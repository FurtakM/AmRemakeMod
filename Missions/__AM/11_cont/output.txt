// starting begin ResetFog ;
   0: CALL_OW 335
// Randomize ;
   4: CALL_OW 10
// InitVariables ;
   8: CALL 87 0 0
// InitMacro ;
  12: CALL 16303 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 29
// FogOff ( 1 ) ;
  22: LD_INT 1
  24: PPUSH
  25: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  29: LD_INT 8
  31: PPUSH
  32: LD_INT 1
  34: PPUSH
  35: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  39: LD_INT 4
  41: PPUSH
  42: LD_INT 3
  44: PPUSH
  45: LD_INT 6
  47: PPUSH
  48: LD_INT 3
  50: PPUSH
  51: LD_INT 2
  53: PPUSH
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 7
  59: PPUSH
  60: LD_INT 18
  62: PPUSH
  63: LD_INT 19
  65: PPUSH
  66: CALL 77908 0 9
// PrepareAmerican ;
  70: CALL 518 0 0
// PrepareArabian ;
  74: CALL 2208 0 0
// MC_Start ( ) ;
  78: CALL 17420 0 0
// Action ;
  82: CALL 7385 0 0
// end ;
  86: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , no_selected , selected ; function InitVariables ; begin
  87: LD_INT 0
  89: PPUSH
// debug := false ;
  90: LD_ADDR_EXP 1
  94: PUSH
  95: LD_INT 0
  97: ST_TO_ADDR
// game := true ;
  98: LD_ADDR_EXP 2
 102: PUSH
 103: LD_INT 1
 105: ST_TO_ADDR
// mission_prefix := 11_ ;
 106: LD_ADDR_EXP 3
 110: PUSH
 111: LD_STRING 11_
 113: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 114: LD_ADDR_EXP 4
 118: PUSH
 119: LD_STRING 10c_
 121: ST_TO_ADDR
// ar_run := false ;
 122: LD_ADDR_EXP 5
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// ar_patrol := false ;
 130: LD_ADDR_EXP 7
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// base_captured := false ;
 138: LD_ADDR_EXP 6
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// us_scout := 0 ;
 146: LD_ADDR_EXP 8
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 154: LD_ADDR_EXP 9
 158: PUSH
 159: LD_INT 0
 161: PUSH
 162: LD_INT 0
 164: PUSH
 165: LD_INT 0
 167: PUSH
 168: LD_INT 0
 170: PUSH
 171: LD_INT 0
 173: PUSH
 174: EMPTY
 175: LIST
 176: LIST
 177: LIST
 178: LIST
 179: LIST
 180: ST_TO_ADDR
// kamikazed := false ;
 181: LD_ADDR_EXP 11
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// artifact_stolen := false ;
 189: LD_ADDR_EXP 12
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// artifact_get := false ;
 197: LD_ADDR_EXP 13
 201: PUSH
 202: LD_INT 0
 204: ST_TO_ADDR
// game_time := [ 90 90$00 , 80 80$00 , 75 75$00 ] [ Difficulty ] ;
 205: LD_ADDR_EXP 15
 209: PUSH
 210: LD_INT 189000
 212: PUSH
 213: LD_INT 168000
 215: PUSH
 216: LD_INT 157500
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: PUSH
 224: LD_OWVAR 67
 228: ARRAY
 229: ST_TO_ADDR
// powell_warn := false ;
 230: LD_ADDR_EXP 16
 234: PUSH
 235: LD_INT 0
 237: ST_TO_ADDR
// loses_counter := 0 ;
 238: LD_ADDR_EXP 17
 242: PUSH
 243: LD_INT 0
 245: ST_TO_ADDR
// artifact_oncargo := false ;
 246: LD_ADDR_EXP 14
 250: PUSH
 251: LD_INT 0
 253: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 254: LD_ADDR_EXP 18
 258: PUSH
 259: LD_STRING 10_GensherEscape_1
 261: PPUSH
 262: LD_EXP 1
 266: PPUSH
 267: CALL_OW 30
 271: ST_TO_ADDR
// can_kamikazed := false ;
 272: LD_ADDR_EXP 10
 276: PUSH
 277: LD_INT 0
 279: ST_TO_ADDR
// end ;
 280: LD_VAR 0 1
 284: RET
// export function CustomInitMacro ; var i ; begin
 285: LD_INT 0
 287: PPUSH
 288: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 289: LD_ADDR_EXP 73
 293: PUSH
 294: LD_INT 20
 296: PUSH
 297: LD_INT 21
 299: PUSH
 300: LD_INT 22
 302: PUSH
 303: EMPTY
 304: LIST
 305: LIST
 306: LIST
 307: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 25
 315: PUSH
 316: LD_INT 24
 318: PUSH
 319: LD_INT 26
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
 327: LD_INT 1
 329: PPUSH
 330: LD_INT 8
 332: PUSH
 333: LD_INT 10
 335: PUSH
 336: LD_INT 12
 338: PUSH
 339: EMPTY
 340: LIST
 341: LIST
 342: LIST
 343: PUSH
 344: LD_OWVAR 67
 348: ARRAY
 349: PPUSH
 350: LD_INT 3
 352: PPUSH
 353: CALL 37677 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 357: LD_INT 2
 359: PPUSH
 360: LD_INT 6
 362: PUSH
 363: LD_INT 8
 365: PUSH
 366: LD_INT 9
 368: PUSH
 369: EMPTY
 370: LIST
 371: LIST
 372: LIST
 373: PUSH
 374: LD_OWVAR 67
 378: ARRAY
 379: PPUSH
 380: LD_INT 2
 382: PPUSH
 383: CALL 37677 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 387: LD_INT 3
 389: PPUSH
 390: LD_INT 6
 392: PUSH
 393: LD_INT 7
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: PUSH
 404: LD_OWVAR 67
 408: ARRAY
 409: PPUSH
 410: LD_INT 1
 412: PPUSH
 413: CALL 37677 0 3
// for i = 1 to mc_bases do
 417: LD_ADDR_VAR 0 2
 421: PUSH
 422: DOUBLE
 423: LD_INT 1
 425: DEC
 426: ST_TO_ADDR
 427: LD_EXP 49
 431: PUSH
 432: FOR_TO
 433: IFFALSE 457
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 435: LD_VAR 0 2
 439: PPUSH
 440: LD_EXP 42
 444: PUSH
 445: LD_VAR 0 2
 449: ARRAY
 450: PPUSH
 451: CALL 38103 0 2
 455: GO 432
 457: POP
 458: POP
// end ;
 459: LD_VAR 0 1
 463: RET
// function Debuger ; var i ; begin
 464: LD_INT 0
 466: PPUSH
 467: PPUSH
// if not debug then
 468: LD_EXP 1
 472: NOT
 473: IFFALSE 477
// exit ;
 475: GO 513
// game_speed := 5 ;
 477: LD_ADDR_OWVAR 65
 481: PUSH
 482: LD_INT 5
 484: ST_TO_ADDR
// uc_side := 1 ;
 485: LD_ADDR_OWVAR 20
 489: PUSH
 490: LD_INT 1
 492: ST_TO_ADDR
// uc_nation := 1 ;
 493: LD_ADDR_OWVAR 21
 497: PUSH
 498: LD_INT 1
 500: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 501: LD_EXP 36
 505: PPUSH
 506: LD_INT 1
 508: PPUSH
 509: CALL_OW 235
// end ; end_of_file
 513: LD_VAR 0 1
 517: RET
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 518: LD_INT 0
 520: PPUSH
 521: PPUSH
 522: PPUSH
 523: PPUSH
 524: PPUSH
 525: PPUSH
 526: PPUSH
 527: PPUSH
// uc_side := 4 ;
 528: LD_ADDR_OWVAR 20
 532: PUSH
 533: LD_INT 4
 535: ST_TO_ADDR
// uc_nation := 1 ;
 536: LD_ADDR_OWVAR 21
 540: PUSH
 541: LD_INT 1
 543: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 544: LD_ADDR_EXP 30
 548: PUSH
 549: LD_STRING Powell
 551: PPUSH
 552: LD_INT 0
 554: PPUSH
 555: LD_STRING 
 557: PPUSH
 558: CALL 43667 0 3
 562: ST_TO_ADDR
// uc_side := 1 ;
 563: LD_ADDR_OWVAR 20
 567: PUSH
 568: LD_INT 1
 570: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 571: LD_ADDR_EXP 21
 575: PUSH
 576: LD_STRING JMM
 578: PPUSH
 579: LD_EXP 1
 583: NOT
 584: PPUSH
 585: LD_EXP 4
 589: PPUSH
 590: CALL 43667 0 3
 594: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 595: LD_EXP 21
 599: PPUSH
 600: CALL_OW 257
 604: PUSH
 605: LD_INT 4
 607: GREATER
 608: IFFALSE 622
// SetClass ( JMM , 1 ) ;
 610: LD_EXP 21
 614: PPUSH
 615: LD_INT 1
 617: PPUSH
 618: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 622: LD_ADDR_EXP 22
 626: PUSH
 627: LD_STRING Lisa
 629: PPUSH
 630: LD_EXP 1
 634: NOT
 635: PPUSH
 636: LD_EXP 4
 640: PPUSH
 641: CALL 43667 0 3
 645: ST_TO_ADDR
// if not Lisa then
 646: LD_EXP 22
 650: NOT
 651: IFFALSE 666
// Lisa := CreateCharacter ( 10_Lisa ) ;
 653: LD_ADDR_EXP 22
 657: PUSH
 658: LD_STRING 10_Lisa
 660: PPUSH
 661: CALL_OW 34
 665: ST_TO_ADDR
// if not Lisa then
 666: LD_EXP 22
 670: NOT
 671: IFFALSE 686
// Lisa := CreateCharacter ( 09_Lisa ) ;
 673: LD_ADDR_EXP 22
 677: PUSH
 678: LD_STRING 09_Lisa
 680: PPUSH
 681: CALL_OW 34
 685: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 686: LD_ADDR_EXP 31
 690: PUSH
 691: LD_STRING Cornel
 693: PPUSH
 694: LD_EXP 1
 698: NOT
 699: PPUSH
 700: LD_EXP 4
 704: PPUSH
 705: CALL 43667 0 3
 709: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 710: LD_ADDR_EXP 23
 714: PUSH
 715: LD_STRING Donaldson
 717: PPUSH
 718: LD_EXP 1
 722: NOT
 723: PPUSH
 724: LD_EXP 4
 728: PPUSH
 729: CALL 43667 0 3
 733: ST_TO_ADDR
// if not Donaldson then
 734: LD_EXP 23
 738: NOT
 739: IFFALSE 754
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 741: LD_ADDR_EXP 23
 745: PUSH
 746: LD_STRING 10_Donaldson
 748: PPUSH
 749: CALL_OW 34
 753: ST_TO_ADDR
// if not Donaldson then
 754: LD_EXP 23
 758: NOT
 759: IFFALSE 774
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 761: LD_ADDR_EXP 23
 765: PUSH
 766: LD_STRING 09_Donaldson
 768: PPUSH
 769: CALL_OW 34
 773: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 774: LD_ADDR_EXP 24
 778: PUSH
 779: LD_STRING Bobby
 781: PPUSH
 782: LD_EXP 1
 786: NOT
 787: PPUSH
 788: LD_EXP 4
 792: PPUSH
 793: CALL 43667 0 3
 797: ST_TO_ADDR
// if not Bobby then
 798: LD_EXP 24
 802: NOT
 803: IFFALSE 818
// Bobby := CreateCharacter ( 10_Bobby ) ;
 805: LD_ADDR_EXP 24
 809: PUSH
 810: LD_STRING 10_Bobby
 812: PPUSH
 813: CALL_OW 34
 817: ST_TO_ADDR
// if not Bobby then
 818: LD_EXP 24
 822: NOT
 823: IFFALSE 838
// Bobby := CreateCharacter ( 09_Bobby ) ;
 825: LD_ADDR_EXP 24
 829: PUSH
 830: LD_STRING 09_Bobby
 832: PPUSH
 833: CALL_OW 34
 837: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 838: LD_ADDR_EXP 25
 842: PUSH
 843: LD_STRING Cyrus
 845: PPUSH
 846: LD_EXP 1
 850: NOT
 851: PPUSH
 852: LD_EXP 4
 856: PPUSH
 857: CALL 43667 0 3
 861: ST_TO_ADDR
// if not Cyrus then
 862: LD_EXP 25
 866: NOT
 867: IFFALSE 882
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 869: LD_ADDR_EXP 25
 873: PUSH
 874: LD_STRING 10_Cyrus
 876: PPUSH
 877: CALL_OW 34
 881: ST_TO_ADDR
// if not Cyrus then
 882: LD_EXP 25
 886: NOT
 887: IFFALSE 902
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
 889: LD_ADDR_EXP 25
 893: PUSH
 894: LD_STRING 09_Cyrus
 896: PPUSH
 897: CALL_OW 34
 901: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
 902: LD_ADDR_EXP 26
 906: PUSH
 907: LD_STRING Denis
 909: PPUSH
 910: LD_EXP 1
 914: NOT
 915: PPUSH
 916: LD_EXP 4
 920: PPUSH
 921: CALL 43667 0 3
 925: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
 926: LD_ADDR_EXP 27
 930: PUSH
 931: LD_STRING Brown
 933: PPUSH
 934: LD_EXP 1
 938: NOT
 939: PPUSH
 940: LD_EXP 4
 944: PPUSH
 945: CALL 43667 0 3
 949: ST_TO_ADDR
// if not Brown then
 950: LD_EXP 27
 954: NOT
 955: IFFALSE 970
// Brown := CreateCharacter ( 10_Brown ) ;
 957: LD_ADDR_EXP 27
 961: PUSH
 962: LD_STRING 10_Brown
 964: PPUSH
 965: CALL_OW 34
 969: ST_TO_ADDR
// if not Brown then
 970: LD_EXP 27
 974: NOT
 975: IFFALSE 990
// Brown := CreateCharacter ( 08_Brown ) ;
 977: LD_ADDR_EXP 27
 981: PUSH
 982: LD_STRING 08_Brown
 984: PPUSH
 985: CALL_OW 34
 989: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
 990: LD_ADDR_EXP 28
 994: PUSH
 995: LD_STRING Gladstone
 997: PPUSH
 998: LD_EXP 1
1002: NOT
1003: PPUSH
1004: LD_EXP 4
1008: PPUSH
1009: CALL 43667 0 3
1013: ST_TO_ADDR
// if not Gladstone then
1014: LD_EXP 28
1018: NOT
1019: IFFALSE 1034
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1021: LD_ADDR_EXP 28
1025: PUSH
1026: LD_STRING 10_Gladstone
1028: PPUSH
1029: CALL_OW 34
1033: ST_TO_ADDR
// if not Gladstone then
1034: LD_EXP 28
1038: NOT
1039: IFFALSE 1054
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1041: LD_ADDR_EXP 28
1045: PUSH
1046: LD_STRING 08_Gladstone
1048: PPUSH
1049: CALL_OW 34
1053: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1054: LD_ADDR_EXP 29
1058: PUSH
1059: LD_STRING Houten
1061: PPUSH
1062: LD_EXP 1
1066: NOT
1067: PPUSH
1068: LD_EXP 4
1072: PPUSH
1073: CALL 43667 0 3
1077: ST_TO_ADDR
// if not Houten then
1078: LD_EXP 29
1082: NOT
1083: IFFALSE 1098
// Houten := CreateCharacter ( 10_Houten ) ;
1085: LD_ADDR_EXP 29
1089: PUSH
1090: LD_STRING 10_Houten
1092: PPUSH
1093: CALL_OW 34
1097: ST_TO_ADDR
// if not Houten then
1098: LD_EXP 29
1102: NOT
1103: IFFALSE 1118
// Houten := CreateCharacter ( 09_Houten ) ;
1105: LD_ADDR_EXP 29
1109: PUSH
1110: LD_STRING 09_Houten
1112: PPUSH
1113: CALL_OW 34
1117: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
1118: LD_ADDR_EXP 31
1122: PUSH
1123: LD_STRING Cornel
1125: PPUSH
1126: LD_EXP 1
1130: NOT
1131: PPUSH
1132: LD_EXP 4
1136: PPUSH
1137: CALL 43667 0 3
1141: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1142: LD_ADDR_EXP 32
1146: PUSH
1147: LD_STRING Gary
1149: PPUSH
1150: LD_EXP 1
1154: NOT
1155: PPUSH
1156: LD_EXP 4
1160: PPUSH
1161: CALL 43667 0 3
1165: ST_TO_ADDR
// if not Gary then
1166: LD_EXP 32
1170: NOT
1171: IFFALSE 1186
// Gary := CreateCharacter ( 10_Gary ) ;
1173: LD_ADDR_EXP 32
1177: PUSH
1178: LD_STRING 10_Gary
1180: PPUSH
1181: CALL_OW 34
1185: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1186: LD_ADDR_EXP 33
1190: PUSH
1191: LD_STRING Frank
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: LD_EXP 4
1204: PPUSH
1205: CALL 43667 0 3
1209: ST_TO_ADDR
// if not Frank then
1210: LD_EXP 33
1214: NOT
1215: IFFALSE 1230
// Frank := CreateCharacter ( 08_Frank ) ;
1217: LD_ADDR_EXP 33
1221: PUSH
1222: LD_STRING 08_Frank
1224: PPUSH
1225: CALL_OW 34
1229: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1230: LD_ADDR_EXP 34
1234: PUSH
1235: LD_STRING Kikuchi
1237: PPUSH
1238: LD_EXP 1
1242: NOT
1243: PPUSH
1244: LD_EXP 4
1248: PPUSH
1249: CALL 43667 0 3
1253: ST_TO_ADDR
// if not Kikuchi then
1254: LD_EXP 34
1258: NOT
1259: IFFALSE 1274
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1261: LD_ADDR_EXP 34
1265: PUSH
1266: LD_STRING 08_Kikuchi
1268: PPUSH
1269: CALL_OW 34
1273: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1274: LD_ADDR_VAR 0 5
1278: PUSH
1279: LD_EXP 22
1283: PUSH
1284: LD_EXP 23
1288: PUSH
1289: LD_EXP 24
1293: PUSH
1294: LD_EXP 25
1298: PUSH
1299: LD_EXP 26
1303: PUSH
1304: LD_EXP 27
1308: PUSH
1309: LD_EXP 28
1313: PUSH
1314: LD_EXP 29
1318: PUSH
1319: LD_EXP 31
1323: PUSH
1324: LD_EXP 32
1328: PUSH
1329: LD_EXP 33
1333: PUSH
1334: LD_EXP 34
1338: PUSH
1339: EMPTY
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: ST_TO_ADDR
// tmp := tmp diff 0 ;
1353: LD_ADDR_VAR 0 5
1357: PUSH
1358: LD_VAR 0 5
1362: PUSH
1363: LD_INT 0
1365: DIFF
1366: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1367: LD_ADDR_VAR 0 5
1371: PUSH
1372: LD_VAR 0 5
1376: PUSH
1377: LD_STRING 10_lock
1379: PPUSH
1380: CALL_OW 31
1384: UNION
1385: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1386: LD_ADDR_VAR 0 5
1390: PUSH
1391: LD_VAR 0 5
1395: PUSH
1396: LD_STRING 10c_lock
1398: PPUSH
1399: CALL_OW 31
1403: UNION
1404: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1405: LD_STRING 10_lock
1407: PPUSH
1408: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1412: LD_STRING 10c_lock
1414: PPUSH
1415: CALL_OW 40
// for i in tmp do
1419: LD_ADDR_VAR 0 2
1423: PUSH
1424: LD_VAR 0 5
1428: PUSH
1429: FOR_IN
1430: IFFALSE 1461
// if GetClass ( i ) = class_mortar then
1432: LD_VAR 0 2
1436: PPUSH
1437: CALL_OW 257
1441: PUSH
1442: LD_INT 8
1444: EQUAL
1445: IFFALSE 1459
// SetClass ( i , class_soldier ) ;
1447: LD_VAR 0 2
1451: PPUSH
1452: LD_INT 1
1454: PPUSH
1455: CALL_OW 336
1459: GO 1429
1461: POP
1462: POP
// if tmp < 12 then
1463: LD_VAR 0 5
1467: PUSH
1468: LD_INT 12
1470: LESS
1471: IFFALSE 1569
// begin k := 16 - tmp ;
1473: LD_ADDR_VAR 0 3
1477: PUSH
1478: LD_INT 16
1480: PUSH
1481: LD_VAR 0 5
1485: MINUS
1486: ST_TO_ADDR
// for i = 1 to k do
1487: LD_ADDR_VAR 0 2
1491: PUSH
1492: DOUBLE
1493: LD_INT 1
1495: DEC
1496: ST_TO_ADDR
1497: LD_VAR 0 3
1501: PUSH
1502: FOR_TO
1503: IFFALSE 1567
// begin PrepareHuman ( false , [ 1 , 1 , 2 , 3 , 4 ] [ rand ( 1 , 5 ) ] , 6 ) ;
1505: LD_INT 0
1507: PPUSH
1508: LD_INT 1
1510: PUSH
1511: LD_INT 1
1513: PUSH
1514: LD_INT 2
1516: PUSH
1517: LD_INT 3
1519: PUSH
1520: LD_INT 4
1522: PUSH
1523: EMPTY
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: PUSH
1530: LD_INT 1
1532: PPUSH
1533: LD_INT 5
1535: PPUSH
1536: CALL_OW 12
1540: ARRAY
1541: PPUSH
1542: LD_INT 6
1544: PPUSH
1545: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1549: LD_ADDR_VAR 0 5
1553: PUSH
1554: LD_VAR 0 5
1558: PUSH
1559: CALL_OW 44
1563: ADD
1564: ST_TO_ADDR
// end ;
1565: GO 1502
1567: POP
1568: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_engineer , 1 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1569: LD_ADDR_EXP 20
1573: PUSH
1574: LD_STRING 1
1576: PPUSH
1577: LD_INT 12
1579: PPUSH
1580: LD_INT 12
1582: PPUSH
1583: LD_INT -5
1585: PUSH
1586: LD_EXP 21
1590: PUSH
1591: LD_INT -2
1593: PUSH
1594: LD_INT -3
1596: PUSH
1597: LD_INT -5
1599: PUSH
1600: EMPTY
1601: LIST
1602: LIST
1603: LIST
1604: LIST
1605: LIST
1606: PUSH
1607: LD_VAR 0 5
1611: ADD
1612: PUSH
1613: LD_INT -6
1615: PUSH
1616: LD_INT -4
1618: PUSH
1619: LD_EXP 30
1623: PUSH
1624: EMPTY
1625: LIST
1626: LIST
1627: LIST
1628: ADD
1629: PPUSH
1630: LD_INT 1
1632: PUSH
1633: LD_INT 4
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: PUSH
1640: LD_INT 2
1642: PUSH
1643: LD_INT 1
1645: PUSH
1646: EMPTY
1647: LIST
1648: LIST
1649: PUSH
1650: LD_INT 3
1652: PUSH
1653: LD_INT 0
1655: PUSH
1656: LD_INT 5
1658: PUSH
1659: EMPTY
1660: LIST
1661: LIST
1662: LIST
1663: PUSH
1664: LD_INT 4
1666: PUSH
1667: LD_INT 0
1669: PUSH
1670: LD_INT 3
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: PUSH
1678: LD_INT 5
1680: PUSH
1681: LD_INT 0
1683: PUSH
1684: LD_INT 2
1686: PUSH
1687: EMPTY
1688: LIST
1689: LIST
1690: LIST
1691: PUSH
1692: EMPTY
1693: LIST
1694: LIST
1695: LIST
1696: LIST
1697: LIST
1698: PPUSH
1699: CALL_OW 42
1703: ST_TO_ADDR
// others := tmp diff selected ;
1704: LD_ADDR_VAR 0 8
1708: PUSH
1709: LD_VAR 0 5
1713: PUSH
1714: LD_EXP 20
1718: DIFF
1719: ST_TO_ADDR
// others := tmp diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1720: LD_ADDR_VAR 0 8
1724: PUSH
1725: LD_VAR 0 5
1729: PUSH
1730: LD_EXP 22
1734: PUSH
1735: LD_EXP 23
1739: PUSH
1740: LD_EXP 24
1744: PUSH
1745: LD_EXP 25
1749: PUSH
1750: LD_EXP 26
1754: PUSH
1755: LD_EXP 27
1759: PUSH
1760: LD_EXP 28
1764: PUSH
1765: LD_EXP 29
1769: PUSH
1770: LD_EXP 31
1774: PUSH
1775: LD_EXP 32
1779: PUSH
1780: LD_EXP 33
1784: PUSH
1785: LD_EXP 34
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: LIST
1796: LIST
1797: LIST
1798: LIST
1799: LIST
1800: LIST
1801: LIST
1802: LIST
1803: DIFF
1804: ST_TO_ADDR
// no_selected := others ;
1805: LD_ADDR_EXP 19
1809: PUSH
1810: LD_VAR 0 8
1814: ST_TO_ADDR
// if no_selected then
1815: LD_EXP 19
1819: IFFALSE 1833
// SaveCharacters ( no_selected , 11_others ) ;
1821: LD_EXP 19
1825: PPUSH
1826: LD_STRING 11_others
1828: PPUSH
1829: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1833: LD_ADDR_VAR 0 6
1837: PUSH
1838: LD_INT 3
1840: PUSH
1841: LD_INT 1
1843: PUSH
1844: LD_INT 1
1846: PUSH
1847: LD_INT 4
1849: PUSH
1850: EMPTY
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: PUSH
1856: LD_INT 2
1858: PUSH
1859: LD_INT 2
1861: PUSH
1862: LD_INT 1
1864: PUSH
1865: LD_INT 5
1867: PUSH
1868: EMPTY
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: PUSH
1874: LD_INT 4
1876: PUSH
1877: LD_INT 1
1879: PUSH
1880: LD_INT 1
1882: PUSH
1883: LD_INT 5
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: PUSH
1892: LD_INT 2
1894: PUSH
1895: LD_INT 1
1897: PUSH
1898: LD_INT 1
1900: PUSH
1901: LD_INT 7
1903: PUSH
1904: EMPTY
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: PUSH
1910: LD_INT 3
1912: PUSH
1913: LD_INT 2
1915: PUSH
1916: LD_INT 1
1918: PUSH
1919: LD_INT 7
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: PUSH
1928: EMPTY
1929: LIST
1930: LIST
1931: LIST
1932: LIST
1933: LIST
1934: ST_TO_ADDR
// for i in JMM ^ selected do
1935: LD_ADDR_VAR 0 2
1939: PUSH
1940: LD_EXP 21
1944: PUSH
1945: LD_EXP 20
1949: ADD
1950: PUSH
1951: FOR_IN
1952: IFFALSE 2141
// begin if GetClass ( i ) = 3 then
1954: LD_VAR 0 2
1958: PPUSH
1959: CALL_OW 257
1963: PUSH
1964: LD_INT 3
1966: EQUAL
1967: IFFALSE 2124
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
1969: LD_ADDR_OWVAR 37
1973: PUSH
1974: LD_VAR 0 6
1978: PUSH
1979: LD_INT 1
1981: ARRAY
1982: PUSH
1983: LD_INT 1
1985: ARRAY
1986: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
1987: LD_ADDR_OWVAR 39
1991: PUSH
1992: LD_VAR 0 6
1996: PUSH
1997: LD_INT 1
1999: ARRAY
2000: PUSH
2001: LD_INT 2
2003: ARRAY
2004: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2005: LD_ADDR_OWVAR 38
2009: PUSH
2010: LD_VAR 0 6
2014: PUSH
2015: LD_INT 1
2017: ARRAY
2018: PUSH
2019: LD_INT 3
2021: ARRAY
2022: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2023: LD_ADDR_OWVAR 40
2027: PUSH
2028: LD_VAR 0 6
2032: PUSH
2033: LD_INT 1
2035: ARRAY
2036: PUSH
2037: LD_INT 4
2039: ARRAY
2040: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2041: LD_ADDR_VAR 0 6
2045: PUSH
2046: LD_VAR 0 6
2050: PPUSH
2051: LD_INT 1
2053: PPUSH
2054: CALL_OW 3
2058: ST_TO_ADDR
// veh := CreateVehicle ;
2059: LD_ADDR_VAR 0 7
2063: PUSH
2064: CALL_OW 45
2068: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2069: LD_VAR 0 7
2073: PPUSH
2074: LD_INT 8
2076: PPUSH
2077: LD_INT 0
2079: PPUSH
2080: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2084: LD_VAR 0 2
2088: PPUSH
2089: LD_VAR 0 7
2093: PPUSH
2094: CALL_OW 52
// if i = JMM then
2098: LD_VAR 0 2
2102: PUSH
2103: LD_EXP 21
2107: EQUAL
2108: IFFALSE 2122
// SetMark ( veh , 1 ) ;
2110: LD_VAR 0 7
2114: PPUSH
2115: LD_INT 1
2117: PPUSH
2118: CALL_OW 242
// end else
2122: GO 2139
// PlaceUnitArea ( i , am_hum_start , false ) ;
2124: LD_VAR 0 2
2128: PPUSH
2129: LD_INT 9
2131: PPUSH
2132: LD_INT 0
2134: PPUSH
2135: CALL_OW 49
// end ;
2139: GO 1951
2141: POP
2142: POP
// vc_chassis := us_medium_tracked ;
2143: LD_ADDR_OWVAR 37
2147: PUSH
2148: LD_INT 3
2150: ST_TO_ADDR
// vc_engine := engine_solar ;
2151: LD_ADDR_OWVAR 39
2155: PUSH
2156: LD_INT 2
2158: ST_TO_ADDR
// vc_control := control_computer ;
2159: LD_ADDR_OWVAR 38
2163: PUSH
2164: LD_INT 3
2166: ST_TO_ADDR
// vc_weapon := us_radar ;
2167: LD_ADDR_OWVAR 40
2171: PUSH
2172: LD_INT 11
2174: ST_TO_ADDR
// veh := CreateVehicle ;
2175: LD_ADDR_VAR 0 7
2179: PUSH
2180: CALL_OW 45
2184: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2185: LD_VAR 0 7
2189: PPUSH
2190: LD_INT 87
2192: PPUSH
2193: LD_INT 142
2195: PPUSH
2196: LD_INT 0
2198: PPUSH
2199: CALL_OW 48
// end ; end_of_file
2203: LD_VAR 0 1
2207: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill ; begin
2208: LD_INT 0
2210: PPUSH
2211: PPUSH
2212: PPUSH
2213: PPUSH
2214: PPUSH
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
2215: LD_ADDR_VAR 0 5
2219: PUSH
2220: LD_INT 6
2222: PUSH
2223: LD_INT 7
2225: PUSH
2226: LD_INT 8
2228: PUSH
2229: EMPTY
2230: LIST
2231: LIST
2232: LIST
2233: PUSH
2234: LD_OWVAR 67
2238: ARRAY
2239: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
2240: LD_INT 69
2242: PUSH
2243: EMPTY
2244: LIST
2245: PPUSH
2246: LD_INT 141
2248: PPUSH
2249: CALL_OW 169
// Wait ( 1 ) ;
2253: LD_INT 1
2255: PPUSH
2256: CALL_OW 67
// uc_side := 2 ;
2260: LD_ADDR_OWVAR 20
2264: PUSH
2265: LD_INT 2
2267: ST_TO_ADDR
// uc_nation := 2 ;
2268: LD_ADDR_OWVAR 21
2272: PUSH
2273: LD_INT 2
2275: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2276: LD_ADDR_OWVAR 37
2280: PUSH
2281: LD_INT 14
2283: ST_TO_ADDR
// vc_engine := engine_siberite ;
2284: LD_ADDR_OWVAR 39
2288: PUSH
2289: LD_INT 3
2291: ST_TO_ADDR
// vc_control := control_manual ;
2292: LD_ADDR_OWVAR 38
2296: PUSH
2297: LD_INT 1
2299: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2300: LD_ADDR_OWVAR 40
2304: PUSH
2305: LD_INT 31
2307: ST_TO_ADDR
// for i = 1 to 3 do
2308: LD_ADDR_VAR 0 2
2312: PUSH
2313: DOUBLE
2314: LD_INT 1
2316: DEC
2317: ST_TO_ADDR
2318: LD_INT 3
2320: PUSH
2321: FOR_TO
2322: IFFALSE 2406
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2324: LD_INT 0
2326: PPUSH
2327: LD_INT 3
2329: PPUSH
2330: LD_VAR 0 5
2334: PPUSH
2335: CALL_OW 380
// un := CreateVehicle ;
2339: LD_ADDR_VAR 0 4
2343: PUSH
2344: CALL_OW 45
2348: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2349: LD_VAR 0 4
2353: PPUSH
2354: LD_INT 0
2356: PPUSH
2357: LD_INT 5
2359: PPUSH
2360: CALL_OW 12
2364: PPUSH
2365: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2369: LD_VAR 0 4
2373: PPUSH
2374: LD_INT 156
2376: PPUSH
2377: LD_INT 15
2379: PPUSH
2380: LD_INT 6
2382: PPUSH
2383: LD_INT 0
2385: PPUSH
2386: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2390: CALL_OW 44
2394: PPUSH
2395: LD_VAR 0 4
2399: PPUSH
2400: CALL_OW 52
// end ;
2404: GO 2321
2406: POP
2407: POP
// ar_force_north := PrepareBase ( ar_dep_n , dammam , skill , [ 10000 , 1000 , 300 ] , [ - 1 , 5 , - 1 , 4 ] ) ;
2408: LD_ADDR_EXP 37
2412: PUSH
2413: LD_INT 94
2415: PPUSH
2416: LD_STRING dammam
2418: PPUSH
2419: LD_VAR 0 5
2423: PPUSH
2424: LD_INT 10000
2426: PUSH
2427: LD_INT 1000
2429: PUSH
2430: LD_INT 300
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: LIST
2437: PPUSH
2438: LD_INT 1
2440: NEG
2441: PUSH
2442: LD_INT 5
2444: PUSH
2445: LD_INT 1
2447: NEG
2448: PUSH
2449: LD_INT 4
2451: PUSH
2452: EMPTY
2453: LIST
2454: LIST
2455: LIST
2456: LIST
2457: PPUSH
2458: CALL 53729 0 5
2462: ST_TO_ADDR
// ar_force_north := ar_force_north ^ PrepareBase ( ar_dep_n2 ,  , skill , [ 100 , 60 , 0 ] , [ - 1 , 4 , 0 , 0 ] ) ;
2463: LD_ADDR_EXP 37
2467: PUSH
2468: LD_EXP 37
2472: PUSH
2473: LD_INT 122
2475: PPUSH
2476: LD_STRING 
2478: PPUSH
2479: LD_VAR 0 5
2483: PPUSH
2484: LD_INT 100
2486: PUSH
2487: LD_INT 60
2489: PUSH
2490: LD_INT 0
2492: PUSH
2493: EMPTY
2494: LIST
2495: LIST
2496: LIST
2497: PPUSH
2498: LD_INT 1
2500: NEG
2501: PUSH
2502: LD_INT 4
2504: PUSH
2505: LD_INT 0
2507: PUSH
2508: LD_INT 0
2510: PUSH
2511: EMPTY
2512: LIST
2513: LIST
2514: LIST
2515: LIST
2516: PPUSH
2517: CALL 53729 0 5
2521: ADD
2522: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , jeddah , skill , [ 700 , 300 , 10 ] , [ - 1 , 5 , 3 , 2 ] ) ;
2523: LD_ADDR_EXP 35
2527: PUSH
2528: LD_INT 45
2530: PPUSH
2531: LD_STRING jeddah
2533: PPUSH
2534: LD_VAR 0 5
2538: PPUSH
2539: LD_INT 700
2541: PUSH
2542: LD_INT 300
2544: PUSH
2545: LD_INT 10
2547: PUSH
2548: EMPTY
2549: LIST
2550: LIST
2551: LIST
2552: PPUSH
2553: LD_INT 1
2555: NEG
2556: PUSH
2557: LD_INT 5
2559: PUSH
2560: LD_INT 3
2562: PUSH
2563: LD_INT 2
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: LIST
2570: LIST
2571: PPUSH
2572: CALL 53729 0 5
2576: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
2577: LD_ADDR_EXP 36
2581: PUSH
2582: LD_INT 7
2584: PPUSH
2585: LD_STRING riyadh
2587: PPUSH
2588: LD_VAR 0 5
2592: PPUSH
2593: LD_INT 500
2595: PUSH
2596: LD_INT 60
2598: PUSH
2599: LD_INT 0
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: LIST
2606: PPUSH
2607: LD_INT 4
2609: PUSH
2610: LD_INT 2
2612: PUSH
2613: LD_INT 3
2615: PUSH
2616: LD_INT 1
2618: PUSH
2619: EMPTY
2620: LIST
2621: LIST
2622: LIST
2623: LIST
2624: PPUSH
2625: CALL 53729 0 5
2629: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e ,  , skill , [ 500 , 50 , 0 ] , [ - 1 , 3 , 3 , 2 ] ) ;
2630: LD_ADDR_EXP 38
2634: PUSH
2635: LD_INT 69
2637: PPUSH
2638: LD_STRING 
2640: PPUSH
2641: LD_VAR 0 5
2645: PPUSH
2646: LD_INT 500
2648: PUSH
2649: LD_INT 50
2651: PUSH
2652: LD_INT 0
2654: PUSH
2655: EMPTY
2656: LIST
2657: LIST
2658: LIST
2659: PPUSH
2660: LD_INT 1
2662: NEG
2663: PUSH
2664: LD_INT 3
2666: PUSH
2667: LD_INT 3
2669: PUSH
2670: LD_INT 2
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: LIST
2677: LIST
2678: PPUSH
2679: CALL 53729 0 5
2683: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
2684: LD_ADDR_EXP 49
2688: PUSH
2689: LD_EXP 37
2693: PUSH
2694: LD_EXP 35
2698: PUSH
2699: LD_EXP 38
2703: PUSH
2704: EMPTY
2705: LIST
2706: LIST
2707: LIST
2708: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
2709: LD_ADDR_VAR 0 2
2713: PUSH
2714: LD_INT 22
2716: PUSH
2717: LD_INT 2
2719: PUSH
2720: EMPTY
2721: LIST
2722: LIST
2723: PUSH
2724: LD_INT 30
2726: PUSH
2727: LD_INT 31
2729: PUSH
2730: EMPTY
2731: LIST
2732: LIST
2733: PUSH
2734: LD_INT 58
2736: PUSH
2737: EMPTY
2738: LIST
2739: PUSH
2740: EMPTY
2741: LIST
2742: LIST
2743: LIST
2744: PPUSH
2745: CALL_OW 69
2749: PUSH
2750: FOR_IN
2751: IFFALSE 2876
// begin if GetBase ( i ) then
2753: LD_VAR 0 2
2757: PPUSH
2758: CALL_OW 274
2762: IFFALSE 2766
// continue ;
2764: GO 2750
// d := GetDir ( i ) ;
2766: LD_ADDR_VAR 0 3
2770: PUSH
2771: LD_VAR 0 2
2775: PPUSH
2776: CALL_OW 254
2780: ST_TO_ADDR
// if d < 3 then
2781: LD_VAR 0 3
2785: PUSH
2786: LD_INT 3
2788: LESS
2789: IFFALSE 2807
// d := d + 3 else
2791: LD_ADDR_VAR 0 3
2795: PUSH
2796: LD_VAR 0 3
2800: PUSH
2801: LD_INT 3
2803: PLUS
2804: ST_TO_ADDR
2805: GO 2821
// d := d - 3 ;
2807: LD_ADDR_VAR 0 3
2811: PUSH
2812: LD_VAR 0 3
2816: PUSH
2817: LD_INT 3
2819: MINUS
2820: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
2821: LD_INT 0
2823: PPUSH
2824: LD_INT 8
2826: PPUSH
2827: LD_VAR 0 5
2831: PPUSH
2832: CALL_OW 380
// un := CreateHuman ;
2836: LD_ADDR_VAR 0 4
2840: PUSH
2841: CALL_OW 44
2845: ST_TO_ADDR
// SetDir ( un , d ) ;
2846: LD_VAR 0 4
2850: PPUSH
2851: LD_VAR 0 3
2855: PPUSH
2856: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
2860: LD_VAR 0 4
2864: PPUSH
2865: LD_VAR 0 2
2869: PPUSH
2870: CALL_OW 52
// end ;
2874: GO 2750
2876: POP
2877: POP
// if Difficulty > 1 then
2878: LD_OWVAR 67
2882: PUSH
2883: LD_INT 1
2885: GREATER
2886: IFFALSE 3257
// begin ar_kamikadze := [ ] ;
2888: LD_ADDR_EXP 41
2892: PUSH
2893: EMPTY
2894: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
2895: LD_INT 0
2897: PPUSH
2898: LD_INT 1
2900: PPUSH
2901: LD_VAR 0 5
2905: PPUSH
2906: CALL_OW 380
// un := CreateHuman ;
2910: LD_ADDR_VAR 0 4
2914: PUSH
2915: CALL_OW 44
2919: ST_TO_ADDR
// SetDir ( un , 3 ) ;
2920: LD_VAR 0 4
2924: PPUSH
2925: LD_INT 3
2927: PPUSH
2928: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
2932: LD_VAR 0 4
2936: PPUSH
2937: LD_INT 23
2939: PPUSH
2940: LD_INT 44
2942: PPUSH
2943: LD_INT 0
2945: PPUSH
2946: CALL_OW 48
// ComCrawl ( un ) ;
2950: LD_VAR 0 4
2954: PPUSH
2955: CALL_OW 137
// un := CreateHuman ;
2959: LD_ADDR_VAR 0 4
2963: PUSH
2964: CALL_OW 44
2968: ST_TO_ADDR
// SetDir ( un , 3 ) ;
2969: LD_VAR 0 4
2973: PPUSH
2974: LD_INT 3
2976: PPUSH
2977: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
2981: LD_VAR 0 4
2985: PPUSH
2986: LD_INT 30
2988: PPUSH
2989: LD_INT 39
2991: PPUSH
2992: LD_INT 0
2994: PPUSH
2995: CALL_OW 48
// ComCrawl ( un ) ;
2999: LD_VAR 0 4
3003: PPUSH
3004: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3008: LD_INT 0
3010: PPUSH
3011: LD_INT 17
3013: PPUSH
3014: LD_VAR 0 5
3018: PPUSH
3019: CALL_OW 380
// un := CreateHuman ;
3023: LD_ADDR_VAR 0 4
3027: PUSH
3028: CALL_OW 44
3032: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3033: LD_VAR 0 4
3037: PPUSH
3038: LD_INT 3
3040: PPUSH
3041: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3045: LD_VAR 0 4
3049: PPUSH
3050: LD_INT 45
3052: PPUSH
3053: LD_INT 86
3055: PPUSH
3056: LD_INT 0
3058: PPUSH
3059: CALL_OW 48
// ComHold ( un ) ;
3063: LD_VAR 0 4
3067: PPUSH
3068: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3072: LD_ADDR_EXP 41
3076: PUSH
3077: LD_EXP 41
3081: PPUSH
3082: LD_EXP 41
3086: PUSH
3087: LD_INT 1
3089: PLUS
3090: PPUSH
3091: LD_VAR 0 4
3095: PPUSH
3096: CALL_OW 1
3100: ST_TO_ADDR
// un := CreateHuman ;
3101: LD_ADDR_VAR 0 4
3105: PUSH
3106: CALL_OW 44
3110: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3111: LD_VAR 0 4
3115: PPUSH
3116: LD_INT 3
3118: PPUSH
3119: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3123: LD_VAR 0 4
3127: PPUSH
3128: LD_INT 60
3130: PPUSH
3131: LD_INT 85
3133: PPUSH
3134: LD_INT 0
3136: PPUSH
3137: CALL_OW 48
// ComHold ( un ) ;
3141: LD_VAR 0 4
3145: PPUSH
3146: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3150: LD_ADDR_EXP 41
3154: PUSH
3155: LD_EXP 41
3159: PPUSH
3160: LD_EXP 41
3164: PUSH
3165: LD_INT 1
3167: PLUS
3168: PPUSH
3169: LD_VAR 0 4
3173: PPUSH
3174: CALL_OW 1
3178: ST_TO_ADDR
// un := CreateHuman ;
3179: LD_ADDR_VAR 0 4
3183: PUSH
3184: CALL_OW 44
3188: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3189: LD_VAR 0 4
3193: PPUSH
3194: LD_INT 3
3196: PPUSH
3197: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3201: LD_VAR 0 4
3205: PPUSH
3206: LD_INT 222
3208: PPUSH
3209: LD_INT 166
3211: PPUSH
3212: LD_INT 0
3214: PPUSH
3215: CALL_OW 48
// ComHold ( un ) ;
3219: LD_VAR 0 4
3223: PPUSH
3224: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3228: LD_ADDR_EXP 41
3232: PUSH
3233: LD_EXP 41
3237: PPUSH
3238: LD_EXP 41
3242: PUSH
3243: LD_INT 1
3245: PLUS
3246: PPUSH
3247: LD_VAR 0 4
3251: PPUSH
3252: CALL_OW 1
3256: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3257: LD_ADDR_EXP 39
3261: PUSH
3262: EMPTY
3263: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3264: LD_INT 1
3266: PPUSH
3267: LD_INT 1
3269: PPUSH
3270: LD_VAR 0 5
3274: PPUSH
3275: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3279: LD_ADDR_OWVAR 26
3283: PUSH
3284: LD_STRING Pavel Grigorovic
3286: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3287: LD_ADDR_OWVAR 33
3291: PUSH
3292: LD_STRING SecondCharsGal
3294: ST_TO_ADDR
// hc_face_number := 4 ;
3295: LD_ADDR_OWVAR 34
3299: PUSH
3300: LD_INT 4
3302: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3303: LD_ADDR_EXP 39
3307: PUSH
3308: LD_EXP 39
3312: PPUSH
3313: LD_INT 1
3315: PPUSH
3316: CALL_OW 44
3320: PPUSH
3321: CALL_OW 1
3325: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3326: LD_INT 2
3328: PPUSH
3329: LD_INT 4
3331: PPUSH
3332: LD_VAR 0 5
3336: PPUSH
3337: CALL_OW 380
// hc_name := Lucy Sebel ;
3341: LD_ADDR_OWVAR 26
3345: PUSH
3346: LD_STRING Lucy Sebel
3348: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3349: LD_ADDR_OWVAR 33
3353: PUSH
3354: LD_STRING SecondCharsGal
3356: ST_TO_ADDR
// hc_face_number := 15 ;
3357: LD_ADDR_OWVAR 34
3361: PUSH
3362: LD_INT 15
3364: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3365: LD_ADDR_EXP 39
3369: PUSH
3370: LD_EXP 39
3374: PPUSH
3375: LD_INT 2
3377: PPUSH
3378: CALL_OW 44
3382: PPUSH
3383: CALL_OW 1
3387: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3388: LD_INT 2
3390: PPUSH
3391: LD_INT 4
3393: PPUSH
3394: LD_VAR 0 5
3398: PPUSH
3399: CALL_OW 380
// hc_gallery :=  ;
3403: LD_ADDR_OWVAR 33
3407: PUSH
3408: LD_STRING 
3410: ST_TO_ADDR
// hc_name :=  ;
3411: LD_ADDR_OWVAR 26
3415: PUSH
3416: LD_STRING 
3418: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3419: LD_ADDR_EXP 39
3423: PUSH
3424: LD_EXP 39
3428: PPUSH
3429: LD_INT 3
3431: PPUSH
3432: CALL_OW 44
3436: PPUSH
3437: CALL_OW 1
3441: ST_TO_ADDR
// hc_sex := sex_male ;
3442: LD_ADDR_OWVAR 27
3446: PUSH
3447: LD_INT 1
3449: ST_TO_ADDR
// hc_class = 11 ;
3450: LD_ADDR_OWVAR 28
3454: PUSH
3455: LD_INT 11
3457: ST_TO_ADDR
// hc_gallery = sandar ;
3458: LD_ADDR_OWVAR 33
3462: PUSH
3463: LD_STRING sandar
3465: ST_TO_ADDR
// hc_face_number = 33 ;
3466: LD_ADDR_OWVAR 34
3470: PUSH
3471: LD_INT 33
3473: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
3474: LD_ADDR_OWVAR 26
3478: PUSH
3479: LD_STRING Thabit Muhair Saliba
3481: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
3482: LD_ADDR_OWVAR 31
3486: PUSH
3487: LD_INT 0
3489: PUSH
3490: LD_INT 0
3492: PUSH
3493: LD_INT 0
3495: PUSH
3496: LD_INT 0
3498: PUSH
3499: EMPTY
3500: LIST
3501: LIST
3502: LIST
3503: LIST
3504: ST_TO_ADDR
// Saliba = CreateHuman ;
3505: LD_ADDR_EXP 43
3509: PUSH
3510: CALL_OW 44
3514: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
3515: LD_EXP 43
3519: PPUSH
3520: LD_INT 7
3522: PPUSH
3523: CALL_OW 52
// if gensher_active then
3527: LD_EXP 18
3531: IFFALSE 3558
// begin Gensher = NewCharacter ( Dietrich ) ;
3533: LD_ADDR_EXP 44
3537: PUSH
3538: LD_STRING Dietrich
3540: PPUSH
3541: CALL_OW 25
3545: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
3546: LD_EXP 44
3550: PPUSH
3551: LD_INT 94
3553: PPUSH
3554: CALL_OW 52
// end ; InitHc ;
3558: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
3562: LD_ADDR_EXP 40
3566: PUSH
3567: EMPTY
3568: ST_TO_ADDR
// for i = 1 to 4 do
3569: LD_ADDR_VAR 0 2
3573: PUSH
3574: DOUBLE
3575: LD_INT 1
3577: DEC
3578: ST_TO_ADDR
3579: LD_INT 4
3581: PUSH
3582: FOR_TO
3583: IFFALSE 3755
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
3585: LD_INT 13
3587: PUSH
3588: LD_INT 14
3590: PUSH
3591: EMPTY
3592: LIST
3593: LIST
3594: PUSH
3595: LD_INT 1
3597: PPUSH
3598: LD_INT 2
3600: PPUSH
3601: CALL_OW 12
3605: ARRAY
3606: PPUSH
3607: LD_INT 1
3609: PUSH
3610: LD_INT 2
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PUSH
3617: LD_INT 1
3619: PPUSH
3620: LD_INT 2
3622: PPUSH
3623: CALL_OW 12
3627: ARRAY
3628: PPUSH
3629: LD_INT 1
3631: PPUSH
3632: LD_INT 25
3634: PUSH
3635: LD_INT 27
3637: PUSH
3638: LD_INT 26
3640: PUSH
3641: EMPTY
3642: LIST
3643: LIST
3644: LIST
3645: PUSH
3646: LD_INT 1
3648: PPUSH
3649: LD_INT 3
3651: PPUSH
3652: CALL_OW 12
3656: ARRAY
3657: PPUSH
3658: LD_INT 60
3660: PPUSH
3661: LD_INT 100
3663: PPUSH
3664: CALL_OW 12
3668: PPUSH
3669: CALL 50300 0 5
// un := CreateVehicle ;
3673: LD_ADDR_VAR 0 4
3677: PUSH
3678: CALL_OW 45
3682: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
3683: LD_ADDR_EXP 40
3687: PUSH
3688: LD_EXP 40
3692: PPUSH
3693: LD_EXP 40
3697: PUSH
3698: LD_INT 1
3700: PLUS
3701: PPUSH
3702: LD_VAR 0 4
3706: PPUSH
3707: CALL_OW 1
3711: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3712: LD_VAR 0 4
3716: PPUSH
3717: LD_INT 0
3719: PPUSH
3720: LD_INT 5
3722: PPUSH
3723: CALL_OW 12
3727: PPUSH
3728: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 6 , false ) ;
3732: LD_VAR 0 4
3736: PPUSH
3737: LD_INT 124
3739: PPUSH
3740: LD_INT 141
3742: PPUSH
3743: LD_INT 6
3745: PPUSH
3746: LD_INT 0
3748: PPUSH
3749: CALL_OW 50
// end ;
3753: GO 3582
3755: POP
3756: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
3757: LD_ADDR_EXP 42
3761: PUSH
3762: EMPTY
3763: PUSH
3764: EMPTY
3765: PUSH
3766: EMPTY
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: LIST
3772: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
3773: LD_ADDR_VAR 0 3
3777: PUSH
3778: DOUBLE
3779: LD_INT 1
3781: DEC
3782: ST_TO_ADDR
3783: LD_INT 3
3785: PUSH
3786: LD_INT 3
3788: PUSH
3789: LD_INT 4
3791: PUSH
3792: EMPTY
3793: LIST
3794: LIST
3795: LIST
3796: PUSH
3797: LD_OWVAR 67
3801: ARRAY
3802: PUSH
3803: FOR_TO
3804: IFFALSE 4018
// for i = 1 to 3 do
3806: LD_ADDR_VAR 0 2
3810: PUSH
3811: DOUBLE
3812: LD_INT 1
3814: DEC
3815: ST_TO_ADDR
3816: LD_INT 3
3818: PUSH
3819: FOR_TO
3820: IFFALSE 4014
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
3822: LD_INT 14
3824: PPUSH
3825: LD_INT 3
3827: PUSH
3828: LD_INT 2
3830: PUSH
3831: EMPTY
3832: LIST
3833: LIST
3834: PUSH
3835: LD_INT 1
3837: PPUSH
3838: LD_INT 2
3840: PPUSH
3841: CALL_OW 12
3845: ARRAY
3846: PPUSH
3847: LD_INT 1
3849: PUSH
3850: LD_INT 5
3852: PUSH
3853: EMPTY
3854: LIST
3855: LIST
3856: PUSH
3857: LD_INT 1
3859: PPUSH
3860: LD_INT 2
3862: PPUSH
3863: CALL_OW 12
3867: ARRAY
3868: PPUSH
3869: LD_INT 25
3871: PUSH
3872: LD_INT 27
3874: PUSH
3875: LD_INT 26
3877: PUSH
3878: LD_INT 28
3880: PUSH
3881: EMPTY
3882: LIST
3883: LIST
3884: LIST
3885: LIST
3886: PUSH
3887: LD_INT 1
3889: PPUSH
3890: LD_INT 4
3892: PPUSH
3893: CALL_OW 12
3897: ARRAY
3898: PPUSH
3899: LD_INT 100
3901: PPUSH
3902: CALL 50300 0 5
// un := CreateVehicle ;
3906: LD_ADDR_VAR 0 4
3910: PUSH
3911: CALL_OW 45
3915: ST_TO_ADDR
// ar_defenders_tmp := Add ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
3916: LD_ADDR_EXP 42
3920: PUSH
3921: LD_EXP 42
3925: PPUSH
3926: LD_VAR 0 2
3930: PUSH
3931: LD_EXP 42
3935: PUSH
3936: LD_VAR 0 2
3940: ARRAY
3941: PUSH
3942: LD_INT 1
3944: PLUS
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: PPUSH
3950: LD_VAR 0 4
3954: PPUSH
3955: CALL 50857 0 3
3959: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3960: LD_VAR 0 4
3964: PPUSH
3965: LD_INT 0
3967: PPUSH
3968: LD_INT 5
3970: PPUSH
3971: CALL_OW 12
3975: PPUSH
3976: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
3980: LD_VAR 0 4
3984: PPUSH
3985: LD_INT 20
3987: PUSH
3988: LD_INT 21
3990: PUSH
3991: LD_INT 22
3993: PUSH
3994: EMPTY
3995: LIST
3996: LIST
3997: LIST
3998: PUSH
3999: LD_VAR 0 2
4003: ARRAY
4004: PPUSH
4005: LD_INT 0
4007: PPUSH
4008: CALL_OW 49
// end ;
4012: GO 3819
4014: POP
4015: POP
4016: GO 3803
4018: POP
4019: POP
// InitHc ;
4020: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4024: LD_INT 4
4026: PPUSH
4027: LD_INT 5
4029: PPUSH
4030: LD_INT 10
4032: PPUSH
4033: LD_INT 5
4035: PPUSH
4036: LD_INT 0
4038: PPUSH
4039: CALL_OW 58
// end ;
4043: LD_VAR 0 1
4047: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4048: LD_EXP 41
4052: IFFALSE 4126
4054: GO 4056
4056: DISABLE
4057: LD_INT 0
4059: PPUSH
// begin enable ;
4060: ENABLE
// for i in ar_kamikadze do
4061: LD_ADDR_VAR 0 1
4065: PUSH
4066: LD_EXP 41
4070: PUSH
4071: FOR_IN
4072: IFFALSE 4124
// if See ( 1 , i ) then
4074: LD_INT 1
4076: PPUSH
4077: LD_VAR 0 1
4081: PPUSH
4082: CALL_OW 292
4086: IFFALSE 4122
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4088: LD_VAR 0 1
4092: PPUSH
4093: LD_INT 81
4095: PUSH
4096: LD_INT 2
4098: PUSH
4099: EMPTY
4100: LIST
4101: LIST
4102: PPUSH
4103: CALL_OW 69
4107: PPUSH
4108: LD_VAR 0 1
4112: PPUSH
4113: CALL_OW 74
4117: PPUSH
4118: CALL_OW 115
4122: GO 4071
4124: POP
4125: POP
// end ;
4126: PPOPN 1
4128: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4129: LD_EXP 13
4133: IFFALSE 4450
4135: GO 4137
4137: DISABLE
4138: LD_INT 0
4140: PPUSH
4141: PPUSH
4142: PPUSH
4143: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4144: LD_INT 35
4146: PPUSH
4147: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4151: LD_INT 1
4153: PPUSH
4154: CALL 38449 0 1
4158: PUSH
4159: LD_INT 0
4161: EQUAL
4162: IFFALSE 4144
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4164: LD_INT 1
4166: PPUSH
4167: LD_INT 14
4169: PUSH
4170: LD_INT 3
4172: PUSH
4173: LD_INT 2
4175: PUSH
4176: LD_INT 32
4178: PUSH
4179: EMPTY
4180: LIST
4181: LIST
4182: LIST
4183: LIST
4184: PUSH
4185: EMPTY
4186: LIST
4187: PPUSH
4188: CALL 37995 0 2
// repeat wait ( 0 0$1 ) ;
4192: LD_INT 35
4194: PPUSH
4195: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4199: LD_EXP 68
4203: PUSH
4204: LD_INT 1
4206: ARRAY
4207: PPUSH
4208: LD_INT 33
4210: PUSH
4211: LD_INT 2
4213: PUSH
4214: EMPTY
4215: LIST
4216: LIST
4217: PUSH
4218: LD_INT 34
4220: PUSH
4221: LD_INT 32
4223: PUSH
4224: EMPTY
4225: LIST
4226: LIST
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PPUSH
4232: CALL_OW 72
4236: IFFALSE 4192
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4238: LD_ADDR_VAR 0 2
4242: PUSH
4243: LD_EXP 68
4247: PUSH
4248: LD_INT 1
4250: ARRAY
4251: PPUSH
4252: LD_INT 33
4254: PUSH
4255: LD_INT 2
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: PUSH
4262: LD_INT 34
4264: PUSH
4265: LD_INT 32
4267: PUSH
4268: EMPTY
4269: LIST
4270: LIST
4271: PUSH
4272: EMPTY
4273: LIST
4274: LIST
4275: PPUSH
4276: CALL_OW 72
4280: PUSH
4281: LD_INT 1
4283: ARRAY
4284: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4285: LD_ADDR_VAR 0 4
4289: PUSH
4290: LD_INT 5
4292: PPUSH
4293: CALL_OW 469
4297: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4298: LD_INT 35
4300: PPUSH
4301: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4305: LD_ADDR_VAR 0 4
4309: PUSH
4310: LD_INT 5
4312: PPUSH
4313: CALL_OW 469
4317: ST_TO_ADDR
// tmp := 100 ;
4318: LD_ADDR_VAR 0 3
4322: PUSH
4323: LD_INT 100
4325: ST_TO_ADDR
// if pos then
4326: LD_VAR 0 4
4330: IFFALSE 4370
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4332: LD_ADDR_VAR 0 3
4336: PUSH
4337: LD_INT 2
4339: PPUSH
4340: LD_VAR 0 4
4344: PUSH
4345: LD_INT 1
4347: ARRAY
4348: PPUSH
4349: LD_VAR 0 4
4353: PUSH
4354: LD_INT 2
4356: ARRAY
4357: PPUSH
4358: LD_INT 20
4360: PPUSH
4361: CALL 51351 0 4
4365: PUSH
4366: LD_INT 4
4368: ARRAY
4369: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4370: LD_VAR 0 4
4374: PUSH
4375: LD_EXP 14
4379: NOT
4380: AND
4381: PUSH
4382: LD_VAR 0 3
4386: PUSH
4387: LD_INT 10
4389: LESS
4390: AND
4391: IFFALSE 4298
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4393: LD_VAR 0 2
4397: PPUSH
4398: LD_VAR 0 4
4402: PUSH
4403: LD_INT 1
4405: ARRAY
4406: PPUSH
4407: LD_VAR 0 4
4411: PUSH
4412: LD_INT 2
4414: ARRAY
4415: PPUSH
4416: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4420: LD_VAR 0 2
4424: PPUSH
4425: LD_INT 198
4427: PPUSH
4428: LD_INT 113
4430: PPUSH
4431: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
4435: LD_VAR 0 2
4439: PPUSH
4440: LD_INT 124
4442: PPUSH
4443: LD_INT 7
4445: PPUSH
4446: CALL_OW 171
// end ;
4450: PPOPN 4
4452: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
4453: LD_EXP 6
4457: IFFALSE 7002
4459: GO 4461
4461: DISABLE
4462: LD_INT 0
4464: PPUSH
4465: PPUSH
4466: PPUSH
4467: PPUSH
4468: PPUSH
4469: PPUSH
4470: PPUSH
4471: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4472: LD_ADDR_VAR 0 4
4476: PUSH
4477: LD_INT 5
4479: PUSH
4480: LD_INT 6
4482: PUSH
4483: LD_INT 7
4485: PUSH
4486: EMPTY
4487: LIST
4488: LIST
4489: LIST
4490: PUSH
4491: LD_OWVAR 67
4495: ARRAY
4496: ST_TO_ADDR
// coords := [ ] ;
4497: LD_ADDR_VAR 0 5
4501: PUSH
4502: EMPTY
4503: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
4504: LD_ADDR_VAR 0 6
4508: PUSH
4509: LD_INT 0
4511: PUSH
4512: LD_INT 0
4514: PUSH
4515: LD_INT 0
4517: PUSH
4518: LD_INT 0
4520: PUSH
4521: LD_INT 1
4523: PUSH
4524: LD_INT 0
4526: PUSH
4527: LD_INT 0
4529: PUSH
4530: LD_INT 0
4532: PUSH
4533: LD_INT 1
4535: PUSH
4536: LD_INT 0
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: LIST
4543: LIST
4544: LIST
4545: LIST
4546: LIST
4547: LIST
4548: LIST
4549: LIST
4550: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
4551: LD_INT 1
4553: PPUSH
4554: LD_INT 14
4556: PUSH
4557: LD_INT 1
4559: PUSH
4560: LD_INT 2
4562: PUSH
4563: LD_INT 28
4565: PUSH
4566: EMPTY
4567: LIST
4568: LIST
4569: LIST
4570: LIST
4571: PUSH
4572: LD_INT 14
4574: PUSH
4575: LD_INT 1
4577: PUSH
4578: LD_INT 2
4580: PUSH
4581: LD_INT 25
4583: PUSH
4584: EMPTY
4585: LIST
4586: LIST
4587: LIST
4588: LIST
4589: PUSH
4590: LD_INT 14
4592: PUSH
4593: LD_INT 1
4595: PUSH
4596: LD_INT 2
4598: PUSH
4599: LD_INT 28
4601: PUSH
4602: EMPTY
4603: LIST
4604: LIST
4605: LIST
4606: LIST
4607: PUSH
4608: LD_INT 14
4610: PUSH
4611: LD_INT 1
4613: PUSH
4614: LD_INT 2
4616: PUSH
4617: LD_INT 29
4619: PUSH
4620: EMPTY
4621: LIST
4622: LIST
4623: LIST
4624: LIST
4625: PUSH
4626: EMPTY
4627: LIST
4628: LIST
4629: LIST
4630: LIST
4631: PPUSH
4632: CALL 37995 0 2
// wait ( [ 10 10$00 , 9 9$20 , 9 9$00 ] [ Difficulty ] ) ;
4636: LD_INT 21000
4638: PUSH
4639: LD_INT 19600
4641: PUSH
4642: LD_INT 18900
4644: PUSH
4645: EMPTY
4646: LIST
4647: LIST
4648: LIST
4649: PUSH
4650: LD_OWVAR 67
4654: ARRAY
4655: PPUSH
4656: CALL_OW 67
// InitHc ;
4660: CALL_OW 19
// InitUc ;
4664: CALL_OW 18
// uc_side := 2 ;
4668: LD_ADDR_OWVAR 20
4672: PUSH
4673: LD_INT 2
4675: ST_TO_ADDR
// uc_nation := 2 ;
4676: LD_ADDR_OWVAR 21
4680: PUSH
4681: LD_INT 2
4683: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
4684: LD_ADDR_VAR 0 3
4688: PUSH
4689: EMPTY
4690: PUSH
4691: EMPTY
4692: PUSH
4693: EMPTY
4694: PUSH
4695: EMPTY
4696: PUSH
4697: EMPTY
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: LIST
4703: LIST
4704: LIST
4705: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_weapon , ar_cargo_bay ] ) ) ;
4706: LD_ADDR_VAR 0 3
4710: PUSH
4711: LD_VAR 0 3
4715: PPUSH
4716: LD_INT 1
4718: PPUSH
4719: LD_EXP 68
4723: PUSH
4724: LD_INT 1
4726: ARRAY
4727: PUSH
4728: LD_INT 34
4730: PUSH
4731: LD_INT 32
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: PPUSH
4738: CALL_OW 69
4742: DIFF
4743: PPUSH
4744: CALL_OW 1
4748: ST_TO_ADDR
// for i = 1 to Difficulty do
4749: LD_ADDR_VAR 0 1
4753: PUSH
4754: DOUBLE
4755: LD_INT 1
4757: DEC
4758: ST_TO_ADDR
4759: LD_OWVAR 67
4763: PUSH
4764: FOR_TO
4765: IFFALSE 4887
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
4767: LD_INT 13
4769: PPUSH
4770: LD_INT 3
4772: PPUSH
4773: LD_INT 5
4775: PPUSH
4776: LD_INT 29
4778: PPUSH
4779: LD_INT 100
4781: PPUSH
4782: CALL 50300 0 5
// un := CreateVehicle ;
4786: LD_ADDR_VAR 0 2
4790: PUSH
4791: CALL_OW 45
4795: ST_TO_ADDR
// tmp := Add ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
4796: LD_ADDR_VAR 0 3
4800: PUSH
4801: LD_VAR 0 3
4805: PPUSH
4806: LD_INT 1
4808: PUSH
4809: LD_VAR 0 3
4813: PUSH
4814: LD_INT 1
4816: ARRAY
4817: PUSH
4818: LD_INT 1
4820: PLUS
4821: PUSH
4822: EMPTY
4823: LIST
4824: LIST
4825: PPUSH
4826: LD_VAR 0 2
4830: PPUSH
4831: CALL 50857 0 3
4835: ST_TO_ADDR
// SetDir ( un , 3 ) ;
4836: LD_VAR 0 2
4840: PPUSH
4841: LD_INT 3
4843: PPUSH
4844: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
4848: LD_VAR 0 2
4852: PPUSH
4853: LD_INT 16
4855: PPUSH
4856: LD_INT 0
4858: PPUSH
4859: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
4863: LD_VAR 0 2
4867: PPUSH
4868: LD_INT 51
4870: PPUSH
4871: LD_INT 10
4873: PPUSH
4874: CALL_OW 111
// wait ( 0 0$2 ) ;
4878: LD_INT 70
4880: PPUSH
4881: CALL_OW 67
// end ;
4885: GO 4764
4887: POP
4888: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
4889: LD_ADDR_VAR 0 5
4893: PUSH
4894: LD_INT 51
4896: PUSH
4897: LD_INT 24
4899: PUSH
4900: EMPTY
4901: LIST
4902: LIST
4903: PUSH
4904: LD_INT 75
4906: PUSH
4907: LD_INT 90
4909: PUSH
4910: EMPTY
4911: LIST
4912: LIST
4913: PUSH
4914: EMPTY
4915: LIST
4916: LIST
4917: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
4918: LD_INT 1
4920: PPUSH
4921: LD_VAR 0 3
4925: PUSH
4926: LD_INT 1
4928: ARRAY
4929: PPUSH
4930: LD_VAR 0 5
4934: PPUSH
4935: LD_VAR 0 6
4939: PPUSH
4940: CALL 38286 0 4
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
4944: LD_ADDR_VAR 0 1
4948: PUSH
4949: DOUBLE
4950: LD_INT 1
4952: DEC
4953: ST_TO_ADDR
4954: LD_INT 2
4956: PUSH
4957: LD_INT 3
4959: PUSH
4960: LD_INT 3
4962: PUSH
4963: EMPTY
4964: LIST
4965: LIST
4966: LIST
4967: PUSH
4968: LD_OWVAR 67
4972: ARRAY
4973: PUSH
4974: FOR_TO
4975: IFFALSE 5059
// begin PrepareHuman ( false , 17 , skill ) ;
4977: LD_INT 0
4979: PPUSH
4980: LD_INT 17
4982: PPUSH
4983: LD_VAR 0 4
4987: PPUSH
4988: CALL_OW 380
// un := CreateHuman ;
4992: LD_ADDR_VAR 0 2
4996: PUSH
4997: CALL_OW 44
5001: ST_TO_ADDR
// tmp := Add ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5002: LD_ADDR_VAR 0 3
5006: PUSH
5007: LD_VAR 0 3
5011: PPUSH
5012: LD_INT 2
5014: PUSH
5015: LD_VAR 0 3
5019: PUSH
5020: LD_INT 2
5022: ARRAY
5023: PUSH
5024: LD_INT 1
5026: PLUS
5027: PUSH
5028: EMPTY
5029: LIST
5030: LIST
5031: PPUSH
5032: LD_VAR 0 2
5036: PPUSH
5037: CALL 50857 0 3
5041: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5042: LD_VAR 0 2
5046: PPUSH
5047: LD_INT 13
5049: PPUSH
5050: LD_INT 0
5052: PPUSH
5053: CALL_OW 49
// end ;
5057: GO 4974
5059: POP
5060: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
5061: LD_ADDR_VAR 0 1
5065: PUSH
5066: DOUBLE
5067: LD_INT 1
5069: DEC
5070: ST_TO_ADDR
5071: LD_INT 2
5073: PUSH
5074: LD_INT 3
5076: PUSH
5077: LD_INT 3
5079: PUSH
5080: EMPTY
5081: LIST
5082: LIST
5083: LIST
5084: PUSH
5085: LD_OWVAR 67
5089: ARRAY
5090: PUSH
5091: FOR_TO
5092: IFFALSE 5195
// begin PrepareHuman ( false , [ 1 , 8 ] [ rand ( 1 , 2 ) ] , skill ) ;
5094: LD_INT 0
5096: PPUSH
5097: LD_INT 1
5099: PUSH
5100: LD_INT 8
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 1
5109: PPUSH
5110: LD_INT 2
5112: PPUSH
5113: CALL_OW 12
5117: ARRAY
5118: PPUSH
5119: LD_VAR 0 4
5123: PPUSH
5124: CALL_OW 380
// un := CreateHuman ;
5128: LD_ADDR_VAR 0 2
5132: PUSH
5133: CALL_OW 44
5137: ST_TO_ADDR
// tmp := Add ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5138: LD_ADDR_VAR 0 3
5142: PUSH
5143: LD_VAR 0 3
5147: PPUSH
5148: LD_INT 2
5150: PUSH
5151: LD_VAR 0 3
5155: PUSH
5156: LD_INT 2
5158: ARRAY
5159: PUSH
5160: LD_INT 1
5162: PLUS
5163: PUSH
5164: EMPTY
5165: LIST
5166: LIST
5167: PPUSH
5168: LD_VAR 0 2
5172: PPUSH
5173: CALL 50857 0 3
5177: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5178: LD_VAR 0 2
5182: PPUSH
5183: LD_INT 13
5185: PPUSH
5186: LD_INT 0
5188: PPUSH
5189: CALL_OW 49
// end ;
5193: GO 5091
5195: POP
5196: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5197: LD_ADDR_VAR 0 5
5201: PUSH
5202: LD_INT 67
5204: PUSH
5205: LD_INT 112
5207: PUSH
5208: EMPTY
5209: LIST
5210: LIST
5211: PUSH
5212: LD_INT 85
5214: PUSH
5215: LD_INT 130
5217: PUSH
5218: EMPTY
5219: LIST
5220: LIST
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5226: LD_INT 2
5228: PPUSH
5229: LD_VAR 0 3
5233: PUSH
5234: LD_INT 2
5236: ARRAY
5237: PPUSH
5238: LD_VAR 0 5
5242: PPUSH
5243: LD_VAR 0 6
5247: PPUSH
5248: CALL 38286 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5252: LD_ADDR_VAR 0 1
5256: PUSH
5257: DOUBLE
5258: LD_INT 1
5260: DEC
5261: ST_TO_ADDR
5262: LD_INT 1
5264: PUSH
5265: LD_INT 2
5267: PUSH
5268: LD_INT 3
5270: PUSH
5271: EMPTY
5272: LIST
5273: LIST
5274: LIST
5275: PUSH
5276: LD_OWVAR 67
5280: ARRAY
5281: PUSH
5282: FOR_TO
5283: IFFALSE 5367
// begin PrepareHuman ( false , 17 , skill ) ;
5285: LD_INT 0
5287: PPUSH
5288: LD_INT 17
5290: PPUSH
5291: LD_VAR 0 4
5295: PPUSH
5296: CALL_OW 380
// un := CreateHuman ;
5300: LD_ADDR_VAR 0 2
5304: PUSH
5305: CALL_OW 44
5309: ST_TO_ADDR
// tmp := Add ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5310: LD_ADDR_VAR 0 3
5314: PUSH
5315: LD_VAR 0 3
5319: PPUSH
5320: LD_INT 3
5322: PUSH
5323: LD_VAR 0 3
5327: PUSH
5328: LD_INT 3
5330: ARRAY
5331: PUSH
5332: LD_INT 1
5334: PLUS
5335: PUSH
5336: EMPTY
5337: LIST
5338: LIST
5339: PPUSH
5340: LD_VAR 0 2
5344: PPUSH
5345: CALL 50857 0 3
5349: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5350: LD_VAR 0 2
5354: PPUSH
5355: LD_INT 14
5357: PPUSH
5358: LD_INT 0
5360: PPUSH
5361: CALL_OW 49
// end ;
5365: GO 5282
5367: POP
5368: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
5369: LD_ADDR_VAR 0 5
5373: PUSH
5374: LD_INT 148
5376: PUSH
5377: LD_INT 158
5379: PUSH
5380: EMPTY
5381: LIST
5382: LIST
5383: PUSH
5384: LD_INT 148
5386: PUSH
5387: LD_INT 158
5389: PUSH
5390: EMPTY
5391: LIST
5392: LIST
5393: PUSH
5394: EMPTY
5395: LIST
5396: LIST
5397: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
5398: LD_INT 3
5400: PPUSH
5401: LD_VAR 0 3
5405: PUSH
5406: LD_INT 3
5408: ARRAY
5409: PPUSH
5410: LD_VAR 0 5
5414: PPUSH
5415: LD_VAR 0 6
5419: PPUSH
5420: CALL 38286 0 4
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
5424: LD_ADDR_VAR 0 1
5428: PUSH
5429: DOUBLE
5430: LD_INT 1
5432: DEC
5433: ST_TO_ADDR
5434: LD_INT 3
5436: PUSH
5437: LD_INT 4
5439: PUSH
5440: LD_INT 4
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: LIST
5447: PUSH
5448: LD_OWVAR 67
5452: ARRAY
5453: PUSH
5454: FOR_TO
5455: IFFALSE 5663
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
5457: LD_INT 14
5459: PPUSH
5460: LD_INT 3
5462: PPUSH
5463: LD_INT 1
5465: PUSH
5466: LD_INT 5
5468: PUSH
5469: EMPTY
5470: LIST
5471: LIST
5472: PUSH
5473: LD_INT 1
5475: PPUSH
5476: LD_INT 2
5478: PPUSH
5479: CALL_OW 12
5483: ARRAY
5484: PPUSH
5485: LD_INT 27
5487: PUSH
5488: LD_INT 26
5490: PUSH
5491: LD_INT 28
5493: PUSH
5494: EMPTY
5495: LIST
5496: LIST
5497: LIST
5498: PUSH
5499: LD_INT 1
5501: PPUSH
5502: LD_INT 3
5504: PPUSH
5505: CALL_OW 12
5509: ARRAY
5510: PPUSH
5511: LD_INT 100
5513: PPUSH
5514: CALL 50300 0 5
// un := CreateVehicle ;
5518: LD_ADDR_VAR 0 2
5522: PUSH
5523: CALL_OW 45
5527: ST_TO_ADDR
// tmp := Add ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
5528: LD_ADDR_VAR 0 3
5532: PUSH
5533: LD_VAR 0 3
5537: PPUSH
5538: LD_INT 4
5540: PUSH
5541: LD_VAR 0 3
5545: PUSH
5546: LD_INT 4
5548: ARRAY
5549: PUSH
5550: LD_INT 1
5552: PLUS
5553: PUSH
5554: EMPTY
5555: LIST
5556: LIST
5557: PPUSH
5558: LD_VAR 0 2
5562: PPUSH
5563: CALL 50857 0 3
5567: ST_TO_ADDR
// SetDir ( un , 5 ) ;
5568: LD_VAR 0 2
5572: PPUSH
5573: LD_INT 5
5575: PPUSH
5576: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
5580: LD_VAR 0 2
5584: PPUSH
5585: LD_INT 15
5587: PPUSH
5588: LD_INT 0
5590: PPUSH
5591: CALL_OW 49
// if GetControl ( un ) = control_manual then
5595: LD_VAR 0 2
5599: PPUSH
5600: CALL_OW 263
5604: PUSH
5605: LD_INT 1
5607: EQUAL
5608: IFFALSE 5639
// begin PrepareHuman ( false , 3 , skill ) ;
5610: LD_INT 0
5612: PPUSH
5613: LD_INT 3
5615: PPUSH
5616: LD_VAR 0 4
5620: PPUSH
5621: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5625: CALL_OW 44
5629: PPUSH
5630: LD_VAR 0 2
5634: PPUSH
5635: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
5639: LD_VAR 0 2
5643: PPUSH
5644: LD_INT 179
5646: PPUSH
5647: LD_INT 135
5649: PPUSH
5650: CALL_OW 111
// wait ( 0 0$2 ) ;
5654: LD_INT 70
5656: PPUSH
5657: CALL_OW 67
// end ;
5661: GO 5454
5663: POP
5664: POP
// vc_chassis := 15 ;
5665: LD_ADDR_OWVAR 37
5669: PUSH
5670: LD_INT 15
5672: ST_TO_ADDR
// tmp := Add ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
5673: LD_ADDR_VAR 0 3
5677: PUSH
5678: LD_VAR 0 3
5682: PPUSH
5683: LD_INT 4
5685: PUSH
5686: LD_VAR 0 3
5690: PUSH
5691: LD_INT 4
5693: ARRAY
5694: PUSH
5695: LD_INT 1
5697: PLUS
5698: PUSH
5699: EMPTY
5700: LIST
5701: LIST
5702: PPUSH
5703: CALL_OW 45
5707: PPUSH
5708: CALL 50857 0 3
5712: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
5713: LD_VAR 0 3
5717: PUSH
5718: LD_INT 4
5720: ARRAY
5721: PUSH
5722: LD_VAR 0 3
5726: PUSH
5727: LD_INT 4
5729: ARRAY
5730: ARRAY
5731: PPUSH
5732: LD_INT 15
5734: PPUSH
5735: LD_INT 0
5737: PPUSH
5738: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
5742: LD_INT 0
5744: PPUSH
5745: LD_INT 11
5747: PPUSH
5748: LD_VAR 0 4
5752: PPUSH
5753: CALL_OW 380
// tmp := Add ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
5757: LD_ADDR_VAR 0 3
5761: PUSH
5762: LD_VAR 0 3
5766: PPUSH
5767: LD_INT 4
5769: PUSH
5770: LD_VAR 0 3
5774: PUSH
5775: LD_INT 4
5777: ARRAY
5778: PUSH
5779: LD_INT 1
5781: PLUS
5782: PUSH
5783: EMPTY
5784: LIST
5785: LIST
5786: PPUSH
5787: CALL_OW 44
5791: PPUSH
5792: CALL 50857 0 3
5796: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
5797: LD_VAR 0 3
5801: PUSH
5802: LD_INT 4
5804: ARRAY
5805: PUSH
5806: LD_VAR 0 3
5810: PUSH
5811: LD_INT 4
5813: ARRAY
5814: ARRAY
5815: PPUSH
5816: LD_VAR 0 3
5820: PUSH
5821: LD_INT 4
5823: ARRAY
5824: PUSH
5825: LD_VAR 0 3
5829: PUSH
5830: LD_INT 4
5832: ARRAY
5833: PUSH
5834: LD_INT 1
5836: MINUS
5837: ARRAY
5838: PPUSH
5839: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
5843: LD_ADDR_VAR 0 5
5847: PUSH
5848: LD_INT 148
5850: PUSH
5851: LD_INT 140
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: PUSH
5858: EMPTY
5859: LIST
5860: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
5861: LD_INT 1
5863: PPUSH
5864: LD_VAR 0 3
5868: PUSH
5869: LD_INT 4
5871: ARRAY
5872: PPUSH
5873: LD_VAR 0 5
5877: PPUSH
5878: LD_VAR 0 6
5882: PPUSH
5883: CALL 38286 0 4
// if gensher_active then
5887: LD_EXP 18
5891: IFFALSE 6244
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
5893: LD_EXP 44
5897: PPUSH
5898: LD_STRING D10-Diet-1
5900: PPUSH
5901: CALL_OW 94
// for i = 1 to 2 do
5905: LD_ADDR_VAR 0 1
5909: PUSH
5910: DOUBLE
5911: LD_INT 1
5913: DEC
5914: ST_TO_ADDR
5915: LD_INT 2
5917: PUSH
5918: FOR_TO
5919: IFFALSE 6041
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5921: LD_INT 13
5923: PPUSH
5924: LD_INT 3
5926: PPUSH
5927: LD_INT 5
5929: PPUSH
5930: LD_INT 29
5932: PPUSH
5933: LD_INT 100
5935: PPUSH
5936: CALL 50300 0 5
// un := CreateVehicle ;
5940: LD_ADDR_VAR 0 2
5944: PUSH
5945: CALL_OW 45
5949: ST_TO_ADDR
// tmp := Add ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
5950: LD_ADDR_VAR 0 3
5954: PUSH
5955: LD_VAR 0 3
5959: PPUSH
5960: LD_INT 5
5962: PUSH
5963: LD_VAR 0 3
5967: PUSH
5968: LD_INT 5
5970: ARRAY
5971: PUSH
5972: LD_INT 1
5974: PLUS
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: PPUSH
5980: LD_VAR 0 2
5984: PPUSH
5985: CALL 50857 0 3
5989: ST_TO_ADDR
// SetDir ( un , 0 ) ;
5990: LD_VAR 0 2
5994: PPUSH
5995: LD_INT 0
5997: PPUSH
5998: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6002: LD_VAR 0 2
6006: PPUSH
6007: LD_INT 23
6009: PPUSH
6010: LD_INT 0
6012: PPUSH
6013: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6017: LD_VAR 0 2
6021: PPUSH
6022: LD_INT 85
6024: PPUSH
6025: LD_INT 152
6027: PPUSH
6028: CALL_OW 111
// wait ( 0 0$2 ) ;
6032: LD_INT 70
6034: PPUSH
6035: CALL_OW 67
// end ;
6039: GO 5918
6041: POP
6042: POP
// for i = 1 to 3 do
6043: LD_ADDR_VAR 0 1
6047: PUSH
6048: DOUBLE
6049: LD_INT 1
6051: DEC
6052: ST_TO_ADDR
6053: LD_INT 3
6055: PUSH
6056: FOR_TO
6057: IFFALSE 6198
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6059: LD_INT 14
6061: PPUSH
6062: LD_INT 3
6064: PPUSH
6065: LD_INT 5
6067: PPUSH
6068: LD_INT 27
6070: PUSH
6071: LD_INT 28
6073: PUSH
6074: EMPTY
6075: LIST
6076: LIST
6077: PUSH
6078: LD_INT 1
6080: PPUSH
6081: LD_INT 2
6083: PPUSH
6084: CALL_OW 12
6088: ARRAY
6089: PPUSH
6090: LD_INT 100
6092: PPUSH
6093: CALL 50300 0 5
// un := CreateVehicle ;
6097: LD_ADDR_VAR 0 2
6101: PUSH
6102: CALL_OW 45
6106: ST_TO_ADDR
// tmp := Add ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6107: LD_ADDR_VAR 0 3
6111: PUSH
6112: LD_VAR 0 3
6116: PPUSH
6117: LD_INT 5
6119: PUSH
6120: LD_VAR 0 3
6124: PUSH
6125: LD_INT 5
6127: ARRAY
6128: PUSH
6129: LD_INT 1
6131: PLUS
6132: PUSH
6133: EMPTY
6134: LIST
6135: LIST
6136: PPUSH
6137: LD_VAR 0 2
6141: PPUSH
6142: CALL 50857 0 3
6146: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6147: LD_VAR 0 2
6151: PPUSH
6152: LD_INT 0
6154: PPUSH
6155: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6159: LD_VAR 0 2
6163: PPUSH
6164: LD_INT 23
6166: PPUSH
6167: LD_INT 0
6169: PPUSH
6170: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6174: LD_VAR 0 2
6178: PPUSH
6179: LD_INT 85
6181: PPUSH
6182: LD_INT 152
6184: PPUSH
6185: CALL_OW 111
// wait ( 0 0$2 ) ;
6189: LD_INT 70
6191: PPUSH
6192: CALL_OW 67
// end ;
6196: GO 6056
6198: POP
6199: POP
// coords := [ [ 97 , 143 ] ] ;
6200: LD_ADDR_VAR 0 5
6204: PUSH
6205: LD_INT 97
6207: PUSH
6208: LD_INT 143
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: PUSH
6215: EMPTY
6216: LIST
6217: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6218: LD_INT 1
6220: PPUSH
6221: LD_VAR 0 3
6225: PUSH
6226: LD_INT 5
6228: ARRAY
6229: PPUSH
6230: LD_VAR 0 5
6234: PPUSH
6235: LD_VAR 0 6
6239: PPUSH
6240: CALL 38286 0 4
// end ; Wait ( 10 10$00 ) ;
6244: LD_INT 21000
6246: PPUSH
6247: CALL_OW 67
// tmp := [ ] ;
6251: LD_ADDR_VAR 0 3
6255: PUSH
6256: EMPTY
6257: ST_TO_ADDR
// w := 1 ;
6258: LD_ADDR_VAR 0 7
6262: PUSH
6263: LD_INT 1
6265: ST_TO_ADDR
// repeat tmp := [ ] ;
6266: LD_ADDR_VAR 0 3
6270: PUSH
6271: EMPTY
6272: ST_TO_ADDR
// if w mod 4 = 0 then
6273: LD_VAR 0 7
6277: PUSH
6278: LD_INT 4
6280: MOD
6281: PUSH
6282: LD_INT 0
6284: EQUAL
6285: IFFALSE 6372
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6287: LD_ADDR_VAR 0 8
6291: PUSH
6292: LD_INT 11
6294: PUSH
6295: LD_INT 1
6297: PUSH
6298: LD_INT 2
6300: PUSH
6301: LD_INT 24
6303: PUSH
6304: EMPTY
6305: LIST
6306: LIST
6307: LIST
6308: LIST
6309: PUSH
6310: LD_INT 11
6312: PUSH
6313: LD_INT 1
6315: PUSH
6316: LD_INT 2
6318: PUSH
6319: LD_INT 24
6321: PUSH
6322: EMPTY
6323: LIST
6324: LIST
6325: LIST
6326: LIST
6327: PUSH
6328: LD_INT 11
6330: PUSH
6331: LD_INT 1
6333: PUSH
6334: LD_INT 2
6336: PUSH
6337: LD_INT 24
6339: PUSH
6340: EMPTY
6341: LIST
6342: LIST
6343: LIST
6344: LIST
6345: PUSH
6346: LD_INT 11
6348: PUSH
6349: LD_INT 1
6351: PUSH
6352: LD_INT 2
6354: PUSH
6355: LD_INT 24
6357: PUSH
6358: EMPTY
6359: LIST
6360: LIST
6361: LIST
6362: LIST
6363: PUSH
6364: EMPTY
6365: LIST
6366: LIST
6367: LIST
6368: LIST
6369: ST_TO_ADDR
6370: GO 6474
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
6372: LD_ADDR_VAR 0 8
6376: PUSH
6377: LD_INT 14
6379: PUSH
6380: LD_INT 1
6382: PUSH
6383: LD_INT 2
6385: PUSH
6386: LD_INT 28
6388: PUSH
6389: EMPTY
6390: LIST
6391: LIST
6392: LIST
6393: LIST
6394: PUSH
6395: LD_INT 14
6397: PUSH
6398: LD_INT 1
6400: PUSH
6401: LD_INT 2
6403: PUSH
6404: LD_INT 25
6406: PUSH
6407: EMPTY
6408: LIST
6409: LIST
6410: LIST
6411: LIST
6412: PUSH
6413: LD_INT 14
6415: PUSH
6416: LD_INT 1
6418: PUSH
6419: LD_INT 2
6421: PUSH
6422: LD_INT 28
6424: PUSH
6425: EMPTY
6426: LIST
6427: LIST
6428: LIST
6429: LIST
6430: PUSH
6431: LD_INT 14
6433: PUSH
6434: LD_INT 1
6436: PUSH
6437: LD_INT 2
6439: PUSH
6440: LD_INT 29
6442: PUSH
6443: EMPTY
6444: LIST
6445: LIST
6446: LIST
6447: LIST
6448: PUSH
6449: LD_INT 11
6451: PUSH
6452: LD_INT 1
6454: PUSH
6455: LD_INT 2
6457: PUSH
6458: LD_INT 24
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: LIST
6465: LIST
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: LIST
6471: LIST
6472: LIST
6473: ST_TO_ADDR
// if w mod 3 = 0 then
6474: LD_VAR 0 7
6478: PUSH
6479: LD_INT 3
6481: MOD
6482: PUSH
6483: LD_INT 0
6485: EQUAL
6486: IFFALSE 6562
// list := Add ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
6488: LD_ADDR_VAR 0 8
6492: PUSH
6493: LD_VAR 0 8
6497: PPUSH
6498: LD_INT 1
6500: PUSH
6501: LD_VAR 0 8
6505: PUSH
6506: LD_VAR 0 1
6510: ARRAY
6511: PUSH
6512: LD_INT 1
6514: PLUS
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: PPUSH
6520: LD_INT 14
6522: PUSH
6523: LD_INT 1
6525: PUSH
6526: LD_INT 2
6528: PUSH
6529: LD_INT 25
6531: PUSH
6532: LD_INT 28
6534: PUSH
6535: EMPTY
6536: LIST
6537: LIST
6538: PUSH
6539: LD_INT 1
6541: PPUSH
6542: LD_INT 2
6544: PPUSH
6545: CALL_OW 12
6549: ARRAY
6550: PUSH
6551: EMPTY
6552: LIST
6553: LIST
6554: LIST
6555: LIST
6556: PPUSH
6557: CALL 50857 0 3
6561: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
6562: LD_INT 1
6564: PPUSH
6565: LD_VAR 0 8
6569: PPUSH
6570: CALL 37995 0 2
// if GetSide ( ar_dep_w ) = 2 then
6574: LD_INT 45
6576: PPUSH
6577: CALL_OW 255
6581: PUSH
6582: LD_INT 2
6584: EQUAL
6585: IFFALSE 6670
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
6587: LD_ADDR_VAR 0 8
6591: PUSH
6592: LD_INT 14
6594: PUSH
6595: LD_INT 1
6597: PUSH
6598: LD_INT 2
6600: PUSH
6601: LD_INT 28
6603: PUSH
6604: EMPTY
6605: LIST
6606: LIST
6607: LIST
6608: LIST
6609: PUSH
6610: LD_INT 14
6612: PUSH
6613: LD_INT 1
6615: PUSH
6616: LD_INT 2
6618: PUSH
6619: LD_INT 27
6621: PUSH
6622: EMPTY
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: PUSH
6628: LD_INT 14
6630: PUSH
6631: LD_INT 1
6633: PUSH
6634: LD_INT 2
6636: PUSH
6637: LD_INT 27
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: LIST
6644: LIST
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: LIST
6650: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
6651: LD_INT 2
6653: PPUSH
6654: LD_VAR 0 8
6658: PPUSH
6659: CALL 37995 0 2
// wait ( 0 0$50 ) ;
6663: LD_INT 1750
6665: PPUSH
6666: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
6670: LD_INT 35
6672: PPUSH
6673: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) >= 4 ;
6677: LD_EXP 68
6681: PUSH
6682: LD_INT 1
6684: ARRAY
6685: PPUSH
6686: LD_INT 3
6688: PUSH
6689: LD_INT 34
6691: PUSH
6692: LD_INT 32
6694: PUSH
6695: EMPTY
6696: LIST
6697: LIST
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: PPUSH
6703: CALL_OW 72
6707: PUSH
6708: LD_INT 4
6710: GREATEREQUAL
6711: IFFALSE 6670
// wait ( 0 0$10 ) ;
6713: LD_INT 350
6715: PPUSH
6716: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) ;
6720: LD_ADDR_VAR 0 3
6724: PUSH
6725: LD_EXP 68
6729: PUSH
6730: LD_INT 1
6732: ARRAY
6733: PPUSH
6734: LD_INT 3
6736: PUSH
6737: LD_INT 34
6739: PUSH
6740: LD_INT 32
6742: PUSH
6743: EMPTY
6744: LIST
6745: LIST
6746: PUSH
6747: EMPTY
6748: LIST
6749: LIST
6750: PPUSH
6751: CALL_OW 72
6755: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
6756: LD_INT 100
6758: PPUSH
6759: CALL_OW 13
6763: PUSH
6764: LD_INT 50
6766: LESS
6767: IFFALSE 6800
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
6769: LD_ADDR_VAR 0 5
6773: PUSH
6774: LD_INT 55
6776: PUSH
6777: LD_INT 7
6779: PUSH
6780: EMPTY
6781: LIST
6782: LIST
6783: PUSH
6784: LD_INT 75
6786: PUSH
6787: LD_INT 90
6789: PUSH
6790: EMPTY
6791: LIST
6792: LIST
6793: PUSH
6794: EMPTY
6795: LIST
6796: LIST
6797: ST_TO_ADDR
6798: GO 6829
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
6800: LD_ADDR_VAR 0 5
6804: PUSH
6805: LD_INT 128
6807: PUSH
6808: LD_INT 94
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: PUSH
6815: LD_INT 180
6817: PUSH
6818: LD_INT 135
6820: PUSH
6821: EMPTY
6822: LIST
6823: LIST
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: ST_TO_ADDR
// if w mod 4 = 0 then
6829: LD_VAR 0 7
6833: PUSH
6834: LD_INT 4
6836: MOD
6837: PUSH
6838: LD_INT 0
6840: EQUAL
6841: IFFALSE 6872
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
6843: LD_ADDR_VAR 0 5
6847: PUSH
6848: LD_INT 91
6850: PUSH
6851: LD_INT 58
6853: PUSH
6854: EMPTY
6855: LIST
6856: LIST
6857: PUSH
6858: LD_INT 117
6860: PUSH
6861: LD_INT 107
6863: PUSH
6864: EMPTY
6865: LIST
6866: LIST
6867: PUSH
6868: EMPTY
6869: LIST
6870: LIST
6871: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp , coords , flags ) ;
6872: LD_INT 1
6874: PPUSH
6875: LD_VAR 0 3
6879: PPUSH
6880: LD_VAR 0 5
6884: PPUSH
6885: LD_VAR 0 6
6889: PPUSH
6890: CALL 38286 0 4
// if mc_vehicles [ 2 ] then
6894: LD_EXP 68
6898: PUSH
6899: LD_INT 2
6901: ARRAY
6902: IFFALSE 6938
// MC_PrepareAttack ( 2 , mc_vehicles [ 2 ] , [ [ 73 , 115 ] ] , flags ) ;
6904: LD_INT 2
6906: PPUSH
6907: LD_EXP 68
6911: PUSH
6912: LD_INT 2
6914: ARRAY
6915: PPUSH
6916: LD_INT 73
6918: PUSH
6919: LD_INT 115
6921: PUSH
6922: EMPTY
6923: LIST
6924: LIST
6925: PUSH
6926: EMPTY
6927: LIST
6928: PPUSH
6929: LD_VAR 0 6
6933: PPUSH
6934: CALL 38286 0 4
// wait ( rand ( 9 9$30 , 12 12$30 ) ) ;
6938: LD_INT 19950
6940: PPUSH
6941: LD_INT 26250
6943: PPUSH
6944: CALL_OW 12
6948: PPUSH
6949: CALL_OW 67
// w := w + 1 ;
6953: LD_ADDR_VAR 0 7
6957: PUSH
6958: LD_VAR 0 7
6962: PUSH
6963: LD_INT 1
6965: PLUS
6966: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
6967: LD_INT 94
6969: PPUSH
6970: CALL_OW 301
6974: PUSH
6975: LD_EXP 49
6979: PUSH
6980: LD_INT 1
6982: ARRAY
6983: PPUSH
6984: LD_INT 30
6986: PUSH
6987: LD_INT 3
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PPUSH
6994: CALL_OW 72
6998: NOT
6999: OR
7000: IFFALSE 6266
// end ;
7002: PPOPN 8
7004: END
// every 18 18$00 trigger ar_dep_e do var i , tmp , un , x ;
7005: LD_INT 69
7007: IFFALSE 7382
7009: GO 7011
7011: DISABLE
7012: LD_INT 0
7014: PPUSH
7015: PPUSH
7016: PPUSH
7017: PPUSH
// begin enable ;
7018: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7019: LD_INT 35
7021: PPUSH
7022: LD_INT 1190
7024: PPUSH
7025: CALL_OW 12
7029: PPUSH
7030: CALL_OW 67
// tmp := [ ] ;
7034: LD_ADDR_VAR 0 2
7038: PUSH
7039: EMPTY
7040: ST_TO_ADDR
// uc_side := 8 ;
7041: LD_ADDR_OWVAR 20
7045: PUSH
7046: LD_INT 8
7048: ST_TO_ADDR
// uc_nation := 2 ;
7049: LD_ADDR_OWVAR 21
7053: PUSH
7054: LD_INT 2
7056: ST_TO_ADDR
// InitHc ;
7057: CALL_OW 19
// for i = 1 to 3 do
7061: LD_ADDR_VAR 0 1
7065: PUSH
7066: DOUBLE
7067: LD_INT 1
7069: DEC
7070: ST_TO_ADDR
7071: LD_INT 3
7073: PUSH
7074: FOR_TO
7075: IFFALSE 7202
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7077: LD_INT 13
7079: PUSH
7080: LD_INT 14
7082: PUSH
7083: EMPTY
7084: LIST
7085: LIST
7086: PUSH
7087: LD_INT 1
7089: PPUSH
7090: LD_INT 2
7092: PPUSH
7093: CALL_OW 12
7097: ARRAY
7098: PPUSH
7099: LD_INT 3
7101: PPUSH
7102: LD_INT 5
7104: PPUSH
7105: LD_INT 27
7107: PUSH
7108: LD_INT 28
7110: PUSH
7111: EMPTY
7112: LIST
7113: LIST
7114: PUSH
7115: LD_INT 1
7117: PPUSH
7118: LD_INT 2
7120: PPUSH
7121: CALL_OW 12
7125: ARRAY
7126: PPUSH
7127: LD_INT 100
7129: PPUSH
7130: CALL 50300 0 5
// un := CreateVehicle ;
7134: LD_ADDR_VAR 0 3
7138: PUSH
7139: CALL_OW 45
7143: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7144: LD_VAR 0 3
7148: PPUSH
7149: LD_INT 4
7151: PPUSH
7152: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7156: LD_VAR 0 3
7160: PPUSH
7161: LD_INT 15
7163: PPUSH
7164: LD_INT 0
7166: PPUSH
7167: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7171: LD_ADDR_VAR 0 2
7175: PUSH
7176: LD_VAR 0 2
7180: PPUSH
7181: LD_VAR 0 2
7185: PUSH
7186: LD_INT 1
7188: PLUS
7189: PPUSH
7190: LD_VAR 0 3
7194: PPUSH
7195: CALL_OW 1
7199: ST_TO_ADDR
// end ;
7200: GO 7074
7202: POP
7203: POP
// for i = 1 to 4 do
7204: LD_ADDR_VAR 0 1
7208: PUSH
7209: DOUBLE
7210: LD_INT 1
7212: DEC
7213: ST_TO_ADDR
7214: LD_INT 4
7216: PUSH
7217: FOR_TO
7218: IFFALSE 7297
// begin PrepareHuman ( false , rand ( 1 , 4 ) , 6 ) ;
7220: LD_INT 0
7222: PPUSH
7223: LD_INT 1
7225: PPUSH
7226: LD_INT 4
7228: PPUSH
7229: CALL_OW 12
7233: PPUSH
7234: LD_INT 6
7236: PPUSH
7237: CALL_OW 380
// un := CreateHuman ;
7241: LD_ADDR_VAR 0 3
7245: PUSH
7246: CALL_OW 44
7250: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7251: LD_VAR 0 3
7255: PPUSH
7256: LD_INT 15
7258: PPUSH
7259: LD_INT 0
7261: PPUSH
7262: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7266: LD_ADDR_VAR 0 2
7270: PUSH
7271: LD_VAR 0 2
7275: PPUSH
7276: LD_VAR 0 2
7280: PUSH
7281: LD_INT 1
7283: PLUS
7284: PPUSH
7285: LD_VAR 0 3
7289: PPUSH
7290: CALL_OW 1
7294: ST_TO_ADDR
// end ;
7295: GO 7217
7297: POP
7298: POP
// repeat ComAgressiveMove ( tmp , 210 , 177 ) ;
7299: LD_VAR 0 2
7303: PPUSH
7304: LD_INT 210
7306: PPUSH
7307: LD_INT 177
7309: PPUSH
7310: CALL_OW 114
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
7314: LD_ADDR_VAR 0 4
7318: PUSH
7319: LD_INT 10
7321: PPUSH
7322: LD_INT 22
7324: PUSH
7325: LD_INT 8
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: PPUSH
7332: CALL_OW 70
7336: ST_TO_ADDR
// if x then
7337: LD_VAR 0 4
7341: IFFALSE 7369
// for i in x do
7343: LD_ADDR_VAR 0 1
7347: PUSH
7348: LD_VAR 0 4
7352: PUSH
7353: FOR_IN
7354: IFFALSE 7367
// RemoveUnit ( i ) ;
7356: LD_VAR 0 1
7360: PPUSH
7361: CALL_OW 64
7365: GO 7353
7367: POP
7368: POP
// wait ( 0 0$3 ) ;
7369: LD_INT 105
7371: PPUSH
7372: CALL_OW 67
// until tmp ;
7376: LD_VAR 0 2
7380: IFFALSE 7299
// end ; end_of_file
7382: PPOPN 4
7384: END
// export function Action ; var tmp , p , radar , sols , i ; begin
7385: LD_INT 0
7387: PPUSH
7388: PPUSH
7389: PPUSH
7390: PPUSH
7391: PPUSH
7392: PPUSH
// InGameOn ;
7393: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
7397: LD_EXP 21
7401: PPUSH
7402: CALL_OW 87
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
7406: LD_ADDR_VAR 0 2
7410: PUSH
7411: LD_INT 22
7413: PUSH
7414: LD_INT 1
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PUSH
7421: LD_INT 25
7423: PUSH
7424: LD_INT 1
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: PUSH
7431: EMPTY
7432: LIST
7433: LIST
7434: PPUSH
7435: CALL_OW 69
7439: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
7440: LD_ADDR_VAR 0 4
7444: PUSH
7445: LD_INT 22
7447: PUSH
7448: LD_INT 1
7450: PUSH
7451: EMPTY
7452: LIST
7453: LIST
7454: PUSH
7455: LD_INT 34
7457: PUSH
7458: LD_INT 11
7460: PUSH
7461: EMPTY
7462: LIST
7463: LIST
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: PPUSH
7469: CALL_OW 69
7473: PUSH
7474: LD_INT 1
7476: ARRAY
7477: ST_TO_ADDR
// for i = 1 to tmp do
7478: LD_ADDR_VAR 0 6
7482: PUSH
7483: DOUBLE
7484: LD_INT 1
7486: DEC
7487: ST_TO_ADDR
7488: LD_VAR 0 2
7492: PUSH
7493: FOR_TO
7494: IFFALSE 7541
// begin if i = 5 then
7496: LD_VAR 0 6
7500: PUSH
7501: LD_INT 5
7503: EQUAL
7504: IFFALSE 7508
// break ;
7506: GO 7541
// sols := Replace ( sols , i , tmp [ i ] ) ;
7508: LD_ADDR_VAR 0 5
7512: PUSH
7513: LD_VAR 0 5
7517: PPUSH
7518: LD_VAR 0 6
7522: PPUSH
7523: LD_VAR 0 2
7527: PUSH
7528: LD_VAR 0 6
7532: ARRAY
7533: PPUSH
7534: CALL_OW 1
7538: ST_TO_ADDR
// end ;
7539: GO 7493
7541: POP
7542: POP
// tmp := ar_force_tmp ;
7543: LD_ADDR_VAR 0 2
7547: PUSH
7548: LD_EXP 39
7552: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
7553: LD_VAR 0 2
7557: PUSH
7558: LD_INT 1
7560: ARRAY
7561: PPUSH
7562: LD_INT 108
7564: PPUSH
7565: LD_INT 139
7567: PPUSH
7568: LD_INT 0
7570: PPUSH
7571: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
7575: LD_VAR 0 2
7579: PUSH
7580: LD_INT 1
7582: ARRAY
7583: PPUSH
7584: LD_EXP 21
7588: PPUSH
7589: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
7593: LD_VAR 0 2
7597: PUSH
7598: LD_INT 2
7600: ARRAY
7601: PPUSH
7602: LD_INT 114
7604: PPUSH
7605: LD_INT 132
7607: PPUSH
7608: LD_INT 0
7610: PPUSH
7611: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
7615: LD_VAR 0 2
7619: PUSH
7620: LD_INT 3
7622: ARRAY
7623: PPUSH
7624: LD_INT 115
7626: PPUSH
7627: LD_INT 132
7629: PPUSH
7630: LD_INT 0
7632: PPUSH
7633: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
7637: LD_VAR 0 2
7641: PUSH
7642: LD_INT 2
7644: ARRAY
7645: PUSH
7646: LD_VAR 0 2
7650: PUSH
7651: LD_INT 3
7653: ARRAY
7654: PUSH
7655: EMPTY
7656: LIST
7657: LIST
7658: PPUSH
7659: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
7663: LD_VAR 0 4
7667: PPUSH
7668: LD_INT 83
7670: PPUSH
7671: LD_INT 123
7673: PPUSH
7674: CALL_OW 111
// Wait ( 0 0$01 ) ;
7678: LD_INT 35
7680: PPUSH
7681: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
7685: LD_INT 90
7687: PPUSH
7688: LD_INT 144
7690: PPUSH
7691: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
7695: LD_VAR 0 5
7699: PPUSH
7700: LD_INT 88
7702: PPUSH
7703: LD_INT 129
7705: PPUSH
7706: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
7710: LD_ADDR_VAR 0 3
7714: PUSH
7715: LD_INT 92
7717: PUSH
7718: LD_INT 131
7720: PUSH
7721: EMPTY
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 88
7727: PUSH
7728: LD_INT 127
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PUSH
7735: LD_INT 91
7737: PUSH
7738: LD_INT 132
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: PUSH
7745: LD_INT 92
7747: PUSH
7748: LD_INT 134
7750: PUSH
7751: EMPTY
7752: LIST
7753: LIST
7754: PUSH
7755: EMPTY
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: ST_TO_ADDR
// for i = 1 to sols do
7761: LD_ADDR_VAR 0 6
7765: PUSH
7766: DOUBLE
7767: LD_INT 1
7769: DEC
7770: ST_TO_ADDR
7771: LD_VAR 0 5
7775: PUSH
7776: FOR_TO
7777: IFFALSE 7850
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
7779: LD_VAR 0 5
7783: PUSH
7784: LD_VAR 0 6
7788: ARRAY
7789: PPUSH
7790: LD_VAR 0 3
7794: PUSH
7795: LD_VAR 0 6
7799: ARRAY
7800: PUSH
7801: LD_INT 1
7803: ARRAY
7804: PPUSH
7805: LD_VAR 0 3
7809: PUSH
7810: LD_VAR 0 6
7814: ARRAY
7815: PUSH
7816: LD_INT 2
7818: ARRAY
7819: PPUSH
7820: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
7824: LD_VAR 0 5
7828: PUSH
7829: LD_VAR 0 6
7833: ARRAY
7834: PPUSH
7835: CALL_OW 197
// AddComHold ( sols ) ;
7839: LD_VAR 0 5
7843: PPUSH
7844: CALL_OW 200
// end ;
7848: GO 7776
7850: POP
7851: POP
// repeat wait ( 0 0$1 ) ;
7852: LD_INT 35
7854: PPUSH
7855: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
7859: LD_VAR 0 5
7863: PUSH
7864: LD_INT 1
7866: ARRAY
7867: PPUSH
7868: LD_INT 92
7870: PPUSH
7871: LD_INT 131
7873: PPUSH
7874: CALL_OW 297
7878: PUSH
7879: LD_INT 4
7881: LESS
7882: IFFALSE 7852
// CenterOnXY ( 96 , 139 ) ;
7884: LD_INT 96
7886: PPUSH
7887: LD_INT 139
7889: PPUSH
7890: CALL_OW 84
// wait ( 0 0$3 ) ;
7894: LD_INT 105
7896: PPUSH
7897: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
7901: LD_INT 111
7903: PPUSH
7904: LD_INT 135
7906: PPUSH
7907: LD_INT 1
7909: PPUSH
7910: LD_INT 25
7912: NEG
7913: PPUSH
7914: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
7918: LD_VAR 0 2
7922: PUSH
7923: LD_INT 2
7925: ARRAY
7926: PPUSH
7927: LD_VAR 0 2
7931: PUSH
7932: LD_INT 1
7934: ARRAY
7935: PPUSH
7936: CALL_OW 250
7940: PUSH
7941: LD_INT 3
7943: PLUS
7944: PPUSH
7945: LD_VAR 0 2
7949: PUSH
7950: LD_INT 1
7952: ARRAY
7953: PPUSH
7954: CALL_OW 251
7958: PPUSH
7959: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
7963: LD_VAR 0 2
7967: PUSH
7968: LD_INT 3
7970: ARRAY
7971: PPUSH
7972: LD_INT 7
7974: PPUSH
7975: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
7979: LD_VAR 0 2
7983: PUSH
7984: LD_INT 2
7986: ARRAY
7987: PPUSH
7988: LD_VAR 0 2
7992: PUSH
7993: LD_INT 1
7995: ARRAY
7996: PPUSH
7997: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
8001: LD_INT 35
8003: PPUSH
8004: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
8008: LD_VAR 0 2
8012: PUSH
8013: LD_INT 1
8015: ARRAY
8016: PPUSH
8017: LD_VAR 0 2
8021: PUSH
8022: LD_INT 2
8024: ARRAY
8025: PPUSH
8026: CALL_OW 296
8030: PUSH
8031: LD_INT 5
8033: LESS
8034: IFFALSE 8001
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
8036: LD_VAR 0 2
8040: PUSH
8041: LD_INT 1
8043: ARRAY
8044: PPUSH
8045: LD_VAR 0 2
8049: PUSH
8050: LD_INT 2
8052: ARRAY
8053: PPUSH
8054: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
8058: LD_VAR 0 2
8062: PUSH
8063: LD_INT 1
8065: ARRAY
8066: PPUSH
8067: LD_STRING D1a-Merc1-1
8069: PPUSH
8070: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
8074: LD_VAR 0 2
8078: PUSH
8079: LD_INT 2
8081: ARRAY
8082: PPUSH
8083: LD_STRING D1a-FMerc2-1
8085: PPUSH
8086: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
8090: LD_VAR 0 2
8094: PUSH
8095: LD_INT 2
8097: ARRAY
8098: PPUSH
8099: LD_VAR 0 2
8103: PUSH
8104: LD_INT 1
8106: ARRAY
8107: PPUSH
8108: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
8112: LD_VAR 0 2
8116: PUSH
8117: LD_INT 1
8119: ARRAY
8120: PPUSH
8121: LD_INT 500
8123: PPUSH
8124: CALL_OW 234
// wait ( 0 0$2 ) ;
8128: LD_INT 70
8130: PPUSH
8131: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
8135: LD_VAR 0 2
8139: PUSH
8140: LD_INT 1
8142: ARRAY
8143: PPUSH
8144: LD_INT 2
8146: PPUSH
8147: CALL_OW 234
// wait ( 0 0$0.3 ) ;
8151: LD_INT 10
8153: PPUSH
8154: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
8158: LD_VAR 0 2
8162: PUSH
8163: LD_INT 1
8165: ARRAY
8166: PPUSH
8167: LD_STRING D1a-Merc1-2
8169: PPUSH
8170: CALL_OW 91
// wait ( 0 0$0.2 ) ;
8174: LD_INT 7
8176: PPUSH
8177: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
8181: LD_VAR 0 2
8185: PUSH
8186: LD_INT 1
8188: ARRAY
8189: PPUSH
8190: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
8194: LD_VAR 0 2
8198: PUSH
8199: LD_INT 2
8201: ARRAY
8202: PPUSH
8203: LD_INT 10
8205: PPUSH
8206: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
8210: LD_VAR 0 2
8214: PUSH
8215: LD_INT 2
8217: ARRAY
8218: PPUSH
8219: LD_STRING D1a-FMerc2-2
8221: PPUSH
8222: CALL_OW 88
// wait ( 0 0$1 ) ;
8226: LD_INT 35
8228: PPUSH
8229: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
8233: LD_INT 7
8235: PPUSH
8236: CALL_OW 85
// wait ( 0 0$2 ) ;
8240: LD_INT 70
8242: PPUSH
8243: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
8247: LD_EXP 43
8251: PPUSH
8252: LD_STRING D1a-Saliba-1
8254: PPUSH
8255: CALL_OW 91
// KillUnit ( Saliba ) ;
8259: LD_EXP 43
8263: PPUSH
8264: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
8268: LD_VAR 0 2
8272: PUSH
8273: LD_INT 3
8275: ARRAY
8276: PPUSH
8277: CALL_OW 122
// CenterOnUnits ( JMM ) ;
8281: LD_EXP 21
8285: PPUSH
8286: CALL_OW 85
// wait ( 0 0$1 ) ;
8290: LD_INT 35
8292: PPUSH
8293: CALL_OW 67
// InGameOff ;
8297: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
8301: LD_STRING M1
8303: PPUSH
8304: CALL_OW 337
// game_speed := 4 ;
8308: LD_ADDR_OWVAR 65
8312: PUSH
8313: LD_INT 4
8315: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
8316: LD_INT 111
8318: PPUSH
8319: LD_INT 135
8321: PPUSH
8322: LD_INT 1
8324: PPUSH
8325: CALL_OW 331
// SaveForQuickRestart ;
8329: CALL_OW 22
// ar_run := true ;
8333: LD_ADDR_EXP 5
8337: PUSH
8338: LD_INT 1
8340: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8341: LD_INT 35
8343: PPUSH
8344: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
8348: LD_INT 22
8350: PUSH
8351: LD_INT 1
8353: PUSH
8354: EMPTY
8355: LIST
8356: LIST
8357: PUSH
8358: LD_INT 91
8360: PUSH
8361: LD_INT 7
8363: PUSH
8364: LD_INT 10
8366: PUSH
8367: EMPTY
8368: LIST
8369: LIST
8370: LIST
8371: PUSH
8372: EMPTY
8373: LIST
8374: LIST
8375: PPUSH
8376: CALL_OW 69
8380: PUSH
8381: LD_INT 7
8383: PPUSH
8384: CALL_OW 256
8388: PUSH
8389: LD_INT 999
8391: LESS
8392: OR
8393: IFFALSE 8341
// if GetSide ( ar_dep_s ) = 2 then
8395: LD_INT 7
8397: PPUSH
8398: CALL_OW 255
8402: PUSH
8403: LD_INT 2
8405: EQUAL
8406: IFFALSE 8418
// SetSide ( ar_dep_s , 1 ) ;
8408: LD_INT 7
8410: PPUSH
8411: LD_INT 1
8413: PPUSH
8414: CALL_OW 235
// end ;
8418: LD_VAR 0 1
8422: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
8423: LD_EXP 5
8427: IFFALSE 8787
8429: GO 8431
8431: DISABLE
8432: LD_INT 0
8434: PPUSH
8435: PPUSH
8436: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
8437: LD_ADDR_VAR 0 2
8441: PUSH
8442: LD_EXP 39
8446: PUSH
8447: LD_EXP 36
8451: PPUSH
8452: LD_INT 2
8454: PUSH
8455: LD_INT 21
8457: PUSH
8458: LD_INT 2
8460: PUSH
8461: EMPTY
8462: LIST
8463: LIST
8464: PUSH
8465: LD_INT 21
8467: PUSH
8468: LD_INT 1
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: PUSH
8475: EMPTY
8476: LIST
8477: LIST
8478: LIST
8479: PPUSH
8480: CALL_OW 72
8484: ADD
8485: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
8486: LD_VAR 0 2
8490: PPUSH
8491: LD_INT 5
8493: PPUSH
8494: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
8498: LD_INT 5
8500: PPUSH
8501: LD_INT 1
8503: PPUSH
8504: CALL_OW 343
// k := 1 ;
8508: LD_ADDR_VAR 0 3
8512: PUSH
8513: LD_INT 1
8515: ST_TO_ADDR
// for i in tmp do
8516: LD_ADDR_VAR 0 1
8520: PUSH
8521: LD_VAR 0 2
8525: PUSH
8526: FOR_IN
8527: IFFALSE 8612
// begin if IsInUnit ( i ) then
8529: LD_VAR 0 1
8533: PPUSH
8534: CALL_OW 310
8538: IFFALSE 8549
// ComExitBuilding ( i ) ;
8540: LD_VAR 0 1
8544: PPUSH
8545: CALL_OW 122
// if GetClass ( i ) = 3 then
8549: LD_VAR 0 1
8553: PPUSH
8554: CALL_OW 257
8558: PUSH
8559: LD_INT 3
8561: EQUAL
8562: IFFALSE 8598
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
8564: LD_VAR 0 1
8568: PPUSH
8569: LD_EXP 40
8573: PUSH
8574: LD_VAR 0 3
8578: ARRAY
8579: PPUSH
8580: CALL_OW 180
// k := k + 1 ;
8584: LD_ADDR_VAR 0 3
8588: PUSH
8589: LD_VAR 0 3
8593: PUSH
8594: LD_INT 1
8596: PLUS
8597: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
8598: LD_VAR 0 1
8602: PPUSH
8603: LD_INT 10
8605: PPUSH
8606: CALL_OW 173
// end ;
8610: GO 8526
8612: POP
8613: POP
// ar_patrol := true ;
8614: LD_ADDR_EXP 7
8618: PUSH
8619: LD_INT 1
8621: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
8622: LD_INT 10
8624: PPUSH
8625: CALL_OW 67
// for i in tmp do
8629: LD_ADDR_VAR 0 1
8633: PUSH
8634: LD_VAR 0 2
8638: PUSH
8639: FOR_IN
8640: IFFALSE 8668
// if not HasTask ( i ) then
8642: LD_VAR 0 1
8646: PPUSH
8647: CALL_OW 314
8651: NOT
8652: IFFALSE 8666
// ComMoveToArea ( i , escape_area ) ;
8654: LD_VAR 0 1
8658: PPUSH
8659: LD_INT 10
8661: PPUSH
8662: CALL_OW 113
8666: GO 8639
8668: POP
8669: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
8670: LD_ADDR_VAR 0 3
8674: PUSH
8675: LD_VAR 0 2
8679: PPUSH
8680: LD_INT 95
8682: PUSH
8683: LD_INT 10
8685: PUSH
8686: EMPTY
8687: LIST
8688: LIST
8689: PPUSH
8690: CALL_OW 72
8694: ST_TO_ADDR
// if k then
8695: LD_VAR 0 3
8699: IFFALSE 8768
// for i in k do
8701: LD_ADDR_VAR 0 1
8705: PUSH
8706: LD_VAR 0 3
8710: PUSH
8711: FOR_IN
8712: IFFALSE 8766
// begin if IsInUnit ( i ) then
8714: LD_VAR 0 1
8718: PPUSH
8719: CALL_OW 310
8723: IFFALSE 8739
// RemoveUnit ( IsInUnit ( i ) ) ;
8725: LD_VAR 0 1
8729: PPUSH
8730: CALL_OW 310
8734: PPUSH
8735: CALL_OW 64
// RemoveUnit ( i ) ;
8739: LD_VAR 0 1
8743: PPUSH
8744: CALL_OW 64
// tmp := tmp diff i ;
8748: LD_ADDR_VAR 0 2
8752: PUSH
8753: LD_VAR 0 2
8757: PUSH
8758: LD_VAR 0 1
8762: DIFF
8763: ST_TO_ADDR
// end ;
8764: GO 8711
8766: POP
8767: POP
// until tmp = [ ] ;
8768: LD_VAR 0 2
8772: PUSH
8773: EMPTY
8774: EQUAL
8775: IFFALSE 8622
// ChangeSideFog ( 5 , 5 ) ;
8777: LD_INT 5
8779: PPUSH
8780: LD_INT 5
8782: PPUSH
8783: CALL_OW 343
// end ;
8787: PPOPN 3
8789: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
8790: LD_EXP 7
8794: IFFALSE 9084
8796: GO 8798
8798: DISABLE
8799: LD_INT 0
8801: PPUSH
8802: PPUSH
8803: PPUSH
// begin uc_side := 2 ;
8804: LD_ADDR_OWVAR 20
8808: PUSH
8809: LD_INT 2
8811: ST_TO_ADDR
// uc_nation := 2 ;
8812: LD_ADDR_OWVAR 21
8816: PUSH
8817: LD_INT 2
8819: ST_TO_ADDR
// InitHc ;
8820: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
8824: LD_INT 1
8826: PPUSH
8827: LD_INT 1
8829: PPUSH
8830: LD_INT 6
8832: PPUSH
8833: CALL_OW 380
// un := CreateHuman ;
8837: LD_ADDR_VAR 0 2
8841: PUSH
8842: CALL_OW 44
8846: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
8847: LD_INT 14
8849: PPUSH
8850: LD_INT 1
8852: PPUSH
8853: LD_INT 1
8855: PPUSH
8856: LD_INT 27
8858: PPUSH
8859: LD_INT 98
8861: PPUSH
8862: CALL 50300 0 5
// veh := CreateVehicle ;
8866: LD_ADDR_VAR 0 3
8870: PUSH
8871: CALL_OW 45
8875: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
8876: LD_VAR 0 3
8880: PPUSH
8881: LD_INT 4
8883: PPUSH
8884: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
8888: LD_VAR 0 3
8892: PPUSH
8893: LD_INT 179
8895: PPUSH
8896: LD_INT 135
8898: PPUSH
8899: LD_INT 0
8901: PPUSH
8902: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
8906: LD_VAR 0 2
8910: PPUSH
8911: LD_VAR 0 3
8915: PPUSH
8916: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
8920: LD_VAR 0 2
8924: PPUSH
8925: LD_INT 126
8927: PPUSH
8928: LD_INT 133
8930: PPUSH
8931: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
8935: LD_INT 10
8937: PPUSH
8938: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
8942: LD_INT 1
8944: PPUSH
8945: LD_VAR 0 3
8949: PPUSH
8950: CALL_OW 292
8954: PUSH
8955: LD_VAR 0 3
8959: PPUSH
8960: LD_INT 7
8962: PPUSH
8963: CALL_OW 296
8967: PUSH
8968: LD_INT 9
8970: LESS
8971: OR
8972: IFFALSE 8935
// ComHold ( veh ) ;
8974: LD_VAR 0 3
8978: PPUSH
8979: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
8983: LD_VAR 0 2
8987: PPUSH
8988: LD_STRING D2aa-Ar1-1
8990: PPUSH
8991: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
8995: LD_VAR 0 2
8999: PPUSH
9000: LD_INT 177
9002: PPUSH
9003: LD_INT 96
9005: PPUSH
9006: CALL_OW 111
// AddComExitVehicle ( un ) ;
9010: LD_VAR 0 2
9014: PPUSH
9015: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
9019: LD_INT 35
9021: PPUSH
9022: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
9026: LD_VAR 0 2
9030: PPUSH
9031: LD_INT 69
9033: PPUSH
9034: CALL_OW 296
9038: PUSH
9039: LD_INT 15
9041: LESS
9042: IFFALSE 9019
// mc_bases := Add ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
9044: LD_ADDR_EXP 49
9048: PUSH
9049: LD_EXP 49
9053: PPUSH
9054: LD_INT 3
9056: PUSH
9057: LD_EXP 49
9061: PUSH
9062: LD_INT 3
9064: ARRAY
9065: PUSH
9066: LD_INT 1
9068: PLUS
9069: PUSH
9070: EMPTY
9071: LIST
9072: LIST
9073: PPUSH
9074: LD_VAR 0 2
9078: PPUSH
9079: CALL 50857 0 3
9083: ST_TO_ADDR
// end ;
9084: PPOPN 3
9086: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
9087: LD_INT 7
9089: PPUSH
9090: CALL_OW 255
9094: PUSH
9095: LD_INT 1
9097: EQUAL
9098: PUSH
9099: LD_INT 7
9101: PPUSH
9102: CALL_OW 301
9106: OR
9107: IFFALSE 11531
9109: GO 9111
9111: DISABLE
9112: LD_INT 0
9114: PPUSH
9115: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
9116: LD_ADDR_VAR 0 1
9120: PUSH
9121: LD_EXP 36
9125: PPUSH
9126: LD_INT 21
9128: PUSH
9129: LD_INT 3
9131: PUSH
9132: EMPTY
9133: LIST
9134: LIST
9135: PPUSH
9136: CALL_OW 72
9140: PUSH
9141: FOR_IN
9142: IFFALSE 9158
// SetSide ( i , 1 ) ;
9144: LD_VAR 0 1
9148: PPUSH
9149: LD_INT 1
9151: PPUSH
9152: CALL_OW 235
9156: GO 9141
9158: POP
9159: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
9160: LD_ADDR_VAR 0 2
9164: PUSH
9165: LD_INT 46
9167: PUSH
9168: LD_INT 41
9170: PUSH
9171: EMPTY
9172: LIST
9173: LIST
9174: PUSH
9175: LD_INT 50
9177: PUSH
9178: LD_INT 25
9180: PUSH
9181: EMPTY
9182: LIST
9183: LIST
9184: PUSH
9185: LD_INT 57
9187: PUSH
9188: LD_INT 75
9190: PUSH
9191: EMPTY
9192: LIST
9193: LIST
9194: PUSH
9195: LD_INT 75
9197: PUSH
9198: LD_INT 89
9200: PUSH
9201: EMPTY
9202: LIST
9203: LIST
9204: PUSH
9205: LD_INT 51
9207: PUSH
9208: LD_INT 45
9210: PUSH
9211: EMPTY
9212: LIST
9213: LIST
9214: PUSH
9215: LD_INT 95
9217: PUSH
9218: LD_INT 95
9220: PUSH
9221: EMPTY
9222: LIST
9223: LIST
9224: PUSH
9225: LD_INT 84
9227: PUSH
9228: LD_INT 77
9230: PUSH
9231: EMPTY
9232: LIST
9233: LIST
9234: PUSH
9235: LD_INT 101
9237: PUSH
9238: LD_INT 76
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: PUSH
9245: LD_INT 118
9247: PUSH
9248: LD_INT 81
9250: PUSH
9251: EMPTY
9252: LIST
9253: LIST
9254: PUSH
9255: LD_INT 139
9257: PUSH
9258: LD_INT 97
9260: PUSH
9261: EMPTY
9262: LIST
9263: LIST
9264: PUSH
9265: LD_INT 129
9267: PUSH
9268: LD_INT 114
9270: PUSH
9271: EMPTY
9272: LIST
9273: LIST
9274: PUSH
9275: LD_INT 154
9277: PUSH
9278: LD_INT 111
9280: PUSH
9281: EMPTY
9282: LIST
9283: LIST
9284: PUSH
9285: EMPTY
9286: LIST
9287: LIST
9288: LIST
9289: LIST
9290: LIST
9291: LIST
9292: LIST
9293: LIST
9294: LIST
9295: LIST
9296: LIST
9297: LIST
9298: ST_TO_ADDR
// base_captured := true ;
9299: LD_ADDR_EXP 6
9303: PUSH
9304: LD_INT 1
9306: ST_TO_ADDR
// DialogueOn ;
9307: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
9311: LD_EXP 21
9315: PPUSH
9316: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
9320: LD_EXP 21
9324: PPUSH
9325: LD_STRING D2-JMM-1
9327: PPUSH
9328: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
9332: LD_EXP 30
9336: PPUSH
9337: LD_STRING D2-Pow-1
9339: PPUSH
9340: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
9344: LD_EXP 21
9348: PPUSH
9349: LD_STRING D2-JMM-2
9351: PPUSH
9352: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
9356: LD_EXP 30
9360: PPUSH
9361: LD_STRING D2-Pow-2
9363: PPUSH
9364: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
9368: LD_EXP 21
9372: PPUSH
9373: LD_STRING D2-JMM-3
9375: PPUSH
9376: CALL_OW 88
// DialogueOff ;
9380: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
9384: LD_STRING M2
9386: PPUSH
9387: CALL_OW 337
// Wait ( 0 0$2 ) ;
9391: LD_INT 70
9393: PPUSH
9394: CALL_OW 67
// if IsOk ( Gary ) then
9398: LD_EXP 32
9402: PPUSH
9403: CALL_OW 302
9407: IFFALSE 9421
// Say ( Gary , D2a-Gary-1 ) ;
9409: LD_EXP 32
9413: PPUSH
9414: LD_STRING D2a-Gary-1
9416: PPUSH
9417: CALL_OW 88
// if IsOk ( Bobby ) then
9421: LD_EXP 24
9425: PPUSH
9426: CALL_OW 302
9430: IFFALSE 9444
// Say ( Bobby , D2a-Bobby-1 ) ;
9432: LD_EXP 24
9436: PPUSH
9437: LD_STRING D2a-Bobby-1
9439: PPUSH
9440: CALL_OW 88
// if IsOk ( Cyrus ) then
9444: LD_EXP 25
9448: PPUSH
9449: CALL_OW 302
9453: IFFALSE 9467
// Say ( Cyrus , D2a-Cyrus-1 ) ;
9455: LD_EXP 25
9459: PPUSH
9460: LD_STRING D2a-Cyrus-1
9462: PPUSH
9463: CALL_OW 88
// if IsOk ( Lisa ) then
9467: LD_EXP 22
9471: PPUSH
9472: CALL_OW 302
9476: IFFALSE 9490
// Say ( Lisa , D2a-Lisa-1 ) ;
9478: LD_EXP 22
9482: PPUSH
9483: LD_STRING D2a-Lisa-1
9485: PPUSH
9486: CALL_OW 88
// if IsOk ( Frank ) then
9490: LD_EXP 33
9494: PPUSH
9495: CALL_OW 302
9499: IFFALSE 9513
// Say ( Frank , D2a-Frank-1 ) ;
9501: LD_EXP 33
9505: PPUSH
9506: LD_STRING D2a-Frank-1
9508: PPUSH
9509: CALL_OW 88
// if IsOk ( Cornel ) then
9513: LD_EXP 31
9517: PPUSH
9518: CALL_OW 302
9522: IFFALSE 9536
// Say ( Cornel , D2a-Corn-1 ) ;
9524: LD_EXP 31
9528: PPUSH
9529: LD_STRING D2a-Corn-1
9531: PPUSH
9532: CALL_OW 88
// if IsOk ( Donaldson ) then
9536: LD_EXP 23
9540: PPUSH
9541: CALL_OW 302
9545: IFFALSE 9559
// Say ( Donaldson , D2a-Don-1 ) ;
9547: LD_EXP 23
9551: PPUSH
9552: LD_STRING D2a-Don-1
9554: PPUSH
9555: CALL_OW 88
// if IsOk ( Brown ) then
9559: LD_EXP 27
9563: PPUSH
9564: CALL_OW 302
9568: IFFALSE 9582
// Say ( Brown , D2a-Brown-1 ) ;
9570: LD_EXP 27
9574: PPUSH
9575: LD_STRING D2a-Brown-1
9577: PPUSH
9578: CALL_OW 88
// Wait ( 0 0$30 ) ;
9582: LD_INT 1050
9584: PPUSH
9585: CALL_OW 67
// if IsOk ( Frank ) then
9589: LD_EXP 33
9593: PPUSH
9594: CALL_OW 302
9598: IFFALSE 9864
// begin DialogueOn ;
9600: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
9604: LD_EXP 21
9608: PUSH
9609: LD_EXP 33
9613: PUSH
9614: EMPTY
9615: LIST
9616: LIST
9617: PPUSH
9618: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
9622: LD_EXP 33
9626: PPUSH
9627: LD_STRING D3F-Frank-1
9629: PPUSH
9630: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
9634: LD_EXP 21
9638: PPUSH
9639: LD_STRING D3F-JMM-1
9641: PPUSH
9642: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
9646: LD_EXP 33
9650: PPUSH
9651: LD_STRING D3F-Frank-2
9653: PPUSH
9654: CALL_OW 88
// case Query ( QFrank ) of 1 :
9658: LD_STRING QFrank
9660: PPUSH
9661: CALL_OW 97
9665: PUSH
9666: LD_INT 1
9668: DOUBLE
9669: EQUAL
9670: IFTRUE 9674
9672: GO 9697
9674: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
9675: LD_EXP 21
9679: PPUSH
9680: LD_STRING D3Fa-JMM-1
9682: PPUSH
9683: CALL_OW 88
// us_scout := 1 ;
9687: LD_ADDR_EXP 8
9691: PUSH
9692: LD_INT 1
9694: ST_TO_ADDR
// end ; 2 :
9695: GO 9860
9697: LD_INT 2
9699: DOUBLE
9700: EQUAL
9701: IFTRUE 9705
9703: GO 9827
9705: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
9706: LD_EXP 21
9710: PPUSH
9711: LD_STRING D3Fb-JMM-1
9713: PPUSH
9714: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
9718: LD_EXP 33
9722: PPUSH
9723: LD_STRING D3Fb-Frank-1
9725: PPUSH
9726: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
9730: LD_STRING QFrank2
9732: PPUSH
9733: CALL_OW 97
9737: PUSH
9738: LD_INT 1
9740: DOUBLE
9741: EQUAL
9742: IFTRUE 9746
9744: GO 9793
9746: POP
// begin us_scout := 2 ;
9747: LD_ADDR_EXP 8
9751: PUSH
9752: LD_INT 2
9754: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
9755: LD_EXP 21
9759: PPUSH
9760: LD_STRING D3Fba-JMM-1
9762: PPUSH
9763: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
9767: LD_EXP 33
9771: PPUSH
9772: LD_STRING D3Fba-Frank-1
9774: PPUSH
9775: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
9779: LD_EXP 21
9783: PPUSH
9784: LD_STRING D3Fba-JMM-2
9786: PPUSH
9787: CALL_OW 88
// end ; 2 :
9791: GO 9825
9793: LD_INT 2
9795: DOUBLE
9796: EQUAL
9797: IFTRUE 9801
9799: GO 9824
9801: POP
// begin us_scout := 0 ;
9802: LD_ADDR_EXP 8
9806: PUSH
9807: LD_INT 0
9809: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
9810: LD_EXP 21
9814: PPUSH
9815: LD_STRING D3Fbb-JMM-1
9817: PPUSH
9818: CALL_OW 88
// end ; end ;
9822: GO 9825
9824: POP
// end ; 3 :
9825: GO 9860
9827: LD_INT 3
9829: DOUBLE
9830: EQUAL
9831: IFTRUE 9835
9833: GO 9859
9835: POP
// begin us_scout := - 1 ;
9836: LD_ADDR_EXP 8
9840: PUSH
9841: LD_INT 1
9843: NEG
9844: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
9845: LD_EXP 21
9849: PPUSH
9850: LD_STRING D3Fc-JMM-1
9852: PPUSH
9853: CALL_OW 88
// end ; end ;
9857: GO 9860
9859: POP
// DialogueOff ;
9860: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
9864: LD_EXP 8
9868: PUSH
9869: LD_INT 1
9871: NEG
9872: PUSH
9873: LD_INT 0
9875: PUSH
9876: EMPTY
9877: LIST
9878: LIST
9879: IN
9880: IFFALSE 9884
// exit ;
9882: GO 11531
// if us_scout in [ 1 , 2 ] then
9884: LD_EXP 8
9888: PUSH
9889: LD_INT 1
9891: PUSH
9892: LD_INT 2
9894: PUSH
9895: EMPTY
9896: LIST
9897: LIST
9898: IN
9899: IFFALSE 10598
// begin if IsInUnit ( Frank ) then
9901: LD_EXP 33
9905: PPUSH
9906: CALL_OW 310
9910: IFFALSE 9921
// ComExitBuilding ( Frank ) ;
9912: LD_EXP 33
9916: PPUSH
9917: CALL_OW 122
// if IsDrivenBy ( Frank ) then
9921: LD_EXP 33
9925: PPUSH
9926: CALL_OW 311
9930: IFFALSE 9941
// ComExitVehicle ( Frank ) ;
9932: LD_EXP 33
9936: PPUSH
9937: CALL_OW 121
// SetSide ( Frank , 4 ) ;
9941: LD_EXP 33
9945: PPUSH
9946: LD_INT 4
9948: PPUSH
9949: CALL_OW 235
// wait ( 0 0$1 ) ;
9953: LD_INT 35
9955: PPUSH
9956: CALL_OW 67
// if us_scout = 2 then
9960: LD_EXP 8
9964: PUSH
9965: LD_INT 2
9967: EQUAL
9968: IFFALSE 10336
// begin ComMoveXY ( Frank , 75 , 63 ) ;
9970: LD_EXP 33
9974: PPUSH
9975: LD_INT 75
9977: PPUSH
9978: LD_INT 63
9980: PPUSH
9981: CALL_OW 111
// AddComHold ( Frank ) ;
9985: LD_EXP 33
9989: PPUSH
9990: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
9994: LD_EXP 33
9998: PPUSH
9999: LD_INT 770
10001: PPUSH
10002: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
10006: LD_EXP 33
10010: PPUSH
10011: LD_INT 100
10013: PPUSH
10014: LD_INT 75
10016: PPUSH
10017: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
10021: LD_EXP 33
10025: PPUSH
10026: LD_INT 123
10028: PPUSH
10029: LD_INT 103
10031: PPUSH
10032: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
10036: LD_EXP 33
10040: PPUSH
10041: LD_INT 138
10043: PPUSH
10044: LD_INT 108
10046: PPUSH
10047: CALL_OW 171
// AddComHold ( Frank ) ;
10051: LD_EXP 33
10055: PPUSH
10056: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10060: LD_INT 35
10062: PPUSH
10063: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
10067: LD_EXP 33
10071: PPUSH
10072: LD_INT 138
10074: PPUSH
10075: LD_INT 108
10077: PPUSH
10078: CALL_OW 307
10082: IFFALSE 10060
// AddComMoveXY ( Frank , 125 , 132 ) ;
10084: LD_EXP 33
10088: PPUSH
10089: LD_INT 125
10091: PPUSH
10092: LD_INT 132
10094: PPUSH
10095: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10099: LD_INT 35
10101: PPUSH
10102: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
10106: LD_INT 1
10108: PPUSH
10109: LD_EXP 33
10113: PPUSH
10114: CALL_OW 292
10118: PUSH
10119: LD_EXP 33
10123: PPUSH
10124: LD_INT 7
10126: PPUSH
10127: CALL_OW 296
10131: PUSH
10132: LD_INT 7
10134: LESS
10135: OR
10136: IFFALSE 10099
// DialogueOn ;
10138: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10142: LD_EXP 33
10146: PPUSH
10147: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
10151: LD_INT 10
10153: PPUSH
10154: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
10158: LD_EXP 21
10162: PPUSH
10163: LD_STRING D4Fa-JMM-1
10165: PPUSH
10166: CALL_OW 88
// for i in points do
10170: LD_ADDR_VAR 0 1
10174: PUSH
10175: LD_VAR 0 2
10179: PUSH
10180: FOR_IN
10181: IFFALSE 10239
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
10183: LD_VAR 0 1
10187: PUSH
10188: LD_INT 1
10190: ARRAY
10191: PPUSH
10192: LD_VAR 0 1
10196: PUSH
10197: LD_INT 2
10199: ARRAY
10200: PPUSH
10201: LD_INT 1
10203: PPUSH
10204: LD_INT 20
10206: NEG
10207: PPUSH
10208: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
10212: LD_VAR 0 1
10216: PUSH
10217: LD_INT 1
10219: ARRAY
10220: PPUSH
10221: LD_VAR 0 1
10225: PUSH
10226: LD_INT 2
10228: ARRAY
10229: PPUSH
10230: LD_INT 1
10232: PPUSH
10233: CALL_OW 331
// end ;
10237: GO 10180
10239: POP
10240: POP
// dwait ( 0 0$0.5 ) ;
10241: LD_INT 18
10243: PPUSH
10244: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
10248: LD_INT 42
10250: PPUSH
10251: LD_INT 27
10253: PPUSH
10254: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
10258: LD_EXP 33
10262: PPUSH
10263: LD_STRING D4Fa-Frank-1
10265: PPUSH
10266: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
10270: LD_INT 18
10272: PPUSH
10273: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
10277: LD_EXP 21
10281: PPUSH
10282: LD_STRING D4Fa-JMM-2
10284: PPUSH
10285: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
10289: LD_INT 118
10291: PPUSH
10292: LD_INT 80
10294: PPUSH
10295: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
10299: LD_EXP 33
10303: PPUSH
10304: LD_STRING D4Fa-Frank-2
10306: PPUSH
10307: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
10311: LD_INT 10
10313: PPUSH
10314: CALL_OW 68
// DialogueOff ;
10318: CALL_OW 7
// SetSide ( Frank , 1 ) ;
10322: LD_EXP 33
10326: PPUSH
10327: LD_INT 1
10329: PPUSH
10330: CALL_OW 235
// end else
10334: GO 10598
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
10336: LD_INT 2
10338: PPUSH
10339: LD_INT 4
10341: PPUSH
10342: LD_INT 2
10344: PPUSH
10345: LD_INT 1
10347: PPUSH
10348: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
10352: LD_EXP 33
10356: PPUSH
10357: LD_INT 75
10359: PPUSH
10360: LD_INT 63
10362: PPUSH
10363: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
10367: LD_EXP 33
10371: PPUSH
10372: LD_INT 175
10374: PPUSH
10375: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
10379: LD_EXP 33
10383: PPUSH
10384: LD_INT 102
10386: PPUSH
10387: LD_INT 76
10389: PPUSH
10390: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
10394: LD_EXP 33
10398: PPUSH
10399: LD_INT 108
10401: PPUSH
10402: LD_INT 70
10404: PPUSH
10405: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10409: LD_INT 35
10411: PPUSH
10412: CALL_OW 67
// until See ( 2 , Frank ) ;
10416: LD_INT 2
10418: PPUSH
10419: LD_EXP 33
10423: PPUSH
10424: CALL_OW 292
10428: IFFALSE 10409
// ComMoveXY ( Frank , 112 , 118 ) ;
10430: LD_EXP 33
10434: PPUSH
10435: LD_INT 112
10437: PPUSH
10438: LD_INT 118
10440: PPUSH
10441: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
10445: LD_EXP 33
10449: PPUSH
10450: CALL_OW 256
10454: PUSH
10455: LD_INT 750
10457: GREATEREQUAL
10458: IFFALSE 10472
// SetLives ( Frank , 700 ) ;
10460: LD_EXP 33
10464: PPUSH
10465: LD_INT 700
10467: PPUSH
10468: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
10472: LD_INT 35
10474: PPUSH
10475: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
10479: LD_INT 1
10481: PPUSH
10482: LD_EXP 33
10486: PPUSH
10487: CALL_OW 292
10491: PUSH
10492: LD_EXP 33
10496: PPUSH
10497: LD_INT 7
10499: PPUSH
10500: CALL_OW 296
10504: PUSH
10505: LD_INT 17
10507: LESS
10508: OR
10509: IFFALSE 10472
// DialogueOn ;
10511: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10515: LD_EXP 33
10519: PPUSH
10520: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
10524: LD_EXP 33
10528: PPUSH
10529: LD_STRING D4Fb-Frank-1
10531: PPUSH
10532: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
10536: LD_EXP 21
10540: PPUSH
10541: LD_STRING D4Fb-JMM-1
10543: PPUSH
10544: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
10548: LD_INT 2
10550: PPUSH
10551: LD_STRING D4Fb-FSci1-1
10553: PPUSH
10554: CALL 15179 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
10558: LD_EXP 33
10562: PPUSH
10563: LD_STRING D4Fb-Frank-2
10565: PPUSH
10566: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
10570: LD_EXP 21
10574: PPUSH
10575: LD_STRING D4Fb-JMM-2
10577: PPUSH
10578: CALL_OW 88
// DialogueOff ;
10582: CALL_OW 7
// SetSide ( Frank , 1 ) ;
10586: LD_EXP 33
10590: PPUSH
10591: LD_INT 1
10593: PPUSH
10594: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
10598: LD_EXP 34
10602: PPUSH
10603: CALL_OW 302
10607: PUSH
10608: LD_EXP 33
10612: NOT
10613: AND
10614: IFFALSE 10762
// begin DialogueOn ;
10616: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
10620: LD_EXP 21
10624: PUSH
10625: LD_EXP 34
10629: PUSH
10630: EMPTY
10631: LIST
10632: LIST
10633: PPUSH
10634: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
10638: LD_EXP 34
10642: PPUSH
10643: LD_STRING D3Y-Yam-1
10645: PPUSH
10646: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
10650: LD_EXP 21
10654: PPUSH
10655: LD_STRING D3Y-JMM-1
10657: PPUSH
10658: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
10662: LD_EXP 34
10666: PPUSH
10667: LD_STRING D3Y-Yam-2
10669: PPUSH
10670: CALL_OW 88
// case Query ( QYamoko ) of 1 :
10674: LD_STRING QYamoko
10676: PPUSH
10677: CALL_OW 97
10681: PUSH
10682: LD_INT 1
10684: DOUBLE
10685: EQUAL
10686: IFTRUE 10690
10688: GO 10725
10690: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
10691: LD_EXP 21
10695: PPUSH
10696: LD_STRING D3Ya-JMM-1
10698: PPUSH
10699: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
10703: LD_EXP 34
10707: PPUSH
10708: LD_STRING D3Ya-Yam-1
10710: PPUSH
10711: CALL_OW 88
// us_scout := 1 ;
10715: LD_ADDR_EXP 8
10719: PUSH
10720: LD_INT 1
10722: ST_TO_ADDR
// end ; 2 :
10723: GO 10758
10725: LD_INT 2
10727: DOUBLE
10728: EQUAL
10729: IFTRUE 10733
10731: GO 10757
10733: POP
// begin us_scout := - 1 ;
10734: LD_ADDR_EXP 8
10738: PUSH
10739: LD_INT 1
10741: NEG
10742: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
10743: LD_EXP 21
10747: PPUSH
10748: LD_STRING D3Yb-JMM-1
10750: PPUSH
10751: CALL_OW 88
// end ; end ;
10755: GO 10758
10757: POP
// DialogueOff ;
10758: CALL_OW 7
// end ; if Frank then
10762: LD_EXP 33
10766: IFFALSE 10770
// exit ;
10768: GO 11531
// if us_scout in [ - 1 , 0 ] then
10770: LD_EXP 8
10774: PUSH
10775: LD_INT 1
10777: NEG
10778: PUSH
10779: LD_INT 0
10781: PUSH
10782: EMPTY
10783: LIST
10784: LIST
10785: IN
10786: IFFALSE 10790
// exit ;
10788: GO 11531
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
10790: LD_ADDR_EXP 8
10794: PUSH
10795: LD_INT 2
10797: PUSH
10798: LD_INT 2
10800: PUSH
10801: LD_INT 1
10803: PUSH
10804: EMPTY
10805: LIST
10806: LIST
10807: LIST
10808: PUSH
10809: LD_OWVAR 67
10813: ARRAY
10814: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
10815: LD_EXP 8
10819: PUSH
10820: LD_INT 1
10822: PUSH
10823: LD_INT 2
10825: PUSH
10826: EMPTY
10827: LIST
10828: LIST
10829: IN
10830: IFFALSE 11531
// begin if IsInUnit ( Kikuchi ) then
10832: LD_EXP 34
10836: PPUSH
10837: CALL_OW 310
10841: IFFALSE 10852
// ComExitBuilding ( Kikuchi ) ;
10843: LD_EXP 34
10847: PPUSH
10848: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
10852: LD_EXP 34
10856: PPUSH
10857: CALL_OW 311
10861: IFFALSE 10872
// ComExitVehicle ( Kikuchi ) ;
10863: LD_EXP 34
10867: PPUSH
10868: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
10872: LD_EXP 34
10876: PPUSH
10877: LD_INT 4
10879: PPUSH
10880: CALL_OW 235
// wait ( 0 0$1 ) ;
10884: LD_INT 35
10886: PPUSH
10887: CALL_OW 67
// if us_scout = 2 then
10891: LD_EXP 8
10895: PUSH
10896: LD_INT 2
10898: EQUAL
10899: IFFALSE 11279
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
10901: LD_EXP 34
10905: PPUSH
10906: LD_INT 75
10908: PPUSH
10909: LD_INT 63
10911: PPUSH
10912: CALL_OW 111
// AddComHold ( Kikuchi ) ;
10916: LD_EXP 34
10920: PPUSH
10921: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
10925: LD_EXP 34
10929: PPUSH
10930: LD_INT 770
10932: PPUSH
10933: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
10937: LD_EXP 34
10941: PPUSH
10942: LD_INT 100
10944: PPUSH
10945: LD_INT 75
10947: PPUSH
10948: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
10952: LD_EXP 34
10956: PPUSH
10957: LD_INT 123
10959: PPUSH
10960: LD_INT 103
10962: PPUSH
10963: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
10967: LD_EXP 34
10971: PPUSH
10972: LD_INT 138
10974: PPUSH
10975: LD_INT 108
10977: PPUSH
10978: CALL_OW 171
// AddComHold ( Kikuchi ) ;
10982: LD_EXP 34
10986: PPUSH
10987: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10991: LD_INT 35
10993: PPUSH
10994: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
10998: LD_EXP 34
11002: PPUSH
11003: LD_INT 138
11005: PPUSH
11006: LD_INT 108
11008: PPUSH
11009: CALL_OW 307
11013: IFFALSE 10991
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
11015: LD_EXP 34
11019: PPUSH
11020: LD_INT 125
11022: PPUSH
11023: LD_INT 132
11025: PPUSH
11026: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11030: LD_INT 35
11032: PPUSH
11033: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
11037: LD_INT 1
11039: PPUSH
11040: LD_EXP 34
11044: PPUSH
11045: CALL_OW 292
11049: PUSH
11050: LD_EXP 34
11054: PPUSH
11055: LD_INT 7
11057: PPUSH
11058: CALL_OW 296
11062: PUSH
11063: LD_INT 7
11065: LESS
11066: OR
11067: IFFALSE 11030
// DialogueOn ;
11069: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11073: LD_EXP 34
11077: PPUSH
11078: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11082: LD_INT 10
11084: PPUSH
11085: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
11089: LD_EXP 34
11093: PPUSH
11094: LD_STRING D4Ya-Yam-1
11096: PPUSH
11097: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
11101: LD_EXP 21
11105: PPUSH
11106: LD_STRING D4Ya-JMM-1
11108: PPUSH
11109: CALL_OW 88
// for i in points do
11113: LD_ADDR_VAR 0 1
11117: PUSH
11118: LD_VAR 0 2
11122: PUSH
11123: FOR_IN
11124: IFFALSE 11182
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11126: LD_VAR 0 1
11130: PUSH
11131: LD_INT 1
11133: ARRAY
11134: PPUSH
11135: LD_VAR 0 1
11139: PUSH
11140: LD_INT 2
11142: ARRAY
11143: PPUSH
11144: LD_INT 1
11146: PPUSH
11147: LD_INT 20
11149: NEG
11150: PPUSH
11151: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11155: LD_VAR 0 1
11159: PUSH
11160: LD_INT 1
11162: ARRAY
11163: PPUSH
11164: LD_VAR 0 1
11168: PUSH
11169: LD_INT 2
11171: ARRAY
11172: PPUSH
11173: LD_INT 1
11175: PPUSH
11176: CALL_OW 331
// end ;
11180: GO 11123
11182: POP
11183: POP
// dwait ( 0 0$0.5 ) ;
11184: LD_INT 18
11186: PPUSH
11187: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11191: LD_INT 42
11193: PPUSH
11194: LD_INT 27
11196: PPUSH
11197: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
11201: LD_EXP 34
11205: PPUSH
11206: LD_STRING D4Ya-Yam-2
11208: PPUSH
11209: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11213: LD_INT 18
11215: PPUSH
11216: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
11220: LD_INT 118
11222: PPUSH
11223: LD_INT 80
11225: PPUSH
11226: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
11230: LD_EXP 21
11234: PPUSH
11235: LD_STRING D4Ya-JMM-2
11237: PPUSH
11238: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
11242: LD_EXP 34
11246: PPUSH
11247: LD_STRING D4Ya-Yam-3
11249: PPUSH
11250: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11254: LD_INT 10
11256: PPUSH
11257: CALL_OW 68
// DialogueOff ;
11261: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
11265: LD_EXP 34
11269: PPUSH
11270: LD_INT 1
11272: PPUSH
11273: CALL_OW 235
// end else
11277: GO 11531
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11279: LD_INT 2
11281: PPUSH
11282: LD_INT 4
11284: PPUSH
11285: LD_INT 2
11287: PPUSH
11288: LD_INT 1
11290: PPUSH
11291: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
11295: LD_EXP 34
11299: PPUSH
11300: LD_INT 75
11302: PPUSH
11303: LD_INT 63
11305: PPUSH
11306: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
11310: LD_EXP 34
11314: PPUSH
11315: LD_INT 175
11317: PPUSH
11318: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
11322: LD_EXP 34
11326: PPUSH
11327: LD_INT 102
11329: PPUSH
11330: LD_INT 76
11332: PPUSH
11333: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
11337: LD_EXP 34
11341: PPUSH
11342: LD_INT 108
11344: PPUSH
11345: LD_INT 70
11347: PPUSH
11348: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11352: LD_INT 35
11354: PPUSH
11355: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
11359: LD_INT 2
11361: PPUSH
11362: LD_EXP 34
11366: PPUSH
11367: CALL_OW 292
11371: IFFALSE 11352
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
11373: LD_EXP 34
11377: PPUSH
11378: LD_INT 112
11380: PPUSH
11381: LD_INT 118
11383: PPUSH
11384: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
11388: LD_EXP 34
11392: PPUSH
11393: CALL_OW 256
11397: PUSH
11398: LD_INT 750
11400: GREATEREQUAL
11401: IFFALSE 11415
// SetLives ( Kikuchi , 700 ) ;
11403: LD_EXP 34
11407: PPUSH
11408: LD_INT 700
11410: PPUSH
11411: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11415: LD_INT 35
11417: PPUSH
11418: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
11422: LD_INT 1
11424: PPUSH
11425: LD_EXP 34
11429: PPUSH
11430: CALL_OW 292
11434: PUSH
11435: LD_EXP 34
11439: PPUSH
11440: LD_INT 7
11442: PPUSH
11443: CALL_OW 296
11447: PUSH
11448: LD_INT 17
11450: LESS
11451: OR
11452: IFFALSE 11415
// DialogueOn ;
11454: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11458: LD_EXP 34
11462: PPUSH
11463: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
11467: LD_EXP 34
11471: PPUSH
11472: LD_STRING D4Yb-Yam-1
11474: PPUSH
11475: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
11479: LD_EXP 21
11483: PPUSH
11484: LD_STRING D4Yb-JMM-1
11486: PPUSH
11487: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
11491: LD_EXP 34
11495: PPUSH
11496: LD_STRING D4Yb-Yam-2
11498: PPUSH
11499: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
11503: LD_EXP 21
11507: PPUSH
11508: LD_STRING D4Yb-JMM-2
11510: PPUSH
11511: CALL_OW 88
// DialogueOff ;
11515: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
11519: LD_EXP 34
11523: PPUSH
11524: LD_INT 1
11526: PPUSH
11527: CALL_OW 235
// end ; end ; end ;
11531: PPOPN 2
11533: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
11534: LD_EXP 6
11538: IFFALSE 12571
11540: GO 11542
11542: DISABLE
11543: LD_INT 0
11545: PPUSH
11546: PPUSH
11547: PPUSH
11548: PPUSH
// begin enable ;
11549: ENABLE
// if not seen [ 1 ] then
11550: LD_EXP 9
11554: PUSH
11555: LD_INT 1
11557: ARRAY
11558: NOT
11559: IFFALSE 11739
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
11561: LD_ADDR_VAR 0 2
11565: PUSH
11566: LD_INT 22
11568: PUSH
11569: LD_INT 2
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: PUSH
11576: LD_INT 2
11578: PUSH
11579: LD_INT 25
11581: PUSH
11582: LD_INT 11
11584: PUSH
11585: EMPTY
11586: LIST
11587: LIST
11588: PUSH
11589: LD_INT 33
11591: PUSH
11592: LD_INT 4
11594: PUSH
11595: EMPTY
11596: LIST
11597: LIST
11598: PUSH
11599: EMPTY
11600: LIST
11601: LIST
11602: LIST
11603: PUSH
11604: EMPTY
11605: LIST
11606: LIST
11607: PPUSH
11608: CALL_OW 69
11612: ST_TO_ADDR
// if tmp then
11613: LD_VAR 0 2
11617: IFFALSE 11739
// for i in tmp do
11619: LD_ADDR_VAR 0 1
11623: PUSH
11624: LD_VAR 0 2
11628: PUSH
11629: FOR_IN
11630: IFFALSE 11737
// if See ( 1 , i ) then
11632: LD_INT 1
11634: PPUSH
11635: LD_VAR 0 1
11639: PPUSH
11640: CALL_OW 292
11644: IFFALSE 11735
// begin seen := Replace ( seen , 1 , true ) ;
11646: LD_ADDR_EXP 9
11650: PUSH
11651: LD_EXP 9
11655: PPUSH
11656: LD_INT 1
11658: PPUSH
11659: LD_INT 1
11661: PPUSH
11662: CALL_OW 1
11666: ST_TO_ADDR
// if CanSayRand ( 1 ) then
11667: LD_INT 1
11669: PPUSH
11670: CALL 15001 0 1
11674: IFFALSE 11735
// begin DialogueOn ;
11676: CALL_OW 6
// CenterNowOnUnits ( i ) ;
11680: LD_VAR 0 1
11684: PPUSH
11685: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11689: LD_INT 10
11691: PPUSH
11692: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
11696: LD_ADDR_VAR 0 3
11700: PUSH
11701: LD_INT 1
11703: PPUSH
11704: LD_STRING D5a-Sol2-1
11706: PPUSH
11707: CALL 15179 0 2
11711: ST_TO_ADDR
// if not un then
11712: LD_VAR 0 3
11716: NOT
11717: IFFALSE 11729
// SayRand ( sex_female , D5a-FSol2-1 ) ;
11719: LD_INT 2
11721: PPUSH
11722: LD_STRING D5a-FSol2-1
11724: PPUSH
11725: CALL 15179 0 2
// DialogueOff ;
11729: CALL_OW 7
// break ;
11733: GO 11737
// end ; end ;
11735: GO 11629
11737: POP
11738: POP
// end ; if not seen [ 2 ] then
11739: LD_EXP 9
11743: PUSH
11744: LD_INT 2
11746: ARRAY
11747: NOT
11748: IFFALSE 11973
// begin can_kamikazed := true ;
11750: LD_ADDR_EXP 10
11754: PUSH
11755: LD_INT 1
11757: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
11758: LD_ADDR_VAR 0 2
11762: PUSH
11763: LD_INT 22
11765: PUSH
11766: LD_INT 2
11768: PUSH
11769: EMPTY
11770: LIST
11771: LIST
11772: PUSH
11773: LD_INT 25
11775: PUSH
11776: LD_INT 17
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: PUSH
11783: EMPTY
11784: LIST
11785: LIST
11786: PPUSH
11787: CALL_OW 69
11791: ST_TO_ADDR
// if tmp then
11792: LD_VAR 0 2
11796: IFFALSE 11973
// for i in tmp do
11798: LD_ADDR_VAR 0 1
11802: PUSH
11803: LD_VAR 0 2
11807: PUSH
11808: FOR_IN
11809: IFFALSE 11971
// if See ( 1 , i ) then
11811: LD_INT 1
11813: PPUSH
11814: LD_VAR 0 1
11818: PPUSH
11819: CALL_OW 292
11823: IFFALSE 11969
// begin seen := Replace ( seen , 2 , true ) ;
11825: LD_ADDR_EXP 9
11829: PUSH
11830: LD_EXP 9
11834: PPUSH
11835: LD_INT 2
11837: PPUSH
11838: LD_INT 1
11840: PPUSH
11841: CALL_OW 1
11845: ST_TO_ADDR
// if CanSayRand ( 1 ) then
11846: LD_INT 1
11848: PPUSH
11849: CALL 15001 0 1
11853: IFFALSE 11969
// begin DialogueOn ;
11855: CALL_OW 6
// CenterNowOnUnits ( i ) ;
11859: LD_VAR 0 1
11863: PPUSH
11864: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11868: LD_INT 10
11870: PPUSH
11871: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
11875: LD_ADDR_VAR 0 3
11879: PUSH
11880: LD_INT 1
11882: PPUSH
11883: LD_STRING D5b-Sol1-1
11885: PPUSH
11886: CALL 15179 0 2
11890: ST_TO_ADDR
// if not un then
11891: LD_VAR 0 3
11895: NOT
11896: IFFALSE 11914
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
11898: LD_ADDR_VAR 0 3
11902: PUSH
11903: LD_INT 2
11905: PPUSH
11906: LD_STRING D5b-FSol1-1
11908: PPUSH
11909: CALL 15179 0 2
11913: ST_TO_ADDR
// if un then
11914: LD_VAR 0 3
11918: IFFALSE 11963
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
11920: LD_ADDR_VAR 0 4
11924: PUSH
11925: LD_INT 1
11927: PPUSH
11928: LD_STRING D5b-Sol2-1
11930: PPUSH
11931: LD_VAR 0 3
11935: PPUSH
11936: CALL 15405 0 3
11940: ST_TO_ADDR
// if not un2 then
11941: LD_VAR 0 4
11945: NOT
11946: IFFALSE 11963
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
11948: LD_INT 2
11950: PPUSH
11951: LD_STRING D5b-FSol2-1
11953: PPUSH
11954: LD_VAR 0 3
11958: PPUSH
11959: CALL 15405 0 3
// end ; DialogueOff ;
11963: CALL_OW 7
// break ;
11967: GO 11971
// end ; end ;
11969: GO 11808
11971: POP
11972: POP
// end ; if not seen [ 3 ] then
11973: LD_EXP 9
11977: PUSH
11978: LD_INT 3
11980: ARRAY
11981: NOT
11982: IFFALSE 12156
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
11984: LD_ADDR_VAR 0 2
11988: PUSH
11989: LD_INT 22
11991: PUSH
11992: LD_INT 2
11994: PUSH
11995: EMPTY
11996: LIST
11997: LIST
11998: PUSH
11999: LD_INT 33
12001: PUSH
12002: LD_INT 2
12004: PUSH
12005: EMPTY
12006: LIST
12007: LIST
12008: PUSH
12009: EMPTY
12010: LIST
12011: LIST
12012: PPUSH
12013: CALL_OW 69
12017: ST_TO_ADDR
// if tmp then
12018: LD_VAR 0 2
12022: IFFALSE 12156
// for i in tmp do
12024: LD_ADDR_VAR 0 1
12028: PUSH
12029: LD_VAR 0 2
12033: PUSH
12034: FOR_IN
12035: IFFALSE 12154
// if See ( 1 , i ) then
12037: LD_INT 1
12039: PPUSH
12040: LD_VAR 0 1
12044: PPUSH
12045: CALL_OW 292
12049: IFFALSE 12152
// begin seen := Replace ( seen , 3 , true ) ;
12051: LD_ADDR_EXP 9
12055: PUSH
12056: LD_EXP 9
12060: PPUSH
12061: LD_INT 3
12063: PPUSH
12064: LD_INT 1
12066: PPUSH
12067: CALL_OW 1
12071: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12072: LD_INT 1
12074: PPUSH
12075: CALL 15001 0 1
12079: IFFALSE 12152
// begin DialogueOn ;
12081: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12085: LD_VAR 0 1
12089: PPUSH
12090: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12094: LD_INT 10
12096: PPUSH
12097: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
12101: LD_ADDR_VAR 0 3
12105: PUSH
12106: LD_INT 1
12108: PPUSH
12109: LD_STRING D8-Sol1-1
12111: PPUSH
12112: CALL 15179 0 2
12116: ST_TO_ADDR
// if not un then
12117: LD_VAR 0 3
12121: NOT
12122: IFFALSE 12134
// SayRand ( sex_female , D8-FSol1-1 ) ;
12124: LD_INT 2
12126: PPUSH
12127: LD_STRING D8-FSol1-1
12129: PPUSH
12130: CALL 15179 0 2
// Say ( JMM , D8-JMM-1 ) ;
12134: LD_EXP 21
12138: PPUSH
12139: LD_STRING D8-JMM-1
12141: PPUSH
12142: CALL_OW 88
// DialogueOff ;
12146: CALL_OW 7
// break ;
12150: GO 12154
// end ; end ;
12152: GO 12034
12154: POP
12155: POP
// end ; if not seen [ 4 ] then
12156: LD_EXP 9
12160: PUSH
12161: LD_INT 4
12163: ARRAY
12164: NOT
12165: IFFALSE 12327
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
12167: LD_ADDR_VAR 0 2
12171: PUSH
12172: LD_INT 22
12174: PUSH
12175: LD_INT 2
12177: PUSH
12178: EMPTY
12179: LIST
12180: LIST
12181: PUSH
12182: LD_INT 33
12184: PUSH
12185: LD_INT 5
12187: PUSH
12188: EMPTY
12189: LIST
12190: LIST
12191: PUSH
12192: EMPTY
12193: LIST
12194: LIST
12195: PPUSH
12196: CALL_OW 69
12200: ST_TO_ADDR
// if tmp then
12201: LD_VAR 0 2
12205: IFFALSE 12327
// for i in tmp do
12207: LD_ADDR_VAR 0 1
12211: PUSH
12212: LD_VAR 0 2
12216: PUSH
12217: FOR_IN
12218: IFFALSE 12325
// if See ( 1 , i ) then
12220: LD_INT 1
12222: PPUSH
12223: LD_VAR 0 1
12227: PPUSH
12228: CALL_OW 292
12232: IFFALSE 12323
// begin seen := Replace ( seen , 4 , true ) ;
12234: LD_ADDR_EXP 9
12238: PUSH
12239: LD_EXP 9
12243: PPUSH
12244: LD_INT 4
12246: PPUSH
12247: LD_INT 1
12249: PPUSH
12250: CALL_OW 1
12254: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12255: LD_INT 1
12257: PPUSH
12258: CALL 15001 0 1
12262: IFFALSE 12323
// begin DialogueOn ;
12264: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12268: LD_VAR 0 1
12272: PPUSH
12273: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12277: LD_INT 10
12279: PPUSH
12280: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
12284: LD_ADDR_VAR 0 3
12288: PUSH
12289: LD_INT 1
12291: PPUSH
12292: LD_STRING D5a-Sol1-1
12294: PPUSH
12295: CALL 15179 0 2
12299: ST_TO_ADDR
// if not un then
12300: LD_VAR 0 3
12304: NOT
12305: IFFALSE 12317
// SayRand ( sex_female , D5a-FSol1-1 ) ;
12307: LD_INT 2
12309: PPUSH
12310: LD_STRING D5a-FSol1-1
12312: PPUSH
12313: CALL 15179 0 2
// DialogueOff ;
12317: CALL_OW 7
// break ;
12321: GO 12325
// end ; end ;
12323: GO 12217
12325: POP
12326: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
12327: LD_EXP 9
12331: PUSH
12332: LD_INT 5
12334: ARRAY
12335: NOT
12336: PUSH
12337: LD_EXP 9
12341: PUSH
12342: LD_INT 3
12344: ARRAY
12345: AND
12346: IFFALSE 12520
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
12348: LD_ADDR_VAR 0 2
12352: PUSH
12353: LD_INT 22
12355: PUSH
12356: LD_INT 2
12358: PUSH
12359: EMPTY
12360: LIST
12361: LIST
12362: PUSH
12363: LD_INT 34
12365: PUSH
12366: LD_INT 31
12368: PUSH
12369: EMPTY
12370: LIST
12371: LIST
12372: PUSH
12373: EMPTY
12374: LIST
12375: LIST
12376: PPUSH
12377: CALL_OW 69
12381: ST_TO_ADDR
// if tmp then
12382: LD_VAR 0 2
12386: IFFALSE 12520
// for i in tmp do
12388: LD_ADDR_VAR 0 1
12392: PUSH
12393: LD_VAR 0 2
12397: PUSH
12398: FOR_IN
12399: IFFALSE 12518
// if See ( 1 , i ) then
12401: LD_INT 1
12403: PPUSH
12404: LD_VAR 0 1
12408: PPUSH
12409: CALL_OW 292
12413: IFFALSE 12516
// begin seen := Replace ( seen , 5 , true ) ;
12415: LD_ADDR_EXP 9
12419: PUSH
12420: LD_EXP 9
12424: PPUSH
12425: LD_INT 5
12427: PPUSH
12428: LD_INT 1
12430: PPUSH
12431: CALL_OW 1
12435: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12436: LD_INT 1
12438: PPUSH
12439: CALL 15001 0 1
12443: IFFALSE 12516
// begin DialogueOn ;
12445: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12449: LD_VAR 0 1
12453: PPUSH
12454: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12458: LD_INT 10
12460: PPUSH
12461: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
12465: LD_ADDR_VAR 0 3
12469: PUSH
12470: LD_INT 1
12472: PPUSH
12473: LD_STRING D8a-Sol2-1
12475: PPUSH
12476: CALL 15179 0 2
12480: ST_TO_ADDR
// if not un then
12481: LD_VAR 0 3
12485: NOT
12486: IFFALSE 12498
// SayRand ( sex_female , D8a-FSol2-1 ) ;
12488: LD_INT 2
12490: PPUSH
12491: LD_STRING D8a-FSol2-1
12493: PPUSH
12494: CALL 15179 0 2
// Say ( JMM , D8a-JMM-1 ) ;
12498: LD_EXP 21
12502: PPUSH
12503: LD_STRING D8a-JMM-1
12505: PPUSH
12506: CALL_OW 88
// DialogueOff ;
12510: CALL_OW 7
// break ;
12514: GO 12518
// end ; end ;
12516: GO 12398
12518: POP
12519: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
12520: LD_EXP 9
12524: PUSH
12525: LD_INT 1
12527: ARRAY
12528: PUSH
12529: LD_EXP 9
12533: PUSH
12534: LD_INT 2
12536: ARRAY
12537: AND
12538: PUSH
12539: LD_EXP 9
12543: PUSH
12544: LD_INT 3
12546: ARRAY
12547: AND
12548: PUSH
12549: LD_EXP 9
12553: PUSH
12554: LD_INT 4
12556: ARRAY
12557: AND
12558: PUSH
12559: LD_EXP 9
12563: PUSH
12564: LD_INT 5
12566: ARRAY
12567: AND
12568: IFFALSE 12571
// disable ;
12570: DISABLE
// end ;
12571: PPOPN 4
12573: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
12574: LD_EXP 10
12578: PUSH
12579: LD_EXP 11
12583: AND
12584: IFFALSE 12782
12586: GO 12588
12588: DISABLE
12589: LD_INT 0
12591: PPUSH
// begin DialogueOn ;
12592: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
12596: LD_EXP 11
12600: PPUSH
12601: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
12605: LD_ADDR_VAR 0 1
12609: PUSH
12610: LD_INT 1
12612: PPUSH
12613: LD_STRING D5c-Sol1-1
12615: PPUSH
12616: CALL 15179 0 2
12620: ST_TO_ADDR
// if not un then
12621: LD_VAR 0 1
12625: NOT
12626: IFFALSE 12644
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
12628: LD_ADDR_VAR 0 1
12632: PUSH
12633: LD_INT 2
12635: PPUSH
12636: LD_STRING D5c-FSol1-1
12638: PPUSH
12639: CALL 15179 0 2
12643: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
12644: LD_EXP 21
12648: PPUSH
12649: LD_STRING D5c-JMM-1
12651: PPUSH
12652: CALL_OW 88
// if IsOk ( Lisa ) then
12656: LD_EXP 22
12660: PPUSH
12661: CALL_OW 302
12665: IFFALSE 12681
// Say ( Lisa , D5d-Lisa-1 ) else
12667: LD_EXP 22
12671: PPUSH
12672: LD_STRING D5d-Lisa-1
12674: PPUSH
12675: CALL_OW 88
12679: GO 12766
// if IsOk ( Cyrus ) then
12681: LD_EXP 25
12685: PPUSH
12686: CALL_OW 302
12690: IFFALSE 12706
// Say ( Cyrus , D5d-Cyrus-1 ) else
12692: LD_EXP 25
12696: PPUSH
12697: LD_STRING D5d-Cyrus-1
12699: PPUSH
12700: CALL_OW 88
12704: GO 12766
// if IsOk ( Gary ) then
12706: LD_EXP 32
12710: PPUSH
12711: CALL_OW 302
12715: IFFALSE 12731
// Say ( Gary , D5d-Gary-1 ) else
12717: LD_EXP 32
12721: PPUSH
12722: LD_STRING D5d-Gary-1
12724: PPUSH
12725: CALL_OW 88
12729: GO 12766
// if GetSex ( un ) = sex_male then
12731: LD_VAR 0 1
12735: PPUSH
12736: CALL_OW 258
12740: PUSH
12741: LD_INT 1
12743: EQUAL
12744: IFFALSE 12760
// Say ( un , D5d-Sol1-1 ) else
12746: LD_VAR 0 1
12750: PPUSH
12751: LD_STRING D5d-Sol1-1
12753: PPUSH
12754: CALL_OW 88
12758: GO 12766
// begin DialogueOff ;
12760: CALL_OW 7
// exit ;
12764: GO 12782
// end ; Say ( JMM , D5d-JMM-1 ) ;
12766: LD_EXP 21
12770: PPUSH
12771: LD_STRING D5d-JMM-1
12773: PPUSH
12774: CALL_OW 88
// DialogueOff ;
12778: CALL_OW 7
// end ;
12782: PPOPN 1
12784: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
12785: LD_INT 1
12787: PPUSH
12788: LD_INT 17
12790: PPUSH
12791: CALL_OW 294
12795: PUSH
12796: LD_INT 2
12798: GREATEREQUAL
12799: IFFALSE 12920
12801: GO 12803
12803: DISABLE
12804: LD_INT 0
12806: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
12807: LD_INT 10
12809: PPUSH
12810: LD_INT 5
12812: PPUSH
12813: LD_INT 1
12815: PPUSH
12816: LD_INT 10
12818: NEG
12819: PPUSH
12820: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
12824: LD_INT 10
12826: PPUSH
12827: LD_INT 5
12829: PPUSH
12830: LD_INT 1
12832: PPUSH
12833: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
12837: LD_INT 10
12839: PPUSH
12840: LD_INT 5
12842: PPUSH
12843: CALL_OW 86
// DialogueOn ;
12847: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
12851: LD_ADDR_VAR 0 1
12855: PUSH
12856: LD_INT 1
12858: PPUSH
12859: LD_STRING D6-Sci1-1
12861: PPUSH
12862: CALL 15179 0 2
12866: ST_TO_ADDR
// if un then
12867: LD_VAR 0 1
12871: IFFALSE 12909
// begin Say ( JMM , D6-JMM-1 ) ;
12873: LD_EXP 21
12877: PPUSH
12878: LD_STRING D6-JMM-1
12880: PPUSH
12881: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
12885: LD_VAR 0 1
12889: PPUSH
12890: LD_STRING D6-Sci1-2
12892: PPUSH
12893: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
12897: LD_EXP 21
12901: PPUSH
12902: LD_STRING D6-JMM-2
12904: PPUSH
12905: CALL_OW 88
// end ; DialogueOff ;
12909: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
12913: LD_STRING M3
12915: PPUSH
12916: CALL_OW 337
// end ;
12920: PPOPN 1
12922: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp ;
12923: LD_OWVAR 1
12927: PUSH
12928: LD_INT 42000
12930: GREATEREQUAL
12931: PUSH
12932: LD_INT 2
12934: PPUSH
12935: LD_INT 169
12937: PPUSH
12938: LD_INT 90
12940: PPUSH
12941: LD_INT 10
12943: PPUSH
12944: CALL 51351 0 4
12948: PUSH
12949: LD_INT 4
12951: ARRAY
12952: PUSH
12953: LD_INT 0
12955: EQUAL
12956: PUSH
12957: LD_INT 45
12959: PPUSH
12960: CALL_OW 301
12964: OR
12965: PUSH
12966: LD_INT 45
12968: PPUSH
12969: CALL_OW 255
12973: PUSH
12974: LD_INT 1
12976: EQUAL
12977: OR
12978: AND
12979: PUSH
12980: LD_INT 94
12982: PPUSH
12983: CALL_OW 301
12987: NOT
12988: AND
12989: IFFALSE 14115
12991: GO 12993
12993: DISABLE
12994: LD_INT 0
12996: PPUSH
12997: PPUSH
12998: PPUSH
12999: PPUSH
// begin uc_side := 5 ;
13000: LD_ADDR_OWVAR 20
13004: PUSH
13005: LD_INT 5
13007: ST_TO_ADDR
// uc_nation := 2 ;
13008: LD_ADDR_OWVAR 21
13012: PUSH
13013: LD_INT 2
13015: ST_TO_ADDR
// InitHc ;
13016: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
13020: LD_INT 1
13022: PPUSH
13023: LD_INT 3
13025: PPUSH
13026: LD_INT 8
13028: PPUSH
13029: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13033: LD_ADDR_OWVAR 29
13037: PUSH
13038: LD_INT 12
13040: PUSH
13041: LD_INT 12
13043: PUSH
13044: EMPTY
13045: LIST
13046: LIST
13047: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13048: LD_ADDR_OWVAR 33
13052: PUSH
13053: LD_STRING SecondCharsGal
13055: ST_TO_ADDR
// hc_face_number := 7 ;
13056: LD_ADDR_OWVAR 34
13060: PUSH
13061: LD_INT 7
13063: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
13064: LD_ADDR_EXP 45
13068: PUSH
13069: CALL_OW 44
13073: ST_TO_ADDR
// InitHc ;
13074: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
13078: LD_INT 1
13080: PPUSH
13081: LD_INT 16
13083: PPUSH
13084: LD_INT 2
13086: PPUSH
13087: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13091: LD_ADDR_OWVAR 29
13095: PUSH
13096: LD_INT 12
13098: PUSH
13099: LD_INT 12
13101: PUSH
13102: EMPTY
13103: LIST
13104: LIST
13105: ST_TO_ADDR
// hc_name :=  ;
13106: LD_ADDR_OWVAR 26
13110: PUSH
13111: LD_STRING 
13113: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
13114: LD_ADDR_EXP 46
13118: PUSH
13119: CALL_OW 44
13123: ST_TO_ADDR
// InitHc ;
13124: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
13128: LD_INT 35
13130: PPUSH
13131: CALL_OW 67
// until not InBattle ( 1 ) ;
13135: LD_INT 1
13137: PPUSH
13138: CALL_OW 463
13142: NOT
13143: IFFALSE 13128
// wait ( 0 0$5 ) ;
13145: LD_INT 175
13147: PPUSH
13148: CALL_OW 67
// DialogueOn ;
13152: CALL_OW 6
// InGameOn ;
13156: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
13160: LD_ADDR_VAR 0 1
13164: PUSH
13165: LD_INT 22
13167: PUSH
13168: LD_INT 1
13170: PUSH
13171: EMPTY
13172: LIST
13173: LIST
13174: PUSH
13175: LD_INT 2
13177: PUSH
13178: LD_INT 25
13180: PUSH
13181: LD_INT 1
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: PUSH
13188: LD_INT 25
13190: PUSH
13191: LD_INT 2
13193: PUSH
13194: EMPTY
13195: LIST
13196: LIST
13197: PUSH
13198: LD_INT 25
13200: PUSH
13201: LD_INT 3
13203: PUSH
13204: EMPTY
13205: LIST
13206: LIST
13207: PUSH
13208: LD_INT 25
13210: PUSH
13211: LD_INT 4
13213: PUSH
13214: EMPTY
13215: LIST
13216: LIST
13217: PUSH
13218: LD_INT 25
13220: PUSH
13221: LD_INT 5
13223: PUSH
13224: EMPTY
13225: LIST
13226: LIST
13227: PUSH
13228: LD_INT 25
13230: PUSH
13231: LD_INT 8
13233: PUSH
13234: EMPTY
13235: LIST
13236: LIST
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: LIST
13242: LIST
13243: LIST
13244: LIST
13245: LIST
13246: PUSH
13247: EMPTY
13248: LIST
13249: LIST
13250: PPUSH
13251: CALL_OW 69
13255: PUSH
13256: LD_EXP 21
13260: PUSH
13261: LD_EXP 22
13265: PUSH
13266: LD_EXP 23
13270: PUSH
13271: LD_EXP 24
13275: PUSH
13276: LD_EXP 25
13280: PUSH
13281: LD_EXP 26
13285: PUSH
13286: LD_EXP 27
13290: PUSH
13291: LD_EXP 28
13295: PUSH
13296: LD_EXP 29
13300: PUSH
13301: LD_EXP 31
13305: PUSH
13306: LD_EXP 32
13310: PUSH
13311: LD_EXP 33
13315: PUSH
13316: LD_EXP 34
13320: PUSH
13321: EMPTY
13322: LIST
13323: LIST
13324: LIST
13325: LIST
13326: LIST
13327: LIST
13328: LIST
13329: LIST
13330: LIST
13331: LIST
13332: LIST
13333: LIST
13334: LIST
13335: DIFF
13336: PPUSH
13337: LD_INT 26
13339: PUSH
13340: LD_INT 1
13342: PUSH
13343: EMPTY
13344: LIST
13345: LIST
13346: PPUSH
13347: CALL_OW 72
13351: PUSH
13352: LD_INT 1
13354: ARRAY
13355: ST_TO_ADDR
// if not un and Brown then
13356: LD_VAR 0 1
13360: NOT
13361: PUSH
13362: LD_EXP 27
13366: AND
13367: IFFALSE 13379
// un := Brown ;
13369: LD_ADDR_VAR 0 1
13373: PUSH
13374: LD_EXP 27
13378: ST_TO_ADDR
// if un then
13379: LD_VAR 0 1
13383: IFFALSE 13409
// begin Say ( un , D7-Sol1-1 ) ;
13385: LD_VAR 0 1
13389: PPUSH
13390: LD_STRING D7-Sol1-1
13392: PPUSH
13393: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
13397: LD_EXP 21
13401: PPUSH
13402: LD_STRING D7-JMM-1
13404: PPUSH
13405: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
13409: LD_EXP 45
13413: PPUSH
13414: LD_STRING D7-Ar1-1
13416: PPUSH
13417: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
13421: LD_EXP 21
13425: PPUSH
13426: LD_STRING D7-JMM-2
13428: PPUSH
13429: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
13433: LD_EXP 45
13437: PPUSH
13438: LD_STRING D7-Ar1-2
13440: PPUSH
13441: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
13445: LD_EXP 21
13449: PPUSH
13450: LD_STRING D7-JMM-3
13452: PPUSH
13453: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
13457: LD_EXP 45
13461: PPUSH
13462: LD_STRING D7-Ar1-3
13464: PPUSH
13465: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
13469: LD_EXP 21
13473: PPUSH
13474: LD_STRING D7-JMM-4
13476: PPUSH
13477: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
13481: LD_EXP 45
13485: PPUSH
13486: LD_STRING D7-Ar1-4
13488: PPUSH
13489: CALL_OW 94
// InGameOff ;
13493: CALL_OW 9
// DialogueOff ;
13497: CALL_OW 7
// case Query ( QCameras ) of 1 :
13501: LD_STRING QCameras
13503: PPUSH
13504: CALL_OW 97
13508: PUSH
13509: LD_INT 1
13511: DOUBLE
13512: EQUAL
13513: IFTRUE 13517
13515: GO 13520
13517: POP
// ; 2 :
13518: GO 13534
13520: LD_INT 2
13522: DOUBLE
13523: EQUAL
13524: IFTRUE 13528
13526: GO 13533
13528: POP
// exit ; end ;
13529: GO 14115
13531: GO 13534
13533: POP
// ChangeMissionObjectives ( MCar ) ;
13534: LD_STRING MCar
13536: PPUSH
13537: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
13541: LD_INT 124
13543: PPUSH
13544: LD_INT 90
13546: PPUSH
13547: LD_INT 1
13549: PPUSH
13550: LD_INT 6
13552: NEG
13553: PPUSH
13554: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
13558: LD_INT 124
13560: PPUSH
13561: LD_INT 90
13563: PPUSH
13564: LD_INT 1
13566: PPUSH
13567: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
13571: LD_INT 12
13573: PPUSH
13574: LD_INT 1
13576: PPUSH
13577: CALL_OW 424
// wait ( 3 ) ;
13581: LD_INT 3
13583: PPUSH
13584: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
13588: LD_INT 124
13590: PPUSH
13591: LD_INT 90
13593: PPUSH
13594: CALL_OW 86
// cargo := false ;
13598: LD_ADDR_VAR 0 3
13602: PUSH
13603: LD_INT 0
13605: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
13606: LD_INT 35
13608: PPUSH
13609: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
13613: LD_ADDR_VAR 0 3
13617: PUSH
13618: LD_INT 12
13620: PPUSH
13621: LD_INT 32
13623: PUSH
13624: LD_INT 3
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: LD_INT 34
13633: PUSH
13634: LD_INT 32
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: PUSH
13641: LD_INT 58
13643: PUSH
13644: EMPTY
13645: LIST
13646: PUSH
13647: EMPTY
13648: LIST
13649: LIST
13650: LIST
13651: PPUSH
13652: CALL_OW 70
13656: ST_TO_ADDR
// until cargo ;
13657: LD_VAR 0 3
13661: IFFALSE 13606
// cargo := cargo [ 1 ] ;
13663: LD_ADDR_VAR 0 3
13667: PUSH
13668: LD_VAR 0 3
13672: PUSH
13673: LD_INT 1
13675: ARRAY
13676: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
13677: LD_VAR 0 3
13681: PPUSH
13682: LD_INT 5
13684: PPUSH
13685: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
13689: LD_INT 12
13691: PPUSH
13692: LD_INT 0
13694: PPUSH
13695: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
13699: LD_EXP 45
13703: PPUSH
13704: LD_INT 11
13706: PPUSH
13707: LD_INT 0
13709: PPUSH
13710: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
13714: LD_EXP 46
13718: PPUSH
13719: LD_INT 11
13721: PPUSH
13722: LD_INT 0
13724: PPUSH
13725: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
13729: LD_EXP 45
13733: PUSH
13734: LD_EXP 46
13738: PUSH
13739: EMPTY
13740: LIST
13741: LIST
13742: PPUSH
13743: LD_INT 12
13745: PPUSH
13746: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
13750: LD_EXP 45
13754: PPUSH
13755: LD_VAR 0 3
13759: PPUSH
13760: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
13764: LD_EXP 45
13768: PUSH
13769: LD_EXP 46
13773: PUSH
13774: EMPTY
13775: LIST
13776: LIST
13777: PPUSH
13778: LD_INT 209
13780: PPUSH
13781: LD_INT 178
13783: PPUSH
13784: CALL_OW 171
// while ( true ) do
13788: LD_INT 1
13790: IFFALSE 13944
// begin wait ( 0 0$1 ) ;
13792: LD_INT 35
13794: PPUSH
13795: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
13799: LD_EXP 45
13803: PPUSH
13804: CALL_OW 314
13808: NOT
13809: PUSH
13810: LD_EXP 46
13814: PPUSH
13815: CALL_OW 314
13819: NOT
13820: OR
13821: IFFALSE 13847
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
13823: LD_EXP 45
13827: PUSH
13828: LD_EXP 46
13832: PUSH
13833: EMPTY
13834: LIST
13835: LIST
13836: PPUSH
13837: LD_INT 209
13839: PPUSH
13840: LD_INT 178
13842: PPUSH
13843: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
13847: LD_EXP 45
13851: PPUSH
13852: LD_INT 10
13854: PPUSH
13855: CALL_OW 308
13859: IFFALSE 13870
// RemoveUnit ( ar_mechanic ) ;
13861: LD_EXP 45
13865: PPUSH
13866: CALL_OW 64
// if IsInArea ( ar_mechanic_friend , escape_area ) then
13870: LD_EXP 46
13874: PPUSH
13875: LD_INT 10
13877: PPUSH
13878: CALL_OW 308
13882: IFFALSE 13893
// RemoveUnit ( ar_mechanic_friend ) ;
13884: LD_EXP 46
13888: PPUSH
13889: CALL_OW 64
// if IsInArea ( cargo , escape_area ) then
13893: LD_VAR 0 3
13897: PPUSH
13898: LD_INT 10
13900: PPUSH
13901: CALL_OW 308
13905: IFFALSE 13916
// RemoveUnit ( cargo ) ;
13907: LD_VAR 0 3
13911: PPUSH
13912: CALL_OW 64
// if not IsLive ( ar_mechanic ) and not IsLive ( ar_mechanic_friend ) then
13916: LD_EXP 45
13920: PPUSH
13921: CALL_OW 300
13925: NOT
13926: PUSH
13927: LD_EXP 46
13931: PPUSH
13932: CALL_OW 300
13936: NOT
13937: AND
13938: IFFALSE 13942
// break ;
13940: GO 13944
// end ;
13942: GO 13788
// wait ( 0 0$2 ) ;
13944: LD_INT 70
13946: PPUSH
13947: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
13951: LD_EXP 45
13955: PPUSH
13956: LD_STRING D7a-Ar1-1
13958: PPUSH
13959: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
13963: LD_ADDR_VAR 0 4
13967: PUSH
13968: LD_INT 129
13970: PUSH
13971: LD_INT 10
13973: PUSH
13974: EMPTY
13975: LIST
13976: LIST
13977: PUSH
13978: LD_INT 103
13980: PUSH
13981: LD_INT 6
13983: PUSH
13984: EMPTY
13985: LIST
13986: LIST
13987: PUSH
13988: LD_INT 148
13990: PUSH
13991: LD_INT 47
13993: PUSH
13994: EMPTY
13995: LIST
13996: LIST
13997: PUSH
13998: LD_INT 155
14000: PUSH
14001: LD_INT 16
14003: PUSH
14004: EMPTY
14005: LIST
14006: LIST
14007: PUSH
14008: EMPTY
14009: LIST
14010: LIST
14011: LIST
14012: LIST
14013: ST_TO_ADDR
// if Difficulty = 1 then
14014: LD_OWVAR 67
14018: PUSH
14019: LD_INT 1
14021: EQUAL
14022: IFFALSE 14059
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
14024: LD_ADDR_VAR 0 4
14028: PUSH
14029: LD_VAR 0 4
14033: PUSH
14034: LD_INT 78
14036: PUSH
14037: LD_INT 7
14039: PUSH
14040: EMPTY
14041: LIST
14042: LIST
14043: PUSH
14044: LD_INT 104
14046: PUSH
14047: LD_INT 43
14049: PUSH
14050: EMPTY
14051: LIST
14052: LIST
14053: PUSH
14054: EMPTY
14055: LIST
14056: LIST
14057: ADD
14058: ST_TO_ADDR
// for i in tmp do
14059: LD_ADDR_VAR 0 2
14063: PUSH
14064: LD_VAR 0 4
14068: PUSH
14069: FOR_IN
14070: IFFALSE 14103
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
14072: LD_VAR 0 2
14076: PUSH
14077: LD_INT 1
14079: ARRAY
14080: PPUSH
14081: LD_VAR 0 2
14085: PUSH
14086: LD_INT 2
14088: ARRAY
14089: PPUSH
14090: LD_INT 1
14092: PPUSH
14093: LD_INT 9
14095: NEG
14096: PPUSH
14097: CALL_OW 330
14101: GO 14069
14103: POP
14104: POP
// CenterOnXY ( 129 , 10 ) ;
14105: LD_INT 129
14107: PPUSH
14108: LD_INT 10
14110: PPUSH
14111: CALL_OW 84
// end ;
14115: PPOPN 4
14117: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
14118: LD_EXP 15
14122: PUSH
14123: LD_INT 21000
14125: MINUS
14126: PUSH
14127: LD_OWVAR 1
14131: LESSEQUAL
14132: IFFALSE 14172
14134: GO 14136
14136: DISABLE
// begin powell_warn := true ;
14137: LD_ADDR_EXP 16
14141: PUSH
14142: LD_INT 1
14144: ST_TO_ADDR
// DialogueOn ;
14145: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
14149: LD_EXP 30
14153: PPUSH
14154: LD_STRING D9-Pow-1
14156: PPUSH
14157: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
14161: LD_INT 10
14163: PPUSH
14164: CALL_OW 68
// DialogueOff ;
14168: CALL_OW 7
// end ;
14172: END
// every 0 0$1 trigger game_time <= tick do
14173: LD_EXP 15
14177: PUSH
14178: LD_OWVAR 1
14182: LESSEQUAL
14183: IFFALSE 14222
14185: GO 14187
14187: DISABLE
// begin DialogueOn ;
14188: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
14192: LD_EXP 30
14196: PPUSH
14197: LD_STRING D9a-Pow-1
14199: PPUSH
14200: CALL_OW 94
// dwait ( 0 0$2 ) ;
14204: LD_INT 70
14206: PPUSH
14207: CALL_OW 68
// DialogueOff ;
14211: CALL_OW 7
// YouLost ( Command ) ;
14215: LD_STRING Command
14217: PPUSH
14218: CALL_OW 104
// end ;
14222: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp ;
14223: LD_INT 22
14225: PUSH
14226: LD_INT 2
14228: PUSH
14229: EMPTY
14230: LIST
14231: LIST
14232: PUSH
14233: LD_INT 30
14235: PUSH
14236: LD_INT 1
14238: PUSH
14239: EMPTY
14240: LIST
14241: LIST
14242: PUSH
14243: EMPTY
14244: LIST
14245: LIST
14246: PPUSH
14247: CALL_OW 69
14251: PUSH
14252: LD_INT 0
14254: EQUAL
14255: PUSH
14256: LD_EXP 21
14260: PPUSH
14261: CALL_OW 302
14265: AND
14266: IFFALSE 14998
14268: GO 14270
14270: DISABLE
14271: LD_INT 0
14273: PPUSH
// begin if tick < [ 70 70$00 , 60 60$00 , 55 55$00 ] [ Difficulty ] then
14274: LD_OWVAR 1
14278: PUSH
14279: LD_INT 147000
14281: PUSH
14282: LD_INT 126000
14284: PUSH
14285: LD_INT 115500
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: LIST
14292: PUSH
14293: LD_OWVAR 67
14297: ARRAY
14298: LESS
14299: IFFALSE 14313
// AddMedal ( Time1 , 1 ) else
14301: LD_STRING Time1
14303: PPUSH
14304: LD_INT 1
14306: PPUSH
14307: CALL_OW 101
14311: GO 14344
// if not powell_warn then
14313: LD_EXP 16
14317: NOT
14318: IFFALSE 14333
// AddMedal ( Time1 , - 1 ) else
14320: LD_STRING Time1
14322: PPUSH
14323: LD_INT 1
14325: NEG
14326: PPUSH
14327: CALL_OW 101
14331: GO 14344
// AddMedal ( Time1 , - 2 ) ;
14333: LD_STRING Time1
14335: PPUSH
14336: LD_INT 2
14338: NEG
14339: PPUSH
14340: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
14344: LD_EXP 17
14348: PUSH
14349: LD_INT 5
14351: PUSH
14352: LD_INT 4
14354: PUSH
14355: LD_INT 3
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: LIST
14362: PUSH
14363: LD_OWVAR 67
14367: ARRAY
14368: GREATEREQUAL
14369: IFFALSE 14384
// AddMedal ( Destroy , - 2 ) else
14371: LD_STRING Destroy
14373: PPUSH
14374: LD_INT 2
14376: NEG
14377: PPUSH
14378: CALL_OW 101
14382: GO 14501
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
14384: LD_INT 22
14386: PUSH
14387: LD_INT 2
14389: PUSH
14390: EMPTY
14391: LIST
14392: LIST
14393: PUSH
14394: LD_INT 21
14396: PUSH
14397: LD_INT 3
14399: PUSH
14400: EMPTY
14401: LIST
14402: LIST
14403: PUSH
14404: LD_INT 50
14406: PUSH
14407: EMPTY
14408: LIST
14409: PUSH
14410: EMPTY
14411: LIST
14412: LIST
14413: LIST
14414: PPUSH
14415: CALL_OW 69
14419: PUSH
14420: LD_INT 25
14422: GREATEREQUAL
14423: IFFALSE 14438
// AddMedal ( Destroy , - 1 ) else
14425: LD_STRING Destroy
14427: PPUSH
14428: LD_INT 1
14430: NEG
14431: PPUSH
14432: CALL_OW 101
14436: GO 14501
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
14438: LD_INT 22
14440: PUSH
14441: LD_INT 2
14443: PUSH
14444: EMPTY
14445: LIST
14446: LIST
14447: PUSH
14448: LD_INT 21
14450: PUSH
14451: LD_INT 3
14453: PUSH
14454: EMPTY
14455: LIST
14456: LIST
14457: PUSH
14458: LD_INT 50
14460: PUSH
14461: EMPTY
14462: LIST
14463: PUSH
14464: EMPTY
14465: LIST
14466: LIST
14467: LIST
14468: PPUSH
14469: CALL_OW 69
14473: PUSH
14474: LD_INT 15
14476: GREATEREQUAL
14477: IFFALSE 14491
// AddMedal ( Destroy , 1 ) else
14479: LD_STRING Destroy
14481: PPUSH
14482: LD_INT 1
14484: PPUSH
14485: CALL_OW 101
14489: GO 14501
// AddMedal ( Destroy , 2 ) ;
14491: LD_STRING Destroy
14493: PPUSH
14494: LD_INT 2
14496: PPUSH
14497: CALL_OW 101
// SaveVariable ( artifact_get , 11_artifact_captured ) ;
14501: LD_EXP 13
14505: PPUSH
14506: LD_STRING 11_artifact_captured
14508: PPUSH
14509: CALL_OW 39
// if artifact_get then
14513: LD_EXP 13
14517: IFFALSE 14531
// AddMedal ( Artefact , 1 ) else
14519: LD_STRING Artefact
14521: PPUSH
14522: LD_INT 1
14524: PPUSH
14525: CALL_OW 101
14529: GO 14542
// AddMedal ( Artefact , - 1 ) ;
14531: LD_STRING Artefact
14533: PPUSH
14534: LD_INT 1
14536: NEG
14537: PPUSH
14538: CALL_OW 101
// GiveMedals ( MAIN ) ;
14542: LD_STRING MAIN
14544: PPUSH
14545: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
14549: LD_ADDR_EXP 20
14553: PUSH
14554: LD_EXP 20
14558: PPUSH
14559: LD_INT 51
14561: PUSH
14562: EMPTY
14563: LIST
14564: PPUSH
14565: CALL_OW 72
14569: ST_TO_ADDR
// tmp := JMM ^ selected ;
14570: LD_ADDR_VAR 0 1
14574: PUSH
14575: LD_EXP 21
14579: PUSH
14580: LD_EXP 20
14584: ADD
14585: ST_TO_ADDR
// RewardPeople ( tmp ) ;
14586: LD_VAR 0 1
14590: PPUSH
14591: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
14595: LD_VAR 0 1
14599: PUSH
14600: LD_EXP 21
14604: PUSH
14605: LD_EXP 22
14609: PUSH
14610: LD_EXP 23
14614: PUSH
14615: LD_EXP 24
14619: PUSH
14620: LD_EXP 25
14624: PUSH
14625: LD_EXP 26
14629: PUSH
14630: LD_EXP 27
14634: PUSH
14635: LD_EXP 28
14639: PUSH
14640: LD_EXP 29
14644: PUSH
14645: LD_EXP 31
14649: PUSH
14650: LD_EXP 32
14654: PUSH
14655: LD_EXP 33
14659: PUSH
14660: LD_EXP 34
14664: PUSH
14665: EMPTY
14666: LIST
14667: LIST
14668: LIST
14669: LIST
14670: LIST
14671: LIST
14672: LIST
14673: LIST
14674: LIST
14675: LIST
14676: LIST
14677: LIST
14678: LIST
14679: DIFF
14680: PPUSH
14681: LD_STRING 11c_others
14683: PPUSH
14684: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
14688: LD_EXP 21
14692: PPUSH
14693: LD_EXP 3
14697: PUSH
14698: LD_STRING JMM
14700: STR
14701: PPUSH
14702: CALL_OW 38
// if Lisa then
14706: LD_EXP 22
14710: IFFALSE 14730
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
14712: LD_EXP 22
14716: PPUSH
14717: LD_EXP 3
14721: PUSH
14722: LD_STRING Lisa
14724: STR
14725: PPUSH
14726: CALL_OW 38
// if Donaldson then
14730: LD_EXP 23
14734: IFFALSE 14754
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
14736: LD_EXP 23
14740: PPUSH
14741: LD_EXP 3
14745: PUSH
14746: LD_STRING Donaldson
14748: STR
14749: PPUSH
14750: CALL_OW 38
// if Bobby then
14754: LD_EXP 24
14758: IFFALSE 14778
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
14760: LD_EXP 24
14764: PPUSH
14765: LD_EXP 3
14769: PUSH
14770: LD_STRING Bobby
14772: STR
14773: PPUSH
14774: CALL_OW 38
// if Cyrus then
14778: LD_EXP 25
14782: IFFALSE 14802
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
14784: LD_EXP 25
14788: PPUSH
14789: LD_EXP 3
14793: PUSH
14794: LD_STRING Cyrus
14796: STR
14797: PPUSH
14798: CALL_OW 38
// if Denis then
14802: LD_EXP 26
14806: IFFALSE 14826
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
14808: LD_EXP 26
14812: PPUSH
14813: LD_EXP 3
14817: PUSH
14818: LD_STRING Denis
14820: STR
14821: PPUSH
14822: CALL_OW 38
// if Brown then
14826: LD_EXP 27
14830: IFFALSE 14850
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
14832: LD_EXP 27
14836: PPUSH
14837: LD_EXP 3
14841: PUSH
14842: LD_STRING Brown
14844: STR
14845: PPUSH
14846: CALL_OW 38
// if Gladstone then
14850: LD_EXP 28
14854: IFFALSE 14874
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
14856: LD_EXP 28
14860: PPUSH
14861: LD_EXP 3
14865: PUSH
14866: LD_STRING Gladstone
14868: STR
14869: PPUSH
14870: CALL_OW 38
// if Houten then
14874: LD_EXP 29
14878: IFFALSE 14898
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
14880: LD_EXP 29
14884: PPUSH
14885: LD_EXP 3
14889: PUSH
14890: LD_STRING Houten
14892: STR
14893: PPUSH
14894: CALL_OW 38
// if Cornel then
14898: LD_EXP 31
14902: IFFALSE 14922
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
14904: LD_EXP 31
14908: PPUSH
14909: LD_EXP 3
14913: PUSH
14914: LD_STRING Cornel
14916: STR
14917: PPUSH
14918: CALL_OW 38
// if Gary then
14922: LD_EXP 32
14926: IFFALSE 14946
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
14928: LD_EXP 32
14932: PPUSH
14933: LD_EXP 3
14937: PUSH
14938: LD_STRING Gary
14940: STR
14941: PPUSH
14942: CALL_OW 38
// if Frank then
14946: LD_EXP 33
14950: IFFALSE 14970
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
14952: LD_EXP 33
14956: PPUSH
14957: LD_EXP 3
14961: PUSH
14962: LD_STRING Frank
14964: STR
14965: PPUSH
14966: CALL_OW 38
// if Kikuchi then
14970: LD_EXP 34
14974: IFFALSE 14994
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
14976: LD_EXP 34
14980: PPUSH
14981: LD_EXP 3
14985: PUSH
14986: LD_STRING Kikuchi
14988: STR
14989: PPUSH
14990: CALL_OW 38
// YouWin ;
14994: CALL_OW 103
// end ;
14998: PPOPN 1
15000: END
// export function CanSayRand ( side ) ; begin
15001: LD_INT 0
15003: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15004: LD_ADDR_VAR 0 2
15008: PUSH
15009: LD_INT 52
15011: PUSH
15012: EMPTY
15013: LIST
15014: PUSH
15015: LD_INT 22
15017: PUSH
15018: LD_VAR 0 1
15022: PUSH
15023: EMPTY
15024: LIST
15025: LIST
15026: PUSH
15027: LD_INT 2
15029: PUSH
15030: LD_INT 25
15032: PUSH
15033: LD_INT 1
15035: PUSH
15036: EMPTY
15037: LIST
15038: LIST
15039: PUSH
15040: LD_INT 25
15042: PUSH
15043: LD_INT 2
15045: PUSH
15046: EMPTY
15047: LIST
15048: LIST
15049: PUSH
15050: LD_INT 25
15052: PUSH
15053: LD_INT 3
15055: PUSH
15056: EMPTY
15057: LIST
15058: LIST
15059: PUSH
15060: LD_INT 25
15062: PUSH
15063: LD_INT 4
15065: PUSH
15066: EMPTY
15067: LIST
15068: LIST
15069: PUSH
15070: EMPTY
15071: LIST
15072: LIST
15073: LIST
15074: LIST
15075: LIST
15076: PUSH
15077: EMPTY
15078: LIST
15079: LIST
15080: LIST
15081: PPUSH
15082: CALL_OW 69
15086: PUSH
15087: LD_EXP 21
15091: PUSH
15092: LD_EXP 33
15096: PUSH
15097: LD_EXP 22
15101: PUSH
15102: LD_EXP 23
15106: PUSH
15107: LD_EXP 24
15111: PUSH
15112: LD_EXP 25
15116: PUSH
15117: LD_EXP 26
15121: PUSH
15122: LD_EXP 27
15126: PUSH
15127: LD_EXP 28
15131: PUSH
15132: LD_EXP 29
15136: PUSH
15137: LD_EXP 30
15141: PUSH
15142: LD_EXP 31
15146: PUSH
15147: LD_EXP 32
15151: PUSH
15152: LD_EXP 34
15156: PUSH
15157: EMPTY
15158: LIST
15159: LIST
15160: LIST
15161: LIST
15162: LIST
15163: LIST
15164: LIST
15165: LIST
15166: LIST
15167: LIST
15168: LIST
15169: LIST
15170: LIST
15171: LIST
15172: DIFF
15173: ST_TO_ADDR
// end ;
15174: LD_VAR 0 2
15178: RET
// export function SayRand ( sex , dial ) ; begin
15179: LD_INT 0
15181: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15182: LD_ADDR_VAR 0 3
15186: PUSH
15187: LD_INT 52
15189: PUSH
15190: EMPTY
15191: LIST
15192: PUSH
15193: LD_INT 22
15195: PUSH
15196: LD_INT 1
15198: PUSH
15199: EMPTY
15200: LIST
15201: LIST
15202: PUSH
15203: LD_INT 26
15205: PUSH
15206: LD_VAR 0 1
15210: PUSH
15211: EMPTY
15212: LIST
15213: LIST
15214: PUSH
15215: LD_INT 2
15217: PUSH
15218: LD_INT 25
15220: PUSH
15221: LD_INT 1
15223: PUSH
15224: EMPTY
15225: LIST
15226: LIST
15227: PUSH
15228: LD_INT 25
15230: PUSH
15231: LD_INT 2
15233: PUSH
15234: EMPTY
15235: LIST
15236: LIST
15237: PUSH
15238: LD_INT 25
15240: PUSH
15241: LD_INT 3
15243: PUSH
15244: EMPTY
15245: LIST
15246: LIST
15247: PUSH
15248: LD_INT 25
15250: PUSH
15251: LD_INT 4
15253: PUSH
15254: EMPTY
15255: LIST
15256: LIST
15257: PUSH
15258: EMPTY
15259: LIST
15260: LIST
15261: LIST
15262: LIST
15263: LIST
15264: PUSH
15265: EMPTY
15266: LIST
15267: LIST
15268: LIST
15269: LIST
15270: PPUSH
15271: CALL_OW 69
15275: PUSH
15276: LD_EXP 21
15280: PUSH
15281: LD_EXP 33
15285: PUSH
15286: LD_EXP 22
15290: PUSH
15291: LD_EXP 23
15295: PUSH
15296: LD_EXP 24
15300: PUSH
15301: LD_EXP 25
15305: PUSH
15306: LD_EXP 26
15310: PUSH
15311: LD_EXP 27
15315: PUSH
15316: LD_EXP 28
15320: PUSH
15321: LD_EXP 29
15325: PUSH
15326: LD_EXP 30
15330: PUSH
15331: LD_EXP 31
15335: PUSH
15336: LD_EXP 32
15340: PUSH
15341: LD_EXP 34
15345: PUSH
15346: EMPTY
15347: LIST
15348: LIST
15349: LIST
15350: LIST
15351: LIST
15352: LIST
15353: LIST
15354: LIST
15355: LIST
15356: LIST
15357: LIST
15358: LIST
15359: LIST
15360: LIST
15361: DIFF
15362: ST_TO_ADDR
// if not result then
15363: LD_VAR 0 3
15367: NOT
15368: IFFALSE 15372
// exit ;
15370: GO 15400
// result := result [ 1 ] ;
15372: LD_ADDR_VAR 0 3
15376: PUSH
15377: LD_VAR 0 3
15381: PUSH
15382: LD_INT 1
15384: ARRAY
15385: ST_TO_ADDR
// Say ( result , dial ) ;
15386: LD_VAR 0 3
15390: PPUSH
15391: LD_VAR 0 2
15395: PPUSH
15396: CALL_OW 88
// end ;
15400: LD_VAR 0 3
15404: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
15405: LD_INT 0
15407: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
15408: LD_ADDR_VAR 0 4
15412: PUSH
15413: LD_INT 22
15415: PUSH
15416: LD_INT 1
15418: PUSH
15419: EMPTY
15420: LIST
15421: LIST
15422: PUSH
15423: LD_INT 26
15425: PUSH
15426: LD_VAR 0 1
15430: PUSH
15431: EMPTY
15432: LIST
15433: LIST
15434: PUSH
15435: LD_INT 2
15437: PUSH
15438: LD_INT 25
15440: PUSH
15441: LD_INT 1
15443: PUSH
15444: EMPTY
15445: LIST
15446: LIST
15447: PUSH
15448: LD_INT 25
15450: PUSH
15451: LD_INT 2
15453: PUSH
15454: EMPTY
15455: LIST
15456: LIST
15457: PUSH
15458: LD_INT 25
15460: PUSH
15461: LD_INT 3
15463: PUSH
15464: EMPTY
15465: LIST
15466: LIST
15467: PUSH
15468: LD_INT 25
15470: PUSH
15471: LD_INT 4
15473: PUSH
15474: EMPTY
15475: LIST
15476: LIST
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: LIST
15482: LIST
15483: LIST
15484: PUSH
15485: EMPTY
15486: LIST
15487: LIST
15488: LIST
15489: PPUSH
15490: CALL_OW 69
15494: PUSH
15495: LD_EXP 21
15499: PUSH
15500: LD_EXP 33
15504: PUSH
15505: LD_EXP 22
15509: PUSH
15510: LD_EXP 23
15514: PUSH
15515: LD_EXP 24
15519: PUSH
15520: LD_EXP 25
15524: PUSH
15525: LD_EXP 26
15529: PUSH
15530: LD_EXP 27
15534: PUSH
15535: LD_EXP 28
15539: PUSH
15540: LD_EXP 29
15544: PUSH
15545: LD_EXP 30
15549: PUSH
15550: LD_EXP 31
15554: PUSH
15555: LD_EXP 32
15559: PUSH
15560: LD_EXP 34
15564: PUSH
15565: EMPTY
15566: LIST
15567: LIST
15568: LIST
15569: LIST
15570: LIST
15571: LIST
15572: LIST
15573: LIST
15574: LIST
15575: LIST
15576: LIST
15577: LIST
15578: LIST
15579: LIST
15580: PUSH
15581: LD_VAR 0 3
15585: ADD
15586: DIFF
15587: ST_TO_ADDR
// if not result then
15588: LD_VAR 0 4
15592: NOT
15593: IFFALSE 15597
// exit ;
15595: GO 15625
// result := result [ 1 ] ;
15597: LD_ADDR_VAR 0 4
15601: PUSH
15602: LD_VAR 0 4
15606: PUSH
15607: LD_INT 1
15609: ARRAY
15610: ST_TO_ADDR
// Say ( result , dial ) ;
15611: LD_VAR 0 4
15615: PPUSH
15616: LD_VAR 0 2
15620: PPUSH
15621: CALL_OW 88
// end ; end_of_file
15625: LD_VAR 0 4
15629: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
15630: LD_VAR 0 1
15634: PPUSH
15635: CALL_OW 255
15639: PUSH
15640: LD_INT 1
15642: EQUAL
15643: IFFALSE 15653
// artifact_get := true ;
15645: LD_ADDR_EXP 13
15649: PUSH
15650: LD_INT 1
15652: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
15653: LD_VAR 0 1
15657: PPUSH
15658: CALL_OW 255
15662: PUSH
15663: LD_INT 2
15665: EQUAL
15666: IFFALSE 15684
// begin artifact_get := false ;
15668: LD_ADDR_EXP 13
15672: PUSH
15673: LD_INT 0
15675: ST_TO_ADDR
// artifact_stolen := true ;
15676: LD_ADDR_EXP 12
15680: PUSH
15681: LD_INT 1
15683: ST_TO_ADDR
// end ; artifact_oncargo := true ;
15684: LD_ADDR_EXP 14
15688: PUSH
15689: LD_INT 1
15691: ST_TO_ADDR
// end ;
15692: PPOPN 2
15694: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
15695: LD_ADDR_EXP 14
15699: PUSH
15700: LD_INT 0
15702: ST_TO_ADDR
// end ;
15703: PPOPN 2
15705: END
// on UnitDestroyed ( un ) do begin if un = JMM then
15706: LD_VAR 0 1
15710: PUSH
15711: LD_EXP 21
15715: EQUAL
15716: IFFALSE 15727
// begin YouLost ( JMM ) ;
15718: LD_STRING JMM
15720: PPUSH
15721: CALL_OW 104
// exit ;
15725: GO 15859
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
15727: LD_VAR 0 1
15731: PUSH
15732: LD_INT 22
15734: PUSH
15735: LD_INT 1
15737: PUSH
15738: EMPTY
15739: LIST
15740: LIST
15741: PUSH
15742: LD_INT 21
15744: PUSH
15745: LD_INT 1
15747: PUSH
15748: EMPTY
15749: LIST
15750: LIST
15751: PUSH
15752: LD_INT 2
15754: PUSH
15755: LD_INT 25
15757: PUSH
15758: LD_INT 1
15760: PUSH
15761: EMPTY
15762: LIST
15763: LIST
15764: PUSH
15765: LD_INT 25
15767: PUSH
15768: LD_INT 2
15770: PUSH
15771: EMPTY
15772: LIST
15773: LIST
15774: PUSH
15775: LD_INT 25
15777: PUSH
15778: LD_INT 3
15780: PUSH
15781: EMPTY
15782: LIST
15783: LIST
15784: PUSH
15785: LD_INT 25
15787: PUSH
15788: LD_INT 4
15790: PUSH
15791: EMPTY
15792: LIST
15793: LIST
15794: PUSH
15795: LD_INT 25
15797: PUSH
15798: LD_INT 5
15800: PUSH
15801: EMPTY
15802: LIST
15803: LIST
15804: PUSH
15805: LD_INT 25
15807: PUSH
15808: LD_INT 8
15810: PUSH
15811: EMPTY
15812: LIST
15813: LIST
15814: PUSH
15815: EMPTY
15816: LIST
15817: LIST
15818: LIST
15819: LIST
15820: LIST
15821: LIST
15822: LIST
15823: PUSH
15824: EMPTY
15825: LIST
15826: LIST
15827: LIST
15828: PPUSH
15829: CALL_OW 69
15833: IN
15834: IFFALSE 15850
// loses_counter := loses_counter + 1 ;
15836: LD_ADDR_EXP 17
15840: PUSH
15841: LD_EXP 17
15845: PUSH
15846: LD_INT 1
15848: PLUS
15849: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
15850: LD_VAR 0 1
15854: PPUSH
15855: CALL 41185 0 1
// end ;
15859: PPOPN 1
15861: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
15862: LD_VAR 0 1
15866: PPUSH
15867: LD_VAR 0 2
15871: PPUSH
15872: CALL 43070 0 2
// end ;
15876: PPOPN 2
15878: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
15879: LD_VAR 0 1
15883: PPUSH
15884: CALL 42386 0 1
// end ;
15888: PPOPN 1
15890: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
15891: LD_VAR 0 1
15895: PPUSH
15896: LD_VAR 0 2
15900: PPUSH
15901: LD_VAR 0 3
15905: PPUSH
15906: LD_VAR 0 4
15910: PPUSH
15911: LD_VAR 0 5
15915: PPUSH
15916: CALL 40524 0 5
// end ;
15920: PPOPN 5
15922: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
15923: LD_VAR 0 1
15927: PPUSH
15928: LD_VAR 0 2
15932: PPUSH
15933: CALL 40121 0 2
// end ;
15937: PPOPN 2
15939: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
15940: LD_VAR 0 1
15944: PPUSH
15945: CALL_OW 247
15949: PUSH
15950: LD_INT 2
15952: EQUAL
15953: IFFALSE 15957
// exit ;
15955: GO 15974
// if not kamikazed then
15957: LD_EXP 11
15961: NOT
15962: IFFALSE 15974
// kamikazed := unit ;
15964: LD_ADDR_EXP 11
15968: PUSH
15969: LD_VAR 0 1
15973: ST_TO_ADDR
// end ;
15974: PPOPN 1
15976: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
15977: LD_INT 0
15979: PPUSH
15980: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
15981: LD_VAR 0 1
15985: PPUSH
15986: LD_VAR 0 2
15990: PPUSH
15991: LD_VAR 0 3
15995: PPUSH
15996: LD_VAR 0 4
16000: PPUSH
16001: CALL 39966 0 4
// end ;
16005: PPOPN 6
16007: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
16008: LD_VAR 0 1
16012: PPUSH
16013: LD_VAR 0 2
16017: PPUSH
16018: LD_VAR 0 3
16022: PPUSH
16023: CALL 39748 0 3
// end ;
16027: PPOPN 3
16029: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
16030: LD_VAR 0 1
16034: PPUSH
16035: LD_VAR 0 2
16039: PPUSH
16040: CALL 40897 0 2
// end ;
16044: PPOPN 2
16046: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
16047: LD_VAR 0 1
16051: PPUSH
16052: LD_VAR 0 2
16056: PPUSH
16057: CALL 39456 0 2
// end ;
16061: PPOPN 2
16063: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
16064: LD_VAR 0 1
16068: PPUSH
16069: LD_VAR 0 2
16073: PPUSH
16074: CALL 39640 0 2
// end ;
16078: PPOPN 2
16080: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
16081: LD_VAR 0 1
16085: PPUSH
16086: CALL 42152 0 1
// end ;
16090: PPOPN 1
16092: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
16093: LD_VAR 0 1
16097: PPUSH
16098: LD_VAR 0 2
16102: PPUSH
16103: CALL 43324 0 2
// end ;
16107: PPOPN 2
16109: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
16110: LD_VAR 0 1
16114: PPUSH
16115: LD_VAR 0 2
16119: PPUSH
16120: LD_VAR 0 3
16124: PPUSH
16125: LD_VAR 0 4
16129: PPUSH
16130: CALL 43533 0 4
// end ; end_of_file
16134: PPOPN 4
16136: END
// every 0 0$1 trigger game do
16137: LD_EXP 2
16141: IFFALSE 16171
16143: GO 16145
16145: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
16146: LD_INT 7
16148: PUSH
16149: LD_INT 6
16151: PUSH
16152: LD_INT 4
16154: PUSH
16155: LD_INT 6
16157: PUSH
16158: EMPTY
16159: LIST
16160: LIST
16161: LIST
16162: LIST
16163: PPUSH
16164: LD_INT 1750
16166: PPUSH
16167: CALL 16172 0 2
16171: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
16172: LD_INT 0
16174: PPUSH
16175: PPUSH
16176: PPUSH
// if not areas then
16177: LD_VAR 0 1
16181: NOT
16182: IFFALSE 16186
// exit ;
16184: GO 16298
// repeat wait ( time ) ;
16186: LD_VAR 0 2
16190: PPUSH
16191: CALL_OW 67
// p := rand ( 1 , 90 ) ;
16195: LD_ADDR_VAR 0 5
16199: PUSH
16200: LD_INT 1
16202: PPUSH
16203: LD_INT 90
16205: PPUSH
16206: CALL_OW 12
16210: ST_TO_ADDR
// for i in areas do
16211: LD_ADDR_VAR 0 4
16215: PUSH
16216: LD_VAR 0 1
16220: PUSH
16221: FOR_IN
16222: IFFALSE 16275
// begin if Prob ( p ) then
16224: LD_VAR 0 5
16228: PPUSH
16229: CALL_OW 13
16233: IFFALSE 16273
// begin CreateCratesArea ( rand ( 1 , 5 ) , i , true ) ;
16235: LD_INT 1
16237: PPUSH
16238: LD_INT 5
16240: PPUSH
16241: CALL_OW 12
16245: PPUSH
16246: LD_VAR 0 4
16250: PPUSH
16251: LD_INT 1
16253: PPUSH
16254: CALL_OW 55
// wait ( rand ( 0 0$13 , 0 0$17 ) ) ;
16258: LD_INT 455
16260: PPUSH
16261: LD_INT 595
16263: PPUSH
16264: CALL_OW 12
16268: PPUSH
16269: CALL_OW 67
// end ; end ;
16273: GO 16221
16275: POP
16276: POP
// time := time + 0 0$3 ;
16277: LD_ADDR_VAR 0 2
16281: PUSH
16282: LD_VAR 0 2
16286: PUSH
16287: LD_INT 105
16289: PLUS
16290: ST_TO_ADDR
// until not game ;
16291: LD_EXP 2
16295: NOT
16296: IFFALSE 16186
// end ; end_of_file
16298: LD_VAR 0 3
16302: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class ; export function InitMacro ; var i ; begin
16303: LD_INT 0
16305: PPUSH
16306: PPUSH
// skirmish := false ;
16307: LD_ADDR_EXP 47
16311: PUSH
16312: LD_INT 0
16314: ST_TO_ADDR
// debug_mc := false ;
16315: LD_ADDR_EXP 48
16319: PUSH
16320: LD_INT 0
16322: ST_TO_ADDR
// mc_bases := [ ] ;
16323: LD_ADDR_EXP 49
16327: PUSH
16328: EMPTY
16329: ST_TO_ADDR
// mc_sides := [ ] ;
16330: LD_ADDR_EXP 75
16334: PUSH
16335: EMPTY
16336: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
16337: LD_ADDR_EXP 50
16341: PUSH
16342: EMPTY
16343: ST_TO_ADDR
// mc_building_repairs := [ ] ;
16344: LD_ADDR_EXP 51
16348: PUSH
16349: EMPTY
16350: ST_TO_ADDR
// mc_need_heal := [ ] ;
16351: LD_ADDR_EXP 52
16355: PUSH
16356: EMPTY
16357: ST_TO_ADDR
// mc_healers := [ ] ;
16358: LD_ADDR_EXP 53
16362: PUSH
16363: EMPTY
16364: ST_TO_ADDR
// mc_build_list := [ ] ;
16365: LD_ADDR_EXP 54
16369: PUSH
16370: EMPTY
16371: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
16372: LD_ADDR_EXP 81
16376: PUSH
16377: EMPTY
16378: ST_TO_ADDR
// mc_builders := [ ] ;
16379: LD_ADDR_EXP 55
16383: PUSH
16384: EMPTY
16385: ST_TO_ADDR
// mc_construct_list := [ ] ;
16386: LD_ADDR_EXP 56
16390: PUSH
16391: EMPTY
16392: ST_TO_ADDR
// mc_turret_list := [ ] ;
16393: LD_ADDR_EXP 57
16397: PUSH
16398: EMPTY
16399: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
16400: LD_ADDR_EXP 58
16404: PUSH
16405: EMPTY
16406: ST_TO_ADDR
// mc_miners := [ ] ;
16407: LD_ADDR_EXP 63
16411: PUSH
16412: EMPTY
16413: ST_TO_ADDR
// mc_mines := [ ] ;
16414: LD_ADDR_EXP 62
16418: PUSH
16419: EMPTY
16420: ST_TO_ADDR
// mc_minefields := [ ] ;
16421: LD_ADDR_EXP 64
16425: PUSH
16426: EMPTY
16427: ST_TO_ADDR
// mc_crates := [ ] ;
16428: LD_ADDR_EXP 65
16432: PUSH
16433: EMPTY
16434: ST_TO_ADDR
// mc_crates_collector := [ ] ;
16435: LD_ADDR_EXP 66
16439: PUSH
16440: EMPTY
16441: ST_TO_ADDR
// mc_crates_area := [ ] ;
16442: LD_ADDR_EXP 67
16446: PUSH
16447: EMPTY
16448: ST_TO_ADDR
// mc_vehicles := [ ] ;
16449: LD_ADDR_EXP 68
16453: PUSH
16454: EMPTY
16455: ST_TO_ADDR
// mc_attack := [ ] ;
16456: LD_ADDR_EXP 69
16460: PUSH
16461: EMPTY
16462: ST_TO_ADDR
// mc_produce := [ ] ;
16463: LD_ADDR_EXP 70
16467: PUSH
16468: EMPTY
16469: ST_TO_ADDR
// mc_defender := [ ] ;
16470: LD_ADDR_EXP 71
16474: PUSH
16475: EMPTY
16476: ST_TO_ADDR
// mc_parking := [ ] ;
16477: LD_ADDR_EXP 73
16481: PUSH
16482: EMPTY
16483: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
16484: LD_ADDR_EXP 59
16488: PUSH
16489: EMPTY
16490: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
16491: LD_ADDR_EXP 61
16495: PUSH
16496: EMPTY
16497: ST_TO_ADDR
// mc_scan := [ ] ;
16498: LD_ADDR_EXP 72
16502: PUSH
16503: EMPTY
16504: ST_TO_ADDR
// mc_scan_area := [ ] ;
16505: LD_ADDR_EXP 74
16509: PUSH
16510: EMPTY
16511: ST_TO_ADDR
// mc_tech := [ ] ;
16512: LD_ADDR_EXP 76
16516: PUSH
16517: EMPTY
16518: ST_TO_ADDR
// mc_class := [ ] ;
16519: LD_ADDR_EXP 90
16523: PUSH
16524: EMPTY
16525: ST_TO_ADDR
// end ;
16526: LD_VAR 0 1
16530: RET
// export function MC_Kill ( base ) ; begin
16531: LD_INT 0
16533: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
16534: LD_ADDR_EXP 49
16538: PUSH
16539: LD_EXP 49
16543: PPUSH
16544: LD_VAR 0 1
16548: PPUSH
16549: EMPTY
16550: PPUSH
16551: CALL_OW 1
16555: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
16556: LD_ADDR_EXP 50
16560: PUSH
16561: LD_EXP 50
16565: PPUSH
16566: LD_VAR 0 1
16570: PPUSH
16571: EMPTY
16572: PPUSH
16573: CALL_OW 1
16577: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
16578: LD_ADDR_EXP 51
16582: PUSH
16583: LD_EXP 51
16587: PPUSH
16588: LD_VAR 0 1
16592: PPUSH
16593: EMPTY
16594: PPUSH
16595: CALL_OW 1
16599: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
16600: LD_ADDR_EXP 52
16604: PUSH
16605: LD_EXP 52
16609: PPUSH
16610: LD_VAR 0 1
16614: PPUSH
16615: EMPTY
16616: PPUSH
16617: CALL_OW 1
16621: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
16622: LD_ADDR_EXP 53
16626: PUSH
16627: LD_EXP 53
16631: PPUSH
16632: LD_VAR 0 1
16636: PPUSH
16637: EMPTY
16638: PPUSH
16639: CALL_OW 1
16643: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
16644: LD_ADDR_EXP 54
16648: PUSH
16649: LD_EXP 54
16653: PPUSH
16654: LD_VAR 0 1
16658: PPUSH
16659: EMPTY
16660: PPUSH
16661: CALL_OW 1
16665: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
16666: LD_ADDR_EXP 55
16670: PUSH
16671: LD_EXP 55
16675: PPUSH
16676: LD_VAR 0 1
16680: PPUSH
16681: EMPTY
16682: PPUSH
16683: CALL_OW 1
16687: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
16688: LD_ADDR_EXP 56
16692: PUSH
16693: LD_EXP 56
16697: PPUSH
16698: LD_VAR 0 1
16702: PPUSH
16703: EMPTY
16704: PPUSH
16705: CALL_OW 1
16709: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
16710: LD_ADDR_EXP 57
16714: PUSH
16715: LD_EXP 57
16719: PPUSH
16720: LD_VAR 0 1
16724: PPUSH
16725: EMPTY
16726: PPUSH
16727: CALL_OW 1
16731: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
16732: LD_ADDR_EXP 58
16736: PUSH
16737: LD_EXP 58
16741: PPUSH
16742: LD_VAR 0 1
16746: PPUSH
16747: EMPTY
16748: PPUSH
16749: CALL_OW 1
16753: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
16754: LD_ADDR_EXP 59
16758: PUSH
16759: LD_EXP 59
16763: PPUSH
16764: LD_VAR 0 1
16768: PPUSH
16769: EMPTY
16770: PPUSH
16771: CALL_OW 1
16775: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
16776: LD_ADDR_EXP 60
16780: PUSH
16781: LD_EXP 60
16785: PPUSH
16786: LD_VAR 0 1
16790: PPUSH
16791: LD_INT 0
16793: PPUSH
16794: CALL_OW 1
16798: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
16799: LD_ADDR_EXP 61
16803: PUSH
16804: LD_EXP 61
16808: PPUSH
16809: LD_VAR 0 1
16813: PPUSH
16814: EMPTY
16815: PPUSH
16816: CALL_OW 1
16820: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
16821: LD_ADDR_EXP 62
16825: PUSH
16826: LD_EXP 62
16830: PPUSH
16831: LD_VAR 0 1
16835: PPUSH
16836: EMPTY
16837: PPUSH
16838: CALL_OW 1
16842: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
16843: LD_ADDR_EXP 63
16847: PUSH
16848: LD_EXP 63
16852: PPUSH
16853: LD_VAR 0 1
16857: PPUSH
16858: EMPTY
16859: PPUSH
16860: CALL_OW 1
16864: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
16865: LD_ADDR_EXP 64
16869: PUSH
16870: LD_EXP 64
16874: PPUSH
16875: LD_VAR 0 1
16879: PPUSH
16880: EMPTY
16881: PPUSH
16882: CALL_OW 1
16886: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
16887: LD_ADDR_EXP 65
16891: PUSH
16892: LD_EXP 65
16896: PPUSH
16897: LD_VAR 0 1
16901: PPUSH
16902: EMPTY
16903: PPUSH
16904: CALL_OW 1
16908: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
16909: LD_ADDR_EXP 66
16913: PUSH
16914: LD_EXP 66
16918: PPUSH
16919: LD_VAR 0 1
16923: PPUSH
16924: EMPTY
16925: PPUSH
16926: CALL_OW 1
16930: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
16931: LD_ADDR_EXP 67
16935: PUSH
16936: LD_EXP 67
16940: PPUSH
16941: LD_VAR 0 1
16945: PPUSH
16946: EMPTY
16947: PPUSH
16948: CALL_OW 1
16952: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
16953: LD_ADDR_EXP 68
16957: PUSH
16958: LD_EXP 68
16962: PPUSH
16963: LD_VAR 0 1
16967: PPUSH
16968: EMPTY
16969: PPUSH
16970: CALL_OW 1
16974: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
16975: LD_ADDR_EXP 69
16979: PUSH
16980: LD_EXP 69
16984: PPUSH
16985: LD_VAR 0 1
16989: PPUSH
16990: EMPTY
16991: PPUSH
16992: CALL_OW 1
16996: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
16997: LD_ADDR_EXP 70
17001: PUSH
17002: LD_EXP 70
17006: PPUSH
17007: LD_VAR 0 1
17011: PPUSH
17012: EMPTY
17013: PPUSH
17014: CALL_OW 1
17018: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
17019: LD_ADDR_EXP 71
17023: PUSH
17024: LD_EXP 71
17028: PPUSH
17029: LD_VAR 0 1
17033: PPUSH
17034: EMPTY
17035: PPUSH
17036: CALL_OW 1
17040: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
17041: LD_ADDR_EXP 72
17045: PUSH
17046: LD_EXP 72
17050: PPUSH
17051: LD_VAR 0 1
17055: PPUSH
17056: EMPTY
17057: PPUSH
17058: CALL_OW 1
17062: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
17063: LD_ADDR_EXP 73
17067: PUSH
17068: LD_EXP 73
17072: PPUSH
17073: LD_VAR 0 1
17077: PPUSH
17078: EMPTY
17079: PPUSH
17080: CALL_OW 1
17084: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
17085: LD_ADDR_EXP 74
17089: PUSH
17090: LD_EXP 74
17094: PPUSH
17095: LD_VAR 0 1
17099: PPUSH
17100: EMPTY
17101: PPUSH
17102: CALL_OW 1
17106: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
17107: LD_ADDR_EXP 76
17111: PUSH
17112: LD_EXP 76
17116: PPUSH
17117: LD_VAR 0 1
17121: PPUSH
17122: EMPTY
17123: PPUSH
17124: CALL_OW 1
17128: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
17129: LD_ADDR_EXP 78
17133: PUSH
17134: LD_EXP 78
17138: PPUSH
17139: LD_VAR 0 1
17143: PPUSH
17144: EMPTY
17145: PPUSH
17146: CALL_OW 1
17150: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
17151: LD_ADDR_EXP 79
17155: PUSH
17156: LD_EXP 79
17160: PPUSH
17161: LD_VAR 0 1
17165: PPUSH
17166: EMPTY
17167: PPUSH
17168: CALL_OW 1
17172: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
17173: LD_ADDR_EXP 80
17177: PUSH
17178: LD_EXP 80
17182: PPUSH
17183: LD_VAR 0 1
17187: PPUSH
17188: EMPTY
17189: PPUSH
17190: CALL_OW 1
17194: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
17195: LD_ADDR_EXP 81
17199: PUSH
17200: LD_EXP 81
17204: PPUSH
17205: LD_VAR 0 1
17209: PPUSH
17210: EMPTY
17211: PPUSH
17212: CALL_OW 1
17216: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
17217: LD_ADDR_EXP 82
17221: PUSH
17222: LD_EXP 82
17226: PPUSH
17227: LD_VAR 0 1
17231: PPUSH
17232: EMPTY
17233: PPUSH
17234: CALL_OW 1
17238: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
17239: LD_ADDR_EXP 83
17243: PUSH
17244: LD_EXP 83
17248: PPUSH
17249: LD_VAR 0 1
17253: PPUSH
17254: EMPTY
17255: PPUSH
17256: CALL_OW 1
17260: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
17261: LD_ADDR_EXP 84
17265: PUSH
17266: LD_EXP 84
17270: PPUSH
17271: LD_VAR 0 1
17275: PPUSH
17276: EMPTY
17277: PPUSH
17278: CALL_OW 1
17282: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
17283: LD_ADDR_EXP 85
17287: PUSH
17288: LD_EXP 85
17292: PPUSH
17293: LD_VAR 0 1
17297: PPUSH
17298: EMPTY
17299: PPUSH
17300: CALL_OW 1
17304: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
17305: LD_ADDR_EXP 86
17309: PUSH
17310: LD_EXP 86
17314: PPUSH
17315: LD_VAR 0 1
17319: PPUSH
17320: EMPTY
17321: PPUSH
17322: CALL_OW 1
17326: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
17327: LD_ADDR_EXP 87
17331: PUSH
17332: LD_EXP 87
17336: PPUSH
17337: LD_VAR 0 1
17341: PPUSH
17342: EMPTY
17343: PPUSH
17344: CALL_OW 1
17348: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
17349: LD_ADDR_EXP 88
17353: PUSH
17354: LD_EXP 88
17358: PPUSH
17359: LD_VAR 0 1
17363: PPUSH
17364: EMPTY
17365: PPUSH
17366: CALL_OW 1
17370: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
17371: LD_ADDR_EXP 89
17375: PUSH
17376: LD_EXP 89
17380: PPUSH
17381: LD_VAR 0 1
17385: PPUSH
17386: EMPTY
17387: PPUSH
17388: CALL_OW 1
17392: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
17393: LD_ADDR_EXP 90
17397: PUSH
17398: LD_EXP 90
17402: PPUSH
17403: LD_VAR 0 1
17407: PPUSH
17408: EMPTY
17409: PPUSH
17410: CALL_OW 1
17414: ST_TO_ADDR
// end ;
17415: LD_VAR 0 2
17419: RET
// export function MC_Start ( ) ; var i ; begin
17420: LD_INT 0
17422: PPUSH
17423: PPUSH
// for i = 1 to mc_bases do
17424: LD_ADDR_VAR 0 2
17428: PUSH
17429: DOUBLE
17430: LD_INT 1
17432: DEC
17433: ST_TO_ADDR
17434: LD_EXP 49
17438: PUSH
17439: FOR_TO
17440: IFFALSE 18494
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
17442: LD_ADDR_EXP 49
17446: PUSH
17447: LD_EXP 49
17451: PPUSH
17452: LD_VAR 0 2
17456: PPUSH
17457: LD_EXP 49
17461: PUSH
17462: LD_VAR 0 2
17466: ARRAY
17467: PUSH
17468: LD_INT 0
17470: DIFF
17471: PPUSH
17472: CALL_OW 1
17476: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
17477: LD_ADDR_EXP 50
17481: PUSH
17482: LD_EXP 50
17486: PPUSH
17487: LD_VAR 0 2
17491: PPUSH
17492: EMPTY
17493: PPUSH
17494: CALL_OW 1
17498: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
17499: LD_ADDR_EXP 51
17503: PUSH
17504: LD_EXP 51
17508: PPUSH
17509: LD_VAR 0 2
17513: PPUSH
17514: EMPTY
17515: PPUSH
17516: CALL_OW 1
17520: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
17521: LD_ADDR_EXP 52
17525: PUSH
17526: LD_EXP 52
17530: PPUSH
17531: LD_VAR 0 2
17535: PPUSH
17536: EMPTY
17537: PPUSH
17538: CALL_OW 1
17542: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
17543: LD_ADDR_EXP 53
17547: PUSH
17548: LD_EXP 53
17552: PPUSH
17553: LD_VAR 0 2
17557: PPUSH
17558: EMPTY
17559: PUSH
17560: EMPTY
17561: PUSH
17562: EMPTY
17563: LIST
17564: LIST
17565: PPUSH
17566: CALL_OW 1
17570: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
17571: LD_ADDR_EXP 54
17575: PUSH
17576: LD_EXP 54
17580: PPUSH
17581: LD_VAR 0 2
17585: PPUSH
17586: EMPTY
17587: PPUSH
17588: CALL_OW 1
17592: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
17593: LD_ADDR_EXP 81
17597: PUSH
17598: LD_EXP 81
17602: PPUSH
17603: LD_VAR 0 2
17607: PPUSH
17608: EMPTY
17609: PPUSH
17610: CALL_OW 1
17614: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
17615: LD_ADDR_EXP 55
17619: PUSH
17620: LD_EXP 55
17624: PPUSH
17625: LD_VAR 0 2
17629: PPUSH
17630: EMPTY
17631: PPUSH
17632: CALL_OW 1
17636: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
17637: LD_ADDR_EXP 56
17641: PUSH
17642: LD_EXP 56
17646: PPUSH
17647: LD_VAR 0 2
17651: PPUSH
17652: EMPTY
17653: PPUSH
17654: CALL_OW 1
17658: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
17659: LD_ADDR_EXP 57
17663: PUSH
17664: LD_EXP 57
17668: PPUSH
17669: LD_VAR 0 2
17673: PPUSH
17674: LD_EXP 49
17678: PUSH
17679: LD_VAR 0 2
17683: ARRAY
17684: PPUSH
17685: LD_INT 2
17687: PUSH
17688: LD_INT 30
17690: PUSH
17691: LD_INT 32
17693: PUSH
17694: EMPTY
17695: LIST
17696: LIST
17697: PUSH
17698: LD_INT 30
17700: PUSH
17701: LD_INT 33
17703: PUSH
17704: EMPTY
17705: LIST
17706: LIST
17707: PUSH
17708: EMPTY
17709: LIST
17710: LIST
17711: LIST
17712: PPUSH
17713: CALL_OW 72
17717: PPUSH
17718: CALL_OW 1
17722: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
17723: LD_ADDR_EXP 58
17727: PUSH
17728: LD_EXP 58
17732: PPUSH
17733: LD_VAR 0 2
17737: PPUSH
17738: LD_EXP 49
17742: PUSH
17743: LD_VAR 0 2
17747: ARRAY
17748: PPUSH
17749: LD_INT 2
17751: PUSH
17752: LD_INT 30
17754: PUSH
17755: LD_INT 32
17757: PUSH
17758: EMPTY
17759: LIST
17760: LIST
17761: PUSH
17762: LD_INT 30
17764: PUSH
17765: LD_INT 31
17767: PUSH
17768: EMPTY
17769: LIST
17770: LIST
17771: PUSH
17772: EMPTY
17773: LIST
17774: LIST
17775: LIST
17776: PUSH
17777: LD_INT 58
17779: PUSH
17780: EMPTY
17781: LIST
17782: PUSH
17783: EMPTY
17784: LIST
17785: LIST
17786: PPUSH
17787: CALL_OW 72
17791: PPUSH
17792: CALL_OW 1
17796: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
17797: LD_ADDR_EXP 59
17801: PUSH
17802: LD_EXP 59
17806: PPUSH
17807: LD_VAR 0 2
17811: PPUSH
17812: EMPTY
17813: PPUSH
17814: CALL_OW 1
17818: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
17819: LD_ADDR_EXP 63
17823: PUSH
17824: LD_EXP 63
17828: PPUSH
17829: LD_VAR 0 2
17833: PPUSH
17834: EMPTY
17835: PPUSH
17836: CALL_OW 1
17840: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
17841: LD_ADDR_EXP 62
17845: PUSH
17846: LD_EXP 62
17850: PPUSH
17851: LD_VAR 0 2
17855: PPUSH
17856: EMPTY
17857: PPUSH
17858: CALL_OW 1
17862: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
17863: LD_ADDR_EXP 64
17867: PUSH
17868: LD_EXP 64
17872: PPUSH
17873: LD_VAR 0 2
17877: PPUSH
17878: EMPTY
17879: PPUSH
17880: CALL_OW 1
17884: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
17885: LD_ADDR_EXP 65
17889: PUSH
17890: LD_EXP 65
17894: PPUSH
17895: LD_VAR 0 2
17899: PPUSH
17900: EMPTY
17901: PPUSH
17902: CALL_OW 1
17906: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
17907: LD_ADDR_EXP 66
17911: PUSH
17912: LD_EXP 66
17916: PPUSH
17917: LD_VAR 0 2
17921: PPUSH
17922: EMPTY
17923: PPUSH
17924: CALL_OW 1
17928: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
17929: LD_ADDR_EXP 67
17933: PUSH
17934: LD_EXP 67
17938: PPUSH
17939: LD_VAR 0 2
17943: PPUSH
17944: EMPTY
17945: PPUSH
17946: CALL_OW 1
17950: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
17951: LD_ADDR_EXP 68
17955: PUSH
17956: LD_EXP 68
17960: PPUSH
17961: LD_VAR 0 2
17965: PPUSH
17966: EMPTY
17967: PPUSH
17968: CALL_OW 1
17972: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
17973: LD_ADDR_EXP 69
17977: PUSH
17978: LD_EXP 69
17982: PPUSH
17983: LD_VAR 0 2
17987: PPUSH
17988: EMPTY
17989: PPUSH
17990: CALL_OW 1
17994: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
17995: LD_ADDR_EXP 70
17999: PUSH
18000: LD_EXP 70
18004: PPUSH
18005: LD_VAR 0 2
18009: PPUSH
18010: EMPTY
18011: PPUSH
18012: CALL_OW 1
18016: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
18017: LD_ADDR_EXP 71
18021: PUSH
18022: LD_EXP 71
18026: PPUSH
18027: LD_VAR 0 2
18031: PPUSH
18032: EMPTY
18033: PPUSH
18034: CALL_OW 1
18038: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
18039: LD_ADDR_EXP 60
18043: PUSH
18044: LD_EXP 60
18048: PPUSH
18049: LD_VAR 0 2
18053: PPUSH
18054: LD_INT 0
18056: PPUSH
18057: CALL_OW 1
18061: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
18062: LD_ADDR_EXP 73
18066: PUSH
18067: LD_EXP 73
18071: PPUSH
18072: LD_VAR 0 2
18076: PPUSH
18077: LD_INT 0
18079: PPUSH
18080: CALL_OW 1
18084: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
18085: LD_ADDR_EXP 61
18089: PUSH
18090: LD_EXP 61
18094: PPUSH
18095: LD_VAR 0 2
18099: PPUSH
18100: EMPTY
18101: PPUSH
18102: CALL_OW 1
18106: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
18107: LD_ADDR_EXP 72
18111: PUSH
18112: LD_EXP 72
18116: PPUSH
18117: LD_VAR 0 2
18121: PPUSH
18122: LD_INT 0
18124: PPUSH
18125: CALL_OW 1
18129: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
18130: LD_ADDR_EXP 74
18134: PUSH
18135: LD_EXP 74
18139: PPUSH
18140: LD_VAR 0 2
18144: PPUSH
18145: EMPTY
18146: PPUSH
18147: CALL_OW 1
18151: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
18152: LD_ADDR_EXP 77
18156: PUSH
18157: LD_EXP 77
18161: PPUSH
18162: LD_VAR 0 2
18166: PPUSH
18167: LD_INT 0
18169: PPUSH
18170: CALL_OW 1
18174: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
18175: LD_ADDR_EXP 78
18179: PUSH
18180: LD_EXP 78
18184: PPUSH
18185: LD_VAR 0 2
18189: PPUSH
18190: EMPTY
18191: PPUSH
18192: CALL_OW 1
18196: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
18197: LD_ADDR_EXP 79
18201: PUSH
18202: LD_EXP 79
18206: PPUSH
18207: LD_VAR 0 2
18211: PPUSH
18212: EMPTY
18213: PPUSH
18214: CALL_OW 1
18218: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
18219: LD_ADDR_EXP 80
18223: PUSH
18224: LD_EXP 80
18228: PPUSH
18229: LD_VAR 0 2
18233: PPUSH
18234: EMPTY
18235: PPUSH
18236: CALL_OW 1
18240: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
18241: LD_ADDR_EXP 82
18245: PUSH
18246: LD_EXP 82
18250: PPUSH
18251: LD_VAR 0 2
18255: PPUSH
18256: LD_EXP 49
18260: PUSH
18261: LD_VAR 0 2
18265: ARRAY
18266: PPUSH
18267: LD_INT 2
18269: PUSH
18270: LD_INT 30
18272: PUSH
18273: LD_INT 6
18275: PUSH
18276: EMPTY
18277: LIST
18278: LIST
18279: PUSH
18280: LD_INT 30
18282: PUSH
18283: LD_INT 7
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: PUSH
18290: LD_INT 30
18292: PUSH
18293: LD_INT 8
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: PUSH
18300: EMPTY
18301: LIST
18302: LIST
18303: LIST
18304: LIST
18305: PPUSH
18306: CALL_OW 72
18310: PPUSH
18311: CALL_OW 1
18315: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
18316: LD_ADDR_EXP 83
18320: PUSH
18321: LD_EXP 83
18325: PPUSH
18326: LD_VAR 0 2
18330: PPUSH
18331: EMPTY
18332: PPUSH
18333: CALL_OW 1
18337: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
18338: LD_ADDR_EXP 84
18342: PUSH
18343: LD_EXP 84
18347: PPUSH
18348: LD_VAR 0 2
18352: PPUSH
18353: EMPTY
18354: PPUSH
18355: CALL_OW 1
18359: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
18360: LD_ADDR_EXP 85
18364: PUSH
18365: LD_EXP 85
18369: PPUSH
18370: LD_VAR 0 2
18374: PPUSH
18375: EMPTY
18376: PPUSH
18377: CALL_OW 1
18381: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
18382: LD_ADDR_EXP 86
18386: PUSH
18387: LD_EXP 86
18391: PPUSH
18392: LD_VAR 0 2
18396: PPUSH
18397: EMPTY
18398: PPUSH
18399: CALL_OW 1
18403: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
18404: LD_ADDR_EXP 87
18408: PUSH
18409: LD_EXP 87
18413: PPUSH
18414: LD_VAR 0 2
18418: PPUSH
18419: EMPTY
18420: PPUSH
18421: CALL_OW 1
18425: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
18426: LD_ADDR_EXP 88
18430: PUSH
18431: LD_EXP 88
18435: PPUSH
18436: LD_VAR 0 2
18440: PPUSH
18441: EMPTY
18442: PPUSH
18443: CALL_OW 1
18447: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
18448: LD_ADDR_EXP 89
18452: PUSH
18453: LD_EXP 89
18457: PPUSH
18458: LD_VAR 0 2
18462: PPUSH
18463: EMPTY
18464: PPUSH
18465: CALL_OW 1
18469: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
18470: LD_ADDR_EXP 90
18474: PUSH
18475: LD_EXP 90
18479: PPUSH
18480: LD_VAR 0 2
18484: PPUSH
18485: EMPTY
18486: PPUSH
18487: CALL_OW 1
18491: ST_TO_ADDR
// end ;
18492: GO 17439
18494: POP
18495: POP
// MC_InitSides ( ) ;
18496: CALL 18782 0 0
// MC_InitResearch ( ) ;
18500: CALL 18521 0 0
// CustomInitMacro ( ) ;
18504: CALL 285 0 0
// skirmish := true ;
18508: LD_ADDR_EXP 47
18512: PUSH
18513: LD_INT 1
18515: ST_TO_ADDR
// end ;
18516: LD_VAR 0 1
18520: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
18521: LD_INT 0
18523: PPUSH
18524: PPUSH
18525: PPUSH
18526: PPUSH
18527: PPUSH
18528: PPUSH
// if not mc_bases then
18529: LD_EXP 49
18533: NOT
18534: IFFALSE 18538
// exit ;
18536: GO 18777
// for i = 1 to 8 do
18538: LD_ADDR_VAR 0 2
18542: PUSH
18543: DOUBLE
18544: LD_INT 1
18546: DEC
18547: ST_TO_ADDR
18548: LD_INT 8
18550: PUSH
18551: FOR_TO
18552: IFFALSE 18578
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
18554: LD_ADDR_EXP 76
18558: PUSH
18559: LD_EXP 76
18563: PPUSH
18564: LD_VAR 0 2
18568: PPUSH
18569: EMPTY
18570: PPUSH
18571: CALL_OW 1
18575: ST_TO_ADDR
18576: GO 18551
18578: POP
18579: POP
// tmp := [ ] ;
18580: LD_ADDR_VAR 0 5
18584: PUSH
18585: EMPTY
18586: ST_TO_ADDR
// for i = 1 to mc_sides do
18587: LD_ADDR_VAR 0 2
18591: PUSH
18592: DOUBLE
18593: LD_INT 1
18595: DEC
18596: ST_TO_ADDR
18597: LD_EXP 75
18601: PUSH
18602: FOR_TO
18603: IFFALSE 18661
// if not mc_sides [ i ] in tmp then
18605: LD_EXP 75
18609: PUSH
18610: LD_VAR 0 2
18614: ARRAY
18615: PUSH
18616: LD_VAR 0 5
18620: IN
18621: NOT
18622: IFFALSE 18659
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
18624: LD_ADDR_VAR 0 5
18628: PUSH
18629: LD_VAR 0 5
18633: PPUSH
18634: LD_VAR 0 5
18638: PUSH
18639: LD_INT 1
18641: PLUS
18642: PPUSH
18643: LD_EXP 75
18647: PUSH
18648: LD_VAR 0 2
18652: ARRAY
18653: PPUSH
18654: CALL_OW 2
18658: ST_TO_ADDR
18659: GO 18602
18661: POP
18662: POP
// if not tmp then
18663: LD_VAR 0 5
18667: NOT
18668: IFFALSE 18672
// exit ;
18670: GO 18777
// for j in tmp do
18672: LD_ADDR_VAR 0 3
18676: PUSH
18677: LD_VAR 0 5
18681: PUSH
18682: FOR_IN
18683: IFFALSE 18775
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
18685: LD_ADDR_VAR 0 6
18689: PUSH
18690: LD_INT 22
18692: PUSH
18693: LD_VAR 0 3
18697: PUSH
18698: EMPTY
18699: LIST
18700: LIST
18701: PPUSH
18702: CALL_OW 69
18706: ST_TO_ADDR
// if not un then
18707: LD_VAR 0 6
18711: NOT
18712: IFFALSE 18716
// continue ;
18714: GO 18682
// nation := GetNation ( un [ 1 ] ) ;
18716: LD_ADDR_VAR 0 4
18720: PUSH
18721: LD_VAR 0 6
18725: PUSH
18726: LD_INT 1
18728: ARRAY
18729: PPUSH
18730: CALL_OW 248
18734: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
18735: LD_ADDR_EXP 76
18739: PUSH
18740: LD_EXP 76
18744: PPUSH
18745: LD_VAR 0 3
18749: PPUSH
18750: LD_VAR 0 3
18754: PPUSH
18755: LD_VAR 0 4
18759: PPUSH
18760: LD_INT 1
18762: PPUSH
18763: CALL 43730 0 3
18767: PPUSH
18768: CALL_OW 1
18772: ST_TO_ADDR
// end ;
18773: GO 18682
18775: POP
18776: POP
// end ;
18777: LD_VAR 0 1
18781: RET
// export function MC_InitSides ( ) ; var i ; begin
18782: LD_INT 0
18784: PPUSH
18785: PPUSH
// if not mc_bases then
18786: LD_EXP 49
18790: NOT
18791: IFFALSE 18795
// exit ;
18793: GO 18869
// for i = 1 to mc_bases do
18795: LD_ADDR_VAR 0 2
18799: PUSH
18800: DOUBLE
18801: LD_INT 1
18803: DEC
18804: ST_TO_ADDR
18805: LD_EXP 49
18809: PUSH
18810: FOR_TO
18811: IFFALSE 18867
// if mc_bases [ i ] then
18813: LD_EXP 49
18817: PUSH
18818: LD_VAR 0 2
18822: ARRAY
18823: IFFALSE 18865
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
18825: LD_ADDR_EXP 75
18829: PUSH
18830: LD_EXP 75
18834: PPUSH
18835: LD_VAR 0 2
18839: PPUSH
18840: LD_EXP 49
18844: PUSH
18845: LD_VAR 0 2
18849: ARRAY
18850: PUSH
18851: LD_INT 1
18853: ARRAY
18854: PPUSH
18855: CALL_OW 255
18859: PPUSH
18860: CALL_OW 1
18864: ST_TO_ADDR
18865: GO 18810
18867: POP
18868: POP
// end ;
18869: LD_VAR 0 1
18873: RET
// every 0 0$01 trigger skirmish do
18874: LD_EXP 47
18878: IFFALSE 19032
18880: GO 18882
18882: DISABLE
// begin enable ;
18883: ENABLE
// MC_CheckBuildings ( ) ;
18884: CALL 23076 0 0
// MC_CheckPeopleLife ( ) ;
18888: CALL 23201 0 0
// RaiseSailEvent ( 100 ) ;
18892: LD_INT 100
18894: PPUSH
18895: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
18899: LD_INT 103
18901: PPUSH
18902: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
18906: LD_INT 104
18908: PPUSH
18909: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
18913: LD_INT 105
18915: PPUSH
18916: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
18920: LD_INT 106
18922: PPUSH
18923: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
18927: LD_INT 107
18929: PPUSH
18930: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
18934: LD_INT 108
18936: PPUSH
18937: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
18941: LD_INT 109
18943: PPUSH
18944: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
18948: LD_INT 110
18950: PPUSH
18951: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
18955: LD_INT 111
18957: PPUSH
18958: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
18962: LD_INT 112
18964: PPUSH
18965: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
18969: LD_INT 113
18971: PPUSH
18972: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
18976: LD_INT 120
18978: PPUSH
18979: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
18983: LD_INT 121
18985: PPUSH
18986: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
18990: LD_INT 122
18992: PPUSH
18993: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
18997: LD_INT 123
18999: PPUSH
19000: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
19004: LD_INT 124
19006: PPUSH
19007: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
19011: LD_INT 125
19013: PPUSH
19014: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
19018: LD_INT 126
19020: PPUSH
19021: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
19025: LD_INT 200
19027: PPUSH
19028: CALL_OW 427
// end ;
19032: END
// on SailEvent ( event ) do begin if event = 100 then
19033: LD_VAR 0 1
19037: PUSH
19038: LD_INT 100
19040: EQUAL
19041: IFFALSE 19047
// MC_ClassManager ( ) ;
19043: CALL 19439 0 0
// if event = 101 then
19047: LD_VAR 0 1
19051: PUSH
19052: LD_INT 101
19054: EQUAL
19055: IFFALSE 19061
// MC_RepairBuildings ( ) ;
19057: CALL 23759 0 0
// if event = 102 then
19061: LD_VAR 0 1
19065: PUSH
19066: LD_INT 102
19068: EQUAL
19069: IFFALSE 19075
// MC_Heal ( ) ;
19071: CALL 24165 0 0
// if event = 103 then
19075: LD_VAR 0 1
19079: PUSH
19080: LD_INT 103
19082: EQUAL
19083: IFFALSE 19089
// MC_Build ( ) ;
19085: CALL 24587 0 0
// if event = 104 then
19089: LD_VAR 0 1
19093: PUSH
19094: LD_INT 104
19096: EQUAL
19097: IFFALSE 19103
// MC_TurretWeapon ( ) ;
19099: CALL 26200 0 0
// if event = 105 then
19103: LD_VAR 0 1
19107: PUSH
19108: LD_INT 105
19110: EQUAL
19111: IFFALSE 19117
// MC_BuildUpgrade ( ) ;
19113: CALL 25751 0 0
// if event = 106 then
19117: LD_VAR 0 1
19121: PUSH
19122: LD_INT 106
19124: EQUAL
19125: IFFALSE 19131
// MC_PlantMines ( ) ;
19127: CALL 26619 0 0
// if event = 107 then
19131: LD_VAR 0 1
19135: PUSH
19136: LD_INT 107
19138: EQUAL
19139: IFFALSE 19145
// MC_CollectCrates ( ) ;
19141: CALL 27653 0 0
// if event = 108 then
19145: LD_VAR 0 1
19149: PUSH
19150: LD_INT 108
19152: EQUAL
19153: IFFALSE 19159
// MC_LinkRemoteControl ( ) ;
19155: CALL 29410 0 0
// if event = 109 then
19159: LD_VAR 0 1
19163: PUSH
19164: LD_INT 109
19166: EQUAL
19167: IFFALSE 19173
// MC_ProduceVehicle ( ) ;
19169: CALL 29591 0 0
// if event = 110 then
19173: LD_VAR 0 1
19177: PUSH
19178: LD_INT 110
19180: EQUAL
19181: IFFALSE 19187
// MC_SendAttack ( ) ;
19183: CALL 30072 0 0
// if event = 111 then
19187: LD_VAR 0 1
19191: PUSH
19192: LD_INT 111
19194: EQUAL
19195: IFFALSE 19201
// MC_Defend ( ) ;
19197: CALL 30180 0 0
// if event = 112 then
19201: LD_VAR 0 1
19205: PUSH
19206: LD_INT 112
19208: EQUAL
19209: IFFALSE 19215
// MC_Research ( ) ;
19211: CALL 30807 0 0
// if event = 113 then
19215: LD_VAR 0 1
19219: PUSH
19220: LD_INT 113
19222: EQUAL
19223: IFFALSE 19229
// MC_MinesTrigger ( ) ;
19225: CALL 31894 0 0
// if event = 120 then
19229: LD_VAR 0 1
19233: PUSH
19234: LD_INT 120
19236: EQUAL
19237: IFFALSE 19243
// MC_RepairVehicle ( ) ;
19239: CALL 31993 0 0
// if event = 121 then
19243: LD_VAR 0 1
19247: PUSH
19248: LD_INT 121
19250: EQUAL
19251: IFFALSE 19257
// MC_TameApe ( ) ;
19253: CALL 32736 0 0
// if event = 122 then
19257: LD_VAR 0 1
19261: PUSH
19262: LD_INT 122
19264: EQUAL
19265: IFFALSE 19271
// MC_ChangeApeClass ( ) ;
19267: CALL 33565 0 0
// if event = 123 then
19271: LD_VAR 0 1
19275: PUSH
19276: LD_INT 123
19278: EQUAL
19279: IFFALSE 19285
// MC_Bazooka ( ) ;
19281: CALL 34215 0 0
// if event = 124 then
19285: LD_VAR 0 1
19289: PUSH
19290: LD_INT 124
19292: EQUAL
19293: IFFALSE 19299
// MC_TeleportExit ( ) ;
19295: CALL 34413 0 0
// if event = 125 then
19299: LD_VAR 0 1
19303: PUSH
19304: LD_INT 125
19306: EQUAL
19307: IFFALSE 19313
// MC_Deposits ( ) ;
19309: CALL 35060 0 0
// if event = 126 then
19313: LD_VAR 0 1
19317: PUSH
19318: LD_INT 126
19320: EQUAL
19321: IFFALSE 19327
// MC_RemoteDriver ( ) ;
19323: CALL 35685 0 0
// if event = 200 then
19327: LD_VAR 0 1
19331: PUSH
19332: LD_INT 200
19334: EQUAL
19335: IFFALSE 19341
// MC_Idle ( ) ;
19337: CALL 37418 0 0
// end ;
19341: PPOPN 1
19343: END
// export function MC_Reset ( base , tag ) ; var i ; begin
19344: LD_INT 0
19346: PPUSH
19347: PPUSH
// if not mc_bases [ base ] or not tag then
19348: LD_EXP 49
19352: PUSH
19353: LD_VAR 0 1
19357: ARRAY
19358: NOT
19359: PUSH
19360: LD_VAR 0 2
19364: NOT
19365: OR
19366: IFFALSE 19370
// exit ;
19368: GO 19434
// for i in mc_bases [ base ] union mc_ape [ base ] do
19370: LD_ADDR_VAR 0 4
19374: PUSH
19375: LD_EXP 49
19379: PUSH
19380: LD_VAR 0 1
19384: ARRAY
19385: PUSH
19386: LD_EXP 78
19390: PUSH
19391: LD_VAR 0 1
19395: ARRAY
19396: UNION
19397: PUSH
19398: FOR_IN
19399: IFFALSE 19432
// if GetTag ( i ) = tag then
19401: LD_VAR 0 4
19405: PPUSH
19406: CALL_OW 110
19410: PUSH
19411: LD_VAR 0 2
19415: EQUAL
19416: IFFALSE 19430
// SetTag ( i , 0 ) ;
19418: LD_VAR 0 4
19422: PPUSH
19423: LD_INT 0
19425: PPUSH
19426: CALL_OW 109
19430: GO 19398
19432: POP
19433: POP
// end ;
19434: LD_VAR 0 3
19438: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
19439: LD_INT 0
19441: PPUSH
19442: PPUSH
19443: PPUSH
19444: PPUSH
19445: PPUSH
19446: PPUSH
19447: PPUSH
19448: PPUSH
// if not mc_bases then
19449: LD_EXP 49
19453: NOT
19454: IFFALSE 19458
// exit ;
19456: GO 19916
// for i = 1 to mc_bases do
19458: LD_ADDR_VAR 0 2
19462: PUSH
19463: DOUBLE
19464: LD_INT 1
19466: DEC
19467: ST_TO_ADDR
19468: LD_EXP 49
19472: PUSH
19473: FOR_TO
19474: IFFALSE 19914
// begin tmp := MC_ClassCheckReq ( i ) ;
19476: LD_ADDR_VAR 0 4
19480: PUSH
19481: LD_VAR 0 2
19485: PPUSH
19486: CALL 19921 0 1
19490: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
19491: LD_ADDR_EXP 90
19495: PUSH
19496: LD_EXP 90
19500: PPUSH
19501: LD_VAR 0 2
19505: PPUSH
19506: LD_VAR 0 4
19510: PPUSH
19511: CALL_OW 1
19515: ST_TO_ADDR
// if not tmp then
19516: LD_VAR 0 4
19520: NOT
19521: IFFALSE 19525
// continue ;
19523: GO 19473
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
19525: LD_ADDR_VAR 0 6
19529: PUSH
19530: LD_EXP 49
19534: PUSH
19535: LD_VAR 0 2
19539: ARRAY
19540: PPUSH
19541: LD_INT 2
19543: PUSH
19544: LD_INT 30
19546: PUSH
19547: LD_INT 4
19549: PUSH
19550: EMPTY
19551: LIST
19552: LIST
19553: PUSH
19554: LD_INT 30
19556: PUSH
19557: LD_INT 5
19559: PUSH
19560: EMPTY
19561: LIST
19562: LIST
19563: PUSH
19564: EMPTY
19565: LIST
19566: LIST
19567: LIST
19568: PPUSH
19569: CALL_OW 72
19573: PUSH
19574: LD_EXP 49
19578: PUSH
19579: LD_VAR 0 2
19583: ARRAY
19584: PPUSH
19585: LD_INT 2
19587: PUSH
19588: LD_INT 30
19590: PUSH
19591: LD_INT 0
19593: PUSH
19594: EMPTY
19595: LIST
19596: LIST
19597: PUSH
19598: LD_INT 30
19600: PUSH
19601: LD_INT 1
19603: PUSH
19604: EMPTY
19605: LIST
19606: LIST
19607: PUSH
19608: EMPTY
19609: LIST
19610: LIST
19611: LIST
19612: PPUSH
19613: CALL_OW 72
19617: PUSH
19618: LD_EXP 49
19622: PUSH
19623: LD_VAR 0 2
19627: ARRAY
19628: PPUSH
19629: LD_INT 30
19631: PUSH
19632: LD_INT 3
19634: PUSH
19635: EMPTY
19636: LIST
19637: LIST
19638: PPUSH
19639: CALL_OW 72
19643: PUSH
19644: LD_EXP 49
19648: PUSH
19649: LD_VAR 0 2
19653: ARRAY
19654: PPUSH
19655: LD_INT 2
19657: PUSH
19658: LD_INT 30
19660: PUSH
19661: LD_INT 6
19663: PUSH
19664: EMPTY
19665: LIST
19666: LIST
19667: PUSH
19668: LD_INT 30
19670: PUSH
19671: LD_INT 7
19673: PUSH
19674: EMPTY
19675: LIST
19676: LIST
19677: PUSH
19678: LD_INT 30
19680: PUSH
19681: LD_INT 8
19683: PUSH
19684: EMPTY
19685: LIST
19686: LIST
19687: PUSH
19688: EMPTY
19689: LIST
19690: LIST
19691: LIST
19692: LIST
19693: PPUSH
19694: CALL_OW 72
19698: PUSH
19699: EMPTY
19700: LIST
19701: LIST
19702: LIST
19703: LIST
19704: ST_TO_ADDR
// for j = 1 to 4 do
19705: LD_ADDR_VAR 0 3
19709: PUSH
19710: DOUBLE
19711: LD_INT 1
19713: DEC
19714: ST_TO_ADDR
19715: LD_INT 4
19717: PUSH
19718: FOR_TO
19719: IFFALSE 19910
// begin if not tmp [ j ] then
19721: LD_VAR 0 4
19725: PUSH
19726: LD_VAR 0 3
19730: ARRAY
19731: NOT
19732: IFFALSE 19736
// continue ;
19734: GO 19718
// for p in tmp [ j ] do
19736: LD_ADDR_VAR 0 5
19740: PUSH
19741: LD_VAR 0 4
19745: PUSH
19746: LD_VAR 0 3
19750: ARRAY
19751: PUSH
19752: FOR_IN
19753: IFFALSE 19906
// begin if not b [ j ] then
19755: LD_VAR 0 6
19759: PUSH
19760: LD_VAR 0 3
19764: ARRAY
19765: NOT
19766: IFFALSE 19770
// break ;
19768: GO 19906
// e := 0 ;
19770: LD_ADDR_VAR 0 7
19774: PUSH
19775: LD_INT 0
19777: ST_TO_ADDR
// for k in b [ j ] do
19778: LD_ADDR_VAR 0 8
19782: PUSH
19783: LD_VAR 0 6
19787: PUSH
19788: LD_VAR 0 3
19792: ARRAY
19793: PUSH
19794: FOR_IN
19795: IFFALSE 19822
// if IsNotFull ( k ) then
19797: LD_VAR 0 8
19801: PPUSH
19802: CALL 47756 0 1
19806: IFFALSE 19820
// begin e := k ;
19808: LD_ADDR_VAR 0 7
19812: PUSH
19813: LD_VAR 0 8
19817: ST_TO_ADDR
// break ;
19818: GO 19822
// end ;
19820: GO 19794
19822: POP
19823: POP
// if e and not UnitGoingToBuilding ( p , e ) then
19824: LD_VAR 0 7
19828: PUSH
19829: LD_VAR 0 5
19833: PPUSH
19834: LD_VAR 0 7
19838: PPUSH
19839: CALL 84562 0 2
19843: NOT
19844: AND
19845: IFFALSE 19904
// begin if IsInUnit ( p ) then
19847: LD_VAR 0 5
19851: PPUSH
19852: CALL_OW 310
19856: IFFALSE 19867
// ComExitBuilding ( p ) ;
19858: LD_VAR 0 5
19862: PPUSH
19863: CALL_OW 122
// ComEnterUnit ( p , e ) ;
19867: LD_VAR 0 5
19871: PPUSH
19872: LD_VAR 0 7
19876: PPUSH
19877: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
19881: LD_VAR 0 5
19885: PPUSH
19886: LD_VAR 0 3
19890: PPUSH
19891: CALL_OW 183
// AddComExitBuilding ( p ) ;
19895: LD_VAR 0 5
19899: PPUSH
19900: CALL_OW 182
// end ; end ;
19904: GO 19752
19906: POP
19907: POP
// end ;
19908: GO 19718
19910: POP
19911: POP
// end ;
19912: GO 19473
19914: POP
19915: POP
// end ;
19916: LD_VAR 0 1
19920: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
19921: LD_INT 0
19923: PPUSH
19924: PPUSH
19925: PPUSH
19926: PPUSH
19927: PPUSH
19928: PPUSH
19929: PPUSH
19930: PPUSH
19931: PPUSH
19932: PPUSH
19933: PPUSH
19934: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
19935: LD_VAR 0 1
19939: NOT
19940: PUSH
19941: LD_EXP 49
19945: PUSH
19946: LD_VAR 0 1
19950: ARRAY
19951: NOT
19952: OR
19953: PUSH
19954: LD_EXP 49
19958: PUSH
19959: LD_VAR 0 1
19963: ARRAY
19964: PPUSH
19965: LD_INT 2
19967: PUSH
19968: LD_INT 30
19970: PUSH
19971: LD_INT 0
19973: PUSH
19974: EMPTY
19975: LIST
19976: LIST
19977: PUSH
19978: LD_INT 30
19980: PUSH
19981: LD_INT 1
19983: PUSH
19984: EMPTY
19985: LIST
19986: LIST
19987: PUSH
19988: EMPTY
19989: LIST
19990: LIST
19991: LIST
19992: PPUSH
19993: CALL_OW 72
19997: NOT
19998: OR
19999: IFFALSE 20003
// exit ;
20001: GO 23071
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
20003: LD_ADDR_VAR 0 4
20007: PUSH
20008: LD_EXP 49
20012: PUSH
20013: LD_VAR 0 1
20017: ARRAY
20018: PPUSH
20019: LD_INT 2
20021: PUSH
20022: LD_INT 25
20024: PUSH
20025: LD_INT 1
20027: PUSH
20028: EMPTY
20029: LIST
20030: LIST
20031: PUSH
20032: LD_INT 25
20034: PUSH
20035: LD_INT 2
20037: PUSH
20038: EMPTY
20039: LIST
20040: LIST
20041: PUSH
20042: LD_INT 25
20044: PUSH
20045: LD_INT 3
20047: PUSH
20048: EMPTY
20049: LIST
20050: LIST
20051: PUSH
20052: LD_INT 25
20054: PUSH
20055: LD_INT 4
20057: PUSH
20058: EMPTY
20059: LIST
20060: LIST
20061: PUSH
20062: LD_INT 25
20064: PUSH
20065: LD_INT 5
20067: PUSH
20068: EMPTY
20069: LIST
20070: LIST
20071: PUSH
20072: LD_INT 25
20074: PUSH
20075: LD_INT 8
20077: PUSH
20078: EMPTY
20079: LIST
20080: LIST
20081: PUSH
20082: LD_INT 25
20084: PUSH
20085: LD_INT 9
20087: PUSH
20088: EMPTY
20089: LIST
20090: LIST
20091: PUSH
20092: EMPTY
20093: LIST
20094: LIST
20095: LIST
20096: LIST
20097: LIST
20098: LIST
20099: LIST
20100: LIST
20101: PPUSH
20102: CALL_OW 72
20106: ST_TO_ADDR
// for i in tmp do
20107: LD_ADDR_VAR 0 3
20111: PUSH
20112: LD_VAR 0 4
20116: PUSH
20117: FOR_IN
20118: IFFALSE 20149
// if GetTag ( i ) then
20120: LD_VAR 0 3
20124: PPUSH
20125: CALL_OW 110
20129: IFFALSE 20147
// tmp := tmp diff i ;
20131: LD_ADDR_VAR 0 4
20135: PUSH
20136: LD_VAR 0 4
20140: PUSH
20141: LD_VAR 0 3
20145: DIFF
20146: ST_TO_ADDR
20147: GO 20117
20149: POP
20150: POP
// if not tmp then
20151: LD_VAR 0 4
20155: NOT
20156: IFFALSE 20160
// exit ;
20158: GO 23071
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
20160: LD_ADDR_VAR 0 5
20164: PUSH
20165: LD_EXP 49
20169: PUSH
20170: LD_VAR 0 1
20174: ARRAY
20175: PPUSH
20176: LD_INT 2
20178: PUSH
20179: LD_INT 25
20181: PUSH
20182: LD_INT 1
20184: PUSH
20185: EMPTY
20186: LIST
20187: LIST
20188: PUSH
20189: LD_INT 25
20191: PUSH
20192: LD_INT 5
20194: PUSH
20195: EMPTY
20196: LIST
20197: LIST
20198: PUSH
20199: LD_INT 25
20201: PUSH
20202: LD_INT 8
20204: PUSH
20205: EMPTY
20206: LIST
20207: LIST
20208: PUSH
20209: LD_INT 25
20211: PUSH
20212: LD_INT 9
20214: PUSH
20215: EMPTY
20216: LIST
20217: LIST
20218: PUSH
20219: EMPTY
20220: LIST
20221: LIST
20222: LIST
20223: LIST
20224: LIST
20225: PPUSH
20226: CALL_OW 72
20230: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
20231: LD_ADDR_VAR 0 6
20235: PUSH
20236: LD_EXP 49
20240: PUSH
20241: LD_VAR 0 1
20245: ARRAY
20246: PPUSH
20247: LD_INT 25
20249: PUSH
20250: LD_INT 2
20252: PUSH
20253: EMPTY
20254: LIST
20255: LIST
20256: PPUSH
20257: CALL_OW 72
20261: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
20262: LD_ADDR_VAR 0 7
20266: PUSH
20267: LD_EXP 49
20271: PUSH
20272: LD_VAR 0 1
20276: ARRAY
20277: PPUSH
20278: LD_INT 25
20280: PUSH
20281: LD_INT 3
20283: PUSH
20284: EMPTY
20285: LIST
20286: LIST
20287: PPUSH
20288: CALL_OW 72
20292: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ f_class , 4 ] ) ;
20293: LD_ADDR_VAR 0 8
20297: PUSH
20298: LD_EXP 49
20302: PUSH
20303: LD_VAR 0 1
20307: ARRAY
20308: PPUSH
20309: LD_INT 25
20311: PUSH
20312: LD_INT 4
20314: PUSH
20315: EMPTY
20316: LIST
20317: LIST
20318: PPUSH
20319: CALL_OW 72
20323: ST_TO_ADDR
// if mc_scan [ base ] then
20324: LD_EXP 72
20328: PUSH
20329: LD_VAR 0 1
20333: ARRAY
20334: IFFALSE 20786
// begin if debug_mc then
20336: LD_EXP 48
20340: IFFALSE 20350
// debug_strings := case 4 ;
20342: LD_ADDR_OWVAR 48
20346: PUSH
20347: LD_STRING case 4
20349: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
20350: LD_ADDR_VAR 0 12
20354: PUSH
20355: LD_EXP 49
20359: PUSH
20360: LD_VAR 0 1
20364: ARRAY
20365: PPUSH
20366: LD_INT 2
20368: PUSH
20369: LD_INT 30
20371: PUSH
20372: LD_INT 4
20374: PUSH
20375: EMPTY
20376: LIST
20377: LIST
20378: PUSH
20379: LD_INT 30
20381: PUSH
20382: LD_INT 5
20384: PUSH
20385: EMPTY
20386: LIST
20387: LIST
20388: PUSH
20389: EMPTY
20390: LIST
20391: LIST
20392: LIST
20393: PPUSH
20394: CALL_OW 72
20398: ST_TO_ADDR
// if not b then
20399: LD_VAR 0 12
20403: NOT
20404: IFFALSE 20408
// exit ;
20406: GO 23071
// p := [ ] ;
20408: LD_ADDR_VAR 0 11
20412: PUSH
20413: EMPTY
20414: ST_TO_ADDR
// if sci >= 2 then
20415: LD_VAR 0 8
20419: PUSH
20420: LD_INT 2
20422: GREATEREQUAL
20423: IFFALSE 20454
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
20425: LD_ADDR_VAR 0 8
20429: PUSH
20430: LD_VAR 0 8
20434: PUSH
20435: LD_INT 1
20437: ARRAY
20438: PUSH
20439: LD_VAR 0 8
20443: PUSH
20444: LD_INT 2
20446: ARRAY
20447: PUSH
20448: EMPTY
20449: LIST
20450: LIST
20451: ST_TO_ADDR
20452: GO 20515
// if sci = 1 then
20454: LD_VAR 0 8
20458: PUSH
20459: LD_INT 1
20461: EQUAL
20462: IFFALSE 20483
// sci := [ sci [ 1 ] ] else
20464: LD_ADDR_VAR 0 8
20468: PUSH
20469: LD_VAR 0 8
20473: PUSH
20474: LD_INT 1
20476: ARRAY
20477: PUSH
20478: EMPTY
20479: LIST
20480: ST_TO_ADDR
20481: GO 20515
// if sci = 0 then
20483: LD_VAR 0 8
20487: PUSH
20488: LD_INT 0
20490: EQUAL
20491: IFFALSE 20515
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
20493: LD_ADDR_VAR 0 11
20497: PUSH
20498: LD_VAR 0 4
20502: PPUSH
20503: LD_INT 4
20505: PPUSH
20506: CALL 84425 0 2
20510: PUSH
20511: LD_INT 1
20513: ARRAY
20514: ST_TO_ADDR
// if eng > 4 then
20515: LD_VAR 0 6
20519: PUSH
20520: LD_INT 4
20522: GREATER
20523: IFFALSE 20569
// for i = eng downto 4 do
20525: LD_ADDR_VAR 0 3
20529: PUSH
20530: DOUBLE
20531: LD_VAR 0 6
20535: INC
20536: ST_TO_ADDR
20537: LD_INT 4
20539: PUSH
20540: FOR_DOWNTO
20541: IFFALSE 20567
// eng := eng diff eng [ i ] ;
20543: LD_ADDR_VAR 0 6
20547: PUSH
20548: LD_VAR 0 6
20552: PUSH
20553: LD_VAR 0 6
20557: PUSH
20558: LD_VAR 0 3
20562: ARRAY
20563: DIFF
20564: ST_TO_ADDR
20565: GO 20540
20567: POP
20568: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
20569: LD_ADDR_VAR 0 4
20573: PUSH
20574: LD_VAR 0 4
20578: PUSH
20579: LD_VAR 0 5
20583: PUSH
20584: LD_VAR 0 6
20588: UNION
20589: PUSH
20590: LD_VAR 0 7
20594: UNION
20595: PUSH
20596: LD_VAR 0 8
20600: UNION
20601: DIFF
20602: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
20603: LD_ADDR_VAR 0 13
20607: PUSH
20608: LD_EXP 49
20612: PUSH
20613: LD_VAR 0 1
20617: ARRAY
20618: PPUSH
20619: LD_INT 2
20621: PUSH
20622: LD_INT 30
20624: PUSH
20625: LD_INT 32
20627: PUSH
20628: EMPTY
20629: LIST
20630: LIST
20631: PUSH
20632: LD_INT 30
20634: PUSH
20635: LD_INT 31
20637: PUSH
20638: EMPTY
20639: LIST
20640: LIST
20641: PUSH
20642: EMPTY
20643: LIST
20644: LIST
20645: LIST
20646: PPUSH
20647: CALL_OW 72
20651: PUSH
20652: LD_EXP 49
20656: PUSH
20657: LD_VAR 0 1
20661: ARRAY
20662: PPUSH
20663: LD_INT 2
20665: PUSH
20666: LD_INT 30
20668: PUSH
20669: LD_INT 4
20671: PUSH
20672: EMPTY
20673: LIST
20674: LIST
20675: PUSH
20676: LD_INT 30
20678: PUSH
20679: LD_INT 5
20681: PUSH
20682: EMPTY
20683: LIST
20684: LIST
20685: PUSH
20686: EMPTY
20687: LIST
20688: LIST
20689: LIST
20690: PPUSH
20691: CALL_OW 72
20695: PUSH
20696: LD_INT 6
20698: MUL
20699: PLUS
20700: ST_TO_ADDR
// if bcount < tmp then
20701: LD_VAR 0 13
20705: PUSH
20706: LD_VAR 0 4
20710: LESS
20711: IFFALSE 20757
// for i = tmp downto bcount do
20713: LD_ADDR_VAR 0 3
20717: PUSH
20718: DOUBLE
20719: LD_VAR 0 4
20723: INC
20724: ST_TO_ADDR
20725: LD_VAR 0 13
20729: PUSH
20730: FOR_DOWNTO
20731: IFFALSE 20755
// tmp := Delete ( tmp , tmp ) ;
20733: LD_ADDR_VAR 0 4
20737: PUSH
20738: LD_VAR 0 4
20742: PPUSH
20743: LD_VAR 0 4
20747: PPUSH
20748: CALL_OW 3
20752: ST_TO_ADDR
20753: GO 20730
20755: POP
20756: POP
// result := [ tmp , 0 , 0 , p ] ;
20757: LD_ADDR_VAR 0 2
20761: PUSH
20762: LD_VAR 0 4
20766: PUSH
20767: LD_INT 0
20769: PUSH
20770: LD_INT 0
20772: PUSH
20773: LD_VAR 0 11
20777: PUSH
20778: EMPTY
20779: LIST
20780: LIST
20781: LIST
20782: LIST
20783: ST_TO_ADDR
// exit ;
20784: GO 23071
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
20786: LD_EXP 49
20790: PUSH
20791: LD_VAR 0 1
20795: ARRAY
20796: PPUSH
20797: LD_INT 2
20799: PUSH
20800: LD_INT 30
20802: PUSH
20803: LD_INT 6
20805: PUSH
20806: EMPTY
20807: LIST
20808: LIST
20809: PUSH
20810: LD_INT 30
20812: PUSH
20813: LD_INT 7
20815: PUSH
20816: EMPTY
20817: LIST
20818: LIST
20819: PUSH
20820: LD_INT 30
20822: PUSH
20823: LD_INT 8
20825: PUSH
20826: EMPTY
20827: LIST
20828: LIST
20829: PUSH
20830: EMPTY
20831: LIST
20832: LIST
20833: LIST
20834: LIST
20835: PPUSH
20836: CALL_OW 72
20840: NOT
20841: PUSH
20842: LD_EXP 49
20846: PUSH
20847: LD_VAR 0 1
20851: ARRAY
20852: PPUSH
20853: LD_INT 30
20855: PUSH
20856: LD_INT 3
20858: PUSH
20859: EMPTY
20860: LIST
20861: LIST
20862: PPUSH
20863: CALL_OW 72
20867: NOT
20868: AND
20869: IFFALSE 20932
// begin if eng = tmp then
20871: LD_VAR 0 6
20875: PUSH
20876: LD_VAR 0 4
20880: EQUAL
20881: IFFALSE 20885
// exit ;
20883: GO 23071
// if debug_mc then
20885: LD_EXP 48
20889: IFFALSE 20899
// debug_strings := case 1 ;
20891: LD_ADDR_OWVAR 48
20895: PUSH
20896: LD_STRING case 1
20898: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
20899: LD_ADDR_VAR 0 2
20903: PUSH
20904: LD_INT 0
20906: PUSH
20907: LD_VAR 0 4
20911: PUSH
20912: LD_VAR 0 6
20916: DIFF
20917: PUSH
20918: LD_INT 0
20920: PUSH
20921: LD_INT 0
20923: PUSH
20924: EMPTY
20925: LIST
20926: LIST
20927: LIST
20928: LIST
20929: ST_TO_ADDR
// exit ;
20930: GO 23071
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
20932: LD_EXP 76
20936: PUSH
20937: LD_EXP 75
20941: PUSH
20942: LD_VAR 0 1
20946: ARRAY
20947: ARRAY
20948: PUSH
20949: LD_EXP 49
20953: PUSH
20954: LD_VAR 0 1
20958: ARRAY
20959: PPUSH
20960: LD_INT 2
20962: PUSH
20963: LD_INT 30
20965: PUSH
20966: LD_INT 6
20968: PUSH
20969: EMPTY
20970: LIST
20971: LIST
20972: PUSH
20973: LD_INT 30
20975: PUSH
20976: LD_INT 7
20978: PUSH
20979: EMPTY
20980: LIST
20981: LIST
20982: PUSH
20983: LD_INT 30
20985: PUSH
20986: LD_INT 8
20988: PUSH
20989: EMPTY
20990: LIST
20991: LIST
20992: PUSH
20993: EMPTY
20994: LIST
20995: LIST
20996: LIST
20997: LIST
20998: PPUSH
20999: CALL_OW 72
21003: AND
21004: PUSH
21005: LD_EXP 49
21009: PUSH
21010: LD_VAR 0 1
21014: ARRAY
21015: PPUSH
21016: LD_INT 30
21018: PUSH
21019: LD_INT 3
21021: PUSH
21022: EMPTY
21023: LIST
21024: LIST
21025: PPUSH
21026: CALL_OW 72
21030: NOT
21031: AND
21032: IFFALSE 21237
// begin if sci >= 6 then
21034: LD_VAR 0 8
21038: PUSH
21039: LD_INT 6
21041: GREATEREQUAL
21042: IFFALSE 21046
// exit ;
21044: GO 23071
// if debug_mc then
21046: LD_EXP 48
21050: IFFALSE 21060
// debug_strings := case 2 ;
21052: LD_ADDR_OWVAR 48
21056: PUSH
21057: LD_STRING case 2
21059: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
21060: LD_ADDR_VAR 0 9
21064: PUSH
21065: LD_VAR 0 4
21069: PUSH
21070: LD_VAR 0 8
21074: DIFF
21075: PPUSH
21076: LD_INT 4
21078: PPUSH
21079: CALL 84425 0 2
21083: ST_TO_ADDR
// p := [ ] ;
21084: LD_ADDR_VAR 0 11
21088: PUSH
21089: EMPTY
21090: ST_TO_ADDR
// if sci < 6 and sort > 6 then
21091: LD_VAR 0 8
21095: PUSH
21096: LD_INT 6
21098: LESS
21099: PUSH
21100: LD_VAR 0 9
21104: PUSH
21105: LD_INT 6
21107: GREATER
21108: AND
21109: IFFALSE 21190
// begin for i = 1 to 6 - sci do
21111: LD_ADDR_VAR 0 3
21115: PUSH
21116: DOUBLE
21117: LD_INT 1
21119: DEC
21120: ST_TO_ADDR
21121: LD_INT 6
21123: PUSH
21124: LD_VAR 0 8
21128: MINUS
21129: PUSH
21130: FOR_TO
21131: IFFALSE 21186
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
21133: LD_ADDR_VAR 0 11
21137: PUSH
21138: LD_VAR 0 11
21142: PPUSH
21143: LD_VAR 0 11
21147: PUSH
21148: LD_INT 1
21150: PLUS
21151: PPUSH
21152: LD_VAR 0 9
21156: PUSH
21157: LD_INT 1
21159: ARRAY
21160: PPUSH
21161: CALL_OW 2
21165: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
21166: LD_ADDR_VAR 0 9
21170: PUSH
21171: LD_VAR 0 9
21175: PPUSH
21176: LD_INT 1
21178: PPUSH
21179: CALL_OW 3
21183: ST_TO_ADDR
// end ;
21184: GO 21130
21186: POP
21187: POP
// end else
21188: GO 21210
// if sort then
21190: LD_VAR 0 9
21194: IFFALSE 21210
// p := sort [ 1 ] ;
21196: LD_ADDR_VAR 0 11
21200: PUSH
21201: LD_VAR 0 9
21205: PUSH
21206: LD_INT 1
21208: ARRAY
21209: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
21210: LD_ADDR_VAR 0 2
21214: PUSH
21215: LD_INT 0
21217: PUSH
21218: LD_INT 0
21220: PUSH
21221: LD_INT 0
21223: PUSH
21224: LD_VAR 0 11
21228: PUSH
21229: EMPTY
21230: LIST
21231: LIST
21232: LIST
21233: LIST
21234: ST_TO_ADDR
// exit ;
21235: GO 23071
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
21237: LD_EXP 76
21241: PUSH
21242: LD_EXP 75
21246: PUSH
21247: LD_VAR 0 1
21251: ARRAY
21252: ARRAY
21253: PUSH
21254: LD_EXP 49
21258: PUSH
21259: LD_VAR 0 1
21263: ARRAY
21264: PPUSH
21265: LD_INT 2
21267: PUSH
21268: LD_INT 30
21270: PUSH
21271: LD_INT 6
21273: PUSH
21274: EMPTY
21275: LIST
21276: LIST
21277: PUSH
21278: LD_INT 30
21280: PUSH
21281: LD_INT 7
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: PUSH
21288: LD_INT 30
21290: PUSH
21291: LD_INT 8
21293: PUSH
21294: EMPTY
21295: LIST
21296: LIST
21297: PUSH
21298: EMPTY
21299: LIST
21300: LIST
21301: LIST
21302: LIST
21303: PPUSH
21304: CALL_OW 72
21308: AND
21309: PUSH
21310: LD_EXP 49
21314: PUSH
21315: LD_VAR 0 1
21319: ARRAY
21320: PPUSH
21321: LD_INT 30
21323: PUSH
21324: LD_INT 3
21326: PUSH
21327: EMPTY
21328: LIST
21329: LIST
21330: PPUSH
21331: CALL_OW 72
21335: AND
21336: IFFALSE 21813
// begin if debug_mc then
21338: LD_EXP 48
21342: IFFALSE 21352
// debug_strings := case 3 ;
21344: LD_ADDR_OWVAR 48
21348: PUSH
21349: LD_STRING case 3
21351: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
21352: LD_ADDR_VAR 0 2
21356: PUSH
21357: LD_INT 0
21359: PUSH
21360: LD_INT 0
21362: PUSH
21363: LD_INT 0
21365: PUSH
21366: LD_INT 0
21368: PUSH
21369: EMPTY
21370: LIST
21371: LIST
21372: LIST
21373: LIST
21374: ST_TO_ADDR
// if not eng then
21375: LD_VAR 0 6
21379: NOT
21380: IFFALSE 21443
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
21382: LD_ADDR_VAR 0 11
21386: PUSH
21387: LD_VAR 0 4
21391: PPUSH
21392: LD_INT 2
21394: PPUSH
21395: CALL 84425 0 2
21399: PUSH
21400: LD_INT 1
21402: ARRAY
21403: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
21404: LD_ADDR_VAR 0 2
21408: PUSH
21409: LD_VAR 0 2
21413: PPUSH
21414: LD_INT 2
21416: PPUSH
21417: LD_VAR 0 11
21421: PPUSH
21422: CALL_OW 1
21426: ST_TO_ADDR
// tmp := tmp diff p ;
21427: LD_ADDR_VAR 0 4
21431: PUSH
21432: LD_VAR 0 4
21436: PUSH
21437: LD_VAR 0 11
21441: DIFF
21442: ST_TO_ADDR
// end ; tmp := tmp diff ( mech union sci ) ;
21443: LD_ADDR_VAR 0 4
21447: PUSH
21448: LD_VAR 0 4
21452: PUSH
21453: LD_VAR 0 7
21457: PUSH
21458: LD_VAR 0 8
21462: UNION
21463: DIFF
21464: ST_TO_ADDR
// if tmp and sci < 6 then
21465: LD_VAR 0 4
21469: PUSH
21470: LD_VAR 0 8
21474: PUSH
21475: LD_INT 6
21477: LESS
21478: AND
21479: IFFALSE 21638
// begin sort := SortBySkill ( tmp , 4 ) ;
21481: LD_ADDR_VAR 0 9
21485: PUSH
21486: LD_VAR 0 4
21490: PPUSH
21491: LD_INT 4
21493: PPUSH
21494: CALL 84425 0 2
21498: ST_TO_ADDR
// p := [ ] ;
21499: LD_ADDR_VAR 0 11
21503: PUSH
21504: EMPTY
21505: ST_TO_ADDR
// if sort then
21506: LD_VAR 0 9
21510: IFFALSE 21609
// for i = 1 to 6 - sci do
21512: LD_ADDR_VAR 0 3
21516: PUSH
21517: DOUBLE
21518: LD_INT 1
21520: DEC
21521: ST_TO_ADDR
21522: LD_INT 6
21524: PUSH
21525: LD_VAR 0 8
21529: MINUS
21530: PUSH
21531: FOR_TO
21532: IFFALSE 21607
// begin if i = sort then
21534: LD_VAR 0 3
21538: PUSH
21539: LD_VAR 0 9
21543: EQUAL
21544: IFFALSE 21548
// break ;
21546: GO 21607
// p := Insert ( p , p + 1 , sort [ i ] ) ;
21548: LD_ADDR_VAR 0 11
21552: PUSH
21553: LD_VAR 0 11
21557: PPUSH
21558: LD_VAR 0 11
21562: PUSH
21563: LD_INT 1
21565: PLUS
21566: PPUSH
21567: LD_VAR 0 9
21571: PUSH
21572: LD_VAR 0 3
21576: ARRAY
21577: PPUSH
21578: CALL_OW 2
21582: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
21583: LD_ADDR_VAR 0 4
21587: PUSH
21588: LD_VAR 0 4
21592: PUSH
21593: LD_VAR 0 9
21597: PUSH
21598: LD_VAR 0 3
21602: ARRAY
21603: DIFF
21604: ST_TO_ADDR
// end ;
21605: GO 21531
21607: POP
21608: POP
// if p then
21609: LD_VAR 0 11
21613: IFFALSE 21638
// result := Replace ( result , 4 , p ) ;
21615: LD_ADDR_VAR 0 2
21619: PUSH
21620: LD_VAR 0 2
21624: PPUSH
21625: LD_INT 4
21627: PPUSH
21628: LD_VAR 0 11
21632: PPUSH
21633: CALL_OW 1
21637: ST_TO_ADDR
// end ; if tmp and mech < 6 then
21638: LD_VAR 0 4
21642: PUSH
21643: LD_VAR 0 7
21647: PUSH
21648: LD_INT 6
21650: LESS
21651: AND
21652: IFFALSE 21811
// begin sort := SortBySkill ( tmp , 3 ) ;
21654: LD_ADDR_VAR 0 9
21658: PUSH
21659: LD_VAR 0 4
21663: PPUSH
21664: LD_INT 3
21666: PPUSH
21667: CALL 84425 0 2
21671: ST_TO_ADDR
// p := [ ] ;
21672: LD_ADDR_VAR 0 11
21676: PUSH
21677: EMPTY
21678: ST_TO_ADDR
// if sort then
21679: LD_VAR 0 9
21683: IFFALSE 21782
// for i = 1 to 6 - mech do
21685: LD_ADDR_VAR 0 3
21689: PUSH
21690: DOUBLE
21691: LD_INT 1
21693: DEC
21694: ST_TO_ADDR
21695: LD_INT 6
21697: PUSH
21698: LD_VAR 0 7
21702: MINUS
21703: PUSH
21704: FOR_TO
21705: IFFALSE 21780
// begin if i = sort then
21707: LD_VAR 0 3
21711: PUSH
21712: LD_VAR 0 9
21716: EQUAL
21717: IFFALSE 21721
// break ;
21719: GO 21780
// p := Insert ( p , p + 1 , sort [ i ] ) ;
21721: LD_ADDR_VAR 0 11
21725: PUSH
21726: LD_VAR 0 11
21730: PPUSH
21731: LD_VAR 0 11
21735: PUSH
21736: LD_INT 1
21738: PLUS
21739: PPUSH
21740: LD_VAR 0 9
21744: PUSH
21745: LD_VAR 0 3
21749: ARRAY
21750: PPUSH
21751: CALL_OW 2
21755: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
21756: LD_ADDR_VAR 0 4
21760: PUSH
21761: LD_VAR 0 4
21765: PUSH
21766: LD_VAR 0 9
21770: PUSH
21771: LD_VAR 0 3
21775: ARRAY
21776: DIFF
21777: ST_TO_ADDR
// end ;
21778: GO 21704
21780: POP
21781: POP
// if p then
21782: LD_VAR 0 11
21786: IFFALSE 21811
// result := Replace ( result , 3 , p ) ;
21788: LD_ADDR_VAR 0 2
21792: PUSH
21793: LD_VAR 0 2
21797: PPUSH
21798: LD_INT 3
21800: PPUSH
21801: LD_VAR 0 11
21805: PPUSH
21806: CALL_OW 1
21810: ST_TO_ADDR
// end ; exit ;
21811: GO 23071
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
21813: LD_EXP 76
21817: PUSH
21818: LD_EXP 75
21822: PUSH
21823: LD_VAR 0 1
21827: ARRAY
21828: ARRAY
21829: NOT
21830: PUSH
21831: LD_EXP 49
21835: PUSH
21836: LD_VAR 0 1
21840: ARRAY
21841: PPUSH
21842: LD_INT 30
21844: PUSH
21845: LD_INT 3
21847: PUSH
21848: EMPTY
21849: LIST
21850: LIST
21851: PPUSH
21852: CALL_OW 72
21856: AND
21857: PUSH
21858: LD_EXP 54
21862: PUSH
21863: LD_VAR 0 1
21867: ARRAY
21868: AND
21869: IFFALSE 22404
// begin if debug_mc then
21871: LD_EXP 48
21875: IFFALSE 21885
// debug_strings := case 5 ;
21877: LD_ADDR_OWVAR 48
21881: PUSH
21882: LD_STRING case 5
21884: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
21885: LD_ADDR_VAR 0 2
21889: PUSH
21890: LD_INT 0
21892: PUSH
21893: LD_INT 0
21895: PUSH
21896: LD_INT 0
21898: PUSH
21899: LD_INT 0
21901: PUSH
21902: EMPTY
21903: LIST
21904: LIST
21905: LIST
21906: LIST
21907: ST_TO_ADDR
// if sci > 1 then
21908: LD_VAR 0 8
21912: PUSH
21913: LD_INT 1
21915: GREATER
21916: IFFALSE 21944
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
21918: LD_ADDR_VAR 0 4
21922: PUSH
21923: LD_VAR 0 4
21927: PUSH
21928: LD_VAR 0 8
21932: PUSH
21933: LD_VAR 0 8
21937: PUSH
21938: LD_INT 1
21940: ARRAY
21941: DIFF
21942: DIFF
21943: ST_TO_ADDR
// if tmp and not sci then
21944: LD_VAR 0 4
21948: PUSH
21949: LD_VAR 0 8
21953: NOT
21954: AND
21955: IFFALSE 22024
// begin sort := SortBySkill ( tmp , 4 ) ;
21957: LD_ADDR_VAR 0 9
21961: PUSH
21962: LD_VAR 0 4
21966: PPUSH
21967: LD_INT 4
21969: PPUSH
21970: CALL 84425 0 2
21974: ST_TO_ADDR
// if sort then
21975: LD_VAR 0 9
21979: IFFALSE 21995
// p := sort [ 1 ] ;
21981: LD_ADDR_VAR 0 11
21985: PUSH
21986: LD_VAR 0 9
21990: PUSH
21991: LD_INT 1
21993: ARRAY
21994: ST_TO_ADDR
// if p then
21995: LD_VAR 0 11
21999: IFFALSE 22024
// result := Replace ( result , 4 , p ) ;
22001: LD_ADDR_VAR 0 2
22005: PUSH
22006: LD_VAR 0 2
22010: PPUSH
22011: LD_INT 4
22013: PPUSH
22014: LD_VAR 0 11
22018: PPUSH
22019: CALL_OW 1
22023: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
22024: LD_ADDR_VAR 0 4
22028: PUSH
22029: LD_VAR 0 4
22033: PUSH
22034: LD_VAR 0 7
22038: DIFF
22039: ST_TO_ADDR
// if tmp and mech < 6 then
22040: LD_VAR 0 4
22044: PUSH
22045: LD_VAR 0 7
22049: PUSH
22050: LD_INT 6
22052: LESS
22053: AND
22054: IFFALSE 22213
// begin sort := SortBySkill ( tmp , 3 ) ;
22056: LD_ADDR_VAR 0 9
22060: PUSH
22061: LD_VAR 0 4
22065: PPUSH
22066: LD_INT 3
22068: PPUSH
22069: CALL 84425 0 2
22073: ST_TO_ADDR
// p := [ ] ;
22074: LD_ADDR_VAR 0 11
22078: PUSH
22079: EMPTY
22080: ST_TO_ADDR
// if sort then
22081: LD_VAR 0 9
22085: IFFALSE 22184
// for i = 1 to 6 - mech do
22087: LD_ADDR_VAR 0 3
22091: PUSH
22092: DOUBLE
22093: LD_INT 1
22095: DEC
22096: ST_TO_ADDR
22097: LD_INT 6
22099: PUSH
22100: LD_VAR 0 7
22104: MINUS
22105: PUSH
22106: FOR_TO
22107: IFFALSE 22182
// begin if i = sort then
22109: LD_VAR 0 3
22113: PUSH
22114: LD_VAR 0 9
22118: EQUAL
22119: IFFALSE 22123
// break ;
22121: GO 22182
// p := Insert ( p , p + 1 , sort [ i ] ) ;
22123: LD_ADDR_VAR 0 11
22127: PUSH
22128: LD_VAR 0 11
22132: PPUSH
22133: LD_VAR 0 11
22137: PUSH
22138: LD_INT 1
22140: PLUS
22141: PPUSH
22142: LD_VAR 0 9
22146: PUSH
22147: LD_VAR 0 3
22151: ARRAY
22152: PPUSH
22153: CALL_OW 2
22157: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
22158: LD_ADDR_VAR 0 4
22162: PUSH
22163: LD_VAR 0 4
22167: PUSH
22168: LD_VAR 0 9
22172: PUSH
22173: LD_VAR 0 3
22177: ARRAY
22178: DIFF
22179: ST_TO_ADDR
// end ;
22180: GO 22106
22182: POP
22183: POP
// if p then
22184: LD_VAR 0 11
22188: IFFALSE 22213
// result := Replace ( result , 3 , p ) ;
22190: LD_ADDR_VAR 0 2
22194: PUSH
22195: LD_VAR 0 2
22199: PPUSH
22200: LD_INT 3
22202: PPUSH
22203: LD_VAR 0 11
22207: PPUSH
22208: CALL_OW 1
22212: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
22213: LD_ADDR_VAR 0 4
22217: PUSH
22218: LD_VAR 0 4
22222: PUSH
22223: LD_VAR 0 6
22227: DIFF
22228: ST_TO_ADDR
// if tmp and eng < 6 then
22229: LD_VAR 0 4
22233: PUSH
22234: LD_VAR 0 6
22238: PUSH
22239: LD_INT 6
22241: LESS
22242: AND
22243: IFFALSE 22402
// begin sort := SortBySkill ( tmp , 2 ) ;
22245: LD_ADDR_VAR 0 9
22249: PUSH
22250: LD_VAR 0 4
22254: PPUSH
22255: LD_INT 2
22257: PPUSH
22258: CALL 84425 0 2
22262: ST_TO_ADDR
// p := [ ] ;
22263: LD_ADDR_VAR 0 11
22267: PUSH
22268: EMPTY
22269: ST_TO_ADDR
// if sort then
22270: LD_VAR 0 9
22274: IFFALSE 22373
// for i = 1 to 6 - eng do
22276: LD_ADDR_VAR 0 3
22280: PUSH
22281: DOUBLE
22282: LD_INT 1
22284: DEC
22285: ST_TO_ADDR
22286: LD_INT 6
22288: PUSH
22289: LD_VAR 0 6
22293: MINUS
22294: PUSH
22295: FOR_TO
22296: IFFALSE 22371
// begin if i = sort then
22298: LD_VAR 0 3
22302: PUSH
22303: LD_VAR 0 9
22307: EQUAL
22308: IFFALSE 22312
// break ;
22310: GO 22371
// p := Insert ( p , p + 1 , sort [ i ] ) ;
22312: LD_ADDR_VAR 0 11
22316: PUSH
22317: LD_VAR 0 11
22321: PPUSH
22322: LD_VAR 0 11
22326: PUSH
22327: LD_INT 1
22329: PLUS
22330: PPUSH
22331: LD_VAR 0 9
22335: PUSH
22336: LD_VAR 0 3
22340: ARRAY
22341: PPUSH
22342: CALL_OW 2
22346: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
22347: LD_ADDR_VAR 0 4
22351: PUSH
22352: LD_VAR 0 4
22356: PUSH
22357: LD_VAR 0 9
22361: PUSH
22362: LD_VAR 0 3
22366: ARRAY
22367: DIFF
22368: ST_TO_ADDR
// end ;
22369: GO 22295
22371: POP
22372: POP
// if p then
22373: LD_VAR 0 11
22377: IFFALSE 22402
// result := Replace ( result , 2 , p ) ;
22379: LD_ADDR_VAR 0 2
22383: PUSH
22384: LD_VAR 0 2
22388: PPUSH
22389: LD_INT 2
22391: PPUSH
22392: LD_VAR 0 11
22396: PPUSH
22397: CALL_OW 1
22401: ST_TO_ADDR
// end ; exit ;
22402: GO 23071
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
22404: LD_EXP 76
22408: PUSH
22409: LD_EXP 75
22413: PUSH
22414: LD_VAR 0 1
22418: ARRAY
22419: ARRAY
22420: NOT
22421: PUSH
22422: LD_EXP 49
22426: PUSH
22427: LD_VAR 0 1
22431: ARRAY
22432: PPUSH
22433: LD_INT 30
22435: PUSH
22436: LD_INT 3
22438: PUSH
22439: EMPTY
22440: LIST
22441: LIST
22442: PPUSH
22443: CALL_OW 72
22447: AND
22448: PUSH
22449: LD_EXP 54
22453: PUSH
22454: LD_VAR 0 1
22458: ARRAY
22459: NOT
22460: AND
22461: IFFALSE 23071
// begin if debug_mc then
22463: LD_EXP 48
22467: IFFALSE 22477
// debug_strings := case 6 ;
22469: LD_ADDR_OWVAR 48
22473: PUSH
22474: LD_STRING case 6
22476: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
22477: LD_ADDR_VAR 0 2
22481: PUSH
22482: LD_INT 0
22484: PUSH
22485: LD_INT 0
22487: PUSH
22488: LD_INT 0
22490: PUSH
22491: LD_INT 0
22493: PUSH
22494: EMPTY
22495: LIST
22496: LIST
22497: LIST
22498: LIST
22499: ST_TO_ADDR
// if sci > 1 then
22500: LD_VAR 0 8
22504: PUSH
22505: LD_INT 1
22507: GREATER
22508: IFFALSE 22536
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
22510: LD_ADDR_VAR 0 4
22514: PUSH
22515: LD_VAR 0 4
22519: PUSH
22520: LD_VAR 0 8
22524: PUSH
22525: LD_VAR 0 8
22529: PUSH
22530: LD_INT 1
22532: ARRAY
22533: DIFF
22534: DIFF
22535: ST_TO_ADDR
// if tmp and not sci then
22536: LD_VAR 0 4
22540: PUSH
22541: LD_VAR 0 8
22545: NOT
22546: AND
22547: IFFALSE 22616
// begin sort := SortBySkill ( tmp , 4 ) ;
22549: LD_ADDR_VAR 0 9
22553: PUSH
22554: LD_VAR 0 4
22558: PPUSH
22559: LD_INT 4
22561: PPUSH
22562: CALL 84425 0 2
22566: ST_TO_ADDR
// if sort then
22567: LD_VAR 0 9
22571: IFFALSE 22587
// p := sort [ 1 ] ;
22573: LD_ADDR_VAR 0 11
22577: PUSH
22578: LD_VAR 0 9
22582: PUSH
22583: LD_INT 1
22585: ARRAY
22586: ST_TO_ADDR
// if p then
22587: LD_VAR 0 11
22591: IFFALSE 22616
// result := Replace ( result , 4 , p ) ;
22593: LD_ADDR_VAR 0 2
22597: PUSH
22598: LD_VAR 0 2
22602: PPUSH
22603: LD_INT 4
22605: PPUSH
22606: LD_VAR 0 11
22610: PPUSH
22611: CALL_OW 1
22615: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
22616: LD_ADDR_VAR 0 4
22620: PUSH
22621: LD_VAR 0 4
22625: PUSH
22626: LD_VAR 0 7
22630: DIFF
22631: ST_TO_ADDR
// if tmp and mech < 6 then
22632: LD_VAR 0 4
22636: PUSH
22637: LD_VAR 0 7
22641: PUSH
22642: LD_INT 6
22644: LESS
22645: AND
22646: IFFALSE 22805
// begin sort := SortBySkill ( tmp , 3 ) ;
22648: LD_ADDR_VAR 0 9
22652: PUSH
22653: LD_VAR 0 4
22657: PPUSH
22658: LD_INT 3
22660: PPUSH
22661: CALL 84425 0 2
22665: ST_TO_ADDR
// p := [ ] ;
22666: LD_ADDR_VAR 0 11
22670: PUSH
22671: EMPTY
22672: ST_TO_ADDR
// if sort then
22673: LD_VAR 0 9
22677: IFFALSE 22776
// for i = 1 to 6 - mech do
22679: LD_ADDR_VAR 0 3
22683: PUSH
22684: DOUBLE
22685: LD_INT 1
22687: DEC
22688: ST_TO_ADDR
22689: LD_INT 6
22691: PUSH
22692: LD_VAR 0 7
22696: MINUS
22697: PUSH
22698: FOR_TO
22699: IFFALSE 22774
// begin if i = sort then
22701: LD_VAR 0 3
22705: PUSH
22706: LD_VAR 0 9
22710: EQUAL
22711: IFFALSE 22715
// break ;
22713: GO 22774
// p := Insert ( p , p + 1 , sort [ i ] ) ;
22715: LD_ADDR_VAR 0 11
22719: PUSH
22720: LD_VAR 0 11
22724: PPUSH
22725: LD_VAR 0 11
22729: PUSH
22730: LD_INT 1
22732: PLUS
22733: PPUSH
22734: LD_VAR 0 9
22738: PUSH
22739: LD_VAR 0 3
22743: ARRAY
22744: PPUSH
22745: CALL_OW 2
22749: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
22750: LD_ADDR_VAR 0 4
22754: PUSH
22755: LD_VAR 0 4
22759: PUSH
22760: LD_VAR 0 9
22764: PUSH
22765: LD_VAR 0 3
22769: ARRAY
22770: DIFF
22771: ST_TO_ADDR
// end ;
22772: GO 22698
22774: POP
22775: POP
// if p then
22776: LD_VAR 0 11
22780: IFFALSE 22805
// result := Replace ( result , 3 , p ) ;
22782: LD_ADDR_VAR 0 2
22786: PUSH
22787: LD_VAR 0 2
22791: PPUSH
22792: LD_INT 3
22794: PPUSH
22795: LD_VAR 0 11
22799: PPUSH
22800: CALL_OW 1
22804: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
22805: LD_ADDR_VAR 0 4
22809: PUSH
22810: LD_VAR 0 4
22814: PUSH
22815: LD_VAR 0 6
22819: DIFF
22820: ST_TO_ADDR
// if tmp and eng < 4 then
22821: LD_VAR 0 4
22825: PUSH
22826: LD_VAR 0 6
22830: PUSH
22831: LD_INT 4
22833: LESS
22834: AND
22835: IFFALSE 22996
// begin sort := SortBySkill ( tmp , 2 ) ;
22837: LD_ADDR_VAR 0 9
22841: PUSH
22842: LD_VAR 0 4
22846: PPUSH
22847: LD_INT 2
22849: PPUSH
22850: CALL 84425 0 2
22854: ST_TO_ADDR
// p := [ ] ;
22855: LD_ADDR_VAR 0 11
22859: PUSH
22860: EMPTY
22861: ST_TO_ADDR
// if sort then
22862: LD_VAR 0 9
22866: IFFALSE 22965
// for i = 1 to 4 - eng do
22868: LD_ADDR_VAR 0 3
22872: PUSH
22873: DOUBLE
22874: LD_INT 1
22876: DEC
22877: ST_TO_ADDR
22878: LD_INT 4
22880: PUSH
22881: LD_VAR 0 6
22885: MINUS
22886: PUSH
22887: FOR_TO
22888: IFFALSE 22963
// begin if i = sort then
22890: LD_VAR 0 3
22894: PUSH
22895: LD_VAR 0 9
22899: EQUAL
22900: IFFALSE 22904
// break ;
22902: GO 22963
// p := Insert ( p , p + 1 , sort [ i ] ) ;
22904: LD_ADDR_VAR 0 11
22908: PUSH
22909: LD_VAR 0 11
22913: PPUSH
22914: LD_VAR 0 11
22918: PUSH
22919: LD_INT 1
22921: PLUS
22922: PPUSH
22923: LD_VAR 0 9
22927: PUSH
22928: LD_VAR 0 3
22932: ARRAY
22933: PPUSH
22934: CALL_OW 2
22938: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
22939: LD_ADDR_VAR 0 4
22943: PUSH
22944: LD_VAR 0 4
22948: PUSH
22949: LD_VAR 0 9
22953: PUSH
22954: LD_VAR 0 3
22958: ARRAY
22959: DIFF
22960: ST_TO_ADDR
// end ;
22961: GO 22887
22963: POP
22964: POP
// if p then
22965: LD_VAR 0 11
22969: IFFALSE 22994
// result := Replace ( result , 2 , p ) ;
22971: LD_ADDR_VAR 0 2
22975: PUSH
22976: LD_VAR 0 2
22980: PPUSH
22981: LD_INT 2
22983: PPUSH
22984: LD_VAR 0 11
22988: PPUSH
22989: CALL_OW 1
22993: ST_TO_ADDR
// end else
22994: GO 23040
// for i = eng downto 5 do
22996: LD_ADDR_VAR 0 3
23000: PUSH
23001: DOUBLE
23002: LD_VAR 0 6
23006: INC
23007: ST_TO_ADDR
23008: LD_INT 5
23010: PUSH
23011: FOR_DOWNTO
23012: IFFALSE 23038
// tmp := tmp union eng [ i ] ;
23014: LD_ADDR_VAR 0 4
23018: PUSH
23019: LD_VAR 0 4
23023: PUSH
23024: LD_VAR 0 6
23028: PUSH
23029: LD_VAR 0 3
23033: ARRAY
23034: UNION
23035: ST_TO_ADDR
23036: GO 23011
23038: POP
23039: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
23040: LD_ADDR_VAR 0 2
23044: PUSH
23045: LD_VAR 0 2
23049: PPUSH
23050: LD_INT 1
23052: PPUSH
23053: LD_VAR 0 4
23057: PUSH
23058: LD_VAR 0 5
23062: DIFF
23063: PPUSH
23064: CALL_OW 1
23068: ST_TO_ADDR
// exit ;
23069: GO 23071
// end ; end ;
23071: LD_VAR 0 2
23075: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
23076: LD_INT 0
23078: PPUSH
23079: PPUSH
23080: PPUSH
// if not mc_bases then
23081: LD_EXP 49
23085: NOT
23086: IFFALSE 23090
// exit ;
23088: GO 23196
// for i = 1 to mc_bases do
23090: LD_ADDR_VAR 0 2
23094: PUSH
23095: DOUBLE
23096: LD_INT 1
23098: DEC
23099: ST_TO_ADDR
23100: LD_EXP 49
23104: PUSH
23105: FOR_TO
23106: IFFALSE 23187
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
23108: LD_ADDR_VAR 0 3
23112: PUSH
23113: LD_EXP 49
23117: PUSH
23118: LD_VAR 0 2
23122: ARRAY
23123: PPUSH
23124: LD_INT 21
23126: PUSH
23127: LD_INT 3
23129: PUSH
23130: EMPTY
23131: LIST
23132: LIST
23133: PUSH
23134: LD_INT 3
23136: PUSH
23137: LD_INT 24
23139: PUSH
23140: LD_INT 1000
23142: PUSH
23143: EMPTY
23144: LIST
23145: LIST
23146: PUSH
23147: EMPTY
23148: LIST
23149: LIST
23150: PUSH
23151: EMPTY
23152: LIST
23153: LIST
23154: PPUSH
23155: CALL_OW 72
23159: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
23160: LD_ADDR_EXP 50
23164: PUSH
23165: LD_EXP 50
23169: PPUSH
23170: LD_VAR 0 2
23174: PPUSH
23175: LD_VAR 0 3
23179: PPUSH
23180: CALL_OW 1
23184: ST_TO_ADDR
// end ;
23185: GO 23105
23187: POP
23188: POP
// RaiseSailEvent ( 101 ) ;
23189: LD_INT 101
23191: PPUSH
23192: CALL_OW 427
// end ;
23196: LD_VAR 0 1
23200: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
23201: LD_INT 0
23203: PPUSH
23204: PPUSH
23205: PPUSH
23206: PPUSH
23207: PPUSH
23208: PPUSH
23209: PPUSH
// if not mc_bases then
23210: LD_EXP 49
23214: NOT
23215: IFFALSE 23219
// exit ;
23217: GO 23754
// for i = 1 to mc_bases do
23219: LD_ADDR_VAR 0 2
23223: PUSH
23224: DOUBLE
23225: LD_INT 1
23227: DEC
23228: ST_TO_ADDR
23229: LD_EXP 49
23233: PUSH
23234: FOR_TO
23235: IFFALSE 23745
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 700 ] ] ] ] ) ;
23237: LD_ADDR_VAR 0 5
23241: PUSH
23242: LD_EXP 49
23246: PUSH
23247: LD_VAR 0 2
23251: ARRAY
23252: PUSH
23253: LD_EXP 78
23257: PUSH
23258: LD_VAR 0 2
23262: ARRAY
23263: UNION
23264: PPUSH
23265: LD_INT 21
23267: PUSH
23268: LD_INT 1
23270: PUSH
23271: EMPTY
23272: LIST
23273: LIST
23274: PUSH
23275: LD_INT 1
23277: PUSH
23278: LD_INT 3
23280: PUSH
23281: LD_INT 54
23283: PUSH
23284: EMPTY
23285: LIST
23286: PUSH
23287: EMPTY
23288: LIST
23289: LIST
23290: PUSH
23291: LD_INT 3
23293: PUSH
23294: LD_INT 24
23296: PUSH
23297: LD_INT 700
23299: PUSH
23300: EMPTY
23301: LIST
23302: LIST
23303: PUSH
23304: EMPTY
23305: LIST
23306: LIST
23307: PUSH
23308: EMPTY
23309: LIST
23310: LIST
23311: LIST
23312: PUSH
23313: EMPTY
23314: LIST
23315: LIST
23316: PPUSH
23317: CALL_OW 72
23321: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
23322: LD_ADDR_VAR 0 6
23326: PUSH
23327: LD_EXP 49
23331: PUSH
23332: LD_VAR 0 2
23336: ARRAY
23337: PPUSH
23338: LD_INT 21
23340: PUSH
23341: LD_INT 1
23343: PUSH
23344: EMPTY
23345: LIST
23346: LIST
23347: PUSH
23348: LD_INT 1
23350: PUSH
23351: LD_INT 3
23353: PUSH
23354: LD_INT 54
23356: PUSH
23357: EMPTY
23358: LIST
23359: PUSH
23360: EMPTY
23361: LIST
23362: LIST
23363: PUSH
23364: LD_INT 3
23366: PUSH
23367: LD_INT 24
23369: PUSH
23370: LD_INT 250
23372: PUSH
23373: EMPTY
23374: LIST
23375: LIST
23376: PUSH
23377: EMPTY
23378: LIST
23379: LIST
23380: PUSH
23381: EMPTY
23382: LIST
23383: LIST
23384: LIST
23385: PUSH
23386: EMPTY
23387: LIST
23388: LIST
23389: PPUSH
23390: CALL_OW 72
23394: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
23395: LD_ADDR_VAR 0 7
23399: PUSH
23400: LD_VAR 0 5
23404: PUSH
23405: LD_VAR 0 6
23409: DIFF
23410: ST_TO_ADDR
// if not need_heal_1 then
23411: LD_VAR 0 6
23415: NOT
23416: IFFALSE 23449
// mc_need_heal := Add ( mc_need_heal , [ i , 1 ] , [ ] ) else
23418: LD_ADDR_EXP 52
23422: PUSH
23423: LD_EXP 52
23427: PPUSH
23428: LD_VAR 0 2
23432: PUSH
23433: LD_INT 1
23435: PUSH
23436: EMPTY
23437: LIST
23438: LIST
23439: PPUSH
23440: EMPTY
23441: PPUSH
23442: CALL 50857 0 3
23446: ST_TO_ADDR
23447: GO 23481
// mc_need_heal := Add ( mc_need_heal , [ i , 1 ] , need_heal_1 ) ;
23449: LD_ADDR_EXP 52
23453: PUSH
23454: LD_EXP 52
23458: PPUSH
23459: LD_VAR 0 2
23463: PUSH
23464: LD_INT 1
23466: PUSH
23467: EMPTY
23468: LIST
23469: LIST
23470: PPUSH
23471: LD_VAR 0 6
23475: PPUSH
23476: CALL 50857 0 3
23480: ST_TO_ADDR
// if not need_heal_2 then
23481: LD_VAR 0 7
23485: NOT
23486: IFFALSE 23519
// mc_need_heal := Add ( mc_need_heal , [ i , 2 ] , [ ] ) else
23488: LD_ADDR_EXP 52
23492: PUSH
23493: LD_EXP 52
23497: PPUSH
23498: LD_VAR 0 2
23502: PUSH
23503: LD_INT 2
23505: PUSH
23506: EMPTY
23507: LIST
23508: LIST
23509: PPUSH
23510: EMPTY
23511: PPUSH
23512: CALL 50857 0 3
23516: ST_TO_ADDR
23517: GO 23551
// mc_need_heal := Add ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
23519: LD_ADDR_EXP 52
23523: PUSH
23524: LD_EXP 52
23528: PPUSH
23529: LD_VAR 0 2
23533: PUSH
23534: LD_INT 2
23536: PUSH
23537: EMPTY
23538: LIST
23539: LIST
23540: PPUSH
23541: LD_VAR 0 7
23545: PPUSH
23546: CALL 50857 0 3
23550: ST_TO_ADDR
// if need_heal_2 then
23551: LD_VAR 0 7
23555: IFFALSE 23727
// for j in need_heal_2 do
23557: LD_ADDR_VAR 0 3
23561: PUSH
23562: LD_VAR 0 7
23566: PUSH
23567: FOR_IN
23568: IFFALSE 23725
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
23570: LD_ADDR_VAR 0 5
23574: PUSH
23575: LD_EXP 49
23579: PUSH
23580: LD_VAR 0 2
23584: ARRAY
23585: PPUSH
23586: LD_INT 2
23588: PUSH
23589: LD_INT 30
23591: PUSH
23592: LD_INT 6
23594: PUSH
23595: EMPTY
23596: LIST
23597: LIST
23598: PUSH
23599: LD_INT 30
23601: PUSH
23602: LD_INT 7
23604: PUSH
23605: EMPTY
23606: LIST
23607: LIST
23608: PUSH
23609: LD_INT 30
23611: PUSH
23612: LD_INT 8
23614: PUSH
23615: EMPTY
23616: LIST
23617: LIST
23618: PUSH
23619: LD_INT 30
23621: PUSH
23622: LD_INT 0
23624: PUSH
23625: EMPTY
23626: LIST
23627: LIST
23628: PUSH
23629: LD_INT 30
23631: PUSH
23632: LD_INT 1
23634: PUSH
23635: EMPTY
23636: LIST
23637: LIST
23638: PUSH
23639: LD_INT 25
23641: PUSH
23642: LD_INT 4
23644: PUSH
23645: EMPTY
23646: LIST
23647: LIST
23648: PUSH
23649: EMPTY
23650: LIST
23651: LIST
23652: LIST
23653: LIST
23654: LIST
23655: LIST
23656: LIST
23657: PPUSH
23658: CALL_OW 72
23662: ST_TO_ADDR
// if tmp then
23663: LD_VAR 0 5
23667: IFFALSE 23723
// begin k := NearestUnitToUnit ( tmp , j ) ;
23669: LD_ADDR_VAR 0 4
23673: PUSH
23674: LD_VAR 0 5
23678: PPUSH
23679: LD_VAR 0 3
23683: PPUSH
23684: CALL_OW 74
23688: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
23689: LD_VAR 0 3
23693: PPUSH
23694: LD_VAR 0 4
23698: PPUSH
23699: CALL_OW 296
23703: PUSH
23704: LD_INT 7
23706: GREATER
23707: IFFALSE 23723
// ComMoveUnit ( j , k ) ;
23709: LD_VAR 0 3
23713: PPUSH
23714: LD_VAR 0 4
23718: PPUSH
23719: CALL_OW 112
// end ; end ;
23723: GO 23567
23725: POP
23726: POP
// if not need_heal_1 and not need_heal_2 then
23727: LD_VAR 0 6
23731: NOT
23732: PUSH
23733: LD_VAR 0 7
23737: NOT
23738: AND
23739: IFFALSE 23743
// continue ;
23741: GO 23234
// end ;
23743: GO 23234
23745: POP
23746: POP
// RaiseSailEvent ( 102 ) ;
23747: LD_INT 102
23749: PPUSH
23750: CALL_OW 427
// end ;
23754: LD_VAR 0 1
23758: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
23759: LD_INT 0
23761: PPUSH
23762: PPUSH
23763: PPUSH
23764: PPUSH
23765: PPUSH
// if not mc_bases then
23766: LD_EXP 49
23770: NOT
23771: IFFALSE 23775
// exit ;
23773: GO 24160
// for i = 1 to mc_bases do
23775: LD_ADDR_VAR 0 2
23779: PUSH
23780: DOUBLE
23781: LD_INT 1
23783: DEC
23784: ST_TO_ADDR
23785: LD_EXP 49
23789: PUSH
23790: FOR_TO
23791: IFFALSE 24158
// begin if not mc_building_need_repair [ i ] then
23793: LD_EXP 50
23797: PUSH
23798: LD_VAR 0 2
23802: ARRAY
23803: NOT
23804: IFFALSE 23842
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23806: LD_ADDR_EXP 51
23810: PUSH
23811: LD_EXP 51
23815: PPUSH
23816: LD_VAR 0 2
23820: PPUSH
23821: EMPTY
23822: PPUSH
23823: CALL_OW 1
23827: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
23828: LD_VAR 0 2
23832: PPUSH
23833: LD_INT 101
23835: PPUSH
23836: CALL 19344 0 2
// continue ;
23840: GO 23790
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
23842: LD_ADDR_EXP 55
23846: PUSH
23847: LD_EXP 55
23851: PPUSH
23852: LD_VAR 0 2
23856: PPUSH
23857: EMPTY
23858: PPUSH
23859: CALL_OW 1
23863: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
23864: LD_VAR 0 2
23868: PPUSH
23869: LD_INT 103
23871: PPUSH
23872: CALL 19344 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
23876: LD_ADDR_VAR 0 5
23880: PUSH
23881: LD_EXP 49
23885: PUSH
23886: LD_VAR 0 2
23890: ARRAY
23891: PUSH
23892: LD_EXP 78
23896: PUSH
23897: LD_VAR 0 2
23901: ARRAY
23902: UNION
23903: PPUSH
23904: LD_INT 2
23906: PUSH
23907: LD_INT 25
23909: PUSH
23910: LD_INT 2
23912: PUSH
23913: EMPTY
23914: LIST
23915: LIST
23916: PUSH
23917: LD_INT 25
23919: PUSH
23920: LD_INT 16
23922: PUSH
23923: EMPTY
23924: LIST
23925: LIST
23926: PUSH
23927: EMPTY
23928: LIST
23929: LIST
23930: LIST
23931: PUSH
23932: EMPTY
23933: LIST
23934: PPUSH
23935: CALL_OW 72
23939: ST_TO_ADDR
// if not tmp then
23940: LD_VAR 0 5
23944: NOT
23945: IFFALSE 23949
// continue ;
23947: GO 23790
// for j in tmp do
23949: LD_ADDR_VAR 0 3
23953: PUSH
23954: LD_VAR 0 5
23958: PUSH
23959: FOR_IN
23960: IFFALSE 24154
// begin if mc_need_heal [ i ] then
23962: LD_EXP 52
23966: PUSH
23967: LD_VAR 0 2
23971: ARRAY
23972: IFFALSE 24020
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
23974: LD_VAR 0 3
23978: PUSH
23979: LD_EXP 52
23983: PUSH
23984: LD_VAR 0 2
23988: ARRAY
23989: PUSH
23990: LD_INT 1
23992: ARRAY
23993: IN
23994: PUSH
23995: LD_VAR 0 3
23999: PUSH
24000: LD_EXP 52
24004: PUSH
24005: LD_VAR 0 2
24009: ARRAY
24010: PUSH
24011: LD_INT 2
24013: ARRAY
24014: IN
24015: OR
24016: IFFALSE 24020
// continue ;
24018: GO 23959
// if IsInUnit ( j ) then
24020: LD_VAR 0 3
24024: PPUSH
24025: CALL_OW 310
24029: IFFALSE 24040
// ComExitBuilding ( j ) ;
24031: LD_VAR 0 3
24035: PPUSH
24036: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
24040: LD_VAR 0 3
24044: PUSH
24045: LD_EXP 51
24049: PUSH
24050: LD_VAR 0 2
24054: ARRAY
24055: IN
24056: NOT
24057: IFFALSE 24115
// begin SetTag ( j , 101 ) ;
24059: LD_VAR 0 3
24063: PPUSH
24064: LD_INT 101
24066: PPUSH
24067: CALL_OW 109
// mc_building_repairs := Add ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
24071: LD_ADDR_EXP 51
24075: PUSH
24076: LD_EXP 51
24080: PPUSH
24081: LD_VAR 0 2
24085: PUSH
24086: LD_EXP 51
24090: PUSH
24091: LD_VAR 0 2
24095: ARRAY
24096: PUSH
24097: LD_INT 1
24099: PLUS
24100: PUSH
24101: EMPTY
24102: LIST
24103: LIST
24104: PPUSH
24105: LD_VAR 0 3
24109: PPUSH
24110: CALL 50857 0 3
24114: ST_TO_ADDR
// end ; Wait ( 3 ) ;
24115: LD_INT 3
24117: PPUSH
24118: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
24122: LD_VAR 0 3
24126: PPUSH
24127: LD_EXP 50
24131: PUSH
24132: LD_VAR 0 2
24136: ARRAY
24137: PPUSH
24138: LD_VAR 0 3
24142: PPUSH
24143: CALL_OW 74
24147: PPUSH
24148: CALL_OW 130
// end ;
24152: GO 23959
24154: POP
24155: POP
// end ;
24156: GO 23790
24158: POP
24159: POP
// end ;
24160: LD_VAR 0 1
24164: RET
// export function MC_Heal ; var i , j , tmp ; begin
24165: LD_INT 0
24167: PPUSH
24168: PPUSH
24169: PPUSH
24170: PPUSH
// if not mc_bases then
24171: LD_EXP 49
24175: NOT
24176: IFFALSE 24180
// exit ;
24178: GO 24582
// for i = 1 to mc_bases do
24180: LD_ADDR_VAR 0 2
24184: PUSH
24185: DOUBLE
24186: LD_INT 1
24188: DEC
24189: ST_TO_ADDR
24190: LD_EXP 49
24194: PUSH
24195: FOR_TO
24196: IFFALSE 24580
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
24198: LD_EXP 52
24202: PUSH
24203: LD_VAR 0 2
24207: ARRAY
24208: PUSH
24209: LD_INT 1
24211: ARRAY
24212: NOT
24213: PUSH
24214: LD_EXP 52
24218: PUSH
24219: LD_VAR 0 2
24223: ARRAY
24224: PUSH
24225: LD_INT 2
24227: ARRAY
24228: NOT
24229: AND
24230: IFFALSE 24268
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
24232: LD_ADDR_EXP 53
24236: PUSH
24237: LD_EXP 53
24241: PPUSH
24242: LD_VAR 0 2
24246: PPUSH
24247: EMPTY
24248: PPUSH
24249: CALL_OW 1
24253: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
24254: LD_VAR 0 2
24258: PPUSH
24259: LD_INT 102
24261: PPUSH
24262: CALL 19344 0 2
// continue ;
24266: GO 24195
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
24268: LD_ADDR_VAR 0 4
24272: PUSH
24273: LD_EXP 49
24277: PUSH
24278: LD_VAR 0 2
24282: ARRAY
24283: PPUSH
24284: LD_INT 25
24286: PUSH
24287: LD_INT 4
24289: PUSH
24290: EMPTY
24291: LIST
24292: LIST
24293: PPUSH
24294: CALL_OW 72
24298: ST_TO_ADDR
// if not tmp then
24299: LD_VAR 0 4
24303: NOT
24304: IFFALSE 24308
// continue ;
24306: GO 24195
// if mc_taming [ i ] then
24308: LD_EXP 80
24312: PUSH
24313: LD_VAR 0 2
24317: ARRAY
24318: IFFALSE 24342
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
24320: LD_ADDR_EXP 80
24324: PUSH
24325: LD_EXP 80
24329: PPUSH
24330: LD_VAR 0 2
24334: PPUSH
24335: EMPTY
24336: PPUSH
24337: CALL_OW 1
24341: ST_TO_ADDR
// for j in tmp do
24342: LD_ADDR_VAR 0 3
24346: PUSH
24347: LD_VAR 0 4
24351: PUSH
24352: FOR_IN
24353: IFFALSE 24576
// begin if IsInUnit ( j ) then
24355: LD_VAR 0 3
24359: PPUSH
24360: CALL_OW 310
24364: IFFALSE 24375
// ComExitBuilding ( j ) ;
24366: LD_VAR 0 3
24370: PPUSH
24371: CALL_OW 122
// if not j in mc_healers [ i ] then
24375: LD_VAR 0 3
24379: PUSH
24380: LD_EXP 53
24384: PUSH
24385: LD_VAR 0 2
24389: ARRAY
24390: IN
24391: NOT
24392: IFFALSE 24438
// mc_healers := Add ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
24394: LD_ADDR_EXP 53
24398: PUSH
24399: LD_EXP 53
24403: PPUSH
24404: LD_VAR 0 2
24408: PUSH
24409: LD_EXP 53
24413: PUSH
24414: LD_VAR 0 2
24418: ARRAY
24419: PUSH
24420: LD_INT 1
24422: PLUS
24423: PUSH
24424: EMPTY
24425: LIST
24426: LIST
24427: PPUSH
24428: LD_VAR 0 3
24432: PPUSH
24433: CALL 50857 0 3
24437: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
24438: LD_VAR 0 3
24442: PPUSH
24443: CALL_OW 110
24447: PUSH
24448: LD_INT 102
24450: NONEQUAL
24451: IFFALSE 24465
// SetTag ( j , 102 ) ;
24453: LD_VAR 0 3
24457: PPUSH
24458: LD_INT 102
24460: PPUSH
24461: CALL_OW 109
// Wait ( 3 ) ;
24465: LD_INT 3
24467: PPUSH
24468: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
24472: LD_EXP 52
24476: PUSH
24477: LD_VAR 0 2
24481: ARRAY
24482: PUSH
24483: LD_INT 1
24485: ARRAY
24486: IFFALSE 24518
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
24488: LD_VAR 0 3
24492: PPUSH
24493: LD_EXP 52
24497: PUSH
24498: LD_VAR 0 2
24502: ARRAY
24503: PUSH
24504: LD_INT 1
24506: ARRAY
24507: PUSH
24508: LD_INT 1
24510: ARRAY
24511: PPUSH
24512: CALL_OW 128
24516: GO 24574
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
24518: LD_VAR 0 3
24522: PPUSH
24523: CALL_OW 314
24527: NOT
24528: PUSH
24529: LD_EXP 52
24533: PUSH
24534: LD_VAR 0 2
24538: ARRAY
24539: PUSH
24540: LD_INT 2
24542: ARRAY
24543: AND
24544: IFFALSE 24574
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
24546: LD_VAR 0 3
24550: PPUSH
24551: LD_EXP 52
24555: PUSH
24556: LD_VAR 0 2
24560: ARRAY
24561: PUSH
24562: LD_INT 2
24564: ARRAY
24565: PUSH
24566: LD_INT 1
24568: ARRAY
24569: PPUSH
24570: CALL_OW 128
// end ;
24574: GO 24352
24576: POP
24577: POP
// end ;
24578: GO 24195
24580: POP
24581: POP
// end ;
24582: LD_VAR 0 1
24586: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
24587: LD_INT 0
24589: PPUSH
24590: PPUSH
24591: PPUSH
24592: PPUSH
24593: PPUSH
// if not mc_bases then
24594: LD_EXP 49
24598: NOT
24599: IFFALSE 24603
// exit ;
24601: GO 25746
// for i = 1 to mc_bases do
24603: LD_ADDR_VAR 0 2
24607: PUSH
24608: DOUBLE
24609: LD_INT 1
24611: DEC
24612: ST_TO_ADDR
24613: LD_EXP 49
24617: PUSH
24618: FOR_TO
24619: IFFALSE 25744
// begin if mc_scan [ i ] then
24621: LD_EXP 72
24625: PUSH
24626: LD_VAR 0 2
24630: ARRAY
24631: IFFALSE 24635
// continue ;
24633: GO 24618
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
24635: LD_EXP 54
24639: PUSH
24640: LD_VAR 0 2
24644: ARRAY
24645: NOT
24646: PUSH
24647: LD_EXP 56
24651: PUSH
24652: LD_VAR 0 2
24656: ARRAY
24657: NOT
24658: AND
24659: PUSH
24660: LD_EXP 55
24664: PUSH
24665: LD_VAR 0 2
24669: ARRAY
24670: AND
24671: IFFALSE 24709
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
24673: LD_ADDR_EXP 55
24677: PUSH
24678: LD_EXP 55
24682: PPUSH
24683: LD_VAR 0 2
24687: PPUSH
24688: EMPTY
24689: PPUSH
24690: CALL_OW 1
24694: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
24695: LD_VAR 0 2
24699: PPUSH
24700: LD_INT 103
24702: PPUSH
24703: CALL 19344 0 2
// continue ;
24707: GO 24618
// end ; if mc_construct_list [ i ] then
24709: LD_EXP 56
24713: PUSH
24714: LD_VAR 0 2
24718: ARRAY
24719: IFFALSE 24939
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
24721: LD_ADDR_VAR 0 4
24725: PUSH
24726: LD_EXP 49
24730: PUSH
24731: LD_VAR 0 2
24735: ARRAY
24736: PPUSH
24737: LD_INT 25
24739: PUSH
24740: LD_INT 2
24742: PUSH
24743: EMPTY
24744: LIST
24745: LIST
24746: PPUSH
24747: CALL_OW 72
24751: PUSH
24752: LD_EXP 51
24756: PUSH
24757: LD_VAR 0 2
24761: ARRAY
24762: DIFF
24763: ST_TO_ADDR
// if not tmp then
24764: LD_VAR 0 4
24768: NOT
24769: IFFALSE 24773
// continue ;
24771: GO 24618
// for j in tmp do
24773: LD_ADDR_VAR 0 3
24777: PUSH
24778: LD_VAR 0 4
24782: PUSH
24783: FOR_IN
24784: IFFALSE 24935
// begin if not mc_builders [ i ] then
24786: LD_EXP 55
24790: PUSH
24791: LD_VAR 0 2
24795: ARRAY
24796: NOT
24797: IFFALSE 24855
// begin SetTag ( j , 103 ) ;
24799: LD_VAR 0 3
24803: PPUSH
24804: LD_INT 103
24806: PPUSH
24807: CALL_OW 109
// mc_builders := Add ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
24811: LD_ADDR_EXP 55
24815: PUSH
24816: LD_EXP 55
24820: PPUSH
24821: LD_VAR 0 2
24825: PUSH
24826: LD_EXP 55
24830: PUSH
24831: LD_VAR 0 2
24835: ARRAY
24836: PUSH
24837: LD_INT 1
24839: PLUS
24840: PUSH
24841: EMPTY
24842: LIST
24843: LIST
24844: PPUSH
24845: LD_VAR 0 3
24849: PPUSH
24850: CALL 50857 0 3
24854: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
24855: LD_VAR 0 3
24859: PPUSH
24860: CALL_OW 310
24864: IFFALSE 24875
// ComExitBuilding ( j ) ;
24866: LD_VAR 0 3
24870: PPUSH
24871: CALL_OW 122
// wait ( 3 ) ;
24875: LD_INT 3
24877: PPUSH
24878: CALL_OW 67
// if not mc_construct_list [ i ] then
24882: LD_EXP 56
24886: PUSH
24887: LD_VAR 0 2
24891: ARRAY
24892: NOT
24893: IFFALSE 24897
// break ;
24895: GO 24935
// if not HasTask ( j ) then
24897: LD_VAR 0 3
24901: PPUSH
24902: CALL_OW 314
24906: NOT
24907: IFFALSE 24933
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
24909: LD_VAR 0 3
24913: PPUSH
24914: LD_EXP 56
24918: PUSH
24919: LD_VAR 0 2
24923: ARRAY
24924: PUSH
24925: LD_INT 1
24927: ARRAY
24928: PPUSH
24929: CALL 53293 0 2
// end ;
24933: GO 24783
24935: POP
24936: POP
// end else
24937: GO 25742
// if mc_build_list [ i ] then
24939: LD_EXP 54
24943: PUSH
24944: LD_VAR 0 2
24948: ARRAY
24949: IFFALSE 25742
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
24951: LD_ADDR_VAR 0 5
24955: PUSH
24956: LD_EXP 49
24960: PUSH
24961: LD_VAR 0 2
24965: ARRAY
24966: PPUSH
24967: LD_INT 2
24969: PUSH
24970: LD_INT 30
24972: PUSH
24973: LD_INT 0
24975: PUSH
24976: EMPTY
24977: LIST
24978: LIST
24979: PUSH
24980: LD_INT 30
24982: PUSH
24983: LD_INT 1
24985: PUSH
24986: EMPTY
24987: LIST
24988: LIST
24989: PUSH
24990: EMPTY
24991: LIST
24992: LIST
24993: LIST
24994: PPUSH
24995: CALL_OW 72
24999: ST_TO_ADDR
// if depot then
25000: LD_VAR 0 5
25004: IFFALSE 25022
// depot := depot [ 1 ] else
25006: LD_ADDR_VAR 0 5
25010: PUSH
25011: LD_VAR 0 5
25015: PUSH
25016: LD_INT 1
25018: ARRAY
25019: ST_TO_ADDR
25020: GO 25030
// depot := 0 ;
25022: LD_ADDR_VAR 0 5
25026: PUSH
25027: LD_INT 0
25029: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
25030: LD_EXP 54
25034: PUSH
25035: LD_VAR 0 2
25039: ARRAY
25040: PUSH
25041: LD_INT 1
25043: ARRAY
25044: PUSH
25045: LD_INT 1
25047: ARRAY
25048: PPUSH
25049: CALL 53136 0 1
25053: PUSH
25054: LD_EXP 49
25058: PUSH
25059: LD_VAR 0 2
25063: ARRAY
25064: PPUSH
25065: LD_INT 2
25067: PUSH
25068: LD_INT 30
25070: PUSH
25071: LD_INT 2
25073: PUSH
25074: EMPTY
25075: LIST
25076: LIST
25077: PUSH
25078: LD_INT 30
25080: PUSH
25081: LD_INT 3
25083: PUSH
25084: EMPTY
25085: LIST
25086: LIST
25087: PUSH
25088: EMPTY
25089: LIST
25090: LIST
25091: LIST
25092: PPUSH
25093: CALL_OW 72
25097: NOT
25098: AND
25099: IFFALSE 25204
// begin for j = 1 to mc_build_list [ i ] do
25101: LD_ADDR_VAR 0 3
25105: PUSH
25106: DOUBLE
25107: LD_INT 1
25109: DEC
25110: ST_TO_ADDR
25111: LD_EXP 54
25115: PUSH
25116: LD_VAR 0 2
25120: ARRAY
25121: PUSH
25122: FOR_TO
25123: IFFALSE 25202
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
25125: LD_EXP 54
25129: PUSH
25130: LD_VAR 0 2
25134: ARRAY
25135: PUSH
25136: LD_VAR 0 3
25140: ARRAY
25141: PUSH
25142: LD_INT 1
25144: ARRAY
25145: PUSH
25146: LD_INT 2
25148: EQUAL
25149: IFFALSE 25200
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
25151: LD_ADDR_EXP 54
25155: PUSH
25156: LD_EXP 54
25160: PPUSH
25161: LD_VAR 0 2
25165: PPUSH
25166: LD_EXP 54
25170: PUSH
25171: LD_VAR 0 2
25175: ARRAY
25176: PPUSH
25177: LD_VAR 0 3
25181: PPUSH
25182: LD_INT 1
25184: PPUSH
25185: LD_INT 0
25187: PPUSH
25188: CALL 49840 0 4
25192: PPUSH
25193: CALL_OW 1
25197: ST_TO_ADDR
// break ;
25198: GO 25202
// end ;
25200: GO 25122
25202: POP
25203: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
25204: LD_EXP 54
25208: PUSH
25209: LD_VAR 0 2
25213: ARRAY
25214: PUSH
25215: LD_INT 1
25217: ARRAY
25218: PUSH
25219: LD_INT 1
25221: ARRAY
25222: PUSH
25223: LD_INT 0
25225: EQUAL
25226: PUSH
25227: LD_VAR 0 5
25231: PUSH
25232: LD_VAR 0 5
25236: PPUSH
25237: LD_EXP 54
25241: PUSH
25242: LD_VAR 0 2
25246: ARRAY
25247: PUSH
25248: LD_INT 1
25250: ARRAY
25251: PUSH
25252: LD_INT 1
25254: ARRAY
25255: PPUSH
25256: LD_EXP 54
25260: PUSH
25261: LD_VAR 0 2
25265: ARRAY
25266: PUSH
25267: LD_INT 1
25269: ARRAY
25270: PUSH
25271: LD_INT 2
25273: ARRAY
25274: PPUSH
25275: LD_EXP 54
25279: PUSH
25280: LD_VAR 0 2
25284: ARRAY
25285: PUSH
25286: LD_INT 1
25288: ARRAY
25289: PUSH
25290: LD_INT 3
25292: ARRAY
25293: PPUSH
25294: LD_EXP 54
25298: PUSH
25299: LD_VAR 0 2
25303: ARRAY
25304: PUSH
25305: LD_INT 1
25307: ARRAY
25308: PUSH
25309: LD_INT 4
25311: ARRAY
25312: PPUSH
25313: CALL 57645 0 5
25317: AND
25318: OR
25319: IFFALSE 25600
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
25321: LD_ADDR_VAR 0 4
25325: PUSH
25326: LD_EXP 49
25330: PUSH
25331: LD_VAR 0 2
25335: ARRAY
25336: PPUSH
25337: LD_INT 25
25339: PUSH
25340: LD_INT 2
25342: PUSH
25343: EMPTY
25344: LIST
25345: LIST
25346: PPUSH
25347: CALL_OW 72
25351: PUSH
25352: LD_EXP 51
25356: PUSH
25357: LD_VAR 0 2
25361: ARRAY
25362: DIFF
25363: ST_TO_ADDR
// if not tmp then
25364: LD_VAR 0 4
25368: NOT
25369: IFFALSE 25373
// continue ;
25371: GO 24618
// for j in tmp do
25373: LD_ADDR_VAR 0 3
25377: PUSH
25378: LD_VAR 0 4
25382: PUSH
25383: FOR_IN
25384: IFFALSE 25596
// begin if not mc_builders [ i ] then
25386: LD_EXP 55
25390: PUSH
25391: LD_VAR 0 2
25395: ARRAY
25396: NOT
25397: IFFALSE 25455
// begin SetTag ( j , 103 ) ;
25399: LD_VAR 0 3
25403: PPUSH
25404: LD_INT 103
25406: PPUSH
25407: CALL_OW 109
// mc_builders := Add ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
25411: LD_ADDR_EXP 55
25415: PUSH
25416: LD_EXP 55
25420: PPUSH
25421: LD_VAR 0 2
25425: PUSH
25426: LD_EXP 55
25430: PUSH
25431: LD_VAR 0 2
25435: ARRAY
25436: PUSH
25437: LD_INT 1
25439: PLUS
25440: PUSH
25441: EMPTY
25442: LIST
25443: LIST
25444: PPUSH
25445: LD_VAR 0 3
25449: PPUSH
25450: CALL 50857 0 3
25454: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
25455: LD_VAR 0 3
25459: PPUSH
25460: CALL_OW 310
25464: IFFALSE 25475
// ComExitBuilding ( j ) ;
25466: LD_VAR 0 3
25470: PPUSH
25471: CALL_OW 122
// wait ( 3 ) ;
25475: LD_INT 3
25477: PPUSH
25478: CALL_OW 67
// if not mc_build_list [ i ] then
25482: LD_EXP 54
25486: PUSH
25487: LD_VAR 0 2
25491: ARRAY
25492: NOT
25493: IFFALSE 25497
// break ;
25495: GO 25596
// if not HasTask ( j ) then
25497: LD_VAR 0 3
25501: PPUSH
25502: CALL_OW 314
25506: NOT
25507: IFFALSE 25594
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
25509: LD_VAR 0 3
25513: PPUSH
25514: LD_EXP 54
25518: PUSH
25519: LD_VAR 0 2
25523: ARRAY
25524: PUSH
25525: LD_INT 1
25527: ARRAY
25528: PUSH
25529: LD_INT 1
25531: ARRAY
25532: PPUSH
25533: LD_EXP 54
25537: PUSH
25538: LD_VAR 0 2
25542: ARRAY
25543: PUSH
25544: LD_INT 1
25546: ARRAY
25547: PUSH
25548: LD_INT 2
25550: ARRAY
25551: PPUSH
25552: LD_EXP 54
25556: PUSH
25557: LD_VAR 0 2
25561: ARRAY
25562: PUSH
25563: LD_INT 1
25565: ARRAY
25566: PUSH
25567: LD_INT 3
25569: ARRAY
25570: PPUSH
25571: LD_EXP 54
25575: PUSH
25576: LD_VAR 0 2
25580: ARRAY
25581: PUSH
25582: LD_INT 1
25584: ARRAY
25585: PUSH
25586: LD_INT 4
25588: ARRAY
25589: PPUSH
25590: CALL_OW 145
// end ;
25594: GO 25383
25596: POP
25597: POP
// end else
25598: GO 25742
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
25600: LD_EXP 49
25604: PUSH
25605: LD_VAR 0 2
25609: ARRAY
25610: PPUSH
25611: LD_EXP 54
25615: PUSH
25616: LD_VAR 0 2
25620: ARRAY
25621: PUSH
25622: LD_INT 1
25624: ARRAY
25625: PUSH
25626: LD_INT 1
25628: ARRAY
25629: PPUSH
25630: LD_EXP 54
25634: PUSH
25635: LD_VAR 0 2
25639: ARRAY
25640: PUSH
25641: LD_INT 1
25643: ARRAY
25644: PUSH
25645: LD_INT 2
25647: ARRAY
25648: PPUSH
25649: LD_EXP 54
25653: PUSH
25654: LD_VAR 0 2
25658: ARRAY
25659: PUSH
25660: LD_INT 1
25662: ARRAY
25663: PUSH
25664: LD_INT 3
25666: ARRAY
25667: PPUSH
25668: LD_EXP 54
25672: PUSH
25673: LD_VAR 0 2
25677: ARRAY
25678: PUSH
25679: LD_INT 1
25681: ARRAY
25682: PUSH
25683: LD_INT 4
25685: ARRAY
25686: PPUSH
25687: CALL 57076 0 5
25691: NOT
25692: IFFALSE 25742
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
25694: LD_ADDR_EXP 54
25698: PUSH
25699: LD_EXP 54
25703: PPUSH
25704: LD_VAR 0 2
25708: PPUSH
25709: LD_EXP 54
25713: PUSH
25714: LD_VAR 0 2
25718: ARRAY
25719: PPUSH
25720: LD_INT 1
25722: PPUSH
25723: LD_INT 1
25725: NEG
25726: PPUSH
25727: LD_INT 0
25729: PPUSH
25730: CALL 49840 0 4
25734: PPUSH
25735: CALL_OW 1
25739: ST_TO_ADDR
// continue ;
25740: GO 24618
// end ; end ; end ;
25742: GO 24618
25744: POP
25745: POP
// end ;
25746: LD_VAR 0 1
25750: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
25751: LD_INT 0
25753: PPUSH
25754: PPUSH
25755: PPUSH
25756: PPUSH
25757: PPUSH
25758: PPUSH
// if not mc_bases then
25759: LD_EXP 49
25763: NOT
25764: IFFALSE 25768
// exit ;
25766: GO 26195
// for i = 1 to mc_bases do
25768: LD_ADDR_VAR 0 2
25772: PUSH
25773: DOUBLE
25774: LD_INT 1
25776: DEC
25777: ST_TO_ADDR
25778: LD_EXP 49
25782: PUSH
25783: FOR_TO
25784: IFFALSE 26193
// begin tmp := mc_build_upgrade [ i ] ;
25786: LD_ADDR_VAR 0 4
25790: PUSH
25791: LD_EXP 81
25795: PUSH
25796: LD_VAR 0 2
25800: ARRAY
25801: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
25802: LD_ADDR_VAR 0 6
25806: PUSH
25807: LD_EXP 82
25811: PUSH
25812: LD_VAR 0 2
25816: ARRAY
25817: PPUSH
25818: LD_INT 2
25820: PUSH
25821: LD_INT 30
25823: PUSH
25824: LD_INT 6
25826: PUSH
25827: EMPTY
25828: LIST
25829: LIST
25830: PUSH
25831: LD_INT 30
25833: PUSH
25834: LD_INT 7
25836: PUSH
25837: EMPTY
25838: LIST
25839: LIST
25840: PUSH
25841: EMPTY
25842: LIST
25843: LIST
25844: LIST
25845: PPUSH
25846: CALL_OW 72
25850: ST_TO_ADDR
// if not tmp and not lab then
25851: LD_VAR 0 4
25855: NOT
25856: PUSH
25857: LD_VAR 0 6
25861: NOT
25862: AND
25863: IFFALSE 25867
// continue ;
25865: GO 25783
// if tmp then
25867: LD_VAR 0 4
25871: IFFALSE 25991
// for j in tmp do
25873: LD_ADDR_VAR 0 3
25877: PUSH
25878: LD_VAR 0 4
25882: PUSH
25883: FOR_IN
25884: IFFALSE 25989
// begin if UpgradeCost ( j ) then
25886: LD_VAR 0 3
25890: PPUSH
25891: CALL 56736 0 1
25895: IFFALSE 25987
// begin ComUpgrade ( j ) ;
25897: LD_VAR 0 3
25901: PPUSH
25902: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
25906: LD_ADDR_EXP 81
25910: PUSH
25911: LD_EXP 81
25915: PPUSH
25916: LD_VAR 0 2
25920: PPUSH
25921: LD_EXP 81
25925: PUSH
25926: LD_VAR 0 2
25930: ARRAY
25931: PUSH
25932: LD_VAR 0 3
25936: DIFF
25937: PPUSH
25938: CALL_OW 1
25942: ST_TO_ADDR
// mc_construct_list := Add ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
25943: LD_ADDR_EXP 56
25947: PUSH
25948: LD_EXP 56
25952: PPUSH
25953: LD_VAR 0 2
25957: PUSH
25958: LD_EXP 56
25962: PUSH
25963: LD_VAR 0 2
25967: ARRAY
25968: PUSH
25969: LD_INT 1
25971: PLUS
25972: PUSH
25973: EMPTY
25974: LIST
25975: LIST
25976: PPUSH
25977: LD_VAR 0 3
25981: PPUSH
25982: CALL 50857 0 3
25986: ST_TO_ADDR
// end ; end ;
25987: GO 25883
25989: POP
25990: POP
// if not lab or not mc_lab_upgrade [ i ] then
25991: LD_VAR 0 6
25995: NOT
25996: PUSH
25997: LD_EXP 83
26001: PUSH
26002: LD_VAR 0 2
26006: ARRAY
26007: NOT
26008: OR
26009: IFFALSE 26013
// continue ;
26011: GO 25783
// for j in lab do
26013: LD_ADDR_VAR 0 3
26017: PUSH
26018: LD_VAR 0 6
26022: PUSH
26023: FOR_IN
26024: IFFALSE 26189
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
26026: LD_VAR 0 3
26030: PPUSH
26031: CALL_OW 266
26035: PUSH
26036: LD_INT 6
26038: PUSH
26039: LD_INT 7
26041: PUSH
26042: EMPTY
26043: LIST
26044: LIST
26045: IN
26046: PUSH
26047: LD_VAR 0 3
26051: PPUSH
26052: CALL_OW 461
26056: PUSH
26057: LD_INT 1
26059: NONEQUAL
26060: AND
26061: IFFALSE 26187
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
26063: LD_VAR 0 3
26067: PPUSH
26068: LD_EXP 83
26072: PUSH
26073: LD_VAR 0 2
26077: ARRAY
26078: PUSH
26079: LD_INT 1
26081: ARRAY
26082: PPUSH
26083: CALL 56941 0 2
26087: IFFALSE 26187
// begin ComCancel ( j ) ;
26089: LD_VAR 0 3
26093: PPUSH
26094: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
26098: LD_VAR 0 3
26102: PPUSH
26103: LD_EXP 83
26107: PUSH
26108: LD_VAR 0 2
26112: ARRAY
26113: PUSH
26114: LD_INT 1
26116: ARRAY
26117: PPUSH
26118: CALL_OW 207
// if not j in mc_construct_list [ i ] then
26122: LD_VAR 0 3
26126: PUSH
26127: LD_EXP 56
26131: PUSH
26132: LD_VAR 0 2
26136: ARRAY
26137: IN
26138: NOT
26139: IFFALSE 26185
// mc_construct_list := Add ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
26141: LD_ADDR_EXP 56
26145: PUSH
26146: LD_EXP 56
26150: PPUSH
26151: LD_VAR 0 2
26155: PUSH
26156: LD_EXP 56
26160: PUSH
26161: LD_VAR 0 2
26165: ARRAY
26166: PUSH
26167: LD_INT 1
26169: PLUS
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: PPUSH
26175: LD_VAR 0 3
26179: PPUSH
26180: CALL 50857 0 3
26184: ST_TO_ADDR
// break ;
26185: GO 26189
// end ; end ; end ;
26187: GO 26023
26189: POP
26190: POP
// end ;
26191: GO 25783
26193: POP
26194: POP
// end ;
26195: LD_VAR 0 1
26199: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
26200: LD_INT 0
26202: PPUSH
26203: PPUSH
26204: PPUSH
26205: PPUSH
26206: PPUSH
26207: PPUSH
26208: PPUSH
26209: PPUSH
26210: PPUSH
// if not mc_bases then
26211: LD_EXP 49
26215: NOT
26216: IFFALSE 26220
// exit ;
26218: GO 26614
// for i = 1 to mc_bases do
26220: LD_ADDR_VAR 0 2
26224: PUSH
26225: DOUBLE
26226: LD_INT 1
26228: DEC
26229: ST_TO_ADDR
26230: LD_EXP 49
26234: PUSH
26235: FOR_TO
26236: IFFALSE 26612
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
26238: LD_EXP 57
26242: PUSH
26243: LD_VAR 0 2
26247: ARRAY
26248: NOT
26249: PUSH
26250: LD_EXP 49
26254: PUSH
26255: LD_VAR 0 2
26259: ARRAY
26260: PPUSH
26261: LD_INT 30
26263: PUSH
26264: LD_INT 3
26266: PUSH
26267: EMPTY
26268: LIST
26269: LIST
26270: PPUSH
26271: CALL_OW 72
26275: NOT
26276: OR
26277: IFFALSE 26281
// continue ;
26279: GO 26235
// busy := false ;
26281: LD_ADDR_VAR 0 8
26285: PUSH
26286: LD_INT 0
26288: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
26289: LD_ADDR_VAR 0 4
26293: PUSH
26294: LD_EXP 49
26298: PUSH
26299: LD_VAR 0 2
26303: ARRAY
26304: PPUSH
26305: LD_INT 30
26307: PUSH
26308: LD_INT 3
26310: PUSH
26311: EMPTY
26312: LIST
26313: LIST
26314: PPUSH
26315: CALL_OW 72
26319: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
26320: LD_ADDR_VAR 0 6
26324: PUSH
26325: LD_EXP 57
26329: PUSH
26330: LD_VAR 0 2
26334: ARRAY
26335: PPUSH
26336: LD_INT 2
26338: PUSH
26339: LD_INT 30
26341: PUSH
26342: LD_INT 32
26344: PUSH
26345: EMPTY
26346: LIST
26347: LIST
26348: PUSH
26349: LD_INT 30
26351: PUSH
26352: LD_INT 33
26354: PUSH
26355: EMPTY
26356: LIST
26357: LIST
26358: PUSH
26359: EMPTY
26360: LIST
26361: LIST
26362: LIST
26363: PPUSH
26364: CALL_OW 72
26368: ST_TO_ADDR
// if not t then
26369: LD_VAR 0 6
26373: NOT
26374: IFFALSE 26378
// continue ;
26376: GO 26235
// for j in tmp do
26378: LD_ADDR_VAR 0 3
26382: PUSH
26383: LD_VAR 0 4
26387: PUSH
26388: FOR_IN
26389: IFFALSE 26419
// if not BuildingStatus ( j ) = bs_idle then
26391: LD_VAR 0 3
26395: PPUSH
26396: CALL_OW 461
26400: PUSH
26401: LD_INT 2
26403: EQUAL
26404: NOT
26405: IFFALSE 26417
// begin busy := true ;
26407: LD_ADDR_VAR 0 8
26411: PUSH
26412: LD_INT 1
26414: ST_TO_ADDR
// break ;
26415: GO 26419
// end ;
26417: GO 26388
26419: POP
26420: POP
// if busy then
26421: LD_VAR 0 8
26425: IFFALSE 26429
// continue ;
26427: GO 26235
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
26429: LD_ADDR_VAR 0 7
26433: PUSH
26434: LD_VAR 0 6
26438: PPUSH
26439: LD_INT 35
26441: PUSH
26442: LD_INT 0
26444: PUSH
26445: EMPTY
26446: LIST
26447: LIST
26448: PPUSH
26449: CALL_OW 72
26453: ST_TO_ADDR
// if tw then
26454: LD_VAR 0 7
26458: IFFALSE 26524
// begin tw := tw [ 1 ] ;
26460: LD_ADDR_VAR 0 7
26464: PUSH
26465: LD_VAR 0 7
26469: PUSH
26470: LD_INT 1
26472: ARRAY
26473: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw ) ;
26474: LD_ADDR_VAR 0 9
26478: PUSH
26479: LD_VAR 0 7
26483: PPUSH
26484: CALL 55300 0 1
26488: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
26489: LD_EXP 88
26493: PUSH
26494: LD_VAR 0 2
26498: ARRAY
26499: IFFALSE 26522
// if not weapon in mc_allowed_tower_weapons [ i ] then
26501: LD_VAR 0 9
26505: PUSH
26506: LD_EXP 88
26510: PUSH
26511: LD_VAR 0 2
26515: ARRAY
26516: IN
26517: NOT
26518: IFFALSE 26522
// continue ;
26520: GO 26235
// end else
26522: GO 26587
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
26524: LD_ADDR_VAR 0 5
26528: PUSH
26529: LD_EXP 57
26533: PUSH
26534: LD_VAR 0 2
26538: ARRAY
26539: PPUSH
26540: LD_VAR 0 4
26544: PPUSH
26545: CALL 85349 0 2
26549: ST_TO_ADDR
// if not tmp2 then
26550: LD_VAR 0 5
26554: NOT
26555: IFFALSE 26559
// continue ;
26557: GO 26235
// tw := tmp2 [ 1 ] ;
26559: LD_ADDR_VAR 0 7
26563: PUSH
26564: LD_VAR 0 5
26568: PUSH
26569: LD_INT 1
26571: ARRAY
26572: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
26573: LD_ADDR_VAR 0 9
26577: PUSH
26578: LD_VAR 0 5
26582: PUSH
26583: LD_INT 2
26585: ARRAY
26586: ST_TO_ADDR
// end ; if not weapon then
26587: LD_VAR 0 9
26591: NOT
26592: IFFALSE 26596
// continue ;
26594: GO 26235
// ComPlaceWeapon ( tw , weapon ) ;
26596: LD_VAR 0 7
26600: PPUSH
26601: LD_VAR 0 9
26605: PPUSH
26606: CALL_OW 148
// end ;
26610: GO 26235
26612: POP
26613: POP
// end ;
26614: LD_VAR 0 1
26618: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
26619: LD_INT 0
26621: PPUSH
26622: PPUSH
26623: PPUSH
26624: PPUSH
26625: PPUSH
26626: PPUSH
// if not mc_bases then
26627: LD_EXP 49
26631: NOT
26632: IFFALSE 26636
// exit ;
26634: GO 27648
// for i = 1 to mc_bases do
26636: LD_ADDR_VAR 0 2
26640: PUSH
26641: DOUBLE
26642: LD_INT 1
26644: DEC
26645: ST_TO_ADDR
26646: LD_EXP 49
26650: PUSH
26651: FOR_TO
26652: IFFALSE 27646
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
26654: LD_EXP 62
26658: PUSH
26659: LD_VAR 0 2
26663: ARRAY
26664: NOT
26665: PUSH
26666: LD_EXP 62
26670: PUSH
26671: LD_VAR 0 2
26675: ARRAY
26676: PUSH
26677: LD_EXP 63
26681: PUSH
26682: LD_VAR 0 2
26686: ARRAY
26687: EQUAL
26688: OR
26689: IFFALSE 26693
// continue ;
26691: GO 26651
// if mc_miners [ i ] then
26693: LD_EXP 63
26697: PUSH
26698: LD_VAR 0 2
26702: ARRAY
26703: IFFALSE 27333
// begin k := 1 ;
26705: LD_ADDR_VAR 0 4
26709: PUSH
26710: LD_INT 1
26712: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
26713: LD_ADDR_VAR 0 3
26717: PUSH
26718: DOUBLE
26719: LD_EXP 63
26723: PUSH
26724: LD_VAR 0 2
26728: ARRAY
26729: INC
26730: ST_TO_ADDR
26731: LD_INT 1
26733: PUSH
26734: FOR_DOWNTO
26735: IFFALSE 27331
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
26737: LD_EXP 63
26741: PUSH
26742: LD_VAR 0 2
26746: ARRAY
26747: PUSH
26748: LD_VAR 0 3
26752: ARRAY
26753: PPUSH
26754: CALL_OW 301
26758: PUSH
26759: LD_EXP 63
26763: PUSH
26764: LD_VAR 0 2
26768: ARRAY
26769: PUSH
26770: LD_VAR 0 3
26774: ARRAY
26775: PPUSH
26776: CALL_OW 257
26780: PUSH
26781: LD_INT 1
26783: NONEQUAL
26784: OR
26785: IFFALSE 26848
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
26787: LD_ADDR_VAR 0 5
26791: PUSH
26792: LD_EXP 63
26796: PUSH
26797: LD_VAR 0 2
26801: ARRAY
26802: PUSH
26803: LD_EXP 63
26807: PUSH
26808: LD_VAR 0 2
26812: ARRAY
26813: PUSH
26814: LD_VAR 0 3
26818: ARRAY
26819: DIFF
26820: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
26821: LD_ADDR_EXP 63
26825: PUSH
26826: LD_EXP 63
26830: PPUSH
26831: LD_VAR 0 2
26835: PPUSH
26836: LD_VAR 0 5
26840: PPUSH
26841: CALL_OW 1
26845: ST_TO_ADDR
// continue ;
26846: GO 26734
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
26848: LD_EXP 63
26852: PUSH
26853: LD_VAR 0 2
26857: ARRAY
26858: PUSH
26859: LD_VAR 0 3
26863: ARRAY
26864: PPUSH
26865: CALL 50358 0 1
26869: PUSH
26870: LD_EXP 63
26874: PUSH
26875: LD_VAR 0 2
26879: ARRAY
26880: PUSH
26881: LD_VAR 0 3
26885: ARRAY
26886: PPUSH
26887: CALL_OW 255
26891: PPUSH
26892: LD_EXP 62
26896: PUSH
26897: LD_VAR 0 2
26901: ARRAY
26902: PUSH
26903: LD_VAR 0 4
26907: ARRAY
26908: PUSH
26909: LD_INT 1
26911: ARRAY
26912: PPUSH
26913: LD_EXP 62
26917: PUSH
26918: LD_VAR 0 2
26922: ARRAY
26923: PUSH
26924: LD_VAR 0 4
26928: ARRAY
26929: PUSH
26930: LD_INT 2
26932: ARRAY
26933: PPUSH
26934: LD_INT 15
26936: PPUSH
26937: CALL 51351 0 4
26941: PUSH
26942: LD_INT 4
26944: ARRAY
26945: PUSH
26946: LD_EXP 63
26950: PUSH
26951: LD_VAR 0 2
26955: ARRAY
26956: PUSH
26957: LD_VAR 0 3
26961: ARRAY
26962: PPUSH
26963: LD_INT 10
26965: PPUSH
26966: CALL 53048 0 2
26970: PUSH
26971: LD_INT 4
26973: ARRAY
26974: OR
26975: AND
26976: IFFALSE 26999
// ComStop ( mc_miners [ i ] [ j ] ) ;
26978: LD_EXP 63
26982: PUSH
26983: LD_VAR 0 2
26987: ARRAY
26988: PUSH
26989: LD_VAR 0 3
26993: ARRAY
26994: PPUSH
26995: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
26999: LD_EXP 63
27003: PUSH
27004: LD_VAR 0 2
27008: ARRAY
27009: PUSH
27010: LD_VAR 0 3
27014: ARRAY
27015: PPUSH
27016: CALL_OW 257
27020: PUSH
27021: LD_INT 1
27023: EQUAL
27024: PUSH
27025: LD_EXP 63
27029: PUSH
27030: LD_VAR 0 2
27034: ARRAY
27035: PUSH
27036: LD_VAR 0 3
27040: ARRAY
27041: PPUSH
27042: CALL_OW 459
27046: NOT
27047: AND
27048: PUSH
27049: LD_EXP 63
27053: PUSH
27054: LD_VAR 0 2
27058: ARRAY
27059: PUSH
27060: LD_VAR 0 3
27064: ARRAY
27065: PPUSH
27066: CALL_OW 255
27070: PPUSH
27071: LD_EXP 62
27075: PUSH
27076: LD_VAR 0 2
27080: ARRAY
27081: PUSH
27082: LD_VAR 0 4
27086: ARRAY
27087: PUSH
27088: LD_INT 1
27090: ARRAY
27091: PPUSH
27092: LD_EXP 62
27096: PUSH
27097: LD_VAR 0 2
27101: ARRAY
27102: PUSH
27103: LD_VAR 0 4
27107: ARRAY
27108: PUSH
27109: LD_INT 2
27111: ARRAY
27112: PPUSH
27113: LD_INT 15
27115: PPUSH
27116: CALL 51351 0 4
27120: PUSH
27121: LD_INT 4
27123: ARRAY
27124: PUSH
27125: LD_INT 0
27127: EQUAL
27128: AND
27129: PUSH
27130: LD_EXP 63
27134: PUSH
27135: LD_VAR 0 2
27139: ARRAY
27140: PUSH
27141: LD_VAR 0 3
27145: ARRAY
27146: PPUSH
27147: CALL_OW 314
27151: NOT
27152: AND
27153: IFFALSE 27329
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
27155: LD_EXP 63
27159: PUSH
27160: LD_VAR 0 2
27164: ARRAY
27165: PUSH
27166: LD_VAR 0 3
27170: ARRAY
27171: PPUSH
27172: CALL_OW 310
27176: IFFALSE 27199
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
27178: LD_EXP 63
27182: PUSH
27183: LD_VAR 0 2
27187: ARRAY
27188: PUSH
27189: LD_VAR 0 3
27193: ARRAY
27194: PPUSH
27195: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
27199: LD_EXP 63
27203: PUSH
27204: LD_VAR 0 2
27208: ARRAY
27209: PUSH
27210: LD_VAR 0 3
27214: ARRAY
27215: PPUSH
27216: CALL_OW 314
27220: NOT
27221: IFFALSE 27289
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
27223: LD_EXP 63
27227: PUSH
27228: LD_VAR 0 2
27232: ARRAY
27233: PUSH
27234: LD_VAR 0 3
27238: ARRAY
27239: PPUSH
27240: LD_EXP 62
27244: PUSH
27245: LD_VAR 0 2
27249: ARRAY
27250: PUSH
27251: LD_VAR 0 4
27255: ARRAY
27256: PUSH
27257: LD_INT 1
27259: ARRAY
27260: PPUSH
27261: LD_EXP 62
27265: PUSH
27266: LD_VAR 0 2
27270: ARRAY
27271: PUSH
27272: LD_VAR 0 4
27276: ARRAY
27277: PUSH
27278: LD_INT 2
27280: ARRAY
27281: PPUSH
27282: LD_INT 0
27284: PPUSH
27285: CALL_OW 193
// k := k + 1 ;
27289: LD_ADDR_VAR 0 4
27293: PUSH
27294: LD_VAR 0 4
27298: PUSH
27299: LD_INT 1
27301: PLUS
27302: ST_TO_ADDR
// if k > mc_mines [ i ] then
27303: LD_VAR 0 4
27307: PUSH
27308: LD_EXP 62
27312: PUSH
27313: LD_VAR 0 2
27317: ARRAY
27318: GREATER
27319: IFFALSE 27329
// k := 1 ;
27321: LD_ADDR_VAR 0 4
27325: PUSH
27326: LD_INT 1
27328: ST_TO_ADDR
// end ; end ;
27329: GO 26734
27331: POP
27332: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
27333: LD_ADDR_VAR 0 5
27337: PUSH
27338: LD_EXP 49
27342: PUSH
27343: LD_VAR 0 2
27347: ARRAY
27348: PPUSH
27349: LD_INT 2
27351: PUSH
27352: LD_INT 30
27354: PUSH
27355: LD_INT 4
27357: PUSH
27358: EMPTY
27359: LIST
27360: LIST
27361: PUSH
27362: LD_INT 30
27364: PUSH
27365: LD_INT 5
27367: PUSH
27368: EMPTY
27369: LIST
27370: LIST
27371: PUSH
27372: LD_INT 30
27374: PUSH
27375: LD_INT 32
27377: PUSH
27378: EMPTY
27379: LIST
27380: LIST
27381: PUSH
27382: EMPTY
27383: LIST
27384: LIST
27385: LIST
27386: LIST
27387: PPUSH
27388: CALL_OW 72
27392: ST_TO_ADDR
// if not tmp then
27393: LD_VAR 0 5
27397: NOT
27398: IFFALSE 27402
// continue ;
27400: GO 26651
// list := [ ] ;
27402: LD_ADDR_VAR 0 6
27406: PUSH
27407: EMPTY
27408: ST_TO_ADDR
// for j in tmp do
27409: LD_ADDR_VAR 0 3
27413: PUSH
27414: LD_VAR 0 5
27418: PUSH
27419: FOR_IN
27420: IFFALSE 27489
// begin for k in UnitsInside ( j ) do
27422: LD_ADDR_VAR 0 4
27426: PUSH
27427: LD_VAR 0 3
27431: PPUSH
27432: CALL_OW 313
27436: PUSH
27437: FOR_IN
27438: IFFALSE 27485
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
27440: LD_VAR 0 4
27444: PPUSH
27445: CALL_OW 257
27449: PUSH
27450: LD_INT 1
27452: EQUAL
27453: PUSH
27454: LD_VAR 0 4
27458: PPUSH
27459: CALL_OW 459
27463: NOT
27464: AND
27465: IFFALSE 27483
// list := list ^ k ;
27467: LD_ADDR_VAR 0 6
27471: PUSH
27472: LD_VAR 0 6
27476: PUSH
27477: LD_VAR 0 4
27481: ADD
27482: ST_TO_ADDR
27483: GO 27437
27485: POP
27486: POP
// end ;
27487: GO 27419
27489: POP
27490: POP
// list := list diff mc_miners [ i ] ;
27491: LD_ADDR_VAR 0 6
27495: PUSH
27496: LD_VAR 0 6
27500: PUSH
27501: LD_EXP 63
27505: PUSH
27506: LD_VAR 0 2
27510: ARRAY
27511: DIFF
27512: ST_TO_ADDR
// if not list then
27513: LD_VAR 0 6
27517: NOT
27518: IFFALSE 27522
// continue ;
27520: GO 26651
// k := mc_mines [ i ] - mc_miners [ i ] ;
27522: LD_ADDR_VAR 0 4
27526: PUSH
27527: LD_EXP 62
27531: PUSH
27532: LD_VAR 0 2
27536: ARRAY
27537: PUSH
27538: LD_EXP 63
27542: PUSH
27543: LD_VAR 0 2
27547: ARRAY
27548: MINUS
27549: ST_TO_ADDR
// if k > list then
27550: LD_VAR 0 4
27554: PUSH
27555: LD_VAR 0 6
27559: GREATER
27560: IFFALSE 27572
// k := list ;
27562: LD_ADDR_VAR 0 4
27566: PUSH
27567: LD_VAR 0 6
27571: ST_TO_ADDR
// for j = 1 to k do
27572: LD_ADDR_VAR 0 3
27576: PUSH
27577: DOUBLE
27578: LD_INT 1
27580: DEC
27581: ST_TO_ADDR
27582: LD_VAR 0 4
27586: PUSH
27587: FOR_TO
27588: IFFALSE 27642
// mc_miners := Add ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
27590: LD_ADDR_EXP 63
27594: PUSH
27595: LD_EXP 63
27599: PPUSH
27600: LD_VAR 0 2
27604: PUSH
27605: LD_EXP 63
27609: PUSH
27610: LD_VAR 0 2
27614: ARRAY
27615: PUSH
27616: LD_INT 1
27618: PLUS
27619: PUSH
27620: EMPTY
27621: LIST
27622: LIST
27623: PPUSH
27624: LD_VAR 0 6
27628: PUSH
27629: LD_VAR 0 3
27633: ARRAY
27634: PPUSH
27635: CALL 50857 0 3
27639: ST_TO_ADDR
27640: GO 27587
27642: POP
27643: POP
// end ;
27644: GO 26651
27646: POP
27647: POP
// end ;
27648: LD_VAR 0 1
27652: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
27653: LD_INT 0
27655: PPUSH
27656: PPUSH
27657: PPUSH
27658: PPUSH
27659: PPUSH
27660: PPUSH
27661: PPUSH
27662: PPUSH
27663: PPUSH
27664: PPUSH
// if not mc_bases then
27665: LD_EXP 49
27669: NOT
27670: IFFALSE 27674
// exit ;
27672: GO 29405
// for i = 1 to mc_bases do
27674: LD_ADDR_VAR 0 2
27678: PUSH
27679: DOUBLE
27680: LD_INT 1
27682: DEC
27683: ST_TO_ADDR
27684: LD_EXP 49
27688: PUSH
27689: FOR_TO
27690: IFFALSE 29403
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
27692: LD_EXP 49
27696: PUSH
27697: LD_VAR 0 2
27701: ARRAY
27702: NOT
27703: PUSH
27704: LD_EXP 56
27708: PUSH
27709: LD_VAR 0 2
27713: ARRAY
27714: OR
27715: IFFALSE 27719
// continue ;
27717: GO 27689
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
27719: LD_EXP 65
27723: PUSH
27724: LD_VAR 0 2
27728: ARRAY
27729: NOT
27730: PUSH
27731: LD_EXP 66
27735: PUSH
27736: LD_VAR 0 2
27740: ARRAY
27741: AND
27742: IFFALSE 27780
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
27744: LD_ADDR_EXP 66
27748: PUSH
27749: LD_EXP 66
27753: PPUSH
27754: LD_VAR 0 2
27758: PPUSH
27759: EMPTY
27760: PPUSH
27761: CALL_OW 1
27765: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
27766: LD_VAR 0 2
27770: PPUSH
27771: LD_INT 107
27773: PPUSH
27774: CALL 19344 0 2
// continue ;
27778: GO 27689
// end ; target := [ ] ;
27780: LD_ADDR_VAR 0 6
27784: PUSH
27785: EMPTY
27786: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
27787: LD_ADDR_VAR 0 3
27791: PUSH
27792: DOUBLE
27793: LD_EXP 65
27797: PUSH
27798: LD_VAR 0 2
27802: ARRAY
27803: INC
27804: ST_TO_ADDR
27805: LD_INT 1
27807: PUSH
27808: FOR_DOWNTO
27809: IFFALSE 28069
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
27811: LD_EXP 65
27815: PUSH
27816: LD_VAR 0 2
27820: ARRAY
27821: PUSH
27822: LD_VAR 0 3
27826: ARRAY
27827: PUSH
27828: LD_INT 2
27830: ARRAY
27831: PPUSH
27832: LD_EXP 65
27836: PUSH
27837: LD_VAR 0 2
27841: ARRAY
27842: PUSH
27843: LD_VAR 0 3
27847: ARRAY
27848: PUSH
27849: LD_INT 3
27851: ARRAY
27852: PPUSH
27853: CALL_OW 488
27857: PUSH
27858: LD_EXP 65
27862: PUSH
27863: LD_VAR 0 2
27867: ARRAY
27868: PUSH
27869: LD_VAR 0 3
27873: ARRAY
27874: PUSH
27875: LD_INT 2
27877: ARRAY
27878: PPUSH
27879: LD_EXP 65
27883: PUSH
27884: LD_VAR 0 2
27888: ARRAY
27889: PUSH
27890: LD_VAR 0 3
27894: ARRAY
27895: PUSH
27896: LD_INT 3
27898: ARRAY
27899: PPUSH
27900: CALL_OW 284
27904: PUSH
27905: LD_INT 0
27907: EQUAL
27908: AND
27909: IFFALSE 27964
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
27911: LD_ADDR_VAR 0 5
27915: PUSH
27916: LD_EXP 65
27920: PUSH
27921: LD_VAR 0 2
27925: ARRAY
27926: PPUSH
27927: LD_VAR 0 3
27931: PPUSH
27932: CALL_OW 3
27936: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
27937: LD_ADDR_EXP 65
27941: PUSH
27942: LD_EXP 65
27946: PPUSH
27947: LD_VAR 0 2
27951: PPUSH
27952: LD_VAR 0 5
27956: PPUSH
27957: CALL_OW 1
27961: ST_TO_ADDR
// continue ;
27962: GO 27808
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
27964: LD_EXP 49
27968: PUSH
27969: LD_VAR 0 2
27973: ARRAY
27974: PUSH
27975: LD_INT 1
27977: ARRAY
27978: PPUSH
27979: CALL_OW 255
27983: PPUSH
27984: LD_EXP 65
27988: PUSH
27989: LD_VAR 0 2
27993: ARRAY
27994: PUSH
27995: LD_VAR 0 3
27999: ARRAY
28000: PUSH
28001: LD_INT 2
28003: ARRAY
28004: PPUSH
28005: LD_EXP 65
28009: PUSH
28010: LD_VAR 0 2
28014: ARRAY
28015: PUSH
28016: LD_VAR 0 3
28020: ARRAY
28021: PUSH
28022: LD_INT 3
28024: ARRAY
28025: PPUSH
28026: LD_INT 30
28028: PPUSH
28029: CALL 51351 0 4
28033: PUSH
28034: LD_INT 4
28036: ARRAY
28037: PUSH
28038: LD_INT 0
28040: EQUAL
28041: IFFALSE 28067
// begin target := mc_crates [ i ] [ j ] ;
28043: LD_ADDR_VAR 0 6
28047: PUSH
28048: LD_EXP 65
28052: PUSH
28053: LD_VAR 0 2
28057: ARRAY
28058: PUSH
28059: LD_VAR 0 3
28063: ARRAY
28064: ST_TO_ADDR
// break ;
28065: GO 28069
// end ; end ;
28067: GO 27808
28069: POP
28070: POP
// if not target then
28071: LD_VAR 0 6
28075: NOT
28076: IFFALSE 28080
// continue ;
28078: GO 27689
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
28080: LD_ADDR_VAR 0 7
28084: PUSH
28085: LD_EXP 68
28089: PUSH
28090: LD_VAR 0 2
28094: ARRAY
28095: PPUSH
28096: LD_INT 2
28098: PUSH
28099: LD_INT 3
28101: PUSH
28102: LD_INT 58
28104: PUSH
28105: EMPTY
28106: LIST
28107: PUSH
28108: EMPTY
28109: LIST
28110: LIST
28111: PUSH
28112: LD_INT 61
28114: PUSH
28115: EMPTY
28116: LIST
28117: PUSH
28118: LD_INT 33
28120: PUSH
28121: LD_INT 5
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: PUSH
28128: LD_INT 33
28130: PUSH
28131: LD_INT 3
28133: PUSH
28134: EMPTY
28135: LIST
28136: LIST
28137: PUSH
28138: EMPTY
28139: LIST
28140: LIST
28141: LIST
28142: LIST
28143: LIST
28144: PUSH
28145: LD_INT 2
28147: PUSH
28148: LD_INT 34
28150: PUSH
28151: LD_INT 32
28153: PUSH
28154: EMPTY
28155: LIST
28156: LIST
28157: PUSH
28158: LD_INT 34
28160: PUSH
28161: LD_INT 51
28163: PUSH
28164: EMPTY
28165: LIST
28166: LIST
28167: PUSH
28168: LD_INT 34
28170: PUSH
28171: LD_INT 12
28173: PUSH
28174: EMPTY
28175: LIST
28176: LIST
28177: PUSH
28178: EMPTY
28179: LIST
28180: LIST
28181: LIST
28182: LIST
28183: PUSH
28184: EMPTY
28185: LIST
28186: LIST
28187: PPUSH
28188: CALL_OW 72
28192: ST_TO_ADDR
// if not cargo then
28193: LD_VAR 0 7
28197: NOT
28198: IFFALSE 28841
// begin if mc_crates_collector [ i ] < 5 then
28200: LD_EXP 66
28204: PUSH
28205: LD_VAR 0 2
28209: ARRAY
28210: PUSH
28211: LD_INT 5
28213: LESS
28214: IFFALSE 28580
// begin if mc_ape [ i ] then
28216: LD_EXP 78
28220: PUSH
28221: LD_VAR 0 2
28225: ARRAY
28226: IFFALSE 28273
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
28228: LD_ADDR_VAR 0 5
28232: PUSH
28233: LD_EXP 78
28237: PUSH
28238: LD_VAR 0 2
28242: ARRAY
28243: PPUSH
28244: LD_INT 25
28246: PUSH
28247: LD_INT 16
28249: PUSH
28250: EMPTY
28251: LIST
28252: LIST
28253: PUSH
28254: LD_INT 24
28256: PUSH
28257: LD_INT 750
28259: PUSH
28260: EMPTY
28261: LIST
28262: LIST
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: PPUSH
28268: CALL_OW 72
28272: ST_TO_ADDR
// if not tmp then
28273: LD_VAR 0 5
28277: NOT
28278: IFFALSE 28325
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
28280: LD_ADDR_VAR 0 5
28284: PUSH
28285: LD_EXP 49
28289: PUSH
28290: LD_VAR 0 2
28294: ARRAY
28295: PPUSH
28296: LD_INT 25
28298: PUSH
28299: LD_INT 2
28301: PUSH
28302: EMPTY
28303: LIST
28304: LIST
28305: PUSH
28306: LD_INT 24
28308: PUSH
28309: LD_INT 750
28311: PUSH
28312: EMPTY
28313: LIST
28314: LIST
28315: PUSH
28316: EMPTY
28317: LIST
28318: LIST
28319: PPUSH
28320: CALL_OW 72
28324: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
28325: LD_EXP 78
28329: PUSH
28330: LD_VAR 0 2
28334: ARRAY
28335: PUSH
28336: LD_EXP 49
28340: PUSH
28341: LD_VAR 0 2
28345: ARRAY
28346: PPUSH
28347: LD_INT 25
28349: PUSH
28350: LD_INT 2
28352: PUSH
28353: EMPTY
28354: LIST
28355: LIST
28356: PUSH
28357: LD_INT 24
28359: PUSH
28360: LD_INT 750
28362: PUSH
28363: EMPTY
28364: LIST
28365: LIST
28366: PUSH
28367: EMPTY
28368: LIST
28369: LIST
28370: PPUSH
28371: CALL_OW 72
28375: AND
28376: PUSH
28377: LD_VAR 0 5
28381: PUSH
28382: LD_INT 5
28384: LESS
28385: AND
28386: IFFALSE 28468
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
28388: LD_ADDR_VAR 0 3
28392: PUSH
28393: LD_EXP 49
28397: PUSH
28398: LD_VAR 0 2
28402: ARRAY
28403: PPUSH
28404: LD_INT 25
28406: PUSH
28407: LD_INT 2
28409: PUSH
28410: EMPTY
28411: LIST
28412: LIST
28413: PUSH
28414: LD_INT 24
28416: PUSH
28417: LD_INT 750
28419: PUSH
28420: EMPTY
28421: LIST
28422: LIST
28423: PUSH
28424: EMPTY
28425: LIST
28426: LIST
28427: PPUSH
28428: CALL_OW 72
28432: PUSH
28433: FOR_IN
28434: IFFALSE 28466
// begin tmp := tmp union j ;
28436: LD_ADDR_VAR 0 5
28440: PUSH
28441: LD_VAR 0 5
28445: PUSH
28446: LD_VAR 0 3
28450: UNION
28451: ST_TO_ADDR
// if tmp >= 5 then
28452: LD_VAR 0 5
28456: PUSH
28457: LD_INT 5
28459: GREATEREQUAL
28460: IFFALSE 28464
// break ;
28462: GO 28466
// end ;
28464: GO 28433
28466: POP
28467: POP
// end ; if not tmp then
28468: LD_VAR 0 5
28472: NOT
28473: IFFALSE 28477
// continue ;
28475: GO 27689
// for j in tmp do
28477: LD_ADDR_VAR 0 3
28481: PUSH
28482: LD_VAR 0 5
28486: PUSH
28487: FOR_IN
28488: IFFALSE 28578
// if not GetTag ( j ) then
28490: LD_VAR 0 3
28494: PPUSH
28495: CALL_OW 110
28499: NOT
28500: IFFALSE 28576
// begin mc_crates_collector := Add ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
28502: LD_ADDR_EXP 66
28506: PUSH
28507: LD_EXP 66
28511: PPUSH
28512: LD_VAR 0 2
28516: PUSH
28517: LD_EXP 66
28521: PUSH
28522: LD_VAR 0 2
28526: ARRAY
28527: PUSH
28528: LD_INT 1
28530: PLUS
28531: PUSH
28532: EMPTY
28533: LIST
28534: LIST
28535: PPUSH
28536: LD_VAR 0 3
28540: PPUSH
28541: CALL 50857 0 3
28545: ST_TO_ADDR
// SetTag ( j , 107 ) ;
28546: LD_VAR 0 3
28550: PPUSH
28551: LD_INT 107
28553: PPUSH
28554: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
28558: LD_EXP 66
28562: PUSH
28563: LD_VAR 0 2
28567: ARRAY
28568: PUSH
28569: LD_INT 5
28571: GREATEREQUAL
28572: IFFALSE 28576
// break ;
28574: GO 28578
// end ;
28576: GO 28487
28578: POP
28579: POP
// end ; if mc_crates_collector [ i ] and target then
28580: LD_EXP 66
28584: PUSH
28585: LD_VAR 0 2
28589: ARRAY
28590: PUSH
28591: LD_VAR 0 6
28595: AND
28596: IFFALSE 28839
// begin if mc_crates_collector [ i ] < target [ 1 ] then
28598: LD_EXP 66
28602: PUSH
28603: LD_VAR 0 2
28607: ARRAY
28608: PUSH
28609: LD_VAR 0 6
28613: PUSH
28614: LD_INT 1
28616: ARRAY
28617: LESS
28618: IFFALSE 28638
// tmp := mc_crates_collector [ i ] else
28620: LD_ADDR_VAR 0 5
28624: PUSH
28625: LD_EXP 66
28629: PUSH
28630: LD_VAR 0 2
28634: ARRAY
28635: ST_TO_ADDR
28636: GO 28652
// tmp := target [ 1 ] ;
28638: LD_ADDR_VAR 0 5
28642: PUSH
28643: LD_VAR 0 6
28647: PUSH
28648: LD_INT 1
28650: ARRAY
28651: ST_TO_ADDR
// k := 0 ;
28652: LD_ADDR_VAR 0 4
28656: PUSH
28657: LD_INT 0
28659: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
28660: LD_ADDR_VAR 0 3
28664: PUSH
28665: LD_EXP 66
28669: PUSH
28670: LD_VAR 0 2
28674: ARRAY
28675: PUSH
28676: FOR_IN
28677: IFFALSE 28837
// begin k := k + 1 ;
28679: LD_ADDR_VAR 0 4
28683: PUSH
28684: LD_VAR 0 4
28688: PUSH
28689: LD_INT 1
28691: PLUS
28692: ST_TO_ADDR
// if k > tmp then
28693: LD_VAR 0 4
28697: PUSH
28698: LD_VAR 0 5
28702: GREATER
28703: IFFALSE 28707
// break ;
28705: GO 28837
// if not GetClass ( j ) in [ 2 , 16 ] then
28707: LD_VAR 0 3
28711: PPUSH
28712: CALL_OW 257
28716: PUSH
28717: LD_INT 2
28719: PUSH
28720: LD_INT 16
28722: PUSH
28723: EMPTY
28724: LIST
28725: LIST
28726: IN
28727: NOT
28728: IFFALSE 28781
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
28730: LD_ADDR_EXP 66
28734: PUSH
28735: LD_EXP 66
28739: PPUSH
28740: LD_VAR 0 2
28744: PPUSH
28745: LD_EXP 66
28749: PUSH
28750: LD_VAR 0 2
28754: ARRAY
28755: PUSH
28756: LD_VAR 0 3
28760: DIFF
28761: PPUSH
28762: CALL_OW 1
28766: ST_TO_ADDR
// SetTag ( j , 0 ) ;
28767: LD_VAR 0 3
28771: PPUSH
28772: LD_INT 0
28774: PPUSH
28775: CALL_OW 109
// continue ;
28779: GO 28676
// end ; if IsInUnit ( j ) then
28781: LD_VAR 0 3
28785: PPUSH
28786: CALL_OW 310
28790: IFFALSE 28801
// ComExitBuilding ( j ) ;
28792: LD_VAR 0 3
28796: PPUSH
28797: CALL_OW 122
// wait ( 3 ) ;
28801: LD_INT 3
28803: PPUSH
28804: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
28808: LD_VAR 0 3
28812: PPUSH
28813: LD_VAR 0 6
28817: PUSH
28818: LD_INT 2
28820: ARRAY
28821: PPUSH
28822: LD_VAR 0 6
28826: PUSH
28827: LD_INT 3
28829: ARRAY
28830: PPUSH
28831: CALL_OW 117
// end ;
28835: GO 28676
28837: POP
28838: POP
// end ; end else
28839: GO 29401
// begin for j in cargo do
28841: LD_ADDR_VAR 0 3
28845: PUSH
28846: LD_VAR 0 7
28850: PUSH
28851: FOR_IN
28852: IFFALSE 29399
// begin if GetTag ( j ) <> 0 then
28854: LD_VAR 0 3
28858: PPUSH
28859: CALL_OW 110
28863: PUSH
28864: LD_INT 0
28866: NONEQUAL
28867: IFFALSE 28871
// continue ;
28869: GO 28851
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
28871: LD_VAR 0 3
28875: PPUSH
28876: CALL_OW 256
28880: PUSH
28881: LD_INT 1000
28883: LESS
28884: PUSH
28885: LD_VAR 0 3
28889: PPUSH
28890: LD_EXP 73
28894: PUSH
28895: LD_VAR 0 2
28899: ARRAY
28900: PPUSH
28901: CALL_OW 308
28905: NOT
28906: AND
28907: IFFALSE 28929
// ComMoveToArea ( j , mc_parking [ i ] ) ;
28909: LD_VAR 0 3
28913: PPUSH
28914: LD_EXP 73
28918: PUSH
28919: LD_VAR 0 2
28923: ARRAY
28924: PPUSH
28925: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
28929: LD_VAR 0 3
28933: PPUSH
28934: CALL_OW 256
28938: PUSH
28939: LD_INT 1000
28941: LESS
28942: PUSH
28943: LD_VAR 0 3
28947: PPUSH
28948: LD_EXP 73
28952: PUSH
28953: LD_VAR 0 2
28957: ARRAY
28958: PPUSH
28959: CALL_OW 308
28963: AND
28964: IFFALSE 28968
// continue ;
28966: GO 28851
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
28968: LD_VAR 0 3
28972: PPUSH
28973: CALL_OW 262
28977: PUSH
28978: LD_INT 2
28980: EQUAL
28981: PUSH
28982: LD_VAR 0 3
28986: PPUSH
28987: CALL_OW 261
28991: PUSH
28992: LD_INT 15
28994: LESS
28995: AND
28996: IFFALSE 29000
// continue ;
28998: GO 28851
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
29000: LD_VAR 0 3
29004: PPUSH
29005: CALL_OW 262
29009: PUSH
29010: LD_INT 1
29012: EQUAL
29013: PUSH
29014: LD_VAR 0 3
29018: PPUSH
29019: CALL_OW 261
29023: PUSH
29024: LD_INT 10
29026: LESS
29027: AND
29028: IFFALSE 29338
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29030: LD_ADDR_VAR 0 8
29034: PUSH
29035: LD_EXP 49
29039: PUSH
29040: LD_VAR 0 2
29044: ARRAY
29045: PPUSH
29046: LD_INT 2
29048: PUSH
29049: LD_INT 30
29051: PUSH
29052: LD_INT 0
29054: PUSH
29055: EMPTY
29056: LIST
29057: LIST
29058: PUSH
29059: LD_INT 30
29061: PUSH
29062: LD_INT 1
29064: PUSH
29065: EMPTY
29066: LIST
29067: LIST
29068: PUSH
29069: EMPTY
29070: LIST
29071: LIST
29072: LIST
29073: PPUSH
29074: CALL_OW 72
29078: ST_TO_ADDR
// if not depot then
29079: LD_VAR 0 8
29083: NOT
29084: IFFALSE 29088
// continue ;
29086: GO 28851
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
29088: LD_VAR 0 3
29092: PPUSH
29093: LD_VAR 0 8
29097: PPUSH
29098: LD_VAR 0 3
29102: PPUSH
29103: CALL_OW 74
29107: PPUSH
29108: CALL_OW 296
29112: PUSH
29113: LD_INT 6
29115: LESS
29116: IFFALSE 29132
// SetFuel ( j , 100 ) else
29118: LD_VAR 0 3
29122: PPUSH
29123: LD_INT 100
29125: PPUSH
29126: CALL_OW 240
29130: GO 29338
// if GetFuel ( j ) = 0 then
29132: LD_VAR 0 3
29136: PPUSH
29137: CALL_OW 261
29141: PUSH
29142: LD_INT 0
29144: EQUAL
29145: IFFALSE 29338
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
29147: LD_ADDR_EXP 68
29151: PUSH
29152: LD_EXP 68
29156: PPUSH
29157: LD_VAR 0 2
29161: PPUSH
29162: LD_EXP 68
29166: PUSH
29167: LD_VAR 0 2
29171: ARRAY
29172: PUSH
29173: LD_VAR 0 3
29177: DIFF
29178: PPUSH
29179: CALL_OW 1
29183: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
29184: LD_VAR 0 3
29188: PPUSH
29189: CALL_OW 263
29193: PUSH
29194: LD_INT 1
29196: EQUAL
29197: IFFALSE 29213
// ComExitVehicle ( IsInUnit ( j ) ) ;
29199: LD_VAR 0 3
29203: PPUSH
29204: CALL_OW 310
29208: PPUSH
29209: CALL_OW 121
// if GetControl ( j ) = control_remote then
29213: LD_VAR 0 3
29217: PPUSH
29218: CALL_OW 263
29222: PUSH
29223: LD_INT 2
29225: EQUAL
29226: IFFALSE 29237
// ComUnlink ( j ) ;
29228: LD_VAR 0 3
29232: PPUSH
29233: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
29237: LD_ADDR_VAR 0 9
29241: PUSH
29242: LD_VAR 0 2
29246: PPUSH
29247: LD_INT 3
29249: PPUSH
29250: CALL 38473 0 2
29254: ST_TO_ADDR
// if fac then
29255: LD_VAR 0 9
29259: IFFALSE 29336
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
29261: LD_ADDR_VAR 0 10
29265: PUSH
29266: LD_VAR 0 9
29270: PPUSH
29271: LD_VAR 0 3
29275: PPUSH
29276: CALL_OW 265
29280: PPUSH
29281: LD_VAR 0 3
29285: PPUSH
29286: CALL_OW 262
29290: PPUSH
29291: LD_VAR 0 3
29295: PPUSH
29296: CALL_OW 263
29300: PPUSH
29301: LD_VAR 0 3
29305: PPUSH
29306: CALL_OW 264
29310: PPUSH
29311: CALL 48022 0 5
29315: ST_TO_ADDR
// if components then
29316: LD_VAR 0 10
29320: IFFALSE 29336
// MC_InsertProduceList ( i , components ) ;
29322: LD_VAR 0 2
29326: PPUSH
29327: LD_VAR 0 10
29331: PPUSH
29332: CALL 38043 0 2
// end ; continue ;
29336: GO 28851
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
29338: LD_VAR 0 3
29342: PPUSH
29343: LD_INT 1
29345: PPUSH
29346: CALL_OW 289
29350: PUSH
29351: LD_INT 100
29353: LESS
29354: PUSH
29355: LD_VAR 0 3
29359: PPUSH
29360: CALL_OW 314
29364: NOT
29365: AND
29366: IFFALSE 29395
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
29368: LD_VAR 0 3
29372: PPUSH
29373: LD_VAR 0 6
29377: PUSH
29378: LD_INT 2
29380: ARRAY
29381: PPUSH
29382: LD_VAR 0 6
29386: PUSH
29387: LD_INT 3
29389: ARRAY
29390: PPUSH
29391: CALL_OW 117
// break ;
29395: GO 29399
// end ;
29397: GO 28851
29399: POP
29400: POP
// end ; end ;
29401: GO 27689
29403: POP
29404: POP
// end ;
29405: LD_VAR 0 1
29409: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
29410: LD_INT 0
29412: PPUSH
29413: PPUSH
29414: PPUSH
29415: PPUSH
// if not mc_bases then
29416: LD_EXP 49
29420: NOT
29421: IFFALSE 29425
// exit ;
29423: GO 29586
// for i = 1 to mc_bases do
29425: LD_ADDR_VAR 0 2
29429: PUSH
29430: DOUBLE
29431: LD_INT 1
29433: DEC
29434: ST_TO_ADDR
29435: LD_EXP 49
29439: PUSH
29440: FOR_TO
29441: IFFALSE 29584
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
29443: LD_ADDR_VAR 0 4
29447: PUSH
29448: LD_EXP 68
29452: PUSH
29453: LD_VAR 0 2
29457: ARRAY
29458: PUSH
29459: LD_EXP 71
29463: PUSH
29464: LD_VAR 0 2
29468: ARRAY
29469: UNION
29470: PPUSH
29471: LD_INT 33
29473: PUSH
29474: LD_INT 2
29476: PUSH
29477: EMPTY
29478: LIST
29479: LIST
29480: PPUSH
29481: CALL_OW 72
29485: ST_TO_ADDR
// if tmp then
29486: LD_VAR 0 4
29490: IFFALSE 29582
// for j in tmp do
29492: LD_ADDR_VAR 0 3
29496: PUSH
29497: LD_VAR 0 4
29501: PUSH
29502: FOR_IN
29503: IFFALSE 29580
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
29505: LD_VAR 0 3
29509: PPUSH
29510: CALL_OW 312
29514: NOT
29515: PUSH
29516: LD_VAR 0 3
29520: PPUSH
29521: CALL_OW 256
29525: PUSH
29526: LD_INT 250
29528: GREATEREQUAL
29529: AND
29530: IFFALSE 29543
// Connect ( j ) else
29532: LD_VAR 0 3
29536: PPUSH
29537: CALL 53375 0 1
29541: GO 29578
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
29543: LD_VAR 0 3
29547: PPUSH
29548: CALL_OW 256
29552: PUSH
29553: LD_INT 250
29555: LESS
29556: PUSH
29557: LD_VAR 0 3
29561: PPUSH
29562: CALL_OW 312
29566: AND
29567: IFFALSE 29578
// ComUnlink ( j ) ;
29569: LD_VAR 0 3
29573: PPUSH
29574: CALL_OW 136
29578: GO 29502
29580: POP
29581: POP
// end ;
29582: GO 29440
29584: POP
29585: POP
// end ;
29586: LD_VAR 0 1
29590: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
29591: LD_INT 0
29593: PPUSH
29594: PPUSH
29595: PPUSH
29596: PPUSH
29597: PPUSH
// if not mc_bases then
29598: LD_EXP 49
29602: NOT
29603: IFFALSE 29607
// exit ;
29605: GO 30067
// for i = 1 to mc_bases do
29607: LD_ADDR_VAR 0 2
29611: PUSH
29612: DOUBLE
29613: LD_INT 1
29615: DEC
29616: ST_TO_ADDR
29617: LD_EXP 49
29621: PUSH
29622: FOR_TO
29623: IFFALSE 30065
// begin if not mc_produce [ i ] then
29625: LD_EXP 70
29629: PUSH
29630: LD_VAR 0 2
29634: ARRAY
29635: NOT
29636: IFFALSE 29640
// continue ;
29638: GO 29622
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
29640: LD_ADDR_VAR 0 5
29644: PUSH
29645: LD_EXP 49
29649: PUSH
29650: LD_VAR 0 2
29654: ARRAY
29655: PPUSH
29656: LD_INT 30
29658: PUSH
29659: LD_INT 3
29661: PUSH
29662: EMPTY
29663: LIST
29664: LIST
29665: PPUSH
29666: CALL_OW 72
29670: ST_TO_ADDR
// if not fac then
29671: LD_VAR 0 5
29675: NOT
29676: IFFALSE 29680
// continue ;
29678: GO 29622
// for j in fac do
29680: LD_ADDR_VAR 0 3
29684: PUSH
29685: LD_VAR 0 5
29689: PUSH
29690: FOR_IN
29691: IFFALSE 30061
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
29693: LD_VAR 0 3
29697: PPUSH
29698: CALL_OW 461
29702: PUSH
29703: LD_INT 2
29705: NONEQUAL
29706: PUSH
29707: LD_VAR 0 3
29711: PPUSH
29712: LD_INT 15
29714: PPUSH
29715: CALL 53048 0 2
29719: PUSH
29720: LD_INT 4
29722: ARRAY
29723: OR
29724: PUSH
29725: LD_VAR 0 3
29729: PPUSH
29730: CALL_OW 313
29734: PUSH
29735: LD_INT 0
29737: EQUAL
29738: OR
29739: IFFALSE 29743
// continue ;
29741: GO 29690
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
29743: LD_VAR 0 3
29747: PPUSH
29748: LD_EXP 70
29752: PUSH
29753: LD_VAR 0 2
29757: ARRAY
29758: PUSH
29759: LD_INT 1
29761: ARRAY
29762: PUSH
29763: LD_INT 1
29765: ARRAY
29766: PPUSH
29767: LD_EXP 70
29771: PUSH
29772: LD_VAR 0 2
29776: ARRAY
29777: PUSH
29778: LD_INT 1
29780: ARRAY
29781: PUSH
29782: LD_INT 2
29784: ARRAY
29785: PPUSH
29786: LD_EXP 70
29790: PUSH
29791: LD_VAR 0 2
29795: ARRAY
29796: PUSH
29797: LD_INT 1
29799: ARRAY
29800: PUSH
29801: LD_INT 3
29803: ARRAY
29804: PPUSH
29805: LD_EXP 70
29809: PUSH
29810: LD_VAR 0 2
29814: ARRAY
29815: PUSH
29816: LD_INT 1
29818: ARRAY
29819: PUSH
29820: LD_INT 4
29822: ARRAY
29823: PPUSH
29824: CALL_OW 448
29828: PUSH
29829: LD_VAR 0 3
29833: PPUSH
29834: LD_EXP 70
29838: PUSH
29839: LD_VAR 0 2
29843: ARRAY
29844: PUSH
29845: LD_INT 1
29847: ARRAY
29848: PUSH
29849: LD_INT 1
29851: ARRAY
29852: PUSH
29853: LD_EXP 70
29857: PUSH
29858: LD_VAR 0 2
29862: ARRAY
29863: PUSH
29864: LD_INT 1
29866: ARRAY
29867: PUSH
29868: LD_INT 2
29870: ARRAY
29871: PUSH
29872: LD_EXP 70
29876: PUSH
29877: LD_VAR 0 2
29881: ARRAY
29882: PUSH
29883: LD_INT 1
29885: ARRAY
29886: PUSH
29887: LD_INT 3
29889: ARRAY
29890: PUSH
29891: LD_EXP 70
29895: PUSH
29896: LD_VAR 0 2
29900: ARRAY
29901: PUSH
29902: LD_INT 1
29904: ARRAY
29905: PUSH
29906: LD_INT 4
29908: ARRAY
29909: PUSH
29910: EMPTY
29911: LIST
29912: LIST
29913: LIST
29914: LIST
29915: PPUSH
29916: CALL 56589 0 2
29920: AND
29921: IFFALSE 30059
// begin ComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
29923: LD_VAR 0 3
29927: PPUSH
29928: LD_EXP 70
29932: PUSH
29933: LD_VAR 0 2
29937: ARRAY
29938: PUSH
29939: LD_INT 1
29941: ARRAY
29942: PUSH
29943: LD_INT 1
29945: ARRAY
29946: PPUSH
29947: LD_EXP 70
29951: PUSH
29952: LD_VAR 0 2
29956: ARRAY
29957: PUSH
29958: LD_INT 1
29960: ARRAY
29961: PUSH
29962: LD_INT 2
29964: ARRAY
29965: PPUSH
29966: LD_EXP 70
29970: PUSH
29971: LD_VAR 0 2
29975: ARRAY
29976: PUSH
29977: LD_INT 1
29979: ARRAY
29980: PUSH
29981: LD_INT 3
29983: ARRAY
29984: PPUSH
29985: LD_EXP 70
29989: PUSH
29990: LD_VAR 0 2
29994: ARRAY
29995: PUSH
29996: LD_INT 1
29998: ARRAY
29999: PUSH
30000: LD_INT 4
30002: ARRAY
30003: PPUSH
30004: CALL_OW 125
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
30008: LD_ADDR_VAR 0 4
30012: PUSH
30013: LD_EXP 70
30017: PUSH
30018: LD_VAR 0 2
30022: ARRAY
30023: PPUSH
30024: LD_INT 1
30026: PPUSH
30027: CALL_OW 3
30031: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
30032: LD_ADDR_EXP 70
30036: PUSH
30037: LD_EXP 70
30041: PPUSH
30042: LD_VAR 0 2
30046: PPUSH
30047: LD_VAR 0 4
30051: PPUSH
30052: CALL_OW 1
30056: ST_TO_ADDR
// break ;
30057: GO 30061
// end ; end ;
30059: GO 29690
30061: POP
30062: POP
// end ;
30063: GO 29622
30065: POP
30066: POP
// end ;
30067: LD_VAR 0 1
30071: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
30072: LD_INT 0
30074: PPUSH
30075: PPUSH
30076: PPUSH
// if not mc_bases then
30077: LD_EXP 49
30081: NOT
30082: IFFALSE 30086
// exit ;
30084: GO 30175
// for i = 1 to mc_bases do
30086: LD_ADDR_VAR 0 2
30090: PUSH
30091: DOUBLE
30092: LD_INT 1
30094: DEC
30095: ST_TO_ADDR
30096: LD_EXP 49
30100: PUSH
30101: FOR_TO
30102: IFFALSE 30173
// begin if mc_attack [ i ] then
30104: LD_EXP 69
30108: PUSH
30109: LD_VAR 0 2
30113: ARRAY
30114: IFFALSE 30171
// begin tmp := mc_attack [ i ] [ 1 ] ;
30116: LD_ADDR_VAR 0 3
30120: PUSH
30121: LD_EXP 69
30125: PUSH
30126: LD_VAR 0 2
30130: ARRAY
30131: PUSH
30132: LD_INT 1
30134: ARRAY
30135: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
30136: LD_ADDR_EXP 69
30140: PUSH
30141: LD_EXP 69
30145: PPUSH
30146: LD_VAR 0 2
30150: PPUSH
30151: EMPTY
30152: PPUSH
30153: CALL_OW 1
30157: ST_TO_ADDR
// Attack ( tmp ) ;
30158: LD_VAR 0 3
30162: PPUSH
30163: CALL 78693 0 1
// exit ;
30167: POP
30168: POP
30169: GO 30175
// end ; end ;
30171: GO 30101
30173: POP
30174: POP
// end ;
30175: LD_VAR 0 1
30179: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
30180: LD_INT 0
30182: PPUSH
30183: PPUSH
30184: PPUSH
30185: PPUSH
30186: PPUSH
30187: PPUSH
30188: PPUSH
// if not mc_bases then
30189: LD_EXP 49
30193: NOT
30194: IFFALSE 30198
// exit ;
30196: GO 30802
// for i = 1 to mc_bases do
30198: LD_ADDR_VAR 0 2
30202: PUSH
30203: DOUBLE
30204: LD_INT 1
30206: DEC
30207: ST_TO_ADDR
30208: LD_EXP 49
30212: PUSH
30213: FOR_TO
30214: IFFALSE 30800
// begin if not mc_bases [ i ] then
30216: LD_EXP 49
30220: PUSH
30221: LD_VAR 0 2
30225: ARRAY
30226: NOT
30227: IFFALSE 30231
// continue ;
30229: GO 30213
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
30231: LD_ADDR_VAR 0 7
30235: PUSH
30236: LD_EXP 49
30240: PUSH
30241: LD_VAR 0 2
30245: ARRAY
30246: PUSH
30247: LD_INT 1
30249: ARRAY
30250: PPUSH
30251: CALL 47326 0 1
30255: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
30256: LD_ADDR_EXP 72
30260: PUSH
30261: LD_EXP 72
30265: PPUSH
30266: LD_VAR 0 2
30270: PPUSH
30271: LD_EXP 49
30275: PUSH
30276: LD_VAR 0 2
30280: ARRAY
30281: PUSH
30282: LD_INT 1
30284: ARRAY
30285: PPUSH
30286: CALL_OW 255
30290: PPUSH
30291: LD_EXP 74
30295: PUSH
30296: LD_VAR 0 2
30300: ARRAY
30301: PPUSH
30302: CALL 45286 0 2
30306: PPUSH
30307: CALL_OW 1
30311: ST_TO_ADDR
// if not mc_scan [ i ] then
30312: LD_EXP 72
30316: PUSH
30317: LD_VAR 0 2
30321: ARRAY
30322: NOT
30323: IFFALSE 30478
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
30325: LD_ADDR_VAR 0 4
30329: PUSH
30330: LD_EXP 49
30334: PUSH
30335: LD_VAR 0 2
30339: ARRAY
30340: PPUSH
30341: LD_INT 2
30343: PUSH
30344: LD_INT 25
30346: PUSH
30347: LD_INT 5
30349: PUSH
30350: EMPTY
30351: LIST
30352: LIST
30353: PUSH
30354: LD_INT 25
30356: PUSH
30357: LD_INT 8
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: PUSH
30364: LD_INT 25
30366: PUSH
30367: LD_INT 9
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: PUSH
30374: EMPTY
30375: LIST
30376: LIST
30377: LIST
30378: LIST
30379: PPUSH
30380: CALL_OW 72
30384: ST_TO_ADDR
// if not tmp then
30385: LD_VAR 0 4
30389: NOT
30390: IFFALSE 30394
// continue ;
30392: GO 30213
// for j in tmp do
30394: LD_ADDR_VAR 0 3
30398: PUSH
30399: LD_VAR 0 4
30403: PUSH
30404: FOR_IN
30405: IFFALSE 30476
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
30407: LD_VAR 0 3
30411: PPUSH
30412: CALL_OW 310
30416: PPUSH
30417: CALL_OW 266
30421: PUSH
30422: LD_INT 5
30424: EQUAL
30425: PUSH
30426: LD_VAR 0 3
30430: PPUSH
30431: CALL_OW 257
30435: PUSH
30436: LD_INT 1
30438: EQUAL
30439: AND
30440: PUSH
30441: LD_VAR 0 3
30445: PPUSH
30446: CALL_OW 459
30450: NOT
30451: AND
30452: PUSH
30453: LD_VAR 0 7
30457: AND
30458: IFFALSE 30474
// ComChangeProfession ( j , class ) ;
30460: LD_VAR 0 3
30464: PPUSH
30465: LD_VAR 0 7
30469: PPUSH
30470: CALL_OW 123
30474: GO 30404
30476: POP
30477: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
30478: LD_EXP 72
30482: PUSH
30483: LD_VAR 0 2
30487: ARRAY
30488: PUSH
30489: LD_EXP 71
30493: PUSH
30494: LD_VAR 0 2
30498: ARRAY
30499: NOT
30500: AND
30501: PUSH
30502: LD_EXP 49
30506: PUSH
30507: LD_VAR 0 2
30511: ARRAY
30512: PPUSH
30513: LD_INT 30
30515: PUSH
30516: LD_INT 32
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: PPUSH
30523: CALL_OW 72
30527: NOT
30528: AND
30529: PUSH
30530: LD_EXP 49
30534: PUSH
30535: LD_VAR 0 2
30539: ARRAY
30540: PPUSH
30541: LD_INT 2
30543: PUSH
30544: LD_INT 30
30546: PUSH
30547: LD_INT 4
30549: PUSH
30550: EMPTY
30551: LIST
30552: LIST
30553: PUSH
30554: LD_INT 30
30556: PUSH
30557: LD_INT 5
30559: PUSH
30560: EMPTY
30561: LIST
30562: LIST
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: LIST
30568: PPUSH
30569: CALL_OW 72
30573: NOT
30574: AND
30575: IFFALSE 30707
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
30577: LD_ADDR_VAR 0 4
30581: PUSH
30582: LD_EXP 49
30586: PUSH
30587: LD_VAR 0 2
30591: ARRAY
30592: PPUSH
30593: LD_INT 2
30595: PUSH
30596: LD_INT 25
30598: PUSH
30599: LD_INT 1
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 25
30608: PUSH
30609: LD_INT 5
30611: PUSH
30612: EMPTY
30613: LIST
30614: LIST
30615: PUSH
30616: LD_INT 25
30618: PUSH
30619: LD_INT 8
30621: PUSH
30622: EMPTY
30623: LIST
30624: LIST
30625: PUSH
30626: LD_INT 25
30628: PUSH
30629: LD_INT 9
30631: PUSH
30632: EMPTY
30633: LIST
30634: LIST
30635: PUSH
30636: EMPTY
30637: LIST
30638: LIST
30639: LIST
30640: LIST
30641: LIST
30642: PPUSH
30643: CALL_OW 72
30647: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
30648: LD_ADDR_VAR 0 4
30652: PUSH
30653: LD_VAR 0 4
30657: PUSH
30658: LD_VAR 0 4
30662: PPUSH
30663: LD_INT 18
30665: PPUSH
30666: CALL 83437 0 2
30670: DIFF
30671: ST_TO_ADDR
// if tmp then
30672: LD_VAR 0 4
30676: IFFALSE 30707
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
30678: LD_VAR 0 2
30682: PPUSH
30683: LD_VAR 0 4
30687: PPUSH
30688: LD_EXP 74
30692: PUSH
30693: LD_VAR 0 2
30697: ARRAY
30698: PPUSH
30699: CALL 45321 0 3
// exit ;
30703: POP
30704: POP
30705: GO 30802
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
30707: LD_EXP 72
30711: PUSH
30712: LD_VAR 0 2
30716: ARRAY
30717: PUSH
30718: LD_EXP 71
30722: PUSH
30723: LD_VAR 0 2
30727: ARRAY
30728: AND
30729: IFFALSE 30798
// begin tmp := mc_defender [ i ] ;
30731: LD_ADDR_VAR 0 4
30735: PUSH
30736: LD_EXP 71
30740: PUSH
30741: LD_VAR 0 2
30745: ARRAY
30746: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
30747: LD_ADDR_EXP 71
30751: PUSH
30752: LD_EXP 71
30756: PPUSH
30757: LD_VAR 0 2
30761: PPUSH
30762: EMPTY
30763: PPUSH
30764: CALL_OW 1
30768: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
30769: LD_VAR 0 2
30773: PPUSH
30774: LD_VAR 0 4
30778: PPUSH
30779: LD_EXP 72
30783: PUSH
30784: LD_VAR 0 2
30788: ARRAY
30789: PPUSH
30790: CALL 45819 0 3
// exit ;
30794: POP
30795: POP
30796: GO 30802
// end ; end ;
30798: GO 30213
30800: POP
30801: POP
// end ;
30802: LD_VAR 0 1
30806: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
30807: LD_INT 0
30809: PPUSH
30810: PPUSH
30811: PPUSH
30812: PPUSH
30813: PPUSH
30814: PPUSH
30815: PPUSH
30816: PPUSH
30817: PPUSH
30818: PPUSH
30819: PPUSH
// if not mc_bases then
30820: LD_EXP 49
30824: NOT
30825: IFFALSE 30829
// exit ;
30827: GO 31889
// for i = 1 to mc_bases do
30829: LD_ADDR_VAR 0 2
30833: PUSH
30834: DOUBLE
30835: LD_INT 1
30837: DEC
30838: ST_TO_ADDR
30839: LD_EXP 49
30843: PUSH
30844: FOR_TO
30845: IFFALSE 31887
// begin tmp := mc_lab [ i ] ;
30847: LD_ADDR_VAR 0 6
30851: PUSH
30852: LD_EXP 82
30856: PUSH
30857: LD_VAR 0 2
30861: ARRAY
30862: ST_TO_ADDR
// if not tmp then
30863: LD_VAR 0 6
30867: NOT
30868: IFFALSE 30872
// continue ;
30870: GO 30844
// idle_lab := 0 ;
30872: LD_ADDR_VAR 0 11
30876: PUSH
30877: LD_INT 0
30879: ST_TO_ADDR
// for j in tmp do
30880: LD_ADDR_VAR 0 3
30884: PUSH
30885: LD_VAR 0 6
30889: PUSH
30890: FOR_IN
30891: IFFALSE 31883
// begin researching := false ;
30893: LD_ADDR_VAR 0 10
30897: PUSH
30898: LD_INT 0
30900: ST_TO_ADDR
// side := GetSide ( j ) ;
30901: LD_ADDR_VAR 0 4
30905: PUSH
30906: LD_VAR 0 3
30910: PPUSH
30911: CALL_OW 255
30915: ST_TO_ADDR
// if not mc_tech [ side ] then
30916: LD_EXP 76
30920: PUSH
30921: LD_VAR 0 4
30925: ARRAY
30926: NOT
30927: IFFALSE 30931
// continue ;
30929: GO 30890
// if BuildingStatus ( j ) = bs_idle then
30931: LD_VAR 0 3
30935: PPUSH
30936: CALL_OW 461
30940: PUSH
30941: LD_INT 2
30943: EQUAL
30944: IFFALSE 31117
// begin if idle_lab then
30946: LD_VAR 0 11
30950: IFFALSE 31021
// begin tmp2 := UnitsInside ( idle_lab ) ;
30952: LD_ADDR_VAR 0 9
30956: PUSH
30957: LD_VAR 0 11
30961: PPUSH
30962: CALL_OW 313
30966: ST_TO_ADDR
// if tmp2 then
30967: LD_VAR 0 9
30971: IFFALSE 31013
// for x in tmp2 do
30973: LD_ADDR_VAR 0 7
30977: PUSH
30978: LD_VAR 0 9
30982: PUSH
30983: FOR_IN
30984: IFFALSE 31011
// begin ComExitBuilding ( x ) ;
30986: LD_VAR 0 7
30990: PPUSH
30991: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
30995: LD_VAR 0 7
30999: PPUSH
31000: LD_VAR 0 3
31004: PPUSH
31005: CALL_OW 180
// end ;
31009: GO 30983
31011: POP
31012: POP
// idle_lab := 0 ;
31013: LD_ADDR_VAR 0 11
31017: PUSH
31018: LD_INT 0
31020: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
31021: LD_ADDR_VAR 0 5
31025: PUSH
31026: LD_EXP 76
31030: PUSH
31031: LD_VAR 0 4
31035: ARRAY
31036: PUSH
31037: FOR_IN
31038: IFFALSE 31098
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
31040: LD_VAR 0 3
31044: PPUSH
31045: LD_VAR 0 5
31049: PPUSH
31050: CALL_OW 430
31054: PUSH
31055: LD_VAR 0 4
31059: PPUSH
31060: LD_VAR 0 5
31064: PPUSH
31065: CALL 44391 0 2
31069: AND
31070: IFFALSE 31096
// begin researching := true ;
31072: LD_ADDR_VAR 0 10
31076: PUSH
31077: LD_INT 1
31079: ST_TO_ADDR
// ComResearch ( j , t ) ;
31080: LD_VAR 0 3
31084: PPUSH
31085: LD_VAR 0 5
31089: PPUSH
31090: CALL_OW 124
// break ;
31094: GO 31098
// end ;
31096: GO 31037
31098: POP
31099: POP
// if not researching then
31100: LD_VAR 0 10
31104: NOT
31105: IFFALSE 31117
// idle_lab := j ;
31107: LD_ADDR_VAR 0 11
31111: PUSH
31112: LD_VAR 0 3
31116: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
31117: LD_VAR 0 3
31121: PPUSH
31122: CALL_OW 461
31126: PUSH
31127: LD_INT 10
31129: EQUAL
31130: IFFALSE 31718
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
31132: LD_EXP 78
31136: PUSH
31137: LD_VAR 0 2
31141: ARRAY
31142: NOT
31143: PUSH
31144: LD_EXP 79
31148: PUSH
31149: LD_VAR 0 2
31153: ARRAY
31154: NOT
31155: AND
31156: PUSH
31157: LD_EXP 76
31161: PUSH
31162: LD_VAR 0 4
31166: ARRAY
31167: PUSH
31168: LD_INT 1
31170: GREATER
31171: AND
31172: IFFALSE 31303
// begin ComCancel ( j ) ;
31174: LD_VAR 0 3
31178: PPUSH
31179: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
31183: LD_ADDR_EXP 76
31187: PUSH
31188: LD_EXP 76
31192: PPUSH
31193: LD_VAR 0 4
31197: PPUSH
31198: LD_EXP 76
31202: PUSH
31203: LD_VAR 0 4
31207: ARRAY
31208: PPUSH
31209: LD_EXP 76
31213: PUSH
31214: LD_VAR 0 4
31218: ARRAY
31219: PUSH
31220: LD_INT 1
31222: MINUS
31223: PPUSH
31224: LD_EXP 76
31228: PUSH
31229: LD_VAR 0 4
31233: ARRAY
31234: PPUSH
31235: LD_INT 0
31237: PPUSH
31238: CALL 49840 0 4
31242: PPUSH
31243: CALL_OW 1
31247: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
31248: LD_ADDR_EXP 76
31252: PUSH
31253: LD_EXP 76
31257: PPUSH
31258: LD_VAR 0 4
31262: PPUSH
31263: LD_EXP 76
31267: PUSH
31268: LD_VAR 0 4
31272: ARRAY
31273: PPUSH
31274: LD_EXP 76
31278: PUSH
31279: LD_VAR 0 4
31283: ARRAY
31284: PPUSH
31285: LD_INT 1
31287: PPUSH
31288: LD_INT 0
31290: PPUSH
31291: CALL 49840 0 4
31295: PPUSH
31296: CALL_OW 1
31300: ST_TO_ADDR
// continue ;
31301: GO 30890
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
31303: LD_EXP 78
31307: PUSH
31308: LD_VAR 0 2
31312: ARRAY
31313: PUSH
31314: LD_EXP 79
31318: PUSH
31319: LD_VAR 0 2
31323: ARRAY
31324: NOT
31325: AND
31326: IFFALSE 31453
// begin mc_ape_in_lab := Add ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
31328: LD_ADDR_EXP 79
31332: PUSH
31333: LD_EXP 79
31337: PPUSH
31338: LD_VAR 0 2
31342: PUSH
31343: LD_EXP 79
31347: PUSH
31348: LD_VAR 0 2
31352: ARRAY
31353: PUSH
31354: LD_INT 1
31356: PLUS
31357: PUSH
31358: EMPTY
31359: LIST
31360: LIST
31361: PPUSH
31362: LD_EXP 78
31366: PUSH
31367: LD_VAR 0 2
31371: ARRAY
31372: PUSH
31373: LD_INT 1
31375: ARRAY
31376: PPUSH
31377: CALL 50857 0 3
31381: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
31382: LD_EXP 78
31386: PUSH
31387: LD_VAR 0 2
31391: ARRAY
31392: PUSH
31393: LD_INT 1
31395: ARRAY
31396: PPUSH
31397: LD_INT 112
31399: PPUSH
31400: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
31404: LD_ADDR_VAR 0 9
31408: PUSH
31409: LD_EXP 78
31413: PUSH
31414: LD_VAR 0 2
31418: ARRAY
31419: PPUSH
31420: LD_INT 1
31422: PPUSH
31423: CALL_OW 3
31427: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
31428: LD_ADDR_EXP 78
31432: PUSH
31433: LD_EXP 78
31437: PPUSH
31438: LD_VAR 0 2
31442: PPUSH
31443: LD_VAR 0 9
31447: PPUSH
31448: CALL_OW 1
31452: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
31453: LD_EXP 78
31457: PUSH
31458: LD_VAR 0 2
31462: ARRAY
31463: PUSH
31464: LD_EXP 79
31468: PUSH
31469: LD_VAR 0 2
31473: ARRAY
31474: AND
31475: PUSH
31476: LD_EXP 79
31480: PUSH
31481: LD_VAR 0 2
31485: ARRAY
31486: PUSH
31487: LD_INT 1
31489: ARRAY
31490: PPUSH
31491: CALL_OW 310
31495: NOT
31496: AND
31497: PUSH
31498: LD_VAR 0 3
31502: PPUSH
31503: CALL_OW 313
31507: PUSH
31508: LD_INT 6
31510: EQUAL
31511: AND
31512: IFFALSE 31568
// begin tmp2 := UnitsInside ( j ) ;
31514: LD_ADDR_VAR 0 9
31518: PUSH
31519: LD_VAR 0 3
31523: PPUSH
31524: CALL_OW 313
31528: ST_TO_ADDR
// if tmp2 = 6 then
31529: LD_VAR 0 9
31533: PUSH
31534: LD_INT 6
31536: EQUAL
31537: IFFALSE 31568
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
31539: LD_VAR 0 9
31543: PUSH
31544: LD_INT 1
31546: ARRAY
31547: PPUSH
31548: LD_INT 112
31550: PPUSH
31551: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
31555: LD_VAR 0 9
31559: PUSH
31560: LD_INT 1
31562: ARRAY
31563: PPUSH
31564: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
31568: LD_EXP 79
31572: PUSH
31573: LD_VAR 0 2
31577: ARRAY
31578: PUSH
31579: LD_EXP 79
31583: PUSH
31584: LD_VAR 0 2
31588: ARRAY
31589: PUSH
31590: LD_INT 1
31592: ARRAY
31593: PPUSH
31594: CALL_OW 314
31598: NOT
31599: AND
31600: PUSH
31601: LD_EXP 79
31605: PUSH
31606: LD_VAR 0 2
31610: ARRAY
31611: PUSH
31612: LD_INT 1
31614: ARRAY
31615: PPUSH
31616: CALL_OW 310
31620: NOT
31621: AND
31622: IFFALSE 31648
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
31624: LD_EXP 79
31628: PUSH
31629: LD_VAR 0 2
31633: ARRAY
31634: PUSH
31635: LD_INT 1
31637: ARRAY
31638: PPUSH
31639: LD_VAR 0 3
31643: PPUSH
31644: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
31648: LD_EXP 79
31652: PUSH
31653: LD_VAR 0 2
31657: ARRAY
31658: PUSH
31659: LD_INT 1
31661: ARRAY
31662: PPUSH
31663: CALL_OW 310
31667: PUSH
31668: LD_EXP 79
31672: PUSH
31673: LD_VAR 0 2
31677: ARRAY
31678: PUSH
31679: LD_INT 1
31681: ARRAY
31682: PPUSH
31683: CALL_OW 310
31687: PPUSH
31688: CALL_OW 461
31692: PUSH
31693: LD_INT 3
31695: NONEQUAL
31696: AND
31697: IFFALSE 31718
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
31699: LD_EXP 79
31703: PUSH
31704: LD_VAR 0 2
31708: ARRAY
31709: PUSH
31710: LD_INT 1
31712: ARRAY
31713: PPUSH
31714: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
31718: LD_VAR 0 3
31722: PPUSH
31723: CALL_OW 461
31727: PUSH
31728: LD_INT 6
31730: EQUAL
31731: PUSH
31732: LD_VAR 0 6
31736: PUSH
31737: LD_INT 1
31739: GREATER
31740: AND
31741: IFFALSE 31881
// begin sci := [ ] ;
31743: LD_ADDR_VAR 0 8
31747: PUSH
31748: EMPTY
31749: ST_TO_ADDR
// for x in tmp diff j do
31750: LD_ADDR_VAR 0 7
31754: PUSH
31755: LD_VAR 0 6
31759: PUSH
31760: LD_VAR 0 3
31764: DIFF
31765: PUSH
31766: FOR_IN
31767: IFFALSE 31807
// begin if BuildingStatus ( x ) = bs_idle then
31769: LD_VAR 0 7
31773: PPUSH
31774: CALL_OW 461
31778: PUSH
31779: LD_INT 2
31781: EQUAL
31782: IFFALSE 31805
// sci := sci ^ UnitsInside ( x ) ;
31784: LD_ADDR_VAR 0 8
31788: PUSH
31789: LD_VAR 0 8
31793: PUSH
31794: LD_VAR 0 7
31798: PPUSH
31799: CALL_OW 313
31803: ADD
31804: ST_TO_ADDR
// end ;
31805: GO 31766
31807: POP
31808: POP
// if not sci then
31809: LD_VAR 0 8
31813: NOT
31814: IFFALSE 31818
// continue ;
31816: GO 30890
// for x in sci do
31818: LD_ADDR_VAR 0 7
31822: PUSH
31823: LD_VAR 0 8
31827: PUSH
31828: FOR_IN
31829: IFFALSE 31879
// if IsInUnit ( x ) and not HasTask ( x ) then
31831: LD_VAR 0 7
31835: PPUSH
31836: CALL_OW 310
31840: PUSH
31841: LD_VAR 0 7
31845: PPUSH
31846: CALL_OW 314
31850: NOT
31851: AND
31852: IFFALSE 31877
// begin ComExitBuilding ( x ) ;
31854: LD_VAR 0 7
31858: PPUSH
31859: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
31863: LD_VAR 0 7
31867: PPUSH
31868: LD_VAR 0 3
31872: PPUSH
31873: CALL_OW 180
// end ;
31877: GO 31828
31879: POP
31880: POP
// end ; end ;
31881: GO 30890
31883: POP
31884: POP
// end ;
31885: GO 30844
31887: POP
31888: POP
// end ;
31889: LD_VAR 0 1
31893: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
31894: LD_INT 0
31896: PPUSH
31897: PPUSH
// if not mc_bases then
31898: LD_EXP 49
31902: NOT
31903: IFFALSE 31907
// exit ;
31905: GO 31988
// for i = 1 to mc_bases do
31907: LD_ADDR_VAR 0 2
31911: PUSH
31912: DOUBLE
31913: LD_INT 1
31915: DEC
31916: ST_TO_ADDR
31917: LD_EXP 49
31921: PUSH
31922: FOR_TO
31923: IFFALSE 31986
// if mc_mines [ i ] and mc_miners [ i ] then
31925: LD_EXP 62
31929: PUSH
31930: LD_VAR 0 2
31934: ARRAY
31935: PUSH
31936: LD_EXP 63
31940: PUSH
31941: LD_VAR 0 2
31945: ARRAY
31946: AND
31947: IFFALSE 31984
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
31949: LD_EXP 63
31953: PUSH
31954: LD_VAR 0 2
31958: ARRAY
31959: PUSH
31960: LD_INT 1
31962: ARRAY
31963: PPUSH
31964: CALL_OW 255
31968: PPUSH
31969: LD_EXP 62
31973: PUSH
31974: LD_VAR 0 2
31978: ARRAY
31979: PPUSH
31980: CALL 47479 0 2
31984: GO 31922
31986: POP
31987: POP
// end ;
31988: LD_VAR 0 1
31992: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
31993: LD_INT 0
31995: PPUSH
31996: PPUSH
31997: PPUSH
31998: PPUSH
31999: PPUSH
32000: PPUSH
32001: PPUSH
32002: PPUSH
// if not mc_bases or not mc_parking then
32003: LD_EXP 49
32007: NOT
32008: PUSH
32009: LD_EXP 73
32013: NOT
32014: OR
32015: IFFALSE 32019
// exit ;
32017: GO 32731
// for i = 1 to mc_bases do
32019: LD_ADDR_VAR 0 2
32023: PUSH
32024: DOUBLE
32025: LD_INT 1
32027: DEC
32028: ST_TO_ADDR
32029: LD_EXP 49
32033: PUSH
32034: FOR_TO
32035: IFFALSE 32729
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
32037: LD_EXP 49
32041: PUSH
32042: LD_VAR 0 2
32046: ARRAY
32047: NOT
32048: PUSH
32049: LD_EXP 73
32053: PUSH
32054: LD_VAR 0 2
32058: ARRAY
32059: NOT
32060: OR
32061: IFFALSE 32065
// continue ;
32063: GO 32034
// if mc_scan [ i ] then
32065: LD_EXP 72
32069: PUSH
32070: LD_VAR 0 2
32074: ARRAY
32075: IFFALSE 32101
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
32077: LD_ADDR_EXP 61
32081: PUSH
32082: LD_EXP 61
32086: PPUSH
32087: LD_VAR 0 2
32091: PPUSH
32092: EMPTY
32093: PPUSH
32094: CALL_OW 1
32098: ST_TO_ADDR
// continue ;
32099: GO 32034
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
32101: LD_ADDR_VAR 0 5
32105: PUSH
32106: LD_EXP 49
32110: PUSH
32111: LD_VAR 0 2
32115: ARRAY
32116: PUSH
32117: LD_INT 1
32119: ARRAY
32120: PPUSH
32121: CALL_OW 255
32125: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32126: LD_ADDR_VAR 0 6
32130: PUSH
32131: LD_EXP 49
32135: PUSH
32136: LD_VAR 0 2
32140: ARRAY
32141: PPUSH
32142: LD_INT 30
32144: PUSH
32145: LD_INT 3
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PPUSH
32152: CALL_OW 72
32156: ST_TO_ADDR
// if not fac then
32157: LD_VAR 0 6
32161: NOT
32162: IFFALSE 32213
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32164: LD_ADDR_VAR 0 6
32168: PUSH
32169: LD_EXP 49
32173: PUSH
32174: LD_VAR 0 2
32178: ARRAY
32179: PPUSH
32180: LD_INT 2
32182: PUSH
32183: LD_INT 30
32185: PUSH
32186: LD_INT 0
32188: PUSH
32189: EMPTY
32190: LIST
32191: LIST
32192: PUSH
32193: LD_INT 30
32195: PUSH
32196: LD_INT 1
32198: PUSH
32199: EMPTY
32200: LIST
32201: LIST
32202: PUSH
32203: EMPTY
32204: LIST
32205: LIST
32206: LIST
32207: PPUSH
32208: CALL_OW 72
32212: ST_TO_ADDR
// if not fac then
32213: LD_VAR 0 6
32217: NOT
32218: IFFALSE 32222
// continue ;
32220: GO 32034
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
32222: LD_ADDR_VAR 0 7
32226: PUSH
32227: LD_EXP 73
32231: PUSH
32232: LD_VAR 0 2
32236: ARRAY
32237: PPUSH
32238: LD_INT 22
32240: PUSH
32241: LD_VAR 0 5
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: PUSH
32250: LD_INT 21
32252: PUSH
32253: LD_INT 2
32255: PUSH
32256: EMPTY
32257: LIST
32258: LIST
32259: PUSH
32260: LD_INT 3
32262: PUSH
32263: LD_INT 24
32265: PUSH
32266: LD_INT 1000
32268: PUSH
32269: EMPTY
32270: LIST
32271: LIST
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: EMPTY
32278: LIST
32279: LIST
32280: LIST
32281: PPUSH
32282: CALL_OW 70
32286: PUSH
32287: LD_INT 22
32289: PUSH
32290: LD_VAR 0 5
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: PUSH
32299: LD_INT 91
32301: PUSH
32302: LD_VAR 0 6
32306: PUSH
32307: LD_INT 1
32309: ARRAY
32310: PUSH
32311: LD_INT 25
32313: PUSH
32314: EMPTY
32315: LIST
32316: LIST
32317: LIST
32318: PUSH
32319: LD_INT 21
32321: PUSH
32322: LD_INT 2
32324: PUSH
32325: EMPTY
32326: LIST
32327: LIST
32328: PUSH
32329: LD_INT 3
32331: PUSH
32332: LD_INT 24
32334: PUSH
32335: LD_INT 1000
32337: PUSH
32338: EMPTY
32339: LIST
32340: LIST
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: LIST
32350: LIST
32351: PPUSH
32352: CALL_OW 69
32356: UNION
32357: ST_TO_ADDR
// if not vehs then
32358: LD_VAR 0 7
32362: NOT
32363: IFFALSE 32389
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
32365: LD_ADDR_EXP 61
32369: PUSH
32370: LD_EXP 61
32374: PPUSH
32375: LD_VAR 0 2
32379: PPUSH
32380: EMPTY
32381: PPUSH
32382: CALL_OW 1
32386: ST_TO_ADDR
// continue ;
32387: GO 32034
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32389: LD_ADDR_VAR 0 8
32393: PUSH
32394: LD_EXP 49
32398: PUSH
32399: LD_VAR 0 2
32403: ARRAY
32404: PPUSH
32405: LD_INT 30
32407: PUSH
32408: LD_INT 3
32410: PUSH
32411: EMPTY
32412: LIST
32413: LIST
32414: PPUSH
32415: CALL_OW 72
32419: ST_TO_ADDR
// if tmp then
32420: LD_VAR 0 8
32424: IFFALSE 32527
// begin for j in tmp do
32426: LD_ADDR_VAR 0 3
32430: PUSH
32431: LD_VAR 0 8
32435: PUSH
32436: FOR_IN
32437: IFFALSE 32525
// for k in UnitsInside ( j ) do
32439: LD_ADDR_VAR 0 4
32443: PUSH
32444: LD_VAR 0 3
32448: PPUSH
32449: CALL_OW 313
32453: PUSH
32454: FOR_IN
32455: IFFALSE 32521
// if k then
32457: LD_VAR 0 4
32461: IFFALSE 32519
// if not k in mc_repair_vehicle [ i ] then
32463: LD_VAR 0 4
32467: PUSH
32468: LD_EXP 61
32472: PUSH
32473: LD_VAR 0 2
32477: ARRAY
32478: IN
32479: NOT
32480: IFFALSE 32519
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
32482: LD_ADDR_EXP 61
32486: PUSH
32487: LD_EXP 61
32491: PPUSH
32492: LD_VAR 0 2
32496: PPUSH
32497: LD_EXP 61
32501: PUSH
32502: LD_VAR 0 2
32506: ARRAY
32507: PUSH
32508: LD_VAR 0 4
32512: UNION
32513: PPUSH
32514: CALL_OW 1
32518: ST_TO_ADDR
32519: GO 32454
32521: POP
32522: POP
32523: GO 32436
32525: POP
32526: POP
// end ; if not mc_repair_vehicle [ i ] then
32527: LD_EXP 61
32531: PUSH
32532: LD_VAR 0 2
32536: ARRAY
32537: NOT
32538: IFFALSE 32542
// continue ;
32540: GO 32034
// for j in mc_repair_vehicle [ i ] do
32542: LD_ADDR_VAR 0 3
32546: PUSH
32547: LD_EXP 61
32551: PUSH
32552: LD_VAR 0 2
32556: ARRAY
32557: PUSH
32558: FOR_IN
32559: IFFALSE 32725
// begin if GetClass ( j ) <> 3 then
32561: LD_VAR 0 3
32565: PPUSH
32566: CALL_OW 257
32570: PUSH
32571: LD_INT 3
32573: NONEQUAL
32574: IFFALSE 32615
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
32576: LD_ADDR_EXP 61
32580: PUSH
32581: LD_EXP 61
32585: PPUSH
32586: LD_VAR 0 2
32590: PPUSH
32591: LD_EXP 61
32595: PUSH
32596: LD_VAR 0 2
32600: ARRAY
32601: PUSH
32602: LD_VAR 0 3
32606: DIFF
32607: PPUSH
32608: CALL_OW 1
32612: ST_TO_ADDR
// continue ;
32613: GO 32558
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
32615: LD_VAR 0 3
32619: PPUSH
32620: CALL_OW 311
32624: NOT
32625: PUSH
32626: LD_VAR 0 3
32630: PUSH
32631: LD_EXP 52
32635: PUSH
32636: LD_VAR 0 2
32640: ARRAY
32641: PUSH
32642: LD_INT 1
32644: ARRAY
32645: IN
32646: NOT
32647: AND
32648: PUSH
32649: LD_VAR 0 3
32653: PUSH
32654: LD_EXP 52
32658: PUSH
32659: LD_VAR 0 2
32663: ARRAY
32664: PUSH
32665: LD_INT 2
32667: ARRAY
32668: IN
32669: NOT
32670: AND
32671: IFFALSE 32723
// begin if IsInUnit ( j ) then
32673: LD_VAR 0 3
32677: PPUSH
32678: CALL_OW 310
32682: IFFALSE 32693
// ComExitBuilding ( j ) ;
32684: LD_VAR 0 3
32688: PPUSH
32689: CALL_OW 122
// if not HasTask ( j ) then
32693: LD_VAR 0 3
32697: PPUSH
32698: CALL_OW 314
32702: NOT
32703: IFFALSE 32723
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
32705: LD_VAR 0 3
32709: PPUSH
32710: LD_VAR 0 7
32714: PUSH
32715: LD_INT 1
32717: ARRAY
32718: PPUSH
32719: CALL_OW 189
// end ; end ;
32723: GO 32558
32725: POP
32726: POP
// end ;
32727: GO 32034
32729: POP
32730: POP
// end ;
32731: LD_VAR 0 1
32735: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
32736: LD_INT 0
32738: PPUSH
32739: PPUSH
32740: PPUSH
32741: PPUSH
32742: PPUSH
32743: PPUSH
32744: PPUSH
32745: PPUSH
32746: PPUSH
32747: PPUSH
32748: PPUSH
// if not mc_bases then
32749: LD_EXP 49
32753: NOT
32754: IFFALSE 32758
// exit ;
32756: GO 33560
// for i = 1 to mc_bases do
32758: LD_ADDR_VAR 0 2
32762: PUSH
32763: DOUBLE
32764: LD_INT 1
32766: DEC
32767: ST_TO_ADDR
32768: LD_EXP 49
32772: PUSH
32773: FOR_TO
32774: IFFALSE 33558
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
32776: LD_EXP 77
32780: PUSH
32781: LD_VAR 0 2
32785: ARRAY
32786: NOT
32787: PUSH
32788: LD_EXP 52
32792: PUSH
32793: LD_VAR 0 2
32797: ARRAY
32798: PUSH
32799: LD_INT 1
32801: ARRAY
32802: OR
32803: PUSH
32804: LD_EXP 52
32808: PUSH
32809: LD_VAR 0 2
32813: ARRAY
32814: PUSH
32815: LD_INT 2
32817: ARRAY
32818: OR
32819: PUSH
32820: LD_EXP 75
32824: PUSH
32825: LD_VAR 0 2
32829: ARRAY
32830: PPUSH
32831: LD_INT 1
32833: PPUSH
32834: CALL_OW 325
32838: NOT
32839: OR
32840: PUSH
32841: LD_EXP 72
32845: PUSH
32846: LD_VAR 0 2
32850: ARRAY
32851: OR
32852: IFFALSE 32856
// continue ;
32854: GO 32773
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
32856: LD_ADDR_VAR 0 8
32860: PUSH
32861: LD_EXP 49
32865: PUSH
32866: LD_VAR 0 2
32870: ARRAY
32871: PPUSH
32872: LD_INT 25
32874: PUSH
32875: LD_INT 4
32877: PUSH
32878: EMPTY
32879: LIST
32880: LIST
32881: PUSH
32882: LD_INT 50
32884: PUSH
32885: EMPTY
32886: LIST
32887: PUSH
32888: LD_INT 3
32890: PUSH
32891: LD_INT 60
32893: PUSH
32894: EMPTY
32895: LIST
32896: PUSH
32897: EMPTY
32898: LIST
32899: LIST
32900: PUSH
32901: EMPTY
32902: LIST
32903: LIST
32904: LIST
32905: PPUSH
32906: CALL_OW 72
32910: PUSH
32911: LD_EXP 53
32915: PUSH
32916: LD_VAR 0 2
32920: ARRAY
32921: DIFF
32922: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32923: LD_ADDR_VAR 0 9
32927: PUSH
32928: LD_EXP 49
32932: PUSH
32933: LD_VAR 0 2
32937: ARRAY
32938: PPUSH
32939: LD_INT 2
32941: PUSH
32942: LD_INT 30
32944: PUSH
32945: LD_INT 0
32947: PUSH
32948: EMPTY
32949: LIST
32950: LIST
32951: PUSH
32952: LD_INT 30
32954: PUSH
32955: LD_INT 1
32957: PUSH
32958: EMPTY
32959: LIST
32960: LIST
32961: PUSH
32962: EMPTY
32963: LIST
32964: LIST
32965: LIST
32966: PPUSH
32967: CALL_OW 72
32971: ST_TO_ADDR
// if not tmp or not dep then
32972: LD_VAR 0 8
32976: NOT
32977: PUSH
32978: LD_VAR 0 9
32982: NOT
32983: OR
32984: IFFALSE 32988
// continue ;
32986: GO 32773
// side := GetSide ( tmp [ 1 ] ) ;
32988: LD_ADDR_VAR 0 11
32992: PUSH
32993: LD_VAR 0 8
32997: PUSH
32998: LD_INT 1
33000: ARRAY
33001: PPUSH
33002: CALL_OW 255
33006: ST_TO_ADDR
// dep := dep [ 1 ] ;
33007: LD_ADDR_VAR 0 9
33011: PUSH
33012: LD_VAR 0 9
33016: PUSH
33017: LD_INT 1
33019: ARRAY
33020: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
33021: LD_ADDR_VAR 0 7
33025: PUSH
33026: LD_EXP 77
33030: PUSH
33031: LD_VAR 0 2
33035: ARRAY
33036: PPUSH
33037: LD_INT 22
33039: PUSH
33040: LD_INT 0
33042: PUSH
33043: EMPTY
33044: LIST
33045: LIST
33046: PUSH
33047: LD_INT 25
33049: PUSH
33050: LD_INT 12
33052: PUSH
33053: EMPTY
33054: LIST
33055: LIST
33056: PUSH
33057: EMPTY
33058: LIST
33059: LIST
33060: PPUSH
33061: CALL_OW 70
33065: PUSH
33066: LD_INT 22
33068: PUSH
33069: LD_INT 0
33071: PUSH
33072: EMPTY
33073: LIST
33074: LIST
33075: PUSH
33076: LD_INT 25
33078: PUSH
33079: LD_INT 12
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: LD_INT 91
33088: PUSH
33089: LD_VAR 0 9
33093: PUSH
33094: LD_INT 20
33096: PUSH
33097: EMPTY
33098: LIST
33099: LIST
33100: LIST
33101: PUSH
33102: EMPTY
33103: LIST
33104: LIST
33105: LIST
33106: PPUSH
33107: CALL_OW 69
33111: UNION
33112: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
33113: LD_ADDR_VAR 0 10
33117: PUSH
33118: LD_EXP 77
33122: PUSH
33123: LD_VAR 0 2
33127: ARRAY
33128: PPUSH
33129: LD_INT 81
33131: PUSH
33132: LD_VAR 0 11
33136: PUSH
33137: EMPTY
33138: LIST
33139: LIST
33140: PPUSH
33141: CALL_OW 70
33145: ST_TO_ADDR
// if not apes or danger_at_area then
33146: LD_VAR 0 7
33150: NOT
33151: PUSH
33152: LD_VAR 0 10
33156: OR
33157: IFFALSE 33207
// begin if mc_taming [ i ] then
33159: LD_EXP 80
33163: PUSH
33164: LD_VAR 0 2
33168: ARRAY
33169: IFFALSE 33205
// begin MC_Reset ( i , 121 ) ;
33171: LD_VAR 0 2
33175: PPUSH
33176: LD_INT 121
33178: PPUSH
33179: CALL 19344 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
33183: LD_ADDR_EXP 80
33187: PUSH
33188: LD_EXP 80
33192: PPUSH
33193: LD_VAR 0 2
33197: PPUSH
33198: EMPTY
33199: PPUSH
33200: CALL_OW 1
33204: ST_TO_ADDR
// end ; continue ;
33205: GO 32773
// end ; for j in tmp do
33207: LD_ADDR_VAR 0 3
33211: PUSH
33212: LD_VAR 0 8
33216: PUSH
33217: FOR_IN
33218: IFFALSE 33554
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
33220: LD_VAR 0 3
33224: PUSH
33225: LD_EXP 80
33229: PUSH
33230: LD_VAR 0 2
33234: ARRAY
33235: IN
33236: NOT
33237: PUSH
33238: LD_EXP 80
33242: PUSH
33243: LD_VAR 0 2
33247: ARRAY
33248: PUSH
33249: LD_INT 3
33251: LESS
33252: AND
33253: IFFALSE 33311
// begin SetTag ( j , 121 ) ;
33255: LD_VAR 0 3
33259: PPUSH
33260: LD_INT 121
33262: PPUSH
33263: CALL_OW 109
// mc_taming := Add ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
33267: LD_ADDR_EXP 80
33271: PUSH
33272: LD_EXP 80
33276: PPUSH
33277: LD_VAR 0 2
33281: PUSH
33282: LD_EXP 80
33286: PUSH
33287: LD_VAR 0 2
33291: ARRAY
33292: PUSH
33293: LD_INT 1
33295: PLUS
33296: PUSH
33297: EMPTY
33298: LIST
33299: LIST
33300: PPUSH
33301: LD_VAR 0 3
33305: PPUSH
33306: CALL 50857 0 3
33310: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
33311: LD_VAR 0 3
33315: PUSH
33316: LD_EXP 80
33320: PUSH
33321: LD_VAR 0 2
33325: ARRAY
33326: IN
33327: IFFALSE 33552
// begin if GetClass ( j ) <> 4 then
33329: LD_VAR 0 3
33333: PPUSH
33334: CALL_OW 257
33338: PUSH
33339: LD_INT 4
33341: NONEQUAL
33342: IFFALSE 33395
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
33344: LD_ADDR_EXP 80
33348: PUSH
33349: LD_EXP 80
33353: PPUSH
33354: LD_VAR 0 2
33358: PPUSH
33359: LD_EXP 80
33363: PUSH
33364: LD_VAR 0 2
33368: ARRAY
33369: PUSH
33370: LD_VAR 0 3
33374: DIFF
33375: PPUSH
33376: CALL_OW 1
33380: ST_TO_ADDR
// SetTag ( j , 0 ) ;
33381: LD_VAR 0 3
33385: PPUSH
33386: LD_INT 0
33388: PPUSH
33389: CALL_OW 109
// continue ;
33393: GO 33217
// end ; if IsInUnit ( j ) then
33395: LD_VAR 0 3
33399: PPUSH
33400: CALL_OW 310
33404: IFFALSE 33415
// ComExitBuilding ( j ) ;
33406: LD_VAR 0 3
33410: PPUSH
33411: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
33415: LD_ADDR_VAR 0 6
33419: PUSH
33420: LD_VAR 0 7
33424: PPUSH
33425: LD_VAR 0 3
33429: PPUSH
33430: CALL_OW 74
33434: ST_TO_ADDR
// if not ape then
33435: LD_VAR 0 6
33439: NOT
33440: IFFALSE 33444
// break ;
33442: GO 33554
// x := GetX ( ape ) ;
33444: LD_ADDR_VAR 0 4
33448: PUSH
33449: LD_VAR 0 6
33453: PPUSH
33454: CALL_OW 250
33458: ST_TO_ADDR
// y := GetY ( ape ) ;
33459: LD_ADDR_VAR 0 5
33463: PUSH
33464: LD_VAR 0 6
33468: PPUSH
33469: CALL_OW 251
33473: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33474: LD_VAR 0 4
33478: PPUSH
33479: LD_VAR 0 5
33483: PPUSH
33484: CALL_OW 488
33488: NOT
33489: PUSH
33490: LD_VAR 0 11
33494: PPUSH
33495: LD_VAR 0 4
33499: PPUSH
33500: LD_VAR 0 5
33504: PPUSH
33505: LD_INT 20
33507: PPUSH
33508: CALL 51351 0 4
33512: PUSH
33513: LD_INT 4
33515: ARRAY
33516: OR
33517: IFFALSE 33521
// break ;
33519: GO 33554
// if not HasTask ( j ) then
33521: LD_VAR 0 3
33525: PPUSH
33526: CALL_OW 314
33530: NOT
33531: IFFALSE 33552
// ComTameXY ( j , x , y ) ;
33533: LD_VAR 0 3
33537: PPUSH
33538: LD_VAR 0 4
33542: PPUSH
33543: LD_VAR 0 5
33547: PPUSH
33548: CALL_OW 131
// end ; end ;
33552: GO 33217
33554: POP
33555: POP
// end ;
33556: GO 32773
33558: POP
33559: POP
// end ;
33560: LD_VAR 0 1
33564: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
33565: LD_INT 0
33567: PPUSH
33568: PPUSH
33569: PPUSH
33570: PPUSH
33571: PPUSH
33572: PPUSH
33573: PPUSH
33574: PPUSH
// if not mc_bases then
33575: LD_EXP 49
33579: NOT
33580: IFFALSE 33584
// exit ;
33582: GO 34210
// for i = 1 to mc_bases do
33584: LD_ADDR_VAR 0 2
33588: PUSH
33589: DOUBLE
33590: LD_INT 1
33592: DEC
33593: ST_TO_ADDR
33594: LD_EXP 49
33598: PUSH
33599: FOR_TO
33600: IFFALSE 34208
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
33602: LD_EXP 78
33606: PUSH
33607: LD_VAR 0 2
33611: ARRAY
33612: NOT
33613: PUSH
33614: LD_EXP 78
33618: PUSH
33619: LD_VAR 0 2
33623: ARRAY
33624: PPUSH
33625: LD_INT 25
33627: PUSH
33628: LD_INT 12
33630: PUSH
33631: EMPTY
33632: LIST
33633: LIST
33634: PPUSH
33635: CALL_OW 72
33639: NOT
33640: OR
33641: IFFALSE 33645
// continue ;
33643: GO 33599
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
33645: LD_ADDR_VAR 0 5
33649: PUSH
33650: LD_EXP 78
33654: PUSH
33655: LD_VAR 0 2
33659: ARRAY
33660: PUSH
33661: LD_INT 1
33663: ARRAY
33664: PPUSH
33665: CALL_OW 255
33669: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
33670: LD_VAR 0 5
33674: PPUSH
33675: LD_INT 2
33677: PPUSH
33678: CALL_OW 325
33682: IFFALSE 33935
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
33684: LD_ADDR_VAR 0 4
33688: PUSH
33689: LD_EXP 78
33693: PUSH
33694: LD_VAR 0 2
33698: ARRAY
33699: PPUSH
33700: LD_INT 25
33702: PUSH
33703: LD_INT 16
33705: PUSH
33706: EMPTY
33707: LIST
33708: LIST
33709: PPUSH
33710: CALL_OW 72
33714: ST_TO_ADDR
// if tmp < 6 then
33715: LD_VAR 0 4
33719: PUSH
33720: LD_INT 6
33722: LESS
33723: IFFALSE 33935
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
33725: LD_ADDR_VAR 0 6
33729: PUSH
33730: LD_EXP 49
33734: PUSH
33735: LD_VAR 0 2
33739: ARRAY
33740: PPUSH
33741: LD_INT 2
33743: PUSH
33744: LD_INT 30
33746: PUSH
33747: LD_INT 0
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: LD_INT 30
33756: PUSH
33757: LD_INT 1
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: LIST
33768: PPUSH
33769: CALL_OW 72
33773: ST_TO_ADDR
// if depot then
33774: LD_VAR 0 6
33778: IFFALSE 33935
// begin selected := 0 ;
33780: LD_ADDR_VAR 0 7
33784: PUSH
33785: LD_INT 0
33787: ST_TO_ADDR
// for j in depot do
33788: LD_ADDR_VAR 0 3
33792: PUSH
33793: LD_VAR 0 6
33797: PUSH
33798: FOR_IN
33799: IFFALSE 33830
// begin if UnitsInside ( j ) < 6 then
33801: LD_VAR 0 3
33805: PPUSH
33806: CALL_OW 313
33810: PUSH
33811: LD_INT 6
33813: LESS
33814: IFFALSE 33828
// begin selected := j ;
33816: LD_ADDR_VAR 0 7
33820: PUSH
33821: LD_VAR 0 3
33825: ST_TO_ADDR
// break ;
33826: GO 33830
// end ; end ;
33828: GO 33798
33830: POP
33831: POP
// if selected then
33832: LD_VAR 0 7
33836: IFFALSE 33935
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
33838: LD_ADDR_VAR 0 3
33842: PUSH
33843: LD_EXP 78
33847: PUSH
33848: LD_VAR 0 2
33852: ARRAY
33853: PPUSH
33854: LD_INT 25
33856: PUSH
33857: LD_INT 12
33859: PUSH
33860: EMPTY
33861: LIST
33862: LIST
33863: PPUSH
33864: CALL_OW 72
33868: PUSH
33869: FOR_IN
33870: IFFALSE 33933
// if not HasTask ( j ) then
33872: LD_VAR 0 3
33876: PPUSH
33877: CALL_OW 314
33881: NOT
33882: IFFALSE 33931
// begin if not IsInUnit ( j ) then
33884: LD_VAR 0 3
33888: PPUSH
33889: CALL_OW 310
33893: NOT
33894: IFFALSE 33910
// ComEnterUnit ( j , selected ) ;
33896: LD_VAR 0 3
33900: PPUSH
33901: LD_VAR 0 7
33905: PPUSH
33906: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
33910: LD_VAR 0 3
33914: PPUSH
33915: LD_INT 16
33917: PPUSH
33918: CALL_OW 183
// AddComExitBuilding ( j ) ;
33922: LD_VAR 0 3
33926: PPUSH
33927: CALL_OW 182
// end ;
33931: GO 33869
33933: POP
33934: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
33935: LD_VAR 0 5
33939: PPUSH
33940: LD_INT 11
33942: PPUSH
33943: CALL_OW 325
33947: IFFALSE 34206
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
33949: LD_ADDR_VAR 0 4
33953: PUSH
33954: LD_EXP 78
33958: PUSH
33959: LD_VAR 0 2
33963: ARRAY
33964: PPUSH
33965: LD_INT 25
33967: PUSH
33968: LD_INT 16
33970: PUSH
33971: EMPTY
33972: LIST
33973: LIST
33974: PPUSH
33975: CALL_OW 72
33979: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
33980: LD_VAR 0 4
33984: PUSH
33985: LD_INT 6
33987: GREATEREQUAL
33988: PUSH
33989: LD_VAR 0 5
33993: PPUSH
33994: LD_INT 2
33996: PPUSH
33997: CALL_OW 325
34001: NOT
34002: OR
34003: IFFALSE 34206
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
34005: LD_ADDR_VAR 0 8
34009: PUSH
34010: LD_EXP 49
34014: PUSH
34015: LD_VAR 0 2
34019: ARRAY
34020: PPUSH
34021: LD_INT 2
34023: PUSH
34024: LD_INT 30
34026: PUSH
34027: LD_INT 4
34029: PUSH
34030: EMPTY
34031: LIST
34032: LIST
34033: PUSH
34034: LD_INT 30
34036: PUSH
34037: LD_INT 5
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: PUSH
34044: EMPTY
34045: LIST
34046: LIST
34047: LIST
34048: PPUSH
34049: CALL_OW 72
34053: ST_TO_ADDR
// if barracks then
34054: LD_VAR 0 8
34058: IFFALSE 34206
// begin selected := 0 ;
34060: LD_ADDR_VAR 0 7
34064: PUSH
34065: LD_INT 0
34067: ST_TO_ADDR
// for j in barracks do
34068: LD_ADDR_VAR 0 3
34072: PUSH
34073: LD_VAR 0 8
34077: PUSH
34078: FOR_IN
34079: IFFALSE 34110
// begin if UnitsInside ( j ) < 6 then
34081: LD_VAR 0 3
34085: PPUSH
34086: CALL_OW 313
34090: PUSH
34091: LD_INT 6
34093: LESS
34094: IFFALSE 34108
// begin selected := j ;
34096: LD_ADDR_VAR 0 7
34100: PUSH
34101: LD_VAR 0 3
34105: ST_TO_ADDR
// break ;
34106: GO 34110
// end ; end ;
34108: GO 34078
34110: POP
34111: POP
// if selected then
34112: LD_VAR 0 7
34116: IFFALSE 34206
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
34118: LD_ADDR_VAR 0 3
34122: PUSH
34123: LD_EXP 78
34127: PUSH
34128: LD_VAR 0 2
34132: ARRAY
34133: PPUSH
34134: LD_INT 25
34136: PUSH
34137: LD_INT 12
34139: PUSH
34140: EMPTY
34141: LIST
34142: LIST
34143: PPUSH
34144: CALL_OW 72
34148: PUSH
34149: FOR_IN
34150: IFFALSE 34204
// if not IsInUnit ( j ) and not HasTask ( j ) then
34152: LD_VAR 0 3
34156: PPUSH
34157: CALL_OW 310
34161: NOT
34162: PUSH
34163: LD_VAR 0 3
34167: PPUSH
34168: CALL_OW 314
34172: NOT
34173: AND
34174: IFFALSE 34202
// begin ComEnterUnit ( j , selected ) ;
34176: LD_VAR 0 3
34180: PPUSH
34181: LD_VAR 0 7
34185: PPUSH
34186: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
34190: LD_VAR 0 3
34194: PPUSH
34195: LD_INT 15
34197: PPUSH
34198: CALL_OW 183
// end ;
34202: GO 34149
34204: POP
34205: POP
// end ; end ; end ; end ; end ;
34206: GO 33599
34208: POP
34209: POP
// end ;
34210: LD_VAR 0 1
34214: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
34215: LD_INT 0
34217: PPUSH
34218: PPUSH
34219: PPUSH
34220: PPUSH
// if not mc_bases then
34221: LD_EXP 49
34225: NOT
34226: IFFALSE 34230
// exit ;
34228: GO 34408
// for i = 1 to mc_bases do
34230: LD_ADDR_VAR 0 2
34234: PUSH
34235: DOUBLE
34236: LD_INT 1
34238: DEC
34239: ST_TO_ADDR
34240: LD_EXP 49
34244: PUSH
34245: FOR_TO
34246: IFFALSE 34406
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
34248: LD_ADDR_VAR 0 4
34252: PUSH
34253: LD_EXP 49
34257: PUSH
34258: LD_VAR 0 2
34262: ARRAY
34263: PPUSH
34264: LD_INT 25
34266: PUSH
34267: LD_INT 9
34269: PUSH
34270: EMPTY
34271: LIST
34272: LIST
34273: PPUSH
34274: CALL_OW 72
34278: ST_TO_ADDR
// if not tmp then
34279: LD_VAR 0 4
34283: NOT
34284: IFFALSE 34288
// continue ;
34286: GO 34245
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
34288: LD_EXP 75
34292: PUSH
34293: LD_VAR 0 2
34297: ARRAY
34298: PPUSH
34299: LD_INT 29
34301: PPUSH
34302: CALL_OW 325
34306: NOT
34307: PUSH
34308: LD_EXP 75
34312: PUSH
34313: LD_VAR 0 2
34317: ARRAY
34318: PPUSH
34319: LD_INT 28
34321: PPUSH
34322: CALL_OW 325
34326: NOT
34327: AND
34328: IFFALSE 34332
// continue ;
34330: GO 34245
// for j in tmp do
34332: LD_ADDR_VAR 0 3
34336: PUSH
34337: LD_VAR 0 4
34341: PUSH
34342: FOR_IN
34343: IFFALSE 34402
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
34345: LD_VAR 0 3
34349: PUSH
34350: LD_EXP 52
34354: PUSH
34355: LD_VAR 0 2
34359: ARRAY
34360: PUSH
34361: LD_INT 1
34363: ARRAY
34364: IN
34365: NOT
34366: PUSH
34367: LD_VAR 0 3
34371: PUSH
34372: LD_EXP 52
34376: PUSH
34377: LD_VAR 0 2
34381: ARRAY
34382: PUSH
34383: LD_INT 2
34385: ARRAY
34386: IN
34387: NOT
34388: AND
34389: IFFALSE 34400
// ComSpaceTimeShoot ( j ) ;
34391: LD_VAR 0 3
34395: PPUSH
34396: CALL 44482 0 1
34400: GO 34342
34402: POP
34403: POP
// end ;
34404: GO 34245
34406: POP
34407: POP
// end ;
34408: LD_VAR 0 1
34412: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
34413: LD_INT 0
34415: PPUSH
34416: PPUSH
34417: PPUSH
34418: PPUSH
34419: PPUSH
34420: PPUSH
34421: PPUSH
34422: PPUSH
34423: PPUSH
// if not mc_bases then
34424: LD_EXP 49
34428: NOT
34429: IFFALSE 34433
// exit ;
34431: GO 35055
// for i = 1 to mc_bases do
34433: LD_ADDR_VAR 0 2
34437: PUSH
34438: DOUBLE
34439: LD_INT 1
34441: DEC
34442: ST_TO_ADDR
34443: LD_EXP 49
34447: PUSH
34448: FOR_TO
34449: IFFALSE 35053
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
34451: LD_EXP 84
34455: PUSH
34456: LD_VAR 0 2
34460: ARRAY
34461: NOT
34462: PUSH
34463: LD_INT 38
34465: PPUSH
34466: LD_EXP 75
34470: PUSH
34471: LD_VAR 0 2
34475: ARRAY
34476: PPUSH
34477: CALL_OW 321
34481: PUSH
34482: LD_INT 2
34484: NONEQUAL
34485: OR
34486: IFFALSE 34490
// continue ;
34488: GO 34448
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
34490: LD_ADDR_VAR 0 8
34494: PUSH
34495: LD_EXP 49
34499: PUSH
34500: LD_VAR 0 2
34504: ARRAY
34505: PPUSH
34506: LD_INT 30
34508: PUSH
34509: LD_INT 34
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PPUSH
34516: CALL_OW 72
34520: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
34521: LD_ADDR_VAR 0 9
34525: PUSH
34526: LD_EXP 49
34530: PUSH
34531: LD_VAR 0 2
34535: ARRAY
34536: PPUSH
34537: LD_INT 25
34539: PUSH
34540: LD_INT 4
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PPUSH
34547: CALL_OW 72
34551: PPUSH
34552: LD_INT 0
34554: PPUSH
34555: CALL 83437 0 2
34559: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
34560: LD_VAR 0 9
34564: NOT
34565: PUSH
34566: LD_VAR 0 8
34570: NOT
34571: OR
34572: PUSH
34573: LD_EXP 49
34577: PUSH
34578: LD_VAR 0 2
34582: ARRAY
34583: PPUSH
34584: LD_INT 124
34586: PPUSH
34587: CALL 83437 0 2
34591: OR
34592: IFFALSE 34596
// continue ;
34594: GO 34448
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
34596: LD_EXP 85
34600: PUSH
34601: LD_VAR 0 2
34605: ARRAY
34606: PUSH
34607: LD_EXP 84
34611: PUSH
34612: LD_VAR 0 2
34616: ARRAY
34617: LESS
34618: PUSH
34619: LD_EXP 85
34623: PUSH
34624: LD_VAR 0 2
34628: ARRAY
34629: PUSH
34630: LD_VAR 0 8
34634: LESS
34635: AND
34636: IFFALSE 35051
// begin tmp := sci [ 1 ] ;
34638: LD_ADDR_VAR 0 7
34642: PUSH
34643: LD_VAR 0 9
34647: PUSH
34648: LD_INT 1
34650: ARRAY
34651: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
34652: LD_VAR 0 7
34656: PPUSH
34657: LD_INT 124
34659: PPUSH
34660: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
34664: LD_ADDR_VAR 0 3
34668: PUSH
34669: DOUBLE
34670: LD_EXP 84
34674: PUSH
34675: LD_VAR 0 2
34679: ARRAY
34680: INC
34681: ST_TO_ADDR
34682: LD_EXP 84
34686: PUSH
34687: LD_VAR 0 2
34691: ARRAY
34692: PUSH
34693: FOR_DOWNTO
34694: IFFALSE 35037
// begin if IsInUnit ( tmp ) then
34696: LD_VAR 0 7
34700: PPUSH
34701: CALL_OW 310
34705: IFFALSE 34716
// ComExitBuilding ( tmp ) ;
34707: LD_VAR 0 7
34711: PPUSH
34712: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
34716: LD_INT 35
34718: PPUSH
34719: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
34723: LD_VAR 0 7
34727: PPUSH
34728: CALL_OW 310
34732: NOT
34733: PUSH
34734: LD_VAR 0 7
34738: PPUSH
34739: CALL_OW 314
34743: NOT
34744: AND
34745: IFFALSE 34716
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
34747: LD_ADDR_VAR 0 6
34751: PUSH
34752: LD_VAR 0 7
34756: PPUSH
34757: CALL_OW 250
34761: PUSH
34762: LD_VAR 0 7
34766: PPUSH
34767: CALL_OW 251
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
34776: LD_INT 35
34778: PPUSH
34779: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
34783: LD_ADDR_VAR 0 4
34787: PUSH
34788: LD_EXP 84
34792: PUSH
34793: LD_VAR 0 2
34797: ARRAY
34798: PUSH
34799: LD_VAR 0 3
34803: ARRAY
34804: PUSH
34805: LD_INT 1
34807: ARRAY
34808: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
34809: LD_ADDR_VAR 0 5
34813: PUSH
34814: LD_EXP 84
34818: PUSH
34819: LD_VAR 0 2
34823: ARRAY
34824: PUSH
34825: LD_VAR 0 3
34829: ARRAY
34830: PUSH
34831: LD_INT 2
34833: ARRAY
34834: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
34835: LD_VAR 0 7
34839: PPUSH
34840: LD_INT 10
34842: PPUSH
34843: CALL 53048 0 2
34847: PUSH
34848: LD_INT 4
34850: ARRAY
34851: IFFALSE 34889
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
34853: LD_VAR 0 7
34857: PPUSH
34858: LD_VAR 0 6
34862: PUSH
34863: LD_INT 1
34865: ARRAY
34866: PPUSH
34867: LD_VAR 0 6
34871: PUSH
34872: LD_INT 2
34874: ARRAY
34875: PPUSH
34876: CALL_OW 111
// wait ( 0 0$10 ) ;
34880: LD_INT 350
34882: PPUSH
34883: CALL_OW 67
// end else
34887: GO 34915
// begin ComMoveXY ( tmp , x , y ) ;
34889: LD_VAR 0 7
34893: PPUSH
34894: LD_VAR 0 4
34898: PPUSH
34899: LD_VAR 0 5
34903: PPUSH
34904: CALL_OW 111
// wait ( 0 0$3 ) ;
34908: LD_INT 105
34910: PPUSH
34911: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
34915: LD_VAR 0 7
34919: PPUSH
34920: LD_VAR 0 4
34924: PPUSH
34925: LD_VAR 0 5
34929: PPUSH
34930: CALL_OW 307
34934: IFFALSE 34776
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
34936: LD_VAR 0 7
34940: PPUSH
34941: LD_VAR 0 4
34945: PPUSH
34946: LD_VAR 0 5
34950: PPUSH
34951: LD_VAR 0 8
34955: PUSH
34956: LD_VAR 0 3
34960: ARRAY
34961: PPUSH
34962: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
34966: LD_INT 35
34968: PPUSH
34969: CALL_OW 67
// until not HasTask ( tmp ) ;
34973: LD_VAR 0 7
34977: PPUSH
34978: CALL_OW 314
34982: NOT
34983: IFFALSE 34966
// mc_teleport_exit_set := Add ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
34985: LD_ADDR_EXP 85
34989: PUSH
34990: LD_EXP 85
34994: PPUSH
34995: LD_VAR 0 2
34999: PUSH
35000: LD_EXP 85
35004: PUSH
35005: LD_VAR 0 2
35009: ARRAY
35010: PUSH
35011: LD_INT 1
35013: PLUS
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PPUSH
35019: LD_VAR 0 8
35023: PUSH
35024: LD_VAR 0 3
35028: ARRAY
35029: PPUSH
35030: CALL 50857 0 3
35034: ST_TO_ADDR
// end ;
35035: GO 34693
35037: POP
35038: POP
// MC_Reset ( i , 124 ) ;
35039: LD_VAR 0 2
35043: PPUSH
35044: LD_INT 124
35046: PPUSH
35047: CALL 19344 0 2
// end ; end ;
35051: GO 34448
35053: POP
35054: POP
// end ;
35055: LD_VAR 0 1
35059: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
35060: LD_INT 0
35062: PPUSH
35063: PPUSH
35064: PPUSH
// if not mc_bases then
35065: LD_EXP 49
35069: NOT
35070: IFFALSE 35074
// exit ;
35072: GO 35680
// for i = 1 to mc_bases do
35074: LD_ADDR_VAR 0 2
35078: PUSH
35079: DOUBLE
35080: LD_INT 1
35082: DEC
35083: ST_TO_ADDR
35084: LD_EXP 49
35088: PUSH
35089: FOR_TO
35090: IFFALSE 35678
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
35092: LD_ADDR_VAR 0 3
35096: PUSH
35097: LD_EXP 49
35101: PUSH
35102: LD_VAR 0 2
35106: ARRAY
35107: PPUSH
35108: LD_INT 25
35110: PUSH
35111: LD_INT 4
35113: PUSH
35114: EMPTY
35115: LIST
35116: LIST
35117: PPUSH
35118: CALL_OW 72
35122: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
35123: LD_VAR 0 3
35127: NOT
35128: PUSH
35129: LD_EXP 86
35133: PUSH
35134: LD_VAR 0 2
35138: ARRAY
35139: NOT
35140: OR
35141: PUSH
35142: LD_EXP 49
35146: PUSH
35147: LD_VAR 0 2
35151: ARRAY
35152: PPUSH
35153: LD_INT 2
35155: PUSH
35156: LD_INT 30
35158: PUSH
35159: LD_INT 0
35161: PUSH
35162: EMPTY
35163: LIST
35164: LIST
35165: PUSH
35166: LD_INT 30
35168: PUSH
35169: LD_INT 1
35171: PUSH
35172: EMPTY
35173: LIST
35174: LIST
35175: PUSH
35176: EMPTY
35177: LIST
35178: LIST
35179: LIST
35180: PPUSH
35181: CALL_OW 72
35185: NOT
35186: OR
35187: IFFALSE 35237
// begin if mc_deposits_finder [ i ] then
35189: LD_EXP 87
35193: PUSH
35194: LD_VAR 0 2
35198: ARRAY
35199: IFFALSE 35235
// begin MC_Reset ( i , 125 ) ;
35201: LD_VAR 0 2
35205: PPUSH
35206: LD_INT 125
35208: PPUSH
35209: CALL 19344 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
35213: LD_ADDR_EXP 87
35217: PUSH
35218: LD_EXP 87
35222: PPUSH
35223: LD_VAR 0 2
35227: PPUSH
35228: EMPTY
35229: PPUSH
35230: CALL_OW 1
35234: ST_TO_ADDR
// end ; continue ;
35235: GO 35089
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
35237: LD_EXP 86
35241: PUSH
35242: LD_VAR 0 2
35246: ARRAY
35247: PUSH
35248: LD_INT 1
35250: ARRAY
35251: PUSH
35252: LD_INT 3
35254: ARRAY
35255: PUSH
35256: LD_INT 1
35258: EQUAL
35259: PUSH
35260: LD_INT 20
35262: PPUSH
35263: LD_EXP 75
35267: PUSH
35268: LD_VAR 0 2
35272: ARRAY
35273: PPUSH
35274: CALL_OW 321
35278: PUSH
35279: LD_INT 2
35281: NONEQUAL
35282: AND
35283: IFFALSE 35333
// begin if mc_deposits_finder [ i ] then
35285: LD_EXP 87
35289: PUSH
35290: LD_VAR 0 2
35294: ARRAY
35295: IFFALSE 35331
// begin MC_Reset ( i , 125 ) ;
35297: LD_VAR 0 2
35301: PPUSH
35302: LD_INT 125
35304: PPUSH
35305: CALL 19344 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
35309: LD_ADDR_EXP 87
35313: PUSH
35314: LD_EXP 87
35318: PPUSH
35319: LD_VAR 0 2
35323: PPUSH
35324: EMPTY
35325: PPUSH
35326: CALL_OW 1
35330: ST_TO_ADDR
// end ; continue ;
35331: GO 35089
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
35333: LD_EXP 86
35337: PUSH
35338: LD_VAR 0 2
35342: ARRAY
35343: PUSH
35344: LD_INT 1
35346: ARRAY
35347: PUSH
35348: LD_INT 1
35350: ARRAY
35351: PPUSH
35352: LD_EXP 86
35356: PUSH
35357: LD_VAR 0 2
35361: ARRAY
35362: PUSH
35363: LD_INT 1
35365: ARRAY
35366: PUSH
35367: LD_INT 2
35369: ARRAY
35370: PPUSH
35371: LD_EXP 75
35375: PUSH
35376: LD_VAR 0 2
35380: ARRAY
35381: PPUSH
35382: CALL_OW 440
35386: IFFALSE 35429
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
35388: LD_ADDR_EXP 86
35392: PUSH
35393: LD_EXP 86
35397: PPUSH
35398: LD_VAR 0 2
35402: PPUSH
35403: LD_EXP 86
35407: PUSH
35408: LD_VAR 0 2
35412: ARRAY
35413: PPUSH
35414: LD_INT 1
35416: PPUSH
35417: CALL_OW 3
35421: PPUSH
35422: CALL_OW 1
35426: ST_TO_ADDR
35427: GO 35676
// begin if not mc_deposits_finder [ i ] then
35429: LD_EXP 87
35433: PUSH
35434: LD_VAR 0 2
35438: ARRAY
35439: NOT
35440: IFFALSE 35492
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
35442: LD_ADDR_EXP 87
35446: PUSH
35447: LD_EXP 87
35451: PPUSH
35452: LD_VAR 0 2
35456: PPUSH
35457: LD_VAR 0 3
35461: PUSH
35462: LD_INT 1
35464: ARRAY
35465: PUSH
35466: EMPTY
35467: LIST
35468: PPUSH
35469: CALL_OW 1
35473: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
35474: LD_VAR 0 3
35478: PUSH
35479: LD_INT 1
35481: ARRAY
35482: PPUSH
35483: LD_INT 125
35485: PPUSH
35486: CALL_OW 109
// end else
35490: GO 35676
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
35492: LD_EXP 87
35496: PUSH
35497: LD_VAR 0 2
35501: ARRAY
35502: PUSH
35503: LD_INT 1
35505: ARRAY
35506: PPUSH
35507: CALL_OW 310
35511: IFFALSE 35534
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
35513: LD_EXP 87
35517: PUSH
35518: LD_VAR 0 2
35522: ARRAY
35523: PUSH
35524: LD_INT 1
35526: ARRAY
35527: PPUSH
35528: CALL_OW 122
35532: GO 35676
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
35534: LD_EXP 87
35538: PUSH
35539: LD_VAR 0 2
35543: ARRAY
35544: PUSH
35545: LD_INT 1
35547: ARRAY
35548: PPUSH
35549: CALL_OW 314
35553: NOT
35554: PUSH
35555: LD_EXP 87
35559: PUSH
35560: LD_VAR 0 2
35564: ARRAY
35565: PUSH
35566: LD_INT 1
35568: ARRAY
35569: PPUSH
35570: LD_EXP 86
35574: PUSH
35575: LD_VAR 0 2
35579: ARRAY
35580: PUSH
35581: LD_INT 1
35583: ARRAY
35584: PUSH
35585: LD_INT 1
35587: ARRAY
35588: PPUSH
35589: LD_EXP 86
35593: PUSH
35594: LD_VAR 0 2
35598: ARRAY
35599: PUSH
35600: LD_INT 1
35602: ARRAY
35603: PUSH
35604: LD_INT 2
35606: ARRAY
35607: PPUSH
35608: CALL_OW 297
35612: PUSH
35613: LD_INT 6
35615: GREATER
35616: AND
35617: IFFALSE 35676
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
35619: LD_EXP 87
35623: PUSH
35624: LD_VAR 0 2
35628: ARRAY
35629: PUSH
35630: LD_INT 1
35632: ARRAY
35633: PPUSH
35634: LD_EXP 86
35638: PUSH
35639: LD_VAR 0 2
35643: ARRAY
35644: PUSH
35645: LD_INT 1
35647: ARRAY
35648: PUSH
35649: LD_INT 1
35651: ARRAY
35652: PPUSH
35653: LD_EXP 86
35657: PUSH
35658: LD_VAR 0 2
35662: ARRAY
35663: PUSH
35664: LD_INT 1
35666: ARRAY
35667: PUSH
35668: LD_INT 2
35670: ARRAY
35671: PPUSH
35672: CALL_OW 111
// end ; end ; end ;
35676: GO 35089
35678: POP
35679: POP
// end ;
35680: LD_VAR 0 1
35684: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
35685: LD_INT 0
35687: PPUSH
35688: PPUSH
35689: PPUSH
35690: PPUSH
35691: PPUSH
35692: PPUSH
35693: PPUSH
35694: PPUSH
35695: PPUSH
35696: PPUSH
35697: PPUSH
// if not mc_bases then
35698: LD_EXP 49
35702: NOT
35703: IFFALSE 35707
// exit ;
35705: GO 36431
// for i = 1 to mc_bases do
35707: LD_ADDR_VAR 0 2
35711: PUSH
35712: DOUBLE
35713: LD_INT 1
35715: DEC
35716: ST_TO_ADDR
35717: LD_EXP 49
35721: PUSH
35722: FOR_TO
35723: IFFALSE 36429
// begin if not mc_bases [ i ] then
35725: LD_EXP 49
35729: PUSH
35730: LD_VAR 0 2
35734: ARRAY
35735: NOT
35736: IFFALSE 35740
// continue ;
35738: GO 35722
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
35740: LD_ADDR_VAR 0 7
35744: PUSH
35745: LD_EXP 49
35749: PUSH
35750: LD_VAR 0 2
35754: ARRAY
35755: PUSH
35756: LD_INT 1
35758: ARRAY
35759: PPUSH
35760: CALL_OW 248
35764: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
35765: LD_VAR 0 7
35769: PUSH
35770: LD_INT 3
35772: EQUAL
35773: PUSH
35774: LD_EXP 68
35778: PUSH
35779: LD_VAR 0 2
35783: ARRAY
35784: PUSH
35785: LD_EXP 71
35789: PUSH
35790: LD_VAR 0 2
35794: ARRAY
35795: UNION
35796: PPUSH
35797: LD_INT 33
35799: PUSH
35800: LD_INT 2
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: PPUSH
35807: CALL_OW 72
35811: NOT
35812: OR
35813: IFFALSE 35817
// continue ;
35815: GO 35722
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
35817: LD_ADDR_VAR 0 9
35821: PUSH
35822: LD_EXP 49
35826: PUSH
35827: LD_VAR 0 2
35831: ARRAY
35832: PPUSH
35833: LD_INT 30
35835: PUSH
35836: LD_INT 36
35838: PUSH
35839: EMPTY
35840: LIST
35841: LIST
35842: PPUSH
35843: CALL_OW 72
35847: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
35848: LD_ADDR_VAR 0 10
35852: PUSH
35853: LD_EXP 68
35857: PUSH
35858: LD_VAR 0 2
35862: ARRAY
35863: PPUSH
35864: LD_INT 34
35866: PUSH
35867: LD_INT 31
35869: PUSH
35870: EMPTY
35871: LIST
35872: LIST
35873: PPUSH
35874: CALL_OW 72
35878: ST_TO_ADDR
// if not cts and not mcts then
35879: LD_VAR 0 9
35883: NOT
35884: PUSH
35885: LD_VAR 0 10
35889: NOT
35890: AND
35891: IFFALSE 35895
// continue ;
35893: GO 35722
// x := cts ;
35895: LD_ADDR_VAR 0 11
35899: PUSH
35900: LD_VAR 0 9
35904: ST_TO_ADDR
// if not x then
35905: LD_VAR 0 11
35909: NOT
35910: IFFALSE 35922
// x := mcts ;
35912: LD_ADDR_VAR 0 11
35916: PUSH
35917: LD_VAR 0 10
35921: ST_TO_ADDR
// if mc_remote_driver [ i ] then
35922: LD_EXP 89
35926: PUSH
35927: LD_VAR 0 2
35931: ARRAY
35932: IFFALSE 36201
// for j in mc_remote_driver [ i ] do
35934: LD_ADDR_VAR 0 3
35938: PUSH
35939: LD_EXP 89
35943: PUSH
35944: LD_VAR 0 2
35948: ARRAY
35949: PUSH
35950: FOR_IN
35951: IFFALSE 36199
// begin if GetClass ( j ) <> 3 then
35953: LD_VAR 0 3
35957: PPUSH
35958: CALL_OW 257
35962: PUSH
35963: LD_INT 3
35965: NONEQUAL
35966: IFFALSE 36019
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
35968: LD_ADDR_EXP 89
35972: PUSH
35973: LD_EXP 89
35977: PPUSH
35978: LD_VAR 0 2
35982: PPUSH
35983: LD_EXP 89
35987: PUSH
35988: LD_VAR 0 2
35992: ARRAY
35993: PUSH
35994: LD_VAR 0 3
35998: DIFF
35999: PPUSH
36000: CALL_OW 1
36004: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36005: LD_VAR 0 3
36009: PPUSH
36010: LD_INT 0
36012: PPUSH
36013: CALL_OW 109
// continue ;
36017: GO 35950
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
36019: LD_VAR 0 3
36023: PPUSH
36024: CALL_OW 310
36028: NOT
36029: PUSH
36030: LD_VAR 0 3
36034: PPUSH
36035: CALL_OW 310
36039: PPUSH
36040: CALL_OW 266
36044: PUSH
36045: LD_INT 36
36047: NONEQUAL
36048: PUSH
36049: LD_VAR 0 3
36053: PPUSH
36054: CALL 83525 0 1
36058: NOT
36059: AND
36060: OR
36061: IFFALSE 36197
// begin if IsInUnit ( j ) then
36063: LD_VAR 0 3
36067: PPUSH
36068: CALL_OW 310
36072: IFFALSE 36083
// ComExitBuilding ( j ) ;
36074: LD_VAR 0 3
36078: PPUSH
36079: CALL_OW 122
// ct := 0 ;
36083: LD_ADDR_VAR 0 8
36087: PUSH
36088: LD_INT 0
36090: ST_TO_ADDR
// for k in x do
36091: LD_ADDR_VAR 0 4
36095: PUSH
36096: LD_VAR 0 11
36100: PUSH
36101: FOR_IN
36102: IFFALSE 36175
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
36104: LD_VAR 0 4
36108: PPUSH
36109: CALL_OW 264
36113: PUSH
36114: LD_INT 31
36116: EQUAL
36117: PUSH
36118: LD_VAR 0 4
36122: PPUSH
36123: CALL_OW 311
36127: NOT
36128: AND
36129: PUSH
36130: LD_VAR 0 4
36134: PPUSH
36135: CALL_OW 266
36139: PUSH
36140: LD_INT 36
36142: EQUAL
36143: PUSH
36144: LD_VAR 0 4
36148: PPUSH
36149: CALL_OW 313
36153: PUSH
36154: LD_INT 3
36156: LESS
36157: AND
36158: OR
36159: IFFALSE 36173
// begin ct := k ;
36161: LD_ADDR_VAR 0 8
36165: PUSH
36166: LD_VAR 0 4
36170: ST_TO_ADDR
// break ;
36171: GO 36175
// end ;
36173: GO 36101
36175: POP
36176: POP
// if ct then
36177: LD_VAR 0 8
36181: IFFALSE 36197
// ComEnterUnit ( j , ct ) ;
36183: LD_VAR 0 3
36187: PPUSH
36188: LD_VAR 0 8
36192: PPUSH
36193: CALL_OW 120
// end ; end ;
36197: GO 35950
36199: POP
36200: POP
// places := 0 ;
36201: LD_ADDR_VAR 0 5
36205: PUSH
36206: LD_INT 0
36208: ST_TO_ADDR
// for j = 1 to x do
36209: LD_ADDR_VAR 0 3
36213: PUSH
36214: DOUBLE
36215: LD_INT 1
36217: DEC
36218: ST_TO_ADDR
36219: LD_VAR 0 11
36223: PUSH
36224: FOR_TO
36225: IFFALSE 36280
// if GetWeapon ( x [ j ] ) = ar_control_tower then
36227: LD_VAR 0 11
36231: PUSH
36232: LD_VAR 0 3
36236: ARRAY
36237: PPUSH
36238: CALL_OW 264
36242: PUSH
36243: LD_INT 31
36245: EQUAL
36246: IFFALSE 36264
// places := places + 1 else
36248: LD_ADDR_VAR 0 5
36252: PUSH
36253: LD_VAR 0 5
36257: PUSH
36258: LD_INT 1
36260: PLUS
36261: ST_TO_ADDR
36262: GO 36278
// places := places + 3 ;
36264: LD_ADDR_VAR 0 5
36268: PUSH
36269: LD_VAR 0 5
36273: PUSH
36274: LD_INT 3
36276: PLUS
36277: ST_TO_ADDR
36278: GO 36224
36280: POP
36281: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
36282: LD_ADDR_VAR 0 6
36286: PUSH
36287: LD_EXP 49
36291: PUSH
36292: LD_VAR 0 2
36296: ARRAY
36297: PPUSH
36298: LD_INT 25
36300: PUSH
36301: LD_INT 3
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PPUSH
36308: CALL_OW 72
36312: PUSH
36313: LD_EXP 89
36317: PUSH
36318: LD_VAR 0 2
36322: ARRAY
36323: DIFF
36324: PPUSH
36325: LD_INT 3
36327: PPUSH
36328: CALL 84425 0 2
36332: ST_TO_ADDR
// if not tmp then
36333: LD_VAR 0 6
36337: NOT
36338: IFFALSE 36342
// continue ;
36340: GO 35722
// places := places - mc_remote_driver [ i ] ;
36342: LD_ADDR_VAR 0 5
36346: PUSH
36347: LD_VAR 0 5
36351: PUSH
36352: LD_EXP 89
36356: PUSH
36357: LD_VAR 0 2
36361: ARRAY
36362: MINUS
36363: ST_TO_ADDR
// if places then
36364: LD_VAR 0 5
36368: IFFALSE 36427
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
36370: LD_ADDR_EXP 89
36374: PUSH
36375: LD_EXP 89
36379: PPUSH
36380: LD_VAR 0 2
36384: PPUSH
36385: LD_EXP 89
36389: PUSH
36390: LD_VAR 0 2
36394: ARRAY
36395: PUSH
36396: LD_VAR 0 6
36400: PUSH
36401: LD_INT 1
36403: ARRAY
36404: UNION
36405: PPUSH
36406: CALL_OW 1
36410: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
36411: LD_VAR 0 6
36415: PUSH
36416: LD_INT 1
36418: ARRAY
36419: PPUSH
36420: LD_INT 126
36422: PPUSH
36423: CALL_OW 109
// end ; end ;
36427: GO 35722
36429: POP
36430: POP
// end ;
36431: LD_VAR 0 1
36435: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
36436: LD_INT 0
36438: PPUSH
36439: PPUSH
36440: PPUSH
36441: PPUSH
36442: PPUSH
36443: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
36444: LD_VAR 0 1
36448: NOT
36449: PUSH
36450: LD_VAR 0 2
36454: NOT
36455: OR
36456: PUSH
36457: LD_VAR 0 3
36461: NOT
36462: OR
36463: PUSH
36464: LD_VAR 0 4
36468: PUSH
36469: LD_INT 1
36471: PUSH
36472: LD_INT 2
36474: PUSH
36475: LD_INT 3
36477: PUSH
36478: LD_INT 4
36480: PUSH
36481: LD_INT 5
36483: PUSH
36484: LD_INT 8
36486: PUSH
36487: LD_INT 9
36489: PUSH
36490: LD_INT 15
36492: PUSH
36493: LD_INT 16
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: LIST
36500: LIST
36501: LIST
36502: LIST
36503: LIST
36504: LIST
36505: LIST
36506: IN
36507: NOT
36508: OR
36509: IFFALSE 36513
// exit ;
36511: GO 37413
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
36513: LD_ADDR_VAR 0 2
36517: PUSH
36518: LD_VAR 0 2
36522: PPUSH
36523: LD_INT 21
36525: PUSH
36526: LD_INT 3
36528: PUSH
36529: EMPTY
36530: LIST
36531: LIST
36532: PUSH
36533: LD_INT 24
36535: PUSH
36536: LD_INT 250
36538: PUSH
36539: EMPTY
36540: LIST
36541: LIST
36542: PUSH
36543: EMPTY
36544: LIST
36545: LIST
36546: PPUSH
36547: CALL_OW 72
36551: ST_TO_ADDR
// case class of 1 , 15 :
36552: LD_VAR 0 4
36556: PUSH
36557: LD_INT 1
36559: DOUBLE
36560: EQUAL
36561: IFTRUE 36571
36563: LD_INT 15
36565: DOUBLE
36566: EQUAL
36567: IFTRUE 36571
36569: GO 36656
36571: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
36572: LD_ADDR_VAR 0 8
36576: PUSH
36577: LD_VAR 0 2
36581: PPUSH
36582: LD_INT 2
36584: PUSH
36585: LD_INT 30
36587: PUSH
36588: LD_INT 32
36590: PUSH
36591: EMPTY
36592: LIST
36593: LIST
36594: PUSH
36595: LD_INT 30
36597: PUSH
36598: LD_INT 31
36600: PUSH
36601: EMPTY
36602: LIST
36603: LIST
36604: PUSH
36605: EMPTY
36606: LIST
36607: LIST
36608: LIST
36609: PPUSH
36610: CALL_OW 72
36614: PUSH
36615: LD_VAR 0 2
36619: PPUSH
36620: LD_INT 2
36622: PUSH
36623: LD_INT 30
36625: PUSH
36626: LD_INT 4
36628: PUSH
36629: EMPTY
36630: LIST
36631: LIST
36632: PUSH
36633: LD_INT 30
36635: PUSH
36636: LD_INT 5
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: LIST
36647: PPUSH
36648: CALL_OW 72
36652: ADD
36653: ST_TO_ADDR
36654: GO 36902
36656: LD_INT 2
36658: DOUBLE
36659: EQUAL
36660: IFTRUE 36670
36662: LD_INT 16
36664: DOUBLE
36665: EQUAL
36666: IFTRUE 36670
36668: GO 36716
36670: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
36671: LD_ADDR_VAR 0 8
36675: PUSH
36676: LD_VAR 0 2
36680: PPUSH
36681: LD_INT 2
36683: PUSH
36684: LD_INT 30
36686: PUSH
36687: LD_INT 0
36689: PUSH
36690: EMPTY
36691: LIST
36692: LIST
36693: PUSH
36694: LD_INT 30
36696: PUSH
36697: LD_INT 1
36699: PUSH
36700: EMPTY
36701: LIST
36702: LIST
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: LIST
36708: PPUSH
36709: CALL_OW 72
36713: ST_TO_ADDR
36714: GO 36902
36716: LD_INT 3
36718: DOUBLE
36719: EQUAL
36720: IFTRUE 36724
36722: GO 36770
36724: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
36725: LD_ADDR_VAR 0 8
36729: PUSH
36730: LD_VAR 0 2
36734: PPUSH
36735: LD_INT 2
36737: PUSH
36738: LD_INT 30
36740: PUSH
36741: LD_INT 2
36743: PUSH
36744: EMPTY
36745: LIST
36746: LIST
36747: PUSH
36748: LD_INT 30
36750: PUSH
36751: LD_INT 3
36753: PUSH
36754: EMPTY
36755: LIST
36756: LIST
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: LIST
36762: PPUSH
36763: CALL_OW 72
36767: ST_TO_ADDR
36768: GO 36902
36770: LD_INT 4
36772: DOUBLE
36773: EQUAL
36774: IFTRUE 36778
36776: GO 36835
36778: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
36779: LD_ADDR_VAR 0 8
36783: PUSH
36784: LD_VAR 0 2
36788: PPUSH
36789: LD_INT 2
36791: PUSH
36792: LD_INT 30
36794: PUSH
36795: LD_INT 6
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: LD_INT 30
36804: PUSH
36805: LD_INT 7
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PUSH
36812: LD_INT 30
36814: PUSH
36815: LD_INT 8
36817: PUSH
36818: EMPTY
36819: LIST
36820: LIST
36821: PUSH
36822: EMPTY
36823: LIST
36824: LIST
36825: LIST
36826: LIST
36827: PPUSH
36828: CALL_OW 72
36832: ST_TO_ADDR
36833: GO 36902
36835: LD_INT 5
36837: DOUBLE
36838: EQUAL
36839: IFTRUE 36855
36841: LD_INT 8
36843: DOUBLE
36844: EQUAL
36845: IFTRUE 36855
36847: LD_INT 9
36849: DOUBLE
36850: EQUAL
36851: IFTRUE 36855
36853: GO 36901
36855: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
36856: LD_ADDR_VAR 0 8
36860: PUSH
36861: LD_VAR 0 2
36865: PPUSH
36866: LD_INT 2
36868: PUSH
36869: LD_INT 30
36871: PUSH
36872: LD_INT 4
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: PUSH
36879: LD_INT 30
36881: PUSH
36882: LD_INT 5
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: EMPTY
36890: LIST
36891: LIST
36892: LIST
36893: PPUSH
36894: CALL_OW 72
36898: ST_TO_ADDR
36899: GO 36902
36901: POP
// if not tmp then
36902: LD_VAR 0 8
36906: NOT
36907: IFFALSE 36911
// exit ;
36909: GO 37413
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
36911: LD_VAR 0 4
36915: PUSH
36916: LD_INT 1
36918: PUSH
36919: LD_INT 15
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: IN
36926: PUSH
36927: LD_EXP 58
36931: PUSH
36932: LD_VAR 0 1
36936: ARRAY
36937: AND
36938: IFFALSE 37094
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
36940: LD_ADDR_VAR 0 9
36944: PUSH
36945: LD_EXP 58
36949: PUSH
36950: LD_VAR 0 1
36954: ARRAY
36955: PUSH
36956: LD_INT 1
36958: ARRAY
36959: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
36960: LD_VAR 0 9
36964: PUSH
36965: LD_EXP 59
36969: PUSH
36970: LD_VAR 0 1
36974: ARRAY
36975: IN
36976: NOT
36977: IFFALSE 37092
// begin mc_busy_turret_list := Add ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
36979: LD_ADDR_EXP 59
36983: PUSH
36984: LD_EXP 59
36988: PPUSH
36989: LD_VAR 0 1
36993: PUSH
36994: LD_EXP 59
36998: PUSH
36999: LD_VAR 0 1
37003: ARRAY
37004: PUSH
37005: LD_INT 1
37007: PLUS
37008: PUSH
37009: EMPTY
37010: LIST
37011: LIST
37012: PPUSH
37013: LD_VAR 0 9
37017: PPUSH
37018: CALL 50857 0 3
37022: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
37023: LD_ADDR_EXP 58
37027: PUSH
37028: LD_EXP 58
37032: PPUSH
37033: LD_VAR 0 1
37037: PPUSH
37038: LD_EXP 58
37042: PUSH
37043: LD_VAR 0 1
37047: ARRAY
37048: PUSH
37049: LD_VAR 0 9
37053: DIFF
37054: PPUSH
37055: CALL_OW 1
37059: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
37060: LD_VAR 0 3
37064: PPUSH
37065: LD_EXP 59
37069: PUSH
37070: LD_VAR 0 1
37074: ARRAY
37075: PUSH
37076: LD_EXP 59
37080: PUSH
37081: LD_VAR 0 1
37085: ARRAY
37086: ARRAY
37087: PPUSH
37088: CALL_OW 120
// end ; exit ;
37092: GO 37413
// end ; if tmp > 1 then
37094: LD_VAR 0 8
37098: PUSH
37099: LD_INT 1
37101: GREATER
37102: IFFALSE 37206
// for i = 2 to tmp do
37104: LD_ADDR_VAR 0 6
37108: PUSH
37109: DOUBLE
37110: LD_INT 2
37112: DEC
37113: ST_TO_ADDR
37114: LD_VAR 0 8
37118: PUSH
37119: FOR_TO
37120: IFFALSE 37204
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
37122: LD_VAR 0 8
37126: PUSH
37127: LD_VAR 0 6
37131: ARRAY
37132: PPUSH
37133: CALL_OW 461
37137: PUSH
37138: LD_INT 6
37140: EQUAL
37141: IFFALSE 37202
// begin x := tmp [ i ] ;
37143: LD_ADDR_VAR 0 9
37147: PUSH
37148: LD_VAR 0 8
37152: PUSH
37153: LD_VAR 0 6
37157: ARRAY
37158: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
37159: LD_ADDR_VAR 0 8
37163: PUSH
37164: LD_VAR 0 8
37168: PPUSH
37169: LD_VAR 0 6
37173: PPUSH
37174: CALL_OW 3
37178: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
37179: LD_ADDR_VAR 0 8
37183: PUSH
37184: LD_VAR 0 8
37188: PPUSH
37189: LD_INT 1
37191: PPUSH
37192: LD_VAR 0 9
37196: PPUSH
37197: CALL_OW 2
37201: ST_TO_ADDR
// end ;
37202: GO 37119
37204: POP
37205: POP
// for i in tmp do
37206: LD_ADDR_VAR 0 6
37210: PUSH
37211: LD_VAR 0 8
37215: PUSH
37216: FOR_IN
37217: IFFALSE 37286
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
37219: LD_VAR 0 6
37223: PPUSH
37224: CALL_OW 313
37228: PUSH
37229: LD_INT 6
37231: LESS
37232: PUSH
37233: LD_VAR 0 6
37237: PPUSH
37238: CALL_OW 266
37242: PUSH
37243: LD_INT 31
37245: PUSH
37246: LD_INT 32
37248: PUSH
37249: EMPTY
37250: LIST
37251: LIST
37252: IN
37253: NOT
37254: AND
37255: PUSH
37256: LD_VAR 0 6
37260: PPUSH
37261: CALL_OW 313
37265: PUSH
37266: LD_INT 0
37268: EQUAL
37269: OR
37270: IFFALSE 37284
// begin j := i ;
37272: LD_ADDR_VAR 0 7
37276: PUSH
37277: LD_VAR 0 6
37281: ST_TO_ADDR
// break ;
37282: GO 37286
// end ; end ;
37284: GO 37216
37286: POP
37287: POP
// if j then
37288: LD_VAR 0 7
37292: IFFALSE 37310
// ComEnterUnit ( unit , j ) else
37294: LD_VAR 0 3
37298: PPUSH
37299: LD_VAR 0 7
37303: PPUSH
37304: CALL_OW 120
37308: GO 37413
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37310: LD_ADDR_VAR 0 10
37314: PUSH
37315: LD_VAR 0 2
37319: PPUSH
37320: LD_INT 2
37322: PUSH
37323: LD_INT 30
37325: PUSH
37326: LD_INT 0
37328: PUSH
37329: EMPTY
37330: LIST
37331: LIST
37332: PUSH
37333: LD_INT 30
37335: PUSH
37336: LD_INT 1
37338: PUSH
37339: EMPTY
37340: LIST
37341: LIST
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: LIST
37347: PPUSH
37348: CALL_OW 72
37352: ST_TO_ADDR
// if depot then
37353: LD_VAR 0 10
37357: IFFALSE 37413
// begin depot := NearestUnitToUnit ( depot , unit ) ;
37359: LD_ADDR_VAR 0 10
37363: PUSH
37364: LD_VAR 0 10
37368: PPUSH
37369: LD_VAR 0 3
37373: PPUSH
37374: CALL_OW 74
37378: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
37379: LD_VAR 0 3
37383: PPUSH
37384: LD_VAR 0 10
37388: PPUSH
37389: CALL_OW 296
37393: PUSH
37394: LD_INT 10
37396: GREATER
37397: IFFALSE 37413
// ComStandNearbyBuilding ( unit , depot ) ;
37399: LD_VAR 0 3
37403: PPUSH
37404: LD_VAR 0 10
37408: PPUSH
37409: CALL 45099 0 2
// end ; end ; end ;
37413: LD_VAR 0 5
37417: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
37418: LD_INT 0
37420: PPUSH
37421: PPUSH
37422: PPUSH
37423: PPUSH
// if not mc_bases then
37424: LD_EXP 49
37428: NOT
37429: IFFALSE 37433
// exit ;
37431: GO 37672
// for i = 1 to mc_bases do
37433: LD_ADDR_VAR 0 2
37437: PUSH
37438: DOUBLE
37439: LD_INT 1
37441: DEC
37442: ST_TO_ADDR
37443: LD_EXP 49
37447: PUSH
37448: FOR_TO
37449: IFFALSE 37670
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
37451: LD_ADDR_VAR 0 4
37455: PUSH
37456: LD_EXP 49
37460: PUSH
37461: LD_VAR 0 2
37465: ARRAY
37466: PPUSH
37467: LD_INT 21
37469: PUSH
37470: LD_INT 1
37472: PUSH
37473: EMPTY
37474: LIST
37475: LIST
37476: PPUSH
37477: CALL_OW 72
37481: PUSH
37482: LD_EXP 78
37486: PUSH
37487: LD_VAR 0 2
37491: ARRAY
37492: UNION
37493: ST_TO_ADDR
// if not tmp then
37494: LD_VAR 0 4
37498: NOT
37499: IFFALSE 37503
// continue ;
37501: GO 37448
// for j in tmp do
37503: LD_ADDR_VAR 0 3
37507: PUSH
37508: LD_VAR 0 4
37512: PUSH
37513: FOR_IN
37514: IFFALSE 37666
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
37516: LD_VAR 0 3
37520: PPUSH
37521: CALL_OW 110
37525: NOT
37526: PUSH
37527: LD_VAR 0 3
37531: PPUSH
37532: CALL_OW 314
37536: NOT
37537: AND
37538: PUSH
37539: LD_VAR 0 3
37543: PPUSH
37544: CALL_OW 311
37548: NOT
37549: AND
37550: PUSH
37551: LD_VAR 0 3
37555: PPUSH
37556: CALL_OW 310
37560: NOT
37561: AND
37562: PUSH
37563: LD_VAR 0 3
37567: PUSH
37568: LD_EXP 52
37572: PUSH
37573: LD_VAR 0 2
37577: ARRAY
37578: PUSH
37579: LD_INT 1
37581: ARRAY
37582: IN
37583: NOT
37584: AND
37585: PUSH
37586: LD_VAR 0 3
37590: PUSH
37591: LD_EXP 52
37595: PUSH
37596: LD_VAR 0 2
37600: ARRAY
37601: PUSH
37602: LD_INT 2
37604: ARRAY
37605: IN
37606: NOT
37607: AND
37608: PUSH
37609: LD_VAR 0 3
37613: PUSH
37614: LD_EXP 61
37618: PUSH
37619: LD_VAR 0 2
37623: ARRAY
37624: IN
37625: NOT
37626: AND
37627: IFFALSE 37664
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
37629: LD_VAR 0 2
37633: PPUSH
37634: LD_EXP 49
37638: PUSH
37639: LD_VAR 0 2
37643: ARRAY
37644: PPUSH
37645: LD_VAR 0 3
37649: PPUSH
37650: LD_VAR 0 3
37654: PPUSH
37655: CALL_OW 257
37659: PPUSH
37660: CALL 36436 0 4
// end ;
37664: GO 37513
37666: POP
37667: POP
// end ;
37668: GO 37448
37670: POP
37671: POP
// end ;
37672: LD_VAR 0 1
37676: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
37677: LD_INT 0
37679: PPUSH
37680: PPUSH
37681: PPUSH
37682: PPUSH
37683: PPUSH
37684: PPUSH
// if not mc_bases [ base ] then
37685: LD_EXP 49
37689: PUSH
37690: LD_VAR 0 1
37694: ARRAY
37695: NOT
37696: IFFALSE 37700
// exit ;
37698: GO 37882
// tmp := [ ] ;
37700: LD_ADDR_VAR 0 6
37704: PUSH
37705: EMPTY
37706: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
37707: LD_ADDR_VAR 0 7
37711: PUSH
37712: LD_VAR 0 3
37716: PPUSH
37717: LD_INT 0
37719: PPUSH
37720: CALL_OW 517
37724: ST_TO_ADDR
// if not list then
37725: LD_VAR 0 7
37729: NOT
37730: IFFALSE 37734
// exit ;
37732: GO 37882
// for i = 1 to amount do
37734: LD_ADDR_VAR 0 5
37738: PUSH
37739: DOUBLE
37740: LD_INT 1
37742: DEC
37743: ST_TO_ADDR
37744: LD_VAR 0 2
37748: PUSH
37749: FOR_TO
37750: IFFALSE 37830
// begin x := rand ( 1 , list [ 1 ] ) ;
37752: LD_ADDR_VAR 0 8
37756: PUSH
37757: LD_INT 1
37759: PPUSH
37760: LD_VAR 0 7
37764: PUSH
37765: LD_INT 1
37767: ARRAY
37768: PPUSH
37769: CALL_OW 12
37773: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
37774: LD_ADDR_VAR 0 6
37778: PUSH
37779: LD_VAR 0 6
37783: PPUSH
37784: LD_VAR 0 5
37788: PPUSH
37789: LD_VAR 0 7
37793: PUSH
37794: LD_INT 1
37796: ARRAY
37797: PUSH
37798: LD_VAR 0 8
37802: ARRAY
37803: PUSH
37804: LD_VAR 0 7
37808: PUSH
37809: LD_INT 2
37811: ARRAY
37812: PUSH
37813: LD_VAR 0 8
37817: ARRAY
37818: PUSH
37819: EMPTY
37820: LIST
37821: LIST
37822: PPUSH
37823: CALL_OW 1
37827: ST_TO_ADDR
// end ;
37828: GO 37749
37830: POP
37831: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
37832: LD_ADDR_EXP 62
37836: PUSH
37837: LD_EXP 62
37841: PPUSH
37842: LD_VAR 0 1
37846: PPUSH
37847: LD_VAR 0 6
37851: PPUSH
37852: CALL_OW 1
37856: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
37857: LD_ADDR_EXP 64
37861: PUSH
37862: LD_EXP 64
37866: PPUSH
37867: LD_VAR 0 1
37871: PPUSH
37872: LD_VAR 0 3
37876: PPUSH
37877: CALL_OW 1
37881: ST_TO_ADDR
// end ;
37882: LD_VAR 0 4
37886: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
37887: LD_INT 0
37889: PPUSH
// if not mc_bases [ base ] then
37890: LD_EXP 49
37894: PUSH
37895: LD_VAR 0 1
37899: ARRAY
37900: NOT
37901: IFFALSE 37905
// exit ;
37903: GO 37930
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
37905: LD_ADDR_EXP 54
37909: PUSH
37910: LD_EXP 54
37914: PPUSH
37915: LD_VAR 0 1
37919: PPUSH
37920: LD_VAR 0 2
37924: PPUSH
37925: CALL_OW 1
37929: ST_TO_ADDR
// end ;
37930: LD_VAR 0 3
37934: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
37935: LD_INT 0
37937: PPUSH
// if not mc_bases [ base ] then
37938: LD_EXP 49
37942: PUSH
37943: LD_VAR 0 1
37947: ARRAY
37948: NOT
37949: IFFALSE 37953
// exit ;
37951: GO 37990
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
37953: LD_ADDR_EXP 54
37957: PUSH
37958: LD_EXP 54
37962: PPUSH
37963: LD_VAR 0 1
37967: PPUSH
37968: LD_EXP 54
37972: PUSH
37973: LD_VAR 0 1
37977: ARRAY
37978: PUSH
37979: LD_VAR 0 2
37983: UNION
37984: PPUSH
37985: CALL_OW 1
37989: ST_TO_ADDR
// end ;
37990: LD_VAR 0 3
37994: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
37995: LD_INT 0
37997: PPUSH
// if not mc_bases [ base ] then
37998: LD_EXP 49
38002: PUSH
38003: LD_VAR 0 1
38007: ARRAY
38008: NOT
38009: IFFALSE 38013
// exit ;
38011: GO 38038
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
38013: LD_ADDR_EXP 70
38017: PUSH
38018: LD_EXP 70
38022: PPUSH
38023: LD_VAR 0 1
38027: PPUSH
38028: LD_VAR 0 2
38032: PPUSH
38033: CALL_OW 1
38037: ST_TO_ADDR
// end ;
38038: LD_VAR 0 3
38042: RET
// export function MC_InsertProduceList ( base , compontents ) ; begin
38043: LD_INT 0
38045: PPUSH
// if not mc_bases [ base ] then
38046: LD_EXP 49
38050: PUSH
38051: LD_VAR 0 1
38055: ARRAY
38056: NOT
38057: IFFALSE 38061
// exit ;
38059: GO 38098
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] union compontents ) ;
38061: LD_ADDR_EXP 70
38065: PUSH
38066: LD_EXP 70
38070: PPUSH
38071: LD_VAR 0 1
38075: PPUSH
38076: LD_EXP 70
38080: PUSH
38081: LD_VAR 0 1
38085: ARRAY
38086: PUSH
38087: LD_VAR 0 2
38091: UNION
38092: PPUSH
38093: CALL_OW 1
38097: ST_TO_ADDR
// end ;
38098: LD_VAR 0 3
38102: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
38103: LD_INT 0
38105: PPUSH
// if not mc_bases [ base ] then
38106: LD_EXP 49
38110: PUSH
38111: LD_VAR 0 1
38115: ARRAY
38116: NOT
38117: IFFALSE 38121
// exit ;
38119: GO 38233
// mc_defender := Replace ( mc_defender , base , deflist ) ;
38121: LD_ADDR_EXP 71
38125: PUSH
38126: LD_EXP 71
38130: PPUSH
38131: LD_VAR 0 1
38135: PPUSH
38136: LD_VAR 0 2
38140: PPUSH
38141: CALL_OW 1
38145: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
38146: LD_ADDR_EXP 60
38150: PUSH
38151: LD_EXP 60
38155: PPUSH
38156: LD_VAR 0 1
38160: PPUSH
38161: LD_VAR 0 2
38165: PUSH
38166: LD_INT 0
38168: PLUS
38169: PPUSH
38170: CALL_OW 1
38174: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] union UnitFilter ( mc_defender [ base ] , [ f_type , unit_vehicle ] ) ) ;
38175: LD_ADDR_EXP 68
38179: PUSH
38180: LD_EXP 68
38184: PPUSH
38185: LD_VAR 0 1
38189: PPUSH
38190: LD_EXP 68
38194: PUSH
38195: LD_VAR 0 1
38199: ARRAY
38200: PUSH
38201: LD_EXP 71
38205: PUSH
38206: LD_VAR 0 1
38210: ARRAY
38211: PPUSH
38212: LD_INT 21
38214: PUSH
38215: LD_INT 2
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PPUSH
38222: CALL_OW 72
38226: UNION
38227: PPUSH
38228: CALL_OW 1
38232: ST_TO_ADDR
// end ;
38233: LD_VAR 0 3
38237: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
38238: LD_INT 0
38240: PPUSH
// if not mc_bases [ base ] then
38241: LD_EXP 49
38245: PUSH
38246: LD_VAR 0 1
38250: ARRAY
38251: NOT
38252: IFFALSE 38256
// exit ;
38254: GO 38281
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
38256: LD_ADDR_EXP 60
38260: PUSH
38261: LD_EXP 60
38265: PPUSH
38266: LD_VAR 0 1
38270: PPUSH
38271: LD_VAR 0 2
38275: PPUSH
38276: CALL_OW 1
38280: ST_TO_ADDR
// end ;
38281: LD_VAR 0 3
38285: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
38286: LD_INT 0
38288: PPUSH
38289: PPUSH
38290: PPUSH
38291: PPUSH
// if not mc_bases [ base ] then
38292: LD_EXP 49
38296: PUSH
38297: LD_VAR 0 1
38301: ARRAY
38302: NOT
38303: IFFALSE 38307
// exit ;
38305: GO 38372
// mc_attack := Add ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
38307: LD_ADDR_EXP 69
38311: PUSH
38312: LD_EXP 69
38316: PPUSH
38317: LD_VAR 0 1
38321: PUSH
38322: LD_EXP 69
38326: PUSH
38327: LD_VAR 0 1
38331: ARRAY
38332: PUSH
38333: LD_INT 1
38335: PLUS
38336: PUSH
38337: EMPTY
38338: LIST
38339: LIST
38340: PPUSH
38341: LD_VAR 0 1
38345: PUSH
38346: LD_VAR 0 2
38350: PUSH
38351: LD_VAR 0 3
38355: PUSH
38356: LD_VAR 0 4
38360: PUSH
38361: EMPTY
38362: LIST
38363: LIST
38364: LIST
38365: LIST
38366: PPUSH
38367: CALL 50857 0 3
38371: ST_TO_ADDR
// end ;
38372: LD_VAR 0 5
38376: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
38377: LD_INT 0
38379: PPUSH
// if not mc_bases [ base ] then
38380: LD_EXP 49
38384: PUSH
38385: LD_VAR 0 1
38389: ARRAY
38390: NOT
38391: IFFALSE 38395
// exit ;
38393: GO 38420
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
38395: LD_ADDR_EXP 86
38399: PUSH
38400: LD_EXP 86
38404: PPUSH
38405: LD_VAR 0 1
38409: PPUSH
38410: LD_VAR 0 2
38414: PPUSH
38415: CALL_OW 1
38419: ST_TO_ADDR
// end ;
38420: LD_VAR 0 3
38424: RET
// export function MC_GetMinesField ( base ) ; begin
38425: LD_INT 0
38427: PPUSH
// result := mc_mines [ base ] ;
38428: LD_ADDR_VAR 0 2
38432: PUSH
38433: LD_EXP 62
38437: PUSH
38438: LD_VAR 0 1
38442: ARRAY
38443: ST_TO_ADDR
// end ;
38444: LD_VAR 0 2
38448: RET
// export function MC_GetProduceList ( base ) ; begin
38449: LD_INT 0
38451: PPUSH
// result := mc_produce [ base ] ;
38452: LD_ADDR_VAR 0 2
38456: PUSH
38457: LD_EXP 70
38461: PUSH
38462: LD_VAR 0 1
38466: ARRAY
38467: ST_TO_ADDR
// end ;
38468: LD_VAR 0 2
38472: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
38473: LD_INT 0
38475: PPUSH
38476: PPUSH
// if not mc_bases then
38477: LD_EXP 49
38481: NOT
38482: IFFALSE 38486
// exit ;
38484: GO 38551
// if mc_bases [ base ] then
38486: LD_EXP 49
38490: PUSH
38491: LD_VAR 0 1
38495: ARRAY
38496: IFFALSE 38551
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
38498: LD_ADDR_VAR 0 3
38502: PUSH
38503: LD_EXP 49
38507: PUSH
38508: LD_VAR 0 1
38512: ARRAY
38513: PPUSH
38514: LD_INT 30
38516: PUSH
38517: LD_VAR 0 2
38521: PUSH
38522: EMPTY
38523: LIST
38524: LIST
38525: PPUSH
38526: CALL_OW 72
38530: ST_TO_ADDR
// if result then
38531: LD_VAR 0 3
38535: IFFALSE 38551
// result := result [ 1 ] ;
38537: LD_ADDR_VAR 0 3
38541: PUSH
38542: LD_VAR 0 3
38546: PUSH
38547: LD_INT 1
38549: ARRAY
38550: ST_TO_ADDR
// end ; end ;
38551: LD_VAR 0 3
38555: RET
// export function MC_SetTame ( base , area ) ; begin
38556: LD_INT 0
38558: PPUSH
// if not mc_bases or not base then
38559: LD_EXP 49
38563: NOT
38564: PUSH
38565: LD_VAR 0 1
38569: NOT
38570: OR
38571: IFFALSE 38575
// exit ;
38573: GO 38600
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
38575: LD_ADDR_EXP 77
38579: PUSH
38580: LD_EXP 77
38584: PPUSH
38585: LD_VAR 0 1
38589: PPUSH
38590: LD_VAR 0 2
38594: PPUSH
38595: CALL_OW 1
38599: ST_TO_ADDR
// end ;
38600: LD_VAR 0 3
38604: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
38605: LD_INT 0
38607: PPUSH
38608: PPUSH
// if not mc_bases or not base then
38609: LD_EXP 49
38613: NOT
38614: PUSH
38615: LD_VAR 0 1
38619: NOT
38620: OR
38621: IFFALSE 38625
// exit ;
38623: GO 38727
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
38625: LD_ADDR_VAR 0 4
38629: PUSH
38630: LD_EXP 49
38634: PUSH
38635: LD_VAR 0 1
38639: ARRAY
38640: PPUSH
38641: LD_INT 30
38643: PUSH
38644: LD_VAR 0 2
38648: PUSH
38649: EMPTY
38650: LIST
38651: LIST
38652: PPUSH
38653: CALL_OW 72
38657: ST_TO_ADDR
// if not tmp then
38658: LD_VAR 0 4
38662: NOT
38663: IFFALSE 38667
// exit ;
38665: GO 38727
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
38667: LD_ADDR_EXP 81
38671: PUSH
38672: LD_EXP 81
38676: PPUSH
38677: LD_VAR 0 1
38681: PPUSH
38682: LD_EXP 81
38686: PUSH
38687: LD_VAR 0 1
38691: ARRAY
38692: PPUSH
38693: LD_EXP 81
38697: PUSH
38698: LD_VAR 0 1
38702: ARRAY
38703: PUSH
38704: LD_INT 1
38706: PLUS
38707: PPUSH
38708: LD_VAR 0 4
38712: PUSH
38713: LD_INT 1
38715: ARRAY
38716: PPUSH
38717: CALL_OW 2
38721: PPUSH
38722: CALL_OW 1
38726: ST_TO_ADDR
// end ;
38727: LD_VAR 0 3
38731: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
38732: LD_INT 0
38734: PPUSH
38735: PPUSH
// if not mc_bases or not base or not kinds then
38736: LD_EXP 49
38740: NOT
38741: PUSH
38742: LD_VAR 0 1
38746: NOT
38747: OR
38748: PUSH
38749: LD_VAR 0 2
38753: NOT
38754: OR
38755: IFFALSE 38759
// exit ;
38757: GO 38820
// for i in kinds do
38759: LD_ADDR_VAR 0 4
38763: PUSH
38764: LD_VAR 0 2
38768: PUSH
38769: FOR_IN
38770: IFFALSE 38818
// mc_lab_upgrade := Add ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
38772: LD_ADDR_EXP 83
38776: PUSH
38777: LD_EXP 83
38781: PPUSH
38782: LD_VAR 0 1
38786: PUSH
38787: LD_EXP 83
38791: PUSH
38792: LD_VAR 0 1
38796: ARRAY
38797: PUSH
38798: LD_INT 1
38800: PLUS
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: PPUSH
38806: LD_VAR 0 4
38810: PPUSH
38811: CALL 50857 0 3
38815: ST_TO_ADDR
38816: GO 38769
38818: POP
38819: POP
// end ;
38820: LD_VAR 0 3
38824: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
38825: LD_INT 0
38827: PPUSH
// if not mc_bases or not base or not areas then
38828: LD_EXP 49
38832: NOT
38833: PUSH
38834: LD_VAR 0 1
38838: NOT
38839: OR
38840: PUSH
38841: LD_VAR 0 2
38845: NOT
38846: OR
38847: IFFALSE 38851
// exit ;
38849: GO 38876
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
38851: LD_ADDR_EXP 67
38855: PUSH
38856: LD_EXP 67
38860: PPUSH
38861: LD_VAR 0 1
38865: PPUSH
38866: LD_VAR 0 2
38870: PPUSH
38871: CALL_OW 1
38875: ST_TO_ADDR
// end ;
38876: LD_VAR 0 3
38880: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
38881: LD_INT 0
38883: PPUSH
// if not mc_bases or not base or not teleports_exit then
38884: LD_EXP 49
38888: NOT
38889: PUSH
38890: LD_VAR 0 1
38894: NOT
38895: OR
38896: PUSH
38897: LD_VAR 0 2
38901: NOT
38902: OR
38903: IFFALSE 38907
// exit ;
38905: GO 38932
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
38907: LD_ADDR_EXP 84
38911: PUSH
38912: LD_EXP 84
38916: PPUSH
38917: LD_VAR 0 1
38921: PPUSH
38922: LD_VAR 0 2
38926: PPUSH
38927: CALL_OW 1
38931: ST_TO_ADDR
// end ;
38932: LD_VAR 0 3
38936: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
38937: LD_INT 0
38939: PPUSH
38940: PPUSH
38941: PPUSH
// if not mc_bases or not base or not ext_list then
38942: LD_EXP 49
38946: NOT
38947: PUSH
38948: LD_VAR 0 1
38952: NOT
38953: OR
38954: PUSH
38955: LD_VAR 0 5
38959: NOT
38960: OR
38961: IFFALSE 38965
// exit ;
38963: GO 39138
// tmp := GetFacExtXYD ( x , y , d ) ;
38965: LD_ADDR_VAR 0 8
38969: PUSH
38970: LD_VAR 0 2
38974: PPUSH
38975: LD_VAR 0 3
38979: PPUSH
38980: LD_VAR 0 4
38984: PPUSH
38985: CALL 83555 0 3
38989: ST_TO_ADDR
// if not tmp then
38990: LD_VAR 0 8
38994: NOT
38995: IFFALSE 38999
// exit ;
38997: GO 39138
// for i in tmp do
38999: LD_ADDR_VAR 0 7
39003: PUSH
39004: LD_VAR 0 8
39008: PUSH
39009: FOR_IN
39010: IFFALSE 39136
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
39012: LD_ADDR_EXP 54
39016: PUSH
39017: LD_EXP 54
39021: PPUSH
39022: LD_VAR 0 1
39026: PPUSH
39027: LD_EXP 54
39031: PUSH
39032: LD_VAR 0 1
39036: ARRAY
39037: PPUSH
39038: LD_EXP 54
39042: PUSH
39043: LD_VAR 0 1
39047: ARRAY
39048: PUSH
39049: LD_INT 1
39051: PLUS
39052: PPUSH
39053: LD_VAR 0 5
39057: PUSH
39058: LD_INT 1
39060: ARRAY
39061: PUSH
39062: LD_VAR 0 7
39066: PUSH
39067: LD_INT 1
39069: ARRAY
39070: PUSH
39071: LD_VAR 0 7
39075: PUSH
39076: LD_INT 2
39078: ARRAY
39079: PUSH
39080: LD_VAR 0 7
39084: PUSH
39085: LD_INT 3
39087: ARRAY
39088: PUSH
39089: EMPTY
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: PPUSH
39095: CALL_OW 2
39099: PPUSH
39100: CALL_OW 1
39104: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
39105: LD_ADDR_VAR 0 5
39109: PUSH
39110: LD_VAR 0 5
39114: PPUSH
39115: LD_INT 1
39117: PPUSH
39118: CALL_OW 3
39122: ST_TO_ADDR
// if not ext_list then
39123: LD_VAR 0 5
39127: NOT
39128: IFFALSE 39134
// exit ;
39130: POP
39131: POP
39132: GO 39138
// end ;
39134: GO 39009
39136: POP
39137: POP
// end ;
39138: LD_VAR 0 6
39142: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
39143: LD_INT 0
39145: PPUSH
// if not mc_bases or not base or not weapon_list then
39146: LD_EXP 49
39150: NOT
39151: PUSH
39152: LD_VAR 0 1
39156: NOT
39157: OR
39158: PUSH
39159: LD_VAR 0 2
39163: NOT
39164: OR
39165: IFFALSE 39169
// exit ;
39167: GO 39194
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
39169: LD_ADDR_EXP 88
39173: PUSH
39174: LD_EXP 88
39178: PPUSH
39179: LD_VAR 0 1
39183: PPUSH
39184: LD_VAR 0 2
39188: PPUSH
39189: CALL_OW 1
39193: ST_TO_ADDR
// end ;
39194: LD_VAR 0 3
39198: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
39199: LD_INT 0
39201: PPUSH
// if not mc_bases or not base or not tech_list then
39202: LD_EXP 49
39206: NOT
39207: PUSH
39208: LD_VAR 0 1
39212: NOT
39213: OR
39214: PUSH
39215: LD_VAR 0 2
39219: NOT
39220: OR
39221: IFFALSE 39225
// exit ;
39223: GO 39250
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
39225: LD_ADDR_EXP 76
39229: PUSH
39230: LD_EXP 76
39234: PPUSH
39235: LD_VAR 0 1
39239: PPUSH
39240: LD_VAR 0 2
39244: PPUSH
39245: CALL_OW 1
39249: ST_TO_ADDR
// end ;
39250: LD_VAR 0 3
39254: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
39255: LD_INT 0
39257: PPUSH
// if not mc_bases or not parking_area or not base then
39258: LD_EXP 49
39262: NOT
39263: PUSH
39264: LD_VAR 0 2
39268: NOT
39269: OR
39270: PUSH
39271: LD_VAR 0 1
39275: NOT
39276: OR
39277: IFFALSE 39281
// exit ;
39279: GO 39306
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
39281: LD_ADDR_EXP 73
39285: PUSH
39286: LD_EXP 73
39290: PPUSH
39291: LD_VAR 0 1
39295: PPUSH
39296: LD_VAR 0 2
39300: PPUSH
39301: CALL_OW 1
39305: ST_TO_ADDR
// end ;
39306: LD_VAR 0 3
39310: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
39311: LD_INT 0
39313: PPUSH
// if not mc_bases or not base or not scan_area then
39314: LD_EXP 49
39318: NOT
39319: PUSH
39320: LD_VAR 0 1
39324: NOT
39325: OR
39326: PUSH
39327: LD_VAR 0 2
39331: NOT
39332: OR
39333: IFFALSE 39337
// exit ;
39335: GO 39362
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
39337: LD_ADDR_EXP 74
39341: PUSH
39342: LD_EXP 74
39346: PPUSH
39347: LD_VAR 0 1
39351: PPUSH
39352: LD_VAR 0 2
39356: PPUSH
39357: CALL_OW 1
39361: ST_TO_ADDR
// end ;
39362: LD_VAR 0 3
39366: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
39367: LD_INT 0
39369: PPUSH
39370: PPUSH
// if not mc_bases or not base then
39371: LD_EXP 49
39375: NOT
39376: PUSH
39377: LD_VAR 0 1
39381: NOT
39382: OR
39383: IFFALSE 39387
// exit ;
39385: GO 39451
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
39387: LD_ADDR_VAR 0 3
39391: PUSH
39392: LD_INT 1
39394: PUSH
39395: LD_INT 2
39397: PUSH
39398: LD_INT 3
39400: PUSH
39401: LD_INT 4
39403: PUSH
39404: LD_INT 11
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: LIST
39411: LIST
39412: LIST
39413: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
39414: LD_ADDR_EXP 76
39418: PUSH
39419: LD_EXP 76
39423: PPUSH
39424: LD_VAR 0 1
39428: PPUSH
39429: LD_EXP 76
39433: PUSH
39434: LD_VAR 0 1
39438: ARRAY
39439: PUSH
39440: LD_VAR 0 3
39444: DIFF
39445: PPUSH
39446: CALL_OW 1
39450: ST_TO_ADDR
// end ; end_of_file
39451: LD_VAR 0 2
39455: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
39456: LD_INT 0
39458: PPUSH
39459: PPUSH
39460: PPUSH
// if not mc_bases then
39461: LD_EXP 49
39465: NOT
39466: IFFALSE 39470
// exit ;
39468: GO 39635
// for i = 1 to mc_bases do
39470: LD_ADDR_VAR 0 4
39474: PUSH
39475: DOUBLE
39476: LD_INT 1
39478: DEC
39479: ST_TO_ADDR
39480: LD_EXP 49
39484: PUSH
39485: FOR_TO
39486: IFFALSE 39633
// begin if sci in mc_bases [ i ] then
39488: LD_VAR 0 2
39492: PUSH
39493: LD_EXP 49
39497: PUSH
39498: LD_VAR 0 4
39502: ARRAY
39503: IN
39504: IFFALSE 39631
// begin mc_ape := Add ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
39506: LD_ADDR_EXP 78
39510: PUSH
39511: LD_EXP 78
39515: PPUSH
39516: LD_VAR 0 4
39520: PUSH
39521: LD_EXP 78
39525: PUSH
39526: LD_VAR 0 4
39530: ARRAY
39531: PUSH
39532: LD_INT 1
39534: PLUS
39535: PUSH
39536: EMPTY
39537: LIST
39538: LIST
39539: PPUSH
39540: LD_VAR 0 1
39544: PPUSH
39545: CALL 50857 0 3
39549: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
39550: LD_ADDR_VAR 0 5
39554: PUSH
39555: LD_EXP 49
39559: PUSH
39560: LD_VAR 0 4
39564: ARRAY
39565: PPUSH
39566: LD_INT 2
39568: PUSH
39569: LD_INT 30
39571: PUSH
39572: LD_INT 0
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: LD_INT 30
39581: PUSH
39582: LD_INT 1
39584: PUSH
39585: EMPTY
39586: LIST
39587: LIST
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: LIST
39593: PPUSH
39594: CALL_OW 72
39598: PPUSH
39599: LD_VAR 0 1
39603: PPUSH
39604: CALL_OW 74
39608: ST_TO_ADDR
// if tmp then
39609: LD_VAR 0 5
39613: IFFALSE 39629
// ComStandNearbyBuilding ( ape , tmp ) ;
39615: LD_VAR 0 1
39619: PPUSH
39620: LD_VAR 0 5
39624: PPUSH
39625: CALL 45099 0 2
// break ;
39629: GO 39633
// end ; end ;
39631: GO 39485
39633: POP
39634: POP
// end ;
39635: LD_VAR 0 3
39639: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
39640: LD_INT 0
39642: PPUSH
39643: PPUSH
39644: PPUSH
// if not mc_bases then
39645: LD_EXP 49
39649: NOT
39650: IFFALSE 39654
// exit ;
39652: GO 39743
// for i = 1 to mc_bases do
39654: LD_ADDR_VAR 0 4
39658: PUSH
39659: DOUBLE
39660: LD_INT 1
39662: DEC
39663: ST_TO_ADDR
39664: LD_EXP 49
39668: PUSH
39669: FOR_TO
39670: IFFALSE 39741
// begin if building in mc_busy_turret_list [ i ] then
39672: LD_VAR 0 1
39676: PUSH
39677: LD_EXP 59
39681: PUSH
39682: LD_VAR 0 4
39686: ARRAY
39687: IN
39688: IFFALSE 39739
// begin tmp := mc_busy_turret_list [ i ] diff building ;
39690: LD_ADDR_VAR 0 5
39694: PUSH
39695: LD_EXP 59
39699: PUSH
39700: LD_VAR 0 4
39704: ARRAY
39705: PUSH
39706: LD_VAR 0 1
39710: DIFF
39711: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
39712: LD_ADDR_EXP 59
39716: PUSH
39717: LD_EXP 59
39721: PPUSH
39722: LD_VAR 0 4
39726: PPUSH
39727: LD_VAR 0 5
39731: PPUSH
39732: CALL_OW 1
39736: ST_TO_ADDR
// break ;
39737: GO 39741
// end ; end ;
39739: GO 39669
39741: POP
39742: POP
// end ;
39743: LD_VAR 0 3
39747: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
39748: LD_INT 0
39750: PPUSH
39751: PPUSH
39752: PPUSH
// if not mc_bases then
39753: LD_EXP 49
39757: NOT
39758: IFFALSE 39762
// exit ;
39760: GO 39961
// for i = 1 to mc_bases do
39762: LD_ADDR_VAR 0 5
39766: PUSH
39767: DOUBLE
39768: LD_INT 1
39770: DEC
39771: ST_TO_ADDR
39772: LD_EXP 49
39776: PUSH
39777: FOR_TO
39778: IFFALSE 39959
// if building in mc_bases [ i ] then
39780: LD_VAR 0 1
39784: PUSH
39785: LD_EXP 49
39789: PUSH
39790: LD_VAR 0 5
39794: ARRAY
39795: IN
39796: IFFALSE 39957
// begin tmp := mc_bases [ i ] diff building ;
39798: LD_ADDR_VAR 0 6
39802: PUSH
39803: LD_EXP 49
39807: PUSH
39808: LD_VAR 0 5
39812: ARRAY
39813: PUSH
39814: LD_VAR 0 1
39818: DIFF
39819: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
39820: LD_ADDR_EXP 49
39824: PUSH
39825: LD_EXP 49
39829: PPUSH
39830: LD_VAR 0 5
39834: PPUSH
39835: LD_VAR 0 6
39839: PPUSH
39840: CALL_OW 1
39844: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
39845: LD_VAR 0 1
39849: PUSH
39850: LD_EXP 57
39854: PUSH
39855: LD_VAR 0 5
39859: ARRAY
39860: IN
39861: IFFALSE 39900
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
39863: LD_ADDR_EXP 57
39867: PUSH
39868: LD_EXP 57
39872: PPUSH
39873: LD_VAR 0 5
39877: PPUSH
39878: LD_EXP 57
39882: PUSH
39883: LD_VAR 0 5
39887: ARRAY
39888: PUSH
39889: LD_VAR 0 1
39893: DIFF
39894: PPUSH
39895: CALL_OW 1
39899: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
39900: LD_VAR 0 1
39904: PUSH
39905: LD_EXP 58
39909: PUSH
39910: LD_VAR 0 5
39914: ARRAY
39915: IN
39916: IFFALSE 39955
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
39918: LD_ADDR_EXP 58
39922: PUSH
39923: LD_EXP 58
39927: PPUSH
39928: LD_VAR 0 5
39932: PPUSH
39933: LD_EXP 58
39937: PUSH
39938: LD_VAR 0 5
39942: ARRAY
39943: PUSH
39944: LD_VAR 0 1
39948: DIFF
39949: PPUSH
39950: CALL_OW 1
39954: ST_TO_ADDR
// break ;
39955: GO 39959
// end ;
39957: GO 39777
39959: POP
39960: POP
// end ;
39961: LD_VAR 0 4
39965: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
39966: LD_INT 0
39968: PPUSH
39969: PPUSH
39970: PPUSH
// if not mc_bases or not side in mc_sides then
39971: LD_EXP 49
39975: NOT
39976: PUSH
39977: LD_VAR 0 3
39981: PUSH
39982: LD_EXP 75
39986: IN
39987: NOT
39988: OR
39989: IFFALSE 39993
// exit ;
39991: GO 40116
// for i = 1 to mc_vehicles do
39993: LD_ADDR_VAR 0 6
39997: PUSH
39998: DOUBLE
39999: LD_INT 1
40001: DEC
40002: ST_TO_ADDR
40003: LD_EXP 68
40007: PUSH
40008: FOR_TO
40009: IFFALSE 40114
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
40011: LD_VAR 0 2
40015: PUSH
40016: LD_EXP 68
40020: PUSH
40021: LD_VAR 0 6
40025: ARRAY
40026: IN
40027: PUSH
40028: LD_VAR 0 1
40032: PUSH
40033: LD_EXP 68
40037: PUSH
40038: LD_VAR 0 6
40042: ARRAY
40043: IN
40044: OR
40045: IFFALSE 40112
// begin tmp := mc_vehicles [ i ] diff old ;
40047: LD_ADDR_VAR 0 7
40051: PUSH
40052: LD_EXP 68
40056: PUSH
40057: LD_VAR 0 6
40061: ARRAY
40062: PUSH
40063: LD_VAR 0 2
40067: DIFF
40068: ST_TO_ADDR
// tmp := tmp diff new ;
40069: LD_ADDR_VAR 0 7
40073: PUSH
40074: LD_VAR 0 7
40078: PUSH
40079: LD_VAR 0 1
40083: DIFF
40084: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
40085: LD_ADDR_EXP 68
40089: PUSH
40090: LD_EXP 68
40094: PPUSH
40095: LD_VAR 0 6
40099: PPUSH
40100: LD_VAR 0 7
40104: PPUSH
40105: CALL_OW 1
40109: ST_TO_ADDR
// break ;
40110: GO 40114
// end ;
40112: GO 40008
40114: POP
40115: POP
// end ;
40116: LD_VAR 0 5
40120: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
40121: LD_INT 0
40123: PPUSH
40124: PPUSH
40125: PPUSH
40126: PPUSH
// if not mc_bases then
40127: LD_EXP 49
40131: NOT
40132: IFFALSE 40136
// exit ;
40134: GO 40519
// side := GetSide ( vehicle ) ;
40136: LD_ADDR_VAR 0 5
40140: PUSH
40141: LD_VAR 0 1
40145: PPUSH
40146: CALL_OW 255
40150: ST_TO_ADDR
// for i = 1 to mc_bases do
40151: LD_ADDR_VAR 0 4
40155: PUSH
40156: DOUBLE
40157: LD_INT 1
40159: DEC
40160: ST_TO_ADDR
40161: LD_EXP 49
40165: PUSH
40166: FOR_TO
40167: IFFALSE 40517
// begin if factory in mc_bases [ i ] then
40169: LD_VAR 0 2
40173: PUSH
40174: LD_EXP 49
40178: PUSH
40179: LD_VAR 0 4
40183: ARRAY
40184: IN
40185: IFFALSE 40515
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
40187: LD_EXP 71
40191: PUSH
40192: LD_VAR 0 4
40196: ARRAY
40197: PUSH
40198: LD_EXP 60
40202: PUSH
40203: LD_VAR 0 4
40207: ARRAY
40208: LESS
40209: PUSH
40210: LD_VAR 0 1
40214: PPUSH
40215: CALL_OW 264
40219: PUSH
40220: LD_INT 31
40222: PUSH
40223: LD_INT 32
40225: PUSH
40226: LD_INT 51
40228: PUSH
40229: LD_EXP 92
40233: PUSH
40234: LD_INT 12
40236: PUSH
40237: LD_INT 30
40239: PUSH
40240: LD_EXP 91
40244: PUSH
40245: LD_INT 11
40247: PUSH
40248: LD_INT 53
40250: PUSH
40251: LD_INT 14
40253: PUSH
40254: LD_EXP 95
40258: PUSH
40259: LD_INT 29
40261: PUSH
40262: LD_EXP 93
40266: PUSH
40267: LD_INT 13
40269: PUSH
40270: LD_INT 52
40272: PUSH
40273: LD_INT 48
40275: PUSH
40276: LD_INT 8
40278: PUSH
40279: EMPTY
40280: LIST
40281: LIST
40282: LIST
40283: LIST
40284: LIST
40285: LIST
40286: LIST
40287: LIST
40288: LIST
40289: LIST
40290: LIST
40291: LIST
40292: LIST
40293: LIST
40294: LIST
40295: LIST
40296: LIST
40297: IN
40298: NOT
40299: AND
40300: IFFALSE 40341
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
40302: LD_ADDR_EXP 71
40306: PUSH
40307: LD_EXP 71
40311: PPUSH
40312: LD_VAR 0 4
40316: PPUSH
40317: LD_EXP 71
40321: PUSH
40322: LD_VAR 0 4
40326: ARRAY
40327: PUSH
40328: LD_VAR 0 1
40332: ADD
40333: PPUSH
40334: CALL_OW 1
40338: ST_TO_ADDR
40339: GO 40385
// mc_vehicles := Add ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
40341: LD_ADDR_EXP 68
40345: PUSH
40346: LD_EXP 68
40350: PPUSH
40351: LD_VAR 0 4
40355: PUSH
40356: LD_EXP 68
40360: PUSH
40361: LD_VAR 0 4
40365: ARRAY
40366: PUSH
40367: LD_INT 1
40369: PLUS
40370: PUSH
40371: EMPTY
40372: LIST
40373: LIST
40374: PPUSH
40375: LD_VAR 0 1
40379: PPUSH
40380: CALL 50857 0 3
40384: ST_TO_ADDR
// if not mc_scan [ i ] then
40385: LD_EXP 72
40389: PUSH
40390: LD_VAR 0 4
40394: ARRAY
40395: NOT
40396: IFFALSE 40515
// begin if GetControl ( vehicle ) = control_remote then
40398: LD_VAR 0 1
40402: PPUSH
40403: CALL_OW 263
40407: PUSH
40408: LD_INT 2
40410: EQUAL
40411: IFFALSE 40431
// repeat wait ( 0 0$1 ) ;
40413: LD_INT 35
40415: PPUSH
40416: CALL_OW 67
// until IsControledBy ( vehicle ) ;
40420: LD_VAR 0 1
40424: PPUSH
40425: CALL_OW 312
40429: IFFALSE 40413
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
40431: LD_VAR 0 1
40435: PPUSH
40436: LD_EXP 73
40440: PUSH
40441: LD_VAR 0 4
40445: ARRAY
40446: PPUSH
40447: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
40451: LD_VAR 0 1
40455: PPUSH
40456: CALL_OW 263
40460: PUSH
40461: LD_INT 1
40463: NONEQUAL
40464: IFFALSE 40468
// break ;
40466: GO 40517
// repeat wait ( 0 0$1 ) ;
40468: LD_INT 35
40470: PPUSH
40471: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
40475: LD_VAR 0 1
40479: PPUSH
40480: LD_EXP 73
40484: PUSH
40485: LD_VAR 0 4
40489: ARRAY
40490: PPUSH
40491: CALL_OW 308
40495: IFFALSE 40468
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
40497: LD_VAR 0 1
40501: PPUSH
40502: CALL_OW 311
40506: PPUSH
40507: CALL_OW 121
// exit ;
40511: POP
40512: POP
40513: GO 40519
// end ; end ; end ;
40515: GO 40166
40517: POP
40518: POP
// end ;
40519: LD_VAR 0 3
40523: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
40524: LD_INT 0
40526: PPUSH
40527: PPUSH
40528: PPUSH
40529: PPUSH
// if not mc_bases then
40530: LD_EXP 49
40534: NOT
40535: IFFALSE 40539
// exit ;
40537: GO 40892
// repeat wait ( 0 0$1 ) ;
40539: LD_INT 35
40541: PPUSH
40542: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
40546: LD_VAR 0 2
40550: PPUSH
40551: LD_VAR 0 3
40555: PPUSH
40556: CALL_OW 284
40560: IFFALSE 40539
// if GetResourceTypeXY ( x , y ) = mat_artefact then
40562: LD_VAR 0 2
40566: PPUSH
40567: LD_VAR 0 3
40571: PPUSH
40572: CALL_OW 283
40576: PUSH
40577: LD_INT 4
40579: EQUAL
40580: IFFALSE 40584
// exit ;
40582: GO 40892
// for i = 1 to mc_bases do
40584: LD_ADDR_VAR 0 7
40588: PUSH
40589: DOUBLE
40590: LD_INT 1
40592: DEC
40593: ST_TO_ADDR
40594: LD_EXP 49
40598: PUSH
40599: FOR_TO
40600: IFFALSE 40890
// begin if mc_crates_area [ i ] then
40602: LD_EXP 67
40606: PUSH
40607: LD_VAR 0 7
40611: ARRAY
40612: IFFALSE 40723
// for j in mc_crates_area [ i ] do
40614: LD_ADDR_VAR 0 8
40618: PUSH
40619: LD_EXP 67
40623: PUSH
40624: LD_VAR 0 7
40628: ARRAY
40629: PUSH
40630: FOR_IN
40631: IFFALSE 40721
// if InArea ( x , y , j ) then
40633: LD_VAR 0 2
40637: PPUSH
40638: LD_VAR 0 3
40642: PPUSH
40643: LD_VAR 0 8
40647: PPUSH
40648: CALL_OW 309
40652: IFFALSE 40719
// begin mc_crates := Add ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
40654: LD_ADDR_EXP 65
40658: PUSH
40659: LD_EXP 65
40663: PPUSH
40664: LD_VAR 0 7
40668: PUSH
40669: LD_EXP 65
40673: PUSH
40674: LD_VAR 0 7
40678: ARRAY
40679: PUSH
40680: LD_INT 1
40682: PLUS
40683: PUSH
40684: EMPTY
40685: LIST
40686: LIST
40687: PPUSH
40688: LD_VAR 0 4
40692: PUSH
40693: LD_VAR 0 2
40697: PUSH
40698: LD_VAR 0 3
40702: PUSH
40703: EMPTY
40704: LIST
40705: LIST
40706: LIST
40707: PPUSH
40708: CALL 50857 0 3
40712: ST_TO_ADDR
// exit ;
40713: POP
40714: POP
40715: POP
40716: POP
40717: GO 40892
// end ;
40719: GO 40630
40721: POP
40722: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40723: LD_ADDR_VAR 0 9
40727: PUSH
40728: LD_EXP 49
40732: PUSH
40733: LD_VAR 0 7
40737: ARRAY
40738: PPUSH
40739: LD_INT 2
40741: PUSH
40742: LD_INT 30
40744: PUSH
40745: LD_INT 0
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: PUSH
40752: LD_INT 30
40754: PUSH
40755: LD_INT 1
40757: PUSH
40758: EMPTY
40759: LIST
40760: LIST
40761: PUSH
40762: EMPTY
40763: LIST
40764: LIST
40765: LIST
40766: PPUSH
40767: CALL_OW 72
40771: ST_TO_ADDR
// if not depot then
40772: LD_VAR 0 9
40776: NOT
40777: IFFALSE 40781
// continue ;
40779: GO 40599
// for j in depot do
40781: LD_ADDR_VAR 0 8
40785: PUSH
40786: LD_VAR 0 9
40790: PUSH
40791: FOR_IN
40792: IFFALSE 40886
// if GetDistUnitXY ( j , x , y ) < 30 then
40794: LD_VAR 0 8
40798: PPUSH
40799: LD_VAR 0 2
40803: PPUSH
40804: LD_VAR 0 3
40808: PPUSH
40809: CALL_OW 297
40813: PUSH
40814: LD_INT 30
40816: LESS
40817: IFFALSE 40884
// begin mc_crates := Add ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
40819: LD_ADDR_EXP 65
40823: PUSH
40824: LD_EXP 65
40828: PPUSH
40829: LD_VAR 0 7
40833: PUSH
40834: LD_EXP 65
40838: PUSH
40839: LD_VAR 0 7
40843: ARRAY
40844: PUSH
40845: LD_INT 1
40847: PLUS
40848: PUSH
40849: EMPTY
40850: LIST
40851: LIST
40852: PPUSH
40853: LD_VAR 0 4
40857: PUSH
40858: LD_VAR 0 2
40862: PUSH
40863: LD_VAR 0 3
40867: PUSH
40868: EMPTY
40869: LIST
40870: LIST
40871: LIST
40872: PPUSH
40873: CALL 50857 0 3
40877: ST_TO_ADDR
// exit ;
40878: POP
40879: POP
40880: POP
40881: POP
40882: GO 40892
// end ;
40884: GO 40791
40886: POP
40887: POP
// end ;
40888: GO 40599
40890: POP
40891: POP
// end ;
40892: LD_VAR 0 6
40896: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
40897: LD_INT 0
40899: PPUSH
40900: PPUSH
40901: PPUSH
40902: PPUSH
// side := GetSide ( lab ) ;
40903: LD_ADDR_VAR 0 4
40907: PUSH
40908: LD_VAR 0 2
40912: PPUSH
40913: CALL_OW 255
40917: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
40918: LD_VAR 0 4
40922: PUSH
40923: LD_EXP 75
40927: IN
40928: NOT
40929: PUSH
40930: LD_EXP 76
40934: NOT
40935: OR
40936: PUSH
40937: LD_EXP 49
40941: NOT
40942: OR
40943: IFFALSE 40947
// exit ;
40945: GO 41180
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
40947: LD_ADDR_EXP 76
40951: PUSH
40952: LD_EXP 76
40956: PPUSH
40957: LD_VAR 0 4
40961: PPUSH
40962: LD_EXP 76
40966: PUSH
40967: LD_VAR 0 4
40971: ARRAY
40972: PUSH
40973: LD_VAR 0 1
40977: DIFF
40978: PPUSH
40979: CALL_OW 1
40983: ST_TO_ADDR
// for i = 1 to mc_bases do
40984: LD_ADDR_VAR 0 5
40988: PUSH
40989: DOUBLE
40990: LD_INT 1
40992: DEC
40993: ST_TO_ADDR
40994: LD_EXP 49
40998: PUSH
40999: FOR_TO
41000: IFFALSE 41178
// begin if lab in mc_bases [ i ] then
41002: LD_VAR 0 2
41006: PUSH
41007: LD_EXP 49
41011: PUSH
41012: LD_VAR 0 5
41016: ARRAY
41017: IN
41018: IFFALSE 41176
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
41020: LD_VAR 0 1
41024: PUSH
41025: LD_INT 11
41027: PUSH
41028: LD_INT 4
41030: PUSH
41031: LD_INT 3
41033: PUSH
41034: LD_INT 2
41036: PUSH
41037: EMPTY
41038: LIST
41039: LIST
41040: LIST
41041: LIST
41042: IN
41043: PUSH
41044: LD_EXP 79
41048: PUSH
41049: LD_VAR 0 5
41053: ARRAY
41054: AND
41055: IFFALSE 41176
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
41057: LD_ADDR_VAR 0 6
41061: PUSH
41062: LD_EXP 79
41066: PUSH
41067: LD_VAR 0 5
41071: ARRAY
41072: PUSH
41073: LD_INT 1
41075: ARRAY
41076: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
41077: LD_ADDR_EXP 79
41081: PUSH
41082: LD_EXP 79
41086: PPUSH
41087: LD_VAR 0 5
41091: PPUSH
41092: EMPTY
41093: PPUSH
41094: CALL_OW 1
41098: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
41099: LD_VAR 0 6
41103: PPUSH
41104: LD_INT 0
41106: PPUSH
41107: CALL_OW 109
// ComExitBuilding ( tmp ) ;
41111: LD_VAR 0 6
41115: PPUSH
41116: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
41120: LD_ADDR_EXP 78
41124: PUSH
41125: LD_EXP 78
41129: PPUSH
41130: LD_VAR 0 5
41134: PPUSH
41135: LD_EXP 78
41139: PUSH
41140: LD_VAR 0 5
41144: ARRAY
41145: PPUSH
41146: LD_INT 1
41148: PPUSH
41149: LD_VAR 0 6
41153: PPUSH
41154: CALL_OW 2
41158: PPUSH
41159: CALL_OW 1
41163: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
41164: LD_VAR 0 5
41168: PPUSH
41169: LD_INT 112
41171: PPUSH
41172: CALL 19344 0 2
// end ; end ; end ;
41176: GO 40999
41178: POP
41179: POP
// end ;
41180: LD_VAR 0 3
41184: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
41185: LD_INT 0
41187: PPUSH
41188: PPUSH
41189: PPUSH
41190: PPUSH
41191: PPUSH
41192: PPUSH
41193: PPUSH
41194: PPUSH
// if not mc_bases then
41195: LD_EXP 49
41199: NOT
41200: IFFALSE 41204
// exit ;
41202: GO 42147
// for i = 1 to mc_bases do
41204: LD_ADDR_VAR 0 3
41208: PUSH
41209: DOUBLE
41210: LD_INT 1
41212: DEC
41213: ST_TO_ADDR
41214: LD_EXP 49
41218: PUSH
41219: FOR_TO
41220: IFFALSE 42145
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
41222: LD_VAR 0 1
41226: PUSH
41227: LD_EXP 49
41231: PUSH
41232: LD_VAR 0 3
41236: ARRAY
41237: IN
41238: PUSH
41239: LD_VAR 0 1
41243: PUSH
41244: LD_EXP 56
41248: PUSH
41249: LD_VAR 0 3
41253: ARRAY
41254: IN
41255: OR
41256: PUSH
41257: LD_VAR 0 1
41261: PUSH
41262: LD_EXP 68
41266: PUSH
41267: LD_VAR 0 3
41271: ARRAY
41272: IN
41273: OR
41274: PUSH
41275: LD_VAR 0 1
41279: PUSH
41280: LD_EXP 78
41284: PUSH
41285: LD_VAR 0 3
41289: ARRAY
41290: IN
41291: OR
41292: PUSH
41293: LD_VAR 0 1
41297: PUSH
41298: LD_EXP 79
41302: PUSH
41303: LD_VAR 0 3
41307: ARRAY
41308: IN
41309: OR
41310: IFFALSE 42143
// begin if un in mc_ape [ i ] then
41312: LD_VAR 0 1
41316: PUSH
41317: LD_EXP 78
41321: PUSH
41322: LD_VAR 0 3
41326: ARRAY
41327: IN
41328: IFFALSE 41367
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
41330: LD_ADDR_EXP 78
41334: PUSH
41335: LD_EXP 78
41339: PPUSH
41340: LD_VAR 0 3
41344: PPUSH
41345: LD_EXP 78
41349: PUSH
41350: LD_VAR 0 3
41354: ARRAY
41355: PUSH
41356: LD_VAR 0 1
41360: DIFF
41361: PPUSH
41362: CALL_OW 1
41366: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
41367: LD_VAR 0 1
41371: PUSH
41372: LD_EXP 79
41376: PUSH
41377: LD_VAR 0 3
41381: ARRAY
41382: IN
41383: IFFALSE 41407
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
41385: LD_ADDR_EXP 79
41389: PUSH
41390: LD_EXP 79
41394: PPUSH
41395: LD_VAR 0 3
41399: PPUSH
41400: EMPTY
41401: PPUSH
41402: CALL_OW 1
41406: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and GetTag ( un ) = 20 then
41407: LD_VAR 0 1
41411: PPUSH
41412: CALL_OW 247
41416: PUSH
41417: LD_INT 2
41419: EQUAL
41420: PUSH
41421: LD_VAR 0 1
41425: PPUSH
41426: CALL_OW 110
41430: PUSH
41431: LD_INT 20
41433: EQUAL
41434: AND
41435: IFFALSE 41538
// begin fac := MC_GetBuilding ( i , b_factory ) ;
41437: LD_ADDR_VAR 0 8
41441: PUSH
41442: LD_VAR 0 3
41446: PPUSH
41447: LD_INT 3
41449: PPUSH
41450: CALL 38473 0 2
41454: ST_TO_ADDR
// if fac then
41455: LD_VAR 0 8
41459: IFFALSE 41538
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
41461: LD_ADDR_VAR 0 9
41465: PUSH
41466: LD_VAR 0 8
41470: PPUSH
41471: LD_VAR 0 1
41475: PPUSH
41476: CALL_OW 265
41480: PPUSH
41481: LD_VAR 0 1
41485: PPUSH
41486: CALL_OW 262
41490: PPUSH
41491: LD_VAR 0 1
41495: PPUSH
41496: CALL_OW 263
41500: PPUSH
41501: LD_VAR 0 1
41505: PPUSH
41506: CALL_OW 264
41510: PPUSH
41511: CALL 48022 0 5
41515: ST_TO_ADDR
// if components then
41516: LD_VAR 0 9
41520: IFFALSE 41536
// MC_InsertProduceList ( i , components ) ;
41522: LD_VAR 0 3
41526: PPUSH
41527: LD_VAR 0 9
41531: PPUSH
41532: CALL 38043 0 2
// break ;
41536: GO 42145
// end ; end ; if GetType ( un ) = unit_building then
41538: LD_VAR 0 1
41542: PPUSH
41543: CALL_OW 247
41547: PUSH
41548: LD_INT 3
41550: EQUAL
41551: IFFALSE 41866
// begin btype := GetBType ( un ) ;
41553: LD_ADDR_VAR 0 5
41557: PUSH
41558: LD_VAR 0 1
41562: PPUSH
41563: CALL_OW 266
41567: ST_TO_ADDR
// if btype = b_warehouse then
41568: LD_VAR 0 5
41572: PUSH
41573: LD_INT 1
41575: EQUAL
41576: IFFALSE 41594
// begin btype := b_depot ;
41578: LD_ADDR_VAR 0 5
41582: PUSH
41583: LD_INT 0
41585: ST_TO_ADDR
// pos := 1 ;
41586: LD_ADDR_VAR 0 6
41590: PUSH
41591: LD_INT 1
41593: ST_TO_ADDR
// end ; if btype = b_factory then
41594: LD_VAR 0 5
41598: PUSH
41599: LD_INT 3
41601: EQUAL
41602: IFFALSE 41620
// begin btype := b_workshop ;
41604: LD_ADDR_VAR 0 5
41608: PUSH
41609: LD_INT 2
41611: ST_TO_ADDR
// pos := 1 ;
41612: LD_ADDR_VAR 0 6
41616: PUSH
41617: LD_INT 1
41619: ST_TO_ADDR
// end ; if btype = b_barracks then
41620: LD_VAR 0 5
41624: PUSH
41625: LD_INT 5
41627: EQUAL
41628: IFFALSE 41638
// btype := b_armoury ;
41630: LD_ADDR_VAR 0 5
41634: PUSH
41635: LD_INT 4
41637: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
41638: LD_VAR 0 5
41642: PUSH
41643: LD_INT 7
41645: PUSH
41646: LD_INT 8
41648: PUSH
41649: EMPTY
41650: LIST
41651: LIST
41652: IN
41653: IFFALSE 41663
// btype := b_lab ;
41655: LD_ADDR_VAR 0 5
41659: PUSH
41660: LD_INT 6
41662: ST_TO_ADDR
// mc_build_list := Add ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
41663: LD_ADDR_EXP 54
41667: PUSH
41668: LD_EXP 54
41672: PPUSH
41673: LD_VAR 0 3
41677: PUSH
41678: LD_EXP 54
41682: PUSH
41683: LD_VAR 0 3
41687: ARRAY
41688: PUSH
41689: LD_INT 1
41691: PLUS
41692: PUSH
41693: EMPTY
41694: LIST
41695: LIST
41696: PPUSH
41697: LD_VAR 0 5
41701: PUSH
41702: LD_VAR 0 1
41706: PPUSH
41707: CALL_OW 250
41711: PUSH
41712: LD_VAR 0 1
41716: PPUSH
41717: CALL_OW 251
41721: PUSH
41722: LD_VAR 0 1
41726: PPUSH
41727: CALL_OW 254
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: LIST
41736: LIST
41737: PPUSH
41738: CALL 50857 0 3
41742: ST_TO_ADDR
// if pos = 1 then
41743: LD_VAR 0 6
41747: PUSH
41748: LD_INT 1
41750: EQUAL
41751: IFFALSE 41866
// begin tmp := mc_build_list [ i ] ;
41753: LD_ADDR_VAR 0 7
41757: PUSH
41758: LD_EXP 54
41762: PUSH
41763: LD_VAR 0 3
41767: ARRAY
41768: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41769: LD_VAR 0 7
41773: PPUSH
41774: LD_INT 2
41776: PUSH
41777: LD_INT 30
41779: PUSH
41780: LD_INT 0
41782: PUSH
41783: EMPTY
41784: LIST
41785: LIST
41786: PUSH
41787: LD_INT 30
41789: PUSH
41790: LD_INT 1
41792: PUSH
41793: EMPTY
41794: LIST
41795: LIST
41796: PUSH
41797: EMPTY
41798: LIST
41799: LIST
41800: LIST
41801: PPUSH
41802: CALL_OW 72
41806: IFFALSE 41816
// pos := 2 ;
41808: LD_ADDR_VAR 0 6
41812: PUSH
41813: LD_INT 2
41815: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
41816: LD_ADDR_VAR 0 7
41820: PUSH
41821: LD_VAR 0 7
41825: PPUSH
41826: LD_VAR 0 6
41830: PPUSH
41831: LD_VAR 0 7
41835: PPUSH
41836: CALL 50748 0 3
41840: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
41841: LD_ADDR_EXP 54
41845: PUSH
41846: LD_EXP 54
41850: PPUSH
41851: LD_VAR 0 3
41855: PPUSH
41856: LD_VAR 0 7
41860: PPUSH
41861: CALL_OW 1
41865: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
41866: LD_VAR 0 1
41870: PUSH
41871: LD_EXP 49
41875: PUSH
41876: LD_VAR 0 3
41880: ARRAY
41881: IN
41882: IFFALSE 41921
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
41884: LD_ADDR_EXP 49
41888: PUSH
41889: LD_EXP 49
41893: PPUSH
41894: LD_VAR 0 3
41898: PPUSH
41899: LD_EXP 49
41903: PUSH
41904: LD_VAR 0 3
41908: ARRAY
41909: PUSH
41910: LD_VAR 0 1
41914: DIFF
41915: PPUSH
41916: CALL_OW 1
41920: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
41921: LD_VAR 0 1
41925: PUSH
41926: LD_EXP 56
41930: PUSH
41931: LD_VAR 0 3
41935: ARRAY
41936: IN
41937: IFFALSE 41976
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
41939: LD_ADDR_EXP 56
41943: PUSH
41944: LD_EXP 56
41948: PPUSH
41949: LD_VAR 0 3
41953: PPUSH
41954: LD_EXP 56
41958: PUSH
41959: LD_VAR 0 3
41963: ARRAY
41964: PUSH
41965: LD_VAR 0 1
41969: DIFF
41970: PPUSH
41971: CALL_OW 1
41975: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
41976: LD_VAR 0 1
41980: PUSH
41981: LD_EXP 68
41985: PUSH
41986: LD_VAR 0 3
41990: ARRAY
41991: IN
41992: IFFALSE 42031
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
41994: LD_ADDR_EXP 68
41998: PUSH
41999: LD_EXP 68
42003: PPUSH
42004: LD_VAR 0 3
42008: PPUSH
42009: LD_EXP 68
42013: PUSH
42014: LD_VAR 0 3
42018: ARRAY
42019: PUSH
42020: LD_VAR 0 1
42024: DIFF
42025: PPUSH
42026: CALL_OW 1
42030: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
42031: LD_VAR 0 1
42035: PUSH
42036: LD_EXP 58
42040: PUSH
42041: LD_VAR 0 3
42045: ARRAY
42046: IN
42047: IFFALSE 42086
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
42049: LD_ADDR_EXP 58
42053: PUSH
42054: LD_EXP 58
42058: PPUSH
42059: LD_VAR 0 3
42063: PPUSH
42064: LD_EXP 58
42068: PUSH
42069: LD_VAR 0 3
42073: ARRAY
42074: PUSH
42075: LD_VAR 0 1
42079: DIFF
42080: PPUSH
42081: CALL_OW 1
42085: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
42086: LD_VAR 0 1
42090: PUSH
42091: LD_EXP 57
42095: PUSH
42096: LD_VAR 0 3
42100: ARRAY
42101: IN
42102: IFFALSE 42141
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
42104: LD_ADDR_EXP 57
42108: PUSH
42109: LD_EXP 57
42113: PPUSH
42114: LD_VAR 0 3
42118: PPUSH
42119: LD_EXP 57
42123: PUSH
42124: LD_VAR 0 3
42128: ARRAY
42129: PUSH
42130: LD_VAR 0 1
42134: DIFF
42135: PPUSH
42136: CALL_OW 1
42140: ST_TO_ADDR
// end ; break ;
42141: GO 42145
// end ;
42143: GO 41219
42145: POP
42146: POP
// end ;
42147: LD_VAR 0 2
42151: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
42152: LD_INT 0
42154: PPUSH
42155: PPUSH
42156: PPUSH
// if not mc_bases then
42157: LD_EXP 49
42161: NOT
42162: IFFALSE 42166
// exit ;
42164: GO 42381
// for i = 1 to mc_bases do
42166: LD_ADDR_VAR 0 3
42170: PUSH
42171: DOUBLE
42172: LD_INT 1
42174: DEC
42175: ST_TO_ADDR
42176: LD_EXP 49
42180: PUSH
42181: FOR_TO
42182: IFFALSE 42379
// begin if building in mc_construct_list [ i ] then
42184: LD_VAR 0 1
42188: PUSH
42189: LD_EXP 56
42193: PUSH
42194: LD_VAR 0 3
42198: ARRAY
42199: IN
42200: IFFALSE 42377
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
42202: LD_ADDR_EXP 56
42206: PUSH
42207: LD_EXP 56
42211: PPUSH
42212: LD_VAR 0 3
42216: PPUSH
42217: LD_EXP 56
42221: PUSH
42222: LD_VAR 0 3
42226: ARRAY
42227: PUSH
42228: LD_VAR 0 1
42232: DIFF
42233: PPUSH
42234: CALL_OW 1
42238: ST_TO_ADDR
// if building in mc_lab [ i ] then
42239: LD_VAR 0 1
42243: PUSH
42244: LD_EXP 82
42248: PUSH
42249: LD_VAR 0 3
42253: ARRAY
42254: IN
42255: IFFALSE 42310
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
42257: LD_ADDR_EXP 83
42261: PUSH
42262: LD_EXP 83
42266: PPUSH
42267: LD_VAR 0 3
42271: PPUSH
42272: LD_EXP 83
42276: PUSH
42277: LD_VAR 0 3
42281: ARRAY
42282: PPUSH
42283: LD_INT 1
42285: PPUSH
42286: LD_EXP 83
42290: PUSH
42291: LD_VAR 0 3
42295: ARRAY
42296: PPUSH
42297: LD_INT 0
42299: PPUSH
42300: CALL 49840 0 4
42304: PPUSH
42305: CALL_OW 1
42309: ST_TO_ADDR
// if not building in mc_bases [ i ] then
42310: LD_VAR 0 1
42314: PUSH
42315: LD_EXP 49
42319: PUSH
42320: LD_VAR 0 3
42324: ARRAY
42325: IN
42326: NOT
42327: IFFALSE 42373
// mc_bases := Add ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
42329: LD_ADDR_EXP 49
42333: PUSH
42334: LD_EXP 49
42338: PPUSH
42339: LD_VAR 0 3
42343: PUSH
42344: LD_EXP 49
42348: PUSH
42349: LD_VAR 0 3
42353: ARRAY
42354: PUSH
42355: LD_INT 1
42357: PLUS
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: PPUSH
42363: LD_VAR 0 1
42367: PPUSH
42368: CALL 50857 0 3
42372: ST_TO_ADDR
// exit ;
42373: POP
42374: POP
42375: GO 42381
// end ; end ;
42377: GO 42181
42379: POP
42380: POP
// end ;
42381: LD_VAR 0 2
42385: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
42386: LD_INT 0
42388: PPUSH
42389: PPUSH
42390: PPUSH
42391: PPUSH
42392: PPUSH
42393: PPUSH
42394: PPUSH
// if not mc_bases then
42395: LD_EXP 49
42399: NOT
42400: IFFALSE 42404
// exit ;
42402: GO 43065
// for i = 1 to mc_bases do
42404: LD_ADDR_VAR 0 3
42408: PUSH
42409: DOUBLE
42410: LD_INT 1
42412: DEC
42413: ST_TO_ADDR
42414: LD_EXP 49
42418: PUSH
42419: FOR_TO
42420: IFFALSE 43063
// begin if building in mc_construct_list [ i ] then
42422: LD_VAR 0 1
42426: PUSH
42427: LD_EXP 56
42431: PUSH
42432: LD_VAR 0 3
42436: ARRAY
42437: IN
42438: IFFALSE 43061
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
42440: LD_ADDR_EXP 56
42444: PUSH
42445: LD_EXP 56
42449: PPUSH
42450: LD_VAR 0 3
42454: PPUSH
42455: LD_EXP 56
42459: PUSH
42460: LD_VAR 0 3
42464: ARRAY
42465: PUSH
42466: LD_VAR 0 1
42470: DIFF
42471: PPUSH
42472: CALL_OW 1
42476: ST_TO_ADDR
// mc_bases := Add ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
42477: LD_ADDR_EXP 49
42481: PUSH
42482: LD_EXP 49
42486: PPUSH
42487: LD_VAR 0 3
42491: PUSH
42492: LD_EXP 49
42496: PUSH
42497: LD_VAR 0 3
42501: ARRAY
42502: PUSH
42503: LD_INT 1
42505: PLUS
42506: PUSH
42507: EMPTY
42508: LIST
42509: LIST
42510: PPUSH
42511: LD_VAR 0 1
42515: PPUSH
42516: CALL 50857 0 3
42520: ST_TO_ADDR
// btype := GetBType ( building ) ;
42521: LD_ADDR_VAR 0 5
42525: PUSH
42526: LD_VAR 0 1
42530: PPUSH
42531: CALL_OW 266
42535: ST_TO_ADDR
// side := GetSide ( building ) ;
42536: LD_ADDR_VAR 0 8
42540: PUSH
42541: LD_VAR 0 1
42545: PPUSH
42546: CALL_OW 255
42550: ST_TO_ADDR
// if btype = b_lab then
42551: LD_VAR 0 5
42555: PUSH
42556: LD_INT 6
42558: EQUAL
42559: IFFALSE 42609
// begin mc_lab := Add ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
42561: LD_ADDR_EXP 82
42565: PUSH
42566: LD_EXP 82
42570: PPUSH
42571: LD_VAR 0 3
42575: PUSH
42576: LD_EXP 82
42580: PUSH
42581: LD_VAR 0 3
42585: ARRAY
42586: PUSH
42587: LD_INT 1
42589: PLUS
42590: PUSH
42591: EMPTY
42592: LIST
42593: LIST
42594: PPUSH
42595: LD_VAR 0 1
42599: PPUSH
42600: CALL 50857 0 3
42604: ST_TO_ADDR
// exit ;
42605: POP
42606: POP
42607: GO 43065
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
42609: LD_VAR 0 5
42613: PUSH
42614: LD_INT 0
42616: PUSH
42617: LD_INT 2
42619: PUSH
42620: LD_INT 4
42622: PUSH
42623: EMPTY
42624: LIST
42625: LIST
42626: LIST
42627: IN
42628: IFFALSE 42752
// begin if btype = b_armoury then
42630: LD_VAR 0 5
42634: PUSH
42635: LD_INT 4
42637: EQUAL
42638: IFFALSE 42648
// btype := b_barracks ;
42640: LD_ADDR_VAR 0 5
42644: PUSH
42645: LD_INT 5
42647: ST_TO_ADDR
// if btype = b_depot then
42648: LD_VAR 0 5
42652: PUSH
42653: LD_INT 0
42655: EQUAL
42656: IFFALSE 42666
// btype := b_warehouse ;
42658: LD_ADDR_VAR 0 5
42662: PUSH
42663: LD_INT 1
42665: ST_TO_ADDR
// if btype = b_workshop then
42666: LD_VAR 0 5
42670: PUSH
42671: LD_INT 2
42673: EQUAL
42674: IFFALSE 42684
// btype := b_factory ;
42676: LD_ADDR_VAR 0 5
42680: PUSH
42681: LD_INT 3
42683: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
42684: LD_VAR 0 5
42688: PPUSH
42689: LD_VAR 0 8
42693: PPUSH
42694: CALL_OW 323
42698: PUSH
42699: LD_INT 1
42701: EQUAL
42702: IFFALSE 42748
// mc_build_upgrade := Add ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
42704: LD_ADDR_EXP 81
42708: PUSH
42709: LD_EXP 81
42713: PPUSH
42714: LD_VAR 0 3
42718: PUSH
42719: LD_EXP 81
42723: PUSH
42724: LD_VAR 0 3
42728: ARRAY
42729: PUSH
42730: LD_INT 1
42732: PLUS
42733: PUSH
42734: EMPTY
42735: LIST
42736: LIST
42737: PPUSH
42738: LD_VAR 0 1
42742: PPUSH
42743: CALL 50857 0 3
42747: ST_TO_ADDR
// exit ;
42748: POP
42749: POP
42750: GO 43065
// end ; if btype in [ b_bunker , b_turret ] then
42752: LD_VAR 0 5
42756: PUSH
42757: LD_INT 32
42759: PUSH
42760: LD_INT 33
42762: PUSH
42763: EMPTY
42764: LIST
42765: LIST
42766: IN
42767: IFFALSE 43057
// begin mc_turret_list := Add ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
42769: LD_ADDR_EXP 57
42773: PUSH
42774: LD_EXP 57
42778: PPUSH
42779: LD_VAR 0 3
42783: PUSH
42784: LD_EXP 57
42788: PUSH
42789: LD_VAR 0 3
42793: ARRAY
42794: PUSH
42795: LD_INT 1
42797: PLUS
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PPUSH
42803: LD_VAR 0 1
42807: PPUSH
42808: CALL 50857 0 3
42812: ST_TO_ADDR
// if btype = b_bunker then
42813: LD_VAR 0 5
42817: PUSH
42818: LD_INT 32
42820: EQUAL
42821: IFFALSE 43057
// begin mc_empty_turret_list := Add ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
42823: LD_ADDR_EXP 58
42827: PUSH
42828: LD_EXP 58
42832: PPUSH
42833: LD_VAR 0 3
42837: PUSH
42838: LD_EXP 58
42842: PUSH
42843: LD_VAR 0 3
42847: ARRAY
42848: PUSH
42849: LD_INT 1
42851: PLUS
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: PPUSH
42857: LD_VAR 0 1
42861: PPUSH
42862: CALL 50857 0 3
42866: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
42867: LD_ADDR_VAR 0 6
42871: PUSH
42872: LD_EXP 49
42876: PUSH
42877: LD_VAR 0 3
42881: ARRAY
42882: PPUSH
42883: LD_INT 25
42885: PUSH
42886: LD_INT 1
42888: PUSH
42889: EMPTY
42890: LIST
42891: LIST
42892: PUSH
42893: LD_INT 3
42895: PUSH
42896: LD_INT 54
42898: PUSH
42899: EMPTY
42900: LIST
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: PUSH
42906: EMPTY
42907: LIST
42908: LIST
42909: PPUSH
42910: CALL_OW 72
42914: ST_TO_ADDR
// if tmp then
42915: LD_VAR 0 6
42919: IFFALSE 42925
// exit ;
42921: POP
42922: POP
42923: GO 43065
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
42925: LD_ADDR_VAR 0 6
42929: PUSH
42930: LD_EXP 49
42934: PUSH
42935: LD_VAR 0 3
42939: ARRAY
42940: PPUSH
42941: LD_INT 2
42943: PUSH
42944: LD_INT 30
42946: PUSH
42947: LD_INT 4
42949: PUSH
42950: EMPTY
42951: LIST
42952: LIST
42953: PUSH
42954: LD_INT 30
42956: PUSH
42957: LD_INT 5
42959: PUSH
42960: EMPTY
42961: LIST
42962: LIST
42963: PUSH
42964: EMPTY
42965: LIST
42966: LIST
42967: LIST
42968: PPUSH
42969: CALL_OW 72
42973: ST_TO_ADDR
// if not tmp then
42974: LD_VAR 0 6
42978: NOT
42979: IFFALSE 42985
// exit ;
42981: POP
42982: POP
42983: GO 43065
// for j in tmp do
42985: LD_ADDR_VAR 0 4
42989: PUSH
42990: LD_VAR 0 6
42994: PUSH
42995: FOR_IN
42996: IFFALSE 43055
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
42998: LD_ADDR_VAR 0 7
43002: PUSH
43003: LD_VAR 0 4
43007: PPUSH
43008: CALL_OW 313
43012: PPUSH
43013: LD_INT 25
43015: PUSH
43016: LD_INT 1
43018: PUSH
43019: EMPTY
43020: LIST
43021: LIST
43022: PPUSH
43023: CALL_OW 72
43027: ST_TO_ADDR
// if units then
43028: LD_VAR 0 7
43032: IFFALSE 43053
// begin ComExitBuilding ( units [ 1 ] ) ;
43034: LD_VAR 0 7
43038: PUSH
43039: LD_INT 1
43041: ARRAY
43042: PPUSH
43043: CALL_OW 122
// exit ;
43047: POP
43048: POP
43049: POP
43050: POP
43051: GO 43065
// end ; end ;
43053: GO 42995
43055: POP
43056: POP
// end ; end ; exit ;
43057: POP
43058: POP
43059: GO 43065
// end ; end ;
43061: GO 42419
43063: POP
43064: POP
// end ;
43065: LD_VAR 0 2
43069: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
43070: LD_INT 0
43072: PPUSH
43073: PPUSH
43074: PPUSH
43075: PPUSH
43076: PPUSH
43077: PPUSH
43078: PPUSH
// if not mc_bases then
43079: LD_EXP 49
43083: NOT
43084: IFFALSE 43088
// exit ;
43086: GO 43319
// btype := GetBType ( building ) ;
43088: LD_ADDR_VAR 0 6
43092: PUSH
43093: LD_VAR 0 1
43097: PPUSH
43098: CALL_OW 266
43102: ST_TO_ADDR
// x := GetX ( building ) ;
43103: LD_ADDR_VAR 0 7
43107: PUSH
43108: LD_VAR 0 1
43112: PPUSH
43113: CALL_OW 250
43117: ST_TO_ADDR
// y := GetY ( building ) ;
43118: LD_ADDR_VAR 0 8
43122: PUSH
43123: LD_VAR 0 1
43127: PPUSH
43128: CALL_OW 251
43132: ST_TO_ADDR
// d := GetDir ( building ) ;
43133: LD_ADDR_VAR 0 9
43137: PUSH
43138: LD_VAR 0 1
43142: PPUSH
43143: CALL_OW 254
43147: ST_TO_ADDR
// for i = 1 to mc_bases do
43148: LD_ADDR_VAR 0 4
43152: PUSH
43153: DOUBLE
43154: LD_INT 1
43156: DEC
43157: ST_TO_ADDR
43158: LD_EXP 49
43162: PUSH
43163: FOR_TO
43164: IFFALSE 43317
// begin if not mc_build_list [ i ] then
43166: LD_EXP 54
43170: PUSH
43171: LD_VAR 0 4
43175: ARRAY
43176: NOT
43177: IFFALSE 43181
// continue ;
43179: GO 43163
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
43181: LD_VAR 0 6
43185: PUSH
43186: LD_VAR 0 7
43190: PUSH
43191: LD_VAR 0 8
43195: PUSH
43196: LD_VAR 0 9
43200: PUSH
43201: EMPTY
43202: LIST
43203: LIST
43204: LIST
43205: LIST
43206: PPUSH
43207: LD_EXP 54
43211: PUSH
43212: LD_VAR 0 4
43216: ARRAY
43217: PUSH
43218: LD_INT 1
43220: ARRAY
43221: PPUSH
43222: CALL 56494 0 2
43226: IFFALSE 43315
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
43228: LD_ADDR_EXP 54
43232: PUSH
43233: LD_EXP 54
43237: PPUSH
43238: LD_VAR 0 4
43242: PPUSH
43243: LD_EXP 54
43247: PUSH
43248: LD_VAR 0 4
43252: ARRAY
43253: PPUSH
43254: LD_INT 1
43256: PPUSH
43257: CALL_OW 3
43261: PPUSH
43262: CALL_OW 1
43266: ST_TO_ADDR
// mc_construct_list := Add ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
43267: LD_ADDR_EXP 56
43271: PUSH
43272: LD_EXP 56
43276: PPUSH
43277: LD_VAR 0 4
43281: PUSH
43282: LD_EXP 56
43286: PUSH
43287: LD_VAR 0 4
43291: ARRAY
43292: PUSH
43293: LD_INT 1
43295: PLUS
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PPUSH
43301: LD_VAR 0 1
43305: PPUSH
43306: CALL 50857 0 3
43310: ST_TO_ADDR
// exit ;
43311: POP
43312: POP
43313: GO 43319
// end ; end ;
43315: GO 43163
43317: POP
43318: POP
// end ;
43319: LD_VAR 0 3
43323: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
43324: LD_INT 0
43326: PPUSH
43327: PPUSH
43328: PPUSH
// if not mc_bases then
43329: LD_EXP 49
43333: NOT
43334: IFFALSE 43338
// exit ;
43336: GO 43528
// for i = 1 to mc_bases do
43338: LD_ADDR_VAR 0 4
43342: PUSH
43343: DOUBLE
43344: LD_INT 1
43346: DEC
43347: ST_TO_ADDR
43348: LD_EXP 49
43352: PUSH
43353: FOR_TO
43354: IFFALSE 43441
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
43356: LD_VAR 0 1
43360: PUSH
43361: LD_EXP 57
43365: PUSH
43366: LD_VAR 0 4
43370: ARRAY
43371: IN
43372: PUSH
43373: LD_VAR 0 1
43377: PUSH
43378: LD_EXP 58
43382: PUSH
43383: LD_VAR 0 4
43387: ARRAY
43388: IN
43389: NOT
43390: AND
43391: IFFALSE 43439
// begin mc_empty_turret_list := Add ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
43393: LD_ADDR_EXP 58
43397: PUSH
43398: LD_EXP 58
43402: PPUSH
43403: LD_VAR 0 4
43407: PUSH
43408: LD_EXP 58
43412: PUSH
43413: LD_VAR 0 4
43417: ARRAY
43418: PUSH
43419: LD_INT 1
43421: PLUS
43422: PUSH
43423: EMPTY
43424: LIST
43425: LIST
43426: PPUSH
43427: LD_VAR 0 1
43431: PPUSH
43432: CALL 50857 0 3
43436: ST_TO_ADDR
// break ;
43437: GO 43441
// end ; end ;
43439: GO 43353
43441: POP
43442: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
43443: LD_VAR 0 1
43447: PPUSH
43448: CALL_OW 257
43452: PUSH
43453: LD_EXP 75
43457: IN
43458: PUSH
43459: LD_VAR 0 1
43463: PPUSH
43464: CALL_OW 266
43468: PUSH
43469: LD_INT 5
43471: EQUAL
43472: AND
43473: PUSH
43474: LD_VAR 0 2
43478: PPUSH
43479: CALL_OW 110
43483: PUSH
43484: LD_INT 18
43486: NONEQUAL
43487: AND
43488: IFFALSE 43528
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
43490: LD_VAR 0 2
43494: PPUSH
43495: CALL_OW 257
43499: PUSH
43500: LD_INT 5
43502: PUSH
43503: LD_INT 8
43505: PUSH
43506: LD_INT 9
43508: PUSH
43509: EMPTY
43510: LIST
43511: LIST
43512: LIST
43513: IN
43514: IFFALSE 43528
// SetClass ( unit , 1 ) ;
43516: LD_VAR 0 2
43520: PPUSH
43521: LD_INT 1
43523: PPUSH
43524: CALL_OW 336
// end ;
43528: LD_VAR 0 3
43532: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
43533: LD_INT 0
43535: PPUSH
43536: PPUSH
// if not mc_bases then
43537: LD_EXP 49
43541: NOT
43542: IFFALSE 43546
// exit ;
43544: GO 43662
// if GetLives ( abandoned_vehicle ) > 250 then
43546: LD_VAR 0 2
43550: PPUSH
43551: CALL_OW 256
43555: PUSH
43556: LD_INT 250
43558: GREATER
43559: IFFALSE 43563
// exit ;
43561: GO 43662
// for i = 1 to mc_bases do
43563: LD_ADDR_VAR 0 6
43567: PUSH
43568: DOUBLE
43569: LD_INT 1
43571: DEC
43572: ST_TO_ADDR
43573: LD_EXP 49
43577: PUSH
43578: FOR_TO
43579: IFFALSE 43660
// begin if driver in mc_bases [ i ] then
43581: LD_VAR 0 1
43585: PUSH
43586: LD_EXP 49
43590: PUSH
43591: LD_VAR 0 6
43595: ARRAY
43596: IN
43597: IFFALSE 43658
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
43599: LD_VAR 0 1
43603: PPUSH
43604: LD_EXP 49
43608: PUSH
43609: LD_VAR 0 6
43613: ARRAY
43614: PPUSH
43615: LD_INT 2
43617: PUSH
43618: LD_INT 30
43620: PUSH
43621: LD_INT 0
43623: PUSH
43624: EMPTY
43625: LIST
43626: LIST
43627: PUSH
43628: LD_INT 30
43630: PUSH
43631: LD_INT 1
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: PUSH
43638: EMPTY
43639: LIST
43640: LIST
43641: LIST
43642: PPUSH
43643: CALL_OW 72
43647: PUSH
43648: LD_INT 1
43650: ARRAY
43651: PPUSH
43652: CALL_OW 112
// break ;
43656: GO 43660
// end ; end ;
43658: GO 43578
43660: POP
43661: POP
// end ; end_of_file
43662: LD_VAR 0 5
43666: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
43667: LD_INT 0
43669: PPUSH
43670: PPUSH
// if exist_mode then
43671: LD_VAR 0 2
43675: IFFALSE 43700
// unit := CreateCharacter ( prefix & ident ) else
43677: LD_ADDR_VAR 0 5
43681: PUSH
43682: LD_VAR 0 3
43686: PUSH
43687: LD_VAR 0 1
43691: STR
43692: PPUSH
43693: CALL_OW 34
43697: ST_TO_ADDR
43698: GO 43715
// unit := NewCharacter ( ident ) ;
43700: LD_ADDR_VAR 0 5
43704: PUSH
43705: LD_VAR 0 1
43709: PPUSH
43710: CALL_OW 25
43714: ST_TO_ADDR
// result := unit ;
43715: LD_ADDR_VAR 0 4
43719: PUSH
43720: LD_VAR 0 5
43724: ST_TO_ADDR
// end ;
43725: LD_VAR 0 4
43729: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
43730: LD_INT 0
43732: PPUSH
43733: PPUSH
// if not side or not nation then
43734: LD_VAR 0 1
43738: NOT
43739: PUSH
43740: LD_VAR 0 2
43744: NOT
43745: OR
43746: IFFALSE 43750
// exit ;
43748: GO 44386
// case nation of nation_american :
43750: LD_VAR 0 2
43754: PUSH
43755: LD_INT 1
43757: DOUBLE
43758: EQUAL
43759: IFTRUE 43763
43761: GO 43933
43763: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
43764: LD_ADDR_VAR 0 4
43768: PUSH
43769: LD_INT 35
43771: PUSH
43772: LD_INT 45
43774: PUSH
43775: LD_INT 46
43777: PUSH
43778: LD_INT 47
43780: PUSH
43781: LD_INT 1
43783: PUSH
43784: LD_INT 2
43786: PUSH
43787: LD_INT 6
43789: PUSH
43790: LD_INT 15
43792: PUSH
43793: LD_INT 16
43795: PUSH
43796: LD_INT 7
43798: PUSH
43799: LD_INT 12
43801: PUSH
43802: LD_INT 13
43804: PUSH
43805: LD_INT 10
43807: PUSH
43808: LD_INT 14
43810: PUSH
43811: LD_INT 20
43813: PUSH
43814: LD_INT 21
43816: PUSH
43817: LD_INT 22
43819: PUSH
43820: LD_INT 25
43822: PUSH
43823: LD_INT 32
43825: PUSH
43826: LD_INT 27
43828: PUSH
43829: LD_INT 36
43831: PUSH
43832: LD_INT 69
43834: PUSH
43835: LD_INT 39
43837: PUSH
43838: LD_INT 34
43840: PUSH
43841: LD_INT 40
43843: PUSH
43844: LD_INT 48
43846: PUSH
43847: LD_INT 49
43849: PUSH
43850: LD_INT 50
43852: PUSH
43853: LD_INT 51
43855: PUSH
43856: LD_INT 52
43858: PUSH
43859: LD_INT 53
43861: PUSH
43862: LD_INT 54
43864: PUSH
43865: LD_INT 55
43867: PUSH
43868: LD_INT 56
43870: PUSH
43871: LD_INT 57
43873: PUSH
43874: LD_INT 58
43876: PUSH
43877: LD_INT 59
43879: PUSH
43880: LD_INT 60
43882: PUSH
43883: LD_INT 61
43885: PUSH
43886: LD_INT 62
43888: PUSH
43889: EMPTY
43890: LIST
43891: LIST
43892: LIST
43893: LIST
43894: LIST
43895: LIST
43896: LIST
43897: LIST
43898: LIST
43899: LIST
43900: LIST
43901: LIST
43902: LIST
43903: LIST
43904: LIST
43905: LIST
43906: LIST
43907: LIST
43908: LIST
43909: LIST
43910: LIST
43911: LIST
43912: LIST
43913: LIST
43914: LIST
43915: LIST
43916: LIST
43917: LIST
43918: LIST
43919: LIST
43920: LIST
43921: LIST
43922: LIST
43923: LIST
43924: LIST
43925: LIST
43926: LIST
43927: LIST
43928: LIST
43929: LIST
43930: ST_TO_ADDR
43931: GO 44310
43933: LD_INT 2
43935: DOUBLE
43936: EQUAL
43937: IFTRUE 43941
43939: GO 44119
43941: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
43942: LD_ADDR_VAR 0 4
43946: PUSH
43947: LD_INT 35
43949: PUSH
43950: LD_INT 45
43952: PUSH
43953: LD_INT 46
43955: PUSH
43956: LD_INT 47
43958: PUSH
43959: LD_INT 70
43961: PUSH
43962: LD_INT 1
43964: PUSH
43965: LD_INT 11
43967: PUSH
43968: LD_INT 3
43970: PUSH
43971: LD_INT 4
43973: PUSH
43974: LD_INT 5
43976: PUSH
43977: LD_INT 6
43979: PUSH
43980: LD_INT 15
43982: PUSH
43983: LD_INT 18
43985: PUSH
43986: LD_INT 7
43988: PUSH
43989: LD_INT 17
43991: PUSH
43992: LD_INT 8
43994: PUSH
43995: LD_INT 20
43997: PUSH
43998: LD_INT 21
44000: PUSH
44001: LD_INT 22
44003: PUSH
44004: LD_INT 72
44006: PUSH
44007: LD_INT 26
44009: PUSH
44010: LD_INT 69
44012: PUSH
44013: LD_INT 39
44015: PUSH
44016: LD_INT 40
44018: PUSH
44019: LD_INT 41
44021: PUSH
44022: LD_INT 42
44024: PUSH
44025: LD_INT 43
44027: PUSH
44028: LD_INT 48
44030: PUSH
44031: LD_INT 49
44033: PUSH
44034: LD_INT 50
44036: PUSH
44037: LD_INT 51
44039: PUSH
44040: LD_INT 52
44042: PUSH
44043: LD_INT 53
44045: PUSH
44046: LD_INT 54
44048: PUSH
44049: LD_INT 55
44051: PUSH
44052: LD_INT 56
44054: PUSH
44055: LD_INT 60
44057: PUSH
44058: LD_INT 61
44060: PUSH
44061: LD_INT 62
44063: PUSH
44064: LD_INT 66
44066: PUSH
44067: LD_INT 67
44069: PUSH
44070: LD_INT 68
44072: PUSH
44073: EMPTY
44074: LIST
44075: LIST
44076: LIST
44077: LIST
44078: LIST
44079: LIST
44080: LIST
44081: LIST
44082: LIST
44083: LIST
44084: LIST
44085: LIST
44086: LIST
44087: LIST
44088: LIST
44089: LIST
44090: LIST
44091: LIST
44092: LIST
44093: LIST
44094: LIST
44095: LIST
44096: LIST
44097: LIST
44098: LIST
44099: LIST
44100: LIST
44101: LIST
44102: LIST
44103: LIST
44104: LIST
44105: LIST
44106: LIST
44107: LIST
44108: LIST
44109: LIST
44110: LIST
44111: LIST
44112: LIST
44113: LIST
44114: LIST
44115: LIST
44116: ST_TO_ADDR
44117: GO 44310
44119: LD_INT 3
44121: DOUBLE
44122: EQUAL
44123: IFTRUE 44127
44125: GO 44309
44127: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
44128: LD_ADDR_VAR 0 4
44132: PUSH
44133: LD_INT 46
44135: PUSH
44136: LD_INT 47
44138: PUSH
44139: LD_INT 1
44141: PUSH
44142: LD_INT 2
44144: PUSH
44145: LD_INT 11
44147: PUSH
44148: LD_INT 9
44150: PUSH
44151: LD_INT 20
44153: PUSH
44154: LD_INT 19
44156: PUSH
44157: LD_INT 21
44159: PUSH
44160: LD_INT 24
44162: PUSH
44163: LD_INT 22
44165: PUSH
44166: LD_INT 25
44168: PUSH
44169: LD_INT 28
44171: PUSH
44172: LD_INT 29
44174: PUSH
44175: LD_INT 30
44177: PUSH
44178: LD_INT 31
44180: PUSH
44181: LD_INT 37
44183: PUSH
44184: LD_INT 38
44186: PUSH
44187: LD_INT 32
44189: PUSH
44190: LD_INT 27
44192: PUSH
44193: LD_INT 33
44195: PUSH
44196: LD_INT 69
44198: PUSH
44199: LD_INT 39
44201: PUSH
44202: LD_INT 34
44204: PUSH
44205: LD_INT 40
44207: PUSH
44208: LD_INT 71
44210: PUSH
44211: LD_INT 23
44213: PUSH
44214: LD_INT 44
44216: PUSH
44217: LD_INT 48
44219: PUSH
44220: LD_INT 49
44222: PUSH
44223: LD_INT 50
44225: PUSH
44226: LD_INT 51
44228: PUSH
44229: LD_INT 52
44231: PUSH
44232: LD_INT 53
44234: PUSH
44235: LD_INT 54
44237: PUSH
44238: LD_INT 55
44240: PUSH
44241: LD_INT 56
44243: PUSH
44244: LD_INT 57
44246: PUSH
44247: LD_INT 58
44249: PUSH
44250: LD_INT 59
44252: PUSH
44253: LD_INT 63
44255: PUSH
44256: LD_INT 64
44258: PUSH
44259: LD_INT 65
44261: PUSH
44262: EMPTY
44263: LIST
44264: LIST
44265: LIST
44266: LIST
44267: LIST
44268: LIST
44269: LIST
44270: LIST
44271: LIST
44272: LIST
44273: LIST
44274: LIST
44275: LIST
44276: LIST
44277: LIST
44278: LIST
44279: LIST
44280: LIST
44281: LIST
44282: LIST
44283: LIST
44284: LIST
44285: LIST
44286: LIST
44287: LIST
44288: LIST
44289: LIST
44290: LIST
44291: LIST
44292: LIST
44293: LIST
44294: LIST
44295: LIST
44296: LIST
44297: LIST
44298: LIST
44299: LIST
44300: LIST
44301: LIST
44302: LIST
44303: LIST
44304: LIST
44305: LIST
44306: ST_TO_ADDR
44307: GO 44310
44309: POP
// if state > - 1 and state < 3 then
44310: LD_VAR 0 3
44314: PUSH
44315: LD_INT 1
44317: NEG
44318: GREATER
44319: PUSH
44320: LD_VAR 0 3
44324: PUSH
44325: LD_INT 3
44327: LESS
44328: AND
44329: IFFALSE 44386
// for i in result do
44331: LD_ADDR_VAR 0 5
44335: PUSH
44336: LD_VAR 0 4
44340: PUSH
44341: FOR_IN
44342: IFFALSE 44384
// if GetTech ( i , side ) <> state then
44344: LD_VAR 0 5
44348: PPUSH
44349: LD_VAR 0 1
44353: PPUSH
44354: CALL_OW 321
44358: PUSH
44359: LD_VAR 0 3
44363: NONEQUAL
44364: IFFALSE 44382
// result := result diff i ;
44366: LD_ADDR_VAR 0 4
44370: PUSH
44371: LD_VAR 0 4
44375: PUSH
44376: LD_VAR 0 5
44380: DIFF
44381: ST_TO_ADDR
44382: GO 44341
44384: POP
44385: POP
// end ;
44386: LD_VAR 0 4
44390: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
44391: LD_INT 0
44393: PPUSH
44394: PPUSH
44395: PPUSH
// result := true ;
44396: LD_ADDR_VAR 0 3
44400: PUSH
44401: LD_INT 1
44403: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
44404: LD_ADDR_VAR 0 5
44408: PUSH
44409: LD_VAR 0 2
44413: PPUSH
44414: CALL_OW 480
44418: ST_TO_ADDR
// if not tmp then
44419: LD_VAR 0 5
44423: NOT
44424: IFFALSE 44428
// exit ;
44426: GO 44477
// for i in tmp do
44428: LD_ADDR_VAR 0 4
44432: PUSH
44433: LD_VAR 0 5
44437: PUSH
44438: FOR_IN
44439: IFFALSE 44475
// if GetTech ( i , side ) <> state_researched then
44441: LD_VAR 0 4
44445: PPUSH
44446: LD_VAR 0 1
44450: PPUSH
44451: CALL_OW 321
44455: PUSH
44456: LD_INT 2
44458: NONEQUAL
44459: IFFALSE 44473
// begin result := false ;
44461: LD_ADDR_VAR 0 3
44465: PUSH
44466: LD_INT 0
44468: ST_TO_ADDR
// exit ;
44469: POP
44470: POP
44471: GO 44477
// end ;
44473: GO 44438
44475: POP
44476: POP
// end ;
44477: LD_VAR 0 3
44481: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
44482: LD_INT 0
44484: PPUSH
44485: PPUSH
44486: PPUSH
44487: PPUSH
44488: PPUSH
44489: PPUSH
44490: PPUSH
44491: PPUSH
44492: PPUSH
44493: PPUSH
44494: PPUSH
44495: PPUSH
44496: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
44497: LD_VAR 0 1
44501: NOT
44502: PUSH
44503: LD_VAR 0 1
44507: PPUSH
44508: CALL_OW 257
44512: PUSH
44513: LD_INT 9
44515: NONEQUAL
44516: OR
44517: IFFALSE 44521
// exit ;
44519: GO 45094
// side := GetSide ( unit ) ;
44521: LD_ADDR_VAR 0 9
44525: PUSH
44526: LD_VAR 0 1
44530: PPUSH
44531: CALL_OW 255
44535: ST_TO_ADDR
// tech_space := tech_spacanom ;
44536: LD_ADDR_VAR 0 12
44540: PUSH
44541: LD_INT 29
44543: ST_TO_ADDR
// tech_time := tech_taurad ;
44544: LD_ADDR_VAR 0 13
44548: PUSH
44549: LD_INT 28
44551: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
44552: LD_ADDR_VAR 0 11
44556: PUSH
44557: LD_VAR 0 1
44561: PPUSH
44562: CALL_OW 310
44566: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
44567: LD_VAR 0 11
44571: PPUSH
44572: CALL_OW 247
44576: PUSH
44577: LD_INT 2
44579: EQUAL
44580: IFFALSE 44584
// exit ;
44582: GO 45094
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
44584: LD_ADDR_VAR 0 8
44588: PUSH
44589: LD_INT 81
44591: PUSH
44592: LD_VAR 0 9
44596: PUSH
44597: EMPTY
44598: LIST
44599: LIST
44600: PUSH
44601: LD_INT 3
44603: PUSH
44604: LD_INT 21
44606: PUSH
44607: LD_INT 3
44609: PUSH
44610: EMPTY
44611: LIST
44612: LIST
44613: PUSH
44614: EMPTY
44615: LIST
44616: LIST
44617: PUSH
44618: EMPTY
44619: LIST
44620: LIST
44621: PPUSH
44622: CALL_OW 69
44626: ST_TO_ADDR
// if not tmp then
44627: LD_VAR 0 8
44631: NOT
44632: IFFALSE 44636
// exit ;
44634: GO 45094
// if in_unit then
44636: LD_VAR 0 11
44640: IFFALSE 44664
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
44642: LD_ADDR_VAR 0 10
44646: PUSH
44647: LD_VAR 0 8
44651: PPUSH
44652: LD_VAR 0 11
44656: PPUSH
44657: CALL_OW 74
44661: ST_TO_ADDR
44662: GO 44684
// enemy := NearestUnitToUnit ( tmp , unit ) ;
44664: LD_ADDR_VAR 0 10
44668: PUSH
44669: LD_VAR 0 8
44673: PPUSH
44674: LD_VAR 0 1
44678: PPUSH
44679: CALL_OW 74
44683: ST_TO_ADDR
// if not enemy then
44684: LD_VAR 0 10
44688: NOT
44689: IFFALSE 44693
// exit ;
44691: GO 45094
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
44693: LD_VAR 0 11
44697: PUSH
44698: LD_VAR 0 11
44702: PPUSH
44703: LD_VAR 0 10
44707: PPUSH
44708: CALL_OW 296
44712: PUSH
44713: LD_INT 13
44715: GREATER
44716: AND
44717: PUSH
44718: LD_VAR 0 1
44722: PPUSH
44723: LD_VAR 0 10
44727: PPUSH
44728: CALL_OW 296
44732: PUSH
44733: LD_INT 12
44735: GREATER
44736: OR
44737: IFFALSE 44741
// exit ;
44739: GO 45094
// missile := [ 1 ] ;
44741: LD_ADDR_VAR 0 14
44745: PUSH
44746: LD_INT 1
44748: PUSH
44749: EMPTY
44750: LIST
44751: ST_TO_ADDR
// if Researched ( side , tech_space ) then
44752: LD_VAR 0 9
44756: PPUSH
44757: LD_VAR 0 12
44761: PPUSH
44762: CALL_OW 325
44766: IFFALSE 44795
// missile := Insert ( missile , missile + 1 , 2 ) ;
44768: LD_ADDR_VAR 0 14
44772: PUSH
44773: LD_VAR 0 14
44777: PPUSH
44778: LD_VAR 0 14
44782: PUSH
44783: LD_INT 1
44785: PLUS
44786: PPUSH
44787: LD_INT 2
44789: PPUSH
44790: CALL_OW 2
44794: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
44795: LD_VAR 0 9
44799: PPUSH
44800: LD_VAR 0 13
44804: PPUSH
44805: CALL_OW 325
44809: PUSH
44810: LD_VAR 0 10
44814: PPUSH
44815: CALL_OW 255
44819: PPUSH
44820: LD_VAR 0 13
44824: PPUSH
44825: CALL_OW 325
44829: NOT
44830: AND
44831: IFFALSE 44860
// missile := Insert ( missile , missile + 1 , 3 ) ;
44833: LD_ADDR_VAR 0 14
44837: PUSH
44838: LD_VAR 0 14
44842: PPUSH
44843: LD_VAR 0 14
44847: PUSH
44848: LD_INT 1
44850: PLUS
44851: PPUSH
44852: LD_INT 3
44854: PPUSH
44855: CALL_OW 2
44859: ST_TO_ADDR
// if missile < 2 then
44860: LD_VAR 0 14
44864: PUSH
44865: LD_INT 2
44867: LESS
44868: IFFALSE 44872
// exit ;
44870: GO 45094
// x := GetX ( enemy ) ;
44872: LD_ADDR_VAR 0 4
44876: PUSH
44877: LD_VAR 0 10
44881: PPUSH
44882: CALL_OW 250
44886: ST_TO_ADDR
// y := GetY ( enemy ) ;
44887: LD_ADDR_VAR 0 5
44891: PUSH
44892: LD_VAR 0 10
44896: PPUSH
44897: CALL_OW 251
44901: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
44902: LD_ADDR_VAR 0 6
44906: PUSH
44907: LD_VAR 0 4
44911: PUSH
44912: LD_INT 1
44914: NEG
44915: PPUSH
44916: LD_INT 1
44918: PPUSH
44919: CALL_OW 12
44923: PLUS
44924: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
44925: LD_ADDR_VAR 0 7
44929: PUSH
44930: LD_VAR 0 5
44934: PUSH
44935: LD_INT 1
44937: NEG
44938: PPUSH
44939: LD_INT 1
44941: PPUSH
44942: CALL_OW 12
44946: PLUS
44947: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
44948: LD_VAR 0 6
44952: PPUSH
44953: LD_VAR 0 7
44957: PPUSH
44958: CALL_OW 488
44962: NOT
44963: IFFALSE 44985
// begin _x := x ;
44965: LD_ADDR_VAR 0 6
44969: PUSH
44970: LD_VAR 0 4
44974: ST_TO_ADDR
// _y := y ;
44975: LD_ADDR_VAR 0 7
44979: PUSH
44980: LD_VAR 0 5
44984: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
44985: LD_ADDR_VAR 0 3
44989: PUSH
44990: LD_INT 1
44992: PPUSH
44993: LD_VAR 0 14
44997: PPUSH
44998: CALL_OW 12
45002: ST_TO_ADDR
// case i of 1 :
45003: LD_VAR 0 3
45007: PUSH
45008: LD_INT 1
45010: DOUBLE
45011: EQUAL
45012: IFTRUE 45016
45014: GO 45033
45016: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
45017: LD_VAR 0 1
45021: PPUSH
45022: LD_VAR 0 10
45026: PPUSH
45027: CALL_OW 115
45031: GO 45094
45033: LD_INT 2
45035: DOUBLE
45036: EQUAL
45037: IFTRUE 45041
45039: GO 45063
45041: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
45042: LD_VAR 0 1
45046: PPUSH
45047: LD_VAR 0 6
45051: PPUSH
45052: LD_VAR 0 7
45056: PPUSH
45057: CALL_OW 153
45061: GO 45094
45063: LD_INT 3
45065: DOUBLE
45066: EQUAL
45067: IFTRUE 45071
45069: GO 45093
45071: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
45072: LD_VAR 0 1
45076: PPUSH
45077: LD_VAR 0 6
45081: PPUSH
45082: LD_VAR 0 7
45086: PPUSH
45087: CALL_OW 154
45091: GO 45094
45093: POP
// end ;
45094: LD_VAR 0 2
45098: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
45099: LD_INT 0
45101: PPUSH
45102: PPUSH
45103: PPUSH
45104: PPUSH
45105: PPUSH
45106: PPUSH
// if not unit or not building then
45107: LD_VAR 0 1
45111: NOT
45112: PUSH
45113: LD_VAR 0 2
45117: NOT
45118: OR
45119: IFFALSE 45123
// exit ;
45121: GO 45281
// x := GetX ( building ) ;
45123: LD_ADDR_VAR 0 5
45127: PUSH
45128: LD_VAR 0 2
45132: PPUSH
45133: CALL_OW 250
45137: ST_TO_ADDR
// y := GetY ( building ) ;
45138: LD_ADDR_VAR 0 6
45142: PUSH
45143: LD_VAR 0 2
45147: PPUSH
45148: CALL_OW 251
45152: ST_TO_ADDR
// for i = 0 to 5 do
45153: LD_ADDR_VAR 0 4
45157: PUSH
45158: DOUBLE
45159: LD_INT 0
45161: DEC
45162: ST_TO_ADDR
45163: LD_INT 5
45165: PUSH
45166: FOR_TO
45167: IFFALSE 45279
// begin _x := ShiftX ( x , i , 3 ) ;
45169: LD_ADDR_VAR 0 7
45173: PUSH
45174: LD_VAR 0 5
45178: PPUSH
45179: LD_VAR 0 4
45183: PPUSH
45184: LD_INT 3
45186: PPUSH
45187: CALL_OW 272
45191: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
45192: LD_ADDR_VAR 0 8
45196: PUSH
45197: LD_VAR 0 6
45201: PPUSH
45202: LD_VAR 0 4
45206: PPUSH
45207: LD_INT 3
45209: PPUSH
45210: CALL_OW 273
45214: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
45215: LD_VAR 0 7
45219: PPUSH
45220: LD_VAR 0 8
45224: PPUSH
45225: CALL_OW 488
45229: NOT
45230: IFFALSE 45234
// continue ;
45232: GO 45166
// if HexInfo ( _x , _y ) = 0 then
45234: LD_VAR 0 7
45238: PPUSH
45239: LD_VAR 0 8
45243: PPUSH
45244: CALL_OW 428
45248: PUSH
45249: LD_INT 0
45251: EQUAL
45252: IFFALSE 45277
// begin ComMoveXY ( unit , _x , _y ) ;
45254: LD_VAR 0 1
45258: PPUSH
45259: LD_VAR 0 7
45263: PPUSH
45264: LD_VAR 0 8
45268: PPUSH
45269: CALL_OW 111
// exit ;
45273: POP
45274: POP
45275: GO 45281
// end ; end ;
45277: GO 45166
45279: POP
45280: POP
// end ;
45281: LD_VAR 0 3
45285: RET
// export function ScanBase ( side , base_area ) ; begin
45286: LD_INT 0
45288: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
45289: LD_ADDR_VAR 0 3
45293: PUSH
45294: LD_VAR 0 2
45298: PPUSH
45299: LD_INT 81
45301: PUSH
45302: LD_VAR 0 1
45306: PUSH
45307: EMPTY
45308: LIST
45309: LIST
45310: PPUSH
45311: CALL_OW 70
45315: ST_TO_ADDR
// end ;
45316: LD_VAR 0 3
45320: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
45321: LD_INT 0
45323: PPUSH
45324: PPUSH
45325: PPUSH
45326: PPUSH
45327: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
45328: LD_VAR 0 1
45332: NOT
45333: PUSH
45334: LD_EXP 49
45338: PUSH
45339: LD_VAR 0 1
45343: ARRAY
45344: NOT
45345: OR
45346: PUSH
45347: LD_VAR 0 2
45351: NOT
45352: OR
45353: PUSH
45354: LD_VAR 0 3
45358: NOT
45359: OR
45360: IFFALSE 45364
// exit ;
45362: GO 45814
// side := mc_sides [ base ] ;
45364: LD_ADDR_VAR 0 6
45368: PUSH
45369: LD_EXP 75
45373: PUSH
45374: LD_VAR 0 1
45378: ARRAY
45379: ST_TO_ADDR
// if not side then
45380: LD_VAR 0 6
45384: NOT
45385: IFFALSE 45389
// exit ;
45387: GO 45814
// for i in solds do
45389: LD_ADDR_VAR 0 7
45393: PUSH
45394: LD_VAR 0 2
45398: PUSH
45399: FOR_IN
45400: IFFALSE 45461
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
45402: LD_VAR 0 7
45406: PPUSH
45407: CALL_OW 310
45411: PPUSH
45412: CALL_OW 266
45416: PUSH
45417: LD_INT 32
45419: PUSH
45420: LD_INT 31
45422: PUSH
45423: EMPTY
45424: LIST
45425: LIST
45426: IN
45427: IFFALSE 45447
// solds := solds diff i else
45429: LD_ADDR_VAR 0 2
45433: PUSH
45434: LD_VAR 0 2
45438: PUSH
45439: LD_VAR 0 7
45443: DIFF
45444: ST_TO_ADDR
45445: GO 45459
// SetTag ( i , 18 ) ;
45447: LD_VAR 0 7
45451: PPUSH
45452: LD_INT 18
45454: PPUSH
45455: CALL_OW 109
45459: GO 45399
45461: POP
45462: POP
// if not solds then
45463: LD_VAR 0 2
45467: NOT
45468: IFFALSE 45472
// exit ;
45470: GO 45814
// repeat wait ( 0 0$1 ) ;
45472: LD_INT 35
45474: PPUSH
45475: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
45479: LD_ADDR_VAR 0 5
45483: PUSH
45484: LD_VAR 0 6
45488: PPUSH
45489: LD_VAR 0 3
45493: PPUSH
45494: CALL 45286 0 2
45498: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
45499: LD_VAR 0 5
45503: NOT
45504: PUSH
45505: LD_VAR 0 5
45509: PUSH
45510: LD_INT 3
45512: GREATER
45513: OR
45514: PUSH
45515: LD_EXP 71
45519: PUSH
45520: LD_VAR 0 1
45524: ARRAY
45525: OR
45526: IFFALSE 45567
// begin for i in solds do
45528: LD_ADDR_VAR 0 7
45532: PUSH
45533: LD_VAR 0 2
45537: PUSH
45538: FOR_IN
45539: IFFALSE 45563
// if HasTask ( i ) then
45541: LD_VAR 0 7
45545: PPUSH
45546: CALL_OW 314
45550: IFFALSE 45561
// ComStop ( i ) ;
45552: LD_VAR 0 7
45556: PPUSH
45557: CALL_OW 141
45561: GO 45538
45563: POP
45564: POP
// break ;
45565: GO 45802
// end ; for i in solds do
45567: LD_ADDR_VAR 0 7
45571: PUSH
45572: LD_VAR 0 2
45576: PUSH
45577: FOR_IN
45578: IFFALSE 45794
// begin if IsInUnit ( i ) then
45580: LD_VAR 0 7
45584: PPUSH
45585: CALL_OW 310
45589: IFFALSE 45600
// ComExitBuilding ( i ) ;
45591: LD_VAR 0 7
45595: PPUSH
45596: CALL_OW 122
// if GetLives ( i ) > 333 then
45600: LD_VAR 0 7
45604: PPUSH
45605: CALL_OW 256
45609: PUSH
45610: LD_INT 333
45612: GREATER
45613: IFFALSE 45641
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
45615: LD_VAR 0 7
45619: PPUSH
45620: LD_VAR 0 5
45624: PPUSH
45625: LD_VAR 0 7
45629: PPUSH
45630: CALL_OW 74
45634: PPUSH
45635: CALL_OW 115
45639: GO 45792
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
45641: LD_ADDR_VAR 0 8
45645: PUSH
45646: LD_EXP 49
45650: PUSH
45651: LD_VAR 0 1
45655: ARRAY
45656: PPUSH
45657: LD_INT 2
45659: PUSH
45660: LD_INT 30
45662: PUSH
45663: LD_INT 0
45665: PUSH
45666: EMPTY
45667: LIST
45668: LIST
45669: PUSH
45670: LD_INT 30
45672: PUSH
45673: LD_INT 1
45675: PUSH
45676: EMPTY
45677: LIST
45678: LIST
45679: PUSH
45680: LD_INT 30
45682: PUSH
45683: LD_INT 6
45685: PUSH
45686: EMPTY
45687: LIST
45688: LIST
45689: PUSH
45690: EMPTY
45691: LIST
45692: LIST
45693: LIST
45694: LIST
45695: PPUSH
45696: CALL_OW 72
45700: PPUSH
45701: LD_VAR 0 7
45705: PPUSH
45706: CALL_OW 74
45710: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
45711: LD_VAR 0 7
45715: PPUSH
45716: LD_VAR 0 8
45720: PPUSH
45721: CALL_OW 250
45725: PPUSH
45726: LD_INT 3
45728: PPUSH
45729: LD_INT 5
45731: PPUSH
45732: CALL_OW 272
45736: PPUSH
45737: LD_VAR 0 8
45741: PPUSH
45742: CALL_OW 251
45746: PPUSH
45747: LD_INT 3
45749: PPUSH
45750: LD_INT 5
45752: PPUSH
45753: CALL_OW 273
45757: PPUSH
45758: CALL_OW 111
// SetTag ( i , 0 ) ;
45762: LD_VAR 0 7
45766: PPUSH
45767: LD_INT 0
45769: PPUSH
45770: CALL_OW 109
// solds := solds diff i ;
45774: LD_ADDR_VAR 0 2
45778: PUSH
45779: LD_VAR 0 2
45783: PUSH
45784: LD_VAR 0 7
45788: DIFF
45789: ST_TO_ADDR
// continue ;
45790: GO 45577
// end ; end ;
45792: GO 45577
45794: POP
45795: POP
// until solds ;
45796: LD_VAR 0 2
45800: IFFALSE 45472
// MC_Reset ( base , 18 ) ;
45802: LD_VAR 0 1
45806: PPUSH
45807: LD_INT 18
45809: PPUSH
45810: CALL 19344 0 2
// end ;
45814: LD_VAR 0 4
45818: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
45819: LD_INT 0
45821: PPUSH
45822: PPUSH
45823: PPUSH
45824: PPUSH
45825: PPUSH
45826: PPUSH
45827: PPUSH
45828: PPUSH
45829: PPUSH
45830: PPUSH
45831: PPUSH
45832: PPUSH
45833: PPUSH
45834: PPUSH
45835: PPUSH
45836: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
45837: LD_ADDR_VAR 0 12
45841: PUSH
45842: LD_EXP 49
45846: PUSH
45847: LD_VAR 0 1
45851: ARRAY
45852: PPUSH
45853: LD_INT 25
45855: PUSH
45856: LD_INT 3
45858: PUSH
45859: EMPTY
45860: LIST
45861: LIST
45862: PPUSH
45863: CALL_OW 72
45867: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
45868: LD_ADDR_VAR 0 8
45872: PUSH
45873: LD_EXP 49
45877: PUSH
45878: LD_VAR 0 1
45882: ARRAY
45883: PPUSH
45884: LD_INT 2
45886: PUSH
45887: LD_INT 25
45889: PUSH
45890: LD_INT 1
45892: PUSH
45893: EMPTY
45894: LIST
45895: LIST
45896: PUSH
45897: LD_INT 25
45899: PUSH
45900: LD_INT 5
45902: PUSH
45903: EMPTY
45904: LIST
45905: LIST
45906: PUSH
45907: LD_INT 25
45909: PUSH
45910: LD_INT 8
45912: PUSH
45913: EMPTY
45914: LIST
45915: LIST
45916: PUSH
45917: LD_INT 25
45919: PUSH
45920: LD_INT 9
45922: PUSH
45923: EMPTY
45924: LIST
45925: LIST
45926: PUSH
45927: EMPTY
45928: LIST
45929: LIST
45930: LIST
45931: LIST
45932: LIST
45933: PPUSH
45934: CALL_OW 72
45938: ST_TO_ADDR
// if not defenders and not solds then
45939: LD_VAR 0 2
45943: NOT
45944: PUSH
45945: LD_VAR 0 8
45949: NOT
45950: AND
45951: IFFALSE 45955
// exit ;
45953: GO 47321
// depot_under_attack := false ;
45955: LD_ADDR_VAR 0 16
45959: PUSH
45960: LD_INT 0
45962: ST_TO_ADDR
// sold_defenders := [ ] ;
45963: LD_ADDR_VAR 0 17
45967: PUSH
45968: EMPTY
45969: ST_TO_ADDR
// if mechs then
45970: LD_VAR 0 12
45974: IFFALSE 46103
// for i in defenders do
45976: LD_ADDR_VAR 0 5
45980: PUSH
45981: LD_VAR 0 2
45985: PUSH
45986: FOR_IN
45987: IFFALSE 46101
// begin SetTag ( i , 20 ) ;
45989: LD_VAR 0 5
45993: PPUSH
45994: LD_INT 20
45996: PPUSH
45997: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
46001: LD_VAR 0 5
46005: PPUSH
46006: CALL_OW 263
46010: PUSH
46011: LD_INT 1
46013: EQUAL
46014: PUSH
46015: LD_VAR 0 5
46019: PPUSH
46020: CALL_OW 311
46024: NOT
46025: AND
46026: PUSH
46027: LD_VAR 0 12
46031: AND
46032: IFFALSE 46099
// begin un := mechs [ 1 ] ;
46034: LD_ADDR_VAR 0 10
46038: PUSH
46039: LD_VAR 0 12
46043: PUSH
46044: LD_INT 1
46046: ARRAY
46047: ST_TO_ADDR
// ComExitBuilding ( un ) ;
46048: LD_VAR 0 10
46052: PPUSH
46053: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
46057: LD_VAR 0 10
46061: PPUSH
46062: LD_VAR 0 5
46066: PPUSH
46067: CALL_OW 180
// SetTag ( un , 19 ) ;
46071: LD_VAR 0 10
46075: PPUSH
46076: LD_INT 19
46078: PPUSH
46079: CALL_OW 109
// mechs := mechs diff un ;
46083: LD_ADDR_VAR 0 12
46087: PUSH
46088: LD_VAR 0 12
46092: PUSH
46093: LD_VAR 0 10
46097: DIFF
46098: ST_TO_ADDR
// end ; end ;
46099: GO 45986
46101: POP
46102: POP
// if solds then
46103: LD_VAR 0 8
46107: IFFALSE 46166
// for i in solds do
46109: LD_ADDR_VAR 0 5
46113: PUSH
46114: LD_VAR 0 8
46118: PUSH
46119: FOR_IN
46120: IFFALSE 46164
// if not GetTag ( i ) then
46122: LD_VAR 0 5
46126: PPUSH
46127: CALL_OW 110
46131: NOT
46132: IFFALSE 46162
// begin defenders := defenders union i ;
46134: LD_ADDR_VAR 0 2
46138: PUSH
46139: LD_VAR 0 2
46143: PUSH
46144: LD_VAR 0 5
46148: UNION
46149: ST_TO_ADDR
// SetTag ( i , 18 ) ;
46150: LD_VAR 0 5
46154: PPUSH
46155: LD_INT 18
46157: PPUSH
46158: CALL_OW 109
// end ;
46162: GO 46119
46164: POP
46165: POP
// repeat wait ( 0 0$1 ) ;
46166: LD_INT 35
46168: PPUSH
46169: CALL_OW 67
// enemy := mc_scan [ base ] ;
46173: LD_ADDR_VAR 0 3
46177: PUSH
46178: LD_EXP 72
46182: PUSH
46183: LD_VAR 0 1
46187: ARRAY
46188: ST_TO_ADDR
// for i in defenders do
46189: LD_ADDR_VAR 0 5
46193: PUSH
46194: LD_VAR 0 2
46198: PUSH
46199: FOR_IN
46200: IFFALSE 46885
// begin e := NearestUnitToUnit ( enemy , i ) ;
46202: LD_ADDR_VAR 0 13
46206: PUSH
46207: LD_VAR 0 3
46211: PPUSH
46212: LD_VAR 0 5
46216: PPUSH
46217: CALL_OW 74
46221: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
46222: LD_ADDR_VAR 0 16
46226: PUSH
46227: LD_EXP 49
46231: PUSH
46232: LD_VAR 0 1
46236: ARRAY
46237: PPUSH
46238: LD_INT 2
46240: PUSH
46241: LD_INT 30
46243: PUSH
46244: LD_INT 0
46246: PUSH
46247: EMPTY
46248: LIST
46249: LIST
46250: PUSH
46251: LD_INT 30
46253: PUSH
46254: LD_INT 1
46256: PUSH
46257: EMPTY
46258: LIST
46259: LIST
46260: PUSH
46261: EMPTY
46262: LIST
46263: LIST
46264: LIST
46265: PPUSH
46266: CALL_OW 72
46270: NOT
46271: PUSH
46272: LD_EXP 49
46276: PUSH
46277: LD_VAR 0 1
46281: ARRAY
46282: PPUSH
46283: LD_INT 2
46285: PUSH
46286: LD_INT 30
46288: PUSH
46289: LD_INT 0
46291: PUSH
46292: EMPTY
46293: LIST
46294: LIST
46295: PUSH
46296: LD_INT 30
46298: PUSH
46299: LD_INT 1
46301: PUSH
46302: EMPTY
46303: LIST
46304: LIST
46305: PUSH
46306: EMPTY
46307: LIST
46308: LIST
46309: LIST
46310: PPUSH
46311: CALL_OW 72
46315: PPUSH
46316: CALL_OW 256
46320: PUSH
46321: LD_INT 600
46323: LESS
46324: OR
46325: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
46326: LD_VAR 0 5
46330: PPUSH
46331: CALL_OW 247
46335: PUSH
46336: LD_INT 2
46338: DOUBLE
46339: EQUAL
46340: IFTRUE 46344
46342: GO 46591
46344: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
46345: LD_VAR 0 5
46349: PPUSH
46350: CALL_OW 256
46354: PUSH
46355: LD_INT 650
46357: GREATER
46358: PUSH
46359: LD_VAR 0 5
46363: PPUSH
46364: LD_VAR 0 13
46368: PPUSH
46369: CALL_OW 296
46373: PUSH
46374: LD_INT 40
46376: LESS
46377: AND
46378: IFFALSE 46396
// ComAttackUnit ( i , e ) else
46380: LD_VAR 0 5
46384: PPUSH
46385: LD_VAR 0 13
46389: PPUSH
46390: CALL_OW 115
46394: GO 46474
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
46396: LD_VAR 0 5
46400: PPUSH
46401: LD_VAR 0 13
46405: PPUSH
46406: CALL_OW 296
46410: PUSH
46411: LD_INT 30
46413: GREATEREQUAL
46414: PUSH
46415: LD_VAR 0 5
46419: PPUSH
46420: CALL_OW 256
46424: PUSH
46425: LD_INT 650
46427: LESSEQUAL
46428: OR
46429: PUSH
46430: LD_VAR 0 5
46434: PPUSH
46435: LD_EXP 73
46439: PUSH
46440: LD_VAR 0 1
46444: ARRAY
46445: PPUSH
46446: CALL_OW 308
46450: NOT
46451: AND
46452: IFFALSE 46474
// ComMoveToArea ( i , mc_parking [ base ] ) ;
46454: LD_VAR 0 5
46458: PPUSH
46459: LD_EXP 73
46463: PUSH
46464: LD_VAR 0 1
46468: ARRAY
46469: PPUSH
46470: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
46474: LD_VAR 0 5
46478: PPUSH
46479: CALL_OW 256
46483: PUSH
46484: LD_INT 998
46486: LESS
46487: PUSH
46488: LD_VAR 0 5
46492: PPUSH
46493: CALL_OW 263
46497: PUSH
46498: LD_INT 1
46500: EQUAL
46501: AND
46502: PUSH
46503: LD_VAR 0 5
46507: PPUSH
46508: CALL_OW 311
46512: AND
46513: PUSH
46514: LD_VAR 0 5
46518: PPUSH
46519: LD_EXP 73
46523: PUSH
46524: LD_VAR 0 1
46528: ARRAY
46529: PPUSH
46530: CALL_OW 308
46534: AND
46535: IFFALSE 46589
// begin mech := IsDrivenBy ( i ) ;
46537: LD_ADDR_VAR 0 9
46541: PUSH
46542: LD_VAR 0 5
46546: PPUSH
46547: CALL_OW 311
46551: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
46552: LD_VAR 0 9
46556: PPUSH
46557: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
46561: LD_VAR 0 9
46565: PPUSH
46566: LD_VAR 0 5
46570: PPUSH
46571: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
46575: LD_VAR 0 9
46579: PPUSH
46580: LD_VAR 0 5
46584: PPUSH
46585: CALL_OW 180
// end ; end ; unit_human :
46589: GO 46856
46591: LD_INT 1
46593: DOUBLE
46594: EQUAL
46595: IFTRUE 46599
46597: GO 46855
46599: POP
// begin b := IsInUnit ( i ) ;
46600: LD_ADDR_VAR 0 18
46604: PUSH
46605: LD_VAR 0 5
46609: PPUSH
46610: CALL_OW 310
46614: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
46615: LD_ADDR_VAR 0 19
46619: PUSH
46620: LD_VAR 0 18
46624: NOT
46625: PUSH
46626: LD_VAR 0 18
46630: PPUSH
46631: CALL_OW 266
46635: PUSH
46636: LD_INT 32
46638: PUSH
46639: LD_INT 31
46641: PUSH
46642: EMPTY
46643: LIST
46644: LIST
46645: IN
46646: OR
46647: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
46648: LD_VAR 0 16
46652: PUSH
46653: LD_VAR 0 2
46657: PPUSH
46658: LD_INT 21
46660: PUSH
46661: LD_INT 2
46663: PUSH
46664: EMPTY
46665: LIST
46666: LIST
46667: PPUSH
46668: CALL_OW 72
46672: PUSH
46673: LD_INT 1
46675: LESSEQUAL
46676: OR
46677: PUSH
46678: LD_VAR 0 19
46682: AND
46683: PUSH
46684: LD_VAR 0 5
46688: PUSH
46689: LD_VAR 0 17
46693: IN
46694: NOT
46695: AND
46696: IFFALSE 46789
// begin if b then
46698: LD_VAR 0 18
46702: IFFALSE 46751
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
46704: LD_VAR 0 18
46708: PPUSH
46709: LD_VAR 0 3
46713: PPUSH
46714: LD_VAR 0 18
46718: PPUSH
46719: CALL_OW 74
46723: PPUSH
46724: CALL_OW 296
46728: PUSH
46729: LD_INT 10
46731: LESS
46732: PUSH
46733: LD_VAR 0 18
46737: PPUSH
46738: CALL_OW 461
46742: PUSH
46743: LD_INT 7
46745: NONEQUAL
46746: AND
46747: IFFALSE 46751
// continue ;
46749: GO 46199
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
46751: LD_ADDR_VAR 0 17
46755: PUSH
46756: LD_VAR 0 17
46760: PPUSH
46761: LD_VAR 0 17
46765: PUSH
46766: LD_INT 1
46768: PLUS
46769: PPUSH
46770: LD_VAR 0 5
46774: PPUSH
46775: CALL_OW 1
46779: ST_TO_ADDR
// ComExitBuilding ( i ) ;
46780: LD_VAR 0 5
46784: PPUSH
46785: CALL_OW 122
// end ; if sold_defenders then
46789: LD_VAR 0 17
46793: IFFALSE 46853
// if i in sold_defenders then
46795: LD_VAR 0 5
46799: PUSH
46800: LD_VAR 0 17
46804: IN
46805: IFFALSE 46853
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
46807: LD_VAR 0 5
46811: PPUSH
46812: CALL_OW 314
46816: NOT
46817: PUSH
46818: LD_VAR 0 5
46822: PPUSH
46823: LD_VAR 0 13
46827: PPUSH
46828: CALL_OW 296
46832: PUSH
46833: LD_INT 30
46835: LESS
46836: AND
46837: IFFALSE 46853
// ComAttackUnit ( i , e ) ;
46839: LD_VAR 0 5
46843: PPUSH
46844: LD_VAR 0 13
46848: PPUSH
46849: CALL_OW 115
// end ; end ; end ;
46853: GO 46856
46855: POP
// if IsDead ( i ) then
46856: LD_VAR 0 5
46860: PPUSH
46861: CALL_OW 301
46865: IFFALSE 46883
// defenders := defenders diff i ;
46867: LD_ADDR_VAR 0 2
46871: PUSH
46872: LD_VAR 0 2
46876: PUSH
46877: LD_VAR 0 5
46881: DIFF
46882: ST_TO_ADDR
// end ;
46883: GO 46199
46885: POP
46886: POP
// until not enemy or not defenders ;
46887: LD_VAR 0 3
46891: NOT
46892: PUSH
46893: LD_VAR 0 2
46897: NOT
46898: OR
46899: IFFALSE 46166
// MC_Reset ( base , 18 ) ;
46901: LD_VAR 0 1
46905: PPUSH
46906: LD_INT 18
46908: PPUSH
46909: CALL 19344 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
46913: LD_ADDR_VAR 0 2
46917: PUSH
46918: LD_VAR 0 2
46922: PUSH
46923: LD_VAR 0 2
46927: PPUSH
46928: LD_INT 2
46930: PUSH
46931: LD_INT 25
46933: PUSH
46934: LD_INT 1
46936: PUSH
46937: EMPTY
46938: LIST
46939: LIST
46940: PUSH
46941: LD_INT 25
46943: PUSH
46944: LD_INT 5
46946: PUSH
46947: EMPTY
46948: LIST
46949: LIST
46950: PUSH
46951: LD_INT 25
46953: PUSH
46954: LD_INT 8
46956: PUSH
46957: EMPTY
46958: LIST
46959: LIST
46960: PUSH
46961: LD_INT 25
46963: PUSH
46964: LD_INT 9
46966: PUSH
46967: EMPTY
46968: LIST
46969: LIST
46970: PUSH
46971: EMPTY
46972: LIST
46973: LIST
46974: LIST
46975: LIST
46976: LIST
46977: PPUSH
46978: CALL_OW 72
46982: DIFF
46983: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
46984: LD_VAR 0 3
46988: NOT
46989: PUSH
46990: LD_VAR 0 2
46994: PPUSH
46995: LD_INT 21
46997: PUSH
46998: LD_INT 2
47000: PUSH
47001: EMPTY
47002: LIST
47003: LIST
47004: PPUSH
47005: CALL_OW 72
47009: AND
47010: IFFALSE 47272
// begin tmp := FilterByTag ( defenders , 19 ) ;
47012: LD_ADDR_VAR 0 11
47016: PUSH
47017: LD_VAR 0 2
47021: PPUSH
47022: LD_INT 19
47024: PPUSH
47025: CALL 83437 0 2
47029: ST_TO_ADDR
// if tmp then
47030: LD_VAR 0 11
47034: IFFALSE 47104
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
47036: LD_ADDR_VAR 0 11
47040: PUSH
47041: LD_VAR 0 11
47045: PPUSH
47046: LD_INT 25
47048: PUSH
47049: LD_INT 3
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: PPUSH
47056: CALL_OW 72
47060: ST_TO_ADDR
// if tmp then
47061: LD_VAR 0 11
47065: IFFALSE 47104
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
47067: LD_ADDR_EXP 61
47071: PUSH
47072: LD_EXP 61
47076: PPUSH
47077: LD_VAR 0 1
47081: PPUSH
47082: LD_EXP 61
47086: PUSH
47087: LD_VAR 0 1
47091: ARRAY
47092: PUSH
47093: LD_VAR 0 11
47097: UNION
47098: PPUSH
47099: CALL_OW 1
47103: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
47104: LD_VAR 0 1
47108: PPUSH
47109: LD_INT 19
47111: PPUSH
47112: CALL 19344 0 2
// repeat wait ( 0 0$1 ) ;
47116: LD_INT 35
47118: PPUSH
47119: CALL_OW 67
// for i in defenders do
47123: LD_ADDR_VAR 0 5
47127: PUSH
47128: LD_VAR 0 2
47132: PUSH
47133: FOR_IN
47134: IFFALSE 47223
// begin if not IsInArea ( i , mc_parking [ base ] ) then
47136: LD_VAR 0 5
47140: PPUSH
47141: LD_EXP 73
47145: PUSH
47146: LD_VAR 0 1
47150: ARRAY
47151: PPUSH
47152: CALL_OW 308
47156: NOT
47157: IFFALSE 47181
// ComMoveToArea ( i , mc_parking [ base ] ) else
47159: LD_VAR 0 5
47163: PPUSH
47164: LD_EXP 73
47168: PUSH
47169: LD_VAR 0 1
47173: ARRAY
47174: PPUSH
47175: CALL_OW 113
47179: GO 47221
// if GetControl ( i ) = control_manual then
47181: LD_VAR 0 5
47185: PPUSH
47186: CALL_OW 263
47190: PUSH
47191: LD_INT 1
47193: EQUAL
47194: IFFALSE 47221
// if IsDrivenBy ( i ) then
47196: LD_VAR 0 5
47200: PPUSH
47201: CALL_OW 311
47205: IFFALSE 47221
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
47207: LD_VAR 0 5
47211: PPUSH
47212: CALL_OW 311
47216: PPUSH
47217: CALL_OW 121
// end ;
47221: GO 47133
47223: POP
47224: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
47225: LD_VAR 0 2
47229: PPUSH
47230: LD_INT 95
47232: PUSH
47233: LD_EXP 73
47237: PUSH
47238: LD_VAR 0 1
47242: ARRAY
47243: PUSH
47244: EMPTY
47245: LIST
47246: LIST
47247: PPUSH
47248: CALL_OW 72
47252: PUSH
47253: LD_VAR 0 2
47257: EQUAL
47258: PUSH
47259: LD_EXP 72
47263: PUSH
47264: LD_VAR 0 1
47268: ARRAY
47269: OR
47270: IFFALSE 47116
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
47272: LD_ADDR_EXP 71
47276: PUSH
47277: LD_EXP 71
47281: PPUSH
47282: LD_VAR 0 1
47286: PPUSH
47287: LD_EXP 71
47291: PUSH
47292: LD_VAR 0 1
47296: ARRAY
47297: PUSH
47298: LD_VAR 0 2
47302: UNION
47303: PPUSH
47304: CALL_OW 1
47308: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
47309: LD_VAR 0 1
47313: PPUSH
47314: LD_INT 20
47316: PPUSH
47317: CALL 19344 0 2
// end ;
47321: LD_VAR 0 4
47325: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
47326: LD_INT 0
47328: PPUSH
47329: PPUSH
47330: PPUSH
47331: PPUSH
// result := false ;
47332: LD_ADDR_VAR 0 2
47336: PUSH
47337: LD_INT 0
47339: ST_TO_ADDR
// side := GetSide ( unit ) ;
47340: LD_ADDR_VAR 0 3
47344: PUSH
47345: LD_VAR 0 1
47349: PPUSH
47350: CALL_OW 255
47354: ST_TO_ADDR
// nat := GetNation ( unit ) ;
47355: LD_ADDR_VAR 0 4
47359: PUSH
47360: LD_VAR 0 1
47364: PPUSH
47365: CALL_OW 248
47369: ST_TO_ADDR
// case nat of 1 :
47370: LD_VAR 0 4
47374: PUSH
47375: LD_INT 1
47377: DOUBLE
47378: EQUAL
47379: IFTRUE 47383
47381: GO 47394
47383: POP
// tech := tech_lassight ; 2 :
47384: LD_ADDR_VAR 0 5
47388: PUSH
47389: LD_INT 12
47391: ST_TO_ADDR
47392: GO 47433
47394: LD_INT 2
47396: DOUBLE
47397: EQUAL
47398: IFTRUE 47402
47400: GO 47413
47402: POP
// tech := tech_mortar ; 3 :
47403: LD_ADDR_VAR 0 5
47407: PUSH
47408: LD_INT 41
47410: ST_TO_ADDR
47411: GO 47433
47413: LD_INT 3
47415: DOUBLE
47416: EQUAL
47417: IFTRUE 47421
47419: GO 47432
47421: POP
// tech := tech_bazooka ; end ;
47422: LD_ADDR_VAR 0 5
47426: PUSH
47427: LD_INT 44
47429: ST_TO_ADDR
47430: GO 47433
47432: POP
// if Researched ( side , tech ) then
47433: LD_VAR 0 3
47437: PPUSH
47438: LD_VAR 0 5
47442: PPUSH
47443: CALL_OW 325
47447: IFFALSE 47474
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
47449: LD_ADDR_VAR 0 2
47453: PUSH
47454: LD_INT 5
47456: PUSH
47457: LD_INT 8
47459: PUSH
47460: LD_INT 9
47462: PUSH
47463: EMPTY
47464: LIST
47465: LIST
47466: LIST
47467: PUSH
47468: LD_VAR 0 4
47472: ARRAY
47473: ST_TO_ADDR
// end ;
47474: LD_VAR 0 2
47478: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
47479: LD_INT 0
47481: PPUSH
47482: PPUSH
47483: PPUSH
// if not mines then
47484: LD_VAR 0 2
47488: NOT
47489: IFFALSE 47493
// exit ;
47491: GO 47637
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
47493: LD_ADDR_VAR 0 5
47497: PUSH
47498: LD_INT 81
47500: PUSH
47501: LD_VAR 0 1
47505: PUSH
47506: EMPTY
47507: LIST
47508: LIST
47509: PUSH
47510: LD_INT 3
47512: PUSH
47513: LD_INT 21
47515: PUSH
47516: LD_INT 3
47518: PUSH
47519: EMPTY
47520: LIST
47521: LIST
47522: PUSH
47523: EMPTY
47524: LIST
47525: LIST
47526: PUSH
47527: EMPTY
47528: LIST
47529: LIST
47530: PPUSH
47531: CALL_OW 69
47535: ST_TO_ADDR
// for i in mines do
47536: LD_ADDR_VAR 0 4
47540: PUSH
47541: LD_VAR 0 2
47545: PUSH
47546: FOR_IN
47547: IFFALSE 47635
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
47549: LD_VAR 0 4
47553: PUSH
47554: LD_INT 1
47556: ARRAY
47557: PPUSH
47558: LD_VAR 0 4
47562: PUSH
47563: LD_INT 2
47565: ARRAY
47566: PPUSH
47567: CALL_OW 458
47571: NOT
47572: IFFALSE 47576
// continue ;
47574: GO 47546
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
47576: LD_VAR 0 4
47580: PUSH
47581: LD_INT 1
47583: ARRAY
47584: PPUSH
47585: LD_VAR 0 4
47589: PUSH
47590: LD_INT 2
47592: ARRAY
47593: PPUSH
47594: CALL_OW 428
47598: PUSH
47599: LD_VAR 0 5
47603: IN
47604: IFFALSE 47633
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
47606: LD_VAR 0 4
47610: PUSH
47611: LD_INT 1
47613: ARRAY
47614: PPUSH
47615: LD_VAR 0 4
47619: PUSH
47620: LD_INT 2
47622: ARRAY
47623: PPUSH
47624: LD_VAR 0 1
47628: PPUSH
47629: CALL_OW 456
// end ;
47633: GO 47546
47635: POP
47636: POP
// end ;
47637: LD_VAR 0 3
47641: RET
// export function Count ( array ) ; var i ; begin
47642: LD_INT 0
47644: PPUSH
47645: PPUSH
// result := 0 ;
47646: LD_ADDR_VAR 0 2
47650: PUSH
47651: LD_INT 0
47653: ST_TO_ADDR
// for i in array do
47654: LD_ADDR_VAR 0 3
47658: PUSH
47659: LD_VAR 0 1
47663: PUSH
47664: FOR_IN
47665: IFFALSE 47689
// if i then
47667: LD_VAR 0 3
47671: IFFALSE 47687
// result := result + 1 ;
47673: LD_ADDR_VAR 0 2
47677: PUSH
47678: LD_VAR 0 2
47682: PUSH
47683: LD_INT 1
47685: PLUS
47686: ST_TO_ADDR
47687: GO 47664
47689: POP
47690: POP
// end ;
47691: LD_VAR 0 2
47695: RET
// export function IsEmpty ( building ) ; begin
47696: LD_INT 0
47698: PPUSH
// if not building then
47699: LD_VAR 0 1
47703: NOT
47704: IFFALSE 47708
// exit ;
47706: GO 47751
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
47708: LD_ADDR_VAR 0 2
47712: PUSH
47713: LD_VAR 0 1
47717: PUSH
47718: LD_INT 22
47720: PUSH
47721: LD_VAR 0 1
47725: PPUSH
47726: CALL_OW 255
47730: PUSH
47731: EMPTY
47732: LIST
47733: LIST
47734: PUSH
47735: LD_INT 58
47737: PUSH
47738: EMPTY
47739: LIST
47740: PUSH
47741: EMPTY
47742: LIST
47743: LIST
47744: PPUSH
47745: CALL_OW 69
47749: IN
47750: ST_TO_ADDR
// end ;
47751: LD_VAR 0 2
47755: RET
// export function IsNotFull ( building ) ; begin
47756: LD_INT 0
47758: PPUSH
// if not building then
47759: LD_VAR 0 1
47763: NOT
47764: IFFALSE 47768
// exit ;
47766: GO 47787
// result := UnitsInside ( building ) < 6 ;
47768: LD_ADDR_VAR 0 2
47772: PUSH
47773: LD_VAR 0 1
47777: PPUSH
47778: CALL_OW 313
47782: PUSH
47783: LD_INT 6
47785: LESS
47786: ST_TO_ADDR
// end ;
47787: LD_VAR 0 2
47791: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
47792: LD_INT 0
47794: PPUSH
47795: PPUSH
47796: PPUSH
47797: PPUSH
// tmp := [ ] ;
47798: LD_ADDR_VAR 0 3
47802: PUSH
47803: EMPTY
47804: ST_TO_ADDR
// list := [ ] ;
47805: LD_ADDR_VAR 0 5
47809: PUSH
47810: EMPTY
47811: ST_TO_ADDR
// for i = 16 to 25 do
47812: LD_ADDR_VAR 0 4
47816: PUSH
47817: DOUBLE
47818: LD_INT 16
47820: DEC
47821: ST_TO_ADDR
47822: LD_INT 25
47824: PUSH
47825: FOR_TO
47826: IFFALSE 47899
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
47828: LD_ADDR_VAR 0 3
47832: PUSH
47833: LD_VAR 0 3
47837: PUSH
47838: LD_INT 22
47840: PUSH
47841: LD_VAR 0 1
47845: PPUSH
47846: CALL_OW 255
47850: PUSH
47851: EMPTY
47852: LIST
47853: LIST
47854: PUSH
47855: LD_INT 91
47857: PUSH
47858: LD_VAR 0 1
47862: PUSH
47863: LD_INT 6
47865: PUSH
47866: EMPTY
47867: LIST
47868: LIST
47869: LIST
47870: PUSH
47871: LD_INT 30
47873: PUSH
47874: LD_VAR 0 4
47878: PUSH
47879: EMPTY
47880: LIST
47881: LIST
47882: PUSH
47883: EMPTY
47884: LIST
47885: LIST
47886: LIST
47887: PUSH
47888: EMPTY
47889: LIST
47890: PPUSH
47891: CALL_OW 69
47895: ADD
47896: ST_TO_ADDR
47897: GO 47825
47899: POP
47900: POP
// for i = 1 to tmp do
47901: LD_ADDR_VAR 0 4
47905: PUSH
47906: DOUBLE
47907: LD_INT 1
47909: DEC
47910: ST_TO_ADDR
47911: LD_VAR 0 3
47915: PUSH
47916: FOR_TO
47917: IFFALSE 48005
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
47919: LD_ADDR_VAR 0 5
47923: PUSH
47924: LD_VAR 0 5
47928: PUSH
47929: LD_VAR 0 3
47933: PUSH
47934: LD_VAR 0 4
47938: ARRAY
47939: PPUSH
47940: CALL_OW 266
47944: PUSH
47945: LD_VAR 0 3
47949: PUSH
47950: LD_VAR 0 4
47954: ARRAY
47955: PPUSH
47956: CALL_OW 250
47960: PUSH
47961: LD_VAR 0 3
47965: PUSH
47966: LD_VAR 0 4
47970: ARRAY
47971: PPUSH
47972: CALL_OW 251
47976: PUSH
47977: LD_VAR 0 3
47981: PUSH
47982: LD_VAR 0 4
47986: ARRAY
47987: PPUSH
47988: CALL_OW 254
47992: PUSH
47993: EMPTY
47994: LIST
47995: LIST
47996: LIST
47997: LIST
47998: PUSH
47999: EMPTY
48000: LIST
48001: ADD
48002: ST_TO_ADDR
48003: GO 47916
48005: POP
48006: POP
// result := list ;
48007: LD_ADDR_VAR 0 2
48011: PUSH
48012: LD_VAR 0 5
48016: ST_TO_ADDR
// end ;
48017: LD_VAR 0 2
48021: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
48022: LD_INT 0
48024: PPUSH
48025: PPUSH
48026: PPUSH
48027: PPUSH
48028: PPUSH
48029: PPUSH
48030: PPUSH
// if not factory then
48031: LD_VAR 0 1
48035: NOT
48036: IFFALSE 48040
// exit ;
48038: GO 48565
// if control = control_apeman then
48040: LD_VAR 0 4
48044: PUSH
48045: LD_INT 5
48047: EQUAL
48048: IFFALSE 48157
// begin tmp := UnitsInside ( factory ) ;
48050: LD_ADDR_VAR 0 8
48054: PUSH
48055: LD_VAR 0 1
48059: PPUSH
48060: CALL_OW 313
48064: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
48065: LD_VAR 0 8
48069: PPUSH
48070: LD_INT 25
48072: PUSH
48073: LD_INT 12
48075: PUSH
48076: EMPTY
48077: LIST
48078: LIST
48079: PPUSH
48080: CALL_OW 72
48084: NOT
48085: IFFALSE 48095
// control := control_manual ;
48087: LD_ADDR_VAR 0 4
48091: PUSH
48092: LD_INT 1
48094: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
48095: LD_ADDR_VAR 0 8
48099: PUSH
48100: LD_VAR 0 1
48104: PPUSH
48105: CALL 47792 0 1
48109: ST_TO_ADDR
// if tmp then
48110: LD_VAR 0 8
48114: IFFALSE 48157
// begin for i in tmp do
48116: LD_ADDR_VAR 0 7
48120: PUSH
48121: LD_VAR 0 8
48125: PUSH
48126: FOR_IN
48127: IFFALSE 48155
// if i [ 1 ] = b_ext_radar then
48129: LD_VAR 0 7
48133: PUSH
48134: LD_INT 1
48136: ARRAY
48137: PUSH
48138: LD_INT 20
48140: EQUAL
48141: IFFALSE 48153
// begin control := control_remote ;
48143: LD_ADDR_VAR 0 4
48147: PUSH
48148: LD_INT 2
48150: ST_TO_ADDR
// break ;
48151: GO 48155
// end ;
48153: GO 48126
48155: POP
48156: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
48157: LD_VAR 0 1
48161: PPUSH
48162: LD_VAR 0 2
48166: PPUSH
48167: LD_VAR 0 3
48171: PPUSH
48172: LD_VAR 0 4
48176: PPUSH
48177: LD_VAR 0 5
48181: PPUSH
48182: CALL_OW 448
48186: IFFALSE 48221
// begin result := [ chassis , engine , control , weapon ] ;
48188: LD_ADDR_VAR 0 6
48192: PUSH
48193: LD_VAR 0 2
48197: PUSH
48198: LD_VAR 0 3
48202: PUSH
48203: LD_VAR 0 4
48207: PUSH
48208: LD_VAR 0 5
48212: PUSH
48213: EMPTY
48214: LIST
48215: LIST
48216: LIST
48217: LIST
48218: ST_TO_ADDR
// exit ;
48219: GO 48565
// end ; _chassis := AvailableChassisList ( factory ) ;
48221: LD_ADDR_VAR 0 9
48225: PUSH
48226: LD_VAR 0 1
48230: PPUSH
48231: CALL_OW 475
48235: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
48236: LD_ADDR_VAR 0 11
48240: PUSH
48241: LD_VAR 0 1
48245: PPUSH
48246: CALL_OW 476
48250: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
48251: LD_ADDR_VAR 0 12
48255: PUSH
48256: LD_VAR 0 1
48260: PPUSH
48261: CALL_OW 477
48265: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
48266: LD_ADDR_VAR 0 10
48270: PUSH
48271: LD_VAR 0 1
48275: PPUSH
48276: CALL_OW 478
48280: ST_TO_ADDR
// if not chassis in _chassis then
48281: LD_VAR 0 2
48285: PUSH
48286: LD_VAR 0 9
48290: IN
48291: NOT
48292: IFFALSE 48318
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
48294: LD_ADDR_VAR 0 2
48298: PUSH
48299: LD_VAR 0 9
48303: PUSH
48304: LD_INT 1
48306: PPUSH
48307: LD_VAR 0 9
48311: PPUSH
48312: CALL_OW 12
48316: ARRAY
48317: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
48318: LD_VAR 0 2
48322: PPUSH
48323: LD_VAR 0 3
48327: PPUSH
48328: CALL 48570 0 2
48332: NOT
48333: IFFALSE 48392
// repeat engine := _engine [ 1 ] ;
48335: LD_ADDR_VAR 0 3
48339: PUSH
48340: LD_VAR 0 11
48344: PUSH
48345: LD_INT 1
48347: ARRAY
48348: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
48349: LD_ADDR_VAR 0 11
48353: PUSH
48354: LD_VAR 0 11
48358: PPUSH
48359: LD_INT 1
48361: PPUSH
48362: CALL_OW 3
48366: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
48367: LD_VAR 0 2
48371: PPUSH
48372: LD_VAR 0 3
48376: PPUSH
48377: CALL 48570 0 2
48381: PUSH
48382: LD_VAR 0 11
48386: PUSH
48387: EMPTY
48388: EQUAL
48389: OR
48390: IFFALSE 48335
// if not control in _control then
48392: LD_VAR 0 4
48396: PUSH
48397: LD_VAR 0 12
48401: IN
48402: NOT
48403: IFFALSE 48429
// control := _control [ rand ( 1 , _control ) ] ;
48405: LD_ADDR_VAR 0 4
48409: PUSH
48410: LD_VAR 0 12
48414: PUSH
48415: LD_INT 1
48417: PPUSH
48418: LD_VAR 0 12
48422: PPUSH
48423: CALL_OW 12
48427: ARRAY
48428: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
48429: LD_VAR 0 2
48433: PPUSH
48434: LD_VAR 0 5
48438: PPUSH
48439: CALL 48790 0 2
48443: NOT
48444: IFFALSE 48503
// repeat weapon := _weapon [ 1 ] ;
48446: LD_ADDR_VAR 0 5
48450: PUSH
48451: LD_VAR 0 10
48455: PUSH
48456: LD_INT 1
48458: ARRAY
48459: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
48460: LD_ADDR_VAR 0 10
48464: PUSH
48465: LD_VAR 0 10
48469: PPUSH
48470: LD_INT 1
48472: PPUSH
48473: CALL_OW 3
48477: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
48478: LD_VAR 0 2
48482: PPUSH
48483: LD_VAR 0 5
48487: PPUSH
48488: CALL 48790 0 2
48492: PUSH
48493: LD_VAR 0 10
48497: PUSH
48498: EMPTY
48499: EQUAL
48500: OR
48501: IFFALSE 48446
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
48503: LD_VAR 0 1
48507: PPUSH
48508: LD_VAR 0 2
48512: PPUSH
48513: LD_VAR 0 3
48517: PPUSH
48518: LD_VAR 0 4
48522: PPUSH
48523: LD_VAR 0 5
48527: PPUSH
48528: CALL_OW 448
48532: IFFALSE 48565
// result := [ chassis , engine , control , weapon ] ;
48534: LD_ADDR_VAR 0 6
48538: PUSH
48539: LD_VAR 0 2
48543: PUSH
48544: LD_VAR 0 3
48548: PUSH
48549: LD_VAR 0 4
48553: PUSH
48554: LD_VAR 0 5
48558: PUSH
48559: EMPTY
48560: LIST
48561: LIST
48562: LIST
48563: LIST
48564: ST_TO_ADDR
// end ;
48565: LD_VAR 0 6
48569: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
48570: LD_INT 0
48572: PPUSH
// if not chassis or not engine then
48573: LD_VAR 0 1
48577: NOT
48578: PUSH
48579: LD_VAR 0 2
48583: NOT
48584: OR
48585: IFFALSE 48589
// exit ;
48587: GO 48785
// case engine of engine_solar :
48589: LD_VAR 0 2
48593: PUSH
48594: LD_INT 2
48596: DOUBLE
48597: EQUAL
48598: IFTRUE 48602
48600: GO 48640
48602: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
48603: LD_ADDR_VAR 0 3
48607: PUSH
48608: LD_INT 11
48610: PUSH
48611: LD_INT 12
48613: PUSH
48614: LD_INT 13
48616: PUSH
48617: LD_INT 14
48619: PUSH
48620: LD_INT 1
48622: PUSH
48623: LD_INT 2
48625: PUSH
48626: LD_INT 3
48628: PUSH
48629: EMPTY
48630: LIST
48631: LIST
48632: LIST
48633: LIST
48634: LIST
48635: LIST
48636: LIST
48637: ST_TO_ADDR
48638: GO 48769
48640: LD_INT 1
48642: DOUBLE
48643: EQUAL
48644: IFTRUE 48648
48646: GO 48710
48648: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
48649: LD_ADDR_VAR 0 3
48653: PUSH
48654: LD_INT 11
48656: PUSH
48657: LD_INT 12
48659: PUSH
48660: LD_INT 13
48662: PUSH
48663: LD_INT 14
48665: PUSH
48666: LD_INT 1
48668: PUSH
48669: LD_INT 2
48671: PUSH
48672: LD_INT 3
48674: PUSH
48675: LD_INT 4
48677: PUSH
48678: LD_INT 5
48680: PUSH
48681: LD_INT 21
48683: PUSH
48684: LD_INT 23
48686: PUSH
48687: LD_INT 22
48689: PUSH
48690: LD_INT 24
48692: PUSH
48693: EMPTY
48694: LIST
48695: LIST
48696: LIST
48697: LIST
48698: LIST
48699: LIST
48700: LIST
48701: LIST
48702: LIST
48703: LIST
48704: LIST
48705: LIST
48706: LIST
48707: ST_TO_ADDR
48708: GO 48769
48710: LD_INT 3
48712: DOUBLE
48713: EQUAL
48714: IFTRUE 48718
48716: GO 48768
48718: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
48719: LD_ADDR_VAR 0 3
48723: PUSH
48724: LD_INT 13
48726: PUSH
48727: LD_INT 14
48729: PUSH
48730: LD_INT 2
48732: PUSH
48733: LD_INT 3
48735: PUSH
48736: LD_INT 4
48738: PUSH
48739: LD_INT 5
48741: PUSH
48742: LD_INT 21
48744: PUSH
48745: LD_INT 22
48747: PUSH
48748: LD_INT 23
48750: PUSH
48751: LD_INT 24
48753: PUSH
48754: EMPTY
48755: LIST
48756: LIST
48757: LIST
48758: LIST
48759: LIST
48760: LIST
48761: LIST
48762: LIST
48763: LIST
48764: LIST
48765: ST_TO_ADDR
48766: GO 48769
48768: POP
// result := ( chassis in result ) ;
48769: LD_ADDR_VAR 0 3
48773: PUSH
48774: LD_VAR 0 1
48778: PUSH
48779: LD_VAR 0 3
48783: IN
48784: ST_TO_ADDR
// end ;
48785: LD_VAR 0 3
48789: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
48790: LD_INT 0
48792: PPUSH
// if not chassis or not weapon then
48793: LD_VAR 0 1
48797: NOT
48798: PUSH
48799: LD_VAR 0 2
48803: NOT
48804: OR
48805: IFFALSE 48809
// exit ;
48807: GO 49835
// case weapon of us_machine_gun :
48809: LD_VAR 0 2
48813: PUSH
48814: LD_INT 2
48816: DOUBLE
48817: EQUAL
48818: IFTRUE 48822
48820: GO 48852
48822: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
48823: LD_ADDR_VAR 0 3
48827: PUSH
48828: LD_INT 1
48830: PUSH
48831: LD_INT 2
48833: PUSH
48834: LD_INT 3
48836: PUSH
48837: LD_INT 4
48839: PUSH
48840: LD_INT 5
48842: PUSH
48843: EMPTY
48844: LIST
48845: LIST
48846: LIST
48847: LIST
48848: LIST
48849: ST_TO_ADDR
48850: GO 49819
48852: LD_INT 3
48854: DOUBLE
48855: EQUAL
48856: IFTRUE 48860
48858: GO 48890
48860: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
48861: LD_ADDR_VAR 0 3
48865: PUSH
48866: LD_INT 1
48868: PUSH
48869: LD_INT 2
48871: PUSH
48872: LD_INT 3
48874: PUSH
48875: LD_INT 4
48877: PUSH
48878: LD_INT 5
48880: PUSH
48881: EMPTY
48882: LIST
48883: LIST
48884: LIST
48885: LIST
48886: LIST
48887: ST_TO_ADDR
48888: GO 49819
48890: LD_INT 11
48892: DOUBLE
48893: EQUAL
48894: IFTRUE 48898
48896: GO 48928
48898: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
48899: LD_ADDR_VAR 0 3
48903: PUSH
48904: LD_INT 1
48906: PUSH
48907: LD_INT 2
48909: PUSH
48910: LD_INT 3
48912: PUSH
48913: LD_INT 4
48915: PUSH
48916: LD_INT 5
48918: PUSH
48919: EMPTY
48920: LIST
48921: LIST
48922: LIST
48923: LIST
48924: LIST
48925: ST_TO_ADDR
48926: GO 49819
48928: LD_INT 4
48930: DOUBLE
48931: EQUAL
48932: IFTRUE 48936
48934: GO 48962
48936: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
48937: LD_ADDR_VAR 0 3
48941: PUSH
48942: LD_INT 2
48944: PUSH
48945: LD_INT 3
48947: PUSH
48948: LD_INT 4
48950: PUSH
48951: LD_INT 5
48953: PUSH
48954: EMPTY
48955: LIST
48956: LIST
48957: LIST
48958: LIST
48959: ST_TO_ADDR
48960: GO 49819
48962: LD_INT 5
48964: DOUBLE
48965: EQUAL
48966: IFTRUE 48970
48968: GO 48996
48970: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
48971: LD_ADDR_VAR 0 3
48975: PUSH
48976: LD_INT 2
48978: PUSH
48979: LD_INT 3
48981: PUSH
48982: LD_INT 4
48984: PUSH
48985: LD_INT 5
48987: PUSH
48988: EMPTY
48989: LIST
48990: LIST
48991: LIST
48992: LIST
48993: ST_TO_ADDR
48994: GO 49819
48996: LD_INT 9
48998: DOUBLE
48999: EQUAL
49000: IFTRUE 49004
49002: GO 49030
49004: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
49005: LD_ADDR_VAR 0 3
49009: PUSH
49010: LD_INT 2
49012: PUSH
49013: LD_INT 3
49015: PUSH
49016: LD_INT 4
49018: PUSH
49019: LD_INT 5
49021: PUSH
49022: EMPTY
49023: LIST
49024: LIST
49025: LIST
49026: LIST
49027: ST_TO_ADDR
49028: GO 49819
49030: LD_INT 7
49032: DOUBLE
49033: EQUAL
49034: IFTRUE 49038
49036: GO 49064
49038: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
49039: LD_ADDR_VAR 0 3
49043: PUSH
49044: LD_INT 2
49046: PUSH
49047: LD_INT 3
49049: PUSH
49050: LD_INT 4
49052: PUSH
49053: LD_INT 5
49055: PUSH
49056: EMPTY
49057: LIST
49058: LIST
49059: LIST
49060: LIST
49061: ST_TO_ADDR
49062: GO 49819
49064: LD_INT 12
49066: DOUBLE
49067: EQUAL
49068: IFTRUE 49072
49070: GO 49098
49072: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
49073: LD_ADDR_VAR 0 3
49077: PUSH
49078: LD_INT 2
49080: PUSH
49081: LD_INT 3
49083: PUSH
49084: LD_INT 4
49086: PUSH
49087: LD_INT 5
49089: PUSH
49090: EMPTY
49091: LIST
49092: LIST
49093: LIST
49094: LIST
49095: ST_TO_ADDR
49096: GO 49819
49098: LD_INT 13
49100: DOUBLE
49101: EQUAL
49102: IFTRUE 49106
49104: GO 49132
49106: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
49107: LD_ADDR_VAR 0 3
49111: PUSH
49112: LD_INT 2
49114: PUSH
49115: LD_INT 3
49117: PUSH
49118: LD_INT 4
49120: PUSH
49121: LD_INT 5
49123: PUSH
49124: EMPTY
49125: LIST
49126: LIST
49127: LIST
49128: LIST
49129: ST_TO_ADDR
49130: GO 49819
49132: LD_INT 14
49134: DOUBLE
49135: EQUAL
49136: IFTRUE 49140
49138: GO 49158
49140: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
49141: LD_ADDR_VAR 0 3
49145: PUSH
49146: LD_INT 4
49148: PUSH
49149: LD_INT 5
49151: PUSH
49152: EMPTY
49153: LIST
49154: LIST
49155: ST_TO_ADDR
49156: GO 49819
49158: LD_INT 6
49160: DOUBLE
49161: EQUAL
49162: IFTRUE 49166
49164: GO 49184
49166: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
49167: LD_ADDR_VAR 0 3
49171: PUSH
49172: LD_INT 4
49174: PUSH
49175: LD_INT 5
49177: PUSH
49178: EMPTY
49179: LIST
49180: LIST
49181: ST_TO_ADDR
49182: GO 49819
49184: LD_INT 10
49186: DOUBLE
49187: EQUAL
49188: IFTRUE 49192
49190: GO 49210
49192: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
49193: LD_ADDR_VAR 0 3
49197: PUSH
49198: LD_INT 4
49200: PUSH
49201: LD_INT 5
49203: PUSH
49204: EMPTY
49205: LIST
49206: LIST
49207: ST_TO_ADDR
49208: GO 49819
49210: LD_INT 22
49212: DOUBLE
49213: EQUAL
49214: IFTRUE 49218
49216: GO 49244
49218: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
49219: LD_ADDR_VAR 0 3
49223: PUSH
49224: LD_INT 11
49226: PUSH
49227: LD_INT 12
49229: PUSH
49230: LD_INT 13
49232: PUSH
49233: LD_INT 14
49235: PUSH
49236: EMPTY
49237: LIST
49238: LIST
49239: LIST
49240: LIST
49241: ST_TO_ADDR
49242: GO 49819
49244: LD_INT 23
49246: DOUBLE
49247: EQUAL
49248: IFTRUE 49252
49250: GO 49278
49252: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
49253: LD_ADDR_VAR 0 3
49257: PUSH
49258: LD_INT 11
49260: PUSH
49261: LD_INT 12
49263: PUSH
49264: LD_INT 13
49266: PUSH
49267: LD_INT 14
49269: PUSH
49270: EMPTY
49271: LIST
49272: LIST
49273: LIST
49274: LIST
49275: ST_TO_ADDR
49276: GO 49819
49278: LD_INT 24
49280: DOUBLE
49281: EQUAL
49282: IFTRUE 49286
49284: GO 49312
49286: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
49287: LD_ADDR_VAR 0 3
49291: PUSH
49292: LD_INT 11
49294: PUSH
49295: LD_INT 12
49297: PUSH
49298: LD_INT 13
49300: PUSH
49301: LD_INT 14
49303: PUSH
49304: EMPTY
49305: LIST
49306: LIST
49307: LIST
49308: LIST
49309: ST_TO_ADDR
49310: GO 49819
49312: LD_INT 30
49314: DOUBLE
49315: EQUAL
49316: IFTRUE 49320
49318: GO 49346
49320: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
49321: LD_ADDR_VAR 0 3
49325: PUSH
49326: LD_INT 11
49328: PUSH
49329: LD_INT 12
49331: PUSH
49332: LD_INT 13
49334: PUSH
49335: LD_INT 14
49337: PUSH
49338: EMPTY
49339: LIST
49340: LIST
49341: LIST
49342: LIST
49343: ST_TO_ADDR
49344: GO 49819
49346: LD_INT 25
49348: DOUBLE
49349: EQUAL
49350: IFTRUE 49354
49352: GO 49372
49354: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
49355: LD_ADDR_VAR 0 3
49359: PUSH
49360: LD_INT 13
49362: PUSH
49363: LD_INT 14
49365: PUSH
49366: EMPTY
49367: LIST
49368: LIST
49369: ST_TO_ADDR
49370: GO 49819
49372: LD_INT 27
49374: DOUBLE
49375: EQUAL
49376: IFTRUE 49380
49378: GO 49398
49380: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
49381: LD_ADDR_VAR 0 3
49385: PUSH
49386: LD_INT 13
49388: PUSH
49389: LD_INT 14
49391: PUSH
49392: EMPTY
49393: LIST
49394: LIST
49395: ST_TO_ADDR
49396: GO 49819
49398: LD_INT 28
49400: DOUBLE
49401: EQUAL
49402: IFTRUE 49406
49404: GO 49424
49406: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
49407: LD_ADDR_VAR 0 3
49411: PUSH
49412: LD_INT 13
49414: PUSH
49415: LD_INT 14
49417: PUSH
49418: EMPTY
49419: LIST
49420: LIST
49421: ST_TO_ADDR
49422: GO 49819
49424: LD_INT 29
49426: DOUBLE
49427: EQUAL
49428: IFTRUE 49432
49430: GO 49450
49432: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
49433: LD_ADDR_VAR 0 3
49437: PUSH
49438: LD_INT 13
49440: PUSH
49441: LD_INT 14
49443: PUSH
49444: EMPTY
49445: LIST
49446: LIST
49447: ST_TO_ADDR
49448: GO 49819
49450: LD_INT 31
49452: DOUBLE
49453: EQUAL
49454: IFTRUE 49458
49456: GO 49476
49458: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
49459: LD_ADDR_VAR 0 3
49463: PUSH
49464: LD_INT 13
49466: PUSH
49467: LD_INT 14
49469: PUSH
49470: EMPTY
49471: LIST
49472: LIST
49473: ST_TO_ADDR
49474: GO 49819
49476: LD_INT 26
49478: DOUBLE
49479: EQUAL
49480: IFTRUE 49484
49482: GO 49502
49484: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
49485: LD_ADDR_VAR 0 3
49489: PUSH
49490: LD_INT 13
49492: PUSH
49493: LD_INT 14
49495: PUSH
49496: EMPTY
49497: LIST
49498: LIST
49499: ST_TO_ADDR
49500: GO 49819
49502: LD_INT 42
49504: DOUBLE
49505: EQUAL
49506: IFTRUE 49510
49508: GO 49536
49510: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
49511: LD_ADDR_VAR 0 3
49515: PUSH
49516: LD_INT 21
49518: PUSH
49519: LD_INT 22
49521: PUSH
49522: LD_INT 23
49524: PUSH
49525: LD_INT 24
49527: PUSH
49528: EMPTY
49529: LIST
49530: LIST
49531: LIST
49532: LIST
49533: ST_TO_ADDR
49534: GO 49819
49536: LD_INT 43
49538: DOUBLE
49539: EQUAL
49540: IFTRUE 49544
49542: GO 49570
49544: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
49545: LD_ADDR_VAR 0 3
49549: PUSH
49550: LD_INT 21
49552: PUSH
49553: LD_INT 22
49555: PUSH
49556: LD_INT 23
49558: PUSH
49559: LD_INT 24
49561: PUSH
49562: EMPTY
49563: LIST
49564: LIST
49565: LIST
49566: LIST
49567: ST_TO_ADDR
49568: GO 49819
49570: LD_INT 44
49572: DOUBLE
49573: EQUAL
49574: IFTRUE 49578
49576: GO 49604
49578: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
49579: LD_ADDR_VAR 0 3
49583: PUSH
49584: LD_INT 21
49586: PUSH
49587: LD_INT 22
49589: PUSH
49590: LD_INT 23
49592: PUSH
49593: LD_INT 24
49595: PUSH
49596: EMPTY
49597: LIST
49598: LIST
49599: LIST
49600: LIST
49601: ST_TO_ADDR
49602: GO 49819
49604: LD_INT 45
49606: DOUBLE
49607: EQUAL
49608: IFTRUE 49612
49610: GO 49638
49612: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
49613: LD_ADDR_VAR 0 3
49617: PUSH
49618: LD_INT 21
49620: PUSH
49621: LD_INT 22
49623: PUSH
49624: LD_INT 23
49626: PUSH
49627: LD_INT 24
49629: PUSH
49630: EMPTY
49631: LIST
49632: LIST
49633: LIST
49634: LIST
49635: ST_TO_ADDR
49636: GO 49819
49638: LD_INT 49
49640: DOUBLE
49641: EQUAL
49642: IFTRUE 49646
49644: GO 49672
49646: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
49647: LD_ADDR_VAR 0 3
49651: PUSH
49652: LD_INT 21
49654: PUSH
49655: LD_INT 22
49657: PUSH
49658: LD_INT 23
49660: PUSH
49661: LD_INT 24
49663: PUSH
49664: EMPTY
49665: LIST
49666: LIST
49667: LIST
49668: LIST
49669: ST_TO_ADDR
49670: GO 49819
49672: LD_INT 51
49674: DOUBLE
49675: EQUAL
49676: IFTRUE 49680
49678: GO 49706
49680: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
49681: LD_ADDR_VAR 0 3
49685: PUSH
49686: LD_INT 21
49688: PUSH
49689: LD_INT 22
49691: PUSH
49692: LD_INT 23
49694: PUSH
49695: LD_INT 24
49697: PUSH
49698: EMPTY
49699: LIST
49700: LIST
49701: LIST
49702: LIST
49703: ST_TO_ADDR
49704: GO 49819
49706: LD_INT 52
49708: DOUBLE
49709: EQUAL
49710: IFTRUE 49714
49712: GO 49740
49714: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
49715: LD_ADDR_VAR 0 3
49719: PUSH
49720: LD_INT 21
49722: PUSH
49723: LD_INT 22
49725: PUSH
49726: LD_INT 23
49728: PUSH
49729: LD_INT 24
49731: PUSH
49732: EMPTY
49733: LIST
49734: LIST
49735: LIST
49736: LIST
49737: ST_TO_ADDR
49738: GO 49819
49740: LD_INT 53
49742: DOUBLE
49743: EQUAL
49744: IFTRUE 49748
49746: GO 49766
49748: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
49749: LD_ADDR_VAR 0 3
49753: PUSH
49754: LD_INT 23
49756: PUSH
49757: LD_INT 24
49759: PUSH
49760: EMPTY
49761: LIST
49762: LIST
49763: ST_TO_ADDR
49764: GO 49819
49766: LD_INT 46
49768: DOUBLE
49769: EQUAL
49770: IFTRUE 49774
49772: GO 49792
49774: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
49775: LD_ADDR_VAR 0 3
49779: PUSH
49780: LD_INT 23
49782: PUSH
49783: LD_INT 24
49785: PUSH
49786: EMPTY
49787: LIST
49788: LIST
49789: ST_TO_ADDR
49790: GO 49819
49792: LD_INT 47
49794: DOUBLE
49795: EQUAL
49796: IFTRUE 49800
49798: GO 49818
49800: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
49801: LD_ADDR_VAR 0 3
49805: PUSH
49806: LD_INT 23
49808: PUSH
49809: LD_INT 24
49811: PUSH
49812: EMPTY
49813: LIST
49814: LIST
49815: ST_TO_ADDR
49816: GO 49819
49818: POP
// result := ( chassis in result ) ;
49819: LD_ADDR_VAR 0 3
49823: PUSH
49824: LD_VAR 0 1
49828: PUSH
49829: LD_VAR 0 3
49833: IN
49834: ST_TO_ADDR
// end ;
49835: LD_VAR 0 3
49839: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
49840: LD_INT 0
49842: PPUSH
49843: PPUSH
49844: PPUSH
49845: PPUSH
49846: PPUSH
49847: PPUSH
49848: PPUSH
// result := array ;
49849: LD_ADDR_VAR 0 5
49853: PUSH
49854: LD_VAR 0 1
49858: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
49859: LD_VAR 0 1
49863: NOT
49864: PUSH
49865: LD_VAR 0 2
49869: NOT
49870: OR
49871: PUSH
49872: LD_VAR 0 3
49876: NOT
49877: OR
49878: PUSH
49879: LD_VAR 0 2
49883: PUSH
49884: LD_VAR 0 1
49888: GREATER
49889: OR
49890: PUSH
49891: LD_VAR 0 3
49895: PUSH
49896: LD_VAR 0 1
49900: GREATER
49901: OR
49902: IFFALSE 49906
// exit ;
49904: GO 50202
// if direction then
49906: LD_VAR 0 4
49910: IFFALSE 49974
// begin d := 1 ;
49912: LD_ADDR_VAR 0 9
49916: PUSH
49917: LD_INT 1
49919: ST_TO_ADDR
// if i_from > i_to then
49920: LD_VAR 0 2
49924: PUSH
49925: LD_VAR 0 3
49929: GREATER
49930: IFFALSE 49956
// length := ( array - i_from ) + i_to else
49932: LD_ADDR_VAR 0 11
49936: PUSH
49937: LD_VAR 0 1
49941: PUSH
49942: LD_VAR 0 2
49946: MINUS
49947: PUSH
49948: LD_VAR 0 3
49952: PLUS
49953: ST_TO_ADDR
49954: GO 49972
// length := i_to - i_from ;
49956: LD_ADDR_VAR 0 11
49960: PUSH
49961: LD_VAR 0 3
49965: PUSH
49966: LD_VAR 0 2
49970: MINUS
49971: ST_TO_ADDR
// end else
49972: GO 50035
// begin d := - 1 ;
49974: LD_ADDR_VAR 0 9
49978: PUSH
49979: LD_INT 1
49981: NEG
49982: ST_TO_ADDR
// if i_from > i_to then
49983: LD_VAR 0 2
49987: PUSH
49988: LD_VAR 0 3
49992: GREATER
49993: IFFALSE 50013
// length := i_from - i_to else
49995: LD_ADDR_VAR 0 11
49999: PUSH
50000: LD_VAR 0 2
50004: PUSH
50005: LD_VAR 0 3
50009: MINUS
50010: ST_TO_ADDR
50011: GO 50035
// length := ( array - i_to ) + i_from ;
50013: LD_ADDR_VAR 0 11
50017: PUSH
50018: LD_VAR 0 1
50022: PUSH
50023: LD_VAR 0 3
50027: MINUS
50028: PUSH
50029: LD_VAR 0 2
50033: PLUS
50034: ST_TO_ADDR
// end ; if not length then
50035: LD_VAR 0 11
50039: NOT
50040: IFFALSE 50044
// exit ;
50042: GO 50202
// tmp := array ;
50044: LD_ADDR_VAR 0 10
50048: PUSH
50049: LD_VAR 0 1
50053: ST_TO_ADDR
// for i = 1 to length do
50054: LD_ADDR_VAR 0 6
50058: PUSH
50059: DOUBLE
50060: LD_INT 1
50062: DEC
50063: ST_TO_ADDR
50064: LD_VAR 0 11
50068: PUSH
50069: FOR_TO
50070: IFFALSE 50190
// begin for j = 1 to array do
50072: LD_ADDR_VAR 0 7
50076: PUSH
50077: DOUBLE
50078: LD_INT 1
50080: DEC
50081: ST_TO_ADDR
50082: LD_VAR 0 1
50086: PUSH
50087: FOR_TO
50088: IFFALSE 50176
// begin k := j + d ;
50090: LD_ADDR_VAR 0 8
50094: PUSH
50095: LD_VAR 0 7
50099: PUSH
50100: LD_VAR 0 9
50104: PLUS
50105: ST_TO_ADDR
// if k > array then
50106: LD_VAR 0 8
50110: PUSH
50111: LD_VAR 0 1
50115: GREATER
50116: IFFALSE 50126
// k := 1 ;
50118: LD_ADDR_VAR 0 8
50122: PUSH
50123: LD_INT 1
50125: ST_TO_ADDR
// if not k then
50126: LD_VAR 0 8
50130: NOT
50131: IFFALSE 50143
// k := array ;
50133: LD_ADDR_VAR 0 8
50137: PUSH
50138: LD_VAR 0 1
50142: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
50143: LD_ADDR_VAR 0 10
50147: PUSH
50148: LD_VAR 0 10
50152: PPUSH
50153: LD_VAR 0 8
50157: PPUSH
50158: LD_VAR 0 1
50162: PUSH
50163: LD_VAR 0 7
50167: ARRAY
50168: PPUSH
50169: CALL_OW 1
50173: ST_TO_ADDR
// end ;
50174: GO 50087
50176: POP
50177: POP
// array := tmp ;
50178: LD_ADDR_VAR 0 1
50182: PUSH
50183: LD_VAR 0 10
50187: ST_TO_ADDR
// end ;
50188: GO 50069
50190: POP
50191: POP
// result := array ;
50192: LD_ADDR_VAR 0 5
50196: PUSH
50197: LD_VAR 0 1
50201: ST_TO_ADDR
// end ;
50202: LD_VAR 0 5
50206: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
50207: LD_INT 0
50209: PPUSH
50210: PPUSH
// result := 0 ;
50211: LD_ADDR_VAR 0 3
50215: PUSH
50216: LD_INT 0
50218: ST_TO_ADDR
// if not array or not value in array then
50219: LD_VAR 0 1
50223: NOT
50224: PUSH
50225: LD_VAR 0 2
50229: PUSH
50230: LD_VAR 0 1
50234: IN
50235: NOT
50236: OR
50237: IFFALSE 50241
// exit ;
50239: GO 50295
// for i = 1 to array do
50241: LD_ADDR_VAR 0 4
50245: PUSH
50246: DOUBLE
50247: LD_INT 1
50249: DEC
50250: ST_TO_ADDR
50251: LD_VAR 0 1
50255: PUSH
50256: FOR_TO
50257: IFFALSE 50293
// if value = array [ i ] then
50259: LD_VAR 0 2
50263: PUSH
50264: LD_VAR 0 1
50268: PUSH
50269: LD_VAR 0 4
50273: ARRAY
50274: EQUAL
50275: IFFALSE 50291
// begin result := i ;
50277: LD_ADDR_VAR 0 3
50281: PUSH
50282: LD_VAR 0 4
50286: ST_TO_ADDR
// exit ;
50287: POP
50288: POP
50289: GO 50295
// end ;
50291: GO 50256
50293: POP
50294: POP
// end ;
50295: LD_VAR 0 3
50299: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
50300: LD_INT 0
50302: PPUSH
// vc_chassis := chassis ;
50303: LD_ADDR_OWVAR 37
50307: PUSH
50308: LD_VAR 0 1
50312: ST_TO_ADDR
// vc_engine := engine ;
50313: LD_ADDR_OWVAR 39
50317: PUSH
50318: LD_VAR 0 2
50322: ST_TO_ADDR
// vc_control := control ;
50323: LD_ADDR_OWVAR 38
50327: PUSH
50328: LD_VAR 0 3
50332: ST_TO_ADDR
// vc_weapon := weapon ;
50333: LD_ADDR_OWVAR 40
50337: PUSH
50338: LD_VAR 0 4
50342: ST_TO_ADDR
// vc_fuel_battery := fuel ;
50343: LD_ADDR_OWVAR 41
50347: PUSH
50348: LD_VAR 0 5
50352: ST_TO_ADDR
// end ;
50353: LD_VAR 0 6
50357: RET
// export function WantPlant ( unit ) ; var task ; begin
50358: LD_INT 0
50360: PPUSH
50361: PPUSH
// result := false ;
50362: LD_ADDR_VAR 0 2
50366: PUSH
50367: LD_INT 0
50369: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
50370: LD_ADDR_VAR 0 3
50374: PUSH
50375: LD_VAR 0 1
50379: PPUSH
50380: CALL_OW 437
50384: ST_TO_ADDR
// if task then
50385: LD_VAR 0 3
50389: IFFALSE 50417
// if task [ 1 ] [ 1 ] = p then
50391: LD_VAR 0 3
50395: PUSH
50396: LD_INT 1
50398: ARRAY
50399: PUSH
50400: LD_INT 1
50402: ARRAY
50403: PUSH
50404: LD_STRING p
50406: EQUAL
50407: IFFALSE 50417
// result := true ;
50409: LD_ADDR_VAR 0 2
50413: PUSH
50414: LD_INT 1
50416: ST_TO_ADDR
// end ;
50417: LD_VAR 0 2
50421: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
50422: LD_INT 0
50424: PPUSH
50425: PPUSH
50426: PPUSH
50427: PPUSH
// if pos < 1 then
50428: LD_VAR 0 2
50432: PUSH
50433: LD_INT 1
50435: LESS
50436: IFFALSE 50440
// exit ;
50438: GO 50743
// if pos = 1 then
50440: LD_VAR 0 2
50444: PUSH
50445: LD_INT 1
50447: EQUAL
50448: IFFALSE 50481
// result := Replace ( arr , pos [ 1 ] , value ) else
50450: LD_ADDR_VAR 0 4
50454: PUSH
50455: LD_VAR 0 1
50459: PPUSH
50460: LD_VAR 0 2
50464: PUSH
50465: LD_INT 1
50467: ARRAY
50468: PPUSH
50469: LD_VAR 0 3
50473: PPUSH
50474: CALL_OW 1
50478: ST_TO_ADDR
50479: GO 50743
// begin tmp := arr ;
50481: LD_ADDR_VAR 0 6
50485: PUSH
50486: LD_VAR 0 1
50490: ST_TO_ADDR
// s_arr := [ tmp ] ;
50491: LD_ADDR_VAR 0 7
50495: PUSH
50496: LD_VAR 0 6
50500: PUSH
50501: EMPTY
50502: LIST
50503: ST_TO_ADDR
// for i = 1 to pos - 1 do
50504: LD_ADDR_VAR 0 5
50508: PUSH
50509: DOUBLE
50510: LD_INT 1
50512: DEC
50513: ST_TO_ADDR
50514: LD_VAR 0 2
50518: PUSH
50519: LD_INT 1
50521: MINUS
50522: PUSH
50523: FOR_TO
50524: IFFALSE 50569
// begin tmp := tmp [ pos [ i ] ] ;
50526: LD_ADDR_VAR 0 6
50530: PUSH
50531: LD_VAR 0 6
50535: PUSH
50536: LD_VAR 0 2
50540: PUSH
50541: LD_VAR 0 5
50545: ARRAY
50546: ARRAY
50547: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
50548: LD_ADDR_VAR 0 7
50552: PUSH
50553: LD_VAR 0 7
50557: PUSH
50558: LD_VAR 0 6
50562: PUSH
50563: EMPTY
50564: LIST
50565: ADD
50566: ST_TO_ADDR
// end ;
50567: GO 50523
50569: POP
50570: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
50571: LD_ADDR_VAR 0 6
50575: PUSH
50576: LD_VAR 0 6
50580: PPUSH
50581: LD_VAR 0 2
50585: PUSH
50586: LD_VAR 0 2
50590: ARRAY
50591: PPUSH
50592: LD_VAR 0 3
50596: PPUSH
50597: CALL_OW 1
50601: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
50602: LD_ADDR_VAR 0 7
50606: PUSH
50607: LD_VAR 0 7
50611: PPUSH
50612: LD_VAR 0 7
50616: PPUSH
50617: LD_VAR 0 6
50621: PPUSH
50622: CALL_OW 1
50626: ST_TO_ADDR
// for i = s_arr downto 2 do
50627: LD_ADDR_VAR 0 5
50631: PUSH
50632: DOUBLE
50633: LD_VAR 0 7
50637: INC
50638: ST_TO_ADDR
50639: LD_INT 2
50641: PUSH
50642: FOR_DOWNTO
50643: IFFALSE 50727
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
50645: LD_ADDR_VAR 0 6
50649: PUSH
50650: LD_VAR 0 7
50654: PUSH
50655: LD_VAR 0 5
50659: PUSH
50660: LD_INT 1
50662: MINUS
50663: ARRAY
50664: PPUSH
50665: LD_VAR 0 2
50669: PUSH
50670: LD_VAR 0 5
50674: PUSH
50675: LD_INT 1
50677: MINUS
50678: ARRAY
50679: PPUSH
50680: LD_VAR 0 7
50684: PUSH
50685: LD_VAR 0 5
50689: ARRAY
50690: PPUSH
50691: CALL_OW 1
50695: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
50696: LD_ADDR_VAR 0 7
50700: PUSH
50701: LD_VAR 0 7
50705: PPUSH
50706: LD_VAR 0 5
50710: PUSH
50711: LD_INT 1
50713: MINUS
50714: PPUSH
50715: LD_VAR 0 6
50719: PPUSH
50720: CALL_OW 1
50724: ST_TO_ADDR
// end ;
50725: GO 50642
50727: POP
50728: POP
// result := s_arr [ 1 ] ;
50729: LD_ADDR_VAR 0 4
50733: PUSH
50734: LD_VAR 0 7
50738: PUSH
50739: LD_INT 1
50741: ARRAY
50742: ST_TO_ADDR
// end ; end ;
50743: LD_VAR 0 4
50747: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
50748: LD_INT 0
50750: PPUSH
50751: PPUSH
// if not list then
50752: LD_VAR 0 1
50756: NOT
50757: IFFALSE 50761
// exit ;
50759: GO 50852
// i := list [ pos1 ] ;
50761: LD_ADDR_VAR 0 5
50765: PUSH
50766: LD_VAR 0 1
50770: PUSH
50771: LD_VAR 0 2
50775: ARRAY
50776: ST_TO_ADDR
// if not i then
50777: LD_VAR 0 5
50781: NOT
50782: IFFALSE 50786
// exit ;
50784: GO 50852
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
50786: LD_ADDR_VAR 0 1
50790: PUSH
50791: LD_VAR 0 1
50795: PPUSH
50796: LD_VAR 0 2
50800: PPUSH
50801: LD_VAR 0 1
50805: PUSH
50806: LD_VAR 0 3
50810: ARRAY
50811: PPUSH
50812: CALL_OW 1
50816: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
50817: LD_ADDR_VAR 0 1
50821: PUSH
50822: LD_VAR 0 1
50826: PPUSH
50827: LD_VAR 0 3
50831: PPUSH
50832: LD_VAR 0 5
50836: PPUSH
50837: CALL_OW 1
50841: ST_TO_ADDR
// result := list ;
50842: LD_ADDR_VAR 0 4
50846: PUSH
50847: LD_VAR 0 1
50851: ST_TO_ADDR
// end ;
50852: LD_VAR 0 4
50856: RET
// export function Add ( list , pos , val ) ; begin
50857: LD_INT 0
50859: PPUSH
// result := ReplaceIn ( list , pos , val ) end ;
50860: LD_ADDR_VAR 0 4
50864: PUSH
50865: LD_VAR 0 1
50869: PPUSH
50870: LD_VAR 0 2
50874: PPUSH
50875: LD_VAR 0 3
50879: PPUSH
50880: CALL 50422 0 3
50884: ST_TO_ADDR
50885: LD_VAR 0 4
50889: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
50890: LD_INT 0
50892: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
50893: LD_ADDR_VAR 0 5
50897: PUSH
50898: LD_VAR 0 1
50902: PPUSH
50903: CALL_OW 250
50907: PPUSH
50908: LD_VAR 0 1
50912: PPUSH
50913: CALL_OW 251
50917: PPUSH
50918: LD_VAR 0 2
50922: PPUSH
50923: LD_VAR 0 3
50927: PPUSH
50928: LD_VAR 0 4
50932: PPUSH
50933: CALL 50943 0 5
50937: ST_TO_ADDR
// end ;
50938: LD_VAR 0 5
50942: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
50943: LD_INT 0
50945: PPUSH
50946: PPUSH
50947: PPUSH
50948: PPUSH
// if not list then
50949: LD_VAR 0 3
50953: NOT
50954: IFFALSE 50958
// exit ;
50956: GO 51346
// result := [ ] ;
50958: LD_ADDR_VAR 0 6
50962: PUSH
50963: EMPTY
50964: ST_TO_ADDR
// for i in list do
50965: LD_ADDR_VAR 0 7
50969: PUSH
50970: LD_VAR 0 3
50974: PUSH
50975: FOR_IN
50976: IFFALSE 51178
// begin tmp := GetDistUnitXY ( i , x , y ) ;
50978: LD_ADDR_VAR 0 9
50982: PUSH
50983: LD_VAR 0 7
50987: PPUSH
50988: LD_VAR 0 1
50992: PPUSH
50993: LD_VAR 0 2
50997: PPUSH
50998: CALL_OW 297
51002: ST_TO_ADDR
// if not result then
51003: LD_VAR 0 6
51007: NOT
51008: IFFALSE 51034
// result := [ [ i , tmp ] ] else
51010: LD_ADDR_VAR 0 6
51014: PUSH
51015: LD_VAR 0 7
51019: PUSH
51020: LD_VAR 0 9
51024: PUSH
51025: EMPTY
51026: LIST
51027: LIST
51028: PUSH
51029: EMPTY
51030: LIST
51031: ST_TO_ADDR
51032: GO 51176
// begin if result [ result ] [ 2 ] < tmp then
51034: LD_VAR 0 6
51038: PUSH
51039: LD_VAR 0 6
51043: ARRAY
51044: PUSH
51045: LD_INT 2
51047: ARRAY
51048: PUSH
51049: LD_VAR 0 9
51053: LESS
51054: IFFALSE 51096
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
51056: LD_ADDR_VAR 0 6
51060: PUSH
51061: LD_VAR 0 6
51065: PPUSH
51066: LD_VAR 0 6
51070: PUSH
51071: LD_INT 1
51073: PLUS
51074: PPUSH
51075: LD_VAR 0 7
51079: PUSH
51080: LD_VAR 0 9
51084: PUSH
51085: EMPTY
51086: LIST
51087: LIST
51088: PPUSH
51089: CALL_OW 2
51093: ST_TO_ADDR
51094: GO 51176
// for j = 1 to result do
51096: LD_ADDR_VAR 0 8
51100: PUSH
51101: DOUBLE
51102: LD_INT 1
51104: DEC
51105: ST_TO_ADDR
51106: LD_VAR 0 6
51110: PUSH
51111: FOR_TO
51112: IFFALSE 51174
// begin if tmp < result [ j ] [ 2 ] then
51114: LD_VAR 0 9
51118: PUSH
51119: LD_VAR 0 6
51123: PUSH
51124: LD_VAR 0 8
51128: ARRAY
51129: PUSH
51130: LD_INT 2
51132: ARRAY
51133: LESS
51134: IFFALSE 51172
// begin result := Insert ( result , j , [ i , tmp ] ) ;
51136: LD_ADDR_VAR 0 6
51140: PUSH
51141: LD_VAR 0 6
51145: PPUSH
51146: LD_VAR 0 8
51150: PPUSH
51151: LD_VAR 0 7
51155: PUSH
51156: LD_VAR 0 9
51160: PUSH
51161: EMPTY
51162: LIST
51163: LIST
51164: PPUSH
51165: CALL_OW 2
51169: ST_TO_ADDR
// break ;
51170: GO 51174
// end ; end ;
51172: GO 51111
51174: POP
51175: POP
// end ; end ;
51176: GO 50975
51178: POP
51179: POP
// if result and not asc then
51180: LD_VAR 0 6
51184: PUSH
51185: LD_VAR 0 4
51189: NOT
51190: AND
51191: IFFALSE 51266
// begin tmp := result ;
51193: LD_ADDR_VAR 0 9
51197: PUSH
51198: LD_VAR 0 6
51202: ST_TO_ADDR
// for i = tmp downto 1 do
51203: LD_ADDR_VAR 0 7
51207: PUSH
51208: DOUBLE
51209: LD_VAR 0 9
51213: INC
51214: ST_TO_ADDR
51215: LD_INT 1
51217: PUSH
51218: FOR_DOWNTO
51219: IFFALSE 51264
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
51221: LD_ADDR_VAR 0 6
51225: PUSH
51226: LD_VAR 0 6
51230: PPUSH
51231: LD_VAR 0 9
51235: PUSH
51236: LD_VAR 0 7
51240: MINUS
51241: PUSH
51242: LD_INT 1
51244: PLUS
51245: PPUSH
51246: LD_VAR 0 9
51250: PUSH
51251: LD_VAR 0 7
51255: ARRAY
51256: PPUSH
51257: CALL_OW 1
51261: ST_TO_ADDR
51262: GO 51218
51264: POP
51265: POP
// end ; tmp := [ ] ;
51266: LD_ADDR_VAR 0 9
51270: PUSH
51271: EMPTY
51272: ST_TO_ADDR
// if mode then
51273: LD_VAR 0 5
51277: IFFALSE 51346
// begin for i = 1 to result do
51279: LD_ADDR_VAR 0 7
51283: PUSH
51284: DOUBLE
51285: LD_INT 1
51287: DEC
51288: ST_TO_ADDR
51289: LD_VAR 0 6
51293: PUSH
51294: FOR_TO
51295: IFFALSE 51334
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
51297: LD_ADDR_VAR 0 9
51301: PUSH
51302: LD_VAR 0 9
51306: PPUSH
51307: LD_VAR 0 7
51311: PPUSH
51312: LD_VAR 0 6
51316: PUSH
51317: LD_VAR 0 7
51321: ARRAY
51322: PUSH
51323: LD_INT 1
51325: ARRAY
51326: PPUSH
51327: CALL_OW 1
51331: ST_TO_ADDR
51332: GO 51294
51334: POP
51335: POP
// result := tmp ;
51336: LD_ADDR_VAR 0 6
51340: PUSH
51341: LD_VAR 0 9
51345: ST_TO_ADDR
// end ; end ;
51346: LD_VAR 0 6
51350: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
51351: LD_INT 0
51353: PPUSH
51354: PPUSH
51355: PPUSH
51356: PPUSH
51357: PPUSH
51358: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
51359: LD_ADDR_VAR 0 5
51363: PUSH
51364: LD_INT 0
51366: PUSH
51367: LD_INT 0
51369: PUSH
51370: LD_INT 0
51372: PUSH
51373: EMPTY
51374: PUSH
51375: EMPTY
51376: LIST
51377: LIST
51378: LIST
51379: LIST
51380: ST_TO_ADDR
// if not x or not y then
51381: LD_VAR 0 2
51385: NOT
51386: PUSH
51387: LD_VAR 0 3
51391: NOT
51392: OR
51393: IFFALSE 51397
// exit ;
51395: GO 53043
// if not range then
51397: LD_VAR 0 4
51401: NOT
51402: IFFALSE 51412
// range := 10 ;
51404: LD_ADDR_VAR 0 4
51408: PUSH
51409: LD_INT 10
51411: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51412: LD_ADDR_VAR 0 8
51416: PUSH
51417: LD_INT 81
51419: PUSH
51420: LD_VAR 0 1
51424: PUSH
51425: EMPTY
51426: LIST
51427: LIST
51428: PUSH
51429: LD_INT 92
51431: PUSH
51432: LD_VAR 0 2
51436: PUSH
51437: LD_VAR 0 3
51441: PUSH
51442: LD_VAR 0 4
51446: PUSH
51447: EMPTY
51448: LIST
51449: LIST
51450: LIST
51451: LIST
51452: PUSH
51453: LD_INT 3
51455: PUSH
51456: LD_INT 21
51458: PUSH
51459: LD_INT 3
51461: PUSH
51462: EMPTY
51463: LIST
51464: LIST
51465: PUSH
51466: EMPTY
51467: LIST
51468: LIST
51469: PUSH
51470: EMPTY
51471: LIST
51472: LIST
51473: LIST
51474: PPUSH
51475: CALL_OW 69
51479: ST_TO_ADDR
// if not tmp then
51480: LD_VAR 0 8
51484: NOT
51485: IFFALSE 51489
// exit ;
51487: GO 53043
// for i in tmp do
51489: LD_ADDR_VAR 0 6
51493: PUSH
51494: LD_VAR 0 8
51498: PUSH
51499: FOR_IN
51500: IFFALSE 53018
// begin points := [ 0 , 0 , 0 ] ;
51502: LD_ADDR_VAR 0 9
51506: PUSH
51507: LD_INT 0
51509: PUSH
51510: LD_INT 0
51512: PUSH
51513: LD_INT 0
51515: PUSH
51516: EMPTY
51517: LIST
51518: LIST
51519: LIST
51520: ST_TO_ADDR
// bpoints := 1 ;
51521: LD_ADDR_VAR 0 10
51525: PUSH
51526: LD_INT 1
51528: ST_TO_ADDR
// case GetType ( i ) of unit_human :
51529: LD_VAR 0 6
51533: PPUSH
51534: CALL_OW 247
51538: PUSH
51539: LD_INT 1
51541: DOUBLE
51542: EQUAL
51543: IFTRUE 51547
51545: GO 52125
51547: POP
// begin if GetClass ( i ) = 1 then
51548: LD_VAR 0 6
51552: PPUSH
51553: CALL_OW 257
51557: PUSH
51558: LD_INT 1
51560: EQUAL
51561: IFFALSE 51582
// points := [ 10 , 5 , 3 ] ;
51563: LD_ADDR_VAR 0 9
51567: PUSH
51568: LD_INT 10
51570: PUSH
51571: LD_INT 5
51573: PUSH
51574: LD_INT 3
51576: PUSH
51577: EMPTY
51578: LIST
51579: LIST
51580: LIST
51581: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
51582: LD_VAR 0 6
51586: PPUSH
51587: CALL_OW 257
51591: PUSH
51592: LD_INT 2
51594: PUSH
51595: LD_INT 3
51597: PUSH
51598: LD_INT 4
51600: PUSH
51601: EMPTY
51602: LIST
51603: LIST
51604: LIST
51605: IN
51606: IFFALSE 51627
// points := [ 3 , 2 , 1 ] ;
51608: LD_ADDR_VAR 0 9
51612: PUSH
51613: LD_INT 3
51615: PUSH
51616: LD_INT 2
51618: PUSH
51619: LD_INT 1
51621: PUSH
51622: EMPTY
51623: LIST
51624: LIST
51625: LIST
51626: ST_TO_ADDR
// if GetClass ( i ) = 5 then
51627: LD_VAR 0 6
51631: PPUSH
51632: CALL_OW 257
51636: PUSH
51637: LD_INT 5
51639: EQUAL
51640: IFFALSE 51661
// points := [ 130 , 5 , 2 ] ;
51642: LD_ADDR_VAR 0 9
51646: PUSH
51647: LD_INT 130
51649: PUSH
51650: LD_INT 5
51652: PUSH
51653: LD_INT 2
51655: PUSH
51656: EMPTY
51657: LIST
51658: LIST
51659: LIST
51660: ST_TO_ADDR
// if GetClass ( i ) = 8 then
51661: LD_VAR 0 6
51665: PPUSH
51666: CALL_OW 257
51670: PUSH
51671: LD_INT 8
51673: EQUAL
51674: IFFALSE 51695
// points := [ 35 , 35 , 30 ] ;
51676: LD_ADDR_VAR 0 9
51680: PUSH
51681: LD_INT 35
51683: PUSH
51684: LD_INT 35
51686: PUSH
51687: LD_INT 30
51689: PUSH
51690: EMPTY
51691: LIST
51692: LIST
51693: LIST
51694: ST_TO_ADDR
// if GetClass ( i ) = 9 then
51695: LD_VAR 0 6
51699: PPUSH
51700: CALL_OW 257
51704: PUSH
51705: LD_INT 9
51707: EQUAL
51708: IFFALSE 51729
// points := [ 20 , 55 , 40 ] ;
51710: LD_ADDR_VAR 0 9
51714: PUSH
51715: LD_INT 20
51717: PUSH
51718: LD_INT 55
51720: PUSH
51721: LD_INT 40
51723: PUSH
51724: EMPTY
51725: LIST
51726: LIST
51727: LIST
51728: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
51729: LD_VAR 0 6
51733: PPUSH
51734: CALL_OW 257
51738: PUSH
51739: LD_INT 12
51741: PUSH
51742: LD_INT 16
51744: PUSH
51745: EMPTY
51746: LIST
51747: LIST
51748: IN
51749: IFFALSE 51770
// points := [ 5 , 3 , 2 ] ;
51751: LD_ADDR_VAR 0 9
51755: PUSH
51756: LD_INT 5
51758: PUSH
51759: LD_INT 3
51761: PUSH
51762: LD_INT 2
51764: PUSH
51765: EMPTY
51766: LIST
51767: LIST
51768: LIST
51769: ST_TO_ADDR
// if GetClass ( i ) = 17 then
51770: LD_VAR 0 6
51774: PPUSH
51775: CALL_OW 257
51779: PUSH
51780: LD_INT 17
51782: EQUAL
51783: IFFALSE 51804
// points := [ 100 , 50 , 75 ] ;
51785: LD_ADDR_VAR 0 9
51789: PUSH
51790: LD_INT 100
51792: PUSH
51793: LD_INT 50
51795: PUSH
51796: LD_INT 75
51798: PUSH
51799: EMPTY
51800: LIST
51801: LIST
51802: LIST
51803: ST_TO_ADDR
// if GetClass ( i ) = 15 then
51804: LD_VAR 0 6
51808: PPUSH
51809: CALL_OW 257
51813: PUSH
51814: LD_INT 15
51816: EQUAL
51817: IFFALSE 51838
// points := [ 10 , 5 , 3 ] ;
51819: LD_ADDR_VAR 0 9
51823: PUSH
51824: LD_INT 10
51826: PUSH
51827: LD_INT 5
51829: PUSH
51830: LD_INT 3
51832: PUSH
51833: EMPTY
51834: LIST
51835: LIST
51836: LIST
51837: ST_TO_ADDR
// if GetClass ( i ) = 14 then
51838: LD_VAR 0 6
51842: PPUSH
51843: CALL_OW 257
51847: PUSH
51848: LD_INT 14
51850: EQUAL
51851: IFFALSE 51872
// points := [ 10 , 0 , 0 ] ;
51853: LD_ADDR_VAR 0 9
51857: PUSH
51858: LD_INT 10
51860: PUSH
51861: LD_INT 0
51863: PUSH
51864: LD_INT 0
51866: PUSH
51867: EMPTY
51868: LIST
51869: LIST
51870: LIST
51871: ST_TO_ADDR
// if GetClass ( i ) = 11 then
51872: LD_VAR 0 6
51876: PPUSH
51877: CALL_OW 257
51881: PUSH
51882: LD_INT 11
51884: EQUAL
51885: IFFALSE 51906
// points := [ 30 , 10 , 5 ] ;
51887: LD_ADDR_VAR 0 9
51891: PUSH
51892: LD_INT 30
51894: PUSH
51895: LD_INT 10
51897: PUSH
51898: LD_INT 5
51900: PUSH
51901: EMPTY
51902: LIST
51903: LIST
51904: LIST
51905: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
51906: LD_VAR 0 1
51910: PPUSH
51911: LD_INT 5
51913: PPUSH
51914: CALL_OW 321
51918: PUSH
51919: LD_INT 2
51921: EQUAL
51922: IFFALSE 51939
// bpoints := bpoints * 1.8 ;
51924: LD_ADDR_VAR 0 10
51928: PUSH
51929: LD_VAR 0 10
51933: PUSH
51934: LD_REAL  1.80000000000000E+0000
51937: MUL
51938: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
51939: LD_VAR 0 6
51943: PPUSH
51944: CALL_OW 257
51948: PUSH
51949: LD_INT 1
51951: PUSH
51952: LD_INT 2
51954: PUSH
51955: LD_INT 3
51957: PUSH
51958: LD_INT 4
51960: PUSH
51961: EMPTY
51962: LIST
51963: LIST
51964: LIST
51965: LIST
51966: IN
51967: PUSH
51968: LD_VAR 0 1
51972: PPUSH
51973: LD_INT 51
51975: PPUSH
51976: CALL_OW 321
51980: PUSH
51981: LD_INT 2
51983: EQUAL
51984: AND
51985: IFFALSE 52002
// bpoints := bpoints * 1.2 ;
51987: LD_ADDR_VAR 0 10
51991: PUSH
51992: LD_VAR 0 10
51996: PUSH
51997: LD_REAL  1.20000000000000E+0000
52000: MUL
52001: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
52002: LD_VAR 0 6
52006: PPUSH
52007: CALL_OW 257
52011: PUSH
52012: LD_INT 5
52014: PUSH
52015: LD_INT 7
52017: PUSH
52018: LD_INT 9
52020: PUSH
52021: EMPTY
52022: LIST
52023: LIST
52024: LIST
52025: IN
52026: PUSH
52027: LD_VAR 0 1
52031: PPUSH
52032: LD_INT 52
52034: PPUSH
52035: CALL_OW 321
52039: PUSH
52040: LD_INT 2
52042: EQUAL
52043: AND
52044: IFFALSE 52061
// bpoints := bpoints * 1.5 ;
52046: LD_ADDR_VAR 0 10
52050: PUSH
52051: LD_VAR 0 10
52055: PUSH
52056: LD_REAL  1.50000000000000E+0000
52059: MUL
52060: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
52061: LD_VAR 0 1
52065: PPUSH
52066: LD_INT 66
52068: PPUSH
52069: CALL_OW 321
52073: PUSH
52074: LD_INT 2
52076: EQUAL
52077: IFFALSE 52094
// bpoints := bpoints * 1.1 ;
52079: LD_ADDR_VAR 0 10
52083: PUSH
52084: LD_VAR 0 10
52088: PUSH
52089: LD_REAL  1.10000000000000E+0000
52092: MUL
52093: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
52094: LD_ADDR_VAR 0 10
52098: PUSH
52099: LD_VAR 0 10
52103: PUSH
52104: LD_VAR 0 6
52108: PPUSH
52109: LD_INT 1
52111: PPUSH
52112: CALL_OW 259
52116: PUSH
52117: LD_REAL  1.15000000000000E+0000
52120: MUL
52121: MUL
52122: ST_TO_ADDR
// end ; unit_vehicle :
52123: GO 52947
52125: LD_INT 2
52127: DOUBLE
52128: EQUAL
52129: IFTRUE 52133
52131: GO 52935
52133: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
52134: LD_VAR 0 6
52138: PPUSH
52139: CALL_OW 264
52143: PUSH
52144: LD_INT 2
52146: PUSH
52147: LD_INT 42
52149: PUSH
52150: LD_INT 24
52152: PUSH
52153: EMPTY
52154: LIST
52155: LIST
52156: LIST
52157: IN
52158: IFFALSE 52179
// points := [ 25 , 5 , 3 ] ;
52160: LD_ADDR_VAR 0 9
52164: PUSH
52165: LD_INT 25
52167: PUSH
52168: LD_INT 5
52170: PUSH
52171: LD_INT 3
52173: PUSH
52174: EMPTY
52175: LIST
52176: LIST
52177: LIST
52178: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
52179: LD_VAR 0 6
52183: PPUSH
52184: CALL_OW 264
52188: PUSH
52189: LD_INT 4
52191: PUSH
52192: LD_INT 43
52194: PUSH
52195: LD_INT 25
52197: PUSH
52198: EMPTY
52199: LIST
52200: LIST
52201: LIST
52202: IN
52203: IFFALSE 52224
// points := [ 40 , 15 , 5 ] ;
52205: LD_ADDR_VAR 0 9
52209: PUSH
52210: LD_INT 40
52212: PUSH
52213: LD_INT 15
52215: PUSH
52216: LD_INT 5
52218: PUSH
52219: EMPTY
52220: LIST
52221: LIST
52222: LIST
52223: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
52224: LD_VAR 0 6
52228: PPUSH
52229: CALL_OW 264
52233: PUSH
52234: LD_INT 3
52236: PUSH
52237: LD_INT 23
52239: PUSH
52240: EMPTY
52241: LIST
52242: LIST
52243: IN
52244: IFFALSE 52265
// points := [ 7 , 25 , 8 ] ;
52246: LD_ADDR_VAR 0 9
52250: PUSH
52251: LD_INT 7
52253: PUSH
52254: LD_INT 25
52256: PUSH
52257: LD_INT 8
52259: PUSH
52260: EMPTY
52261: LIST
52262: LIST
52263: LIST
52264: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
52265: LD_VAR 0 6
52269: PPUSH
52270: CALL_OW 264
52274: PUSH
52275: LD_INT 5
52277: PUSH
52278: LD_INT 27
52280: PUSH
52281: LD_INT 44
52283: PUSH
52284: EMPTY
52285: LIST
52286: LIST
52287: LIST
52288: IN
52289: IFFALSE 52310
// points := [ 14 , 50 , 16 ] ;
52291: LD_ADDR_VAR 0 9
52295: PUSH
52296: LD_INT 14
52298: PUSH
52299: LD_INT 50
52301: PUSH
52302: LD_INT 16
52304: PUSH
52305: EMPTY
52306: LIST
52307: LIST
52308: LIST
52309: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
52310: LD_VAR 0 6
52314: PPUSH
52315: CALL_OW 264
52319: PUSH
52320: LD_INT 6
52322: PUSH
52323: LD_INT 46
52325: PUSH
52326: EMPTY
52327: LIST
52328: LIST
52329: IN
52330: IFFALSE 52351
// points := [ 32 , 120 , 70 ] ;
52332: LD_ADDR_VAR 0 9
52336: PUSH
52337: LD_INT 32
52339: PUSH
52340: LD_INT 120
52342: PUSH
52343: LD_INT 70
52345: PUSH
52346: EMPTY
52347: LIST
52348: LIST
52349: LIST
52350: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
52351: LD_VAR 0 6
52355: PPUSH
52356: CALL_OW 264
52360: PUSH
52361: LD_INT 7
52363: PUSH
52364: LD_INT 28
52366: PUSH
52367: LD_INT 45
52369: PUSH
52370: EMPTY
52371: LIST
52372: LIST
52373: LIST
52374: IN
52375: IFFALSE 52396
// points := [ 35 , 20 , 45 ] ;
52377: LD_ADDR_VAR 0 9
52381: PUSH
52382: LD_INT 35
52384: PUSH
52385: LD_INT 20
52387: PUSH
52388: LD_INT 45
52390: PUSH
52391: EMPTY
52392: LIST
52393: LIST
52394: LIST
52395: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
52396: LD_VAR 0 6
52400: PPUSH
52401: CALL_OW 264
52405: PUSH
52406: LD_INT 47
52408: PUSH
52409: EMPTY
52410: LIST
52411: IN
52412: IFFALSE 52433
// points := [ 67 , 45 , 75 ] ;
52414: LD_ADDR_VAR 0 9
52418: PUSH
52419: LD_INT 67
52421: PUSH
52422: LD_INT 45
52424: PUSH
52425: LD_INT 75
52427: PUSH
52428: EMPTY
52429: LIST
52430: LIST
52431: LIST
52432: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
52433: LD_VAR 0 6
52437: PPUSH
52438: CALL_OW 264
52442: PUSH
52443: LD_INT 26
52445: PUSH
52446: EMPTY
52447: LIST
52448: IN
52449: IFFALSE 52470
// points := [ 120 , 30 , 80 ] ;
52451: LD_ADDR_VAR 0 9
52455: PUSH
52456: LD_INT 120
52458: PUSH
52459: LD_INT 30
52461: PUSH
52462: LD_INT 80
52464: PUSH
52465: EMPTY
52466: LIST
52467: LIST
52468: LIST
52469: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
52470: LD_VAR 0 6
52474: PPUSH
52475: CALL_OW 264
52479: PUSH
52480: LD_INT 22
52482: PUSH
52483: EMPTY
52484: LIST
52485: IN
52486: IFFALSE 52507
// points := [ 40 , 1 , 1 ] ;
52488: LD_ADDR_VAR 0 9
52492: PUSH
52493: LD_INT 40
52495: PUSH
52496: LD_INT 1
52498: PUSH
52499: LD_INT 1
52501: PUSH
52502: EMPTY
52503: LIST
52504: LIST
52505: LIST
52506: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
52507: LD_VAR 0 6
52511: PPUSH
52512: CALL_OW 264
52516: PUSH
52517: LD_INT 29
52519: PUSH
52520: EMPTY
52521: LIST
52522: IN
52523: IFFALSE 52544
// points := [ 70 , 200 , 400 ] ;
52525: LD_ADDR_VAR 0 9
52529: PUSH
52530: LD_INT 70
52532: PUSH
52533: LD_INT 200
52535: PUSH
52536: LD_INT 400
52538: PUSH
52539: EMPTY
52540: LIST
52541: LIST
52542: LIST
52543: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
52544: LD_VAR 0 6
52548: PPUSH
52549: CALL_OW 264
52553: PUSH
52554: LD_INT 14
52556: PUSH
52557: LD_INT 53
52559: PUSH
52560: EMPTY
52561: LIST
52562: LIST
52563: IN
52564: IFFALSE 52585
// points := [ 40 , 10 , 20 ] ;
52566: LD_ADDR_VAR 0 9
52570: PUSH
52571: LD_INT 40
52573: PUSH
52574: LD_INT 10
52576: PUSH
52577: LD_INT 20
52579: PUSH
52580: EMPTY
52581: LIST
52582: LIST
52583: LIST
52584: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
52585: LD_VAR 0 6
52589: PPUSH
52590: CALL_OW 264
52594: PUSH
52595: LD_INT 9
52597: PUSH
52598: EMPTY
52599: LIST
52600: IN
52601: IFFALSE 52622
// points := [ 5 , 70 , 20 ] ;
52603: LD_ADDR_VAR 0 9
52607: PUSH
52608: LD_INT 5
52610: PUSH
52611: LD_INT 70
52613: PUSH
52614: LD_INT 20
52616: PUSH
52617: EMPTY
52618: LIST
52619: LIST
52620: LIST
52621: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
52622: LD_VAR 0 6
52626: PPUSH
52627: CALL_OW 264
52631: PUSH
52632: LD_INT 10
52634: PUSH
52635: EMPTY
52636: LIST
52637: IN
52638: IFFALSE 52659
// points := [ 35 , 110 , 70 ] ;
52640: LD_ADDR_VAR 0 9
52644: PUSH
52645: LD_INT 35
52647: PUSH
52648: LD_INT 110
52650: PUSH
52651: LD_INT 70
52653: PUSH
52654: EMPTY
52655: LIST
52656: LIST
52657: LIST
52658: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
52659: LD_VAR 0 6
52663: PPUSH
52664: CALL_OW 265
52668: PUSH
52669: LD_INT 25
52671: EQUAL
52672: IFFALSE 52693
// points := [ 80 , 65 , 100 ] ;
52674: LD_ADDR_VAR 0 9
52678: PUSH
52679: LD_INT 80
52681: PUSH
52682: LD_INT 65
52684: PUSH
52685: LD_INT 100
52687: PUSH
52688: EMPTY
52689: LIST
52690: LIST
52691: LIST
52692: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
52693: LD_VAR 0 6
52697: PPUSH
52698: CALL_OW 263
52702: PUSH
52703: LD_INT 1
52705: EQUAL
52706: IFFALSE 52741
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
52708: LD_ADDR_VAR 0 10
52712: PUSH
52713: LD_VAR 0 10
52717: PUSH
52718: LD_VAR 0 6
52722: PPUSH
52723: CALL_OW 311
52727: PPUSH
52728: LD_INT 3
52730: PPUSH
52731: CALL_OW 259
52735: PUSH
52736: LD_INT 4
52738: MUL
52739: MUL
52740: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
52741: LD_VAR 0 6
52745: PPUSH
52746: CALL_OW 263
52750: PUSH
52751: LD_INT 2
52753: EQUAL
52754: IFFALSE 52805
// begin j := IsControledBy ( i ) ;
52756: LD_ADDR_VAR 0 7
52760: PUSH
52761: LD_VAR 0 6
52765: PPUSH
52766: CALL_OW 312
52770: ST_TO_ADDR
// if j then
52771: LD_VAR 0 7
52775: IFFALSE 52805
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
52777: LD_ADDR_VAR 0 10
52781: PUSH
52782: LD_VAR 0 10
52786: PUSH
52787: LD_VAR 0 7
52791: PPUSH
52792: LD_INT 3
52794: PPUSH
52795: CALL_OW 259
52799: PUSH
52800: LD_INT 3
52802: MUL
52803: MUL
52804: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
52805: LD_VAR 0 6
52809: PPUSH
52810: CALL_OW 264
52814: PUSH
52815: LD_INT 5
52817: PUSH
52818: LD_INT 6
52820: PUSH
52821: LD_INT 46
52823: PUSH
52824: LD_INT 44
52826: PUSH
52827: LD_INT 47
52829: PUSH
52830: LD_INT 45
52832: PUSH
52833: LD_INT 28
52835: PUSH
52836: LD_INT 7
52838: PUSH
52839: LD_INT 27
52841: PUSH
52842: LD_INT 29
52844: PUSH
52845: EMPTY
52846: LIST
52847: LIST
52848: LIST
52849: LIST
52850: LIST
52851: LIST
52852: LIST
52853: LIST
52854: LIST
52855: LIST
52856: IN
52857: PUSH
52858: LD_VAR 0 1
52862: PPUSH
52863: LD_INT 52
52865: PPUSH
52866: CALL_OW 321
52870: PUSH
52871: LD_INT 2
52873: EQUAL
52874: AND
52875: IFFALSE 52892
// bpoints := bpoints * 1.2 ;
52877: LD_ADDR_VAR 0 10
52881: PUSH
52882: LD_VAR 0 10
52886: PUSH
52887: LD_REAL  1.20000000000000E+0000
52890: MUL
52891: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
52892: LD_VAR 0 6
52896: PPUSH
52897: CALL_OW 264
52901: PUSH
52902: LD_INT 6
52904: PUSH
52905: LD_INT 46
52907: PUSH
52908: LD_INT 47
52910: PUSH
52911: EMPTY
52912: LIST
52913: LIST
52914: LIST
52915: IN
52916: IFFALSE 52933
// bpoints := bpoints * 1.2 ;
52918: LD_ADDR_VAR 0 10
52922: PUSH
52923: LD_VAR 0 10
52927: PUSH
52928: LD_REAL  1.20000000000000E+0000
52931: MUL
52932: ST_TO_ADDR
// end ; unit_building :
52933: GO 52947
52935: LD_INT 3
52937: DOUBLE
52938: EQUAL
52939: IFTRUE 52943
52941: GO 52946
52943: POP
// ; end ;
52944: GO 52947
52946: POP
// for j = 1 to 3 do
52947: LD_ADDR_VAR 0 7
52951: PUSH
52952: DOUBLE
52953: LD_INT 1
52955: DEC
52956: ST_TO_ADDR
52957: LD_INT 3
52959: PUSH
52960: FOR_TO
52961: IFFALSE 53014
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
52963: LD_ADDR_VAR 0 5
52967: PUSH
52968: LD_VAR 0 5
52972: PPUSH
52973: LD_VAR 0 7
52977: PPUSH
52978: LD_VAR 0 5
52982: PUSH
52983: LD_VAR 0 7
52987: ARRAY
52988: PUSH
52989: LD_VAR 0 9
52993: PUSH
52994: LD_VAR 0 7
52998: ARRAY
52999: PUSH
53000: LD_VAR 0 10
53004: MUL
53005: PLUS
53006: PPUSH
53007: CALL_OW 1
53011: ST_TO_ADDR
53012: GO 52960
53014: POP
53015: POP
// end ;
53016: GO 51499
53018: POP
53019: POP
// result := Replace ( result , 4 , tmp ) ;
53020: LD_ADDR_VAR 0 5
53024: PUSH
53025: LD_VAR 0 5
53029: PPUSH
53030: LD_INT 4
53032: PPUSH
53033: LD_VAR 0 8
53037: PPUSH
53038: CALL_OW 1
53042: ST_TO_ADDR
// end ;
53043: LD_VAR 0 5
53047: RET
// export function DangerAtRange ( unit , range ) ; begin
53048: LD_INT 0
53050: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
53051: LD_ADDR_VAR 0 3
53055: PUSH
53056: LD_VAR 0 1
53060: PPUSH
53061: CALL_OW 255
53065: PPUSH
53066: LD_VAR 0 1
53070: PPUSH
53071: CALL_OW 250
53075: PPUSH
53076: LD_VAR 0 1
53080: PPUSH
53081: CALL_OW 251
53085: PPUSH
53086: LD_VAR 0 2
53090: PPUSH
53091: CALL 51351 0 4
53095: ST_TO_ADDR
// end ;
53096: LD_VAR 0 3
53100: RET
// export function DangerInArea ( side , area ) ; begin
53101: LD_INT 0
53103: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
53104: LD_ADDR_VAR 0 3
53108: PUSH
53109: LD_VAR 0 2
53113: PPUSH
53114: LD_INT 81
53116: PUSH
53117: LD_VAR 0 1
53121: PUSH
53122: EMPTY
53123: LIST
53124: LIST
53125: PPUSH
53126: CALL_OW 70
53130: ST_TO_ADDR
// end ;
53131: LD_VAR 0 3
53135: RET
// export function IsExtension ( b ) ; begin
53136: LD_INT 0
53138: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
53139: LD_ADDR_VAR 0 2
53143: PUSH
53144: LD_VAR 0 1
53148: PUSH
53149: LD_INT 23
53151: PUSH
53152: LD_INT 20
53154: PUSH
53155: LD_INT 22
53157: PUSH
53158: LD_INT 17
53160: PUSH
53161: LD_INT 24
53163: PUSH
53164: LD_INT 21
53166: PUSH
53167: LD_INT 19
53169: PUSH
53170: LD_INT 16
53172: PUSH
53173: LD_INT 25
53175: PUSH
53176: LD_INT 18
53178: PUSH
53179: EMPTY
53180: LIST
53181: LIST
53182: LIST
53183: LIST
53184: LIST
53185: LIST
53186: LIST
53187: LIST
53188: LIST
53189: LIST
53190: IN
53191: ST_TO_ADDR
// end ;
53192: LD_VAR 0 2
53196: RET
// export function GetBaseBuildings ( base ) ; var tmp , i ; begin
53197: LD_INT 0
53199: PPUSH
53200: PPUSH
53201: PPUSH
// result := [ ] ;
53202: LD_ADDR_VAR 0 2
53206: PUSH
53207: EMPTY
53208: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
53209: LD_ADDR_VAR 0 3
53213: PUSH
53214: LD_INT 21
53216: PUSH
53217: LD_INT 3
53219: PUSH
53220: EMPTY
53221: LIST
53222: LIST
53223: PPUSH
53224: CALL_OW 69
53228: ST_TO_ADDR
// if not tmp then
53229: LD_VAR 0 3
53233: NOT
53234: IFFALSE 53238
// exit ;
53236: GO 53288
// for i in tmp do
53238: LD_ADDR_VAR 0 4
53242: PUSH
53243: LD_VAR 0 3
53247: PUSH
53248: FOR_IN
53249: IFFALSE 53286
// if GetBase ( i ) = base then
53251: LD_VAR 0 4
53255: PPUSH
53256: CALL_OW 274
53260: PUSH
53261: LD_VAR 0 1
53265: EQUAL
53266: IFFALSE 53284
// result := result ^ i ;
53268: LD_ADDR_VAR 0 2
53272: PUSH
53273: LD_VAR 0 2
53277: PUSH
53278: LD_VAR 0 4
53282: ADD
53283: ST_TO_ADDR
53284: GO 53248
53286: POP
53287: POP
// end ;
53288: LD_VAR 0 2
53292: RET
// export function ComComplete ( unit , b ) ; var i ; begin
53293: LD_INT 0
53295: PPUSH
53296: PPUSH
// if BuildingStatus ( b ) = bs_build then
53297: LD_VAR 0 2
53301: PPUSH
53302: CALL_OW 461
53306: PUSH
53307: LD_INT 1
53309: EQUAL
53310: IFFALSE 53370
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
53312: LD_VAR 0 1
53316: PPUSH
53317: LD_STRING h
53319: PUSH
53320: LD_VAR 0 2
53324: PPUSH
53325: CALL_OW 250
53329: PUSH
53330: LD_VAR 0 2
53334: PPUSH
53335: CALL_OW 251
53339: PUSH
53340: LD_VAR 0 2
53344: PUSH
53345: LD_INT 0
53347: PUSH
53348: LD_INT 0
53350: PUSH
53351: LD_INT 0
53353: PUSH
53354: EMPTY
53355: LIST
53356: LIST
53357: LIST
53358: LIST
53359: LIST
53360: LIST
53361: LIST
53362: PUSH
53363: EMPTY
53364: LIST
53365: PPUSH
53366: CALL_OW 446
// end ;
53370: LD_VAR 0 3
53374: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
53375: LD_INT 0
53377: PPUSH
53378: PPUSH
53379: PPUSH
53380: PPUSH
53381: PPUSH
53382: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
53383: LD_VAR 0 1
53387: NOT
53388: PUSH
53389: LD_VAR 0 1
53393: PPUSH
53394: CALL_OW 263
53398: PUSH
53399: LD_INT 2
53401: EQUAL
53402: NOT
53403: OR
53404: IFFALSE 53408
// exit ;
53406: GO 53724
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
53408: LD_ADDR_VAR 0 6
53412: PUSH
53413: LD_INT 22
53415: PUSH
53416: LD_VAR 0 1
53420: PPUSH
53421: CALL_OW 255
53425: PUSH
53426: EMPTY
53427: LIST
53428: LIST
53429: PUSH
53430: LD_INT 2
53432: PUSH
53433: LD_INT 30
53435: PUSH
53436: LD_INT 36
53438: PUSH
53439: EMPTY
53440: LIST
53441: LIST
53442: PUSH
53443: LD_INT 34
53445: PUSH
53446: LD_INT 31
53448: PUSH
53449: EMPTY
53450: LIST
53451: LIST
53452: PUSH
53453: EMPTY
53454: LIST
53455: LIST
53456: LIST
53457: PUSH
53458: EMPTY
53459: LIST
53460: LIST
53461: PPUSH
53462: CALL_OW 69
53466: ST_TO_ADDR
// if not tmp then
53467: LD_VAR 0 6
53471: NOT
53472: IFFALSE 53476
// exit ;
53474: GO 53724
// result := [ ] ;
53476: LD_ADDR_VAR 0 2
53480: PUSH
53481: EMPTY
53482: ST_TO_ADDR
// for i in tmp do
53483: LD_ADDR_VAR 0 3
53487: PUSH
53488: LD_VAR 0 6
53492: PUSH
53493: FOR_IN
53494: IFFALSE 53565
// begin t := UnitsInside ( i ) ;
53496: LD_ADDR_VAR 0 4
53500: PUSH
53501: LD_VAR 0 3
53505: PPUSH
53506: CALL_OW 313
53510: ST_TO_ADDR
// if t then
53511: LD_VAR 0 4
53515: IFFALSE 53563
// for j in t do
53517: LD_ADDR_VAR 0 7
53521: PUSH
53522: LD_VAR 0 4
53526: PUSH
53527: FOR_IN
53528: IFFALSE 53561
// result := Insert ( result , result + 1 , j ) ;
53530: LD_ADDR_VAR 0 2
53534: PUSH
53535: LD_VAR 0 2
53539: PPUSH
53540: LD_VAR 0 2
53544: PUSH
53545: LD_INT 1
53547: PLUS
53548: PPUSH
53549: LD_VAR 0 7
53553: PPUSH
53554: CALL_OW 2
53558: ST_TO_ADDR
53559: GO 53527
53561: POP
53562: POP
// end ;
53563: GO 53493
53565: POP
53566: POP
// if not result then
53567: LD_VAR 0 2
53571: NOT
53572: IFFALSE 53576
// exit ;
53574: GO 53724
// mech := result [ 1 ] ;
53576: LD_ADDR_VAR 0 5
53580: PUSH
53581: LD_VAR 0 2
53585: PUSH
53586: LD_INT 1
53588: ARRAY
53589: ST_TO_ADDR
// if result > 1 then
53590: LD_VAR 0 2
53594: PUSH
53595: LD_INT 1
53597: GREATER
53598: IFFALSE 53710
// for i = 2 to result do
53600: LD_ADDR_VAR 0 3
53604: PUSH
53605: DOUBLE
53606: LD_INT 2
53608: DEC
53609: ST_TO_ADDR
53610: LD_VAR 0 2
53614: PUSH
53615: FOR_TO
53616: IFFALSE 53708
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
53618: LD_ADDR_VAR 0 4
53622: PUSH
53623: LD_VAR 0 2
53627: PUSH
53628: LD_VAR 0 3
53632: ARRAY
53633: PPUSH
53634: LD_INT 3
53636: PPUSH
53637: CALL_OW 259
53641: PUSH
53642: LD_VAR 0 2
53646: PUSH
53647: LD_VAR 0 3
53651: ARRAY
53652: PPUSH
53653: CALL_OW 432
53657: MINUS
53658: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
53659: LD_VAR 0 4
53663: PUSH
53664: LD_VAR 0 5
53668: PPUSH
53669: LD_INT 3
53671: PPUSH
53672: CALL_OW 259
53676: PUSH
53677: LD_VAR 0 5
53681: PPUSH
53682: CALL_OW 432
53686: MINUS
53687: GREATEREQUAL
53688: IFFALSE 53706
// mech := result [ i ] ;
53690: LD_ADDR_VAR 0 5
53694: PUSH
53695: LD_VAR 0 2
53699: PUSH
53700: LD_VAR 0 3
53704: ARRAY
53705: ST_TO_ADDR
// end ;
53706: GO 53615
53708: POP
53709: POP
// ComLinkTo ( vehicle , mech ) ;
53710: LD_VAR 0 1
53714: PPUSH
53715: LD_VAR 0 5
53719: PPUSH
53720: CALL_OW 135
// end ;
53724: LD_VAR 0 2
53728: RET
// export function PrepareBase ( base_dep , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
53729: LD_INT 0
53731: PPUSH
53732: PPUSH
53733: PPUSH
53734: PPUSH
53735: PPUSH
53736: PPUSH
53737: PPUSH
53738: PPUSH
53739: PPUSH
53740: PPUSH
53741: PPUSH
53742: PPUSH
53743: PPUSH
// result := [ ] ;
53744: LD_ADDR_VAR 0 6
53748: PUSH
53749: EMPTY
53750: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
53751: LD_VAR 0 1
53755: PPUSH
53756: CALL_OW 266
53760: PUSH
53761: LD_INT 0
53763: PUSH
53764: LD_INT 1
53766: PUSH
53767: EMPTY
53768: LIST
53769: LIST
53770: IN
53771: NOT
53772: IFFALSE 53776
// exit ;
53774: GO 55295
// if name then
53776: LD_VAR 0 2
53780: IFFALSE 53796
// SetBName ( base_dep , name ) ;
53782: LD_VAR 0 1
53786: PPUSH
53787: LD_VAR 0 2
53791: PPUSH
53792: CALL_OW 500
// base := GetBase ( base_dep ) ;
53796: LD_ADDR_VAR 0 14
53800: PUSH
53801: LD_VAR 0 1
53805: PPUSH
53806: CALL_OW 274
53810: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
53811: LD_ADDR_VAR 0 15
53815: PUSH
53816: LD_VAR 0 1
53820: PPUSH
53821: CALL_OW 255
53825: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
53826: LD_ADDR_VAR 0 16
53830: PUSH
53831: LD_VAR 0 1
53835: PPUSH
53836: CALL_OW 248
53840: ST_TO_ADDR
// if sources then
53841: LD_VAR 0 4
53845: IFFALSE 53892
// for i = 1 to 3 do
53847: LD_ADDR_VAR 0 7
53851: PUSH
53852: DOUBLE
53853: LD_INT 1
53855: DEC
53856: ST_TO_ADDR
53857: LD_INT 3
53859: PUSH
53860: FOR_TO
53861: IFFALSE 53890
// AddResourceType ( base , i , sources [ i ] ) ;
53863: LD_VAR 0 14
53867: PPUSH
53868: LD_VAR 0 7
53872: PPUSH
53873: LD_VAR 0 4
53877: PUSH
53878: LD_VAR 0 7
53882: ARRAY
53883: PPUSH
53884: CALL_OW 276
53888: GO 53860
53890: POP
53891: POP
// buildings := GetBaseBuildings ( base ) ;
53892: LD_ADDR_VAR 0 17
53896: PUSH
53897: LD_VAR 0 14
53901: PPUSH
53902: CALL 53197 0 1
53906: ST_TO_ADDR
// InitHc ;
53907: CALL_OW 19
// InitUc ;
53911: CALL_OW 18
// uc_side := side ;
53915: LD_ADDR_OWVAR 20
53919: PUSH
53920: LD_VAR 0 15
53924: ST_TO_ADDR
// uc_nation := nation ;
53925: LD_ADDR_OWVAR 21
53929: PUSH
53930: LD_VAR 0 16
53934: ST_TO_ADDR
// if buildings then
53935: LD_VAR 0 17
53939: IFFALSE 55154
// begin if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
53941: LD_VAR 0 17
53945: PPUSH
53946: LD_INT 2
53948: PUSH
53949: LD_INT 30
53951: PUSH
53952: LD_INT 32
53954: PUSH
53955: EMPTY
53956: LIST
53957: LIST
53958: PUSH
53959: LD_INT 30
53961: PUSH
53962: LD_INT 33
53964: PUSH
53965: EMPTY
53966: LIST
53967: LIST
53968: PUSH
53969: EMPTY
53970: LIST
53971: LIST
53972: LIST
53973: PPUSH
53974: CALL_OW 72
53978: IFFALSE 54061
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
53980: LD_ADDR_VAR 0 7
53984: PUSH
53985: LD_VAR 0 17
53989: PPUSH
53990: LD_INT 2
53992: PUSH
53993: LD_INT 30
53995: PUSH
53996: LD_INT 32
53998: PUSH
53999: EMPTY
54000: LIST
54001: LIST
54002: PUSH
54003: LD_INT 30
54005: PUSH
54006: LD_INT 33
54008: PUSH
54009: EMPTY
54010: LIST
54011: LIST
54012: PUSH
54013: EMPTY
54014: LIST
54015: LIST
54016: LIST
54017: PPUSH
54018: CALL_OW 72
54022: PUSH
54023: FOR_IN
54024: IFFALSE 54059
// begin if not GetBWeapon ( i ) then
54026: LD_VAR 0 7
54030: PPUSH
54031: CALL_OW 269
54035: NOT
54036: IFFALSE 54057
// PlaceWeaponTurret ( i , GetTurretWeapon ( i ) ) ;
54038: LD_VAR 0 7
54042: PPUSH
54043: LD_VAR 0 7
54047: PPUSH
54048: CALL 55300 0 1
54052: PPUSH
54053: CALL_OW 431
// end ;
54057: GO 54023
54059: POP
54060: POP
// end ; for i = 1 to personel do
54061: LD_ADDR_VAR 0 7
54065: PUSH
54066: DOUBLE
54067: LD_INT 1
54069: DEC
54070: ST_TO_ADDR
54071: LD_VAR 0 5
54075: PUSH
54076: FOR_TO
54077: IFFALSE 55134
// begin if i > 4 then
54079: LD_VAR 0 7
54083: PUSH
54084: LD_INT 4
54086: GREATER
54087: IFFALSE 54091
// break ;
54089: GO 55134
// case i of 1 :
54091: LD_VAR 0 7
54095: PUSH
54096: LD_INT 1
54098: DOUBLE
54099: EQUAL
54100: IFTRUE 54104
54102: GO 54177
54104: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
54105: LD_ADDR_VAR 0 11
54109: PUSH
54110: LD_VAR 0 17
54114: PPUSH
54115: LD_INT 22
54117: PUSH
54118: LD_VAR 0 15
54122: PUSH
54123: EMPTY
54124: LIST
54125: LIST
54126: PUSH
54127: LD_INT 2
54129: PUSH
54130: LD_INT 30
54132: PUSH
54133: LD_INT 32
54135: PUSH
54136: EMPTY
54137: LIST
54138: LIST
54139: PUSH
54140: LD_INT 30
54142: PUSH
54143: LD_INT 4
54145: PUSH
54146: EMPTY
54147: LIST
54148: LIST
54149: PUSH
54150: LD_INT 30
54152: PUSH
54153: LD_INT 5
54155: PUSH
54156: EMPTY
54157: LIST
54158: LIST
54159: PUSH
54160: EMPTY
54161: LIST
54162: LIST
54163: LIST
54164: LIST
54165: PUSH
54166: EMPTY
54167: LIST
54168: LIST
54169: PPUSH
54170: CALL_OW 72
54174: ST_TO_ADDR
54175: GO 54399
54177: LD_INT 2
54179: DOUBLE
54180: EQUAL
54181: IFTRUE 54185
54183: GO 54247
54185: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
54186: LD_ADDR_VAR 0 11
54190: PUSH
54191: LD_VAR 0 17
54195: PPUSH
54196: LD_INT 22
54198: PUSH
54199: LD_VAR 0 15
54203: PUSH
54204: EMPTY
54205: LIST
54206: LIST
54207: PUSH
54208: LD_INT 2
54210: PUSH
54211: LD_INT 30
54213: PUSH
54214: LD_INT 0
54216: PUSH
54217: EMPTY
54218: LIST
54219: LIST
54220: PUSH
54221: LD_INT 30
54223: PUSH
54224: LD_INT 1
54226: PUSH
54227: EMPTY
54228: LIST
54229: LIST
54230: PUSH
54231: EMPTY
54232: LIST
54233: LIST
54234: LIST
54235: PUSH
54236: EMPTY
54237: LIST
54238: LIST
54239: PPUSH
54240: CALL_OW 72
54244: ST_TO_ADDR
54245: GO 54399
54247: LD_INT 3
54249: DOUBLE
54250: EQUAL
54251: IFTRUE 54255
54253: GO 54317
54255: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
54256: LD_ADDR_VAR 0 11
54260: PUSH
54261: LD_VAR 0 17
54265: PPUSH
54266: LD_INT 22
54268: PUSH
54269: LD_VAR 0 15
54273: PUSH
54274: EMPTY
54275: LIST
54276: LIST
54277: PUSH
54278: LD_INT 2
54280: PUSH
54281: LD_INT 30
54283: PUSH
54284: LD_INT 2
54286: PUSH
54287: EMPTY
54288: LIST
54289: LIST
54290: PUSH
54291: LD_INT 30
54293: PUSH
54294: LD_INT 3
54296: PUSH
54297: EMPTY
54298: LIST
54299: LIST
54300: PUSH
54301: EMPTY
54302: LIST
54303: LIST
54304: LIST
54305: PUSH
54306: EMPTY
54307: LIST
54308: LIST
54309: PPUSH
54310: CALL_OW 72
54314: ST_TO_ADDR
54315: GO 54399
54317: LD_INT 4
54319: DOUBLE
54320: EQUAL
54321: IFTRUE 54325
54323: GO 54398
54325: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
54326: LD_ADDR_VAR 0 11
54330: PUSH
54331: LD_VAR 0 17
54335: PPUSH
54336: LD_INT 22
54338: PUSH
54339: LD_VAR 0 15
54343: PUSH
54344: EMPTY
54345: LIST
54346: LIST
54347: PUSH
54348: LD_INT 2
54350: PUSH
54351: LD_INT 30
54353: PUSH
54354: LD_INT 6
54356: PUSH
54357: EMPTY
54358: LIST
54359: LIST
54360: PUSH
54361: LD_INT 30
54363: PUSH
54364: LD_INT 7
54366: PUSH
54367: EMPTY
54368: LIST
54369: LIST
54370: PUSH
54371: LD_INT 30
54373: PUSH
54374: LD_INT 8
54376: PUSH
54377: EMPTY
54378: LIST
54379: LIST
54380: PUSH
54381: EMPTY
54382: LIST
54383: LIST
54384: LIST
54385: LIST
54386: PUSH
54387: EMPTY
54388: LIST
54389: LIST
54390: PPUSH
54391: CALL_OW 72
54395: ST_TO_ADDR
54396: GO 54399
54398: POP
// if i = 1 then
54399: LD_VAR 0 7
54403: PUSH
54404: LD_INT 1
54406: EQUAL
54407: IFFALSE 54518
// begin tmp := [ ] ;
54409: LD_ADDR_VAR 0 18
54413: PUSH
54414: EMPTY
54415: ST_TO_ADDR
// for j in f do
54416: LD_ADDR_VAR 0 8
54420: PUSH
54421: LD_VAR 0 11
54425: PUSH
54426: FOR_IN
54427: IFFALSE 54500
// if GetBType ( j ) = b_bunker then
54429: LD_VAR 0 8
54433: PPUSH
54434: CALL_OW 266
54438: PUSH
54439: LD_INT 32
54441: EQUAL
54442: IFFALSE 54469
// tmp := Insert ( tmp , 1 , j ) else
54444: LD_ADDR_VAR 0 18
54448: PUSH
54449: LD_VAR 0 18
54453: PPUSH
54454: LD_INT 1
54456: PPUSH
54457: LD_VAR 0 8
54461: PPUSH
54462: CALL_OW 2
54466: ST_TO_ADDR
54467: GO 54498
// tmp := Insert ( tmp , tmp + 1 , j ) ;
54469: LD_ADDR_VAR 0 18
54473: PUSH
54474: LD_VAR 0 18
54478: PPUSH
54479: LD_VAR 0 18
54483: PUSH
54484: LD_INT 1
54486: PLUS
54487: PPUSH
54488: LD_VAR 0 8
54492: PPUSH
54493: CALL_OW 2
54497: ST_TO_ADDR
54498: GO 54426
54500: POP
54501: POP
// if tmp then
54502: LD_VAR 0 18
54506: IFFALSE 54518
// f := tmp ;
54508: LD_ADDR_VAR 0 11
54512: PUSH
54513: LD_VAR 0 18
54517: ST_TO_ADDR
// end ; x := personel [ i ] ;
54518: LD_ADDR_VAR 0 12
54522: PUSH
54523: LD_VAR 0 5
54527: PUSH
54528: LD_VAR 0 7
54532: ARRAY
54533: ST_TO_ADDR
// if x = - 1 then
54534: LD_VAR 0 12
54538: PUSH
54539: LD_INT 1
54541: NEG
54542: EQUAL
54543: IFFALSE 54752
// begin for j in f do
54545: LD_ADDR_VAR 0 8
54549: PUSH
54550: LD_VAR 0 11
54554: PUSH
54555: FOR_IN
54556: IFFALSE 54748
// repeat InitHc ;
54558: CALL_OW 19
// if GetBType ( j ) = b_barracks then
54562: LD_VAR 0 8
54566: PPUSH
54567: CALL_OW 266
54571: PUSH
54572: LD_INT 5
54574: EQUAL
54575: IFFALSE 54645
// begin if UnitsInside ( j ) < 3 then
54577: LD_VAR 0 8
54581: PPUSH
54582: CALL_OW 313
54586: PUSH
54587: LD_INT 3
54589: LESS
54590: IFFALSE 54626
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
54592: LD_INT 0
54594: PPUSH
54595: LD_INT 5
54597: PUSH
54598: LD_INT 8
54600: PUSH
54601: LD_INT 9
54603: PUSH
54604: EMPTY
54605: LIST
54606: LIST
54607: LIST
54608: PUSH
54609: LD_VAR 0 16
54613: ARRAY
54614: PPUSH
54615: LD_VAR 0 3
54619: PPUSH
54620: CALL_OW 380
54624: GO 54643
// PrepareHuman ( false , i , skill ) ;
54626: LD_INT 0
54628: PPUSH
54629: LD_VAR 0 7
54633: PPUSH
54634: LD_VAR 0 3
54638: PPUSH
54639: CALL_OW 380
// end else
54643: GO 54662
// PrepareHuman ( false , i , skill ) ;
54645: LD_INT 0
54647: PPUSH
54648: LD_VAR 0 7
54652: PPUSH
54653: LD_VAR 0 3
54657: PPUSH
54658: CALL_OW 380
// un := CreateHuman ;
54662: LD_ADDR_VAR 0 13
54666: PUSH
54667: CALL_OW 44
54671: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
54672: LD_ADDR_VAR 0 6
54676: PUSH
54677: LD_VAR 0 6
54681: PPUSH
54682: LD_INT 1
54684: PPUSH
54685: LD_VAR 0 13
54689: PPUSH
54690: CALL_OW 2
54694: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
54695: LD_VAR 0 13
54699: PPUSH
54700: LD_VAR 0 8
54704: PPUSH
54705: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
54709: LD_VAR 0 8
54713: PPUSH
54714: CALL_OW 313
54718: PUSH
54719: LD_INT 6
54721: EQUAL
54722: PUSH
54723: LD_VAR 0 8
54727: PPUSH
54728: CALL_OW 266
54732: PUSH
54733: LD_INT 32
54735: PUSH
54736: LD_INT 31
54738: PUSH
54739: EMPTY
54740: LIST
54741: LIST
54742: IN
54743: OR
54744: IFFALSE 54558
54746: GO 54555
54748: POP
54749: POP
// end else
54750: GO 55132
// for j = 1 to x do
54752: LD_ADDR_VAR 0 8
54756: PUSH
54757: DOUBLE
54758: LD_INT 1
54760: DEC
54761: ST_TO_ADDR
54762: LD_VAR 0 12
54766: PUSH
54767: FOR_TO
54768: IFFALSE 55130
// begin InitHc ;
54770: CALL_OW 19
// if not f then
54774: LD_VAR 0 11
54778: NOT
54779: IFFALSE 54868
// begin PrepareHuman ( false , i , skill ) ;
54781: LD_INT 0
54783: PPUSH
54784: LD_VAR 0 7
54788: PPUSH
54789: LD_VAR 0 3
54793: PPUSH
54794: CALL_OW 380
// un := CreateHuman ;
54798: LD_ADDR_VAR 0 13
54802: PUSH
54803: CALL_OW 44
54807: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
54808: LD_ADDR_VAR 0 6
54812: PUSH
54813: LD_VAR 0 6
54817: PPUSH
54818: LD_INT 1
54820: PPUSH
54821: LD_VAR 0 13
54825: PPUSH
54826: CALL_OW 2
54830: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
54831: LD_VAR 0 13
54835: PPUSH
54836: LD_VAR 0 1
54840: PPUSH
54841: CALL_OW 250
54845: PPUSH
54846: LD_VAR 0 1
54850: PPUSH
54851: CALL_OW 251
54855: PPUSH
54856: LD_INT 10
54858: PPUSH
54859: LD_INT 0
54861: PPUSH
54862: CALL_OW 50
// continue ;
54866: GO 54767
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
54868: LD_VAR 0 11
54872: PUSH
54873: LD_INT 1
54875: ARRAY
54876: PPUSH
54877: CALL_OW 313
54881: PUSH
54882: LD_VAR 0 11
54886: PUSH
54887: LD_INT 1
54889: ARRAY
54890: PPUSH
54891: CALL_OW 266
54895: PUSH
54896: LD_INT 32
54898: PUSH
54899: LD_INT 31
54901: PUSH
54902: EMPTY
54903: LIST
54904: LIST
54905: IN
54906: AND
54907: PUSH
54908: LD_VAR 0 11
54912: PUSH
54913: LD_INT 1
54915: ARRAY
54916: PPUSH
54917: CALL_OW 313
54921: PUSH
54922: LD_INT 6
54924: EQUAL
54925: OR
54926: IFFALSE 54946
// f := Delete ( f , 1 ) ;
54928: LD_ADDR_VAR 0 11
54932: PUSH
54933: LD_VAR 0 11
54937: PPUSH
54938: LD_INT 1
54940: PPUSH
54941: CALL_OW 3
54945: ST_TO_ADDR
// if not f then
54946: LD_VAR 0 11
54950: NOT
54951: IFFALSE 54969
// begin x := x + 2 ;
54953: LD_ADDR_VAR 0 12
54957: PUSH
54958: LD_VAR 0 12
54962: PUSH
54963: LD_INT 2
54965: PLUS
54966: ST_TO_ADDR
// continue ;
54967: GO 54767
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
54969: LD_VAR 0 11
54973: PUSH
54974: LD_INT 1
54976: ARRAY
54977: PPUSH
54978: CALL_OW 266
54982: PUSH
54983: LD_INT 5
54985: EQUAL
54986: IFFALSE 55060
// begin if UnitsInside ( f [ 1 ] ) < 3 then
54988: LD_VAR 0 11
54992: PUSH
54993: LD_INT 1
54995: ARRAY
54996: PPUSH
54997: CALL_OW 313
55001: PUSH
55002: LD_INT 3
55004: LESS
55005: IFFALSE 55041
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
55007: LD_INT 0
55009: PPUSH
55010: LD_INT 5
55012: PUSH
55013: LD_INT 8
55015: PUSH
55016: LD_INT 9
55018: PUSH
55019: EMPTY
55020: LIST
55021: LIST
55022: LIST
55023: PUSH
55024: LD_VAR 0 16
55028: ARRAY
55029: PPUSH
55030: LD_VAR 0 3
55034: PPUSH
55035: CALL_OW 380
55039: GO 55058
// PrepareHuman ( false , i , skill ) ;
55041: LD_INT 0
55043: PPUSH
55044: LD_VAR 0 7
55048: PPUSH
55049: LD_VAR 0 3
55053: PPUSH
55054: CALL_OW 380
// end else
55058: GO 55077
// PrepareHuman ( false , i , skill ) ;
55060: LD_INT 0
55062: PPUSH
55063: LD_VAR 0 7
55067: PPUSH
55068: LD_VAR 0 3
55072: PPUSH
55073: CALL_OW 380
// un := CreateHuman ;
55077: LD_ADDR_VAR 0 13
55081: PUSH
55082: CALL_OW 44
55086: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
55087: LD_ADDR_VAR 0 6
55091: PUSH
55092: LD_VAR 0 6
55096: PPUSH
55097: LD_INT 1
55099: PPUSH
55100: LD_VAR 0 13
55104: PPUSH
55105: CALL_OW 2
55109: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
55110: LD_VAR 0 13
55114: PPUSH
55115: LD_VAR 0 11
55119: PUSH
55120: LD_INT 1
55122: ARRAY
55123: PPUSH
55124: CALL_OW 52
// end ;
55128: GO 54767
55130: POP
55131: POP
// end ;
55132: GO 54076
55134: POP
55135: POP
// result := result ^ buildings ;
55136: LD_ADDR_VAR 0 6
55140: PUSH
55141: LD_VAR 0 6
55145: PUSH
55146: LD_VAR 0 17
55150: ADD
55151: ST_TO_ADDR
// end else
55152: GO 55295
// begin for i = 1 to personel do
55154: LD_ADDR_VAR 0 7
55158: PUSH
55159: DOUBLE
55160: LD_INT 1
55162: DEC
55163: ST_TO_ADDR
55164: LD_VAR 0 5
55168: PUSH
55169: FOR_TO
55170: IFFALSE 55293
// begin if i > 4 then
55172: LD_VAR 0 7
55176: PUSH
55177: LD_INT 4
55179: GREATER
55180: IFFALSE 55184
// break ;
55182: GO 55293
// x := personel [ i ] ;
55184: LD_ADDR_VAR 0 12
55188: PUSH
55189: LD_VAR 0 5
55193: PUSH
55194: LD_VAR 0 7
55198: ARRAY
55199: ST_TO_ADDR
// if x = - 1 then
55200: LD_VAR 0 12
55204: PUSH
55205: LD_INT 1
55207: NEG
55208: EQUAL
55209: IFFALSE 55213
// continue ;
55211: GO 55169
// PrepareHuman ( false , i , skill ) ;
55213: LD_INT 0
55215: PPUSH
55216: LD_VAR 0 7
55220: PPUSH
55221: LD_VAR 0 3
55225: PPUSH
55226: CALL_OW 380
// un := CreateHuman ;
55230: LD_ADDR_VAR 0 13
55234: PUSH
55235: CALL_OW 44
55239: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
55240: LD_VAR 0 13
55244: PPUSH
55245: LD_VAR 0 1
55249: PPUSH
55250: CALL_OW 250
55254: PPUSH
55255: LD_VAR 0 1
55259: PPUSH
55260: CALL_OW 251
55264: PPUSH
55265: LD_INT 10
55267: PPUSH
55268: LD_INT 0
55270: PPUSH
55271: CALL_OW 50
// result := result ^ un ;
55275: LD_ADDR_VAR 0 6
55279: PUSH
55280: LD_VAR 0 6
55284: PUSH
55285: LD_VAR 0 13
55289: ADD
55290: ST_TO_ADDR
// end ;
55291: GO 55169
55293: POP
55294: POP
// end ; end ;
55295: LD_VAR 0 6
55299: RET
// export function GetTurretWeapon ( tower ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
55300: LD_INT 0
55302: PPUSH
55303: PPUSH
55304: PPUSH
55305: PPUSH
55306: PPUSH
55307: PPUSH
55308: PPUSH
55309: PPUSH
55310: PPUSH
55311: PPUSH
55312: PPUSH
55313: PPUSH
55314: PPUSH
55315: PPUSH
55316: PPUSH
55317: PPUSH
// result := false ;
55318: LD_ADDR_VAR 0 2
55322: PUSH
55323: LD_INT 0
55325: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
55326: LD_VAR 0 1
55330: NOT
55331: PUSH
55332: LD_VAR 0 1
55336: PPUSH
55337: CALL_OW 266
55341: PUSH
55342: LD_INT 32
55344: PUSH
55345: LD_INT 33
55347: PUSH
55348: EMPTY
55349: LIST
55350: LIST
55351: IN
55352: NOT
55353: OR
55354: IFFALSE 55358
// exit ;
55356: GO 56489
// nat := GetNation ( tower ) ;
55358: LD_ADDR_VAR 0 11
55362: PUSH
55363: LD_VAR 0 1
55367: PPUSH
55368: CALL_OW 248
55372: ST_TO_ADDR
// side := GetSide ( tower ) ;
55373: LD_ADDR_VAR 0 15
55377: PUSH
55378: LD_VAR 0 1
55382: PPUSH
55383: CALL_OW 255
55387: ST_TO_ADDR
// x := GetX ( tower ) ;
55388: LD_ADDR_VAR 0 9
55392: PUSH
55393: LD_VAR 0 1
55397: PPUSH
55398: CALL_OW 250
55402: ST_TO_ADDR
// y := GetY ( tower ) ;
55403: LD_ADDR_VAR 0 10
55407: PUSH
55408: LD_VAR 0 1
55412: PPUSH
55413: CALL_OW 251
55417: ST_TO_ADDR
// if not x or not y then
55418: LD_VAR 0 9
55422: NOT
55423: PUSH
55424: LD_VAR 0 10
55428: NOT
55429: OR
55430: IFFALSE 55434
// exit ;
55432: GO 56489
// weapon := 0 ;
55434: LD_ADDR_VAR 0 17
55438: PUSH
55439: LD_INT 0
55441: ST_TO_ADDR
// fac_list := [ ] ;
55442: LD_ADDR_VAR 0 16
55446: PUSH
55447: EMPTY
55448: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) ) , [ f_btype , b_factory ] ) ;
55449: LD_ADDR_VAR 0 5
55453: PUSH
55454: LD_VAR 0 1
55458: PPUSH
55459: CALL_OW 274
55463: PPUSH
55464: CALL 53197 0 1
55468: PPUSH
55469: LD_INT 30
55471: PUSH
55472: LD_INT 3
55474: PUSH
55475: EMPTY
55476: LIST
55477: LIST
55478: PPUSH
55479: CALL_OW 72
55483: ST_TO_ADDR
// if not factories then
55484: LD_VAR 0 5
55488: NOT
55489: IFFALSE 55493
// exit ;
55491: GO 56489
// for i in factories do
55493: LD_ADDR_VAR 0 7
55497: PUSH
55498: LD_VAR 0 5
55502: PUSH
55503: FOR_IN
55504: IFFALSE 55529
// fac_list := fac_list union AvailableWeaponList ( i ) ;
55506: LD_ADDR_VAR 0 16
55510: PUSH
55511: LD_VAR 0 16
55515: PUSH
55516: LD_VAR 0 7
55520: PPUSH
55521: CALL_OW 478
55525: UNION
55526: ST_TO_ADDR
55527: GO 55503
55529: POP
55530: POP
// if not fac_list then
55531: LD_VAR 0 16
55535: NOT
55536: IFFALSE 55540
// exit ;
55538: GO 56489
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
55540: LD_ADDR_VAR 0 4
55544: PUSH
55545: LD_INT 4
55547: PUSH
55548: LD_INT 5
55550: PUSH
55551: LD_INT 9
55553: PUSH
55554: LD_INT 10
55556: PUSH
55557: LD_INT 6
55559: PUSH
55560: LD_INT 7
55562: PUSH
55563: LD_INT 11
55565: PUSH
55566: EMPTY
55567: LIST
55568: LIST
55569: LIST
55570: LIST
55571: LIST
55572: LIST
55573: LIST
55574: PUSH
55575: LD_INT 27
55577: PUSH
55578: LD_INT 28
55580: PUSH
55581: LD_INT 26
55583: PUSH
55584: LD_INT 30
55586: PUSH
55587: EMPTY
55588: LIST
55589: LIST
55590: LIST
55591: LIST
55592: PUSH
55593: LD_INT 43
55595: PUSH
55596: LD_INT 44
55598: PUSH
55599: LD_INT 46
55601: PUSH
55602: LD_INT 45
55604: PUSH
55605: LD_INT 47
55607: PUSH
55608: LD_INT 49
55610: PUSH
55611: EMPTY
55612: LIST
55613: LIST
55614: LIST
55615: LIST
55616: LIST
55617: LIST
55618: PUSH
55619: EMPTY
55620: LIST
55621: LIST
55622: LIST
55623: PUSH
55624: LD_VAR 0 11
55628: ARRAY
55629: ST_TO_ADDR
// for i in list do
55630: LD_ADDR_VAR 0 7
55634: PUSH
55635: LD_VAR 0 4
55639: PUSH
55640: FOR_IN
55641: IFFALSE 55674
// if not i in fac_list then
55643: LD_VAR 0 7
55647: PUSH
55648: LD_VAR 0 16
55652: IN
55653: NOT
55654: IFFALSE 55672
// list := list diff i ;
55656: LD_ADDR_VAR 0 4
55660: PUSH
55661: LD_VAR 0 4
55665: PUSH
55666: LD_VAR 0 7
55670: DIFF
55671: ST_TO_ADDR
55672: GO 55640
55674: POP
55675: POP
// if not list then
55676: LD_VAR 0 4
55680: NOT
55681: IFFALSE 55685
// exit ;
55683: GO 56489
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
55685: LD_VAR 0 11
55689: PUSH
55690: LD_INT 3
55692: EQUAL
55693: PUSH
55694: LD_INT 49
55696: PUSH
55697: LD_VAR 0 4
55701: IN
55702: AND
55703: PUSH
55704: LD_INT 31
55706: PPUSH
55707: LD_VAR 0 15
55711: PPUSH
55712: CALL_OW 321
55716: PUSH
55717: LD_INT 2
55719: EQUAL
55720: AND
55721: IFFALSE 55781
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
55723: LD_INT 22
55725: PUSH
55726: LD_VAR 0 15
55730: PUSH
55731: EMPTY
55732: LIST
55733: LIST
55734: PUSH
55735: LD_INT 35
55737: PUSH
55738: LD_INT 49
55740: PUSH
55741: EMPTY
55742: LIST
55743: LIST
55744: PUSH
55745: LD_INT 91
55747: PUSH
55748: LD_VAR 0 1
55752: PUSH
55753: LD_INT 10
55755: PUSH
55756: EMPTY
55757: LIST
55758: LIST
55759: LIST
55760: PUSH
55761: EMPTY
55762: LIST
55763: LIST
55764: LIST
55765: PPUSH
55766: CALL_OW 69
55770: NOT
55771: IFFALSE 55781
// weapon := ru_time_lapser ;
55773: LD_ADDR_VAR 0 17
55777: PUSH
55778: LD_INT 49
55780: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
55781: LD_VAR 0 11
55785: PUSH
55786: LD_INT 1
55788: PUSH
55789: LD_INT 2
55791: PUSH
55792: EMPTY
55793: LIST
55794: LIST
55795: IN
55796: PUSH
55797: LD_INT 11
55799: PUSH
55800: LD_VAR 0 4
55804: IN
55805: PUSH
55806: LD_INT 30
55808: PUSH
55809: LD_VAR 0 4
55813: IN
55814: OR
55815: AND
55816: PUSH
55817: LD_INT 6
55819: PPUSH
55820: LD_VAR 0 15
55824: PPUSH
55825: CALL_OW 321
55829: PUSH
55830: LD_INT 2
55832: EQUAL
55833: AND
55834: IFFALSE 55999
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
55836: LD_INT 22
55838: PUSH
55839: LD_VAR 0 15
55843: PUSH
55844: EMPTY
55845: LIST
55846: LIST
55847: PUSH
55848: LD_INT 2
55850: PUSH
55851: LD_INT 35
55853: PUSH
55854: LD_INT 11
55856: PUSH
55857: EMPTY
55858: LIST
55859: LIST
55860: PUSH
55861: LD_INT 35
55863: PUSH
55864: LD_INT 30
55866: PUSH
55867: EMPTY
55868: LIST
55869: LIST
55870: PUSH
55871: EMPTY
55872: LIST
55873: LIST
55874: LIST
55875: PUSH
55876: LD_INT 91
55878: PUSH
55879: LD_VAR 0 1
55883: PUSH
55884: LD_INT 18
55886: PUSH
55887: EMPTY
55888: LIST
55889: LIST
55890: LIST
55891: PUSH
55892: EMPTY
55893: LIST
55894: LIST
55895: LIST
55896: PPUSH
55897: CALL_OW 69
55901: NOT
55902: PUSH
55903: LD_INT 22
55905: PUSH
55906: LD_VAR 0 15
55910: PUSH
55911: EMPTY
55912: LIST
55913: LIST
55914: PUSH
55915: LD_INT 2
55917: PUSH
55918: LD_INT 30
55920: PUSH
55921: LD_INT 32
55923: PUSH
55924: EMPTY
55925: LIST
55926: LIST
55927: PUSH
55928: LD_INT 30
55930: PUSH
55931: LD_INT 33
55933: PUSH
55934: EMPTY
55935: LIST
55936: LIST
55937: PUSH
55938: EMPTY
55939: LIST
55940: LIST
55941: LIST
55942: PUSH
55943: LD_INT 91
55945: PUSH
55946: LD_VAR 0 1
55950: PUSH
55951: LD_INT 12
55953: PUSH
55954: EMPTY
55955: LIST
55956: LIST
55957: LIST
55958: PUSH
55959: EMPTY
55960: LIST
55961: LIST
55962: LIST
55963: PUSH
55964: EMPTY
55965: LIST
55966: PPUSH
55967: CALL_OW 69
55971: PUSH
55972: LD_INT 2
55974: GREATER
55975: AND
55976: IFFALSE 55999
// weapon := [ us_radar , ar_radar ] [ nat ] ;
55978: LD_ADDR_VAR 0 17
55982: PUSH
55983: LD_INT 11
55985: PUSH
55986: LD_INT 30
55988: PUSH
55989: EMPTY
55990: LIST
55991: LIST
55992: PUSH
55993: LD_VAR 0 11
55997: ARRAY
55998: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
55999: LD_VAR 0 17
56003: NOT
56004: PUSH
56005: LD_INT 40
56007: PPUSH
56008: LD_VAR 0 15
56012: PPUSH
56013: CALL_OW 321
56017: PUSH
56018: LD_INT 2
56020: EQUAL
56021: AND
56022: PUSH
56023: LD_INT 7
56025: PUSH
56026: LD_VAR 0 4
56030: IN
56031: PUSH
56032: LD_INT 28
56034: PUSH
56035: LD_VAR 0 4
56039: IN
56040: OR
56041: PUSH
56042: LD_INT 45
56044: PUSH
56045: LD_VAR 0 4
56049: IN
56050: OR
56051: AND
56052: IFFALSE 56306
// begin hex := GetHexInfo ( x , y ) ;
56054: LD_ADDR_VAR 0 3
56058: PUSH
56059: LD_VAR 0 9
56063: PPUSH
56064: LD_VAR 0 10
56068: PPUSH
56069: CALL_OW 546
56073: ST_TO_ADDR
// if hex [ 1 ] then
56074: LD_VAR 0 3
56078: PUSH
56079: LD_INT 1
56081: ARRAY
56082: IFFALSE 56086
// exit ;
56084: GO 56489
// height := hex [ 2 ] ;
56086: LD_ADDR_VAR 0 14
56090: PUSH
56091: LD_VAR 0 3
56095: PUSH
56096: LD_INT 2
56098: ARRAY
56099: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
56100: LD_ADDR_VAR 0 13
56104: PUSH
56105: LD_INT 0
56107: PUSH
56108: LD_INT 2
56110: PUSH
56111: LD_INT 3
56113: PUSH
56114: LD_INT 5
56116: PUSH
56117: EMPTY
56118: LIST
56119: LIST
56120: LIST
56121: LIST
56122: ST_TO_ADDR
// for i in tmp do
56123: LD_ADDR_VAR 0 7
56127: PUSH
56128: LD_VAR 0 13
56132: PUSH
56133: FOR_IN
56134: IFFALSE 56304
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
56136: LD_ADDR_VAR 0 8
56140: PUSH
56141: LD_VAR 0 9
56145: PPUSH
56146: LD_VAR 0 7
56150: PPUSH
56151: LD_INT 5
56153: PPUSH
56154: CALL_OW 272
56158: PUSH
56159: LD_VAR 0 10
56163: PPUSH
56164: LD_VAR 0 7
56168: PPUSH
56169: LD_INT 5
56171: PPUSH
56172: CALL_OW 273
56176: PUSH
56177: EMPTY
56178: LIST
56179: LIST
56180: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
56181: LD_VAR 0 8
56185: PUSH
56186: LD_INT 1
56188: ARRAY
56189: PPUSH
56190: LD_VAR 0 8
56194: PUSH
56195: LD_INT 2
56197: ARRAY
56198: PPUSH
56199: CALL_OW 488
56203: IFFALSE 56302
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
56205: LD_ADDR_VAR 0 3
56209: PUSH
56210: LD_VAR 0 8
56214: PUSH
56215: LD_INT 1
56217: ARRAY
56218: PPUSH
56219: LD_VAR 0 8
56223: PUSH
56224: LD_INT 2
56226: ARRAY
56227: PPUSH
56228: CALL_OW 546
56232: ST_TO_ADDR
// if hex [ 1 ] then
56233: LD_VAR 0 3
56237: PUSH
56238: LD_INT 1
56240: ARRAY
56241: IFFALSE 56245
// continue ;
56243: GO 56133
// h := hex [ 2 ] ;
56245: LD_ADDR_VAR 0 12
56249: PUSH
56250: LD_VAR 0 3
56254: PUSH
56255: LD_INT 2
56257: ARRAY
56258: ST_TO_ADDR
// if h + 7 < height then
56259: LD_VAR 0 12
56263: PUSH
56264: LD_INT 7
56266: PLUS
56267: PUSH
56268: LD_VAR 0 14
56272: LESS
56273: IFFALSE 56302
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
56275: LD_ADDR_VAR 0 17
56279: PUSH
56280: LD_INT 7
56282: PUSH
56283: LD_INT 28
56285: PUSH
56286: LD_INT 45
56288: PUSH
56289: EMPTY
56290: LIST
56291: LIST
56292: LIST
56293: PUSH
56294: LD_VAR 0 11
56298: ARRAY
56299: ST_TO_ADDR
// break ;
56300: GO 56304
// end ; end ; end ;
56302: GO 56133
56304: POP
56305: POP
// end ; if not weapon then
56306: LD_VAR 0 17
56310: NOT
56311: IFFALSE 56371
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
56313: LD_ADDR_VAR 0 4
56317: PUSH
56318: LD_VAR 0 4
56322: PUSH
56323: LD_INT 11
56325: PUSH
56326: LD_INT 30
56328: PUSH
56329: LD_INT 49
56331: PUSH
56332: EMPTY
56333: LIST
56334: LIST
56335: LIST
56336: DIFF
56337: ST_TO_ADDR
// if not list then
56338: LD_VAR 0 4
56342: NOT
56343: IFFALSE 56347
// exit ;
56345: GO 56489
// weapon := list [ rand ( 1 , list ) ] ;
56347: LD_ADDR_VAR 0 17
56351: PUSH
56352: LD_VAR 0 4
56356: PUSH
56357: LD_INT 1
56359: PPUSH
56360: LD_VAR 0 4
56364: PPUSH
56365: CALL_OW 12
56369: ARRAY
56370: ST_TO_ADDR
// end ; if weapon then
56371: LD_VAR 0 17
56375: IFFALSE 56489
// begin tmp := CostOfWeapon ( weapon ) ;
56377: LD_ADDR_VAR 0 13
56381: PUSH
56382: LD_VAR 0 17
56386: PPUSH
56387: CALL_OW 451
56391: ST_TO_ADDR
// j := GetBase ( tower ) ;
56392: LD_ADDR_VAR 0 8
56396: PUSH
56397: LD_VAR 0 1
56401: PPUSH
56402: CALL_OW 274
56406: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
56407: LD_VAR 0 8
56411: PPUSH
56412: LD_INT 1
56414: PPUSH
56415: CALL_OW 275
56419: PUSH
56420: LD_VAR 0 13
56424: PUSH
56425: LD_INT 1
56427: ARRAY
56428: GREATEREQUAL
56429: PUSH
56430: LD_VAR 0 8
56434: PPUSH
56435: LD_INT 2
56437: PPUSH
56438: CALL_OW 275
56442: PUSH
56443: LD_VAR 0 13
56447: PUSH
56448: LD_INT 2
56450: ARRAY
56451: GREATEREQUAL
56452: AND
56453: PUSH
56454: LD_VAR 0 8
56458: PPUSH
56459: LD_INT 3
56461: PPUSH
56462: CALL_OW 275
56466: PUSH
56467: LD_VAR 0 13
56471: PUSH
56472: LD_INT 3
56474: ARRAY
56475: GREATEREQUAL
56476: AND
56477: IFFALSE 56489
// result := weapon ;
56479: LD_ADDR_VAR 0 2
56483: PUSH
56484: LD_VAR 0 17
56488: ST_TO_ADDR
// end ; end ;
56489: LD_VAR 0 2
56493: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
56494: LD_INT 0
56496: PPUSH
56497: PPUSH
// result := true ;
56498: LD_ADDR_VAR 0 3
56502: PUSH
56503: LD_INT 1
56505: ST_TO_ADDR
// if array1 = array2 then
56506: LD_VAR 0 1
56510: PUSH
56511: LD_VAR 0 2
56515: EQUAL
56516: IFFALSE 56576
// begin for i = 1 to array1 do
56518: LD_ADDR_VAR 0 4
56522: PUSH
56523: DOUBLE
56524: LD_INT 1
56526: DEC
56527: ST_TO_ADDR
56528: LD_VAR 0 1
56532: PUSH
56533: FOR_TO
56534: IFFALSE 56572
// if array1 [ i ] <> array2 [ i ] then
56536: LD_VAR 0 1
56540: PUSH
56541: LD_VAR 0 4
56545: ARRAY
56546: PUSH
56547: LD_VAR 0 2
56551: PUSH
56552: LD_VAR 0 4
56556: ARRAY
56557: NONEQUAL
56558: IFFALSE 56570
// begin result := false ;
56560: LD_ADDR_VAR 0 3
56564: PUSH
56565: LD_INT 0
56567: ST_TO_ADDR
// break ;
56568: GO 56572
// end ;
56570: GO 56533
56572: POP
56573: POP
// end else
56574: GO 56584
// result := false ;
56576: LD_ADDR_VAR 0 3
56580: PUSH
56581: LD_INT 0
56583: ST_TO_ADDR
// end ;
56584: LD_VAR 0 3
56588: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
56589: LD_INT 0
56591: PPUSH
56592: PPUSH
56593: PPUSH
// pom := GetBase ( fac ) ;
56594: LD_ADDR_VAR 0 5
56598: PUSH
56599: LD_VAR 0 1
56603: PPUSH
56604: CALL_OW 274
56608: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
56609: LD_ADDR_VAR 0 4
56613: PUSH
56614: LD_VAR 0 2
56618: PUSH
56619: LD_INT 1
56621: ARRAY
56622: PPUSH
56623: LD_VAR 0 2
56627: PUSH
56628: LD_INT 2
56630: ARRAY
56631: PPUSH
56632: LD_VAR 0 2
56636: PUSH
56637: LD_INT 3
56639: ARRAY
56640: PPUSH
56641: LD_VAR 0 2
56645: PUSH
56646: LD_INT 4
56648: ARRAY
56649: PPUSH
56650: CALL_OW 449
56654: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
56655: LD_ADDR_VAR 0 3
56659: PUSH
56660: LD_VAR 0 5
56664: PPUSH
56665: LD_INT 1
56667: PPUSH
56668: CALL_OW 275
56672: PUSH
56673: LD_VAR 0 4
56677: PUSH
56678: LD_INT 1
56680: ARRAY
56681: GREATEREQUAL
56682: PUSH
56683: LD_VAR 0 5
56687: PPUSH
56688: LD_INT 2
56690: PPUSH
56691: CALL_OW 275
56695: PUSH
56696: LD_VAR 0 4
56700: PUSH
56701: LD_INT 2
56703: ARRAY
56704: GREATEREQUAL
56705: AND
56706: PUSH
56707: LD_VAR 0 5
56711: PPUSH
56712: LD_INT 3
56714: PPUSH
56715: CALL_OW 275
56719: PUSH
56720: LD_VAR 0 4
56724: PUSH
56725: LD_INT 3
56727: ARRAY
56728: GREATEREQUAL
56729: AND
56730: ST_TO_ADDR
// end ;
56731: LD_VAR 0 3
56735: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
56736: LD_INT 0
56738: PPUSH
56739: PPUSH
56740: PPUSH
56741: PPUSH
// pom := GetBase ( building ) ;
56742: LD_ADDR_VAR 0 3
56746: PUSH
56747: LD_VAR 0 1
56751: PPUSH
56752: CALL_OW 274
56756: ST_TO_ADDR
// if not pom then
56757: LD_VAR 0 3
56761: NOT
56762: IFFALSE 56766
// exit ;
56764: GO 56936
// btype := GetBType ( building ) ;
56766: LD_ADDR_VAR 0 5
56770: PUSH
56771: LD_VAR 0 1
56775: PPUSH
56776: CALL_OW 266
56780: ST_TO_ADDR
// if btype = b_armoury then
56781: LD_VAR 0 5
56785: PUSH
56786: LD_INT 4
56788: EQUAL
56789: IFFALSE 56799
// btype := b_barracks ;
56791: LD_ADDR_VAR 0 5
56795: PUSH
56796: LD_INT 5
56798: ST_TO_ADDR
// if btype = b_depot then
56799: LD_VAR 0 5
56803: PUSH
56804: LD_INT 0
56806: EQUAL
56807: IFFALSE 56817
// btype := b_warehouse ;
56809: LD_ADDR_VAR 0 5
56813: PUSH
56814: LD_INT 1
56816: ST_TO_ADDR
// if btype = b_workshop then
56817: LD_VAR 0 5
56821: PUSH
56822: LD_INT 2
56824: EQUAL
56825: IFFALSE 56835
// btype := b_factory ;
56827: LD_ADDR_VAR 0 5
56831: PUSH
56832: LD_INT 3
56834: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
56835: LD_ADDR_VAR 0 4
56839: PUSH
56840: LD_VAR 0 5
56844: PPUSH
56845: LD_VAR 0 1
56849: PPUSH
56850: CALL_OW 248
56854: PPUSH
56855: CALL_OW 450
56859: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
56860: LD_ADDR_VAR 0 2
56864: PUSH
56865: LD_VAR 0 3
56869: PPUSH
56870: LD_INT 1
56872: PPUSH
56873: CALL_OW 275
56877: PUSH
56878: LD_VAR 0 4
56882: PUSH
56883: LD_INT 1
56885: ARRAY
56886: GREATEREQUAL
56887: PUSH
56888: LD_VAR 0 3
56892: PPUSH
56893: LD_INT 2
56895: PPUSH
56896: CALL_OW 275
56900: PUSH
56901: LD_VAR 0 4
56905: PUSH
56906: LD_INT 2
56908: ARRAY
56909: GREATEREQUAL
56910: AND
56911: PUSH
56912: LD_VAR 0 3
56916: PPUSH
56917: LD_INT 3
56919: PPUSH
56920: CALL_OW 275
56924: PUSH
56925: LD_VAR 0 4
56929: PUSH
56930: LD_INT 3
56932: ARRAY
56933: GREATEREQUAL
56934: AND
56935: ST_TO_ADDR
// end ;
56936: LD_VAR 0 2
56940: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
56941: LD_INT 0
56943: PPUSH
56944: PPUSH
56945: PPUSH
// pom := GetBase ( building ) ;
56946: LD_ADDR_VAR 0 4
56950: PUSH
56951: LD_VAR 0 1
56955: PPUSH
56956: CALL_OW 274
56960: ST_TO_ADDR
// if not pom then
56961: LD_VAR 0 4
56965: NOT
56966: IFFALSE 56970
// exit ;
56968: GO 57071
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
56970: LD_ADDR_VAR 0 5
56974: PUSH
56975: LD_VAR 0 2
56979: PPUSH
56980: LD_VAR 0 1
56984: PPUSH
56985: CALL_OW 248
56989: PPUSH
56990: CALL_OW 450
56994: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
56995: LD_ADDR_VAR 0 3
56999: PUSH
57000: LD_VAR 0 4
57004: PPUSH
57005: LD_INT 1
57007: PPUSH
57008: CALL_OW 275
57012: PUSH
57013: LD_VAR 0 5
57017: PUSH
57018: LD_INT 1
57020: ARRAY
57021: GREATEREQUAL
57022: PUSH
57023: LD_VAR 0 4
57027: PPUSH
57028: LD_INT 2
57030: PPUSH
57031: CALL_OW 275
57035: PUSH
57036: LD_VAR 0 5
57040: PUSH
57041: LD_INT 2
57043: ARRAY
57044: GREATEREQUAL
57045: AND
57046: PUSH
57047: LD_VAR 0 4
57051: PPUSH
57052: LD_INT 3
57054: PPUSH
57055: CALL_OW 275
57059: PUSH
57060: LD_VAR 0 5
57064: PUSH
57065: LD_INT 3
57067: ARRAY
57068: GREATEREQUAL
57069: AND
57070: ST_TO_ADDR
// end ;
57071: LD_VAR 0 3
57075: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
57076: LD_INT 0
57078: PPUSH
57079: PPUSH
57080: PPUSH
57081: PPUSH
57082: PPUSH
57083: PPUSH
57084: PPUSH
57085: PPUSH
57086: PPUSH
57087: PPUSH
// result := false ;
57088: LD_ADDR_VAR 0 6
57092: PUSH
57093: LD_INT 0
57095: ST_TO_ADDR
// if not base or not btype or not x or not y then
57096: LD_VAR 0 1
57100: NOT
57101: PUSH
57102: LD_VAR 0 2
57106: NOT
57107: OR
57108: PUSH
57109: LD_VAR 0 3
57113: NOT
57114: OR
57115: PUSH
57116: LD_VAR 0 4
57120: NOT
57121: OR
57122: IFFALSE 57126
// exit ;
57124: GO 57640
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
57126: LD_ADDR_VAR 0 12
57130: PUSH
57131: LD_VAR 0 2
57135: PPUSH
57136: LD_VAR 0 3
57140: PPUSH
57141: LD_VAR 0 4
57145: PPUSH
57146: LD_VAR 0 5
57150: PPUSH
57151: LD_VAR 0 1
57155: PUSH
57156: LD_INT 1
57158: ARRAY
57159: PPUSH
57160: CALL_OW 248
57164: PPUSH
57165: LD_INT 0
57167: PPUSH
57168: CALL 58469 0 6
57172: ST_TO_ADDR
// if not hexes then
57173: LD_VAR 0 12
57177: NOT
57178: IFFALSE 57182
// exit ;
57180: GO 57640
// for i = 1 to hexes do
57182: LD_ADDR_VAR 0 7
57186: PUSH
57187: DOUBLE
57188: LD_INT 1
57190: DEC
57191: ST_TO_ADDR
57192: LD_VAR 0 12
57196: PUSH
57197: FOR_TO
57198: IFFALSE 57638
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
57200: LD_ADDR_VAR 0 11
57204: PUSH
57205: LD_VAR 0 12
57209: PUSH
57210: LD_VAR 0 7
57214: ARRAY
57215: PUSH
57216: LD_INT 1
57218: ARRAY
57219: PPUSH
57220: LD_VAR 0 12
57224: PUSH
57225: LD_VAR 0 7
57229: ARRAY
57230: PUSH
57231: LD_INT 2
57233: ARRAY
57234: PPUSH
57235: CALL_OW 428
57239: ST_TO_ADDR
// if not tmp or GetType ( tmp ) = unit_building then
57240: LD_VAR 0 11
57244: NOT
57245: PUSH
57246: LD_VAR 0 11
57250: PPUSH
57251: CALL_OW 247
57255: PUSH
57256: LD_INT 3
57258: EQUAL
57259: OR
57260: IFFALSE 57264
// continue ;
57262: GO 57197
// result := true ;
57264: LD_ADDR_VAR 0 6
57268: PUSH
57269: LD_INT 1
57271: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
57272: LD_ADDR_VAR 0 15
57276: PUSH
57277: LD_INT 22
57279: PUSH
57280: LD_VAR 0 11
57284: PPUSH
57285: CALL_OW 255
57289: PUSH
57290: EMPTY
57291: LIST
57292: LIST
57293: PUSH
57294: LD_INT 2
57296: PUSH
57297: LD_INT 30
57299: PUSH
57300: LD_INT 0
57302: PUSH
57303: EMPTY
57304: LIST
57305: LIST
57306: PUSH
57307: LD_INT 30
57309: PUSH
57310: LD_INT 1
57312: PUSH
57313: EMPTY
57314: LIST
57315: LIST
57316: PUSH
57317: EMPTY
57318: LIST
57319: LIST
57320: LIST
57321: PUSH
57322: EMPTY
57323: LIST
57324: LIST
57325: PPUSH
57326: CALL_OW 69
57330: ST_TO_ADDR
// if dep then
57331: LD_VAR 0 15
57335: IFFALSE 57471
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
57337: LD_ADDR_VAR 0 14
57341: PUSH
57342: LD_VAR 0 15
57346: PUSH
57347: LD_INT 1
57349: ARRAY
57350: PPUSH
57351: CALL_OW 250
57355: PPUSH
57356: LD_VAR 0 15
57360: PUSH
57361: LD_INT 1
57363: ARRAY
57364: PPUSH
57365: CALL_OW 254
57369: PPUSH
57370: LD_INT 5
57372: PPUSH
57373: CALL_OW 272
57377: PUSH
57378: LD_VAR 0 15
57382: PUSH
57383: LD_INT 1
57385: ARRAY
57386: PPUSH
57387: CALL_OW 251
57391: PPUSH
57392: LD_VAR 0 15
57396: PUSH
57397: LD_INT 1
57399: ARRAY
57400: PPUSH
57401: CALL_OW 254
57405: PPUSH
57406: LD_INT 5
57408: PPUSH
57409: CALL_OW 273
57413: PUSH
57414: EMPTY
57415: LIST
57416: LIST
57417: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
57418: LD_VAR 0 14
57422: PUSH
57423: LD_INT 1
57425: ARRAY
57426: PPUSH
57427: LD_VAR 0 14
57431: PUSH
57432: LD_INT 2
57434: ARRAY
57435: PPUSH
57436: CALL_OW 488
57440: IFFALSE 57471
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
57442: LD_VAR 0 11
57446: PPUSH
57447: LD_VAR 0 14
57451: PUSH
57452: LD_INT 1
57454: ARRAY
57455: PPUSH
57456: LD_VAR 0 14
57460: PUSH
57461: LD_INT 2
57463: ARRAY
57464: PPUSH
57465: CALL_OW 111
// continue ;
57469: GO 57197
// end ; end ; r := GetDir ( tmp ) ;
57471: LD_ADDR_VAR 0 13
57475: PUSH
57476: LD_VAR 0 11
57480: PPUSH
57481: CALL_OW 254
57485: ST_TO_ADDR
// if r = 5 then
57486: LD_VAR 0 13
57490: PUSH
57491: LD_INT 5
57493: EQUAL
57494: IFFALSE 57504
// r := 0 ;
57496: LD_ADDR_VAR 0 13
57500: PUSH
57501: LD_INT 0
57503: ST_TO_ADDR
// for j = r to 5 do
57504: LD_ADDR_VAR 0 8
57508: PUSH
57509: DOUBLE
57510: LD_VAR 0 13
57514: DEC
57515: ST_TO_ADDR
57516: LD_INT 5
57518: PUSH
57519: FOR_TO
57520: IFFALSE 57634
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
57522: LD_ADDR_VAR 0 9
57526: PUSH
57527: LD_VAR 0 11
57531: PPUSH
57532: CALL_OW 250
57536: PPUSH
57537: LD_VAR 0 8
57541: PPUSH
57542: LD_INT 2
57544: PPUSH
57545: CALL_OW 272
57549: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
57550: LD_ADDR_VAR 0 10
57554: PUSH
57555: LD_VAR 0 11
57559: PPUSH
57560: CALL_OW 251
57564: PPUSH
57565: LD_VAR 0 8
57569: PPUSH
57570: LD_INT 2
57572: PPUSH
57573: CALL_OW 273
57577: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
57578: LD_VAR 0 9
57582: PPUSH
57583: LD_VAR 0 10
57587: PPUSH
57588: CALL_OW 488
57592: PUSH
57593: LD_VAR 0 9
57597: PPUSH
57598: LD_VAR 0 10
57602: PPUSH
57603: CALL_OW 428
57607: NOT
57608: AND
57609: IFFALSE 57632
// begin ComMoveXY ( tmp , _x , _y ) ;
57611: LD_VAR 0 11
57615: PPUSH
57616: LD_VAR 0 9
57620: PPUSH
57621: LD_VAR 0 10
57625: PPUSH
57626: CALL_OW 111
// break ;
57630: GO 57634
// end ; end ;
57632: GO 57519
57634: POP
57635: POP
// end ;
57636: GO 57197
57638: POP
57639: POP
// end ;
57640: LD_VAR 0 6
57644: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , pom , cost , hexes , height , dist , hex ; begin
57645: LD_INT 0
57647: PPUSH
57648: PPUSH
57649: PPUSH
57650: PPUSH
57651: PPUSH
57652: PPUSH
57653: PPUSH
57654: PPUSH
57655: PPUSH
// result := false ;
57656: LD_ADDR_VAR 0 6
57660: PUSH
57661: LD_INT 0
57663: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
57664: LD_VAR 0 1
57668: NOT
57669: PUSH
57670: LD_VAR 0 1
57674: PPUSH
57675: CALL_OW 266
57679: PUSH
57680: LD_INT 0
57682: PUSH
57683: LD_INT 1
57685: PUSH
57686: EMPTY
57687: LIST
57688: LIST
57689: IN
57690: NOT
57691: OR
57692: PUSH
57693: LD_VAR 0 2
57697: NOT
57698: OR
57699: PUSH
57700: LD_VAR 0 5
57704: PUSH
57705: LD_INT 0
57707: PUSH
57708: LD_INT 1
57710: PUSH
57711: LD_INT 2
57713: PUSH
57714: LD_INT 3
57716: PUSH
57717: LD_INT 4
57719: PUSH
57720: LD_INT 5
57722: PUSH
57723: EMPTY
57724: LIST
57725: LIST
57726: LIST
57727: LIST
57728: LIST
57729: LIST
57730: IN
57731: NOT
57732: OR
57733: PUSH
57734: LD_VAR 0 3
57738: PPUSH
57739: LD_VAR 0 4
57743: PPUSH
57744: CALL_OW 488
57748: NOT
57749: OR
57750: IFFALSE 57754
// exit ;
57752: GO 58464
// pom := GetBase ( bdepot ) ;
57754: LD_ADDR_VAR 0 9
57758: PUSH
57759: LD_VAR 0 1
57763: PPUSH
57764: CALL_OW 274
57768: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
57769: LD_ADDR_VAR 0 10
57773: PUSH
57774: LD_VAR 0 2
57778: PPUSH
57779: LD_VAR 0 1
57783: PPUSH
57784: CALL_OW 248
57788: PPUSH
57789: CALL_OW 450
57793: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
57794: LD_VAR 0 9
57798: PPUSH
57799: LD_INT 1
57801: PPUSH
57802: CALL_OW 275
57806: PUSH
57807: LD_VAR 0 10
57811: PUSH
57812: LD_INT 1
57814: ARRAY
57815: GREATEREQUAL
57816: PUSH
57817: LD_VAR 0 9
57821: PPUSH
57822: LD_INT 2
57824: PPUSH
57825: CALL_OW 275
57829: PUSH
57830: LD_VAR 0 10
57834: PUSH
57835: LD_INT 2
57837: ARRAY
57838: GREATEREQUAL
57839: AND
57840: PUSH
57841: LD_VAR 0 9
57845: PPUSH
57846: LD_INT 3
57848: PPUSH
57849: CALL_OW 275
57853: PUSH
57854: LD_VAR 0 10
57858: PUSH
57859: LD_INT 3
57861: ARRAY
57862: GREATEREQUAL
57863: AND
57864: NOT
57865: IFFALSE 57869
// exit ;
57867: GO 58464
// if GetBType ( bdepot ) = b_depot then
57869: LD_VAR 0 1
57873: PPUSH
57874: CALL_OW 266
57878: PUSH
57879: LD_INT 0
57881: EQUAL
57882: IFFALSE 57894
// dist := 28 else
57884: LD_ADDR_VAR 0 13
57888: PUSH
57889: LD_INT 28
57891: ST_TO_ADDR
57892: GO 57902
// dist := 36 ;
57894: LD_ADDR_VAR 0 13
57898: PUSH
57899: LD_INT 36
57901: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
57902: LD_VAR 0 1
57906: PPUSH
57907: LD_VAR 0 3
57911: PPUSH
57912: LD_VAR 0 4
57916: PPUSH
57917: CALL_OW 297
57921: PUSH
57922: LD_VAR 0 13
57926: GREATER
57927: IFFALSE 57931
// exit ;
57929: GO 58464
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
57931: LD_ADDR_VAR 0 11
57935: PUSH
57936: LD_VAR 0 2
57940: PPUSH
57941: LD_VAR 0 3
57945: PPUSH
57946: LD_VAR 0 4
57950: PPUSH
57951: LD_VAR 0 5
57955: PPUSH
57956: LD_VAR 0 1
57960: PPUSH
57961: CALL_OW 248
57965: PPUSH
57966: LD_INT 0
57968: PPUSH
57969: CALL 58469 0 6
57973: ST_TO_ADDR
// if not hexes then
57974: LD_VAR 0 11
57978: NOT
57979: IFFALSE 57983
// exit ;
57981: GO 58464
// hex := GetHexInfo ( x , y ) ;
57983: LD_ADDR_VAR 0 14
57987: PUSH
57988: LD_VAR 0 3
57992: PPUSH
57993: LD_VAR 0 4
57997: PPUSH
57998: CALL_OW 546
58002: ST_TO_ADDR
// if hex [ 1 ] then
58003: LD_VAR 0 14
58007: PUSH
58008: LD_INT 1
58010: ARRAY
58011: IFFALSE 58015
// exit ;
58013: GO 58464
// height := hex [ 2 ] ;
58015: LD_ADDR_VAR 0 12
58019: PUSH
58020: LD_VAR 0 14
58024: PUSH
58025: LD_INT 2
58027: ARRAY
58028: ST_TO_ADDR
// for i = 1 to hexes do
58029: LD_ADDR_VAR 0 7
58033: PUSH
58034: DOUBLE
58035: LD_INT 1
58037: DEC
58038: ST_TO_ADDR
58039: LD_VAR 0 11
58043: PUSH
58044: FOR_TO
58045: IFFALSE 58373
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
58047: LD_VAR 0 11
58051: PUSH
58052: LD_VAR 0 7
58056: ARRAY
58057: PUSH
58058: LD_INT 1
58060: ARRAY
58061: PPUSH
58062: LD_VAR 0 11
58066: PUSH
58067: LD_VAR 0 7
58071: ARRAY
58072: PUSH
58073: LD_INT 2
58075: ARRAY
58076: PPUSH
58077: CALL_OW 488
58081: NOT
58082: IFFALSE 58086
// continue ;
58084: GO 58044
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
58086: LD_ADDR_VAR 0 8
58090: PUSH
58091: LD_VAR 0 11
58095: PUSH
58096: LD_VAR 0 7
58100: ARRAY
58101: PUSH
58102: LD_INT 1
58104: ARRAY
58105: PPUSH
58106: LD_VAR 0 11
58110: PUSH
58111: LD_VAR 0 7
58115: ARRAY
58116: PUSH
58117: LD_INT 2
58119: ARRAY
58120: PPUSH
58121: CALL_OW 546
58125: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
58126: LD_VAR 0 8
58130: PUSH
58131: LD_INT 1
58133: ARRAY
58134: PUSH
58135: LD_VAR 0 8
58139: PUSH
58140: LD_INT 2
58142: ARRAY
58143: PUSH
58144: LD_VAR 0 12
58148: PUSH
58149: LD_INT 2
58151: PLUS
58152: GREATER
58153: OR
58154: PUSH
58155: LD_VAR 0 8
58159: PUSH
58160: LD_INT 2
58162: ARRAY
58163: PUSH
58164: LD_VAR 0 12
58168: PUSH
58169: LD_INT 2
58171: MINUS
58172: LESS
58173: OR
58174: PUSH
58175: LD_VAR 0 8
58179: PUSH
58180: LD_INT 3
58182: ARRAY
58183: PUSH
58184: LD_INT 0
58186: PUSH
58187: LD_INT 8
58189: PUSH
58190: LD_INT 9
58192: PUSH
58193: LD_INT 10
58195: PUSH
58196: LD_INT 11
58198: PUSH
58199: LD_INT 12
58201: PUSH
58202: LD_INT 13
58204: PUSH
58205: LD_INT 16
58207: PUSH
58208: LD_INT 17
58210: PUSH
58211: LD_INT 18
58213: PUSH
58214: LD_INT 19
58216: PUSH
58217: LD_INT 20
58219: PUSH
58220: LD_INT 21
58222: PUSH
58223: EMPTY
58224: LIST
58225: LIST
58226: LIST
58227: LIST
58228: LIST
58229: LIST
58230: LIST
58231: LIST
58232: LIST
58233: LIST
58234: LIST
58235: LIST
58236: LIST
58237: IN
58238: NOT
58239: OR
58240: PUSH
58241: LD_VAR 0 8
58245: PUSH
58246: LD_INT 5
58248: ARRAY
58249: NOT
58250: OR
58251: PUSH
58252: LD_VAR 0 8
58256: PUSH
58257: LD_INT 6
58259: ARRAY
58260: PUSH
58261: LD_INT 1
58263: PUSH
58264: LD_INT 2
58266: PUSH
58267: LD_INT 7
58269: PUSH
58270: LD_INT 9
58272: PUSH
58273: LD_INT 10
58275: PUSH
58276: LD_INT 11
58278: PUSH
58279: EMPTY
58280: LIST
58281: LIST
58282: LIST
58283: LIST
58284: LIST
58285: LIST
58286: IN
58287: NOT
58288: OR
58289: PUSH
58290: LD_VAR 0 11
58294: PUSH
58295: LD_VAR 0 7
58299: ARRAY
58300: PUSH
58301: LD_INT 1
58303: ARRAY
58304: PPUSH
58305: LD_VAR 0 11
58309: PUSH
58310: LD_VAR 0 7
58314: ARRAY
58315: PUSH
58316: LD_INT 2
58318: ARRAY
58319: PPUSH
58320: CALL_OW 428
58324: PUSH
58325: LD_INT 0
58327: GREATER
58328: OR
58329: PUSH
58330: LD_VAR 0 11
58334: PUSH
58335: LD_VAR 0 7
58339: ARRAY
58340: PUSH
58341: LD_INT 1
58343: ARRAY
58344: PPUSH
58345: LD_VAR 0 11
58349: PUSH
58350: LD_VAR 0 7
58354: ARRAY
58355: PUSH
58356: LD_INT 2
58358: ARRAY
58359: PPUSH
58360: CALL_OW 351
58364: OR
58365: IFFALSE 58371
// exit ;
58367: POP
58368: POP
58369: GO 58464
// end ;
58371: GO 58044
58373: POP
58374: POP
// if DangerAtRangeXY ( GetSide ( bdepot ) , x , y , 20 ) [ 4 ] then
58375: LD_VAR 0 1
58379: PPUSH
58380: CALL_OW 255
58384: PPUSH
58385: LD_VAR 0 3
58389: PPUSH
58390: LD_VAR 0 4
58394: PPUSH
58395: LD_INT 20
58397: PPUSH
58398: CALL 51351 0 4
58402: PUSH
58403: LD_INT 4
58405: ARRAY
58406: IFFALSE 58410
// exit ;
58408: GO 58464
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , GetSide ( bdepot ) ) then
58410: LD_VAR 0 2
58414: PUSH
58415: LD_INT 29
58417: PUSH
58418: LD_INT 30
58420: PUSH
58421: EMPTY
58422: LIST
58423: LIST
58424: IN
58425: PUSH
58426: LD_VAR 0 3
58430: PPUSH
58431: LD_VAR 0 4
58435: PPUSH
58436: LD_VAR 0 1
58440: PPUSH
58441: CALL_OW 255
58445: PPUSH
58446: CALL_OW 440
58450: NOT
58451: AND
58452: IFFALSE 58456
// exit ;
58454: GO 58464
// result := true ;
58456: LD_ADDR_VAR 0 6
58460: PUSH
58461: LD_INT 1
58463: ST_TO_ADDR
// end ;
58464: LD_VAR 0 6
58468: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
58469: LD_INT 0
58471: PPUSH
58472: PPUSH
58473: PPUSH
58474: PPUSH
58475: PPUSH
58476: PPUSH
58477: PPUSH
58478: PPUSH
58479: PPUSH
58480: PPUSH
58481: PPUSH
58482: PPUSH
58483: PPUSH
58484: PPUSH
58485: PPUSH
58486: PPUSH
58487: PPUSH
58488: PPUSH
58489: PPUSH
58490: PPUSH
58491: PPUSH
58492: PPUSH
58493: PPUSH
58494: PPUSH
58495: PPUSH
58496: PPUSH
58497: PPUSH
58498: PPUSH
58499: PPUSH
58500: PPUSH
58501: PPUSH
58502: PPUSH
58503: PPUSH
58504: PPUSH
58505: PPUSH
58506: PPUSH
58507: PPUSH
58508: PPUSH
58509: PPUSH
58510: PPUSH
58511: PPUSH
58512: PPUSH
58513: PPUSH
58514: PPUSH
58515: PPUSH
58516: PPUSH
58517: PPUSH
58518: PPUSH
58519: PPUSH
58520: PPUSH
58521: PPUSH
58522: PPUSH
58523: PPUSH
58524: PPUSH
58525: PPUSH
58526: PPUSH
58527: PPUSH
58528: PPUSH
// result = [ ] ;
58529: LD_ADDR_VAR 0 7
58533: PUSH
58534: EMPTY
58535: ST_TO_ADDR
// temp_list = [ ] ;
58536: LD_ADDR_VAR 0 9
58540: PUSH
58541: EMPTY
58542: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
58543: LD_VAR 0 4
58547: PUSH
58548: LD_INT 0
58550: PUSH
58551: LD_INT 1
58553: PUSH
58554: LD_INT 2
58556: PUSH
58557: LD_INT 3
58559: PUSH
58560: LD_INT 4
58562: PUSH
58563: LD_INT 5
58565: PUSH
58566: EMPTY
58567: LIST
58568: LIST
58569: LIST
58570: LIST
58571: LIST
58572: LIST
58573: IN
58574: NOT
58575: PUSH
58576: LD_VAR 0 1
58580: PUSH
58581: LD_INT 0
58583: PUSH
58584: LD_INT 1
58586: PUSH
58587: EMPTY
58588: LIST
58589: LIST
58590: IN
58591: PUSH
58592: LD_VAR 0 5
58596: PUSH
58597: LD_INT 1
58599: PUSH
58600: LD_INT 2
58602: PUSH
58603: LD_INT 3
58605: PUSH
58606: EMPTY
58607: LIST
58608: LIST
58609: LIST
58610: IN
58611: NOT
58612: AND
58613: OR
58614: IFFALSE 58618
// exit ;
58616: GO 77003
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
58618: LD_VAR 0 1
58622: PUSH
58623: LD_INT 6
58625: PUSH
58626: LD_INT 7
58628: PUSH
58629: LD_INT 8
58631: PUSH
58632: LD_INT 13
58634: PUSH
58635: LD_INT 12
58637: PUSH
58638: LD_INT 15
58640: PUSH
58641: LD_INT 11
58643: PUSH
58644: LD_INT 14
58646: PUSH
58647: LD_INT 10
58649: PUSH
58650: EMPTY
58651: LIST
58652: LIST
58653: LIST
58654: LIST
58655: LIST
58656: LIST
58657: LIST
58658: LIST
58659: LIST
58660: IN
58661: IFFALSE 58671
// btype = b_lab ;
58663: LD_ADDR_VAR 0 1
58667: PUSH
58668: LD_INT 6
58670: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
58671: LD_VAR 0 6
58675: PUSH
58676: LD_INT 0
58678: PUSH
58679: LD_INT 1
58681: PUSH
58682: LD_INT 2
58684: PUSH
58685: EMPTY
58686: LIST
58687: LIST
58688: LIST
58689: IN
58690: NOT
58691: PUSH
58692: LD_VAR 0 1
58696: PUSH
58697: LD_INT 0
58699: PUSH
58700: LD_INT 1
58702: PUSH
58703: LD_INT 2
58705: PUSH
58706: LD_INT 3
58708: PUSH
58709: LD_INT 6
58711: PUSH
58712: LD_INT 36
58714: PUSH
58715: LD_INT 4
58717: PUSH
58718: LD_INT 5
58720: PUSH
58721: LD_INT 31
58723: PUSH
58724: LD_INT 32
58726: PUSH
58727: LD_INT 33
58729: PUSH
58730: EMPTY
58731: LIST
58732: LIST
58733: LIST
58734: LIST
58735: LIST
58736: LIST
58737: LIST
58738: LIST
58739: LIST
58740: LIST
58741: LIST
58742: IN
58743: NOT
58744: PUSH
58745: LD_VAR 0 6
58749: PUSH
58750: LD_INT 1
58752: EQUAL
58753: AND
58754: OR
58755: PUSH
58756: LD_VAR 0 1
58760: PUSH
58761: LD_INT 2
58763: PUSH
58764: LD_INT 3
58766: PUSH
58767: EMPTY
58768: LIST
58769: LIST
58770: IN
58771: NOT
58772: PUSH
58773: LD_VAR 0 6
58777: PUSH
58778: LD_INT 2
58780: EQUAL
58781: AND
58782: OR
58783: IFFALSE 58793
// mode = 0 ;
58785: LD_ADDR_VAR 0 6
58789: PUSH
58790: LD_INT 0
58792: ST_TO_ADDR
// case mode of 0 :
58793: LD_VAR 0 6
58797: PUSH
58798: LD_INT 0
58800: DOUBLE
58801: EQUAL
58802: IFTRUE 58806
58804: GO 70259
58806: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
58807: LD_ADDR_VAR 0 11
58811: PUSH
58812: LD_INT 0
58814: PUSH
58815: LD_INT 0
58817: PUSH
58818: EMPTY
58819: LIST
58820: LIST
58821: PUSH
58822: LD_INT 0
58824: PUSH
58825: LD_INT 1
58827: NEG
58828: PUSH
58829: EMPTY
58830: LIST
58831: LIST
58832: PUSH
58833: LD_INT 1
58835: PUSH
58836: LD_INT 0
58838: PUSH
58839: EMPTY
58840: LIST
58841: LIST
58842: PUSH
58843: LD_INT 1
58845: PUSH
58846: LD_INT 1
58848: PUSH
58849: EMPTY
58850: LIST
58851: LIST
58852: PUSH
58853: LD_INT 0
58855: PUSH
58856: LD_INT 1
58858: PUSH
58859: EMPTY
58860: LIST
58861: LIST
58862: PUSH
58863: LD_INT 1
58865: NEG
58866: PUSH
58867: LD_INT 0
58869: PUSH
58870: EMPTY
58871: LIST
58872: LIST
58873: PUSH
58874: LD_INT 1
58876: NEG
58877: PUSH
58878: LD_INT 1
58880: NEG
58881: PUSH
58882: EMPTY
58883: LIST
58884: LIST
58885: PUSH
58886: LD_INT 1
58888: NEG
58889: PUSH
58890: LD_INT 2
58892: NEG
58893: PUSH
58894: EMPTY
58895: LIST
58896: LIST
58897: PUSH
58898: LD_INT 0
58900: PUSH
58901: LD_INT 2
58903: NEG
58904: PUSH
58905: EMPTY
58906: LIST
58907: LIST
58908: PUSH
58909: LD_INT 1
58911: PUSH
58912: LD_INT 1
58914: NEG
58915: PUSH
58916: EMPTY
58917: LIST
58918: LIST
58919: PUSH
58920: LD_INT 1
58922: PUSH
58923: LD_INT 2
58925: PUSH
58926: EMPTY
58927: LIST
58928: LIST
58929: PUSH
58930: LD_INT 0
58932: PUSH
58933: LD_INT 2
58935: PUSH
58936: EMPTY
58937: LIST
58938: LIST
58939: PUSH
58940: LD_INT 1
58942: NEG
58943: PUSH
58944: LD_INT 1
58946: PUSH
58947: EMPTY
58948: LIST
58949: LIST
58950: PUSH
58951: LD_INT 1
58953: PUSH
58954: LD_INT 3
58956: PUSH
58957: EMPTY
58958: LIST
58959: LIST
58960: PUSH
58961: LD_INT 0
58963: PUSH
58964: LD_INT 3
58966: PUSH
58967: EMPTY
58968: LIST
58969: LIST
58970: PUSH
58971: LD_INT 1
58973: NEG
58974: PUSH
58975: LD_INT 2
58977: PUSH
58978: EMPTY
58979: LIST
58980: LIST
58981: PUSH
58982: EMPTY
58983: LIST
58984: LIST
58985: LIST
58986: LIST
58987: LIST
58988: LIST
58989: LIST
58990: LIST
58991: LIST
58992: LIST
58993: LIST
58994: LIST
58995: LIST
58996: LIST
58997: LIST
58998: LIST
58999: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
59000: LD_ADDR_VAR 0 12
59004: PUSH
59005: LD_INT 0
59007: PUSH
59008: LD_INT 0
59010: PUSH
59011: EMPTY
59012: LIST
59013: LIST
59014: PUSH
59015: LD_INT 0
59017: PUSH
59018: LD_INT 1
59020: NEG
59021: PUSH
59022: EMPTY
59023: LIST
59024: LIST
59025: PUSH
59026: LD_INT 1
59028: PUSH
59029: LD_INT 0
59031: PUSH
59032: EMPTY
59033: LIST
59034: LIST
59035: PUSH
59036: LD_INT 1
59038: PUSH
59039: LD_INT 1
59041: PUSH
59042: EMPTY
59043: LIST
59044: LIST
59045: PUSH
59046: LD_INT 0
59048: PUSH
59049: LD_INT 1
59051: PUSH
59052: EMPTY
59053: LIST
59054: LIST
59055: PUSH
59056: LD_INT 1
59058: NEG
59059: PUSH
59060: LD_INT 0
59062: PUSH
59063: EMPTY
59064: LIST
59065: LIST
59066: PUSH
59067: LD_INT 1
59069: NEG
59070: PUSH
59071: LD_INT 1
59073: NEG
59074: PUSH
59075: EMPTY
59076: LIST
59077: LIST
59078: PUSH
59079: LD_INT 1
59081: PUSH
59082: LD_INT 1
59084: NEG
59085: PUSH
59086: EMPTY
59087: LIST
59088: LIST
59089: PUSH
59090: LD_INT 2
59092: PUSH
59093: LD_INT 0
59095: PUSH
59096: EMPTY
59097: LIST
59098: LIST
59099: PUSH
59100: LD_INT 2
59102: PUSH
59103: LD_INT 1
59105: PUSH
59106: EMPTY
59107: LIST
59108: LIST
59109: PUSH
59110: LD_INT 1
59112: NEG
59113: PUSH
59114: LD_INT 1
59116: PUSH
59117: EMPTY
59118: LIST
59119: LIST
59120: PUSH
59121: LD_INT 2
59123: NEG
59124: PUSH
59125: LD_INT 0
59127: PUSH
59128: EMPTY
59129: LIST
59130: LIST
59131: PUSH
59132: LD_INT 2
59134: NEG
59135: PUSH
59136: LD_INT 1
59138: NEG
59139: PUSH
59140: EMPTY
59141: LIST
59142: LIST
59143: PUSH
59144: LD_INT 2
59146: NEG
59147: PUSH
59148: LD_INT 1
59150: PUSH
59151: EMPTY
59152: LIST
59153: LIST
59154: PUSH
59155: LD_INT 3
59157: NEG
59158: PUSH
59159: LD_INT 0
59161: PUSH
59162: EMPTY
59163: LIST
59164: LIST
59165: PUSH
59166: LD_INT 3
59168: NEG
59169: PUSH
59170: LD_INT 1
59172: NEG
59173: PUSH
59174: EMPTY
59175: LIST
59176: LIST
59177: PUSH
59178: EMPTY
59179: LIST
59180: LIST
59181: LIST
59182: LIST
59183: LIST
59184: LIST
59185: LIST
59186: LIST
59187: LIST
59188: LIST
59189: LIST
59190: LIST
59191: LIST
59192: LIST
59193: LIST
59194: LIST
59195: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
59196: LD_ADDR_VAR 0 13
59200: PUSH
59201: LD_INT 0
59203: PUSH
59204: LD_INT 0
59206: PUSH
59207: EMPTY
59208: LIST
59209: LIST
59210: PUSH
59211: LD_INT 0
59213: PUSH
59214: LD_INT 1
59216: NEG
59217: PUSH
59218: EMPTY
59219: LIST
59220: LIST
59221: PUSH
59222: LD_INT 1
59224: PUSH
59225: LD_INT 0
59227: PUSH
59228: EMPTY
59229: LIST
59230: LIST
59231: PUSH
59232: LD_INT 1
59234: PUSH
59235: LD_INT 1
59237: PUSH
59238: EMPTY
59239: LIST
59240: LIST
59241: PUSH
59242: LD_INT 0
59244: PUSH
59245: LD_INT 1
59247: PUSH
59248: EMPTY
59249: LIST
59250: LIST
59251: PUSH
59252: LD_INT 1
59254: NEG
59255: PUSH
59256: LD_INT 0
59258: PUSH
59259: EMPTY
59260: LIST
59261: LIST
59262: PUSH
59263: LD_INT 1
59265: NEG
59266: PUSH
59267: LD_INT 1
59269: NEG
59270: PUSH
59271: EMPTY
59272: LIST
59273: LIST
59274: PUSH
59275: LD_INT 1
59277: NEG
59278: PUSH
59279: LD_INT 2
59281: NEG
59282: PUSH
59283: EMPTY
59284: LIST
59285: LIST
59286: PUSH
59287: LD_INT 2
59289: PUSH
59290: LD_INT 1
59292: PUSH
59293: EMPTY
59294: LIST
59295: LIST
59296: PUSH
59297: LD_INT 2
59299: PUSH
59300: LD_INT 2
59302: PUSH
59303: EMPTY
59304: LIST
59305: LIST
59306: PUSH
59307: LD_INT 1
59309: PUSH
59310: LD_INT 2
59312: PUSH
59313: EMPTY
59314: LIST
59315: LIST
59316: PUSH
59317: LD_INT 2
59319: NEG
59320: PUSH
59321: LD_INT 1
59323: NEG
59324: PUSH
59325: EMPTY
59326: LIST
59327: LIST
59328: PUSH
59329: LD_INT 2
59331: NEG
59332: PUSH
59333: LD_INT 2
59335: NEG
59336: PUSH
59337: EMPTY
59338: LIST
59339: LIST
59340: PUSH
59341: LD_INT 2
59343: NEG
59344: PUSH
59345: LD_INT 3
59347: NEG
59348: PUSH
59349: EMPTY
59350: LIST
59351: LIST
59352: PUSH
59353: LD_INT 3
59355: NEG
59356: PUSH
59357: LD_INT 2
59359: NEG
59360: PUSH
59361: EMPTY
59362: LIST
59363: LIST
59364: PUSH
59365: LD_INT 3
59367: NEG
59368: PUSH
59369: LD_INT 3
59371: NEG
59372: PUSH
59373: EMPTY
59374: LIST
59375: LIST
59376: PUSH
59377: EMPTY
59378: LIST
59379: LIST
59380: LIST
59381: LIST
59382: LIST
59383: LIST
59384: LIST
59385: LIST
59386: LIST
59387: LIST
59388: LIST
59389: LIST
59390: LIST
59391: LIST
59392: LIST
59393: LIST
59394: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
59395: LD_ADDR_VAR 0 14
59399: PUSH
59400: LD_INT 0
59402: PUSH
59403: LD_INT 0
59405: PUSH
59406: EMPTY
59407: LIST
59408: LIST
59409: PUSH
59410: LD_INT 0
59412: PUSH
59413: LD_INT 1
59415: NEG
59416: PUSH
59417: EMPTY
59418: LIST
59419: LIST
59420: PUSH
59421: LD_INT 1
59423: PUSH
59424: LD_INT 0
59426: PUSH
59427: EMPTY
59428: LIST
59429: LIST
59430: PUSH
59431: LD_INT 1
59433: PUSH
59434: LD_INT 1
59436: PUSH
59437: EMPTY
59438: LIST
59439: LIST
59440: PUSH
59441: LD_INT 0
59443: PUSH
59444: LD_INT 1
59446: PUSH
59447: EMPTY
59448: LIST
59449: LIST
59450: PUSH
59451: LD_INT 1
59453: NEG
59454: PUSH
59455: LD_INT 0
59457: PUSH
59458: EMPTY
59459: LIST
59460: LIST
59461: PUSH
59462: LD_INT 1
59464: NEG
59465: PUSH
59466: LD_INT 1
59468: NEG
59469: PUSH
59470: EMPTY
59471: LIST
59472: LIST
59473: PUSH
59474: LD_INT 1
59476: NEG
59477: PUSH
59478: LD_INT 2
59480: NEG
59481: PUSH
59482: EMPTY
59483: LIST
59484: LIST
59485: PUSH
59486: LD_INT 0
59488: PUSH
59489: LD_INT 2
59491: NEG
59492: PUSH
59493: EMPTY
59494: LIST
59495: LIST
59496: PUSH
59497: LD_INT 1
59499: PUSH
59500: LD_INT 1
59502: NEG
59503: PUSH
59504: EMPTY
59505: LIST
59506: LIST
59507: PUSH
59508: LD_INT 1
59510: PUSH
59511: LD_INT 2
59513: PUSH
59514: EMPTY
59515: LIST
59516: LIST
59517: PUSH
59518: LD_INT 0
59520: PUSH
59521: LD_INT 2
59523: PUSH
59524: EMPTY
59525: LIST
59526: LIST
59527: PUSH
59528: LD_INT 1
59530: NEG
59531: PUSH
59532: LD_INT 1
59534: PUSH
59535: EMPTY
59536: LIST
59537: LIST
59538: PUSH
59539: LD_INT 1
59541: NEG
59542: PUSH
59543: LD_INT 3
59545: NEG
59546: PUSH
59547: EMPTY
59548: LIST
59549: LIST
59550: PUSH
59551: LD_INT 0
59553: PUSH
59554: LD_INT 3
59556: NEG
59557: PUSH
59558: EMPTY
59559: LIST
59560: LIST
59561: PUSH
59562: LD_INT 1
59564: PUSH
59565: LD_INT 2
59567: NEG
59568: PUSH
59569: EMPTY
59570: LIST
59571: LIST
59572: PUSH
59573: EMPTY
59574: LIST
59575: LIST
59576: LIST
59577: LIST
59578: LIST
59579: LIST
59580: LIST
59581: LIST
59582: LIST
59583: LIST
59584: LIST
59585: LIST
59586: LIST
59587: LIST
59588: LIST
59589: LIST
59590: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
59591: LD_ADDR_VAR 0 15
59595: PUSH
59596: LD_INT 0
59598: PUSH
59599: LD_INT 0
59601: PUSH
59602: EMPTY
59603: LIST
59604: LIST
59605: PUSH
59606: LD_INT 0
59608: PUSH
59609: LD_INT 1
59611: NEG
59612: PUSH
59613: EMPTY
59614: LIST
59615: LIST
59616: PUSH
59617: LD_INT 1
59619: PUSH
59620: LD_INT 0
59622: PUSH
59623: EMPTY
59624: LIST
59625: LIST
59626: PUSH
59627: LD_INT 1
59629: PUSH
59630: LD_INT 1
59632: PUSH
59633: EMPTY
59634: LIST
59635: LIST
59636: PUSH
59637: LD_INT 0
59639: PUSH
59640: LD_INT 1
59642: PUSH
59643: EMPTY
59644: LIST
59645: LIST
59646: PUSH
59647: LD_INT 1
59649: NEG
59650: PUSH
59651: LD_INT 0
59653: PUSH
59654: EMPTY
59655: LIST
59656: LIST
59657: PUSH
59658: LD_INT 1
59660: NEG
59661: PUSH
59662: LD_INT 1
59664: NEG
59665: PUSH
59666: EMPTY
59667: LIST
59668: LIST
59669: PUSH
59670: LD_INT 1
59672: PUSH
59673: LD_INT 1
59675: NEG
59676: PUSH
59677: EMPTY
59678: LIST
59679: LIST
59680: PUSH
59681: LD_INT 2
59683: PUSH
59684: LD_INT 0
59686: PUSH
59687: EMPTY
59688: LIST
59689: LIST
59690: PUSH
59691: LD_INT 2
59693: PUSH
59694: LD_INT 1
59696: PUSH
59697: EMPTY
59698: LIST
59699: LIST
59700: PUSH
59701: LD_INT 1
59703: NEG
59704: PUSH
59705: LD_INT 1
59707: PUSH
59708: EMPTY
59709: LIST
59710: LIST
59711: PUSH
59712: LD_INT 2
59714: NEG
59715: PUSH
59716: LD_INT 0
59718: PUSH
59719: EMPTY
59720: LIST
59721: LIST
59722: PUSH
59723: LD_INT 2
59725: NEG
59726: PUSH
59727: LD_INT 1
59729: NEG
59730: PUSH
59731: EMPTY
59732: LIST
59733: LIST
59734: PUSH
59735: LD_INT 2
59737: PUSH
59738: LD_INT 1
59740: NEG
59741: PUSH
59742: EMPTY
59743: LIST
59744: LIST
59745: PUSH
59746: LD_INT 3
59748: PUSH
59749: LD_INT 0
59751: PUSH
59752: EMPTY
59753: LIST
59754: LIST
59755: PUSH
59756: LD_INT 3
59758: PUSH
59759: LD_INT 1
59761: PUSH
59762: EMPTY
59763: LIST
59764: LIST
59765: PUSH
59766: EMPTY
59767: LIST
59768: LIST
59769: LIST
59770: LIST
59771: LIST
59772: LIST
59773: LIST
59774: LIST
59775: LIST
59776: LIST
59777: LIST
59778: LIST
59779: LIST
59780: LIST
59781: LIST
59782: LIST
59783: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
59784: LD_ADDR_VAR 0 16
59788: PUSH
59789: LD_INT 0
59791: PUSH
59792: LD_INT 0
59794: PUSH
59795: EMPTY
59796: LIST
59797: LIST
59798: PUSH
59799: LD_INT 0
59801: PUSH
59802: LD_INT 1
59804: NEG
59805: PUSH
59806: EMPTY
59807: LIST
59808: LIST
59809: PUSH
59810: LD_INT 1
59812: PUSH
59813: LD_INT 0
59815: PUSH
59816: EMPTY
59817: LIST
59818: LIST
59819: PUSH
59820: LD_INT 1
59822: PUSH
59823: LD_INT 1
59825: PUSH
59826: EMPTY
59827: LIST
59828: LIST
59829: PUSH
59830: LD_INT 0
59832: PUSH
59833: LD_INT 1
59835: PUSH
59836: EMPTY
59837: LIST
59838: LIST
59839: PUSH
59840: LD_INT 1
59842: NEG
59843: PUSH
59844: LD_INT 0
59846: PUSH
59847: EMPTY
59848: LIST
59849: LIST
59850: PUSH
59851: LD_INT 1
59853: NEG
59854: PUSH
59855: LD_INT 1
59857: NEG
59858: PUSH
59859: EMPTY
59860: LIST
59861: LIST
59862: PUSH
59863: LD_INT 1
59865: NEG
59866: PUSH
59867: LD_INT 2
59869: NEG
59870: PUSH
59871: EMPTY
59872: LIST
59873: LIST
59874: PUSH
59875: LD_INT 2
59877: PUSH
59878: LD_INT 1
59880: PUSH
59881: EMPTY
59882: LIST
59883: LIST
59884: PUSH
59885: LD_INT 2
59887: PUSH
59888: LD_INT 2
59890: PUSH
59891: EMPTY
59892: LIST
59893: LIST
59894: PUSH
59895: LD_INT 1
59897: PUSH
59898: LD_INT 2
59900: PUSH
59901: EMPTY
59902: LIST
59903: LIST
59904: PUSH
59905: LD_INT 2
59907: NEG
59908: PUSH
59909: LD_INT 1
59911: NEG
59912: PUSH
59913: EMPTY
59914: LIST
59915: LIST
59916: PUSH
59917: LD_INT 2
59919: NEG
59920: PUSH
59921: LD_INT 2
59923: NEG
59924: PUSH
59925: EMPTY
59926: LIST
59927: LIST
59928: PUSH
59929: LD_INT 3
59931: PUSH
59932: LD_INT 2
59934: PUSH
59935: EMPTY
59936: LIST
59937: LIST
59938: PUSH
59939: LD_INT 3
59941: PUSH
59942: LD_INT 3
59944: PUSH
59945: EMPTY
59946: LIST
59947: LIST
59948: PUSH
59949: LD_INT 2
59951: PUSH
59952: LD_INT 3
59954: PUSH
59955: EMPTY
59956: LIST
59957: LIST
59958: PUSH
59959: EMPTY
59960: LIST
59961: LIST
59962: LIST
59963: LIST
59964: LIST
59965: LIST
59966: LIST
59967: LIST
59968: LIST
59969: LIST
59970: LIST
59971: LIST
59972: LIST
59973: LIST
59974: LIST
59975: LIST
59976: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
59977: LD_ADDR_VAR 0 17
59981: PUSH
59982: LD_INT 0
59984: PUSH
59985: LD_INT 0
59987: PUSH
59988: EMPTY
59989: LIST
59990: LIST
59991: PUSH
59992: LD_INT 0
59994: PUSH
59995: LD_INT 1
59997: NEG
59998: PUSH
59999: EMPTY
60000: LIST
60001: LIST
60002: PUSH
60003: LD_INT 1
60005: PUSH
60006: LD_INT 0
60008: PUSH
60009: EMPTY
60010: LIST
60011: LIST
60012: PUSH
60013: LD_INT 1
60015: PUSH
60016: LD_INT 1
60018: PUSH
60019: EMPTY
60020: LIST
60021: LIST
60022: PUSH
60023: LD_INT 0
60025: PUSH
60026: LD_INT 1
60028: PUSH
60029: EMPTY
60030: LIST
60031: LIST
60032: PUSH
60033: LD_INT 1
60035: NEG
60036: PUSH
60037: LD_INT 0
60039: PUSH
60040: EMPTY
60041: LIST
60042: LIST
60043: PUSH
60044: LD_INT 1
60046: NEG
60047: PUSH
60048: LD_INT 1
60050: NEG
60051: PUSH
60052: EMPTY
60053: LIST
60054: LIST
60055: PUSH
60056: LD_INT 1
60058: NEG
60059: PUSH
60060: LD_INT 2
60062: NEG
60063: PUSH
60064: EMPTY
60065: LIST
60066: LIST
60067: PUSH
60068: LD_INT 0
60070: PUSH
60071: LD_INT 2
60073: NEG
60074: PUSH
60075: EMPTY
60076: LIST
60077: LIST
60078: PUSH
60079: LD_INT 1
60081: PUSH
60082: LD_INT 1
60084: NEG
60085: PUSH
60086: EMPTY
60087: LIST
60088: LIST
60089: PUSH
60090: LD_INT 2
60092: PUSH
60093: LD_INT 0
60095: PUSH
60096: EMPTY
60097: LIST
60098: LIST
60099: PUSH
60100: LD_INT 2
60102: PUSH
60103: LD_INT 1
60105: PUSH
60106: EMPTY
60107: LIST
60108: LIST
60109: PUSH
60110: LD_INT 2
60112: PUSH
60113: LD_INT 2
60115: PUSH
60116: EMPTY
60117: LIST
60118: LIST
60119: PUSH
60120: LD_INT 1
60122: PUSH
60123: LD_INT 2
60125: PUSH
60126: EMPTY
60127: LIST
60128: LIST
60129: PUSH
60130: LD_INT 0
60132: PUSH
60133: LD_INT 2
60135: PUSH
60136: EMPTY
60137: LIST
60138: LIST
60139: PUSH
60140: LD_INT 1
60142: NEG
60143: PUSH
60144: LD_INT 1
60146: PUSH
60147: EMPTY
60148: LIST
60149: LIST
60150: PUSH
60151: LD_INT 2
60153: NEG
60154: PUSH
60155: LD_INT 0
60157: PUSH
60158: EMPTY
60159: LIST
60160: LIST
60161: PUSH
60162: LD_INT 2
60164: NEG
60165: PUSH
60166: LD_INT 1
60168: NEG
60169: PUSH
60170: EMPTY
60171: LIST
60172: LIST
60173: PUSH
60174: LD_INT 2
60176: NEG
60177: PUSH
60178: LD_INT 2
60180: NEG
60181: PUSH
60182: EMPTY
60183: LIST
60184: LIST
60185: PUSH
60186: EMPTY
60187: LIST
60188: LIST
60189: LIST
60190: LIST
60191: LIST
60192: LIST
60193: LIST
60194: LIST
60195: LIST
60196: LIST
60197: LIST
60198: LIST
60199: LIST
60200: LIST
60201: LIST
60202: LIST
60203: LIST
60204: LIST
60205: LIST
60206: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
60207: LD_ADDR_VAR 0 18
60211: PUSH
60212: LD_INT 0
60214: PUSH
60215: LD_INT 0
60217: PUSH
60218: EMPTY
60219: LIST
60220: LIST
60221: PUSH
60222: LD_INT 0
60224: PUSH
60225: LD_INT 1
60227: NEG
60228: PUSH
60229: EMPTY
60230: LIST
60231: LIST
60232: PUSH
60233: LD_INT 1
60235: PUSH
60236: LD_INT 0
60238: PUSH
60239: EMPTY
60240: LIST
60241: LIST
60242: PUSH
60243: LD_INT 1
60245: PUSH
60246: LD_INT 1
60248: PUSH
60249: EMPTY
60250: LIST
60251: LIST
60252: PUSH
60253: LD_INT 0
60255: PUSH
60256: LD_INT 1
60258: PUSH
60259: EMPTY
60260: LIST
60261: LIST
60262: PUSH
60263: LD_INT 1
60265: NEG
60266: PUSH
60267: LD_INT 0
60269: PUSH
60270: EMPTY
60271: LIST
60272: LIST
60273: PUSH
60274: LD_INT 1
60276: NEG
60277: PUSH
60278: LD_INT 1
60280: NEG
60281: PUSH
60282: EMPTY
60283: LIST
60284: LIST
60285: PUSH
60286: LD_INT 1
60288: NEG
60289: PUSH
60290: LD_INT 2
60292: NEG
60293: PUSH
60294: EMPTY
60295: LIST
60296: LIST
60297: PUSH
60298: LD_INT 0
60300: PUSH
60301: LD_INT 2
60303: NEG
60304: PUSH
60305: EMPTY
60306: LIST
60307: LIST
60308: PUSH
60309: LD_INT 1
60311: PUSH
60312: LD_INT 1
60314: NEG
60315: PUSH
60316: EMPTY
60317: LIST
60318: LIST
60319: PUSH
60320: LD_INT 2
60322: PUSH
60323: LD_INT 0
60325: PUSH
60326: EMPTY
60327: LIST
60328: LIST
60329: PUSH
60330: LD_INT 2
60332: PUSH
60333: LD_INT 1
60335: PUSH
60336: EMPTY
60337: LIST
60338: LIST
60339: PUSH
60340: LD_INT 2
60342: PUSH
60343: LD_INT 2
60345: PUSH
60346: EMPTY
60347: LIST
60348: LIST
60349: PUSH
60350: LD_INT 1
60352: PUSH
60353: LD_INT 2
60355: PUSH
60356: EMPTY
60357: LIST
60358: LIST
60359: PUSH
60360: LD_INT 0
60362: PUSH
60363: LD_INT 2
60365: PUSH
60366: EMPTY
60367: LIST
60368: LIST
60369: PUSH
60370: LD_INT 1
60372: NEG
60373: PUSH
60374: LD_INT 1
60376: PUSH
60377: EMPTY
60378: LIST
60379: LIST
60380: PUSH
60381: LD_INT 2
60383: NEG
60384: PUSH
60385: LD_INT 0
60387: PUSH
60388: EMPTY
60389: LIST
60390: LIST
60391: PUSH
60392: LD_INT 2
60394: NEG
60395: PUSH
60396: LD_INT 1
60398: NEG
60399: PUSH
60400: EMPTY
60401: LIST
60402: LIST
60403: PUSH
60404: LD_INT 2
60406: NEG
60407: PUSH
60408: LD_INT 2
60410: NEG
60411: PUSH
60412: EMPTY
60413: LIST
60414: LIST
60415: PUSH
60416: EMPTY
60417: LIST
60418: LIST
60419: LIST
60420: LIST
60421: LIST
60422: LIST
60423: LIST
60424: LIST
60425: LIST
60426: LIST
60427: LIST
60428: LIST
60429: LIST
60430: LIST
60431: LIST
60432: LIST
60433: LIST
60434: LIST
60435: LIST
60436: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
60437: LD_ADDR_VAR 0 19
60441: PUSH
60442: LD_INT 0
60444: PUSH
60445: LD_INT 0
60447: PUSH
60448: EMPTY
60449: LIST
60450: LIST
60451: PUSH
60452: LD_INT 0
60454: PUSH
60455: LD_INT 1
60457: NEG
60458: PUSH
60459: EMPTY
60460: LIST
60461: LIST
60462: PUSH
60463: LD_INT 1
60465: PUSH
60466: LD_INT 0
60468: PUSH
60469: EMPTY
60470: LIST
60471: LIST
60472: PUSH
60473: LD_INT 1
60475: PUSH
60476: LD_INT 1
60478: PUSH
60479: EMPTY
60480: LIST
60481: LIST
60482: PUSH
60483: LD_INT 0
60485: PUSH
60486: LD_INT 1
60488: PUSH
60489: EMPTY
60490: LIST
60491: LIST
60492: PUSH
60493: LD_INT 1
60495: NEG
60496: PUSH
60497: LD_INT 0
60499: PUSH
60500: EMPTY
60501: LIST
60502: LIST
60503: PUSH
60504: LD_INT 1
60506: NEG
60507: PUSH
60508: LD_INT 1
60510: NEG
60511: PUSH
60512: EMPTY
60513: LIST
60514: LIST
60515: PUSH
60516: LD_INT 1
60518: NEG
60519: PUSH
60520: LD_INT 2
60522: NEG
60523: PUSH
60524: EMPTY
60525: LIST
60526: LIST
60527: PUSH
60528: LD_INT 0
60530: PUSH
60531: LD_INT 2
60533: NEG
60534: PUSH
60535: EMPTY
60536: LIST
60537: LIST
60538: PUSH
60539: LD_INT 1
60541: PUSH
60542: LD_INT 1
60544: NEG
60545: PUSH
60546: EMPTY
60547: LIST
60548: LIST
60549: PUSH
60550: LD_INT 2
60552: PUSH
60553: LD_INT 0
60555: PUSH
60556: EMPTY
60557: LIST
60558: LIST
60559: PUSH
60560: LD_INT 2
60562: PUSH
60563: LD_INT 1
60565: PUSH
60566: EMPTY
60567: LIST
60568: LIST
60569: PUSH
60570: LD_INT 2
60572: PUSH
60573: LD_INT 2
60575: PUSH
60576: EMPTY
60577: LIST
60578: LIST
60579: PUSH
60580: LD_INT 1
60582: PUSH
60583: LD_INT 2
60585: PUSH
60586: EMPTY
60587: LIST
60588: LIST
60589: PUSH
60590: LD_INT 0
60592: PUSH
60593: LD_INT 2
60595: PUSH
60596: EMPTY
60597: LIST
60598: LIST
60599: PUSH
60600: LD_INT 1
60602: NEG
60603: PUSH
60604: LD_INT 1
60606: PUSH
60607: EMPTY
60608: LIST
60609: LIST
60610: PUSH
60611: LD_INT 2
60613: NEG
60614: PUSH
60615: LD_INT 0
60617: PUSH
60618: EMPTY
60619: LIST
60620: LIST
60621: PUSH
60622: LD_INT 2
60624: NEG
60625: PUSH
60626: LD_INT 1
60628: NEG
60629: PUSH
60630: EMPTY
60631: LIST
60632: LIST
60633: PUSH
60634: LD_INT 2
60636: NEG
60637: PUSH
60638: LD_INT 2
60640: NEG
60641: PUSH
60642: EMPTY
60643: LIST
60644: LIST
60645: PUSH
60646: EMPTY
60647: LIST
60648: LIST
60649: LIST
60650: LIST
60651: LIST
60652: LIST
60653: LIST
60654: LIST
60655: LIST
60656: LIST
60657: LIST
60658: LIST
60659: LIST
60660: LIST
60661: LIST
60662: LIST
60663: LIST
60664: LIST
60665: LIST
60666: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
60667: LD_ADDR_VAR 0 20
60671: PUSH
60672: LD_INT 0
60674: PUSH
60675: LD_INT 0
60677: PUSH
60678: EMPTY
60679: LIST
60680: LIST
60681: PUSH
60682: LD_INT 0
60684: PUSH
60685: LD_INT 1
60687: NEG
60688: PUSH
60689: EMPTY
60690: LIST
60691: LIST
60692: PUSH
60693: LD_INT 1
60695: PUSH
60696: LD_INT 0
60698: PUSH
60699: EMPTY
60700: LIST
60701: LIST
60702: PUSH
60703: LD_INT 1
60705: PUSH
60706: LD_INT 1
60708: PUSH
60709: EMPTY
60710: LIST
60711: LIST
60712: PUSH
60713: LD_INT 0
60715: PUSH
60716: LD_INT 1
60718: PUSH
60719: EMPTY
60720: LIST
60721: LIST
60722: PUSH
60723: LD_INT 1
60725: NEG
60726: PUSH
60727: LD_INT 0
60729: PUSH
60730: EMPTY
60731: LIST
60732: LIST
60733: PUSH
60734: LD_INT 1
60736: NEG
60737: PUSH
60738: LD_INT 1
60740: NEG
60741: PUSH
60742: EMPTY
60743: LIST
60744: LIST
60745: PUSH
60746: LD_INT 1
60748: NEG
60749: PUSH
60750: LD_INT 2
60752: NEG
60753: PUSH
60754: EMPTY
60755: LIST
60756: LIST
60757: PUSH
60758: LD_INT 0
60760: PUSH
60761: LD_INT 2
60763: NEG
60764: PUSH
60765: EMPTY
60766: LIST
60767: LIST
60768: PUSH
60769: LD_INT 1
60771: PUSH
60772: LD_INT 1
60774: NEG
60775: PUSH
60776: EMPTY
60777: LIST
60778: LIST
60779: PUSH
60780: LD_INT 2
60782: PUSH
60783: LD_INT 0
60785: PUSH
60786: EMPTY
60787: LIST
60788: LIST
60789: PUSH
60790: LD_INT 2
60792: PUSH
60793: LD_INT 1
60795: PUSH
60796: EMPTY
60797: LIST
60798: LIST
60799: PUSH
60800: LD_INT 2
60802: PUSH
60803: LD_INT 2
60805: PUSH
60806: EMPTY
60807: LIST
60808: LIST
60809: PUSH
60810: LD_INT 1
60812: PUSH
60813: LD_INT 2
60815: PUSH
60816: EMPTY
60817: LIST
60818: LIST
60819: PUSH
60820: LD_INT 0
60822: PUSH
60823: LD_INT 2
60825: PUSH
60826: EMPTY
60827: LIST
60828: LIST
60829: PUSH
60830: LD_INT 1
60832: NEG
60833: PUSH
60834: LD_INT 1
60836: PUSH
60837: EMPTY
60838: LIST
60839: LIST
60840: PUSH
60841: LD_INT 2
60843: NEG
60844: PUSH
60845: LD_INT 0
60847: PUSH
60848: EMPTY
60849: LIST
60850: LIST
60851: PUSH
60852: LD_INT 2
60854: NEG
60855: PUSH
60856: LD_INT 1
60858: NEG
60859: PUSH
60860: EMPTY
60861: LIST
60862: LIST
60863: PUSH
60864: LD_INT 2
60866: NEG
60867: PUSH
60868: LD_INT 2
60870: NEG
60871: PUSH
60872: EMPTY
60873: LIST
60874: LIST
60875: PUSH
60876: EMPTY
60877: LIST
60878: LIST
60879: LIST
60880: LIST
60881: LIST
60882: LIST
60883: LIST
60884: LIST
60885: LIST
60886: LIST
60887: LIST
60888: LIST
60889: LIST
60890: LIST
60891: LIST
60892: LIST
60893: LIST
60894: LIST
60895: LIST
60896: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
60897: LD_ADDR_VAR 0 21
60901: PUSH
60902: LD_INT 0
60904: PUSH
60905: LD_INT 0
60907: PUSH
60908: EMPTY
60909: LIST
60910: LIST
60911: PUSH
60912: LD_INT 0
60914: PUSH
60915: LD_INT 1
60917: NEG
60918: PUSH
60919: EMPTY
60920: LIST
60921: LIST
60922: PUSH
60923: LD_INT 1
60925: PUSH
60926: LD_INT 0
60928: PUSH
60929: EMPTY
60930: LIST
60931: LIST
60932: PUSH
60933: LD_INT 1
60935: PUSH
60936: LD_INT 1
60938: PUSH
60939: EMPTY
60940: LIST
60941: LIST
60942: PUSH
60943: LD_INT 0
60945: PUSH
60946: LD_INT 1
60948: PUSH
60949: EMPTY
60950: LIST
60951: LIST
60952: PUSH
60953: LD_INT 1
60955: NEG
60956: PUSH
60957: LD_INT 0
60959: PUSH
60960: EMPTY
60961: LIST
60962: LIST
60963: PUSH
60964: LD_INT 1
60966: NEG
60967: PUSH
60968: LD_INT 1
60970: NEG
60971: PUSH
60972: EMPTY
60973: LIST
60974: LIST
60975: PUSH
60976: LD_INT 1
60978: NEG
60979: PUSH
60980: LD_INT 2
60982: NEG
60983: PUSH
60984: EMPTY
60985: LIST
60986: LIST
60987: PUSH
60988: LD_INT 0
60990: PUSH
60991: LD_INT 2
60993: NEG
60994: PUSH
60995: EMPTY
60996: LIST
60997: LIST
60998: PUSH
60999: LD_INT 1
61001: PUSH
61002: LD_INT 1
61004: NEG
61005: PUSH
61006: EMPTY
61007: LIST
61008: LIST
61009: PUSH
61010: LD_INT 2
61012: PUSH
61013: LD_INT 0
61015: PUSH
61016: EMPTY
61017: LIST
61018: LIST
61019: PUSH
61020: LD_INT 2
61022: PUSH
61023: LD_INT 1
61025: PUSH
61026: EMPTY
61027: LIST
61028: LIST
61029: PUSH
61030: LD_INT 2
61032: PUSH
61033: LD_INT 2
61035: PUSH
61036: EMPTY
61037: LIST
61038: LIST
61039: PUSH
61040: LD_INT 1
61042: PUSH
61043: LD_INT 2
61045: PUSH
61046: EMPTY
61047: LIST
61048: LIST
61049: PUSH
61050: LD_INT 0
61052: PUSH
61053: LD_INT 2
61055: PUSH
61056: EMPTY
61057: LIST
61058: LIST
61059: PUSH
61060: LD_INT 1
61062: NEG
61063: PUSH
61064: LD_INT 1
61066: PUSH
61067: EMPTY
61068: LIST
61069: LIST
61070: PUSH
61071: LD_INT 2
61073: NEG
61074: PUSH
61075: LD_INT 0
61077: PUSH
61078: EMPTY
61079: LIST
61080: LIST
61081: PUSH
61082: LD_INT 2
61084: NEG
61085: PUSH
61086: LD_INT 1
61088: NEG
61089: PUSH
61090: EMPTY
61091: LIST
61092: LIST
61093: PUSH
61094: LD_INT 2
61096: NEG
61097: PUSH
61098: LD_INT 2
61100: NEG
61101: PUSH
61102: EMPTY
61103: LIST
61104: LIST
61105: PUSH
61106: EMPTY
61107: LIST
61108: LIST
61109: LIST
61110: LIST
61111: LIST
61112: LIST
61113: LIST
61114: LIST
61115: LIST
61116: LIST
61117: LIST
61118: LIST
61119: LIST
61120: LIST
61121: LIST
61122: LIST
61123: LIST
61124: LIST
61125: LIST
61126: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
61127: LD_ADDR_VAR 0 22
61131: PUSH
61132: LD_INT 0
61134: PUSH
61135: LD_INT 0
61137: PUSH
61138: EMPTY
61139: LIST
61140: LIST
61141: PUSH
61142: LD_INT 0
61144: PUSH
61145: LD_INT 1
61147: NEG
61148: PUSH
61149: EMPTY
61150: LIST
61151: LIST
61152: PUSH
61153: LD_INT 1
61155: PUSH
61156: LD_INT 0
61158: PUSH
61159: EMPTY
61160: LIST
61161: LIST
61162: PUSH
61163: LD_INT 1
61165: PUSH
61166: LD_INT 1
61168: PUSH
61169: EMPTY
61170: LIST
61171: LIST
61172: PUSH
61173: LD_INT 0
61175: PUSH
61176: LD_INT 1
61178: PUSH
61179: EMPTY
61180: LIST
61181: LIST
61182: PUSH
61183: LD_INT 1
61185: NEG
61186: PUSH
61187: LD_INT 0
61189: PUSH
61190: EMPTY
61191: LIST
61192: LIST
61193: PUSH
61194: LD_INT 1
61196: NEG
61197: PUSH
61198: LD_INT 1
61200: NEG
61201: PUSH
61202: EMPTY
61203: LIST
61204: LIST
61205: PUSH
61206: LD_INT 1
61208: NEG
61209: PUSH
61210: LD_INT 2
61212: NEG
61213: PUSH
61214: EMPTY
61215: LIST
61216: LIST
61217: PUSH
61218: LD_INT 0
61220: PUSH
61221: LD_INT 2
61223: NEG
61224: PUSH
61225: EMPTY
61226: LIST
61227: LIST
61228: PUSH
61229: LD_INT 1
61231: PUSH
61232: LD_INT 1
61234: NEG
61235: PUSH
61236: EMPTY
61237: LIST
61238: LIST
61239: PUSH
61240: LD_INT 2
61242: PUSH
61243: LD_INT 0
61245: PUSH
61246: EMPTY
61247: LIST
61248: LIST
61249: PUSH
61250: LD_INT 2
61252: PUSH
61253: LD_INT 1
61255: PUSH
61256: EMPTY
61257: LIST
61258: LIST
61259: PUSH
61260: LD_INT 2
61262: PUSH
61263: LD_INT 2
61265: PUSH
61266: EMPTY
61267: LIST
61268: LIST
61269: PUSH
61270: LD_INT 1
61272: PUSH
61273: LD_INT 2
61275: PUSH
61276: EMPTY
61277: LIST
61278: LIST
61279: PUSH
61280: LD_INT 0
61282: PUSH
61283: LD_INT 2
61285: PUSH
61286: EMPTY
61287: LIST
61288: LIST
61289: PUSH
61290: LD_INT 1
61292: NEG
61293: PUSH
61294: LD_INT 1
61296: PUSH
61297: EMPTY
61298: LIST
61299: LIST
61300: PUSH
61301: LD_INT 2
61303: NEG
61304: PUSH
61305: LD_INT 0
61307: PUSH
61308: EMPTY
61309: LIST
61310: LIST
61311: PUSH
61312: LD_INT 2
61314: NEG
61315: PUSH
61316: LD_INT 1
61318: NEG
61319: PUSH
61320: EMPTY
61321: LIST
61322: LIST
61323: PUSH
61324: LD_INT 2
61326: NEG
61327: PUSH
61328: LD_INT 2
61330: NEG
61331: PUSH
61332: EMPTY
61333: LIST
61334: LIST
61335: PUSH
61336: EMPTY
61337: LIST
61338: LIST
61339: LIST
61340: LIST
61341: LIST
61342: LIST
61343: LIST
61344: LIST
61345: LIST
61346: LIST
61347: LIST
61348: LIST
61349: LIST
61350: LIST
61351: LIST
61352: LIST
61353: LIST
61354: LIST
61355: LIST
61356: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
61357: LD_ADDR_VAR 0 23
61361: PUSH
61362: LD_INT 0
61364: PUSH
61365: LD_INT 0
61367: PUSH
61368: EMPTY
61369: LIST
61370: LIST
61371: PUSH
61372: LD_INT 0
61374: PUSH
61375: LD_INT 1
61377: NEG
61378: PUSH
61379: EMPTY
61380: LIST
61381: LIST
61382: PUSH
61383: LD_INT 1
61385: PUSH
61386: LD_INT 0
61388: PUSH
61389: EMPTY
61390: LIST
61391: LIST
61392: PUSH
61393: LD_INT 1
61395: PUSH
61396: LD_INT 1
61398: PUSH
61399: EMPTY
61400: LIST
61401: LIST
61402: PUSH
61403: LD_INT 0
61405: PUSH
61406: LD_INT 1
61408: PUSH
61409: EMPTY
61410: LIST
61411: LIST
61412: PUSH
61413: LD_INT 1
61415: NEG
61416: PUSH
61417: LD_INT 0
61419: PUSH
61420: EMPTY
61421: LIST
61422: LIST
61423: PUSH
61424: LD_INT 1
61426: NEG
61427: PUSH
61428: LD_INT 1
61430: NEG
61431: PUSH
61432: EMPTY
61433: LIST
61434: LIST
61435: PUSH
61436: LD_INT 1
61438: NEG
61439: PUSH
61440: LD_INT 2
61442: NEG
61443: PUSH
61444: EMPTY
61445: LIST
61446: LIST
61447: PUSH
61448: LD_INT 0
61450: PUSH
61451: LD_INT 2
61453: NEG
61454: PUSH
61455: EMPTY
61456: LIST
61457: LIST
61458: PUSH
61459: LD_INT 1
61461: PUSH
61462: LD_INT 1
61464: NEG
61465: PUSH
61466: EMPTY
61467: LIST
61468: LIST
61469: PUSH
61470: LD_INT 2
61472: PUSH
61473: LD_INT 0
61475: PUSH
61476: EMPTY
61477: LIST
61478: LIST
61479: PUSH
61480: LD_INT 2
61482: PUSH
61483: LD_INT 1
61485: PUSH
61486: EMPTY
61487: LIST
61488: LIST
61489: PUSH
61490: LD_INT 2
61492: PUSH
61493: LD_INT 2
61495: PUSH
61496: EMPTY
61497: LIST
61498: LIST
61499: PUSH
61500: LD_INT 1
61502: PUSH
61503: LD_INT 2
61505: PUSH
61506: EMPTY
61507: LIST
61508: LIST
61509: PUSH
61510: LD_INT 0
61512: PUSH
61513: LD_INT 2
61515: PUSH
61516: EMPTY
61517: LIST
61518: LIST
61519: PUSH
61520: LD_INT 1
61522: NEG
61523: PUSH
61524: LD_INT 1
61526: PUSH
61527: EMPTY
61528: LIST
61529: LIST
61530: PUSH
61531: LD_INT 2
61533: NEG
61534: PUSH
61535: LD_INT 0
61537: PUSH
61538: EMPTY
61539: LIST
61540: LIST
61541: PUSH
61542: LD_INT 2
61544: NEG
61545: PUSH
61546: LD_INT 1
61548: NEG
61549: PUSH
61550: EMPTY
61551: LIST
61552: LIST
61553: PUSH
61554: LD_INT 2
61556: NEG
61557: PUSH
61558: LD_INT 2
61560: NEG
61561: PUSH
61562: EMPTY
61563: LIST
61564: LIST
61565: PUSH
61566: LD_INT 2
61568: NEG
61569: PUSH
61570: LD_INT 3
61572: NEG
61573: PUSH
61574: EMPTY
61575: LIST
61576: LIST
61577: PUSH
61578: LD_INT 1
61580: NEG
61581: PUSH
61582: LD_INT 3
61584: NEG
61585: PUSH
61586: EMPTY
61587: LIST
61588: LIST
61589: PUSH
61590: LD_INT 1
61592: PUSH
61593: LD_INT 2
61595: NEG
61596: PUSH
61597: EMPTY
61598: LIST
61599: LIST
61600: PUSH
61601: LD_INT 2
61603: PUSH
61604: LD_INT 1
61606: NEG
61607: PUSH
61608: EMPTY
61609: LIST
61610: LIST
61611: PUSH
61612: EMPTY
61613: LIST
61614: LIST
61615: LIST
61616: LIST
61617: LIST
61618: LIST
61619: LIST
61620: LIST
61621: LIST
61622: LIST
61623: LIST
61624: LIST
61625: LIST
61626: LIST
61627: LIST
61628: LIST
61629: LIST
61630: LIST
61631: LIST
61632: LIST
61633: LIST
61634: LIST
61635: LIST
61636: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
61637: LD_ADDR_VAR 0 24
61641: PUSH
61642: LD_INT 0
61644: PUSH
61645: LD_INT 0
61647: PUSH
61648: EMPTY
61649: LIST
61650: LIST
61651: PUSH
61652: LD_INT 0
61654: PUSH
61655: LD_INT 1
61657: NEG
61658: PUSH
61659: EMPTY
61660: LIST
61661: LIST
61662: PUSH
61663: LD_INT 1
61665: PUSH
61666: LD_INT 0
61668: PUSH
61669: EMPTY
61670: LIST
61671: LIST
61672: PUSH
61673: LD_INT 1
61675: PUSH
61676: LD_INT 1
61678: PUSH
61679: EMPTY
61680: LIST
61681: LIST
61682: PUSH
61683: LD_INT 0
61685: PUSH
61686: LD_INT 1
61688: PUSH
61689: EMPTY
61690: LIST
61691: LIST
61692: PUSH
61693: LD_INT 1
61695: NEG
61696: PUSH
61697: LD_INT 0
61699: PUSH
61700: EMPTY
61701: LIST
61702: LIST
61703: PUSH
61704: LD_INT 1
61706: NEG
61707: PUSH
61708: LD_INT 1
61710: NEG
61711: PUSH
61712: EMPTY
61713: LIST
61714: LIST
61715: PUSH
61716: LD_INT 1
61718: NEG
61719: PUSH
61720: LD_INT 2
61722: NEG
61723: PUSH
61724: EMPTY
61725: LIST
61726: LIST
61727: PUSH
61728: LD_INT 0
61730: PUSH
61731: LD_INT 2
61733: NEG
61734: PUSH
61735: EMPTY
61736: LIST
61737: LIST
61738: PUSH
61739: LD_INT 1
61741: PUSH
61742: LD_INT 1
61744: NEG
61745: PUSH
61746: EMPTY
61747: LIST
61748: LIST
61749: PUSH
61750: LD_INT 2
61752: PUSH
61753: LD_INT 0
61755: PUSH
61756: EMPTY
61757: LIST
61758: LIST
61759: PUSH
61760: LD_INT 2
61762: PUSH
61763: LD_INT 1
61765: PUSH
61766: EMPTY
61767: LIST
61768: LIST
61769: PUSH
61770: LD_INT 2
61772: PUSH
61773: LD_INT 2
61775: PUSH
61776: EMPTY
61777: LIST
61778: LIST
61779: PUSH
61780: LD_INT 1
61782: PUSH
61783: LD_INT 2
61785: PUSH
61786: EMPTY
61787: LIST
61788: LIST
61789: PUSH
61790: LD_INT 0
61792: PUSH
61793: LD_INT 2
61795: PUSH
61796: EMPTY
61797: LIST
61798: LIST
61799: PUSH
61800: LD_INT 1
61802: NEG
61803: PUSH
61804: LD_INT 1
61806: PUSH
61807: EMPTY
61808: LIST
61809: LIST
61810: PUSH
61811: LD_INT 2
61813: NEG
61814: PUSH
61815: LD_INT 0
61817: PUSH
61818: EMPTY
61819: LIST
61820: LIST
61821: PUSH
61822: LD_INT 2
61824: NEG
61825: PUSH
61826: LD_INT 1
61828: NEG
61829: PUSH
61830: EMPTY
61831: LIST
61832: LIST
61833: PUSH
61834: LD_INT 2
61836: NEG
61837: PUSH
61838: LD_INT 2
61840: NEG
61841: PUSH
61842: EMPTY
61843: LIST
61844: LIST
61845: PUSH
61846: LD_INT 1
61848: PUSH
61849: LD_INT 2
61851: NEG
61852: PUSH
61853: EMPTY
61854: LIST
61855: LIST
61856: PUSH
61857: LD_INT 2
61859: PUSH
61860: LD_INT 1
61862: NEG
61863: PUSH
61864: EMPTY
61865: LIST
61866: LIST
61867: PUSH
61868: LD_INT 3
61870: PUSH
61871: LD_INT 1
61873: PUSH
61874: EMPTY
61875: LIST
61876: LIST
61877: PUSH
61878: LD_INT 3
61880: PUSH
61881: LD_INT 2
61883: PUSH
61884: EMPTY
61885: LIST
61886: LIST
61887: PUSH
61888: EMPTY
61889: LIST
61890: LIST
61891: LIST
61892: LIST
61893: LIST
61894: LIST
61895: LIST
61896: LIST
61897: LIST
61898: LIST
61899: LIST
61900: LIST
61901: LIST
61902: LIST
61903: LIST
61904: LIST
61905: LIST
61906: LIST
61907: LIST
61908: LIST
61909: LIST
61910: LIST
61911: LIST
61912: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
61913: LD_ADDR_VAR 0 25
61917: PUSH
61918: LD_INT 0
61920: PUSH
61921: LD_INT 0
61923: PUSH
61924: EMPTY
61925: LIST
61926: LIST
61927: PUSH
61928: LD_INT 0
61930: PUSH
61931: LD_INT 1
61933: NEG
61934: PUSH
61935: EMPTY
61936: LIST
61937: LIST
61938: PUSH
61939: LD_INT 1
61941: PUSH
61942: LD_INT 0
61944: PUSH
61945: EMPTY
61946: LIST
61947: LIST
61948: PUSH
61949: LD_INT 1
61951: PUSH
61952: LD_INT 1
61954: PUSH
61955: EMPTY
61956: LIST
61957: LIST
61958: PUSH
61959: LD_INT 0
61961: PUSH
61962: LD_INT 1
61964: PUSH
61965: EMPTY
61966: LIST
61967: LIST
61968: PUSH
61969: LD_INT 1
61971: NEG
61972: PUSH
61973: LD_INT 0
61975: PUSH
61976: EMPTY
61977: LIST
61978: LIST
61979: PUSH
61980: LD_INT 1
61982: NEG
61983: PUSH
61984: LD_INT 1
61986: NEG
61987: PUSH
61988: EMPTY
61989: LIST
61990: LIST
61991: PUSH
61992: LD_INT 1
61994: NEG
61995: PUSH
61996: LD_INT 2
61998: NEG
61999: PUSH
62000: EMPTY
62001: LIST
62002: LIST
62003: PUSH
62004: LD_INT 0
62006: PUSH
62007: LD_INT 2
62009: NEG
62010: PUSH
62011: EMPTY
62012: LIST
62013: LIST
62014: PUSH
62015: LD_INT 1
62017: PUSH
62018: LD_INT 1
62020: NEG
62021: PUSH
62022: EMPTY
62023: LIST
62024: LIST
62025: PUSH
62026: LD_INT 2
62028: PUSH
62029: LD_INT 0
62031: PUSH
62032: EMPTY
62033: LIST
62034: LIST
62035: PUSH
62036: LD_INT 2
62038: PUSH
62039: LD_INT 1
62041: PUSH
62042: EMPTY
62043: LIST
62044: LIST
62045: PUSH
62046: LD_INT 2
62048: PUSH
62049: LD_INT 2
62051: PUSH
62052: EMPTY
62053: LIST
62054: LIST
62055: PUSH
62056: LD_INT 1
62058: PUSH
62059: LD_INT 2
62061: PUSH
62062: EMPTY
62063: LIST
62064: LIST
62065: PUSH
62066: LD_INT 0
62068: PUSH
62069: LD_INT 2
62071: PUSH
62072: EMPTY
62073: LIST
62074: LIST
62075: PUSH
62076: LD_INT 1
62078: NEG
62079: PUSH
62080: LD_INT 1
62082: PUSH
62083: EMPTY
62084: LIST
62085: LIST
62086: PUSH
62087: LD_INT 2
62089: NEG
62090: PUSH
62091: LD_INT 0
62093: PUSH
62094: EMPTY
62095: LIST
62096: LIST
62097: PUSH
62098: LD_INT 2
62100: NEG
62101: PUSH
62102: LD_INT 1
62104: NEG
62105: PUSH
62106: EMPTY
62107: LIST
62108: LIST
62109: PUSH
62110: LD_INT 2
62112: NEG
62113: PUSH
62114: LD_INT 2
62116: NEG
62117: PUSH
62118: EMPTY
62119: LIST
62120: LIST
62121: PUSH
62122: LD_INT 3
62124: PUSH
62125: LD_INT 1
62127: PUSH
62128: EMPTY
62129: LIST
62130: LIST
62131: PUSH
62132: LD_INT 3
62134: PUSH
62135: LD_INT 2
62137: PUSH
62138: EMPTY
62139: LIST
62140: LIST
62141: PUSH
62142: LD_INT 2
62144: PUSH
62145: LD_INT 3
62147: PUSH
62148: EMPTY
62149: LIST
62150: LIST
62151: PUSH
62152: LD_INT 1
62154: PUSH
62155: LD_INT 3
62157: PUSH
62158: EMPTY
62159: LIST
62160: LIST
62161: PUSH
62162: EMPTY
62163: LIST
62164: LIST
62165: LIST
62166: LIST
62167: LIST
62168: LIST
62169: LIST
62170: LIST
62171: LIST
62172: LIST
62173: LIST
62174: LIST
62175: LIST
62176: LIST
62177: LIST
62178: LIST
62179: LIST
62180: LIST
62181: LIST
62182: LIST
62183: LIST
62184: LIST
62185: LIST
62186: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
62187: LD_ADDR_VAR 0 26
62191: PUSH
62192: LD_INT 0
62194: PUSH
62195: LD_INT 0
62197: PUSH
62198: EMPTY
62199: LIST
62200: LIST
62201: PUSH
62202: LD_INT 0
62204: PUSH
62205: LD_INT 1
62207: NEG
62208: PUSH
62209: EMPTY
62210: LIST
62211: LIST
62212: PUSH
62213: LD_INT 1
62215: PUSH
62216: LD_INT 0
62218: PUSH
62219: EMPTY
62220: LIST
62221: LIST
62222: PUSH
62223: LD_INT 1
62225: PUSH
62226: LD_INT 1
62228: PUSH
62229: EMPTY
62230: LIST
62231: LIST
62232: PUSH
62233: LD_INT 0
62235: PUSH
62236: LD_INT 1
62238: PUSH
62239: EMPTY
62240: LIST
62241: LIST
62242: PUSH
62243: LD_INT 1
62245: NEG
62246: PUSH
62247: LD_INT 0
62249: PUSH
62250: EMPTY
62251: LIST
62252: LIST
62253: PUSH
62254: LD_INT 1
62256: NEG
62257: PUSH
62258: LD_INT 1
62260: NEG
62261: PUSH
62262: EMPTY
62263: LIST
62264: LIST
62265: PUSH
62266: LD_INT 1
62268: NEG
62269: PUSH
62270: LD_INT 2
62272: NEG
62273: PUSH
62274: EMPTY
62275: LIST
62276: LIST
62277: PUSH
62278: LD_INT 0
62280: PUSH
62281: LD_INT 2
62283: NEG
62284: PUSH
62285: EMPTY
62286: LIST
62287: LIST
62288: PUSH
62289: LD_INT 1
62291: PUSH
62292: LD_INT 1
62294: NEG
62295: PUSH
62296: EMPTY
62297: LIST
62298: LIST
62299: PUSH
62300: LD_INT 2
62302: PUSH
62303: LD_INT 0
62305: PUSH
62306: EMPTY
62307: LIST
62308: LIST
62309: PUSH
62310: LD_INT 2
62312: PUSH
62313: LD_INT 1
62315: PUSH
62316: EMPTY
62317: LIST
62318: LIST
62319: PUSH
62320: LD_INT 2
62322: PUSH
62323: LD_INT 2
62325: PUSH
62326: EMPTY
62327: LIST
62328: LIST
62329: PUSH
62330: LD_INT 1
62332: PUSH
62333: LD_INT 2
62335: PUSH
62336: EMPTY
62337: LIST
62338: LIST
62339: PUSH
62340: LD_INT 0
62342: PUSH
62343: LD_INT 2
62345: PUSH
62346: EMPTY
62347: LIST
62348: LIST
62349: PUSH
62350: LD_INT 1
62352: NEG
62353: PUSH
62354: LD_INT 1
62356: PUSH
62357: EMPTY
62358: LIST
62359: LIST
62360: PUSH
62361: LD_INT 2
62363: NEG
62364: PUSH
62365: LD_INT 0
62367: PUSH
62368: EMPTY
62369: LIST
62370: LIST
62371: PUSH
62372: LD_INT 2
62374: NEG
62375: PUSH
62376: LD_INT 1
62378: NEG
62379: PUSH
62380: EMPTY
62381: LIST
62382: LIST
62383: PUSH
62384: LD_INT 2
62386: NEG
62387: PUSH
62388: LD_INT 2
62390: NEG
62391: PUSH
62392: EMPTY
62393: LIST
62394: LIST
62395: PUSH
62396: LD_INT 2
62398: PUSH
62399: LD_INT 3
62401: PUSH
62402: EMPTY
62403: LIST
62404: LIST
62405: PUSH
62406: LD_INT 1
62408: PUSH
62409: LD_INT 3
62411: PUSH
62412: EMPTY
62413: LIST
62414: LIST
62415: PUSH
62416: LD_INT 1
62418: NEG
62419: PUSH
62420: LD_INT 2
62422: PUSH
62423: EMPTY
62424: LIST
62425: LIST
62426: PUSH
62427: LD_INT 2
62429: NEG
62430: PUSH
62431: LD_INT 1
62433: PUSH
62434: EMPTY
62435: LIST
62436: LIST
62437: PUSH
62438: EMPTY
62439: LIST
62440: LIST
62441: LIST
62442: LIST
62443: LIST
62444: LIST
62445: LIST
62446: LIST
62447: LIST
62448: LIST
62449: LIST
62450: LIST
62451: LIST
62452: LIST
62453: LIST
62454: LIST
62455: LIST
62456: LIST
62457: LIST
62458: LIST
62459: LIST
62460: LIST
62461: LIST
62462: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
62463: LD_ADDR_VAR 0 27
62467: PUSH
62468: LD_INT 0
62470: PUSH
62471: LD_INT 0
62473: PUSH
62474: EMPTY
62475: LIST
62476: LIST
62477: PUSH
62478: LD_INT 0
62480: PUSH
62481: LD_INT 1
62483: NEG
62484: PUSH
62485: EMPTY
62486: LIST
62487: LIST
62488: PUSH
62489: LD_INT 1
62491: PUSH
62492: LD_INT 0
62494: PUSH
62495: EMPTY
62496: LIST
62497: LIST
62498: PUSH
62499: LD_INT 1
62501: PUSH
62502: LD_INT 1
62504: PUSH
62505: EMPTY
62506: LIST
62507: LIST
62508: PUSH
62509: LD_INT 0
62511: PUSH
62512: LD_INT 1
62514: PUSH
62515: EMPTY
62516: LIST
62517: LIST
62518: PUSH
62519: LD_INT 1
62521: NEG
62522: PUSH
62523: LD_INT 0
62525: PUSH
62526: EMPTY
62527: LIST
62528: LIST
62529: PUSH
62530: LD_INT 1
62532: NEG
62533: PUSH
62534: LD_INT 1
62536: NEG
62537: PUSH
62538: EMPTY
62539: LIST
62540: LIST
62541: PUSH
62542: LD_INT 1
62544: NEG
62545: PUSH
62546: LD_INT 2
62548: NEG
62549: PUSH
62550: EMPTY
62551: LIST
62552: LIST
62553: PUSH
62554: LD_INT 0
62556: PUSH
62557: LD_INT 2
62559: NEG
62560: PUSH
62561: EMPTY
62562: LIST
62563: LIST
62564: PUSH
62565: LD_INT 1
62567: PUSH
62568: LD_INT 1
62570: NEG
62571: PUSH
62572: EMPTY
62573: LIST
62574: LIST
62575: PUSH
62576: LD_INT 2
62578: PUSH
62579: LD_INT 0
62581: PUSH
62582: EMPTY
62583: LIST
62584: LIST
62585: PUSH
62586: LD_INT 2
62588: PUSH
62589: LD_INT 1
62591: PUSH
62592: EMPTY
62593: LIST
62594: LIST
62595: PUSH
62596: LD_INT 2
62598: PUSH
62599: LD_INT 2
62601: PUSH
62602: EMPTY
62603: LIST
62604: LIST
62605: PUSH
62606: LD_INT 1
62608: PUSH
62609: LD_INT 2
62611: PUSH
62612: EMPTY
62613: LIST
62614: LIST
62615: PUSH
62616: LD_INT 0
62618: PUSH
62619: LD_INT 2
62621: PUSH
62622: EMPTY
62623: LIST
62624: LIST
62625: PUSH
62626: LD_INT 1
62628: NEG
62629: PUSH
62630: LD_INT 1
62632: PUSH
62633: EMPTY
62634: LIST
62635: LIST
62636: PUSH
62637: LD_INT 2
62639: NEG
62640: PUSH
62641: LD_INT 0
62643: PUSH
62644: EMPTY
62645: LIST
62646: LIST
62647: PUSH
62648: LD_INT 2
62650: NEG
62651: PUSH
62652: LD_INT 1
62654: NEG
62655: PUSH
62656: EMPTY
62657: LIST
62658: LIST
62659: PUSH
62660: LD_INT 2
62662: NEG
62663: PUSH
62664: LD_INT 2
62666: NEG
62667: PUSH
62668: EMPTY
62669: LIST
62670: LIST
62671: PUSH
62672: LD_INT 1
62674: NEG
62675: PUSH
62676: LD_INT 2
62678: PUSH
62679: EMPTY
62680: LIST
62681: LIST
62682: PUSH
62683: LD_INT 2
62685: NEG
62686: PUSH
62687: LD_INT 1
62689: PUSH
62690: EMPTY
62691: LIST
62692: LIST
62693: PUSH
62694: LD_INT 3
62696: NEG
62697: PUSH
62698: LD_INT 1
62700: NEG
62701: PUSH
62702: EMPTY
62703: LIST
62704: LIST
62705: PUSH
62706: LD_INT 3
62708: NEG
62709: PUSH
62710: LD_INT 2
62712: NEG
62713: PUSH
62714: EMPTY
62715: LIST
62716: LIST
62717: PUSH
62718: EMPTY
62719: LIST
62720: LIST
62721: LIST
62722: LIST
62723: LIST
62724: LIST
62725: LIST
62726: LIST
62727: LIST
62728: LIST
62729: LIST
62730: LIST
62731: LIST
62732: LIST
62733: LIST
62734: LIST
62735: LIST
62736: LIST
62737: LIST
62738: LIST
62739: LIST
62740: LIST
62741: LIST
62742: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
62743: LD_ADDR_VAR 0 28
62747: PUSH
62748: LD_INT 0
62750: PUSH
62751: LD_INT 0
62753: PUSH
62754: EMPTY
62755: LIST
62756: LIST
62757: PUSH
62758: LD_INT 0
62760: PUSH
62761: LD_INT 1
62763: NEG
62764: PUSH
62765: EMPTY
62766: LIST
62767: LIST
62768: PUSH
62769: LD_INT 1
62771: PUSH
62772: LD_INT 0
62774: PUSH
62775: EMPTY
62776: LIST
62777: LIST
62778: PUSH
62779: LD_INT 1
62781: PUSH
62782: LD_INT 1
62784: PUSH
62785: EMPTY
62786: LIST
62787: LIST
62788: PUSH
62789: LD_INT 0
62791: PUSH
62792: LD_INT 1
62794: PUSH
62795: EMPTY
62796: LIST
62797: LIST
62798: PUSH
62799: LD_INT 1
62801: NEG
62802: PUSH
62803: LD_INT 0
62805: PUSH
62806: EMPTY
62807: LIST
62808: LIST
62809: PUSH
62810: LD_INT 1
62812: NEG
62813: PUSH
62814: LD_INT 1
62816: NEG
62817: PUSH
62818: EMPTY
62819: LIST
62820: LIST
62821: PUSH
62822: LD_INT 1
62824: NEG
62825: PUSH
62826: LD_INT 2
62828: NEG
62829: PUSH
62830: EMPTY
62831: LIST
62832: LIST
62833: PUSH
62834: LD_INT 0
62836: PUSH
62837: LD_INT 2
62839: NEG
62840: PUSH
62841: EMPTY
62842: LIST
62843: LIST
62844: PUSH
62845: LD_INT 1
62847: PUSH
62848: LD_INT 1
62850: NEG
62851: PUSH
62852: EMPTY
62853: LIST
62854: LIST
62855: PUSH
62856: LD_INT 2
62858: PUSH
62859: LD_INT 0
62861: PUSH
62862: EMPTY
62863: LIST
62864: LIST
62865: PUSH
62866: LD_INT 2
62868: PUSH
62869: LD_INT 1
62871: PUSH
62872: EMPTY
62873: LIST
62874: LIST
62875: PUSH
62876: LD_INT 2
62878: PUSH
62879: LD_INT 2
62881: PUSH
62882: EMPTY
62883: LIST
62884: LIST
62885: PUSH
62886: LD_INT 1
62888: PUSH
62889: LD_INT 2
62891: PUSH
62892: EMPTY
62893: LIST
62894: LIST
62895: PUSH
62896: LD_INT 0
62898: PUSH
62899: LD_INT 2
62901: PUSH
62902: EMPTY
62903: LIST
62904: LIST
62905: PUSH
62906: LD_INT 1
62908: NEG
62909: PUSH
62910: LD_INT 1
62912: PUSH
62913: EMPTY
62914: LIST
62915: LIST
62916: PUSH
62917: LD_INT 2
62919: NEG
62920: PUSH
62921: LD_INT 0
62923: PUSH
62924: EMPTY
62925: LIST
62926: LIST
62927: PUSH
62928: LD_INT 2
62930: NEG
62931: PUSH
62932: LD_INT 1
62934: NEG
62935: PUSH
62936: EMPTY
62937: LIST
62938: LIST
62939: PUSH
62940: LD_INT 2
62942: NEG
62943: PUSH
62944: LD_INT 2
62946: NEG
62947: PUSH
62948: EMPTY
62949: LIST
62950: LIST
62951: PUSH
62952: LD_INT 2
62954: NEG
62955: PUSH
62956: LD_INT 3
62958: NEG
62959: PUSH
62960: EMPTY
62961: LIST
62962: LIST
62963: PUSH
62964: LD_INT 1
62966: NEG
62967: PUSH
62968: LD_INT 3
62970: NEG
62971: PUSH
62972: EMPTY
62973: LIST
62974: LIST
62975: PUSH
62976: LD_INT 3
62978: NEG
62979: PUSH
62980: LD_INT 1
62982: NEG
62983: PUSH
62984: EMPTY
62985: LIST
62986: LIST
62987: PUSH
62988: LD_INT 3
62990: NEG
62991: PUSH
62992: LD_INT 2
62994: NEG
62995: PUSH
62996: EMPTY
62997: LIST
62998: LIST
62999: PUSH
63000: EMPTY
63001: LIST
63002: LIST
63003: LIST
63004: LIST
63005: LIST
63006: LIST
63007: LIST
63008: LIST
63009: LIST
63010: LIST
63011: LIST
63012: LIST
63013: LIST
63014: LIST
63015: LIST
63016: LIST
63017: LIST
63018: LIST
63019: LIST
63020: LIST
63021: LIST
63022: LIST
63023: LIST
63024: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
63025: LD_ADDR_VAR 0 29
63029: PUSH
63030: LD_INT 0
63032: PUSH
63033: LD_INT 0
63035: PUSH
63036: EMPTY
63037: LIST
63038: LIST
63039: PUSH
63040: LD_INT 0
63042: PUSH
63043: LD_INT 1
63045: NEG
63046: PUSH
63047: EMPTY
63048: LIST
63049: LIST
63050: PUSH
63051: LD_INT 1
63053: PUSH
63054: LD_INT 0
63056: PUSH
63057: EMPTY
63058: LIST
63059: LIST
63060: PUSH
63061: LD_INT 1
63063: PUSH
63064: LD_INT 1
63066: PUSH
63067: EMPTY
63068: LIST
63069: LIST
63070: PUSH
63071: LD_INT 0
63073: PUSH
63074: LD_INT 1
63076: PUSH
63077: EMPTY
63078: LIST
63079: LIST
63080: PUSH
63081: LD_INT 1
63083: NEG
63084: PUSH
63085: LD_INT 0
63087: PUSH
63088: EMPTY
63089: LIST
63090: LIST
63091: PUSH
63092: LD_INT 1
63094: NEG
63095: PUSH
63096: LD_INT 1
63098: NEG
63099: PUSH
63100: EMPTY
63101: LIST
63102: LIST
63103: PUSH
63104: LD_INT 1
63106: NEG
63107: PUSH
63108: LD_INT 2
63110: NEG
63111: PUSH
63112: EMPTY
63113: LIST
63114: LIST
63115: PUSH
63116: LD_INT 0
63118: PUSH
63119: LD_INT 2
63121: NEG
63122: PUSH
63123: EMPTY
63124: LIST
63125: LIST
63126: PUSH
63127: LD_INT 1
63129: PUSH
63130: LD_INT 1
63132: NEG
63133: PUSH
63134: EMPTY
63135: LIST
63136: LIST
63137: PUSH
63138: LD_INT 2
63140: PUSH
63141: LD_INT 0
63143: PUSH
63144: EMPTY
63145: LIST
63146: LIST
63147: PUSH
63148: LD_INT 2
63150: PUSH
63151: LD_INT 1
63153: PUSH
63154: EMPTY
63155: LIST
63156: LIST
63157: PUSH
63158: LD_INT 1
63160: PUSH
63161: LD_INT 2
63163: PUSH
63164: EMPTY
63165: LIST
63166: LIST
63167: PUSH
63168: LD_INT 0
63170: PUSH
63171: LD_INT 2
63173: PUSH
63174: EMPTY
63175: LIST
63176: LIST
63177: PUSH
63178: LD_INT 1
63180: NEG
63181: PUSH
63182: LD_INT 1
63184: PUSH
63185: EMPTY
63186: LIST
63187: LIST
63188: PUSH
63189: LD_INT 2
63191: NEG
63192: PUSH
63193: LD_INT 1
63195: NEG
63196: PUSH
63197: EMPTY
63198: LIST
63199: LIST
63200: PUSH
63201: LD_INT 2
63203: NEG
63204: PUSH
63205: LD_INT 2
63207: NEG
63208: PUSH
63209: EMPTY
63210: LIST
63211: LIST
63212: PUSH
63213: LD_INT 2
63215: NEG
63216: PUSH
63217: LD_INT 3
63219: NEG
63220: PUSH
63221: EMPTY
63222: LIST
63223: LIST
63224: PUSH
63225: LD_INT 2
63227: PUSH
63228: LD_INT 1
63230: NEG
63231: PUSH
63232: EMPTY
63233: LIST
63234: LIST
63235: PUSH
63236: LD_INT 3
63238: PUSH
63239: LD_INT 1
63241: PUSH
63242: EMPTY
63243: LIST
63244: LIST
63245: PUSH
63246: LD_INT 1
63248: PUSH
63249: LD_INT 3
63251: PUSH
63252: EMPTY
63253: LIST
63254: LIST
63255: PUSH
63256: LD_INT 1
63258: NEG
63259: PUSH
63260: LD_INT 2
63262: PUSH
63263: EMPTY
63264: LIST
63265: LIST
63266: PUSH
63267: LD_INT 3
63269: NEG
63270: PUSH
63271: LD_INT 2
63273: NEG
63274: PUSH
63275: EMPTY
63276: LIST
63277: LIST
63278: PUSH
63279: EMPTY
63280: LIST
63281: LIST
63282: LIST
63283: LIST
63284: LIST
63285: LIST
63286: LIST
63287: LIST
63288: LIST
63289: LIST
63290: LIST
63291: LIST
63292: LIST
63293: LIST
63294: LIST
63295: LIST
63296: LIST
63297: LIST
63298: LIST
63299: LIST
63300: LIST
63301: LIST
63302: LIST
63303: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
63304: LD_ADDR_VAR 0 30
63308: PUSH
63309: LD_INT 0
63311: PUSH
63312: LD_INT 0
63314: PUSH
63315: EMPTY
63316: LIST
63317: LIST
63318: PUSH
63319: LD_INT 0
63321: PUSH
63322: LD_INT 1
63324: NEG
63325: PUSH
63326: EMPTY
63327: LIST
63328: LIST
63329: PUSH
63330: LD_INT 1
63332: PUSH
63333: LD_INT 0
63335: PUSH
63336: EMPTY
63337: LIST
63338: LIST
63339: PUSH
63340: LD_INT 1
63342: PUSH
63343: LD_INT 1
63345: PUSH
63346: EMPTY
63347: LIST
63348: LIST
63349: PUSH
63350: LD_INT 0
63352: PUSH
63353: LD_INT 1
63355: PUSH
63356: EMPTY
63357: LIST
63358: LIST
63359: PUSH
63360: LD_INT 1
63362: NEG
63363: PUSH
63364: LD_INT 0
63366: PUSH
63367: EMPTY
63368: LIST
63369: LIST
63370: PUSH
63371: LD_INT 1
63373: NEG
63374: PUSH
63375: LD_INT 1
63377: NEG
63378: PUSH
63379: EMPTY
63380: LIST
63381: LIST
63382: PUSH
63383: LD_INT 1
63385: NEG
63386: PUSH
63387: LD_INT 2
63389: NEG
63390: PUSH
63391: EMPTY
63392: LIST
63393: LIST
63394: PUSH
63395: LD_INT 0
63397: PUSH
63398: LD_INT 2
63400: NEG
63401: PUSH
63402: EMPTY
63403: LIST
63404: LIST
63405: PUSH
63406: LD_INT 1
63408: PUSH
63409: LD_INT 1
63411: NEG
63412: PUSH
63413: EMPTY
63414: LIST
63415: LIST
63416: PUSH
63417: LD_INT 2
63419: PUSH
63420: LD_INT 0
63422: PUSH
63423: EMPTY
63424: LIST
63425: LIST
63426: PUSH
63427: LD_INT 2
63429: PUSH
63430: LD_INT 1
63432: PUSH
63433: EMPTY
63434: LIST
63435: LIST
63436: PUSH
63437: LD_INT 2
63439: PUSH
63440: LD_INT 2
63442: PUSH
63443: EMPTY
63444: LIST
63445: LIST
63446: PUSH
63447: LD_INT 1
63449: PUSH
63450: LD_INT 2
63452: PUSH
63453: EMPTY
63454: LIST
63455: LIST
63456: PUSH
63457: LD_INT 1
63459: NEG
63460: PUSH
63461: LD_INT 1
63463: PUSH
63464: EMPTY
63465: LIST
63466: LIST
63467: PUSH
63468: LD_INT 2
63470: NEG
63471: PUSH
63472: LD_INT 0
63474: PUSH
63475: EMPTY
63476: LIST
63477: LIST
63478: PUSH
63479: LD_INT 2
63481: NEG
63482: PUSH
63483: LD_INT 1
63485: NEG
63486: PUSH
63487: EMPTY
63488: LIST
63489: LIST
63490: PUSH
63491: LD_INT 1
63493: NEG
63494: PUSH
63495: LD_INT 3
63497: NEG
63498: PUSH
63499: EMPTY
63500: LIST
63501: LIST
63502: PUSH
63503: LD_INT 1
63505: PUSH
63506: LD_INT 2
63508: NEG
63509: PUSH
63510: EMPTY
63511: LIST
63512: LIST
63513: PUSH
63514: LD_INT 3
63516: PUSH
63517: LD_INT 2
63519: PUSH
63520: EMPTY
63521: LIST
63522: LIST
63523: PUSH
63524: LD_INT 2
63526: PUSH
63527: LD_INT 3
63529: PUSH
63530: EMPTY
63531: LIST
63532: LIST
63533: PUSH
63534: LD_INT 2
63536: NEG
63537: PUSH
63538: LD_INT 1
63540: PUSH
63541: EMPTY
63542: LIST
63543: LIST
63544: PUSH
63545: LD_INT 3
63547: NEG
63548: PUSH
63549: LD_INT 1
63551: NEG
63552: PUSH
63553: EMPTY
63554: LIST
63555: LIST
63556: PUSH
63557: EMPTY
63558: LIST
63559: LIST
63560: LIST
63561: LIST
63562: LIST
63563: LIST
63564: LIST
63565: LIST
63566: LIST
63567: LIST
63568: LIST
63569: LIST
63570: LIST
63571: LIST
63572: LIST
63573: LIST
63574: LIST
63575: LIST
63576: LIST
63577: LIST
63578: LIST
63579: LIST
63580: LIST
63581: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
63582: LD_ADDR_VAR 0 31
63586: PUSH
63587: LD_INT 0
63589: PUSH
63590: LD_INT 0
63592: PUSH
63593: EMPTY
63594: LIST
63595: LIST
63596: PUSH
63597: LD_INT 0
63599: PUSH
63600: LD_INT 1
63602: NEG
63603: PUSH
63604: EMPTY
63605: LIST
63606: LIST
63607: PUSH
63608: LD_INT 1
63610: PUSH
63611: LD_INT 0
63613: PUSH
63614: EMPTY
63615: LIST
63616: LIST
63617: PUSH
63618: LD_INT 1
63620: PUSH
63621: LD_INT 1
63623: PUSH
63624: EMPTY
63625: LIST
63626: LIST
63627: PUSH
63628: LD_INT 0
63630: PUSH
63631: LD_INT 1
63633: PUSH
63634: EMPTY
63635: LIST
63636: LIST
63637: PUSH
63638: LD_INT 1
63640: NEG
63641: PUSH
63642: LD_INT 0
63644: PUSH
63645: EMPTY
63646: LIST
63647: LIST
63648: PUSH
63649: LD_INT 1
63651: NEG
63652: PUSH
63653: LD_INT 1
63655: NEG
63656: PUSH
63657: EMPTY
63658: LIST
63659: LIST
63660: PUSH
63661: LD_INT 1
63663: NEG
63664: PUSH
63665: LD_INT 2
63667: NEG
63668: PUSH
63669: EMPTY
63670: LIST
63671: LIST
63672: PUSH
63673: LD_INT 1
63675: PUSH
63676: LD_INT 1
63678: NEG
63679: PUSH
63680: EMPTY
63681: LIST
63682: LIST
63683: PUSH
63684: LD_INT 2
63686: PUSH
63687: LD_INT 0
63689: PUSH
63690: EMPTY
63691: LIST
63692: LIST
63693: PUSH
63694: LD_INT 2
63696: PUSH
63697: LD_INT 1
63699: PUSH
63700: EMPTY
63701: LIST
63702: LIST
63703: PUSH
63704: LD_INT 2
63706: PUSH
63707: LD_INT 2
63709: PUSH
63710: EMPTY
63711: LIST
63712: LIST
63713: PUSH
63714: LD_INT 1
63716: PUSH
63717: LD_INT 2
63719: PUSH
63720: EMPTY
63721: LIST
63722: LIST
63723: PUSH
63724: LD_INT 0
63726: PUSH
63727: LD_INT 2
63729: PUSH
63730: EMPTY
63731: LIST
63732: LIST
63733: PUSH
63734: LD_INT 1
63736: NEG
63737: PUSH
63738: LD_INT 1
63740: PUSH
63741: EMPTY
63742: LIST
63743: LIST
63744: PUSH
63745: LD_INT 2
63747: NEG
63748: PUSH
63749: LD_INT 1
63751: NEG
63752: PUSH
63753: EMPTY
63754: LIST
63755: LIST
63756: PUSH
63757: LD_INT 2
63759: NEG
63760: PUSH
63761: LD_INT 2
63763: NEG
63764: PUSH
63765: EMPTY
63766: LIST
63767: LIST
63768: PUSH
63769: LD_INT 2
63771: NEG
63772: PUSH
63773: LD_INT 3
63775: NEG
63776: PUSH
63777: EMPTY
63778: LIST
63779: LIST
63780: PUSH
63781: LD_INT 2
63783: PUSH
63784: LD_INT 1
63786: NEG
63787: PUSH
63788: EMPTY
63789: LIST
63790: LIST
63791: PUSH
63792: LD_INT 3
63794: PUSH
63795: LD_INT 1
63797: PUSH
63798: EMPTY
63799: LIST
63800: LIST
63801: PUSH
63802: LD_INT 1
63804: PUSH
63805: LD_INT 3
63807: PUSH
63808: EMPTY
63809: LIST
63810: LIST
63811: PUSH
63812: LD_INT 1
63814: NEG
63815: PUSH
63816: LD_INT 2
63818: PUSH
63819: EMPTY
63820: LIST
63821: LIST
63822: PUSH
63823: LD_INT 3
63825: NEG
63826: PUSH
63827: LD_INT 2
63829: NEG
63830: PUSH
63831: EMPTY
63832: LIST
63833: LIST
63834: PUSH
63835: EMPTY
63836: LIST
63837: LIST
63838: LIST
63839: LIST
63840: LIST
63841: LIST
63842: LIST
63843: LIST
63844: LIST
63845: LIST
63846: LIST
63847: LIST
63848: LIST
63849: LIST
63850: LIST
63851: LIST
63852: LIST
63853: LIST
63854: LIST
63855: LIST
63856: LIST
63857: LIST
63858: LIST
63859: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
63860: LD_ADDR_VAR 0 32
63864: PUSH
63865: LD_INT 0
63867: PUSH
63868: LD_INT 0
63870: PUSH
63871: EMPTY
63872: LIST
63873: LIST
63874: PUSH
63875: LD_INT 0
63877: PUSH
63878: LD_INT 1
63880: NEG
63881: PUSH
63882: EMPTY
63883: LIST
63884: LIST
63885: PUSH
63886: LD_INT 1
63888: PUSH
63889: LD_INT 0
63891: PUSH
63892: EMPTY
63893: LIST
63894: LIST
63895: PUSH
63896: LD_INT 1
63898: PUSH
63899: LD_INT 1
63901: PUSH
63902: EMPTY
63903: LIST
63904: LIST
63905: PUSH
63906: LD_INT 0
63908: PUSH
63909: LD_INT 1
63911: PUSH
63912: EMPTY
63913: LIST
63914: LIST
63915: PUSH
63916: LD_INT 1
63918: NEG
63919: PUSH
63920: LD_INT 0
63922: PUSH
63923: EMPTY
63924: LIST
63925: LIST
63926: PUSH
63927: LD_INT 1
63929: NEG
63930: PUSH
63931: LD_INT 1
63933: NEG
63934: PUSH
63935: EMPTY
63936: LIST
63937: LIST
63938: PUSH
63939: LD_INT 1
63941: NEG
63942: PUSH
63943: LD_INT 2
63945: NEG
63946: PUSH
63947: EMPTY
63948: LIST
63949: LIST
63950: PUSH
63951: LD_INT 0
63953: PUSH
63954: LD_INT 2
63956: NEG
63957: PUSH
63958: EMPTY
63959: LIST
63960: LIST
63961: PUSH
63962: LD_INT 1
63964: PUSH
63965: LD_INT 1
63967: NEG
63968: PUSH
63969: EMPTY
63970: LIST
63971: LIST
63972: PUSH
63973: LD_INT 2
63975: PUSH
63976: LD_INT 1
63978: PUSH
63979: EMPTY
63980: LIST
63981: LIST
63982: PUSH
63983: LD_INT 2
63985: PUSH
63986: LD_INT 2
63988: PUSH
63989: EMPTY
63990: LIST
63991: LIST
63992: PUSH
63993: LD_INT 1
63995: PUSH
63996: LD_INT 2
63998: PUSH
63999: EMPTY
64000: LIST
64001: LIST
64002: PUSH
64003: LD_INT 0
64005: PUSH
64006: LD_INT 2
64008: PUSH
64009: EMPTY
64010: LIST
64011: LIST
64012: PUSH
64013: LD_INT 1
64015: NEG
64016: PUSH
64017: LD_INT 1
64019: PUSH
64020: EMPTY
64021: LIST
64022: LIST
64023: PUSH
64024: LD_INT 2
64026: NEG
64027: PUSH
64028: LD_INT 0
64030: PUSH
64031: EMPTY
64032: LIST
64033: LIST
64034: PUSH
64035: LD_INT 2
64037: NEG
64038: PUSH
64039: LD_INT 1
64041: NEG
64042: PUSH
64043: EMPTY
64044: LIST
64045: LIST
64046: PUSH
64047: LD_INT 1
64049: NEG
64050: PUSH
64051: LD_INT 3
64053: NEG
64054: PUSH
64055: EMPTY
64056: LIST
64057: LIST
64058: PUSH
64059: LD_INT 1
64061: PUSH
64062: LD_INT 2
64064: NEG
64065: PUSH
64066: EMPTY
64067: LIST
64068: LIST
64069: PUSH
64070: LD_INT 3
64072: PUSH
64073: LD_INT 2
64075: PUSH
64076: EMPTY
64077: LIST
64078: LIST
64079: PUSH
64080: LD_INT 2
64082: PUSH
64083: LD_INT 3
64085: PUSH
64086: EMPTY
64087: LIST
64088: LIST
64089: PUSH
64090: LD_INT 2
64092: NEG
64093: PUSH
64094: LD_INT 1
64096: PUSH
64097: EMPTY
64098: LIST
64099: LIST
64100: PUSH
64101: LD_INT 3
64103: NEG
64104: PUSH
64105: LD_INT 1
64107: NEG
64108: PUSH
64109: EMPTY
64110: LIST
64111: LIST
64112: PUSH
64113: EMPTY
64114: LIST
64115: LIST
64116: LIST
64117: LIST
64118: LIST
64119: LIST
64120: LIST
64121: LIST
64122: LIST
64123: LIST
64124: LIST
64125: LIST
64126: LIST
64127: LIST
64128: LIST
64129: LIST
64130: LIST
64131: LIST
64132: LIST
64133: LIST
64134: LIST
64135: LIST
64136: LIST
64137: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
64138: LD_ADDR_VAR 0 33
64142: PUSH
64143: LD_INT 0
64145: PUSH
64146: LD_INT 0
64148: PUSH
64149: EMPTY
64150: LIST
64151: LIST
64152: PUSH
64153: LD_INT 0
64155: PUSH
64156: LD_INT 1
64158: NEG
64159: PUSH
64160: EMPTY
64161: LIST
64162: LIST
64163: PUSH
64164: LD_INT 1
64166: PUSH
64167: LD_INT 0
64169: PUSH
64170: EMPTY
64171: LIST
64172: LIST
64173: PUSH
64174: LD_INT 1
64176: PUSH
64177: LD_INT 1
64179: PUSH
64180: EMPTY
64181: LIST
64182: LIST
64183: PUSH
64184: LD_INT 0
64186: PUSH
64187: LD_INT 1
64189: PUSH
64190: EMPTY
64191: LIST
64192: LIST
64193: PUSH
64194: LD_INT 1
64196: NEG
64197: PUSH
64198: LD_INT 0
64200: PUSH
64201: EMPTY
64202: LIST
64203: LIST
64204: PUSH
64205: LD_INT 1
64207: NEG
64208: PUSH
64209: LD_INT 1
64211: NEG
64212: PUSH
64213: EMPTY
64214: LIST
64215: LIST
64216: PUSH
64217: LD_INT 1
64219: NEG
64220: PUSH
64221: LD_INT 2
64223: NEG
64224: PUSH
64225: EMPTY
64226: LIST
64227: LIST
64228: PUSH
64229: LD_INT 1
64231: PUSH
64232: LD_INT 1
64234: NEG
64235: PUSH
64236: EMPTY
64237: LIST
64238: LIST
64239: PUSH
64240: LD_INT 2
64242: PUSH
64243: LD_INT 0
64245: PUSH
64246: EMPTY
64247: LIST
64248: LIST
64249: PUSH
64250: LD_INT 2
64252: PUSH
64253: LD_INT 1
64255: PUSH
64256: EMPTY
64257: LIST
64258: LIST
64259: PUSH
64260: LD_INT 1
64262: PUSH
64263: LD_INT 2
64265: PUSH
64266: EMPTY
64267: LIST
64268: LIST
64269: PUSH
64270: LD_INT 0
64272: PUSH
64273: LD_INT 2
64275: PUSH
64276: EMPTY
64277: LIST
64278: LIST
64279: PUSH
64280: LD_INT 1
64282: NEG
64283: PUSH
64284: LD_INT 1
64286: PUSH
64287: EMPTY
64288: LIST
64289: LIST
64290: PUSH
64291: LD_INT 2
64293: NEG
64294: PUSH
64295: LD_INT 0
64297: PUSH
64298: EMPTY
64299: LIST
64300: LIST
64301: PUSH
64302: LD_INT 2
64304: NEG
64305: PUSH
64306: LD_INT 1
64308: NEG
64309: PUSH
64310: EMPTY
64311: LIST
64312: LIST
64313: PUSH
64314: LD_INT 2
64316: NEG
64317: PUSH
64318: LD_INT 2
64320: NEG
64321: PUSH
64322: EMPTY
64323: LIST
64324: LIST
64325: PUSH
64326: LD_INT 2
64328: NEG
64329: PUSH
64330: LD_INT 3
64332: NEG
64333: PUSH
64334: EMPTY
64335: LIST
64336: LIST
64337: PUSH
64338: LD_INT 2
64340: PUSH
64341: LD_INT 1
64343: NEG
64344: PUSH
64345: EMPTY
64346: LIST
64347: LIST
64348: PUSH
64349: LD_INT 3
64351: PUSH
64352: LD_INT 1
64354: PUSH
64355: EMPTY
64356: LIST
64357: LIST
64358: PUSH
64359: LD_INT 1
64361: PUSH
64362: LD_INT 3
64364: PUSH
64365: EMPTY
64366: LIST
64367: LIST
64368: PUSH
64369: LD_INT 1
64371: NEG
64372: PUSH
64373: LD_INT 2
64375: PUSH
64376: EMPTY
64377: LIST
64378: LIST
64379: PUSH
64380: LD_INT 3
64382: NEG
64383: PUSH
64384: LD_INT 2
64386: NEG
64387: PUSH
64388: EMPTY
64389: LIST
64390: LIST
64391: PUSH
64392: EMPTY
64393: LIST
64394: LIST
64395: LIST
64396: LIST
64397: LIST
64398: LIST
64399: LIST
64400: LIST
64401: LIST
64402: LIST
64403: LIST
64404: LIST
64405: LIST
64406: LIST
64407: LIST
64408: LIST
64409: LIST
64410: LIST
64411: LIST
64412: LIST
64413: LIST
64414: LIST
64415: LIST
64416: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
64417: LD_ADDR_VAR 0 34
64421: PUSH
64422: LD_INT 0
64424: PUSH
64425: LD_INT 0
64427: PUSH
64428: EMPTY
64429: LIST
64430: LIST
64431: PUSH
64432: LD_INT 0
64434: PUSH
64435: LD_INT 1
64437: NEG
64438: PUSH
64439: EMPTY
64440: LIST
64441: LIST
64442: PUSH
64443: LD_INT 1
64445: PUSH
64446: LD_INT 0
64448: PUSH
64449: EMPTY
64450: LIST
64451: LIST
64452: PUSH
64453: LD_INT 1
64455: PUSH
64456: LD_INT 1
64458: PUSH
64459: EMPTY
64460: LIST
64461: LIST
64462: PUSH
64463: LD_INT 0
64465: PUSH
64466: LD_INT 1
64468: PUSH
64469: EMPTY
64470: LIST
64471: LIST
64472: PUSH
64473: LD_INT 1
64475: NEG
64476: PUSH
64477: LD_INT 0
64479: PUSH
64480: EMPTY
64481: LIST
64482: LIST
64483: PUSH
64484: LD_INT 1
64486: NEG
64487: PUSH
64488: LD_INT 1
64490: NEG
64491: PUSH
64492: EMPTY
64493: LIST
64494: LIST
64495: PUSH
64496: LD_INT 1
64498: NEG
64499: PUSH
64500: LD_INT 2
64502: NEG
64503: PUSH
64504: EMPTY
64505: LIST
64506: LIST
64507: PUSH
64508: LD_INT 0
64510: PUSH
64511: LD_INT 2
64513: NEG
64514: PUSH
64515: EMPTY
64516: LIST
64517: LIST
64518: PUSH
64519: LD_INT 1
64521: PUSH
64522: LD_INT 1
64524: NEG
64525: PUSH
64526: EMPTY
64527: LIST
64528: LIST
64529: PUSH
64530: LD_INT 2
64532: PUSH
64533: LD_INT 1
64535: PUSH
64536: EMPTY
64537: LIST
64538: LIST
64539: PUSH
64540: LD_INT 2
64542: PUSH
64543: LD_INT 2
64545: PUSH
64546: EMPTY
64547: LIST
64548: LIST
64549: PUSH
64550: LD_INT 1
64552: PUSH
64553: LD_INT 2
64555: PUSH
64556: EMPTY
64557: LIST
64558: LIST
64559: PUSH
64560: LD_INT 1
64562: NEG
64563: PUSH
64564: LD_INT 1
64566: PUSH
64567: EMPTY
64568: LIST
64569: LIST
64570: PUSH
64571: LD_INT 2
64573: NEG
64574: PUSH
64575: LD_INT 0
64577: PUSH
64578: EMPTY
64579: LIST
64580: LIST
64581: PUSH
64582: LD_INT 2
64584: NEG
64585: PUSH
64586: LD_INT 1
64588: NEG
64589: PUSH
64590: EMPTY
64591: LIST
64592: LIST
64593: PUSH
64594: LD_INT 2
64596: NEG
64597: PUSH
64598: LD_INT 2
64600: NEG
64601: PUSH
64602: EMPTY
64603: LIST
64604: LIST
64605: PUSH
64606: LD_INT 1
64608: NEG
64609: PUSH
64610: LD_INT 3
64612: NEG
64613: PUSH
64614: EMPTY
64615: LIST
64616: LIST
64617: PUSH
64618: LD_INT 1
64620: PUSH
64621: LD_INT 2
64623: NEG
64624: PUSH
64625: EMPTY
64626: LIST
64627: LIST
64628: PUSH
64629: LD_INT 3
64631: PUSH
64632: LD_INT 2
64634: PUSH
64635: EMPTY
64636: LIST
64637: LIST
64638: PUSH
64639: LD_INT 2
64641: PUSH
64642: LD_INT 3
64644: PUSH
64645: EMPTY
64646: LIST
64647: LIST
64648: PUSH
64649: LD_INT 2
64651: NEG
64652: PUSH
64653: LD_INT 1
64655: PUSH
64656: EMPTY
64657: LIST
64658: LIST
64659: PUSH
64660: LD_INT 3
64662: NEG
64663: PUSH
64664: LD_INT 1
64666: NEG
64667: PUSH
64668: EMPTY
64669: LIST
64670: LIST
64671: PUSH
64672: EMPTY
64673: LIST
64674: LIST
64675: LIST
64676: LIST
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: LIST
64682: LIST
64683: LIST
64684: LIST
64685: LIST
64686: LIST
64687: LIST
64688: LIST
64689: LIST
64690: LIST
64691: LIST
64692: LIST
64693: LIST
64694: LIST
64695: LIST
64696: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
64697: LD_ADDR_VAR 0 35
64701: PUSH
64702: LD_INT 0
64704: PUSH
64705: LD_INT 0
64707: PUSH
64708: EMPTY
64709: LIST
64710: LIST
64711: PUSH
64712: LD_INT 0
64714: PUSH
64715: LD_INT 1
64717: NEG
64718: PUSH
64719: EMPTY
64720: LIST
64721: LIST
64722: PUSH
64723: LD_INT 1
64725: PUSH
64726: LD_INT 0
64728: PUSH
64729: EMPTY
64730: LIST
64731: LIST
64732: PUSH
64733: LD_INT 1
64735: PUSH
64736: LD_INT 1
64738: PUSH
64739: EMPTY
64740: LIST
64741: LIST
64742: PUSH
64743: LD_INT 0
64745: PUSH
64746: LD_INT 1
64748: PUSH
64749: EMPTY
64750: LIST
64751: LIST
64752: PUSH
64753: LD_INT 1
64755: NEG
64756: PUSH
64757: LD_INT 0
64759: PUSH
64760: EMPTY
64761: LIST
64762: LIST
64763: PUSH
64764: LD_INT 1
64766: NEG
64767: PUSH
64768: LD_INT 1
64770: NEG
64771: PUSH
64772: EMPTY
64773: LIST
64774: LIST
64775: PUSH
64776: LD_INT 2
64778: PUSH
64779: LD_INT 1
64781: PUSH
64782: EMPTY
64783: LIST
64784: LIST
64785: PUSH
64786: LD_INT 2
64788: NEG
64789: PUSH
64790: LD_INT 1
64792: NEG
64793: PUSH
64794: EMPTY
64795: LIST
64796: LIST
64797: PUSH
64798: EMPTY
64799: LIST
64800: LIST
64801: LIST
64802: LIST
64803: LIST
64804: LIST
64805: LIST
64806: LIST
64807: LIST
64808: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
64809: LD_ADDR_VAR 0 36
64813: PUSH
64814: LD_INT 0
64816: PUSH
64817: LD_INT 0
64819: PUSH
64820: EMPTY
64821: LIST
64822: LIST
64823: PUSH
64824: LD_INT 0
64826: PUSH
64827: LD_INT 1
64829: NEG
64830: PUSH
64831: EMPTY
64832: LIST
64833: LIST
64834: PUSH
64835: LD_INT 1
64837: PUSH
64838: LD_INT 0
64840: PUSH
64841: EMPTY
64842: LIST
64843: LIST
64844: PUSH
64845: LD_INT 1
64847: PUSH
64848: LD_INT 1
64850: PUSH
64851: EMPTY
64852: LIST
64853: LIST
64854: PUSH
64855: LD_INT 0
64857: PUSH
64858: LD_INT 1
64860: PUSH
64861: EMPTY
64862: LIST
64863: LIST
64864: PUSH
64865: LD_INT 1
64867: NEG
64868: PUSH
64869: LD_INT 0
64871: PUSH
64872: EMPTY
64873: LIST
64874: LIST
64875: PUSH
64876: LD_INT 1
64878: NEG
64879: PUSH
64880: LD_INT 1
64882: NEG
64883: PUSH
64884: EMPTY
64885: LIST
64886: LIST
64887: PUSH
64888: LD_INT 1
64890: NEG
64891: PUSH
64892: LD_INT 2
64894: NEG
64895: PUSH
64896: EMPTY
64897: LIST
64898: LIST
64899: PUSH
64900: LD_INT 1
64902: PUSH
64903: LD_INT 2
64905: PUSH
64906: EMPTY
64907: LIST
64908: LIST
64909: PUSH
64910: EMPTY
64911: LIST
64912: LIST
64913: LIST
64914: LIST
64915: LIST
64916: LIST
64917: LIST
64918: LIST
64919: LIST
64920: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
64921: LD_ADDR_VAR 0 37
64925: PUSH
64926: LD_INT 0
64928: PUSH
64929: LD_INT 0
64931: PUSH
64932: EMPTY
64933: LIST
64934: LIST
64935: PUSH
64936: LD_INT 0
64938: PUSH
64939: LD_INT 1
64941: NEG
64942: PUSH
64943: EMPTY
64944: LIST
64945: LIST
64946: PUSH
64947: LD_INT 1
64949: PUSH
64950: LD_INT 0
64952: PUSH
64953: EMPTY
64954: LIST
64955: LIST
64956: PUSH
64957: LD_INT 1
64959: PUSH
64960: LD_INT 1
64962: PUSH
64963: EMPTY
64964: LIST
64965: LIST
64966: PUSH
64967: LD_INT 0
64969: PUSH
64970: LD_INT 1
64972: PUSH
64973: EMPTY
64974: LIST
64975: LIST
64976: PUSH
64977: LD_INT 1
64979: NEG
64980: PUSH
64981: LD_INT 0
64983: PUSH
64984: EMPTY
64985: LIST
64986: LIST
64987: PUSH
64988: LD_INT 1
64990: NEG
64991: PUSH
64992: LD_INT 1
64994: NEG
64995: PUSH
64996: EMPTY
64997: LIST
64998: LIST
64999: PUSH
65000: LD_INT 1
65002: PUSH
65003: LD_INT 1
65005: NEG
65006: PUSH
65007: EMPTY
65008: LIST
65009: LIST
65010: PUSH
65011: LD_INT 1
65013: NEG
65014: PUSH
65015: LD_INT 1
65017: PUSH
65018: EMPTY
65019: LIST
65020: LIST
65021: PUSH
65022: EMPTY
65023: LIST
65024: LIST
65025: LIST
65026: LIST
65027: LIST
65028: LIST
65029: LIST
65030: LIST
65031: LIST
65032: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
65033: LD_ADDR_VAR 0 38
65037: PUSH
65038: LD_INT 0
65040: PUSH
65041: LD_INT 0
65043: PUSH
65044: EMPTY
65045: LIST
65046: LIST
65047: PUSH
65048: LD_INT 0
65050: PUSH
65051: LD_INT 1
65053: NEG
65054: PUSH
65055: EMPTY
65056: LIST
65057: LIST
65058: PUSH
65059: LD_INT 1
65061: PUSH
65062: LD_INT 0
65064: PUSH
65065: EMPTY
65066: LIST
65067: LIST
65068: PUSH
65069: LD_INT 1
65071: PUSH
65072: LD_INT 1
65074: PUSH
65075: EMPTY
65076: LIST
65077: LIST
65078: PUSH
65079: LD_INT 0
65081: PUSH
65082: LD_INT 1
65084: PUSH
65085: EMPTY
65086: LIST
65087: LIST
65088: PUSH
65089: LD_INT 1
65091: NEG
65092: PUSH
65093: LD_INT 0
65095: PUSH
65096: EMPTY
65097: LIST
65098: LIST
65099: PUSH
65100: LD_INT 1
65102: NEG
65103: PUSH
65104: LD_INT 1
65106: NEG
65107: PUSH
65108: EMPTY
65109: LIST
65110: LIST
65111: PUSH
65112: LD_INT 2
65114: PUSH
65115: LD_INT 1
65117: PUSH
65118: EMPTY
65119: LIST
65120: LIST
65121: PUSH
65122: LD_INT 2
65124: NEG
65125: PUSH
65126: LD_INT 1
65128: NEG
65129: PUSH
65130: EMPTY
65131: LIST
65132: LIST
65133: PUSH
65134: EMPTY
65135: LIST
65136: LIST
65137: LIST
65138: LIST
65139: LIST
65140: LIST
65141: LIST
65142: LIST
65143: LIST
65144: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
65145: LD_ADDR_VAR 0 39
65149: PUSH
65150: LD_INT 0
65152: PUSH
65153: LD_INT 0
65155: PUSH
65156: EMPTY
65157: LIST
65158: LIST
65159: PUSH
65160: LD_INT 0
65162: PUSH
65163: LD_INT 1
65165: NEG
65166: PUSH
65167: EMPTY
65168: LIST
65169: LIST
65170: PUSH
65171: LD_INT 1
65173: PUSH
65174: LD_INT 0
65176: PUSH
65177: EMPTY
65178: LIST
65179: LIST
65180: PUSH
65181: LD_INT 1
65183: PUSH
65184: LD_INT 1
65186: PUSH
65187: EMPTY
65188: LIST
65189: LIST
65190: PUSH
65191: LD_INT 0
65193: PUSH
65194: LD_INT 1
65196: PUSH
65197: EMPTY
65198: LIST
65199: LIST
65200: PUSH
65201: LD_INT 1
65203: NEG
65204: PUSH
65205: LD_INT 0
65207: PUSH
65208: EMPTY
65209: LIST
65210: LIST
65211: PUSH
65212: LD_INT 1
65214: NEG
65215: PUSH
65216: LD_INT 1
65218: NEG
65219: PUSH
65220: EMPTY
65221: LIST
65222: LIST
65223: PUSH
65224: LD_INT 1
65226: NEG
65227: PUSH
65228: LD_INT 2
65230: NEG
65231: PUSH
65232: EMPTY
65233: LIST
65234: LIST
65235: PUSH
65236: LD_INT 1
65238: PUSH
65239: LD_INT 2
65241: PUSH
65242: EMPTY
65243: LIST
65244: LIST
65245: PUSH
65246: EMPTY
65247: LIST
65248: LIST
65249: LIST
65250: LIST
65251: LIST
65252: LIST
65253: LIST
65254: LIST
65255: LIST
65256: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
65257: LD_ADDR_VAR 0 40
65261: PUSH
65262: LD_INT 0
65264: PUSH
65265: LD_INT 0
65267: PUSH
65268: EMPTY
65269: LIST
65270: LIST
65271: PUSH
65272: LD_INT 0
65274: PUSH
65275: LD_INT 1
65277: NEG
65278: PUSH
65279: EMPTY
65280: LIST
65281: LIST
65282: PUSH
65283: LD_INT 1
65285: PUSH
65286: LD_INT 0
65288: PUSH
65289: EMPTY
65290: LIST
65291: LIST
65292: PUSH
65293: LD_INT 1
65295: PUSH
65296: LD_INT 1
65298: PUSH
65299: EMPTY
65300: LIST
65301: LIST
65302: PUSH
65303: LD_INT 0
65305: PUSH
65306: LD_INT 1
65308: PUSH
65309: EMPTY
65310: LIST
65311: LIST
65312: PUSH
65313: LD_INT 1
65315: NEG
65316: PUSH
65317: LD_INT 0
65319: PUSH
65320: EMPTY
65321: LIST
65322: LIST
65323: PUSH
65324: LD_INT 1
65326: NEG
65327: PUSH
65328: LD_INT 1
65330: NEG
65331: PUSH
65332: EMPTY
65333: LIST
65334: LIST
65335: PUSH
65336: LD_INT 1
65338: PUSH
65339: LD_INT 1
65341: NEG
65342: PUSH
65343: EMPTY
65344: LIST
65345: LIST
65346: PUSH
65347: LD_INT 1
65349: NEG
65350: PUSH
65351: LD_INT 1
65353: PUSH
65354: EMPTY
65355: LIST
65356: LIST
65357: PUSH
65358: EMPTY
65359: LIST
65360: LIST
65361: LIST
65362: LIST
65363: LIST
65364: LIST
65365: LIST
65366: LIST
65367: LIST
65368: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
65369: LD_ADDR_VAR 0 41
65373: PUSH
65374: LD_INT 0
65376: PUSH
65377: LD_INT 0
65379: PUSH
65380: EMPTY
65381: LIST
65382: LIST
65383: PUSH
65384: LD_INT 0
65386: PUSH
65387: LD_INT 1
65389: NEG
65390: PUSH
65391: EMPTY
65392: LIST
65393: LIST
65394: PUSH
65395: LD_INT 1
65397: PUSH
65398: LD_INT 0
65400: PUSH
65401: EMPTY
65402: LIST
65403: LIST
65404: PUSH
65405: LD_INT 1
65407: PUSH
65408: LD_INT 1
65410: PUSH
65411: EMPTY
65412: LIST
65413: LIST
65414: PUSH
65415: LD_INT 0
65417: PUSH
65418: LD_INT 1
65420: PUSH
65421: EMPTY
65422: LIST
65423: LIST
65424: PUSH
65425: LD_INT 1
65427: NEG
65428: PUSH
65429: LD_INT 0
65431: PUSH
65432: EMPTY
65433: LIST
65434: LIST
65435: PUSH
65436: LD_INT 1
65438: NEG
65439: PUSH
65440: LD_INT 1
65442: NEG
65443: PUSH
65444: EMPTY
65445: LIST
65446: LIST
65447: PUSH
65448: LD_INT 1
65450: NEG
65451: PUSH
65452: LD_INT 2
65454: NEG
65455: PUSH
65456: EMPTY
65457: LIST
65458: LIST
65459: PUSH
65460: LD_INT 1
65462: PUSH
65463: LD_INT 1
65465: NEG
65466: PUSH
65467: EMPTY
65468: LIST
65469: LIST
65470: PUSH
65471: LD_INT 2
65473: PUSH
65474: LD_INT 0
65476: PUSH
65477: EMPTY
65478: LIST
65479: LIST
65480: PUSH
65481: LD_INT 2
65483: PUSH
65484: LD_INT 1
65486: PUSH
65487: EMPTY
65488: LIST
65489: LIST
65490: PUSH
65491: LD_INT 2
65493: PUSH
65494: LD_INT 2
65496: PUSH
65497: EMPTY
65498: LIST
65499: LIST
65500: PUSH
65501: LD_INT 1
65503: PUSH
65504: LD_INT 2
65506: PUSH
65507: EMPTY
65508: LIST
65509: LIST
65510: PUSH
65511: LD_INT 1
65513: NEG
65514: PUSH
65515: LD_INT 1
65517: PUSH
65518: EMPTY
65519: LIST
65520: LIST
65521: PUSH
65522: LD_INT 2
65524: NEG
65525: PUSH
65526: LD_INT 0
65528: PUSH
65529: EMPTY
65530: LIST
65531: LIST
65532: PUSH
65533: LD_INT 2
65535: NEG
65536: PUSH
65537: LD_INT 1
65539: NEG
65540: PUSH
65541: EMPTY
65542: LIST
65543: LIST
65544: PUSH
65545: LD_INT 2
65547: NEG
65548: PUSH
65549: LD_INT 2
65551: NEG
65552: PUSH
65553: EMPTY
65554: LIST
65555: LIST
65556: PUSH
65557: LD_INT 2
65559: NEG
65560: PUSH
65561: LD_INT 3
65563: NEG
65564: PUSH
65565: EMPTY
65566: LIST
65567: LIST
65568: PUSH
65569: LD_INT 2
65571: PUSH
65572: LD_INT 1
65574: NEG
65575: PUSH
65576: EMPTY
65577: LIST
65578: LIST
65579: PUSH
65580: LD_INT 3
65582: PUSH
65583: LD_INT 0
65585: PUSH
65586: EMPTY
65587: LIST
65588: LIST
65589: PUSH
65590: LD_INT 3
65592: PUSH
65593: LD_INT 1
65595: PUSH
65596: EMPTY
65597: LIST
65598: LIST
65599: PUSH
65600: LD_INT 3
65602: PUSH
65603: LD_INT 2
65605: PUSH
65606: EMPTY
65607: LIST
65608: LIST
65609: PUSH
65610: LD_INT 3
65612: PUSH
65613: LD_INT 3
65615: PUSH
65616: EMPTY
65617: LIST
65618: LIST
65619: PUSH
65620: LD_INT 2
65622: PUSH
65623: LD_INT 3
65625: PUSH
65626: EMPTY
65627: LIST
65628: LIST
65629: PUSH
65630: LD_INT 2
65632: NEG
65633: PUSH
65634: LD_INT 1
65636: PUSH
65637: EMPTY
65638: LIST
65639: LIST
65640: PUSH
65641: LD_INT 3
65643: NEG
65644: PUSH
65645: LD_INT 0
65647: PUSH
65648: EMPTY
65649: LIST
65650: LIST
65651: PUSH
65652: LD_INT 3
65654: NEG
65655: PUSH
65656: LD_INT 1
65658: NEG
65659: PUSH
65660: EMPTY
65661: LIST
65662: LIST
65663: PUSH
65664: LD_INT 3
65666: NEG
65667: PUSH
65668: LD_INT 2
65670: NEG
65671: PUSH
65672: EMPTY
65673: LIST
65674: LIST
65675: PUSH
65676: LD_INT 3
65678: NEG
65679: PUSH
65680: LD_INT 3
65682: NEG
65683: PUSH
65684: EMPTY
65685: LIST
65686: LIST
65687: PUSH
65688: EMPTY
65689: LIST
65690: LIST
65691: LIST
65692: LIST
65693: LIST
65694: LIST
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: LIST
65701: LIST
65702: LIST
65703: LIST
65704: LIST
65705: LIST
65706: LIST
65707: LIST
65708: LIST
65709: LIST
65710: LIST
65711: LIST
65712: LIST
65713: LIST
65714: LIST
65715: LIST
65716: LIST
65717: LIST
65718: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
65719: LD_ADDR_VAR 0 42
65723: PUSH
65724: LD_INT 0
65726: PUSH
65727: LD_INT 0
65729: PUSH
65730: EMPTY
65731: LIST
65732: LIST
65733: PUSH
65734: LD_INT 0
65736: PUSH
65737: LD_INT 1
65739: NEG
65740: PUSH
65741: EMPTY
65742: LIST
65743: LIST
65744: PUSH
65745: LD_INT 1
65747: PUSH
65748: LD_INT 0
65750: PUSH
65751: EMPTY
65752: LIST
65753: LIST
65754: PUSH
65755: LD_INT 1
65757: PUSH
65758: LD_INT 1
65760: PUSH
65761: EMPTY
65762: LIST
65763: LIST
65764: PUSH
65765: LD_INT 0
65767: PUSH
65768: LD_INT 1
65770: PUSH
65771: EMPTY
65772: LIST
65773: LIST
65774: PUSH
65775: LD_INT 1
65777: NEG
65778: PUSH
65779: LD_INT 0
65781: PUSH
65782: EMPTY
65783: LIST
65784: LIST
65785: PUSH
65786: LD_INT 1
65788: NEG
65789: PUSH
65790: LD_INT 1
65792: NEG
65793: PUSH
65794: EMPTY
65795: LIST
65796: LIST
65797: PUSH
65798: LD_INT 1
65800: NEG
65801: PUSH
65802: LD_INT 2
65804: NEG
65805: PUSH
65806: EMPTY
65807: LIST
65808: LIST
65809: PUSH
65810: LD_INT 0
65812: PUSH
65813: LD_INT 2
65815: NEG
65816: PUSH
65817: EMPTY
65818: LIST
65819: LIST
65820: PUSH
65821: LD_INT 1
65823: PUSH
65824: LD_INT 1
65826: NEG
65827: PUSH
65828: EMPTY
65829: LIST
65830: LIST
65831: PUSH
65832: LD_INT 2
65834: PUSH
65835: LD_INT 1
65837: PUSH
65838: EMPTY
65839: LIST
65840: LIST
65841: PUSH
65842: LD_INT 2
65844: PUSH
65845: LD_INT 2
65847: PUSH
65848: EMPTY
65849: LIST
65850: LIST
65851: PUSH
65852: LD_INT 1
65854: PUSH
65855: LD_INT 2
65857: PUSH
65858: EMPTY
65859: LIST
65860: LIST
65861: PUSH
65862: LD_INT 0
65864: PUSH
65865: LD_INT 2
65867: PUSH
65868: EMPTY
65869: LIST
65870: LIST
65871: PUSH
65872: LD_INT 1
65874: NEG
65875: PUSH
65876: LD_INT 1
65878: PUSH
65879: EMPTY
65880: LIST
65881: LIST
65882: PUSH
65883: LD_INT 2
65885: NEG
65886: PUSH
65887: LD_INT 1
65889: NEG
65890: PUSH
65891: EMPTY
65892: LIST
65893: LIST
65894: PUSH
65895: LD_INT 2
65897: NEG
65898: PUSH
65899: LD_INT 2
65901: NEG
65902: PUSH
65903: EMPTY
65904: LIST
65905: LIST
65906: PUSH
65907: LD_INT 2
65909: NEG
65910: PUSH
65911: LD_INT 3
65913: NEG
65914: PUSH
65915: EMPTY
65916: LIST
65917: LIST
65918: PUSH
65919: LD_INT 1
65921: NEG
65922: PUSH
65923: LD_INT 3
65925: NEG
65926: PUSH
65927: EMPTY
65928: LIST
65929: LIST
65930: PUSH
65931: LD_INT 0
65933: PUSH
65934: LD_INT 3
65936: NEG
65937: PUSH
65938: EMPTY
65939: LIST
65940: LIST
65941: PUSH
65942: LD_INT 1
65944: PUSH
65945: LD_INT 2
65947: NEG
65948: PUSH
65949: EMPTY
65950: LIST
65951: LIST
65952: PUSH
65953: LD_INT 3
65955: PUSH
65956: LD_INT 2
65958: PUSH
65959: EMPTY
65960: LIST
65961: LIST
65962: PUSH
65963: LD_INT 3
65965: PUSH
65966: LD_INT 3
65968: PUSH
65969: EMPTY
65970: LIST
65971: LIST
65972: PUSH
65973: LD_INT 2
65975: PUSH
65976: LD_INT 3
65978: PUSH
65979: EMPTY
65980: LIST
65981: LIST
65982: PUSH
65983: LD_INT 1
65985: PUSH
65986: LD_INT 3
65988: PUSH
65989: EMPTY
65990: LIST
65991: LIST
65992: PUSH
65993: LD_INT 0
65995: PUSH
65996: LD_INT 3
65998: PUSH
65999: EMPTY
66000: LIST
66001: LIST
66002: PUSH
66003: LD_INT 1
66005: NEG
66006: PUSH
66007: LD_INT 2
66009: PUSH
66010: EMPTY
66011: LIST
66012: LIST
66013: PUSH
66014: LD_INT 3
66016: NEG
66017: PUSH
66018: LD_INT 2
66020: NEG
66021: PUSH
66022: EMPTY
66023: LIST
66024: LIST
66025: PUSH
66026: LD_INT 3
66028: NEG
66029: PUSH
66030: LD_INT 3
66032: NEG
66033: PUSH
66034: EMPTY
66035: LIST
66036: LIST
66037: PUSH
66038: EMPTY
66039: LIST
66040: LIST
66041: LIST
66042: LIST
66043: LIST
66044: LIST
66045: LIST
66046: LIST
66047: LIST
66048: LIST
66049: LIST
66050: LIST
66051: LIST
66052: LIST
66053: LIST
66054: LIST
66055: LIST
66056: LIST
66057: LIST
66058: LIST
66059: LIST
66060: LIST
66061: LIST
66062: LIST
66063: LIST
66064: LIST
66065: LIST
66066: LIST
66067: LIST
66068: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66069: LD_ADDR_VAR 0 43
66073: PUSH
66074: LD_INT 0
66076: PUSH
66077: LD_INT 0
66079: PUSH
66080: EMPTY
66081: LIST
66082: LIST
66083: PUSH
66084: LD_INT 0
66086: PUSH
66087: LD_INT 1
66089: NEG
66090: PUSH
66091: EMPTY
66092: LIST
66093: LIST
66094: PUSH
66095: LD_INT 1
66097: PUSH
66098: LD_INT 0
66100: PUSH
66101: EMPTY
66102: LIST
66103: LIST
66104: PUSH
66105: LD_INT 1
66107: PUSH
66108: LD_INT 1
66110: PUSH
66111: EMPTY
66112: LIST
66113: LIST
66114: PUSH
66115: LD_INT 0
66117: PUSH
66118: LD_INT 1
66120: PUSH
66121: EMPTY
66122: LIST
66123: LIST
66124: PUSH
66125: LD_INT 1
66127: NEG
66128: PUSH
66129: LD_INT 0
66131: PUSH
66132: EMPTY
66133: LIST
66134: LIST
66135: PUSH
66136: LD_INT 1
66138: NEG
66139: PUSH
66140: LD_INT 1
66142: NEG
66143: PUSH
66144: EMPTY
66145: LIST
66146: LIST
66147: PUSH
66148: LD_INT 1
66150: NEG
66151: PUSH
66152: LD_INT 2
66154: NEG
66155: PUSH
66156: EMPTY
66157: LIST
66158: LIST
66159: PUSH
66160: LD_INT 0
66162: PUSH
66163: LD_INT 2
66165: NEG
66166: PUSH
66167: EMPTY
66168: LIST
66169: LIST
66170: PUSH
66171: LD_INT 1
66173: PUSH
66174: LD_INT 1
66176: NEG
66177: PUSH
66178: EMPTY
66179: LIST
66180: LIST
66181: PUSH
66182: LD_INT 2
66184: PUSH
66185: LD_INT 0
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: PUSH
66192: LD_INT 2
66194: PUSH
66195: LD_INT 1
66197: PUSH
66198: EMPTY
66199: LIST
66200: LIST
66201: PUSH
66202: LD_INT 1
66204: PUSH
66205: LD_INT 2
66207: PUSH
66208: EMPTY
66209: LIST
66210: LIST
66211: PUSH
66212: LD_INT 0
66214: PUSH
66215: LD_INT 2
66217: PUSH
66218: EMPTY
66219: LIST
66220: LIST
66221: PUSH
66222: LD_INT 1
66224: NEG
66225: PUSH
66226: LD_INT 1
66228: PUSH
66229: EMPTY
66230: LIST
66231: LIST
66232: PUSH
66233: LD_INT 2
66235: NEG
66236: PUSH
66237: LD_INT 0
66239: PUSH
66240: EMPTY
66241: LIST
66242: LIST
66243: PUSH
66244: LD_INT 2
66246: NEG
66247: PUSH
66248: LD_INT 1
66250: NEG
66251: PUSH
66252: EMPTY
66253: LIST
66254: LIST
66255: PUSH
66256: LD_INT 1
66258: NEG
66259: PUSH
66260: LD_INT 3
66262: NEG
66263: PUSH
66264: EMPTY
66265: LIST
66266: LIST
66267: PUSH
66268: LD_INT 0
66270: PUSH
66271: LD_INT 3
66273: NEG
66274: PUSH
66275: EMPTY
66276: LIST
66277: LIST
66278: PUSH
66279: LD_INT 1
66281: PUSH
66282: LD_INT 2
66284: NEG
66285: PUSH
66286: EMPTY
66287: LIST
66288: LIST
66289: PUSH
66290: LD_INT 2
66292: PUSH
66293: LD_INT 1
66295: NEG
66296: PUSH
66297: EMPTY
66298: LIST
66299: LIST
66300: PUSH
66301: LD_INT 3
66303: PUSH
66304: LD_INT 0
66306: PUSH
66307: EMPTY
66308: LIST
66309: LIST
66310: PUSH
66311: LD_INT 3
66313: PUSH
66314: LD_INT 1
66316: PUSH
66317: EMPTY
66318: LIST
66319: LIST
66320: PUSH
66321: LD_INT 1
66323: PUSH
66324: LD_INT 3
66326: PUSH
66327: EMPTY
66328: LIST
66329: LIST
66330: PUSH
66331: LD_INT 0
66333: PUSH
66334: LD_INT 3
66336: PUSH
66337: EMPTY
66338: LIST
66339: LIST
66340: PUSH
66341: LD_INT 1
66343: NEG
66344: PUSH
66345: LD_INT 2
66347: PUSH
66348: EMPTY
66349: LIST
66350: LIST
66351: PUSH
66352: LD_INT 2
66354: NEG
66355: PUSH
66356: LD_INT 1
66358: PUSH
66359: EMPTY
66360: LIST
66361: LIST
66362: PUSH
66363: LD_INT 3
66365: NEG
66366: PUSH
66367: LD_INT 0
66369: PUSH
66370: EMPTY
66371: LIST
66372: LIST
66373: PUSH
66374: LD_INT 3
66376: NEG
66377: PUSH
66378: LD_INT 1
66380: NEG
66381: PUSH
66382: EMPTY
66383: LIST
66384: LIST
66385: PUSH
66386: EMPTY
66387: LIST
66388: LIST
66389: LIST
66390: LIST
66391: LIST
66392: LIST
66393: LIST
66394: LIST
66395: LIST
66396: LIST
66397: LIST
66398: LIST
66399: LIST
66400: LIST
66401: LIST
66402: LIST
66403: LIST
66404: LIST
66405: LIST
66406: LIST
66407: LIST
66408: LIST
66409: LIST
66410: LIST
66411: LIST
66412: LIST
66413: LIST
66414: LIST
66415: LIST
66416: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66417: LD_ADDR_VAR 0 44
66421: PUSH
66422: LD_INT 0
66424: PUSH
66425: LD_INT 0
66427: PUSH
66428: EMPTY
66429: LIST
66430: LIST
66431: PUSH
66432: LD_INT 0
66434: PUSH
66435: LD_INT 1
66437: NEG
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: LD_INT 1
66445: PUSH
66446: LD_INT 0
66448: PUSH
66449: EMPTY
66450: LIST
66451: LIST
66452: PUSH
66453: LD_INT 1
66455: PUSH
66456: LD_INT 1
66458: PUSH
66459: EMPTY
66460: LIST
66461: LIST
66462: PUSH
66463: LD_INT 0
66465: PUSH
66466: LD_INT 1
66468: PUSH
66469: EMPTY
66470: LIST
66471: LIST
66472: PUSH
66473: LD_INT 1
66475: NEG
66476: PUSH
66477: LD_INT 0
66479: PUSH
66480: EMPTY
66481: LIST
66482: LIST
66483: PUSH
66484: LD_INT 1
66486: NEG
66487: PUSH
66488: LD_INT 1
66490: NEG
66491: PUSH
66492: EMPTY
66493: LIST
66494: LIST
66495: PUSH
66496: LD_INT 1
66498: NEG
66499: PUSH
66500: LD_INT 2
66502: NEG
66503: PUSH
66504: EMPTY
66505: LIST
66506: LIST
66507: PUSH
66508: LD_INT 1
66510: PUSH
66511: LD_INT 1
66513: NEG
66514: PUSH
66515: EMPTY
66516: LIST
66517: LIST
66518: PUSH
66519: LD_INT 2
66521: PUSH
66522: LD_INT 0
66524: PUSH
66525: EMPTY
66526: LIST
66527: LIST
66528: PUSH
66529: LD_INT 2
66531: PUSH
66532: LD_INT 1
66534: PUSH
66535: EMPTY
66536: LIST
66537: LIST
66538: PUSH
66539: LD_INT 2
66541: PUSH
66542: LD_INT 2
66544: PUSH
66545: EMPTY
66546: LIST
66547: LIST
66548: PUSH
66549: LD_INT 1
66551: PUSH
66552: LD_INT 2
66554: PUSH
66555: EMPTY
66556: LIST
66557: LIST
66558: PUSH
66559: LD_INT 1
66561: NEG
66562: PUSH
66563: LD_INT 1
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: PUSH
66570: LD_INT 2
66572: NEG
66573: PUSH
66574: LD_INT 0
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: PUSH
66581: LD_INT 2
66583: NEG
66584: PUSH
66585: LD_INT 1
66587: NEG
66588: PUSH
66589: EMPTY
66590: LIST
66591: LIST
66592: PUSH
66593: LD_INT 2
66595: NEG
66596: PUSH
66597: LD_INT 2
66599: NEG
66600: PUSH
66601: EMPTY
66602: LIST
66603: LIST
66604: PUSH
66605: LD_INT 2
66607: NEG
66608: PUSH
66609: LD_INT 3
66611: NEG
66612: PUSH
66613: EMPTY
66614: LIST
66615: LIST
66616: PUSH
66617: LD_INT 2
66619: PUSH
66620: LD_INT 1
66622: NEG
66623: PUSH
66624: EMPTY
66625: LIST
66626: LIST
66627: PUSH
66628: LD_INT 3
66630: PUSH
66631: LD_INT 0
66633: PUSH
66634: EMPTY
66635: LIST
66636: LIST
66637: PUSH
66638: LD_INT 3
66640: PUSH
66641: LD_INT 1
66643: PUSH
66644: EMPTY
66645: LIST
66646: LIST
66647: PUSH
66648: LD_INT 3
66650: PUSH
66651: LD_INT 2
66653: PUSH
66654: EMPTY
66655: LIST
66656: LIST
66657: PUSH
66658: LD_INT 3
66660: PUSH
66661: LD_INT 3
66663: PUSH
66664: EMPTY
66665: LIST
66666: LIST
66667: PUSH
66668: LD_INT 2
66670: PUSH
66671: LD_INT 3
66673: PUSH
66674: EMPTY
66675: LIST
66676: LIST
66677: PUSH
66678: LD_INT 2
66680: NEG
66681: PUSH
66682: LD_INT 1
66684: PUSH
66685: EMPTY
66686: LIST
66687: LIST
66688: PUSH
66689: LD_INT 3
66691: NEG
66692: PUSH
66693: LD_INT 0
66695: PUSH
66696: EMPTY
66697: LIST
66698: LIST
66699: PUSH
66700: LD_INT 3
66702: NEG
66703: PUSH
66704: LD_INT 1
66706: NEG
66707: PUSH
66708: EMPTY
66709: LIST
66710: LIST
66711: PUSH
66712: LD_INT 3
66714: NEG
66715: PUSH
66716: LD_INT 2
66718: NEG
66719: PUSH
66720: EMPTY
66721: LIST
66722: LIST
66723: PUSH
66724: LD_INT 3
66726: NEG
66727: PUSH
66728: LD_INT 3
66730: NEG
66731: PUSH
66732: EMPTY
66733: LIST
66734: LIST
66735: PUSH
66736: EMPTY
66737: LIST
66738: LIST
66739: LIST
66740: LIST
66741: LIST
66742: LIST
66743: LIST
66744: LIST
66745: LIST
66746: LIST
66747: LIST
66748: LIST
66749: LIST
66750: LIST
66751: LIST
66752: LIST
66753: LIST
66754: LIST
66755: LIST
66756: LIST
66757: LIST
66758: LIST
66759: LIST
66760: LIST
66761: LIST
66762: LIST
66763: LIST
66764: LIST
66765: LIST
66766: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66767: LD_ADDR_VAR 0 45
66771: PUSH
66772: LD_INT 0
66774: PUSH
66775: LD_INT 0
66777: PUSH
66778: EMPTY
66779: LIST
66780: LIST
66781: PUSH
66782: LD_INT 0
66784: PUSH
66785: LD_INT 1
66787: NEG
66788: PUSH
66789: EMPTY
66790: LIST
66791: LIST
66792: PUSH
66793: LD_INT 1
66795: PUSH
66796: LD_INT 0
66798: PUSH
66799: EMPTY
66800: LIST
66801: LIST
66802: PUSH
66803: LD_INT 1
66805: PUSH
66806: LD_INT 1
66808: PUSH
66809: EMPTY
66810: LIST
66811: LIST
66812: PUSH
66813: LD_INT 0
66815: PUSH
66816: LD_INT 1
66818: PUSH
66819: EMPTY
66820: LIST
66821: LIST
66822: PUSH
66823: LD_INT 1
66825: NEG
66826: PUSH
66827: LD_INT 0
66829: PUSH
66830: EMPTY
66831: LIST
66832: LIST
66833: PUSH
66834: LD_INT 1
66836: NEG
66837: PUSH
66838: LD_INT 1
66840: NEG
66841: PUSH
66842: EMPTY
66843: LIST
66844: LIST
66845: PUSH
66846: LD_INT 1
66848: NEG
66849: PUSH
66850: LD_INT 2
66852: NEG
66853: PUSH
66854: EMPTY
66855: LIST
66856: LIST
66857: PUSH
66858: LD_INT 0
66860: PUSH
66861: LD_INT 2
66863: NEG
66864: PUSH
66865: EMPTY
66866: LIST
66867: LIST
66868: PUSH
66869: LD_INT 1
66871: PUSH
66872: LD_INT 1
66874: NEG
66875: PUSH
66876: EMPTY
66877: LIST
66878: LIST
66879: PUSH
66880: LD_INT 2
66882: PUSH
66883: LD_INT 1
66885: PUSH
66886: EMPTY
66887: LIST
66888: LIST
66889: PUSH
66890: LD_INT 2
66892: PUSH
66893: LD_INT 2
66895: PUSH
66896: EMPTY
66897: LIST
66898: LIST
66899: PUSH
66900: LD_INT 1
66902: PUSH
66903: LD_INT 2
66905: PUSH
66906: EMPTY
66907: LIST
66908: LIST
66909: PUSH
66910: LD_INT 0
66912: PUSH
66913: LD_INT 2
66915: PUSH
66916: EMPTY
66917: LIST
66918: LIST
66919: PUSH
66920: LD_INT 1
66922: NEG
66923: PUSH
66924: LD_INT 1
66926: PUSH
66927: EMPTY
66928: LIST
66929: LIST
66930: PUSH
66931: LD_INT 2
66933: NEG
66934: PUSH
66935: LD_INT 1
66937: NEG
66938: PUSH
66939: EMPTY
66940: LIST
66941: LIST
66942: PUSH
66943: LD_INT 2
66945: NEG
66946: PUSH
66947: LD_INT 2
66949: NEG
66950: PUSH
66951: EMPTY
66952: LIST
66953: LIST
66954: PUSH
66955: LD_INT 2
66957: NEG
66958: PUSH
66959: LD_INT 3
66961: NEG
66962: PUSH
66963: EMPTY
66964: LIST
66965: LIST
66966: PUSH
66967: LD_INT 1
66969: NEG
66970: PUSH
66971: LD_INT 3
66973: NEG
66974: PUSH
66975: EMPTY
66976: LIST
66977: LIST
66978: PUSH
66979: LD_INT 0
66981: PUSH
66982: LD_INT 3
66984: NEG
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: PUSH
66990: LD_INT 1
66992: PUSH
66993: LD_INT 2
66995: NEG
66996: PUSH
66997: EMPTY
66998: LIST
66999: LIST
67000: PUSH
67001: LD_INT 3
67003: PUSH
67004: LD_INT 2
67006: PUSH
67007: EMPTY
67008: LIST
67009: LIST
67010: PUSH
67011: LD_INT 3
67013: PUSH
67014: LD_INT 3
67016: PUSH
67017: EMPTY
67018: LIST
67019: LIST
67020: PUSH
67021: LD_INT 2
67023: PUSH
67024: LD_INT 3
67026: PUSH
67027: EMPTY
67028: LIST
67029: LIST
67030: PUSH
67031: LD_INT 1
67033: PUSH
67034: LD_INT 3
67036: PUSH
67037: EMPTY
67038: LIST
67039: LIST
67040: PUSH
67041: LD_INT 0
67043: PUSH
67044: LD_INT 3
67046: PUSH
67047: EMPTY
67048: LIST
67049: LIST
67050: PUSH
67051: LD_INT 1
67053: NEG
67054: PUSH
67055: LD_INT 2
67057: PUSH
67058: EMPTY
67059: LIST
67060: LIST
67061: PUSH
67062: LD_INT 3
67064: NEG
67065: PUSH
67066: LD_INT 2
67068: NEG
67069: PUSH
67070: EMPTY
67071: LIST
67072: LIST
67073: PUSH
67074: LD_INT 3
67076: NEG
67077: PUSH
67078: LD_INT 3
67080: NEG
67081: PUSH
67082: EMPTY
67083: LIST
67084: LIST
67085: PUSH
67086: EMPTY
67087: LIST
67088: LIST
67089: LIST
67090: LIST
67091: LIST
67092: LIST
67093: LIST
67094: LIST
67095: LIST
67096: LIST
67097: LIST
67098: LIST
67099: LIST
67100: LIST
67101: LIST
67102: LIST
67103: LIST
67104: LIST
67105: LIST
67106: LIST
67107: LIST
67108: LIST
67109: LIST
67110: LIST
67111: LIST
67112: LIST
67113: LIST
67114: LIST
67115: LIST
67116: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
67117: LD_ADDR_VAR 0 46
67121: PUSH
67122: LD_INT 0
67124: PUSH
67125: LD_INT 0
67127: PUSH
67128: EMPTY
67129: LIST
67130: LIST
67131: PUSH
67132: LD_INT 0
67134: PUSH
67135: LD_INT 1
67137: NEG
67138: PUSH
67139: EMPTY
67140: LIST
67141: LIST
67142: PUSH
67143: LD_INT 1
67145: PUSH
67146: LD_INT 0
67148: PUSH
67149: EMPTY
67150: LIST
67151: LIST
67152: PUSH
67153: LD_INT 1
67155: PUSH
67156: LD_INT 1
67158: PUSH
67159: EMPTY
67160: LIST
67161: LIST
67162: PUSH
67163: LD_INT 0
67165: PUSH
67166: LD_INT 1
67168: PUSH
67169: EMPTY
67170: LIST
67171: LIST
67172: PUSH
67173: LD_INT 1
67175: NEG
67176: PUSH
67177: LD_INT 0
67179: PUSH
67180: EMPTY
67181: LIST
67182: LIST
67183: PUSH
67184: LD_INT 1
67186: NEG
67187: PUSH
67188: LD_INT 1
67190: NEG
67191: PUSH
67192: EMPTY
67193: LIST
67194: LIST
67195: PUSH
67196: LD_INT 1
67198: NEG
67199: PUSH
67200: LD_INT 2
67202: NEG
67203: PUSH
67204: EMPTY
67205: LIST
67206: LIST
67207: PUSH
67208: LD_INT 0
67210: PUSH
67211: LD_INT 2
67213: NEG
67214: PUSH
67215: EMPTY
67216: LIST
67217: LIST
67218: PUSH
67219: LD_INT 1
67221: PUSH
67222: LD_INT 1
67224: NEG
67225: PUSH
67226: EMPTY
67227: LIST
67228: LIST
67229: PUSH
67230: LD_INT 2
67232: PUSH
67233: LD_INT 0
67235: PUSH
67236: EMPTY
67237: LIST
67238: LIST
67239: PUSH
67240: LD_INT 2
67242: PUSH
67243: LD_INT 1
67245: PUSH
67246: EMPTY
67247: LIST
67248: LIST
67249: PUSH
67250: LD_INT 1
67252: PUSH
67253: LD_INT 2
67255: PUSH
67256: EMPTY
67257: LIST
67258: LIST
67259: PUSH
67260: LD_INT 0
67262: PUSH
67263: LD_INT 2
67265: PUSH
67266: EMPTY
67267: LIST
67268: LIST
67269: PUSH
67270: LD_INT 1
67272: NEG
67273: PUSH
67274: LD_INT 1
67276: PUSH
67277: EMPTY
67278: LIST
67279: LIST
67280: PUSH
67281: LD_INT 2
67283: NEG
67284: PUSH
67285: LD_INT 0
67287: PUSH
67288: EMPTY
67289: LIST
67290: LIST
67291: PUSH
67292: LD_INT 2
67294: NEG
67295: PUSH
67296: LD_INT 1
67298: NEG
67299: PUSH
67300: EMPTY
67301: LIST
67302: LIST
67303: PUSH
67304: LD_INT 1
67306: NEG
67307: PUSH
67308: LD_INT 3
67310: NEG
67311: PUSH
67312: EMPTY
67313: LIST
67314: LIST
67315: PUSH
67316: LD_INT 0
67318: PUSH
67319: LD_INT 3
67321: NEG
67322: PUSH
67323: EMPTY
67324: LIST
67325: LIST
67326: PUSH
67327: LD_INT 1
67329: PUSH
67330: LD_INT 2
67332: NEG
67333: PUSH
67334: EMPTY
67335: LIST
67336: LIST
67337: PUSH
67338: LD_INT 2
67340: PUSH
67341: LD_INT 1
67343: NEG
67344: PUSH
67345: EMPTY
67346: LIST
67347: LIST
67348: PUSH
67349: LD_INT 3
67351: PUSH
67352: LD_INT 0
67354: PUSH
67355: EMPTY
67356: LIST
67357: LIST
67358: PUSH
67359: LD_INT 3
67361: PUSH
67362: LD_INT 1
67364: PUSH
67365: EMPTY
67366: LIST
67367: LIST
67368: PUSH
67369: LD_INT 1
67371: PUSH
67372: LD_INT 3
67374: PUSH
67375: EMPTY
67376: LIST
67377: LIST
67378: PUSH
67379: LD_INT 0
67381: PUSH
67382: LD_INT 3
67384: PUSH
67385: EMPTY
67386: LIST
67387: LIST
67388: PUSH
67389: LD_INT 1
67391: NEG
67392: PUSH
67393: LD_INT 2
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PUSH
67400: LD_INT 2
67402: NEG
67403: PUSH
67404: LD_INT 1
67406: PUSH
67407: EMPTY
67408: LIST
67409: LIST
67410: PUSH
67411: LD_INT 3
67413: NEG
67414: PUSH
67415: LD_INT 0
67417: PUSH
67418: EMPTY
67419: LIST
67420: LIST
67421: PUSH
67422: LD_INT 3
67424: NEG
67425: PUSH
67426: LD_INT 1
67428: NEG
67429: PUSH
67430: EMPTY
67431: LIST
67432: LIST
67433: PUSH
67434: EMPTY
67435: LIST
67436: LIST
67437: LIST
67438: LIST
67439: LIST
67440: LIST
67441: LIST
67442: LIST
67443: LIST
67444: LIST
67445: LIST
67446: LIST
67447: LIST
67448: LIST
67449: LIST
67450: LIST
67451: LIST
67452: LIST
67453: LIST
67454: LIST
67455: LIST
67456: LIST
67457: LIST
67458: LIST
67459: LIST
67460: LIST
67461: LIST
67462: LIST
67463: LIST
67464: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67465: LD_ADDR_VAR 0 47
67469: PUSH
67470: LD_INT 0
67472: PUSH
67473: LD_INT 0
67475: PUSH
67476: EMPTY
67477: LIST
67478: LIST
67479: PUSH
67480: LD_INT 0
67482: PUSH
67483: LD_INT 1
67485: NEG
67486: PUSH
67487: EMPTY
67488: LIST
67489: LIST
67490: PUSH
67491: LD_INT 1
67493: PUSH
67494: LD_INT 0
67496: PUSH
67497: EMPTY
67498: LIST
67499: LIST
67500: PUSH
67501: LD_INT 1
67503: PUSH
67504: LD_INT 1
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: PUSH
67511: LD_INT 0
67513: PUSH
67514: LD_INT 1
67516: PUSH
67517: EMPTY
67518: LIST
67519: LIST
67520: PUSH
67521: LD_INT 1
67523: NEG
67524: PUSH
67525: LD_INT 0
67527: PUSH
67528: EMPTY
67529: LIST
67530: LIST
67531: PUSH
67532: LD_INT 1
67534: NEG
67535: PUSH
67536: LD_INT 1
67538: NEG
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PUSH
67544: LD_INT 1
67546: NEG
67547: PUSH
67548: LD_INT 2
67550: NEG
67551: PUSH
67552: EMPTY
67553: LIST
67554: LIST
67555: PUSH
67556: LD_INT 0
67558: PUSH
67559: LD_INT 2
67561: NEG
67562: PUSH
67563: EMPTY
67564: LIST
67565: LIST
67566: PUSH
67567: LD_INT 1
67569: PUSH
67570: LD_INT 1
67572: NEG
67573: PUSH
67574: EMPTY
67575: LIST
67576: LIST
67577: PUSH
67578: LD_INT 2
67580: NEG
67581: PUSH
67582: LD_INT 1
67584: NEG
67585: PUSH
67586: EMPTY
67587: LIST
67588: LIST
67589: PUSH
67590: LD_INT 2
67592: NEG
67593: PUSH
67594: LD_INT 2
67596: NEG
67597: PUSH
67598: EMPTY
67599: LIST
67600: LIST
67601: PUSH
67602: EMPTY
67603: LIST
67604: LIST
67605: LIST
67606: LIST
67607: LIST
67608: LIST
67609: LIST
67610: LIST
67611: LIST
67612: LIST
67613: LIST
67614: LIST
67615: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
67616: LD_ADDR_VAR 0 48
67620: PUSH
67621: LD_INT 0
67623: PUSH
67624: LD_INT 0
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: PUSH
67631: LD_INT 0
67633: PUSH
67634: LD_INT 1
67636: NEG
67637: PUSH
67638: EMPTY
67639: LIST
67640: LIST
67641: PUSH
67642: LD_INT 1
67644: PUSH
67645: LD_INT 0
67647: PUSH
67648: EMPTY
67649: LIST
67650: LIST
67651: PUSH
67652: LD_INT 1
67654: PUSH
67655: LD_INT 1
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: PUSH
67662: LD_INT 0
67664: PUSH
67665: LD_INT 1
67667: PUSH
67668: EMPTY
67669: LIST
67670: LIST
67671: PUSH
67672: LD_INT 1
67674: NEG
67675: PUSH
67676: LD_INT 0
67678: PUSH
67679: EMPTY
67680: LIST
67681: LIST
67682: PUSH
67683: LD_INT 1
67685: NEG
67686: PUSH
67687: LD_INT 1
67689: NEG
67690: PUSH
67691: EMPTY
67692: LIST
67693: LIST
67694: PUSH
67695: LD_INT 1
67697: NEG
67698: PUSH
67699: LD_INT 2
67701: NEG
67702: PUSH
67703: EMPTY
67704: LIST
67705: LIST
67706: PUSH
67707: LD_INT 0
67709: PUSH
67710: LD_INT 2
67712: NEG
67713: PUSH
67714: EMPTY
67715: LIST
67716: LIST
67717: PUSH
67718: LD_INT 1
67720: PUSH
67721: LD_INT 1
67723: NEG
67724: PUSH
67725: EMPTY
67726: LIST
67727: LIST
67728: PUSH
67729: LD_INT 2
67731: PUSH
67732: LD_INT 0
67734: PUSH
67735: EMPTY
67736: LIST
67737: LIST
67738: PUSH
67739: LD_INT 2
67741: PUSH
67742: LD_INT 1
67744: PUSH
67745: EMPTY
67746: LIST
67747: LIST
67748: PUSH
67749: EMPTY
67750: LIST
67751: LIST
67752: LIST
67753: LIST
67754: LIST
67755: LIST
67756: LIST
67757: LIST
67758: LIST
67759: LIST
67760: LIST
67761: LIST
67762: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
67763: LD_ADDR_VAR 0 49
67767: PUSH
67768: LD_INT 0
67770: PUSH
67771: LD_INT 0
67773: PUSH
67774: EMPTY
67775: LIST
67776: LIST
67777: PUSH
67778: LD_INT 0
67780: PUSH
67781: LD_INT 1
67783: NEG
67784: PUSH
67785: EMPTY
67786: LIST
67787: LIST
67788: PUSH
67789: LD_INT 1
67791: PUSH
67792: LD_INT 0
67794: PUSH
67795: EMPTY
67796: LIST
67797: LIST
67798: PUSH
67799: LD_INT 1
67801: PUSH
67802: LD_INT 1
67804: PUSH
67805: EMPTY
67806: LIST
67807: LIST
67808: PUSH
67809: LD_INT 0
67811: PUSH
67812: LD_INT 1
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: PUSH
67819: LD_INT 1
67821: NEG
67822: PUSH
67823: LD_INT 0
67825: PUSH
67826: EMPTY
67827: LIST
67828: LIST
67829: PUSH
67830: LD_INT 1
67832: NEG
67833: PUSH
67834: LD_INT 1
67836: NEG
67837: PUSH
67838: EMPTY
67839: LIST
67840: LIST
67841: PUSH
67842: LD_INT 1
67844: PUSH
67845: LD_INT 1
67847: NEG
67848: PUSH
67849: EMPTY
67850: LIST
67851: LIST
67852: PUSH
67853: LD_INT 2
67855: PUSH
67856: LD_INT 0
67858: PUSH
67859: EMPTY
67860: LIST
67861: LIST
67862: PUSH
67863: LD_INT 2
67865: PUSH
67866: LD_INT 1
67868: PUSH
67869: EMPTY
67870: LIST
67871: LIST
67872: PUSH
67873: LD_INT 2
67875: PUSH
67876: LD_INT 2
67878: PUSH
67879: EMPTY
67880: LIST
67881: LIST
67882: PUSH
67883: LD_INT 1
67885: PUSH
67886: LD_INT 2
67888: PUSH
67889: EMPTY
67890: LIST
67891: LIST
67892: PUSH
67893: EMPTY
67894: LIST
67895: LIST
67896: LIST
67897: LIST
67898: LIST
67899: LIST
67900: LIST
67901: LIST
67902: LIST
67903: LIST
67904: LIST
67905: LIST
67906: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
67907: LD_ADDR_VAR 0 50
67911: PUSH
67912: LD_INT 0
67914: PUSH
67915: LD_INT 0
67917: PUSH
67918: EMPTY
67919: LIST
67920: LIST
67921: PUSH
67922: LD_INT 0
67924: PUSH
67925: LD_INT 1
67927: NEG
67928: PUSH
67929: EMPTY
67930: LIST
67931: LIST
67932: PUSH
67933: LD_INT 1
67935: PUSH
67936: LD_INT 0
67938: PUSH
67939: EMPTY
67940: LIST
67941: LIST
67942: PUSH
67943: LD_INT 1
67945: PUSH
67946: LD_INT 1
67948: PUSH
67949: EMPTY
67950: LIST
67951: LIST
67952: PUSH
67953: LD_INT 0
67955: PUSH
67956: LD_INT 1
67958: PUSH
67959: EMPTY
67960: LIST
67961: LIST
67962: PUSH
67963: LD_INT 1
67965: NEG
67966: PUSH
67967: LD_INT 0
67969: PUSH
67970: EMPTY
67971: LIST
67972: LIST
67973: PUSH
67974: LD_INT 1
67976: NEG
67977: PUSH
67978: LD_INT 1
67980: NEG
67981: PUSH
67982: EMPTY
67983: LIST
67984: LIST
67985: PUSH
67986: LD_INT 2
67988: PUSH
67989: LD_INT 1
67991: PUSH
67992: EMPTY
67993: LIST
67994: LIST
67995: PUSH
67996: LD_INT 2
67998: PUSH
67999: LD_INT 2
68001: PUSH
68002: EMPTY
68003: LIST
68004: LIST
68005: PUSH
68006: LD_INT 1
68008: PUSH
68009: LD_INT 2
68011: PUSH
68012: EMPTY
68013: LIST
68014: LIST
68015: PUSH
68016: LD_INT 0
68018: PUSH
68019: LD_INT 2
68021: PUSH
68022: EMPTY
68023: LIST
68024: LIST
68025: PUSH
68026: LD_INT 1
68028: NEG
68029: PUSH
68030: LD_INT 1
68032: PUSH
68033: EMPTY
68034: LIST
68035: LIST
68036: PUSH
68037: EMPTY
68038: LIST
68039: LIST
68040: LIST
68041: LIST
68042: LIST
68043: LIST
68044: LIST
68045: LIST
68046: LIST
68047: LIST
68048: LIST
68049: LIST
68050: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
68051: LD_ADDR_VAR 0 51
68055: PUSH
68056: LD_INT 0
68058: PUSH
68059: LD_INT 0
68061: PUSH
68062: EMPTY
68063: LIST
68064: LIST
68065: PUSH
68066: LD_INT 0
68068: PUSH
68069: LD_INT 1
68071: NEG
68072: PUSH
68073: EMPTY
68074: LIST
68075: LIST
68076: PUSH
68077: LD_INT 1
68079: PUSH
68080: LD_INT 0
68082: PUSH
68083: EMPTY
68084: LIST
68085: LIST
68086: PUSH
68087: LD_INT 1
68089: PUSH
68090: LD_INT 1
68092: PUSH
68093: EMPTY
68094: LIST
68095: LIST
68096: PUSH
68097: LD_INT 0
68099: PUSH
68100: LD_INT 1
68102: PUSH
68103: EMPTY
68104: LIST
68105: LIST
68106: PUSH
68107: LD_INT 1
68109: NEG
68110: PUSH
68111: LD_INT 0
68113: PUSH
68114: EMPTY
68115: LIST
68116: LIST
68117: PUSH
68118: LD_INT 1
68120: NEG
68121: PUSH
68122: LD_INT 1
68124: NEG
68125: PUSH
68126: EMPTY
68127: LIST
68128: LIST
68129: PUSH
68130: LD_INT 1
68132: PUSH
68133: LD_INT 2
68135: PUSH
68136: EMPTY
68137: LIST
68138: LIST
68139: PUSH
68140: LD_INT 0
68142: PUSH
68143: LD_INT 2
68145: PUSH
68146: EMPTY
68147: LIST
68148: LIST
68149: PUSH
68150: LD_INT 1
68152: NEG
68153: PUSH
68154: LD_INT 1
68156: PUSH
68157: EMPTY
68158: LIST
68159: LIST
68160: PUSH
68161: LD_INT 2
68163: NEG
68164: PUSH
68165: LD_INT 0
68167: PUSH
68168: EMPTY
68169: LIST
68170: LIST
68171: PUSH
68172: LD_INT 2
68174: NEG
68175: PUSH
68176: LD_INT 1
68178: NEG
68179: PUSH
68180: EMPTY
68181: LIST
68182: LIST
68183: PUSH
68184: EMPTY
68185: LIST
68186: LIST
68187: LIST
68188: LIST
68189: LIST
68190: LIST
68191: LIST
68192: LIST
68193: LIST
68194: LIST
68195: LIST
68196: LIST
68197: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68198: LD_ADDR_VAR 0 52
68202: PUSH
68203: LD_INT 0
68205: PUSH
68206: LD_INT 0
68208: PUSH
68209: EMPTY
68210: LIST
68211: LIST
68212: PUSH
68213: LD_INT 0
68215: PUSH
68216: LD_INT 1
68218: NEG
68219: PUSH
68220: EMPTY
68221: LIST
68222: LIST
68223: PUSH
68224: LD_INT 1
68226: PUSH
68227: LD_INT 0
68229: PUSH
68230: EMPTY
68231: LIST
68232: LIST
68233: PUSH
68234: LD_INT 1
68236: PUSH
68237: LD_INT 1
68239: PUSH
68240: EMPTY
68241: LIST
68242: LIST
68243: PUSH
68244: LD_INT 0
68246: PUSH
68247: LD_INT 1
68249: PUSH
68250: EMPTY
68251: LIST
68252: LIST
68253: PUSH
68254: LD_INT 1
68256: NEG
68257: PUSH
68258: LD_INT 0
68260: PUSH
68261: EMPTY
68262: LIST
68263: LIST
68264: PUSH
68265: LD_INT 1
68267: NEG
68268: PUSH
68269: LD_INT 1
68271: NEG
68272: PUSH
68273: EMPTY
68274: LIST
68275: LIST
68276: PUSH
68277: LD_INT 1
68279: NEG
68280: PUSH
68281: LD_INT 2
68283: NEG
68284: PUSH
68285: EMPTY
68286: LIST
68287: LIST
68288: PUSH
68289: LD_INT 1
68291: NEG
68292: PUSH
68293: LD_INT 1
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: PUSH
68300: LD_INT 2
68302: NEG
68303: PUSH
68304: LD_INT 0
68306: PUSH
68307: EMPTY
68308: LIST
68309: LIST
68310: PUSH
68311: LD_INT 2
68313: NEG
68314: PUSH
68315: LD_INT 1
68317: NEG
68318: PUSH
68319: EMPTY
68320: LIST
68321: LIST
68322: PUSH
68323: LD_INT 2
68325: NEG
68326: PUSH
68327: LD_INT 2
68329: NEG
68330: PUSH
68331: EMPTY
68332: LIST
68333: LIST
68334: PUSH
68335: EMPTY
68336: LIST
68337: LIST
68338: LIST
68339: LIST
68340: LIST
68341: LIST
68342: LIST
68343: LIST
68344: LIST
68345: LIST
68346: LIST
68347: LIST
68348: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68349: LD_ADDR_VAR 0 53
68353: PUSH
68354: LD_INT 0
68356: PUSH
68357: LD_INT 0
68359: PUSH
68360: EMPTY
68361: LIST
68362: LIST
68363: PUSH
68364: LD_INT 0
68366: PUSH
68367: LD_INT 1
68369: NEG
68370: PUSH
68371: EMPTY
68372: LIST
68373: LIST
68374: PUSH
68375: LD_INT 1
68377: PUSH
68378: LD_INT 0
68380: PUSH
68381: EMPTY
68382: LIST
68383: LIST
68384: PUSH
68385: LD_INT 1
68387: PUSH
68388: LD_INT 1
68390: PUSH
68391: EMPTY
68392: LIST
68393: LIST
68394: PUSH
68395: LD_INT 0
68397: PUSH
68398: LD_INT 1
68400: PUSH
68401: EMPTY
68402: LIST
68403: LIST
68404: PUSH
68405: LD_INT 1
68407: NEG
68408: PUSH
68409: LD_INT 0
68411: PUSH
68412: EMPTY
68413: LIST
68414: LIST
68415: PUSH
68416: LD_INT 1
68418: NEG
68419: PUSH
68420: LD_INT 1
68422: NEG
68423: PUSH
68424: EMPTY
68425: LIST
68426: LIST
68427: PUSH
68428: LD_INT 1
68430: NEG
68431: PUSH
68432: LD_INT 2
68434: NEG
68435: PUSH
68436: EMPTY
68437: LIST
68438: LIST
68439: PUSH
68440: LD_INT 0
68442: PUSH
68443: LD_INT 2
68445: NEG
68446: PUSH
68447: EMPTY
68448: LIST
68449: LIST
68450: PUSH
68451: LD_INT 1
68453: PUSH
68454: LD_INT 1
68456: NEG
68457: PUSH
68458: EMPTY
68459: LIST
68460: LIST
68461: PUSH
68462: LD_INT 2
68464: PUSH
68465: LD_INT 0
68467: PUSH
68468: EMPTY
68469: LIST
68470: LIST
68471: PUSH
68472: LD_INT 2
68474: PUSH
68475: LD_INT 1
68477: PUSH
68478: EMPTY
68479: LIST
68480: LIST
68481: PUSH
68482: LD_INT 2
68484: PUSH
68485: LD_INT 2
68487: PUSH
68488: EMPTY
68489: LIST
68490: LIST
68491: PUSH
68492: LD_INT 1
68494: PUSH
68495: LD_INT 2
68497: PUSH
68498: EMPTY
68499: LIST
68500: LIST
68501: PUSH
68502: LD_INT 0
68504: PUSH
68505: LD_INT 2
68507: PUSH
68508: EMPTY
68509: LIST
68510: LIST
68511: PUSH
68512: LD_INT 1
68514: NEG
68515: PUSH
68516: LD_INT 1
68518: PUSH
68519: EMPTY
68520: LIST
68521: LIST
68522: PUSH
68523: LD_INT 2
68525: NEG
68526: PUSH
68527: LD_INT 0
68529: PUSH
68530: EMPTY
68531: LIST
68532: LIST
68533: PUSH
68534: LD_INT 2
68536: NEG
68537: PUSH
68538: LD_INT 1
68540: NEG
68541: PUSH
68542: EMPTY
68543: LIST
68544: LIST
68545: PUSH
68546: LD_INT 2
68548: NEG
68549: PUSH
68550: LD_INT 2
68552: NEG
68553: PUSH
68554: EMPTY
68555: LIST
68556: LIST
68557: PUSH
68558: EMPTY
68559: LIST
68560: LIST
68561: LIST
68562: LIST
68563: LIST
68564: LIST
68565: LIST
68566: LIST
68567: LIST
68568: LIST
68569: LIST
68570: LIST
68571: LIST
68572: LIST
68573: LIST
68574: LIST
68575: LIST
68576: LIST
68577: LIST
68578: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68579: LD_ADDR_VAR 0 54
68583: PUSH
68584: LD_INT 0
68586: PUSH
68587: LD_INT 0
68589: PUSH
68590: EMPTY
68591: LIST
68592: LIST
68593: PUSH
68594: LD_INT 0
68596: PUSH
68597: LD_INT 1
68599: NEG
68600: PUSH
68601: EMPTY
68602: LIST
68603: LIST
68604: PUSH
68605: LD_INT 1
68607: PUSH
68608: LD_INT 0
68610: PUSH
68611: EMPTY
68612: LIST
68613: LIST
68614: PUSH
68615: LD_INT 1
68617: PUSH
68618: LD_INT 1
68620: PUSH
68621: EMPTY
68622: LIST
68623: LIST
68624: PUSH
68625: LD_INT 0
68627: PUSH
68628: LD_INT 1
68630: PUSH
68631: EMPTY
68632: LIST
68633: LIST
68634: PUSH
68635: LD_INT 1
68637: NEG
68638: PUSH
68639: LD_INT 0
68641: PUSH
68642: EMPTY
68643: LIST
68644: LIST
68645: PUSH
68646: LD_INT 1
68648: NEG
68649: PUSH
68650: LD_INT 1
68652: NEG
68653: PUSH
68654: EMPTY
68655: LIST
68656: LIST
68657: PUSH
68658: LD_INT 1
68660: NEG
68661: PUSH
68662: LD_INT 2
68664: NEG
68665: PUSH
68666: EMPTY
68667: LIST
68668: LIST
68669: PUSH
68670: LD_INT 0
68672: PUSH
68673: LD_INT 2
68675: NEG
68676: PUSH
68677: EMPTY
68678: LIST
68679: LIST
68680: PUSH
68681: LD_INT 1
68683: PUSH
68684: LD_INT 1
68686: NEG
68687: PUSH
68688: EMPTY
68689: LIST
68690: LIST
68691: PUSH
68692: LD_INT 2
68694: PUSH
68695: LD_INT 0
68697: PUSH
68698: EMPTY
68699: LIST
68700: LIST
68701: PUSH
68702: LD_INT 2
68704: PUSH
68705: LD_INT 1
68707: PUSH
68708: EMPTY
68709: LIST
68710: LIST
68711: PUSH
68712: LD_INT 2
68714: PUSH
68715: LD_INT 2
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: PUSH
68722: LD_INT 1
68724: PUSH
68725: LD_INT 2
68727: PUSH
68728: EMPTY
68729: LIST
68730: LIST
68731: PUSH
68732: LD_INT 0
68734: PUSH
68735: LD_INT 2
68737: PUSH
68738: EMPTY
68739: LIST
68740: LIST
68741: PUSH
68742: LD_INT 1
68744: NEG
68745: PUSH
68746: LD_INT 1
68748: PUSH
68749: EMPTY
68750: LIST
68751: LIST
68752: PUSH
68753: LD_INT 2
68755: NEG
68756: PUSH
68757: LD_INT 0
68759: PUSH
68760: EMPTY
68761: LIST
68762: LIST
68763: PUSH
68764: LD_INT 2
68766: NEG
68767: PUSH
68768: LD_INT 1
68770: NEG
68771: PUSH
68772: EMPTY
68773: LIST
68774: LIST
68775: PUSH
68776: LD_INT 2
68778: NEG
68779: PUSH
68780: LD_INT 2
68782: NEG
68783: PUSH
68784: EMPTY
68785: LIST
68786: LIST
68787: PUSH
68788: EMPTY
68789: LIST
68790: LIST
68791: LIST
68792: LIST
68793: LIST
68794: LIST
68795: LIST
68796: LIST
68797: LIST
68798: LIST
68799: LIST
68800: LIST
68801: LIST
68802: LIST
68803: LIST
68804: LIST
68805: LIST
68806: LIST
68807: LIST
68808: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68809: LD_ADDR_VAR 0 55
68813: PUSH
68814: LD_INT 0
68816: PUSH
68817: LD_INT 0
68819: PUSH
68820: EMPTY
68821: LIST
68822: LIST
68823: PUSH
68824: LD_INT 0
68826: PUSH
68827: LD_INT 1
68829: NEG
68830: PUSH
68831: EMPTY
68832: LIST
68833: LIST
68834: PUSH
68835: LD_INT 1
68837: PUSH
68838: LD_INT 0
68840: PUSH
68841: EMPTY
68842: LIST
68843: LIST
68844: PUSH
68845: LD_INT 1
68847: PUSH
68848: LD_INT 1
68850: PUSH
68851: EMPTY
68852: LIST
68853: LIST
68854: PUSH
68855: LD_INT 0
68857: PUSH
68858: LD_INT 1
68860: PUSH
68861: EMPTY
68862: LIST
68863: LIST
68864: PUSH
68865: LD_INT 1
68867: NEG
68868: PUSH
68869: LD_INT 0
68871: PUSH
68872: EMPTY
68873: LIST
68874: LIST
68875: PUSH
68876: LD_INT 1
68878: NEG
68879: PUSH
68880: LD_INT 1
68882: NEG
68883: PUSH
68884: EMPTY
68885: LIST
68886: LIST
68887: PUSH
68888: LD_INT 1
68890: NEG
68891: PUSH
68892: LD_INT 2
68894: NEG
68895: PUSH
68896: EMPTY
68897: LIST
68898: LIST
68899: PUSH
68900: LD_INT 0
68902: PUSH
68903: LD_INT 2
68905: NEG
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: PUSH
68911: LD_INT 1
68913: PUSH
68914: LD_INT 1
68916: NEG
68917: PUSH
68918: EMPTY
68919: LIST
68920: LIST
68921: PUSH
68922: LD_INT 2
68924: PUSH
68925: LD_INT 0
68927: PUSH
68928: EMPTY
68929: LIST
68930: LIST
68931: PUSH
68932: LD_INT 2
68934: PUSH
68935: LD_INT 1
68937: PUSH
68938: EMPTY
68939: LIST
68940: LIST
68941: PUSH
68942: LD_INT 2
68944: PUSH
68945: LD_INT 2
68947: PUSH
68948: EMPTY
68949: LIST
68950: LIST
68951: PUSH
68952: LD_INT 1
68954: PUSH
68955: LD_INT 2
68957: PUSH
68958: EMPTY
68959: LIST
68960: LIST
68961: PUSH
68962: LD_INT 0
68964: PUSH
68965: LD_INT 2
68967: PUSH
68968: EMPTY
68969: LIST
68970: LIST
68971: PUSH
68972: LD_INT 1
68974: NEG
68975: PUSH
68976: LD_INT 1
68978: PUSH
68979: EMPTY
68980: LIST
68981: LIST
68982: PUSH
68983: LD_INT 2
68985: NEG
68986: PUSH
68987: LD_INT 0
68989: PUSH
68990: EMPTY
68991: LIST
68992: LIST
68993: PUSH
68994: LD_INT 2
68996: NEG
68997: PUSH
68998: LD_INT 1
69000: NEG
69001: PUSH
69002: EMPTY
69003: LIST
69004: LIST
69005: PUSH
69006: LD_INT 2
69008: NEG
69009: PUSH
69010: LD_INT 2
69012: NEG
69013: PUSH
69014: EMPTY
69015: LIST
69016: LIST
69017: PUSH
69018: EMPTY
69019: LIST
69020: LIST
69021: LIST
69022: LIST
69023: LIST
69024: LIST
69025: LIST
69026: LIST
69027: LIST
69028: LIST
69029: LIST
69030: LIST
69031: LIST
69032: LIST
69033: LIST
69034: LIST
69035: LIST
69036: LIST
69037: LIST
69038: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69039: LD_ADDR_VAR 0 56
69043: PUSH
69044: LD_INT 0
69046: PUSH
69047: LD_INT 0
69049: PUSH
69050: EMPTY
69051: LIST
69052: LIST
69053: PUSH
69054: LD_INT 0
69056: PUSH
69057: LD_INT 1
69059: NEG
69060: PUSH
69061: EMPTY
69062: LIST
69063: LIST
69064: PUSH
69065: LD_INT 1
69067: PUSH
69068: LD_INT 0
69070: PUSH
69071: EMPTY
69072: LIST
69073: LIST
69074: PUSH
69075: LD_INT 1
69077: PUSH
69078: LD_INT 1
69080: PUSH
69081: EMPTY
69082: LIST
69083: LIST
69084: PUSH
69085: LD_INT 0
69087: PUSH
69088: LD_INT 1
69090: PUSH
69091: EMPTY
69092: LIST
69093: LIST
69094: PUSH
69095: LD_INT 1
69097: NEG
69098: PUSH
69099: LD_INT 0
69101: PUSH
69102: EMPTY
69103: LIST
69104: LIST
69105: PUSH
69106: LD_INT 1
69108: NEG
69109: PUSH
69110: LD_INT 1
69112: NEG
69113: PUSH
69114: EMPTY
69115: LIST
69116: LIST
69117: PUSH
69118: LD_INT 1
69120: NEG
69121: PUSH
69122: LD_INT 2
69124: NEG
69125: PUSH
69126: EMPTY
69127: LIST
69128: LIST
69129: PUSH
69130: LD_INT 0
69132: PUSH
69133: LD_INT 2
69135: NEG
69136: PUSH
69137: EMPTY
69138: LIST
69139: LIST
69140: PUSH
69141: LD_INT 1
69143: PUSH
69144: LD_INT 1
69146: NEG
69147: PUSH
69148: EMPTY
69149: LIST
69150: LIST
69151: PUSH
69152: LD_INT 2
69154: PUSH
69155: LD_INT 0
69157: PUSH
69158: EMPTY
69159: LIST
69160: LIST
69161: PUSH
69162: LD_INT 2
69164: PUSH
69165: LD_INT 1
69167: PUSH
69168: EMPTY
69169: LIST
69170: LIST
69171: PUSH
69172: LD_INT 2
69174: PUSH
69175: LD_INT 2
69177: PUSH
69178: EMPTY
69179: LIST
69180: LIST
69181: PUSH
69182: LD_INT 1
69184: PUSH
69185: LD_INT 2
69187: PUSH
69188: EMPTY
69189: LIST
69190: LIST
69191: PUSH
69192: LD_INT 0
69194: PUSH
69195: LD_INT 2
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: PUSH
69202: LD_INT 1
69204: NEG
69205: PUSH
69206: LD_INT 1
69208: PUSH
69209: EMPTY
69210: LIST
69211: LIST
69212: PUSH
69213: LD_INT 2
69215: NEG
69216: PUSH
69217: LD_INT 0
69219: PUSH
69220: EMPTY
69221: LIST
69222: LIST
69223: PUSH
69224: LD_INT 2
69226: NEG
69227: PUSH
69228: LD_INT 1
69230: NEG
69231: PUSH
69232: EMPTY
69233: LIST
69234: LIST
69235: PUSH
69236: LD_INT 2
69238: NEG
69239: PUSH
69240: LD_INT 2
69242: NEG
69243: PUSH
69244: EMPTY
69245: LIST
69246: LIST
69247: PUSH
69248: EMPTY
69249: LIST
69250: LIST
69251: LIST
69252: LIST
69253: LIST
69254: LIST
69255: LIST
69256: LIST
69257: LIST
69258: LIST
69259: LIST
69260: LIST
69261: LIST
69262: LIST
69263: LIST
69264: LIST
69265: LIST
69266: LIST
69267: LIST
69268: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69269: LD_ADDR_VAR 0 57
69273: PUSH
69274: LD_INT 0
69276: PUSH
69277: LD_INT 0
69279: PUSH
69280: EMPTY
69281: LIST
69282: LIST
69283: PUSH
69284: LD_INT 0
69286: PUSH
69287: LD_INT 1
69289: NEG
69290: PUSH
69291: EMPTY
69292: LIST
69293: LIST
69294: PUSH
69295: LD_INT 1
69297: PUSH
69298: LD_INT 0
69300: PUSH
69301: EMPTY
69302: LIST
69303: LIST
69304: PUSH
69305: LD_INT 1
69307: PUSH
69308: LD_INT 1
69310: PUSH
69311: EMPTY
69312: LIST
69313: LIST
69314: PUSH
69315: LD_INT 0
69317: PUSH
69318: LD_INT 1
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: PUSH
69325: LD_INT 1
69327: NEG
69328: PUSH
69329: LD_INT 0
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: PUSH
69336: LD_INT 1
69338: NEG
69339: PUSH
69340: LD_INT 1
69342: NEG
69343: PUSH
69344: EMPTY
69345: LIST
69346: LIST
69347: PUSH
69348: LD_INT 1
69350: NEG
69351: PUSH
69352: LD_INT 2
69354: NEG
69355: PUSH
69356: EMPTY
69357: LIST
69358: LIST
69359: PUSH
69360: LD_INT 0
69362: PUSH
69363: LD_INT 2
69365: NEG
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: PUSH
69371: LD_INT 1
69373: PUSH
69374: LD_INT 1
69376: NEG
69377: PUSH
69378: EMPTY
69379: LIST
69380: LIST
69381: PUSH
69382: LD_INT 2
69384: PUSH
69385: LD_INT 0
69387: PUSH
69388: EMPTY
69389: LIST
69390: LIST
69391: PUSH
69392: LD_INT 2
69394: PUSH
69395: LD_INT 1
69397: PUSH
69398: EMPTY
69399: LIST
69400: LIST
69401: PUSH
69402: LD_INT 2
69404: PUSH
69405: LD_INT 2
69407: PUSH
69408: EMPTY
69409: LIST
69410: LIST
69411: PUSH
69412: LD_INT 1
69414: PUSH
69415: LD_INT 2
69417: PUSH
69418: EMPTY
69419: LIST
69420: LIST
69421: PUSH
69422: LD_INT 0
69424: PUSH
69425: LD_INT 2
69427: PUSH
69428: EMPTY
69429: LIST
69430: LIST
69431: PUSH
69432: LD_INT 1
69434: NEG
69435: PUSH
69436: LD_INT 1
69438: PUSH
69439: EMPTY
69440: LIST
69441: LIST
69442: PUSH
69443: LD_INT 2
69445: NEG
69446: PUSH
69447: LD_INT 0
69449: PUSH
69450: EMPTY
69451: LIST
69452: LIST
69453: PUSH
69454: LD_INT 2
69456: NEG
69457: PUSH
69458: LD_INT 1
69460: NEG
69461: PUSH
69462: EMPTY
69463: LIST
69464: LIST
69465: PUSH
69466: LD_INT 2
69468: NEG
69469: PUSH
69470: LD_INT 2
69472: NEG
69473: PUSH
69474: EMPTY
69475: LIST
69476: LIST
69477: PUSH
69478: EMPTY
69479: LIST
69480: LIST
69481: LIST
69482: LIST
69483: LIST
69484: LIST
69485: LIST
69486: LIST
69487: LIST
69488: LIST
69489: LIST
69490: LIST
69491: LIST
69492: LIST
69493: LIST
69494: LIST
69495: LIST
69496: LIST
69497: LIST
69498: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69499: LD_ADDR_VAR 0 58
69503: PUSH
69504: LD_INT 0
69506: PUSH
69507: LD_INT 0
69509: PUSH
69510: EMPTY
69511: LIST
69512: LIST
69513: PUSH
69514: LD_INT 0
69516: PUSH
69517: LD_INT 1
69519: NEG
69520: PUSH
69521: EMPTY
69522: LIST
69523: LIST
69524: PUSH
69525: LD_INT 1
69527: PUSH
69528: LD_INT 0
69530: PUSH
69531: EMPTY
69532: LIST
69533: LIST
69534: PUSH
69535: LD_INT 1
69537: PUSH
69538: LD_INT 1
69540: PUSH
69541: EMPTY
69542: LIST
69543: LIST
69544: PUSH
69545: LD_INT 0
69547: PUSH
69548: LD_INT 1
69550: PUSH
69551: EMPTY
69552: LIST
69553: LIST
69554: PUSH
69555: LD_INT 1
69557: NEG
69558: PUSH
69559: LD_INT 0
69561: PUSH
69562: EMPTY
69563: LIST
69564: LIST
69565: PUSH
69566: LD_INT 1
69568: NEG
69569: PUSH
69570: LD_INT 1
69572: NEG
69573: PUSH
69574: EMPTY
69575: LIST
69576: LIST
69577: PUSH
69578: LD_INT 1
69580: NEG
69581: PUSH
69582: LD_INT 2
69584: NEG
69585: PUSH
69586: EMPTY
69587: LIST
69588: LIST
69589: PUSH
69590: LD_INT 0
69592: PUSH
69593: LD_INT 2
69595: NEG
69596: PUSH
69597: EMPTY
69598: LIST
69599: LIST
69600: PUSH
69601: LD_INT 1
69603: PUSH
69604: LD_INT 1
69606: NEG
69607: PUSH
69608: EMPTY
69609: LIST
69610: LIST
69611: PUSH
69612: LD_INT 2
69614: PUSH
69615: LD_INT 0
69617: PUSH
69618: EMPTY
69619: LIST
69620: LIST
69621: PUSH
69622: LD_INT 2
69624: PUSH
69625: LD_INT 1
69627: PUSH
69628: EMPTY
69629: LIST
69630: LIST
69631: PUSH
69632: LD_INT 2
69634: PUSH
69635: LD_INT 2
69637: PUSH
69638: EMPTY
69639: LIST
69640: LIST
69641: PUSH
69642: LD_INT 1
69644: PUSH
69645: LD_INT 2
69647: PUSH
69648: EMPTY
69649: LIST
69650: LIST
69651: PUSH
69652: LD_INT 0
69654: PUSH
69655: LD_INT 2
69657: PUSH
69658: EMPTY
69659: LIST
69660: LIST
69661: PUSH
69662: LD_INT 1
69664: NEG
69665: PUSH
69666: LD_INT 1
69668: PUSH
69669: EMPTY
69670: LIST
69671: LIST
69672: PUSH
69673: LD_INT 2
69675: NEG
69676: PUSH
69677: LD_INT 0
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: PUSH
69684: LD_INT 2
69686: NEG
69687: PUSH
69688: LD_INT 1
69690: NEG
69691: PUSH
69692: EMPTY
69693: LIST
69694: LIST
69695: PUSH
69696: LD_INT 2
69698: NEG
69699: PUSH
69700: LD_INT 2
69702: NEG
69703: PUSH
69704: EMPTY
69705: LIST
69706: LIST
69707: PUSH
69708: EMPTY
69709: LIST
69710: LIST
69711: LIST
69712: LIST
69713: LIST
69714: LIST
69715: LIST
69716: LIST
69717: LIST
69718: LIST
69719: LIST
69720: LIST
69721: LIST
69722: LIST
69723: LIST
69724: LIST
69725: LIST
69726: LIST
69727: LIST
69728: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
69729: LD_ADDR_VAR 0 59
69733: PUSH
69734: LD_INT 0
69736: PUSH
69737: LD_INT 0
69739: PUSH
69740: EMPTY
69741: LIST
69742: LIST
69743: PUSH
69744: LD_INT 0
69746: PUSH
69747: LD_INT 1
69749: NEG
69750: PUSH
69751: EMPTY
69752: LIST
69753: LIST
69754: PUSH
69755: LD_INT 1
69757: PUSH
69758: LD_INT 0
69760: PUSH
69761: EMPTY
69762: LIST
69763: LIST
69764: PUSH
69765: LD_INT 1
69767: PUSH
69768: LD_INT 1
69770: PUSH
69771: EMPTY
69772: LIST
69773: LIST
69774: PUSH
69775: LD_INT 0
69777: PUSH
69778: LD_INT 1
69780: PUSH
69781: EMPTY
69782: LIST
69783: LIST
69784: PUSH
69785: LD_INT 1
69787: NEG
69788: PUSH
69789: LD_INT 0
69791: PUSH
69792: EMPTY
69793: LIST
69794: LIST
69795: PUSH
69796: LD_INT 1
69798: NEG
69799: PUSH
69800: LD_INT 1
69802: NEG
69803: PUSH
69804: EMPTY
69805: LIST
69806: LIST
69807: PUSH
69808: EMPTY
69809: LIST
69810: LIST
69811: LIST
69812: LIST
69813: LIST
69814: LIST
69815: LIST
69816: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
69817: LD_ADDR_VAR 0 60
69821: PUSH
69822: LD_INT 0
69824: PUSH
69825: LD_INT 0
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: PUSH
69832: LD_INT 0
69834: PUSH
69835: LD_INT 1
69837: NEG
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: PUSH
69843: LD_INT 1
69845: PUSH
69846: LD_INT 0
69848: PUSH
69849: EMPTY
69850: LIST
69851: LIST
69852: PUSH
69853: LD_INT 1
69855: PUSH
69856: LD_INT 1
69858: PUSH
69859: EMPTY
69860: LIST
69861: LIST
69862: PUSH
69863: LD_INT 0
69865: PUSH
69866: LD_INT 1
69868: PUSH
69869: EMPTY
69870: LIST
69871: LIST
69872: PUSH
69873: LD_INT 1
69875: NEG
69876: PUSH
69877: LD_INT 0
69879: PUSH
69880: EMPTY
69881: LIST
69882: LIST
69883: PUSH
69884: LD_INT 1
69886: NEG
69887: PUSH
69888: LD_INT 1
69890: NEG
69891: PUSH
69892: EMPTY
69893: LIST
69894: LIST
69895: PUSH
69896: EMPTY
69897: LIST
69898: LIST
69899: LIST
69900: LIST
69901: LIST
69902: LIST
69903: LIST
69904: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
69905: LD_ADDR_VAR 0 61
69909: PUSH
69910: LD_INT 0
69912: PUSH
69913: LD_INT 0
69915: PUSH
69916: EMPTY
69917: LIST
69918: LIST
69919: PUSH
69920: LD_INT 0
69922: PUSH
69923: LD_INT 1
69925: NEG
69926: PUSH
69927: EMPTY
69928: LIST
69929: LIST
69930: PUSH
69931: LD_INT 1
69933: PUSH
69934: LD_INT 0
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: LD_INT 1
69943: PUSH
69944: LD_INT 1
69946: PUSH
69947: EMPTY
69948: LIST
69949: LIST
69950: PUSH
69951: LD_INT 0
69953: PUSH
69954: LD_INT 1
69956: PUSH
69957: EMPTY
69958: LIST
69959: LIST
69960: PUSH
69961: LD_INT 1
69963: NEG
69964: PUSH
69965: LD_INT 0
69967: PUSH
69968: EMPTY
69969: LIST
69970: LIST
69971: PUSH
69972: LD_INT 1
69974: NEG
69975: PUSH
69976: LD_INT 1
69978: NEG
69979: PUSH
69980: EMPTY
69981: LIST
69982: LIST
69983: PUSH
69984: EMPTY
69985: LIST
69986: LIST
69987: LIST
69988: LIST
69989: LIST
69990: LIST
69991: LIST
69992: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
69993: LD_ADDR_VAR 0 62
69997: PUSH
69998: LD_INT 0
70000: PUSH
70001: LD_INT 0
70003: PUSH
70004: EMPTY
70005: LIST
70006: LIST
70007: PUSH
70008: LD_INT 0
70010: PUSH
70011: LD_INT 1
70013: NEG
70014: PUSH
70015: EMPTY
70016: LIST
70017: LIST
70018: PUSH
70019: LD_INT 1
70021: PUSH
70022: LD_INT 0
70024: PUSH
70025: EMPTY
70026: LIST
70027: LIST
70028: PUSH
70029: LD_INT 1
70031: PUSH
70032: LD_INT 1
70034: PUSH
70035: EMPTY
70036: LIST
70037: LIST
70038: PUSH
70039: LD_INT 0
70041: PUSH
70042: LD_INT 1
70044: PUSH
70045: EMPTY
70046: LIST
70047: LIST
70048: PUSH
70049: LD_INT 1
70051: NEG
70052: PUSH
70053: LD_INT 0
70055: PUSH
70056: EMPTY
70057: LIST
70058: LIST
70059: PUSH
70060: LD_INT 1
70062: NEG
70063: PUSH
70064: LD_INT 1
70066: NEG
70067: PUSH
70068: EMPTY
70069: LIST
70070: LIST
70071: PUSH
70072: EMPTY
70073: LIST
70074: LIST
70075: LIST
70076: LIST
70077: LIST
70078: LIST
70079: LIST
70080: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
70081: LD_ADDR_VAR 0 63
70085: PUSH
70086: LD_INT 0
70088: PUSH
70089: LD_INT 0
70091: PUSH
70092: EMPTY
70093: LIST
70094: LIST
70095: PUSH
70096: LD_INT 0
70098: PUSH
70099: LD_INT 1
70101: NEG
70102: PUSH
70103: EMPTY
70104: LIST
70105: LIST
70106: PUSH
70107: LD_INT 1
70109: PUSH
70110: LD_INT 0
70112: PUSH
70113: EMPTY
70114: LIST
70115: LIST
70116: PUSH
70117: LD_INT 1
70119: PUSH
70120: LD_INT 1
70122: PUSH
70123: EMPTY
70124: LIST
70125: LIST
70126: PUSH
70127: LD_INT 0
70129: PUSH
70130: LD_INT 1
70132: PUSH
70133: EMPTY
70134: LIST
70135: LIST
70136: PUSH
70137: LD_INT 1
70139: NEG
70140: PUSH
70141: LD_INT 0
70143: PUSH
70144: EMPTY
70145: LIST
70146: LIST
70147: PUSH
70148: LD_INT 1
70150: NEG
70151: PUSH
70152: LD_INT 1
70154: NEG
70155: PUSH
70156: EMPTY
70157: LIST
70158: LIST
70159: PUSH
70160: EMPTY
70161: LIST
70162: LIST
70163: LIST
70164: LIST
70165: LIST
70166: LIST
70167: LIST
70168: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
70169: LD_ADDR_VAR 0 64
70173: PUSH
70174: LD_INT 0
70176: PUSH
70177: LD_INT 0
70179: PUSH
70180: EMPTY
70181: LIST
70182: LIST
70183: PUSH
70184: LD_INT 0
70186: PUSH
70187: LD_INT 1
70189: NEG
70190: PUSH
70191: EMPTY
70192: LIST
70193: LIST
70194: PUSH
70195: LD_INT 1
70197: PUSH
70198: LD_INT 0
70200: PUSH
70201: EMPTY
70202: LIST
70203: LIST
70204: PUSH
70205: LD_INT 1
70207: PUSH
70208: LD_INT 1
70210: PUSH
70211: EMPTY
70212: LIST
70213: LIST
70214: PUSH
70215: LD_INT 0
70217: PUSH
70218: LD_INT 1
70220: PUSH
70221: EMPTY
70222: LIST
70223: LIST
70224: PUSH
70225: LD_INT 1
70227: NEG
70228: PUSH
70229: LD_INT 0
70231: PUSH
70232: EMPTY
70233: LIST
70234: LIST
70235: PUSH
70236: LD_INT 1
70238: NEG
70239: PUSH
70240: LD_INT 1
70242: NEG
70243: PUSH
70244: EMPTY
70245: LIST
70246: LIST
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: LIST
70252: LIST
70253: LIST
70254: LIST
70255: LIST
70256: ST_TO_ADDR
// end ; 1 :
70257: GO 76154
70259: LD_INT 1
70261: DOUBLE
70262: EQUAL
70263: IFTRUE 70267
70265: GO 72890
70267: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
70268: LD_ADDR_VAR 0 11
70272: PUSH
70273: LD_INT 1
70275: NEG
70276: PUSH
70277: LD_INT 3
70279: NEG
70280: PUSH
70281: EMPTY
70282: LIST
70283: LIST
70284: PUSH
70285: LD_INT 0
70287: PUSH
70288: LD_INT 3
70290: NEG
70291: PUSH
70292: EMPTY
70293: LIST
70294: LIST
70295: PUSH
70296: LD_INT 1
70298: PUSH
70299: LD_INT 2
70301: NEG
70302: PUSH
70303: EMPTY
70304: LIST
70305: LIST
70306: PUSH
70307: EMPTY
70308: LIST
70309: LIST
70310: LIST
70311: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
70312: LD_ADDR_VAR 0 12
70316: PUSH
70317: LD_INT 2
70319: PUSH
70320: LD_INT 1
70322: NEG
70323: PUSH
70324: EMPTY
70325: LIST
70326: LIST
70327: PUSH
70328: LD_INT 3
70330: PUSH
70331: LD_INT 0
70333: PUSH
70334: EMPTY
70335: LIST
70336: LIST
70337: PUSH
70338: LD_INT 3
70340: PUSH
70341: LD_INT 1
70343: PUSH
70344: EMPTY
70345: LIST
70346: LIST
70347: PUSH
70348: EMPTY
70349: LIST
70350: LIST
70351: LIST
70352: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
70353: LD_ADDR_VAR 0 13
70357: PUSH
70358: LD_INT 3
70360: PUSH
70361: LD_INT 2
70363: PUSH
70364: EMPTY
70365: LIST
70366: LIST
70367: PUSH
70368: LD_INT 3
70370: PUSH
70371: LD_INT 3
70373: PUSH
70374: EMPTY
70375: LIST
70376: LIST
70377: PUSH
70378: LD_INT 2
70380: PUSH
70381: LD_INT 3
70383: PUSH
70384: EMPTY
70385: LIST
70386: LIST
70387: PUSH
70388: EMPTY
70389: LIST
70390: LIST
70391: LIST
70392: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
70393: LD_ADDR_VAR 0 14
70397: PUSH
70398: LD_INT 1
70400: PUSH
70401: LD_INT 3
70403: PUSH
70404: EMPTY
70405: LIST
70406: LIST
70407: PUSH
70408: LD_INT 0
70410: PUSH
70411: LD_INT 3
70413: PUSH
70414: EMPTY
70415: LIST
70416: LIST
70417: PUSH
70418: LD_INT 1
70420: NEG
70421: PUSH
70422: LD_INT 2
70424: PUSH
70425: EMPTY
70426: LIST
70427: LIST
70428: PUSH
70429: EMPTY
70430: LIST
70431: LIST
70432: LIST
70433: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70434: LD_ADDR_VAR 0 15
70438: PUSH
70439: LD_INT 2
70441: NEG
70442: PUSH
70443: LD_INT 1
70445: PUSH
70446: EMPTY
70447: LIST
70448: LIST
70449: PUSH
70450: LD_INT 3
70452: NEG
70453: PUSH
70454: LD_INT 0
70456: PUSH
70457: EMPTY
70458: LIST
70459: LIST
70460: PUSH
70461: LD_INT 3
70463: NEG
70464: PUSH
70465: LD_INT 1
70467: NEG
70468: PUSH
70469: EMPTY
70470: LIST
70471: LIST
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: LIST
70477: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70478: LD_ADDR_VAR 0 16
70482: PUSH
70483: LD_INT 2
70485: NEG
70486: PUSH
70487: LD_INT 3
70489: NEG
70490: PUSH
70491: EMPTY
70492: LIST
70493: LIST
70494: PUSH
70495: LD_INT 3
70497: NEG
70498: PUSH
70499: LD_INT 2
70501: NEG
70502: PUSH
70503: EMPTY
70504: LIST
70505: LIST
70506: PUSH
70507: LD_INT 3
70509: NEG
70510: PUSH
70511: LD_INT 3
70513: NEG
70514: PUSH
70515: EMPTY
70516: LIST
70517: LIST
70518: PUSH
70519: EMPTY
70520: LIST
70521: LIST
70522: LIST
70523: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
70524: LD_ADDR_VAR 0 17
70528: PUSH
70529: LD_INT 1
70531: NEG
70532: PUSH
70533: LD_INT 3
70535: NEG
70536: PUSH
70537: EMPTY
70538: LIST
70539: LIST
70540: PUSH
70541: LD_INT 0
70543: PUSH
70544: LD_INT 3
70546: NEG
70547: PUSH
70548: EMPTY
70549: LIST
70550: LIST
70551: PUSH
70552: LD_INT 1
70554: PUSH
70555: LD_INT 2
70557: NEG
70558: PUSH
70559: EMPTY
70560: LIST
70561: LIST
70562: PUSH
70563: EMPTY
70564: LIST
70565: LIST
70566: LIST
70567: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
70568: LD_ADDR_VAR 0 18
70572: PUSH
70573: LD_INT 2
70575: PUSH
70576: LD_INT 1
70578: NEG
70579: PUSH
70580: EMPTY
70581: LIST
70582: LIST
70583: PUSH
70584: LD_INT 3
70586: PUSH
70587: LD_INT 0
70589: PUSH
70590: EMPTY
70591: LIST
70592: LIST
70593: PUSH
70594: LD_INT 3
70596: PUSH
70597: LD_INT 1
70599: PUSH
70600: EMPTY
70601: LIST
70602: LIST
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: LIST
70608: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
70609: LD_ADDR_VAR 0 19
70613: PUSH
70614: LD_INT 3
70616: PUSH
70617: LD_INT 2
70619: PUSH
70620: EMPTY
70621: LIST
70622: LIST
70623: PUSH
70624: LD_INT 3
70626: PUSH
70627: LD_INT 3
70629: PUSH
70630: EMPTY
70631: LIST
70632: LIST
70633: PUSH
70634: LD_INT 2
70636: PUSH
70637: LD_INT 3
70639: PUSH
70640: EMPTY
70641: LIST
70642: LIST
70643: PUSH
70644: EMPTY
70645: LIST
70646: LIST
70647: LIST
70648: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
70649: LD_ADDR_VAR 0 20
70653: PUSH
70654: LD_INT 1
70656: PUSH
70657: LD_INT 3
70659: PUSH
70660: EMPTY
70661: LIST
70662: LIST
70663: PUSH
70664: LD_INT 0
70666: PUSH
70667: LD_INT 3
70669: PUSH
70670: EMPTY
70671: LIST
70672: LIST
70673: PUSH
70674: LD_INT 1
70676: NEG
70677: PUSH
70678: LD_INT 2
70680: PUSH
70681: EMPTY
70682: LIST
70683: LIST
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: LIST
70689: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70690: LD_ADDR_VAR 0 21
70694: PUSH
70695: LD_INT 2
70697: NEG
70698: PUSH
70699: LD_INT 1
70701: PUSH
70702: EMPTY
70703: LIST
70704: LIST
70705: PUSH
70706: LD_INT 3
70708: NEG
70709: PUSH
70710: LD_INT 0
70712: PUSH
70713: EMPTY
70714: LIST
70715: LIST
70716: PUSH
70717: LD_INT 3
70719: NEG
70720: PUSH
70721: LD_INT 1
70723: NEG
70724: PUSH
70725: EMPTY
70726: LIST
70727: LIST
70728: PUSH
70729: EMPTY
70730: LIST
70731: LIST
70732: LIST
70733: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70734: LD_ADDR_VAR 0 22
70738: PUSH
70739: LD_INT 2
70741: NEG
70742: PUSH
70743: LD_INT 3
70745: NEG
70746: PUSH
70747: EMPTY
70748: LIST
70749: LIST
70750: PUSH
70751: LD_INT 3
70753: NEG
70754: PUSH
70755: LD_INT 2
70757: NEG
70758: PUSH
70759: EMPTY
70760: LIST
70761: LIST
70762: PUSH
70763: LD_INT 3
70765: NEG
70766: PUSH
70767: LD_INT 3
70769: NEG
70770: PUSH
70771: EMPTY
70772: LIST
70773: LIST
70774: PUSH
70775: EMPTY
70776: LIST
70777: LIST
70778: LIST
70779: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
70780: LD_ADDR_VAR 0 23
70784: PUSH
70785: LD_INT 0
70787: PUSH
70788: LD_INT 3
70790: NEG
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: LD_INT 1
70798: NEG
70799: PUSH
70800: LD_INT 4
70802: NEG
70803: PUSH
70804: EMPTY
70805: LIST
70806: LIST
70807: PUSH
70808: LD_INT 1
70810: PUSH
70811: LD_INT 3
70813: NEG
70814: PUSH
70815: EMPTY
70816: LIST
70817: LIST
70818: PUSH
70819: EMPTY
70820: LIST
70821: LIST
70822: LIST
70823: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
70824: LD_ADDR_VAR 0 24
70828: PUSH
70829: LD_INT 3
70831: PUSH
70832: LD_INT 0
70834: PUSH
70835: EMPTY
70836: LIST
70837: LIST
70838: PUSH
70839: LD_INT 3
70841: PUSH
70842: LD_INT 1
70844: NEG
70845: PUSH
70846: EMPTY
70847: LIST
70848: LIST
70849: PUSH
70850: LD_INT 4
70852: PUSH
70853: LD_INT 1
70855: PUSH
70856: EMPTY
70857: LIST
70858: LIST
70859: PUSH
70860: EMPTY
70861: LIST
70862: LIST
70863: LIST
70864: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
70865: LD_ADDR_VAR 0 25
70869: PUSH
70870: LD_INT 3
70872: PUSH
70873: LD_INT 3
70875: PUSH
70876: EMPTY
70877: LIST
70878: LIST
70879: PUSH
70880: LD_INT 4
70882: PUSH
70883: LD_INT 3
70885: PUSH
70886: EMPTY
70887: LIST
70888: LIST
70889: PUSH
70890: LD_INT 3
70892: PUSH
70893: LD_INT 4
70895: PUSH
70896: EMPTY
70897: LIST
70898: LIST
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: LIST
70904: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
70905: LD_ADDR_VAR 0 26
70909: PUSH
70910: LD_INT 0
70912: PUSH
70913: LD_INT 3
70915: PUSH
70916: EMPTY
70917: LIST
70918: LIST
70919: PUSH
70920: LD_INT 1
70922: PUSH
70923: LD_INT 4
70925: PUSH
70926: EMPTY
70927: LIST
70928: LIST
70929: PUSH
70930: LD_INT 1
70932: NEG
70933: PUSH
70934: LD_INT 3
70936: PUSH
70937: EMPTY
70938: LIST
70939: LIST
70940: PUSH
70941: EMPTY
70942: LIST
70943: LIST
70944: LIST
70945: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
70946: LD_ADDR_VAR 0 27
70950: PUSH
70951: LD_INT 3
70953: NEG
70954: PUSH
70955: LD_INT 0
70957: PUSH
70958: EMPTY
70959: LIST
70960: LIST
70961: PUSH
70962: LD_INT 3
70964: NEG
70965: PUSH
70966: LD_INT 1
70968: PUSH
70969: EMPTY
70970: LIST
70971: LIST
70972: PUSH
70973: LD_INT 4
70975: NEG
70976: PUSH
70977: LD_INT 1
70979: NEG
70980: PUSH
70981: EMPTY
70982: LIST
70983: LIST
70984: PUSH
70985: EMPTY
70986: LIST
70987: LIST
70988: LIST
70989: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
70990: LD_ADDR_VAR 0 28
70994: PUSH
70995: LD_INT 3
70997: NEG
70998: PUSH
70999: LD_INT 3
71001: NEG
71002: PUSH
71003: EMPTY
71004: LIST
71005: LIST
71006: PUSH
71007: LD_INT 3
71009: NEG
71010: PUSH
71011: LD_INT 4
71013: NEG
71014: PUSH
71015: EMPTY
71016: LIST
71017: LIST
71018: PUSH
71019: LD_INT 4
71021: NEG
71022: PUSH
71023: LD_INT 3
71025: NEG
71026: PUSH
71027: EMPTY
71028: LIST
71029: LIST
71030: PUSH
71031: EMPTY
71032: LIST
71033: LIST
71034: LIST
71035: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
71036: LD_ADDR_VAR 0 29
71040: PUSH
71041: LD_INT 1
71043: NEG
71044: PUSH
71045: LD_INT 3
71047: NEG
71048: PUSH
71049: EMPTY
71050: LIST
71051: LIST
71052: PUSH
71053: LD_INT 0
71055: PUSH
71056: LD_INT 3
71058: NEG
71059: PUSH
71060: EMPTY
71061: LIST
71062: LIST
71063: PUSH
71064: LD_INT 1
71066: PUSH
71067: LD_INT 2
71069: NEG
71070: PUSH
71071: EMPTY
71072: LIST
71073: LIST
71074: PUSH
71075: LD_INT 1
71077: NEG
71078: PUSH
71079: LD_INT 4
71081: NEG
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: PUSH
71087: LD_INT 0
71089: PUSH
71090: LD_INT 4
71092: NEG
71093: PUSH
71094: EMPTY
71095: LIST
71096: LIST
71097: PUSH
71098: LD_INT 1
71100: PUSH
71101: LD_INT 3
71103: NEG
71104: PUSH
71105: EMPTY
71106: LIST
71107: LIST
71108: PUSH
71109: LD_INT 1
71111: NEG
71112: PUSH
71113: LD_INT 5
71115: NEG
71116: PUSH
71117: EMPTY
71118: LIST
71119: LIST
71120: PUSH
71121: LD_INT 0
71123: PUSH
71124: LD_INT 5
71126: NEG
71127: PUSH
71128: EMPTY
71129: LIST
71130: LIST
71131: PUSH
71132: LD_INT 1
71134: PUSH
71135: LD_INT 4
71137: NEG
71138: PUSH
71139: EMPTY
71140: LIST
71141: LIST
71142: PUSH
71143: LD_INT 1
71145: NEG
71146: PUSH
71147: LD_INT 6
71149: NEG
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: PUSH
71155: LD_INT 0
71157: PUSH
71158: LD_INT 6
71160: NEG
71161: PUSH
71162: EMPTY
71163: LIST
71164: LIST
71165: PUSH
71166: LD_INT 1
71168: PUSH
71169: LD_INT 5
71171: NEG
71172: PUSH
71173: EMPTY
71174: LIST
71175: LIST
71176: PUSH
71177: EMPTY
71178: LIST
71179: LIST
71180: LIST
71181: LIST
71182: LIST
71183: LIST
71184: LIST
71185: LIST
71186: LIST
71187: LIST
71188: LIST
71189: LIST
71190: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
71191: LD_ADDR_VAR 0 30
71195: PUSH
71196: LD_INT 2
71198: PUSH
71199: LD_INT 1
71201: NEG
71202: PUSH
71203: EMPTY
71204: LIST
71205: LIST
71206: PUSH
71207: LD_INT 3
71209: PUSH
71210: LD_INT 0
71212: PUSH
71213: EMPTY
71214: LIST
71215: LIST
71216: PUSH
71217: LD_INT 3
71219: PUSH
71220: LD_INT 1
71222: PUSH
71223: EMPTY
71224: LIST
71225: LIST
71226: PUSH
71227: LD_INT 3
71229: PUSH
71230: LD_INT 1
71232: NEG
71233: PUSH
71234: EMPTY
71235: LIST
71236: LIST
71237: PUSH
71238: LD_INT 4
71240: PUSH
71241: LD_INT 0
71243: PUSH
71244: EMPTY
71245: LIST
71246: LIST
71247: PUSH
71248: LD_INT 4
71250: PUSH
71251: LD_INT 1
71253: PUSH
71254: EMPTY
71255: LIST
71256: LIST
71257: PUSH
71258: LD_INT 4
71260: PUSH
71261: LD_INT 1
71263: NEG
71264: PUSH
71265: EMPTY
71266: LIST
71267: LIST
71268: PUSH
71269: LD_INT 5
71271: PUSH
71272: LD_INT 0
71274: PUSH
71275: EMPTY
71276: LIST
71277: LIST
71278: PUSH
71279: LD_INT 5
71281: PUSH
71282: LD_INT 1
71284: PUSH
71285: EMPTY
71286: LIST
71287: LIST
71288: PUSH
71289: LD_INT 5
71291: PUSH
71292: LD_INT 1
71294: NEG
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 6
71302: PUSH
71303: LD_INT 0
71305: PUSH
71306: EMPTY
71307: LIST
71308: LIST
71309: PUSH
71310: LD_INT 6
71312: PUSH
71313: LD_INT 1
71315: PUSH
71316: EMPTY
71317: LIST
71318: LIST
71319: PUSH
71320: EMPTY
71321: LIST
71322: LIST
71323: LIST
71324: LIST
71325: LIST
71326: LIST
71327: LIST
71328: LIST
71329: LIST
71330: LIST
71331: LIST
71332: LIST
71333: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
71334: LD_ADDR_VAR 0 31
71338: PUSH
71339: LD_INT 3
71341: PUSH
71342: LD_INT 2
71344: PUSH
71345: EMPTY
71346: LIST
71347: LIST
71348: PUSH
71349: LD_INT 3
71351: PUSH
71352: LD_INT 3
71354: PUSH
71355: EMPTY
71356: LIST
71357: LIST
71358: PUSH
71359: LD_INT 2
71361: PUSH
71362: LD_INT 3
71364: PUSH
71365: EMPTY
71366: LIST
71367: LIST
71368: PUSH
71369: LD_INT 4
71371: PUSH
71372: LD_INT 3
71374: PUSH
71375: EMPTY
71376: LIST
71377: LIST
71378: PUSH
71379: LD_INT 4
71381: PUSH
71382: LD_INT 4
71384: PUSH
71385: EMPTY
71386: LIST
71387: LIST
71388: PUSH
71389: LD_INT 3
71391: PUSH
71392: LD_INT 4
71394: PUSH
71395: EMPTY
71396: LIST
71397: LIST
71398: PUSH
71399: LD_INT 5
71401: PUSH
71402: LD_INT 4
71404: PUSH
71405: EMPTY
71406: LIST
71407: LIST
71408: PUSH
71409: LD_INT 5
71411: PUSH
71412: LD_INT 5
71414: PUSH
71415: EMPTY
71416: LIST
71417: LIST
71418: PUSH
71419: LD_INT 4
71421: PUSH
71422: LD_INT 5
71424: PUSH
71425: EMPTY
71426: LIST
71427: LIST
71428: PUSH
71429: LD_INT 6
71431: PUSH
71432: LD_INT 5
71434: PUSH
71435: EMPTY
71436: LIST
71437: LIST
71438: PUSH
71439: LD_INT 6
71441: PUSH
71442: LD_INT 6
71444: PUSH
71445: EMPTY
71446: LIST
71447: LIST
71448: PUSH
71449: LD_INT 5
71451: PUSH
71452: LD_INT 6
71454: PUSH
71455: EMPTY
71456: LIST
71457: LIST
71458: PUSH
71459: EMPTY
71460: LIST
71461: LIST
71462: LIST
71463: LIST
71464: LIST
71465: LIST
71466: LIST
71467: LIST
71468: LIST
71469: LIST
71470: LIST
71471: LIST
71472: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
71473: LD_ADDR_VAR 0 32
71477: PUSH
71478: LD_INT 1
71480: PUSH
71481: LD_INT 3
71483: PUSH
71484: EMPTY
71485: LIST
71486: LIST
71487: PUSH
71488: LD_INT 0
71490: PUSH
71491: LD_INT 3
71493: PUSH
71494: EMPTY
71495: LIST
71496: LIST
71497: PUSH
71498: LD_INT 1
71500: NEG
71501: PUSH
71502: LD_INT 2
71504: PUSH
71505: EMPTY
71506: LIST
71507: LIST
71508: PUSH
71509: LD_INT 1
71511: PUSH
71512: LD_INT 4
71514: PUSH
71515: EMPTY
71516: LIST
71517: LIST
71518: PUSH
71519: LD_INT 0
71521: PUSH
71522: LD_INT 4
71524: PUSH
71525: EMPTY
71526: LIST
71527: LIST
71528: PUSH
71529: LD_INT 1
71531: NEG
71532: PUSH
71533: LD_INT 3
71535: PUSH
71536: EMPTY
71537: LIST
71538: LIST
71539: PUSH
71540: LD_INT 1
71542: PUSH
71543: LD_INT 5
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: PUSH
71550: LD_INT 0
71552: PUSH
71553: LD_INT 5
71555: PUSH
71556: EMPTY
71557: LIST
71558: LIST
71559: PUSH
71560: LD_INT 1
71562: NEG
71563: PUSH
71564: LD_INT 4
71566: PUSH
71567: EMPTY
71568: LIST
71569: LIST
71570: PUSH
71571: LD_INT 1
71573: PUSH
71574: LD_INT 6
71576: PUSH
71577: EMPTY
71578: LIST
71579: LIST
71580: PUSH
71581: LD_INT 0
71583: PUSH
71584: LD_INT 6
71586: PUSH
71587: EMPTY
71588: LIST
71589: LIST
71590: PUSH
71591: LD_INT 1
71593: NEG
71594: PUSH
71595: LD_INT 5
71597: PUSH
71598: EMPTY
71599: LIST
71600: LIST
71601: PUSH
71602: EMPTY
71603: LIST
71604: LIST
71605: LIST
71606: LIST
71607: LIST
71608: LIST
71609: LIST
71610: LIST
71611: LIST
71612: LIST
71613: LIST
71614: LIST
71615: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
71616: LD_ADDR_VAR 0 33
71620: PUSH
71621: LD_INT 2
71623: NEG
71624: PUSH
71625: LD_INT 1
71627: PUSH
71628: EMPTY
71629: LIST
71630: LIST
71631: PUSH
71632: LD_INT 3
71634: NEG
71635: PUSH
71636: LD_INT 0
71638: PUSH
71639: EMPTY
71640: LIST
71641: LIST
71642: PUSH
71643: LD_INT 3
71645: NEG
71646: PUSH
71647: LD_INT 1
71649: NEG
71650: PUSH
71651: EMPTY
71652: LIST
71653: LIST
71654: PUSH
71655: LD_INT 3
71657: NEG
71658: PUSH
71659: LD_INT 1
71661: PUSH
71662: EMPTY
71663: LIST
71664: LIST
71665: PUSH
71666: LD_INT 4
71668: NEG
71669: PUSH
71670: LD_INT 0
71672: PUSH
71673: EMPTY
71674: LIST
71675: LIST
71676: PUSH
71677: LD_INT 4
71679: NEG
71680: PUSH
71681: LD_INT 1
71683: NEG
71684: PUSH
71685: EMPTY
71686: LIST
71687: LIST
71688: PUSH
71689: LD_INT 4
71691: NEG
71692: PUSH
71693: LD_INT 1
71695: PUSH
71696: EMPTY
71697: LIST
71698: LIST
71699: PUSH
71700: LD_INT 5
71702: NEG
71703: PUSH
71704: LD_INT 0
71706: PUSH
71707: EMPTY
71708: LIST
71709: LIST
71710: PUSH
71711: LD_INT 5
71713: NEG
71714: PUSH
71715: LD_INT 1
71717: NEG
71718: PUSH
71719: EMPTY
71720: LIST
71721: LIST
71722: PUSH
71723: LD_INT 5
71725: NEG
71726: PUSH
71727: LD_INT 1
71729: PUSH
71730: EMPTY
71731: LIST
71732: LIST
71733: PUSH
71734: LD_INT 6
71736: NEG
71737: PUSH
71738: LD_INT 0
71740: PUSH
71741: EMPTY
71742: LIST
71743: LIST
71744: PUSH
71745: LD_INT 6
71747: NEG
71748: PUSH
71749: LD_INT 1
71751: NEG
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: PUSH
71757: EMPTY
71758: LIST
71759: LIST
71760: LIST
71761: LIST
71762: LIST
71763: LIST
71764: LIST
71765: LIST
71766: LIST
71767: LIST
71768: LIST
71769: LIST
71770: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
71771: LD_ADDR_VAR 0 34
71775: PUSH
71776: LD_INT 2
71778: NEG
71779: PUSH
71780: LD_INT 3
71782: NEG
71783: PUSH
71784: EMPTY
71785: LIST
71786: LIST
71787: PUSH
71788: LD_INT 3
71790: NEG
71791: PUSH
71792: LD_INT 2
71794: NEG
71795: PUSH
71796: EMPTY
71797: LIST
71798: LIST
71799: PUSH
71800: LD_INT 3
71802: NEG
71803: PUSH
71804: LD_INT 3
71806: NEG
71807: PUSH
71808: EMPTY
71809: LIST
71810: LIST
71811: PUSH
71812: LD_INT 3
71814: NEG
71815: PUSH
71816: LD_INT 4
71818: NEG
71819: PUSH
71820: EMPTY
71821: LIST
71822: LIST
71823: PUSH
71824: LD_INT 4
71826: NEG
71827: PUSH
71828: LD_INT 3
71830: NEG
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: LD_INT 4
71838: NEG
71839: PUSH
71840: LD_INT 4
71842: NEG
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PUSH
71848: LD_INT 4
71850: NEG
71851: PUSH
71852: LD_INT 5
71854: NEG
71855: PUSH
71856: EMPTY
71857: LIST
71858: LIST
71859: PUSH
71860: LD_INT 5
71862: NEG
71863: PUSH
71864: LD_INT 4
71866: NEG
71867: PUSH
71868: EMPTY
71869: LIST
71870: LIST
71871: PUSH
71872: LD_INT 5
71874: NEG
71875: PUSH
71876: LD_INT 5
71878: NEG
71879: PUSH
71880: EMPTY
71881: LIST
71882: LIST
71883: PUSH
71884: LD_INT 5
71886: NEG
71887: PUSH
71888: LD_INT 6
71890: NEG
71891: PUSH
71892: EMPTY
71893: LIST
71894: LIST
71895: PUSH
71896: LD_INT 6
71898: NEG
71899: PUSH
71900: LD_INT 5
71902: NEG
71903: PUSH
71904: EMPTY
71905: LIST
71906: LIST
71907: PUSH
71908: LD_INT 6
71910: NEG
71911: PUSH
71912: LD_INT 6
71914: NEG
71915: PUSH
71916: EMPTY
71917: LIST
71918: LIST
71919: PUSH
71920: EMPTY
71921: LIST
71922: LIST
71923: LIST
71924: LIST
71925: LIST
71926: LIST
71927: LIST
71928: LIST
71929: LIST
71930: LIST
71931: LIST
71932: LIST
71933: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
71934: LD_ADDR_VAR 0 41
71938: PUSH
71939: LD_INT 0
71941: PUSH
71942: LD_INT 2
71944: NEG
71945: PUSH
71946: EMPTY
71947: LIST
71948: LIST
71949: PUSH
71950: LD_INT 1
71952: NEG
71953: PUSH
71954: LD_INT 3
71956: NEG
71957: PUSH
71958: EMPTY
71959: LIST
71960: LIST
71961: PUSH
71962: LD_INT 1
71964: PUSH
71965: LD_INT 2
71967: NEG
71968: PUSH
71969: EMPTY
71970: LIST
71971: LIST
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: LIST
71977: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
71978: LD_ADDR_VAR 0 42
71982: PUSH
71983: LD_INT 2
71985: PUSH
71986: LD_INT 0
71988: PUSH
71989: EMPTY
71990: LIST
71991: LIST
71992: PUSH
71993: LD_INT 2
71995: PUSH
71996: LD_INT 1
71998: NEG
71999: PUSH
72000: EMPTY
72001: LIST
72002: LIST
72003: PUSH
72004: LD_INT 3
72006: PUSH
72007: LD_INT 1
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: PUSH
72014: EMPTY
72015: LIST
72016: LIST
72017: LIST
72018: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
72019: LD_ADDR_VAR 0 43
72023: PUSH
72024: LD_INT 2
72026: PUSH
72027: LD_INT 2
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: PUSH
72034: LD_INT 3
72036: PUSH
72037: LD_INT 2
72039: PUSH
72040: EMPTY
72041: LIST
72042: LIST
72043: PUSH
72044: LD_INT 2
72046: PUSH
72047: LD_INT 3
72049: PUSH
72050: EMPTY
72051: LIST
72052: LIST
72053: PUSH
72054: EMPTY
72055: LIST
72056: LIST
72057: LIST
72058: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
72059: LD_ADDR_VAR 0 44
72063: PUSH
72064: LD_INT 0
72066: PUSH
72067: LD_INT 2
72069: PUSH
72070: EMPTY
72071: LIST
72072: LIST
72073: PUSH
72074: LD_INT 1
72076: PUSH
72077: LD_INT 3
72079: PUSH
72080: EMPTY
72081: LIST
72082: LIST
72083: PUSH
72084: LD_INT 1
72086: NEG
72087: PUSH
72088: LD_INT 2
72090: PUSH
72091: EMPTY
72092: LIST
72093: LIST
72094: PUSH
72095: EMPTY
72096: LIST
72097: LIST
72098: LIST
72099: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72100: LD_ADDR_VAR 0 45
72104: PUSH
72105: LD_INT 2
72107: NEG
72108: PUSH
72109: LD_INT 0
72111: PUSH
72112: EMPTY
72113: LIST
72114: LIST
72115: PUSH
72116: LD_INT 2
72118: NEG
72119: PUSH
72120: LD_INT 1
72122: PUSH
72123: EMPTY
72124: LIST
72125: LIST
72126: PUSH
72127: LD_INT 3
72129: NEG
72130: PUSH
72131: LD_INT 1
72133: NEG
72134: PUSH
72135: EMPTY
72136: LIST
72137: LIST
72138: PUSH
72139: EMPTY
72140: LIST
72141: LIST
72142: LIST
72143: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
72144: LD_ADDR_VAR 0 46
72148: PUSH
72149: LD_INT 2
72151: NEG
72152: PUSH
72153: LD_INT 2
72155: NEG
72156: PUSH
72157: EMPTY
72158: LIST
72159: LIST
72160: PUSH
72161: LD_INT 2
72163: NEG
72164: PUSH
72165: LD_INT 3
72167: NEG
72168: PUSH
72169: EMPTY
72170: LIST
72171: LIST
72172: PUSH
72173: LD_INT 3
72175: NEG
72176: PUSH
72177: LD_INT 2
72179: NEG
72180: PUSH
72181: EMPTY
72182: LIST
72183: LIST
72184: PUSH
72185: EMPTY
72186: LIST
72187: LIST
72188: LIST
72189: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
72190: LD_ADDR_VAR 0 47
72194: PUSH
72195: LD_INT 2
72197: NEG
72198: PUSH
72199: LD_INT 3
72201: NEG
72202: PUSH
72203: EMPTY
72204: LIST
72205: LIST
72206: PUSH
72207: LD_INT 1
72209: NEG
72210: PUSH
72211: LD_INT 3
72213: NEG
72214: PUSH
72215: EMPTY
72216: LIST
72217: LIST
72218: PUSH
72219: EMPTY
72220: LIST
72221: LIST
72222: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
72223: LD_ADDR_VAR 0 48
72227: PUSH
72228: LD_INT 1
72230: PUSH
72231: LD_INT 2
72233: NEG
72234: PUSH
72235: EMPTY
72236: LIST
72237: LIST
72238: PUSH
72239: LD_INT 2
72241: PUSH
72242: LD_INT 1
72244: NEG
72245: PUSH
72246: EMPTY
72247: LIST
72248: LIST
72249: PUSH
72250: EMPTY
72251: LIST
72252: LIST
72253: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
72254: LD_ADDR_VAR 0 49
72258: PUSH
72259: LD_INT 3
72261: PUSH
72262: LD_INT 1
72264: PUSH
72265: EMPTY
72266: LIST
72267: LIST
72268: PUSH
72269: LD_INT 3
72271: PUSH
72272: LD_INT 2
72274: PUSH
72275: EMPTY
72276: LIST
72277: LIST
72278: PUSH
72279: EMPTY
72280: LIST
72281: LIST
72282: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
72283: LD_ADDR_VAR 0 50
72287: PUSH
72288: LD_INT 2
72290: PUSH
72291: LD_INT 3
72293: PUSH
72294: EMPTY
72295: LIST
72296: LIST
72297: PUSH
72298: LD_INT 1
72300: PUSH
72301: LD_INT 3
72303: PUSH
72304: EMPTY
72305: LIST
72306: LIST
72307: PUSH
72308: EMPTY
72309: LIST
72310: LIST
72311: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
72312: LD_ADDR_VAR 0 51
72316: PUSH
72317: LD_INT 1
72319: NEG
72320: PUSH
72321: LD_INT 2
72323: PUSH
72324: EMPTY
72325: LIST
72326: LIST
72327: PUSH
72328: LD_INT 2
72330: NEG
72331: PUSH
72332: LD_INT 1
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: PUSH
72339: EMPTY
72340: LIST
72341: LIST
72342: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
72343: LD_ADDR_VAR 0 52
72347: PUSH
72348: LD_INT 3
72350: NEG
72351: PUSH
72352: LD_INT 1
72354: NEG
72355: PUSH
72356: EMPTY
72357: LIST
72358: LIST
72359: PUSH
72360: LD_INT 3
72362: NEG
72363: PUSH
72364: LD_INT 2
72366: NEG
72367: PUSH
72368: EMPTY
72369: LIST
72370: LIST
72371: PUSH
72372: EMPTY
72373: LIST
72374: LIST
72375: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
72376: LD_ADDR_VAR 0 53
72380: PUSH
72381: LD_INT 1
72383: NEG
72384: PUSH
72385: LD_INT 3
72387: NEG
72388: PUSH
72389: EMPTY
72390: LIST
72391: LIST
72392: PUSH
72393: LD_INT 0
72395: PUSH
72396: LD_INT 3
72398: NEG
72399: PUSH
72400: EMPTY
72401: LIST
72402: LIST
72403: PUSH
72404: LD_INT 1
72406: PUSH
72407: LD_INT 2
72409: NEG
72410: PUSH
72411: EMPTY
72412: LIST
72413: LIST
72414: PUSH
72415: EMPTY
72416: LIST
72417: LIST
72418: LIST
72419: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
72420: LD_ADDR_VAR 0 54
72424: PUSH
72425: LD_INT 2
72427: PUSH
72428: LD_INT 1
72430: NEG
72431: PUSH
72432: EMPTY
72433: LIST
72434: LIST
72435: PUSH
72436: LD_INT 3
72438: PUSH
72439: LD_INT 0
72441: PUSH
72442: EMPTY
72443: LIST
72444: LIST
72445: PUSH
72446: LD_INT 3
72448: PUSH
72449: LD_INT 1
72451: PUSH
72452: EMPTY
72453: LIST
72454: LIST
72455: PUSH
72456: EMPTY
72457: LIST
72458: LIST
72459: LIST
72460: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
72461: LD_ADDR_VAR 0 55
72465: PUSH
72466: LD_INT 3
72468: PUSH
72469: LD_INT 2
72471: PUSH
72472: EMPTY
72473: LIST
72474: LIST
72475: PUSH
72476: LD_INT 3
72478: PUSH
72479: LD_INT 3
72481: PUSH
72482: EMPTY
72483: LIST
72484: LIST
72485: PUSH
72486: LD_INT 2
72488: PUSH
72489: LD_INT 3
72491: PUSH
72492: EMPTY
72493: LIST
72494: LIST
72495: PUSH
72496: EMPTY
72497: LIST
72498: LIST
72499: LIST
72500: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
72501: LD_ADDR_VAR 0 56
72505: PUSH
72506: LD_INT 1
72508: PUSH
72509: LD_INT 3
72511: PUSH
72512: EMPTY
72513: LIST
72514: LIST
72515: PUSH
72516: LD_INT 0
72518: PUSH
72519: LD_INT 3
72521: PUSH
72522: EMPTY
72523: LIST
72524: LIST
72525: PUSH
72526: LD_INT 1
72528: NEG
72529: PUSH
72530: LD_INT 2
72532: PUSH
72533: EMPTY
72534: LIST
72535: LIST
72536: PUSH
72537: EMPTY
72538: LIST
72539: LIST
72540: LIST
72541: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72542: LD_ADDR_VAR 0 57
72546: PUSH
72547: LD_INT 2
72549: NEG
72550: PUSH
72551: LD_INT 1
72553: PUSH
72554: EMPTY
72555: LIST
72556: LIST
72557: PUSH
72558: LD_INT 3
72560: NEG
72561: PUSH
72562: LD_INT 0
72564: PUSH
72565: EMPTY
72566: LIST
72567: LIST
72568: PUSH
72569: LD_INT 3
72571: NEG
72572: PUSH
72573: LD_INT 1
72575: NEG
72576: PUSH
72577: EMPTY
72578: LIST
72579: LIST
72580: PUSH
72581: EMPTY
72582: LIST
72583: LIST
72584: LIST
72585: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72586: LD_ADDR_VAR 0 58
72590: PUSH
72591: LD_INT 2
72593: NEG
72594: PUSH
72595: LD_INT 3
72597: NEG
72598: PUSH
72599: EMPTY
72600: LIST
72601: LIST
72602: PUSH
72603: LD_INT 3
72605: NEG
72606: PUSH
72607: LD_INT 2
72609: NEG
72610: PUSH
72611: EMPTY
72612: LIST
72613: LIST
72614: PUSH
72615: LD_INT 3
72617: NEG
72618: PUSH
72619: LD_INT 3
72621: NEG
72622: PUSH
72623: EMPTY
72624: LIST
72625: LIST
72626: PUSH
72627: EMPTY
72628: LIST
72629: LIST
72630: LIST
72631: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
72632: LD_ADDR_VAR 0 59
72636: PUSH
72637: LD_INT 1
72639: NEG
72640: PUSH
72641: LD_INT 2
72643: NEG
72644: PUSH
72645: EMPTY
72646: LIST
72647: LIST
72648: PUSH
72649: LD_INT 0
72651: PUSH
72652: LD_INT 2
72654: NEG
72655: PUSH
72656: EMPTY
72657: LIST
72658: LIST
72659: PUSH
72660: LD_INT 1
72662: PUSH
72663: LD_INT 1
72665: NEG
72666: PUSH
72667: EMPTY
72668: LIST
72669: LIST
72670: PUSH
72671: EMPTY
72672: LIST
72673: LIST
72674: LIST
72675: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
72676: LD_ADDR_VAR 0 60
72680: PUSH
72681: LD_INT 1
72683: PUSH
72684: LD_INT 1
72686: NEG
72687: PUSH
72688: EMPTY
72689: LIST
72690: LIST
72691: PUSH
72692: LD_INT 2
72694: PUSH
72695: LD_INT 0
72697: PUSH
72698: EMPTY
72699: LIST
72700: LIST
72701: PUSH
72702: LD_INT 2
72704: PUSH
72705: LD_INT 1
72707: PUSH
72708: EMPTY
72709: LIST
72710: LIST
72711: PUSH
72712: EMPTY
72713: LIST
72714: LIST
72715: LIST
72716: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72717: LD_ADDR_VAR 0 61
72721: PUSH
72722: LD_INT 2
72724: PUSH
72725: LD_INT 1
72727: PUSH
72728: EMPTY
72729: LIST
72730: LIST
72731: PUSH
72732: LD_INT 2
72734: PUSH
72735: LD_INT 2
72737: PUSH
72738: EMPTY
72739: LIST
72740: LIST
72741: PUSH
72742: LD_INT 1
72744: PUSH
72745: LD_INT 2
72747: PUSH
72748: EMPTY
72749: LIST
72750: LIST
72751: PUSH
72752: EMPTY
72753: LIST
72754: LIST
72755: LIST
72756: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72757: LD_ADDR_VAR 0 62
72761: PUSH
72762: LD_INT 1
72764: PUSH
72765: LD_INT 2
72767: PUSH
72768: EMPTY
72769: LIST
72770: LIST
72771: PUSH
72772: LD_INT 0
72774: PUSH
72775: LD_INT 2
72777: PUSH
72778: EMPTY
72779: LIST
72780: LIST
72781: PUSH
72782: LD_INT 1
72784: NEG
72785: PUSH
72786: LD_INT 1
72788: PUSH
72789: EMPTY
72790: LIST
72791: LIST
72792: PUSH
72793: EMPTY
72794: LIST
72795: LIST
72796: LIST
72797: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72798: LD_ADDR_VAR 0 63
72802: PUSH
72803: LD_INT 1
72805: NEG
72806: PUSH
72807: LD_INT 1
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: PUSH
72814: LD_INT 2
72816: NEG
72817: PUSH
72818: LD_INT 0
72820: PUSH
72821: EMPTY
72822: LIST
72823: LIST
72824: PUSH
72825: LD_INT 2
72827: NEG
72828: PUSH
72829: LD_INT 1
72831: NEG
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: PUSH
72837: EMPTY
72838: LIST
72839: LIST
72840: LIST
72841: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72842: LD_ADDR_VAR 0 64
72846: PUSH
72847: LD_INT 1
72849: NEG
72850: PUSH
72851: LD_INT 2
72853: NEG
72854: PUSH
72855: EMPTY
72856: LIST
72857: LIST
72858: PUSH
72859: LD_INT 2
72861: NEG
72862: PUSH
72863: LD_INT 1
72865: NEG
72866: PUSH
72867: EMPTY
72868: LIST
72869: LIST
72870: PUSH
72871: LD_INT 2
72873: NEG
72874: PUSH
72875: LD_INT 2
72877: NEG
72878: PUSH
72879: EMPTY
72880: LIST
72881: LIST
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: LIST
72887: ST_TO_ADDR
// end ; 2 :
72888: GO 76154
72890: LD_INT 2
72892: DOUBLE
72893: EQUAL
72894: IFTRUE 72898
72896: GO 76153
72898: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
72899: LD_ADDR_VAR 0 29
72903: PUSH
72904: LD_INT 4
72906: PUSH
72907: LD_INT 0
72909: PUSH
72910: EMPTY
72911: LIST
72912: LIST
72913: PUSH
72914: LD_INT 4
72916: PUSH
72917: LD_INT 1
72919: NEG
72920: PUSH
72921: EMPTY
72922: LIST
72923: LIST
72924: PUSH
72925: LD_INT 5
72927: PUSH
72928: LD_INT 0
72930: PUSH
72931: EMPTY
72932: LIST
72933: LIST
72934: PUSH
72935: LD_INT 5
72937: PUSH
72938: LD_INT 1
72940: PUSH
72941: EMPTY
72942: LIST
72943: LIST
72944: PUSH
72945: LD_INT 4
72947: PUSH
72948: LD_INT 1
72950: PUSH
72951: EMPTY
72952: LIST
72953: LIST
72954: PUSH
72955: LD_INT 3
72957: PUSH
72958: LD_INT 0
72960: PUSH
72961: EMPTY
72962: LIST
72963: LIST
72964: PUSH
72965: LD_INT 3
72967: PUSH
72968: LD_INT 1
72970: NEG
72971: PUSH
72972: EMPTY
72973: LIST
72974: LIST
72975: PUSH
72976: LD_INT 3
72978: PUSH
72979: LD_INT 2
72981: NEG
72982: PUSH
72983: EMPTY
72984: LIST
72985: LIST
72986: PUSH
72987: LD_INT 5
72989: PUSH
72990: LD_INT 2
72992: PUSH
72993: EMPTY
72994: LIST
72995: LIST
72996: PUSH
72997: LD_INT 3
72999: PUSH
73000: LD_INT 3
73002: PUSH
73003: EMPTY
73004: LIST
73005: LIST
73006: PUSH
73007: LD_INT 3
73009: PUSH
73010: LD_INT 2
73012: PUSH
73013: EMPTY
73014: LIST
73015: LIST
73016: PUSH
73017: LD_INT 4
73019: PUSH
73020: LD_INT 3
73022: PUSH
73023: EMPTY
73024: LIST
73025: LIST
73026: PUSH
73027: LD_INT 4
73029: PUSH
73030: LD_INT 4
73032: PUSH
73033: EMPTY
73034: LIST
73035: LIST
73036: PUSH
73037: LD_INT 3
73039: PUSH
73040: LD_INT 4
73042: PUSH
73043: EMPTY
73044: LIST
73045: LIST
73046: PUSH
73047: LD_INT 2
73049: PUSH
73050: LD_INT 3
73052: PUSH
73053: EMPTY
73054: LIST
73055: LIST
73056: PUSH
73057: LD_INT 2
73059: PUSH
73060: LD_INT 2
73062: PUSH
73063: EMPTY
73064: LIST
73065: LIST
73066: PUSH
73067: LD_INT 4
73069: PUSH
73070: LD_INT 2
73072: PUSH
73073: EMPTY
73074: LIST
73075: LIST
73076: PUSH
73077: LD_INT 2
73079: PUSH
73080: LD_INT 4
73082: PUSH
73083: EMPTY
73084: LIST
73085: LIST
73086: PUSH
73087: LD_INT 0
73089: PUSH
73090: LD_INT 4
73092: PUSH
73093: EMPTY
73094: LIST
73095: LIST
73096: PUSH
73097: LD_INT 0
73099: PUSH
73100: LD_INT 3
73102: PUSH
73103: EMPTY
73104: LIST
73105: LIST
73106: PUSH
73107: LD_INT 1
73109: PUSH
73110: LD_INT 4
73112: PUSH
73113: EMPTY
73114: LIST
73115: LIST
73116: PUSH
73117: LD_INT 1
73119: PUSH
73120: LD_INT 5
73122: PUSH
73123: EMPTY
73124: LIST
73125: LIST
73126: PUSH
73127: LD_INT 0
73129: PUSH
73130: LD_INT 5
73132: PUSH
73133: EMPTY
73134: LIST
73135: LIST
73136: PUSH
73137: LD_INT 1
73139: NEG
73140: PUSH
73141: LD_INT 4
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: LD_INT 1
73150: NEG
73151: PUSH
73152: LD_INT 3
73154: PUSH
73155: EMPTY
73156: LIST
73157: LIST
73158: PUSH
73159: LD_INT 2
73161: PUSH
73162: LD_INT 5
73164: PUSH
73165: EMPTY
73166: LIST
73167: LIST
73168: PUSH
73169: LD_INT 2
73171: NEG
73172: PUSH
73173: LD_INT 3
73175: PUSH
73176: EMPTY
73177: LIST
73178: LIST
73179: PUSH
73180: LD_INT 3
73182: NEG
73183: PUSH
73184: LD_INT 0
73186: PUSH
73187: EMPTY
73188: LIST
73189: LIST
73190: PUSH
73191: LD_INT 3
73193: NEG
73194: PUSH
73195: LD_INT 1
73197: NEG
73198: PUSH
73199: EMPTY
73200: LIST
73201: LIST
73202: PUSH
73203: LD_INT 2
73205: NEG
73206: PUSH
73207: LD_INT 0
73209: PUSH
73210: EMPTY
73211: LIST
73212: LIST
73213: PUSH
73214: LD_INT 2
73216: NEG
73217: PUSH
73218: LD_INT 1
73220: PUSH
73221: EMPTY
73222: LIST
73223: LIST
73224: PUSH
73225: LD_INT 3
73227: NEG
73228: PUSH
73229: LD_INT 1
73231: PUSH
73232: EMPTY
73233: LIST
73234: LIST
73235: PUSH
73236: LD_INT 4
73238: NEG
73239: PUSH
73240: LD_INT 0
73242: PUSH
73243: EMPTY
73244: LIST
73245: LIST
73246: PUSH
73247: LD_INT 4
73249: NEG
73250: PUSH
73251: LD_INT 1
73253: NEG
73254: PUSH
73255: EMPTY
73256: LIST
73257: LIST
73258: PUSH
73259: LD_INT 4
73261: NEG
73262: PUSH
73263: LD_INT 2
73265: NEG
73266: PUSH
73267: EMPTY
73268: LIST
73269: LIST
73270: PUSH
73271: LD_INT 2
73273: NEG
73274: PUSH
73275: LD_INT 2
73277: PUSH
73278: EMPTY
73279: LIST
73280: LIST
73281: PUSH
73282: LD_INT 4
73284: NEG
73285: PUSH
73286: LD_INT 4
73288: NEG
73289: PUSH
73290: EMPTY
73291: LIST
73292: LIST
73293: PUSH
73294: LD_INT 4
73296: NEG
73297: PUSH
73298: LD_INT 5
73300: NEG
73301: PUSH
73302: EMPTY
73303: LIST
73304: LIST
73305: PUSH
73306: LD_INT 3
73308: NEG
73309: PUSH
73310: LD_INT 4
73312: NEG
73313: PUSH
73314: EMPTY
73315: LIST
73316: LIST
73317: PUSH
73318: LD_INT 3
73320: NEG
73321: PUSH
73322: LD_INT 3
73324: NEG
73325: PUSH
73326: EMPTY
73327: LIST
73328: LIST
73329: PUSH
73330: LD_INT 4
73332: NEG
73333: PUSH
73334: LD_INT 3
73336: NEG
73337: PUSH
73338: EMPTY
73339: LIST
73340: LIST
73341: PUSH
73342: LD_INT 5
73344: NEG
73345: PUSH
73346: LD_INT 4
73348: NEG
73349: PUSH
73350: EMPTY
73351: LIST
73352: LIST
73353: PUSH
73354: LD_INT 5
73356: NEG
73357: PUSH
73358: LD_INT 5
73360: NEG
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: PUSH
73366: LD_INT 3
73368: NEG
73369: PUSH
73370: LD_INT 5
73372: NEG
73373: PUSH
73374: EMPTY
73375: LIST
73376: LIST
73377: PUSH
73378: LD_INT 5
73380: NEG
73381: PUSH
73382: LD_INT 3
73384: NEG
73385: PUSH
73386: EMPTY
73387: LIST
73388: LIST
73389: PUSH
73390: EMPTY
73391: LIST
73392: LIST
73393: LIST
73394: LIST
73395: LIST
73396: LIST
73397: LIST
73398: LIST
73399: LIST
73400: LIST
73401: LIST
73402: LIST
73403: LIST
73404: LIST
73405: LIST
73406: LIST
73407: LIST
73408: LIST
73409: LIST
73410: LIST
73411: LIST
73412: LIST
73413: LIST
73414: LIST
73415: LIST
73416: LIST
73417: LIST
73418: LIST
73419: LIST
73420: LIST
73421: LIST
73422: LIST
73423: LIST
73424: LIST
73425: LIST
73426: LIST
73427: LIST
73428: LIST
73429: LIST
73430: LIST
73431: LIST
73432: LIST
73433: LIST
73434: LIST
73435: LIST
73436: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
73437: LD_ADDR_VAR 0 30
73441: PUSH
73442: LD_INT 4
73444: PUSH
73445: LD_INT 4
73447: PUSH
73448: EMPTY
73449: LIST
73450: LIST
73451: PUSH
73452: LD_INT 4
73454: PUSH
73455: LD_INT 3
73457: PUSH
73458: EMPTY
73459: LIST
73460: LIST
73461: PUSH
73462: LD_INT 5
73464: PUSH
73465: LD_INT 4
73467: PUSH
73468: EMPTY
73469: LIST
73470: LIST
73471: PUSH
73472: LD_INT 5
73474: PUSH
73475: LD_INT 5
73477: PUSH
73478: EMPTY
73479: LIST
73480: LIST
73481: PUSH
73482: LD_INT 4
73484: PUSH
73485: LD_INT 5
73487: PUSH
73488: EMPTY
73489: LIST
73490: LIST
73491: PUSH
73492: LD_INT 3
73494: PUSH
73495: LD_INT 4
73497: PUSH
73498: EMPTY
73499: LIST
73500: LIST
73501: PUSH
73502: LD_INT 3
73504: PUSH
73505: LD_INT 3
73507: PUSH
73508: EMPTY
73509: LIST
73510: LIST
73511: PUSH
73512: LD_INT 5
73514: PUSH
73515: LD_INT 3
73517: PUSH
73518: EMPTY
73519: LIST
73520: LIST
73521: PUSH
73522: LD_INT 3
73524: PUSH
73525: LD_INT 5
73527: PUSH
73528: EMPTY
73529: LIST
73530: LIST
73531: PUSH
73532: LD_INT 0
73534: PUSH
73535: LD_INT 3
73537: PUSH
73538: EMPTY
73539: LIST
73540: LIST
73541: PUSH
73542: LD_INT 0
73544: PUSH
73545: LD_INT 2
73547: PUSH
73548: EMPTY
73549: LIST
73550: LIST
73551: PUSH
73552: LD_INT 1
73554: PUSH
73555: LD_INT 3
73557: PUSH
73558: EMPTY
73559: LIST
73560: LIST
73561: PUSH
73562: LD_INT 1
73564: PUSH
73565: LD_INT 4
73567: PUSH
73568: EMPTY
73569: LIST
73570: LIST
73571: PUSH
73572: LD_INT 0
73574: PUSH
73575: LD_INT 4
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: PUSH
73582: LD_INT 1
73584: NEG
73585: PUSH
73586: LD_INT 3
73588: PUSH
73589: EMPTY
73590: LIST
73591: LIST
73592: PUSH
73593: LD_INT 1
73595: NEG
73596: PUSH
73597: LD_INT 2
73599: PUSH
73600: EMPTY
73601: LIST
73602: LIST
73603: PUSH
73604: LD_INT 2
73606: PUSH
73607: LD_INT 4
73609: PUSH
73610: EMPTY
73611: LIST
73612: LIST
73613: PUSH
73614: LD_INT 2
73616: NEG
73617: PUSH
73618: LD_INT 2
73620: PUSH
73621: EMPTY
73622: LIST
73623: LIST
73624: PUSH
73625: LD_INT 4
73627: NEG
73628: PUSH
73629: LD_INT 0
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: LD_INT 4
73638: NEG
73639: PUSH
73640: LD_INT 1
73642: NEG
73643: PUSH
73644: EMPTY
73645: LIST
73646: LIST
73647: PUSH
73648: LD_INT 3
73650: NEG
73651: PUSH
73652: LD_INT 0
73654: PUSH
73655: EMPTY
73656: LIST
73657: LIST
73658: PUSH
73659: LD_INT 3
73661: NEG
73662: PUSH
73663: LD_INT 1
73665: PUSH
73666: EMPTY
73667: LIST
73668: LIST
73669: PUSH
73670: LD_INT 4
73672: NEG
73673: PUSH
73674: LD_INT 1
73676: PUSH
73677: EMPTY
73678: LIST
73679: LIST
73680: PUSH
73681: LD_INT 5
73683: NEG
73684: PUSH
73685: LD_INT 0
73687: PUSH
73688: EMPTY
73689: LIST
73690: LIST
73691: PUSH
73692: LD_INT 5
73694: NEG
73695: PUSH
73696: LD_INT 1
73698: NEG
73699: PUSH
73700: EMPTY
73701: LIST
73702: LIST
73703: PUSH
73704: LD_INT 5
73706: NEG
73707: PUSH
73708: LD_INT 2
73710: NEG
73711: PUSH
73712: EMPTY
73713: LIST
73714: LIST
73715: PUSH
73716: LD_INT 3
73718: NEG
73719: PUSH
73720: LD_INT 2
73722: PUSH
73723: EMPTY
73724: LIST
73725: LIST
73726: PUSH
73727: LD_INT 3
73729: NEG
73730: PUSH
73731: LD_INT 3
73733: NEG
73734: PUSH
73735: EMPTY
73736: LIST
73737: LIST
73738: PUSH
73739: LD_INT 3
73741: NEG
73742: PUSH
73743: LD_INT 4
73745: NEG
73746: PUSH
73747: EMPTY
73748: LIST
73749: LIST
73750: PUSH
73751: LD_INT 2
73753: NEG
73754: PUSH
73755: LD_INT 3
73757: NEG
73758: PUSH
73759: EMPTY
73760: LIST
73761: LIST
73762: PUSH
73763: LD_INT 2
73765: NEG
73766: PUSH
73767: LD_INT 2
73769: NEG
73770: PUSH
73771: EMPTY
73772: LIST
73773: LIST
73774: PUSH
73775: LD_INT 3
73777: NEG
73778: PUSH
73779: LD_INT 2
73781: NEG
73782: PUSH
73783: EMPTY
73784: LIST
73785: LIST
73786: PUSH
73787: LD_INT 4
73789: NEG
73790: PUSH
73791: LD_INT 3
73793: NEG
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: PUSH
73799: LD_INT 4
73801: NEG
73802: PUSH
73803: LD_INT 4
73805: NEG
73806: PUSH
73807: EMPTY
73808: LIST
73809: LIST
73810: PUSH
73811: LD_INT 2
73813: NEG
73814: PUSH
73815: LD_INT 4
73817: NEG
73818: PUSH
73819: EMPTY
73820: LIST
73821: LIST
73822: PUSH
73823: LD_INT 4
73825: NEG
73826: PUSH
73827: LD_INT 2
73829: NEG
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: PUSH
73835: LD_INT 0
73837: PUSH
73838: LD_INT 4
73840: NEG
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: LD_INT 0
73848: PUSH
73849: LD_INT 5
73851: NEG
73852: PUSH
73853: EMPTY
73854: LIST
73855: LIST
73856: PUSH
73857: LD_INT 1
73859: PUSH
73860: LD_INT 4
73862: NEG
73863: PUSH
73864: EMPTY
73865: LIST
73866: LIST
73867: PUSH
73868: LD_INT 1
73870: PUSH
73871: LD_INT 3
73873: NEG
73874: PUSH
73875: EMPTY
73876: LIST
73877: LIST
73878: PUSH
73879: LD_INT 0
73881: PUSH
73882: LD_INT 3
73884: NEG
73885: PUSH
73886: EMPTY
73887: LIST
73888: LIST
73889: PUSH
73890: LD_INT 1
73892: NEG
73893: PUSH
73894: LD_INT 4
73896: NEG
73897: PUSH
73898: EMPTY
73899: LIST
73900: LIST
73901: PUSH
73902: LD_INT 1
73904: NEG
73905: PUSH
73906: LD_INT 5
73908: NEG
73909: PUSH
73910: EMPTY
73911: LIST
73912: LIST
73913: PUSH
73914: LD_INT 2
73916: PUSH
73917: LD_INT 3
73919: NEG
73920: PUSH
73921: EMPTY
73922: LIST
73923: LIST
73924: PUSH
73925: LD_INT 2
73927: NEG
73928: PUSH
73929: LD_INT 5
73931: NEG
73932: PUSH
73933: EMPTY
73934: LIST
73935: LIST
73936: PUSH
73937: EMPTY
73938: LIST
73939: LIST
73940: LIST
73941: LIST
73942: LIST
73943: LIST
73944: LIST
73945: LIST
73946: LIST
73947: LIST
73948: LIST
73949: LIST
73950: LIST
73951: LIST
73952: LIST
73953: LIST
73954: LIST
73955: LIST
73956: LIST
73957: LIST
73958: LIST
73959: LIST
73960: LIST
73961: LIST
73962: LIST
73963: LIST
73964: LIST
73965: LIST
73966: LIST
73967: LIST
73968: LIST
73969: LIST
73970: LIST
73971: LIST
73972: LIST
73973: LIST
73974: LIST
73975: LIST
73976: LIST
73977: LIST
73978: LIST
73979: LIST
73980: LIST
73981: LIST
73982: LIST
73983: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
73984: LD_ADDR_VAR 0 31
73988: PUSH
73989: LD_INT 0
73991: PUSH
73992: LD_INT 4
73994: PUSH
73995: EMPTY
73996: LIST
73997: LIST
73998: PUSH
73999: LD_INT 0
74001: PUSH
74002: LD_INT 3
74004: PUSH
74005: EMPTY
74006: LIST
74007: LIST
74008: PUSH
74009: LD_INT 1
74011: PUSH
74012: LD_INT 4
74014: PUSH
74015: EMPTY
74016: LIST
74017: LIST
74018: PUSH
74019: LD_INT 1
74021: PUSH
74022: LD_INT 5
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: LD_INT 0
74031: PUSH
74032: LD_INT 5
74034: PUSH
74035: EMPTY
74036: LIST
74037: LIST
74038: PUSH
74039: LD_INT 1
74041: NEG
74042: PUSH
74043: LD_INT 4
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: PUSH
74050: LD_INT 1
74052: NEG
74053: PUSH
74054: LD_INT 3
74056: PUSH
74057: EMPTY
74058: LIST
74059: LIST
74060: PUSH
74061: LD_INT 2
74063: PUSH
74064: LD_INT 5
74066: PUSH
74067: EMPTY
74068: LIST
74069: LIST
74070: PUSH
74071: LD_INT 2
74073: NEG
74074: PUSH
74075: LD_INT 3
74077: PUSH
74078: EMPTY
74079: LIST
74080: LIST
74081: PUSH
74082: LD_INT 3
74084: NEG
74085: PUSH
74086: LD_INT 0
74088: PUSH
74089: EMPTY
74090: LIST
74091: LIST
74092: PUSH
74093: LD_INT 3
74095: NEG
74096: PUSH
74097: LD_INT 1
74099: NEG
74100: PUSH
74101: EMPTY
74102: LIST
74103: LIST
74104: PUSH
74105: LD_INT 2
74107: NEG
74108: PUSH
74109: LD_INT 0
74111: PUSH
74112: EMPTY
74113: LIST
74114: LIST
74115: PUSH
74116: LD_INT 2
74118: NEG
74119: PUSH
74120: LD_INT 1
74122: PUSH
74123: EMPTY
74124: LIST
74125: LIST
74126: PUSH
74127: LD_INT 3
74129: NEG
74130: PUSH
74131: LD_INT 1
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: PUSH
74138: LD_INT 4
74140: NEG
74141: PUSH
74142: LD_INT 0
74144: PUSH
74145: EMPTY
74146: LIST
74147: LIST
74148: PUSH
74149: LD_INT 4
74151: NEG
74152: PUSH
74153: LD_INT 1
74155: NEG
74156: PUSH
74157: EMPTY
74158: LIST
74159: LIST
74160: PUSH
74161: LD_INT 4
74163: NEG
74164: PUSH
74165: LD_INT 2
74167: NEG
74168: PUSH
74169: EMPTY
74170: LIST
74171: LIST
74172: PUSH
74173: LD_INT 2
74175: NEG
74176: PUSH
74177: LD_INT 2
74179: PUSH
74180: EMPTY
74181: LIST
74182: LIST
74183: PUSH
74184: LD_INT 4
74186: NEG
74187: PUSH
74188: LD_INT 4
74190: NEG
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: PUSH
74196: LD_INT 4
74198: NEG
74199: PUSH
74200: LD_INT 5
74202: NEG
74203: PUSH
74204: EMPTY
74205: LIST
74206: LIST
74207: PUSH
74208: LD_INT 3
74210: NEG
74211: PUSH
74212: LD_INT 4
74214: NEG
74215: PUSH
74216: EMPTY
74217: LIST
74218: LIST
74219: PUSH
74220: LD_INT 3
74222: NEG
74223: PUSH
74224: LD_INT 3
74226: NEG
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PUSH
74232: LD_INT 4
74234: NEG
74235: PUSH
74236: LD_INT 3
74238: NEG
74239: PUSH
74240: EMPTY
74241: LIST
74242: LIST
74243: PUSH
74244: LD_INT 5
74246: NEG
74247: PUSH
74248: LD_INT 4
74250: NEG
74251: PUSH
74252: EMPTY
74253: LIST
74254: LIST
74255: PUSH
74256: LD_INT 5
74258: NEG
74259: PUSH
74260: LD_INT 5
74262: NEG
74263: PUSH
74264: EMPTY
74265: LIST
74266: LIST
74267: PUSH
74268: LD_INT 3
74270: NEG
74271: PUSH
74272: LD_INT 5
74274: NEG
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PUSH
74280: LD_INT 5
74282: NEG
74283: PUSH
74284: LD_INT 3
74286: NEG
74287: PUSH
74288: EMPTY
74289: LIST
74290: LIST
74291: PUSH
74292: LD_INT 0
74294: PUSH
74295: LD_INT 3
74297: NEG
74298: PUSH
74299: EMPTY
74300: LIST
74301: LIST
74302: PUSH
74303: LD_INT 0
74305: PUSH
74306: LD_INT 4
74308: NEG
74309: PUSH
74310: EMPTY
74311: LIST
74312: LIST
74313: PUSH
74314: LD_INT 1
74316: PUSH
74317: LD_INT 3
74319: NEG
74320: PUSH
74321: EMPTY
74322: LIST
74323: LIST
74324: PUSH
74325: LD_INT 1
74327: PUSH
74328: LD_INT 2
74330: NEG
74331: PUSH
74332: EMPTY
74333: LIST
74334: LIST
74335: PUSH
74336: LD_INT 0
74338: PUSH
74339: LD_INT 2
74341: NEG
74342: PUSH
74343: EMPTY
74344: LIST
74345: LIST
74346: PUSH
74347: LD_INT 1
74349: NEG
74350: PUSH
74351: LD_INT 3
74353: NEG
74354: PUSH
74355: EMPTY
74356: LIST
74357: LIST
74358: PUSH
74359: LD_INT 1
74361: NEG
74362: PUSH
74363: LD_INT 4
74365: NEG
74366: PUSH
74367: EMPTY
74368: LIST
74369: LIST
74370: PUSH
74371: LD_INT 2
74373: PUSH
74374: LD_INT 2
74376: NEG
74377: PUSH
74378: EMPTY
74379: LIST
74380: LIST
74381: PUSH
74382: LD_INT 2
74384: NEG
74385: PUSH
74386: LD_INT 4
74388: NEG
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: PUSH
74394: LD_INT 4
74396: PUSH
74397: LD_INT 0
74399: PUSH
74400: EMPTY
74401: LIST
74402: LIST
74403: PUSH
74404: LD_INT 4
74406: PUSH
74407: LD_INT 1
74409: NEG
74410: PUSH
74411: EMPTY
74412: LIST
74413: LIST
74414: PUSH
74415: LD_INT 5
74417: PUSH
74418: LD_INT 0
74420: PUSH
74421: EMPTY
74422: LIST
74423: LIST
74424: PUSH
74425: LD_INT 5
74427: PUSH
74428: LD_INT 1
74430: PUSH
74431: EMPTY
74432: LIST
74433: LIST
74434: PUSH
74435: LD_INT 4
74437: PUSH
74438: LD_INT 1
74440: PUSH
74441: EMPTY
74442: LIST
74443: LIST
74444: PUSH
74445: LD_INT 3
74447: PUSH
74448: LD_INT 0
74450: PUSH
74451: EMPTY
74452: LIST
74453: LIST
74454: PUSH
74455: LD_INT 3
74457: PUSH
74458: LD_INT 1
74460: NEG
74461: PUSH
74462: EMPTY
74463: LIST
74464: LIST
74465: PUSH
74466: LD_INT 3
74468: PUSH
74469: LD_INT 2
74471: NEG
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PUSH
74477: LD_INT 5
74479: PUSH
74480: LD_INT 2
74482: PUSH
74483: EMPTY
74484: LIST
74485: LIST
74486: PUSH
74487: EMPTY
74488: LIST
74489: LIST
74490: LIST
74491: LIST
74492: LIST
74493: LIST
74494: LIST
74495: LIST
74496: LIST
74497: LIST
74498: LIST
74499: LIST
74500: LIST
74501: LIST
74502: LIST
74503: LIST
74504: LIST
74505: LIST
74506: LIST
74507: LIST
74508: LIST
74509: LIST
74510: LIST
74511: LIST
74512: LIST
74513: LIST
74514: LIST
74515: LIST
74516: LIST
74517: LIST
74518: LIST
74519: LIST
74520: LIST
74521: LIST
74522: LIST
74523: LIST
74524: LIST
74525: LIST
74526: LIST
74527: LIST
74528: LIST
74529: LIST
74530: LIST
74531: LIST
74532: LIST
74533: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
74534: LD_ADDR_VAR 0 32
74538: PUSH
74539: LD_INT 4
74541: NEG
74542: PUSH
74543: LD_INT 0
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: PUSH
74550: LD_INT 4
74552: NEG
74553: PUSH
74554: LD_INT 1
74556: NEG
74557: PUSH
74558: EMPTY
74559: LIST
74560: LIST
74561: PUSH
74562: LD_INT 3
74564: NEG
74565: PUSH
74566: LD_INT 0
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: PUSH
74573: LD_INT 3
74575: NEG
74576: PUSH
74577: LD_INT 1
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PUSH
74584: LD_INT 4
74586: NEG
74587: PUSH
74588: LD_INT 1
74590: PUSH
74591: EMPTY
74592: LIST
74593: LIST
74594: PUSH
74595: LD_INT 5
74597: NEG
74598: PUSH
74599: LD_INT 0
74601: PUSH
74602: EMPTY
74603: LIST
74604: LIST
74605: PUSH
74606: LD_INT 5
74608: NEG
74609: PUSH
74610: LD_INT 1
74612: NEG
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: PUSH
74618: LD_INT 5
74620: NEG
74621: PUSH
74622: LD_INT 2
74624: NEG
74625: PUSH
74626: EMPTY
74627: LIST
74628: LIST
74629: PUSH
74630: LD_INT 3
74632: NEG
74633: PUSH
74634: LD_INT 2
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: PUSH
74641: LD_INT 3
74643: NEG
74644: PUSH
74645: LD_INT 3
74647: NEG
74648: PUSH
74649: EMPTY
74650: LIST
74651: LIST
74652: PUSH
74653: LD_INT 3
74655: NEG
74656: PUSH
74657: LD_INT 4
74659: NEG
74660: PUSH
74661: EMPTY
74662: LIST
74663: LIST
74664: PUSH
74665: LD_INT 2
74667: NEG
74668: PUSH
74669: LD_INT 3
74671: NEG
74672: PUSH
74673: EMPTY
74674: LIST
74675: LIST
74676: PUSH
74677: LD_INT 2
74679: NEG
74680: PUSH
74681: LD_INT 2
74683: NEG
74684: PUSH
74685: EMPTY
74686: LIST
74687: LIST
74688: PUSH
74689: LD_INT 3
74691: NEG
74692: PUSH
74693: LD_INT 2
74695: NEG
74696: PUSH
74697: EMPTY
74698: LIST
74699: LIST
74700: PUSH
74701: LD_INT 4
74703: NEG
74704: PUSH
74705: LD_INT 3
74707: NEG
74708: PUSH
74709: EMPTY
74710: LIST
74711: LIST
74712: PUSH
74713: LD_INT 4
74715: NEG
74716: PUSH
74717: LD_INT 4
74719: NEG
74720: PUSH
74721: EMPTY
74722: LIST
74723: LIST
74724: PUSH
74725: LD_INT 2
74727: NEG
74728: PUSH
74729: LD_INT 4
74731: NEG
74732: PUSH
74733: EMPTY
74734: LIST
74735: LIST
74736: PUSH
74737: LD_INT 4
74739: NEG
74740: PUSH
74741: LD_INT 2
74743: NEG
74744: PUSH
74745: EMPTY
74746: LIST
74747: LIST
74748: PUSH
74749: LD_INT 0
74751: PUSH
74752: LD_INT 4
74754: NEG
74755: PUSH
74756: EMPTY
74757: LIST
74758: LIST
74759: PUSH
74760: LD_INT 0
74762: PUSH
74763: LD_INT 5
74765: NEG
74766: PUSH
74767: EMPTY
74768: LIST
74769: LIST
74770: PUSH
74771: LD_INT 1
74773: PUSH
74774: LD_INT 4
74776: NEG
74777: PUSH
74778: EMPTY
74779: LIST
74780: LIST
74781: PUSH
74782: LD_INT 1
74784: PUSH
74785: LD_INT 3
74787: NEG
74788: PUSH
74789: EMPTY
74790: LIST
74791: LIST
74792: PUSH
74793: LD_INT 0
74795: PUSH
74796: LD_INT 3
74798: NEG
74799: PUSH
74800: EMPTY
74801: LIST
74802: LIST
74803: PUSH
74804: LD_INT 1
74806: NEG
74807: PUSH
74808: LD_INT 4
74810: NEG
74811: PUSH
74812: EMPTY
74813: LIST
74814: LIST
74815: PUSH
74816: LD_INT 1
74818: NEG
74819: PUSH
74820: LD_INT 5
74822: NEG
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: PUSH
74828: LD_INT 2
74830: PUSH
74831: LD_INT 3
74833: NEG
74834: PUSH
74835: EMPTY
74836: LIST
74837: LIST
74838: PUSH
74839: LD_INT 2
74841: NEG
74842: PUSH
74843: LD_INT 5
74845: NEG
74846: PUSH
74847: EMPTY
74848: LIST
74849: LIST
74850: PUSH
74851: LD_INT 3
74853: PUSH
74854: LD_INT 0
74856: PUSH
74857: EMPTY
74858: LIST
74859: LIST
74860: PUSH
74861: LD_INT 3
74863: PUSH
74864: LD_INT 1
74866: NEG
74867: PUSH
74868: EMPTY
74869: LIST
74870: LIST
74871: PUSH
74872: LD_INT 4
74874: PUSH
74875: LD_INT 0
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: PUSH
74882: LD_INT 4
74884: PUSH
74885: LD_INT 1
74887: PUSH
74888: EMPTY
74889: LIST
74890: LIST
74891: PUSH
74892: LD_INT 3
74894: PUSH
74895: LD_INT 1
74897: PUSH
74898: EMPTY
74899: LIST
74900: LIST
74901: PUSH
74902: LD_INT 2
74904: PUSH
74905: LD_INT 0
74907: PUSH
74908: EMPTY
74909: LIST
74910: LIST
74911: PUSH
74912: LD_INT 2
74914: PUSH
74915: LD_INT 1
74917: NEG
74918: PUSH
74919: EMPTY
74920: LIST
74921: LIST
74922: PUSH
74923: LD_INT 2
74925: PUSH
74926: LD_INT 2
74928: NEG
74929: PUSH
74930: EMPTY
74931: LIST
74932: LIST
74933: PUSH
74934: LD_INT 4
74936: PUSH
74937: LD_INT 2
74939: PUSH
74940: EMPTY
74941: LIST
74942: LIST
74943: PUSH
74944: LD_INT 4
74946: PUSH
74947: LD_INT 4
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: PUSH
74954: LD_INT 4
74956: PUSH
74957: LD_INT 3
74959: PUSH
74960: EMPTY
74961: LIST
74962: LIST
74963: PUSH
74964: LD_INT 5
74966: PUSH
74967: LD_INT 4
74969: PUSH
74970: EMPTY
74971: LIST
74972: LIST
74973: PUSH
74974: LD_INT 5
74976: PUSH
74977: LD_INT 5
74979: PUSH
74980: EMPTY
74981: LIST
74982: LIST
74983: PUSH
74984: LD_INT 4
74986: PUSH
74987: LD_INT 5
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: PUSH
74994: LD_INT 3
74996: PUSH
74997: LD_INT 4
74999: PUSH
75000: EMPTY
75001: LIST
75002: LIST
75003: PUSH
75004: LD_INT 3
75006: PUSH
75007: LD_INT 3
75009: PUSH
75010: EMPTY
75011: LIST
75012: LIST
75013: PUSH
75014: LD_INT 5
75016: PUSH
75017: LD_INT 3
75019: PUSH
75020: EMPTY
75021: LIST
75022: LIST
75023: PUSH
75024: LD_INT 3
75026: PUSH
75027: LD_INT 5
75029: PUSH
75030: EMPTY
75031: LIST
75032: LIST
75033: PUSH
75034: EMPTY
75035: LIST
75036: LIST
75037: LIST
75038: LIST
75039: LIST
75040: LIST
75041: LIST
75042: LIST
75043: LIST
75044: LIST
75045: LIST
75046: LIST
75047: LIST
75048: LIST
75049: LIST
75050: LIST
75051: LIST
75052: LIST
75053: LIST
75054: LIST
75055: LIST
75056: LIST
75057: LIST
75058: LIST
75059: LIST
75060: LIST
75061: LIST
75062: LIST
75063: LIST
75064: LIST
75065: LIST
75066: LIST
75067: LIST
75068: LIST
75069: LIST
75070: LIST
75071: LIST
75072: LIST
75073: LIST
75074: LIST
75075: LIST
75076: LIST
75077: LIST
75078: LIST
75079: LIST
75080: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
75081: LD_ADDR_VAR 0 33
75085: PUSH
75086: LD_INT 4
75088: NEG
75089: PUSH
75090: LD_INT 4
75092: NEG
75093: PUSH
75094: EMPTY
75095: LIST
75096: LIST
75097: PUSH
75098: LD_INT 4
75100: NEG
75101: PUSH
75102: LD_INT 5
75104: NEG
75105: PUSH
75106: EMPTY
75107: LIST
75108: LIST
75109: PUSH
75110: LD_INT 3
75112: NEG
75113: PUSH
75114: LD_INT 4
75116: NEG
75117: PUSH
75118: EMPTY
75119: LIST
75120: LIST
75121: PUSH
75122: LD_INT 3
75124: NEG
75125: PUSH
75126: LD_INT 3
75128: NEG
75129: PUSH
75130: EMPTY
75131: LIST
75132: LIST
75133: PUSH
75134: LD_INT 4
75136: NEG
75137: PUSH
75138: LD_INT 3
75140: NEG
75141: PUSH
75142: EMPTY
75143: LIST
75144: LIST
75145: PUSH
75146: LD_INT 5
75148: NEG
75149: PUSH
75150: LD_INT 4
75152: NEG
75153: PUSH
75154: EMPTY
75155: LIST
75156: LIST
75157: PUSH
75158: LD_INT 5
75160: NEG
75161: PUSH
75162: LD_INT 5
75164: NEG
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: LD_INT 3
75172: NEG
75173: PUSH
75174: LD_INT 5
75176: NEG
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PUSH
75182: LD_INT 5
75184: NEG
75185: PUSH
75186: LD_INT 3
75188: NEG
75189: PUSH
75190: EMPTY
75191: LIST
75192: LIST
75193: PUSH
75194: LD_INT 0
75196: PUSH
75197: LD_INT 3
75199: NEG
75200: PUSH
75201: EMPTY
75202: LIST
75203: LIST
75204: PUSH
75205: LD_INT 0
75207: PUSH
75208: LD_INT 4
75210: NEG
75211: PUSH
75212: EMPTY
75213: LIST
75214: LIST
75215: PUSH
75216: LD_INT 1
75218: PUSH
75219: LD_INT 3
75221: NEG
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: PUSH
75227: LD_INT 1
75229: PUSH
75230: LD_INT 2
75232: NEG
75233: PUSH
75234: EMPTY
75235: LIST
75236: LIST
75237: PUSH
75238: LD_INT 0
75240: PUSH
75241: LD_INT 2
75243: NEG
75244: PUSH
75245: EMPTY
75246: LIST
75247: LIST
75248: PUSH
75249: LD_INT 1
75251: NEG
75252: PUSH
75253: LD_INT 3
75255: NEG
75256: PUSH
75257: EMPTY
75258: LIST
75259: LIST
75260: PUSH
75261: LD_INT 1
75263: NEG
75264: PUSH
75265: LD_INT 4
75267: NEG
75268: PUSH
75269: EMPTY
75270: LIST
75271: LIST
75272: PUSH
75273: LD_INT 2
75275: PUSH
75276: LD_INT 2
75278: NEG
75279: PUSH
75280: EMPTY
75281: LIST
75282: LIST
75283: PUSH
75284: LD_INT 2
75286: NEG
75287: PUSH
75288: LD_INT 4
75290: NEG
75291: PUSH
75292: EMPTY
75293: LIST
75294: LIST
75295: PUSH
75296: LD_INT 4
75298: PUSH
75299: LD_INT 0
75301: PUSH
75302: EMPTY
75303: LIST
75304: LIST
75305: PUSH
75306: LD_INT 4
75308: PUSH
75309: LD_INT 1
75311: NEG
75312: PUSH
75313: EMPTY
75314: LIST
75315: LIST
75316: PUSH
75317: LD_INT 5
75319: PUSH
75320: LD_INT 0
75322: PUSH
75323: EMPTY
75324: LIST
75325: LIST
75326: PUSH
75327: LD_INT 5
75329: PUSH
75330: LD_INT 1
75332: PUSH
75333: EMPTY
75334: LIST
75335: LIST
75336: PUSH
75337: LD_INT 4
75339: PUSH
75340: LD_INT 1
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: LD_INT 3
75349: PUSH
75350: LD_INT 0
75352: PUSH
75353: EMPTY
75354: LIST
75355: LIST
75356: PUSH
75357: LD_INT 3
75359: PUSH
75360: LD_INT 1
75362: NEG
75363: PUSH
75364: EMPTY
75365: LIST
75366: LIST
75367: PUSH
75368: LD_INT 3
75370: PUSH
75371: LD_INT 2
75373: NEG
75374: PUSH
75375: EMPTY
75376: LIST
75377: LIST
75378: PUSH
75379: LD_INT 5
75381: PUSH
75382: LD_INT 2
75384: PUSH
75385: EMPTY
75386: LIST
75387: LIST
75388: PUSH
75389: LD_INT 3
75391: PUSH
75392: LD_INT 3
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: PUSH
75399: LD_INT 3
75401: PUSH
75402: LD_INT 2
75404: PUSH
75405: EMPTY
75406: LIST
75407: LIST
75408: PUSH
75409: LD_INT 4
75411: PUSH
75412: LD_INT 3
75414: PUSH
75415: EMPTY
75416: LIST
75417: LIST
75418: PUSH
75419: LD_INT 4
75421: PUSH
75422: LD_INT 4
75424: PUSH
75425: EMPTY
75426: LIST
75427: LIST
75428: PUSH
75429: LD_INT 3
75431: PUSH
75432: LD_INT 4
75434: PUSH
75435: EMPTY
75436: LIST
75437: LIST
75438: PUSH
75439: LD_INT 2
75441: PUSH
75442: LD_INT 3
75444: PUSH
75445: EMPTY
75446: LIST
75447: LIST
75448: PUSH
75449: LD_INT 2
75451: PUSH
75452: LD_INT 2
75454: PUSH
75455: EMPTY
75456: LIST
75457: LIST
75458: PUSH
75459: LD_INT 4
75461: PUSH
75462: LD_INT 2
75464: PUSH
75465: EMPTY
75466: LIST
75467: LIST
75468: PUSH
75469: LD_INT 2
75471: PUSH
75472: LD_INT 4
75474: PUSH
75475: EMPTY
75476: LIST
75477: LIST
75478: PUSH
75479: LD_INT 0
75481: PUSH
75482: LD_INT 4
75484: PUSH
75485: EMPTY
75486: LIST
75487: LIST
75488: PUSH
75489: LD_INT 0
75491: PUSH
75492: LD_INT 3
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: LD_INT 1
75501: PUSH
75502: LD_INT 4
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: PUSH
75509: LD_INT 1
75511: PUSH
75512: LD_INT 5
75514: PUSH
75515: EMPTY
75516: LIST
75517: LIST
75518: PUSH
75519: LD_INT 0
75521: PUSH
75522: LD_INT 5
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: PUSH
75529: LD_INT 1
75531: NEG
75532: PUSH
75533: LD_INT 4
75535: PUSH
75536: EMPTY
75537: LIST
75538: LIST
75539: PUSH
75540: LD_INT 1
75542: NEG
75543: PUSH
75544: LD_INT 3
75546: PUSH
75547: EMPTY
75548: LIST
75549: LIST
75550: PUSH
75551: LD_INT 2
75553: PUSH
75554: LD_INT 5
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: PUSH
75561: LD_INT 2
75563: NEG
75564: PUSH
75565: LD_INT 3
75567: PUSH
75568: EMPTY
75569: LIST
75570: LIST
75571: PUSH
75572: EMPTY
75573: LIST
75574: LIST
75575: LIST
75576: LIST
75577: LIST
75578: LIST
75579: LIST
75580: LIST
75581: LIST
75582: LIST
75583: LIST
75584: LIST
75585: LIST
75586: LIST
75587: LIST
75588: LIST
75589: LIST
75590: LIST
75591: LIST
75592: LIST
75593: LIST
75594: LIST
75595: LIST
75596: LIST
75597: LIST
75598: LIST
75599: LIST
75600: LIST
75601: LIST
75602: LIST
75603: LIST
75604: LIST
75605: LIST
75606: LIST
75607: LIST
75608: LIST
75609: LIST
75610: LIST
75611: LIST
75612: LIST
75613: LIST
75614: LIST
75615: LIST
75616: LIST
75617: LIST
75618: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
75619: LD_ADDR_VAR 0 34
75623: PUSH
75624: LD_INT 0
75626: PUSH
75627: LD_INT 4
75629: NEG
75630: PUSH
75631: EMPTY
75632: LIST
75633: LIST
75634: PUSH
75635: LD_INT 0
75637: PUSH
75638: LD_INT 5
75640: NEG
75641: PUSH
75642: EMPTY
75643: LIST
75644: LIST
75645: PUSH
75646: LD_INT 1
75648: PUSH
75649: LD_INT 4
75651: NEG
75652: PUSH
75653: EMPTY
75654: LIST
75655: LIST
75656: PUSH
75657: LD_INT 1
75659: PUSH
75660: LD_INT 3
75662: NEG
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: PUSH
75668: LD_INT 0
75670: PUSH
75671: LD_INT 3
75673: NEG
75674: PUSH
75675: EMPTY
75676: LIST
75677: LIST
75678: PUSH
75679: LD_INT 1
75681: NEG
75682: PUSH
75683: LD_INT 4
75685: NEG
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: PUSH
75691: LD_INT 1
75693: NEG
75694: PUSH
75695: LD_INT 5
75697: NEG
75698: PUSH
75699: EMPTY
75700: LIST
75701: LIST
75702: PUSH
75703: LD_INT 2
75705: PUSH
75706: LD_INT 3
75708: NEG
75709: PUSH
75710: EMPTY
75711: LIST
75712: LIST
75713: PUSH
75714: LD_INT 2
75716: NEG
75717: PUSH
75718: LD_INT 5
75720: NEG
75721: PUSH
75722: EMPTY
75723: LIST
75724: LIST
75725: PUSH
75726: LD_INT 3
75728: PUSH
75729: LD_INT 0
75731: PUSH
75732: EMPTY
75733: LIST
75734: LIST
75735: PUSH
75736: LD_INT 3
75738: PUSH
75739: LD_INT 1
75741: NEG
75742: PUSH
75743: EMPTY
75744: LIST
75745: LIST
75746: PUSH
75747: LD_INT 4
75749: PUSH
75750: LD_INT 0
75752: PUSH
75753: EMPTY
75754: LIST
75755: LIST
75756: PUSH
75757: LD_INT 4
75759: PUSH
75760: LD_INT 1
75762: PUSH
75763: EMPTY
75764: LIST
75765: LIST
75766: PUSH
75767: LD_INT 3
75769: PUSH
75770: LD_INT 1
75772: PUSH
75773: EMPTY
75774: LIST
75775: LIST
75776: PUSH
75777: LD_INT 2
75779: PUSH
75780: LD_INT 0
75782: PUSH
75783: EMPTY
75784: LIST
75785: LIST
75786: PUSH
75787: LD_INT 2
75789: PUSH
75790: LD_INT 1
75792: NEG
75793: PUSH
75794: EMPTY
75795: LIST
75796: LIST
75797: PUSH
75798: LD_INT 2
75800: PUSH
75801: LD_INT 2
75803: NEG
75804: PUSH
75805: EMPTY
75806: LIST
75807: LIST
75808: PUSH
75809: LD_INT 4
75811: PUSH
75812: LD_INT 2
75814: PUSH
75815: EMPTY
75816: LIST
75817: LIST
75818: PUSH
75819: LD_INT 4
75821: PUSH
75822: LD_INT 4
75824: PUSH
75825: EMPTY
75826: LIST
75827: LIST
75828: PUSH
75829: LD_INT 4
75831: PUSH
75832: LD_INT 3
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: PUSH
75839: LD_INT 5
75841: PUSH
75842: LD_INT 4
75844: PUSH
75845: EMPTY
75846: LIST
75847: LIST
75848: PUSH
75849: LD_INT 5
75851: PUSH
75852: LD_INT 5
75854: PUSH
75855: EMPTY
75856: LIST
75857: LIST
75858: PUSH
75859: LD_INT 4
75861: PUSH
75862: LD_INT 5
75864: PUSH
75865: EMPTY
75866: LIST
75867: LIST
75868: PUSH
75869: LD_INT 3
75871: PUSH
75872: LD_INT 4
75874: PUSH
75875: EMPTY
75876: LIST
75877: LIST
75878: PUSH
75879: LD_INT 3
75881: PUSH
75882: LD_INT 3
75884: PUSH
75885: EMPTY
75886: LIST
75887: LIST
75888: PUSH
75889: LD_INT 5
75891: PUSH
75892: LD_INT 3
75894: PUSH
75895: EMPTY
75896: LIST
75897: LIST
75898: PUSH
75899: LD_INT 3
75901: PUSH
75902: LD_INT 5
75904: PUSH
75905: EMPTY
75906: LIST
75907: LIST
75908: PUSH
75909: LD_INT 0
75911: PUSH
75912: LD_INT 3
75914: PUSH
75915: EMPTY
75916: LIST
75917: LIST
75918: PUSH
75919: LD_INT 0
75921: PUSH
75922: LD_INT 2
75924: PUSH
75925: EMPTY
75926: LIST
75927: LIST
75928: PUSH
75929: LD_INT 1
75931: PUSH
75932: LD_INT 3
75934: PUSH
75935: EMPTY
75936: LIST
75937: LIST
75938: PUSH
75939: LD_INT 1
75941: PUSH
75942: LD_INT 4
75944: PUSH
75945: EMPTY
75946: LIST
75947: LIST
75948: PUSH
75949: LD_INT 0
75951: PUSH
75952: LD_INT 4
75954: PUSH
75955: EMPTY
75956: LIST
75957: LIST
75958: PUSH
75959: LD_INT 1
75961: NEG
75962: PUSH
75963: LD_INT 3
75965: PUSH
75966: EMPTY
75967: LIST
75968: LIST
75969: PUSH
75970: LD_INT 1
75972: NEG
75973: PUSH
75974: LD_INT 2
75976: PUSH
75977: EMPTY
75978: LIST
75979: LIST
75980: PUSH
75981: LD_INT 2
75983: PUSH
75984: LD_INT 4
75986: PUSH
75987: EMPTY
75988: LIST
75989: LIST
75990: PUSH
75991: LD_INT 2
75993: NEG
75994: PUSH
75995: LD_INT 2
75997: PUSH
75998: EMPTY
75999: LIST
76000: LIST
76001: PUSH
76002: LD_INT 4
76004: NEG
76005: PUSH
76006: LD_INT 0
76008: PUSH
76009: EMPTY
76010: LIST
76011: LIST
76012: PUSH
76013: LD_INT 4
76015: NEG
76016: PUSH
76017: LD_INT 1
76019: NEG
76020: PUSH
76021: EMPTY
76022: LIST
76023: LIST
76024: PUSH
76025: LD_INT 3
76027: NEG
76028: PUSH
76029: LD_INT 0
76031: PUSH
76032: EMPTY
76033: LIST
76034: LIST
76035: PUSH
76036: LD_INT 3
76038: NEG
76039: PUSH
76040: LD_INT 1
76042: PUSH
76043: EMPTY
76044: LIST
76045: LIST
76046: PUSH
76047: LD_INT 4
76049: NEG
76050: PUSH
76051: LD_INT 1
76053: PUSH
76054: EMPTY
76055: LIST
76056: LIST
76057: PUSH
76058: LD_INT 5
76060: NEG
76061: PUSH
76062: LD_INT 0
76064: PUSH
76065: EMPTY
76066: LIST
76067: LIST
76068: PUSH
76069: LD_INT 5
76071: NEG
76072: PUSH
76073: LD_INT 1
76075: NEG
76076: PUSH
76077: EMPTY
76078: LIST
76079: LIST
76080: PUSH
76081: LD_INT 5
76083: NEG
76084: PUSH
76085: LD_INT 2
76087: NEG
76088: PUSH
76089: EMPTY
76090: LIST
76091: LIST
76092: PUSH
76093: LD_INT 3
76095: NEG
76096: PUSH
76097: LD_INT 2
76099: PUSH
76100: EMPTY
76101: LIST
76102: LIST
76103: PUSH
76104: EMPTY
76105: LIST
76106: LIST
76107: LIST
76108: LIST
76109: LIST
76110: LIST
76111: LIST
76112: LIST
76113: LIST
76114: LIST
76115: LIST
76116: LIST
76117: LIST
76118: LIST
76119: LIST
76120: LIST
76121: LIST
76122: LIST
76123: LIST
76124: LIST
76125: LIST
76126: LIST
76127: LIST
76128: LIST
76129: LIST
76130: LIST
76131: LIST
76132: LIST
76133: LIST
76134: LIST
76135: LIST
76136: LIST
76137: LIST
76138: LIST
76139: LIST
76140: LIST
76141: LIST
76142: LIST
76143: LIST
76144: LIST
76145: LIST
76146: LIST
76147: LIST
76148: LIST
76149: LIST
76150: ST_TO_ADDR
// end ; end ;
76151: GO 76154
76153: POP
// case btype of b_depot , b_warehouse :
76154: LD_VAR 0 1
76158: PUSH
76159: LD_INT 0
76161: DOUBLE
76162: EQUAL
76163: IFTRUE 76173
76165: LD_INT 1
76167: DOUBLE
76168: EQUAL
76169: IFTRUE 76173
76171: GO 76374
76173: POP
// case nation of nation_american :
76174: LD_VAR 0 5
76178: PUSH
76179: LD_INT 1
76181: DOUBLE
76182: EQUAL
76183: IFTRUE 76187
76185: GO 76243
76187: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
76188: LD_ADDR_VAR 0 9
76192: PUSH
76193: LD_VAR 0 11
76197: PUSH
76198: LD_VAR 0 12
76202: PUSH
76203: LD_VAR 0 13
76207: PUSH
76208: LD_VAR 0 14
76212: PUSH
76213: LD_VAR 0 15
76217: PUSH
76218: LD_VAR 0 16
76222: PUSH
76223: EMPTY
76224: LIST
76225: LIST
76226: LIST
76227: LIST
76228: LIST
76229: LIST
76230: PUSH
76231: LD_VAR 0 4
76235: PUSH
76236: LD_INT 1
76238: PLUS
76239: ARRAY
76240: ST_TO_ADDR
76241: GO 76372
76243: LD_INT 2
76245: DOUBLE
76246: EQUAL
76247: IFTRUE 76251
76249: GO 76307
76251: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
76252: LD_ADDR_VAR 0 9
76256: PUSH
76257: LD_VAR 0 17
76261: PUSH
76262: LD_VAR 0 18
76266: PUSH
76267: LD_VAR 0 19
76271: PUSH
76272: LD_VAR 0 20
76276: PUSH
76277: LD_VAR 0 21
76281: PUSH
76282: LD_VAR 0 22
76286: PUSH
76287: EMPTY
76288: LIST
76289: LIST
76290: LIST
76291: LIST
76292: LIST
76293: LIST
76294: PUSH
76295: LD_VAR 0 4
76299: PUSH
76300: LD_INT 1
76302: PLUS
76303: ARRAY
76304: ST_TO_ADDR
76305: GO 76372
76307: LD_INT 3
76309: DOUBLE
76310: EQUAL
76311: IFTRUE 76315
76313: GO 76371
76315: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
76316: LD_ADDR_VAR 0 9
76320: PUSH
76321: LD_VAR 0 23
76325: PUSH
76326: LD_VAR 0 24
76330: PUSH
76331: LD_VAR 0 25
76335: PUSH
76336: LD_VAR 0 26
76340: PUSH
76341: LD_VAR 0 27
76345: PUSH
76346: LD_VAR 0 28
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: LIST
76355: LIST
76356: LIST
76357: LIST
76358: PUSH
76359: LD_VAR 0 4
76363: PUSH
76364: LD_INT 1
76366: PLUS
76367: ARRAY
76368: ST_TO_ADDR
76369: GO 76372
76371: POP
76372: GO 76921
76374: LD_INT 2
76376: DOUBLE
76377: EQUAL
76378: IFTRUE 76388
76380: LD_INT 3
76382: DOUBLE
76383: EQUAL
76384: IFTRUE 76388
76386: GO 76444
76388: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
76389: LD_ADDR_VAR 0 9
76393: PUSH
76394: LD_VAR 0 29
76398: PUSH
76399: LD_VAR 0 30
76403: PUSH
76404: LD_VAR 0 31
76408: PUSH
76409: LD_VAR 0 32
76413: PUSH
76414: LD_VAR 0 33
76418: PUSH
76419: LD_VAR 0 34
76423: PUSH
76424: EMPTY
76425: LIST
76426: LIST
76427: LIST
76428: LIST
76429: LIST
76430: LIST
76431: PUSH
76432: LD_VAR 0 4
76436: PUSH
76437: LD_INT 1
76439: PLUS
76440: ARRAY
76441: ST_TO_ADDR
76442: GO 76921
76444: LD_INT 16
76446: DOUBLE
76447: EQUAL
76448: IFTRUE 76500
76450: LD_INT 17
76452: DOUBLE
76453: EQUAL
76454: IFTRUE 76500
76456: LD_INT 18
76458: DOUBLE
76459: EQUAL
76460: IFTRUE 76500
76462: LD_INT 19
76464: DOUBLE
76465: EQUAL
76466: IFTRUE 76500
76468: LD_INT 20
76470: DOUBLE
76471: EQUAL
76472: IFTRUE 76500
76474: LD_INT 21
76476: DOUBLE
76477: EQUAL
76478: IFTRUE 76500
76480: LD_INT 23
76482: DOUBLE
76483: EQUAL
76484: IFTRUE 76500
76486: LD_INT 24
76488: DOUBLE
76489: EQUAL
76490: IFTRUE 76500
76492: LD_INT 25
76494: DOUBLE
76495: EQUAL
76496: IFTRUE 76500
76498: GO 76556
76500: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
76501: LD_ADDR_VAR 0 9
76505: PUSH
76506: LD_VAR 0 35
76510: PUSH
76511: LD_VAR 0 36
76515: PUSH
76516: LD_VAR 0 37
76520: PUSH
76521: LD_VAR 0 38
76525: PUSH
76526: LD_VAR 0 39
76530: PUSH
76531: LD_VAR 0 40
76535: PUSH
76536: EMPTY
76537: LIST
76538: LIST
76539: LIST
76540: LIST
76541: LIST
76542: LIST
76543: PUSH
76544: LD_VAR 0 4
76548: PUSH
76549: LD_INT 1
76551: PLUS
76552: ARRAY
76553: ST_TO_ADDR
76554: GO 76921
76556: LD_INT 6
76558: DOUBLE
76559: EQUAL
76560: IFTRUE 76612
76562: LD_INT 7
76564: DOUBLE
76565: EQUAL
76566: IFTRUE 76612
76568: LD_INT 8
76570: DOUBLE
76571: EQUAL
76572: IFTRUE 76612
76574: LD_INT 13
76576: DOUBLE
76577: EQUAL
76578: IFTRUE 76612
76580: LD_INT 12
76582: DOUBLE
76583: EQUAL
76584: IFTRUE 76612
76586: LD_INT 15
76588: DOUBLE
76589: EQUAL
76590: IFTRUE 76612
76592: LD_INT 11
76594: DOUBLE
76595: EQUAL
76596: IFTRUE 76612
76598: LD_INT 14
76600: DOUBLE
76601: EQUAL
76602: IFTRUE 76612
76604: LD_INT 10
76606: DOUBLE
76607: EQUAL
76608: IFTRUE 76612
76610: GO 76668
76612: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
76613: LD_ADDR_VAR 0 9
76617: PUSH
76618: LD_VAR 0 41
76622: PUSH
76623: LD_VAR 0 42
76627: PUSH
76628: LD_VAR 0 43
76632: PUSH
76633: LD_VAR 0 44
76637: PUSH
76638: LD_VAR 0 45
76642: PUSH
76643: LD_VAR 0 46
76647: PUSH
76648: EMPTY
76649: LIST
76650: LIST
76651: LIST
76652: LIST
76653: LIST
76654: LIST
76655: PUSH
76656: LD_VAR 0 4
76660: PUSH
76661: LD_INT 1
76663: PLUS
76664: ARRAY
76665: ST_TO_ADDR
76666: GO 76921
76668: LD_INT 36
76670: DOUBLE
76671: EQUAL
76672: IFTRUE 76676
76674: GO 76732
76676: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
76677: LD_ADDR_VAR 0 9
76681: PUSH
76682: LD_VAR 0 47
76686: PUSH
76687: LD_VAR 0 48
76691: PUSH
76692: LD_VAR 0 49
76696: PUSH
76697: LD_VAR 0 50
76701: PUSH
76702: LD_VAR 0 51
76706: PUSH
76707: LD_VAR 0 52
76711: PUSH
76712: EMPTY
76713: LIST
76714: LIST
76715: LIST
76716: LIST
76717: LIST
76718: LIST
76719: PUSH
76720: LD_VAR 0 4
76724: PUSH
76725: LD_INT 1
76727: PLUS
76728: ARRAY
76729: ST_TO_ADDR
76730: GO 76921
76732: LD_INT 4
76734: DOUBLE
76735: EQUAL
76736: IFTRUE 76758
76738: LD_INT 5
76740: DOUBLE
76741: EQUAL
76742: IFTRUE 76758
76744: LD_INT 34
76746: DOUBLE
76747: EQUAL
76748: IFTRUE 76758
76750: LD_INT 37
76752: DOUBLE
76753: EQUAL
76754: IFTRUE 76758
76756: GO 76814
76758: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
76759: LD_ADDR_VAR 0 9
76763: PUSH
76764: LD_VAR 0 53
76768: PUSH
76769: LD_VAR 0 54
76773: PUSH
76774: LD_VAR 0 55
76778: PUSH
76779: LD_VAR 0 56
76783: PUSH
76784: LD_VAR 0 57
76788: PUSH
76789: LD_VAR 0 58
76793: PUSH
76794: EMPTY
76795: LIST
76796: LIST
76797: LIST
76798: LIST
76799: LIST
76800: LIST
76801: PUSH
76802: LD_VAR 0 4
76806: PUSH
76807: LD_INT 1
76809: PLUS
76810: ARRAY
76811: ST_TO_ADDR
76812: GO 76921
76814: LD_INT 31
76816: DOUBLE
76817: EQUAL
76818: IFTRUE 76864
76820: LD_INT 32
76822: DOUBLE
76823: EQUAL
76824: IFTRUE 76864
76826: LD_INT 33
76828: DOUBLE
76829: EQUAL
76830: IFTRUE 76864
76832: LD_INT 27
76834: DOUBLE
76835: EQUAL
76836: IFTRUE 76864
76838: LD_INT 26
76840: DOUBLE
76841: EQUAL
76842: IFTRUE 76864
76844: LD_INT 28
76846: DOUBLE
76847: EQUAL
76848: IFTRUE 76864
76850: LD_INT 29
76852: DOUBLE
76853: EQUAL
76854: IFTRUE 76864
76856: LD_INT 30
76858: DOUBLE
76859: EQUAL
76860: IFTRUE 76864
76862: GO 76920
76864: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
76865: LD_ADDR_VAR 0 9
76869: PUSH
76870: LD_VAR 0 59
76874: PUSH
76875: LD_VAR 0 60
76879: PUSH
76880: LD_VAR 0 61
76884: PUSH
76885: LD_VAR 0 62
76889: PUSH
76890: LD_VAR 0 63
76894: PUSH
76895: LD_VAR 0 64
76899: PUSH
76900: EMPTY
76901: LIST
76902: LIST
76903: LIST
76904: LIST
76905: LIST
76906: LIST
76907: PUSH
76908: LD_VAR 0 4
76912: PUSH
76913: LD_INT 1
76915: PLUS
76916: ARRAY
76917: ST_TO_ADDR
76918: GO 76921
76920: POP
// temp_list2 = [ ] ;
76921: LD_ADDR_VAR 0 10
76925: PUSH
76926: EMPTY
76927: ST_TO_ADDR
// for i in temp_list do
76928: LD_ADDR_VAR 0 8
76932: PUSH
76933: LD_VAR 0 9
76937: PUSH
76938: FOR_IN
76939: IFFALSE 76991
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
76941: LD_ADDR_VAR 0 10
76945: PUSH
76946: LD_VAR 0 10
76950: PUSH
76951: LD_VAR 0 8
76955: PUSH
76956: LD_INT 1
76958: ARRAY
76959: PUSH
76960: LD_VAR 0 2
76964: PLUS
76965: PUSH
76966: LD_VAR 0 8
76970: PUSH
76971: LD_INT 2
76973: ARRAY
76974: PUSH
76975: LD_VAR 0 3
76979: PLUS
76980: PUSH
76981: EMPTY
76982: LIST
76983: LIST
76984: PUSH
76985: EMPTY
76986: LIST
76987: ADD
76988: ST_TO_ADDR
76989: GO 76938
76991: POP
76992: POP
// result = temp_list2 ;
76993: LD_ADDR_VAR 0 7
76997: PUSH
76998: LD_VAR 0 10
77002: ST_TO_ADDR
// end ;
77003: LD_VAR 0 7
77007: RET
// export function EnemyInRange ( unit , dist ) ; begin
77008: LD_INT 0
77010: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
77011: LD_ADDR_VAR 0 3
77015: PUSH
77016: LD_VAR 0 1
77020: PPUSH
77021: CALL_OW 255
77025: PPUSH
77026: LD_VAR 0 1
77030: PPUSH
77031: CALL_OW 250
77035: PPUSH
77036: LD_VAR 0 1
77040: PPUSH
77041: CALL_OW 251
77045: PPUSH
77046: LD_VAR 0 2
77050: PPUSH
77051: CALL 51351 0 4
77055: PUSH
77056: LD_INT 4
77058: ARRAY
77059: ST_TO_ADDR
// end ;
77060: LD_VAR 0 3
77064: RET
// export function PlayerSeeMe ( unit ) ; begin
77065: LD_INT 0
77067: PPUSH
// result := See ( your_side , unit ) ;
77068: LD_ADDR_VAR 0 2
77072: PUSH
77073: LD_OWVAR 2
77077: PPUSH
77078: LD_VAR 0 1
77082: PPUSH
77083: CALL_OW 292
77087: ST_TO_ADDR
// end ;
77088: LD_VAR 0 2
77092: RET
// export function ReverseDir ( unit ) ; begin
77093: LD_INT 0
77095: PPUSH
// if not unit then
77096: LD_VAR 0 1
77100: NOT
77101: IFFALSE 77105
// exit ;
77103: GO 77151
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
77105: LD_ADDR_VAR 0 2
77109: PUSH
77110: LD_INT 3
77112: PUSH
77113: LD_INT 4
77115: PUSH
77116: LD_INT 5
77118: PUSH
77119: LD_INT 0
77121: PUSH
77122: LD_INT 1
77124: PUSH
77125: LD_INT 2
77127: PUSH
77128: EMPTY
77129: LIST
77130: LIST
77131: LIST
77132: LIST
77133: LIST
77134: LIST
77135: PUSH
77136: LD_VAR 0 1
77140: PPUSH
77141: CALL_OW 254
77145: PUSH
77146: LD_INT 1
77148: PLUS
77149: ARRAY
77150: ST_TO_ADDR
// end ;
77151: LD_VAR 0 2
77155: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
77156: LD_INT 0
77158: PPUSH
77159: PPUSH
77160: PPUSH
77161: PPUSH
77162: PPUSH
// if not hexes then
77163: LD_VAR 0 2
77167: NOT
77168: IFFALSE 77172
// exit ;
77170: GO 77320
// dist := 9999 ;
77172: LD_ADDR_VAR 0 5
77176: PUSH
77177: LD_INT 9999
77179: ST_TO_ADDR
// for i = 1 to hexes do
77180: LD_ADDR_VAR 0 4
77184: PUSH
77185: DOUBLE
77186: LD_INT 1
77188: DEC
77189: ST_TO_ADDR
77190: LD_VAR 0 2
77194: PUSH
77195: FOR_TO
77196: IFFALSE 77308
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
77198: LD_VAR 0 1
77202: PPUSH
77203: LD_VAR 0 2
77207: PUSH
77208: LD_VAR 0 4
77212: ARRAY
77213: PUSH
77214: LD_INT 1
77216: ARRAY
77217: PPUSH
77218: LD_VAR 0 2
77222: PUSH
77223: LD_VAR 0 4
77227: ARRAY
77228: PUSH
77229: LD_INT 2
77231: ARRAY
77232: PPUSH
77233: CALL_OW 297
77237: PUSH
77238: LD_VAR 0 5
77242: LESS
77243: IFFALSE 77306
// begin hex := hexes [ i ] ;
77245: LD_ADDR_VAR 0 7
77249: PUSH
77250: LD_VAR 0 2
77254: PUSH
77255: LD_VAR 0 4
77259: ARRAY
77260: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77261: LD_ADDR_VAR 0 5
77265: PUSH
77266: LD_VAR 0 1
77270: PPUSH
77271: LD_VAR 0 2
77275: PUSH
77276: LD_VAR 0 4
77280: ARRAY
77281: PUSH
77282: LD_INT 1
77284: ARRAY
77285: PPUSH
77286: LD_VAR 0 2
77290: PUSH
77291: LD_VAR 0 4
77295: ARRAY
77296: PUSH
77297: LD_INT 2
77299: ARRAY
77300: PPUSH
77301: CALL_OW 297
77305: ST_TO_ADDR
// end ; end ;
77306: GO 77195
77308: POP
77309: POP
// result := hex ;
77310: LD_ADDR_VAR 0 3
77314: PUSH
77315: LD_VAR 0 7
77319: ST_TO_ADDR
// end ;
77320: LD_VAR 0 3
77324: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
77325: LD_INT 0
77327: PPUSH
77328: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
77329: LD_VAR 0 1
77333: NOT
77334: PUSH
77335: LD_VAR 0 1
77339: PUSH
77340: LD_INT 21
77342: PUSH
77343: LD_INT 2
77345: PUSH
77346: EMPTY
77347: LIST
77348: LIST
77349: PUSH
77350: LD_INT 23
77352: PUSH
77353: LD_INT 2
77355: PUSH
77356: EMPTY
77357: LIST
77358: LIST
77359: PUSH
77360: EMPTY
77361: LIST
77362: LIST
77363: PPUSH
77364: CALL_OW 69
77368: IN
77369: NOT
77370: OR
77371: IFFALSE 77375
// exit ;
77373: GO 77422
// for i = 1 to 3 do
77375: LD_ADDR_VAR 0 3
77379: PUSH
77380: DOUBLE
77381: LD_INT 1
77383: DEC
77384: ST_TO_ADDR
77385: LD_INT 3
77387: PUSH
77388: FOR_TO
77389: IFFALSE 77420
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
77391: LD_VAR 0 1
77395: PPUSH
77396: CALL_OW 250
77400: PPUSH
77401: LD_VAR 0 1
77405: PPUSH
77406: CALL_OW 251
77410: PPUSH
77411: LD_INT 1
77413: PPUSH
77414: CALL_OW 453
77418: GO 77388
77420: POP
77421: POP
// end ;
77422: LD_VAR 0 2
77426: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
77427: LD_INT 0
77429: PPUSH
77430: PPUSH
77431: PPUSH
77432: PPUSH
77433: PPUSH
77434: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
77435: LD_VAR 0 1
77439: NOT
77440: PUSH
77441: LD_VAR 0 2
77445: NOT
77446: OR
77447: PUSH
77448: LD_VAR 0 1
77452: PPUSH
77453: CALL_OW 314
77457: OR
77458: IFFALSE 77462
// exit ;
77460: GO 77903
// x := GetX ( enemy_unit ) ;
77462: LD_ADDR_VAR 0 7
77466: PUSH
77467: LD_VAR 0 2
77471: PPUSH
77472: CALL_OW 250
77476: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
77477: LD_ADDR_VAR 0 8
77481: PUSH
77482: LD_VAR 0 2
77486: PPUSH
77487: CALL_OW 251
77491: ST_TO_ADDR
// if not x or not y then
77492: LD_VAR 0 7
77496: NOT
77497: PUSH
77498: LD_VAR 0 8
77502: NOT
77503: OR
77504: IFFALSE 77508
// exit ;
77506: GO 77903
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
77508: LD_ADDR_VAR 0 6
77512: PUSH
77513: LD_VAR 0 7
77517: PPUSH
77518: LD_INT 0
77520: PPUSH
77521: LD_INT 4
77523: PPUSH
77524: CALL_OW 272
77528: PUSH
77529: LD_VAR 0 8
77533: PPUSH
77534: LD_INT 0
77536: PPUSH
77537: LD_INT 4
77539: PPUSH
77540: CALL_OW 273
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: PUSH
77549: LD_VAR 0 7
77553: PPUSH
77554: LD_INT 1
77556: PPUSH
77557: LD_INT 4
77559: PPUSH
77560: CALL_OW 272
77564: PUSH
77565: LD_VAR 0 8
77569: PPUSH
77570: LD_INT 1
77572: PPUSH
77573: LD_INT 4
77575: PPUSH
77576: CALL_OW 273
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: PUSH
77585: LD_VAR 0 7
77589: PPUSH
77590: LD_INT 2
77592: PPUSH
77593: LD_INT 4
77595: PPUSH
77596: CALL_OW 272
77600: PUSH
77601: LD_VAR 0 8
77605: PPUSH
77606: LD_INT 2
77608: PPUSH
77609: LD_INT 4
77611: PPUSH
77612: CALL_OW 273
77616: PUSH
77617: EMPTY
77618: LIST
77619: LIST
77620: PUSH
77621: LD_VAR 0 7
77625: PPUSH
77626: LD_INT 3
77628: PPUSH
77629: LD_INT 4
77631: PPUSH
77632: CALL_OW 272
77636: PUSH
77637: LD_VAR 0 8
77641: PPUSH
77642: LD_INT 3
77644: PPUSH
77645: LD_INT 4
77647: PPUSH
77648: CALL_OW 273
77652: PUSH
77653: EMPTY
77654: LIST
77655: LIST
77656: PUSH
77657: LD_VAR 0 7
77661: PPUSH
77662: LD_INT 4
77664: PPUSH
77665: LD_INT 4
77667: PPUSH
77668: CALL_OW 272
77672: PUSH
77673: LD_VAR 0 8
77677: PPUSH
77678: LD_INT 4
77680: PPUSH
77681: LD_INT 4
77683: PPUSH
77684: CALL_OW 273
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: LD_VAR 0 7
77697: PPUSH
77698: LD_INT 5
77700: PPUSH
77701: LD_INT 4
77703: PPUSH
77704: CALL_OW 272
77708: PUSH
77709: LD_VAR 0 8
77713: PPUSH
77714: LD_INT 5
77716: PPUSH
77717: LD_INT 4
77719: PPUSH
77720: CALL_OW 273
77724: PUSH
77725: EMPTY
77726: LIST
77727: LIST
77728: PUSH
77729: EMPTY
77730: LIST
77731: LIST
77732: LIST
77733: LIST
77734: LIST
77735: LIST
77736: ST_TO_ADDR
// for i = tmp downto 1 do
77737: LD_ADDR_VAR 0 4
77741: PUSH
77742: DOUBLE
77743: LD_VAR 0 6
77747: INC
77748: ST_TO_ADDR
77749: LD_INT 1
77751: PUSH
77752: FOR_DOWNTO
77753: IFFALSE 77854
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
77755: LD_VAR 0 6
77759: PUSH
77760: LD_VAR 0 4
77764: ARRAY
77765: PUSH
77766: LD_INT 1
77768: ARRAY
77769: PPUSH
77770: LD_VAR 0 6
77774: PUSH
77775: LD_VAR 0 4
77779: ARRAY
77780: PUSH
77781: LD_INT 2
77783: ARRAY
77784: PPUSH
77785: CALL_OW 488
77789: NOT
77790: PUSH
77791: LD_VAR 0 6
77795: PUSH
77796: LD_VAR 0 4
77800: ARRAY
77801: PUSH
77802: LD_INT 1
77804: ARRAY
77805: PPUSH
77806: LD_VAR 0 6
77810: PUSH
77811: LD_VAR 0 4
77815: ARRAY
77816: PUSH
77817: LD_INT 2
77819: ARRAY
77820: PPUSH
77821: CALL_OW 428
77825: PUSH
77826: LD_INT 0
77828: NONEQUAL
77829: OR
77830: IFFALSE 77852
// tmp := Delete ( tmp , i ) ;
77832: LD_ADDR_VAR 0 6
77836: PUSH
77837: LD_VAR 0 6
77841: PPUSH
77842: LD_VAR 0 4
77846: PPUSH
77847: CALL_OW 3
77851: ST_TO_ADDR
77852: GO 77752
77854: POP
77855: POP
// j := GetClosestHex ( unit , tmp ) ;
77856: LD_ADDR_VAR 0 5
77860: PUSH
77861: LD_VAR 0 1
77865: PPUSH
77866: LD_VAR 0 6
77870: PPUSH
77871: CALL 77156 0 2
77875: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
77876: LD_VAR 0 1
77880: PPUSH
77881: LD_VAR 0 5
77885: PUSH
77886: LD_INT 1
77888: ARRAY
77889: PPUSH
77890: LD_VAR 0 5
77894: PUSH
77895: LD_INT 2
77897: ARRAY
77898: PPUSH
77899: CALL_OW 111
// end ;
77903: LD_VAR 0 3
77907: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
77908: LD_INT 0
77910: PPUSH
77911: PPUSH
77912: PPUSH
// uc_side = 0 ;
77913: LD_ADDR_OWVAR 20
77917: PUSH
77918: LD_INT 0
77920: ST_TO_ADDR
// uc_nation = 0 ;
77921: LD_ADDR_OWVAR 21
77925: PUSH
77926: LD_INT 0
77928: ST_TO_ADDR
// InitHc ;
77929: CALL_OW 19
// InitVc ;
77933: CALL_OW 20
// if mastodonts then
77937: LD_VAR 0 6
77941: IFFALSE 78008
// for i = 1 to mastodonts do
77943: LD_ADDR_VAR 0 11
77947: PUSH
77948: DOUBLE
77949: LD_INT 1
77951: DEC
77952: ST_TO_ADDR
77953: LD_VAR 0 6
77957: PUSH
77958: FOR_TO
77959: IFFALSE 78006
// begin vc_chassis := 31 ;
77961: LD_ADDR_OWVAR 37
77965: PUSH
77966: LD_INT 31
77968: ST_TO_ADDR
// vc_control := control_rider ;
77969: LD_ADDR_OWVAR 38
77973: PUSH
77974: LD_INT 4
77976: ST_TO_ADDR
// animal := CreateVehicle ;
77977: LD_ADDR_VAR 0 12
77981: PUSH
77982: CALL_OW 45
77986: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
77987: LD_VAR 0 12
77991: PPUSH
77992: LD_VAR 0 8
77996: PPUSH
77997: LD_INT 0
77999: PPUSH
78000: CALL 84714 0 3
// end ;
78004: GO 77958
78006: POP
78007: POP
// if horses then
78008: LD_VAR 0 5
78012: IFFALSE 78079
// for i = 1 to horses do
78014: LD_ADDR_VAR 0 11
78018: PUSH
78019: DOUBLE
78020: LD_INT 1
78022: DEC
78023: ST_TO_ADDR
78024: LD_VAR 0 5
78028: PUSH
78029: FOR_TO
78030: IFFALSE 78077
// begin hc_class := 21 ;
78032: LD_ADDR_OWVAR 28
78036: PUSH
78037: LD_INT 21
78039: ST_TO_ADDR
// hc_gallery :=  ;
78040: LD_ADDR_OWVAR 33
78044: PUSH
78045: LD_STRING 
78047: ST_TO_ADDR
// animal := CreateHuman ;
78048: LD_ADDR_VAR 0 12
78052: PUSH
78053: CALL_OW 44
78057: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
78058: LD_VAR 0 12
78062: PPUSH
78063: LD_VAR 0 8
78067: PPUSH
78068: LD_INT 0
78070: PPUSH
78071: CALL 84714 0 3
// end ;
78075: GO 78029
78077: POP
78078: POP
// if birds then
78079: LD_VAR 0 1
78083: IFFALSE 78150
// for i = 1 to birds do
78085: LD_ADDR_VAR 0 11
78089: PUSH
78090: DOUBLE
78091: LD_INT 1
78093: DEC
78094: ST_TO_ADDR
78095: LD_VAR 0 1
78099: PUSH
78100: FOR_TO
78101: IFFALSE 78148
// begin hc_class = 18 ;
78103: LD_ADDR_OWVAR 28
78107: PUSH
78108: LD_INT 18
78110: ST_TO_ADDR
// hc_gallery =  ;
78111: LD_ADDR_OWVAR 33
78115: PUSH
78116: LD_STRING 
78118: ST_TO_ADDR
// animal := CreateHuman ;
78119: LD_ADDR_VAR 0 12
78123: PUSH
78124: CALL_OW 44
78128: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
78129: LD_VAR 0 12
78133: PPUSH
78134: LD_VAR 0 8
78138: PPUSH
78139: LD_INT 0
78141: PPUSH
78142: CALL 84714 0 3
// end ;
78146: GO 78100
78148: POP
78149: POP
// if tigers then
78150: LD_VAR 0 2
78154: IFFALSE 78238
// for i = 1 to tigers do
78156: LD_ADDR_VAR 0 11
78160: PUSH
78161: DOUBLE
78162: LD_INT 1
78164: DEC
78165: ST_TO_ADDR
78166: LD_VAR 0 2
78170: PUSH
78171: FOR_TO
78172: IFFALSE 78236
// begin hc_class = class_tiger ;
78174: LD_ADDR_OWVAR 28
78178: PUSH
78179: LD_INT 14
78181: ST_TO_ADDR
// hc_gallery =  ;
78182: LD_ADDR_OWVAR 33
78186: PUSH
78187: LD_STRING 
78189: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
78190: LD_ADDR_OWVAR 35
78194: PUSH
78195: LD_INT 7
78197: NEG
78198: PPUSH
78199: LD_INT 7
78201: PPUSH
78202: CALL_OW 12
78206: ST_TO_ADDR
// animal := CreateHuman ;
78207: LD_ADDR_VAR 0 12
78211: PUSH
78212: CALL_OW 44
78216: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
78217: LD_VAR 0 12
78221: PPUSH
78222: LD_VAR 0 8
78226: PPUSH
78227: LD_INT 0
78229: PPUSH
78230: CALL 84714 0 3
// end ;
78234: GO 78171
78236: POP
78237: POP
// if apemans then
78238: LD_VAR 0 3
78242: IFFALSE 78365
// for i = 1 to apemans do
78244: LD_ADDR_VAR 0 11
78248: PUSH
78249: DOUBLE
78250: LD_INT 1
78252: DEC
78253: ST_TO_ADDR
78254: LD_VAR 0 3
78258: PUSH
78259: FOR_TO
78260: IFFALSE 78363
// begin hc_class = class_apeman ;
78262: LD_ADDR_OWVAR 28
78266: PUSH
78267: LD_INT 12
78269: ST_TO_ADDR
// hc_gallery =  ;
78270: LD_ADDR_OWVAR 33
78274: PUSH
78275: LD_STRING 
78277: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
78278: LD_ADDR_OWVAR 35
78282: PUSH
78283: LD_INT 5
78285: NEG
78286: PPUSH
78287: LD_INT 5
78289: PPUSH
78290: CALL_OW 12
78294: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
78295: LD_ADDR_OWVAR 31
78299: PUSH
78300: LD_INT 1
78302: PPUSH
78303: LD_INT 3
78305: PPUSH
78306: CALL_OW 12
78310: PUSH
78311: LD_INT 1
78313: PPUSH
78314: LD_INT 3
78316: PPUSH
78317: CALL_OW 12
78321: PUSH
78322: LD_INT 0
78324: PUSH
78325: LD_INT 0
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: LIST
78332: LIST
78333: ST_TO_ADDR
// animal := CreateHuman ;
78334: LD_ADDR_VAR 0 12
78338: PUSH
78339: CALL_OW 44
78343: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
78344: LD_VAR 0 12
78348: PPUSH
78349: LD_VAR 0 8
78353: PPUSH
78354: LD_INT 0
78356: PPUSH
78357: CALL 84714 0 3
// end ;
78361: GO 78259
78363: POP
78364: POP
// if enchidnas then
78365: LD_VAR 0 4
78369: IFFALSE 78436
// for i = 1 to enchidnas do
78371: LD_ADDR_VAR 0 11
78375: PUSH
78376: DOUBLE
78377: LD_INT 1
78379: DEC
78380: ST_TO_ADDR
78381: LD_VAR 0 4
78385: PUSH
78386: FOR_TO
78387: IFFALSE 78434
// begin hc_class = 13 ;
78389: LD_ADDR_OWVAR 28
78393: PUSH
78394: LD_INT 13
78396: ST_TO_ADDR
// hc_gallery =  ;
78397: LD_ADDR_OWVAR 33
78401: PUSH
78402: LD_STRING 
78404: ST_TO_ADDR
// animal := CreateHuman ;
78405: LD_ADDR_VAR 0 12
78409: PUSH
78410: CALL_OW 44
78414: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
78415: LD_VAR 0 12
78419: PPUSH
78420: LD_VAR 0 8
78424: PPUSH
78425: LD_INT 0
78427: PPUSH
78428: CALL 84714 0 3
// end ;
78432: GO 78386
78434: POP
78435: POP
// if fishes then
78436: LD_VAR 0 7
78440: IFFALSE 78507
// for i = 1 to fishes do
78442: LD_ADDR_VAR 0 11
78446: PUSH
78447: DOUBLE
78448: LD_INT 1
78450: DEC
78451: ST_TO_ADDR
78452: LD_VAR 0 7
78456: PUSH
78457: FOR_TO
78458: IFFALSE 78505
// begin hc_class = 20 ;
78460: LD_ADDR_OWVAR 28
78464: PUSH
78465: LD_INT 20
78467: ST_TO_ADDR
// hc_gallery =  ;
78468: LD_ADDR_OWVAR 33
78472: PUSH
78473: LD_STRING 
78475: ST_TO_ADDR
// animal := CreateHuman ;
78476: LD_ADDR_VAR 0 12
78480: PUSH
78481: CALL_OW 44
78485: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
78486: LD_VAR 0 12
78490: PPUSH
78491: LD_VAR 0 9
78495: PPUSH
78496: LD_INT 0
78498: PPUSH
78499: CALL 84714 0 3
// end ;
78503: GO 78457
78505: POP
78506: POP
// end ;
78507: LD_VAR 0 10
78511: RET
// export function WantHeal ( sci , unit ) ; begin
78512: LD_INT 0
78514: PPUSH
// if GetTaskList ( sci ) > 0 then
78515: LD_VAR 0 1
78519: PPUSH
78520: CALL_OW 437
78524: PUSH
78525: LD_INT 0
78527: GREATER
78528: IFFALSE 78598
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
78530: LD_VAR 0 1
78534: PPUSH
78535: CALL_OW 437
78539: PUSH
78540: LD_INT 1
78542: ARRAY
78543: PUSH
78544: LD_INT 1
78546: ARRAY
78547: PUSH
78548: LD_STRING l
78550: EQUAL
78551: PUSH
78552: LD_VAR 0 1
78556: PPUSH
78557: CALL_OW 437
78561: PUSH
78562: LD_INT 1
78564: ARRAY
78565: PUSH
78566: LD_INT 4
78568: ARRAY
78569: PUSH
78570: LD_VAR 0 2
78574: EQUAL
78575: AND
78576: IFFALSE 78588
// result := true else
78578: LD_ADDR_VAR 0 3
78582: PUSH
78583: LD_INT 1
78585: ST_TO_ADDR
78586: GO 78596
// result := false ;
78588: LD_ADDR_VAR 0 3
78592: PUSH
78593: LD_INT 0
78595: ST_TO_ADDR
// end else
78596: GO 78606
// result := false ;
78598: LD_ADDR_VAR 0 3
78602: PUSH
78603: LD_INT 0
78605: ST_TO_ADDR
// end ;
78606: LD_VAR 0 3
78610: RET
// export function HealTarget ( sci ) ; begin
78611: LD_INT 0
78613: PPUSH
// if not sci then
78614: LD_VAR 0 1
78618: NOT
78619: IFFALSE 78623
// exit ;
78621: GO 78688
// result := 0 ;
78623: LD_ADDR_VAR 0 2
78627: PUSH
78628: LD_INT 0
78630: ST_TO_ADDR
// if GetTaskList ( sci ) then
78631: LD_VAR 0 1
78635: PPUSH
78636: CALL_OW 437
78640: IFFALSE 78688
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
78642: LD_VAR 0 1
78646: PPUSH
78647: CALL_OW 437
78651: PUSH
78652: LD_INT 1
78654: ARRAY
78655: PUSH
78656: LD_INT 1
78658: ARRAY
78659: PUSH
78660: LD_STRING l
78662: EQUAL
78663: IFFALSE 78688
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
78665: LD_ADDR_VAR 0 2
78669: PUSH
78670: LD_VAR 0 1
78674: PPUSH
78675: CALL_OW 437
78679: PUSH
78680: LD_INT 1
78682: ARRAY
78683: PUSH
78684: LD_INT 4
78686: ARRAY
78687: ST_TO_ADDR
// end ;
78688: LD_VAR 0 2
78692: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
78693: LD_INT 0
78695: PPUSH
78696: PPUSH
78697: PPUSH
78698: PPUSH
78699: PPUSH
78700: PPUSH
78701: PPUSH
78702: PPUSH
78703: PPUSH
78704: PPUSH
78705: PPUSH
78706: PPUSH
78707: PPUSH
78708: PPUSH
78709: PPUSH
78710: PPUSH
78711: PPUSH
78712: PPUSH
78713: PPUSH
78714: PPUSH
78715: PPUSH
78716: PPUSH
78717: PPUSH
78718: PPUSH
78719: PPUSH
78720: PPUSH
78721: PPUSH
78722: PPUSH
78723: PPUSH
78724: PPUSH
78725: PPUSH
78726: PPUSH
78727: PPUSH
// if not list then
78728: LD_VAR 0 1
78732: NOT
78733: IFFALSE 78737
// exit ;
78735: GO 83325
// base := list [ 1 ] ;
78737: LD_ADDR_VAR 0 3
78741: PUSH
78742: LD_VAR 0 1
78746: PUSH
78747: LD_INT 1
78749: ARRAY
78750: ST_TO_ADDR
// group := list [ 2 ] ;
78751: LD_ADDR_VAR 0 4
78755: PUSH
78756: LD_VAR 0 1
78760: PUSH
78761: LD_INT 2
78763: ARRAY
78764: ST_TO_ADDR
// path := list [ 3 ] ;
78765: LD_ADDR_VAR 0 5
78769: PUSH
78770: LD_VAR 0 1
78774: PUSH
78775: LD_INT 3
78777: ARRAY
78778: ST_TO_ADDR
// flags := list [ 4 ] ;
78779: LD_ADDR_VAR 0 6
78783: PUSH
78784: LD_VAR 0 1
78788: PUSH
78789: LD_INT 4
78791: ARRAY
78792: ST_TO_ADDR
// mined := [ ] ;
78793: LD_ADDR_VAR 0 27
78797: PUSH
78798: EMPTY
78799: ST_TO_ADDR
// bombed := [ ] ;
78800: LD_ADDR_VAR 0 28
78804: PUSH
78805: EMPTY
78806: ST_TO_ADDR
// healers := [ ] ;
78807: LD_ADDR_VAR 0 31
78811: PUSH
78812: EMPTY
78813: ST_TO_ADDR
// to_heal := [ ] ;
78814: LD_ADDR_VAR 0 30
78818: PUSH
78819: EMPTY
78820: ST_TO_ADDR
// repairs := [ ] ;
78821: LD_ADDR_VAR 0 33
78825: PUSH
78826: EMPTY
78827: ST_TO_ADDR
// to_repair := [ ] ;
78828: LD_ADDR_VAR 0 32
78832: PUSH
78833: EMPTY
78834: ST_TO_ADDR
// if not group or not path then
78835: LD_VAR 0 4
78839: NOT
78840: PUSH
78841: LD_VAR 0 5
78845: NOT
78846: OR
78847: IFFALSE 78851
// exit ;
78849: GO 83325
// if flags then
78851: LD_VAR 0 6
78855: IFFALSE 78999
// begin f_ignore_area := flags [ 1 ] ;
78857: LD_ADDR_VAR 0 17
78861: PUSH
78862: LD_VAR 0 6
78866: PUSH
78867: LD_INT 1
78869: ARRAY
78870: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
78871: LD_ADDR_VAR 0 18
78875: PUSH
78876: LD_VAR 0 6
78880: PUSH
78881: LD_INT 2
78883: ARRAY
78884: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
78885: LD_ADDR_VAR 0 19
78889: PUSH
78890: LD_VAR 0 6
78894: PUSH
78895: LD_INT 3
78897: ARRAY
78898: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
78899: LD_ADDR_VAR 0 20
78903: PUSH
78904: LD_VAR 0 6
78908: PUSH
78909: LD_INT 4
78911: ARRAY
78912: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
78913: LD_ADDR_VAR 0 21
78917: PUSH
78918: LD_VAR 0 6
78922: PUSH
78923: LD_INT 5
78925: ARRAY
78926: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
78927: LD_ADDR_VAR 0 22
78931: PUSH
78932: LD_VAR 0 6
78936: PUSH
78937: LD_INT 6
78939: ARRAY
78940: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
78941: LD_ADDR_VAR 0 23
78945: PUSH
78946: LD_VAR 0 6
78950: PUSH
78951: LD_INT 7
78953: ARRAY
78954: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
78955: LD_ADDR_VAR 0 24
78959: PUSH
78960: LD_VAR 0 6
78964: PUSH
78965: LD_INT 8
78967: ARRAY
78968: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
78969: LD_ADDR_VAR 0 25
78973: PUSH
78974: LD_VAR 0 6
78978: PUSH
78979: LD_INT 9
78981: ARRAY
78982: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
78983: LD_ADDR_VAR 0 26
78987: PUSH
78988: LD_VAR 0 6
78992: PUSH
78993: LD_INT 10
78995: ARRAY
78996: ST_TO_ADDR
// end else
78997: GO 79079
// begin f_ignore_area := false ;
78999: LD_ADDR_VAR 0 17
79003: PUSH
79004: LD_INT 0
79006: ST_TO_ADDR
// f_capture := false ;
79007: LD_ADDR_VAR 0 18
79011: PUSH
79012: LD_INT 0
79014: ST_TO_ADDR
// f_ignore_civ := false ;
79015: LD_ADDR_VAR 0 19
79019: PUSH
79020: LD_INT 0
79022: ST_TO_ADDR
// f_murder := false ;
79023: LD_ADDR_VAR 0 20
79027: PUSH
79028: LD_INT 0
79030: ST_TO_ADDR
// f_mines := false ;
79031: LD_ADDR_VAR 0 21
79035: PUSH
79036: LD_INT 0
79038: ST_TO_ADDR
// f_repair := false ;
79039: LD_ADDR_VAR 0 22
79043: PUSH
79044: LD_INT 0
79046: ST_TO_ADDR
// f_heal := false ;
79047: LD_ADDR_VAR 0 23
79051: PUSH
79052: LD_INT 0
79054: ST_TO_ADDR
// f_spacetime := false ;
79055: LD_ADDR_VAR 0 24
79059: PUSH
79060: LD_INT 0
79062: ST_TO_ADDR
// f_attack_depot := false ;
79063: LD_ADDR_VAR 0 25
79067: PUSH
79068: LD_INT 0
79070: ST_TO_ADDR
// f_crawl := false ;
79071: LD_ADDR_VAR 0 26
79075: PUSH
79076: LD_INT 0
79078: ST_TO_ADDR
// end ; if f_heal then
79079: LD_VAR 0 23
79083: IFFALSE 79110
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
79085: LD_ADDR_VAR 0 31
79089: PUSH
79090: LD_VAR 0 4
79094: PPUSH
79095: LD_INT 25
79097: PUSH
79098: LD_INT 4
79100: PUSH
79101: EMPTY
79102: LIST
79103: LIST
79104: PPUSH
79105: CALL_OW 72
79109: ST_TO_ADDR
// if f_repair then
79110: LD_VAR 0 22
79114: IFFALSE 79141
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
79116: LD_ADDR_VAR 0 33
79120: PUSH
79121: LD_VAR 0 4
79125: PPUSH
79126: LD_INT 25
79128: PUSH
79129: LD_INT 3
79131: PUSH
79132: EMPTY
79133: LIST
79134: LIST
79135: PPUSH
79136: CALL_OW 72
79140: ST_TO_ADDR
// units_path := [ ] ;
79141: LD_ADDR_VAR 0 16
79145: PUSH
79146: EMPTY
79147: ST_TO_ADDR
// for i = 1 to group do
79148: LD_ADDR_VAR 0 7
79152: PUSH
79153: DOUBLE
79154: LD_INT 1
79156: DEC
79157: ST_TO_ADDR
79158: LD_VAR 0 4
79162: PUSH
79163: FOR_TO
79164: IFFALSE 79193
// units_path := Replace ( units_path , i , path ) ;
79166: LD_ADDR_VAR 0 16
79170: PUSH
79171: LD_VAR 0 16
79175: PPUSH
79176: LD_VAR 0 7
79180: PPUSH
79181: LD_VAR 0 5
79185: PPUSH
79186: CALL_OW 1
79190: ST_TO_ADDR
79191: GO 79163
79193: POP
79194: POP
// repeat for i = group downto 1 do
79195: LD_ADDR_VAR 0 7
79199: PUSH
79200: DOUBLE
79201: LD_VAR 0 4
79205: INC
79206: ST_TO_ADDR
79207: LD_INT 1
79209: PUSH
79210: FOR_DOWNTO
79211: IFFALSE 83307
// begin wait ( 5 ) ;
79213: LD_INT 5
79215: PPUSH
79216: CALL_OW 67
// tmp := [ ] ;
79220: LD_ADDR_VAR 0 14
79224: PUSH
79225: EMPTY
79226: ST_TO_ADDR
// attacking := false ;
79227: LD_ADDR_VAR 0 29
79231: PUSH
79232: LD_INT 0
79234: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
79235: LD_VAR 0 4
79239: PUSH
79240: LD_VAR 0 7
79244: ARRAY
79245: PPUSH
79246: CALL_OW 301
79250: PUSH
79251: LD_VAR 0 4
79255: PUSH
79256: LD_VAR 0 7
79260: ARRAY
79261: NOT
79262: OR
79263: IFFALSE 79372
// begin if GetType ( group [ i ] ) = unit_human then
79265: LD_VAR 0 4
79269: PUSH
79270: LD_VAR 0 7
79274: ARRAY
79275: PPUSH
79276: CALL_OW 247
79280: PUSH
79281: LD_INT 1
79283: EQUAL
79284: IFFALSE 79330
// begin to_heal := to_heal diff group [ i ] ;
79286: LD_ADDR_VAR 0 30
79290: PUSH
79291: LD_VAR 0 30
79295: PUSH
79296: LD_VAR 0 4
79300: PUSH
79301: LD_VAR 0 7
79305: ARRAY
79306: DIFF
79307: ST_TO_ADDR
// healers := healers diff group [ i ] ;
79308: LD_ADDR_VAR 0 31
79312: PUSH
79313: LD_VAR 0 31
79317: PUSH
79318: LD_VAR 0 4
79322: PUSH
79323: LD_VAR 0 7
79327: ARRAY
79328: DIFF
79329: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
79330: LD_ADDR_VAR 0 4
79334: PUSH
79335: LD_VAR 0 4
79339: PPUSH
79340: LD_VAR 0 7
79344: PPUSH
79345: CALL_OW 3
79349: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
79350: LD_ADDR_VAR 0 16
79354: PUSH
79355: LD_VAR 0 16
79359: PPUSH
79360: LD_VAR 0 7
79364: PPUSH
79365: CALL_OW 3
79369: ST_TO_ADDR
// continue ;
79370: GO 79210
// end ; if f_repair then
79372: LD_VAR 0 22
79376: IFFALSE 79865
// begin if GetType ( group [ i ] ) = unit_vehicle then
79378: LD_VAR 0 4
79382: PUSH
79383: LD_VAR 0 7
79387: ARRAY
79388: PPUSH
79389: CALL_OW 247
79393: PUSH
79394: LD_INT 2
79396: EQUAL
79397: IFFALSE 79587
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
79399: LD_VAR 0 4
79403: PUSH
79404: LD_VAR 0 7
79408: ARRAY
79409: PPUSH
79410: CALL_OW 256
79414: PUSH
79415: LD_INT 700
79417: LESS
79418: PUSH
79419: LD_VAR 0 4
79423: PUSH
79424: LD_VAR 0 7
79428: ARRAY
79429: PUSH
79430: LD_VAR 0 32
79434: IN
79435: NOT
79436: AND
79437: IFFALSE 79461
// to_repair := to_repair union group [ i ] ;
79439: LD_ADDR_VAR 0 32
79443: PUSH
79444: LD_VAR 0 32
79448: PUSH
79449: LD_VAR 0 4
79453: PUSH
79454: LD_VAR 0 7
79458: ARRAY
79459: UNION
79460: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
79461: LD_VAR 0 4
79465: PUSH
79466: LD_VAR 0 7
79470: ARRAY
79471: PPUSH
79472: CALL_OW 256
79476: PUSH
79477: LD_INT 1000
79479: EQUAL
79480: PUSH
79481: LD_VAR 0 4
79485: PUSH
79486: LD_VAR 0 7
79490: ARRAY
79491: PUSH
79492: LD_VAR 0 32
79496: IN
79497: AND
79498: IFFALSE 79522
// to_repair := to_repair diff group [ i ] ;
79500: LD_ADDR_VAR 0 32
79504: PUSH
79505: LD_VAR 0 32
79509: PUSH
79510: LD_VAR 0 4
79514: PUSH
79515: LD_VAR 0 7
79519: ARRAY
79520: DIFF
79521: ST_TO_ADDR
// if group [ i ] in to_repair then
79522: LD_VAR 0 4
79526: PUSH
79527: LD_VAR 0 7
79531: ARRAY
79532: PUSH
79533: LD_VAR 0 32
79537: IN
79538: IFFALSE 79585
// begin if not IsInArea ( group [ i ] , f_repair ) then
79540: LD_VAR 0 4
79544: PUSH
79545: LD_VAR 0 7
79549: ARRAY
79550: PPUSH
79551: LD_VAR 0 22
79555: PPUSH
79556: CALL_OW 308
79560: NOT
79561: IFFALSE 79583
// ComMoveToArea ( group [ i ] , f_repair ) ;
79563: LD_VAR 0 4
79567: PUSH
79568: LD_VAR 0 7
79572: ARRAY
79573: PPUSH
79574: LD_VAR 0 22
79578: PPUSH
79579: CALL_OW 113
// continue ;
79583: GO 79210
// end ; end else
79585: GO 79865
// if group [ i ] in repairs then
79587: LD_VAR 0 4
79591: PUSH
79592: LD_VAR 0 7
79596: ARRAY
79597: PUSH
79598: LD_VAR 0 33
79602: IN
79603: IFFALSE 79865
// begin if IsInUnit ( group [ i ] ) then
79605: LD_VAR 0 4
79609: PUSH
79610: LD_VAR 0 7
79614: ARRAY
79615: PPUSH
79616: CALL_OW 310
79620: IFFALSE 79688
// begin z := IsInUnit ( group [ i ] ) ;
79622: LD_ADDR_VAR 0 13
79626: PUSH
79627: LD_VAR 0 4
79631: PUSH
79632: LD_VAR 0 7
79636: ARRAY
79637: PPUSH
79638: CALL_OW 310
79642: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
79643: LD_VAR 0 13
79647: PUSH
79648: LD_VAR 0 32
79652: IN
79653: PUSH
79654: LD_VAR 0 13
79658: PPUSH
79659: LD_VAR 0 22
79663: PPUSH
79664: CALL_OW 308
79668: AND
79669: IFFALSE 79686
// ComExitVehicle ( group [ i ] ) ;
79671: LD_VAR 0 4
79675: PUSH
79676: LD_VAR 0 7
79680: ARRAY
79681: PPUSH
79682: CALL_OW 121
// end else
79686: GO 79865
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
79688: LD_ADDR_VAR 0 13
79692: PUSH
79693: LD_VAR 0 4
79697: PPUSH
79698: LD_INT 95
79700: PUSH
79701: LD_VAR 0 22
79705: PUSH
79706: EMPTY
79707: LIST
79708: LIST
79709: PUSH
79710: LD_INT 58
79712: PUSH
79713: EMPTY
79714: LIST
79715: PUSH
79716: EMPTY
79717: LIST
79718: LIST
79719: PPUSH
79720: CALL_OW 72
79724: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
79725: LD_VAR 0 4
79729: PUSH
79730: LD_VAR 0 7
79734: ARRAY
79735: PPUSH
79736: CALL_OW 314
79740: NOT
79741: IFFALSE 79863
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
79743: LD_ADDR_VAR 0 10
79747: PUSH
79748: LD_VAR 0 13
79752: PPUSH
79753: LD_VAR 0 4
79757: PUSH
79758: LD_VAR 0 7
79762: ARRAY
79763: PPUSH
79764: CALL_OW 74
79768: ST_TO_ADDR
// if not x then
79769: LD_VAR 0 10
79773: NOT
79774: IFFALSE 79778
// continue ;
79776: GO 79210
// if GetLives ( x ) < 1000 then
79778: LD_VAR 0 10
79782: PPUSH
79783: CALL_OW 256
79787: PUSH
79788: LD_INT 1000
79790: LESS
79791: IFFALSE 79815
// ComRepairVehicle ( group [ i ] , x ) else
79793: LD_VAR 0 4
79797: PUSH
79798: LD_VAR 0 7
79802: ARRAY
79803: PPUSH
79804: LD_VAR 0 10
79808: PPUSH
79809: CALL_OW 129
79813: GO 79863
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
79815: LD_VAR 0 23
79819: PUSH
79820: LD_VAR 0 4
79824: PUSH
79825: LD_VAR 0 7
79829: ARRAY
79830: PPUSH
79831: CALL_OW 256
79835: PUSH
79836: LD_INT 1000
79838: LESS
79839: AND
79840: NOT
79841: IFFALSE 79863
// ComEnterUnit ( group [ i ] , x ) ;
79843: LD_VAR 0 4
79847: PUSH
79848: LD_VAR 0 7
79852: ARRAY
79853: PPUSH
79854: LD_VAR 0 10
79858: PPUSH
79859: CALL_OW 120
// end ; continue ;
79863: GO 79210
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
79865: LD_VAR 0 23
79869: PUSH
79870: LD_VAR 0 4
79874: PUSH
79875: LD_VAR 0 7
79879: ARRAY
79880: PPUSH
79881: CALL_OW 247
79885: PUSH
79886: LD_INT 1
79888: EQUAL
79889: AND
79890: IFFALSE 80368
// begin if group [ i ] in healers then
79892: LD_VAR 0 4
79896: PUSH
79897: LD_VAR 0 7
79901: ARRAY
79902: PUSH
79903: LD_VAR 0 31
79907: IN
79908: IFFALSE 80181
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
79910: LD_VAR 0 4
79914: PUSH
79915: LD_VAR 0 7
79919: ARRAY
79920: PPUSH
79921: LD_VAR 0 23
79925: PPUSH
79926: CALL_OW 308
79930: NOT
79931: PUSH
79932: LD_VAR 0 4
79936: PUSH
79937: LD_VAR 0 7
79941: ARRAY
79942: PPUSH
79943: CALL_OW 314
79947: NOT
79948: AND
79949: IFFALSE 79973
// ComMoveToArea ( group [ i ] , f_heal ) else
79951: LD_VAR 0 4
79955: PUSH
79956: LD_VAR 0 7
79960: ARRAY
79961: PPUSH
79962: LD_VAR 0 23
79966: PPUSH
79967: CALL_OW 113
79971: GO 80179
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
79973: LD_VAR 0 4
79977: PUSH
79978: LD_VAR 0 7
79982: ARRAY
79983: PPUSH
79984: CALL 78611 0 1
79988: PPUSH
79989: CALL_OW 256
79993: PUSH
79994: LD_INT 1000
79996: EQUAL
79997: IFFALSE 80016
// ComStop ( group [ i ] ) else
79999: LD_VAR 0 4
80003: PUSH
80004: LD_VAR 0 7
80008: ARRAY
80009: PPUSH
80010: CALL_OW 141
80014: GO 80179
// if not HasTask ( group [ i ] ) and to_heal then
80016: LD_VAR 0 4
80020: PUSH
80021: LD_VAR 0 7
80025: ARRAY
80026: PPUSH
80027: CALL_OW 314
80031: NOT
80032: PUSH
80033: LD_VAR 0 30
80037: AND
80038: IFFALSE 80179
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
80040: LD_ADDR_VAR 0 13
80044: PUSH
80045: LD_VAR 0 30
80049: PPUSH
80050: LD_INT 3
80052: PUSH
80053: LD_INT 54
80055: PUSH
80056: EMPTY
80057: LIST
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PPUSH
80063: CALL_OW 72
80067: PPUSH
80068: LD_VAR 0 4
80072: PUSH
80073: LD_VAR 0 7
80077: ARRAY
80078: PPUSH
80079: CALL_OW 74
80083: ST_TO_ADDR
// if z then
80084: LD_VAR 0 13
80088: IFFALSE 80179
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
80090: LD_INT 91
80092: PUSH
80093: LD_VAR 0 13
80097: PUSH
80098: LD_INT 10
80100: PUSH
80101: EMPTY
80102: LIST
80103: LIST
80104: LIST
80105: PUSH
80106: LD_INT 81
80108: PUSH
80109: LD_VAR 0 13
80113: PPUSH
80114: CALL_OW 255
80118: PUSH
80119: EMPTY
80120: LIST
80121: LIST
80122: PUSH
80123: EMPTY
80124: LIST
80125: LIST
80126: PPUSH
80127: CALL_OW 69
80131: PUSH
80132: LD_INT 0
80134: EQUAL
80135: IFFALSE 80159
// ComHeal ( group [ i ] , z ) else
80137: LD_VAR 0 4
80141: PUSH
80142: LD_VAR 0 7
80146: ARRAY
80147: PPUSH
80148: LD_VAR 0 13
80152: PPUSH
80153: CALL_OW 128
80157: GO 80179
// ComMoveToArea ( group [ i ] , f_heal ) ;
80159: LD_VAR 0 4
80163: PUSH
80164: LD_VAR 0 7
80168: ARRAY
80169: PPUSH
80170: LD_VAR 0 23
80174: PPUSH
80175: CALL_OW 113
// end ; continue ;
80179: GO 79210
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
80181: LD_VAR 0 4
80185: PUSH
80186: LD_VAR 0 7
80190: ARRAY
80191: PPUSH
80192: CALL_OW 256
80196: PUSH
80197: LD_INT 700
80199: LESS
80200: PUSH
80201: LD_VAR 0 4
80205: PUSH
80206: LD_VAR 0 7
80210: ARRAY
80211: PUSH
80212: LD_VAR 0 30
80216: IN
80217: NOT
80218: AND
80219: IFFALSE 80243
// to_heal := to_heal union group [ i ] ;
80221: LD_ADDR_VAR 0 30
80225: PUSH
80226: LD_VAR 0 30
80230: PUSH
80231: LD_VAR 0 4
80235: PUSH
80236: LD_VAR 0 7
80240: ARRAY
80241: UNION
80242: ST_TO_ADDR
// if group [ i ] in to_heal then
80243: LD_VAR 0 4
80247: PUSH
80248: LD_VAR 0 7
80252: ARRAY
80253: PUSH
80254: LD_VAR 0 30
80258: IN
80259: IFFALSE 80368
// begin if GetLives ( group [ i ] ) = 1000 then
80261: LD_VAR 0 4
80265: PUSH
80266: LD_VAR 0 7
80270: ARRAY
80271: PPUSH
80272: CALL_OW 256
80276: PUSH
80277: LD_INT 1000
80279: EQUAL
80280: IFFALSE 80306
// to_heal := to_heal diff group [ i ] else
80282: LD_ADDR_VAR 0 30
80286: PUSH
80287: LD_VAR 0 30
80291: PUSH
80292: LD_VAR 0 4
80296: PUSH
80297: LD_VAR 0 7
80301: ARRAY
80302: DIFF
80303: ST_TO_ADDR
80304: GO 80368
// begin if not IsInArea ( group [ i ] , to_heal ) then
80306: LD_VAR 0 4
80310: PUSH
80311: LD_VAR 0 7
80315: ARRAY
80316: PPUSH
80317: LD_VAR 0 30
80321: PPUSH
80322: CALL_OW 308
80326: NOT
80327: IFFALSE 80351
// ComMoveToArea ( group [ i ] , f_heal ) else
80329: LD_VAR 0 4
80333: PUSH
80334: LD_VAR 0 7
80338: ARRAY
80339: PPUSH
80340: LD_VAR 0 23
80344: PPUSH
80345: CALL_OW 113
80349: GO 80366
// ComHold ( group [ i ] ) ;
80351: LD_VAR 0 4
80355: PUSH
80356: LD_VAR 0 7
80360: ARRAY
80361: PPUSH
80362: CALL_OW 140
// continue ;
80366: GO 79210
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
80368: LD_VAR 0 4
80372: PUSH
80373: LD_VAR 0 7
80377: ARRAY
80378: PPUSH
80379: LD_INT 10
80381: PPUSH
80382: CALL 77008 0 2
80386: NOT
80387: PUSH
80388: LD_VAR 0 16
80392: PUSH
80393: LD_VAR 0 7
80397: ARRAY
80398: PUSH
80399: EMPTY
80400: EQUAL
80401: NOT
80402: AND
80403: IFFALSE 80669
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
80405: LD_VAR 0 4
80409: PUSH
80410: LD_VAR 0 7
80414: ARRAY
80415: PPUSH
80416: CALL_OW 262
80420: PUSH
80421: LD_INT 1
80423: PUSH
80424: LD_INT 2
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: IN
80431: IFFALSE 80472
// if GetFuel ( group [ i ] ) < 10 then
80433: LD_VAR 0 4
80437: PUSH
80438: LD_VAR 0 7
80442: ARRAY
80443: PPUSH
80444: CALL_OW 261
80448: PUSH
80449: LD_INT 10
80451: LESS
80452: IFFALSE 80472
// SetFuel ( group [ i ] , 12 ) ;
80454: LD_VAR 0 4
80458: PUSH
80459: LD_VAR 0 7
80463: ARRAY
80464: PPUSH
80465: LD_INT 12
80467: PPUSH
80468: CALL_OW 240
// if units_path [ i ] then
80472: LD_VAR 0 16
80476: PUSH
80477: LD_VAR 0 7
80481: ARRAY
80482: IFFALSE 80667
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
80484: LD_VAR 0 4
80488: PUSH
80489: LD_VAR 0 7
80493: ARRAY
80494: PPUSH
80495: LD_VAR 0 16
80499: PUSH
80500: LD_VAR 0 7
80504: ARRAY
80505: PUSH
80506: LD_INT 1
80508: ARRAY
80509: PUSH
80510: LD_INT 1
80512: ARRAY
80513: PPUSH
80514: LD_VAR 0 16
80518: PUSH
80519: LD_VAR 0 7
80523: ARRAY
80524: PUSH
80525: LD_INT 1
80527: ARRAY
80528: PUSH
80529: LD_INT 2
80531: ARRAY
80532: PPUSH
80533: CALL_OW 297
80537: PUSH
80538: LD_INT 6
80540: GREATER
80541: IFFALSE 80616
// begin if not HasTask ( group [ i ] ) then
80543: LD_VAR 0 4
80547: PUSH
80548: LD_VAR 0 7
80552: ARRAY
80553: PPUSH
80554: CALL_OW 314
80558: NOT
80559: IFFALSE 80614
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
80561: LD_VAR 0 4
80565: PUSH
80566: LD_VAR 0 7
80570: ARRAY
80571: PPUSH
80572: LD_VAR 0 16
80576: PUSH
80577: LD_VAR 0 7
80581: ARRAY
80582: PUSH
80583: LD_INT 1
80585: ARRAY
80586: PUSH
80587: LD_INT 1
80589: ARRAY
80590: PPUSH
80591: LD_VAR 0 16
80595: PUSH
80596: LD_VAR 0 7
80600: ARRAY
80601: PUSH
80602: LD_INT 1
80604: ARRAY
80605: PUSH
80606: LD_INT 2
80608: ARRAY
80609: PPUSH
80610: CALL_OW 114
// end else
80614: GO 80667
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
80616: LD_ADDR_VAR 0 15
80620: PUSH
80621: LD_VAR 0 16
80625: PUSH
80626: LD_VAR 0 7
80630: ARRAY
80631: PPUSH
80632: LD_INT 1
80634: PPUSH
80635: CALL_OW 3
80639: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
80640: LD_ADDR_VAR 0 16
80644: PUSH
80645: LD_VAR 0 16
80649: PPUSH
80650: LD_VAR 0 7
80654: PPUSH
80655: LD_VAR 0 15
80659: PPUSH
80660: CALL_OW 1
80664: ST_TO_ADDR
// continue ;
80665: GO 79210
// end ; end ; end else
80667: GO 83305
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
80669: LD_ADDR_VAR 0 14
80673: PUSH
80674: LD_INT 81
80676: PUSH
80677: LD_VAR 0 4
80681: PUSH
80682: LD_VAR 0 7
80686: ARRAY
80687: PPUSH
80688: CALL_OW 255
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: PPUSH
80697: CALL_OW 69
80701: ST_TO_ADDR
// if not tmp then
80702: LD_VAR 0 14
80706: NOT
80707: IFFALSE 80711
// continue ;
80709: GO 79210
// if f_ignore_area then
80711: LD_VAR 0 17
80715: IFFALSE 80803
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
80717: LD_ADDR_VAR 0 15
80721: PUSH
80722: LD_VAR 0 14
80726: PPUSH
80727: LD_INT 3
80729: PUSH
80730: LD_INT 92
80732: PUSH
80733: LD_VAR 0 17
80737: PUSH
80738: LD_INT 1
80740: ARRAY
80741: PUSH
80742: LD_VAR 0 17
80746: PUSH
80747: LD_INT 2
80749: ARRAY
80750: PUSH
80751: LD_VAR 0 17
80755: PUSH
80756: LD_INT 3
80758: ARRAY
80759: PUSH
80760: EMPTY
80761: LIST
80762: LIST
80763: LIST
80764: LIST
80765: PUSH
80766: EMPTY
80767: LIST
80768: LIST
80769: PPUSH
80770: CALL_OW 72
80774: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
80775: LD_VAR 0 14
80779: PUSH
80780: LD_VAR 0 15
80784: DIFF
80785: IFFALSE 80803
// tmp := tmp diff tmp2 ;
80787: LD_ADDR_VAR 0 14
80791: PUSH
80792: LD_VAR 0 14
80796: PUSH
80797: LD_VAR 0 15
80801: DIFF
80802: ST_TO_ADDR
// end ; if not f_murder then
80803: LD_VAR 0 20
80807: NOT
80808: IFFALSE 80866
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
80810: LD_ADDR_VAR 0 15
80814: PUSH
80815: LD_VAR 0 14
80819: PPUSH
80820: LD_INT 3
80822: PUSH
80823: LD_INT 50
80825: PUSH
80826: EMPTY
80827: LIST
80828: PUSH
80829: EMPTY
80830: LIST
80831: LIST
80832: PPUSH
80833: CALL_OW 72
80837: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
80838: LD_VAR 0 14
80842: PUSH
80843: LD_VAR 0 15
80847: DIFF
80848: IFFALSE 80866
// tmp := tmp diff tmp2 ;
80850: LD_ADDR_VAR 0 14
80854: PUSH
80855: LD_VAR 0 14
80859: PUSH
80860: LD_VAR 0 15
80864: DIFF
80865: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
80866: LD_ADDR_VAR 0 14
80870: PUSH
80871: LD_VAR 0 4
80875: PUSH
80876: LD_VAR 0 7
80880: ARRAY
80881: PPUSH
80882: LD_VAR 0 14
80886: PPUSH
80887: LD_INT 1
80889: PPUSH
80890: LD_INT 1
80892: PPUSH
80893: CALL 50890 0 4
80897: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
80898: LD_VAR 0 4
80902: PUSH
80903: LD_VAR 0 7
80907: ARRAY
80908: PPUSH
80909: CALL_OW 257
80913: PUSH
80914: LD_INT 1
80916: EQUAL
80917: IFFALSE 81365
// begin if WantPlant ( group [ i ] ) then
80919: LD_VAR 0 4
80923: PUSH
80924: LD_VAR 0 7
80928: ARRAY
80929: PPUSH
80930: CALL 50358 0 1
80934: IFFALSE 80938
// continue ;
80936: GO 79210
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
80938: LD_VAR 0 18
80942: PUSH
80943: LD_VAR 0 4
80947: PUSH
80948: LD_VAR 0 7
80952: ARRAY
80953: PPUSH
80954: CALL_OW 310
80958: NOT
80959: AND
80960: PUSH
80961: LD_VAR 0 14
80965: PUSH
80966: LD_INT 1
80968: ARRAY
80969: PUSH
80970: LD_VAR 0 14
80974: PPUSH
80975: LD_INT 21
80977: PUSH
80978: LD_INT 2
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: PUSH
80985: LD_INT 58
80987: PUSH
80988: EMPTY
80989: LIST
80990: PUSH
80991: EMPTY
80992: LIST
80993: LIST
80994: PPUSH
80995: CALL_OW 72
80999: IN
81000: AND
81001: IFFALSE 81037
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
81003: LD_VAR 0 4
81007: PUSH
81008: LD_VAR 0 7
81012: ARRAY
81013: PPUSH
81014: LD_VAR 0 14
81018: PUSH
81019: LD_INT 1
81021: ARRAY
81022: PPUSH
81023: CALL_OW 120
// attacking := true ;
81027: LD_ADDR_VAR 0 29
81031: PUSH
81032: LD_INT 1
81034: ST_TO_ADDR
// continue ;
81035: GO 79210
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
81037: LD_VAR 0 26
81041: PUSH
81042: LD_VAR 0 4
81046: PUSH
81047: LD_VAR 0 7
81051: ARRAY
81052: PPUSH
81053: CALL_OW 257
81057: PUSH
81058: LD_INT 1
81060: EQUAL
81061: AND
81062: PUSH
81063: LD_VAR 0 4
81067: PUSH
81068: LD_VAR 0 7
81072: ARRAY
81073: PPUSH
81074: CALL_OW 256
81078: PUSH
81079: LD_INT 800
81081: LESS
81082: AND
81083: PUSH
81084: LD_VAR 0 4
81088: PUSH
81089: LD_VAR 0 7
81093: ARRAY
81094: PPUSH
81095: CALL_OW 318
81099: NOT
81100: AND
81101: IFFALSE 81118
// ComCrawl ( group [ i ] ) ;
81103: LD_VAR 0 4
81107: PUSH
81108: LD_VAR 0 7
81112: ARRAY
81113: PPUSH
81114: CALL_OW 137
// if f_mines then
81118: LD_VAR 0 21
81122: IFFALSE 81365
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
81124: LD_VAR 0 14
81128: PUSH
81129: LD_INT 1
81131: ARRAY
81132: PPUSH
81133: CALL_OW 247
81137: PUSH
81138: LD_INT 3
81140: EQUAL
81141: PUSH
81142: LD_VAR 0 14
81146: PUSH
81147: LD_INT 1
81149: ARRAY
81150: PUSH
81151: LD_VAR 0 27
81155: IN
81156: NOT
81157: AND
81158: IFFALSE 81365
// begin x := GetX ( tmp [ 1 ] ) ;
81160: LD_ADDR_VAR 0 10
81164: PUSH
81165: LD_VAR 0 14
81169: PUSH
81170: LD_INT 1
81172: ARRAY
81173: PPUSH
81174: CALL_OW 250
81178: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
81179: LD_ADDR_VAR 0 11
81183: PUSH
81184: LD_VAR 0 14
81188: PUSH
81189: LD_INT 1
81191: ARRAY
81192: PPUSH
81193: CALL_OW 251
81197: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
81198: LD_ADDR_VAR 0 12
81202: PUSH
81203: LD_VAR 0 4
81207: PUSH
81208: LD_VAR 0 7
81212: ARRAY
81213: PPUSH
81214: CALL 77093 0 1
81218: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
81219: LD_VAR 0 4
81223: PUSH
81224: LD_VAR 0 7
81228: ARRAY
81229: PPUSH
81230: LD_VAR 0 10
81234: PPUSH
81235: LD_VAR 0 11
81239: PPUSH
81240: LD_VAR 0 14
81244: PUSH
81245: LD_INT 1
81247: ARRAY
81248: PPUSH
81249: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
81253: LD_VAR 0 4
81257: PUSH
81258: LD_VAR 0 7
81262: ARRAY
81263: PPUSH
81264: LD_VAR 0 10
81268: PPUSH
81269: LD_VAR 0 12
81273: PPUSH
81274: LD_INT 7
81276: PPUSH
81277: CALL_OW 272
81281: PPUSH
81282: LD_VAR 0 11
81286: PPUSH
81287: LD_VAR 0 12
81291: PPUSH
81292: LD_INT 7
81294: PPUSH
81295: CALL_OW 273
81299: PPUSH
81300: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
81304: LD_VAR 0 4
81308: PUSH
81309: LD_VAR 0 7
81313: ARRAY
81314: PPUSH
81315: LD_INT 71
81317: PPUSH
81318: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
81322: LD_ADDR_VAR 0 27
81326: PUSH
81327: LD_VAR 0 27
81331: PPUSH
81332: LD_VAR 0 27
81336: PUSH
81337: LD_INT 1
81339: PLUS
81340: PPUSH
81341: LD_VAR 0 14
81345: PUSH
81346: LD_INT 1
81348: ARRAY
81349: PPUSH
81350: CALL_OW 1
81354: ST_TO_ADDR
// attacking := true ;
81355: LD_ADDR_VAR 0 29
81359: PUSH
81360: LD_INT 1
81362: ST_TO_ADDR
// continue ;
81363: GO 79210
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
81365: LD_VAR 0 4
81369: PUSH
81370: LD_VAR 0 7
81374: ARRAY
81375: PPUSH
81376: CALL_OW 257
81380: PUSH
81381: LD_INT 17
81383: EQUAL
81384: PUSH
81385: LD_VAR 0 4
81389: PUSH
81390: LD_VAR 0 7
81394: ARRAY
81395: PPUSH
81396: CALL_OW 110
81400: PUSH
81401: LD_INT 71
81403: EQUAL
81404: NOT
81405: AND
81406: IFFALSE 81552
// begin attacking := false ;
81408: LD_ADDR_VAR 0 29
81412: PUSH
81413: LD_INT 0
81415: ST_TO_ADDR
// k := 5 ;
81416: LD_ADDR_VAR 0 9
81420: PUSH
81421: LD_INT 5
81423: ST_TO_ADDR
// if tmp < k then
81424: LD_VAR 0 14
81428: PUSH
81429: LD_VAR 0 9
81433: LESS
81434: IFFALSE 81446
// k := tmp ;
81436: LD_ADDR_VAR 0 9
81440: PUSH
81441: LD_VAR 0 14
81445: ST_TO_ADDR
// for j = 1 to k do
81446: LD_ADDR_VAR 0 8
81450: PUSH
81451: DOUBLE
81452: LD_INT 1
81454: DEC
81455: ST_TO_ADDR
81456: LD_VAR 0 9
81460: PUSH
81461: FOR_TO
81462: IFFALSE 81550
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
81464: LD_VAR 0 14
81468: PUSH
81469: LD_VAR 0 8
81473: ARRAY
81474: PUSH
81475: LD_VAR 0 14
81479: PPUSH
81480: LD_INT 58
81482: PUSH
81483: EMPTY
81484: LIST
81485: PPUSH
81486: CALL_OW 72
81490: IN
81491: NOT
81492: IFFALSE 81548
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81494: LD_VAR 0 4
81498: PUSH
81499: LD_VAR 0 7
81503: ARRAY
81504: PPUSH
81505: LD_VAR 0 14
81509: PUSH
81510: LD_VAR 0 8
81514: ARRAY
81515: PPUSH
81516: CALL_OW 115
// attacking := true ;
81520: LD_ADDR_VAR 0 29
81524: PUSH
81525: LD_INT 1
81527: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
81528: LD_VAR 0 4
81532: PUSH
81533: LD_VAR 0 7
81537: ARRAY
81538: PPUSH
81539: LD_INT 71
81541: PPUSH
81542: CALL_OW 109
// continue ;
81546: GO 81461
// end ; end ;
81548: GO 81461
81550: POP
81551: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
81552: LD_VAR 0 4
81556: PUSH
81557: LD_VAR 0 7
81561: ARRAY
81562: PPUSH
81563: CALL_OW 257
81567: PUSH
81568: LD_INT 8
81570: EQUAL
81571: PUSH
81572: LD_VAR 0 4
81576: PUSH
81577: LD_VAR 0 7
81581: ARRAY
81582: PPUSH
81583: CALL_OW 264
81587: PUSH
81588: LD_INT 28
81590: PUSH
81591: LD_INT 45
81593: PUSH
81594: LD_INT 7
81596: PUSH
81597: LD_INT 47
81599: PUSH
81600: EMPTY
81601: LIST
81602: LIST
81603: LIST
81604: LIST
81605: IN
81606: OR
81607: IFFALSE 81837
// begin attacking := false ;
81609: LD_ADDR_VAR 0 29
81613: PUSH
81614: LD_INT 0
81616: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
81617: LD_VAR 0 14
81621: PUSH
81622: LD_INT 1
81624: ARRAY
81625: PPUSH
81626: CALL_OW 266
81630: PUSH
81631: LD_INT 32
81633: PUSH
81634: LD_INT 31
81636: PUSH
81637: LD_INT 33
81639: PUSH
81640: LD_INT 4
81642: PUSH
81643: LD_INT 5
81645: PUSH
81646: EMPTY
81647: LIST
81648: LIST
81649: LIST
81650: LIST
81651: LIST
81652: IN
81653: IFFALSE 81837
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
81655: LD_ADDR_VAR 0 9
81659: PUSH
81660: LD_VAR 0 14
81664: PUSH
81665: LD_INT 1
81667: ARRAY
81668: PPUSH
81669: CALL_OW 266
81673: PPUSH
81674: LD_VAR 0 14
81678: PUSH
81679: LD_INT 1
81681: ARRAY
81682: PPUSH
81683: CALL_OW 250
81687: PPUSH
81688: LD_VAR 0 14
81692: PUSH
81693: LD_INT 1
81695: ARRAY
81696: PPUSH
81697: CALL_OW 251
81701: PPUSH
81702: LD_VAR 0 14
81706: PUSH
81707: LD_INT 1
81709: ARRAY
81710: PPUSH
81711: CALL_OW 254
81715: PPUSH
81716: LD_VAR 0 14
81720: PUSH
81721: LD_INT 1
81723: ARRAY
81724: PPUSH
81725: CALL_OW 248
81729: PPUSH
81730: LD_INT 0
81732: PPUSH
81733: CALL 58469 0 6
81737: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
81738: LD_ADDR_VAR 0 8
81742: PUSH
81743: LD_VAR 0 4
81747: PUSH
81748: LD_VAR 0 7
81752: ARRAY
81753: PPUSH
81754: LD_VAR 0 9
81758: PPUSH
81759: CALL 77156 0 2
81763: ST_TO_ADDR
// if j then
81764: LD_VAR 0 8
81768: IFFALSE 81837
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
81770: LD_VAR 0 8
81774: PUSH
81775: LD_INT 1
81777: ARRAY
81778: PPUSH
81779: LD_VAR 0 8
81783: PUSH
81784: LD_INT 2
81786: ARRAY
81787: PPUSH
81788: CALL_OW 488
81792: IFFALSE 81837
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
81794: LD_VAR 0 4
81798: PUSH
81799: LD_VAR 0 7
81803: ARRAY
81804: PPUSH
81805: LD_VAR 0 8
81809: PUSH
81810: LD_INT 1
81812: ARRAY
81813: PPUSH
81814: LD_VAR 0 8
81818: PUSH
81819: LD_INT 2
81821: ARRAY
81822: PPUSH
81823: CALL_OW 116
// attacking := true ;
81827: LD_ADDR_VAR 0 29
81831: PUSH
81832: LD_INT 1
81834: ST_TO_ADDR
// continue ;
81835: GO 79210
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
81837: LD_VAR 0 4
81841: PUSH
81842: LD_VAR 0 7
81846: ARRAY
81847: PPUSH
81848: CALL_OW 265
81852: PUSH
81853: LD_INT 11
81855: EQUAL
81856: IFFALSE 82134
// begin k := 10 ;
81858: LD_ADDR_VAR 0 9
81862: PUSH
81863: LD_INT 10
81865: ST_TO_ADDR
// x := 0 ;
81866: LD_ADDR_VAR 0 10
81870: PUSH
81871: LD_INT 0
81873: ST_TO_ADDR
// if tmp < k then
81874: LD_VAR 0 14
81878: PUSH
81879: LD_VAR 0 9
81883: LESS
81884: IFFALSE 81896
// k := tmp ;
81886: LD_ADDR_VAR 0 9
81890: PUSH
81891: LD_VAR 0 14
81895: ST_TO_ADDR
// for j = k downto 1 do
81896: LD_ADDR_VAR 0 8
81900: PUSH
81901: DOUBLE
81902: LD_VAR 0 9
81906: INC
81907: ST_TO_ADDR
81908: LD_INT 1
81910: PUSH
81911: FOR_DOWNTO
81912: IFFALSE 81987
// begin if GetType ( tmp [ j ] ) = unit_human then
81914: LD_VAR 0 14
81918: PUSH
81919: LD_VAR 0 8
81923: ARRAY
81924: PPUSH
81925: CALL_OW 247
81929: PUSH
81930: LD_INT 1
81932: EQUAL
81933: IFFALSE 81985
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
81935: LD_VAR 0 4
81939: PUSH
81940: LD_VAR 0 7
81944: ARRAY
81945: PPUSH
81946: LD_VAR 0 14
81950: PUSH
81951: LD_VAR 0 8
81955: ARRAY
81956: PPUSH
81957: CALL 77427 0 2
// x := tmp [ j ] ;
81961: LD_ADDR_VAR 0 10
81965: PUSH
81966: LD_VAR 0 14
81970: PUSH
81971: LD_VAR 0 8
81975: ARRAY
81976: ST_TO_ADDR
// attacking := true ;
81977: LD_ADDR_VAR 0 29
81981: PUSH
81982: LD_INT 1
81984: ST_TO_ADDR
// end ; end ;
81985: GO 81911
81987: POP
81988: POP
// if not x then
81989: LD_VAR 0 10
81993: NOT
81994: IFFALSE 82134
// begin attacking := true ;
81996: LD_ADDR_VAR 0 29
82000: PUSH
82001: LD_INT 1
82003: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
82004: LD_VAR 0 4
82008: PUSH
82009: LD_VAR 0 7
82013: ARRAY
82014: PPUSH
82015: CALL_OW 250
82019: PPUSH
82020: LD_VAR 0 4
82024: PUSH
82025: LD_VAR 0 7
82029: ARRAY
82030: PPUSH
82031: CALL_OW 251
82035: PPUSH
82036: CALL_OW 546
82040: PUSH
82041: LD_INT 2
82043: ARRAY
82044: PUSH
82045: LD_VAR 0 14
82049: PUSH
82050: LD_INT 1
82052: ARRAY
82053: PPUSH
82054: CALL_OW 250
82058: PPUSH
82059: LD_VAR 0 14
82063: PUSH
82064: LD_INT 1
82066: ARRAY
82067: PPUSH
82068: CALL_OW 251
82072: PPUSH
82073: CALL_OW 546
82077: PUSH
82078: LD_INT 2
82080: ARRAY
82081: EQUAL
82082: IFFALSE 82110
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
82084: LD_VAR 0 4
82088: PUSH
82089: LD_VAR 0 7
82093: ARRAY
82094: PPUSH
82095: LD_VAR 0 14
82099: PUSH
82100: LD_INT 1
82102: ARRAY
82103: PPUSH
82104: CALL 77427 0 2
82108: GO 82134
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82110: LD_VAR 0 4
82114: PUSH
82115: LD_VAR 0 7
82119: ARRAY
82120: PPUSH
82121: LD_VAR 0 14
82125: PUSH
82126: LD_INT 1
82128: ARRAY
82129: PPUSH
82130: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
82134: LD_VAR 0 4
82138: PUSH
82139: LD_VAR 0 7
82143: ARRAY
82144: PPUSH
82145: CALL_OW 264
82149: PUSH
82150: LD_INT 29
82152: EQUAL
82153: IFFALSE 82519
// begin if WantsToAttack ( group [ i ] ) in bombed then
82155: LD_VAR 0 4
82159: PUSH
82160: LD_VAR 0 7
82164: ARRAY
82165: PPUSH
82166: CALL_OW 319
82170: PUSH
82171: LD_VAR 0 28
82175: IN
82176: IFFALSE 82180
// continue ;
82178: GO 79210
// k := 8 ;
82180: LD_ADDR_VAR 0 9
82184: PUSH
82185: LD_INT 8
82187: ST_TO_ADDR
// x := 0 ;
82188: LD_ADDR_VAR 0 10
82192: PUSH
82193: LD_INT 0
82195: ST_TO_ADDR
// if tmp < k then
82196: LD_VAR 0 14
82200: PUSH
82201: LD_VAR 0 9
82205: LESS
82206: IFFALSE 82218
// k := tmp ;
82208: LD_ADDR_VAR 0 9
82212: PUSH
82213: LD_VAR 0 14
82217: ST_TO_ADDR
// for j = 1 to k do
82218: LD_ADDR_VAR 0 8
82222: PUSH
82223: DOUBLE
82224: LD_INT 1
82226: DEC
82227: ST_TO_ADDR
82228: LD_VAR 0 9
82232: PUSH
82233: FOR_TO
82234: IFFALSE 82366
// begin if GetType ( tmp [ j ] ) = unit_building then
82236: LD_VAR 0 14
82240: PUSH
82241: LD_VAR 0 8
82245: ARRAY
82246: PPUSH
82247: CALL_OW 247
82251: PUSH
82252: LD_INT 3
82254: EQUAL
82255: IFFALSE 82364
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
82257: LD_VAR 0 14
82261: PUSH
82262: LD_VAR 0 8
82266: ARRAY
82267: PUSH
82268: LD_VAR 0 28
82272: IN
82273: NOT
82274: PUSH
82275: LD_VAR 0 14
82279: PUSH
82280: LD_VAR 0 8
82284: ARRAY
82285: PPUSH
82286: CALL_OW 313
82290: AND
82291: IFFALSE 82364
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
82293: LD_VAR 0 4
82297: PUSH
82298: LD_VAR 0 7
82302: ARRAY
82303: PPUSH
82304: LD_VAR 0 14
82308: PUSH
82309: LD_VAR 0 8
82313: ARRAY
82314: PPUSH
82315: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
82319: LD_ADDR_VAR 0 28
82323: PUSH
82324: LD_VAR 0 28
82328: PPUSH
82329: LD_VAR 0 28
82333: PUSH
82334: LD_INT 1
82336: PLUS
82337: PPUSH
82338: LD_VAR 0 14
82342: PUSH
82343: LD_VAR 0 8
82347: ARRAY
82348: PPUSH
82349: CALL_OW 1
82353: ST_TO_ADDR
// attacking := true ;
82354: LD_ADDR_VAR 0 29
82358: PUSH
82359: LD_INT 1
82361: ST_TO_ADDR
// break ;
82362: GO 82366
// end ; end ;
82364: GO 82233
82366: POP
82367: POP
// if not attacking and f_attack_depot then
82368: LD_VAR 0 29
82372: NOT
82373: PUSH
82374: LD_VAR 0 25
82378: AND
82379: IFFALSE 82474
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82381: LD_ADDR_VAR 0 13
82385: PUSH
82386: LD_VAR 0 14
82390: PPUSH
82391: LD_INT 2
82393: PUSH
82394: LD_INT 30
82396: PUSH
82397: LD_INT 0
82399: PUSH
82400: EMPTY
82401: LIST
82402: LIST
82403: PUSH
82404: LD_INT 30
82406: PUSH
82407: LD_INT 1
82409: PUSH
82410: EMPTY
82411: LIST
82412: LIST
82413: PUSH
82414: EMPTY
82415: LIST
82416: LIST
82417: LIST
82418: PPUSH
82419: CALL_OW 72
82423: ST_TO_ADDR
// if z then
82424: LD_VAR 0 13
82428: IFFALSE 82474
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
82430: LD_VAR 0 4
82434: PUSH
82435: LD_VAR 0 7
82439: ARRAY
82440: PPUSH
82441: LD_VAR 0 13
82445: PPUSH
82446: LD_VAR 0 4
82450: PUSH
82451: LD_VAR 0 7
82455: ARRAY
82456: PPUSH
82457: CALL_OW 74
82461: PPUSH
82462: CALL_OW 115
// attacking := true ;
82466: LD_ADDR_VAR 0 29
82470: PUSH
82471: LD_INT 1
82473: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
82474: LD_VAR 0 4
82478: PUSH
82479: LD_VAR 0 7
82483: ARRAY
82484: PPUSH
82485: CALL_OW 256
82489: PUSH
82490: LD_INT 500
82492: LESS
82493: IFFALSE 82519
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82495: LD_VAR 0 4
82499: PUSH
82500: LD_VAR 0 7
82504: ARRAY
82505: PPUSH
82506: LD_VAR 0 14
82510: PUSH
82511: LD_INT 1
82513: ARRAY
82514: PPUSH
82515: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
82519: LD_VAR 0 4
82523: PUSH
82524: LD_VAR 0 7
82528: ARRAY
82529: PPUSH
82530: CALL_OW 264
82534: PUSH
82535: LD_INT 49
82537: EQUAL
82538: IFFALSE 82659
// begin if not HasTask ( group [ i ] ) then
82540: LD_VAR 0 4
82544: PUSH
82545: LD_VAR 0 7
82549: ARRAY
82550: PPUSH
82551: CALL_OW 314
82555: NOT
82556: IFFALSE 82659
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
82558: LD_ADDR_VAR 0 9
82562: PUSH
82563: LD_INT 81
82565: PUSH
82566: LD_VAR 0 4
82570: PUSH
82571: LD_VAR 0 7
82575: ARRAY
82576: PPUSH
82577: CALL_OW 255
82581: PUSH
82582: EMPTY
82583: LIST
82584: LIST
82585: PPUSH
82586: CALL_OW 69
82590: PPUSH
82591: LD_VAR 0 4
82595: PUSH
82596: LD_VAR 0 7
82600: ARRAY
82601: PPUSH
82602: CALL_OW 74
82606: ST_TO_ADDR
// if k then
82607: LD_VAR 0 9
82611: IFFALSE 82659
// if GetDistUnits ( group [ i ] , k ) > 10 then
82613: LD_VAR 0 4
82617: PUSH
82618: LD_VAR 0 7
82622: ARRAY
82623: PPUSH
82624: LD_VAR 0 9
82628: PPUSH
82629: CALL_OW 296
82633: PUSH
82634: LD_INT 10
82636: GREATER
82637: IFFALSE 82659
// ComMoveUnit ( group [ i ] , k ) ;
82639: LD_VAR 0 4
82643: PUSH
82644: LD_VAR 0 7
82648: ARRAY
82649: PPUSH
82650: LD_VAR 0 9
82654: PPUSH
82655: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82659: LD_VAR 0 4
82663: PUSH
82664: LD_VAR 0 7
82668: ARRAY
82669: PPUSH
82670: CALL_OW 256
82674: PUSH
82675: LD_INT 250
82677: LESS
82678: PUSH
82679: LD_VAR 0 4
82683: PUSH
82684: LD_VAR 0 7
82688: ARRAY
82689: PUSH
82690: LD_INT 21
82692: PUSH
82693: LD_INT 2
82695: PUSH
82696: EMPTY
82697: LIST
82698: LIST
82699: PUSH
82700: LD_INT 23
82702: PUSH
82703: LD_INT 2
82705: PUSH
82706: EMPTY
82707: LIST
82708: LIST
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PPUSH
82714: CALL_OW 69
82718: IN
82719: AND
82720: IFFALSE 82845
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
82722: LD_ADDR_VAR 0 9
82726: PUSH
82727: LD_OWVAR 3
82731: PUSH
82732: LD_VAR 0 4
82736: PUSH
82737: LD_VAR 0 7
82741: ARRAY
82742: DIFF
82743: PPUSH
82744: LD_VAR 0 4
82748: PUSH
82749: LD_VAR 0 7
82753: ARRAY
82754: PPUSH
82755: CALL_OW 74
82759: ST_TO_ADDR
// if not k then
82760: LD_VAR 0 9
82764: NOT
82765: IFFALSE 82769
// continue ;
82767: GO 79210
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
82769: LD_VAR 0 9
82773: PUSH
82774: LD_INT 81
82776: PUSH
82777: LD_VAR 0 4
82781: PUSH
82782: LD_VAR 0 7
82786: ARRAY
82787: PPUSH
82788: CALL_OW 255
82792: PUSH
82793: EMPTY
82794: LIST
82795: LIST
82796: PPUSH
82797: CALL_OW 69
82801: IN
82802: PUSH
82803: LD_VAR 0 9
82807: PPUSH
82808: LD_VAR 0 4
82812: PUSH
82813: LD_VAR 0 7
82817: ARRAY
82818: PPUSH
82819: CALL_OW 296
82823: PUSH
82824: LD_INT 5
82826: LESS
82827: AND
82828: IFFALSE 82845
// ComAutodestruct ( group [ i ] ) ;
82830: LD_VAR 0 4
82834: PUSH
82835: LD_VAR 0 7
82839: ARRAY
82840: PPUSH
82841: CALL 77325 0 1
// end ; if f_attack_depot then
82845: LD_VAR 0 25
82849: IFFALSE 82961
// begin k := 6 ;
82851: LD_ADDR_VAR 0 9
82855: PUSH
82856: LD_INT 6
82858: ST_TO_ADDR
// if tmp < k then
82859: LD_VAR 0 14
82863: PUSH
82864: LD_VAR 0 9
82868: LESS
82869: IFFALSE 82881
// k := tmp ;
82871: LD_ADDR_VAR 0 9
82875: PUSH
82876: LD_VAR 0 14
82880: ST_TO_ADDR
// for j = 1 to k do
82881: LD_ADDR_VAR 0 8
82885: PUSH
82886: DOUBLE
82887: LD_INT 1
82889: DEC
82890: ST_TO_ADDR
82891: LD_VAR 0 9
82895: PUSH
82896: FOR_TO
82897: IFFALSE 82959
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
82899: LD_VAR 0 8
82903: PPUSH
82904: CALL_OW 266
82908: PUSH
82909: LD_INT 0
82911: PUSH
82912: LD_INT 1
82914: PUSH
82915: EMPTY
82916: LIST
82917: LIST
82918: IN
82919: IFFALSE 82957
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
82921: LD_VAR 0 4
82925: PUSH
82926: LD_VAR 0 7
82930: ARRAY
82931: PPUSH
82932: LD_VAR 0 14
82936: PUSH
82937: LD_VAR 0 8
82941: ARRAY
82942: PPUSH
82943: CALL_OW 115
// attacking := true ;
82947: LD_ADDR_VAR 0 29
82951: PUSH
82952: LD_INT 1
82954: ST_TO_ADDR
// break ;
82955: GO 82959
// end ;
82957: GO 82896
82959: POP
82960: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
82961: LD_VAR 0 4
82965: PUSH
82966: LD_VAR 0 7
82970: ARRAY
82971: PPUSH
82972: CALL_OW 302
82976: PUSH
82977: LD_VAR 0 29
82981: NOT
82982: AND
82983: IFFALSE 83305
// begin if GetTag ( group [ i ] ) = 71 then
82985: LD_VAR 0 4
82989: PUSH
82990: LD_VAR 0 7
82994: ARRAY
82995: PPUSH
82996: CALL_OW 110
83000: PUSH
83001: LD_INT 71
83003: EQUAL
83004: IFFALSE 83045
// begin if HasTask ( group [ i ] ) then
83006: LD_VAR 0 4
83010: PUSH
83011: LD_VAR 0 7
83015: ARRAY
83016: PPUSH
83017: CALL_OW 314
83021: IFFALSE 83027
// continue else
83023: GO 79210
83025: GO 83045
// SetTag ( group [ i ] , 0 ) ;
83027: LD_VAR 0 4
83031: PUSH
83032: LD_VAR 0 7
83036: ARRAY
83037: PPUSH
83038: LD_INT 0
83040: PPUSH
83041: CALL_OW 109
// end ; k := 8 ;
83045: LD_ADDR_VAR 0 9
83049: PUSH
83050: LD_INT 8
83052: ST_TO_ADDR
// x := 0 ;
83053: LD_ADDR_VAR 0 10
83057: PUSH
83058: LD_INT 0
83060: ST_TO_ADDR
// if tmp < k then
83061: LD_VAR 0 14
83065: PUSH
83066: LD_VAR 0 9
83070: LESS
83071: IFFALSE 83083
// k := tmp ;
83073: LD_ADDR_VAR 0 9
83077: PUSH
83078: LD_VAR 0 14
83082: ST_TO_ADDR
// for j = 1 to k do
83083: LD_ADDR_VAR 0 8
83087: PUSH
83088: DOUBLE
83089: LD_INT 1
83091: DEC
83092: ST_TO_ADDR
83093: LD_VAR 0 9
83097: PUSH
83098: FOR_TO
83099: IFFALSE 83197
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
83101: LD_VAR 0 14
83105: PUSH
83106: LD_VAR 0 8
83110: ARRAY
83111: PPUSH
83112: CALL_OW 247
83116: PUSH
83117: LD_INT 1
83119: EQUAL
83120: PUSH
83121: LD_VAR 0 14
83125: PUSH
83126: LD_VAR 0 8
83130: ARRAY
83131: PPUSH
83132: CALL_OW 256
83136: PUSH
83137: LD_INT 250
83139: LESS
83140: PUSH
83141: LD_VAR 0 20
83145: AND
83146: PUSH
83147: LD_VAR 0 20
83151: NOT
83152: PUSH
83153: LD_VAR 0 14
83157: PUSH
83158: LD_VAR 0 8
83162: ARRAY
83163: PPUSH
83164: CALL_OW 256
83168: PUSH
83169: LD_INT 250
83171: GREATEREQUAL
83172: AND
83173: OR
83174: AND
83175: IFFALSE 83195
// begin x := tmp [ j ] ;
83177: LD_ADDR_VAR 0 10
83181: PUSH
83182: LD_VAR 0 14
83186: PUSH
83187: LD_VAR 0 8
83191: ARRAY
83192: ST_TO_ADDR
// break ;
83193: GO 83197
// end ;
83195: GO 83098
83197: POP
83198: POP
// if x then
83199: LD_VAR 0 10
83203: IFFALSE 83227
// ComAttackUnit ( group [ i ] , x ) else
83205: LD_VAR 0 4
83209: PUSH
83210: LD_VAR 0 7
83214: ARRAY
83215: PPUSH
83216: LD_VAR 0 10
83220: PPUSH
83221: CALL_OW 115
83225: GO 83251
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83227: LD_VAR 0 4
83231: PUSH
83232: LD_VAR 0 7
83236: ARRAY
83237: PPUSH
83238: LD_VAR 0 14
83242: PUSH
83243: LD_INT 1
83245: ARRAY
83246: PPUSH
83247: CALL_OW 115
// if not HasTask ( group [ i ] ) then
83251: LD_VAR 0 4
83255: PUSH
83256: LD_VAR 0 7
83260: ARRAY
83261: PPUSH
83262: CALL_OW 314
83266: NOT
83267: IFFALSE 83305
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
83269: LD_VAR 0 4
83273: PUSH
83274: LD_VAR 0 7
83278: ARRAY
83279: PPUSH
83280: LD_VAR 0 14
83284: PPUSH
83285: LD_VAR 0 4
83289: PUSH
83290: LD_VAR 0 7
83294: ARRAY
83295: PPUSH
83296: CALL_OW 74
83300: PPUSH
83301: CALL_OW 115
// end ; end ; end ;
83305: GO 79210
83307: POP
83308: POP
// wait ( 0 0$1 ) ;
83309: LD_INT 35
83311: PPUSH
83312: CALL_OW 67
// until group = [ ] ;
83316: LD_VAR 0 4
83320: PUSH
83321: EMPTY
83322: EQUAL
83323: IFFALSE 79195
// end ;
83325: LD_VAR 0 2
83329: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
83330: LD_INT 0
83332: PPUSH
83333: PPUSH
83334: PPUSH
83335: PPUSH
// if not base_units then
83336: LD_VAR 0 1
83340: NOT
83341: IFFALSE 83345
// exit ;
83343: GO 83432
// result := false ;
83345: LD_ADDR_VAR 0 2
83349: PUSH
83350: LD_INT 0
83352: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
83353: LD_ADDR_VAR 0 5
83357: PUSH
83358: LD_VAR 0 1
83362: PPUSH
83363: LD_INT 21
83365: PUSH
83366: LD_INT 3
83368: PUSH
83369: EMPTY
83370: LIST
83371: LIST
83372: PPUSH
83373: CALL_OW 72
83377: ST_TO_ADDR
// if not tmp then
83378: LD_VAR 0 5
83382: NOT
83383: IFFALSE 83387
// exit ;
83385: GO 83432
// for i in tmp do
83387: LD_ADDR_VAR 0 3
83391: PUSH
83392: LD_VAR 0 5
83396: PUSH
83397: FOR_IN
83398: IFFALSE 83430
// begin result := EnemyInRange ( i , 22 ) ;
83400: LD_ADDR_VAR 0 2
83404: PUSH
83405: LD_VAR 0 3
83409: PPUSH
83410: LD_INT 22
83412: PPUSH
83413: CALL 77008 0 2
83417: ST_TO_ADDR
// if result then
83418: LD_VAR 0 2
83422: IFFALSE 83428
// exit ;
83424: POP
83425: POP
83426: GO 83432
// end ;
83428: GO 83397
83430: POP
83431: POP
// end ;
83432: LD_VAR 0 2
83436: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
83437: LD_INT 0
83439: PPUSH
83440: PPUSH
// if not units then
83441: LD_VAR 0 1
83445: NOT
83446: IFFALSE 83450
// exit ;
83448: GO 83520
// result := [ ] ;
83450: LD_ADDR_VAR 0 3
83454: PUSH
83455: EMPTY
83456: ST_TO_ADDR
// for i in units do
83457: LD_ADDR_VAR 0 4
83461: PUSH
83462: LD_VAR 0 1
83466: PUSH
83467: FOR_IN
83468: IFFALSE 83518
// if GetTag ( i ) = tag then
83470: LD_VAR 0 4
83474: PPUSH
83475: CALL_OW 110
83479: PUSH
83480: LD_VAR 0 2
83484: EQUAL
83485: IFFALSE 83516
// result := Insert ( result , result + 1 , i ) ;
83487: LD_ADDR_VAR 0 3
83491: PUSH
83492: LD_VAR 0 3
83496: PPUSH
83497: LD_VAR 0 3
83501: PUSH
83502: LD_INT 1
83504: PLUS
83505: PPUSH
83506: LD_VAR 0 4
83510: PPUSH
83511: CALL_OW 2
83515: ST_TO_ADDR
83516: GO 83467
83518: POP
83519: POP
// end ;
83520: LD_VAR 0 3
83524: RET
// export function IsDriver ( un ) ; begin
83525: LD_INT 0
83527: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
83528: LD_ADDR_VAR 0 2
83532: PUSH
83533: LD_VAR 0 1
83537: PUSH
83538: LD_INT 55
83540: PUSH
83541: EMPTY
83542: LIST
83543: PPUSH
83544: CALL_OW 69
83548: IN
83549: ST_TO_ADDR
// end ;
83550: LD_VAR 0 2
83554: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
83555: LD_INT 0
83557: PPUSH
83558: PPUSH
// list := [ ] ;
83559: LD_ADDR_VAR 0 5
83563: PUSH
83564: EMPTY
83565: ST_TO_ADDR
// case d of 0 :
83566: LD_VAR 0 3
83570: PUSH
83571: LD_INT 0
83573: DOUBLE
83574: EQUAL
83575: IFTRUE 83579
83577: GO 83712
83579: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
83580: LD_ADDR_VAR 0 5
83584: PUSH
83585: LD_VAR 0 1
83589: PUSH
83590: LD_INT 4
83592: MINUS
83593: PUSH
83594: LD_VAR 0 2
83598: PUSH
83599: LD_INT 4
83601: MINUS
83602: PUSH
83603: LD_INT 2
83605: PUSH
83606: EMPTY
83607: LIST
83608: LIST
83609: LIST
83610: PUSH
83611: LD_VAR 0 1
83615: PUSH
83616: LD_INT 3
83618: MINUS
83619: PUSH
83620: LD_VAR 0 2
83624: PUSH
83625: LD_INT 1
83627: PUSH
83628: EMPTY
83629: LIST
83630: LIST
83631: LIST
83632: PUSH
83633: LD_VAR 0 1
83637: PUSH
83638: LD_INT 4
83640: PLUS
83641: PUSH
83642: LD_VAR 0 2
83646: PUSH
83647: LD_INT 4
83649: PUSH
83650: EMPTY
83651: LIST
83652: LIST
83653: LIST
83654: PUSH
83655: LD_VAR 0 1
83659: PUSH
83660: LD_INT 3
83662: PLUS
83663: PUSH
83664: LD_VAR 0 2
83668: PUSH
83669: LD_INT 3
83671: PLUS
83672: PUSH
83673: LD_INT 5
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: LIST
83680: PUSH
83681: LD_VAR 0 1
83685: PUSH
83686: LD_VAR 0 2
83690: PUSH
83691: LD_INT 4
83693: PLUS
83694: PUSH
83695: LD_INT 0
83697: PUSH
83698: EMPTY
83699: LIST
83700: LIST
83701: LIST
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: LIST
83707: LIST
83708: LIST
83709: ST_TO_ADDR
// end ; 1 :
83710: GO 84410
83712: LD_INT 1
83714: DOUBLE
83715: EQUAL
83716: IFTRUE 83720
83718: GO 83853
83720: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
83721: LD_ADDR_VAR 0 5
83725: PUSH
83726: LD_VAR 0 1
83730: PUSH
83731: LD_VAR 0 2
83735: PUSH
83736: LD_INT 4
83738: MINUS
83739: PUSH
83740: LD_INT 3
83742: PUSH
83743: EMPTY
83744: LIST
83745: LIST
83746: LIST
83747: PUSH
83748: LD_VAR 0 1
83752: PUSH
83753: LD_INT 3
83755: MINUS
83756: PUSH
83757: LD_VAR 0 2
83761: PUSH
83762: LD_INT 3
83764: MINUS
83765: PUSH
83766: LD_INT 2
83768: PUSH
83769: EMPTY
83770: LIST
83771: LIST
83772: LIST
83773: PUSH
83774: LD_VAR 0 1
83778: PUSH
83779: LD_INT 4
83781: MINUS
83782: PUSH
83783: LD_VAR 0 2
83787: PUSH
83788: LD_INT 1
83790: PUSH
83791: EMPTY
83792: LIST
83793: LIST
83794: LIST
83795: PUSH
83796: LD_VAR 0 1
83800: PUSH
83801: LD_VAR 0 2
83805: PUSH
83806: LD_INT 3
83808: PLUS
83809: PUSH
83810: LD_INT 0
83812: PUSH
83813: EMPTY
83814: LIST
83815: LIST
83816: LIST
83817: PUSH
83818: LD_VAR 0 1
83822: PUSH
83823: LD_INT 4
83825: PLUS
83826: PUSH
83827: LD_VAR 0 2
83831: PUSH
83832: LD_INT 4
83834: PLUS
83835: PUSH
83836: LD_INT 5
83838: PUSH
83839: EMPTY
83840: LIST
83841: LIST
83842: LIST
83843: PUSH
83844: EMPTY
83845: LIST
83846: LIST
83847: LIST
83848: LIST
83849: LIST
83850: ST_TO_ADDR
// end ; 2 :
83851: GO 84410
83853: LD_INT 2
83855: DOUBLE
83856: EQUAL
83857: IFTRUE 83861
83859: GO 83990
83861: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
83862: LD_ADDR_VAR 0 5
83866: PUSH
83867: LD_VAR 0 1
83871: PUSH
83872: LD_VAR 0 2
83876: PUSH
83877: LD_INT 3
83879: MINUS
83880: PUSH
83881: LD_INT 3
83883: PUSH
83884: EMPTY
83885: LIST
83886: LIST
83887: LIST
83888: PUSH
83889: LD_VAR 0 1
83893: PUSH
83894: LD_INT 4
83896: PLUS
83897: PUSH
83898: LD_VAR 0 2
83902: PUSH
83903: LD_INT 4
83905: PUSH
83906: EMPTY
83907: LIST
83908: LIST
83909: LIST
83910: PUSH
83911: LD_VAR 0 1
83915: PUSH
83916: LD_VAR 0 2
83920: PUSH
83921: LD_INT 4
83923: PLUS
83924: PUSH
83925: LD_INT 0
83927: PUSH
83928: EMPTY
83929: LIST
83930: LIST
83931: LIST
83932: PUSH
83933: LD_VAR 0 1
83937: PUSH
83938: LD_INT 3
83940: MINUS
83941: PUSH
83942: LD_VAR 0 2
83946: PUSH
83947: LD_INT 1
83949: PUSH
83950: EMPTY
83951: LIST
83952: LIST
83953: LIST
83954: PUSH
83955: LD_VAR 0 1
83959: PUSH
83960: LD_INT 4
83962: MINUS
83963: PUSH
83964: LD_VAR 0 2
83968: PUSH
83969: LD_INT 4
83971: MINUS
83972: PUSH
83973: LD_INT 2
83975: PUSH
83976: EMPTY
83977: LIST
83978: LIST
83979: LIST
83980: PUSH
83981: EMPTY
83982: LIST
83983: LIST
83984: LIST
83985: LIST
83986: LIST
83987: ST_TO_ADDR
// end ; 3 :
83988: GO 84410
83990: LD_INT 3
83992: DOUBLE
83993: EQUAL
83994: IFTRUE 83998
83996: GO 84131
83998: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
83999: LD_ADDR_VAR 0 5
84003: PUSH
84004: LD_VAR 0 1
84008: PUSH
84009: LD_INT 3
84011: PLUS
84012: PUSH
84013: LD_VAR 0 2
84017: PUSH
84018: LD_INT 4
84020: PUSH
84021: EMPTY
84022: LIST
84023: LIST
84024: LIST
84025: PUSH
84026: LD_VAR 0 1
84030: PUSH
84031: LD_INT 4
84033: PLUS
84034: PUSH
84035: LD_VAR 0 2
84039: PUSH
84040: LD_INT 4
84042: PLUS
84043: PUSH
84044: LD_INT 5
84046: PUSH
84047: EMPTY
84048: LIST
84049: LIST
84050: LIST
84051: PUSH
84052: LD_VAR 0 1
84056: PUSH
84057: LD_INT 4
84059: MINUS
84060: PUSH
84061: LD_VAR 0 2
84065: PUSH
84066: LD_INT 1
84068: PUSH
84069: EMPTY
84070: LIST
84071: LIST
84072: LIST
84073: PUSH
84074: LD_VAR 0 1
84078: PUSH
84079: LD_VAR 0 2
84083: PUSH
84084: LD_INT 4
84086: MINUS
84087: PUSH
84088: LD_INT 3
84090: PUSH
84091: EMPTY
84092: LIST
84093: LIST
84094: LIST
84095: PUSH
84096: LD_VAR 0 1
84100: PUSH
84101: LD_INT 3
84103: MINUS
84104: PUSH
84105: LD_VAR 0 2
84109: PUSH
84110: LD_INT 3
84112: MINUS
84113: PUSH
84114: LD_INT 2
84116: PUSH
84117: EMPTY
84118: LIST
84119: LIST
84120: LIST
84121: PUSH
84122: EMPTY
84123: LIST
84124: LIST
84125: LIST
84126: LIST
84127: LIST
84128: ST_TO_ADDR
// end ; 4 :
84129: GO 84410
84131: LD_INT 4
84133: DOUBLE
84134: EQUAL
84135: IFTRUE 84139
84137: GO 84272
84139: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84140: LD_ADDR_VAR 0 5
84144: PUSH
84145: LD_VAR 0 1
84149: PUSH
84150: LD_VAR 0 2
84154: PUSH
84155: LD_INT 4
84157: PLUS
84158: PUSH
84159: LD_INT 0
84161: PUSH
84162: EMPTY
84163: LIST
84164: LIST
84165: LIST
84166: PUSH
84167: LD_VAR 0 1
84171: PUSH
84172: LD_INT 3
84174: PLUS
84175: PUSH
84176: LD_VAR 0 2
84180: PUSH
84181: LD_INT 3
84183: PLUS
84184: PUSH
84185: LD_INT 5
84187: PUSH
84188: EMPTY
84189: LIST
84190: LIST
84191: LIST
84192: PUSH
84193: LD_VAR 0 1
84197: PUSH
84198: LD_INT 4
84200: PLUS
84201: PUSH
84202: LD_VAR 0 2
84206: PUSH
84207: LD_INT 4
84209: PUSH
84210: EMPTY
84211: LIST
84212: LIST
84213: LIST
84214: PUSH
84215: LD_VAR 0 1
84219: PUSH
84220: LD_VAR 0 2
84224: PUSH
84225: LD_INT 3
84227: MINUS
84228: PUSH
84229: LD_INT 3
84231: PUSH
84232: EMPTY
84233: LIST
84234: LIST
84235: LIST
84236: PUSH
84237: LD_VAR 0 1
84241: PUSH
84242: LD_INT 4
84244: MINUS
84245: PUSH
84246: LD_VAR 0 2
84250: PUSH
84251: LD_INT 4
84253: MINUS
84254: PUSH
84255: LD_INT 2
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: LIST
84262: PUSH
84263: EMPTY
84264: LIST
84265: LIST
84266: LIST
84267: LIST
84268: LIST
84269: ST_TO_ADDR
// end ; 5 :
84270: GO 84410
84272: LD_INT 5
84274: DOUBLE
84275: EQUAL
84276: IFTRUE 84280
84278: GO 84409
84280: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
84281: LD_ADDR_VAR 0 5
84285: PUSH
84286: LD_VAR 0 1
84290: PUSH
84291: LD_INT 4
84293: MINUS
84294: PUSH
84295: LD_VAR 0 2
84299: PUSH
84300: LD_INT 1
84302: PUSH
84303: EMPTY
84304: LIST
84305: LIST
84306: LIST
84307: PUSH
84308: LD_VAR 0 1
84312: PUSH
84313: LD_VAR 0 2
84317: PUSH
84318: LD_INT 4
84320: MINUS
84321: PUSH
84322: LD_INT 3
84324: PUSH
84325: EMPTY
84326: LIST
84327: LIST
84328: LIST
84329: PUSH
84330: LD_VAR 0 1
84334: PUSH
84335: LD_INT 4
84337: PLUS
84338: PUSH
84339: LD_VAR 0 2
84343: PUSH
84344: LD_INT 4
84346: PLUS
84347: PUSH
84348: LD_INT 5
84350: PUSH
84351: EMPTY
84352: LIST
84353: LIST
84354: LIST
84355: PUSH
84356: LD_VAR 0 1
84360: PUSH
84361: LD_INT 3
84363: PLUS
84364: PUSH
84365: LD_VAR 0 2
84369: PUSH
84370: LD_INT 4
84372: PUSH
84373: EMPTY
84374: LIST
84375: LIST
84376: LIST
84377: PUSH
84378: LD_VAR 0 1
84382: PUSH
84383: LD_VAR 0 2
84387: PUSH
84388: LD_INT 3
84390: PLUS
84391: PUSH
84392: LD_INT 0
84394: PUSH
84395: EMPTY
84396: LIST
84397: LIST
84398: LIST
84399: PUSH
84400: EMPTY
84401: LIST
84402: LIST
84403: LIST
84404: LIST
84405: LIST
84406: ST_TO_ADDR
// end ; end ;
84407: GO 84410
84409: POP
// result := list ;
84410: LD_ADDR_VAR 0 4
84414: PUSH
84415: LD_VAR 0 5
84419: ST_TO_ADDR
// end ;
84420: LD_VAR 0 4
84424: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
84425: LD_INT 0
84427: PPUSH
84428: PPUSH
84429: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
84430: LD_VAR 0 1
84434: NOT
84435: PUSH
84436: LD_VAR 0 2
84440: PUSH
84441: LD_INT 1
84443: PUSH
84444: LD_INT 2
84446: PUSH
84447: LD_INT 3
84449: PUSH
84450: LD_INT 4
84452: PUSH
84453: EMPTY
84454: LIST
84455: LIST
84456: LIST
84457: LIST
84458: IN
84459: NOT
84460: OR
84461: IFFALSE 84465
// exit ;
84463: GO 84557
// tmp := [ ] ;
84465: LD_ADDR_VAR 0 5
84469: PUSH
84470: EMPTY
84471: ST_TO_ADDR
// for i in units do
84472: LD_ADDR_VAR 0 4
84476: PUSH
84477: LD_VAR 0 1
84481: PUSH
84482: FOR_IN
84483: IFFALSE 84526
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
84485: LD_ADDR_VAR 0 5
84489: PUSH
84490: LD_VAR 0 5
84494: PPUSH
84495: LD_VAR 0 5
84499: PUSH
84500: LD_INT 1
84502: PLUS
84503: PPUSH
84504: LD_VAR 0 4
84508: PPUSH
84509: LD_VAR 0 2
84513: PPUSH
84514: CALL_OW 259
84518: PPUSH
84519: CALL_OW 2
84523: ST_TO_ADDR
84524: GO 84482
84526: POP
84527: POP
// if not tmp then
84528: LD_VAR 0 5
84532: NOT
84533: IFFALSE 84537
// exit ;
84535: GO 84557
// result := SortListByListDesc ( units , tmp ) ;
84537: LD_ADDR_VAR 0 3
84541: PUSH
84542: LD_VAR 0 1
84546: PPUSH
84547: LD_VAR 0 5
84551: PPUSH
84552: CALL_OW 77
84556: ST_TO_ADDR
// end ;
84557: LD_VAR 0 3
84561: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
84562: LD_INT 0
84564: PPUSH
84565: PPUSH
84566: PPUSH
// x := GetX ( building ) ;
84567: LD_ADDR_VAR 0 4
84571: PUSH
84572: LD_VAR 0 2
84576: PPUSH
84577: CALL_OW 250
84581: ST_TO_ADDR
// y := GetY ( building ) ;
84582: LD_ADDR_VAR 0 5
84586: PUSH
84587: LD_VAR 0 2
84591: PPUSH
84592: CALL_OW 251
84596: ST_TO_ADDR
// if GetTaskList ( unit ) then
84597: LD_VAR 0 1
84601: PPUSH
84602: CALL_OW 437
84606: IFFALSE 84701
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84608: LD_STRING e
84610: PUSH
84611: LD_VAR 0 1
84615: PPUSH
84616: CALL_OW 437
84620: PUSH
84621: LD_INT 1
84623: ARRAY
84624: PUSH
84625: LD_INT 1
84627: ARRAY
84628: EQUAL
84629: PUSH
84630: LD_VAR 0 4
84634: PUSH
84635: LD_VAR 0 1
84639: PPUSH
84640: CALL_OW 437
84644: PUSH
84645: LD_INT 1
84647: ARRAY
84648: PUSH
84649: LD_INT 2
84651: ARRAY
84652: EQUAL
84653: AND
84654: PUSH
84655: LD_VAR 0 5
84659: PUSH
84660: LD_VAR 0 1
84664: PPUSH
84665: CALL_OW 437
84669: PUSH
84670: LD_INT 1
84672: ARRAY
84673: PUSH
84674: LD_INT 3
84676: ARRAY
84677: EQUAL
84678: AND
84679: IFFALSE 84691
// result := true else
84681: LD_ADDR_VAR 0 3
84685: PUSH
84686: LD_INT 1
84688: ST_TO_ADDR
84689: GO 84699
// result := false ;
84691: LD_ADDR_VAR 0 3
84695: PUSH
84696: LD_INT 0
84698: ST_TO_ADDR
// end else
84699: GO 84709
// result := false ;
84701: LD_ADDR_VAR 0 3
84705: PUSH
84706: LD_INT 0
84708: ST_TO_ADDR
// end ;
84709: LD_VAR 0 3
84713: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
84714: LD_INT 0
84716: PPUSH
84717: PPUSH
84718: PPUSH
84719: PPUSH
// if not unit or not area then
84720: LD_VAR 0 1
84724: NOT
84725: PUSH
84726: LD_VAR 0 2
84730: NOT
84731: OR
84732: IFFALSE 84736
// exit ;
84734: GO 84901
// tmp := AreaToList ( area , i ) ;
84736: LD_ADDR_VAR 0 6
84740: PUSH
84741: LD_VAR 0 2
84745: PPUSH
84746: LD_VAR 0 5
84750: PPUSH
84751: CALL_OW 517
84755: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
84756: LD_ADDR_VAR 0 5
84760: PUSH
84761: DOUBLE
84762: LD_INT 1
84764: DEC
84765: ST_TO_ADDR
84766: LD_VAR 0 6
84770: PUSH
84771: LD_INT 1
84773: ARRAY
84774: PUSH
84775: FOR_TO
84776: IFFALSE 84891
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
84778: LD_ADDR_VAR 0 7
84782: PUSH
84783: LD_VAR 0 6
84787: PUSH
84788: LD_INT 1
84790: ARRAY
84791: PUSH
84792: LD_VAR 0 5
84796: ARRAY
84797: PUSH
84798: LD_VAR 0 6
84802: PUSH
84803: LD_INT 2
84805: ARRAY
84806: PUSH
84807: LD_VAR 0 5
84811: ARRAY
84812: PUSH
84813: EMPTY
84814: LIST
84815: LIST
84816: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
84817: LD_VAR 0 7
84821: PUSH
84822: LD_INT 1
84824: ARRAY
84825: PPUSH
84826: LD_VAR 0 7
84830: PUSH
84831: LD_INT 2
84833: ARRAY
84834: PPUSH
84835: CALL_OW 428
84839: PUSH
84840: LD_INT 0
84842: EQUAL
84843: IFFALSE 84889
// begin result := true ;
84845: LD_ADDR_VAR 0 4
84849: PUSH
84850: LD_INT 1
84852: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
84853: LD_VAR 0 1
84857: PPUSH
84858: LD_VAR 0 7
84862: PUSH
84863: LD_INT 1
84865: ARRAY
84866: PPUSH
84867: LD_VAR 0 7
84871: PUSH
84872: LD_INT 2
84874: ARRAY
84875: PPUSH
84876: LD_VAR 0 3
84880: PPUSH
84881: CALL_OW 48
// exit ;
84885: POP
84886: POP
84887: GO 84901
// end ; end ;
84889: GO 84775
84891: POP
84892: POP
// result := false ;
84893: LD_ADDR_VAR 0 4
84897: PUSH
84898: LD_INT 0
84900: ST_TO_ADDR
// end ;
84901: LD_VAR 0 4
84905: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
84906: LD_INT 0
84908: PPUSH
84909: PPUSH
84910: PPUSH
// if not side or side > 8 then
84911: LD_VAR 0 1
84915: NOT
84916: PUSH
84917: LD_VAR 0 1
84921: PUSH
84922: LD_INT 8
84924: GREATER
84925: OR
84926: IFFALSE 84930
// exit ;
84928: GO 85117
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
84930: LD_ADDR_VAR 0 4
84934: PUSH
84935: LD_INT 22
84937: PUSH
84938: LD_VAR 0 1
84942: PUSH
84943: EMPTY
84944: LIST
84945: LIST
84946: PUSH
84947: LD_INT 21
84949: PUSH
84950: LD_INT 3
84952: PUSH
84953: EMPTY
84954: LIST
84955: LIST
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: PPUSH
84961: CALL_OW 69
84965: ST_TO_ADDR
// if not tmp then
84966: LD_VAR 0 4
84970: NOT
84971: IFFALSE 84975
// exit ;
84973: GO 85117
// enable_addtolog := true ;
84975: LD_ADDR_OWVAR 81
84979: PUSH
84980: LD_INT 1
84982: ST_TO_ADDR
// AddToLog ( [ ) ;
84983: LD_STRING [
84985: PPUSH
84986: CALL_OW 561
// for i in tmp do
84990: LD_ADDR_VAR 0 3
84994: PUSH
84995: LD_VAR 0 4
84999: PUSH
85000: FOR_IN
85001: IFFALSE 85108
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85003: LD_STRING [
85005: PUSH
85006: LD_VAR 0 3
85010: PPUSH
85011: CALL_OW 266
85015: STR
85016: PUSH
85017: LD_STRING , 
85019: STR
85020: PUSH
85021: LD_VAR 0 3
85025: PPUSH
85026: CALL_OW 250
85030: STR
85031: PUSH
85032: LD_STRING , 
85034: STR
85035: PUSH
85036: LD_VAR 0 3
85040: PPUSH
85041: CALL_OW 251
85045: STR
85046: PUSH
85047: LD_STRING , 
85049: STR
85050: PUSH
85051: LD_VAR 0 3
85055: PPUSH
85056: CALL_OW 254
85060: STR
85061: PUSH
85062: LD_STRING , 
85064: STR
85065: PUSH
85066: LD_VAR 0 3
85070: PPUSH
85071: LD_INT 1
85073: PPUSH
85074: CALL_OW 268
85078: STR
85079: PUSH
85080: LD_STRING , 
85082: STR
85083: PUSH
85084: LD_VAR 0 3
85088: PPUSH
85089: LD_INT 2
85091: PPUSH
85092: CALL_OW 268
85096: STR
85097: PUSH
85098: LD_STRING ],
85100: STR
85101: PPUSH
85102: CALL_OW 561
// end ;
85106: GO 85000
85108: POP
85109: POP
// AddToLog ( ]; ) ;
85110: LD_STRING ];
85112: PPUSH
85113: CALL_OW 561
// end ;
85117: LD_VAR 0 2
85121: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85122: LD_INT 0
85124: PPUSH
85125: PPUSH
85126: PPUSH
85127: PPUSH
85128: PPUSH
// if not area or not rate or not max then
85129: LD_VAR 0 1
85133: NOT
85134: PUSH
85135: LD_VAR 0 2
85139: NOT
85140: OR
85141: PUSH
85142: LD_VAR 0 4
85146: NOT
85147: OR
85148: IFFALSE 85152
// exit ;
85150: GO 85344
// while 1 do
85152: LD_INT 1
85154: IFFALSE 85344
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85156: LD_ADDR_VAR 0 9
85160: PUSH
85161: LD_VAR 0 1
85165: PPUSH
85166: LD_INT 1
85168: PPUSH
85169: CALL_OW 287
85173: PUSH
85174: LD_INT 10
85176: MUL
85177: ST_TO_ADDR
// r := rate / 10 ;
85178: LD_ADDR_VAR 0 7
85182: PUSH
85183: LD_VAR 0 2
85187: PUSH
85188: LD_INT 10
85190: DIVREAL
85191: ST_TO_ADDR
// time := 1 1$00 ;
85192: LD_ADDR_VAR 0 8
85196: PUSH
85197: LD_INT 2100
85199: ST_TO_ADDR
// if amount < min then
85200: LD_VAR 0 9
85204: PUSH
85205: LD_VAR 0 3
85209: LESS
85210: IFFALSE 85228
// r := r * 2 else
85212: LD_ADDR_VAR 0 7
85216: PUSH
85217: LD_VAR 0 7
85221: PUSH
85222: LD_INT 2
85224: MUL
85225: ST_TO_ADDR
85226: GO 85254
// if amount > max then
85228: LD_VAR 0 9
85232: PUSH
85233: LD_VAR 0 4
85237: GREATER
85238: IFFALSE 85254
// r := r / 2 ;
85240: LD_ADDR_VAR 0 7
85244: PUSH
85245: LD_VAR 0 7
85249: PUSH
85250: LD_INT 2
85252: DIVREAL
85253: ST_TO_ADDR
// time := time / r ;
85254: LD_ADDR_VAR 0 8
85258: PUSH
85259: LD_VAR 0 8
85263: PUSH
85264: LD_VAR 0 7
85268: DIVREAL
85269: ST_TO_ADDR
// if time < 0 then
85270: LD_VAR 0 8
85274: PUSH
85275: LD_INT 0
85277: LESS
85278: IFFALSE 85295
// time := time * - 1 ;
85280: LD_ADDR_VAR 0 8
85284: PUSH
85285: LD_VAR 0 8
85289: PUSH
85290: LD_INT 1
85292: NEG
85293: MUL
85294: ST_TO_ADDR
// wait ( time ) ;
85295: LD_VAR 0 8
85299: PPUSH
85300: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
85304: LD_INT 35
85306: PPUSH
85307: LD_INT 875
85309: PPUSH
85310: CALL_OW 12
85314: PPUSH
85315: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
85319: LD_INT 1
85321: PPUSH
85322: LD_INT 5
85324: PPUSH
85325: CALL_OW 12
85329: PPUSH
85330: LD_VAR 0 1
85334: PPUSH
85335: LD_INT 1
85337: PPUSH
85338: CALL_OW 55
// end ;
85342: GO 85152
// end ;
85344: LD_VAR 0 5
85348: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
85349: LD_INT 0
85351: PPUSH
85352: PPUSH
85353: PPUSH
85354: PPUSH
85355: PPUSH
85356: PPUSH
85357: PPUSH
85358: PPUSH
// if not turrets or not factories then
85359: LD_VAR 0 1
85363: NOT
85364: PUSH
85365: LD_VAR 0 2
85369: NOT
85370: OR
85371: IFFALSE 85375
// exit ;
85373: GO 85682
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
85375: LD_ADDR_VAR 0 10
85379: PUSH
85380: LD_INT 5
85382: PUSH
85383: LD_INT 6
85385: PUSH
85386: EMPTY
85387: LIST
85388: LIST
85389: PUSH
85390: LD_INT 2
85392: PUSH
85393: LD_INT 4
85395: PUSH
85396: EMPTY
85397: LIST
85398: LIST
85399: PUSH
85400: LD_INT 3
85402: PUSH
85403: LD_INT 5
85405: PUSH
85406: EMPTY
85407: LIST
85408: LIST
85409: PUSH
85410: EMPTY
85411: LIST
85412: LIST
85413: LIST
85414: PUSH
85415: LD_INT 24
85417: PUSH
85418: LD_INT 25
85420: PUSH
85421: EMPTY
85422: LIST
85423: LIST
85424: PUSH
85425: LD_INT 23
85427: PUSH
85428: LD_INT 27
85430: PUSH
85431: EMPTY
85432: LIST
85433: LIST
85434: PUSH
85435: EMPTY
85436: LIST
85437: LIST
85438: PUSH
85439: LD_INT 42
85441: PUSH
85442: LD_INT 43
85444: PUSH
85445: EMPTY
85446: LIST
85447: LIST
85448: PUSH
85449: LD_INT 44
85451: PUSH
85452: LD_INT 46
85454: PUSH
85455: EMPTY
85456: LIST
85457: LIST
85458: PUSH
85459: LD_INT 45
85461: PUSH
85462: LD_INT 47
85464: PUSH
85465: EMPTY
85466: LIST
85467: LIST
85468: PUSH
85469: EMPTY
85470: LIST
85471: LIST
85472: LIST
85473: PUSH
85474: EMPTY
85475: LIST
85476: LIST
85477: LIST
85478: ST_TO_ADDR
// result := [ ] ;
85479: LD_ADDR_VAR 0 3
85483: PUSH
85484: EMPTY
85485: ST_TO_ADDR
// for i in turrets do
85486: LD_ADDR_VAR 0 4
85490: PUSH
85491: LD_VAR 0 1
85495: PUSH
85496: FOR_IN
85497: IFFALSE 85680
// begin nat := GetNation ( i ) ;
85499: LD_ADDR_VAR 0 7
85503: PUSH
85504: LD_VAR 0 4
85508: PPUSH
85509: CALL_OW 248
85513: ST_TO_ADDR
// weapon := 0 ;
85514: LD_ADDR_VAR 0 8
85518: PUSH
85519: LD_INT 0
85521: ST_TO_ADDR
// if not nat then
85522: LD_VAR 0 7
85526: NOT
85527: IFFALSE 85531
// continue ;
85529: GO 85496
// for j in list [ nat ] do
85531: LD_ADDR_VAR 0 5
85535: PUSH
85536: LD_VAR 0 10
85540: PUSH
85541: LD_VAR 0 7
85545: ARRAY
85546: PUSH
85547: FOR_IN
85548: IFFALSE 85589
// if GetBWeapon ( i ) = j [ 1 ] then
85550: LD_VAR 0 4
85554: PPUSH
85555: CALL_OW 269
85559: PUSH
85560: LD_VAR 0 5
85564: PUSH
85565: LD_INT 1
85567: ARRAY
85568: EQUAL
85569: IFFALSE 85587
// begin weapon := j [ 2 ] ;
85571: LD_ADDR_VAR 0 8
85575: PUSH
85576: LD_VAR 0 5
85580: PUSH
85581: LD_INT 2
85583: ARRAY
85584: ST_TO_ADDR
// break ;
85585: GO 85589
// end ;
85587: GO 85547
85589: POP
85590: POP
// if not weapon then
85591: LD_VAR 0 8
85595: NOT
85596: IFFALSE 85600
// continue ;
85598: GO 85496
// for k in factories do
85600: LD_ADDR_VAR 0 6
85604: PUSH
85605: LD_VAR 0 2
85609: PUSH
85610: FOR_IN
85611: IFFALSE 85676
// begin weapons := AvailableWeaponList ( k ) ;
85613: LD_ADDR_VAR 0 9
85617: PUSH
85618: LD_VAR 0 6
85622: PPUSH
85623: CALL_OW 478
85627: ST_TO_ADDR
// if not weapons then
85628: LD_VAR 0 9
85632: NOT
85633: IFFALSE 85637
// continue ;
85635: GO 85610
// if weapon in weapons then
85637: LD_VAR 0 8
85641: PUSH
85642: LD_VAR 0 9
85646: IN
85647: IFFALSE 85674
// begin result := [ i , weapon ] ;
85649: LD_ADDR_VAR 0 3
85653: PUSH
85654: LD_VAR 0 4
85658: PUSH
85659: LD_VAR 0 8
85663: PUSH
85664: EMPTY
85665: LIST
85666: LIST
85667: ST_TO_ADDR
// exit ;
85668: POP
85669: POP
85670: POP
85671: POP
85672: GO 85682
// end ; end ;
85674: GO 85610
85676: POP
85677: POP
// end ;
85678: GO 85496
85680: POP
85681: POP
// end ; end_of_file
85682: LD_VAR 0 3
85686: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
85687: GO 85689
85689: DISABLE
// begin ru_radar := 98 ;
85690: LD_ADDR_EXP 91
85694: PUSH
85695: LD_INT 98
85697: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
85698: LD_ADDR_EXP 92
85702: PUSH
85703: LD_INT 89
85705: ST_TO_ADDR
// us_hack := 99 ;
85706: LD_ADDR_EXP 93
85710: PUSH
85711: LD_INT 99
85713: ST_TO_ADDR
// us_artillery := 97 ;
85714: LD_ADDR_EXP 94
85718: PUSH
85719: LD_INT 97
85721: ST_TO_ADDR
// ar_bio_bomb := 91 ;
85722: LD_ADDR_EXP 95
85726: PUSH
85727: LD_INT 91
85729: ST_TO_ADDR
// end ;
85730: END
