// starting begin ResetFog ;
   0: CALL_OW 335
// Randomize ;
   4: CALL_OW 10
// InitVariables ;
   8: CALL 87 0 0
// InitMacro ;
  12: CALL 16595 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 29
// FogOff ( 1 ) ;
  22: LD_INT 1
  24: PPUSH
  25: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  29: LD_INT 8
  31: PPUSH
  32: LD_INT 1
  34: PPUSH
  35: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  39: LD_INT 4
  41: PPUSH
  42: LD_INT 3
  44: PPUSH
  45: LD_INT 6
  47: PPUSH
  48: LD_INT 3
  50: PPUSH
  51: LD_INT 2
  53: PPUSH
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 7
  59: PPUSH
  60: LD_INT 18
  62: PPUSH
  63: LD_INT 19
  65: PPUSH
  66: CALL 78733 0 9
// PrepareAmerican ;
  70: CALL 518 0 0
// PrepareArabian ;
  74: CALL 2200 0 0
// MC_Start ( ) ;
  78: CALL 17742 0 0
// Action ;
  82: CALL 7576 0 0
// end ;
  86: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , no_selected , selected ; function InitVariables ; begin
  87: LD_INT 0
  89: PPUSH
// debug := false ;
  90: LD_ADDR_EXP 1
  94: PUSH
  95: LD_INT 0
  97: ST_TO_ADDR
// game := true ;
  98: LD_ADDR_EXP 2
 102: PUSH
 103: LD_INT 1
 105: ST_TO_ADDR
// mission_prefix := 11_ ;
 106: LD_ADDR_EXP 3
 110: PUSH
 111: LD_STRING 11_
 113: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 114: LD_ADDR_EXP 4
 118: PUSH
 119: LD_STRING 10c_
 121: ST_TO_ADDR
// ar_run := false ;
 122: LD_ADDR_EXP 5
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// ar_patrol := false ;
 130: LD_ADDR_EXP 7
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// base_captured := false ;
 138: LD_ADDR_EXP 6
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// us_scout := 0 ;
 146: LD_ADDR_EXP 8
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 154: LD_ADDR_EXP 9
 158: PUSH
 159: LD_INT 0
 161: PUSH
 162: LD_INT 0
 164: PUSH
 165: LD_INT 0
 167: PUSH
 168: LD_INT 0
 170: PUSH
 171: LD_INT 0
 173: PUSH
 174: EMPTY
 175: LIST
 176: LIST
 177: LIST
 178: LIST
 179: LIST
 180: ST_TO_ADDR
// kamikazed := false ;
 181: LD_ADDR_EXP 11
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// artifact_stolen := false ;
 189: LD_ADDR_EXP 12
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// artifact_get := false ;
 197: LD_ADDR_EXP 13
 201: PUSH
 202: LD_INT 0
 204: ST_TO_ADDR
// game_time := [ 100 100$00 , 90 90$00 , 85 85$00 ] [ Difficulty ] ;
 205: LD_ADDR_EXP 15
 209: PUSH
 210: LD_INT 210000
 212: PUSH
 213: LD_INT 189000
 215: PUSH
 216: LD_INT 178500
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: PUSH
 224: LD_OWVAR 67
 228: ARRAY
 229: ST_TO_ADDR
// powell_warn := false ;
 230: LD_ADDR_EXP 16
 234: PUSH
 235: LD_INT 0
 237: ST_TO_ADDR
// loses_counter := 0 ;
 238: LD_ADDR_EXP 17
 242: PUSH
 243: LD_INT 0
 245: ST_TO_ADDR
// artifact_oncargo := false ;
 246: LD_ADDR_EXP 14
 250: PUSH
 251: LD_INT 0
 253: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 254: LD_ADDR_EXP 18
 258: PUSH
 259: LD_STRING 10_GensherEscape_1
 261: PPUSH
 262: LD_EXP 1
 266: PPUSH
 267: CALL_OW 30
 271: ST_TO_ADDR
// can_kamikazed := false ;
 272: LD_ADDR_EXP 10
 276: PUSH
 277: LD_INT 0
 279: ST_TO_ADDR
// end ;
 280: LD_VAR 0 1
 284: RET
// export function CustomInitMacro ; var i ; begin
 285: LD_INT 0
 287: PPUSH
 288: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 289: LD_ADDR_EXP 74
 293: PUSH
 294: LD_INT 20
 296: PUSH
 297: LD_INT 21
 299: PUSH
 300: LD_INT 22
 302: PUSH
 303: EMPTY
 304: LIST
 305: LIST
 306: LIST
 307: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 308: LD_ADDR_EXP 75
 312: PUSH
 313: LD_INT 28
 315: PUSH
 316: LD_INT 24
 318: PUSH
 319: LD_INT 26
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
 327: LD_INT 1
 329: PPUSH
 330: LD_INT 8
 332: PUSH
 333: LD_INT 10
 335: PUSH
 336: LD_INT 12
 338: PUSH
 339: EMPTY
 340: LIST
 341: LIST
 342: LIST
 343: PUSH
 344: LD_OWVAR 67
 348: ARRAY
 349: PPUSH
 350: LD_INT 3
 352: PPUSH
 353: CALL 38220 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 357: LD_INT 2
 359: PPUSH
 360: LD_INT 6
 362: PUSH
 363: LD_INT 8
 365: PUSH
 366: LD_INT 9
 368: PUSH
 369: EMPTY
 370: LIST
 371: LIST
 372: LIST
 373: PUSH
 374: LD_OWVAR 67
 378: ARRAY
 379: PPUSH
 380: LD_INT 2
 382: PPUSH
 383: CALL 38220 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 387: LD_INT 3
 389: PPUSH
 390: LD_INT 6
 392: PUSH
 393: LD_INT 7
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: PUSH
 404: LD_OWVAR 67
 408: ARRAY
 409: PPUSH
 410: LD_INT 1
 412: PPUSH
 413: CALL 38220 0 3
// for i = 1 to mc_bases do
 417: LD_ADDR_VAR 0 2
 421: PUSH
 422: DOUBLE
 423: LD_INT 1
 425: DEC
 426: ST_TO_ADDR
 427: LD_EXP 50
 431: PUSH
 432: FOR_TO
 433: IFFALSE 457
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 435: LD_VAR 0 2
 439: PPUSH
 440: LD_EXP 43
 444: PUSH
 445: LD_VAR 0 2
 449: ARRAY
 450: PPUSH
 451: CALL 38646 0 2
 455: GO 432
 457: POP
 458: POP
// end ;
 459: LD_VAR 0 1
 463: RET
// function Debuger ; var i ; begin
 464: LD_INT 0
 466: PPUSH
 467: PPUSH
// if not debug then
 468: LD_EXP 1
 472: NOT
 473: IFFALSE 477
// exit ;
 475: GO 513
// game_speed := 5 ;
 477: LD_ADDR_OWVAR 65
 481: PUSH
 482: LD_INT 5
 484: ST_TO_ADDR
// uc_side := 1 ;
 485: LD_ADDR_OWVAR 20
 489: PUSH
 490: LD_INT 1
 492: ST_TO_ADDR
// uc_nation := 1 ;
 493: LD_ADDR_OWVAR 21
 497: PUSH
 498: LD_INT 1
 500: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 501: LD_EXP 36
 505: PPUSH
 506: LD_INT 1
 508: PPUSH
 509: CALL_OW 235
// end ; end_of_file
 513: LD_VAR 0 1
 517: RET
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 518: LD_INT 0
 520: PPUSH
 521: PPUSH
 522: PPUSH
 523: PPUSH
 524: PPUSH
 525: PPUSH
 526: PPUSH
 527: PPUSH
// uc_side := 4 ;
 528: LD_ADDR_OWVAR 20
 532: PUSH
 533: LD_INT 4
 535: ST_TO_ADDR
// uc_nation := 1 ;
 536: LD_ADDR_OWVAR 21
 540: PUSH
 541: LD_INT 1
 543: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 544: LD_ADDR_EXP 30
 548: PUSH
 549: LD_STRING Powell
 551: PPUSH
 552: LD_INT 0
 554: PPUSH
 555: LD_STRING 
 557: PPUSH
 558: CALL 44310 0 3
 562: ST_TO_ADDR
// uc_side := 1 ;
 563: LD_ADDR_OWVAR 20
 567: PUSH
 568: LD_INT 1
 570: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 571: LD_ADDR_EXP 21
 575: PUSH
 576: LD_STRING JMM
 578: PPUSH
 579: LD_EXP 1
 583: NOT
 584: PPUSH
 585: LD_EXP 4
 589: PPUSH
 590: CALL 44310 0 3
 594: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 595: LD_EXP 21
 599: PPUSH
 600: CALL_OW 257
 604: PUSH
 605: LD_INT 4
 607: GREATER
 608: IFFALSE 622
// SetClass ( JMM , 1 ) ;
 610: LD_EXP 21
 614: PPUSH
 615: LD_INT 1
 617: PPUSH
 618: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 622: LD_ADDR_EXP 22
 626: PUSH
 627: LD_STRING Lisa
 629: PPUSH
 630: LD_EXP 1
 634: NOT
 635: PPUSH
 636: LD_EXP 4
 640: PPUSH
 641: CALL 44310 0 3
 645: ST_TO_ADDR
// if not Lisa then
 646: LD_EXP 22
 650: NOT
 651: IFFALSE 666
// Lisa := CreateCharacter ( 10_Lisa ) ;
 653: LD_ADDR_EXP 22
 657: PUSH
 658: LD_STRING 10_Lisa
 660: PPUSH
 661: CALL_OW 34
 665: ST_TO_ADDR
// if not Lisa then
 666: LD_EXP 22
 670: NOT
 671: IFFALSE 686
// Lisa := CreateCharacter ( 09_Lisa ) ;
 673: LD_ADDR_EXP 22
 677: PUSH
 678: LD_STRING 09_Lisa
 680: PPUSH
 681: CALL_OW 34
 685: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 686: LD_ADDR_EXP 31
 690: PUSH
 691: LD_STRING Cornel
 693: PPUSH
 694: LD_EXP 1
 698: NOT
 699: PPUSH
 700: LD_EXP 4
 704: PPUSH
 705: CALL 44310 0 3
 709: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 710: LD_ADDR_EXP 23
 714: PUSH
 715: LD_STRING Donaldson
 717: PPUSH
 718: LD_EXP 1
 722: NOT
 723: PPUSH
 724: LD_EXP 4
 728: PPUSH
 729: CALL 44310 0 3
 733: ST_TO_ADDR
// if not Donaldson then
 734: LD_EXP 23
 738: NOT
 739: IFFALSE 754
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 741: LD_ADDR_EXP 23
 745: PUSH
 746: LD_STRING 10_Donaldson
 748: PPUSH
 749: CALL_OW 34
 753: ST_TO_ADDR
// if not Donaldson then
 754: LD_EXP 23
 758: NOT
 759: IFFALSE 774
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 761: LD_ADDR_EXP 23
 765: PUSH
 766: LD_STRING 09_Donaldson
 768: PPUSH
 769: CALL_OW 34
 773: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 774: LD_ADDR_EXP 24
 778: PUSH
 779: LD_STRING Bobby
 781: PPUSH
 782: LD_EXP 1
 786: NOT
 787: PPUSH
 788: LD_EXP 4
 792: PPUSH
 793: CALL 44310 0 3
 797: ST_TO_ADDR
// if not Bobby then
 798: LD_EXP 24
 802: NOT
 803: IFFALSE 818
// Bobby := CreateCharacter ( 10_Bobby ) ;
 805: LD_ADDR_EXP 24
 809: PUSH
 810: LD_STRING 10_Bobby
 812: PPUSH
 813: CALL_OW 34
 817: ST_TO_ADDR
// if not Bobby then
 818: LD_EXP 24
 822: NOT
 823: IFFALSE 838
// Bobby := CreateCharacter ( 09_Bobby ) ;
 825: LD_ADDR_EXP 24
 829: PUSH
 830: LD_STRING 09_Bobby
 832: PPUSH
 833: CALL_OW 34
 837: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 838: LD_ADDR_EXP 25
 842: PUSH
 843: LD_STRING Cyrus
 845: PPUSH
 846: LD_EXP 1
 850: NOT
 851: PPUSH
 852: LD_EXP 4
 856: PPUSH
 857: CALL 44310 0 3
 861: ST_TO_ADDR
// if not Cyrus then
 862: LD_EXP 25
 866: NOT
 867: IFFALSE 882
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 869: LD_ADDR_EXP 25
 873: PUSH
 874: LD_STRING 10_Cyrus
 876: PPUSH
 877: CALL_OW 34
 881: ST_TO_ADDR
// if not Cyrus then
 882: LD_EXP 25
 886: NOT
 887: IFFALSE 902
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
 889: LD_ADDR_EXP 25
 893: PUSH
 894: LD_STRING 09_Cyrus
 896: PPUSH
 897: CALL_OW 34
 901: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
 902: LD_ADDR_EXP 26
 906: PUSH
 907: LD_STRING Denis
 909: PPUSH
 910: LD_EXP 1
 914: NOT
 915: PPUSH
 916: LD_EXP 4
 920: PPUSH
 921: CALL 44310 0 3
 925: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
 926: LD_ADDR_EXP 27
 930: PUSH
 931: LD_STRING Brown
 933: PPUSH
 934: LD_EXP 1
 938: NOT
 939: PPUSH
 940: LD_EXP 4
 944: PPUSH
 945: CALL 44310 0 3
 949: ST_TO_ADDR
// if not Brown then
 950: LD_EXP 27
 954: NOT
 955: IFFALSE 970
// Brown := CreateCharacter ( 10_Brown ) ;
 957: LD_ADDR_EXP 27
 961: PUSH
 962: LD_STRING 10_Brown
 964: PPUSH
 965: CALL_OW 34
 969: ST_TO_ADDR
// if not Brown then
 970: LD_EXP 27
 974: NOT
 975: IFFALSE 990
// Brown := CreateCharacter ( 08_Brown ) ;
 977: LD_ADDR_EXP 27
 981: PUSH
 982: LD_STRING 08_Brown
 984: PPUSH
 985: CALL_OW 34
 989: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
 990: LD_ADDR_EXP 28
 994: PUSH
 995: LD_STRING Gladstone
 997: PPUSH
 998: LD_EXP 1
1002: NOT
1003: PPUSH
1004: LD_EXP 4
1008: PPUSH
1009: CALL 44310 0 3
1013: ST_TO_ADDR
// if not Gladstone then
1014: LD_EXP 28
1018: NOT
1019: IFFALSE 1034
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1021: LD_ADDR_EXP 28
1025: PUSH
1026: LD_STRING 10_Gladstone
1028: PPUSH
1029: CALL_OW 34
1033: ST_TO_ADDR
// if not Gladstone then
1034: LD_EXP 28
1038: NOT
1039: IFFALSE 1054
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1041: LD_ADDR_EXP 28
1045: PUSH
1046: LD_STRING 08_Gladstone
1048: PPUSH
1049: CALL_OW 34
1053: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1054: LD_ADDR_EXP 29
1058: PUSH
1059: LD_STRING Houten
1061: PPUSH
1062: LD_EXP 1
1066: NOT
1067: PPUSH
1068: LD_EXP 4
1072: PPUSH
1073: CALL 44310 0 3
1077: ST_TO_ADDR
// if not Houten then
1078: LD_EXP 29
1082: NOT
1083: IFFALSE 1098
// Houten := CreateCharacter ( 10_Houten ) ;
1085: LD_ADDR_EXP 29
1089: PUSH
1090: LD_STRING 10_Houten
1092: PPUSH
1093: CALL_OW 34
1097: ST_TO_ADDR
// if not Houten then
1098: LD_EXP 29
1102: NOT
1103: IFFALSE 1118
// Houten := CreateCharacter ( 09_Houten ) ;
1105: LD_ADDR_EXP 29
1109: PUSH
1110: LD_STRING 09_Houten
1112: PPUSH
1113: CALL_OW 34
1117: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
1118: LD_ADDR_EXP 31
1122: PUSH
1123: LD_STRING Cornel
1125: PPUSH
1126: LD_EXP 1
1130: NOT
1131: PPUSH
1132: LD_EXP 4
1136: PPUSH
1137: CALL 44310 0 3
1141: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1142: LD_ADDR_EXP 32
1146: PUSH
1147: LD_STRING Gary
1149: PPUSH
1150: LD_EXP 1
1154: NOT
1155: PPUSH
1156: LD_EXP 4
1160: PPUSH
1161: CALL 44310 0 3
1165: ST_TO_ADDR
// if not Gary then
1166: LD_EXP 32
1170: NOT
1171: IFFALSE 1186
// Gary := CreateCharacter ( 10_Gary ) ;
1173: LD_ADDR_EXP 32
1177: PUSH
1178: LD_STRING 10_Gary
1180: PPUSH
1181: CALL_OW 34
1185: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1186: LD_ADDR_EXP 33
1190: PUSH
1191: LD_STRING Frank
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: LD_EXP 4
1204: PPUSH
1205: CALL 44310 0 3
1209: ST_TO_ADDR
// if not Frank then
1210: LD_EXP 33
1214: NOT
1215: IFFALSE 1230
// Frank := CreateCharacter ( 08_Frank ) ;
1217: LD_ADDR_EXP 33
1221: PUSH
1222: LD_STRING 08_Frank
1224: PPUSH
1225: CALL_OW 34
1229: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1230: LD_ADDR_EXP 34
1234: PUSH
1235: LD_STRING Kikuchi
1237: PPUSH
1238: LD_EXP 1
1242: NOT
1243: PPUSH
1244: LD_EXP 4
1248: PPUSH
1249: CALL 44310 0 3
1253: ST_TO_ADDR
// if not Kikuchi then
1254: LD_EXP 34
1258: NOT
1259: IFFALSE 1274
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1261: LD_ADDR_EXP 34
1265: PUSH
1266: LD_STRING 08_Kikuchi
1268: PPUSH
1269: CALL_OW 34
1273: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1274: LD_ADDR_VAR 0 5
1278: PUSH
1279: LD_EXP 22
1283: PUSH
1284: LD_EXP 23
1288: PUSH
1289: LD_EXP 24
1293: PUSH
1294: LD_EXP 25
1298: PUSH
1299: LD_EXP 26
1303: PUSH
1304: LD_EXP 27
1308: PUSH
1309: LD_EXP 28
1313: PUSH
1314: LD_EXP 29
1318: PUSH
1319: LD_EXP 31
1323: PUSH
1324: LD_EXP 32
1328: PUSH
1329: LD_EXP 33
1333: PUSH
1334: LD_EXP 34
1338: PUSH
1339: EMPTY
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: ST_TO_ADDR
// tmp := tmp diff 0 ;
1353: LD_ADDR_VAR 0 5
1357: PUSH
1358: LD_VAR 0 5
1362: PUSH
1363: LD_INT 0
1365: DIFF
1366: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1367: LD_ADDR_VAR 0 5
1371: PUSH
1372: LD_VAR 0 5
1376: PUSH
1377: LD_STRING 10_lock
1379: PPUSH
1380: CALL_OW 31
1384: UNION
1385: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1386: LD_ADDR_VAR 0 5
1390: PUSH
1391: LD_VAR 0 5
1395: PUSH
1396: LD_STRING 10c_lock
1398: PPUSH
1399: CALL_OW 31
1403: UNION
1404: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1405: LD_STRING 10_lock
1407: PPUSH
1408: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1412: LD_STRING 10c_lock
1414: PPUSH
1415: CALL_OW 40
// for i in tmp do
1419: LD_ADDR_VAR 0 2
1423: PUSH
1424: LD_VAR 0 5
1428: PUSH
1429: FOR_IN
1430: IFFALSE 1468
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1432: LD_VAR 0 2
1436: PPUSH
1437: CALL_OW 257
1441: PUSH
1442: LD_INT 8
1444: PUSH
1445: LD_INT 2
1447: PUSH
1448: EMPTY
1449: LIST
1450: LIST
1451: IN
1452: IFFALSE 1466
// SetClass ( i , class_soldier ) ;
1454: LD_VAR 0 2
1458: PPUSH
1459: LD_INT 1
1461: PPUSH
1462: CALL_OW 336
1466: GO 1429
1468: POP
1469: POP
// if tmp < 12 then
1470: LD_VAR 0 5
1474: PUSH
1475: LD_INT 12
1477: LESS
1478: IFFALSE 1572
// begin k := 16 - tmp ;
1480: LD_ADDR_VAR 0 3
1484: PUSH
1485: LD_INT 16
1487: PUSH
1488: LD_VAR 0 5
1492: MINUS
1493: ST_TO_ADDR
// for i = 1 to k do
1494: LD_ADDR_VAR 0 2
1498: PUSH
1499: DOUBLE
1500: LD_INT 1
1502: DEC
1503: ST_TO_ADDR
1504: LD_VAR 0 3
1508: PUSH
1509: FOR_TO
1510: IFFALSE 1570
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1512: LD_INT 0
1514: PPUSH
1515: LD_INT 1
1517: PUSH
1518: LD_INT 1
1520: PUSH
1521: LD_INT 3
1523: PUSH
1524: LD_INT 4
1526: PUSH
1527: EMPTY
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: PUSH
1533: LD_INT 1
1535: PPUSH
1536: LD_INT 4
1538: PPUSH
1539: CALL_OW 12
1543: ARRAY
1544: PPUSH
1545: LD_INT 6
1547: PPUSH
1548: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1552: LD_ADDR_VAR 0 5
1556: PUSH
1557: LD_VAR 0 5
1561: PUSH
1562: CALL_OW 44
1566: ADD
1567: ST_TO_ADDR
// end ;
1568: GO 1509
1570: POP
1571: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1572: LD_ADDR_EXP 20
1576: PUSH
1577: LD_STRING 1
1579: PPUSH
1580: LD_INT 12
1582: PPUSH
1583: LD_INT 12
1585: PPUSH
1586: LD_INT -5
1588: PUSH
1589: LD_EXP 21
1593: PUSH
1594: LD_INT -2
1596: PUSH
1597: LD_INT -3
1599: PUSH
1600: LD_INT -5
1602: PUSH
1603: EMPTY
1604: LIST
1605: LIST
1606: LIST
1607: LIST
1608: LIST
1609: PUSH
1610: LD_VAR 0 5
1614: ADD
1615: PUSH
1616: LD_INT -6
1618: PUSH
1619: LD_INT -4
1621: PUSH
1622: LD_EXP 30
1626: PUSH
1627: EMPTY
1628: LIST
1629: LIST
1630: LIST
1631: ADD
1632: PPUSH
1633: LD_INT 1
1635: PUSH
1636: LD_INT 4
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: PUSH
1643: LD_INT 3
1645: PUSH
1646: LD_INT 0
1648: PUSH
1649: LD_INT 5
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: LIST
1656: PUSH
1657: LD_INT 4
1659: PUSH
1660: LD_INT 0
1662: PUSH
1663: LD_INT 3
1665: PUSH
1666: EMPTY
1667: LIST
1668: LIST
1669: LIST
1670: PUSH
1671: LD_INT 5
1673: PUSH
1674: LD_INT 0
1676: PUSH
1677: LD_INT 2
1679: PUSH
1680: EMPTY
1681: LIST
1682: LIST
1683: LIST
1684: PUSH
1685: EMPTY
1686: LIST
1687: LIST
1688: LIST
1689: LIST
1690: PPUSH
1691: CALL_OW 42
1695: ST_TO_ADDR
// others := tmp diff selected ;
1696: LD_ADDR_VAR 0 8
1700: PUSH
1701: LD_VAR 0 5
1705: PUSH
1706: LD_EXP 20
1710: DIFF
1711: ST_TO_ADDR
// others := tmp diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1712: LD_ADDR_VAR 0 8
1716: PUSH
1717: LD_VAR 0 5
1721: PUSH
1722: LD_EXP 22
1726: PUSH
1727: LD_EXP 23
1731: PUSH
1732: LD_EXP 24
1736: PUSH
1737: LD_EXP 25
1741: PUSH
1742: LD_EXP 26
1746: PUSH
1747: LD_EXP 27
1751: PUSH
1752: LD_EXP 28
1756: PUSH
1757: LD_EXP 29
1761: PUSH
1762: LD_EXP 31
1766: PUSH
1767: LD_EXP 32
1771: PUSH
1772: LD_EXP 33
1776: PUSH
1777: LD_EXP 34
1781: PUSH
1782: EMPTY
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: DIFF
1796: ST_TO_ADDR
// no_selected := others ;
1797: LD_ADDR_EXP 19
1801: PUSH
1802: LD_VAR 0 8
1806: ST_TO_ADDR
// if no_selected then
1807: LD_EXP 19
1811: IFFALSE 1825
// SaveCharacters ( no_selected , 11_others ) ;
1813: LD_EXP 19
1817: PPUSH
1818: LD_STRING 11_others
1820: PPUSH
1821: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1825: LD_ADDR_VAR 0 6
1829: PUSH
1830: LD_INT 3
1832: PUSH
1833: LD_INT 1
1835: PUSH
1836: LD_INT 1
1838: PUSH
1839: LD_INT 4
1841: PUSH
1842: EMPTY
1843: LIST
1844: LIST
1845: LIST
1846: LIST
1847: PUSH
1848: LD_INT 2
1850: PUSH
1851: LD_INT 2
1853: PUSH
1854: LD_INT 1
1856: PUSH
1857: LD_INT 5
1859: PUSH
1860: EMPTY
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: PUSH
1866: LD_INT 4
1868: PUSH
1869: LD_INT 1
1871: PUSH
1872: LD_INT 1
1874: PUSH
1875: LD_INT 5
1877: PUSH
1878: EMPTY
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: PUSH
1884: LD_INT 2
1886: PUSH
1887: LD_INT 1
1889: PUSH
1890: LD_INT 1
1892: PUSH
1893: LD_INT 7
1895: PUSH
1896: EMPTY
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: PUSH
1902: LD_INT 3
1904: PUSH
1905: LD_INT 2
1907: PUSH
1908: LD_INT 1
1910: PUSH
1911: LD_INT 7
1913: PUSH
1914: EMPTY
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: PUSH
1920: EMPTY
1921: LIST
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: ST_TO_ADDR
// for i in JMM ^ selected do
1927: LD_ADDR_VAR 0 2
1931: PUSH
1932: LD_EXP 21
1936: PUSH
1937: LD_EXP 20
1941: ADD
1942: PUSH
1943: FOR_IN
1944: IFFALSE 2133
// begin if GetClass ( i ) = 3 then
1946: LD_VAR 0 2
1950: PPUSH
1951: CALL_OW 257
1955: PUSH
1956: LD_INT 3
1958: EQUAL
1959: IFFALSE 2116
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
1961: LD_ADDR_OWVAR 37
1965: PUSH
1966: LD_VAR 0 6
1970: PUSH
1971: LD_INT 1
1973: ARRAY
1974: PUSH
1975: LD_INT 1
1977: ARRAY
1978: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
1979: LD_ADDR_OWVAR 39
1983: PUSH
1984: LD_VAR 0 6
1988: PUSH
1989: LD_INT 1
1991: ARRAY
1992: PUSH
1993: LD_INT 2
1995: ARRAY
1996: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
1997: LD_ADDR_OWVAR 38
2001: PUSH
2002: LD_VAR 0 6
2006: PUSH
2007: LD_INT 1
2009: ARRAY
2010: PUSH
2011: LD_INT 3
2013: ARRAY
2014: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2015: LD_ADDR_OWVAR 40
2019: PUSH
2020: LD_VAR 0 6
2024: PUSH
2025: LD_INT 1
2027: ARRAY
2028: PUSH
2029: LD_INT 4
2031: ARRAY
2032: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2033: LD_ADDR_VAR 0 6
2037: PUSH
2038: LD_VAR 0 6
2042: PPUSH
2043: LD_INT 1
2045: PPUSH
2046: CALL_OW 3
2050: ST_TO_ADDR
// veh := CreateVehicle ;
2051: LD_ADDR_VAR 0 7
2055: PUSH
2056: CALL_OW 45
2060: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2061: LD_VAR 0 7
2065: PPUSH
2066: LD_INT 8
2068: PPUSH
2069: LD_INT 0
2071: PPUSH
2072: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2076: LD_VAR 0 2
2080: PPUSH
2081: LD_VAR 0 7
2085: PPUSH
2086: CALL_OW 52
// if i = JMM then
2090: LD_VAR 0 2
2094: PUSH
2095: LD_EXP 21
2099: EQUAL
2100: IFFALSE 2114
// SetMark ( veh , 1 ) ;
2102: LD_VAR 0 7
2106: PPUSH
2107: LD_INT 1
2109: PPUSH
2110: CALL_OW 242
// end else
2114: GO 2131
// PlaceUnitArea ( i , am_hum_start , false ) ;
2116: LD_VAR 0 2
2120: PPUSH
2121: LD_INT 9
2123: PPUSH
2124: LD_INT 0
2126: PPUSH
2127: CALL_OW 49
// end ;
2131: GO 1943
2133: POP
2134: POP
// vc_chassis := us_medium_tracked ;
2135: LD_ADDR_OWVAR 37
2139: PUSH
2140: LD_INT 3
2142: ST_TO_ADDR
// vc_engine := engine_solar ;
2143: LD_ADDR_OWVAR 39
2147: PUSH
2148: LD_INT 2
2150: ST_TO_ADDR
// vc_control := control_computer ;
2151: LD_ADDR_OWVAR 38
2155: PUSH
2156: LD_INT 3
2158: ST_TO_ADDR
// vc_weapon := us_radar ;
2159: LD_ADDR_OWVAR 40
2163: PUSH
2164: LD_INT 11
2166: ST_TO_ADDR
// veh := CreateVehicle ;
2167: LD_ADDR_VAR 0 7
2171: PUSH
2172: CALL_OW 45
2176: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2177: LD_VAR 0 7
2181: PPUSH
2182: LD_INT 87
2184: PPUSH
2185: LD_INT 142
2187: PPUSH
2188: LD_INT 0
2190: PPUSH
2191: CALL_OW 48
// end ; end_of_file
2195: LD_VAR 0 1
2199: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2200: LD_INT 0
2202: PPUSH
2203: PPUSH
2204: PPUSH
2205: PPUSH
2206: PPUSH
2207: PPUSH
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
2208: LD_ADDR_VAR 0 5
2212: PUSH
2213: LD_INT 6
2215: PUSH
2216: LD_INT 7
2218: PUSH
2219: LD_INT 8
2221: PUSH
2222: EMPTY
2223: LIST
2224: LIST
2225: LIST
2226: PUSH
2227: LD_OWVAR 67
2231: ARRAY
2232: ST_TO_ADDR
// uc_side := 2 ;
2233: LD_ADDR_OWVAR 20
2237: PUSH
2238: LD_INT 2
2240: ST_TO_ADDR
// uc_nation := 2 ;
2241: LD_ADDR_OWVAR 21
2245: PUSH
2246: LD_INT 2
2248: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2249: LD_ADDR_OWVAR 37
2253: PUSH
2254: LD_INT 14
2256: ST_TO_ADDR
// vc_engine := engine_siberite ;
2257: LD_ADDR_OWVAR 39
2261: PUSH
2262: LD_INT 3
2264: ST_TO_ADDR
// vc_control := control_manual ;
2265: LD_ADDR_OWVAR 38
2269: PUSH
2270: LD_INT 1
2272: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2273: LD_ADDR_OWVAR 40
2277: PUSH
2278: LD_INT 31
2280: ST_TO_ADDR
// for i = 1 to 3 do
2281: LD_ADDR_VAR 0 2
2285: PUSH
2286: DOUBLE
2287: LD_INT 1
2289: DEC
2290: ST_TO_ADDR
2291: LD_INT 3
2293: PUSH
2294: FOR_TO
2295: IFFALSE 2379
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2297: LD_INT 0
2299: PPUSH
2300: LD_INT 3
2302: PPUSH
2303: LD_VAR 0 5
2307: PPUSH
2308: CALL_OW 380
// un := CreateVehicle ;
2312: LD_ADDR_VAR 0 4
2316: PUSH
2317: CALL_OW 45
2321: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2322: LD_VAR 0 4
2326: PPUSH
2327: LD_INT 0
2329: PPUSH
2330: LD_INT 5
2332: PPUSH
2333: CALL_OW 12
2337: PPUSH
2338: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2342: LD_VAR 0 4
2346: PPUSH
2347: LD_INT 156
2349: PPUSH
2350: LD_INT 15
2352: PPUSH
2353: LD_INT 6
2355: PPUSH
2356: LD_INT 0
2358: PPUSH
2359: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2363: CALL_OW 44
2367: PPUSH
2368: LD_VAR 0 4
2372: PPUSH
2373: CALL_OW 52
// end ;
2377: GO 2294
2379: POP
2380: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ - 1 , 5 , - 1 , 4 ] ) ;
2381: LD_ADDR_EXP 37
2385: PUSH
2386: LD_INT 94
2388: PPUSH
2389: LD_INT 28
2391: PPUSH
2392: LD_STRING dammam
2394: PPUSH
2395: LD_VAR 0 5
2399: PPUSH
2400: LD_INT 10000
2402: PUSH
2403: LD_INT 1000
2405: PUSH
2406: LD_INT 300
2408: PUSH
2409: EMPTY
2410: LIST
2411: LIST
2412: LIST
2413: PPUSH
2414: LD_INT 1
2416: NEG
2417: PUSH
2418: LD_INT 5
2420: PUSH
2421: LD_INT 1
2423: NEG
2424: PUSH
2425: LD_INT 4
2427: PUSH
2428: EMPTY
2429: LIST
2430: LIST
2431: LIST
2432: LIST
2433: PPUSH
2434: CALL 54352 0 6
2438: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ - 1 , 4 , 2 , 0 ] ) ;
2439: LD_ADDR_EXP 37
2443: PUSH
2444: LD_EXP 37
2448: PUSH
2449: LD_INT 122
2451: PPUSH
2452: LD_INT 25
2454: PPUSH
2455: LD_STRING 
2457: PPUSH
2458: LD_VAR 0 5
2462: PPUSH
2463: LD_INT 500
2465: PUSH
2466: LD_INT 60
2468: PUSH
2469: LD_INT 0
2471: PUSH
2472: EMPTY
2473: LIST
2474: LIST
2475: LIST
2476: PPUSH
2477: LD_INT 1
2479: NEG
2480: PUSH
2481: LD_INT 4
2483: PUSH
2484: LD_INT 2
2486: PUSH
2487: LD_INT 0
2489: PUSH
2490: EMPTY
2491: LIST
2492: LIST
2493: LIST
2494: LIST
2495: PPUSH
2496: CALL 54352 0 6
2500: UNION
2501: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ - 1 , 5 , 3 , 2 ] ) ;
2502: LD_ADDR_EXP 35
2506: PUSH
2507: LD_INT 45
2509: PPUSH
2510: LD_INT 24
2512: PPUSH
2513: LD_STRING jeddah
2515: PPUSH
2516: LD_VAR 0 5
2520: PPUSH
2521: LD_INT 700
2523: PUSH
2524: LD_INT 300
2526: PUSH
2527: LD_INT 10
2529: PUSH
2530: EMPTY
2531: LIST
2532: LIST
2533: LIST
2534: PPUSH
2535: LD_INT 1
2537: NEG
2538: PUSH
2539: LD_INT 5
2541: PUSH
2542: LD_INT 3
2544: PUSH
2545: LD_INT 2
2547: PUSH
2548: EMPTY
2549: LIST
2550: LIST
2551: LIST
2552: LIST
2553: PPUSH
2554: CALL 54352 0 6
2558: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
2559: LD_ADDR_EXP 36
2563: PUSH
2564: LD_INT 7
2566: PPUSH
2567: LD_INT 27
2569: PPUSH
2570: LD_STRING riyadh
2572: PPUSH
2573: LD_VAR 0 5
2577: PPUSH
2578: LD_INT 500
2580: PUSH
2581: LD_INT 60
2583: PUSH
2584: LD_INT 0
2586: PUSH
2587: EMPTY
2588: LIST
2589: LIST
2590: LIST
2591: PPUSH
2592: LD_INT 4
2594: PUSH
2595: LD_INT 2
2597: PUSH
2598: LD_INT 3
2600: PUSH
2601: LD_INT 1
2603: PUSH
2604: EMPTY
2605: LIST
2606: LIST
2607: LIST
2608: LIST
2609: PPUSH
2610: CALL 54352 0 6
2614: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ - 1 , 3 , 3 , 2 ] ) ;
2615: LD_ADDR_EXP 39
2619: PUSH
2620: LD_INT 204
2622: PPUSH
2623: LD_INT 26
2625: PPUSH
2626: LD_STRING 
2628: PPUSH
2629: LD_VAR 0 5
2633: PPUSH
2634: LD_INT 500
2636: PUSH
2637: LD_INT 50
2639: PUSH
2640: LD_INT 0
2642: PUSH
2643: EMPTY
2644: LIST
2645: LIST
2646: LIST
2647: PPUSH
2648: LD_INT 1
2650: NEG
2651: PUSH
2652: LD_INT 3
2654: PUSH
2655: LD_INT 3
2657: PUSH
2658: LD_INT 2
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: LIST
2665: LIST
2666: PPUSH
2667: CALL 54352 0 6
2671: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
2672: LD_ADDR_EXP 50
2676: PUSH
2677: LD_EXP 37
2681: PUSH
2682: LD_EXP 35
2686: PUSH
2687: LD_EXP 39
2691: PUSH
2692: EMPTY
2693: LIST
2694: LIST
2695: LIST
2696: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
2697: LD_ADDR_VAR 0 2
2701: PUSH
2702: LD_INT 22
2704: PUSH
2705: LD_INT 2
2707: PUSH
2708: EMPTY
2709: LIST
2710: LIST
2711: PUSH
2712: LD_INT 30
2714: PUSH
2715: LD_INT 31
2717: PUSH
2718: EMPTY
2719: LIST
2720: LIST
2721: PUSH
2722: LD_INT 58
2724: PUSH
2725: EMPTY
2726: LIST
2727: PUSH
2728: EMPTY
2729: LIST
2730: LIST
2731: LIST
2732: PPUSH
2733: CALL_OW 69
2737: PUSH
2738: FOR_IN
2739: IFFALSE 2864
// begin if GetBase ( i ) then
2741: LD_VAR 0 2
2745: PPUSH
2746: CALL_OW 274
2750: IFFALSE 2754
// continue ;
2752: GO 2738
// d := GetDir ( i ) ;
2754: LD_ADDR_VAR 0 3
2758: PUSH
2759: LD_VAR 0 2
2763: PPUSH
2764: CALL_OW 254
2768: ST_TO_ADDR
// if d < 3 then
2769: LD_VAR 0 3
2773: PUSH
2774: LD_INT 3
2776: LESS
2777: IFFALSE 2795
// d := d + 3 else
2779: LD_ADDR_VAR 0 3
2783: PUSH
2784: LD_VAR 0 3
2788: PUSH
2789: LD_INT 3
2791: PLUS
2792: ST_TO_ADDR
2793: GO 2809
// d := d - 3 ;
2795: LD_ADDR_VAR 0 3
2799: PUSH
2800: LD_VAR 0 3
2804: PUSH
2805: LD_INT 3
2807: MINUS
2808: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
2809: LD_INT 0
2811: PPUSH
2812: LD_INT 8
2814: PPUSH
2815: LD_VAR 0 5
2819: PPUSH
2820: CALL_OW 380
// un := CreateHuman ;
2824: LD_ADDR_VAR 0 4
2828: PUSH
2829: CALL_OW 44
2833: ST_TO_ADDR
// SetDir ( un , d ) ;
2834: LD_VAR 0 4
2838: PPUSH
2839: LD_VAR 0 3
2843: PPUSH
2844: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
2848: LD_VAR 0 4
2852: PPUSH
2853: LD_VAR 0 2
2857: PPUSH
2858: CALL_OW 52
// end ;
2862: GO 2738
2864: POP
2865: POP
// if Difficulty > 1 then
2866: LD_OWVAR 67
2870: PUSH
2871: LD_INT 1
2873: GREATER
2874: IFFALSE 3245
// begin ar_kamikadze := [ ] ;
2876: LD_ADDR_EXP 42
2880: PUSH
2881: EMPTY
2882: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
2883: LD_INT 0
2885: PPUSH
2886: LD_INT 1
2888: PPUSH
2889: LD_VAR 0 5
2893: PPUSH
2894: CALL_OW 380
// un := CreateHuman ;
2898: LD_ADDR_VAR 0 4
2902: PUSH
2903: CALL_OW 44
2907: ST_TO_ADDR
// SetDir ( un , 3 ) ;
2908: LD_VAR 0 4
2912: PPUSH
2913: LD_INT 3
2915: PPUSH
2916: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
2920: LD_VAR 0 4
2924: PPUSH
2925: LD_INT 23
2927: PPUSH
2928: LD_INT 44
2930: PPUSH
2931: LD_INT 0
2933: PPUSH
2934: CALL_OW 48
// ComCrawl ( un ) ;
2938: LD_VAR 0 4
2942: PPUSH
2943: CALL_OW 137
// un := CreateHuman ;
2947: LD_ADDR_VAR 0 4
2951: PUSH
2952: CALL_OW 44
2956: ST_TO_ADDR
// SetDir ( un , 3 ) ;
2957: LD_VAR 0 4
2961: PPUSH
2962: LD_INT 3
2964: PPUSH
2965: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
2969: LD_VAR 0 4
2973: PPUSH
2974: LD_INT 30
2976: PPUSH
2977: LD_INT 39
2979: PPUSH
2980: LD_INT 0
2982: PPUSH
2983: CALL_OW 48
// ComCrawl ( un ) ;
2987: LD_VAR 0 4
2991: PPUSH
2992: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
2996: LD_INT 0
2998: PPUSH
2999: LD_INT 17
3001: PPUSH
3002: LD_VAR 0 5
3006: PPUSH
3007: CALL_OW 380
// un := CreateHuman ;
3011: LD_ADDR_VAR 0 4
3015: PUSH
3016: CALL_OW 44
3020: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3021: LD_VAR 0 4
3025: PPUSH
3026: LD_INT 3
3028: PPUSH
3029: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3033: LD_VAR 0 4
3037: PPUSH
3038: LD_INT 45
3040: PPUSH
3041: LD_INT 86
3043: PPUSH
3044: LD_INT 0
3046: PPUSH
3047: CALL_OW 48
// ComHold ( un ) ;
3051: LD_VAR 0 4
3055: PPUSH
3056: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3060: LD_ADDR_EXP 42
3064: PUSH
3065: LD_EXP 42
3069: PPUSH
3070: LD_EXP 42
3074: PUSH
3075: LD_INT 1
3077: PLUS
3078: PPUSH
3079: LD_VAR 0 4
3083: PPUSH
3084: CALL_OW 1
3088: ST_TO_ADDR
// un := CreateHuman ;
3089: LD_ADDR_VAR 0 4
3093: PUSH
3094: CALL_OW 44
3098: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3099: LD_VAR 0 4
3103: PPUSH
3104: LD_INT 3
3106: PPUSH
3107: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3111: LD_VAR 0 4
3115: PPUSH
3116: LD_INT 60
3118: PPUSH
3119: LD_INT 85
3121: PPUSH
3122: LD_INT 0
3124: PPUSH
3125: CALL_OW 48
// ComHold ( un ) ;
3129: LD_VAR 0 4
3133: PPUSH
3134: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3138: LD_ADDR_EXP 42
3142: PUSH
3143: LD_EXP 42
3147: PPUSH
3148: LD_EXP 42
3152: PUSH
3153: LD_INT 1
3155: PLUS
3156: PPUSH
3157: LD_VAR 0 4
3161: PPUSH
3162: CALL_OW 1
3166: ST_TO_ADDR
// un := CreateHuman ;
3167: LD_ADDR_VAR 0 4
3171: PUSH
3172: CALL_OW 44
3176: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3177: LD_VAR 0 4
3181: PPUSH
3182: LD_INT 3
3184: PPUSH
3185: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3189: LD_VAR 0 4
3193: PPUSH
3194: LD_INT 222
3196: PPUSH
3197: LD_INT 166
3199: PPUSH
3200: LD_INT 0
3202: PPUSH
3203: CALL_OW 48
// ComHold ( un ) ;
3207: LD_VAR 0 4
3211: PPUSH
3212: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3216: LD_ADDR_EXP 42
3220: PUSH
3221: LD_EXP 42
3225: PPUSH
3226: LD_EXP 42
3230: PUSH
3231: LD_INT 1
3233: PLUS
3234: PPUSH
3235: LD_VAR 0 4
3239: PPUSH
3240: CALL_OW 1
3244: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3245: LD_ADDR_EXP 40
3249: PUSH
3250: EMPTY
3251: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3252: LD_INT 1
3254: PPUSH
3255: LD_INT 1
3257: PPUSH
3258: LD_VAR 0 5
3262: PPUSH
3263: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3267: LD_ADDR_OWVAR 26
3271: PUSH
3272: LD_STRING Pavel Grigorovic
3274: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3275: LD_ADDR_OWVAR 33
3279: PUSH
3280: LD_STRING SecondCharsGal
3282: ST_TO_ADDR
// hc_face_number := 4 ;
3283: LD_ADDR_OWVAR 34
3287: PUSH
3288: LD_INT 4
3290: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3291: LD_ADDR_EXP 40
3295: PUSH
3296: LD_EXP 40
3300: PPUSH
3301: LD_INT 1
3303: PPUSH
3304: CALL_OW 44
3308: PPUSH
3309: CALL_OW 1
3313: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3314: LD_INT 2
3316: PPUSH
3317: LD_INT 4
3319: PPUSH
3320: LD_VAR 0 5
3324: PPUSH
3325: CALL_OW 380
// hc_name := Lucy Sebel ;
3329: LD_ADDR_OWVAR 26
3333: PUSH
3334: LD_STRING Lucy Sebel
3336: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3337: LD_ADDR_OWVAR 33
3341: PUSH
3342: LD_STRING SecondCharsGal
3344: ST_TO_ADDR
// hc_face_number := 15 ;
3345: LD_ADDR_OWVAR 34
3349: PUSH
3350: LD_INT 15
3352: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3353: LD_ADDR_EXP 40
3357: PUSH
3358: LD_EXP 40
3362: PPUSH
3363: LD_INT 2
3365: PPUSH
3366: CALL_OW 44
3370: PPUSH
3371: CALL_OW 1
3375: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3376: LD_INT 2
3378: PPUSH
3379: LD_INT 4
3381: PPUSH
3382: LD_VAR 0 5
3386: PPUSH
3387: CALL_OW 380
// hc_gallery :=  ;
3391: LD_ADDR_OWVAR 33
3395: PUSH
3396: LD_STRING 
3398: ST_TO_ADDR
// hc_name :=  ;
3399: LD_ADDR_OWVAR 26
3403: PUSH
3404: LD_STRING 
3406: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3407: LD_ADDR_EXP 40
3411: PUSH
3412: LD_EXP 40
3416: PPUSH
3417: LD_INT 3
3419: PPUSH
3420: CALL_OW 44
3424: PPUSH
3425: CALL_OW 1
3429: ST_TO_ADDR
// hc_sex := sex_male ;
3430: LD_ADDR_OWVAR 27
3434: PUSH
3435: LD_INT 1
3437: ST_TO_ADDR
// hc_class = 11 ;
3438: LD_ADDR_OWVAR 28
3442: PUSH
3443: LD_INT 11
3445: ST_TO_ADDR
// hc_gallery = sandar ;
3446: LD_ADDR_OWVAR 33
3450: PUSH
3451: LD_STRING sandar
3453: ST_TO_ADDR
// hc_face_number = 33 ;
3454: LD_ADDR_OWVAR 34
3458: PUSH
3459: LD_INT 33
3461: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
3462: LD_ADDR_OWVAR 26
3466: PUSH
3467: LD_STRING Thabit Muhair Saliba
3469: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
3470: LD_ADDR_OWVAR 31
3474: PUSH
3475: LD_INT 0
3477: PUSH
3478: LD_INT 0
3480: PUSH
3481: LD_INT 0
3483: PUSH
3484: LD_INT 0
3486: PUSH
3487: EMPTY
3488: LIST
3489: LIST
3490: LIST
3491: LIST
3492: ST_TO_ADDR
// Saliba = CreateHuman ;
3493: LD_ADDR_EXP 44
3497: PUSH
3498: CALL_OW 44
3502: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
3503: LD_EXP 44
3507: PPUSH
3508: LD_INT 7
3510: PPUSH
3511: CALL_OW 52
// if gensher_active then
3515: LD_EXP 18
3519: IFFALSE 3546
// begin Gensher = NewCharacter ( Dietrich ) ;
3521: LD_ADDR_EXP 45
3525: PUSH
3526: LD_STRING Dietrich
3528: PPUSH
3529: CALL_OW 25
3533: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
3534: LD_EXP 45
3538: PPUSH
3539: LD_INT 94
3541: PPUSH
3542: CALL_OW 52
// end ; InitHc ;
3546: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
3550: LD_ADDR_EXP 41
3554: PUSH
3555: EMPTY
3556: ST_TO_ADDR
// for i = 1 to 5 do
3557: LD_ADDR_VAR 0 2
3561: PUSH
3562: DOUBLE
3563: LD_INT 1
3565: DEC
3566: ST_TO_ADDR
3567: LD_INT 5
3569: PUSH
3570: FOR_TO
3571: IFFALSE 3743
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
3573: LD_INT 13
3575: PUSH
3576: LD_INT 14
3578: PUSH
3579: EMPTY
3580: LIST
3581: LIST
3582: PUSH
3583: LD_INT 1
3585: PPUSH
3586: LD_INT 2
3588: PPUSH
3589: CALL_OW 12
3593: ARRAY
3594: PPUSH
3595: LD_INT 1
3597: PUSH
3598: LD_INT 2
3600: PUSH
3601: EMPTY
3602: LIST
3603: LIST
3604: PUSH
3605: LD_INT 1
3607: PPUSH
3608: LD_INT 2
3610: PPUSH
3611: CALL_OW 12
3615: ARRAY
3616: PPUSH
3617: LD_INT 1
3619: PPUSH
3620: LD_INT 25
3622: PUSH
3623: LD_INT 27
3625: PUSH
3626: LD_INT 26
3628: PUSH
3629: EMPTY
3630: LIST
3631: LIST
3632: LIST
3633: PUSH
3634: LD_INT 1
3636: PPUSH
3637: LD_INT 3
3639: PPUSH
3640: CALL_OW 12
3644: ARRAY
3645: PPUSH
3646: LD_INT 60
3648: PPUSH
3649: LD_INT 100
3651: PPUSH
3652: CALL_OW 12
3656: PPUSH
3657: CALL 50943 0 5
// un := CreateVehicle ;
3661: LD_ADDR_VAR 0 4
3665: PUSH
3666: CALL_OW 45
3670: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
3671: LD_ADDR_EXP 41
3675: PUSH
3676: LD_EXP 41
3680: PPUSH
3681: LD_EXP 41
3685: PUSH
3686: LD_INT 1
3688: PLUS
3689: PPUSH
3690: LD_VAR 0 4
3694: PPUSH
3695: CALL_OW 1
3699: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3700: LD_VAR 0 4
3704: PPUSH
3705: LD_INT 0
3707: PPUSH
3708: LD_INT 5
3710: PPUSH
3711: CALL_OW 12
3715: PPUSH
3716: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
3720: LD_VAR 0 4
3724: PPUSH
3725: LD_INT 124
3727: PPUSH
3728: LD_INT 141
3730: PPUSH
3731: LD_INT 8
3733: PPUSH
3734: LD_INT 0
3736: PPUSH
3737: CALL_OW 50
// end ;
3741: GO 3570
3743: POP
3744: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
3745: LD_ADDR_EXP 43
3749: PUSH
3750: EMPTY
3751: PUSH
3752: EMPTY
3753: PUSH
3754: EMPTY
3755: PUSH
3756: EMPTY
3757: LIST
3758: LIST
3759: LIST
3760: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
3761: LD_ADDR_VAR 0 3
3765: PUSH
3766: DOUBLE
3767: LD_INT 1
3769: DEC
3770: ST_TO_ADDR
3771: LD_INT 3
3773: PUSH
3774: LD_INT 3
3776: PUSH
3777: LD_INT 4
3779: PUSH
3780: EMPTY
3781: LIST
3782: LIST
3783: LIST
3784: PUSH
3785: LD_OWVAR 67
3789: ARRAY
3790: PUSH
3791: FOR_TO
3792: IFFALSE 4006
// for i = 1 to 3 do
3794: LD_ADDR_VAR 0 2
3798: PUSH
3799: DOUBLE
3800: LD_INT 1
3802: DEC
3803: ST_TO_ADDR
3804: LD_INT 3
3806: PUSH
3807: FOR_TO
3808: IFFALSE 4002
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
3810: LD_INT 14
3812: PPUSH
3813: LD_INT 3
3815: PUSH
3816: LD_INT 2
3818: PUSH
3819: EMPTY
3820: LIST
3821: LIST
3822: PUSH
3823: LD_INT 1
3825: PPUSH
3826: LD_INT 2
3828: PPUSH
3829: CALL_OW 12
3833: ARRAY
3834: PPUSH
3835: LD_INT 1
3837: PUSH
3838: LD_INT 5
3840: PUSH
3841: EMPTY
3842: LIST
3843: LIST
3844: PUSH
3845: LD_INT 1
3847: PPUSH
3848: LD_INT 2
3850: PPUSH
3851: CALL_OW 12
3855: ARRAY
3856: PPUSH
3857: LD_INT 25
3859: PUSH
3860: LD_INT 27
3862: PUSH
3863: LD_INT 26
3865: PUSH
3866: LD_INT 28
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: PUSH
3875: LD_INT 1
3877: PPUSH
3878: LD_INT 4
3880: PPUSH
3881: CALL_OW 12
3885: ARRAY
3886: PPUSH
3887: LD_INT 100
3889: PPUSH
3890: CALL 50943 0 5
// un := CreateVehicle ;
3894: LD_ADDR_VAR 0 4
3898: PUSH
3899: CALL_OW 45
3903: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
3904: LD_ADDR_EXP 43
3908: PUSH
3909: LD_EXP 43
3913: PPUSH
3914: LD_VAR 0 2
3918: PUSH
3919: LD_EXP 43
3923: PUSH
3924: LD_VAR 0 2
3928: ARRAY
3929: PUSH
3930: LD_INT 1
3932: PLUS
3933: PUSH
3934: EMPTY
3935: LIST
3936: LIST
3937: PPUSH
3938: LD_VAR 0 4
3942: PPUSH
3943: CALL 51065 0 3
3947: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3948: LD_VAR 0 4
3952: PPUSH
3953: LD_INT 0
3955: PPUSH
3956: LD_INT 5
3958: PPUSH
3959: CALL_OW 12
3963: PPUSH
3964: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
3968: LD_VAR 0 4
3972: PPUSH
3973: LD_INT 20
3975: PUSH
3976: LD_INT 21
3978: PUSH
3979: LD_INT 22
3981: PUSH
3982: EMPTY
3983: LIST
3984: LIST
3985: LIST
3986: PUSH
3987: LD_VAR 0 2
3991: ARRAY
3992: PPUSH
3993: LD_INT 0
3995: PPUSH
3996: CALL_OW 49
// end ;
4000: GO 3807
4002: POP
4003: POP
4004: GO 3791
4006: POP
4007: POP
// InitHc ;
4008: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4012: LD_INT 4
4014: PPUSH
4015: LD_INT 5
4017: PPUSH
4018: LD_INT 10
4020: PPUSH
4021: LD_INT 5
4023: PPUSH
4024: LD_INT 0
4026: PPUSH
4027: CALL_OW 58
// end ;
4031: LD_VAR 0 1
4035: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4036: LD_EXP 42
4040: IFFALSE 4114
4042: GO 4044
4044: DISABLE
4045: LD_INT 0
4047: PPUSH
// begin enable ;
4048: ENABLE
// for i in ar_kamikadze do
4049: LD_ADDR_VAR 0 1
4053: PUSH
4054: LD_EXP 42
4058: PUSH
4059: FOR_IN
4060: IFFALSE 4112
// if See ( 1 , i ) then
4062: LD_INT 1
4064: PPUSH
4065: LD_VAR 0 1
4069: PPUSH
4070: CALL_OW 292
4074: IFFALSE 4110
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4076: LD_VAR 0 1
4080: PPUSH
4081: LD_INT 81
4083: PUSH
4084: LD_INT 2
4086: PUSH
4087: EMPTY
4088: LIST
4089: LIST
4090: PPUSH
4091: CALL_OW 69
4095: PPUSH
4096: LD_VAR 0 1
4100: PPUSH
4101: CALL_OW 74
4105: PPUSH
4106: CALL_OW 115
4110: GO 4059
4112: POP
4113: POP
// end ;
4114: PPOPN 1
4116: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4117: LD_EXP 13
4121: IFFALSE 4438
4123: GO 4125
4125: DISABLE
4126: LD_INT 0
4128: PPUSH
4129: PPUSH
4130: PPUSH
4131: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4132: LD_INT 35
4134: PPUSH
4135: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4139: LD_INT 1
4141: PPUSH
4142: CALL 38992 0 1
4146: PUSH
4147: LD_INT 0
4149: EQUAL
4150: IFFALSE 4132
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4152: LD_INT 1
4154: PPUSH
4155: LD_INT 14
4157: PUSH
4158: LD_INT 3
4160: PUSH
4161: LD_INT 2
4163: PUSH
4164: LD_INT 32
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: LIST
4171: LIST
4172: PUSH
4173: EMPTY
4174: LIST
4175: PPUSH
4176: CALL 38538 0 2
// repeat wait ( 0 0$1 ) ;
4180: LD_INT 35
4182: PPUSH
4183: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4187: LD_EXP 69
4191: PUSH
4192: LD_INT 1
4194: ARRAY
4195: PPUSH
4196: LD_INT 33
4198: PUSH
4199: LD_INT 2
4201: PUSH
4202: EMPTY
4203: LIST
4204: LIST
4205: PUSH
4206: LD_INT 34
4208: PUSH
4209: LD_INT 32
4211: PUSH
4212: EMPTY
4213: LIST
4214: LIST
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: PPUSH
4220: CALL_OW 72
4224: IFFALSE 4180
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4226: LD_ADDR_VAR 0 2
4230: PUSH
4231: LD_EXP 69
4235: PUSH
4236: LD_INT 1
4238: ARRAY
4239: PPUSH
4240: LD_INT 33
4242: PUSH
4243: LD_INT 2
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: PUSH
4250: LD_INT 34
4252: PUSH
4253: LD_INT 32
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: PPUSH
4264: CALL_OW 72
4268: PUSH
4269: LD_INT 1
4271: ARRAY
4272: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4273: LD_ADDR_VAR 0 4
4277: PUSH
4278: LD_INT 5
4280: PPUSH
4281: CALL_OW 469
4285: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4286: LD_INT 35
4288: PPUSH
4289: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4293: LD_ADDR_VAR 0 4
4297: PUSH
4298: LD_INT 5
4300: PPUSH
4301: CALL_OW 469
4305: ST_TO_ADDR
// tmp := 100 ;
4306: LD_ADDR_VAR 0 3
4310: PUSH
4311: LD_INT 100
4313: ST_TO_ADDR
// if pos then
4314: LD_VAR 0 4
4318: IFFALSE 4358
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4320: LD_ADDR_VAR 0 3
4324: PUSH
4325: LD_INT 2
4327: PPUSH
4328: LD_VAR 0 4
4332: PUSH
4333: LD_INT 1
4335: ARRAY
4336: PPUSH
4337: LD_VAR 0 4
4341: PUSH
4342: LD_INT 2
4344: ARRAY
4345: PPUSH
4346: LD_INT 20
4348: PPUSH
4349: CALL 51961 0 4
4353: PUSH
4354: LD_INT 4
4356: ARRAY
4357: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4358: LD_VAR 0 4
4362: PUSH
4363: LD_EXP 14
4367: NOT
4368: AND
4369: PUSH
4370: LD_VAR 0 3
4374: PUSH
4375: LD_INT 10
4377: LESS
4378: AND
4379: IFFALSE 4286
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4381: LD_VAR 0 2
4385: PPUSH
4386: LD_VAR 0 4
4390: PUSH
4391: LD_INT 1
4393: ARRAY
4394: PPUSH
4395: LD_VAR 0 4
4399: PUSH
4400: LD_INT 2
4402: ARRAY
4403: PPUSH
4404: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4408: LD_VAR 0 2
4412: PPUSH
4413: LD_INT 198
4415: PPUSH
4416: LD_INT 113
4418: PPUSH
4419: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
4423: LD_VAR 0 2
4427: PPUSH
4428: LD_INT 124
4430: PPUSH
4431: LD_INT 7
4433: PPUSH
4434: CALL_OW 171
// end ;
4438: PPOPN 4
4440: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
4441: LD_EXP 6
4445: IFFALSE 7102
4447: GO 4449
4449: DISABLE
4450: LD_INT 0
4452: PPUSH
4453: PPUSH
4454: PPUSH
4455: PPUSH
4456: PPUSH
4457: PPUSH
4458: PPUSH
4459: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4460: LD_ADDR_VAR 0 4
4464: PUSH
4465: LD_INT 5
4467: PUSH
4468: LD_INT 6
4470: PUSH
4471: LD_INT 7
4473: PUSH
4474: EMPTY
4475: LIST
4476: LIST
4477: LIST
4478: PUSH
4479: LD_OWVAR 67
4483: ARRAY
4484: ST_TO_ADDR
// coords := [ ] ;
4485: LD_ADDR_VAR 0 5
4489: PUSH
4490: EMPTY
4491: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
4492: LD_ADDR_VAR 0 6
4496: PUSH
4497: LD_INT 0
4499: PUSH
4500: LD_INT 0
4502: PUSH
4503: LD_INT 0
4505: PUSH
4506: LD_INT 0
4508: PUSH
4509: LD_INT 1
4511: PUSH
4512: LD_INT 0
4514: PUSH
4515: LD_INT 0
4517: PUSH
4518: LD_INT 0
4520: PUSH
4521: LD_INT 1
4523: PUSH
4524: LD_INT 0
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: LIST
4531: LIST
4532: LIST
4533: LIST
4534: LIST
4535: LIST
4536: LIST
4537: LIST
4538: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
4539: LD_INT 1
4541: PPUSH
4542: LD_INT 14
4544: PUSH
4545: LD_INT 1
4547: PUSH
4548: LD_INT 2
4550: PUSH
4551: LD_INT 28
4553: PUSH
4554: EMPTY
4555: LIST
4556: LIST
4557: LIST
4558: LIST
4559: PUSH
4560: LD_INT 14
4562: PUSH
4563: LD_INT 1
4565: PUSH
4566: LD_INT 2
4568: PUSH
4569: LD_INT 25
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: LIST
4576: LIST
4577: PUSH
4578: LD_INT 14
4580: PUSH
4581: LD_INT 1
4583: PUSH
4584: LD_INT 2
4586: PUSH
4587: LD_INT 28
4589: PUSH
4590: EMPTY
4591: LIST
4592: LIST
4593: LIST
4594: LIST
4595: PUSH
4596: LD_INT 14
4598: PUSH
4599: LD_INT 1
4601: PUSH
4602: LD_INT 2
4604: PUSH
4605: LD_INT 29
4607: PUSH
4608: EMPTY
4609: LIST
4610: LIST
4611: LIST
4612: LIST
4613: PUSH
4614: EMPTY
4615: LIST
4616: LIST
4617: LIST
4618: LIST
4619: PPUSH
4620: CALL 38538 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
4624: LD_INT 21000
4626: PUSH
4627: LD_INT 19950
4629: PUSH
4630: LD_INT 18900
4632: PUSH
4633: EMPTY
4634: LIST
4635: LIST
4636: LIST
4637: PUSH
4638: LD_OWVAR 67
4642: ARRAY
4643: PPUSH
4644: CALL_OW 67
// InitHc ;
4648: CALL_OW 19
// InitUc ;
4652: CALL_OW 18
// uc_side := 2 ;
4656: LD_ADDR_OWVAR 20
4660: PUSH
4661: LD_INT 2
4663: ST_TO_ADDR
// uc_nation := 2 ;
4664: LD_ADDR_OWVAR 21
4668: PUSH
4669: LD_INT 2
4671: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
4672: LD_ADDR_VAR 0 3
4676: PUSH
4677: EMPTY
4678: PUSH
4679: EMPTY
4680: PUSH
4681: EMPTY
4682: PUSH
4683: EMPTY
4684: PUSH
4685: EMPTY
4686: PUSH
4687: EMPTY
4688: LIST
4689: LIST
4690: LIST
4691: LIST
4692: LIST
4693: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_weapon , ar_cargo_bay ] ) ) ;
4694: LD_ADDR_VAR 0 3
4698: PUSH
4699: LD_VAR 0 3
4703: PPUSH
4704: LD_INT 1
4706: PPUSH
4707: LD_EXP 69
4711: PUSH
4712: LD_INT 1
4714: ARRAY
4715: PUSH
4716: LD_INT 34
4718: PUSH
4719: LD_INT 32
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: PPUSH
4726: CALL_OW 69
4730: DIFF
4731: PPUSH
4732: CALL_OW 1
4736: ST_TO_ADDR
// for i = 1 to Difficulty do
4737: LD_ADDR_VAR 0 1
4741: PUSH
4742: DOUBLE
4743: LD_INT 1
4745: DEC
4746: ST_TO_ADDR
4747: LD_OWVAR 67
4751: PUSH
4752: FOR_TO
4753: IFFALSE 4891
// begin uc_side := 2 ;
4755: LD_ADDR_OWVAR 20
4759: PUSH
4760: LD_INT 2
4762: ST_TO_ADDR
// uc_nation := 2 ;
4763: LD_ADDR_OWVAR 21
4767: PUSH
4768: LD_INT 2
4770: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
4771: LD_INT 13
4773: PPUSH
4774: LD_INT 3
4776: PPUSH
4777: LD_INT 5
4779: PPUSH
4780: LD_INT 29
4782: PPUSH
4783: LD_INT 100
4785: PPUSH
4786: CALL 50943 0 5
// un := CreateVehicle ;
4790: LD_ADDR_VAR 0 2
4794: PUSH
4795: CALL_OW 45
4799: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
4800: LD_ADDR_VAR 0 3
4804: PUSH
4805: LD_VAR 0 3
4809: PPUSH
4810: LD_INT 1
4812: PUSH
4813: LD_VAR 0 3
4817: PUSH
4818: LD_INT 1
4820: ARRAY
4821: PUSH
4822: LD_INT 1
4824: PLUS
4825: PUSH
4826: EMPTY
4827: LIST
4828: LIST
4829: PPUSH
4830: LD_VAR 0 2
4834: PPUSH
4835: CALL 51065 0 3
4839: ST_TO_ADDR
// SetDir ( un , 3 ) ;
4840: LD_VAR 0 2
4844: PPUSH
4845: LD_INT 3
4847: PPUSH
4848: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
4852: LD_VAR 0 2
4856: PPUSH
4857: LD_INT 16
4859: PPUSH
4860: LD_INT 0
4862: PPUSH
4863: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
4867: LD_VAR 0 2
4871: PPUSH
4872: LD_INT 51
4874: PPUSH
4875: LD_INT 10
4877: PPUSH
4878: CALL_OW 111
// wait ( 0 0$2 ) ;
4882: LD_INT 70
4884: PPUSH
4885: CALL_OW 67
// end ;
4889: GO 4752
4891: POP
4892: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
4893: LD_ADDR_VAR 0 5
4897: PUSH
4898: LD_INT 51
4900: PUSH
4901: LD_INT 24
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: PUSH
4908: LD_INT 75
4910: PUSH
4911: LD_INT 90
4913: PUSH
4914: EMPTY
4915: LIST
4916: LIST
4917: PUSH
4918: EMPTY
4919: LIST
4920: LIST
4921: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
4922: LD_INT 1
4924: PPUSH
4925: LD_VAR 0 3
4929: PUSH
4930: LD_INT 1
4932: ARRAY
4933: PPUSH
4934: LD_VAR 0 5
4938: PPUSH
4939: LD_VAR 0 6
4943: PPUSH
4944: CALL 38829 0 4
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
4948: LD_ADDR_VAR 0 1
4952: PUSH
4953: DOUBLE
4954: LD_INT 1
4956: DEC
4957: ST_TO_ADDR
4958: LD_INT 2
4960: PUSH
4961: LD_INT 3
4963: PUSH
4964: LD_INT 3
4966: PUSH
4967: EMPTY
4968: LIST
4969: LIST
4970: LIST
4971: PUSH
4972: LD_OWVAR 67
4976: ARRAY
4977: PUSH
4978: FOR_TO
4979: IFFALSE 5079
// begin uc_side := 2 ;
4981: LD_ADDR_OWVAR 20
4985: PUSH
4986: LD_INT 2
4988: ST_TO_ADDR
// uc_nation := 2 ;
4989: LD_ADDR_OWVAR 21
4993: PUSH
4994: LD_INT 2
4996: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
4997: LD_INT 0
4999: PPUSH
5000: LD_INT 17
5002: PPUSH
5003: LD_VAR 0 4
5007: PPUSH
5008: CALL_OW 380
// un := CreateHuman ;
5012: LD_ADDR_VAR 0 2
5016: PUSH
5017: CALL_OW 44
5021: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5022: LD_ADDR_VAR 0 3
5026: PUSH
5027: LD_VAR 0 3
5031: PPUSH
5032: LD_INT 2
5034: PUSH
5035: LD_VAR 0 3
5039: PUSH
5040: LD_INT 2
5042: ARRAY
5043: PUSH
5044: LD_INT 1
5046: PLUS
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PPUSH
5052: LD_VAR 0 2
5056: PPUSH
5057: CALL 51065 0 3
5061: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5062: LD_VAR 0 2
5066: PPUSH
5067: LD_INT 13
5069: PPUSH
5070: LD_INT 0
5072: PPUSH
5073: CALL_OW 49
// end ;
5077: GO 4978
5079: POP
5080: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
5081: LD_ADDR_VAR 0 1
5085: PUSH
5086: DOUBLE
5087: LD_INT 1
5089: DEC
5090: ST_TO_ADDR
5091: LD_INT 2
5093: PUSH
5094: LD_INT 3
5096: PUSH
5097: LD_INT 3
5099: PUSH
5100: EMPTY
5101: LIST
5102: LIST
5103: LIST
5104: PUSH
5105: LD_OWVAR 67
5109: ARRAY
5110: PUSH
5111: FOR_TO
5112: IFFALSE 5231
// begin uc_side := 2 ;
5114: LD_ADDR_OWVAR 20
5118: PUSH
5119: LD_INT 2
5121: ST_TO_ADDR
// uc_nation := 2 ;
5122: LD_ADDR_OWVAR 21
5126: PUSH
5127: LD_INT 2
5129: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ rand ( 1 , 2 ) ] , skill ) ;
5130: LD_INT 0
5132: PPUSH
5133: LD_INT 1
5135: PUSH
5136: LD_INT 8
5138: PUSH
5139: EMPTY
5140: LIST
5141: LIST
5142: PUSH
5143: LD_INT 1
5145: PPUSH
5146: LD_INT 2
5148: PPUSH
5149: CALL_OW 12
5153: ARRAY
5154: PPUSH
5155: LD_VAR 0 4
5159: PPUSH
5160: CALL_OW 380
// un := CreateHuman ;
5164: LD_ADDR_VAR 0 2
5168: PUSH
5169: CALL_OW 44
5173: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5174: LD_ADDR_VAR 0 3
5178: PUSH
5179: LD_VAR 0 3
5183: PPUSH
5184: LD_INT 2
5186: PUSH
5187: LD_VAR 0 3
5191: PUSH
5192: LD_INT 2
5194: ARRAY
5195: PUSH
5196: LD_INT 1
5198: PLUS
5199: PUSH
5200: EMPTY
5201: LIST
5202: LIST
5203: PPUSH
5204: LD_VAR 0 2
5208: PPUSH
5209: CALL 51065 0 3
5213: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5214: LD_VAR 0 2
5218: PPUSH
5219: LD_INT 13
5221: PPUSH
5222: LD_INT 0
5224: PPUSH
5225: CALL_OW 49
// end ;
5229: GO 5111
5231: POP
5232: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5233: LD_ADDR_VAR 0 5
5237: PUSH
5238: LD_INT 67
5240: PUSH
5241: LD_INT 112
5243: PUSH
5244: EMPTY
5245: LIST
5246: LIST
5247: PUSH
5248: LD_INT 85
5250: PUSH
5251: LD_INT 130
5253: PUSH
5254: EMPTY
5255: LIST
5256: LIST
5257: PUSH
5258: EMPTY
5259: LIST
5260: LIST
5261: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5262: LD_INT 2
5264: PPUSH
5265: LD_VAR 0 3
5269: PUSH
5270: LD_INT 2
5272: ARRAY
5273: PPUSH
5274: LD_VAR 0 5
5278: PPUSH
5279: LD_VAR 0 6
5283: PPUSH
5284: CALL 38829 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5288: LD_ADDR_VAR 0 1
5292: PUSH
5293: DOUBLE
5294: LD_INT 1
5296: DEC
5297: ST_TO_ADDR
5298: LD_INT 1
5300: PUSH
5301: LD_INT 2
5303: PUSH
5304: LD_INT 3
5306: PUSH
5307: EMPTY
5308: LIST
5309: LIST
5310: LIST
5311: PUSH
5312: LD_OWVAR 67
5316: ARRAY
5317: PUSH
5318: FOR_TO
5319: IFFALSE 5419
// begin uc_side := 2 ;
5321: LD_ADDR_OWVAR 20
5325: PUSH
5326: LD_INT 2
5328: ST_TO_ADDR
// uc_nation := 2 ;
5329: LD_ADDR_OWVAR 21
5333: PUSH
5334: LD_INT 2
5336: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5337: LD_INT 0
5339: PPUSH
5340: LD_INT 17
5342: PPUSH
5343: LD_VAR 0 4
5347: PPUSH
5348: CALL_OW 380
// un := CreateHuman ;
5352: LD_ADDR_VAR 0 2
5356: PUSH
5357: CALL_OW 44
5361: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5362: LD_ADDR_VAR 0 3
5366: PUSH
5367: LD_VAR 0 3
5371: PPUSH
5372: LD_INT 3
5374: PUSH
5375: LD_VAR 0 3
5379: PUSH
5380: LD_INT 3
5382: ARRAY
5383: PUSH
5384: LD_INT 1
5386: PLUS
5387: PUSH
5388: EMPTY
5389: LIST
5390: LIST
5391: PPUSH
5392: LD_VAR 0 2
5396: PPUSH
5397: CALL 51065 0 3
5401: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5402: LD_VAR 0 2
5406: PPUSH
5407: LD_INT 14
5409: PPUSH
5410: LD_INT 0
5412: PPUSH
5413: CALL_OW 49
// end ;
5417: GO 5318
5419: POP
5420: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
5421: LD_ADDR_VAR 0 5
5425: PUSH
5426: LD_INT 148
5428: PUSH
5429: LD_INT 158
5431: PUSH
5432: EMPTY
5433: LIST
5434: LIST
5435: PUSH
5436: LD_INT 148
5438: PUSH
5439: LD_INT 158
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: PUSH
5446: EMPTY
5447: LIST
5448: LIST
5449: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
5450: LD_INT 3
5452: PPUSH
5453: LD_VAR 0 3
5457: PUSH
5458: LD_INT 3
5460: ARRAY
5461: PPUSH
5462: LD_VAR 0 5
5466: PPUSH
5467: LD_VAR 0 6
5471: PPUSH
5472: CALL 38829 0 4
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
5476: LD_ADDR_VAR 0 1
5480: PUSH
5481: DOUBLE
5482: LD_INT 1
5484: DEC
5485: ST_TO_ADDR
5486: LD_INT 3
5488: PUSH
5489: LD_INT 4
5491: PUSH
5492: LD_INT 4
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: LIST
5499: PUSH
5500: LD_OWVAR 67
5504: ARRAY
5505: PUSH
5506: FOR_TO
5507: IFFALSE 5731
// begin uc_side := 2 ;
5509: LD_ADDR_OWVAR 20
5513: PUSH
5514: LD_INT 2
5516: ST_TO_ADDR
// uc_nation := 2 ;
5517: LD_ADDR_OWVAR 21
5521: PUSH
5522: LD_INT 2
5524: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
5525: LD_INT 14
5527: PPUSH
5528: LD_INT 3
5530: PPUSH
5531: LD_INT 1
5533: PUSH
5534: LD_INT 5
5536: PUSH
5537: EMPTY
5538: LIST
5539: LIST
5540: PUSH
5541: LD_INT 1
5543: PPUSH
5544: LD_INT 2
5546: PPUSH
5547: CALL_OW 12
5551: ARRAY
5552: PPUSH
5553: LD_INT 27
5555: PUSH
5556: LD_INT 26
5558: PUSH
5559: LD_INT 28
5561: PUSH
5562: EMPTY
5563: LIST
5564: LIST
5565: LIST
5566: PUSH
5567: LD_INT 1
5569: PPUSH
5570: LD_INT 3
5572: PPUSH
5573: CALL_OW 12
5577: ARRAY
5578: PPUSH
5579: LD_INT 100
5581: PPUSH
5582: CALL 50943 0 5
// un := CreateVehicle ;
5586: LD_ADDR_VAR 0 2
5590: PUSH
5591: CALL_OW 45
5595: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
5596: LD_ADDR_VAR 0 3
5600: PUSH
5601: LD_VAR 0 3
5605: PPUSH
5606: LD_INT 4
5608: PUSH
5609: LD_VAR 0 3
5613: PUSH
5614: LD_INT 4
5616: ARRAY
5617: PUSH
5618: LD_INT 1
5620: PLUS
5621: PUSH
5622: EMPTY
5623: LIST
5624: LIST
5625: PPUSH
5626: LD_VAR 0 2
5630: PPUSH
5631: CALL 51065 0 3
5635: ST_TO_ADDR
// SetDir ( un , 5 ) ;
5636: LD_VAR 0 2
5640: PPUSH
5641: LD_INT 5
5643: PPUSH
5644: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
5648: LD_VAR 0 2
5652: PPUSH
5653: LD_INT 15
5655: PPUSH
5656: LD_INT 0
5658: PPUSH
5659: CALL_OW 49
// if GetControl ( un ) = control_manual then
5663: LD_VAR 0 2
5667: PPUSH
5668: CALL_OW 263
5672: PUSH
5673: LD_INT 1
5675: EQUAL
5676: IFFALSE 5707
// begin PrepareHuman ( false , 3 , skill ) ;
5678: LD_INT 0
5680: PPUSH
5681: LD_INT 3
5683: PPUSH
5684: LD_VAR 0 4
5688: PPUSH
5689: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5693: CALL_OW 44
5697: PPUSH
5698: LD_VAR 0 2
5702: PPUSH
5703: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
5707: LD_VAR 0 2
5711: PPUSH
5712: LD_INT 179
5714: PPUSH
5715: LD_INT 135
5717: PPUSH
5718: CALL_OW 111
// wait ( 0 0$2 ) ;
5722: LD_INT 70
5724: PPUSH
5725: CALL_OW 67
// end ;
5729: GO 5506
5731: POP
5732: POP
// vc_chassis := 15 ;
5733: LD_ADDR_OWVAR 37
5737: PUSH
5738: LD_INT 15
5740: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
5741: LD_ADDR_VAR 0 3
5745: PUSH
5746: LD_VAR 0 3
5750: PPUSH
5751: LD_INT 4
5753: PUSH
5754: LD_VAR 0 3
5758: PUSH
5759: LD_INT 4
5761: ARRAY
5762: PUSH
5763: LD_INT 1
5765: PLUS
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: PPUSH
5771: CALL_OW 45
5775: PPUSH
5776: CALL 51065 0 3
5780: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
5781: LD_VAR 0 3
5785: PUSH
5786: LD_INT 4
5788: ARRAY
5789: PUSH
5790: LD_VAR 0 3
5794: PUSH
5795: LD_INT 4
5797: ARRAY
5798: ARRAY
5799: PPUSH
5800: LD_INT 15
5802: PPUSH
5803: LD_INT 0
5805: PPUSH
5806: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
5810: LD_INT 0
5812: PPUSH
5813: LD_INT 11
5815: PPUSH
5816: LD_VAR 0 4
5820: PPUSH
5821: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
5825: LD_ADDR_VAR 0 3
5829: PUSH
5830: LD_VAR 0 3
5834: PPUSH
5835: LD_INT 4
5837: PUSH
5838: LD_VAR 0 3
5842: PUSH
5843: LD_INT 4
5845: ARRAY
5846: PUSH
5847: LD_INT 1
5849: PLUS
5850: PUSH
5851: EMPTY
5852: LIST
5853: LIST
5854: PPUSH
5855: CALL_OW 44
5859: PPUSH
5860: CALL 51065 0 3
5864: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
5865: LD_VAR 0 3
5869: PUSH
5870: LD_INT 4
5872: ARRAY
5873: PUSH
5874: LD_VAR 0 3
5878: PUSH
5879: LD_INT 4
5881: ARRAY
5882: ARRAY
5883: PPUSH
5884: LD_VAR 0 3
5888: PUSH
5889: LD_INT 4
5891: ARRAY
5892: PUSH
5893: LD_VAR 0 3
5897: PUSH
5898: LD_INT 4
5900: ARRAY
5901: PUSH
5902: LD_INT 1
5904: MINUS
5905: ARRAY
5906: PPUSH
5907: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
5911: LD_ADDR_VAR 0 5
5915: PUSH
5916: LD_INT 148
5918: PUSH
5919: LD_INT 140
5921: PUSH
5922: EMPTY
5923: LIST
5924: LIST
5925: PUSH
5926: EMPTY
5927: LIST
5928: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
5929: LD_INT 1
5931: PPUSH
5932: LD_VAR 0 3
5936: PUSH
5937: LD_INT 4
5939: ARRAY
5940: PPUSH
5941: LD_VAR 0 5
5945: PPUSH
5946: LD_VAR 0 6
5950: PPUSH
5951: CALL 38829 0 4
// if gensher_active then
5955: LD_EXP 18
5959: IFFALSE 6344
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
5961: LD_EXP 45
5965: PPUSH
5966: LD_STRING D10-Diet-1
5968: PPUSH
5969: CALL_OW 94
// for i = 1 to 2 do
5973: LD_ADDR_VAR 0 1
5977: PUSH
5978: DOUBLE
5979: LD_INT 1
5981: DEC
5982: ST_TO_ADDR
5983: LD_INT 2
5985: PUSH
5986: FOR_TO
5987: IFFALSE 6125
// begin uc_side := 2 ;
5989: LD_ADDR_OWVAR 20
5993: PUSH
5994: LD_INT 2
5996: ST_TO_ADDR
// uc_nation := 2 ;
5997: LD_ADDR_OWVAR 21
6001: PUSH
6002: LD_INT 2
6004: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6005: LD_INT 13
6007: PPUSH
6008: LD_INT 3
6010: PPUSH
6011: LD_INT 5
6013: PPUSH
6014: LD_INT 29
6016: PPUSH
6017: LD_INT 100
6019: PPUSH
6020: CALL 50943 0 5
// un := CreateVehicle ;
6024: LD_ADDR_VAR 0 2
6028: PUSH
6029: CALL_OW 45
6033: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6034: LD_ADDR_VAR 0 3
6038: PUSH
6039: LD_VAR 0 3
6043: PPUSH
6044: LD_INT 5
6046: PUSH
6047: LD_VAR 0 3
6051: PUSH
6052: LD_INT 5
6054: ARRAY
6055: PUSH
6056: LD_INT 1
6058: PLUS
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: PPUSH
6064: LD_VAR 0 2
6068: PPUSH
6069: CALL 51065 0 3
6073: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6074: LD_VAR 0 2
6078: PPUSH
6079: LD_INT 0
6081: PPUSH
6082: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6086: LD_VAR 0 2
6090: PPUSH
6091: LD_INT 23
6093: PPUSH
6094: LD_INT 0
6096: PPUSH
6097: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6101: LD_VAR 0 2
6105: PPUSH
6106: LD_INT 85
6108: PPUSH
6109: LD_INT 152
6111: PPUSH
6112: CALL_OW 111
// wait ( 0 0$2 ) ;
6116: LD_INT 70
6118: PPUSH
6119: CALL_OW 67
// end ;
6123: GO 5986
6125: POP
6126: POP
// for i = 1 to 3 do
6127: LD_ADDR_VAR 0 1
6131: PUSH
6132: DOUBLE
6133: LD_INT 1
6135: DEC
6136: ST_TO_ADDR
6137: LD_INT 3
6139: PUSH
6140: FOR_TO
6141: IFFALSE 6298
// begin uc_side := 2 ;
6143: LD_ADDR_OWVAR 20
6147: PUSH
6148: LD_INT 2
6150: ST_TO_ADDR
// uc_nation := 2 ;
6151: LD_ADDR_OWVAR 21
6155: PUSH
6156: LD_INT 2
6158: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6159: LD_INT 14
6161: PPUSH
6162: LD_INT 3
6164: PPUSH
6165: LD_INT 5
6167: PPUSH
6168: LD_INT 27
6170: PUSH
6171: LD_INT 28
6173: PUSH
6174: EMPTY
6175: LIST
6176: LIST
6177: PUSH
6178: LD_INT 1
6180: PPUSH
6181: LD_INT 2
6183: PPUSH
6184: CALL_OW 12
6188: ARRAY
6189: PPUSH
6190: LD_INT 100
6192: PPUSH
6193: CALL 50943 0 5
// un := CreateVehicle ;
6197: LD_ADDR_VAR 0 2
6201: PUSH
6202: CALL_OW 45
6206: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6207: LD_ADDR_VAR 0 3
6211: PUSH
6212: LD_VAR 0 3
6216: PPUSH
6217: LD_INT 5
6219: PUSH
6220: LD_VAR 0 3
6224: PUSH
6225: LD_INT 5
6227: ARRAY
6228: PUSH
6229: LD_INT 1
6231: PLUS
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: PPUSH
6237: LD_VAR 0 2
6241: PPUSH
6242: CALL 51065 0 3
6246: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6247: LD_VAR 0 2
6251: PPUSH
6252: LD_INT 0
6254: PPUSH
6255: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6259: LD_VAR 0 2
6263: PPUSH
6264: LD_INT 23
6266: PPUSH
6267: LD_INT 0
6269: PPUSH
6270: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6274: LD_VAR 0 2
6278: PPUSH
6279: LD_INT 85
6281: PPUSH
6282: LD_INT 152
6284: PPUSH
6285: CALL_OW 111
// wait ( 0 0$2 ) ;
6289: LD_INT 70
6291: PPUSH
6292: CALL_OW 67
// end ;
6296: GO 6140
6298: POP
6299: POP
// coords := [ [ 97 , 143 ] ] ;
6300: LD_ADDR_VAR 0 5
6304: PUSH
6305: LD_INT 97
6307: PUSH
6308: LD_INT 143
6310: PUSH
6311: EMPTY
6312: LIST
6313: LIST
6314: PUSH
6315: EMPTY
6316: LIST
6317: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6318: LD_INT 1
6320: PPUSH
6321: LD_VAR 0 3
6325: PUSH
6326: LD_INT 5
6328: ARRAY
6329: PPUSH
6330: LD_VAR 0 5
6334: PPUSH
6335: LD_VAR 0 6
6339: PPUSH
6340: CALL 38829 0 4
// end ; Wait ( 13 13$00 ) ;
6344: LD_INT 27300
6346: PPUSH
6347: CALL_OW 67
// tmp := [ ] ;
6351: LD_ADDR_VAR 0 3
6355: PUSH
6356: EMPTY
6357: ST_TO_ADDR
// w := 1 ;
6358: LD_ADDR_VAR 0 7
6362: PUSH
6363: LD_INT 1
6365: ST_TO_ADDR
// repeat tmp := [ ] ;
6366: LD_ADDR_VAR 0 3
6370: PUSH
6371: EMPTY
6372: ST_TO_ADDR
// if w mod 4 = 0 then
6373: LD_VAR 0 7
6377: PUSH
6378: LD_INT 4
6380: MOD
6381: PUSH
6382: LD_INT 0
6384: EQUAL
6385: IFFALSE 6472
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6387: LD_ADDR_VAR 0 8
6391: PUSH
6392: LD_INT 11
6394: PUSH
6395: LD_INT 1
6397: PUSH
6398: LD_INT 2
6400: PUSH
6401: LD_INT 24
6403: PUSH
6404: EMPTY
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: PUSH
6410: LD_INT 11
6412: PUSH
6413: LD_INT 1
6415: PUSH
6416: LD_INT 2
6418: PUSH
6419: LD_INT 24
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: PUSH
6428: LD_INT 11
6430: PUSH
6431: LD_INT 1
6433: PUSH
6434: LD_INT 2
6436: PUSH
6437: LD_INT 24
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 11
6448: PUSH
6449: LD_INT 1
6451: PUSH
6452: LD_INT 2
6454: PUSH
6455: LD_INT 24
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: LIST
6462: LIST
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: LIST
6468: LIST
6469: ST_TO_ADDR
6470: GO 6574
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
6472: LD_ADDR_VAR 0 8
6476: PUSH
6477: LD_INT 14
6479: PUSH
6480: LD_INT 1
6482: PUSH
6483: LD_INT 2
6485: PUSH
6486: LD_INT 28
6488: PUSH
6489: EMPTY
6490: LIST
6491: LIST
6492: LIST
6493: LIST
6494: PUSH
6495: LD_INT 14
6497: PUSH
6498: LD_INT 1
6500: PUSH
6501: LD_INT 2
6503: PUSH
6504: LD_INT 25
6506: PUSH
6507: EMPTY
6508: LIST
6509: LIST
6510: LIST
6511: LIST
6512: PUSH
6513: LD_INT 14
6515: PUSH
6516: LD_INT 1
6518: PUSH
6519: LD_INT 2
6521: PUSH
6522: LD_INT 28
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: LIST
6529: LIST
6530: PUSH
6531: LD_INT 14
6533: PUSH
6534: LD_INT 1
6536: PUSH
6537: LD_INT 2
6539: PUSH
6540: LD_INT 29
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: LIST
6547: LIST
6548: PUSH
6549: LD_INT 11
6551: PUSH
6552: LD_INT 1
6554: PUSH
6555: LD_INT 2
6557: PUSH
6558: LD_INT 24
6560: PUSH
6561: EMPTY
6562: LIST
6563: LIST
6564: LIST
6565: LIST
6566: PUSH
6567: EMPTY
6568: LIST
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: ST_TO_ADDR
// if w mod 3 = 0 then
6574: LD_VAR 0 7
6578: PUSH
6579: LD_INT 3
6581: MOD
6582: PUSH
6583: LD_INT 0
6585: EQUAL
6586: IFFALSE 6662
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
6588: LD_ADDR_VAR 0 8
6592: PUSH
6593: LD_VAR 0 8
6597: PPUSH
6598: LD_INT 1
6600: PUSH
6601: LD_VAR 0 8
6605: PUSH
6606: LD_VAR 0 1
6610: ARRAY
6611: PUSH
6612: LD_INT 1
6614: PLUS
6615: PUSH
6616: EMPTY
6617: LIST
6618: LIST
6619: PPUSH
6620: LD_INT 14
6622: PUSH
6623: LD_INT 1
6625: PUSH
6626: LD_INT 2
6628: PUSH
6629: LD_INT 25
6631: PUSH
6632: LD_INT 28
6634: PUSH
6635: EMPTY
6636: LIST
6637: LIST
6638: PUSH
6639: LD_INT 1
6641: PPUSH
6642: LD_INT 2
6644: PPUSH
6645: CALL_OW 12
6649: ARRAY
6650: PUSH
6651: EMPTY
6652: LIST
6653: LIST
6654: LIST
6655: LIST
6656: PPUSH
6657: CALL 51065 0 3
6661: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
6662: LD_INT 1
6664: PPUSH
6665: LD_VAR 0 8
6669: PPUSH
6670: CALL 38538 0 2
// if GetSide ( ar_dep_w ) = 2 then
6674: LD_INT 45
6676: PPUSH
6677: CALL_OW 255
6681: PUSH
6682: LD_INT 2
6684: EQUAL
6685: IFFALSE 6770
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
6687: LD_ADDR_VAR 0 8
6691: PUSH
6692: LD_INT 14
6694: PUSH
6695: LD_INT 1
6697: PUSH
6698: LD_INT 2
6700: PUSH
6701: LD_INT 28
6703: PUSH
6704: EMPTY
6705: LIST
6706: LIST
6707: LIST
6708: LIST
6709: PUSH
6710: LD_INT 14
6712: PUSH
6713: LD_INT 1
6715: PUSH
6716: LD_INT 2
6718: PUSH
6719: LD_INT 27
6721: PUSH
6722: EMPTY
6723: LIST
6724: LIST
6725: LIST
6726: LIST
6727: PUSH
6728: LD_INT 14
6730: PUSH
6731: LD_INT 1
6733: PUSH
6734: LD_INT 2
6736: PUSH
6737: LD_INT 27
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: LIST
6744: LIST
6745: PUSH
6746: EMPTY
6747: LIST
6748: LIST
6749: LIST
6750: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
6751: LD_INT 2
6753: PPUSH
6754: LD_VAR 0 8
6758: PPUSH
6759: CALL 38538 0 2
// wait ( 0 0$50 ) ;
6763: LD_INT 1750
6765: PPUSH
6766: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
6770: LD_INT 35
6772: PPUSH
6773: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) >= 4 ;
6777: LD_EXP 69
6781: PUSH
6782: LD_INT 1
6784: ARRAY
6785: PPUSH
6786: LD_INT 3
6788: PUSH
6789: LD_INT 34
6791: PUSH
6792: LD_INT 32
6794: PUSH
6795: EMPTY
6796: LIST
6797: LIST
6798: PUSH
6799: EMPTY
6800: LIST
6801: LIST
6802: PPUSH
6803: CALL_OW 72
6807: PUSH
6808: LD_INT 4
6810: GREATEREQUAL
6811: IFFALSE 6770
// wait ( 0 0$10 ) ;
6813: LD_INT 350
6815: PPUSH
6816: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) ;
6820: LD_ADDR_VAR 0 3
6824: PUSH
6825: LD_EXP 69
6829: PUSH
6830: LD_INT 1
6832: ARRAY
6833: PPUSH
6834: LD_INT 3
6836: PUSH
6837: LD_INT 34
6839: PUSH
6840: LD_INT 32
6842: PUSH
6843: EMPTY
6844: LIST
6845: LIST
6846: PUSH
6847: EMPTY
6848: LIST
6849: LIST
6850: PPUSH
6851: CALL_OW 72
6855: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
6856: LD_INT 100
6858: PPUSH
6859: CALL_OW 13
6863: PUSH
6864: LD_INT 50
6866: LESS
6867: IFFALSE 6900
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
6869: LD_ADDR_VAR 0 5
6873: PUSH
6874: LD_INT 55
6876: PUSH
6877: LD_INT 7
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: PUSH
6884: LD_INT 75
6886: PUSH
6887: LD_INT 90
6889: PUSH
6890: EMPTY
6891: LIST
6892: LIST
6893: PUSH
6894: EMPTY
6895: LIST
6896: LIST
6897: ST_TO_ADDR
6898: GO 6929
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
6900: LD_ADDR_VAR 0 5
6904: PUSH
6905: LD_INT 128
6907: PUSH
6908: LD_INT 94
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: PUSH
6915: LD_INT 180
6917: PUSH
6918: LD_INT 135
6920: PUSH
6921: EMPTY
6922: LIST
6923: LIST
6924: PUSH
6925: EMPTY
6926: LIST
6927: LIST
6928: ST_TO_ADDR
// if w mod 4 = 0 then
6929: LD_VAR 0 7
6933: PUSH
6934: LD_INT 4
6936: MOD
6937: PUSH
6938: LD_INT 0
6940: EQUAL
6941: IFFALSE 6972
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
6943: LD_ADDR_VAR 0 5
6947: PUSH
6948: LD_INT 91
6950: PUSH
6951: LD_INT 58
6953: PUSH
6954: EMPTY
6955: LIST
6956: LIST
6957: PUSH
6958: LD_INT 117
6960: PUSH
6961: LD_INT 107
6963: PUSH
6964: EMPTY
6965: LIST
6966: LIST
6967: PUSH
6968: EMPTY
6969: LIST
6970: LIST
6971: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp , coords , flags ) ;
6972: LD_INT 1
6974: PPUSH
6975: LD_VAR 0 3
6979: PPUSH
6980: LD_VAR 0 5
6984: PPUSH
6985: LD_VAR 0 6
6989: PPUSH
6990: CALL 38829 0 4
// if mc_vehicles [ 2 ] then
6994: LD_EXP 69
6998: PUSH
6999: LD_INT 2
7001: ARRAY
7002: IFFALSE 7038
// MC_PrepareAttack ( 2 , mc_vehicles [ 2 ] , [ [ 73 , 115 ] ] , flags ) ;
7004: LD_INT 2
7006: PPUSH
7007: LD_EXP 69
7011: PUSH
7012: LD_INT 2
7014: ARRAY
7015: PPUSH
7016: LD_INT 73
7018: PUSH
7019: LD_INT 115
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: PUSH
7026: EMPTY
7027: LIST
7028: PPUSH
7029: LD_VAR 0 6
7033: PPUSH
7034: CALL 38829 0 4
// wait ( rand ( 9 9$30 , 12 12$30 ) ) ;
7038: LD_INT 19950
7040: PPUSH
7041: LD_INT 26250
7043: PPUSH
7044: CALL_OW 12
7048: PPUSH
7049: CALL_OW 67
// w := w + 1 ;
7053: LD_ADDR_VAR 0 7
7057: PUSH
7058: LD_VAR 0 7
7062: PUSH
7063: LD_INT 1
7065: PLUS
7066: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7067: LD_INT 94
7069: PPUSH
7070: CALL_OW 301
7074: PUSH
7075: LD_EXP 50
7079: PUSH
7080: LD_INT 1
7082: ARRAY
7083: PPUSH
7084: LD_INT 30
7086: PUSH
7087: LD_INT 3
7089: PUSH
7090: EMPTY
7091: LIST
7092: LIST
7093: PPUSH
7094: CALL_OW 72
7098: NOT
7099: OR
7100: IFFALSE 6366
// end ;
7102: PPOPN 8
7104: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7105: LD_INT 204
7107: IFFALSE 7482
7109: GO 7111
7111: DISABLE
7112: LD_INT 0
7114: PPUSH
7115: PPUSH
7116: PPUSH
7117: PPUSH
// begin enable ;
7118: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7119: LD_INT 35
7121: PPUSH
7122: LD_INT 1190
7124: PPUSH
7125: CALL_OW 12
7129: PPUSH
7130: CALL_OW 67
// tmp := [ ] ;
7134: LD_ADDR_VAR 0 2
7138: PUSH
7139: EMPTY
7140: ST_TO_ADDR
// uc_side := 8 ;
7141: LD_ADDR_OWVAR 20
7145: PUSH
7146: LD_INT 8
7148: ST_TO_ADDR
// uc_nation := 2 ;
7149: LD_ADDR_OWVAR 21
7153: PUSH
7154: LD_INT 2
7156: ST_TO_ADDR
// InitHc ;
7157: CALL_OW 19
// for i = 1 to 3 do
7161: LD_ADDR_VAR 0 1
7165: PUSH
7166: DOUBLE
7167: LD_INT 1
7169: DEC
7170: ST_TO_ADDR
7171: LD_INT 3
7173: PUSH
7174: FOR_TO
7175: IFFALSE 7302
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7177: LD_INT 13
7179: PUSH
7180: LD_INT 14
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: PUSH
7187: LD_INT 1
7189: PPUSH
7190: LD_INT 2
7192: PPUSH
7193: CALL_OW 12
7197: ARRAY
7198: PPUSH
7199: LD_INT 3
7201: PPUSH
7202: LD_INT 5
7204: PPUSH
7205: LD_INT 27
7207: PUSH
7208: LD_INT 28
7210: PUSH
7211: EMPTY
7212: LIST
7213: LIST
7214: PUSH
7215: LD_INT 1
7217: PPUSH
7218: LD_INT 2
7220: PPUSH
7221: CALL_OW 12
7225: ARRAY
7226: PPUSH
7227: LD_INT 100
7229: PPUSH
7230: CALL 50943 0 5
// un := CreateVehicle ;
7234: LD_ADDR_VAR 0 3
7238: PUSH
7239: CALL_OW 45
7243: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7244: LD_VAR 0 3
7248: PPUSH
7249: LD_INT 4
7251: PPUSH
7252: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7256: LD_VAR 0 3
7260: PPUSH
7261: LD_INT 15
7263: PPUSH
7264: LD_INT 0
7266: PPUSH
7267: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7271: LD_ADDR_VAR 0 2
7275: PUSH
7276: LD_VAR 0 2
7280: PPUSH
7281: LD_VAR 0 2
7285: PUSH
7286: LD_INT 1
7288: PLUS
7289: PPUSH
7290: LD_VAR 0 3
7294: PPUSH
7295: CALL_OW 1
7299: ST_TO_ADDR
// end ;
7300: GO 7174
7302: POP
7303: POP
// for i = 1 to 4 do
7304: LD_ADDR_VAR 0 1
7308: PUSH
7309: DOUBLE
7310: LD_INT 1
7312: DEC
7313: ST_TO_ADDR
7314: LD_INT 4
7316: PUSH
7317: FOR_TO
7318: IFFALSE 7397
// begin PrepareHuman ( false , rand ( 1 , 4 ) , 6 ) ;
7320: LD_INT 0
7322: PPUSH
7323: LD_INT 1
7325: PPUSH
7326: LD_INT 4
7328: PPUSH
7329: CALL_OW 12
7333: PPUSH
7334: LD_INT 6
7336: PPUSH
7337: CALL_OW 380
// un := CreateHuman ;
7341: LD_ADDR_VAR 0 3
7345: PUSH
7346: CALL_OW 44
7350: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7351: LD_VAR 0 3
7355: PPUSH
7356: LD_INT 15
7358: PPUSH
7359: LD_INT 0
7361: PPUSH
7362: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7366: LD_ADDR_VAR 0 2
7370: PUSH
7371: LD_VAR 0 2
7375: PPUSH
7376: LD_VAR 0 2
7380: PUSH
7381: LD_INT 1
7383: PLUS
7384: PPUSH
7385: LD_VAR 0 3
7389: PPUSH
7390: CALL_OW 1
7394: ST_TO_ADDR
// end ;
7395: GO 7317
7397: POP
7398: POP
// repeat ComAgressiveMove ( tmp , 210 , 177 ) ;
7399: LD_VAR 0 2
7403: PPUSH
7404: LD_INT 210
7406: PPUSH
7407: LD_INT 177
7409: PPUSH
7410: CALL_OW 114
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
7414: LD_ADDR_VAR 0 4
7418: PUSH
7419: LD_INT 10
7421: PPUSH
7422: LD_INT 22
7424: PUSH
7425: LD_INT 8
7427: PUSH
7428: EMPTY
7429: LIST
7430: LIST
7431: PPUSH
7432: CALL_OW 70
7436: ST_TO_ADDR
// if x then
7437: LD_VAR 0 4
7441: IFFALSE 7469
// for i in x do
7443: LD_ADDR_VAR 0 1
7447: PUSH
7448: LD_VAR 0 4
7452: PUSH
7453: FOR_IN
7454: IFFALSE 7467
// RemoveUnit ( i ) ;
7456: LD_VAR 0 1
7460: PPUSH
7461: CALL_OW 64
7465: GO 7453
7467: POP
7468: POP
// wait ( 0 0$3 ) ;
7469: LD_INT 105
7471: PPUSH
7472: CALL_OW 67
// until tmp ;
7476: LD_VAR 0 2
7480: IFFALSE 7399
// end ;
7482: PPOPN 4
7484: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
7485: LD_INT 22
7487: PUSH
7488: LD_INT 2
7490: PUSH
7491: EMPTY
7492: LIST
7493: LIST
7494: PUSH
7495: LD_INT 34
7497: PUSH
7498: LD_INT 31
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: PUSH
7505: LD_INT 3
7507: PUSH
7508: LD_INT 24
7510: PUSH
7511: LD_INT 1000
7513: PUSH
7514: EMPTY
7515: LIST
7516: LIST
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: LIST
7526: PPUSH
7527: CALL_OW 69
7531: IFFALSE 7575
7533: GO 7535
7535: DISABLE
// begin ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
7536: LD_INT 22
7538: PUSH
7539: LD_INT 2
7541: PUSH
7542: EMPTY
7543: LIST
7544: LIST
7545: PUSH
7546: LD_INT 34
7548: PUSH
7549: LD_INT 31
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: PUSH
7556: EMPTY
7557: LIST
7558: LIST
7559: PPUSH
7560: CALL_OW 69
7564: PPUSH
7565: LD_INT 106
7567: PPUSH
7568: LD_INT 14
7570: PPUSH
7571: CALL_OW 111
// end ; end_of_file
7575: END
// export function Action ; var tmp , p , radar , sols , i ; begin
7576: LD_INT 0
7578: PPUSH
7579: PPUSH
7580: PPUSH
7581: PPUSH
7582: PPUSH
7583: PPUSH
// InGameOn ;
7584: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
7588: LD_EXP 21
7592: PPUSH
7593: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
7597: LD_INT 2
7599: PPUSH
7600: LD_INT 1
7602: PPUSH
7603: LD_INT 1
7605: PPUSH
7606: LD_INT 1
7608: PPUSH
7609: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
7613: LD_ADDR_VAR 0 2
7617: PUSH
7618: LD_INT 22
7620: PUSH
7621: LD_INT 1
7623: PUSH
7624: EMPTY
7625: LIST
7626: LIST
7627: PUSH
7628: LD_INT 25
7630: PUSH
7631: LD_INT 1
7633: PUSH
7634: EMPTY
7635: LIST
7636: LIST
7637: PUSH
7638: EMPTY
7639: LIST
7640: LIST
7641: PPUSH
7642: CALL_OW 69
7646: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
7647: LD_ADDR_VAR 0 4
7651: PUSH
7652: LD_INT 22
7654: PUSH
7655: LD_INT 1
7657: PUSH
7658: EMPTY
7659: LIST
7660: LIST
7661: PUSH
7662: LD_INT 34
7664: PUSH
7665: LD_INT 11
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PUSH
7672: EMPTY
7673: LIST
7674: LIST
7675: PPUSH
7676: CALL_OW 69
7680: PUSH
7681: LD_INT 1
7683: ARRAY
7684: ST_TO_ADDR
// for i = 1 to tmp do
7685: LD_ADDR_VAR 0 6
7689: PUSH
7690: DOUBLE
7691: LD_INT 1
7693: DEC
7694: ST_TO_ADDR
7695: LD_VAR 0 2
7699: PUSH
7700: FOR_TO
7701: IFFALSE 7748
// begin if i = 5 then
7703: LD_VAR 0 6
7707: PUSH
7708: LD_INT 5
7710: EQUAL
7711: IFFALSE 7715
// break ;
7713: GO 7748
// sols := Replace ( sols , i , tmp [ i ] ) ;
7715: LD_ADDR_VAR 0 5
7719: PUSH
7720: LD_VAR 0 5
7724: PPUSH
7725: LD_VAR 0 6
7729: PPUSH
7730: LD_VAR 0 2
7734: PUSH
7735: LD_VAR 0 6
7739: ARRAY
7740: PPUSH
7741: CALL_OW 1
7745: ST_TO_ADDR
// end ;
7746: GO 7700
7748: POP
7749: POP
// tmp := ar_force_tmp ;
7750: LD_ADDR_VAR 0 2
7754: PUSH
7755: LD_EXP 40
7759: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
7760: LD_VAR 0 2
7764: PUSH
7765: LD_INT 1
7767: ARRAY
7768: PPUSH
7769: LD_INT 108
7771: PPUSH
7772: LD_INT 139
7774: PPUSH
7775: LD_INT 0
7777: PPUSH
7778: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
7782: LD_VAR 0 2
7786: PUSH
7787: LD_INT 1
7789: ARRAY
7790: PPUSH
7791: LD_EXP 21
7795: PPUSH
7796: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
7800: LD_VAR 0 2
7804: PUSH
7805: LD_INT 2
7807: ARRAY
7808: PPUSH
7809: LD_INT 114
7811: PPUSH
7812: LD_INT 132
7814: PPUSH
7815: LD_INT 0
7817: PPUSH
7818: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
7822: LD_VAR 0 2
7826: PUSH
7827: LD_INT 3
7829: ARRAY
7830: PPUSH
7831: LD_INT 115
7833: PPUSH
7834: LD_INT 132
7836: PPUSH
7837: LD_INT 0
7839: PPUSH
7840: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
7844: LD_VAR 0 2
7848: PUSH
7849: LD_INT 2
7851: ARRAY
7852: PUSH
7853: LD_VAR 0 2
7857: PUSH
7858: LD_INT 3
7860: ARRAY
7861: PUSH
7862: EMPTY
7863: LIST
7864: LIST
7865: PPUSH
7866: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
7870: LD_VAR 0 4
7874: PPUSH
7875: LD_INT 83
7877: PPUSH
7878: LD_INT 123
7880: PPUSH
7881: CALL_OW 111
// Wait ( 0 0$01 ) ;
7885: LD_INT 35
7887: PPUSH
7888: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
7892: LD_INT 90
7894: PPUSH
7895: LD_INT 144
7897: PPUSH
7898: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
7902: LD_VAR 0 5
7906: PPUSH
7907: LD_INT 88
7909: PPUSH
7910: LD_INT 129
7912: PPUSH
7913: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
7917: LD_ADDR_VAR 0 3
7921: PUSH
7922: LD_INT 92
7924: PUSH
7925: LD_INT 131
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PUSH
7932: LD_INT 88
7934: PUSH
7935: LD_INT 127
7937: PUSH
7938: EMPTY
7939: LIST
7940: LIST
7941: PUSH
7942: LD_INT 91
7944: PUSH
7945: LD_INT 132
7947: PUSH
7948: EMPTY
7949: LIST
7950: LIST
7951: PUSH
7952: LD_INT 92
7954: PUSH
7955: LD_INT 134
7957: PUSH
7958: EMPTY
7959: LIST
7960: LIST
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: LIST
7966: LIST
7967: ST_TO_ADDR
// for i = 1 to sols do
7968: LD_ADDR_VAR 0 6
7972: PUSH
7973: DOUBLE
7974: LD_INT 1
7976: DEC
7977: ST_TO_ADDR
7978: LD_VAR 0 5
7982: PUSH
7983: FOR_TO
7984: IFFALSE 8057
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
7986: LD_VAR 0 5
7990: PUSH
7991: LD_VAR 0 6
7995: ARRAY
7996: PPUSH
7997: LD_VAR 0 3
8001: PUSH
8002: LD_VAR 0 6
8006: ARRAY
8007: PUSH
8008: LD_INT 1
8010: ARRAY
8011: PPUSH
8012: LD_VAR 0 3
8016: PUSH
8017: LD_VAR 0 6
8021: ARRAY
8022: PUSH
8023: LD_INT 2
8025: ARRAY
8026: PPUSH
8027: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8031: LD_VAR 0 5
8035: PUSH
8036: LD_VAR 0 6
8040: ARRAY
8041: PPUSH
8042: CALL_OW 197
// AddComHold ( sols ) ;
8046: LD_VAR 0 5
8050: PPUSH
8051: CALL_OW 200
// end ;
8055: GO 7983
8057: POP
8058: POP
// repeat wait ( 0 0$1 ) ;
8059: LD_INT 35
8061: PPUSH
8062: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8066: LD_VAR 0 5
8070: PUSH
8071: LD_INT 1
8073: ARRAY
8074: PPUSH
8075: LD_INT 92
8077: PPUSH
8078: LD_INT 131
8080: PPUSH
8081: CALL_OW 297
8085: PUSH
8086: LD_INT 4
8088: LESS
8089: IFFALSE 8059
// CenterOnXY ( 96 , 139 ) ;
8091: LD_INT 96
8093: PPUSH
8094: LD_INT 139
8096: PPUSH
8097: CALL_OW 84
// wait ( 0 0$3 ) ;
8101: LD_INT 105
8103: PPUSH
8104: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
8108: LD_INT 111
8110: PPUSH
8111: LD_INT 135
8113: PPUSH
8114: LD_INT 1
8116: PPUSH
8117: LD_INT 25
8119: NEG
8120: PPUSH
8121: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
8125: LD_VAR 0 2
8129: PUSH
8130: LD_INT 2
8132: ARRAY
8133: PPUSH
8134: LD_VAR 0 2
8138: PUSH
8139: LD_INT 1
8141: ARRAY
8142: PPUSH
8143: CALL_OW 250
8147: PUSH
8148: LD_INT 3
8150: PLUS
8151: PPUSH
8152: LD_VAR 0 2
8156: PUSH
8157: LD_INT 1
8159: ARRAY
8160: PPUSH
8161: CALL_OW 251
8165: PPUSH
8166: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
8170: LD_VAR 0 2
8174: PUSH
8175: LD_INT 3
8177: ARRAY
8178: PPUSH
8179: LD_INT 7
8181: PPUSH
8182: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
8186: LD_VAR 0 2
8190: PUSH
8191: LD_INT 2
8193: ARRAY
8194: PPUSH
8195: LD_VAR 0 2
8199: PUSH
8200: LD_INT 1
8202: ARRAY
8203: PPUSH
8204: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
8208: LD_INT 35
8210: PPUSH
8211: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
8215: LD_VAR 0 2
8219: PUSH
8220: LD_INT 1
8222: ARRAY
8223: PPUSH
8224: LD_VAR 0 2
8228: PUSH
8229: LD_INT 2
8231: ARRAY
8232: PPUSH
8233: CALL_OW 296
8237: PUSH
8238: LD_INT 5
8240: LESS
8241: IFFALSE 8208
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
8243: LD_VAR 0 2
8247: PUSH
8248: LD_INT 1
8250: ARRAY
8251: PPUSH
8252: LD_VAR 0 2
8256: PUSH
8257: LD_INT 2
8259: ARRAY
8260: PPUSH
8261: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
8265: LD_VAR 0 2
8269: PUSH
8270: LD_INT 1
8272: ARRAY
8273: PPUSH
8274: LD_STRING D1a-Merc1-1
8276: PPUSH
8277: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
8281: LD_VAR 0 2
8285: PUSH
8286: LD_INT 2
8288: ARRAY
8289: PPUSH
8290: LD_STRING D1a-FMerc2-1
8292: PPUSH
8293: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
8297: LD_VAR 0 2
8301: PUSH
8302: LD_INT 2
8304: ARRAY
8305: PPUSH
8306: LD_VAR 0 2
8310: PUSH
8311: LD_INT 1
8313: ARRAY
8314: PPUSH
8315: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
8319: LD_VAR 0 2
8323: PUSH
8324: LD_INT 1
8326: ARRAY
8327: PPUSH
8328: LD_INT 500
8330: PPUSH
8331: CALL_OW 234
// wait ( 0 0$2 ) ;
8335: LD_INT 70
8337: PPUSH
8338: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
8342: LD_VAR 0 2
8346: PUSH
8347: LD_INT 1
8349: ARRAY
8350: PPUSH
8351: LD_INT 2
8353: PPUSH
8354: CALL_OW 234
// wait ( 0 0$0.3 ) ;
8358: LD_INT 10
8360: PPUSH
8361: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
8365: LD_VAR 0 2
8369: PUSH
8370: LD_INT 1
8372: ARRAY
8373: PPUSH
8374: LD_STRING D1a-Merc1-2
8376: PPUSH
8377: CALL_OW 91
// wait ( 0 0$0.2 ) ;
8381: LD_INT 7
8383: PPUSH
8384: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
8388: LD_VAR 0 2
8392: PUSH
8393: LD_INT 1
8395: ARRAY
8396: PPUSH
8397: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
8401: LD_VAR 0 2
8405: PUSH
8406: LD_INT 2
8408: ARRAY
8409: PPUSH
8410: LD_INT 10
8412: PPUSH
8413: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
8417: LD_VAR 0 2
8421: PUSH
8422: LD_INT 2
8424: ARRAY
8425: PPUSH
8426: LD_STRING D1a-FMerc2-2
8428: PPUSH
8429: CALL_OW 88
// wait ( 0 0$1 ) ;
8433: LD_INT 35
8435: PPUSH
8436: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
8440: LD_INT 7
8442: PPUSH
8443: CALL_OW 85
// wait ( 0 0$2 ) ;
8447: LD_INT 70
8449: PPUSH
8450: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
8454: LD_EXP 44
8458: PPUSH
8459: LD_STRING D1a-Saliba-1
8461: PPUSH
8462: CALL_OW 91
// KillUnit ( Saliba ) ;
8466: LD_EXP 44
8470: PPUSH
8471: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
8475: LD_VAR 0 2
8479: PUSH
8480: LD_INT 3
8482: ARRAY
8483: PPUSH
8484: CALL_OW 122
// CenterOnUnits ( JMM ) ;
8488: LD_EXP 21
8492: PPUSH
8493: CALL_OW 85
// wait ( 0 0$1 ) ;
8497: LD_INT 35
8499: PPUSH
8500: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
8504: LD_VAR 0 5
8508: PPUSH
8509: LD_INT 88
8511: PPUSH
8512: LD_INT 141
8514: PPUSH
8515: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
8519: LD_VAR 0 5
8523: PPUSH
8524: LD_INT 70
8526: PPUSH
8527: CALL_OW 202
// wait ( 0 0$2 ) ;
8531: LD_INT 70
8533: PPUSH
8534: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
8538: LD_INT 2
8540: PPUSH
8541: LD_INT 1
8543: PPUSH
8544: LD_INT 2
8546: PPUSH
8547: LD_INT 1
8549: PPUSH
8550: CALL_OW 80
// InGameOff ;
8554: CALL_OW 9
// ComWalk ( sols ) ;
8558: LD_VAR 0 5
8562: PPUSH
8563: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
8567: LD_STRING M1
8569: PPUSH
8570: CALL_OW 337
// game_speed := 4 ;
8574: LD_ADDR_OWVAR 65
8578: PUSH
8579: LD_INT 4
8581: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
8582: LD_INT 111
8584: PPUSH
8585: LD_INT 135
8587: PPUSH
8588: LD_INT 1
8590: PPUSH
8591: CALL_OW 331
// SaveForQuickRestart ;
8595: CALL_OW 22
// ar_run := true ;
8599: LD_ADDR_EXP 5
8603: PUSH
8604: LD_INT 1
8606: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8607: LD_INT 35
8609: PPUSH
8610: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
8614: LD_INT 22
8616: PUSH
8617: LD_INT 1
8619: PUSH
8620: EMPTY
8621: LIST
8622: LIST
8623: PUSH
8624: LD_INT 91
8626: PUSH
8627: LD_INT 7
8629: PUSH
8630: LD_INT 10
8632: PUSH
8633: EMPTY
8634: LIST
8635: LIST
8636: LIST
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: PPUSH
8642: CALL_OW 69
8646: PUSH
8647: LD_INT 7
8649: PPUSH
8650: CALL_OW 256
8654: PUSH
8655: LD_INT 999
8657: LESS
8658: OR
8659: IFFALSE 8607
// if GetSide ( ar_dep_s ) = 2 then
8661: LD_INT 7
8663: PPUSH
8664: CALL_OW 255
8668: PUSH
8669: LD_INT 2
8671: EQUAL
8672: IFFALSE 8684
// SetSide ( ar_dep_s , 1 ) ;
8674: LD_INT 7
8676: PPUSH
8677: LD_INT 1
8679: PPUSH
8680: CALL_OW 235
// end ;
8684: LD_VAR 0 1
8688: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
8689: LD_EXP 5
8693: IFFALSE 9053
8695: GO 8697
8697: DISABLE
8698: LD_INT 0
8700: PPUSH
8701: PPUSH
8702: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
8703: LD_ADDR_VAR 0 2
8707: PUSH
8708: LD_EXP 40
8712: PUSH
8713: LD_EXP 36
8717: PPUSH
8718: LD_INT 2
8720: PUSH
8721: LD_INT 21
8723: PUSH
8724: LD_INT 2
8726: PUSH
8727: EMPTY
8728: LIST
8729: LIST
8730: PUSH
8731: LD_INT 21
8733: PUSH
8734: LD_INT 1
8736: PUSH
8737: EMPTY
8738: LIST
8739: LIST
8740: PUSH
8741: EMPTY
8742: LIST
8743: LIST
8744: LIST
8745: PPUSH
8746: CALL_OW 72
8750: ADD
8751: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
8752: LD_VAR 0 2
8756: PPUSH
8757: LD_INT 5
8759: PPUSH
8760: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
8764: LD_INT 5
8766: PPUSH
8767: LD_INT 1
8769: PPUSH
8770: CALL_OW 343
// k := 1 ;
8774: LD_ADDR_VAR 0 3
8778: PUSH
8779: LD_INT 1
8781: ST_TO_ADDR
// for i in tmp do
8782: LD_ADDR_VAR 0 1
8786: PUSH
8787: LD_VAR 0 2
8791: PUSH
8792: FOR_IN
8793: IFFALSE 8878
// begin if IsInUnit ( i ) then
8795: LD_VAR 0 1
8799: PPUSH
8800: CALL_OW 310
8804: IFFALSE 8815
// ComExitBuilding ( i ) ;
8806: LD_VAR 0 1
8810: PPUSH
8811: CALL_OW 122
// if GetClass ( i ) = 3 then
8815: LD_VAR 0 1
8819: PPUSH
8820: CALL_OW 257
8824: PUSH
8825: LD_INT 3
8827: EQUAL
8828: IFFALSE 8864
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
8830: LD_VAR 0 1
8834: PPUSH
8835: LD_EXP 41
8839: PUSH
8840: LD_VAR 0 3
8844: ARRAY
8845: PPUSH
8846: CALL_OW 180
// k := k + 1 ;
8850: LD_ADDR_VAR 0 3
8854: PUSH
8855: LD_VAR 0 3
8859: PUSH
8860: LD_INT 1
8862: PLUS
8863: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
8864: LD_VAR 0 1
8868: PPUSH
8869: LD_INT 10
8871: PPUSH
8872: CALL_OW 173
// end ;
8876: GO 8792
8878: POP
8879: POP
// ar_patrol := true ;
8880: LD_ADDR_EXP 7
8884: PUSH
8885: LD_INT 1
8887: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
8888: LD_INT 10
8890: PPUSH
8891: CALL_OW 67
// for i in tmp do
8895: LD_ADDR_VAR 0 1
8899: PUSH
8900: LD_VAR 0 2
8904: PUSH
8905: FOR_IN
8906: IFFALSE 8934
// if not HasTask ( i ) then
8908: LD_VAR 0 1
8912: PPUSH
8913: CALL_OW 314
8917: NOT
8918: IFFALSE 8932
// ComMoveToArea ( i , escape_area ) ;
8920: LD_VAR 0 1
8924: PPUSH
8925: LD_INT 10
8927: PPUSH
8928: CALL_OW 113
8932: GO 8905
8934: POP
8935: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
8936: LD_ADDR_VAR 0 3
8940: PUSH
8941: LD_VAR 0 2
8945: PPUSH
8946: LD_INT 95
8948: PUSH
8949: LD_INT 10
8951: PUSH
8952: EMPTY
8953: LIST
8954: LIST
8955: PPUSH
8956: CALL_OW 72
8960: ST_TO_ADDR
// if k then
8961: LD_VAR 0 3
8965: IFFALSE 9034
// for i in k do
8967: LD_ADDR_VAR 0 1
8971: PUSH
8972: LD_VAR 0 3
8976: PUSH
8977: FOR_IN
8978: IFFALSE 9032
// begin if IsInUnit ( i ) then
8980: LD_VAR 0 1
8984: PPUSH
8985: CALL_OW 310
8989: IFFALSE 9005
// RemoveUnit ( IsInUnit ( i ) ) ;
8991: LD_VAR 0 1
8995: PPUSH
8996: CALL_OW 310
9000: PPUSH
9001: CALL_OW 64
// RemoveUnit ( i ) ;
9005: LD_VAR 0 1
9009: PPUSH
9010: CALL_OW 64
// tmp := tmp diff i ;
9014: LD_ADDR_VAR 0 2
9018: PUSH
9019: LD_VAR 0 2
9023: PUSH
9024: LD_VAR 0 1
9028: DIFF
9029: ST_TO_ADDR
// end ;
9030: GO 8977
9032: POP
9033: POP
// until tmp = [ ] ;
9034: LD_VAR 0 2
9038: PUSH
9039: EMPTY
9040: EQUAL
9041: IFFALSE 8888
// ChangeSideFog ( 5 , 5 ) ;
9043: LD_INT 5
9045: PPUSH
9046: LD_INT 5
9048: PPUSH
9049: CALL_OW 343
// end ;
9053: PPOPN 3
9055: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9056: LD_EXP 7
9060: IFFALSE 9350
9062: GO 9064
9064: DISABLE
9065: LD_INT 0
9067: PPUSH
9068: PPUSH
9069: PPUSH
// begin uc_side := 2 ;
9070: LD_ADDR_OWVAR 20
9074: PUSH
9075: LD_INT 2
9077: ST_TO_ADDR
// uc_nation := 2 ;
9078: LD_ADDR_OWVAR 21
9082: PUSH
9083: LD_INT 2
9085: ST_TO_ADDR
// InitHc ;
9086: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
9090: LD_INT 1
9092: PPUSH
9093: LD_INT 1
9095: PPUSH
9096: LD_INT 6
9098: PPUSH
9099: CALL_OW 380
// un := CreateHuman ;
9103: LD_ADDR_VAR 0 2
9107: PUSH
9108: CALL_OW 44
9112: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
9113: LD_INT 14
9115: PPUSH
9116: LD_INT 1
9118: PPUSH
9119: LD_INT 1
9121: PPUSH
9122: LD_INT 27
9124: PPUSH
9125: LD_INT 98
9127: PPUSH
9128: CALL 50943 0 5
// veh := CreateVehicle ;
9132: LD_ADDR_VAR 0 3
9136: PUSH
9137: CALL_OW 45
9141: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
9142: LD_VAR 0 3
9146: PPUSH
9147: LD_INT 4
9149: PPUSH
9150: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
9154: LD_VAR 0 3
9158: PPUSH
9159: LD_INT 179
9161: PPUSH
9162: LD_INT 135
9164: PPUSH
9165: LD_INT 0
9167: PPUSH
9168: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
9172: LD_VAR 0 2
9176: PPUSH
9177: LD_VAR 0 3
9181: PPUSH
9182: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
9186: LD_VAR 0 2
9190: PPUSH
9191: LD_INT 126
9193: PPUSH
9194: LD_INT 133
9196: PPUSH
9197: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
9201: LD_INT 10
9203: PPUSH
9204: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
9208: LD_INT 1
9210: PPUSH
9211: LD_VAR 0 3
9215: PPUSH
9216: CALL_OW 292
9220: PUSH
9221: LD_VAR 0 3
9225: PPUSH
9226: LD_INT 7
9228: PPUSH
9229: CALL_OW 296
9233: PUSH
9234: LD_INT 9
9236: LESS
9237: OR
9238: IFFALSE 9201
// ComHold ( veh ) ;
9240: LD_VAR 0 3
9244: PPUSH
9245: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
9249: LD_VAR 0 2
9253: PPUSH
9254: LD_STRING D2aa-Ar1-1
9256: PPUSH
9257: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
9261: LD_VAR 0 2
9265: PPUSH
9266: LD_INT 177
9268: PPUSH
9269: LD_INT 96
9271: PPUSH
9272: CALL_OW 111
// AddComExitVehicle ( un ) ;
9276: LD_VAR 0 2
9280: PPUSH
9281: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
9285: LD_INT 35
9287: PPUSH
9288: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
9292: LD_VAR 0 2
9296: PPUSH
9297: LD_INT 204
9299: PPUSH
9300: CALL_OW 296
9304: PUSH
9305: LD_INT 15
9307: LESS
9308: IFFALSE 9285
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
9310: LD_ADDR_EXP 50
9314: PUSH
9315: LD_EXP 50
9319: PPUSH
9320: LD_INT 3
9322: PUSH
9323: LD_EXP 50
9327: PUSH
9328: LD_INT 3
9330: ARRAY
9331: PUSH
9332: LD_INT 1
9334: PLUS
9335: PUSH
9336: EMPTY
9337: LIST
9338: LIST
9339: PPUSH
9340: LD_VAR 0 2
9344: PPUSH
9345: CALL 51065 0 3
9349: ST_TO_ADDR
// end ;
9350: PPOPN 3
9352: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
9353: LD_INT 7
9355: PPUSH
9356: CALL_OW 255
9360: PUSH
9361: LD_INT 1
9363: EQUAL
9364: PUSH
9365: LD_INT 7
9367: PPUSH
9368: CALL_OW 301
9372: OR
9373: IFFALSE 11797
9375: GO 9377
9377: DISABLE
9378: LD_INT 0
9380: PPUSH
9381: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
9382: LD_ADDR_VAR 0 1
9386: PUSH
9387: LD_EXP 36
9391: PPUSH
9392: LD_INT 21
9394: PUSH
9395: LD_INT 3
9397: PUSH
9398: EMPTY
9399: LIST
9400: LIST
9401: PPUSH
9402: CALL_OW 72
9406: PUSH
9407: FOR_IN
9408: IFFALSE 9424
// SetSide ( i , 1 ) ;
9410: LD_VAR 0 1
9414: PPUSH
9415: LD_INT 1
9417: PPUSH
9418: CALL_OW 235
9422: GO 9407
9424: POP
9425: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
9426: LD_ADDR_VAR 0 2
9430: PUSH
9431: LD_INT 46
9433: PUSH
9434: LD_INT 41
9436: PUSH
9437: EMPTY
9438: LIST
9439: LIST
9440: PUSH
9441: LD_INT 50
9443: PUSH
9444: LD_INT 25
9446: PUSH
9447: EMPTY
9448: LIST
9449: LIST
9450: PUSH
9451: LD_INT 57
9453: PUSH
9454: LD_INT 75
9456: PUSH
9457: EMPTY
9458: LIST
9459: LIST
9460: PUSH
9461: LD_INT 75
9463: PUSH
9464: LD_INT 89
9466: PUSH
9467: EMPTY
9468: LIST
9469: LIST
9470: PUSH
9471: LD_INT 51
9473: PUSH
9474: LD_INT 45
9476: PUSH
9477: EMPTY
9478: LIST
9479: LIST
9480: PUSH
9481: LD_INT 95
9483: PUSH
9484: LD_INT 95
9486: PUSH
9487: EMPTY
9488: LIST
9489: LIST
9490: PUSH
9491: LD_INT 84
9493: PUSH
9494: LD_INT 77
9496: PUSH
9497: EMPTY
9498: LIST
9499: LIST
9500: PUSH
9501: LD_INT 101
9503: PUSH
9504: LD_INT 76
9506: PUSH
9507: EMPTY
9508: LIST
9509: LIST
9510: PUSH
9511: LD_INT 118
9513: PUSH
9514: LD_INT 81
9516: PUSH
9517: EMPTY
9518: LIST
9519: LIST
9520: PUSH
9521: LD_INT 139
9523: PUSH
9524: LD_INT 97
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: PUSH
9531: LD_INT 129
9533: PUSH
9534: LD_INT 114
9536: PUSH
9537: EMPTY
9538: LIST
9539: LIST
9540: PUSH
9541: LD_INT 154
9543: PUSH
9544: LD_INT 111
9546: PUSH
9547: EMPTY
9548: LIST
9549: LIST
9550: PUSH
9551: EMPTY
9552: LIST
9553: LIST
9554: LIST
9555: LIST
9556: LIST
9557: LIST
9558: LIST
9559: LIST
9560: LIST
9561: LIST
9562: LIST
9563: LIST
9564: ST_TO_ADDR
// base_captured := true ;
9565: LD_ADDR_EXP 6
9569: PUSH
9570: LD_INT 1
9572: ST_TO_ADDR
// DialogueOn ;
9573: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
9577: LD_EXP 21
9581: PPUSH
9582: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
9586: LD_EXP 21
9590: PPUSH
9591: LD_STRING D2-JMM-1
9593: PPUSH
9594: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
9598: LD_EXP 30
9602: PPUSH
9603: LD_STRING D2-Pow-1
9605: PPUSH
9606: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
9610: LD_EXP 21
9614: PPUSH
9615: LD_STRING D2-JMM-2
9617: PPUSH
9618: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
9622: LD_EXP 30
9626: PPUSH
9627: LD_STRING D2-Pow-2
9629: PPUSH
9630: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
9634: LD_EXP 21
9638: PPUSH
9639: LD_STRING D2-JMM-3
9641: PPUSH
9642: CALL_OW 88
// DialogueOff ;
9646: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
9650: LD_STRING M2
9652: PPUSH
9653: CALL_OW 337
// Wait ( 0 0$2 ) ;
9657: LD_INT 70
9659: PPUSH
9660: CALL_OW 67
// if IsOk ( Gary ) then
9664: LD_EXP 32
9668: PPUSH
9669: CALL_OW 302
9673: IFFALSE 9687
// Say ( Gary , D2a-Gary-1 ) ;
9675: LD_EXP 32
9679: PPUSH
9680: LD_STRING D2a-Gary-1
9682: PPUSH
9683: CALL_OW 88
// if IsOk ( Bobby ) then
9687: LD_EXP 24
9691: PPUSH
9692: CALL_OW 302
9696: IFFALSE 9710
// Say ( Bobby , D2a-Bobby-1 ) ;
9698: LD_EXP 24
9702: PPUSH
9703: LD_STRING D2a-Bobby-1
9705: PPUSH
9706: CALL_OW 88
// if IsOk ( Cyrus ) then
9710: LD_EXP 25
9714: PPUSH
9715: CALL_OW 302
9719: IFFALSE 9733
// Say ( Cyrus , D2a-Cyrus-1 ) ;
9721: LD_EXP 25
9725: PPUSH
9726: LD_STRING D2a-Cyrus-1
9728: PPUSH
9729: CALL_OW 88
// if IsOk ( Lisa ) then
9733: LD_EXP 22
9737: PPUSH
9738: CALL_OW 302
9742: IFFALSE 9756
// Say ( Lisa , D2a-Lisa-1 ) ;
9744: LD_EXP 22
9748: PPUSH
9749: LD_STRING D2a-Lisa-1
9751: PPUSH
9752: CALL_OW 88
// if IsOk ( Frank ) then
9756: LD_EXP 33
9760: PPUSH
9761: CALL_OW 302
9765: IFFALSE 9779
// Say ( Frank , D2a-Frank-1 ) ;
9767: LD_EXP 33
9771: PPUSH
9772: LD_STRING D2a-Frank-1
9774: PPUSH
9775: CALL_OW 88
// if IsOk ( Cornel ) then
9779: LD_EXP 31
9783: PPUSH
9784: CALL_OW 302
9788: IFFALSE 9802
// Say ( Cornel , D2a-Corn-1 ) ;
9790: LD_EXP 31
9794: PPUSH
9795: LD_STRING D2a-Corn-1
9797: PPUSH
9798: CALL_OW 88
// if IsOk ( Donaldson ) then
9802: LD_EXP 23
9806: PPUSH
9807: CALL_OW 302
9811: IFFALSE 9825
// Say ( Donaldson , D2a-Don-1 ) ;
9813: LD_EXP 23
9817: PPUSH
9818: LD_STRING D2a-Don-1
9820: PPUSH
9821: CALL_OW 88
// if IsOk ( Brown ) then
9825: LD_EXP 27
9829: PPUSH
9830: CALL_OW 302
9834: IFFALSE 9848
// Say ( Brown , D2a-Brown-1 ) ;
9836: LD_EXP 27
9840: PPUSH
9841: LD_STRING D2a-Brown-1
9843: PPUSH
9844: CALL_OW 88
// Wait ( 0 0$30 ) ;
9848: LD_INT 1050
9850: PPUSH
9851: CALL_OW 67
// if IsOk ( Frank ) then
9855: LD_EXP 33
9859: PPUSH
9860: CALL_OW 302
9864: IFFALSE 10130
// begin DialogueOn ;
9866: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
9870: LD_EXP 21
9874: PUSH
9875: LD_EXP 33
9879: PUSH
9880: EMPTY
9881: LIST
9882: LIST
9883: PPUSH
9884: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
9888: LD_EXP 33
9892: PPUSH
9893: LD_STRING D3F-Frank-1
9895: PPUSH
9896: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
9900: LD_EXP 21
9904: PPUSH
9905: LD_STRING D3F-JMM-1
9907: PPUSH
9908: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
9912: LD_EXP 33
9916: PPUSH
9917: LD_STRING D3F-Frank-2
9919: PPUSH
9920: CALL_OW 88
// case Query ( QFrank ) of 1 :
9924: LD_STRING QFrank
9926: PPUSH
9927: CALL_OW 97
9931: PUSH
9932: LD_INT 1
9934: DOUBLE
9935: EQUAL
9936: IFTRUE 9940
9938: GO 9963
9940: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
9941: LD_EXP 21
9945: PPUSH
9946: LD_STRING D3Fa-JMM-1
9948: PPUSH
9949: CALL_OW 88
// us_scout := 1 ;
9953: LD_ADDR_EXP 8
9957: PUSH
9958: LD_INT 1
9960: ST_TO_ADDR
// end ; 2 :
9961: GO 10126
9963: LD_INT 2
9965: DOUBLE
9966: EQUAL
9967: IFTRUE 9971
9969: GO 10093
9971: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
9972: LD_EXP 21
9976: PPUSH
9977: LD_STRING D3Fb-JMM-1
9979: PPUSH
9980: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
9984: LD_EXP 33
9988: PPUSH
9989: LD_STRING D3Fb-Frank-1
9991: PPUSH
9992: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
9996: LD_STRING QFrank2
9998: PPUSH
9999: CALL_OW 97
10003: PUSH
10004: LD_INT 1
10006: DOUBLE
10007: EQUAL
10008: IFTRUE 10012
10010: GO 10059
10012: POP
// begin us_scout := 2 ;
10013: LD_ADDR_EXP 8
10017: PUSH
10018: LD_INT 2
10020: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10021: LD_EXP 21
10025: PPUSH
10026: LD_STRING D3Fba-JMM-1
10028: PPUSH
10029: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10033: LD_EXP 33
10037: PPUSH
10038: LD_STRING D3Fba-Frank-1
10040: PPUSH
10041: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10045: LD_EXP 21
10049: PPUSH
10050: LD_STRING D3Fba-JMM-2
10052: PPUSH
10053: CALL_OW 88
// end ; 2 :
10057: GO 10091
10059: LD_INT 2
10061: DOUBLE
10062: EQUAL
10063: IFTRUE 10067
10065: GO 10090
10067: POP
// begin us_scout := 0 ;
10068: LD_ADDR_EXP 8
10072: PUSH
10073: LD_INT 0
10075: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10076: LD_EXP 21
10080: PPUSH
10081: LD_STRING D3Fbb-JMM-1
10083: PPUSH
10084: CALL_OW 88
// end ; end ;
10088: GO 10091
10090: POP
// end ; 3 :
10091: GO 10126
10093: LD_INT 3
10095: DOUBLE
10096: EQUAL
10097: IFTRUE 10101
10099: GO 10125
10101: POP
// begin us_scout := - 1 ;
10102: LD_ADDR_EXP 8
10106: PUSH
10107: LD_INT 1
10109: NEG
10110: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
10111: LD_EXP 21
10115: PPUSH
10116: LD_STRING D3Fc-JMM-1
10118: PPUSH
10119: CALL_OW 88
// end ; end ;
10123: GO 10126
10125: POP
// DialogueOff ;
10126: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
10130: LD_EXP 8
10134: PUSH
10135: LD_INT 1
10137: NEG
10138: PUSH
10139: LD_INT 0
10141: PUSH
10142: EMPTY
10143: LIST
10144: LIST
10145: IN
10146: IFFALSE 10150
// exit ;
10148: GO 11797
// if us_scout in [ 1 , 2 ] then
10150: LD_EXP 8
10154: PUSH
10155: LD_INT 1
10157: PUSH
10158: LD_INT 2
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: IN
10165: IFFALSE 10864
// begin if IsInUnit ( Frank ) then
10167: LD_EXP 33
10171: PPUSH
10172: CALL_OW 310
10176: IFFALSE 10187
// ComExitBuilding ( Frank ) ;
10178: LD_EXP 33
10182: PPUSH
10183: CALL_OW 122
// if IsDrivenBy ( Frank ) then
10187: LD_EXP 33
10191: PPUSH
10192: CALL_OW 311
10196: IFFALSE 10207
// ComExitVehicle ( Frank ) ;
10198: LD_EXP 33
10202: PPUSH
10203: CALL_OW 121
// SetSide ( Frank , 4 ) ;
10207: LD_EXP 33
10211: PPUSH
10212: LD_INT 4
10214: PPUSH
10215: CALL_OW 235
// wait ( 0 0$1 ) ;
10219: LD_INT 35
10221: PPUSH
10222: CALL_OW 67
// if us_scout = 2 then
10226: LD_EXP 8
10230: PUSH
10231: LD_INT 2
10233: EQUAL
10234: IFFALSE 10602
// begin ComMoveXY ( Frank , 75 , 63 ) ;
10236: LD_EXP 33
10240: PPUSH
10241: LD_INT 75
10243: PPUSH
10244: LD_INT 63
10246: PPUSH
10247: CALL_OW 111
// AddComHold ( Frank ) ;
10251: LD_EXP 33
10255: PPUSH
10256: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
10260: LD_EXP 33
10264: PPUSH
10265: LD_INT 770
10267: PPUSH
10268: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
10272: LD_EXP 33
10276: PPUSH
10277: LD_INT 100
10279: PPUSH
10280: LD_INT 75
10282: PPUSH
10283: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
10287: LD_EXP 33
10291: PPUSH
10292: LD_INT 123
10294: PPUSH
10295: LD_INT 103
10297: PPUSH
10298: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
10302: LD_EXP 33
10306: PPUSH
10307: LD_INT 138
10309: PPUSH
10310: LD_INT 108
10312: PPUSH
10313: CALL_OW 171
// AddComHold ( Frank ) ;
10317: LD_EXP 33
10321: PPUSH
10322: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10326: LD_INT 35
10328: PPUSH
10329: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
10333: LD_EXP 33
10337: PPUSH
10338: LD_INT 138
10340: PPUSH
10341: LD_INT 108
10343: PPUSH
10344: CALL_OW 307
10348: IFFALSE 10326
// AddComMoveXY ( Frank , 125 , 132 ) ;
10350: LD_EXP 33
10354: PPUSH
10355: LD_INT 125
10357: PPUSH
10358: LD_INT 132
10360: PPUSH
10361: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10365: LD_INT 35
10367: PPUSH
10368: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
10372: LD_INT 1
10374: PPUSH
10375: LD_EXP 33
10379: PPUSH
10380: CALL_OW 292
10384: PUSH
10385: LD_EXP 33
10389: PPUSH
10390: LD_INT 7
10392: PPUSH
10393: CALL_OW 296
10397: PUSH
10398: LD_INT 7
10400: LESS
10401: OR
10402: IFFALSE 10365
// DialogueOn ;
10404: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10408: LD_EXP 33
10412: PPUSH
10413: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
10417: LD_INT 10
10419: PPUSH
10420: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
10424: LD_EXP 21
10428: PPUSH
10429: LD_STRING D4Fa-JMM-1
10431: PPUSH
10432: CALL_OW 88
// for i in points do
10436: LD_ADDR_VAR 0 1
10440: PUSH
10441: LD_VAR 0 2
10445: PUSH
10446: FOR_IN
10447: IFFALSE 10505
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
10449: LD_VAR 0 1
10453: PUSH
10454: LD_INT 1
10456: ARRAY
10457: PPUSH
10458: LD_VAR 0 1
10462: PUSH
10463: LD_INT 2
10465: ARRAY
10466: PPUSH
10467: LD_INT 1
10469: PPUSH
10470: LD_INT 20
10472: NEG
10473: PPUSH
10474: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
10478: LD_VAR 0 1
10482: PUSH
10483: LD_INT 1
10485: ARRAY
10486: PPUSH
10487: LD_VAR 0 1
10491: PUSH
10492: LD_INT 2
10494: ARRAY
10495: PPUSH
10496: LD_INT 1
10498: PPUSH
10499: CALL_OW 331
// end ;
10503: GO 10446
10505: POP
10506: POP
// dwait ( 0 0$0.5 ) ;
10507: LD_INT 18
10509: PPUSH
10510: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
10514: LD_INT 42
10516: PPUSH
10517: LD_INT 27
10519: PPUSH
10520: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
10524: LD_EXP 33
10528: PPUSH
10529: LD_STRING D4Fa-Frank-1
10531: PPUSH
10532: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
10536: LD_INT 18
10538: PPUSH
10539: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
10543: LD_EXP 21
10547: PPUSH
10548: LD_STRING D4Fa-JMM-2
10550: PPUSH
10551: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
10555: LD_INT 118
10557: PPUSH
10558: LD_INT 80
10560: PPUSH
10561: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
10565: LD_EXP 33
10569: PPUSH
10570: LD_STRING D4Fa-Frank-2
10572: PPUSH
10573: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
10577: LD_INT 10
10579: PPUSH
10580: CALL_OW 68
// DialogueOff ;
10584: CALL_OW 7
// SetSide ( Frank , 1 ) ;
10588: LD_EXP 33
10592: PPUSH
10593: LD_INT 1
10595: PPUSH
10596: CALL_OW 235
// end else
10600: GO 10864
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
10602: LD_INT 2
10604: PPUSH
10605: LD_INT 4
10607: PPUSH
10608: LD_INT 2
10610: PPUSH
10611: LD_INT 1
10613: PPUSH
10614: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
10618: LD_EXP 33
10622: PPUSH
10623: LD_INT 75
10625: PPUSH
10626: LD_INT 63
10628: PPUSH
10629: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
10633: LD_EXP 33
10637: PPUSH
10638: LD_INT 175
10640: PPUSH
10641: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
10645: LD_EXP 33
10649: PPUSH
10650: LD_INT 102
10652: PPUSH
10653: LD_INT 76
10655: PPUSH
10656: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
10660: LD_EXP 33
10664: PPUSH
10665: LD_INT 108
10667: PPUSH
10668: LD_INT 70
10670: PPUSH
10671: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10675: LD_INT 35
10677: PPUSH
10678: CALL_OW 67
// until See ( 2 , Frank ) ;
10682: LD_INT 2
10684: PPUSH
10685: LD_EXP 33
10689: PPUSH
10690: CALL_OW 292
10694: IFFALSE 10675
// ComMoveXY ( Frank , 112 , 118 ) ;
10696: LD_EXP 33
10700: PPUSH
10701: LD_INT 112
10703: PPUSH
10704: LD_INT 118
10706: PPUSH
10707: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
10711: LD_EXP 33
10715: PPUSH
10716: CALL_OW 256
10720: PUSH
10721: LD_INT 750
10723: GREATEREQUAL
10724: IFFALSE 10738
// SetLives ( Frank , 700 ) ;
10726: LD_EXP 33
10730: PPUSH
10731: LD_INT 700
10733: PPUSH
10734: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
10738: LD_INT 35
10740: PPUSH
10741: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
10745: LD_INT 1
10747: PPUSH
10748: LD_EXP 33
10752: PPUSH
10753: CALL_OW 292
10757: PUSH
10758: LD_EXP 33
10762: PPUSH
10763: LD_INT 7
10765: PPUSH
10766: CALL_OW 296
10770: PUSH
10771: LD_INT 17
10773: LESS
10774: OR
10775: IFFALSE 10738
// DialogueOn ;
10777: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10781: LD_EXP 33
10785: PPUSH
10786: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
10790: LD_EXP 33
10794: PPUSH
10795: LD_STRING D4Fb-Frank-1
10797: PPUSH
10798: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
10802: LD_EXP 21
10806: PPUSH
10807: LD_STRING D4Fb-JMM-1
10809: PPUSH
10810: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
10814: LD_INT 2
10816: PPUSH
10817: LD_STRING D4Fb-FSci1-1
10819: PPUSH
10820: CALL 15445 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
10824: LD_EXP 33
10828: PPUSH
10829: LD_STRING D4Fb-Frank-2
10831: PPUSH
10832: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
10836: LD_EXP 21
10840: PPUSH
10841: LD_STRING D4Fb-JMM-2
10843: PPUSH
10844: CALL_OW 88
// DialogueOff ;
10848: CALL_OW 7
// SetSide ( Frank , 1 ) ;
10852: LD_EXP 33
10856: PPUSH
10857: LD_INT 1
10859: PPUSH
10860: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
10864: LD_EXP 34
10868: PPUSH
10869: CALL_OW 302
10873: PUSH
10874: LD_EXP 33
10878: NOT
10879: AND
10880: IFFALSE 11028
// begin DialogueOn ;
10882: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
10886: LD_EXP 21
10890: PUSH
10891: LD_EXP 34
10895: PUSH
10896: EMPTY
10897: LIST
10898: LIST
10899: PPUSH
10900: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
10904: LD_EXP 34
10908: PPUSH
10909: LD_STRING D3Y-Yam-1
10911: PPUSH
10912: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
10916: LD_EXP 21
10920: PPUSH
10921: LD_STRING D3Y-JMM-1
10923: PPUSH
10924: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
10928: LD_EXP 34
10932: PPUSH
10933: LD_STRING D3Y-Yam-2
10935: PPUSH
10936: CALL_OW 88
// case Query ( QYamoko ) of 1 :
10940: LD_STRING QYamoko
10942: PPUSH
10943: CALL_OW 97
10947: PUSH
10948: LD_INT 1
10950: DOUBLE
10951: EQUAL
10952: IFTRUE 10956
10954: GO 10991
10956: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
10957: LD_EXP 21
10961: PPUSH
10962: LD_STRING D3Ya-JMM-1
10964: PPUSH
10965: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
10969: LD_EXP 34
10973: PPUSH
10974: LD_STRING D3Ya-Yam-1
10976: PPUSH
10977: CALL_OW 88
// us_scout := 1 ;
10981: LD_ADDR_EXP 8
10985: PUSH
10986: LD_INT 1
10988: ST_TO_ADDR
// end ; 2 :
10989: GO 11024
10991: LD_INT 2
10993: DOUBLE
10994: EQUAL
10995: IFTRUE 10999
10997: GO 11023
10999: POP
// begin us_scout := - 1 ;
11000: LD_ADDR_EXP 8
11004: PUSH
11005: LD_INT 1
11007: NEG
11008: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11009: LD_EXP 21
11013: PPUSH
11014: LD_STRING D3Yb-JMM-1
11016: PPUSH
11017: CALL_OW 88
// end ; end ;
11021: GO 11024
11023: POP
// DialogueOff ;
11024: CALL_OW 7
// end ; if Frank then
11028: LD_EXP 33
11032: IFFALSE 11036
// exit ;
11034: GO 11797
// if us_scout in [ - 1 , 0 ] then
11036: LD_EXP 8
11040: PUSH
11041: LD_INT 1
11043: NEG
11044: PUSH
11045: LD_INT 0
11047: PUSH
11048: EMPTY
11049: LIST
11050: LIST
11051: IN
11052: IFFALSE 11056
// exit ;
11054: GO 11797
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11056: LD_ADDR_EXP 8
11060: PUSH
11061: LD_INT 2
11063: PUSH
11064: LD_INT 2
11066: PUSH
11067: LD_INT 1
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: LIST
11074: PUSH
11075: LD_OWVAR 67
11079: ARRAY
11080: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11081: LD_EXP 8
11085: PUSH
11086: LD_INT 1
11088: PUSH
11089: LD_INT 2
11091: PUSH
11092: EMPTY
11093: LIST
11094: LIST
11095: IN
11096: IFFALSE 11797
// begin if IsInUnit ( Kikuchi ) then
11098: LD_EXP 34
11102: PPUSH
11103: CALL_OW 310
11107: IFFALSE 11118
// ComExitBuilding ( Kikuchi ) ;
11109: LD_EXP 34
11113: PPUSH
11114: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
11118: LD_EXP 34
11122: PPUSH
11123: CALL_OW 311
11127: IFFALSE 11138
// ComExitVehicle ( Kikuchi ) ;
11129: LD_EXP 34
11133: PPUSH
11134: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
11138: LD_EXP 34
11142: PPUSH
11143: LD_INT 4
11145: PPUSH
11146: CALL_OW 235
// wait ( 0 0$1 ) ;
11150: LD_INT 35
11152: PPUSH
11153: CALL_OW 67
// if us_scout = 2 then
11157: LD_EXP 8
11161: PUSH
11162: LD_INT 2
11164: EQUAL
11165: IFFALSE 11545
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
11167: LD_EXP 34
11171: PPUSH
11172: LD_INT 75
11174: PPUSH
11175: LD_INT 63
11177: PPUSH
11178: CALL_OW 111
// AddComHold ( Kikuchi ) ;
11182: LD_EXP 34
11186: PPUSH
11187: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
11191: LD_EXP 34
11195: PPUSH
11196: LD_INT 770
11198: PPUSH
11199: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
11203: LD_EXP 34
11207: PPUSH
11208: LD_INT 100
11210: PPUSH
11211: LD_INT 75
11213: PPUSH
11214: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
11218: LD_EXP 34
11222: PPUSH
11223: LD_INT 123
11225: PPUSH
11226: LD_INT 103
11228: PPUSH
11229: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
11233: LD_EXP 34
11237: PPUSH
11238: LD_INT 138
11240: PPUSH
11241: LD_INT 108
11243: PPUSH
11244: CALL_OW 171
// AddComHold ( Kikuchi ) ;
11248: LD_EXP 34
11252: PPUSH
11253: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11257: LD_INT 35
11259: PPUSH
11260: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
11264: LD_EXP 34
11268: PPUSH
11269: LD_INT 138
11271: PPUSH
11272: LD_INT 108
11274: PPUSH
11275: CALL_OW 307
11279: IFFALSE 11257
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
11281: LD_EXP 34
11285: PPUSH
11286: LD_INT 125
11288: PPUSH
11289: LD_INT 132
11291: PPUSH
11292: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11296: LD_INT 35
11298: PPUSH
11299: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
11303: LD_INT 1
11305: PPUSH
11306: LD_EXP 34
11310: PPUSH
11311: CALL_OW 292
11315: PUSH
11316: LD_EXP 34
11320: PPUSH
11321: LD_INT 7
11323: PPUSH
11324: CALL_OW 296
11328: PUSH
11329: LD_INT 7
11331: LESS
11332: OR
11333: IFFALSE 11296
// DialogueOn ;
11335: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11339: LD_EXP 34
11343: PPUSH
11344: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11348: LD_INT 10
11350: PPUSH
11351: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
11355: LD_EXP 34
11359: PPUSH
11360: LD_STRING D4Ya-Yam-1
11362: PPUSH
11363: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
11367: LD_EXP 21
11371: PPUSH
11372: LD_STRING D4Ya-JMM-1
11374: PPUSH
11375: CALL_OW 88
// for i in points do
11379: LD_ADDR_VAR 0 1
11383: PUSH
11384: LD_VAR 0 2
11388: PUSH
11389: FOR_IN
11390: IFFALSE 11448
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11392: LD_VAR 0 1
11396: PUSH
11397: LD_INT 1
11399: ARRAY
11400: PPUSH
11401: LD_VAR 0 1
11405: PUSH
11406: LD_INT 2
11408: ARRAY
11409: PPUSH
11410: LD_INT 1
11412: PPUSH
11413: LD_INT 20
11415: NEG
11416: PPUSH
11417: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11421: LD_VAR 0 1
11425: PUSH
11426: LD_INT 1
11428: ARRAY
11429: PPUSH
11430: LD_VAR 0 1
11434: PUSH
11435: LD_INT 2
11437: ARRAY
11438: PPUSH
11439: LD_INT 1
11441: PPUSH
11442: CALL_OW 331
// end ;
11446: GO 11389
11448: POP
11449: POP
// dwait ( 0 0$0.5 ) ;
11450: LD_INT 18
11452: PPUSH
11453: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11457: LD_INT 42
11459: PPUSH
11460: LD_INT 27
11462: PPUSH
11463: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
11467: LD_EXP 34
11471: PPUSH
11472: LD_STRING D4Ya-Yam-2
11474: PPUSH
11475: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11479: LD_INT 18
11481: PPUSH
11482: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
11486: LD_INT 118
11488: PPUSH
11489: LD_INT 80
11491: PPUSH
11492: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
11496: LD_EXP 21
11500: PPUSH
11501: LD_STRING D4Ya-JMM-2
11503: PPUSH
11504: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
11508: LD_EXP 34
11512: PPUSH
11513: LD_STRING D4Ya-Yam-3
11515: PPUSH
11516: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11520: LD_INT 10
11522: PPUSH
11523: CALL_OW 68
// DialogueOff ;
11527: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
11531: LD_EXP 34
11535: PPUSH
11536: LD_INT 1
11538: PPUSH
11539: CALL_OW 235
// end else
11543: GO 11797
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11545: LD_INT 2
11547: PPUSH
11548: LD_INT 4
11550: PPUSH
11551: LD_INT 2
11553: PPUSH
11554: LD_INT 1
11556: PPUSH
11557: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
11561: LD_EXP 34
11565: PPUSH
11566: LD_INT 75
11568: PPUSH
11569: LD_INT 63
11571: PPUSH
11572: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
11576: LD_EXP 34
11580: PPUSH
11581: LD_INT 175
11583: PPUSH
11584: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
11588: LD_EXP 34
11592: PPUSH
11593: LD_INT 102
11595: PPUSH
11596: LD_INT 76
11598: PPUSH
11599: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
11603: LD_EXP 34
11607: PPUSH
11608: LD_INT 108
11610: PPUSH
11611: LD_INT 70
11613: PPUSH
11614: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11618: LD_INT 35
11620: PPUSH
11621: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
11625: LD_INT 2
11627: PPUSH
11628: LD_EXP 34
11632: PPUSH
11633: CALL_OW 292
11637: IFFALSE 11618
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
11639: LD_EXP 34
11643: PPUSH
11644: LD_INT 112
11646: PPUSH
11647: LD_INT 118
11649: PPUSH
11650: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
11654: LD_EXP 34
11658: PPUSH
11659: CALL_OW 256
11663: PUSH
11664: LD_INT 750
11666: GREATEREQUAL
11667: IFFALSE 11681
// SetLives ( Kikuchi , 700 ) ;
11669: LD_EXP 34
11673: PPUSH
11674: LD_INT 700
11676: PPUSH
11677: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11681: LD_INT 35
11683: PPUSH
11684: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
11688: LD_INT 1
11690: PPUSH
11691: LD_EXP 34
11695: PPUSH
11696: CALL_OW 292
11700: PUSH
11701: LD_EXP 34
11705: PPUSH
11706: LD_INT 7
11708: PPUSH
11709: CALL_OW 296
11713: PUSH
11714: LD_INT 17
11716: LESS
11717: OR
11718: IFFALSE 11681
// DialogueOn ;
11720: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11724: LD_EXP 34
11728: PPUSH
11729: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
11733: LD_EXP 34
11737: PPUSH
11738: LD_STRING D4Yb-Yam-1
11740: PPUSH
11741: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
11745: LD_EXP 21
11749: PPUSH
11750: LD_STRING D4Yb-JMM-1
11752: PPUSH
11753: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
11757: LD_EXP 34
11761: PPUSH
11762: LD_STRING D4Yb-Yam-2
11764: PPUSH
11765: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
11769: LD_EXP 21
11773: PPUSH
11774: LD_STRING D4Yb-JMM-2
11776: PPUSH
11777: CALL_OW 88
// DialogueOff ;
11781: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
11785: LD_EXP 34
11789: PPUSH
11790: LD_INT 1
11792: PPUSH
11793: CALL_OW 235
// end ; end ; end ;
11797: PPOPN 2
11799: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
11800: LD_EXP 6
11804: IFFALSE 12837
11806: GO 11808
11808: DISABLE
11809: LD_INT 0
11811: PPUSH
11812: PPUSH
11813: PPUSH
11814: PPUSH
// begin enable ;
11815: ENABLE
// if not seen [ 1 ] then
11816: LD_EXP 9
11820: PUSH
11821: LD_INT 1
11823: ARRAY
11824: NOT
11825: IFFALSE 12005
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
11827: LD_ADDR_VAR 0 2
11831: PUSH
11832: LD_INT 22
11834: PUSH
11835: LD_INT 2
11837: PUSH
11838: EMPTY
11839: LIST
11840: LIST
11841: PUSH
11842: LD_INT 2
11844: PUSH
11845: LD_INT 25
11847: PUSH
11848: LD_INT 11
11850: PUSH
11851: EMPTY
11852: LIST
11853: LIST
11854: PUSH
11855: LD_INT 33
11857: PUSH
11858: LD_INT 4
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: PUSH
11865: EMPTY
11866: LIST
11867: LIST
11868: LIST
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: PPUSH
11874: CALL_OW 69
11878: ST_TO_ADDR
// if tmp then
11879: LD_VAR 0 2
11883: IFFALSE 12005
// for i in tmp do
11885: LD_ADDR_VAR 0 1
11889: PUSH
11890: LD_VAR 0 2
11894: PUSH
11895: FOR_IN
11896: IFFALSE 12003
// if See ( 1 , i ) then
11898: LD_INT 1
11900: PPUSH
11901: LD_VAR 0 1
11905: PPUSH
11906: CALL_OW 292
11910: IFFALSE 12001
// begin seen := Replace ( seen , 1 , true ) ;
11912: LD_ADDR_EXP 9
11916: PUSH
11917: LD_EXP 9
11921: PPUSH
11922: LD_INT 1
11924: PPUSH
11925: LD_INT 1
11927: PPUSH
11928: CALL_OW 1
11932: ST_TO_ADDR
// if CanSayRand ( 1 ) then
11933: LD_INT 1
11935: PPUSH
11936: CALL 15267 0 1
11940: IFFALSE 12001
// begin DialogueOn ;
11942: CALL_OW 6
// CenterNowOnUnits ( i ) ;
11946: LD_VAR 0 1
11950: PPUSH
11951: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11955: LD_INT 10
11957: PPUSH
11958: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
11962: LD_ADDR_VAR 0 3
11966: PUSH
11967: LD_INT 1
11969: PPUSH
11970: LD_STRING D5a-Sol2-1
11972: PPUSH
11973: CALL 15445 0 2
11977: ST_TO_ADDR
// if not un then
11978: LD_VAR 0 3
11982: NOT
11983: IFFALSE 11995
// SayRand ( sex_female , D5a-FSol2-1 ) ;
11985: LD_INT 2
11987: PPUSH
11988: LD_STRING D5a-FSol2-1
11990: PPUSH
11991: CALL 15445 0 2
// DialogueOff ;
11995: CALL_OW 7
// break ;
11999: GO 12003
// end ; end ;
12001: GO 11895
12003: POP
12004: POP
// end ; if not seen [ 2 ] then
12005: LD_EXP 9
12009: PUSH
12010: LD_INT 2
12012: ARRAY
12013: NOT
12014: IFFALSE 12239
// begin can_kamikazed := true ;
12016: LD_ADDR_EXP 10
12020: PUSH
12021: LD_INT 1
12023: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12024: LD_ADDR_VAR 0 2
12028: PUSH
12029: LD_INT 22
12031: PUSH
12032: LD_INT 2
12034: PUSH
12035: EMPTY
12036: LIST
12037: LIST
12038: PUSH
12039: LD_INT 25
12041: PUSH
12042: LD_INT 17
12044: PUSH
12045: EMPTY
12046: LIST
12047: LIST
12048: PUSH
12049: EMPTY
12050: LIST
12051: LIST
12052: PPUSH
12053: CALL_OW 69
12057: ST_TO_ADDR
// if tmp then
12058: LD_VAR 0 2
12062: IFFALSE 12239
// for i in tmp do
12064: LD_ADDR_VAR 0 1
12068: PUSH
12069: LD_VAR 0 2
12073: PUSH
12074: FOR_IN
12075: IFFALSE 12237
// if See ( 1 , i ) then
12077: LD_INT 1
12079: PPUSH
12080: LD_VAR 0 1
12084: PPUSH
12085: CALL_OW 292
12089: IFFALSE 12235
// begin seen := Replace ( seen , 2 , true ) ;
12091: LD_ADDR_EXP 9
12095: PUSH
12096: LD_EXP 9
12100: PPUSH
12101: LD_INT 2
12103: PPUSH
12104: LD_INT 1
12106: PPUSH
12107: CALL_OW 1
12111: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12112: LD_INT 1
12114: PPUSH
12115: CALL 15267 0 1
12119: IFFALSE 12235
// begin DialogueOn ;
12121: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12125: LD_VAR 0 1
12129: PPUSH
12130: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12134: LD_INT 10
12136: PPUSH
12137: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
12141: LD_ADDR_VAR 0 3
12145: PUSH
12146: LD_INT 1
12148: PPUSH
12149: LD_STRING D5b-Sol1-1
12151: PPUSH
12152: CALL 15445 0 2
12156: ST_TO_ADDR
// if not un then
12157: LD_VAR 0 3
12161: NOT
12162: IFFALSE 12180
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
12164: LD_ADDR_VAR 0 3
12168: PUSH
12169: LD_INT 2
12171: PPUSH
12172: LD_STRING D5b-FSol1-1
12174: PPUSH
12175: CALL 15445 0 2
12179: ST_TO_ADDR
// if un then
12180: LD_VAR 0 3
12184: IFFALSE 12229
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
12186: LD_ADDR_VAR 0 4
12190: PUSH
12191: LD_INT 1
12193: PPUSH
12194: LD_STRING D5b-Sol2-1
12196: PPUSH
12197: LD_VAR 0 3
12201: PPUSH
12202: CALL 15671 0 3
12206: ST_TO_ADDR
// if not un2 then
12207: LD_VAR 0 4
12211: NOT
12212: IFFALSE 12229
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
12214: LD_INT 2
12216: PPUSH
12217: LD_STRING D5b-FSol2-1
12219: PPUSH
12220: LD_VAR 0 3
12224: PPUSH
12225: CALL 15671 0 3
// end ; DialogueOff ;
12229: CALL_OW 7
// break ;
12233: GO 12237
// end ; end ;
12235: GO 12074
12237: POP
12238: POP
// end ; if not seen [ 3 ] then
12239: LD_EXP 9
12243: PUSH
12244: LD_INT 3
12246: ARRAY
12247: NOT
12248: IFFALSE 12422
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
12250: LD_ADDR_VAR 0 2
12254: PUSH
12255: LD_INT 22
12257: PUSH
12258: LD_INT 2
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: PUSH
12265: LD_INT 33
12267: PUSH
12268: LD_INT 2
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: PUSH
12275: EMPTY
12276: LIST
12277: LIST
12278: PPUSH
12279: CALL_OW 69
12283: ST_TO_ADDR
// if tmp then
12284: LD_VAR 0 2
12288: IFFALSE 12422
// for i in tmp do
12290: LD_ADDR_VAR 0 1
12294: PUSH
12295: LD_VAR 0 2
12299: PUSH
12300: FOR_IN
12301: IFFALSE 12420
// if See ( 1 , i ) then
12303: LD_INT 1
12305: PPUSH
12306: LD_VAR 0 1
12310: PPUSH
12311: CALL_OW 292
12315: IFFALSE 12418
// begin seen := Replace ( seen , 3 , true ) ;
12317: LD_ADDR_EXP 9
12321: PUSH
12322: LD_EXP 9
12326: PPUSH
12327: LD_INT 3
12329: PPUSH
12330: LD_INT 1
12332: PPUSH
12333: CALL_OW 1
12337: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12338: LD_INT 1
12340: PPUSH
12341: CALL 15267 0 1
12345: IFFALSE 12418
// begin DialogueOn ;
12347: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12351: LD_VAR 0 1
12355: PPUSH
12356: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12360: LD_INT 10
12362: PPUSH
12363: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
12367: LD_ADDR_VAR 0 3
12371: PUSH
12372: LD_INT 1
12374: PPUSH
12375: LD_STRING D8-Sol1-1
12377: PPUSH
12378: CALL 15445 0 2
12382: ST_TO_ADDR
// if not un then
12383: LD_VAR 0 3
12387: NOT
12388: IFFALSE 12400
// SayRand ( sex_female , D8-FSol1-1 ) ;
12390: LD_INT 2
12392: PPUSH
12393: LD_STRING D8-FSol1-1
12395: PPUSH
12396: CALL 15445 0 2
// Say ( JMM , D8-JMM-1 ) ;
12400: LD_EXP 21
12404: PPUSH
12405: LD_STRING D8-JMM-1
12407: PPUSH
12408: CALL_OW 88
// DialogueOff ;
12412: CALL_OW 7
// break ;
12416: GO 12420
// end ; end ;
12418: GO 12300
12420: POP
12421: POP
// end ; if not seen [ 4 ] then
12422: LD_EXP 9
12426: PUSH
12427: LD_INT 4
12429: ARRAY
12430: NOT
12431: IFFALSE 12593
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
12433: LD_ADDR_VAR 0 2
12437: PUSH
12438: LD_INT 22
12440: PUSH
12441: LD_INT 2
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: PUSH
12448: LD_INT 33
12450: PUSH
12451: LD_INT 5
12453: PUSH
12454: EMPTY
12455: LIST
12456: LIST
12457: PUSH
12458: EMPTY
12459: LIST
12460: LIST
12461: PPUSH
12462: CALL_OW 69
12466: ST_TO_ADDR
// if tmp then
12467: LD_VAR 0 2
12471: IFFALSE 12593
// for i in tmp do
12473: LD_ADDR_VAR 0 1
12477: PUSH
12478: LD_VAR 0 2
12482: PUSH
12483: FOR_IN
12484: IFFALSE 12591
// if See ( 1 , i ) then
12486: LD_INT 1
12488: PPUSH
12489: LD_VAR 0 1
12493: PPUSH
12494: CALL_OW 292
12498: IFFALSE 12589
// begin seen := Replace ( seen , 4 , true ) ;
12500: LD_ADDR_EXP 9
12504: PUSH
12505: LD_EXP 9
12509: PPUSH
12510: LD_INT 4
12512: PPUSH
12513: LD_INT 1
12515: PPUSH
12516: CALL_OW 1
12520: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12521: LD_INT 1
12523: PPUSH
12524: CALL 15267 0 1
12528: IFFALSE 12589
// begin DialogueOn ;
12530: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12534: LD_VAR 0 1
12538: PPUSH
12539: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12543: LD_INT 10
12545: PPUSH
12546: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
12550: LD_ADDR_VAR 0 3
12554: PUSH
12555: LD_INT 1
12557: PPUSH
12558: LD_STRING D5a-Sol1-1
12560: PPUSH
12561: CALL 15445 0 2
12565: ST_TO_ADDR
// if not un then
12566: LD_VAR 0 3
12570: NOT
12571: IFFALSE 12583
// SayRand ( sex_female , D5a-FSol1-1 ) ;
12573: LD_INT 2
12575: PPUSH
12576: LD_STRING D5a-FSol1-1
12578: PPUSH
12579: CALL 15445 0 2
// DialogueOff ;
12583: CALL_OW 7
// break ;
12587: GO 12591
// end ; end ;
12589: GO 12483
12591: POP
12592: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
12593: LD_EXP 9
12597: PUSH
12598: LD_INT 5
12600: ARRAY
12601: NOT
12602: PUSH
12603: LD_EXP 9
12607: PUSH
12608: LD_INT 3
12610: ARRAY
12611: AND
12612: IFFALSE 12786
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
12614: LD_ADDR_VAR 0 2
12618: PUSH
12619: LD_INT 22
12621: PUSH
12622: LD_INT 2
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: PUSH
12629: LD_INT 34
12631: PUSH
12632: LD_INT 31
12634: PUSH
12635: EMPTY
12636: LIST
12637: LIST
12638: PUSH
12639: EMPTY
12640: LIST
12641: LIST
12642: PPUSH
12643: CALL_OW 69
12647: ST_TO_ADDR
// if tmp then
12648: LD_VAR 0 2
12652: IFFALSE 12786
// for i in tmp do
12654: LD_ADDR_VAR 0 1
12658: PUSH
12659: LD_VAR 0 2
12663: PUSH
12664: FOR_IN
12665: IFFALSE 12784
// if See ( 1 , i ) then
12667: LD_INT 1
12669: PPUSH
12670: LD_VAR 0 1
12674: PPUSH
12675: CALL_OW 292
12679: IFFALSE 12782
// begin seen := Replace ( seen , 5 , true ) ;
12681: LD_ADDR_EXP 9
12685: PUSH
12686: LD_EXP 9
12690: PPUSH
12691: LD_INT 5
12693: PPUSH
12694: LD_INT 1
12696: PPUSH
12697: CALL_OW 1
12701: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12702: LD_INT 1
12704: PPUSH
12705: CALL 15267 0 1
12709: IFFALSE 12782
// begin DialogueOn ;
12711: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12715: LD_VAR 0 1
12719: PPUSH
12720: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12724: LD_INT 10
12726: PPUSH
12727: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
12731: LD_ADDR_VAR 0 3
12735: PUSH
12736: LD_INT 1
12738: PPUSH
12739: LD_STRING D8a-Sol2-1
12741: PPUSH
12742: CALL 15445 0 2
12746: ST_TO_ADDR
// if not un then
12747: LD_VAR 0 3
12751: NOT
12752: IFFALSE 12764
// SayRand ( sex_female , D8a-FSol2-1 ) ;
12754: LD_INT 2
12756: PPUSH
12757: LD_STRING D8a-FSol2-1
12759: PPUSH
12760: CALL 15445 0 2
// Say ( JMM , D8a-JMM-1 ) ;
12764: LD_EXP 21
12768: PPUSH
12769: LD_STRING D8a-JMM-1
12771: PPUSH
12772: CALL_OW 88
// DialogueOff ;
12776: CALL_OW 7
// break ;
12780: GO 12784
// end ; end ;
12782: GO 12664
12784: POP
12785: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
12786: LD_EXP 9
12790: PUSH
12791: LD_INT 1
12793: ARRAY
12794: PUSH
12795: LD_EXP 9
12799: PUSH
12800: LD_INT 2
12802: ARRAY
12803: AND
12804: PUSH
12805: LD_EXP 9
12809: PUSH
12810: LD_INT 3
12812: ARRAY
12813: AND
12814: PUSH
12815: LD_EXP 9
12819: PUSH
12820: LD_INT 4
12822: ARRAY
12823: AND
12824: PUSH
12825: LD_EXP 9
12829: PUSH
12830: LD_INT 5
12832: ARRAY
12833: AND
12834: IFFALSE 12837
// disable ;
12836: DISABLE
// end ;
12837: PPOPN 4
12839: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
12840: LD_EXP 10
12844: PUSH
12845: LD_EXP 11
12849: AND
12850: IFFALSE 13048
12852: GO 12854
12854: DISABLE
12855: LD_INT 0
12857: PPUSH
// begin DialogueOn ;
12858: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
12862: LD_EXP 11
12866: PPUSH
12867: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
12871: LD_ADDR_VAR 0 1
12875: PUSH
12876: LD_INT 1
12878: PPUSH
12879: LD_STRING D5c-Sol1-1
12881: PPUSH
12882: CALL 15445 0 2
12886: ST_TO_ADDR
// if not un then
12887: LD_VAR 0 1
12891: NOT
12892: IFFALSE 12910
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
12894: LD_ADDR_VAR 0 1
12898: PUSH
12899: LD_INT 2
12901: PPUSH
12902: LD_STRING D5c-FSol1-1
12904: PPUSH
12905: CALL 15445 0 2
12909: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
12910: LD_EXP 21
12914: PPUSH
12915: LD_STRING D5c-JMM-1
12917: PPUSH
12918: CALL_OW 88
// if IsOk ( Lisa ) then
12922: LD_EXP 22
12926: PPUSH
12927: CALL_OW 302
12931: IFFALSE 12947
// Say ( Lisa , D5d-Lisa-1 ) else
12933: LD_EXP 22
12937: PPUSH
12938: LD_STRING D5d-Lisa-1
12940: PPUSH
12941: CALL_OW 88
12945: GO 13032
// if IsOk ( Cyrus ) then
12947: LD_EXP 25
12951: PPUSH
12952: CALL_OW 302
12956: IFFALSE 12972
// Say ( Cyrus , D5d-Cyrus-1 ) else
12958: LD_EXP 25
12962: PPUSH
12963: LD_STRING D5d-Cyrus-1
12965: PPUSH
12966: CALL_OW 88
12970: GO 13032
// if IsOk ( Gary ) then
12972: LD_EXP 32
12976: PPUSH
12977: CALL_OW 302
12981: IFFALSE 12997
// Say ( Gary , D5d-Gary-1 ) else
12983: LD_EXP 32
12987: PPUSH
12988: LD_STRING D5d-Gary-1
12990: PPUSH
12991: CALL_OW 88
12995: GO 13032
// if GetSex ( un ) = sex_male then
12997: LD_VAR 0 1
13001: PPUSH
13002: CALL_OW 258
13006: PUSH
13007: LD_INT 1
13009: EQUAL
13010: IFFALSE 13026
// Say ( un , D5d-Sol1-1 ) else
13012: LD_VAR 0 1
13016: PPUSH
13017: LD_STRING D5d-Sol1-1
13019: PPUSH
13020: CALL_OW 88
13024: GO 13032
// begin DialogueOff ;
13026: CALL_OW 7
// exit ;
13030: GO 13048
// end ; Say ( JMM , D5d-JMM-1 ) ;
13032: LD_EXP 21
13036: PPUSH
13037: LD_STRING D5d-JMM-1
13039: PPUSH
13040: CALL_OW 88
// DialogueOff ;
13044: CALL_OW 7
// end ;
13048: PPOPN 1
13050: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13051: LD_INT 1
13053: PPUSH
13054: LD_INT 17
13056: PPUSH
13057: CALL_OW 294
13061: PUSH
13062: LD_INT 2
13064: GREATEREQUAL
13065: IFFALSE 13186
13067: GO 13069
13069: DISABLE
13070: LD_INT 0
13072: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13073: LD_INT 10
13075: PPUSH
13076: LD_INT 5
13078: PPUSH
13079: LD_INT 1
13081: PPUSH
13082: LD_INT 10
13084: NEG
13085: PPUSH
13086: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13090: LD_INT 10
13092: PPUSH
13093: LD_INT 5
13095: PPUSH
13096: LD_INT 1
13098: PPUSH
13099: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
13103: LD_INT 10
13105: PPUSH
13106: LD_INT 5
13108: PPUSH
13109: CALL_OW 86
// DialogueOn ;
13113: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
13117: LD_ADDR_VAR 0 1
13121: PUSH
13122: LD_INT 1
13124: PPUSH
13125: LD_STRING D6-Sci1-1
13127: PPUSH
13128: CALL 15445 0 2
13132: ST_TO_ADDR
// if un then
13133: LD_VAR 0 1
13137: IFFALSE 13175
// begin Say ( JMM , D6-JMM-1 ) ;
13139: LD_EXP 21
13143: PPUSH
13144: LD_STRING D6-JMM-1
13146: PPUSH
13147: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
13151: LD_VAR 0 1
13155: PPUSH
13156: LD_STRING D6-Sci1-2
13158: PPUSH
13159: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
13163: LD_EXP 21
13167: PPUSH
13168: LD_STRING D6-JMM-2
13170: PPUSH
13171: CALL_OW 88
// end ; DialogueOff ;
13175: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
13179: LD_STRING M3
13181: PPUSH
13182: CALL_OW 337
// end ;
13186: PPOPN 1
13188: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp ;
13189: LD_OWVAR 1
13193: PUSH
13194: LD_INT 42000
13196: GREATEREQUAL
13197: PUSH
13198: LD_INT 2
13200: PPUSH
13201: LD_INT 169
13203: PPUSH
13204: LD_INT 90
13206: PPUSH
13207: LD_INT 10
13209: PPUSH
13210: CALL 51961 0 4
13214: PUSH
13215: LD_INT 4
13217: ARRAY
13218: PUSH
13219: LD_INT 0
13221: EQUAL
13222: PUSH
13223: LD_INT 45
13225: PPUSH
13226: CALL_OW 301
13230: OR
13231: PUSH
13232: LD_INT 45
13234: PPUSH
13235: CALL_OW 255
13239: PUSH
13240: LD_INT 1
13242: EQUAL
13243: OR
13244: AND
13245: PUSH
13246: LD_INT 94
13248: PPUSH
13249: CALL_OW 301
13253: NOT
13254: AND
13255: IFFALSE 14381
13257: GO 13259
13259: DISABLE
13260: LD_INT 0
13262: PPUSH
13263: PPUSH
13264: PPUSH
13265: PPUSH
// begin uc_side := 5 ;
13266: LD_ADDR_OWVAR 20
13270: PUSH
13271: LD_INT 5
13273: ST_TO_ADDR
// uc_nation := 2 ;
13274: LD_ADDR_OWVAR 21
13278: PUSH
13279: LD_INT 2
13281: ST_TO_ADDR
// InitHc ;
13282: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
13286: LD_INT 1
13288: PPUSH
13289: LD_INT 3
13291: PPUSH
13292: LD_INT 8
13294: PPUSH
13295: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13299: LD_ADDR_OWVAR 29
13303: PUSH
13304: LD_INT 12
13306: PUSH
13307: LD_INT 12
13309: PUSH
13310: EMPTY
13311: LIST
13312: LIST
13313: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13314: LD_ADDR_OWVAR 33
13318: PUSH
13319: LD_STRING SecondCharsGal
13321: ST_TO_ADDR
// hc_face_number := 7 ;
13322: LD_ADDR_OWVAR 34
13326: PUSH
13327: LD_INT 7
13329: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
13330: LD_ADDR_EXP 46
13334: PUSH
13335: CALL_OW 44
13339: ST_TO_ADDR
// InitHc ;
13340: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
13344: LD_INT 1
13346: PPUSH
13347: LD_INT 16
13349: PPUSH
13350: LD_INT 2
13352: PPUSH
13353: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13357: LD_ADDR_OWVAR 29
13361: PUSH
13362: LD_INT 12
13364: PUSH
13365: LD_INT 12
13367: PUSH
13368: EMPTY
13369: LIST
13370: LIST
13371: ST_TO_ADDR
// hc_name :=  ;
13372: LD_ADDR_OWVAR 26
13376: PUSH
13377: LD_STRING 
13379: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
13380: LD_ADDR_EXP 47
13384: PUSH
13385: CALL_OW 44
13389: ST_TO_ADDR
// InitHc ;
13390: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
13394: LD_INT 35
13396: PPUSH
13397: CALL_OW 67
// until not InBattle ( 1 ) ;
13401: LD_INT 1
13403: PPUSH
13404: CALL_OW 463
13408: NOT
13409: IFFALSE 13394
// wait ( 0 0$5 ) ;
13411: LD_INT 175
13413: PPUSH
13414: CALL_OW 67
// DialogueOn ;
13418: CALL_OW 6
// InGameOn ;
13422: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
13426: LD_ADDR_VAR 0 1
13430: PUSH
13431: LD_INT 22
13433: PUSH
13434: LD_INT 1
13436: PUSH
13437: EMPTY
13438: LIST
13439: LIST
13440: PUSH
13441: LD_INT 2
13443: PUSH
13444: LD_INT 25
13446: PUSH
13447: LD_INT 1
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PUSH
13454: LD_INT 25
13456: PUSH
13457: LD_INT 2
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 25
13466: PUSH
13467: LD_INT 3
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: LD_INT 25
13476: PUSH
13477: LD_INT 4
13479: PUSH
13480: EMPTY
13481: LIST
13482: LIST
13483: PUSH
13484: LD_INT 25
13486: PUSH
13487: LD_INT 5
13489: PUSH
13490: EMPTY
13491: LIST
13492: LIST
13493: PUSH
13494: LD_INT 25
13496: PUSH
13497: LD_INT 8
13499: PUSH
13500: EMPTY
13501: LIST
13502: LIST
13503: PUSH
13504: EMPTY
13505: LIST
13506: LIST
13507: LIST
13508: LIST
13509: LIST
13510: LIST
13511: LIST
13512: PUSH
13513: EMPTY
13514: LIST
13515: LIST
13516: PPUSH
13517: CALL_OW 69
13521: PUSH
13522: LD_EXP 21
13526: PUSH
13527: LD_EXP 22
13531: PUSH
13532: LD_EXP 23
13536: PUSH
13537: LD_EXP 24
13541: PUSH
13542: LD_EXP 25
13546: PUSH
13547: LD_EXP 26
13551: PUSH
13552: LD_EXP 27
13556: PUSH
13557: LD_EXP 28
13561: PUSH
13562: LD_EXP 29
13566: PUSH
13567: LD_EXP 31
13571: PUSH
13572: LD_EXP 32
13576: PUSH
13577: LD_EXP 33
13581: PUSH
13582: LD_EXP 34
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: LIST
13591: LIST
13592: LIST
13593: LIST
13594: LIST
13595: LIST
13596: LIST
13597: LIST
13598: LIST
13599: LIST
13600: LIST
13601: DIFF
13602: PPUSH
13603: LD_INT 26
13605: PUSH
13606: LD_INT 1
13608: PUSH
13609: EMPTY
13610: LIST
13611: LIST
13612: PPUSH
13613: CALL_OW 72
13617: PUSH
13618: LD_INT 1
13620: ARRAY
13621: ST_TO_ADDR
// if not un and Brown then
13622: LD_VAR 0 1
13626: NOT
13627: PUSH
13628: LD_EXP 27
13632: AND
13633: IFFALSE 13645
// un := Brown ;
13635: LD_ADDR_VAR 0 1
13639: PUSH
13640: LD_EXP 27
13644: ST_TO_ADDR
// if un then
13645: LD_VAR 0 1
13649: IFFALSE 13675
// begin Say ( un , D7-Sol1-1 ) ;
13651: LD_VAR 0 1
13655: PPUSH
13656: LD_STRING D7-Sol1-1
13658: PPUSH
13659: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
13663: LD_EXP 21
13667: PPUSH
13668: LD_STRING D7-JMM-1
13670: PPUSH
13671: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
13675: LD_EXP 46
13679: PPUSH
13680: LD_STRING D7-Ar1-1
13682: PPUSH
13683: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
13687: LD_EXP 21
13691: PPUSH
13692: LD_STRING D7-JMM-2
13694: PPUSH
13695: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
13699: LD_EXP 46
13703: PPUSH
13704: LD_STRING D7-Ar1-2
13706: PPUSH
13707: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
13711: LD_EXP 21
13715: PPUSH
13716: LD_STRING D7-JMM-3
13718: PPUSH
13719: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
13723: LD_EXP 46
13727: PPUSH
13728: LD_STRING D7-Ar1-3
13730: PPUSH
13731: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
13735: LD_EXP 21
13739: PPUSH
13740: LD_STRING D7-JMM-4
13742: PPUSH
13743: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
13747: LD_EXP 46
13751: PPUSH
13752: LD_STRING D7-Ar1-4
13754: PPUSH
13755: CALL_OW 94
// InGameOff ;
13759: CALL_OW 9
// DialogueOff ;
13763: CALL_OW 7
// case Query ( QCameras ) of 1 :
13767: LD_STRING QCameras
13769: PPUSH
13770: CALL_OW 97
13774: PUSH
13775: LD_INT 1
13777: DOUBLE
13778: EQUAL
13779: IFTRUE 13783
13781: GO 13786
13783: POP
// ; 2 :
13784: GO 13800
13786: LD_INT 2
13788: DOUBLE
13789: EQUAL
13790: IFTRUE 13794
13792: GO 13799
13794: POP
// exit ; end ;
13795: GO 14381
13797: GO 13800
13799: POP
// ChangeMissionObjectives ( MCar ) ;
13800: LD_STRING MCar
13802: PPUSH
13803: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
13807: LD_INT 124
13809: PPUSH
13810: LD_INT 90
13812: PPUSH
13813: LD_INT 1
13815: PPUSH
13816: LD_INT 6
13818: NEG
13819: PPUSH
13820: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
13824: LD_INT 124
13826: PPUSH
13827: LD_INT 90
13829: PPUSH
13830: LD_INT 1
13832: PPUSH
13833: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
13837: LD_INT 12
13839: PPUSH
13840: LD_INT 1
13842: PPUSH
13843: CALL_OW 424
// wait ( 3 ) ;
13847: LD_INT 3
13849: PPUSH
13850: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
13854: LD_INT 124
13856: PPUSH
13857: LD_INT 90
13859: PPUSH
13860: CALL_OW 86
// cargo := false ;
13864: LD_ADDR_VAR 0 3
13868: PUSH
13869: LD_INT 0
13871: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
13872: LD_INT 35
13874: PPUSH
13875: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
13879: LD_ADDR_VAR 0 3
13883: PUSH
13884: LD_INT 12
13886: PPUSH
13887: LD_INT 32
13889: PUSH
13890: LD_INT 3
13892: PUSH
13893: EMPTY
13894: LIST
13895: LIST
13896: PUSH
13897: LD_INT 34
13899: PUSH
13900: LD_INT 32
13902: PUSH
13903: EMPTY
13904: LIST
13905: LIST
13906: PUSH
13907: LD_INT 58
13909: PUSH
13910: EMPTY
13911: LIST
13912: PUSH
13913: EMPTY
13914: LIST
13915: LIST
13916: LIST
13917: PPUSH
13918: CALL_OW 70
13922: ST_TO_ADDR
// until cargo ;
13923: LD_VAR 0 3
13927: IFFALSE 13872
// cargo := cargo [ 1 ] ;
13929: LD_ADDR_VAR 0 3
13933: PUSH
13934: LD_VAR 0 3
13938: PUSH
13939: LD_INT 1
13941: ARRAY
13942: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
13943: LD_VAR 0 3
13947: PPUSH
13948: LD_INT 5
13950: PPUSH
13951: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
13955: LD_INT 12
13957: PPUSH
13958: LD_INT 0
13960: PPUSH
13961: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
13965: LD_EXP 46
13969: PPUSH
13970: LD_INT 11
13972: PPUSH
13973: LD_INT 0
13975: PPUSH
13976: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
13980: LD_EXP 47
13984: PPUSH
13985: LD_INT 11
13987: PPUSH
13988: LD_INT 0
13990: PPUSH
13991: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
13995: LD_EXP 46
13999: PUSH
14000: LD_EXP 47
14004: PUSH
14005: EMPTY
14006: LIST
14007: LIST
14008: PPUSH
14009: LD_INT 12
14011: PPUSH
14012: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14016: LD_EXP 46
14020: PPUSH
14021: LD_VAR 0 3
14025: PPUSH
14026: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14030: LD_EXP 46
14034: PUSH
14035: LD_EXP 47
14039: PUSH
14040: EMPTY
14041: LIST
14042: LIST
14043: PPUSH
14044: LD_INT 209
14046: PPUSH
14047: LD_INT 178
14049: PPUSH
14050: CALL_OW 171
// while ( true ) do
14054: LD_INT 1
14056: IFFALSE 14210
// begin wait ( 0 0$1 ) ;
14058: LD_INT 35
14060: PPUSH
14061: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14065: LD_EXP 46
14069: PPUSH
14070: CALL_OW 314
14074: NOT
14075: PUSH
14076: LD_EXP 47
14080: PPUSH
14081: CALL_OW 314
14085: NOT
14086: OR
14087: IFFALSE 14113
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14089: LD_EXP 46
14093: PUSH
14094: LD_EXP 47
14098: PUSH
14099: EMPTY
14100: LIST
14101: LIST
14102: PPUSH
14103: LD_INT 209
14105: PPUSH
14106: LD_INT 178
14108: PPUSH
14109: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
14113: LD_EXP 46
14117: PPUSH
14118: LD_INT 10
14120: PPUSH
14121: CALL_OW 308
14125: IFFALSE 14136
// RemoveUnit ( ar_mechanic ) ;
14127: LD_EXP 46
14131: PPUSH
14132: CALL_OW 64
// if IsInArea ( ar_mechanic_friend , escape_area ) then
14136: LD_EXP 47
14140: PPUSH
14141: LD_INT 10
14143: PPUSH
14144: CALL_OW 308
14148: IFFALSE 14159
// RemoveUnit ( ar_mechanic_friend ) ;
14150: LD_EXP 47
14154: PPUSH
14155: CALL_OW 64
// if IsInArea ( cargo , escape_area ) then
14159: LD_VAR 0 3
14163: PPUSH
14164: LD_INT 10
14166: PPUSH
14167: CALL_OW 308
14171: IFFALSE 14182
// RemoveUnit ( cargo ) ;
14173: LD_VAR 0 3
14177: PPUSH
14178: CALL_OW 64
// if not IsLive ( ar_mechanic ) and not IsLive ( ar_mechanic_friend ) then
14182: LD_EXP 46
14186: PPUSH
14187: CALL_OW 300
14191: NOT
14192: PUSH
14193: LD_EXP 47
14197: PPUSH
14198: CALL_OW 300
14202: NOT
14203: AND
14204: IFFALSE 14208
// break ;
14206: GO 14210
// end ;
14208: GO 14054
// wait ( 0 0$2 ) ;
14210: LD_INT 70
14212: PPUSH
14213: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
14217: LD_EXP 46
14221: PPUSH
14222: LD_STRING D7a-Ar1-1
14224: PPUSH
14225: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
14229: LD_ADDR_VAR 0 4
14233: PUSH
14234: LD_INT 129
14236: PUSH
14237: LD_INT 10
14239: PUSH
14240: EMPTY
14241: LIST
14242: LIST
14243: PUSH
14244: LD_INT 103
14246: PUSH
14247: LD_INT 6
14249: PUSH
14250: EMPTY
14251: LIST
14252: LIST
14253: PUSH
14254: LD_INT 148
14256: PUSH
14257: LD_INT 47
14259: PUSH
14260: EMPTY
14261: LIST
14262: LIST
14263: PUSH
14264: LD_INT 155
14266: PUSH
14267: LD_INT 16
14269: PUSH
14270: EMPTY
14271: LIST
14272: LIST
14273: PUSH
14274: EMPTY
14275: LIST
14276: LIST
14277: LIST
14278: LIST
14279: ST_TO_ADDR
// if Difficulty = 1 then
14280: LD_OWVAR 67
14284: PUSH
14285: LD_INT 1
14287: EQUAL
14288: IFFALSE 14325
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
14290: LD_ADDR_VAR 0 4
14294: PUSH
14295: LD_VAR 0 4
14299: PUSH
14300: LD_INT 78
14302: PUSH
14303: LD_INT 7
14305: PUSH
14306: EMPTY
14307: LIST
14308: LIST
14309: PUSH
14310: LD_INT 104
14312: PUSH
14313: LD_INT 43
14315: PUSH
14316: EMPTY
14317: LIST
14318: LIST
14319: PUSH
14320: EMPTY
14321: LIST
14322: LIST
14323: ADD
14324: ST_TO_ADDR
// for i in tmp do
14325: LD_ADDR_VAR 0 2
14329: PUSH
14330: LD_VAR 0 4
14334: PUSH
14335: FOR_IN
14336: IFFALSE 14369
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
14338: LD_VAR 0 2
14342: PUSH
14343: LD_INT 1
14345: ARRAY
14346: PPUSH
14347: LD_VAR 0 2
14351: PUSH
14352: LD_INT 2
14354: ARRAY
14355: PPUSH
14356: LD_INT 1
14358: PPUSH
14359: LD_INT 9
14361: NEG
14362: PPUSH
14363: CALL_OW 330
14367: GO 14335
14369: POP
14370: POP
// CenterOnXY ( 129 , 10 ) ;
14371: LD_INT 129
14373: PPUSH
14374: LD_INT 10
14376: PPUSH
14377: CALL_OW 84
// end ;
14381: PPOPN 4
14383: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
14384: LD_EXP 15
14388: PUSH
14389: LD_INT 21000
14391: MINUS
14392: PUSH
14393: LD_OWVAR 1
14397: LESSEQUAL
14398: IFFALSE 14438
14400: GO 14402
14402: DISABLE
// begin powell_warn := true ;
14403: LD_ADDR_EXP 16
14407: PUSH
14408: LD_INT 1
14410: ST_TO_ADDR
// DialogueOn ;
14411: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
14415: LD_EXP 30
14419: PPUSH
14420: LD_STRING D9-Pow-1
14422: PPUSH
14423: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
14427: LD_INT 10
14429: PPUSH
14430: CALL_OW 68
// DialogueOff ;
14434: CALL_OW 7
// end ;
14438: END
// every 0 0$1 trigger game_time <= tick do
14439: LD_EXP 15
14443: PUSH
14444: LD_OWVAR 1
14448: LESSEQUAL
14449: IFFALSE 14488
14451: GO 14453
14453: DISABLE
// begin DialogueOn ;
14454: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
14458: LD_EXP 30
14462: PPUSH
14463: LD_STRING D9a-Pow-1
14465: PPUSH
14466: CALL_OW 94
// dwait ( 0 0$2 ) ;
14470: LD_INT 70
14472: PPUSH
14473: CALL_OW 68
// DialogueOff ;
14477: CALL_OW 7
// YouLost ( Command ) ;
14481: LD_STRING Command
14483: PPUSH
14484: CALL_OW 104
// end ;
14488: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp ;
14489: LD_INT 22
14491: PUSH
14492: LD_INT 2
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: PUSH
14499: LD_INT 30
14501: PUSH
14502: LD_INT 1
14504: PUSH
14505: EMPTY
14506: LIST
14507: LIST
14508: PUSH
14509: EMPTY
14510: LIST
14511: LIST
14512: PPUSH
14513: CALL_OW 69
14517: PUSH
14518: LD_INT 0
14520: EQUAL
14521: PUSH
14522: LD_EXP 21
14526: PPUSH
14527: CALL_OW 302
14531: AND
14532: IFFALSE 15264
14534: GO 14536
14536: DISABLE
14537: LD_INT 0
14539: PPUSH
// begin if tick < [ 90 90$00 , 80 80$00 , 75 75$00 ] [ Difficulty ] then
14540: LD_OWVAR 1
14544: PUSH
14545: LD_INT 189000
14547: PUSH
14548: LD_INT 168000
14550: PUSH
14551: LD_INT 157500
14553: PUSH
14554: EMPTY
14555: LIST
14556: LIST
14557: LIST
14558: PUSH
14559: LD_OWVAR 67
14563: ARRAY
14564: LESS
14565: IFFALSE 14579
// AddMedal ( Time1 , 1 ) else
14567: LD_STRING Time1
14569: PPUSH
14570: LD_INT 1
14572: PPUSH
14573: CALL_OW 101
14577: GO 14610
// if not powell_warn then
14579: LD_EXP 16
14583: NOT
14584: IFFALSE 14599
// AddMedal ( Time1 , - 1 ) else
14586: LD_STRING Time1
14588: PPUSH
14589: LD_INT 1
14591: NEG
14592: PPUSH
14593: CALL_OW 101
14597: GO 14610
// AddMedal ( Time1 , - 2 ) ;
14599: LD_STRING Time1
14601: PPUSH
14602: LD_INT 2
14604: NEG
14605: PPUSH
14606: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
14610: LD_EXP 17
14614: PUSH
14615: LD_INT 5
14617: PUSH
14618: LD_INT 4
14620: PUSH
14621: LD_INT 3
14623: PUSH
14624: EMPTY
14625: LIST
14626: LIST
14627: LIST
14628: PUSH
14629: LD_OWVAR 67
14633: ARRAY
14634: GREATEREQUAL
14635: IFFALSE 14650
// AddMedal ( Destroy , - 2 ) else
14637: LD_STRING Destroy
14639: PPUSH
14640: LD_INT 2
14642: NEG
14643: PPUSH
14644: CALL_OW 101
14648: GO 14767
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
14650: LD_INT 22
14652: PUSH
14653: LD_INT 2
14655: PUSH
14656: EMPTY
14657: LIST
14658: LIST
14659: PUSH
14660: LD_INT 21
14662: PUSH
14663: LD_INT 3
14665: PUSH
14666: EMPTY
14667: LIST
14668: LIST
14669: PUSH
14670: LD_INT 50
14672: PUSH
14673: EMPTY
14674: LIST
14675: PUSH
14676: EMPTY
14677: LIST
14678: LIST
14679: LIST
14680: PPUSH
14681: CALL_OW 69
14685: PUSH
14686: LD_INT 25
14688: GREATEREQUAL
14689: IFFALSE 14704
// AddMedal ( Destroy , - 1 ) else
14691: LD_STRING Destroy
14693: PPUSH
14694: LD_INT 1
14696: NEG
14697: PPUSH
14698: CALL_OW 101
14702: GO 14767
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
14704: LD_INT 22
14706: PUSH
14707: LD_INT 2
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: PUSH
14714: LD_INT 21
14716: PUSH
14717: LD_INT 3
14719: PUSH
14720: EMPTY
14721: LIST
14722: LIST
14723: PUSH
14724: LD_INT 50
14726: PUSH
14727: EMPTY
14728: LIST
14729: PUSH
14730: EMPTY
14731: LIST
14732: LIST
14733: LIST
14734: PPUSH
14735: CALL_OW 69
14739: PUSH
14740: LD_INT 15
14742: GREATEREQUAL
14743: IFFALSE 14757
// AddMedal ( Destroy , 1 ) else
14745: LD_STRING Destroy
14747: PPUSH
14748: LD_INT 1
14750: PPUSH
14751: CALL_OW 101
14755: GO 14767
// AddMedal ( Destroy , 2 ) ;
14757: LD_STRING Destroy
14759: PPUSH
14760: LD_INT 2
14762: PPUSH
14763: CALL_OW 101
// SaveVariable ( artifact_get , 11_artifact_captured ) ;
14767: LD_EXP 13
14771: PPUSH
14772: LD_STRING 11_artifact_captured
14774: PPUSH
14775: CALL_OW 39
// if artifact_get then
14779: LD_EXP 13
14783: IFFALSE 14797
// AddMedal ( Artefact , 1 ) else
14785: LD_STRING Artefact
14787: PPUSH
14788: LD_INT 1
14790: PPUSH
14791: CALL_OW 101
14795: GO 14808
// AddMedal ( Artefact , - 1 ) ;
14797: LD_STRING Artefact
14799: PPUSH
14800: LD_INT 1
14802: NEG
14803: PPUSH
14804: CALL_OW 101
// GiveMedals ( MAIN ) ;
14808: LD_STRING MAIN
14810: PPUSH
14811: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
14815: LD_ADDR_EXP 20
14819: PUSH
14820: LD_EXP 20
14824: PPUSH
14825: LD_INT 51
14827: PUSH
14828: EMPTY
14829: LIST
14830: PPUSH
14831: CALL_OW 72
14835: ST_TO_ADDR
// tmp := JMM ^ selected ;
14836: LD_ADDR_VAR 0 1
14840: PUSH
14841: LD_EXP 21
14845: PUSH
14846: LD_EXP 20
14850: ADD
14851: ST_TO_ADDR
// RewardPeople ( tmp ) ;
14852: LD_VAR 0 1
14856: PPUSH
14857: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
14861: LD_VAR 0 1
14865: PUSH
14866: LD_EXP 21
14870: PUSH
14871: LD_EXP 22
14875: PUSH
14876: LD_EXP 23
14880: PUSH
14881: LD_EXP 24
14885: PUSH
14886: LD_EXP 25
14890: PUSH
14891: LD_EXP 26
14895: PUSH
14896: LD_EXP 27
14900: PUSH
14901: LD_EXP 28
14905: PUSH
14906: LD_EXP 29
14910: PUSH
14911: LD_EXP 31
14915: PUSH
14916: LD_EXP 32
14920: PUSH
14921: LD_EXP 33
14925: PUSH
14926: LD_EXP 34
14930: PUSH
14931: EMPTY
14932: LIST
14933: LIST
14934: LIST
14935: LIST
14936: LIST
14937: LIST
14938: LIST
14939: LIST
14940: LIST
14941: LIST
14942: LIST
14943: LIST
14944: LIST
14945: DIFF
14946: PPUSH
14947: LD_STRING 11c_others
14949: PPUSH
14950: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
14954: LD_EXP 21
14958: PPUSH
14959: LD_EXP 3
14963: PUSH
14964: LD_STRING JMM
14966: STR
14967: PPUSH
14968: CALL_OW 38
// if Lisa then
14972: LD_EXP 22
14976: IFFALSE 14996
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
14978: LD_EXP 22
14982: PPUSH
14983: LD_EXP 3
14987: PUSH
14988: LD_STRING Lisa
14990: STR
14991: PPUSH
14992: CALL_OW 38
// if Donaldson then
14996: LD_EXP 23
15000: IFFALSE 15020
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
15002: LD_EXP 23
15006: PPUSH
15007: LD_EXP 3
15011: PUSH
15012: LD_STRING Donaldson
15014: STR
15015: PPUSH
15016: CALL_OW 38
// if Bobby then
15020: LD_EXP 24
15024: IFFALSE 15044
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
15026: LD_EXP 24
15030: PPUSH
15031: LD_EXP 3
15035: PUSH
15036: LD_STRING Bobby
15038: STR
15039: PPUSH
15040: CALL_OW 38
// if Cyrus then
15044: LD_EXP 25
15048: IFFALSE 15068
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
15050: LD_EXP 25
15054: PPUSH
15055: LD_EXP 3
15059: PUSH
15060: LD_STRING Cyrus
15062: STR
15063: PPUSH
15064: CALL_OW 38
// if Denis then
15068: LD_EXP 26
15072: IFFALSE 15092
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
15074: LD_EXP 26
15078: PPUSH
15079: LD_EXP 3
15083: PUSH
15084: LD_STRING Denis
15086: STR
15087: PPUSH
15088: CALL_OW 38
// if Brown then
15092: LD_EXP 27
15096: IFFALSE 15116
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
15098: LD_EXP 27
15102: PPUSH
15103: LD_EXP 3
15107: PUSH
15108: LD_STRING Brown
15110: STR
15111: PPUSH
15112: CALL_OW 38
// if Gladstone then
15116: LD_EXP 28
15120: IFFALSE 15140
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
15122: LD_EXP 28
15126: PPUSH
15127: LD_EXP 3
15131: PUSH
15132: LD_STRING Gladstone
15134: STR
15135: PPUSH
15136: CALL_OW 38
// if Houten then
15140: LD_EXP 29
15144: IFFALSE 15164
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
15146: LD_EXP 29
15150: PPUSH
15151: LD_EXP 3
15155: PUSH
15156: LD_STRING Houten
15158: STR
15159: PPUSH
15160: CALL_OW 38
// if Cornel then
15164: LD_EXP 31
15168: IFFALSE 15188
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
15170: LD_EXP 31
15174: PPUSH
15175: LD_EXP 3
15179: PUSH
15180: LD_STRING Cornel
15182: STR
15183: PPUSH
15184: CALL_OW 38
// if Gary then
15188: LD_EXP 32
15192: IFFALSE 15212
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
15194: LD_EXP 32
15198: PPUSH
15199: LD_EXP 3
15203: PUSH
15204: LD_STRING Gary
15206: STR
15207: PPUSH
15208: CALL_OW 38
// if Frank then
15212: LD_EXP 33
15216: IFFALSE 15236
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
15218: LD_EXP 33
15222: PPUSH
15223: LD_EXP 3
15227: PUSH
15228: LD_STRING Frank
15230: STR
15231: PPUSH
15232: CALL_OW 38
// if Kikuchi then
15236: LD_EXP 34
15240: IFFALSE 15260
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
15242: LD_EXP 34
15246: PPUSH
15247: LD_EXP 3
15251: PUSH
15252: LD_STRING Kikuchi
15254: STR
15255: PPUSH
15256: CALL_OW 38
// YouWin ;
15260: CALL_OW 103
// end ;
15264: PPOPN 1
15266: END
// export function CanSayRand ( side ) ; begin
15267: LD_INT 0
15269: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15270: LD_ADDR_VAR 0 2
15274: PUSH
15275: LD_INT 52
15277: PUSH
15278: EMPTY
15279: LIST
15280: PUSH
15281: LD_INT 22
15283: PUSH
15284: LD_VAR 0 1
15288: PUSH
15289: EMPTY
15290: LIST
15291: LIST
15292: PUSH
15293: LD_INT 2
15295: PUSH
15296: LD_INT 25
15298: PUSH
15299: LD_INT 1
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: PUSH
15306: LD_INT 25
15308: PUSH
15309: LD_INT 2
15311: PUSH
15312: EMPTY
15313: LIST
15314: LIST
15315: PUSH
15316: LD_INT 25
15318: PUSH
15319: LD_INT 3
15321: PUSH
15322: EMPTY
15323: LIST
15324: LIST
15325: PUSH
15326: LD_INT 25
15328: PUSH
15329: LD_INT 4
15331: PUSH
15332: EMPTY
15333: LIST
15334: LIST
15335: PUSH
15336: EMPTY
15337: LIST
15338: LIST
15339: LIST
15340: LIST
15341: LIST
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: LIST
15347: PPUSH
15348: CALL_OW 69
15352: PUSH
15353: LD_EXP 21
15357: PUSH
15358: LD_EXP 33
15362: PUSH
15363: LD_EXP 22
15367: PUSH
15368: LD_EXP 23
15372: PUSH
15373: LD_EXP 24
15377: PUSH
15378: LD_EXP 25
15382: PUSH
15383: LD_EXP 26
15387: PUSH
15388: LD_EXP 27
15392: PUSH
15393: LD_EXP 28
15397: PUSH
15398: LD_EXP 29
15402: PUSH
15403: LD_EXP 30
15407: PUSH
15408: LD_EXP 31
15412: PUSH
15413: LD_EXP 32
15417: PUSH
15418: LD_EXP 34
15422: PUSH
15423: EMPTY
15424: LIST
15425: LIST
15426: LIST
15427: LIST
15428: LIST
15429: LIST
15430: LIST
15431: LIST
15432: LIST
15433: LIST
15434: LIST
15435: LIST
15436: LIST
15437: LIST
15438: DIFF
15439: ST_TO_ADDR
// end ;
15440: LD_VAR 0 2
15444: RET
// export function SayRand ( sex , dial ) ; begin
15445: LD_INT 0
15447: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15448: LD_ADDR_VAR 0 3
15452: PUSH
15453: LD_INT 52
15455: PUSH
15456: EMPTY
15457: LIST
15458: PUSH
15459: LD_INT 22
15461: PUSH
15462: LD_INT 1
15464: PUSH
15465: EMPTY
15466: LIST
15467: LIST
15468: PUSH
15469: LD_INT 26
15471: PUSH
15472: LD_VAR 0 1
15476: PUSH
15477: EMPTY
15478: LIST
15479: LIST
15480: PUSH
15481: LD_INT 2
15483: PUSH
15484: LD_INT 25
15486: PUSH
15487: LD_INT 1
15489: PUSH
15490: EMPTY
15491: LIST
15492: LIST
15493: PUSH
15494: LD_INT 25
15496: PUSH
15497: LD_INT 2
15499: PUSH
15500: EMPTY
15501: LIST
15502: LIST
15503: PUSH
15504: LD_INT 25
15506: PUSH
15507: LD_INT 3
15509: PUSH
15510: EMPTY
15511: LIST
15512: LIST
15513: PUSH
15514: LD_INT 25
15516: PUSH
15517: LD_INT 4
15519: PUSH
15520: EMPTY
15521: LIST
15522: LIST
15523: PUSH
15524: EMPTY
15525: LIST
15526: LIST
15527: LIST
15528: LIST
15529: LIST
15530: PUSH
15531: EMPTY
15532: LIST
15533: LIST
15534: LIST
15535: LIST
15536: PPUSH
15537: CALL_OW 69
15541: PUSH
15542: LD_EXP 21
15546: PUSH
15547: LD_EXP 33
15551: PUSH
15552: LD_EXP 22
15556: PUSH
15557: LD_EXP 23
15561: PUSH
15562: LD_EXP 24
15566: PUSH
15567: LD_EXP 25
15571: PUSH
15572: LD_EXP 26
15576: PUSH
15577: LD_EXP 27
15581: PUSH
15582: LD_EXP 28
15586: PUSH
15587: LD_EXP 29
15591: PUSH
15592: LD_EXP 30
15596: PUSH
15597: LD_EXP 31
15601: PUSH
15602: LD_EXP 32
15606: PUSH
15607: LD_EXP 34
15611: PUSH
15612: EMPTY
15613: LIST
15614: LIST
15615: LIST
15616: LIST
15617: LIST
15618: LIST
15619: LIST
15620: LIST
15621: LIST
15622: LIST
15623: LIST
15624: LIST
15625: LIST
15626: LIST
15627: DIFF
15628: ST_TO_ADDR
// if not result then
15629: LD_VAR 0 3
15633: NOT
15634: IFFALSE 15638
// exit ;
15636: GO 15666
// result := result [ 1 ] ;
15638: LD_ADDR_VAR 0 3
15642: PUSH
15643: LD_VAR 0 3
15647: PUSH
15648: LD_INT 1
15650: ARRAY
15651: ST_TO_ADDR
// Say ( result , dial ) ;
15652: LD_VAR 0 3
15656: PPUSH
15657: LD_VAR 0 2
15661: PPUSH
15662: CALL_OW 88
// end ;
15666: LD_VAR 0 3
15670: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
15671: LD_INT 0
15673: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
15674: LD_ADDR_VAR 0 4
15678: PUSH
15679: LD_INT 22
15681: PUSH
15682: LD_INT 1
15684: PUSH
15685: EMPTY
15686: LIST
15687: LIST
15688: PUSH
15689: LD_INT 26
15691: PUSH
15692: LD_VAR 0 1
15696: PUSH
15697: EMPTY
15698: LIST
15699: LIST
15700: PUSH
15701: LD_INT 2
15703: PUSH
15704: LD_INT 25
15706: PUSH
15707: LD_INT 1
15709: PUSH
15710: EMPTY
15711: LIST
15712: LIST
15713: PUSH
15714: LD_INT 25
15716: PUSH
15717: LD_INT 2
15719: PUSH
15720: EMPTY
15721: LIST
15722: LIST
15723: PUSH
15724: LD_INT 25
15726: PUSH
15727: LD_INT 3
15729: PUSH
15730: EMPTY
15731: LIST
15732: LIST
15733: PUSH
15734: LD_INT 25
15736: PUSH
15737: LD_INT 4
15739: PUSH
15740: EMPTY
15741: LIST
15742: LIST
15743: PUSH
15744: EMPTY
15745: LIST
15746: LIST
15747: LIST
15748: LIST
15749: LIST
15750: PUSH
15751: EMPTY
15752: LIST
15753: LIST
15754: LIST
15755: PPUSH
15756: CALL_OW 69
15760: PUSH
15761: LD_EXP 21
15765: PUSH
15766: LD_EXP 33
15770: PUSH
15771: LD_EXP 22
15775: PUSH
15776: LD_EXP 23
15780: PUSH
15781: LD_EXP 24
15785: PUSH
15786: LD_EXP 25
15790: PUSH
15791: LD_EXP 26
15795: PUSH
15796: LD_EXP 27
15800: PUSH
15801: LD_EXP 28
15805: PUSH
15806: LD_EXP 29
15810: PUSH
15811: LD_EXP 30
15815: PUSH
15816: LD_EXP 31
15820: PUSH
15821: LD_EXP 32
15825: PUSH
15826: LD_EXP 34
15830: PUSH
15831: EMPTY
15832: LIST
15833: LIST
15834: LIST
15835: LIST
15836: LIST
15837: LIST
15838: LIST
15839: LIST
15840: LIST
15841: LIST
15842: LIST
15843: LIST
15844: LIST
15845: LIST
15846: PUSH
15847: LD_VAR 0 3
15851: ADD
15852: DIFF
15853: ST_TO_ADDR
// if not result then
15854: LD_VAR 0 4
15858: NOT
15859: IFFALSE 15863
// exit ;
15861: GO 15891
// result := result [ 1 ] ;
15863: LD_ADDR_VAR 0 4
15867: PUSH
15868: LD_VAR 0 4
15872: PUSH
15873: LD_INT 1
15875: ARRAY
15876: ST_TO_ADDR
// Say ( result , dial ) ;
15877: LD_VAR 0 4
15881: PPUSH
15882: LD_VAR 0 2
15886: PPUSH
15887: CALL_OW 88
// end ; end_of_file
15891: LD_VAR 0 4
15895: RET
// export function CustomEvent ( event ) ; begin
15896: LD_INT 0
15898: PPUSH
// end ;
15899: LD_VAR 0 2
15903: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
15904: LD_VAR 0 1
15908: PPUSH
15909: CALL_OW 255
15913: PUSH
15914: LD_INT 1
15916: EQUAL
15917: IFFALSE 15927
// artifact_get := true ;
15919: LD_ADDR_EXP 13
15923: PUSH
15924: LD_INT 1
15926: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
15927: LD_VAR 0 1
15931: PPUSH
15932: CALL_OW 255
15936: PUSH
15937: LD_INT 2
15939: EQUAL
15940: IFFALSE 15958
// begin artifact_get := false ;
15942: LD_ADDR_EXP 13
15946: PUSH
15947: LD_INT 0
15949: ST_TO_ADDR
// artifact_stolen := true ;
15950: LD_ADDR_EXP 12
15954: PUSH
15955: LD_INT 1
15957: ST_TO_ADDR
// end ; artifact_oncargo := true ;
15958: LD_ADDR_EXP 14
15962: PUSH
15963: LD_INT 1
15965: ST_TO_ADDR
// end ;
15966: PPOPN 2
15968: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
15969: LD_ADDR_EXP 14
15973: PUSH
15974: LD_INT 0
15976: ST_TO_ADDR
// end ;
15977: PPOPN 2
15979: END
// on UnitDestroyed ( un ) do begin if un = JMM then
15980: LD_VAR 0 1
15984: PUSH
15985: LD_EXP 21
15989: EQUAL
15990: IFFALSE 16001
// begin YouLost ( JMM ) ;
15992: LD_STRING JMM
15994: PPUSH
15995: CALL_OW 104
// exit ;
15999: GO 16133
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
16001: LD_VAR 0 1
16005: PUSH
16006: LD_INT 22
16008: PUSH
16009: LD_INT 1
16011: PUSH
16012: EMPTY
16013: LIST
16014: LIST
16015: PUSH
16016: LD_INT 21
16018: PUSH
16019: LD_INT 1
16021: PUSH
16022: EMPTY
16023: LIST
16024: LIST
16025: PUSH
16026: LD_INT 2
16028: PUSH
16029: LD_INT 25
16031: PUSH
16032: LD_INT 1
16034: PUSH
16035: EMPTY
16036: LIST
16037: LIST
16038: PUSH
16039: LD_INT 25
16041: PUSH
16042: LD_INT 2
16044: PUSH
16045: EMPTY
16046: LIST
16047: LIST
16048: PUSH
16049: LD_INT 25
16051: PUSH
16052: LD_INT 3
16054: PUSH
16055: EMPTY
16056: LIST
16057: LIST
16058: PUSH
16059: LD_INT 25
16061: PUSH
16062: LD_INT 4
16064: PUSH
16065: EMPTY
16066: LIST
16067: LIST
16068: PUSH
16069: LD_INT 25
16071: PUSH
16072: LD_INT 5
16074: PUSH
16075: EMPTY
16076: LIST
16077: LIST
16078: PUSH
16079: LD_INT 25
16081: PUSH
16082: LD_INT 8
16084: PUSH
16085: EMPTY
16086: LIST
16087: LIST
16088: PUSH
16089: EMPTY
16090: LIST
16091: LIST
16092: LIST
16093: LIST
16094: LIST
16095: LIST
16096: LIST
16097: PUSH
16098: EMPTY
16099: LIST
16100: LIST
16101: LIST
16102: PPUSH
16103: CALL_OW 69
16107: IN
16108: IFFALSE 16124
// loses_counter := loses_counter + 1 ;
16110: LD_ADDR_EXP 17
16114: PUSH
16115: LD_EXP 17
16119: PUSH
16120: LD_INT 1
16122: PLUS
16123: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
16124: LD_VAR 0 1
16128: PPUSH
16129: CALL 41786 0 1
// end ;
16133: PPOPN 1
16135: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16136: LD_VAR 0 1
16140: PPUSH
16141: LD_VAR 0 2
16145: PPUSH
16146: CALL 43692 0 2
// end ;
16150: PPOPN 2
16152: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
16153: LD_VAR 0 1
16157: PPUSH
16158: CALL 43001 0 1
// end ;
16162: PPOPN 1
16164: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16165: LD_VAR 0 1
16169: PPUSH
16170: LD_VAR 0 2
16174: PPUSH
16175: LD_VAR 0 3
16179: PPUSH
16180: LD_VAR 0 4
16184: PPUSH
16185: LD_VAR 0 5
16189: PPUSH
16190: CALL 41102 0 5
// end ;
16194: PPOPN 5
16196: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
16197: LD_VAR 0 1
16201: PPUSH
16202: LD_VAR 0 2
16206: PPUSH
16207: CALL 40692 0 2
// end ;
16211: PPOPN 2
16213: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
16214: LD_VAR 0 1
16218: PPUSH
16219: CALL_OW 247
16223: PUSH
16224: LD_INT 2
16226: EQUAL
16227: IFFALSE 16231
// exit ;
16229: GO 16248
// if not kamikazed then
16231: LD_EXP 11
16235: NOT
16236: IFFALSE 16248
// kamikazed := unit ;
16238: LD_ADDR_EXP 11
16242: PUSH
16243: LD_VAR 0 1
16247: ST_TO_ADDR
// end ;
16248: PPOPN 1
16250: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
16251: LD_INT 0
16253: PPUSH
16254: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
16255: LD_VAR 0 1
16259: PPUSH
16260: LD_VAR 0 2
16264: PPUSH
16265: LD_VAR 0 3
16269: PPUSH
16270: LD_VAR 0 4
16274: PPUSH
16275: CALL 40530 0 4
// end ;
16279: PPOPN 6
16281: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
16282: LD_VAR 0 1
16286: PPUSH
16287: LD_VAR 0 2
16291: PPUSH
16292: LD_VAR 0 3
16296: PPUSH
16297: CALL 40305 0 3
// end ;
16301: PPOPN 3
16303: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
16304: LD_VAR 0 1
16308: PPUSH
16309: LD_VAR 0 2
16313: PPUSH
16314: CALL 41482 0 2
// end ;
16318: PPOPN 2
16320: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
16321: LD_VAR 0 1
16325: PPUSH
16326: LD_VAR 0 2
16330: PPUSH
16331: CALL 39999 0 2
// end ;
16335: PPOPN 2
16337: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
16338: LD_VAR 0 1
16342: PPUSH
16343: LD_VAR 0 2
16347: PPUSH
16348: CALL 40190 0 2
// end ;
16352: PPOPN 2
16354: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
16355: LD_VAR 0 1
16359: PPUSH
16360: CALL 42760 0 1
// end ;
16364: PPOPN 1
16366: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
16367: LD_VAR 0 1
16371: PPUSH
16372: LD_VAR 0 2
16376: PPUSH
16377: CALL 43953 0 2
// end ;
16381: PPOPN 2
16383: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
16384: LD_VAR 0 1
16388: PPUSH
16389: LD_VAR 0 2
16393: PPUSH
16394: LD_VAR 0 3
16398: PPUSH
16399: LD_VAR 0 4
16403: PPUSH
16404: CALL 44169 0 4
// end ; end_of_file
16408: PPOPN 4
16410: END
// every 0 0$1 trigger game do
16411: LD_EXP 2
16415: IFFALSE 16445
16417: GO 16419
16419: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
16420: LD_INT 7
16422: PUSH
16423: LD_INT 6
16425: PUSH
16426: LD_INT 4
16428: PUSH
16429: LD_INT 6
16431: PUSH
16432: EMPTY
16433: LIST
16434: LIST
16435: LIST
16436: LIST
16437: PPUSH
16438: LD_INT 1750
16440: PPUSH
16441: CALL 16446 0 2
16445: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
16446: LD_INT 0
16448: PPUSH
16449: PPUSH
16450: PPUSH
// if not areas then
16451: LD_VAR 0 1
16455: NOT
16456: IFFALSE 16460
// exit ;
16458: GO 16590
// repeat wait ( time ) ;
16460: LD_VAR 0 2
16464: PPUSH
16465: CALL_OW 67
// p := rand ( 1 , 90 ) ;
16469: LD_ADDR_VAR 0 5
16473: PUSH
16474: LD_INT 1
16476: PPUSH
16477: LD_INT 90
16479: PPUSH
16480: CALL_OW 12
16484: ST_TO_ADDR
// for i in areas do
16485: LD_ADDR_VAR 0 4
16489: PUSH
16490: LD_VAR 0 1
16494: PUSH
16495: FOR_IN
16496: IFFALSE 16549
// begin if Prob ( p ) then
16498: LD_VAR 0 5
16502: PPUSH
16503: CALL_OW 13
16507: IFFALSE 16547
// begin CreateCratesArea ( rand ( 1 , 5 ) , i , true ) ;
16509: LD_INT 1
16511: PPUSH
16512: LD_INT 5
16514: PPUSH
16515: CALL_OW 12
16519: PPUSH
16520: LD_VAR 0 4
16524: PPUSH
16525: LD_INT 1
16527: PPUSH
16528: CALL_OW 55
// wait ( rand ( 0 0$11 , 0 0$17 ) ) ;
16532: LD_INT 385
16534: PPUSH
16535: LD_INT 595
16537: PPUSH
16538: CALL_OW 12
16542: PPUSH
16543: CALL_OW 67
// end ; end ;
16547: GO 16495
16549: POP
16550: POP
// time := time + 0 0$3 ;
16551: LD_ADDR_VAR 0 2
16555: PUSH
16556: LD_VAR 0 2
16560: PUSH
16561: LD_INT 105
16563: PLUS
16564: ST_TO_ADDR
// if time > 7 7$00 then
16565: LD_VAR 0 2
16569: PUSH
16570: LD_INT 14700
16572: GREATER
16573: IFFALSE 16583
// time := 0 0$40 ;
16575: LD_ADDR_VAR 0 2
16579: PUSH
16580: LD_INT 1400
16582: ST_TO_ADDR
// until not game ;
16583: LD_EXP 2
16587: NOT
16588: IFFALSE 16460
// end ; end_of_file
16590: LD_VAR 0 3
16594: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
16595: LD_INT 0
16597: PPUSH
16598: PPUSH
// skirmish := false ;
16599: LD_ADDR_EXP 48
16603: PUSH
16604: LD_INT 0
16606: ST_TO_ADDR
// debug_mc := false ;
16607: LD_ADDR_EXP 49
16611: PUSH
16612: LD_INT 0
16614: ST_TO_ADDR
// mc_bases := [ ] ;
16615: LD_ADDR_EXP 50
16619: PUSH
16620: EMPTY
16621: ST_TO_ADDR
// mc_sides := [ ] ;
16622: LD_ADDR_EXP 76
16626: PUSH
16627: EMPTY
16628: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
16629: LD_ADDR_EXP 51
16633: PUSH
16634: EMPTY
16635: ST_TO_ADDR
// mc_building_repairs := [ ] ;
16636: LD_ADDR_EXP 52
16640: PUSH
16641: EMPTY
16642: ST_TO_ADDR
// mc_need_heal := [ ] ;
16643: LD_ADDR_EXP 53
16647: PUSH
16648: EMPTY
16649: ST_TO_ADDR
// mc_healers := [ ] ;
16650: LD_ADDR_EXP 54
16654: PUSH
16655: EMPTY
16656: ST_TO_ADDR
// mc_build_list := [ ] ;
16657: LD_ADDR_EXP 55
16661: PUSH
16662: EMPTY
16663: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
16664: LD_ADDR_EXP 82
16668: PUSH
16669: EMPTY
16670: ST_TO_ADDR
// mc_builders := [ ] ;
16671: LD_ADDR_EXP 56
16675: PUSH
16676: EMPTY
16677: ST_TO_ADDR
// mc_construct_list := [ ] ;
16678: LD_ADDR_EXP 57
16682: PUSH
16683: EMPTY
16684: ST_TO_ADDR
// mc_turret_list := [ ] ;
16685: LD_ADDR_EXP 58
16689: PUSH
16690: EMPTY
16691: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
16692: LD_ADDR_EXP 59
16696: PUSH
16697: EMPTY
16698: ST_TO_ADDR
// mc_miners := [ ] ;
16699: LD_ADDR_EXP 64
16703: PUSH
16704: EMPTY
16705: ST_TO_ADDR
// mc_mines := [ ] ;
16706: LD_ADDR_EXP 63
16710: PUSH
16711: EMPTY
16712: ST_TO_ADDR
// mc_minefields := [ ] ;
16713: LD_ADDR_EXP 65
16717: PUSH
16718: EMPTY
16719: ST_TO_ADDR
// mc_crates := [ ] ;
16720: LD_ADDR_EXP 66
16724: PUSH
16725: EMPTY
16726: ST_TO_ADDR
// mc_crates_collector := [ ] ;
16727: LD_ADDR_EXP 67
16731: PUSH
16732: EMPTY
16733: ST_TO_ADDR
// mc_crates_area := [ ] ;
16734: LD_ADDR_EXP 68
16738: PUSH
16739: EMPTY
16740: ST_TO_ADDR
// mc_vehicles := [ ] ;
16741: LD_ADDR_EXP 69
16745: PUSH
16746: EMPTY
16747: ST_TO_ADDR
// mc_attack := [ ] ;
16748: LD_ADDR_EXP 70
16752: PUSH
16753: EMPTY
16754: ST_TO_ADDR
// mc_produce := [ ] ;
16755: LD_ADDR_EXP 71
16759: PUSH
16760: EMPTY
16761: ST_TO_ADDR
// mc_defender := [ ] ;
16762: LD_ADDR_EXP 72
16766: PUSH
16767: EMPTY
16768: ST_TO_ADDR
// mc_parking := [ ] ;
16769: LD_ADDR_EXP 74
16773: PUSH
16774: EMPTY
16775: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
16776: LD_ADDR_EXP 60
16780: PUSH
16781: EMPTY
16782: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
16783: LD_ADDR_EXP 62
16787: PUSH
16788: EMPTY
16789: ST_TO_ADDR
// mc_scan := [ ] ;
16790: LD_ADDR_EXP 73
16794: PUSH
16795: EMPTY
16796: ST_TO_ADDR
// mc_scan_area := [ ] ;
16797: LD_ADDR_EXP 75
16801: PUSH
16802: EMPTY
16803: ST_TO_ADDR
// mc_tech := [ ] ;
16804: LD_ADDR_EXP 77
16808: PUSH
16809: EMPTY
16810: ST_TO_ADDR
// mc_class := [ ] ;
16811: LD_ADDR_EXP 91
16815: PUSH
16816: EMPTY
16817: ST_TO_ADDR
// mc_class_case_use := [ ] ;
16818: LD_ADDR_EXP 92
16822: PUSH
16823: EMPTY
16824: ST_TO_ADDR
// end ;
16825: LD_VAR 0 1
16829: RET
// export function MC_Kill ( base ) ; begin
16830: LD_INT 0
16832: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
16833: LD_ADDR_EXP 50
16837: PUSH
16838: LD_EXP 50
16842: PPUSH
16843: LD_VAR 0 1
16847: PPUSH
16848: EMPTY
16849: PPUSH
16850: CALL_OW 1
16854: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
16855: LD_ADDR_EXP 51
16859: PUSH
16860: LD_EXP 51
16864: PPUSH
16865: LD_VAR 0 1
16869: PPUSH
16870: EMPTY
16871: PPUSH
16872: CALL_OW 1
16876: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
16877: LD_ADDR_EXP 52
16881: PUSH
16882: LD_EXP 52
16886: PPUSH
16887: LD_VAR 0 1
16891: PPUSH
16892: EMPTY
16893: PPUSH
16894: CALL_OW 1
16898: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
16899: LD_ADDR_EXP 53
16903: PUSH
16904: LD_EXP 53
16908: PPUSH
16909: LD_VAR 0 1
16913: PPUSH
16914: EMPTY
16915: PPUSH
16916: CALL_OW 1
16920: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
16921: LD_ADDR_EXP 54
16925: PUSH
16926: LD_EXP 54
16930: PPUSH
16931: LD_VAR 0 1
16935: PPUSH
16936: EMPTY
16937: PPUSH
16938: CALL_OW 1
16942: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
16943: LD_ADDR_EXP 55
16947: PUSH
16948: LD_EXP 55
16952: PPUSH
16953: LD_VAR 0 1
16957: PPUSH
16958: EMPTY
16959: PPUSH
16960: CALL_OW 1
16964: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
16965: LD_ADDR_EXP 56
16969: PUSH
16970: LD_EXP 56
16974: PPUSH
16975: LD_VAR 0 1
16979: PPUSH
16980: EMPTY
16981: PPUSH
16982: CALL_OW 1
16986: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
16987: LD_ADDR_EXP 57
16991: PUSH
16992: LD_EXP 57
16996: PPUSH
16997: LD_VAR 0 1
17001: PPUSH
17002: EMPTY
17003: PPUSH
17004: CALL_OW 1
17008: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
17009: LD_ADDR_EXP 58
17013: PUSH
17014: LD_EXP 58
17018: PPUSH
17019: LD_VAR 0 1
17023: PPUSH
17024: EMPTY
17025: PPUSH
17026: CALL_OW 1
17030: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
17031: LD_ADDR_EXP 59
17035: PUSH
17036: LD_EXP 59
17040: PPUSH
17041: LD_VAR 0 1
17045: PPUSH
17046: EMPTY
17047: PPUSH
17048: CALL_OW 1
17052: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
17053: LD_ADDR_EXP 60
17057: PUSH
17058: LD_EXP 60
17062: PPUSH
17063: LD_VAR 0 1
17067: PPUSH
17068: EMPTY
17069: PPUSH
17070: CALL_OW 1
17074: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
17075: LD_ADDR_EXP 61
17079: PUSH
17080: LD_EXP 61
17084: PPUSH
17085: LD_VAR 0 1
17089: PPUSH
17090: LD_INT 0
17092: PPUSH
17093: CALL_OW 1
17097: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
17098: LD_ADDR_EXP 62
17102: PUSH
17103: LD_EXP 62
17107: PPUSH
17108: LD_VAR 0 1
17112: PPUSH
17113: EMPTY
17114: PPUSH
17115: CALL_OW 1
17119: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
17120: LD_ADDR_EXP 63
17124: PUSH
17125: LD_EXP 63
17129: PPUSH
17130: LD_VAR 0 1
17134: PPUSH
17135: EMPTY
17136: PPUSH
17137: CALL_OW 1
17141: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
17142: LD_ADDR_EXP 64
17146: PUSH
17147: LD_EXP 64
17151: PPUSH
17152: LD_VAR 0 1
17156: PPUSH
17157: EMPTY
17158: PPUSH
17159: CALL_OW 1
17163: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
17164: LD_ADDR_EXP 65
17168: PUSH
17169: LD_EXP 65
17173: PPUSH
17174: LD_VAR 0 1
17178: PPUSH
17179: EMPTY
17180: PPUSH
17181: CALL_OW 1
17185: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
17186: LD_ADDR_EXP 66
17190: PUSH
17191: LD_EXP 66
17195: PPUSH
17196: LD_VAR 0 1
17200: PPUSH
17201: EMPTY
17202: PPUSH
17203: CALL_OW 1
17207: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
17208: LD_ADDR_EXP 67
17212: PUSH
17213: LD_EXP 67
17217: PPUSH
17218: LD_VAR 0 1
17222: PPUSH
17223: EMPTY
17224: PPUSH
17225: CALL_OW 1
17229: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
17230: LD_ADDR_EXP 68
17234: PUSH
17235: LD_EXP 68
17239: PPUSH
17240: LD_VAR 0 1
17244: PPUSH
17245: EMPTY
17246: PPUSH
17247: CALL_OW 1
17251: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
17252: LD_ADDR_EXP 69
17256: PUSH
17257: LD_EXP 69
17261: PPUSH
17262: LD_VAR 0 1
17266: PPUSH
17267: EMPTY
17268: PPUSH
17269: CALL_OW 1
17273: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
17274: LD_ADDR_EXP 70
17278: PUSH
17279: LD_EXP 70
17283: PPUSH
17284: LD_VAR 0 1
17288: PPUSH
17289: EMPTY
17290: PPUSH
17291: CALL_OW 1
17295: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
17296: LD_ADDR_EXP 71
17300: PUSH
17301: LD_EXP 71
17305: PPUSH
17306: LD_VAR 0 1
17310: PPUSH
17311: EMPTY
17312: PPUSH
17313: CALL_OW 1
17317: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
17318: LD_ADDR_EXP 72
17322: PUSH
17323: LD_EXP 72
17327: PPUSH
17328: LD_VAR 0 1
17332: PPUSH
17333: EMPTY
17334: PPUSH
17335: CALL_OW 1
17339: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
17340: LD_ADDR_EXP 73
17344: PUSH
17345: LD_EXP 73
17349: PPUSH
17350: LD_VAR 0 1
17354: PPUSH
17355: EMPTY
17356: PPUSH
17357: CALL_OW 1
17361: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
17362: LD_ADDR_EXP 74
17366: PUSH
17367: LD_EXP 74
17371: PPUSH
17372: LD_VAR 0 1
17376: PPUSH
17377: EMPTY
17378: PPUSH
17379: CALL_OW 1
17383: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
17384: LD_ADDR_EXP 75
17388: PUSH
17389: LD_EXP 75
17393: PPUSH
17394: LD_VAR 0 1
17398: PPUSH
17399: EMPTY
17400: PPUSH
17401: CALL_OW 1
17405: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
17406: LD_ADDR_EXP 77
17410: PUSH
17411: LD_EXP 77
17415: PPUSH
17416: LD_VAR 0 1
17420: PPUSH
17421: EMPTY
17422: PPUSH
17423: CALL_OW 1
17427: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
17428: LD_ADDR_EXP 79
17432: PUSH
17433: LD_EXP 79
17437: PPUSH
17438: LD_VAR 0 1
17442: PPUSH
17443: EMPTY
17444: PPUSH
17445: CALL_OW 1
17449: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
17450: LD_ADDR_EXP 80
17454: PUSH
17455: LD_EXP 80
17459: PPUSH
17460: LD_VAR 0 1
17464: PPUSH
17465: EMPTY
17466: PPUSH
17467: CALL_OW 1
17471: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
17472: LD_ADDR_EXP 81
17476: PUSH
17477: LD_EXP 81
17481: PPUSH
17482: LD_VAR 0 1
17486: PPUSH
17487: EMPTY
17488: PPUSH
17489: CALL_OW 1
17493: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
17494: LD_ADDR_EXP 82
17498: PUSH
17499: LD_EXP 82
17503: PPUSH
17504: LD_VAR 0 1
17508: PPUSH
17509: EMPTY
17510: PPUSH
17511: CALL_OW 1
17515: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
17516: LD_ADDR_EXP 83
17520: PUSH
17521: LD_EXP 83
17525: PPUSH
17526: LD_VAR 0 1
17530: PPUSH
17531: EMPTY
17532: PPUSH
17533: CALL_OW 1
17537: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
17538: LD_ADDR_EXP 84
17542: PUSH
17543: LD_EXP 84
17547: PPUSH
17548: LD_VAR 0 1
17552: PPUSH
17553: EMPTY
17554: PPUSH
17555: CALL_OW 1
17559: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
17560: LD_ADDR_EXP 85
17564: PUSH
17565: LD_EXP 85
17569: PPUSH
17570: LD_VAR 0 1
17574: PPUSH
17575: EMPTY
17576: PPUSH
17577: CALL_OW 1
17581: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
17582: LD_ADDR_EXP 86
17586: PUSH
17587: LD_EXP 86
17591: PPUSH
17592: LD_VAR 0 1
17596: PPUSH
17597: EMPTY
17598: PPUSH
17599: CALL_OW 1
17603: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
17604: LD_ADDR_EXP 87
17608: PUSH
17609: LD_EXP 87
17613: PPUSH
17614: LD_VAR 0 1
17618: PPUSH
17619: EMPTY
17620: PPUSH
17621: CALL_OW 1
17625: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
17626: LD_ADDR_EXP 88
17630: PUSH
17631: LD_EXP 88
17635: PPUSH
17636: LD_VAR 0 1
17640: PPUSH
17641: EMPTY
17642: PPUSH
17643: CALL_OW 1
17647: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
17648: LD_ADDR_EXP 89
17652: PUSH
17653: LD_EXP 89
17657: PPUSH
17658: LD_VAR 0 1
17662: PPUSH
17663: EMPTY
17664: PPUSH
17665: CALL_OW 1
17669: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
17670: LD_ADDR_EXP 90
17674: PUSH
17675: LD_EXP 90
17679: PPUSH
17680: LD_VAR 0 1
17684: PPUSH
17685: EMPTY
17686: PPUSH
17687: CALL_OW 1
17691: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
17692: LD_ADDR_EXP 91
17696: PUSH
17697: LD_EXP 91
17701: PPUSH
17702: LD_VAR 0 1
17706: PPUSH
17707: EMPTY
17708: PPUSH
17709: CALL_OW 1
17713: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
17714: LD_ADDR_EXP 92
17718: PUSH
17719: LD_EXP 92
17723: PPUSH
17724: LD_VAR 0 1
17728: PPUSH
17729: LD_INT 0
17731: PPUSH
17732: CALL_OW 1
17736: ST_TO_ADDR
// end ;
17737: LD_VAR 0 2
17741: RET
// export function MC_Start ( ) ; var i ; begin
17742: LD_INT 0
17744: PPUSH
17745: PPUSH
// for i = 1 to mc_bases do
17746: LD_ADDR_VAR 0 2
17750: PUSH
17751: DOUBLE
17752: LD_INT 1
17754: DEC
17755: ST_TO_ADDR
17756: LD_EXP 50
17760: PUSH
17761: FOR_TO
17762: IFFALSE 18839
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
17764: LD_ADDR_EXP 50
17768: PUSH
17769: LD_EXP 50
17773: PPUSH
17774: LD_VAR 0 2
17778: PPUSH
17779: LD_EXP 50
17783: PUSH
17784: LD_VAR 0 2
17788: ARRAY
17789: PUSH
17790: LD_INT 0
17792: DIFF
17793: PPUSH
17794: CALL_OW 1
17798: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
17799: LD_ADDR_EXP 51
17803: PUSH
17804: LD_EXP 51
17808: PPUSH
17809: LD_VAR 0 2
17813: PPUSH
17814: EMPTY
17815: PPUSH
17816: CALL_OW 1
17820: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
17821: LD_ADDR_EXP 52
17825: PUSH
17826: LD_EXP 52
17830: PPUSH
17831: LD_VAR 0 2
17835: PPUSH
17836: EMPTY
17837: PPUSH
17838: CALL_OW 1
17842: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
17843: LD_ADDR_EXP 53
17847: PUSH
17848: LD_EXP 53
17852: PPUSH
17853: LD_VAR 0 2
17857: PPUSH
17858: EMPTY
17859: PPUSH
17860: CALL_OW 1
17864: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
17865: LD_ADDR_EXP 54
17869: PUSH
17870: LD_EXP 54
17874: PPUSH
17875: LD_VAR 0 2
17879: PPUSH
17880: EMPTY
17881: PUSH
17882: EMPTY
17883: PUSH
17884: EMPTY
17885: LIST
17886: LIST
17887: PPUSH
17888: CALL_OW 1
17892: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
17893: LD_ADDR_EXP 55
17897: PUSH
17898: LD_EXP 55
17902: PPUSH
17903: LD_VAR 0 2
17907: PPUSH
17908: EMPTY
17909: PPUSH
17910: CALL_OW 1
17914: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
17915: LD_ADDR_EXP 82
17919: PUSH
17920: LD_EXP 82
17924: PPUSH
17925: LD_VAR 0 2
17929: PPUSH
17930: EMPTY
17931: PPUSH
17932: CALL_OW 1
17936: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
17937: LD_ADDR_EXP 56
17941: PUSH
17942: LD_EXP 56
17946: PPUSH
17947: LD_VAR 0 2
17951: PPUSH
17952: EMPTY
17953: PPUSH
17954: CALL_OW 1
17958: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
17959: LD_ADDR_EXP 57
17963: PUSH
17964: LD_EXP 57
17968: PPUSH
17969: LD_VAR 0 2
17973: PPUSH
17974: EMPTY
17975: PPUSH
17976: CALL_OW 1
17980: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
17981: LD_ADDR_EXP 58
17985: PUSH
17986: LD_EXP 58
17990: PPUSH
17991: LD_VAR 0 2
17995: PPUSH
17996: LD_EXP 50
18000: PUSH
18001: LD_VAR 0 2
18005: ARRAY
18006: PPUSH
18007: LD_INT 2
18009: PUSH
18010: LD_INT 30
18012: PUSH
18013: LD_INT 32
18015: PUSH
18016: EMPTY
18017: LIST
18018: LIST
18019: PUSH
18020: LD_INT 30
18022: PUSH
18023: LD_INT 33
18025: PUSH
18026: EMPTY
18027: LIST
18028: LIST
18029: PUSH
18030: EMPTY
18031: LIST
18032: LIST
18033: LIST
18034: PPUSH
18035: CALL_OW 72
18039: PPUSH
18040: CALL_OW 1
18044: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
18045: LD_ADDR_EXP 59
18049: PUSH
18050: LD_EXP 59
18054: PPUSH
18055: LD_VAR 0 2
18059: PPUSH
18060: LD_EXP 50
18064: PUSH
18065: LD_VAR 0 2
18069: ARRAY
18070: PPUSH
18071: LD_INT 2
18073: PUSH
18074: LD_INT 30
18076: PUSH
18077: LD_INT 32
18079: PUSH
18080: EMPTY
18081: LIST
18082: LIST
18083: PUSH
18084: LD_INT 30
18086: PUSH
18087: LD_INT 31
18089: PUSH
18090: EMPTY
18091: LIST
18092: LIST
18093: PUSH
18094: EMPTY
18095: LIST
18096: LIST
18097: LIST
18098: PUSH
18099: LD_INT 58
18101: PUSH
18102: EMPTY
18103: LIST
18104: PUSH
18105: EMPTY
18106: LIST
18107: LIST
18108: PPUSH
18109: CALL_OW 72
18113: PPUSH
18114: CALL_OW 1
18118: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
18119: LD_ADDR_EXP 60
18123: PUSH
18124: LD_EXP 60
18128: PPUSH
18129: LD_VAR 0 2
18133: PPUSH
18134: EMPTY
18135: PPUSH
18136: CALL_OW 1
18140: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
18141: LD_ADDR_EXP 64
18145: PUSH
18146: LD_EXP 64
18150: PPUSH
18151: LD_VAR 0 2
18155: PPUSH
18156: EMPTY
18157: PPUSH
18158: CALL_OW 1
18162: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
18163: LD_ADDR_EXP 63
18167: PUSH
18168: LD_EXP 63
18172: PPUSH
18173: LD_VAR 0 2
18177: PPUSH
18178: EMPTY
18179: PPUSH
18180: CALL_OW 1
18184: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
18185: LD_ADDR_EXP 65
18189: PUSH
18190: LD_EXP 65
18194: PPUSH
18195: LD_VAR 0 2
18199: PPUSH
18200: EMPTY
18201: PPUSH
18202: CALL_OW 1
18206: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
18207: LD_ADDR_EXP 66
18211: PUSH
18212: LD_EXP 66
18216: PPUSH
18217: LD_VAR 0 2
18221: PPUSH
18222: EMPTY
18223: PPUSH
18224: CALL_OW 1
18228: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
18229: LD_ADDR_EXP 67
18233: PUSH
18234: LD_EXP 67
18238: PPUSH
18239: LD_VAR 0 2
18243: PPUSH
18244: EMPTY
18245: PPUSH
18246: CALL_OW 1
18250: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
18251: LD_ADDR_EXP 68
18255: PUSH
18256: LD_EXP 68
18260: PPUSH
18261: LD_VAR 0 2
18265: PPUSH
18266: EMPTY
18267: PPUSH
18268: CALL_OW 1
18272: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
18273: LD_ADDR_EXP 69
18277: PUSH
18278: LD_EXP 69
18282: PPUSH
18283: LD_VAR 0 2
18287: PPUSH
18288: EMPTY
18289: PPUSH
18290: CALL_OW 1
18294: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
18295: LD_ADDR_EXP 70
18299: PUSH
18300: LD_EXP 70
18304: PPUSH
18305: LD_VAR 0 2
18309: PPUSH
18310: EMPTY
18311: PPUSH
18312: CALL_OW 1
18316: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
18317: LD_ADDR_EXP 71
18321: PUSH
18322: LD_EXP 71
18326: PPUSH
18327: LD_VAR 0 2
18331: PPUSH
18332: EMPTY
18333: PPUSH
18334: CALL_OW 1
18338: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
18339: LD_ADDR_EXP 72
18343: PUSH
18344: LD_EXP 72
18348: PPUSH
18349: LD_VAR 0 2
18353: PPUSH
18354: EMPTY
18355: PPUSH
18356: CALL_OW 1
18360: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
18361: LD_ADDR_EXP 61
18365: PUSH
18366: LD_EXP 61
18370: PPUSH
18371: LD_VAR 0 2
18375: PPUSH
18376: LD_INT 0
18378: PPUSH
18379: CALL_OW 1
18383: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
18384: LD_ADDR_EXP 74
18388: PUSH
18389: LD_EXP 74
18393: PPUSH
18394: LD_VAR 0 2
18398: PPUSH
18399: LD_INT 0
18401: PPUSH
18402: CALL_OW 1
18406: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
18407: LD_ADDR_EXP 62
18411: PUSH
18412: LD_EXP 62
18416: PPUSH
18417: LD_VAR 0 2
18421: PPUSH
18422: EMPTY
18423: PPUSH
18424: CALL_OW 1
18428: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
18429: LD_ADDR_EXP 73
18433: PUSH
18434: LD_EXP 73
18438: PPUSH
18439: LD_VAR 0 2
18443: PPUSH
18444: LD_INT 0
18446: PPUSH
18447: CALL_OW 1
18451: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
18452: LD_ADDR_EXP 75
18456: PUSH
18457: LD_EXP 75
18461: PPUSH
18462: LD_VAR 0 2
18466: PPUSH
18467: EMPTY
18468: PPUSH
18469: CALL_OW 1
18473: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
18474: LD_ADDR_EXP 78
18478: PUSH
18479: LD_EXP 78
18483: PPUSH
18484: LD_VAR 0 2
18488: PPUSH
18489: LD_INT 0
18491: PPUSH
18492: CALL_OW 1
18496: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
18497: LD_ADDR_EXP 79
18501: PUSH
18502: LD_EXP 79
18506: PPUSH
18507: LD_VAR 0 2
18511: PPUSH
18512: EMPTY
18513: PPUSH
18514: CALL_OW 1
18518: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
18519: LD_ADDR_EXP 80
18523: PUSH
18524: LD_EXP 80
18528: PPUSH
18529: LD_VAR 0 2
18533: PPUSH
18534: EMPTY
18535: PPUSH
18536: CALL_OW 1
18540: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
18541: LD_ADDR_EXP 81
18545: PUSH
18546: LD_EXP 81
18550: PPUSH
18551: LD_VAR 0 2
18555: PPUSH
18556: EMPTY
18557: PPUSH
18558: CALL_OW 1
18562: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
18563: LD_ADDR_EXP 83
18567: PUSH
18568: LD_EXP 83
18572: PPUSH
18573: LD_VAR 0 2
18577: PPUSH
18578: LD_EXP 50
18582: PUSH
18583: LD_VAR 0 2
18587: ARRAY
18588: PPUSH
18589: LD_INT 2
18591: PUSH
18592: LD_INT 30
18594: PUSH
18595: LD_INT 6
18597: PUSH
18598: EMPTY
18599: LIST
18600: LIST
18601: PUSH
18602: LD_INT 30
18604: PUSH
18605: LD_INT 7
18607: PUSH
18608: EMPTY
18609: LIST
18610: LIST
18611: PUSH
18612: LD_INT 30
18614: PUSH
18615: LD_INT 8
18617: PUSH
18618: EMPTY
18619: LIST
18620: LIST
18621: PUSH
18622: EMPTY
18623: LIST
18624: LIST
18625: LIST
18626: LIST
18627: PPUSH
18628: CALL_OW 72
18632: PPUSH
18633: CALL_OW 1
18637: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
18638: LD_ADDR_EXP 84
18642: PUSH
18643: LD_EXP 84
18647: PPUSH
18648: LD_VAR 0 2
18652: PPUSH
18653: EMPTY
18654: PPUSH
18655: CALL_OW 1
18659: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
18660: LD_ADDR_EXP 85
18664: PUSH
18665: LD_EXP 85
18669: PPUSH
18670: LD_VAR 0 2
18674: PPUSH
18675: EMPTY
18676: PPUSH
18677: CALL_OW 1
18681: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
18682: LD_ADDR_EXP 86
18686: PUSH
18687: LD_EXP 86
18691: PPUSH
18692: LD_VAR 0 2
18696: PPUSH
18697: EMPTY
18698: PPUSH
18699: CALL_OW 1
18703: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
18704: LD_ADDR_EXP 87
18708: PUSH
18709: LD_EXP 87
18713: PPUSH
18714: LD_VAR 0 2
18718: PPUSH
18719: EMPTY
18720: PPUSH
18721: CALL_OW 1
18725: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
18726: LD_ADDR_EXP 88
18730: PUSH
18731: LD_EXP 88
18735: PPUSH
18736: LD_VAR 0 2
18740: PPUSH
18741: EMPTY
18742: PPUSH
18743: CALL_OW 1
18747: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
18748: LD_ADDR_EXP 89
18752: PUSH
18753: LD_EXP 89
18757: PPUSH
18758: LD_VAR 0 2
18762: PPUSH
18763: EMPTY
18764: PPUSH
18765: CALL_OW 1
18769: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
18770: LD_ADDR_EXP 90
18774: PUSH
18775: LD_EXP 90
18779: PPUSH
18780: LD_VAR 0 2
18784: PPUSH
18785: EMPTY
18786: PPUSH
18787: CALL_OW 1
18791: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
18792: LD_ADDR_EXP 91
18796: PUSH
18797: LD_EXP 91
18801: PPUSH
18802: LD_VAR 0 2
18806: PPUSH
18807: EMPTY
18808: PPUSH
18809: CALL_OW 1
18813: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
18814: LD_ADDR_EXP 92
18818: PUSH
18819: LD_EXP 92
18823: PPUSH
18824: LD_VAR 0 2
18828: PPUSH
18829: LD_INT 0
18831: PPUSH
18832: CALL_OW 1
18836: ST_TO_ADDR
// end ;
18837: GO 17761
18839: POP
18840: POP
// MC_InitSides ( ) ;
18841: CALL 19127 0 0
// MC_InitResearch ( ) ;
18845: CALL 18866 0 0
// CustomInitMacro ( ) ;
18849: CALL 285 0 0
// skirmish := true ;
18853: LD_ADDR_EXP 48
18857: PUSH
18858: LD_INT 1
18860: ST_TO_ADDR
// end ;
18861: LD_VAR 0 1
18865: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
18866: LD_INT 0
18868: PPUSH
18869: PPUSH
18870: PPUSH
18871: PPUSH
18872: PPUSH
18873: PPUSH
// if not mc_bases then
18874: LD_EXP 50
18878: NOT
18879: IFFALSE 18883
// exit ;
18881: GO 19122
// for i = 1 to 8 do
18883: LD_ADDR_VAR 0 2
18887: PUSH
18888: DOUBLE
18889: LD_INT 1
18891: DEC
18892: ST_TO_ADDR
18893: LD_INT 8
18895: PUSH
18896: FOR_TO
18897: IFFALSE 18923
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
18899: LD_ADDR_EXP 77
18903: PUSH
18904: LD_EXP 77
18908: PPUSH
18909: LD_VAR 0 2
18913: PPUSH
18914: EMPTY
18915: PPUSH
18916: CALL_OW 1
18920: ST_TO_ADDR
18921: GO 18896
18923: POP
18924: POP
// tmp := [ ] ;
18925: LD_ADDR_VAR 0 5
18929: PUSH
18930: EMPTY
18931: ST_TO_ADDR
// for i = 1 to mc_sides do
18932: LD_ADDR_VAR 0 2
18936: PUSH
18937: DOUBLE
18938: LD_INT 1
18940: DEC
18941: ST_TO_ADDR
18942: LD_EXP 76
18946: PUSH
18947: FOR_TO
18948: IFFALSE 19006
// if not mc_sides [ i ] in tmp then
18950: LD_EXP 76
18954: PUSH
18955: LD_VAR 0 2
18959: ARRAY
18960: PUSH
18961: LD_VAR 0 5
18965: IN
18966: NOT
18967: IFFALSE 19004
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
18969: LD_ADDR_VAR 0 5
18973: PUSH
18974: LD_VAR 0 5
18978: PPUSH
18979: LD_VAR 0 5
18983: PUSH
18984: LD_INT 1
18986: PLUS
18987: PPUSH
18988: LD_EXP 76
18992: PUSH
18993: LD_VAR 0 2
18997: ARRAY
18998: PPUSH
18999: CALL_OW 2
19003: ST_TO_ADDR
19004: GO 18947
19006: POP
19007: POP
// if not tmp then
19008: LD_VAR 0 5
19012: NOT
19013: IFFALSE 19017
// exit ;
19015: GO 19122
// for j in tmp do
19017: LD_ADDR_VAR 0 3
19021: PUSH
19022: LD_VAR 0 5
19026: PUSH
19027: FOR_IN
19028: IFFALSE 19120
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
19030: LD_ADDR_VAR 0 6
19034: PUSH
19035: LD_INT 22
19037: PUSH
19038: LD_VAR 0 3
19042: PUSH
19043: EMPTY
19044: LIST
19045: LIST
19046: PPUSH
19047: CALL_OW 69
19051: ST_TO_ADDR
// if not un then
19052: LD_VAR 0 6
19056: NOT
19057: IFFALSE 19061
// continue ;
19059: GO 19027
// nation := GetNation ( un [ 1 ] ) ;
19061: LD_ADDR_VAR 0 4
19065: PUSH
19066: LD_VAR 0 6
19070: PUSH
19071: LD_INT 1
19073: ARRAY
19074: PPUSH
19075: CALL_OW 248
19079: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
19080: LD_ADDR_EXP 77
19084: PUSH
19085: LD_EXP 77
19089: PPUSH
19090: LD_VAR 0 3
19094: PPUSH
19095: LD_VAR 0 3
19099: PPUSH
19100: LD_VAR 0 4
19104: PPUSH
19105: LD_INT 1
19107: PPUSH
19108: CALL 44373 0 3
19112: PPUSH
19113: CALL_OW 1
19117: ST_TO_ADDR
// end ;
19118: GO 19027
19120: POP
19121: POP
// end ;
19122: LD_VAR 0 1
19126: RET
// export function MC_InitSides ( ) ; var i ; begin
19127: LD_INT 0
19129: PPUSH
19130: PPUSH
// if not mc_bases then
19131: LD_EXP 50
19135: NOT
19136: IFFALSE 19140
// exit ;
19138: GO 19214
// for i = 1 to mc_bases do
19140: LD_ADDR_VAR 0 2
19144: PUSH
19145: DOUBLE
19146: LD_INT 1
19148: DEC
19149: ST_TO_ADDR
19150: LD_EXP 50
19154: PUSH
19155: FOR_TO
19156: IFFALSE 19212
// if mc_bases [ i ] then
19158: LD_EXP 50
19162: PUSH
19163: LD_VAR 0 2
19167: ARRAY
19168: IFFALSE 19210
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
19170: LD_ADDR_EXP 76
19174: PUSH
19175: LD_EXP 76
19179: PPUSH
19180: LD_VAR 0 2
19184: PPUSH
19185: LD_EXP 50
19189: PUSH
19190: LD_VAR 0 2
19194: ARRAY
19195: PUSH
19196: LD_INT 1
19198: ARRAY
19199: PPUSH
19200: CALL_OW 255
19204: PPUSH
19205: CALL_OW 1
19209: ST_TO_ADDR
19210: GO 19155
19212: POP
19213: POP
// end ;
19214: LD_VAR 0 1
19218: RET
// every 0 0$01 trigger skirmish do
19219: LD_EXP 48
19223: IFFALSE 19377
19225: GO 19227
19227: DISABLE
// begin enable ;
19228: ENABLE
// MC_CheckBuildings ( ) ;
19229: CALL 23543 0 0
// MC_CheckPeopleLife ( ) ;
19233: CALL 23668 0 0
// RaiseSailEvent ( 100 ) ;
19237: LD_INT 100
19239: PPUSH
19240: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
19244: LD_INT 103
19246: PPUSH
19247: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
19251: LD_INT 104
19253: PPUSH
19254: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
19258: LD_INT 105
19260: PPUSH
19261: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
19265: LD_INT 106
19267: PPUSH
19268: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
19272: LD_INT 107
19274: PPUSH
19275: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
19279: LD_INT 108
19281: PPUSH
19282: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
19286: LD_INT 109
19288: PPUSH
19289: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
19293: LD_INT 110
19295: PPUSH
19296: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
19300: LD_INT 111
19302: PPUSH
19303: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
19307: LD_INT 112
19309: PPUSH
19310: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
19314: LD_INT 113
19316: PPUSH
19317: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
19321: LD_INT 120
19323: PPUSH
19324: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
19328: LD_INT 121
19330: PPUSH
19331: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
19335: LD_INT 122
19337: PPUSH
19338: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
19342: LD_INT 123
19344: PPUSH
19345: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
19349: LD_INT 124
19351: PPUSH
19352: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
19356: LD_INT 125
19358: PPUSH
19359: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
19363: LD_INT 126
19365: PPUSH
19366: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
19370: LD_INT 200
19372: PPUSH
19373: CALL_OW 427
// end ;
19377: END
// on SailEvent ( event ) do begin if event < 100 then
19378: LD_VAR 0 1
19382: PUSH
19383: LD_INT 100
19385: LESS
19386: IFFALSE 19397
// CustomEvent ( event ) ;
19388: LD_VAR 0 1
19392: PPUSH
19393: CALL 15896 0 1
// if event = 100 then
19397: LD_VAR 0 1
19401: PUSH
19402: LD_INT 100
19404: EQUAL
19405: IFFALSE 19411
// MC_ClassManager ( ) ;
19407: CALL 19803 0 0
// if event = 101 then
19411: LD_VAR 0 1
19415: PUSH
19416: LD_INT 101
19418: EQUAL
19419: IFFALSE 19425
// MC_RepairBuildings ( ) ;
19421: CALL 24264 0 0
// if event = 102 then
19425: LD_VAR 0 1
19429: PUSH
19430: LD_INT 102
19432: EQUAL
19433: IFFALSE 19439
// MC_Heal ( ) ;
19435: CALL 24670 0 0
// if event = 103 then
19439: LD_VAR 0 1
19443: PUSH
19444: LD_INT 103
19446: EQUAL
19447: IFFALSE 19453
// MC_Build ( ) ;
19449: CALL 25092 0 0
// if event = 104 then
19453: LD_VAR 0 1
19457: PUSH
19458: LD_INT 104
19460: EQUAL
19461: IFFALSE 19467
// MC_TurretWeapon ( ) ;
19463: CALL 26705 0 0
// if event = 105 then
19467: LD_VAR 0 1
19471: PUSH
19472: LD_INT 105
19474: EQUAL
19475: IFFALSE 19481
// MC_BuildUpgrade ( ) ;
19477: CALL 26256 0 0
// if event = 106 then
19481: LD_VAR 0 1
19485: PUSH
19486: LD_INT 106
19488: EQUAL
19489: IFFALSE 19495
// MC_PlantMines ( ) ;
19491: CALL 27135 0 0
// if event = 107 then
19495: LD_VAR 0 1
19499: PUSH
19500: LD_INT 107
19502: EQUAL
19503: IFFALSE 19509
// MC_CollectCrates ( ) ;
19505: CALL 28169 0 0
// if event = 108 then
19509: LD_VAR 0 1
19513: PUSH
19514: LD_INT 108
19516: EQUAL
19517: IFFALSE 19523
// MC_LinkRemoteControl ( ) ;
19519: CALL 29926 0 0
// if event = 109 then
19523: LD_VAR 0 1
19527: PUSH
19528: LD_INT 109
19530: EQUAL
19531: IFFALSE 19537
// MC_ProduceVehicle ( ) ;
19533: CALL 30107 0 0
// if event = 110 then
19537: LD_VAR 0 1
19541: PUSH
19542: LD_INT 110
19544: EQUAL
19545: IFFALSE 19551
// MC_SendAttack ( ) ;
19547: CALL 30588 0 0
// if event = 111 then
19551: LD_VAR 0 1
19555: PUSH
19556: LD_INT 111
19558: EQUAL
19559: IFFALSE 19565
// MC_Defend ( ) ;
19561: CALL 30696 0 0
// if event = 112 then
19565: LD_VAR 0 1
19569: PUSH
19570: LD_INT 112
19572: EQUAL
19573: IFFALSE 19579
// MC_Research ( ) ;
19575: CALL 31323 0 0
// if event = 113 then
19579: LD_VAR 0 1
19583: PUSH
19584: LD_INT 113
19586: EQUAL
19587: IFFALSE 19593
// MC_MinesTrigger ( ) ;
19589: CALL 32437 0 0
// if event = 120 then
19593: LD_VAR 0 1
19597: PUSH
19598: LD_INT 120
19600: EQUAL
19601: IFFALSE 19607
// MC_RepairVehicle ( ) ;
19603: CALL 32536 0 0
// if event = 121 then
19607: LD_VAR 0 1
19611: PUSH
19612: LD_INT 121
19614: EQUAL
19615: IFFALSE 19621
// MC_TameApe ( ) ;
19617: CALL 33279 0 0
// if event = 122 then
19621: LD_VAR 0 1
19625: PUSH
19626: LD_INT 122
19628: EQUAL
19629: IFFALSE 19635
// MC_ChangeApeClass ( ) ;
19631: CALL 34108 0 0
// if event = 123 then
19635: LD_VAR 0 1
19639: PUSH
19640: LD_INT 123
19642: EQUAL
19643: IFFALSE 19649
// MC_Bazooka ( ) ;
19645: CALL 34758 0 0
// if event = 124 then
19649: LD_VAR 0 1
19653: PUSH
19654: LD_INT 124
19656: EQUAL
19657: IFFALSE 19663
// MC_TeleportExit ( ) ;
19659: CALL 34956 0 0
// if event = 125 then
19663: LD_VAR 0 1
19667: PUSH
19668: LD_INT 125
19670: EQUAL
19671: IFFALSE 19677
// MC_Deposits ( ) ;
19673: CALL 35603 0 0
// if event = 126 then
19677: LD_VAR 0 1
19681: PUSH
19682: LD_INT 126
19684: EQUAL
19685: IFFALSE 19691
// MC_RemoteDriver ( ) ;
19687: CALL 36228 0 0
// if event = 200 then
19691: LD_VAR 0 1
19695: PUSH
19696: LD_INT 200
19698: EQUAL
19699: IFFALSE 19705
// MC_Idle ( ) ;
19701: CALL 37961 0 0
// end ;
19705: PPOPN 1
19707: END
// export function MC_Reset ( base , tag ) ; var i ; begin
19708: LD_INT 0
19710: PPUSH
19711: PPUSH
// if not mc_bases [ base ] or not tag then
19712: LD_EXP 50
19716: PUSH
19717: LD_VAR 0 1
19721: ARRAY
19722: NOT
19723: PUSH
19724: LD_VAR 0 2
19728: NOT
19729: OR
19730: IFFALSE 19734
// exit ;
19732: GO 19798
// for i in mc_bases [ base ] union mc_ape [ base ] do
19734: LD_ADDR_VAR 0 4
19738: PUSH
19739: LD_EXP 50
19743: PUSH
19744: LD_VAR 0 1
19748: ARRAY
19749: PUSH
19750: LD_EXP 79
19754: PUSH
19755: LD_VAR 0 1
19759: ARRAY
19760: UNION
19761: PUSH
19762: FOR_IN
19763: IFFALSE 19796
// if GetTag ( i ) = tag then
19765: LD_VAR 0 4
19769: PPUSH
19770: CALL_OW 110
19774: PUSH
19775: LD_VAR 0 2
19779: EQUAL
19780: IFFALSE 19794
// SetTag ( i , 0 ) ;
19782: LD_VAR 0 4
19786: PPUSH
19787: LD_INT 0
19789: PPUSH
19790: CALL_OW 109
19794: GO 19762
19796: POP
19797: POP
// end ;
19798: LD_VAR 0 3
19802: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
19803: LD_INT 0
19805: PPUSH
19806: PPUSH
19807: PPUSH
19808: PPUSH
19809: PPUSH
19810: PPUSH
19811: PPUSH
19812: PPUSH
// if not mc_bases then
19813: LD_EXP 50
19817: NOT
19818: IFFALSE 19822
// exit ;
19820: GO 20280
// for i = 1 to mc_bases do
19822: LD_ADDR_VAR 0 2
19826: PUSH
19827: DOUBLE
19828: LD_INT 1
19830: DEC
19831: ST_TO_ADDR
19832: LD_EXP 50
19836: PUSH
19837: FOR_TO
19838: IFFALSE 20278
// begin tmp := MC_ClassCheckReq ( i ) ;
19840: LD_ADDR_VAR 0 4
19844: PUSH
19845: LD_VAR 0 2
19849: PPUSH
19850: CALL 20285 0 1
19854: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
19855: LD_ADDR_EXP 91
19859: PUSH
19860: LD_EXP 91
19864: PPUSH
19865: LD_VAR 0 2
19869: PPUSH
19870: LD_VAR 0 4
19874: PPUSH
19875: CALL_OW 1
19879: ST_TO_ADDR
// if not tmp then
19880: LD_VAR 0 4
19884: NOT
19885: IFFALSE 19889
// continue ;
19887: GO 19837
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
19889: LD_ADDR_VAR 0 6
19893: PUSH
19894: LD_EXP 50
19898: PUSH
19899: LD_VAR 0 2
19903: ARRAY
19904: PPUSH
19905: LD_INT 2
19907: PUSH
19908: LD_INT 30
19910: PUSH
19911: LD_INT 4
19913: PUSH
19914: EMPTY
19915: LIST
19916: LIST
19917: PUSH
19918: LD_INT 30
19920: PUSH
19921: LD_INT 5
19923: PUSH
19924: EMPTY
19925: LIST
19926: LIST
19927: PUSH
19928: EMPTY
19929: LIST
19930: LIST
19931: LIST
19932: PPUSH
19933: CALL_OW 72
19937: PUSH
19938: LD_EXP 50
19942: PUSH
19943: LD_VAR 0 2
19947: ARRAY
19948: PPUSH
19949: LD_INT 2
19951: PUSH
19952: LD_INT 30
19954: PUSH
19955: LD_INT 0
19957: PUSH
19958: EMPTY
19959: LIST
19960: LIST
19961: PUSH
19962: LD_INT 30
19964: PUSH
19965: LD_INT 1
19967: PUSH
19968: EMPTY
19969: LIST
19970: LIST
19971: PUSH
19972: EMPTY
19973: LIST
19974: LIST
19975: LIST
19976: PPUSH
19977: CALL_OW 72
19981: PUSH
19982: LD_EXP 50
19986: PUSH
19987: LD_VAR 0 2
19991: ARRAY
19992: PPUSH
19993: LD_INT 30
19995: PUSH
19996: LD_INT 3
19998: PUSH
19999: EMPTY
20000: LIST
20001: LIST
20002: PPUSH
20003: CALL_OW 72
20007: PUSH
20008: LD_EXP 50
20012: PUSH
20013: LD_VAR 0 2
20017: ARRAY
20018: PPUSH
20019: LD_INT 2
20021: PUSH
20022: LD_INT 30
20024: PUSH
20025: LD_INT 6
20027: PUSH
20028: EMPTY
20029: LIST
20030: LIST
20031: PUSH
20032: LD_INT 30
20034: PUSH
20035: LD_INT 7
20037: PUSH
20038: EMPTY
20039: LIST
20040: LIST
20041: PUSH
20042: LD_INT 30
20044: PUSH
20045: LD_INT 8
20047: PUSH
20048: EMPTY
20049: LIST
20050: LIST
20051: PUSH
20052: EMPTY
20053: LIST
20054: LIST
20055: LIST
20056: LIST
20057: PPUSH
20058: CALL_OW 72
20062: PUSH
20063: EMPTY
20064: LIST
20065: LIST
20066: LIST
20067: LIST
20068: ST_TO_ADDR
// for j = 1 to 4 do
20069: LD_ADDR_VAR 0 3
20073: PUSH
20074: DOUBLE
20075: LD_INT 1
20077: DEC
20078: ST_TO_ADDR
20079: LD_INT 4
20081: PUSH
20082: FOR_TO
20083: IFFALSE 20274
// begin if not tmp [ j ] then
20085: LD_VAR 0 4
20089: PUSH
20090: LD_VAR 0 3
20094: ARRAY
20095: NOT
20096: IFFALSE 20100
// continue ;
20098: GO 20082
// for p in tmp [ j ] do
20100: LD_ADDR_VAR 0 5
20104: PUSH
20105: LD_VAR 0 4
20109: PUSH
20110: LD_VAR 0 3
20114: ARRAY
20115: PUSH
20116: FOR_IN
20117: IFFALSE 20270
// begin if not b [ j ] then
20119: LD_VAR 0 6
20123: PUSH
20124: LD_VAR 0 3
20128: ARRAY
20129: NOT
20130: IFFALSE 20134
// break ;
20132: GO 20270
// e := 0 ;
20134: LD_ADDR_VAR 0 7
20138: PUSH
20139: LD_INT 0
20141: ST_TO_ADDR
// for k in b [ j ] do
20142: LD_ADDR_VAR 0 8
20146: PUSH
20147: LD_VAR 0 6
20151: PUSH
20152: LD_VAR 0 3
20156: ARRAY
20157: PUSH
20158: FOR_IN
20159: IFFALSE 20186
// if IsNotFull ( k ) then
20161: LD_VAR 0 8
20165: PPUSH
20166: CALL 48399 0 1
20170: IFFALSE 20184
// begin e := k ;
20172: LD_ADDR_VAR 0 7
20176: PUSH
20177: LD_VAR 0 8
20181: ST_TO_ADDR
// break ;
20182: GO 20186
// end ;
20184: GO 20158
20186: POP
20187: POP
// if e and not UnitGoingToBuilding ( p , e ) then
20188: LD_VAR 0 7
20192: PUSH
20193: LD_VAR 0 5
20197: PPUSH
20198: LD_VAR 0 7
20202: PPUSH
20203: CALL 85387 0 2
20207: NOT
20208: AND
20209: IFFALSE 20268
// begin if IsInUnit ( p ) then
20211: LD_VAR 0 5
20215: PPUSH
20216: CALL_OW 310
20220: IFFALSE 20231
// ComExitBuilding ( p ) ;
20222: LD_VAR 0 5
20226: PPUSH
20227: CALL_OW 122
// ComEnterUnit ( p , e ) ;
20231: LD_VAR 0 5
20235: PPUSH
20236: LD_VAR 0 7
20240: PPUSH
20241: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
20245: LD_VAR 0 5
20249: PPUSH
20250: LD_VAR 0 3
20254: PPUSH
20255: CALL_OW 183
// AddComExitBuilding ( p ) ;
20259: LD_VAR 0 5
20263: PPUSH
20264: CALL_OW 182
// end ; end ;
20268: GO 20116
20270: POP
20271: POP
// end ;
20272: GO 20082
20274: POP
20275: POP
// end ;
20276: GO 19837
20278: POP
20279: POP
// end ;
20280: LD_VAR 0 1
20284: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
20285: LD_INT 0
20287: PPUSH
20288: PPUSH
20289: PPUSH
20290: PPUSH
20291: PPUSH
20292: PPUSH
20293: PPUSH
20294: PPUSH
20295: PPUSH
20296: PPUSH
20297: PPUSH
20298: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
20299: LD_VAR 0 1
20303: NOT
20304: PUSH
20305: LD_EXP 50
20309: PUSH
20310: LD_VAR 0 1
20314: ARRAY
20315: NOT
20316: OR
20317: PUSH
20318: LD_EXP 50
20322: PUSH
20323: LD_VAR 0 1
20327: ARRAY
20328: PPUSH
20329: LD_INT 2
20331: PUSH
20332: LD_INT 30
20334: PUSH
20335: LD_INT 0
20337: PUSH
20338: EMPTY
20339: LIST
20340: LIST
20341: PUSH
20342: LD_INT 30
20344: PUSH
20345: LD_INT 1
20347: PUSH
20348: EMPTY
20349: LIST
20350: LIST
20351: PUSH
20352: EMPTY
20353: LIST
20354: LIST
20355: LIST
20356: PPUSH
20357: CALL_OW 72
20361: NOT
20362: OR
20363: IFFALSE 20367
// exit ;
20365: GO 23538
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
20367: LD_ADDR_VAR 0 4
20371: PUSH
20372: LD_EXP 50
20376: PUSH
20377: LD_VAR 0 1
20381: ARRAY
20382: PPUSH
20383: LD_INT 2
20385: PUSH
20386: LD_INT 25
20388: PUSH
20389: LD_INT 1
20391: PUSH
20392: EMPTY
20393: LIST
20394: LIST
20395: PUSH
20396: LD_INT 25
20398: PUSH
20399: LD_INT 2
20401: PUSH
20402: EMPTY
20403: LIST
20404: LIST
20405: PUSH
20406: LD_INT 25
20408: PUSH
20409: LD_INT 3
20411: PUSH
20412: EMPTY
20413: LIST
20414: LIST
20415: PUSH
20416: LD_INT 25
20418: PUSH
20419: LD_INT 4
20421: PUSH
20422: EMPTY
20423: LIST
20424: LIST
20425: PUSH
20426: LD_INT 25
20428: PUSH
20429: LD_INT 5
20431: PUSH
20432: EMPTY
20433: LIST
20434: LIST
20435: PUSH
20436: LD_INT 25
20438: PUSH
20439: LD_INT 8
20441: PUSH
20442: EMPTY
20443: LIST
20444: LIST
20445: PUSH
20446: LD_INT 25
20448: PUSH
20449: LD_INT 9
20451: PUSH
20452: EMPTY
20453: LIST
20454: LIST
20455: PUSH
20456: EMPTY
20457: LIST
20458: LIST
20459: LIST
20460: LIST
20461: LIST
20462: LIST
20463: LIST
20464: LIST
20465: PPUSH
20466: CALL_OW 72
20470: ST_TO_ADDR
// for i in tmp do
20471: LD_ADDR_VAR 0 3
20475: PUSH
20476: LD_VAR 0 4
20480: PUSH
20481: FOR_IN
20482: IFFALSE 20513
// if GetTag ( i ) then
20484: LD_VAR 0 3
20488: PPUSH
20489: CALL_OW 110
20493: IFFALSE 20511
// tmp := tmp diff i ;
20495: LD_ADDR_VAR 0 4
20499: PUSH
20500: LD_VAR 0 4
20504: PUSH
20505: LD_VAR 0 3
20509: DIFF
20510: ST_TO_ADDR
20511: GO 20481
20513: POP
20514: POP
// if not tmp then
20515: LD_VAR 0 4
20519: NOT
20520: IFFALSE 20524
// exit ;
20522: GO 23538
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
20524: LD_ADDR_VAR 0 5
20528: PUSH
20529: LD_EXP 50
20533: PUSH
20534: LD_VAR 0 1
20538: ARRAY
20539: PPUSH
20540: LD_INT 2
20542: PUSH
20543: LD_INT 25
20545: PUSH
20546: LD_INT 1
20548: PUSH
20549: EMPTY
20550: LIST
20551: LIST
20552: PUSH
20553: LD_INT 25
20555: PUSH
20556: LD_INT 5
20558: PUSH
20559: EMPTY
20560: LIST
20561: LIST
20562: PUSH
20563: LD_INT 25
20565: PUSH
20566: LD_INT 8
20568: PUSH
20569: EMPTY
20570: LIST
20571: LIST
20572: PUSH
20573: LD_INT 25
20575: PUSH
20576: LD_INT 9
20578: PUSH
20579: EMPTY
20580: LIST
20581: LIST
20582: PUSH
20583: EMPTY
20584: LIST
20585: LIST
20586: LIST
20587: LIST
20588: LIST
20589: PPUSH
20590: CALL_OW 72
20594: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
20595: LD_ADDR_VAR 0 6
20599: PUSH
20600: LD_EXP 50
20604: PUSH
20605: LD_VAR 0 1
20609: ARRAY
20610: PPUSH
20611: LD_INT 25
20613: PUSH
20614: LD_INT 2
20616: PUSH
20617: EMPTY
20618: LIST
20619: LIST
20620: PPUSH
20621: CALL_OW 72
20625: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
20626: LD_ADDR_VAR 0 7
20630: PUSH
20631: LD_EXP 50
20635: PUSH
20636: LD_VAR 0 1
20640: ARRAY
20641: PPUSH
20642: LD_INT 25
20644: PUSH
20645: LD_INT 3
20647: PUSH
20648: EMPTY
20649: LIST
20650: LIST
20651: PPUSH
20652: CALL_OW 72
20656: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
20657: LD_ADDR_VAR 0 8
20661: PUSH
20662: LD_EXP 50
20666: PUSH
20667: LD_VAR 0 1
20671: ARRAY
20672: PPUSH
20673: LD_INT 25
20675: PUSH
20676: LD_INT 4
20678: PUSH
20679: EMPTY
20680: LIST
20681: LIST
20682: PUSH
20683: LD_INT 24
20685: PUSH
20686: LD_INT 251
20688: PUSH
20689: EMPTY
20690: LIST
20691: LIST
20692: PUSH
20693: EMPTY
20694: LIST
20695: LIST
20696: PPUSH
20697: CALL_OW 72
20701: ST_TO_ADDR
// if mc_scan [ base ] then
20702: LD_EXP 73
20706: PUSH
20707: LD_VAR 0 1
20711: ARRAY
20712: IFFALSE 21173
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
20714: LD_ADDR_EXP 92
20718: PUSH
20719: LD_EXP 92
20723: PPUSH
20724: LD_VAR 0 1
20728: PPUSH
20729: LD_INT 4
20731: PPUSH
20732: CALL_OW 1
20736: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
20737: LD_ADDR_VAR 0 12
20741: PUSH
20742: LD_EXP 50
20746: PUSH
20747: LD_VAR 0 1
20751: ARRAY
20752: PPUSH
20753: LD_INT 2
20755: PUSH
20756: LD_INT 30
20758: PUSH
20759: LD_INT 4
20761: PUSH
20762: EMPTY
20763: LIST
20764: LIST
20765: PUSH
20766: LD_INT 30
20768: PUSH
20769: LD_INT 5
20771: PUSH
20772: EMPTY
20773: LIST
20774: LIST
20775: PUSH
20776: EMPTY
20777: LIST
20778: LIST
20779: LIST
20780: PPUSH
20781: CALL_OW 72
20785: ST_TO_ADDR
// if not b then
20786: LD_VAR 0 12
20790: NOT
20791: IFFALSE 20795
// exit ;
20793: GO 23538
// p := [ ] ;
20795: LD_ADDR_VAR 0 11
20799: PUSH
20800: EMPTY
20801: ST_TO_ADDR
// if sci >= 2 then
20802: LD_VAR 0 8
20806: PUSH
20807: LD_INT 2
20809: GREATEREQUAL
20810: IFFALSE 20841
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
20812: LD_ADDR_VAR 0 8
20816: PUSH
20817: LD_VAR 0 8
20821: PUSH
20822: LD_INT 1
20824: ARRAY
20825: PUSH
20826: LD_VAR 0 8
20830: PUSH
20831: LD_INT 2
20833: ARRAY
20834: PUSH
20835: EMPTY
20836: LIST
20837: LIST
20838: ST_TO_ADDR
20839: GO 20902
// if sci = 1 then
20841: LD_VAR 0 8
20845: PUSH
20846: LD_INT 1
20848: EQUAL
20849: IFFALSE 20870
// sci := [ sci [ 1 ] ] else
20851: LD_ADDR_VAR 0 8
20855: PUSH
20856: LD_VAR 0 8
20860: PUSH
20861: LD_INT 1
20863: ARRAY
20864: PUSH
20865: EMPTY
20866: LIST
20867: ST_TO_ADDR
20868: GO 20902
// if sci = 0 then
20870: LD_VAR 0 8
20874: PUSH
20875: LD_INT 0
20877: EQUAL
20878: IFFALSE 20902
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
20880: LD_ADDR_VAR 0 11
20884: PUSH
20885: LD_VAR 0 4
20889: PPUSH
20890: LD_INT 4
20892: PPUSH
20893: CALL 85250 0 2
20897: PUSH
20898: LD_INT 1
20900: ARRAY
20901: ST_TO_ADDR
// if eng > 4 then
20902: LD_VAR 0 6
20906: PUSH
20907: LD_INT 4
20909: GREATER
20910: IFFALSE 20956
// for i = eng downto 4 do
20912: LD_ADDR_VAR 0 3
20916: PUSH
20917: DOUBLE
20918: LD_VAR 0 6
20922: INC
20923: ST_TO_ADDR
20924: LD_INT 4
20926: PUSH
20927: FOR_DOWNTO
20928: IFFALSE 20954
// eng := eng diff eng [ i ] ;
20930: LD_ADDR_VAR 0 6
20934: PUSH
20935: LD_VAR 0 6
20939: PUSH
20940: LD_VAR 0 6
20944: PUSH
20945: LD_VAR 0 3
20949: ARRAY
20950: DIFF
20951: ST_TO_ADDR
20952: GO 20927
20954: POP
20955: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
20956: LD_ADDR_VAR 0 4
20960: PUSH
20961: LD_VAR 0 4
20965: PUSH
20966: LD_VAR 0 5
20970: PUSH
20971: LD_VAR 0 6
20975: UNION
20976: PUSH
20977: LD_VAR 0 7
20981: UNION
20982: PUSH
20983: LD_VAR 0 8
20987: UNION
20988: DIFF
20989: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
20990: LD_ADDR_VAR 0 13
20994: PUSH
20995: LD_EXP 50
20999: PUSH
21000: LD_VAR 0 1
21004: ARRAY
21005: PPUSH
21006: LD_INT 2
21008: PUSH
21009: LD_INT 30
21011: PUSH
21012: LD_INT 32
21014: PUSH
21015: EMPTY
21016: LIST
21017: LIST
21018: PUSH
21019: LD_INT 30
21021: PUSH
21022: LD_INT 31
21024: PUSH
21025: EMPTY
21026: LIST
21027: LIST
21028: PUSH
21029: EMPTY
21030: LIST
21031: LIST
21032: LIST
21033: PPUSH
21034: CALL_OW 72
21038: PUSH
21039: LD_EXP 50
21043: PUSH
21044: LD_VAR 0 1
21048: ARRAY
21049: PPUSH
21050: LD_INT 2
21052: PUSH
21053: LD_INT 30
21055: PUSH
21056: LD_INT 4
21058: PUSH
21059: EMPTY
21060: LIST
21061: LIST
21062: PUSH
21063: LD_INT 30
21065: PUSH
21066: LD_INT 5
21068: PUSH
21069: EMPTY
21070: LIST
21071: LIST
21072: PUSH
21073: EMPTY
21074: LIST
21075: LIST
21076: LIST
21077: PPUSH
21078: CALL_OW 72
21082: PUSH
21083: LD_INT 6
21085: MUL
21086: PLUS
21087: ST_TO_ADDR
// if bcount < tmp then
21088: LD_VAR 0 13
21092: PUSH
21093: LD_VAR 0 4
21097: LESS
21098: IFFALSE 21144
// for i = tmp downto bcount do
21100: LD_ADDR_VAR 0 3
21104: PUSH
21105: DOUBLE
21106: LD_VAR 0 4
21110: INC
21111: ST_TO_ADDR
21112: LD_VAR 0 13
21116: PUSH
21117: FOR_DOWNTO
21118: IFFALSE 21142
// tmp := Delete ( tmp , tmp ) ;
21120: LD_ADDR_VAR 0 4
21124: PUSH
21125: LD_VAR 0 4
21129: PPUSH
21130: LD_VAR 0 4
21134: PPUSH
21135: CALL_OW 3
21139: ST_TO_ADDR
21140: GO 21117
21142: POP
21143: POP
// result := [ tmp , 0 , 0 , p ] ;
21144: LD_ADDR_VAR 0 2
21148: PUSH
21149: LD_VAR 0 4
21153: PUSH
21154: LD_INT 0
21156: PUSH
21157: LD_INT 0
21159: PUSH
21160: LD_VAR 0 11
21164: PUSH
21165: EMPTY
21166: LIST
21167: LIST
21168: LIST
21169: LIST
21170: ST_TO_ADDR
// exit ;
21171: GO 23538
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
21173: LD_EXP 50
21177: PUSH
21178: LD_VAR 0 1
21182: ARRAY
21183: PPUSH
21184: LD_INT 2
21186: PUSH
21187: LD_INT 30
21189: PUSH
21190: LD_INT 6
21192: PUSH
21193: EMPTY
21194: LIST
21195: LIST
21196: PUSH
21197: LD_INT 30
21199: PUSH
21200: LD_INT 7
21202: PUSH
21203: EMPTY
21204: LIST
21205: LIST
21206: PUSH
21207: LD_INT 30
21209: PUSH
21210: LD_INT 8
21212: PUSH
21213: EMPTY
21214: LIST
21215: LIST
21216: PUSH
21217: EMPTY
21218: LIST
21219: LIST
21220: LIST
21221: LIST
21222: PPUSH
21223: CALL_OW 72
21227: NOT
21228: PUSH
21229: LD_EXP 50
21233: PUSH
21234: LD_VAR 0 1
21238: ARRAY
21239: PPUSH
21240: LD_INT 30
21242: PUSH
21243: LD_INT 3
21245: PUSH
21246: EMPTY
21247: LIST
21248: LIST
21249: PPUSH
21250: CALL_OW 72
21254: NOT
21255: AND
21256: IFFALSE 21328
// begin if eng = tmp then
21258: LD_VAR 0 6
21262: PUSH
21263: LD_VAR 0 4
21267: EQUAL
21268: IFFALSE 21272
// exit ;
21270: GO 23538
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
21272: LD_ADDR_EXP 92
21276: PUSH
21277: LD_EXP 92
21281: PPUSH
21282: LD_VAR 0 1
21286: PPUSH
21287: LD_INT 1
21289: PPUSH
21290: CALL_OW 1
21294: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
21295: LD_ADDR_VAR 0 2
21299: PUSH
21300: LD_INT 0
21302: PUSH
21303: LD_VAR 0 4
21307: PUSH
21308: LD_VAR 0 6
21312: DIFF
21313: PUSH
21314: LD_INT 0
21316: PUSH
21317: LD_INT 0
21319: PUSH
21320: EMPTY
21321: LIST
21322: LIST
21323: LIST
21324: LIST
21325: ST_TO_ADDR
// exit ;
21326: GO 23538
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
21328: LD_EXP 77
21332: PUSH
21333: LD_EXP 76
21337: PUSH
21338: LD_VAR 0 1
21342: ARRAY
21343: ARRAY
21344: PUSH
21345: LD_EXP 50
21349: PUSH
21350: LD_VAR 0 1
21354: ARRAY
21355: PPUSH
21356: LD_INT 2
21358: PUSH
21359: LD_INT 30
21361: PUSH
21362: LD_INT 6
21364: PUSH
21365: EMPTY
21366: LIST
21367: LIST
21368: PUSH
21369: LD_INT 30
21371: PUSH
21372: LD_INT 7
21374: PUSH
21375: EMPTY
21376: LIST
21377: LIST
21378: PUSH
21379: LD_INT 30
21381: PUSH
21382: LD_INT 8
21384: PUSH
21385: EMPTY
21386: LIST
21387: LIST
21388: PUSH
21389: EMPTY
21390: LIST
21391: LIST
21392: LIST
21393: LIST
21394: PPUSH
21395: CALL_OW 72
21399: AND
21400: PUSH
21401: LD_EXP 50
21405: PUSH
21406: LD_VAR 0 1
21410: ARRAY
21411: PPUSH
21412: LD_INT 30
21414: PUSH
21415: LD_INT 3
21417: PUSH
21418: EMPTY
21419: LIST
21420: LIST
21421: PPUSH
21422: CALL_OW 72
21426: NOT
21427: AND
21428: IFFALSE 21642
// begin if sci >= 6 then
21430: LD_VAR 0 8
21434: PUSH
21435: LD_INT 6
21437: GREATEREQUAL
21438: IFFALSE 21442
// exit ;
21440: GO 23538
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
21442: LD_ADDR_EXP 92
21446: PUSH
21447: LD_EXP 92
21451: PPUSH
21452: LD_VAR 0 1
21456: PPUSH
21457: LD_INT 2
21459: PPUSH
21460: CALL_OW 1
21464: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
21465: LD_ADDR_VAR 0 9
21469: PUSH
21470: LD_VAR 0 4
21474: PUSH
21475: LD_VAR 0 8
21479: DIFF
21480: PPUSH
21481: LD_INT 4
21483: PPUSH
21484: CALL 85250 0 2
21488: ST_TO_ADDR
// p := [ ] ;
21489: LD_ADDR_VAR 0 11
21493: PUSH
21494: EMPTY
21495: ST_TO_ADDR
// if sci < 6 and sort > 6 then
21496: LD_VAR 0 8
21500: PUSH
21501: LD_INT 6
21503: LESS
21504: PUSH
21505: LD_VAR 0 9
21509: PUSH
21510: LD_INT 6
21512: GREATER
21513: AND
21514: IFFALSE 21595
// begin for i = 1 to 6 - sci do
21516: LD_ADDR_VAR 0 3
21520: PUSH
21521: DOUBLE
21522: LD_INT 1
21524: DEC
21525: ST_TO_ADDR
21526: LD_INT 6
21528: PUSH
21529: LD_VAR 0 8
21533: MINUS
21534: PUSH
21535: FOR_TO
21536: IFFALSE 21591
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
21538: LD_ADDR_VAR 0 11
21542: PUSH
21543: LD_VAR 0 11
21547: PPUSH
21548: LD_VAR 0 11
21552: PUSH
21553: LD_INT 1
21555: PLUS
21556: PPUSH
21557: LD_VAR 0 9
21561: PUSH
21562: LD_INT 1
21564: ARRAY
21565: PPUSH
21566: CALL_OW 2
21570: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
21571: LD_ADDR_VAR 0 9
21575: PUSH
21576: LD_VAR 0 9
21580: PPUSH
21581: LD_INT 1
21583: PPUSH
21584: CALL_OW 3
21588: ST_TO_ADDR
// end ;
21589: GO 21535
21591: POP
21592: POP
// end else
21593: GO 21615
// if sort then
21595: LD_VAR 0 9
21599: IFFALSE 21615
// p := sort [ 1 ] ;
21601: LD_ADDR_VAR 0 11
21605: PUSH
21606: LD_VAR 0 9
21610: PUSH
21611: LD_INT 1
21613: ARRAY
21614: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
21615: LD_ADDR_VAR 0 2
21619: PUSH
21620: LD_INT 0
21622: PUSH
21623: LD_INT 0
21625: PUSH
21626: LD_INT 0
21628: PUSH
21629: LD_VAR 0 11
21633: PUSH
21634: EMPTY
21635: LIST
21636: LIST
21637: LIST
21638: LIST
21639: ST_TO_ADDR
// exit ;
21640: GO 23538
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
21642: LD_EXP 77
21646: PUSH
21647: LD_EXP 76
21651: PUSH
21652: LD_VAR 0 1
21656: ARRAY
21657: ARRAY
21658: PUSH
21659: LD_EXP 50
21663: PUSH
21664: LD_VAR 0 1
21668: ARRAY
21669: PPUSH
21670: LD_INT 2
21672: PUSH
21673: LD_INT 30
21675: PUSH
21676: LD_INT 6
21678: PUSH
21679: EMPTY
21680: LIST
21681: LIST
21682: PUSH
21683: LD_INT 30
21685: PUSH
21686: LD_INT 7
21688: PUSH
21689: EMPTY
21690: LIST
21691: LIST
21692: PUSH
21693: LD_INT 30
21695: PUSH
21696: LD_INT 8
21698: PUSH
21699: EMPTY
21700: LIST
21701: LIST
21702: PUSH
21703: EMPTY
21704: LIST
21705: LIST
21706: LIST
21707: LIST
21708: PPUSH
21709: CALL_OW 72
21713: AND
21714: PUSH
21715: LD_EXP 50
21719: PUSH
21720: LD_VAR 0 1
21724: ARRAY
21725: PPUSH
21726: LD_INT 30
21728: PUSH
21729: LD_INT 3
21731: PUSH
21732: EMPTY
21733: LIST
21734: LIST
21735: PPUSH
21736: CALL_OW 72
21740: AND
21741: IFFALSE 22268
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
21743: LD_ADDR_EXP 92
21747: PUSH
21748: LD_EXP 92
21752: PPUSH
21753: LD_VAR 0 1
21757: PPUSH
21758: LD_INT 3
21760: PPUSH
21761: CALL_OW 1
21765: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
21766: LD_ADDR_VAR 0 2
21770: PUSH
21771: LD_INT 0
21773: PUSH
21774: LD_INT 0
21776: PUSH
21777: LD_INT 0
21779: PUSH
21780: LD_INT 0
21782: PUSH
21783: EMPTY
21784: LIST
21785: LIST
21786: LIST
21787: LIST
21788: ST_TO_ADDR
// if not eng then
21789: LD_VAR 0 6
21793: NOT
21794: IFFALSE 21857
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
21796: LD_ADDR_VAR 0 11
21800: PUSH
21801: LD_VAR 0 4
21805: PPUSH
21806: LD_INT 2
21808: PPUSH
21809: CALL 85250 0 2
21813: PUSH
21814: LD_INT 1
21816: ARRAY
21817: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
21818: LD_ADDR_VAR 0 2
21822: PUSH
21823: LD_VAR 0 2
21827: PPUSH
21828: LD_INT 2
21830: PPUSH
21831: LD_VAR 0 11
21835: PPUSH
21836: CALL_OW 1
21840: ST_TO_ADDR
// tmp := tmp diff p ;
21841: LD_ADDR_VAR 0 4
21845: PUSH
21846: LD_VAR 0 4
21850: PUSH
21851: LD_VAR 0 11
21855: DIFF
21856: ST_TO_ADDR
// end ; if not eng then
21857: LD_VAR 0 6
21861: NOT
21862: IFFALSE 21888
// tmp := tmp diff ( mech union sci ) else
21864: LD_ADDR_VAR 0 4
21868: PUSH
21869: LD_VAR 0 4
21873: PUSH
21874: LD_VAR 0 7
21878: PUSH
21879: LD_VAR 0 8
21883: UNION
21884: DIFF
21885: ST_TO_ADDR
21886: GO 21920
// tmp := tmp diff ( eng [ 1 ] union mech union sci ) ;
21888: LD_ADDR_VAR 0 4
21892: PUSH
21893: LD_VAR 0 4
21897: PUSH
21898: LD_VAR 0 6
21902: PUSH
21903: LD_INT 1
21905: ARRAY
21906: PUSH
21907: LD_VAR 0 7
21911: UNION
21912: PUSH
21913: LD_VAR 0 8
21917: UNION
21918: DIFF
21919: ST_TO_ADDR
// if tmp and sci < 6 then
21920: LD_VAR 0 4
21924: PUSH
21925: LD_VAR 0 8
21929: PUSH
21930: LD_INT 6
21932: LESS
21933: AND
21934: IFFALSE 22093
// begin sort := SortBySkill ( tmp , 4 ) ;
21936: LD_ADDR_VAR 0 9
21940: PUSH
21941: LD_VAR 0 4
21945: PPUSH
21946: LD_INT 4
21948: PPUSH
21949: CALL 85250 0 2
21953: ST_TO_ADDR
// p := [ ] ;
21954: LD_ADDR_VAR 0 11
21958: PUSH
21959: EMPTY
21960: ST_TO_ADDR
// if sort then
21961: LD_VAR 0 9
21965: IFFALSE 22064
// for i = 1 to 6 - sci do
21967: LD_ADDR_VAR 0 3
21971: PUSH
21972: DOUBLE
21973: LD_INT 1
21975: DEC
21976: ST_TO_ADDR
21977: LD_INT 6
21979: PUSH
21980: LD_VAR 0 8
21984: MINUS
21985: PUSH
21986: FOR_TO
21987: IFFALSE 22062
// begin if i = sort then
21989: LD_VAR 0 3
21993: PUSH
21994: LD_VAR 0 9
21998: EQUAL
21999: IFFALSE 22003
// break ;
22001: GO 22062
// p := Insert ( p , p + 1 , sort [ i ] ) ;
22003: LD_ADDR_VAR 0 11
22007: PUSH
22008: LD_VAR 0 11
22012: PPUSH
22013: LD_VAR 0 11
22017: PUSH
22018: LD_INT 1
22020: PLUS
22021: PPUSH
22022: LD_VAR 0 9
22026: PUSH
22027: LD_VAR 0 3
22031: ARRAY
22032: PPUSH
22033: CALL_OW 2
22037: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
22038: LD_ADDR_VAR 0 4
22042: PUSH
22043: LD_VAR 0 4
22047: PUSH
22048: LD_VAR 0 9
22052: PUSH
22053: LD_VAR 0 3
22057: ARRAY
22058: DIFF
22059: ST_TO_ADDR
// end ;
22060: GO 21986
22062: POP
22063: POP
// if p then
22064: LD_VAR 0 11
22068: IFFALSE 22093
// result := Replace ( result , 4 , p ) ;
22070: LD_ADDR_VAR 0 2
22074: PUSH
22075: LD_VAR 0 2
22079: PPUSH
22080: LD_INT 4
22082: PPUSH
22083: LD_VAR 0 11
22087: PPUSH
22088: CALL_OW 1
22092: ST_TO_ADDR
// end ; if tmp and mech < 6 then
22093: LD_VAR 0 4
22097: PUSH
22098: LD_VAR 0 7
22102: PUSH
22103: LD_INT 6
22105: LESS
22106: AND
22107: IFFALSE 22266
// begin sort := SortBySkill ( tmp , 3 ) ;
22109: LD_ADDR_VAR 0 9
22113: PUSH
22114: LD_VAR 0 4
22118: PPUSH
22119: LD_INT 3
22121: PPUSH
22122: CALL 85250 0 2
22126: ST_TO_ADDR
// p := [ ] ;
22127: LD_ADDR_VAR 0 11
22131: PUSH
22132: EMPTY
22133: ST_TO_ADDR
// if sort then
22134: LD_VAR 0 9
22138: IFFALSE 22237
// for i = 1 to 6 - mech do
22140: LD_ADDR_VAR 0 3
22144: PUSH
22145: DOUBLE
22146: LD_INT 1
22148: DEC
22149: ST_TO_ADDR
22150: LD_INT 6
22152: PUSH
22153: LD_VAR 0 7
22157: MINUS
22158: PUSH
22159: FOR_TO
22160: IFFALSE 22235
// begin if i = sort then
22162: LD_VAR 0 3
22166: PUSH
22167: LD_VAR 0 9
22171: EQUAL
22172: IFFALSE 22176
// break ;
22174: GO 22235
// p := Insert ( p , p + 1 , sort [ i ] ) ;
22176: LD_ADDR_VAR 0 11
22180: PUSH
22181: LD_VAR 0 11
22185: PPUSH
22186: LD_VAR 0 11
22190: PUSH
22191: LD_INT 1
22193: PLUS
22194: PPUSH
22195: LD_VAR 0 9
22199: PUSH
22200: LD_VAR 0 3
22204: ARRAY
22205: PPUSH
22206: CALL_OW 2
22210: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
22211: LD_ADDR_VAR 0 4
22215: PUSH
22216: LD_VAR 0 4
22220: PUSH
22221: LD_VAR 0 9
22225: PUSH
22226: LD_VAR 0 3
22230: ARRAY
22231: DIFF
22232: ST_TO_ADDR
// end ;
22233: GO 22159
22235: POP
22236: POP
// if p then
22237: LD_VAR 0 11
22241: IFFALSE 22266
// result := Replace ( result , 3 , p ) ;
22243: LD_ADDR_VAR 0 2
22247: PUSH
22248: LD_VAR 0 2
22252: PPUSH
22253: LD_INT 3
22255: PPUSH
22256: LD_VAR 0 11
22260: PPUSH
22261: CALL_OW 1
22265: ST_TO_ADDR
// end ; exit ;
22266: GO 23538
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
22268: LD_EXP 77
22272: PUSH
22273: LD_EXP 76
22277: PUSH
22278: LD_VAR 0 1
22282: ARRAY
22283: ARRAY
22284: NOT
22285: PUSH
22286: LD_EXP 50
22290: PUSH
22291: LD_VAR 0 1
22295: ARRAY
22296: PPUSH
22297: LD_INT 30
22299: PUSH
22300: LD_INT 3
22302: PUSH
22303: EMPTY
22304: LIST
22305: LIST
22306: PPUSH
22307: CALL_OW 72
22311: AND
22312: PUSH
22313: LD_EXP 55
22317: PUSH
22318: LD_VAR 0 1
22322: ARRAY
22323: AND
22324: IFFALSE 22868
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
22326: LD_ADDR_EXP 92
22330: PUSH
22331: LD_EXP 92
22335: PPUSH
22336: LD_VAR 0 1
22340: PPUSH
22341: LD_INT 5
22343: PPUSH
22344: CALL_OW 1
22348: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
22349: LD_ADDR_VAR 0 2
22353: PUSH
22354: LD_INT 0
22356: PUSH
22357: LD_INT 0
22359: PUSH
22360: LD_INT 0
22362: PUSH
22363: LD_INT 0
22365: PUSH
22366: EMPTY
22367: LIST
22368: LIST
22369: LIST
22370: LIST
22371: ST_TO_ADDR
// if sci > 1 then
22372: LD_VAR 0 8
22376: PUSH
22377: LD_INT 1
22379: GREATER
22380: IFFALSE 22408
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
22382: LD_ADDR_VAR 0 4
22386: PUSH
22387: LD_VAR 0 4
22391: PUSH
22392: LD_VAR 0 8
22396: PUSH
22397: LD_VAR 0 8
22401: PUSH
22402: LD_INT 1
22404: ARRAY
22405: DIFF
22406: DIFF
22407: ST_TO_ADDR
// if tmp and not sci then
22408: LD_VAR 0 4
22412: PUSH
22413: LD_VAR 0 8
22417: NOT
22418: AND
22419: IFFALSE 22488
// begin sort := SortBySkill ( tmp , 4 ) ;
22421: LD_ADDR_VAR 0 9
22425: PUSH
22426: LD_VAR 0 4
22430: PPUSH
22431: LD_INT 4
22433: PPUSH
22434: CALL 85250 0 2
22438: ST_TO_ADDR
// if sort then
22439: LD_VAR 0 9
22443: IFFALSE 22459
// p := sort [ 1 ] ;
22445: LD_ADDR_VAR 0 11
22449: PUSH
22450: LD_VAR 0 9
22454: PUSH
22455: LD_INT 1
22457: ARRAY
22458: ST_TO_ADDR
// if p then
22459: LD_VAR 0 11
22463: IFFALSE 22488
// result := Replace ( result , 4 , p ) ;
22465: LD_ADDR_VAR 0 2
22469: PUSH
22470: LD_VAR 0 2
22474: PPUSH
22475: LD_INT 4
22477: PPUSH
22478: LD_VAR 0 11
22482: PPUSH
22483: CALL_OW 1
22487: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
22488: LD_ADDR_VAR 0 4
22492: PUSH
22493: LD_VAR 0 4
22497: PUSH
22498: LD_VAR 0 7
22502: DIFF
22503: ST_TO_ADDR
// if tmp and mech < 6 then
22504: LD_VAR 0 4
22508: PUSH
22509: LD_VAR 0 7
22513: PUSH
22514: LD_INT 6
22516: LESS
22517: AND
22518: IFFALSE 22677
// begin sort := SortBySkill ( tmp , 3 ) ;
22520: LD_ADDR_VAR 0 9
22524: PUSH
22525: LD_VAR 0 4
22529: PPUSH
22530: LD_INT 3
22532: PPUSH
22533: CALL 85250 0 2
22537: ST_TO_ADDR
// p := [ ] ;
22538: LD_ADDR_VAR 0 11
22542: PUSH
22543: EMPTY
22544: ST_TO_ADDR
// if sort then
22545: LD_VAR 0 9
22549: IFFALSE 22648
// for i = 1 to 6 - mech do
22551: LD_ADDR_VAR 0 3
22555: PUSH
22556: DOUBLE
22557: LD_INT 1
22559: DEC
22560: ST_TO_ADDR
22561: LD_INT 6
22563: PUSH
22564: LD_VAR 0 7
22568: MINUS
22569: PUSH
22570: FOR_TO
22571: IFFALSE 22646
// begin if i = sort then
22573: LD_VAR 0 3
22577: PUSH
22578: LD_VAR 0 9
22582: EQUAL
22583: IFFALSE 22587
// break ;
22585: GO 22646
// p := Insert ( p , p + 1 , sort [ i ] ) ;
22587: LD_ADDR_VAR 0 11
22591: PUSH
22592: LD_VAR 0 11
22596: PPUSH
22597: LD_VAR 0 11
22601: PUSH
22602: LD_INT 1
22604: PLUS
22605: PPUSH
22606: LD_VAR 0 9
22610: PUSH
22611: LD_VAR 0 3
22615: ARRAY
22616: PPUSH
22617: CALL_OW 2
22621: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
22622: LD_ADDR_VAR 0 4
22626: PUSH
22627: LD_VAR 0 4
22631: PUSH
22632: LD_VAR 0 9
22636: PUSH
22637: LD_VAR 0 3
22641: ARRAY
22642: DIFF
22643: ST_TO_ADDR
// end ;
22644: GO 22570
22646: POP
22647: POP
// if p then
22648: LD_VAR 0 11
22652: IFFALSE 22677
// result := Replace ( result , 3 , p ) ;
22654: LD_ADDR_VAR 0 2
22658: PUSH
22659: LD_VAR 0 2
22663: PPUSH
22664: LD_INT 3
22666: PPUSH
22667: LD_VAR 0 11
22671: PPUSH
22672: CALL_OW 1
22676: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
22677: LD_ADDR_VAR 0 4
22681: PUSH
22682: LD_VAR 0 4
22686: PUSH
22687: LD_VAR 0 6
22691: DIFF
22692: ST_TO_ADDR
// if tmp and eng < 6 then
22693: LD_VAR 0 4
22697: PUSH
22698: LD_VAR 0 6
22702: PUSH
22703: LD_INT 6
22705: LESS
22706: AND
22707: IFFALSE 22866
// begin sort := SortBySkill ( tmp , 2 ) ;
22709: LD_ADDR_VAR 0 9
22713: PUSH
22714: LD_VAR 0 4
22718: PPUSH
22719: LD_INT 2
22721: PPUSH
22722: CALL 85250 0 2
22726: ST_TO_ADDR
// p := [ ] ;
22727: LD_ADDR_VAR 0 11
22731: PUSH
22732: EMPTY
22733: ST_TO_ADDR
// if sort then
22734: LD_VAR 0 9
22738: IFFALSE 22837
// for i = 1 to 6 - eng do
22740: LD_ADDR_VAR 0 3
22744: PUSH
22745: DOUBLE
22746: LD_INT 1
22748: DEC
22749: ST_TO_ADDR
22750: LD_INT 6
22752: PUSH
22753: LD_VAR 0 6
22757: MINUS
22758: PUSH
22759: FOR_TO
22760: IFFALSE 22835
// begin if i = sort then
22762: LD_VAR 0 3
22766: PUSH
22767: LD_VAR 0 9
22771: EQUAL
22772: IFFALSE 22776
// break ;
22774: GO 22835
// p := Insert ( p , p + 1 , sort [ i ] ) ;
22776: LD_ADDR_VAR 0 11
22780: PUSH
22781: LD_VAR 0 11
22785: PPUSH
22786: LD_VAR 0 11
22790: PUSH
22791: LD_INT 1
22793: PLUS
22794: PPUSH
22795: LD_VAR 0 9
22799: PUSH
22800: LD_VAR 0 3
22804: ARRAY
22805: PPUSH
22806: CALL_OW 2
22810: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
22811: LD_ADDR_VAR 0 4
22815: PUSH
22816: LD_VAR 0 4
22820: PUSH
22821: LD_VAR 0 9
22825: PUSH
22826: LD_VAR 0 3
22830: ARRAY
22831: DIFF
22832: ST_TO_ADDR
// end ;
22833: GO 22759
22835: POP
22836: POP
// if p then
22837: LD_VAR 0 11
22841: IFFALSE 22866
// result := Replace ( result , 2 , p ) ;
22843: LD_ADDR_VAR 0 2
22847: PUSH
22848: LD_VAR 0 2
22852: PPUSH
22853: LD_INT 2
22855: PPUSH
22856: LD_VAR 0 11
22860: PPUSH
22861: CALL_OW 1
22865: ST_TO_ADDR
// end ; exit ;
22866: GO 23538
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
22868: LD_EXP 77
22872: PUSH
22873: LD_EXP 76
22877: PUSH
22878: LD_VAR 0 1
22882: ARRAY
22883: ARRAY
22884: NOT
22885: PUSH
22886: LD_EXP 50
22890: PUSH
22891: LD_VAR 0 1
22895: ARRAY
22896: PPUSH
22897: LD_INT 30
22899: PUSH
22900: LD_INT 3
22902: PUSH
22903: EMPTY
22904: LIST
22905: LIST
22906: PPUSH
22907: CALL_OW 72
22911: AND
22912: PUSH
22913: LD_EXP 55
22917: PUSH
22918: LD_VAR 0 1
22922: ARRAY
22923: NOT
22924: AND
22925: IFFALSE 23538
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
22927: LD_ADDR_EXP 92
22931: PUSH
22932: LD_EXP 92
22936: PPUSH
22937: LD_VAR 0 1
22941: PPUSH
22942: LD_INT 6
22944: PPUSH
22945: CALL_OW 1
22949: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
22950: LD_ADDR_VAR 0 2
22954: PUSH
22955: LD_INT 0
22957: PUSH
22958: LD_INT 0
22960: PUSH
22961: LD_INT 0
22963: PUSH
22964: LD_INT 0
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: LIST
22971: LIST
22972: ST_TO_ADDR
// if sci >= 1 then
22973: LD_VAR 0 8
22977: PUSH
22978: LD_INT 1
22980: GREATEREQUAL
22981: IFFALSE 23003
// tmp := tmp diff sci [ 1 ] ;
22983: LD_ADDR_VAR 0 4
22987: PUSH
22988: LD_VAR 0 4
22992: PUSH
22993: LD_VAR 0 8
22997: PUSH
22998: LD_INT 1
23000: ARRAY
23001: DIFF
23002: ST_TO_ADDR
// if tmp and not sci then
23003: LD_VAR 0 4
23007: PUSH
23008: LD_VAR 0 8
23012: NOT
23013: AND
23014: IFFALSE 23083
// begin sort := SortBySkill ( tmp , 4 ) ;
23016: LD_ADDR_VAR 0 9
23020: PUSH
23021: LD_VAR 0 4
23025: PPUSH
23026: LD_INT 4
23028: PPUSH
23029: CALL 85250 0 2
23033: ST_TO_ADDR
// if sort then
23034: LD_VAR 0 9
23038: IFFALSE 23054
// p := sort [ 1 ] ;
23040: LD_ADDR_VAR 0 11
23044: PUSH
23045: LD_VAR 0 9
23049: PUSH
23050: LD_INT 1
23052: ARRAY
23053: ST_TO_ADDR
// if p then
23054: LD_VAR 0 11
23058: IFFALSE 23083
// result := Replace ( result , 4 , p ) ;
23060: LD_ADDR_VAR 0 2
23064: PUSH
23065: LD_VAR 0 2
23069: PPUSH
23070: LD_INT 4
23072: PPUSH
23073: LD_VAR 0 11
23077: PPUSH
23078: CALL_OW 1
23082: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
23083: LD_ADDR_VAR 0 4
23087: PUSH
23088: LD_VAR 0 4
23092: PUSH
23093: LD_VAR 0 7
23097: DIFF
23098: ST_TO_ADDR
// if tmp and mech < 6 then
23099: LD_VAR 0 4
23103: PUSH
23104: LD_VAR 0 7
23108: PUSH
23109: LD_INT 6
23111: LESS
23112: AND
23113: IFFALSE 23272
// begin sort := SortBySkill ( tmp , 3 ) ;
23115: LD_ADDR_VAR 0 9
23119: PUSH
23120: LD_VAR 0 4
23124: PPUSH
23125: LD_INT 3
23127: PPUSH
23128: CALL 85250 0 2
23132: ST_TO_ADDR
// p := [ ] ;
23133: LD_ADDR_VAR 0 11
23137: PUSH
23138: EMPTY
23139: ST_TO_ADDR
// if sort then
23140: LD_VAR 0 9
23144: IFFALSE 23243
// for i = 1 to 6 - mech do
23146: LD_ADDR_VAR 0 3
23150: PUSH
23151: DOUBLE
23152: LD_INT 1
23154: DEC
23155: ST_TO_ADDR
23156: LD_INT 6
23158: PUSH
23159: LD_VAR 0 7
23163: MINUS
23164: PUSH
23165: FOR_TO
23166: IFFALSE 23241
// begin if i = sort then
23168: LD_VAR 0 3
23172: PUSH
23173: LD_VAR 0 9
23177: EQUAL
23178: IFFALSE 23182
// break ;
23180: GO 23241
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23182: LD_ADDR_VAR 0 11
23186: PUSH
23187: LD_VAR 0 11
23191: PPUSH
23192: LD_VAR 0 11
23196: PUSH
23197: LD_INT 1
23199: PLUS
23200: PPUSH
23201: LD_VAR 0 9
23205: PUSH
23206: LD_VAR 0 3
23210: ARRAY
23211: PPUSH
23212: CALL_OW 2
23216: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23217: LD_ADDR_VAR 0 4
23221: PUSH
23222: LD_VAR 0 4
23226: PUSH
23227: LD_VAR 0 9
23231: PUSH
23232: LD_VAR 0 3
23236: ARRAY
23237: DIFF
23238: ST_TO_ADDR
// end ;
23239: GO 23165
23241: POP
23242: POP
// if p then
23243: LD_VAR 0 11
23247: IFFALSE 23272
// result := Replace ( result , 3 , p ) ;
23249: LD_ADDR_VAR 0 2
23253: PUSH
23254: LD_VAR 0 2
23258: PPUSH
23259: LD_INT 3
23261: PPUSH
23262: LD_VAR 0 11
23266: PPUSH
23267: CALL_OW 1
23271: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
23272: LD_ADDR_VAR 0 4
23276: PUSH
23277: LD_VAR 0 4
23281: PUSH
23282: LD_VAR 0 6
23286: DIFF
23287: ST_TO_ADDR
// if tmp and eng < 4 then
23288: LD_VAR 0 4
23292: PUSH
23293: LD_VAR 0 6
23297: PUSH
23298: LD_INT 4
23300: LESS
23301: AND
23302: IFFALSE 23463
// begin sort := SortBySkill ( tmp , 2 ) ;
23304: LD_ADDR_VAR 0 9
23308: PUSH
23309: LD_VAR 0 4
23313: PPUSH
23314: LD_INT 2
23316: PPUSH
23317: CALL 85250 0 2
23321: ST_TO_ADDR
// p := [ ] ;
23322: LD_ADDR_VAR 0 11
23326: PUSH
23327: EMPTY
23328: ST_TO_ADDR
// if sort then
23329: LD_VAR 0 9
23333: IFFALSE 23432
// for i = 1 to 4 - eng do
23335: LD_ADDR_VAR 0 3
23339: PUSH
23340: DOUBLE
23341: LD_INT 1
23343: DEC
23344: ST_TO_ADDR
23345: LD_INT 4
23347: PUSH
23348: LD_VAR 0 6
23352: MINUS
23353: PUSH
23354: FOR_TO
23355: IFFALSE 23430
// begin if i = sort then
23357: LD_VAR 0 3
23361: PUSH
23362: LD_VAR 0 9
23366: EQUAL
23367: IFFALSE 23371
// break ;
23369: GO 23430
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23371: LD_ADDR_VAR 0 11
23375: PUSH
23376: LD_VAR 0 11
23380: PPUSH
23381: LD_VAR 0 11
23385: PUSH
23386: LD_INT 1
23388: PLUS
23389: PPUSH
23390: LD_VAR 0 9
23394: PUSH
23395: LD_VAR 0 3
23399: ARRAY
23400: PPUSH
23401: CALL_OW 2
23405: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23406: LD_ADDR_VAR 0 4
23410: PUSH
23411: LD_VAR 0 4
23415: PUSH
23416: LD_VAR 0 9
23420: PUSH
23421: LD_VAR 0 3
23425: ARRAY
23426: DIFF
23427: ST_TO_ADDR
// end ;
23428: GO 23354
23430: POP
23431: POP
// if p then
23432: LD_VAR 0 11
23436: IFFALSE 23461
// result := Replace ( result , 2 , p ) ;
23438: LD_ADDR_VAR 0 2
23442: PUSH
23443: LD_VAR 0 2
23447: PPUSH
23448: LD_INT 2
23450: PPUSH
23451: LD_VAR 0 11
23455: PPUSH
23456: CALL_OW 1
23460: ST_TO_ADDR
// end else
23461: GO 23507
// for i = eng downto 5 do
23463: LD_ADDR_VAR 0 3
23467: PUSH
23468: DOUBLE
23469: LD_VAR 0 6
23473: INC
23474: ST_TO_ADDR
23475: LD_INT 5
23477: PUSH
23478: FOR_DOWNTO
23479: IFFALSE 23505
// tmp := tmp union eng [ i ] ;
23481: LD_ADDR_VAR 0 4
23485: PUSH
23486: LD_VAR 0 4
23490: PUSH
23491: LD_VAR 0 6
23495: PUSH
23496: LD_VAR 0 3
23500: ARRAY
23501: UNION
23502: ST_TO_ADDR
23503: GO 23478
23505: POP
23506: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
23507: LD_ADDR_VAR 0 2
23511: PUSH
23512: LD_VAR 0 2
23516: PPUSH
23517: LD_INT 1
23519: PPUSH
23520: LD_VAR 0 4
23524: PUSH
23525: LD_VAR 0 5
23529: DIFF
23530: PPUSH
23531: CALL_OW 1
23535: ST_TO_ADDR
// exit ;
23536: GO 23538
// end ; end ;
23538: LD_VAR 0 2
23542: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
23543: LD_INT 0
23545: PPUSH
23546: PPUSH
23547: PPUSH
// if not mc_bases then
23548: LD_EXP 50
23552: NOT
23553: IFFALSE 23557
// exit ;
23555: GO 23663
// for i = 1 to mc_bases do
23557: LD_ADDR_VAR 0 2
23561: PUSH
23562: DOUBLE
23563: LD_INT 1
23565: DEC
23566: ST_TO_ADDR
23567: LD_EXP 50
23571: PUSH
23572: FOR_TO
23573: IFFALSE 23654
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
23575: LD_ADDR_VAR 0 3
23579: PUSH
23580: LD_EXP 50
23584: PUSH
23585: LD_VAR 0 2
23589: ARRAY
23590: PPUSH
23591: LD_INT 21
23593: PUSH
23594: LD_INT 3
23596: PUSH
23597: EMPTY
23598: LIST
23599: LIST
23600: PUSH
23601: LD_INT 3
23603: PUSH
23604: LD_INT 24
23606: PUSH
23607: LD_INT 1000
23609: PUSH
23610: EMPTY
23611: LIST
23612: LIST
23613: PUSH
23614: EMPTY
23615: LIST
23616: LIST
23617: PUSH
23618: EMPTY
23619: LIST
23620: LIST
23621: PPUSH
23622: CALL_OW 72
23626: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
23627: LD_ADDR_EXP 51
23631: PUSH
23632: LD_EXP 51
23636: PPUSH
23637: LD_VAR 0 2
23641: PPUSH
23642: LD_VAR 0 3
23646: PPUSH
23647: CALL_OW 1
23651: ST_TO_ADDR
// end ;
23652: GO 23572
23654: POP
23655: POP
// RaiseSailEvent ( 101 ) ;
23656: LD_INT 101
23658: PPUSH
23659: CALL_OW 427
// end ;
23663: LD_VAR 0 1
23667: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
23668: LD_INT 0
23670: PPUSH
23671: PPUSH
23672: PPUSH
23673: PPUSH
23674: PPUSH
23675: PPUSH
23676: PPUSH
// if not mc_bases then
23677: LD_EXP 50
23681: NOT
23682: IFFALSE 23686
// exit ;
23684: GO 24259
// for i = 1 to mc_bases do
23686: LD_ADDR_VAR 0 2
23690: PUSH
23691: DOUBLE
23692: LD_INT 1
23694: DEC
23695: ST_TO_ADDR
23696: LD_EXP 50
23700: PUSH
23701: FOR_TO
23702: IFFALSE 24250
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
23704: LD_ADDR_VAR 0 5
23708: PUSH
23709: LD_EXP 50
23713: PUSH
23714: LD_VAR 0 2
23718: ARRAY
23719: PUSH
23720: LD_EXP 79
23724: PUSH
23725: LD_VAR 0 2
23729: ARRAY
23730: UNION
23731: PPUSH
23732: LD_INT 21
23734: PUSH
23735: LD_INT 1
23737: PUSH
23738: EMPTY
23739: LIST
23740: LIST
23741: PUSH
23742: LD_INT 1
23744: PUSH
23745: LD_INT 3
23747: PUSH
23748: LD_INT 54
23750: PUSH
23751: EMPTY
23752: LIST
23753: PUSH
23754: EMPTY
23755: LIST
23756: LIST
23757: PUSH
23758: LD_INT 3
23760: PUSH
23761: LD_INT 24
23763: PUSH
23764: LD_INT 750
23766: PUSH
23767: EMPTY
23768: LIST
23769: LIST
23770: PUSH
23771: EMPTY
23772: LIST
23773: LIST
23774: PUSH
23775: EMPTY
23776: LIST
23777: LIST
23778: LIST
23779: PUSH
23780: EMPTY
23781: LIST
23782: LIST
23783: PPUSH
23784: CALL_OW 72
23788: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
23789: LD_ADDR_VAR 0 6
23793: PUSH
23794: LD_EXP 50
23798: PUSH
23799: LD_VAR 0 2
23803: ARRAY
23804: PPUSH
23805: LD_INT 21
23807: PUSH
23808: LD_INT 1
23810: PUSH
23811: EMPTY
23812: LIST
23813: LIST
23814: PUSH
23815: LD_INT 1
23817: PUSH
23818: LD_INT 3
23820: PUSH
23821: LD_INT 54
23823: PUSH
23824: EMPTY
23825: LIST
23826: PUSH
23827: EMPTY
23828: LIST
23829: LIST
23830: PUSH
23831: LD_INT 3
23833: PUSH
23834: LD_INT 24
23836: PUSH
23837: LD_INT 250
23839: PUSH
23840: EMPTY
23841: LIST
23842: LIST
23843: PUSH
23844: EMPTY
23845: LIST
23846: LIST
23847: PUSH
23848: EMPTY
23849: LIST
23850: LIST
23851: LIST
23852: PUSH
23853: EMPTY
23854: LIST
23855: LIST
23856: PPUSH
23857: CALL_OW 72
23861: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
23862: LD_ADDR_VAR 0 7
23866: PUSH
23867: LD_VAR 0 5
23871: PUSH
23872: LD_VAR 0 6
23876: DIFF
23877: ST_TO_ADDR
// if not need_heal_1 then
23878: LD_VAR 0 6
23882: NOT
23883: IFFALSE 23916
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
23885: LD_ADDR_EXP 53
23889: PUSH
23890: LD_EXP 53
23894: PPUSH
23895: LD_VAR 0 2
23899: PUSH
23900: LD_INT 1
23902: PUSH
23903: EMPTY
23904: LIST
23905: LIST
23906: PPUSH
23907: EMPTY
23908: PPUSH
23909: CALL 51065 0 3
23913: ST_TO_ADDR
23914: GO 23986
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
23916: LD_ADDR_EXP 53
23920: PUSH
23921: LD_EXP 53
23925: PPUSH
23926: LD_VAR 0 2
23930: PUSH
23931: LD_INT 1
23933: PUSH
23934: EMPTY
23935: LIST
23936: LIST
23937: PPUSH
23938: LD_EXP 53
23942: PUSH
23943: LD_VAR 0 2
23947: ARRAY
23948: PUSH
23949: LD_INT 1
23951: ARRAY
23952: PPUSH
23953: LD_INT 3
23955: PUSH
23956: LD_INT 24
23958: PUSH
23959: LD_INT 1000
23961: PUSH
23962: EMPTY
23963: LIST
23964: LIST
23965: PUSH
23966: EMPTY
23967: LIST
23968: LIST
23969: PPUSH
23970: CALL_OW 72
23974: PUSH
23975: LD_VAR 0 6
23979: UNION
23980: PPUSH
23981: CALL 51065 0 3
23985: ST_TO_ADDR
// if not need_heal_2 then
23986: LD_VAR 0 7
23990: NOT
23991: IFFALSE 24024
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
23993: LD_ADDR_EXP 53
23997: PUSH
23998: LD_EXP 53
24002: PPUSH
24003: LD_VAR 0 2
24007: PUSH
24008: LD_INT 2
24010: PUSH
24011: EMPTY
24012: LIST
24013: LIST
24014: PPUSH
24015: EMPTY
24016: PPUSH
24017: CALL 51065 0 3
24021: ST_TO_ADDR
24022: GO 24056
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
24024: LD_ADDR_EXP 53
24028: PUSH
24029: LD_EXP 53
24033: PPUSH
24034: LD_VAR 0 2
24038: PUSH
24039: LD_INT 2
24041: PUSH
24042: EMPTY
24043: LIST
24044: LIST
24045: PPUSH
24046: LD_VAR 0 7
24050: PPUSH
24051: CALL 51065 0 3
24055: ST_TO_ADDR
// if need_heal_2 then
24056: LD_VAR 0 7
24060: IFFALSE 24232
// for j in need_heal_2 do
24062: LD_ADDR_VAR 0 3
24066: PUSH
24067: LD_VAR 0 7
24071: PUSH
24072: FOR_IN
24073: IFFALSE 24230
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
24075: LD_ADDR_VAR 0 5
24079: PUSH
24080: LD_EXP 50
24084: PUSH
24085: LD_VAR 0 2
24089: ARRAY
24090: PPUSH
24091: LD_INT 2
24093: PUSH
24094: LD_INT 30
24096: PUSH
24097: LD_INT 6
24099: PUSH
24100: EMPTY
24101: LIST
24102: LIST
24103: PUSH
24104: LD_INT 30
24106: PUSH
24107: LD_INT 7
24109: PUSH
24110: EMPTY
24111: LIST
24112: LIST
24113: PUSH
24114: LD_INT 30
24116: PUSH
24117: LD_INT 8
24119: PUSH
24120: EMPTY
24121: LIST
24122: LIST
24123: PUSH
24124: LD_INT 30
24126: PUSH
24127: LD_INT 0
24129: PUSH
24130: EMPTY
24131: LIST
24132: LIST
24133: PUSH
24134: LD_INT 30
24136: PUSH
24137: LD_INT 1
24139: PUSH
24140: EMPTY
24141: LIST
24142: LIST
24143: PUSH
24144: LD_INT 25
24146: PUSH
24147: LD_INT 4
24149: PUSH
24150: EMPTY
24151: LIST
24152: LIST
24153: PUSH
24154: EMPTY
24155: LIST
24156: LIST
24157: LIST
24158: LIST
24159: LIST
24160: LIST
24161: LIST
24162: PPUSH
24163: CALL_OW 72
24167: ST_TO_ADDR
// if tmp then
24168: LD_VAR 0 5
24172: IFFALSE 24228
// begin k := NearestUnitToUnit ( tmp , j ) ;
24174: LD_ADDR_VAR 0 4
24178: PUSH
24179: LD_VAR 0 5
24183: PPUSH
24184: LD_VAR 0 3
24188: PPUSH
24189: CALL_OW 74
24193: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
24194: LD_VAR 0 3
24198: PPUSH
24199: LD_VAR 0 4
24203: PPUSH
24204: CALL_OW 296
24208: PUSH
24209: LD_INT 7
24211: GREATER
24212: IFFALSE 24228
// ComMoveUnit ( j , k ) ;
24214: LD_VAR 0 3
24218: PPUSH
24219: LD_VAR 0 4
24223: PPUSH
24224: CALL_OW 112
// end ; end ;
24228: GO 24072
24230: POP
24231: POP
// if not need_heal_1 and not need_heal_2 then
24232: LD_VAR 0 6
24236: NOT
24237: PUSH
24238: LD_VAR 0 7
24242: NOT
24243: AND
24244: IFFALSE 24248
// continue ;
24246: GO 23701
// end ;
24248: GO 23701
24250: POP
24251: POP
// RaiseSailEvent ( 102 ) ;
24252: LD_INT 102
24254: PPUSH
24255: CALL_OW 427
// end ;
24259: LD_VAR 0 1
24263: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
24264: LD_INT 0
24266: PPUSH
24267: PPUSH
24268: PPUSH
24269: PPUSH
24270: PPUSH
// if not mc_bases then
24271: LD_EXP 50
24275: NOT
24276: IFFALSE 24280
// exit ;
24278: GO 24665
// for i = 1 to mc_bases do
24280: LD_ADDR_VAR 0 2
24284: PUSH
24285: DOUBLE
24286: LD_INT 1
24288: DEC
24289: ST_TO_ADDR
24290: LD_EXP 50
24294: PUSH
24295: FOR_TO
24296: IFFALSE 24663
// begin if not mc_building_need_repair [ i ] then
24298: LD_EXP 51
24302: PUSH
24303: LD_VAR 0 2
24307: ARRAY
24308: NOT
24309: IFFALSE 24347
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
24311: LD_ADDR_EXP 52
24315: PUSH
24316: LD_EXP 52
24320: PPUSH
24321: LD_VAR 0 2
24325: PPUSH
24326: EMPTY
24327: PPUSH
24328: CALL_OW 1
24332: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
24333: LD_VAR 0 2
24337: PPUSH
24338: LD_INT 101
24340: PPUSH
24341: CALL 19708 0 2
// continue ;
24345: GO 24295
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
24347: LD_ADDR_EXP 56
24351: PUSH
24352: LD_EXP 56
24356: PPUSH
24357: LD_VAR 0 2
24361: PPUSH
24362: EMPTY
24363: PPUSH
24364: CALL_OW 1
24368: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
24369: LD_VAR 0 2
24373: PPUSH
24374: LD_INT 103
24376: PPUSH
24377: CALL 19708 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
24381: LD_ADDR_VAR 0 5
24385: PUSH
24386: LD_EXP 50
24390: PUSH
24391: LD_VAR 0 2
24395: ARRAY
24396: PUSH
24397: LD_EXP 79
24401: PUSH
24402: LD_VAR 0 2
24406: ARRAY
24407: UNION
24408: PPUSH
24409: LD_INT 2
24411: PUSH
24412: LD_INT 25
24414: PUSH
24415: LD_INT 2
24417: PUSH
24418: EMPTY
24419: LIST
24420: LIST
24421: PUSH
24422: LD_INT 25
24424: PUSH
24425: LD_INT 16
24427: PUSH
24428: EMPTY
24429: LIST
24430: LIST
24431: PUSH
24432: EMPTY
24433: LIST
24434: LIST
24435: LIST
24436: PUSH
24437: EMPTY
24438: LIST
24439: PPUSH
24440: CALL_OW 72
24444: ST_TO_ADDR
// if not tmp then
24445: LD_VAR 0 5
24449: NOT
24450: IFFALSE 24454
// continue ;
24452: GO 24295
// for j in tmp do
24454: LD_ADDR_VAR 0 3
24458: PUSH
24459: LD_VAR 0 5
24463: PUSH
24464: FOR_IN
24465: IFFALSE 24659
// begin if mc_need_heal [ i ] then
24467: LD_EXP 53
24471: PUSH
24472: LD_VAR 0 2
24476: ARRAY
24477: IFFALSE 24525
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
24479: LD_VAR 0 3
24483: PUSH
24484: LD_EXP 53
24488: PUSH
24489: LD_VAR 0 2
24493: ARRAY
24494: PUSH
24495: LD_INT 1
24497: ARRAY
24498: IN
24499: PUSH
24500: LD_VAR 0 3
24504: PUSH
24505: LD_EXP 53
24509: PUSH
24510: LD_VAR 0 2
24514: ARRAY
24515: PUSH
24516: LD_INT 2
24518: ARRAY
24519: IN
24520: OR
24521: IFFALSE 24525
// continue ;
24523: GO 24464
// if IsInUnit ( j ) then
24525: LD_VAR 0 3
24529: PPUSH
24530: CALL_OW 310
24534: IFFALSE 24545
// ComExitBuilding ( j ) ;
24536: LD_VAR 0 3
24540: PPUSH
24541: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
24545: LD_VAR 0 3
24549: PUSH
24550: LD_EXP 52
24554: PUSH
24555: LD_VAR 0 2
24559: ARRAY
24560: IN
24561: NOT
24562: IFFALSE 24620
// begin SetTag ( j , 101 ) ;
24564: LD_VAR 0 3
24568: PPUSH
24569: LD_INT 101
24571: PPUSH
24572: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
24576: LD_ADDR_EXP 52
24580: PUSH
24581: LD_EXP 52
24585: PPUSH
24586: LD_VAR 0 2
24590: PUSH
24591: LD_EXP 52
24595: PUSH
24596: LD_VAR 0 2
24600: ARRAY
24601: PUSH
24602: LD_INT 1
24604: PLUS
24605: PUSH
24606: EMPTY
24607: LIST
24608: LIST
24609: PPUSH
24610: LD_VAR 0 3
24614: PPUSH
24615: CALL 51065 0 3
24619: ST_TO_ADDR
// end ; wait ( 1 ) ;
24620: LD_INT 1
24622: PPUSH
24623: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
24627: LD_VAR 0 3
24631: PPUSH
24632: LD_EXP 51
24636: PUSH
24637: LD_VAR 0 2
24641: ARRAY
24642: PPUSH
24643: LD_VAR 0 3
24647: PPUSH
24648: CALL_OW 74
24652: PPUSH
24653: CALL_OW 130
// end ;
24657: GO 24464
24659: POP
24660: POP
// end ;
24661: GO 24295
24663: POP
24664: POP
// end ;
24665: LD_VAR 0 1
24669: RET
// export function MC_Heal ; var i , j , tmp ; begin
24670: LD_INT 0
24672: PPUSH
24673: PPUSH
24674: PPUSH
24675: PPUSH
// if not mc_bases then
24676: LD_EXP 50
24680: NOT
24681: IFFALSE 24685
// exit ;
24683: GO 25087
// for i = 1 to mc_bases do
24685: LD_ADDR_VAR 0 2
24689: PUSH
24690: DOUBLE
24691: LD_INT 1
24693: DEC
24694: ST_TO_ADDR
24695: LD_EXP 50
24699: PUSH
24700: FOR_TO
24701: IFFALSE 25085
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
24703: LD_EXP 53
24707: PUSH
24708: LD_VAR 0 2
24712: ARRAY
24713: PUSH
24714: LD_INT 1
24716: ARRAY
24717: NOT
24718: PUSH
24719: LD_EXP 53
24723: PUSH
24724: LD_VAR 0 2
24728: ARRAY
24729: PUSH
24730: LD_INT 2
24732: ARRAY
24733: NOT
24734: AND
24735: IFFALSE 24773
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
24737: LD_ADDR_EXP 54
24741: PUSH
24742: LD_EXP 54
24746: PPUSH
24747: LD_VAR 0 2
24751: PPUSH
24752: EMPTY
24753: PPUSH
24754: CALL_OW 1
24758: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
24759: LD_VAR 0 2
24763: PPUSH
24764: LD_INT 102
24766: PPUSH
24767: CALL 19708 0 2
// continue ;
24771: GO 24700
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
24773: LD_ADDR_VAR 0 4
24777: PUSH
24778: LD_EXP 50
24782: PUSH
24783: LD_VAR 0 2
24787: ARRAY
24788: PPUSH
24789: LD_INT 25
24791: PUSH
24792: LD_INT 4
24794: PUSH
24795: EMPTY
24796: LIST
24797: LIST
24798: PPUSH
24799: CALL_OW 72
24803: ST_TO_ADDR
// if not tmp then
24804: LD_VAR 0 4
24808: NOT
24809: IFFALSE 24813
// continue ;
24811: GO 24700
// if mc_taming [ i ] then
24813: LD_EXP 81
24817: PUSH
24818: LD_VAR 0 2
24822: ARRAY
24823: IFFALSE 24847
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
24825: LD_ADDR_EXP 81
24829: PUSH
24830: LD_EXP 81
24834: PPUSH
24835: LD_VAR 0 2
24839: PPUSH
24840: EMPTY
24841: PPUSH
24842: CALL_OW 1
24846: ST_TO_ADDR
// for j in tmp do
24847: LD_ADDR_VAR 0 3
24851: PUSH
24852: LD_VAR 0 4
24856: PUSH
24857: FOR_IN
24858: IFFALSE 25081
// begin if IsInUnit ( j ) then
24860: LD_VAR 0 3
24864: PPUSH
24865: CALL_OW 310
24869: IFFALSE 24880
// ComExitBuilding ( j ) ;
24871: LD_VAR 0 3
24875: PPUSH
24876: CALL_OW 122
// if not j in mc_healers [ i ] then
24880: LD_VAR 0 3
24884: PUSH
24885: LD_EXP 54
24889: PUSH
24890: LD_VAR 0 2
24894: ARRAY
24895: IN
24896: NOT
24897: IFFALSE 24943
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
24899: LD_ADDR_EXP 54
24903: PUSH
24904: LD_EXP 54
24908: PPUSH
24909: LD_VAR 0 2
24913: PUSH
24914: LD_EXP 54
24918: PUSH
24919: LD_VAR 0 2
24923: ARRAY
24924: PUSH
24925: LD_INT 1
24927: PLUS
24928: PUSH
24929: EMPTY
24930: LIST
24931: LIST
24932: PPUSH
24933: LD_VAR 0 3
24937: PPUSH
24938: CALL 51065 0 3
24942: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
24943: LD_VAR 0 3
24947: PPUSH
24948: CALL_OW 110
24952: PUSH
24953: LD_INT 102
24955: NONEQUAL
24956: IFFALSE 24970
// SetTag ( j , 102 ) ;
24958: LD_VAR 0 3
24962: PPUSH
24963: LD_INT 102
24965: PPUSH
24966: CALL_OW 109
// Wait ( 3 ) ;
24970: LD_INT 3
24972: PPUSH
24973: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
24977: LD_EXP 53
24981: PUSH
24982: LD_VAR 0 2
24986: ARRAY
24987: PUSH
24988: LD_INT 1
24990: ARRAY
24991: IFFALSE 25023
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
24993: LD_VAR 0 3
24997: PPUSH
24998: LD_EXP 53
25002: PUSH
25003: LD_VAR 0 2
25007: ARRAY
25008: PUSH
25009: LD_INT 1
25011: ARRAY
25012: PUSH
25013: LD_INT 1
25015: ARRAY
25016: PPUSH
25017: CALL_OW 128
25021: GO 25079
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
25023: LD_VAR 0 3
25027: PPUSH
25028: CALL_OW 314
25032: NOT
25033: PUSH
25034: LD_EXP 53
25038: PUSH
25039: LD_VAR 0 2
25043: ARRAY
25044: PUSH
25045: LD_INT 2
25047: ARRAY
25048: AND
25049: IFFALSE 25079
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
25051: LD_VAR 0 3
25055: PPUSH
25056: LD_EXP 53
25060: PUSH
25061: LD_VAR 0 2
25065: ARRAY
25066: PUSH
25067: LD_INT 2
25069: ARRAY
25070: PUSH
25071: LD_INT 1
25073: ARRAY
25074: PPUSH
25075: CALL_OW 128
// end ;
25079: GO 24857
25081: POP
25082: POP
// end ;
25083: GO 24700
25085: POP
25086: POP
// end ;
25087: LD_VAR 0 1
25091: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
25092: LD_INT 0
25094: PPUSH
25095: PPUSH
25096: PPUSH
25097: PPUSH
25098: PPUSH
// if not mc_bases then
25099: LD_EXP 50
25103: NOT
25104: IFFALSE 25108
// exit ;
25106: GO 26251
// for i = 1 to mc_bases do
25108: LD_ADDR_VAR 0 2
25112: PUSH
25113: DOUBLE
25114: LD_INT 1
25116: DEC
25117: ST_TO_ADDR
25118: LD_EXP 50
25122: PUSH
25123: FOR_TO
25124: IFFALSE 26249
// begin if mc_scan [ i ] then
25126: LD_EXP 73
25130: PUSH
25131: LD_VAR 0 2
25135: ARRAY
25136: IFFALSE 25140
// continue ;
25138: GO 25123
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
25140: LD_EXP 55
25144: PUSH
25145: LD_VAR 0 2
25149: ARRAY
25150: NOT
25151: PUSH
25152: LD_EXP 57
25156: PUSH
25157: LD_VAR 0 2
25161: ARRAY
25162: NOT
25163: AND
25164: PUSH
25165: LD_EXP 56
25169: PUSH
25170: LD_VAR 0 2
25174: ARRAY
25175: AND
25176: IFFALSE 25214
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
25178: LD_ADDR_EXP 56
25182: PUSH
25183: LD_EXP 56
25187: PPUSH
25188: LD_VAR 0 2
25192: PPUSH
25193: EMPTY
25194: PPUSH
25195: CALL_OW 1
25199: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
25200: LD_VAR 0 2
25204: PPUSH
25205: LD_INT 103
25207: PPUSH
25208: CALL 19708 0 2
// continue ;
25212: GO 25123
// end ; if mc_construct_list [ i ] then
25214: LD_EXP 57
25218: PUSH
25219: LD_VAR 0 2
25223: ARRAY
25224: IFFALSE 25444
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
25226: LD_ADDR_VAR 0 4
25230: PUSH
25231: LD_EXP 50
25235: PUSH
25236: LD_VAR 0 2
25240: ARRAY
25241: PPUSH
25242: LD_INT 25
25244: PUSH
25245: LD_INT 2
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PPUSH
25252: CALL_OW 72
25256: PUSH
25257: LD_EXP 52
25261: PUSH
25262: LD_VAR 0 2
25266: ARRAY
25267: DIFF
25268: ST_TO_ADDR
// if not tmp then
25269: LD_VAR 0 4
25273: NOT
25274: IFFALSE 25278
// continue ;
25276: GO 25123
// for j in tmp do
25278: LD_ADDR_VAR 0 3
25282: PUSH
25283: LD_VAR 0 4
25287: PUSH
25288: FOR_IN
25289: IFFALSE 25440
// begin if not mc_builders [ i ] then
25291: LD_EXP 56
25295: PUSH
25296: LD_VAR 0 2
25300: ARRAY
25301: NOT
25302: IFFALSE 25360
// begin SetTag ( j , 103 ) ;
25304: LD_VAR 0 3
25308: PPUSH
25309: LD_INT 103
25311: PPUSH
25312: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
25316: LD_ADDR_EXP 56
25320: PUSH
25321: LD_EXP 56
25325: PPUSH
25326: LD_VAR 0 2
25330: PUSH
25331: LD_EXP 56
25335: PUSH
25336: LD_VAR 0 2
25340: ARRAY
25341: PUSH
25342: LD_INT 1
25344: PLUS
25345: PUSH
25346: EMPTY
25347: LIST
25348: LIST
25349: PPUSH
25350: LD_VAR 0 3
25354: PPUSH
25355: CALL 51065 0 3
25359: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
25360: LD_VAR 0 3
25364: PPUSH
25365: CALL_OW 310
25369: IFFALSE 25380
// ComExitBuilding ( j ) ;
25371: LD_VAR 0 3
25375: PPUSH
25376: CALL_OW 122
// wait ( 3 ) ;
25380: LD_INT 3
25382: PPUSH
25383: CALL_OW 67
// if not mc_construct_list [ i ] then
25387: LD_EXP 57
25391: PUSH
25392: LD_VAR 0 2
25396: ARRAY
25397: NOT
25398: IFFALSE 25402
// break ;
25400: GO 25440
// if not HasTask ( j ) then
25402: LD_VAR 0 3
25406: PPUSH
25407: CALL_OW 314
25411: NOT
25412: IFFALSE 25438
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
25414: LD_VAR 0 3
25418: PPUSH
25419: LD_EXP 57
25423: PUSH
25424: LD_VAR 0 2
25428: ARRAY
25429: PUSH
25430: LD_INT 1
25432: ARRAY
25433: PPUSH
25434: CALL 53916 0 2
// end ;
25438: GO 25288
25440: POP
25441: POP
// end else
25442: GO 26247
// if mc_build_list [ i ] then
25444: LD_EXP 55
25448: PUSH
25449: LD_VAR 0 2
25453: ARRAY
25454: IFFALSE 26247
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
25456: LD_ADDR_VAR 0 5
25460: PUSH
25461: LD_EXP 50
25465: PUSH
25466: LD_VAR 0 2
25470: ARRAY
25471: PPUSH
25472: LD_INT 2
25474: PUSH
25475: LD_INT 30
25477: PUSH
25478: LD_INT 0
25480: PUSH
25481: EMPTY
25482: LIST
25483: LIST
25484: PUSH
25485: LD_INT 30
25487: PUSH
25488: LD_INT 1
25490: PUSH
25491: EMPTY
25492: LIST
25493: LIST
25494: PUSH
25495: EMPTY
25496: LIST
25497: LIST
25498: LIST
25499: PPUSH
25500: CALL_OW 72
25504: ST_TO_ADDR
// if depot then
25505: LD_VAR 0 5
25509: IFFALSE 25527
// depot := depot [ 1 ] else
25511: LD_ADDR_VAR 0 5
25515: PUSH
25516: LD_VAR 0 5
25520: PUSH
25521: LD_INT 1
25523: ARRAY
25524: ST_TO_ADDR
25525: GO 25535
// depot := 0 ;
25527: LD_ADDR_VAR 0 5
25531: PUSH
25532: LD_INT 0
25534: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
25535: LD_EXP 55
25539: PUSH
25540: LD_VAR 0 2
25544: ARRAY
25545: PUSH
25546: LD_INT 1
25548: ARRAY
25549: PUSH
25550: LD_INT 1
25552: ARRAY
25553: PPUSH
25554: CALL 53746 0 1
25558: PUSH
25559: LD_EXP 50
25563: PUSH
25564: LD_VAR 0 2
25568: ARRAY
25569: PPUSH
25570: LD_INT 2
25572: PUSH
25573: LD_INT 30
25575: PUSH
25576: LD_INT 2
25578: PUSH
25579: EMPTY
25580: LIST
25581: LIST
25582: PUSH
25583: LD_INT 30
25585: PUSH
25586: LD_INT 3
25588: PUSH
25589: EMPTY
25590: LIST
25591: LIST
25592: PUSH
25593: EMPTY
25594: LIST
25595: LIST
25596: LIST
25597: PPUSH
25598: CALL_OW 72
25602: NOT
25603: AND
25604: IFFALSE 25709
// begin for j = 1 to mc_build_list [ i ] do
25606: LD_ADDR_VAR 0 3
25610: PUSH
25611: DOUBLE
25612: LD_INT 1
25614: DEC
25615: ST_TO_ADDR
25616: LD_EXP 55
25620: PUSH
25621: LD_VAR 0 2
25625: ARRAY
25626: PUSH
25627: FOR_TO
25628: IFFALSE 25707
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
25630: LD_EXP 55
25634: PUSH
25635: LD_VAR 0 2
25639: ARRAY
25640: PUSH
25641: LD_VAR 0 3
25645: ARRAY
25646: PUSH
25647: LD_INT 1
25649: ARRAY
25650: PUSH
25651: LD_INT 2
25653: EQUAL
25654: IFFALSE 25705
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
25656: LD_ADDR_EXP 55
25660: PUSH
25661: LD_EXP 55
25665: PPUSH
25666: LD_VAR 0 2
25670: PPUSH
25671: LD_EXP 55
25675: PUSH
25676: LD_VAR 0 2
25680: ARRAY
25681: PPUSH
25682: LD_VAR 0 3
25686: PPUSH
25687: LD_INT 1
25689: PPUSH
25690: LD_INT 0
25692: PPUSH
25693: CALL 50483 0 4
25697: PPUSH
25698: CALL_OW 1
25702: ST_TO_ADDR
// break ;
25703: GO 25707
// end ;
25705: GO 25627
25707: POP
25708: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
25709: LD_EXP 55
25713: PUSH
25714: LD_VAR 0 2
25718: ARRAY
25719: PUSH
25720: LD_INT 1
25722: ARRAY
25723: PUSH
25724: LD_INT 1
25726: ARRAY
25727: PUSH
25728: LD_INT 0
25730: EQUAL
25731: PUSH
25732: LD_VAR 0 5
25736: PUSH
25737: LD_VAR 0 5
25741: PPUSH
25742: LD_EXP 55
25746: PUSH
25747: LD_VAR 0 2
25751: ARRAY
25752: PUSH
25753: LD_INT 1
25755: ARRAY
25756: PUSH
25757: LD_INT 1
25759: ARRAY
25760: PPUSH
25761: LD_EXP 55
25765: PUSH
25766: LD_VAR 0 2
25770: ARRAY
25771: PUSH
25772: LD_INT 1
25774: ARRAY
25775: PUSH
25776: LD_INT 2
25778: ARRAY
25779: PPUSH
25780: LD_EXP 55
25784: PUSH
25785: LD_VAR 0 2
25789: ARRAY
25790: PUSH
25791: LD_INT 1
25793: ARRAY
25794: PUSH
25795: LD_INT 3
25797: ARRAY
25798: PPUSH
25799: LD_EXP 55
25803: PUSH
25804: LD_VAR 0 2
25808: ARRAY
25809: PUSH
25810: LD_INT 1
25812: ARRAY
25813: PUSH
25814: LD_INT 4
25816: ARRAY
25817: PPUSH
25818: CALL 58462 0 5
25822: AND
25823: OR
25824: IFFALSE 26105
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
25826: LD_ADDR_VAR 0 4
25830: PUSH
25831: LD_EXP 50
25835: PUSH
25836: LD_VAR 0 2
25840: ARRAY
25841: PPUSH
25842: LD_INT 25
25844: PUSH
25845: LD_INT 2
25847: PUSH
25848: EMPTY
25849: LIST
25850: LIST
25851: PPUSH
25852: CALL_OW 72
25856: PUSH
25857: LD_EXP 52
25861: PUSH
25862: LD_VAR 0 2
25866: ARRAY
25867: DIFF
25868: ST_TO_ADDR
// if not tmp then
25869: LD_VAR 0 4
25873: NOT
25874: IFFALSE 25878
// continue ;
25876: GO 25123
// for j in tmp do
25878: LD_ADDR_VAR 0 3
25882: PUSH
25883: LD_VAR 0 4
25887: PUSH
25888: FOR_IN
25889: IFFALSE 26101
// begin if not mc_builders [ i ] then
25891: LD_EXP 56
25895: PUSH
25896: LD_VAR 0 2
25900: ARRAY
25901: NOT
25902: IFFALSE 25960
// begin SetTag ( j , 103 ) ;
25904: LD_VAR 0 3
25908: PPUSH
25909: LD_INT 103
25911: PPUSH
25912: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
25916: LD_ADDR_EXP 56
25920: PUSH
25921: LD_EXP 56
25925: PPUSH
25926: LD_VAR 0 2
25930: PUSH
25931: LD_EXP 56
25935: PUSH
25936: LD_VAR 0 2
25940: ARRAY
25941: PUSH
25942: LD_INT 1
25944: PLUS
25945: PUSH
25946: EMPTY
25947: LIST
25948: LIST
25949: PPUSH
25950: LD_VAR 0 3
25954: PPUSH
25955: CALL 51065 0 3
25959: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
25960: LD_VAR 0 3
25964: PPUSH
25965: CALL_OW 310
25969: IFFALSE 25980
// ComExitBuilding ( j ) ;
25971: LD_VAR 0 3
25975: PPUSH
25976: CALL_OW 122
// wait ( 3 ) ;
25980: LD_INT 3
25982: PPUSH
25983: CALL_OW 67
// if not mc_build_list [ i ] then
25987: LD_EXP 55
25991: PUSH
25992: LD_VAR 0 2
25996: ARRAY
25997: NOT
25998: IFFALSE 26002
// break ;
26000: GO 26101
// if not HasTask ( j ) then
26002: LD_VAR 0 3
26006: PPUSH
26007: CALL_OW 314
26011: NOT
26012: IFFALSE 26099
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
26014: LD_VAR 0 3
26018: PPUSH
26019: LD_EXP 55
26023: PUSH
26024: LD_VAR 0 2
26028: ARRAY
26029: PUSH
26030: LD_INT 1
26032: ARRAY
26033: PUSH
26034: LD_INT 1
26036: ARRAY
26037: PPUSH
26038: LD_EXP 55
26042: PUSH
26043: LD_VAR 0 2
26047: ARRAY
26048: PUSH
26049: LD_INT 1
26051: ARRAY
26052: PUSH
26053: LD_INT 2
26055: ARRAY
26056: PPUSH
26057: LD_EXP 55
26061: PUSH
26062: LD_VAR 0 2
26066: ARRAY
26067: PUSH
26068: LD_INT 1
26070: ARRAY
26071: PUSH
26072: LD_INT 3
26074: ARRAY
26075: PPUSH
26076: LD_EXP 55
26080: PUSH
26081: LD_VAR 0 2
26085: ARRAY
26086: PUSH
26087: LD_INT 1
26089: ARRAY
26090: PUSH
26091: LD_INT 4
26093: ARRAY
26094: PPUSH
26095: CALL_OW 145
// end ;
26099: GO 25888
26101: POP
26102: POP
// end else
26103: GO 26247
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
26105: LD_EXP 50
26109: PUSH
26110: LD_VAR 0 2
26114: ARRAY
26115: PPUSH
26116: LD_EXP 55
26120: PUSH
26121: LD_VAR 0 2
26125: ARRAY
26126: PUSH
26127: LD_INT 1
26129: ARRAY
26130: PUSH
26131: LD_INT 1
26133: ARRAY
26134: PPUSH
26135: LD_EXP 55
26139: PUSH
26140: LD_VAR 0 2
26144: ARRAY
26145: PUSH
26146: LD_INT 1
26148: ARRAY
26149: PUSH
26150: LD_INT 2
26152: ARRAY
26153: PPUSH
26154: LD_EXP 55
26158: PUSH
26159: LD_VAR 0 2
26163: ARRAY
26164: PUSH
26165: LD_INT 1
26167: ARRAY
26168: PUSH
26169: LD_INT 3
26171: ARRAY
26172: PPUSH
26173: LD_EXP 55
26177: PUSH
26178: LD_VAR 0 2
26182: ARRAY
26183: PUSH
26184: LD_INT 1
26186: ARRAY
26187: PUSH
26188: LD_INT 4
26190: ARRAY
26191: PPUSH
26192: CALL 57816 0 5
26196: NOT
26197: IFFALSE 26247
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
26199: LD_ADDR_EXP 55
26203: PUSH
26204: LD_EXP 55
26208: PPUSH
26209: LD_VAR 0 2
26213: PPUSH
26214: LD_EXP 55
26218: PUSH
26219: LD_VAR 0 2
26223: ARRAY
26224: PPUSH
26225: LD_INT 1
26227: PPUSH
26228: LD_INT 1
26230: NEG
26231: PPUSH
26232: LD_INT 0
26234: PPUSH
26235: CALL 50483 0 4
26239: PPUSH
26240: CALL_OW 1
26244: ST_TO_ADDR
// continue ;
26245: GO 25123
// end ; end ; end ;
26247: GO 25123
26249: POP
26250: POP
// end ;
26251: LD_VAR 0 1
26255: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
26256: LD_INT 0
26258: PPUSH
26259: PPUSH
26260: PPUSH
26261: PPUSH
26262: PPUSH
26263: PPUSH
// if not mc_bases then
26264: LD_EXP 50
26268: NOT
26269: IFFALSE 26273
// exit ;
26271: GO 26700
// for i = 1 to mc_bases do
26273: LD_ADDR_VAR 0 2
26277: PUSH
26278: DOUBLE
26279: LD_INT 1
26281: DEC
26282: ST_TO_ADDR
26283: LD_EXP 50
26287: PUSH
26288: FOR_TO
26289: IFFALSE 26698
// begin tmp := mc_build_upgrade [ i ] ;
26291: LD_ADDR_VAR 0 4
26295: PUSH
26296: LD_EXP 82
26300: PUSH
26301: LD_VAR 0 2
26305: ARRAY
26306: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
26307: LD_ADDR_VAR 0 6
26311: PUSH
26312: LD_EXP 83
26316: PUSH
26317: LD_VAR 0 2
26321: ARRAY
26322: PPUSH
26323: LD_INT 2
26325: PUSH
26326: LD_INT 30
26328: PUSH
26329: LD_INT 6
26331: PUSH
26332: EMPTY
26333: LIST
26334: LIST
26335: PUSH
26336: LD_INT 30
26338: PUSH
26339: LD_INT 7
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: PUSH
26346: EMPTY
26347: LIST
26348: LIST
26349: LIST
26350: PPUSH
26351: CALL_OW 72
26355: ST_TO_ADDR
// if not tmp and not lab then
26356: LD_VAR 0 4
26360: NOT
26361: PUSH
26362: LD_VAR 0 6
26366: NOT
26367: AND
26368: IFFALSE 26372
// continue ;
26370: GO 26288
// if tmp then
26372: LD_VAR 0 4
26376: IFFALSE 26496
// for j in tmp do
26378: LD_ADDR_VAR 0 3
26382: PUSH
26383: LD_VAR 0 4
26387: PUSH
26388: FOR_IN
26389: IFFALSE 26494
// begin if UpgradeCost ( j ) then
26391: LD_VAR 0 3
26395: PPUSH
26396: CALL 57476 0 1
26400: IFFALSE 26492
// begin ComUpgrade ( j ) ;
26402: LD_VAR 0 3
26406: PPUSH
26407: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
26411: LD_ADDR_EXP 82
26415: PUSH
26416: LD_EXP 82
26420: PPUSH
26421: LD_VAR 0 2
26425: PPUSH
26426: LD_EXP 82
26430: PUSH
26431: LD_VAR 0 2
26435: ARRAY
26436: PUSH
26437: LD_VAR 0 3
26441: DIFF
26442: PPUSH
26443: CALL_OW 1
26447: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
26448: LD_ADDR_EXP 57
26452: PUSH
26453: LD_EXP 57
26457: PPUSH
26458: LD_VAR 0 2
26462: PUSH
26463: LD_EXP 57
26467: PUSH
26468: LD_VAR 0 2
26472: ARRAY
26473: PUSH
26474: LD_INT 1
26476: PLUS
26477: PUSH
26478: EMPTY
26479: LIST
26480: LIST
26481: PPUSH
26482: LD_VAR 0 3
26486: PPUSH
26487: CALL 51065 0 3
26491: ST_TO_ADDR
// end ; end ;
26492: GO 26388
26494: POP
26495: POP
// if not lab or not mc_lab_upgrade [ i ] then
26496: LD_VAR 0 6
26500: NOT
26501: PUSH
26502: LD_EXP 84
26506: PUSH
26507: LD_VAR 0 2
26511: ARRAY
26512: NOT
26513: OR
26514: IFFALSE 26518
// continue ;
26516: GO 26288
// for j in lab do
26518: LD_ADDR_VAR 0 3
26522: PUSH
26523: LD_VAR 0 6
26527: PUSH
26528: FOR_IN
26529: IFFALSE 26694
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
26531: LD_VAR 0 3
26535: PPUSH
26536: CALL_OW 266
26540: PUSH
26541: LD_INT 6
26543: PUSH
26544: LD_INT 7
26546: PUSH
26547: EMPTY
26548: LIST
26549: LIST
26550: IN
26551: PUSH
26552: LD_VAR 0 3
26556: PPUSH
26557: CALL_OW 461
26561: PUSH
26562: LD_INT 1
26564: NONEQUAL
26565: AND
26566: IFFALSE 26692
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
26568: LD_VAR 0 3
26572: PPUSH
26573: LD_EXP 84
26577: PUSH
26578: LD_VAR 0 2
26582: ARRAY
26583: PUSH
26584: LD_INT 1
26586: ARRAY
26587: PPUSH
26588: CALL 57681 0 2
26592: IFFALSE 26692
// begin ComCancel ( j ) ;
26594: LD_VAR 0 3
26598: PPUSH
26599: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
26603: LD_VAR 0 3
26607: PPUSH
26608: LD_EXP 84
26612: PUSH
26613: LD_VAR 0 2
26617: ARRAY
26618: PUSH
26619: LD_INT 1
26621: ARRAY
26622: PPUSH
26623: CALL_OW 207
// if not j in mc_construct_list [ i ] then
26627: LD_VAR 0 3
26631: PUSH
26632: LD_EXP 57
26636: PUSH
26637: LD_VAR 0 2
26641: ARRAY
26642: IN
26643: NOT
26644: IFFALSE 26690
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
26646: LD_ADDR_EXP 57
26650: PUSH
26651: LD_EXP 57
26655: PPUSH
26656: LD_VAR 0 2
26660: PUSH
26661: LD_EXP 57
26665: PUSH
26666: LD_VAR 0 2
26670: ARRAY
26671: PUSH
26672: LD_INT 1
26674: PLUS
26675: PUSH
26676: EMPTY
26677: LIST
26678: LIST
26679: PPUSH
26680: LD_VAR 0 3
26684: PPUSH
26685: CALL 51065 0 3
26689: ST_TO_ADDR
// break ;
26690: GO 26694
// end ; end ; end ;
26692: GO 26528
26694: POP
26695: POP
// end ;
26696: GO 26288
26698: POP
26699: POP
// end ;
26700: LD_VAR 0 1
26704: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
26705: LD_INT 0
26707: PPUSH
26708: PPUSH
26709: PPUSH
26710: PPUSH
26711: PPUSH
26712: PPUSH
26713: PPUSH
26714: PPUSH
26715: PPUSH
// if not mc_bases then
26716: LD_EXP 50
26720: NOT
26721: IFFALSE 26725
// exit ;
26723: GO 27130
// for i = 1 to mc_bases do
26725: LD_ADDR_VAR 0 2
26729: PUSH
26730: DOUBLE
26731: LD_INT 1
26733: DEC
26734: ST_TO_ADDR
26735: LD_EXP 50
26739: PUSH
26740: FOR_TO
26741: IFFALSE 27128
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
26743: LD_EXP 58
26747: PUSH
26748: LD_VAR 0 2
26752: ARRAY
26753: NOT
26754: PUSH
26755: LD_EXP 50
26759: PUSH
26760: LD_VAR 0 2
26764: ARRAY
26765: PPUSH
26766: LD_INT 30
26768: PUSH
26769: LD_INT 3
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: PPUSH
26776: CALL_OW 72
26780: NOT
26781: OR
26782: IFFALSE 26786
// continue ;
26784: GO 26740
// busy := false ;
26786: LD_ADDR_VAR 0 8
26790: PUSH
26791: LD_INT 0
26793: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
26794: LD_ADDR_VAR 0 4
26798: PUSH
26799: LD_EXP 50
26803: PUSH
26804: LD_VAR 0 2
26808: ARRAY
26809: PPUSH
26810: LD_INT 30
26812: PUSH
26813: LD_INT 3
26815: PUSH
26816: EMPTY
26817: LIST
26818: LIST
26819: PPUSH
26820: CALL_OW 72
26824: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
26825: LD_ADDR_VAR 0 6
26829: PUSH
26830: LD_EXP 58
26834: PUSH
26835: LD_VAR 0 2
26839: ARRAY
26840: PPUSH
26841: LD_INT 2
26843: PUSH
26844: LD_INT 30
26846: PUSH
26847: LD_INT 32
26849: PUSH
26850: EMPTY
26851: LIST
26852: LIST
26853: PUSH
26854: LD_INT 30
26856: PUSH
26857: LD_INT 33
26859: PUSH
26860: EMPTY
26861: LIST
26862: LIST
26863: PUSH
26864: EMPTY
26865: LIST
26866: LIST
26867: LIST
26868: PPUSH
26869: CALL_OW 72
26873: ST_TO_ADDR
// if not t then
26874: LD_VAR 0 6
26878: NOT
26879: IFFALSE 26883
// continue ;
26881: GO 26740
// for j in tmp do
26883: LD_ADDR_VAR 0 3
26887: PUSH
26888: LD_VAR 0 4
26892: PUSH
26893: FOR_IN
26894: IFFALSE 26924
// if not BuildingStatus ( j ) = bs_idle then
26896: LD_VAR 0 3
26900: PPUSH
26901: CALL_OW 461
26905: PUSH
26906: LD_INT 2
26908: EQUAL
26909: NOT
26910: IFFALSE 26922
// begin busy := true ;
26912: LD_ADDR_VAR 0 8
26916: PUSH
26917: LD_INT 1
26919: ST_TO_ADDR
// break ;
26920: GO 26924
// end ;
26922: GO 26893
26924: POP
26925: POP
// if busy then
26926: LD_VAR 0 8
26930: IFFALSE 26934
// continue ;
26932: GO 26740
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
26934: LD_ADDR_VAR 0 7
26938: PUSH
26939: LD_VAR 0 6
26943: PPUSH
26944: LD_INT 35
26946: PUSH
26947: LD_INT 0
26949: PUSH
26950: EMPTY
26951: LIST
26952: LIST
26953: PPUSH
26954: CALL_OW 72
26958: ST_TO_ADDR
// if tw then
26959: LD_VAR 0 7
26963: IFFALSE 27040
// begin tw := tw [ 1 ] ;
26965: LD_ADDR_VAR 0 7
26969: PUSH
26970: LD_VAR 0 7
26974: PUSH
26975: LD_INT 1
26977: ARRAY
26978: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
26979: LD_ADDR_VAR 0 9
26983: PUSH
26984: LD_VAR 0 7
26988: PPUSH
26989: LD_EXP 75
26993: PUSH
26994: LD_VAR 0 2
26998: ARRAY
26999: PPUSH
27000: CALL 56035 0 2
27004: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
27005: LD_EXP 89
27009: PUSH
27010: LD_VAR 0 2
27014: ARRAY
27015: IFFALSE 27038
// if not weapon in mc_allowed_tower_weapons [ i ] then
27017: LD_VAR 0 9
27021: PUSH
27022: LD_EXP 89
27026: PUSH
27027: LD_VAR 0 2
27031: ARRAY
27032: IN
27033: NOT
27034: IFFALSE 27038
// continue ;
27036: GO 26740
// end else
27038: GO 27103
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
27040: LD_ADDR_VAR 0 5
27044: PUSH
27045: LD_EXP 58
27049: PUSH
27050: LD_VAR 0 2
27054: ARRAY
27055: PPUSH
27056: LD_VAR 0 4
27060: PPUSH
27061: CALL 86174 0 2
27065: ST_TO_ADDR
// if not tmp2 then
27066: LD_VAR 0 5
27070: NOT
27071: IFFALSE 27075
// continue ;
27073: GO 26740
// tw := tmp2 [ 1 ] ;
27075: LD_ADDR_VAR 0 7
27079: PUSH
27080: LD_VAR 0 5
27084: PUSH
27085: LD_INT 1
27087: ARRAY
27088: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
27089: LD_ADDR_VAR 0 9
27093: PUSH
27094: LD_VAR 0 5
27098: PUSH
27099: LD_INT 2
27101: ARRAY
27102: ST_TO_ADDR
// end ; if not weapon then
27103: LD_VAR 0 9
27107: NOT
27108: IFFALSE 27112
// continue ;
27110: GO 26740
// ComPlaceWeapon ( tw , weapon ) ;
27112: LD_VAR 0 7
27116: PPUSH
27117: LD_VAR 0 9
27121: PPUSH
27122: CALL_OW 148
// end ;
27126: GO 26740
27128: POP
27129: POP
// end ;
27130: LD_VAR 0 1
27134: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
27135: LD_INT 0
27137: PPUSH
27138: PPUSH
27139: PPUSH
27140: PPUSH
27141: PPUSH
27142: PPUSH
// if not mc_bases then
27143: LD_EXP 50
27147: NOT
27148: IFFALSE 27152
// exit ;
27150: GO 28164
// for i = 1 to mc_bases do
27152: LD_ADDR_VAR 0 2
27156: PUSH
27157: DOUBLE
27158: LD_INT 1
27160: DEC
27161: ST_TO_ADDR
27162: LD_EXP 50
27166: PUSH
27167: FOR_TO
27168: IFFALSE 28162
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
27170: LD_EXP 63
27174: PUSH
27175: LD_VAR 0 2
27179: ARRAY
27180: NOT
27181: PUSH
27182: LD_EXP 63
27186: PUSH
27187: LD_VAR 0 2
27191: ARRAY
27192: PUSH
27193: LD_EXP 64
27197: PUSH
27198: LD_VAR 0 2
27202: ARRAY
27203: EQUAL
27204: OR
27205: IFFALSE 27209
// continue ;
27207: GO 27167
// if mc_miners [ i ] then
27209: LD_EXP 64
27213: PUSH
27214: LD_VAR 0 2
27218: ARRAY
27219: IFFALSE 27849
// begin k := 1 ;
27221: LD_ADDR_VAR 0 4
27225: PUSH
27226: LD_INT 1
27228: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
27229: LD_ADDR_VAR 0 3
27233: PUSH
27234: DOUBLE
27235: LD_EXP 64
27239: PUSH
27240: LD_VAR 0 2
27244: ARRAY
27245: INC
27246: ST_TO_ADDR
27247: LD_INT 1
27249: PUSH
27250: FOR_DOWNTO
27251: IFFALSE 27847
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
27253: LD_EXP 64
27257: PUSH
27258: LD_VAR 0 2
27262: ARRAY
27263: PUSH
27264: LD_VAR 0 3
27268: ARRAY
27269: PPUSH
27270: CALL_OW 301
27274: PUSH
27275: LD_EXP 64
27279: PUSH
27280: LD_VAR 0 2
27284: ARRAY
27285: PUSH
27286: LD_VAR 0 3
27290: ARRAY
27291: PPUSH
27292: CALL_OW 257
27296: PUSH
27297: LD_INT 1
27299: NONEQUAL
27300: OR
27301: IFFALSE 27364
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
27303: LD_ADDR_VAR 0 5
27307: PUSH
27308: LD_EXP 64
27312: PUSH
27313: LD_VAR 0 2
27317: ARRAY
27318: PUSH
27319: LD_EXP 64
27323: PUSH
27324: LD_VAR 0 2
27328: ARRAY
27329: PUSH
27330: LD_VAR 0 3
27334: ARRAY
27335: DIFF
27336: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
27337: LD_ADDR_EXP 64
27341: PUSH
27342: LD_EXP 64
27346: PPUSH
27347: LD_VAR 0 2
27351: PPUSH
27352: LD_VAR 0 5
27356: PPUSH
27357: CALL_OW 1
27361: ST_TO_ADDR
// continue ;
27362: GO 27250
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
27364: LD_EXP 64
27368: PUSH
27369: LD_VAR 0 2
27373: ARRAY
27374: PUSH
27375: LD_VAR 0 3
27379: ARRAY
27380: PPUSH
27381: CALL 51001 0 1
27385: PUSH
27386: LD_EXP 64
27390: PUSH
27391: LD_VAR 0 2
27395: ARRAY
27396: PUSH
27397: LD_VAR 0 3
27401: ARRAY
27402: PPUSH
27403: CALL_OW 255
27407: PPUSH
27408: LD_EXP 63
27412: PUSH
27413: LD_VAR 0 2
27417: ARRAY
27418: PUSH
27419: LD_VAR 0 4
27423: ARRAY
27424: PUSH
27425: LD_INT 1
27427: ARRAY
27428: PPUSH
27429: LD_EXP 63
27433: PUSH
27434: LD_VAR 0 2
27438: ARRAY
27439: PUSH
27440: LD_VAR 0 4
27444: ARRAY
27445: PUSH
27446: LD_INT 2
27448: ARRAY
27449: PPUSH
27450: LD_INT 15
27452: PPUSH
27453: CALL 51961 0 4
27457: PUSH
27458: LD_INT 4
27460: ARRAY
27461: PUSH
27462: LD_EXP 64
27466: PUSH
27467: LD_VAR 0 2
27471: ARRAY
27472: PUSH
27473: LD_VAR 0 3
27477: ARRAY
27478: PPUSH
27479: LD_INT 10
27481: PPUSH
27482: CALL 53658 0 2
27486: PUSH
27487: LD_INT 4
27489: ARRAY
27490: OR
27491: AND
27492: IFFALSE 27515
// ComStop ( mc_miners [ i ] [ j ] ) ;
27494: LD_EXP 64
27498: PUSH
27499: LD_VAR 0 2
27503: ARRAY
27504: PUSH
27505: LD_VAR 0 3
27509: ARRAY
27510: PPUSH
27511: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
27515: LD_EXP 64
27519: PUSH
27520: LD_VAR 0 2
27524: ARRAY
27525: PUSH
27526: LD_VAR 0 3
27530: ARRAY
27531: PPUSH
27532: CALL_OW 257
27536: PUSH
27537: LD_INT 1
27539: EQUAL
27540: PUSH
27541: LD_EXP 64
27545: PUSH
27546: LD_VAR 0 2
27550: ARRAY
27551: PUSH
27552: LD_VAR 0 3
27556: ARRAY
27557: PPUSH
27558: CALL_OW 459
27562: NOT
27563: AND
27564: PUSH
27565: LD_EXP 64
27569: PUSH
27570: LD_VAR 0 2
27574: ARRAY
27575: PUSH
27576: LD_VAR 0 3
27580: ARRAY
27581: PPUSH
27582: CALL_OW 255
27586: PPUSH
27587: LD_EXP 63
27591: PUSH
27592: LD_VAR 0 2
27596: ARRAY
27597: PUSH
27598: LD_VAR 0 4
27602: ARRAY
27603: PUSH
27604: LD_INT 1
27606: ARRAY
27607: PPUSH
27608: LD_EXP 63
27612: PUSH
27613: LD_VAR 0 2
27617: ARRAY
27618: PUSH
27619: LD_VAR 0 4
27623: ARRAY
27624: PUSH
27625: LD_INT 2
27627: ARRAY
27628: PPUSH
27629: LD_INT 15
27631: PPUSH
27632: CALL 51961 0 4
27636: PUSH
27637: LD_INT 4
27639: ARRAY
27640: PUSH
27641: LD_INT 0
27643: EQUAL
27644: AND
27645: PUSH
27646: LD_EXP 64
27650: PUSH
27651: LD_VAR 0 2
27655: ARRAY
27656: PUSH
27657: LD_VAR 0 3
27661: ARRAY
27662: PPUSH
27663: CALL_OW 314
27667: NOT
27668: AND
27669: IFFALSE 27845
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
27671: LD_EXP 64
27675: PUSH
27676: LD_VAR 0 2
27680: ARRAY
27681: PUSH
27682: LD_VAR 0 3
27686: ARRAY
27687: PPUSH
27688: CALL_OW 310
27692: IFFALSE 27715
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
27694: LD_EXP 64
27698: PUSH
27699: LD_VAR 0 2
27703: ARRAY
27704: PUSH
27705: LD_VAR 0 3
27709: ARRAY
27710: PPUSH
27711: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
27715: LD_EXP 64
27719: PUSH
27720: LD_VAR 0 2
27724: ARRAY
27725: PUSH
27726: LD_VAR 0 3
27730: ARRAY
27731: PPUSH
27732: CALL_OW 314
27736: NOT
27737: IFFALSE 27805
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
27739: LD_EXP 64
27743: PUSH
27744: LD_VAR 0 2
27748: ARRAY
27749: PUSH
27750: LD_VAR 0 3
27754: ARRAY
27755: PPUSH
27756: LD_EXP 63
27760: PUSH
27761: LD_VAR 0 2
27765: ARRAY
27766: PUSH
27767: LD_VAR 0 4
27771: ARRAY
27772: PUSH
27773: LD_INT 1
27775: ARRAY
27776: PPUSH
27777: LD_EXP 63
27781: PUSH
27782: LD_VAR 0 2
27786: ARRAY
27787: PUSH
27788: LD_VAR 0 4
27792: ARRAY
27793: PUSH
27794: LD_INT 2
27796: ARRAY
27797: PPUSH
27798: LD_INT 0
27800: PPUSH
27801: CALL_OW 193
// k := k + 1 ;
27805: LD_ADDR_VAR 0 4
27809: PUSH
27810: LD_VAR 0 4
27814: PUSH
27815: LD_INT 1
27817: PLUS
27818: ST_TO_ADDR
// if k > mc_mines [ i ] then
27819: LD_VAR 0 4
27823: PUSH
27824: LD_EXP 63
27828: PUSH
27829: LD_VAR 0 2
27833: ARRAY
27834: GREATER
27835: IFFALSE 27845
// k := 1 ;
27837: LD_ADDR_VAR 0 4
27841: PUSH
27842: LD_INT 1
27844: ST_TO_ADDR
// end ; end ;
27845: GO 27250
27847: POP
27848: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
27849: LD_ADDR_VAR 0 5
27853: PUSH
27854: LD_EXP 50
27858: PUSH
27859: LD_VAR 0 2
27863: ARRAY
27864: PPUSH
27865: LD_INT 2
27867: PUSH
27868: LD_INT 30
27870: PUSH
27871: LD_INT 4
27873: PUSH
27874: EMPTY
27875: LIST
27876: LIST
27877: PUSH
27878: LD_INT 30
27880: PUSH
27881: LD_INT 5
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: LD_INT 30
27890: PUSH
27891: LD_INT 32
27893: PUSH
27894: EMPTY
27895: LIST
27896: LIST
27897: PUSH
27898: EMPTY
27899: LIST
27900: LIST
27901: LIST
27902: LIST
27903: PPUSH
27904: CALL_OW 72
27908: ST_TO_ADDR
// if not tmp then
27909: LD_VAR 0 5
27913: NOT
27914: IFFALSE 27918
// continue ;
27916: GO 27167
// list := [ ] ;
27918: LD_ADDR_VAR 0 6
27922: PUSH
27923: EMPTY
27924: ST_TO_ADDR
// for j in tmp do
27925: LD_ADDR_VAR 0 3
27929: PUSH
27930: LD_VAR 0 5
27934: PUSH
27935: FOR_IN
27936: IFFALSE 28005
// begin for k in UnitsInside ( j ) do
27938: LD_ADDR_VAR 0 4
27942: PUSH
27943: LD_VAR 0 3
27947: PPUSH
27948: CALL_OW 313
27952: PUSH
27953: FOR_IN
27954: IFFALSE 28001
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
27956: LD_VAR 0 4
27960: PPUSH
27961: CALL_OW 257
27965: PUSH
27966: LD_INT 1
27968: EQUAL
27969: PUSH
27970: LD_VAR 0 4
27974: PPUSH
27975: CALL_OW 459
27979: NOT
27980: AND
27981: IFFALSE 27999
// list := list ^ k ;
27983: LD_ADDR_VAR 0 6
27987: PUSH
27988: LD_VAR 0 6
27992: PUSH
27993: LD_VAR 0 4
27997: ADD
27998: ST_TO_ADDR
27999: GO 27953
28001: POP
28002: POP
// end ;
28003: GO 27935
28005: POP
28006: POP
// list := list diff mc_miners [ i ] ;
28007: LD_ADDR_VAR 0 6
28011: PUSH
28012: LD_VAR 0 6
28016: PUSH
28017: LD_EXP 64
28021: PUSH
28022: LD_VAR 0 2
28026: ARRAY
28027: DIFF
28028: ST_TO_ADDR
// if not list then
28029: LD_VAR 0 6
28033: NOT
28034: IFFALSE 28038
// continue ;
28036: GO 27167
// k := mc_mines [ i ] - mc_miners [ i ] ;
28038: LD_ADDR_VAR 0 4
28042: PUSH
28043: LD_EXP 63
28047: PUSH
28048: LD_VAR 0 2
28052: ARRAY
28053: PUSH
28054: LD_EXP 64
28058: PUSH
28059: LD_VAR 0 2
28063: ARRAY
28064: MINUS
28065: ST_TO_ADDR
// if k > list then
28066: LD_VAR 0 4
28070: PUSH
28071: LD_VAR 0 6
28075: GREATER
28076: IFFALSE 28088
// k := list ;
28078: LD_ADDR_VAR 0 4
28082: PUSH
28083: LD_VAR 0 6
28087: ST_TO_ADDR
// for j = 1 to k do
28088: LD_ADDR_VAR 0 3
28092: PUSH
28093: DOUBLE
28094: LD_INT 1
28096: DEC
28097: ST_TO_ADDR
28098: LD_VAR 0 4
28102: PUSH
28103: FOR_TO
28104: IFFALSE 28158
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
28106: LD_ADDR_EXP 64
28110: PUSH
28111: LD_EXP 64
28115: PPUSH
28116: LD_VAR 0 2
28120: PUSH
28121: LD_EXP 64
28125: PUSH
28126: LD_VAR 0 2
28130: ARRAY
28131: PUSH
28132: LD_INT 1
28134: PLUS
28135: PUSH
28136: EMPTY
28137: LIST
28138: LIST
28139: PPUSH
28140: LD_VAR 0 6
28144: PUSH
28145: LD_VAR 0 3
28149: ARRAY
28150: PPUSH
28151: CALL 51065 0 3
28155: ST_TO_ADDR
28156: GO 28103
28158: POP
28159: POP
// end ;
28160: GO 27167
28162: POP
28163: POP
// end ;
28164: LD_VAR 0 1
28168: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
28169: LD_INT 0
28171: PPUSH
28172: PPUSH
28173: PPUSH
28174: PPUSH
28175: PPUSH
28176: PPUSH
28177: PPUSH
28178: PPUSH
28179: PPUSH
28180: PPUSH
// if not mc_bases then
28181: LD_EXP 50
28185: NOT
28186: IFFALSE 28190
// exit ;
28188: GO 29921
// for i = 1 to mc_bases do
28190: LD_ADDR_VAR 0 2
28194: PUSH
28195: DOUBLE
28196: LD_INT 1
28198: DEC
28199: ST_TO_ADDR
28200: LD_EXP 50
28204: PUSH
28205: FOR_TO
28206: IFFALSE 29919
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
28208: LD_EXP 50
28212: PUSH
28213: LD_VAR 0 2
28217: ARRAY
28218: NOT
28219: PUSH
28220: LD_EXP 57
28224: PUSH
28225: LD_VAR 0 2
28229: ARRAY
28230: OR
28231: IFFALSE 28235
// continue ;
28233: GO 28205
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
28235: LD_EXP 66
28239: PUSH
28240: LD_VAR 0 2
28244: ARRAY
28245: NOT
28246: PUSH
28247: LD_EXP 67
28251: PUSH
28252: LD_VAR 0 2
28256: ARRAY
28257: AND
28258: IFFALSE 28296
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
28260: LD_ADDR_EXP 67
28264: PUSH
28265: LD_EXP 67
28269: PPUSH
28270: LD_VAR 0 2
28274: PPUSH
28275: EMPTY
28276: PPUSH
28277: CALL_OW 1
28281: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
28282: LD_VAR 0 2
28286: PPUSH
28287: LD_INT 107
28289: PPUSH
28290: CALL 19708 0 2
// continue ;
28294: GO 28205
// end ; target := [ ] ;
28296: LD_ADDR_VAR 0 6
28300: PUSH
28301: EMPTY
28302: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
28303: LD_ADDR_VAR 0 3
28307: PUSH
28308: DOUBLE
28309: LD_EXP 66
28313: PUSH
28314: LD_VAR 0 2
28318: ARRAY
28319: INC
28320: ST_TO_ADDR
28321: LD_INT 1
28323: PUSH
28324: FOR_DOWNTO
28325: IFFALSE 28585
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
28327: LD_EXP 66
28331: PUSH
28332: LD_VAR 0 2
28336: ARRAY
28337: PUSH
28338: LD_VAR 0 3
28342: ARRAY
28343: PUSH
28344: LD_INT 2
28346: ARRAY
28347: PPUSH
28348: LD_EXP 66
28352: PUSH
28353: LD_VAR 0 2
28357: ARRAY
28358: PUSH
28359: LD_VAR 0 3
28363: ARRAY
28364: PUSH
28365: LD_INT 3
28367: ARRAY
28368: PPUSH
28369: CALL_OW 488
28373: PUSH
28374: LD_EXP 66
28378: PUSH
28379: LD_VAR 0 2
28383: ARRAY
28384: PUSH
28385: LD_VAR 0 3
28389: ARRAY
28390: PUSH
28391: LD_INT 2
28393: ARRAY
28394: PPUSH
28395: LD_EXP 66
28399: PUSH
28400: LD_VAR 0 2
28404: ARRAY
28405: PUSH
28406: LD_VAR 0 3
28410: ARRAY
28411: PUSH
28412: LD_INT 3
28414: ARRAY
28415: PPUSH
28416: CALL_OW 284
28420: PUSH
28421: LD_INT 0
28423: EQUAL
28424: AND
28425: IFFALSE 28480
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
28427: LD_ADDR_VAR 0 5
28431: PUSH
28432: LD_EXP 66
28436: PUSH
28437: LD_VAR 0 2
28441: ARRAY
28442: PPUSH
28443: LD_VAR 0 3
28447: PPUSH
28448: CALL_OW 3
28452: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
28453: LD_ADDR_EXP 66
28457: PUSH
28458: LD_EXP 66
28462: PPUSH
28463: LD_VAR 0 2
28467: PPUSH
28468: LD_VAR 0 5
28472: PPUSH
28473: CALL_OW 1
28477: ST_TO_ADDR
// continue ;
28478: GO 28324
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
28480: LD_EXP 50
28484: PUSH
28485: LD_VAR 0 2
28489: ARRAY
28490: PUSH
28491: LD_INT 1
28493: ARRAY
28494: PPUSH
28495: CALL_OW 255
28499: PPUSH
28500: LD_EXP 66
28504: PUSH
28505: LD_VAR 0 2
28509: ARRAY
28510: PUSH
28511: LD_VAR 0 3
28515: ARRAY
28516: PUSH
28517: LD_INT 2
28519: ARRAY
28520: PPUSH
28521: LD_EXP 66
28525: PUSH
28526: LD_VAR 0 2
28530: ARRAY
28531: PUSH
28532: LD_VAR 0 3
28536: ARRAY
28537: PUSH
28538: LD_INT 3
28540: ARRAY
28541: PPUSH
28542: LD_INT 30
28544: PPUSH
28545: CALL 51961 0 4
28549: PUSH
28550: LD_INT 4
28552: ARRAY
28553: PUSH
28554: LD_INT 0
28556: EQUAL
28557: IFFALSE 28583
// begin target := mc_crates [ i ] [ j ] ;
28559: LD_ADDR_VAR 0 6
28563: PUSH
28564: LD_EXP 66
28568: PUSH
28569: LD_VAR 0 2
28573: ARRAY
28574: PUSH
28575: LD_VAR 0 3
28579: ARRAY
28580: ST_TO_ADDR
// break ;
28581: GO 28585
// end ; end ;
28583: GO 28324
28585: POP
28586: POP
// if not target then
28587: LD_VAR 0 6
28591: NOT
28592: IFFALSE 28596
// continue ;
28594: GO 28205
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
28596: LD_ADDR_VAR 0 7
28600: PUSH
28601: LD_EXP 69
28605: PUSH
28606: LD_VAR 0 2
28610: ARRAY
28611: PPUSH
28612: LD_INT 2
28614: PUSH
28615: LD_INT 3
28617: PUSH
28618: LD_INT 58
28620: PUSH
28621: EMPTY
28622: LIST
28623: PUSH
28624: EMPTY
28625: LIST
28626: LIST
28627: PUSH
28628: LD_INT 61
28630: PUSH
28631: EMPTY
28632: LIST
28633: PUSH
28634: LD_INT 33
28636: PUSH
28637: LD_INT 5
28639: PUSH
28640: EMPTY
28641: LIST
28642: LIST
28643: PUSH
28644: LD_INT 33
28646: PUSH
28647: LD_INT 3
28649: PUSH
28650: EMPTY
28651: LIST
28652: LIST
28653: PUSH
28654: EMPTY
28655: LIST
28656: LIST
28657: LIST
28658: LIST
28659: LIST
28660: PUSH
28661: LD_INT 2
28663: PUSH
28664: LD_INT 34
28666: PUSH
28667: LD_INT 32
28669: PUSH
28670: EMPTY
28671: LIST
28672: LIST
28673: PUSH
28674: LD_INT 34
28676: PUSH
28677: LD_INT 51
28679: PUSH
28680: EMPTY
28681: LIST
28682: LIST
28683: PUSH
28684: LD_INT 34
28686: PUSH
28687: LD_INT 12
28689: PUSH
28690: EMPTY
28691: LIST
28692: LIST
28693: PUSH
28694: EMPTY
28695: LIST
28696: LIST
28697: LIST
28698: LIST
28699: PUSH
28700: EMPTY
28701: LIST
28702: LIST
28703: PPUSH
28704: CALL_OW 72
28708: ST_TO_ADDR
// if not cargo then
28709: LD_VAR 0 7
28713: NOT
28714: IFFALSE 29357
// begin if mc_crates_collector [ i ] < 5 then
28716: LD_EXP 67
28720: PUSH
28721: LD_VAR 0 2
28725: ARRAY
28726: PUSH
28727: LD_INT 5
28729: LESS
28730: IFFALSE 29096
// begin if mc_ape [ i ] then
28732: LD_EXP 79
28736: PUSH
28737: LD_VAR 0 2
28741: ARRAY
28742: IFFALSE 28789
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
28744: LD_ADDR_VAR 0 5
28748: PUSH
28749: LD_EXP 79
28753: PUSH
28754: LD_VAR 0 2
28758: ARRAY
28759: PPUSH
28760: LD_INT 25
28762: PUSH
28763: LD_INT 16
28765: PUSH
28766: EMPTY
28767: LIST
28768: LIST
28769: PUSH
28770: LD_INT 24
28772: PUSH
28773: LD_INT 750
28775: PUSH
28776: EMPTY
28777: LIST
28778: LIST
28779: PUSH
28780: EMPTY
28781: LIST
28782: LIST
28783: PPUSH
28784: CALL_OW 72
28788: ST_TO_ADDR
// if not tmp then
28789: LD_VAR 0 5
28793: NOT
28794: IFFALSE 28841
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
28796: LD_ADDR_VAR 0 5
28800: PUSH
28801: LD_EXP 50
28805: PUSH
28806: LD_VAR 0 2
28810: ARRAY
28811: PPUSH
28812: LD_INT 25
28814: PUSH
28815: LD_INT 2
28817: PUSH
28818: EMPTY
28819: LIST
28820: LIST
28821: PUSH
28822: LD_INT 24
28824: PUSH
28825: LD_INT 750
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: PUSH
28832: EMPTY
28833: LIST
28834: LIST
28835: PPUSH
28836: CALL_OW 72
28840: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
28841: LD_EXP 79
28845: PUSH
28846: LD_VAR 0 2
28850: ARRAY
28851: PUSH
28852: LD_EXP 50
28856: PUSH
28857: LD_VAR 0 2
28861: ARRAY
28862: PPUSH
28863: LD_INT 25
28865: PUSH
28866: LD_INT 2
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: PUSH
28873: LD_INT 24
28875: PUSH
28876: LD_INT 750
28878: PUSH
28879: EMPTY
28880: LIST
28881: LIST
28882: PUSH
28883: EMPTY
28884: LIST
28885: LIST
28886: PPUSH
28887: CALL_OW 72
28891: AND
28892: PUSH
28893: LD_VAR 0 5
28897: PUSH
28898: LD_INT 5
28900: LESS
28901: AND
28902: IFFALSE 28984
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
28904: LD_ADDR_VAR 0 3
28908: PUSH
28909: LD_EXP 50
28913: PUSH
28914: LD_VAR 0 2
28918: ARRAY
28919: PPUSH
28920: LD_INT 25
28922: PUSH
28923: LD_INT 2
28925: PUSH
28926: EMPTY
28927: LIST
28928: LIST
28929: PUSH
28930: LD_INT 24
28932: PUSH
28933: LD_INT 750
28935: PUSH
28936: EMPTY
28937: LIST
28938: LIST
28939: PUSH
28940: EMPTY
28941: LIST
28942: LIST
28943: PPUSH
28944: CALL_OW 72
28948: PUSH
28949: FOR_IN
28950: IFFALSE 28982
// begin tmp := tmp union j ;
28952: LD_ADDR_VAR 0 5
28956: PUSH
28957: LD_VAR 0 5
28961: PUSH
28962: LD_VAR 0 3
28966: UNION
28967: ST_TO_ADDR
// if tmp >= 5 then
28968: LD_VAR 0 5
28972: PUSH
28973: LD_INT 5
28975: GREATEREQUAL
28976: IFFALSE 28980
// break ;
28978: GO 28982
// end ;
28980: GO 28949
28982: POP
28983: POP
// end ; if not tmp then
28984: LD_VAR 0 5
28988: NOT
28989: IFFALSE 28993
// continue ;
28991: GO 28205
// for j in tmp do
28993: LD_ADDR_VAR 0 3
28997: PUSH
28998: LD_VAR 0 5
29002: PUSH
29003: FOR_IN
29004: IFFALSE 29094
// if not GetTag ( j ) then
29006: LD_VAR 0 3
29010: PPUSH
29011: CALL_OW 110
29015: NOT
29016: IFFALSE 29092
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
29018: LD_ADDR_EXP 67
29022: PUSH
29023: LD_EXP 67
29027: PPUSH
29028: LD_VAR 0 2
29032: PUSH
29033: LD_EXP 67
29037: PUSH
29038: LD_VAR 0 2
29042: ARRAY
29043: PUSH
29044: LD_INT 1
29046: PLUS
29047: PUSH
29048: EMPTY
29049: LIST
29050: LIST
29051: PPUSH
29052: LD_VAR 0 3
29056: PPUSH
29057: CALL 51065 0 3
29061: ST_TO_ADDR
// SetTag ( j , 107 ) ;
29062: LD_VAR 0 3
29066: PPUSH
29067: LD_INT 107
29069: PPUSH
29070: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
29074: LD_EXP 67
29078: PUSH
29079: LD_VAR 0 2
29083: ARRAY
29084: PUSH
29085: LD_INT 5
29087: GREATEREQUAL
29088: IFFALSE 29092
// break ;
29090: GO 29094
// end ;
29092: GO 29003
29094: POP
29095: POP
// end ; if mc_crates_collector [ i ] and target then
29096: LD_EXP 67
29100: PUSH
29101: LD_VAR 0 2
29105: ARRAY
29106: PUSH
29107: LD_VAR 0 6
29111: AND
29112: IFFALSE 29355
// begin if mc_crates_collector [ i ] < target [ 1 ] then
29114: LD_EXP 67
29118: PUSH
29119: LD_VAR 0 2
29123: ARRAY
29124: PUSH
29125: LD_VAR 0 6
29129: PUSH
29130: LD_INT 1
29132: ARRAY
29133: LESS
29134: IFFALSE 29154
// tmp := mc_crates_collector [ i ] else
29136: LD_ADDR_VAR 0 5
29140: PUSH
29141: LD_EXP 67
29145: PUSH
29146: LD_VAR 0 2
29150: ARRAY
29151: ST_TO_ADDR
29152: GO 29168
// tmp := target [ 1 ] ;
29154: LD_ADDR_VAR 0 5
29158: PUSH
29159: LD_VAR 0 6
29163: PUSH
29164: LD_INT 1
29166: ARRAY
29167: ST_TO_ADDR
// k := 0 ;
29168: LD_ADDR_VAR 0 4
29172: PUSH
29173: LD_INT 0
29175: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
29176: LD_ADDR_VAR 0 3
29180: PUSH
29181: LD_EXP 67
29185: PUSH
29186: LD_VAR 0 2
29190: ARRAY
29191: PUSH
29192: FOR_IN
29193: IFFALSE 29353
// begin k := k + 1 ;
29195: LD_ADDR_VAR 0 4
29199: PUSH
29200: LD_VAR 0 4
29204: PUSH
29205: LD_INT 1
29207: PLUS
29208: ST_TO_ADDR
// if k > tmp then
29209: LD_VAR 0 4
29213: PUSH
29214: LD_VAR 0 5
29218: GREATER
29219: IFFALSE 29223
// break ;
29221: GO 29353
// if not GetClass ( j ) in [ 2 , 16 ] then
29223: LD_VAR 0 3
29227: PPUSH
29228: CALL_OW 257
29232: PUSH
29233: LD_INT 2
29235: PUSH
29236: LD_INT 16
29238: PUSH
29239: EMPTY
29240: LIST
29241: LIST
29242: IN
29243: NOT
29244: IFFALSE 29297
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
29246: LD_ADDR_EXP 67
29250: PUSH
29251: LD_EXP 67
29255: PPUSH
29256: LD_VAR 0 2
29260: PPUSH
29261: LD_EXP 67
29265: PUSH
29266: LD_VAR 0 2
29270: ARRAY
29271: PUSH
29272: LD_VAR 0 3
29276: DIFF
29277: PPUSH
29278: CALL_OW 1
29282: ST_TO_ADDR
// SetTag ( j , 0 ) ;
29283: LD_VAR 0 3
29287: PPUSH
29288: LD_INT 0
29290: PPUSH
29291: CALL_OW 109
// continue ;
29295: GO 29192
// end ; if IsInUnit ( j ) then
29297: LD_VAR 0 3
29301: PPUSH
29302: CALL_OW 310
29306: IFFALSE 29317
// ComExitBuilding ( j ) ;
29308: LD_VAR 0 3
29312: PPUSH
29313: CALL_OW 122
// wait ( 3 ) ;
29317: LD_INT 3
29319: PPUSH
29320: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
29324: LD_VAR 0 3
29328: PPUSH
29329: LD_VAR 0 6
29333: PUSH
29334: LD_INT 2
29336: ARRAY
29337: PPUSH
29338: LD_VAR 0 6
29342: PUSH
29343: LD_INT 3
29345: ARRAY
29346: PPUSH
29347: CALL_OW 117
// end ;
29351: GO 29192
29353: POP
29354: POP
// end ; end else
29355: GO 29917
// begin for j in cargo do
29357: LD_ADDR_VAR 0 3
29361: PUSH
29362: LD_VAR 0 7
29366: PUSH
29367: FOR_IN
29368: IFFALSE 29915
// begin if GetTag ( j ) <> 0 then
29370: LD_VAR 0 3
29374: PPUSH
29375: CALL_OW 110
29379: PUSH
29380: LD_INT 0
29382: NONEQUAL
29383: IFFALSE 29387
// continue ;
29385: GO 29367
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
29387: LD_VAR 0 3
29391: PPUSH
29392: CALL_OW 256
29396: PUSH
29397: LD_INT 1000
29399: LESS
29400: PUSH
29401: LD_VAR 0 3
29405: PPUSH
29406: LD_EXP 74
29410: PUSH
29411: LD_VAR 0 2
29415: ARRAY
29416: PPUSH
29417: CALL_OW 308
29421: NOT
29422: AND
29423: IFFALSE 29445
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29425: LD_VAR 0 3
29429: PPUSH
29430: LD_EXP 74
29434: PUSH
29435: LD_VAR 0 2
29439: ARRAY
29440: PPUSH
29441: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
29445: LD_VAR 0 3
29449: PPUSH
29450: CALL_OW 256
29454: PUSH
29455: LD_INT 1000
29457: LESS
29458: PUSH
29459: LD_VAR 0 3
29463: PPUSH
29464: LD_EXP 74
29468: PUSH
29469: LD_VAR 0 2
29473: ARRAY
29474: PPUSH
29475: CALL_OW 308
29479: AND
29480: IFFALSE 29484
// continue ;
29482: GO 29367
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
29484: LD_VAR 0 3
29488: PPUSH
29489: CALL_OW 262
29493: PUSH
29494: LD_INT 2
29496: EQUAL
29497: PUSH
29498: LD_VAR 0 3
29502: PPUSH
29503: CALL_OW 261
29507: PUSH
29508: LD_INT 15
29510: LESS
29511: AND
29512: IFFALSE 29516
// continue ;
29514: GO 29367
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
29516: LD_VAR 0 3
29520: PPUSH
29521: CALL_OW 262
29525: PUSH
29526: LD_INT 1
29528: EQUAL
29529: PUSH
29530: LD_VAR 0 3
29534: PPUSH
29535: CALL_OW 261
29539: PUSH
29540: LD_INT 10
29542: LESS
29543: AND
29544: IFFALSE 29854
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29546: LD_ADDR_VAR 0 8
29550: PUSH
29551: LD_EXP 50
29555: PUSH
29556: LD_VAR 0 2
29560: ARRAY
29561: PPUSH
29562: LD_INT 2
29564: PUSH
29565: LD_INT 30
29567: PUSH
29568: LD_INT 0
29570: PUSH
29571: EMPTY
29572: LIST
29573: LIST
29574: PUSH
29575: LD_INT 30
29577: PUSH
29578: LD_INT 1
29580: PUSH
29581: EMPTY
29582: LIST
29583: LIST
29584: PUSH
29585: EMPTY
29586: LIST
29587: LIST
29588: LIST
29589: PPUSH
29590: CALL_OW 72
29594: ST_TO_ADDR
// if not depot then
29595: LD_VAR 0 8
29599: NOT
29600: IFFALSE 29604
// continue ;
29602: GO 29367
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
29604: LD_VAR 0 3
29608: PPUSH
29609: LD_VAR 0 8
29613: PPUSH
29614: LD_VAR 0 3
29618: PPUSH
29619: CALL_OW 74
29623: PPUSH
29624: CALL_OW 296
29628: PUSH
29629: LD_INT 6
29631: LESS
29632: IFFALSE 29648
// SetFuel ( j , 100 ) else
29634: LD_VAR 0 3
29638: PPUSH
29639: LD_INT 100
29641: PPUSH
29642: CALL_OW 240
29646: GO 29854
// if GetFuel ( j ) = 0 then
29648: LD_VAR 0 3
29652: PPUSH
29653: CALL_OW 261
29657: PUSH
29658: LD_INT 0
29660: EQUAL
29661: IFFALSE 29854
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
29663: LD_ADDR_EXP 69
29667: PUSH
29668: LD_EXP 69
29672: PPUSH
29673: LD_VAR 0 2
29677: PPUSH
29678: LD_EXP 69
29682: PUSH
29683: LD_VAR 0 2
29687: ARRAY
29688: PUSH
29689: LD_VAR 0 3
29693: DIFF
29694: PPUSH
29695: CALL_OW 1
29699: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
29700: LD_VAR 0 3
29704: PPUSH
29705: CALL_OW 263
29709: PUSH
29710: LD_INT 1
29712: EQUAL
29713: IFFALSE 29729
// ComExitVehicle ( IsInUnit ( j ) ) ;
29715: LD_VAR 0 3
29719: PPUSH
29720: CALL_OW 310
29724: PPUSH
29725: CALL_OW 121
// if GetControl ( j ) = control_remote then
29729: LD_VAR 0 3
29733: PPUSH
29734: CALL_OW 263
29738: PUSH
29739: LD_INT 2
29741: EQUAL
29742: IFFALSE 29753
// ComUnlink ( j ) ;
29744: LD_VAR 0 3
29748: PPUSH
29749: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
29753: LD_ADDR_VAR 0 9
29757: PUSH
29758: LD_VAR 0 2
29762: PPUSH
29763: LD_INT 3
29765: PPUSH
29766: CALL 39016 0 2
29770: ST_TO_ADDR
// if fac then
29771: LD_VAR 0 9
29775: IFFALSE 29852
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
29777: LD_ADDR_VAR 0 10
29781: PUSH
29782: LD_VAR 0 9
29786: PPUSH
29787: LD_VAR 0 3
29791: PPUSH
29792: CALL_OW 265
29796: PPUSH
29797: LD_VAR 0 3
29801: PPUSH
29802: CALL_OW 262
29806: PPUSH
29807: LD_VAR 0 3
29811: PPUSH
29812: CALL_OW 263
29816: PPUSH
29817: LD_VAR 0 3
29821: PPUSH
29822: CALL_OW 264
29826: PPUSH
29827: CALL 48665 0 5
29831: ST_TO_ADDR
// if components then
29832: LD_VAR 0 10
29836: IFFALSE 29852
// MC_InsertProduceList ( i , components ) ;
29838: LD_VAR 0 2
29842: PPUSH
29843: LD_VAR 0 10
29847: PPUSH
29848: CALL 38586 0 2
// end ; continue ;
29852: GO 29367
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
29854: LD_VAR 0 3
29858: PPUSH
29859: LD_INT 1
29861: PPUSH
29862: CALL_OW 289
29866: PUSH
29867: LD_INT 100
29869: LESS
29870: PUSH
29871: LD_VAR 0 3
29875: PPUSH
29876: CALL_OW 314
29880: NOT
29881: AND
29882: IFFALSE 29911
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
29884: LD_VAR 0 3
29888: PPUSH
29889: LD_VAR 0 6
29893: PUSH
29894: LD_INT 2
29896: ARRAY
29897: PPUSH
29898: LD_VAR 0 6
29902: PUSH
29903: LD_INT 3
29905: ARRAY
29906: PPUSH
29907: CALL_OW 117
// break ;
29911: GO 29915
// end ;
29913: GO 29367
29915: POP
29916: POP
// end ; end ;
29917: GO 28205
29919: POP
29920: POP
// end ;
29921: LD_VAR 0 1
29925: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
29926: LD_INT 0
29928: PPUSH
29929: PPUSH
29930: PPUSH
29931: PPUSH
// if not mc_bases then
29932: LD_EXP 50
29936: NOT
29937: IFFALSE 29941
// exit ;
29939: GO 30102
// for i = 1 to mc_bases do
29941: LD_ADDR_VAR 0 2
29945: PUSH
29946: DOUBLE
29947: LD_INT 1
29949: DEC
29950: ST_TO_ADDR
29951: LD_EXP 50
29955: PUSH
29956: FOR_TO
29957: IFFALSE 30100
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
29959: LD_ADDR_VAR 0 4
29963: PUSH
29964: LD_EXP 69
29968: PUSH
29969: LD_VAR 0 2
29973: ARRAY
29974: PUSH
29975: LD_EXP 72
29979: PUSH
29980: LD_VAR 0 2
29984: ARRAY
29985: UNION
29986: PPUSH
29987: LD_INT 33
29989: PUSH
29990: LD_INT 2
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PPUSH
29997: CALL_OW 72
30001: ST_TO_ADDR
// if tmp then
30002: LD_VAR 0 4
30006: IFFALSE 30098
// for j in tmp do
30008: LD_ADDR_VAR 0 3
30012: PUSH
30013: LD_VAR 0 4
30017: PUSH
30018: FOR_IN
30019: IFFALSE 30096
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
30021: LD_VAR 0 3
30025: PPUSH
30026: CALL_OW 312
30030: NOT
30031: PUSH
30032: LD_VAR 0 3
30036: PPUSH
30037: CALL_OW 256
30041: PUSH
30042: LD_INT 250
30044: GREATEREQUAL
30045: AND
30046: IFFALSE 30059
// Connect ( j ) else
30048: LD_VAR 0 3
30052: PPUSH
30053: CALL 53998 0 1
30057: GO 30094
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
30059: LD_VAR 0 3
30063: PPUSH
30064: CALL_OW 256
30068: PUSH
30069: LD_INT 250
30071: LESS
30072: PUSH
30073: LD_VAR 0 3
30077: PPUSH
30078: CALL_OW 312
30082: AND
30083: IFFALSE 30094
// ComUnlink ( j ) ;
30085: LD_VAR 0 3
30089: PPUSH
30090: CALL_OW 136
30094: GO 30018
30096: POP
30097: POP
// end ;
30098: GO 29956
30100: POP
30101: POP
// end ;
30102: LD_VAR 0 1
30106: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
30107: LD_INT 0
30109: PPUSH
30110: PPUSH
30111: PPUSH
30112: PPUSH
30113: PPUSH
// if not mc_bases then
30114: LD_EXP 50
30118: NOT
30119: IFFALSE 30123
// exit ;
30121: GO 30583
// for i = 1 to mc_bases do
30123: LD_ADDR_VAR 0 2
30127: PUSH
30128: DOUBLE
30129: LD_INT 1
30131: DEC
30132: ST_TO_ADDR
30133: LD_EXP 50
30137: PUSH
30138: FOR_TO
30139: IFFALSE 30581
// begin if not mc_produce [ i ] then
30141: LD_EXP 71
30145: PUSH
30146: LD_VAR 0 2
30150: ARRAY
30151: NOT
30152: IFFALSE 30156
// continue ;
30154: GO 30138
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30156: LD_ADDR_VAR 0 5
30160: PUSH
30161: LD_EXP 50
30165: PUSH
30166: LD_VAR 0 2
30170: ARRAY
30171: PPUSH
30172: LD_INT 30
30174: PUSH
30175: LD_INT 3
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PPUSH
30182: CALL_OW 72
30186: ST_TO_ADDR
// if not fac then
30187: LD_VAR 0 5
30191: NOT
30192: IFFALSE 30196
// continue ;
30194: GO 30138
// for j in fac do
30196: LD_ADDR_VAR 0 3
30200: PUSH
30201: LD_VAR 0 5
30205: PUSH
30206: FOR_IN
30207: IFFALSE 30577
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
30209: LD_VAR 0 3
30213: PPUSH
30214: CALL_OW 461
30218: PUSH
30219: LD_INT 2
30221: NONEQUAL
30222: PUSH
30223: LD_VAR 0 3
30227: PPUSH
30228: LD_INT 15
30230: PPUSH
30231: CALL 53658 0 2
30235: PUSH
30236: LD_INT 4
30238: ARRAY
30239: OR
30240: PUSH
30241: LD_VAR 0 3
30245: PPUSH
30246: CALL_OW 313
30250: PUSH
30251: LD_INT 0
30253: EQUAL
30254: OR
30255: IFFALSE 30259
// continue ;
30257: GO 30206
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
30259: LD_VAR 0 3
30263: PPUSH
30264: LD_EXP 71
30268: PUSH
30269: LD_VAR 0 2
30273: ARRAY
30274: PUSH
30275: LD_INT 1
30277: ARRAY
30278: PUSH
30279: LD_INT 1
30281: ARRAY
30282: PPUSH
30283: LD_EXP 71
30287: PUSH
30288: LD_VAR 0 2
30292: ARRAY
30293: PUSH
30294: LD_INT 1
30296: ARRAY
30297: PUSH
30298: LD_INT 2
30300: ARRAY
30301: PPUSH
30302: LD_EXP 71
30306: PUSH
30307: LD_VAR 0 2
30311: ARRAY
30312: PUSH
30313: LD_INT 1
30315: ARRAY
30316: PUSH
30317: LD_INT 3
30319: ARRAY
30320: PPUSH
30321: LD_EXP 71
30325: PUSH
30326: LD_VAR 0 2
30330: ARRAY
30331: PUSH
30332: LD_INT 1
30334: ARRAY
30335: PUSH
30336: LD_INT 4
30338: ARRAY
30339: PPUSH
30340: CALL_OW 448
30344: PUSH
30345: LD_VAR 0 3
30349: PPUSH
30350: LD_EXP 71
30354: PUSH
30355: LD_VAR 0 2
30359: ARRAY
30360: PUSH
30361: LD_INT 1
30363: ARRAY
30364: PUSH
30365: LD_INT 1
30367: ARRAY
30368: PUSH
30369: LD_EXP 71
30373: PUSH
30374: LD_VAR 0 2
30378: ARRAY
30379: PUSH
30380: LD_INT 1
30382: ARRAY
30383: PUSH
30384: LD_INT 2
30386: ARRAY
30387: PUSH
30388: LD_EXP 71
30392: PUSH
30393: LD_VAR 0 2
30397: ARRAY
30398: PUSH
30399: LD_INT 1
30401: ARRAY
30402: PUSH
30403: LD_INT 3
30405: ARRAY
30406: PUSH
30407: LD_EXP 71
30411: PUSH
30412: LD_VAR 0 2
30416: ARRAY
30417: PUSH
30418: LD_INT 1
30420: ARRAY
30421: PUSH
30422: LD_INT 4
30424: ARRAY
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: LIST
30430: LIST
30431: PPUSH
30432: CALL 57329 0 2
30436: AND
30437: IFFALSE 30575
// begin ComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
30439: LD_VAR 0 3
30443: PPUSH
30444: LD_EXP 71
30448: PUSH
30449: LD_VAR 0 2
30453: ARRAY
30454: PUSH
30455: LD_INT 1
30457: ARRAY
30458: PUSH
30459: LD_INT 1
30461: ARRAY
30462: PPUSH
30463: LD_EXP 71
30467: PUSH
30468: LD_VAR 0 2
30472: ARRAY
30473: PUSH
30474: LD_INT 1
30476: ARRAY
30477: PUSH
30478: LD_INT 2
30480: ARRAY
30481: PPUSH
30482: LD_EXP 71
30486: PUSH
30487: LD_VAR 0 2
30491: ARRAY
30492: PUSH
30493: LD_INT 1
30495: ARRAY
30496: PUSH
30497: LD_INT 3
30499: ARRAY
30500: PPUSH
30501: LD_EXP 71
30505: PUSH
30506: LD_VAR 0 2
30510: ARRAY
30511: PUSH
30512: LD_INT 1
30514: ARRAY
30515: PUSH
30516: LD_INT 4
30518: ARRAY
30519: PPUSH
30520: CALL_OW 125
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
30524: LD_ADDR_VAR 0 4
30528: PUSH
30529: LD_EXP 71
30533: PUSH
30534: LD_VAR 0 2
30538: ARRAY
30539: PPUSH
30540: LD_INT 1
30542: PPUSH
30543: CALL_OW 3
30547: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
30548: LD_ADDR_EXP 71
30552: PUSH
30553: LD_EXP 71
30557: PPUSH
30558: LD_VAR 0 2
30562: PPUSH
30563: LD_VAR 0 4
30567: PPUSH
30568: CALL_OW 1
30572: ST_TO_ADDR
// break ;
30573: GO 30577
// end ; end ;
30575: GO 30206
30577: POP
30578: POP
// end ;
30579: GO 30138
30581: POP
30582: POP
// end ;
30583: LD_VAR 0 1
30587: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
30588: LD_INT 0
30590: PPUSH
30591: PPUSH
30592: PPUSH
// if not mc_bases then
30593: LD_EXP 50
30597: NOT
30598: IFFALSE 30602
// exit ;
30600: GO 30691
// for i = 1 to mc_bases do
30602: LD_ADDR_VAR 0 2
30606: PUSH
30607: DOUBLE
30608: LD_INT 1
30610: DEC
30611: ST_TO_ADDR
30612: LD_EXP 50
30616: PUSH
30617: FOR_TO
30618: IFFALSE 30689
// begin if mc_attack [ i ] then
30620: LD_EXP 70
30624: PUSH
30625: LD_VAR 0 2
30629: ARRAY
30630: IFFALSE 30687
// begin tmp := mc_attack [ i ] [ 1 ] ;
30632: LD_ADDR_VAR 0 3
30636: PUSH
30637: LD_EXP 70
30641: PUSH
30642: LD_VAR 0 2
30646: ARRAY
30647: PUSH
30648: LD_INT 1
30650: ARRAY
30651: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
30652: LD_ADDR_EXP 70
30656: PUSH
30657: LD_EXP 70
30661: PPUSH
30662: LD_VAR 0 2
30666: PPUSH
30667: EMPTY
30668: PPUSH
30669: CALL_OW 1
30673: ST_TO_ADDR
// Attack ( tmp ) ;
30674: LD_VAR 0 3
30678: PPUSH
30679: CALL 79518 0 1
// exit ;
30683: POP
30684: POP
30685: GO 30691
// end ; end ;
30687: GO 30617
30689: POP
30690: POP
// end ;
30691: LD_VAR 0 1
30695: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
30696: LD_INT 0
30698: PPUSH
30699: PPUSH
30700: PPUSH
30701: PPUSH
30702: PPUSH
30703: PPUSH
30704: PPUSH
// if not mc_bases then
30705: LD_EXP 50
30709: NOT
30710: IFFALSE 30714
// exit ;
30712: GO 31318
// for i = 1 to mc_bases do
30714: LD_ADDR_VAR 0 2
30718: PUSH
30719: DOUBLE
30720: LD_INT 1
30722: DEC
30723: ST_TO_ADDR
30724: LD_EXP 50
30728: PUSH
30729: FOR_TO
30730: IFFALSE 31316
// begin if not mc_bases [ i ] then
30732: LD_EXP 50
30736: PUSH
30737: LD_VAR 0 2
30741: ARRAY
30742: NOT
30743: IFFALSE 30747
// continue ;
30745: GO 30729
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
30747: LD_ADDR_VAR 0 7
30751: PUSH
30752: LD_EXP 50
30756: PUSH
30757: LD_VAR 0 2
30761: ARRAY
30762: PUSH
30763: LD_INT 1
30765: ARRAY
30766: PPUSH
30767: CALL 47969 0 1
30771: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
30772: LD_ADDR_EXP 73
30776: PUSH
30777: LD_EXP 73
30781: PPUSH
30782: LD_VAR 0 2
30786: PPUSH
30787: LD_EXP 50
30791: PUSH
30792: LD_VAR 0 2
30796: ARRAY
30797: PUSH
30798: LD_INT 1
30800: ARRAY
30801: PPUSH
30802: CALL_OW 255
30806: PPUSH
30807: LD_EXP 75
30811: PUSH
30812: LD_VAR 0 2
30816: ARRAY
30817: PPUSH
30818: CALL 45929 0 2
30822: PPUSH
30823: CALL_OW 1
30827: ST_TO_ADDR
// if not mc_scan [ i ] then
30828: LD_EXP 73
30832: PUSH
30833: LD_VAR 0 2
30837: ARRAY
30838: NOT
30839: IFFALSE 30994
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
30841: LD_ADDR_VAR 0 4
30845: PUSH
30846: LD_EXP 50
30850: PUSH
30851: LD_VAR 0 2
30855: ARRAY
30856: PPUSH
30857: LD_INT 2
30859: PUSH
30860: LD_INT 25
30862: PUSH
30863: LD_INT 5
30865: PUSH
30866: EMPTY
30867: LIST
30868: LIST
30869: PUSH
30870: LD_INT 25
30872: PUSH
30873: LD_INT 8
30875: PUSH
30876: EMPTY
30877: LIST
30878: LIST
30879: PUSH
30880: LD_INT 25
30882: PUSH
30883: LD_INT 9
30885: PUSH
30886: EMPTY
30887: LIST
30888: LIST
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: LIST
30894: LIST
30895: PPUSH
30896: CALL_OW 72
30900: ST_TO_ADDR
// if not tmp then
30901: LD_VAR 0 4
30905: NOT
30906: IFFALSE 30910
// continue ;
30908: GO 30729
// for j in tmp do
30910: LD_ADDR_VAR 0 3
30914: PUSH
30915: LD_VAR 0 4
30919: PUSH
30920: FOR_IN
30921: IFFALSE 30992
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
30923: LD_VAR 0 3
30927: PPUSH
30928: CALL_OW 310
30932: PPUSH
30933: CALL_OW 266
30937: PUSH
30938: LD_INT 5
30940: EQUAL
30941: PUSH
30942: LD_VAR 0 3
30946: PPUSH
30947: CALL_OW 257
30951: PUSH
30952: LD_INT 1
30954: EQUAL
30955: AND
30956: PUSH
30957: LD_VAR 0 3
30961: PPUSH
30962: CALL_OW 459
30966: NOT
30967: AND
30968: PUSH
30969: LD_VAR 0 7
30973: AND
30974: IFFALSE 30990
// ComChangeProfession ( j , class ) ;
30976: LD_VAR 0 3
30980: PPUSH
30981: LD_VAR 0 7
30985: PPUSH
30986: CALL_OW 123
30990: GO 30920
30992: POP
30993: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
30994: LD_EXP 73
30998: PUSH
30999: LD_VAR 0 2
31003: ARRAY
31004: PUSH
31005: LD_EXP 72
31009: PUSH
31010: LD_VAR 0 2
31014: ARRAY
31015: NOT
31016: AND
31017: PUSH
31018: LD_EXP 50
31022: PUSH
31023: LD_VAR 0 2
31027: ARRAY
31028: PPUSH
31029: LD_INT 30
31031: PUSH
31032: LD_INT 32
31034: PUSH
31035: EMPTY
31036: LIST
31037: LIST
31038: PPUSH
31039: CALL_OW 72
31043: NOT
31044: AND
31045: PUSH
31046: LD_EXP 50
31050: PUSH
31051: LD_VAR 0 2
31055: ARRAY
31056: PPUSH
31057: LD_INT 2
31059: PUSH
31060: LD_INT 30
31062: PUSH
31063: LD_INT 4
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: LD_INT 30
31072: PUSH
31073: LD_INT 5
31075: PUSH
31076: EMPTY
31077: LIST
31078: LIST
31079: PUSH
31080: EMPTY
31081: LIST
31082: LIST
31083: LIST
31084: PPUSH
31085: CALL_OW 72
31089: NOT
31090: AND
31091: IFFALSE 31223
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
31093: LD_ADDR_VAR 0 4
31097: PUSH
31098: LD_EXP 50
31102: PUSH
31103: LD_VAR 0 2
31107: ARRAY
31108: PPUSH
31109: LD_INT 2
31111: PUSH
31112: LD_INT 25
31114: PUSH
31115: LD_INT 1
31117: PUSH
31118: EMPTY
31119: LIST
31120: LIST
31121: PUSH
31122: LD_INT 25
31124: PUSH
31125: LD_INT 5
31127: PUSH
31128: EMPTY
31129: LIST
31130: LIST
31131: PUSH
31132: LD_INT 25
31134: PUSH
31135: LD_INT 8
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: PUSH
31142: LD_INT 25
31144: PUSH
31145: LD_INT 9
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: LIST
31156: LIST
31157: LIST
31158: PPUSH
31159: CALL_OW 72
31163: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
31164: LD_ADDR_VAR 0 4
31168: PUSH
31169: LD_VAR 0 4
31173: PUSH
31174: LD_VAR 0 4
31178: PPUSH
31179: LD_INT 18
31181: PPUSH
31182: CALL 84262 0 2
31186: DIFF
31187: ST_TO_ADDR
// if tmp then
31188: LD_VAR 0 4
31192: IFFALSE 31223
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
31194: LD_VAR 0 2
31198: PPUSH
31199: LD_VAR 0 4
31203: PPUSH
31204: LD_EXP 75
31208: PUSH
31209: LD_VAR 0 2
31213: ARRAY
31214: PPUSH
31215: CALL 45964 0 3
// exit ;
31219: POP
31220: POP
31221: GO 31318
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
31223: LD_EXP 73
31227: PUSH
31228: LD_VAR 0 2
31232: ARRAY
31233: PUSH
31234: LD_EXP 72
31238: PUSH
31239: LD_VAR 0 2
31243: ARRAY
31244: AND
31245: IFFALSE 31314
// begin tmp := mc_defender [ i ] ;
31247: LD_ADDR_VAR 0 4
31251: PUSH
31252: LD_EXP 72
31256: PUSH
31257: LD_VAR 0 2
31261: ARRAY
31262: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
31263: LD_ADDR_EXP 72
31267: PUSH
31268: LD_EXP 72
31272: PPUSH
31273: LD_VAR 0 2
31277: PPUSH
31278: EMPTY
31279: PPUSH
31280: CALL_OW 1
31284: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
31285: LD_VAR 0 2
31289: PPUSH
31290: LD_VAR 0 4
31294: PPUSH
31295: LD_EXP 73
31299: PUSH
31300: LD_VAR 0 2
31304: ARRAY
31305: PPUSH
31306: CALL 46462 0 3
// exit ;
31310: POP
31311: POP
31312: GO 31318
// end ; end ;
31314: GO 30729
31316: POP
31317: POP
// end ;
31318: LD_VAR 0 1
31322: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
31323: LD_INT 0
31325: PPUSH
31326: PPUSH
31327: PPUSH
31328: PPUSH
31329: PPUSH
31330: PPUSH
31331: PPUSH
31332: PPUSH
31333: PPUSH
31334: PPUSH
31335: PPUSH
// if not mc_bases then
31336: LD_EXP 50
31340: NOT
31341: IFFALSE 31345
// exit ;
31343: GO 32432
// for i = 1 to mc_bases do
31345: LD_ADDR_VAR 0 2
31349: PUSH
31350: DOUBLE
31351: LD_INT 1
31353: DEC
31354: ST_TO_ADDR
31355: LD_EXP 50
31359: PUSH
31360: FOR_TO
31361: IFFALSE 32430
// begin tmp := mc_lab [ i ] ;
31363: LD_ADDR_VAR 0 6
31367: PUSH
31368: LD_EXP 83
31372: PUSH
31373: LD_VAR 0 2
31377: ARRAY
31378: ST_TO_ADDR
// if not tmp then
31379: LD_VAR 0 6
31383: NOT
31384: IFFALSE 31388
// continue ;
31386: GO 31360
// idle_lab := 0 ;
31388: LD_ADDR_VAR 0 11
31392: PUSH
31393: LD_INT 0
31395: ST_TO_ADDR
// for j in tmp do
31396: LD_ADDR_VAR 0 3
31400: PUSH
31401: LD_VAR 0 6
31405: PUSH
31406: FOR_IN
31407: IFFALSE 32426
// begin researching := false ;
31409: LD_ADDR_VAR 0 10
31413: PUSH
31414: LD_INT 0
31416: ST_TO_ADDR
// side := GetSide ( j ) ;
31417: LD_ADDR_VAR 0 4
31421: PUSH
31422: LD_VAR 0 3
31426: PPUSH
31427: CALL_OW 255
31431: ST_TO_ADDR
// if not mc_tech [ side ] then
31432: LD_EXP 77
31436: PUSH
31437: LD_VAR 0 4
31441: ARRAY
31442: NOT
31443: IFFALSE 31447
// continue ;
31445: GO 31406
// if BuildingStatus ( j ) = bs_idle then
31447: LD_VAR 0 3
31451: PPUSH
31452: CALL_OW 461
31456: PUSH
31457: LD_INT 2
31459: EQUAL
31460: IFFALSE 31648
// begin if idle_lab and UnitsInside ( j ) < 6 then
31462: LD_VAR 0 11
31466: PUSH
31467: LD_VAR 0 3
31471: PPUSH
31472: CALL_OW 313
31476: PUSH
31477: LD_INT 6
31479: LESS
31480: AND
31481: IFFALSE 31552
// begin tmp2 := UnitsInside ( idle_lab ) ;
31483: LD_ADDR_VAR 0 9
31487: PUSH
31488: LD_VAR 0 11
31492: PPUSH
31493: CALL_OW 313
31497: ST_TO_ADDR
// if tmp2 then
31498: LD_VAR 0 9
31502: IFFALSE 31544
// for x in tmp2 do
31504: LD_ADDR_VAR 0 7
31508: PUSH
31509: LD_VAR 0 9
31513: PUSH
31514: FOR_IN
31515: IFFALSE 31542
// begin ComExitBuilding ( x ) ;
31517: LD_VAR 0 7
31521: PPUSH
31522: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
31526: LD_VAR 0 7
31530: PPUSH
31531: LD_VAR 0 3
31535: PPUSH
31536: CALL_OW 180
// end ;
31540: GO 31514
31542: POP
31543: POP
// idle_lab := 0 ;
31544: LD_ADDR_VAR 0 11
31548: PUSH
31549: LD_INT 0
31551: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
31552: LD_ADDR_VAR 0 5
31556: PUSH
31557: LD_EXP 77
31561: PUSH
31562: LD_VAR 0 4
31566: ARRAY
31567: PUSH
31568: FOR_IN
31569: IFFALSE 31629
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
31571: LD_VAR 0 3
31575: PPUSH
31576: LD_VAR 0 5
31580: PPUSH
31581: CALL_OW 430
31585: PUSH
31586: LD_VAR 0 4
31590: PPUSH
31591: LD_VAR 0 5
31595: PPUSH
31596: CALL 45034 0 2
31600: AND
31601: IFFALSE 31627
// begin researching := true ;
31603: LD_ADDR_VAR 0 10
31607: PUSH
31608: LD_INT 1
31610: ST_TO_ADDR
// ComResearch ( j , t ) ;
31611: LD_VAR 0 3
31615: PPUSH
31616: LD_VAR 0 5
31620: PPUSH
31621: CALL_OW 124
// break ;
31625: GO 31629
// end ;
31627: GO 31568
31629: POP
31630: POP
// if not researching then
31631: LD_VAR 0 10
31635: NOT
31636: IFFALSE 31648
// idle_lab := j ;
31638: LD_ADDR_VAR 0 11
31642: PUSH
31643: LD_VAR 0 3
31647: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
31648: LD_VAR 0 3
31652: PPUSH
31653: CALL_OW 461
31657: PUSH
31658: LD_INT 10
31660: EQUAL
31661: IFFALSE 32249
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
31663: LD_EXP 79
31667: PUSH
31668: LD_VAR 0 2
31672: ARRAY
31673: NOT
31674: PUSH
31675: LD_EXP 80
31679: PUSH
31680: LD_VAR 0 2
31684: ARRAY
31685: NOT
31686: AND
31687: PUSH
31688: LD_EXP 77
31692: PUSH
31693: LD_VAR 0 4
31697: ARRAY
31698: PUSH
31699: LD_INT 1
31701: GREATER
31702: AND
31703: IFFALSE 31834
// begin ComCancel ( j ) ;
31705: LD_VAR 0 3
31709: PPUSH
31710: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
31714: LD_ADDR_EXP 77
31718: PUSH
31719: LD_EXP 77
31723: PPUSH
31724: LD_VAR 0 4
31728: PPUSH
31729: LD_EXP 77
31733: PUSH
31734: LD_VAR 0 4
31738: ARRAY
31739: PPUSH
31740: LD_EXP 77
31744: PUSH
31745: LD_VAR 0 4
31749: ARRAY
31750: PUSH
31751: LD_INT 1
31753: MINUS
31754: PPUSH
31755: LD_EXP 77
31759: PUSH
31760: LD_VAR 0 4
31764: ARRAY
31765: PPUSH
31766: LD_INT 0
31768: PPUSH
31769: CALL 50483 0 4
31773: PPUSH
31774: CALL_OW 1
31778: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
31779: LD_ADDR_EXP 77
31783: PUSH
31784: LD_EXP 77
31788: PPUSH
31789: LD_VAR 0 4
31793: PPUSH
31794: LD_EXP 77
31798: PUSH
31799: LD_VAR 0 4
31803: ARRAY
31804: PPUSH
31805: LD_EXP 77
31809: PUSH
31810: LD_VAR 0 4
31814: ARRAY
31815: PPUSH
31816: LD_INT 1
31818: PPUSH
31819: LD_INT 0
31821: PPUSH
31822: CALL 50483 0 4
31826: PPUSH
31827: CALL_OW 1
31831: ST_TO_ADDR
// continue ;
31832: GO 31406
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
31834: LD_EXP 79
31838: PUSH
31839: LD_VAR 0 2
31843: ARRAY
31844: PUSH
31845: LD_EXP 80
31849: PUSH
31850: LD_VAR 0 2
31854: ARRAY
31855: NOT
31856: AND
31857: IFFALSE 31984
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
31859: LD_ADDR_EXP 80
31863: PUSH
31864: LD_EXP 80
31868: PPUSH
31869: LD_VAR 0 2
31873: PUSH
31874: LD_EXP 80
31878: PUSH
31879: LD_VAR 0 2
31883: ARRAY
31884: PUSH
31885: LD_INT 1
31887: PLUS
31888: PUSH
31889: EMPTY
31890: LIST
31891: LIST
31892: PPUSH
31893: LD_EXP 79
31897: PUSH
31898: LD_VAR 0 2
31902: ARRAY
31903: PUSH
31904: LD_INT 1
31906: ARRAY
31907: PPUSH
31908: CALL 51065 0 3
31912: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
31913: LD_EXP 79
31917: PUSH
31918: LD_VAR 0 2
31922: ARRAY
31923: PUSH
31924: LD_INT 1
31926: ARRAY
31927: PPUSH
31928: LD_INT 112
31930: PPUSH
31931: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
31935: LD_ADDR_VAR 0 9
31939: PUSH
31940: LD_EXP 79
31944: PUSH
31945: LD_VAR 0 2
31949: ARRAY
31950: PPUSH
31951: LD_INT 1
31953: PPUSH
31954: CALL_OW 3
31958: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
31959: LD_ADDR_EXP 79
31963: PUSH
31964: LD_EXP 79
31968: PPUSH
31969: LD_VAR 0 2
31973: PPUSH
31974: LD_VAR 0 9
31978: PPUSH
31979: CALL_OW 1
31983: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
31984: LD_EXP 79
31988: PUSH
31989: LD_VAR 0 2
31993: ARRAY
31994: PUSH
31995: LD_EXP 80
31999: PUSH
32000: LD_VAR 0 2
32004: ARRAY
32005: AND
32006: PUSH
32007: LD_EXP 80
32011: PUSH
32012: LD_VAR 0 2
32016: ARRAY
32017: PUSH
32018: LD_INT 1
32020: ARRAY
32021: PPUSH
32022: CALL_OW 310
32026: NOT
32027: AND
32028: PUSH
32029: LD_VAR 0 3
32033: PPUSH
32034: CALL_OW 313
32038: PUSH
32039: LD_INT 6
32041: EQUAL
32042: AND
32043: IFFALSE 32099
// begin tmp2 := UnitsInside ( j ) ;
32045: LD_ADDR_VAR 0 9
32049: PUSH
32050: LD_VAR 0 3
32054: PPUSH
32055: CALL_OW 313
32059: ST_TO_ADDR
// if tmp2 = 6 then
32060: LD_VAR 0 9
32064: PUSH
32065: LD_INT 6
32067: EQUAL
32068: IFFALSE 32099
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
32070: LD_VAR 0 9
32074: PUSH
32075: LD_INT 1
32077: ARRAY
32078: PPUSH
32079: LD_INT 112
32081: PPUSH
32082: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
32086: LD_VAR 0 9
32090: PUSH
32091: LD_INT 1
32093: ARRAY
32094: PPUSH
32095: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
32099: LD_EXP 80
32103: PUSH
32104: LD_VAR 0 2
32108: ARRAY
32109: PUSH
32110: LD_EXP 80
32114: PUSH
32115: LD_VAR 0 2
32119: ARRAY
32120: PUSH
32121: LD_INT 1
32123: ARRAY
32124: PPUSH
32125: CALL_OW 314
32129: NOT
32130: AND
32131: PUSH
32132: LD_EXP 80
32136: PUSH
32137: LD_VAR 0 2
32141: ARRAY
32142: PUSH
32143: LD_INT 1
32145: ARRAY
32146: PPUSH
32147: CALL_OW 310
32151: NOT
32152: AND
32153: IFFALSE 32179
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
32155: LD_EXP 80
32159: PUSH
32160: LD_VAR 0 2
32164: ARRAY
32165: PUSH
32166: LD_INT 1
32168: ARRAY
32169: PPUSH
32170: LD_VAR 0 3
32174: PPUSH
32175: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
32179: LD_EXP 80
32183: PUSH
32184: LD_VAR 0 2
32188: ARRAY
32189: PUSH
32190: LD_INT 1
32192: ARRAY
32193: PPUSH
32194: CALL_OW 310
32198: PUSH
32199: LD_EXP 80
32203: PUSH
32204: LD_VAR 0 2
32208: ARRAY
32209: PUSH
32210: LD_INT 1
32212: ARRAY
32213: PPUSH
32214: CALL_OW 310
32218: PPUSH
32219: CALL_OW 461
32223: PUSH
32224: LD_INT 3
32226: NONEQUAL
32227: AND
32228: IFFALSE 32249
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
32230: LD_EXP 80
32234: PUSH
32235: LD_VAR 0 2
32239: ARRAY
32240: PUSH
32241: LD_INT 1
32243: ARRAY
32244: PPUSH
32245: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
32249: LD_VAR 0 3
32253: PPUSH
32254: CALL_OW 461
32258: PUSH
32259: LD_INT 6
32261: EQUAL
32262: PUSH
32263: LD_VAR 0 6
32267: PUSH
32268: LD_INT 1
32270: GREATER
32271: AND
32272: IFFALSE 32424
// begin sci := [ ] ;
32274: LD_ADDR_VAR 0 8
32278: PUSH
32279: EMPTY
32280: ST_TO_ADDR
// for x in ( tmp diff j ) do
32281: LD_ADDR_VAR 0 7
32285: PUSH
32286: LD_VAR 0 6
32290: PUSH
32291: LD_VAR 0 3
32295: DIFF
32296: PUSH
32297: FOR_IN
32298: IFFALSE 32350
// begin if sci = 6 then
32300: LD_VAR 0 8
32304: PUSH
32305: LD_INT 6
32307: EQUAL
32308: IFFALSE 32312
// break ;
32310: GO 32350
// if BuildingStatus ( x ) = bs_idle then
32312: LD_VAR 0 7
32316: PPUSH
32317: CALL_OW 461
32321: PUSH
32322: LD_INT 2
32324: EQUAL
32325: IFFALSE 32348
// sci := sci ^ UnitsInside ( x ) ;
32327: LD_ADDR_VAR 0 8
32331: PUSH
32332: LD_VAR 0 8
32336: PUSH
32337: LD_VAR 0 7
32341: PPUSH
32342: CALL_OW 313
32346: ADD
32347: ST_TO_ADDR
// end ;
32348: GO 32297
32350: POP
32351: POP
// if not sci then
32352: LD_VAR 0 8
32356: NOT
32357: IFFALSE 32361
// continue ;
32359: GO 31406
// for x in sci do
32361: LD_ADDR_VAR 0 7
32365: PUSH
32366: LD_VAR 0 8
32370: PUSH
32371: FOR_IN
32372: IFFALSE 32422
// if IsInUnit ( x ) and not HasTask ( x ) then
32374: LD_VAR 0 7
32378: PPUSH
32379: CALL_OW 310
32383: PUSH
32384: LD_VAR 0 7
32388: PPUSH
32389: CALL_OW 314
32393: NOT
32394: AND
32395: IFFALSE 32420
// begin ComExitBuilding ( x ) ;
32397: LD_VAR 0 7
32401: PPUSH
32402: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
32406: LD_VAR 0 7
32410: PPUSH
32411: LD_VAR 0 3
32415: PPUSH
32416: CALL_OW 180
// end ;
32420: GO 32371
32422: POP
32423: POP
// end ; end ;
32424: GO 31406
32426: POP
32427: POP
// end ;
32428: GO 31360
32430: POP
32431: POP
// end ;
32432: LD_VAR 0 1
32436: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
32437: LD_INT 0
32439: PPUSH
32440: PPUSH
// if not mc_bases then
32441: LD_EXP 50
32445: NOT
32446: IFFALSE 32450
// exit ;
32448: GO 32531
// for i = 1 to mc_bases do
32450: LD_ADDR_VAR 0 2
32454: PUSH
32455: DOUBLE
32456: LD_INT 1
32458: DEC
32459: ST_TO_ADDR
32460: LD_EXP 50
32464: PUSH
32465: FOR_TO
32466: IFFALSE 32529
// if mc_mines [ i ] and mc_miners [ i ] then
32468: LD_EXP 63
32472: PUSH
32473: LD_VAR 0 2
32477: ARRAY
32478: PUSH
32479: LD_EXP 64
32483: PUSH
32484: LD_VAR 0 2
32488: ARRAY
32489: AND
32490: IFFALSE 32527
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
32492: LD_EXP 64
32496: PUSH
32497: LD_VAR 0 2
32501: ARRAY
32502: PUSH
32503: LD_INT 1
32505: ARRAY
32506: PPUSH
32507: CALL_OW 255
32511: PPUSH
32512: LD_EXP 63
32516: PUSH
32517: LD_VAR 0 2
32521: ARRAY
32522: PPUSH
32523: CALL 48122 0 2
32527: GO 32465
32529: POP
32530: POP
// end ;
32531: LD_VAR 0 1
32535: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
32536: LD_INT 0
32538: PPUSH
32539: PPUSH
32540: PPUSH
32541: PPUSH
32542: PPUSH
32543: PPUSH
32544: PPUSH
32545: PPUSH
// if not mc_bases or not mc_parking then
32546: LD_EXP 50
32550: NOT
32551: PUSH
32552: LD_EXP 74
32556: NOT
32557: OR
32558: IFFALSE 32562
// exit ;
32560: GO 33274
// for i = 1 to mc_bases do
32562: LD_ADDR_VAR 0 2
32566: PUSH
32567: DOUBLE
32568: LD_INT 1
32570: DEC
32571: ST_TO_ADDR
32572: LD_EXP 50
32576: PUSH
32577: FOR_TO
32578: IFFALSE 33272
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
32580: LD_EXP 50
32584: PUSH
32585: LD_VAR 0 2
32589: ARRAY
32590: NOT
32591: PUSH
32592: LD_EXP 74
32596: PUSH
32597: LD_VAR 0 2
32601: ARRAY
32602: NOT
32603: OR
32604: IFFALSE 32608
// continue ;
32606: GO 32577
// if mc_scan [ i ] then
32608: LD_EXP 73
32612: PUSH
32613: LD_VAR 0 2
32617: ARRAY
32618: IFFALSE 32644
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
32620: LD_ADDR_EXP 62
32624: PUSH
32625: LD_EXP 62
32629: PPUSH
32630: LD_VAR 0 2
32634: PPUSH
32635: EMPTY
32636: PPUSH
32637: CALL_OW 1
32641: ST_TO_ADDR
// continue ;
32642: GO 32577
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
32644: LD_ADDR_VAR 0 5
32648: PUSH
32649: LD_EXP 50
32653: PUSH
32654: LD_VAR 0 2
32658: ARRAY
32659: PUSH
32660: LD_INT 1
32662: ARRAY
32663: PPUSH
32664: CALL_OW 255
32668: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32669: LD_ADDR_VAR 0 6
32673: PUSH
32674: LD_EXP 50
32678: PUSH
32679: LD_VAR 0 2
32683: ARRAY
32684: PPUSH
32685: LD_INT 30
32687: PUSH
32688: LD_INT 3
32690: PUSH
32691: EMPTY
32692: LIST
32693: LIST
32694: PPUSH
32695: CALL_OW 72
32699: ST_TO_ADDR
// if not fac then
32700: LD_VAR 0 6
32704: NOT
32705: IFFALSE 32756
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32707: LD_ADDR_VAR 0 6
32711: PUSH
32712: LD_EXP 50
32716: PUSH
32717: LD_VAR 0 2
32721: ARRAY
32722: PPUSH
32723: LD_INT 2
32725: PUSH
32726: LD_INT 30
32728: PUSH
32729: LD_INT 0
32731: PUSH
32732: EMPTY
32733: LIST
32734: LIST
32735: PUSH
32736: LD_INT 30
32738: PUSH
32739: LD_INT 1
32741: PUSH
32742: EMPTY
32743: LIST
32744: LIST
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: LIST
32750: PPUSH
32751: CALL_OW 72
32755: ST_TO_ADDR
// if not fac then
32756: LD_VAR 0 6
32760: NOT
32761: IFFALSE 32765
// continue ;
32763: GO 32577
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
32765: LD_ADDR_VAR 0 7
32769: PUSH
32770: LD_EXP 74
32774: PUSH
32775: LD_VAR 0 2
32779: ARRAY
32780: PPUSH
32781: LD_INT 22
32783: PUSH
32784: LD_VAR 0 5
32788: PUSH
32789: EMPTY
32790: LIST
32791: LIST
32792: PUSH
32793: LD_INT 21
32795: PUSH
32796: LD_INT 2
32798: PUSH
32799: EMPTY
32800: LIST
32801: LIST
32802: PUSH
32803: LD_INT 3
32805: PUSH
32806: LD_INT 24
32808: PUSH
32809: LD_INT 1000
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: PUSH
32816: EMPTY
32817: LIST
32818: LIST
32819: PUSH
32820: EMPTY
32821: LIST
32822: LIST
32823: LIST
32824: PPUSH
32825: CALL_OW 70
32829: PUSH
32830: LD_INT 22
32832: PUSH
32833: LD_VAR 0 5
32837: PUSH
32838: EMPTY
32839: LIST
32840: LIST
32841: PUSH
32842: LD_INT 91
32844: PUSH
32845: LD_VAR 0 6
32849: PUSH
32850: LD_INT 1
32852: ARRAY
32853: PUSH
32854: LD_INT 25
32856: PUSH
32857: EMPTY
32858: LIST
32859: LIST
32860: LIST
32861: PUSH
32862: LD_INT 21
32864: PUSH
32865: LD_INT 2
32867: PUSH
32868: EMPTY
32869: LIST
32870: LIST
32871: PUSH
32872: LD_INT 3
32874: PUSH
32875: LD_INT 24
32877: PUSH
32878: LD_INT 1000
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: EMPTY
32886: LIST
32887: LIST
32888: PUSH
32889: EMPTY
32890: LIST
32891: LIST
32892: LIST
32893: LIST
32894: PPUSH
32895: CALL_OW 69
32899: UNION
32900: ST_TO_ADDR
// if not vehs then
32901: LD_VAR 0 7
32905: NOT
32906: IFFALSE 32932
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
32908: LD_ADDR_EXP 62
32912: PUSH
32913: LD_EXP 62
32917: PPUSH
32918: LD_VAR 0 2
32922: PPUSH
32923: EMPTY
32924: PPUSH
32925: CALL_OW 1
32929: ST_TO_ADDR
// continue ;
32930: GO 32577
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32932: LD_ADDR_VAR 0 8
32936: PUSH
32937: LD_EXP 50
32941: PUSH
32942: LD_VAR 0 2
32946: ARRAY
32947: PPUSH
32948: LD_INT 30
32950: PUSH
32951: LD_INT 3
32953: PUSH
32954: EMPTY
32955: LIST
32956: LIST
32957: PPUSH
32958: CALL_OW 72
32962: ST_TO_ADDR
// if tmp then
32963: LD_VAR 0 8
32967: IFFALSE 33070
// begin for j in tmp do
32969: LD_ADDR_VAR 0 3
32973: PUSH
32974: LD_VAR 0 8
32978: PUSH
32979: FOR_IN
32980: IFFALSE 33068
// for k in UnitsInside ( j ) do
32982: LD_ADDR_VAR 0 4
32986: PUSH
32987: LD_VAR 0 3
32991: PPUSH
32992: CALL_OW 313
32996: PUSH
32997: FOR_IN
32998: IFFALSE 33064
// if k then
33000: LD_VAR 0 4
33004: IFFALSE 33062
// if not k in mc_repair_vehicle [ i ] then
33006: LD_VAR 0 4
33010: PUSH
33011: LD_EXP 62
33015: PUSH
33016: LD_VAR 0 2
33020: ARRAY
33021: IN
33022: NOT
33023: IFFALSE 33062
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
33025: LD_ADDR_EXP 62
33029: PUSH
33030: LD_EXP 62
33034: PPUSH
33035: LD_VAR 0 2
33039: PPUSH
33040: LD_EXP 62
33044: PUSH
33045: LD_VAR 0 2
33049: ARRAY
33050: PUSH
33051: LD_VAR 0 4
33055: UNION
33056: PPUSH
33057: CALL_OW 1
33061: ST_TO_ADDR
33062: GO 32997
33064: POP
33065: POP
33066: GO 32979
33068: POP
33069: POP
// end ; if not mc_repair_vehicle [ i ] then
33070: LD_EXP 62
33074: PUSH
33075: LD_VAR 0 2
33079: ARRAY
33080: NOT
33081: IFFALSE 33085
// continue ;
33083: GO 32577
// for j in mc_repair_vehicle [ i ] do
33085: LD_ADDR_VAR 0 3
33089: PUSH
33090: LD_EXP 62
33094: PUSH
33095: LD_VAR 0 2
33099: ARRAY
33100: PUSH
33101: FOR_IN
33102: IFFALSE 33268
// begin if GetClass ( j ) <> 3 then
33104: LD_VAR 0 3
33108: PPUSH
33109: CALL_OW 257
33113: PUSH
33114: LD_INT 3
33116: NONEQUAL
33117: IFFALSE 33158
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
33119: LD_ADDR_EXP 62
33123: PUSH
33124: LD_EXP 62
33128: PPUSH
33129: LD_VAR 0 2
33133: PPUSH
33134: LD_EXP 62
33138: PUSH
33139: LD_VAR 0 2
33143: ARRAY
33144: PUSH
33145: LD_VAR 0 3
33149: DIFF
33150: PPUSH
33151: CALL_OW 1
33155: ST_TO_ADDR
// continue ;
33156: GO 33101
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
33158: LD_VAR 0 3
33162: PPUSH
33163: CALL_OW 311
33167: NOT
33168: PUSH
33169: LD_VAR 0 3
33173: PUSH
33174: LD_EXP 53
33178: PUSH
33179: LD_VAR 0 2
33183: ARRAY
33184: PUSH
33185: LD_INT 1
33187: ARRAY
33188: IN
33189: NOT
33190: AND
33191: PUSH
33192: LD_VAR 0 3
33196: PUSH
33197: LD_EXP 53
33201: PUSH
33202: LD_VAR 0 2
33206: ARRAY
33207: PUSH
33208: LD_INT 2
33210: ARRAY
33211: IN
33212: NOT
33213: AND
33214: IFFALSE 33266
// begin if IsInUnit ( j ) then
33216: LD_VAR 0 3
33220: PPUSH
33221: CALL_OW 310
33225: IFFALSE 33236
// ComExitBuilding ( j ) ;
33227: LD_VAR 0 3
33231: PPUSH
33232: CALL_OW 122
// if not HasTask ( j ) then
33236: LD_VAR 0 3
33240: PPUSH
33241: CALL_OW 314
33245: NOT
33246: IFFALSE 33266
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
33248: LD_VAR 0 3
33252: PPUSH
33253: LD_VAR 0 7
33257: PUSH
33258: LD_INT 1
33260: ARRAY
33261: PPUSH
33262: CALL_OW 189
// end ; end ;
33266: GO 33101
33268: POP
33269: POP
// end ;
33270: GO 32577
33272: POP
33273: POP
// end ;
33274: LD_VAR 0 1
33278: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
33279: LD_INT 0
33281: PPUSH
33282: PPUSH
33283: PPUSH
33284: PPUSH
33285: PPUSH
33286: PPUSH
33287: PPUSH
33288: PPUSH
33289: PPUSH
33290: PPUSH
33291: PPUSH
// if not mc_bases then
33292: LD_EXP 50
33296: NOT
33297: IFFALSE 33301
// exit ;
33299: GO 34103
// for i = 1 to mc_bases do
33301: LD_ADDR_VAR 0 2
33305: PUSH
33306: DOUBLE
33307: LD_INT 1
33309: DEC
33310: ST_TO_ADDR
33311: LD_EXP 50
33315: PUSH
33316: FOR_TO
33317: IFFALSE 34101
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
33319: LD_EXP 78
33323: PUSH
33324: LD_VAR 0 2
33328: ARRAY
33329: NOT
33330: PUSH
33331: LD_EXP 53
33335: PUSH
33336: LD_VAR 0 2
33340: ARRAY
33341: PUSH
33342: LD_INT 1
33344: ARRAY
33345: OR
33346: PUSH
33347: LD_EXP 53
33351: PUSH
33352: LD_VAR 0 2
33356: ARRAY
33357: PUSH
33358: LD_INT 2
33360: ARRAY
33361: OR
33362: PUSH
33363: LD_EXP 76
33367: PUSH
33368: LD_VAR 0 2
33372: ARRAY
33373: PPUSH
33374: LD_INT 1
33376: PPUSH
33377: CALL_OW 325
33381: NOT
33382: OR
33383: PUSH
33384: LD_EXP 73
33388: PUSH
33389: LD_VAR 0 2
33393: ARRAY
33394: OR
33395: IFFALSE 33399
// continue ;
33397: GO 33316
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
33399: LD_ADDR_VAR 0 8
33403: PUSH
33404: LD_EXP 50
33408: PUSH
33409: LD_VAR 0 2
33413: ARRAY
33414: PPUSH
33415: LD_INT 25
33417: PUSH
33418: LD_INT 4
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 50
33427: PUSH
33428: EMPTY
33429: LIST
33430: PUSH
33431: LD_INT 3
33433: PUSH
33434: LD_INT 60
33436: PUSH
33437: EMPTY
33438: LIST
33439: PUSH
33440: EMPTY
33441: LIST
33442: LIST
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: LIST
33448: PPUSH
33449: CALL_OW 72
33453: PUSH
33454: LD_EXP 54
33458: PUSH
33459: LD_VAR 0 2
33463: ARRAY
33464: DIFF
33465: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
33466: LD_ADDR_VAR 0 9
33470: PUSH
33471: LD_EXP 50
33475: PUSH
33476: LD_VAR 0 2
33480: ARRAY
33481: PPUSH
33482: LD_INT 2
33484: PUSH
33485: LD_INT 30
33487: PUSH
33488: LD_INT 0
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: PUSH
33495: LD_INT 30
33497: PUSH
33498: LD_INT 1
33500: PUSH
33501: EMPTY
33502: LIST
33503: LIST
33504: PUSH
33505: EMPTY
33506: LIST
33507: LIST
33508: LIST
33509: PPUSH
33510: CALL_OW 72
33514: ST_TO_ADDR
// if not tmp or not dep then
33515: LD_VAR 0 8
33519: NOT
33520: PUSH
33521: LD_VAR 0 9
33525: NOT
33526: OR
33527: IFFALSE 33531
// continue ;
33529: GO 33316
// side := GetSide ( tmp [ 1 ] ) ;
33531: LD_ADDR_VAR 0 11
33535: PUSH
33536: LD_VAR 0 8
33540: PUSH
33541: LD_INT 1
33543: ARRAY
33544: PPUSH
33545: CALL_OW 255
33549: ST_TO_ADDR
// dep := dep [ 1 ] ;
33550: LD_ADDR_VAR 0 9
33554: PUSH
33555: LD_VAR 0 9
33559: PUSH
33560: LD_INT 1
33562: ARRAY
33563: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
33564: LD_ADDR_VAR 0 7
33568: PUSH
33569: LD_EXP 78
33573: PUSH
33574: LD_VAR 0 2
33578: ARRAY
33579: PPUSH
33580: LD_INT 22
33582: PUSH
33583: LD_INT 0
33585: PUSH
33586: EMPTY
33587: LIST
33588: LIST
33589: PUSH
33590: LD_INT 25
33592: PUSH
33593: LD_INT 12
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: PUSH
33600: EMPTY
33601: LIST
33602: LIST
33603: PPUSH
33604: CALL_OW 70
33608: PUSH
33609: LD_INT 22
33611: PUSH
33612: LD_INT 0
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PUSH
33619: LD_INT 25
33621: PUSH
33622: LD_INT 12
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 91
33631: PUSH
33632: LD_VAR 0 9
33636: PUSH
33637: LD_INT 20
33639: PUSH
33640: EMPTY
33641: LIST
33642: LIST
33643: LIST
33644: PUSH
33645: EMPTY
33646: LIST
33647: LIST
33648: LIST
33649: PPUSH
33650: CALL_OW 69
33654: UNION
33655: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
33656: LD_ADDR_VAR 0 10
33660: PUSH
33661: LD_EXP 78
33665: PUSH
33666: LD_VAR 0 2
33670: ARRAY
33671: PPUSH
33672: LD_INT 81
33674: PUSH
33675: LD_VAR 0 11
33679: PUSH
33680: EMPTY
33681: LIST
33682: LIST
33683: PPUSH
33684: CALL_OW 70
33688: ST_TO_ADDR
// if not apes or danger_at_area then
33689: LD_VAR 0 7
33693: NOT
33694: PUSH
33695: LD_VAR 0 10
33699: OR
33700: IFFALSE 33750
// begin if mc_taming [ i ] then
33702: LD_EXP 81
33706: PUSH
33707: LD_VAR 0 2
33711: ARRAY
33712: IFFALSE 33748
// begin MC_Reset ( i , 121 ) ;
33714: LD_VAR 0 2
33718: PPUSH
33719: LD_INT 121
33721: PPUSH
33722: CALL 19708 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
33726: LD_ADDR_EXP 81
33730: PUSH
33731: LD_EXP 81
33735: PPUSH
33736: LD_VAR 0 2
33740: PPUSH
33741: EMPTY
33742: PPUSH
33743: CALL_OW 1
33747: ST_TO_ADDR
// end ; continue ;
33748: GO 33316
// end ; for j in tmp do
33750: LD_ADDR_VAR 0 3
33754: PUSH
33755: LD_VAR 0 8
33759: PUSH
33760: FOR_IN
33761: IFFALSE 34097
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
33763: LD_VAR 0 3
33767: PUSH
33768: LD_EXP 81
33772: PUSH
33773: LD_VAR 0 2
33777: ARRAY
33778: IN
33779: NOT
33780: PUSH
33781: LD_EXP 81
33785: PUSH
33786: LD_VAR 0 2
33790: ARRAY
33791: PUSH
33792: LD_INT 3
33794: LESS
33795: AND
33796: IFFALSE 33854
// begin SetTag ( j , 121 ) ;
33798: LD_VAR 0 3
33802: PPUSH
33803: LD_INT 121
33805: PPUSH
33806: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
33810: LD_ADDR_EXP 81
33814: PUSH
33815: LD_EXP 81
33819: PPUSH
33820: LD_VAR 0 2
33824: PUSH
33825: LD_EXP 81
33829: PUSH
33830: LD_VAR 0 2
33834: ARRAY
33835: PUSH
33836: LD_INT 1
33838: PLUS
33839: PUSH
33840: EMPTY
33841: LIST
33842: LIST
33843: PPUSH
33844: LD_VAR 0 3
33848: PPUSH
33849: CALL 51065 0 3
33853: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
33854: LD_VAR 0 3
33858: PUSH
33859: LD_EXP 81
33863: PUSH
33864: LD_VAR 0 2
33868: ARRAY
33869: IN
33870: IFFALSE 34095
// begin if GetClass ( j ) <> 4 then
33872: LD_VAR 0 3
33876: PPUSH
33877: CALL_OW 257
33881: PUSH
33882: LD_INT 4
33884: NONEQUAL
33885: IFFALSE 33938
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
33887: LD_ADDR_EXP 81
33891: PUSH
33892: LD_EXP 81
33896: PPUSH
33897: LD_VAR 0 2
33901: PPUSH
33902: LD_EXP 81
33906: PUSH
33907: LD_VAR 0 2
33911: ARRAY
33912: PUSH
33913: LD_VAR 0 3
33917: DIFF
33918: PPUSH
33919: CALL_OW 1
33923: ST_TO_ADDR
// SetTag ( j , 0 ) ;
33924: LD_VAR 0 3
33928: PPUSH
33929: LD_INT 0
33931: PPUSH
33932: CALL_OW 109
// continue ;
33936: GO 33760
// end ; if IsInUnit ( j ) then
33938: LD_VAR 0 3
33942: PPUSH
33943: CALL_OW 310
33947: IFFALSE 33958
// ComExitBuilding ( j ) ;
33949: LD_VAR 0 3
33953: PPUSH
33954: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
33958: LD_ADDR_VAR 0 6
33962: PUSH
33963: LD_VAR 0 7
33967: PPUSH
33968: LD_VAR 0 3
33972: PPUSH
33973: CALL_OW 74
33977: ST_TO_ADDR
// if not ape then
33978: LD_VAR 0 6
33982: NOT
33983: IFFALSE 33987
// break ;
33985: GO 34097
// x := GetX ( ape ) ;
33987: LD_ADDR_VAR 0 4
33991: PUSH
33992: LD_VAR 0 6
33996: PPUSH
33997: CALL_OW 250
34001: ST_TO_ADDR
// y := GetY ( ape ) ;
34002: LD_ADDR_VAR 0 5
34006: PUSH
34007: LD_VAR 0 6
34011: PPUSH
34012: CALL_OW 251
34016: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
34017: LD_VAR 0 4
34021: PPUSH
34022: LD_VAR 0 5
34026: PPUSH
34027: CALL_OW 488
34031: NOT
34032: PUSH
34033: LD_VAR 0 11
34037: PPUSH
34038: LD_VAR 0 4
34042: PPUSH
34043: LD_VAR 0 5
34047: PPUSH
34048: LD_INT 20
34050: PPUSH
34051: CALL 51961 0 4
34055: PUSH
34056: LD_INT 4
34058: ARRAY
34059: OR
34060: IFFALSE 34064
// break ;
34062: GO 34097
// if not HasTask ( j ) then
34064: LD_VAR 0 3
34068: PPUSH
34069: CALL_OW 314
34073: NOT
34074: IFFALSE 34095
// ComTameXY ( j , x , y ) ;
34076: LD_VAR 0 3
34080: PPUSH
34081: LD_VAR 0 4
34085: PPUSH
34086: LD_VAR 0 5
34090: PPUSH
34091: CALL_OW 131
// end ; end ;
34095: GO 33760
34097: POP
34098: POP
// end ;
34099: GO 33316
34101: POP
34102: POP
// end ;
34103: LD_VAR 0 1
34107: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
34108: LD_INT 0
34110: PPUSH
34111: PPUSH
34112: PPUSH
34113: PPUSH
34114: PPUSH
34115: PPUSH
34116: PPUSH
34117: PPUSH
// if not mc_bases then
34118: LD_EXP 50
34122: NOT
34123: IFFALSE 34127
// exit ;
34125: GO 34753
// for i = 1 to mc_bases do
34127: LD_ADDR_VAR 0 2
34131: PUSH
34132: DOUBLE
34133: LD_INT 1
34135: DEC
34136: ST_TO_ADDR
34137: LD_EXP 50
34141: PUSH
34142: FOR_TO
34143: IFFALSE 34751
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
34145: LD_EXP 79
34149: PUSH
34150: LD_VAR 0 2
34154: ARRAY
34155: NOT
34156: PUSH
34157: LD_EXP 79
34161: PUSH
34162: LD_VAR 0 2
34166: ARRAY
34167: PPUSH
34168: LD_INT 25
34170: PUSH
34171: LD_INT 12
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PPUSH
34178: CALL_OW 72
34182: NOT
34183: OR
34184: IFFALSE 34188
// continue ;
34186: GO 34142
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
34188: LD_ADDR_VAR 0 5
34192: PUSH
34193: LD_EXP 79
34197: PUSH
34198: LD_VAR 0 2
34202: ARRAY
34203: PUSH
34204: LD_INT 1
34206: ARRAY
34207: PPUSH
34208: CALL_OW 255
34212: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
34213: LD_VAR 0 5
34217: PPUSH
34218: LD_INT 2
34220: PPUSH
34221: CALL_OW 325
34225: IFFALSE 34478
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
34227: LD_ADDR_VAR 0 4
34231: PUSH
34232: LD_EXP 79
34236: PUSH
34237: LD_VAR 0 2
34241: ARRAY
34242: PPUSH
34243: LD_INT 25
34245: PUSH
34246: LD_INT 16
34248: PUSH
34249: EMPTY
34250: LIST
34251: LIST
34252: PPUSH
34253: CALL_OW 72
34257: ST_TO_ADDR
// if tmp < 6 then
34258: LD_VAR 0 4
34262: PUSH
34263: LD_INT 6
34265: LESS
34266: IFFALSE 34478
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34268: LD_ADDR_VAR 0 6
34272: PUSH
34273: LD_EXP 50
34277: PUSH
34278: LD_VAR 0 2
34282: ARRAY
34283: PPUSH
34284: LD_INT 2
34286: PUSH
34287: LD_INT 30
34289: PUSH
34290: LD_INT 0
34292: PUSH
34293: EMPTY
34294: LIST
34295: LIST
34296: PUSH
34297: LD_INT 30
34299: PUSH
34300: LD_INT 1
34302: PUSH
34303: EMPTY
34304: LIST
34305: LIST
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: LIST
34311: PPUSH
34312: CALL_OW 72
34316: ST_TO_ADDR
// if depot then
34317: LD_VAR 0 6
34321: IFFALSE 34478
// begin selected := 0 ;
34323: LD_ADDR_VAR 0 7
34327: PUSH
34328: LD_INT 0
34330: ST_TO_ADDR
// for j in depot do
34331: LD_ADDR_VAR 0 3
34335: PUSH
34336: LD_VAR 0 6
34340: PUSH
34341: FOR_IN
34342: IFFALSE 34373
// begin if UnitsInside ( j ) < 6 then
34344: LD_VAR 0 3
34348: PPUSH
34349: CALL_OW 313
34353: PUSH
34354: LD_INT 6
34356: LESS
34357: IFFALSE 34371
// begin selected := j ;
34359: LD_ADDR_VAR 0 7
34363: PUSH
34364: LD_VAR 0 3
34368: ST_TO_ADDR
// break ;
34369: GO 34373
// end ; end ;
34371: GO 34341
34373: POP
34374: POP
// if selected then
34375: LD_VAR 0 7
34379: IFFALSE 34478
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
34381: LD_ADDR_VAR 0 3
34385: PUSH
34386: LD_EXP 79
34390: PUSH
34391: LD_VAR 0 2
34395: ARRAY
34396: PPUSH
34397: LD_INT 25
34399: PUSH
34400: LD_INT 12
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PPUSH
34407: CALL_OW 72
34411: PUSH
34412: FOR_IN
34413: IFFALSE 34476
// if not HasTask ( j ) then
34415: LD_VAR 0 3
34419: PPUSH
34420: CALL_OW 314
34424: NOT
34425: IFFALSE 34474
// begin if not IsInUnit ( j ) then
34427: LD_VAR 0 3
34431: PPUSH
34432: CALL_OW 310
34436: NOT
34437: IFFALSE 34453
// ComEnterUnit ( j , selected ) ;
34439: LD_VAR 0 3
34443: PPUSH
34444: LD_VAR 0 7
34448: PPUSH
34449: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
34453: LD_VAR 0 3
34457: PPUSH
34458: LD_INT 16
34460: PPUSH
34461: CALL_OW 183
// AddComExitBuilding ( j ) ;
34465: LD_VAR 0 3
34469: PPUSH
34470: CALL_OW 182
// end ;
34474: GO 34412
34476: POP
34477: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
34478: LD_VAR 0 5
34482: PPUSH
34483: LD_INT 11
34485: PPUSH
34486: CALL_OW 325
34490: IFFALSE 34749
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
34492: LD_ADDR_VAR 0 4
34496: PUSH
34497: LD_EXP 79
34501: PUSH
34502: LD_VAR 0 2
34506: ARRAY
34507: PPUSH
34508: LD_INT 25
34510: PUSH
34511: LD_INT 16
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PPUSH
34518: CALL_OW 72
34522: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
34523: LD_VAR 0 4
34527: PUSH
34528: LD_INT 6
34530: GREATEREQUAL
34531: PUSH
34532: LD_VAR 0 5
34536: PPUSH
34537: LD_INT 2
34539: PPUSH
34540: CALL_OW 325
34544: NOT
34545: OR
34546: IFFALSE 34749
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
34548: LD_ADDR_VAR 0 8
34552: PUSH
34553: LD_EXP 50
34557: PUSH
34558: LD_VAR 0 2
34562: ARRAY
34563: PPUSH
34564: LD_INT 2
34566: PUSH
34567: LD_INT 30
34569: PUSH
34570: LD_INT 4
34572: PUSH
34573: EMPTY
34574: LIST
34575: LIST
34576: PUSH
34577: LD_INT 30
34579: PUSH
34580: LD_INT 5
34582: PUSH
34583: EMPTY
34584: LIST
34585: LIST
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: LIST
34591: PPUSH
34592: CALL_OW 72
34596: ST_TO_ADDR
// if barracks then
34597: LD_VAR 0 8
34601: IFFALSE 34749
// begin selected := 0 ;
34603: LD_ADDR_VAR 0 7
34607: PUSH
34608: LD_INT 0
34610: ST_TO_ADDR
// for j in barracks do
34611: LD_ADDR_VAR 0 3
34615: PUSH
34616: LD_VAR 0 8
34620: PUSH
34621: FOR_IN
34622: IFFALSE 34653
// begin if UnitsInside ( j ) < 6 then
34624: LD_VAR 0 3
34628: PPUSH
34629: CALL_OW 313
34633: PUSH
34634: LD_INT 6
34636: LESS
34637: IFFALSE 34651
// begin selected := j ;
34639: LD_ADDR_VAR 0 7
34643: PUSH
34644: LD_VAR 0 3
34648: ST_TO_ADDR
// break ;
34649: GO 34653
// end ; end ;
34651: GO 34621
34653: POP
34654: POP
// if selected then
34655: LD_VAR 0 7
34659: IFFALSE 34749
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
34661: LD_ADDR_VAR 0 3
34665: PUSH
34666: LD_EXP 79
34670: PUSH
34671: LD_VAR 0 2
34675: ARRAY
34676: PPUSH
34677: LD_INT 25
34679: PUSH
34680: LD_INT 12
34682: PUSH
34683: EMPTY
34684: LIST
34685: LIST
34686: PPUSH
34687: CALL_OW 72
34691: PUSH
34692: FOR_IN
34693: IFFALSE 34747
// if not IsInUnit ( j ) and not HasTask ( j ) then
34695: LD_VAR 0 3
34699: PPUSH
34700: CALL_OW 310
34704: NOT
34705: PUSH
34706: LD_VAR 0 3
34710: PPUSH
34711: CALL_OW 314
34715: NOT
34716: AND
34717: IFFALSE 34745
// begin ComEnterUnit ( j , selected ) ;
34719: LD_VAR 0 3
34723: PPUSH
34724: LD_VAR 0 7
34728: PPUSH
34729: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
34733: LD_VAR 0 3
34737: PPUSH
34738: LD_INT 15
34740: PPUSH
34741: CALL_OW 183
// end ;
34745: GO 34692
34747: POP
34748: POP
// end ; end ; end ; end ; end ;
34749: GO 34142
34751: POP
34752: POP
// end ;
34753: LD_VAR 0 1
34757: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
34758: LD_INT 0
34760: PPUSH
34761: PPUSH
34762: PPUSH
34763: PPUSH
// if not mc_bases then
34764: LD_EXP 50
34768: NOT
34769: IFFALSE 34773
// exit ;
34771: GO 34951
// for i = 1 to mc_bases do
34773: LD_ADDR_VAR 0 2
34777: PUSH
34778: DOUBLE
34779: LD_INT 1
34781: DEC
34782: ST_TO_ADDR
34783: LD_EXP 50
34787: PUSH
34788: FOR_TO
34789: IFFALSE 34949
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
34791: LD_ADDR_VAR 0 4
34795: PUSH
34796: LD_EXP 50
34800: PUSH
34801: LD_VAR 0 2
34805: ARRAY
34806: PPUSH
34807: LD_INT 25
34809: PUSH
34810: LD_INT 9
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PPUSH
34817: CALL_OW 72
34821: ST_TO_ADDR
// if not tmp then
34822: LD_VAR 0 4
34826: NOT
34827: IFFALSE 34831
// continue ;
34829: GO 34788
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
34831: LD_EXP 76
34835: PUSH
34836: LD_VAR 0 2
34840: ARRAY
34841: PPUSH
34842: LD_INT 29
34844: PPUSH
34845: CALL_OW 325
34849: NOT
34850: PUSH
34851: LD_EXP 76
34855: PUSH
34856: LD_VAR 0 2
34860: ARRAY
34861: PPUSH
34862: LD_INT 28
34864: PPUSH
34865: CALL_OW 325
34869: NOT
34870: AND
34871: IFFALSE 34875
// continue ;
34873: GO 34788
// for j in tmp do
34875: LD_ADDR_VAR 0 3
34879: PUSH
34880: LD_VAR 0 4
34884: PUSH
34885: FOR_IN
34886: IFFALSE 34945
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
34888: LD_VAR 0 3
34892: PUSH
34893: LD_EXP 53
34897: PUSH
34898: LD_VAR 0 2
34902: ARRAY
34903: PUSH
34904: LD_INT 1
34906: ARRAY
34907: IN
34908: NOT
34909: PUSH
34910: LD_VAR 0 3
34914: PUSH
34915: LD_EXP 53
34919: PUSH
34920: LD_VAR 0 2
34924: ARRAY
34925: PUSH
34926: LD_INT 2
34928: ARRAY
34929: IN
34930: NOT
34931: AND
34932: IFFALSE 34943
// ComSpaceTimeShoot ( j ) ;
34934: LD_VAR 0 3
34938: PPUSH
34939: CALL 45125 0 1
34943: GO 34885
34945: POP
34946: POP
// end ;
34947: GO 34788
34949: POP
34950: POP
// end ;
34951: LD_VAR 0 1
34955: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
34956: LD_INT 0
34958: PPUSH
34959: PPUSH
34960: PPUSH
34961: PPUSH
34962: PPUSH
34963: PPUSH
34964: PPUSH
34965: PPUSH
34966: PPUSH
// if not mc_bases then
34967: LD_EXP 50
34971: NOT
34972: IFFALSE 34976
// exit ;
34974: GO 35598
// for i = 1 to mc_bases do
34976: LD_ADDR_VAR 0 2
34980: PUSH
34981: DOUBLE
34982: LD_INT 1
34984: DEC
34985: ST_TO_ADDR
34986: LD_EXP 50
34990: PUSH
34991: FOR_TO
34992: IFFALSE 35596
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
34994: LD_EXP 85
34998: PUSH
34999: LD_VAR 0 2
35003: ARRAY
35004: NOT
35005: PUSH
35006: LD_INT 38
35008: PPUSH
35009: LD_EXP 76
35013: PUSH
35014: LD_VAR 0 2
35018: ARRAY
35019: PPUSH
35020: CALL_OW 321
35024: PUSH
35025: LD_INT 2
35027: NONEQUAL
35028: OR
35029: IFFALSE 35033
// continue ;
35031: GO 34991
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
35033: LD_ADDR_VAR 0 8
35037: PUSH
35038: LD_EXP 50
35042: PUSH
35043: LD_VAR 0 2
35047: ARRAY
35048: PPUSH
35049: LD_INT 30
35051: PUSH
35052: LD_INT 34
35054: PUSH
35055: EMPTY
35056: LIST
35057: LIST
35058: PPUSH
35059: CALL_OW 72
35063: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
35064: LD_ADDR_VAR 0 9
35068: PUSH
35069: LD_EXP 50
35073: PUSH
35074: LD_VAR 0 2
35078: ARRAY
35079: PPUSH
35080: LD_INT 25
35082: PUSH
35083: LD_INT 4
35085: PUSH
35086: EMPTY
35087: LIST
35088: LIST
35089: PPUSH
35090: CALL_OW 72
35094: PPUSH
35095: LD_INT 0
35097: PPUSH
35098: CALL 84262 0 2
35102: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
35103: LD_VAR 0 9
35107: NOT
35108: PUSH
35109: LD_VAR 0 8
35113: NOT
35114: OR
35115: PUSH
35116: LD_EXP 50
35120: PUSH
35121: LD_VAR 0 2
35125: ARRAY
35126: PPUSH
35127: LD_INT 124
35129: PPUSH
35130: CALL 84262 0 2
35134: OR
35135: IFFALSE 35139
// continue ;
35137: GO 34991
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
35139: LD_EXP 86
35143: PUSH
35144: LD_VAR 0 2
35148: ARRAY
35149: PUSH
35150: LD_EXP 85
35154: PUSH
35155: LD_VAR 0 2
35159: ARRAY
35160: LESS
35161: PUSH
35162: LD_EXP 86
35166: PUSH
35167: LD_VAR 0 2
35171: ARRAY
35172: PUSH
35173: LD_VAR 0 8
35177: LESS
35178: AND
35179: IFFALSE 35594
// begin tmp := sci [ 1 ] ;
35181: LD_ADDR_VAR 0 7
35185: PUSH
35186: LD_VAR 0 9
35190: PUSH
35191: LD_INT 1
35193: ARRAY
35194: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
35195: LD_VAR 0 7
35199: PPUSH
35200: LD_INT 124
35202: PPUSH
35203: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
35207: LD_ADDR_VAR 0 3
35211: PUSH
35212: DOUBLE
35213: LD_EXP 85
35217: PUSH
35218: LD_VAR 0 2
35222: ARRAY
35223: INC
35224: ST_TO_ADDR
35225: LD_EXP 85
35229: PUSH
35230: LD_VAR 0 2
35234: ARRAY
35235: PUSH
35236: FOR_DOWNTO
35237: IFFALSE 35580
// begin if IsInUnit ( tmp ) then
35239: LD_VAR 0 7
35243: PPUSH
35244: CALL_OW 310
35248: IFFALSE 35259
// ComExitBuilding ( tmp ) ;
35250: LD_VAR 0 7
35254: PPUSH
35255: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
35259: LD_INT 35
35261: PPUSH
35262: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
35266: LD_VAR 0 7
35270: PPUSH
35271: CALL_OW 310
35275: NOT
35276: PUSH
35277: LD_VAR 0 7
35281: PPUSH
35282: CALL_OW 314
35286: NOT
35287: AND
35288: IFFALSE 35259
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
35290: LD_ADDR_VAR 0 6
35294: PUSH
35295: LD_VAR 0 7
35299: PPUSH
35300: CALL_OW 250
35304: PUSH
35305: LD_VAR 0 7
35309: PPUSH
35310: CALL_OW 251
35314: PUSH
35315: EMPTY
35316: LIST
35317: LIST
35318: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
35319: LD_INT 35
35321: PPUSH
35322: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
35326: LD_ADDR_VAR 0 4
35330: PUSH
35331: LD_EXP 85
35335: PUSH
35336: LD_VAR 0 2
35340: ARRAY
35341: PUSH
35342: LD_VAR 0 3
35346: ARRAY
35347: PUSH
35348: LD_INT 1
35350: ARRAY
35351: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
35352: LD_ADDR_VAR 0 5
35356: PUSH
35357: LD_EXP 85
35361: PUSH
35362: LD_VAR 0 2
35366: ARRAY
35367: PUSH
35368: LD_VAR 0 3
35372: ARRAY
35373: PUSH
35374: LD_INT 2
35376: ARRAY
35377: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
35378: LD_VAR 0 7
35382: PPUSH
35383: LD_INT 10
35385: PPUSH
35386: CALL 53658 0 2
35390: PUSH
35391: LD_INT 4
35393: ARRAY
35394: IFFALSE 35432
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
35396: LD_VAR 0 7
35400: PPUSH
35401: LD_VAR 0 6
35405: PUSH
35406: LD_INT 1
35408: ARRAY
35409: PPUSH
35410: LD_VAR 0 6
35414: PUSH
35415: LD_INT 2
35417: ARRAY
35418: PPUSH
35419: CALL_OW 111
// wait ( 0 0$10 ) ;
35423: LD_INT 350
35425: PPUSH
35426: CALL_OW 67
// end else
35430: GO 35458
// begin ComMoveXY ( tmp , x , y ) ;
35432: LD_VAR 0 7
35436: PPUSH
35437: LD_VAR 0 4
35441: PPUSH
35442: LD_VAR 0 5
35446: PPUSH
35447: CALL_OW 111
// wait ( 0 0$3 ) ;
35451: LD_INT 105
35453: PPUSH
35454: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
35458: LD_VAR 0 7
35462: PPUSH
35463: LD_VAR 0 4
35467: PPUSH
35468: LD_VAR 0 5
35472: PPUSH
35473: CALL_OW 307
35477: IFFALSE 35319
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
35479: LD_VAR 0 7
35483: PPUSH
35484: LD_VAR 0 4
35488: PPUSH
35489: LD_VAR 0 5
35493: PPUSH
35494: LD_VAR 0 8
35498: PUSH
35499: LD_VAR 0 3
35503: ARRAY
35504: PPUSH
35505: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
35509: LD_INT 35
35511: PPUSH
35512: CALL_OW 67
// until not HasTask ( tmp ) ;
35516: LD_VAR 0 7
35520: PPUSH
35521: CALL_OW 314
35525: NOT
35526: IFFALSE 35509
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
35528: LD_ADDR_EXP 86
35532: PUSH
35533: LD_EXP 86
35537: PPUSH
35538: LD_VAR 0 2
35542: PUSH
35543: LD_EXP 86
35547: PUSH
35548: LD_VAR 0 2
35552: ARRAY
35553: PUSH
35554: LD_INT 1
35556: PLUS
35557: PUSH
35558: EMPTY
35559: LIST
35560: LIST
35561: PPUSH
35562: LD_VAR 0 8
35566: PUSH
35567: LD_VAR 0 3
35571: ARRAY
35572: PPUSH
35573: CALL 51065 0 3
35577: ST_TO_ADDR
// end ;
35578: GO 35236
35580: POP
35581: POP
// MC_Reset ( i , 124 ) ;
35582: LD_VAR 0 2
35586: PPUSH
35587: LD_INT 124
35589: PPUSH
35590: CALL 19708 0 2
// end ; end ;
35594: GO 34991
35596: POP
35597: POP
// end ;
35598: LD_VAR 0 1
35602: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
35603: LD_INT 0
35605: PPUSH
35606: PPUSH
35607: PPUSH
// if not mc_bases then
35608: LD_EXP 50
35612: NOT
35613: IFFALSE 35617
// exit ;
35615: GO 36223
// for i = 1 to mc_bases do
35617: LD_ADDR_VAR 0 2
35621: PUSH
35622: DOUBLE
35623: LD_INT 1
35625: DEC
35626: ST_TO_ADDR
35627: LD_EXP 50
35631: PUSH
35632: FOR_TO
35633: IFFALSE 36221
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
35635: LD_ADDR_VAR 0 3
35639: PUSH
35640: LD_EXP 50
35644: PUSH
35645: LD_VAR 0 2
35649: ARRAY
35650: PPUSH
35651: LD_INT 25
35653: PUSH
35654: LD_INT 4
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PPUSH
35661: CALL_OW 72
35665: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
35666: LD_VAR 0 3
35670: NOT
35671: PUSH
35672: LD_EXP 87
35676: PUSH
35677: LD_VAR 0 2
35681: ARRAY
35682: NOT
35683: OR
35684: PUSH
35685: LD_EXP 50
35689: PUSH
35690: LD_VAR 0 2
35694: ARRAY
35695: PPUSH
35696: LD_INT 2
35698: PUSH
35699: LD_INT 30
35701: PUSH
35702: LD_INT 0
35704: PUSH
35705: EMPTY
35706: LIST
35707: LIST
35708: PUSH
35709: LD_INT 30
35711: PUSH
35712: LD_INT 1
35714: PUSH
35715: EMPTY
35716: LIST
35717: LIST
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: LIST
35723: PPUSH
35724: CALL_OW 72
35728: NOT
35729: OR
35730: IFFALSE 35780
// begin if mc_deposits_finder [ i ] then
35732: LD_EXP 88
35736: PUSH
35737: LD_VAR 0 2
35741: ARRAY
35742: IFFALSE 35778
// begin MC_Reset ( i , 125 ) ;
35744: LD_VAR 0 2
35748: PPUSH
35749: LD_INT 125
35751: PPUSH
35752: CALL 19708 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
35756: LD_ADDR_EXP 88
35760: PUSH
35761: LD_EXP 88
35765: PPUSH
35766: LD_VAR 0 2
35770: PPUSH
35771: EMPTY
35772: PPUSH
35773: CALL_OW 1
35777: ST_TO_ADDR
// end ; continue ;
35778: GO 35632
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
35780: LD_EXP 87
35784: PUSH
35785: LD_VAR 0 2
35789: ARRAY
35790: PUSH
35791: LD_INT 1
35793: ARRAY
35794: PUSH
35795: LD_INT 3
35797: ARRAY
35798: PUSH
35799: LD_INT 1
35801: EQUAL
35802: PUSH
35803: LD_INT 20
35805: PPUSH
35806: LD_EXP 76
35810: PUSH
35811: LD_VAR 0 2
35815: ARRAY
35816: PPUSH
35817: CALL_OW 321
35821: PUSH
35822: LD_INT 2
35824: NONEQUAL
35825: AND
35826: IFFALSE 35876
// begin if mc_deposits_finder [ i ] then
35828: LD_EXP 88
35832: PUSH
35833: LD_VAR 0 2
35837: ARRAY
35838: IFFALSE 35874
// begin MC_Reset ( i , 125 ) ;
35840: LD_VAR 0 2
35844: PPUSH
35845: LD_INT 125
35847: PPUSH
35848: CALL 19708 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
35852: LD_ADDR_EXP 88
35856: PUSH
35857: LD_EXP 88
35861: PPUSH
35862: LD_VAR 0 2
35866: PPUSH
35867: EMPTY
35868: PPUSH
35869: CALL_OW 1
35873: ST_TO_ADDR
// end ; continue ;
35874: GO 35632
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
35876: LD_EXP 87
35880: PUSH
35881: LD_VAR 0 2
35885: ARRAY
35886: PUSH
35887: LD_INT 1
35889: ARRAY
35890: PUSH
35891: LD_INT 1
35893: ARRAY
35894: PPUSH
35895: LD_EXP 87
35899: PUSH
35900: LD_VAR 0 2
35904: ARRAY
35905: PUSH
35906: LD_INT 1
35908: ARRAY
35909: PUSH
35910: LD_INT 2
35912: ARRAY
35913: PPUSH
35914: LD_EXP 76
35918: PUSH
35919: LD_VAR 0 2
35923: ARRAY
35924: PPUSH
35925: CALL_OW 440
35929: IFFALSE 35972
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
35931: LD_ADDR_EXP 87
35935: PUSH
35936: LD_EXP 87
35940: PPUSH
35941: LD_VAR 0 2
35945: PPUSH
35946: LD_EXP 87
35950: PUSH
35951: LD_VAR 0 2
35955: ARRAY
35956: PPUSH
35957: LD_INT 1
35959: PPUSH
35960: CALL_OW 3
35964: PPUSH
35965: CALL_OW 1
35969: ST_TO_ADDR
35970: GO 36219
// begin if not mc_deposits_finder [ i ] then
35972: LD_EXP 88
35976: PUSH
35977: LD_VAR 0 2
35981: ARRAY
35982: NOT
35983: IFFALSE 36035
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
35985: LD_ADDR_EXP 88
35989: PUSH
35990: LD_EXP 88
35994: PPUSH
35995: LD_VAR 0 2
35999: PPUSH
36000: LD_VAR 0 3
36004: PUSH
36005: LD_INT 1
36007: ARRAY
36008: PUSH
36009: EMPTY
36010: LIST
36011: PPUSH
36012: CALL_OW 1
36016: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
36017: LD_VAR 0 3
36021: PUSH
36022: LD_INT 1
36024: ARRAY
36025: PPUSH
36026: LD_INT 125
36028: PPUSH
36029: CALL_OW 109
// end else
36033: GO 36219
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
36035: LD_EXP 88
36039: PUSH
36040: LD_VAR 0 2
36044: ARRAY
36045: PUSH
36046: LD_INT 1
36048: ARRAY
36049: PPUSH
36050: CALL_OW 310
36054: IFFALSE 36077
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
36056: LD_EXP 88
36060: PUSH
36061: LD_VAR 0 2
36065: ARRAY
36066: PUSH
36067: LD_INT 1
36069: ARRAY
36070: PPUSH
36071: CALL_OW 122
36075: GO 36219
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
36077: LD_EXP 88
36081: PUSH
36082: LD_VAR 0 2
36086: ARRAY
36087: PUSH
36088: LD_INT 1
36090: ARRAY
36091: PPUSH
36092: CALL_OW 314
36096: NOT
36097: PUSH
36098: LD_EXP 88
36102: PUSH
36103: LD_VAR 0 2
36107: ARRAY
36108: PUSH
36109: LD_INT 1
36111: ARRAY
36112: PPUSH
36113: LD_EXP 87
36117: PUSH
36118: LD_VAR 0 2
36122: ARRAY
36123: PUSH
36124: LD_INT 1
36126: ARRAY
36127: PUSH
36128: LD_INT 1
36130: ARRAY
36131: PPUSH
36132: LD_EXP 87
36136: PUSH
36137: LD_VAR 0 2
36141: ARRAY
36142: PUSH
36143: LD_INT 1
36145: ARRAY
36146: PUSH
36147: LD_INT 2
36149: ARRAY
36150: PPUSH
36151: CALL_OW 297
36155: PUSH
36156: LD_INT 6
36158: GREATER
36159: AND
36160: IFFALSE 36219
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
36162: LD_EXP 88
36166: PUSH
36167: LD_VAR 0 2
36171: ARRAY
36172: PUSH
36173: LD_INT 1
36175: ARRAY
36176: PPUSH
36177: LD_EXP 87
36181: PUSH
36182: LD_VAR 0 2
36186: ARRAY
36187: PUSH
36188: LD_INT 1
36190: ARRAY
36191: PUSH
36192: LD_INT 1
36194: ARRAY
36195: PPUSH
36196: LD_EXP 87
36200: PUSH
36201: LD_VAR 0 2
36205: ARRAY
36206: PUSH
36207: LD_INT 1
36209: ARRAY
36210: PUSH
36211: LD_INT 2
36213: ARRAY
36214: PPUSH
36215: CALL_OW 111
// end ; end ; end ;
36219: GO 35632
36221: POP
36222: POP
// end ;
36223: LD_VAR 0 1
36227: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
36228: LD_INT 0
36230: PPUSH
36231: PPUSH
36232: PPUSH
36233: PPUSH
36234: PPUSH
36235: PPUSH
36236: PPUSH
36237: PPUSH
36238: PPUSH
36239: PPUSH
36240: PPUSH
// if not mc_bases then
36241: LD_EXP 50
36245: NOT
36246: IFFALSE 36250
// exit ;
36248: GO 36974
// for i = 1 to mc_bases do
36250: LD_ADDR_VAR 0 2
36254: PUSH
36255: DOUBLE
36256: LD_INT 1
36258: DEC
36259: ST_TO_ADDR
36260: LD_EXP 50
36264: PUSH
36265: FOR_TO
36266: IFFALSE 36972
// begin if not mc_bases [ i ] then
36268: LD_EXP 50
36272: PUSH
36273: LD_VAR 0 2
36277: ARRAY
36278: NOT
36279: IFFALSE 36283
// continue ;
36281: GO 36265
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
36283: LD_ADDR_VAR 0 7
36287: PUSH
36288: LD_EXP 50
36292: PUSH
36293: LD_VAR 0 2
36297: ARRAY
36298: PUSH
36299: LD_INT 1
36301: ARRAY
36302: PPUSH
36303: CALL_OW 248
36307: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
36308: LD_VAR 0 7
36312: PUSH
36313: LD_INT 3
36315: EQUAL
36316: PUSH
36317: LD_EXP 69
36321: PUSH
36322: LD_VAR 0 2
36326: ARRAY
36327: PUSH
36328: LD_EXP 72
36332: PUSH
36333: LD_VAR 0 2
36337: ARRAY
36338: UNION
36339: PPUSH
36340: LD_INT 33
36342: PUSH
36343: LD_INT 2
36345: PUSH
36346: EMPTY
36347: LIST
36348: LIST
36349: PPUSH
36350: CALL_OW 72
36354: NOT
36355: OR
36356: IFFALSE 36360
// continue ;
36358: GO 36265
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
36360: LD_ADDR_VAR 0 9
36364: PUSH
36365: LD_EXP 50
36369: PUSH
36370: LD_VAR 0 2
36374: ARRAY
36375: PPUSH
36376: LD_INT 30
36378: PUSH
36379: LD_INT 36
36381: PUSH
36382: EMPTY
36383: LIST
36384: LIST
36385: PPUSH
36386: CALL_OW 72
36390: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
36391: LD_ADDR_VAR 0 10
36395: PUSH
36396: LD_EXP 69
36400: PUSH
36401: LD_VAR 0 2
36405: ARRAY
36406: PPUSH
36407: LD_INT 34
36409: PUSH
36410: LD_INT 31
36412: PUSH
36413: EMPTY
36414: LIST
36415: LIST
36416: PPUSH
36417: CALL_OW 72
36421: ST_TO_ADDR
// if not cts and not mcts then
36422: LD_VAR 0 9
36426: NOT
36427: PUSH
36428: LD_VAR 0 10
36432: NOT
36433: AND
36434: IFFALSE 36438
// continue ;
36436: GO 36265
// x := cts ;
36438: LD_ADDR_VAR 0 11
36442: PUSH
36443: LD_VAR 0 9
36447: ST_TO_ADDR
// if not x then
36448: LD_VAR 0 11
36452: NOT
36453: IFFALSE 36465
// x := mcts ;
36455: LD_ADDR_VAR 0 11
36459: PUSH
36460: LD_VAR 0 10
36464: ST_TO_ADDR
// if mc_remote_driver [ i ] then
36465: LD_EXP 90
36469: PUSH
36470: LD_VAR 0 2
36474: ARRAY
36475: IFFALSE 36744
// for j in mc_remote_driver [ i ] do
36477: LD_ADDR_VAR 0 3
36481: PUSH
36482: LD_EXP 90
36486: PUSH
36487: LD_VAR 0 2
36491: ARRAY
36492: PUSH
36493: FOR_IN
36494: IFFALSE 36742
// begin if GetClass ( j ) <> 3 then
36496: LD_VAR 0 3
36500: PPUSH
36501: CALL_OW 257
36505: PUSH
36506: LD_INT 3
36508: NONEQUAL
36509: IFFALSE 36562
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
36511: LD_ADDR_EXP 90
36515: PUSH
36516: LD_EXP 90
36520: PPUSH
36521: LD_VAR 0 2
36525: PPUSH
36526: LD_EXP 90
36530: PUSH
36531: LD_VAR 0 2
36535: ARRAY
36536: PUSH
36537: LD_VAR 0 3
36541: DIFF
36542: PPUSH
36543: CALL_OW 1
36547: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36548: LD_VAR 0 3
36552: PPUSH
36553: LD_INT 0
36555: PPUSH
36556: CALL_OW 109
// continue ;
36560: GO 36493
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
36562: LD_VAR 0 3
36566: PPUSH
36567: CALL_OW 310
36571: NOT
36572: PUSH
36573: LD_VAR 0 3
36577: PPUSH
36578: CALL_OW 310
36582: PPUSH
36583: CALL_OW 266
36587: PUSH
36588: LD_INT 36
36590: NONEQUAL
36591: PUSH
36592: LD_VAR 0 3
36596: PPUSH
36597: CALL 84350 0 1
36601: NOT
36602: AND
36603: OR
36604: IFFALSE 36740
// begin if IsInUnit ( j ) then
36606: LD_VAR 0 3
36610: PPUSH
36611: CALL_OW 310
36615: IFFALSE 36626
// ComExitBuilding ( j ) ;
36617: LD_VAR 0 3
36621: PPUSH
36622: CALL_OW 122
// ct := 0 ;
36626: LD_ADDR_VAR 0 8
36630: PUSH
36631: LD_INT 0
36633: ST_TO_ADDR
// for k in x do
36634: LD_ADDR_VAR 0 4
36638: PUSH
36639: LD_VAR 0 11
36643: PUSH
36644: FOR_IN
36645: IFFALSE 36718
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
36647: LD_VAR 0 4
36651: PPUSH
36652: CALL_OW 264
36656: PUSH
36657: LD_INT 31
36659: EQUAL
36660: PUSH
36661: LD_VAR 0 4
36665: PPUSH
36666: CALL_OW 311
36670: NOT
36671: AND
36672: PUSH
36673: LD_VAR 0 4
36677: PPUSH
36678: CALL_OW 266
36682: PUSH
36683: LD_INT 36
36685: EQUAL
36686: PUSH
36687: LD_VAR 0 4
36691: PPUSH
36692: CALL_OW 313
36696: PUSH
36697: LD_INT 3
36699: LESS
36700: AND
36701: OR
36702: IFFALSE 36716
// begin ct := k ;
36704: LD_ADDR_VAR 0 8
36708: PUSH
36709: LD_VAR 0 4
36713: ST_TO_ADDR
// break ;
36714: GO 36718
// end ;
36716: GO 36644
36718: POP
36719: POP
// if ct then
36720: LD_VAR 0 8
36724: IFFALSE 36740
// ComEnterUnit ( j , ct ) ;
36726: LD_VAR 0 3
36730: PPUSH
36731: LD_VAR 0 8
36735: PPUSH
36736: CALL_OW 120
// end ; end ;
36740: GO 36493
36742: POP
36743: POP
// places := 0 ;
36744: LD_ADDR_VAR 0 5
36748: PUSH
36749: LD_INT 0
36751: ST_TO_ADDR
// for j = 1 to x do
36752: LD_ADDR_VAR 0 3
36756: PUSH
36757: DOUBLE
36758: LD_INT 1
36760: DEC
36761: ST_TO_ADDR
36762: LD_VAR 0 11
36766: PUSH
36767: FOR_TO
36768: IFFALSE 36823
// if GetWeapon ( x [ j ] ) = ar_control_tower then
36770: LD_VAR 0 11
36774: PUSH
36775: LD_VAR 0 3
36779: ARRAY
36780: PPUSH
36781: CALL_OW 264
36785: PUSH
36786: LD_INT 31
36788: EQUAL
36789: IFFALSE 36807
// places := places + 1 else
36791: LD_ADDR_VAR 0 5
36795: PUSH
36796: LD_VAR 0 5
36800: PUSH
36801: LD_INT 1
36803: PLUS
36804: ST_TO_ADDR
36805: GO 36821
// places := places + 3 ;
36807: LD_ADDR_VAR 0 5
36811: PUSH
36812: LD_VAR 0 5
36816: PUSH
36817: LD_INT 3
36819: PLUS
36820: ST_TO_ADDR
36821: GO 36767
36823: POP
36824: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
36825: LD_ADDR_VAR 0 6
36829: PUSH
36830: LD_EXP 50
36834: PUSH
36835: LD_VAR 0 2
36839: ARRAY
36840: PPUSH
36841: LD_INT 25
36843: PUSH
36844: LD_INT 3
36846: PUSH
36847: EMPTY
36848: LIST
36849: LIST
36850: PPUSH
36851: CALL_OW 72
36855: PUSH
36856: LD_EXP 90
36860: PUSH
36861: LD_VAR 0 2
36865: ARRAY
36866: DIFF
36867: PPUSH
36868: LD_INT 3
36870: PPUSH
36871: CALL 85250 0 2
36875: ST_TO_ADDR
// if not tmp then
36876: LD_VAR 0 6
36880: NOT
36881: IFFALSE 36885
// continue ;
36883: GO 36265
// places := places - mc_remote_driver [ i ] ;
36885: LD_ADDR_VAR 0 5
36889: PUSH
36890: LD_VAR 0 5
36894: PUSH
36895: LD_EXP 90
36899: PUSH
36900: LD_VAR 0 2
36904: ARRAY
36905: MINUS
36906: ST_TO_ADDR
// if places then
36907: LD_VAR 0 5
36911: IFFALSE 36970
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
36913: LD_ADDR_EXP 90
36917: PUSH
36918: LD_EXP 90
36922: PPUSH
36923: LD_VAR 0 2
36927: PPUSH
36928: LD_EXP 90
36932: PUSH
36933: LD_VAR 0 2
36937: ARRAY
36938: PUSH
36939: LD_VAR 0 6
36943: PUSH
36944: LD_INT 1
36946: ARRAY
36947: UNION
36948: PPUSH
36949: CALL_OW 1
36953: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
36954: LD_VAR 0 6
36958: PUSH
36959: LD_INT 1
36961: ARRAY
36962: PPUSH
36963: LD_INT 126
36965: PPUSH
36966: CALL_OW 109
// end ; end ;
36970: GO 36265
36972: POP
36973: POP
// end ;
36974: LD_VAR 0 1
36978: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
36979: LD_INT 0
36981: PPUSH
36982: PPUSH
36983: PPUSH
36984: PPUSH
36985: PPUSH
36986: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
36987: LD_VAR 0 1
36991: NOT
36992: PUSH
36993: LD_VAR 0 2
36997: NOT
36998: OR
36999: PUSH
37000: LD_VAR 0 3
37004: NOT
37005: OR
37006: PUSH
37007: LD_VAR 0 4
37011: PUSH
37012: LD_INT 1
37014: PUSH
37015: LD_INT 2
37017: PUSH
37018: LD_INT 3
37020: PUSH
37021: LD_INT 4
37023: PUSH
37024: LD_INT 5
37026: PUSH
37027: LD_INT 8
37029: PUSH
37030: LD_INT 9
37032: PUSH
37033: LD_INT 15
37035: PUSH
37036: LD_INT 16
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: LIST
37043: LIST
37044: LIST
37045: LIST
37046: LIST
37047: LIST
37048: LIST
37049: IN
37050: NOT
37051: OR
37052: IFFALSE 37056
// exit ;
37054: GO 37956
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
37056: LD_ADDR_VAR 0 2
37060: PUSH
37061: LD_VAR 0 2
37065: PPUSH
37066: LD_INT 21
37068: PUSH
37069: LD_INT 3
37071: PUSH
37072: EMPTY
37073: LIST
37074: LIST
37075: PUSH
37076: LD_INT 24
37078: PUSH
37079: LD_INT 250
37081: PUSH
37082: EMPTY
37083: LIST
37084: LIST
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PPUSH
37090: CALL_OW 72
37094: ST_TO_ADDR
// case class of 1 , 15 :
37095: LD_VAR 0 4
37099: PUSH
37100: LD_INT 1
37102: DOUBLE
37103: EQUAL
37104: IFTRUE 37114
37106: LD_INT 15
37108: DOUBLE
37109: EQUAL
37110: IFTRUE 37114
37112: GO 37199
37114: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
37115: LD_ADDR_VAR 0 8
37119: PUSH
37120: LD_VAR 0 2
37124: PPUSH
37125: LD_INT 2
37127: PUSH
37128: LD_INT 30
37130: PUSH
37131: LD_INT 32
37133: PUSH
37134: EMPTY
37135: LIST
37136: LIST
37137: PUSH
37138: LD_INT 30
37140: PUSH
37141: LD_INT 31
37143: PUSH
37144: EMPTY
37145: LIST
37146: LIST
37147: PUSH
37148: EMPTY
37149: LIST
37150: LIST
37151: LIST
37152: PPUSH
37153: CALL_OW 72
37157: PUSH
37158: LD_VAR 0 2
37162: PPUSH
37163: LD_INT 2
37165: PUSH
37166: LD_INT 30
37168: PUSH
37169: LD_INT 4
37171: PUSH
37172: EMPTY
37173: LIST
37174: LIST
37175: PUSH
37176: LD_INT 30
37178: PUSH
37179: LD_INT 5
37181: PUSH
37182: EMPTY
37183: LIST
37184: LIST
37185: PUSH
37186: EMPTY
37187: LIST
37188: LIST
37189: LIST
37190: PPUSH
37191: CALL_OW 72
37195: ADD
37196: ST_TO_ADDR
37197: GO 37445
37199: LD_INT 2
37201: DOUBLE
37202: EQUAL
37203: IFTRUE 37213
37205: LD_INT 16
37207: DOUBLE
37208: EQUAL
37209: IFTRUE 37213
37211: GO 37259
37213: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
37214: LD_ADDR_VAR 0 8
37218: PUSH
37219: LD_VAR 0 2
37223: PPUSH
37224: LD_INT 2
37226: PUSH
37227: LD_INT 30
37229: PUSH
37230: LD_INT 0
37232: PUSH
37233: EMPTY
37234: LIST
37235: LIST
37236: PUSH
37237: LD_INT 30
37239: PUSH
37240: LD_INT 1
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: LIST
37251: PPUSH
37252: CALL_OW 72
37256: ST_TO_ADDR
37257: GO 37445
37259: LD_INT 3
37261: DOUBLE
37262: EQUAL
37263: IFTRUE 37267
37265: GO 37313
37267: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
37268: LD_ADDR_VAR 0 8
37272: PUSH
37273: LD_VAR 0 2
37277: PPUSH
37278: LD_INT 2
37280: PUSH
37281: LD_INT 30
37283: PUSH
37284: LD_INT 2
37286: PUSH
37287: EMPTY
37288: LIST
37289: LIST
37290: PUSH
37291: LD_INT 30
37293: PUSH
37294: LD_INT 3
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PUSH
37301: EMPTY
37302: LIST
37303: LIST
37304: LIST
37305: PPUSH
37306: CALL_OW 72
37310: ST_TO_ADDR
37311: GO 37445
37313: LD_INT 4
37315: DOUBLE
37316: EQUAL
37317: IFTRUE 37321
37319: GO 37378
37321: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
37322: LD_ADDR_VAR 0 8
37326: PUSH
37327: LD_VAR 0 2
37331: PPUSH
37332: LD_INT 2
37334: PUSH
37335: LD_INT 30
37337: PUSH
37338: LD_INT 6
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: PUSH
37345: LD_INT 30
37347: PUSH
37348: LD_INT 7
37350: PUSH
37351: EMPTY
37352: LIST
37353: LIST
37354: PUSH
37355: LD_INT 30
37357: PUSH
37358: LD_INT 8
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: LIST
37369: LIST
37370: PPUSH
37371: CALL_OW 72
37375: ST_TO_ADDR
37376: GO 37445
37378: LD_INT 5
37380: DOUBLE
37381: EQUAL
37382: IFTRUE 37398
37384: LD_INT 8
37386: DOUBLE
37387: EQUAL
37388: IFTRUE 37398
37390: LD_INT 9
37392: DOUBLE
37393: EQUAL
37394: IFTRUE 37398
37396: GO 37444
37398: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
37399: LD_ADDR_VAR 0 8
37403: PUSH
37404: LD_VAR 0 2
37408: PPUSH
37409: LD_INT 2
37411: PUSH
37412: LD_INT 30
37414: PUSH
37415: LD_INT 4
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: PUSH
37422: LD_INT 30
37424: PUSH
37425: LD_INT 5
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: EMPTY
37433: LIST
37434: LIST
37435: LIST
37436: PPUSH
37437: CALL_OW 72
37441: ST_TO_ADDR
37442: GO 37445
37444: POP
// if not tmp then
37445: LD_VAR 0 8
37449: NOT
37450: IFFALSE 37454
// exit ;
37452: GO 37956
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
37454: LD_VAR 0 4
37458: PUSH
37459: LD_INT 1
37461: PUSH
37462: LD_INT 15
37464: PUSH
37465: EMPTY
37466: LIST
37467: LIST
37468: IN
37469: PUSH
37470: LD_EXP 59
37474: PUSH
37475: LD_VAR 0 1
37479: ARRAY
37480: AND
37481: IFFALSE 37637
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
37483: LD_ADDR_VAR 0 9
37487: PUSH
37488: LD_EXP 59
37492: PUSH
37493: LD_VAR 0 1
37497: ARRAY
37498: PUSH
37499: LD_INT 1
37501: ARRAY
37502: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
37503: LD_VAR 0 9
37507: PUSH
37508: LD_EXP 60
37512: PUSH
37513: LD_VAR 0 1
37517: ARRAY
37518: IN
37519: NOT
37520: IFFALSE 37635
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
37522: LD_ADDR_EXP 60
37526: PUSH
37527: LD_EXP 60
37531: PPUSH
37532: LD_VAR 0 1
37536: PUSH
37537: LD_EXP 60
37541: PUSH
37542: LD_VAR 0 1
37546: ARRAY
37547: PUSH
37548: LD_INT 1
37550: PLUS
37551: PUSH
37552: EMPTY
37553: LIST
37554: LIST
37555: PPUSH
37556: LD_VAR 0 9
37560: PPUSH
37561: CALL 51065 0 3
37565: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
37566: LD_ADDR_EXP 59
37570: PUSH
37571: LD_EXP 59
37575: PPUSH
37576: LD_VAR 0 1
37580: PPUSH
37581: LD_EXP 59
37585: PUSH
37586: LD_VAR 0 1
37590: ARRAY
37591: PUSH
37592: LD_VAR 0 9
37596: DIFF
37597: PPUSH
37598: CALL_OW 1
37602: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
37603: LD_VAR 0 3
37607: PPUSH
37608: LD_EXP 60
37612: PUSH
37613: LD_VAR 0 1
37617: ARRAY
37618: PUSH
37619: LD_EXP 60
37623: PUSH
37624: LD_VAR 0 1
37628: ARRAY
37629: ARRAY
37630: PPUSH
37631: CALL_OW 120
// end ; exit ;
37635: GO 37956
// end ; if tmp > 1 then
37637: LD_VAR 0 8
37641: PUSH
37642: LD_INT 1
37644: GREATER
37645: IFFALSE 37749
// for i = 2 to tmp do
37647: LD_ADDR_VAR 0 6
37651: PUSH
37652: DOUBLE
37653: LD_INT 2
37655: DEC
37656: ST_TO_ADDR
37657: LD_VAR 0 8
37661: PUSH
37662: FOR_TO
37663: IFFALSE 37747
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
37665: LD_VAR 0 8
37669: PUSH
37670: LD_VAR 0 6
37674: ARRAY
37675: PPUSH
37676: CALL_OW 461
37680: PUSH
37681: LD_INT 6
37683: EQUAL
37684: IFFALSE 37745
// begin x := tmp [ i ] ;
37686: LD_ADDR_VAR 0 9
37690: PUSH
37691: LD_VAR 0 8
37695: PUSH
37696: LD_VAR 0 6
37700: ARRAY
37701: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
37702: LD_ADDR_VAR 0 8
37706: PUSH
37707: LD_VAR 0 8
37711: PPUSH
37712: LD_VAR 0 6
37716: PPUSH
37717: CALL_OW 3
37721: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
37722: LD_ADDR_VAR 0 8
37726: PUSH
37727: LD_VAR 0 8
37731: PPUSH
37732: LD_INT 1
37734: PPUSH
37735: LD_VAR 0 9
37739: PPUSH
37740: CALL_OW 2
37744: ST_TO_ADDR
// end ;
37745: GO 37662
37747: POP
37748: POP
// for i in tmp do
37749: LD_ADDR_VAR 0 6
37753: PUSH
37754: LD_VAR 0 8
37758: PUSH
37759: FOR_IN
37760: IFFALSE 37829
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
37762: LD_VAR 0 6
37766: PPUSH
37767: CALL_OW 313
37771: PUSH
37772: LD_INT 6
37774: LESS
37775: PUSH
37776: LD_VAR 0 6
37780: PPUSH
37781: CALL_OW 266
37785: PUSH
37786: LD_INT 31
37788: PUSH
37789: LD_INT 32
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: IN
37796: NOT
37797: AND
37798: PUSH
37799: LD_VAR 0 6
37803: PPUSH
37804: CALL_OW 313
37808: PUSH
37809: LD_INT 0
37811: EQUAL
37812: OR
37813: IFFALSE 37827
// begin j := i ;
37815: LD_ADDR_VAR 0 7
37819: PUSH
37820: LD_VAR 0 6
37824: ST_TO_ADDR
// break ;
37825: GO 37829
// end ; end ;
37827: GO 37759
37829: POP
37830: POP
// if j then
37831: LD_VAR 0 7
37835: IFFALSE 37853
// ComEnterUnit ( unit , j ) else
37837: LD_VAR 0 3
37841: PPUSH
37842: LD_VAR 0 7
37846: PPUSH
37847: CALL_OW 120
37851: GO 37956
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37853: LD_ADDR_VAR 0 10
37857: PUSH
37858: LD_VAR 0 2
37862: PPUSH
37863: LD_INT 2
37865: PUSH
37866: LD_INT 30
37868: PUSH
37869: LD_INT 0
37871: PUSH
37872: EMPTY
37873: LIST
37874: LIST
37875: PUSH
37876: LD_INT 30
37878: PUSH
37879: LD_INT 1
37881: PUSH
37882: EMPTY
37883: LIST
37884: LIST
37885: PUSH
37886: EMPTY
37887: LIST
37888: LIST
37889: LIST
37890: PPUSH
37891: CALL_OW 72
37895: ST_TO_ADDR
// if depot then
37896: LD_VAR 0 10
37900: IFFALSE 37956
// begin depot := NearestUnitToUnit ( depot , unit ) ;
37902: LD_ADDR_VAR 0 10
37906: PUSH
37907: LD_VAR 0 10
37911: PPUSH
37912: LD_VAR 0 3
37916: PPUSH
37917: CALL_OW 74
37921: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
37922: LD_VAR 0 3
37926: PPUSH
37927: LD_VAR 0 10
37931: PPUSH
37932: CALL_OW 296
37936: PUSH
37937: LD_INT 10
37939: GREATER
37940: IFFALSE 37956
// ComStandNearbyBuilding ( unit , depot ) ;
37942: LD_VAR 0 3
37946: PPUSH
37947: LD_VAR 0 10
37951: PPUSH
37952: CALL 45742 0 2
// end ; end ; end ;
37956: LD_VAR 0 5
37960: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
37961: LD_INT 0
37963: PPUSH
37964: PPUSH
37965: PPUSH
37966: PPUSH
// if not mc_bases then
37967: LD_EXP 50
37971: NOT
37972: IFFALSE 37976
// exit ;
37974: GO 38215
// for i = 1 to mc_bases do
37976: LD_ADDR_VAR 0 2
37980: PUSH
37981: DOUBLE
37982: LD_INT 1
37984: DEC
37985: ST_TO_ADDR
37986: LD_EXP 50
37990: PUSH
37991: FOR_TO
37992: IFFALSE 38213
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
37994: LD_ADDR_VAR 0 4
37998: PUSH
37999: LD_EXP 50
38003: PUSH
38004: LD_VAR 0 2
38008: ARRAY
38009: PPUSH
38010: LD_INT 21
38012: PUSH
38013: LD_INT 1
38015: PUSH
38016: EMPTY
38017: LIST
38018: LIST
38019: PPUSH
38020: CALL_OW 72
38024: PUSH
38025: LD_EXP 79
38029: PUSH
38030: LD_VAR 0 2
38034: ARRAY
38035: UNION
38036: ST_TO_ADDR
// if not tmp then
38037: LD_VAR 0 4
38041: NOT
38042: IFFALSE 38046
// continue ;
38044: GO 37991
// for j in tmp do
38046: LD_ADDR_VAR 0 3
38050: PUSH
38051: LD_VAR 0 4
38055: PUSH
38056: FOR_IN
38057: IFFALSE 38209
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
38059: LD_VAR 0 3
38063: PPUSH
38064: CALL_OW 110
38068: NOT
38069: PUSH
38070: LD_VAR 0 3
38074: PPUSH
38075: CALL_OW 314
38079: NOT
38080: AND
38081: PUSH
38082: LD_VAR 0 3
38086: PPUSH
38087: CALL_OW 311
38091: NOT
38092: AND
38093: PUSH
38094: LD_VAR 0 3
38098: PPUSH
38099: CALL_OW 310
38103: NOT
38104: AND
38105: PUSH
38106: LD_VAR 0 3
38110: PUSH
38111: LD_EXP 53
38115: PUSH
38116: LD_VAR 0 2
38120: ARRAY
38121: PUSH
38122: LD_INT 1
38124: ARRAY
38125: IN
38126: NOT
38127: AND
38128: PUSH
38129: LD_VAR 0 3
38133: PUSH
38134: LD_EXP 53
38138: PUSH
38139: LD_VAR 0 2
38143: ARRAY
38144: PUSH
38145: LD_INT 2
38147: ARRAY
38148: IN
38149: NOT
38150: AND
38151: PUSH
38152: LD_VAR 0 3
38156: PUSH
38157: LD_EXP 62
38161: PUSH
38162: LD_VAR 0 2
38166: ARRAY
38167: IN
38168: NOT
38169: AND
38170: IFFALSE 38207
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
38172: LD_VAR 0 2
38176: PPUSH
38177: LD_EXP 50
38181: PUSH
38182: LD_VAR 0 2
38186: ARRAY
38187: PPUSH
38188: LD_VAR 0 3
38192: PPUSH
38193: LD_VAR 0 3
38197: PPUSH
38198: CALL_OW 257
38202: PPUSH
38203: CALL 36979 0 4
// end ;
38207: GO 38056
38209: POP
38210: POP
// end ;
38211: GO 37991
38213: POP
38214: POP
// end ;
38215: LD_VAR 0 1
38219: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
38220: LD_INT 0
38222: PPUSH
38223: PPUSH
38224: PPUSH
38225: PPUSH
38226: PPUSH
38227: PPUSH
// if not mc_bases [ base ] then
38228: LD_EXP 50
38232: PUSH
38233: LD_VAR 0 1
38237: ARRAY
38238: NOT
38239: IFFALSE 38243
// exit ;
38241: GO 38425
// tmp := [ ] ;
38243: LD_ADDR_VAR 0 6
38247: PUSH
38248: EMPTY
38249: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
38250: LD_ADDR_VAR 0 7
38254: PUSH
38255: LD_VAR 0 3
38259: PPUSH
38260: LD_INT 0
38262: PPUSH
38263: CALL_OW 517
38267: ST_TO_ADDR
// if not list then
38268: LD_VAR 0 7
38272: NOT
38273: IFFALSE 38277
// exit ;
38275: GO 38425
// for i = 1 to amount do
38277: LD_ADDR_VAR 0 5
38281: PUSH
38282: DOUBLE
38283: LD_INT 1
38285: DEC
38286: ST_TO_ADDR
38287: LD_VAR 0 2
38291: PUSH
38292: FOR_TO
38293: IFFALSE 38373
// begin x := rand ( 1 , list [ 1 ] ) ;
38295: LD_ADDR_VAR 0 8
38299: PUSH
38300: LD_INT 1
38302: PPUSH
38303: LD_VAR 0 7
38307: PUSH
38308: LD_INT 1
38310: ARRAY
38311: PPUSH
38312: CALL_OW 12
38316: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
38317: LD_ADDR_VAR 0 6
38321: PUSH
38322: LD_VAR 0 6
38326: PPUSH
38327: LD_VAR 0 5
38331: PPUSH
38332: LD_VAR 0 7
38336: PUSH
38337: LD_INT 1
38339: ARRAY
38340: PUSH
38341: LD_VAR 0 8
38345: ARRAY
38346: PUSH
38347: LD_VAR 0 7
38351: PUSH
38352: LD_INT 2
38354: ARRAY
38355: PUSH
38356: LD_VAR 0 8
38360: ARRAY
38361: PUSH
38362: EMPTY
38363: LIST
38364: LIST
38365: PPUSH
38366: CALL_OW 1
38370: ST_TO_ADDR
// end ;
38371: GO 38292
38373: POP
38374: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
38375: LD_ADDR_EXP 63
38379: PUSH
38380: LD_EXP 63
38384: PPUSH
38385: LD_VAR 0 1
38389: PPUSH
38390: LD_VAR 0 6
38394: PPUSH
38395: CALL_OW 1
38399: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
38400: LD_ADDR_EXP 65
38404: PUSH
38405: LD_EXP 65
38409: PPUSH
38410: LD_VAR 0 1
38414: PPUSH
38415: LD_VAR 0 3
38419: PPUSH
38420: CALL_OW 1
38424: ST_TO_ADDR
// end ;
38425: LD_VAR 0 4
38429: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
38430: LD_INT 0
38432: PPUSH
// if not mc_bases [ base ] then
38433: LD_EXP 50
38437: PUSH
38438: LD_VAR 0 1
38442: ARRAY
38443: NOT
38444: IFFALSE 38448
// exit ;
38446: GO 38473
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
38448: LD_ADDR_EXP 55
38452: PUSH
38453: LD_EXP 55
38457: PPUSH
38458: LD_VAR 0 1
38462: PPUSH
38463: LD_VAR 0 2
38467: PPUSH
38468: CALL_OW 1
38472: ST_TO_ADDR
// end ;
38473: LD_VAR 0 3
38477: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
38478: LD_INT 0
38480: PPUSH
// if not mc_bases [ base ] then
38481: LD_EXP 50
38485: PUSH
38486: LD_VAR 0 1
38490: ARRAY
38491: NOT
38492: IFFALSE 38496
// exit ;
38494: GO 38533
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
38496: LD_ADDR_EXP 55
38500: PUSH
38501: LD_EXP 55
38505: PPUSH
38506: LD_VAR 0 1
38510: PPUSH
38511: LD_EXP 55
38515: PUSH
38516: LD_VAR 0 1
38520: ARRAY
38521: PUSH
38522: LD_VAR 0 2
38526: UNION
38527: PPUSH
38528: CALL_OW 1
38532: ST_TO_ADDR
// end ;
38533: LD_VAR 0 3
38537: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
38538: LD_INT 0
38540: PPUSH
// if not mc_bases [ base ] then
38541: LD_EXP 50
38545: PUSH
38546: LD_VAR 0 1
38550: ARRAY
38551: NOT
38552: IFFALSE 38556
// exit ;
38554: GO 38581
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
38556: LD_ADDR_EXP 71
38560: PUSH
38561: LD_EXP 71
38565: PPUSH
38566: LD_VAR 0 1
38570: PPUSH
38571: LD_VAR 0 2
38575: PPUSH
38576: CALL_OW 1
38580: ST_TO_ADDR
// end ;
38581: LD_VAR 0 3
38585: RET
// export function MC_InsertProduceList ( base , compontents ) ; begin
38586: LD_INT 0
38588: PPUSH
// if not mc_bases [ base ] then
38589: LD_EXP 50
38593: PUSH
38594: LD_VAR 0 1
38598: ARRAY
38599: NOT
38600: IFFALSE 38604
// exit ;
38602: GO 38641
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] union compontents ) ;
38604: LD_ADDR_EXP 71
38608: PUSH
38609: LD_EXP 71
38613: PPUSH
38614: LD_VAR 0 1
38618: PPUSH
38619: LD_EXP 71
38623: PUSH
38624: LD_VAR 0 1
38628: ARRAY
38629: PUSH
38630: LD_VAR 0 2
38634: UNION
38635: PPUSH
38636: CALL_OW 1
38640: ST_TO_ADDR
// end ;
38641: LD_VAR 0 3
38645: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
38646: LD_INT 0
38648: PPUSH
// if not mc_bases [ base ] then
38649: LD_EXP 50
38653: PUSH
38654: LD_VAR 0 1
38658: ARRAY
38659: NOT
38660: IFFALSE 38664
// exit ;
38662: GO 38776
// mc_defender := Replace ( mc_defender , base , deflist ) ;
38664: LD_ADDR_EXP 72
38668: PUSH
38669: LD_EXP 72
38673: PPUSH
38674: LD_VAR 0 1
38678: PPUSH
38679: LD_VAR 0 2
38683: PPUSH
38684: CALL_OW 1
38688: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
38689: LD_ADDR_EXP 61
38693: PUSH
38694: LD_EXP 61
38698: PPUSH
38699: LD_VAR 0 1
38703: PPUSH
38704: LD_VAR 0 2
38708: PUSH
38709: LD_INT 0
38711: PLUS
38712: PPUSH
38713: CALL_OW 1
38717: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] union UnitFilter ( mc_defender [ base ] , [ f_type , unit_vehicle ] ) ) ;
38718: LD_ADDR_EXP 69
38722: PUSH
38723: LD_EXP 69
38727: PPUSH
38728: LD_VAR 0 1
38732: PPUSH
38733: LD_EXP 69
38737: PUSH
38738: LD_VAR 0 1
38742: ARRAY
38743: PUSH
38744: LD_EXP 72
38748: PUSH
38749: LD_VAR 0 1
38753: ARRAY
38754: PPUSH
38755: LD_INT 21
38757: PUSH
38758: LD_INT 2
38760: PUSH
38761: EMPTY
38762: LIST
38763: LIST
38764: PPUSH
38765: CALL_OW 72
38769: UNION
38770: PPUSH
38771: CALL_OW 1
38775: ST_TO_ADDR
// end ;
38776: LD_VAR 0 3
38780: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
38781: LD_INT 0
38783: PPUSH
// if not mc_bases [ base ] then
38784: LD_EXP 50
38788: PUSH
38789: LD_VAR 0 1
38793: ARRAY
38794: NOT
38795: IFFALSE 38799
// exit ;
38797: GO 38824
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
38799: LD_ADDR_EXP 61
38803: PUSH
38804: LD_EXP 61
38808: PPUSH
38809: LD_VAR 0 1
38813: PPUSH
38814: LD_VAR 0 2
38818: PPUSH
38819: CALL_OW 1
38823: ST_TO_ADDR
// end ;
38824: LD_VAR 0 3
38828: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
38829: LD_INT 0
38831: PPUSH
38832: PPUSH
38833: PPUSH
38834: PPUSH
// if not mc_bases [ base ] then
38835: LD_EXP 50
38839: PUSH
38840: LD_VAR 0 1
38844: ARRAY
38845: NOT
38846: IFFALSE 38850
// exit ;
38848: GO 38915
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
38850: LD_ADDR_EXP 70
38854: PUSH
38855: LD_EXP 70
38859: PPUSH
38860: LD_VAR 0 1
38864: PUSH
38865: LD_EXP 70
38869: PUSH
38870: LD_VAR 0 1
38874: ARRAY
38875: PUSH
38876: LD_INT 1
38878: PLUS
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PPUSH
38884: LD_VAR 0 1
38888: PUSH
38889: LD_VAR 0 2
38893: PUSH
38894: LD_VAR 0 3
38898: PUSH
38899: LD_VAR 0 4
38903: PUSH
38904: EMPTY
38905: LIST
38906: LIST
38907: LIST
38908: LIST
38909: PPUSH
38910: CALL 51065 0 3
38914: ST_TO_ADDR
// end ;
38915: LD_VAR 0 5
38919: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
38920: LD_INT 0
38922: PPUSH
// if not mc_bases [ base ] then
38923: LD_EXP 50
38927: PUSH
38928: LD_VAR 0 1
38932: ARRAY
38933: NOT
38934: IFFALSE 38938
// exit ;
38936: GO 38963
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
38938: LD_ADDR_EXP 87
38942: PUSH
38943: LD_EXP 87
38947: PPUSH
38948: LD_VAR 0 1
38952: PPUSH
38953: LD_VAR 0 2
38957: PPUSH
38958: CALL_OW 1
38962: ST_TO_ADDR
// end ;
38963: LD_VAR 0 3
38967: RET
// export function MC_GetMinesField ( base ) ; begin
38968: LD_INT 0
38970: PPUSH
// result := mc_mines [ base ] ;
38971: LD_ADDR_VAR 0 2
38975: PUSH
38976: LD_EXP 63
38980: PUSH
38981: LD_VAR 0 1
38985: ARRAY
38986: ST_TO_ADDR
// end ;
38987: LD_VAR 0 2
38991: RET
// export function MC_GetProduceList ( base ) ; begin
38992: LD_INT 0
38994: PPUSH
// result := mc_produce [ base ] ;
38995: LD_ADDR_VAR 0 2
38999: PUSH
39000: LD_EXP 71
39004: PUSH
39005: LD_VAR 0 1
39009: ARRAY
39010: ST_TO_ADDR
// end ;
39011: LD_VAR 0 2
39015: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
39016: LD_INT 0
39018: PPUSH
39019: PPUSH
// if not mc_bases then
39020: LD_EXP 50
39024: NOT
39025: IFFALSE 39029
// exit ;
39027: GO 39094
// if mc_bases [ base ] then
39029: LD_EXP 50
39033: PUSH
39034: LD_VAR 0 1
39038: ARRAY
39039: IFFALSE 39094
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
39041: LD_ADDR_VAR 0 3
39045: PUSH
39046: LD_EXP 50
39050: PUSH
39051: LD_VAR 0 1
39055: ARRAY
39056: PPUSH
39057: LD_INT 30
39059: PUSH
39060: LD_VAR 0 2
39064: PUSH
39065: EMPTY
39066: LIST
39067: LIST
39068: PPUSH
39069: CALL_OW 72
39073: ST_TO_ADDR
// if result then
39074: LD_VAR 0 3
39078: IFFALSE 39094
// result := result [ 1 ] ;
39080: LD_ADDR_VAR 0 3
39084: PUSH
39085: LD_VAR 0 3
39089: PUSH
39090: LD_INT 1
39092: ARRAY
39093: ST_TO_ADDR
// end ; end ;
39094: LD_VAR 0 3
39098: RET
// export function MC_SetTame ( base , area ) ; begin
39099: LD_INT 0
39101: PPUSH
// if not mc_bases or not base then
39102: LD_EXP 50
39106: NOT
39107: PUSH
39108: LD_VAR 0 1
39112: NOT
39113: OR
39114: IFFALSE 39118
// exit ;
39116: GO 39143
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
39118: LD_ADDR_EXP 78
39122: PUSH
39123: LD_EXP 78
39127: PPUSH
39128: LD_VAR 0 1
39132: PPUSH
39133: LD_VAR 0 2
39137: PPUSH
39138: CALL_OW 1
39142: ST_TO_ADDR
// end ;
39143: LD_VAR 0 3
39147: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
39148: LD_INT 0
39150: PPUSH
39151: PPUSH
// if not mc_bases or not base then
39152: LD_EXP 50
39156: NOT
39157: PUSH
39158: LD_VAR 0 1
39162: NOT
39163: OR
39164: IFFALSE 39168
// exit ;
39166: GO 39270
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
39168: LD_ADDR_VAR 0 4
39172: PUSH
39173: LD_EXP 50
39177: PUSH
39178: LD_VAR 0 1
39182: ARRAY
39183: PPUSH
39184: LD_INT 30
39186: PUSH
39187: LD_VAR 0 2
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PPUSH
39196: CALL_OW 72
39200: ST_TO_ADDR
// if not tmp then
39201: LD_VAR 0 4
39205: NOT
39206: IFFALSE 39210
// exit ;
39208: GO 39270
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
39210: LD_ADDR_EXP 82
39214: PUSH
39215: LD_EXP 82
39219: PPUSH
39220: LD_VAR 0 1
39224: PPUSH
39225: LD_EXP 82
39229: PUSH
39230: LD_VAR 0 1
39234: ARRAY
39235: PPUSH
39236: LD_EXP 82
39240: PUSH
39241: LD_VAR 0 1
39245: ARRAY
39246: PUSH
39247: LD_INT 1
39249: PLUS
39250: PPUSH
39251: LD_VAR 0 4
39255: PUSH
39256: LD_INT 1
39258: ARRAY
39259: PPUSH
39260: CALL_OW 2
39264: PPUSH
39265: CALL_OW 1
39269: ST_TO_ADDR
// end ;
39270: LD_VAR 0 3
39274: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
39275: LD_INT 0
39277: PPUSH
39278: PPUSH
// if not mc_bases or not base or not kinds then
39279: LD_EXP 50
39283: NOT
39284: PUSH
39285: LD_VAR 0 1
39289: NOT
39290: OR
39291: PUSH
39292: LD_VAR 0 2
39296: NOT
39297: OR
39298: IFFALSE 39302
// exit ;
39300: GO 39363
// for i in kinds do
39302: LD_ADDR_VAR 0 4
39306: PUSH
39307: LD_VAR 0 2
39311: PUSH
39312: FOR_IN
39313: IFFALSE 39361
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
39315: LD_ADDR_EXP 84
39319: PUSH
39320: LD_EXP 84
39324: PPUSH
39325: LD_VAR 0 1
39329: PUSH
39330: LD_EXP 84
39334: PUSH
39335: LD_VAR 0 1
39339: ARRAY
39340: PUSH
39341: LD_INT 1
39343: PLUS
39344: PUSH
39345: EMPTY
39346: LIST
39347: LIST
39348: PPUSH
39349: LD_VAR 0 4
39353: PPUSH
39354: CALL 51065 0 3
39358: ST_TO_ADDR
39359: GO 39312
39361: POP
39362: POP
// end ;
39363: LD_VAR 0 3
39367: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
39368: LD_INT 0
39370: PPUSH
// if not mc_bases or not base or not areas then
39371: LD_EXP 50
39375: NOT
39376: PUSH
39377: LD_VAR 0 1
39381: NOT
39382: OR
39383: PUSH
39384: LD_VAR 0 2
39388: NOT
39389: OR
39390: IFFALSE 39394
// exit ;
39392: GO 39419
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
39394: LD_ADDR_EXP 68
39398: PUSH
39399: LD_EXP 68
39403: PPUSH
39404: LD_VAR 0 1
39408: PPUSH
39409: LD_VAR 0 2
39413: PPUSH
39414: CALL_OW 1
39418: ST_TO_ADDR
// end ;
39419: LD_VAR 0 3
39423: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
39424: LD_INT 0
39426: PPUSH
// if not mc_bases or not base or not teleports_exit then
39427: LD_EXP 50
39431: NOT
39432: PUSH
39433: LD_VAR 0 1
39437: NOT
39438: OR
39439: PUSH
39440: LD_VAR 0 2
39444: NOT
39445: OR
39446: IFFALSE 39450
// exit ;
39448: GO 39475
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
39450: LD_ADDR_EXP 85
39454: PUSH
39455: LD_EXP 85
39459: PPUSH
39460: LD_VAR 0 1
39464: PPUSH
39465: LD_VAR 0 2
39469: PPUSH
39470: CALL_OW 1
39474: ST_TO_ADDR
// end ;
39475: LD_VAR 0 3
39479: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
39480: LD_INT 0
39482: PPUSH
39483: PPUSH
39484: PPUSH
// if not mc_bases or not base or not ext_list then
39485: LD_EXP 50
39489: NOT
39490: PUSH
39491: LD_VAR 0 1
39495: NOT
39496: OR
39497: PUSH
39498: LD_VAR 0 5
39502: NOT
39503: OR
39504: IFFALSE 39508
// exit ;
39506: GO 39681
// tmp := GetFacExtXYD ( x , y , d ) ;
39508: LD_ADDR_VAR 0 8
39512: PUSH
39513: LD_VAR 0 2
39517: PPUSH
39518: LD_VAR 0 3
39522: PPUSH
39523: LD_VAR 0 4
39527: PPUSH
39528: CALL 84380 0 3
39532: ST_TO_ADDR
// if not tmp then
39533: LD_VAR 0 8
39537: NOT
39538: IFFALSE 39542
// exit ;
39540: GO 39681
// for i in tmp do
39542: LD_ADDR_VAR 0 7
39546: PUSH
39547: LD_VAR 0 8
39551: PUSH
39552: FOR_IN
39553: IFFALSE 39679
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
39555: LD_ADDR_EXP 55
39559: PUSH
39560: LD_EXP 55
39564: PPUSH
39565: LD_VAR 0 1
39569: PPUSH
39570: LD_EXP 55
39574: PUSH
39575: LD_VAR 0 1
39579: ARRAY
39580: PPUSH
39581: LD_EXP 55
39585: PUSH
39586: LD_VAR 0 1
39590: ARRAY
39591: PUSH
39592: LD_INT 1
39594: PLUS
39595: PPUSH
39596: LD_VAR 0 5
39600: PUSH
39601: LD_INT 1
39603: ARRAY
39604: PUSH
39605: LD_VAR 0 7
39609: PUSH
39610: LD_INT 1
39612: ARRAY
39613: PUSH
39614: LD_VAR 0 7
39618: PUSH
39619: LD_INT 2
39621: ARRAY
39622: PUSH
39623: LD_VAR 0 7
39627: PUSH
39628: LD_INT 3
39630: ARRAY
39631: PUSH
39632: EMPTY
39633: LIST
39634: LIST
39635: LIST
39636: LIST
39637: PPUSH
39638: CALL_OW 2
39642: PPUSH
39643: CALL_OW 1
39647: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
39648: LD_ADDR_VAR 0 5
39652: PUSH
39653: LD_VAR 0 5
39657: PPUSH
39658: LD_INT 1
39660: PPUSH
39661: CALL_OW 3
39665: ST_TO_ADDR
// if not ext_list then
39666: LD_VAR 0 5
39670: NOT
39671: IFFALSE 39677
// exit ;
39673: POP
39674: POP
39675: GO 39681
// end ;
39677: GO 39552
39679: POP
39680: POP
// end ;
39681: LD_VAR 0 6
39685: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
39686: LD_INT 0
39688: PPUSH
// if not mc_bases or not base or not weapon_list then
39689: LD_EXP 50
39693: NOT
39694: PUSH
39695: LD_VAR 0 1
39699: NOT
39700: OR
39701: PUSH
39702: LD_VAR 0 2
39706: NOT
39707: OR
39708: IFFALSE 39712
// exit ;
39710: GO 39737
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
39712: LD_ADDR_EXP 89
39716: PUSH
39717: LD_EXP 89
39721: PPUSH
39722: LD_VAR 0 1
39726: PPUSH
39727: LD_VAR 0 2
39731: PPUSH
39732: CALL_OW 1
39736: ST_TO_ADDR
// end ;
39737: LD_VAR 0 3
39741: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
39742: LD_INT 0
39744: PPUSH
// if not mc_bases or not base or not tech_list then
39745: LD_EXP 50
39749: NOT
39750: PUSH
39751: LD_VAR 0 1
39755: NOT
39756: OR
39757: PUSH
39758: LD_VAR 0 2
39762: NOT
39763: OR
39764: IFFALSE 39768
// exit ;
39766: GO 39793
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
39768: LD_ADDR_EXP 77
39772: PUSH
39773: LD_EXP 77
39777: PPUSH
39778: LD_VAR 0 1
39782: PPUSH
39783: LD_VAR 0 2
39787: PPUSH
39788: CALL_OW 1
39792: ST_TO_ADDR
// end ;
39793: LD_VAR 0 3
39797: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
39798: LD_INT 0
39800: PPUSH
// if not mc_bases or not parking_area or not base then
39801: LD_EXP 50
39805: NOT
39806: PUSH
39807: LD_VAR 0 2
39811: NOT
39812: OR
39813: PUSH
39814: LD_VAR 0 1
39818: NOT
39819: OR
39820: IFFALSE 39824
// exit ;
39822: GO 39849
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
39824: LD_ADDR_EXP 74
39828: PUSH
39829: LD_EXP 74
39833: PPUSH
39834: LD_VAR 0 1
39838: PPUSH
39839: LD_VAR 0 2
39843: PPUSH
39844: CALL_OW 1
39848: ST_TO_ADDR
// end ;
39849: LD_VAR 0 3
39853: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
39854: LD_INT 0
39856: PPUSH
// if not mc_bases or not base or not scan_area then
39857: LD_EXP 50
39861: NOT
39862: PUSH
39863: LD_VAR 0 1
39867: NOT
39868: OR
39869: PUSH
39870: LD_VAR 0 2
39874: NOT
39875: OR
39876: IFFALSE 39880
// exit ;
39878: GO 39905
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
39880: LD_ADDR_EXP 75
39884: PUSH
39885: LD_EXP 75
39889: PPUSH
39890: LD_VAR 0 1
39894: PPUSH
39895: LD_VAR 0 2
39899: PPUSH
39900: CALL_OW 1
39904: ST_TO_ADDR
// end ;
39905: LD_VAR 0 3
39909: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
39910: LD_INT 0
39912: PPUSH
39913: PPUSH
// if not mc_bases or not base then
39914: LD_EXP 50
39918: NOT
39919: PUSH
39920: LD_VAR 0 1
39924: NOT
39925: OR
39926: IFFALSE 39930
// exit ;
39928: GO 39994
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
39930: LD_ADDR_VAR 0 3
39934: PUSH
39935: LD_INT 1
39937: PUSH
39938: LD_INT 2
39940: PUSH
39941: LD_INT 3
39943: PUSH
39944: LD_INT 4
39946: PUSH
39947: LD_INT 11
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: LIST
39954: LIST
39955: LIST
39956: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
39957: LD_ADDR_EXP 77
39961: PUSH
39962: LD_EXP 77
39966: PPUSH
39967: LD_VAR 0 1
39971: PPUSH
39972: LD_EXP 77
39976: PUSH
39977: LD_VAR 0 1
39981: ARRAY
39982: PUSH
39983: LD_VAR 0 3
39987: DIFF
39988: PPUSH
39989: CALL_OW 1
39993: ST_TO_ADDR
// end ; end_of_file
39994: LD_VAR 0 2
39998: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
39999: LD_INT 0
40001: PPUSH
40002: PPUSH
40003: PPUSH
// if not mc_bases or not skirmish then
40004: LD_EXP 50
40008: NOT
40009: PUSH
40010: LD_EXP 48
40014: NOT
40015: OR
40016: IFFALSE 40020
// exit ;
40018: GO 40185
// for i = 1 to mc_bases do
40020: LD_ADDR_VAR 0 4
40024: PUSH
40025: DOUBLE
40026: LD_INT 1
40028: DEC
40029: ST_TO_ADDR
40030: LD_EXP 50
40034: PUSH
40035: FOR_TO
40036: IFFALSE 40183
// begin if sci in mc_bases [ i ] then
40038: LD_VAR 0 2
40042: PUSH
40043: LD_EXP 50
40047: PUSH
40048: LD_VAR 0 4
40052: ARRAY
40053: IN
40054: IFFALSE 40181
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
40056: LD_ADDR_EXP 79
40060: PUSH
40061: LD_EXP 79
40065: PPUSH
40066: LD_VAR 0 4
40070: PUSH
40071: LD_EXP 79
40075: PUSH
40076: LD_VAR 0 4
40080: ARRAY
40081: PUSH
40082: LD_INT 1
40084: PLUS
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PPUSH
40090: LD_VAR 0 1
40094: PPUSH
40095: CALL 51065 0 3
40099: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
40100: LD_ADDR_VAR 0 5
40104: PUSH
40105: LD_EXP 50
40109: PUSH
40110: LD_VAR 0 4
40114: ARRAY
40115: PPUSH
40116: LD_INT 2
40118: PUSH
40119: LD_INT 30
40121: PUSH
40122: LD_INT 0
40124: PUSH
40125: EMPTY
40126: LIST
40127: LIST
40128: PUSH
40129: LD_INT 30
40131: PUSH
40132: LD_INT 1
40134: PUSH
40135: EMPTY
40136: LIST
40137: LIST
40138: PUSH
40139: EMPTY
40140: LIST
40141: LIST
40142: LIST
40143: PPUSH
40144: CALL_OW 72
40148: PPUSH
40149: LD_VAR 0 1
40153: PPUSH
40154: CALL_OW 74
40158: ST_TO_ADDR
// if tmp then
40159: LD_VAR 0 5
40163: IFFALSE 40179
// ComStandNearbyBuilding ( ape , tmp ) ;
40165: LD_VAR 0 1
40169: PPUSH
40170: LD_VAR 0 5
40174: PPUSH
40175: CALL 45742 0 2
// break ;
40179: GO 40183
// end ; end ;
40181: GO 40035
40183: POP
40184: POP
// end ;
40185: LD_VAR 0 3
40189: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
40190: LD_INT 0
40192: PPUSH
40193: PPUSH
40194: PPUSH
// if not mc_bases or not skirmish then
40195: LD_EXP 50
40199: NOT
40200: PUSH
40201: LD_EXP 48
40205: NOT
40206: OR
40207: IFFALSE 40211
// exit ;
40209: GO 40300
// for i = 1 to mc_bases do
40211: LD_ADDR_VAR 0 4
40215: PUSH
40216: DOUBLE
40217: LD_INT 1
40219: DEC
40220: ST_TO_ADDR
40221: LD_EXP 50
40225: PUSH
40226: FOR_TO
40227: IFFALSE 40298
// begin if building in mc_busy_turret_list [ i ] then
40229: LD_VAR 0 1
40233: PUSH
40234: LD_EXP 60
40238: PUSH
40239: LD_VAR 0 4
40243: ARRAY
40244: IN
40245: IFFALSE 40296
// begin tmp := mc_busy_turret_list [ i ] diff building ;
40247: LD_ADDR_VAR 0 5
40251: PUSH
40252: LD_EXP 60
40256: PUSH
40257: LD_VAR 0 4
40261: ARRAY
40262: PUSH
40263: LD_VAR 0 1
40267: DIFF
40268: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
40269: LD_ADDR_EXP 60
40273: PUSH
40274: LD_EXP 60
40278: PPUSH
40279: LD_VAR 0 4
40283: PPUSH
40284: LD_VAR 0 5
40288: PPUSH
40289: CALL_OW 1
40293: ST_TO_ADDR
// break ;
40294: GO 40298
// end ; end ;
40296: GO 40226
40298: POP
40299: POP
// end ;
40300: LD_VAR 0 3
40304: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
40305: LD_INT 0
40307: PPUSH
40308: PPUSH
40309: PPUSH
// if not mc_bases or not skirmish then
40310: LD_EXP 50
40314: NOT
40315: PUSH
40316: LD_EXP 48
40320: NOT
40321: OR
40322: IFFALSE 40326
// exit ;
40324: GO 40525
// for i = 1 to mc_bases do
40326: LD_ADDR_VAR 0 5
40330: PUSH
40331: DOUBLE
40332: LD_INT 1
40334: DEC
40335: ST_TO_ADDR
40336: LD_EXP 50
40340: PUSH
40341: FOR_TO
40342: IFFALSE 40523
// if building in mc_bases [ i ] then
40344: LD_VAR 0 1
40348: PUSH
40349: LD_EXP 50
40353: PUSH
40354: LD_VAR 0 5
40358: ARRAY
40359: IN
40360: IFFALSE 40521
// begin tmp := mc_bases [ i ] diff building ;
40362: LD_ADDR_VAR 0 6
40366: PUSH
40367: LD_EXP 50
40371: PUSH
40372: LD_VAR 0 5
40376: ARRAY
40377: PUSH
40378: LD_VAR 0 1
40382: DIFF
40383: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
40384: LD_ADDR_EXP 50
40388: PUSH
40389: LD_EXP 50
40393: PPUSH
40394: LD_VAR 0 5
40398: PPUSH
40399: LD_VAR 0 6
40403: PPUSH
40404: CALL_OW 1
40408: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
40409: LD_VAR 0 1
40413: PUSH
40414: LD_EXP 58
40418: PUSH
40419: LD_VAR 0 5
40423: ARRAY
40424: IN
40425: IFFALSE 40464
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
40427: LD_ADDR_EXP 58
40431: PUSH
40432: LD_EXP 58
40436: PPUSH
40437: LD_VAR 0 5
40441: PPUSH
40442: LD_EXP 58
40446: PUSH
40447: LD_VAR 0 5
40451: ARRAY
40452: PUSH
40453: LD_VAR 0 1
40457: DIFF
40458: PPUSH
40459: CALL_OW 1
40463: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
40464: LD_VAR 0 1
40468: PUSH
40469: LD_EXP 59
40473: PUSH
40474: LD_VAR 0 5
40478: ARRAY
40479: IN
40480: IFFALSE 40519
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
40482: LD_ADDR_EXP 59
40486: PUSH
40487: LD_EXP 59
40491: PPUSH
40492: LD_VAR 0 5
40496: PPUSH
40497: LD_EXP 59
40501: PUSH
40502: LD_VAR 0 5
40506: ARRAY
40507: PUSH
40508: LD_VAR 0 1
40512: DIFF
40513: PPUSH
40514: CALL_OW 1
40518: ST_TO_ADDR
// break ;
40519: GO 40523
// end ;
40521: GO 40341
40523: POP
40524: POP
// end ;
40525: LD_VAR 0 4
40529: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
40530: LD_INT 0
40532: PPUSH
40533: PPUSH
40534: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
40535: LD_EXP 50
40539: NOT
40540: PUSH
40541: LD_EXP 48
40545: NOT
40546: OR
40547: PUSH
40548: LD_VAR 0 3
40552: PUSH
40553: LD_EXP 76
40557: IN
40558: NOT
40559: OR
40560: IFFALSE 40564
// exit ;
40562: GO 40687
// for i = 1 to mc_vehicles do
40564: LD_ADDR_VAR 0 6
40568: PUSH
40569: DOUBLE
40570: LD_INT 1
40572: DEC
40573: ST_TO_ADDR
40574: LD_EXP 69
40578: PUSH
40579: FOR_TO
40580: IFFALSE 40685
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
40582: LD_VAR 0 2
40586: PUSH
40587: LD_EXP 69
40591: PUSH
40592: LD_VAR 0 6
40596: ARRAY
40597: IN
40598: PUSH
40599: LD_VAR 0 1
40603: PUSH
40604: LD_EXP 69
40608: PUSH
40609: LD_VAR 0 6
40613: ARRAY
40614: IN
40615: OR
40616: IFFALSE 40683
// begin tmp := mc_vehicles [ i ] diff old ;
40618: LD_ADDR_VAR 0 7
40622: PUSH
40623: LD_EXP 69
40627: PUSH
40628: LD_VAR 0 6
40632: ARRAY
40633: PUSH
40634: LD_VAR 0 2
40638: DIFF
40639: ST_TO_ADDR
// tmp := tmp diff new ;
40640: LD_ADDR_VAR 0 7
40644: PUSH
40645: LD_VAR 0 7
40649: PUSH
40650: LD_VAR 0 1
40654: DIFF
40655: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
40656: LD_ADDR_EXP 69
40660: PUSH
40661: LD_EXP 69
40665: PPUSH
40666: LD_VAR 0 6
40670: PPUSH
40671: LD_VAR 0 7
40675: PPUSH
40676: CALL_OW 1
40680: ST_TO_ADDR
// break ;
40681: GO 40685
// end ;
40683: GO 40579
40685: POP
40686: POP
// end ;
40687: LD_VAR 0 5
40691: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
40692: LD_INT 0
40694: PPUSH
40695: PPUSH
40696: PPUSH
40697: PPUSH
// if not mc_bases or not skirmish then
40698: LD_EXP 50
40702: NOT
40703: PUSH
40704: LD_EXP 48
40708: NOT
40709: OR
40710: IFFALSE 40714
// exit ;
40712: GO 41097
// side := GetSide ( vehicle ) ;
40714: LD_ADDR_VAR 0 5
40718: PUSH
40719: LD_VAR 0 1
40723: PPUSH
40724: CALL_OW 255
40728: ST_TO_ADDR
// for i = 1 to mc_bases do
40729: LD_ADDR_VAR 0 4
40733: PUSH
40734: DOUBLE
40735: LD_INT 1
40737: DEC
40738: ST_TO_ADDR
40739: LD_EXP 50
40743: PUSH
40744: FOR_TO
40745: IFFALSE 41095
// begin if factory in mc_bases [ i ] then
40747: LD_VAR 0 2
40751: PUSH
40752: LD_EXP 50
40756: PUSH
40757: LD_VAR 0 4
40761: ARRAY
40762: IN
40763: IFFALSE 41093
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
40765: LD_EXP 72
40769: PUSH
40770: LD_VAR 0 4
40774: ARRAY
40775: PUSH
40776: LD_EXP 61
40780: PUSH
40781: LD_VAR 0 4
40785: ARRAY
40786: LESS
40787: PUSH
40788: LD_VAR 0 1
40792: PPUSH
40793: CALL_OW 264
40797: PUSH
40798: LD_INT 31
40800: PUSH
40801: LD_INT 32
40803: PUSH
40804: LD_INT 51
40806: PUSH
40807: LD_EXP 94
40811: PUSH
40812: LD_INT 12
40814: PUSH
40815: LD_INT 30
40817: PUSH
40818: LD_EXP 93
40822: PUSH
40823: LD_INT 11
40825: PUSH
40826: LD_INT 53
40828: PUSH
40829: LD_INT 14
40831: PUSH
40832: LD_EXP 97
40836: PUSH
40837: LD_INT 29
40839: PUSH
40840: LD_EXP 95
40844: PUSH
40845: LD_INT 13
40847: PUSH
40848: LD_INT 52
40850: PUSH
40851: LD_INT 48
40853: PUSH
40854: LD_INT 8
40856: PUSH
40857: EMPTY
40858: LIST
40859: LIST
40860: LIST
40861: LIST
40862: LIST
40863: LIST
40864: LIST
40865: LIST
40866: LIST
40867: LIST
40868: LIST
40869: LIST
40870: LIST
40871: LIST
40872: LIST
40873: LIST
40874: LIST
40875: IN
40876: NOT
40877: AND
40878: IFFALSE 40919
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
40880: LD_ADDR_EXP 72
40884: PUSH
40885: LD_EXP 72
40889: PPUSH
40890: LD_VAR 0 4
40894: PPUSH
40895: LD_EXP 72
40899: PUSH
40900: LD_VAR 0 4
40904: ARRAY
40905: PUSH
40906: LD_VAR 0 1
40910: ADD
40911: PPUSH
40912: CALL_OW 1
40916: ST_TO_ADDR
40917: GO 40963
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
40919: LD_ADDR_EXP 69
40923: PUSH
40924: LD_EXP 69
40928: PPUSH
40929: LD_VAR 0 4
40933: PUSH
40934: LD_EXP 69
40938: PUSH
40939: LD_VAR 0 4
40943: ARRAY
40944: PUSH
40945: LD_INT 1
40947: PLUS
40948: PUSH
40949: EMPTY
40950: LIST
40951: LIST
40952: PPUSH
40953: LD_VAR 0 1
40957: PPUSH
40958: CALL 51065 0 3
40962: ST_TO_ADDR
// if not mc_scan [ i ] then
40963: LD_EXP 73
40967: PUSH
40968: LD_VAR 0 4
40972: ARRAY
40973: NOT
40974: IFFALSE 41093
// begin if GetControl ( vehicle ) = control_remote then
40976: LD_VAR 0 1
40980: PPUSH
40981: CALL_OW 263
40985: PUSH
40986: LD_INT 2
40988: EQUAL
40989: IFFALSE 41009
// repeat wait ( 0 0$1 ) ;
40991: LD_INT 35
40993: PPUSH
40994: CALL_OW 67
// until IsControledBy ( vehicle ) ;
40998: LD_VAR 0 1
41002: PPUSH
41003: CALL_OW 312
41007: IFFALSE 40991
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
41009: LD_VAR 0 1
41013: PPUSH
41014: LD_EXP 74
41018: PUSH
41019: LD_VAR 0 4
41023: ARRAY
41024: PPUSH
41025: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
41029: LD_VAR 0 1
41033: PPUSH
41034: CALL_OW 263
41038: PUSH
41039: LD_INT 1
41041: NONEQUAL
41042: IFFALSE 41046
// break ;
41044: GO 41095
// repeat wait ( 0 0$1 ) ;
41046: LD_INT 35
41048: PPUSH
41049: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
41053: LD_VAR 0 1
41057: PPUSH
41058: LD_EXP 74
41062: PUSH
41063: LD_VAR 0 4
41067: ARRAY
41068: PPUSH
41069: CALL_OW 308
41073: IFFALSE 41046
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
41075: LD_VAR 0 1
41079: PPUSH
41080: CALL_OW 311
41084: PPUSH
41085: CALL_OW 121
// exit ;
41089: POP
41090: POP
41091: GO 41097
// end ; end ; end ;
41093: GO 40744
41095: POP
41096: POP
// end ;
41097: LD_VAR 0 3
41101: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
41102: LD_INT 0
41104: PPUSH
41105: PPUSH
41106: PPUSH
41107: PPUSH
// if not mc_bases or not skirmish then
41108: LD_EXP 50
41112: NOT
41113: PUSH
41114: LD_EXP 48
41118: NOT
41119: OR
41120: IFFALSE 41124
// exit ;
41122: GO 41477
// repeat wait ( 0 0$1 ) ;
41124: LD_INT 35
41126: PPUSH
41127: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
41131: LD_VAR 0 2
41135: PPUSH
41136: LD_VAR 0 3
41140: PPUSH
41141: CALL_OW 284
41145: IFFALSE 41124
// if GetResourceTypeXY ( x , y ) = mat_artefact then
41147: LD_VAR 0 2
41151: PPUSH
41152: LD_VAR 0 3
41156: PPUSH
41157: CALL_OW 283
41161: PUSH
41162: LD_INT 4
41164: EQUAL
41165: IFFALSE 41169
// exit ;
41167: GO 41477
// for i = 1 to mc_bases do
41169: LD_ADDR_VAR 0 7
41173: PUSH
41174: DOUBLE
41175: LD_INT 1
41177: DEC
41178: ST_TO_ADDR
41179: LD_EXP 50
41183: PUSH
41184: FOR_TO
41185: IFFALSE 41475
// begin if mc_crates_area [ i ] then
41187: LD_EXP 68
41191: PUSH
41192: LD_VAR 0 7
41196: ARRAY
41197: IFFALSE 41308
// for j in mc_crates_area [ i ] do
41199: LD_ADDR_VAR 0 8
41203: PUSH
41204: LD_EXP 68
41208: PUSH
41209: LD_VAR 0 7
41213: ARRAY
41214: PUSH
41215: FOR_IN
41216: IFFALSE 41306
// if InArea ( x , y , j ) then
41218: LD_VAR 0 2
41222: PPUSH
41223: LD_VAR 0 3
41227: PPUSH
41228: LD_VAR 0 8
41232: PPUSH
41233: CALL_OW 309
41237: IFFALSE 41304
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
41239: LD_ADDR_EXP 66
41243: PUSH
41244: LD_EXP 66
41248: PPUSH
41249: LD_VAR 0 7
41253: PUSH
41254: LD_EXP 66
41258: PUSH
41259: LD_VAR 0 7
41263: ARRAY
41264: PUSH
41265: LD_INT 1
41267: PLUS
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: PPUSH
41273: LD_VAR 0 4
41277: PUSH
41278: LD_VAR 0 2
41282: PUSH
41283: LD_VAR 0 3
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: LIST
41292: PPUSH
41293: CALL 51065 0 3
41297: ST_TO_ADDR
// exit ;
41298: POP
41299: POP
41300: POP
41301: POP
41302: GO 41477
// end ;
41304: GO 41215
41306: POP
41307: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41308: LD_ADDR_VAR 0 9
41312: PUSH
41313: LD_EXP 50
41317: PUSH
41318: LD_VAR 0 7
41322: ARRAY
41323: PPUSH
41324: LD_INT 2
41326: PUSH
41327: LD_INT 30
41329: PUSH
41330: LD_INT 0
41332: PUSH
41333: EMPTY
41334: LIST
41335: LIST
41336: PUSH
41337: LD_INT 30
41339: PUSH
41340: LD_INT 1
41342: PUSH
41343: EMPTY
41344: LIST
41345: LIST
41346: PUSH
41347: EMPTY
41348: LIST
41349: LIST
41350: LIST
41351: PPUSH
41352: CALL_OW 72
41356: ST_TO_ADDR
// if not depot then
41357: LD_VAR 0 9
41361: NOT
41362: IFFALSE 41366
// continue ;
41364: GO 41184
// for j in depot do
41366: LD_ADDR_VAR 0 8
41370: PUSH
41371: LD_VAR 0 9
41375: PUSH
41376: FOR_IN
41377: IFFALSE 41471
// if GetDistUnitXY ( j , x , y ) < 30 then
41379: LD_VAR 0 8
41383: PPUSH
41384: LD_VAR 0 2
41388: PPUSH
41389: LD_VAR 0 3
41393: PPUSH
41394: CALL_OW 297
41398: PUSH
41399: LD_INT 30
41401: LESS
41402: IFFALSE 41469
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
41404: LD_ADDR_EXP 66
41408: PUSH
41409: LD_EXP 66
41413: PPUSH
41414: LD_VAR 0 7
41418: PUSH
41419: LD_EXP 66
41423: PUSH
41424: LD_VAR 0 7
41428: ARRAY
41429: PUSH
41430: LD_INT 1
41432: PLUS
41433: PUSH
41434: EMPTY
41435: LIST
41436: LIST
41437: PPUSH
41438: LD_VAR 0 4
41442: PUSH
41443: LD_VAR 0 2
41447: PUSH
41448: LD_VAR 0 3
41452: PUSH
41453: EMPTY
41454: LIST
41455: LIST
41456: LIST
41457: PPUSH
41458: CALL 51065 0 3
41462: ST_TO_ADDR
// exit ;
41463: POP
41464: POP
41465: POP
41466: POP
41467: GO 41477
// end ;
41469: GO 41376
41471: POP
41472: POP
// end ;
41473: GO 41184
41475: POP
41476: POP
// end ;
41477: LD_VAR 0 6
41481: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
41482: LD_INT 0
41484: PPUSH
41485: PPUSH
41486: PPUSH
41487: PPUSH
// if not mc_bases or not skirmish then
41488: LD_EXP 50
41492: NOT
41493: PUSH
41494: LD_EXP 48
41498: NOT
41499: OR
41500: IFFALSE 41504
// exit ;
41502: GO 41781
// side := GetSide ( lab ) ;
41504: LD_ADDR_VAR 0 4
41508: PUSH
41509: LD_VAR 0 2
41513: PPUSH
41514: CALL_OW 255
41518: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
41519: LD_VAR 0 4
41523: PUSH
41524: LD_EXP 76
41528: IN
41529: NOT
41530: PUSH
41531: LD_EXP 77
41535: NOT
41536: OR
41537: PUSH
41538: LD_EXP 50
41542: NOT
41543: OR
41544: IFFALSE 41548
// exit ;
41546: GO 41781
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
41548: LD_ADDR_EXP 77
41552: PUSH
41553: LD_EXP 77
41557: PPUSH
41558: LD_VAR 0 4
41562: PPUSH
41563: LD_EXP 77
41567: PUSH
41568: LD_VAR 0 4
41572: ARRAY
41573: PUSH
41574: LD_VAR 0 1
41578: DIFF
41579: PPUSH
41580: CALL_OW 1
41584: ST_TO_ADDR
// for i = 1 to mc_bases do
41585: LD_ADDR_VAR 0 5
41589: PUSH
41590: DOUBLE
41591: LD_INT 1
41593: DEC
41594: ST_TO_ADDR
41595: LD_EXP 50
41599: PUSH
41600: FOR_TO
41601: IFFALSE 41779
// begin if lab in mc_bases [ i ] then
41603: LD_VAR 0 2
41607: PUSH
41608: LD_EXP 50
41612: PUSH
41613: LD_VAR 0 5
41617: ARRAY
41618: IN
41619: IFFALSE 41777
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
41621: LD_VAR 0 1
41625: PUSH
41626: LD_INT 11
41628: PUSH
41629: LD_INT 4
41631: PUSH
41632: LD_INT 3
41634: PUSH
41635: LD_INT 2
41637: PUSH
41638: EMPTY
41639: LIST
41640: LIST
41641: LIST
41642: LIST
41643: IN
41644: PUSH
41645: LD_EXP 80
41649: PUSH
41650: LD_VAR 0 5
41654: ARRAY
41655: AND
41656: IFFALSE 41777
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
41658: LD_ADDR_VAR 0 6
41662: PUSH
41663: LD_EXP 80
41667: PUSH
41668: LD_VAR 0 5
41672: ARRAY
41673: PUSH
41674: LD_INT 1
41676: ARRAY
41677: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
41678: LD_ADDR_EXP 80
41682: PUSH
41683: LD_EXP 80
41687: PPUSH
41688: LD_VAR 0 5
41692: PPUSH
41693: EMPTY
41694: PPUSH
41695: CALL_OW 1
41699: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
41700: LD_VAR 0 6
41704: PPUSH
41705: LD_INT 0
41707: PPUSH
41708: CALL_OW 109
// ComExitBuilding ( tmp ) ;
41712: LD_VAR 0 6
41716: PPUSH
41717: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
41721: LD_ADDR_EXP 79
41725: PUSH
41726: LD_EXP 79
41730: PPUSH
41731: LD_VAR 0 5
41735: PPUSH
41736: LD_EXP 79
41740: PUSH
41741: LD_VAR 0 5
41745: ARRAY
41746: PPUSH
41747: LD_INT 1
41749: PPUSH
41750: LD_VAR 0 6
41754: PPUSH
41755: CALL_OW 2
41759: PPUSH
41760: CALL_OW 1
41764: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
41765: LD_VAR 0 5
41769: PPUSH
41770: LD_INT 112
41772: PPUSH
41773: CALL 19708 0 2
// end ; end ; end ;
41777: GO 41600
41779: POP
41780: POP
// end ;
41781: LD_VAR 0 3
41785: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
41786: LD_INT 0
41788: PPUSH
41789: PPUSH
41790: PPUSH
41791: PPUSH
41792: PPUSH
41793: PPUSH
41794: PPUSH
41795: PPUSH
// if not mc_bases or not skirmish then
41796: LD_EXP 50
41800: NOT
41801: PUSH
41802: LD_EXP 48
41806: NOT
41807: OR
41808: IFFALSE 41812
// exit ;
41810: GO 42755
// for i = 1 to mc_bases do
41812: LD_ADDR_VAR 0 3
41816: PUSH
41817: DOUBLE
41818: LD_INT 1
41820: DEC
41821: ST_TO_ADDR
41822: LD_EXP 50
41826: PUSH
41827: FOR_TO
41828: IFFALSE 42753
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
41830: LD_VAR 0 1
41834: PUSH
41835: LD_EXP 50
41839: PUSH
41840: LD_VAR 0 3
41844: ARRAY
41845: IN
41846: PUSH
41847: LD_VAR 0 1
41851: PUSH
41852: LD_EXP 57
41856: PUSH
41857: LD_VAR 0 3
41861: ARRAY
41862: IN
41863: OR
41864: PUSH
41865: LD_VAR 0 1
41869: PUSH
41870: LD_EXP 69
41874: PUSH
41875: LD_VAR 0 3
41879: ARRAY
41880: IN
41881: OR
41882: PUSH
41883: LD_VAR 0 1
41887: PUSH
41888: LD_EXP 79
41892: PUSH
41893: LD_VAR 0 3
41897: ARRAY
41898: IN
41899: OR
41900: PUSH
41901: LD_VAR 0 1
41905: PUSH
41906: LD_EXP 80
41910: PUSH
41911: LD_VAR 0 3
41915: ARRAY
41916: IN
41917: OR
41918: IFFALSE 42751
// begin if un in mc_ape [ i ] then
41920: LD_VAR 0 1
41924: PUSH
41925: LD_EXP 79
41929: PUSH
41930: LD_VAR 0 3
41934: ARRAY
41935: IN
41936: IFFALSE 41975
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
41938: LD_ADDR_EXP 79
41942: PUSH
41943: LD_EXP 79
41947: PPUSH
41948: LD_VAR 0 3
41952: PPUSH
41953: LD_EXP 79
41957: PUSH
41958: LD_VAR 0 3
41962: ARRAY
41963: PUSH
41964: LD_VAR 0 1
41968: DIFF
41969: PPUSH
41970: CALL_OW 1
41974: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
41975: LD_VAR 0 1
41979: PUSH
41980: LD_EXP 80
41984: PUSH
41985: LD_VAR 0 3
41989: ARRAY
41990: IN
41991: IFFALSE 42015
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
41993: LD_ADDR_EXP 80
41997: PUSH
41998: LD_EXP 80
42002: PPUSH
42003: LD_VAR 0 3
42007: PPUSH
42008: EMPTY
42009: PPUSH
42010: CALL_OW 1
42014: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and GetTag ( un ) = 20 then
42015: LD_VAR 0 1
42019: PPUSH
42020: CALL_OW 247
42024: PUSH
42025: LD_INT 2
42027: EQUAL
42028: PUSH
42029: LD_VAR 0 1
42033: PPUSH
42034: CALL_OW 110
42038: PUSH
42039: LD_INT 20
42041: EQUAL
42042: AND
42043: IFFALSE 42146
// begin fac := MC_GetBuilding ( i , b_factory ) ;
42045: LD_ADDR_VAR 0 8
42049: PUSH
42050: LD_VAR 0 3
42054: PPUSH
42055: LD_INT 3
42057: PPUSH
42058: CALL 39016 0 2
42062: ST_TO_ADDR
// if fac then
42063: LD_VAR 0 8
42067: IFFALSE 42146
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
42069: LD_ADDR_VAR 0 9
42073: PUSH
42074: LD_VAR 0 8
42078: PPUSH
42079: LD_VAR 0 1
42083: PPUSH
42084: CALL_OW 265
42088: PPUSH
42089: LD_VAR 0 1
42093: PPUSH
42094: CALL_OW 262
42098: PPUSH
42099: LD_VAR 0 1
42103: PPUSH
42104: CALL_OW 263
42108: PPUSH
42109: LD_VAR 0 1
42113: PPUSH
42114: CALL_OW 264
42118: PPUSH
42119: CALL 48665 0 5
42123: ST_TO_ADDR
// if components then
42124: LD_VAR 0 9
42128: IFFALSE 42144
// MC_InsertProduceList ( i , components ) ;
42130: LD_VAR 0 3
42134: PPUSH
42135: LD_VAR 0 9
42139: PPUSH
42140: CALL 38586 0 2
// break ;
42144: GO 42753
// end ; end ; if GetType ( un ) = unit_building then
42146: LD_VAR 0 1
42150: PPUSH
42151: CALL_OW 247
42155: PUSH
42156: LD_INT 3
42158: EQUAL
42159: IFFALSE 42474
// begin btype := GetBType ( un ) ;
42161: LD_ADDR_VAR 0 5
42165: PUSH
42166: LD_VAR 0 1
42170: PPUSH
42171: CALL_OW 266
42175: ST_TO_ADDR
// if btype = b_warehouse then
42176: LD_VAR 0 5
42180: PUSH
42181: LD_INT 1
42183: EQUAL
42184: IFFALSE 42202
// begin btype := b_depot ;
42186: LD_ADDR_VAR 0 5
42190: PUSH
42191: LD_INT 0
42193: ST_TO_ADDR
// pos := 1 ;
42194: LD_ADDR_VAR 0 6
42198: PUSH
42199: LD_INT 1
42201: ST_TO_ADDR
// end ; if btype = b_factory then
42202: LD_VAR 0 5
42206: PUSH
42207: LD_INT 3
42209: EQUAL
42210: IFFALSE 42228
// begin btype := b_workshop ;
42212: LD_ADDR_VAR 0 5
42216: PUSH
42217: LD_INT 2
42219: ST_TO_ADDR
// pos := 1 ;
42220: LD_ADDR_VAR 0 6
42224: PUSH
42225: LD_INT 1
42227: ST_TO_ADDR
// end ; if btype = b_barracks then
42228: LD_VAR 0 5
42232: PUSH
42233: LD_INT 5
42235: EQUAL
42236: IFFALSE 42246
// btype := b_armoury ;
42238: LD_ADDR_VAR 0 5
42242: PUSH
42243: LD_INT 4
42245: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
42246: LD_VAR 0 5
42250: PUSH
42251: LD_INT 7
42253: PUSH
42254: LD_INT 8
42256: PUSH
42257: EMPTY
42258: LIST
42259: LIST
42260: IN
42261: IFFALSE 42271
// btype := b_lab ;
42263: LD_ADDR_VAR 0 5
42267: PUSH
42268: LD_INT 6
42270: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
42271: LD_ADDR_EXP 55
42275: PUSH
42276: LD_EXP 55
42280: PPUSH
42281: LD_VAR 0 3
42285: PUSH
42286: LD_EXP 55
42290: PUSH
42291: LD_VAR 0 3
42295: ARRAY
42296: PUSH
42297: LD_INT 1
42299: PLUS
42300: PUSH
42301: EMPTY
42302: LIST
42303: LIST
42304: PPUSH
42305: LD_VAR 0 5
42309: PUSH
42310: LD_VAR 0 1
42314: PPUSH
42315: CALL_OW 250
42319: PUSH
42320: LD_VAR 0 1
42324: PPUSH
42325: CALL_OW 251
42329: PUSH
42330: LD_VAR 0 1
42334: PPUSH
42335: CALL_OW 254
42339: PUSH
42340: EMPTY
42341: LIST
42342: LIST
42343: LIST
42344: LIST
42345: PPUSH
42346: CALL 51065 0 3
42350: ST_TO_ADDR
// if pos = 1 then
42351: LD_VAR 0 6
42355: PUSH
42356: LD_INT 1
42358: EQUAL
42359: IFFALSE 42474
// begin tmp := mc_build_list [ i ] ;
42361: LD_ADDR_VAR 0 7
42365: PUSH
42366: LD_EXP 55
42370: PUSH
42371: LD_VAR 0 3
42375: ARRAY
42376: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42377: LD_VAR 0 7
42381: PPUSH
42382: LD_INT 2
42384: PUSH
42385: LD_INT 30
42387: PUSH
42388: LD_INT 0
42390: PUSH
42391: EMPTY
42392: LIST
42393: LIST
42394: PUSH
42395: LD_INT 30
42397: PUSH
42398: LD_INT 1
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: LIST
42409: PPUSH
42410: CALL_OW 72
42414: IFFALSE 42424
// pos := 2 ;
42416: LD_ADDR_VAR 0 6
42420: PUSH
42421: LD_INT 2
42423: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
42424: LD_ADDR_VAR 0 7
42428: PUSH
42429: LD_VAR 0 7
42433: PPUSH
42434: LD_VAR 0 6
42438: PPUSH
42439: LD_VAR 0 7
42443: PPUSH
42444: CALL 51391 0 3
42448: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
42449: LD_ADDR_EXP 55
42453: PUSH
42454: LD_EXP 55
42458: PPUSH
42459: LD_VAR 0 3
42463: PPUSH
42464: LD_VAR 0 7
42468: PPUSH
42469: CALL_OW 1
42473: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
42474: LD_VAR 0 1
42478: PUSH
42479: LD_EXP 50
42483: PUSH
42484: LD_VAR 0 3
42488: ARRAY
42489: IN
42490: IFFALSE 42529
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
42492: LD_ADDR_EXP 50
42496: PUSH
42497: LD_EXP 50
42501: PPUSH
42502: LD_VAR 0 3
42506: PPUSH
42507: LD_EXP 50
42511: PUSH
42512: LD_VAR 0 3
42516: ARRAY
42517: PUSH
42518: LD_VAR 0 1
42522: DIFF
42523: PPUSH
42524: CALL_OW 1
42528: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
42529: LD_VAR 0 1
42533: PUSH
42534: LD_EXP 57
42538: PUSH
42539: LD_VAR 0 3
42543: ARRAY
42544: IN
42545: IFFALSE 42584
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
42547: LD_ADDR_EXP 57
42551: PUSH
42552: LD_EXP 57
42556: PPUSH
42557: LD_VAR 0 3
42561: PPUSH
42562: LD_EXP 57
42566: PUSH
42567: LD_VAR 0 3
42571: ARRAY
42572: PUSH
42573: LD_VAR 0 1
42577: DIFF
42578: PPUSH
42579: CALL_OW 1
42583: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
42584: LD_VAR 0 1
42588: PUSH
42589: LD_EXP 69
42593: PUSH
42594: LD_VAR 0 3
42598: ARRAY
42599: IN
42600: IFFALSE 42639
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
42602: LD_ADDR_EXP 69
42606: PUSH
42607: LD_EXP 69
42611: PPUSH
42612: LD_VAR 0 3
42616: PPUSH
42617: LD_EXP 69
42621: PUSH
42622: LD_VAR 0 3
42626: ARRAY
42627: PUSH
42628: LD_VAR 0 1
42632: DIFF
42633: PPUSH
42634: CALL_OW 1
42638: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
42639: LD_VAR 0 1
42643: PUSH
42644: LD_EXP 59
42648: PUSH
42649: LD_VAR 0 3
42653: ARRAY
42654: IN
42655: IFFALSE 42694
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
42657: LD_ADDR_EXP 59
42661: PUSH
42662: LD_EXP 59
42666: PPUSH
42667: LD_VAR 0 3
42671: PPUSH
42672: LD_EXP 59
42676: PUSH
42677: LD_VAR 0 3
42681: ARRAY
42682: PUSH
42683: LD_VAR 0 1
42687: DIFF
42688: PPUSH
42689: CALL_OW 1
42693: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
42694: LD_VAR 0 1
42698: PUSH
42699: LD_EXP 58
42703: PUSH
42704: LD_VAR 0 3
42708: ARRAY
42709: IN
42710: IFFALSE 42749
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
42712: LD_ADDR_EXP 58
42716: PUSH
42717: LD_EXP 58
42721: PPUSH
42722: LD_VAR 0 3
42726: PPUSH
42727: LD_EXP 58
42731: PUSH
42732: LD_VAR 0 3
42736: ARRAY
42737: PUSH
42738: LD_VAR 0 1
42742: DIFF
42743: PPUSH
42744: CALL_OW 1
42748: ST_TO_ADDR
// end ; break ;
42749: GO 42753
// end ;
42751: GO 41827
42753: POP
42754: POP
// end ;
42755: LD_VAR 0 2
42759: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
42760: LD_INT 0
42762: PPUSH
42763: PPUSH
42764: PPUSH
// if not mc_bases or not skirmish then
42765: LD_EXP 50
42769: NOT
42770: PUSH
42771: LD_EXP 48
42775: NOT
42776: OR
42777: IFFALSE 42781
// exit ;
42779: GO 42996
// for i = 1 to mc_bases do
42781: LD_ADDR_VAR 0 3
42785: PUSH
42786: DOUBLE
42787: LD_INT 1
42789: DEC
42790: ST_TO_ADDR
42791: LD_EXP 50
42795: PUSH
42796: FOR_TO
42797: IFFALSE 42994
// begin if building in mc_construct_list [ i ] then
42799: LD_VAR 0 1
42803: PUSH
42804: LD_EXP 57
42808: PUSH
42809: LD_VAR 0 3
42813: ARRAY
42814: IN
42815: IFFALSE 42992
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
42817: LD_ADDR_EXP 57
42821: PUSH
42822: LD_EXP 57
42826: PPUSH
42827: LD_VAR 0 3
42831: PPUSH
42832: LD_EXP 57
42836: PUSH
42837: LD_VAR 0 3
42841: ARRAY
42842: PUSH
42843: LD_VAR 0 1
42847: DIFF
42848: PPUSH
42849: CALL_OW 1
42853: ST_TO_ADDR
// if building in mc_lab [ i ] then
42854: LD_VAR 0 1
42858: PUSH
42859: LD_EXP 83
42863: PUSH
42864: LD_VAR 0 3
42868: ARRAY
42869: IN
42870: IFFALSE 42925
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
42872: LD_ADDR_EXP 84
42876: PUSH
42877: LD_EXP 84
42881: PPUSH
42882: LD_VAR 0 3
42886: PPUSH
42887: LD_EXP 84
42891: PUSH
42892: LD_VAR 0 3
42896: ARRAY
42897: PPUSH
42898: LD_INT 1
42900: PPUSH
42901: LD_EXP 84
42905: PUSH
42906: LD_VAR 0 3
42910: ARRAY
42911: PPUSH
42912: LD_INT 0
42914: PPUSH
42915: CALL 50483 0 4
42919: PPUSH
42920: CALL_OW 1
42924: ST_TO_ADDR
// if not building in mc_bases [ i ] then
42925: LD_VAR 0 1
42929: PUSH
42930: LD_EXP 50
42934: PUSH
42935: LD_VAR 0 3
42939: ARRAY
42940: IN
42941: NOT
42942: IFFALSE 42988
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
42944: LD_ADDR_EXP 50
42948: PUSH
42949: LD_EXP 50
42953: PPUSH
42954: LD_VAR 0 3
42958: PUSH
42959: LD_EXP 50
42963: PUSH
42964: LD_VAR 0 3
42968: ARRAY
42969: PUSH
42970: LD_INT 1
42972: PLUS
42973: PUSH
42974: EMPTY
42975: LIST
42976: LIST
42977: PPUSH
42978: LD_VAR 0 1
42982: PPUSH
42983: CALL 51065 0 3
42987: ST_TO_ADDR
// exit ;
42988: POP
42989: POP
42990: GO 42996
// end ; end ;
42992: GO 42796
42994: POP
42995: POP
// end ;
42996: LD_VAR 0 2
43000: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
43001: LD_INT 0
43003: PPUSH
43004: PPUSH
43005: PPUSH
43006: PPUSH
43007: PPUSH
43008: PPUSH
43009: PPUSH
// if not mc_bases or not skirmish then
43010: LD_EXP 50
43014: NOT
43015: PUSH
43016: LD_EXP 48
43020: NOT
43021: OR
43022: IFFALSE 43026
// exit ;
43024: GO 43687
// for i = 1 to mc_bases do
43026: LD_ADDR_VAR 0 3
43030: PUSH
43031: DOUBLE
43032: LD_INT 1
43034: DEC
43035: ST_TO_ADDR
43036: LD_EXP 50
43040: PUSH
43041: FOR_TO
43042: IFFALSE 43685
// begin if building in mc_construct_list [ i ] then
43044: LD_VAR 0 1
43048: PUSH
43049: LD_EXP 57
43053: PUSH
43054: LD_VAR 0 3
43058: ARRAY
43059: IN
43060: IFFALSE 43683
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
43062: LD_ADDR_EXP 57
43066: PUSH
43067: LD_EXP 57
43071: PPUSH
43072: LD_VAR 0 3
43076: PPUSH
43077: LD_EXP 57
43081: PUSH
43082: LD_VAR 0 3
43086: ARRAY
43087: PUSH
43088: LD_VAR 0 1
43092: DIFF
43093: PPUSH
43094: CALL_OW 1
43098: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
43099: LD_ADDR_EXP 50
43103: PUSH
43104: LD_EXP 50
43108: PPUSH
43109: LD_VAR 0 3
43113: PUSH
43114: LD_EXP 50
43118: PUSH
43119: LD_VAR 0 3
43123: ARRAY
43124: PUSH
43125: LD_INT 1
43127: PLUS
43128: PUSH
43129: EMPTY
43130: LIST
43131: LIST
43132: PPUSH
43133: LD_VAR 0 1
43137: PPUSH
43138: CALL 51065 0 3
43142: ST_TO_ADDR
// btype := GetBType ( building ) ;
43143: LD_ADDR_VAR 0 5
43147: PUSH
43148: LD_VAR 0 1
43152: PPUSH
43153: CALL_OW 266
43157: ST_TO_ADDR
// side := GetSide ( building ) ;
43158: LD_ADDR_VAR 0 8
43162: PUSH
43163: LD_VAR 0 1
43167: PPUSH
43168: CALL_OW 255
43172: ST_TO_ADDR
// if btype = b_lab then
43173: LD_VAR 0 5
43177: PUSH
43178: LD_INT 6
43180: EQUAL
43181: IFFALSE 43231
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
43183: LD_ADDR_EXP 83
43187: PUSH
43188: LD_EXP 83
43192: PPUSH
43193: LD_VAR 0 3
43197: PUSH
43198: LD_EXP 83
43202: PUSH
43203: LD_VAR 0 3
43207: ARRAY
43208: PUSH
43209: LD_INT 1
43211: PLUS
43212: PUSH
43213: EMPTY
43214: LIST
43215: LIST
43216: PPUSH
43217: LD_VAR 0 1
43221: PPUSH
43222: CALL 51065 0 3
43226: ST_TO_ADDR
// exit ;
43227: POP
43228: POP
43229: GO 43687
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
43231: LD_VAR 0 5
43235: PUSH
43236: LD_INT 0
43238: PUSH
43239: LD_INT 2
43241: PUSH
43242: LD_INT 4
43244: PUSH
43245: EMPTY
43246: LIST
43247: LIST
43248: LIST
43249: IN
43250: IFFALSE 43374
// begin if btype = b_armoury then
43252: LD_VAR 0 5
43256: PUSH
43257: LD_INT 4
43259: EQUAL
43260: IFFALSE 43270
// btype := b_barracks ;
43262: LD_ADDR_VAR 0 5
43266: PUSH
43267: LD_INT 5
43269: ST_TO_ADDR
// if btype = b_depot then
43270: LD_VAR 0 5
43274: PUSH
43275: LD_INT 0
43277: EQUAL
43278: IFFALSE 43288
// btype := b_warehouse ;
43280: LD_ADDR_VAR 0 5
43284: PUSH
43285: LD_INT 1
43287: ST_TO_ADDR
// if btype = b_workshop then
43288: LD_VAR 0 5
43292: PUSH
43293: LD_INT 2
43295: EQUAL
43296: IFFALSE 43306
// btype := b_factory ;
43298: LD_ADDR_VAR 0 5
43302: PUSH
43303: LD_INT 3
43305: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
43306: LD_VAR 0 5
43310: PPUSH
43311: LD_VAR 0 8
43315: PPUSH
43316: CALL_OW 323
43320: PUSH
43321: LD_INT 1
43323: EQUAL
43324: IFFALSE 43370
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
43326: LD_ADDR_EXP 82
43330: PUSH
43331: LD_EXP 82
43335: PPUSH
43336: LD_VAR 0 3
43340: PUSH
43341: LD_EXP 82
43345: PUSH
43346: LD_VAR 0 3
43350: ARRAY
43351: PUSH
43352: LD_INT 1
43354: PLUS
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PPUSH
43360: LD_VAR 0 1
43364: PPUSH
43365: CALL 51065 0 3
43369: ST_TO_ADDR
// exit ;
43370: POP
43371: POP
43372: GO 43687
// end ; if btype in [ b_bunker , b_turret ] then
43374: LD_VAR 0 5
43378: PUSH
43379: LD_INT 32
43381: PUSH
43382: LD_INT 33
43384: PUSH
43385: EMPTY
43386: LIST
43387: LIST
43388: IN
43389: IFFALSE 43679
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
43391: LD_ADDR_EXP 58
43395: PUSH
43396: LD_EXP 58
43400: PPUSH
43401: LD_VAR 0 3
43405: PUSH
43406: LD_EXP 58
43410: PUSH
43411: LD_VAR 0 3
43415: ARRAY
43416: PUSH
43417: LD_INT 1
43419: PLUS
43420: PUSH
43421: EMPTY
43422: LIST
43423: LIST
43424: PPUSH
43425: LD_VAR 0 1
43429: PPUSH
43430: CALL 51065 0 3
43434: ST_TO_ADDR
// if btype = b_bunker then
43435: LD_VAR 0 5
43439: PUSH
43440: LD_INT 32
43442: EQUAL
43443: IFFALSE 43679
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
43445: LD_ADDR_EXP 59
43449: PUSH
43450: LD_EXP 59
43454: PPUSH
43455: LD_VAR 0 3
43459: PUSH
43460: LD_EXP 59
43464: PUSH
43465: LD_VAR 0 3
43469: ARRAY
43470: PUSH
43471: LD_INT 1
43473: PLUS
43474: PUSH
43475: EMPTY
43476: LIST
43477: LIST
43478: PPUSH
43479: LD_VAR 0 1
43483: PPUSH
43484: CALL 51065 0 3
43488: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
43489: LD_ADDR_VAR 0 6
43493: PUSH
43494: LD_EXP 50
43498: PUSH
43499: LD_VAR 0 3
43503: ARRAY
43504: PPUSH
43505: LD_INT 25
43507: PUSH
43508: LD_INT 1
43510: PUSH
43511: EMPTY
43512: LIST
43513: LIST
43514: PUSH
43515: LD_INT 3
43517: PUSH
43518: LD_INT 54
43520: PUSH
43521: EMPTY
43522: LIST
43523: PUSH
43524: EMPTY
43525: LIST
43526: LIST
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PPUSH
43532: CALL_OW 72
43536: ST_TO_ADDR
// if tmp then
43537: LD_VAR 0 6
43541: IFFALSE 43547
// exit ;
43543: POP
43544: POP
43545: GO 43687
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
43547: LD_ADDR_VAR 0 6
43551: PUSH
43552: LD_EXP 50
43556: PUSH
43557: LD_VAR 0 3
43561: ARRAY
43562: PPUSH
43563: LD_INT 2
43565: PUSH
43566: LD_INT 30
43568: PUSH
43569: LD_INT 4
43571: PUSH
43572: EMPTY
43573: LIST
43574: LIST
43575: PUSH
43576: LD_INT 30
43578: PUSH
43579: LD_INT 5
43581: PUSH
43582: EMPTY
43583: LIST
43584: LIST
43585: PUSH
43586: EMPTY
43587: LIST
43588: LIST
43589: LIST
43590: PPUSH
43591: CALL_OW 72
43595: ST_TO_ADDR
// if not tmp then
43596: LD_VAR 0 6
43600: NOT
43601: IFFALSE 43607
// exit ;
43603: POP
43604: POP
43605: GO 43687
// for j in tmp do
43607: LD_ADDR_VAR 0 4
43611: PUSH
43612: LD_VAR 0 6
43616: PUSH
43617: FOR_IN
43618: IFFALSE 43677
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
43620: LD_ADDR_VAR 0 7
43624: PUSH
43625: LD_VAR 0 4
43629: PPUSH
43630: CALL_OW 313
43634: PPUSH
43635: LD_INT 25
43637: PUSH
43638: LD_INT 1
43640: PUSH
43641: EMPTY
43642: LIST
43643: LIST
43644: PPUSH
43645: CALL_OW 72
43649: ST_TO_ADDR
// if units then
43650: LD_VAR 0 7
43654: IFFALSE 43675
// begin ComExitBuilding ( units [ 1 ] ) ;
43656: LD_VAR 0 7
43660: PUSH
43661: LD_INT 1
43663: ARRAY
43664: PPUSH
43665: CALL_OW 122
// exit ;
43669: POP
43670: POP
43671: POP
43672: POP
43673: GO 43687
// end ; end ;
43675: GO 43617
43677: POP
43678: POP
// end ; end ; exit ;
43679: POP
43680: POP
43681: GO 43687
// end ; end ;
43683: GO 43041
43685: POP
43686: POP
// end ;
43687: LD_VAR 0 2
43691: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
43692: LD_INT 0
43694: PPUSH
43695: PPUSH
43696: PPUSH
43697: PPUSH
43698: PPUSH
43699: PPUSH
43700: PPUSH
// if not mc_bases or not skirmish then
43701: LD_EXP 50
43705: NOT
43706: PUSH
43707: LD_EXP 48
43711: NOT
43712: OR
43713: IFFALSE 43717
// exit ;
43715: GO 43948
// btype := GetBType ( building ) ;
43717: LD_ADDR_VAR 0 6
43721: PUSH
43722: LD_VAR 0 1
43726: PPUSH
43727: CALL_OW 266
43731: ST_TO_ADDR
// x := GetX ( building ) ;
43732: LD_ADDR_VAR 0 7
43736: PUSH
43737: LD_VAR 0 1
43741: PPUSH
43742: CALL_OW 250
43746: ST_TO_ADDR
// y := GetY ( building ) ;
43747: LD_ADDR_VAR 0 8
43751: PUSH
43752: LD_VAR 0 1
43756: PPUSH
43757: CALL_OW 251
43761: ST_TO_ADDR
// d := GetDir ( building ) ;
43762: LD_ADDR_VAR 0 9
43766: PUSH
43767: LD_VAR 0 1
43771: PPUSH
43772: CALL_OW 254
43776: ST_TO_ADDR
// for i = 1 to mc_bases do
43777: LD_ADDR_VAR 0 4
43781: PUSH
43782: DOUBLE
43783: LD_INT 1
43785: DEC
43786: ST_TO_ADDR
43787: LD_EXP 50
43791: PUSH
43792: FOR_TO
43793: IFFALSE 43946
// begin if not mc_build_list [ i ] then
43795: LD_EXP 55
43799: PUSH
43800: LD_VAR 0 4
43804: ARRAY
43805: NOT
43806: IFFALSE 43810
// continue ;
43808: GO 43792
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
43810: LD_VAR 0 6
43814: PUSH
43815: LD_VAR 0 7
43819: PUSH
43820: LD_VAR 0 8
43824: PUSH
43825: LD_VAR 0 9
43829: PUSH
43830: EMPTY
43831: LIST
43832: LIST
43833: LIST
43834: LIST
43835: PPUSH
43836: LD_EXP 55
43840: PUSH
43841: LD_VAR 0 4
43845: ARRAY
43846: PUSH
43847: LD_INT 1
43849: ARRAY
43850: PPUSH
43851: CALL 57234 0 2
43855: IFFALSE 43944
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
43857: LD_ADDR_EXP 55
43861: PUSH
43862: LD_EXP 55
43866: PPUSH
43867: LD_VAR 0 4
43871: PPUSH
43872: LD_EXP 55
43876: PUSH
43877: LD_VAR 0 4
43881: ARRAY
43882: PPUSH
43883: LD_INT 1
43885: PPUSH
43886: CALL_OW 3
43890: PPUSH
43891: CALL_OW 1
43895: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
43896: LD_ADDR_EXP 57
43900: PUSH
43901: LD_EXP 57
43905: PPUSH
43906: LD_VAR 0 4
43910: PUSH
43911: LD_EXP 57
43915: PUSH
43916: LD_VAR 0 4
43920: ARRAY
43921: PUSH
43922: LD_INT 1
43924: PLUS
43925: PUSH
43926: EMPTY
43927: LIST
43928: LIST
43929: PPUSH
43930: LD_VAR 0 1
43934: PPUSH
43935: CALL 51065 0 3
43939: ST_TO_ADDR
// exit ;
43940: POP
43941: POP
43942: GO 43948
// end ; end ;
43944: GO 43792
43946: POP
43947: POP
// end ;
43948: LD_VAR 0 3
43952: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
43953: LD_INT 0
43955: PPUSH
43956: PPUSH
43957: PPUSH
// if not mc_bases or not skirmish then
43958: LD_EXP 50
43962: NOT
43963: PUSH
43964: LD_EXP 48
43968: NOT
43969: OR
43970: IFFALSE 43974
// exit ;
43972: GO 44164
// for i = 1 to mc_bases do
43974: LD_ADDR_VAR 0 4
43978: PUSH
43979: DOUBLE
43980: LD_INT 1
43982: DEC
43983: ST_TO_ADDR
43984: LD_EXP 50
43988: PUSH
43989: FOR_TO
43990: IFFALSE 44077
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
43992: LD_VAR 0 1
43996: PUSH
43997: LD_EXP 58
44001: PUSH
44002: LD_VAR 0 4
44006: ARRAY
44007: IN
44008: PUSH
44009: LD_VAR 0 1
44013: PUSH
44014: LD_EXP 59
44018: PUSH
44019: LD_VAR 0 4
44023: ARRAY
44024: IN
44025: NOT
44026: AND
44027: IFFALSE 44075
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
44029: LD_ADDR_EXP 59
44033: PUSH
44034: LD_EXP 59
44038: PPUSH
44039: LD_VAR 0 4
44043: PUSH
44044: LD_EXP 59
44048: PUSH
44049: LD_VAR 0 4
44053: ARRAY
44054: PUSH
44055: LD_INT 1
44057: PLUS
44058: PUSH
44059: EMPTY
44060: LIST
44061: LIST
44062: PPUSH
44063: LD_VAR 0 1
44067: PPUSH
44068: CALL 51065 0 3
44072: ST_TO_ADDR
// break ;
44073: GO 44077
// end ; end ;
44075: GO 43989
44077: POP
44078: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
44079: LD_VAR 0 1
44083: PPUSH
44084: CALL_OW 257
44088: PUSH
44089: LD_EXP 76
44093: IN
44094: PUSH
44095: LD_VAR 0 1
44099: PPUSH
44100: CALL_OW 266
44104: PUSH
44105: LD_INT 5
44107: EQUAL
44108: AND
44109: PUSH
44110: LD_VAR 0 2
44114: PPUSH
44115: CALL_OW 110
44119: PUSH
44120: LD_INT 18
44122: NONEQUAL
44123: AND
44124: IFFALSE 44164
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
44126: LD_VAR 0 2
44130: PPUSH
44131: CALL_OW 257
44135: PUSH
44136: LD_INT 5
44138: PUSH
44139: LD_INT 8
44141: PUSH
44142: LD_INT 9
44144: PUSH
44145: EMPTY
44146: LIST
44147: LIST
44148: LIST
44149: IN
44150: IFFALSE 44164
// SetClass ( unit , 1 ) ;
44152: LD_VAR 0 2
44156: PPUSH
44157: LD_INT 1
44159: PPUSH
44160: CALL_OW 336
// end ;
44164: LD_VAR 0 3
44168: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
44169: LD_INT 0
44171: PPUSH
44172: PPUSH
// if not mc_bases or not skirmish then
44173: LD_EXP 50
44177: NOT
44178: PUSH
44179: LD_EXP 48
44183: NOT
44184: OR
44185: IFFALSE 44189
// exit ;
44187: GO 44305
// if GetLives ( abandoned_vehicle ) > 250 then
44189: LD_VAR 0 2
44193: PPUSH
44194: CALL_OW 256
44198: PUSH
44199: LD_INT 250
44201: GREATER
44202: IFFALSE 44206
// exit ;
44204: GO 44305
// for i = 1 to mc_bases do
44206: LD_ADDR_VAR 0 6
44210: PUSH
44211: DOUBLE
44212: LD_INT 1
44214: DEC
44215: ST_TO_ADDR
44216: LD_EXP 50
44220: PUSH
44221: FOR_TO
44222: IFFALSE 44303
// begin if driver in mc_bases [ i ] then
44224: LD_VAR 0 1
44228: PUSH
44229: LD_EXP 50
44233: PUSH
44234: LD_VAR 0 6
44238: ARRAY
44239: IN
44240: IFFALSE 44301
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
44242: LD_VAR 0 1
44246: PPUSH
44247: LD_EXP 50
44251: PUSH
44252: LD_VAR 0 6
44256: ARRAY
44257: PPUSH
44258: LD_INT 2
44260: PUSH
44261: LD_INT 30
44263: PUSH
44264: LD_INT 0
44266: PUSH
44267: EMPTY
44268: LIST
44269: LIST
44270: PUSH
44271: LD_INT 30
44273: PUSH
44274: LD_INT 1
44276: PUSH
44277: EMPTY
44278: LIST
44279: LIST
44280: PUSH
44281: EMPTY
44282: LIST
44283: LIST
44284: LIST
44285: PPUSH
44286: CALL_OW 72
44290: PUSH
44291: LD_INT 1
44293: ARRAY
44294: PPUSH
44295: CALL_OW 112
// break ;
44299: GO 44303
// end ; end ;
44301: GO 44221
44303: POP
44304: POP
// end ; end_of_file
44305: LD_VAR 0 5
44309: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
44310: LD_INT 0
44312: PPUSH
44313: PPUSH
// if exist_mode then
44314: LD_VAR 0 2
44318: IFFALSE 44343
// unit := CreateCharacter ( prefix & ident ) else
44320: LD_ADDR_VAR 0 5
44324: PUSH
44325: LD_VAR 0 3
44329: PUSH
44330: LD_VAR 0 1
44334: STR
44335: PPUSH
44336: CALL_OW 34
44340: ST_TO_ADDR
44341: GO 44358
// unit := NewCharacter ( ident ) ;
44343: LD_ADDR_VAR 0 5
44347: PUSH
44348: LD_VAR 0 1
44352: PPUSH
44353: CALL_OW 25
44357: ST_TO_ADDR
// result := unit ;
44358: LD_ADDR_VAR 0 4
44362: PUSH
44363: LD_VAR 0 5
44367: ST_TO_ADDR
// end ;
44368: LD_VAR 0 4
44372: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
44373: LD_INT 0
44375: PPUSH
44376: PPUSH
// if not side or not nation then
44377: LD_VAR 0 1
44381: NOT
44382: PUSH
44383: LD_VAR 0 2
44387: NOT
44388: OR
44389: IFFALSE 44393
// exit ;
44391: GO 45029
// case nation of nation_american :
44393: LD_VAR 0 2
44397: PUSH
44398: LD_INT 1
44400: DOUBLE
44401: EQUAL
44402: IFTRUE 44406
44404: GO 44576
44406: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
44407: LD_ADDR_VAR 0 4
44411: PUSH
44412: LD_INT 35
44414: PUSH
44415: LD_INT 45
44417: PUSH
44418: LD_INT 46
44420: PUSH
44421: LD_INT 47
44423: PUSH
44424: LD_INT 1
44426: PUSH
44427: LD_INT 2
44429: PUSH
44430: LD_INT 6
44432: PUSH
44433: LD_INT 15
44435: PUSH
44436: LD_INT 16
44438: PUSH
44439: LD_INT 7
44441: PUSH
44442: LD_INT 12
44444: PUSH
44445: LD_INT 13
44447: PUSH
44448: LD_INT 10
44450: PUSH
44451: LD_INT 14
44453: PUSH
44454: LD_INT 20
44456: PUSH
44457: LD_INT 21
44459: PUSH
44460: LD_INT 22
44462: PUSH
44463: LD_INT 25
44465: PUSH
44466: LD_INT 32
44468: PUSH
44469: LD_INT 27
44471: PUSH
44472: LD_INT 36
44474: PUSH
44475: LD_INT 69
44477: PUSH
44478: LD_INT 39
44480: PUSH
44481: LD_INT 34
44483: PUSH
44484: LD_INT 40
44486: PUSH
44487: LD_INT 48
44489: PUSH
44490: LD_INT 49
44492: PUSH
44493: LD_INT 50
44495: PUSH
44496: LD_INT 51
44498: PUSH
44499: LD_INT 52
44501: PUSH
44502: LD_INT 53
44504: PUSH
44505: LD_INT 54
44507: PUSH
44508: LD_INT 55
44510: PUSH
44511: LD_INT 56
44513: PUSH
44514: LD_INT 57
44516: PUSH
44517: LD_INT 58
44519: PUSH
44520: LD_INT 59
44522: PUSH
44523: LD_INT 60
44525: PUSH
44526: LD_INT 61
44528: PUSH
44529: LD_INT 62
44531: PUSH
44532: EMPTY
44533: LIST
44534: LIST
44535: LIST
44536: LIST
44537: LIST
44538: LIST
44539: LIST
44540: LIST
44541: LIST
44542: LIST
44543: LIST
44544: LIST
44545: LIST
44546: LIST
44547: LIST
44548: LIST
44549: LIST
44550: LIST
44551: LIST
44552: LIST
44553: LIST
44554: LIST
44555: LIST
44556: LIST
44557: LIST
44558: LIST
44559: LIST
44560: LIST
44561: LIST
44562: LIST
44563: LIST
44564: LIST
44565: LIST
44566: LIST
44567: LIST
44568: LIST
44569: LIST
44570: LIST
44571: LIST
44572: LIST
44573: ST_TO_ADDR
44574: GO 44953
44576: LD_INT 2
44578: DOUBLE
44579: EQUAL
44580: IFTRUE 44584
44582: GO 44762
44584: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
44585: LD_ADDR_VAR 0 4
44589: PUSH
44590: LD_INT 35
44592: PUSH
44593: LD_INT 45
44595: PUSH
44596: LD_INT 46
44598: PUSH
44599: LD_INT 47
44601: PUSH
44602: LD_INT 70
44604: PUSH
44605: LD_INT 1
44607: PUSH
44608: LD_INT 11
44610: PUSH
44611: LD_INT 3
44613: PUSH
44614: LD_INT 4
44616: PUSH
44617: LD_INT 5
44619: PUSH
44620: LD_INT 6
44622: PUSH
44623: LD_INT 15
44625: PUSH
44626: LD_INT 18
44628: PUSH
44629: LD_INT 7
44631: PUSH
44632: LD_INT 17
44634: PUSH
44635: LD_INT 8
44637: PUSH
44638: LD_INT 20
44640: PUSH
44641: LD_INT 21
44643: PUSH
44644: LD_INT 22
44646: PUSH
44647: LD_INT 72
44649: PUSH
44650: LD_INT 26
44652: PUSH
44653: LD_INT 69
44655: PUSH
44656: LD_INT 39
44658: PUSH
44659: LD_INT 40
44661: PUSH
44662: LD_INT 41
44664: PUSH
44665: LD_INT 42
44667: PUSH
44668: LD_INT 43
44670: PUSH
44671: LD_INT 48
44673: PUSH
44674: LD_INT 49
44676: PUSH
44677: LD_INT 50
44679: PUSH
44680: LD_INT 51
44682: PUSH
44683: LD_INT 52
44685: PUSH
44686: LD_INT 53
44688: PUSH
44689: LD_INT 54
44691: PUSH
44692: LD_INT 55
44694: PUSH
44695: LD_INT 56
44697: PUSH
44698: LD_INT 60
44700: PUSH
44701: LD_INT 61
44703: PUSH
44704: LD_INT 62
44706: PUSH
44707: LD_INT 66
44709: PUSH
44710: LD_INT 67
44712: PUSH
44713: LD_INT 68
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: LIST
44720: LIST
44721: LIST
44722: LIST
44723: LIST
44724: LIST
44725: LIST
44726: LIST
44727: LIST
44728: LIST
44729: LIST
44730: LIST
44731: LIST
44732: LIST
44733: LIST
44734: LIST
44735: LIST
44736: LIST
44737: LIST
44738: LIST
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: LIST
44744: LIST
44745: LIST
44746: LIST
44747: LIST
44748: LIST
44749: LIST
44750: LIST
44751: LIST
44752: LIST
44753: LIST
44754: LIST
44755: LIST
44756: LIST
44757: LIST
44758: LIST
44759: ST_TO_ADDR
44760: GO 44953
44762: LD_INT 3
44764: DOUBLE
44765: EQUAL
44766: IFTRUE 44770
44768: GO 44952
44770: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
44771: LD_ADDR_VAR 0 4
44775: PUSH
44776: LD_INT 46
44778: PUSH
44779: LD_INT 47
44781: PUSH
44782: LD_INT 1
44784: PUSH
44785: LD_INT 2
44787: PUSH
44788: LD_INT 11
44790: PUSH
44791: LD_INT 9
44793: PUSH
44794: LD_INT 20
44796: PUSH
44797: LD_INT 19
44799: PUSH
44800: LD_INT 21
44802: PUSH
44803: LD_INT 24
44805: PUSH
44806: LD_INT 22
44808: PUSH
44809: LD_INT 25
44811: PUSH
44812: LD_INT 28
44814: PUSH
44815: LD_INT 29
44817: PUSH
44818: LD_INT 30
44820: PUSH
44821: LD_INT 31
44823: PUSH
44824: LD_INT 37
44826: PUSH
44827: LD_INT 38
44829: PUSH
44830: LD_INT 32
44832: PUSH
44833: LD_INT 27
44835: PUSH
44836: LD_INT 33
44838: PUSH
44839: LD_INT 69
44841: PUSH
44842: LD_INT 39
44844: PUSH
44845: LD_INT 34
44847: PUSH
44848: LD_INT 40
44850: PUSH
44851: LD_INT 71
44853: PUSH
44854: LD_INT 23
44856: PUSH
44857: LD_INT 44
44859: PUSH
44860: LD_INT 48
44862: PUSH
44863: LD_INT 49
44865: PUSH
44866: LD_INT 50
44868: PUSH
44869: LD_INT 51
44871: PUSH
44872: LD_INT 52
44874: PUSH
44875: LD_INT 53
44877: PUSH
44878: LD_INT 54
44880: PUSH
44881: LD_INT 55
44883: PUSH
44884: LD_INT 56
44886: PUSH
44887: LD_INT 57
44889: PUSH
44890: LD_INT 58
44892: PUSH
44893: LD_INT 59
44895: PUSH
44896: LD_INT 63
44898: PUSH
44899: LD_INT 64
44901: PUSH
44902: LD_INT 65
44904: PUSH
44905: EMPTY
44906: LIST
44907: LIST
44908: LIST
44909: LIST
44910: LIST
44911: LIST
44912: LIST
44913: LIST
44914: LIST
44915: LIST
44916: LIST
44917: LIST
44918: LIST
44919: LIST
44920: LIST
44921: LIST
44922: LIST
44923: LIST
44924: LIST
44925: LIST
44926: LIST
44927: LIST
44928: LIST
44929: LIST
44930: LIST
44931: LIST
44932: LIST
44933: LIST
44934: LIST
44935: LIST
44936: LIST
44937: LIST
44938: LIST
44939: LIST
44940: LIST
44941: LIST
44942: LIST
44943: LIST
44944: LIST
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: ST_TO_ADDR
44950: GO 44953
44952: POP
// if state > - 1 and state < 3 then
44953: LD_VAR 0 3
44957: PUSH
44958: LD_INT 1
44960: NEG
44961: GREATER
44962: PUSH
44963: LD_VAR 0 3
44967: PUSH
44968: LD_INT 3
44970: LESS
44971: AND
44972: IFFALSE 45029
// for i in result do
44974: LD_ADDR_VAR 0 5
44978: PUSH
44979: LD_VAR 0 4
44983: PUSH
44984: FOR_IN
44985: IFFALSE 45027
// if GetTech ( i , side ) <> state then
44987: LD_VAR 0 5
44991: PPUSH
44992: LD_VAR 0 1
44996: PPUSH
44997: CALL_OW 321
45001: PUSH
45002: LD_VAR 0 3
45006: NONEQUAL
45007: IFFALSE 45025
// result := result diff i ;
45009: LD_ADDR_VAR 0 4
45013: PUSH
45014: LD_VAR 0 4
45018: PUSH
45019: LD_VAR 0 5
45023: DIFF
45024: ST_TO_ADDR
45025: GO 44984
45027: POP
45028: POP
// end ;
45029: LD_VAR 0 4
45033: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
45034: LD_INT 0
45036: PPUSH
45037: PPUSH
45038: PPUSH
// result := true ;
45039: LD_ADDR_VAR 0 3
45043: PUSH
45044: LD_INT 1
45046: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
45047: LD_ADDR_VAR 0 5
45051: PUSH
45052: LD_VAR 0 2
45056: PPUSH
45057: CALL_OW 480
45061: ST_TO_ADDR
// if not tmp then
45062: LD_VAR 0 5
45066: NOT
45067: IFFALSE 45071
// exit ;
45069: GO 45120
// for i in tmp do
45071: LD_ADDR_VAR 0 4
45075: PUSH
45076: LD_VAR 0 5
45080: PUSH
45081: FOR_IN
45082: IFFALSE 45118
// if GetTech ( i , side ) <> state_researched then
45084: LD_VAR 0 4
45088: PPUSH
45089: LD_VAR 0 1
45093: PPUSH
45094: CALL_OW 321
45098: PUSH
45099: LD_INT 2
45101: NONEQUAL
45102: IFFALSE 45116
// begin result := false ;
45104: LD_ADDR_VAR 0 3
45108: PUSH
45109: LD_INT 0
45111: ST_TO_ADDR
// exit ;
45112: POP
45113: POP
45114: GO 45120
// end ;
45116: GO 45081
45118: POP
45119: POP
// end ;
45120: LD_VAR 0 3
45124: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
45125: LD_INT 0
45127: PPUSH
45128: PPUSH
45129: PPUSH
45130: PPUSH
45131: PPUSH
45132: PPUSH
45133: PPUSH
45134: PPUSH
45135: PPUSH
45136: PPUSH
45137: PPUSH
45138: PPUSH
45139: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
45140: LD_VAR 0 1
45144: NOT
45145: PUSH
45146: LD_VAR 0 1
45150: PPUSH
45151: CALL_OW 257
45155: PUSH
45156: LD_INT 9
45158: NONEQUAL
45159: OR
45160: IFFALSE 45164
// exit ;
45162: GO 45737
// side := GetSide ( unit ) ;
45164: LD_ADDR_VAR 0 9
45168: PUSH
45169: LD_VAR 0 1
45173: PPUSH
45174: CALL_OW 255
45178: ST_TO_ADDR
// tech_space := tech_spacanom ;
45179: LD_ADDR_VAR 0 12
45183: PUSH
45184: LD_INT 29
45186: ST_TO_ADDR
// tech_time := tech_taurad ;
45187: LD_ADDR_VAR 0 13
45191: PUSH
45192: LD_INT 28
45194: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
45195: LD_ADDR_VAR 0 11
45199: PUSH
45200: LD_VAR 0 1
45204: PPUSH
45205: CALL_OW 310
45209: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
45210: LD_VAR 0 11
45214: PPUSH
45215: CALL_OW 247
45219: PUSH
45220: LD_INT 2
45222: EQUAL
45223: IFFALSE 45227
// exit ;
45225: GO 45737
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
45227: LD_ADDR_VAR 0 8
45231: PUSH
45232: LD_INT 81
45234: PUSH
45235: LD_VAR 0 9
45239: PUSH
45240: EMPTY
45241: LIST
45242: LIST
45243: PUSH
45244: LD_INT 3
45246: PUSH
45247: LD_INT 21
45249: PUSH
45250: LD_INT 3
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: PUSH
45257: EMPTY
45258: LIST
45259: LIST
45260: PUSH
45261: EMPTY
45262: LIST
45263: LIST
45264: PPUSH
45265: CALL_OW 69
45269: ST_TO_ADDR
// if not tmp then
45270: LD_VAR 0 8
45274: NOT
45275: IFFALSE 45279
// exit ;
45277: GO 45737
// if in_unit then
45279: LD_VAR 0 11
45283: IFFALSE 45307
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
45285: LD_ADDR_VAR 0 10
45289: PUSH
45290: LD_VAR 0 8
45294: PPUSH
45295: LD_VAR 0 11
45299: PPUSH
45300: CALL_OW 74
45304: ST_TO_ADDR
45305: GO 45327
// enemy := NearestUnitToUnit ( tmp , unit ) ;
45307: LD_ADDR_VAR 0 10
45311: PUSH
45312: LD_VAR 0 8
45316: PPUSH
45317: LD_VAR 0 1
45321: PPUSH
45322: CALL_OW 74
45326: ST_TO_ADDR
// if not enemy then
45327: LD_VAR 0 10
45331: NOT
45332: IFFALSE 45336
// exit ;
45334: GO 45737
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
45336: LD_VAR 0 11
45340: PUSH
45341: LD_VAR 0 11
45345: PPUSH
45346: LD_VAR 0 10
45350: PPUSH
45351: CALL_OW 296
45355: PUSH
45356: LD_INT 13
45358: GREATER
45359: AND
45360: PUSH
45361: LD_VAR 0 1
45365: PPUSH
45366: LD_VAR 0 10
45370: PPUSH
45371: CALL_OW 296
45375: PUSH
45376: LD_INT 12
45378: GREATER
45379: OR
45380: IFFALSE 45384
// exit ;
45382: GO 45737
// missile := [ 1 ] ;
45384: LD_ADDR_VAR 0 14
45388: PUSH
45389: LD_INT 1
45391: PUSH
45392: EMPTY
45393: LIST
45394: ST_TO_ADDR
// if Researched ( side , tech_space ) then
45395: LD_VAR 0 9
45399: PPUSH
45400: LD_VAR 0 12
45404: PPUSH
45405: CALL_OW 325
45409: IFFALSE 45438
// missile := Insert ( missile , missile + 1 , 2 ) ;
45411: LD_ADDR_VAR 0 14
45415: PUSH
45416: LD_VAR 0 14
45420: PPUSH
45421: LD_VAR 0 14
45425: PUSH
45426: LD_INT 1
45428: PLUS
45429: PPUSH
45430: LD_INT 2
45432: PPUSH
45433: CALL_OW 2
45437: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
45438: LD_VAR 0 9
45442: PPUSH
45443: LD_VAR 0 13
45447: PPUSH
45448: CALL_OW 325
45452: PUSH
45453: LD_VAR 0 10
45457: PPUSH
45458: CALL_OW 255
45462: PPUSH
45463: LD_VAR 0 13
45467: PPUSH
45468: CALL_OW 325
45472: NOT
45473: AND
45474: IFFALSE 45503
// missile := Insert ( missile , missile + 1 , 3 ) ;
45476: LD_ADDR_VAR 0 14
45480: PUSH
45481: LD_VAR 0 14
45485: PPUSH
45486: LD_VAR 0 14
45490: PUSH
45491: LD_INT 1
45493: PLUS
45494: PPUSH
45495: LD_INT 3
45497: PPUSH
45498: CALL_OW 2
45502: ST_TO_ADDR
// if missile < 2 then
45503: LD_VAR 0 14
45507: PUSH
45508: LD_INT 2
45510: LESS
45511: IFFALSE 45515
// exit ;
45513: GO 45737
// x := GetX ( enemy ) ;
45515: LD_ADDR_VAR 0 4
45519: PUSH
45520: LD_VAR 0 10
45524: PPUSH
45525: CALL_OW 250
45529: ST_TO_ADDR
// y := GetY ( enemy ) ;
45530: LD_ADDR_VAR 0 5
45534: PUSH
45535: LD_VAR 0 10
45539: PPUSH
45540: CALL_OW 251
45544: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
45545: LD_ADDR_VAR 0 6
45549: PUSH
45550: LD_VAR 0 4
45554: PUSH
45555: LD_INT 1
45557: NEG
45558: PPUSH
45559: LD_INT 1
45561: PPUSH
45562: CALL_OW 12
45566: PLUS
45567: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
45568: LD_ADDR_VAR 0 7
45572: PUSH
45573: LD_VAR 0 5
45577: PUSH
45578: LD_INT 1
45580: NEG
45581: PPUSH
45582: LD_INT 1
45584: PPUSH
45585: CALL_OW 12
45589: PLUS
45590: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
45591: LD_VAR 0 6
45595: PPUSH
45596: LD_VAR 0 7
45600: PPUSH
45601: CALL_OW 488
45605: NOT
45606: IFFALSE 45628
// begin _x := x ;
45608: LD_ADDR_VAR 0 6
45612: PUSH
45613: LD_VAR 0 4
45617: ST_TO_ADDR
// _y := y ;
45618: LD_ADDR_VAR 0 7
45622: PUSH
45623: LD_VAR 0 5
45627: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
45628: LD_ADDR_VAR 0 3
45632: PUSH
45633: LD_INT 1
45635: PPUSH
45636: LD_VAR 0 14
45640: PPUSH
45641: CALL_OW 12
45645: ST_TO_ADDR
// case i of 1 :
45646: LD_VAR 0 3
45650: PUSH
45651: LD_INT 1
45653: DOUBLE
45654: EQUAL
45655: IFTRUE 45659
45657: GO 45676
45659: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
45660: LD_VAR 0 1
45664: PPUSH
45665: LD_VAR 0 10
45669: PPUSH
45670: CALL_OW 115
45674: GO 45737
45676: LD_INT 2
45678: DOUBLE
45679: EQUAL
45680: IFTRUE 45684
45682: GO 45706
45684: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
45685: LD_VAR 0 1
45689: PPUSH
45690: LD_VAR 0 6
45694: PPUSH
45695: LD_VAR 0 7
45699: PPUSH
45700: CALL_OW 153
45704: GO 45737
45706: LD_INT 3
45708: DOUBLE
45709: EQUAL
45710: IFTRUE 45714
45712: GO 45736
45714: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
45715: LD_VAR 0 1
45719: PPUSH
45720: LD_VAR 0 6
45724: PPUSH
45725: LD_VAR 0 7
45729: PPUSH
45730: CALL_OW 154
45734: GO 45737
45736: POP
// end ;
45737: LD_VAR 0 2
45741: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
45742: LD_INT 0
45744: PPUSH
45745: PPUSH
45746: PPUSH
45747: PPUSH
45748: PPUSH
45749: PPUSH
// if not unit or not building then
45750: LD_VAR 0 1
45754: NOT
45755: PUSH
45756: LD_VAR 0 2
45760: NOT
45761: OR
45762: IFFALSE 45766
// exit ;
45764: GO 45924
// x := GetX ( building ) ;
45766: LD_ADDR_VAR 0 5
45770: PUSH
45771: LD_VAR 0 2
45775: PPUSH
45776: CALL_OW 250
45780: ST_TO_ADDR
// y := GetY ( building ) ;
45781: LD_ADDR_VAR 0 6
45785: PUSH
45786: LD_VAR 0 2
45790: PPUSH
45791: CALL_OW 251
45795: ST_TO_ADDR
// for i = 0 to 5 do
45796: LD_ADDR_VAR 0 4
45800: PUSH
45801: DOUBLE
45802: LD_INT 0
45804: DEC
45805: ST_TO_ADDR
45806: LD_INT 5
45808: PUSH
45809: FOR_TO
45810: IFFALSE 45922
// begin _x := ShiftX ( x , i , 3 ) ;
45812: LD_ADDR_VAR 0 7
45816: PUSH
45817: LD_VAR 0 5
45821: PPUSH
45822: LD_VAR 0 4
45826: PPUSH
45827: LD_INT 3
45829: PPUSH
45830: CALL_OW 272
45834: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
45835: LD_ADDR_VAR 0 8
45839: PUSH
45840: LD_VAR 0 6
45844: PPUSH
45845: LD_VAR 0 4
45849: PPUSH
45850: LD_INT 3
45852: PPUSH
45853: CALL_OW 273
45857: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
45858: LD_VAR 0 7
45862: PPUSH
45863: LD_VAR 0 8
45867: PPUSH
45868: CALL_OW 488
45872: NOT
45873: IFFALSE 45877
// continue ;
45875: GO 45809
// if HexInfo ( _x , _y ) = 0 then
45877: LD_VAR 0 7
45881: PPUSH
45882: LD_VAR 0 8
45886: PPUSH
45887: CALL_OW 428
45891: PUSH
45892: LD_INT 0
45894: EQUAL
45895: IFFALSE 45920
// begin ComMoveXY ( unit , _x , _y ) ;
45897: LD_VAR 0 1
45901: PPUSH
45902: LD_VAR 0 7
45906: PPUSH
45907: LD_VAR 0 8
45911: PPUSH
45912: CALL_OW 111
// exit ;
45916: POP
45917: POP
45918: GO 45924
// end ; end ;
45920: GO 45809
45922: POP
45923: POP
// end ;
45924: LD_VAR 0 3
45928: RET
// export function ScanBase ( side , base_area ) ; begin
45929: LD_INT 0
45931: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
45932: LD_ADDR_VAR 0 3
45936: PUSH
45937: LD_VAR 0 2
45941: PPUSH
45942: LD_INT 81
45944: PUSH
45945: LD_VAR 0 1
45949: PUSH
45950: EMPTY
45951: LIST
45952: LIST
45953: PPUSH
45954: CALL_OW 70
45958: ST_TO_ADDR
// end ;
45959: LD_VAR 0 3
45963: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
45964: LD_INT 0
45966: PPUSH
45967: PPUSH
45968: PPUSH
45969: PPUSH
45970: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
45971: LD_VAR 0 1
45975: NOT
45976: PUSH
45977: LD_EXP 50
45981: PUSH
45982: LD_VAR 0 1
45986: ARRAY
45987: NOT
45988: OR
45989: PUSH
45990: LD_VAR 0 2
45994: NOT
45995: OR
45996: PUSH
45997: LD_VAR 0 3
46001: NOT
46002: OR
46003: IFFALSE 46007
// exit ;
46005: GO 46457
// side := mc_sides [ base ] ;
46007: LD_ADDR_VAR 0 6
46011: PUSH
46012: LD_EXP 76
46016: PUSH
46017: LD_VAR 0 1
46021: ARRAY
46022: ST_TO_ADDR
// if not side then
46023: LD_VAR 0 6
46027: NOT
46028: IFFALSE 46032
// exit ;
46030: GO 46457
// for i in solds do
46032: LD_ADDR_VAR 0 7
46036: PUSH
46037: LD_VAR 0 2
46041: PUSH
46042: FOR_IN
46043: IFFALSE 46104
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
46045: LD_VAR 0 7
46049: PPUSH
46050: CALL_OW 310
46054: PPUSH
46055: CALL_OW 266
46059: PUSH
46060: LD_INT 32
46062: PUSH
46063: LD_INT 31
46065: PUSH
46066: EMPTY
46067: LIST
46068: LIST
46069: IN
46070: IFFALSE 46090
// solds := solds diff i else
46072: LD_ADDR_VAR 0 2
46076: PUSH
46077: LD_VAR 0 2
46081: PUSH
46082: LD_VAR 0 7
46086: DIFF
46087: ST_TO_ADDR
46088: GO 46102
// SetTag ( i , 18 ) ;
46090: LD_VAR 0 7
46094: PPUSH
46095: LD_INT 18
46097: PPUSH
46098: CALL_OW 109
46102: GO 46042
46104: POP
46105: POP
// if not solds then
46106: LD_VAR 0 2
46110: NOT
46111: IFFALSE 46115
// exit ;
46113: GO 46457
// repeat wait ( 0 0$1 ) ;
46115: LD_INT 35
46117: PPUSH
46118: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
46122: LD_ADDR_VAR 0 5
46126: PUSH
46127: LD_VAR 0 6
46131: PPUSH
46132: LD_VAR 0 3
46136: PPUSH
46137: CALL 45929 0 2
46141: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
46142: LD_VAR 0 5
46146: NOT
46147: PUSH
46148: LD_VAR 0 5
46152: PUSH
46153: LD_INT 3
46155: GREATER
46156: OR
46157: PUSH
46158: LD_EXP 72
46162: PUSH
46163: LD_VAR 0 1
46167: ARRAY
46168: OR
46169: IFFALSE 46210
// begin for i in solds do
46171: LD_ADDR_VAR 0 7
46175: PUSH
46176: LD_VAR 0 2
46180: PUSH
46181: FOR_IN
46182: IFFALSE 46206
// if HasTask ( i ) then
46184: LD_VAR 0 7
46188: PPUSH
46189: CALL_OW 314
46193: IFFALSE 46204
// ComStop ( i ) ;
46195: LD_VAR 0 7
46199: PPUSH
46200: CALL_OW 141
46204: GO 46181
46206: POP
46207: POP
// break ;
46208: GO 46445
// end ; for i in solds do
46210: LD_ADDR_VAR 0 7
46214: PUSH
46215: LD_VAR 0 2
46219: PUSH
46220: FOR_IN
46221: IFFALSE 46437
// begin if IsInUnit ( i ) then
46223: LD_VAR 0 7
46227: PPUSH
46228: CALL_OW 310
46232: IFFALSE 46243
// ComExitBuilding ( i ) ;
46234: LD_VAR 0 7
46238: PPUSH
46239: CALL_OW 122
// if GetLives ( i ) > 333 then
46243: LD_VAR 0 7
46247: PPUSH
46248: CALL_OW 256
46252: PUSH
46253: LD_INT 333
46255: GREATER
46256: IFFALSE 46284
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
46258: LD_VAR 0 7
46262: PPUSH
46263: LD_VAR 0 5
46267: PPUSH
46268: LD_VAR 0 7
46272: PPUSH
46273: CALL_OW 74
46277: PPUSH
46278: CALL_OW 115
46282: GO 46435
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
46284: LD_ADDR_VAR 0 8
46288: PUSH
46289: LD_EXP 50
46293: PUSH
46294: LD_VAR 0 1
46298: ARRAY
46299: PPUSH
46300: LD_INT 2
46302: PUSH
46303: LD_INT 30
46305: PUSH
46306: LD_INT 0
46308: PUSH
46309: EMPTY
46310: LIST
46311: LIST
46312: PUSH
46313: LD_INT 30
46315: PUSH
46316: LD_INT 1
46318: PUSH
46319: EMPTY
46320: LIST
46321: LIST
46322: PUSH
46323: LD_INT 30
46325: PUSH
46326: LD_INT 6
46328: PUSH
46329: EMPTY
46330: LIST
46331: LIST
46332: PUSH
46333: EMPTY
46334: LIST
46335: LIST
46336: LIST
46337: LIST
46338: PPUSH
46339: CALL_OW 72
46343: PPUSH
46344: LD_VAR 0 7
46348: PPUSH
46349: CALL_OW 74
46353: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
46354: LD_VAR 0 7
46358: PPUSH
46359: LD_VAR 0 8
46363: PPUSH
46364: CALL_OW 250
46368: PPUSH
46369: LD_INT 3
46371: PPUSH
46372: LD_INT 5
46374: PPUSH
46375: CALL_OW 272
46379: PPUSH
46380: LD_VAR 0 8
46384: PPUSH
46385: CALL_OW 251
46389: PPUSH
46390: LD_INT 3
46392: PPUSH
46393: LD_INT 5
46395: PPUSH
46396: CALL_OW 273
46400: PPUSH
46401: CALL_OW 111
// SetTag ( i , 0 ) ;
46405: LD_VAR 0 7
46409: PPUSH
46410: LD_INT 0
46412: PPUSH
46413: CALL_OW 109
// solds := solds diff i ;
46417: LD_ADDR_VAR 0 2
46421: PUSH
46422: LD_VAR 0 2
46426: PUSH
46427: LD_VAR 0 7
46431: DIFF
46432: ST_TO_ADDR
// continue ;
46433: GO 46220
// end ; end ;
46435: GO 46220
46437: POP
46438: POP
// until solds ;
46439: LD_VAR 0 2
46443: IFFALSE 46115
// MC_Reset ( base , 18 ) ;
46445: LD_VAR 0 1
46449: PPUSH
46450: LD_INT 18
46452: PPUSH
46453: CALL 19708 0 2
// end ;
46457: LD_VAR 0 4
46461: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
46462: LD_INT 0
46464: PPUSH
46465: PPUSH
46466: PPUSH
46467: PPUSH
46468: PPUSH
46469: PPUSH
46470: PPUSH
46471: PPUSH
46472: PPUSH
46473: PPUSH
46474: PPUSH
46475: PPUSH
46476: PPUSH
46477: PPUSH
46478: PPUSH
46479: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
46480: LD_ADDR_VAR 0 12
46484: PUSH
46485: LD_EXP 50
46489: PUSH
46490: LD_VAR 0 1
46494: ARRAY
46495: PPUSH
46496: LD_INT 25
46498: PUSH
46499: LD_INT 3
46501: PUSH
46502: EMPTY
46503: LIST
46504: LIST
46505: PPUSH
46506: CALL_OW 72
46510: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
46511: LD_ADDR_VAR 0 8
46515: PUSH
46516: LD_EXP 50
46520: PUSH
46521: LD_VAR 0 1
46525: ARRAY
46526: PPUSH
46527: LD_INT 2
46529: PUSH
46530: LD_INT 25
46532: PUSH
46533: LD_INT 1
46535: PUSH
46536: EMPTY
46537: LIST
46538: LIST
46539: PUSH
46540: LD_INT 25
46542: PUSH
46543: LD_INT 5
46545: PUSH
46546: EMPTY
46547: LIST
46548: LIST
46549: PUSH
46550: LD_INT 25
46552: PUSH
46553: LD_INT 8
46555: PUSH
46556: EMPTY
46557: LIST
46558: LIST
46559: PUSH
46560: LD_INT 25
46562: PUSH
46563: LD_INT 9
46565: PUSH
46566: EMPTY
46567: LIST
46568: LIST
46569: PUSH
46570: EMPTY
46571: LIST
46572: LIST
46573: LIST
46574: LIST
46575: LIST
46576: PPUSH
46577: CALL_OW 72
46581: ST_TO_ADDR
// if not defenders and not solds then
46582: LD_VAR 0 2
46586: NOT
46587: PUSH
46588: LD_VAR 0 8
46592: NOT
46593: AND
46594: IFFALSE 46598
// exit ;
46596: GO 47964
// depot_under_attack := false ;
46598: LD_ADDR_VAR 0 16
46602: PUSH
46603: LD_INT 0
46605: ST_TO_ADDR
// sold_defenders := [ ] ;
46606: LD_ADDR_VAR 0 17
46610: PUSH
46611: EMPTY
46612: ST_TO_ADDR
// if mechs then
46613: LD_VAR 0 12
46617: IFFALSE 46746
// for i in defenders do
46619: LD_ADDR_VAR 0 5
46623: PUSH
46624: LD_VAR 0 2
46628: PUSH
46629: FOR_IN
46630: IFFALSE 46744
// begin SetTag ( i , 20 ) ;
46632: LD_VAR 0 5
46636: PPUSH
46637: LD_INT 20
46639: PPUSH
46640: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
46644: LD_VAR 0 5
46648: PPUSH
46649: CALL_OW 263
46653: PUSH
46654: LD_INT 1
46656: EQUAL
46657: PUSH
46658: LD_VAR 0 5
46662: PPUSH
46663: CALL_OW 311
46667: NOT
46668: AND
46669: PUSH
46670: LD_VAR 0 12
46674: AND
46675: IFFALSE 46742
// begin un := mechs [ 1 ] ;
46677: LD_ADDR_VAR 0 10
46681: PUSH
46682: LD_VAR 0 12
46686: PUSH
46687: LD_INT 1
46689: ARRAY
46690: ST_TO_ADDR
// ComExitBuilding ( un ) ;
46691: LD_VAR 0 10
46695: PPUSH
46696: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
46700: LD_VAR 0 10
46704: PPUSH
46705: LD_VAR 0 5
46709: PPUSH
46710: CALL_OW 180
// SetTag ( un , 19 ) ;
46714: LD_VAR 0 10
46718: PPUSH
46719: LD_INT 19
46721: PPUSH
46722: CALL_OW 109
// mechs := mechs diff un ;
46726: LD_ADDR_VAR 0 12
46730: PUSH
46731: LD_VAR 0 12
46735: PUSH
46736: LD_VAR 0 10
46740: DIFF
46741: ST_TO_ADDR
// end ; end ;
46742: GO 46629
46744: POP
46745: POP
// if solds then
46746: LD_VAR 0 8
46750: IFFALSE 46809
// for i in solds do
46752: LD_ADDR_VAR 0 5
46756: PUSH
46757: LD_VAR 0 8
46761: PUSH
46762: FOR_IN
46763: IFFALSE 46807
// if not GetTag ( i ) then
46765: LD_VAR 0 5
46769: PPUSH
46770: CALL_OW 110
46774: NOT
46775: IFFALSE 46805
// begin defenders := defenders union i ;
46777: LD_ADDR_VAR 0 2
46781: PUSH
46782: LD_VAR 0 2
46786: PUSH
46787: LD_VAR 0 5
46791: UNION
46792: ST_TO_ADDR
// SetTag ( i , 18 ) ;
46793: LD_VAR 0 5
46797: PPUSH
46798: LD_INT 18
46800: PPUSH
46801: CALL_OW 109
// end ;
46805: GO 46762
46807: POP
46808: POP
// repeat wait ( 0 0$1 ) ;
46809: LD_INT 35
46811: PPUSH
46812: CALL_OW 67
// enemy := mc_scan [ base ] ;
46816: LD_ADDR_VAR 0 3
46820: PUSH
46821: LD_EXP 73
46825: PUSH
46826: LD_VAR 0 1
46830: ARRAY
46831: ST_TO_ADDR
// for i in defenders do
46832: LD_ADDR_VAR 0 5
46836: PUSH
46837: LD_VAR 0 2
46841: PUSH
46842: FOR_IN
46843: IFFALSE 47528
// begin e := NearestUnitToUnit ( enemy , i ) ;
46845: LD_ADDR_VAR 0 13
46849: PUSH
46850: LD_VAR 0 3
46854: PPUSH
46855: LD_VAR 0 5
46859: PPUSH
46860: CALL_OW 74
46864: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
46865: LD_ADDR_VAR 0 16
46869: PUSH
46870: LD_EXP 50
46874: PUSH
46875: LD_VAR 0 1
46879: ARRAY
46880: PPUSH
46881: LD_INT 2
46883: PUSH
46884: LD_INT 30
46886: PUSH
46887: LD_INT 0
46889: PUSH
46890: EMPTY
46891: LIST
46892: LIST
46893: PUSH
46894: LD_INT 30
46896: PUSH
46897: LD_INT 1
46899: PUSH
46900: EMPTY
46901: LIST
46902: LIST
46903: PUSH
46904: EMPTY
46905: LIST
46906: LIST
46907: LIST
46908: PPUSH
46909: CALL_OW 72
46913: NOT
46914: PUSH
46915: LD_EXP 50
46919: PUSH
46920: LD_VAR 0 1
46924: ARRAY
46925: PPUSH
46926: LD_INT 2
46928: PUSH
46929: LD_INT 30
46931: PUSH
46932: LD_INT 0
46934: PUSH
46935: EMPTY
46936: LIST
46937: LIST
46938: PUSH
46939: LD_INT 30
46941: PUSH
46942: LD_INT 1
46944: PUSH
46945: EMPTY
46946: LIST
46947: LIST
46948: PUSH
46949: EMPTY
46950: LIST
46951: LIST
46952: LIST
46953: PPUSH
46954: CALL_OW 72
46958: PPUSH
46959: CALL_OW 256
46963: PUSH
46964: LD_INT 600
46966: LESS
46967: OR
46968: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
46969: LD_VAR 0 5
46973: PPUSH
46974: CALL_OW 247
46978: PUSH
46979: LD_INT 2
46981: DOUBLE
46982: EQUAL
46983: IFTRUE 46987
46985: GO 47234
46987: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
46988: LD_VAR 0 5
46992: PPUSH
46993: CALL_OW 256
46997: PUSH
46998: LD_INT 650
47000: GREATER
47001: PUSH
47002: LD_VAR 0 5
47006: PPUSH
47007: LD_VAR 0 13
47011: PPUSH
47012: CALL_OW 296
47016: PUSH
47017: LD_INT 40
47019: LESS
47020: AND
47021: IFFALSE 47039
// ComAttackUnit ( i , e ) else
47023: LD_VAR 0 5
47027: PPUSH
47028: LD_VAR 0 13
47032: PPUSH
47033: CALL_OW 115
47037: GO 47117
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
47039: LD_VAR 0 5
47043: PPUSH
47044: LD_VAR 0 13
47048: PPUSH
47049: CALL_OW 296
47053: PUSH
47054: LD_INT 30
47056: GREATEREQUAL
47057: PUSH
47058: LD_VAR 0 5
47062: PPUSH
47063: CALL_OW 256
47067: PUSH
47068: LD_INT 650
47070: LESSEQUAL
47071: OR
47072: PUSH
47073: LD_VAR 0 5
47077: PPUSH
47078: LD_EXP 74
47082: PUSH
47083: LD_VAR 0 1
47087: ARRAY
47088: PPUSH
47089: CALL_OW 308
47093: NOT
47094: AND
47095: IFFALSE 47117
// ComMoveToArea ( i , mc_parking [ base ] ) ;
47097: LD_VAR 0 5
47101: PPUSH
47102: LD_EXP 74
47106: PUSH
47107: LD_VAR 0 1
47111: ARRAY
47112: PPUSH
47113: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
47117: LD_VAR 0 5
47121: PPUSH
47122: CALL_OW 256
47126: PUSH
47127: LD_INT 998
47129: LESS
47130: PUSH
47131: LD_VAR 0 5
47135: PPUSH
47136: CALL_OW 263
47140: PUSH
47141: LD_INT 1
47143: EQUAL
47144: AND
47145: PUSH
47146: LD_VAR 0 5
47150: PPUSH
47151: CALL_OW 311
47155: AND
47156: PUSH
47157: LD_VAR 0 5
47161: PPUSH
47162: LD_EXP 74
47166: PUSH
47167: LD_VAR 0 1
47171: ARRAY
47172: PPUSH
47173: CALL_OW 308
47177: AND
47178: IFFALSE 47232
// begin mech := IsDrivenBy ( i ) ;
47180: LD_ADDR_VAR 0 9
47184: PUSH
47185: LD_VAR 0 5
47189: PPUSH
47190: CALL_OW 311
47194: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
47195: LD_VAR 0 9
47199: PPUSH
47200: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
47204: LD_VAR 0 9
47208: PPUSH
47209: LD_VAR 0 5
47213: PPUSH
47214: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
47218: LD_VAR 0 9
47222: PPUSH
47223: LD_VAR 0 5
47227: PPUSH
47228: CALL_OW 180
// end ; end ; unit_human :
47232: GO 47499
47234: LD_INT 1
47236: DOUBLE
47237: EQUAL
47238: IFTRUE 47242
47240: GO 47498
47242: POP
// begin b := IsInUnit ( i ) ;
47243: LD_ADDR_VAR 0 18
47247: PUSH
47248: LD_VAR 0 5
47252: PPUSH
47253: CALL_OW 310
47257: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
47258: LD_ADDR_VAR 0 19
47262: PUSH
47263: LD_VAR 0 18
47267: NOT
47268: PUSH
47269: LD_VAR 0 18
47273: PPUSH
47274: CALL_OW 266
47278: PUSH
47279: LD_INT 32
47281: PUSH
47282: LD_INT 31
47284: PUSH
47285: EMPTY
47286: LIST
47287: LIST
47288: IN
47289: OR
47290: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
47291: LD_VAR 0 16
47295: PUSH
47296: LD_VAR 0 2
47300: PPUSH
47301: LD_INT 21
47303: PUSH
47304: LD_INT 2
47306: PUSH
47307: EMPTY
47308: LIST
47309: LIST
47310: PPUSH
47311: CALL_OW 72
47315: PUSH
47316: LD_INT 1
47318: LESSEQUAL
47319: OR
47320: PUSH
47321: LD_VAR 0 19
47325: AND
47326: PUSH
47327: LD_VAR 0 5
47331: PUSH
47332: LD_VAR 0 17
47336: IN
47337: NOT
47338: AND
47339: IFFALSE 47432
// begin if b then
47341: LD_VAR 0 18
47345: IFFALSE 47394
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
47347: LD_VAR 0 18
47351: PPUSH
47352: LD_VAR 0 3
47356: PPUSH
47357: LD_VAR 0 18
47361: PPUSH
47362: CALL_OW 74
47366: PPUSH
47367: CALL_OW 296
47371: PUSH
47372: LD_INT 10
47374: LESS
47375: PUSH
47376: LD_VAR 0 18
47380: PPUSH
47381: CALL_OW 461
47385: PUSH
47386: LD_INT 7
47388: NONEQUAL
47389: AND
47390: IFFALSE 47394
// continue ;
47392: GO 46842
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
47394: LD_ADDR_VAR 0 17
47398: PUSH
47399: LD_VAR 0 17
47403: PPUSH
47404: LD_VAR 0 17
47408: PUSH
47409: LD_INT 1
47411: PLUS
47412: PPUSH
47413: LD_VAR 0 5
47417: PPUSH
47418: CALL_OW 1
47422: ST_TO_ADDR
// ComExitBuilding ( i ) ;
47423: LD_VAR 0 5
47427: PPUSH
47428: CALL_OW 122
// end ; if sold_defenders then
47432: LD_VAR 0 17
47436: IFFALSE 47496
// if i in sold_defenders then
47438: LD_VAR 0 5
47442: PUSH
47443: LD_VAR 0 17
47447: IN
47448: IFFALSE 47496
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
47450: LD_VAR 0 5
47454: PPUSH
47455: CALL_OW 314
47459: NOT
47460: PUSH
47461: LD_VAR 0 5
47465: PPUSH
47466: LD_VAR 0 13
47470: PPUSH
47471: CALL_OW 296
47475: PUSH
47476: LD_INT 30
47478: LESS
47479: AND
47480: IFFALSE 47496
// ComAttackUnit ( i , e ) ;
47482: LD_VAR 0 5
47486: PPUSH
47487: LD_VAR 0 13
47491: PPUSH
47492: CALL_OW 115
// end ; end ; end ;
47496: GO 47499
47498: POP
// if IsDead ( i ) then
47499: LD_VAR 0 5
47503: PPUSH
47504: CALL_OW 301
47508: IFFALSE 47526
// defenders := defenders diff i ;
47510: LD_ADDR_VAR 0 2
47514: PUSH
47515: LD_VAR 0 2
47519: PUSH
47520: LD_VAR 0 5
47524: DIFF
47525: ST_TO_ADDR
// end ;
47526: GO 46842
47528: POP
47529: POP
// until not enemy or not defenders ;
47530: LD_VAR 0 3
47534: NOT
47535: PUSH
47536: LD_VAR 0 2
47540: NOT
47541: OR
47542: IFFALSE 46809
// MC_Reset ( base , 18 ) ;
47544: LD_VAR 0 1
47548: PPUSH
47549: LD_INT 18
47551: PPUSH
47552: CALL 19708 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
47556: LD_ADDR_VAR 0 2
47560: PUSH
47561: LD_VAR 0 2
47565: PUSH
47566: LD_VAR 0 2
47570: PPUSH
47571: LD_INT 2
47573: PUSH
47574: LD_INT 25
47576: PUSH
47577: LD_INT 1
47579: PUSH
47580: EMPTY
47581: LIST
47582: LIST
47583: PUSH
47584: LD_INT 25
47586: PUSH
47587: LD_INT 5
47589: PUSH
47590: EMPTY
47591: LIST
47592: LIST
47593: PUSH
47594: LD_INT 25
47596: PUSH
47597: LD_INT 8
47599: PUSH
47600: EMPTY
47601: LIST
47602: LIST
47603: PUSH
47604: LD_INT 25
47606: PUSH
47607: LD_INT 9
47609: PUSH
47610: EMPTY
47611: LIST
47612: LIST
47613: PUSH
47614: EMPTY
47615: LIST
47616: LIST
47617: LIST
47618: LIST
47619: LIST
47620: PPUSH
47621: CALL_OW 72
47625: DIFF
47626: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
47627: LD_VAR 0 3
47631: NOT
47632: PUSH
47633: LD_VAR 0 2
47637: PPUSH
47638: LD_INT 21
47640: PUSH
47641: LD_INT 2
47643: PUSH
47644: EMPTY
47645: LIST
47646: LIST
47647: PPUSH
47648: CALL_OW 72
47652: AND
47653: IFFALSE 47915
// begin tmp := FilterByTag ( defenders , 19 ) ;
47655: LD_ADDR_VAR 0 11
47659: PUSH
47660: LD_VAR 0 2
47664: PPUSH
47665: LD_INT 19
47667: PPUSH
47668: CALL 84262 0 2
47672: ST_TO_ADDR
// if tmp then
47673: LD_VAR 0 11
47677: IFFALSE 47747
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
47679: LD_ADDR_VAR 0 11
47683: PUSH
47684: LD_VAR 0 11
47688: PPUSH
47689: LD_INT 25
47691: PUSH
47692: LD_INT 3
47694: PUSH
47695: EMPTY
47696: LIST
47697: LIST
47698: PPUSH
47699: CALL_OW 72
47703: ST_TO_ADDR
// if tmp then
47704: LD_VAR 0 11
47708: IFFALSE 47747
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
47710: LD_ADDR_EXP 62
47714: PUSH
47715: LD_EXP 62
47719: PPUSH
47720: LD_VAR 0 1
47724: PPUSH
47725: LD_EXP 62
47729: PUSH
47730: LD_VAR 0 1
47734: ARRAY
47735: PUSH
47736: LD_VAR 0 11
47740: UNION
47741: PPUSH
47742: CALL_OW 1
47746: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
47747: LD_VAR 0 1
47751: PPUSH
47752: LD_INT 19
47754: PPUSH
47755: CALL 19708 0 2
// repeat wait ( 0 0$1 ) ;
47759: LD_INT 35
47761: PPUSH
47762: CALL_OW 67
// for i in defenders do
47766: LD_ADDR_VAR 0 5
47770: PUSH
47771: LD_VAR 0 2
47775: PUSH
47776: FOR_IN
47777: IFFALSE 47866
// begin if not IsInArea ( i , mc_parking [ base ] ) then
47779: LD_VAR 0 5
47783: PPUSH
47784: LD_EXP 74
47788: PUSH
47789: LD_VAR 0 1
47793: ARRAY
47794: PPUSH
47795: CALL_OW 308
47799: NOT
47800: IFFALSE 47824
// ComMoveToArea ( i , mc_parking [ base ] ) else
47802: LD_VAR 0 5
47806: PPUSH
47807: LD_EXP 74
47811: PUSH
47812: LD_VAR 0 1
47816: ARRAY
47817: PPUSH
47818: CALL_OW 113
47822: GO 47864
// if GetControl ( i ) = control_manual then
47824: LD_VAR 0 5
47828: PPUSH
47829: CALL_OW 263
47833: PUSH
47834: LD_INT 1
47836: EQUAL
47837: IFFALSE 47864
// if IsDrivenBy ( i ) then
47839: LD_VAR 0 5
47843: PPUSH
47844: CALL_OW 311
47848: IFFALSE 47864
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
47850: LD_VAR 0 5
47854: PPUSH
47855: CALL_OW 311
47859: PPUSH
47860: CALL_OW 121
// end ;
47864: GO 47776
47866: POP
47867: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
47868: LD_VAR 0 2
47872: PPUSH
47873: LD_INT 95
47875: PUSH
47876: LD_EXP 74
47880: PUSH
47881: LD_VAR 0 1
47885: ARRAY
47886: PUSH
47887: EMPTY
47888: LIST
47889: LIST
47890: PPUSH
47891: CALL_OW 72
47895: PUSH
47896: LD_VAR 0 2
47900: EQUAL
47901: PUSH
47902: LD_EXP 73
47906: PUSH
47907: LD_VAR 0 1
47911: ARRAY
47912: OR
47913: IFFALSE 47759
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
47915: LD_ADDR_EXP 72
47919: PUSH
47920: LD_EXP 72
47924: PPUSH
47925: LD_VAR 0 1
47929: PPUSH
47930: LD_EXP 72
47934: PUSH
47935: LD_VAR 0 1
47939: ARRAY
47940: PUSH
47941: LD_VAR 0 2
47945: UNION
47946: PPUSH
47947: CALL_OW 1
47951: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
47952: LD_VAR 0 1
47956: PPUSH
47957: LD_INT 20
47959: PPUSH
47960: CALL 19708 0 2
// end ;
47964: LD_VAR 0 4
47968: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
47969: LD_INT 0
47971: PPUSH
47972: PPUSH
47973: PPUSH
47974: PPUSH
// result := false ;
47975: LD_ADDR_VAR 0 2
47979: PUSH
47980: LD_INT 0
47982: ST_TO_ADDR
// side := GetSide ( unit ) ;
47983: LD_ADDR_VAR 0 3
47987: PUSH
47988: LD_VAR 0 1
47992: PPUSH
47993: CALL_OW 255
47997: ST_TO_ADDR
// nat := GetNation ( unit ) ;
47998: LD_ADDR_VAR 0 4
48002: PUSH
48003: LD_VAR 0 1
48007: PPUSH
48008: CALL_OW 248
48012: ST_TO_ADDR
// case nat of 1 :
48013: LD_VAR 0 4
48017: PUSH
48018: LD_INT 1
48020: DOUBLE
48021: EQUAL
48022: IFTRUE 48026
48024: GO 48037
48026: POP
// tech := tech_lassight ; 2 :
48027: LD_ADDR_VAR 0 5
48031: PUSH
48032: LD_INT 12
48034: ST_TO_ADDR
48035: GO 48076
48037: LD_INT 2
48039: DOUBLE
48040: EQUAL
48041: IFTRUE 48045
48043: GO 48056
48045: POP
// tech := tech_mortar ; 3 :
48046: LD_ADDR_VAR 0 5
48050: PUSH
48051: LD_INT 41
48053: ST_TO_ADDR
48054: GO 48076
48056: LD_INT 3
48058: DOUBLE
48059: EQUAL
48060: IFTRUE 48064
48062: GO 48075
48064: POP
// tech := tech_bazooka ; end ;
48065: LD_ADDR_VAR 0 5
48069: PUSH
48070: LD_INT 44
48072: ST_TO_ADDR
48073: GO 48076
48075: POP
// if Researched ( side , tech ) then
48076: LD_VAR 0 3
48080: PPUSH
48081: LD_VAR 0 5
48085: PPUSH
48086: CALL_OW 325
48090: IFFALSE 48117
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
48092: LD_ADDR_VAR 0 2
48096: PUSH
48097: LD_INT 5
48099: PUSH
48100: LD_INT 8
48102: PUSH
48103: LD_INT 9
48105: PUSH
48106: EMPTY
48107: LIST
48108: LIST
48109: LIST
48110: PUSH
48111: LD_VAR 0 4
48115: ARRAY
48116: ST_TO_ADDR
// end ;
48117: LD_VAR 0 2
48121: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
48122: LD_INT 0
48124: PPUSH
48125: PPUSH
48126: PPUSH
// if not mines then
48127: LD_VAR 0 2
48131: NOT
48132: IFFALSE 48136
// exit ;
48134: GO 48280
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
48136: LD_ADDR_VAR 0 5
48140: PUSH
48141: LD_INT 81
48143: PUSH
48144: LD_VAR 0 1
48148: PUSH
48149: EMPTY
48150: LIST
48151: LIST
48152: PUSH
48153: LD_INT 3
48155: PUSH
48156: LD_INT 21
48158: PUSH
48159: LD_INT 3
48161: PUSH
48162: EMPTY
48163: LIST
48164: LIST
48165: PUSH
48166: EMPTY
48167: LIST
48168: LIST
48169: PUSH
48170: EMPTY
48171: LIST
48172: LIST
48173: PPUSH
48174: CALL_OW 69
48178: ST_TO_ADDR
// for i in mines do
48179: LD_ADDR_VAR 0 4
48183: PUSH
48184: LD_VAR 0 2
48188: PUSH
48189: FOR_IN
48190: IFFALSE 48278
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
48192: LD_VAR 0 4
48196: PUSH
48197: LD_INT 1
48199: ARRAY
48200: PPUSH
48201: LD_VAR 0 4
48205: PUSH
48206: LD_INT 2
48208: ARRAY
48209: PPUSH
48210: CALL_OW 458
48214: NOT
48215: IFFALSE 48219
// continue ;
48217: GO 48189
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
48219: LD_VAR 0 4
48223: PUSH
48224: LD_INT 1
48226: ARRAY
48227: PPUSH
48228: LD_VAR 0 4
48232: PUSH
48233: LD_INT 2
48235: ARRAY
48236: PPUSH
48237: CALL_OW 428
48241: PUSH
48242: LD_VAR 0 5
48246: IN
48247: IFFALSE 48276
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
48249: LD_VAR 0 4
48253: PUSH
48254: LD_INT 1
48256: ARRAY
48257: PPUSH
48258: LD_VAR 0 4
48262: PUSH
48263: LD_INT 2
48265: ARRAY
48266: PPUSH
48267: LD_VAR 0 1
48271: PPUSH
48272: CALL_OW 456
// end ;
48276: GO 48189
48278: POP
48279: POP
// end ;
48280: LD_VAR 0 3
48284: RET
// export function Count ( array ) ; var i ; begin
48285: LD_INT 0
48287: PPUSH
48288: PPUSH
// result := 0 ;
48289: LD_ADDR_VAR 0 2
48293: PUSH
48294: LD_INT 0
48296: ST_TO_ADDR
// for i in array do
48297: LD_ADDR_VAR 0 3
48301: PUSH
48302: LD_VAR 0 1
48306: PUSH
48307: FOR_IN
48308: IFFALSE 48332
// if i then
48310: LD_VAR 0 3
48314: IFFALSE 48330
// result := result + 1 ;
48316: LD_ADDR_VAR 0 2
48320: PUSH
48321: LD_VAR 0 2
48325: PUSH
48326: LD_INT 1
48328: PLUS
48329: ST_TO_ADDR
48330: GO 48307
48332: POP
48333: POP
// end ;
48334: LD_VAR 0 2
48338: RET
// export function IsEmpty ( building ) ; begin
48339: LD_INT 0
48341: PPUSH
// if not building then
48342: LD_VAR 0 1
48346: NOT
48347: IFFALSE 48351
// exit ;
48349: GO 48394
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
48351: LD_ADDR_VAR 0 2
48355: PUSH
48356: LD_VAR 0 1
48360: PUSH
48361: LD_INT 22
48363: PUSH
48364: LD_VAR 0 1
48368: PPUSH
48369: CALL_OW 255
48373: PUSH
48374: EMPTY
48375: LIST
48376: LIST
48377: PUSH
48378: LD_INT 58
48380: PUSH
48381: EMPTY
48382: LIST
48383: PUSH
48384: EMPTY
48385: LIST
48386: LIST
48387: PPUSH
48388: CALL_OW 69
48392: IN
48393: ST_TO_ADDR
// end ;
48394: LD_VAR 0 2
48398: RET
// export function IsNotFull ( building ) ; begin
48399: LD_INT 0
48401: PPUSH
// if not building then
48402: LD_VAR 0 1
48406: NOT
48407: IFFALSE 48411
// exit ;
48409: GO 48430
// result := UnitsInside ( building ) < 6 ;
48411: LD_ADDR_VAR 0 2
48415: PUSH
48416: LD_VAR 0 1
48420: PPUSH
48421: CALL_OW 313
48425: PUSH
48426: LD_INT 6
48428: LESS
48429: ST_TO_ADDR
// end ;
48430: LD_VAR 0 2
48434: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
48435: LD_INT 0
48437: PPUSH
48438: PPUSH
48439: PPUSH
48440: PPUSH
// tmp := [ ] ;
48441: LD_ADDR_VAR 0 3
48445: PUSH
48446: EMPTY
48447: ST_TO_ADDR
// list := [ ] ;
48448: LD_ADDR_VAR 0 5
48452: PUSH
48453: EMPTY
48454: ST_TO_ADDR
// for i = 16 to 25 do
48455: LD_ADDR_VAR 0 4
48459: PUSH
48460: DOUBLE
48461: LD_INT 16
48463: DEC
48464: ST_TO_ADDR
48465: LD_INT 25
48467: PUSH
48468: FOR_TO
48469: IFFALSE 48542
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
48471: LD_ADDR_VAR 0 3
48475: PUSH
48476: LD_VAR 0 3
48480: PUSH
48481: LD_INT 22
48483: PUSH
48484: LD_VAR 0 1
48488: PPUSH
48489: CALL_OW 255
48493: PUSH
48494: EMPTY
48495: LIST
48496: LIST
48497: PUSH
48498: LD_INT 91
48500: PUSH
48501: LD_VAR 0 1
48505: PUSH
48506: LD_INT 6
48508: PUSH
48509: EMPTY
48510: LIST
48511: LIST
48512: LIST
48513: PUSH
48514: LD_INT 30
48516: PUSH
48517: LD_VAR 0 4
48521: PUSH
48522: EMPTY
48523: LIST
48524: LIST
48525: PUSH
48526: EMPTY
48527: LIST
48528: LIST
48529: LIST
48530: PUSH
48531: EMPTY
48532: LIST
48533: PPUSH
48534: CALL_OW 69
48538: ADD
48539: ST_TO_ADDR
48540: GO 48468
48542: POP
48543: POP
// for i = 1 to tmp do
48544: LD_ADDR_VAR 0 4
48548: PUSH
48549: DOUBLE
48550: LD_INT 1
48552: DEC
48553: ST_TO_ADDR
48554: LD_VAR 0 3
48558: PUSH
48559: FOR_TO
48560: IFFALSE 48648
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
48562: LD_ADDR_VAR 0 5
48566: PUSH
48567: LD_VAR 0 5
48571: PUSH
48572: LD_VAR 0 3
48576: PUSH
48577: LD_VAR 0 4
48581: ARRAY
48582: PPUSH
48583: CALL_OW 266
48587: PUSH
48588: LD_VAR 0 3
48592: PUSH
48593: LD_VAR 0 4
48597: ARRAY
48598: PPUSH
48599: CALL_OW 250
48603: PUSH
48604: LD_VAR 0 3
48608: PUSH
48609: LD_VAR 0 4
48613: ARRAY
48614: PPUSH
48615: CALL_OW 251
48619: PUSH
48620: LD_VAR 0 3
48624: PUSH
48625: LD_VAR 0 4
48629: ARRAY
48630: PPUSH
48631: CALL_OW 254
48635: PUSH
48636: EMPTY
48637: LIST
48638: LIST
48639: LIST
48640: LIST
48641: PUSH
48642: EMPTY
48643: LIST
48644: ADD
48645: ST_TO_ADDR
48646: GO 48559
48648: POP
48649: POP
// result := list ;
48650: LD_ADDR_VAR 0 2
48654: PUSH
48655: LD_VAR 0 5
48659: ST_TO_ADDR
// end ;
48660: LD_VAR 0 2
48664: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
48665: LD_INT 0
48667: PPUSH
48668: PPUSH
48669: PPUSH
48670: PPUSH
48671: PPUSH
48672: PPUSH
48673: PPUSH
// if not factory then
48674: LD_VAR 0 1
48678: NOT
48679: IFFALSE 48683
// exit ;
48681: GO 49208
// if control = control_apeman then
48683: LD_VAR 0 4
48687: PUSH
48688: LD_INT 5
48690: EQUAL
48691: IFFALSE 48800
// begin tmp := UnitsInside ( factory ) ;
48693: LD_ADDR_VAR 0 8
48697: PUSH
48698: LD_VAR 0 1
48702: PPUSH
48703: CALL_OW 313
48707: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
48708: LD_VAR 0 8
48712: PPUSH
48713: LD_INT 25
48715: PUSH
48716: LD_INT 12
48718: PUSH
48719: EMPTY
48720: LIST
48721: LIST
48722: PPUSH
48723: CALL_OW 72
48727: NOT
48728: IFFALSE 48738
// control := control_manual ;
48730: LD_ADDR_VAR 0 4
48734: PUSH
48735: LD_INT 1
48737: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
48738: LD_ADDR_VAR 0 8
48742: PUSH
48743: LD_VAR 0 1
48747: PPUSH
48748: CALL 48435 0 1
48752: ST_TO_ADDR
// if tmp then
48753: LD_VAR 0 8
48757: IFFALSE 48800
// begin for i in tmp do
48759: LD_ADDR_VAR 0 7
48763: PUSH
48764: LD_VAR 0 8
48768: PUSH
48769: FOR_IN
48770: IFFALSE 48798
// if i [ 1 ] = b_ext_radar then
48772: LD_VAR 0 7
48776: PUSH
48777: LD_INT 1
48779: ARRAY
48780: PUSH
48781: LD_INT 20
48783: EQUAL
48784: IFFALSE 48796
// begin control := control_remote ;
48786: LD_ADDR_VAR 0 4
48790: PUSH
48791: LD_INT 2
48793: ST_TO_ADDR
// break ;
48794: GO 48798
// end ;
48796: GO 48769
48798: POP
48799: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
48800: LD_VAR 0 1
48804: PPUSH
48805: LD_VAR 0 2
48809: PPUSH
48810: LD_VAR 0 3
48814: PPUSH
48815: LD_VAR 0 4
48819: PPUSH
48820: LD_VAR 0 5
48824: PPUSH
48825: CALL_OW 448
48829: IFFALSE 48864
// begin result := [ chassis , engine , control , weapon ] ;
48831: LD_ADDR_VAR 0 6
48835: PUSH
48836: LD_VAR 0 2
48840: PUSH
48841: LD_VAR 0 3
48845: PUSH
48846: LD_VAR 0 4
48850: PUSH
48851: LD_VAR 0 5
48855: PUSH
48856: EMPTY
48857: LIST
48858: LIST
48859: LIST
48860: LIST
48861: ST_TO_ADDR
// exit ;
48862: GO 49208
// end ; _chassis := AvailableChassisList ( factory ) ;
48864: LD_ADDR_VAR 0 9
48868: PUSH
48869: LD_VAR 0 1
48873: PPUSH
48874: CALL_OW 475
48878: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
48879: LD_ADDR_VAR 0 11
48883: PUSH
48884: LD_VAR 0 1
48888: PPUSH
48889: CALL_OW 476
48893: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
48894: LD_ADDR_VAR 0 12
48898: PUSH
48899: LD_VAR 0 1
48903: PPUSH
48904: CALL_OW 477
48908: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
48909: LD_ADDR_VAR 0 10
48913: PUSH
48914: LD_VAR 0 1
48918: PPUSH
48919: CALL_OW 478
48923: ST_TO_ADDR
// if not chassis in _chassis then
48924: LD_VAR 0 2
48928: PUSH
48929: LD_VAR 0 9
48933: IN
48934: NOT
48935: IFFALSE 48961
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
48937: LD_ADDR_VAR 0 2
48941: PUSH
48942: LD_VAR 0 9
48946: PUSH
48947: LD_INT 1
48949: PPUSH
48950: LD_VAR 0 9
48954: PPUSH
48955: CALL_OW 12
48959: ARRAY
48960: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
48961: LD_VAR 0 2
48965: PPUSH
48966: LD_VAR 0 3
48970: PPUSH
48971: CALL 49213 0 2
48975: NOT
48976: IFFALSE 49035
// repeat engine := _engine [ 1 ] ;
48978: LD_ADDR_VAR 0 3
48982: PUSH
48983: LD_VAR 0 11
48987: PUSH
48988: LD_INT 1
48990: ARRAY
48991: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
48992: LD_ADDR_VAR 0 11
48996: PUSH
48997: LD_VAR 0 11
49001: PPUSH
49002: LD_INT 1
49004: PPUSH
49005: CALL_OW 3
49009: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
49010: LD_VAR 0 2
49014: PPUSH
49015: LD_VAR 0 3
49019: PPUSH
49020: CALL 49213 0 2
49024: PUSH
49025: LD_VAR 0 11
49029: PUSH
49030: EMPTY
49031: EQUAL
49032: OR
49033: IFFALSE 48978
// if not control in _control then
49035: LD_VAR 0 4
49039: PUSH
49040: LD_VAR 0 12
49044: IN
49045: NOT
49046: IFFALSE 49072
// control := _control [ rand ( 1 , _control ) ] ;
49048: LD_ADDR_VAR 0 4
49052: PUSH
49053: LD_VAR 0 12
49057: PUSH
49058: LD_INT 1
49060: PPUSH
49061: LD_VAR 0 12
49065: PPUSH
49066: CALL_OW 12
49070: ARRAY
49071: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
49072: LD_VAR 0 2
49076: PPUSH
49077: LD_VAR 0 5
49081: PPUSH
49082: CALL 49433 0 2
49086: NOT
49087: IFFALSE 49146
// repeat weapon := _weapon [ 1 ] ;
49089: LD_ADDR_VAR 0 5
49093: PUSH
49094: LD_VAR 0 10
49098: PUSH
49099: LD_INT 1
49101: ARRAY
49102: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
49103: LD_ADDR_VAR 0 10
49107: PUSH
49108: LD_VAR 0 10
49112: PPUSH
49113: LD_INT 1
49115: PPUSH
49116: CALL_OW 3
49120: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
49121: LD_VAR 0 2
49125: PPUSH
49126: LD_VAR 0 5
49130: PPUSH
49131: CALL 49433 0 2
49135: PUSH
49136: LD_VAR 0 10
49140: PUSH
49141: EMPTY
49142: EQUAL
49143: OR
49144: IFFALSE 49089
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
49146: LD_VAR 0 1
49150: PPUSH
49151: LD_VAR 0 2
49155: PPUSH
49156: LD_VAR 0 3
49160: PPUSH
49161: LD_VAR 0 4
49165: PPUSH
49166: LD_VAR 0 5
49170: PPUSH
49171: CALL_OW 448
49175: IFFALSE 49208
// result := [ chassis , engine , control , weapon ] ;
49177: LD_ADDR_VAR 0 6
49181: PUSH
49182: LD_VAR 0 2
49186: PUSH
49187: LD_VAR 0 3
49191: PUSH
49192: LD_VAR 0 4
49196: PUSH
49197: LD_VAR 0 5
49201: PUSH
49202: EMPTY
49203: LIST
49204: LIST
49205: LIST
49206: LIST
49207: ST_TO_ADDR
// end ;
49208: LD_VAR 0 6
49212: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
49213: LD_INT 0
49215: PPUSH
// if not chassis or not engine then
49216: LD_VAR 0 1
49220: NOT
49221: PUSH
49222: LD_VAR 0 2
49226: NOT
49227: OR
49228: IFFALSE 49232
// exit ;
49230: GO 49428
// case engine of engine_solar :
49232: LD_VAR 0 2
49236: PUSH
49237: LD_INT 2
49239: DOUBLE
49240: EQUAL
49241: IFTRUE 49245
49243: GO 49283
49245: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
49246: LD_ADDR_VAR 0 3
49250: PUSH
49251: LD_INT 11
49253: PUSH
49254: LD_INT 12
49256: PUSH
49257: LD_INT 13
49259: PUSH
49260: LD_INT 14
49262: PUSH
49263: LD_INT 1
49265: PUSH
49266: LD_INT 2
49268: PUSH
49269: LD_INT 3
49271: PUSH
49272: EMPTY
49273: LIST
49274: LIST
49275: LIST
49276: LIST
49277: LIST
49278: LIST
49279: LIST
49280: ST_TO_ADDR
49281: GO 49412
49283: LD_INT 1
49285: DOUBLE
49286: EQUAL
49287: IFTRUE 49291
49289: GO 49353
49291: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
49292: LD_ADDR_VAR 0 3
49296: PUSH
49297: LD_INT 11
49299: PUSH
49300: LD_INT 12
49302: PUSH
49303: LD_INT 13
49305: PUSH
49306: LD_INT 14
49308: PUSH
49309: LD_INT 1
49311: PUSH
49312: LD_INT 2
49314: PUSH
49315: LD_INT 3
49317: PUSH
49318: LD_INT 4
49320: PUSH
49321: LD_INT 5
49323: PUSH
49324: LD_INT 21
49326: PUSH
49327: LD_INT 23
49329: PUSH
49330: LD_INT 22
49332: PUSH
49333: LD_INT 24
49335: PUSH
49336: EMPTY
49337: LIST
49338: LIST
49339: LIST
49340: LIST
49341: LIST
49342: LIST
49343: LIST
49344: LIST
49345: LIST
49346: LIST
49347: LIST
49348: LIST
49349: LIST
49350: ST_TO_ADDR
49351: GO 49412
49353: LD_INT 3
49355: DOUBLE
49356: EQUAL
49357: IFTRUE 49361
49359: GO 49411
49361: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
49362: LD_ADDR_VAR 0 3
49366: PUSH
49367: LD_INT 13
49369: PUSH
49370: LD_INT 14
49372: PUSH
49373: LD_INT 2
49375: PUSH
49376: LD_INT 3
49378: PUSH
49379: LD_INT 4
49381: PUSH
49382: LD_INT 5
49384: PUSH
49385: LD_INT 21
49387: PUSH
49388: LD_INT 22
49390: PUSH
49391: LD_INT 23
49393: PUSH
49394: LD_INT 24
49396: PUSH
49397: EMPTY
49398: LIST
49399: LIST
49400: LIST
49401: LIST
49402: LIST
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: ST_TO_ADDR
49409: GO 49412
49411: POP
// result := ( chassis in result ) ;
49412: LD_ADDR_VAR 0 3
49416: PUSH
49417: LD_VAR 0 1
49421: PUSH
49422: LD_VAR 0 3
49426: IN
49427: ST_TO_ADDR
// end ;
49428: LD_VAR 0 3
49432: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
49433: LD_INT 0
49435: PPUSH
// if not chassis or not weapon then
49436: LD_VAR 0 1
49440: NOT
49441: PUSH
49442: LD_VAR 0 2
49446: NOT
49447: OR
49448: IFFALSE 49452
// exit ;
49450: GO 50478
// case weapon of us_machine_gun :
49452: LD_VAR 0 2
49456: PUSH
49457: LD_INT 2
49459: DOUBLE
49460: EQUAL
49461: IFTRUE 49465
49463: GO 49495
49465: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
49466: LD_ADDR_VAR 0 3
49470: PUSH
49471: LD_INT 1
49473: PUSH
49474: LD_INT 2
49476: PUSH
49477: LD_INT 3
49479: PUSH
49480: LD_INT 4
49482: PUSH
49483: LD_INT 5
49485: PUSH
49486: EMPTY
49487: LIST
49488: LIST
49489: LIST
49490: LIST
49491: LIST
49492: ST_TO_ADDR
49493: GO 50462
49495: LD_INT 3
49497: DOUBLE
49498: EQUAL
49499: IFTRUE 49503
49501: GO 49533
49503: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
49504: LD_ADDR_VAR 0 3
49508: PUSH
49509: LD_INT 1
49511: PUSH
49512: LD_INT 2
49514: PUSH
49515: LD_INT 3
49517: PUSH
49518: LD_INT 4
49520: PUSH
49521: LD_INT 5
49523: PUSH
49524: EMPTY
49525: LIST
49526: LIST
49527: LIST
49528: LIST
49529: LIST
49530: ST_TO_ADDR
49531: GO 50462
49533: LD_INT 11
49535: DOUBLE
49536: EQUAL
49537: IFTRUE 49541
49539: GO 49571
49541: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
49542: LD_ADDR_VAR 0 3
49546: PUSH
49547: LD_INT 1
49549: PUSH
49550: LD_INT 2
49552: PUSH
49553: LD_INT 3
49555: PUSH
49556: LD_INT 4
49558: PUSH
49559: LD_INT 5
49561: PUSH
49562: EMPTY
49563: LIST
49564: LIST
49565: LIST
49566: LIST
49567: LIST
49568: ST_TO_ADDR
49569: GO 50462
49571: LD_INT 4
49573: DOUBLE
49574: EQUAL
49575: IFTRUE 49579
49577: GO 49605
49579: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
49580: LD_ADDR_VAR 0 3
49584: PUSH
49585: LD_INT 2
49587: PUSH
49588: LD_INT 3
49590: PUSH
49591: LD_INT 4
49593: PUSH
49594: LD_INT 5
49596: PUSH
49597: EMPTY
49598: LIST
49599: LIST
49600: LIST
49601: LIST
49602: ST_TO_ADDR
49603: GO 50462
49605: LD_INT 5
49607: DOUBLE
49608: EQUAL
49609: IFTRUE 49613
49611: GO 49639
49613: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
49614: LD_ADDR_VAR 0 3
49618: PUSH
49619: LD_INT 2
49621: PUSH
49622: LD_INT 3
49624: PUSH
49625: LD_INT 4
49627: PUSH
49628: LD_INT 5
49630: PUSH
49631: EMPTY
49632: LIST
49633: LIST
49634: LIST
49635: LIST
49636: ST_TO_ADDR
49637: GO 50462
49639: LD_INT 9
49641: DOUBLE
49642: EQUAL
49643: IFTRUE 49647
49645: GO 49673
49647: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
49648: LD_ADDR_VAR 0 3
49652: PUSH
49653: LD_INT 2
49655: PUSH
49656: LD_INT 3
49658: PUSH
49659: LD_INT 4
49661: PUSH
49662: LD_INT 5
49664: PUSH
49665: EMPTY
49666: LIST
49667: LIST
49668: LIST
49669: LIST
49670: ST_TO_ADDR
49671: GO 50462
49673: LD_INT 7
49675: DOUBLE
49676: EQUAL
49677: IFTRUE 49681
49679: GO 49707
49681: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
49682: LD_ADDR_VAR 0 3
49686: PUSH
49687: LD_INT 2
49689: PUSH
49690: LD_INT 3
49692: PUSH
49693: LD_INT 4
49695: PUSH
49696: LD_INT 5
49698: PUSH
49699: EMPTY
49700: LIST
49701: LIST
49702: LIST
49703: LIST
49704: ST_TO_ADDR
49705: GO 50462
49707: LD_INT 12
49709: DOUBLE
49710: EQUAL
49711: IFTRUE 49715
49713: GO 49741
49715: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
49716: LD_ADDR_VAR 0 3
49720: PUSH
49721: LD_INT 2
49723: PUSH
49724: LD_INT 3
49726: PUSH
49727: LD_INT 4
49729: PUSH
49730: LD_INT 5
49732: PUSH
49733: EMPTY
49734: LIST
49735: LIST
49736: LIST
49737: LIST
49738: ST_TO_ADDR
49739: GO 50462
49741: LD_INT 13
49743: DOUBLE
49744: EQUAL
49745: IFTRUE 49749
49747: GO 49775
49749: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
49750: LD_ADDR_VAR 0 3
49754: PUSH
49755: LD_INT 2
49757: PUSH
49758: LD_INT 3
49760: PUSH
49761: LD_INT 4
49763: PUSH
49764: LD_INT 5
49766: PUSH
49767: EMPTY
49768: LIST
49769: LIST
49770: LIST
49771: LIST
49772: ST_TO_ADDR
49773: GO 50462
49775: LD_INT 14
49777: DOUBLE
49778: EQUAL
49779: IFTRUE 49783
49781: GO 49801
49783: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
49784: LD_ADDR_VAR 0 3
49788: PUSH
49789: LD_INT 4
49791: PUSH
49792: LD_INT 5
49794: PUSH
49795: EMPTY
49796: LIST
49797: LIST
49798: ST_TO_ADDR
49799: GO 50462
49801: LD_INT 6
49803: DOUBLE
49804: EQUAL
49805: IFTRUE 49809
49807: GO 49827
49809: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
49810: LD_ADDR_VAR 0 3
49814: PUSH
49815: LD_INT 4
49817: PUSH
49818: LD_INT 5
49820: PUSH
49821: EMPTY
49822: LIST
49823: LIST
49824: ST_TO_ADDR
49825: GO 50462
49827: LD_INT 10
49829: DOUBLE
49830: EQUAL
49831: IFTRUE 49835
49833: GO 49853
49835: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
49836: LD_ADDR_VAR 0 3
49840: PUSH
49841: LD_INT 4
49843: PUSH
49844: LD_INT 5
49846: PUSH
49847: EMPTY
49848: LIST
49849: LIST
49850: ST_TO_ADDR
49851: GO 50462
49853: LD_INT 22
49855: DOUBLE
49856: EQUAL
49857: IFTRUE 49861
49859: GO 49887
49861: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
49862: LD_ADDR_VAR 0 3
49866: PUSH
49867: LD_INT 11
49869: PUSH
49870: LD_INT 12
49872: PUSH
49873: LD_INT 13
49875: PUSH
49876: LD_INT 14
49878: PUSH
49879: EMPTY
49880: LIST
49881: LIST
49882: LIST
49883: LIST
49884: ST_TO_ADDR
49885: GO 50462
49887: LD_INT 23
49889: DOUBLE
49890: EQUAL
49891: IFTRUE 49895
49893: GO 49921
49895: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
49896: LD_ADDR_VAR 0 3
49900: PUSH
49901: LD_INT 11
49903: PUSH
49904: LD_INT 12
49906: PUSH
49907: LD_INT 13
49909: PUSH
49910: LD_INT 14
49912: PUSH
49913: EMPTY
49914: LIST
49915: LIST
49916: LIST
49917: LIST
49918: ST_TO_ADDR
49919: GO 50462
49921: LD_INT 24
49923: DOUBLE
49924: EQUAL
49925: IFTRUE 49929
49927: GO 49955
49929: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
49930: LD_ADDR_VAR 0 3
49934: PUSH
49935: LD_INT 11
49937: PUSH
49938: LD_INT 12
49940: PUSH
49941: LD_INT 13
49943: PUSH
49944: LD_INT 14
49946: PUSH
49947: EMPTY
49948: LIST
49949: LIST
49950: LIST
49951: LIST
49952: ST_TO_ADDR
49953: GO 50462
49955: LD_INT 30
49957: DOUBLE
49958: EQUAL
49959: IFTRUE 49963
49961: GO 49989
49963: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
49964: LD_ADDR_VAR 0 3
49968: PUSH
49969: LD_INT 11
49971: PUSH
49972: LD_INT 12
49974: PUSH
49975: LD_INT 13
49977: PUSH
49978: LD_INT 14
49980: PUSH
49981: EMPTY
49982: LIST
49983: LIST
49984: LIST
49985: LIST
49986: ST_TO_ADDR
49987: GO 50462
49989: LD_INT 25
49991: DOUBLE
49992: EQUAL
49993: IFTRUE 49997
49995: GO 50015
49997: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
49998: LD_ADDR_VAR 0 3
50002: PUSH
50003: LD_INT 13
50005: PUSH
50006: LD_INT 14
50008: PUSH
50009: EMPTY
50010: LIST
50011: LIST
50012: ST_TO_ADDR
50013: GO 50462
50015: LD_INT 27
50017: DOUBLE
50018: EQUAL
50019: IFTRUE 50023
50021: GO 50041
50023: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
50024: LD_ADDR_VAR 0 3
50028: PUSH
50029: LD_INT 13
50031: PUSH
50032: LD_INT 14
50034: PUSH
50035: EMPTY
50036: LIST
50037: LIST
50038: ST_TO_ADDR
50039: GO 50462
50041: LD_INT 28
50043: DOUBLE
50044: EQUAL
50045: IFTRUE 50049
50047: GO 50067
50049: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
50050: LD_ADDR_VAR 0 3
50054: PUSH
50055: LD_INT 13
50057: PUSH
50058: LD_INT 14
50060: PUSH
50061: EMPTY
50062: LIST
50063: LIST
50064: ST_TO_ADDR
50065: GO 50462
50067: LD_INT 29
50069: DOUBLE
50070: EQUAL
50071: IFTRUE 50075
50073: GO 50093
50075: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
50076: LD_ADDR_VAR 0 3
50080: PUSH
50081: LD_INT 13
50083: PUSH
50084: LD_INT 14
50086: PUSH
50087: EMPTY
50088: LIST
50089: LIST
50090: ST_TO_ADDR
50091: GO 50462
50093: LD_INT 31
50095: DOUBLE
50096: EQUAL
50097: IFTRUE 50101
50099: GO 50119
50101: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
50102: LD_ADDR_VAR 0 3
50106: PUSH
50107: LD_INT 13
50109: PUSH
50110: LD_INT 14
50112: PUSH
50113: EMPTY
50114: LIST
50115: LIST
50116: ST_TO_ADDR
50117: GO 50462
50119: LD_INT 26
50121: DOUBLE
50122: EQUAL
50123: IFTRUE 50127
50125: GO 50145
50127: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
50128: LD_ADDR_VAR 0 3
50132: PUSH
50133: LD_INT 13
50135: PUSH
50136: LD_INT 14
50138: PUSH
50139: EMPTY
50140: LIST
50141: LIST
50142: ST_TO_ADDR
50143: GO 50462
50145: LD_INT 42
50147: DOUBLE
50148: EQUAL
50149: IFTRUE 50153
50151: GO 50179
50153: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
50154: LD_ADDR_VAR 0 3
50158: PUSH
50159: LD_INT 21
50161: PUSH
50162: LD_INT 22
50164: PUSH
50165: LD_INT 23
50167: PUSH
50168: LD_INT 24
50170: PUSH
50171: EMPTY
50172: LIST
50173: LIST
50174: LIST
50175: LIST
50176: ST_TO_ADDR
50177: GO 50462
50179: LD_INT 43
50181: DOUBLE
50182: EQUAL
50183: IFTRUE 50187
50185: GO 50213
50187: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
50188: LD_ADDR_VAR 0 3
50192: PUSH
50193: LD_INT 21
50195: PUSH
50196: LD_INT 22
50198: PUSH
50199: LD_INT 23
50201: PUSH
50202: LD_INT 24
50204: PUSH
50205: EMPTY
50206: LIST
50207: LIST
50208: LIST
50209: LIST
50210: ST_TO_ADDR
50211: GO 50462
50213: LD_INT 44
50215: DOUBLE
50216: EQUAL
50217: IFTRUE 50221
50219: GO 50247
50221: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
50222: LD_ADDR_VAR 0 3
50226: PUSH
50227: LD_INT 21
50229: PUSH
50230: LD_INT 22
50232: PUSH
50233: LD_INT 23
50235: PUSH
50236: LD_INT 24
50238: PUSH
50239: EMPTY
50240: LIST
50241: LIST
50242: LIST
50243: LIST
50244: ST_TO_ADDR
50245: GO 50462
50247: LD_INT 45
50249: DOUBLE
50250: EQUAL
50251: IFTRUE 50255
50253: GO 50281
50255: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
50256: LD_ADDR_VAR 0 3
50260: PUSH
50261: LD_INT 21
50263: PUSH
50264: LD_INT 22
50266: PUSH
50267: LD_INT 23
50269: PUSH
50270: LD_INT 24
50272: PUSH
50273: EMPTY
50274: LIST
50275: LIST
50276: LIST
50277: LIST
50278: ST_TO_ADDR
50279: GO 50462
50281: LD_INT 49
50283: DOUBLE
50284: EQUAL
50285: IFTRUE 50289
50287: GO 50315
50289: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
50290: LD_ADDR_VAR 0 3
50294: PUSH
50295: LD_INT 21
50297: PUSH
50298: LD_INT 22
50300: PUSH
50301: LD_INT 23
50303: PUSH
50304: LD_INT 24
50306: PUSH
50307: EMPTY
50308: LIST
50309: LIST
50310: LIST
50311: LIST
50312: ST_TO_ADDR
50313: GO 50462
50315: LD_INT 51
50317: DOUBLE
50318: EQUAL
50319: IFTRUE 50323
50321: GO 50349
50323: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
50324: LD_ADDR_VAR 0 3
50328: PUSH
50329: LD_INT 21
50331: PUSH
50332: LD_INT 22
50334: PUSH
50335: LD_INT 23
50337: PUSH
50338: LD_INT 24
50340: PUSH
50341: EMPTY
50342: LIST
50343: LIST
50344: LIST
50345: LIST
50346: ST_TO_ADDR
50347: GO 50462
50349: LD_INT 52
50351: DOUBLE
50352: EQUAL
50353: IFTRUE 50357
50355: GO 50383
50357: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
50358: LD_ADDR_VAR 0 3
50362: PUSH
50363: LD_INT 21
50365: PUSH
50366: LD_INT 22
50368: PUSH
50369: LD_INT 23
50371: PUSH
50372: LD_INT 24
50374: PUSH
50375: EMPTY
50376: LIST
50377: LIST
50378: LIST
50379: LIST
50380: ST_TO_ADDR
50381: GO 50462
50383: LD_INT 53
50385: DOUBLE
50386: EQUAL
50387: IFTRUE 50391
50389: GO 50409
50391: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
50392: LD_ADDR_VAR 0 3
50396: PUSH
50397: LD_INT 23
50399: PUSH
50400: LD_INT 24
50402: PUSH
50403: EMPTY
50404: LIST
50405: LIST
50406: ST_TO_ADDR
50407: GO 50462
50409: LD_INT 46
50411: DOUBLE
50412: EQUAL
50413: IFTRUE 50417
50415: GO 50435
50417: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
50418: LD_ADDR_VAR 0 3
50422: PUSH
50423: LD_INT 23
50425: PUSH
50426: LD_INT 24
50428: PUSH
50429: EMPTY
50430: LIST
50431: LIST
50432: ST_TO_ADDR
50433: GO 50462
50435: LD_INT 47
50437: DOUBLE
50438: EQUAL
50439: IFTRUE 50443
50441: GO 50461
50443: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
50444: LD_ADDR_VAR 0 3
50448: PUSH
50449: LD_INT 23
50451: PUSH
50452: LD_INT 24
50454: PUSH
50455: EMPTY
50456: LIST
50457: LIST
50458: ST_TO_ADDR
50459: GO 50462
50461: POP
// result := ( chassis in result ) ;
50462: LD_ADDR_VAR 0 3
50466: PUSH
50467: LD_VAR 0 1
50471: PUSH
50472: LD_VAR 0 3
50476: IN
50477: ST_TO_ADDR
// end ;
50478: LD_VAR 0 3
50482: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
50483: LD_INT 0
50485: PPUSH
50486: PPUSH
50487: PPUSH
50488: PPUSH
50489: PPUSH
50490: PPUSH
50491: PPUSH
// result := array ;
50492: LD_ADDR_VAR 0 5
50496: PUSH
50497: LD_VAR 0 1
50501: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
50502: LD_VAR 0 1
50506: NOT
50507: PUSH
50508: LD_VAR 0 2
50512: NOT
50513: OR
50514: PUSH
50515: LD_VAR 0 3
50519: NOT
50520: OR
50521: PUSH
50522: LD_VAR 0 2
50526: PUSH
50527: LD_VAR 0 1
50531: GREATER
50532: OR
50533: PUSH
50534: LD_VAR 0 3
50538: PUSH
50539: LD_VAR 0 1
50543: GREATER
50544: OR
50545: IFFALSE 50549
// exit ;
50547: GO 50845
// if direction then
50549: LD_VAR 0 4
50553: IFFALSE 50617
// begin d := 1 ;
50555: LD_ADDR_VAR 0 9
50559: PUSH
50560: LD_INT 1
50562: ST_TO_ADDR
// if i_from > i_to then
50563: LD_VAR 0 2
50567: PUSH
50568: LD_VAR 0 3
50572: GREATER
50573: IFFALSE 50599
// length := ( array - i_from ) + i_to else
50575: LD_ADDR_VAR 0 11
50579: PUSH
50580: LD_VAR 0 1
50584: PUSH
50585: LD_VAR 0 2
50589: MINUS
50590: PUSH
50591: LD_VAR 0 3
50595: PLUS
50596: ST_TO_ADDR
50597: GO 50615
// length := i_to - i_from ;
50599: LD_ADDR_VAR 0 11
50603: PUSH
50604: LD_VAR 0 3
50608: PUSH
50609: LD_VAR 0 2
50613: MINUS
50614: ST_TO_ADDR
// end else
50615: GO 50678
// begin d := - 1 ;
50617: LD_ADDR_VAR 0 9
50621: PUSH
50622: LD_INT 1
50624: NEG
50625: ST_TO_ADDR
// if i_from > i_to then
50626: LD_VAR 0 2
50630: PUSH
50631: LD_VAR 0 3
50635: GREATER
50636: IFFALSE 50656
// length := i_from - i_to else
50638: LD_ADDR_VAR 0 11
50642: PUSH
50643: LD_VAR 0 2
50647: PUSH
50648: LD_VAR 0 3
50652: MINUS
50653: ST_TO_ADDR
50654: GO 50678
// length := ( array - i_to ) + i_from ;
50656: LD_ADDR_VAR 0 11
50660: PUSH
50661: LD_VAR 0 1
50665: PUSH
50666: LD_VAR 0 3
50670: MINUS
50671: PUSH
50672: LD_VAR 0 2
50676: PLUS
50677: ST_TO_ADDR
// end ; if not length then
50678: LD_VAR 0 11
50682: NOT
50683: IFFALSE 50687
// exit ;
50685: GO 50845
// tmp := array ;
50687: LD_ADDR_VAR 0 10
50691: PUSH
50692: LD_VAR 0 1
50696: ST_TO_ADDR
// for i = 1 to length do
50697: LD_ADDR_VAR 0 6
50701: PUSH
50702: DOUBLE
50703: LD_INT 1
50705: DEC
50706: ST_TO_ADDR
50707: LD_VAR 0 11
50711: PUSH
50712: FOR_TO
50713: IFFALSE 50833
// begin for j = 1 to array do
50715: LD_ADDR_VAR 0 7
50719: PUSH
50720: DOUBLE
50721: LD_INT 1
50723: DEC
50724: ST_TO_ADDR
50725: LD_VAR 0 1
50729: PUSH
50730: FOR_TO
50731: IFFALSE 50819
// begin k := j + d ;
50733: LD_ADDR_VAR 0 8
50737: PUSH
50738: LD_VAR 0 7
50742: PUSH
50743: LD_VAR 0 9
50747: PLUS
50748: ST_TO_ADDR
// if k > array then
50749: LD_VAR 0 8
50753: PUSH
50754: LD_VAR 0 1
50758: GREATER
50759: IFFALSE 50769
// k := 1 ;
50761: LD_ADDR_VAR 0 8
50765: PUSH
50766: LD_INT 1
50768: ST_TO_ADDR
// if not k then
50769: LD_VAR 0 8
50773: NOT
50774: IFFALSE 50786
// k := array ;
50776: LD_ADDR_VAR 0 8
50780: PUSH
50781: LD_VAR 0 1
50785: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
50786: LD_ADDR_VAR 0 10
50790: PUSH
50791: LD_VAR 0 10
50795: PPUSH
50796: LD_VAR 0 8
50800: PPUSH
50801: LD_VAR 0 1
50805: PUSH
50806: LD_VAR 0 7
50810: ARRAY
50811: PPUSH
50812: CALL_OW 1
50816: ST_TO_ADDR
// end ;
50817: GO 50730
50819: POP
50820: POP
// array := tmp ;
50821: LD_ADDR_VAR 0 1
50825: PUSH
50826: LD_VAR 0 10
50830: ST_TO_ADDR
// end ;
50831: GO 50712
50833: POP
50834: POP
// result := array ;
50835: LD_ADDR_VAR 0 5
50839: PUSH
50840: LD_VAR 0 1
50844: ST_TO_ADDR
// end ;
50845: LD_VAR 0 5
50849: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
50850: LD_INT 0
50852: PPUSH
50853: PPUSH
// result := 0 ;
50854: LD_ADDR_VAR 0 3
50858: PUSH
50859: LD_INT 0
50861: ST_TO_ADDR
// if not array or not value in array then
50862: LD_VAR 0 1
50866: NOT
50867: PUSH
50868: LD_VAR 0 2
50872: PUSH
50873: LD_VAR 0 1
50877: IN
50878: NOT
50879: OR
50880: IFFALSE 50884
// exit ;
50882: GO 50938
// for i = 1 to array do
50884: LD_ADDR_VAR 0 4
50888: PUSH
50889: DOUBLE
50890: LD_INT 1
50892: DEC
50893: ST_TO_ADDR
50894: LD_VAR 0 1
50898: PUSH
50899: FOR_TO
50900: IFFALSE 50936
// if value = array [ i ] then
50902: LD_VAR 0 2
50906: PUSH
50907: LD_VAR 0 1
50911: PUSH
50912: LD_VAR 0 4
50916: ARRAY
50917: EQUAL
50918: IFFALSE 50934
// begin result := i ;
50920: LD_ADDR_VAR 0 3
50924: PUSH
50925: LD_VAR 0 4
50929: ST_TO_ADDR
// exit ;
50930: POP
50931: POP
50932: GO 50938
// end ;
50934: GO 50899
50936: POP
50937: POP
// end ;
50938: LD_VAR 0 3
50942: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
50943: LD_INT 0
50945: PPUSH
// vc_chassis := chassis ;
50946: LD_ADDR_OWVAR 37
50950: PUSH
50951: LD_VAR 0 1
50955: ST_TO_ADDR
// vc_engine := engine ;
50956: LD_ADDR_OWVAR 39
50960: PUSH
50961: LD_VAR 0 2
50965: ST_TO_ADDR
// vc_control := control ;
50966: LD_ADDR_OWVAR 38
50970: PUSH
50971: LD_VAR 0 3
50975: ST_TO_ADDR
// vc_weapon := weapon ;
50976: LD_ADDR_OWVAR 40
50980: PUSH
50981: LD_VAR 0 4
50985: ST_TO_ADDR
// vc_fuel_battery := fuel ;
50986: LD_ADDR_OWVAR 41
50990: PUSH
50991: LD_VAR 0 5
50995: ST_TO_ADDR
// end ;
50996: LD_VAR 0 6
51000: RET
// export function WantPlant ( unit ) ; var task ; begin
51001: LD_INT 0
51003: PPUSH
51004: PPUSH
// result := false ;
51005: LD_ADDR_VAR 0 2
51009: PUSH
51010: LD_INT 0
51012: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
51013: LD_ADDR_VAR 0 3
51017: PUSH
51018: LD_VAR 0 1
51022: PPUSH
51023: CALL_OW 437
51027: ST_TO_ADDR
// if task then
51028: LD_VAR 0 3
51032: IFFALSE 51060
// if task [ 1 ] [ 1 ] = p then
51034: LD_VAR 0 3
51038: PUSH
51039: LD_INT 1
51041: ARRAY
51042: PUSH
51043: LD_INT 1
51045: ARRAY
51046: PUSH
51047: LD_STRING p
51049: EQUAL
51050: IFFALSE 51060
// result := true ;
51052: LD_ADDR_VAR 0 2
51056: PUSH
51057: LD_INT 1
51059: ST_TO_ADDR
// end ;
51060: LD_VAR 0 2
51064: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
51065: LD_INT 0
51067: PPUSH
51068: PPUSH
51069: PPUSH
51070: PPUSH
// if pos < 1 then
51071: LD_VAR 0 2
51075: PUSH
51076: LD_INT 1
51078: LESS
51079: IFFALSE 51083
// exit ;
51081: GO 51386
// if pos = 1 then
51083: LD_VAR 0 2
51087: PUSH
51088: LD_INT 1
51090: EQUAL
51091: IFFALSE 51124
// result := Replace ( arr , pos [ 1 ] , value ) else
51093: LD_ADDR_VAR 0 4
51097: PUSH
51098: LD_VAR 0 1
51102: PPUSH
51103: LD_VAR 0 2
51107: PUSH
51108: LD_INT 1
51110: ARRAY
51111: PPUSH
51112: LD_VAR 0 3
51116: PPUSH
51117: CALL_OW 1
51121: ST_TO_ADDR
51122: GO 51386
// begin tmp := arr ;
51124: LD_ADDR_VAR 0 6
51128: PUSH
51129: LD_VAR 0 1
51133: ST_TO_ADDR
// s_arr := [ tmp ] ;
51134: LD_ADDR_VAR 0 7
51138: PUSH
51139: LD_VAR 0 6
51143: PUSH
51144: EMPTY
51145: LIST
51146: ST_TO_ADDR
// for i = 1 to pos - 1 do
51147: LD_ADDR_VAR 0 5
51151: PUSH
51152: DOUBLE
51153: LD_INT 1
51155: DEC
51156: ST_TO_ADDR
51157: LD_VAR 0 2
51161: PUSH
51162: LD_INT 1
51164: MINUS
51165: PUSH
51166: FOR_TO
51167: IFFALSE 51212
// begin tmp := tmp [ pos [ i ] ] ;
51169: LD_ADDR_VAR 0 6
51173: PUSH
51174: LD_VAR 0 6
51178: PUSH
51179: LD_VAR 0 2
51183: PUSH
51184: LD_VAR 0 5
51188: ARRAY
51189: ARRAY
51190: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
51191: LD_ADDR_VAR 0 7
51195: PUSH
51196: LD_VAR 0 7
51200: PUSH
51201: LD_VAR 0 6
51205: PUSH
51206: EMPTY
51207: LIST
51208: ADD
51209: ST_TO_ADDR
// end ;
51210: GO 51166
51212: POP
51213: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
51214: LD_ADDR_VAR 0 6
51218: PUSH
51219: LD_VAR 0 6
51223: PPUSH
51224: LD_VAR 0 2
51228: PUSH
51229: LD_VAR 0 2
51233: ARRAY
51234: PPUSH
51235: LD_VAR 0 3
51239: PPUSH
51240: CALL_OW 1
51244: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
51245: LD_ADDR_VAR 0 7
51249: PUSH
51250: LD_VAR 0 7
51254: PPUSH
51255: LD_VAR 0 7
51259: PPUSH
51260: LD_VAR 0 6
51264: PPUSH
51265: CALL_OW 1
51269: ST_TO_ADDR
// for i = s_arr downto 2 do
51270: LD_ADDR_VAR 0 5
51274: PUSH
51275: DOUBLE
51276: LD_VAR 0 7
51280: INC
51281: ST_TO_ADDR
51282: LD_INT 2
51284: PUSH
51285: FOR_DOWNTO
51286: IFFALSE 51370
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
51288: LD_ADDR_VAR 0 6
51292: PUSH
51293: LD_VAR 0 7
51297: PUSH
51298: LD_VAR 0 5
51302: PUSH
51303: LD_INT 1
51305: MINUS
51306: ARRAY
51307: PPUSH
51308: LD_VAR 0 2
51312: PUSH
51313: LD_VAR 0 5
51317: PUSH
51318: LD_INT 1
51320: MINUS
51321: ARRAY
51322: PPUSH
51323: LD_VAR 0 7
51327: PUSH
51328: LD_VAR 0 5
51332: ARRAY
51333: PPUSH
51334: CALL_OW 1
51338: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
51339: LD_ADDR_VAR 0 7
51343: PUSH
51344: LD_VAR 0 7
51348: PPUSH
51349: LD_VAR 0 5
51353: PUSH
51354: LD_INT 1
51356: MINUS
51357: PPUSH
51358: LD_VAR 0 6
51362: PPUSH
51363: CALL_OW 1
51367: ST_TO_ADDR
// end ;
51368: GO 51285
51370: POP
51371: POP
// result := s_arr [ 1 ] ;
51372: LD_ADDR_VAR 0 4
51376: PUSH
51377: LD_VAR 0 7
51381: PUSH
51382: LD_INT 1
51384: ARRAY
51385: ST_TO_ADDR
// end ; end ;
51386: LD_VAR 0 4
51390: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
51391: LD_INT 0
51393: PPUSH
51394: PPUSH
// if not list then
51395: LD_VAR 0 1
51399: NOT
51400: IFFALSE 51404
// exit ;
51402: GO 51495
// i := list [ pos1 ] ;
51404: LD_ADDR_VAR 0 5
51408: PUSH
51409: LD_VAR 0 1
51413: PUSH
51414: LD_VAR 0 2
51418: ARRAY
51419: ST_TO_ADDR
// if not i then
51420: LD_VAR 0 5
51424: NOT
51425: IFFALSE 51429
// exit ;
51427: GO 51495
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
51429: LD_ADDR_VAR 0 1
51433: PUSH
51434: LD_VAR 0 1
51438: PPUSH
51439: LD_VAR 0 2
51443: PPUSH
51444: LD_VAR 0 1
51448: PUSH
51449: LD_VAR 0 3
51453: ARRAY
51454: PPUSH
51455: CALL_OW 1
51459: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
51460: LD_ADDR_VAR 0 1
51464: PUSH
51465: LD_VAR 0 1
51469: PPUSH
51470: LD_VAR 0 3
51474: PPUSH
51475: LD_VAR 0 5
51479: PPUSH
51480: CALL_OW 1
51484: ST_TO_ADDR
// result := list ;
51485: LD_ADDR_VAR 0 4
51489: PUSH
51490: LD_VAR 0 1
51494: ST_TO_ADDR
// end ;
51495: LD_VAR 0 4
51499: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
51500: LD_INT 0
51502: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
51503: LD_ADDR_VAR 0 5
51507: PUSH
51508: LD_VAR 0 1
51512: PPUSH
51513: CALL_OW 250
51517: PPUSH
51518: LD_VAR 0 1
51522: PPUSH
51523: CALL_OW 251
51527: PPUSH
51528: LD_VAR 0 2
51532: PPUSH
51533: LD_VAR 0 3
51537: PPUSH
51538: LD_VAR 0 4
51542: PPUSH
51543: CALL 51553 0 5
51547: ST_TO_ADDR
// end ;
51548: LD_VAR 0 5
51552: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
51553: LD_INT 0
51555: PPUSH
51556: PPUSH
51557: PPUSH
51558: PPUSH
// if not list then
51559: LD_VAR 0 3
51563: NOT
51564: IFFALSE 51568
// exit ;
51566: GO 51956
// result := [ ] ;
51568: LD_ADDR_VAR 0 6
51572: PUSH
51573: EMPTY
51574: ST_TO_ADDR
// for i in list do
51575: LD_ADDR_VAR 0 7
51579: PUSH
51580: LD_VAR 0 3
51584: PUSH
51585: FOR_IN
51586: IFFALSE 51788
// begin tmp := GetDistUnitXY ( i , x , y ) ;
51588: LD_ADDR_VAR 0 9
51592: PUSH
51593: LD_VAR 0 7
51597: PPUSH
51598: LD_VAR 0 1
51602: PPUSH
51603: LD_VAR 0 2
51607: PPUSH
51608: CALL_OW 297
51612: ST_TO_ADDR
// if not result then
51613: LD_VAR 0 6
51617: NOT
51618: IFFALSE 51644
// result := [ [ i , tmp ] ] else
51620: LD_ADDR_VAR 0 6
51624: PUSH
51625: LD_VAR 0 7
51629: PUSH
51630: LD_VAR 0 9
51634: PUSH
51635: EMPTY
51636: LIST
51637: LIST
51638: PUSH
51639: EMPTY
51640: LIST
51641: ST_TO_ADDR
51642: GO 51786
// begin if result [ result ] [ 2 ] < tmp then
51644: LD_VAR 0 6
51648: PUSH
51649: LD_VAR 0 6
51653: ARRAY
51654: PUSH
51655: LD_INT 2
51657: ARRAY
51658: PUSH
51659: LD_VAR 0 9
51663: LESS
51664: IFFALSE 51706
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
51666: LD_ADDR_VAR 0 6
51670: PUSH
51671: LD_VAR 0 6
51675: PPUSH
51676: LD_VAR 0 6
51680: PUSH
51681: LD_INT 1
51683: PLUS
51684: PPUSH
51685: LD_VAR 0 7
51689: PUSH
51690: LD_VAR 0 9
51694: PUSH
51695: EMPTY
51696: LIST
51697: LIST
51698: PPUSH
51699: CALL_OW 2
51703: ST_TO_ADDR
51704: GO 51786
// for j = 1 to result do
51706: LD_ADDR_VAR 0 8
51710: PUSH
51711: DOUBLE
51712: LD_INT 1
51714: DEC
51715: ST_TO_ADDR
51716: LD_VAR 0 6
51720: PUSH
51721: FOR_TO
51722: IFFALSE 51784
// begin if tmp < result [ j ] [ 2 ] then
51724: LD_VAR 0 9
51728: PUSH
51729: LD_VAR 0 6
51733: PUSH
51734: LD_VAR 0 8
51738: ARRAY
51739: PUSH
51740: LD_INT 2
51742: ARRAY
51743: LESS
51744: IFFALSE 51782
// begin result := Insert ( result , j , [ i , tmp ] ) ;
51746: LD_ADDR_VAR 0 6
51750: PUSH
51751: LD_VAR 0 6
51755: PPUSH
51756: LD_VAR 0 8
51760: PPUSH
51761: LD_VAR 0 7
51765: PUSH
51766: LD_VAR 0 9
51770: PUSH
51771: EMPTY
51772: LIST
51773: LIST
51774: PPUSH
51775: CALL_OW 2
51779: ST_TO_ADDR
// break ;
51780: GO 51784
// end ; end ;
51782: GO 51721
51784: POP
51785: POP
// end ; end ;
51786: GO 51585
51788: POP
51789: POP
// if result and not asc then
51790: LD_VAR 0 6
51794: PUSH
51795: LD_VAR 0 4
51799: NOT
51800: AND
51801: IFFALSE 51876
// begin tmp := result ;
51803: LD_ADDR_VAR 0 9
51807: PUSH
51808: LD_VAR 0 6
51812: ST_TO_ADDR
// for i = tmp downto 1 do
51813: LD_ADDR_VAR 0 7
51817: PUSH
51818: DOUBLE
51819: LD_VAR 0 9
51823: INC
51824: ST_TO_ADDR
51825: LD_INT 1
51827: PUSH
51828: FOR_DOWNTO
51829: IFFALSE 51874
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
51831: LD_ADDR_VAR 0 6
51835: PUSH
51836: LD_VAR 0 6
51840: PPUSH
51841: LD_VAR 0 9
51845: PUSH
51846: LD_VAR 0 7
51850: MINUS
51851: PUSH
51852: LD_INT 1
51854: PLUS
51855: PPUSH
51856: LD_VAR 0 9
51860: PUSH
51861: LD_VAR 0 7
51865: ARRAY
51866: PPUSH
51867: CALL_OW 1
51871: ST_TO_ADDR
51872: GO 51828
51874: POP
51875: POP
// end ; tmp := [ ] ;
51876: LD_ADDR_VAR 0 9
51880: PUSH
51881: EMPTY
51882: ST_TO_ADDR
// if mode then
51883: LD_VAR 0 5
51887: IFFALSE 51956
// begin for i = 1 to result do
51889: LD_ADDR_VAR 0 7
51893: PUSH
51894: DOUBLE
51895: LD_INT 1
51897: DEC
51898: ST_TO_ADDR
51899: LD_VAR 0 6
51903: PUSH
51904: FOR_TO
51905: IFFALSE 51944
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
51907: LD_ADDR_VAR 0 9
51911: PUSH
51912: LD_VAR 0 9
51916: PPUSH
51917: LD_VAR 0 7
51921: PPUSH
51922: LD_VAR 0 6
51926: PUSH
51927: LD_VAR 0 7
51931: ARRAY
51932: PUSH
51933: LD_INT 1
51935: ARRAY
51936: PPUSH
51937: CALL_OW 1
51941: ST_TO_ADDR
51942: GO 51904
51944: POP
51945: POP
// result := tmp ;
51946: LD_ADDR_VAR 0 6
51950: PUSH
51951: LD_VAR 0 9
51955: ST_TO_ADDR
// end ; end ;
51956: LD_VAR 0 6
51960: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
51961: LD_INT 0
51963: PPUSH
51964: PPUSH
51965: PPUSH
51966: PPUSH
51967: PPUSH
51968: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
51969: LD_ADDR_VAR 0 5
51973: PUSH
51974: LD_INT 0
51976: PUSH
51977: LD_INT 0
51979: PUSH
51980: LD_INT 0
51982: PUSH
51983: EMPTY
51984: PUSH
51985: EMPTY
51986: LIST
51987: LIST
51988: LIST
51989: LIST
51990: ST_TO_ADDR
// if not x or not y then
51991: LD_VAR 0 2
51995: NOT
51996: PUSH
51997: LD_VAR 0 3
52001: NOT
52002: OR
52003: IFFALSE 52007
// exit ;
52005: GO 53653
// if not range then
52007: LD_VAR 0 4
52011: NOT
52012: IFFALSE 52022
// range := 10 ;
52014: LD_ADDR_VAR 0 4
52018: PUSH
52019: LD_INT 10
52021: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52022: LD_ADDR_VAR 0 8
52026: PUSH
52027: LD_INT 81
52029: PUSH
52030: LD_VAR 0 1
52034: PUSH
52035: EMPTY
52036: LIST
52037: LIST
52038: PUSH
52039: LD_INT 92
52041: PUSH
52042: LD_VAR 0 2
52046: PUSH
52047: LD_VAR 0 3
52051: PUSH
52052: LD_VAR 0 4
52056: PUSH
52057: EMPTY
52058: LIST
52059: LIST
52060: LIST
52061: LIST
52062: PUSH
52063: LD_INT 3
52065: PUSH
52066: LD_INT 21
52068: PUSH
52069: LD_INT 3
52071: PUSH
52072: EMPTY
52073: LIST
52074: LIST
52075: PUSH
52076: EMPTY
52077: LIST
52078: LIST
52079: PUSH
52080: EMPTY
52081: LIST
52082: LIST
52083: LIST
52084: PPUSH
52085: CALL_OW 69
52089: ST_TO_ADDR
// if not tmp then
52090: LD_VAR 0 8
52094: NOT
52095: IFFALSE 52099
// exit ;
52097: GO 53653
// for i in tmp do
52099: LD_ADDR_VAR 0 6
52103: PUSH
52104: LD_VAR 0 8
52108: PUSH
52109: FOR_IN
52110: IFFALSE 53628
// begin points := [ 0 , 0 , 0 ] ;
52112: LD_ADDR_VAR 0 9
52116: PUSH
52117: LD_INT 0
52119: PUSH
52120: LD_INT 0
52122: PUSH
52123: LD_INT 0
52125: PUSH
52126: EMPTY
52127: LIST
52128: LIST
52129: LIST
52130: ST_TO_ADDR
// bpoints := 1 ;
52131: LD_ADDR_VAR 0 10
52135: PUSH
52136: LD_INT 1
52138: ST_TO_ADDR
// case GetType ( i ) of unit_human :
52139: LD_VAR 0 6
52143: PPUSH
52144: CALL_OW 247
52148: PUSH
52149: LD_INT 1
52151: DOUBLE
52152: EQUAL
52153: IFTRUE 52157
52155: GO 52735
52157: POP
// begin if GetClass ( i ) = 1 then
52158: LD_VAR 0 6
52162: PPUSH
52163: CALL_OW 257
52167: PUSH
52168: LD_INT 1
52170: EQUAL
52171: IFFALSE 52192
// points := [ 10 , 5 , 3 ] ;
52173: LD_ADDR_VAR 0 9
52177: PUSH
52178: LD_INT 10
52180: PUSH
52181: LD_INT 5
52183: PUSH
52184: LD_INT 3
52186: PUSH
52187: EMPTY
52188: LIST
52189: LIST
52190: LIST
52191: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
52192: LD_VAR 0 6
52196: PPUSH
52197: CALL_OW 257
52201: PUSH
52202: LD_INT 2
52204: PUSH
52205: LD_INT 3
52207: PUSH
52208: LD_INT 4
52210: PUSH
52211: EMPTY
52212: LIST
52213: LIST
52214: LIST
52215: IN
52216: IFFALSE 52237
// points := [ 3 , 2 , 1 ] ;
52218: LD_ADDR_VAR 0 9
52222: PUSH
52223: LD_INT 3
52225: PUSH
52226: LD_INT 2
52228: PUSH
52229: LD_INT 1
52231: PUSH
52232: EMPTY
52233: LIST
52234: LIST
52235: LIST
52236: ST_TO_ADDR
// if GetClass ( i ) = 5 then
52237: LD_VAR 0 6
52241: PPUSH
52242: CALL_OW 257
52246: PUSH
52247: LD_INT 5
52249: EQUAL
52250: IFFALSE 52271
// points := [ 130 , 5 , 2 ] ;
52252: LD_ADDR_VAR 0 9
52256: PUSH
52257: LD_INT 130
52259: PUSH
52260: LD_INT 5
52262: PUSH
52263: LD_INT 2
52265: PUSH
52266: EMPTY
52267: LIST
52268: LIST
52269: LIST
52270: ST_TO_ADDR
// if GetClass ( i ) = 8 then
52271: LD_VAR 0 6
52275: PPUSH
52276: CALL_OW 257
52280: PUSH
52281: LD_INT 8
52283: EQUAL
52284: IFFALSE 52305
// points := [ 35 , 35 , 30 ] ;
52286: LD_ADDR_VAR 0 9
52290: PUSH
52291: LD_INT 35
52293: PUSH
52294: LD_INT 35
52296: PUSH
52297: LD_INT 30
52299: PUSH
52300: EMPTY
52301: LIST
52302: LIST
52303: LIST
52304: ST_TO_ADDR
// if GetClass ( i ) = 9 then
52305: LD_VAR 0 6
52309: PPUSH
52310: CALL_OW 257
52314: PUSH
52315: LD_INT 9
52317: EQUAL
52318: IFFALSE 52339
// points := [ 20 , 55 , 40 ] ;
52320: LD_ADDR_VAR 0 9
52324: PUSH
52325: LD_INT 20
52327: PUSH
52328: LD_INT 55
52330: PUSH
52331: LD_INT 40
52333: PUSH
52334: EMPTY
52335: LIST
52336: LIST
52337: LIST
52338: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
52339: LD_VAR 0 6
52343: PPUSH
52344: CALL_OW 257
52348: PUSH
52349: LD_INT 12
52351: PUSH
52352: LD_INT 16
52354: PUSH
52355: EMPTY
52356: LIST
52357: LIST
52358: IN
52359: IFFALSE 52380
// points := [ 5 , 3 , 2 ] ;
52361: LD_ADDR_VAR 0 9
52365: PUSH
52366: LD_INT 5
52368: PUSH
52369: LD_INT 3
52371: PUSH
52372: LD_INT 2
52374: PUSH
52375: EMPTY
52376: LIST
52377: LIST
52378: LIST
52379: ST_TO_ADDR
// if GetClass ( i ) = 17 then
52380: LD_VAR 0 6
52384: PPUSH
52385: CALL_OW 257
52389: PUSH
52390: LD_INT 17
52392: EQUAL
52393: IFFALSE 52414
// points := [ 100 , 50 , 75 ] ;
52395: LD_ADDR_VAR 0 9
52399: PUSH
52400: LD_INT 100
52402: PUSH
52403: LD_INT 50
52405: PUSH
52406: LD_INT 75
52408: PUSH
52409: EMPTY
52410: LIST
52411: LIST
52412: LIST
52413: ST_TO_ADDR
// if GetClass ( i ) = 15 then
52414: LD_VAR 0 6
52418: PPUSH
52419: CALL_OW 257
52423: PUSH
52424: LD_INT 15
52426: EQUAL
52427: IFFALSE 52448
// points := [ 10 , 5 , 3 ] ;
52429: LD_ADDR_VAR 0 9
52433: PUSH
52434: LD_INT 10
52436: PUSH
52437: LD_INT 5
52439: PUSH
52440: LD_INT 3
52442: PUSH
52443: EMPTY
52444: LIST
52445: LIST
52446: LIST
52447: ST_TO_ADDR
// if GetClass ( i ) = 14 then
52448: LD_VAR 0 6
52452: PPUSH
52453: CALL_OW 257
52457: PUSH
52458: LD_INT 14
52460: EQUAL
52461: IFFALSE 52482
// points := [ 10 , 0 , 0 ] ;
52463: LD_ADDR_VAR 0 9
52467: PUSH
52468: LD_INT 10
52470: PUSH
52471: LD_INT 0
52473: PUSH
52474: LD_INT 0
52476: PUSH
52477: EMPTY
52478: LIST
52479: LIST
52480: LIST
52481: ST_TO_ADDR
// if GetClass ( i ) = 11 then
52482: LD_VAR 0 6
52486: PPUSH
52487: CALL_OW 257
52491: PUSH
52492: LD_INT 11
52494: EQUAL
52495: IFFALSE 52516
// points := [ 30 , 10 , 5 ] ;
52497: LD_ADDR_VAR 0 9
52501: PUSH
52502: LD_INT 30
52504: PUSH
52505: LD_INT 10
52507: PUSH
52508: LD_INT 5
52510: PUSH
52511: EMPTY
52512: LIST
52513: LIST
52514: LIST
52515: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
52516: LD_VAR 0 1
52520: PPUSH
52521: LD_INT 5
52523: PPUSH
52524: CALL_OW 321
52528: PUSH
52529: LD_INT 2
52531: EQUAL
52532: IFFALSE 52549
// bpoints := bpoints * 1.8 ;
52534: LD_ADDR_VAR 0 10
52538: PUSH
52539: LD_VAR 0 10
52543: PUSH
52544: LD_REAL  1.80000000000000E+0000
52547: MUL
52548: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
52549: LD_VAR 0 6
52553: PPUSH
52554: CALL_OW 257
52558: PUSH
52559: LD_INT 1
52561: PUSH
52562: LD_INT 2
52564: PUSH
52565: LD_INT 3
52567: PUSH
52568: LD_INT 4
52570: PUSH
52571: EMPTY
52572: LIST
52573: LIST
52574: LIST
52575: LIST
52576: IN
52577: PUSH
52578: LD_VAR 0 1
52582: PPUSH
52583: LD_INT 51
52585: PPUSH
52586: CALL_OW 321
52590: PUSH
52591: LD_INT 2
52593: EQUAL
52594: AND
52595: IFFALSE 52612
// bpoints := bpoints * 1.2 ;
52597: LD_ADDR_VAR 0 10
52601: PUSH
52602: LD_VAR 0 10
52606: PUSH
52607: LD_REAL  1.20000000000000E+0000
52610: MUL
52611: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
52612: LD_VAR 0 6
52616: PPUSH
52617: CALL_OW 257
52621: PUSH
52622: LD_INT 5
52624: PUSH
52625: LD_INT 7
52627: PUSH
52628: LD_INT 9
52630: PUSH
52631: EMPTY
52632: LIST
52633: LIST
52634: LIST
52635: IN
52636: PUSH
52637: LD_VAR 0 1
52641: PPUSH
52642: LD_INT 52
52644: PPUSH
52645: CALL_OW 321
52649: PUSH
52650: LD_INT 2
52652: EQUAL
52653: AND
52654: IFFALSE 52671
// bpoints := bpoints * 1.5 ;
52656: LD_ADDR_VAR 0 10
52660: PUSH
52661: LD_VAR 0 10
52665: PUSH
52666: LD_REAL  1.50000000000000E+0000
52669: MUL
52670: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
52671: LD_VAR 0 1
52675: PPUSH
52676: LD_INT 66
52678: PPUSH
52679: CALL_OW 321
52683: PUSH
52684: LD_INT 2
52686: EQUAL
52687: IFFALSE 52704
// bpoints := bpoints * 1.1 ;
52689: LD_ADDR_VAR 0 10
52693: PUSH
52694: LD_VAR 0 10
52698: PUSH
52699: LD_REAL  1.10000000000000E+0000
52702: MUL
52703: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
52704: LD_ADDR_VAR 0 10
52708: PUSH
52709: LD_VAR 0 10
52713: PUSH
52714: LD_VAR 0 6
52718: PPUSH
52719: LD_INT 1
52721: PPUSH
52722: CALL_OW 259
52726: PUSH
52727: LD_REAL  1.15000000000000E+0000
52730: MUL
52731: MUL
52732: ST_TO_ADDR
// end ; unit_vehicle :
52733: GO 53557
52735: LD_INT 2
52737: DOUBLE
52738: EQUAL
52739: IFTRUE 52743
52741: GO 53545
52743: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
52744: LD_VAR 0 6
52748: PPUSH
52749: CALL_OW 264
52753: PUSH
52754: LD_INT 2
52756: PUSH
52757: LD_INT 42
52759: PUSH
52760: LD_INT 24
52762: PUSH
52763: EMPTY
52764: LIST
52765: LIST
52766: LIST
52767: IN
52768: IFFALSE 52789
// points := [ 25 , 5 , 3 ] ;
52770: LD_ADDR_VAR 0 9
52774: PUSH
52775: LD_INT 25
52777: PUSH
52778: LD_INT 5
52780: PUSH
52781: LD_INT 3
52783: PUSH
52784: EMPTY
52785: LIST
52786: LIST
52787: LIST
52788: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
52789: LD_VAR 0 6
52793: PPUSH
52794: CALL_OW 264
52798: PUSH
52799: LD_INT 4
52801: PUSH
52802: LD_INT 43
52804: PUSH
52805: LD_INT 25
52807: PUSH
52808: EMPTY
52809: LIST
52810: LIST
52811: LIST
52812: IN
52813: IFFALSE 52834
// points := [ 40 , 15 , 5 ] ;
52815: LD_ADDR_VAR 0 9
52819: PUSH
52820: LD_INT 40
52822: PUSH
52823: LD_INT 15
52825: PUSH
52826: LD_INT 5
52828: PUSH
52829: EMPTY
52830: LIST
52831: LIST
52832: LIST
52833: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
52834: LD_VAR 0 6
52838: PPUSH
52839: CALL_OW 264
52843: PUSH
52844: LD_INT 3
52846: PUSH
52847: LD_INT 23
52849: PUSH
52850: EMPTY
52851: LIST
52852: LIST
52853: IN
52854: IFFALSE 52875
// points := [ 7 , 25 , 8 ] ;
52856: LD_ADDR_VAR 0 9
52860: PUSH
52861: LD_INT 7
52863: PUSH
52864: LD_INT 25
52866: PUSH
52867: LD_INT 8
52869: PUSH
52870: EMPTY
52871: LIST
52872: LIST
52873: LIST
52874: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
52875: LD_VAR 0 6
52879: PPUSH
52880: CALL_OW 264
52884: PUSH
52885: LD_INT 5
52887: PUSH
52888: LD_INT 27
52890: PUSH
52891: LD_INT 44
52893: PUSH
52894: EMPTY
52895: LIST
52896: LIST
52897: LIST
52898: IN
52899: IFFALSE 52920
// points := [ 14 , 50 , 16 ] ;
52901: LD_ADDR_VAR 0 9
52905: PUSH
52906: LD_INT 14
52908: PUSH
52909: LD_INT 50
52911: PUSH
52912: LD_INT 16
52914: PUSH
52915: EMPTY
52916: LIST
52917: LIST
52918: LIST
52919: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
52920: LD_VAR 0 6
52924: PPUSH
52925: CALL_OW 264
52929: PUSH
52930: LD_INT 6
52932: PUSH
52933: LD_INT 46
52935: PUSH
52936: EMPTY
52937: LIST
52938: LIST
52939: IN
52940: IFFALSE 52961
// points := [ 32 , 120 , 70 ] ;
52942: LD_ADDR_VAR 0 9
52946: PUSH
52947: LD_INT 32
52949: PUSH
52950: LD_INT 120
52952: PUSH
52953: LD_INT 70
52955: PUSH
52956: EMPTY
52957: LIST
52958: LIST
52959: LIST
52960: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
52961: LD_VAR 0 6
52965: PPUSH
52966: CALL_OW 264
52970: PUSH
52971: LD_INT 7
52973: PUSH
52974: LD_INT 28
52976: PUSH
52977: LD_INT 45
52979: PUSH
52980: EMPTY
52981: LIST
52982: LIST
52983: LIST
52984: IN
52985: IFFALSE 53006
// points := [ 35 , 20 , 45 ] ;
52987: LD_ADDR_VAR 0 9
52991: PUSH
52992: LD_INT 35
52994: PUSH
52995: LD_INT 20
52997: PUSH
52998: LD_INT 45
53000: PUSH
53001: EMPTY
53002: LIST
53003: LIST
53004: LIST
53005: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
53006: LD_VAR 0 6
53010: PPUSH
53011: CALL_OW 264
53015: PUSH
53016: LD_INT 47
53018: PUSH
53019: EMPTY
53020: LIST
53021: IN
53022: IFFALSE 53043
// points := [ 67 , 45 , 75 ] ;
53024: LD_ADDR_VAR 0 9
53028: PUSH
53029: LD_INT 67
53031: PUSH
53032: LD_INT 45
53034: PUSH
53035: LD_INT 75
53037: PUSH
53038: EMPTY
53039: LIST
53040: LIST
53041: LIST
53042: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
53043: LD_VAR 0 6
53047: PPUSH
53048: CALL_OW 264
53052: PUSH
53053: LD_INT 26
53055: PUSH
53056: EMPTY
53057: LIST
53058: IN
53059: IFFALSE 53080
// points := [ 120 , 30 , 80 ] ;
53061: LD_ADDR_VAR 0 9
53065: PUSH
53066: LD_INT 120
53068: PUSH
53069: LD_INT 30
53071: PUSH
53072: LD_INT 80
53074: PUSH
53075: EMPTY
53076: LIST
53077: LIST
53078: LIST
53079: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
53080: LD_VAR 0 6
53084: PPUSH
53085: CALL_OW 264
53089: PUSH
53090: LD_INT 22
53092: PUSH
53093: EMPTY
53094: LIST
53095: IN
53096: IFFALSE 53117
// points := [ 40 , 1 , 1 ] ;
53098: LD_ADDR_VAR 0 9
53102: PUSH
53103: LD_INT 40
53105: PUSH
53106: LD_INT 1
53108: PUSH
53109: LD_INT 1
53111: PUSH
53112: EMPTY
53113: LIST
53114: LIST
53115: LIST
53116: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
53117: LD_VAR 0 6
53121: PPUSH
53122: CALL_OW 264
53126: PUSH
53127: LD_INT 29
53129: PUSH
53130: EMPTY
53131: LIST
53132: IN
53133: IFFALSE 53154
// points := [ 70 , 200 , 400 ] ;
53135: LD_ADDR_VAR 0 9
53139: PUSH
53140: LD_INT 70
53142: PUSH
53143: LD_INT 200
53145: PUSH
53146: LD_INT 400
53148: PUSH
53149: EMPTY
53150: LIST
53151: LIST
53152: LIST
53153: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
53154: LD_VAR 0 6
53158: PPUSH
53159: CALL_OW 264
53163: PUSH
53164: LD_INT 14
53166: PUSH
53167: LD_INT 53
53169: PUSH
53170: EMPTY
53171: LIST
53172: LIST
53173: IN
53174: IFFALSE 53195
// points := [ 40 , 10 , 20 ] ;
53176: LD_ADDR_VAR 0 9
53180: PUSH
53181: LD_INT 40
53183: PUSH
53184: LD_INT 10
53186: PUSH
53187: LD_INT 20
53189: PUSH
53190: EMPTY
53191: LIST
53192: LIST
53193: LIST
53194: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
53195: LD_VAR 0 6
53199: PPUSH
53200: CALL_OW 264
53204: PUSH
53205: LD_INT 9
53207: PUSH
53208: EMPTY
53209: LIST
53210: IN
53211: IFFALSE 53232
// points := [ 5 , 70 , 20 ] ;
53213: LD_ADDR_VAR 0 9
53217: PUSH
53218: LD_INT 5
53220: PUSH
53221: LD_INT 70
53223: PUSH
53224: LD_INT 20
53226: PUSH
53227: EMPTY
53228: LIST
53229: LIST
53230: LIST
53231: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
53232: LD_VAR 0 6
53236: PPUSH
53237: CALL_OW 264
53241: PUSH
53242: LD_INT 10
53244: PUSH
53245: EMPTY
53246: LIST
53247: IN
53248: IFFALSE 53269
// points := [ 35 , 110 , 70 ] ;
53250: LD_ADDR_VAR 0 9
53254: PUSH
53255: LD_INT 35
53257: PUSH
53258: LD_INT 110
53260: PUSH
53261: LD_INT 70
53263: PUSH
53264: EMPTY
53265: LIST
53266: LIST
53267: LIST
53268: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
53269: LD_VAR 0 6
53273: PPUSH
53274: CALL_OW 265
53278: PUSH
53279: LD_INT 25
53281: EQUAL
53282: IFFALSE 53303
// points := [ 80 , 65 , 100 ] ;
53284: LD_ADDR_VAR 0 9
53288: PUSH
53289: LD_INT 80
53291: PUSH
53292: LD_INT 65
53294: PUSH
53295: LD_INT 100
53297: PUSH
53298: EMPTY
53299: LIST
53300: LIST
53301: LIST
53302: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
53303: LD_VAR 0 6
53307: PPUSH
53308: CALL_OW 263
53312: PUSH
53313: LD_INT 1
53315: EQUAL
53316: IFFALSE 53351
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
53318: LD_ADDR_VAR 0 10
53322: PUSH
53323: LD_VAR 0 10
53327: PUSH
53328: LD_VAR 0 6
53332: PPUSH
53333: CALL_OW 311
53337: PPUSH
53338: LD_INT 3
53340: PPUSH
53341: CALL_OW 259
53345: PUSH
53346: LD_INT 4
53348: MUL
53349: MUL
53350: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
53351: LD_VAR 0 6
53355: PPUSH
53356: CALL_OW 263
53360: PUSH
53361: LD_INT 2
53363: EQUAL
53364: IFFALSE 53415
// begin j := IsControledBy ( i ) ;
53366: LD_ADDR_VAR 0 7
53370: PUSH
53371: LD_VAR 0 6
53375: PPUSH
53376: CALL_OW 312
53380: ST_TO_ADDR
// if j then
53381: LD_VAR 0 7
53385: IFFALSE 53415
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
53387: LD_ADDR_VAR 0 10
53391: PUSH
53392: LD_VAR 0 10
53396: PUSH
53397: LD_VAR 0 7
53401: PPUSH
53402: LD_INT 3
53404: PPUSH
53405: CALL_OW 259
53409: PUSH
53410: LD_INT 3
53412: MUL
53413: MUL
53414: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
53415: LD_VAR 0 6
53419: PPUSH
53420: CALL_OW 264
53424: PUSH
53425: LD_INT 5
53427: PUSH
53428: LD_INT 6
53430: PUSH
53431: LD_INT 46
53433: PUSH
53434: LD_INT 44
53436: PUSH
53437: LD_INT 47
53439: PUSH
53440: LD_INT 45
53442: PUSH
53443: LD_INT 28
53445: PUSH
53446: LD_INT 7
53448: PUSH
53449: LD_INT 27
53451: PUSH
53452: LD_INT 29
53454: PUSH
53455: EMPTY
53456: LIST
53457: LIST
53458: LIST
53459: LIST
53460: LIST
53461: LIST
53462: LIST
53463: LIST
53464: LIST
53465: LIST
53466: IN
53467: PUSH
53468: LD_VAR 0 1
53472: PPUSH
53473: LD_INT 52
53475: PPUSH
53476: CALL_OW 321
53480: PUSH
53481: LD_INT 2
53483: EQUAL
53484: AND
53485: IFFALSE 53502
// bpoints := bpoints * 1.2 ;
53487: LD_ADDR_VAR 0 10
53491: PUSH
53492: LD_VAR 0 10
53496: PUSH
53497: LD_REAL  1.20000000000000E+0000
53500: MUL
53501: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
53502: LD_VAR 0 6
53506: PPUSH
53507: CALL_OW 264
53511: PUSH
53512: LD_INT 6
53514: PUSH
53515: LD_INT 46
53517: PUSH
53518: LD_INT 47
53520: PUSH
53521: EMPTY
53522: LIST
53523: LIST
53524: LIST
53525: IN
53526: IFFALSE 53543
// bpoints := bpoints * 1.2 ;
53528: LD_ADDR_VAR 0 10
53532: PUSH
53533: LD_VAR 0 10
53537: PUSH
53538: LD_REAL  1.20000000000000E+0000
53541: MUL
53542: ST_TO_ADDR
// end ; unit_building :
53543: GO 53557
53545: LD_INT 3
53547: DOUBLE
53548: EQUAL
53549: IFTRUE 53553
53551: GO 53556
53553: POP
// ; end ;
53554: GO 53557
53556: POP
// for j = 1 to 3 do
53557: LD_ADDR_VAR 0 7
53561: PUSH
53562: DOUBLE
53563: LD_INT 1
53565: DEC
53566: ST_TO_ADDR
53567: LD_INT 3
53569: PUSH
53570: FOR_TO
53571: IFFALSE 53624
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
53573: LD_ADDR_VAR 0 5
53577: PUSH
53578: LD_VAR 0 5
53582: PPUSH
53583: LD_VAR 0 7
53587: PPUSH
53588: LD_VAR 0 5
53592: PUSH
53593: LD_VAR 0 7
53597: ARRAY
53598: PUSH
53599: LD_VAR 0 9
53603: PUSH
53604: LD_VAR 0 7
53608: ARRAY
53609: PUSH
53610: LD_VAR 0 10
53614: MUL
53615: PLUS
53616: PPUSH
53617: CALL_OW 1
53621: ST_TO_ADDR
53622: GO 53570
53624: POP
53625: POP
// end ;
53626: GO 52109
53628: POP
53629: POP
// result := Replace ( result , 4 , tmp ) ;
53630: LD_ADDR_VAR 0 5
53634: PUSH
53635: LD_VAR 0 5
53639: PPUSH
53640: LD_INT 4
53642: PPUSH
53643: LD_VAR 0 8
53647: PPUSH
53648: CALL_OW 1
53652: ST_TO_ADDR
// end ;
53653: LD_VAR 0 5
53657: RET
// export function DangerAtRange ( unit , range ) ; begin
53658: LD_INT 0
53660: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
53661: LD_ADDR_VAR 0 3
53665: PUSH
53666: LD_VAR 0 1
53670: PPUSH
53671: CALL_OW 255
53675: PPUSH
53676: LD_VAR 0 1
53680: PPUSH
53681: CALL_OW 250
53685: PPUSH
53686: LD_VAR 0 1
53690: PPUSH
53691: CALL_OW 251
53695: PPUSH
53696: LD_VAR 0 2
53700: PPUSH
53701: CALL 51961 0 4
53705: ST_TO_ADDR
// end ;
53706: LD_VAR 0 3
53710: RET
// export function DangerInArea ( side , area ) ; begin
53711: LD_INT 0
53713: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
53714: LD_ADDR_VAR 0 3
53718: PUSH
53719: LD_VAR 0 2
53723: PPUSH
53724: LD_INT 81
53726: PUSH
53727: LD_VAR 0 1
53731: PUSH
53732: EMPTY
53733: LIST
53734: LIST
53735: PPUSH
53736: CALL_OW 70
53740: ST_TO_ADDR
// end ;
53741: LD_VAR 0 3
53745: RET
// export function IsExtension ( b ) ; begin
53746: LD_INT 0
53748: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
53749: LD_ADDR_VAR 0 2
53753: PUSH
53754: LD_VAR 0 1
53758: PUSH
53759: LD_INT 23
53761: PUSH
53762: LD_INT 20
53764: PUSH
53765: LD_INT 22
53767: PUSH
53768: LD_INT 17
53770: PUSH
53771: LD_INT 24
53773: PUSH
53774: LD_INT 21
53776: PUSH
53777: LD_INT 19
53779: PUSH
53780: LD_INT 16
53782: PUSH
53783: LD_INT 25
53785: PUSH
53786: LD_INT 18
53788: PUSH
53789: EMPTY
53790: LIST
53791: LIST
53792: LIST
53793: LIST
53794: LIST
53795: LIST
53796: LIST
53797: LIST
53798: LIST
53799: LIST
53800: IN
53801: ST_TO_ADDR
// end ;
53802: LD_VAR 0 2
53806: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
53807: LD_INT 0
53809: PPUSH
53810: PPUSH
53811: PPUSH
// result := [ ] ;
53812: LD_ADDR_VAR 0 3
53816: PUSH
53817: EMPTY
53818: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
53819: LD_ADDR_VAR 0 4
53823: PUSH
53824: LD_VAR 0 2
53828: PPUSH
53829: LD_INT 21
53831: PUSH
53832: LD_INT 3
53834: PUSH
53835: EMPTY
53836: LIST
53837: LIST
53838: PPUSH
53839: CALL_OW 70
53843: ST_TO_ADDR
// if not tmp then
53844: LD_VAR 0 4
53848: NOT
53849: IFFALSE 53853
// exit ;
53851: GO 53911
// for i in tmp do
53853: LD_ADDR_VAR 0 5
53857: PUSH
53858: LD_VAR 0 4
53862: PUSH
53863: FOR_IN
53864: IFFALSE 53899
// if GetBase ( i ) <> base then
53866: LD_VAR 0 5
53870: PPUSH
53871: CALL_OW 274
53875: PUSH
53876: LD_VAR 0 1
53880: NONEQUAL
53881: IFFALSE 53897
// ComLinkToBase ( base , i ) ;
53883: LD_VAR 0 1
53887: PPUSH
53888: LD_VAR 0 5
53892: PPUSH
53893: CALL_OW 169
53897: GO 53863
53899: POP
53900: POP
// result := tmp ;
53901: LD_ADDR_VAR 0 3
53905: PUSH
53906: LD_VAR 0 4
53910: ST_TO_ADDR
// end ;
53911: LD_VAR 0 3
53915: RET
// export function ComComplete ( unit , b ) ; var i ; begin
53916: LD_INT 0
53918: PPUSH
53919: PPUSH
// if BuildingStatus ( b ) = bs_build then
53920: LD_VAR 0 2
53924: PPUSH
53925: CALL_OW 461
53929: PUSH
53930: LD_INT 1
53932: EQUAL
53933: IFFALSE 53993
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
53935: LD_VAR 0 1
53939: PPUSH
53940: LD_STRING h
53942: PUSH
53943: LD_VAR 0 2
53947: PPUSH
53948: CALL_OW 250
53952: PUSH
53953: LD_VAR 0 2
53957: PPUSH
53958: CALL_OW 251
53962: PUSH
53963: LD_VAR 0 2
53967: PUSH
53968: LD_INT 0
53970: PUSH
53971: LD_INT 0
53973: PUSH
53974: LD_INT 0
53976: PUSH
53977: EMPTY
53978: LIST
53979: LIST
53980: LIST
53981: LIST
53982: LIST
53983: LIST
53984: LIST
53985: PUSH
53986: EMPTY
53987: LIST
53988: PPUSH
53989: CALL_OW 446
// end ;
53993: LD_VAR 0 3
53997: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
53998: LD_INT 0
54000: PPUSH
54001: PPUSH
54002: PPUSH
54003: PPUSH
54004: PPUSH
54005: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
54006: LD_VAR 0 1
54010: NOT
54011: PUSH
54012: LD_VAR 0 1
54016: PPUSH
54017: CALL_OW 263
54021: PUSH
54022: LD_INT 2
54024: EQUAL
54025: NOT
54026: OR
54027: IFFALSE 54031
// exit ;
54029: GO 54347
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
54031: LD_ADDR_VAR 0 6
54035: PUSH
54036: LD_INT 22
54038: PUSH
54039: LD_VAR 0 1
54043: PPUSH
54044: CALL_OW 255
54048: PUSH
54049: EMPTY
54050: LIST
54051: LIST
54052: PUSH
54053: LD_INT 2
54055: PUSH
54056: LD_INT 30
54058: PUSH
54059: LD_INT 36
54061: PUSH
54062: EMPTY
54063: LIST
54064: LIST
54065: PUSH
54066: LD_INT 34
54068: PUSH
54069: LD_INT 31
54071: PUSH
54072: EMPTY
54073: LIST
54074: LIST
54075: PUSH
54076: EMPTY
54077: LIST
54078: LIST
54079: LIST
54080: PUSH
54081: EMPTY
54082: LIST
54083: LIST
54084: PPUSH
54085: CALL_OW 69
54089: ST_TO_ADDR
// if not tmp then
54090: LD_VAR 0 6
54094: NOT
54095: IFFALSE 54099
// exit ;
54097: GO 54347
// result := [ ] ;
54099: LD_ADDR_VAR 0 2
54103: PUSH
54104: EMPTY
54105: ST_TO_ADDR
// for i in tmp do
54106: LD_ADDR_VAR 0 3
54110: PUSH
54111: LD_VAR 0 6
54115: PUSH
54116: FOR_IN
54117: IFFALSE 54188
// begin t := UnitsInside ( i ) ;
54119: LD_ADDR_VAR 0 4
54123: PUSH
54124: LD_VAR 0 3
54128: PPUSH
54129: CALL_OW 313
54133: ST_TO_ADDR
// if t then
54134: LD_VAR 0 4
54138: IFFALSE 54186
// for j in t do
54140: LD_ADDR_VAR 0 7
54144: PUSH
54145: LD_VAR 0 4
54149: PUSH
54150: FOR_IN
54151: IFFALSE 54184
// result := Insert ( result , result + 1 , j ) ;
54153: LD_ADDR_VAR 0 2
54157: PUSH
54158: LD_VAR 0 2
54162: PPUSH
54163: LD_VAR 0 2
54167: PUSH
54168: LD_INT 1
54170: PLUS
54171: PPUSH
54172: LD_VAR 0 7
54176: PPUSH
54177: CALL_OW 2
54181: ST_TO_ADDR
54182: GO 54150
54184: POP
54185: POP
// end ;
54186: GO 54116
54188: POP
54189: POP
// if not result then
54190: LD_VAR 0 2
54194: NOT
54195: IFFALSE 54199
// exit ;
54197: GO 54347
// mech := result [ 1 ] ;
54199: LD_ADDR_VAR 0 5
54203: PUSH
54204: LD_VAR 0 2
54208: PUSH
54209: LD_INT 1
54211: ARRAY
54212: ST_TO_ADDR
// if result > 1 then
54213: LD_VAR 0 2
54217: PUSH
54218: LD_INT 1
54220: GREATER
54221: IFFALSE 54333
// for i = 2 to result do
54223: LD_ADDR_VAR 0 3
54227: PUSH
54228: DOUBLE
54229: LD_INT 2
54231: DEC
54232: ST_TO_ADDR
54233: LD_VAR 0 2
54237: PUSH
54238: FOR_TO
54239: IFFALSE 54331
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
54241: LD_ADDR_VAR 0 4
54245: PUSH
54246: LD_VAR 0 2
54250: PUSH
54251: LD_VAR 0 3
54255: ARRAY
54256: PPUSH
54257: LD_INT 3
54259: PPUSH
54260: CALL_OW 259
54264: PUSH
54265: LD_VAR 0 2
54269: PUSH
54270: LD_VAR 0 3
54274: ARRAY
54275: PPUSH
54276: CALL_OW 432
54280: MINUS
54281: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
54282: LD_VAR 0 4
54286: PUSH
54287: LD_VAR 0 5
54291: PPUSH
54292: LD_INT 3
54294: PPUSH
54295: CALL_OW 259
54299: PUSH
54300: LD_VAR 0 5
54304: PPUSH
54305: CALL_OW 432
54309: MINUS
54310: GREATEREQUAL
54311: IFFALSE 54329
// mech := result [ i ] ;
54313: LD_ADDR_VAR 0 5
54317: PUSH
54318: LD_VAR 0 2
54322: PUSH
54323: LD_VAR 0 3
54327: ARRAY
54328: ST_TO_ADDR
// end ;
54329: GO 54238
54331: POP
54332: POP
// ComLinkTo ( vehicle , mech ) ;
54333: LD_VAR 0 1
54337: PPUSH
54338: LD_VAR 0 5
54342: PPUSH
54343: CALL_OW 135
// end ;
54347: LD_VAR 0 2
54351: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
54352: LD_INT 0
54354: PPUSH
54355: PPUSH
54356: PPUSH
54357: PPUSH
54358: PPUSH
54359: PPUSH
54360: PPUSH
54361: PPUSH
54362: PPUSH
54363: PPUSH
54364: PPUSH
54365: PPUSH
54366: PPUSH
// result := [ ] ;
54367: LD_ADDR_VAR 0 7
54371: PUSH
54372: EMPTY
54373: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
54374: LD_VAR 0 1
54378: PPUSH
54379: CALL_OW 266
54383: PUSH
54384: LD_INT 0
54386: PUSH
54387: LD_INT 1
54389: PUSH
54390: EMPTY
54391: LIST
54392: LIST
54393: IN
54394: NOT
54395: IFFALSE 54399
// exit ;
54397: GO 56030
// if name then
54399: LD_VAR 0 3
54403: IFFALSE 54419
// SetBName ( base_dep , name ) ;
54405: LD_VAR 0 1
54409: PPUSH
54410: LD_VAR 0 3
54414: PPUSH
54415: CALL_OW 500
// base := GetBase ( base_dep ) ;
54419: LD_ADDR_VAR 0 15
54423: PUSH
54424: LD_VAR 0 1
54428: PPUSH
54429: CALL_OW 274
54433: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
54434: LD_ADDR_VAR 0 16
54438: PUSH
54439: LD_VAR 0 1
54443: PPUSH
54444: CALL_OW 255
54448: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
54449: LD_ADDR_VAR 0 17
54453: PUSH
54454: LD_VAR 0 1
54458: PPUSH
54459: CALL_OW 248
54463: ST_TO_ADDR
// if sources then
54464: LD_VAR 0 5
54468: IFFALSE 54515
// for i = 1 to 3 do
54470: LD_ADDR_VAR 0 8
54474: PUSH
54475: DOUBLE
54476: LD_INT 1
54478: DEC
54479: ST_TO_ADDR
54480: LD_INT 3
54482: PUSH
54483: FOR_TO
54484: IFFALSE 54513
// AddResourceType ( base , i , sources [ i ] ) ;
54486: LD_VAR 0 15
54490: PPUSH
54491: LD_VAR 0 8
54495: PPUSH
54496: LD_VAR 0 5
54500: PUSH
54501: LD_VAR 0 8
54505: ARRAY
54506: PPUSH
54507: CALL_OW 276
54511: GO 54483
54513: POP
54514: POP
// buildings := GetBaseBuildings ( base , area ) ;
54515: LD_ADDR_VAR 0 18
54519: PUSH
54520: LD_VAR 0 15
54524: PPUSH
54525: LD_VAR 0 2
54529: PPUSH
54530: CALL 53807 0 2
54534: ST_TO_ADDR
// InitHc ;
54535: CALL_OW 19
// InitUc ;
54539: CALL_OW 18
// uc_side := side ;
54543: LD_ADDR_OWVAR 20
54547: PUSH
54548: LD_VAR 0 16
54552: ST_TO_ADDR
// uc_nation := nation ;
54553: LD_ADDR_OWVAR 21
54557: PUSH
54558: LD_VAR 0 17
54562: ST_TO_ADDR
// if buildings then
54563: LD_VAR 0 18
54567: IFFALSE 55889
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
54569: LD_ADDR_VAR 0 19
54573: PUSH
54574: LD_VAR 0 18
54578: PPUSH
54579: LD_INT 2
54581: PUSH
54582: LD_INT 30
54584: PUSH
54585: LD_INT 29
54587: PUSH
54588: EMPTY
54589: LIST
54590: LIST
54591: PUSH
54592: LD_INT 30
54594: PUSH
54595: LD_INT 30
54597: PUSH
54598: EMPTY
54599: LIST
54600: LIST
54601: PUSH
54602: EMPTY
54603: LIST
54604: LIST
54605: LIST
54606: PPUSH
54607: CALL_OW 72
54611: ST_TO_ADDR
// if tmp then
54612: LD_VAR 0 19
54616: IFFALSE 54664
// for i in tmp do
54618: LD_ADDR_VAR 0 8
54622: PUSH
54623: LD_VAR 0 19
54627: PUSH
54628: FOR_IN
54629: IFFALSE 54662
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
54631: LD_VAR 0 8
54635: PPUSH
54636: CALL_OW 250
54640: PPUSH
54641: LD_VAR 0 8
54645: PPUSH
54646: CALL_OW 251
54650: PPUSH
54651: LD_VAR 0 16
54655: PPUSH
54656: CALL_OW 441
54660: GO 54628
54662: POP
54663: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
54664: LD_VAR 0 18
54668: PPUSH
54669: LD_INT 2
54671: PUSH
54672: LD_INT 30
54674: PUSH
54675: LD_INT 32
54677: PUSH
54678: EMPTY
54679: LIST
54680: LIST
54681: PUSH
54682: LD_INT 30
54684: PUSH
54685: LD_INT 33
54687: PUSH
54688: EMPTY
54689: LIST
54690: LIST
54691: PUSH
54692: EMPTY
54693: LIST
54694: LIST
54695: LIST
54696: PPUSH
54697: CALL_OW 72
54701: IFFALSE 54789
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
54703: LD_ADDR_VAR 0 8
54707: PUSH
54708: LD_VAR 0 18
54712: PPUSH
54713: LD_INT 2
54715: PUSH
54716: LD_INT 30
54718: PUSH
54719: LD_INT 32
54721: PUSH
54722: EMPTY
54723: LIST
54724: LIST
54725: PUSH
54726: LD_INT 30
54728: PUSH
54729: LD_INT 33
54731: PUSH
54732: EMPTY
54733: LIST
54734: LIST
54735: PUSH
54736: EMPTY
54737: LIST
54738: LIST
54739: LIST
54740: PPUSH
54741: CALL_OW 72
54745: PUSH
54746: FOR_IN
54747: IFFALSE 54787
// begin if not GetBWeapon ( i ) then
54749: LD_VAR 0 8
54753: PPUSH
54754: CALL_OW 269
54758: NOT
54759: IFFALSE 54785
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
54761: LD_VAR 0 8
54765: PPUSH
54766: LD_VAR 0 8
54770: PPUSH
54771: LD_VAR 0 2
54775: PPUSH
54776: CALL 56035 0 2
54780: PPUSH
54781: CALL_OW 431
// end ;
54785: GO 54746
54787: POP
54788: POP
// end ; for i = 1 to personel do
54789: LD_ADDR_VAR 0 8
54793: PUSH
54794: DOUBLE
54795: LD_INT 1
54797: DEC
54798: ST_TO_ADDR
54799: LD_VAR 0 6
54803: PUSH
54804: FOR_TO
54805: IFFALSE 55869
// begin if i > 4 then
54807: LD_VAR 0 8
54811: PUSH
54812: LD_INT 4
54814: GREATER
54815: IFFALSE 54819
// break ;
54817: GO 55869
// case i of 1 :
54819: LD_VAR 0 8
54823: PUSH
54824: LD_INT 1
54826: DOUBLE
54827: EQUAL
54828: IFTRUE 54832
54830: GO 54912
54832: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
54833: LD_ADDR_VAR 0 12
54837: PUSH
54838: LD_VAR 0 18
54842: PPUSH
54843: LD_INT 22
54845: PUSH
54846: LD_VAR 0 16
54850: PUSH
54851: EMPTY
54852: LIST
54853: LIST
54854: PUSH
54855: LD_INT 58
54857: PUSH
54858: EMPTY
54859: LIST
54860: PUSH
54861: LD_INT 2
54863: PUSH
54864: LD_INT 30
54866: PUSH
54867: LD_INT 32
54869: PUSH
54870: EMPTY
54871: LIST
54872: LIST
54873: PUSH
54874: LD_INT 30
54876: PUSH
54877: LD_INT 4
54879: PUSH
54880: EMPTY
54881: LIST
54882: LIST
54883: PUSH
54884: LD_INT 30
54886: PUSH
54887: LD_INT 5
54889: PUSH
54890: EMPTY
54891: LIST
54892: LIST
54893: PUSH
54894: EMPTY
54895: LIST
54896: LIST
54897: LIST
54898: LIST
54899: PUSH
54900: EMPTY
54901: LIST
54902: LIST
54903: LIST
54904: PPUSH
54905: CALL_OW 72
54909: ST_TO_ADDR
54910: GO 55134
54912: LD_INT 2
54914: DOUBLE
54915: EQUAL
54916: IFTRUE 54920
54918: GO 54982
54920: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
54921: LD_ADDR_VAR 0 12
54925: PUSH
54926: LD_VAR 0 18
54930: PPUSH
54931: LD_INT 22
54933: PUSH
54934: LD_VAR 0 16
54938: PUSH
54939: EMPTY
54940: LIST
54941: LIST
54942: PUSH
54943: LD_INT 2
54945: PUSH
54946: LD_INT 30
54948: PUSH
54949: LD_INT 0
54951: PUSH
54952: EMPTY
54953: LIST
54954: LIST
54955: PUSH
54956: LD_INT 30
54958: PUSH
54959: LD_INT 1
54961: PUSH
54962: EMPTY
54963: LIST
54964: LIST
54965: PUSH
54966: EMPTY
54967: LIST
54968: LIST
54969: LIST
54970: PUSH
54971: EMPTY
54972: LIST
54973: LIST
54974: PPUSH
54975: CALL_OW 72
54979: ST_TO_ADDR
54980: GO 55134
54982: LD_INT 3
54984: DOUBLE
54985: EQUAL
54986: IFTRUE 54990
54988: GO 55052
54990: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
54991: LD_ADDR_VAR 0 12
54995: PUSH
54996: LD_VAR 0 18
55000: PPUSH
55001: LD_INT 22
55003: PUSH
55004: LD_VAR 0 16
55008: PUSH
55009: EMPTY
55010: LIST
55011: LIST
55012: PUSH
55013: LD_INT 2
55015: PUSH
55016: LD_INT 30
55018: PUSH
55019: LD_INT 2
55021: PUSH
55022: EMPTY
55023: LIST
55024: LIST
55025: PUSH
55026: LD_INT 30
55028: PUSH
55029: LD_INT 3
55031: PUSH
55032: EMPTY
55033: LIST
55034: LIST
55035: PUSH
55036: EMPTY
55037: LIST
55038: LIST
55039: LIST
55040: PUSH
55041: EMPTY
55042: LIST
55043: LIST
55044: PPUSH
55045: CALL_OW 72
55049: ST_TO_ADDR
55050: GO 55134
55052: LD_INT 4
55054: DOUBLE
55055: EQUAL
55056: IFTRUE 55060
55058: GO 55133
55060: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
55061: LD_ADDR_VAR 0 12
55065: PUSH
55066: LD_VAR 0 18
55070: PPUSH
55071: LD_INT 22
55073: PUSH
55074: LD_VAR 0 16
55078: PUSH
55079: EMPTY
55080: LIST
55081: LIST
55082: PUSH
55083: LD_INT 2
55085: PUSH
55086: LD_INT 30
55088: PUSH
55089: LD_INT 6
55091: PUSH
55092: EMPTY
55093: LIST
55094: LIST
55095: PUSH
55096: LD_INT 30
55098: PUSH
55099: LD_INT 7
55101: PUSH
55102: EMPTY
55103: LIST
55104: LIST
55105: PUSH
55106: LD_INT 30
55108: PUSH
55109: LD_INT 8
55111: PUSH
55112: EMPTY
55113: LIST
55114: LIST
55115: PUSH
55116: EMPTY
55117: LIST
55118: LIST
55119: LIST
55120: LIST
55121: PUSH
55122: EMPTY
55123: LIST
55124: LIST
55125: PPUSH
55126: CALL_OW 72
55130: ST_TO_ADDR
55131: GO 55134
55133: POP
// if i = 1 then
55134: LD_VAR 0 8
55138: PUSH
55139: LD_INT 1
55141: EQUAL
55142: IFFALSE 55253
// begin tmp := [ ] ;
55144: LD_ADDR_VAR 0 19
55148: PUSH
55149: EMPTY
55150: ST_TO_ADDR
// for j in f do
55151: LD_ADDR_VAR 0 9
55155: PUSH
55156: LD_VAR 0 12
55160: PUSH
55161: FOR_IN
55162: IFFALSE 55235
// if GetBType ( j ) = b_bunker then
55164: LD_VAR 0 9
55168: PPUSH
55169: CALL_OW 266
55173: PUSH
55174: LD_INT 32
55176: EQUAL
55177: IFFALSE 55204
// tmp := Insert ( tmp , 1 , j ) else
55179: LD_ADDR_VAR 0 19
55183: PUSH
55184: LD_VAR 0 19
55188: PPUSH
55189: LD_INT 1
55191: PPUSH
55192: LD_VAR 0 9
55196: PPUSH
55197: CALL_OW 2
55201: ST_TO_ADDR
55202: GO 55233
// tmp := Insert ( tmp , tmp + 1 , j ) ;
55204: LD_ADDR_VAR 0 19
55208: PUSH
55209: LD_VAR 0 19
55213: PPUSH
55214: LD_VAR 0 19
55218: PUSH
55219: LD_INT 1
55221: PLUS
55222: PPUSH
55223: LD_VAR 0 9
55227: PPUSH
55228: CALL_OW 2
55232: ST_TO_ADDR
55233: GO 55161
55235: POP
55236: POP
// if tmp then
55237: LD_VAR 0 19
55241: IFFALSE 55253
// f := tmp ;
55243: LD_ADDR_VAR 0 12
55247: PUSH
55248: LD_VAR 0 19
55252: ST_TO_ADDR
// end ; x := personel [ i ] ;
55253: LD_ADDR_VAR 0 13
55257: PUSH
55258: LD_VAR 0 6
55262: PUSH
55263: LD_VAR 0 8
55267: ARRAY
55268: ST_TO_ADDR
// if x = - 1 then
55269: LD_VAR 0 13
55273: PUSH
55274: LD_INT 1
55276: NEG
55277: EQUAL
55278: IFFALSE 55487
// begin for j in f do
55280: LD_ADDR_VAR 0 9
55284: PUSH
55285: LD_VAR 0 12
55289: PUSH
55290: FOR_IN
55291: IFFALSE 55483
// repeat InitHc ;
55293: CALL_OW 19
// if GetBType ( j ) = b_barracks then
55297: LD_VAR 0 9
55301: PPUSH
55302: CALL_OW 266
55306: PUSH
55307: LD_INT 5
55309: EQUAL
55310: IFFALSE 55380
// begin if UnitsInside ( j ) < 3 then
55312: LD_VAR 0 9
55316: PPUSH
55317: CALL_OW 313
55321: PUSH
55322: LD_INT 3
55324: LESS
55325: IFFALSE 55361
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
55327: LD_INT 0
55329: PPUSH
55330: LD_INT 5
55332: PUSH
55333: LD_INT 8
55335: PUSH
55336: LD_INT 9
55338: PUSH
55339: EMPTY
55340: LIST
55341: LIST
55342: LIST
55343: PUSH
55344: LD_VAR 0 17
55348: ARRAY
55349: PPUSH
55350: LD_VAR 0 4
55354: PPUSH
55355: CALL_OW 380
55359: GO 55378
// PrepareHuman ( false , i , skill ) ;
55361: LD_INT 0
55363: PPUSH
55364: LD_VAR 0 8
55368: PPUSH
55369: LD_VAR 0 4
55373: PPUSH
55374: CALL_OW 380
// end else
55378: GO 55397
// PrepareHuman ( false , i , skill ) ;
55380: LD_INT 0
55382: PPUSH
55383: LD_VAR 0 8
55387: PPUSH
55388: LD_VAR 0 4
55392: PPUSH
55393: CALL_OW 380
// un := CreateHuman ;
55397: LD_ADDR_VAR 0 14
55401: PUSH
55402: CALL_OW 44
55406: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
55407: LD_ADDR_VAR 0 7
55411: PUSH
55412: LD_VAR 0 7
55416: PPUSH
55417: LD_INT 1
55419: PPUSH
55420: LD_VAR 0 14
55424: PPUSH
55425: CALL_OW 2
55429: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
55430: LD_VAR 0 14
55434: PPUSH
55435: LD_VAR 0 9
55439: PPUSH
55440: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
55444: LD_VAR 0 9
55448: PPUSH
55449: CALL_OW 313
55453: PUSH
55454: LD_INT 6
55456: EQUAL
55457: PUSH
55458: LD_VAR 0 9
55462: PPUSH
55463: CALL_OW 266
55467: PUSH
55468: LD_INT 32
55470: PUSH
55471: LD_INT 31
55473: PUSH
55474: EMPTY
55475: LIST
55476: LIST
55477: IN
55478: OR
55479: IFFALSE 55293
55481: GO 55290
55483: POP
55484: POP
// end else
55485: GO 55867
// for j = 1 to x do
55487: LD_ADDR_VAR 0 9
55491: PUSH
55492: DOUBLE
55493: LD_INT 1
55495: DEC
55496: ST_TO_ADDR
55497: LD_VAR 0 13
55501: PUSH
55502: FOR_TO
55503: IFFALSE 55865
// begin InitHc ;
55505: CALL_OW 19
// if not f then
55509: LD_VAR 0 12
55513: NOT
55514: IFFALSE 55603
// begin PrepareHuman ( false , i , skill ) ;
55516: LD_INT 0
55518: PPUSH
55519: LD_VAR 0 8
55523: PPUSH
55524: LD_VAR 0 4
55528: PPUSH
55529: CALL_OW 380
// un := CreateHuman ;
55533: LD_ADDR_VAR 0 14
55537: PUSH
55538: CALL_OW 44
55542: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
55543: LD_ADDR_VAR 0 7
55547: PUSH
55548: LD_VAR 0 7
55552: PPUSH
55553: LD_INT 1
55555: PPUSH
55556: LD_VAR 0 14
55560: PPUSH
55561: CALL_OW 2
55565: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
55566: LD_VAR 0 14
55570: PPUSH
55571: LD_VAR 0 1
55575: PPUSH
55576: CALL_OW 250
55580: PPUSH
55581: LD_VAR 0 1
55585: PPUSH
55586: CALL_OW 251
55590: PPUSH
55591: LD_INT 10
55593: PPUSH
55594: LD_INT 0
55596: PPUSH
55597: CALL_OW 50
// continue ;
55601: GO 55502
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
55603: LD_VAR 0 12
55607: PUSH
55608: LD_INT 1
55610: ARRAY
55611: PPUSH
55612: CALL_OW 313
55616: PUSH
55617: LD_VAR 0 12
55621: PUSH
55622: LD_INT 1
55624: ARRAY
55625: PPUSH
55626: CALL_OW 266
55630: PUSH
55631: LD_INT 32
55633: PUSH
55634: LD_INT 31
55636: PUSH
55637: EMPTY
55638: LIST
55639: LIST
55640: IN
55641: AND
55642: PUSH
55643: LD_VAR 0 12
55647: PUSH
55648: LD_INT 1
55650: ARRAY
55651: PPUSH
55652: CALL_OW 313
55656: PUSH
55657: LD_INT 6
55659: EQUAL
55660: OR
55661: IFFALSE 55681
// f := Delete ( f , 1 ) ;
55663: LD_ADDR_VAR 0 12
55667: PUSH
55668: LD_VAR 0 12
55672: PPUSH
55673: LD_INT 1
55675: PPUSH
55676: CALL_OW 3
55680: ST_TO_ADDR
// if not f then
55681: LD_VAR 0 12
55685: NOT
55686: IFFALSE 55704
// begin x := x + 2 ;
55688: LD_ADDR_VAR 0 13
55692: PUSH
55693: LD_VAR 0 13
55697: PUSH
55698: LD_INT 2
55700: PLUS
55701: ST_TO_ADDR
// continue ;
55702: GO 55502
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
55704: LD_VAR 0 12
55708: PUSH
55709: LD_INT 1
55711: ARRAY
55712: PPUSH
55713: CALL_OW 266
55717: PUSH
55718: LD_INT 5
55720: EQUAL
55721: IFFALSE 55795
// begin if UnitsInside ( f [ 1 ] ) < 3 then
55723: LD_VAR 0 12
55727: PUSH
55728: LD_INT 1
55730: ARRAY
55731: PPUSH
55732: CALL_OW 313
55736: PUSH
55737: LD_INT 3
55739: LESS
55740: IFFALSE 55776
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
55742: LD_INT 0
55744: PPUSH
55745: LD_INT 5
55747: PUSH
55748: LD_INT 8
55750: PUSH
55751: LD_INT 9
55753: PUSH
55754: EMPTY
55755: LIST
55756: LIST
55757: LIST
55758: PUSH
55759: LD_VAR 0 17
55763: ARRAY
55764: PPUSH
55765: LD_VAR 0 4
55769: PPUSH
55770: CALL_OW 380
55774: GO 55793
// PrepareHuman ( false , i , skill ) ;
55776: LD_INT 0
55778: PPUSH
55779: LD_VAR 0 8
55783: PPUSH
55784: LD_VAR 0 4
55788: PPUSH
55789: CALL_OW 380
// end else
55793: GO 55812
// PrepareHuman ( false , i , skill ) ;
55795: LD_INT 0
55797: PPUSH
55798: LD_VAR 0 8
55802: PPUSH
55803: LD_VAR 0 4
55807: PPUSH
55808: CALL_OW 380
// un := CreateHuman ;
55812: LD_ADDR_VAR 0 14
55816: PUSH
55817: CALL_OW 44
55821: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
55822: LD_ADDR_VAR 0 7
55826: PUSH
55827: LD_VAR 0 7
55831: PPUSH
55832: LD_INT 1
55834: PPUSH
55835: LD_VAR 0 14
55839: PPUSH
55840: CALL_OW 2
55844: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
55845: LD_VAR 0 14
55849: PPUSH
55850: LD_VAR 0 12
55854: PUSH
55855: LD_INT 1
55857: ARRAY
55858: PPUSH
55859: CALL_OW 52
// end ;
55863: GO 55502
55865: POP
55866: POP
// end ;
55867: GO 54804
55869: POP
55870: POP
// result := result ^ buildings ;
55871: LD_ADDR_VAR 0 7
55875: PUSH
55876: LD_VAR 0 7
55880: PUSH
55881: LD_VAR 0 18
55885: ADD
55886: ST_TO_ADDR
// end else
55887: GO 56030
// begin for i = 1 to personel do
55889: LD_ADDR_VAR 0 8
55893: PUSH
55894: DOUBLE
55895: LD_INT 1
55897: DEC
55898: ST_TO_ADDR
55899: LD_VAR 0 6
55903: PUSH
55904: FOR_TO
55905: IFFALSE 56028
// begin if i > 4 then
55907: LD_VAR 0 8
55911: PUSH
55912: LD_INT 4
55914: GREATER
55915: IFFALSE 55919
// break ;
55917: GO 56028
// x := personel [ i ] ;
55919: LD_ADDR_VAR 0 13
55923: PUSH
55924: LD_VAR 0 6
55928: PUSH
55929: LD_VAR 0 8
55933: ARRAY
55934: ST_TO_ADDR
// if x = - 1 then
55935: LD_VAR 0 13
55939: PUSH
55940: LD_INT 1
55942: NEG
55943: EQUAL
55944: IFFALSE 55948
// continue ;
55946: GO 55904
// PrepareHuman ( false , i , skill ) ;
55948: LD_INT 0
55950: PPUSH
55951: LD_VAR 0 8
55955: PPUSH
55956: LD_VAR 0 4
55960: PPUSH
55961: CALL_OW 380
// un := CreateHuman ;
55965: LD_ADDR_VAR 0 14
55969: PUSH
55970: CALL_OW 44
55974: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
55975: LD_VAR 0 14
55979: PPUSH
55980: LD_VAR 0 1
55984: PPUSH
55985: CALL_OW 250
55989: PPUSH
55990: LD_VAR 0 1
55994: PPUSH
55995: CALL_OW 251
55999: PPUSH
56000: LD_INT 10
56002: PPUSH
56003: LD_INT 0
56005: PPUSH
56006: CALL_OW 50
// result := result ^ un ;
56010: LD_ADDR_VAR 0 7
56014: PUSH
56015: LD_VAR 0 7
56019: PUSH
56020: LD_VAR 0 14
56024: ADD
56025: ST_TO_ADDR
// end ;
56026: GO 55904
56028: POP
56029: POP
// end ; end ;
56030: LD_VAR 0 7
56034: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
56035: LD_INT 0
56037: PPUSH
56038: PPUSH
56039: PPUSH
56040: PPUSH
56041: PPUSH
56042: PPUSH
56043: PPUSH
56044: PPUSH
56045: PPUSH
56046: PPUSH
56047: PPUSH
56048: PPUSH
56049: PPUSH
56050: PPUSH
56051: PPUSH
56052: PPUSH
// result := false ;
56053: LD_ADDR_VAR 0 3
56057: PUSH
56058: LD_INT 0
56060: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
56061: LD_VAR 0 1
56065: NOT
56066: PUSH
56067: LD_VAR 0 1
56071: PPUSH
56072: CALL_OW 266
56076: PUSH
56077: LD_INT 32
56079: PUSH
56080: LD_INT 33
56082: PUSH
56083: EMPTY
56084: LIST
56085: LIST
56086: IN
56087: NOT
56088: OR
56089: IFFALSE 56093
// exit ;
56091: GO 57229
// nat := GetNation ( tower ) ;
56093: LD_ADDR_VAR 0 12
56097: PUSH
56098: LD_VAR 0 1
56102: PPUSH
56103: CALL_OW 248
56107: ST_TO_ADDR
// side := GetSide ( tower ) ;
56108: LD_ADDR_VAR 0 16
56112: PUSH
56113: LD_VAR 0 1
56117: PPUSH
56118: CALL_OW 255
56122: ST_TO_ADDR
// x := GetX ( tower ) ;
56123: LD_ADDR_VAR 0 10
56127: PUSH
56128: LD_VAR 0 1
56132: PPUSH
56133: CALL_OW 250
56137: ST_TO_ADDR
// y := GetY ( tower ) ;
56138: LD_ADDR_VAR 0 11
56142: PUSH
56143: LD_VAR 0 1
56147: PPUSH
56148: CALL_OW 251
56152: ST_TO_ADDR
// if not x or not y then
56153: LD_VAR 0 10
56157: NOT
56158: PUSH
56159: LD_VAR 0 11
56163: NOT
56164: OR
56165: IFFALSE 56169
// exit ;
56167: GO 57229
// weapon := 0 ;
56169: LD_ADDR_VAR 0 18
56173: PUSH
56174: LD_INT 0
56176: ST_TO_ADDR
// fac_list := [ ] ;
56177: LD_ADDR_VAR 0 17
56181: PUSH
56182: EMPTY
56183: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
56184: LD_ADDR_VAR 0 6
56188: PUSH
56189: LD_VAR 0 1
56193: PPUSH
56194: CALL_OW 274
56198: PPUSH
56199: LD_VAR 0 2
56203: PPUSH
56204: CALL 53807 0 2
56208: PPUSH
56209: LD_INT 30
56211: PUSH
56212: LD_INT 3
56214: PUSH
56215: EMPTY
56216: LIST
56217: LIST
56218: PPUSH
56219: CALL_OW 72
56223: ST_TO_ADDR
// if not factories then
56224: LD_VAR 0 6
56228: NOT
56229: IFFALSE 56233
// exit ;
56231: GO 57229
// for i in factories do
56233: LD_ADDR_VAR 0 8
56237: PUSH
56238: LD_VAR 0 6
56242: PUSH
56243: FOR_IN
56244: IFFALSE 56269
// fac_list := fac_list union AvailableWeaponList ( i ) ;
56246: LD_ADDR_VAR 0 17
56250: PUSH
56251: LD_VAR 0 17
56255: PUSH
56256: LD_VAR 0 8
56260: PPUSH
56261: CALL_OW 478
56265: UNION
56266: ST_TO_ADDR
56267: GO 56243
56269: POP
56270: POP
// if not fac_list then
56271: LD_VAR 0 17
56275: NOT
56276: IFFALSE 56280
// exit ;
56278: GO 57229
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
56280: LD_ADDR_VAR 0 5
56284: PUSH
56285: LD_INT 4
56287: PUSH
56288: LD_INT 5
56290: PUSH
56291: LD_INT 9
56293: PUSH
56294: LD_INT 10
56296: PUSH
56297: LD_INT 6
56299: PUSH
56300: LD_INT 7
56302: PUSH
56303: LD_INT 11
56305: PUSH
56306: EMPTY
56307: LIST
56308: LIST
56309: LIST
56310: LIST
56311: LIST
56312: LIST
56313: LIST
56314: PUSH
56315: LD_INT 27
56317: PUSH
56318: LD_INT 28
56320: PUSH
56321: LD_INT 26
56323: PUSH
56324: LD_INT 30
56326: PUSH
56327: EMPTY
56328: LIST
56329: LIST
56330: LIST
56331: LIST
56332: PUSH
56333: LD_INT 43
56335: PUSH
56336: LD_INT 44
56338: PUSH
56339: LD_INT 46
56341: PUSH
56342: LD_INT 45
56344: PUSH
56345: LD_INT 47
56347: PUSH
56348: LD_INT 49
56350: PUSH
56351: EMPTY
56352: LIST
56353: LIST
56354: LIST
56355: LIST
56356: LIST
56357: LIST
56358: PUSH
56359: EMPTY
56360: LIST
56361: LIST
56362: LIST
56363: PUSH
56364: LD_VAR 0 12
56368: ARRAY
56369: ST_TO_ADDR
// for i in list do
56370: LD_ADDR_VAR 0 8
56374: PUSH
56375: LD_VAR 0 5
56379: PUSH
56380: FOR_IN
56381: IFFALSE 56414
// if not i in fac_list then
56383: LD_VAR 0 8
56387: PUSH
56388: LD_VAR 0 17
56392: IN
56393: NOT
56394: IFFALSE 56412
// list := list diff i ;
56396: LD_ADDR_VAR 0 5
56400: PUSH
56401: LD_VAR 0 5
56405: PUSH
56406: LD_VAR 0 8
56410: DIFF
56411: ST_TO_ADDR
56412: GO 56380
56414: POP
56415: POP
// if not list then
56416: LD_VAR 0 5
56420: NOT
56421: IFFALSE 56425
// exit ;
56423: GO 57229
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
56425: LD_VAR 0 12
56429: PUSH
56430: LD_INT 3
56432: EQUAL
56433: PUSH
56434: LD_INT 49
56436: PUSH
56437: LD_VAR 0 5
56441: IN
56442: AND
56443: PUSH
56444: LD_INT 31
56446: PPUSH
56447: LD_VAR 0 16
56451: PPUSH
56452: CALL_OW 321
56456: PUSH
56457: LD_INT 2
56459: EQUAL
56460: AND
56461: IFFALSE 56521
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
56463: LD_INT 22
56465: PUSH
56466: LD_VAR 0 16
56470: PUSH
56471: EMPTY
56472: LIST
56473: LIST
56474: PUSH
56475: LD_INT 35
56477: PUSH
56478: LD_INT 49
56480: PUSH
56481: EMPTY
56482: LIST
56483: LIST
56484: PUSH
56485: LD_INT 91
56487: PUSH
56488: LD_VAR 0 1
56492: PUSH
56493: LD_INT 10
56495: PUSH
56496: EMPTY
56497: LIST
56498: LIST
56499: LIST
56500: PUSH
56501: EMPTY
56502: LIST
56503: LIST
56504: LIST
56505: PPUSH
56506: CALL_OW 69
56510: NOT
56511: IFFALSE 56521
// weapon := ru_time_lapser ;
56513: LD_ADDR_VAR 0 18
56517: PUSH
56518: LD_INT 49
56520: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
56521: LD_VAR 0 12
56525: PUSH
56526: LD_INT 1
56528: PUSH
56529: LD_INT 2
56531: PUSH
56532: EMPTY
56533: LIST
56534: LIST
56535: IN
56536: PUSH
56537: LD_INT 11
56539: PUSH
56540: LD_VAR 0 5
56544: IN
56545: PUSH
56546: LD_INT 30
56548: PUSH
56549: LD_VAR 0 5
56553: IN
56554: OR
56555: AND
56556: PUSH
56557: LD_INT 6
56559: PPUSH
56560: LD_VAR 0 16
56564: PPUSH
56565: CALL_OW 321
56569: PUSH
56570: LD_INT 2
56572: EQUAL
56573: AND
56574: IFFALSE 56739
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
56576: LD_INT 22
56578: PUSH
56579: LD_VAR 0 16
56583: PUSH
56584: EMPTY
56585: LIST
56586: LIST
56587: PUSH
56588: LD_INT 2
56590: PUSH
56591: LD_INT 35
56593: PUSH
56594: LD_INT 11
56596: PUSH
56597: EMPTY
56598: LIST
56599: LIST
56600: PUSH
56601: LD_INT 35
56603: PUSH
56604: LD_INT 30
56606: PUSH
56607: EMPTY
56608: LIST
56609: LIST
56610: PUSH
56611: EMPTY
56612: LIST
56613: LIST
56614: LIST
56615: PUSH
56616: LD_INT 91
56618: PUSH
56619: LD_VAR 0 1
56623: PUSH
56624: LD_INT 18
56626: PUSH
56627: EMPTY
56628: LIST
56629: LIST
56630: LIST
56631: PUSH
56632: EMPTY
56633: LIST
56634: LIST
56635: LIST
56636: PPUSH
56637: CALL_OW 69
56641: NOT
56642: PUSH
56643: LD_INT 22
56645: PUSH
56646: LD_VAR 0 16
56650: PUSH
56651: EMPTY
56652: LIST
56653: LIST
56654: PUSH
56655: LD_INT 2
56657: PUSH
56658: LD_INT 30
56660: PUSH
56661: LD_INT 32
56663: PUSH
56664: EMPTY
56665: LIST
56666: LIST
56667: PUSH
56668: LD_INT 30
56670: PUSH
56671: LD_INT 33
56673: PUSH
56674: EMPTY
56675: LIST
56676: LIST
56677: PUSH
56678: EMPTY
56679: LIST
56680: LIST
56681: LIST
56682: PUSH
56683: LD_INT 91
56685: PUSH
56686: LD_VAR 0 1
56690: PUSH
56691: LD_INT 12
56693: PUSH
56694: EMPTY
56695: LIST
56696: LIST
56697: LIST
56698: PUSH
56699: EMPTY
56700: LIST
56701: LIST
56702: LIST
56703: PUSH
56704: EMPTY
56705: LIST
56706: PPUSH
56707: CALL_OW 69
56711: PUSH
56712: LD_INT 2
56714: GREATER
56715: AND
56716: IFFALSE 56739
// weapon := [ us_radar , ar_radar ] [ nat ] ;
56718: LD_ADDR_VAR 0 18
56722: PUSH
56723: LD_INT 11
56725: PUSH
56726: LD_INT 30
56728: PUSH
56729: EMPTY
56730: LIST
56731: LIST
56732: PUSH
56733: LD_VAR 0 12
56737: ARRAY
56738: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
56739: LD_VAR 0 18
56743: NOT
56744: PUSH
56745: LD_INT 40
56747: PPUSH
56748: LD_VAR 0 16
56752: PPUSH
56753: CALL_OW 321
56757: PUSH
56758: LD_INT 2
56760: EQUAL
56761: AND
56762: PUSH
56763: LD_INT 7
56765: PUSH
56766: LD_VAR 0 5
56770: IN
56771: PUSH
56772: LD_INT 28
56774: PUSH
56775: LD_VAR 0 5
56779: IN
56780: OR
56781: PUSH
56782: LD_INT 45
56784: PUSH
56785: LD_VAR 0 5
56789: IN
56790: OR
56791: AND
56792: IFFALSE 57046
// begin hex := GetHexInfo ( x , y ) ;
56794: LD_ADDR_VAR 0 4
56798: PUSH
56799: LD_VAR 0 10
56803: PPUSH
56804: LD_VAR 0 11
56808: PPUSH
56809: CALL_OW 546
56813: ST_TO_ADDR
// if hex [ 1 ] then
56814: LD_VAR 0 4
56818: PUSH
56819: LD_INT 1
56821: ARRAY
56822: IFFALSE 56826
// exit ;
56824: GO 57229
// height := hex [ 2 ] ;
56826: LD_ADDR_VAR 0 15
56830: PUSH
56831: LD_VAR 0 4
56835: PUSH
56836: LD_INT 2
56838: ARRAY
56839: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
56840: LD_ADDR_VAR 0 14
56844: PUSH
56845: LD_INT 0
56847: PUSH
56848: LD_INT 2
56850: PUSH
56851: LD_INT 3
56853: PUSH
56854: LD_INT 5
56856: PUSH
56857: EMPTY
56858: LIST
56859: LIST
56860: LIST
56861: LIST
56862: ST_TO_ADDR
// for i in tmp do
56863: LD_ADDR_VAR 0 8
56867: PUSH
56868: LD_VAR 0 14
56872: PUSH
56873: FOR_IN
56874: IFFALSE 57044
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
56876: LD_ADDR_VAR 0 9
56880: PUSH
56881: LD_VAR 0 10
56885: PPUSH
56886: LD_VAR 0 8
56890: PPUSH
56891: LD_INT 5
56893: PPUSH
56894: CALL_OW 272
56898: PUSH
56899: LD_VAR 0 11
56903: PPUSH
56904: LD_VAR 0 8
56908: PPUSH
56909: LD_INT 5
56911: PPUSH
56912: CALL_OW 273
56916: PUSH
56917: EMPTY
56918: LIST
56919: LIST
56920: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
56921: LD_VAR 0 9
56925: PUSH
56926: LD_INT 1
56928: ARRAY
56929: PPUSH
56930: LD_VAR 0 9
56934: PUSH
56935: LD_INT 2
56937: ARRAY
56938: PPUSH
56939: CALL_OW 488
56943: IFFALSE 57042
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
56945: LD_ADDR_VAR 0 4
56949: PUSH
56950: LD_VAR 0 9
56954: PUSH
56955: LD_INT 1
56957: ARRAY
56958: PPUSH
56959: LD_VAR 0 9
56963: PUSH
56964: LD_INT 2
56966: ARRAY
56967: PPUSH
56968: CALL_OW 546
56972: ST_TO_ADDR
// if hex [ 1 ] then
56973: LD_VAR 0 4
56977: PUSH
56978: LD_INT 1
56980: ARRAY
56981: IFFALSE 56985
// continue ;
56983: GO 56873
// h := hex [ 2 ] ;
56985: LD_ADDR_VAR 0 13
56989: PUSH
56990: LD_VAR 0 4
56994: PUSH
56995: LD_INT 2
56997: ARRAY
56998: ST_TO_ADDR
// if h + 7 < height then
56999: LD_VAR 0 13
57003: PUSH
57004: LD_INT 7
57006: PLUS
57007: PUSH
57008: LD_VAR 0 15
57012: LESS
57013: IFFALSE 57042
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
57015: LD_ADDR_VAR 0 18
57019: PUSH
57020: LD_INT 7
57022: PUSH
57023: LD_INT 28
57025: PUSH
57026: LD_INT 45
57028: PUSH
57029: EMPTY
57030: LIST
57031: LIST
57032: LIST
57033: PUSH
57034: LD_VAR 0 12
57038: ARRAY
57039: ST_TO_ADDR
// break ;
57040: GO 57044
// end ; end ; end ;
57042: GO 56873
57044: POP
57045: POP
// end ; if not weapon then
57046: LD_VAR 0 18
57050: NOT
57051: IFFALSE 57111
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
57053: LD_ADDR_VAR 0 5
57057: PUSH
57058: LD_VAR 0 5
57062: PUSH
57063: LD_INT 11
57065: PUSH
57066: LD_INT 30
57068: PUSH
57069: LD_INT 49
57071: PUSH
57072: EMPTY
57073: LIST
57074: LIST
57075: LIST
57076: DIFF
57077: ST_TO_ADDR
// if not list then
57078: LD_VAR 0 5
57082: NOT
57083: IFFALSE 57087
// exit ;
57085: GO 57229
// weapon := list [ rand ( 1 , list ) ] ;
57087: LD_ADDR_VAR 0 18
57091: PUSH
57092: LD_VAR 0 5
57096: PUSH
57097: LD_INT 1
57099: PPUSH
57100: LD_VAR 0 5
57104: PPUSH
57105: CALL_OW 12
57109: ARRAY
57110: ST_TO_ADDR
// end ; if weapon then
57111: LD_VAR 0 18
57115: IFFALSE 57229
// begin tmp := CostOfWeapon ( weapon ) ;
57117: LD_ADDR_VAR 0 14
57121: PUSH
57122: LD_VAR 0 18
57126: PPUSH
57127: CALL_OW 451
57131: ST_TO_ADDR
// j := GetBase ( tower ) ;
57132: LD_ADDR_VAR 0 9
57136: PUSH
57137: LD_VAR 0 1
57141: PPUSH
57142: CALL_OW 274
57146: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
57147: LD_VAR 0 9
57151: PPUSH
57152: LD_INT 1
57154: PPUSH
57155: CALL_OW 275
57159: PUSH
57160: LD_VAR 0 14
57164: PUSH
57165: LD_INT 1
57167: ARRAY
57168: GREATEREQUAL
57169: PUSH
57170: LD_VAR 0 9
57174: PPUSH
57175: LD_INT 2
57177: PPUSH
57178: CALL_OW 275
57182: PUSH
57183: LD_VAR 0 14
57187: PUSH
57188: LD_INT 2
57190: ARRAY
57191: GREATEREQUAL
57192: AND
57193: PUSH
57194: LD_VAR 0 9
57198: PPUSH
57199: LD_INT 3
57201: PPUSH
57202: CALL_OW 275
57206: PUSH
57207: LD_VAR 0 14
57211: PUSH
57212: LD_INT 3
57214: ARRAY
57215: GREATEREQUAL
57216: AND
57217: IFFALSE 57229
// result := weapon ;
57219: LD_ADDR_VAR 0 3
57223: PUSH
57224: LD_VAR 0 18
57228: ST_TO_ADDR
// end ; end ;
57229: LD_VAR 0 3
57233: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
57234: LD_INT 0
57236: PPUSH
57237: PPUSH
// result := true ;
57238: LD_ADDR_VAR 0 3
57242: PUSH
57243: LD_INT 1
57245: ST_TO_ADDR
// if array1 = array2 then
57246: LD_VAR 0 1
57250: PUSH
57251: LD_VAR 0 2
57255: EQUAL
57256: IFFALSE 57316
// begin for i = 1 to array1 do
57258: LD_ADDR_VAR 0 4
57262: PUSH
57263: DOUBLE
57264: LD_INT 1
57266: DEC
57267: ST_TO_ADDR
57268: LD_VAR 0 1
57272: PUSH
57273: FOR_TO
57274: IFFALSE 57312
// if array1 [ i ] <> array2 [ i ] then
57276: LD_VAR 0 1
57280: PUSH
57281: LD_VAR 0 4
57285: ARRAY
57286: PUSH
57287: LD_VAR 0 2
57291: PUSH
57292: LD_VAR 0 4
57296: ARRAY
57297: NONEQUAL
57298: IFFALSE 57310
// begin result := false ;
57300: LD_ADDR_VAR 0 3
57304: PUSH
57305: LD_INT 0
57307: ST_TO_ADDR
// break ;
57308: GO 57312
// end ;
57310: GO 57273
57312: POP
57313: POP
// end else
57314: GO 57324
// result := false ;
57316: LD_ADDR_VAR 0 3
57320: PUSH
57321: LD_INT 0
57323: ST_TO_ADDR
// end ;
57324: LD_VAR 0 3
57328: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
57329: LD_INT 0
57331: PPUSH
57332: PPUSH
57333: PPUSH
// pom := GetBase ( fac ) ;
57334: LD_ADDR_VAR 0 5
57338: PUSH
57339: LD_VAR 0 1
57343: PPUSH
57344: CALL_OW 274
57348: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
57349: LD_ADDR_VAR 0 4
57353: PUSH
57354: LD_VAR 0 2
57358: PUSH
57359: LD_INT 1
57361: ARRAY
57362: PPUSH
57363: LD_VAR 0 2
57367: PUSH
57368: LD_INT 2
57370: ARRAY
57371: PPUSH
57372: LD_VAR 0 2
57376: PUSH
57377: LD_INT 3
57379: ARRAY
57380: PPUSH
57381: LD_VAR 0 2
57385: PUSH
57386: LD_INT 4
57388: ARRAY
57389: PPUSH
57390: CALL_OW 449
57394: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
57395: LD_ADDR_VAR 0 3
57399: PUSH
57400: LD_VAR 0 5
57404: PPUSH
57405: LD_INT 1
57407: PPUSH
57408: CALL_OW 275
57412: PUSH
57413: LD_VAR 0 4
57417: PUSH
57418: LD_INT 1
57420: ARRAY
57421: GREATEREQUAL
57422: PUSH
57423: LD_VAR 0 5
57427: PPUSH
57428: LD_INT 2
57430: PPUSH
57431: CALL_OW 275
57435: PUSH
57436: LD_VAR 0 4
57440: PUSH
57441: LD_INT 2
57443: ARRAY
57444: GREATEREQUAL
57445: AND
57446: PUSH
57447: LD_VAR 0 5
57451: PPUSH
57452: LD_INT 3
57454: PPUSH
57455: CALL_OW 275
57459: PUSH
57460: LD_VAR 0 4
57464: PUSH
57465: LD_INT 3
57467: ARRAY
57468: GREATEREQUAL
57469: AND
57470: ST_TO_ADDR
// end ;
57471: LD_VAR 0 3
57475: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
57476: LD_INT 0
57478: PPUSH
57479: PPUSH
57480: PPUSH
57481: PPUSH
// pom := GetBase ( building ) ;
57482: LD_ADDR_VAR 0 3
57486: PUSH
57487: LD_VAR 0 1
57491: PPUSH
57492: CALL_OW 274
57496: ST_TO_ADDR
// if not pom then
57497: LD_VAR 0 3
57501: NOT
57502: IFFALSE 57506
// exit ;
57504: GO 57676
// btype := GetBType ( building ) ;
57506: LD_ADDR_VAR 0 5
57510: PUSH
57511: LD_VAR 0 1
57515: PPUSH
57516: CALL_OW 266
57520: ST_TO_ADDR
// if btype = b_armoury then
57521: LD_VAR 0 5
57525: PUSH
57526: LD_INT 4
57528: EQUAL
57529: IFFALSE 57539
// btype := b_barracks ;
57531: LD_ADDR_VAR 0 5
57535: PUSH
57536: LD_INT 5
57538: ST_TO_ADDR
// if btype = b_depot then
57539: LD_VAR 0 5
57543: PUSH
57544: LD_INT 0
57546: EQUAL
57547: IFFALSE 57557
// btype := b_warehouse ;
57549: LD_ADDR_VAR 0 5
57553: PUSH
57554: LD_INT 1
57556: ST_TO_ADDR
// if btype = b_workshop then
57557: LD_VAR 0 5
57561: PUSH
57562: LD_INT 2
57564: EQUAL
57565: IFFALSE 57575
// btype := b_factory ;
57567: LD_ADDR_VAR 0 5
57571: PUSH
57572: LD_INT 3
57574: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
57575: LD_ADDR_VAR 0 4
57579: PUSH
57580: LD_VAR 0 5
57584: PPUSH
57585: LD_VAR 0 1
57589: PPUSH
57590: CALL_OW 248
57594: PPUSH
57595: CALL_OW 450
57599: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
57600: LD_ADDR_VAR 0 2
57604: PUSH
57605: LD_VAR 0 3
57609: PPUSH
57610: LD_INT 1
57612: PPUSH
57613: CALL_OW 275
57617: PUSH
57618: LD_VAR 0 4
57622: PUSH
57623: LD_INT 1
57625: ARRAY
57626: GREATEREQUAL
57627: PUSH
57628: LD_VAR 0 3
57632: PPUSH
57633: LD_INT 2
57635: PPUSH
57636: CALL_OW 275
57640: PUSH
57641: LD_VAR 0 4
57645: PUSH
57646: LD_INT 2
57648: ARRAY
57649: GREATEREQUAL
57650: AND
57651: PUSH
57652: LD_VAR 0 3
57656: PPUSH
57657: LD_INT 3
57659: PPUSH
57660: CALL_OW 275
57664: PUSH
57665: LD_VAR 0 4
57669: PUSH
57670: LD_INT 3
57672: ARRAY
57673: GREATEREQUAL
57674: AND
57675: ST_TO_ADDR
// end ;
57676: LD_VAR 0 2
57680: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
57681: LD_INT 0
57683: PPUSH
57684: PPUSH
57685: PPUSH
// pom := GetBase ( building ) ;
57686: LD_ADDR_VAR 0 4
57690: PUSH
57691: LD_VAR 0 1
57695: PPUSH
57696: CALL_OW 274
57700: ST_TO_ADDR
// if not pom then
57701: LD_VAR 0 4
57705: NOT
57706: IFFALSE 57710
// exit ;
57708: GO 57811
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
57710: LD_ADDR_VAR 0 5
57714: PUSH
57715: LD_VAR 0 2
57719: PPUSH
57720: LD_VAR 0 1
57724: PPUSH
57725: CALL_OW 248
57729: PPUSH
57730: CALL_OW 450
57734: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
57735: LD_ADDR_VAR 0 3
57739: PUSH
57740: LD_VAR 0 4
57744: PPUSH
57745: LD_INT 1
57747: PPUSH
57748: CALL_OW 275
57752: PUSH
57753: LD_VAR 0 5
57757: PUSH
57758: LD_INT 1
57760: ARRAY
57761: GREATEREQUAL
57762: PUSH
57763: LD_VAR 0 4
57767: PPUSH
57768: LD_INT 2
57770: PPUSH
57771: CALL_OW 275
57775: PUSH
57776: LD_VAR 0 5
57780: PUSH
57781: LD_INT 2
57783: ARRAY
57784: GREATEREQUAL
57785: AND
57786: PUSH
57787: LD_VAR 0 4
57791: PPUSH
57792: LD_INT 3
57794: PPUSH
57795: CALL_OW 275
57799: PUSH
57800: LD_VAR 0 5
57804: PUSH
57805: LD_INT 3
57807: ARRAY
57808: GREATEREQUAL
57809: AND
57810: ST_TO_ADDR
// end ;
57811: LD_VAR 0 3
57815: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
57816: LD_INT 0
57818: PPUSH
57819: PPUSH
57820: PPUSH
57821: PPUSH
57822: PPUSH
57823: PPUSH
57824: PPUSH
57825: PPUSH
57826: PPUSH
57827: PPUSH
// result := false ;
57828: LD_ADDR_VAR 0 6
57832: PUSH
57833: LD_INT 0
57835: ST_TO_ADDR
// if not base or not btype or not x or not y then
57836: LD_VAR 0 1
57840: NOT
57841: PUSH
57842: LD_VAR 0 2
57846: NOT
57847: OR
57848: PUSH
57849: LD_VAR 0 3
57853: NOT
57854: OR
57855: PUSH
57856: LD_VAR 0 4
57860: NOT
57861: OR
57862: IFFALSE 57866
// exit ;
57864: GO 58457
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
57866: LD_ADDR_VAR 0 12
57870: PUSH
57871: LD_VAR 0 2
57875: PPUSH
57876: LD_VAR 0 3
57880: PPUSH
57881: LD_VAR 0 4
57885: PPUSH
57886: LD_VAR 0 5
57890: PPUSH
57891: LD_VAR 0 1
57895: PUSH
57896: LD_INT 1
57898: ARRAY
57899: PPUSH
57900: CALL_OW 248
57904: PPUSH
57905: LD_INT 0
57907: PPUSH
57908: CALL 59294 0 6
57912: ST_TO_ADDR
// if not hexes then
57913: LD_VAR 0 12
57917: NOT
57918: IFFALSE 57922
// exit ;
57920: GO 58457
// for i = 1 to hexes do
57922: LD_ADDR_VAR 0 7
57926: PUSH
57927: DOUBLE
57928: LD_INT 1
57930: DEC
57931: ST_TO_ADDR
57932: LD_VAR 0 12
57936: PUSH
57937: FOR_TO
57938: IFFALSE 58455
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
57940: LD_ADDR_VAR 0 11
57944: PUSH
57945: LD_VAR 0 12
57949: PUSH
57950: LD_VAR 0 7
57954: ARRAY
57955: PUSH
57956: LD_INT 1
57958: ARRAY
57959: PPUSH
57960: LD_VAR 0 12
57964: PUSH
57965: LD_VAR 0 7
57969: ARRAY
57970: PUSH
57971: LD_INT 2
57973: ARRAY
57974: PPUSH
57975: CALL_OW 428
57979: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
57980: LD_VAR 0 12
57984: PUSH
57985: LD_VAR 0 7
57989: ARRAY
57990: PUSH
57991: LD_INT 1
57993: ARRAY
57994: PPUSH
57995: LD_VAR 0 12
57999: PUSH
58000: LD_VAR 0 7
58004: ARRAY
58005: PUSH
58006: LD_INT 2
58008: ARRAY
58009: PPUSH
58010: CALL_OW 351
58014: PUSH
58015: LD_VAR 0 12
58019: PUSH
58020: LD_VAR 0 7
58024: ARRAY
58025: PUSH
58026: LD_INT 1
58028: ARRAY
58029: PPUSH
58030: LD_VAR 0 12
58034: PUSH
58035: LD_VAR 0 7
58039: ARRAY
58040: PUSH
58041: LD_INT 2
58043: ARRAY
58044: PPUSH
58045: CALL_OW 488
58049: NOT
58050: OR
58051: PUSH
58052: LD_VAR 0 11
58056: PPUSH
58057: CALL_OW 247
58061: PUSH
58062: LD_INT 3
58064: EQUAL
58065: OR
58066: IFFALSE 58072
// exit ;
58068: POP
58069: POP
58070: GO 58457
// if not tmp then
58072: LD_VAR 0 11
58076: NOT
58077: IFFALSE 58081
// continue ;
58079: GO 57937
// result := true ;
58081: LD_ADDR_VAR 0 6
58085: PUSH
58086: LD_INT 1
58088: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
58089: LD_ADDR_VAR 0 15
58093: PUSH
58094: LD_INT 22
58096: PUSH
58097: LD_VAR 0 11
58101: PPUSH
58102: CALL_OW 255
58106: PUSH
58107: EMPTY
58108: LIST
58109: LIST
58110: PUSH
58111: LD_INT 2
58113: PUSH
58114: LD_INT 30
58116: PUSH
58117: LD_INT 0
58119: PUSH
58120: EMPTY
58121: LIST
58122: LIST
58123: PUSH
58124: LD_INT 30
58126: PUSH
58127: LD_INT 1
58129: PUSH
58130: EMPTY
58131: LIST
58132: LIST
58133: PUSH
58134: EMPTY
58135: LIST
58136: LIST
58137: LIST
58138: PUSH
58139: EMPTY
58140: LIST
58141: LIST
58142: PPUSH
58143: CALL_OW 69
58147: ST_TO_ADDR
// if dep then
58148: LD_VAR 0 15
58152: IFFALSE 58288
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
58154: LD_ADDR_VAR 0 14
58158: PUSH
58159: LD_VAR 0 15
58163: PUSH
58164: LD_INT 1
58166: ARRAY
58167: PPUSH
58168: CALL_OW 250
58172: PPUSH
58173: LD_VAR 0 15
58177: PUSH
58178: LD_INT 1
58180: ARRAY
58181: PPUSH
58182: CALL_OW 254
58186: PPUSH
58187: LD_INT 5
58189: PPUSH
58190: CALL_OW 272
58194: PUSH
58195: LD_VAR 0 15
58199: PUSH
58200: LD_INT 1
58202: ARRAY
58203: PPUSH
58204: CALL_OW 251
58208: PPUSH
58209: LD_VAR 0 15
58213: PUSH
58214: LD_INT 1
58216: ARRAY
58217: PPUSH
58218: CALL_OW 254
58222: PPUSH
58223: LD_INT 5
58225: PPUSH
58226: CALL_OW 273
58230: PUSH
58231: EMPTY
58232: LIST
58233: LIST
58234: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
58235: LD_VAR 0 14
58239: PUSH
58240: LD_INT 1
58242: ARRAY
58243: PPUSH
58244: LD_VAR 0 14
58248: PUSH
58249: LD_INT 2
58251: ARRAY
58252: PPUSH
58253: CALL_OW 488
58257: IFFALSE 58288
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
58259: LD_VAR 0 11
58263: PPUSH
58264: LD_VAR 0 14
58268: PUSH
58269: LD_INT 1
58271: ARRAY
58272: PPUSH
58273: LD_VAR 0 14
58277: PUSH
58278: LD_INT 2
58280: ARRAY
58281: PPUSH
58282: CALL_OW 111
// continue ;
58286: GO 57937
// end ; end ; r := GetDir ( tmp ) ;
58288: LD_ADDR_VAR 0 13
58292: PUSH
58293: LD_VAR 0 11
58297: PPUSH
58298: CALL_OW 254
58302: ST_TO_ADDR
// if r = 5 then
58303: LD_VAR 0 13
58307: PUSH
58308: LD_INT 5
58310: EQUAL
58311: IFFALSE 58321
// r := 0 ;
58313: LD_ADDR_VAR 0 13
58317: PUSH
58318: LD_INT 0
58320: ST_TO_ADDR
// for j = r to 5 do
58321: LD_ADDR_VAR 0 8
58325: PUSH
58326: DOUBLE
58327: LD_VAR 0 13
58331: DEC
58332: ST_TO_ADDR
58333: LD_INT 5
58335: PUSH
58336: FOR_TO
58337: IFFALSE 58451
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
58339: LD_ADDR_VAR 0 9
58343: PUSH
58344: LD_VAR 0 11
58348: PPUSH
58349: CALL_OW 250
58353: PPUSH
58354: LD_VAR 0 8
58358: PPUSH
58359: LD_INT 2
58361: PPUSH
58362: CALL_OW 272
58366: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
58367: LD_ADDR_VAR 0 10
58371: PUSH
58372: LD_VAR 0 11
58376: PPUSH
58377: CALL_OW 251
58381: PPUSH
58382: LD_VAR 0 8
58386: PPUSH
58387: LD_INT 2
58389: PPUSH
58390: CALL_OW 273
58394: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
58395: LD_VAR 0 9
58399: PPUSH
58400: LD_VAR 0 10
58404: PPUSH
58405: CALL_OW 488
58409: PUSH
58410: LD_VAR 0 9
58414: PPUSH
58415: LD_VAR 0 10
58419: PPUSH
58420: CALL_OW 428
58424: NOT
58425: AND
58426: IFFALSE 58449
// begin ComMoveXY ( tmp , _x , _y ) ;
58428: LD_VAR 0 11
58432: PPUSH
58433: LD_VAR 0 9
58437: PPUSH
58438: LD_VAR 0 10
58442: PPUSH
58443: CALL_OW 111
// break ;
58447: GO 58451
// end ; end ;
58449: GO 58336
58451: POP
58452: POP
// end ;
58453: GO 57937
58455: POP
58456: POP
// end ;
58457: LD_VAR 0 6
58461: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
58462: LD_INT 0
58464: PPUSH
58465: PPUSH
58466: PPUSH
58467: PPUSH
58468: PPUSH
58469: PPUSH
58470: PPUSH
58471: PPUSH
58472: PPUSH
58473: PPUSH
// result := false ;
58474: LD_ADDR_VAR 0 6
58478: PUSH
58479: LD_INT 0
58481: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
58482: LD_VAR 0 1
58486: NOT
58487: PUSH
58488: LD_VAR 0 1
58492: PPUSH
58493: CALL_OW 266
58497: PUSH
58498: LD_INT 0
58500: PUSH
58501: LD_INT 1
58503: PUSH
58504: EMPTY
58505: LIST
58506: LIST
58507: IN
58508: NOT
58509: OR
58510: PUSH
58511: LD_VAR 0 2
58515: NOT
58516: OR
58517: PUSH
58518: LD_VAR 0 5
58522: PUSH
58523: LD_INT 0
58525: PUSH
58526: LD_INT 1
58528: PUSH
58529: LD_INT 2
58531: PUSH
58532: LD_INT 3
58534: PUSH
58535: LD_INT 4
58537: PUSH
58538: LD_INT 5
58540: PUSH
58541: EMPTY
58542: LIST
58543: LIST
58544: LIST
58545: LIST
58546: LIST
58547: LIST
58548: IN
58549: NOT
58550: OR
58551: PUSH
58552: LD_VAR 0 3
58556: PPUSH
58557: LD_VAR 0 4
58561: PPUSH
58562: CALL_OW 488
58566: NOT
58567: OR
58568: IFFALSE 58572
// exit ;
58570: GO 59289
// pom := GetBase ( bdepot ) ;
58572: LD_ADDR_VAR 0 10
58576: PUSH
58577: LD_VAR 0 1
58581: PPUSH
58582: CALL_OW 274
58586: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
58587: LD_ADDR_VAR 0 11
58591: PUSH
58592: LD_VAR 0 2
58596: PPUSH
58597: LD_VAR 0 1
58601: PPUSH
58602: CALL_OW 248
58606: PPUSH
58607: CALL_OW 450
58611: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
58612: LD_VAR 0 10
58616: PPUSH
58617: LD_INT 1
58619: PPUSH
58620: CALL_OW 275
58624: PUSH
58625: LD_VAR 0 11
58629: PUSH
58630: LD_INT 1
58632: ARRAY
58633: GREATEREQUAL
58634: PUSH
58635: LD_VAR 0 10
58639: PPUSH
58640: LD_INT 2
58642: PPUSH
58643: CALL_OW 275
58647: PUSH
58648: LD_VAR 0 11
58652: PUSH
58653: LD_INT 2
58655: ARRAY
58656: GREATEREQUAL
58657: AND
58658: PUSH
58659: LD_VAR 0 10
58663: PPUSH
58664: LD_INT 3
58666: PPUSH
58667: CALL_OW 275
58671: PUSH
58672: LD_VAR 0 11
58676: PUSH
58677: LD_INT 3
58679: ARRAY
58680: GREATEREQUAL
58681: AND
58682: NOT
58683: IFFALSE 58687
// exit ;
58685: GO 59289
// if GetBType ( bdepot ) = b_depot then
58687: LD_VAR 0 1
58691: PPUSH
58692: CALL_OW 266
58696: PUSH
58697: LD_INT 0
58699: EQUAL
58700: IFFALSE 58712
// dist := 28 else
58702: LD_ADDR_VAR 0 14
58706: PUSH
58707: LD_INT 28
58709: ST_TO_ADDR
58710: GO 58720
// dist := 36 ;
58712: LD_ADDR_VAR 0 14
58716: PUSH
58717: LD_INT 36
58719: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
58720: LD_VAR 0 1
58724: PPUSH
58725: LD_VAR 0 3
58729: PPUSH
58730: LD_VAR 0 4
58734: PPUSH
58735: CALL_OW 297
58739: PUSH
58740: LD_VAR 0 14
58744: GREATER
58745: IFFALSE 58749
// exit ;
58747: GO 59289
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
58749: LD_ADDR_VAR 0 12
58753: PUSH
58754: LD_VAR 0 2
58758: PPUSH
58759: LD_VAR 0 3
58763: PPUSH
58764: LD_VAR 0 4
58768: PPUSH
58769: LD_VAR 0 5
58773: PPUSH
58774: LD_VAR 0 1
58778: PPUSH
58779: CALL_OW 248
58783: PPUSH
58784: LD_INT 0
58786: PPUSH
58787: CALL 59294 0 6
58791: ST_TO_ADDR
// if not hexes then
58792: LD_VAR 0 12
58796: NOT
58797: IFFALSE 58801
// exit ;
58799: GO 59289
// hex := GetHexInfo ( x , y ) ;
58801: LD_ADDR_VAR 0 15
58805: PUSH
58806: LD_VAR 0 3
58810: PPUSH
58811: LD_VAR 0 4
58815: PPUSH
58816: CALL_OW 546
58820: ST_TO_ADDR
// if hex [ 1 ] then
58821: LD_VAR 0 15
58825: PUSH
58826: LD_INT 1
58828: ARRAY
58829: IFFALSE 58833
// exit ;
58831: GO 59289
// height := hex [ 2 ] ;
58833: LD_ADDR_VAR 0 13
58837: PUSH
58838: LD_VAR 0 15
58842: PUSH
58843: LD_INT 2
58845: ARRAY
58846: ST_TO_ADDR
// for i = 1 to hexes do
58847: LD_ADDR_VAR 0 7
58851: PUSH
58852: DOUBLE
58853: LD_INT 1
58855: DEC
58856: ST_TO_ADDR
58857: LD_VAR 0 12
58861: PUSH
58862: FOR_TO
58863: IFFALSE 59193
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
58865: LD_VAR 0 12
58869: PUSH
58870: LD_VAR 0 7
58874: ARRAY
58875: PUSH
58876: LD_INT 1
58878: ARRAY
58879: PPUSH
58880: LD_VAR 0 12
58884: PUSH
58885: LD_VAR 0 7
58889: ARRAY
58890: PUSH
58891: LD_INT 2
58893: ARRAY
58894: PPUSH
58895: CALL_OW 488
58899: NOT
58900: PUSH
58901: LD_VAR 0 12
58905: PUSH
58906: LD_VAR 0 7
58910: ARRAY
58911: PUSH
58912: LD_INT 1
58914: ARRAY
58915: PPUSH
58916: LD_VAR 0 12
58920: PUSH
58921: LD_VAR 0 7
58925: ARRAY
58926: PUSH
58927: LD_INT 2
58929: ARRAY
58930: PPUSH
58931: CALL_OW 428
58935: PUSH
58936: LD_INT 0
58938: GREATER
58939: OR
58940: PUSH
58941: LD_VAR 0 12
58945: PUSH
58946: LD_VAR 0 7
58950: ARRAY
58951: PUSH
58952: LD_INT 1
58954: ARRAY
58955: PPUSH
58956: LD_VAR 0 12
58960: PUSH
58961: LD_VAR 0 7
58965: ARRAY
58966: PUSH
58967: LD_INT 2
58969: ARRAY
58970: PPUSH
58971: CALL_OW 351
58975: OR
58976: IFFALSE 58982
// exit ;
58978: POP
58979: POP
58980: GO 59289
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
58982: LD_ADDR_VAR 0 8
58986: PUSH
58987: LD_VAR 0 12
58991: PUSH
58992: LD_VAR 0 7
58996: ARRAY
58997: PUSH
58998: LD_INT 1
59000: ARRAY
59001: PPUSH
59002: LD_VAR 0 12
59006: PUSH
59007: LD_VAR 0 7
59011: ARRAY
59012: PUSH
59013: LD_INT 2
59015: ARRAY
59016: PPUSH
59017: CALL_OW 546
59021: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
59022: LD_VAR 0 8
59026: PUSH
59027: LD_INT 1
59029: ARRAY
59030: PUSH
59031: LD_VAR 0 8
59035: PUSH
59036: LD_INT 2
59038: ARRAY
59039: PUSH
59040: LD_VAR 0 13
59044: PUSH
59045: LD_INT 2
59047: PLUS
59048: GREATER
59049: OR
59050: PUSH
59051: LD_VAR 0 8
59055: PUSH
59056: LD_INT 2
59058: ARRAY
59059: PUSH
59060: LD_VAR 0 13
59064: PUSH
59065: LD_INT 2
59067: MINUS
59068: LESS
59069: OR
59070: PUSH
59071: LD_VAR 0 8
59075: PUSH
59076: LD_INT 3
59078: ARRAY
59079: PUSH
59080: LD_INT 0
59082: PUSH
59083: LD_INT 8
59085: PUSH
59086: LD_INT 9
59088: PUSH
59089: LD_INT 10
59091: PUSH
59092: LD_INT 11
59094: PUSH
59095: LD_INT 12
59097: PUSH
59098: LD_INT 13
59100: PUSH
59101: LD_INT 16
59103: PUSH
59104: LD_INT 17
59106: PUSH
59107: LD_INT 18
59109: PUSH
59110: LD_INT 19
59112: PUSH
59113: LD_INT 20
59115: PUSH
59116: LD_INT 21
59118: PUSH
59119: EMPTY
59120: LIST
59121: LIST
59122: LIST
59123: LIST
59124: LIST
59125: LIST
59126: LIST
59127: LIST
59128: LIST
59129: LIST
59130: LIST
59131: LIST
59132: LIST
59133: IN
59134: NOT
59135: OR
59136: PUSH
59137: LD_VAR 0 8
59141: PUSH
59142: LD_INT 5
59144: ARRAY
59145: NOT
59146: OR
59147: PUSH
59148: LD_VAR 0 8
59152: PUSH
59153: LD_INT 6
59155: ARRAY
59156: PUSH
59157: LD_INT 1
59159: PUSH
59160: LD_INT 2
59162: PUSH
59163: LD_INT 7
59165: PUSH
59166: LD_INT 9
59168: PUSH
59169: LD_INT 10
59171: PUSH
59172: LD_INT 11
59174: PUSH
59175: EMPTY
59176: LIST
59177: LIST
59178: LIST
59179: LIST
59180: LIST
59181: LIST
59182: IN
59183: NOT
59184: OR
59185: IFFALSE 59191
// exit ;
59187: POP
59188: POP
59189: GO 59289
// end ;
59191: GO 58862
59193: POP
59194: POP
// side := GetSide ( bdepot ) ;
59195: LD_ADDR_VAR 0 9
59199: PUSH
59200: LD_VAR 0 1
59204: PPUSH
59205: CALL_OW 255
59209: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
59210: LD_VAR 0 9
59214: PPUSH
59215: LD_VAR 0 3
59219: PPUSH
59220: LD_VAR 0 4
59224: PPUSH
59225: LD_INT 20
59227: PPUSH
59228: CALL 51961 0 4
59232: PUSH
59233: LD_INT 4
59235: ARRAY
59236: IFFALSE 59240
// exit ;
59238: GO 59289
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
59240: LD_VAR 0 2
59244: PUSH
59245: LD_INT 29
59247: PUSH
59248: LD_INT 30
59250: PUSH
59251: EMPTY
59252: LIST
59253: LIST
59254: IN
59255: PUSH
59256: LD_VAR 0 3
59260: PPUSH
59261: LD_VAR 0 4
59265: PPUSH
59266: LD_VAR 0 9
59270: PPUSH
59271: CALL_OW 440
59275: NOT
59276: AND
59277: IFFALSE 59281
// exit ;
59279: GO 59289
// result := true ;
59281: LD_ADDR_VAR 0 6
59285: PUSH
59286: LD_INT 1
59288: ST_TO_ADDR
// end ;
59289: LD_VAR 0 6
59293: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
59294: LD_INT 0
59296: PPUSH
59297: PPUSH
59298: PPUSH
59299: PPUSH
59300: PPUSH
59301: PPUSH
59302: PPUSH
59303: PPUSH
59304: PPUSH
59305: PPUSH
59306: PPUSH
59307: PPUSH
59308: PPUSH
59309: PPUSH
59310: PPUSH
59311: PPUSH
59312: PPUSH
59313: PPUSH
59314: PPUSH
59315: PPUSH
59316: PPUSH
59317: PPUSH
59318: PPUSH
59319: PPUSH
59320: PPUSH
59321: PPUSH
59322: PPUSH
59323: PPUSH
59324: PPUSH
59325: PPUSH
59326: PPUSH
59327: PPUSH
59328: PPUSH
59329: PPUSH
59330: PPUSH
59331: PPUSH
59332: PPUSH
59333: PPUSH
59334: PPUSH
59335: PPUSH
59336: PPUSH
59337: PPUSH
59338: PPUSH
59339: PPUSH
59340: PPUSH
59341: PPUSH
59342: PPUSH
59343: PPUSH
59344: PPUSH
59345: PPUSH
59346: PPUSH
59347: PPUSH
59348: PPUSH
59349: PPUSH
59350: PPUSH
59351: PPUSH
59352: PPUSH
59353: PPUSH
// result = [ ] ;
59354: LD_ADDR_VAR 0 7
59358: PUSH
59359: EMPTY
59360: ST_TO_ADDR
// temp_list = [ ] ;
59361: LD_ADDR_VAR 0 9
59365: PUSH
59366: EMPTY
59367: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
59368: LD_VAR 0 4
59372: PUSH
59373: LD_INT 0
59375: PUSH
59376: LD_INT 1
59378: PUSH
59379: LD_INT 2
59381: PUSH
59382: LD_INT 3
59384: PUSH
59385: LD_INT 4
59387: PUSH
59388: LD_INT 5
59390: PUSH
59391: EMPTY
59392: LIST
59393: LIST
59394: LIST
59395: LIST
59396: LIST
59397: LIST
59398: IN
59399: NOT
59400: PUSH
59401: LD_VAR 0 1
59405: PUSH
59406: LD_INT 0
59408: PUSH
59409: LD_INT 1
59411: PUSH
59412: EMPTY
59413: LIST
59414: LIST
59415: IN
59416: PUSH
59417: LD_VAR 0 5
59421: PUSH
59422: LD_INT 1
59424: PUSH
59425: LD_INT 2
59427: PUSH
59428: LD_INT 3
59430: PUSH
59431: EMPTY
59432: LIST
59433: LIST
59434: LIST
59435: IN
59436: NOT
59437: AND
59438: OR
59439: IFFALSE 59443
// exit ;
59441: GO 77828
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
59443: LD_VAR 0 1
59447: PUSH
59448: LD_INT 6
59450: PUSH
59451: LD_INT 7
59453: PUSH
59454: LD_INT 8
59456: PUSH
59457: LD_INT 13
59459: PUSH
59460: LD_INT 12
59462: PUSH
59463: LD_INT 15
59465: PUSH
59466: LD_INT 11
59468: PUSH
59469: LD_INT 14
59471: PUSH
59472: LD_INT 10
59474: PUSH
59475: EMPTY
59476: LIST
59477: LIST
59478: LIST
59479: LIST
59480: LIST
59481: LIST
59482: LIST
59483: LIST
59484: LIST
59485: IN
59486: IFFALSE 59496
// btype = b_lab ;
59488: LD_ADDR_VAR 0 1
59492: PUSH
59493: LD_INT 6
59495: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
59496: LD_VAR 0 6
59500: PUSH
59501: LD_INT 0
59503: PUSH
59504: LD_INT 1
59506: PUSH
59507: LD_INT 2
59509: PUSH
59510: EMPTY
59511: LIST
59512: LIST
59513: LIST
59514: IN
59515: NOT
59516: PUSH
59517: LD_VAR 0 1
59521: PUSH
59522: LD_INT 0
59524: PUSH
59525: LD_INT 1
59527: PUSH
59528: LD_INT 2
59530: PUSH
59531: LD_INT 3
59533: PUSH
59534: LD_INT 6
59536: PUSH
59537: LD_INT 36
59539: PUSH
59540: LD_INT 4
59542: PUSH
59543: LD_INT 5
59545: PUSH
59546: LD_INT 31
59548: PUSH
59549: LD_INT 32
59551: PUSH
59552: LD_INT 33
59554: PUSH
59555: EMPTY
59556: LIST
59557: LIST
59558: LIST
59559: LIST
59560: LIST
59561: LIST
59562: LIST
59563: LIST
59564: LIST
59565: LIST
59566: LIST
59567: IN
59568: NOT
59569: PUSH
59570: LD_VAR 0 6
59574: PUSH
59575: LD_INT 1
59577: EQUAL
59578: AND
59579: OR
59580: PUSH
59581: LD_VAR 0 1
59585: PUSH
59586: LD_INT 2
59588: PUSH
59589: LD_INT 3
59591: PUSH
59592: EMPTY
59593: LIST
59594: LIST
59595: IN
59596: NOT
59597: PUSH
59598: LD_VAR 0 6
59602: PUSH
59603: LD_INT 2
59605: EQUAL
59606: AND
59607: OR
59608: IFFALSE 59618
// mode = 0 ;
59610: LD_ADDR_VAR 0 6
59614: PUSH
59615: LD_INT 0
59617: ST_TO_ADDR
// case mode of 0 :
59618: LD_VAR 0 6
59622: PUSH
59623: LD_INT 0
59625: DOUBLE
59626: EQUAL
59627: IFTRUE 59631
59629: GO 71084
59631: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
59632: LD_ADDR_VAR 0 11
59636: PUSH
59637: LD_INT 0
59639: PUSH
59640: LD_INT 0
59642: PUSH
59643: EMPTY
59644: LIST
59645: LIST
59646: PUSH
59647: LD_INT 0
59649: PUSH
59650: LD_INT 1
59652: NEG
59653: PUSH
59654: EMPTY
59655: LIST
59656: LIST
59657: PUSH
59658: LD_INT 1
59660: PUSH
59661: LD_INT 0
59663: PUSH
59664: EMPTY
59665: LIST
59666: LIST
59667: PUSH
59668: LD_INT 1
59670: PUSH
59671: LD_INT 1
59673: PUSH
59674: EMPTY
59675: LIST
59676: LIST
59677: PUSH
59678: LD_INT 0
59680: PUSH
59681: LD_INT 1
59683: PUSH
59684: EMPTY
59685: LIST
59686: LIST
59687: PUSH
59688: LD_INT 1
59690: NEG
59691: PUSH
59692: LD_INT 0
59694: PUSH
59695: EMPTY
59696: LIST
59697: LIST
59698: PUSH
59699: LD_INT 1
59701: NEG
59702: PUSH
59703: LD_INT 1
59705: NEG
59706: PUSH
59707: EMPTY
59708: LIST
59709: LIST
59710: PUSH
59711: LD_INT 1
59713: NEG
59714: PUSH
59715: LD_INT 2
59717: NEG
59718: PUSH
59719: EMPTY
59720: LIST
59721: LIST
59722: PUSH
59723: LD_INT 0
59725: PUSH
59726: LD_INT 2
59728: NEG
59729: PUSH
59730: EMPTY
59731: LIST
59732: LIST
59733: PUSH
59734: LD_INT 1
59736: PUSH
59737: LD_INT 1
59739: NEG
59740: PUSH
59741: EMPTY
59742: LIST
59743: LIST
59744: PUSH
59745: LD_INT 1
59747: PUSH
59748: LD_INT 2
59750: PUSH
59751: EMPTY
59752: LIST
59753: LIST
59754: PUSH
59755: LD_INT 0
59757: PUSH
59758: LD_INT 2
59760: PUSH
59761: EMPTY
59762: LIST
59763: LIST
59764: PUSH
59765: LD_INT 1
59767: NEG
59768: PUSH
59769: LD_INT 1
59771: PUSH
59772: EMPTY
59773: LIST
59774: LIST
59775: PUSH
59776: LD_INT 1
59778: PUSH
59779: LD_INT 3
59781: PUSH
59782: EMPTY
59783: LIST
59784: LIST
59785: PUSH
59786: LD_INT 0
59788: PUSH
59789: LD_INT 3
59791: PUSH
59792: EMPTY
59793: LIST
59794: LIST
59795: PUSH
59796: LD_INT 1
59798: NEG
59799: PUSH
59800: LD_INT 2
59802: PUSH
59803: EMPTY
59804: LIST
59805: LIST
59806: PUSH
59807: EMPTY
59808: LIST
59809: LIST
59810: LIST
59811: LIST
59812: LIST
59813: LIST
59814: LIST
59815: LIST
59816: LIST
59817: LIST
59818: LIST
59819: LIST
59820: LIST
59821: LIST
59822: LIST
59823: LIST
59824: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
59825: LD_ADDR_VAR 0 12
59829: PUSH
59830: LD_INT 0
59832: PUSH
59833: LD_INT 0
59835: PUSH
59836: EMPTY
59837: LIST
59838: LIST
59839: PUSH
59840: LD_INT 0
59842: PUSH
59843: LD_INT 1
59845: NEG
59846: PUSH
59847: EMPTY
59848: LIST
59849: LIST
59850: PUSH
59851: LD_INT 1
59853: PUSH
59854: LD_INT 0
59856: PUSH
59857: EMPTY
59858: LIST
59859: LIST
59860: PUSH
59861: LD_INT 1
59863: PUSH
59864: LD_INT 1
59866: PUSH
59867: EMPTY
59868: LIST
59869: LIST
59870: PUSH
59871: LD_INT 0
59873: PUSH
59874: LD_INT 1
59876: PUSH
59877: EMPTY
59878: LIST
59879: LIST
59880: PUSH
59881: LD_INT 1
59883: NEG
59884: PUSH
59885: LD_INT 0
59887: PUSH
59888: EMPTY
59889: LIST
59890: LIST
59891: PUSH
59892: LD_INT 1
59894: NEG
59895: PUSH
59896: LD_INT 1
59898: NEG
59899: PUSH
59900: EMPTY
59901: LIST
59902: LIST
59903: PUSH
59904: LD_INT 1
59906: PUSH
59907: LD_INT 1
59909: NEG
59910: PUSH
59911: EMPTY
59912: LIST
59913: LIST
59914: PUSH
59915: LD_INT 2
59917: PUSH
59918: LD_INT 0
59920: PUSH
59921: EMPTY
59922: LIST
59923: LIST
59924: PUSH
59925: LD_INT 2
59927: PUSH
59928: LD_INT 1
59930: PUSH
59931: EMPTY
59932: LIST
59933: LIST
59934: PUSH
59935: LD_INT 1
59937: NEG
59938: PUSH
59939: LD_INT 1
59941: PUSH
59942: EMPTY
59943: LIST
59944: LIST
59945: PUSH
59946: LD_INT 2
59948: NEG
59949: PUSH
59950: LD_INT 0
59952: PUSH
59953: EMPTY
59954: LIST
59955: LIST
59956: PUSH
59957: LD_INT 2
59959: NEG
59960: PUSH
59961: LD_INT 1
59963: NEG
59964: PUSH
59965: EMPTY
59966: LIST
59967: LIST
59968: PUSH
59969: LD_INT 2
59971: NEG
59972: PUSH
59973: LD_INT 1
59975: PUSH
59976: EMPTY
59977: LIST
59978: LIST
59979: PUSH
59980: LD_INT 3
59982: NEG
59983: PUSH
59984: LD_INT 0
59986: PUSH
59987: EMPTY
59988: LIST
59989: LIST
59990: PUSH
59991: LD_INT 3
59993: NEG
59994: PUSH
59995: LD_INT 1
59997: NEG
59998: PUSH
59999: EMPTY
60000: LIST
60001: LIST
60002: PUSH
60003: EMPTY
60004: LIST
60005: LIST
60006: LIST
60007: LIST
60008: LIST
60009: LIST
60010: LIST
60011: LIST
60012: LIST
60013: LIST
60014: LIST
60015: LIST
60016: LIST
60017: LIST
60018: LIST
60019: LIST
60020: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
60021: LD_ADDR_VAR 0 13
60025: PUSH
60026: LD_INT 0
60028: PUSH
60029: LD_INT 0
60031: PUSH
60032: EMPTY
60033: LIST
60034: LIST
60035: PUSH
60036: LD_INT 0
60038: PUSH
60039: LD_INT 1
60041: NEG
60042: PUSH
60043: EMPTY
60044: LIST
60045: LIST
60046: PUSH
60047: LD_INT 1
60049: PUSH
60050: LD_INT 0
60052: PUSH
60053: EMPTY
60054: LIST
60055: LIST
60056: PUSH
60057: LD_INT 1
60059: PUSH
60060: LD_INT 1
60062: PUSH
60063: EMPTY
60064: LIST
60065: LIST
60066: PUSH
60067: LD_INT 0
60069: PUSH
60070: LD_INT 1
60072: PUSH
60073: EMPTY
60074: LIST
60075: LIST
60076: PUSH
60077: LD_INT 1
60079: NEG
60080: PUSH
60081: LD_INT 0
60083: PUSH
60084: EMPTY
60085: LIST
60086: LIST
60087: PUSH
60088: LD_INT 1
60090: NEG
60091: PUSH
60092: LD_INT 1
60094: NEG
60095: PUSH
60096: EMPTY
60097: LIST
60098: LIST
60099: PUSH
60100: LD_INT 1
60102: NEG
60103: PUSH
60104: LD_INT 2
60106: NEG
60107: PUSH
60108: EMPTY
60109: LIST
60110: LIST
60111: PUSH
60112: LD_INT 2
60114: PUSH
60115: LD_INT 1
60117: PUSH
60118: EMPTY
60119: LIST
60120: LIST
60121: PUSH
60122: LD_INT 2
60124: PUSH
60125: LD_INT 2
60127: PUSH
60128: EMPTY
60129: LIST
60130: LIST
60131: PUSH
60132: LD_INT 1
60134: PUSH
60135: LD_INT 2
60137: PUSH
60138: EMPTY
60139: LIST
60140: LIST
60141: PUSH
60142: LD_INT 2
60144: NEG
60145: PUSH
60146: LD_INT 1
60148: NEG
60149: PUSH
60150: EMPTY
60151: LIST
60152: LIST
60153: PUSH
60154: LD_INT 2
60156: NEG
60157: PUSH
60158: LD_INT 2
60160: NEG
60161: PUSH
60162: EMPTY
60163: LIST
60164: LIST
60165: PUSH
60166: LD_INT 2
60168: NEG
60169: PUSH
60170: LD_INT 3
60172: NEG
60173: PUSH
60174: EMPTY
60175: LIST
60176: LIST
60177: PUSH
60178: LD_INT 3
60180: NEG
60181: PUSH
60182: LD_INT 2
60184: NEG
60185: PUSH
60186: EMPTY
60187: LIST
60188: LIST
60189: PUSH
60190: LD_INT 3
60192: NEG
60193: PUSH
60194: LD_INT 3
60196: NEG
60197: PUSH
60198: EMPTY
60199: LIST
60200: LIST
60201: PUSH
60202: EMPTY
60203: LIST
60204: LIST
60205: LIST
60206: LIST
60207: LIST
60208: LIST
60209: LIST
60210: LIST
60211: LIST
60212: LIST
60213: LIST
60214: LIST
60215: LIST
60216: LIST
60217: LIST
60218: LIST
60219: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
60220: LD_ADDR_VAR 0 14
60224: PUSH
60225: LD_INT 0
60227: PUSH
60228: LD_INT 0
60230: PUSH
60231: EMPTY
60232: LIST
60233: LIST
60234: PUSH
60235: LD_INT 0
60237: PUSH
60238: LD_INT 1
60240: NEG
60241: PUSH
60242: EMPTY
60243: LIST
60244: LIST
60245: PUSH
60246: LD_INT 1
60248: PUSH
60249: LD_INT 0
60251: PUSH
60252: EMPTY
60253: LIST
60254: LIST
60255: PUSH
60256: LD_INT 1
60258: PUSH
60259: LD_INT 1
60261: PUSH
60262: EMPTY
60263: LIST
60264: LIST
60265: PUSH
60266: LD_INT 0
60268: PUSH
60269: LD_INT 1
60271: PUSH
60272: EMPTY
60273: LIST
60274: LIST
60275: PUSH
60276: LD_INT 1
60278: NEG
60279: PUSH
60280: LD_INT 0
60282: PUSH
60283: EMPTY
60284: LIST
60285: LIST
60286: PUSH
60287: LD_INT 1
60289: NEG
60290: PUSH
60291: LD_INT 1
60293: NEG
60294: PUSH
60295: EMPTY
60296: LIST
60297: LIST
60298: PUSH
60299: LD_INT 1
60301: NEG
60302: PUSH
60303: LD_INT 2
60305: NEG
60306: PUSH
60307: EMPTY
60308: LIST
60309: LIST
60310: PUSH
60311: LD_INT 0
60313: PUSH
60314: LD_INT 2
60316: NEG
60317: PUSH
60318: EMPTY
60319: LIST
60320: LIST
60321: PUSH
60322: LD_INT 1
60324: PUSH
60325: LD_INT 1
60327: NEG
60328: PUSH
60329: EMPTY
60330: LIST
60331: LIST
60332: PUSH
60333: LD_INT 1
60335: PUSH
60336: LD_INT 2
60338: PUSH
60339: EMPTY
60340: LIST
60341: LIST
60342: PUSH
60343: LD_INT 0
60345: PUSH
60346: LD_INT 2
60348: PUSH
60349: EMPTY
60350: LIST
60351: LIST
60352: PUSH
60353: LD_INT 1
60355: NEG
60356: PUSH
60357: LD_INT 1
60359: PUSH
60360: EMPTY
60361: LIST
60362: LIST
60363: PUSH
60364: LD_INT 1
60366: NEG
60367: PUSH
60368: LD_INT 3
60370: NEG
60371: PUSH
60372: EMPTY
60373: LIST
60374: LIST
60375: PUSH
60376: LD_INT 0
60378: PUSH
60379: LD_INT 3
60381: NEG
60382: PUSH
60383: EMPTY
60384: LIST
60385: LIST
60386: PUSH
60387: LD_INT 1
60389: PUSH
60390: LD_INT 2
60392: NEG
60393: PUSH
60394: EMPTY
60395: LIST
60396: LIST
60397: PUSH
60398: EMPTY
60399: LIST
60400: LIST
60401: LIST
60402: LIST
60403: LIST
60404: LIST
60405: LIST
60406: LIST
60407: LIST
60408: LIST
60409: LIST
60410: LIST
60411: LIST
60412: LIST
60413: LIST
60414: LIST
60415: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
60416: LD_ADDR_VAR 0 15
60420: PUSH
60421: LD_INT 0
60423: PUSH
60424: LD_INT 0
60426: PUSH
60427: EMPTY
60428: LIST
60429: LIST
60430: PUSH
60431: LD_INT 0
60433: PUSH
60434: LD_INT 1
60436: NEG
60437: PUSH
60438: EMPTY
60439: LIST
60440: LIST
60441: PUSH
60442: LD_INT 1
60444: PUSH
60445: LD_INT 0
60447: PUSH
60448: EMPTY
60449: LIST
60450: LIST
60451: PUSH
60452: LD_INT 1
60454: PUSH
60455: LD_INT 1
60457: PUSH
60458: EMPTY
60459: LIST
60460: LIST
60461: PUSH
60462: LD_INT 0
60464: PUSH
60465: LD_INT 1
60467: PUSH
60468: EMPTY
60469: LIST
60470: LIST
60471: PUSH
60472: LD_INT 1
60474: NEG
60475: PUSH
60476: LD_INT 0
60478: PUSH
60479: EMPTY
60480: LIST
60481: LIST
60482: PUSH
60483: LD_INT 1
60485: NEG
60486: PUSH
60487: LD_INT 1
60489: NEG
60490: PUSH
60491: EMPTY
60492: LIST
60493: LIST
60494: PUSH
60495: LD_INT 1
60497: PUSH
60498: LD_INT 1
60500: NEG
60501: PUSH
60502: EMPTY
60503: LIST
60504: LIST
60505: PUSH
60506: LD_INT 2
60508: PUSH
60509: LD_INT 0
60511: PUSH
60512: EMPTY
60513: LIST
60514: LIST
60515: PUSH
60516: LD_INT 2
60518: PUSH
60519: LD_INT 1
60521: PUSH
60522: EMPTY
60523: LIST
60524: LIST
60525: PUSH
60526: LD_INT 1
60528: NEG
60529: PUSH
60530: LD_INT 1
60532: PUSH
60533: EMPTY
60534: LIST
60535: LIST
60536: PUSH
60537: LD_INT 2
60539: NEG
60540: PUSH
60541: LD_INT 0
60543: PUSH
60544: EMPTY
60545: LIST
60546: LIST
60547: PUSH
60548: LD_INT 2
60550: NEG
60551: PUSH
60552: LD_INT 1
60554: NEG
60555: PUSH
60556: EMPTY
60557: LIST
60558: LIST
60559: PUSH
60560: LD_INT 2
60562: PUSH
60563: LD_INT 1
60565: NEG
60566: PUSH
60567: EMPTY
60568: LIST
60569: LIST
60570: PUSH
60571: LD_INT 3
60573: PUSH
60574: LD_INT 0
60576: PUSH
60577: EMPTY
60578: LIST
60579: LIST
60580: PUSH
60581: LD_INT 3
60583: PUSH
60584: LD_INT 1
60586: PUSH
60587: EMPTY
60588: LIST
60589: LIST
60590: PUSH
60591: EMPTY
60592: LIST
60593: LIST
60594: LIST
60595: LIST
60596: LIST
60597: LIST
60598: LIST
60599: LIST
60600: LIST
60601: LIST
60602: LIST
60603: LIST
60604: LIST
60605: LIST
60606: LIST
60607: LIST
60608: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
60609: LD_ADDR_VAR 0 16
60613: PUSH
60614: LD_INT 0
60616: PUSH
60617: LD_INT 0
60619: PUSH
60620: EMPTY
60621: LIST
60622: LIST
60623: PUSH
60624: LD_INT 0
60626: PUSH
60627: LD_INT 1
60629: NEG
60630: PUSH
60631: EMPTY
60632: LIST
60633: LIST
60634: PUSH
60635: LD_INT 1
60637: PUSH
60638: LD_INT 0
60640: PUSH
60641: EMPTY
60642: LIST
60643: LIST
60644: PUSH
60645: LD_INT 1
60647: PUSH
60648: LD_INT 1
60650: PUSH
60651: EMPTY
60652: LIST
60653: LIST
60654: PUSH
60655: LD_INT 0
60657: PUSH
60658: LD_INT 1
60660: PUSH
60661: EMPTY
60662: LIST
60663: LIST
60664: PUSH
60665: LD_INT 1
60667: NEG
60668: PUSH
60669: LD_INT 0
60671: PUSH
60672: EMPTY
60673: LIST
60674: LIST
60675: PUSH
60676: LD_INT 1
60678: NEG
60679: PUSH
60680: LD_INT 1
60682: NEG
60683: PUSH
60684: EMPTY
60685: LIST
60686: LIST
60687: PUSH
60688: LD_INT 1
60690: NEG
60691: PUSH
60692: LD_INT 2
60694: NEG
60695: PUSH
60696: EMPTY
60697: LIST
60698: LIST
60699: PUSH
60700: LD_INT 2
60702: PUSH
60703: LD_INT 1
60705: PUSH
60706: EMPTY
60707: LIST
60708: LIST
60709: PUSH
60710: LD_INT 2
60712: PUSH
60713: LD_INT 2
60715: PUSH
60716: EMPTY
60717: LIST
60718: LIST
60719: PUSH
60720: LD_INT 1
60722: PUSH
60723: LD_INT 2
60725: PUSH
60726: EMPTY
60727: LIST
60728: LIST
60729: PUSH
60730: LD_INT 2
60732: NEG
60733: PUSH
60734: LD_INT 1
60736: NEG
60737: PUSH
60738: EMPTY
60739: LIST
60740: LIST
60741: PUSH
60742: LD_INT 2
60744: NEG
60745: PUSH
60746: LD_INT 2
60748: NEG
60749: PUSH
60750: EMPTY
60751: LIST
60752: LIST
60753: PUSH
60754: LD_INT 3
60756: PUSH
60757: LD_INT 2
60759: PUSH
60760: EMPTY
60761: LIST
60762: LIST
60763: PUSH
60764: LD_INT 3
60766: PUSH
60767: LD_INT 3
60769: PUSH
60770: EMPTY
60771: LIST
60772: LIST
60773: PUSH
60774: LD_INT 2
60776: PUSH
60777: LD_INT 3
60779: PUSH
60780: EMPTY
60781: LIST
60782: LIST
60783: PUSH
60784: EMPTY
60785: LIST
60786: LIST
60787: LIST
60788: LIST
60789: LIST
60790: LIST
60791: LIST
60792: LIST
60793: LIST
60794: LIST
60795: LIST
60796: LIST
60797: LIST
60798: LIST
60799: LIST
60800: LIST
60801: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
60802: LD_ADDR_VAR 0 17
60806: PUSH
60807: LD_INT 0
60809: PUSH
60810: LD_INT 0
60812: PUSH
60813: EMPTY
60814: LIST
60815: LIST
60816: PUSH
60817: LD_INT 0
60819: PUSH
60820: LD_INT 1
60822: NEG
60823: PUSH
60824: EMPTY
60825: LIST
60826: LIST
60827: PUSH
60828: LD_INT 1
60830: PUSH
60831: LD_INT 0
60833: PUSH
60834: EMPTY
60835: LIST
60836: LIST
60837: PUSH
60838: LD_INT 1
60840: PUSH
60841: LD_INT 1
60843: PUSH
60844: EMPTY
60845: LIST
60846: LIST
60847: PUSH
60848: LD_INT 0
60850: PUSH
60851: LD_INT 1
60853: PUSH
60854: EMPTY
60855: LIST
60856: LIST
60857: PUSH
60858: LD_INT 1
60860: NEG
60861: PUSH
60862: LD_INT 0
60864: PUSH
60865: EMPTY
60866: LIST
60867: LIST
60868: PUSH
60869: LD_INT 1
60871: NEG
60872: PUSH
60873: LD_INT 1
60875: NEG
60876: PUSH
60877: EMPTY
60878: LIST
60879: LIST
60880: PUSH
60881: LD_INT 1
60883: NEG
60884: PUSH
60885: LD_INT 2
60887: NEG
60888: PUSH
60889: EMPTY
60890: LIST
60891: LIST
60892: PUSH
60893: LD_INT 0
60895: PUSH
60896: LD_INT 2
60898: NEG
60899: PUSH
60900: EMPTY
60901: LIST
60902: LIST
60903: PUSH
60904: LD_INT 1
60906: PUSH
60907: LD_INT 1
60909: NEG
60910: PUSH
60911: EMPTY
60912: LIST
60913: LIST
60914: PUSH
60915: LD_INT 2
60917: PUSH
60918: LD_INT 0
60920: PUSH
60921: EMPTY
60922: LIST
60923: LIST
60924: PUSH
60925: LD_INT 2
60927: PUSH
60928: LD_INT 1
60930: PUSH
60931: EMPTY
60932: LIST
60933: LIST
60934: PUSH
60935: LD_INT 2
60937: PUSH
60938: LD_INT 2
60940: PUSH
60941: EMPTY
60942: LIST
60943: LIST
60944: PUSH
60945: LD_INT 1
60947: PUSH
60948: LD_INT 2
60950: PUSH
60951: EMPTY
60952: LIST
60953: LIST
60954: PUSH
60955: LD_INT 0
60957: PUSH
60958: LD_INT 2
60960: PUSH
60961: EMPTY
60962: LIST
60963: LIST
60964: PUSH
60965: LD_INT 1
60967: NEG
60968: PUSH
60969: LD_INT 1
60971: PUSH
60972: EMPTY
60973: LIST
60974: LIST
60975: PUSH
60976: LD_INT 2
60978: NEG
60979: PUSH
60980: LD_INT 0
60982: PUSH
60983: EMPTY
60984: LIST
60985: LIST
60986: PUSH
60987: LD_INT 2
60989: NEG
60990: PUSH
60991: LD_INT 1
60993: NEG
60994: PUSH
60995: EMPTY
60996: LIST
60997: LIST
60998: PUSH
60999: LD_INT 2
61001: NEG
61002: PUSH
61003: LD_INT 2
61005: NEG
61006: PUSH
61007: EMPTY
61008: LIST
61009: LIST
61010: PUSH
61011: EMPTY
61012: LIST
61013: LIST
61014: LIST
61015: LIST
61016: LIST
61017: LIST
61018: LIST
61019: LIST
61020: LIST
61021: LIST
61022: LIST
61023: LIST
61024: LIST
61025: LIST
61026: LIST
61027: LIST
61028: LIST
61029: LIST
61030: LIST
61031: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
61032: LD_ADDR_VAR 0 18
61036: PUSH
61037: LD_INT 0
61039: PUSH
61040: LD_INT 0
61042: PUSH
61043: EMPTY
61044: LIST
61045: LIST
61046: PUSH
61047: LD_INT 0
61049: PUSH
61050: LD_INT 1
61052: NEG
61053: PUSH
61054: EMPTY
61055: LIST
61056: LIST
61057: PUSH
61058: LD_INT 1
61060: PUSH
61061: LD_INT 0
61063: PUSH
61064: EMPTY
61065: LIST
61066: LIST
61067: PUSH
61068: LD_INT 1
61070: PUSH
61071: LD_INT 1
61073: PUSH
61074: EMPTY
61075: LIST
61076: LIST
61077: PUSH
61078: LD_INT 0
61080: PUSH
61081: LD_INT 1
61083: PUSH
61084: EMPTY
61085: LIST
61086: LIST
61087: PUSH
61088: LD_INT 1
61090: NEG
61091: PUSH
61092: LD_INT 0
61094: PUSH
61095: EMPTY
61096: LIST
61097: LIST
61098: PUSH
61099: LD_INT 1
61101: NEG
61102: PUSH
61103: LD_INT 1
61105: NEG
61106: PUSH
61107: EMPTY
61108: LIST
61109: LIST
61110: PUSH
61111: LD_INT 1
61113: NEG
61114: PUSH
61115: LD_INT 2
61117: NEG
61118: PUSH
61119: EMPTY
61120: LIST
61121: LIST
61122: PUSH
61123: LD_INT 0
61125: PUSH
61126: LD_INT 2
61128: NEG
61129: PUSH
61130: EMPTY
61131: LIST
61132: LIST
61133: PUSH
61134: LD_INT 1
61136: PUSH
61137: LD_INT 1
61139: NEG
61140: PUSH
61141: EMPTY
61142: LIST
61143: LIST
61144: PUSH
61145: LD_INT 2
61147: PUSH
61148: LD_INT 0
61150: PUSH
61151: EMPTY
61152: LIST
61153: LIST
61154: PUSH
61155: LD_INT 2
61157: PUSH
61158: LD_INT 1
61160: PUSH
61161: EMPTY
61162: LIST
61163: LIST
61164: PUSH
61165: LD_INT 2
61167: PUSH
61168: LD_INT 2
61170: PUSH
61171: EMPTY
61172: LIST
61173: LIST
61174: PUSH
61175: LD_INT 1
61177: PUSH
61178: LD_INT 2
61180: PUSH
61181: EMPTY
61182: LIST
61183: LIST
61184: PUSH
61185: LD_INT 0
61187: PUSH
61188: LD_INT 2
61190: PUSH
61191: EMPTY
61192: LIST
61193: LIST
61194: PUSH
61195: LD_INT 1
61197: NEG
61198: PUSH
61199: LD_INT 1
61201: PUSH
61202: EMPTY
61203: LIST
61204: LIST
61205: PUSH
61206: LD_INT 2
61208: NEG
61209: PUSH
61210: LD_INT 0
61212: PUSH
61213: EMPTY
61214: LIST
61215: LIST
61216: PUSH
61217: LD_INT 2
61219: NEG
61220: PUSH
61221: LD_INT 1
61223: NEG
61224: PUSH
61225: EMPTY
61226: LIST
61227: LIST
61228: PUSH
61229: LD_INT 2
61231: NEG
61232: PUSH
61233: LD_INT 2
61235: NEG
61236: PUSH
61237: EMPTY
61238: LIST
61239: LIST
61240: PUSH
61241: EMPTY
61242: LIST
61243: LIST
61244: LIST
61245: LIST
61246: LIST
61247: LIST
61248: LIST
61249: LIST
61250: LIST
61251: LIST
61252: LIST
61253: LIST
61254: LIST
61255: LIST
61256: LIST
61257: LIST
61258: LIST
61259: LIST
61260: LIST
61261: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
61262: LD_ADDR_VAR 0 19
61266: PUSH
61267: LD_INT 0
61269: PUSH
61270: LD_INT 0
61272: PUSH
61273: EMPTY
61274: LIST
61275: LIST
61276: PUSH
61277: LD_INT 0
61279: PUSH
61280: LD_INT 1
61282: NEG
61283: PUSH
61284: EMPTY
61285: LIST
61286: LIST
61287: PUSH
61288: LD_INT 1
61290: PUSH
61291: LD_INT 0
61293: PUSH
61294: EMPTY
61295: LIST
61296: LIST
61297: PUSH
61298: LD_INT 1
61300: PUSH
61301: LD_INT 1
61303: PUSH
61304: EMPTY
61305: LIST
61306: LIST
61307: PUSH
61308: LD_INT 0
61310: PUSH
61311: LD_INT 1
61313: PUSH
61314: EMPTY
61315: LIST
61316: LIST
61317: PUSH
61318: LD_INT 1
61320: NEG
61321: PUSH
61322: LD_INT 0
61324: PUSH
61325: EMPTY
61326: LIST
61327: LIST
61328: PUSH
61329: LD_INT 1
61331: NEG
61332: PUSH
61333: LD_INT 1
61335: NEG
61336: PUSH
61337: EMPTY
61338: LIST
61339: LIST
61340: PUSH
61341: LD_INT 1
61343: NEG
61344: PUSH
61345: LD_INT 2
61347: NEG
61348: PUSH
61349: EMPTY
61350: LIST
61351: LIST
61352: PUSH
61353: LD_INT 0
61355: PUSH
61356: LD_INT 2
61358: NEG
61359: PUSH
61360: EMPTY
61361: LIST
61362: LIST
61363: PUSH
61364: LD_INT 1
61366: PUSH
61367: LD_INT 1
61369: NEG
61370: PUSH
61371: EMPTY
61372: LIST
61373: LIST
61374: PUSH
61375: LD_INT 2
61377: PUSH
61378: LD_INT 0
61380: PUSH
61381: EMPTY
61382: LIST
61383: LIST
61384: PUSH
61385: LD_INT 2
61387: PUSH
61388: LD_INT 1
61390: PUSH
61391: EMPTY
61392: LIST
61393: LIST
61394: PUSH
61395: LD_INT 2
61397: PUSH
61398: LD_INT 2
61400: PUSH
61401: EMPTY
61402: LIST
61403: LIST
61404: PUSH
61405: LD_INT 1
61407: PUSH
61408: LD_INT 2
61410: PUSH
61411: EMPTY
61412: LIST
61413: LIST
61414: PUSH
61415: LD_INT 0
61417: PUSH
61418: LD_INT 2
61420: PUSH
61421: EMPTY
61422: LIST
61423: LIST
61424: PUSH
61425: LD_INT 1
61427: NEG
61428: PUSH
61429: LD_INT 1
61431: PUSH
61432: EMPTY
61433: LIST
61434: LIST
61435: PUSH
61436: LD_INT 2
61438: NEG
61439: PUSH
61440: LD_INT 0
61442: PUSH
61443: EMPTY
61444: LIST
61445: LIST
61446: PUSH
61447: LD_INT 2
61449: NEG
61450: PUSH
61451: LD_INT 1
61453: NEG
61454: PUSH
61455: EMPTY
61456: LIST
61457: LIST
61458: PUSH
61459: LD_INT 2
61461: NEG
61462: PUSH
61463: LD_INT 2
61465: NEG
61466: PUSH
61467: EMPTY
61468: LIST
61469: LIST
61470: PUSH
61471: EMPTY
61472: LIST
61473: LIST
61474: LIST
61475: LIST
61476: LIST
61477: LIST
61478: LIST
61479: LIST
61480: LIST
61481: LIST
61482: LIST
61483: LIST
61484: LIST
61485: LIST
61486: LIST
61487: LIST
61488: LIST
61489: LIST
61490: LIST
61491: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
61492: LD_ADDR_VAR 0 20
61496: PUSH
61497: LD_INT 0
61499: PUSH
61500: LD_INT 0
61502: PUSH
61503: EMPTY
61504: LIST
61505: LIST
61506: PUSH
61507: LD_INT 0
61509: PUSH
61510: LD_INT 1
61512: NEG
61513: PUSH
61514: EMPTY
61515: LIST
61516: LIST
61517: PUSH
61518: LD_INT 1
61520: PUSH
61521: LD_INT 0
61523: PUSH
61524: EMPTY
61525: LIST
61526: LIST
61527: PUSH
61528: LD_INT 1
61530: PUSH
61531: LD_INT 1
61533: PUSH
61534: EMPTY
61535: LIST
61536: LIST
61537: PUSH
61538: LD_INT 0
61540: PUSH
61541: LD_INT 1
61543: PUSH
61544: EMPTY
61545: LIST
61546: LIST
61547: PUSH
61548: LD_INT 1
61550: NEG
61551: PUSH
61552: LD_INT 0
61554: PUSH
61555: EMPTY
61556: LIST
61557: LIST
61558: PUSH
61559: LD_INT 1
61561: NEG
61562: PUSH
61563: LD_INT 1
61565: NEG
61566: PUSH
61567: EMPTY
61568: LIST
61569: LIST
61570: PUSH
61571: LD_INT 1
61573: NEG
61574: PUSH
61575: LD_INT 2
61577: NEG
61578: PUSH
61579: EMPTY
61580: LIST
61581: LIST
61582: PUSH
61583: LD_INT 0
61585: PUSH
61586: LD_INT 2
61588: NEG
61589: PUSH
61590: EMPTY
61591: LIST
61592: LIST
61593: PUSH
61594: LD_INT 1
61596: PUSH
61597: LD_INT 1
61599: NEG
61600: PUSH
61601: EMPTY
61602: LIST
61603: LIST
61604: PUSH
61605: LD_INT 2
61607: PUSH
61608: LD_INT 0
61610: PUSH
61611: EMPTY
61612: LIST
61613: LIST
61614: PUSH
61615: LD_INT 2
61617: PUSH
61618: LD_INT 1
61620: PUSH
61621: EMPTY
61622: LIST
61623: LIST
61624: PUSH
61625: LD_INT 2
61627: PUSH
61628: LD_INT 2
61630: PUSH
61631: EMPTY
61632: LIST
61633: LIST
61634: PUSH
61635: LD_INT 1
61637: PUSH
61638: LD_INT 2
61640: PUSH
61641: EMPTY
61642: LIST
61643: LIST
61644: PUSH
61645: LD_INT 0
61647: PUSH
61648: LD_INT 2
61650: PUSH
61651: EMPTY
61652: LIST
61653: LIST
61654: PUSH
61655: LD_INT 1
61657: NEG
61658: PUSH
61659: LD_INT 1
61661: PUSH
61662: EMPTY
61663: LIST
61664: LIST
61665: PUSH
61666: LD_INT 2
61668: NEG
61669: PUSH
61670: LD_INT 0
61672: PUSH
61673: EMPTY
61674: LIST
61675: LIST
61676: PUSH
61677: LD_INT 2
61679: NEG
61680: PUSH
61681: LD_INT 1
61683: NEG
61684: PUSH
61685: EMPTY
61686: LIST
61687: LIST
61688: PUSH
61689: LD_INT 2
61691: NEG
61692: PUSH
61693: LD_INT 2
61695: NEG
61696: PUSH
61697: EMPTY
61698: LIST
61699: LIST
61700: PUSH
61701: EMPTY
61702: LIST
61703: LIST
61704: LIST
61705: LIST
61706: LIST
61707: LIST
61708: LIST
61709: LIST
61710: LIST
61711: LIST
61712: LIST
61713: LIST
61714: LIST
61715: LIST
61716: LIST
61717: LIST
61718: LIST
61719: LIST
61720: LIST
61721: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
61722: LD_ADDR_VAR 0 21
61726: PUSH
61727: LD_INT 0
61729: PUSH
61730: LD_INT 0
61732: PUSH
61733: EMPTY
61734: LIST
61735: LIST
61736: PUSH
61737: LD_INT 0
61739: PUSH
61740: LD_INT 1
61742: NEG
61743: PUSH
61744: EMPTY
61745: LIST
61746: LIST
61747: PUSH
61748: LD_INT 1
61750: PUSH
61751: LD_INT 0
61753: PUSH
61754: EMPTY
61755: LIST
61756: LIST
61757: PUSH
61758: LD_INT 1
61760: PUSH
61761: LD_INT 1
61763: PUSH
61764: EMPTY
61765: LIST
61766: LIST
61767: PUSH
61768: LD_INT 0
61770: PUSH
61771: LD_INT 1
61773: PUSH
61774: EMPTY
61775: LIST
61776: LIST
61777: PUSH
61778: LD_INT 1
61780: NEG
61781: PUSH
61782: LD_INT 0
61784: PUSH
61785: EMPTY
61786: LIST
61787: LIST
61788: PUSH
61789: LD_INT 1
61791: NEG
61792: PUSH
61793: LD_INT 1
61795: NEG
61796: PUSH
61797: EMPTY
61798: LIST
61799: LIST
61800: PUSH
61801: LD_INT 1
61803: NEG
61804: PUSH
61805: LD_INT 2
61807: NEG
61808: PUSH
61809: EMPTY
61810: LIST
61811: LIST
61812: PUSH
61813: LD_INT 0
61815: PUSH
61816: LD_INT 2
61818: NEG
61819: PUSH
61820: EMPTY
61821: LIST
61822: LIST
61823: PUSH
61824: LD_INT 1
61826: PUSH
61827: LD_INT 1
61829: NEG
61830: PUSH
61831: EMPTY
61832: LIST
61833: LIST
61834: PUSH
61835: LD_INT 2
61837: PUSH
61838: LD_INT 0
61840: PUSH
61841: EMPTY
61842: LIST
61843: LIST
61844: PUSH
61845: LD_INT 2
61847: PUSH
61848: LD_INT 1
61850: PUSH
61851: EMPTY
61852: LIST
61853: LIST
61854: PUSH
61855: LD_INT 2
61857: PUSH
61858: LD_INT 2
61860: PUSH
61861: EMPTY
61862: LIST
61863: LIST
61864: PUSH
61865: LD_INT 1
61867: PUSH
61868: LD_INT 2
61870: PUSH
61871: EMPTY
61872: LIST
61873: LIST
61874: PUSH
61875: LD_INT 0
61877: PUSH
61878: LD_INT 2
61880: PUSH
61881: EMPTY
61882: LIST
61883: LIST
61884: PUSH
61885: LD_INT 1
61887: NEG
61888: PUSH
61889: LD_INT 1
61891: PUSH
61892: EMPTY
61893: LIST
61894: LIST
61895: PUSH
61896: LD_INT 2
61898: NEG
61899: PUSH
61900: LD_INT 0
61902: PUSH
61903: EMPTY
61904: LIST
61905: LIST
61906: PUSH
61907: LD_INT 2
61909: NEG
61910: PUSH
61911: LD_INT 1
61913: NEG
61914: PUSH
61915: EMPTY
61916: LIST
61917: LIST
61918: PUSH
61919: LD_INT 2
61921: NEG
61922: PUSH
61923: LD_INT 2
61925: NEG
61926: PUSH
61927: EMPTY
61928: LIST
61929: LIST
61930: PUSH
61931: EMPTY
61932: LIST
61933: LIST
61934: LIST
61935: LIST
61936: LIST
61937: LIST
61938: LIST
61939: LIST
61940: LIST
61941: LIST
61942: LIST
61943: LIST
61944: LIST
61945: LIST
61946: LIST
61947: LIST
61948: LIST
61949: LIST
61950: LIST
61951: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
61952: LD_ADDR_VAR 0 22
61956: PUSH
61957: LD_INT 0
61959: PUSH
61960: LD_INT 0
61962: PUSH
61963: EMPTY
61964: LIST
61965: LIST
61966: PUSH
61967: LD_INT 0
61969: PUSH
61970: LD_INT 1
61972: NEG
61973: PUSH
61974: EMPTY
61975: LIST
61976: LIST
61977: PUSH
61978: LD_INT 1
61980: PUSH
61981: LD_INT 0
61983: PUSH
61984: EMPTY
61985: LIST
61986: LIST
61987: PUSH
61988: LD_INT 1
61990: PUSH
61991: LD_INT 1
61993: PUSH
61994: EMPTY
61995: LIST
61996: LIST
61997: PUSH
61998: LD_INT 0
62000: PUSH
62001: LD_INT 1
62003: PUSH
62004: EMPTY
62005: LIST
62006: LIST
62007: PUSH
62008: LD_INT 1
62010: NEG
62011: PUSH
62012: LD_INT 0
62014: PUSH
62015: EMPTY
62016: LIST
62017: LIST
62018: PUSH
62019: LD_INT 1
62021: NEG
62022: PUSH
62023: LD_INT 1
62025: NEG
62026: PUSH
62027: EMPTY
62028: LIST
62029: LIST
62030: PUSH
62031: LD_INT 1
62033: NEG
62034: PUSH
62035: LD_INT 2
62037: NEG
62038: PUSH
62039: EMPTY
62040: LIST
62041: LIST
62042: PUSH
62043: LD_INT 0
62045: PUSH
62046: LD_INT 2
62048: NEG
62049: PUSH
62050: EMPTY
62051: LIST
62052: LIST
62053: PUSH
62054: LD_INT 1
62056: PUSH
62057: LD_INT 1
62059: NEG
62060: PUSH
62061: EMPTY
62062: LIST
62063: LIST
62064: PUSH
62065: LD_INT 2
62067: PUSH
62068: LD_INT 0
62070: PUSH
62071: EMPTY
62072: LIST
62073: LIST
62074: PUSH
62075: LD_INT 2
62077: PUSH
62078: LD_INT 1
62080: PUSH
62081: EMPTY
62082: LIST
62083: LIST
62084: PUSH
62085: LD_INT 2
62087: PUSH
62088: LD_INT 2
62090: PUSH
62091: EMPTY
62092: LIST
62093: LIST
62094: PUSH
62095: LD_INT 1
62097: PUSH
62098: LD_INT 2
62100: PUSH
62101: EMPTY
62102: LIST
62103: LIST
62104: PUSH
62105: LD_INT 0
62107: PUSH
62108: LD_INT 2
62110: PUSH
62111: EMPTY
62112: LIST
62113: LIST
62114: PUSH
62115: LD_INT 1
62117: NEG
62118: PUSH
62119: LD_INT 1
62121: PUSH
62122: EMPTY
62123: LIST
62124: LIST
62125: PUSH
62126: LD_INT 2
62128: NEG
62129: PUSH
62130: LD_INT 0
62132: PUSH
62133: EMPTY
62134: LIST
62135: LIST
62136: PUSH
62137: LD_INT 2
62139: NEG
62140: PUSH
62141: LD_INT 1
62143: NEG
62144: PUSH
62145: EMPTY
62146: LIST
62147: LIST
62148: PUSH
62149: LD_INT 2
62151: NEG
62152: PUSH
62153: LD_INT 2
62155: NEG
62156: PUSH
62157: EMPTY
62158: LIST
62159: LIST
62160: PUSH
62161: EMPTY
62162: LIST
62163: LIST
62164: LIST
62165: LIST
62166: LIST
62167: LIST
62168: LIST
62169: LIST
62170: LIST
62171: LIST
62172: LIST
62173: LIST
62174: LIST
62175: LIST
62176: LIST
62177: LIST
62178: LIST
62179: LIST
62180: LIST
62181: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
62182: LD_ADDR_VAR 0 23
62186: PUSH
62187: LD_INT 0
62189: PUSH
62190: LD_INT 0
62192: PUSH
62193: EMPTY
62194: LIST
62195: LIST
62196: PUSH
62197: LD_INT 0
62199: PUSH
62200: LD_INT 1
62202: NEG
62203: PUSH
62204: EMPTY
62205: LIST
62206: LIST
62207: PUSH
62208: LD_INT 1
62210: PUSH
62211: LD_INT 0
62213: PUSH
62214: EMPTY
62215: LIST
62216: LIST
62217: PUSH
62218: LD_INT 1
62220: PUSH
62221: LD_INT 1
62223: PUSH
62224: EMPTY
62225: LIST
62226: LIST
62227: PUSH
62228: LD_INT 0
62230: PUSH
62231: LD_INT 1
62233: PUSH
62234: EMPTY
62235: LIST
62236: LIST
62237: PUSH
62238: LD_INT 1
62240: NEG
62241: PUSH
62242: LD_INT 0
62244: PUSH
62245: EMPTY
62246: LIST
62247: LIST
62248: PUSH
62249: LD_INT 1
62251: NEG
62252: PUSH
62253: LD_INT 1
62255: NEG
62256: PUSH
62257: EMPTY
62258: LIST
62259: LIST
62260: PUSH
62261: LD_INT 1
62263: NEG
62264: PUSH
62265: LD_INT 2
62267: NEG
62268: PUSH
62269: EMPTY
62270: LIST
62271: LIST
62272: PUSH
62273: LD_INT 0
62275: PUSH
62276: LD_INT 2
62278: NEG
62279: PUSH
62280: EMPTY
62281: LIST
62282: LIST
62283: PUSH
62284: LD_INT 1
62286: PUSH
62287: LD_INT 1
62289: NEG
62290: PUSH
62291: EMPTY
62292: LIST
62293: LIST
62294: PUSH
62295: LD_INT 2
62297: PUSH
62298: LD_INT 0
62300: PUSH
62301: EMPTY
62302: LIST
62303: LIST
62304: PUSH
62305: LD_INT 2
62307: PUSH
62308: LD_INT 1
62310: PUSH
62311: EMPTY
62312: LIST
62313: LIST
62314: PUSH
62315: LD_INT 2
62317: PUSH
62318: LD_INT 2
62320: PUSH
62321: EMPTY
62322: LIST
62323: LIST
62324: PUSH
62325: LD_INT 1
62327: PUSH
62328: LD_INT 2
62330: PUSH
62331: EMPTY
62332: LIST
62333: LIST
62334: PUSH
62335: LD_INT 0
62337: PUSH
62338: LD_INT 2
62340: PUSH
62341: EMPTY
62342: LIST
62343: LIST
62344: PUSH
62345: LD_INT 1
62347: NEG
62348: PUSH
62349: LD_INT 1
62351: PUSH
62352: EMPTY
62353: LIST
62354: LIST
62355: PUSH
62356: LD_INT 2
62358: NEG
62359: PUSH
62360: LD_INT 0
62362: PUSH
62363: EMPTY
62364: LIST
62365: LIST
62366: PUSH
62367: LD_INT 2
62369: NEG
62370: PUSH
62371: LD_INT 1
62373: NEG
62374: PUSH
62375: EMPTY
62376: LIST
62377: LIST
62378: PUSH
62379: LD_INT 2
62381: NEG
62382: PUSH
62383: LD_INT 2
62385: NEG
62386: PUSH
62387: EMPTY
62388: LIST
62389: LIST
62390: PUSH
62391: LD_INT 2
62393: NEG
62394: PUSH
62395: LD_INT 3
62397: NEG
62398: PUSH
62399: EMPTY
62400: LIST
62401: LIST
62402: PUSH
62403: LD_INT 1
62405: NEG
62406: PUSH
62407: LD_INT 3
62409: NEG
62410: PUSH
62411: EMPTY
62412: LIST
62413: LIST
62414: PUSH
62415: LD_INT 1
62417: PUSH
62418: LD_INT 2
62420: NEG
62421: PUSH
62422: EMPTY
62423: LIST
62424: LIST
62425: PUSH
62426: LD_INT 2
62428: PUSH
62429: LD_INT 1
62431: NEG
62432: PUSH
62433: EMPTY
62434: LIST
62435: LIST
62436: PUSH
62437: EMPTY
62438: LIST
62439: LIST
62440: LIST
62441: LIST
62442: LIST
62443: LIST
62444: LIST
62445: LIST
62446: LIST
62447: LIST
62448: LIST
62449: LIST
62450: LIST
62451: LIST
62452: LIST
62453: LIST
62454: LIST
62455: LIST
62456: LIST
62457: LIST
62458: LIST
62459: LIST
62460: LIST
62461: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
62462: LD_ADDR_VAR 0 24
62466: PUSH
62467: LD_INT 0
62469: PUSH
62470: LD_INT 0
62472: PUSH
62473: EMPTY
62474: LIST
62475: LIST
62476: PUSH
62477: LD_INT 0
62479: PUSH
62480: LD_INT 1
62482: NEG
62483: PUSH
62484: EMPTY
62485: LIST
62486: LIST
62487: PUSH
62488: LD_INT 1
62490: PUSH
62491: LD_INT 0
62493: PUSH
62494: EMPTY
62495: LIST
62496: LIST
62497: PUSH
62498: LD_INT 1
62500: PUSH
62501: LD_INT 1
62503: PUSH
62504: EMPTY
62505: LIST
62506: LIST
62507: PUSH
62508: LD_INT 0
62510: PUSH
62511: LD_INT 1
62513: PUSH
62514: EMPTY
62515: LIST
62516: LIST
62517: PUSH
62518: LD_INT 1
62520: NEG
62521: PUSH
62522: LD_INT 0
62524: PUSH
62525: EMPTY
62526: LIST
62527: LIST
62528: PUSH
62529: LD_INT 1
62531: NEG
62532: PUSH
62533: LD_INT 1
62535: NEG
62536: PUSH
62537: EMPTY
62538: LIST
62539: LIST
62540: PUSH
62541: LD_INT 1
62543: NEG
62544: PUSH
62545: LD_INT 2
62547: NEG
62548: PUSH
62549: EMPTY
62550: LIST
62551: LIST
62552: PUSH
62553: LD_INT 0
62555: PUSH
62556: LD_INT 2
62558: NEG
62559: PUSH
62560: EMPTY
62561: LIST
62562: LIST
62563: PUSH
62564: LD_INT 1
62566: PUSH
62567: LD_INT 1
62569: NEG
62570: PUSH
62571: EMPTY
62572: LIST
62573: LIST
62574: PUSH
62575: LD_INT 2
62577: PUSH
62578: LD_INT 0
62580: PUSH
62581: EMPTY
62582: LIST
62583: LIST
62584: PUSH
62585: LD_INT 2
62587: PUSH
62588: LD_INT 1
62590: PUSH
62591: EMPTY
62592: LIST
62593: LIST
62594: PUSH
62595: LD_INT 2
62597: PUSH
62598: LD_INT 2
62600: PUSH
62601: EMPTY
62602: LIST
62603: LIST
62604: PUSH
62605: LD_INT 1
62607: PUSH
62608: LD_INT 2
62610: PUSH
62611: EMPTY
62612: LIST
62613: LIST
62614: PUSH
62615: LD_INT 0
62617: PUSH
62618: LD_INT 2
62620: PUSH
62621: EMPTY
62622: LIST
62623: LIST
62624: PUSH
62625: LD_INT 1
62627: NEG
62628: PUSH
62629: LD_INT 1
62631: PUSH
62632: EMPTY
62633: LIST
62634: LIST
62635: PUSH
62636: LD_INT 2
62638: NEG
62639: PUSH
62640: LD_INT 0
62642: PUSH
62643: EMPTY
62644: LIST
62645: LIST
62646: PUSH
62647: LD_INT 2
62649: NEG
62650: PUSH
62651: LD_INT 1
62653: NEG
62654: PUSH
62655: EMPTY
62656: LIST
62657: LIST
62658: PUSH
62659: LD_INT 2
62661: NEG
62662: PUSH
62663: LD_INT 2
62665: NEG
62666: PUSH
62667: EMPTY
62668: LIST
62669: LIST
62670: PUSH
62671: LD_INT 1
62673: PUSH
62674: LD_INT 2
62676: NEG
62677: PUSH
62678: EMPTY
62679: LIST
62680: LIST
62681: PUSH
62682: LD_INT 2
62684: PUSH
62685: LD_INT 1
62687: NEG
62688: PUSH
62689: EMPTY
62690: LIST
62691: LIST
62692: PUSH
62693: LD_INT 3
62695: PUSH
62696: LD_INT 1
62698: PUSH
62699: EMPTY
62700: LIST
62701: LIST
62702: PUSH
62703: LD_INT 3
62705: PUSH
62706: LD_INT 2
62708: PUSH
62709: EMPTY
62710: LIST
62711: LIST
62712: PUSH
62713: EMPTY
62714: LIST
62715: LIST
62716: LIST
62717: LIST
62718: LIST
62719: LIST
62720: LIST
62721: LIST
62722: LIST
62723: LIST
62724: LIST
62725: LIST
62726: LIST
62727: LIST
62728: LIST
62729: LIST
62730: LIST
62731: LIST
62732: LIST
62733: LIST
62734: LIST
62735: LIST
62736: LIST
62737: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
62738: LD_ADDR_VAR 0 25
62742: PUSH
62743: LD_INT 0
62745: PUSH
62746: LD_INT 0
62748: PUSH
62749: EMPTY
62750: LIST
62751: LIST
62752: PUSH
62753: LD_INT 0
62755: PUSH
62756: LD_INT 1
62758: NEG
62759: PUSH
62760: EMPTY
62761: LIST
62762: LIST
62763: PUSH
62764: LD_INT 1
62766: PUSH
62767: LD_INT 0
62769: PUSH
62770: EMPTY
62771: LIST
62772: LIST
62773: PUSH
62774: LD_INT 1
62776: PUSH
62777: LD_INT 1
62779: PUSH
62780: EMPTY
62781: LIST
62782: LIST
62783: PUSH
62784: LD_INT 0
62786: PUSH
62787: LD_INT 1
62789: PUSH
62790: EMPTY
62791: LIST
62792: LIST
62793: PUSH
62794: LD_INT 1
62796: NEG
62797: PUSH
62798: LD_INT 0
62800: PUSH
62801: EMPTY
62802: LIST
62803: LIST
62804: PUSH
62805: LD_INT 1
62807: NEG
62808: PUSH
62809: LD_INT 1
62811: NEG
62812: PUSH
62813: EMPTY
62814: LIST
62815: LIST
62816: PUSH
62817: LD_INT 1
62819: NEG
62820: PUSH
62821: LD_INT 2
62823: NEG
62824: PUSH
62825: EMPTY
62826: LIST
62827: LIST
62828: PUSH
62829: LD_INT 0
62831: PUSH
62832: LD_INT 2
62834: NEG
62835: PUSH
62836: EMPTY
62837: LIST
62838: LIST
62839: PUSH
62840: LD_INT 1
62842: PUSH
62843: LD_INT 1
62845: NEG
62846: PUSH
62847: EMPTY
62848: LIST
62849: LIST
62850: PUSH
62851: LD_INT 2
62853: PUSH
62854: LD_INT 0
62856: PUSH
62857: EMPTY
62858: LIST
62859: LIST
62860: PUSH
62861: LD_INT 2
62863: PUSH
62864: LD_INT 1
62866: PUSH
62867: EMPTY
62868: LIST
62869: LIST
62870: PUSH
62871: LD_INT 2
62873: PUSH
62874: LD_INT 2
62876: PUSH
62877: EMPTY
62878: LIST
62879: LIST
62880: PUSH
62881: LD_INT 1
62883: PUSH
62884: LD_INT 2
62886: PUSH
62887: EMPTY
62888: LIST
62889: LIST
62890: PUSH
62891: LD_INT 0
62893: PUSH
62894: LD_INT 2
62896: PUSH
62897: EMPTY
62898: LIST
62899: LIST
62900: PUSH
62901: LD_INT 1
62903: NEG
62904: PUSH
62905: LD_INT 1
62907: PUSH
62908: EMPTY
62909: LIST
62910: LIST
62911: PUSH
62912: LD_INT 2
62914: NEG
62915: PUSH
62916: LD_INT 0
62918: PUSH
62919: EMPTY
62920: LIST
62921: LIST
62922: PUSH
62923: LD_INT 2
62925: NEG
62926: PUSH
62927: LD_INT 1
62929: NEG
62930: PUSH
62931: EMPTY
62932: LIST
62933: LIST
62934: PUSH
62935: LD_INT 2
62937: NEG
62938: PUSH
62939: LD_INT 2
62941: NEG
62942: PUSH
62943: EMPTY
62944: LIST
62945: LIST
62946: PUSH
62947: LD_INT 3
62949: PUSH
62950: LD_INT 1
62952: PUSH
62953: EMPTY
62954: LIST
62955: LIST
62956: PUSH
62957: LD_INT 3
62959: PUSH
62960: LD_INT 2
62962: PUSH
62963: EMPTY
62964: LIST
62965: LIST
62966: PUSH
62967: LD_INT 2
62969: PUSH
62970: LD_INT 3
62972: PUSH
62973: EMPTY
62974: LIST
62975: LIST
62976: PUSH
62977: LD_INT 1
62979: PUSH
62980: LD_INT 3
62982: PUSH
62983: EMPTY
62984: LIST
62985: LIST
62986: PUSH
62987: EMPTY
62988: LIST
62989: LIST
62990: LIST
62991: LIST
62992: LIST
62993: LIST
62994: LIST
62995: LIST
62996: LIST
62997: LIST
62998: LIST
62999: LIST
63000: LIST
63001: LIST
63002: LIST
63003: LIST
63004: LIST
63005: LIST
63006: LIST
63007: LIST
63008: LIST
63009: LIST
63010: LIST
63011: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
63012: LD_ADDR_VAR 0 26
63016: PUSH
63017: LD_INT 0
63019: PUSH
63020: LD_INT 0
63022: PUSH
63023: EMPTY
63024: LIST
63025: LIST
63026: PUSH
63027: LD_INT 0
63029: PUSH
63030: LD_INT 1
63032: NEG
63033: PUSH
63034: EMPTY
63035: LIST
63036: LIST
63037: PUSH
63038: LD_INT 1
63040: PUSH
63041: LD_INT 0
63043: PUSH
63044: EMPTY
63045: LIST
63046: LIST
63047: PUSH
63048: LD_INT 1
63050: PUSH
63051: LD_INT 1
63053: PUSH
63054: EMPTY
63055: LIST
63056: LIST
63057: PUSH
63058: LD_INT 0
63060: PUSH
63061: LD_INT 1
63063: PUSH
63064: EMPTY
63065: LIST
63066: LIST
63067: PUSH
63068: LD_INT 1
63070: NEG
63071: PUSH
63072: LD_INT 0
63074: PUSH
63075: EMPTY
63076: LIST
63077: LIST
63078: PUSH
63079: LD_INT 1
63081: NEG
63082: PUSH
63083: LD_INT 1
63085: NEG
63086: PUSH
63087: EMPTY
63088: LIST
63089: LIST
63090: PUSH
63091: LD_INT 1
63093: NEG
63094: PUSH
63095: LD_INT 2
63097: NEG
63098: PUSH
63099: EMPTY
63100: LIST
63101: LIST
63102: PUSH
63103: LD_INT 0
63105: PUSH
63106: LD_INT 2
63108: NEG
63109: PUSH
63110: EMPTY
63111: LIST
63112: LIST
63113: PUSH
63114: LD_INT 1
63116: PUSH
63117: LD_INT 1
63119: NEG
63120: PUSH
63121: EMPTY
63122: LIST
63123: LIST
63124: PUSH
63125: LD_INT 2
63127: PUSH
63128: LD_INT 0
63130: PUSH
63131: EMPTY
63132: LIST
63133: LIST
63134: PUSH
63135: LD_INT 2
63137: PUSH
63138: LD_INT 1
63140: PUSH
63141: EMPTY
63142: LIST
63143: LIST
63144: PUSH
63145: LD_INT 2
63147: PUSH
63148: LD_INT 2
63150: PUSH
63151: EMPTY
63152: LIST
63153: LIST
63154: PUSH
63155: LD_INT 1
63157: PUSH
63158: LD_INT 2
63160: PUSH
63161: EMPTY
63162: LIST
63163: LIST
63164: PUSH
63165: LD_INT 0
63167: PUSH
63168: LD_INT 2
63170: PUSH
63171: EMPTY
63172: LIST
63173: LIST
63174: PUSH
63175: LD_INT 1
63177: NEG
63178: PUSH
63179: LD_INT 1
63181: PUSH
63182: EMPTY
63183: LIST
63184: LIST
63185: PUSH
63186: LD_INT 2
63188: NEG
63189: PUSH
63190: LD_INT 0
63192: PUSH
63193: EMPTY
63194: LIST
63195: LIST
63196: PUSH
63197: LD_INT 2
63199: NEG
63200: PUSH
63201: LD_INT 1
63203: NEG
63204: PUSH
63205: EMPTY
63206: LIST
63207: LIST
63208: PUSH
63209: LD_INT 2
63211: NEG
63212: PUSH
63213: LD_INT 2
63215: NEG
63216: PUSH
63217: EMPTY
63218: LIST
63219: LIST
63220: PUSH
63221: LD_INT 2
63223: PUSH
63224: LD_INT 3
63226: PUSH
63227: EMPTY
63228: LIST
63229: LIST
63230: PUSH
63231: LD_INT 1
63233: PUSH
63234: LD_INT 3
63236: PUSH
63237: EMPTY
63238: LIST
63239: LIST
63240: PUSH
63241: LD_INT 1
63243: NEG
63244: PUSH
63245: LD_INT 2
63247: PUSH
63248: EMPTY
63249: LIST
63250: LIST
63251: PUSH
63252: LD_INT 2
63254: NEG
63255: PUSH
63256: LD_INT 1
63258: PUSH
63259: EMPTY
63260: LIST
63261: LIST
63262: PUSH
63263: EMPTY
63264: LIST
63265: LIST
63266: LIST
63267: LIST
63268: LIST
63269: LIST
63270: LIST
63271: LIST
63272: LIST
63273: LIST
63274: LIST
63275: LIST
63276: LIST
63277: LIST
63278: LIST
63279: LIST
63280: LIST
63281: LIST
63282: LIST
63283: LIST
63284: LIST
63285: LIST
63286: LIST
63287: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
63288: LD_ADDR_VAR 0 27
63292: PUSH
63293: LD_INT 0
63295: PUSH
63296: LD_INT 0
63298: PUSH
63299: EMPTY
63300: LIST
63301: LIST
63302: PUSH
63303: LD_INT 0
63305: PUSH
63306: LD_INT 1
63308: NEG
63309: PUSH
63310: EMPTY
63311: LIST
63312: LIST
63313: PUSH
63314: LD_INT 1
63316: PUSH
63317: LD_INT 0
63319: PUSH
63320: EMPTY
63321: LIST
63322: LIST
63323: PUSH
63324: LD_INT 1
63326: PUSH
63327: LD_INT 1
63329: PUSH
63330: EMPTY
63331: LIST
63332: LIST
63333: PUSH
63334: LD_INT 0
63336: PUSH
63337: LD_INT 1
63339: PUSH
63340: EMPTY
63341: LIST
63342: LIST
63343: PUSH
63344: LD_INT 1
63346: NEG
63347: PUSH
63348: LD_INT 0
63350: PUSH
63351: EMPTY
63352: LIST
63353: LIST
63354: PUSH
63355: LD_INT 1
63357: NEG
63358: PUSH
63359: LD_INT 1
63361: NEG
63362: PUSH
63363: EMPTY
63364: LIST
63365: LIST
63366: PUSH
63367: LD_INT 1
63369: NEG
63370: PUSH
63371: LD_INT 2
63373: NEG
63374: PUSH
63375: EMPTY
63376: LIST
63377: LIST
63378: PUSH
63379: LD_INT 0
63381: PUSH
63382: LD_INT 2
63384: NEG
63385: PUSH
63386: EMPTY
63387: LIST
63388: LIST
63389: PUSH
63390: LD_INT 1
63392: PUSH
63393: LD_INT 1
63395: NEG
63396: PUSH
63397: EMPTY
63398: LIST
63399: LIST
63400: PUSH
63401: LD_INT 2
63403: PUSH
63404: LD_INT 0
63406: PUSH
63407: EMPTY
63408: LIST
63409: LIST
63410: PUSH
63411: LD_INT 2
63413: PUSH
63414: LD_INT 1
63416: PUSH
63417: EMPTY
63418: LIST
63419: LIST
63420: PUSH
63421: LD_INT 2
63423: PUSH
63424: LD_INT 2
63426: PUSH
63427: EMPTY
63428: LIST
63429: LIST
63430: PUSH
63431: LD_INT 1
63433: PUSH
63434: LD_INT 2
63436: PUSH
63437: EMPTY
63438: LIST
63439: LIST
63440: PUSH
63441: LD_INT 0
63443: PUSH
63444: LD_INT 2
63446: PUSH
63447: EMPTY
63448: LIST
63449: LIST
63450: PUSH
63451: LD_INT 1
63453: NEG
63454: PUSH
63455: LD_INT 1
63457: PUSH
63458: EMPTY
63459: LIST
63460: LIST
63461: PUSH
63462: LD_INT 2
63464: NEG
63465: PUSH
63466: LD_INT 0
63468: PUSH
63469: EMPTY
63470: LIST
63471: LIST
63472: PUSH
63473: LD_INT 2
63475: NEG
63476: PUSH
63477: LD_INT 1
63479: NEG
63480: PUSH
63481: EMPTY
63482: LIST
63483: LIST
63484: PUSH
63485: LD_INT 2
63487: NEG
63488: PUSH
63489: LD_INT 2
63491: NEG
63492: PUSH
63493: EMPTY
63494: LIST
63495: LIST
63496: PUSH
63497: LD_INT 1
63499: NEG
63500: PUSH
63501: LD_INT 2
63503: PUSH
63504: EMPTY
63505: LIST
63506: LIST
63507: PUSH
63508: LD_INT 2
63510: NEG
63511: PUSH
63512: LD_INT 1
63514: PUSH
63515: EMPTY
63516: LIST
63517: LIST
63518: PUSH
63519: LD_INT 3
63521: NEG
63522: PUSH
63523: LD_INT 1
63525: NEG
63526: PUSH
63527: EMPTY
63528: LIST
63529: LIST
63530: PUSH
63531: LD_INT 3
63533: NEG
63534: PUSH
63535: LD_INT 2
63537: NEG
63538: PUSH
63539: EMPTY
63540: LIST
63541: LIST
63542: PUSH
63543: EMPTY
63544: LIST
63545: LIST
63546: LIST
63547: LIST
63548: LIST
63549: LIST
63550: LIST
63551: LIST
63552: LIST
63553: LIST
63554: LIST
63555: LIST
63556: LIST
63557: LIST
63558: LIST
63559: LIST
63560: LIST
63561: LIST
63562: LIST
63563: LIST
63564: LIST
63565: LIST
63566: LIST
63567: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
63568: LD_ADDR_VAR 0 28
63572: PUSH
63573: LD_INT 0
63575: PUSH
63576: LD_INT 0
63578: PUSH
63579: EMPTY
63580: LIST
63581: LIST
63582: PUSH
63583: LD_INT 0
63585: PUSH
63586: LD_INT 1
63588: NEG
63589: PUSH
63590: EMPTY
63591: LIST
63592: LIST
63593: PUSH
63594: LD_INT 1
63596: PUSH
63597: LD_INT 0
63599: PUSH
63600: EMPTY
63601: LIST
63602: LIST
63603: PUSH
63604: LD_INT 1
63606: PUSH
63607: LD_INT 1
63609: PUSH
63610: EMPTY
63611: LIST
63612: LIST
63613: PUSH
63614: LD_INT 0
63616: PUSH
63617: LD_INT 1
63619: PUSH
63620: EMPTY
63621: LIST
63622: LIST
63623: PUSH
63624: LD_INT 1
63626: NEG
63627: PUSH
63628: LD_INT 0
63630: PUSH
63631: EMPTY
63632: LIST
63633: LIST
63634: PUSH
63635: LD_INT 1
63637: NEG
63638: PUSH
63639: LD_INT 1
63641: NEG
63642: PUSH
63643: EMPTY
63644: LIST
63645: LIST
63646: PUSH
63647: LD_INT 1
63649: NEG
63650: PUSH
63651: LD_INT 2
63653: NEG
63654: PUSH
63655: EMPTY
63656: LIST
63657: LIST
63658: PUSH
63659: LD_INT 0
63661: PUSH
63662: LD_INT 2
63664: NEG
63665: PUSH
63666: EMPTY
63667: LIST
63668: LIST
63669: PUSH
63670: LD_INT 1
63672: PUSH
63673: LD_INT 1
63675: NEG
63676: PUSH
63677: EMPTY
63678: LIST
63679: LIST
63680: PUSH
63681: LD_INT 2
63683: PUSH
63684: LD_INT 0
63686: PUSH
63687: EMPTY
63688: LIST
63689: LIST
63690: PUSH
63691: LD_INT 2
63693: PUSH
63694: LD_INT 1
63696: PUSH
63697: EMPTY
63698: LIST
63699: LIST
63700: PUSH
63701: LD_INT 2
63703: PUSH
63704: LD_INT 2
63706: PUSH
63707: EMPTY
63708: LIST
63709: LIST
63710: PUSH
63711: LD_INT 1
63713: PUSH
63714: LD_INT 2
63716: PUSH
63717: EMPTY
63718: LIST
63719: LIST
63720: PUSH
63721: LD_INT 0
63723: PUSH
63724: LD_INT 2
63726: PUSH
63727: EMPTY
63728: LIST
63729: LIST
63730: PUSH
63731: LD_INT 1
63733: NEG
63734: PUSH
63735: LD_INT 1
63737: PUSH
63738: EMPTY
63739: LIST
63740: LIST
63741: PUSH
63742: LD_INT 2
63744: NEG
63745: PUSH
63746: LD_INT 0
63748: PUSH
63749: EMPTY
63750: LIST
63751: LIST
63752: PUSH
63753: LD_INT 2
63755: NEG
63756: PUSH
63757: LD_INT 1
63759: NEG
63760: PUSH
63761: EMPTY
63762: LIST
63763: LIST
63764: PUSH
63765: LD_INT 2
63767: NEG
63768: PUSH
63769: LD_INT 2
63771: NEG
63772: PUSH
63773: EMPTY
63774: LIST
63775: LIST
63776: PUSH
63777: LD_INT 2
63779: NEG
63780: PUSH
63781: LD_INT 3
63783: NEG
63784: PUSH
63785: EMPTY
63786: LIST
63787: LIST
63788: PUSH
63789: LD_INT 1
63791: NEG
63792: PUSH
63793: LD_INT 3
63795: NEG
63796: PUSH
63797: EMPTY
63798: LIST
63799: LIST
63800: PUSH
63801: LD_INT 3
63803: NEG
63804: PUSH
63805: LD_INT 1
63807: NEG
63808: PUSH
63809: EMPTY
63810: LIST
63811: LIST
63812: PUSH
63813: LD_INT 3
63815: NEG
63816: PUSH
63817: LD_INT 2
63819: NEG
63820: PUSH
63821: EMPTY
63822: LIST
63823: LIST
63824: PUSH
63825: EMPTY
63826: LIST
63827: LIST
63828: LIST
63829: LIST
63830: LIST
63831: LIST
63832: LIST
63833: LIST
63834: LIST
63835: LIST
63836: LIST
63837: LIST
63838: LIST
63839: LIST
63840: LIST
63841: LIST
63842: LIST
63843: LIST
63844: LIST
63845: LIST
63846: LIST
63847: LIST
63848: LIST
63849: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
63850: LD_ADDR_VAR 0 29
63854: PUSH
63855: LD_INT 0
63857: PUSH
63858: LD_INT 0
63860: PUSH
63861: EMPTY
63862: LIST
63863: LIST
63864: PUSH
63865: LD_INT 0
63867: PUSH
63868: LD_INT 1
63870: NEG
63871: PUSH
63872: EMPTY
63873: LIST
63874: LIST
63875: PUSH
63876: LD_INT 1
63878: PUSH
63879: LD_INT 0
63881: PUSH
63882: EMPTY
63883: LIST
63884: LIST
63885: PUSH
63886: LD_INT 1
63888: PUSH
63889: LD_INT 1
63891: PUSH
63892: EMPTY
63893: LIST
63894: LIST
63895: PUSH
63896: LD_INT 0
63898: PUSH
63899: LD_INT 1
63901: PUSH
63902: EMPTY
63903: LIST
63904: LIST
63905: PUSH
63906: LD_INT 1
63908: NEG
63909: PUSH
63910: LD_INT 0
63912: PUSH
63913: EMPTY
63914: LIST
63915: LIST
63916: PUSH
63917: LD_INT 1
63919: NEG
63920: PUSH
63921: LD_INT 1
63923: NEG
63924: PUSH
63925: EMPTY
63926: LIST
63927: LIST
63928: PUSH
63929: LD_INT 1
63931: NEG
63932: PUSH
63933: LD_INT 2
63935: NEG
63936: PUSH
63937: EMPTY
63938: LIST
63939: LIST
63940: PUSH
63941: LD_INT 0
63943: PUSH
63944: LD_INT 2
63946: NEG
63947: PUSH
63948: EMPTY
63949: LIST
63950: LIST
63951: PUSH
63952: LD_INT 1
63954: PUSH
63955: LD_INT 1
63957: NEG
63958: PUSH
63959: EMPTY
63960: LIST
63961: LIST
63962: PUSH
63963: LD_INT 2
63965: PUSH
63966: LD_INT 0
63968: PUSH
63969: EMPTY
63970: LIST
63971: LIST
63972: PUSH
63973: LD_INT 2
63975: PUSH
63976: LD_INT 1
63978: PUSH
63979: EMPTY
63980: LIST
63981: LIST
63982: PUSH
63983: LD_INT 1
63985: PUSH
63986: LD_INT 2
63988: PUSH
63989: EMPTY
63990: LIST
63991: LIST
63992: PUSH
63993: LD_INT 0
63995: PUSH
63996: LD_INT 2
63998: PUSH
63999: EMPTY
64000: LIST
64001: LIST
64002: PUSH
64003: LD_INT 1
64005: NEG
64006: PUSH
64007: LD_INT 1
64009: PUSH
64010: EMPTY
64011: LIST
64012: LIST
64013: PUSH
64014: LD_INT 2
64016: NEG
64017: PUSH
64018: LD_INT 1
64020: NEG
64021: PUSH
64022: EMPTY
64023: LIST
64024: LIST
64025: PUSH
64026: LD_INT 2
64028: NEG
64029: PUSH
64030: LD_INT 2
64032: NEG
64033: PUSH
64034: EMPTY
64035: LIST
64036: LIST
64037: PUSH
64038: LD_INT 2
64040: NEG
64041: PUSH
64042: LD_INT 3
64044: NEG
64045: PUSH
64046: EMPTY
64047: LIST
64048: LIST
64049: PUSH
64050: LD_INT 2
64052: PUSH
64053: LD_INT 1
64055: NEG
64056: PUSH
64057: EMPTY
64058: LIST
64059: LIST
64060: PUSH
64061: LD_INT 3
64063: PUSH
64064: LD_INT 1
64066: PUSH
64067: EMPTY
64068: LIST
64069: LIST
64070: PUSH
64071: LD_INT 1
64073: PUSH
64074: LD_INT 3
64076: PUSH
64077: EMPTY
64078: LIST
64079: LIST
64080: PUSH
64081: LD_INT 1
64083: NEG
64084: PUSH
64085: LD_INT 2
64087: PUSH
64088: EMPTY
64089: LIST
64090: LIST
64091: PUSH
64092: LD_INT 3
64094: NEG
64095: PUSH
64096: LD_INT 2
64098: NEG
64099: PUSH
64100: EMPTY
64101: LIST
64102: LIST
64103: PUSH
64104: EMPTY
64105: LIST
64106: LIST
64107: LIST
64108: LIST
64109: LIST
64110: LIST
64111: LIST
64112: LIST
64113: LIST
64114: LIST
64115: LIST
64116: LIST
64117: LIST
64118: LIST
64119: LIST
64120: LIST
64121: LIST
64122: LIST
64123: LIST
64124: LIST
64125: LIST
64126: LIST
64127: LIST
64128: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
64129: LD_ADDR_VAR 0 30
64133: PUSH
64134: LD_INT 0
64136: PUSH
64137: LD_INT 0
64139: PUSH
64140: EMPTY
64141: LIST
64142: LIST
64143: PUSH
64144: LD_INT 0
64146: PUSH
64147: LD_INT 1
64149: NEG
64150: PUSH
64151: EMPTY
64152: LIST
64153: LIST
64154: PUSH
64155: LD_INT 1
64157: PUSH
64158: LD_INT 0
64160: PUSH
64161: EMPTY
64162: LIST
64163: LIST
64164: PUSH
64165: LD_INT 1
64167: PUSH
64168: LD_INT 1
64170: PUSH
64171: EMPTY
64172: LIST
64173: LIST
64174: PUSH
64175: LD_INT 0
64177: PUSH
64178: LD_INT 1
64180: PUSH
64181: EMPTY
64182: LIST
64183: LIST
64184: PUSH
64185: LD_INT 1
64187: NEG
64188: PUSH
64189: LD_INT 0
64191: PUSH
64192: EMPTY
64193: LIST
64194: LIST
64195: PUSH
64196: LD_INT 1
64198: NEG
64199: PUSH
64200: LD_INT 1
64202: NEG
64203: PUSH
64204: EMPTY
64205: LIST
64206: LIST
64207: PUSH
64208: LD_INT 1
64210: NEG
64211: PUSH
64212: LD_INT 2
64214: NEG
64215: PUSH
64216: EMPTY
64217: LIST
64218: LIST
64219: PUSH
64220: LD_INT 0
64222: PUSH
64223: LD_INT 2
64225: NEG
64226: PUSH
64227: EMPTY
64228: LIST
64229: LIST
64230: PUSH
64231: LD_INT 1
64233: PUSH
64234: LD_INT 1
64236: NEG
64237: PUSH
64238: EMPTY
64239: LIST
64240: LIST
64241: PUSH
64242: LD_INT 2
64244: PUSH
64245: LD_INT 0
64247: PUSH
64248: EMPTY
64249: LIST
64250: LIST
64251: PUSH
64252: LD_INT 2
64254: PUSH
64255: LD_INT 1
64257: PUSH
64258: EMPTY
64259: LIST
64260: LIST
64261: PUSH
64262: LD_INT 2
64264: PUSH
64265: LD_INT 2
64267: PUSH
64268: EMPTY
64269: LIST
64270: LIST
64271: PUSH
64272: LD_INT 1
64274: PUSH
64275: LD_INT 2
64277: PUSH
64278: EMPTY
64279: LIST
64280: LIST
64281: PUSH
64282: LD_INT 1
64284: NEG
64285: PUSH
64286: LD_INT 1
64288: PUSH
64289: EMPTY
64290: LIST
64291: LIST
64292: PUSH
64293: LD_INT 2
64295: NEG
64296: PUSH
64297: LD_INT 0
64299: PUSH
64300: EMPTY
64301: LIST
64302: LIST
64303: PUSH
64304: LD_INT 2
64306: NEG
64307: PUSH
64308: LD_INT 1
64310: NEG
64311: PUSH
64312: EMPTY
64313: LIST
64314: LIST
64315: PUSH
64316: LD_INT 1
64318: NEG
64319: PUSH
64320: LD_INT 3
64322: NEG
64323: PUSH
64324: EMPTY
64325: LIST
64326: LIST
64327: PUSH
64328: LD_INT 1
64330: PUSH
64331: LD_INT 2
64333: NEG
64334: PUSH
64335: EMPTY
64336: LIST
64337: LIST
64338: PUSH
64339: LD_INT 3
64341: PUSH
64342: LD_INT 2
64344: PUSH
64345: EMPTY
64346: LIST
64347: LIST
64348: PUSH
64349: LD_INT 2
64351: PUSH
64352: LD_INT 3
64354: PUSH
64355: EMPTY
64356: LIST
64357: LIST
64358: PUSH
64359: LD_INT 2
64361: NEG
64362: PUSH
64363: LD_INT 1
64365: PUSH
64366: EMPTY
64367: LIST
64368: LIST
64369: PUSH
64370: LD_INT 3
64372: NEG
64373: PUSH
64374: LD_INT 1
64376: NEG
64377: PUSH
64378: EMPTY
64379: LIST
64380: LIST
64381: PUSH
64382: EMPTY
64383: LIST
64384: LIST
64385: LIST
64386: LIST
64387: LIST
64388: LIST
64389: LIST
64390: LIST
64391: LIST
64392: LIST
64393: LIST
64394: LIST
64395: LIST
64396: LIST
64397: LIST
64398: LIST
64399: LIST
64400: LIST
64401: LIST
64402: LIST
64403: LIST
64404: LIST
64405: LIST
64406: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
64407: LD_ADDR_VAR 0 31
64411: PUSH
64412: LD_INT 0
64414: PUSH
64415: LD_INT 0
64417: PUSH
64418: EMPTY
64419: LIST
64420: LIST
64421: PUSH
64422: LD_INT 0
64424: PUSH
64425: LD_INT 1
64427: NEG
64428: PUSH
64429: EMPTY
64430: LIST
64431: LIST
64432: PUSH
64433: LD_INT 1
64435: PUSH
64436: LD_INT 0
64438: PUSH
64439: EMPTY
64440: LIST
64441: LIST
64442: PUSH
64443: LD_INT 1
64445: PUSH
64446: LD_INT 1
64448: PUSH
64449: EMPTY
64450: LIST
64451: LIST
64452: PUSH
64453: LD_INT 0
64455: PUSH
64456: LD_INT 1
64458: PUSH
64459: EMPTY
64460: LIST
64461: LIST
64462: PUSH
64463: LD_INT 1
64465: NEG
64466: PUSH
64467: LD_INT 0
64469: PUSH
64470: EMPTY
64471: LIST
64472: LIST
64473: PUSH
64474: LD_INT 1
64476: NEG
64477: PUSH
64478: LD_INT 1
64480: NEG
64481: PUSH
64482: EMPTY
64483: LIST
64484: LIST
64485: PUSH
64486: LD_INT 1
64488: NEG
64489: PUSH
64490: LD_INT 2
64492: NEG
64493: PUSH
64494: EMPTY
64495: LIST
64496: LIST
64497: PUSH
64498: LD_INT 1
64500: PUSH
64501: LD_INT 1
64503: NEG
64504: PUSH
64505: EMPTY
64506: LIST
64507: LIST
64508: PUSH
64509: LD_INT 2
64511: PUSH
64512: LD_INT 0
64514: PUSH
64515: EMPTY
64516: LIST
64517: LIST
64518: PUSH
64519: LD_INT 2
64521: PUSH
64522: LD_INT 1
64524: PUSH
64525: EMPTY
64526: LIST
64527: LIST
64528: PUSH
64529: LD_INT 2
64531: PUSH
64532: LD_INT 2
64534: PUSH
64535: EMPTY
64536: LIST
64537: LIST
64538: PUSH
64539: LD_INT 1
64541: PUSH
64542: LD_INT 2
64544: PUSH
64545: EMPTY
64546: LIST
64547: LIST
64548: PUSH
64549: LD_INT 0
64551: PUSH
64552: LD_INT 2
64554: PUSH
64555: EMPTY
64556: LIST
64557: LIST
64558: PUSH
64559: LD_INT 1
64561: NEG
64562: PUSH
64563: LD_INT 1
64565: PUSH
64566: EMPTY
64567: LIST
64568: LIST
64569: PUSH
64570: LD_INT 2
64572: NEG
64573: PUSH
64574: LD_INT 1
64576: NEG
64577: PUSH
64578: EMPTY
64579: LIST
64580: LIST
64581: PUSH
64582: LD_INT 2
64584: NEG
64585: PUSH
64586: LD_INT 2
64588: NEG
64589: PUSH
64590: EMPTY
64591: LIST
64592: LIST
64593: PUSH
64594: LD_INT 2
64596: NEG
64597: PUSH
64598: LD_INT 3
64600: NEG
64601: PUSH
64602: EMPTY
64603: LIST
64604: LIST
64605: PUSH
64606: LD_INT 2
64608: PUSH
64609: LD_INT 1
64611: NEG
64612: PUSH
64613: EMPTY
64614: LIST
64615: LIST
64616: PUSH
64617: LD_INT 3
64619: PUSH
64620: LD_INT 1
64622: PUSH
64623: EMPTY
64624: LIST
64625: LIST
64626: PUSH
64627: LD_INT 1
64629: PUSH
64630: LD_INT 3
64632: PUSH
64633: EMPTY
64634: LIST
64635: LIST
64636: PUSH
64637: LD_INT 1
64639: NEG
64640: PUSH
64641: LD_INT 2
64643: PUSH
64644: EMPTY
64645: LIST
64646: LIST
64647: PUSH
64648: LD_INT 3
64650: NEG
64651: PUSH
64652: LD_INT 2
64654: NEG
64655: PUSH
64656: EMPTY
64657: LIST
64658: LIST
64659: PUSH
64660: EMPTY
64661: LIST
64662: LIST
64663: LIST
64664: LIST
64665: LIST
64666: LIST
64667: LIST
64668: LIST
64669: LIST
64670: LIST
64671: LIST
64672: LIST
64673: LIST
64674: LIST
64675: LIST
64676: LIST
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: LIST
64682: LIST
64683: LIST
64684: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
64685: LD_ADDR_VAR 0 32
64689: PUSH
64690: LD_INT 0
64692: PUSH
64693: LD_INT 0
64695: PUSH
64696: EMPTY
64697: LIST
64698: LIST
64699: PUSH
64700: LD_INT 0
64702: PUSH
64703: LD_INT 1
64705: NEG
64706: PUSH
64707: EMPTY
64708: LIST
64709: LIST
64710: PUSH
64711: LD_INT 1
64713: PUSH
64714: LD_INT 0
64716: PUSH
64717: EMPTY
64718: LIST
64719: LIST
64720: PUSH
64721: LD_INT 1
64723: PUSH
64724: LD_INT 1
64726: PUSH
64727: EMPTY
64728: LIST
64729: LIST
64730: PUSH
64731: LD_INT 0
64733: PUSH
64734: LD_INT 1
64736: PUSH
64737: EMPTY
64738: LIST
64739: LIST
64740: PUSH
64741: LD_INT 1
64743: NEG
64744: PUSH
64745: LD_INT 0
64747: PUSH
64748: EMPTY
64749: LIST
64750: LIST
64751: PUSH
64752: LD_INT 1
64754: NEG
64755: PUSH
64756: LD_INT 1
64758: NEG
64759: PUSH
64760: EMPTY
64761: LIST
64762: LIST
64763: PUSH
64764: LD_INT 1
64766: NEG
64767: PUSH
64768: LD_INT 2
64770: NEG
64771: PUSH
64772: EMPTY
64773: LIST
64774: LIST
64775: PUSH
64776: LD_INT 0
64778: PUSH
64779: LD_INT 2
64781: NEG
64782: PUSH
64783: EMPTY
64784: LIST
64785: LIST
64786: PUSH
64787: LD_INT 1
64789: PUSH
64790: LD_INT 1
64792: NEG
64793: PUSH
64794: EMPTY
64795: LIST
64796: LIST
64797: PUSH
64798: LD_INT 2
64800: PUSH
64801: LD_INT 1
64803: PUSH
64804: EMPTY
64805: LIST
64806: LIST
64807: PUSH
64808: LD_INT 2
64810: PUSH
64811: LD_INT 2
64813: PUSH
64814: EMPTY
64815: LIST
64816: LIST
64817: PUSH
64818: LD_INT 1
64820: PUSH
64821: LD_INT 2
64823: PUSH
64824: EMPTY
64825: LIST
64826: LIST
64827: PUSH
64828: LD_INT 0
64830: PUSH
64831: LD_INT 2
64833: PUSH
64834: EMPTY
64835: LIST
64836: LIST
64837: PUSH
64838: LD_INT 1
64840: NEG
64841: PUSH
64842: LD_INT 1
64844: PUSH
64845: EMPTY
64846: LIST
64847: LIST
64848: PUSH
64849: LD_INT 2
64851: NEG
64852: PUSH
64853: LD_INT 0
64855: PUSH
64856: EMPTY
64857: LIST
64858: LIST
64859: PUSH
64860: LD_INT 2
64862: NEG
64863: PUSH
64864: LD_INT 1
64866: NEG
64867: PUSH
64868: EMPTY
64869: LIST
64870: LIST
64871: PUSH
64872: LD_INT 1
64874: NEG
64875: PUSH
64876: LD_INT 3
64878: NEG
64879: PUSH
64880: EMPTY
64881: LIST
64882: LIST
64883: PUSH
64884: LD_INT 1
64886: PUSH
64887: LD_INT 2
64889: NEG
64890: PUSH
64891: EMPTY
64892: LIST
64893: LIST
64894: PUSH
64895: LD_INT 3
64897: PUSH
64898: LD_INT 2
64900: PUSH
64901: EMPTY
64902: LIST
64903: LIST
64904: PUSH
64905: LD_INT 2
64907: PUSH
64908: LD_INT 3
64910: PUSH
64911: EMPTY
64912: LIST
64913: LIST
64914: PUSH
64915: LD_INT 2
64917: NEG
64918: PUSH
64919: LD_INT 1
64921: PUSH
64922: EMPTY
64923: LIST
64924: LIST
64925: PUSH
64926: LD_INT 3
64928: NEG
64929: PUSH
64930: LD_INT 1
64932: NEG
64933: PUSH
64934: EMPTY
64935: LIST
64936: LIST
64937: PUSH
64938: EMPTY
64939: LIST
64940: LIST
64941: LIST
64942: LIST
64943: LIST
64944: LIST
64945: LIST
64946: LIST
64947: LIST
64948: LIST
64949: LIST
64950: LIST
64951: LIST
64952: LIST
64953: LIST
64954: LIST
64955: LIST
64956: LIST
64957: LIST
64958: LIST
64959: LIST
64960: LIST
64961: LIST
64962: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
64963: LD_ADDR_VAR 0 33
64967: PUSH
64968: LD_INT 0
64970: PUSH
64971: LD_INT 0
64973: PUSH
64974: EMPTY
64975: LIST
64976: LIST
64977: PUSH
64978: LD_INT 0
64980: PUSH
64981: LD_INT 1
64983: NEG
64984: PUSH
64985: EMPTY
64986: LIST
64987: LIST
64988: PUSH
64989: LD_INT 1
64991: PUSH
64992: LD_INT 0
64994: PUSH
64995: EMPTY
64996: LIST
64997: LIST
64998: PUSH
64999: LD_INT 1
65001: PUSH
65002: LD_INT 1
65004: PUSH
65005: EMPTY
65006: LIST
65007: LIST
65008: PUSH
65009: LD_INT 0
65011: PUSH
65012: LD_INT 1
65014: PUSH
65015: EMPTY
65016: LIST
65017: LIST
65018: PUSH
65019: LD_INT 1
65021: NEG
65022: PUSH
65023: LD_INT 0
65025: PUSH
65026: EMPTY
65027: LIST
65028: LIST
65029: PUSH
65030: LD_INT 1
65032: NEG
65033: PUSH
65034: LD_INT 1
65036: NEG
65037: PUSH
65038: EMPTY
65039: LIST
65040: LIST
65041: PUSH
65042: LD_INT 1
65044: NEG
65045: PUSH
65046: LD_INT 2
65048: NEG
65049: PUSH
65050: EMPTY
65051: LIST
65052: LIST
65053: PUSH
65054: LD_INT 1
65056: PUSH
65057: LD_INT 1
65059: NEG
65060: PUSH
65061: EMPTY
65062: LIST
65063: LIST
65064: PUSH
65065: LD_INT 2
65067: PUSH
65068: LD_INT 0
65070: PUSH
65071: EMPTY
65072: LIST
65073: LIST
65074: PUSH
65075: LD_INT 2
65077: PUSH
65078: LD_INT 1
65080: PUSH
65081: EMPTY
65082: LIST
65083: LIST
65084: PUSH
65085: LD_INT 1
65087: PUSH
65088: LD_INT 2
65090: PUSH
65091: EMPTY
65092: LIST
65093: LIST
65094: PUSH
65095: LD_INT 0
65097: PUSH
65098: LD_INT 2
65100: PUSH
65101: EMPTY
65102: LIST
65103: LIST
65104: PUSH
65105: LD_INT 1
65107: NEG
65108: PUSH
65109: LD_INT 1
65111: PUSH
65112: EMPTY
65113: LIST
65114: LIST
65115: PUSH
65116: LD_INT 2
65118: NEG
65119: PUSH
65120: LD_INT 0
65122: PUSH
65123: EMPTY
65124: LIST
65125: LIST
65126: PUSH
65127: LD_INT 2
65129: NEG
65130: PUSH
65131: LD_INT 1
65133: NEG
65134: PUSH
65135: EMPTY
65136: LIST
65137: LIST
65138: PUSH
65139: LD_INT 2
65141: NEG
65142: PUSH
65143: LD_INT 2
65145: NEG
65146: PUSH
65147: EMPTY
65148: LIST
65149: LIST
65150: PUSH
65151: LD_INT 2
65153: NEG
65154: PUSH
65155: LD_INT 3
65157: NEG
65158: PUSH
65159: EMPTY
65160: LIST
65161: LIST
65162: PUSH
65163: LD_INT 2
65165: PUSH
65166: LD_INT 1
65168: NEG
65169: PUSH
65170: EMPTY
65171: LIST
65172: LIST
65173: PUSH
65174: LD_INT 3
65176: PUSH
65177: LD_INT 1
65179: PUSH
65180: EMPTY
65181: LIST
65182: LIST
65183: PUSH
65184: LD_INT 1
65186: PUSH
65187: LD_INT 3
65189: PUSH
65190: EMPTY
65191: LIST
65192: LIST
65193: PUSH
65194: LD_INT 1
65196: NEG
65197: PUSH
65198: LD_INT 2
65200: PUSH
65201: EMPTY
65202: LIST
65203: LIST
65204: PUSH
65205: LD_INT 3
65207: NEG
65208: PUSH
65209: LD_INT 2
65211: NEG
65212: PUSH
65213: EMPTY
65214: LIST
65215: LIST
65216: PUSH
65217: EMPTY
65218: LIST
65219: LIST
65220: LIST
65221: LIST
65222: LIST
65223: LIST
65224: LIST
65225: LIST
65226: LIST
65227: LIST
65228: LIST
65229: LIST
65230: LIST
65231: LIST
65232: LIST
65233: LIST
65234: LIST
65235: LIST
65236: LIST
65237: LIST
65238: LIST
65239: LIST
65240: LIST
65241: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
65242: LD_ADDR_VAR 0 34
65246: PUSH
65247: LD_INT 0
65249: PUSH
65250: LD_INT 0
65252: PUSH
65253: EMPTY
65254: LIST
65255: LIST
65256: PUSH
65257: LD_INT 0
65259: PUSH
65260: LD_INT 1
65262: NEG
65263: PUSH
65264: EMPTY
65265: LIST
65266: LIST
65267: PUSH
65268: LD_INT 1
65270: PUSH
65271: LD_INT 0
65273: PUSH
65274: EMPTY
65275: LIST
65276: LIST
65277: PUSH
65278: LD_INT 1
65280: PUSH
65281: LD_INT 1
65283: PUSH
65284: EMPTY
65285: LIST
65286: LIST
65287: PUSH
65288: LD_INT 0
65290: PUSH
65291: LD_INT 1
65293: PUSH
65294: EMPTY
65295: LIST
65296: LIST
65297: PUSH
65298: LD_INT 1
65300: NEG
65301: PUSH
65302: LD_INT 0
65304: PUSH
65305: EMPTY
65306: LIST
65307: LIST
65308: PUSH
65309: LD_INT 1
65311: NEG
65312: PUSH
65313: LD_INT 1
65315: NEG
65316: PUSH
65317: EMPTY
65318: LIST
65319: LIST
65320: PUSH
65321: LD_INT 1
65323: NEG
65324: PUSH
65325: LD_INT 2
65327: NEG
65328: PUSH
65329: EMPTY
65330: LIST
65331: LIST
65332: PUSH
65333: LD_INT 0
65335: PUSH
65336: LD_INT 2
65338: NEG
65339: PUSH
65340: EMPTY
65341: LIST
65342: LIST
65343: PUSH
65344: LD_INT 1
65346: PUSH
65347: LD_INT 1
65349: NEG
65350: PUSH
65351: EMPTY
65352: LIST
65353: LIST
65354: PUSH
65355: LD_INT 2
65357: PUSH
65358: LD_INT 1
65360: PUSH
65361: EMPTY
65362: LIST
65363: LIST
65364: PUSH
65365: LD_INT 2
65367: PUSH
65368: LD_INT 2
65370: PUSH
65371: EMPTY
65372: LIST
65373: LIST
65374: PUSH
65375: LD_INT 1
65377: PUSH
65378: LD_INT 2
65380: PUSH
65381: EMPTY
65382: LIST
65383: LIST
65384: PUSH
65385: LD_INT 1
65387: NEG
65388: PUSH
65389: LD_INT 1
65391: PUSH
65392: EMPTY
65393: LIST
65394: LIST
65395: PUSH
65396: LD_INT 2
65398: NEG
65399: PUSH
65400: LD_INT 0
65402: PUSH
65403: EMPTY
65404: LIST
65405: LIST
65406: PUSH
65407: LD_INT 2
65409: NEG
65410: PUSH
65411: LD_INT 1
65413: NEG
65414: PUSH
65415: EMPTY
65416: LIST
65417: LIST
65418: PUSH
65419: LD_INT 2
65421: NEG
65422: PUSH
65423: LD_INT 2
65425: NEG
65426: PUSH
65427: EMPTY
65428: LIST
65429: LIST
65430: PUSH
65431: LD_INT 1
65433: NEG
65434: PUSH
65435: LD_INT 3
65437: NEG
65438: PUSH
65439: EMPTY
65440: LIST
65441: LIST
65442: PUSH
65443: LD_INT 1
65445: PUSH
65446: LD_INT 2
65448: NEG
65449: PUSH
65450: EMPTY
65451: LIST
65452: LIST
65453: PUSH
65454: LD_INT 3
65456: PUSH
65457: LD_INT 2
65459: PUSH
65460: EMPTY
65461: LIST
65462: LIST
65463: PUSH
65464: LD_INT 2
65466: PUSH
65467: LD_INT 3
65469: PUSH
65470: EMPTY
65471: LIST
65472: LIST
65473: PUSH
65474: LD_INT 2
65476: NEG
65477: PUSH
65478: LD_INT 1
65480: PUSH
65481: EMPTY
65482: LIST
65483: LIST
65484: PUSH
65485: LD_INT 3
65487: NEG
65488: PUSH
65489: LD_INT 1
65491: NEG
65492: PUSH
65493: EMPTY
65494: LIST
65495: LIST
65496: PUSH
65497: EMPTY
65498: LIST
65499: LIST
65500: LIST
65501: LIST
65502: LIST
65503: LIST
65504: LIST
65505: LIST
65506: LIST
65507: LIST
65508: LIST
65509: LIST
65510: LIST
65511: LIST
65512: LIST
65513: LIST
65514: LIST
65515: LIST
65516: LIST
65517: LIST
65518: LIST
65519: LIST
65520: LIST
65521: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
65522: LD_ADDR_VAR 0 35
65526: PUSH
65527: LD_INT 0
65529: PUSH
65530: LD_INT 0
65532: PUSH
65533: EMPTY
65534: LIST
65535: LIST
65536: PUSH
65537: LD_INT 0
65539: PUSH
65540: LD_INT 1
65542: NEG
65543: PUSH
65544: EMPTY
65545: LIST
65546: LIST
65547: PUSH
65548: LD_INT 1
65550: PUSH
65551: LD_INT 0
65553: PUSH
65554: EMPTY
65555: LIST
65556: LIST
65557: PUSH
65558: LD_INT 1
65560: PUSH
65561: LD_INT 1
65563: PUSH
65564: EMPTY
65565: LIST
65566: LIST
65567: PUSH
65568: LD_INT 0
65570: PUSH
65571: LD_INT 1
65573: PUSH
65574: EMPTY
65575: LIST
65576: LIST
65577: PUSH
65578: LD_INT 1
65580: NEG
65581: PUSH
65582: LD_INT 0
65584: PUSH
65585: EMPTY
65586: LIST
65587: LIST
65588: PUSH
65589: LD_INT 1
65591: NEG
65592: PUSH
65593: LD_INT 1
65595: NEG
65596: PUSH
65597: EMPTY
65598: LIST
65599: LIST
65600: PUSH
65601: LD_INT 2
65603: PUSH
65604: LD_INT 1
65606: PUSH
65607: EMPTY
65608: LIST
65609: LIST
65610: PUSH
65611: LD_INT 2
65613: NEG
65614: PUSH
65615: LD_INT 1
65617: NEG
65618: PUSH
65619: EMPTY
65620: LIST
65621: LIST
65622: PUSH
65623: EMPTY
65624: LIST
65625: LIST
65626: LIST
65627: LIST
65628: LIST
65629: LIST
65630: LIST
65631: LIST
65632: LIST
65633: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
65634: LD_ADDR_VAR 0 36
65638: PUSH
65639: LD_INT 0
65641: PUSH
65642: LD_INT 0
65644: PUSH
65645: EMPTY
65646: LIST
65647: LIST
65648: PUSH
65649: LD_INT 0
65651: PUSH
65652: LD_INT 1
65654: NEG
65655: PUSH
65656: EMPTY
65657: LIST
65658: LIST
65659: PUSH
65660: LD_INT 1
65662: PUSH
65663: LD_INT 0
65665: PUSH
65666: EMPTY
65667: LIST
65668: LIST
65669: PUSH
65670: LD_INT 1
65672: PUSH
65673: LD_INT 1
65675: PUSH
65676: EMPTY
65677: LIST
65678: LIST
65679: PUSH
65680: LD_INT 0
65682: PUSH
65683: LD_INT 1
65685: PUSH
65686: EMPTY
65687: LIST
65688: LIST
65689: PUSH
65690: LD_INT 1
65692: NEG
65693: PUSH
65694: LD_INT 0
65696: PUSH
65697: EMPTY
65698: LIST
65699: LIST
65700: PUSH
65701: LD_INT 1
65703: NEG
65704: PUSH
65705: LD_INT 1
65707: NEG
65708: PUSH
65709: EMPTY
65710: LIST
65711: LIST
65712: PUSH
65713: LD_INT 1
65715: NEG
65716: PUSH
65717: LD_INT 2
65719: NEG
65720: PUSH
65721: EMPTY
65722: LIST
65723: LIST
65724: PUSH
65725: LD_INT 1
65727: PUSH
65728: LD_INT 2
65730: PUSH
65731: EMPTY
65732: LIST
65733: LIST
65734: PUSH
65735: EMPTY
65736: LIST
65737: LIST
65738: LIST
65739: LIST
65740: LIST
65741: LIST
65742: LIST
65743: LIST
65744: LIST
65745: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
65746: LD_ADDR_VAR 0 37
65750: PUSH
65751: LD_INT 0
65753: PUSH
65754: LD_INT 0
65756: PUSH
65757: EMPTY
65758: LIST
65759: LIST
65760: PUSH
65761: LD_INT 0
65763: PUSH
65764: LD_INT 1
65766: NEG
65767: PUSH
65768: EMPTY
65769: LIST
65770: LIST
65771: PUSH
65772: LD_INT 1
65774: PUSH
65775: LD_INT 0
65777: PUSH
65778: EMPTY
65779: LIST
65780: LIST
65781: PUSH
65782: LD_INT 1
65784: PUSH
65785: LD_INT 1
65787: PUSH
65788: EMPTY
65789: LIST
65790: LIST
65791: PUSH
65792: LD_INT 0
65794: PUSH
65795: LD_INT 1
65797: PUSH
65798: EMPTY
65799: LIST
65800: LIST
65801: PUSH
65802: LD_INT 1
65804: NEG
65805: PUSH
65806: LD_INT 0
65808: PUSH
65809: EMPTY
65810: LIST
65811: LIST
65812: PUSH
65813: LD_INT 1
65815: NEG
65816: PUSH
65817: LD_INT 1
65819: NEG
65820: PUSH
65821: EMPTY
65822: LIST
65823: LIST
65824: PUSH
65825: LD_INT 1
65827: PUSH
65828: LD_INT 1
65830: NEG
65831: PUSH
65832: EMPTY
65833: LIST
65834: LIST
65835: PUSH
65836: LD_INT 1
65838: NEG
65839: PUSH
65840: LD_INT 1
65842: PUSH
65843: EMPTY
65844: LIST
65845: LIST
65846: PUSH
65847: EMPTY
65848: LIST
65849: LIST
65850: LIST
65851: LIST
65852: LIST
65853: LIST
65854: LIST
65855: LIST
65856: LIST
65857: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
65858: LD_ADDR_VAR 0 38
65862: PUSH
65863: LD_INT 0
65865: PUSH
65866: LD_INT 0
65868: PUSH
65869: EMPTY
65870: LIST
65871: LIST
65872: PUSH
65873: LD_INT 0
65875: PUSH
65876: LD_INT 1
65878: NEG
65879: PUSH
65880: EMPTY
65881: LIST
65882: LIST
65883: PUSH
65884: LD_INT 1
65886: PUSH
65887: LD_INT 0
65889: PUSH
65890: EMPTY
65891: LIST
65892: LIST
65893: PUSH
65894: LD_INT 1
65896: PUSH
65897: LD_INT 1
65899: PUSH
65900: EMPTY
65901: LIST
65902: LIST
65903: PUSH
65904: LD_INT 0
65906: PUSH
65907: LD_INT 1
65909: PUSH
65910: EMPTY
65911: LIST
65912: LIST
65913: PUSH
65914: LD_INT 1
65916: NEG
65917: PUSH
65918: LD_INT 0
65920: PUSH
65921: EMPTY
65922: LIST
65923: LIST
65924: PUSH
65925: LD_INT 1
65927: NEG
65928: PUSH
65929: LD_INT 1
65931: NEG
65932: PUSH
65933: EMPTY
65934: LIST
65935: LIST
65936: PUSH
65937: LD_INT 2
65939: PUSH
65940: LD_INT 1
65942: PUSH
65943: EMPTY
65944: LIST
65945: LIST
65946: PUSH
65947: LD_INT 2
65949: NEG
65950: PUSH
65951: LD_INT 1
65953: NEG
65954: PUSH
65955: EMPTY
65956: LIST
65957: LIST
65958: PUSH
65959: EMPTY
65960: LIST
65961: LIST
65962: LIST
65963: LIST
65964: LIST
65965: LIST
65966: LIST
65967: LIST
65968: LIST
65969: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
65970: LD_ADDR_VAR 0 39
65974: PUSH
65975: LD_INT 0
65977: PUSH
65978: LD_INT 0
65980: PUSH
65981: EMPTY
65982: LIST
65983: LIST
65984: PUSH
65985: LD_INT 0
65987: PUSH
65988: LD_INT 1
65990: NEG
65991: PUSH
65992: EMPTY
65993: LIST
65994: LIST
65995: PUSH
65996: LD_INT 1
65998: PUSH
65999: LD_INT 0
66001: PUSH
66002: EMPTY
66003: LIST
66004: LIST
66005: PUSH
66006: LD_INT 1
66008: PUSH
66009: LD_INT 1
66011: PUSH
66012: EMPTY
66013: LIST
66014: LIST
66015: PUSH
66016: LD_INT 0
66018: PUSH
66019: LD_INT 1
66021: PUSH
66022: EMPTY
66023: LIST
66024: LIST
66025: PUSH
66026: LD_INT 1
66028: NEG
66029: PUSH
66030: LD_INT 0
66032: PUSH
66033: EMPTY
66034: LIST
66035: LIST
66036: PUSH
66037: LD_INT 1
66039: NEG
66040: PUSH
66041: LD_INT 1
66043: NEG
66044: PUSH
66045: EMPTY
66046: LIST
66047: LIST
66048: PUSH
66049: LD_INT 1
66051: NEG
66052: PUSH
66053: LD_INT 2
66055: NEG
66056: PUSH
66057: EMPTY
66058: LIST
66059: LIST
66060: PUSH
66061: LD_INT 1
66063: PUSH
66064: LD_INT 2
66066: PUSH
66067: EMPTY
66068: LIST
66069: LIST
66070: PUSH
66071: EMPTY
66072: LIST
66073: LIST
66074: LIST
66075: LIST
66076: LIST
66077: LIST
66078: LIST
66079: LIST
66080: LIST
66081: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
66082: LD_ADDR_VAR 0 40
66086: PUSH
66087: LD_INT 0
66089: PUSH
66090: LD_INT 0
66092: PUSH
66093: EMPTY
66094: LIST
66095: LIST
66096: PUSH
66097: LD_INT 0
66099: PUSH
66100: LD_INT 1
66102: NEG
66103: PUSH
66104: EMPTY
66105: LIST
66106: LIST
66107: PUSH
66108: LD_INT 1
66110: PUSH
66111: LD_INT 0
66113: PUSH
66114: EMPTY
66115: LIST
66116: LIST
66117: PUSH
66118: LD_INT 1
66120: PUSH
66121: LD_INT 1
66123: PUSH
66124: EMPTY
66125: LIST
66126: LIST
66127: PUSH
66128: LD_INT 0
66130: PUSH
66131: LD_INT 1
66133: PUSH
66134: EMPTY
66135: LIST
66136: LIST
66137: PUSH
66138: LD_INT 1
66140: NEG
66141: PUSH
66142: LD_INT 0
66144: PUSH
66145: EMPTY
66146: LIST
66147: LIST
66148: PUSH
66149: LD_INT 1
66151: NEG
66152: PUSH
66153: LD_INT 1
66155: NEG
66156: PUSH
66157: EMPTY
66158: LIST
66159: LIST
66160: PUSH
66161: LD_INT 1
66163: PUSH
66164: LD_INT 1
66166: NEG
66167: PUSH
66168: EMPTY
66169: LIST
66170: LIST
66171: PUSH
66172: LD_INT 1
66174: NEG
66175: PUSH
66176: LD_INT 1
66178: PUSH
66179: EMPTY
66180: LIST
66181: LIST
66182: PUSH
66183: EMPTY
66184: LIST
66185: LIST
66186: LIST
66187: LIST
66188: LIST
66189: LIST
66190: LIST
66191: LIST
66192: LIST
66193: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66194: LD_ADDR_VAR 0 41
66198: PUSH
66199: LD_INT 0
66201: PUSH
66202: LD_INT 0
66204: PUSH
66205: EMPTY
66206: LIST
66207: LIST
66208: PUSH
66209: LD_INT 0
66211: PUSH
66212: LD_INT 1
66214: NEG
66215: PUSH
66216: EMPTY
66217: LIST
66218: LIST
66219: PUSH
66220: LD_INT 1
66222: PUSH
66223: LD_INT 0
66225: PUSH
66226: EMPTY
66227: LIST
66228: LIST
66229: PUSH
66230: LD_INT 1
66232: PUSH
66233: LD_INT 1
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: PUSH
66240: LD_INT 0
66242: PUSH
66243: LD_INT 1
66245: PUSH
66246: EMPTY
66247: LIST
66248: LIST
66249: PUSH
66250: LD_INT 1
66252: NEG
66253: PUSH
66254: LD_INT 0
66256: PUSH
66257: EMPTY
66258: LIST
66259: LIST
66260: PUSH
66261: LD_INT 1
66263: NEG
66264: PUSH
66265: LD_INT 1
66267: NEG
66268: PUSH
66269: EMPTY
66270: LIST
66271: LIST
66272: PUSH
66273: LD_INT 1
66275: NEG
66276: PUSH
66277: LD_INT 2
66279: NEG
66280: PUSH
66281: EMPTY
66282: LIST
66283: LIST
66284: PUSH
66285: LD_INT 1
66287: PUSH
66288: LD_INT 1
66290: NEG
66291: PUSH
66292: EMPTY
66293: LIST
66294: LIST
66295: PUSH
66296: LD_INT 2
66298: PUSH
66299: LD_INT 0
66301: PUSH
66302: EMPTY
66303: LIST
66304: LIST
66305: PUSH
66306: LD_INT 2
66308: PUSH
66309: LD_INT 1
66311: PUSH
66312: EMPTY
66313: LIST
66314: LIST
66315: PUSH
66316: LD_INT 2
66318: PUSH
66319: LD_INT 2
66321: PUSH
66322: EMPTY
66323: LIST
66324: LIST
66325: PUSH
66326: LD_INT 1
66328: PUSH
66329: LD_INT 2
66331: PUSH
66332: EMPTY
66333: LIST
66334: LIST
66335: PUSH
66336: LD_INT 1
66338: NEG
66339: PUSH
66340: LD_INT 1
66342: PUSH
66343: EMPTY
66344: LIST
66345: LIST
66346: PUSH
66347: LD_INT 2
66349: NEG
66350: PUSH
66351: LD_INT 0
66353: PUSH
66354: EMPTY
66355: LIST
66356: LIST
66357: PUSH
66358: LD_INT 2
66360: NEG
66361: PUSH
66362: LD_INT 1
66364: NEG
66365: PUSH
66366: EMPTY
66367: LIST
66368: LIST
66369: PUSH
66370: LD_INT 2
66372: NEG
66373: PUSH
66374: LD_INT 2
66376: NEG
66377: PUSH
66378: EMPTY
66379: LIST
66380: LIST
66381: PUSH
66382: LD_INT 2
66384: NEG
66385: PUSH
66386: LD_INT 3
66388: NEG
66389: PUSH
66390: EMPTY
66391: LIST
66392: LIST
66393: PUSH
66394: LD_INT 2
66396: PUSH
66397: LD_INT 1
66399: NEG
66400: PUSH
66401: EMPTY
66402: LIST
66403: LIST
66404: PUSH
66405: LD_INT 3
66407: PUSH
66408: LD_INT 0
66410: PUSH
66411: EMPTY
66412: LIST
66413: LIST
66414: PUSH
66415: LD_INT 3
66417: PUSH
66418: LD_INT 1
66420: PUSH
66421: EMPTY
66422: LIST
66423: LIST
66424: PUSH
66425: LD_INT 3
66427: PUSH
66428: LD_INT 2
66430: PUSH
66431: EMPTY
66432: LIST
66433: LIST
66434: PUSH
66435: LD_INT 3
66437: PUSH
66438: LD_INT 3
66440: PUSH
66441: EMPTY
66442: LIST
66443: LIST
66444: PUSH
66445: LD_INT 2
66447: PUSH
66448: LD_INT 3
66450: PUSH
66451: EMPTY
66452: LIST
66453: LIST
66454: PUSH
66455: LD_INT 2
66457: NEG
66458: PUSH
66459: LD_INT 1
66461: PUSH
66462: EMPTY
66463: LIST
66464: LIST
66465: PUSH
66466: LD_INT 3
66468: NEG
66469: PUSH
66470: LD_INT 0
66472: PUSH
66473: EMPTY
66474: LIST
66475: LIST
66476: PUSH
66477: LD_INT 3
66479: NEG
66480: PUSH
66481: LD_INT 1
66483: NEG
66484: PUSH
66485: EMPTY
66486: LIST
66487: LIST
66488: PUSH
66489: LD_INT 3
66491: NEG
66492: PUSH
66493: LD_INT 2
66495: NEG
66496: PUSH
66497: EMPTY
66498: LIST
66499: LIST
66500: PUSH
66501: LD_INT 3
66503: NEG
66504: PUSH
66505: LD_INT 3
66507: NEG
66508: PUSH
66509: EMPTY
66510: LIST
66511: LIST
66512: PUSH
66513: EMPTY
66514: LIST
66515: LIST
66516: LIST
66517: LIST
66518: LIST
66519: LIST
66520: LIST
66521: LIST
66522: LIST
66523: LIST
66524: LIST
66525: LIST
66526: LIST
66527: LIST
66528: LIST
66529: LIST
66530: LIST
66531: LIST
66532: LIST
66533: LIST
66534: LIST
66535: LIST
66536: LIST
66537: LIST
66538: LIST
66539: LIST
66540: LIST
66541: LIST
66542: LIST
66543: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66544: LD_ADDR_VAR 0 42
66548: PUSH
66549: LD_INT 0
66551: PUSH
66552: LD_INT 0
66554: PUSH
66555: EMPTY
66556: LIST
66557: LIST
66558: PUSH
66559: LD_INT 0
66561: PUSH
66562: LD_INT 1
66564: NEG
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: PUSH
66570: LD_INT 1
66572: PUSH
66573: LD_INT 0
66575: PUSH
66576: EMPTY
66577: LIST
66578: LIST
66579: PUSH
66580: LD_INT 1
66582: PUSH
66583: LD_INT 1
66585: PUSH
66586: EMPTY
66587: LIST
66588: LIST
66589: PUSH
66590: LD_INT 0
66592: PUSH
66593: LD_INT 1
66595: PUSH
66596: EMPTY
66597: LIST
66598: LIST
66599: PUSH
66600: LD_INT 1
66602: NEG
66603: PUSH
66604: LD_INT 0
66606: PUSH
66607: EMPTY
66608: LIST
66609: LIST
66610: PUSH
66611: LD_INT 1
66613: NEG
66614: PUSH
66615: LD_INT 1
66617: NEG
66618: PUSH
66619: EMPTY
66620: LIST
66621: LIST
66622: PUSH
66623: LD_INT 1
66625: NEG
66626: PUSH
66627: LD_INT 2
66629: NEG
66630: PUSH
66631: EMPTY
66632: LIST
66633: LIST
66634: PUSH
66635: LD_INT 0
66637: PUSH
66638: LD_INT 2
66640: NEG
66641: PUSH
66642: EMPTY
66643: LIST
66644: LIST
66645: PUSH
66646: LD_INT 1
66648: PUSH
66649: LD_INT 1
66651: NEG
66652: PUSH
66653: EMPTY
66654: LIST
66655: LIST
66656: PUSH
66657: LD_INT 2
66659: PUSH
66660: LD_INT 1
66662: PUSH
66663: EMPTY
66664: LIST
66665: LIST
66666: PUSH
66667: LD_INT 2
66669: PUSH
66670: LD_INT 2
66672: PUSH
66673: EMPTY
66674: LIST
66675: LIST
66676: PUSH
66677: LD_INT 1
66679: PUSH
66680: LD_INT 2
66682: PUSH
66683: EMPTY
66684: LIST
66685: LIST
66686: PUSH
66687: LD_INT 0
66689: PUSH
66690: LD_INT 2
66692: PUSH
66693: EMPTY
66694: LIST
66695: LIST
66696: PUSH
66697: LD_INT 1
66699: NEG
66700: PUSH
66701: LD_INT 1
66703: PUSH
66704: EMPTY
66705: LIST
66706: LIST
66707: PUSH
66708: LD_INT 2
66710: NEG
66711: PUSH
66712: LD_INT 1
66714: NEG
66715: PUSH
66716: EMPTY
66717: LIST
66718: LIST
66719: PUSH
66720: LD_INT 2
66722: NEG
66723: PUSH
66724: LD_INT 2
66726: NEG
66727: PUSH
66728: EMPTY
66729: LIST
66730: LIST
66731: PUSH
66732: LD_INT 2
66734: NEG
66735: PUSH
66736: LD_INT 3
66738: NEG
66739: PUSH
66740: EMPTY
66741: LIST
66742: LIST
66743: PUSH
66744: LD_INT 1
66746: NEG
66747: PUSH
66748: LD_INT 3
66750: NEG
66751: PUSH
66752: EMPTY
66753: LIST
66754: LIST
66755: PUSH
66756: LD_INT 0
66758: PUSH
66759: LD_INT 3
66761: NEG
66762: PUSH
66763: EMPTY
66764: LIST
66765: LIST
66766: PUSH
66767: LD_INT 1
66769: PUSH
66770: LD_INT 2
66772: NEG
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: PUSH
66778: LD_INT 3
66780: PUSH
66781: LD_INT 2
66783: PUSH
66784: EMPTY
66785: LIST
66786: LIST
66787: PUSH
66788: LD_INT 3
66790: PUSH
66791: LD_INT 3
66793: PUSH
66794: EMPTY
66795: LIST
66796: LIST
66797: PUSH
66798: LD_INT 2
66800: PUSH
66801: LD_INT 3
66803: PUSH
66804: EMPTY
66805: LIST
66806: LIST
66807: PUSH
66808: LD_INT 1
66810: PUSH
66811: LD_INT 3
66813: PUSH
66814: EMPTY
66815: LIST
66816: LIST
66817: PUSH
66818: LD_INT 0
66820: PUSH
66821: LD_INT 3
66823: PUSH
66824: EMPTY
66825: LIST
66826: LIST
66827: PUSH
66828: LD_INT 1
66830: NEG
66831: PUSH
66832: LD_INT 2
66834: PUSH
66835: EMPTY
66836: LIST
66837: LIST
66838: PUSH
66839: LD_INT 3
66841: NEG
66842: PUSH
66843: LD_INT 2
66845: NEG
66846: PUSH
66847: EMPTY
66848: LIST
66849: LIST
66850: PUSH
66851: LD_INT 3
66853: NEG
66854: PUSH
66855: LD_INT 3
66857: NEG
66858: PUSH
66859: EMPTY
66860: LIST
66861: LIST
66862: PUSH
66863: EMPTY
66864: LIST
66865: LIST
66866: LIST
66867: LIST
66868: LIST
66869: LIST
66870: LIST
66871: LIST
66872: LIST
66873: LIST
66874: LIST
66875: LIST
66876: LIST
66877: LIST
66878: LIST
66879: LIST
66880: LIST
66881: LIST
66882: LIST
66883: LIST
66884: LIST
66885: LIST
66886: LIST
66887: LIST
66888: LIST
66889: LIST
66890: LIST
66891: LIST
66892: LIST
66893: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66894: LD_ADDR_VAR 0 43
66898: PUSH
66899: LD_INT 0
66901: PUSH
66902: LD_INT 0
66904: PUSH
66905: EMPTY
66906: LIST
66907: LIST
66908: PUSH
66909: LD_INT 0
66911: PUSH
66912: LD_INT 1
66914: NEG
66915: PUSH
66916: EMPTY
66917: LIST
66918: LIST
66919: PUSH
66920: LD_INT 1
66922: PUSH
66923: LD_INT 0
66925: PUSH
66926: EMPTY
66927: LIST
66928: LIST
66929: PUSH
66930: LD_INT 1
66932: PUSH
66933: LD_INT 1
66935: PUSH
66936: EMPTY
66937: LIST
66938: LIST
66939: PUSH
66940: LD_INT 0
66942: PUSH
66943: LD_INT 1
66945: PUSH
66946: EMPTY
66947: LIST
66948: LIST
66949: PUSH
66950: LD_INT 1
66952: NEG
66953: PUSH
66954: LD_INT 0
66956: PUSH
66957: EMPTY
66958: LIST
66959: LIST
66960: PUSH
66961: LD_INT 1
66963: NEG
66964: PUSH
66965: LD_INT 1
66967: NEG
66968: PUSH
66969: EMPTY
66970: LIST
66971: LIST
66972: PUSH
66973: LD_INT 1
66975: NEG
66976: PUSH
66977: LD_INT 2
66979: NEG
66980: PUSH
66981: EMPTY
66982: LIST
66983: LIST
66984: PUSH
66985: LD_INT 0
66987: PUSH
66988: LD_INT 2
66990: NEG
66991: PUSH
66992: EMPTY
66993: LIST
66994: LIST
66995: PUSH
66996: LD_INT 1
66998: PUSH
66999: LD_INT 1
67001: NEG
67002: PUSH
67003: EMPTY
67004: LIST
67005: LIST
67006: PUSH
67007: LD_INT 2
67009: PUSH
67010: LD_INT 0
67012: PUSH
67013: EMPTY
67014: LIST
67015: LIST
67016: PUSH
67017: LD_INT 2
67019: PUSH
67020: LD_INT 1
67022: PUSH
67023: EMPTY
67024: LIST
67025: LIST
67026: PUSH
67027: LD_INT 1
67029: PUSH
67030: LD_INT 2
67032: PUSH
67033: EMPTY
67034: LIST
67035: LIST
67036: PUSH
67037: LD_INT 0
67039: PUSH
67040: LD_INT 2
67042: PUSH
67043: EMPTY
67044: LIST
67045: LIST
67046: PUSH
67047: LD_INT 1
67049: NEG
67050: PUSH
67051: LD_INT 1
67053: PUSH
67054: EMPTY
67055: LIST
67056: LIST
67057: PUSH
67058: LD_INT 2
67060: NEG
67061: PUSH
67062: LD_INT 0
67064: PUSH
67065: EMPTY
67066: LIST
67067: LIST
67068: PUSH
67069: LD_INT 2
67071: NEG
67072: PUSH
67073: LD_INT 1
67075: NEG
67076: PUSH
67077: EMPTY
67078: LIST
67079: LIST
67080: PUSH
67081: LD_INT 1
67083: NEG
67084: PUSH
67085: LD_INT 3
67087: NEG
67088: PUSH
67089: EMPTY
67090: LIST
67091: LIST
67092: PUSH
67093: LD_INT 0
67095: PUSH
67096: LD_INT 3
67098: NEG
67099: PUSH
67100: EMPTY
67101: LIST
67102: LIST
67103: PUSH
67104: LD_INT 1
67106: PUSH
67107: LD_INT 2
67109: NEG
67110: PUSH
67111: EMPTY
67112: LIST
67113: LIST
67114: PUSH
67115: LD_INT 2
67117: PUSH
67118: LD_INT 1
67120: NEG
67121: PUSH
67122: EMPTY
67123: LIST
67124: LIST
67125: PUSH
67126: LD_INT 3
67128: PUSH
67129: LD_INT 0
67131: PUSH
67132: EMPTY
67133: LIST
67134: LIST
67135: PUSH
67136: LD_INT 3
67138: PUSH
67139: LD_INT 1
67141: PUSH
67142: EMPTY
67143: LIST
67144: LIST
67145: PUSH
67146: LD_INT 1
67148: PUSH
67149: LD_INT 3
67151: PUSH
67152: EMPTY
67153: LIST
67154: LIST
67155: PUSH
67156: LD_INT 0
67158: PUSH
67159: LD_INT 3
67161: PUSH
67162: EMPTY
67163: LIST
67164: LIST
67165: PUSH
67166: LD_INT 1
67168: NEG
67169: PUSH
67170: LD_INT 2
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: PUSH
67177: LD_INT 2
67179: NEG
67180: PUSH
67181: LD_INT 1
67183: PUSH
67184: EMPTY
67185: LIST
67186: LIST
67187: PUSH
67188: LD_INT 3
67190: NEG
67191: PUSH
67192: LD_INT 0
67194: PUSH
67195: EMPTY
67196: LIST
67197: LIST
67198: PUSH
67199: LD_INT 3
67201: NEG
67202: PUSH
67203: LD_INT 1
67205: NEG
67206: PUSH
67207: EMPTY
67208: LIST
67209: LIST
67210: PUSH
67211: EMPTY
67212: LIST
67213: LIST
67214: LIST
67215: LIST
67216: LIST
67217: LIST
67218: LIST
67219: LIST
67220: LIST
67221: LIST
67222: LIST
67223: LIST
67224: LIST
67225: LIST
67226: LIST
67227: LIST
67228: LIST
67229: LIST
67230: LIST
67231: LIST
67232: LIST
67233: LIST
67234: LIST
67235: LIST
67236: LIST
67237: LIST
67238: LIST
67239: LIST
67240: LIST
67241: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67242: LD_ADDR_VAR 0 44
67246: PUSH
67247: LD_INT 0
67249: PUSH
67250: LD_INT 0
67252: PUSH
67253: EMPTY
67254: LIST
67255: LIST
67256: PUSH
67257: LD_INT 0
67259: PUSH
67260: LD_INT 1
67262: NEG
67263: PUSH
67264: EMPTY
67265: LIST
67266: LIST
67267: PUSH
67268: LD_INT 1
67270: PUSH
67271: LD_INT 0
67273: PUSH
67274: EMPTY
67275: LIST
67276: LIST
67277: PUSH
67278: LD_INT 1
67280: PUSH
67281: LD_INT 1
67283: PUSH
67284: EMPTY
67285: LIST
67286: LIST
67287: PUSH
67288: LD_INT 0
67290: PUSH
67291: LD_INT 1
67293: PUSH
67294: EMPTY
67295: LIST
67296: LIST
67297: PUSH
67298: LD_INT 1
67300: NEG
67301: PUSH
67302: LD_INT 0
67304: PUSH
67305: EMPTY
67306: LIST
67307: LIST
67308: PUSH
67309: LD_INT 1
67311: NEG
67312: PUSH
67313: LD_INT 1
67315: NEG
67316: PUSH
67317: EMPTY
67318: LIST
67319: LIST
67320: PUSH
67321: LD_INT 1
67323: NEG
67324: PUSH
67325: LD_INT 2
67327: NEG
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: PUSH
67333: LD_INT 1
67335: PUSH
67336: LD_INT 1
67338: NEG
67339: PUSH
67340: EMPTY
67341: LIST
67342: LIST
67343: PUSH
67344: LD_INT 2
67346: PUSH
67347: LD_INT 0
67349: PUSH
67350: EMPTY
67351: LIST
67352: LIST
67353: PUSH
67354: LD_INT 2
67356: PUSH
67357: LD_INT 1
67359: PUSH
67360: EMPTY
67361: LIST
67362: LIST
67363: PUSH
67364: LD_INT 2
67366: PUSH
67367: LD_INT 2
67369: PUSH
67370: EMPTY
67371: LIST
67372: LIST
67373: PUSH
67374: LD_INT 1
67376: PUSH
67377: LD_INT 2
67379: PUSH
67380: EMPTY
67381: LIST
67382: LIST
67383: PUSH
67384: LD_INT 1
67386: NEG
67387: PUSH
67388: LD_INT 1
67390: PUSH
67391: EMPTY
67392: LIST
67393: LIST
67394: PUSH
67395: LD_INT 2
67397: NEG
67398: PUSH
67399: LD_INT 0
67401: PUSH
67402: EMPTY
67403: LIST
67404: LIST
67405: PUSH
67406: LD_INT 2
67408: NEG
67409: PUSH
67410: LD_INT 1
67412: NEG
67413: PUSH
67414: EMPTY
67415: LIST
67416: LIST
67417: PUSH
67418: LD_INT 2
67420: NEG
67421: PUSH
67422: LD_INT 2
67424: NEG
67425: PUSH
67426: EMPTY
67427: LIST
67428: LIST
67429: PUSH
67430: LD_INT 2
67432: NEG
67433: PUSH
67434: LD_INT 3
67436: NEG
67437: PUSH
67438: EMPTY
67439: LIST
67440: LIST
67441: PUSH
67442: LD_INT 2
67444: PUSH
67445: LD_INT 1
67447: NEG
67448: PUSH
67449: EMPTY
67450: LIST
67451: LIST
67452: PUSH
67453: LD_INT 3
67455: PUSH
67456: LD_INT 0
67458: PUSH
67459: EMPTY
67460: LIST
67461: LIST
67462: PUSH
67463: LD_INT 3
67465: PUSH
67466: LD_INT 1
67468: PUSH
67469: EMPTY
67470: LIST
67471: LIST
67472: PUSH
67473: LD_INT 3
67475: PUSH
67476: LD_INT 2
67478: PUSH
67479: EMPTY
67480: LIST
67481: LIST
67482: PUSH
67483: LD_INT 3
67485: PUSH
67486: LD_INT 3
67488: PUSH
67489: EMPTY
67490: LIST
67491: LIST
67492: PUSH
67493: LD_INT 2
67495: PUSH
67496: LD_INT 3
67498: PUSH
67499: EMPTY
67500: LIST
67501: LIST
67502: PUSH
67503: LD_INT 2
67505: NEG
67506: PUSH
67507: LD_INT 1
67509: PUSH
67510: EMPTY
67511: LIST
67512: LIST
67513: PUSH
67514: LD_INT 3
67516: NEG
67517: PUSH
67518: LD_INT 0
67520: PUSH
67521: EMPTY
67522: LIST
67523: LIST
67524: PUSH
67525: LD_INT 3
67527: NEG
67528: PUSH
67529: LD_INT 1
67531: NEG
67532: PUSH
67533: EMPTY
67534: LIST
67535: LIST
67536: PUSH
67537: LD_INT 3
67539: NEG
67540: PUSH
67541: LD_INT 2
67543: NEG
67544: PUSH
67545: EMPTY
67546: LIST
67547: LIST
67548: PUSH
67549: LD_INT 3
67551: NEG
67552: PUSH
67553: LD_INT 3
67555: NEG
67556: PUSH
67557: EMPTY
67558: LIST
67559: LIST
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: LIST
67565: LIST
67566: LIST
67567: LIST
67568: LIST
67569: LIST
67570: LIST
67571: LIST
67572: LIST
67573: LIST
67574: LIST
67575: LIST
67576: LIST
67577: LIST
67578: LIST
67579: LIST
67580: LIST
67581: LIST
67582: LIST
67583: LIST
67584: LIST
67585: LIST
67586: LIST
67587: LIST
67588: LIST
67589: LIST
67590: LIST
67591: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67592: LD_ADDR_VAR 0 45
67596: PUSH
67597: LD_INT 0
67599: PUSH
67600: LD_INT 0
67602: PUSH
67603: EMPTY
67604: LIST
67605: LIST
67606: PUSH
67607: LD_INT 0
67609: PUSH
67610: LD_INT 1
67612: NEG
67613: PUSH
67614: EMPTY
67615: LIST
67616: LIST
67617: PUSH
67618: LD_INT 1
67620: PUSH
67621: LD_INT 0
67623: PUSH
67624: EMPTY
67625: LIST
67626: LIST
67627: PUSH
67628: LD_INT 1
67630: PUSH
67631: LD_INT 1
67633: PUSH
67634: EMPTY
67635: LIST
67636: LIST
67637: PUSH
67638: LD_INT 0
67640: PUSH
67641: LD_INT 1
67643: PUSH
67644: EMPTY
67645: LIST
67646: LIST
67647: PUSH
67648: LD_INT 1
67650: NEG
67651: PUSH
67652: LD_INT 0
67654: PUSH
67655: EMPTY
67656: LIST
67657: LIST
67658: PUSH
67659: LD_INT 1
67661: NEG
67662: PUSH
67663: LD_INT 1
67665: NEG
67666: PUSH
67667: EMPTY
67668: LIST
67669: LIST
67670: PUSH
67671: LD_INT 1
67673: NEG
67674: PUSH
67675: LD_INT 2
67677: NEG
67678: PUSH
67679: EMPTY
67680: LIST
67681: LIST
67682: PUSH
67683: LD_INT 0
67685: PUSH
67686: LD_INT 2
67688: NEG
67689: PUSH
67690: EMPTY
67691: LIST
67692: LIST
67693: PUSH
67694: LD_INT 1
67696: PUSH
67697: LD_INT 1
67699: NEG
67700: PUSH
67701: EMPTY
67702: LIST
67703: LIST
67704: PUSH
67705: LD_INT 2
67707: PUSH
67708: LD_INT 1
67710: PUSH
67711: EMPTY
67712: LIST
67713: LIST
67714: PUSH
67715: LD_INT 2
67717: PUSH
67718: LD_INT 2
67720: PUSH
67721: EMPTY
67722: LIST
67723: LIST
67724: PUSH
67725: LD_INT 1
67727: PUSH
67728: LD_INT 2
67730: PUSH
67731: EMPTY
67732: LIST
67733: LIST
67734: PUSH
67735: LD_INT 0
67737: PUSH
67738: LD_INT 2
67740: PUSH
67741: EMPTY
67742: LIST
67743: LIST
67744: PUSH
67745: LD_INT 1
67747: NEG
67748: PUSH
67749: LD_INT 1
67751: PUSH
67752: EMPTY
67753: LIST
67754: LIST
67755: PUSH
67756: LD_INT 2
67758: NEG
67759: PUSH
67760: LD_INT 1
67762: NEG
67763: PUSH
67764: EMPTY
67765: LIST
67766: LIST
67767: PUSH
67768: LD_INT 2
67770: NEG
67771: PUSH
67772: LD_INT 2
67774: NEG
67775: PUSH
67776: EMPTY
67777: LIST
67778: LIST
67779: PUSH
67780: LD_INT 2
67782: NEG
67783: PUSH
67784: LD_INT 3
67786: NEG
67787: PUSH
67788: EMPTY
67789: LIST
67790: LIST
67791: PUSH
67792: LD_INT 1
67794: NEG
67795: PUSH
67796: LD_INT 3
67798: NEG
67799: PUSH
67800: EMPTY
67801: LIST
67802: LIST
67803: PUSH
67804: LD_INT 0
67806: PUSH
67807: LD_INT 3
67809: NEG
67810: PUSH
67811: EMPTY
67812: LIST
67813: LIST
67814: PUSH
67815: LD_INT 1
67817: PUSH
67818: LD_INT 2
67820: NEG
67821: PUSH
67822: EMPTY
67823: LIST
67824: LIST
67825: PUSH
67826: LD_INT 3
67828: PUSH
67829: LD_INT 2
67831: PUSH
67832: EMPTY
67833: LIST
67834: LIST
67835: PUSH
67836: LD_INT 3
67838: PUSH
67839: LD_INT 3
67841: PUSH
67842: EMPTY
67843: LIST
67844: LIST
67845: PUSH
67846: LD_INT 2
67848: PUSH
67849: LD_INT 3
67851: PUSH
67852: EMPTY
67853: LIST
67854: LIST
67855: PUSH
67856: LD_INT 1
67858: PUSH
67859: LD_INT 3
67861: PUSH
67862: EMPTY
67863: LIST
67864: LIST
67865: PUSH
67866: LD_INT 0
67868: PUSH
67869: LD_INT 3
67871: PUSH
67872: EMPTY
67873: LIST
67874: LIST
67875: PUSH
67876: LD_INT 1
67878: NEG
67879: PUSH
67880: LD_INT 2
67882: PUSH
67883: EMPTY
67884: LIST
67885: LIST
67886: PUSH
67887: LD_INT 3
67889: NEG
67890: PUSH
67891: LD_INT 2
67893: NEG
67894: PUSH
67895: EMPTY
67896: LIST
67897: LIST
67898: PUSH
67899: LD_INT 3
67901: NEG
67902: PUSH
67903: LD_INT 3
67905: NEG
67906: PUSH
67907: EMPTY
67908: LIST
67909: LIST
67910: PUSH
67911: EMPTY
67912: LIST
67913: LIST
67914: LIST
67915: LIST
67916: LIST
67917: LIST
67918: LIST
67919: LIST
67920: LIST
67921: LIST
67922: LIST
67923: LIST
67924: LIST
67925: LIST
67926: LIST
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: LIST
67935: LIST
67936: LIST
67937: LIST
67938: LIST
67939: LIST
67940: LIST
67941: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
67942: LD_ADDR_VAR 0 46
67946: PUSH
67947: LD_INT 0
67949: PUSH
67950: LD_INT 0
67952: PUSH
67953: EMPTY
67954: LIST
67955: LIST
67956: PUSH
67957: LD_INT 0
67959: PUSH
67960: LD_INT 1
67962: NEG
67963: PUSH
67964: EMPTY
67965: LIST
67966: LIST
67967: PUSH
67968: LD_INT 1
67970: PUSH
67971: LD_INT 0
67973: PUSH
67974: EMPTY
67975: LIST
67976: LIST
67977: PUSH
67978: LD_INT 1
67980: PUSH
67981: LD_INT 1
67983: PUSH
67984: EMPTY
67985: LIST
67986: LIST
67987: PUSH
67988: LD_INT 0
67990: PUSH
67991: LD_INT 1
67993: PUSH
67994: EMPTY
67995: LIST
67996: LIST
67997: PUSH
67998: LD_INT 1
68000: NEG
68001: PUSH
68002: LD_INT 0
68004: PUSH
68005: EMPTY
68006: LIST
68007: LIST
68008: PUSH
68009: LD_INT 1
68011: NEG
68012: PUSH
68013: LD_INT 1
68015: NEG
68016: PUSH
68017: EMPTY
68018: LIST
68019: LIST
68020: PUSH
68021: LD_INT 1
68023: NEG
68024: PUSH
68025: LD_INT 2
68027: NEG
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: PUSH
68033: LD_INT 0
68035: PUSH
68036: LD_INT 2
68038: NEG
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: PUSH
68044: LD_INT 1
68046: PUSH
68047: LD_INT 1
68049: NEG
68050: PUSH
68051: EMPTY
68052: LIST
68053: LIST
68054: PUSH
68055: LD_INT 2
68057: PUSH
68058: LD_INT 0
68060: PUSH
68061: EMPTY
68062: LIST
68063: LIST
68064: PUSH
68065: LD_INT 2
68067: PUSH
68068: LD_INT 1
68070: PUSH
68071: EMPTY
68072: LIST
68073: LIST
68074: PUSH
68075: LD_INT 1
68077: PUSH
68078: LD_INT 2
68080: PUSH
68081: EMPTY
68082: LIST
68083: LIST
68084: PUSH
68085: LD_INT 0
68087: PUSH
68088: LD_INT 2
68090: PUSH
68091: EMPTY
68092: LIST
68093: LIST
68094: PUSH
68095: LD_INT 1
68097: NEG
68098: PUSH
68099: LD_INT 1
68101: PUSH
68102: EMPTY
68103: LIST
68104: LIST
68105: PUSH
68106: LD_INT 2
68108: NEG
68109: PUSH
68110: LD_INT 0
68112: PUSH
68113: EMPTY
68114: LIST
68115: LIST
68116: PUSH
68117: LD_INT 2
68119: NEG
68120: PUSH
68121: LD_INT 1
68123: NEG
68124: PUSH
68125: EMPTY
68126: LIST
68127: LIST
68128: PUSH
68129: LD_INT 1
68131: NEG
68132: PUSH
68133: LD_INT 3
68135: NEG
68136: PUSH
68137: EMPTY
68138: LIST
68139: LIST
68140: PUSH
68141: LD_INT 0
68143: PUSH
68144: LD_INT 3
68146: NEG
68147: PUSH
68148: EMPTY
68149: LIST
68150: LIST
68151: PUSH
68152: LD_INT 1
68154: PUSH
68155: LD_INT 2
68157: NEG
68158: PUSH
68159: EMPTY
68160: LIST
68161: LIST
68162: PUSH
68163: LD_INT 2
68165: PUSH
68166: LD_INT 1
68168: NEG
68169: PUSH
68170: EMPTY
68171: LIST
68172: LIST
68173: PUSH
68174: LD_INT 3
68176: PUSH
68177: LD_INT 0
68179: PUSH
68180: EMPTY
68181: LIST
68182: LIST
68183: PUSH
68184: LD_INT 3
68186: PUSH
68187: LD_INT 1
68189: PUSH
68190: EMPTY
68191: LIST
68192: LIST
68193: PUSH
68194: LD_INT 1
68196: PUSH
68197: LD_INT 3
68199: PUSH
68200: EMPTY
68201: LIST
68202: LIST
68203: PUSH
68204: LD_INT 0
68206: PUSH
68207: LD_INT 3
68209: PUSH
68210: EMPTY
68211: LIST
68212: LIST
68213: PUSH
68214: LD_INT 1
68216: NEG
68217: PUSH
68218: LD_INT 2
68220: PUSH
68221: EMPTY
68222: LIST
68223: LIST
68224: PUSH
68225: LD_INT 2
68227: NEG
68228: PUSH
68229: LD_INT 1
68231: PUSH
68232: EMPTY
68233: LIST
68234: LIST
68235: PUSH
68236: LD_INT 3
68238: NEG
68239: PUSH
68240: LD_INT 0
68242: PUSH
68243: EMPTY
68244: LIST
68245: LIST
68246: PUSH
68247: LD_INT 3
68249: NEG
68250: PUSH
68251: LD_INT 1
68253: NEG
68254: PUSH
68255: EMPTY
68256: LIST
68257: LIST
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: LIST
68263: LIST
68264: LIST
68265: LIST
68266: LIST
68267: LIST
68268: LIST
68269: LIST
68270: LIST
68271: LIST
68272: LIST
68273: LIST
68274: LIST
68275: LIST
68276: LIST
68277: LIST
68278: LIST
68279: LIST
68280: LIST
68281: LIST
68282: LIST
68283: LIST
68284: LIST
68285: LIST
68286: LIST
68287: LIST
68288: LIST
68289: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68290: LD_ADDR_VAR 0 47
68294: PUSH
68295: LD_INT 0
68297: PUSH
68298: LD_INT 0
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: PUSH
68305: LD_INT 0
68307: PUSH
68308: LD_INT 1
68310: NEG
68311: PUSH
68312: EMPTY
68313: LIST
68314: LIST
68315: PUSH
68316: LD_INT 1
68318: PUSH
68319: LD_INT 0
68321: PUSH
68322: EMPTY
68323: LIST
68324: LIST
68325: PUSH
68326: LD_INT 1
68328: PUSH
68329: LD_INT 1
68331: PUSH
68332: EMPTY
68333: LIST
68334: LIST
68335: PUSH
68336: LD_INT 0
68338: PUSH
68339: LD_INT 1
68341: PUSH
68342: EMPTY
68343: LIST
68344: LIST
68345: PUSH
68346: LD_INT 1
68348: NEG
68349: PUSH
68350: LD_INT 0
68352: PUSH
68353: EMPTY
68354: LIST
68355: LIST
68356: PUSH
68357: LD_INT 1
68359: NEG
68360: PUSH
68361: LD_INT 1
68363: NEG
68364: PUSH
68365: EMPTY
68366: LIST
68367: LIST
68368: PUSH
68369: LD_INT 1
68371: NEG
68372: PUSH
68373: LD_INT 2
68375: NEG
68376: PUSH
68377: EMPTY
68378: LIST
68379: LIST
68380: PUSH
68381: LD_INT 0
68383: PUSH
68384: LD_INT 2
68386: NEG
68387: PUSH
68388: EMPTY
68389: LIST
68390: LIST
68391: PUSH
68392: LD_INT 1
68394: PUSH
68395: LD_INT 1
68397: NEG
68398: PUSH
68399: EMPTY
68400: LIST
68401: LIST
68402: PUSH
68403: LD_INT 2
68405: NEG
68406: PUSH
68407: LD_INT 1
68409: NEG
68410: PUSH
68411: EMPTY
68412: LIST
68413: LIST
68414: PUSH
68415: LD_INT 2
68417: NEG
68418: PUSH
68419: LD_INT 2
68421: NEG
68422: PUSH
68423: EMPTY
68424: LIST
68425: LIST
68426: PUSH
68427: EMPTY
68428: LIST
68429: LIST
68430: LIST
68431: LIST
68432: LIST
68433: LIST
68434: LIST
68435: LIST
68436: LIST
68437: LIST
68438: LIST
68439: LIST
68440: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
68441: LD_ADDR_VAR 0 48
68445: PUSH
68446: LD_INT 0
68448: PUSH
68449: LD_INT 0
68451: PUSH
68452: EMPTY
68453: LIST
68454: LIST
68455: PUSH
68456: LD_INT 0
68458: PUSH
68459: LD_INT 1
68461: NEG
68462: PUSH
68463: EMPTY
68464: LIST
68465: LIST
68466: PUSH
68467: LD_INT 1
68469: PUSH
68470: LD_INT 0
68472: PUSH
68473: EMPTY
68474: LIST
68475: LIST
68476: PUSH
68477: LD_INT 1
68479: PUSH
68480: LD_INT 1
68482: PUSH
68483: EMPTY
68484: LIST
68485: LIST
68486: PUSH
68487: LD_INT 0
68489: PUSH
68490: LD_INT 1
68492: PUSH
68493: EMPTY
68494: LIST
68495: LIST
68496: PUSH
68497: LD_INT 1
68499: NEG
68500: PUSH
68501: LD_INT 0
68503: PUSH
68504: EMPTY
68505: LIST
68506: LIST
68507: PUSH
68508: LD_INT 1
68510: NEG
68511: PUSH
68512: LD_INT 1
68514: NEG
68515: PUSH
68516: EMPTY
68517: LIST
68518: LIST
68519: PUSH
68520: LD_INT 1
68522: NEG
68523: PUSH
68524: LD_INT 2
68526: NEG
68527: PUSH
68528: EMPTY
68529: LIST
68530: LIST
68531: PUSH
68532: LD_INT 0
68534: PUSH
68535: LD_INT 2
68537: NEG
68538: PUSH
68539: EMPTY
68540: LIST
68541: LIST
68542: PUSH
68543: LD_INT 1
68545: PUSH
68546: LD_INT 1
68548: NEG
68549: PUSH
68550: EMPTY
68551: LIST
68552: LIST
68553: PUSH
68554: LD_INT 2
68556: PUSH
68557: LD_INT 0
68559: PUSH
68560: EMPTY
68561: LIST
68562: LIST
68563: PUSH
68564: LD_INT 2
68566: PUSH
68567: LD_INT 1
68569: PUSH
68570: EMPTY
68571: LIST
68572: LIST
68573: PUSH
68574: EMPTY
68575: LIST
68576: LIST
68577: LIST
68578: LIST
68579: LIST
68580: LIST
68581: LIST
68582: LIST
68583: LIST
68584: LIST
68585: LIST
68586: LIST
68587: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
68588: LD_ADDR_VAR 0 49
68592: PUSH
68593: LD_INT 0
68595: PUSH
68596: LD_INT 0
68598: PUSH
68599: EMPTY
68600: LIST
68601: LIST
68602: PUSH
68603: LD_INT 0
68605: PUSH
68606: LD_INT 1
68608: NEG
68609: PUSH
68610: EMPTY
68611: LIST
68612: LIST
68613: PUSH
68614: LD_INT 1
68616: PUSH
68617: LD_INT 0
68619: PUSH
68620: EMPTY
68621: LIST
68622: LIST
68623: PUSH
68624: LD_INT 1
68626: PUSH
68627: LD_INT 1
68629: PUSH
68630: EMPTY
68631: LIST
68632: LIST
68633: PUSH
68634: LD_INT 0
68636: PUSH
68637: LD_INT 1
68639: PUSH
68640: EMPTY
68641: LIST
68642: LIST
68643: PUSH
68644: LD_INT 1
68646: NEG
68647: PUSH
68648: LD_INT 0
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: PUSH
68655: LD_INT 1
68657: NEG
68658: PUSH
68659: LD_INT 1
68661: NEG
68662: PUSH
68663: EMPTY
68664: LIST
68665: LIST
68666: PUSH
68667: LD_INT 1
68669: PUSH
68670: LD_INT 1
68672: NEG
68673: PUSH
68674: EMPTY
68675: LIST
68676: LIST
68677: PUSH
68678: LD_INT 2
68680: PUSH
68681: LD_INT 0
68683: PUSH
68684: EMPTY
68685: LIST
68686: LIST
68687: PUSH
68688: LD_INT 2
68690: PUSH
68691: LD_INT 1
68693: PUSH
68694: EMPTY
68695: LIST
68696: LIST
68697: PUSH
68698: LD_INT 2
68700: PUSH
68701: LD_INT 2
68703: PUSH
68704: EMPTY
68705: LIST
68706: LIST
68707: PUSH
68708: LD_INT 1
68710: PUSH
68711: LD_INT 2
68713: PUSH
68714: EMPTY
68715: LIST
68716: LIST
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: LIST
68722: LIST
68723: LIST
68724: LIST
68725: LIST
68726: LIST
68727: LIST
68728: LIST
68729: LIST
68730: LIST
68731: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
68732: LD_ADDR_VAR 0 50
68736: PUSH
68737: LD_INT 0
68739: PUSH
68740: LD_INT 0
68742: PUSH
68743: EMPTY
68744: LIST
68745: LIST
68746: PUSH
68747: LD_INT 0
68749: PUSH
68750: LD_INT 1
68752: NEG
68753: PUSH
68754: EMPTY
68755: LIST
68756: LIST
68757: PUSH
68758: LD_INT 1
68760: PUSH
68761: LD_INT 0
68763: PUSH
68764: EMPTY
68765: LIST
68766: LIST
68767: PUSH
68768: LD_INT 1
68770: PUSH
68771: LD_INT 1
68773: PUSH
68774: EMPTY
68775: LIST
68776: LIST
68777: PUSH
68778: LD_INT 0
68780: PUSH
68781: LD_INT 1
68783: PUSH
68784: EMPTY
68785: LIST
68786: LIST
68787: PUSH
68788: LD_INT 1
68790: NEG
68791: PUSH
68792: LD_INT 0
68794: PUSH
68795: EMPTY
68796: LIST
68797: LIST
68798: PUSH
68799: LD_INT 1
68801: NEG
68802: PUSH
68803: LD_INT 1
68805: NEG
68806: PUSH
68807: EMPTY
68808: LIST
68809: LIST
68810: PUSH
68811: LD_INT 2
68813: PUSH
68814: LD_INT 1
68816: PUSH
68817: EMPTY
68818: LIST
68819: LIST
68820: PUSH
68821: LD_INT 2
68823: PUSH
68824: LD_INT 2
68826: PUSH
68827: EMPTY
68828: LIST
68829: LIST
68830: PUSH
68831: LD_INT 1
68833: PUSH
68834: LD_INT 2
68836: PUSH
68837: EMPTY
68838: LIST
68839: LIST
68840: PUSH
68841: LD_INT 0
68843: PUSH
68844: LD_INT 2
68846: PUSH
68847: EMPTY
68848: LIST
68849: LIST
68850: PUSH
68851: LD_INT 1
68853: NEG
68854: PUSH
68855: LD_INT 1
68857: PUSH
68858: EMPTY
68859: LIST
68860: LIST
68861: PUSH
68862: EMPTY
68863: LIST
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: LIST
68872: LIST
68873: LIST
68874: LIST
68875: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
68876: LD_ADDR_VAR 0 51
68880: PUSH
68881: LD_INT 0
68883: PUSH
68884: LD_INT 0
68886: PUSH
68887: EMPTY
68888: LIST
68889: LIST
68890: PUSH
68891: LD_INT 0
68893: PUSH
68894: LD_INT 1
68896: NEG
68897: PUSH
68898: EMPTY
68899: LIST
68900: LIST
68901: PUSH
68902: LD_INT 1
68904: PUSH
68905: LD_INT 0
68907: PUSH
68908: EMPTY
68909: LIST
68910: LIST
68911: PUSH
68912: LD_INT 1
68914: PUSH
68915: LD_INT 1
68917: PUSH
68918: EMPTY
68919: LIST
68920: LIST
68921: PUSH
68922: LD_INT 0
68924: PUSH
68925: LD_INT 1
68927: PUSH
68928: EMPTY
68929: LIST
68930: LIST
68931: PUSH
68932: LD_INT 1
68934: NEG
68935: PUSH
68936: LD_INT 0
68938: PUSH
68939: EMPTY
68940: LIST
68941: LIST
68942: PUSH
68943: LD_INT 1
68945: NEG
68946: PUSH
68947: LD_INT 1
68949: NEG
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: PUSH
68955: LD_INT 1
68957: PUSH
68958: LD_INT 2
68960: PUSH
68961: EMPTY
68962: LIST
68963: LIST
68964: PUSH
68965: LD_INT 0
68967: PUSH
68968: LD_INT 2
68970: PUSH
68971: EMPTY
68972: LIST
68973: LIST
68974: PUSH
68975: LD_INT 1
68977: NEG
68978: PUSH
68979: LD_INT 1
68981: PUSH
68982: EMPTY
68983: LIST
68984: LIST
68985: PUSH
68986: LD_INT 2
68988: NEG
68989: PUSH
68990: LD_INT 0
68992: PUSH
68993: EMPTY
68994: LIST
68995: LIST
68996: PUSH
68997: LD_INT 2
68999: NEG
69000: PUSH
69001: LD_INT 1
69003: NEG
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: PUSH
69009: EMPTY
69010: LIST
69011: LIST
69012: LIST
69013: LIST
69014: LIST
69015: LIST
69016: LIST
69017: LIST
69018: LIST
69019: LIST
69020: LIST
69021: LIST
69022: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69023: LD_ADDR_VAR 0 52
69027: PUSH
69028: LD_INT 0
69030: PUSH
69031: LD_INT 0
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: LD_INT 0
69040: PUSH
69041: LD_INT 1
69043: NEG
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: LD_INT 1
69051: PUSH
69052: LD_INT 0
69054: PUSH
69055: EMPTY
69056: LIST
69057: LIST
69058: PUSH
69059: LD_INT 1
69061: PUSH
69062: LD_INT 1
69064: PUSH
69065: EMPTY
69066: LIST
69067: LIST
69068: PUSH
69069: LD_INT 0
69071: PUSH
69072: LD_INT 1
69074: PUSH
69075: EMPTY
69076: LIST
69077: LIST
69078: PUSH
69079: LD_INT 1
69081: NEG
69082: PUSH
69083: LD_INT 0
69085: PUSH
69086: EMPTY
69087: LIST
69088: LIST
69089: PUSH
69090: LD_INT 1
69092: NEG
69093: PUSH
69094: LD_INT 1
69096: NEG
69097: PUSH
69098: EMPTY
69099: LIST
69100: LIST
69101: PUSH
69102: LD_INT 1
69104: NEG
69105: PUSH
69106: LD_INT 2
69108: NEG
69109: PUSH
69110: EMPTY
69111: LIST
69112: LIST
69113: PUSH
69114: LD_INT 1
69116: NEG
69117: PUSH
69118: LD_INT 1
69120: PUSH
69121: EMPTY
69122: LIST
69123: LIST
69124: PUSH
69125: LD_INT 2
69127: NEG
69128: PUSH
69129: LD_INT 0
69131: PUSH
69132: EMPTY
69133: LIST
69134: LIST
69135: PUSH
69136: LD_INT 2
69138: NEG
69139: PUSH
69140: LD_INT 1
69142: NEG
69143: PUSH
69144: EMPTY
69145: LIST
69146: LIST
69147: PUSH
69148: LD_INT 2
69150: NEG
69151: PUSH
69152: LD_INT 2
69154: NEG
69155: PUSH
69156: EMPTY
69157: LIST
69158: LIST
69159: PUSH
69160: EMPTY
69161: LIST
69162: LIST
69163: LIST
69164: LIST
69165: LIST
69166: LIST
69167: LIST
69168: LIST
69169: LIST
69170: LIST
69171: LIST
69172: LIST
69173: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69174: LD_ADDR_VAR 0 53
69178: PUSH
69179: LD_INT 0
69181: PUSH
69182: LD_INT 0
69184: PUSH
69185: EMPTY
69186: LIST
69187: LIST
69188: PUSH
69189: LD_INT 0
69191: PUSH
69192: LD_INT 1
69194: NEG
69195: PUSH
69196: EMPTY
69197: LIST
69198: LIST
69199: PUSH
69200: LD_INT 1
69202: PUSH
69203: LD_INT 0
69205: PUSH
69206: EMPTY
69207: LIST
69208: LIST
69209: PUSH
69210: LD_INT 1
69212: PUSH
69213: LD_INT 1
69215: PUSH
69216: EMPTY
69217: LIST
69218: LIST
69219: PUSH
69220: LD_INT 0
69222: PUSH
69223: LD_INT 1
69225: PUSH
69226: EMPTY
69227: LIST
69228: LIST
69229: PUSH
69230: LD_INT 1
69232: NEG
69233: PUSH
69234: LD_INT 0
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: PUSH
69241: LD_INT 1
69243: NEG
69244: PUSH
69245: LD_INT 1
69247: NEG
69248: PUSH
69249: EMPTY
69250: LIST
69251: LIST
69252: PUSH
69253: LD_INT 1
69255: NEG
69256: PUSH
69257: LD_INT 2
69259: NEG
69260: PUSH
69261: EMPTY
69262: LIST
69263: LIST
69264: PUSH
69265: LD_INT 0
69267: PUSH
69268: LD_INT 2
69270: NEG
69271: PUSH
69272: EMPTY
69273: LIST
69274: LIST
69275: PUSH
69276: LD_INT 1
69278: PUSH
69279: LD_INT 1
69281: NEG
69282: PUSH
69283: EMPTY
69284: LIST
69285: LIST
69286: PUSH
69287: LD_INT 2
69289: PUSH
69290: LD_INT 0
69292: PUSH
69293: EMPTY
69294: LIST
69295: LIST
69296: PUSH
69297: LD_INT 2
69299: PUSH
69300: LD_INT 1
69302: PUSH
69303: EMPTY
69304: LIST
69305: LIST
69306: PUSH
69307: LD_INT 2
69309: PUSH
69310: LD_INT 2
69312: PUSH
69313: EMPTY
69314: LIST
69315: LIST
69316: PUSH
69317: LD_INT 1
69319: PUSH
69320: LD_INT 2
69322: PUSH
69323: EMPTY
69324: LIST
69325: LIST
69326: PUSH
69327: LD_INT 0
69329: PUSH
69330: LD_INT 2
69332: PUSH
69333: EMPTY
69334: LIST
69335: LIST
69336: PUSH
69337: LD_INT 1
69339: NEG
69340: PUSH
69341: LD_INT 1
69343: PUSH
69344: EMPTY
69345: LIST
69346: LIST
69347: PUSH
69348: LD_INT 2
69350: NEG
69351: PUSH
69352: LD_INT 0
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: PUSH
69359: LD_INT 2
69361: NEG
69362: PUSH
69363: LD_INT 1
69365: NEG
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: PUSH
69371: LD_INT 2
69373: NEG
69374: PUSH
69375: LD_INT 2
69377: NEG
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: LIST
69387: LIST
69388: LIST
69389: LIST
69390: LIST
69391: LIST
69392: LIST
69393: LIST
69394: LIST
69395: LIST
69396: LIST
69397: LIST
69398: LIST
69399: LIST
69400: LIST
69401: LIST
69402: LIST
69403: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69404: LD_ADDR_VAR 0 54
69408: PUSH
69409: LD_INT 0
69411: PUSH
69412: LD_INT 0
69414: PUSH
69415: EMPTY
69416: LIST
69417: LIST
69418: PUSH
69419: LD_INT 0
69421: PUSH
69422: LD_INT 1
69424: NEG
69425: PUSH
69426: EMPTY
69427: LIST
69428: LIST
69429: PUSH
69430: LD_INT 1
69432: PUSH
69433: LD_INT 0
69435: PUSH
69436: EMPTY
69437: LIST
69438: LIST
69439: PUSH
69440: LD_INT 1
69442: PUSH
69443: LD_INT 1
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PUSH
69450: LD_INT 0
69452: PUSH
69453: LD_INT 1
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: PUSH
69460: LD_INT 1
69462: NEG
69463: PUSH
69464: LD_INT 0
69466: PUSH
69467: EMPTY
69468: LIST
69469: LIST
69470: PUSH
69471: LD_INT 1
69473: NEG
69474: PUSH
69475: LD_INT 1
69477: NEG
69478: PUSH
69479: EMPTY
69480: LIST
69481: LIST
69482: PUSH
69483: LD_INT 1
69485: NEG
69486: PUSH
69487: LD_INT 2
69489: NEG
69490: PUSH
69491: EMPTY
69492: LIST
69493: LIST
69494: PUSH
69495: LD_INT 0
69497: PUSH
69498: LD_INT 2
69500: NEG
69501: PUSH
69502: EMPTY
69503: LIST
69504: LIST
69505: PUSH
69506: LD_INT 1
69508: PUSH
69509: LD_INT 1
69511: NEG
69512: PUSH
69513: EMPTY
69514: LIST
69515: LIST
69516: PUSH
69517: LD_INT 2
69519: PUSH
69520: LD_INT 0
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: PUSH
69527: LD_INT 2
69529: PUSH
69530: LD_INT 1
69532: PUSH
69533: EMPTY
69534: LIST
69535: LIST
69536: PUSH
69537: LD_INT 2
69539: PUSH
69540: LD_INT 2
69542: PUSH
69543: EMPTY
69544: LIST
69545: LIST
69546: PUSH
69547: LD_INT 1
69549: PUSH
69550: LD_INT 2
69552: PUSH
69553: EMPTY
69554: LIST
69555: LIST
69556: PUSH
69557: LD_INT 0
69559: PUSH
69560: LD_INT 2
69562: PUSH
69563: EMPTY
69564: LIST
69565: LIST
69566: PUSH
69567: LD_INT 1
69569: NEG
69570: PUSH
69571: LD_INT 1
69573: PUSH
69574: EMPTY
69575: LIST
69576: LIST
69577: PUSH
69578: LD_INT 2
69580: NEG
69581: PUSH
69582: LD_INT 0
69584: PUSH
69585: EMPTY
69586: LIST
69587: LIST
69588: PUSH
69589: LD_INT 2
69591: NEG
69592: PUSH
69593: LD_INT 1
69595: NEG
69596: PUSH
69597: EMPTY
69598: LIST
69599: LIST
69600: PUSH
69601: LD_INT 2
69603: NEG
69604: PUSH
69605: LD_INT 2
69607: NEG
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: PUSH
69613: EMPTY
69614: LIST
69615: LIST
69616: LIST
69617: LIST
69618: LIST
69619: LIST
69620: LIST
69621: LIST
69622: LIST
69623: LIST
69624: LIST
69625: LIST
69626: LIST
69627: LIST
69628: LIST
69629: LIST
69630: LIST
69631: LIST
69632: LIST
69633: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69634: LD_ADDR_VAR 0 55
69638: PUSH
69639: LD_INT 0
69641: PUSH
69642: LD_INT 0
69644: PUSH
69645: EMPTY
69646: LIST
69647: LIST
69648: PUSH
69649: LD_INT 0
69651: PUSH
69652: LD_INT 1
69654: NEG
69655: PUSH
69656: EMPTY
69657: LIST
69658: LIST
69659: PUSH
69660: LD_INT 1
69662: PUSH
69663: LD_INT 0
69665: PUSH
69666: EMPTY
69667: LIST
69668: LIST
69669: PUSH
69670: LD_INT 1
69672: PUSH
69673: LD_INT 1
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PUSH
69680: LD_INT 0
69682: PUSH
69683: LD_INT 1
69685: PUSH
69686: EMPTY
69687: LIST
69688: LIST
69689: PUSH
69690: LD_INT 1
69692: NEG
69693: PUSH
69694: LD_INT 0
69696: PUSH
69697: EMPTY
69698: LIST
69699: LIST
69700: PUSH
69701: LD_INT 1
69703: NEG
69704: PUSH
69705: LD_INT 1
69707: NEG
69708: PUSH
69709: EMPTY
69710: LIST
69711: LIST
69712: PUSH
69713: LD_INT 1
69715: NEG
69716: PUSH
69717: LD_INT 2
69719: NEG
69720: PUSH
69721: EMPTY
69722: LIST
69723: LIST
69724: PUSH
69725: LD_INT 0
69727: PUSH
69728: LD_INT 2
69730: NEG
69731: PUSH
69732: EMPTY
69733: LIST
69734: LIST
69735: PUSH
69736: LD_INT 1
69738: PUSH
69739: LD_INT 1
69741: NEG
69742: PUSH
69743: EMPTY
69744: LIST
69745: LIST
69746: PUSH
69747: LD_INT 2
69749: PUSH
69750: LD_INT 0
69752: PUSH
69753: EMPTY
69754: LIST
69755: LIST
69756: PUSH
69757: LD_INT 2
69759: PUSH
69760: LD_INT 1
69762: PUSH
69763: EMPTY
69764: LIST
69765: LIST
69766: PUSH
69767: LD_INT 2
69769: PUSH
69770: LD_INT 2
69772: PUSH
69773: EMPTY
69774: LIST
69775: LIST
69776: PUSH
69777: LD_INT 1
69779: PUSH
69780: LD_INT 2
69782: PUSH
69783: EMPTY
69784: LIST
69785: LIST
69786: PUSH
69787: LD_INT 0
69789: PUSH
69790: LD_INT 2
69792: PUSH
69793: EMPTY
69794: LIST
69795: LIST
69796: PUSH
69797: LD_INT 1
69799: NEG
69800: PUSH
69801: LD_INT 1
69803: PUSH
69804: EMPTY
69805: LIST
69806: LIST
69807: PUSH
69808: LD_INT 2
69810: NEG
69811: PUSH
69812: LD_INT 0
69814: PUSH
69815: EMPTY
69816: LIST
69817: LIST
69818: PUSH
69819: LD_INT 2
69821: NEG
69822: PUSH
69823: LD_INT 1
69825: NEG
69826: PUSH
69827: EMPTY
69828: LIST
69829: LIST
69830: PUSH
69831: LD_INT 2
69833: NEG
69834: PUSH
69835: LD_INT 2
69837: NEG
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: PUSH
69843: EMPTY
69844: LIST
69845: LIST
69846: LIST
69847: LIST
69848: LIST
69849: LIST
69850: LIST
69851: LIST
69852: LIST
69853: LIST
69854: LIST
69855: LIST
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69864: LD_ADDR_VAR 0 56
69868: PUSH
69869: LD_INT 0
69871: PUSH
69872: LD_INT 0
69874: PUSH
69875: EMPTY
69876: LIST
69877: LIST
69878: PUSH
69879: LD_INT 0
69881: PUSH
69882: LD_INT 1
69884: NEG
69885: PUSH
69886: EMPTY
69887: LIST
69888: LIST
69889: PUSH
69890: LD_INT 1
69892: PUSH
69893: LD_INT 0
69895: PUSH
69896: EMPTY
69897: LIST
69898: LIST
69899: PUSH
69900: LD_INT 1
69902: PUSH
69903: LD_INT 1
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: PUSH
69910: LD_INT 0
69912: PUSH
69913: LD_INT 1
69915: PUSH
69916: EMPTY
69917: LIST
69918: LIST
69919: PUSH
69920: LD_INT 1
69922: NEG
69923: PUSH
69924: LD_INT 0
69926: PUSH
69927: EMPTY
69928: LIST
69929: LIST
69930: PUSH
69931: LD_INT 1
69933: NEG
69934: PUSH
69935: LD_INT 1
69937: NEG
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: PUSH
69943: LD_INT 1
69945: NEG
69946: PUSH
69947: LD_INT 2
69949: NEG
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: PUSH
69955: LD_INT 0
69957: PUSH
69958: LD_INT 2
69960: NEG
69961: PUSH
69962: EMPTY
69963: LIST
69964: LIST
69965: PUSH
69966: LD_INT 1
69968: PUSH
69969: LD_INT 1
69971: NEG
69972: PUSH
69973: EMPTY
69974: LIST
69975: LIST
69976: PUSH
69977: LD_INT 2
69979: PUSH
69980: LD_INT 0
69982: PUSH
69983: EMPTY
69984: LIST
69985: LIST
69986: PUSH
69987: LD_INT 2
69989: PUSH
69990: LD_INT 1
69992: PUSH
69993: EMPTY
69994: LIST
69995: LIST
69996: PUSH
69997: LD_INT 2
69999: PUSH
70000: LD_INT 2
70002: PUSH
70003: EMPTY
70004: LIST
70005: LIST
70006: PUSH
70007: LD_INT 1
70009: PUSH
70010: LD_INT 2
70012: PUSH
70013: EMPTY
70014: LIST
70015: LIST
70016: PUSH
70017: LD_INT 0
70019: PUSH
70020: LD_INT 2
70022: PUSH
70023: EMPTY
70024: LIST
70025: LIST
70026: PUSH
70027: LD_INT 1
70029: NEG
70030: PUSH
70031: LD_INT 1
70033: PUSH
70034: EMPTY
70035: LIST
70036: LIST
70037: PUSH
70038: LD_INT 2
70040: NEG
70041: PUSH
70042: LD_INT 0
70044: PUSH
70045: EMPTY
70046: LIST
70047: LIST
70048: PUSH
70049: LD_INT 2
70051: NEG
70052: PUSH
70053: LD_INT 1
70055: NEG
70056: PUSH
70057: EMPTY
70058: LIST
70059: LIST
70060: PUSH
70061: LD_INT 2
70063: NEG
70064: PUSH
70065: LD_INT 2
70067: NEG
70068: PUSH
70069: EMPTY
70070: LIST
70071: LIST
70072: PUSH
70073: EMPTY
70074: LIST
70075: LIST
70076: LIST
70077: LIST
70078: LIST
70079: LIST
70080: LIST
70081: LIST
70082: LIST
70083: LIST
70084: LIST
70085: LIST
70086: LIST
70087: LIST
70088: LIST
70089: LIST
70090: LIST
70091: LIST
70092: LIST
70093: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70094: LD_ADDR_VAR 0 57
70098: PUSH
70099: LD_INT 0
70101: PUSH
70102: LD_INT 0
70104: PUSH
70105: EMPTY
70106: LIST
70107: LIST
70108: PUSH
70109: LD_INT 0
70111: PUSH
70112: LD_INT 1
70114: NEG
70115: PUSH
70116: EMPTY
70117: LIST
70118: LIST
70119: PUSH
70120: LD_INT 1
70122: PUSH
70123: LD_INT 0
70125: PUSH
70126: EMPTY
70127: LIST
70128: LIST
70129: PUSH
70130: LD_INT 1
70132: PUSH
70133: LD_INT 1
70135: PUSH
70136: EMPTY
70137: LIST
70138: LIST
70139: PUSH
70140: LD_INT 0
70142: PUSH
70143: LD_INT 1
70145: PUSH
70146: EMPTY
70147: LIST
70148: LIST
70149: PUSH
70150: LD_INT 1
70152: NEG
70153: PUSH
70154: LD_INT 0
70156: PUSH
70157: EMPTY
70158: LIST
70159: LIST
70160: PUSH
70161: LD_INT 1
70163: NEG
70164: PUSH
70165: LD_INT 1
70167: NEG
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: PUSH
70173: LD_INT 1
70175: NEG
70176: PUSH
70177: LD_INT 2
70179: NEG
70180: PUSH
70181: EMPTY
70182: LIST
70183: LIST
70184: PUSH
70185: LD_INT 0
70187: PUSH
70188: LD_INT 2
70190: NEG
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: LD_INT 1
70198: PUSH
70199: LD_INT 1
70201: NEG
70202: PUSH
70203: EMPTY
70204: LIST
70205: LIST
70206: PUSH
70207: LD_INT 2
70209: PUSH
70210: LD_INT 0
70212: PUSH
70213: EMPTY
70214: LIST
70215: LIST
70216: PUSH
70217: LD_INT 2
70219: PUSH
70220: LD_INT 1
70222: PUSH
70223: EMPTY
70224: LIST
70225: LIST
70226: PUSH
70227: LD_INT 2
70229: PUSH
70230: LD_INT 2
70232: PUSH
70233: EMPTY
70234: LIST
70235: LIST
70236: PUSH
70237: LD_INT 1
70239: PUSH
70240: LD_INT 2
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: PUSH
70247: LD_INT 0
70249: PUSH
70250: LD_INT 2
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: PUSH
70257: LD_INT 1
70259: NEG
70260: PUSH
70261: LD_INT 1
70263: PUSH
70264: EMPTY
70265: LIST
70266: LIST
70267: PUSH
70268: LD_INT 2
70270: NEG
70271: PUSH
70272: LD_INT 0
70274: PUSH
70275: EMPTY
70276: LIST
70277: LIST
70278: PUSH
70279: LD_INT 2
70281: NEG
70282: PUSH
70283: LD_INT 1
70285: NEG
70286: PUSH
70287: EMPTY
70288: LIST
70289: LIST
70290: PUSH
70291: LD_INT 2
70293: NEG
70294: PUSH
70295: LD_INT 2
70297: NEG
70298: PUSH
70299: EMPTY
70300: LIST
70301: LIST
70302: PUSH
70303: EMPTY
70304: LIST
70305: LIST
70306: LIST
70307: LIST
70308: LIST
70309: LIST
70310: LIST
70311: LIST
70312: LIST
70313: LIST
70314: LIST
70315: LIST
70316: LIST
70317: LIST
70318: LIST
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70324: LD_ADDR_VAR 0 58
70328: PUSH
70329: LD_INT 0
70331: PUSH
70332: LD_INT 0
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: PUSH
70339: LD_INT 0
70341: PUSH
70342: LD_INT 1
70344: NEG
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: PUSH
70350: LD_INT 1
70352: PUSH
70353: LD_INT 0
70355: PUSH
70356: EMPTY
70357: LIST
70358: LIST
70359: PUSH
70360: LD_INT 1
70362: PUSH
70363: LD_INT 1
70365: PUSH
70366: EMPTY
70367: LIST
70368: LIST
70369: PUSH
70370: LD_INT 0
70372: PUSH
70373: LD_INT 1
70375: PUSH
70376: EMPTY
70377: LIST
70378: LIST
70379: PUSH
70380: LD_INT 1
70382: NEG
70383: PUSH
70384: LD_INT 0
70386: PUSH
70387: EMPTY
70388: LIST
70389: LIST
70390: PUSH
70391: LD_INT 1
70393: NEG
70394: PUSH
70395: LD_INT 1
70397: NEG
70398: PUSH
70399: EMPTY
70400: LIST
70401: LIST
70402: PUSH
70403: LD_INT 1
70405: NEG
70406: PUSH
70407: LD_INT 2
70409: NEG
70410: PUSH
70411: EMPTY
70412: LIST
70413: LIST
70414: PUSH
70415: LD_INT 0
70417: PUSH
70418: LD_INT 2
70420: NEG
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: PUSH
70426: LD_INT 1
70428: PUSH
70429: LD_INT 1
70431: NEG
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: LD_INT 2
70439: PUSH
70440: LD_INT 0
70442: PUSH
70443: EMPTY
70444: LIST
70445: LIST
70446: PUSH
70447: LD_INT 2
70449: PUSH
70450: LD_INT 1
70452: PUSH
70453: EMPTY
70454: LIST
70455: LIST
70456: PUSH
70457: LD_INT 2
70459: PUSH
70460: LD_INT 2
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: PUSH
70467: LD_INT 1
70469: PUSH
70470: LD_INT 2
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: PUSH
70477: LD_INT 0
70479: PUSH
70480: LD_INT 2
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: PUSH
70487: LD_INT 1
70489: NEG
70490: PUSH
70491: LD_INT 1
70493: PUSH
70494: EMPTY
70495: LIST
70496: LIST
70497: PUSH
70498: LD_INT 2
70500: NEG
70501: PUSH
70502: LD_INT 0
70504: PUSH
70505: EMPTY
70506: LIST
70507: LIST
70508: PUSH
70509: LD_INT 2
70511: NEG
70512: PUSH
70513: LD_INT 1
70515: NEG
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: PUSH
70521: LD_INT 2
70523: NEG
70524: PUSH
70525: LD_INT 2
70527: NEG
70528: PUSH
70529: EMPTY
70530: LIST
70531: LIST
70532: PUSH
70533: EMPTY
70534: LIST
70535: LIST
70536: LIST
70537: LIST
70538: LIST
70539: LIST
70540: LIST
70541: LIST
70542: LIST
70543: LIST
70544: LIST
70545: LIST
70546: LIST
70547: LIST
70548: LIST
70549: LIST
70550: LIST
70551: LIST
70552: LIST
70553: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
70554: LD_ADDR_VAR 0 59
70558: PUSH
70559: LD_INT 0
70561: PUSH
70562: LD_INT 0
70564: PUSH
70565: EMPTY
70566: LIST
70567: LIST
70568: PUSH
70569: LD_INT 0
70571: PUSH
70572: LD_INT 1
70574: NEG
70575: PUSH
70576: EMPTY
70577: LIST
70578: LIST
70579: PUSH
70580: LD_INT 1
70582: PUSH
70583: LD_INT 0
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 1
70592: PUSH
70593: LD_INT 1
70595: PUSH
70596: EMPTY
70597: LIST
70598: LIST
70599: PUSH
70600: LD_INT 0
70602: PUSH
70603: LD_INT 1
70605: PUSH
70606: EMPTY
70607: LIST
70608: LIST
70609: PUSH
70610: LD_INT 1
70612: NEG
70613: PUSH
70614: LD_INT 0
70616: PUSH
70617: EMPTY
70618: LIST
70619: LIST
70620: PUSH
70621: LD_INT 1
70623: NEG
70624: PUSH
70625: LD_INT 1
70627: NEG
70628: PUSH
70629: EMPTY
70630: LIST
70631: LIST
70632: PUSH
70633: EMPTY
70634: LIST
70635: LIST
70636: LIST
70637: LIST
70638: LIST
70639: LIST
70640: LIST
70641: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
70642: LD_ADDR_VAR 0 60
70646: PUSH
70647: LD_INT 0
70649: PUSH
70650: LD_INT 0
70652: PUSH
70653: EMPTY
70654: LIST
70655: LIST
70656: PUSH
70657: LD_INT 0
70659: PUSH
70660: LD_INT 1
70662: NEG
70663: PUSH
70664: EMPTY
70665: LIST
70666: LIST
70667: PUSH
70668: LD_INT 1
70670: PUSH
70671: LD_INT 0
70673: PUSH
70674: EMPTY
70675: LIST
70676: LIST
70677: PUSH
70678: LD_INT 1
70680: PUSH
70681: LD_INT 1
70683: PUSH
70684: EMPTY
70685: LIST
70686: LIST
70687: PUSH
70688: LD_INT 0
70690: PUSH
70691: LD_INT 1
70693: PUSH
70694: EMPTY
70695: LIST
70696: LIST
70697: PUSH
70698: LD_INT 1
70700: NEG
70701: PUSH
70702: LD_INT 0
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 1
70711: NEG
70712: PUSH
70713: LD_INT 1
70715: NEG
70716: PUSH
70717: EMPTY
70718: LIST
70719: LIST
70720: PUSH
70721: EMPTY
70722: LIST
70723: LIST
70724: LIST
70725: LIST
70726: LIST
70727: LIST
70728: LIST
70729: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
70730: LD_ADDR_VAR 0 61
70734: PUSH
70735: LD_INT 0
70737: PUSH
70738: LD_INT 0
70740: PUSH
70741: EMPTY
70742: LIST
70743: LIST
70744: PUSH
70745: LD_INT 0
70747: PUSH
70748: LD_INT 1
70750: NEG
70751: PUSH
70752: EMPTY
70753: LIST
70754: LIST
70755: PUSH
70756: LD_INT 1
70758: PUSH
70759: LD_INT 0
70761: PUSH
70762: EMPTY
70763: LIST
70764: LIST
70765: PUSH
70766: LD_INT 1
70768: PUSH
70769: LD_INT 1
70771: PUSH
70772: EMPTY
70773: LIST
70774: LIST
70775: PUSH
70776: LD_INT 0
70778: PUSH
70779: LD_INT 1
70781: PUSH
70782: EMPTY
70783: LIST
70784: LIST
70785: PUSH
70786: LD_INT 1
70788: NEG
70789: PUSH
70790: LD_INT 0
70792: PUSH
70793: EMPTY
70794: LIST
70795: LIST
70796: PUSH
70797: LD_INT 1
70799: NEG
70800: PUSH
70801: LD_INT 1
70803: NEG
70804: PUSH
70805: EMPTY
70806: LIST
70807: LIST
70808: PUSH
70809: EMPTY
70810: LIST
70811: LIST
70812: LIST
70813: LIST
70814: LIST
70815: LIST
70816: LIST
70817: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
70818: LD_ADDR_VAR 0 62
70822: PUSH
70823: LD_INT 0
70825: PUSH
70826: LD_INT 0
70828: PUSH
70829: EMPTY
70830: LIST
70831: LIST
70832: PUSH
70833: LD_INT 0
70835: PUSH
70836: LD_INT 1
70838: NEG
70839: PUSH
70840: EMPTY
70841: LIST
70842: LIST
70843: PUSH
70844: LD_INT 1
70846: PUSH
70847: LD_INT 0
70849: PUSH
70850: EMPTY
70851: LIST
70852: LIST
70853: PUSH
70854: LD_INT 1
70856: PUSH
70857: LD_INT 1
70859: PUSH
70860: EMPTY
70861: LIST
70862: LIST
70863: PUSH
70864: LD_INT 0
70866: PUSH
70867: LD_INT 1
70869: PUSH
70870: EMPTY
70871: LIST
70872: LIST
70873: PUSH
70874: LD_INT 1
70876: NEG
70877: PUSH
70878: LD_INT 0
70880: PUSH
70881: EMPTY
70882: LIST
70883: LIST
70884: PUSH
70885: LD_INT 1
70887: NEG
70888: PUSH
70889: LD_INT 1
70891: NEG
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: EMPTY
70898: LIST
70899: LIST
70900: LIST
70901: LIST
70902: LIST
70903: LIST
70904: LIST
70905: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
70906: LD_ADDR_VAR 0 63
70910: PUSH
70911: LD_INT 0
70913: PUSH
70914: LD_INT 0
70916: PUSH
70917: EMPTY
70918: LIST
70919: LIST
70920: PUSH
70921: LD_INT 0
70923: PUSH
70924: LD_INT 1
70926: NEG
70927: PUSH
70928: EMPTY
70929: LIST
70930: LIST
70931: PUSH
70932: LD_INT 1
70934: PUSH
70935: LD_INT 0
70937: PUSH
70938: EMPTY
70939: LIST
70940: LIST
70941: PUSH
70942: LD_INT 1
70944: PUSH
70945: LD_INT 1
70947: PUSH
70948: EMPTY
70949: LIST
70950: LIST
70951: PUSH
70952: LD_INT 0
70954: PUSH
70955: LD_INT 1
70957: PUSH
70958: EMPTY
70959: LIST
70960: LIST
70961: PUSH
70962: LD_INT 1
70964: NEG
70965: PUSH
70966: LD_INT 0
70968: PUSH
70969: EMPTY
70970: LIST
70971: LIST
70972: PUSH
70973: LD_INT 1
70975: NEG
70976: PUSH
70977: LD_INT 1
70979: NEG
70980: PUSH
70981: EMPTY
70982: LIST
70983: LIST
70984: PUSH
70985: EMPTY
70986: LIST
70987: LIST
70988: LIST
70989: LIST
70990: LIST
70991: LIST
70992: LIST
70993: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
70994: LD_ADDR_VAR 0 64
70998: PUSH
70999: LD_INT 0
71001: PUSH
71002: LD_INT 0
71004: PUSH
71005: EMPTY
71006: LIST
71007: LIST
71008: PUSH
71009: LD_INT 0
71011: PUSH
71012: LD_INT 1
71014: NEG
71015: PUSH
71016: EMPTY
71017: LIST
71018: LIST
71019: PUSH
71020: LD_INT 1
71022: PUSH
71023: LD_INT 0
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PUSH
71030: LD_INT 1
71032: PUSH
71033: LD_INT 1
71035: PUSH
71036: EMPTY
71037: LIST
71038: LIST
71039: PUSH
71040: LD_INT 0
71042: PUSH
71043: LD_INT 1
71045: PUSH
71046: EMPTY
71047: LIST
71048: LIST
71049: PUSH
71050: LD_INT 1
71052: NEG
71053: PUSH
71054: LD_INT 0
71056: PUSH
71057: EMPTY
71058: LIST
71059: LIST
71060: PUSH
71061: LD_INT 1
71063: NEG
71064: PUSH
71065: LD_INT 1
71067: NEG
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: LIST
71077: LIST
71078: LIST
71079: LIST
71080: LIST
71081: ST_TO_ADDR
// end ; 1 :
71082: GO 76979
71084: LD_INT 1
71086: DOUBLE
71087: EQUAL
71088: IFTRUE 71092
71090: GO 73715
71092: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
71093: LD_ADDR_VAR 0 11
71097: PUSH
71098: LD_INT 1
71100: NEG
71101: PUSH
71102: LD_INT 3
71104: NEG
71105: PUSH
71106: EMPTY
71107: LIST
71108: LIST
71109: PUSH
71110: LD_INT 0
71112: PUSH
71113: LD_INT 3
71115: NEG
71116: PUSH
71117: EMPTY
71118: LIST
71119: LIST
71120: PUSH
71121: LD_INT 1
71123: PUSH
71124: LD_INT 2
71126: NEG
71127: PUSH
71128: EMPTY
71129: LIST
71130: LIST
71131: PUSH
71132: EMPTY
71133: LIST
71134: LIST
71135: LIST
71136: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
71137: LD_ADDR_VAR 0 12
71141: PUSH
71142: LD_INT 2
71144: PUSH
71145: LD_INT 1
71147: NEG
71148: PUSH
71149: EMPTY
71150: LIST
71151: LIST
71152: PUSH
71153: LD_INT 3
71155: PUSH
71156: LD_INT 0
71158: PUSH
71159: EMPTY
71160: LIST
71161: LIST
71162: PUSH
71163: LD_INT 3
71165: PUSH
71166: LD_INT 1
71168: PUSH
71169: EMPTY
71170: LIST
71171: LIST
71172: PUSH
71173: EMPTY
71174: LIST
71175: LIST
71176: LIST
71177: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
71178: LD_ADDR_VAR 0 13
71182: PUSH
71183: LD_INT 3
71185: PUSH
71186: LD_INT 2
71188: PUSH
71189: EMPTY
71190: LIST
71191: LIST
71192: PUSH
71193: LD_INT 3
71195: PUSH
71196: LD_INT 3
71198: PUSH
71199: EMPTY
71200: LIST
71201: LIST
71202: PUSH
71203: LD_INT 2
71205: PUSH
71206: LD_INT 3
71208: PUSH
71209: EMPTY
71210: LIST
71211: LIST
71212: PUSH
71213: EMPTY
71214: LIST
71215: LIST
71216: LIST
71217: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
71218: LD_ADDR_VAR 0 14
71222: PUSH
71223: LD_INT 1
71225: PUSH
71226: LD_INT 3
71228: PUSH
71229: EMPTY
71230: LIST
71231: LIST
71232: PUSH
71233: LD_INT 0
71235: PUSH
71236: LD_INT 3
71238: PUSH
71239: EMPTY
71240: LIST
71241: LIST
71242: PUSH
71243: LD_INT 1
71245: NEG
71246: PUSH
71247: LD_INT 2
71249: PUSH
71250: EMPTY
71251: LIST
71252: LIST
71253: PUSH
71254: EMPTY
71255: LIST
71256: LIST
71257: LIST
71258: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71259: LD_ADDR_VAR 0 15
71263: PUSH
71264: LD_INT 2
71266: NEG
71267: PUSH
71268: LD_INT 1
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: PUSH
71275: LD_INT 3
71277: NEG
71278: PUSH
71279: LD_INT 0
71281: PUSH
71282: EMPTY
71283: LIST
71284: LIST
71285: PUSH
71286: LD_INT 3
71288: NEG
71289: PUSH
71290: LD_INT 1
71292: NEG
71293: PUSH
71294: EMPTY
71295: LIST
71296: LIST
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: LIST
71302: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71303: LD_ADDR_VAR 0 16
71307: PUSH
71308: LD_INT 2
71310: NEG
71311: PUSH
71312: LD_INT 3
71314: NEG
71315: PUSH
71316: EMPTY
71317: LIST
71318: LIST
71319: PUSH
71320: LD_INT 3
71322: NEG
71323: PUSH
71324: LD_INT 2
71326: NEG
71327: PUSH
71328: EMPTY
71329: LIST
71330: LIST
71331: PUSH
71332: LD_INT 3
71334: NEG
71335: PUSH
71336: LD_INT 3
71338: NEG
71339: PUSH
71340: EMPTY
71341: LIST
71342: LIST
71343: PUSH
71344: EMPTY
71345: LIST
71346: LIST
71347: LIST
71348: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
71349: LD_ADDR_VAR 0 17
71353: PUSH
71354: LD_INT 1
71356: NEG
71357: PUSH
71358: LD_INT 3
71360: NEG
71361: PUSH
71362: EMPTY
71363: LIST
71364: LIST
71365: PUSH
71366: LD_INT 0
71368: PUSH
71369: LD_INT 3
71371: NEG
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: PUSH
71377: LD_INT 1
71379: PUSH
71380: LD_INT 2
71382: NEG
71383: PUSH
71384: EMPTY
71385: LIST
71386: LIST
71387: PUSH
71388: EMPTY
71389: LIST
71390: LIST
71391: LIST
71392: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
71393: LD_ADDR_VAR 0 18
71397: PUSH
71398: LD_INT 2
71400: PUSH
71401: LD_INT 1
71403: NEG
71404: PUSH
71405: EMPTY
71406: LIST
71407: LIST
71408: PUSH
71409: LD_INT 3
71411: PUSH
71412: LD_INT 0
71414: PUSH
71415: EMPTY
71416: LIST
71417: LIST
71418: PUSH
71419: LD_INT 3
71421: PUSH
71422: LD_INT 1
71424: PUSH
71425: EMPTY
71426: LIST
71427: LIST
71428: PUSH
71429: EMPTY
71430: LIST
71431: LIST
71432: LIST
71433: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
71434: LD_ADDR_VAR 0 19
71438: PUSH
71439: LD_INT 3
71441: PUSH
71442: LD_INT 2
71444: PUSH
71445: EMPTY
71446: LIST
71447: LIST
71448: PUSH
71449: LD_INT 3
71451: PUSH
71452: LD_INT 3
71454: PUSH
71455: EMPTY
71456: LIST
71457: LIST
71458: PUSH
71459: LD_INT 2
71461: PUSH
71462: LD_INT 3
71464: PUSH
71465: EMPTY
71466: LIST
71467: LIST
71468: PUSH
71469: EMPTY
71470: LIST
71471: LIST
71472: LIST
71473: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
71474: LD_ADDR_VAR 0 20
71478: PUSH
71479: LD_INT 1
71481: PUSH
71482: LD_INT 3
71484: PUSH
71485: EMPTY
71486: LIST
71487: LIST
71488: PUSH
71489: LD_INT 0
71491: PUSH
71492: LD_INT 3
71494: PUSH
71495: EMPTY
71496: LIST
71497: LIST
71498: PUSH
71499: LD_INT 1
71501: NEG
71502: PUSH
71503: LD_INT 2
71505: PUSH
71506: EMPTY
71507: LIST
71508: LIST
71509: PUSH
71510: EMPTY
71511: LIST
71512: LIST
71513: LIST
71514: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71515: LD_ADDR_VAR 0 21
71519: PUSH
71520: LD_INT 2
71522: NEG
71523: PUSH
71524: LD_INT 1
71526: PUSH
71527: EMPTY
71528: LIST
71529: LIST
71530: PUSH
71531: LD_INT 3
71533: NEG
71534: PUSH
71535: LD_INT 0
71537: PUSH
71538: EMPTY
71539: LIST
71540: LIST
71541: PUSH
71542: LD_INT 3
71544: NEG
71545: PUSH
71546: LD_INT 1
71548: NEG
71549: PUSH
71550: EMPTY
71551: LIST
71552: LIST
71553: PUSH
71554: EMPTY
71555: LIST
71556: LIST
71557: LIST
71558: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71559: LD_ADDR_VAR 0 22
71563: PUSH
71564: LD_INT 2
71566: NEG
71567: PUSH
71568: LD_INT 3
71570: NEG
71571: PUSH
71572: EMPTY
71573: LIST
71574: LIST
71575: PUSH
71576: LD_INT 3
71578: NEG
71579: PUSH
71580: LD_INT 2
71582: NEG
71583: PUSH
71584: EMPTY
71585: LIST
71586: LIST
71587: PUSH
71588: LD_INT 3
71590: NEG
71591: PUSH
71592: LD_INT 3
71594: NEG
71595: PUSH
71596: EMPTY
71597: LIST
71598: LIST
71599: PUSH
71600: EMPTY
71601: LIST
71602: LIST
71603: LIST
71604: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
71605: LD_ADDR_VAR 0 23
71609: PUSH
71610: LD_INT 0
71612: PUSH
71613: LD_INT 3
71615: NEG
71616: PUSH
71617: EMPTY
71618: LIST
71619: LIST
71620: PUSH
71621: LD_INT 1
71623: NEG
71624: PUSH
71625: LD_INT 4
71627: NEG
71628: PUSH
71629: EMPTY
71630: LIST
71631: LIST
71632: PUSH
71633: LD_INT 1
71635: PUSH
71636: LD_INT 3
71638: NEG
71639: PUSH
71640: EMPTY
71641: LIST
71642: LIST
71643: PUSH
71644: EMPTY
71645: LIST
71646: LIST
71647: LIST
71648: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
71649: LD_ADDR_VAR 0 24
71653: PUSH
71654: LD_INT 3
71656: PUSH
71657: LD_INT 0
71659: PUSH
71660: EMPTY
71661: LIST
71662: LIST
71663: PUSH
71664: LD_INT 3
71666: PUSH
71667: LD_INT 1
71669: NEG
71670: PUSH
71671: EMPTY
71672: LIST
71673: LIST
71674: PUSH
71675: LD_INT 4
71677: PUSH
71678: LD_INT 1
71680: PUSH
71681: EMPTY
71682: LIST
71683: LIST
71684: PUSH
71685: EMPTY
71686: LIST
71687: LIST
71688: LIST
71689: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
71690: LD_ADDR_VAR 0 25
71694: PUSH
71695: LD_INT 3
71697: PUSH
71698: LD_INT 3
71700: PUSH
71701: EMPTY
71702: LIST
71703: LIST
71704: PUSH
71705: LD_INT 4
71707: PUSH
71708: LD_INT 3
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: PUSH
71715: LD_INT 3
71717: PUSH
71718: LD_INT 4
71720: PUSH
71721: EMPTY
71722: LIST
71723: LIST
71724: PUSH
71725: EMPTY
71726: LIST
71727: LIST
71728: LIST
71729: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
71730: LD_ADDR_VAR 0 26
71734: PUSH
71735: LD_INT 0
71737: PUSH
71738: LD_INT 3
71740: PUSH
71741: EMPTY
71742: LIST
71743: LIST
71744: PUSH
71745: LD_INT 1
71747: PUSH
71748: LD_INT 4
71750: PUSH
71751: EMPTY
71752: LIST
71753: LIST
71754: PUSH
71755: LD_INT 1
71757: NEG
71758: PUSH
71759: LD_INT 3
71761: PUSH
71762: EMPTY
71763: LIST
71764: LIST
71765: PUSH
71766: EMPTY
71767: LIST
71768: LIST
71769: LIST
71770: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
71771: LD_ADDR_VAR 0 27
71775: PUSH
71776: LD_INT 3
71778: NEG
71779: PUSH
71780: LD_INT 0
71782: PUSH
71783: EMPTY
71784: LIST
71785: LIST
71786: PUSH
71787: LD_INT 3
71789: NEG
71790: PUSH
71791: LD_INT 1
71793: PUSH
71794: EMPTY
71795: LIST
71796: LIST
71797: PUSH
71798: LD_INT 4
71800: NEG
71801: PUSH
71802: LD_INT 1
71804: NEG
71805: PUSH
71806: EMPTY
71807: LIST
71808: LIST
71809: PUSH
71810: EMPTY
71811: LIST
71812: LIST
71813: LIST
71814: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
71815: LD_ADDR_VAR 0 28
71819: PUSH
71820: LD_INT 3
71822: NEG
71823: PUSH
71824: LD_INT 3
71826: NEG
71827: PUSH
71828: EMPTY
71829: LIST
71830: LIST
71831: PUSH
71832: LD_INT 3
71834: NEG
71835: PUSH
71836: LD_INT 4
71838: NEG
71839: PUSH
71840: EMPTY
71841: LIST
71842: LIST
71843: PUSH
71844: LD_INT 4
71846: NEG
71847: PUSH
71848: LD_INT 3
71850: NEG
71851: PUSH
71852: EMPTY
71853: LIST
71854: LIST
71855: PUSH
71856: EMPTY
71857: LIST
71858: LIST
71859: LIST
71860: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
71861: LD_ADDR_VAR 0 29
71865: PUSH
71866: LD_INT 1
71868: NEG
71869: PUSH
71870: LD_INT 3
71872: NEG
71873: PUSH
71874: EMPTY
71875: LIST
71876: LIST
71877: PUSH
71878: LD_INT 0
71880: PUSH
71881: LD_INT 3
71883: NEG
71884: PUSH
71885: EMPTY
71886: LIST
71887: LIST
71888: PUSH
71889: LD_INT 1
71891: PUSH
71892: LD_INT 2
71894: NEG
71895: PUSH
71896: EMPTY
71897: LIST
71898: LIST
71899: PUSH
71900: LD_INT 1
71902: NEG
71903: PUSH
71904: LD_INT 4
71906: NEG
71907: PUSH
71908: EMPTY
71909: LIST
71910: LIST
71911: PUSH
71912: LD_INT 0
71914: PUSH
71915: LD_INT 4
71917: NEG
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PUSH
71923: LD_INT 1
71925: PUSH
71926: LD_INT 3
71928: NEG
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: PUSH
71934: LD_INT 1
71936: NEG
71937: PUSH
71938: LD_INT 5
71940: NEG
71941: PUSH
71942: EMPTY
71943: LIST
71944: LIST
71945: PUSH
71946: LD_INT 0
71948: PUSH
71949: LD_INT 5
71951: NEG
71952: PUSH
71953: EMPTY
71954: LIST
71955: LIST
71956: PUSH
71957: LD_INT 1
71959: PUSH
71960: LD_INT 4
71962: NEG
71963: PUSH
71964: EMPTY
71965: LIST
71966: LIST
71967: PUSH
71968: LD_INT 1
71970: NEG
71971: PUSH
71972: LD_INT 6
71974: NEG
71975: PUSH
71976: EMPTY
71977: LIST
71978: LIST
71979: PUSH
71980: LD_INT 0
71982: PUSH
71983: LD_INT 6
71985: NEG
71986: PUSH
71987: EMPTY
71988: LIST
71989: LIST
71990: PUSH
71991: LD_INT 1
71993: PUSH
71994: LD_INT 5
71996: NEG
71997: PUSH
71998: EMPTY
71999: LIST
72000: LIST
72001: PUSH
72002: EMPTY
72003: LIST
72004: LIST
72005: LIST
72006: LIST
72007: LIST
72008: LIST
72009: LIST
72010: LIST
72011: LIST
72012: LIST
72013: LIST
72014: LIST
72015: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
72016: LD_ADDR_VAR 0 30
72020: PUSH
72021: LD_INT 2
72023: PUSH
72024: LD_INT 1
72026: NEG
72027: PUSH
72028: EMPTY
72029: LIST
72030: LIST
72031: PUSH
72032: LD_INT 3
72034: PUSH
72035: LD_INT 0
72037: PUSH
72038: EMPTY
72039: LIST
72040: LIST
72041: PUSH
72042: LD_INT 3
72044: PUSH
72045: LD_INT 1
72047: PUSH
72048: EMPTY
72049: LIST
72050: LIST
72051: PUSH
72052: LD_INT 3
72054: PUSH
72055: LD_INT 1
72057: NEG
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: PUSH
72063: LD_INT 4
72065: PUSH
72066: LD_INT 0
72068: PUSH
72069: EMPTY
72070: LIST
72071: LIST
72072: PUSH
72073: LD_INT 4
72075: PUSH
72076: LD_INT 1
72078: PUSH
72079: EMPTY
72080: LIST
72081: LIST
72082: PUSH
72083: LD_INT 4
72085: PUSH
72086: LD_INT 1
72088: NEG
72089: PUSH
72090: EMPTY
72091: LIST
72092: LIST
72093: PUSH
72094: LD_INT 5
72096: PUSH
72097: LD_INT 0
72099: PUSH
72100: EMPTY
72101: LIST
72102: LIST
72103: PUSH
72104: LD_INT 5
72106: PUSH
72107: LD_INT 1
72109: PUSH
72110: EMPTY
72111: LIST
72112: LIST
72113: PUSH
72114: LD_INT 5
72116: PUSH
72117: LD_INT 1
72119: NEG
72120: PUSH
72121: EMPTY
72122: LIST
72123: LIST
72124: PUSH
72125: LD_INT 6
72127: PUSH
72128: LD_INT 0
72130: PUSH
72131: EMPTY
72132: LIST
72133: LIST
72134: PUSH
72135: LD_INT 6
72137: PUSH
72138: LD_INT 1
72140: PUSH
72141: EMPTY
72142: LIST
72143: LIST
72144: PUSH
72145: EMPTY
72146: LIST
72147: LIST
72148: LIST
72149: LIST
72150: LIST
72151: LIST
72152: LIST
72153: LIST
72154: LIST
72155: LIST
72156: LIST
72157: LIST
72158: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
72159: LD_ADDR_VAR 0 31
72163: PUSH
72164: LD_INT 3
72166: PUSH
72167: LD_INT 2
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: PUSH
72174: LD_INT 3
72176: PUSH
72177: LD_INT 3
72179: PUSH
72180: EMPTY
72181: LIST
72182: LIST
72183: PUSH
72184: LD_INT 2
72186: PUSH
72187: LD_INT 3
72189: PUSH
72190: EMPTY
72191: LIST
72192: LIST
72193: PUSH
72194: LD_INT 4
72196: PUSH
72197: LD_INT 3
72199: PUSH
72200: EMPTY
72201: LIST
72202: LIST
72203: PUSH
72204: LD_INT 4
72206: PUSH
72207: LD_INT 4
72209: PUSH
72210: EMPTY
72211: LIST
72212: LIST
72213: PUSH
72214: LD_INT 3
72216: PUSH
72217: LD_INT 4
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: PUSH
72224: LD_INT 5
72226: PUSH
72227: LD_INT 4
72229: PUSH
72230: EMPTY
72231: LIST
72232: LIST
72233: PUSH
72234: LD_INT 5
72236: PUSH
72237: LD_INT 5
72239: PUSH
72240: EMPTY
72241: LIST
72242: LIST
72243: PUSH
72244: LD_INT 4
72246: PUSH
72247: LD_INT 5
72249: PUSH
72250: EMPTY
72251: LIST
72252: LIST
72253: PUSH
72254: LD_INT 6
72256: PUSH
72257: LD_INT 5
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: PUSH
72264: LD_INT 6
72266: PUSH
72267: LD_INT 6
72269: PUSH
72270: EMPTY
72271: LIST
72272: LIST
72273: PUSH
72274: LD_INT 5
72276: PUSH
72277: LD_INT 6
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: EMPTY
72285: LIST
72286: LIST
72287: LIST
72288: LIST
72289: LIST
72290: LIST
72291: LIST
72292: LIST
72293: LIST
72294: LIST
72295: LIST
72296: LIST
72297: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
72298: LD_ADDR_VAR 0 32
72302: PUSH
72303: LD_INT 1
72305: PUSH
72306: LD_INT 3
72308: PUSH
72309: EMPTY
72310: LIST
72311: LIST
72312: PUSH
72313: LD_INT 0
72315: PUSH
72316: LD_INT 3
72318: PUSH
72319: EMPTY
72320: LIST
72321: LIST
72322: PUSH
72323: LD_INT 1
72325: NEG
72326: PUSH
72327: LD_INT 2
72329: PUSH
72330: EMPTY
72331: LIST
72332: LIST
72333: PUSH
72334: LD_INT 1
72336: PUSH
72337: LD_INT 4
72339: PUSH
72340: EMPTY
72341: LIST
72342: LIST
72343: PUSH
72344: LD_INT 0
72346: PUSH
72347: LD_INT 4
72349: PUSH
72350: EMPTY
72351: LIST
72352: LIST
72353: PUSH
72354: LD_INT 1
72356: NEG
72357: PUSH
72358: LD_INT 3
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: PUSH
72365: LD_INT 1
72367: PUSH
72368: LD_INT 5
72370: PUSH
72371: EMPTY
72372: LIST
72373: LIST
72374: PUSH
72375: LD_INT 0
72377: PUSH
72378: LD_INT 5
72380: PUSH
72381: EMPTY
72382: LIST
72383: LIST
72384: PUSH
72385: LD_INT 1
72387: NEG
72388: PUSH
72389: LD_INT 4
72391: PUSH
72392: EMPTY
72393: LIST
72394: LIST
72395: PUSH
72396: LD_INT 1
72398: PUSH
72399: LD_INT 6
72401: PUSH
72402: EMPTY
72403: LIST
72404: LIST
72405: PUSH
72406: LD_INT 0
72408: PUSH
72409: LD_INT 6
72411: PUSH
72412: EMPTY
72413: LIST
72414: LIST
72415: PUSH
72416: LD_INT 1
72418: NEG
72419: PUSH
72420: LD_INT 5
72422: PUSH
72423: EMPTY
72424: LIST
72425: LIST
72426: PUSH
72427: EMPTY
72428: LIST
72429: LIST
72430: LIST
72431: LIST
72432: LIST
72433: LIST
72434: LIST
72435: LIST
72436: LIST
72437: LIST
72438: LIST
72439: LIST
72440: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
72441: LD_ADDR_VAR 0 33
72445: PUSH
72446: LD_INT 2
72448: NEG
72449: PUSH
72450: LD_INT 1
72452: PUSH
72453: EMPTY
72454: LIST
72455: LIST
72456: PUSH
72457: LD_INT 3
72459: NEG
72460: PUSH
72461: LD_INT 0
72463: PUSH
72464: EMPTY
72465: LIST
72466: LIST
72467: PUSH
72468: LD_INT 3
72470: NEG
72471: PUSH
72472: LD_INT 1
72474: NEG
72475: PUSH
72476: EMPTY
72477: LIST
72478: LIST
72479: PUSH
72480: LD_INT 3
72482: NEG
72483: PUSH
72484: LD_INT 1
72486: PUSH
72487: EMPTY
72488: LIST
72489: LIST
72490: PUSH
72491: LD_INT 4
72493: NEG
72494: PUSH
72495: LD_INT 0
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PUSH
72502: LD_INT 4
72504: NEG
72505: PUSH
72506: LD_INT 1
72508: NEG
72509: PUSH
72510: EMPTY
72511: LIST
72512: LIST
72513: PUSH
72514: LD_INT 4
72516: NEG
72517: PUSH
72518: LD_INT 1
72520: PUSH
72521: EMPTY
72522: LIST
72523: LIST
72524: PUSH
72525: LD_INT 5
72527: NEG
72528: PUSH
72529: LD_INT 0
72531: PUSH
72532: EMPTY
72533: LIST
72534: LIST
72535: PUSH
72536: LD_INT 5
72538: NEG
72539: PUSH
72540: LD_INT 1
72542: NEG
72543: PUSH
72544: EMPTY
72545: LIST
72546: LIST
72547: PUSH
72548: LD_INT 5
72550: NEG
72551: PUSH
72552: LD_INT 1
72554: PUSH
72555: EMPTY
72556: LIST
72557: LIST
72558: PUSH
72559: LD_INT 6
72561: NEG
72562: PUSH
72563: LD_INT 0
72565: PUSH
72566: EMPTY
72567: LIST
72568: LIST
72569: PUSH
72570: LD_INT 6
72572: NEG
72573: PUSH
72574: LD_INT 1
72576: NEG
72577: PUSH
72578: EMPTY
72579: LIST
72580: LIST
72581: PUSH
72582: EMPTY
72583: LIST
72584: LIST
72585: LIST
72586: LIST
72587: LIST
72588: LIST
72589: LIST
72590: LIST
72591: LIST
72592: LIST
72593: LIST
72594: LIST
72595: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
72596: LD_ADDR_VAR 0 34
72600: PUSH
72601: LD_INT 2
72603: NEG
72604: PUSH
72605: LD_INT 3
72607: NEG
72608: PUSH
72609: EMPTY
72610: LIST
72611: LIST
72612: PUSH
72613: LD_INT 3
72615: NEG
72616: PUSH
72617: LD_INT 2
72619: NEG
72620: PUSH
72621: EMPTY
72622: LIST
72623: LIST
72624: PUSH
72625: LD_INT 3
72627: NEG
72628: PUSH
72629: LD_INT 3
72631: NEG
72632: PUSH
72633: EMPTY
72634: LIST
72635: LIST
72636: PUSH
72637: LD_INT 3
72639: NEG
72640: PUSH
72641: LD_INT 4
72643: NEG
72644: PUSH
72645: EMPTY
72646: LIST
72647: LIST
72648: PUSH
72649: LD_INT 4
72651: NEG
72652: PUSH
72653: LD_INT 3
72655: NEG
72656: PUSH
72657: EMPTY
72658: LIST
72659: LIST
72660: PUSH
72661: LD_INT 4
72663: NEG
72664: PUSH
72665: LD_INT 4
72667: NEG
72668: PUSH
72669: EMPTY
72670: LIST
72671: LIST
72672: PUSH
72673: LD_INT 4
72675: NEG
72676: PUSH
72677: LD_INT 5
72679: NEG
72680: PUSH
72681: EMPTY
72682: LIST
72683: LIST
72684: PUSH
72685: LD_INT 5
72687: NEG
72688: PUSH
72689: LD_INT 4
72691: NEG
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: PUSH
72697: LD_INT 5
72699: NEG
72700: PUSH
72701: LD_INT 5
72703: NEG
72704: PUSH
72705: EMPTY
72706: LIST
72707: LIST
72708: PUSH
72709: LD_INT 5
72711: NEG
72712: PUSH
72713: LD_INT 6
72715: NEG
72716: PUSH
72717: EMPTY
72718: LIST
72719: LIST
72720: PUSH
72721: LD_INT 6
72723: NEG
72724: PUSH
72725: LD_INT 5
72727: NEG
72728: PUSH
72729: EMPTY
72730: LIST
72731: LIST
72732: PUSH
72733: LD_INT 6
72735: NEG
72736: PUSH
72737: LD_INT 6
72739: NEG
72740: PUSH
72741: EMPTY
72742: LIST
72743: LIST
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: LIST
72749: LIST
72750: LIST
72751: LIST
72752: LIST
72753: LIST
72754: LIST
72755: LIST
72756: LIST
72757: LIST
72758: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
72759: LD_ADDR_VAR 0 41
72763: PUSH
72764: LD_INT 0
72766: PUSH
72767: LD_INT 2
72769: NEG
72770: PUSH
72771: EMPTY
72772: LIST
72773: LIST
72774: PUSH
72775: LD_INT 1
72777: NEG
72778: PUSH
72779: LD_INT 3
72781: NEG
72782: PUSH
72783: EMPTY
72784: LIST
72785: LIST
72786: PUSH
72787: LD_INT 1
72789: PUSH
72790: LD_INT 2
72792: NEG
72793: PUSH
72794: EMPTY
72795: LIST
72796: LIST
72797: PUSH
72798: EMPTY
72799: LIST
72800: LIST
72801: LIST
72802: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
72803: LD_ADDR_VAR 0 42
72807: PUSH
72808: LD_INT 2
72810: PUSH
72811: LD_INT 0
72813: PUSH
72814: EMPTY
72815: LIST
72816: LIST
72817: PUSH
72818: LD_INT 2
72820: PUSH
72821: LD_INT 1
72823: NEG
72824: PUSH
72825: EMPTY
72826: LIST
72827: LIST
72828: PUSH
72829: LD_INT 3
72831: PUSH
72832: LD_INT 1
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PUSH
72839: EMPTY
72840: LIST
72841: LIST
72842: LIST
72843: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
72844: LD_ADDR_VAR 0 43
72848: PUSH
72849: LD_INT 2
72851: PUSH
72852: LD_INT 2
72854: PUSH
72855: EMPTY
72856: LIST
72857: LIST
72858: PUSH
72859: LD_INT 3
72861: PUSH
72862: LD_INT 2
72864: PUSH
72865: EMPTY
72866: LIST
72867: LIST
72868: PUSH
72869: LD_INT 2
72871: PUSH
72872: LD_INT 3
72874: PUSH
72875: EMPTY
72876: LIST
72877: LIST
72878: PUSH
72879: EMPTY
72880: LIST
72881: LIST
72882: LIST
72883: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
72884: LD_ADDR_VAR 0 44
72888: PUSH
72889: LD_INT 0
72891: PUSH
72892: LD_INT 2
72894: PUSH
72895: EMPTY
72896: LIST
72897: LIST
72898: PUSH
72899: LD_INT 1
72901: PUSH
72902: LD_INT 3
72904: PUSH
72905: EMPTY
72906: LIST
72907: LIST
72908: PUSH
72909: LD_INT 1
72911: NEG
72912: PUSH
72913: LD_INT 2
72915: PUSH
72916: EMPTY
72917: LIST
72918: LIST
72919: PUSH
72920: EMPTY
72921: LIST
72922: LIST
72923: LIST
72924: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72925: LD_ADDR_VAR 0 45
72929: PUSH
72930: LD_INT 2
72932: NEG
72933: PUSH
72934: LD_INT 0
72936: PUSH
72937: EMPTY
72938: LIST
72939: LIST
72940: PUSH
72941: LD_INT 2
72943: NEG
72944: PUSH
72945: LD_INT 1
72947: PUSH
72948: EMPTY
72949: LIST
72950: LIST
72951: PUSH
72952: LD_INT 3
72954: NEG
72955: PUSH
72956: LD_INT 1
72958: NEG
72959: PUSH
72960: EMPTY
72961: LIST
72962: LIST
72963: PUSH
72964: EMPTY
72965: LIST
72966: LIST
72967: LIST
72968: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
72969: LD_ADDR_VAR 0 46
72973: PUSH
72974: LD_INT 2
72976: NEG
72977: PUSH
72978: LD_INT 2
72980: NEG
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: PUSH
72986: LD_INT 2
72988: NEG
72989: PUSH
72990: LD_INT 3
72992: NEG
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: PUSH
72998: LD_INT 3
73000: NEG
73001: PUSH
73002: LD_INT 2
73004: NEG
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PUSH
73010: EMPTY
73011: LIST
73012: LIST
73013: LIST
73014: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
73015: LD_ADDR_VAR 0 47
73019: PUSH
73020: LD_INT 2
73022: NEG
73023: PUSH
73024: LD_INT 3
73026: NEG
73027: PUSH
73028: EMPTY
73029: LIST
73030: LIST
73031: PUSH
73032: LD_INT 1
73034: NEG
73035: PUSH
73036: LD_INT 3
73038: NEG
73039: PUSH
73040: EMPTY
73041: LIST
73042: LIST
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
73048: LD_ADDR_VAR 0 48
73052: PUSH
73053: LD_INT 1
73055: PUSH
73056: LD_INT 2
73058: NEG
73059: PUSH
73060: EMPTY
73061: LIST
73062: LIST
73063: PUSH
73064: LD_INT 2
73066: PUSH
73067: LD_INT 1
73069: NEG
73070: PUSH
73071: EMPTY
73072: LIST
73073: LIST
73074: PUSH
73075: EMPTY
73076: LIST
73077: LIST
73078: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
73079: LD_ADDR_VAR 0 49
73083: PUSH
73084: LD_INT 3
73086: PUSH
73087: LD_INT 1
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: PUSH
73094: LD_INT 3
73096: PUSH
73097: LD_INT 2
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: PUSH
73104: EMPTY
73105: LIST
73106: LIST
73107: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
73108: LD_ADDR_VAR 0 50
73112: PUSH
73113: LD_INT 2
73115: PUSH
73116: LD_INT 3
73118: PUSH
73119: EMPTY
73120: LIST
73121: LIST
73122: PUSH
73123: LD_INT 1
73125: PUSH
73126: LD_INT 3
73128: PUSH
73129: EMPTY
73130: LIST
73131: LIST
73132: PUSH
73133: EMPTY
73134: LIST
73135: LIST
73136: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
73137: LD_ADDR_VAR 0 51
73141: PUSH
73142: LD_INT 1
73144: NEG
73145: PUSH
73146: LD_INT 2
73148: PUSH
73149: EMPTY
73150: LIST
73151: LIST
73152: PUSH
73153: LD_INT 2
73155: NEG
73156: PUSH
73157: LD_INT 1
73159: PUSH
73160: EMPTY
73161: LIST
73162: LIST
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
73168: LD_ADDR_VAR 0 52
73172: PUSH
73173: LD_INT 3
73175: NEG
73176: PUSH
73177: LD_INT 1
73179: NEG
73180: PUSH
73181: EMPTY
73182: LIST
73183: LIST
73184: PUSH
73185: LD_INT 3
73187: NEG
73188: PUSH
73189: LD_INT 2
73191: NEG
73192: PUSH
73193: EMPTY
73194: LIST
73195: LIST
73196: PUSH
73197: EMPTY
73198: LIST
73199: LIST
73200: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
73201: LD_ADDR_VAR 0 53
73205: PUSH
73206: LD_INT 1
73208: NEG
73209: PUSH
73210: LD_INT 3
73212: NEG
73213: PUSH
73214: EMPTY
73215: LIST
73216: LIST
73217: PUSH
73218: LD_INT 0
73220: PUSH
73221: LD_INT 3
73223: NEG
73224: PUSH
73225: EMPTY
73226: LIST
73227: LIST
73228: PUSH
73229: LD_INT 1
73231: PUSH
73232: LD_INT 2
73234: NEG
73235: PUSH
73236: EMPTY
73237: LIST
73238: LIST
73239: PUSH
73240: EMPTY
73241: LIST
73242: LIST
73243: LIST
73244: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
73245: LD_ADDR_VAR 0 54
73249: PUSH
73250: LD_INT 2
73252: PUSH
73253: LD_INT 1
73255: NEG
73256: PUSH
73257: EMPTY
73258: LIST
73259: LIST
73260: PUSH
73261: LD_INT 3
73263: PUSH
73264: LD_INT 0
73266: PUSH
73267: EMPTY
73268: LIST
73269: LIST
73270: PUSH
73271: LD_INT 3
73273: PUSH
73274: LD_INT 1
73276: PUSH
73277: EMPTY
73278: LIST
73279: LIST
73280: PUSH
73281: EMPTY
73282: LIST
73283: LIST
73284: LIST
73285: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
73286: LD_ADDR_VAR 0 55
73290: PUSH
73291: LD_INT 3
73293: PUSH
73294: LD_INT 2
73296: PUSH
73297: EMPTY
73298: LIST
73299: LIST
73300: PUSH
73301: LD_INT 3
73303: PUSH
73304: LD_INT 3
73306: PUSH
73307: EMPTY
73308: LIST
73309: LIST
73310: PUSH
73311: LD_INT 2
73313: PUSH
73314: LD_INT 3
73316: PUSH
73317: EMPTY
73318: LIST
73319: LIST
73320: PUSH
73321: EMPTY
73322: LIST
73323: LIST
73324: LIST
73325: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
73326: LD_ADDR_VAR 0 56
73330: PUSH
73331: LD_INT 1
73333: PUSH
73334: LD_INT 3
73336: PUSH
73337: EMPTY
73338: LIST
73339: LIST
73340: PUSH
73341: LD_INT 0
73343: PUSH
73344: LD_INT 3
73346: PUSH
73347: EMPTY
73348: LIST
73349: LIST
73350: PUSH
73351: LD_INT 1
73353: NEG
73354: PUSH
73355: LD_INT 2
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: LIST
73366: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73367: LD_ADDR_VAR 0 57
73371: PUSH
73372: LD_INT 2
73374: NEG
73375: PUSH
73376: LD_INT 1
73378: PUSH
73379: EMPTY
73380: LIST
73381: LIST
73382: PUSH
73383: LD_INT 3
73385: NEG
73386: PUSH
73387: LD_INT 0
73389: PUSH
73390: EMPTY
73391: LIST
73392: LIST
73393: PUSH
73394: LD_INT 3
73396: NEG
73397: PUSH
73398: LD_INT 1
73400: NEG
73401: PUSH
73402: EMPTY
73403: LIST
73404: LIST
73405: PUSH
73406: EMPTY
73407: LIST
73408: LIST
73409: LIST
73410: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73411: LD_ADDR_VAR 0 58
73415: PUSH
73416: LD_INT 2
73418: NEG
73419: PUSH
73420: LD_INT 3
73422: NEG
73423: PUSH
73424: EMPTY
73425: LIST
73426: LIST
73427: PUSH
73428: LD_INT 3
73430: NEG
73431: PUSH
73432: LD_INT 2
73434: NEG
73435: PUSH
73436: EMPTY
73437: LIST
73438: LIST
73439: PUSH
73440: LD_INT 3
73442: NEG
73443: PUSH
73444: LD_INT 3
73446: NEG
73447: PUSH
73448: EMPTY
73449: LIST
73450: LIST
73451: PUSH
73452: EMPTY
73453: LIST
73454: LIST
73455: LIST
73456: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
73457: LD_ADDR_VAR 0 59
73461: PUSH
73462: LD_INT 1
73464: NEG
73465: PUSH
73466: LD_INT 2
73468: NEG
73469: PUSH
73470: EMPTY
73471: LIST
73472: LIST
73473: PUSH
73474: LD_INT 0
73476: PUSH
73477: LD_INT 2
73479: NEG
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: PUSH
73485: LD_INT 1
73487: PUSH
73488: LD_INT 1
73490: NEG
73491: PUSH
73492: EMPTY
73493: LIST
73494: LIST
73495: PUSH
73496: EMPTY
73497: LIST
73498: LIST
73499: LIST
73500: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
73501: LD_ADDR_VAR 0 60
73505: PUSH
73506: LD_INT 1
73508: PUSH
73509: LD_INT 1
73511: NEG
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: PUSH
73517: LD_INT 2
73519: PUSH
73520: LD_INT 0
73522: PUSH
73523: EMPTY
73524: LIST
73525: LIST
73526: PUSH
73527: LD_INT 2
73529: PUSH
73530: LD_INT 1
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: PUSH
73537: EMPTY
73538: LIST
73539: LIST
73540: LIST
73541: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
73542: LD_ADDR_VAR 0 61
73546: PUSH
73547: LD_INT 2
73549: PUSH
73550: LD_INT 1
73552: PUSH
73553: EMPTY
73554: LIST
73555: LIST
73556: PUSH
73557: LD_INT 2
73559: PUSH
73560: LD_INT 2
73562: PUSH
73563: EMPTY
73564: LIST
73565: LIST
73566: PUSH
73567: LD_INT 1
73569: PUSH
73570: LD_INT 2
73572: PUSH
73573: EMPTY
73574: LIST
73575: LIST
73576: PUSH
73577: EMPTY
73578: LIST
73579: LIST
73580: LIST
73581: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
73582: LD_ADDR_VAR 0 62
73586: PUSH
73587: LD_INT 1
73589: PUSH
73590: LD_INT 2
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PUSH
73597: LD_INT 0
73599: PUSH
73600: LD_INT 2
73602: PUSH
73603: EMPTY
73604: LIST
73605: LIST
73606: PUSH
73607: LD_INT 1
73609: NEG
73610: PUSH
73611: LD_INT 1
73613: PUSH
73614: EMPTY
73615: LIST
73616: LIST
73617: PUSH
73618: EMPTY
73619: LIST
73620: LIST
73621: LIST
73622: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
73623: LD_ADDR_VAR 0 63
73627: PUSH
73628: LD_INT 1
73630: NEG
73631: PUSH
73632: LD_INT 1
73634: PUSH
73635: EMPTY
73636: LIST
73637: LIST
73638: PUSH
73639: LD_INT 2
73641: NEG
73642: PUSH
73643: LD_INT 0
73645: PUSH
73646: EMPTY
73647: LIST
73648: LIST
73649: PUSH
73650: LD_INT 2
73652: NEG
73653: PUSH
73654: LD_INT 1
73656: NEG
73657: PUSH
73658: EMPTY
73659: LIST
73660: LIST
73661: PUSH
73662: EMPTY
73663: LIST
73664: LIST
73665: LIST
73666: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73667: LD_ADDR_VAR 0 64
73671: PUSH
73672: LD_INT 1
73674: NEG
73675: PUSH
73676: LD_INT 2
73678: NEG
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: PUSH
73684: LD_INT 2
73686: NEG
73687: PUSH
73688: LD_INT 1
73690: NEG
73691: PUSH
73692: EMPTY
73693: LIST
73694: LIST
73695: PUSH
73696: LD_INT 2
73698: NEG
73699: PUSH
73700: LD_INT 2
73702: NEG
73703: PUSH
73704: EMPTY
73705: LIST
73706: LIST
73707: PUSH
73708: EMPTY
73709: LIST
73710: LIST
73711: LIST
73712: ST_TO_ADDR
// end ; 2 :
73713: GO 76979
73715: LD_INT 2
73717: DOUBLE
73718: EQUAL
73719: IFTRUE 73723
73721: GO 76978
73723: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
73724: LD_ADDR_VAR 0 29
73728: PUSH
73729: LD_INT 4
73731: PUSH
73732: LD_INT 0
73734: PUSH
73735: EMPTY
73736: LIST
73737: LIST
73738: PUSH
73739: LD_INT 4
73741: PUSH
73742: LD_INT 1
73744: NEG
73745: PUSH
73746: EMPTY
73747: LIST
73748: LIST
73749: PUSH
73750: LD_INT 5
73752: PUSH
73753: LD_INT 0
73755: PUSH
73756: EMPTY
73757: LIST
73758: LIST
73759: PUSH
73760: LD_INT 5
73762: PUSH
73763: LD_INT 1
73765: PUSH
73766: EMPTY
73767: LIST
73768: LIST
73769: PUSH
73770: LD_INT 4
73772: PUSH
73773: LD_INT 1
73775: PUSH
73776: EMPTY
73777: LIST
73778: LIST
73779: PUSH
73780: LD_INT 3
73782: PUSH
73783: LD_INT 0
73785: PUSH
73786: EMPTY
73787: LIST
73788: LIST
73789: PUSH
73790: LD_INT 3
73792: PUSH
73793: LD_INT 1
73795: NEG
73796: PUSH
73797: EMPTY
73798: LIST
73799: LIST
73800: PUSH
73801: LD_INT 3
73803: PUSH
73804: LD_INT 2
73806: NEG
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: PUSH
73812: LD_INT 5
73814: PUSH
73815: LD_INT 2
73817: PUSH
73818: EMPTY
73819: LIST
73820: LIST
73821: PUSH
73822: LD_INT 3
73824: PUSH
73825: LD_INT 3
73827: PUSH
73828: EMPTY
73829: LIST
73830: LIST
73831: PUSH
73832: LD_INT 3
73834: PUSH
73835: LD_INT 2
73837: PUSH
73838: EMPTY
73839: LIST
73840: LIST
73841: PUSH
73842: LD_INT 4
73844: PUSH
73845: LD_INT 3
73847: PUSH
73848: EMPTY
73849: LIST
73850: LIST
73851: PUSH
73852: LD_INT 4
73854: PUSH
73855: LD_INT 4
73857: PUSH
73858: EMPTY
73859: LIST
73860: LIST
73861: PUSH
73862: LD_INT 3
73864: PUSH
73865: LD_INT 4
73867: PUSH
73868: EMPTY
73869: LIST
73870: LIST
73871: PUSH
73872: LD_INT 2
73874: PUSH
73875: LD_INT 3
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PUSH
73882: LD_INT 2
73884: PUSH
73885: LD_INT 2
73887: PUSH
73888: EMPTY
73889: LIST
73890: LIST
73891: PUSH
73892: LD_INT 4
73894: PUSH
73895: LD_INT 2
73897: PUSH
73898: EMPTY
73899: LIST
73900: LIST
73901: PUSH
73902: LD_INT 2
73904: PUSH
73905: LD_INT 4
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: PUSH
73912: LD_INT 0
73914: PUSH
73915: LD_INT 4
73917: PUSH
73918: EMPTY
73919: LIST
73920: LIST
73921: PUSH
73922: LD_INT 0
73924: PUSH
73925: LD_INT 3
73927: PUSH
73928: EMPTY
73929: LIST
73930: LIST
73931: PUSH
73932: LD_INT 1
73934: PUSH
73935: LD_INT 4
73937: PUSH
73938: EMPTY
73939: LIST
73940: LIST
73941: PUSH
73942: LD_INT 1
73944: PUSH
73945: LD_INT 5
73947: PUSH
73948: EMPTY
73949: LIST
73950: LIST
73951: PUSH
73952: LD_INT 0
73954: PUSH
73955: LD_INT 5
73957: PUSH
73958: EMPTY
73959: LIST
73960: LIST
73961: PUSH
73962: LD_INT 1
73964: NEG
73965: PUSH
73966: LD_INT 4
73968: PUSH
73969: EMPTY
73970: LIST
73971: LIST
73972: PUSH
73973: LD_INT 1
73975: NEG
73976: PUSH
73977: LD_INT 3
73979: PUSH
73980: EMPTY
73981: LIST
73982: LIST
73983: PUSH
73984: LD_INT 2
73986: PUSH
73987: LD_INT 5
73989: PUSH
73990: EMPTY
73991: LIST
73992: LIST
73993: PUSH
73994: LD_INT 2
73996: NEG
73997: PUSH
73998: LD_INT 3
74000: PUSH
74001: EMPTY
74002: LIST
74003: LIST
74004: PUSH
74005: LD_INT 3
74007: NEG
74008: PUSH
74009: LD_INT 0
74011: PUSH
74012: EMPTY
74013: LIST
74014: LIST
74015: PUSH
74016: LD_INT 3
74018: NEG
74019: PUSH
74020: LD_INT 1
74022: NEG
74023: PUSH
74024: EMPTY
74025: LIST
74026: LIST
74027: PUSH
74028: LD_INT 2
74030: NEG
74031: PUSH
74032: LD_INT 0
74034: PUSH
74035: EMPTY
74036: LIST
74037: LIST
74038: PUSH
74039: LD_INT 2
74041: NEG
74042: PUSH
74043: LD_INT 1
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: PUSH
74050: LD_INT 3
74052: NEG
74053: PUSH
74054: LD_INT 1
74056: PUSH
74057: EMPTY
74058: LIST
74059: LIST
74060: PUSH
74061: LD_INT 4
74063: NEG
74064: PUSH
74065: LD_INT 0
74067: PUSH
74068: EMPTY
74069: LIST
74070: LIST
74071: PUSH
74072: LD_INT 4
74074: NEG
74075: PUSH
74076: LD_INT 1
74078: NEG
74079: PUSH
74080: EMPTY
74081: LIST
74082: LIST
74083: PUSH
74084: LD_INT 4
74086: NEG
74087: PUSH
74088: LD_INT 2
74090: NEG
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 2
74098: NEG
74099: PUSH
74100: LD_INT 2
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: PUSH
74107: LD_INT 4
74109: NEG
74110: PUSH
74111: LD_INT 4
74113: NEG
74114: PUSH
74115: EMPTY
74116: LIST
74117: LIST
74118: PUSH
74119: LD_INT 4
74121: NEG
74122: PUSH
74123: LD_INT 5
74125: NEG
74126: PUSH
74127: EMPTY
74128: LIST
74129: LIST
74130: PUSH
74131: LD_INT 3
74133: NEG
74134: PUSH
74135: LD_INT 4
74137: NEG
74138: PUSH
74139: EMPTY
74140: LIST
74141: LIST
74142: PUSH
74143: LD_INT 3
74145: NEG
74146: PUSH
74147: LD_INT 3
74149: NEG
74150: PUSH
74151: EMPTY
74152: LIST
74153: LIST
74154: PUSH
74155: LD_INT 4
74157: NEG
74158: PUSH
74159: LD_INT 3
74161: NEG
74162: PUSH
74163: EMPTY
74164: LIST
74165: LIST
74166: PUSH
74167: LD_INT 5
74169: NEG
74170: PUSH
74171: LD_INT 4
74173: NEG
74174: PUSH
74175: EMPTY
74176: LIST
74177: LIST
74178: PUSH
74179: LD_INT 5
74181: NEG
74182: PUSH
74183: LD_INT 5
74185: NEG
74186: PUSH
74187: EMPTY
74188: LIST
74189: LIST
74190: PUSH
74191: LD_INT 3
74193: NEG
74194: PUSH
74195: LD_INT 5
74197: NEG
74198: PUSH
74199: EMPTY
74200: LIST
74201: LIST
74202: PUSH
74203: LD_INT 5
74205: NEG
74206: PUSH
74207: LD_INT 3
74209: NEG
74210: PUSH
74211: EMPTY
74212: LIST
74213: LIST
74214: PUSH
74215: EMPTY
74216: LIST
74217: LIST
74218: LIST
74219: LIST
74220: LIST
74221: LIST
74222: LIST
74223: LIST
74224: LIST
74225: LIST
74226: LIST
74227: LIST
74228: LIST
74229: LIST
74230: LIST
74231: LIST
74232: LIST
74233: LIST
74234: LIST
74235: LIST
74236: LIST
74237: LIST
74238: LIST
74239: LIST
74240: LIST
74241: LIST
74242: LIST
74243: LIST
74244: LIST
74245: LIST
74246: LIST
74247: LIST
74248: LIST
74249: LIST
74250: LIST
74251: LIST
74252: LIST
74253: LIST
74254: LIST
74255: LIST
74256: LIST
74257: LIST
74258: LIST
74259: LIST
74260: LIST
74261: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
74262: LD_ADDR_VAR 0 30
74266: PUSH
74267: LD_INT 4
74269: PUSH
74270: LD_INT 4
74272: PUSH
74273: EMPTY
74274: LIST
74275: LIST
74276: PUSH
74277: LD_INT 4
74279: PUSH
74280: LD_INT 3
74282: PUSH
74283: EMPTY
74284: LIST
74285: LIST
74286: PUSH
74287: LD_INT 5
74289: PUSH
74290: LD_INT 4
74292: PUSH
74293: EMPTY
74294: LIST
74295: LIST
74296: PUSH
74297: LD_INT 5
74299: PUSH
74300: LD_INT 5
74302: PUSH
74303: EMPTY
74304: LIST
74305: LIST
74306: PUSH
74307: LD_INT 4
74309: PUSH
74310: LD_INT 5
74312: PUSH
74313: EMPTY
74314: LIST
74315: LIST
74316: PUSH
74317: LD_INT 3
74319: PUSH
74320: LD_INT 4
74322: PUSH
74323: EMPTY
74324: LIST
74325: LIST
74326: PUSH
74327: LD_INT 3
74329: PUSH
74330: LD_INT 3
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: PUSH
74337: LD_INT 5
74339: PUSH
74340: LD_INT 3
74342: PUSH
74343: EMPTY
74344: LIST
74345: LIST
74346: PUSH
74347: LD_INT 3
74349: PUSH
74350: LD_INT 5
74352: PUSH
74353: EMPTY
74354: LIST
74355: LIST
74356: PUSH
74357: LD_INT 0
74359: PUSH
74360: LD_INT 3
74362: PUSH
74363: EMPTY
74364: LIST
74365: LIST
74366: PUSH
74367: LD_INT 0
74369: PUSH
74370: LD_INT 2
74372: PUSH
74373: EMPTY
74374: LIST
74375: LIST
74376: PUSH
74377: LD_INT 1
74379: PUSH
74380: LD_INT 3
74382: PUSH
74383: EMPTY
74384: LIST
74385: LIST
74386: PUSH
74387: LD_INT 1
74389: PUSH
74390: LD_INT 4
74392: PUSH
74393: EMPTY
74394: LIST
74395: LIST
74396: PUSH
74397: LD_INT 0
74399: PUSH
74400: LD_INT 4
74402: PUSH
74403: EMPTY
74404: LIST
74405: LIST
74406: PUSH
74407: LD_INT 1
74409: NEG
74410: PUSH
74411: LD_INT 3
74413: PUSH
74414: EMPTY
74415: LIST
74416: LIST
74417: PUSH
74418: LD_INT 1
74420: NEG
74421: PUSH
74422: LD_INT 2
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: PUSH
74429: LD_INT 2
74431: PUSH
74432: LD_INT 4
74434: PUSH
74435: EMPTY
74436: LIST
74437: LIST
74438: PUSH
74439: LD_INT 2
74441: NEG
74442: PUSH
74443: LD_INT 2
74445: PUSH
74446: EMPTY
74447: LIST
74448: LIST
74449: PUSH
74450: LD_INT 4
74452: NEG
74453: PUSH
74454: LD_INT 0
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: PUSH
74461: LD_INT 4
74463: NEG
74464: PUSH
74465: LD_INT 1
74467: NEG
74468: PUSH
74469: EMPTY
74470: LIST
74471: LIST
74472: PUSH
74473: LD_INT 3
74475: NEG
74476: PUSH
74477: LD_INT 0
74479: PUSH
74480: EMPTY
74481: LIST
74482: LIST
74483: PUSH
74484: LD_INT 3
74486: NEG
74487: PUSH
74488: LD_INT 1
74490: PUSH
74491: EMPTY
74492: LIST
74493: LIST
74494: PUSH
74495: LD_INT 4
74497: NEG
74498: PUSH
74499: LD_INT 1
74501: PUSH
74502: EMPTY
74503: LIST
74504: LIST
74505: PUSH
74506: LD_INT 5
74508: NEG
74509: PUSH
74510: LD_INT 0
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: PUSH
74517: LD_INT 5
74519: NEG
74520: PUSH
74521: LD_INT 1
74523: NEG
74524: PUSH
74525: EMPTY
74526: LIST
74527: LIST
74528: PUSH
74529: LD_INT 5
74531: NEG
74532: PUSH
74533: LD_INT 2
74535: NEG
74536: PUSH
74537: EMPTY
74538: LIST
74539: LIST
74540: PUSH
74541: LD_INT 3
74543: NEG
74544: PUSH
74545: LD_INT 2
74547: PUSH
74548: EMPTY
74549: LIST
74550: LIST
74551: PUSH
74552: LD_INT 3
74554: NEG
74555: PUSH
74556: LD_INT 3
74558: NEG
74559: PUSH
74560: EMPTY
74561: LIST
74562: LIST
74563: PUSH
74564: LD_INT 3
74566: NEG
74567: PUSH
74568: LD_INT 4
74570: NEG
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: PUSH
74576: LD_INT 2
74578: NEG
74579: PUSH
74580: LD_INT 3
74582: NEG
74583: PUSH
74584: EMPTY
74585: LIST
74586: LIST
74587: PUSH
74588: LD_INT 2
74590: NEG
74591: PUSH
74592: LD_INT 2
74594: NEG
74595: PUSH
74596: EMPTY
74597: LIST
74598: LIST
74599: PUSH
74600: LD_INT 3
74602: NEG
74603: PUSH
74604: LD_INT 2
74606: NEG
74607: PUSH
74608: EMPTY
74609: LIST
74610: LIST
74611: PUSH
74612: LD_INT 4
74614: NEG
74615: PUSH
74616: LD_INT 3
74618: NEG
74619: PUSH
74620: EMPTY
74621: LIST
74622: LIST
74623: PUSH
74624: LD_INT 4
74626: NEG
74627: PUSH
74628: LD_INT 4
74630: NEG
74631: PUSH
74632: EMPTY
74633: LIST
74634: LIST
74635: PUSH
74636: LD_INT 2
74638: NEG
74639: PUSH
74640: LD_INT 4
74642: NEG
74643: PUSH
74644: EMPTY
74645: LIST
74646: LIST
74647: PUSH
74648: LD_INT 4
74650: NEG
74651: PUSH
74652: LD_INT 2
74654: NEG
74655: PUSH
74656: EMPTY
74657: LIST
74658: LIST
74659: PUSH
74660: LD_INT 0
74662: PUSH
74663: LD_INT 4
74665: NEG
74666: PUSH
74667: EMPTY
74668: LIST
74669: LIST
74670: PUSH
74671: LD_INT 0
74673: PUSH
74674: LD_INT 5
74676: NEG
74677: PUSH
74678: EMPTY
74679: LIST
74680: LIST
74681: PUSH
74682: LD_INT 1
74684: PUSH
74685: LD_INT 4
74687: NEG
74688: PUSH
74689: EMPTY
74690: LIST
74691: LIST
74692: PUSH
74693: LD_INT 1
74695: PUSH
74696: LD_INT 3
74698: NEG
74699: PUSH
74700: EMPTY
74701: LIST
74702: LIST
74703: PUSH
74704: LD_INT 0
74706: PUSH
74707: LD_INT 3
74709: NEG
74710: PUSH
74711: EMPTY
74712: LIST
74713: LIST
74714: PUSH
74715: LD_INT 1
74717: NEG
74718: PUSH
74719: LD_INT 4
74721: NEG
74722: PUSH
74723: EMPTY
74724: LIST
74725: LIST
74726: PUSH
74727: LD_INT 1
74729: NEG
74730: PUSH
74731: LD_INT 5
74733: NEG
74734: PUSH
74735: EMPTY
74736: LIST
74737: LIST
74738: PUSH
74739: LD_INT 2
74741: PUSH
74742: LD_INT 3
74744: NEG
74745: PUSH
74746: EMPTY
74747: LIST
74748: LIST
74749: PUSH
74750: LD_INT 2
74752: NEG
74753: PUSH
74754: LD_INT 5
74756: NEG
74757: PUSH
74758: EMPTY
74759: LIST
74760: LIST
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: LIST
74766: LIST
74767: LIST
74768: LIST
74769: LIST
74770: LIST
74771: LIST
74772: LIST
74773: LIST
74774: LIST
74775: LIST
74776: LIST
74777: LIST
74778: LIST
74779: LIST
74780: LIST
74781: LIST
74782: LIST
74783: LIST
74784: LIST
74785: LIST
74786: LIST
74787: LIST
74788: LIST
74789: LIST
74790: LIST
74791: LIST
74792: LIST
74793: LIST
74794: LIST
74795: LIST
74796: LIST
74797: LIST
74798: LIST
74799: LIST
74800: LIST
74801: LIST
74802: LIST
74803: LIST
74804: LIST
74805: LIST
74806: LIST
74807: LIST
74808: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
74809: LD_ADDR_VAR 0 31
74813: PUSH
74814: LD_INT 0
74816: PUSH
74817: LD_INT 4
74819: PUSH
74820: EMPTY
74821: LIST
74822: LIST
74823: PUSH
74824: LD_INT 0
74826: PUSH
74827: LD_INT 3
74829: PUSH
74830: EMPTY
74831: LIST
74832: LIST
74833: PUSH
74834: LD_INT 1
74836: PUSH
74837: LD_INT 4
74839: PUSH
74840: EMPTY
74841: LIST
74842: LIST
74843: PUSH
74844: LD_INT 1
74846: PUSH
74847: LD_INT 5
74849: PUSH
74850: EMPTY
74851: LIST
74852: LIST
74853: PUSH
74854: LD_INT 0
74856: PUSH
74857: LD_INT 5
74859: PUSH
74860: EMPTY
74861: LIST
74862: LIST
74863: PUSH
74864: LD_INT 1
74866: NEG
74867: PUSH
74868: LD_INT 4
74870: PUSH
74871: EMPTY
74872: LIST
74873: LIST
74874: PUSH
74875: LD_INT 1
74877: NEG
74878: PUSH
74879: LD_INT 3
74881: PUSH
74882: EMPTY
74883: LIST
74884: LIST
74885: PUSH
74886: LD_INT 2
74888: PUSH
74889: LD_INT 5
74891: PUSH
74892: EMPTY
74893: LIST
74894: LIST
74895: PUSH
74896: LD_INT 2
74898: NEG
74899: PUSH
74900: LD_INT 3
74902: PUSH
74903: EMPTY
74904: LIST
74905: LIST
74906: PUSH
74907: LD_INT 3
74909: NEG
74910: PUSH
74911: LD_INT 0
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: PUSH
74918: LD_INT 3
74920: NEG
74921: PUSH
74922: LD_INT 1
74924: NEG
74925: PUSH
74926: EMPTY
74927: LIST
74928: LIST
74929: PUSH
74930: LD_INT 2
74932: NEG
74933: PUSH
74934: LD_INT 0
74936: PUSH
74937: EMPTY
74938: LIST
74939: LIST
74940: PUSH
74941: LD_INT 2
74943: NEG
74944: PUSH
74945: LD_INT 1
74947: PUSH
74948: EMPTY
74949: LIST
74950: LIST
74951: PUSH
74952: LD_INT 3
74954: NEG
74955: PUSH
74956: LD_INT 1
74958: PUSH
74959: EMPTY
74960: LIST
74961: LIST
74962: PUSH
74963: LD_INT 4
74965: NEG
74966: PUSH
74967: LD_INT 0
74969: PUSH
74970: EMPTY
74971: LIST
74972: LIST
74973: PUSH
74974: LD_INT 4
74976: NEG
74977: PUSH
74978: LD_INT 1
74980: NEG
74981: PUSH
74982: EMPTY
74983: LIST
74984: LIST
74985: PUSH
74986: LD_INT 4
74988: NEG
74989: PUSH
74990: LD_INT 2
74992: NEG
74993: PUSH
74994: EMPTY
74995: LIST
74996: LIST
74997: PUSH
74998: LD_INT 2
75000: NEG
75001: PUSH
75002: LD_INT 2
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: PUSH
75009: LD_INT 4
75011: NEG
75012: PUSH
75013: LD_INT 4
75015: NEG
75016: PUSH
75017: EMPTY
75018: LIST
75019: LIST
75020: PUSH
75021: LD_INT 4
75023: NEG
75024: PUSH
75025: LD_INT 5
75027: NEG
75028: PUSH
75029: EMPTY
75030: LIST
75031: LIST
75032: PUSH
75033: LD_INT 3
75035: NEG
75036: PUSH
75037: LD_INT 4
75039: NEG
75040: PUSH
75041: EMPTY
75042: LIST
75043: LIST
75044: PUSH
75045: LD_INT 3
75047: NEG
75048: PUSH
75049: LD_INT 3
75051: NEG
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 4
75059: NEG
75060: PUSH
75061: LD_INT 3
75063: NEG
75064: PUSH
75065: EMPTY
75066: LIST
75067: LIST
75068: PUSH
75069: LD_INT 5
75071: NEG
75072: PUSH
75073: LD_INT 4
75075: NEG
75076: PUSH
75077: EMPTY
75078: LIST
75079: LIST
75080: PUSH
75081: LD_INT 5
75083: NEG
75084: PUSH
75085: LD_INT 5
75087: NEG
75088: PUSH
75089: EMPTY
75090: LIST
75091: LIST
75092: PUSH
75093: LD_INT 3
75095: NEG
75096: PUSH
75097: LD_INT 5
75099: NEG
75100: PUSH
75101: EMPTY
75102: LIST
75103: LIST
75104: PUSH
75105: LD_INT 5
75107: NEG
75108: PUSH
75109: LD_INT 3
75111: NEG
75112: PUSH
75113: EMPTY
75114: LIST
75115: LIST
75116: PUSH
75117: LD_INT 0
75119: PUSH
75120: LD_INT 3
75122: NEG
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: PUSH
75128: LD_INT 0
75130: PUSH
75131: LD_INT 4
75133: NEG
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: PUSH
75139: LD_INT 1
75141: PUSH
75142: LD_INT 3
75144: NEG
75145: PUSH
75146: EMPTY
75147: LIST
75148: LIST
75149: PUSH
75150: LD_INT 1
75152: PUSH
75153: LD_INT 2
75155: NEG
75156: PUSH
75157: EMPTY
75158: LIST
75159: LIST
75160: PUSH
75161: LD_INT 0
75163: PUSH
75164: LD_INT 2
75166: NEG
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: PUSH
75172: LD_INT 1
75174: NEG
75175: PUSH
75176: LD_INT 3
75178: NEG
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PUSH
75184: LD_INT 1
75186: NEG
75187: PUSH
75188: LD_INT 4
75190: NEG
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: PUSH
75196: LD_INT 2
75198: PUSH
75199: LD_INT 2
75201: NEG
75202: PUSH
75203: EMPTY
75204: LIST
75205: LIST
75206: PUSH
75207: LD_INT 2
75209: NEG
75210: PUSH
75211: LD_INT 4
75213: NEG
75214: PUSH
75215: EMPTY
75216: LIST
75217: LIST
75218: PUSH
75219: LD_INT 4
75221: PUSH
75222: LD_INT 0
75224: PUSH
75225: EMPTY
75226: LIST
75227: LIST
75228: PUSH
75229: LD_INT 4
75231: PUSH
75232: LD_INT 1
75234: NEG
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PUSH
75240: LD_INT 5
75242: PUSH
75243: LD_INT 0
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PUSH
75250: LD_INT 5
75252: PUSH
75253: LD_INT 1
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PUSH
75260: LD_INT 4
75262: PUSH
75263: LD_INT 1
75265: PUSH
75266: EMPTY
75267: LIST
75268: LIST
75269: PUSH
75270: LD_INT 3
75272: PUSH
75273: LD_INT 0
75275: PUSH
75276: EMPTY
75277: LIST
75278: LIST
75279: PUSH
75280: LD_INT 3
75282: PUSH
75283: LD_INT 1
75285: NEG
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: PUSH
75291: LD_INT 3
75293: PUSH
75294: LD_INT 2
75296: NEG
75297: PUSH
75298: EMPTY
75299: LIST
75300: LIST
75301: PUSH
75302: LD_INT 5
75304: PUSH
75305: LD_INT 2
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PUSH
75312: EMPTY
75313: LIST
75314: LIST
75315: LIST
75316: LIST
75317: LIST
75318: LIST
75319: LIST
75320: LIST
75321: LIST
75322: LIST
75323: LIST
75324: LIST
75325: LIST
75326: LIST
75327: LIST
75328: LIST
75329: LIST
75330: LIST
75331: LIST
75332: LIST
75333: LIST
75334: LIST
75335: LIST
75336: LIST
75337: LIST
75338: LIST
75339: LIST
75340: LIST
75341: LIST
75342: LIST
75343: LIST
75344: LIST
75345: LIST
75346: LIST
75347: LIST
75348: LIST
75349: LIST
75350: LIST
75351: LIST
75352: LIST
75353: LIST
75354: LIST
75355: LIST
75356: LIST
75357: LIST
75358: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
75359: LD_ADDR_VAR 0 32
75363: PUSH
75364: LD_INT 4
75366: NEG
75367: PUSH
75368: LD_INT 0
75370: PUSH
75371: EMPTY
75372: LIST
75373: LIST
75374: PUSH
75375: LD_INT 4
75377: NEG
75378: PUSH
75379: LD_INT 1
75381: NEG
75382: PUSH
75383: EMPTY
75384: LIST
75385: LIST
75386: PUSH
75387: LD_INT 3
75389: NEG
75390: PUSH
75391: LD_INT 0
75393: PUSH
75394: EMPTY
75395: LIST
75396: LIST
75397: PUSH
75398: LD_INT 3
75400: NEG
75401: PUSH
75402: LD_INT 1
75404: PUSH
75405: EMPTY
75406: LIST
75407: LIST
75408: PUSH
75409: LD_INT 4
75411: NEG
75412: PUSH
75413: LD_INT 1
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 5
75422: NEG
75423: PUSH
75424: LD_INT 0
75426: PUSH
75427: EMPTY
75428: LIST
75429: LIST
75430: PUSH
75431: LD_INT 5
75433: NEG
75434: PUSH
75435: LD_INT 1
75437: NEG
75438: PUSH
75439: EMPTY
75440: LIST
75441: LIST
75442: PUSH
75443: LD_INT 5
75445: NEG
75446: PUSH
75447: LD_INT 2
75449: NEG
75450: PUSH
75451: EMPTY
75452: LIST
75453: LIST
75454: PUSH
75455: LD_INT 3
75457: NEG
75458: PUSH
75459: LD_INT 2
75461: PUSH
75462: EMPTY
75463: LIST
75464: LIST
75465: PUSH
75466: LD_INT 3
75468: NEG
75469: PUSH
75470: LD_INT 3
75472: NEG
75473: PUSH
75474: EMPTY
75475: LIST
75476: LIST
75477: PUSH
75478: LD_INT 3
75480: NEG
75481: PUSH
75482: LD_INT 4
75484: NEG
75485: PUSH
75486: EMPTY
75487: LIST
75488: LIST
75489: PUSH
75490: LD_INT 2
75492: NEG
75493: PUSH
75494: LD_INT 3
75496: NEG
75497: PUSH
75498: EMPTY
75499: LIST
75500: LIST
75501: PUSH
75502: LD_INT 2
75504: NEG
75505: PUSH
75506: LD_INT 2
75508: NEG
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: PUSH
75514: LD_INT 3
75516: NEG
75517: PUSH
75518: LD_INT 2
75520: NEG
75521: PUSH
75522: EMPTY
75523: LIST
75524: LIST
75525: PUSH
75526: LD_INT 4
75528: NEG
75529: PUSH
75530: LD_INT 3
75532: NEG
75533: PUSH
75534: EMPTY
75535: LIST
75536: LIST
75537: PUSH
75538: LD_INT 4
75540: NEG
75541: PUSH
75542: LD_INT 4
75544: NEG
75545: PUSH
75546: EMPTY
75547: LIST
75548: LIST
75549: PUSH
75550: LD_INT 2
75552: NEG
75553: PUSH
75554: LD_INT 4
75556: NEG
75557: PUSH
75558: EMPTY
75559: LIST
75560: LIST
75561: PUSH
75562: LD_INT 4
75564: NEG
75565: PUSH
75566: LD_INT 2
75568: NEG
75569: PUSH
75570: EMPTY
75571: LIST
75572: LIST
75573: PUSH
75574: LD_INT 0
75576: PUSH
75577: LD_INT 4
75579: NEG
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: PUSH
75585: LD_INT 0
75587: PUSH
75588: LD_INT 5
75590: NEG
75591: PUSH
75592: EMPTY
75593: LIST
75594: LIST
75595: PUSH
75596: LD_INT 1
75598: PUSH
75599: LD_INT 4
75601: NEG
75602: PUSH
75603: EMPTY
75604: LIST
75605: LIST
75606: PUSH
75607: LD_INT 1
75609: PUSH
75610: LD_INT 3
75612: NEG
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: PUSH
75618: LD_INT 0
75620: PUSH
75621: LD_INT 3
75623: NEG
75624: PUSH
75625: EMPTY
75626: LIST
75627: LIST
75628: PUSH
75629: LD_INT 1
75631: NEG
75632: PUSH
75633: LD_INT 4
75635: NEG
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PUSH
75641: LD_INT 1
75643: NEG
75644: PUSH
75645: LD_INT 5
75647: NEG
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: LD_INT 2
75655: PUSH
75656: LD_INT 3
75658: NEG
75659: PUSH
75660: EMPTY
75661: LIST
75662: LIST
75663: PUSH
75664: LD_INT 2
75666: NEG
75667: PUSH
75668: LD_INT 5
75670: NEG
75671: PUSH
75672: EMPTY
75673: LIST
75674: LIST
75675: PUSH
75676: LD_INT 3
75678: PUSH
75679: LD_INT 0
75681: PUSH
75682: EMPTY
75683: LIST
75684: LIST
75685: PUSH
75686: LD_INT 3
75688: PUSH
75689: LD_INT 1
75691: NEG
75692: PUSH
75693: EMPTY
75694: LIST
75695: LIST
75696: PUSH
75697: LD_INT 4
75699: PUSH
75700: LD_INT 0
75702: PUSH
75703: EMPTY
75704: LIST
75705: LIST
75706: PUSH
75707: LD_INT 4
75709: PUSH
75710: LD_INT 1
75712: PUSH
75713: EMPTY
75714: LIST
75715: LIST
75716: PUSH
75717: LD_INT 3
75719: PUSH
75720: LD_INT 1
75722: PUSH
75723: EMPTY
75724: LIST
75725: LIST
75726: PUSH
75727: LD_INT 2
75729: PUSH
75730: LD_INT 0
75732: PUSH
75733: EMPTY
75734: LIST
75735: LIST
75736: PUSH
75737: LD_INT 2
75739: PUSH
75740: LD_INT 1
75742: NEG
75743: PUSH
75744: EMPTY
75745: LIST
75746: LIST
75747: PUSH
75748: LD_INT 2
75750: PUSH
75751: LD_INT 2
75753: NEG
75754: PUSH
75755: EMPTY
75756: LIST
75757: LIST
75758: PUSH
75759: LD_INT 4
75761: PUSH
75762: LD_INT 2
75764: PUSH
75765: EMPTY
75766: LIST
75767: LIST
75768: PUSH
75769: LD_INT 4
75771: PUSH
75772: LD_INT 4
75774: PUSH
75775: EMPTY
75776: LIST
75777: LIST
75778: PUSH
75779: LD_INT 4
75781: PUSH
75782: LD_INT 3
75784: PUSH
75785: EMPTY
75786: LIST
75787: LIST
75788: PUSH
75789: LD_INT 5
75791: PUSH
75792: LD_INT 4
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: PUSH
75799: LD_INT 5
75801: PUSH
75802: LD_INT 5
75804: PUSH
75805: EMPTY
75806: LIST
75807: LIST
75808: PUSH
75809: LD_INT 4
75811: PUSH
75812: LD_INT 5
75814: PUSH
75815: EMPTY
75816: LIST
75817: LIST
75818: PUSH
75819: LD_INT 3
75821: PUSH
75822: LD_INT 4
75824: PUSH
75825: EMPTY
75826: LIST
75827: LIST
75828: PUSH
75829: LD_INT 3
75831: PUSH
75832: LD_INT 3
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: PUSH
75839: LD_INT 5
75841: PUSH
75842: LD_INT 3
75844: PUSH
75845: EMPTY
75846: LIST
75847: LIST
75848: PUSH
75849: LD_INT 3
75851: PUSH
75852: LD_INT 5
75854: PUSH
75855: EMPTY
75856: LIST
75857: LIST
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: LIST
75863: LIST
75864: LIST
75865: LIST
75866: LIST
75867: LIST
75868: LIST
75869: LIST
75870: LIST
75871: LIST
75872: LIST
75873: LIST
75874: LIST
75875: LIST
75876: LIST
75877: LIST
75878: LIST
75879: LIST
75880: LIST
75881: LIST
75882: LIST
75883: LIST
75884: LIST
75885: LIST
75886: LIST
75887: LIST
75888: LIST
75889: LIST
75890: LIST
75891: LIST
75892: LIST
75893: LIST
75894: LIST
75895: LIST
75896: LIST
75897: LIST
75898: LIST
75899: LIST
75900: LIST
75901: LIST
75902: LIST
75903: LIST
75904: LIST
75905: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
75906: LD_ADDR_VAR 0 33
75910: PUSH
75911: LD_INT 4
75913: NEG
75914: PUSH
75915: LD_INT 4
75917: NEG
75918: PUSH
75919: EMPTY
75920: LIST
75921: LIST
75922: PUSH
75923: LD_INT 4
75925: NEG
75926: PUSH
75927: LD_INT 5
75929: NEG
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: LD_INT 3
75937: NEG
75938: PUSH
75939: LD_INT 4
75941: NEG
75942: PUSH
75943: EMPTY
75944: LIST
75945: LIST
75946: PUSH
75947: LD_INT 3
75949: NEG
75950: PUSH
75951: LD_INT 3
75953: NEG
75954: PUSH
75955: EMPTY
75956: LIST
75957: LIST
75958: PUSH
75959: LD_INT 4
75961: NEG
75962: PUSH
75963: LD_INT 3
75965: NEG
75966: PUSH
75967: EMPTY
75968: LIST
75969: LIST
75970: PUSH
75971: LD_INT 5
75973: NEG
75974: PUSH
75975: LD_INT 4
75977: NEG
75978: PUSH
75979: EMPTY
75980: LIST
75981: LIST
75982: PUSH
75983: LD_INT 5
75985: NEG
75986: PUSH
75987: LD_INT 5
75989: NEG
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: PUSH
75995: LD_INT 3
75997: NEG
75998: PUSH
75999: LD_INT 5
76001: NEG
76002: PUSH
76003: EMPTY
76004: LIST
76005: LIST
76006: PUSH
76007: LD_INT 5
76009: NEG
76010: PUSH
76011: LD_INT 3
76013: NEG
76014: PUSH
76015: EMPTY
76016: LIST
76017: LIST
76018: PUSH
76019: LD_INT 0
76021: PUSH
76022: LD_INT 3
76024: NEG
76025: PUSH
76026: EMPTY
76027: LIST
76028: LIST
76029: PUSH
76030: LD_INT 0
76032: PUSH
76033: LD_INT 4
76035: NEG
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: PUSH
76041: LD_INT 1
76043: PUSH
76044: LD_INT 3
76046: NEG
76047: PUSH
76048: EMPTY
76049: LIST
76050: LIST
76051: PUSH
76052: LD_INT 1
76054: PUSH
76055: LD_INT 2
76057: NEG
76058: PUSH
76059: EMPTY
76060: LIST
76061: LIST
76062: PUSH
76063: LD_INT 0
76065: PUSH
76066: LD_INT 2
76068: NEG
76069: PUSH
76070: EMPTY
76071: LIST
76072: LIST
76073: PUSH
76074: LD_INT 1
76076: NEG
76077: PUSH
76078: LD_INT 3
76080: NEG
76081: PUSH
76082: EMPTY
76083: LIST
76084: LIST
76085: PUSH
76086: LD_INT 1
76088: NEG
76089: PUSH
76090: LD_INT 4
76092: NEG
76093: PUSH
76094: EMPTY
76095: LIST
76096: LIST
76097: PUSH
76098: LD_INT 2
76100: PUSH
76101: LD_INT 2
76103: NEG
76104: PUSH
76105: EMPTY
76106: LIST
76107: LIST
76108: PUSH
76109: LD_INT 2
76111: NEG
76112: PUSH
76113: LD_INT 4
76115: NEG
76116: PUSH
76117: EMPTY
76118: LIST
76119: LIST
76120: PUSH
76121: LD_INT 4
76123: PUSH
76124: LD_INT 0
76126: PUSH
76127: EMPTY
76128: LIST
76129: LIST
76130: PUSH
76131: LD_INT 4
76133: PUSH
76134: LD_INT 1
76136: NEG
76137: PUSH
76138: EMPTY
76139: LIST
76140: LIST
76141: PUSH
76142: LD_INT 5
76144: PUSH
76145: LD_INT 0
76147: PUSH
76148: EMPTY
76149: LIST
76150: LIST
76151: PUSH
76152: LD_INT 5
76154: PUSH
76155: LD_INT 1
76157: PUSH
76158: EMPTY
76159: LIST
76160: LIST
76161: PUSH
76162: LD_INT 4
76164: PUSH
76165: LD_INT 1
76167: PUSH
76168: EMPTY
76169: LIST
76170: LIST
76171: PUSH
76172: LD_INT 3
76174: PUSH
76175: LD_INT 0
76177: PUSH
76178: EMPTY
76179: LIST
76180: LIST
76181: PUSH
76182: LD_INT 3
76184: PUSH
76185: LD_INT 1
76187: NEG
76188: PUSH
76189: EMPTY
76190: LIST
76191: LIST
76192: PUSH
76193: LD_INT 3
76195: PUSH
76196: LD_INT 2
76198: NEG
76199: PUSH
76200: EMPTY
76201: LIST
76202: LIST
76203: PUSH
76204: LD_INT 5
76206: PUSH
76207: LD_INT 2
76209: PUSH
76210: EMPTY
76211: LIST
76212: LIST
76213: PUSH
76214: LD_INT 3
76216: PUSH
76217: LD_INT 3
76219: PUSH
76220: EMPTY
76221: LIST
76222: LIST
76223: PUSH
76224: LD_INT 3
76226: PUSH
76227: LD_INT 2
76229: PUSH
76230: EMPTY
76231: LIST
76232: LIST
76233: PUSH
76234: LD_INT 4
76236: PUSH
76237: LD_INT 3
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: PUSH
76244: LD_INT 4
76246: PUSH
76247: LD_INT 4
76249: PUSH
76250: EMPTY
76251: LIST
76252: LIST
76253: PUSH
76254: LD_INT 3
76256: PUSH
76257: LD_INT 4
76259: PUSH
76260: EMPTY
76261: LIST
76262: LIST
76263: PUSH
76264: LD_INT 2
76266: PUSH
76267: LD_INT 3
76269: PUSH
76270: EMPTY
76271: LIST
76272: LIST
76273: PUSH
76274: LD_INT 2
76276: PUSH
76277: LD_INT 2
76279: PUSH
76280: EMPTY
76281: LIST
76282: LIST
76283: PUSH
76284: LD_INT 4
76286: PUSH
76287: LD_INT 2
76289: PUSH
76290: EMPTY
76291: LIST
76292: LIST
76293: PUSH
76294: LD_INT 2
76296: PUSH
76297: LD_INT 4
76299: PUSH
76300: EMPTY
76301: LIST
76302: LIST
76303: PUSH
76304: LD_INT 0
76306: PUSH
76307: LD_INT 4
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: PUSH
76314: LD_INT 0
76316: PUSH
76317: LD_INT 3
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: PUSH
76324: LD_INT 1
76326: PUSH
76327: LD_INT 4
76329: PUSH
76330: EMPTY
76331: LIST
76332: LIST
76333: PUSH
76334: LD_INT 1
76336: PUSH
76337: LD_INT 5
76339: PUSH
76340: EMPTY
76341: LIST
76342: LIST
76343: PUSH
76344: LD_INT 0
76346: PUSH
76347: LD_INT 5
76349: PUSH
76350: EMPTY
76351: LIST
76352: LIST
76353: PUSH
76354: LD_INT 1
76356: NEG
76357: PUSH
76358: LD_INT 4
76360: PUSH
76361: EMPTY
76362: LIST
76363: LIST
76364: PUSH
76365: LD_INT 1
76367: NEG
76368: PUSH
76369: LD_INT 3
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: PUSH
76376: LD_INT 2
76378: PUSH
76379: LD_INT 5
76381: PUSH
76382: EMPTY
76383: LIST
76384: LIST
76385: PUSH
76386: LD_INT 2
76388: NEG
76389: PUSH
76390: LD_INT 3
76392: PUSH
76393: EMPTY
76394: LIST
76395: LIST
76396: PUSH
76397: EMPTY
76398: LIST
76399: LIST
76400: LIST
76401: LIST
76402: LIST
76403: LIST
76404: LIST
76405: LIST
76406: LIST
76407: LIST
76408: LIST
76409: LIST
76410: LIST
76411: LIST
76412: LIST
76413: LIST
76414: LIST
76415: LIST
76416: LIST
76417: LIST
76418: LIST
76419: LIST
76420: LIST
76421: LIST
76422: LIST
76423: LIST
76424: LIST
76425: LIST
76426: LIST
76427: LIST
76428: LIST
76429: LIST
76430: LIST
76431: LIST
76432: LIST
76433: LIST
76434: LIST
76435: LIST
76436: LIST
76437: LIST
76438: LIST
76439: LIST
76440: LIST
76441: LIST
76442: LIST
76443: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
76444: LD_ADDR_VAR 0 34
76448: PUSH
76449: LD_INT 0
76451: PUSH
76452: LD_INT 4
76454: NEG
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 0
76462: PUSH
76463: LD_INT 5
76465: NEG
76466: PUSH
76467: EMPTY
76468: LIST
76469: LIST
76470: PUSH
76471: LD_INT 1
76473: PUSH
76474: LD_INT 4
76476: NEG
76477: PUSH
76478: EMPTY
76479: LIST
76480: LIST
76481: PUSH
76482: LD_INT 1
76484: PUSH
76485: LD_INT 3
76487: NEG
76488: PUSH
76489: EMPTY
76490: LIST
76491: LIST
76492: PUSH
76493: LD_INT 0
76495: PUSH
76496: LD_INT 3
76498: NEG
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: PUSH
76504: LD_INT 1
76506: NEG
76507: PUSH
76508: LD_INT 4
76510: NEG
76511: PUSH
76512: EMPTY
76513: LIST
76514: LIST
76515: PUSH
76516: LD_INT 1
76518: NEG
76519: PUSH
76520: LD_INT 5
76522: NEG
76523: PUSH
76524: EMPTY
76525: LIST
76526: LIST
76527: PUSH
76528: LD_INT 2
76530: PUSH
76531: LD_INT 3
76533: NEG
76534: PUSH
76535: EMPTY
76536: LIST
76537: LIST
76538: PUSH
76539: LD_INT 2
76541: NEG
76542: PUSH
76543: LD_INT 5
76545: NEG
76546: PUSH
76547: EMPTY
76548: LIST
76549: LIST
76550: PUSH
76551: LD_INT 3
76553: PUSH
76554: LD_INT 0
76556: PUSH
76557: EMPTY
76558: LIST
76559: LIST
76560: PUSH
76561: LD_INT 3
76563: PUSH
76564: LD_INT 1
76566: NEG
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: PUSH
76572: LD_INT 4
76574: PUSH
76575: LD_INT 0
76577: PUSH
76578: EMPTY
76579: LIST
76580: LIST
76581: PUSH
76582: LD_INT 4
76584: PUSH
76585: LD_INT 1
76587: PUSH
76588: EMPTY
76589: LIST
76590: LIST
76591: PUSH
76592: LD_INT 3
76594: PUSH
76595: LD_INT 1
76597: PUSH
76598: EMPTY
76599: LIST
76600: LIST
76601: PUSH
76602: LD_INT 2
76604: PUSH
76605: LD_INT 0
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: PUSH
76612: LD_INT 2
76614: PUSH
76615: LD_INT 1
76617: NEG
76618: PUSH
76619: EMPTY
76620: LIST
76621: LIST
76622: PUSH
76623: LD_INT 2
76625: PUSH
76626: LD_INT 2
76628: NEG
76629: PUSH
76630: EMPTY
76631: LIST
76632: LIST
76633: PUSH
76634: LD_INT 4
76636: PUSH
76637: LD_INT 2
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: PUSH
76644: LD_INT 4
76646: PUSH
76647: LD_INT 4
76649: PUSH
76650: EMPTY
76651: LIST
76652: LIST
76653: PUSH
76654: LD_INT 4
76656: PUSH
76657: LD_INT 3
76659: PUSH
76660: EMPTY
76661: LIST
76662: LIST
76663: PUSH
76664: LD_INT 5
76666: PUSH
76667: LD_INT 4
76669: PUSH
76670: EMPTY
76671: LIST
76672: LIST
76673: PUSH
76674: LD_INT 5
76676: PUSH
76677: LD_INT 5
76679: PUSH
76680: EMPTY
76681: LIST
76682: LIST
76683: PUSH
76684: LD_INT 4
76686: PUSH
76687: LD_INT 5
76689: PUSH
76690: EMPTY
76691: LIST
76692: LIST
76693: PUSH
76694: LD_INT 3
76696: PUSH
76697: LD_INT 4
76699: PUSH
76700: EMPTY
76701: LIST
76702: LIST
76703: PUSH
76704: LD_INT 3
76706: PUSH
76707: LD_INT 3
76709: PUSH
76710: EMPTY
76711: LIST
76712: LIST
76713: PUSH
76714: LD_INT 5
76716: PUSH
76717: LD_INT 3
76719: PUSH
76720: EMPTY
76721: LIST
76722: LIST
76723: PUSH
76724: LD_INT 3
76726: PUSH
76727: LD_INT 5
76729: PUSH
76730: EMPTY
76731: LIST
76732: LIST
76733: PUSH
76734: LD_INT 0
76736: PUSH
76737: LD_INT 3
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: LD_INT 0
76746: PUSH
76747: LD_INT 2
76749: PUSH
76750: EMPTY
76751: LIST
76752: LIST
76753: PUSH
76754: LD_INT 1
76756: PUSH
76757: LD_INT 3
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: PUSH
76764: LD_INT 1
76766: PUSH
76767: LD_INT 4
76769: PUSH
76770: EMPTY
76771: LIST
76772: LIST
76773: PUSH
76774: LD_INT 0
76776: PUSH
76777: LD_INT 4
76779: PUSH
76780: EMPTY
76781: LIST
76782: LIST
76783: PUSH
76784: LD_INT 1
76786: NEG
76787: PUSH
76788: LD_INT 3
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: PUSH
76795: LD_INT 1
76797: NEG
76798: PUSH
76799: LD_INT 2
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: PUSH
76806: LD_INT 2
76808: PUSH
76809: LD_INT 4
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PUSH
76816: LD_INT 2
76818: NEG
76819: PUSH
76820: LD_INT 2
76822: PUSH
76823: EMPTY
76824: LIST
76825: LIST
76826: PUSH
76827: LD_INT 4
76829: NEG
76830: PUSH
76831: LD_INT 0
76833: PUSH
76834: EMPTY
76835: LIST
76836: LIST
76837: PUSH
76838: LD_INT 4
76840: NEG
76841: PUSH
76842: LD_INT 1
76844: NEG
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: PUSH
76850: LD_INT 3
76852: NEG
76853: PUSH
76854: LD_INT 0
76856: PUSH
76857: EMPTY
76858: LIST
76859: LIST
76860: PUSH
76861: LD_INT 3
76863: NEG
76864: PUSH
76865: LD_INT 1
76867: PUSH
76868: EMPTY
76869: LIST
76870: LIST
76871: PUSH
76872: LD_INT 4
76874: NEG
76875: PUSH
76876: LD_INT 1
76878: PUSH
76879: EMPTY
76880: LIST
76881: LIST
76882: PUSH
76883: LD_INT 5
76885: NEG
76886: PUSH
76887: LD_INT 0
76889: PUSH
76890: EMPTY
76891: LIST
76892: LIST
76893: PUSH
76894: LD_INT 5
76896: NEG
76897: PUSH
76898: LD_INT 1
76900: NEG
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: PUSH
76906: LD_INT 5
76908: NEG
76909: PUSH
76910: LD_INT 2
76912: NEG
76913: PUSH
76914: EMPTY
76915: LIST
76916: LIST
76917: PUSH
76918: LD_INT 3
76920: NEG
76921: PUSH
76922: LD_INT 2
76924: PUSH
76925: EMPTY
76926: LIST
76927: LIST
76928: PUSH
76929: EMPTY
76930: LIST
76931: LIST
76932: LIST
76933: LIST
76934: LIST
76935: LIST
76936: LIST
76937: LIST
76938: LIST
76939: LIST
76940: LIST
76941: LIST
76942: LIST
76943: LIST
76944: LIST
76945: LIST
76946: LIST
76947: LIST
76948: LIST
76949: LIST
76950: LIST
76951: LIST
76952: LIST
76953: LIST
76954: LIST
76955: LIST
76956: LIST
76957: LIST
76958: LIST
76959: LIST
76960: LIST
76961: LIST
76962: LIST
76963: LIST
76964: LIST
76965: LIST
76966: LIST
76967: LIST
76968: LIST
76969: LIST
76970: LIST
76971: LIST
76972: LIST
76973: LIST
76974: LIST
76975: ST_TO_ADDR
// end ; end ;
76976: GO 76979
76978: POP
// case btype of b_depot , b_warehouse :
76979: LD_VAR 0 1
76983: PUSH
76984: LD_INT 0
76986: DOUBLE
76987: EQUAL
76988: IFTRUE 76998
76990: LD_INT 1
76992: DOUBLE
76993: EQUAL
76994: IFTRUE 76998
76996: GO 77199
76998: POP
// case nation of nation_american :
76999: LD_VAR 0 5
77003: PUSH
77004: LD_INT 1
77006: DOUBLE
77007: EQUAL
77008: IFTRUE 77012
77010: GO 77068
77012: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
77013: LD_ADDR_VAR 0 9
77017: PUSH
77018: LD_VAR 0 11
77022: PUSH
77023: LD_VAR 0 12
77027: PUSH
77028: LD_VAR 0 13
77032: PUSH
77033: LD_VAR 0 14
77037: PUSH
77038: LD_VAR 0 15
77042: PUSH
77043: LD_VAR 0 16
77047: PUSH
77048: EMPTY
77049: LIST
77050: LIST
77051: LIST
77052: LIST
77053: LIST
77054: LIST
77055: PUSH
77056: LD_VAR 0 4
77060: PUSH
77061: LD_INT 1
77063: PLUS
77064: ARRAY
77065: ST_TO_ADDR
77066: GO 77197
77068: LD_INT 2
77070: DOUBLE
77071: EQUAL
77072: IFTRUE 77076
77074: GO 77132
77076: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
77077: LD_ADDR_VAR 0 9
77081: PUSH
77082: LD_VAR 0 17
77086: PUSH
77087: LD_VAR 0 18
77091: PUSH
77092: LD_VAR 0 19
77096: PUSH
77097: LD_VAR 0 20
77101: PUSH
77102: LD_VAR 0 21
77106: PUSH
77107: LD_VAR 0 22
77111: PUSH
77112: EMPTY
77113: LIST
77114: LIST
77115: LIST
77116: LIST
77117: LIST
77118: LIST
77119: PUSH
77120: LD_VAR 0 4
77124: PUSH
77125: LD_INT 1
77127: PLUS
77128: ARRAY
77129: ST_TO_ADDR
77130: GO 77197
77132: LD_INT 3
77134: DOUBLE
77135: EQUAL
77136: IFTRUE 77140
77138: GO 77196
77140: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
77141: LD_ADDR_VAR 0 9
77145: PUSH
77146: LD_VAR 0 23
77150: PUSH
77151: LD_VAR 0 24
77155: PUSH
77156: LD_VAR 0 25
77160: PUSH
77161: LD_VAR 0 26
77165: PUSH
77166: LD_VAR 0 27
77170: PUSH
77171: LD_VAR 0 28
77175: PUSH
77176: EMPTY
77177: LIST
77178: LIST
77179: LIST
77180: LIST
77181: LIST
77182: LIST
77183: PUSH
77184: LD_VAR 0 4
77188: PUSH
77189: LD_INT 1
77191: PLUS
77192: ARRAY
77193: ST_TO_ADDR
77194: GO 77197
77196: POP
77197: GO 77746
77199: LD_INT 2
77201: DOUBLE
77202: EQUAL
77203: IFTRUE 77213
77205: LD_INT 3
77207: DOUBLE
77208: EQUAL
77209: IFTRUE 77213
77211: GO 77269
77213: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
77214: LD_ADDR_VAR 0 9
77218: PUSH
77219: LD_VAR 0 29
77223: PUSH
77224: LD_VAR 0 30
77228: PUSH
77229: LD_VAR 0 31
77233: PUSH
77234: LD_VAR 0 32
77238: PUSH
77239: LD_VAR 0 33
77243: PUSH
77244: LD_VAR 0 34
77248: PUSH
77249: EMPTY
77250: LIST
77251: LIST
77252: LIST
77253: LIST
77254: LIST
77255: LIST
77256: PUSH
77257: LD_VAR 0 4
77261: PUSH
77262: LD_INT 1
77264: PLUS
77265: ARRAY
77266: ST_TO_ADDR
77267: GO 77746
77269: LD_INT 16
77271: DOUBLE
77272: EQUAL
77273: IFTRUE 77325
77275: LD_INT 17
77277: DOUBLE
77278: EQUAL
77279: IFTRUE 77325
77281: LD_INT 18
77283: DOUBLE
77284: EQUAL
77285: IFTRUE 77325
77287: LD_INT 19
77289: DOUBLE
77290: EQUAL
77291: IFTRUE 77325
77293: LD_INT 20
77295: DOUBLE
77296: EQUAL
77297: IFTRUE 77325
77299: LD_INT 21
77301: DOUBLE
77302: EQUAL
77303: IFTRUE 77325
77305: LD_INT 23
77307: DOUBLE
77308: EQUAL
77309: IFTRUE 77325
77311: LD_INT 24
77313: DOUBLE
77314: EQUAL
77315: IFTRUE 77325
77317: LD_INT 25
77319: DOUBLE
77320: EQUAL
77321: IFTRUE 77325
77323: GO 77381
77325: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
77326: LD_ADDR_VAR 0 9
77330: PUSH
77331: LD_VAR 0 35
77335: PUSH
77336: LD_VAR 0 36
77340: PUSH
77341: LD_VAR 0 37
77345: PUSH
77346: LD_VAR 0 38
77350: PUSH
77351: LD_VAR 0 39
77355: PUSH
77356: LD_VAR 0 40
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: LIST
77365: LIST
77366: LIST
77367: LIST
77368: PUSH
77369: LD_VAR 0 4
77373: PUSH
77374: LD_INT 1
77376: PLUS
77377: ARRAY
77378: ST_TO_ADDR
77379: GO 77746
77381: LD_INT 6
77383: DOUBLE
77384: EQUAL
77385: IFTRUE 77437
77387: LD_INT 7
77389: DOUBLE
77390: EQUAL
77391: IFTRUE 77437
77393: LD_INT 8
77395: DOUBLE
77396: EQUAL
77397: IFTRUE 77437
77399: LD_INT 13
77401: DOUBLE
77402: EQUAL
77403: IFTRUE 77437
77405: LD_INT 12
77407: DOUBLE
77408: EQUAL
77409: IFTRUE 77437
77411: LD_INT 15
77413: DOUBLE
77414: EQUAL
77415: IFTRUE 77437
77417: LD_INT 11
77419: DOUBLE
77420: EQUAL
77421: IFTRUE 77437
77423: LD_INT 14
77425: DOUBLE
77426: EQUAL
77427: IFTRUE 77437
77429: LD_INT 10
77431: DOUBLE
77432: EQUAL
77433: IFTRUE 77437
77435: GO 77493
77437: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
77438: LD_ADDR_VAR 0 9
77442: PUSH
77443: LD_VAR 0 41
77447: PUSH
77448: LD_VAR 0 42
77452: PUSH
77453: LD_VAR 0 43
77457: PUSH
77458: LD_VAR 0 44
77462: PUSH
77463: LD_VAR 0 45
77467: PUSH
77468: LD_VAR 0 46
77472: PUSH
77473: EMPTY
77474: LIST
77475: LIST
77476: LIST
77477: LIST
77478: LIST
77479: LIST
77480: PUSH
77481: LD_VAR 0 4
77485: PUSH
77486: LD_INT 1
77488: PLUS
77489: ARRAY
77490: ST_TO_ADDR
77491: GO 77746
77493: LD_INT 36
77495: DOUBLE
77496: EQUAL
77497: IFTRUE 77501
77499: GO 77557
77501: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
77502: LD_ADDR_VAR 0 9
77506: PUSH
77507: LD_VAR 0 47
77511: PUSH
77512: LD_VAR 0 48
77516: PUSH
77517: LD_VAR 0 49
77521: PUSH
77522: LD_VAR 0 50
77526: PUSH
77527: LD_VAR 0 51
77531: PUSH
77532: LD_VAR 0 52
77536: PUSH
77537: EMPTY
77538: LIST
77539: LIST
77540: LIST
77541: LIST
77542: LIST
77543: LIST
77544: PUSH
77545: LD_VAR 0 4
77549: PUSH
77550: LD_INT 1
77552: PLUS
77553: ARRAY
77554: ST_TO_ADDR
77555: GO 77746
77557: LD_INT 4
77559: DOUBLE
77560: EQUAL
77561: IFTRUE 77583
77563: LD_INT 5
77565: DOUBLE
77566: EQUAL
77567: IFTRUE 77583
77569: LD_INT 34
77571: DOUBLE
77572: EQUAL
77573: IFTRUE 77583
77575: LD_INT 37
77577: DOUBLE
77578: EQUAL
77579: IFTRUE 77583
77581: GO 77639
77583: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
77584: LD_ADDR_VAR 0 9
77588: PUSH
77589: LD_VAR 0 53
77593: PUSH
77594: LD_VAR 0 54
77598: PUSH
77599: LD_VAR 0 55
77603: PUSH
77604: LD_VAR 0 56
77608: PUSH
77609: LD_VAR 0 57
77613: PUSH
77614: LD_VAR 0 58
77618: PUSH
77619: EMPTY
77620: LIST
77621: LIST
77622: LIST
77623: LIST
77624: LIST
77625: LIST
77626: PUSH
77627: LD_VAR 0 4
77631: PUSH
77632: LD_INT 1
77634: PLUS
77635: ARRAY
77636: ST_TO_ADDR
77637: GO 77746
77639: LD_INT 31
77641: DOUBLE
77642: EQUAL
77643: IFTRUE 77689
77645: LD_INT 32
77647: DOUBLE
77648: EQUAL
77649: IFTRUE 77689
77651: LD_INT 33
77653: DOUBLE
77654: EQUAL
77655: IFTRUE 77689
77657: LD_INT 27
77659: DOUBLE
77660: EQUAL
77661: IFTRUE 77689
77663: LD_INT 26
77665: DOUBLE
77666: EQUAL
77667: IFTRUE 77689
77669: LD_INT 28
77671: DOUBLE
77672: EQUAL
77673: IFTRUE 77689
77675: LD_INT 29
77677: DOUBLE
77678: EQUAL
77679: IFTRUE 77689
77681: LD_INT 30
77683: DOUBLE
77684: EQUAL
77685: IFTRUE 77689
77687: GO 77745
77689: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
77690: LD_ADDR_VAR 0 9
77694: PUSH
77695: LD_VAR 0 59
77699: PUSH
77700: LD_VAR 0 60
77704: PUSH
77705: LD_VAR 0 61
77709: PUSH
77710: LD_VAR 0 62
77714: PUSH
77715: LD_VAR 0 63
77719: PUSH
77720: LD_VAR 0 64
77724: PUSH
77725: EMPTY
77726: LIST
77727: LIST
77728: LIST
77729: LIST
77730: LIST
77731: LIST
77732: PUSH
77733: LD_VAR 0 4
77737: PUSH
77738: LD_INT 1
77740: PLUS
77741: ARRAY
77742: ST_TO_ADDR
77743: GO 77746
77745: POP
// temp_list2 = [ ] ;
77746: LD_ADDR_VAR 0 10
77750: PUSH
77751: EMPTY
77752: ST_TO_ADDR
// for i in temp_list do
77753: LD_ADDR_VAR 0 8
77757: PUSH
77758: LD_VAR 0 9
77762: PUSH
77763: FOR_IN
77764: IFFALSE 77816
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
77766: LD_ADDR_VAR 0 10
77770: PUSH
77771: LD_VAR 0 10
77775: PUSH
77776: LD_VAR 0 8
77780: PUSH
77781: LD_INT 1
77783: ARRAY
77784: PUSH
77785: LD_VAR 0 2
77789: PLUS
77790: PUSH
77791: LD_VAR 0 8
77795: PUSH
77796: LD_INT 2
77798: ARRAY
77799: PUSH
77800: LD_VAR 0 3
77804: PLUS
77805: PUSH
77806: EMPTY
77807: LIST
77808: LIST
77809: PUSH
77810: EMPTY
77811: LIST
77812: ADD
77813: ST_TO_ADDR
77814: GO 77763
77816: POP
77817: POP
// result = temp_list2 ;
77818: LD_ADDR_VAR 0 7
77822: PUSH
77823: LD_VAR 0 10
77827: ST_TO_ADDR
// end ;
77828: LD_VAR 0 7
77832: RET
// export function EnemyInRange ( unit , dist ) ; begin
77833: LD_INT 0
77835: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
77836: LD_ADDR_VAR 0 3
77840: PUSH
77841: LD_VAR 0 1
77845: PPUSH
77846: CALL_OW 255
77850: PPUSH
77851: LD_VAR 0 1
77855: PPUSH
77856: CALL_OW 250
77860: PPUSH
77861: LD_VAR 0 1
77865: PPUSH
77866: CALL_OW 251
77870: PPUSH
77871: LD_VAR 0 2
77875: PPUSH
77876: CALL 51961 0 4
77880: PUSH
77881: LD_INT 4
77883: ARRAY
77884: ST_TO_ADDR
// end ;
77885: LD_VAR 0 3
77889: RET
// export function PlayerSeeMe ( unit ) ; begin
77890: LD_INT 0
77892: PPUSH
// result := See ( your_side , unit ) ;
77893: LD_ADDR_VAR 0 2
77897: PUSH
77898: LD_OWVAR 2
77902: PPUSH
77903: LD_VAR 0 1
77907: PPUSH
77908: CALL_OW 292
77912: ST_TO_ADDR
// end ;
77913: LD_VAR 0 2
77917: RET
// export function ReverseDir ( unit ) ; begin
77918: LD_INT 0
77920: PPUSH
// if not unit then
77921: LD_VAR 0 1
77925: NOT
77926: IFFALSE 77930
// exit ;
77928: GO 77976
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
77930: LD_ADDR_VAR 0 2
77934: PUSH
77935: LD_INT 3
77937: PUSH
77938: LD_INT 4
77940: PUSH
77941: LD_INT 5
77943: PUSH
77944: LD_INT 0
77946: PUSH
77947: LD_INT 1
77949: PUSH
77950: LD_INT 2
77952: PUSH
77953: EMPTY
77954: LIST
77955: LIST
77956: LIST
77957: LIST
77958: LIST
77959: LIST
77960: PUSH
77961: LD_VAR 0 1
77965: PPUSH
77966: CALL_OW 254
77970: PUSH
77971: LD_INT 1
77973: PLUS
77974: ARRAY
77975: ST_TO_ADDR
// end ;
77976: LD_VAR 0 2
77980: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
77981: LD_INT 0
77983: PPUSH
77984: PPUSH
77985: PPUSH
77986: PPUSH
77987: PPUSH
// if not hexes then
77988: LD_VAR 0 2
77992: NOT
77993: IFFALSE 77997
// exit ;
77995: GO 78145
// dist := 9999 ;
77997: LD_ADDR_VAR 0 5
78001: PUSH
78002: LD_INT 9999
78004: ST_TO_ADDR
// for i = 1 to hexes do
78005: LD_ADDR_VAR 0 4
78009: PUSH
78010: DOUBLE
78011: LD_INT 1
78013: DEC
78014: ST_TO_ADDR
78015: LD_VAR 0 2
78019: PUSH
78020: FOR_TO
78021: IFFALSE 78133
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
78023: LD_VAR 0 1
78027: PPUSH
78028: LD_VAR 0 2
78032: PUSH
78033: LD_VAR 0 4
78037: ARRAY
78038: PUSH
78039: LD_INT 1
78041: ARRAY
78042: PPUSH
78043: LD_VAR 0 2
78047: PUSH
78048: LD_VAR 0 4
78052: ARRAY
78053: PUSH
78054: LD_INT 2
78056: ARRAY
78057: PPUSH
78058: CALL_OW 297
78062: PUSH
78063: LD_VAR 0 5
78067: LESS
78068: IFFALSE 78131
// begin hex := hexes [ i ] ;
78070: LD_ADDR_VAR 0 7
78074: PUSH
78075: LD_VAR 0 2
78079: PUSH
78080: LD_VAR 0 4
78084: ARRAY
78085: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78086: LD_ADDR_VAR 0 5
78090: PUSH
78091: LD_VAR 0 1
78095: PPUSH
78096: LD_VAR 0 2
78100: PUSH
78101: LD_VAR 0 4
78105: ARRAY
78106: PUSH
78107: LD_INT 1
78109: ARRAY
78110: PPUSH
78111: LD_VAR 0 2
78115: PUSH
78116: LD_VAR 0 4
78120: ARRAY
78121: PUSH
78122: LD_INT 2
78124: ARRAY
78125: PPUSH
78126: CALL_OW 297
78130: ST_TO_ADDR
// end ; end ;
78131: GO 78020
78133: POP
78134: POP
// result := hex ;
78135: LD_ADDR_VAR 0 3
78139: PUSH
78140: LD_VAR 0 7
78144: ST_TO_ADDR
// end ;
78145: LD_VAR 0 3
78149: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
78150: LD_INT 0
78152: PPUSH
78153: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
78154: LD_VAR 0 1
78158: NOT
78159: PUSH
78160: LD_VAR 0 1
78164: PUSH
78165: LD_INT 21
78167: PUSH
78168: LD_INT 2
78170: PUSH
78171: EMPTY
78172: LIST
78173: LIST
78174: PUSH
78175: LD_INT 23
78177: PUSH
78178: LD_INT 2
78180: PUSH
78181: EMPTY
78182: LIST
78183: LIST
78184: PUSH
78185: EMPTY
78186: LIST
78187: LIST
78188: PPUSH
78189: CALL_OW 69
78193: IN
78194: NOT
78195: OR
78196: IFFALSE 78200
// exit ;
78198: GO 78247
// for i = 1 to 3 do
78200: LD_ADDR_VAR 0 3
78204: PUSH
78205: DOUBLE
78206: LD_INT 1
78208: DEC
78209: ST_TO_ADDR
78210: LD_INT 3
78212: PUSH
78213: FOR_TO
78214: IFFALSE 78245
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
78216: LD_VAR 0 1
78220: PPUSH
78221: CALL_OW 250
78225: PPUSH
78226: LD_VAR 0 1
78230: PPUSH
78231: CALL_OW 251
78235: PPUSH
78236: LD_INT 1
78238: PPUSH
78239: CALL_OW 453
78243: GO 78213
78245: POP
78246: POP
// end ;
78247: LD_VAR 0 2
78251: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
78252: LD_INT 0
78254: PPUSH
78255: PPUSH
78256: PPUSH
78257: PPUSH
78258: PPUSH
78259: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
78260: LD_VAR 0 1
78264: NOT
78265: PUSH
78266: LD_VAR 0 2
78270: NOT
78271: OR
78272: PUSH
78273: LD_VAR 0 1
78277: PPUSH
78278: CALL_OW 314
78282: OR
78283: IFFALSE 78287
// exit ;
78285: GO 78728
// x := GetX ( enemy_unit ) ;
78287: LD_ADDR_VAR 0 7
78291: PUSH
78292: LD_VAR 0 2
78296: PPUSH
78297: CALL_OW 250
78301: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
78302: LD_ADDR_VAR 0 8
78306: PUSH
78307: LD_VAR 0 2
78311: PPUSH
78312: CALL_OW 251
78316: ST_TO_ADDR
// if not x or not y then
78317: LD_VAR 0 7
78321: NOT
78322: PUSH
78323: LD_VAR 0 8
78327: NOT
78328: OR
78329: IFFALSE 78333
// exit ;
78331: GO 78728
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
78333: LD_ADDR_VAR 0 6
78337: PUSH
78338: LD_VAR 0 7
78342: PPUSH
78343: LD_INT 0
78345: PPUSH
78346: LD_INT 4
78348: PPUSH
78349: CALL_OW 272
78353: PUSH
78354: LD_VAR 0 8
78358: PPUSH
78359: LD_INT 0
78361: PPUSH
78362: LD_INT 4
78364: PPUSH
78365: CALL_OW 273
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_VAR 0 7
78378: PPUSH
78379: LD_INT 1
78381: PPUSH
78382: LD_INT 4
78384: PPUSH
78385: CALL_OW 272
78389: PUSH
78390: LD_VAR 0 8
78394: PPUSH
78395: LD_INT 1
78397: PPUSH
78398: LD_INT 4
78400: PPUSH
78401: CALL_OW 273
78405: PUSH
78406: EMPTY
78407: LIST
78408: LIST
78409: PUSH
78410: LD_VAR 0 7
78414: PPUSH
78415: LD_INT 2
78417: PPUSH
78418: LD_INT 4
78420: PPUSH
78421: CALL_OW 272
78425: PUSH
78426: LD_VAR 0 8
78430: PPUSH
78431: LD_INT 2
78433: PPUSH
78434: LD_INT 4
78436: PPUSH
78437: CALL_OW 273
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: PUSH
78446: LD_VAR 0 7
78450: PPUSH
78451: LD_INT 3
78453: PPUSH
78454: LD_INT 4
78456: PPUSH
78457: CALL_OW 272
78461: PUSH
78462: LD_VAR 0 8
78466: PPUSH
78467: LD_INT 3
78469: PPUSH
78470: LD_INT 4
78472: PPUSH
78473: CALL_OW 273
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: LD_VAR 0 7
78486: PPUSH
78487: LD_INT 4
78489: PPUSH
78490: LD_INT 4
78492: PPUSH
78493: CALL_OW 272
78497: PUSH
78498: LD_VAR 0 8
78502: PPUSH
78503: LD_INT 4
78505: PPUSH
78506: LD_INT 4
78508: PPUSH
78509: CALL_OW 273
78513: PUSH
78514: EMPTY
78515: LIST
78516: LIST
78517: PUSH
78518: LD_VAR 0 7
78522: PPUSH
78523: LD_INT 5
78525: PPUSH
78526: LD_INT 4
78528: PPUSH
78529: CALL_OW 272
78533: PUSH
78534: LD_VAR 0 8
78538: PPUSH
78539: LD_INT 5
78541: PPUSH
78542: LD_INT 4
78544: PPUSH
78545: CALL_OW 273
78549: PUSH
78550: EMPTY
78551: LIST
78552: LIST
78553: PUSH
78554: EMPTY
78555: LIST
78556: LIST
78557: LIST
78558: LIST
78559: LIST
78560: LIST
78561: ST_TO_ADDR
// for i = tmp downto 1 do
78562: LD_ADDR_VAR 0 4
78566: PUSH
78567: DOUBLE
78568: LD_VAR 0 6
78572: INC
78573: ST_TO_ADDR
78574: LD_INT 1
78576: PUSH
78577: FOR_DOWNTO
78578: IFFALSE 78679
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
78580: LD_VAR 0 6
78584: PUSH
78585: LD_VAR 0 4
78589: ARRAY
78590: PUSH
78591: LD_INT 1
78593: ARRAY
78594: PPUSH
78595: LD_VAR 0 6
78599: PUSH
78600: LD_VAR 0 4
78604: ARRAY
78605: PUSH
78606: LD_INT 2
78608: ARRAY
78609: PPUSH
78610: CALL_OW 488
78614: NOT
78615: PUSH
78616: LD_VAR 0 6
78620: PUSH
78621: LD_VAR 0 4
78625: ARRAY
78626: PUSH
78627: LD_INT 1
78629: ARRAY
78630: PPUSH
78631: LD_VAR 0 6
78635: PUSH
78636: LD_VAR 0 4
78640: ARRAY
78641: PUSH
78642: LD_INT 2
78644: ARRAY
78645: PPUSH
78646: CALL_OW 428
78650: PUSH
78651: LD_INT 0
78653: NONEQUAL
78654: OR
78655: IFFALSE 78677
// tmp := Delete ( tmp , i ) ;
78657: LD_ADDR_VAR 0 6
78661: PUSH
78662: LD_VAR 0 6
78666: PPUSH
78667: LD_VAR 0 4
78671: PPUSH
78672: CALL_OW 3
78676: ST_TO_ADDR
78677: GO 78577
78679: POP
78680: POP
// j := GetClosestHex ( unit , tmp ) ;
78681: LD_ADDR_VAR 0 5
78685: PUSH
78686: LD_VAR 0 1
78690: PPUSH
78691: LD_VAR 0 6
78695: PPUSH
78696: CALL 77981 0 2
78700: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
78701: LD_VAR 0 1
78705: PPUSH
78706: LD_VAR 0 5
78710: PUSH
78711: LD_INT 1
78713: ARRAY
78714: PPUSH
78715: LD_VAR 0 5
78719: PUSH
78720: LD_INT 2
78722: ARRAY
78723: PPUSH
78724: CALL_OW 111
// end ;
78728: LD_VAR 0 3
78732: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
78733: LD_INT 0
78735: PPUSH
78736: PPUSH
78737: PPUSH
// uc_side = 0 ;
78738: LD_ADDR_OWVAR 20
78742: PUSH
78743: LD_INT 0
78745: ST_TO_ADDR
// uc_nation = 0 ;
78746: LD_ADDR_OWVAR 21
78750: PUSH
78751: LD_INT 0
78753: ST_TO_ADDR
// InitHc ;
78754: CALL_OW 19
// InitVc ;
78758: CALL_OW 20
// if mastodonts then
78762: LD_VAR 0 6
78766: IFFALSE 78833
// for i = 1 to mastodonts do
78768: LD_ADDR_VAR 0 11
78772: PUSH
78773: DOUBLE
78774: LD_INT 1
78776: DEC
78777: ST_TO_ADDR
78778: LD_VAR 0 6
78782: PUSH
78783: FOR_TO
78784: IFFALSE 78831
// begin vc_chassis := 31 ;
78786: LD_ADDR_OWVAR 37
78790: PUSH
78791: LD_INT 31
78793: ST_TO_ADDR
// vc_control := control_rider ;
78794: LD_ADDR_OWVAR 38
78798: PUSH
78799: LD_INT 4
78801: ST_TO_ADDR
// animal := CreateVehicle ;
78802: LD_ADDR_VAR 0 12
78806: PUSH
78807: CALL_OW 45
78811: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
78812: LD_VAR 0 12
78816: PPUSH
78817: LD_VAR 0 8
78821: PPUSH
78822: LD_INT 0
78824: PPUSH
78825: CALL 85539 0 3
// end ;
78829: GO 78783
78831: POP
78832: POP
// if horses then
78833: LD_VAR 0 5
78837: IFFALSE 78904
// for i = 1 to horses do
78839: LD_ADDR_VAR 0 11
78843: PUSH
78844: DOUBLE
78845: LD_INT 1
78847: DEC
78848: ST_TO_ADDR
78849: LD_VAR 0 5
78853: PUSH
78854: FOR_TO
78855: IFFALSE 78902
// begin hc_class := 21 ;
78857: LD_ADDR_OWVAR 28
78861: PUSH
78862: LD_INT 21
78864: ST_TO_ADDR
// hc_gallery :=  ;
78865: LD_ADDR_OWVAR 33
78869: PUSH
78870: LD_STRING 
78872: ST_TO_ADDR
// animal := CreateHuman ;
78873: LD_ADDR_VAR 0 12
78877: PUSH
78878: CALL_OW 44
78882: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
78883: LD_VAR 0 12
78887: PPUSH
78888: LD_VAR 0 8
78892: PPUSH
78893: LD_INT 0
78895: PPUSH
78896: CALL 85539 0 3
// end ;
78900: GO 78854
78902: POP
78903: POP
// if birds then
78904: LD_VAR 0 1
78908: IFFALSE 78975
// for i = 1 to birds do
78910: LD_ADDR_VAR 0 11
78914: PUSH
78915: DOUBLE
78916: LD_INT 1
78918: DEC
78919: ST_TO_ADDR
78920: LD_VAR 0 1
78924: PUSH
78925: FOR_TO
78926: IFFALSE 78973
// begin hc_class = 18 ;
78928: LD_ADDR_OWVAR 28
78932: PUSH
78933: LD_INT 18
78935: ST_TO_ADDR
// hc_gallery =  ;
78936: LD_ADDR_OWVAR 33
78940: PUSH
78941: LD_STRING 
78943: ST_TO_ADDR
// animal := CreateHuman ;
78944: LD_ADDR_VAR 0 12
78948: PUSH
78949: CALL_OW 44
78953: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
78954: LD_VAR 0 12
78958: PPUSH
78959: LD_VAR 0 8
78963: PPUSH
78964: LD_INT 0
78966: PPUSH
78967: CALL 85539 0 3
// end ;
78971: GO 78925
78973: POP
78974: POP
// if tigers then
78975: LD_VAR 0 2
78979: IFFALSE 79063
// for i = 1 to tigers do
78981: LD_ADDR_VAR 0 11
78985: PUSH
78986: DOUBLE
78987: LD_INT 1
78989: DEC
78990: ST_TO_ADDR
78991: LD_VAR 0 2
78995: PUSH
78996: FOR_TO
78997: IFFALSE 79061
// begin hc_class = class_tiger ;
78999: LD_ADDR_OWVAR 28
79003: PUSH
79004: LD_INT 14
79006: ST_TO_ADDR
// hc_gallery =  ;
79007: LD_ADDR_OWVAR 33
79011: PUSH
79012: LD_STRING 
79014: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
79015: LD_ADDR_OWVAR 35
79019: PUSH
79020: LD_INT 7
79022: NEG
79023: PPUSH
79024: LD_INT 7
79026: PPUSH
79027: CALL_OW 12
79031: ST_TO_ADDR
// animal := CreateHuman ;
79032: LD_ADDR_VAR 0 12
79036: PUSH
79037: CALL_OW 44
79041: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
79042: LD_VAR 0 12
79046: PPUSH
79047: LD_VAR 0 8
79051: PPUSH
79052: LD_INT 0
79054: PPUSH
79055: CALL 85539 0 3
// end ;
79059: GO 78996
79061: POP
79062: POP
// if apemans then
79063: LD_VAR 0 3
79067: IFFALSE 79190
// for i = 1 to apemans do
79069: LD_ADDR_VAR 0 11
79073: PUSH
79074: DOUBLE
79075: LD_INT 1
79077: DEC
79078: ST_TO_ADDR
79079: LD_VAR 0 3
79083: PUSH
79084: FOR_TO
79085: IFFALSE 79188
// begin hc_class = class_apeman ;
79087: LD_ADDR_OWVAR 28
79091: PUSH
79092: LD_INT 12
79094: ST_TO_ADDR
// hc_gallery =  ;
79095: LD_ADDR_OWVAR 33
79099: PUSH
79100: LD_STRING 
79102: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
79103: LD_ADDR_OWVAR 35
79107: PUSH
79108: LD_INT 5
79110: NEG
79111: PPUSH
79112: LD_INT 5
79114: PPUSH
79115: CALL_OW 12
79119: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
79120: LD_ADDR_OWVAR 31
79124: PUSH
79125: LD_INT 1
79127: PPUSH
79128: LD_INT 3
79130: PPUSH
79131: CALL_OW 12
79135: PUSH
79136: LD_INT 1
79138: PPUSH
79139: LD_INT 3
79141: PPUSH
79142: CALL_OW 12
79146: PUSH
79147: LD_INT 0
79149: PUSH
79150: LD_INT 0
79152: PUSH
79153: EMPTY
79154: LIST
79155: LIST
79156: LIST
79157: LIST
79158: ST_TO_ADDR
// animal := CreateHuman ;
79159: LD_ADDR_VAR 0 12
79163: PUSH
79164: CALL_OW 44
79168: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
79169: LD_VAR 0 12
79173: PPUSH
79174: LD_VAR 0 8
79178: PPUSH
79179: LD_INT 0
79181: PPUSH
79182: CALL 85539 0 3
// end ;
79186: GO 79084
79188: POP
79189: POP
// if enchidnas then
79190: LD_VAR 0 4
79194: IFFALSE 79261
// for i = 1 to enchidnas do
79196: LD_ADDR_VAR 0 11
79200: PUSH
79201: DOUBLE
79202: LD_INT 1
79204: DEC
79205: ST_TO_ADDR
79206: LD_VAR 0 4
79210: PUSH
79211: FOR_TO
79212: IFFALSE 79259
// begin hc_class = 13 ;
79214: LD_ADDR_OWVAR 28
79218: PUSH
79219: LD_INT 13
79221: ST_TO_ADDR
// hc_gallery =  ;
79222: LD_ADDR_OWVAR 33
79226: PUSH
79227: LD_STRING 
79229: ST_TO_ADDR
// animal := CreateHuman ;
79230: LD_ADDR_VAR 0 12
79234: PUSH
79235: CALL_OW 44
79239: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
79240: LD_VAR 0 12
79244: PPUSH
79245: LD_VAR 0 8
79249: PPUSH
79250: LD_INT 0
79252: PPUSH
79253: CALL 85539 0 3
// end ;
79257: GO 79211
79259: POP
79260: POP
// if fishes then
79261: LD_VAR 0 7
79265: IFFALSE 79332
// for i = 1 to fishes do
79267: LD_ADDR_VAR 0 11
79271: PUSH
79272: DOUBLE
79273: LD_INT 1
79275: DEC
79276: ST_TO_ADDR
79277: LD_VAR 0 7
79281: PUSH
79282: FOR_TO
79283: IFFALSE 79330
// begin hc_class = 20 ;
79285: LD_ADDR_OWVAR 28
79289: PUSH
79290: LD_INT 20
79292: ST_TO_ADDR
// hc_gallery =  ;
79293: LD_ADDR_OWVAR 33
79297: PUSH
79298: LD_STRING 
79300: ST_TO_ADDR
// animal := CreateHuman ;
79301: LD_ADDR_VAR 0 12
79305: PUSH
79306: CALL_OW 44
79310: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
79311: LD_VAR 0 12
79315: PPUSH
79316: LD_VAR 0 9
79320: PPUSH
79321: LD_INT 0
79323: PPUSH
79324: CALL 85539 0 3
// end ;
79328: GO 79282
79330: POP
79331: POP
// end ;
79332: LD_VAR 0 10
79336: RET
// export function WantHeal ( sci , unit ) ; begin
79337: LD_INT 0
79339: PPUSH
// if GetTaskList ( sci ) > 0 then
79340: LD_VAR 0 1
79344: PPUSH
79345: CALL_OW 437
79349: PUSH
79350: LD_INT 0
79352: GREATER
79353: IFFALSE 79423
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
79355: LD_VAR 0 1
79359: PPUSH
79360: CALL_OW 437
79364: PUSH
79365: LD_INT 1
79367: ARRAY
79368: PUSH
79369: LD_INT 1
79371: ARRAY
79372: PUSH
79373: LD_STRING l
79375: EQUAL
79376: PUSH
79377: LD_VAR 0 1
79381: PPUSH
79382: CALL_OW 437
79386: PUSH
79387: LD_INT 1
79389: ARRAY
79390: PUSH
79391: LD_INT 4
79393: ARRAY
79394: PUSH
79395: LD_VAR 0 2
79399: EQUAL
79400: AND
79401: IFFALSE 79413
// result := true else
79403: LD_ADDR_VAR 0 3
79407: PUSH
79408: LD_INT 1
79410: ST_TO_ADDR
79411: GO 79421
// result := false ;
79413: LD_ADDR_VAR 0 3
79417: PUSH
79418: LD_INT 0
79420: ST_TO_ADDR
// end else
79421: GO 79431
// result := false ;
79423: LD_ADDR_VAR 0 3
79427: PUSH
79428: LD_INT 0
79430: ST_TO_ADDR
// end ;
79431: LD_VAR 0 3
79435: RET
// export function HealTarget ( sci ) ; begin
79436: LD_INT 0
79438: PPUSH
// if not sci then
79439: LD_VAR 0 1
79443: NOT
79444: IFFALSE 79448
// exit ;
79446: GO 79513
// result := 0 ;
79448: LD_ADDR_VAR 0 2
79452: PUSH
79453: LD_INT 0
79455: ST_TO_ADDR
// if GetTaskList ( sci ) then
79456: LD_VAR 0 1
79460: PPUSH
79461: CALL_OW 437
79465: IFFALSE 79513
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
79467: LD_VAR 0 1
79471: PPUSH
79472: CALL_OW 437
79476: PUSH
79477: LD_INT 1
79479: ARRAY
79480: PUSH
79481: LD_INT 1
79483: ARRAY
79484: PUSH
79485: LD_STRING l
79487: EQUAL
79488: IFFALSE 79513
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
79490: LD_ADDR_VAR 0 2
79494: PUSH
79495: LD_VAR 0 1
79499: PPUSH
79500: CALL_OW 437
79504: PUSH
79505: LD_INT 1
79507: ARRAY
79508: PUSH
79509: LD_INT 4
79511: ARRAY
79512: ST_TO_ADDR
// end ;
79513: LD_VAR 0 2
79517: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
79518: LD_INT 0
79520: PPUSH
79521: PPUSH
79522: PPUSH
79523: PPUSH
79524: PPUSH
79525: PPUSH
79526: PPUSH
79527: PPUSH
79528: PPUSH
79529: PPUSH
79530: PPUSH
79531: PPUSH
79532: PPUSH
79533: PPUSH
79534: PPUSH
79535: PPUSH
79536: PPUSH
79537: PPUSH
79538: PPUSH
79539: PPUSH
79540: PPUSH
79541: PPUSH
79542: PPUSH
79543: PPUSH
79544: PPUSH
79545: PPUSH
79546: PPUSH
79547: PPUSH
79548: PPUSH
79549: PPUSH
79550: PPUSH
79551: PPUSH
79552: PPUSH
// if not list then
79553: LD_VAR 0 1
79557: NOT
79558: IFFALSE 79562
// exit ;
79560: GO 84150
// base := list [ 1 ] ;
79562: LD_ADDR_VAR 0 3
79566: PUSH
79567: LD_VAR 0 1
79571: PUSH
79572: LD_INT 1
79574: ARRAY
79575: ST_TO_ADDR
// group := list [ 2 ] ;
79576: LD_ADDR_VAR 0 4
79580: PUSH
79581: LD_VAR 0 1
79585: PUSH
79586: LD_INT 2
79588: ARRAY
79589: ST_TO_ADDR
// path := list [ 3 ] ;
79590: LD_ADDR_VAR 0 5
79594: PUSH
79595: LD_VAR 0 1
79599: PUSH
79600: LD_INT 3
79602: ARRAY
79603: ST_TO_ADDR
// flags := list [ 4 ] ;
79604: LD_ADDR_VAR 0 6
79608: PUSH
79609: LD_VAR 0 1
79613: PUSH
79614: LD_INT 4
79616: ARRAY
79617: ST_TO_ADDR
// mined := [ ] ;
79618: LD_ADDR_VAR 0 27
79622: PUSH
79623: EMPTY
79624: ST_TO_ADDR
// bombed := [ ] ;
79625: LD_ADDR_VAR 0 28
79629: PUSH
79630: EMPTY
79631: ST_TO_ADDR
// healers := [ ] ;
79632: LD_ADDR_VAR 0 31
79636: PUSH
79637: EMPTY
79638: ST_TO_ADDR
// to_heal := [ ] ;
79639: LD_ADDR_VAR 0 30
79643: PUSH
79644: EMPTY
79645: ST_TO_ADDR
// repairs := [ ] ;
79646: LD_ADDR_VAR 0 33
79650: PUSH
79651: EMPTY
79652: ST_TO_ADDR
// to_repair := [ ] ;
79653: LD_ADDR_VAR 0 32
79657: PUSH
79658: EMPTY
79659: ST_TO_ADDR
// if not group or not path then
79660: LD_VAR 0 4
79664: NOT
79665: PUSH
79666: LD_VAR 0 5
79670: NOT
79671: OR
79672: IFFALSE 79676
// exit ;
79674: GO 84150
// if flags then
79676: LD_VAR 0 6
79680: IFFALSE 79824
// begin f_ignore_area := flags [ 1 ] ;
79682: LD_ADDR_VAR 0 17
79686: PUSH
79687: LD_VAR 0 6
79691: PUSH
79692: LD_INT 1
79694: ARRAY
79695: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
79696: LD_ADDR_VAR 0 18
79700: PUSH
79701: LD_VAR 0 6
79705: PUSH
79706: LD_INT 2
79708: ARRAY
79709: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
79710: LD_ADDR_VAR 0 19
79714: PUSH
79715: LD_VAR 0 6
79719: PUSH
79720: LD_INT 3
79722: ARRAY
79723: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
79724: LD_ADDR_VAR 0 20
79728: PUSH
79729: LD_VAR 0 6
79733: PUSH
79734: LD_INT 4
79736: ARRAY
79737: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
79738: LD_ADDR_VAR 0 21
79742: PUSH
79743: LD_VAR 0 6
79747: PUSH
79748: LD_INT 5
79750: ARRAY
79751: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
79752: LD_ADDR_VAR 0 22
79756: PUSH
79757: LD_VAR 0 6
79761: PUSH
79762: LD_INT 6
79764: ARRAY
79765: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
79766: LD_ADDR_VAR 0 23
79770: PUSH
79771: LD_VAR 0 6
79775: PUSH
79776: LD_INT 7
79778: ARRAY
79779: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
79780: LD_ADDR_VAR 0 24
79784: PUSH
79785: LD_VAR 0 6
79789: PUSH
79790: LD_INT 8
79792: ARRAY
79793: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
79794: LD_ADDR_VAR 0 25
79798: PUSH
79799: LD_VAR 0 6
79803: PUSH
79804: LD_INT 9
79806: ARRAY
79807: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
79808: LD_ADDR_VAR 0 26
79812: PUSH
79813: LD_VAR 0 6
79817: PUSH
79818: LD_INT 10
79820: ARRAY
79821: ST_TO_ADDR
// end else
79822: GO 79904
// begin f_ignore_area := false ;
79824: LD_ADDR_VAR 0 17
79828: PUSH
79829: LD_INT 0
79831: ST_TO_ADDR
// f_capture := false ;
79832: LD_ADDR_VAR 0 18
79836: PUSH
79837: LD_INT 0
79839: ST_TO_ADDR
// f_ignore_civ := false ;
79840: LD_ADDR_VAR 0 19
79844: PUSH
79845: LD_INT 0
79847: ST_TO_ADDR
// f_murder := false ;
79848: LD_ADDR_VAR 0 20
79852: PUSH
79853: LD_INT 0
79855: ST_TO_ADDR
// f_mines := false ;
79856: LD_ADDR_VAR 0 21
79860: PUSH
79861: LD_INT 0
79863: ST_TO_ADDR
// f_repair := false ;
79864: LD_ADDR_VAR 0 22
79868: PUSH
79869: LD_INT 0
79871: ST_TO_ADDR
// f_heal := false ;
79872: LD_ADDR_VAR 0 23
79876: PUSH
79877: LD_INT 0
79879: ST_TO_ADDR
// f_spacetime := false ;
79880: LD_ADDR_VAR 0 24
79884: PUSH
79885: LD_INT 0
79887: ST_TO_ADDR
// f_attack_depot := false ;
79888: LD_ADDR_VAR 0 25
79892: PUSH
79893: LD_INT 0
79895: ST_TO_ADDR
// f_crawl := false ;
79896: LD_ADDR_VAR 0 26
79900: PUSH
79901: LD_INT 0
79903: ST_TO_ADDR
// end ; if f_heal then
79904: LD_VAR 0 23
79908: IFFALSE 79935
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
79910: LD_ADDR_VAR 0 31
79914: PUSH
79915: LD_VAR 0 4
79919: PPUSH
79920: LD_INT 25
79922: PUSH
79923: LD_INT 4
79925: PUSH
79926: EMPTY
79927: LIST
79928: LIST
79929: PPUSH
79930: CALL_OW 72
79934: ST_TO_ADDR
// if f_repair then
79935: LD_VAR 0 22
79939: IFFALSE 79966
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
79941: LD_ADDR_VAR 0 33
79945: PUSH
79946: LD_VAR 0 4
79950: PPUSH
79951: LD_INT 25
79953: PUSH
79954: LD_INT 3
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: PPUSH
79961: CALL_OW 72
79965: ST_TO_ADDR
// units_path := [ ] ;
79966: LD_ADDR_VAR 0 16
79970: PUSH
79971: EMPTY
79972: ST_TO_ADDR
// for i = 1 to group do
79973: LD_ADDR_VAR 0 7
79977: PUSH
79978: DOUBLE
79979: LD_INT 1
79981: DEC
79982: ST_TO_ADDR
79983: LD_VAR 0 4
79987: PUSH
79988: FOR_TO
79989: IFFALSE 80018
// units_path := Replace ( units_path , i , path ) ;
79991: LD_ADDR_VAR 0 16
79995: PUSH
79996: LD_VAR 0 16
80000: PPUSH
80001: LD_VAR 0 7
80005: PPUSH
80006: LD_VAR 0 5
80010: PPUSH
80011: CALL_OW 1
80015: ST_TO_ADDR
80016: GO 79988
80018: POP
80019: POP
// repeat for i = group downto 1 do
80020: LD_ADDR_VAR 0 7
80024: PUSH
80025: DOUBLE
80026: LD_VAR 0 4
80030: INC
80031: ST_TO_ADDR
80032: LD_INT 1
80034: PUSH
80035: FOR_DOWNTO
80036: IFFALSE 84132
// begin wait ( 5 ) ;
80038: LD_INT 5
80040: PPUSH
80041: CALL_OW 67
// tmp := [ ] ;
80045: LD_ADDR_VAR 0 14
80049: PUSH
80050: EMPTY
80051: ST_TO_ADDR
// attacking := false ;
80052: LD_ADDR_VAR 0 29
80056: PUSH
80057: LD_INT 0
80059: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
80060: LD_VAR 0 4
80064: PUSH
80065: LD_VAR 0 7
80069: ARRAY
80070: PPUSH
80071: CALL_OW 301
80075: PUSH
80076: LD_VAR 0 4
80080: PUSH
80081: LD_VAR 0 7
80085: ARRAY
80086: NOT
80087: OR
80088: IFFALSE 80197
// begin if GetType ( group [ i ] ) = unit_human then
80090: LD_VAR 0 4
80094: PUSH
80095: LD_VAR 0 7
80099: ARRAY
80100: PPUSH
80101: CALL_OW 247
80105: PUSH
80106: LD_INT 1
80108: EQUAL
80109: IFFALSE 80155
// begin to_heal := to_heal diff group [ i ] ;
80111: LD_ADDR_VAR 0 30
80115: PUSH
80116: LD_VAR 0 30
80120: PUSH
80121: LD_VAR 0 4
80125: PUSH
80126: LD_VAR 0 7
80130: ARRAY
80131: DIFF
80132: ST_TO_ADDR
// healers := healers diff group [ i ] ;
80133: LD_ADDR_VAR 0 31
80137: PUSH
80138: LD_VAR 0 31
80142: PUSH
80143: LD_VAR 0 4
80147: PUSH
80148: LD_VAR 0 7
80152: ARRAY
80153: DIFF
80154: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
80155: LD_ADDR_VAR 0 4
80159: PUSH
80160: LD_VAR 0 4
80164: PPUSH
80165: LD_VAR 0 7
80169: PPUSH
80170: CALL_OW 3
80174: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
80175: LD_ADDR_VAR 0 16
80179: PUSH
80180: LD_VAR 0 16
80184: PPUSH
80185: LD_VAR 0 7
80189: PPUSH
80190: CALL_OW 3
80194: ST_TO_ADDR
// continue ;
80195: GO 80035
// end ; if f_repair then
80197: LD_VAR 0 22
80201: IFFALSE 80690
// begin if GetType ( group [ i ] ) = unit_vehicle then
80203: LD_VAR 0 4
80207: PUSH
80208: LD_VAR 0 7
80212: ARRAY
80213: PPUSH
80214: CALL_OW 247
80218: PUSH
80219: LD_INT 2
80221: EQUAL
80222: IFFALSE 80412
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
80224: LD_VAR 0 4
80228: PUSH
80229: LD_VAR 0 7
80233: ARRAY
80234: PPUSH
80235: CALL_OW 256
80239: PUSH
80240: LD_INT 700
80242: LESS
80243: PUSH
80244: LD_VAR 0 4
80248: PUSH
80249: LD_VAR 0 7
80253: ARRAY
80254: PUSH
80255: LD_VAR 0 32
80259: IN
80260: NOT
80261: AND
80262: IFFALSE 80286
// to_repair := to_repair union group [ i ] ;
80264: LD_ADDR_VAR 0 32
80268: PUSH
80269: LD_VAR 0 32
80273: PUSH
80274: LD_VAR 0 4
80278: PUSH
80279: LD_VAR 0 7
80283: ARRAY
80284: UNION
80285: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
80286: LD_VAR 0 4
80290: PUSH
80291: LD_VAR 0 7
80295: ARRAY
80296: PPUSH
80297: CALL_OW 256
80301: PUSH
80302: LD_INT 1000
80304: EQUAL
80305: PUSH
80306: LD_VAR 0 4
80310: PUSH
80311: LD_VAR 0 7
80315: ARRAY
80316: PUSH
80317: LD_VAR 0 32
80321: IN
80322: AND
80323: IFFALSE 80347
// to_repair := to_repair diff group [ i ] ;
80325: LD_ADDR_VAR 0 32
80329: PUSH
80330: LD_VAR 0 32
80334: PUSH
80335: LD_VAR 0 4
80339: PUSH
80340: LD_VAR 0 7
80344: ARRAY
80345: DIFF
80346: ST_TO_ADDR
// if group [ i ] in to_repair then
80347: LD_VAR 0 4
80351: PUSH
80352: LD_VAR 0 7
80356: ARRAY
80357: PUSH
80358: LD_VAR 0 32
80362: IN
80363: IFFALSE 80410
// begin if not IsInArea ( group [ i ] , f_repair ) then
80365: LD_VAR 0 4
80369: PUSH
80370: LD_VAR 0 7
80374: ARRAY
80375: PPUSH
80376: LD_VAR 0 22
80380: PPUSH
80381: CALL_OW 308
80385: NOT
80386: IFFALSE 80408
// ComMoveToArea ( group [ i ] , f_repair ) ;
80388: LD_VAR 0 4
80392: PUSH
80393: LD_VAR 0 7
80397: ARRAY
80398: PPUSH
80399: LD_VAR 0 22
80403: PPUSH
80404: CALL_OW 113
// continue ;
80408: GO 80035
// end ; end else
80410: GO 80690
// if group [ i ] in repairs then
80412: LD_VAR 0 4
80416: PUSH
80417: LD_VAR 0 7
80421: ARRAY
80422: PUSH
80423: LD_VAR 0 33
80427: IN
80428: IFFALSE 80690
// begin if IsInUnit ( group [ i ] ) then
80430: LD_VAR 0 4
80434: PUSH
80435: LD_VAR 0 7
80439: ARRAY
80440: PPUSH
80441: CALL_OW 310
80445: IFFALSE 80513
// begin z := IsInUnit ( group [ i ] ) ;
80447: LD_ADDR_VAR 0 13
80451: PUSH
80452: LD_VAR 0 4
80456: PUSH
80457: LD_VAR 0 7
80461: ARRAY
80462: PPUSH
80463: CALL_OW 310
80467: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
80468: LD_VAR 0 13
80472: PUSH
80473: LD_VAR 0 32
80477: IN
80478: PUSH
80479: LD_VAR 0 13
80483: PPUSH
80484: LD_VAR 0 22
80488: PPUSH
80489: CALL_OW 308
80493: AND
80494: IFFALSE 80511
// ComExitVehicle ( group [ i ] ) ;
80496: LD_VAR 0 4
80500: PUSH
80501: LD_VAR 0 7
80505: ARRAY
80506: PPUSH
80507: CALL_OW 121
// end else
80511: GO 80690
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
80513: LD_ADDR_VAR 0 13
80517: PUSH
80518: LD_VAR 0 4
80522: PPUSH
80523: LD_INT 95
80525: PUSH
80526: LD_VAR 0 22
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 58
80537: PUSH
80538: EMPTY
80539: LIST
80540: PUSH
80541: EMPTY
80542: LIST
80543: LIST
80544: PPUSH
80545: CALL_OW 72
80549: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
80550: LD_VAR 0 4
80554: PUSH
80555: LD_VAR 0 7
80559: ARRAY
80560: PPUSH
80561: CALL_OW 314
80565: NOT
80566: IFFALSE 80688
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
80568: LD_ADDR_VAR 0 10
80572: PUSH
80573: LD_VAR 0 13
80577: PPUSH
80578: LD_VAR 0 4
80582: PUSH
80583: LD_VAR 0 7
80587: ARRAY
80588: PPUSH
80589: CALL_OW 74
80593: ST_TO_ADDR
// if not x then
80594: LD_VAR 0 10
80598: NOT
80599: IFFALSE 80603
// continue ;
80601: GO 80035
// if GetLives ( x ) < 1000 then
80603: LD_VAR 0 10
80607: PPUSH
80608: CALL_OW 256
80612: PUSH
80613: LD_INT 1000
80615: LESS
80616: IFFALSE 80640
// ComRepairVehicle ( group [ i ] , x ) else
80618: LD_VAR 0 4
80622: PUSH
80623: LD_VAR 0 7
80627: ARRAY
80628: PPUSH
80629: LD_VAR 0 10
80633: PPUSH
80634: CALL_OW 129
80638: GO 80688
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
80640: LD_VAR 0 23
80644: PUSH
80645: LD_VAR 0 4
80649: PUSH
80650: LD_VAR 0 7
80654: ARRAY
80655: PPUSH
80656: CALL_OW 256
80660: PUSH
80661: LD_INT 1000
80663: LESS
80664: AND
80665: NOT
80666: IFFALSE 80688
// ComEnterUnit ( group [ i ] , x ) ;
80668: LD_VAR 0 4
80672: PUSH
80673: LD_VAR 0 7
80677: ARRAY
80678: PPUSH
80679: LD_VAR 0 10
80683: PPUSH
80684: CALL_OW 120
// end ; continue ;
80688: GO 80035
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
80690: LD_VAR 0 23
80694: PUSH
80695: LD_VAR 0 4
80699: PUSH
80700: LD_VAR 0 7
80704: ARRAY
80705: PPUSH
80706: CALL_OW 247
80710: PUSH
80711: LD_INT 1
80713: EQUAL
80714: AND
80715: IFFALSE 81193
// begin if group [ i ] in healers then
80717: LD_VAR 0 4
80721: PUSH
80722: LD_VAR 0 7
80726: ARRAY
80727: PUSH
80728: LD_VAR 0 31
80732: IN
80733: IFFALSE 81006
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
80735: LD_VAR 0 4
80739: PUSH
80740: LD_VAR 0 7
80744: ARRAY
80745: PPUSH
80746: LD_VAR 0 23
80750: PPUSH
80751: CALL_OW 308
80755: NOT
80756: PUSH
80757: LD_VAR 0 4
80761: PUSH
80762: LD_VAR 0 7
80766: ARRAY
80767: PPUSH
80768: CALL_OW 314
80772: NOT
80773: AND
80774: IFFALSE 80798
// ComMoveToArea ( group [ i ] , f_heal ) else
80776: LD_VAR 0 4
80780: PUSH
80781: LD_VAR 0 7
80785: ARRAY
80786: PPUSH
80787: LD_VAR 0 23
80791: PPUSH
80792: CALL_OW 113
80796: GO 81004
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
80798: LD_VAR 0 4
80802: PUSH
80803: LD_VAR 0 7
80807: ARRAY
80808: PPUSH
80809: CALL 79436 0 1
80813: PPUSH
80814: CALL_OW 256
80818: PUSH
80819: LD_INT 1000
80821: EQUAL
80822: IFFALSE 80841
// ComStop ( group [ i ] ) else
80824: LD_VAR 0 4
80828: PUSH
80829: LD_VAR 0 7
80833: ARRAY
80834: PPUSH
80835: CALL_OW 141
80839: GO 81004
// if not HasTask ( group [ i ] ) and to_heal then
80841: LD_VAR 0 4
80845: PUSH
80846: LD_VAR 0 7
80850: ARRAY
80851: PPUSH
80852: CALL_OW 314
80856: NOT
80857: PUSH
80858: LD_VAR 0 30
80862: AND
80863: IFFALSE 81004
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
80865: LD_ADDR_VAR 0 13
80869: PUSH
80870: LD_VAR 0 30
80874: PPUSH
80875: LD_INT 3
80877: PUSH
80878: LD_INT 54
80880: PUSH
80881: EMPTY
80882: LIST
80883: PUSH
80884: EMPTY
80885: LIST
80886: LIST
80887: PPUSH
80888: CALL_OW 72
80892: PPUSH
80893: LD_VAR 0 4
80897: PUSH
80898: LD_VAR 0 7
80902: ARRAY
80903: PPUSH
80904: CALL_OW 74
80908: ST_TO_ADDR
// if z then
80909: LD_VAR 0 13
80913: IFFALSE 81004
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
80915: LD_INT 91
80917: PUSH
80918: LD_VAR 0 13
80922: PUSH
80923: LD_INT 10
80925: PUSH
80926: EMPTY
80927: LIST
80928: LIST
80929: LIST
80930: PUSH
80931: LD_INT 81
80933: PUSH
80934: LD_VAR 0 13
80938: PPUSH
80939: CALL_OW 255
80943: PUSH
80944: EMPTY
80945: LIST
80946: LIST
80947: PUSH
80948: EMPTY
80949: LIST
80950: LIST
80951: PPUSH
80952: CALL_OW 69
80956: PUSH
80957: LD_INT 0
80959: EQUAL
80960: IFFALSE 80984
// ComHeal ( group [ i ] , z ) else
80962: LD_VAR 0 4
80966: PUSH
80967: LD_VAR 0 7
80971: ARRAY
80972: PPUSH
80973: LD_VAR 0 13
80977: PPUSH
80978: CALL_OW 128
80982: GO 81004
// ComMoveToArea ( group [ i ] , f_heal ) ;
80984: LD_VAR 0 4
80988: PUSH
80989: LD_VAR 0 7
80993: ARRAY
80994: PPUSH
80995: LD_VAR 0 23
80999: PPUSH
81000: CALL_OW 113
// end ; continue ;
81004: GO 80035
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
81006: LD_VAR 0 4
81010: PUSH
81011: LD_VAR 0 7
81015: ARRAY
81016: PPUSH
81017: CALL_OW 256
81021: PUSH
81022: LD_INT 700
81024: LESS
81025: PUSH
81026: LD_VAR 0 4
81030: PUSH
81031: LD_VAR 0 7
81035: ARRAY
81036: PUSH
81037: LD_VAR 0 30
81041: IN
81042: NOT
81043: AND
81044: IFFALSE 81068
// to_heal := to_heal union group [ i ] ;
81046: LD_ADDR_VAR 0 30
81050: PUSH
81051: LD_VAR 0 30
81055: PUSH
81056: LD_VAR 0 4
81060: PUSH
81061: LD_VAR 0 7
81065: ARRAY
81066: UNION
81067: ST_TO_ADDR
// if group [ i ] in to_heal then
81068: LD_VAR 0 4
81072: PUSH
81073: LD_VAR 0 7
81077: ARRAY
81078: PUSH
81079: LD_VAR 0 30
81083: IN
81084: IFFALSE 81193
// begin if GetLives ( group [ i ] ) = 1000 then
81086: LD_VAR 0 4
81090: PUSH
81091: LD_VAR 0 7
81095: ARRAY
81096: PPUSH
81097: CALL_OW 256
81101: PUSH
81102: LD_INT 1000
81104: EQUAL
81105: IFFALSE 81131
// to_heal := to_heal diff group [ i ] else
81107: LD_ADDR_VAR 0 30
81111: PUSH
81112: LD_VAR 0 30
81116: PUSH
81117: LD_VAR 0 4
81121: PUSH
81122: LD_VAR 0 7
81126: ARRAY
81127: DIFF
81128: ST_TO_ADDR
81129: GO 81193
// begin if not IsInArea ( group [ i ] , to_heal ) then
81131: LD_VAR 0 4
81135: PUSH
81136: LD_VAR 0 7
81140: ARRAY
81141: PPUSH
81142: LD_VAR 0 30
81146: PPUSH
81147: CALL_OW 308
81151: NOT
81152: IFFALSE 81176
// ComMoveToArea ( group [ i ] , f_heal ) else
81154: LD_VAR 0 4
81158: PUSH
81159: LD_VAR 0 7
81163: ARRAY
81164: PPUSH
81165: LD_VAR 0 23
81169: PPUSH
81170: CALL_OW 113
81174: GO 81191
// ComHold ( group [ i ] ) ;
81176: LD_VAR 0 4
81180: PUSH
81181: LD_VAR 0 7
81185: ARRAY
81186: PPUSH
81187: CALL_OW 140
// continue ;
81191: GO 80035
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
81193: LD_VAR 0 4
81197: PUSH
81198: LD_VAR 0 7
81202: ARRAY
81203: PPUSH
81204: LD_INT 10
81206: PPUSH
81207: CALL 77833 0 2
81211: NOT
81212: PUSH
81213: LD_VAR 0 16
81217: PUSH
81218: LD_VAR 0 7
81222: ARRAY
81223: PUSH
81224: EMPTY
81225: EQUAL
81226: NOT
81227: AND
81228: IFFALSE 81494
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
81230: LD_VAR 0 4
81234: PUSH
81235: LD_VAR 0 7
81239: ARRAY
81240: PPUSH
81241: CALL_OW 262
81245: PUSH
81246: LD_INT 1
81248: PUSH
81249: LD_INT 2
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: IN
81256: IFFALSE 81297
// if GetFuel ( group [ i ] ) < 10 then
81258: LD_VAR 0 4
81262: PUSH
81263: LD_VAR 0 7
81267: ARRAY
81268: PPUSH
81269: CALL_OW 261
81273: PUSH
81274: LD_INT 10
81276: LESS
81277: IFFALSE 81297
// SetFuel ( group [ i ] , 12 ) ;
81279: LD_VAR 0 4
81283: PUSH
81284: LD_VAR 0 7
81288: ARRAY
81289: PPUSH
81290: LD_INT 12
81292: PPUSH
81293: CALL_OW 240
// if units_path [ i ] then
81297: LD_VAR 0 16
81301: PUSH
81302: LD_VAR 0 7
81306: ARRAY
81307: IFFALSE 81492
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
81309: LD_VAR 0 4
81313: PUSH
81314: LD_VAR 0 7
81318: ARRAY
81319: PPUSH
81320: LD_VAR 0 16
81324: PUSH
81325: LD_VAR 0 7
81329: ARRAY
81330: PUSH
81331: LD_INT 1
81333: ARRAY
81334: PUSH
81335: LD_INT 1
81337: ARRAY
81338: PPUSH
81339: LD_VAR 0 16
81343: PUSH
81344: LD_VAR 0 7
81348: ARRAY
81349: PUSH
81350: LD_INT 1
81352: ARRAY
81353: PUSH
81354: LD_INT 2
81356: ARRAY
81357: PPUSH
81358: CALL_OW 297
81362: PUSH
81363: LD_INT 6
81365: GREATER
81366: IFFALSE 81441
// begin if not HasTask ( group [ i ] ) then
81368: LD_VAR 0 4
81372: PUSH
81373: LD_VAR 0 7
81377: ARRAY
81378: PPUSH
81379: CALL_OW 314
81383: NOT
81384: IFFALSE 81439
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
81386: LD_VAR 0 4
81390: PUSH
81391: LD_VAR 0 7
81395: ARRAY
81396: PPUSH
81397: LD_VAR 0 16
81401: PUSH
81402: LD_VAR 0 7
81406: ARRAY
81407: PUSH
81408: LD_INT 1
81410: ARRAY
81411: PUSH
81412: LD_INT 1
81414: ARRAY
81415: PPUSH
81416: LD_VAR 0 16
81420: PUSH
81421: LD_VAR 0 7
81425: ARRAY
81426: PUSH
81427: LD_INT 1
81429: ARRAY
81430: PUSH
81431: LD_INT 2
81433: ARRAY
81434: PPUSH
81435: CALL_OW 114
// end else
81439: GO 81492
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
81441: LD_ADDR_VAR 0 15
81445: PUSH
81446: LD_VAR 0 16
81450: PUSH
81451: LD_VAR 0 7
81455: ARRAY
81456: PPUSH
81457: LD_INT 1
81459: PPUSH
81460: CALL_OW 3
81464: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
81465: LD_ADDR_VAR 0 16
81469: PUSH
81470: LD_VAR 0 16
81474: PPUSH
81475: LD_VAR 0 7
81479: PPUSH
81480: LD_VAR 0 15
81484: PPUSH
81485: CALL_OW 1
81489: ST_TO_ADDR
// continue ;
81490: GO 80035
// end ; end ; end else
81492: GO 84130
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
81494: LD_ADDR_VAR 0 14
81498: PUSH
81499: LD_INT 81
81501: PUSH
81502: LD_VAR 0 4
81506: PUSH
81507: LD_VAR 0 7
81511: ARRAY
81512: PPUSH
81513: CALL_OW 255
81517: PUSH
81518: EMPTY
81519: LIST
81520: LIST
81521: PPUSH
81522: CALL_OW 69
81526: ST_TO_ADDR
// if not tmp then
81527: LD_VAR 0 14
81531: NOT
81532: IFFALSE 81536
// continue ;
81534: GO 80035
// if f_ignore_area then
81536: LD_VAR 0 17
81540: IFFALSE 81628
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
81542: LD_ADDR_VAR 0 15
81546: PUSH
81547: LD_VAR 0 14
81551: PPUSH
81552: LD_INT 3
81554: PUSH
81555: LD_INT 92
81557: PUSH
81558: LD_VAR 0 17
81562: PUSH
81563: LD_INT 1
81565: ARRAY
81566: PUSH
81567: LD_VAR 0 17
81571: PUSH
81572: LD_INT 2
81574: ARRAY
81575: PUSH
81576: LD_VAR 0 17
81580: PUSH
81581: LD_INT 3
81583: ARRAY
81584: PUSH
81585: EMPTY
81586: LIST
81587: LIST
81588: LIST
81589: LIST
81590: PUSH
81591: EMPTY
81592: LIST
81593: LIST
81594: PPUSH
81595: CALL_OW 72
81599: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
81600: LD_VAR 0 14
81604: PUSH
81605: LD_VAR 0 15
81609: DIFF
81610: IFFALSE 81628
// tmp := tmp diff tmp2 ;
81612: LD_ADDR_VAR 0 14
81616: PUSH
81617: LD_VAR 0 14
81621: PUSH
81622: LD_VAR 0 15
81626: DIFF
81627: ST_TO_ADDR
// end ; if not f_murder then
81628: LD_VAR 0 20
81632: NOT
81633: IFFALSE 81691
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
81635: LD_ADDR_VAR 0 15
81639: PUSH
81640: LD_VAR 0 14
81644: PPUSH
81645: LD_INT 3
81647: PUSH
81648: LD_INT 50
81650: PUSH
81651: EMPTY
81652: LIST
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PPUSH
81658: CALL_OW 72
81662: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
81663: LD_VAR 0 14
81667: PUSH
81668: LD_VAR 0 15
81672: DIFF
81673: IFFALSE 81691
// tmp := tmp diff tmp2 ;
81675: LD_ADDR_VAR 0 14
81679: PUSH
81680: LD_VAR 0 14
81684: PUSH
81685: LD_VAR 0 15
81689: DIFF
81690: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
81691: LD_ADDR_VAR 0 14
81695: PUSH
81696: LD_VAR 0 4
81700: PUSH
81701: LD_VAR 0 7
81705: ARRAY
81706: PPUSH
81707: LD_VAR 0 14
81711: PPUSH
81712: LD_INT 1
81714: PPUSH
81715: LD_INT 1
81717: PPUSH
81718: CALL 51500 0 4
81722: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
81723: LD_VAR 0 4
81727: PUSH
81728: LD_VAR 0 7
81732: ARRAY
81733: PPUSH
81734: CALL_OW 257
81738: PUSH
81739: LD_INT 1
81741: EQUAL
81742: IFFALSE 82190
// begin if WantPlant ( group [ i ] ) then
81744: LD_VAR 0 4
81748: PUSH
81749: LD_VAR 0 7
81753: ARRAY
81754: PPUSH
81755: CALL 51001 0 1
81759: IFFALSE 81763
// continue ;
81761: GO 80035
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
81763: LD_VAR 0 18
81767: PUSH
81768: LD_VAR 0 4
81772: PUSH
81773: LD_VAR 0 7
81777: ARRAY
81778: PPUSH
81779: CALL_OW 310
81783: NOT
81784: AND
81785: PUSH
81786: LD_VAR 0 14
81790: PUSH
81791: LD_INT 1
81793: ARRAY
81794: PUSH
81795: LD_VAR 0 14
81799: PPUSH
81800: LD_INT 21
81802: PUSH
81803: LD_INT 2
81805: PUSH
81806: EMPTY
81807: LIST
81808: LIST
81809: PUSH
81810: LD_INT 58
81812: PUSH
81813: EMPTY
81814: LIST
81815: PUSH
81816: EMPTY
81817: LIST
81818: LIST
81819: PPUSH
81820: CALL_OW 72
81824: IN
81825: AND
81826: IFFALSE 81862
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
81828: LD_VAR 0 4
81832: PUSH
81833: LD_VAR 0 7
81837: ARRAY
81838: PPUSH
81839: LD_VAR 0 14
81843: PUSH
81844: LD_INT 1
81846: ARRAY
81847: PPUSH
81848: CALL_OW 120
// attacking := true ;
81852: LD_ADDR_VAR 0 29
81856: PUSH
81857: LD_INT 1
81859: ST_TO_ADDR
// continue ;
81860: GO 80035
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
81862: LD_VAR 0 26
81866: PUSH
81867: LD_VAR 0 4
81871: PUSH
81872: LD_VAR 0 7
81876: ARRAY
81877: PPUSH
81878: CALL_OW 257
81882: PUSH
81883: LD_INT 1
81885: EQUAL
81886: AND
81887: PUSH
81888: LD_VAR 0 4
81892: PUSH
81893: LD_VAR 0 7
81897: ARRAY
81898: PPUSH
81899: CALL_OW 256
81903: PUSH
81904: LD_INT 800
81906: LESS
81907: AND
81908: PUSH
81909: LD_VAR 0 4
81913: PUSH
81914: LD_VAR 0 7
81918: ARRAY
81919: PPUSH
81920: CALL_OW 318
81924: NOT
81925: AND
81926: IFFALSE 81943
// ComCrawl ( group [ i ] ) ;
81928: LD_VAR 0 4
81932: PUSH
81933: LD_VAR 0 7
81937: ARRAY
81938: PPUSH
81939: CALL_OW 137
// if f_mines then
81943: LD_VAR 0 21
81947: IFFALSE 82190
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
81949: LD_VAR 0 14
81953: PUSH
81954: LD_INT 1
81956: ARRAY
81957: PPUSH
81958: CALL_OW 247
81962: PUSH
81963: LD_INT 3
81965: EQUAL
81966: PUSH
81967: LD_VAR 0 14
81971: PUSH
81972: LD_INT 1
81974: ARRAY
81975: PUSH
81976: LD_VAR 0 27
81980: IN
81981: NOT
81982: AND
81983: IFFALSE 82190
// begin x := GetX ( tmp [ 1 ] ) ;
81985: LD_ADDR_VAR 0 10
81989: PUSH
81990: LD_VAR 0 14
81994: PUSH
81995: LD_INT 1
81997: ARRAY
81998: PPUSH
81999: CALL_OW 250
82003: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
82004: LD_ADDR_VAR 0 11
82008: PUSH
82009: LD_VAR 0 14
82013: PUSH
82014: LD_INT 1
82016: ARRAY
82017: PPUSH
82018: CALL_OW 251
82022: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
82023: LD_ADDR_VAR 0 12
82027: PUSH
82028: LD_VAR 0 4
82032: PUSH
82033: LD_VAR 0 7
82037: ARRAY
82038: PPUSH
82039: CALL 77918 0 1
82043: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
82044: LD_VAR 0 4
82048: PUSH
82049: LD_VAR 0 7
82053: ARRAY
82054: PPUSH
82055: LD_VAR 0 10
82059: PPUSH
82060: LD_VAR 0 11
82064: PPUSH
82065: LD_VAR 0 14
82069: PUSH
82070: LD_INT 1
82072: ARRAY
82073: PPUSH
82074: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
82078: LD_VAR 0 4
82082: PUSH
82083: LD_VAR 0 7
82087: ARRAY
82088: PPUSH
82089: LD_VAR 0 10
82093: PPUSH
82094: LD_VAR 0 12
82098: PPUSH
82099: LD_INT 7
82101: PPUSH
82102: CALL_OW 272
82106: PPUSH
82107: LD_VAR 0 11
82111: PPUSH
82112: LD_VAR 0 12
82116: PPUSH
82117: LD_INT 7
82119: PPUSH
82120: CALL_OW 273
82124: PPUSH
82125: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
82129: LD_VAR 0 4
82133: PUSH
82134: LD_VAR 0 7
82138: ARRAY
82139: PPUSH
82140: LD_INT 71
82142: PPUSH
82143: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
82147: LD_ADDR_VAR 0 27
82151: PUSH
82152: LD_VAR 0 27
82156: PPUSH
82157: LD_VAR 0 27
82161: PUSH
82162: LD_INT 1
82164: PLUS
82165: PPUSH
82166: LD_VAR 0 14
82170: PUSH
82171: LD_INT 1
82173: ARRAY
82174: PPUSH
82175: CALL_OW 1
82179: ST_TO_ADDR
// attacking := true ;
82180: LD_ADDR_VAR 0 29
82184: PUSH
82185: LD_INT 1
82187: ST_TO_ADDR
// continue ;
82188: GO 80035
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
82190: LD_VAR 0 4
82194: PUSH
82195: LD_VAR 0 7
82199: ARRAY
82200: PPUSH
82201: CALL_OW 257
82205: PUSH
82206: LD_INT 17
82208: EQUAL
82209: PUSH
82210: LD_VAR 0 4
82214: PUSH
82215: LD_VAR 0 7
82219: ARRAY
82220: PPUSH
82221: CALL_OW 110
82225: PUSH
82226: LD_INT 71
82228: EQUAL
82229: NOT
82230: AND
82231: IFFALSE 82377
// begin attacking := false ;
82233: LD_ADDR_VAR 0 29
82237: PUSH
82238: LD_INT 0
82240: ST_TO_ADDR
// k := 5 ;
82241: LD_ADDR_VAR 0 9
82245: PUSH
82246: LD_INT 5
82248: ST_TO_ADDR
// if tmp < k then
82249: LD_VAR 0 14
82253: PUSH
82254: LD_VAR 0 9
82258: LESS
82259: IFFALSE 82271
// k := tmp ;
82261: LD_ADDR_VAR 0 9
82265: PUSH
82266: LD_VAR 0 14
82270: ST_TO_ADDR
// for j = 1 to k do
82271: LD_ADDR_VAR 0 8
82275: PUSH
82276: DOUBLE
82277: LD_INT 1
82279: DEC
82280: ST_TO_ADDR
82281: LD_VAR 0 9
82285: PUSH
82286: FOR_TO
82287: IFFALSE 82375
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
82289: LD_VAR 0 14
82293: PUSH
82294: LD_VAR 0 8
82298: ARRAY
82299: PUSH
82300: LD_VAR 0 14
82304: PPUSH
82305: LD_INT 58
82307: PUSH
82308: EMPTY
82309: LIST
82310: PPUSH
82311: CALL_OW 72
82315: IN
82316: NOT
82317: IFFALSE 82373
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
82319: LD_VAR 0 4
82323: PUSH
82324: LD_VAR 0 7
82328: ARRAY
82329: PPUSH
82330: LD_VAR 0 14
82334: PUSH
82335: LD_VAR 0 8
82339: ARRAY
82340: PPUSH
82341: CALL_OW 115
// attacking := true ;
82345: LD_ADDR_VAR 0 29
82349: PUSH
82350: LD_INT 1
82352: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
82353: LD_VAR 0 4
82357: PUSH
82358: LD_VAR 0 7
82362: ARRAY
82363: PPUSH
82364: LD_INT 71
82366: PPUSH
82367: CALL_OW 109
// continue ;
82371: GO 82286
// end ; end ;
82373: GO 82286
82375: POP
82376: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
82377: LD_VAR 0 4
82381: PUSH
82382: LD_VAR 0 7
82386: ARRAY
82387: PPUSH
82388: CALL_OW 257
82392: PUSH
82393: LD_INT 8
82395: EQUAL
82396: PUSH
82397: LD_VAR 0 4
82401: PUSH
82402: LD_VAR 0 7
82406: ARRAY
82407: PPUSH
82408: CALL_OW 264
82412: PUSH
82413: LD_INT 28
82415: PUSH
82416: LD_INT 45
82418: PUSH
82419: LD_INT 7
82421: PUSH
82422: LD_INT 47
82424: PUSH
82425: EMPTY
82426: LIST
82427: LIST
82428: LIST
82429: LIST
82430: IN
82431: OR
82432: IFFALSE 82662
// begin attacking := false ;
82434: LD_ADDR_VAR 0 29
82438: PUSH
82439: LD_INT 0
82441: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
82442: LD_VAR 0 14
82446: PUSH
82447: LD_INT 1
82449: ARRAY
82450: PPUSH
82451: CALL_OW 266
82455: PUSH
82456: LD_INT 32
82458: PUSH
82459: LD_INT 31
82461: PUSH
82462: LD_INT 33
82464: PUSH
82465: LD_INT 4
82467: PUSH
82468: LD_INT 5
82470: PUSH
82471: EMPTY
82472: LIST
82473: LIST
82474: LIST
82475: LIST
82476: LIST
82477: IN
82478: IFFALSE 82662
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
82480: LD_ADDR_VAR 0 9
82484: PUSH
82485: LD_VAR 0 14
82489: PUSH
82490: LD_INT 1
82492: ARRAY
82493: PPUSH
82494: CALL_OW 266
82498: PPUSH
82499: LD_VAR 0 14
82503: PUSH
82504: LD_INT 1
82506: ARRAY
82507: PPUSH
82508: CALL_OW 250
82512: PPUSH
82513: LD_VAR 0 14
82517: PUSH
82518: LD_INT 1
82520: ARRAY
82521: PPUSH
82522: CALL_OW 251
82526: PPUSH
82527: LD_VAR 0 14
82531: PUSH
82532: LD_INT 1
82534: ARRAY
82535: PPUSH
82536: CALL_OW 254
82540: PPUSH
82541: LD_VAR 0 14
82545: PUSH
82546: LD_INT 1
82548: ARRAY
82549: PPUSH
82550: CALL_OW 248
82554: PPUSH
82555: LD_INT 0
82557: PPUSH
82558: CALL 59294 0 6
82562: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
82563: LD_ADDR_VAR 0 8
82567: PUSH
82568: LD_VAR 0 4
82572: PUSH
82573: LD_VAR 0 7
82577: ARRAY
82578: PPUSH
82579: LD_VAR 0 9
82583: PPUSH
82584: CALL 77981 0 2
82588: ST_TO_ADDR
// if j then
82589: LD_VAR 0 8
82593: IFFALSE 82662
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
82595: LD_VAR 0 8
82599: PUSH
82600: LD_INT 1
82602: ARRAY
82603: PPUSH
82604: LD_VAR 0 8
82608: PUSH
82609: LD_INT 2
82611: ARRAY
82612: PPUSH
82613: CALL_OW 488
82617: IFFALSE 82662
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
82619: LD_VAR 0 4
82623: PUSH
82624: LD_VAR 0 7
82628: ARRAY
82629: PPUSH
82630: LD_VAR 0 8
82634: PUSH
82635: LD_INT 1
82637: ARRAY
82638: PPUSH
82639: LD_VAR 0 8
82643: PUSH
82644: LD_INT 2
82646: ARRAY
82647: PPUSH
82648: CALL_OW 116
// attacking := true ;
82652: LD_ADDR_VAR 0 29
82656: PUSH
82657: LD_INT 1
82659: ST_TO_ADDR
// continue ;
82660: GO 80035
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
82662: LD_VAR 0 4
82666: PUSH
82667: LD_VAR 0 7
82671: ARRAY
82672: PPUSH
82673: CALL_OW 265
82677: PUSH
82678: LD_INT 11
82680: EQUAL
82681: IFFALSE 82959
// begin k := 10 ;
82683: LD_ADDR_VAR 0 9
82687: PUSH
82688: LD_INT 10
82690: ST_TO_ADDR
// x := 0 ;
82691: LD_ADDR_VAR 0 10
82695: PUSH
82696: LD_INT 0
82698: ST_TO_ADDR
// if tmp < k then
82699: LD_VAR 0 14
82703: PUSH
82704: LD_VAR 0 9
82708: LESS
82709: IFFALSE 82721
// k := tmp ;
82711: LD_ADDR_VAR 0 9
82715: PUSH
82716: LD_VAR 0 14
82720: ST_TO_ADDR
// for j = k downto 1 do
82721: LD_ADDR_VAR 0 8
82725: PUSH
82726: DOUBLE
82727: LD_VAR 0 9
82731: INC
82732: ST_TO_ADDR
82733: LD_INT 1
82735: PUSH
82736: FOR_DOWNTO
82737: IFFALSE 82812
// begin if GetType ( tmp [ j ] ) = unit_human then
82739: LD_VAR 0 14
82743: PUSH
82744: LD_VAR 0 8
82748: ARRAY
82749: PPUSH
82750: CALL_OW 247
82754: PUSH
82755: LD_INT 1
82757: EQUAL
82758: IFFALSE 82810
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
82760: LD_VAR 0 4
82764: PUSH
82765: LD_VAR 0 7
82769: ARRAY
82770: PPUSH
82771: LD_VAR 0 14
82775: PUSH
82776: LD_VAR 0 8
82780: ARRAY
82781: PPUSH
82782: CALL 78252 0 2
// x := tmp [ j ] ;
82786: LD_ADDR_VAR 0 10
82790: PUSH
82791: LD_VAR 0 14
82795: PUSH
82796: LD_VAR 0 8
82800: ARRAY
82801: ST_TO_ADDR
// attacking := true ;
82802: LD_ADDR_VAR 0 29
82806: PUSH
82807: LD_INT 1
82809: ST_TO_ADDR
// end ; end ;
82810: GO 82736
82812: POP
82813: POP
// if not x then
82814: LD_VAR 0 10
82818: NOT
82819: IFFALSE 82959
// begin attacking := true ;
82821: LD_ADDR_VAR 0 29
82825: PUSH
82826: LD_INT 1
82828: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
82829: LD_VAR 0 4
82833: PUSH
82834: LD_VAR 0 7
82838: ARRAY
82839: PPUSH
82840: CALL_OW 250
82844: PPUSH
82845: LD_VAR 0 4
82849: PUSH
82850: LD_VAR 0 7
82854: ARRAY
82855: PPUSH
82856: CALL_OW 251
82860: PPUSH
82861: CALL_OW 546
82865: PUSH
82866: LD_INT 2
82868: ARRAY
82869: PUSH
82870: LD_VAR 0 14
82874: PUSH
82875: LD_INT 1
82877: ARRAY
82878: PPUSH
82879: CALL_OW 250
82883: PPUSH
82884: LD_VAR 0 14
82888: PUSH
82889: LD_INT 1
82891: ARRAY
82892: PPUSH
82893: CALL_OW 251
82897: PPUSH
82898: CALL_OW 546
82902: PUSH
82903: LD_INT 2
82905: ARRAY
82906: EQUAL
82907: IFFALSE 82935
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
82909: LD_VAR 0 4
82913: PUSH
82914: LD_VAR 0 7
82918: ARRAY
82919: PPUSH
82920: LD_VAR 0 14
82924: PUSH
82925: LD_INT 1
82927: ARRAY
82928: PPUSH
82929: CALL 78252 0 2
82933: GO 82959
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82935: LD_VAR 0 4
82939: PUSH
82940: LD_VAR 0 7
82944: ARRAY
82945: PPUSH
82946: LD_VAR 0 14
82950: PUSH
82951: LD_INT 1
82953: ARRAY
82954: PPUSH
82955: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
82959: LD_VAR 0 4
82963: PUSH
82964: LD_VAR 0 7
82968: ARRAY
82969: PPUSH
82970: CALL_OW 264
82974: PUSH
82975: LD_INT 29
82977: EQUAL
82978: IFFALSE 83344
// begin if WantsToAttack ( group [ i ] ) in bombed then
82980: LD_VAR 0 4
82984: PUSH
82985: LD_VAR 0 7
82989: ARRAY
82990: PPUSH
82991: CALL_OW 319
82995: PUSH
82996: LD_VAR 0 28
83000: IN
83001: IFFALSE 83005
// continue ;
83003: GO 80035
// k := 8 ;
83005: LD_ADDR_VAR 0 9
83009: PUSH
83010: LD_INT 8
83012: ST_TO_ADDR
// x := 0 ;
83013: LD_ADDR_VAR 0 10
83017: PUSH
83018: LD_INT 0
83020: ST_TO_ADDR
// if tmp < k then
83021: LD_VAR 0 14
83025: PUSH
83026: LD_VAR 0 9
83030: LESS
83031: IFFALSE 83043
// k := tmp ;
83033: LD_ADDR_VAR 0 9
83037: PUSH
83038: LD_VAR 0 14
83042: ST_TO_ADDR
// for j = 1 to k do
83043: LD_ADDR_VAR 0 8
83047: PUSH
83048: DOUBLE
83049: LD_INT 1
83051: DEC
83052: ST_TO_ADDR
83053: LD_VAR 0 9
83057: PUSH
83058: FOR_TO
83059: IFFALSE 83191
// begin if GetType ( tmp [ j ] ) = unit_building then
83061: LD_VAR 0 14
83065: PUSH
83066: LD_VAR 0 8
83070: ARRAY
83071: PPUSH
83072: CALL_OW 247
83076: PUSH
83077: LD_INT 3
83079: EQUAL
83080: IFFALSE 83189
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
83082: LD_VAR 0 14
83086: PUSH
83087: LD_VAR 0 8
83091: ARRAY
83092: PUSH
83093: LD_VAR 0 28
83097: IN
83098: NOT
83099: PUSH
83100: LD_VAR 0 14
83104: PUSH
83105: LD_VAR 0 8
83109: ARRAY
83110: PPUSH
83111: CALL_OW 313
83115: AND
83116: IFFALSE 83189
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83118: LD_VAR 0 4
83122: PUSH
83123: LD_VAR 0 7
83127: ARRAY
83128: PPUSH
83129: LD_VAR 0 14
83133: PUSH
83134: LD_VAR 0 8
83138: ARRAY
83139: PPUSH
83140: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
83144: LD_ADDR_VAR 0 28
83148: PUSH
83149: LD_VAR 0 28
83153: PPUSH
83154: LD_VAR 0 28
83158: PUSH
83159: LD_INT 1
83161: PLUS
83162: PPUSH
83163: LD_VAR 0 14
83167: PUSH
83168: LD_VAR 0 8
83172: ARRAY
83173: PPUSH
83174: CALL_OW 1
83178: ST_TO_ADDR
// attacking := true ;
83179: LD_ADDR_VAR 0 29
83183: PUSH
83184: LD_INT 1
83186: ST_TO_ADDR
// break ;
83187: GO 83191
// end ; end ;
83189: GO 83058
83191: POP
83192: POP
// if not attacking and f_attack_depot then
83193: LD_VAR 0 29
83197: NOT
83198: PUSH
83199: LD_VAR 0 25
83203: AND
83204: IFFALSE 83299
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83206: LD_ADDR_VAR 0 13
83210: PUSH
83211: LD_VAR 0 14
83215: PPUSH
83216: LD_INT 2
83218: PUSH
83219: LD_INT 30
83221: PUSH
83222: LD_INT 0
83224: PUSH
83225: EMPTY
83226: LIST
83227: LIST
83228: PUSH
83229: LD_INT 30
83231: PUSH
83232: LD_INT 1
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: PUSH
83239: EMPTY
83240: LIST
83241: LIST
83242: LIST
83243: PPUSH
83244: CALL_OW 72
83248: ST_TO_ADDR
// if z then
83249: LD_VAR 0 13
83253: IFFALSE 83299
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
83255: LD_VAR 0 4
83259: PUSH
83260: LD_VAR 0 7
83264: ARRAY
83265: PPUSH
83266: LD_VAR 0 13
83270: PPUSH
83271: LD_VAR 0 4
83275: PUSH
83276: LD_VAR 0 7
83280: ARRAY
83281: PPUSH
83282: CALL_OW 74
83286: PPUSH
83287: CALL_OW 115
// attacking := true ;
83291: LD_ADDR_VAR 0 29
83295: PUSH
83296: LD_INT 1
83298: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
83299: LD_VAR 0 4
83303: PUSH
83304: LD_VAR 0 7
83308: ARRAY
83309: PPUSH
83310: CALL_OW 256
83314: PUSH
83315: LD_INT 500
83317: LESS
83318: IFFALSE 83344
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83320: LD_VAR 0 4
83324: PUSH
83325: LD_VAR 0 7
83329: ARRAY
83330: PPUSH
83331: LD_VAR 0 14
83335: PUSH
83336: LD_INT 1
83338: ARRAY
83339: PPUSH
83340: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
83344: LD_VAR 0 4
83348: PUSH
83349: LD_VAR 0 7
83353: ARRAY
83354: PPUSH
83355: CALL_OW 264
83359: PUSH
83360: LD_INT 49
83362: EQUAL
83363: IFFALSE 83484
// begin if not HasTask ( group [ i ] ) then
83365: LD_VAR 0 4
83369: PUSH
83370: LD_VAR 0 7
83374: ARRAY
83375: PPUSH
83376: CALL_OW 314
83380: NOT
83381: IFFALSE 83484
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
83383: LD_ADDR_VAR 0 9
83387: PUSH
83388: LD_INT 81
83390: PUSH
83391: LD_VAR 0 4
83395: PUSH
83396: LD_VAR 0 7
83400: ARRAY
83401: PPUSH
83402: CALL_OW 255
83406: PUSH
83407: EMPTY
83408: LIST
83409: LIST
83410: PPUSH
83411: CALL_OW 69
83415: PPUSH
83416: LD_VAR 0 4
83420: PUSH
83421: LD_VAR 0 7
83425: ARRAY
83426: PPUSH
83427: CALL_OW 74
83431: ST_TO_ADDR
// if k then
83432: LD_VAR 0 9
83436: IFFALSE 83484
// if GetDistUnits ( group [ i ] , k ) > 10 then
83438: LD_VAR 0 4
83442: PUSH
83443: LD_VAR 0 7
83447: ARRAY
83448: PPUSH
83449: LD_VAR 0 9
83453: PPUSH
83454: CALL_OW 296
83458: PUSH
83459: LD_INT 10
83461: GREATER
83462: IFFALSE 83484
// ComMoveUnit ( group [ i ] , k ) ;
83464: LD_VAR 0 4
83468: PUSH
83469: LD_VAR 0 7
83473: ARRAY
83474: PPUSH
83475: LD_VAR 0 9
83479: PPUSH
83480: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
83484: LD_VAR 0 4
83488: PUSH
83489: LD_VAR 0 7
83493: ARRAY
83494: PPUSH
83495: CALL_OW 256
83499: PUSH
83500: LD_INT 250
83502: LESS
83503: PUSH
83504: LD_VAR 0 4
83508: PUSH
83509: LD_VAR 0 7
83513: ARRAY
83514: PUSH
83515: LD_INT 21
83517: PUSH
83518: LD_INT 2
83520: PUSH
83521: EMPTY
83522: LIST
83523: LIST
83524: PUSH
83525: LD_INT 23
83527: PUSH
83528: LD_INT 2
83530: PUSH
83531: EMPTY
83532: LIST
83533: LIST
83534: PUSH
83535: EMPTY
83536: LIST
83537: LIST
83538: PPUSH
83539: CALL_OW 69
83543: IN
83544: AND
83545: IFFALSE 83670
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
83547: LD_ADDR_VAR 0 9
83551: PUSH
83552: LD_OWVAR 3
83556: PUSH
83557: LD_VAR 0 4
83561: PUSH
83562: LD_VAR 0 7
83566: ARRAY
83567: DIFF
83568: PPUSH
83569: LD_VAR 0 4
83573: PUSH
83574: LD_VAR 0 7
83578: ARRAY
83579: PPUSH
83580: CALL_OW 74
83584: ST_TO_ADDR
// if not k then
83585: LD_VAR 0 9
83589: NOT
83590: IFFALSE 83594
// continue ;
83592: GO 80035
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
83594: LD_VAR 0 9
83598: PUSH
83599: LD_INT 81
83601: PUSH
83602: LD_VAR 0 4
83606: PUSH
83607: LD_VAR 0 7
83611: ARRAY
83612: PPUSH
83613: CALL_OW 255
83617: PUSH
83618: EMPTY
83619: LIST
83620: LIST
83621: PPUSH
83622: CALL_OW 69
83626: IN
83627: PUSH
83628: LD_VAR 0 9
83632: PPUSH
83633: LD_VAR 0 4
83637: PUSH
83638: LD_VAR 0 7
83642: ARRAY
83643: PPUSH
83644: CALL_OW 296
83648: PUSH
83649: LD_INT 5
83651: LESS
83652: AND
83653: IFFALSE 83670
// ComAutodestruct ( group [ i ] ) ;
83655: LD_VAR 0 4
83659: PUSH
83660: LD_VAR 0 7
83664: ARRAY
83665: PPUSH
83666: CALL 78150 0 1
// end ; if f_attack_depot then
83670: LD_VAR 0 25
83674: IFFALSE 83786
// begin k := 6 ;
83676: LD_ADDR_VAR 0 9
83680: PUSH
83681: LD_INT 6
83683: ST_TO_ADDR
// if tmp < k then
83684: LD_VAR 0 14
83688: PUSH
83689: LD_VAR 0 9
83693: LESS
83694: IFFALSE 83706
// k := tmp ;
83696: LD_ADDR_VAR 0 9
83700: PUSH
83701: LD_VAR 0 14
83705: ST_TO_ADDR
// for j = 1 to k do
83706: LD_ADDR_VAR 0 8
83710: PUSH
83711: DOUBLE
83712: LD_INT 1
83714: DEC
83715: ST_TO_ADDR
83716: LD_VAR 0 9
83720: PUSH
83721: FOR_TO
83722: IFFALSE 83784
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
83724: LD_VAR 0 8
83728: PPUSH
83729: CALL_OW 266
83733: PUSH
83734: LD_INT 0
83736: PUSH
83737: LD_INT 1
83739: PUSH
83740: EMPTY
83741: LIST
83742: LIST
83743: IN
83744: IFFALSE 83782
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83746: LD_VAR 0 4
83750: PUSH
83751: LD_VAR 0 7
83755: ARRAY
83756: PPUSH
83757: LD_VAR 0 14
83761: PUSH
83762: LD_VAR 0 8
83766: ARRAY
83767: PPUSH
83768: CALL_OW 115
// attacking := true ;
83772: LD_ADDR_VAR 0 29
83776: PUSH
83777: LD_INT 1
83779: ST_TO_ADDR
// break ;
83780: GO 83784
// end ;
83782: GO 83721
83784: POP
83785: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
83786: LD_VAR 0 4
83790: PUSH
83791: LD_VAR 0 7
83795: ARRAY
83796: PPUSH
83797: CALL_OW 302
83801: PUSH
83802: LD_VAR 0 29
83806: NOT
83807: AND
83808: IFFALSE 84130
// begin if GetTag ( group [ i ] ) = 71 then
83810: LD_VAR 0 4
83814: PUSH
83815: LD_VAR 0 7
83819: ARRAY
83820: PPUSH
83821: CALL_OW 110
83825: PUSH
83826: LD_INT 71
83828: EQUAL
83829: IFFALSE 83870
// begin if HasTask ( group [ i ] ) then
83831: LD_VAR 0 4
83835: PUSH
83836: LD_VAR 0 7
83840: ARRAY
83841: PPUSH
83842: CALL_OW 314
83846: IFFALSE 83852
// continue else
83848: GO 80035
83850: GO 83870
// SetTag ( group [ i ] , 0 ) ;
83852: LD_VAR 0 4
83856: PUSH
83857: LD_VAR 0 7
83861: ARRAY
83862: PPUSH
83863: LD_INT 0
83865: PPUSH
83866: CALL_OW 109
// end ; k := 8 ;
83870: LD_ADDR_VAR 0 9
83874: PUSH
83875: LD_INT 8
83877: ST_TO_ADDR
// x := 0 ;
83878: LD_ADDR_VAR 0 10
83882: PUSH
83883: LD_INT 0
83885: ST_TO_ADDR
// if tmp < k then
83886: LD_VAR 0 14
83890: PUSH
83891: LD_VAR 0 9
83895: LESS
83896: IFFALSE 83908
// k := tmp ;
83898: LD_ADDR_VAR 0 9
83902: PUSH
83903: LD_VAR 0 14
83907: ST_TO_ADDR
// for j = 1 to k do
83908: LD_ADDR_VAR 0 8
83912: PUSH
83913: DOUBLE
83914: LD_INT 1
83916: DEC
83917: ST_TO_ADDR
83918: LD_VAR 0 9
83922: PUSH
83923: FOR_TO
83924: IFFALSE 84022
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
83926: LD_VAR 0 14
83930: PUSH
83931: LD_VAR 0 8
83935: ARRAY
83936: PPUSH
83937: CALL_OW 247
83941: PUSH
83942: LD_INT 1
83944: EQUAL
83945: PUSH
83946: LD_VAR 0 14
83950: PUSH
83951: LD_VAR 0 8
83955: ARRAY
83956: PPUSH
83957: CALL_OW 256
83961: PUSH
83962: LD_INT 250
83964: LESS
83965: PUSH
83966: LD_VAR 0 20
83970: AND
83971: PUSH
83972: LD_VAR 0 20
83976: NOT
83977: PUSH
83978: LD_VAR 0 14
83982: PUSH
83983: LD_VAR 0 8
83987: ARRAY
83988: PPUSH
83989: CALL_OW 256
83993: PUSH
83994: LD_INT 250
83996: GREATEREQUAL
83997: AND
83998: OR
83999: AND
84000: IFFALSE 84020
// begin x := tmp [ j ] ;
84002: LD_ADDR_VAR 0 10
84006: PUSH
84007: LD_VAR 0 14
84011: PUSH
84012: LD_VAR 0 8
84016: ARRAY
84017: ST_TO_ADDR
// break ;
84018: GO 84022
// end ;
84020: GO 83923
84022: POP
84023: POP
// if x then
84024: LD_VAR 0 10
84028: IFFALSE 84052
// ComAttackUnit ( group [ i ] , x ) else
84030: LD_VAR 0 4
84034: PUSH
84035: LD_VAR 0 7
84039: ARRAY
84040: PPUSH
84041: LD_VAR 0 10
84045: PPUSH
84046: CALL_OW 115
84050: GO 84076
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84052: LD_VAR 0 4
84056: PUSH
84057: LD_VAR 0 7
84061: ARRAY
84062: PPUSH
84063: LD_VAR 0 14
84067: PUSH
84068: LD_INT 1
84070: ARRAY
84071: PPUSH
84072: CALL_OW 115
// if not HasTask ( group [ i ] ) then
84076: LD_VAR 0 4
84080: PUSH
84081: LD_VAR 0 7
84085: ARRAY
84086: PPUSH
84087: CALL_OW 314
84091: NOT
84092: IFFALSE 84130
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
84094: LD_VAR 0 4
84098: PUSH
84099: LD_VAR 0 7
84103: ARRAY
84104: PPUSH
84105: LD_VAR 0 14
84109: PPUSH
84110: LD_VAR 0 4
84114: PUSH
84115: LD_VAR 0 7
84119: ARRAY
84120: PPUSH
84121: CALL_OW 74
84125: PPUSH
84126: CALL_OW 115
// end ; end ; end ;
84130: GO 80035
84132: POP
84133: POP
// wait ( 0 0$1 ) ;
84134: LD_INT 35
84136: PPUSH
84137: CALL_OW 67
// until group = [ ] ;
84141: LD_VAR 0 4
84145: PUSH
84146: EMPTY
84147: EQUAL
84148: IFFALSE 80020
// end ;
84150: LD_VAR 0 2
84154: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84155: LD_INT 0
84157: PPUSH
84158: PPUSH
84159: PPUSH
84160: PPUSH
// if not base_units then
84161: LD_VAR 0 1
84165: NOT
84166: IFFALSE 84170
// exit ;
84168: GO 84257
// result := false ;
84170: LD_ADDR_VAR 0 2
84174: PUSH
84175: LD_INT 0
84177: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84178: LD_ADDR_VAR 0 5
84182: PUSH
84183: LD_VAR 0 1
84187: PPUSH
84188: LD_INT 21
84190: PUSH
84191: LD_INT 3
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PPUSH
84198: CALL_OW 72
84202: ST_TO_ADDR
// if not tmp then
84203: LD_VAR 0 5
84207: NOT
84208: IFFALSE 84212
// exit ;
84210: GO 84257
// for i in tmp do
84212: LD_ADDR_VAR 0 3
84216: PUSH
84217: LD_VAR 0 5
84221: PUSH
84222: FOR_IN
84223: IFFALSE 84255
// begin result := EnemyInRange ( i , 22 ) ;
84225: LD_ADDR_VAR 0 2
84229: PUSH
84230: LD_VAR 0 3
84234: PPUSH
84235: LD_INT 22
84237: PPUSH
84238: CALL 77833 0 2
84242: ST_TO_ADDR
// if result then
84243: LD_VAR 0 2
84247: IFFALSE 84253
// exit ;
84249: POP
84250: POP
84251: GO 84257
// end ;
84253: GO 84222
84255: POP
84256: POP
// end ;
84257: LD_VAR 0 2
84261: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
84262: LD_INT 0
84264: PPUSH
84265: PPUSH
// if not units then
84266: LD_VAR 0 1
84270: NOT
84271: IFFALSE 84275
// exit ;
84273: GO 84345
// result := [ ] ;
84275: LD_ADDR_VAR 0 3
84279: PUSH
84280: EMPTY
84281: ST_TO_ADDR
// for i in units do
84282: LD_ADDR_VAR 0 4
84286: PUSH
84287: LD_VAR 0 1
84291: PUSH
84292: FOR_IN
84293: IFFALSE 84343
// if GetTag ( i ) = tag then
84295: LD_VAR 0 4
84299: PPUSH
84300: CALL_OW 110
84304: PUSH
84305: LD_VAR 0 2
84309: EQUAL
84310: IFFALSE 84341
// result := Insert ( result , result + 1 , i ) ;
84312: LD_ADDR_VAR 0 3
84316: PUSH
84317: LD_VAR 0 3
84321: PPUSH
84322: LD_VAR 0 3
84326: PUSH
84327: LD_INT 1
84329: PLUS
84330: PPUSH
84331: LD_VAR 0 4
84335: PPUSH
84336: CALL_OW 2
84340: ST_TO_ADDR
84341: GO 84292
84343: POP
84344: POP
// end ;
84345: LD_VAR 0 3
84349: RET
// export function IsDriver ( un ) ; begin
84350: LD_INT 0
84352: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84353: LD_ADDR_VAR 0 2
84357: PUSH
84358: LD_VAR 0 1
84362: PUSH
84363: LD_INT 55
84365: PUSH
84366: EMPTY
84367: LIST
84368: PPUSH
84369: CALL_OW 69
84373: IN
84374: ST_TO_ADDR
// end ;
84375: LD_VAR 0 2
84379: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84380: LD_INT 0
84382: PPUSH
84383: PPUSH
// list := [ ] ;
84384: LD_ADDR_VAR 0 5
84388: PUSH
84389: EMPTY
84390: ST_TO_ADDR
// case d of 0 :
84391: LD_VAR 0 3
84395: PUSH
84396: LD_INT 0
84398: DOUBLE
84399: EQUAL
84400: IFTRUE 84404
84402: GO 84537
84404: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84405: LD_ADDR_VAR 0 5
84409: PUSH
84410: LD_VAR 0 1
84414: PUSH
84415: LD_INT 4
84417: MINUS
84418: PUSH
84419: LD_VAR 0 2
84423: PUSH
84424: LD_INT 4
84426: MINUS
84427: PUSH
84428: LD_INT 2
84430: PUSH
84431: EMPTY
84432: LIST
84433: LIST
84434: LIST
84435: PUSH
84436: LD_VAR 0 1
84440: PUSH
84441: LD_INT 3
84443: MINUS
84444: PUSH
84445: LD_VAR 0 2
84449: PUSH
84450: LD_INT 1
84452: PUSH
84453: EMPTY
84454: LIST
84455: LIST
84456: LIST
84457: PUSH
84458: LD_VAR 0 1
84462: PUSH
84463: LD_INT 4
84465: PLUS
84466: PUSH
84467: LD_VAR 0 2
84471: PUSH
84472: LD_INT 4
84474: PUSH
84475: EMPTY
84476: LIST
84477: LIST
84478: LIST
84479: PUSH
84480: LD_VAR 0 1
84484: PUSH
84485: LD_INT 3
84487: PLUS
84488: PUSH
84489: LD_VAR 0 2
84493: PUSH
84494: LD_INT 3
84496: PLUS
84497: PUSH
84498: LD_INT 5
84500: PUSH
84501: EMPTY
84502: LIST
84503: LIST
84504: LIST
84505: PUSH
84506: LD_VAR 0 1
84510: PUSH
84511: LD_VAR 0 2
84515: PUSH
84516: LD_INT 4
84518: PLUS
84519: PUSH
84520: LD_INT 0
84522: PUSH
84523: EMPTY
84524: LIST
84525: LIST
84526: LIST
84527: PUSH
84528: EMPTY
84529: LIST
84530: LIST
84531: LIST
84532: LIST
84533: LIST
84534: ST_TO_ADDR
// end ; 1 :
84535: GO 85235
84537: LD_INT 1
84539: DOUBLE
84540: EQUAL
84541: IFTRUE 84545
84543: GO 84678
84545: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84546: LD_ADDR_VAR 0 5
84550: PUSH
84551: LD_VAR 0 1
84555: PUSH
84556: LD_VAR 0 2
84560: PUSH
84561: LD_INT 4
84563: MINUS
84564: PUSH
84565: LD_INT 3
84567: PUSH
84568: EMPTY
84569: LIST
84570: LIST
84571: LIST
84572: PUSH
84573: LD_VAR 0 1
84577: PUSH
84578: LD_INT 3
84580: MINUS
84581: PUSH
84582: LD_VAR 0 2
84586: PUSH
84587: LD_INT 3
84589: MINUS
84590: PUSH
84591: LD_INT 2
84593: PUSH
84594: EMPTY
84595: LIST
84596: LIST
84597: LIST
84598: PUSH
84599: LD_VAR 0 1
84603: PUSH
84604: LD_INT 4
84606: MINUS
84607: PUSH
84608: LD_VAR 0 2
84612: PUSH
84613: LD_INT 1
84615: PUSH
84616: EMPTY
84617: LIST
84618: LIST
84619: LIST
84620: PUSH
84621: LD_VAR 0 1
84625: PUSH
84626: LD_VAR 0 2
84630: PUSH
84631: LD_INT 3
84633: PLUS
84634: PUSH
84635: LD_INT 0
84637: PUSH
84638: EMPTY
84639: LIST
84640: LIST
84641: LIST
84642: PUSH
84643: LD_VAR 0 1
84647: PUSH
84648: LD_INT 4
84650: PLUS
84651: PUSH
84652: LD_VAR 0 2
84656: PUSH
84657: LD_INT 4
84659: PLUS
84660: PUSH
84661: LD_INT 5
84663: PUSH
84664: EMPTY
84665: LIST
84666: LIST
84667: LIST
84668: PUSH
84669: EMPTY
84670: LIST
84671: LIST
84672: LIST
84673: LIST
84674: LIST
84675: ST_TO_ADDR
// end ; 2 :
84676: GO 85235
84678: LD_INT 2
84680: DOUBLE
84681: EQUAL
84682: IFTRUE 84686
84684: GO 84815
84686: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84687: LD_ADDR_VAR 0 5
84691: PUSH
84692: LD_VAR 0 1
84696: PUSH
84697: LD_VAR 0 2
84701: PUSH
84702: LD_INT 3
84704: MINUS
84705: PUSH
84706: LD_INT 3
84708: PUSH
84709: EMPTY
84710: LIST
84711: LIST
84712: LIST
84713: PUSH
84714: LD_VAR 0 1
84718: PUSH
84719: LD_INT 4
84721: PLUS
84722: PUSH
84723: LD_VAR 0 2
84727: PUSH
84728: LD_INT 4
84730: PUSH
84731: EMPTY
84732: LIST
84733: LIST
84734: LIST
84735: PUSH
84736: LD_VAR 0 1
84740: PUSH
84741: LD_VAR 0 2
84745: PUSH
84746: LD_INT 4
84748: PLUS
84749: PUSH
84750: LD_INT 0
84752: PUSH
84753: EMPTY
84754: LIST
84755: LIST
84756: LIST
84757: PUSH
84758: LD_VAR 0 1
84762: PUSH
84763: LD_INT 3
84765: MINUS
84766: PUSH
84767: LD_VAR 0 2
84771: PUSH
84772: LD_INT 1
84774: PUSH
84775: EMPTY
84776: LIST
84777: LIST
84778: LIST
84779: PUSH
84780: LD_VAR 0 1
84784: PUSH
84785: LD_INT 4
84787: MINUS
84788: PUSH
84789: LD_VAR 0 2
84793: PUSH
84794: LD_INT 4
84796: MINUS
84797: PUSH
84798: LD_INT 2
84800: PUSH
84801: EMPTY
84802: LIST
84803: LIST
84804: LIST
84805: PUSH
84806: EMPTY
84807: LIST
84808: LIST
84809: LIST
84810: LIST
84811: LIST
84812: ST_TO_ADDR
// end ; 3 :
84813: GO 85235
84815: LD_INT 3
84817: DOUBLE
84818: EQUAL
84819: IFTRUE 84823
84821: GO 84956
84823: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84824: LD_ADDR_VAR 0 5
84828: PUSH
84829: LD_VAR 0 1
84833: PUSH
84834: LD_INT 3
84836: PLUS
84837: PUSH
84838: LD_VAR 0 2
84842: PUSH
84843: LD_INT 4
84845: PUSH
84846: EMPTY
84847: LIST
84848: LIST
84849: LIST
84850: PUSH
84851: LD_VAR 0 1
84855: PUSH
84856: LD_INT 4
84858: PLUS
84859: PUSH
84860: LD_VAR 0 2
84864: PUSH
84865: LD_INT 4
84867: PLUS
84868: PUSH
84869: LD_INT 5
84871: PUSH
84872: EMPTY
84873: LIST
84874: LIST
84875: LIST
84876: PUSH
84877: LD_VAR 0 1
84881: PUSH
84882: LD_INT 4
84884: MINUS
84885: PUSH
84886: LD_VAR 0 2
84890: PUSH
84891: LD_INT 1
84893: PUSH
84894: EMPTY
84895: LIST
84896: LIST
84897: LIST
84898: PUSH
84899: LD_VAR 0 1
84903: PUSH
84904: LD_VAR 0 2
84908: PUSH
84909: LD_INT 4
84911: MINUS
84912: PUSH
84913: LD_INT 3
84915: PUSH
84916: EMPTY
84917: LIST
84918: LIST
84919: LIST
84920: PUSH
84921: LD_VAR 0 1
84925: PUSH
84926: LD_INT 3
84928: MINUS
84929: PUSH
84930: LD_VAR 0 2
84934: PUSH
84935: LD_INT 3
84937: MINUS
84938: PUSH
84939: LD_INT 2
84941: PUSH
84942: EMPTY
84943: LIST
84944: LIST
84945: LIST
84946: PUSH
84947: EMPTY
84948: LIST
84949: LIST
84950: LIST
84951: LIST
84952: LIST
84953: ST_TO_ADDR
// end ; 4 :
84954: GO 85235
84956: LD_INT 4
84958: DOUBLE
84959: EQUAL
84960: IFTRUE 84964
84962: GO 85097
84964: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84965: LD_ADDR_VAR 0 5
84969: PUSH
84970: LD_VAR 0 1
84974: PUSH
84975: LD_VAR 0 2
84979: PUSH
84980: LD_INT 4
84982: PLUS
84983: PUSH
84984: LD_INT 0
84986: PUSH
84987: EMPTY
84988: LIST
84989: LIST
84990: LIST
84991: PUSH
84992: LD_VAR 0 1
84996: PUSH
84997: LD_INT 3
84999: PLUS
85000: PUSH
85001: LD_VAR 0 2
85005: PUSH
85006: LD_INT 3
85008: PLUS
85009: PUSH
85010: LD_INT 5
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: LIST
85017: PUSH
85018: LD_VAR 0 1
85022: PUSH
85023: LD_INT 4
85025: PLUS
85026: PUSH
85027: LD_VAR 0 2
85031: PUSH
85032: LD_INT 4
85034: PUSH
85035: EMPTY
85036: LIST
85037: LIST
85038: LIST
85039: PUSH
85040: LD_VAR 0 1
85044: PUSH
85045: LD_VAR 0 2
85049: PUSH
85050: LD_INT 3
85052: MINUS
85053: PUSH
85054: LD_INT 3
85056: PUSH
85057: EMPTY
85058: LIST
85059: LIST
85060: LIST
85061: PUSH
85062: LD_VAR 0 1
85066: PUSH
85067: LD_INT 4
85069: MINUS
85070: PUSH
85071: LD_VAR 0 2
85075: PUSH
85076: LD_INT 4
85078: MINUS
85079: PUSH
85080: LD_INT 2
85082: PUSH
85083: EMPTY
85084: LIST
85085: LIST
85086: LIST
85087: PUSH
85088: EMPTY
85089: LIST
85090: LIST
85091: LIST
85092: LIST
85093: LIST
85094: ST_TO_ADDR
// end ; 5 :
85095: GO 85235
85097: LD_INT 5
85099: DOUBLE
85100: EQUAL
85101: IFTRUE 85105
85103: GO 85234
85105: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
85106: LD_ADDR_VAR 0 5
85110: PUSH
85111: LD_VAR 0 1
85115: PUSH
85116: LD_INT 4
85118: MINUS
85119: PUSH
85120: LD_VAR 0 2
85124: PUSH
85125: LD_INT 1
85127: PUSH
85128: EMPTY
85129: LIST
85130: LIST
85131: LIST
85132: PUSH
85133: LD_VAR 0 1
85137: PUSH
85138: LD_VAR 0 2
85142: PUSH
85143: LD_INT 4
85145: MINUS
85146: PUSH
85147: LD_INT 3
85149: PUSH
85150: EMPTY
85151: LIST
85152: LIST
85153: LIST
85154: PUSH
85155: LD_VAR 0 1
85159: PUSH
85160: LD_INT 4
85162: PLUS
85163: PUSH
85164: LD_VAR 0 2
85168: PUSH
85169: LD_INT 4
85171: PLUS
85172: PUSH
85173: LD_INT 5
85175: PUSH
85176: EMPTY
85177: LIST
85178: LIST
85179: LIST
85180: PUSH
85181: LD_VAR 0 1
85185: PUSH
85186: LD_INT 3
85188: PLUS
85189: PUSH
85190: LD_VAR 0 2
85194: PUSH
85195: LD_INT 4
85197: PUSH
85198: EMPTY
85199: LIST
85200: LIST
85201: LIST
85202: PUSH
85203: LD_VAR 0 1
85207: PUSH
85208: LD_VAR 0 2
85212: PUSH
85213: LD_INT 3
85215: PLUS
85216: PUSH
85217: LD_INT 0
85219: PUSH
85220: EMPTY
85221: LIST
85222: LIST
85223: LIST
85224: PUSH
85225: EMPTY
85226: LIST
85227: LIST
85228: LIST
85229: LIST
85230: LIST
85231: ST_TO_ADDR
// end ; end ;
85232: GO 85235
85234: POP
// result := list ;
85235: LD_ADDR_VAR 0 4
85239: PUSH
85240: LD_VAR 0 5
85244: ST_TO_ADDR
// end ;
85245: LD_VAR 0 4
85249: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85250: LD_INT 0
85252: PPUSH
85253: PPUSH
85254: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85255: LD_VAR 0 1
85259: NOT
85260: PUSH
85261: LD_VAR 0 2
85265: PUSH
85266: LD_INT 1
85268: PUSH
85269: LD_INT 2
85271: PUSH
85272: LD_INT 3
85274: PUSH
85275: LD_INT 4
85277: PUSH
85278: EMPTY
85279: LIST
85280: LIST
85281: LIST
85282: LIST
85283: IN
85284: NOT
85285: OR
85286: IFFALSE 85290
// exit ;
85288: GO 85382
// tmp := [ ] ;
85290: LD_ADDR_VAR 0 5
85294: PUSH
85295: EMPTY
85296: ST_TO_ADDR
// for i in units do
85297: LD_ADDR_VAR 0 4
85301: PUSH
85302: LD_VAR 0 1
85306: PUSH
85307: FOR_IN
85308: IFFALSE 85351
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
85310: LD_ADDR_VAR 0 5
85314: PUSH
85315: LD_VAR 0 5
85319: PPUSH
85320: LD_VAR 0 5
85324: PUSH
85325: LD_INT 1
85327: PLUS
85328: PPUSH
85329: LD_VAR 0 4
85333: PPUSH
85334: LD_VAR 0 2
85338: PPUSH
85339: CALL_OW 259
85343: PPUSH
85344: CALL_OW 2
85348: ST_TO_ADDR
85349: GO 85307
85351: POP
85352: POP
// if not tmp then
85353: LD_VAR 0 5
85357: NOT
85358: IFFALSE 85362
// exit ;
85360: GO 85382
// result := SortListByListDesc ( units , tmp ) ;
85362: LD_ADDR_VAR 0 3
85366: PUSH
85367: LD_VAR 0 1
85371: PPUSH
85372: LD_VAR 0 5
85376: PPUSH
85377: CALL_OW 77
85381: ST_TO_ADDR
// end ;
85382: LD_VAR 0 3
85386: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85387: LD_INT 0
85389: PPUSH
85390: PPUSH
85391: PPUSH
// x := GetX ( building ) ;
85392: LD_ADDR_VAR 0 4
85396: PUSH
85397: LD_VAR 0 2
85401: PPUSH
85402: CALL_OW 250
85406: ST_TO_ADDR
// y := GetY ( building ) ;
85407: LD_ADDR_VAR 0 5
85411: PUSH
85412: LD_VAR 0 2
85416: PPUSH
85417: CALL_OW 251
85421: ST_TO_ADDR
// if GetTaskList ( unit ) then
85422: LD_VAR 0 1
85426: PPUSH
85427: CALL_OW 437
85431: IFFALSE 85526
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85433: LD_STRING e
85435: PUSH
85436: LD_VAR 0 1
85440: PPUSH
85441: CALL_OW 437
85445: PUSH
85446: LD_INT 1
85448: ARRAY
85449: PUSH
85450: LD_INT 1
85452: ARRAY
85453: EQUAL
85454: PUSH
85455: LD_VAR 0 4
85459: PUSH
85460: LD_VAR 0 1
85464: PPUSH
85465: CALL_OW 437
85469: PUSH
85470: LD_INT 1
85472: ARRAY
85473: PUSH
85474: LD_INT 2
85476: ARRAY
85477: EQUAL
85478: AND
85479: PUSH
85480: LD_VAR 0 5
85484: PUSH
85485: LD_VAR 0 1
85489: PPUSH
85490: CALL_OW 437
85494: PUSH
85495: LD_INT 1
85497: ARRAY
85498: PUSH
85499: LD_INT 3
85501: ARRAY
85502: EQUAL
85503: AND
85504: IFFALSE 85516
// result := true else
85506: LD_ADDR_VAR 0 3
85510: PUSH
85511: LD_INT 1
85513: ST_TO_ADDR
85514: GO 85524
// result := false ;
85516: LD_ADDR_VAR 0 3
85520: PUSH
85521: LD_INT 0
85523: ST_TO_ADDR
// end else
85524: GO 85534
// result := false ;
85526: LD_ADDR_VAR 0 3
85530: PUSH
85531: LD_INT 0
85533: ST_TO_ADDR
// end ;
85534: LD_VAR 0 3
85538: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85539: LD_INT 0
85541: PPUSH
85542: PPUSH
85543: PPUSH
85544: PPUSH
// if not unit or not area then
85545: LD_VAR 0 1
85549: NOT
85550: PUSH
85551: LD_VAR 0 2
85555: NOT
85556: OR
85557: IFFALSE 85561
// exit ;
85559: GO 85726
// tmp := AreaToList ( area , i ) ;
85561: LD_ADDR_VAR 0 6
85565: PUSH
85566: LD_VAR 0 2
85570: PPUSH
85571: LD_VAR 0 5
85575: PPUSH
85576: CALL_OW 517
85580: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85581: LD_ADDR_VAR 0 5
85585: PUSH
85586: DOUBLE
85587: LD_INT 1
85589: DEC
85590: ST_TO_ADDR
85591: LD_VAR 0 6
85595: PUSH
85596: LD_INT 1
85598: ARRAY
85599: PUSH
85600: FOR_TO
85601: IFFALSE 85716
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85603: LD_ADDR_VAR 0 7
85607: PUSH
85608: LD_VAR 0 6
85612: PUSH
85613: LD_INT 1
85615: ARRAY
85616: PUSH
85617: LD_VAR 0 5
85621: ARRAY
85622: PUSH
85623: LD_VAR 0 6
85627: PUSH
85628: LD_INT 2
85630: ARRAY
85631: PUSH
85632: LD_VAR 0 5
85636: ARRAY
85637: PUSH
85638: EMPTY
85639: LIST
85640: LIST
85641: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
85642: LD_VAR 0 7
85646: PUSH
85647: LD_INT 1
85649: ARRAY
85650: PPUSH
85651: LD_VAR 0 7
85655: PUSH
85656: LD_INT 2
85658: ARRAY
85659: PPUSH
85660: CALL_OW 428
85664: PUSH
85665: LD_INT 0
85667: EQUAL
85668: IFFALSE 85714
// begin result := true ;
85670: LD_ADDR_VAR 0 4
85674: PUSH
85675: LD_INT 1
85677: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85678: LD_VAR 0 1
85682: PPUSH
85683: LD_VAR 0 7
85687: PUSH
85688: LD_INT 1
85690: ARRAY
85691: PPUSH
85692: LD_VAR 0 7
85696: PUSH
85697: LD_INT 2
85699: ARRAY
85700: PPUSH
85701: LD_VAR 0 3
85705: PPUSH
85706: CALL_OW 48
// exit ;
85710: POP
85711: POP
85712: GO 85726
// end ; end ;
85714: GO 85600
85716: POP
85717: POP
// result := false ;
85718: LD_ADDR_VAR 0 4
85722: PUSH
85723: LD_INT 0
85725: ST_TO_ADDR
// end ;
85726: LD_VAR 0 4
85730: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85731: LD_INT 0
85733: PPUSH
85734: PPUSH
85735: PPUSH
// if not side or side > 8 then
85736: LD_VAR 0 1
85740: NOT
85741: PUSH
85742: LD_VAR 0 1
85746: PUSH
85747: LD_INT 8
85749: GREATER
85750: OR
85751: IFFALSE 85755
// exit ;
85753: GO 85942
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85755: LD_ADDR_VAR 0 4
85759: PUSH
85760: LD_INT 22
85762: PUSH
85763: LD_VAR 0 1
85767: PUSH
85768: EMPTY
85769: LIST
85770: LIST
85771: PUSH
85772: LD_INT 21
85774: PUSH
85775: LD_INT 3
85777: PUSH
85778: EMPTY
85779: LIST
85780: LIST
85781: PUSH
85782: EMPTY
85783: LIST
85784: LIST
85785: PPUSH
85786: CALL_OW 69
85790: ST_TO_ADDR
// if not tmp then
85791: LD_VAR 0 4
85795: NOT
85796: IFFALSE 85800
// exit ;
85798: GO 85942
// enable_addtolog := true ;
85800: LD_ADDR_OWVAR 81
85804: PUSH
85805: LD_INT 1
85807: ST_TO_ADDR
// AddToLog ( [ ) ;
85808: LD_STRING [
85810: PPUSH
85811: CALL_OW 561
// for i in tmp do
85815: LD_ADDR_VAR 0 3
85819: PUSH
85820: LD_VAR 0 4
85824: PUSH
85825: FOR_IN
85826: IFFALSE 85933
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85828: LD_STRING [
85830: PUSH
85831: LD_VAR 0 3
85835: PPUSH
85836: CALL_OW 266
85840: STR
85841: PUSH
85842: LD_STRING , 
85844: STR
85845: PUSH
85846: LD_VAR 0 3
85850: PPUSH
85851: CALL_OW 250
85855: STR
85856: PUSH
85857: LD_STRING , 
85859: STR
85860: PUSH
85861: LD_VAR 0 3
85865: PPUSH
85866: CALL_OW 251
85870: STR
85871: PUSH
85872: LD_STRING , 
85874: STR
85875: PUSH
85876: LD_VAR 0 3
85880: PPUSH
85881: CALL_OW 254
85885: STR
85886: PUSH
85887: LD_STRING , 
85889: STR
85890: PUSH
85891: LD_VAR 0 3
85895: PPUSH
85896: LD_INT 1
85898: PPUSH
85899: CALL_OW 268
85903: STR
85904: PUSH
85905: LD_STRING , 
85907: STR
85908: PUSH
85909: LD_VAR 0 3
85913: PPUSH
85914: LD_INT 2
85916: PPUSH
85917: CALL_OW 268
85921: STR
85922: PUSH
85923: LD_STRING ],
85925: STR
85926: PPUSH
85927: CALL_OW 561
// end ;
85931: GO 85825
85933: POP
85934: POP
// AddToLog ( ]; ) ;
85935: LD_STRING ];
85937: PPUSH
85938: CALL_OW 561
// end ;
85942: LD_VAR 0 2
85946: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85947: LD_INT 0
85949: PPUSH
85950: PPUSH
85951: PPUSH
85952: PPUSH
85953: PPUSH
// if not area or not rate or not max then
85954: LD_VAR 0 1
85958: NOT
85959: PUSH
85960: LD_VAR 0 2
85964: NOT
85965: OR
85966: PUSH
85967: LD_VAR 0 4
85971: NOT
85972: OR
85973: IFFALSE 85977
// exit ;
85975: GO 86169
// while 1 do
85977: LD_INT 1
85979: IFFALSE 86169
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85981: LD_ADDR_VAR 0 9
85985: PUSH
85986: LD_VAR 0 1
85990: PPUSH
85991: LD_INT 1
85993: PPUSH
85994: CALL_OW 287
85998: PUSH
85999: LD_INT 10
86001: MUL
86002: ST_TO_ADDR
// r := rate / 10 ;
86003: LD_ADDR_VAR 0 7
86007: PUSH
86008: LD_VAR 0 2
86012: PUSH
86013: LD_INT 10
86015: DIVREAL
86016: ST_TO_ADDR
// time := 1 1$00 ;
86017: LD_ADDR_VAR 0 8
86021: PUSH
86022: LD_INT 2100
86024: ST_TO_ADDR
// if amount < min then
86025: LD_VAR 0 9
86029: PUSH
86030: LD_VAR 0 3
86034: LESS
86035: IFFALSE 86053
// r := r * 2 else
86037: LD_ADDR_VAR 0 7
86041: PUSH
86042: LD_VAR 0 7
86046: PUSH
86047: LD_INT 2
86049: MUL
86050: ST_TO_ADDR
86051: GO 86079
// if amount > max then
86053: LD_VAR 0 9
86057: PUSH
86058: LD_VAR 0 4
86062: GREATER
86063: IFFALSE 86079
// r := r / 2 ;
86065: LD_ADDR_VAR 0 7
86069: PUSH
86070: LD_VAR 0 7
86074: PUSH
86075: LD_INT 2
86077: DIVREAL
86078: ST_TO_ADDR
// time := time / r ;
86079: LD_ADDR_VAR 0 8
86083: PUSH
86084: LD_VAR 0 8
86088: PUSH
86089: LD_VAR 0 7
86093: DIVREAL
86094: ST_TO_ADDR
// if time < 0 then
86095: LD_VAR 0 8
86099: PUSH
86100: LD_INT 0
86102: LESS
86103: IFFALSE 86120
// time := time * - 1 ;
86105: LD_ADDR_VAR 0 8
86109: PUSH
86110: LD_VAR 0 8
86114: PUSH
86115: LD_INT 1
86117: NEG
86118: MUL
86119: ST_TO_ADDR
// wait ( time ) ;
86120: LD_VAR 0 8
86124: PPUSH
86125: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
86129: LD_INT 35
86131: PPUSH
86132: LD_INT 875
86134: PPUSH
86135: CALL_OW 12
86139: PPUSH
86140: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86144: LD_INT 1
86146: PPUSH
86147: LD_INT 5
86149: PPUSH
86150: CALL_OW 12
86154: PPUSH
86155: LD_VAR 0 1
86159: PPUSH
86160: LD_INT 1
86162: PPUSH
86163: CALL_OW 55
// end ;
86167: GO 85977
// end ;
86169: LD_VAR 0 5
86173: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86174: LD_INT 0
86176: PPUSH
86177: PPUSH
86178: PPUSH
86179: PPUSH
86180: PPUSH
86181: PPUSH
86182: PPUSH
86183: PPUSH
// if not turrets or not factories then
86184: LD_VAR 0 1
86188: NOT
86189: PUSH
86190: LD_VAR 0 2
86194: NOT
86195: OR
86196: IFFALSE 86200
// exit ;
86198: GO 86507
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86200: LD_ADDR_VAR 0 10
86204: PUSH
86205: LD_INT 5
86207: PUSH
86208: LD_INT 6
86210: PUSH
86211: EMPTY
86212: LIST
86213: LIST
86214: PUSH
86215: LD_INT 2
86217: PUSH
86218: LD_INT 4
86220: PUSH
86221: EMPTY
86222: LIST
86223: LIST
86224: PUSH
86225: LD_INT 3
86227: PUSH
86228: LD_INT 5
86230: PUSH
86231: EMPTY
86232: LIST
86233: LIST
86234: PUSH
86235: EMPTY
86236: LIST
86237: LIST
86238: LIST
86239: PUSH
86240: LD_INT 24
86242: PUSH
86243: LD_INT 25
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: PUSH
86250: LD_INT 23
86252: PUSH
86253: LD_INT 27
86255: PUSH
86256: EMPTY
86257: LIST
86258: LIST
86259: PUSH
86260: EMPTY
86261: LIST
86262: LIST
86263: PUSH
86264: LD_INT 42
86266: PUSH
86267: LD_INT 43
86269: PUSH
86270: EMPTY
86271: LIST
86272: LIST
86273: PUSH
86274: LD_INT 44
86276: PUSH
86277: LD_INT 46
86279: PUSH
86280: EMPTY
86281: LIST
86282: LIST
86283: PUSH
86284: LD_INT 45
86286: PUSH
86287: LD_INT 47
86289: PUSH
86290: EMPTY
86291: LIST
86292: LIST
86293: PUSH
86294: EMPTY
86295: LIST
86296: LIST
86297: LIST
86298: PUSH
86299: EMPTY
86300: LIST
86301: LIST
86302: LIST
86303: ST_TO_ADDR
// result := [ ] ;
86304: LD_ADDR_VAR 0 3
86308: PUSH
86309: EMPTY
86310: ST_TO_ADDR
// for i in turrets do
86311: LD_ADDR_VAR 0 4
86315: PUSH
86316: LD_VAR 0 1
86320: PUSH
86321: FOR_IN
86322: IFFALSE 86505
// begin nat := GetNation ( i ) ;
86324: LD_ADDR_VAR 0 7
86328: PUSH
86329: LD_VAR 0 4
86333: PPUSH
86334: CALL_OW 248
86338: ST_TO_ADDR
// weapon := 0 ;
86339: LD_ADDR_VAR 0 8
86343: PUSH
86344: LD_INT 0
86346: ST_TO_ADDR
// if not nat then
86347: LD_VAR 0 7
86351: NOT
86352: IFFALSE 86356
// continue ;
86354: GO 86321
// for j in list [ nat ] do
86356: LD_ADDR_VAR 0 5
86360: PUSH
86361: LD_VAR 0 10
86365: PUSH
86366: LD_VAR 0 7
86370: ARRAY
86371: PUSH
86372: FOR_IN
86373: IFFALSE 86414
// if GetBWeapon ( i ) = j [ 1 ] then
86375: LD_VAR 0 4
86379: PPUSH
86380: CALL_OW 269
86384: PUSH
86385: LD_VAR 0 5
86389: PUSH
86390: LD_INT 1
86392: ARRAY
86393: EQUAL
86394: IFFALSE 86412
// begin weapon := j [ 2 ] ;
86396: LD_ADDR_VAR 0 8
86400: PUSH
86401: LD_VAR 0 5
86405: PUSH
86406: LD_INT 2
86408: ARRAY
86409: ST_TO_ADDR
// break ;
86410: GO 86414
// end ;
86412: GO 86372
86414: POP
86415: POP
// if not weapon then
86416: LD_VAR 0 8
86420: NOT
86421: IFFALSE 86425
// continue ;
86423: GO 86321
// for k in factories do
86425: LD_ADDR_VAR 0 6
86429: PUSH
86430: LD_VAR 0 2
86434: PUSH
86435: FOR_IN
86436: IFFALSE 86501
// begin weapons := AvailableWeaponList ( k ) ;
86438: LD_ADDR_VAR 0 9
86442: PUSH
86443: LD_VAR 0 6
86447: PPUSH
86448: CALL_OW 478
86452: ST_TO_ADDR
// if not weapons then
86453: LD_VAR 0 9
86457: NOT
86458: IFFALSE 86462
// continue ;
86460: GO 86435
// if weapon in weapons then
86462: LD_VAR 0 8
86466: PUSH
86467: LD_VAR 0 9
86471: IN
86472: IFFALSE 86499
// begin result := [ i , weapon ] ;
86474: LD_ADDR_VAR 0 3
86478: PUSH
86479: LD_VAR 0 4
86483: PUSH
86484: LD_VAR 0 8
86488: PUSH
86489: EMPTY
86490: LIST
86491: LIST
86492: ST_TO_ADDR
// exit ;
86493: POP
86494: POP
86495: POP
86496: POP
86497: GO 86507
// end ; end ;
86499: GO 86435
86501: POP
86502: POP
// end ;
86503: GO 86321
86505: POP
86506: POP
// end ;
86507: LD_VAR 0 3
86511: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86512: LD_INT 0
86514: PPUSH
// if not side or side > 8 then
86515: LD_VAR 0 3
86519: NOT
86520: PUSH
86521: LD_VAR 0 3
86525: PUSH
86526: LD_INT 8
86528: GREATER
86529: OR
86530: IFFALSE 86534
// exit ;
86532: GO 86593
// if not range then
86534: LD_VAR 0 4
86538: NOT
86539: IFFALSE 86550
// range := - 12 ;
86541: LD_ADDR_VAR 0 4
86545: PUSH
86546: LD_INT 12
86548: NEG
86549: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86550: LD_VAR 0 1
86554: PPUSH
86555: LD_VAR 0 2
86559: PPUSH
86560: LD_VAR 0 3
86564: PPUSH
86565: LD_VAR 0 4
86569: PPUSH
86570: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86574: LD_VAR 0 1
86578: PPUSH
86579: LD_VAR 0 2
86583: PPUSH
86584: LD_VAR 0 3
86588: PPUSH
86589: CALL_OW 331
// end ;
86593: LD_VAR 0 5
86597: RET
// export function Video ( mode ) ; begin
86598: LD_INT 0
86600: PPUSH
// ingame_video = mode ;
86601: LD_ADDR_OWVAR 52
86605: PUSH
86606: LD_VAR 0 1
86610: ST_TO_ADDR
// interface_hidden = mode ;
86611: LD_ADDR_OWVAR 54
86615: PUSH
86616: LD_VAR 0 1
86620: ST_TO_ADDR
// end ; end_of_file
86621: LD_VAR 0 2
86625: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
86626: GO 86628
86628: DISABLE
// begin ru_radar := 98 ;
86629: LD_ADDR_EXP 93
86633: PUSH
86634: LD_INT 98
86636: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
86637: LD_ADDR_EXP 94
86641: PUSH
86642: LD_INT 89
86644: ST_TO_ADDR
// us_hack := 99 ;
86645: LD_ADDR_EXP 95
86649: PUSH
86650: LD_INT 99
86652: ST_TO_ADDR
// us_artillery := 97 ;
86653: LD_ADDR_EXP 96
86657: PUSH
86658: LD_INT 97
86660: ST_TO_ADDR
// ar_bio_bomb := 91 ;
86661: LD_ADDR_EXP 97
86665: PUSH
86666: LD_INT 91
86668: ST_TO_ADDR
// end ;
86669: END
