// starting begin ResetFog ;
   0: CALL_OW 335
// Randomize ;
   4: CALL_OW 10
// InitVariables ;
   8: CALL 87 0 0
// InitMacro ;
  12: CALL 16587 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 29
// FogOff ( 1 ) ;
  22: LD_INT 1
  24: PPUSH
  25: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  29: LD_INT 8
  31: PPUSH
  32: LD_INT 1
  34: PPUSH
  35: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  39: LD_INT 4
  41: PPUSH
  42: LD_INT 3
  44: PPUSH
  45: LD_INT 6
  47: PPUSH
  48: LD_INT 3
  50: PPUSH
  51: LD_INT 2
  53: PPUSH
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 7
  59: PPUSH
  60: LD_INT 18
  62: PPUSH
  63: LD_INT 19
  65: PPUSH
  66: CALL 78387 0 9
// PrepareAmerican ;
  70: CALL 518 0 0
// PrepareArabian ;
  74: CALL 2200 0 0
// MC_Start ( ) ;
  78: CALL 17734 0 0
// Action ;
  82: CALL 7576 0 0
// end ;
  86: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , no_selected , selected ; function InitVariables ; begin
  87: LD_INT 0
  89: PPUSH
// debug := false ;
  90: LD_ADDR_EXP 1
  94: PUSH
  95: LD_INT 0
  97: ST_TO_ADDR
// game := true ;
  98: LD_ADDR_EXP 2
 102: PUSH
 103: LD_INT 1
 105: ST_TO_ADDR
// mission_prefix := 11_ ;
 106: LD_ADDR_EXP 3
 110: PUSH
 111: LD_STRING 11_
 113: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 114: LD_ADDR_EXP 4
 118: PUSH
 119: LD_STRING 10c_
 121: ST_TO_ADDR
// ar_run := false ;
 122: LD_ADDR_EXP 5
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// ar_patrol := false ;
 130: LD_ADDR_EXP 7
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// base_captured := false ;
 138: LD_ADDR_EXP 6
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// us_scout := 0 ;
 146: LD_ADDR_EXP 8
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 154: LD_ADDR_EXP 9
 158: PUSH
 159: LD_INT 0
 161: PUSH
 162: LD_INT 0
 164: PUSH
 165: LD_INT 0
 167: PUSH
 168: LD_INT 0
 170: PUSH
 171: LD_INT 0
 173: PUSH
 174: EMPTY
 175: LIST
 176: LIST
 177: LIST
 178: LIST
 179: LIST
 180: ST_TO_ADDR
// kamikazed := false ;
 181: LD_ADDR_EXP 11
 185: PUSH
 186: LD_INT 0
 188: ST_TO_ADDR
// artifact_stolen := false ;
 189: LD_ADDR_EXP 12
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// artifact_get := false ;
 197: LD_ADDR_EXP 13
 201: PUSH
 202: LD_INT 0
 204: ST_TO_ADDR
// game_time := [ 100 100$00 , 90 90$00 , 85 85$00 ] [ Difficulty ] ;
 205: LD_ADDR_EXP 15
 209: PUSH
 210: LD_INT 210000
 212: PUSH
 213: LD_INT 189000
 215: PUSH
 216: LD_INT 178500
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: PUSH
 224: LD_OWVAR 67
 228: ARRAY
 229: ST_TO_ADDR
// powell_warn := false ;
 230: LD_ADDR_EXP 16
 234: PUSH
 235: LD_INT 0
 237: ST_TO_ADDR
// loses_counter := 0 ;
 238: LD_ADDR_EXP 17
 242: PUSH
 243: LD_INT 0
 245: ST_TO_ADDR
// artifact_oncargo := false ;
 246: LD_ADDR_EXP 14
 250: PUSH
 251: LD_INT 0
 253: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 254: LD_ADDR_EXP 18
 258: PUSH
 259: LD_STRING 10_GensherEscape_1
 261: PPUSH
 262: LD_EXP 1
 266: PPUSH
 267: CALL_OW 30
 271: ST_TO_ADDR
// can_kamikazed := false ;
 272: LD_ADDR_EXP 10
 276: PUSH
 277: LD_INT 0
 279: ST_TO_ADDR
// end ;
 280: LD_VAR 0 1
 284: RET
// export function CustomInitMacro ; var i ; begin
 285: LD_INT 0
 287: PPUSH
 288: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 289: LD_ADDR_EXP 74
 293: PUSH
 294: LD_INT 20
 296: PUSH
 297: LD_INT 21
 299: PUSH
 300: LD_INT 22
 302: PUSH
 303: EMPTY
 304: LIST
 305: LIST
 306: LIST
 307: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 308: LD_ADDR_EXP 75
 312: PUSH
 313: LD_INT 28
 315: PUSH
 316: LD_INT 24
 318: PUSH
 319: LD_INT 26
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
 327: LD_INT 1
 329: PPUSH
 330: LD_INT 8
 332: PUSH
 333: LD_INT 10
 335: PUSH
 336: LD_INT 12
 338: PUSH
 339: EMPTY
 340: LIST
 341: LIST
 342: LIST
 343: PUSH
 344: LD_OWVAR 67
 348: ARRAY
 349: PPUSH
 350: LD_INT 3
 352: PPUSH
 353: CALL 38128 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 357: LD_INT 2
 359: PPUSH
 360: LD_INT 6
 362: PUSH
 363: LD_INT 8
 365: PUSH
 366: LD_INT 9
 368: PUSH
 369: EMPTY
 370: LIST
 371: LIST
 372: LIST
 373: PUSH
 374: LD_OWVAR 67
 378: ARRAY
 379: PPUSH
 380: LD_INT 2
 382: PPUSH
 383: CALL 38128 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 387: LD_INT 3
 389: PPUSH
 390: LD_INT 6
 392: PUSH
 393: LD_INT 7
 395: PUSH
 396: LD_INT 9
 398: PUSH
 399: EMPTY
 400: LIST
 401: LIST
 402: LIST
 403: PUSH
 404: LD_OWVAR 67
 408: ARRAY
 409: PPUSH
 410: LD_INT 1
 412: PPUSH
 413: CALL 38128 0 3
// for i = 1 to mc_bases do
 417: LD_ADDR_VAR 0 2
 421: PUSH
 422: DOUBLE
 423: LD_INT 1
 425: DEC
 426: ST_TO_ADDR
 427: LD_EXP 50
 431: PUSH
 432: FOR_TO
 433: IFFALSE 457
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 435: LD_VAR 0 2
 439: PPUSH
 440: LD_EXP 43
 444: PUSH
 445: LD_VAR 0 2
 449: ARRAY
 450: PPUSH
 451: CALL 38554 0 2
 455: GO 432
 457: POP
 458: POP
// end ;
 459: LD_VAR 0 1
 463: RET
// function Debuger ; var i ; begin
 464: LD_INT 0
 466: PPUSH
 467: PPUSH
// if not debug then
 468: LD_EXP 1
 472: NOT
 473: IFFALSE 477
// exit ;
 475: GO 513
// game_speed := 5 ;
 477: LD_ADDR_OWVAR 65
 481: PUSH
 482: LD_INT 5
 484: ST_TO_ADDR
// uc_side := 1 ;
 485: LD_ADDR_OWVAR 20
 489: PUSH
 490: LD_INT 1
 492: ST_TO_ADDR
// uc_nation := 1 ;
 493: LD_ADDR_OWVAR 21
 497: PUSH
 498: LD_INT 1
 500: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 501: LD_EXP 36
 505: PPUSH
 506: LD_INT 1
 508: PPUSH
 509: CALL_OW 235
// end ; end_of_file
 513: LD_VAR 0 1
 517: RET
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 518: LD_INT 0
 520: PPUSH
 521: PPUSH
 522: PPUSH
 523: PPUSH
 524: PPUSH
 525: PPUSH
 526: PPUSH
 527: PPUSH
// uc_side := 4 ;
 528: LD_ADDR_OWVAR 20
 532: PUSH
 533: LD_INT 4
 535: ST_TO_ADDR
// uc_nation := 1 ;
 536: LD_ADDR_OWVAR 21
 540: PUSH
 541: LD_INT 1
 543: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 544: LD_ADDR_EXP 30
 548: PUSH
 549: LD_STRING Powell
 551: PPUSH
 552: LD_INT 0
 554: PPUSH
 555: LD_STRING 
 557: PPUSH
 558: CALL 44118 0 3
 562: ST_TO_ADDR
// uc_side := 1 ;
 563: LD_ADDR_OWVAR 20
 567: PUSH
 568: LD_INT 1
 570: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 571: LD_ADDR_EXP 21
 575: PUSH
 576: LD_STRING JMM
 578: PPUSH
 579: LD_EXP 1
 583: NOT
 584: PPUSH
 585: LD_EXP 4
 589: PPUSH
 590: CALL 44118 0 3
 594: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 595: LD_EXP 21
 599: PPUSH
 600: CALL_OW 257
 604: PUSH
 605: LD_INT 4
 607: GREATER
 608: IFFALSE 622
// SetClass ( JMM , 1 ) ;
 610: LD_EXP 21
 614: PPUSH
 615: LD_INT 1
 617: PPUSH
 618: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 622: LD_ADDR_EXP 22
 626: PUSH
 627: LD_STRING Lisa
 629: PPUSH
 630: LD_EXP 1
 634: NOT
 635: PPUSH
 636: LD_EXP 4
 640: PPUSH
 641: CALL 44118 0 3
 645: ST_TO_ADDR
// if not Lisa then
 646: LD_EXP 22
 650: NOT
 651: IFFALSE 666
// Lisa := CreateCharacter ( 10_Lisa ) ;
 653: LD_ADDR_EXP 22
 657: PUSH
 658: LD_STRING 10_Lisa
 660: PPUSH
 661: CALL_OW 34
 665: ST_TO_ADDR
// if not Lisa then
 666: LD_EXP 22
 670: NOT
 671: IFFALSE 686
// Lisa := CreateCharacter ( 09_Lisa ) ;
 673: LD_ADDR_EXP 22
 677: PUSH
 678: LD_STRING 09_Lisa
 680: PPUSH
 681: CALL_OW 34
 685: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 686: LD_ADDR_EXP 31
 690: PUSH
 691: LD_STRING Cornel
 693: PPUSH
 694: LD_EXP 1
 698: NOT
 699: PPUSH
 700: LD_EXP 4
 704: PPUSH
 705: CALL 44118 0 3
 709: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 710: LD_ADDR_EXP 23
 714: PUSH
 715: LD_STRING Donaldson
 717: PPUSH
 718: LD_EXP 1
 722: NOT
 723: PPUSH
 724: LD_EXP 4
 728: PPUSH
 729: CALL 44118 0 3
 733: ST_TO_ADDR
// if not Donaldson then
 734: LD_EXP 23
 738: NOT
 739: IFFALSE 754
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 741: LD_ADDR_EXP 23
 745: PUSH
 746: LD_STRING 10_Donaldson
 748: PPUSH
 749: CALL_OW 34
 753: ST_TO_ADDR
// if not Donaldson then
 754: LD_EXP 23
 758: NOT
 759: IFFALSE 774
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 761: LD_ADDR_EXP 23
 765: PUSH
 766: LD_STRING 09_Donaldson
 768: PPUSH
 769: CALL_OW 34
 773: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 774: LD_ADDR_EXP 24
 778: PUSH
 779: LD_STRING Bobby
 781: PPUSH
 782: LD_EXP 1
 786: NOT
 787: PPUSH
 788: LD_EXP 4
 792: PPUSH
 793: CALL 44118 0 3
 797: ST_TO_ADDR
// if not Bobby then
 798: LD_EXP 24
 802: NOT
 803: IFFALSE 818
// Bobby := CreateCharacter ( 10_Bobby ) ;
 805: LD_ADDR_EXP 24
 809: PUSH
 810: LD_STRING 10_Bobby
 812: PPUSH
 813: CALL_OW 34
 817: ST_TO_ADDR
// if not Bobby then
 818: LD_EXP 24
 822: NOT
 823: IFFALSE 838
// Bobby := CreateCharacter ( 09_Bobby ) ;
 825: LD_ADDR_EXP 24
 829: PUSH
 830: LD_STRING 09_Bobby
 832: PPUSH
 833: CALL_OW 34
 837: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 838: LD_ADDR_EXP 25
 842: PUSH
 843: LD_STRING Cyrus
 845: PPUSH
 846: LD_EXP 1
 850: NOT
 851: PPUSH
 852: LD_EXP 4
 856: PPUSH
 857: CALL 44118 0 3
 861: ST_TO_ADDR
// if not Cyrus then
 862: LD_EXP 25
 866: NOT
 867: IFFALSE 882
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 869: LD_ADDR_EXP 25
 873: PUSH
 874: LD_STRING 10_Cyrus
 876: PPUSH
 877: CALL_OW 34
 881: ST_TO_ADDR
// if not Cyrus then
 882: LD_EXP 25
 886: NOT
 887: IFFALSE 902
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
 889: LD_ADDR_EXP 25
 893: PUSH
 894: LD_STRING 09_Cyrus
 896: PPUSH
 897: CALL_OW 34
 901: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
 902: LD_ADDR_EXP 26
 906: PUSH
 907: LD_STRING Denis
 909: PPUSH
 910: LD_EXP 1
 914: NOT
 915: PPUSH
 916: LD_EXP 4
 920: PPUSH
 921: CALL 44118 0 3
 925: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
 926: LD_ADDR_EXP 27
 930: PUSH
 931: LD_STRING Brown
 933: PPUSH
 934: LD_EXP 1
 938: NOT
 939: PPUSH
 940: LD_EXP 4
 944: PPUSH
 945: CALL 44118 0 3
 949: ST_TO_ADDR
// if not Brown then
 950: LD_EXP 27
 954: NOT
 955: IFFALSE 970
// Brown := CreateCharacter ( 10_Brown ) ;
 957: LD_ADDR_EXP 27
 961: PUSH
 962: LD_STRING 10_Brown
 964: PPUSH
 965: CALL_OW 34
 969: ST_TO_ADDR
// if not Brown then
 970: LD_EXP 27
 974: NOT
 975: IFFALSE 990
// Brown := CreateCharacter ( 08_Brown ) ;
 977: LD_ADDR_EXP 27
 981: PUSH
 982: LD_STRING 08_Brown
 984: PPUSH
 985: CALL_OW 34
 989: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
 990: LD_ADDR_EXP 28
 994: PUSH
 995: LD_STRING Gladstone
 997: PPUSH
 998: LD_EXP 1
1002: NOT
1003: PPUSH
1004: LD_EXP 4
1008: PPUSH
1009: CALL 44118 0 3
1013: ST_TO_ADDR
// if not Gladstone then
1014: LD_EXP 28
1018: NOT
1019: IFFALSE 1034
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1021: LD_ADDR_EXP 28
1025: PUSH
1026: LD_STRING 10_Gladstone
1028: PPUSH
1029: CALL_OW 34
1033: ST_TO_ADDR
// if not Gladstone then
1034: LD_EXP 28
1038: NOT
1039: IFFALSE 1054
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1041: LD_ADDR_EXP 28
1045: PUSH
1046: LD_STRING 08_Gladstone
1048: PPUSH
1049: CALL_OW 34
1053: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1054: LD_ADDR_EXP 29
1058: PUSH
1059: LD_STRING Houten
1061: PPUSH
1062: LD_EXP 1
1066: NOT
1067: PPUSH
1068: LD_EXP 4
1072: PPUSH
1073: CALL 44118 0 3
1077: ST_TO_ADDR
// if not Houten then
1078: LD_EXP 29
1082: NOT
1083: IFFALSE 1098
// Houten := CreateCharacter ( 10_Houten ) ;
1085: LD_ADDR_EXP 29
1089: PUSH
1090: LD_STRING 10_Houten
1092: PPUSH
1093: CALL_OW 34
1097: ST_TO_ADDR
// if not Houten then
1098: LD_EXP 29
1102: NOT
1103: IFFALSE 1118
// Houten := CreateCharacter ( 09_Houten ) ;
1105: LD_ADDR_EXP 29
1109: PUSH
1110: LD_STRING 09_Houten
1112: PPUSH
1113: CALL_OW 34
1117: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
1118: LD_ADDR_EXP 31
1122: PUSH
1123: LD_STRING Cornel
1125: PPUSH
1126: LD_EXP 1
1130: NOT
1131: PPUSH
1132: LD_EXP 4
1136: PPUSH
1137: CALL 44118 0 3
1141: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1142: LD_ADDR_EXP 32
1146: PUSH
1147: LD_STRING Gary
1149: PPUSH
1150: LD_EXP 1
1154: NOT
1155: PPUSH
1156: LD_EXP 4
1160: PPUSH
1161: CALL 44118 0 3
1165: ST_TO_ADDR
// if not Gary then
1166: LD_EXP 32
1170: NOT
1171: IFFALSE 1186
// Gary := CreateCharacter ( 10_Gary ) ;
1173: LD_ADDR_EXP 32
1177: PUSH
1178: LD_STRING 10_Gary
1180: PPUSH
1181: CALL_OW 34
1185: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1186: LD_ADDR_EXP 33
1190: PUSH
1191: LD_STRING Frank
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: LD_EXP 4
1204: PPUSH
1205: CALL 44118 0 3
1209: ST_TO_ADDR
// if not Frank then
1210: LD_EXP 33
1214: NOT
1215: IFFALSE 1230
// Frank := CreateCharacter ( 08_Frank ) ;
1217: LD_ADDR_EXP 33
1221: PUSH
1222: LD_STRING 08_Frank
1224: PPUSH
1225: CALL_OW 34
1229: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1230: LD_ADDR_EXP 34
1234: PUSH
1235: LD_STRING Kikuchi
1237: PPUSH
1238: LD_EXP 1
1242: NOT
1243: PPUSH
1244: LD_EXP 4
1248: PPUSH
1249: CALL 44118 0 3
1253: ST_TO_ADDR
// if not Kikuchi then
1254: LD_EXP 34
1258: NOT
1259: IFFALSE 1274
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1261: LD_ADDR_EXP 34
1265: PUSH
1266: LD_STRING 08_Kikuchi
1268: PPUSH
1269: CALL_OW 34
1273: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1274: LD_ADDR_VAR 0 5
1278: PUSH
1279: LD_EXP 22
1283: PUSH
1284: LD_EXP 23
1288: PUSH
1289: LD_EXP 24
1293: PUSH
1294: LD_EXP 25
1298: PUSH
1299: LD_EXP 26
1303: PUSH
1304: LD_EXP 27
1308: PUSH
1309: LD_EXP 28
1313: PUSH
1314: LD_EXP 29
1318: PUSH
1319: LD_EXP 31
1323: PUSH
1324: LD_EXP 32
1328: PUSH
1329: LD_EXP 33
1333: PUSH
1334: LD_EXP 34
1338: PUSH
1339: EMPTY
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: ST_TO_ADDR
// tmp := tmp diff 0 ;
1353: LD_ADDR_VAR 0 5
1357: PUSH
1358: LD_VAR 0 5
1362: PUSH
1363: LD_INT 0
1365: DIFF
1366: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1367: LD_ADDR_VAR 0 5
1371: PUSH
1372: LD_VAR 0 5
1376: PUSH
1377: LD_STRING 10_lock
1379: PPUSH
1380: CALL_OW 31
1384: UNION
1385: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1386: LD_ADDR_VAR 0 5
1390: PUSH
1391: LD_VAR 0 5
1395: PUSH
1396: LD_STRING 10c_lock
1398: PPUSH
1399: CALL_OW 31
1403: UNION
1404: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1405: LD_STRING 10_lock
1407: PPUSH
1408: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1412: LD_STRING 10c_lock
1414: PPUSH
1415: CALL_OW 40
// for i in tmp do
1419: LD_ADDR_VAR 0 2
1423: PUSH
1424: LD_VAR 0 5
1428: PUSH
1429: FOR_IN
1430: IFFALSE 1468
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1432: LD_VAR 0 2
1436: PPUSH
1437: CALL_OW 257
1441: PUSH
1442: LD_INT 8
1444: PUSH
1445: LD_INT 2
1447: PUSH
1448: EMPTY
1449: LIST
1450: LIST
1451: IN
1452: IFFALSE 1466
// SetClass ( i , class_soldier ) ;
1454: LD_VAR 0 2
1458: PPUSH
1459: LD_INT 1
1461: PPUSH
1462: CALL_OW 336
1466: GO 1429
1468: POP
1469: POP
// if tmp < 12 then
1470: LD_VAR 0 5
1474: PUSH
1475: LD_INT 12
1477: LESS
1478: IFFALSE 1572
// begin k := 16 - tmp ;
1480: LD_ADDR_VAR 0 3
1484: PUSH
1485: LD_INT 16
1487: PUSH
1488: LD_VAR 0 5
1492: MINUS
1493: ST_TO_ADDR
// for i = 1 to k do
1494: LD_ADDR_VAR 0 2
1498: PUSH
1499: DOUBLE
1500: LD_INT 1
1502: DEC
1503: ST_TO_ADDR
1504: LD_VAR 0 3
1508: PUSH
1509: FOR_TO
1510: IFFALSE 1570
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1512: LD_INT 0
1514: PPUSH
1515: LD_INT 1
1517: PUSH
1518: LD_INT 1
1520: PUSH
1521: LD_INT 3
1523: PUSH
1524: LD_INT 4
1526: PUSH
1527: EMPTY
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: PUSH
1533: LD_INT 1
1535: PPUSH
1536: LD_INT 4
1538: PPUSH
1539: CALL_OW 12
1543: ARRAY
1544: PPUSH
1545: LD_INT 6
1547: PPUSH
1548: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1552: LD_ADDR_VAR 0 5
1556: PUSH
1557: LD_VAR 0 5
1561: PUSH
1562: CALL_OW 44
1566: ADD
1567: ST_TO_ADDR
// end ;
1568: GO 1509
1570: POP
1571: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1572: LD_ADDR_EXP 20
1576: PUSH
1577: LD_STRING 1
1579: PPUSH
1580: LD_INT 12
1582: PPUSH
1583: LD_INT 12
1585: PPUSH
1586: LD_INT -5
1588: PUSH
1589: LD_EXP 21
1593: PUSH
1594: LD_INT -2
1596: PUSH
1597: LD_INT -3
1599: PUSH
1600: LD_INT -5
1602: PUSH
1603: EMPTY
1604: LIST
1605: LIST
1606: LIST
1607: LIST
1608: LIST
1609: PUSH
1610: LD_VAR 0 5
1614: ADD
1615: PUSH
1616: LD_INT -6
1618: PUSH
1619: LD_INT -4
1621: PUSH
1622: LD_EXP 30
1626: PUSH
1627: EMPTY
1628: LIST
1629: LIST
1630: LIST
1631: ADD
1632: PPUSH
1633: LD_INT 1
1635: PUSH
1636: LD_INT 4
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: PUSH
1643: LD_INT 3
1645: PUSH
1646: LD_INT 0
1648: PUSH
1649: LD_INT 5
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: LIST
1656: PUSH
1657: LD_INT 4
1659: PUSH
1660: LD_INT 0
1662: PUSH
1663: LD_INT 3
1665: PUSH
1666: EMPTY
1667: LIST
1668: LIST
1669: LIST
1670: PUSH
1671: LD_INT 5
1673: PUSH
1674: LD_INT 0
1676: PUSH
1677: LD_INT 2
1679: PUSH
1680: EMPTY
1681: LIST
1682: LIST
1683: LIST
1684: PUSH
1685: EMPTY
1686: LIST
1687: LIST
1688: LIST
1689: LIST
1690: PPUSH
1691: CALL_OW 42
1695: ST_TO_ADDR
// others := tmp diff selected ;
1696: LD_ADDR_VAR 0 8
1700: PUSH
1701: LD_VAR 0 5
1705: PUSH
1706: LD_EXP 20
1710: DIFF
1711: ST_TO_ADDR
// others := tmp diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1712: LD_ADDR_VAR 0 8
1716: PUSH
1717: LD_VAR 0 5
1721: PUSH
1722: LD_EXP 22
1726: PUSH
1727: LD_EXP 23
1731: PUSH
1732: LD_EXP 24
1736: PUSH
1737: LD_EXP 25
1741: PUSH
1742: LD_EXP 26
1746: PUSH
1747: LD_EXP 27
1751: PUSH
1752: LD_EXP 28
1756: PUSH
1757: LD_EXP 29
1761: PUSH
1762: LD_EXP 31
1766: PUSH
1767: LD_EXP 32
1771: PUSH
1772: LD_EXP 33
1776: PUSH
1777: LD_EXP 34
1781: PUSH
1782: EMPTY
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: DIFF
1796: ST_TO_ADDR
// no_selected := others ;
1797: LD_ADDR_EXP 19
1801: PUSH
1802: LD_VAR 0 8
1806: ST_TO_ADDR
// if no_selected then
1807: LD_EXP 19
1811: IFFALSE 1825
// SaveCharacters ( no_selected , 11_others ) ;
1813: LD_EXP 19
1817: PPUSH
1818: LD_STRING 11_others
1820: PPUSH
1821: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1825: LD_ADDR_VAR 0 6
1829: PUSH
1830: LD_INT 3
1832: PUSH
1833: LD_INT 1
1835: PUSH
1836: LD_INT 1
1838: PUSH
1839: LD_INT 4
1841: PUSH
1842: EMPTY
1843: LIST
1844: LIST
1845: LIST
1846: LIST
1847: PUSH
1848: LD_INT 2
1850: PUSH
1851: LD_INT 2
1853: PUSH
1854: LD_INT 1
1856: PUSH
1857: LD_INT 5
1859: PUSH
1860: EMPTY
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: PUSH
1866: LD_INT 4
1868: PUSH
1869: LD_INT 1
1871: PUSH
1872: LD_INT 1
1874: PUSH
1875: LD_INT 5
1877: PUSH
1878: EMPTY
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: PUSH
1884: LD_INT 2
1886: PUSH
1887: LD_INT 1
1889: PUSH
1890: LD_INT 1
1892: PUSH
1893: LD_INT 7
1895: PUSH
1896: EMPTY
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: PUSH
1902: LD_INT 3
1904: PUSH
1905: LD_INT 2
1907: PUSH
1908: LD_INT 1
1910: PUSH
1911: LD_INT 7
1913: PUSH
1914: EMPTY
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: PUSH
1920: EMPTY
1921: LIST
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: ST_TO_ADDR
// for i in JMM ^ selected do
1927: LD_ADDR_VAR 0 2
1931: PUSH
1932: LD_EXP 21
1936: PUSH
1937: LD_EXP 20
1941: ADD
1942: PUSH
1943: FOR_IN
1944: IFFALSE 2133
// begin if GetClass ( i ) = 3 then
1946: LD_VAR 0 2
1950: PPUSH
1951: CALL_OW 257
1955: PUSH
1956: LD_INT 3
1958: EQUAL
1959: IFFALSE 2116
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
1961: LD_ADDR_OWVAR 37
1965: PUSH
1966: LD_VAR 0 6
1970: PUSH
1971: LD_INT 1
1973: ARRAY
1974: PUSH
1975: LD_INT 1
1977: ARRAY
1978: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
1979: LD_ADDR_OWVAR 39
1983: PUSH
1984: LD_VAR 0 6
1988: PUSH
1989: LD_INT 1
1991: ARRAY
1992: PUSH
1993: LD_INT 2
1995: ARRAY
1996: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
1997: LD_ADDR_OWVAR 38
2001: PUSH
2002: LD_VAR 0 6
2006: PUSH
2007: LD_INT 1
2009: ARRAY
2010: PUSH
2011: LD_INT 3
2013: ARRAY
2014: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2015: LD_ADDR_OWVAR 40
2019: PUSH
2020: LD_VAR 0 6
2024: PUSH
2025: LD_INT 1
2027: ARRAY
2028: PUSH
2029: LD_INT 4
2031: ARRAY
2032: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2033: LD_ADDR_VAR 0 6
2037: PUSH
2038: LD_VAR 0 6
2042: PPUSH
2043: LD_INT 1
2045: PPUSH
2046: CALL_OW 3
2050: ST_TO_ADDR
// veh := CreateVehicle ;
2051: LD_ADDR_VAR 0 7
2055: PUSH
2056: CALL_OW 45
2060: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2061: LD_VAR 0 7
2065: PPUSH
2066: LD_INT 8
2068: PPUSH
2069: LD_INT 0
2071: PPUSH
2072: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2076: LD_VAR 0 2
2080: PPUSH
2081: LD_VAR 0 7
2085: PPUSH
2086: CALL_OW 52
// if i = JMM then
2090: LD_VAR 0 2
2094: PUSH
2095: LD_EXP 21
2099: EQUAL
2100: IFFALSE 2114
// SetMark ( veh , 1 ) ;
2102: LD_VAR 0 7
2106: PPUSH
2107: LD_INT 1
2109: PPUSH
2110: CALL_OW 242
// end else
2114: GO 2131
// PlaceUnitArea ( i , am_hum_start , false ) ;
2116: LD_VAR 0 2
2120: PPUSH
2121: LD_INT 9
2123: PPUSH
2124: LD_INT 0
2126: PPUSH
2127: CALL_OW 49
// end ;
2131: GO 1943
2133: POP
2134: POP
// vc_chassis := us_medium_tracked ;
2135: LD_ADDR_OWVAR 37
2139: PUSH
2140: LD_INT 3
2142: ST_TO_ADDR
// vc_engine := engine_solar ;
2143: LD_ADDR_OWVAR 39
2147: PUSH
2148: LD_INT 2
2150: ST_TO_ADDR
// vc_control := control_computer ;
2151: LD_ADDR_OWVAR 38
2155: PUSH
2156: LD_INT 3
2158: ST_TO_ADDR
// vc_weapon := us_radar ;
2159: LD_ADDR_OWVAR 40
2163: PUSH
2164: LD_INT 11
2166: ST_TO_ADDR
// veh := CreateVehicle ;
2167: LD_ADDR_VAR 0 7
2171: PUSH
2172: CALL_OW 45
2176: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2177: LD_VAR 0 7
2181: PPUSH
2182: LD_INT 87
2184: PPUSH
2185: LD_INT 142
2187: PPUSH
2188: LD_INT 0
2190: PPUSH
2191: CALL_OW 48
// end ; end_of_file
2195: LD_VAR 0 1
2199: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2200: LD_INT 0
2202: PPUSH
2203: PPUSH
2204: PPUSH
2205: PPUSH
2206: PPUSH
2207: PPUSH
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
2208: LD_ADDR_VAR 0 5
2212: PUSH
2213: LD_INT 6
2215: PUSH
2216: LD_INT 7
2218: PUSH
2219: LD_INT 8
2221: PUSH
2222: EMPTY
2223: LIST
2224: LIST
2225: LIST
2226: PUSH
2227: LD_OWVAR 67
2231: ARRAY
2232: ST_TO_ADDR
// uc_side := 2 ;
2233: LD_ADDR_OWVAR 20
2237: PUSH
2238: LD_INT 2
2240: ST_TO_ADDR
// uc_nation := 2 ;
2241: LD_ADDR_OWVAR 21
2245: PUSH
2246: LD_INT 2
2248: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2249: LD_ADDR_OWVAR 37
2253: PUSH
2254: LD_INT 14
2256: ST_TO_ADDR
// vc_engine := engine_siberite ;
2257: LD_ADDR_OWVAR 39
2261: PUSH
2262: LD_INT 3
2264: ST_TO_ADDR
// vc_control := control_manual ;
2265: LD_ADDR_OWVAR 38
2269: PUSH
2270: LD_INT 1
2272: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2273: LD_ADDR_OWVAR 40
2277: PUSH
2278: LD_INT 31
2280: ST_TO_ADDR
// for i = 1 to 3 do
2281: LD_ADDR_VAR 0 2
2285: PUSH
2286: DOUBLE
2287: LD_INT 1
2289: DEC
2290: ST_TO_ADDR
2291: LD_INT 3
2293: PUSH
2294: FOR_TO
2295: IFFALSE 2379
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2297: LD_INT 0
2299: PPUSH
2300: LD_INT 3
2302: PPUSH
2303: LD_VAR 0 5
2307: PPUSH
2308: CALL_OW 380
// un := CreateVehicle ;
2312: LD_ADDR_VAR 0 4
2316: PUSH
2317: CALL_OW 45
2321: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2322: LD_VAR 0 4
2326: PPUSH
2327: LD_INT 0
2329: PPUSH
2330: LD_INT 5
2332: PPUSH
2333: CALL_OW 12
2337: PPUSH
2338: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2342: LD_VAR 0 4
2346: PPUSH
2347: LD_INT 156
2349: PPUSH
2350: LD_INT 15
2352: PPUSH
2353: LD_INT 6
2355: PPUSH
2356: LD_INT 0
2358: PPUSH
2359: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2363: CALL_OW 44
2367: PPUSH
2368: LD_VAR 0 4
2372: PPUSH
2373: CALL_OW 52
// end ;
2377: GO 2294
2379: POP
2380: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ - 1 , 5 , - 1 , 4 ] ) ;
2381: LD_ADDR_EXP 37
2385: PUSH
2386: LD_INT 94
2388: PPUSH
2389: LD_INT 28
2391: PPUSH
2392: LD_STRING dammam
2394: PPUSH
2395: LD_VAR 0 5
2399: PPUSH
2400: LD_INT 10000
2402: PUSH
2403: LD_INT 1000
2405: PUSH
2406: LD_INT 300
2408: PUSH
2409: EMPTY
2410: LIST
2411: LIST
2412: LIST
2413: PPUSH
2414: LD_INT 1
2416: NEG
2417: PUSH
2418: LD_INT 5
2420: PUSH
2421: LD_INT 1
2423: NEG
2424: PUSH
2425: LD_INT 4
2427: PUSH
2428: EMPTY
2429: LIST
2430: LIST
2431: LIST
2432: LIST
2433: PPUSH
2434: CALL 54193 0 6
2438: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ - 1 , 4 , 2 , 0 ] ) ;
2439: LD_ADDR_EXP 37
2443: PUSH
2444: LD_EXP 37
2448: PUSH
2449: LD_INT 122
2451: PPUSH
2452: LD_INT 25
2454: PPUSH
2455: LD_STRING 
2457: PPUSH
2458: LD_VAR 0 5
2462: PPUSH
2463: LD_INT 500
2465: PUSH
2466: LD_INT 60
2468: PUSH
2469: LD_INT 0
2471: PUSH
2472: EMPTY
2473: LIST
2474: LIST
2475: LIST
2476: PPUSH
2477: LD_INT 1
2479: NEG
2480: PUSH
2481: LD_INT 4
2483: PUSH
2484: LD_INT 2
2486: PUSH
2487: LD_INT 0
2489: PUSH
2490: EMPTY
2491: LIST
2492: LIST
2493: LIST
2494: LIST
2495: PPUSH
2496: CALL 54193 0 6
2500: UNION
2501: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ - 1 , 5 , 3 , 2 ] ) ;
2502: LD_ADDR_EXP 35
2506: PUSH
2507: LD_INT 45
2509: PPUSH
2510: LD_INT 24
2512: PPUSH
2513: LD_STRING jeddah
2515: PPUSH
2516: LD_VAR 0 5
2520: PPUSH
2521: LD_INT 700
2523: PUSH
2524: LD_INT 300
2526: PUSH
2527: LD_INT 10
2529: PUSH
2530: EMPTY
2531: LIST
2532: LIST
2533: LIST
2534: PPUSH
2535: LD_INT 1
2537: NEG
2538: PUSH
2539: LD_INT 5
2541: PUSH
2542: LD_INT 3
2544: PUSH
2545: LD_INT 2
2547: PUSH
2548: EMPTY
2549: LIST
2550: LIST
2551: LIST
2552: LIST
2553: PPUSH
2554: CALL 54193 0 6
2558: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
2559: LD_ADDR_EXP 36
2563: PUSH
2564: LD_INT 7
2566: PPUSH
2567: LD_INT 27
2569: PPUSH
2570: LD_STRING riyadh
2572: PPUSH
2573: LD_VAR 0 5
2577: PPUSH
2578: LD_INT 500
2580: PUSH
2581: LD_INT 60
2583: PUSH
2584: LD_INT 0
2586: PUSH
2587: EMPTY
2588: LIST
2589: LIST
2590: LIST
2591: PPUSH
2592: LD_INT 4
2594: PUSH
2595: LD_INT 2
2597: PUSH
2598: LD_INT 3
2600: PUSH
2601: LD_INT 1
2603: PUSH
2604: EMPTY
2605: LIST
2606: LIST
2607: LIST
2608: LIST
2609: PPUSH
2610: CALL 54193 0 6
2614: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ - 1 , 3 , 3 , 2 ] ) ;
2615: LD_ADDR_EXP 39
2619: PUSH
2620: LD_INT 204
2622: PPUSH
2623: LD_INT 26
2625: PPUSH
2626: LD_STRING 
2628: PPUSH
2629: LD_VAR 0 5
2633: PPUSH
2634: LD_INT 500
2636: PUSH
2637: LD_INT 50
2639: PUSH
2640: LD_INT 0
2642: PUSH
2643: EMPTY
2644: LIST
2645: LIST
2646: LIST
2647: PPUSH
2648: LD_INT 1
2650: NEG
2651: PUSH
2652: LD_INT 3
2654: PUSH
2655: LD_INT 3
2657: PUSH
2658: LD_INT 2
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: LIST
2665: LIST
2666: PPUSH
2667: CALL 54193 0 6
2671: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
2672: LD_ADDR_EXP 50
2676: PUSH
2677: LD_EXP 37
2681: PUSH
2682: LD_EXP 35
2686: PUSH
2687: LD_EXP 39
2691: PUSH
2692: EMPTY
2693: LIST
2694: LIST
2695: LIST
2696: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
2697: LD_ADDR_VAR 0 2
2701: PUSH
2702: LD_INT 22
2704: PUSH
2705: LD_INT 2
2707: PUSH
2708: EMPTY
2709: LIST
2710: LIST
2711: PUSH
2712: LD_INT 30
2714: PUSH
2715: LD_INT 31
2717: PUSH
2718: EMPTY
2719: LIST
2720: LIST
2721: PUSH
2722: LD_INT 58
2724: PUSH
2725: EMPTY
2726: LIST
2727: PUSH
2728: EMPTY
2729: LIST
2730: LIST
2731: LIST
2732: PPUSH
2733: CALL_OW 69
2737: PUSH
2738: FOR_IN
2739: IFFALSE 2864
// begin if GetBase ( i ) then
2741: LD_VAR 0 2
2745: PPUSH
2746: CALL_OW 274
2750: IFFALSE 2754
// continue ;
2752: GO 2738
// d := GetDir ( i ) ;
2754: LD_ADDR_VAR 0 3
2758: PUSH
2759: LD_VAR 0 2
2763: PPUSH
2764: CALL_OW 254
2768: ST_TO_ADDR
// if d < 3 then
2769: LD_VAR 0 3
2773: PUSH
2774: LD_INT 3
2776: LESS
2777: IFFALSE 2795
// d := d + 3 else
2779: LD_ADDR_VAR 0 3
2783: PUSH
2784: LD_VAR 0 3
2788: PUSH
2789: LD_INT 3
2791: PLUS
2792: ST_TO_ADDR
2793: GO 2809
// d := d - 3 ;
2795: LD_ADDR_VAR 0 3
2799: PUSH
2800: LD_VAR 0 3
2804: PUSH
2805: LD_INT 3
2807: MINUS
2808: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
2809: LD_INT 0
2811: PPUSH
2812: LD_INT 8
2814: PPUSH
2815: LD_VAR 0 5
2819: PPUSH
2820: CALL_OW 380
// un := CreateHuman ;
2824: LD_ADDR_VAR 0 4
2828: PUSH
2829: CALL_OW 44
2833: ST_TO_ADDR
// SetDir ( un , d ) ;
2834: LD_VAR 0 4
2838: PPUSH
2839: LD_VAR 0 3
2843: PPUSH
2844: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
2848: LD_VAR 0 4
2852: PPUSH
2853: LD_VAR 0 2
2857: PPUSH
2858: CALL_OW 52
// end ;
2862: GO 2738
2864: POP
2865: POP
// if Difficulty > 1 then
2866: LD_OWVAR 67
2870: PUSH
2871: LD_INT 1
2873: GREATER
2874: IFFALSE 3245
// begin ar_kamikadze := [ ] ;
2876: LD_ADDR_EXP 42
2880: PUSH
2881: EMPTY
2882: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
2883: LD_INT 0
2885: PPUSH
2886: LD_INT 1
2888: PPUSH
2889: LD_VAR 0 5
2893: PPUSH
2894: CALL_OW 380
// un := CreateHuman ;
2898: LD_ADDR_VAR 0 4
2902: PUSH
2903: CALL_OW 44
2907: ST_TO_ADDR
// SetDir ( un , 3 ) ;
2908: LD_VAR 0 4
2912: PPUSH
2913: LD_INT 3
2915: PPUSH
2916: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
2920: LD_VAR 0 4
2924: PPUSH
2925: LD_INT 23
2927: PPUSH
2928: LD_INT 44
2930: PPUSH
2931: LD_INT 0
2933: PPUSH
2934: CALL_OW 48
// ComCrawl ( un ) ;
2938: LD_VAR 0 4
2942: PPUSH
2943: CALL_OW 137
// un := CreateHuman ;
2947: LD_ADDR_VAR 0 4
2951: PUSH
2952: CALL_OW 44
2956: ST_TO_ADDR
// SetDir ( un , 3 ) ;
2957: LD_VAR 0 4
2961: PPUSH
2962: LD_INT 3
2964: PPUSH
2965: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
2969: LD_VAR 0 4
2973: PPUSH
2974: LD_INT 30
2976: PPUSH
2977: LD_INT 39
2979: PPUSH
2980: LD_INT 0
2982: PPUSH
2983: CALL_OW 48
// ComCrawl ( un ) ;
2987: LD_VAR 0 4
2991: PPUSH
2992: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
2996: LD_INT 0
2998: PPUSH
2999: LD_INT 17
3001: PPUSH
3002: LD_VAR 0 5
3006: PPUSH
3007: CALL_OW 380
// un := CreateHuman ;
3011: LD_ADDR_VAR 0 4
3015: PUSH
3016: CALL_OW 44
3020: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3021: LD_VAR 0 4
3025: PPUSH
3026: LD_INT 3
3028: PPUSH
3029: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3033: LD_VAR 0 4
3037: PPUSH
3038: LD_INT 45
3040: PPUSH
3041: LD_INT 86
3043: PPUSH
3044: LD_INT 0
3046: PPUSH
3047: CALL_OW 48
// ComHold ( un ) ;
3051: LD_VAR 0 4
3055: PPUSH
3056: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3060: LD_ADDR_EXP 42
3064: PUSH
3065: LD_EXP 42
3069: PPUSH
3070: LD_EXP 42
3074: PUSH
3075: LD_INT 1
3077: PLUS
3078: PPUSH
3079: LD_VAR 0 4
3083: PPUSH
3084: CALL_OW 1
3088: ST_TO_ADDR
// un := CreateHuman ;
3089: LD_ADDR_VAR 0 4
3093: PUSH
3094: CALL_OW 44
3098: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3099: LD_VAR 0 4
3103: PPUSH
3104: LD_INT 3
3106: PPUSH
3107: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3111: LD_VAR 0 4
3115: PPUSH
3116: LD_INT 60
3118: PPUSH
3119: LD_INT 85
3121: PPUSH
3122: LD_INT 0
3124: PPUSH
3125: CALL_OW 48
// ComHold ( un ) ;
3129: LD_VAR 0 4
3133: PPUSH
3134: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3138: LD_ADDR_EXP 42
3142: PUSH
3143: LD_EXP 42
3147: PPUSH
3148: LD_EXP 42
3152: PUSH
3153: LD_INT 1
3155: PLUS
3156: PPUSH
3157: LD_VAR 0 4
3161: PPUSH
3162: CALL_OW 1
3166: ST_TO_ADDR
// un := CreateHuman ;
3167: LD_ADDR_VAR 0 4
3171: PUSH
3172: CALL_OW 44
3176: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3177: LD_VAR 0 4
3181: PPUSH
3182: LD_INT 3
3184: PPUSH
3185: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3189: LD_VAR 0 4
3193: PPUSH
3194: LD_INT 222
3196: PPUSH
3197: LD_INT 166
3199: PPUSH
3200: LD_INT 0
3202: PPUSH
3203: CALL_OW 48
// ComHold ( un ) ;
3207: LD_VAR 0 4
3211: PPUSH
3212: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3216: LD_ADDR_EXP 42
3220: PUSH
3221: LD_EXP 42
3225: PPUSH
3226: LD_EXP 42
3230: PUSH
3231: LD_INT 1
3233: PLUS
3234: PPUSH
3235: LD_VAR 0 4
3239: PPUSH
3240: CALL_OW 1
3244: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3245: LD_ADDR_EXP 40
3249: PUSH
3250: EMPTY
3251: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3252: LD_INT 1
3254: PPUSH
3255: LD_INT 1
3257: PPUSH
3258: LD_VAR 0 5
3262: PPUSH
3263: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3267: LD_ADDR_OWVAR 26
3271: PUSH
3272: LD_STRING Pavel Grigorovic
3274: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3275: LD_ADDR_OWVAR 33
3279: PUSH
3280: LD_STRING SecondCharsGal
3282: ST_TO_ADDR
// hc_face_number := 4 ;
3283: LD_ADDR_OWVAR 34
3287: PUSH
3288: LD_INT 4
3290: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3291: LD_ADDR_EXP 40
3295: PUSH
3296: LD_EXP 40
3300: PPUSH
3301: LD_INT 1
3303: PPUSH
3304: CALL_OW 44
3308: PPUSH
3309: CALL_OW 1
3313: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3314: LD_INT 2
3316: PPUSH
3317: LD_INT 4
3319: PPUSH
3320: LD_VAR 0 5
3324: PPUSH
3325: CALL_OW 380
// hc_name := Lucy Sebel ;
3329: LD_ADDR_OWVAR 26
3333: PUSH
3334: LD_STRING Lucy Sebel
3336: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3337: LD_ADDR_OWVAR 33
3341: PUSH
3342: LD_STRING SecondCharsGal
3344: ST_TO_ADDR
// hc_face_number := 15 ;
3345: LD_ADDR_OWVAR 34
3349: PUSH
3350: LD_INT 15
3352: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3353: LD_ADDR_EXP 40
3357: PUSH
3358: LD_EXP 40
3362: PPUSH
3363: LD_INT 2
3365: PPUSH
3366: CALL_OW 44
3370: PPUSH
3371: CALL_OW 1
3375: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
3376: LD_INT 2
3378: PPUSH
3379: LD_INT 4
3381: PPUSH
3382: LD_VAR 0 5
3386: PPUSH
3387: CALL_OW 380
// hc_gallery :=  ;
3391: LD_ADDR_OWVAR 33
3395: PUSH
3396: LD_STRING 
3398: ST_TO_ADDR
// hc_name :=  ;
3399: LD_ADDR_OWVAR 26
3403: PUSH
3404: LD_STRING 
3406: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3407: LD_ADDR_EXP 40
3411: PUSH
3412: LD_EXP 40
3416: PPUSH
3417: LD_INT 3
3419: PPUSH
3420: CALL_OW 44
3424: PPUSH
3425: CALL_OW 1
3429: ST_TO_ADDR
// hc_sex := sex_male ;
3430: LD_ADDR_OWVAR 27
3434: PUSH
3435: LD_INT 1
3437: ST_TO_ADDR
// hc_class = 11 ;
3438: LD_ADDR_OWVAR 28
3442: PUSH
3443: LD_INT 11
3445: ST_TO_ADDR
// hc_gallery = sandar ;
3446: LD_ADDR_OWVAR 33
3450: PUSH
3451: LD_STRING sandar
3453: ST_TO_ADDR
// hc_face_number = 33 ;
3454: LD_ADDR_OWVAR 34
3458: PUSH
3459: LD_INT 33
3461: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
3462: LD_ADDR_OWVAR 26
3466: PUSH
3467: LD_STRING Thabit Muhair Saliba
3469: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
3470: LD_ADDR_OWVAR 31
3474: PUSH
3475: LD_INT 0
3477: PUSH
3478: LD_INT 0
3480: PUSH
3481: LD_INT 0
3483: PUSH
3484: LD_INT 0
3486: PUSH
3487: EMPTY
3488: LIST
3489: LIST
3490: LIST
3491: LIST
3492: ST_TO_ADDR
// Saliba = CreateHuman ;
3493: LD_ADDR_EXP 44
3497: PUSH
3498: CALL_OW 44
3502: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
3503: LD_EXP 44
3507: PPUSH
3508: LD_INT 7
3510: PPUSH
3511: CALL_OW 52
// if gensher_active then
3515: LD_EXP 18
3519: IFFALSE 3546
// begin Gensher = NewCharacter ( Dietrich ) ;
3521: LD_ADDR_EXP 45
3525: PUSH
3526: LD_STRING Dietrich
3528: PPUSH
3529: CALL_OW 25
3533: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
3534: LD_EXP 45
3538: PPUSH
3539: LD_INT 94
3541: PPUSH
3542: CALL_OW 52
// end ; InitHc ;
3546: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
3550: LD_ADDR_EXP 41
3554: PUSH
3555: EMPTY
3556: ST_TO_ADDR
// for i = 1 to 5 do
3557: LD_ADDR_VAR 0 2
3561: PUSH
3562: DOUBLE
3563: LD_INT 1
3565: DEC
3566: ST_TO_ADDR
3567: LD_INT 5
3569: PUSH
3570: FOR_TO
3571: IFFALSE 3743
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
3573: LD_INT 13
3575: PUSH
3576: LD_INT 14
3578: PUSH
3579: EMPTY
3580: LIST
3581: LIST
3582: PUSH
3583: LD_INT 1
3585: PPUSH
3586: LD_INT 2
3588: PPUSH
3589: CALL_OW 12
3593: ARRAY
3594: PPUSH
3595: LD_INT 1
3597: PUSH
3598: LD_INT 2
3600: PUSH
3601: EMPTY
3602: LIST
3603: LIST
3604: PUSH
3605: LD_INT 1
3607: PPUSH
3608: LD_INT 2
3610: PPUSH
3611: CALL_OW 12
3615: ARRAY
3616: PPUSH
3617: LD_INT 1
3619: PPUSH
3620: LD_INT 25
3622: PUSH
3623: LD_INT 27
3625: PUSH
3626: LD_INT 26
3628: PUSH
3629: EMPTY
3630: LIST
3631: LIST
3632: LIST
3633: PUSH
3634: LD_INT 1
3636: PPUSH
3637: LD_INT 3
3639: PPUSH
3640: CALL_OW 12
3644: ARRAY
3645: PPUSH
3646: LD_INT 60
3648: PPUSH
3649: LD_INT 100
3651: PPUSH
3652: CALL_OW 12
3656: PPUSH
3657: CALL 50751 0 5
// un := CreateVehicle ;
3661: LD_ADDR_VAR 0 4
3665: PUSH
3666: CALL_OW 45
3670: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
3671: LD_ADDR_EXP 41
3675: PUSH
3676: LD_EXP 41
3680: PPUSH
3681: LD_EXP 41
3685: PUSH
3686: LD_INT 1
3688: PLUS
3689: PPUSH
3690: LD_VAR 0 4
3694: PPUSH
3695: CALL_OW 1
3699: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3700: LD_VAR 0 4
3704: PPUSH
3705: LD_INT 0
3707: PPUSH
3708: LD_INT 5
3710: PPUSH
3711: CALL_OW 12
3715: PPUSH
3716: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
3720: LD_VAR 0 4
3724: PPUSH
3725: LD_INT 124
3727: PPUSH
3728: LD_INT 141
3730: PPUSH
3731: LD_INT 8
3733: PPUSH
3734: LD_INT 0
3736: PPUSH
3737: CALL_OW 50
// end ;
3741: GO 3570
3743: POP
3744: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
3745: LD_ADDR_EXP 43
3749: PUSH
3750: EMPTY
3751: PUSH
3752: EMPTY
3753: PUSH
3754: EMPTY
3755: PUSH
3756: EMPTY
3757: LIST
3758: LIST
3759: LIST
3760: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
3761: LD_ADDR_VAR 0 3
3765: PUSH
3766: DOUBLE
3767: LD_INT 1
3769: DEC
3770: ST_TO_ADDR
3771: LD_INT 3
3773: PUSH
3774: LD_INT 3
3776: PUSH
3777: LD_INT 4
3779: PUSH
3780: EMPTY
3781: LIST
3782: LIST
3783: LIST
3784: PUSH
3785: LD_OWVAR 67
3789: ARRAY
3790: PUSH
3791: FOR_TO
3792: IFFALSE 4006
// for i = 1 to 3 do
3794: LD_ADDR_VAR 0 2
3798: PUSH
3799: DOUBLE
3800: LD_INT 1
3802: DEC
3803: ST_TO_ADDR
3804: LD_INT 3
3806: PUSH
3807: FOR_TO
3808: IFFALSE 4002
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
3810: LD_INT 14
3812: PPUSH
3813: LD_INT 3
3815: PUSH
3816: LD_INT 2
3818: PUSH
3819: EMPTY
3820: LIST
3821: LIST
3822: PUSH
3823: LD_INT 1
3825: PPUSH
3826: LD_INT 2
3828: PPUSH
3829: CALL_OW 12
3833: ARRAY
3834: PPUSH
3835: LD_INT 1
3837: PUSH
3838: LD_INT 5
3840: PUSH
3841: EMPTY
3842: LIST
3843: LIST
3844: PUSH
3845: LD_INT 1
3847: PPUSH
3848: LD_INT 2
3850: PPUSH
3851: CALL_OW 12
3855: ARRAY
3856: PPUSH
3857: LD_INT 25
3859: PUSH
3860: LD_INT 27
3862: PUSH
3863: LD_INT 26
3865: PUSH
3866: LD_INT 28
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: PUSH
3875: LD_INT 1
3877: PPUSH
3878: LD_INT 4
3880: PPUSH
3881: CALL_OW 12
3885: ARRAY
3886: PPUSH
3887: LD_INT 100
3889: PPUSH
3890: CALL 50751 0 5
// un := CreateVehicle ;
3894: LD_ADDR_VAR 0 4
3898: PUSH
3899: CALL_OW 45
3903: ST_TO_ADDR
// ar_defenders_tmp := Add ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
3904: LD_ADDR_EXP 43
3908: PUSH
3909: LD_EXP 43
3913: PPUSH
3914: LD_VAR 0 2
3918: PUSH
3919: LD_EXP 43
3923: PUSH
3924: LD_VAR 0 2
3928: ARRAY
3929: PUSH
3930: LD_INT 1
3932: PLUS
3933: PUSH
3934: EMPTY
3935: LIST
3936: LIST
3937: PPUSH
3938: LD_VAR 0 4
3942: PPUSH
3943: CALL 51308 0 3
3947: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3948: LD_VAR 0 4
3952: PPUSH
3953: LD_INT 0
3955: PPUSH
3956: LD_INT 5
3958: PPUSH
3959: CALL_OW 12
3963: PPUSH
3964: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
3968: LD_VAR 0 4
3972: PPUSH
3973: LD_INT 20
3975: PUSH
3976: LD_INT 21
3978: PUSH
3979: LD_INT 22
3981: PUSH
3982: EMPTY
3983: LIST
3984: LIST
3985: LIST
3986: PUSH
3987: LD_VAR 0 2
3991: ARRAY
3992: PPUSH
3993: LD_INT 0
3995: PPUSH
3996: CALL_OW 49
// end ;
4000: GO 3807
4002: POP
4003: POP
4004: GO 3791
4006: POP
4007: POP
// InitHc ;
4008: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4012: LD_INT 4
4014: PPUSH
4015: LD_INT 5
4017: PPUSH
4018: LD_INT 10
4020: PPUSH
4021: LD_INT 5
4023: PPUSH
4024: LD_INT 0
4026: PPUSH
4027: CALL_OW 58
// end ;
4031: LD_VAR 0 1
4035: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4036: LD_EXP 42
4040: IFFALSE 4114
4042: GO 4044
4044: DISABLE
4045: LD_INT 0
4047: PPUSH
// begin enable ;
4048: ENABLE
// for i in ar_kamikadze do
4049: LD_ADDR_VAR 0 1
4053: PUSH
4054: LD_EXP 42
4058: PUSH
4059: FOR_IN
4060: IFFALSE 4112
// if See ( 1 , i ) then
4062: LD_INT 1
4064: PPUSH
4065: LD_VAR 0 1
4069: PPUSH
4070: CALL_OW 292
4074: IFFALSE 4110
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4076: LD_VAR 0 1
4080: PPUSH
4081: LD_INT 81
4083: PUSH
4084: LD_INT 2
4086: PUSH
4087: EMPTY
4088: LIST
4089: LIST
4090: PPUSH
4091: CALL_OW 69
4095: PPUSH
4096: LD_VAR 0 1
4100: PPUSH
4101: CALL_OW 74
4105: PPUSH
4106: CALL_OW 115
4110: GO 4059
4112: POP
4113: POP
// end ;
4114: PPOPN 1
4116: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4117: LD_EXP 13
4121: IFFALSE 4438
4123: GO 4125
4125: DISABLE
4126: LD_INT 0
4128: PPUSH
4129: PPUSH
4130: PPUSH
4131: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4132: LD_INT 35
4134: PPUSH
4135: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4139: LD_INT 1
4141: PPUSH
4142: CALL 38900 0 1
4146: PUSH
4147: LD_INT 0
4149: EQUAL
4150: IFFALSE 4132
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4152: LD_INT 1
4154: PPUSH
4155: LD_INT 14
4157: PUSH
4158: LD_INT 3
4160: PUSH
4161: LD_INT 2
4163: PUSH
4164: LD_INT 32
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: LIST
4171: LIST
4172: PUSH
4173: EMPTY
4174: LIST
4175: PPUSH
4176: CALL 38446 0 2
// repeat wait ( 0 0$1 ) ;
4180: LD_INT 35
4182: PPUSH
4183: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4187: LD_EXP 69
4191: PUSH
4192: LD_INT 1
4194: ARRAY
4195: PPUSH
4196: LD_INT 33
4198: PUSH
4199: LD_INT 2
4201: PUSH
4202: EMPTY
4203: LIST
4204: LIST
4205: PUSH
4206: LD_INT 34
4208: PUSH
4209: LD_INT 32
4211: PUSH
4212: EMPTY
4213: LIST
4214: LIST
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: PPUSH
4220: CALL_OW 72
4224: IFFALSE 4180
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4226: LD_ADDR_VAR 0 2
4230: PUSH
4231: LD_EXP 69
4235: PUSH
4236: LD_INT 1
4238: ARRAY
4239: PPUSH
4240: LD_INT 33
4242: PUSH
4243: LD_INT 2
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: PUSH
4250: LD_INT 34
4252: PUSH
4253: LD_INT 32
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: PPUSH
4264: CALL_OW 72
4268: PUSH
4269: LD_INT 1
4271: ARRAY
4272: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4273: LD_ADDR_VAR 0 4
4277: PUSH
4278: LD_INT 5
4280: PPUSH
4281: CALL_OW 469
4285: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4286: LD_INT 35
4288: PPUSH
4289: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4293: LD_ADDR_VAR 0 4
4297: PUSH
4298: LD_INT 5
4300: PPUSH
4301: CALL_OW 469
4305: ST_TO_ADDR
// tmp := 100 ;
4306: LD_ADDR_VAR 0 3
4310: PUSH
4311: LD_INT 100
4313: ST_TO_ADDR
// if pos then
4314: LD_VAR 0 4
4318: IFFALSE 4358
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4320: LD_ADDR_VAR 0 3
4324: PUSH
4325: LD_INT 2
4327: PPUSH
4328: LD_VAR 0 4
4332: PUSH
4333: LD_INT 1
4335: ARRAY
4336: PPUSH
4337: LD_VAR 0 4
4341: PUSH
4342: LD_INT 2
4344: ARRAY
4345: PPUSH
4346: LD_INT 20
4348: PPUSH
4349: CALL 51802 0 4
4353: PUSH
4354: LD_INT 4
4356: ARRAY
4357: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4358: LD_VAR 0 4
4362: PUSH
4363: LD_EXP 14
4367: NOT
4368: AND
4369: PUSH
4370: LD_VAR 0 3
4374: PUSH
4375: LD_INT 10
4377: LESS
4378: AND
4379: IFFALSE 4286
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4381: LD_VAR 0 2
4385: PPUSH
4386: LD_VAR 0 4
4390: PUSH
4391: LD_INT 1
4393: ARRAY
4394: PPUSH
4395: LD_VAR 0 4
4399: PUSH
4400: LD_INT 2
4402: ARRAY
4403: PPUSH
4404: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4408: LD_VAR 0 2
4412: PPUSH
4413: LD_INT 198
4415: PPUSH
4416: LD_INT 113
4418: PPUSH
4419: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
4423: LD_VAR 0 2
4427: PPUSH
4428: LD_INT 124
4430: PPUSH
4431: LD_INT 7
4433: PPUSH
4434: CALL_OW 171
// end ;
4438: PPOPN 4
4440: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
4441: LD_EXP 6
4445: IFFALSE 7102
4447: GO 4449
4449: DISABLE
4450: LD_INT 0
4452: PPUSH
4453: PPUSH
4454: PPUSH
4455: PPUSH
4456: PPUSH
4457: PPUSH
4458: PPUSH
4459: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4460: LD_ADDR_VAR 0 4
4464: PUSH
4465: LD_INT 5
4467: PUSH
4468: LD_INT 6
4470: PUSH
4471: LD_INT 7
4473: PUSH
4474: EMPTY
4475: LIST
4476: LIST
4477: LIST
4478: PUSH
4479: LD_OWVAR 67
4483: ARRAY
4484: ST_TO_ADDR
// coords := [ ] ;
4485: LD_ADDR_VAR 0 5
4489: PUSH
4490: EMPTY
4491: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
4492: LD_ADDR_VAR 0 6
4496: PUSH
4497: LD_INT 0
4499: PUSH
4500: LD_INT 0
4502: PUSH
4503: LD_INT 0
4505: PUSH
4506: LD_INT 0
4508: PUSH
4509: LD_INT 1
4511: PUSH
4512: LD_INT 0
4514: PUSH
4515: LD_INT 0
4517: PUSH
4518: LD_INT 0
4520: PUSH
4521: LD_INT 1
4523: PUSH
4524: LD_INT 0
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: LIST
4531: LIST
4532: LIST
4533: LIST
4534: LIST
4535: LIST
4536: LIST
4537: LIST
4538: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
4539: LD_INT 1
4541: PPUSH
4542: LD_INT 14
4544: PUSH
4545: LD_INT 1
4547: PUSH
4548: LD_INT 2
4550: PUSH
4551: LD_INT 28
4553: PUSH
4554: EMPTY
4555: LIST
4556: LIST
4557: LIST
4558: LIST
4559: PUSH
4560: LD_INT 14
4562: PUSH
4563: LD_INT 1
4565: PUSH
4566: LD_INT 2
4568: PUSH
4569: LD_INT 25
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: LIST
4576: LIST
4577: PUSH
4578: LD_INT 14
4580: PUSH
4581: LD_INT 1
4583: PUSH
4584: LD_INT 2
4586: PUSH
4587: LD_INT 28
4589: PUSH
4590: EMPTY
4591: LIST
4592: LIST
4593: LIST
4594: LIST
4595: PUSH
4596: LD_INT 14
4598: PUSH
4599: LD_INT 1
4601: PUSH
4602: LD_INT 2
4604: PUSH
4605: LD_INT 29
4607: PUSH
4608: EMPTY
4609: LIST
4610: LIST
4611: LIST
4612: LIST
4613: PUSH
4614: EMPTY
4615: LIST
4616: LIST
4617: LIST
4618: LIST
4619: PPUSH
4620: CALL 38446 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
4624: LD_INT 21000
4626: PUSH
4627: LD_INT 19950
4629: PUSH
4630: LD_INT 18900
4632: PUSH
4633: EMPTY
4634: LIST
4635: LIST
4636: LIST
4637: PUSH
4638: LD_OWVAR 67
4642: ARRAY
4643: PPUSH
4644: CALL_OW 67
// InitHc ;
4648: CALL_OW 19
// InitUc ;
4652: CALL_OW 18
// uc_side := 2 ;
4656: LD_ADDR_OWVAR 20
4660: PUSH
4661: LD_INT 2
4663: ST_TO_ADDR
// uc_nation := 2 ;
4664: LD_ADDR_OWVAR 21
4668: PUSH
4669: LD_INT 2
4671: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
4672: LD_ADDR_VAR 0 3
4676: PUSH
4677: EMPTY
4678: PUSH
4679: EMPTY
4680: PUSH
4681: EMPTY
4682: PUSH
4683: EMPTY
4684: PUSH
4685: EMPTY
4686: PUSH
4687: EMPTY
4688: LIST
4689: LIST
4690: LIST
4691: LIST
4692: LIST
4693: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_weapon , ar_cargo_bay ] ) ) ;
4694: LD_ADDR_VAR 0 3
4698: PUSH
4699: LD_VAR 0 3
4703: PPUSH
4704: LD_INT 1
4706: PPUSH
4707: LD_EXP 69
4711: PUSH
4712: LD_INT 1
4714: ARRAY
4715: PUSH
4716: LD_INT 34
4718: PUSH
4719: LD_INT 32
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: PPUSH
4726: CALL_OW 69
4730: DIFF
4731: PPUSH
4732: CALL_OW 1
4736: ST_TO_ADDR
// for i = 1 to Difficulty do
4737: LD_ADDR_VAR 0 1
4741: PUSH
4742: DOUBLE
4743: LD_INT 1
4745: DEC
4746: ST_TO_ADDR
4747: LD_OWVAR 67
4751: PUSH
4752: FOR_TO
4753: IFFALSE 4891
// begin uc_side := 2 ;
4755: LD_ADDR_OWVAR 20
4759: PUSH
4760: LD_INT 2
4762: ST_TO_ADDR
// uc_nation := 2 ;
4763: LD_ADDR_OWVAR 21
4767: PUSH
4768: LD_INT 2
4770: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
4771: LD_INT 13
4773: PPUSH
4774: LD_INT 3
4776: PPUSH
4777: LD_INT 5
4779: PPUSH
4780: LD_INT 29
4782: PPUSH
4783: LD_INT 100
4785: PPUSH
4786: CALL 50751 0 5
// un := CreateVehicle ;
4790: LD_ADDR_VAR 0 2
4794: PUSH
4795: CALL_OW 45
4799: ST_TO_ADDR
// tmp := Add ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
4800: LD_ADDR_VAR 0 3
4804: PUSH
4805: LD_VAR 0 3
4809: PPUSH
4810: LD_INT 1
4812: PUSH
4813: LD_VAR 0 3
4817: PUSH
4818: LD_INT 1
4820: ARRAY
4821: PUSH
4822: LD_INT 1
4824: PLUS
4825: PUSH
4826: EMPTY
4827: LIST
4828: LIST
4829: PPUSH
4830: LD_VAR 0 2
4834: PPUSH
4835: CALL 51308 0 3
4839: ST_TO_ADDR
// SetDir ( un , 3 ) ;
4840: LD_VAR 0 2
4844: PPUSH
4845: LD_INT 3
4847: PPUSH
4848: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
4852: LD_VAR 0 2
4856: PPUSH
4857: LD_INT 16
4859: PPUSH
4860: LD_INT 0
4862: PPUSH
4863: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
4867: LD_VAR 0 2
4871: PPUSH
4872: LD_INT 51
4874: PPUSH
4875: LD_INT 10
4877: PPUSH
4878: CALL_OW 111
// wait ( 0 0$2 ) ;
4882: LD_INT 70
4884: PPUSH
4885: CALL_OW 67
// end ;
4889: GO 4752
4891: POP
4892: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
4893: LD_ADDR_VAR 0 5
4897: PUSH
4898: LD_INT 51
4900: PUSH
4901: LD_INT 24
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: PUSH
4908: LD_INT 75
4910: PUSH
4911: LD_INT 90
4913: PUSH
4914: EMPTY
4915: LIST
4916: LIST
4917: PUSH
4918: EMPTY
4919: LIST
4920: LIST
4921: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
4922: LD_INT 1
4924: PPUSH
4925: LD_VAR 0 3
4929: PUSH
4930: LD_INT 1
4932: ARRAY
4933: PPUSH
4934: LD_VAR 0 5
4938: PPUSH
4939: LD_VAR 0 6
4943: PPUSH
4944: CALL 38737 0 4
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
4948: LD_ADDR_VAR 0 1
4952: PUSH
4953: DOUBLE
4954: LD_INT 1
4956: DEC
4957: ST_TO_ADDR
4958: LD_INT 2
4960: PUSH
4961: LD_INT 3
4963: PUSH
4964: LD_INT 3
4966: PUSH
4967: EMPTY
4968: LIST
4969: LIST
4970: LIST
4971: PUSH
4972: LD_OWVAR 67
4976: ARRAY
4977: PUSH
4978: FOR_TO
4979: IFFALSE 5079
// begin uc_side := 2 ;
4981: LD_ADDR_OWVAR 20
4985: PUSH
4986: LD_INT 2
4988: ST_TO_ADDR
// uc_nation := 2 ;
4989: LD_ADDR_OWVAR 21
4993: PUSH
4994: LD_INT 2
4996: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
4997: LD_INT 0
4999: PPUSH
5000: LD_INT 17
5002: PPUSH
5003: LD_VAR 0 4
5007: PPUSH
5008: CALL_OW 380
// un := CreateHuman ;
5012: LD_ADDR_VAR 0 2
5016: PUSH
5017: CALL_OW 44
5021: ST_TO_ADDR
// tmp := Add ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5022: LD_ADDR_VAR 0 3
5026: PUSH
5027: LD_VAR 0 3
5031: PPUSH
5032: LD_INT 2
5034: PUSH
5035: LD_VAR 0 3
5039: PUSH
5040: LD_INT 2
5042: ARRAY
5043: PUSH
5044: LD_INT 1
5046: PLUS
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PPUSH
5052: LD_VAR 0 2
5056: PPUSH
5057: CALL 51308 0 3
5061: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5062: LD_VAR 0 2
5066: PPUSH
5067: LD_INT 13
5069: PPUSH
5070: LD_INT 0
5072: PPUSH
5073: CALL_OW 49
// end ;
5077: GO 4978
5079: POP
5080: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
5081: LD_ADDR_VAR 0 1
5085: PUSH
5086: DOUBLE
5087: LD_INT 1
5089: DEC
5090: ST_TO_ADDR
5091: LD_INT 2
5093: PUSH
5094: LD_INT 3
5096: PUSH
5097: LD_INT 3
5099: PUSH
5100: EMPTY
5101: LIST
5102: LIST
5103: LIST
5104: PUSH
5105: LD_OWVAR 67
5109: ARRAY
5110: PUSH
5111: FOR_TO
5112: IFFALSE 5231
// begin uc_side := 2 ;
5114: LD_ADDR_OWVAR 20
5118: PUSH
5119: LD_INT 2
5121: ST_TO_ADDR
// uc_nation := 2 ;
5122: LD_ADDR_OWVAR 21
5126: PUSH
5127: LD_INT 2
5129: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ rand ( 1 , 2 ) ] , skill ) ;
5130: LD_INT 0
5132: PPUSH
5133: LD_INT 1
5135: PUSH
5136: LD_INT 8
5138: PUSH
5139: EMPTY
5140: LIST
5141: LIST
5142: PUSH
5143: LD_INT 1
5145: PPUSH
5146: LD_INT 2
5148: PPUSH
5149: CALL_OW 12
5153: ARRAY
5154: PPUSH
5155: LD_VAR 0 4
5159: PPUSH
5160: CALL_OW 380
// un := CreateHuman ;
5164: LD_ADDR_VAR 0 2
5168: PUSH
5169: CALL_OW 44
5173: ST_TO_ADDR
// tmp := Add ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5174: LD_ADDR_VAR 0 3
5178: PUSH
5179: LD_VAR 0 3
5183: PPUSH
5184: LD_INT 2
5186: PUSH
5187: LD_VAR 0 3
5191: PUSH
5192: LD_INT 2
5194: ARRAY
5195: PUSH
5196: LD_INT 1
5198: PLUS
5199: PUSH
5200: EMPTY
5201: LIST
5202: LIST
5203: PPUSH
5204: LD_VAR 0 2
5208: PPUSH
5209: CALL 51308 0 3
5213: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5214: LD_VAR 0 2
5218: PPUSH
5219: LD_INT 13
5221: PPUSH
5222: LD_INT 0
5224: PPUSH
5225: CALL_OW 49
// end ;
5229: GO 5111
5231: POP
5232: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5233: LD_ADDR_VAR 0 5
5237: PUSH
5238: LD_INT 67
5240: PUSH
5241: LD_INT 112
5243: PUSH
5244: EMPTY
5245: LIST
5246: LIST
5247: PUSH
5248: LD_INT 85
5250: PUSH
5251: LD_INT 130
5253: PUSH
5254: EMPTY
5255: LIST
5256: LIST
5257: PUSH
5258: EMPTY
5259: LIST
5260: LIST
5261: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5262: LD_INT 2
5264: PPUSH
5265: LD_VAR 0 3
5269: PUSH
5270: LD_INT 2
5272: ARRAY
5273: PPUSH
5274: LD_VAR 0 5
5278: PPUSH
5279: LD_VAR 0 6
5283: PPUSH
5284: CALL 38737 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5288: LD_ADDR_VAR 0 1
5292: PUSH
5293: DOUBLE
5294: LD_INT 1
5296: DEC
5297: ST_TO_ADDR
5298: LD_INT 1
5300: PUSH
5301: LD_INT 2
5303: PUSH
5304: LD_INT 3
5306: PUSH
5307: EMPTY
5308: LIST
5309: LIST
5310: LIST
5311: PUSH
5312: LD_OWVAR 67
5316: ARRAY
5317: PUSH
5318: FOR_TO
5319: IFFALSE 5419
// begin uc_side := 2 ;
5321: LD_ADDR_OWVAR 20
5325: PUSH
5326: LD_INT 2
5328: ST_TO_ADDR
// uc_nation := 2 ;
5329: LD_ADDR_OWVAR 21
5333: PUSH
5334: LD_INT 2
5336: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5337: LD_INT 0
5339: PPUSH
5340: LD_INT 17
5342: PPUSH
5343: LD_VAR 0 4
5347: PPUSH
5348: CALL_OW 380
// un := CreateHuman ;
5352: LD_ADDR_VAR 0 2
5356: PUSH
5357: CALL_OW 44
5361: ST_TO_ADDR
// tmp := Add ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5362: LD_ADDR_VAR 0 3
5366: PUSH
5367: LD_VAR 0 3
5371: PPUSH
5372: LD_INT 3
5374: PUSH
5375: LD_VAR 0 3
5379: PUSH
5380: LD_INT 3
5382: ARRAY
5383: PUSH
5384: LD_INT 1
5386: PLUS
5387: PUSH
5388: EMPTY
5389: LIST
5390: LIST
5391: PPUSH
5392: LD_VAR 0 2
5396: PPUSH
5397: CALL 51308 0 3
5401: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5402: LD_VAR 0 2
5406: PPUSH
5407: LD_INT 14
5409: PPUSH
5410: LD_INT 0
5412: PPUSH
5413: CALL_OW 49
// end ;
5417: GO 5318
5419: POP
5420: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
5421: LD_ADDR_VAR 0 5
5425: PUSH
5426: LD_INT 148
5428: PUSH
5429: LD_INT 158
5431: PUSH
5432: EMPTY
5433: LIST
5434: LIST
5435: PUSH
5436: LD_INT 148
5438: PUSH
5439: LD_INT 158
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: PUSH
5446: EMPTY
5447: LIST
5448: LIST
5449: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
5450: LD_INT 3
5452: PPUSH
5453: LD_VAR 0 3
5457: PUSH
5458: LD_INT 3
5460: ARRAY
5461: PPUSH
5462: LD_VAR 0 5
5466: PPUSH
5467: LD_VAR 0 6
5471: PPUSH
5472: CALL 38737 0 4
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
5476: LD_ADDR_VAR 0 1
5480: PUSH
5481: DOUBLE
5482: LD_INT 1
5484: DEC
5485: ST_TO_ADDR
5486: LD_INT 3
5488: PUSH
5489: LD_INT 4
5491: PUSH
5492: LD_INT 4
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: LIST
5499: PUSH
5500: LD_OWVAR 67
5504: ARRAY
5505: PUSH
5506: FOR_TO
5507: IFFALSE 5731
// begin uc_side := 2 ;
5509: LD_ADDR_OWVAR 20
5513: PUSH
5514: LD_INT 2
5516: ST_TO_ADDR
// uc_nation := 2 ;
5517: LD_ADDR_OWVAR 21
5521: PUSH
5522: LD_INT 2
5524: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
5525: LD_INT 14
5527: PPUSH
5528: LD_INT 3
5530: PPUSH
5531: LD_INT 1
5533: PUSH
5534: LD_INT 5
5536: PUSH
5537: EMPTY
5538: LIST
5539: LIST
5540: PUSH
5541: LD_INT 1
5543: PPUSH
5544: LD_INT 2
5546: PPUSH
5547: CALL_OW 12
5551: ARRAY
5552: PPUSH
5553: LD_INT 27
5555: PUSH
5556: LD_INT 26
5558: PUSH
5559: LD_INT 28
5561: PUSH
5562: EMPTY
5563: LIST
5564: LIST
5565: LIST
5566: PUSH
5567: LD_INT 1
5569: PPUSH
5570: LD_INT 3
5572: PPUSH
5573: CALL_OW 12
5577: ARRAY
5578: PPUSH
5579: LD_INT 100
5581: PPUSH
5582: CALL 50751 0 5
// un := CreateVehicle ;
5586: LD_ADDR_VAR 0 2
5590: PUSH
5591: CALL_OW 45
5595: ST_TO_ADDR
// tmp := Add ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
5596: LD_ADDR_VAR 0 3
5600: PUSH
5601: LD_VAR 0 3
5605: PPUSH
5606: LD_INT 4
5608: PUSH
5609: LD_VAR 0 3
5613: PUSH
5614: LD_INT 4
5616: ARRAY
5617: PUSH
5618: LD_INT 1
5620: PLUS
5621: PUSH
5622: EMPTY
5623: LIST
5624: LIST
5625: PPUSH
5626: LD_VAR 0 2
5630: PPUSH
5631: CALL 51308 0 3
5635: ST_TO_ADDR
// SetDir ( un , 5 ) ;
5636: LD_VAR 0 2
5640: PPUSH
5641: LD_INT 5
5643: PPUSH
5644: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
5648: LD_VAR 0 2
5652: PPUSH
5653: LD_INT 15
5655: PPUSH
5656: LD_INT 0
5658: PPUSH
5659: CALL_OW 49
// if GetControl ( un ) = control_manual then
5663: LD_VAR 0 2
5667: PPUSH
5668: CALL_OW 263
5672: PUSH
5673: LD_INT 1
5675: EQUAL
5676: IFFALSE 5707
// begin PrepareHuman ( false , 3 , skill ) ;
5678: LD_INT 0
5680: PPUSH
5681: LD_INT 3
5683: PPUSH
5684: LD_VAR 0 4
5688: PPUSH
5689: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5693: CALL_OW 44
5697: PPUSH
5698: LD_VAR 0 2
5702: PPUSH
5703: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
5707: LD_VAR 0 2
5711: PPUSH
5712: LD_INT 179
5714: PPUSH
5715: LD_INT 135
5717: PPUSH
5718: CALL_OW 111
// wait ( 0 0$2 ) ;
5722: LD_INT 70
5724: PPUSH
5725: CALL_OW 67
// end ;
5729: GO 5506
5731: POP
5732: POP
// vc_chassis := 15 ;
5733: LD_ADDR_OWVAR 37
5737: PUSH
5738: LD_INT 15
5740: ST_TO_ADDR
// tmp := Add ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
5741: LD_ADDR_VAR 0 3
5745: PUSH
5746: LD_VAR 0 3
5750: PPUSH
5751: LD_INT 4
5753: PUSH
5754: LD_VAR 0 3
5758: PUSH
5759: LD_INT 4
5761: ARRAY
5762: PUSH
5763: LD_INT 1
5765: PLUS
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: PPUSH
5771: CALL_OW 45
5775: PPUSH
5776: CALL 51308 0 3
5780: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
5781: LD_VAR 0 3
5785: PUSH
5786: LD_INT 4
5788: ARRAY
5789: PUSH
5790: LD_VAR 0 3
5794: PUSH
5795: LD_INT 4
5797: ARRAY
5798: ARRAY
5799: PPUSH
5800: LD_INT 15
5802: PPUSH
5803: LD_INT 0
5805: PPUSH
5806: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
5810: LD_INT 0
5812: PPUSH
5813: LD_INT 11
5815: PPUSH
5816: LD_VAR 0 4
5820: PPUSH
5821: CALL_OW 380
// tmp := Add ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
5825: LD_ADDR_VAR 0 3
5829: PUSH
5830: LD_VAR 0 3
5834: PPUSH
5835: LD_INT 4
5837: PUSH
5838: LD_VAR 0 3
5842: PUSH
5843: LD_INT 4
5845: ARRAY
5846: PUSH
5847: LD_INT 1
5849: PLUS
5850: PUSH
5851: EMPTY
5852: LIST
5853: LIST
5854: PPUSH
5855: CALL_OW 44
5859: PPUSH
5860: CALL 51308 0 3
5864: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
5865: LD_VAR 0 3
5869: PUSH
5870: LD_INT 4
5872: ARRAY
5873: PUSH
5874: LD_VAR 0 3
5878: PUSH
5879: LD_INT 4
5881: ARRAY
5882: ARRAY
5883: PPUSH
5884: LD_VAR 0 3
5888: PUSH
5889: LD_INT 4
5891: ARRAY
5892: PUSH
5893: LD_VAR 0 3
5897: PUSH
5898: LD_INT 4
5900: ARRAY
5901: PUSH
5902: LD_INT 1
5904: MINUS
5905: ARRAY
5906: PPUSH
5907: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
5911: LD_ADDR_VAR 0 5
5915: PUSH
5916: LD_INT 148
5918: PUSH
5919: LD_INT 140
5921: PUSH
5922: EMPTY
5923: LIST
5924: LIST
5925: PUSH
5926: EMPTY
5927: LIST
5928: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
5929: LD_INT 1
5931: PPUSH
5932: LD_VAR 0 3
5936: PUSH
5937: LD_INT 4
5939: ARRAY
5940: PPUSH
5941: LD_VAR 0 5
5945: PPUSH
5946: LD_VAR 0 6
5950: PPUSH
5951: CALL 38737 0 4
// if gensher_active then
5955: LD_EXP 18
5959: IFFALSE 6344
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
5961: LD_EXP 45
5965: PPUSH
5966: LD_STRING D10-Diet-1
5968: PPUSH
5969: CALL_OW 94
// for i = 1 to 2 do
5973: LD_ADDR_VAR 0 1
5977: PUSH
5978: DOUBLE
5979: LD_INT 1
5981: DEC
5982: ST_TO_ADDR
5983: LD_INT 2
5985: PUSH
5986: FOR_TO
5987: IFFALSE 6125
// begin uc_side := 2 ;
5989: LD_ADDR_OWVAR 20
5993: PUSH
5994: LD_INT 2
5996: ST_TO_ADDR
// uc_nation := 2 ;
5997: LD_ADDR_OWVAR 21
6001: PUSH
6002: LD_INT 2
6004: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6005: LD_INT 13
6007: PPUSH
6008: LD_INT 3
6010: PPUSH
6011: LD_INT 5
6013: PPUSH
6014: LD_INT 29
6016: PPUSH
6017: LD_INT 100
6019: PPUSH
6020: CALL 50751 0 5
// un := CreateVehicle ;
6024: LD_ADDR_VAR 0 2
6028: PUSH
6029: CALL_OW 45
6033: ST_TO_ADDR
// tmp := Add ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6034: LD_ADDR_VAR 0 3
6038: PUSH
6039: LD_VAR 0 3
6043: PPUSH
6044: LD_INT 5
6046: PUSH
6047: LD_VAR 0 3
6051: PUSH
6052: LD_INT 5
6054: ARRAY
6055: PUSH
6056: LD_INT 1
6058: PLUS
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: PPUSH
6064: LD_VAR 0 2
6068: PPUSH
6069: CALL 51308 0 3
6073: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6074: LD_VAR 0 2
6078: PPUSH
6079: LD_INT 0
6081: PPUSH
6082: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6086: LD_VAR 0 2
6090: PPUSH
6091: LD_INT 23
6093: PPUSH
6094: LD_INT 0
6096: PPUSH
6097: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6101: LD_VAR 0 2
6105: PPUSH
6106: LD_INT 85
6108: PPUSH
6109: LD_INT 152
6111: PPUSH
6112: CALL_OW 111
// wait ( 0 0$2 ) ;
6116: LD_INT 70
6118: PPUSH
6119: CALL_OW 67
// end ;
6123: GO 5986
6125: POP
6126: POP
// for i = 1 to 3 do
6127: LD_ADDR_VAR 0 1
6131: PUSH
6132: DOUBLE
6133: LD_INT 1
6135: DEC
6136: ST_TO_ADDR
6137: LD_INT 3
6139: PUSH
6140: FOR_TO
6141: IFFALSE 6298
// begin uc_side := 2 ;
6143: LD_ADDR_OWVAR 20
6147: PUSH
6148: LD_INT 2
6150: ST_TO_ADDR
// uc_nation := 2 ;
6151: LD_ADDR_OWVAR 21
6155: PUSH
6156: LD_INT 2
6158: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6159: LD_INT 14
6161: PPUSH
6162: LD_INT 3
6164: PPUSH
6165: LD_INT 5
6167: PPUSH
6168: LD_INT 27
6170: PUSH
6171: LD_INT 28
6173: PUSH
6174: EMPTY
6175: LIST
6176: LIST
6177: PUSH
6178: LD_INT 1
6180: PPUSH
6181: LD_INT 2
6183: PPUSH
6184: CALL_OW 12
6188: ARRAY
6189: PPUSH
6190: LD_INT 100
6192: PPUSH
6193: CALL 50751 0 5
// un := CreateVehicle ;
6197: LD_ADDR_VAR 0 2
6201: PUSH
6202: CALL_OW 45
6206: ST_TO_ADDR
// tmp := Add ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6207: LD_ADDR_VAR 0 3
6211: PUSH
6212: LD_VAR 0 3
6216: PPUSH
6217: LD_INT 5
6219: PUSH
6220: LD_VAR 0 3
6224: PUSH
6225: LD_INT 5
6227: ARRAY
6228: PUSH
6229: LD_INT 1
6231: PLUS
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: PPUSH
6237: LD_VAR 0 2
6241: PPUSH
6242: CALL 51308 0 3
6246: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6247: LD_VAR 0 2
6251: PPUSH
6252: LD_INT 0
6254: PPUSH
6255: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6259: LD_VAR 0 2
6263: PPUSH
6264: LD_INT 23
6266: PPUSH
6267: LD_INT 0
6269: PPUSH
6270: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6274: LD_VAR 0 2
6278: PPUSH
6279: LD_INT 85
6281: PPUSH
6282: LD_INT 152
6284: PPUSH
6285: CALL_OW 111
// wait ( 0 0$2 ) ;
6289: LD_INT 70
6291: PPUSH
6292: CALL_OW 67
// end ;
6296: GO 6140
6298: POP
6299: POP
// coords := [ [ 97 , 143 ] ] ;
6300: LD_ADDR_VAR 0 5
6304: PUSH
6305: LD_INT 97
6307: PUSH
6308: LD_INT 143
6310: PUSH
6311: EMPTY
6312: LIST
6313: LIST
6314: PUSH
6315: EMPTY
6316: LIST
6317: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6318: LD_INT 1
6320: PPUSH
6321: LD_VAR 0 3
6325: PUSH
6326: LD_INT 5
6328: ARRAY
6329: PPUSH
6330: LD_VAR 0 5
6334: PPUSH
6335: LD_VAR 0 6
6339: PPUSH
6340: CALL 38737 0 4
// end ; Wait ( 13 13$00 ) ;
6344: LD_INT 27300
6346: PPUSH
6347: CALL_OW 67
// tmp := [ ] ;
6351: LD_ADDR_VAR 0 3
6355: PUSH
6356: EMPTY
6357: ST_TO_ADDR
// w := 1 ;
6358: LD_ADDR_VAR 0 7
6362: PUSH
6363: LD_INT 1
6365: ST_TO_ADDR
// repeat tmp := [ ] ;
6366: LD_ADDR_VAR 0 3
6370: PUSH
6371: EMPTY
6372: ST_TO_ADDR
// if w mod 4 = 0 then
6373: LD_VAR 0 7
6377: PUSH
6378: LD_INT 4
6380: MOD
6381: PUSH
6382: LD_INT 0
6384: EQUAL
6385: IFFALSE 6472
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6387: LD_ADDR_VAR 0 8
6391: PUSH
6392: LD_INT 11
6394: PUSH
6395: LD_INT 1
6397: PUSH
6398: LD_INT 2
6400: PUSH
6401: LD_INT 24
6403: PUSH
6404: EMPTY
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: PUSH
6410: LD_INT 11
6412: PUSH
6413: LD_INT 1
6415: PUSH
6416: LD_INT 2
6418: PUSH
6419: LD_INT 24
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: PUSH
6428: LD_INT 11
6430: PUSH
6431: LD_INT 1
6433: PUSH
6434: LD_INT 2
6436: PUSH
6437: LD_INT 24
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 11
6448: PUSH
6449: LD_INT 1
6451: PUSH
6452: LD_INT 2
6454: PUSH
6455: LD_INT 24
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: LIST
6462: LIST
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: LIST
6468: LIST
6469: ST_TO_ADDR
6470: GO 6574
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
6472: LD_ADDR_VAR 0 8
6476: PUSH
6477: LD_INT 14
6479: PUSH
6480: LD_INT 1
6482: PUSH
6483: LD_INT 2
6485: PUSH
6486: LD_INT 28
6488: PUSH
6489: EMPTY
6490: LIST
6491: LIST
6492: LIST
6493: LIST
6494: PUSH
6495: LD_INT 14
6497: PUSH
6498: LD_INT 1
6500: PUSH
6501: LD_INT 2
6503: PUSH
6504: LD_INT 25
6506: PUSH
6507: EMPTY
6508: LIST
6509: LIST
6510: LIST
6511: LIST
6512: PUSH
6513: LD_INT 14
6515: PUSH
6516: LD_INT 1
6518: PUSH
6519: LD_INT 2
6521: PUSH
6522: LD_INT 28
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: LIST
6529: LIST
6530: PUSH
6531: LD_INT 14
6533: PUSH
6534: LD_INT 1
6536: PUSH
6537: LD_INT 2
6539: PUSH
6540: LD_INT 29
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: LIST
6547: LIST
6548: PUSH
6549: LD_INT 11
6551: PUSH
6552: LD_INT 1
6554: PUSH
6555: LD_INT 2
6557: PUSH
6558: LD_INT 24
6560: PUSH
6561: EMPTY
6562: LIST
6563: LIST
6564: LIST
6565: LIST
6566: PUSH
6567: EMPTY
6568: LIST
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: ST_TO_ADDR
// if w mod 3 = 0 then
6574: LD_VAR 0 7
6578: PUSH
6579: LD_INT 3
6581: MOD
6582: PUSH
6583: LD_INT 0
6585: EQUAL
6586: IFFALSE 6662
// list := Add ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
6588: LD_ADDR_VAR 0 8
6592: PUSH
6593: LD_VAR 0 8
6597: PPUSH
6598: LD_INT 1
6600: PUSH
6601: LD_VAR 0 8
6605: PUSH
6606: LD_VAR 0 1
6610: ARRAY
6611: PUSH
6612: LD_INT 1
6614: PLUS
6615: PUSH
6616: EMPTY
6617: LIST
6618: LIST
6619: PPUSH
6620: LD_INT 14
6622: PUSH
6623: LD_INT 1
6625: PUSH
6626: LD_INT 2
6628: PUSH
6629: LD_INT 25
6631: PUSH
6632: LD_INT 28
6634: PUSH
6635: EMPTY
6636: LIST
6637: LIST
6638: PUSH
6639: LD_INT 1
6641: PPUSH
6642: LD_INT 2
6644: PPUSH
6645: CALL_OW 12
6649: ARRAY
6650: PUSH
6651: EMPTY
6652: LIST
6653: LIST
6654: LIST
6655: LIST
6656: PPUSH
6657: CALL 51308 0 3
6661: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
6662: LD_INT 1
6664: PPUSH
6665: LD_VAR 0 8
6669: PPUSH
6670: CALL 38446 0 2
// if GetSide ( ar_dep_w ) = 2 then
6674: LD_INT 45
6676: PPUSH
6677: CALL_OW 255
6681: PUSH
6682: LD_INT 2
6684: EQUAL
6685: IFFALSE 6770
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
6687: LD_ADDR_VAR 0 8
6691: PUSH
6692: LD_INT 14
6694: PUSH
6695: LD_INT 1
6697: PUSH
6698: LD_INT 2
6700: PUSH
6701: LD_INT 28
6703: PUSH
6704: EMPTY
6705: LIST
6706: LIST
6707: LIST
6708: LIST
6709: PUSH
6710: LD_INT 14
6712: PUSH
6713: LD_INT 1
6715: PUSH
6716: LD_INT 2
6718: PUSH
6719: LD_INT 27
6721: PUSH
6722: EMPTY
6723: LIST
6724: LIST
6725: LIST
6726: LIST
6727: PUSH
6728: LD_INT 14
6730: PUSH
6731: LD_INT 1
6733: PUSH
6734: LD_INT 2
6736: PUSH
6737: LD_INT 27
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: LIST
6744: LIST
6745: PUSH
6746: EMPTY
6747: LIST
6748: LIST
6749: LIST
6750: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
6751: LD_INT 2
6753: PPUSH
6754: LD_VAR 0 8
6758: PPUSH
6759: CALL 38446 0 2
// wait ( 0 0$50 ) ;
6763: LD_INT 1750
6765: PPUSH
6766: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
6770: LD_INT 35
6772: PPUSH
6773: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) >= 4 ;
6777: LD_EXP 69
6781: PUSH
6782: LD_INT 1
6784: ARRAY
6785: PPUSH
6786: LD_INT 3
6788: PUSH
6789: LD_INT 34
6791: PUSH
6792: LD_INT 32
6794: PUSH
6795: EMPTY
6796: LIST
6797: LIST
6798: PUSH
6799: EMPTY
6800: LIST
6801: LIST
6802: PPUSH
6803: CALL_OW 72
6807: PUSH
6808: LD_INT 4
6810: GREATEREQUAL
6811: IFFALSE 6770
// wait ( 0 0$10 ) ;
6813: LD_INT 350
6815: PPUSH
6816: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) ;
6820: LD_ADDR_VAR 0 3
6824: PUSH
6825: LD_EXP 69
6829: PUSH
6830: LD_INT 1
6832: ARRAY
6833: PPUSH
6834: LD_INT 3
6836: PUSH
6837: LD_INT 34
6839: PUSH
6840: LD_INT 32
6842: PUSH
6843: EMPTY
6844: LIST
6845: LIST
6846: PUSH
6847: EMPTY
6848: LIST
6849: LIST
6850: PPUSH
6851: CALL_OW 72
6855: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
6856: LD_INT 100
6858: PPUSH
6859: CALL_OW 13
6863: PUSH
6864: LD_INT 50
6866: LESS
6867: IFFALSE 6900
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
6869: LD_ADDR_VAR 0 5
6873: PUSH
6874: LD_INT 55
6876: PUSH
6877: LD_INT 7
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: PUSH
6884: LD_INT 75
6886: PUSH
6887: LD_INT 90
6889: PUSH
6890: EMPTY
6891: LIST
6892: LIST
6893: PUSH
6894: EMPTY
6895: LIST
6896: LIST
6897: ST_TO_ADDR
6898: GO 6929
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
6900: LD_ADDR_VAR 0 5
6904: PUSH
6905: LD_INT 128
6907: PUSH
6908: LD_INT 94
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: PUSH
6915: LD_INT 180
6917: PUSH
6918: LD_INT 135
6920: PUSH
6921: EMPTY
6922: LIST
6923: LIST
6924: PUSH
6925: EMPTY
6926: LIST
6927: LIST
6928: ST_TO_ADDR
// if w mod 4 = 0 then
6929: LD_VAR 0 7
6933: PUSH
6934: LD_INT 4
6936: MOD
6937: PUSH
6938: LD_INT 0
6940: EQUAL
6941: IFFALSE 6972
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
6943: LD_ADDR_VAR 0 5
6947: PUSH
6948: LD_INT 91
6950: PUSH
6951: LD_INT 58
6953: PUSH
6954: EMPTY
6955: LIST
6956: LIST
6957: PUSH
6958: LD_INT 117
6960: PUSH
6961: LD_INT 107
6963: PUSH
6964: EMPTY
6965: LIST
6966: LIST
6967: PUSH
6968: EMPTY
6969: LIST
6970: LIST
6971: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp , coords , flags ) ;
6972: LD_INT 1
6974: PPUSH
6975: LD_VAR 0 3
6979: PPUSH
6980: LD_VAR 0 5
6984: PPUSH
6985: LD_VAR 0 6
6989: PPUSH
6990: CALL 38737 0 4
// if mc_vehicles [ 2 ] then
6994: LD_EXP 69
6998: PUSH
6999: LD_INT 2
7001: ARRAY
7002: IFFALSE 7038
// MC_PrepareAttack ( 2 , mc_vehicles [ 2 ] , [ [ 73 , 115 ] ] , flags ) ;
7004: LD_INT 2
7006: PPUSH
7007: LD_EXP 69
7011: PUSH
7012: LD_INT 2
7014: ARRAY
7015: PPUSH
7016: LD_INT 73
7018: PUSH
7019: LD_INT 115
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: PUSH
7026: EMPTY
7027: LIST
7028: PPUSH
7029: LD_VAR 0 6
7033: PPUSH
7034: CALL 38737 0 4
// wait ( rand ( 9 9$30 , 12 12$30 ) ) ;
7038: LD_INT 19950
7040: PPUSH
7041: LD_INT 26250
7043: PPUSH
7044: CALL_OW 12
7048: PPUSH
7049: CALL_OW 67
// w := w + 1 ;
7053: LD_ADDR_VAR 0 7
7057: PUSH
7058: LD_VAR 0 7
7062: PUSH
7063: LD_INT 1
7065: PLUS
7066: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7067: LD_INT 94
7069: PPUSH
7070: CALL_OW 301
7074: PUSH
7075: LD_EXP 50
7079: PUSH
7080: LD_INT 1
7082: ARRAY
7083: PPUSH
7084: LD_INT 30
7086: PUSH
7087: LD_INT 3
7089: PUSH
7090: EMPTY
7091: LIST
7092: LIST
7093: PPUSH
7094: CALL_OW 72
7098: NOT
7099: OR
7100: IFFALSE 6366
// end ;
7102: PPOPN 8
7104: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7105: LD_INT 204
7107: IFFALSE 7482
7109: GO 7111
7111: DISABLE
7112: LD_INT 0
7114: PPUSH
7115: PPUSH
7116: PPUSH
7117: PPUSH
// begin enable ;
7118: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7119: LD_INT 35
7121: PPUSH
7122: LD_INT 1190
7124: PPUSH
7125: CALL_OW 12
7129: PPUSH
7130: CALL_OW 67
// tmp := [ ] ;
7134: LD_ADDR_VAR 0 2
7138: PUSH
7139: EMPTY
7140: ST_TO_ADDR
// uc_side := 8 ;
7141: LD_ADDR_OWVAR 20
7145: PUSH
7146: LD_INT 8
7148: ST_TO_ADDR
// uc_nation := 2 ;
7149: LD_ADDR_OWVAR 21
7153: PUSH
7154: LD_INT 2
7156: ST_TO_ADDR
// InitHc ;
7157: CALL_OW 19
// for i = 1 to 3 do
7161: LD_ADDR_VAR 0 1
7165: PUSH
7166: DOUBLE
7167: LD_INT 1
7169: DEC
7170: ST_TO_ADDR
7171: LD_INT 3
7173: PUSH
7174: FOR_TO
7175: IFFALSE 7302
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7177: LD_INT 13
7179: PUSH
7180: LD_INT 14
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: PUSH
7187: LD_INT 1
7189: PPUSH
7190: LD_INT 2
7192: PPUSH
7193: CALL_OW 12
7197: ARRAY
7198: PPUSH
7199: LD_INT 3
7201: PPUSH
7202: LD_INT 5
7204: PPUSH
7205: LD_INT 27
7207: PUSH
7208: LD_INT 28
7210: PUSH
7211: EMPTY
7212: LIST
7213: LIST
7214: PUSH
7215: LD_INT 1
7217: PPUSH
7218: LD_INT 2
7220: PPUSH
7221: CALL_OW 12
7225: ARRAY
7226: PPUSH
7227: LD_INT 100
7229: PPUSH
7230: CALL 50751 0 5
// un := CreateVehicle ;
7234: LD_ADDR_VAR 0 3
7238: PUSH
7239: CALL_OW 45
7243: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7244: LD_VAR 0 3
7248: PPUSH
7249: LD_INT 4
7251: PPUSH
7252: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7256: LD_VAR 0 3
7260: PPUSH
7261: LD_INT 15
7263: PPUSH
7264: LD_INT 0
7266: PPUSH
7267: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7271: LD_ADDR_VAR 0 2
7275: PUSH
7276: LD_VAR 0 2
7280: PPUSH
7281: LD_VAR 0 2
7285: PUSH
7286: LD_INT 1
7288: PLUS
7289: PPUSH
7290: LD_VAR 0 3
7294: PPUSH
7295: CALL_OW 1
7299: ST_TO_ADDR
// end ;
7300: GO 7174
7302: POP
7303: POP
// for i = 1 to 4 do
7304: LD_ADDR_VAR 0 1
7308: PUSH
7309: DOUBLE
7310: LD_INT 1
7312: DEC
7313: ST_TO_ADDR
7314: LD_INT 4
7316: PUSH
7317: FOR_TO
7318: IFFALSE 7397
// begin PrepareHuman ( false , rand ( 1 , 4 ) , 6 ) ;
7320: LD_INT 0
7322: PPUSH
7323: LD_INT 1
7325: PPUSH
7326: LD_INT 4
7328: PPUSH
7329: CALL_OW 12
7333: PPUSH
7334: LD_INT 6
7336: PPUSH
7337: CALL_OW 380
// un := CreateHuman ;
7341: LD_ADDR_VAR 0 3
7345: PUSH
7346: CALL_OW 44
7350: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7351: LD_VAR 0 3
7355: PPUSH
7356: LD_INT 15
7358: PPUSH
7359: LD_INT 0
7361: PPUSH
7362: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7366: LD_ADDR_VAR 0 2
7370: PUSH
7371: LD_VAR 0 2
7375: PPUSH
7376: LD_VAR 0 2
7380: PUSH
7381: LD_INT 1
7383: PLUS
7384: PPUSH
7385: LD_VAR 0 3
7389: PPUSH
7390: CALL_OW 1
7394: ST_TO_ADDR
// end ;
7395: GO 7317
7397: POP
7398: POP
// repeat ComAgressiveMove ( tmp , 210 , 177 ) ;
7399: LD_VAR 0 2
7403: PPUSH
7404: LD_INT 210
7406: PPUSH
7407: LD_INT 177
7409: PPUSH
7410: CALL_OW 114
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
7414: LD_ADDR_VAR 0 4
7418: PUSH
7419: LD_INT 10
7421: PPUSH
7422: LD_INT 22
7424: PUSH
7425: LD_INT 8
7427: PUSH
7428: EMPTY
7429: LIST
7430: LIST
7431: PPUSH
7432: CALL_OW 70
7436: ST_TO_ADDR
// if x then
7437: LD_VAR 0 4
7441: IFFALSE 7469
// for i in x do
7443: LD_ADDR_VAR 0 1
7447: PUSH
7448: LD_VAR 0 4
7452: PUSH
7453: FOR_IN
7454: IFFALSE 7467
// RemoveUnit ( i ) ;
7456: LD_VAR 0 1
7460: PPUSH
7461: CALL_OW 64
7465: GO 7453
7467: POP
7468: POP
// wait ( 0 0$3 ) ;
7469: LD_INT 105
7471: PPUSH
7472: CALL_OW 67
// until tmp ;
7476: LD_VAR 0 2
7480: IFFALSE 7399
// end ;
7482: PPOPN 4
7484: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
7485: LD_INT 22
7487: PUSH
7488: LD_INT 2
7490: PUSH
7491: EMPTY
7492: LIST
7493: LIST
7494: PUSH
7495: LD_INT 34
7497: PUSH
7498: LD_INT 31
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: PUSH
7505: LD_INT 3
7507: PUSH
7508: LD_INT 24
7510: PUSH
7511: LD_INT 1000
7513: PUSH
7514: EMPTY
7515: LIST
7516: LIST
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: LIST
7526: PPUSH
7527: CALL_OW 69
7531: IFFALSE 7575
7533: GO 7535
7535: DISABLE
// begin ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
7536: LD_INT 22
7538: PUSH
7539: LD_INT 2
7541: PUSH
7542: EMPTY
7543: LIST
7544: LIST
7545: PUSH
7546: LD_INT 34
7548: PUSH
7549: LD_INT 31
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: PUSH
7556: EMPTY
7557: LIST
7558: LIST
7559: PPUSH
7560: CALL_OW 69
7564: PPUSH
7565: LD_INT 106
7567: PPUSH
7568: LD_INT 14
7570: PPUSH
7571: CALL_OW 111
// end ; end_of_file
7575: END
// export function Action ; var tmp , p , radar , sols , i ; begin
7576: LD_INT 0
7578: PPUSH
7579: PPUSH
7580: PPUSH
7581: PPUSH
7582: PPUSH
7583: PPUSH
// InGameOn ;
7584: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
7588: LD_EXP 21
7592: PPUSH
7593: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
7597: LD_INT 2
7599: PPUSH
7600: LD_INT 1
7602: PPUSH
7603: LD_INT 1
7605: PPUSH
7606: LD_INT 1
7608: PPUSH
7609: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
7613: LD_ADDR_VAR 0 2
7617: PUSH
7618: LD_INT 22
7620: PUSH
7621: LD_INT 1
7623: PUSH
7624: EMPTY
7625: LIST
7626: LIST
7627: PUSH
7628: LD_INT 25
7630: PUSH
7631: LD_INT 1
7633: PUSH
7634: EMPTY
7635: LIST
7636: LIST
7637: PUSH
7638: EMPTY
7639: LIST
7640: LIST
7641: PPUSH
7642: CALL_OW 69
7646: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
7647: LD_ADDR_VAR 0 4
7651: PUSH
7652: LD_INT 22
7654: PUSH
7655: LD_INT 1
7657: PUSH
7658: EMPTY
7659: LIST
7660: LIST
7661: PUSH
7662: LD_INT 34
7664: PUSH
7665: LD_INT 11
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PUSH
7672: EMPTY
7673: LIST
7674: LIST
7675: PPUSH
7676: CALL_OW 69
7680: PUSH
7681: LD_INT 1
7683: ARRAY
7684: ST_TO_ADDR
// for i = 1 to tmp do
7685: LD_ADDR_VAR 0 6
7689: PUSH
7690: DOUBLE
7691: LD_INT 1
7693: DEC
7694: ST_TO_ADDR
7695: LD_VAR 0 2
7699: PUSH
7700: FOR_TO
7701: IFFALSE 7748
// begin if i = 5 then
7703: LD_VAR 0 6
7707: PUSH
7708: LD_INT 5
7710: EQUAL
7711: IFFALSE 7715
// break ;
7713: GO 7748
// sols := Replace ( sols , i , tmp [ i ] ) ;
7715: LD_ADDR_VAR 0 5
7719: PUSH
7720: LD_VAR 0 5
7724: PPUSH
7725: LD_VAR 0 6
7729: PPUSH
7730: LD_VAR 0 2
7734: PUSH
7735: LD_VAR 0 6
7739: ARRAY
7740: PPUSH
7741: CALL_OW 1
7745: ST_TO_ADDR
// end ;
7746: GO 7700
7748: POP
7749: POP
// tmp := ar_force_tmp ;
7750: LD_ADDR_VAR 0 2
7754: PUSH
7755: LD_EXP 40
7759: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
7760: LD_VAR 0 2
7764: PUSH
7765: LD_INT 1
7767: ARRAY
7768: PPUSH
7769: LD_INT 108
7771: PPUSH
7772: LD_INT 139
7774: PPUSH
7775: LD_INT 0
7777: PPUSH
7778: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
7782: LD_VAR 0 2
7786: PUSH
7787: LD_INT 1
7789: ARRAY
7790: PPUSH
7791: LD_EXP 21
7795: PPUSH
7796: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
7800: LD_VAR 0 2
7804: PUSH
7805: LD_INT 2
7807: ARRAY
7808: PPUSH
7809: LD_INT 114
7811: PPUSH
7812: LD_INT 132
7814: PPUSH
7815: LD_INT 0
7817: PPUSH
7818: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
7822: LD_VAR 0 2
7826: PUSH
7827: LD_INT 3
7829: ARRAY
7830: PPUSH
7831: LD_INT 115
7833: PPUSH
7834: LD_INT 132
7836: PPUSH
7837: LD_INT 0
7839: PPUSH
7840: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
7844: LD_VAR 0 2
7848: PUSH
7849: LD_INT 2
7851: ARRAY
7852: PUSH
7853: LD_VAR 0 2
7857: PUSH
7858: LD_INT 3
7860: ARRAY
7861: PUSH
7862: EMPTY
7863: LIST
7864: LIST
7865: PPUSH
7866: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
7870: LD_VAR 0 4
7874: PPUSH
7875: LD_INT 83
7877: PPUSH
7878: LD_INT 123
7880: PPUSH
7881: CALL_OW 111
// Wait ( 0 0$01 ) ;
7885: LD_INT 35
7887: PPUSH
7888: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
7892: LD_INT 90
7894: PPUSH
7895: LD_INT 144
7897: PPUSH
7898: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
7902: LD_VAR 0 5
7906: PPUSH
7907: LD_INT 88
7909: PPUSH
7910: LD_INT 129
7912: PPUSH
7913: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
7917: LD_ADDR_VAR 0 3
7921: PUSH
7922: LD_INT 92
7924: PUSH
7925: LD_INT 131
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PUSH
7932: LD_INT 88
7934: PUSH
7935: LD_INT 127
7937: PUSH
7938: EMPTY
7939: LIST
7940: LIST
7941: PUSH
7942: LD_INT 91
7944: PUSH
7945: LD_INT 132
7947: PUSH
7948: EMPTY
7949: LIST
7950: LIST
7951: PUSH
7952: LD_INT 92
7954: PUSH
7955: LD_INT 134
7957: PUSH
7958: EMPTY
7959: LIST
7960: LIST
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: LIST
7966: LIST
7967: ST_TO_ADDR
// for i = 1 to sols do
7968: LD_ADDR_VAR 0 6
7972: PUSH
7973: DOUBLE
7974: LD_INT 1
7976: DEC
7977: ST_TO_ADDR
7978: LD_VAR 0 5
7982: PUSH
7983: FOR_TO
7984: IFFALSE 8057
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
7986: LD_VAR 0 5
7990: PUSH
7991: LD_VAR 0 6
7995: ARRAY
7996: PPUSH
7997: LD_VAR 0 3
8001: PUSH
8002: LD_VAR 0 6
8006: ARRAY
8007: PUSH
8008: LD_INT 1
8010: ARRAY
8011: PPUSH
8012: LD_VAR 0 3
8016: PUSH
8017: LD_VAR 0 6
8021: ARRAY
8022: PUSH
8023: LD_INT 2
8025: ARRAY
8026: PPUSH
8027: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8031: LD_VAR 0 5
8035: PUSH
8036: LD_VAR 0 6
8040: ARRAY
8041: PPUSH
8042: CALL_OW 197
// AddComHold ( sols ) ;
8046: LD_VAR 0 5
8050: PPUSH
8051: CALL_OW 200
// end ;
8055: GO 7983
8057: POP
8058: POP
// repeat wait ( 0 0$1 ) ;
8059: LD_INT 35
8061: PPUSH
8062: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8066: LD_VAR 0 5
8070: PUSH
8071: LD_INT 1
8073: ARRAY
8074: PPUSH
8075: LD_INT 92
8077: PPUSH
8078: LD_INT 131
8080: PPUSH
8081: CALL_OW 297
8085: PUSH
8086: LD_INT 4
8088: LESS
8089: IFFALSE 8059
// CenterOnXY ( 96 , 139 ) ;
8091: LD_INT 96
8093: PPUSH
8094: LD_INT 139
8096: PPUSH
8097: CALL_OW 84
// wait ( 0 0$3 ) ;
8101: LD_INT 105
8103: PPUSH
8104: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
8108: LD_INT 111
8110: PPUSH
8111: LD_INT 135
8113: PPUSH
8114: LD_INT 1
8116: PPUSH
8117: LD_INT 25
8119: NEG
8120: PPUSH
8121: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
8125: LD_VAR 0 2
8129: PUSH
8130: LD_INT 2
8132: ARRAY
8133: PPUSH
8134: LD_VAR 0 2
8138: PUSH
8139: LD_INT 1
8141: ARRAY
8142: PPUSH
8143: CALL_OW 250
8147: PUSH
8148: LD_INT 3
8150: PLUS
8151: PPUSH
8152: LD_VAR 0 2
8156: PUSH
8157: LD_INT 1
8159: ARRAY
8160: PPUSH
8161: CALL_OW 251
8165: PPUSH
8166: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
8170: LD_VAR 0 2
8174: PUSH
8175: LD_INT 3
8177: ARRAY
8178: PPUSH
8179: LD_INT 7
8181: PPUSH
8182: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
8186: LD_VAR 0 2
8190: PUSH
8191: LD_INT 2
8193: ARRAY
8194: PPUSH
8195: LD_VAR 0 2
8199: PUSH
8200: LD_INT 1
8202: ARRAY
8203: PPUSH
8204: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
8208: LD_INT 35
8210: PPUSH
8211: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
8215: LD_VAR 0 2
8219: PUSH
8220: LD_INT 1
8222: ARRAY
8223: PPUSH
8224: LD_VAR 0 2
8228: PUSH
8229: LD_INT 2
8231: ARRAY
8232: PPUSH
8233: CALL_OW 296
8237: PUSH
8238: LD_INT 5
8240: LESS
8241: IFFALSE 8208
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
8243: LD_VAR 0 2
8247: PUSH
8248: LD_INT 1
8250: ARRAY
8251: PPUSH
8252: LD_VAR 0 2
8256: PUSH
8257: LD_INT 2
8259: ARRAY
8260: PPUSH
8261: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
8265: LD_VAR 0 2
8269: PUSH
8270: LD_INT 1
8272: ARRAY
8273: PPUSH
8274: LD_STRING D1a-Merc1-1
8276: PPUSH
8277: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
8281: LD_VAR 0 2
8285: PUSH
8286: LD_INT 2
8288: ARRAY
8289: PPUSH
8290: LD_STRING D1a-FMerc2-1
8292: PPUSH
8293: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
8297: LD_VAR 0 2
8301: PUSH
8302: LD_INT 2
8304: ARRAY
8305: PPUSH
8306: LD_VAR 0 2
8310: PUSH
8311: LD_INT 1
8313: ARRAY
8314: PPUSH
8315: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
8319: LD_VAR 0 2
8323: PUSH
8324: LD_INT 1
8326: ARRAY
8327: PPUSH
8328: LD_INT 500
8330: PPUSH
8331: CALL_OW 234
// wait ( 0 0$2 ) ;
8335: LD_INT 70
8337: PPUSH
8338: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
8342: LD_VAR 0 2
8346: PUSH
8347: LD_INT 1
8349: ARRAY
8350: PPUSH
8351: LD_INT 2
8353: PPUSH
8354: CALL_OW 234
// wait ( 0 0$0.3 ) ;
8358: LD_INT 10
8360: PPUSH
8361: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
8365: LD_VAR 0 2
8369: PUSH
8370: LD_INT 1
8372: ARRAY
8373: PPUSH
8374: LD_STRING D1a-Merc1-2
8376: PPUSH
8377: CALL_OW 91
// wait ( 0 0$0.2 ) ;
8381: LD_INT 7
8383: PPUSH
8384: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
8388: LD_VAR 0 2
8392: PUSH
8393: LD_INT 1
8395: ARRAY
8396: PPUSH
8397: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
8401: LD_VAR 0 2
8405: PUSH
8406: LD_INT 2
8408: ARRAY
8409: PPUSH
8410: LD_INT 10
8412: PPUSH
8413: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
8417: LD_VAR 0 2
8421: PUSH
8422: LD_INT 2
8424: ARRAY
8425: PPUSH
8426: LD_STRING D1a-FMerc2-2
8428: PPUSH
8429: CALL_OW 88
// wait ( 0 0$1 ) ;
8433: LD_INT 35
8435: PPUSH
8436: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
8440: LD_INT 7
8442: PPUSH
8443: CALL_OW 85
// wait ( 0 0$2 ) ;
8447: LD_INT 70
8449: PPUSH
8450: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
8454: LD_EXP 44
8458: PPUSH
8459: LD_STRING D1a-Saliba-1
8461: PPUSH
8462: CALL_OW 91
// KillUnit ( Saliba ) ;
8466: LD_EXP 44
8470: PPUSH
8471: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
8475: LD_VAR 0 2
8479: PUSH
8480: LD_INT 3
8482: ARRAY
8483: PPUSH
8484: CALL_OW 122
// CenterOnUnits ( JMM ) ;
8488: LD_EXP 21
8492: PPUSH
8493: CALL_OW 85
// wait ( 0 0$1 ) ;
8497: LD_INT 35
8499: PPUSH
8500: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
8504: LD_VAR 0 5
8508: PPUSH
8509: LD_INT 88
8511: PPUSH
8512: LD_INT 141
8514: PPUSH
8515: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
8519: LD_VAR 0 5
8523: PPUSH
8524: LD_INT 70
8526: PPUSH
8527: CALL_OW 202
// wait ( 0 0$2 ) ;
8531: LD_INT 70
8533: PPUSH
8534: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
8538: LD_INT 2
8540: PPUSH
8541: LD_INT 1
8543: PPUSH
8544: LD_INT 2
8546: PPUSH
8547: LD_INT 1
8549: PPUSH
8550: CALL_OW 80
// InGameOff ;
8554: CALL_OW 9
// ComWalk ( sols ) ;
8558: LD_VAR 0 5
8562: PPUSH
8563: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
8567: LD_STRING M1
8569: PPUSH
8570: CALL_OW 337
// game_speed := 4 ;
8574: LD_ADDR_OWVAR 65
8578: PUSH
8579: LD_INT 4
8581: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
8582: LD_INT 111
8584: PPUSH
8585: LD_INT 135
8587: PPUSH
8588: LD_INT 1
8590: PPUSH
8591: CALL_OW 331
// SaveForQuickRestart ;
8595: CALL_OW 22
// ar_run := true ;
8599: LD_ADDR_EXP 5
8603: PUSH
8604: LD_INT 1
8606: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8607: LD_INT 35
8609: PPUSH
8610: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
8614: LD_INT 22
8616: PUSH
8617: LD_INT 1
8619: PUSH
8620: EMPTY
8621: LIST
8622: LIST
8623: PUSH
8624: LD_INT 91
8626: PUSH
8627: LD_INT 7
8629: PUSH
8630: LD_INT 10
8632: PUSH
8633: EMPTY
8634: LIST
8635: LIST
8636: LIST
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: PPUSH
8642: CALL_OW 69
8646: PUSH
8647: LD_INT 7
8649: PPUSH
8650: CALL_OW 256
8654: PUSH
8655: LD_INT 999
8657: LESS
8658: OR
8659: IFFALSE 8607
// if GetSide ( ar_dep_s ) = 2 then
8661: LD_INT 7
8663: PPUSH
8664: CALL_OW 255
8668: PUSH
8669: LD_INT 2
8671: EQUAL
8672: IFFALSE 8684
// SetSide ( ar_dep_s , 1 ) ;
8674: LD_INT 7
8676: PPUSH
8677: LD_INT 1
8679: PPUSH
8680: CALL_OW 235
// end ;
8684: LD_VAR 0 1
8688: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
8689: LD_EXP 5
8693: IFFALSE 9053
8695: GO 8697
8697: DISABLE
8698: LD_INT 0
8700: PPUSH
8701: PPUSH
8702: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
8703: LD_ADDR_VAR 0 2
8707: PUSH
8708: LD_EXP 40
8712: PUSH
8713: LD_EXP 36
8717: PPUSH
8718: LD_INT 2
8720: PUSH
8721: LD_INT 21
8723: PUSH
8724: LD_INT 2
8726: PUSH
8727: EMPTY
8728: LIST
8729: LIST
8730: PUSH
8731: LD_INT 21
8733: PUSH
8734: LD_INT 1
8736: PUSH
8737: EMPTY
8738: LIST
8739: LIST
8740: PUSH
8741: EMPTY
8742: LIST
8743: LIST
8744: LIST
8745: PPUSH
8746: CALL_OW 72
8750: ADD
8751: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
8752: LD_VAR 0 2
8756: PPUSH
8757: LD_INT 5
8759: PPUSH
8760: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
8764: LD_INT 5
8766: PPUSH
8767: LD_INT 1
8769: PPUSH
8770: CALL_OW 343
// k := 1 ;
8774: LD_ADDR_VAR 0 3
8778: PUSH
8779: LD_INT 1
8781: ST_TO_ADDR
// for i in tmp do
8782: LD_ADDR_VAR 0 1
8786: PUSH
8787: LD_VAR 0 2
8791: PUSH
8792: FOR_IN
8793: IFFALSE 8878
// begin if IsInUnit ( i ) then
8795: LD_VAR 0 1
8799: PPUSH
8800: CALL_OW 310
8804: IFFALSE 8815
// ComExitBuilding ( i ) ;
8806: LD_VAR 0 1
8810: PPUSH
8811: CALL_OW 122
// if GetClass ( i ) = 3 then
8815: LD_VAR 0 1
8819: PPUSH
8820: CALL_OW 257
8824: PUSH
8825: LD_INT 3
8827: EQUAL
8828: IFFALSE 8864
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
8830: LD_VAR 0 1
8834: PPUSH
8835: LD_EXP 41
8839: PUSH
8840: LD_VAR 0 3
8844: ARRAY
8845: PPUSH
8846: CALL_OW 180
// k := k + 1 ;
8850: LD_ADDR_VAR 0 3
8854: PUSH
8855: LD_VAR 0 3
8859: PUSH
8860: LD_INT 1
8862: PLUS
8863: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
8864: LD_VAR 0 1
8868: PPUSH
8869: LD_INT 10
8871: PPUSH
8872: CALL_OW 173
// end ;
8876: GO 8792
8878: POP
8879: POP
// ar_patrol := true ;
8880: LD_ADDR_EXP 7
8884: PUSH
8885: LD_INT 1
8887: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
8888: LD_INT 10
8890: PPUSH
8891: CALL_OW 67
// for i in tmp do
8895: LD_ADDR_VAR 0 1
8899: PUSH
8900: LD_VAR 0 2
8904: PUSH
8905: FOR_IN
8906: IFFALSE 8934
// if not HasTask ( i ) then
8908: LD_VAR 0 1
8912: PPUSH
8913: CALL_OW 314
8917: NOT
8918: IFFALSE 8932
// ComMoveToArea ( i , escape_area ) ;
8920: LD_VAR 0 1
8924: PPUSH
8925: LD_INT 10
8927: PPUSH
8928: CALL_OW 113
8932: GO 8905
8934: POP
8935: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
8936: LD_ADDR_VAR 0 3
8940: PUSH
8941: LD_VAR 0 2
8945: PPUSH
8946: LD_INT 95
8948: PUSH
8949: LD_INT 10
8951: PUSH
8952: EMPTY
8953: LIST
8954: LIST
8955: PPUSH
8956: CALL_OW 72
8960: ST_TO_ADDR
// if k then
8961: LD_VAR 0 3
8965: IFFALSE 9034
// for i in k do
8967: LD_ADDR_VAR 0 1
8971: PUSH
8972: LD_VAR 0 3
8976: PUSH
8977: FOR_IN
8978: IFFALSE 9032
// begin if IsInUnit ( i ) then
8980: LD_VAR 0 1
8984: PPUSH
8985: CALL_OW 310
8989: IFFALSE 9005
// RemoveUnit ( IsInUnit ( i ) ) ;
8991: LD_VAR 0 1
8995: PPUSH
8996: CALL_OW 310
9000: PPUSH
9001: CALL_OW 64
// RemoveUnit ( i ) ;
9005: LD_VAR 0 1
9009: PPUSH
9010: CALL_OW 64
// tmp := tmp diff i ;
9014: LD_ADDR_VAR 0 2
9018: PUSH
9019: LD_VAR 0 2
9023: PUSH
9024: LD_VAR 0 1
9028: DIFF
9029: ST_TO_ADDR
// end ;
9030: GO 8977
9032: POP
9033: POP
// until tmp = [ ] ;
9034: LD_VAR 0 2
9038: PUSH
9039: EMPTY
9040: EQUAL
9041: IFFALSE 8888
// ChangeSideFog ( 5 , 5 ) ;
9043: LD_INT 5
9045: PPUSH
9046: LD_INT 5
9048: PPUSH
9049: CALL_OW 343
// end ;
9053: PPOPN 3
9055: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9056: LD_EXP 7
9060: IFFALSE 9350
9062: GO 9064
9064: DISABLE
9065: LD_INT 0
9067: PPUSH
9068: PPUSH
9069: PPUSH
// begin uc_side := 2 ;
9070: LD_ADDR_OWVAR 20
9074: PUSH
9075: LD_INT 2
9077: ST_TO_ADDR
// uc_nation := 2 ;
9078: LD_ADDR_OWVAR 21
9082: PUSH
9083: LD_INT 2
9085: ST_TO_ADDR
// InitHc ;
9086: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
9090: LD_INT 1
9092: PPUSH
9093: LD_INT 1
9095: PPUSH
9096: LD_INT 6
9098: PPUSH
9099: CALL_OW 380
// un := CreateHuman ;
9103: LD_ADDR_VAR 0 2
9107: PUSH
9108: CALL_OW 44
9112: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
9113: LD_INT 14
9115: PPUSH
9116: LD_INT 1
9118: PPUSH
9119: LD_INT 1
9121: PPUSH
9122: LD_INT 27
9124: PPUSH
9125: LD_INT 98
9127: PPUSH
9128: CALL 50751 0 5
// veh := CreateVehicle ;
9132: LD_ADDR_VAR 0 3
9136: PUSH
9137: CALL_OW 45
9141: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
9142: LD_VAR 0 3
9146: PPUSH
9147: LD_INT 4
9149: PPUSH
9150: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
9154: LD_VAR 0 3
9158: PPUSH
9159: LD_INT 179
9161: PPUSH
9162: LD_INT 135
9164: PPUSH
9165: LD_INT 0
9167: PPUSH
9168: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
9172: LD_VAR 0 2
9176: PPUSH
9177: LD_VAR 0 3
9181: PPUSH
9182: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
9186: LD_VAR 0 2
9190: PPUSH
9191: LD_INT 126
9193: PPUSH
9194: LD_INT 133
9196: PPUSH
9197: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
9201: LD_INT 10
9203: PPUSH
9204: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
9208: LD_INT 1
9210: PPUSH
9211: LD_VAR 0 3
9215: PPUSH
9216: CALL_OW 292
9220: PUSH
9221: LD_VAR 0 3
9225: PPUSH
9226: LD_INT 7
9228: PPUSH
9229: CALL_OW 296
9233: PUSH
9234: LD_INT 9
9236: LESS
9237: OR
9238: IFFALSE 9201
// ComHold ( veh ) ;
9240: LD_VAR 0 3
9244: PPUSH
9245: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
9249: LD_VAR 0 2
9253: PPUSH
9254: LD_STRING D2aa-Ar1-1
9256: PPUSH
9257: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
9261: LD_VAR 0 2
9265: PPUSH
9266: LD_INT 177
9268: PPUSH
9269: LD_INT 96
9271: PPUSH
9272: CALL_OW 111
// AddComExitVehicle ( un ) ;
9276: LD_VAR 0 2
9280: PPUSH
9281: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
9285: LD_INT 35
9287: PPUSH
9288: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
9292: LD_VAR 0 2
9296: PPUSH
9297: LD_INT 204
9299: PPUSH
9300: CALL_OW 296
9304: PUSH
9305: LD_INT 15
9307: LESS
9308: IFFALSE 9285
// mc_bases := Add ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
9310: LD_ADDR_EXP 50
9314: PUSH
9315: LD_EXP 50
9319: PPUSH
9320: LD_INT 3
9322: PUSH
9323: LD_EXP 50
9327: PUSH
9328: LD_INT 3
9330: ARRAY
9331: PUSH
9332: LD_INT 1
9334: PLUS
9335: PUSH
9336: EMPTY
9337: LIST
9338: LIST
9339: PPUSH
9340: LD_VAR 0 2
9344: PPUSH
9345: CALL 51308 0 3
9349: ST_TO_ADDR
// end ;
9350: PPOPN 3
9352: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
9353: LD_INT 7
9355: PPUSH
9356: CALL_OW 255
9360: PUSH
9361: LD_INT 1
9363: EQUAL
9364: PUSH
9365: LD_INT 7
9367: PPUSH
9368: CALL_OW 301
9372: OR
9373: IFFALSE 11797
9375: GO 9377
9377: DISABLE
9378: LD_INT 0
9380: PPUSH
9381: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
9382: LD_ADDR_VAR 0 1
9386: PUSH
9387: LD_EXP 36
9391: PPUSH
9392: LD_INT 21
9394: PUSH
9395: LD_INT 3
9397: PUSH
9398: EMPTY
9399: LIST
9400: LIST
9401: PPUSH
9402: CALL_OW 72
9406: PUSH
9407: FOR_IN
9408: IFFALSE 9424
// SetSide ( i , 1 ) ;
9410: LD_VAR 0 1
9414: PPUSH
9415: LD_INT 1
9417: PPUSH
9418: CALL_OW 235
9422: GO 9407
9424: POP
9425: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
9426: LD_ADDR_VAR 0 2
9430: PUSH
9431: LD_INT 46
9433: PUSH
9434: LD_INT 41
9436: PUSH
9437: EMPTY
9438: LIST
9439: LIST
9440: PUSH
9441: LD_INT 50
9443: PUSH
9444: LD_INT 25
9446: PUSH
9447: EMPTY
9448: LIST
9449: LIST
9450: PUSH
9451: LD_INT 57
9453: PUSH
9454: LD_INT 75
9456: PUSH
9457: EMPTY
9458: LIST
9459: LIST
9460: PUSH
9461: LD_INT 75
9463: PUSH
9464: LD_INT 89
9466: PUSH
9467: EMPTY
9468: LIST
9469: LIST
9470: PUSH
9471: LD_INT 51
9473: PUSH
9474: LD_INT 45
9476: PUSH
9477: EMPTY
9478: LIST
9479: LIST
9480: PUSH
9481: LD_INT 95
9483: PUSH
9484: LD_INT 95
9486: PUSH
9487: EMPTY
9488: LIST
9489: LIST
9490: PUSH
9491: LD_INT 84
9493: PUSH
9494: LD_INT 77
9496: PUSH
9497: EMPTY
9498: LIST
9499: LIST
9500: PUSH
9501: LD_INT 101
9503: PUSH
9504: LD_INT 76
9506: PUSH
9507: EMPTY
9508: LIST
9509: LIST
9510: PUSH
9511: LD_INT 118
9513: PUSH
9514: LD_INT 81
9516: PUSH
9517: EMPTY
9518: LIST
9519: LIST
9520: PUSH
9521: LD_INT 139
9523: PUSH
9524: LD_INT 97
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: PUSH
9531: LD_INT 129
9533: PUSH
9534: LD_INT 114
9536: PUSH
9537: EMPTY
9538: LIST
9539: LIST
9540: PUSH
9541: LD_INT 154
9543: PUSH
9544: LD_INT 111
9546: PUSH
9547: EMPTY
9548: LIST
9549: LIST
9550: PUSH
9551: EMPTY
9552: LIST
9553: LIST
9554: LIST
9555: LIST
9556: LIST
9557: LIST
9558: LIST
9559: LIST
9560: LIST
9561: LIST
9562: LIST
9563: LIST
9564: ST_TO_ADDR
// base_captured := true ;
9565: LD_ADDR_EXP 6
9569: PUSH
9570: LD_INT 1
9572: ST_TO_ADDR
// DialogueOn ;
9573: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
9577: LD_EXP 21
9581: PPUSH
9582: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
9586: LD_EXP 21
9590: PPUSH
9591: LD_STRING D2-JMM-1
9593: PPUSH
9594: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
9598: LD_EXP 30
9602: PPUSH
9603: LD_STRING D2-Pow-1
9605: PPUSH
9606: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
9610: LD_EXP 21
9614: PPUSH
9615: LD_STRING D2-JMM-2
9617: PPUSH
9618: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
9622: LD_EXP 30
9626: PPUSH
9627: LD_STRING D2-Pow-2
9629: PPUSH
9630: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
9634: LD_EXP 21
9638: PPUSH
9639: LD_STRING D2-JMM-3
9641: PPUSH
9642: CALL_OW 88
// DialogueOff ;
9646: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
9650: LD_STRING M2
9652: PPUSH
9653: CALL_OW 337
// Wait ( 0 0$2 ) ;
9657: LD_INT 70
9659: PPUSH
9660: CALL_OW 67
// if IsOk ( Gary ) then
9664: LD_EXP 32
9668: PPUSH
9669: CALL_OW 302
9673: IFFALSE 9687
// Say ( Gary , D2a-Gary-1 ) ;
9675: LD_EXP 32
9679: PPUSH
9680: LD_STRING D2a-Gary-1
9682: PPUSH
9683: CALL_OW 88
// if IsOk ( Bobby ) then
9687: LD_EXP 24
9691: PPUSH
9692: CALL_OW 302
9696: IFFALSE 9710
// Say ( Bobby , D2a-Bobby-1 ) ;
9698: LD_EXP 24
9702: PPUSH
9703: LD_STRING D2a-Bobby-1
9705: PPUSH
9706: CALL_OW 88
// if IsOk ( Cyrus ) then
9710: LD_EXP 25
9714: PPUSH
9715: CALL_OW 302
9719: IFFALSE 9733
// Say ( Cyrus , D2a-Cyrus-1 ) ;
9721: LD_EXP 25
9725: PPUSH
9726: LD_STRING D2a-Cyrus-1
9728: PPUSH
9729: CALL_OW 88
// if IsOk ( Lisa ) then
9733: LD_EXP 22
9737: PPUSH
9738: CALL_OW 302
9742: IFFALSE 9756
// Say ( Lisa , D2a-Lisa-1 ) ;
9744: LD_EXP 22
9748: PPUSH
9749: LD_STRING D2a-Lisa-1
9751: PPUSH
9752: CALL_OW 88
// if IsOk ( Frank ) then
9756: LD_EXP 33
9760: PPUSH
9761: CALL_OW 302
9765: IFFALSE 9779
// Say ( Frank , D2a-Frank-1 ) ;
9767: LD_EXP 33
9771: PPUSH
9772: LD_STRING D2a-Frank-1
9774: PPUSH
9775: CALL_OW 88
// if IsOk ( Cornel ) then
9779: LD_EXP 31
9783: PPUSH
9784: CALL_OW 302
9788: IFFALSE 9802
// Say ( Cornel , D2a-Corn-1 ) ;
9790: LD_EXP 31
9794: PPUSH
9795: LD_STRING D2a-Corn-1
9797: PPUSH
9798: CALL_OW 88
// if IsOk ( Donaldson ) then
9802: LD_EXP 23
9806: PPUSH
9807: CALL_OW 302
9811: IFFALSE 9825
// Say ( Donaldson , D2a-Don-1 ) ;
9813: LD_EXP 23
9817: PPUSH
9818: LD_STRING D2a-Don-1
9820: PPUSH
9821: CALL_OW 88
// if IsOk ( Brown ) then
9825: LD_EXP 27
9829: PPUSH
9830: CALL_OW 302
9834: IFFALSE 9848
// Say ( Brown , D2a-Brown-1 ) ;
9836: LD_EXP 27
9840: PPUSH
9841: LD_STRING D2a-Brown-1
9843: PPUSH
9844: CALL_OW 88
// Wait ( 0 0$30 ) ;
9848: LD_INT 1050
9850: PPUSH
9851: CALL_OW 67
// if IsOk ( Frank ) then
9855: LD_EXP 33
9859: PPUSH
9860: CALL_OW 302
9864: IFFALSE 10130
// begin DialogueOn ;
9866: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
9870: LD_EXP 21
9874: PUSH
9875: LD_EXP 33
9879: PUSH
9880: EMPTY
9881: LIST
9882: LIST
9883: PPUSH
9884: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
9888: LD_EXP 33
9892: PPUSH
9893: LD_STRING D3F-Frank-1
9895: PPUSH
9896: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
9900: LD_EXP 21
9904: PPUSH
9905: LD_STRING D3F-JMM-1
9907: PPUSH
9908: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
9912: LD_EXP 33
9916: PPUSH
9917: LD_STRING D3F-Frank-2
9919: PPUSH
9920: CALL_OW 88
// case Query ( QFrank ) of 1 :
9924: LD_STRING QFrank
9926: PPUSH
9927: CALL_OW 97
9931: PUSH
9932: LD_INT 1
9934: DOUBLE
9935: EQUAL
9936: IFTRUE 9940
9938: GO 9963
9940: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
9941: LD_EXP 21
9945: PPUSH
9946: LD_STRING D3Fa-JMM-1
9948: PPUSH
9949: CALL_OW 88
// us_scout := 1 ;
9953: LD_ADDR_EXP 8
9957: PUSH
9958: LD_INT 1
9960: ST_TO_ADDR
// end ; 2 :
9961: GO 10126
9963: LD_INT 2
9965: DOUBLE
9966: EQUAL
9967: IFTRUE 9971
9969: GO 10093
9971: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
9972: LD_EXP 21
9976: PPUSH
9977: LD_STRING D3Fb-JMM-1
9979: PPUSH
9980: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
9984: LD_EXP 33
9988: PPUSH
9989: LD_STRING D3Fb-Frank-1
9991: PPUSH
9992: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
9996: LD_STRING QFrank2
9998: PPUSH
9999: CALL_OW 97
10003: PUSH
10004: LD_INT 1
10006: DOUBLE
10007: EQUAL
10008: IFTRUE 10012
10010: GO 10059
10012: POP
// begin us_scout := 2 ;
10013: LD_ADDR_EXP 8
10017: PUSH
10018: LD_INT 2
10020: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10021: LD_EXP 21
10025: PPUSH
10026: LD_STRING D3Fba-JMM-1
10028: PPUSH
10029: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10033: LD_EXP 33
10037: PPUSH
10038: LD_STRING D3Fba-Frank-1
10040: PPUSH
10041: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10045: LD_EXP 21
10049: PPUSH
10050: LD_STRING D3Fba-JMM-2
10052: PPUSH
10053: CALL_OW 88
// end ; 2 :
10057: GO 10091
10059: LD_INT 2
10061: DOUBLE
10062: EQUAL
10063: IFTRUE 10067
10065: GO 10090
10067: POP
// begin us_scout := 0 ;
10068: LD_ADDR_EXP 8
10072: PUSH
10073: LD_INT 0
10075: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10076: LD_EXP 21
10080: PPUSH
10081: LD_STRING D3Fbb-JMM-1
10083: PPUSH
10084: CALL_OW 88
// end ; end ;
10088: GO 10091
10090: POP
// end ; 3 :
10091: GO 10126
10093: LD_INT 3
10095: DOUBLE
10096: EQUAL
10097: IFTRUE 10101
10099: GO 10125
10101: POP
// begin us_scout := - 1 ;
10102: LD_ADDR_EXP 8
10106: PUSH
10107: LD_INT 1
10109: NEG
10110: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
10111: LD_EXP 21
10115: PPUSH
10116: LD_STRING D3Fc-JMM-1
10118: PPUSH
10119: CALL_OW 88
// end ; end ;
10123: GO 10126
10125: POP
// DialogueOff ;
10126: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
10130: LD_EXP 8
10134: PUSH
10135: LD_INT 1
10137: NEG
10138: PUSH
10139: LD_INT 0
10141: PUSH
10142: EMPTY
10143: LIST
10144: LIST
10145: IN
10146: IFFALSE 10150
// exit ;
10148: GO 11797
// if us_scout in [ 1 , 2 ] then
10150: LD_EXP 8
10154: PUSH
10155: LD_INT 1
10157: PUSH
10158: LD_INT 2
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: IN
10165: IFFALSE 10864
// begin if IsInUnit ( Frank ) then
10167: LD_EXP 33
10171: PPUSH
10172: CALL_OW 310
10176: IFFALSE 10187
// ComExitBuilding ( Frank ) ;
10178: LD_EXP 33
10182: PPUSH
10183: CALL_OW 122
// if IsDrivenBy ( Frank ) then
10187: LD_EXP 33
10191: PPUSH
10192: CALL_OW 311
10196: IFFALSE 10207
// ComExitVehicle ( Frank ) ;
10198: LD_EXP 33
10202: PPUSH
10203: CALL_OW 121
// SetSide ( Frank , 4 ) ;
10207: LD_EXP 33
10211: PPUSH
10212: LD_INT 4
10214: PPUSH
10215: CALL_OW 235
// wait ( 0 0$1 ) ;
10219: LD_INT 35
10221: PPUSH
10222: CALL_OW 67
// if us_scout = 2 then
10226: LD_EXP 8
10230: PUSH
10231: LD_INT 2
10233: EQUAL
10234: IFFALSE 10602
// begin ComMoveXY ( Frank , 75 , 63 ) ;
10236: LD_EXP 33
10240: PPUSH
10241: LD_INT 75
10243: PPUSH
10244: LD_INT 63
10246: PPUSH
10247: CALL_OW 111
// AddComHold ( Frank ) ;
10251: LD_EXP 33
10255: PPUSH
10256: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
10260: LD_EXP 33
10264: PPUSH
10265: LD_INT 770
10267: PPUSH
10268: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
10272: LD_EXP 33
10276: PPUSH
10277: LD_INT 100
10279: PPUSH
10280: LD_INT 75
10282: PPUSH
10283: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
10287: LD_EXP 33
10291: PPUSH
10292: LD_INT 123
10294: PPUSH
10295: LD_INT 103
10297: PPUSH
10298: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
10302: LD_EXP 33
10306: PPUSH
10307: LD_INT 138
10309: PPUSH
10310: LD_INT 108
10312: PPUSH
10313: CALL_OW 171
// AddComHold ( Frank ) ;
10317: LD_EXP 33
10321: PPUSH
10322: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10326: LD_INT 35
10328: PPUSH
10329: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
10333: LD_EXP 33
10337: PPUSH
10338: LD_INT 138
10340: PPUSH
10341: LD_INT 108
10343: PPUSH
10344: CALL_OW 307
10348: IFFALSE 10326
// AddComMoveXY ( Frank , 125 , 132 ) ;
10350: LD_EXP 33
10354: PPUSH
10355: LD_INT 125
10357: PPUSH
10358: LD_INT 132
10360: PPUSH
10361: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10365: LD_INT 35
10367: PPUSH
10368: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
10372: LD_INT 1
10374: PPUSH
10375: LD_EXP 33
10379: PPUSH
10380: CALL_OW 292
10384: PUSH
10385: LD_EXP 33
10389: PPUSH
10390: LD_INT 7
10392: PPUSH
10393: CALL_OW 296
10397: PUSH
10398: LD_INT 7
10400: LESS
10401: OR
10402: IFFALSE 10365
// DialogueOn ;
10404: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10408: LD_EXP 33
10412: PPUSH
10413: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
10417: LD_INT 10
10419: PPUSH
10420: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
10424: LD_EXP 21
10428: PPUSH
10429: LD_STRING D4Fa-JMM-1
10431: PPUSH
10432: CALL_OW 88
// for i in points do
10436: LD_ADDR_VAR 0 1
10440: PUSH
10441: LD_VAR 0 2
10445: PUSH
10446: FOR_IN
10447: IFFALSE 10505
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
10449: LD_VAR 0 1
10453: PUSH
10454: LD_INT 1
10456: ARRAY
10457: PPUSH
10458: LD_VAR 0 1
10462: PUSH
10463: LD_INT 2
10465: ARRAY
10466: PPUSH
10467: LD_INT 1
10469: PPUSH
10470: LD_INT 20
10472: NEG
10473: PPUSH
10474: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
10478: LD_VAR 0 1
10482: PUSH
10483: LD_INT 1
10485: ARRAY
10486: PPUSH
10487: LD_VAR 0 1
10491: PUSH
10492: LD_INT 2
10494: ARRAY
10495: PPUSH
10496: LD_INT 1
10498: PPUSH
10499: CALL_OW 331
// end ;
10503: GO 10446
10505: POP
10506: POP
// dwait ( 0 0$0.5 ) ;
10507: LD_INT 18
10509: PPUSH
10510: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
10514: LD_INT 42
10516: PPUSH
10517: LD_INT 27
10519: PPUSH
10520: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
10524: LD_EXP 33
10528: PPUSH
10529: LD_STRING D4Fa-Frank-1
10531: PPUSH
10532: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
10536: LD_INT 18
10538: PPUSH
10539: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
10543: LD_EXP 21
10547: PPUSH
10548: LD_STRING D4Fa-JMM-2
10550: PPUSH
10551: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
10555: LD_INT 118
10557: PPUSH
10558: LD_INT 80
10560: PPUSH
10561: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
10565: LD_EXP 33
10569: PPUSH
10570: LD_STRING D4Fa-Frank-2
10572: PPUSH
10573: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
10577: LD_INT 10
10579: PPUSH
10580: CALL_OW 68
// DialogueOff ;
10584: CALL_OW 7
// SetSide ( Frank , 1 ) ;
10588: LD_EXP 33
10592: PPUSH
10593: LD_INT 1
10595: PPUSH
10596: CALL_OW 235
// end else
10600: GO 10864
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
10602: LD_INT 2
10604: PPUSH
10605: LD_INT 4
10607: PPUSH
10608: LD_INT 2
10610: PPUSH
10611: LD_INT 1
10613: PPUSH
10614: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
10618: LD_EXP 33
10622: PPUSH
10623: LD_INT 75
10625: PPUSH
10626: LD_INT 63
10628: PPUSH
10629: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
10633: LD_EXP 33
10637: PPUSH
10638: LD_INT 175
10640: PPUSH
10641: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
10645: LD_EXP 33
10649: PPUSH
10650: LD_INT 102
10652: PPUSH
10653: LD_INT 76
10655: PPUSH
10656: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
10660: LD_EXP 33
10664: PPUSH
10665: LD_INT 108
10667: PPUSH
10668: LD_INT 70
10670: PPUSH
10671: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10675: LD_INT 35
10677: PPUSH
10678: CALL_OW 67
// until See ( 2 , Frank ) ;
10682: LD_INT 2
10684: PPUSH
10685: LD_EXP 33
10689: PPUSH
10690: CALL_OW 292
10694: IFFALSE 10675
// ComMoveXY ( Frank , 112 , 118 ) ;
10696: LD_EXP 33
10700: PPUSH
10701: LD_INT 112
10703: PPUSH
10704: LD_INT 118
10706: PPUSH
10707: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
10711: LD_EXP 33
10715: PPUSH
10716: CALL_OW 256
10720: PUSH
10721: LD_INT 750
10723: GREATEREQUAL
10724: IFFALSE 10738
// SetLives ( Frank , 700 ) ;
10726: LD_EXP 33
10730: PPUSH
10731: LD_INT 700
10733: PPUSH
10734: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
10738: LD_INT 35
10740: PPUSH
10741: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
10745: LD_INT 1
10747: PPUSH
10748: LD_EXP 33
10752: PPUSH
10753: CALL_OW 292
10757: PUSH
10758: LD_EXP 33
10762: PPUSH
10763: LD_INT 7
10765: PPUSH
10766: CALL_OW 296
10770: PUSH
10771: LD_INT 17
10773: LESS
10774: OR
10775: IFFALSE 10738
// DialogueOn ;
10777: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
10781: LD_EXP 33
10785: PPUSH
10786: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
10790: LD_EXP 33
10794: PPUSH
10795: LD_STRING D4Fb-Frank-1
10797: PPUSH
10798: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
10802: LD_EXP 21
10806: PPUSH
10807: LD_STRING D4Fb-JMM-1
10809: PPUSH
10810: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
10814: LD_INT 2
10816: PPUSH
10817: LD_STRING D4Fb-FSci1-1
10819: PPUSH
10820: CALL 15445 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
10824: LD_EXP 33
10828: PPUSH
10829: LD_STRING D4Fb-Frank-2
10831: PPUSH
10832: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
10836: LD_EXP 21
10840: PPUSH
10841: LD_STRING D4Fb-JMM-2
10843: PPUSH
10844: CALL_OW 88
// DialogueOff ;
10848: CALL_OW 7
// SetSide ( Frank , 1 ) ;
10852: LD_EXP 33
10856: PPUSH
10857: LD_INT 1
10859: PPUSH
10860: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
10864: LD_EXP 34
10868: PPUSH
10869: CALL_OW 302
10873: PUSH
10874: LD_EXP 33
10878: NOT
10879: AND
10880: IFFALSE 11028
// begin DialogueOn ;
10882: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
10886: LD_EXP 21
10890: PUSH
10891: LD_EXP 34
10895: PUSH
10896: EMPTY
10897: LIST
10898: LIST
10899: PPUSH
10900: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
10904: LD_EXP 34
10908: PPUSH
10909: LD_STRING D3Y-Yam-1
10911: PPUSH
10912: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
10916: LD_EXP 21
10920: PPUSH
10921: LD_STRING D3Y-JMM-1
10923: PPUSH
10924: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
10928: LD_EXP 34
10932: PPUSH
10933: LD_STRING D3Y-Yam-2
10935: PPUSH
10936: CALL_OW 88
// case Query ( QYamoko ) of 1 :
10940: LD_STRING QYamoko
10942: PPUSH
10943: CALL_OW 97
10947: PUSH
10948: LD_INT 1
10950: DOUBLE
10951: EQUAL
10952: IFTRUE 10956
10954: GO 10991
10956: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
10957: LD_EXP 21
10961: PPUSH
10962: LD_STRING D3Ya-JMM-1
10964: PPUSH
10965: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
10969: LD_EXP 34
10973: PPUSH
10974: LD_STRING D3Ya-Yam-1
10976: PPUSH
10977: CALL_OW 88
// us_scout := 1 ;
10981: LD_ADDR_EXP 8
10985: PUSH
10986: LD_INT 1
10988: ST_TO_ADDR
// end ; 2 :
10989: GO 11024
10991: LD_INT 2
10993: DOUBLE
10994: EQUAL
10995: IFTRUE 10999
10997: GO 11023
10999: POP
// begin us_scout := - 1 ;
11000: LD_ADDR_EXP 8
11004: PUSH
11005: LD_INT 1
11007: NEG
11008: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11009: LD_EXP 21
11013: PPUSH
11014: LD_STRING D3Yb-JMM-1
11016: PPUSH
11017: CALL_OW 88
// end ; end ;
11021: GO 11024
11023: POP
// DialogueOff ;
11024: CALL_OW 7
// end ; if Frank then
11028: LD_EXP 33
11032: IFFALSE 11036
// exit ;
11034: GO 11797
// if us_scout in [ - 1 , 0 ] then
11036: LD_EXP 8
11040: PUSH
11041: LD_INT 1
11043: NEG
11044: PUSH
11045: LD_INT 0
11047: PUSH
11048: EMPTY
11049: LIST
11050: LIST
11051: IN
11052: IFFALSE 11056
// exit ;
11054: GO 11797
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11056: LD_ADDR_EXP 8
11060: PUSH
11061: LD_INT 2
11063: PUSH
11064: LD_INT 2
11066: PUSH
11067: LD_INT 1
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: LIST
11074: PUSH
11075: LD_OWVAR 67
11079: ARRAY
11080: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11081: LD_EXP 8
11085: PUSH
11086: LD_INT 1
11088: PUSH
11089: LD_INT 2
11091: PUSH
11092: EMPTY
11093: LIST
11094: LIST
11095: IN
11096: IFFALSE 11797
// begin if IsInUnit ( Kikuchi ) then
11098: LD_EXP 34
11102: PPUSH
11103: CALL_OW 310
11107: IFFALSE 11118
// ComExitBuilding ( Kikuchi ) ;
11109: LD_EXP 34
11113: PPUSH
11114: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
11118: LD_EXP 34
11122: PPUSH
11123: CALL_OW 311
11127: IFFALSE 11138
// ComExitVehicle ( Kikuchi ) ;
11129: LD_EXP 34
11133: PPUSH
11134: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
11138: LD_EXP 34
11142: PPUSH
11143: LD_INT 4
11145: PPUSH
11146: CALL_OW 235
// wait ( 0 0$1 ) ;
11150: LD_INT 35
11152: PPUSH
11153: CALL_OW 67
// if us_scout = 2 then
11157: LD_EXP 8
11161: PUSH
11162: LD_INT 2
11164: EQUAL
11165: IFFALSE 11545
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
11167: LD_EXP 34
11171: PPUSH
11172: LD_INT 75
11174: PPUSH
11175: LD_INT 63
11177: PPUSH
11178: CALL_OW 111
// AddComHold ( Kikuchi ) ;
11182: LD_EXP 34
11186: PPUSH
11187: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
11191: LD_EXP 34
11195: PPUSH
11196: LD_INT 770
11198: PPUSH
11199: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
11203: LD_EXP 34
11207: PPUSH
11208: LD_INT 100
11210: PPUSH
11211: LD_INT 75
11213: PPUSH
11214: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
11218: LD_EXP 34
11222: PPUSH
11223: LD_INT 123
11225: PPUSH
11226: LD_INT 103
11228: PPUSH
11229: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
11233: LD_EXP 34
11237: PPUSH
11238: LD_INT 138
11240: PPUSH
11241: LD_INT 108
11243: PPUSH
11244: CALL_OW 171
// AddComHold ( Kikuchi ) ;
11248: LD_EXP 34
11252: PPUSH
11253: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11257: LD_INT 35
11259: PPUSH
11260: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
11264: LD_EXP 34
11268: PPUSH
11269: LD_INT 138
11271: PPUSH
11272: LD_INT 108
11274: PPUSH
11275: CALL_OW 307
11279: IFFALSE 11257
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
11281: LD_EXP 34
11285: PPUSH
11286: LD_INT 125
11288: PPUSH
11289: LD_INT 132
11291: PPUSH
11292: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11296: LD_INT 35
11298: PPUSH
11299: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
11303: LD_INT 1
11305: PPUSH
11306: LD_EXP 34
11310: PPUSH
11311: CALL_OW 292
11315: PUSH
11316: LD_EXP 34
11320: PPUSH
11321: LD_INT 7
11323: PPUSH
11324: CALL_OW 296
11328: PUSH
11329: LD_INT 7
11331: LESS
11332: OR
11333: IFFALSE 11296
// DialogueOn ;
11335: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11339: LD_EXP 34
11343: PPUSH
11344: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11348: LD_INT 10
11350: PPUSH
11351: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
11355: LD_EXP 34
11359: PPUSH
11360: LD_STRING D4Ya-Yam-1
11362: PPUSH
11363: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
11367: LD_EXP 21
11371: PPUSH
11372: LD_STRING D4Ya-JMM-1
11374: PPUSH
11375: CALL_OW 88
// for i in points do
11379: LD_ADDR_VAR 0 1
11383: PUSH
11384: LD_VAR 0 2
11388: PUSH
11389: FOR_IN
11390: IFFALSE 11448
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11392: LD_VAR 0 1
11396: PUSH
11397: LD_INT 1
11399: ARRAY
11400: PPUSH
11401: LD_VAR 0 1
11405: PUSH
11406: LD_INT 2
11408: ARRAY
11409: PPUSH
11410: LD_INT 1
11412: PPUSH
11413: LD_INT 20
11415: NEG
11416: PPUSH
11417: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11421: LD_VAR 0 1
11425: PUSH
11426: LD_INT 1
11428: ARRAY
11429: PPUSH
11430: LD_VAR 0 1
11434: PUSH
11435: LD_INT 2
11437: ARRAY
11438: PPUSH
11439: LD_INT 1
11441: PPUSH
11442: CALL_OW 331
// end ;
11446: GO 11389
11448: POP
11449: POP
// dwait ( 0 0$0.5 ) ;
11450: LD_INT 18
11452: PPUSH
11453: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11457: LD_INT 42
11459: PPUSH
11460: LD_INT 27
11462: PPUSH
11463: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
11467: LD_EXP 34
11471: PPUSH
11472: LD_STRING D4Ya-Yam-2
11474: PPUSH
11475: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11479: LD_INT 18
11481: PPUSH
11482: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
11486: LD_INT 118
11488: PPUSH
11489: LD_INT 80
11491: PPUSH
11492: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
11496: LD_EXP 21
11500: PPUSH
11501: LD_STRING D4Ya-JMM-2
11503: PPUSH
11504: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
11508: LD_EXP 34
11512: PPUSH
11513: LD_STRING D4Ya-Yam-3
11515: PPUSH
11516: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11520: LD_INT 10
11522: PPUSH
11523: CALL_OW 68
// DialogueOff ;
11527: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
11531: LD_EXP 34
11535: PPUSH
11536: LD_INT 1
11538: PPUSH
11539: CALL_OW 235
// end else
11543: GO 11797
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11545: LD_INT 2
11547: PPUSH
11548: LD_INT 4
11550: PPUSH
11551: LD_INT 2
11553: PPUSH
11554: LD_INT 1
11556: PPUSH
11557: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
11561: LD_EXP 34
11565: PPUSH
11566: LD_INT 75
11568: PPUSH
11569: LD_INT 63
11571: PPUSH
11572: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
11576: LD_EXP 34
11580: PPUSH
11581: LD_INT 175
11583: PPUSH
11584: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
11588: LD_EXP 34
11592: PPUSH
11593: LD_INT 102
11595: PPUSH
11596: LD_INT 76
11598: PPUSH
11599: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
11603: LD_EXP 34
11607: PPUSH
11608: LD_INT 108
11610: PPUSH
11611: LD_INT 70
11613: PPUSH
11614: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11618: LD_INT 35
11620: PPUSH
11621: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
11625: LD_INT 2
11627: PPUSH
11628: LD_EXP 34
11632: PPUSH
11633: CALL_OW 292
11637: IFFALSE 11618
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
11639: LD_EXP 34
11643: PPUSH
11644: LD_INT 112
11646: PPUSH
11647: LD_INT 118
11649: PPUSH
11650: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
11654: LD_EXP 34
11658: PPUSH
11659: CALL_OW 256
11663: PUSH
11664: LD_INT 750
11666: GREATEREQUAL
11667: IFFALSE 11681
// SetLives ( Kikuchi , 700 ) ;
11669: LD_EXP 34
11673: PPUSH
11674: LD_INT 700
11676: PPUSH
11677: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11681: LD_INT 35
11683: PPUSH
11684: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
11688: LD_INT 1
11690: PPUSH
11691: LD_EXP 34
11695: PPUSH
11696: CALL_OW 292
11700: PUSH
11701: LD_EXP 34
11705: PPUSH
11706: LD_INT 7
11708: PPUSH
11709: CALL_OW 296
11713: PUSH
11714: LD_INT 17
11716: LESS
11717: OR
11718: IFFALSE 11681
// DialogueOn ;
11720: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
11724: LD_EXP 34
11728: PPUSH
11729: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
11733: LD_EXP 34
11737: PPUSH
11738: LD_STRING D4Yb-Yam-1
11740: PPUSH
11741: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
11745: LD_EXP 21
11749: PPUSH
11750: LD_STRING D4Yb-JMM-1
11752: PPUSH
11753: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
11757: LD_EXP 34
11761: PPUSH
11762: LD_STRING D4Yb-Yam-2
11764: PPUSH
11765: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
11769: LD_EXP 21
11773: PPUSH
11774: LD_STRING D4Yb-JMM-2
11776: PPUSH
11777: CALL_OW 88
// DialogueOff ;
11781: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
11785: LD_EXP 34
11789: PPUSH
11790: LD_INT 1
11792: PPUSH
11793: CALL_OW 235
// end ; end ; end ;
11797: PPOPN 2
11799: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
11800: LD_EXP 6
11804: IFFALSE 12837
11806: GO 11808
11808: DISABLE
11809: LD_INT 0
11811: PPUSH
11812: PPUSH
11813: PPUSH
11814: PPUSH
// begin enable ;
11815: ENABLE
// if not seen [ 1 ] then
11816: LD_EXP 9
11820: PUSH
11821: LD_INT 1
11823: ARRAY
11824: NOT
11825: IFFALSE 12005
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
11827: LD_ADDR_VAR 0 2
11831: PUSH
11832: LD_INT 22
11834: PUSH
11835: LD_INT 2
11837: PUSH
11838: EMPTY
11839: LIST
11840: LIST
11841: PUSH
11842: LD_INT 2
11844: PUSH
11845: LD_INT 25
11847: PUSH
11848: LD_INT 11
11850: PUSH
11851: EMPTY
11852: LIST
11853: LIST
11854: PUSH
11855: LD_INT 33
11857: PUSH
11858: LD_INT 4
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: PUSH
11865: EMPTY
11866: LIST
11867: LIST
11868: LIST
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: PPUSH
11874: CALL_OW 69
11878: ST_TO_ADDR
// if tmp then
11879: LD_VAR 0 2
11883: IFFALSE 12005
// for i in tmp do
11885: LD_ADDR_VAR 0 1
11889: PUSH
11890: LD_VAR 0 2
11894: PUSH
11895: FOR_IN
11896: IFFALSE 12003
// if See ( 1 , i ) then
11898: LD_INT 1
11900: PPUSH
11901: LD_VAR 0 1
11905: PPUSH
11906: CALL_OW 292
11910: IFFALSE 12001
// begin seen := Replace ( seen , 1 , true ) ;
11912: LD_ADDR_EXP 9
11916: PUSH
11917: LD_EXP 9
11921: PPUSH
11922: LD_INT 1
11924: PPUSH
11925: LD_INT 1
11927: PPUSH
11928: CALL_OW 1
11932: ST_TO_ADDR
// if CanSayRand ( 1 ) then
11933: LD_INT 1
11935: PPUSH
11936: CALL 15267 0 1
11940: IFFALSE 12001
// begin DialogueOn ;
11942: CALL_OW 6
// CenterNowOnUnits ( i ) ;
11946: LD_VAR 0 1
11950: PPUSH
11951: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11955: LD_INT 10
11957: PPUSH
11958: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
11962: LD_ADDR_VAR 0 3
11966: PUSH
11967: LD_INT 1
11969: PPUSH
11970: LD_STRING D5a-Sol2-1
11972: PPUSH
11973: CALL 15445 0 2
11977: ST_TO_ADDR
// if not un then
11978: LD_VAR 0 3
11982: NOT
11983: IFFALSE 11995
// SayRand ( sex_female , D5a-FSol2-1 ) ;
11985: LD_INT 2
11987: PPUSH
11988: LD_STRING D5a-FSol2-1
11990: PPUSH
11991: CALL 15445 0 2
// DialogueOff ;
11995: CALL_OW 7
// break ;
11999: GO 12003
// end ; end ;
12001: GO 11895
12003: POP
12004: POP
// end ; if not seen [ 2 ] then
12005: LD_EXP 9
12009: PUSH
12010: LD_INT 2
12012: ARRAY
12013: NOT
12014: IFFALSE 12239
// begin can_kamikazed := true ;
12016: LD_ADDR_EXP 10
12020: PUSH
12021: LD_INT 1
12023: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12024: LD_ADDR_VAR 0 2
12028: PUSH
12029: LD_INT 22
12031: PUSH
12032: LD_INT 2
12034: PUSH
12035: EMPTY
12036: LIST
12037: LIST
12038: PUSH
12039: LD_INT 25
12041: PUSH
12042: LD_INT 17
12044: PUSH
12045: EMPTY
12046: LIST
12047: LIST
12048: PUSH
12049: EMPTY
12050: LIST
12051: LIST
12052: PPUSH
12053: CALL_OW 69
12057: ST_TO_ADDR
// if tmp then
12058: LD_VAR 0 2
12062: IFFALSE 12239
// for i in tmp do
12064: LD_ADDR_VAR 0 1
12068: PUSH
12069: LD_VAR 0 2
12073: PUSH
12074: FOR_IN
12075: IFFALSE 12237
// if See ( 1 , i ) then
12077: LD_INT 1
12079: PPUSH
12080: LD_VAR 0 1
12084: PPUSH
12085: CALL_OW 292
12089: IFFALSE 12235
// begin seen := Replace ( seen , 2 , true ) ;
12091: LD_ADDR_EXP 9
12095: PUSH
12096: LD_EXP 9
12100: PPUSH
12101: LD_INT 2
12103: PPUSH
12104: LD_INT 1
12106: PPUSH
12107: CALL_OW 1
12111: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12112: LD_INT 1
12114: PPUSH
12115: CALL 15267 0 1
12119: IFFALSE 12235
// begin DialogueOn ;
12121: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12125: LD_VAR 0 1
12129: PPUSH
12130: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12134: LD_INT 10
12136: PPUSH
12137: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
12141: LD_ADDR_VAR 0 3
12145: PUSH
12146: LD_INT 1
12148: PPUSH
12149: LD_STRING D5b-Sol1-1
12151: PPUSH
12152: CALL 15445 0 2
12156: ST_TO_ADDR
// if not un then
12157: LD_VAR 0 3
12161: NOT
12162: IFFALSE 12180
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
12164: LD_ADDR_VAR 0 3
12168: PUSH
12169: LD_INT 2
12171: PPUSH
12172: LD_STRING D5b-FSol1-1
12174: PPUSH
12175: CALL 15445 0 2
12179: ST_TO_ADDR
// if un then
12180: LD_VAR 0 3
12184: IFFALSE 12229
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
12186: LD_ADDR_VAR 0 4
12190: PUSH
12191: LD_INT 1
12193: PPUSH
12194: LD_STRING D5b-Sol2-1
12196: PPUSH
12197: LD_VAR 0 3
12201: PPUSH
12202: CALL 15671 0 3
12206: ST_TO_ADDR
// if not un2 then
12207: LD_VAR 0 4
12211: NOT
12212: IFFALSE 12229
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
12214: LD_INT 2
12216: PPUSH
12217: LD_STRING D5b-FSol2-1
12219: PPUSH
12220: LD_VAR 0 3
12224: PPUSH
12225: CALL 15671 0 3
// end ; DialogueOff ;
12229: CALL_OW 7
// break ;
12233: GO 12237
// end ; end ;
12235: GO 12074
12237: POP
12238: POP
// end ; if not seen [ 3 ] then
12239: LD_EXP 9
12243: PUSH
12244: LD_INT 3
12246: ARRAY
12247: NOT
12248: IFFALSE 12422
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
12250: LD_ADDR_VAR 0 2
12254: PUSH
12255: LD_INT 22
12257: PUSH
12258: LD_INT 2
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: PUSH
12265: LD_INT 33
12267: PUSH
12268: LD_INT 2
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: PUSH
12275: EMPTY
12276: LIST
12277: LIST
12278: PPUSH
12279: CALL_OW 69
12283: ST_TO_ADDR
// if tmp then
12284: LD_VAR 0 2
12288: IFFALSE 12422
// for i in tmp do
12290: LD_ADDR_VAR 0 1
12294: PUSH
12295: LD_VAR 0 2
12299: PUSH
12300: FOR_IN
12301: IFFALSE 12420
// if See ( 1 , i ) then
12303: LD_INT 1
12305: PPUSH
12306: LD_VAR 0 1
12310: PPUSH
12311: CALL_OW 292
12315: IFFALSE 12418
// begin seen := Replace ( seen , 3 , true ) ;
12317: LD_ADDR_EXP 9
12321: PUSH
12322: LD_EXP 9
12326: PPUSH
12327: LD_INT 3
12329: PPUSH
12330: LD_INT 1
12332: PPUSH
12333: CALL_OW 1
12337: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12338: LD_INT 1
12340: PPUSH
12341: CALL 15267 0 1
12345: IFFALSE 12418
// begin DialogueOn ;
12347: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12351: LD_VAR 0 1
12355: PPUSH
12356: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12360: LD_INT 10
12362: PPUSH
12363: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
12367: LD_ADDR_VAR 0 3
12371: PUSH
12372: LD_INT 1
12374: PPUSH
12375: LD_STRING D8-Sol1-1
12377: PPUSH
12378: CALL 15445 0 2
12382: ST_TO_ADDR
// if not un then
12383: LD_VAR 0 3
12387: NOT
12388: IFFALSE 12400
// SayRand ( sex_female , D8-FSol1-1 ) ;
12390: LD_INT 2
12392: PPUSH
12393: LD_STRING D8-FSol1-1
12395: PPUSH
12396: CALL 15445 0 2
// Say ( JMM , D8-JMM-1 ) ;
12400: LD_EXP 21
12404: PPUSH
12405: LD_STRING D8-JMM-1
12407: PPUSH
12408: CALL_OW 88
// DialogueOff ;
12412: CALL_OW 7
// break ;
12416: GO 12420
// end ; end ;
12418: GO 12300
12420: POP
12421: POP
// end ; if not seen [ 4 ] then
12422: LD_EXP 9
12426: PUSH
12427: LD_INT 4
12429: ARRAY
12430: NOT
12431: IFFALSE 12593
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
12433: LD_ADDR_VAR 0 2
12437: PUSH
12438: LD_INT 22
12440: PUSH
12441: LD_INT 2
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: PUSH
12448: LD_INT 33
12450: PUSH
12451: LD_INT 5
12453: PUSH
12454: EMPTY
12455: LIST
12456: LIST
12457: PUSH
12458: EMPTY
12459: LIST
12460: LIST
12461: PPUSH
12462: CALL_OW 69
12466: ST_TO_ADDR
// if tmp then
12467: LD_VAR 0 2
12471: IFFALSE 12593
// for i in tmp do
12473: LD_ADDR_VAR 0 1
12477: PUSH
12478: LD_VAR 0 2
12482: PUSH
12483: FOR_IN
12484: IFFALSE 12591
// if See ( 1 , i ) then
12486: LD_INT 1
12488: PPUSH
12489: LD_VAR 0 1
12493: PPUSH
12494: CALL_OW 292
12498: IFFALSE 12589
// begin seen := Replace ( seen , 4 , true ) ;
12500: LD_ADDR_EXP 9
12504: PUSH
12505: LD_EXP 9
12509: PPUSH
12510: LD_INT 4
12512: PPUSH
12513: LD_INT 1
12515: PPUSH
12516: CALL_OW 1
12520: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12521: LD_INT 1
12523: PPUSH
12524: CALL 15267 0 1
12528: IFFALSE 12589
// begin DialogueOn ;
12530: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12534: LD_VAR 0 1
12538: PPUSH
12539: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12543: LD_INT 10
12545: PPUSH
12546: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
12550: LD_ADDR_VAR 0 3
12554: PUSH
12555: LD_INT 1
12557: PPUSH
12558: LD_STRING D5a-Sol1-1
12560: PPUSH
12561: CALL 15445 0 2
12565: ST_TO_ADDR
// if not un then
12566: LD_VAR 0 3
12570: NOT
12571: IFFALSE 12583
// SayRand ( sex_female , D5a-FSol1-1 ) ;
12573: LD_INT 2
12575: PPUSH
12576: LD_STRING D5a-FSol1-1
12578: PPUSH
12579: CALL 15445 0 2
// DialogueOff ;
12583: CALL_OW 7
// break ;
12587: GO 12591
// end ; end ;
12589: GO 12483
12591: POP
12592: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
12593: LD_EXP 9
12597: PUSH
12598: LD_INT 5
12600: ARRAY
12601: NOT
12602: PUSH
12603: LD_EXP 9
12607: PUSH
12608: LD_INT 3
12610: ARRAY
12611: AND
12612: IFFALSE 12786
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
12614: LD_ADDR_VAR 0 2
12618: PUSH
12619: LD_INT 22
12621: PUSH
12622: LD_INT 2
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: PUSH
12629: LD_INT 34
12631: PUSH
12632: LD_INT 31
12634: PUSH
12635: EMPTY
12636: LIST
12637: LIST
12638: PUSH
12639: EMPTY
12640: LIST
12641: LIST
12642: PPUSH
12643: CALL_OW 69
12647: ST_TO_ADDR
// if tmp then
12648: LD_VAR 0 2
12652: IFFALSE 12786
// for i in tmp do
12654: LD_ADDR_VAR 0 1
12658: PUSH
12659: LD_VAR 0 2
12663: PUSH
12664: FOR_IN
12665: IFFALSE 12784
// if See ( 1 , i ) then
12667: LD_INT 1
12669: PPUSH
12670: LD_VAR 0 1
12674: PPUSH
12675: CALL_OW 292
12679: IFFALSE 12782
// begin seen := Replace ( seen , 5 , true ) ;
12681: LD_ADDR_EXP 9
12685: PUSH
12686: LD_EXP 9
12690: PPUSH
12691: LD_INT 5
12693: PPUSH
12694: LD_INT 1
12696: PPUSH
12697: CALL_OW 1
12701: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12702: LD_INT 1
12704: PPUSH
12705: CALL 15267 0 1
12709: IFFALSE 12782
// begin DialogueOn ;
12711: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12715: LD_VAR 0 1
12719: PPUSH
12720: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12724: LD_INT 10
12726: PPUSH
12727: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
12731: LD_ADDR_VAR 0 3
12735: PUSH
12736: LD_INT 1
12738: PPUSH
12739: LD_STRING D8a-Sol2-1
12741: PPUSH
12742: CALL 15445 0 2
12746: ST_TO_ADDR
// if not un then
12747: LD_VAR 0 3
12751: NOT
12752: IFFALSE 12764
// SayRand ( sex_female , D8a-FSol2-1 ) ;
12754: LD_INT 2
12756: PPUSH
12757: LD_STRING D8a-FSol2-1
12759: PPUSH
12760: CALL 15445 0 2
// Say ( JMM , D8a-JMM-1 ) ;
12764: LD_EXP 21
12768: PPUSH
12769: LD_STRING D8a-JMM-1
12771: PPUSH
12772: CALL_OW 88
// DialogueOff ;
12776: CALL_OW 7
// break ;
12780: GO 12784
// end ; end ;
12782: GO 12664
12784: POP
12785: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
12786: LD_EXP 9
12790: PUSH
12791: LD_INT 1
12793: ARRAY
12794: PUSH
12795: LD_EXP 9
12799: PUSH
12800: LD_INT 2
12802: ARRAY
12803: AND
12804: PUSH
12805: LD_EXP 9
12809: PUSH
12810: LD_INT 3
12812: ARRAY
12813: AND
12814: PUSH
12815: LD_EXP 9
12819: PUSH
12820: LD_INT 4
12822: ARRAY
12823: AND
12824: PUSH
12825: LD_EXP 9
12829: PUSH
12830: LD_INT 5
12832: ARRAY
12833: AND
12834: IFFALSE 12837
// disable ;
12836: DISABLE
// end ;
12837: PPOPN 4
12839: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
12840: LD_EXP 10
12844: PUSH
12845: LD_EXP 11
12849: AND
12850: IFFALSE 13048
12852: GO 12854
12854: DISABLE
12855: LD_INT 0
12857: PPUSH
// begin DialogueOn ;
12858: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
12862: LD_EXP 11
12866: PPUSH
12867: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
12871: LD_ADDR_VAR 0 1
12875: PUSH
12876: LD_INT 1
12878: PPUSH
12879: LD_STRING D5c-Sol1-1
12881: PPUSH
12882: CALL 15445 0 2
12886: ST_TO_ADDR
// if not un then
12887: LD_VAR 0 1
12891: NOT
12892: IFFALSE 12910
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
12894: LD_ADDR_VAR 0 1
12898: PUSH
12899: LD_INT 2
12901: PPUSH
12902: LD_STRING D5c-FSol1-1
12904: PPUSH
12905: CALL 15445 0 2
12909: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
12910: LD_EXP 21
12914: PPUSH
12915: LD_STRING D5c-JMM-1
12917: PPUSH
12918: CALL_OW 88
// if IsOk ( Lisa ) then
12922: LD_EXP 22
12926: PPUSH
12927: CALL_OW 302
12931: IFFALSE 12947
// Say ( Lisa , D5d-Lisa-1 ) else
12933: LD_EXP 22
12937: PPUSH
12938: LD_STRING D5d-Lisa-1
12940: PPUSH
12941: CALL_OW 88
12945: GO 13032
// if IsOk ( Cyrus ) then
12947: LD_EXP 25
12951: PPUSH
12952: CALL_OW 302
12956: IFFALSE 12972
// Say ( Cyrus , D5d-Cyrus-1 ) else
12958: LD_EXP 25
12962: PPUSH
12963: LD_STRING D5d-Cyrus-1
12965: PPUSH
12966: CALL_OW 88
12970: GO 13032
// if IsOk ( Gary ) then
12972: LD_EXP 32
12976: PPUSH
12977: CALL_OW 302
12981: IFFALSE 12997
// Say ( Gary , D5d-Gary-1 ) else
12983: LD_EXP 32
12987: PPUSH
12988: LD_STRING D5d-Gary-1
12990: PPUSH
12991: CALL_OW 88
12995: GO 13032
// if GetSex ( un ) = sex_male then
12997: LD_VAR 0 1
13001: PPUSH
13002: CALL_OW 258
13006: PUSH
13007: LD_INT 1
13009: EQUAL
13010: IFFALSE 13026
// Say ( un , D5d-Sol1-1 ) else
13012: LD_VAR 0 1
13016: PPUSH
13017: LD_STRING D5d-Sol1-1
13019: PPUSH
13020: CALL_OW 88
13024: GO 13032
// begin DialogueOff ;
13026: CALL_OW 7
// exit ;
13030: GO 13048
// end ; Say ( JMM , D5d-JMM-1 ) ;
13032: LD_EXP 21
13036: PPUSH
13037: LD_STRING D5d-JMM-1
13039: PPUSH
13040: CALL_OW 88
// DialogueOff ;
13044: CALL_OW 7
// end ;
13048: PPOPN 1
13050: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13051: LD_INT 1
13053: PPUSH
13054: LD_INT 17
13056: PPUSH
13057: CALL_OW 294
13061: PUSH
13062: LD_INT 2
13064: GREATEREQUAL
13065: IFFALSE 13186
13067: GO 13069
13069: DISABLE
13070: LD_INT 0
13072: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13073: LD_INT 10
13075: PPUSH
13076: LD_INT 5
13078: PPUSH
13079: LD_INT 1
13081: PPUSH
13082: LD_INT 10
13084: NEG
13085: PPUSH
13086: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13090: LD_INT 10
13092: PPUSH
13093: LD_INT 5
13095: PPUSH
13096: LD_INT 1
13098: PPUSH
13099: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
13103: LD_INT 10
13105: PPUSH
13106: LD_INT 5
13108: PPUSH
13109: CALL_OW 86
// DialogueOn ;
13113: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
13117: LD_ADDR_VAR 0 1
13121: PUSH
13122: LD_INT 1
13124: PPUSH
13125: LD_STRING D6-Sci1-1
13127: PPUSH
13128: CALL 15445 0 2
13132: ST_TO_ADDR
// if un then
13133: LD_VAR 0 1
13137: IFFALSE 13175
// begin Say ( JMM , D6-JMM-1 ) ;
13139: LD_EXP 21
13143: PPUSH
13144: LD_STRING D6-JMM-1
13146: PPUSH
13147: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
13151: LD_VAR 0 1
13155: PPUSH
13156: LD_STRING D6-Sci1-2
13158: PPUSH
13159: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
13163: LD_EXP 21
13167: PPUSH
13168: LD_STRING D6-JMM-2
13170: PPUSH
13171: CALL_OW 88
// end ; DialogueOff ;
13175: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
13179: LD_STRING M3
13181: PPUSH
13182: CALL_OW 337
// end ;
13186: PPOPN 1
13188: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp ;
13189: LD_OWVAR 1
13193: PUSH
13194: LD_INT 42000
13196: GREATEREQUAL
13197: PUSH
13198: LD_INT 2
13200: PPUSH
13201: LD_INT 169
13203: PPUSH
13204: LD_INT 90
13206: PPUSH
13207: LD_INT 10
13209: PPUSH
13210: CALL 51802 0 4
13214: PUSH
13215: LD_INT 4
13217: ARRAY
13218: PUSH
13219: LD_INT 0
13221: EQUAL
13222: PUSH
13223: LD_INT 45
13225: PPUSH
13226: CALL_OW 301
13230: OR
13231: PUSH
13232: LD_INT 45
13234: PPUSH
13235: CALL_OW 255
13239: PUSH
13240: LD_INT 1
13242: EQUAL
13243: OR
13244: AND
13245: PUSH
13246: LD_INT 94
13248: PPUSH
13249: CALL_OW 301
13253: NOT
13254: AND
13255: IFFALSE 14381
13257: GO 13259
13259: DISABLE
13260: LD_INT 0
13262: PPUSH
13263: PPUSH
13264: PPUSH
13265: PPUSH
// begin uc_side := 5 ;
13266: LD_ADDR_OWVAR 20
13270: PUSH
13271: LD_INT 5
13273: ST_TO_ADDR
// uc_nation := 2 ;
13274: LD_ADDR_OWVAR 21
13278: PUSH
13279: LD_INT 2
13281: ST_TO_ADDR
// InitHc ;
13282: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
13286: LD_INT 1
13288: PPUSH
13289: LD_INT 3
13291: PPUSH
13292: LD_INT 8
13294: PPUSH
13295: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13299: LD_ADDR_OWVAR 29
13303: PUSH
13304: LD_INT 12
13306: PUSH
13307: LD_INT 12
13309: PUSH
13310: EMPTY
13311: LIST
13312: LIST
13313: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
13314: LD_ADDR_OWVAR 33
13318: PUSH
13319: LD_STRING SecondCharsGal
13321: ST_TO_ADDR
// hc_face_number := 7 ;
13322: LD_ADDR_OWVAR 34
13326: PUSH
13327: LD_INT 7
13329: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
13330: LD_ADDR_EXP 46
13334: PUSH
13335: CALL_OW 44
13339: ST_TO_ADDR
// InitHc ;
13340: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
13344: LD_INT 1
13346: PPUSH
13347: LD_INT 16
13349: PPUSH
13350: LD_INT 2
13352: PPUSH
13353: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
13357: LD_ADDR_OWVAR 29
13361: PUSH
13362: LD_INT 12
13364: PUSH
13365: LD_INT 12
13367: PUSH
13368: EMPTY
13369: LIST
13370: LIST
13371: ST_TO_ADDR
// hc_name :=  ;
13372: LD_ADDR_OWVAR 26
13376: PUSH
13377: LD_STRING 
13379: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
13380: LD_ADDR_EXP 47
13384: PUSH
13385: CALL_OW 44
13389: ST_TO_ADDR
// InitHc ;
13390: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
13394: LD_INT 35
13396: PPUSH
13397: CALL_OW 67
// until not InBattle ( 1 ) ;
13401: LD_INT 1
13403: PPUSH
13404: CALL_OW 463
13408: NOT
13409: IFFALSE 13394
// wait ( 0 0$5 ) ;
13411: LD_INT 175
13413: PPUSH
13414: CALL_OW 67
// DialogueOn ;
13418: CALL_OW 6
// InGameOn ;
13422: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
13426: LD_ADDR_VAR 0 1
13430: PUSH
13431: LD_INT 22
13433: PUSH
13434: LD_INT 1
13436: PUSH
13437: EMPTY
13438: LIST
13439: LIST
13440: PUSH
13441: LD_INT 2
13443: PUSH
13444: LD_INT 25
13446: PUSH
13447: LD_INT 1
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PUSH
13454: LD_INT 25
13456: PUSH
13457: LD_INT 2
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 25
13466: PUSH
13467: LD_INT 3
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: LD_INT 25
13476: PUSH
13477: LD_INT 4
13479: PUSH
13480: EMPTY
13481: LIST
13482: LIST
13483: PUSH
13484: LD_INT 25
13486: PUSH
13487: LD_INT 5
13489: PUSH
13490: EMPTY
13491: LIST
13492: LIST
13493: PUSH
13494: LD_INT 25
13496: PUSH
13497: LD_INT 8
13499: PUSH
13500: EMPTY
13501: LIST
13502: LIST
13503: PUSH
13504: EMPTY
13505: LIST
13506: LIST
13507: LIST
13508: LIST
13509: LIST
13510: LIST
13511: LIST
13512: PUSH
13513: EMPTY
13514: LIST
13515: LIST
13516: PPUSH
13517: CALL_OW 69
13521: PUSH
13522: LD_EXP 21
13526: PUSH
13527: LD_EXP 22
13531: PUSH
13532: LD_EXP 23
13536: PUSH
13537: LD_EXP 24
13541: PUSH
13542: LD_EXP 25
13546: PUSH
13547: LD_EXP 26
13551: PUSH
13552: LD_EXP 27
13556: PUSH
13557: LD_EXP 28
13561: PUSH
13562: LD_EXP 29
13566: PUSH
13567: LD_EXP 31
13571: PUSH
13572: LD_EXP 32
13576: PUSH
13577: LD_EXP 33
13581: PUSH
13582: LD_EXP 34
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: LIST
13591: LIST
13592: LIST
13593: LIST
13594: LIST
13595: LIST
13596: LIST
13597: LIST
13598: LIST
13599: LIST
13600: LIST
13601: DIFF
13602: PPUSH
13603: LD_INT 26
13605: PUSH
13606: LD_INT 1
13608: PUSH
13609: EMPTY
13610: LIST
13611: LIST
13612: PPUSH
13613: CALL_OW 72
13617: PUSH
13618: LD_INT 1
13620: ARRAY
13621: ST_TO_ADDR
// if not un and Brown then
13622: LD_VAR 0 1
13626: NOT
13627: PUSH
13628: LD_EXP 27
13632: AND
13633: IFFALSE 13645
// un := Brown ;
13635: LD_ADDR_VAR 0 1
13639: PUSH
13640: LD_EXP 27
13644: ST_TO_ADDR
// if un then
13645: LD_VAR 0 1
13649: IFFALSE 13675
// begin Say ( un , D7-Sol1-1 ) ;
13651: LD_VAR 0 1
13655: PPUSH
13656: LD_STRING D7-Sol1-1
13658: PPUSH
13659: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
13663: LD_EXP 21
13667: PPUSH
13668: LD_STRING D7-JMM-1
13670: PPUSH
13671: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
13675: LD_EXP 46
13679: PPUSH
13680: LD_STRING D7-Ar1-1
13682: PPUSH
13683: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
13687: LD_EXP 21
13691: PPUSH
13692: LD_STRING D7-JMM-2
13694: PPUSH
13695: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
13699: LD_EXP 46
13703: PPUSH
13704: LD_STRING D7-Ar1-2
13706: PPUSH
13707: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
13711: LD_EXP 21
13715: PPUSH
13716: LD_STRING D7-JMM-3
13718: PPUSH
13719: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
13723: LD_EXP 46
13727: PPUSH
13728: LD_STRING D7-Ar1-3
13730: PPUSH
13731: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
13735: LD_EXP 21
13739: PPUSH
13740: LD_STRING D7-JMM-4
13742: PPUSH
13743: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
13747: LD_EXP 46
13751: PPUSH
13752: LD_STRING D7-Ar1-4
13754: PPUSH
13755: CALL_OW 94
// InGameOff ;
13759: CALL_OW 9
// DialogueOff ;
13763: CALL_OW 7
// case Query ( QCameras ) of 1 :
13767: LD_STRING QCameras
13769: PPUSH
13770: CALL_OW 97
13774: PUSH
13775: LD_INT 1
13777: DOUBLE
13778: EQUAL
13779: IFTRUE 13783
13781: GO 13786
13783: POP
// ; 2 :
13784: GO 13800
13786: LD_INT 2
13788: DOUBLE
13789: EQUAL
13790: IFTRUE 13794
13792: GO 13799
13794: POP
// exit ; end ;
13795: GO 14381
13797: GO 13800
13799: POP
// ChangeMissionObjectives ( MCar ) ;
13800: LD_STRING MCar
13802: PPUSH
13803: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
13807: LD_INT 124
13809: PPUSH
13810: LD_INT 90
13812: PPUSH
13813: LD_INT 1
13815: PPUSH
13816: LD_INT 6
13818: NEG
13819: PPUSH
13820: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
13824: LD_INT 124
13826: PPUSH
13827: LD_INT 90
13829: PPUSH
13830: LD_INT 1
13832: PPUSH
13833: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
13837: LD_INT 12
13839: PPUSH
13840: LD_INT 1
13842: PPUSH
13843: CALL_OW 424
// wait ( 3 ) ;
13847: LD_INT 3
13849: PPUSH
13850: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
13854: LD_INT 124
13856: PPUSH
13857: LD_INT 90
13859: PPUSH
13860: CALL_OW 86
// cargo := false ;
13864: LD_ADDR_VAR 0 3
13868: PUSH
13869: LD_INT 0
13871: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
13872: LD_INT 35
13874: PPUSH
13875: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
13879: LD_ADDR_VAR 0 3
13883: PUSH
13884: LD_INT 12
13886: PPUSH
13887: LD_INT 32
13889: PUSH
13890: LD_INT 3
13892: PUSH
13893: EMPTY
13894: LIST
13895: LIST
13896: PUSH
13897: LD_INT 34
13899: PUSH
13900: LD_INT 32
13902: PUSH
13903: EMPTY
13904: LIST
13905: LIST
13906: PUSH
13907: LD_INT 58
13909: PUSH
13910: EMPTY
13911: LIST
13912: PUSH
13913: EMPTY
13914: LIST
13915: LIST
13916: LIST
13917: PPUSH
13918: CALL_OW 70
13922: ST_TO_ADDR
// until cargo ;
13923: LD_VAR 0 3
13927: IFFALSE 13872
// cargo := cargo [ 1 ] ;
13929: LD_ADDR_VAR 0 3
13933: PUSH
13934: LD_VAR 0 3
13938: PUSH
13939: LD_INT 1
13941: ARRAY
13942: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
13943: LD_VAR 0 3
13947: PPUSH
13948: LD_INT 5
13950: PPUSH
13951: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
13955: LD_INT 12
13957: PPUSH
13958: LD_INT 0
13960: PPUSH
13961: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
13965: LD_EXP 46
13969: PPUSH
13970: LD_INT 11
13972: PPUSH
13973: LD_INT 0
13975: PPUSH
13976: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
13980: LD_EXP 47
13984: PPUSH
13985: LD_INT 11
13987: PPUSH
13988: LD_INT 0
13990: PPUSH
13991: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
13995: LD_EXP 46
13999: PUSH
14000: LD_EXP 47
14004: PUSH
14005: EMPTY
14006: LIST
14007: LIST
14008: PPUSH
14009: LD_INT 12
14011: PPUSH
14012: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14016: LD_EXP 46
14020: PPUSH
14021: LD_VAR 0 3
14025: PPUSH
14026: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14030: LD_EXP 46
14034: PUSH
14035: LD_EXP 47
14039: PUSH
14040: EMPTY
14041: LIST
14042: LIST
14043: PPUSH
14044: LD_INT 209
14046: PPUSH
14047: LD_INT 178
14049: PPUSH
14050: CALL_OW 171
// while ( true ) do
14054: LD_INT 1
14056: IFFALSE 14210
// begin wait ( 0 0$1 ) ;
14058: LD_INT 35
14060: PPUSH
14061: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14065: LD_EXP 46
14069: PPUSH
14070: CALL_OW 314
14074: NOT
14075: PUSH
14076: LD_EXP 47
14080: PPUSH
14081: CALL_OW 314
14085: NOT
14086: OR
14087: IFFALSE 14113
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14089: LD_EXP 46
14093: PUSH
14094: LD_EXP 47
14098: PUSH
14099: EMPTY
14100: LIST
14101: LIST
14102: PPUSH
14103: LD_INT 209
14105: PPUSH
14106: LD_INT 178
14108: PPUSH
14109: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
14113: LD_EXP 46
14117: PPUSH
14118: LD_INT 10
14120: PPUSH
14121: CALL_OW 308
14125: IFFALSE 14136
// RemoveUnit ( ar_mechanic ) ;
14127: LD_EXP 46
14131: PPUSH
14132: CALL_OW 64
// if IsInArea ( ar_mechanic_friend , escape_area ) then
14136: LD_EXP 47
14140: PPUSH
14141: LD_INT 10
14143: PPUSH
14144: CALL_OW 308
14148: IFFALSE 14159
// RemoveUnit ( ar_mechanic_friend ) ;
14150: LD_EXP 47
14154: PPUSH
14155: CALL_OW 64
// if IsInArea ( cargo , escape_area ) then
14159: LD_VAR 0 3
14163: PPUSH
14164: LD_INT 10
14166: PPUSH
14167: CALL_OW 308
14171: IFFALSE 14182
// RemoveUnit ( cargo ) ;
14173: LD_VAR 0 3
14177: PPUSH
14178: CALL_OW 64
// if not IsLive ( ar_mechanic ) and not IsLive ( ar_mechanic_friend ) then
14182: LD_EXP 46
14186: PPUSH
14187: CALL_OW 300
14191: NOT
14192: PUSH
14193: LD_EXP 47
14197: PPUSH
14198: CALL_OW 300
14202: NOT
14203: AND
14204: IFFALSE 14208
// break ;
14206: GO 14210
// end ;
14208: GO 14054
// wait ( 0 0$2 ) ;
14210: LD_INT 70
14212: PPUSH
14213: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
14217: LD_EXP 46
14221: PPUSH
14222: LD_STRING D7a-Ar1-1
14224: PPUSH
14225: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
14229: LD_ADDR_VAR 0 4
14233: PUSH
14234: LD_INT 129
14236: PUSH
14237: LD_INT 10
14239: PUSH
14240: EMPTY
14241: LIST
14242: LIST
14243: PUSH
14244: LD_INT 103
14246: PUSH
14247: LD_INT 6
14249: PUSH
14250: EMPTY
14251: LIST
14252: LIST
14253: PUSH
14254: LD_INT 148
14256: PUSH
14257: LD_INT 47
14259: PUSH
14260: EMPTY
14261: LIST
14262: LIST
14263: PUSH
14264: LD_INT 155
14266: PUSH
14267: LD_INT 16
14269: PUSH
14270: EMPTY
14271: LIST
14272: LIST
14273: PUSH
14274: EMPTY
14275: LIST
14276: LIST
14277: LIST
14278: LIST
14279: ST_TO_ADDR
// if Difficulty = 1 then
14280: LD_OWVAR 67
14284: PUSH
14285: LD_INT 1
14287: EQUAL
14288: IFFALSE 14325
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
14290: LD_ADDR_VAR 0 4
14294: PUSH
14295: LD_VAR 0 4
14299: PUSH
14300: LD_INT 78
14302: PUSH
14303: LD_INT 7
14305: PUSH
14306: EMPTY
14307: LIST
14308: LIST
14309: PUSH
14310: LD_INT 104
14312: PUSH
14313: LD_INT 43
14315: PUSH
14316: EMPTY
14317: LIST
14318: LIST
14319: PUSH
14320: EMPTY
14321: LIST
14322: LIST
14323: ADD
14324: ST_TO_ADDR
// for i in tmp do
14325: LD_ADDR_VAR 0 2
14329: PUSH
14330: LD_VAR 0 4
14334: PUSH
14335: FOR_IN
14336: IFFALSE 14369
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
14338: LD_VAR 0 2
14342: PUSH
14343: LD_INT 1
14345: ARRAY
14346: PPUSH
14347: LD_VAR 0 2
14351: PUSH
14352: LD_INT 2
14354: ARRAY
14355: PPUSH
14356: LD_INT 1
14358: PPUSH
14359: LD_INT 9
14361: NEG
14362: PPUSH
14363: CALL_OW 330
14367: GO 14335
14369: POP
14370: POP
// CenterOnXY ( 129 , 10 ) ;
14371: LD_INT 129
14373: PPUSH
14374: LD_INT 10
14376: PPUSH
14377: CALL_OW 84
// end ;
14381: PPOPN 4
14383: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
14384: LD_EXP 15
14388: PUSH
14389: LD_INT 21000
14391: MINUS
14392: PUSH
14393: LD_OWVAR 1
14397: LESSEQUAL
14398: IFFALSE 14438
14400: GO 14402
14402: DISABLE
// begin powell_warn := true ;
14403: LD_ADDR_EXP 16
14407: PUSH
14408: LD_INT 1
14410: ST_TO_ADDR
// DialogueOn ;
14411: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
14415: LD_EXP 30
14419: PPUSH
14420: LD_STRING D9-Pow-1
14422: PPUSH
14423: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
14427: LD_INT 10
14429: PPUSH
14430: CALL_OW 68
// DialogueOff ;
14434: CALL_OW 7
// end ;
14438: END
// every 0 0$1 trigger game_time <= tick do
14439: LD_EXP 15
14443: PUSH
14444: LD_OWVAR 1
14448: LESSEQUAL
14449: IFFALSE 14488
14451: GO 14453
14453: DISABLE
// begin DialogueOn ;
14454: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
14458: LD_EXP 30
14462: PPUSH
14463: LD_STRING D9a-Pow-1
14465: PPUSH
14466: CALL_OW 94
// dwait ( 0 0$2 ) ;
14470: LD_INT 70
14472: PPUSH
14473: CALL_OW 68
// DialogueOff ;
14477: CALL_OW 7
// YouLost ( Command ) ;
14481: LD_STRING Command
14483: PPUSH
14484: CALL_OW 104
// end ;
14488: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp ;
14489: LD_INT 22
14491: PUSH
14492: LD_INT 2
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: PUSH
14499: LD_INT 30
14501: PUSH
14502: LD_INT 1
14504: PUSH
14505: EMPTY
14506: LIST
14507: LIST
14508: PUSH
14509: EMPTY
14510: LIST
14511: LIST
14512: PPUSH
14513: CALL_OW 69
14517: PUSH
14518: LD_INT 0
14520: EQUAL
14521: PUSH
14522: LD_EXP 21
14526: PPUSH
14527: CALL_OW 302
14531: AND
14532: IFFALSE 15264
14534: GO 14536
14536: DISABLE
14537: LD_INT 0
14539: PPUSH
// begin if tick < [ 90 90$00 , 80 80$00 , 75 75$00 ] [ Difficulty ] then
14540: LD_OWVAR 1
14544: PUSH
14545: LD_INT 189000
14547: PUSH
14548: LD_INT 168000
14550: PUSH
14551: LD_INT 157500
14553: PUSH
14554: EMPTY
14555: LIST
14556: LIST
14557: LIST
14558: PUSH
14559: LD_OWVAR 67
14563: ARRAY
14564: LESS
14565: IFFALSE 14579
// AddMedal ( Time1 , 1 ) else
14567: LD_STRING Time1
14569: PPUSH
14570: LD_INT 1
14572: PPUSH
14573: CALL_OW 101
14577: GO 14610
// if not powell_warn then
14579: LD_EXP 16
14583: NOT
14584: IFFALSE 14599
// AddMedal ( Time1 , - 1 ) else
14586: LD_STRING Time1
14588: PPUSH
14589: LD_INT 1
14591: NEG
14592: PPUSH
14593: CALL_OW 101
14597: GO 14610
// AddMedal ( Time1 , - 2 ) ;
14599: LD_STRING Time1
14601: PPUSH
14602: LD_INT 2
14604: NEG
14605: PPUSH
14606: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
14610: LD_EXP 17
14614: PUSH
14615: LD_INT 5
14617: PUSH
14618: LD_INT 4
14620: PUSH
14621: LD_INT 3
14623: PUSH
14624: EMPTY
14625: LIST
14626: LIST
14627: LIST
14628: PUSH
14629: LD_OWVAR 67
14633: ARRAY
14634: GREATEREQUAL
14635: IFFALSE 14650
// AddMedal ( Destroy , - 2 ) else
14637: LD_STRING Destroy
14639: PPUSH
14640: LD_INT 2
14642: NEG
14643: PPUSH
14644: CALL_OW 101
14648: GO 14767
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
14650: LD_INT 22
14652: PUSH
14653: LD_INT 2
14655: PUSH
14656: EMPTY
14657: LIST
14658: LIST
14659: PUSH
14660: LD_INT 21
14662: PUSH
14663: LD_INT 3
14665: PUSH
14666: EMPTY
14667: LIST
14668: LIST
14669: PUSH
14670: LD_INT 50
14672: PUSH
14673: EMPTY
14674: LIST
14675: PUSH
14676: EMPTY
14677: LIST
14678: LIST
14679: LIST
14680: PPUSH
14681: CALL_OW 69
14685: PUSH
14686: LD_INT 25
14688: GREATEREQUAL
14689: IFFALSE 14704
// AddMedal ( Destroy , - 1 ) else
14691: LD_STRING Destroy
14693: PPUSH
14694: LD_INT 1
14696: NEG
14697: PPUSH
14698: CALL_OW 101
14702: GO 14767
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
14704: LD_INT 22
14706: PUSH
14707: LD_INT 2
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: PUSH
14714: LD_INT 21
14716: PUSH
14717: LD_INT 3
14719: PUSH
14720: EMPTY
14721: LIST
14722: LIST
14723: PUSH
14724: LD_INT 50
14726: PUSH
14727: EMPTY
14728: LIST
14729: PUSH
14730: EMPTY
14731: LIST
14732: LIST
14733: LIST
14734: PPUSH
14735: CALL_OW 69
14739: PUSH
14740: LD_INT 15
14742: GREATEREQUAL
14743: IFFALSE 14757
// AddMedal ( Destroy , 1 ) else
14745: LD_STRING Destroy
14747: PPUSH
14748: LD_INT 1
14750: PPUSH
14751: CALL_OW 101
14755: GO 14767
// AddMedal ( Destroy , 2 ) ;
14757: LD_STRING Destroy
14759: PPUSH
14760: LD_INT 2
14762: PPUSH
14763: CALL_OW 101
// SaveVariable ( artifact_get , 11_artifact_captured ) ;
14767: LD_EXP 13
14771: PPUSH
14772: LD_STRING 11_artifact_captured
14774: PPUSH
14775: CALL_OW 39
// if artifact_get then
14779: LD_EXP 13
14783: IFFALSE 14797
// AddMedal ( Artefact , 1 ) else
14785: LD_STRING Artefact
14787: PPUSH
14788: LD_INT 1
14790: PPUSH
14791: CALL_OW 101
14795: GO 14808
// AddMedal ( Artefact , - 1 ) ;
14797: LD_STRING Artefact
14799: PPUSH
14800: LD_INT 1
14802: NEG
14803: PPUSH
14804: CALL_OW 101
// GiveMedals ( MAIN ) ;
14808: LD_STRING MAIN
14810: PPUSH
14811: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
14815: LD_ADDR_EXP 20
14819: PUSH
14820: LD_EXP 20
14824: PPUSH
14825: LD_INT 51
14827: PUSH
14828: EMPTY
14829: LIST
14830: PPUSH
14831: CALL_OW 72
14835: ST_TO_ADDR
// tmp := JMM ^ selected ;
14836: LD_ADDR_VAR 0 1
14840: PUSH
14841: LD_EXP 21
14845: PUSH
14846: LD_EXP 20
14850: ADD
14851: ST_TO_ADDR
// RewardPeople ( tmp ) ;
14852: LD_VAR 0 1
14856: PPUSH
14857: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
14861: LD_VAR 0 1
14865: PUSH
14866: LD_EXP 21
14870: PUSH
14871: LD_EXP 22
14875: PUSH
14876: LD_EXP 23
14880: PUSH
14881: LD_EXP 24
14885: PUSH
14886: LD_EXP 25
14890: PUSH
14891: LD_EXP 26
14895: PUSH
14896: LD_EXP 27
14900: PUSH
14901: LD_EXP 28
14905: PUSH
14906: LD_EXP 29
14910: PUSH
14911: LD_EXP 31
14915: PUSH
14916: LD_EXP 32
14920: PUSH
14921: LD_EXP 33
14925: PUSH
14926: LD_EXP 34
14930: PUSH
14931: EMPTY
14932: LIST
14933: LIST
14934: LIST
14935: LIST
14936: LIST
14937: LIST
14938: LIST
14939: LIST
14940: LIST
14941: LIST
14942: LIST
14943: LIST
14944: LIST
14945: DIFF
14946: PPUSH
14947: LD_STRING 11c_others
14949: PPUSH
14950: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
14954: LD_EXP 21
14958: PPUSH
14959: LD_EXP 3
14963: PUSH
14964: LD_STRING JMM
14966: STR
14967: PPUSH
14968: CALL_OW 38
// if Lisa then
14972: LD_EXP 22
14976: IFFALSE 14996
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
14978: LD_EXP 22
14982: PPUSH
14983: LD_EXP 3
14987: PUSH
14988: LD_STRING Lisa
14990: STR
14991: PPUSH
14992: CALL_OW 38
// if Donaldson then
14996: LD_EXP 23
15000: IFFALSE 15020
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
15002: LD_EXP 23
15006: PPUSH
15007: LD_EXP 3
15011: PUSH
15012: LD_STRING Donaldson
15014: STR
15015: PPUSH
15016: CALL_OW 38
// if Bobby then
15020: LD_EXP 24
15024: IFFALSE 15044
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
15026: LD_EXP 24
15030: PPUSH
15031: LD_EXP 3
15035: PUSH
15036: LD_STRING Bobby
15038: STR
15039: PPUSH
15040: CALL_OW 38
// if Cyrus then
15044: LD_EXP 25
15048: IFFALSE 15068
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
15050: LD_EXP 25
15054: PPUSH
15055: LD_EXP 3
15059: PUSH
15060: LD_STRING Cyrus
15062: STR
15063: PPUSH
15064: CALL_OW 38
// if Denis then
15068: LD_EXP 26
15072: IFFALSE 15092
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
15074: LD_EXP 26
15078: PPUSH
15079: LD_EXP 3
15083: PUSH
15084: LD_STRING Denis
15086: STR
15087: PPUSH
15088: CALL_OW 38
// if Brown then
15092: LD_EXP 27
15096: IFFALSE 15116
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
15098: LD_EXP 27
15102: PPUSH
15103: LD_EXP 3
15107: PUSH
15108: LD_STRING Brown
15110: STR
15111: PPUSH
15112: CALL_OW 38
// if Gladstone then
15116: LD_EXP 28
15120: IFFALSE 15140
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
15122: LD_EXP 28
15126: PPUSH
15127: LD_EXP 3
15131: PUSH
15132: LD_STRING Gladstone
15134: STR
15135: PPUSH
15136: CALL_OW 38
// if Houten then
15140: LD_EXP 29
15144: IFFALSE 15164
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
15146: LD_EXP 29
15150: PPUSH
15151: LD_EXP 3
15155: PUSH
15156: LD_STRING Houten
15158: STR
15159: PPUSH
15160: CALL_OW 38
// if Cornel then
15164: LD_EXP 31
15168: IFFALSE 15188
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
15170: LD_EXP 31
15174: PPUSH
15175: LD_EXP 3
15179: PUSH
15180: LD_STRING Cornel
15182: STR
15183: PPUSH
15184: CALL_OW 38
// if Gary then
15188: LD_EXP 32
15192: IFFALSE 15212
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
15194: LD_EXP 32
15198: PPUSH
15199: LD_EXP 3
15203: PUSH
15204: LD_STRING Gary
15206: STR
15207: PPUSH
15208: CALL_OW 38
// if Frank then
15212: LD_EXP 33
15216: IFFALSE 15236
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
15218: LD_EXP 33
15222: PPUSH
15223: LD_EXP 3
15227: PUSH
15228: LD_STRING Frank
15230: STR
15231: PPUSH
15232: CALL_OW 38
// if Kikuchi then
15236: LD_EXP 34
15240: IFFALSE 15260
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
15242: LD_EXP 34
15246: PPUSH
15247: LD_EXP 3
15251: PUSH
15252: LD_STRING Kikuchi
15254: STR
15255: PPUSH
15256: CALL_OW 38
// YouWin ;
15260: CALL_OW 103
// end ;
15264: PPOPN 1
15266: END
// export function CanSayRand ( side ) ; begin
15267: LD_INT 0
15269: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15270: LD_ADDR_VAR 0 2
15274: PUSH
15275: LD_INT 52
15277: PUSH
15278: EMPTY
15279: LIST
15280: PUSH
15281: LD_INT 22
15283: PUSH
15284: LD_VAR 0 1
15288: PUSH
15289: EMPTY
15290: LIST
15291: LIST
15292: PUSH
15293: LD_INT 2
15295: PUSH
15296: LD_INT 25
15298: PUSH
15299: LD_INT 1
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: PUSH
15306: LD_INT 25
15308: PUSH
15309: LD_INT 2
15311: PUSH
15312: EMPTY
15313: LIST
15314: LIST
15315: PUSH
15316: LD_INT 25
15318: PUSH
15319: LD_INT 3
15321: PUSH
15322: EMPTY
15323: LIST
15324: LIST
15325: PUSH
15326: LD_INT 25
15328: PUSH
15329: LD_INT 4
15331: PUSH
15332: EMPTY
15333: LIST
15334: LIST
15335: PUSH
15336: EMPTY
15337: LIST
15338: LIST
15339: LIST
15340: LIST
15341: LIST
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: LIST
15347: PPUSH
15348: CALL_OW 69
15352: PUSH
15353: LD_EXP 21
15357: PUSH
15358: LD_EXP 33
15362: PUSH
15363: LD_EXP 22
15367: PUSH
15368: LD_EXP 23
15372: PUSH
15373: LD_EXP 24
15377: PUSH
15378: LD_EXP 25
15382: PUSH
15383: LD_EXP 26
15387: PUSH
15388: LD_EXP 27
15392: PUSH
15393: LD_EXP 28
15397: PUSH
15398: LD_EXP 29
15402: PUSH
15403: LD_EXP 30
15407: PUSH
15408: LD_EXP 31
15412: PUSH
15413: LD_EXP 32
15417: PUSH
15418: LD_EXP 34
15422: PUSH
15423: EMPTY
15424: LIST
15425: LIST
15426: LIST
15427: LIST
15428: LIST
15429: LIST
15430: LIST
15431: LIST
15432: LIST
15433: LIST
15434: LIST
15435: LIST
15436: LIST
15437: LIST
15438: DIFF
15439: ST_TO_ADDR
// end ;
15440: LD_VAR 0 2
15444: RET
// export function SayRand ( sex , dial ) ; begin
15445: LD_INT 0
15447: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
15448: LD_ADDR_VAR 0 3
15452: PUSH
15453: LD_INT 52
15455: PUSH
15456: EMPTY
15457: LIST
15458: PUSH
15459: LD_INT 22
15461: PUSH
15462: LD_INT 1
15464: PUSH
15465: EMPTY
15466: LIST
15467: LIST
15468: PUSH
15469: LD_INT 26
15471: PUSH
15472: LD_VAR 0 1
15476: PUSH
15477: EMPTY
15478: LIST
15479: LIST
15480: PUSH
15481: LD_INT 2
15483: PUSH
15484: LD_INT 25
15486: PUSH
15487: LD_INT 1
15489: PUSH
15490: EMPTY
15491: LIST
15492: LIST
15493: PUSH
15494: LD_INT 25
15496: PUSH
15497: LD_INT 2
15499: PUSH
15500: EMPTY
15501: LIST
15502: LIST
15503: PUSH
15504: LD_INT 25
15506: PUSH
15507: LD_INT 3
15509: PUSH
15510: EMPTY
15511: LIST
15512: LIST
15513: PUSH
15514: LD_INT 25
15516: PUSH
15517: LD_INT 4
15519: PUSH
15520: EMPTY
15521: LIST
15522: LIST
15523: PUSH
15524: EMPTY
15525: LIST
15526: LIST
15527: LIST
15528: LIST
15529: LIST
15530: PUSH
15531: EMPTY
15532: LIST
15533: LIST
15534: LIST
15535: LIST
15536: PPUSH
15537: CALL_OW 69
15541: PUSH
15542: LD_EXP 21
15546: PUSH
15547: LD_EXP 33
15551: PUSH
15552: LD_EXP 22
15556: PUSH
15557: LD_EXP 23
15561: PUSH
15562: LD_EXP 24
15566: PUSH
15567: LD_EXP 25
15571: PUSH
15572: LD_EXP 26
15576: PUSH
15577: LD_EXP 27
15581: PUSH
15582: LD_EXP 28
15586: PUSH
15587: LD_EXP 29
15591: PUSH
15592: LD_EXP 30
15596: PUSH
15597: LD_EXP 31
15601: PUSH
15602: LD_EXP 32
15606: PUSH
15607: LD_EXP 34
15611: PUSH
15612: EMPTY
15613: LIST
15614: LIST
15615: LIST
15616: LIST
15617: LIST
15618: LIST
15619: LIST
15620: LIST
15621: LIST
15622: LIST
15623: LIST
15624: LIST
15625: LIST
15626: LIST
15627: DIFF
15628: ST_TO_ADDR
// if not result then
15629: LD_VAR 0 3
15633: NOT
15634: IFFALSE 15638
// exit ;
15636: GO 15666
// result := result [ 1 ] ;
15638: LD_ADDR_VAR 0 3
15642: PUSH
15643: LD_VAR 0 3
15647: PUSH
15648: LD_INT 1
15650: ARRAY
15651: ST_TO_ADDR
// Say ( result , dial ) ;
15652: LD_VAR 0 3
15656: PPUSH
15657: LD_VAR 0 2
15661: PPUSH
15662: CALL_OW 88
// end ;
15666: LD_VAR 0 3
15670: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
15671: LD_INT 0
15673: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
15674: LD_ADDR_VAR 0 4
15678: PUSH
15679: LD_INT 22
15681: PUSH
15682: LD_INT 1
15684: PUSH
15685: EMPTY
15686: LIST
15687: LIST
15688: PUSH
15689: LD_INT 26
15691: PUSH
15692: LD_VAR 0 1
15696: PUSH
15697: EMPTY
15698: LIST
15699: LIST
15700: PUSH
15701: LD_INT 2
15703: PUSH
15704: LD_INT 25
15706: PUSH
15707: LD_INT 1
15709: PUSH
15710: EMPTY
15711: LIST
15712: LIST
15713: PUSH
15714: LD_INT 25
15716: PUSH
15717: LD_INT 2
15719: PUSH
15720: EMPTY
15721: LIST
15722: LIST
15723: PUSH
15724: LD_INT 25
15726: PUSH
15727: LD_INT 3
15729: PUSH
15730: EMPTY
15731: LIST
15732: LIST
15733: PUSH
15734: LD_INT 25
15736: PUSH
15737: LD_INT 4
15739: PUSH
15740: EMPTY
15741: LIST
15742: LIST
15743: PUSH
15744: EMPTY
15745: LIST
15746: LIST
15747: LIST
15748: LIST
15749: LIST
15750: PUSH
15751: EMPTY
15752: LIST
15753: LIST
15754: LIST
15755: PPUSH
15756: CALL_OW 69
15760: PUSH
15761: LD_EXP 21
15765: PUSH
15766: LD_EXP 33
15770: PUSH
15771: LD_EXP 22
15775: PUSH
15776: LD_EXP 23
15780: PUSH
15781: LD_EXP 24
15785: PUSH
15786: LD_EXP 25
15790: PUSH
15791: LD_EXP 26
15795: PUSH
15796: LD_EXP 27
15800: PUSH
15801: LD_EXP 28
15805: PUSH
15806: LD_EXP 29
15810: PUSH
15811: LD_EXP 30
15815: PUSH
15816: LD_EXP 31
15820: PUSH
15821: LD_EXP 32
15825: PUSH
15826: LD_EXP 34
15830: PUSH
15831: EMPTY
15832: LIST
15833: LIST
15834: LIST
15835: LIST
15836: LIST
15837: LIST
15838: LIST
15839: LIST
15840: LIST
15841: LIST
15842: LIST
15843: LIST
15844: LIST
15845: LIST
15846: PUSH
15847: LD_VAR 0 3
15851: ADD
15852: DIFF
15853: ST_TO_ADDR
// if not result then
15854: LD_VAR 0 4
15858: NOT
15859: IFFALSE 15863
// exit ;
15861: GO 15891
// result := result [ 1 ] ;
15863: LD_ADDR_VAR 0 4
15867: PUSH
15868: LD_VAR 0 4
15872: PUSH
15873: LD_INT 1
15875: ARRAY
15876: ST_TO_ADDR
// Say ( result , dial ) ;
15877: LD_VAR 0 4
15881: PPUSH
15882: LD_VAR 0 2
15886: PPUSH
15887: CALL_OW 88
// end ; end_of_file
15891: LD_VAR 0 4
15895: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
15896: LD_VAR 0 1
15900: PPUSH
15901: CALL_OW 255
15905: PUSH
15906: LD_INT 1
15908: EQUAL
15909: IFFALSE 15919
// artifact_get := true ;
15911: LD_ADDR_EXP 13
15915: PUSH
15916: LD_INT 1
15918: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
15919: LD_VAR 0 1
15923: PPUSH
15924: CALL_OW 255
15928: PUSH
15929: LD_INT 2
15931: EQUAL
15932: IFFALSE 15950
// begin artifact_get := false ;
15934: LD_ADDR_EXP 13
15938: PUSH
15939: LD_INT 0
15941: ST_TO_ADDR
// artifact_stolen := true ;
15942: LD_ADDR_EXP 12
15946: PUSH
15947: LD_INT 1
15949: ST_TO_ADDR
// end ; artifact_oncargo := true ;
15950: LD_ADDR_EXP 14
15954: PUSH
15955: LD_INT 1
15957: ST_TO_ADDR
// end ;
15958: PPOPN 2
15960: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
15961: LD_ADDR_EXP 14
15965: PUSH
15966: LD_INT 0
15968: ST_TO_ADDR
// end ;
15969: PPOPN 2
15971: END
// on UnitDestroyed ( un ) do begin if un = JMM then
15972: LD_VAR 0 1
15976: PUSH
15977: LD_EXP 21
15981: EQUAL
15982: IFFALSE 15993
// begin YouLost ( JMM ) ;
15984: LD_STRING JMM
15986: PPUSH
15987: CALL_OW 104
// exit ;
15991: GO 16125
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
15993: LD_VAR 0 1
15997: PUSH
15998: LD_INT 22
16000: PUSH
16001: LD_INT 1
16003: PUSH
16004: EMPTY
16005: LIST
16006: LIST
16007: PUSH
16008: LD_INT 21
16010: PUSH
16011: LD_INT 1
16013: PUSH
16014: EMPTY
16015: LIST
16016: LIST
16017: PUSH
16018: LD_INT 2
16020: PUSH
16021: LD_INT 25
16023: PUSH
16024: LD_INT 1
16026: PUSH
16027: EMPTY
16028: LIST
16029: LIST
16030: PUSH
16031: LD_INT 25
16033: PUSH
16034: LD_INT 2
16036: PUSH
16037: EMPTY
16038: LIST
16039: LIST
16040: PUSH
16041: LD_INT 25
16043: PUSH
16044: LD_INT 3
16046: PUSH
16047: EMPTY
16048: LIST
16049: LIST
16050: PUSH
16051: LD_INT 25
16053: PUSH
16054: LD_INT 4
16056: PUSH
16057: EMPTY
16058: LIST
16059: LIST
16060: PUSH
16061: LD_INT 25
16063: PUSH
16064: LD_INT 5
16066: PUSH
16067: EMPTY
16068: LIST
16069: LIST
16070: PUSH
16071: LD_INT 25
16073: PUSH
16074: LD_INT 8
16076: PUSH
16077: EMPTY
16078: LIST
16079: LIST
16080: PUSH
16081: EMPTY
16082: LIST
16083: LIST
16084: LIST
16085: LIST
16086: LIST
16087: LIST
16088: LIST
16089: PUSH
16090: EMPTY
16091: LIST
16092: LIST
16093: LIST
16094: PPUSH
16095: CALL_OW 69
16099: IN
16100: IFFALSE 16116
// loses_counter := loses_counter + 1 ;
16102: LD_ADDR_EXP 17
16106: PUSH
16107: LD_EXP 17
16111: PUSH
16112: LD_INT 1
16114: PLUS
16115: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
16116: LD_VAR 0 1
16120: PPUSH
16121: CALL 41636 0 1
// end ;
16125: PPOPN 1
16127: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16128: LD_VAR 0 1
16132: PPUSH
16133: LD_VAR 0 2
16137: PPUSH
16138: CALL 43521 0 2
// end ;
16142: PPOPN 2
16144: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
16145: LD_VAR 0 1
16149: PPUSH
16150: CALL 42837 0 1
// end ;
16154: PPOPN 1
16156: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16157: LD_VAR 0 1
16161: PPUSH
16162: LD_VAR 0 2
16166: PPUSH
16167: LD_VAR 0 3
16171: PPUSH
16172: LD_VAR 0 4
16176: PPUSH
16177: LD_VAR 0 5
16181: PPUSH
16182: CALL 40975 0 5
// end ;
16186: PPOPN 5
16188: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
16189: LD_VAR 0 1
16193: PPUSH
16194: LD_VAR 0 2
16198: PPUSH
16199: CALL 40572 0 2
// end ;
16203: PPOPN 2
16205: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
16206: LD_VAR 0 1
16210: PPUSH
16211: CALL_OW 247
16215: PUSH
16216: LD_INT 2
16218: EQUAL
16219: IFFALSE 16223
// exit ;
16221: GO 16240
// if not kamikazed then
16223: LD_EXP 11
16227: NOT
16228: IFFALSE 16240
// kamikazed := unit ;
16230: LD_ADDR_EXP 11
16234: PUSH
16235: LD_VAR 0 1
16239: ST_TO_ADDR
// end ;
16240: PPOPN 1
16242: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
16243: LD_INT 0
16245: PPUSH
16246: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
16247: LD_VAR 0 1
16251: PPUSH
16252: LD_VAR 0 2
16256: PPUSH
16257: LD_VAR 0 3
16261: PPUSH
16262: LD_VAR 0 4
16266: PPUSH
16267: CALL 40417 0 4
// end ;
16271: PPOPN 6
16273: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
16274: LD_VAR 0 1
16278: PPUSH
16279: LD_VAR 0 2
16283: PPUSH
16284: LD_VAR 0 3
16288: PPUSH
16289: CALL 40199 0 3
// end ;
16293: PPOPN 3
16295: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
16296: LD_VAR 0 1
16300: PPUSH
16301: LD_VAR 0 2
16305: PPUSH
16306: CALL 41348 0 2
// end ;
16310: PPOPN 2
16312: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
16313: LD_VAR 0 1
16317: PPUSH
16318: LD_VAR 0 2
16322: PPUSH
16323: CALL 39907 0 2
// end ;
16327: PPOPN 2
16329: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
16330: LD_VAR 0 1
16334: PPUSH
16335: LD_VAR 0 2
16339: PPUSH
16340: CALL 40091 0 2
// end ;
16344: PPOPN 2
16346: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
16347: LD_VAR 0 1
16351: PPUSH
16352: CALL 42603 0 1
// end ;
16356: PPOPN 1
16358: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
16359: LD_VAR 0 1
16363: PPUSH
16364: LD_VAR 0 2
16368: PPUSH
16369: CALL 43775 0 2
// end ;
16373: PPOPN 2
16375: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
16376: LD_VAR 0 1
16380: PPUSH
16381: LD_VAR 0 2
16385: PPUSH
16386: LD_VAR 0 3
16390: PPUSH
16391: LD_VAR 0 4
16395: PPUSH
16396: CALL 43984 0 4
// end ; end_of_file
16400: PPOPN 4
16402: END
// every 0 0$1 trigger game do
16403: LD_EXP 2
16407: IFFALSE 16437
16409: GO 16411
16411: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
16412: LD_INT 7
16414: PUSH
16415: LD_INT 6
16417: PUSH
16418: LD_INT 4
16420: PUSH
16421: LD_INT 6
16423: PUSH
16424: EMPTY
16425: LIST
16426: LIST
16427: LIST
16428: LIST
16429: PPUSH
16430: LD_INT 1750
16432: PPUSH
16433: CALL 16438 0 2
16437: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
16438: LD_INT 0
16440: PPUSH
16441: PPUSH
16442: PPUSH
// if not areas then
16443: LD_VAR 0 1
16447: NOT
16448: IFFALSE 16452
// exit ;
16450: GO 16582
// repeat wait ( time ) ;
16452: LD_VAR 0 2
16456: PPUSH
16457: CALL_OW 67
// p := rand ( 1 , 90 ) ;
16461: LD_ADDR_VAR 0 5
16465: PUSH
16466: LD_INT 1
16468: PPUSH
16469: LD_INT 90
16471: PPUSH
16472: CALL_OW 12
16476: ST_TO_ADDR
// for i in areas do
16477: LD_ADDR_VAR 0 4
16481: PUSH
16482: LD_VAR 0 1
16486: PUSH
16487: FOR_IN
16488: IFFALSE 16541
// begin if Prob ( p ) then
16490: LD_VAR 0 5
16494: PPUSH
16495: CALL_OW 13
16499: IFFALSE 16539
// begin CreateCratesArea ( rand ( 1 , 5 ) , i , true ) ;
16501: LD_INT 1
16503: PPUSH
16504: LD_INT 5
16506: PPUSH
16507: CALL_OW 12
16511: PPUSH
16512: LD_VAR 0 4
16516: PPUSH
16517: LD_INT 1
16519: PPUSH
16520: CALL_OW 55
// wait ( rand ( 0 0$11 , 0 0$17 ) ) ;
16524: LD_INT 385
16526: PPUSH
16527: LD_INT 595
16529: PPUSH
16530: CALL_OW 12
16534: PPUSH
16535: CALL_OW 67
// end ; end ;
16539: GO 16487
16541: POP
16542: POP
// time := time + 0 0$3 ;
16543: LD_ADDR_VAR 0 2
16547: PUSH
16548: LD_VAR 0 2
16552: PUSH
16553: LD_INT 105
16555: PLUS
16556: ST_TO_ADDR
// if time > 7 7$00 then
16557: LD_VAR 0 2
16561: PUSH
16562: LD_INT 14700
16564: GREATER
16565: IFFALSE 16575
// time := 0 0$40 ;
16567: LD_ADDR_VAR 0 2
16571: PUSH
16572: LD_INT 1400
16574: ST_TO_ADDR
// until not game ;
16575: LD_EXP 2
16579: NOT
16580: IFFALSE 16452
// end ; end_of_file
16582: LD_VAR 0 3
16586: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
16587: LD_INT 0
16589: PPUSH
16590: PPUSH
// skirmish := false ;
16591: LD_ADDR_EXP 48
16595: PUSH
16596: LD_INT 0
16598: ST_TO_ADDR
// debug_mc := false ;
16599: LD_ADDR_EXP 49
16603: PUSH
16604: LD_INT 0
16606: ST_TO_ADDR
// mc_bases := [ ] ;
16607: LD_ADDR_EXP 50
16611: PUSH
16612: EMPTY
16613: ST_TO_ADDR
// mc_sides := [ ] ;
16614: LD_ADDR_EXP 76
16618: PUSH
16619: EMPTY
16620: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
16621: LD_ADDR_EXP 51
16625: PUSH
16626: EMPTY
16627: ST_TO_ADDR
// mc_building_repairs := [ ] ;
16628: LD_ADDR_EXP 52
16632: PUSH
16633: EMPTY
16634: ST_TO_ADDR
// mc_need_heal := [ ] ;
16635: LD_ADDR_EXP 53
16639: PUSH
16640: EMPTY
16641: ST_TO_ADDR
// mc_healers := [ ] ;
16642: LD_ADDR_EXP 54
16646: PUSH
16647: EMPTY
16648: ST_TO_ADDR
// mc_build_list := [ ] ;
16649: LD_ADDR_EXP 55
16653: PUSH
16654: EMPTY
16655: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
16656: LD_ADDR_EXP 82
16660: PUSH
16661: EMPTY
16662: ST_TO_ADDR
// mc_builders := [ ] ;
16663: LD_ADDR_EXP 56
16667: PUSH
16668: EMPTY
16669: ST_TO_ADDR
// mc_construct_list := [ ] ;
16670: LD_ADDR_EXP 57
16674: PUSH
16675: EMPTY
16676: ST_TO_ADDR
// mc_turret_list := [ ] ;
16677: LD_ADDR_EXP 58
16681: PUSH
16682: EMPTY
16683: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
16684: LD_ADDR_EXP 59
16688: PUSH
16689: EMPTY
16690: ST_TO_ADDR
// mc_miners := [ ] ;
16691: LD_ADDR_EXP 64
16695: PUSH
16696: EMPTY
16697: ST_TO_ADDR
// mc_mines := [ ] ;
16698: LD_ADDR_EXP 63
16702: PUSH
16703: EMPTY
16704: ST_TO_ADDR
// mc_minefields := [ ] ;
16705: LD_ADDR_EXP 65
16709: PUSH
16710: EMPTY
16711: ST_TO_ADDR
// mc_crates := [ ] ;
16712: LD_ADDR_EXP 66
16716: PUSH
16717: EMPTY
16718: ST_TO_ADDR
// mc_crates_collector := [ ] ;
16719: LD_ADDR_EXP 67
16723: PUSH
16724: EMPTY
16725: ST_TO_ADDR
// mc_crates_area := [ ] ;
16726: LD_ADDR_EXP 68
16730: PUSH
16731: EMPTY
16732: ST_TO_ADDR
// mc_vehicles := [ ] ;
16733: LD_ADDR_EXP 69
16737: PUSH
16738: EMPTY
16739: ST_TO_ADDR
// mc_attack := [ ] ;
16740: LD_ADDR_EXP 70
16744: PUSH
16745: EMPTY
16746: ST_TO_ADDR
// mc_produce := [ ] ;
16747: LD_ADDR_EXP 71
16751: PUSH
16752: EMPTY
16753: ST_TO_ADDR
// mc_defender := [ ] ;
16754: LD_ADDR_EXP 72
16758: PUSH
16759: EMPTY
16760: ST_TO_ADDR
// mc_parking := [ ] ;
16761: LD_ADDR_EXP 74
16765: PUSH
16766: EMPTY
16767: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
16768: LD_ADDR_EXP 60
16772: PUSH
16773: EMPTY
16774: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
16775: LD_ADDR_EXP 62
16779: PUSH
16780: EMPTY
16781: ST_TO_ADDR
// mc_scan := [ ] ;
16782: LD_ADDR_EXP 73
16786: PUSH
16787: EMPTY
16788: ST_TO_ADDR
// mc_scan_area := [ ] ;
16789: LD_ADDR_EXP 75
16793: PUSH
16794: EMPTY
16795: ST_TO_ADDR
// mc_tech := [ ] ;
16796: LD_ADDR_EXP 77
16800: PUSH
16801: EMPTY
16802: ST_TO_ADDR
// mc_class := [ ] ;
16803: LD_ADDR_EXP 91
16807: PUSH
16808: EMPTY
16809: ST_TO_ADDR
// mc_class_case_use := [ ] ;
16810: LD_ADDR_EXP 92
16814: PUSH
16815: EMPTY
16816: ST_TO_ADDR
// end ;
16817: LD_VAR 0 1
16821: RET
// export function MC_Kill ( base ) ; begin
16822: LD_INT 0
16824: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
16825: LD_ADDR_EXP 50
16829: PUSH
16830: LD_EXP 50
16834: PPUSH
16835: LD_VAR 0 1
16839: PPUSH
16840: EMPTY
16841: PPUSH
16842: CALL_OW 1
16846: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
16847: LD_ADDR_EXP 51
16851: PUSH
16852: LD_EXP 51
16856: PPUSH
16857: LD_VAR 0 1
16861: PPUSH
16862: EMPTY
16863: PPUSH
16864: CALL_OW 1
16868: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
16869: LD_ADDR_EXP 52
16873: PUSH
16874: LD_EXP 52
16878: PPUSH
16879: LD_VAR 0 1
16883: PPUSH
16884: EMPTY
16885: PPUSH
16886: CALL_OW 1
16890: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
16891: LD_ADDR_EXP 53
16895: PUSH
16896: LD_EXP 53
16900: PPUSH
16901: LD_VAR 0 1
16905: PPUSH
16906: EMPTY
16907: PPUSH
16908: CALL_OW 1
16912: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
16913: LD_ADDR_EXP 54
16917: PUSH
16918: LD_EXP 54
16922: PPUSH
16923: LD_VAR 0 1
16927: PPUSH
16928: EMPTY
16929: PPUSH
16930: CALL_OW 1
16934: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
16935: LD_ADDR_EXP 55
16939: PUSH
16940: LD_EXP 55
16944: PPUSH
16945: LD_VAR 0 1
16949: PPUSH
16950: EMPTY
16951: PPUSH
16952: CALL_OW 1
16956: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
16957: LD_ADDR_EXP 56
16961: PUSH
16962: LD_EXP 56
16966: PPUSH
16967: LD_VAR 0 1
16971: PPUSH
16972: EMPTY
16973: PPUSH
16974: CALL_OW 1
16978: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
16979: LD_ADDR_EXP 57
16983: PUSH
16984: LD_EXP 57
16988: PPUSH
16989: LD_VAR 0 1
16993: PPUSH
16994: EMPTY
16995: PPUSH
16996: CALL_OW 1
17000: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
17001: LD_ADDR_EXP 58
17005: PUSH
17006: LD_EXP 58
17010: PPUSH
17011: LD_VAR 0 1
17015: PPUSH
17016: EMPTY
17017: PPUSH
17018: CALL_OW 1
17022: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
17023: LD_ADDR_EXP 59
17027: PUSH
17028: LD_EXP 59
17032: PPUSH
17033: LD_VAR 0 1
17037: PPUSH
17038: EMPTY
17039: PPUSH
17040: CALL_OW 1
17044: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
17045: LD_ADDR_EXP 60
17049: PUSH
17050: LD_EXP 60
17054: PPUSH
17055: LD_VAR 0 1
17059: PPUSH
17060: EMPTY
17061: PPUSH
17062: CALL_OW 1
17066: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
17067: LD_ADDR_EXP 61
17071: PUSH
17072: LD_EXP 61
17076: PPUSH
17077: LD_VAR 0 1
17081: PPUSH
17082: LD_INT 0
17084: PPUSH
17085: CALL_OW 1
17089: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
17090: LD_ADDR_EXP 62
17094: PUSH
17095: LD_EXP 62
17099: PPUSH
17100: LD_VAR 0 1
17104: PPUSH
17105: EMPTY
17106: PPUSH
17107: CALL_OW 1
17111: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
17112: LD_ADDR_EXP 63
17116: PUSH
17117: LD_EXP 63
17121: PPUSH
17122: LD_VAR 0 1
17126: PPUSH
17127: EMPTY
17128: PPUSH
17129: CALL_OW 1
17133: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
17134: LD_ADDR_EXP 64
17138: PUSH
17139: LD_EXP 64
17143: PPUSH
17144: LD_VAR 0 1
17148: PPUSH
17149: EMPTY
17150: PPUSH
17151: CALL_OW 1
17155: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
17156: LD_ADDR_EXP 65
17160: PUSH
17161: LD_EXP 65
17165: PPUSH
17166: LD_VAR 0 1
17170: PPUSH
17171: EMPTY
17172: PPUSH
17173: CALL_OW 1
17177: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
17178: LD_ADDR_EXP 66
17182: PUSH
17183: LD_EXP 66
17187: PPUSH
17188: LD_VAR 0 1
17192: PPUSH
17193: EMPTY
17194: PPUSH
17195: CALL_OW 1
17199: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
17200: LD_ADDR_EXP 67
17204: PUSH
17205: LD_EXP 67
17209: PPUSH
17210: LD_VAR 0 1
17214: PPUSH
17215: EMPTY
17216: PPUSH
17217: CALL_OW 1
17221: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
17222: LD_ADDR_EXP 68
17226: PUSH
17227: LD_EXP 68
17231: PPUSH
17232: LD_VAR 0 1
17236: PPUSH
17237: EMPTY
17238: PPUSH
17239: CALL_OW 1
17243: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
17244: LD_ADDR_EXP 69
17248: PUSH
17249: LD_EXP 69
17253: PPUSH
17254: LD_VAR 0 1
17258: PPUSH
17259: EMPTY
17260: PPUSH
17261: CALL_OW 1
17265: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
17266: LD_ADDR_EXP 70
17270: PUSH
17271: LD_EXP 70
17275: PPUSH
17276: LD_VAR 0 1
17280: PPUSH
17281: EMPTY
17282: PPUSH
17283: CALL_OW 1
17287: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
17288: LD_ADDR_EXP 71
17292: PUSH
17293: LD_EXP 71
17297: PPUSH
17298: LD_VAR 0 1
17302: PPUSH
17303: EMPTY
17304: PPUSH
17305: CALL_OW 1
17309: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
17310: LD_ADDR_EXP 72
17314: PUSH
17315: LD_EXP 72
17319: PPUSH
17320: LD_VAR 0 1
17324: PPUSH
17325: EMPTY
17326: PPUSH
17327: CALL_OW 1
17331: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
17332: LD_ADDR_EXP 73
17336: PUSH
17337: LD_EXP 73
17341: PPUSH
17342: LD_VAR 0 1
17346: PPUSH
17347: EMPTY
17348: PPUSH
17349: CALL_OW 1
17353: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
17354: LD_ADDR_EXP 74
17358: PUSH
17359: LD_EXP 74
17363: PPUSH
17364: LD_VAR 0 1
17368: PPUSH
17369: EMPTY
17370: PPUSH
17371: CALL_OW 1
17375: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
17376: LD_ADDR_EXP 75
17380: PUSH
17381: LD_EXP 75
17385: PPUSH
17386: LD_VAR 0 1
17390: PPUSH
17391: EMPTY
17392: PPUSH
17393: CALL_OW 1
17397: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
17398: LD_ADDR_EXP 77
17402: PUSH
17403: LD_EXP 77
17407: PPUSH
17408: LD_VAR 0 1
17412: PPUSH
17413: EMPTY
17414: PPUSH
17415: CALL_OW 1
17419: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
17420: LD_ADDR_EXP 79
17424: PUSH
17425: LD_EXP 79
17429: PPUSH
17430: LD_VAR 0 1
17434: PPUSH
17435: EMPTY
17436: PPUSH
17437: CALL_OW 1
17441: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
17442: LD_ADDR_EXP 80
17446: PUSH
17447: LD_EXP 80
17451: PPUSH
17452: LD_VAR 0 1
17456: PPUSH
17457: EMPTY
17458: PPUSH
17459: CALL_OW 1
17463: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
17464: LD_ADDR_EXP 81
17468: PUSH
17469: LD_EXP 81
17473: PPUSH
17474: LD_VAR 0 1
17478: PPUSH
17479: EMPTY
17480: PPUSH
17481: CALL_OW 1
17485: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
17486: LD_ADDR_EXP 82
17490: PUSH
17491: LD_EXP 82
17495: PPUSH
17496: LD_VAR 0 1
17500: PPUSH
17501: EMPTY
17502: PPUSH
17503: CALL_OW 1
17507: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
17508: LD_ADDR_EXP 83
17512: PUSH
17513: LD_EXP 83
17517: PPUSH
17518: LD_VAR 0 1
17522: PPUSH
17523: EMPTY
17524: PPUSH
17525: CALL_OW 1
17529: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
17530: LD_ADDR_EXP 84
17534: PUSH
17535: LD_EXP 84
17539: PPUSH
17540: LD_VAR 0 1
17544: PPUSH
17545: EMPTY
17546: PPUSH
17547: CALL_OW 1
17551: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
17552: LD_ADDR_EXP 85
17556: PUSH
17557: LD_EXP 85
17561: PPUSH
17562: LD_VAR 0 1
17566: PPUSH
17567: EMPTY
17568: PPUSH
17569: CALL_OW 1
17573: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
17574: LD_ADDR_EXP 86
17578: PUSH
17579: LD_EXP 86
17583: PPUSH
17584: LD_VAR 0 1
17588: PPUSH
17589: EMPTY
17590: PPUSH
17591: CALL_OW 1
17595: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
17596: LD_ADDR_EXP 87
17600: PUSH
17601: LD_EXP 87
17605: PPUSH
17606: LD_VAR 0 1
17610: PPUSH
17611: EMPTY
17612: PPUSH
17613: CALL_OW 1
17617: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
17618: LD_ADDR_EXP 88
17622: PUSH
17623: LD_EXP 88
17627: PPUSH
17628: LD_VAR 0 1
17632: PPUSH
17633: EMPTY
17634: PPUSH
17635: CALL_OW 1
17639: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
17640: LD_ADDR_EXP 89
17644: PUSH
17645: LD_EXP 89
17649: PPUSH
17650: LD_VAR 0 1
17654: PPUSH
17655: EMPTY
17656: PPUSH
17657: CALL_OW 1
17661: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
17662: LD_ADDR_EXP 90
17666: PUSH
17667: LD_EXP 90
17671: PPUSH
17672: LD_VAR 0 1
17676: PPUSH
17677: EMPTY
17678: PPUSH
17679: CALL_OW 1
17683: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
17684: LD_ADDR_EXP 91
17688: PUSH
17689: LD_EXP 91
17693: PPUSH
17694: LD_VAR 0 1
17698: PPUSH
17699: EMPTY
17700: PPUSH
17701: CALL_OW 1
17705: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
17706: LD_ADDR_EXP 92
17710: PUSH
17711: LD_EXP 92
17715: PPUSH
17716: LD_VAR 0 1
17720: PPUSH
17721: LD_INT 0
17723: PPUSH
17724: CALL_OW 1
17728: ST_TO_ADDR
// end ;
17729: LD_VAR 0 2
17733: RET
// export function MC_Start ( ) ; var i ; begin
17734: LD_INT 0
17736: PPUSH
17737: PPUSH
// for i = 1 to mc_bases do
17738: LD_ADDR_VAR 0 2
17742: PUSH
17743: DOUBLE
17744: LD_INT 1
17746: DEC
17747: ST_TO_ADDR
17748: LD_EXP 50
17752: PUSH
17753: FOR_TO
17754: IFFALSE 18831
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
17756: LD_ADDR_EXP 50
17760: PUSH
17761: LD_EXP 50
17765: PPUSH
17766: LD_VAR 0 2
17770: PPUSH
17771: LD_EXP 50
17775: PUSH
17776: LD_VAR 0 2
17780: ARRAY
17781: PUSH
17782: LD_INT 0
17784: DIFF
17785: PPUSH
17786: CALL_OW 1
17790: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
17791: LD_ADDR_EXP 51
17795: PUSH
17796: LD_EXP 51
17800: PPUSH
17801: LD_VAR 0 2
17805: PPUSH
17806: EMPTY
17807: PPUSH
17808: CALL_OW 1
17812: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
17813: LD_ADDR_EXP 52
17817: PUSH
17818: LD_EXP 52
17822: PPUSH
17823: LD_VAR 0 2
17827: PPUSH
17828: EMPTY
17829: PPUSH
17830: CALL_OW 1
17834: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
17835: LD_ADDR_EXP 53
17839: PUSH
17840: LD_EXP 53
17844: PPUSH
17845: LD_VAR 0 2
17849: PPUSH
17850: EMPTY
17851: PPUSH
17852: CALL_OW 1
17856: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
17857: LD_ADDR_EXP 54
17861: PUSH
17862: LD_EXP 54
17866: PPUSH
17867: LD_VAR 0 2
17871: PPUSH
17872: EMPTY
17873: PUSH
17874: EMPTY
17875: PUSH
17876: EMPTY
17877: LIST
17878: LIST
17879: PPUSH
17880: CALL_OW 1
17884: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
17885: LD_ADDR_EXP 55
17889: PUSH
17890: LD_EXP 55
17894: PPUSH
17895: LD_VAR 0 2
17899: PPUSH
17900: EMPTY
17901: PPUSH
17902: CALL_OW 1
17906: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
17907: LD_ADDR_EXP 82
17911: PUSH
17912: LD_EXP 82
17916: PPUSH
17917: LD_VAR 0 2
17921: PPUSH
17922: EMPTY
17923: PPUSH
17924: CALL_OW 1
17928: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
17929: LD_ADDR_EXP 56
17933: PUSH
17934: LD_EXP 56
17938: PPUSH
17939: LD_VAR 0 2
17943: PPUSH
17944: EMPTY
17945: PPUSH
17946: CALL_OW 1
17950: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
17951: LD_ADDR_EXP 57
17955: PUSH
17956: LD_EXP 57
17960: PPUSH
17961: LD_VAR 0 2
17965: PPUSH
17966: EMPTY
17967: PPUSH
17968: CALL_OW 1
17972: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
17973: LD_ADDR_EXP 58
17977: PUSH
17978: LD_EXP 58
17982: PPUSH
17983: LD_VAR 0 2
17987: PPUSH
17988: LD_EXP 50
17992: PUSH
17993: LD_VAR 0 2
17997: ARRAY
17998: PPUSH
17999: LD_INT 2
18001: PUSH
18002: LD_INT 30
18004: PUSH
18005: LD_INT 32
18007: PUSH
18008: EMPTY
18009: LIST
18010: LIST
18011: PUSH
18012: LD_INT 30
18014: PUSH
18015: LD_INT 33
18017: PUSH
18018: EMPTY
18019: LIST
18020: LIST
18021: PUSH
18022: EMPTY
18023: LIST
18024: LIST
18025: LIST
18026: PPUSH
18027: CALL_OW 72
18031: PPUSH
18032: CALL_OW 1
18036: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
18037: LD_ADDR_EXP 59
18041: PUSH
18042: LD_EXP 59
18046: PPUSH
18047: LD_VAR 0 2
18051: PPUSH
18052: LD_EXP 50
18056: PUSH
18057: LD_VAR 0 2
18061: ARRAY
18062: PPUSH
18063: LD_INT 2
18065: PUSH
18066: LD_INT 30
18068: PUSH
18069: LD_INT 32
18071: PUSH
18072: EMPTY
18073: LIST
18074: LIST
18075: PUSH
18076: LD_INT 30
18078: PUSH
18079: LD_INT 31
18081: PUSH
18082: EMPTY
18083: LIST
18084: LIST
18085: PUSH
18086: EMPTY
18087: LIST
18088: LIST
18089: LIST
18090: PUSH
18091: LD_INT 58
18093: PUSH
18094: EMPTY
18095: LIST
18096: PUSH
18097: EMPTY
18098: LIST
18099: LIST
18100: PPUSH
18101: CALL_OW 72
18105: PPUSH
18106: CALL_OW 1
18110: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
18111: LD_ADDR_EXP 60
18115: PUSH
18116: LD_EXP 60
18120: PPUSH
18121: LD_VAR 0 2
18125: PPUSH
18126: EMPTY
18127: PPUSH
18128: CALL_OW 1
18132: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
18133: LD_ADDR_EXP 64
18137: PUSH
18138: LD_EXP 64
18142: PPUSH
18143: LD_VAR 0 2
18147: PPUSH
18148: EMPTY
18149: PPUSH
18150: CALL_OW 1
18154: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
18155: LD_ADDR_EXP 63
18159: PUSH
18160: LD_EXP 63
18164: PPUSH
18165: LD_VAR 0 2
18169: PPUSH
18170: EMPTY
18171: PPUSH
18172: CALL_OW 1
18176: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
18177: LD_ADDR_EXP 65
18181: PUSH
18182: LD_EXP 65
18186: PPUSH
18187: LD_VAR 0 2
18191: PPUSH
18192: EMPTY
18193: PPUSH
18194: CALL_OW 1
18198: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
18199: LD_ADDR_EXP 66
18203: PUSH
18204: LD_EXP 66
18208: PPUSH
18209: LD_VAR 0 2
18213: PPUSH
18214: EMPTY
18215: PPUSH
18216: CALL_OW 1
18220: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
18221: LD_ADDR_EXP 67
18225: PUSH
18226: LD_EXP 67
18230: PPUSH
18231: LD_VAR 0 2
18235: PPUSH
18236: EMPTY
18237: PPUSH
18238: CALL_OW 1
18242: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
18243: LD_ADDR_EXP 68
18247: PUSH
18248: LD_EXP 68
18252: PPUSH
18253: LD_VAR 0 2
18257: PPUSH
18258: EMPTY
18259: PPUSH
18260: CALL_OW 1
18264: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
18265: LD_ADDR_EXP 69
18269: PUSH
18270: LD_EXP 69
18274: PPUSH
18275: LD_VAR 0 2
18279: PPUSH
18280: EMPTY
18281: PPUSH
18282: CALL_OW 1
18286: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
18287: LD_ADDR_EXP 70
18291: PUSH
18292: LD_EXP 70
18296: PPUSH
18297: LD_VAR 0 2
18301: PPUSH
18302: EMPTY
18303: PPUSH
18304: CALL_OW 1
18308: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
18309: LD_ADDR_EXP 71
18313: PUSH
18314: LD_EXP 71
18318: PPUSH
18319: LD_VAR 0 2
18323: PPUSH
18324: EMPTY
18325: PPUSH
18326: CALL_OW 1
18330: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
18331: LD_ADDR_EXP 72
18335: PUSH
18336: LD_EXP 72
18340: PPUSH
18341: LD_VAR 0 2
18345: PPUSH
18346: EMPTY
18347: PPUSH
18348: CALL_OW 1
18352: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
18353: LD_ADDR_EXP 61
18357: PUSH
18358: LD_EXP 61
18362: PPUSH
18363: LD_VAR 0 2
18367: PPUSH
18368: LD_INT 0
18370: PPUSH
18371: CALL_OW 1
18375: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
18376: LD_ADDR_EXP 74
18380: PUSH
18381: LD_EXP 74
18385: PPUSH
18386: LD_VAR 0 2
18390: PPUSH
18391: LD_INT 0
18393: PPUSH
18394: CALL_OW 1
18398: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
18399: LD_ADDR_EXP 62
18403: PUSH
18404: LD_EXP 62
18408: PPUSH
18409: LD_VAR 0 2
18413: PPUSH
18414: EMPTY
18415: PPUSH
18416: CALL_OW 1
18420: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
18421: LD_ADDR_EXP 73
18425: PUSH
18426: LD_EXP 73
18430: PPUSH
18431: LD_VAR 0 2
18435: PPUSH
18436: LD_INT 0
18438: PPUSH
18439: CALL_OW 1
18443: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
18444: LD_ADDR_EXP 75
18448: PUSH
18449: LD_EXP 75
18453: PPUSH
18454: LD_VAR 0 2
18458: PPUSH
18459: EMPTY
18460: PPUSH
18461: CALL_OW 1
18465: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
18466: LD_ADDR_EXP 78
18470: PUSH
18471: LD_EXP 78
18475: PPUSH
18476: LD_VAR 0 2
18480: PPUSH
18481: LD_INT 0
18483: PPUSH
18484: CALL_OW 1
18488: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
18489: LD_ADDR_EXP 79
18493: PUSH
18494: LD_EXP 79
18498: PPUSH
18499: LD_VAR 0 2
18503: PPUSH
18504: EMPTY
18505: PPUSH
18506: CALL_OW 1
18510: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
18511: LD_ADDR_EXP 80
18515: PUSH
18516: LD_EXP 80
18520: PPUSH
18521: LD_VAR 0 2
18525: PPUSH
18526: EMPTY
18527: PPUSH
18528: CALL_OW 1
18532: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
18533: LD_ADDR_EXP 81
18537: PUSH
18538: LD_EXP 81
18542: PPUSH
18543: LD_VAR 0 2
18547: PPUSH
18548: EMPTY
18549: PPUSH
18550: CALL_OW 1
18554: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
18555: LD_ADDR_EXP 83
18559: PUSH
18560: LD_EXP 83
18564: PPUSH
18565: LD_VAR 0 2
18569: PPUSH
18570: LD_EXP 50
18574: PUSH
18575: LD_VAR 0 2
18579: ARRAY
18580: PPUSH
18581: LD_INT 2
18583: PUSH
18584: LD_INT 30
18586: PUSH
18587: LD_INT 6
18589: PUSH
18590: EMPTY
18591: LIST
18592: LIST
18593: PUSH
18594: LD_INT 30
18596: PUSH
18597: LD_INT 7
18599: PUSH
18600: EMPTY
18601: LIST
18602: LIST
18603: PUSH
18604: LD_INT 30
18606: PUSH
18607: LD_INT 8
18609: PUSH
18610: EMPTY
18611: LIST
18612: LIST
18613: PUSH
18614: EMPTY
18615: LIST
18616: LIST
18617: LIST
18618: LIST
18619: PPUSH
18620: CALL_OW 72
18624: PPUSH
18625: CALL_OW 1
18629: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
18630: LD_ADDR_EXP 84
18634: PUSH
18635: LD_EXP 84
18639: PPUSH
18640: LD_VAR 0 2
18644: PPUSH
18645: EMPTY
18646: PPUSH
18647: CALL_OW 1
18651: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
18652: LD_ADDR_EXP 85
18656: PUSH
18657: LD_EXP 85
18661: PPUSH
18662: LD_VAR 0 2
18666: PPUSH
18667: EMPTY
18668: PPUSH
18669: CALL_OW 1
18673: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
18674: LD_ADDR_EXP 86
18678: PUSH
18679: LD_EXP 86
18683: PPUSH
18684: LD_VAR 0 2
18688: PPUSH
18689: EMPTY
18690: PPUSH
18691: CALL_OW 1
18695: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
18696: LD_ADDR_EXP 87
18700: PUSH
18701: LD_EXP 87
18705: PPUSH
18706: LD_VAR 0 2
18710: PPUSH
18711: EMPTY
18712: PPUSH
18713: CALL_OW 1
18717: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
18718: LD_ADDR_EXP 88
18722: PUSH
18723: LD_EXP 88
18727: PPUSH
18728: LD_VAR 0 2
18732: PPUSH
18733: EMPTY
18734: PPUSH
18735: CALL_OW 1
18739: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
18740: LD_ADDR_EXP 89
18744: PUSH
18745: LD_EXP 89
18749: PPUSH
18750: LD_VAR 0 2
18754: PPUSH
18755: EMPTY
18756: PPUSH
18757: CALL_OW 1
18761: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
18762: LD_ADDR_EXP 90
18766: PUSH
18767: LD_EXP 90
18771: PPUSH
18772: LD_VAR 0 2
18776: PPUSH
18777: EMPTY
18778: PPUSH
18779: CALL_OW 1
18783: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
18784: LD_ADDR_EXP 91
18788: PUSH
18789: LD_EXP 91
18793: PPUSH
18794: LD_VAR 0 2
18798: PPUSH
18799: EMPTY
18800: PPUSH
18801: CALL_OW 1
18805: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
18806: LD_ADDR_EXP 92
18810: PUSH
18811: LD_EXP 92
18815: PPUSH
18816: LD_VAR 0 2
18820: PPUSH
18821: LD_INT 0
18823: PPUSH
18824: CALL_OW 1
18828: ST_TO_ADDR
// end ;
18829: GO 17753
18831: POP
18832: POP
// MC_InitSides ( ) ;
18833: CALL 19119 0 0
// MC_InitResearch ( ) ;
18837: CALL 18858 0 0
// CustomInitMacro ( ) ;
18841: CALL 285 0 0
// skirmish := true ;
18845: LD_ADDR_EXP 48
18849: PUSH
18850: LD_INT 1
18852: ST_TO_ADDR
// end ;
18853: LD_VAR 0 1
18857: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
18858: LD_INT 0
18860: PPUSH
18861: PPUSH
18862: PPUSH
18863: PPUSH
18864: PPUSH
18865: PPUSH
// if not mc_bases then
18866: LD_EXP 50
18870: NOT
18871: IFFALSE 18875
// exit ;
18873: GO 19114
// for i = 1 to 8 do
18875: LD_ADDR_VAR 0 2
18879: PUSH
18880: DOUBLE
18881: LD_INT 1
18883: DEC
18884: ST_TO_ADDR
18885: LD_INT 8
18887: PUSH
18888: FOR_TO
18889: IFFALSE 18915
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
18891: LD_ADDR_EXP 77
18895: PUSH
18896: LD_EXP 77
18900: PPUSH
18901: LD_VAR 0 2
18905: PPUSH
18906: EMPTY
18907: PPUSH
18908: CALL_OW 1
18912: ST_TO_ADDR
18913: GO 18888
18915: POP
18916: POP
// tmp := [ ] ;
18917: LD_ADDR_VAR 0 5
18921: PUSH
18922: EMPTY
18923: ST_TO_ADDR
// for i = 1 to mc_sides do
18924: LD_ADDR_VAR 0 2
18928: PUSH
18929: DOUBLE
18930: LD_INT 1
18932: DEC
18933: ST_TO_ADDR
18934: LD_EXP 76
18938: PUSH
18939: FOR_TO
18940: IFFALSE 18998
// if not mc_sides [ i ] in tmp then
18942: LD_EXP 76
18946: PUSH
18947: LD_VAR 0 2
18951: ARRAY
18952: PUSH
18953: LD_VAR 0 5
18957: IN
18958: NOT
18959: IFFALSE 18996
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
18961: LD_ADDR_VAR 0 5
18965: PUSH
18966: LD_VAR 0 5
18970: PPUSH
18971: LD_VAR 0 5
18975: PUSH
18976: LD_INT 1
18978: PLUS
18979: PPUSH
18980: LD_EXP 76
18984: PUSH
18985: LD_VAR 0 2
18989: ARRAY
18990: PPUSH
18991: CALL_OW 2
18995: ST_TO_ADDR
18996: GO 18939
18998: POP
18999: POP
// if not tmp then
19000: LD_VAR 0 5
19004: NOT
19005: IFFALSE 19009
// exit ;
19007: GO 19114
// for j in tmp do
19009: LD_ADDR_VAR 0 3
19013: PUSH
19014: LD_VAR 0 5
19018: PUSH
19019: FOR_IN
19020: IFFALSE 19112
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
19022: LD_ADDR_VAR 0 6
19026: PUSH
19027: LD_INT 22
19029: PUSH
19030: LD_VAR 0 3
19034: PUSH
19035: EMPTY
19036: LIST
19037: LIST
19038: PPUSH
19039: CALL_OW 69
19043: ST_TO_ADDR
// if not un then
19044: LD_VAR 0 6
19048: NOT
19049: IFFALSE 19053
// continue ;
19051: GO 19019
// nation := GetNation ( un [ 1 ] ) ;
19053: LD_ADDR_VAR 0 4
19057: PUSH
19058: LD_VAR 0 6
19062: PUSH
19063: LD_INT 1
19065: ARRAY
19066: PPUSH
19067: CALL_OW 248
19071: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
19072: LD_ADDR_EXP 77
19076: PUSH
19077: LD_EXP 77
19081: PPUSH
19082: LD_VAR 0 3
19086: PPUSH
19087: LD_VAR 0 3
19091: PPUSH
19092: LD_VAR 0 4
19096: PPUSH
19097: LD_INT 1
19099: PPUSH
19100: CALL 44181 0 3
19104: PPUSH
19105: CALL_OW 1
19109: ST_TO_ADDR
// end ;
19110: GO 19019
19112: POP
19113: POP
// end ;
19114: LD_VAR 0 1
19118: RET
// export function MC_InitSides ( ) ; var i ; begin
19119: LD_INT 0
19121: PPUSH
19122: PPUSH
// if not mc_bases then
19123: LD_EXP 50
19127: NOT
19128: IFFALSE 19132
// exit ;
19130: GO 19206
// for i = 1 to mc_bases do
19132: LD_ADDR_VAR 0 2
19136: PUSH
19137: DOUBLE
19138: LD_INT 1
19140: DEC
19141: ST_TO_ADDR
19142: LD_EXP 50
19146: PUSH
19147: FOR_TO
19148: IFFALSE 19204
// if mc_bases [ i ] then
19150: LD_EXP 50
19154: PUSH
19155: LD_VAR 0 2
19159: ARRAY
19160: IFFALSE 19202
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
19162: LD_ADDR_EXP 76
19166: PUSH
19167: LD_EXP 76
19171: PPUSH
19172: LD_VAR 0 2
19176: PPUSH
19177: LD_EXP 50
19181: PUSH
19182: LD_VAR 0 2
19186: ARRAY
19187: PUSH
19188: LD_INT 1
19190: ARRAY
19191: PPUSH
19192: CALL_OW 255
19196: PPUSH
19197: CALL_OW 1
19201: ST_TO_ADDR
19202: GO 19147
19204: POP
19205: POP
// end ;
19206: LD_VAR 0 1
19210: RET
// every 0 0$01 trigger skirmish do
19211: LD_EXP 48
19215: IFFALSE 19369
19217: GO 19219
19219: DISABLE
// begin enable ;
19220: ENABLE
// MC_CheckBuildings ( ) ;
19221: CALL 23516 0 0
// MC_CheckPeopleLife ( ) ;
19225: CALL 23641 0 0
// RaiseSailEvent ( 100 ) ;
19229: LD_INT 100
19231: PPUSH
19232: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
19236: LD_INT 103
19238: PPUSH
19239: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
19243: LD_INT 104
19245: PPUSH
19246: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
19250: LD_INT 105
19252: PPUSH
19253: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
19257: LD_INT 106
19259: PPUSH
19260: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
19264: LD_INT 107
19266: PPUSH
19267: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
19271: LD_INT 108
19273: PPUSH
19274: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
19278: LD_INT 109
19280: PPUSH
19281: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
19285: LD_INT 110
19287: PPUSH
19288: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
19292: LD_INT 111
19294: PPUSH
19295: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
19299: LD_INT 112
19301: PPUSH
19302: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
19306: LD_INT 113
19308: PPUSH
19309: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
19313: LD_INT 120
19315: PPUSH
19316: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
19320: LD_INT 121
19322: PPUSH
19323: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
19327: LD_INT 122
19329: PPUSH
19330: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
19334: LD_INT 123
19336: PPUSH
19337: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
19341: LD_INT 124
19343: PPUSH
19344: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
19348: LD_INT 125
19350: PPUSH
19351: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
19355: LD_INT 126
19357: PPUSH
19358: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
19362: LD_INT 200
19364: PPUSH
19365: CALL_OW 427
// end ;
19369: END
// on SailEvent ( event ) do begin if event = 100 then
19370: LD_VAR 0 1
19374: PUSH
19375: LD_INT 100
19377: EQUAL
19378: IFFALSE 19384
// MC_ClassManager ( ) ;
19380: CALL 19776 0 0
// if event = 101 then
19384: LD_VAR 0 1
19388: PUSH
19389: LD_INT 101
19391: EQUAL
19392: IFFALSE 19398
// MC_RepairBuildings ( ) ;
19394: CALL 24199 0 0
// if event = 102 then
19398: LD_VAR 0 1
19402: PUSH
19403: LD_INT 102
19405: EQUAL
19406: IFFALSE 19412
// MC_Heal ( ) ;
19408: CALL 24605 0 0
// if event = 103 then
19412: LD_VAR 0 1
19416: PUSH
19417: LD_INT 103
19419: EQUAL
19420: IFFALSE 19426
// MC_Build ( ) ;
19422: CALL 25027 0 0
// if event = 104 then
19426: LD_VAR 0 1
19430: PUSH
19431: LD_INT 104
19433: EQUAL
19434: IFFALSE 19440
// MC_TurretWeapon ( ) ;
19436: CALL 26640 0 0
// if event = 105 then
19440: LD_VAR 0 1
19444: PUSH
19445: LD_INT 105
19447: EQUAL
19448: IFFALSE 19454
// MC_BuildUpgrade ( ) ;
19450: CALL 26191 0 0
// if event = 106 then
19454: LD_VAR 0 1
19458: PUSH
19459: LD_INT 106
19461: EQUAL
19462: IFFALSE 19468
// MC_PlantMines ( ) ;
19464: CALL 27070 0 0
// if event = 107 then
19468: LD_VAR 0 1
19472: PUSH
19473: LD_INT 107
19475: EQUAL
19476: IFFALSE 19482
// MC_CollectCrates ( ) ;
19478: CALL 28104 0 0
// if event = 108 then
19482: LD_VAR 0 1
19486: PUSH
19487: LD_INT 108
19489: EQUAL
19490: IFFALSE 19496
// MC_LinkRemoteControl ( ) ;
19492: CALL 29861 0 0
// if event = 109 then
19496: LD_VAR 0 1
19500: PUSH
19501: LD_INT 109
19503: EQUAL
19504: IFFALSE 19510
// MC_ProduceVehicle ( ) ;
19506: CALL 30042 0 0
// if event = 110 then
19510: LD_VAR 0 1
19514: PUSH
19515: LD_INT 110
19517: EQUAL
19518: IFFALSE 19524
// MC_SendAttack ( ) ;
19520: CALL 30523 0 0
// if event = 111 then
19524: LD_VAR 0 1
19528: PUSH
19529: LD_INT 111
19531: EQUAL
19532: IFFALSE 19538
// MC_Defend ( ) ;
19534: CALL 30631 0 0
// if event = 112 then
19538: LD_VAR 0 1
19542: PUSH
19543: LD_INT 112
19545: EQUAL
19546: IFFALSE 19552
// MC_Research ( ) ;
19548: CALL 31258 0 0
// if event = 113 then
19552: LD_VAR 0 1
19556: PUSH
19557: LD_INT 113
19559: EQUAL
19560: IFFALSE 19566
// MC_MinesTrigger ( ) ;
19562: CALL 32345 0 0
// if event = 120 then
19566: LD_VAR 0 1
19570: PUSH
19571: LD_INT 120
19573: EQUAL
19574: IFFALSE 19580
// MC_RepairVehicle ( ) ;
19576: CALL 32444 0 0
// if event = 121 then
19580: LD_VAR 0 1
19584: PUSH
19585: LD_INT 121
19587: EQUAL
19588: IFFALSE 19594
// MC_TameApe ( ) ;
19590: CALL 33187 0 0
// if event = 122 then
19594: LD_VAR 0 1
19598: PUSH
19599: LD_INT 122
19601: EQUAL
19602: IFFALSE 19608
// MC_ChangeApeClass ( ) ;
19604: CALL 34016 0 0
// if event = 123 then
19608: LD_VAR 0 1
19612: PUSH
19613: LD_INT 123
19615: EQUAL
19616: IFFALSE 19622
// MC_Bazooka ( ) ;
19618: CALL 34666 0 0
// if event = 124 then
19622: LD_VAR 0 1
19626: PUSH
19627: LD_INT 124
19629: EQUAL
19630: IFFALSE 19636
// MC_TeleportExit ( ) ;
19632: CALL 34864 0 0
// if event = 125 then
19636: LD_VAR 0 1
19640: PUSH
19641: LD_INT 125
19643: EQUAL
19644: IFFALSE 19650
// MC_Deposits ( ) ;
19646: CALL 35511 0 0
// if event = 126 then
19650: LD_VAR 0 1
19654: PUSH
19655: LD_INT 126
19657: EQUAL
19658: IFFALSE 19664
// MC_RemoteDriver ( ) ;
19660: CALL 36136 0 0
// if event = 200 then
19664: LD_VAR 0 1
19668: PUSH
19669: LD_INT 200
19671: EQUAL
19672: IFFALSE 19678
// MC_Idle ( ) ;
19674: CALL 37869 0 0
// end ;
19678: PPOPN 1
19680: END
// export function MC_Reset ( base , tag ) ; var i ; begin
19681: LD_INT 0
19683: PPUSH
19684: PPUSH
// if not mc_bases [ base ] or not tag then
19685: LD_EXP 50
19689: PUSH
19690: LD_VAR 0 1
19694: ARRAY
19695: NOT
19696: PUSH
19697: LD_VAR 0 2
19701: NOT
19702: OR
19703: IFFALSE 19707
// exit ;
19705: GO 19771
// for i in mc_bases [ base ] union mc_ape [ base ] do
19707: LD_ADDR_VAR 0 4
19711: PUSH
19712: LD_EXP 50
19716: PUSH
19717: LD_VAR 0 1
19721: ARRAY
19722: PUSH
19723: LD_EXP 79
19727: PUSH
19728: LD_VAR 0 1
19732: ARRAY
19733: UNION
19734: PUSH
19735: FOR_IN
19736: IFFALSE 19769
// if GetTag ( i ) = tag then
19738: LD_VAR 0 4
19742: PPUSH
19743: CALL_OW 110
19747: PUSH
19748: LD_VAR 0 2
19752: EQUAL
19753: IFFALSE 19767
// SetTag ( i , 0 ) ;
19755: LD_VAR 0 4
19759: PPUSH
19760: LD_INT 0
19762: PPUSH
19763: CALL_OW 109
19767: GO 19735
19769: POP
19770: POP
// end ;
19771: LD_VAR 0 3
19775: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
19776: LD_INT 0
19778: PPUSH
19779: PPUSH
19780: PPUSH
19781: PPUSH
19782: PPUSH
19783: PPUSH
19784: PPUSH
19785: PPUSH
// if not mc_bases then
19786: LD_EXP 50
19790: NOT
19791: IFFALSE 19795
// exit ;
19793: GO 20253
// for i = 1 to mc_bases do
19795: LD_ADDR_VAR 0 2
19799: PUSH
19800: DOUBLE
19801: LD_INT 1
19803: DEC
19804: ST_TO_ADDR
19805: LD_EXP 50
19809: PUSH
19810: FOR_TO
19811: IFFALSE 20251
// begin tmp := MC_ClassCheckReq ( i ) ;
19813: LD_ADDR_VAR 0 4
19817: PUSH
19818: LD_VAR 0 2
19822: PPUSH
19823: CALL 20258 0 1
19827: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
19828: LD_ADDR_EXP 91
19832: PUSH
19833: LD_EXP 91
19837: PPUSH
19838: LD_VAR 0 2
19842: PPUSH
19843: LD_VAR 0 4
19847: PPUSH
19848: CALL_OW 1
19852: ST_TO_ADDR
// if not tmp then
19853: LD_VAR 0 4
19857: NOT
19858: IFFALSE 19862
// continue ;
19860: GO 19810
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
19862: LD_ADDR_VAR 0 6
19866: PUSH
19867: LD_EXP 50
19871: PUSH
19872: LD_VAR 0 2
19876: ARRAY
19877: PPUSH
19878: LD_INT 2
19880: PUSH
19881: LD_INT 30
19883: PUSH
19884: LD_INT 4
19886: PUSH
19887: EMPTY
19888: LIST
19889: LIST
19890: PUSH
19891: LD_INT 30
19893: PUSH
19894: LD_INT 5
19896: PUSH
19897: EMPTY
19898: LIST
19899: LIST
19900: PUSH
19901: EMPTY
19902: LIST
19903: LIST
19904: LIST
19905: PPUSH
19906: CALL_OW 72
19910: PUSH
19911: LD_EXP 50
19915: PUSH
19916: LD_VAR 0 2
19920: ARRAY
19921: PPUSH
19922: LD_INT 2
19924: PUSH
19925: LD_INT 30
19927: PUSH
19928: LD_INT 0
19930: PUSH
19931: EMPTY
19932: LIST
19933: LIST
19934: PUSH
19935: LD_INT 30
19937: PUSH
19938: LD_INT 1
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: PUSH
19945: EMPTY
19946: LIST
19947: LIST
19948: LIST
19949: PPUSH
19950: CALL_OW 72
19954: PUSH
19955: LD_EXP 50
19959: PUSH
19960: LD_VAR 0 2
19964: ARRAY
19965: PPUSH
19966: LD_INT 30
19968: PUSH
19969: LD_INT 3
19971: PUSH
19972: EMPTY
19973: LIST
19974: LIST
19975: PPUSH
19976: CALL_OW 72
19980: PUSH
19981: LD_EXP 50
19985: PUSH
19986: LD_VAR 0 2
19990: ARRAY
19991: PPUSH
19992: LD_INT 2
19994: PUSH
19995: LD_INT 30
19997: PUSH
19998: LD_INT 6
20000: PUSH
20001: EMPTY
20002: LIST
20003: LIST
20004: PUSH
20005: LD_INT 30
20007: PUSH
20008: LD_INT 7
20010: PUSH
20011: EMPTY
20012: LIST
20013: LIST
20014: PUSH
20015: LD_INT 30
20017: PUSH
20018: LD_INT 8
20020: PUSH
20021: EMPTY
20022: LIST
20023: LIST
20024: PUSH
20025: EMPTY
20026: LIST
20027: LIST
20028: LIST
20029: LIST
20030: PPUSH
20031: CALL_OW 72
20035: PUSH
20036: EMPTY
20037: LIST
20038: LIST
20039: LIST
20040: LIST
20041: ST_TO_ADDR
// for j = 1 to 4 do
20042: LD_ADDR_VAR 0 3
20046: PUSH
20047: DOUBLE
20048: LD_INT 1
20050: DEC
20051: ST_TO_ADDR
20052: LD_INT 4
20054: PUSH
20055: FOR_TO
20056: IFFALSE 20247
// begin if not tmp [ j ] then
20058: LD_VAR 0 4
20062: PUSH
20063: LD_VAR 0 3
20067: ARRAY
20068: NOT
20069: IFFALSE 20073
// continue ;
20071: GO 20055
// for p in tmp [ j ] do
20073: LD_ADDR_VAR 0 5
20077: PUSH
20078: LD_VAR 0 4
20082: PUSH
20083: LD_VAR 0 3
20087: ARRAY
20088: PUSH
20089: FOR_IN
20090: IFFALSE 20243
// begin if not b [ j ] then
20092: LD_VAR 0 6
20096: PUSH
20097: LD_VAR 0 3
20101: ARRAY
20102: NOT
20103: IFFALSE 20107
// break ;
20105: GO 20243
// e := 0 ;
20107: LD_ADDR_VAR 0 7
20111: PUSH
20112: LD_INT 0
20114: ST_TO_ADDR
// for k in b [ j ] do
20115: LD_ADDR_VAR 0 8
20119: PUSH
20120: LD_VAR 0 6
20124: PUSH
20125: LD_VAR 0 3
20129: ARRAY
20130: PUSH
20131: FOR_IN
20132: IFFALSE 20159
// if IsNotFull ( k ) then
20134: LD_VAR 0 8
20138: PPUSH
20139: CALL 48207 0 1
20143: IFFALSE 20157
// begin e := k ;
20145: LD_ADDR_VAR 0 7
20149: PUSH
20150: LD_VAR 0 8
20154: ST_TO_ADDR
// break ;
20155: GO 20159
// end ;
20157: GO 20131
20159: POP
20160: POP
// if e and not UnitGoingToBuilding ( p , e ) then
20161: LD_VAR 0 7
20165: PUSH
20166: LD_VAR 0 5
20170: PPUSH
20171: LD_VAR 0 7
20175: PPUSH
20176: CALL 85041 0 2
20180: NOT
20181: AND
20182: IFFALSE 20241
// begin if IsInUnit ( p ) then
20184: LD_VAR 0 5
20188: PPUSH
20189: CALL_OW 310
20193: IFFALSE 20204
// ComExitBuilding ( p ) ;
20195: LD_VAR 0 5
20199: PPUSH
20200: CALL_OW 122
// ComEnterUnit ( p , e ) ;
20204: LD_VAR 0 5
20208: PPUSH
20209: LD_VAR 0 7
20213: PPUSH
20214: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
20218: LD_VAR 0 5
20222: PPUSH
20223: LD_VAR 0 3
20227: PPUSH
20228: CALL_OW 183
// AddComExitBuilding ( p ) ;
20232: LD_VAR 0 5
20236: PPUSH
20237: CALL_OW 182
// end ; end ;
20241: GO 20089
20243: POP
20244: POP
// end ;
20245: GO 20055
20247: POP
20248: POP
// end ;
20249: GO 19810
20251: POP
20252: POP
// end ;
20253: LD_VAR 0 1
20257: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
20258: LD_INT 0
20260: PPUSH
20261: PPUSH
20262: PPUSH
20263: PPUSH
20264: PPUSH
20265: PPUSH
20266: PPUSH
20267: PPUSH
20268: PPUSH
20269: PPUSH
20270: PPUSH
20271: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
20272: LD_VAR 0 1
20276: NOT
20277: PUSH
20278: LD_EXP 50
20282: PUSH
20283: LD_VAR 0 1
20287: ARRAY
20288: NOT
20289: OR
20290: PUSH
20291: LD_EXP 50
20295: PUSH
20296: LD_VAR 0 1
20300: ARRAY
20301: PPUSH
20302: LD_INT 2
20304: PUSH
20305: LD_INT 30
20307: PUSH
20308: LD_INT 0
20310: PUSH
20311: EMPTY
20312: LIST
20313: LIST
20314: PUSH
20315: LD_INT 30
20317: PUSH
20318: LD_INT 1
20320: PUSH
20321: EMPTY
20322: LIST
20323: LIST
20324: PUSH
20325: EMPTY
20326: LIST
20327: LIST
20328: LIST
20329: PPUSH
20330: CALL_OW 72
20334: NOT
20335: OR
20336: IFFALSE 20340
// exit ;
20338: GO 23511
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
20340: LD_ADDR_VAR 0 4
20344: PUSH
20345: LD_EXP 50
20349: PUSH
20350: LD_VAR 0 1
20354: ARRAY
20355: PPUSH
20356: LD_INT 2
20358: PUSH
20359: LD_INT 25
20361: PUSH
20362: LD_INT 1
20364: PUSH
20365: EMPTY
20366: LIST
20367: LIST
20368: PUSH
20369: LD_INT 25
20371: PUSH
20372: LD_INT 2
20374: PUSH
20375: EMPTY
20376: LIST
20377: LIST
20378: PUSH
20379: LD_INT 25
20381: PUSH
20382: LD_INT 3
20384: PUSH
20385: EMPTY
20386: LIST
20387: LIST
20388: PUSH
20389: LD_INT 25
20391: PUSH
20392: LD_INT 4
20394: PUSH
20395: EMPTY
20396: LIST
20397: LIST
20398: PUSH
20399: LD_INT 25
20401: PUSH
20402: LD_INT 5
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: PUSH
20409: LD_INT 25
20411: PUSH
20412: LD_INT 8
20414: PUSH
20415: EMPTY
20416: LIST
20417: LIST
20418: PUSH
20419: LD_INT 25
20421: PUSH
20422: LD_INT 9
20424: PUSH
20425: EMPTY
20426: LIST
20427: LIST
20428: PUSH
20429: EMPTY
20430: LIST
20431: LIST
20432: LIST
20433: LIST
20434: LIST
20435: LIST
20436: LIST
20437: LIST
20438: PPUSH
20439: CALL_OW 72
20443: ST_TO_ADDR
// for i in tmp do
20444: LD_ADDR_VAR 0 3
20448: PUSH
20449: LD_VAR 0 4
20453: PUSH
20454: FOR_IN
20455: IFFALSE 20486
// if GetTag ( i ) then
20457: LD_VAR 0 3
20461: PPUSH
20462: CALL_OW 110
20466: IFFALSE 20484
// tmp := tmp diff i ;
20468: LD_ADDR_VAR 0 4
20472: PUSH
20473: LD_VAR 0 4
20477: PUSH
20478: LD_VAR 0 3
20482: DIFF
20483: ST_TO_ADDR
20484: GO 20454
20486: POP
20487: POP
// if not tmp then
20488: LD_VAR 0 4
20492: NOT
20493: IFFALSE 20497
// exit ;
20495: GO 23511
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
20497: LD_ADDR_VAR 0 5
20501: PUSH
20502: LD_EXP 50
20506: PUSH
20507: LD_VAR 0 1
20511: ARRAY
20512: PPUSH
20513: LD_INT 2
20515: PUSH
20516: LD_INT 25
20518: PUSH
20519: LD_INT 1
20521: PUSH
20522: EMPTY
20523: LIST
20524: LIST
20525: PUSH
20526: LD_INT 25
20528: PUSH
20529: LD_INT 5
20531: PUSH
20532: EMPTY
20533: LIST
20534: LIST
20535: PUSH
20536: LD_INT 25
20538: PUSH
20539: LD_INT 8
20541: PUSH
20542: EMPTY
20543: LIST
20544: LIST
20545: PUSH
20546: LD_INT 25
20548: PUSH
20549: LD_INT 9
20551: PUSH
20552: EMPTY
20553: LIST
20554: LIST
20555: PUSH
20556: EMPTY
20557: LIST
20558: LIST
20559: LIST
20560: LIST
20561: LIST
20562: PPUSH
20563: CALL_OW 72
20567: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
20568: LD_ADDR_VAR 0 6
20572: PUSH
20573: LD_EXP 50
20577: PUSH
20578: LD_VAR 0 1
20582: ARRAY
20583: PPUSH
20584: LD_INT 25
20586: PUSH
20587: LD_INT 2
20589: PUSH
20590: EMPTY
20591: LIST
20592: LIST
20593: PPUSH
20594: CALL_OW 72
20598: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
20599: LD_ADDR_VAR 0 7
20603: PUSH
20604: LD_EXP 50
20608: PUSH
20609: LD_VAR 0 1
20613: ARRAY
20614: PPUSH
20615: LD_INT 25
20617: PUSH
20618: LD_INT 3
20620: PUSH
20621: EMPTY
20622: LIST
20623: LIST
20624: PPUSH
20625: CALL_OW 72
20629: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
20630: LD_ADDR_VAR 0 8
20634: PUSH
20635: LD_EXP 50
20639: PUSH
20640: LD_VAR 0 1
20644: ARRAY
20645: PPUSH
20646: LD_INT 25
20648: PUSH
20649: LD_INT 4
20651: PUSH
20652: EMPTY
20653: LIST
20654: LIST
20655: PUSH
20656: LD_INT 24
20658: PUSH
20659: LD_INT 251
20661: PUSH
20662: EMPTY
20663: LIST
20664: LIST
20665: PUSH
20666: EMPTY
20667: LIST
20668: LIST
20669: PPUSH
20670: CALL_OW 72
20674: ST_TO_ADDR
// if mc_scan [ base ] then
20675: LD_EXP 73
20679: PUSH
20680: LD_VAR 0 1
20684: ARRAY
20685: IFFALSE 21146
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
20687: LD_ADDR_EXP 92
20691: PUSH
20692: LD_EXP 92
20696: PPUSH
20697: LD_VAR 0 1
20701: PPUSH
20702: LD_INT 4
20704: PPUSH
20705: CALL_OW 1
20709: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
20710: LD_ADDR_VAR 0 12
20714: PUSH
20715: LD_EXP 50
20719: PUSH
20720: LD_VAR 0 1
20724: ARRAY
20725: PPUSH
20726: LD_INT 2
20728: PUSH
20729: LD_INT 30
20731: PUSH
20732: LD_INT 4
20734: PUSH
20735: EMPTY
20736: LIST
20737: LIST
20738: PUSH
20739: LD_INT 30
20741: PUSH
20742: LD_INT 5
20744: PUSH
20745: EMPTY
20746: LIST
20747: LIST
20748: PUSH
20749: EMPTY
20750: LIST
20751: LIST
20752: LIST
20753: PPUSH
20754: CALL_OW 72
20758: ST_TO_ADDR
// if not b then
20759: LD_VAR 0 12
20763: NOT
20764: IFFALSE 20768
// exit ;
20766: GO 23511
// p := [ ] ;
20768: LD_ADDR_VAR 0 11
20772: PUSH
20773: EMPTY
20774: ST_TO_ADDR
// if sci >= 2 then
20775: LD_VAR 0 8
20779: PUSH
20780: LD_INT 2
20782: GREATEREQUAL
20783: IFFALSE 20814
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
20785: LD_ADDR_VAR 0 8
20789: PUSH
20790: LD_VAR 0 8
20794: PUSH
20795: LD_INT 1
20797: ARRAY
20798: PUSH
20799: LD_VAR 0 8
20803: PUSH
20804: LD_INT 2
20806: ARRAY
20807: PUSH
20808: EMPTY
20809: LIST
20810: LIST
20811: ST_TO_ADDR
20812: GO 20875
// if sci = 1 then
20814: LD_VAR 0 8
20818: PUSH
20819: LD_INT 1
20821: EQUAL
20822: IFFALSE 20843
// sci := [ sci [ 1 ] ] else
20824: LD_ADDR_VAR 0 8
20828: PUSH
20829: LD_VAR 0 8
20833: PUSH
20834: LD_INT 1
20836: ARRAY
20837: PUSH
20838: EMPTY
20839: LIST
20840: ST_TO_ADDR
20841: GO 20875
// if sci = 0 then
20843: LD_VAR 0 8
20847: PUSH
20848: LD_INT 0
20850: EQUAL
20851: IFFALSE 20875
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
20853: LD_ADDR_VAR 0 11
20857: PUSH
20858: LD_VAR 0 4
20862: PPUSH
20863: LD_INT 4
20865: PPUSH
20866: CALL 84904 0 2
20870: PUSH
20871: LD_INT 1
20873: ARRAY
20874: ST_TO_ADDR
// if eng > 4 then
20875: LD_VAR 0 6
20879: PUSH
20880: LD_INT 4
20882: GREATER
20883: IFFALSE 20929
// for i = eng downto 4 do
20885: LD_ADDR_VAR 0 3
20889: PUSH
20890: DOUBLE
20891: LD_VAR 0 6
20895: INC
20896: ST_TO_ADDR
20897: LD_INT 4
20899: PUSH
20900: FOR_DOWNTO
20901: IFFALSE 20927
// eng := eng diff eng [ i ] ;
20903: LD_ADDR_VAR 0 6
20907: PUSH
20908: LD_VAR 0 6
20912: PUSH
20913: LD_VAR 0 6
20917: PUSH
20918: LD_VAR 0 3
20922: ARRAY
20923: DIFF
20924: ST_TO_ADDR
20925: GO 20900
20927: POP
20928: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
20929: LD_ADDR_VAR 0 4
20933: PUSH
20934: LD_VAR 0 4
20938: PUSH
20939: LD_VAR 0 5
20943: PUSH
20944: LD_VAR 0 6
20948: UNION
20949: PUSH
20950: LD_VAR 0 7
20954: UNION
20955: PUSH
20956: LD_VAR 0 8
20960: UNION
20961: DIFF
20962: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
20963: LD_ADDR_VAR 0 13
20967: PUSH
20968: LD_EXP 50
20972: PUSH
20973: LD_VAR 0 1
20977: ARRAY
20978: PPUSH
20979: LD_INT 2
20981: PUSH
20982: LD_INT 30
20984: PUSH
20985: LD_INT 32
20987: PUSH
20988: EMPTY
20989: LIST
20990: LIST
20991: PUSH
20992: LD_INT 30
20994: PUSH
20995: LD_INT 31
20997: PUSH
20998: EMPTY
20999: LIST
21000: LIST
21001: PUSH
21002: EMPTY
21003: LIST
21004: LIST
21005: LIST
21006: PPUSH
21007: CALL_OW 72
21011: PUSH
21012: LD_EXP 50
21016: PUSH
21017: LD_VAR 0 1
21021: ARRAY
21022: PPUSH
21023: LD_INT 2
21025: PUSH
21026: LD_INT 30
21028: PUSH
21029: LD_INT 4
21031: PUSH
21032: EMPTY
21033: LIST
21034: LIST
21035: PUSH
21036: LD_INT 30
21038: PUSH
21039: LD_INT 5
21041: PUSH
21042: EMPTY
21043: LIST
21044: LIST
21045: PUSH
21046: EMPTY
21047: LIST
21048: LIST
21049: LIST
21050: PPUSH
21051: CALL_OW 72
21055: PUSH
21056: LD_INT 6
21058: MUL
21059: PLUS
21060: ST_TO_ADDR
// if bcount < tmp then
21061: LD_VAR 0 13
21065: PUSH
21066: LD_VAR 0 4
21070: LESS
21071: IFFALSE 21117
// for i = tmp downto bcount do
21073: LD_ADDR_VAR 0 3
21077: PUSH
21078: DOUBLE
21079: LD_VAR 0 4
21083: INC
21084: ST_TO_ADDR
21085: LD_VAR 0 13
21089: PUSH
21090: FOR_DOWNTO
21091: IFFALSE 21115
// tmp := Delete ( tmp , tmp ) ;
21093: LD_ADDR_VAR 0 4
21097: PUSH
21098: LD_VAR 0 4
21102: PPUSH
21103: LD_VAR 0 4
21107: PPUSH
21108: CALL_OW 3
21112: ST_TO_ADDR
21113: GO 21090
21115: POP
21116: POP
// result := [ tmp , 0 , 0 , p ] ;
21117: LD_ADDR_VAR 0 2
21121: PUSH
21122: LD_VAR 0 4
21126: PUSH
21127: LD_INT 0
21129: PUSH
21130: LD_INT 0
21132: PUSH
21133: LD_VAR 0 11
21137: PUSH
21138: EMPTY
21139: LIST
21140: LIST
21141: LIST
21142: LIST
21143: ST_TO_ADDR
// exit ;
21144: GO 23511
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
21146: LD_EXP 50
21150: PUSH
21151: LD_VAR 0 1
21155: ARRAY
21156: PPUSH
21157: LD_INT 2
21159: PUSH
21160: LD_INT 30
21162: PUSH
21163: LD_INT 6
21165: PUSH
21166: EMPTY
21167: LIST
21168: LIST
21169: PUSH
21170: LD_INT 30
21172: PUSH
21173: LD_INT 7
21175: PUSH
21176: EMPTY
21177: LIST
21178: LIST
21179: PUSH
21180: LD_INT 30
21182: PUSH
21183: LD_INT 8
21185: PUSH
21186: EMPTY
21187: LIST
21188: LIST
21189: PUSH
21190: EMPTY
21191: LIST
21192: LIST
21193: LIST
21194: LIST
21195: PPUSH
21196: CALL_OW 72
21200: NOT
21201: PUSH
21202: LD_EXP 50
21206: PUSH
21207: LD_VAR 0 1
21211: ARRAY
21212: PPUSH
21213: LD_INT 30
21215: PUSH
21216: LD_INT 3
21218: PUSH
21219: EMPTY
21220: LIST
21221: LIST
21222: PPUSH
21223: CALL_OW 72
21227: NOT
21228: AND
21229: IFFALSE 21301
// begin if eng = tmp then
21231: LD_VAR 0 6
21235: PUSH
21236: LD_VAR 0 4
21240: EQUAL
21241: IFFALSE 21245
// exit ;
21243: GO 23511
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
21245: LD_ADDR_EXP 92
21249: PUSH
21250: LD_EXP 92
21254: PPUSH
21255: LD_VAR 0 1
21259: PPUSH
21260: LD_INT 1
21262: PPUSH
21263: CALL_OW 1
21267: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
21268: LD_ADDR_VAR 0 2
21272: PUSH
21273: LD_INT 0
21275: PUSH
21276: LD_VAR 0 4
21280: PUSH
21281: LD_VAR 0 6
21285: DIFF
21286: PUSH
21287: LD_INT 0
21289: PUSH
21290: LD_INT 0
21292: PUSH
21293: EMPTY
21294: LIST
21295: LIST
21296: LIST
21297: LIST
21298: ST_TO_ADDR
// exit ;
21299: GO 23511
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
21301: LD_EXP 77
21305: PUSH
21306: LD_EXP 76
21310: PUSH
21311: LD_VAR 0 1
21315: ARRAY
21316: ARRAY
21317: PUSH
21318: LD_EXP 50
21322: PUSH
21323: LD_VAR 0 1
21327: ARRAY
21328: PPUSH
21329: LD_INT 2
21331: PUSH
21332: LD_INT 30
21334: PUSH
21335: LD_INT 6
21337: PUSH
21338: EMPTY
21339: LIST
21340: LIST
21341: PUSH
21342: LD_INT 30
21344: PUSH
21345: LD_INT 7
21347: PUSH
21348: EMPTY
21349: LIST
21350: LIST
21351: PUSH
21352: LD_INT 30
21354: PUSH
21355: LD_INT 8
21357: PUSH
21358: EMPTY
21359: LIST
21360: LIST
21361: PUSH
21362: EMPTY
21363: LIST
21364: LIST
21365: LIST
21366: LIST
21367: PPUSH
21368: CALL_OW 72
21372: AND
21373: PUSH
21374: LD_EXP 50
21378: PUSH
21379: LD_VAR 0 1
21383: ARRAY
21384: PPUSH
21385: LD_INT 30
21387: PUSH
21388: LD_INT 3
21390: PUSH
21391: EMPTY
21392: LIST
21393: LIST
21394: PPUSH
21395: CALL_OW 72
21399: NOT
21400: AND
21401: IFFALSE 21615
// begin if sci >= 6 then
21403: LD_VAR 0 8
21407: PUSH
21408: LD_INT 6
21410: GREATEREQUAL
21411: IFFALSE 21415
// exit ;
21413: GO 23511
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
21415: LD_ADDR_EXP 92
21419: PUSH
21420: LD_EXP 92
21424: PPUSH
21425: LD_VAR 0 1
21429: PPUSH
21430: LD_INT 2
21432: PPUSH
21433: CALL_OW 1
21437: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
21438: LD_ADDR_VAR 0 9
21442: PUSH
21443: LD_VAR 0 4
21447: PUSH
21448: LD_VAR 0 8
21452: DIFF
21453: PPUSH
21454: LD_INT 4
21456: PPUSH
21457: CALL 84904 0 2
21461: ST_TO_ADDR
// p := [ ] ;
21462: LD_ADDR_VAR 0 11
21466: PUSH
21467: EMPTY
21468: ST_TO_ADDR
// if sci < 6 and sort > 6 then
21469: LD_VAR 0 8
21473: PUSH
21474: LD_INT 6
21476: LESS
21477: PUSH
21478: LD_VAR 0 9
21482: PUSH
21483: LD_INT 6
21485: GREATER
21486: AND
21487: IFFALSE 21568
// begin for i = 1 to 6 - sci do
21489: LD_ADDR_VAR 0 3
21493: PUSH
21494: DOUBLE
21495: LD_INT 1
21497: DEC
21498: ST_TO_ADDR
21499: LD_INT 6
21501: PUSH
21502: LD_VAR 0 8
21506: MINUS
21507: PUSH
21508: FOR_TO
21509: IFFALSE 21564
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
21511: LD_ADDR_VAR 0 11
21515: PUSH
21516: LD_VAR 0 11
21520: PPUSH
21521: LD_VAR 0 11
21525: PUSH
21526: LD_INT 1
21528: PLUS
21529: PPUSH
21530: LD_VAR 0 9
21534: PUSH
21535: LD_INT 1
21537: ARRAY
21538: PPUSH
21539: CALL_OW 2
21543: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
21544: LD_ADDR_VAR 0 9
21548: PUSH
21549: LD_VAR 0 9
21553: PPUSH
21554: LD_INT 1
21556: PPUSH
21557: CALL_OW 3
21561: ST_TO_ADDR
// end ;
21562: GO 21508
21564: POP
21565: POP
// end else
21566: GO 21588
// if sort then
21568: LD_VAR 0 9
21572: IFFALSE 21588
// p := sort [ 1 ] ;
21574: LD_ADDR_VAR 0 11
21578: PUSH
21579: LD_VAR 0 9
21583: PUSH
21584: LD_INT 1
21586: ARRAY
21587: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
21588: LD_ADDR_VAR 0 2
21592: PUSH
21593: LD_INT 0
21595: PUSH
21596: LD_INT 0
21598: PUSH
21599: LD_INT 0
21601: PUSH
21602: LD_VAR 0 11
21606: PUSH
21607: EMPTY
21608: LIST
21609: LIST
21610: LIST
21611: LIST
21612: ST_TO_ADDR
// exit ;
21613: GO 23511
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
21615: LD_EXP 77
21619: PUSH
21620: LD_EXP 76
21624: PUSH
21625: LD_VAR 0 1
21629: ARRAY
21630: ARRAY
21631: PUSH
21632: LD_EXP 50
21636: PUSH
21637: LD_VAR 0 1
21641: ARRAY
21642: PPUSH
21643: LD_INT 2
21645: PUSH
21646: LD_INT 30
21648: PUSH
21649: LD_INT 6
21651: PUSH
21652: EMPTY
21653: LIST
21654: LIST
21655: PUSH
21656: LD_INT 30
21658: PUSH
21659: LD_INT 7
21661: PUSH
21662: EMPTY
21663: LIST
21664: LIST
21665: PUSH
21666: LD_INT 30
21668: PUSH
21669: LD_INT 8
21671: PUSH
21672: EMPTY
21673: LIST
21674: LIST
21675: PUSH
21676: EMPTY
21677: LIST
21678: LIST
21679: LIST
21680: LIST
21681: PPUSH
21682: CALL_OW 72
21686: AND
21687: PUSH
21688: LD_EXP 50
21692: PUSH
21693: LD_VAR 0 1
21697: ARRAY
21698: PPUSH
21699: LD_INT 30
21701: PUSH
21702: LD_INT 3
21704: PUSH
21705: EMPTY
21706: LIST
21707: LIST
21708: PPUSH
21709: CALL_OW 72
21713: AND
21714: IFFALSE 22241
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
21716: LD_ADDR_EXP 92
21720: PUSH
21721: LD_EXP 92
21725: PPUSH
21726: LD_VAR 0 1
21730: PPUSH
21731: LD_INT 3
21733: PPUSH
21734: CALL_OW 1
21738: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
21739: LD_ADDR_VAR 0 2
21743: PUSH
21744: LD_INT 0
21746: PUSH
21747: LD_INT 0
21749: PUSH
21750: LD_INT 0
21752: PUSH
21753: LD_INT 0
21755: PUSH
21756: EMPTY
21757: LIST
21758: LIST
21759: LIST
21760: LIST
21761: ST_TO_ADDR
// if not eng then
21762: LD_VAR 0 6
21766: NOT
21767: IFFALSE 21830
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
21769: LD_ADDR_VAR 0 11
21773: PUSH
21774: LD_VAR 0 4
21778: PPUSH
21779: LD_INT 2
21781: PPUSH
21782: CALL 84904 0 2
21786: PUSH
21787: LD_INT 1
21789: ARRAY
21790: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
21791: LD_ADDR_VAR 0 2
21795: PUSH
21796: LD_VAR 0 2
21800: PPUSH
21801: LD_INT 2
21803: PPUSH
21804: LD_VAR 0 11
21808: PPUSH
21809: CALL_OW 1
21813: ST_TO_ADDR
// tmp := tmp diff p ;
21814: LD_ADDR_VAR 0 4
21818: PUSH
21819: LD_VAR 0 4
21823: PUSH
21824: LD_VAR 0 11
21828: DIFF
21829: ST_TO_ADDR
// end ; if not eng then
21830: LD_VAR 0 6
21834: NOT
21835: IFFALSE 21861
// tmp := tmp diff ( mech union sci ) else
21837: LD_ADDR_VAR 0 4
21841: PUSH
21842: LD_VAR 0 4
21846: PUSH
21847: LD_VAR 0 7
21851: PUSH
21852: LD_VAR 0 8
21856: UNION
21857: DIFF
21858: ST_TO_ADDR
21859: GO 21893
// tmp := tmp diff ( eng [ 1 ] union mech union sci ) ;
21861: LD_ADDR_VAR 0 4
21865: PUSH
21866: LD_VAR 0 4
21870: PUSH
21871: LD_VAR 0 6
21875: PUSH
21876: LD_INT 1
21878: ARRAY
21879: PUSH
21880: LD_VAR 0 7
21884: UNION
21885: PUSH
21886: LD_VAR 0 8
21890: UNION
21891: DIFF
21892: ST_TO_ADDR
// if tmp and sci < 6 then
21893: LD_VAR 0 4
21897: PUSH
21898: LD_VAR 0 8
21902: PUSH
21903: LD_INT 6
21905: LESS
21906: AND
21907: IFFALSE 22066
// begin sort := SortBySkill ( tmp , 4 ) ;
21909: LD_ADDR_VAR 0 9
21913: PUSH
21914: LD_VAR 0 4
21918: PPUSH
21919: LD_INT 4
21921: PPUSH
21922: CALL 84904 0 2
21926: ST_TO_ADDR
// p := [ ] ;
21927: LD_ADDR_VAR 0 11
21931: PUSH
21932: EMPTY
21933: ST_TO_ADDR
// if sort then
21934: LD_VAR 0 9
21938: IFFALSE 22037
// for i = 1 to 6 - sci do
21940: LD_ADDR_VAR 0 3
21944: PUSH
21945: DOUBLE
21946: LD_INT 1
21948: DEC
21949: ST_TO_ADDR
21950: LD_INT 6
21952: PUSH
21953: LD_VAR 0 8
21957: MINUS
21958: PUSH
21959: FOR_TO
21960: IFFALSE 22035
// begin if i = sort then
21962: LD_VAR 0 3
21966: PUSH
21967: LD_VAR 0 9
21971: EQUAL
21972: IFFALSE 21976
// break ;
21974: GO 22035
// p := Insert ( p , p + 1 , sort [ i ] ) ;
21976: LD_ADDR_VAR 0 11
21980: PUSH
21981: LD_VAR 0 11
21985: PPUSH
21986: LD_VAR 0 11
21990: PUSH
21991: LD_INT 1
21993: PLUS
21994: PPUSH
21995: LD_VAR 0 9
21999: PUSH
22000: LD_VAR 0 3
22004: ARRAY
22005: PPUSH
22006: CALL_OW 2
22010: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
22011: LD_ADDR_VAR 0 4
22015: PUSH
22016: LD_VAR 0 4
22020: PUSH
22021: LD_VAR 0 9
22025: PUSH
22026: LD_VAR 0 3
22030: ARRAY
22031: DIFF
22032: ST_TO_ADDR
// end ;
22033: GO 21959
22035: POP
22036: POP
// if p then
22037: LD_VAR 0 11
22041: IFFALSE 22066
// result := Replace ( result , 4 , p ) ;
22043: LD_ADDR_VAR 0 2
22047: PUSH
22048: LD_VAR 0 2
22052: PPUSH
22053: LD_INT 4
22055: PPUSH
22056: LD_VAR 0 11
22060: PPUSH
22061: CALL_OW 1
22065: ST_TO_ADDR
// end ; if tmp and mech < 6 then
22066: LD_VAR 0 4
22070: PUSH
22071: LD_VAR 0 7
22075: PUSH
22076: LD_INT 6
22078: LESS
22079: AND
22080: IFFALSE 22239
// begin sort := SortBySkill ( tmp , 3 ) ;
22082: LD_ADDR_VAR 0 9
22086: PUSH
22087: LD_VAR 0 4
22091: PPUSH
22092: LD_INT 3
22094: PPUSH
22095: CALL 84904 0 2
22099: ST_TO_ADDR
// p := [ ] ;
22100: LD_ADDR_VAR 0 11
22104: PUSH
22105: EMPTY
22106: ST_TO_ADDR
// if sort then
22107: LD_VAR 0 9
22111: IFFALSE 22210
// for i = 1 to 6 - mech do
22113: LD_ADDR_VAR 0 3
22117: PUSH
22118: DOUBLE
22119: LD_INT 1
22121: DEC
22122: ST_TO_ADDR
22123: LD_INT 6
22125: PUSH
22126: LD_VAR 0 7
22130: MINUS
22131: PUSH
22132: FOR_TO
22133: IFFALSE 22208
// begin if i = sort then
22135: LD_VAR 0 3
22139: PUSH
22140: LD_VAR 0 9
22144: EQUAL
22145: IFFALSE 22149
// break ;
22147: GO 22208
// p := Insert ( p , p + 1 , sort [ i ] ) ;
22149: LD_ADDR_VAR 0 11
22153: PUSH
22154: LD_VAR 0 11
22158: PPUSH
22159: LD_VAR 0 11
22163: PUSH
22164: LD_INT 1
22166: PLUS
22167: PPUSH
22168: LD_VAR 0 9
22172: PUSH
22173: LD_VAR 0 3
22177: ARRAY
22178: PPUSH
22179: CALL_OW 2
22183: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
22184: LD_ADDR_VAR 0 4
22188: PUSH
22189: LD_VAR 0 4
22193: PUSH
22194: LD_VAR 0 9
22198: PUSH
22199: LD_VAR 0 3
22203: ARRAY
22204: DIFF
22205: ST_TO_ADDR
// end ;
22206: GO 22132
22208: POP
22209: POP
// if p then
22210: LD_VAR 0 11
22214: IFFALSE 22239
// result := Replace ( result , 3 , p ) ;
22216: LD_ADDR_VAR 0 2
22220: PUSH
22221: LD_VAR 0 2
22225: PPUSH
22226: LD_INT 3
22228: PPUSH
22229: LD_VAR 0 11
22233: PPUSH
22234: CALL_OW 1
22238: ST_TO_ADDR
// end ; exit ;
22239: GO 23511
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
22241: LD_EXP 77
22245: PUSH
22246: LD_EXP 76
22250: PUSH
22251: LD_VAR 0 1
22255: ARRAY
22256: ARRAY
22257: NOT
22258: PUSH
22259: LD_EXP 50
22263: PUSH
22264: LD_VAR 0 1
22268: ARRAY
22269: PPUSH
22270: LD_INT 30
22272: PUSH
22273: LD_INT 3
22275: PUSH
22276: EMPTY
22277: LIST
22278: LIST
22279: PPUSH
22280: CALL_OW 72
22284: AND
22285: PUSH
22286: LD_EXP 55
22290: PUSH
22291: LD_VAR 0 1
22295: ARRAY
22296: AND
22297: IFFALSE 22841
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
22299: LD_ADDR_EXP 92
22303: PUSH
22304: LD_EXP 92
22308: PPUSH
22309: LD_VAR 0 1
22313: PPUSH
22314: LD_INT 5
22316: PPUSH
22317: CALL_OW 1
22321: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
22322: LD_ADDR_VAR 0 2
22326: PUSH
22327: LD_INT 0
22329: PUSH
22330: LD_INT 0
22332: PUSH
22333: LD_INT 0
22335: PUSH
22336: LD_INT 0
22338: PUSH
22339: EMPTY
22340: LIST
22341: LIST
22342: LIST
22343: LIST
22344: ST_TO_ADDR
// if sci > 1 then
22345: LD_VAR 0 8
22349: PUSH
22350: LD_INT 1
22352: GREATER
22353: IFFALSE 22381
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
22355: LD_ADDR_VAR 0 4
22359: PUSH
22360: LD_VAR 0 4
22364: PUSH
22365: LD_VAR 0 8
22369: PUSH
22370: LD_VAR 0 8
22374: PUSH
22375: LD_INT 1
22377: ARRAY
22378: DIFF
22379: DIFF
22380: ST_TO_ADDR
// if tmp and not sci then
22381: LD_VAR 0 4
22385: PUSH
22386: LD_VAR 0 8
22390: NOT
22391: AND
22392: IFFALSE 22461
// begin sort := SortBySkill ( tmp , 4 ) ;
22394: LD_ADDR_VAR 0 9
22398: PUSH
22399: LD_VAR 0 4
22403: PPUSH
22404: LD_INT 4
22406: PPUSH
22407: CALL 84904 0 2
22411: ST_TO_ADDR
// if sort then
22412: LD_VAR 0 9
22416: IFFALSE 22432
// p := sort [ 1 ] ;
22418: LD_ADDR_VAR 0 11
22422: PUSH
22423: LD_VAR 0 9
22427: PUSH
22428: LD_INT 1
22430: ARRAY
22431: ST_TO_ADDR
// if p then
22432: LD_VAR 0 11
22436: IFFALSE 22461
// result := Replace ( result , 4 , p ) ;
22438: LD_ADDR_VAR 0 2
22442: PUSH
22443: LD_VAR 0 2
22447: PPUSH
22448: LD_INT 4
22450: PPUSH
22451: LD_VAR 0 11
22455: PPUSH
22456: CALL_OW 1
22460: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
22461: LD_ADDR_VAR 0 4
22465: PUSH
22466: LD_VAR 0 4
22470: PUSH
22471: LD_VAR 0 7
22475: DIFF
22476: ST_TO_ADDR
// if tmp and mech < 6 then
22477: LD_VAR 0 4
22481: PUSH
22482: LD_VAR 0 7
22486: PUSH
22487: LD_INT 6
22489: LESS
22490: AND
22491: IFFALSE 22650
// begin sort := SortBySkill ( tmp , 3 ) ;
22493: LD_ADDR_VAR 0 9
22497: PUSH
22498: LD_VAR 0 4
22502: PPUSH
22503: LD_INT 3
22505: PPUSH
22506: CALL 84904 0 2
22510: ST_TO_ADDR
// p := [ ] ;
22511: LD_ADDR_VAR 0 11
22515: PUSH
22516: EMPTY
22517: ST_TO_ADDR
// if sort then
22518: LD_VAR 0 9
22522: IFFALSE 22621
// for i = 1 to 6 - mech do
22524: LD_ADDR_VAR 0 3
22528: PUSH
22529: DOUBLE
22530: LD_INT 1
22532: DEC
22533: ST_TO_ADDR
22534: LD_INT 6
22536: PUSH
22537: LD_VAR 0 7
22541: MINUS
22542: PUSH
22543: FOR_TO
22544: IFFALSE 22619
// begin if i = sort then
22546: LD_VAR 0 3
22550: PUSH
22551: LD_VAR 0 9
22555: EQUAL
22556: IFFALSE 22560
// break ;
22558: GO 22619
// p := Insert ( p , p + 1 , sort [ i ] ) ;
22560: LD_ADDR_VAR 0 11
22564: PUSH
22565: LD_VAR 0 11
22569: PPUSH
22570: LD_VAR 0 11
22574: PUSH
22575: LD_INT 1
22577: PLUS
22578: PPUSH
22579: LD_VAR 0 9
22583: PUSH
22584: LD_VAR 0 3
22588: ARRAY
22589: PPUSH
22590: CALL_OW 2
22594: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
22595: LD_ADDR_VAR 0 4
22599: PUSH
22600: LD_VAR 0 4
22604: PUSH
22605: LD_VAR 0 9
22609: PUSH
22610: LD_VAR 0 3
22614: ARRAY
22615: DIFF
22616: ST_TO_ADDR
// end ;
22617: GO 22543
22619: POP
22620: POP
// if p then
22621: LD_VAR 0 11
22625: IFFALSE 22650
// result := Replace ( result , 3 , p ) ;
22627: LD_ADDR_VAR 0 2
22631: PUSH
22632: LD_VAR 0 2
22636: PPUSH
22637: LD_INT 3
22639: PPUSH
22640: LD_VAR 0 11
22644: PPUSH
22645: CALL_OW 1
22649: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
22650: LD_ADDR_VAR 0 4
22654: PUSH
22655: LD_VAR 0 4
22659: PUSH
22660: LD_VAR 0 6
22664: DIFF
22665: ST_TO_ADDR
// if tmp and eng < 6 then
22666: LD_VAR 0 4
22670: PUSH
22671: LD_VAR 0 6
22675: PUSH
22676: LD_INT 6
22678: LESS
22679: AND
22680: IFFALSE 22839
// begin sort := SortBySkill ( tmp , 2 ) ;
22682: LD_ADDR_VAR 0 9
22686: PUSH
22687: LD_VAR 0 4
22691: PPUSH
22692: LD_INT 2
22694: PPUSH
22695: CALL 84904 0 2
22699: ST_TO_ADDR
// p := [ ] ;
22700: LD_ADDR_VAR 0 11
22704: PUSH
22705: EMPTY
22706: ST_TO_ADDR
// if sort then
22707: LD_VAR 0 9
22711: IFFALSE 22810
// for i = 1 to 6 - eng do
22713: LD_ADDR_VAR 0 3
22717: PUSH
22718: DOUBLE
22719: LD_INT 1
22721: DEC
22722: ST_TO_ADDR
22723: LD_INT 6
22725: PUSH
22726: LD_VAR 0 6
22730: MINUS
22731: PUSH
22732: FOR_TO
22733: IFFALSE 22808
// begin if i = sort then
22735: LD_VAR 0 3
22739: PUSH
22740: LD_VAR 0 9
22744: EQUAL
22745: IFFALSE 22749
// break ;
22747: GO 22808
// p := Insert ( p , p + 1 , sort [ i ] ) ;
22749: LD_ADDR_VAR 0 11
22753: PUSH
22754: LD_VAR 0 11
22758: PPUSH
22759: LD_VAR 0 11
22763: PUSH
22764: LD_INT 1
22766: PLUS
22767: PPUSH
22768: LD_VAR 0 9
22772: PUSH
22773: LD_VAR 0 3
22777: ARRAY
22778: PPUSH
22779: CALL_OW 2
22783: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
22784: LD_ADDR_VAR 0 4
22788: PUSH
22789: LD_VAR 0 4
22793: PUSH
22794: LD_VAR 0 9
22798: PUSH
22799: LD_VAR 0 3
22803: ARRAY
22804: DIFF
22805: ST_TO_ADDR
// end ;
22806: GO 22732
22808: POP
22809: POP
// if p then
22810: LD_VAR 0 11
22814: IFFALSE 22839
// result := Replace ( result , 2 , p ) ;
22816: LD_ADDR_VAR 0 2
22820: PUSH
22821: LD_VAR 0 2
22825: PPUSH
22826: LD_INT 2
22828: PPUSH
22829: LD_VAR 0 11
22833: PPUSH
22834: CALL_OW 1
22838: ST_TO_ADDR
// end ; exit ;
22839: GO 23511
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
22841: LD_EXP 77
22845: PUSH
22846: LD_EXP 76
22850: PUSH
22851: LD_VAR 0 1
22855: ARRAY
22856: ARRAY
22857: NOT
22858: PUSH
22859: LD_EXP 50
22863: PUSH
22864: LD_VAR 0 1
22868: ARRAY
22869: PPUSH
22870: LD_INT 30
22872: PUSH
22873: LD_INT 3
22875: PUSH
22876: EMPTY
22877: LIST
22878: LIST
22879: PPUSH
22880: CALL_OW 72
22884: AND
22885: PUSH
22886: LD_EXP 55
22890: PUSH
22891: LD_VAR 0 1
22895: ARRAY
22896: NOT
22897: AND
22898: IFFALSE 23511
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
22900: LD_ADDR_EXP 92
22904: PUSH
22905: LD_EXP 92
22909: PPUSH
22910: LD_VAR 0 1
22914: PPUSH
22915: LD_INT 6
22917: PPUSH
22918: CALL_OW 1
22922: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
22923: LD_ADDR_VAR 0 2
22927: PUSH
22928: LD_INT 0
22930: PUSH
22931: LD_INT 0
22933: PUSH
22934: LD_INT 0
22936: PUSH
22937: LD_INT 0
22939: PUSH
22940: EMPTY
22941: LIST
22942: LIST
22943: LIST
22944: LIST
22945: ST_TO_ADDR
// if sci >= 1 then
22946: LD_VAR 0 8
22950: PUSH
22951: LD_INT 1
22953: GREATEREQUAL
22954: IFFALSE 22976
// tmp := tmp diff sci [ 1 ] ;
22956: LD_ADDR_VAR 0 4
22960: PUSH
22961: LD_VAR 0 4
22965: PUSH
22966: LD_VAR 0 8
22970: PUSH
22971: LD_INT 1
22973: ARRAY
22974: DIFF
22975: ST_TO_ADDR
// if tmp and not sci then
22976: LD_VAR 0 4
22980: PUSH
22981: LD_VAR 0 8
22985: NOT
22986: AND
22987: IFFALSE 23056
// begin sort := SortBySkill ( tmp , 4 ) ;
22989: LD_ADDR_VAR 0 9
22993: PUSH
22994: LD_VAR 0 4
22998: PPUSH
22999: LD_INT 4
23001: PPUSH
23002: CALL 84904 0 2
23006: ST_TO_ADDR
// if sort then
23007: LD_VAR 0 9
23011: IFFALSE 23027
// p := sort [ 1 ] ;
23013: LD_ADDR_VAR 0 11
23017: PUSH
23018: LD_VAR 0 9
23022: PUSH
23023: LD_INT 1
23025: ARRAY
23026: ST_TO_ADDR
// if p then
23027: LD_VAR 0 11
23031: IFFALSE 23056
// result := Replace ( result , 4 , p ) ;
23033: LD_ADDR_VAR 0 2
23037: PUSH
23038: LD_VAR 0 2
23042: PPUSH
23043: LD_INT 4
23045: PPUSH
23046: LD_VAR 0 11
23050: PPUSH
23051: CALL_OW 1
23055: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
23056: LD_ADDR_VAR 0 4
23060: PUSH
23061: LD_VAR 0 4
23065: PUSH
23066: LD_VAR 0 7
23070: DIFF
23071: ST_TO_ADDR
// if tmp and mech < 6 then
23072: LD_VAR 0 4
23076: PUSH
23077: LD_VAR 0 7
23081: PUSH
23082: LD_INT 6
23084: LESS
23085: AND
23086: IFFALSE 23245
// begin sort := SortBySkill ( tmp , 3 ) ;
23088: LD_ADDR_VAR 0 9
23092: PUSH
23093: LD_VAR 0 4
23097: PPUSH
23098: LD_INT 3
23100: PPUSH
23101: CALL 84904 0 2
23105: ST_TO_ADDR
// p := [ ] ;
23106: LD_ADDR_VAR 0 11
23110: PUSH
23111: EMPTY
23112: ST_TO_ADDR
// if sort then
23113: LD_VAR 0 9
23117: IFFALSE 23216
// for i = 1 to 6 - mech do
23119: LD_ADDR_VAR 0 3
23123: PUSH
23124: DOUBLE
23125: LD_INT 1
23127: DEC
23128: ST_TO_ADDR
23129: LD_INT 6
23131: PUSH
23132: LD_VAR 0 7
23136: MINUS
23137: PUSH
23138: FOR_TO
23139: IFFALSE 23214
// begin if i = sort then
23141: LD_VAR 0 3
23145: PUSH
23146: LD_VAR 0 9
23150: EQUAL
23151: IFFALSE 23155
// break ;
23153: GO 23214
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23155: LD_ADDR_VAR 0 11
23159: PUSH
23160: LD_VAR 0 11
23164: PPUSH
23165: LD_VAR 0 11
23169: PUSH
23170: LD_INT 1
23172: PLUS
23173: PPUSH
23174: LD_VAR 0 9
23178: PUSH
23179: LD_VAR 0 3
23183: ARRAY
23184: PPUSH
23185: CALL_OW 2
23189: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23190: LD_ADDR_VAR 0 4
23194: PUSH
23195: LD_VAR 0 4
23199: PUSH
23200: LD_VAR 0 9
23204: PUSH
23205: LD_VAR 0 3
23209: ARRAY
23210: DIFF
23211: ST_TO_ADDR
// end ;
23212: GO 23138
23214: POP
23215: POP
// if p then
23216: LD_VAR 0 11
23220: IFFALSE 23245
// result := Replace ( result , 3 , p ) ;
23222: LD_ADDR_VAR 0 2
23226: PUSH
23227: LD_VAR 0 2
23231: PPUSH
23232: LD_INT 3
23234: PPUSH
23235: LD_VAR 0 11
23239: PPUSH
23240: CALL_OW 1
23244: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
23245: LD_ADDR_VAR 0 4
23249: PUSH
23250: LD_VAR 0 4
23254: PUSH
23255: LD_VAR 0 6
23259: DIFF
23260: ST_TO_ADDR
// if tmp and eng < 4 then
23261: LD_VAR 0 4
23265: PUSH
23266: LD_VAR 0 6
23270: PUSH
23271: LD_INT 4
23273: LESS
23274: AND
23275: IFFALSE 23436
// begin sort := SortBySkill ( tmp , 2 ) ;
23277: LD_ADDR_VAR 0 9
23281: PUSH
23282: LD_VAR 0 4
23286: PPUSH
23287: LD_INT 2
23289: PPUSH
23290: CALL 84904 0 2
23294: ST_TO_ADDR
// p := [ ] ;
23295: LD_ADDR_VAR 0 11
23299: PUSH
23300: EMPTY
23301: ST_TO_ADDR
// if sort then
23302: LD_VAR 0 9
23306: IFFALSE 23405
// for i = 1 to 4 - eng do
23308: LD_ADDR_VAR 0 3
23312: PUSH
23313: DOUBLE
23314: LD_INT 1
23316: DEC
23317: ST_TO_ADDR
23318: LD_INT 4
23320: PUSH
23321: LD_VAR 0 6
23325: MINUS
23326: PUSH
23327: FOR_TO
23328: IFFALSE 23403
// begin if i = sort then
23330: LD_VAR 0 3
23334: PUSH
23335: LD_VAR 0 9
23339: EQUAL
23340: IFFALSE 23344
// break ;
23342: GO 23403
// p := Insert ( p , p + 1 , sort [ i ] ) ;
23344: LD_ADDR_VAR 0 11
23348: PUSH
23349: LD_VAR 0 11
23353: PPUSH
23354: LD_VAR 0 11
23358: PUSH
23359: LD_INT 1
23361: PLUS
23362: PPUSH
23363: LD_VAR 0 9
23367: PUSH
23368: LD_VAR 0 3
23372: ARRAY
23373: PPUSH
23374: CALL_OW 2
23378: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
23379: LD_ADDR_VAR 0 4
23383: PUSH
23384: LD_VAR 0 4
23388: PUSH
23389: LD_VAR 0 9
23393: PUSH
23394: LD_VAR 0 3
23398: ARRAY
23399: DIFF
23400: ST_TO_ADDR
// end ;
23401: GO 23327
23403: POP
23404: POP
// if p then
23405: LD_VAR 0 11
23409: IFFALSE 23434
// result := Replace ( result , 2 , p ) ;
23411: LD_ADDR_VAR 0 2
23415: PUSH
23416: LD_VAR 0 2
23420: PPUSH
23421: LD_INT 2
23423: PPUSH
23424: LD_VAR 0 11
23428: PPUSH
23429: CALL_OW 1
23433: ST_TO_ADDR
// end else
23434: GO 23480
// for i = eng downto 5 do
23436: LD_ADDR_VAR 0 3
23440: PUSH
23441: DOUBLE
23442: LD_VAR 0 6
23446: INC
23447: ST_TO_ADDR
23448: LD_INT 5
23450: PUSH
23451: FOR_DOWNTO
23452: IFFALSE 23478
// tmp := tmp union eng [ i ] ;
23454: LD_ADDR_VAR 0 4
23458: PUSH
23459: LD_VAR 0 4
23463: PUSH
23464: LD_VAR 0 6
23468: PUSH
23469: LD_VAR 0 3
23473: ARRAY
23474: UNION
23475: ST_TO_ADDR
23476: GO 23451
23478: POP
23479: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
23480: LD_ADDR_VAR 0 2
23484: PUSH
23485: LD_VAR 0 2
23489: PPUSH
23490: LD_INT 1
23492: PPUSH
23493: LD_VAR 0 4
23497: PUSH
23498: LD_VAR 0 5
23502: DIFF
23503: PPUSH
23504: CALL_OW 1
23508: ST_TO_ADDR
// exit ;
23509: GO 23511
// end ; end ;
23511: LD_VAR 0 2
23515: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
23516: LD_INT 0
23518: PPUSH
23519: PPUSH
23520: PPUSH
// if not mc_bases then
23521: LD_EXP 50
23525: NOT
23526: IFFALSE 23530
// exit ;
23528: GO 23636
// for i = 1 to mc_bases do
23530: LD_ADDR_VAR 0 2
23534: PUSH
23535: DOUBLE
23536: LD_INT 1
23538: DEC
23539: ST_TO_ADDR
23540: LD_EXP 50
23544: PUSH
23545: FOR_TO
23546: IFFALSE 23627
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
23548: LD_ADDR_VAR 0 3
23552: PUSH
23553: LD_EXP 50
23557: PUSH
23558: LD_VAR 0 2
23562: ARRAY
23563: PPUSH
23564: LD_INT 21
23566: PUSH
23567: LD_INT 3
23569: PUSH
23570: EMPTY
23571: LIST
23572: LIST
23573: PUSH
23574: LD_INT 3
23576: PUSH
23577: LD_INT 24
23579: PUSH
23580: LD_INT 1000
23582: PUSH
23583: EMPTY
23584: LIST
23585: LIST
23586: PUSH
23587: EMPTY
23588: LIST
23589: LIST
23590: PUSH
23591: EMPTY
23592: LIST
23593: LIST
23594: PPUSH
23595: CALL_OW 72
23599: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
23600: LD_ADDR_EXP 51
23604: PUSH
23605: LD_EXP 51
23609: PPUSH
23610: LD_VAR 0 2
23614: PPUSH
23615: LD_VAR 0 3
23619: PPUSH
23620: CALL_OW 1
23624: ST_TO_ADDR
// end ;
23625: GO 23545
23627: POP
23628: POP
// RaiseSailEvent ( 101 ) ;
23629: LD_INT 101
23631: PPUSH
23632: CALL_OW 427
// end ;
23636: LD_VAR 0 1
23640: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
23641: LD_INT 0
23643: PPUSH
23644: PPUSH
23645: PPUSH
23646: PPUSH
23647: PPUSH
23648: PPUSH
23649: PPUSH
// if not mc_bases then
23650: LD_EXP 50
23654: NOT
23655: IFFALSE 23659
// exit ;
23657: GO 24194
// for i = 1 to mc_bases do
23659: LD_ADDR_VAR 0 2
23663: PUSH
23664: DOUBLE
23665: LD_INT 1
23667: DEC
23668: ST_TO_ADDR
23669: LD_EXP 50
23673: PUSH
23674: FOR_TO
23675: IFFALSE 24185
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 700 ] ] ] ] ) ;
23677: LD_ADDR_VAR 0 5
23681: PUSH
23682: LD_EXP 50
23686: PUSH
23687: LD_VAR 0 2
23691: ARRAY
23692: PUSH
23693: LD_EXP 79
23697: PUSH
23698: LD_VAR 0 2
23702: ARRAY
23703: UNION
23704: PPUSH
23705: LD_INT 21
23707: PUSH
23708: LD_INT 1
23710: PUSH
23711: EMPTY
23712: LIST
23713: LIST
23714: PUSH
23715: LD_INT 1
23717: PUSH
23718: LD_INT 3
23720: PUSH
23721: LD_INT 54
23723: PUSH
23724: EMPTY
23725: LIST
23726: PUSH
23727: EMPTY
23728: LIST
23729: LIST
23730: PUSH
23731: LD_INT 3
23733: PUSH
23734: LD_INT 24
23736: PUSH
23737: LD_INT 700
23739: PUSH
23740: EMPTY
23741: LIST
23742: LIST
23743: PUSH
23744: EMPTY
23745: LIST
23746: LIST
23747: PUSH
23748: EMPTY
23749: LIST
23750: LIST
23751: LIST
23752: PUSH
23753: EMPTY
23754: LIST
23755: LIST
23756: PPUSH
23757: CALL_OW 72
23761: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
23762: LD_ADDR_VAR 0 6
23766: PUSH
23767: LD_EXP 50
23771: PUSH
23772: LD_VAR 0 2
23776: ARRAY
23777: PPUSH
23778: LD_INT 21
23780: PUSH
23781: LD_INT 1
23783: PUSH
23784: EMPTY
23785: LIST
23786: LIST
23787: PUSH
23788: LD_INT 1
23790: PUSH
23791: LD_INT 3
23793: PUSH
23794: LD_INT 54
23796: PUSH
23797: EMPTY
23798: LIST
23799: PUSH
23800: EMPTY
23801: LIST
23802: LIST
23803: PUSH
23804: LD_INT 3
23806: PUSH
23807: LD_INT 24
23809: PUSH
23810: LD_INT 250
23812: PUSH
23813: EMPTY
23814: LIST
23815: LIST
23816: PUSH
23817: EMPTY
23818: LIST
23819: LIST
23820: PUSH
23821: EMPTY
23822: LIST
23823: LIST
23824: LIST
23825: PUSH
23826: EMPTY
23827: LIST
23828: LIST
23829: PPUSH
23830: CALL_OW 72
23834: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
23835: LD_ADDR_VAR 0 7
23839: PUSH
23840: LD_VAR 0 5
23844: PUSH
23845: LD_VAR 0 6
23849: DIFF
23850: ST_TO_ADDR
// if not need_heal_1 then
23851: LD_VAR 0 6
23855: NOT
23856: IFFALSE 23889
// mc_need_heal := Add ( mc_need_heal , [ i , 1 ] , [ ] ) else
23858: LD_ADDR_EXP 53
23862: PUSH
23863: LD_EXP 53
23867: PPUSH
23868: LD_VAR 0 2
23872: PUSH
23873: LD_INT 1
23875: PUSH
23876: EMPTY
23877: LIST
23878: LIST
23879: PPUSH
23880: EMPTY
23881: PPUSH
23882: CALL 51308 0 3
23886: ST_TO_ADDR
23887: GO 23921
// mc_need_heal := Add ( mc_need_heal , [ i , 1 ] , need_heal_1 ) ;
23889: LD_ADDR_EXP 53
23893: PUSH
23894: LD_EXP 53
23898: PPUSH
23899: LD_VAR 0 2
23903: PUSH
23904: LD_INT 1
23906: PUSH
23907: EMPTY
23908: LIST
23909: LIST
23910: PPUSH
23911: LD_VAR 0 6
23915: PPUSH
23916: CALL 51308 0 3
23920: ST_TO_ADDR
// if not need_heal_2 then
23921: LD_VAR 0 7
23925: NOT
23926: IFFALSE 23959
// mc_need_heal := Add ( mc_need_heal , [ i , 2 ] , [ ] ) else
23928: LD_ADDR_EXP 53
23932: PUSH
23933: LD_EXP 53
23937: PPUSH
23938: LD_VAR 0 2
23942: PUSH
23943: LD_INT 2
23945: PUSH
23946: EMPTY
23947: LIST
23948: LIST
23949: PPUSH
23950: EMPTY
23951: PPUSH
23952: CALL 51308 0 3
23956: ST_TO_ADDR
23957: GO 23991
// mc_need_heal := Add ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
23959: LD_ADDR_EXP 53
23963: PUSH
23964: LD_EXP 53
23968: PPUSH
23969: LD_VAR 0 2
23973: PUSH
23974: LD_INT 2
23976: PUSH
23977: EMPTY
23978: LIST
23979: LIST
23980: PPUSH
23981: LD_VAR 0 7
23985: PPUSH
23986: CALL 51308 0 3
23990: ST_TO_ADDR
// if need_heal_2 then
23991: LD_VAR 0 7
23995: IFFALSE 24167
// for j in need_heal_2 do
23997: LD_ADDR_VAR 0 3
24001: PUSH
24002: LD_VAR 0 7
24006: PUSH
24007: FOR_IN
24008: IFFALSE 24165
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
24010: LD_ADDR_VAR 0 5
24014: PUSH
24015: LD_EXP 50
24019: PUSH
24020: LD_VAR 0 2
24024: ARRAY
24025: PPUSH
24026: LD_INT 2
24028: PUSH
24029: LD_INT 30
24031: PUSH
24032: LD_INT 6
24034: PUSH
24035: EMPTY
24036: LIST
24037: LIST
24038: PUSH
24039: LD_INT 30
24041: PUSH
24042: LD_INT 7
24044: PUSH
24045: EMPTY
24046: LIST
24047: LIST
24048: PUSH
24049: LD_INT 30
24051: PUSH
24052: LD_INT 8
24054: PUSH
24055: EMPTY
24056: LIST
24057: LIST
24058: PUSH
24059: LD_INT 30
24061: PUSH
24062: LD_INT 0
24064: PUSH
24065: EMPTY
24066: LIST
24067: LIST
24068: PUSH
24069: LD_INT 30
24071: PUSH
24072: LD_INT 1
24074: PUSH
24075: EMPTY
24076: LIST
24077: LIST
24078: PUSH
24079: LD_INT 25
24081: PUSH
24082: LD_INT 4
24084: PUSH
24085: EMPTY
24086: LIST
24087: LIST
24088: PUSH
24089: EMPTY
24090: LIST
24091: LIST
24092: LIST
24093: LIST
24094: LIST
24095: LIST
24096: LIST
24097: PPUSH
24098: CALL_OW 72
24102: ST_TO_ADDR
// if tmp then
24103: LD_VAR 0 5
24107: IFFALSE 24163
// begin k := NearestUnitToUnit ( tmp , j ) ;
24109: LD_ADDR_VAR 0 4
24113: PUSH
24114: LD_VAR 0 5
24118: PPUSH
24119: LD_VAR 0 3
24123: PPUSH
24124: CALL_OW 74
24128: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
24129: LD_VAR 0 3
24133: PPUSH
24134: LD_VAR 0 4
24138: PPUSH
24139: CALL_OW 296
24143: PUSH
24144: LD_INT 7
24146: GREATER
24147: IFFALSE 24163
// ComMoveUnit ( j , k ) ;
24149: LD_VAR 0 3
24153: PPUSH
24154: LD_VAR 0 4
24158: PPUSH
24159: CALL_OW 112
// end ; end ;
24163: GO 24007
24165: POP
24166: POP
// if not need_heal_1 and not need_heal_2 then
24167: LD_VAR 0 6
24171: NOT
24172: PUSH
24173: LD_VAR 0 7
24177: NOT
24178: AND
24179: IFFALSE 24183
// continue ;
24181: GO 23674
// end ;
24183: GO 23674
24185: POP
24186: POP
// RaiseSailEvent ( 102 ) ;
24187: LD_INT 102
24189: PPUSH
24190: CALL_OW 427
// end ;
24194: LD_VAR 0 1
24198: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
24199: LD_INT 0
24201: PPUSH
24202: PPUSH
24203: PPUSH
24204: PPUSH
24205: PPUSH
// if not mc_bases then
24206: LD_EXP 50
24210: NOT
24211: IFFALSE 24215
// exit ;
24213: GO 24600
// for i = 1 to mc_bases do
24215: LD_ADDR_VAR 0 2
24219: PUSH
24220: DOUBLE
24221: LD_INT 1
24223: DEC
24224: ST_TO_ADDR
24225: LD_EXP 50
24229: PUSH
24230: FOR_TO
24231: IFFALSE 24598
// begin if not mc_building_need_repair [ i ] then
24233: LD_EXP 51
24237: PUSH
24238: LD_VAR 0 2
24242: ARRAY
24243: NOT
24244: IFFALSE 24282
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
24246: LD_ADDR_EXP 52
24250: PUSH
24251: LD_EXP 52
24255: PPUSH
24256: LD_VAR 0 2
24260: PPUSH
24261: EMPTY
24262: PPUSH
24263: CALL_OW 1
24267: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
24268: LD_VAR 0 2
24272: PPUSH
24273: LD_INT 101
24275: PPUSH
24276: CALL 19681 0 2
// continue ;
24280: GO 24230
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
24282: LD_ADDR_EXP 56
24286: PUSH
24287: LD_EXP 56
24291: PPUSH
24292: LD_VAR 0 2
24296: PPUSH
24297: EMPTY
24298: PPUSH
24299: CALL_OW 1
24303: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
24304: LD_VAR 0 2
24308: PPUSH
24309: LD_INT 103
24311: PPUSH
24312: CALL 19681 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
24316: LD_ADDR_VAR 0 5
24320: PUSH
24321: LD_EXP 50
24325: PUSH
24326: LD_VAR 0 2
24330: ARRAY
24331: PUSH
24332: LD_EXP 79
24336: PUSH
24337: LD_VAR 0 2
24341: ARRAY
24342: UNION
24343: PPUSH
24344: LD_INT 2
24346: PUSH
24347: LD_INT 25
24349: PUSH
24350: LD_INT 2
24352: PUSH
24353: EMPTY
24354: LIST
24355: LIST
24356: PUSH
24357: LD_INT 25
24359: PUSH
24360: LD_INT 16
24362: PUSH
24363: EMPTY
24364: LIST
24365: LIST
24366: PUSH
24367: EMPTY
24368: LIST
24369: LIST
24370: LIST
24371: PUSH
24372: EMPTY
24373: LIST
24374: PPUSH
24375: CALL_OW 72
24379: ST_TO_ADDR
// if not tmp then
24380: LD_VAR 0 5
24384: NOT
24385: IFFALSE 24389
// continue ;
24387: GO 24230
// for j in tmp do
24389: LD_ADDR_VAR 0 3
24393: PUSH
24394: LD_VAR 0 5
24398: PUSH
24399: FOR_IN
24400: IFFALSE 24594
// begin if mc_need_heal [ i ] then
24402: LD_EXP 53
24406: PUSH
24407: LD_VAR 0 2
24411: ARRAY
24412: IFFALSE 24460
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
24414: LD_VAR 0 3
24418: PUSH
24419: LD_EXP 53
24423: PUSH
24424: LD_VAR 0 2
24428: ARRAY
24429: PUSH
24430: LD_INT 1
24432: ARRAY
24433: IN
24434: PUSH
24435: LD_VAR 0 3
24439: PUSH
24440: LD_EXP 53
24444: PUSH
24445: LD_VAR 0 2
24449: ARRAY
24450: PUSH
24451: LD_INT 2
24453: ARRAY
24454: IN
24455: OR
24456: IFFALSE 24460
// continue ;
24458: GO 24399
// if IsInUnit ( j ) then
24460: LD_VAR 0 3
24464: PPUSH
24465: CALL_OW 310
24469: IFFALSE 24480
// ComExitBuilding ( j ) ;
24471: LD_VAR 0 3
24475: PPUSH
24476: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
24480: LD_VAR 0 3
24484: PUSH
24485: LD_EXP 52
24489: PUSH
24490: LD_VAR 0 2
24494: ARRAY
24495: IN
24496: NOT
24497: IFFALSE 24555
// begin SetTag ( j , 101 ) ;
24499: LD_VAR 0 3
24503: PPUSH
24504: LD_INT 101
24506: PPUSH
24507: CALL_OW 109
// mc_building_repairs := Add ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
24511: LD_ADDR_EXP 52
24515: PUSH
24516: LD_EXP 52
24520: PPUSH
24521: LD_VAR 0 2
24525: PUSH
24526: LD_EXP 52
24530: PUSH
24531: LD_VAR 0 2
24535: ARRAY
24536: PUSH
24537: LD_INT 1
24539: PLUS
24540: PUSH
24541: EMPTY
24542: LIST
24543: LIST
24544: PPUSH
24545: LD_VAR 0 3
24549: PPUSH
24550: CALL 51308 0 3
24554: ST_TO_ADDR
// end ; Wait ( 3 ) ;
24555: LD_INT 3
24557: PPUSH
24558: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
24562: LD_VAR 0 3
24566: PPUSH
24567: LD_EXP 51
24571: PUSH
24572: LD_VAR 0 2
24576: ARRAY
24577: PPUSH
24578: LD_VAR 0 3
24582: PPUSH
24583: CALL_OW 74
24587: PPUSH
24588: CALL_OW 130
// end ;
24592: GO 24399
24594: POP
24595: POP
// end ;
24596: GO 24230
24598: POP
24599: POP
// end ;
24600: LD_VAR 0 1
24604: RET
// export function MC_Heal ; var i , j , tmp ; begin
24605: LD_INT 0
24607: PPUSH
24608: PPUSH
24609: PPUSH
24610: PPUSH
// if not mc_bases then
24611: LD_EXP 50
24615: NOT
24616: IFFALSE 24620
// exit ;
24618: GO 25022
// for i = 1 to mc_bases do
24620: LD_ADDR_VAR 0 2
24624: PUSH
24625: DOUBLE
24626: LD_INT 1
24628: DEC
24629: ST_TO_ADDR
24630: LD_EXP 50
24634: PUSH
24635: FOR_TO
24636: IFFALSE 25020
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
24638: LD_EXP 53
24642: PUSH
24643: LD_VAR 0 2
24647: ARRAY
24648: PUSH
24649: LD_INT 1
24651: ARRAY
24652: NOT
24653: PUSH
24654: LD_EXP 53
24658: PUSH
24659: LD_VAR 0 2
24663: ARRAY
24664: PUSH
24665: LD_INT 2
24667: ARRAY
24668: NOT
24669: AND
24670: IFFALSE 24708
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
24672: LD_ADDR_EXP 54
24676: PUSH
24677: LD_EXP 54
24681: PPUSH
24682: LD_VAR 0 2
24686: PPUSH
24687: EMPTY
24688: PPUSH
24689: CALL_OW 1
24693: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
24694: LD_VAR 0 2
24698: PPUSH
24699: LD_INT 102
24701: PPUSH
24702: CALL 19681 0 2
// continue ;
24706: GO 24635
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
24708: LD_ADDR_VAR 0 4
24712: PUSH
24713: LD_EXP 50
24717: PUSH
24718: LD_VAR 0 2
24722: ARRAY
24723: PPUSH
24724: LD_INT 25
24726: PUSH
24727: LD_INT 4
24729: PUSH
24730: EMPTY
24731: LIST
24732: LIST
24733: PPUSH
24734: CALL_OW 72
24738: ST_TO_ADDR
// if not tmp then
24739: LD_VAR 0 4
24743: NOT
24744: IFFALSE 24748
// continue ;
24746: GO 24635
// if mc_taming [ i ] then
24748: LD_EXP 81
24752: PUSH
24753: LD_VAR 0 2
24757: ARRAY
24758: IFFALSE 24782
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
24760: LD_ADDR_EXP 81
24764: PUSH
24765: LD_EXP 81
24769: PPUSH
24770: LD_VAR 0 2
24774: PPUSH
24775: EMPTY
24776: PPUSH
24777: CALL_OW 1
24781: ST_TO_ADDR
// for j in tmp do
24782: LD_ADDR_VAR 0 3
24786: PUSH
24787: LD_VAR 0 4
24791: PUSH
24792: FOR_IN
24793: IFFALSE 25016
// begin if IsInUnit ( j ) then
24795: LD_VAR 0 3
24799: PPUSH
24800: CALL_OW 310
24804: IFFALSE 24815
// ComExitBuilding ( j ) ;
24806: LD_VAR 0 3
24810: PPUSH
24811: CALL_OW 122
// if not j in mc_healers [ i ] then
24815: LD_VAR 0 3
24819: PUSH
24820: LD_EXP 54
24824: PUSH
24825: LD_VAR 0 2
24829: ARRAY
24830: IN
24831: NOT
24832: IFFALSE 24878
// mc_healers := Add ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
24834: LD_ADDR_EXP 54
24838: PUSH
24839: LD_EXP 54
24843: PPUSH
24844: LD_VAR 0 2
24848: PUSH
24849: LD_EXP 54
24853: PUSH
24854: LD_VAR 0 2
24858: ARRAY
24859: PUSH
24860: LD_INT 1
24862: PLUS
24863: PUSH
24864: EMPTY
24865: LIST
24866: LIST
24867: PPUSH
24868: LD_VAR 0 3
24872: PPUSH
24873: CALL 51308 0 3
24877: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
24878: LD_VAR 0 3
24882: PPUSH
24883: CALL_OW 110
24887: PUSH
24888: LD_INT 102
24890: NONEQUAL
24891: IFFALSE 24905
// SetTag ( j , 102 ) ;
24893: LD_VAR 0 3
24897: PPUSH
24898: LD_INT 102
24900: PPUSH
24901: CALL_OW 109
// Wait ( 3 ) ;
24905: LD_INT 3
24907: PPUSH
24908: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
24912: LD_EXP 53
24916: PUSH
24917: LD_VAR 0 2
24921: ARRAY
24922: PUSH
24923: LD_INT 1
24925: ARRAY
24926: IFFALSE 24958
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
24928: LD_VAR 0 3
24932: PPUSH
24933: LD_EXP 53
24937: PUSH
24938: LD_VAR 0 2
24942: ARRAY
24943: PUSH
24944: LD_INT 1
24946: ARRAY
24947: PUSH
24948: LD_INT 1
24950: ARRAY
24951: PPUSH
24952: CALL_OW 128
24956: GO 25014
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
24958: LD_VAR 0 3
24962: PPUSH
24963: CALL_OW 314
24967: NOT
24968: PUSH
24969: LD_EXP 53
24973: PUSH
24974: LD_VAR 0 2
24978: ARRAY
24979: PUSH
24980: LD_INT 2
24982: ARRAY
24983: AND
24984: IFFALSE 25014
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
24986: LD_VAR 0 3
24990: PPUSH
24991: LD_EXP 53
24995: PUSH
24996: LD_VAR 0 2
25000: ARRAY
25001: PUSH
25002: LD_INT 2
25004: ARRAY
25005: PUSH
25006: LD_INT 1
25008: ARRAY
25009: PPUSH
25010: CALL_OW 128
// end ;
25014: GO 24792
25016: POP
25017: POP
// end ;
25018: GO 24635
25020: POP
25021: POP
// end ;
25022: LD_VAR 0 1
25026: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
25027: LD_INT 0
25029: PPUSH
25030: PPUSH
25031: PPUSH
25032: PPUSH
25033: PPUSH
// if not mc_bases then
25034: LD_EXP 50
25038: NOT
25039: IFFALSE 25043
// exit ;
25041: GO 26186
// for i = 1 to mc_bases do
25043: LD_ADDR_VAR 0 2
25047: PUSH
25048: DOUBLE
25049: LD_INT 1
25051: DEC
25052: ST_TO_ADDR
25053: LD_EXP 50
25057: PUSH
25058: FOR_TO
25059: IFFALSE 26184
// begin if mc_scan [ i ] then
25061: LD_EXP 73
25065: PUSH
25066: LD_VAR 0 2
25070: ARRAY
25071: IFFALSE 25075
// continue ;
25073: GO 25058
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
25075: LD_EXP 55
25079: PUSH
25080: LD_VAR 0 2
25084: ARRAY
25085: NOT
25086: PUSH
25087: LD_EXP 57
25091: PUSH
25092: LD_VAR 0 2
25096: ARRAY
25097: NOT
25098: AND
25099: PUSH
25100: LD_EXP 56
25104: PUSH
25105: LD_VAR 0 2
25109: ARRAY
25110: AND
25111: IFFALSE 25149
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
25113: LD_ADDR_EXP 56
25117: PUSH
25118: LD_EXP 56
25122: PPUSH
25123: LD_VAR 0 2
25127: PPUSH
25128: EMPTY
25129: PPUSH
25130: CALL_OW 1
25134: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
25135: LD_VAR 0 2
25139: PPUSH
25140: LD_INT 103
25142: PPUSH
25143: CALL 19681 0 2
// continue ;
25147: GO 25058
// end ; if mc_construct_list [ i ] then
25149: LD_EXP 57
25153: PUSH
25154: LD_VAR 0 2
25158: ARRAY
25159: IFFALSE 25379
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
25161: LD_ADDR_VAR 0 4
25165: PUSH
25166: LD_EXP 50
25170: PUSH
25171: LD_VAR 0 2
25175: ARRAY
25176: PPUSH
25177: LD_INT 25
25179: PUSH
25180: LD_INT 2
25182: PUSH
25183: EMPTY
25184: LIST
25185: LIST
25186: PPUSH
25187: CALL_OW 72
25191: PUSH
25192: LD_EXP 52
25196: PUSH
25197: LD_VAR 0 2
25201: ARRAY
25202: DIFF
25203: ST_TO_ADDR
// if not tmp then
25204: LD_VAR 0 4
25208: NOT
25209: IFFALSE 25213
// continue ;
25211: GO 25058
// for j in tmp do
25213: LD_ADDR_VAR 0 3
25217: PUSH
25218: LD_VAR 0 4
25222: PUSH
25223: FOR_IN
25224: IFFALSE 25375
// begin if not mc_builders [ i ] then
25226: LD_EXP 56
25230: PUSH
25231: LD_VAR 0 2
25235: ARRAY
25236: NOT
25237: IFFALSE 25295
// begin SetTag ( j , 103 ) ;
25239: LD_VAR 0 3
25243: PPUSH
25244: LD_INT 103
25246: PPUSH
25247: CALL_OW 109
// mc_builders := Add ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
25251: LD_ADDR_EXP 56
25255: PUSH
25256: LD_EXP 56
25260: PPUSH
25261: LD_VAR 0 2
25265: PUSH
25266: LD_EXP 56
25270: PUSH
25271: LD_VAR 0 2
25275: ARRAY
25276: PUSH
25277: LD_INT 1
25279: PLUS
25280: PUSH
25281: EMPTY
25282: LIST
25283: LIST
25284: PPUSH
25285: LD_VAR 0 3
25289: PPUSH
25290: CALL 51308 0 3
25294: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
25295: LD_VAR 0 3
25299: PPUSH
25300: CALL_OW 310
25304: IFFALSE 25315
// ComExitBuilding ( j ) ;
25306: LD_VAR 0 3
25310: PPUSH
25311: CALL_OW 122
// wait ( 3 ) ;
25315: LD_INT 3
25317: PPUSH
25318: CALL_OW 67
// if not mc_construct_list [ i ] then
25322: LD_EXP 57
25326: PUSH
25327: LD_VAR 0 2
25331: ARRAY
25332: NOT
25333: IFFALSE 25337
// break ;
25335: GO 25375
// if not HasTask ( j ) then
25337: LD_VAR 0 3
25341: PPUSH
25342: CALL_OW 314
25346: NOT
25347: IFFALSE 25373
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
25349: LD_VAR 0 3
25353: PPUSH
25354: LD_EXP 57
25358: PUSH
25359: LD_VAR 0 2
25363: ARRAY
25364: PUSH
25365: LD_INT 1
25367: ARRAY
25368: PPUSH
25369: CALL 53757 0 2
// end ;
25373: GO 25223
25375: POP
25376: POP
// end else
25377: GO 26182
// if mc_build_list [ i ] then
25379: LD_EXP 55
25383: PUSH
25384: LD_VAR 0 2
25388: ARRAY
25389: IFFALSE 26182
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
25391: LD_ADDR_VAR 0 5
25395: PUSH
25396: LD_EXP 50
25400: PUSH
25401: LD_VAR 0 2
25405: ARRAY
25406: PPUSH
25407: LD_INT 2
25409: PUSH
25410: LD_INT 30
25412: PUSH
25413: LD_INT 0
25415: PUSH
25416: EMPTY
25417: LIST
25418: LIST
25419: PUSH
25420: LD_INT 30
25422: PUSH
25423: LD_INT 1
25425: PUSH
25426: EMPTY
25427: LIST
25428: LIST
25429: PUSH
25430: EMPTY
25431: LIST
25432: LIST
25433: LIST
25434: PPUSH
25435: CALL_OW 72
25439: ST_TO_ADDR
// if depot then
25440: LD_VAR 0 5
25444: IFFALSE 25462
// depot := depot [ 1 ] else
25446: LD_ADDR_VAR 0 5
25450: PUSH
25451: LD_VAR 0 5
25455: PUSH
25456: LD_INT 1
25458: ARRAY
25459: ST_TO_ADDR
25460: GO 25470
// depot := 0 ;
25462: LD_ADDR_VAR 0 5
25466: PUSH
25467: LD_INT 0
25469: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
25470: LD_EXP 55
25474: PUSH
25475: LD_VAR 0 2
25479: ARRAY
25480: PUSH
25481: LD_INT 1
25483: ARRAY
25484: PUSH
25485: LD_INT 1
25487: ARRAY
25488: PPUSH
25489: CALL 53587 0 1
25493: PUSH
25494: LD_EXP 50
25498: PUSH
25499: LD_VAR 0 2
25503: ARRAY
25504: PPUSH
25505: LD_INT 2
25507: PUSH
25508: LD_INT 30
25510: PUSH
25511: LD_INT 2
25513: PUSH
25514: EMPTY
25515: LIST
25516: LIST
25517: PUSH
25518: LD_INT 30
25520: PUSH
25521: LD_INT 3
25523: PUSH
25524: EMPTY
25525: LIST
25526: LIST
25527: PUSH
25528: EMPTY
25529: LIST
25530: LIST
25531: LIST
25532: PPUSH
25533: CALL_OW 72
25537: NOT
25538: AND
25539: IFFALSE 25644
// begin for j = 1 to mc_build_list [ i ] do
25541: LD_ADDR_VAR 0 3
25545: PUSH
25546: DOUBLE
25547: LD_INT 1
25549: DEC
25550: ST_TO_ADDR
25551: LD_EXP 55
25555: PUSH
25556: LD_VAR 0 2
25560: ARRAY
25561: PUSH
25562: FOR_TO
25563: IFFALSE 25642
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
25565: LD_EXP 55
25569: PUSH
25570: LD_VAR 0 2
25574: ARRAY
25575: PUSH
25576: LD_VAR 0 3
25580: ARRAY
25581: PUSH
25582: LD_INT 1
25584: ARRAY
25585: PUSH
25586: LD_INT 2
25588: EQUAL
25589: IFFALSE 25640
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
25591: LD_ADDR_EXP 55
25595: PUSH
25596: LD_EXP 55
25600: PPUSH
25601: LD_VAR 0 2
25605: PPUSH
25606: LD_EXP 55
25610: PUSH
25611: LD_VAR 0 2
25615: ARRAY
25616: PPUSH
25617: LD_VAR 0 3
25621: PPUSH
25622: LD_INT 1
25624: PPUSH
25625: LD_INT 0
25627: PPUSH
25628: CALL 50291 0 4
25632: PPUSH
25633: CALL_OW 1
25637: ST_TO_ADDR
// break ;
25638: GO 25642
// end ;
25640: GO 25562
25642: POP
25643: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
25644: LD_EXP 55
25648: PUSH
25649: LD_VAR 0 2
25653: ARRAY
25654: PUSH
25655: LD_INT 1
25657: ARRAY
25658: PUSH
25659: LD_INT 1
25661: ARRAY
25662: PUSH
25663: LD_INT 0
25665: EQUAL
25666: PUSH
25667: LD_VAR 0 5
25671: PUSH
25672: LD_VAR 0 5
25676: PPUSH
25677: LD_EXP 55
25681: PUSH
25682: LD_VAR 0 2
25686: ARRAY
25687: PUSH
25688: LD_INT 1
25690: ARRAY
25691: PUSH
25692: LD_INT 1
25694: ARRAY
25695: PPUSH
25696: LD_EXP 55
25700: PUSH
25701: LD_VAR 0 2
25705: ARRAY
25706: PUSH
25707: LD_INT 1
25709: ARRAY
25710: PUSH
25711: LD_INT 2
25713: ARRAY
25714: PPUSH
25715: LD_EXP 55
25719: PUSH
25720: LD_VAR 0 2
25724: ARRAY
25725: PUSH
25726: LD_INT 1
25728: ARRAY
25729: PUSH
25730: LD_INT 3
25732: ARRAY
25733: PPUSH
25734: LD_EXP 55
25738: PUSH
25739: LD_VAR 0 2
25743: ARRAY
25744: PUSH
25745: LD_INT 1
25747: ARRAY
25748: PUSH
25749: LD_INT 4
25751: ARRAY
25752: PPUSH
25753: CALL 58124 0 5
25757: AND
25758: OR
25759: IFFALSE 26040
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
25761: LD_ADDR_VAR 0 4
25765: PUSH
25766: LD_EXP 50
25770: PUSH
25771: LD_VAR 0 2
25775: ARRAY
25776: PPUSH
25777: LD_INT 25
25779: PUSH
25780: LD_INT 2
25782: PUSH
25783: EMPTY
25784: LIST
25785: LIST
25786: PPUSH
25787: CALL_OW 72
25791: PUSH
25792: LD_EXP 52
25796: PUSH
25797: LD_VAR 0 2
25801: ARRAY
25802: DIFF
25803: ST_TO_ADDR
// if not tmp then
25804: LD_VAR 0 4
25808: NOT
25809: IFFALSE 25813
// continue ;
25811: GO 25058
// for j in tmp do
25813: LD_ADDR_VAR 0 3
25817: PUSH
25818: LD_VAR 0 4
25822: PUSH
25823: FOR_IN
25824: IFFALSE 26036
// begin if not mc_builders [ i ] then
25826: LD_EXP 56
25830: PUSH
25831: LD_VAR 0 2
25835: ARRAY
25836: NOT
25837: IFFALSE 25895
// begin SetTag ( j , 103 ) ;
25839: LD_VAR 0 3
25843: PPUSH
25844: LD_INT 103
25846: PPUSH
25847: CALL_OW 109
// mc_builders := Add ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
25851: LD_ADDR_EXP 56
25855: PUSH
25856: LD_EXP 56
25860: PPUSH
25861: LD_VAR 0 2
25865: PUSH
25866: LD_EXP 56
25870: PUSH
25871: LD_VAR 0 2
25875: ARRAY
25876: PUSH
25877: LD_INT 1
25879: PLUS
25880: PUSH
25881: EMPTY
25882: LIST
25883: LIST
25884: PPUSH
25885: LD_VAR 0 3
25889: PPUSH
25890: CALL 51308 0 3
25894: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
25895: LD_VAR 0 3
25899: PPUSH
25900: CALL_OW 310
25904: IFFALSE 25915
// ComExitBuilding ( j ) ;
25906: LD_VAR 0 3
25910: PPUSH
25911: CALL_OW 122
// wait ( 3 ) ;
25915: LD_INT 3
25917: PPUSH
25918: CALL_OW 67
// if not mc_build_list [ i ] then
25922: LD_EXP 55
25926: PUSH
25927: LD_VAR 0 2
25931: ARRAY
25932: NOT
25933: IFFALSE 25937
// break ;
25935: GO 26036
// if not HasTask ( j ) then
25937: LD_VAR 0 3
25941: PPUSH
25942: CALL_OW 314
25946: NOT
25947: IFFALSE 26034
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
25949: LD_VAR 0 3
25953: PPUSH
25954: LD_EXP 55
25958: PUSH
25959: LD_VAR 0 2
25963: ARRAY
25964: PUSH
25965: LD_INT 1
25967: ARRAY
25968: PUSH
25969: LD_INT 1
25971: ARRAY
25972: PPUSH
25973: LD_EXP 55
25977: PUSH
25978: LD_VAR 0 2
25982: ARRAY
25983: PUSH
25984: LD_INT 1
25986: ARRAY
25987: PUSH
25988: LD_INT 2
25990: ARRAY
25991: PPUSH
25992: LD_EXP 55
25996: PUSH
25997: LD_VAR 0 2
26001: ARRAY
26002: PUSH
26003: LD_INT 1
26005: ARRAY
26006: PUSH
26007: LD_INT 3
26009: ARRAY
26010: PPUSH
26011: LD_EXP 55
26015: PUSH
26016: LD_VAR 0 2
26020: ARRAY
26021: PUSH
26022: LD_INT 1
26024: ARRAY
26025: PUSH
26026: LD_INT 4
26028: ARRAY
26029: PPUSH
26030: CALL_OW 145
// end ;
26034: GO 25823
26036: POP
26037: POP
// end else
26038: GO 26182
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
26040: LD_EXP 50
26044: PUSH
26045: LD_VAR 0 2
26049: ARRAY
26050: PPUSH
26051: LD_EXP 55
26055: PUSH
26056: LD_VAR 0 2
26060: ARRAY
26061: PUSH
26062: LD_INT 1
26064: ARRAY
26065: PUSH
26066: LD_INT 1
26068: ARRAY
26069: PPUSH
26070: LD_EXP 55
26074: PUSH
26075: LD_VAR 0 2
26079: ARRAY
26080: PUSH
26081: LD_INT 1
26083: ARRAY
26084: PUSH
26085: LD_INT 2
26087: ARRAY
26088: PPUSH
26089: LD_EXP 55
26093: PUSH
26094: LD_VAR 0 2
26098: ARRAY
26099: PUSH
26100: LD_INT 1
26102: ARRAY
26103: PUSH
26104: LD_INT 3
26106: ARRAY
26107: PPUSH
26108: LD_EXP 55
26112: PUSH
26113: LD_VAR 0 2
26117: ARRAY
26118: PUSH
26119: LD_INT 1
26121: ARRAY
26122: PUSH
26123: LD_INT 4
26125: ARRAY
26126: PPUSH
26127: CALL 57555 0 5
26131: NOT
26132: IFFALSE 26182
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
26134: LD_ADDR_EXP 55
26138: PUSH
26139: LD_EXP 55
26143: PPUSH
26144: LD_VAR 0 2
26148: PPUSH
26149: LD_EXP 55
26153: PUSH
26154: LD_VAR 0 2
26158: ARRAY
26159: PPUSH
26160: LD_INT 1
26162: PPUSH
26163: LD_INT 1
26165: NEG
26166: PPUSH
26167: LD_INT 0
26169: PPUSH
26170: CALL 50291 0 4
26174: PPUSH
26175: CALL_OW 1
26179: ST_TO_ADDR
// continue ;
26180: GO 25058
// end ; end ; end ;
26182: GO 25058
26184: POP
26185: POP
// end ;
26186: LD_VAR 0 1
26190: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
26191: LD_INT 0
26193: PPUSH
26194: PPUSH
26195: PPUSH
26196: PPUSH
26197: PPUSH
26198: PPUSH
// if not mc_bases then
26199: LD_EXP 50
26203: NOT
26204: IFFALSE 26208
// exit ;
26206: GO 26635
// for i = 1 to mc_bases do
26208: LD_ADDR_VAR 0 2
26212: PUSH
26213: DOUBLE
26214: LD_INT 1
26216: DEC
26217: ST_TO_ADDR
26218: LD_EXP 50
26222: PUSH
26223: FOR_TO
26224: IFFALSE 26633
// begin tmp := mc_build_upgrade [ i ] ;
26226: LD_ADDR_VAR 0 4
26230: PUSH
26231: LD_EXP 82
26235: PUSH
26236: LD_VAR 0 2
26240: ARRAY
26241: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
26242: LD_ADDR_VAR 0 6
26246: PUSH
26247: LD_EXP 83
26251: PUSH
26252: LD_VAR 0 2
26256: ARRAY
26257: PPUSH
26258: LD_INT 2
26260: PUSH
26261: LD_INT 30
26263: PUSH
26264: LD_INT 6
26266: PUSH
26267: EMPTY
26268: LIST
26269: LIST
26270: PUSH
26271: LD_INT 30
26273: PUSH
26274: LD_INT 7
26276: PUSH
26277: EMPTY
26278: LIST
26279: LIST
26280: PUSH
26281: EMPTY
26282: LIST
26283: LIST
26284: LIST
26285: PPUSH
26286: CALL_OW 72
26290: ST_TO_ADDR
// if not tmp and not lab then
26291: LD_VAR 0 4
26295: NOT
26296: PUSH
26297: LD_VAR 0 6
26301: NOT
26302: AND
26303: IFFALSE 26307
// continue ;
26305: GO 26223
// if tmp then
26307: LD_VAR 0 4
26311: IFFALSE 26431
// for j in tmp do
26313: LD_ADDR_VAR 0 3
26317: PUSH
26318: LD_VAR 0 4
26322: PUSH
26323: FOR_IN
26324: IFFALSE 26429
// begin if UpgradeCost ( j ) then
26326: LD_VAR 0 3
26330: PPUSH
26331: CALL 57215 0 1
26335: IFFALSE 26427
// begin ComUpgrade ( j ) ;
26337: LD_VAR 0 3
26341: PPUSH
26342: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
26346: LD_ADDR_EXP 82
26350: PUSH
26351: LD_EXP 82
26355: PPUSH
26356: LD_VAR 0 2
26360: PPUSH
26361: LD_EXP 82
26365: PUSH
26366: LD_VAR 0 2
26370: ARRAY
26371: PUSH
26372: LD_VAR 0 3
26376: DIFF
26377: PPUSH
26378: CALL_OW 1
26382: ST_TO_ADDR
// mc_construct_list := Add ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
26383: LD_ADDR_EXP 57
26387: PUSH
26388: LD_EXP 57
26392: PPUSH
26393: LD_VAR 0 2
26397: PUSH
26398: LD_EXP 57
26402: PUSH
26403: LD_VAR 0 2
26407: ARRAY
26408: PUSH
26409: LD_INT 1
26411: PLUS
26412: PUSH
26413: EMPTY
26414: LIST
26415: LIST
26416: PPUSH
26417: LD_VAR 0 3
26421: PPUSH
26422: CALL 51308 0 3
26426: ST_TO_ADDR
// end ; end ;
26427: GO 26323
26429: POP
26430: POP
// if not lab or not mc_lab_upgrade [ i ] then
26431: LD_VAR 0 6
26435: NOT
26436: PUSH
26437: LD_EXP 84
26441: PUSH
26442: LD_VAR 0 2
26446: ARRAY
26447: NOT
26448: OR
26449: IFFALSE 26453
// continue ;
26451: GO 26223
// for j in lab do
26453: LD_ADDR_VAR 0 3
26457: PUSH
26458: LD_VAR 0 6
26462: PUSH
26463: FOR_IN
26464: IFFALSE 26629
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
26466: LD_VAR 0 3
26470: PPUSH
26471: CALL_OW 266
26475: PUSH
26476: LD_INT 6
26478: PUSH
26479: LD_INT 7
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: IN
26486: PUSH
26487: LD_VAR 0 3
26491: PPUSH
26492: CALL_OW 461
26496: PUSH
26497: LD_INT 1
26499: NONEQUAL
26500: AND
26501: IFFALSE 26627
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
26503: LD_VAR 0 3
26507: PPUSH
26508: LD_EXP 84
26512: PUSH
26513: LD_VAR 0 2
26517: ARRAY
26518: PUSH
26519: LD_INT 1
26521: ARRAY
26522: PPUSH
26523: CALL 57420 0 2
26527: IFFALSE 26627
// begin ComCancel ( j ) ;
26529: LD_VAR 0 3
26533: PPUSH
26534: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
26538: LD_VAR 0 3
26542: PPUSH
26543: LD_EXP 84
26547: PUSH
26548: LD_VAR 0 2
26552: ARRAY
26553: PUSH
26554: LD_INT 1
26556: ARRAY
26557: PPUSH
26558: CALL_OW 207
// if not j in mc_construct_list [ i ] then
26562: LD_VAR 0 3
26566: PUSH
26567: LD_EXP 57
26571: PUSH
26572: LD_VAR 0 2
26576: ARRAY
26577: IN
26578: NOT
26579: IFFALSE 26625
// mc_construct_list := Add ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
26581: LD_ADDR_EXP 57
26585: PUSH
26586: LD_EXP 57
26590: PPUSH
26591: LD_VAR 0 2
26595: PUSH
26596: LD_EXP 57
26600: PUSH
26601: LD_VAR 0 2
26605: ARRAY
26606: PUSH
26607: LD_INT 1
26609: PLUS
26610: PUSH
26611: EMPTY
26612: LIST
26613: LIST
26614: PPUSH
26615: LD_VAR 0 3
26619: PPUSH
26620: CALL 51308 0 3
26624: ST_TO_ADDR
// break ;
26625: GO 26629
// end ; end ; end ;
26627: GO 26463
26629: POP
26630: POP
// end ;
26631: GO 26223
26633: POP
26634: POP
// end ;
26635: LD_VAR 0 1
26639: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
26640: LD_INT 0
26642: PPUSH
26643: PPUSH
26644: PPUSH
26645: PPUSH
26646: PPUSH
26647: PPUSH
26648: PPUSH
26649: PPUSH
26650: PPUSH
// if not mc_bases then
26651: LD_EXP 50
26655: NOT
26656: IFFALSE 26660
// exit ;
26658: GO 27065
// for i = 1 to mc_bases do
26660: LD_ADDR_VAR 0 2
26664: PUSH
26665: DOUBLE
26666: LD_INT 1
26668: DEC
26669: ST_TO_ADDR
26670: LD_EXP 50
26674: PUSH
26675: FOR_TO
26676: IFFALSE 27063
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
26678: LD_EXP 58
26682: PUSH
26683: LD_VAR 0 2
26687: ARRAY
26688: NOT
26689: PUSH
26690: LD_EXP 50
26694: PUSH
26695: LD_VAR 0 2
26699: ARRAY
26700: PPUSH
26701: LD_INT 30
26703: PUSH
26704: LD_INT 3
26706: PUSH
26707: EMPTY
26708: LIST
26709: LIST
26710: PPUSH
26711: CALL_OW 72
26715: NOT
26716: OR
26717: IFFALSE 26721
// continue ;
26719: GO 26675
// busy := false ;
26721: LD_ADDR_VAR 0 8
26725: PUSH
26726: LD_INT 0
26728: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
26729: LD_ADDR_VAR 0 4
26733: PUSH
26734: LD_EXP 50
26738: PUSH
26739: LD_VAR 0 2
26743: ARRAY
26744: PPUSH
26745: LD_INT 30
26747: PUSH
26748: LD_INT 3
26750: PUSH
26751: EMPTY
26752: LIST
26753: LIST
26754: PPUSH
26755: CALL_OW 72
26759: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
26760: LD_ADDR_VAR 0 6
26764: PUSH
26765: LD_EXP 58
26769: PUSH
26770: LD_VAR 0 2
26774: ARRAY
26775: PPUSH
26776: LD_INT 2
26778: PUSH
26779: LD_INT 30
26781: PUSH
26782: LD_INT 32
26784: PUSH
26785: EMPTY
26786: LIST
26787: LIST
26788: PUSH
26789: LD_INT 30
26791: PUSH
26792: LD_INT 33
26794: PUSH
26795: EMPTY
26796: LIST
26797: LIST
26798: PUSH
26799: EMPTY
26800: LIST
26801: LIST
26802: LIST
26803: PPUSH
26804: CALL_OW 72
26808: ST_TO_ADDR
// if not t then
26809: LD_VAR 0 6
26813: NOT
26814: IFFALSE 26818
// continue ;
26816: GO 26675
// for j in tmp do
26818: LD_ADDR_VAR 0 3
26822: PUSH
26823: LD_VAR 0 4
26827: PUSH
26828: FOR_IN
26829: IFFALSE 26859
// if not BuildingStatus ( j ) = bs_idle then
26831: LD_VAR 0 3
26835: PPUSH
26836: CALL_OW 461
26840: PUSH
26841: LD_INT 2
26843: EQUAL
26844: NOT
26845: IFFALSE 26857
// begin busy := true ;
26847: LD_ADDR_VAR 0 8
26851: PUSH
26852: LD_INT 1
26854: ST_TO_ADDR
// break ;
26855: GO 26859
// end ;
26857: GO 26828
26859: POP
26860: POP
// if busy then
26861: LD_VAR 0 8
26865: IFFALSE 26869
// continue ;
26867: GO 26675
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
26869: LD_ADDR_VAR 0 7
26873: PUSH
26874: LD_VAR 0 6
26878: PPUSH
26879: LD_INT 35
26881: PUSH
26882: LD_INT 0
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: PPUSH
26889: CALL_OW 72
26893: ST_TO_ADDR
// if tw then
26894: LD_VAR 0 7
26898: IFFALSE 26975
// begin tw := tw [ 1 ] ;
26900: LD_ADDR_VAR 0 7
26904: PUSH
26905: LD_VAR 0 7
26909: PUSH
26910: LD_INT 1
26912: ARRAY
26913: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
26914: LD_ADDR_VAR 0 9
26918: PUSH
26919: LD_VAR 0 7
26923: PPUSH
26924: LD_EXP 75
26928: PUSH
26929: LD_VAR 0 2
26933: ARRAY
26934: PPUSH
26935: CALL 55774 0 2
26939: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
26940: LD_EXP 89
26944: PUSH
26945: LD_VAR 0 2
26949: ARRAY
26950: IFFALSE 26973
// if not weapon in mc_allowed_tower_weapons [ i ] then
26952: LD_VAR 0 9
26956: PUSH
26957: LD_EXP 89
26961: PUSH
26962: LD_VAR 0 2
26966: ARRAY
26967: IN
26968: NOT
26969: IFFALSE 26973
// continue ;
26971: GO 26675
// end else
26973: GO 27038
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
26975: LD_ADDR_VAR 0 5
26979: PUSH
26980: LD_EXP 58
26984: PUSH
26985: LD_VAR 0 2
26989: ARRAY
26990: PPUSH
26991: LD_VAR 0 4
26995: PPUSH
26996: CALL 85828 0 2
27000: ST_TO_ADDR
// if not tmp2 then
27001: LD_VAR 0 5
27005: NOT
27006: IFFALSE 27010
// continue ;
27008: GO 26675
// tw := tmp2 [ 1 ] ;
27010: LD_ADDR_VAR 0 7
27014: PUSH
27015: LD_VAR 0 5
27019: PUSH
27020: LD_INT 1
27022: ARRAY
27023: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
27024: LD_ADDR_VAR 0 9
27028: PUSH
27029: LD_VAR 0 5
27033: PUSH
27034: LD_INT 2
27036: ARRAY
27037: ST_TO_ADDR
// end ; if not weapon then
27038: LD_VAR 0 9
27042: NOT
27043: IFFALSE 27047
// continue ;
27045: GO 26675
// ComPlaceWeapon ( tw , weapon ) ;
27047: LD_VAR 0 7
27051: PPUSH
27052: LD_VAR 0 9
27056: PPUSH
27057: CALL_OW 148
// end ;
27061: GO 26675
27063: POP
27064: POP
// end ;
27065: LD_VAR 0 1
27069: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
27070: LD_INT 0
27072: PPUSH
27073: PPUSH
27074: PPUSH
27075: PPUSH
27076: PPUSH
27077: PPUSH
// if not mc_bases then
27078: LD_EXP 50
27082: NOT
27083: IFFALSE 27087
// exit ;
27085: GO 28099
// for i = 1 to mc_bases do
27087: LD_ADDR_VAR 0 2
27091: PUSH
27092: DOUBLE
27093: LD_INT 1
27095: DEC
27096: ST_TO_ADDR
27097: LD_EXP 50
27101: PUSH
27102: FOR_TO
27103: IFFALSE 28097
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
27105: LD_EXP 63
27109: PUSH
27110: LD_VAR 0 2
27114: ARRAY
27115: NOT
27116: PUSH
27117: LD_EXP 63
27121: PUSH
27122: LD_VAR 0 2
27126: ARRAY
27127: PUSH
27128: LD_EXP 64
27132: PUSH
27133: LD_VAR 0 2
27137: ARRAY
27138: EQUAL
27139: OR
27140: IFFALSE 27144
// continue ;
27142: GO 27102
// if mc_miners [ i ] then
27144: LD_EXP 64
27148: PUSH
27149: LD_VAR 0 2
27153: ARRAY
27154: IFFALSE 27784
// begin k := 1 ;
27156: LD_ADDR_VAR 0 4
27160: PUSH
27161: LD_INT 1
27163: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
27164: LD_ADDR_VAR 0 3
27168: PUSH
27169: DOUBLE
27170: LD_EXP 64
27174: PUSH
27175: LD_VAR 0 2
27179: ARRAY
27180: INC
27181: ST_TO_ADDR
27182: LD_INT 1
27184: PUSH
27185: FOR_DOWNTO
27186: IFFALSE 27782
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
27188: LD_EXP 64
27192: PUSH
27193: LD_VAR 0 2
27197: ARRAY
27198: PUSH
27199: LD_VAR 0 3
27203: ARRAY
27204: PPUSH
27205: CALL_OW 301
27209: PUSH
27210: LD_EXP 64
27214: PUSH
27215: LD_VAR 0 2
27219: ARRAY
27220: PUSH
27221: LD_VAR 0 3
27225: ARRAY
27226: PPUSH
27227: CALL_OW 257
27231: PUSH
27232: LD_INT 1
27234: NONEQUAL
27235: OR
27236: IFFALSE 27299
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
27238: LD_ADDR_VAR 0 5
27242: PUSH
27243: LD_EXP 64
27247: PUSH
27248: LD_VAR 0 2
27252: ARRAY
27253: PUSH
27254: LD_EXP 64
27258: PUSH
27259: LD_VAR 0 2
27263: ARRAY
27264: PUSH
27265: LD_VAR 0 3
27269: ARRAY
27270: DIFF
27271: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
27272: LD_ADDR_EXP 64
27276: PUSH
27277: LD_EXP 64
27281: PPUSH
27282: LD_VAR 0 2
27286: PPUSH
27287: LD_VAR 0 5
27291: PPUSH
27292: CALL_OW 1
27296: ST_TO_ADDR
// continue ;
27297: GO 27185
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
27299: LD_EXP 64
27303: PUSH
27304: LD_VAR 0 2
27308: ARRAY
27309: PUSH
27310: LD_VAR 0 3
27314: ARRAY
27315: PPUSH
27316: CALL 50809 0 1
27320: PUSH
27321: LD_EXP 64
27325: PUSH
27326: LD_VAR 0 2
27330: ARRAY
27331: PUSH
27332: LD_VAR 0 3
27336: ARRAY
27337: PPUSH
27338: CALL_OW 255
27342: PPUSH
27343: LD_EXP 63
27347: PUSH
27348: LD_VAR 0 2
27352: ARRAY
27353: PUSH
27354: LD_VAR 0 4
27358: ARRAY
27359: PUSH
27360: LD_INT 1
27362: ARRAY
27363: PPUSH
27364: LD_EXP 63
27368: PUSH
27369: LD_VAR 0 2
27373: ARRAY
27374: PUSH
27375: LD_VAR 0 4
27379: ARRAY
27380: PUSH
27381: LD_INT 2
27383: ARRAY
27384: PPUSH
27385: LD_INT 15
27387: PPUSH
27388: CALL 51802 0 4
27392: PUSH
27393: LD_INT 4
27395: ARRAY
27396: PUSH
27397: LD_EXP 64
27401: PUSH
27402: LD_VAR 0 2
27406: ARRAY
27407: PUSH
27408: LD_VAR 0 3
27412: ARRAY
27413: PPUSH
27414: LD_INT 10
27416: PPUSH
27417: CALL 53499 0 2
27421: PUSH
27422: LD_INT 4
27424: ARRAY
27425: OR
27426: AND
27427: IFFALSE 27450
// ComStop ( mc_miners [ i ] [ j ] ) ;
27429: LD_EXP 64
27433: PUSH
27434: LD_VAR 0 2
27438: ARRAY
27439: PUSH
27440: LD_VAR 0 3
27444: ARRAY
27445: PPUSH
27446: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
27450: LD_EXP 64
27454: PUSH
27455: LD_VAR 0 2
27459: ARRAY
27460: PUSH
27461: LD_VAR 0 3
27465: ARRAY
27466: PPUSH
27467: CALL_OW 257
27471: PUSH
27472: LD_INT 1
27474: EQUAL
27475: PUSH
27476: LD_EXP 64
27480: PUSH
27481: LD_VAR 0 2
27485: ARRAY
27486: PUSH
27487: LD_VAR 0 3
27491: ARRAY
27492: PPUSH
27493: CALL_OW 459
27497: NOT
27498: AND
27499: PUSH
27500: LD_EXP 64
27504: PUSH
27505: LD_VAR 0 2
27509: ARRAY
27510: PUSH
27511: LD_VAR 0 3
27515: ARRAY
27516: PPUSH
27517: CALL_OW 255
27521: PPUSH
27522: LD_EXP 63
27526: PUSH
27527: LD_VAR 0 2
27531: ARRAY
27532: PUSH
27533: LD_VAR 0 4
27537: ARRAY
27538: PUSH
27539: LD_INT 1
27541: ARRAY
27542: PPUSH
27543: LD_EXP 63
27547: PUSH
27548: LD_VAR 0 2
27552: ARRAY
27553: PUSH
27554: LD_VAR 0 4
27558: ARRAY
27559: PUSH
27560: LD_INT 2
27562: ARRAY
27563: PPUSH
27564: LD_INT 15
27566: PPUSH
27567: CALL 51802 0 4
27571: PUSH
27572: LD_INT 4
27574: ARRAY
27575: PUSH
27576: LD_INT 0
27578: EQUAL
27579: AND
27580: PUSH
27581: LD_EXP 64
27585: PUSH
27586: LD_VAR 0 2
27590: ARRAY
27591: PUSH
27592: LD_VAR 0 3
27596: ARRAY
27597: PPUSH
27598: CALL_OW 314
27602: NOT
27603: AND
27604: IFFALSE 27780
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
27606: LD_EXP 64
27610: PUSH
27611: LD_VAR 0 2
27615: ARRAY
27616: PUSH
27617: LD_VAR 0 3
27621: ARRAY
27622: PPUSH
27623: CALL_OW 310
27627: IFFALSE 27650
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
27629: LD_EXP 64
27633: PUSH
27634: LD_VAR 0 2
27638: ARRAY
27639: PUSH
27640: LD_VAR 0 3
27644: ARRAY
27645: PPUSH
27646: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
27650: LD_EXP 64
27654: PUSH
27655: LD_VAR 0 2
27659: ARRAY
27660: PUSH
27661: LD_VAR 0 3
27665: ARRAY
27666: PPUSH
27667: CALL_OW 314
27671: NOT
27672: IFFALSE 27740
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
27674: LD_EXP 64
27678: PUSH
27679: LD_VAR 0 2
27683: ARRAY
27684: PUSH
27685: LD_VAR 0 3
27689: ARRAY
27690: PPUSH
27691: LD_EXP 63
27695: PUSH
27696: LD_VAR 0 2
27700: ARRAY
27701: PUSH
27702: LD_VAR 0 4
27706: ARRAY
27707: PUSH
27708: LD_INT 1
27710: ARRAY
27711: PPUSH
27712: LD_EXP 63
27716: PUSH
27717: LD_VAR 0 2
27721: ARRAY
27722: PUSH
27723: LD_VAR 0 4
27727: ARRAY
27728: PUSH
27729: LD_INT 2
27731: ARRAY
27732: PPUSH
27733: LD_INT 0
27735: PPUSH
27736: CALL_OW 193
// k := k + 1 ;
27740: LD_ADDR_VAR 0 4
27744: PUSH
27745: LD_VAR 0 4
27749: PUSH
27750: LD_INT 1
27752: PLUS
27753: ST_TO_ADDR
// if k > mc_mines [ i ] then
27754: LD_VAR 0 4
27758: PUSH
27759: LD_EXP 63
27763: PUSH
27764: LD_VAR 0 2
27768: ARRAY
27769: GREATER
27770: IFFALSE 27780
// k := 1 ;
27772: LD_ADDR_VAR 0 4
27776: PUSH
27777: LD_INT 1
27779: ST_TO_ADDR
// end ; end ;
27780: GO 27185
27782: POP
27783: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
27784: LD_ADDR_VAR 0 5
27788: PUSH
27789: LD_EXP 50
27793: PUSH
27794: LD_VAR 0 2
27798: ARRAY
27799: PPUSH
27800: LD_INT 2
27802: PUSH
27803: LD_INT 30
27805: PUSH
27806: LD_INT 4
27808: PUSH
27809: EMPTY
27810: LIST
27811: LIST
27812: PUSH
27813: LD_INT 30
27815: PUSH
27816: LD_INT 5
27818: PUSH
27819: EMPTY
27820: LIST
27821: LIST
27822: PUSH
27823: LD_INT 30
27825: PUSH
27826: LD_INT 32
27828: PUSH
27829: EMPTY
27830: LIST
27831: LIST
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: LIST
27837: LIST
27838: PPUSH
27839: CALL_OW 72
27843: ST_TO_ADDR
// if not tmp then
27844: LD_VAR 0 5
27848: NOT
27849: IFFALSE 27853
// continue ;
27851: GO 27102
// list := [ ] ;
27853: LD_ADDR_VAR 0 6
27857: PUSH
27858: EMPTY
27859: ST_TO_ADDR
// for j in tmp do
27860: LD_ADDR_VAR 0 3
27864: PUSH
27865: LD_VAR 0 5
27869: PUSH
27870: FOR_IN
27871: IFFALSE 27940
// begin for k in UnitsInside ( j ) do
27873: LD_ADDR_VAR 0 4
27877: PUSH
27878: LD_VAR 0 3
27882: PPUSH
27883: CALL_OW 313
27887: PUSH
27888: FOR_IN
27889: IFFALSE 27936
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
27891: LD_VAR 0 4
27895: PPUSH
27896: CALL_OW 257
27900: PUSH
27901: LD_INT 1
27903: EQUAL
27904: PUSH
27905: LD_VAR 0 4
27909: PPUSH
27910: CALL_OW 459
27914: NOT
27915: AND
27916: IFFALSE 27934
// list := list ^ k ;
27918: LD_ADDR_VAR 0 6
27922: PUSH
27923: LD_VAR 0 6
27927: PUSH
27928: LD_VAR 0 4
27932: ADD
27933: ST_TO_ADDR
27934: GO 27888
27936: POP
27937: POP
// end ;
27938: GO 27870
27940: POP
27941: POP
// list := list diff mc_miners [ i ] ;
27942: LD_ADDR_VAR 0 6
27946: PUSH
27947: LD_VAR 0 6
27951: PUSH
27952: LD_EXP 64
27956: PUSH
27957: LD_VAR 0 2
27961: ARRAY
27962: DIFF
27963: ST_TO_ADDR
// if not list then
27964: LD_VAR 0 6
27968: NOT
27969: IFFALSE 27973
// continue ;
27971: GO 27102
// k := mc_mines [ i ] - mc_miners [ i ] ;
27973: LD_ADDR_VAR 0 4
27977: PUSH
27978: LD_EXP 63
27982: PUSH
27983: LD_VAR 0 2
27987: ARRAY
27988: PUSH
27989: LD_EXP 64
27993: PUSH
27994: LD_VAR 0 2
27998: ARRAY
27999: MINUS
28000: ST_TO_ADDR
// if k > list then
28001: LD_VAR 0 4
28005: PUSH
28006: LD_VAR 0 6
28010: GREATER
28011: IFFALSE 28023
// k := list ;
28013: LD_ADDR_VAR 0 4
28017: PUSH
28018: LD_VAR 0 6
28022: ST_TO_ADDR
// for j = 1 to k do
28023: LD_ADDR_VAR 0 3
28027: PUSH
28028: DOUBLE
28029: LD_INT 1
28031: DEC
28032: ST_TO_ADDR
28033: LD_VAR 0 4
28037: PUSH
28038: FOR_TO
28039: IFFALSE 28093
// mc_miners := Add ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
28041: LD_ADDR_EXP 64
28045: PUSH
28046: LD_EXP 64
28050: PPUSH
28051: LD_VAR 0 2
28055: PUSH
28056: LD_EXP 64
28060: PUSH
28061: LD_VAR 0 2
28065: ARRAY
28066: PUSH
28067: LD_INT 1
28069: PLUS
28070: PUSH
28071: EMPTY
28072: LIST
28073: LIST
28074: PPUSH
28075: LD_VAR 0 6
28079: PUSH
28080: LD_VAR 0 3
28084: ARRAY
28085: PPUSH
28086: CALL 51308 0 3
28090: ST_TO_ADDR
28091: GO 28038
28093: POP
28094: POP
// end ;
28095: GO 27102
28097: POP
28098: POP
// end ;
28099: LD_VAR 0 1
28103: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
28104: LD_INT 0
28106: PPUSH
28107: PPUSH
28108: PPUSH
28109: PPUSH
28110: PPUSH
28111: PPUSH
28112: PPUSH
28113: PPUSH
28114: PPUSH
28115: PPUSH
// if not mc_bases then
28116: LD_EXP 50
28120: NOT
28121: IFFALSE 28125
// exit ;
28123: GO 29856
// for i = 1 to mc_bases do
28125: LD_ADDR_VAR 0 2
28129: PUSH
28130: DOUBLE
28131: LD_INT 1
28133: DEC
28134: ST_TO_ADDR
28135: LD_EXP 50
28139: PUSH
28140: FOR_TO
28141: IFFALSE 29854
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
28143: LD_EXP 50
28147: PUSH
28148: LD_VAR 0 2
28152: ARRAY
28153: NOT
28154: PUSH
28155: LD_EXP 57
28159: PUSH
28160: LD_VAR 0 2
28164: ARRAY
28165: OR
28166: IFFALSE 28170
// continue ;
28168: GO 28140
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
28170: LD_EXP 66
28174: PUSH
28175: LD_VAR 0 2
28179: ARRAY
28180: NOT
28181: PUSH
28182: LD_EXP 67
28186: PUSH
28187: LD_VAR 0 2
28191: ARRAY
28192: AND
28193: IFFALSE 28231
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
28195: LD_ADDR_EXP 67
28199: PUSH
28200: LD_EXP 67
28204: PPUSH
28205: LD_VAR 0 2
28209: PPUSH
28210: EMPTY
28211: PPUSH
28212: CALL_OW 1
28216: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
28217: LD_VAR 0 2
28221: PPUSH
28222: LD_INT 107
28224: PPUSH
28225: CALL 19681 0 2
// continue ;
28229: GO 28140
// end ; target := [ ] ;
28231: LD_ADDR_VAR 0 6
28235: PUSH
28236: EMPTY
28237: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
28238: LD_ADDR_VAR 0 3
28242: PUSH
28243: DOUBLE
28244: LD_EXP 66
28248: PUSH
28249: LD_VAR 0 2
28253: ARRAY
28254: INC
28255: ST_TO_ADDR
28256: LD_INT 1
28258: PUSH
28259: FOR_DOWNTO
28260: IFFALSE 28520
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
28262: LD_EXP 66
28266: PUSH
28267: LD_VAR 0 2
28271: ARRAY
28272: PUSH
28273: LD_VAR 0 3
28277: ARRAY
28278: PUSH
28279: LD_INT 2
28281: ARRAY
28282: PPUSH
28283: LD_EXP 66
28287: PUSH
28288: LD_VAR 0 2
28292: ARRAY
28293: PUSH
28294: LD_VAR 0 3
28298: ARRAY
28299: PUSH
28300: LD_INT 3
28302: ARRAY
28303: PPUSH
28304: CALL_OW 488
28308: PUSH
28309: LD_EXP 66
28313: PUSH
28314: LD_VAR 0 2
28318: ARRAY
28319: PUSH
28320: LD_VAR 0 3
28324: ARRAY
28325: PUSH
28326: LD_INT 2
28328: ARRAY
28329: PPUSH
28330: LD_EXP 66
28334: PUSH
28335: LD_VAR 0 2
28339: ARRAY
28340: PUSH
28341: LD_VAR 0 3
28345: ARRAY
28346: PUSH
28347: LD_INT 3
28349: ARRAY
28350: PPUSH
28351: CALL_OW 284
28355: PUSH
28356: LD_INT 0
28358: EQUAL
28359: AND
28360: IFFALSE 28415
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
28362: LD_ADDR_VAR 0 5
28366: PUSH
28367: LD_EXP 66
28371: PUSH
28372: LD_VAR 0 2
28376: ARRAY
28377: PPUSH
28378: LD_VAR 0 3
28382: PPUSH
28383: CALL_OW 3
28387: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
28388: LD_ADDR_EXP 66
28392: PUSH
28393: LD_EXP 66
28397: PPUSH
28398: LD_VAR 0 2
28402: PPUSH
28403: LD_VAR 0 5
28407: PPUSH
28408: CALL_OW 1
28412: ST_TO_ADDR
// continue ;
28413: GO 28259
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
28415: LD_EXP 50
28419: PUSH
28420: LD_VAR 0 2
28424: ARRAY
28425: PUSH
28426: LD_INT 1
28428: ARRAY
28429: PPUSH
28430: CALL_OW 255
28434: PPUSH
28435: LD_EXP 66
28439: PUSH
28440: LD_VAR 0 2
28444: ARRAY
28445: PUSH
28446: LD_VAR 0 3
28450: ARRAY
28451: PUSH
28452: LD_INT 2
28454: ARRAY
28455: PPUSH
28456: LD_EXP 66
28460: PUSH
28461: LD_VAR 0 2
28465: ARRAY
28466: PUSH
28467: LD_VAR 0 3
28471: ARRAY
28472: PUSH
28473: LD_INT 3
28475: ARRAY
28476: PPUSH
28477: LD_INT 30
28479: PPUSH
28480: CALL 51802 0 4
28484: PUSH
28485: LD_INT 4
28487: ARRAY
28488: PUSH
28489: LD_INT 0
28491: EQUAL
28492: IFFALSE 28518
// begin target := mc_crates [ i ] [ j ] ;
28494: LD_ADDR_VAR 0 6
28498: PUSH
28499: LD_EXP 66
28503: PUSH
28504: LD_VAR 0 2
28508: ARRAY
28509: PUSH
28510: LD_VAR 0 3
28514: ARRAY
28515: ST_TO_ADDR
// break ;
28516: GO 28520
// end ; end ;
28518: GO 28259
28520: POP
28521: POP
// if not target then
28522: LD_VAR 0 6
28526: NOT
28527: IFFALSE 28531
// continue ;
28529: GO 28140
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
28531: LD_ADDR_VAR 0 7
28535: PUSH
28536: LD_EXP 69
28540: PUSH
28541: LD_VAR 0 2
28545: ARRAY
28546: PPUSH
28547: LD_INT 2
28549: PUSH
28550: LD_INT 3
28552: PUSH
28553: LD_INT 58
28555: PUSH
28556: EMPTY
28557: LIST
28558: PUSH
28559: EMPTY
28560: LIST
28561: LIST
28562: PUSH
28563: LD_INT 61
28565: PUSH
28566: EMPTY
28567: LIST
28568: PUSH
28569: LD_INT 33
28571: PUSH
28572: LD_INT 5
28574: PUSH
28575: EMPTY
28576: LIST
28577: LIST
28578: PUSH
28579: LD_INT 33
28581: PUSH
28582: LD_INT 3
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: LIST
28593: LIST
28594: LIST
28595: PUSH
28596: LD_INT 2
28598: PUSH
28599: LD_INT 34
28601: PUSH
28602: LD_INT 32
28604: PUSH
28605: EMPTY
28606: LIST
28607: LIST
28608: PUSH
28609: LD_INT 34
28611: PUSH
28612: LD_INT 51
28614: PUSH
28615: EMPTY
28616: LIST
28617: LIST
28618: PUSH
28619: LD_INT 34
28621: PUSH
28622: LD_INT 12
28624: PUSH
28625: EMPTY
28626: LIST
28627: LIST
28628: PUSH
28629: EMPTY
28630: LIST
28631: LIST
28632: LIST
28633: LIST
28634: PUSH
28635: EMPTY
28636: LIST
28637: LIST
28638: PPUSH
28639: CALL_OW 72
28643: ST_TO_ADDR
// if not cargo then
28644: LD_VAR 0 7
28648: NOT
28649: IFFALSE 29292
// begin if mc_crates_collector [ i ] < 5 then
28651: LD_EXP 67
28655: PUSH
28656: LD_VAR 0 2
28660: ARRAY
28661: PUSH
28662: LD_INT 5
28664: LESS
28665: IFFALSE 29031
// begin if mc_ape [ i ] then
28667: LD_EXP 79
28671: PUSH
28672: LD_VAR 0 2
28676: ARRAY
28677: IFFALSE 28724
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
28679: LD_ADDR_VAR 0 5
28683: PUSH
28684: LD_EXP 79
28688: PUSH
28689: LD_VAR 0 2
28693: ARRAY
28694: PPUSH
28695: LD_INT 25
28697: PUSH
28698: LD_INT 16
28700: PUSH
28701: EMPTY
28702: LIST
28703: LIST
28704: PUSH
28705: LD_INT 24
28707: PUSH
28708: LD_INT 750
28710: PUSH
28711: EMPTY
28712: LIST
28713: LIST
28714: PUSH
28715: EMPTY
28716: LIST
28717: LIST
28718: PPUSH
28719: CALL_OW 72
28723: ST_TO_ADDR
// if not tmp then
28724: LD_VAR 0 5
28728: NOT
28729: IFFALSE 28776
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
28731: LD_ADDR_VAR 0 5
28735: PUSH
28736: LD_EXP 50
28740: PUSH
28741: LD_VAR 0 2
28745: ARRAY
28746: PPUSH
28747: LD_INT 25
28749: PUSH
28750: LD_INT 2
28752: PUSH
28753: EMPTY
28754: LIST
28755: LIST
28756: PUSH
28757: LD_INT 24
28759: PUSH
28760: LD_INT 750
28762: PUSH
28763: EMPTY
28764: LIST
28765: LIST
28766: PUSH
28767: EMPTY
28768: LIST
28769: LIST
28770: PPUSH
28771: CALL_OW 72
28775: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
28776: LD_EXP 79
28780: PUSH
28781: LD_VAR 0 2
28785: ARRAY
28786: PUSH
28787: LD_EXP 50
28791: PUSH
28792: LD_VAR 0 2
28796: ARRAY
28797: PPUSH
28798: LD_INT 25
28800: PUSH
28801: LD_INT 2
28803: PUSH
28804: EMPTY
28805: LIST
28806: LIST
28807: PUSH
28808: LD_INT 24
28810: PUSH
28811: LD_INT 750
28813: PUSH
28814: EMPTY
28815: LIST
28816: LIST
28817: PUSH
28818: EMPTY
28819: LIST
28820: LIST
28821: PPUSH
28822: CALL_OW 72
28826: AND
28827: PUSH
28828: LD_VAR 0 5
28832: PUSH
28833: LD_INT 5
28835: LESS
28836: AND
28837: IFFALSE 28919
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
28839: LD_ADDR_VAR 0 3
28843: PUSH
28844: LD_EXP 50
28848: PUSH
28849: LD_VAR 0 2
28853: ARRAY
28854: PPUSH
28855: LD_INT 25
28857: PUSH
28858: LD_INT 2
28860: PUSH
28861: EMPTY
28862: LIST
28863: LIST
28864: PUSH
28865: LD_INT 24
28867: PUSH
28868: LD_INT 750
28870: PUSH
28871: EMPTY
28872: LIST
28873: LIST
28874: PUSH
28875: EMPTY
28876: LIST
28877: LIST
28878: PPUSH
28879: CALL_OW 72
28883: PUSH
28884: FOR_IN
28885: IFFALSE 28917
// begin tmp := tmp union j ;
28887: LD_ADDR_VAR 0 5
28891: PUSH
28892: LD_VAR 0 5
28896: PUSH
28897: LD_VAR 0 3
28901: UNION
28902: ST_TO_ADDR
// if tmp >= 5 then
28903: LD_VAR 0 5
28907: PUSH
28908: LD_INT 5
28910: GREATEREQUAL
28911: IFFALSE 28915
// break ;
28913: GO 28917
// end ;
28915: GO 28884
28917: POP
28918: POP
// end ; if not tmp then
28919: LD_VAR 0 5
28923: NOT
28924: IFFALSE 28928
// continue ;
28926: GO 28140
// for j in tmp do
28928: LD_ADDR_VAR 0 3
28932: PUSH
28933: LD_VAR 0 5
28937: PUSH
28938: FOR_IN
28939: IFFALSE 29029
// if not GetTag ( j ) then
28941: LD_VAR 0 3
28945: PPUSH
28946: CALL_OW 110
28950: NOT
28951: IFFALSE 29027
// begin mc_crates_collector := Add ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
28953: LD_ADDR_EXP 67
28957: PUSH
28958: LD_EXP 67
28962: PPUSH
28963: LD_VAR 0 2
28967: PUSH
28968: LD_EXP 67
28972: PUSH
28973: LD_VAR 0 2
28977: ARRAY
28978: PUSH
28979: LD_INT 1
28981: PLUS
28982: PUSH
28983: EMPTY
28984: LIST
28985: LIST
28986: PPUSH
28987: LD_VAR 0 3
28991: PPUSH
28992: CALL 51308 0 3
28996: ST_TO_ADDR
// SetTag ( j , 107 ) ;
28997: LD_VAR 0 3
29001: PPUSH
29002: LD_INT 107
29004: PPUSH
29005: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
29009: LD_EXP 67
29013: PUSH
29014: LD_VAR 0 2
29018: ARRAY
29019: PUSH
29020: LD_INT 5
29022: GREATEREQUAL
29023: IFFALSE 29027
// break ;
29025: GO 29029
// end ;
29027: GO 28938
29029: POP
29030: POP
// end ; if mc_crates_collector [ i ] and target then
29031: LD_EXP 67
29035: PUSH
29036: LD_VAR 0 2
29040: ARRAY
29041: PUSH
29042: LD_VAR 0 6
29046: AND
29047: IFFALSE 29290
// begin if mc_crates_collector [ i ] < target [ 1 ] then
29049: LD_EXP 67
29053: PUSH
29054: LD_VAR 0 2
29058: ARRAY
29059: PUSH
29060: LD_VAR 0 6
29064: PUSH
29065: LD_INT 1
29067: ARRAY
29068: LESS
29069: IFFALSE 29089
// tmp := mc_crates_collector [ i ] else
29071: LD_ADDR_VAR 0 5
29075: PUSH
29076: LD_EXP 67
29080: PUSH
29081: LD_VAR 0 2
29085: ARRAY
29086: ST_TO_ADDR
29087: GO 29103
// tmp := target [ 1 ] ;
29089: LD_ADDR_VAR 0 5
29093: PUSH
29094: LD_VAR 0 6
29098: PUSH
29099: LD_INT 1
29101: ARRAY
29102: ST_TO_ADDR
// k := 0 ;
29103: LD_ADDR_VAR 0 4
29107: PUSH
29108: LD_INT 0
29110: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
29111: LD_ADDR_VAR 0 3
29115: PUSH
29116: LD_EXP 67
29120: PUSH
29121: LD_VAR 0 2
29125: ARRAY
29126: PUSH
29127: FOR_IN
29128: IFFALSE 29288
// begin k := k + 1 ;
29130: LD_ADDR_VAR 0 4
29134: PUSH
29135: LD_VAR 0 4
29139: PUSH
29140: LD_INT 1
29142: PLUS
29143: ST_TO_ADDR
// if k > tmp then
29144: LD_VAR 0 4
29148: PUSH
29149: LD_VAR 0 5
29153: GREATER
29154: IFFALSE 29158
// break ;
29156: GO 29288
// if not GetClass ( j ) in [ 2 , 16 ] then
29158: LD_VAR 0 3
29162: PPUSH
29163: CALL_OW 257
29167: PUSH
29168: LD_INT 2
29170: PUSH
29171: LD_INT 16
29173: PUSH
29174: EMPTY
29175: LIST
29176: LIST
29177: IN
29178: NOT
29179: IFFALSE 29232
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
29181: LD_ADDR_EXP 67
29185: PUSH
29186: LD_EXP 67
29190: PPUSH
29191: LD_VAR 0 2
29195: PPUSH
29196: LD_EXP 67
29200: PUSH
29201: LD_VAR 0 2
29205: ARRAY
29206: PUSH
29207: LD_VAR 0 3
29211: DIFF
29212: PPUSH
29213: CALL_OW 1
29217: ST_TO_ADDR
// SetTag ( j , 0 ) ;
29218: LD_VAR 0 3
29222: PPUSH
29223: LD_INT 0
29225: PPUSH
29226: CALL_OW 109
// continue ;
29230: GO 29127
// end ; if IsInUnit ( j ) then
29232: LD_VAR 0 3
29236: PPUSH
29237: CALL_OW 310
29241: IFFALSE 29252
// ComExitBuilding ( j ) ;
29243: LD_VAR 0 3
29247: PPUSH
29248: CALL_OW 122
// wait ( 3 ) ;
29252: LD_INT 3
29254: PPUSH
29255: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
29259: LD_VAR 0 3
29263: PPUSH
29264: LD_VAR 0 6
29268: PUSH
29269: LD_INT 2
29271: ARRAY
29272: PPUSH
29273: LD_VAR 0 6
29277: PUSH
29278: LD_INT 3
29280: ARRAY
29281: PPUSH
29282: CALL_OW 117
// end ;
29286: GO 29127
29288: POP
29289: POP
// end ; end else
29290: GO 29852
// begin for j in cargo do
29292: LD_ADDR_VAR 0 3
29296: PUSH
29297: LD_VAR 0 7
29301: PUSH
29302: FOR_IN
29303: IFFALSE 29850
// begin if GetTag ( j ) <> 0 then
29305: LD_VAR 0 3
29309: PPUSH
29310: CALL_OW 110
29314: PUSH
29315: LD_INT 0
29317: NONEQUAL
29318: IFFALSE 29322
// continue ;
29320: GO 29302
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
29322: LD_VAR 0 3
29326: PPUSH
29327: CALL_OW 256
29331: PUSH
29332: LD_INT 1000
29334: LESS
29335: PUSH
29336: LD_VAR 0 3
29340: PPUSH
29341: LD_EXP 74
29345: PUSH
29346: LD_VAR 0 2
29350: ARRAY
29351: PPUSH
29352: CALL_OW 308
29356: NOT
29357: AND
29358: IFFALSE 29380
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29360: LD_VAR 0 3
29364: PPUSH
29365: LD_EXP 74
29369: PUSH
29370: LD_VAR 0 2
29374: ARRAY
29375: PPUSH
29376: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
29380: LD_VAR 0 3
29384: PPUSH
29385: CALL_OW 256
29389: PUSH
29390: LD_INT 1000
29392: LESS
29393: PUSH
29394: LD_VAR 0 3
29398: PPUSH
29399: LD_EXP 74
29403: PUSH
29404: LD_VAR 0 2
29408: ARRAY
29409: PPUSH
29410: CALL_OW 308
29414: AND
29415: IFFALSE 29419
// continue ;
29417: GO 29302
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
29419: LD_VAR 0 3
29423: PPUSH
29424: CALL_OW 262
29428: PUSH
29429: LD_INT 2
29431: EQUAL
29432: PUSH
29433: LD_VAR 0 3
29437: PPUSH
29438: CALL_OW 261
29442: PUSH
29443: LD_INT 15
29445: LESS
29446: AND
29447: IFFALSE 29451
// continue ;
29449: GO 29302
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
29451: LD_VAR 0 3
29455: PPUSH
29456: CALL_OW 262
29460: PUSH
29461: LD_INT 1
29463: EQUAL
29464: PUSH
29465: LD_VAR 0 3
29469: PPUSH
29470: CALL_OW 261
29474: PUSH
29475: LD_INT 10
29477: LESS
29478: AND
29479: IFFALSE 29789
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29481: LD_ADDR_VAR 0 8
29485: PUSH
29486: LD_EXP 50
29490: PUSH
29491: LD_VAR 0 2
29495: ARRAY
29496: PPUSH
29497: LD_INT 2
29499: PUSH
29500: LD_INT 30
29502: PUSH
29503: LD_INT 0
29505: PUSH
29506: EMPTY
29507: LIST
29508: LIST
29509: PUSH
29510: LD_INT 30
29512: PUSH
29513: LD_INT 1
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: LIST
29524: PPUSH
29525: CALL_OW 72
29529: ST_TO_ADDR
// if not depot then
29530: LD_VAR 0 8
29534: NOT
29535: IFFALSE 29539
// continue ;
29537: GO 29302
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
29539: LD_VAR 0 3
29543: PPUSH
29544: LD_VAR 0 8
29548: PPUSH
29549: LD_VAR 0 3
29553: PPUSH
29554: CALL_OW 74
29558: PPUSH
29559: CALL_OW 296
29563: PUSH
29564: LD_INT 6
29566: LESS
29567: IFFALSE 29583
// SetFuel ( j , 100 ) else
29569: LD_VAR 0 3
29573: PPUSH
29574: LD_INT 100
29576: PPUSH
29577: CALL_OW 240
29581: GO 29789
// if GetFuel ( j ) = 0 then
29583: LD_VAR 0 3
29587: PPUSH
29588: CALL_OW 261
29592: PUSH
29593: LD_INT 0
29595: EQUAL
29596: IFFALSE 29789
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
29598: LD_ADDR_EXP 69
29602: PUSH
29603: LD_EXP 69
29607: PPUSH
29608: LD_VAR 0 2
29612: PPUSH
29613: LD_EXP 69
29617: PUSH
29618: LD_VAR 0 2
29622: ARRAY
29623: PUSH
29624: LD_VAR 0 3
29628: DIFF
29629: PPUSH
29630: CALL_OW 1
29634: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
29635: LD_VAR 0 3
29639: PPUSH
29640: CALL_OW 263
29644: PUSH
29645: LD_INT 1
29647: EQUAL
29648: IFFALSE 29664
// ComExitVehicle ( IsInUnit ( j ) ) ;
29650: LD_VAR 0 3
29654: PPUSH
29655: CALL_OW 310
29659: PPUSH
29660: CALL_OW 121
// if GetControl ( j ) = control_remote then
29664: LD_VAR 0 3
29668: PPUSH
29669: CALL_OW 263
29673: PUSH
29674: LD_INT 2
29676: EQUAL
29677: IFFALSE 29688
// ComUnlink ( j ) ;
29679: LD_VAR 0 3
29683: PPUSH
29684: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
29688: LD_ADDR_VAR 0 9
29692: PUSH
29693: LD_VAR 0 2
29697: PPUSH
29698: LD_INT 3
29700: PPUSH
29701: CALL 38924 0 2
29705: ST_TO_ADDR
// if fac then
29706: LD_VAR 0 9
29710: IFFALSE 29787
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
29712: LD_ADDR_VAR 0 10
29716: PUSH
29717: LD_VAR 0 9
29721: PPUSH
29722: LD_VAR 0 3
29726: PPUSH
29727: CALL_OW 265
29731: PPUSH
29732: LD_VAR 0 3
29736: PPUSH
29737: CALL_OW 262
29741: PPUSH
29742: LD_VAR 0 3
29746: PPUSH
29747: CALL_OW 263
29751: PPUSH
29752: LD_VAR 0 3
29756: PPUSH
29757: CALL_OW 264
29761: PPUSH
29762: CALL 48473 0 5
29766: ST_TO_ADDR
// if components then
29767: LD_VAR 0 10
29771: IFFALSE 29787
// MC_InsertProduceList ( i , components ) ;
29773: LD_VAR 0 2
29777: PPUSH
29778: LD_VAR 0 10
29782: PPUSH
29783: CALL 38494 0 2
// end ; continue ;
29787: GO 29302
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
29789: LD_VAR 0 3
29793: PPUSH
29794: LD_INT 1
29796: PPUSH
29797: CALL_OW 289
29801: PUSH
29802: LD_INT 100
29804: LESS
29805: PUSH
29806: LD_VAR 0 3
29810: PPUSH
29811: CALL_OW 314
29815: NOT
29816: AND
29817: IFFALSE 29846
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
29819: LD_VAR 0 3
29823: PPUSH
29824: LD_VAR 0 6
29828: PUSH
29829: LD_INT 2
29831: ARRAY
29832: PPUSH
29833: LD_VAR 0 6
29837: PUSH
29838: LD_INT 3
29840: ARRAY
29841: PPUSH
29842: CALL_OW 117
// break ;
29846: GO 29850
// end ;
29848: GO 29302
29850: POP
29851: POP
// end ; end ;
29852: GO 28140
29854: POP
29855: POP
// end ;
29856: LD_VAR 0 1
29860: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
29861: LD_INT 0
29863: PPUSH
29864: PPUSH
29865: PPUSH
29866: PPUSH
// if not mc_bases then
29867: LD_EXP 50
29871: NOT
29872: IFFALSE 29876
// exit ;
29874: GO 30037
// for i = 1 to mc_bases do
29876: LD_ADDR_VAR 0 2
29880: PUSH
29881: DOUBLE
29882: LD_INT 1
29884: DEC
29885: ST_TO_ADDR
29886: LD_EXP 50
29890: PUSH
29891: FOR_TO
29892: IFFALSE 30035
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
29894: LD_ADDR_VAR 0 4
29898: PUSH
29899: LD_EXP 69
29903: PUSH
29904: LD_VAR 0 2
29908: ARRAY
29909: PUSH
29910: LD_EXP 72
29914: PUSH
29915: LD_VAR 0 2
29919: ARRAY
29920: UNION
29921: PPUSH
29922: LD_INT 33
29924: PUSH
29925: LD_INT 2
29927: PUSH
29928: EMPTY
29929: LIST
29930: LIST
29931: PPUSH
29932: CALL_OW 72
29936: ST_TO_ADDR
// if tmp then
29937: LD_VAR 0 4
29941: IFFALSE 30033
// for j in tmp do
29943: LD_ADDR_VAR 0 3
29947: PUSH
29948: LD_VAR 0 4
29952: PUSH
29953: FOR_IN
29954: IFFALSE 30031
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
29956: LD_VAR 0 3
29960: PPUSH
29961: CALL_OW 312
29965: NOT
29966: PUSH
29967: LD_VAR 0 3
29971: PPUSH
29972: CALL_OW 256
29976: PUSH
29977: LD_INT 250
29979: GREATEREQUAL
29980: AND
29981: IFFALSE 29994
// Connect ( j ) else
29983: LD_VAR 0 3
29987: PPUSH
29988: CALL 53839 0 1
29992: GO 30029
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
29994: LD_VAR 0 3
29998: PPUSH
29999: CALL_OW 256
30003: PUSH
30004: LD_INT 250
30006: LESS
30007: PUSH
30008: LD_VAR 0 3
30012: PPUSH
30013: CALL_OW 312
30017: AND
30018: IFFALSE 30029
// ComUnlink ( j ) ;
30020: LD_VAR 0 3
30024: PPUSH
30025: CALL_OW 136
30029: GO 29953
30031: POP
30032: POP
// end ;
30033: GO 29891
30035: POP
30036: POP
// end ;
30037: LD_VAR 0 1
30041: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
30042: LD_INT 0
30044: PPUSH
30045: PPUSH
30046: PPUSH
30047: PPUSH
30048: PPUSH
// if not mc_bases then
30049: LD_EXP 50
30053: NOT
30054: IFFALSE 30058
// exit ;
30056: GO 30518
// for i = 1 to mc_bases do
30058: LD_ADDR_VAR 0 2
30062: PUSH
30063: DOUBLE
30064: LD_INT 1
30066: DEC
30067: ST_TO_ADDR
30068: LD_EXP 50
30072: PUSH
30073: FOR_TO
30074: IFFALSE 30516
// begin if not mc_produce [ i ] then
30076: LD_EXP 71
30080: PUSH
30081: LD_VAR 0 2
30085: ARRAY
30086: NOT
30087: IFFALSE 30091
// continue ;
30089: GO 30073
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30091: LD_ADDR_VAR 0 5
30095: PUSH
30096: LD_EXP 50
30100: PUSH
30101: LD_VAR 0 2
30105: ARRAY
30106: PPUSH
30107: LD_INT 30
30109: PUSH
30110: LD_INT 3
30112: PUSH
30113: EMPTY
30114: LIST
30115: LIST
30116: PPUSH
30117: CALL_OW 72
30121: ST_TO_ADDR
// if not fac then
30122: LD_VAR 0 5
30126: NOT
30127: IFFALSE 30131
// continue ;
30129: GO 30073
// for j in fac do
30131: LD_ADDR_VAR 0 3
30135: PUSH
30136: LD_VAR 0 5
30140: PUSH
30141: FOR_IN
30142: IFFALSE 30512
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
30144: LD_VAR 0 3
30148: PPUSH
30149: CALL_OW 461
30153: PUSH
30154: LD_INT 2
30156: NONEQUAL
30157: PUSH
30158: LD_VAR 0 3
30162: PPUSH
30163: LD_INT 15
30165: PPUSH
30166: CALL 53499 0 2
30170: PUSH
30171: LD_INT 4
30173: ARRAY
30174: OR
30175: PUSH
30176: LD_VAR 0 3
30180: PPUSH
30181: CALL_OW 313
30185: PUSH
30186: LD_INT 0
30188: EQUAL
30189: OR
30190: IFFALSE 30194
// continue ;
30192: GO 30141
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
30194: LD_VAR 0 3
30198: PPUSH
30199: LD_EXP 71
30203: PUSH
30204: LD_VAR 0 2
30208: ARRAY
30209: PUSH
30210: LD_INT 1
30212: ARRAY
30213: PUSH
30214: LD_INT 1
30216: ARRAY
30217: PPUSH
30218: LD_EXP 71
30222: PUSH
30223: LD_VAR 0 2
30227: ARRAY
30228: PUSH
30229: LD_INT 1
30231: ARRAY
30232: PUSH
30233: LD_INT 2
30235: ARRAY
30236: PPUSH
30237: LD_EXP 71
30241: PUSH
30242: LD_VAR 0 2
30246: ARRAY
30247: PUSH
30248: LD_INT 1
30250: ARRAY
30251: PUSH
30252: LD_INT 3
30254: ARRAY
30255: PPUSH
30256: LD_EXP 71
30260: PUSH
30261: LD_VAR 0 2
30265: ARRAY
30266: PUSH
30267: LD_INT 1
30269: ARRAY
30270: PUSH
30271: LD_INT 4
30273: ARRAY
30274: PPUSH
30275: CALL_OW 448
30279: PUSH
30280: LD_VAR 0 3
30284: PPUSH
30285: LD_EXP 71
30289: PUSH
30290: LD_VAR 0 2
30294: ARRAY
30295: PUSH
30296: LD_INT 1
30298: ARRAY
30299: PUSH
30300: LD_INT 1
30302: ARRAY
30303: PUSH
30304: LD_EXP 71
30308: PUSH
30309: LD_VAR 0 2
30313: ARRAY
30314: PUSH
30315: LD_INT 1
30317: ARRAY
30318: PUSH
30319: LD_INT 2
30321: ARRAY
30322: PUSH
30323: LD_EXP 71
30327: PUSH
30328: LD_VAR 0 2
30332: ARRAY
30333: PUSH
30334: LD_INT 1
30336: ARRAY
30337: PUSH
30338: LD_INT 3
30340: ARRAY
30341: PUSH
30342: LD_EXP 71
30346: PUSH
30347: LD_VAR 0 2
30351: ARRAY
30352: PUSH
30353: LD_INT 1
30355: ARRAY
30356: PUSH
30357: LD_INT 4
30359: ARRAY
30360: PUSH
30361: EMPTY
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: PPUSH
30367: CALL 57068 0 2
30371: AND
30372: IFFALSE 30510
// begin ComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
30374: LD_VAR 0 3
30378: PPUSH
30379: LD_EXP 71
30383: PUSH
30384: LD_VAR 0 2
30388: ARRAY
30389: PUSH
30390: LD_INT 1
30392: ARRAY
30393: PUSH
30394: LD_INT 1
30396: ARRAY
30397: PPUSH
30398: LD_EXP 71
30402: PUSH
30403: LD_VAR 0 2
30407: ARRAY
30408: PUSH
30409: LD_INT 1
30411: ARRAY
30412: PUSH
30413: LD_INT 2
30415: ARRAY
30416: PPUSH
30417: LD_EXP 71
30421: PUSH
30422: LD_VAR 0 2
30426: ARRAY
30427: PUSH
30428: LD_INT 1
30430: ARRAY
30431: PUSH
30432: LD_INT 3
30434: ARRAY
30435: PPUSH
30436: LD_EXP 71
30440: PUSH
30441: LD_VAR 0 2
30445: ARRAY
30446: PUSH
30447: LD_INT 1
30449: ARRAY
30450: PUSH
30451: LD_INT 4
30453: ARRAY
30454: PPUSH
30455: CALL_OW 125
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
30459: LD_ADDR_VAR 0 4
30463: PUSH
30464: LD_EXP 71
30468: PUSH
30469: LD_VAR 0 2
30473: ARRAY
30474: PPUSH
30475: LD_INT 1
30477: PPUSH
30478: CALL_OW 3
30482: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
30483: LD_ADDR_EXP 71
30487: PUSH
30488: LD_EXP 71
30492: PPUSH
30493: LD_VAR 0 2
30497: PPUSH
30498: LD_VAR 0 4
30502: PPUSH
30503: CALL_OW 1
30507: ST_TO_ADDR
// break ;
30508: GO 30512
// end ; end ;
30510: GO 30141
30512: POP
30513: POP
// end ;
30514: GO 30073
30516: POP
30517: POP
// end ;
30518: LD_VAR 0 1
30522: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
30523: LD_INT 0
30525: PPUSH
30526: PPUSH
30527: PPUSH
// if not mc_bases then
30528: LD_EXP 50
30532: NOT
30533: IFFALSE 30537
// exit ;
30535: GO 30626
// for i = 1 to mc_bases do
30537: LD_ADDR_VAR 0 2
30541: PUSH
30542: DOUBLE
30543: LD_INT 1
30545: DEC
30546: ST_TO_ADDR
30547: LD_EXP 50
30551: PUSH
30552: FOR_TO
30553: IFFALSE 30624
// begin if mc_attack [ i ] then
30555: LD_EXP 70
30559: PUSH
30560: LD_VAR 0 2
30564: ARRAY
30565: IFFALSE 30622
// begin tmp := mc_attack [ i ] [ 1 ] ;
30567: LD_ADDR_VAR 0 3
30571: PUSH
30572: LD_EXP 70
30576: PUSH
30577: LD_VAR 0 2
30581: ARRAY
30582: PUSH
30583: LD_INT 1
30585: ARRAY
30586: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
30587: LD_ADDR_EXP 70
30591: PUSH
30592: LD_EXP 70
30596: PPUSH
30597: LD_VAR 0 2
30601: PPUSH
30602: EMPTY
30603: PPUSH
30604: CALL_OW 1
30608: ST_TO_ADDR
// Attack ( tmp ) ;
30609: LD_VAR 0 3
30613: PPUSH
30614: CALL 79172 0 1
// exit ;
30618: POP
30619: POP
30620: GO 30626
// end ; end ;
30622: GO 30552
30624: POP
30625: POP
// end ;
30626: LD_VAR 0 1
30630: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
30631: LD_INT 0
30633: PPUSH
30634: PPUSH
30635: PPUSH
30636: PPUSH
30637: PPUSH
30638: PPUSH
30639: PPUSH
// if not mc_bases then
30640: LD_EXP 50
30644: NOT
30645: IFFALSE 30649
// exit ;
30647: GO 31253
// for i = 1 to mc_bases do
30649: LD_ADDR_VAR 0 2
30653: PUSH
30654: DOUBLE
30655: LD_INT 1
30657: DEC
30658: ST_TO_ADDR
30659: LD_EXP 50
30663: PUSH
30664: FOR_TO
30665: IFFALSE 31251
// begin if not mc_bases [ i ] then
30667: LD_EXP 50
30671: PUSH
30672: LD_VAR 0 2
30676: ARRAY
30677: NOT
30678: IFFALSE 30682
// continue ;
30680: GO 30664
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
30682: LD_ADDR_VAR 0 7
30686: PUSH
30687: LD_EXP 50
30691: PUSH
30692: LD_VAR 0 2
30696: ARRAY
30697: PUSH
30698: LD_INT 1
30700: ARRAY
30701: PPUSH
30702: CALL 47777 0 1
30706: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
30707: LD_ADDR_EXP 73
30711: PUSH
30712: LD_EXP 73
30716: PPUSH
30717: LD_VAR 0 2
30721: PPUSH
30722: LD_EXP 50
30726: PUSH
30727: LD_VAR 0 2
30731: ARRAY
30732: PUSH
30733: LD_INT 1
30735: ARRAY
30736: PPUSH
30737: CALL_OW 255
30741: PPUSH
30742: LD_EXP 75
30746: PUSH
30747: LD_VAR 0 2
30751: ARRAY
30752: PPUSH
30753: CALL 45737 0 2
30757: PPUSH
30758: CALL_OW 1
30762: ST_TO_ADDR
// if not mc_scan [ i ] then
30763: LD_EXP 73
30767: PUSH
30768: LD_VAR 0 2
30772: ARRAY
30773: NOT
30774: IFFALSE 30929
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
30776: LD_ADDR_VAR 0 4
30780: PUSH
30781: LD_EXP 50
30785: PUSH
30786: LD_VAR 0 2
30790: ARRAY
30791: PPUSH
30792: LD_INT 2
30794: PUSH
30795: LD_INT 25
30797: PUSH
30798: LD_INT 5
30800: PUSH
30801: EMPTY
30802: LIST
30803: LIST
30804: PUSH
30805: LD_INT 25
30807: PUSH
30808: LD_INT 8
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: LD_INT 25
30817: PUSH
30818: LD_INT 9
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: PUSH
30825: EMPTY
30826: LIST
30827: LIST
30828: LIST
30829: LIST
30830: PPUSH
30831: CALL_OW 72
30835: ST_TO_ADDR
// if not tmp then
30836: LD_VAR 0 4
30840: NOT
30841: IFFALSE 30845
// continue ;
30843: GO 30664
// for j in tmp do
30845: LD_ADDR_VAR 0 3
30849: PUSH
30850: LD_VAR 0 4
30854: PUSH
30855: FOR_IN
30856: IFFALSE 30927
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
30858: LD_VAR 0 3
30862: PPUSH
30863: CALL_OW 310
30867: PPUSH
30868: CALL_OW 266
30872: PUSH
30873: LD_INT 5
30875: EQUAL
30876: PUSH
30877: LD_VAR 0 3
30881: PPUSH
30882: CALL_OW 257
30886: PUSH
30887: LD_INT 1
30889: EQUAL
30890: AND
30891: PUSH
30892: LD_VAR 0 3
30896: PPUSH
30897: CALL_OW 459
30901: NOT
30902: AND
30903: PUSH
30904: LD_VAR 0 7
30908: AND
30909: IFFALSE 30925
// ComChangeProfession ( j , class ) ;
30911: LD_VAR 0 3
30915: PPUSH
30916: LD_VAR 0 7
30920: PPUSH
30921: CALL_OW 123
30925: GO 30855
30927: POP
30928: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
30929: LD_EXP 73
30933: PUSH
30934: LD_VAR 0 2
30938: ARRAY
30939: PUSH
30940: LD_EXP 72
30944: PUSH
30945: LD_VAR 0 2
30949: ARRAY
30950: NOT
30951: AND
30952: PUSH
30953: LD_EXP 50
30957: PUSH
30958: LD_VAR 0 2
30962: ARRAY
30963: PPUSH
30964: LD_INT 30
30966: PUSH
30967: LD_INT 32
30969: PUSH
30970: EMPTY
30971: LIST
30972: LIST
30973: PPUSH
30974: CALL_OW 72
30978: NOT
30979: AND
30980: PUSH
30981: LD_EXP 50
30985: PUSH
30986: LD_VAR 0 2
30990: ARRAY
30991: PPUSH
30992: LD_INT 2
30994: PUSH
30995: LD_INT 30
30997: PUSH
30998: LD_INT 4
31000: PUSH
31001: EMPTY
31002: LIST
31003: LIST
31004: PUSH
31005: LD_INT 30
31007: PUSH
31008: LD_INT 5
31010: PUSH
31011: EMPTY
31012: LIST
31013: LIST
31014: PUSH
31015: EMPTY
31016: LIST
31017: LIST
31018: LIST
31019: PPUSH
31020: CALL_OW 72
31024: NOT
31025: AND
31026: IFFALSE 31158
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
31028: LD_ADDR_VAR 0 4
31032: PUSH
31033: LD_EXP 50
31037: PUSH
31038: LD_VAR 0 2
31042: ARRAY
31043: PPUSH
31044: LD_INT 2
31046: PUSH
31047: LD_INT 25
31049: PUSH
31050: LD_INT 1
31052: PUSH
31053: EMPTY
31054: LIST
31055: LIST
31056: PUSH
31057: LD_INT 25
31059: PUSH
31060: LD_INT 5
31062: PUSH
31063: EMPTY
31064: LIST
31065: LIST
31066: PUSH
31067: LD_INT 25
31069: PUSH
31070: LD_INT 8
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: PUSH
31077: LD_INT 25
31079: PUSH
31080: LD_INT 9
31082: PUSH
31083: EMPTY
31084: LIST
31085: LIST
31086: PUSH
31087: EMPTY
31088: LIST
31089: LIST
31090: LIST
31091: LIST
31092: LIST
31093: PPUSH
31094: CALL_OW 72
31098: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
31099: LD_ADDR_VAR 0 4
31103: PUSH
31104: LD_VAR 0 4
31108: PUSH
31109: LD_VAR 0 4
31113: PPUSH
31114: LD_INT 18
31116: PPUSH
31117: CALL 83916 0 2
31121: DIFF
31122: ST_TO_ADDR
// if tmp then
31123: LD_VAR 0 4
31127: IFFALSE 31158
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
31129: LD_VAR 0 2
31133: PPUSH
31134: LD_VAR 0 4
31138: PPUSH
31139: LD_EXP 75
31143: PUSH
31144: LD_VAR 0 2
31148: ARRAY
31149: PPUSH
31150: CALL 45772 0 3
// exit ;
31154: POP
31155: POP
31156: GO 31253
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
31158: LD_EXP 73
31162: PUSH
31163: LD_VAR 0 2
31167: ARRAY
31168: PUSH
31169: LD_EXP 72
31173: PUSH
31174: LD_VAR 0 2
31178: ARRAY
31179: AND
31180: IFFALSE 31249
// begin tmp := mc_defender [ i ] ;
31182: LD_ADDR_VAR 0 4
31186: PUSH
31187: LD_EXP 72
31191: PUSH
31192: LD_VAR 0 2
31196: ARRAY
31197: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
31198: LD_ADDR_EXP 72
31202: PUSH
31203: LD_EXP 72
31207: PPUSH
31208: LD_VAR 0 2
31212: PPUSH
31213: EMPTY
31214: PPUSH
31215: CALL_OW 1
31219: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
31220: LD_VAR 0 2
31224: PPUSH
31225: LD_VAR 0 4
31229: PPUSH
31230: LD_EXP 73
31234: PUSH
31235: LD_VAR 0 2
31239: ARRAY
31240: PPUSH
31241: CALL 46270 0 3
// exit ;
31245: POP
31246: POP
31247: GO 31253
// end ; end ;
31249: GO 30664
31251: POP
31252: POP
// end ;
31253: LD_VAR 0 1
31257: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
31258: LD_INT 0
31260: PPUSH
31261: PPUSH
31262: PPUSH
31263: PPUSH
31264: PPUSH
31265: PPUSH
31266: PPUSH
31267: PPUSH
31268: PPUSH
31269: PPUSH
31270: PPUSH
// if not mc_bases then
31271: LD_EXP 50
31275: NOT
31276: IFFALSE 31280
// exit ;
31278: GO 32340
// for i = 1 to mc_bases do
31280: LD_ADDR_VAR 0 2
31284: PUSH
31285: DOUBLE
31286: LD_INT 1
31288: DEC
31289: ST_TO_ADDR
31290: LD_EXP 50
31294: PUSH
31295: FOR_TO
31296: IFFALSE 32338
// begin tmp := mc_lab [ i ] ;
31298: LD_ADDR_VAR 0 6
31302: PUSH
31303: LD_EXP 83
31307: PUSH
31308: LD_VAR 0 2
31312: ARRAY
31313: ST_TO_ADDR
// if not tmp then
31314: LD_VAR 0 6
31318: NOT
31319: IFFALSE 31323
// continue ;
31321: GO 31295
// idle_lab := 0 ;
31323: LD_ADDR_VAR 0 11
31327: PUSH
31328: LD_INT 0
31330: ST_TO_ADDR
// for j in tmp do
31331: LD_ADDR_VAR 0 3
31335: PUSH
31336: LD_VAR 0 6
31340: PUSH
31341: FOR_IN
31342: IFFALSE 32334
// begin researching := false ;
31344: LD_ADDR_VAR 0 10
31348: PUSH
31349: LD_INT 0
31351: ST_TO_ADDR
// side := GetSide ( j ) ;
31352: LD_ADDR_VAR 0 4
31356: PUSH
31357: LD_VAR 0 3
31361: PPUSH
31362: CALL_OW 255
31366: ST_TO_ADDR
// if not mc_tech [ side ] then
31367: LD_EXP 77
31371: PUSH
31372: LD_VAR 0 4
31376: ARRAY
31377: NOT
31378: IFFALSE 31382
// continue ;
31380: GO 31341
// if BuildingStatus ( j ) = bs_idle then
31382: LD_VAR 0 3
31386: PPUSH
31387: CALL_OW 461
31391: PUSH
31392: LD_INT 2
31394: EQUAL
31395: IFFALSE 31568
// begin if idle_lab then
31397: LD_VAR 0 11
31401: IFFALSE 31472
// begin tmp2 := UnitsInside ( idle_lab ) ;
31403: LD_ADDR_VAR 0 9
31407: PUSH
31408: LD_VAR 0 11
31412: PPUSH
31413: CALL_OW 313
31417: ST_TO_ADDR
// if tmp2 then
31418: LD_VAR 0 9
31422: IFFALSE 31464
// for x in tmp2 do
31424: LD_ADDR_VAR 0 7
31428: PUSH
31429: LD_VAR 0 9
31433: PUSH
31434: FOR_IN
31435: IFFALSE 31462
// begin ComExitBuilding ( x ) ;
31437: LD_VAR 0 7
31441: PPUSH
31442: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
31446: LD_VAR 0 7
31450: PPUSH
31451: LD_VAR 0 3
31455: PPUSH
31456: CALL_OW 180
// end ;
31460: GO 31434
31462: POP
31463: POP
// idle_lab := 0 ;
31464: LD_ADDR_VAR 0 11
31468: PUSH
31469: LD_INT 0
31471: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
31472: LD_ADDR_VAR 0 5
31476: PUSH
31477: LD_EXP 77
31481: PUSH
31482: LD_VAR 0 4
31486: ARRAY
31487: PUSH
31488: FOR_IN
31489: IFFALSE 31549
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
31491: LD_VAR 0 3
31495: PPUSH
31496: LD_VAR 0 5
31500: PPUSH
31501: CALL_OW 430
31505: PUSH
31506: LD_VAR 0 4
31510: PPUSH
31511: LD_VAR 0 5
31515: PPUSH
31516: CALL 44842 0 2
31520: AND
31521: IFFALSE 31547
// begin researching := true ;
31523: LD_ADDR_VAR 0 10
31527: PUSH
31528: LD_INT 1
31530: ST_TO_ADDR
// ComResearch ( j , t ) ;
31531: LD_VAR 0 3
31535: PPUSH
31536: LD_VAR 0 5
31540: PPUSH
31541: CALL_OW 124
// break ;
31545: GO 31549
// end ;
31547: GO 31488
31549: POP
31550: POP
// if not researching then
31551: LD_VAR 0 10
31555: NOT
31556: IFFALSE 31568
// idle_lab := j ;
31558: LD_ADDR_VAR 0 11
31562: PUSH
31563: LD_VAR 0 3
31567: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
31568: LD_VAR 0 3
31572: PPUSH
31573: CALL_OW 461
31577: PUSH
31578: LD_INT 10
31580: EQUAL
31581: IFFALSE 32169
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
31583: LD_EXP 79
31587: PUSH
31588: LD_VAR 0 2
31592: ARRAY
31593: NOT
31594: PUSH
31595: LD_EXP 80
31599: PUSH
31600: LD_VAR 0 2
31604: ARRAY
31605: NOT
31606: AND
31607: PUSH
31608: LD_EXP 77
31612: PUSH
31613: LD_VAR 0 4
31617: ARRAY
31618: PUSH
31619: LD_INT 1
31621: GREATER
31622: AND
31623: IFFALSE 31754
// begin ComCancel ( j ) ;
31625: LD_VAR 0 3
31629: PPUSH
31630: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
31634: LD_ADDR_EXP 77
31638: PUSH
31639: LD_EXP 77
31643: PPUSH
31644: LD_VAR 0 4
31648: PPUSH
31649: LD_EXP 77
31653: PUSH
31654: LD_VAR 0 4
31658: ARRAY
31659: PPUSH
31660: LD_EXP 77
31664: PUSH
31665: LD_VAR 0 4
31669: ARRAY
31670: PUSH
31671: LD_INT 1
31673: MINUS
31674: PPUSH
31675: LD_EXP 77
31679: PUSH
31680: LD_VAR 0 4
31684: ARRAY
31685: PPUSH
31686: LD_INT 0
31688: PPUSH
31689: CALL 50291 0 4
31693: PPUSH
31694: CALL_OW 1
31698: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
31699: LD_ADDR_EXP 77
31703: PUSH
31704: LD_EXP 77
31708: PPUSH
31709: LD_VAR 0 4
31713: PPUSH
31714: LD_EXP 77
31718: PUSH
31719: LD_VAR 0 4
31723: ARRAY
31724: PPUSH
31725: LD_EXP 77
31729: PUSH
31730: LD_VAR 0 4
31734: ARRAY
31735: PPUSH
31736: LD_INT 1
31738: PPUSH
31739: LD_INT 0
31741: PPUSH
31742: CALL 50291 0 4
31746: PPUSH
31747: CALL_OW 1
31751: ST_TO_ADDR
// continue ;
31752: GO 31341
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
31754: LD_EXP 79
31758: PUSH
31759: LD_VAR 0 2
31763: ARRAY
31764: PUSH
31765: LD_EXP 80
31769: PUSH
31770: LD_VAR 0 2
31774: ARRAY
31775: NOT
31776: AND
31777: IFFALSE 31904
// begin mc_ape_in_lab := Add ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
31779: LD_ADDR_EXP 80
31783: PUSH
31784: LD_EXP 80
31788: PPUSH
31789: LD_VAR 0 2
31793: PUSH
31794: LD_EXP 80
31798: PUSH
31799: LD_VAR 0 2
31803: ARRAY
31804: PUSH
31805: LD_INT 1
31807: PLUS
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PPUSH
31813: LD_EXP 79
31817: PUSH
31818: LD_VAR 0 2
31822: ARRAY
31823: PUSH
31824: LD_INT 1
31826: ARRAY
31827: PPUSH
31828: CALL 51308 0 3
31832: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
31833: LD_EXP 79
31837: PUSH
31838: LD_VAR 0 2
31842: ARRAY
31843: PUSH
31844: LD_INT 1
31846: ARRAY
31847: PPUSH
31848: LD_INT 112
31850: PPUSH
31851: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
31855: LD_ADDR_VAR 0 9
31859: PUSH
31860: LD_EXP 79
31864: PUSH
31865: LD_VAR 0 2
31869: ARRAY
31870: PPUSH
31871: LD_INT 1
31873: PPUSH
31874: CALL_OW 3
31878: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
31879: LD_ADDR_EXP 79
31883: PUSH
31884: LD_EXP 79
31888: PPUSH
31889: LD_VAR 0 2
31893: PPUSH
31894: LD_VAR 0 9
31898: PPUSH
31899: CALL_OW 1
31903: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
31904: LD_EXP 79
31908: PUSH
31909: LD_VAR 0 2
31913: ARRAY
31914: PUSH
31915: LD_EXP 80
31919: PUSH
31920: LD_VAR 0 2
31924: ARRAY
31925: AND
31926: PUSH
31927: LD_EXP 80
31931: PUSH
31932: LD_VAR 0 2
31936: ARRAY
31937: PUSH
31938: LD_INT 1
31940: ARRAY
31941: PPUSH
31942: CALL_OW 310
31946: NOT
31947: AND
31948: PUSH
31949: LD_VAR 0 3
31953: PPUSH
31954: CALL_OW 313
31958: PUSH
31959: LD_INT 6
31961: EQUAL
31962: AND
31963: IFFALSE 32019
// begin tmp2 := UnitsInside ( j ) ;
31965: LD_ADDR_VAR 0 9
31969: PUSH
31970: LD_VAR 0 3
31974: PPUSH
31975: CALL_OW 313
31979: ST_TO_ADDR
// if tmp2 = 6 then
31980: LD_VAR 0 9
31984: PUSH
31985: LD_INT 6
31987: EQUAL
31988: IFFALSE 32019
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
31990: LD_VAR 0 9
31994: PUSH
31995: LD_INT 1
31997: ARRAY
31998: PPUSH
31999: LD_INT 112
32001: PPUSH
32002: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
32006: LD_VAR 0 9
32010: PUSH
32011: LD_INT 1
32013: ARRAY
32014: PPUSH
32015: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
32019: LD_EXP 80
32023: PUSH
32024: LD_VAR 0 2
32028: ARRAY
32029: PUSH
32030: LD_EXP 80
32034: PUSH
32035: LD_VAR 0 2
32039: ARRAY
32040: PUSH
32041: LD_INT 1
32043: ARRAY
32044: PPUSH
32045: CALL_OW 314
32049: NOT
32050: AND
32051: PUSH
32052: LD_EXP 80
32056: PUSH
32057: LD_VAR 0 2
32061: ARRAY
32062: PUSH
32063: LD_INT 1
32065: ARRAY
32066: PPUSH
32067: CALL_OW 310
32071: NOT
32072: AND
32073: IFFALSE 32099
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
32075: LD_EXP 80
32079: PUSH
32080: LD_VAR 0 2
32084: ARRAY
32085: PUSH
32086: LD_INT 1
32088: ARRAY
32089: PPUSH
32090: LD_VAR 0 3
32094: PPUSH
32095: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
32099: LD_EXP 80
32103: PUSH
32104: LD_VAR 0 2
32108: ARRAY
32109: PUSH
32110: LD_INT 1
32112: ARRAY
32113: PPUSH
32114: CALL_OW 310
32118: PUSH
32119: LD_EXP 80
32123: PUSH
32124: LD_VAR 0 2
32128: ARRAY
32129: PUSH
32130: LD_INT 1
32132: ARRAY
32133: PPUSH
32134: CALL_OW 310
32138: PPUSH
32139: CALL_OW 461
32143: PUSH
32144: LD_INT 3
32146: NONEQUAL
32147: AND
32148: IFFALSE 32169
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
32150: LD_EXP 80
32154: PUSH
32155: LD_VAR 0 2
32159: ARRAY
32160: PUSH
32161: LD_INT 1
32163: ARRAY
32164: PPUSH
32165: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
32169: LD_VAR 0 3
32173: PPUSH
32174: CALL_OW 461
32178: PUSH
32179: LD_INT 6
32181: EQUAL
32182: PUSH
32183: LD_VAR 0 6
32187: PUSH
32188: LD_INT 1
32190: GREATER
32191: AND
32192: IFFALSE 32332
// begin sci := [ ] ;
32194: LD_ADDR_VAR 0 8
32198: PUSH
32199: EMPTY
32200: ST_TO_ADDR
// for x in tmp diff j do
32201: LD_ADDR_VAR 0 7
32205: PUSH
32206: LD_VAR 0 6
32210: PUSH
32211: LD_VAR 0 3
32215: DIFF
32216: PUSH
32217: FOR_IN
32218: IFFALSE 32258
// begin if BuildingStatus ( x ) = bs_idle then
32220: LD_VAR 0 7
32224: PPUSH
32225: CALL_OW 461
32229: PUSH
32230: LD_INT 2
32232: EQUAL
32233: IFFALSE 32256
// sci := sci ^ UnitsInside ( x ) ;
32235: LD_ADDR_VAR 0 8
32239: PUSH
32240: LD_VAR 0 8
32244: PUSH
32245: LD_VAR 0 7
32249: PPUSH
32250: CALL_OW 313
32254: ADD
32255: ST_TO_ADDR
// end ;
32256: GO 32217
32258: POP
32259: POP
// if not sci then
32260: LD_VAR 0 8
32264: NOT
32265: IFFALSE 32269
// continue ;
32267: GO 31341
// for x in sci do
32269: LD_ADDR_VAR 0 7
32273: PUSH
32274: LD_VAR 0 8
32278: PUSH
32279: FOR_IN
32280: IFFALSE 32330
// if IsInUnit ( x ) and not HasTask ( x ) then
32282: LD_VAR 0 7
32286: PPUSH
32287: CALL_OW 310
32291: PUSH
32292: LD_VAR 0 7
32296: PPUSH
32297: CALL_OW 314
32301: NOT
32302: AND
32303: IFFALSE 32328
// begin ComExitBuilding ( x ) ;
32305: LD_VAR 0 7
32309: PPUSH
32310: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
32314: LD_VAR 0 7
32318: PPUSH
32319: LD_VAR 0 3
32323: PPUSH
32324: CALL_OW 180
// end ;
32328: GO 32279
32330: POP
32331: POP
// end ; end ;
32332: GO 31341
32334: POP
32335: POP
// end ;
32336: GO 31295
32338: POP
32339: POP
// end ;
32340: LD_VAR 0 1
32344: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
32345: LD_INT 0
32347: PPUSH
32348: PPUSH
// if not mc_bases then
32349: LD_EXP 50
32353: NOT
32354: IFFALSE 32358
// exit ;
32356: GO 32439
// for i = 1 to mc_bases do
32358: LD_ADDR_VAR 0 2
32362: PUSH
32363: DOUBLE
32364: LD_INT 1
32366: DEC
32367: ST_TO_ADDR
32368: LD_EXP 50
32372: PUSH
32373: FOR_TO
32374: IFFALSE 32437
// if mc_mines [ i ] and mc_miners [ i ] then
32376: LD_EXP 63
32380: PUSH
32381: LD_VAR 0 2
32385: ARRAY
32386: PUSH
32387: LD_EXP 64
32391: PUSH
32392: LD_VAR 0 2
32396: ARRAY
32397: AND
32398: IFFALSE 32435
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
32400: LD_EXP 64
32404: PUSH
32405: LD_VAR 0 2
32409: ARRAY
32410: PUSH
32411: LD_INT 1
32413: ARRAY
32414: PPUSH
32415: CALL_OW 255
32419: PPUSH
32420: LD_EXP 63
32424: PUSH
32425: LD_VAR 0 2
32429: ARRAY
32430: PPUSH
32431: CALL 47930 0 2
32435: GO 32373
32437: POP
32438: POP
// end ;
32439: LD_VAR 0 1
32443: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
32444: LD_INT 0
32446: PPUSH
32447: PPUSH
32448: PPUSH
32449: PPUSH
32450: PPUSH
32451: PPUSH
32452: PPUSH
32453: PPUSH
// if not mc_bases or not mc_parking then
32454: LD_EXP 50
32458: NOT
32459: PUSH
32460: LD_EXP 74
32464: NOT
32465: OR
32466: IFFALSE 32470
// exit ;
32468: GO 33182
// for i = 1 to mc_bases do
32470: LD_ADDR_VAR 0 2
32474: PUSH
32475: DOUBLE
32476: LD_INT 1
32478: DEC
32479: ST_TO_ADDR
32480: LD_EXP 50
32484: PUSH
32485: FOR_TO
32486: IFFALSE 33180
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
32488: LD_EXP 50
32492: PUSH
32493: LD_VAR 0 2
32497: ARRAY
32498: NOT
32499: PUSH
32500: LD_EXP 74
32504: PUSH
32505: LD_VAR 0 2
32509: ARRAY
32510: NOT
32511: OR
32512: IFFALSE 32516
// continue ;
32514: GO 32485
// if mc_scan [ i ] then
32516: LD_EXP 73
32520: PUSH
32521: LD_VAR 0 2
32525: ARRAY
32526: IFFALSE 32552
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
32528: LD_ADDR_EXP 62
32532: PUSH
32533: LD_EXP 62
32537: PPUSH
32538: LD_VAR 0 2
32542: PPUSH
32543: EMPTY
32544: PPUSH
32545: CALL_OW 1
32549: ST_TO_ADDR
// continue ;
32550: GO 32485
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
32552: LD_ADDR_VAR 0 5
32556: PUSH
32557: LD_EXP 50
32561: PUSH
32562: LD_VAR 0 2
32566: ARRAY
32567: PUSH
32568: LD_INT 1
32570: ARRAY
32571: PPUSH
32572: CALL_OW 255
32576: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32577: LD_ADDR_VAR 0 6
32581: PUSH
32582: LD_EXP 50
32586: PUSH
32587: LD_VAR 0 2
32591: ARRAY
32592: PPUSH
32593: LD_INT 30
32595: PUSH
32596: LD_INT 3
32598: PUSH
32599: EMPTY
32600: LIST
32601: LIST
32602: PPUSH
32603: CALL_OW 72
32607: ST_TO_ADDR
// if not fac then
32608: LD_VAR 0 6
32612: NOT
32613: IFFALSE 32664
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32615: LD_ADDR_VAR 0 6
32619: PUSH
32620: LD_EXP 50
32624: PUSH
32625: LD_VAR 0 2
32629: ARRAY
32630: PPUSH
32631: LD_INT 2
32633: PUSH
32634: LD_INT 30
32636: PUSH
32637: LD_INT 0
32639: PUSH
32640: EMPTY
32641: LIST
32642: LIST
32643: PUSH
32644: LD_INT 30
32646: PUSH
32647: LD_INT 1
32649: PUSH
32650: EMPTY
32651: LIST
32652: LIST
32653: PUSH
32654: EMPTY
32655: LIST
32656: LIST
32657: LIST
32658: PPUSH
32659: CALL_OW 72
32663: ST_TO_ADDR
// if not fac then
32664: LD_VAR 0 6
32668: NOT
32669: IFFALSE 32673
// continue ;
32671: GO 32485
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
32673: LD_ADDR_VAR 0 7
32677: PUSH
32678: LD_EXP 74
32682: PUSH
32683: LD_VAR 0 2
32687: ARRAY
32688: PPUSH
32689: LD_INT 22
32691: PUSH
32692: LD_VAR 0 5
32696: PUSH
32697: EMPTY
32698: LIST
32699: LIST
32700: PUSH
32701: LD_INT 21
32703: PUSH
32704: LD_INT 2
32706: PUSH
32707: EMPTY
32708: LIST
32709: LIST
32710: PUSH
32711: LD_INT 3
32713: PUSH
32714: LD_INT 24
32716: PUSH
32717: LD_INT 1000
32719: PUSH
32720: EMPTY
32721: LIST
32722: LIST
32723: PUSH
32724: EMPTY
32725: LIST
32726: LIST
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: LIST
32732: PPUSH
32733: CALL_OW 70
32737: PUSH
32738: LD_INT 22
32740: PUSH
32741: LD_VAR 0 5
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: PUSH
32750: LD_INT 91
32752: PUSH
32753: LD_VAR 0 6
32757: PUSH
32758: LD_INT 1
32760: ARRAY
32761: PUSH
32762: LD_INT 25
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: LIST
32769: PUSH
32770: LD_INT 21
32772: PUSH
32773: LD_INT 2
32775: PUSH
32776: EMPTY
32777: LIST
32778: LIST
32779: PUSH
32780: LD_INT 3
32782: PUSH
32783: LD_INT 24
32785: PUSH
32786: LD_INT 1000
32788: PUSH
32789: EMPTY
32790: LIST
32791: LIST
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: LIST
32801: LIST
32802: PPUSH
32803: CALL_OW 69
32807: UNION
32808: ST_TO_ADDR
// if not vehs then
32809: LD_VAR 0 7
32813: NOT
32814: IFFALSE 32840
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
32816: LD_ADDR_EXP 62
32820: PUSH
32821: LD_EXP 62
32825: PPUSH
32826: LD_VAR 0 2
32830: PPUSH
32831: EMPTY
32832: PPUSH
32833: CALL_OW 1
32837: ST_TO_ADDR
// continue ;
32838: GO 32485
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32840: LD_ADDR_VAR 0 8
32844: PUSH
32845: LD_EXP 50
32849: PUSH
32850: LD_VAR 0 2
32854: ARRAY
32855: PPUSH
32856: LD_INT 30
32858: PUSH
32859: LD_INT 3
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: PPUSH
32866: CALL_OW 72
32870: ST_TO_ADDR
// if tmp then
32871: LD_VAR 0 8
32875: IFFALSE 32978
// begin for j in tmp do
32877: LD_ADDR_VAR 0 3
32881: PUSH
32882: LD_VAR 0 8
32886: PUSH
32887: FOR_IN
32888: IFFALSE 32976
// for k in UnitsInside ( j ) do
32890: LD_ADDR_VAR 0 4
32894: PUSH
32895: LD_VAR 0 3
32899: PPUSH
32900: CALL_OW 313
32904: PUSH
32905: FOR_IN
32906: IFFALSE 32972
// if k then
32908: LD_VAR 0 4
32912: IFFALSE 32970
// if not k in mc_repair_vehicle [ i ] then
32914: LD_VAR 0 4
32918: PUSH
32919: LD_EXP 62
32923: PUSH
32924: LD_VAR 0 2
32928: ARRAY
32929: IN
32930: NOT
32931: IFFALSE 32970
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
32933: LD_ADDR_EXP 62
32937: PUSH
32938: LD_EXP 62
32942: PPUSH
32943: LD_VAR 0 2
32947: PPUSH
32948: LD_EXP 62
32952: PUSH
32953: LD_VAR 0 2
32957: ARRAY
32958: PUSH
32959: LD_VAR 0 4
32963: UNION
32964: PPUSH
32965: CALL_OW 1
32969: ST_TO_ADDR
32970: GO 32905
32972: POP
32973: POP
32974: GO 32887
32976: POP
32977: POP
// end ; if not mc_repair_vehicle [ i ] then
32978: LD_EXP 62
32982: PUSH
32983: LD_VAR 0 2
32987: ARRAY
32988: NOT
32989: IFFALSE 32993
// continue ;
32991: GO 32485
// for j in mc_repair_vehicle [ i ] do
32993: LD_ADDR_VAR 0 3
32997: PUSH
32998: LD_EXP 62
33002: PUSH
33003: LD_VAR 0 2
33007: ARRAY
33008: PUSH
33009: FOR_IN
33010: IFFALSE 33176
// begin if GetClass ( j ) <> 3 then
33012: LD_VAR 0 3
33016: PPUSH
33017: CALL_OW 257
33021: PUSH
33022: LD_INT 3
33024: NONEQUAL
33025: IFFALSE 33066
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
33027: LD_ADDR_EXP 62
33031: PUSH
33032: LD_EXP 62
33036: PPUSH
33037: LD_VAR 0 2
33041: PPUSH
33042: LD_EXP 62
33046: PUSH
33047: LD_VAR 0 2
33051: ARRAY
33052: PUSH
33053: LD_VAR 0 3
33057: DIFF
33058: PPUSH
33059: CALL_OW 1
33063: ST_TO_ADDR
// continue ;
33064: GO 33009
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
33066: LD_VAR 0 3
33070: PPUSH
33071: CALL_OW 311
33075: NOT
33076: PUSH
33077: LD_VAR 0 3
33081: PUSH
33082: LD_EXP 53
33086: PUSH
33087: LD_VAR 0 2
33091: ARRAY
33092: PUSH
33093: LD_INT 1
33095: ARRAY
33096: IN
33097: NOT
33098: AND
33099: PUSH
33100: LD_VAR 0 3
33104: PUSH
33105: LD_EXP 53
33109: PUSH
33110: LD_VAR 0 2
33114: ARRAY
33115: PUSH
33116: LD_INT 2
33118: ARRAY
33119: IN
33120: NOT
33121: AND
33122: IFFALSE 33174
// begin if IsInUnit ( j ) then
33124: LD_VAR 0 3
33128: PPUSH
33129: CALL_OW 310
33133: IFFALSE 33144
// ComExitBuilding ( j ) ;
33135: LD_VAR 0 3
33139: PPUSH
33140: CALL_OW 122
// if not HasTask ( j ) then
33144: LD_VAR 0 3
33148: PPUSH
33149: CALL_OW 314
33153: NOT
33154: IFFALSE 33174
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
33156: LD_VAR 0 3
33160: PPUSH
33161: LD_VAR 0 7
33165: PUSH
33166: LD_INT 1
33168: ARRAY
33169: PPUSH
33170: CALL_OW 189
// end ; end ;
33174: GO 33009
33176: POP
33177: POP
// end ;
33178: GO 32485
33180: POP
33181: POP
// end ;
33182: LD_VAR 0 1
33186: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
33187: LD_INT 0
33189: PPUSH
33190: PPUSH
33191: PPUSH
33192: PPUSH
33193: PPUSH
33194: PPUSH
33195: PPUSH
33196: PPUSH
33197: PPUSH
33198: PPUSH
33199: PPUSH
// if not mc_bases then
33200: LD_EXP 50
33204: NOT
33205: IFFALSE 33209
// exit ;
33207: GO 34011
// for i = 1 to mc_bases do
33209: LD_ADDR_VAR 0 2
33213: PUSH
33214: DOUBLE
33215: LD_INT 1
33217: DEC
33218: ST_TO_ADDR
33219: LD_EXP 50
33223: PUSH
33224: FOR_TO
33225: IFFALSE 34009
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
33227: LD_EXP 78
33231: PUSH
33232: LD_VAR 0 2
33236: ARRAY
33237: NOT
33238: PUSH
33239: LD_EXP 53
33243: PUSH
33244: LD_VAR 0 2
33248: ARRAY
33249: PUSH
33250: LD_INT 1
33252: ARRAY
33253: OR
33254: PUSH
33255: LD_EXP 53
33259: PUSH
33260: LD_VAR 0 2
33264: ARRAY
33265: PUSH
33266: LD_INT 2
33268: ARRAY
33269: OR
33270: PUSH
33271: LD_EXP 76
33275: PUSH
33276: LD_VAR 0 2
33280: ARRAY
33281: PPUSH
33282: LD_INT 1
33284: PPUSH
33285: CALL_OW 325
33289: NOT
33290: OR
33291: PUSH
33292: LD_EXP 73
33296: PUSH
33297: LD_VAR 0 2
33301: ARRAY
33302: OR
33303: IFFALSE 33307
// continue ;
33305: GO 33224
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
33307: LD_ADDR_VAR 0 8
33311: PUSH
33312: LD_EXP 50
33316: PUSH
33317: LD_VAR 0 2
33321: ARRAY
33322: PPUSH
33323: LD_INT 25
33325: PUSH
33326: LD_INT 4
33328: PUSH
33329: EMPTY
33330: LIST
33331: LIST
33332: PUSH
33333: LD_INT 50
33335: PUSH
33336: EMPTY
33337: LIST
33338: PUSH
33339: LD_INT 3
33341: PUSH
33342: LD_INT 60
33344: PUSH
33345: EMPTY
33346: LIST
33347: PUSH
33348: EMPTY
33349: LIST
33350: LIST
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: LIST
33356: PPUSH
33357: CALL_OW 72
33361: PUSH
33362: LD_EXP 54
33366: PUSH
33367: LD_VAR 0 2
33371: ARRAY
33372: DIFF
33373: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
33374: LD_ADDR_VAR 0 9
33378: PUSH
33379: LD_EXP 50
33383: PUSH
33384: LD_VAR 0 2
33388: ARRAY
33389: PPUSH
33390: LD_INT 2
33392: PUSH
33393: LD_INT 30
33395: PUSH
33396: LD_INT 0
33398: PUSH
33399: EMPTY
33400: LIST
33401: LIST
33402: PUSH
33403: LD_INT 30
33405: PUSH
33406: LD_INT 1
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: EMPTY
33414: LIST
33415: LIST
33416: LIST
33417: PPUSH
33418: CALL_OW 72
33422: ST_TO_ADDR
// if not tmp or not dep then
33423: LD_VAR 0 8
33427: NOT
33428: PUSH
33429: LD_VAR 0 9
33433: NOT
33434: OR
33435: IFFALSE 33439
// continue ;
33437: GO 33224
// side := GetSide ( tmp [ 1 ] ) ;
33439: LD_ADDR_VAR 0 11
33443: PUSH
33444: LD_VAR 0 8
33448: PUSH
33449: LD_INT 1
33451: ARRAY
33452: PPUSH
33453: CALL_OW 255
33457: ST_TO_ADDR
// dep := dep [ 1 ] ;
33458: LD_ADDR_VAR 0 9
33462: PUSH
33463: LD_VAR 0 9
33467: PUSH
33468: LD_INT 1
33470: ARRAY
33471: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
33472: LD_ADDR_VAR 0 7
33476: PUSH
33477: LD_EXP 78
33481: PUSH
33482: LD_VAR 0 2
33486: ARRAY
33487: PPUSH
33488: LD_INT 22
33490: PUSH
33491: LD_INT 0
33493: PUSH
33494: EMPTY
33495: LIST
33496: LIST
33497: PUSH
33498: LD_INT 25
33500: PUSH
33501: LD_INT 12
33503: PUSH
33504: EMPTY
33505: LIST
33506: LIST
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PPUSH
33512: CALL_OW 70
33516: PUSH
33517: LD_INT 22
33519: PUSH
33520: LD_INT 0
33522: PUSH
33523: EMPTY
33524: LIST
33525: LIST
33526: PUSH
33527: LD_INT 25
33529: PUSH
33530: LD_INT 12
33532: PUSH
33533: EMPTY
33534: LIST
33535: LIST
33536: PUSH
33537: LD_INT 91
33539: PUSH
33540: LD_VAR 0 9
33544: PUSH
33545: LD_INT 20
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: LIST
33552: PUSH
33553: EMPTY
33554: LIST
33555: LIST
33556: LIST
33557: PPUSH
33558: CALL_OW 69
33562: UNION
33563: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
33564: LD_ADDR_VAR 0 10
33568: PUSH
33569: LD_EXP 78
33573: PUSH
33574: LD_VAR 0 2
33578: ARRAY
33579: PPUSH
33580: LD_INT 81
33582: PUSH
33583: LD_VAR 0 11
33587: PUSH
33588: EMPTY
33589: LIST
33590: LIST
33591: PPUSH
33592: CALL_OW 70
33596: ST_TO_ADDR
// if not apes or danger_at_area then
33597: LD_VAR 0 7
33601: NOT
33602: PUSH
33603: LD_VAR 0 10
33607: OR
33608: IFFALSE 33658
// begin if mc_taming [ i ] then
33610: LD_EXP 81
33614: PUSH
33615: LD_VAR 0 2
33619: ARRAY
33620: IFFALSE 33656
// begin MC_Reset ( i , 121 ) ;
33622: LD_VAR 0 2
33626: PPUSH
33627: LD_INT 121
33629: PPUSH
33630: CALL 19681 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
33634: LD_ADDR_EXP 81
33638: PUSH
33639: LD_EXP 81
33643: PPUSH
33644: LD_VAR 0 2
33648: PPUSH
33649: EMPTY
33650: PPUSH
33651: CALL_OW 1
33655: ST_TO_ADDR
// end ; continue ;
33656: GO 33224
// end ; for j in tmp do
33658: LD_ADDR_VAR 0 3
33662: PUSH
33663: LD_VAR 0 8
33667: PUSH
33668: FOR_IN
33669: IFFALSE 34005
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
33671: LD_VAR 0 3
33675: PUSH
33676: LD_EXP 81
33680: PUSH
33681: LD_VAR 0 2
33685: ARRAY
33686: IN
33687: NOT
33688: PUSH
33689: LD_EXP 81
33693: PUSH
33694: LD_VAR 0 2
33698: ARRAY
33699: PUSH
33700: LD_INT 3
33702: LESS
33703: AND
33704: IFFALSE 33762
// begin SetTag ( j , 121 ) ;
33706: LD_VAR 0 3
33710: PPUSH
33711: LD_INT 121
33713: PPUSH
33714: CALL_OW 109
// mc_taming := Add ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
33718: LD_ADDR_EXP 81
33722: PUSH
33723: LD_EXP 81
33727: PPUSH
33728: LD_VAR 0 2
33732: PUSH
33733: LD_EXP 81
33737: PUSH
33738: LD_VAR 0 2
33742: ARRAY
33743: PUSH
33744: LD_INT 1
33746: PLUS
33747: PUSH
33748: EMPTY
33749: LIST
33750: LIST
33751: PPUSH
33752: LD_VAR 0 3
33756: PPUSH
33757: CALL 51308 0 3
33761: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
33762: LD_VAR 0 3
33766: PUSH
33767: LD_EXP 81
33771: PUSH
33772: LD_VAR 0 2
33776: ARRAY
33777: IN
33778: IFFALSE 34003
// begin if GetClass ( j ) <> 4 then
33780: LD_VAR 0 3
33784: PPUSH
33785: CALL_OW 257
33789: PUSH
33790: LD_INT 4
33792: NONEQUAL
33793: IFFALSE 33846
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
33795: LD_ADDR_EXP 81
33799: PUSH
33800: LD_EXP 81
33804: PPUSH
33805: LD_VAR 0 2
33809: PPUSH
33810: LD_EXP 81
33814: PUSH
33815: LD_VAR 0 2
33819: ARRAY
33820: PUSH
33821: LD_VAR 0 3
33825: DIFF
33826: PPUSH
33827: CALL_OW 1
33831: ST_TO_ADDR
// SetTag ( j , 0 ) ;
33832: LD_VAR 0 3
33836: PPUSH
33837: LD_INT 0
33839: PPUSH
33840: CALL_OW 109
// continue ;
33844: GO 33668
// end ; if IsInUnit ( j ) then
33846: LD_VAR 0 3
33850: PPUSH
33851: CALL_OW 310
33855: IFFALSE 33866
// ComExitBuilding ( j ) ;
33857: LD_VAR 0 3
33861: PPUSH
33862: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
33866: LD_ADDR_VAR 0 6
33870: PUSH
33871: LD_VAR 0 7
33875: PPUSH
33876: LD_VAR 0 3
33880: PPUSH
33881: CALL_OW 74
33885: ST_TO_ADDR
// if not ape then
33886: LD_VAR 0 6
33890: NOT
33891: IFFALSE 33895
// break ;
33893: GO 34005
// x := GetX ( ape ) ;
33895: LD_ADDR_VAR 0 4
33899: PUSH
33900: LD_VAR 0 6
33904: PPUSH
33905: CALL_OW 250
33909: ST_TO_ADDR
// y := GetY ( ape ) ;
33910: LD_ADDR_VAR 0 5
33914: PUSH
33915: LD_VAR 0 6
33919: PPUSH
33920: CALL_OW 251
33924: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
33925: LD_VAR 0 4
33929: PPUSH
33930: LD_VAR 0 5
33934: PPUSH
33935: CALL_OW 488
33939: NOT
33940: PUSH
33941: LD_VAR 0 11
33945: PPUSH
33946: LD_VAR 0 4
33950: PPUSH
33951: LD_VAR 0 5
33955: PPUSH
33956: LD_INT 20
33958: PPUSH
33959: CALL 51802 0 4
33963: PUSH
33964: LD_INT 4
33966: ARRAY
33967: OR
33968: IFFALSE 33972
// break ;
33970: GO 34005
// if not HasTask ( j ) then
33972: LD_VAR 0 3
33976: PPUSH
33977: CALL_OW 314
33981: NOT
33982: IFFALSE 34003
// ComTameXY ( j , x , y ) ;
33984: LD_VAR 0 3
33988: PPUSH
33989: LD_VAR 0 4
33993: PPUSH
33994: LD_VAR 0 5
33998: PPUSH
33999: CALL_OW 131
// end ; end ;
34003: GO 33668
34005: POP
34006: POP
// end ;
34007: GO 33224
34009: POP
34010: POP
// end ;
34011: LD_VAR 0 1
34015: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
34016: LD_INT 0
34018: PPUSH
34019: PPUSH
34020: PPUSH
34021: PPUSH
34022: PPUSH
34023: PPUSH
34024: PPUSH
34025: PPUSH
// if not mc_bases then
34026: LD_EXP 50
34030: NOT
34031: IFFALSE 34035
// exit ;
34033: GO 34661
// for i = 1 to mc_bases do
34035: LD_ADDR_VAR 0 2
34039: PUSH
34040: DOUBLE
34041: LD_INT 1
34043: DEC
34044: ST_TO_ADDR
34045: LD_EXP 50
34049: PUSH
34050: FOR_TO
34051: IFFALSE 34659
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
34053: LD_EXP 79
34057: PUSH
34058: LD_VAR 0 2
34062: ARRAY
34063: NOT
34064: PUSH
34065: LD_EXP 79
34069: PUSH
34070: LD_VAR 0 2
34074: ARRAY
34075: PPUSH
34076: LD_INT 25
34078: PUSH
34079: LD_INT 12
34081: PUSH
34082: EMPTY
34083: LIST
34084: LIST
34085: PPUSH
34086: CALL_OW 72
34090: NOT
34091: OR
34092: IFFALSE 34096
// continue ;
34094: GO 34050
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
34096: LD_ADDR_VAR 0 5
34100: PUSH
34101: LD_EXP 79
34105: PUSH
34106: LD_VAR 0 2
34110: ARRAY
34111: PUSH
34112: LD_INT 1
34114: ARRAY
34115: PPUSH
34116: CALL_OW 255
34120: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
34121: LD_VAR 0 5
34125: PPUSH
34126: LD_INT 2
34128: PPUSH
34129: CALL_OW 325
34133: IFFALSE 34386
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
34135: LD_ADDR_VAR 0 4
34139: PUSH
34140: LD_EXP 79
34144: PUSH
34145: LD_VAR 0 2
34149: ARRAY
34150: PPUSH
34151: LD_INT 25
34153: PUSH
34154: LD_INT 16
34156: PUSH
34157: EMPTY
34158: LIST
34159: LIST
34160: PPUSH
34161: CALL_OW 72
34165: ST_TO_ADDR
// if tmp < 6 then
34166: LD_VAR 0 4
34170: PUSH
34171: LD_INT 6
34173: LESS
34174: IFFALSE 34386
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34176: LD_ADDR_VAR 0 6
34180: PUSH
34181: LD_EXP 50
34185: PUSH
34186: LD_VAR 0 2
34190: ARRAY
34191: PPUSH
34192: LD_INT 2
34194: PUSH
34195: LD_INT 30
34197: PUSH
34198: LD_INT 0
34200: PUSH
34201: EMPTY
34202: LIST
34203: LIST
34204: PUSH
34205: LD_INT 30
34207: PUSH
34208: LD_INT 1
34210: PUSH
34211: EMPTY
34212: LIST
34213: LIST
34214: PUSH
34215: EMPTY
34216: LIST
34217: LIST
34218: LIST
34219: PPUSH
34220: CALL_OW 72
34224: ST_TO_ADDR
// if depot then
34225: LD_VAR 0 6
34229: IFFALSE 34386
// begin selected := 0 ;
34231: LD_ADDR_VAR 0 7
34235: PUSH
34236: LD_INT 0
34238: ST_TO_ADDR
// for j in depot do
34239: LD_ADDR_VAR 0 3
34243: PUSH
34244: LD_VAR 0 6
34248: PUSH
34249: FOR_IN
34250: IFFALSE 34281
// begin if UnitsInside ( j ) < 6 then
34252: LD_VAR 0 3
34256: PPUSH
34257: CALL_OW 313
34261: PUSH
34262: LD_INT 6
34264: LESS
34265: IFFALSE 34279
// begin selected := j ;
34267: LD_ADDR_VAR 0 7
34271: PUSH
34272: LD_VAR 0 3
34276: ST_TO_ADDR
// break ;
34277: GO 34281
// end ; end ;
34279: GO 34249
34281: POP
34282: POP
// if selected then
34283: LD_VAR 0 7
34287: IFFALSE 34386
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
34289: LD_ADDR_VAR 0 3
34293: PUSH
34294: LD_EXP 79
34298: PUSH
34299: LD_VAR 0 2
34303: ARRAY
34304: PPUSH
34305: LD_INT 25
34307: PUSH
34308: LD_INT 12
34310: PUSH
34311: EMPTY
34312: LIST
34313: LIST
34314: PPUSH
34315: CALL_OW 72
34319: PUSH
34320: FOR_IN
34321: IFFALSE 34384
// if not HasTask ( j ) then
34323: LD_VAR 0 3
34327: PPUSH
34328: CALL_OW 314
34332: NOT
34333: IFFALSE 34382
// begin if not IsInUnit ( j ) then
34335: LD_VAR 0 3
34339: PPUSH
34340: CALL_OW 310
34344: NOT
34345: IFFALSE 34361
// ComEnterUnit ( j , selected ) ;
34347: LD_VAR 0 3
34351: PPUSH
34352: LD_VAR 0 7
34356: PPUSH
34357: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
34361: LD_VAR 0 3
34365: PPUSH
34366: LD_INT 16
34368: PPUSH
34369: CALL_OW 183
// AddComExitBuilding ( j ) ;
34373: LD_VAR 0 3
34377: PPUSH
34378: CALL_OW 182
// end ;
34382: GO 34320
34384: POP
34385: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
34386: LD_VAR 0 5
34390: PPUSH
34391: LD_INT 11
34393: PPUSH
34394: CALL_OW 325
34398: IFFALSE 34657
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
34400: LD_ADDR_VAR 0 4
34404: PUSH
34405: LD_EXP 79
34409: PUSH
34410: LD_VAR 0 2
34414: ARRAY
34415: PPUSH
34416: LD_INT 25
34418: PUSH
34419: LD_INT 16
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: PPUSH
34426: CALL_OW 72
34430: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
34431: LD_VAR 0 4
34435: PUSH
34436: LD_INT 6
34438: GREATEREQUAL
34439: PUSH
34440: LD_VAR 0 5
34444: PPUSH
34445: LD_INT 2
34447: PPUSH
34448: CALL_OW 325
34452: NOT
34453: OR
34454: IFFALSE 34657
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
34456: LD_ADDR_VAR 0 8
34460: PUSH
34461: LD_EXP 50
34465: PUSH
34466: LD_VAR 0 2
34470: ARRAY
34471: PPUSH
34472: LD_INT 2
34474: PUSH
34475: LD_INT 30
34477: PUSH
34478: LD_INT 4
34480: PUSH
34481: EMPTY
34482: LIST
34483: LIST
34484: PUSH
34485: LD_INT 30
34487: PUSH
34488: LD_INT 5
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: EMPTY
34496: LIST
34497: LIST
34498: LIST
34499: PPUSH
34500: CALL_OW 72
34504: ST_TO_ADDR
// if barracks then
34505: LD_VAR 0 8
34509: IFFALSE 34657
// begin selected := 0 ;
34511: LD_ADDR_VAR 0 7
34515: PUSH
34516: LD_INT 0
34518: ST_TO_ADDR
// for j in barracks do
34519: LD_ADDR_VAR 0 3
34523: PUSH
34524: LD_VAR 0 8
34528: PUSH
34529: FOR_IN
34530: IFFALSE 34561
// begin if UnitsInside ( j ) < 6 then
34532: LD_VAR 0 3
34536: PPUSH
34537: CALL_OW 313
34541: PUSH
34542: LD_INT 6
34544: LESS
34545: IFFALSE 34559
// begin selected := j ;
34547: LD_ADDR_VAR 0 7
34551: PUSH
34552: LD_VAR 0 3
34556: ST_TO_ADDR
// break ;
34557: GO 34561
// end ; end ;
34559: GO 34529
34561: POP
34562: POP
// if selected then
34563: LD_VAR 0 7
34567: IFFALSE 34657
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
34569: LD_ADDR_VAR 0 3
34573: PUSH
34574: LD_EXP 79
34578: PUSH
34579: LD_VAR 0 2
34583: ARRAY
34584: PPUSH
34585: LD_INT 25
34587: PUSH
34588: LD_INT 12
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PPUSH
34595: CALL_OW 72
34599: PUSH
34600: FOR_IN
34601: IFFALSE 34655
// if not IsInUnit ( j ) and not HasTask ( j ) then
34603: LD_VAR 0 3
34607: PPUSH
34608: CALL_OW 310
34612: NOT
34613: PUSH
34614: LD_VAR 0 3
34618: PPUSH
34619: CALL_OW 314
34623: NOT
34624: AND
34625: IFFALSE 34653
// begin ComEnterUnit ( j , selected ) ;
34627: LD_VAR 0 3
34631: PPUSH
34632: LD_VAR 0 7
34636: PPUSH
34637: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
34641: LD_VAR 0 3
34645: PPUSH
34646: LD_INT 15
34648: PPUSH
34649: CALL_OW 183
// end ;
34653: GO 34600
34655: POP
34656: POP
// end ; end ; end ; end ; end ;
34657: GO 34050
34659: POP
34660: POP
// end ;
34661: LD_VAR 0 1
34665: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
34666: LD_INT 0
34668: PPUSH
34669: PPUSH
34670: PPUSH
34671: PPUSH
// if not mc_bases then
34672: LD_EXP 50
34676: NOT
34677: IFFALSE 34681
// exit ;
34679: GO 34859
// for i = 1 to mc_bases do
34681: LD_ADDR_VAR 0 2
34685: PUSH
34686: DOUBLE
34687: LD_INT 1
34689: DEC
34690: ST_TO_ADDR
34691: LD_EXP 50
34695: PUSH
34696: FOR_TO
34697: IFFALSE 34857
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
34699: LD_ADDR_VAR 0 4
34703: PUSH
34704: LD_EXP 50
34708: PUSH
34709: LD_VAR 0 2
34713: ARRAY
34714: PPUSH
34715: LD_INT 25
34717: PUSH
34718: LD_INT 9
34720: PUSH
34721: EMPTY
34722: LIST
34723: LIST
34724: PPUSH
34725: CALL_OW 72
34729: ST_TO_ADDR
// if not tmp then
34730: LD_VAR 0 4
34734: NOT
34735: IFFALSE 34739
// continue ;
34737: GO 34696
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
34739: LD_EXP 76
34743: PUSH
34744: LD_VAR 0 2
34748: ARRAY
34749: PPUSH
34750: LD_INT 29
34752: PPUSH
34753: CALL_OW 325
34757: NOT
34758: PUSH
34759: LD_EXP 76
34763: PUSH
34764: LD_VAR 0 2
34768: ARRAY
34769: PPUSH
34770: LD_INT 28
34772: PPUSH
34773: CALL_OW 325
34777: NOT
34778: AND
34779: IFFALSE 34783
// continue ;
34781: GO 34696
// for j in tmp do
34783: LD_ADDR_VAR 0 3
34787: PUSH
34788: LD_VAR 0 4
34792: PUSH
34793: FOR_IN
34794: IFFALSE 34853
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
34796: LD_VAR 0 3
34800: PUSH
34801: LD_EXP 53
34805: PUSH
34806: LD_VAR 0 2
34810: ARRAY
34811: PUSH
34812: LD_INT 1
34814: ARRAY
34815: IN
34816: NOT
34817: PUSH
34818: LD_VAR 0 3
34822: PUSH
34823: LD_EXP 53
34827: PUSH
34828: LD_VAR 0 2
34832: ARRAY
34833: PUSH
34834: LD_INT 2
34836: ARRAY
34837: IN
34838: NOT
34839: AND
34840: IFFALSE 34851
// ComSpaceTimeShoot ( j ) ;
34842: LD_VAR 0 3
34846: PPUSH
34847: CALL 44933 0 1
34851: GO 34793
34853: POP
34854: POP
// end ;
34855: GO 34696
34857: POP
34858: POP
// end ;
34859: LD_VAR 0 1
34863: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
34864: LD_INT 0
34866: PPUSH
34867: PPUSH
34868: PPUSH
34869: PPUSH
34870: PPUSH
34871: PPUSH
34872: PPUSH
34873: PPUSH
34874: PPUSH
// if not mc_bases then
34875: LD_EXP 50
34879: NOT
34880: IFFALSE 34884
// exit ;
34882: GO 35506
// for i = 1 to mc_bases do
34884: LD_ADDR_VAR 0 2
34888: PUSH
34889: DOUBLE
34890: LD_INT 1
34892: DEC
34893: ST_TO_ADDR
34894: LD_EXP 50
34898: PUSH
34899: FOR_TO
34900: IFFALSE 35504
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
34902: LD_EXP 85
34906: PUSH
34907: LD_VAR 0 2
34911: ARRAY
34912: NOT
34913: PUSH
34914: LD_INT 38
34916: PPUSH
34917: LD_EXP 76
34921: PUSH
34922: LD_VAR 0 2
34926: ARRAY
34927: PPUSH
34928: CALL_OW 321
34932: PUSH
34933: LD_INT 2
34935: NONEQUAL
34936: OR
34937: IFFALSE 34941
// continue ;
34939: GO 34899
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
34941: LD_ADDR_VAR 0 8
34945: PUSH
34946: LD_EXP 50
34950: PUSH
34951: LD_VAR 0 2
34955: ARRAY
34956: PPUSH
34957: LD_INT 30
34959: PUSH
34960: LD_INT 34
34962: PUSH
34963: EMPTY
34964: LIST
34965: LIST
34966: PPUSH
34967: CALL_OW 72
34971: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
34972: LD_ADDR_VAR 0 9
34976: PUSH
34977: LD_EXP 50
34981: PUSH
34982: LD_VAR 0 2
34986: ARRAY
34987: PPUSH
34988: LD_INT 25
34990: PUSH
34991: LD_INT 4
34993: PUSH
34994: EMPTY
34995: LIST
34996: LIST
34997: PPUSH
34998: CALL_OW 72
35002: PPUSH
35003: LD_INT 0
35005: PPUSH
35006: CALL 83916 0 2
35010: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
35011: LD_VAR 0 9
35015: NOT
35016: PUSH
35017: LD_VAR 0 8
35021: NOT
35022: OR
35023: PUSH
35024: LD_EXP 50
35028: PUSH
35029: LD_VAR 0 2
35033: ARRAY
35034: PPUSH
35035: LD_INT 124
35037: PPUSH
35038: CALL 83916 0 2
35042: OR
35043: IFFALSE 35047
// continue ;
35045: GO 34899
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
35047: LD_EXP 86
35051: PUSH
35052: LD_VAR 0 2
35056: ARRAY
35057: PUSH
35058: LD_EXP 85
35062: PUSH
35063: LD_VAR 0 2
35067: ARRAY
35068: LESS
35069: PUSH
35070: LD_EXP 86
35074: PUSH
35075: LD_VAR 0 2
35079: ARRAY
35080: PUSH
35081: LD_VAR 0 8
35085: LESS
35086: AND
35087: IFFALSE 35502
// begin tmp := sci [ 1 ] ;
35089: LD_ADDR_VAR 0 7
35093: PUSH
35094: LD_VAR 0 9
35098: PUSH
35099: LD_INT 1
35101: ARRAY
35102: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
35103: LD_VAR 0 7
35107: PPUSH
35108: LD_INT 124
35110: PPUSH
35111: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
35115: LD_ADDR_VAR 0 3
35119: PUSH
35120: DOUBLE
35121: LD_EXP 85
35125: PUSH
35126: LD_VAR 0 2
35130: ARRAY
35131: INC
35132: ST_TO_ADDR
35133: LD_EXP 85
35137: PUSH
35138: LD_VAR 0 2
35142: ARRAY
35143: PUSH
35144: FOR_DOWNTO
35145: IFFALSE 35488
// begin if IsInUnit ( tmp ) then
35147: LD_VAR 0 7
35151: PPUSH
35152: CALL_OW 310
35156: IFFALSE 35167
// ComExitBuilding ( tmp ) ;
35158: LD_VAR 0 7
35162: PPUSH
35163: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
35167: LD_INT 35
35169: PPUSH
35170: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
35174: LD_VAR 0 7
35178: PPUSH
35179: CALL_OW 310
35183: NOT
35184: PUSH
35185: LD_VAR 0 7
35189: PPUSH
35190: CALL_OW 314
35194: NOT
35195: AND
35196: IFFALSE 35167
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
35198: LD_ADDR_VAR 0 6
35202: PUSH
35203: LD_VAR 0 7
35207: PPUSH
35208: CALL_OW 250
35212: PUSH
35213: LD_VAR 0 7
35217: PPUSH
35218: CALL_OW 251
35222: PUSH
35223: EMPTY
35224: LIST
35225: LIST
35226: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
35227: LD_INT 35
35229: PPUSH
35230: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
35234: LD_ADDR_VAR 0 4
35238: PUSH
35239: LD_EXP 85
35243: PUSH
35244: LD_VAR 0 2
35248: ARRAY
35249: PUSH
35250: LD_VAR 0 3
35254: ARRAY
35255: PUSH
35256: LD_INT 1
35258: ARRAY
35259: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
35260: LD_ADDR_VAR 0 5
35264: PUSH
35265: LD_EXP 85
35269: PUSH
35270: LD_VAR 0 2
35274: ARRAY
35275: PUSH
35276: LD_VAR 0 3
35280: ARRAY
35281: PUSH
35282: LD_INT 2
35284: ARRAY
35285: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
35286: LD_VAR 0 7
35290: PPUSH
35291: LD_INT 10
35293: PPUSH
35294: CALL 53499 0 2
35298: PUSH
35299: LD_INT 4
35301: ARRAY
35302: IFFALSE 35340
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
35304: LD_VAR 0 7
35308: PPUSH
35309: LD_VAR 0 6
35313: PUSH
35314: LD_INT 1
35316: ARRAY
35317: PPUSH
35318: LD_VAR 0 6
35322: PUSH
35323: LD_INT 2
35325: ARRAY
35326: PPUSH
35327: CALL_OW 111
// wait ( 0 0$10 ) ;
35331: LD_INT 350
35333: PPUSH
35334: CALL_OW 67
// end else
35338: GO 35366
// begin ComMoveXY ( tmp , x , y ) ;
35340: LD_VAR 0 7
35344: PPUSH
35345: LD_VAR 0 4
35349: PPUSH
35350: LD_VAR 0 5
35354: PPUSH
35355: CALL_OW 111
// wait ( 0 0$3 ) ;
35359: LD_INT 105
35361: PPUSH
35362: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
35366: LD_VAR 0 7
35370: PPUSH
35371: LD_VAR 0 4
35375: PPUSH
35376: LD_VAR 0 5
35380: PPUSH
35381: CALL_OW 307
35385: IFFALSE 35227
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
35387: LD_VAR 0 7
35391: PPUSH
35392: LD_VAR 0 4
35396: PPUSH
35397: LD_VAR 0 5
35401: PPUSH
35402: LD_VAR 0 8
35406: PUSH
35407: LD_VAR 0 3
35411: ARRAY
35412: PPUSH
35413: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
35417: LD_INT 35
35419: PPUSH
35420: CALL_OW 67
// until not HasTask ( tmp ) ;
35424: LD_VAR 0 7
35428: PPUSH
35429: CALL_OW 314
35433: NOT
35434: IFFALSE 35417
// mc_teleport_exit_set := Add ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
35436: LD_ADDR_EXP 86
35440: PUSH
35441: LD_EXP 86
35445: PPUSH
35446: LD_VAR 0 2
35450: PUSH
35451: LD_EXP 86
35455: PUSH
35456: LD_VAR 0 2
35460: ARRAY
35461: PUSH
35462: LD_INT 1
35464: PLUS
35465: PUSH
35466: EMPTY
35467: LIST
35468: LIST
35469: PPUSH
35470: LD_VAR 0 8
35474: PUSH
35475: LD_VAR 0 3
35479: ARRAY
35480: PPUSH
35481: CALL 51308 0 3
35485: ST_TO_ADDR
// end ;
35486: GO 35144
35488: POP
35489: POP
// MC_Reset ( i , 124 ) ;
35490: LD_VAR 0 2
35494: PPUSH
35495: LD_INT 124
35497: PPUSH
35498: CALL 19681 0 2
// end ; end ;
35502: GO 34899
35504: POP
35505: POP
// end ;
35506: LD_VAR 0 1
35510: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
35511: LD_INT 0
35513: PPUSH
35514: PPUSH
35515: PPUSH
// if not mc_bases then
35516: LD_EXP 50
35520: NOT
35521: IFFALSE 35525
// exit ;
35523: GO 36131
// for i = 1 to mc_bases do
35525: LD_ADDR_VAR 0 2
35529: PUSH
35530: DOUBLE
35531: LD_INT 1
35533: DEC
35534: ST_TO_ADDR
35535: LD_EXP 50
35539: PUSH
35540: FOR_TO
35541: IFFALSE 36129
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
35543: LD_ADDR_VAR 0 3
35547: PUSH
35548: LD_EXP 50
35552: PUSH
35553: LD_VAR 0 2
35557: ARRAY
35558: PPUSH
35559: LD_INT 25
35561: PUSH
35562: LD_INT 4
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: PPUSH
35569: CALL_OW 72
35573: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
35574: LD_VAR 0 3
35578: NOT
35579: PUSH
35580: LD_EXP 87
35584: PUSH
35585: LD_VAR 0 2
35589: ARRAY
35590: NOT
35591: OR
35592: PUSH
35593: LD_EXP 50
35597: PUSH
35598: LD_VAR 0 2
35602: ARRAY
35603: PPUSH
35604: LD_INT 2
35606: PUSH
35607: LD_INT 30
35609: PUSH
35610: LD_INT 0
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: PUSH
35617: LD_INT 30
35619: PUSH
35620: LD_INT 1
35622: PUSH
35623: EMPTY
35624: LIST
35625: LIST
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: LIST
35631: PPUSH
35632: CALL_OW 72
35636: NOT
35637: OR
35638: IFFALSE 35688
// begin if mc_deposits_finder [ i ] then
35640: LD_EXP 88
35644: PUSH
35645: LD_VAR 0 2
35649: ARRAY
35650: IFFALSE 35686
// begin MC_Reset ( i , 125 ) ;
35652: LD_VAR 0 2
35656: PPUSH
35657: LD_INT 125
35659: PPUSH
35660: CALL 19681 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
35664: LD_ADDR_EXP 88
35668: PUSH
35669: LD_EXP 88
35673: PPUSH
35674: LD_VAR 0 2
35678: PPUSH
35679: EMPTY
35680: PPUSH
35681: CALL_OW 1
35685: ST_TO_ADDR
// end ; continue ;
35686: GO 35540
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
35688: LD_EXP 87
35692: PUSH
35693: LD_VAR 0 2
35697: ARRAY
35698: PUSH
35699: LD_INT 1
35701: ARRAY
35702: PUSH
35703: LD_INT 3
35705: ARRAY
35706: PUSH
35707: LD_INT 1
35709: EQUAL
35710: PUSH
35711: LD_INT 20
35713: PPUSH
35714: LD_EXP 76
35718: PUSH
35719: LD_VAR 0 2
35723: ARRAY
35724: PPUSH
35725: CALL_OW 321
35729: PUSH
35730: LD_INT 2
35732: NONEQUAL
35733: AND
35734: IFFALSE 35784
// begin if mc_deposits_finder [ i ] then
35736: LD_EXP 88
35740: PUSH
35741: LD_VAR 0 2
35745: ARRAY
35746: IFFALSE 35782
// begin MC_Reset ( i , 125 ) ;
35748: LD_VAR 0 2
35752: PPUSH
35753: LD_INT 125
35755: PPUSH
35756: CALL 19681 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
35760: LD_ADDR_EXP 88
35764: PUSH
35765: LD_EXP 88
35769: PPUSH
35770: LD_VAR 0 2
35774: PPUSH
35775: EMPTY
35776: PPUSH
35777: CALL_OW 1
35781: ST_TO_ADDR
// end ; continue ;
35782: GO 35540
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
35784: LD_EXP 87
35788: PUSH
35789: LD_VAR 0 2
35793: ARRAY
35794: PUSH
35795: LD_INT 1
35797: ARRAY
35798: PUSH
35799: LD_INT 1
35801: ARRAY
35802: PPUSH
35803: LD_EXP 87
35807: PUSH
35808: LD_VAR 0 2
35812: ARRAY
35813: PUSH
35814: LD_INT 1
35816: ARRAY
35817: PUSH
35818: LD_INT 2
35820: ARRAY
35821: PPUSH
35822: LD_EXP 76
35826: PUSH
35827: LD_VAR 0 2
35831: ARRAY
35832: PPUSH
35833: CALL_OW 440
35837: IFFALSE 35880
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
35839: LD_ADDR_EXP 87
35843: PUSH
35844: LD_EXP 87
35848: PPUSH
35849: LD_VAR 0 2
35853: PPUSH
35854: LD_EXP 87
35858: PUSH
35859: LD_VAR 0 2
35863: ARRAY
35864: PPUSH
35865: LD_INT 1
35867: PPUSH
35868: CALL_OW 3
35872: PPUSH
35873: CALL_OW 1
35877: ST_TO_ADDR
35878: GO 36127
// begin if not mc_deposits_finder [ i ] then
35880: LD_EXP 88
35884: PUSH
35885: LD_VAR 0 2
35889: ARRAY
35890: NOT
35891: IFFALSE 35943
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
35893: LD_ADDR_EXP 88
35897: PUSH
35898: LD_EXP 88
35902: PPUSH
35903: LD_VAR 0 2
35907: PPUSH
35908: LD_VAR 0 3
35912: PUSH
35913: LD_INT 1
35915: ARRAY
35916: PUSH
35917: EMPTY
35918: LIST
35919: PPUSH
35920: CALL_OW 1
35924: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
35925: LD_VAR 0 3
35929: PUSH
35930: LD_INT 1
35932: ARRAY
35933: PPUSH
35934: LD_INT 125
35936: PPUSH
35937: CALL_OW 109
// end else
35941: GO 36127
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
35943: LD_EXP 88
35947: PUSH
35948: LD_VAR 0 2
35952: ARRAY
35953: PUSH
35954: LD_INT 1
35956: ARRAY
35957: PPUSH
35958: CALL_OW 310
35962: IFFALSE 35985
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
35964: LD_EXP 88
35968: PUSH
35969: LD_VAR 0 2
35973: ARRAY
35974: PUSH
35975: LD_INT 1
35977: ARRAY
35978: PPUSH
35979: CALL_OW 122
35983: GO 36127
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
35985: LD_EXP 88
35989: PUSH
35990: LD_VAR 0 2
35994: ARRAY
35995: PUSH
35996: LD_INT 1
35998: ARRAY
35999: PPUSH
36000: CALL_OW 314
36004: NOT
36005: PUSH
36006: LD_EXP 88
36010: PUSH
36011: LD_VAR 0 2
36015: ARRAY
36016: PUSH
36017: LD_INT 1
36019: ARRAY
36020: PPUSH
36021: LD_EXP 87
36025: PUSH
36026: LD_VAR 0 2
36030: ARRAY
36031: PUSH
36032: LD_INT 1
36034: ARRAY
36035: PUSH
36036: LD_INT 1
36038: ARRAY
36039: PPUSH
36040: LD_EXP 87
36044: PUSH
36045: LD_VAR 0 2
36049: ARRAY
36050: PUSH
36051: LD_INT 1
36053: ARRAY
36054: PUSH
36055: LD_INT 2
36057: ARRAY
36058: PPUSH
36059: CALL_OW 297
36063: PUSH
36064: LD_INT 6
36066: GREATER
36067: AND
36068: IFFALSE 36127
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
36070: LD_EXP 88
36074: PUSH
36075: LD_VAR 0 2
36079: ARRAY
36080: PUSH
36081: LD_INT 1
36083: ARRAY
36084: PPUSH
36085: LD_EXP 87
36089: PUSH
36090: LD_VAR 0 2
36094: ARRAY
36095: PUSH
36096: LD_INT 1
36098: ARRAY
36099: PUSH
36100: LD_INT 1
36102: ARRAY
36103: PPUSH
36104: LD_EXP 87
36108: PUSH
36109: LD_VAR 0 2
36113: ARRAY
36114: PUSH
36115: LD_INT 1
36117: ARRAY
36118: PUSH
36119: LD_INT 2
36121: ARRAY
36122: PPUSH
36123: CALL_OW 111
// end ; end ; end ;
36127: GO 35540
36129: POP
36130: POP
// end ;
36131: LD_VAR 0 1
36135: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
36136: LD_INT 0
36138: PPUSH
36139: PPUSH
36140: PPUSH
36141: PPUSH
36142: PPUSH
36143: PPUSH
36144: PPUSH
36145: PPUSH
36146: PPUSH
36147: PPUSH
36148: PPUSH
// if not mc_bases then
36149: LD_EXP 50
36153: NOT
36154: IFFALSE 36158
// exit ;
36156: GO 36882
// for i = 1 to mc_bases do
36158: LD_ADDR_VAR 0 2
36162: PUSH
36163: DOUBLE
36164: LD_INT 1
36166: DEC
36167: ST_TO_ADDR
36168: LD_EXP 50
36172: PUSH
36173: FOR_TO
36174: IFFALSE 36880
// begin if not mc_bases [ i ] then
36176: LD_EXP 50
36180: PUSH
36181: LD_VAR 0 2
36185: ARRAY
36186: NOT
36187: IFFALSE 36191
// continue ;
36189: GO 36173
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
36191: LD_ADDR_VAR 0 7
36195: PUSH
36196: LD_EXP 50
36200: PUSH
36201: LD_VAR 0 2
36205: ARRAY
36206: PUSH
36207: LD_INT 1
36209: ARRAY
36210: PPUSH
36211: CALL_OW 248
36215: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
36216: LD_VAR 0 7
36220: PUSH
36221: LD_INT 3
36223: EQUAL
36224: PUSH
36225: LD_EXP 69
36229: PUSH
36230: LD_VAR 0 2
36234: ARRAY
36235: PUSH
36236: LD_EXP 72
36240: PUSH
36241: LD_VAR 0 2
36245: ARRAY
36246: UNION
36247: PPUSH
36248: LD_INT 33
36250: PUSH
36251: LD_INT 2
36253: PUSH
36254: EMPTY
36255: LIST
36256: LIST
36257: PPUSH
36258: CALL_OW 72
36262: NOT
36263: OR
36264: IFFALSE 36268
// continue ;
36266: GO 36173
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
36268: LD_ADDR_VAR 0 9
36272: PUSH
36273: LD_EXP 50
36277: PUSH
36278: LD_VAR 0 2
36282: ARRAY
36283: PPUSH
36284: LD_INT 30
36286: PUSH
36287: LD_INT 36
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PPUSH
36294: CALL_OW 72
36298: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
36299: LD_ADDR_VAR 0 10
36303: PUSH
36304: LD_EXP 69
36308: PUSH
36309: LD_VAR 0 2
36313: ARRAY
36314: PPUSH
36315: LD_INT 34
36317: PUSH
36318: LD_INT 31
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PPUSH
36325: CALL_OW 72
36329: ST_TO_ADDR
// if not cts and not mcts then
36330: LD_VAR 0 9
36334: NOT
36335: PUSH
36336: LD_VAR 0 10
36340: NOT
36341: AND
36342: IFFALSE 36346
// continue ;
36344: GO 36173
// x := cts ;
36346: LD_ADDR_VAR 0 11
36350: PUSH
36351: LD_VAR 0 9
36355: ST_TO_ADDR
// if not x then
36356: LD_VAR 0 11
36360: NOT
36361: IFFALSE 36373
// x := mcts ;
36363: LD_ADDR_VAR 0 11
36367: PUSH
36368: LD_VAR 0 10
36372: ST_TO_ADDR
// if mc_remote_driver [ i ] then
36373: LD_EXP 90
36377: PUSH
36378: LD_VAR 0 2
36382: ARRAY
36383: IFFALSE 36652
// for j in mc_remote_driver [ i ] do
36385: LD_ADDR_VAR 0 3
36389: PUSH
36390: LD_EXP 90
36394: PUSH
36395: LD_VAR 0 2
36399: ARRAY
36400: PUSH
36401: FOR_IN
36402: IFFALSE 36650
// begin if GetClass ( j ) <> 3 then
36404: LD_VAR 0 3
36408: PPUSH
36409: CALL_OW 257
36413: PUSH
36414: LD_INT 3
36416: NONEQUAL
36417: IFFALSE 36470
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
36419: LD_ADDR_EXP 90
36423: PUSH
36424: LD_EXP 90
36428: PPUSH
36429: LD_VAR 0 2
36433: PPUSH
36434: LD_EXP 90
36438: PUSH
36439: LD_VAR 0 2
36443: ARRAY
36444: PUSH
36445: LD_VAR 0 3
36449: DIFF
36450: PPUSH
36451: CALL_OW 1
36455: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36456: LD_VAR 0 3
36460: PPUSH
36461: LD_INT 0
36463: PPUSH
36464: CALL_OW 109
// continue ;
36468: GO 36401
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
36470: LD_VAR 0 3
36474: PPUSH
36475: CALL_OW 310
36479: NOT
36480: PUSH
36481: LD_VAR 0 3
36485: PPUSH
36486: CALL_OW 310
36490: PPUSH
36491: CALL_OW 266
36495: PUSH
36496: LD_INT 36
36498: NONEQUAL
36499: PUSH
36500: LD_VAR 0 3
36504: PPUSH
36505: CALL 84004 0 1
36509: NOT
36510: AND
36511: OR
36512: IFFALSE 36648
// begin if IsInUnit ( j ) then
36514: LD_VAR 0 3
36518: PPUSH
36519: CALL_OW 310
36523: IFFALSE 36534
// ComExitBuilding ( j ) ;
36525: LD_VAR 0 3
36529: PPUSH
36530: CALL_OW 122
// ct := 0 ;
36534: LD_ADDR_VAR 0 8
36538: PUSH
36539: LD_INT 0
36541: ST_TO_ADDR
// for k in x do
36542: LD_ADDR_VAR 0 4
36546: PUSH
36547: LD_VAR 0 11
36551: PUSH
36552: FOR_IN
36553: IFFALSE 36626
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
36555: LD_VAR 0 4
36559: PPUSH
36560: CALL_OW 264
36564: PUSH
36565: LD_INT 31
36567: EQUAL
36568: PUSH
36569: LD_VAR 0 4
36573: PPUSH
36574: CALL_OW 311
36578: NOT
36579: AND
36580: PUSH
36581: LD_VAR 0 4
36585: PPUSH
36586: CALL_OW 266
36590: PUSH
36591: LD_INT 36
36593: EQUAL
36594: PUSH
36595: LD_VAR 0 4
36599: PPUSH
36600: CALL_OW 313
36604: PUSH
36605: LD_INT 3
36607: LESS
36608: AND
36609: OR
36610: IFFALSE 36624
// begin ct := k ;
36612: LD_ADDR_VAR 0 8
36616: PUSH
36617: LD_VAR 0 4
36621: ST_TO_ADDR
// break ;
36622: GO 36626
// end ;
36624: GO 36552
36626: POP
36627: POP
// if ct then
36628: LD_VAR 0 8
36632: IFFALSE 36648
// ComEnterUnit ( j , ct ) ;
36634: LD_VAR 0 3
36638: PPUSH
36639: LD_VAR 0 8
36643: PPUSH
36644: CALL_OW 120
// end ; end ;
36648: GO 36401
36650: POP
36651: POP
// places := 0 ;
36652: LD_ADDR_VAR 0 5
36656: PUSH
36657: LD_INT 0
36659: ST_TO_ADDR
// for j = 1 to x do
36660: LD_ADDR_VAR 0 3
36664: PUSH
36665: DOUBLE
36666: LD_INT 1
36668: DEC
36669: ST_TO_ADDR
36670: LD_VAR 0 11
36674: PUSH
36675: FOR_TO
36676: IFFALSE 36731
// if GetWeapon ( x [ j ] ) = ar_control_tower then
36678: LD_VAR 0 11
36682: PUSH
36683: LD_VAR 0 3
36687: ARRAY
36688: PPUSH
36689: CALL_OW 264
36693: PUSH
36694: LD_INT 31
36696: EQUAL
36697: IFFALSE 36715
// places := places + 1 else
36699: LD_ADDR_VAR 0 5
36703: PUSH
36704: LD_VAR 0 5
36708: PUSH
36709: LD_INT 1
36711: PLUS
36712: ST_TO_ADDR
36713: GO 36729
// places := places + 3 ;
36715: LD_ADDR_VAR 0 5
36719: PUSH
36720: LD_VAR 0 5
36724: PUSH
36725: LD_INT 3
36727: PLUS
36728: ST_TO_ADDR
36729: GO 36675
36731: POP
36732: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
36733: LD_ADDR_VAR 0 6
36737: PUSH
36738: LD_EXP 50
36742: PUSH
36743: LD_VAR 0 2
36747: ARRAY
36748: PPUSH
36749: LD_INT 25
36751: PUSH
36752: LD_INT 3
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: PPUSH
36759: CALL_OW 72
36763: PUSH
36764: LD_EXP 90
36768: PUSH
36769: LD_VAR 0 2
36773: ARRAY
36774: DIFF
36775: PPUSH
36776: LD_INT 3
36778: PPUSH
36779: CALL 84904 0 2
36783: ST_TO_ADDR
// if not tmp then
36784: LD_VAR 0 6
36788: NOT
36789: IFFALSE 36793
// continue ;
36791: GO 36173
// places := places - mc_remote_driver [ i ] ;
36793: LD_ADDR_VAR 0 5
36797: PUSH
36798: LD_VAR 0 5
36802: PUSH
36803: LD_EXP 90
36807: PUSH
36808: LD_VAR 0 2
36812: ARRAY
36813: MINUS
36814: ST_TO_ADDR
// if places then
36815: LD_VAR 0 5
36819: IFFALSE 36878
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
36821: LD_ADDR_EXP 90
36825: PUSH
36826: LD_EXP 90
36830: PPUSH
36831: LD_VAR 0 2
36835: PPUSH
36836: LD_EXP 90
36840: PUSH
36841: LD_VAR 0 2
36845: ARRAY
36846: PUSH
36847: LD_VAR 0 6
36851: PUSH
36852: LD_INT 1
36854: ARRAY
36855: UNION
36856: PPUSH
36857: CALL_OW 1
36861: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
36862: LD_VAR 0 6
36866: PUSH
36867: LD_INT 1
36869: ARRAY
36870: PPUSH
36871: LD_INT 126
36873: PPUSH
36874: CALL_OW 109
// end ; end ;
36878: GO 36173
36880: POP
36881: POP
// end ;
36882: LD_VAR 0 1
36886: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
36887: LD_INT 0
36889: PPUSH
36890: PPUSH
36891: PPUSH
36892: PPUSH
36893: PPUSH
36894: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
36895: LD_VAR 0 1
36899: NOT
36900: PUSH
36901: LD_VAR 0 2
36905: NOT
36906: OR
36907: PUSH
36908: LD_VAR 0 3
36912: NOT
36913: OR
36914: PUSH
36915: LD_VAR 0 4
36919: PUSH
36920: LD_INT 1
36922: PUSH
36923: LD_INT 2
36925: PUSH
36926: LD_INT 3
36928: PUSH
36929: LD_INT 4
36931: PUSH
36932: LD_INT 5
36934: PUSH
36935: LD_INT 8
36937: PUSH
36938: LD_INT 9
36940: PUSH
36941: LD_INT 15
36943: PUSH
36944: LD_INT 16
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: LIST
36951: LIST
36952: LIST
36953: LIST
36954: LIST
36955: LIST
36956: LIST
36957: IN
36958: NOT
36959: OR
36960: IFFALSE 36964
// exit ;
36962: GO 37864
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
36964: LD_ADDR_VAR 0 2
36968: PUSH
36969: LD_VAR 0 2
36973: PPUSH
36974: LD_INT 21
36976: PUSH
36977: LD_INT 3
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: LD_INT 24
36986: PUSH
36987: LD_INT 250
36989: PUSH
36990: EMPTY
36991: LIST
36992: LIST
36993: PUSH
36994: EMPTY
36995: LIST
36996: LIST
36997: PPUSH
36998: CALL_OW 72
37002: ST_TO_ADDR
// case class of 1 , 15 :
37003: LD_VAR 0 4
37007: PUSH
37008: LD_INT 1
37010: DOUBLE
37011: EQUAL
37012: IFTRUE 37022
37014: LD_INT 15
37016: DOUBLE
37017: EQUAL
37018: IFTRUE 37022
37020: GO 37107
37022: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
37023: LD_ADDR_VAR 0 8
37027: PUSH
37028: LD_VAR 0 2
37032: PPUSH
37033: LD_INT 2
37035: PUSH
37036: LD_INT 30
37038: PUSH
37039: LD_INT 32
37041: PUSH
37042: EMPTY
37043: LIST
37044: LIST
37045: PUSH
37046: LD_INT 30
37048: PUSH
37049: LD_INT 31
37051: PUSH
37052: EMPTY
37053: LIST
37054: LIST
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: LIST
37060: PPUSH
37061: CALL_OW 72
37065: PUSH
37066: LD_VAR 0 2
37070: PPUSH
37071: LD_INT 2
37073: PUSH
37074: LD_INT 30
37076: PUSH
37077: LD_INT 4
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: PUSH
37084: LD_INT 30
37086: PUSH
37087: LD_INT 5
37089: PUSH
37090: EMPTY
37091: LIST
37092: LIST
37093: PUSH
37094: EMPTY
37095: LIST
37096: LIST
37097: LIST
37098: PPUSH
37099: CALL_OW 72
37103: ADD
37104: ST_TO_ADDR
37105: GO 37353
37107: LD_INT 2
37109: DOUBLE
37110: EQUAL
37111: IFTRUE 37121
37113: LD_INT 16
37115: DOUBLE
37116: EQUAL
37117: IFTRUE 37121
37119: GO 37167
37121: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
37122: LD_ADDR_VAR 0 8
37126: PUSH
37127: LD_VAR 0 2
37131: PPUSH
37132: LD_INT 2
37134: PUSH
37135: LD_INT 30
37137: PUSH
37138: LD_INT 0
37140: PUSH
37141: EMPTY
37142: LIST
37143: LIST
37144: PUSH
37145: LD_INT 30
37147: PUSH
37148: LD_INT 1
37150: PUSH
37151: EMPTY
37152: LIST
37153: LIST
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: LIST
37159: PPUSH
37160: CALL_OW 72
37164: ST_TO_ADDR
37165: GO 37353
37167: LD_INT 3
37169: DOUBLE
37170: EQUAL
37171: IFTRUE 37175
37173: GO 37221
37175: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
37176: LD_ADDR_VAR 0 8
37180: PUSH
37181: LD_VAR 0 2
37185: PPUSH
37186: LD_INT 2
37188: PUSH
37189: LD_INT 30
37191: PUSH
37192: LD_INT 2
37194: PUSH
37195: EMPTY
37196: LIST
37197: LIST
37198: PUSH
37199: LD_INT 30
37201: PUSH
37202: LD_INT 3
37204: PUSH
37205: EMPTY
37206: LIST
37207: LIST
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: LIST
37213: PPUSH
37214: CALL_OW 72
37218: ST_TO_ADDR
37219: GO 37353
37221: LD_INT 4
37223: DOUBLE
37224: EQUAL
37225: IFTRUE 37229
37227: GO 37286
37229: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
37230: LD_ADDR_VAR 0 8
37234: PUSH
37235: LD_VAR 0 2
37239: PPUSH
37240: LD_INT 2
37242: PUSH
37243: LD_INT 30
37245: PUSH
37246: LD_INT 6
37248: PUSH
37249: EMPTY
37250: LIST
37251: LIST
37252: PUSH
37253: LD_INT 30
37255: PUSH
37256: LD_INT 7
37258: PUSH
37259: EMPTY
37260: LIST
37261: LIST
37262: PUSH
37263: LD_INT 30
37265: PUSH
37266: LD_INT 8
37268: PUSH
37269: EMPTY
37270: LIST
37271: LIST
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: LIST
37277: LIST
37278: PPUSH
37279: CALL_OW 72
37283: ST_TO_ADDR
37284: GO 37353
37286: LD_INT 5
37288: DOUBLE
37289: EQUAL
37290: IFTRUE 37306
37292: LD_INT 8
37294: DOUBLE
37295: EQUAL
37296: IFTRUE 37306
37298: LD_INT 9
37300: DOUBLE
37301: EQUAL
37302: IFTRUE 37306
37304: GO 37352
37306: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
37307: LD_ADDR_VAR 0 8
37311: PUSH
37312: LD_VAR 0 2
37316: PPUSH
37317: LD_INT 2
37319: PUSH
37320: LD_INT 30
37322: PUSH
37323: LD_INT 4
37325: PUSH
37326: EMPTY
37327: LIST
37328: LIST
37329: PUSH
37330: LD_INT 30
37332: PUSH
37333: LD_INT 5
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: LIST
37344: PPUSH
37345: CALL_OW 72
37349: ST_TO_ADDR
37350: GO 37353
37352: POP
// if not tmp then
37353: LD_VAR 0 8
37357: NOT
37358: IFFALSE 37362
// exit ;
37360: GO 37864
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
37362: LD_VAR 0 4
37366: PUSH
37367: LD_INT 1
37369: PUSH
37370: LD_INT 15
37372: PUSH
37373: EMPTY
37374: LIST
37375: LIST
37376: IN
37377: PUSH
37378: LD_EXP 59
37382: PUSH
37383: LD_VAR 0 1
37387: ARRAY
37388: AND
37389: IFFALSE 37545
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
37391: LD_ADDR_VAR 0 9
37395: PUSH
37396: LD_EXP 59
37400: PUSH
37401: LD_VAR 0 1
37405: ARRAY
37406: PUSH
37407: LD_INT 1
37409: ARRAY
37410: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
37411: LD_VAR 0 9
37415: PUSH
37416: LD_EXP 60
37420: PUSH
37421: LD_VAR 0 1
37425: ARRAY
37426: IN
37427: NOT
37428: IFFALSE 37543
// begin mc_busy_turret_list := Add ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
37430: LD_ADDR_EXP 60
37434: PUSH
37435: LD_EXP 60
37439: PPUSH
37440: LD_VAR 0 1
37444: PUSH
37445: LD_EXP 60
37449: PUSH
37450: LD_VAR 0 1
37454: ARRAY
37455: PUSH
37456: LD_INT 1
37458: PLUS
37459: PUSH
37460: EMPTY
37461: LIST
37462: LIST
37463: PPUSH
37464: LD_VAR 0 9
37468: PPUSH
37469: CALL 51308 0 3
37473: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
37474: LD_ADDR_EXP 59
37478: PUSH
37479: LD_EXP 59
37483: PPUSH
37484: LD_VAR 0 1
37488: PPUSH
37489: LD_EXP 59
37493: PUSH
37494: LD_VAR 0 1
37498: ARRAY
37499: PUSH
37500: LD_VAR 0 9
37504: DIFF
37505: PPUSH
37506: CALL_OW 1
37510: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
37511: LD_VAR 0 3
37515: PPUSH
37516: LD_EXP 60
37520: PUSH
37521: LD_VAR 0 1
37525: ARRAY
37526: PUSH
37527: LD_EXP 60
37531: PUSH
37532: LD_VAR 0 1
37536: ARRAY
37537: ARRAY
37538: PPUSH
37539: CALL_OW 120
// end ; exit ;
37543: GO 37864
// end ; if tmp > 1 then
37545: LD_VAR 0 8
37549: PUSH
37550: LD_INT 1
37552: GREATER
37553: IFFALSE 37657
// for i = 2 to tmp do
37555: LD_ADDR_VAR 0 6
37559: PUSH
37560: DOUBLE
37561: LD_INT 2
37563: DEC
37564: ST_TO_ADDR
37565: LD_VAR 0 8
37569: PUSH
37570: FOR_TO
37571: IFFALSE 37655
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
37573: LD_VAR 0 8
37577: PUSH
37578: LD_VAR 0 6
37582: ARRAY
37583: PPUSH
37584: CALL_OW 461
37588: PUSH
37589: LD_INT 6
37591: EQUAL
37592: IFFALSE 37653
// begin x := tmp [ i ] ;
37594: LD_ADDR_VAR 0 9
37598: PUSH
37599: LD_VAR 0 8
37603: PUSH
37604: LD_VAR 0 6
37608: ARRAY
37609: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
37610: LD_ADDR_VAR 0 8
37614: PUSH
37615: LD_VAR 0 8
37619: PPUSH
37620: LD_VAR 0 6
37624: PPUSH
37625: CALL_OW 3
37629: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
37630: LD_ADDR_VAR 0 8
37634: PUSH
37635: LD_VAR 0 8
37639: PPUSH
37640: LD_INT 1
37642: PPUSH
37643: LD_VAR 0 9
37647: PPUSH
37648: CALL_OW 2
37652: ST_TO_ADDR
// end ;
37653: GO 37570
37655: POP
37656: POP
// for i in tmp do
37657: LD_ADDR_VAR 0 6
37661: PUSH
37662: LD_VAR 0 8
37666: PUSH
37667: FOR_IN
37668: IFFALSE 37737
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
37670: LD_VAR 0 6
37674: PPUSH
37675: CALL_OW 313
37679: PUSH
37680: LD_INT 6
37682: LESS
37683: PUSH
37684: LD_VAR 0 6
37688: PPUSH
37689: CALL_OW 266
37693: PUSH
37694: LD_INT 31
37696: PUSH
37697: LD_INT 32
37699: PUSH
37700: EMPTY
37701: LIST
37702: LIST
37703: IN
37704: NOT
37705: AND
37706: PUSH
37707: LD_VAR 0 6
37711: PPUSH
37712: CALL_OW 313
37716: PUSH
37717: LD_INT 0
37719: EQUAL
37720: OR
37721: IFFALSE 37735
// begin j := i ;
37723: LD_ADDR_VAR 0 7
37727: PUSH
37728: LD_VAR 0 6
37732: ST_TO_ADDR
// break ;
37733: GO 37737
// end ; end ;
37735: GO 37667
37737: POP
37738: POP
// if j then
37739: LD_VAR 0 7
37743: IFFALSE 37761
// ComEnterUnit ( unit , j ) else
37745: LD_VAR 0 3
37749: PPUSH
37750: LD_VAR 0 7
37754: PPUSH
37755: CALL_OW 120
37759: GO 37864
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37761: LD_ADDR_VAR 0 10
37765: PUSH
37766: LD_VAR 0 2
37770: PPUSH
37771: LD_INT 2
37773: PUSH
37774: LD_INT 30
37776: PUSH
37777: LD_INT 0
37779: PUSH
37780: EMPTY
37781: LIST
37782: LIST
37783: PUSH
37784: LD_INT 30
37786: PUSH
37787: LD_INT 1
37789: PUSH
37790: EMPTY
37791: LIST
37792: LIST
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: LIST
37798: PPUSH
37799: CALL_OW 72
37803: ST_TO_ADDR
// if depot then
37804: LD_VAR 0 10
37808: IFFALSE 37864
// begin depot := NearestUnitToUnit ( depot , unit ) ;
37810: LD_ADDR_VAR 0 10
37814: PUSH
37815: LD_VAR 0 10
37819: PPUSH
37820: LD_VAR 0 3
37824: PPUSH
37825: CALL_OW 74
37829: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
37830: LD_VAR 0 3
37834: PPUSH
37835: LD_VAR 0 10
37839: PPUSH
37840: CALL_OW 296
37844: PUSH
37845: LD_INT 10
37847: GREATER
37848: IFFALSE 37864
// ComStandNearbyBuilding ( unit , depot ) ;
37850: LD_VAR 0 3
37854: PPUSH
37855: LD_VAR 0 10
37859: PPUSH
37860: CALL 45550 0 2
// end ; end ; end ;
37864: LD_VAR 0 5
37868: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
37869: LD_INT 0
37871: PPUSH
37872: PPUSH
37873: PPUSH
37874: PPUSH
// if not mc_bases then
37875: LD_EXP 50
37879: NOT
37880: IFFALSE 37884
// exit ;
37882: GO 38123
// for i = 1 to mc_bases do
37884: LD_ADDR_VAR 0 2
37888: PUSH
37889: DOUBLE
37890: LD_INT 1
37892: DEC
37893: ST_TO_ADDR
37894: LD_EXP 50
37898: PUSH
37899: FOR_TO
37900: IFFALSE 38121
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
37902: LD_ADDR_VAR 0 4
37906: PUSH
37907: LD_EXP 50
37911: PUSH
37912: LD_VAR 0 2
37916: ARRAY
37917: PPUSH
37918: LD_INT 21
37920: PUSH
37921: LD_INT 1
37923: PUSH
37924: EMPTY
37925: LIST
37926: LIST
37927: PPUSH
37928: CALL_OW 72
37932: PUSH
37933: LD_EXP 79
37937: PUSH
37938: LD_VAR 0 2
37942: ARRAY
37943: UNION
37944: ST_TO_ADDR
// if not tmp then
37945: LD_VAR 0 4
37949: NOT
37950: IFFALSE 37954
// continue ;
37952: GO 37899
// for j in tmp do
37954: LD_ADDR_VAR 0 3
37958: PUSH
37959: LD_VAR 0 4
37963: PUSH
37964: FOR_IN
37965: IFFALSE 38117
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
37967: LD_VAR 0 3
37971: PPUSH
37972: CALL_OW 110
37976: NOT
37977: PUSH
37978: LD_VAR 0 3
37982: PPUSH
37983: CALL_OW 314
37987: NOT
37988: AND
37989: PUSH
37990: LD_VAR 0 3
37994: PPUSH
37995: CALL_OW 311
37999: NOT
38000: AND
38001: PUSH
38002: LD_VAR 0 3
38006: PPUSH
38007: CALL_OW 310
38011: NOT
38012: AND
38013: PUSH
38014: LD_VAR 0 3
38018: PUSH
38019: LD_EXP 53
38023: PUSH
38024: LD_VAR 0 2
38028: ARRAY
38029: PUSH
38030: LD_INT 1
38032: ARRAY
38033: IN
38034: NOT
38035: AND
38036: PUSH
38037: LD_VAR 0 3
38041: PUSH
38042: LD_EXP 53
38046: PUSH
38047: LD_VAR 0 2
38051: ARRAY
38052: PUSH
38053: LD_INT 2
38055: ARRAY
38056: IN
38057: NOT
38058: AND
38059: PUSH
38060: LD_VAR 0 3
38064: PUSH
38065: LD_EXP 62
38069: PUSH
38070: LD_VAR 0 2
38074: ARRAY
38075: IN
38076: NOT
38077: AND
38078: IFFALSE 38115
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
38080: LD_VAR 0 2
38084: PPUSH
38085: LD_EXP 50
38089: PUSH
38090: LD_VAR 0 2
38094: ARRAY
38095: PPUSH
38096: LD_VAR 0 3
38100: PPUSH
38101: LD_VAR 0 3
38105: PPUSH
38106: CALL_OW 257
38110: PPUSH
38111: CALL 36887 0 4
// end ;
38115: GO 37964
38117: POP
38118: POP
// end ;
38119: GO 37899
38121: POP
38122: POP
// end ;
38123: LD_VAR 0 1
38127: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
38128: LD_INT 0
38130: PPUSH
38131: PPUSH
38132: PPUSH
38133: PPUSH
38134: PPUSH
38135: PPUSH
// if not mc_bases [ base ] then
38136: LD_EXP 50
38140: PUSH
38141: LD_VAR 0 1
38145: ARRAY
38146: NOT
38147: IFFALSE 38151
// exit ;
38149: GO 38333
// tmp := [ ] ;
38151: LD_ADDR_VAR 0 6
38155: PUSH
38156: EMPTY
38157: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
38158: LD_ADDR_VAR 0 7
38162: PUSH
38163: LD_VAR 0 3
38167: PPUSH
38168: LD_INT 0
38170: PPUSH
38171: CALL_OW 517
38175: ST_TO_ADDR
// if not list then
38176: LD_VAR 0 7
38180: NOT
38181: IFFALSE 38185
// exit ;
38183: GO 38333
// for i = 1 to amount do
38185: LD_ADDR_VAR 0 5
38189: PUSH
38190: DOUBLE
38191: LD_INT 1
38193: DEC
38194: ST_TO_ADDR
38195: LD_VAR 0 2
38199: PUSH
38200: FOR_TO
38201: IFFALSE 38281
// begin x := rand ( 1 , list [ 1 ] ) ;
38203: LD_ADDR_VAR 0 8
38207: PUSH
38208: LD_INT 1
38210: PPUSH
38211: LD_VAR 0 7
38215: PUSH
38216: LD_INT 1
38218: ARRAY
38219: PPUSH
38220: CALL_OW 12
38224: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
38225: LD_ADDR_VAR 0 6
38229: PUSH
38230: LD_VAR 0 6
38234: PPUSH
38235: LD_VAR 0 5
38239: PPUSH
38240: LD_VAR 0 7
38244: PUSH
38245: LD_INT 1
38247: ARRAY
38248: PUSH
38249: LD_VAR 0 8
38253: ARRAY
38254: PUSH
38255: LD_VAR 0 7
38259: PUSH
38260: LD_INT 2
38262: ARRAY
38263: PUSH
38264: LD_VAR 0 8
38268: ARRAY
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PPUSH
38274: CALL_OW 1
38278: ST_TO_ADDR
// end ;
38279: GO 38200
38281: POP
38282: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
38283: LD_ADDR_EXP 63
38287: PUSH
38288: LD_EXP 63
38292: PPUSH
38293: LD_VAR 0 1
38297: PPUSH
38298: LD_VAR 0 6
38302: PPUSH
38303: CALL_OW 1
38307: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
38308: LD_ADDR_EXP 65
38312: PUSH
38313: LD_EXP 65
38317: PPUSH
38318: LD_VAR 0 1
38322: PPUSH
38323: LD_VAR 0 3
38327: PPUSH
38328: CALL_OW 1
38332: ST_TO_ADDR
// end ;
38333: LD_VAR 0 4
38337: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
38338: LD_INT 0
38340: PPUSH
// if not mc_bases [ base ] then
38341: LD_EXP 50
38345: PUSH
38346: LD_VAR 0 1
38350: ARRAY
38351: NOT
38352: IFFALSE 38356
// exit ;
38354: GO 38381
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
38356: LD_ADDR_EXP 55
38360: PUSH
38361: LD_EXP 55
38365: PPUSH
38366: LD_VAR 0 1
38370: PPUSH
38371: LD_VAR 0 2
38375: PPUSH
38376: CALL_OW 1
38380: ST_TO_ADDR
// end ;
38381: LD_VAR 0 3
38385: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
38386: LD_INT 0
38388: PPUSH
// if not mc_bases [ base ] then
38389: LD_EXP 50
38393: PUSH
38394: LD_VAR 0 1
38398: ARRAY
38399: NOT
38400: IFFALSE 38404
// exit ;
38402: GO 38441
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
38404: LD_ADDR_EXP 55
38408: PUSH
38409: LD_EXP 55
38413: PPUSH
38414: LD_VAR 0 1
38418: PPUSH
38419: LD_EXP 55
38423: PUSH
38424: LD_VAR 0 1
38428: ARRAY
38429: PUSH
38430: LD_VAR 0 2
38434: UNION
38435: PPUSH
38436: CALL_OW 1
38440: ST_TO_ADDR
// end ;
38441: LD_VAR 0 3
38445: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
38446: LD_INT 0
38448: PPUSH
// if not mc_bases [ base ] then
38449: LD_EXP 50
38453: PUSH
38454: LD_VAR 0 1
38458: ARRAY
38459: NOT
38460: IFFALSE 38464
// exit ;
38462: GO 38489
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
38464: LD_ADDR_EXP 71
38468: PUSH
38469: LD_EXP 71
38473: PPUSH
38474: LD_VAR 0 1
38478: PPUSH
38479: LD_VAR 0 2
38483: PPUSH
38484: CALL_OW 1
38488: ST_TO_ADDR
// end ;
38489: LD_VAR 0 3
38493: RET
// export function MC_InsertProduceList ( base , compontents ) ; begin
38494: LD_INT 0
38496: PPUSH
// if not mc_bases [ base ] then
38497: LD_EXP 50
38501: PUSH
38502: LD_VAR 0 1
38506: ARRAY
38507: NOT
38508: IFFALSE 38512
// exit ;
38510: GO 38549
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] union compontents ) ;
38512: LD_ADDR_EXP 71
38516: PUSH
38517: LD_EXP 71
38521: PPUSH
38522: LD_VAR 0 1
38526: PPUSH
38527: LD_EXP 71
38531: PUSH
38532: LD_VAR 0 1
38536: ARRAY
38537: PUSH
38538: LD_VAR 0 2
38542: UNION
38543: PPUSH
38544: CALL_OW 1
38548: ST_TO_ADDR
// end ;
38549: LD_VAR 0 3
38553: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
38554: LD_INT 0
38556: PPUSH
// if not mc_bases [ base ] then
38557: LD_EXP 50
38561: PUSH
38562: LD_VAR 0 1
38566: ARRAY
38567: NOT
38568: IFFALSE 38572
// exit ;
38570: GO 38684
// mc_defender := Replace ( mc_defender , base , deflist ) ;
38572: LD_ADDR_EXP 72
38576: PUSH
38577: LD_EXP 72
38581: PPUSH
38582: LD_VAR 0 1
38586: PPUSH
38587: LD_VAR 0 2
38591: PPUSH
38592: CALL_OW 1
38596: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
38597: LD_ADDR_EXP 61
38601: PUSH
38602: LD_EXP 61
38606: PPUSH
38607: LD_VAR 0 1
38611: PPUSH
38612: LD_VAR 0 2
38616: PUSH
38617: LD_INT 0
38619: PLUS
38620: PPUSH
38621: CALL_OW 1
38625: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] union UnitFilter ( mc_defender [ base ] , [ f_type , unit_vehicle ] ) ) ;
38626: LD_ADDR_EXP 69
38630: PUSH
38631: LD_EXP 69
38635: PPUSH
38636: LD_VAR 0 1
38640: PPUSH
38641: LD_EXP 69
38645: PUSH
38646: LD_VAR 0 1
38650: ARRAY
38651: PUSH
38652: LD_EXP 72
38656: PUSH
38657: LD_VAR 0 1
38661: ARRAY
38662: PPUSH
38663: LD_INT 21
38665: PUSH
38666: LD_INT 2
38668: PUSH
38669: EMPTY
38670: LIST
38671: LIST
38672: PPUSH
38673: CALL_OW 72
38677: UNION
38678: PPUSH
38679: CALL_OW 1
38683: ST_TO_ADDR
// end ;
38684: LD_VAR 0 3
38688: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
38689: LD_INT 0
38691: PPUSH
// if not mc_bases [ base ] then
38692: LD_EXP 50
38696: PUSH
38697: LD_VAR 0 1
38701: ARRAY
38702: NOT
38703: IFFALSE 38707
// exit ;
38705: GO 38732
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
38707: LD_ADDR_EXP 61
38711: PUSH
38712: LD_EXP 61
38716: PPUSH
38717: LD_VAR 0 1
38721: PPUSH
38722: LD_VAR 0 2
38726: PPUSH
38727: CALL_OW 1
38731: ST_TO_ADDR
// end ;
38732: LD_VAR 0 3
38736: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
38737: LD_INT 0
38739: PPUSH
38740: PPUSH
38741: PPUSH
38742: PPUSH
// if not mc_bases [ base ] then
38743: LD_EXP 50
38747: PUSH
38748: LD_VAR 0 1
38752: ARRAY
38753: NOT
38754: IFFALSE 38758
// exit ;
38756: GO 38823
// mc_attack := Add ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
38758: LD_ADDR_EXP 70
38762: PUSH
38763: LD_EXP 70
38767: PPUSH
38768: LD_VAR 0 1
38772: PUSH
38773: LD_EXP 70
38777: PUSH
38778: LD_VAR 0 1
38782: ARRAY
38783: PUSH
38784: LD_INT 1
38786: PLUS
38787: PUSH
38788: EMPTY
38789: LIST
38790: LIST
38791: PPUSH
38792: LD_VAR 0 1
38796: PUSH
38797: LD_VAR 0 2
38801: PUSH
38802: LD_VAR 0 3
38806: PUSH
38807: LD_VAR 0 4
38811: PUSH
38812: EMPTY
38813: LIST
38814: LIST
38815: LIST
38816: LIST
38817: PPUSH
38818: CALL 51308 0 3
38822: ST_TO_ADDR
// end ;
38823: LD_VAR 0 5
38827: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
38828: LD_INT 0
38830: PPUSH
// if not mc_bases [ base ] then
38831: LD_EXP 50
38835: PUSH
38836: LD_VAR 0 1
38840: ARRAY
38841: NOT
38842: IFFALSE 38846
// exit ;
38844: GO 38871
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
38846: LD_ADDR_EXP 87
38850: PUSH
38851: LD_EXP 87
38855: PPUSH
38856: LD_VAR 0 1
38860: PPUSH
38861: LD_VAR 0 2
38865: PPUSH
38866: CALL_OW 1
38870: ST_TO_ADDR
// end ;
38871: LD_VAR 0 3
38875: RET
// export function MC_GetMinesField ( base ) ; begin
38876: LD_INT 0
38878: PPUSH
// result := mc_mines [ base ] ;
38879: LD_ADDR_VAR 0 2
38883: PUSH
38884: LD_EXP 63
38888: PUSH
38889: LD_VAR 0 1
38893: ARRAY
38894: ST_TO_ADDR
// end ;
38895: LD_VAR 0 2
38899: RET
// export function MC_GetProduceList ( base ) ; begin
38900: LD_INT 0
38902: PPUSH
// result := mc_produce [ base ] ;
38903: LD_ADDR_VAR 0 2
38907: PUSH
38908: LD_EXP 71
38912: PUSH
38913: LD_VAR 0 1
38917: ARRAY
38918: ST_TO_ADDR
// end ;
38919: LD_VAR 0 2
38923: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
38924: LD_INT 0
38926: PPUSH
38927: PPUSH
// if not mc_bases then
38928: LD_EXP 50
38932: NOT
38933: IFFALSE 38937
// exit ;
38935: GO 39002
// if mc_bases [ base ] then
38937: LD_EXP 50
38941: PUSH
38942: LD_VAR 0 1
38946: ARRAY
38947: IFFALSE 39002
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
38949: LD_ADDR_VAR 0 3
38953: PUSH
38954: LD_EXP 50
38958: PUSH
38959: LD_VAR 0 1
38963: ARRAY
38964: PPUSH
38965: LD_INT 30
38967: PUSH
38968: LD_VAR 0 2
38972: PUSH
38973: EMPTY
38974: LIST
38975: LIST
38976: PPUSH
38977: CALL_OW 72
38981: ST_TO_ADDR
// if result then
38982: LD_VAR 0 3
38986: IFFALSE 39002
// result := result [ 1 ] ;
38988: LD_ADDR_VAR 0 3
38992: PUSH
38993: LD_VAR 0 3
38997: PUSH
38998: LD_INT 1
39000: ARRAY
39001: ST_TO_ADDR
// end ; end ;
39002: LD_VAR 0 3
39006: RET
// export function MC_SetTame ( base , area ) ; begin
39007: LD_INT 0
39009: PPUSH
// if not mc_bases or not base then
39010: LD_EXP 50
39014: NOT
39015: PUSH
39016: LD_VAR 0 1
39020: NOT
39021: OR
39022: IFFALSE 39026
// exit ;
39024: GO 39051
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
39026: LD_ADDR_EXP 78
39030: PUSH
39031: LD_EXP 78
39035: PPUSH
39036: LD_VAR 0 1
39040: PPUSH
39041: LD_VAR 0 2
39045: PPUSH
39046: CALL_OW 1
39050: ST_TO_ADDR
// end ;
39051: LD_VAR 0 3
39055: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
39056: LD_INT 0
39058: PPUSH
39059: PPUSH
// if not mc_bases or not base then
39060: LD_EXP 50
39064: NOT
39065: PUSH
39066: LD_VAR 0 1
39070: NOT
39071: OR
39072: IFFALSE 39076
// exit ;
39074: GO 39178
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
39076: LD_ADDR_VAR 0 4
39080: PUSH
39081: LD_EXP 50
39085: PUSH
39086: LD_VAR 0 1
39090: ARRAY
39091: PPUSH
39092: LD_INT 30
39094: PUSH
39095: LD_VAR 0 2
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: PPUSH
39104: CALL_OW 72
39108: ST_TO_ADDR
// if not tmp then
39109: LD_VAR 0 4
39113: NOT
39114: IFFALSE 39118
// exit ;
39116: GO 39178
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
39118: LD_ADDR_EXP 82
39122: PUSH
39123: LD_EXP 82
39127: PPUSH
39128: LD_VAR 0 1
39132: PPUSH
39133: LD_EXP 82
39137: PUSH
39138: LD_VAR 0 1
39142: ARRAY
39143: PPUSH
39144: LD_EXP 82
39148: PUSH
39149: LD_VAR 0 1
39153: ARRAY
39154: PUSH
39155: LD_INT 1
39157: PLUS
39158: PPUSH
39159: LD_VAR 0 4
39163: PUSH
39164: LD_INT 1
39166: ARRAY
39167: PPUSH
39168: CALL_OW 2
39172: PPUSH
39173: CALL_OW 1
39177: ST_TO_ADDR
// end ;
39178: LD_VAR 0 3
39182: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
39183: LD_INT 0
39185: PPUSH
39186: PPUSH
// if not mc_bases or not base or not kinds then
39187: LD_EXP 50
39191: NOT
39192: PUSH
39193: LD_VAR 0 1
39197: NOT
39198: OR
39199: PUSH
39200: LD_VAR 0 2
39204: NOT
39205: OR
39206: IFFALSE 39210
// exit ;
39208: GO 39271
// for i in kinds do
39210: LD_ADDR_VAR 0 4
39214: PUSH
39215: LD_VAR 0 2
39219: PUSH
39220: FOR_IN
39221: IFFALSE 39269
// mc_lab_upgrade := Add ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
39223: LD_ADDR_EXP 84
39227: PUSH
39228: LD_EXP 84
39232: PPUSH
39233: LD_VAR 0 1
39237: PUSH
39238: LD_EXP 84
39242: PUSH
39243: LD_VAR 0 1
39247: ARRAY
39248: PUSH
39249: LD_INT 1
39251: PLUS
39252: PUSH
39253: EMPTY
39254: LIST
39255: LIST
39256: PPUSH
39257: LD_VAR 0 4
39261: PPUSH
39262: CALL 51308 0 3
39266: ST_TO_ADDR
39267: GO 39220
39269: POP
39270: POP
// end ;
39271: LD_VAR 0 3
39275: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
39276: LD_INT 0
39278: PPUSH
// if not mc_bases or not base or not areas then
39279: LD_EXP 50
39283: NOT
39284: PUSH
39285: LD_VAR 0 1
39289: NOT
39290: OR
39291: PUSH
39292: LD_VAR 0 2
39296: NOT
39297: OR
39298: IFFALSE 39302
// exit ;
39300: GO 39327
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
39302: LD_ADDR_EXP 68
39306: PUSH
39307: LD_EXP 68
39311: PPUSH
39312: LD_VAR 0 1
39316: PPUSH
39317: LD_VAR 0 2
39321: PPUSH
39322: CALL_OW 1
39326: ST_TO_ADDR
// end ;
39327: LD_VAR 0 3
39331: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
39332: LD_INT 0
39334: PPUSH
// if not mc_bases or not base or not teleports_exit then
39335: LD_EXP 50
39339: NOT
39340: PUSH
39341: LD_VAR 0 1
39345: NOT
39346: OR
39347: PUSH
39348: LD_VAR 0 2
39352: NOT
39353: OR
39354: IFFALSE 39358
// exit ;
39356: GO 39383
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
39358: LD_ADDR_EXP 85
39362: PUSH
39363: LD_EXP 85
39367: PPUSH
39368: LD_VAR 0 1
39372: PPUSH
39373: LD_VAR 0 2
39377: PPUSH
39378: CALL_OW 1
39382: ST_TO_ADDR
// end ;
39383: LD_VAR 0 3
39387: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
39388: LD_INT 0
39390: PPUSH
39391: PPUSH
39392: PPUSH
// if not mc_bases or not base or not ext_list then
39393: LD_EXP 50
39397: NOT
39398: PUSH
39399: LD_VAR 0 1
39403: NOT
39404: OR
39405: PUSH
39406: LD_VAR 0 5
39410: NOT
39411: OR
39412: IFFALSE 39416
// exit ;
39414: GO 39589
// tmp := GetFacExtXYD ( x , y , d ) ;
39416: LD_ADDR_VAR 0 8
39420: PUSH
39421: LD_VAR 0 2
39425: PPUSH
39426: LD_VAR 0 3
39430: PPUSH
39431: LD_VAR 0 4
39435: PPUSH
39436: CALL 84034 0 3
39440: ST_TO_ADDR
// if not tmp then
39441: LD_VAR 0 8
39445: NOT
39446: IFFALSE 39450
// exit ;
39448: GO 39589
// for i in tmp do
39450: LD_ADDR_VAR 0 7
39454: PUSH
39455: LD_VAR 0 8
39459: PUSH
39460: FOR_IN
39461: IFFALSE 39587
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
39463: LD_ADDR_EXP 55
39467: PUSH
39468: LD_EXP 55
39472: PPUSH
39473: LD_VAR 0 1
39477: PPUSH
39478: LD_EXP 55
39482: PUSH
39483: LD_VAR 0 1
39487: ARRAY
39488: PPUSH
39489: LD_EXP 55
39493: PUSH
39494: LD_VAR 0 1
39498: ARRAY
39499: PUSH
39500: LD_INT 1
39502: PLUS
39503: PPUSH
39504: LD_VAR 0 5
39508: PUSH
39509: LD_INT 1
39511: ARRAY
39512: PUSH
39513: LD_VAR 0 7
39517: PUSH
39518: LD_INT 1
39520: ARRAY
39521: PUSH
39522: LD_VAR 0 7
39526: PUSH
39527: LD_INT 2
39529: ARRAY
39530: PUSH
39531: LD_VAR 0 7
39535: PUSH
39536: LD_INT 3
39538: ARRAY
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: LIST
39544: LIST
39545: PPUSH
39546: CALL_OW 2
39550: PPUSH
39551: CALL_OW 1
39555: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
39556: LD_ADDR_VAR 0 5
39560: PUSH
39561: LD_VAR 0 5
39565: PPUSH
39566: LD_INT 1
39568: PPUSH
39569: CALL_OW 3
39573: ST_TO_ADDR
// if not ext_list then
39574: LD_VAR 0 5
39578: NOT
39579: IFFALSE 39585
// exit ;
39581: POP
39582: POP
39583: GO 39589
// end ;
39585: GO 39460
39587: POP
39588: POP
// end ;
39589: LD_VAR 0 6
39593: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
39594: LD_INT 0
39596: PPUSH
// if not mc_bases or not base or not weapon_list then
39597: LD_EXP 50
39601: NOT
39602: PUSH
39603: LD_VAR 0 1
39607: NOT
39608: OR
39609: PUSH
39610: LD_VAR 0 2
39614: NOT
39615: OR
39616: IFFALSE 39620
// exit ;
39618: GO 39645
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
39620: LD_ADDR_EXP 89
39624: PUSH
39625: LD_EXP 89
39629: PPUSH
39630: LD_VAR 0 1
39634: PPUSH
39635: LD_VAR 0 2
39639: PPUSH
39640: CALL_OW 1
39644: ST_TO_ADDR
// end ;
39645: LD_VAR 0 3
39649: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
39650: LD_INT 0
39652: PPUSH
// if not mc_bases or not base or not tech_list then
39653: LD_EXP 50
39657: NOT
39658: PUSH
39659: LD_VAR 0 1
39663: NOT
39664: OR
39665: PUSH
39666: LD_VAR 0 2
39670: NOT
39671: OR
39672: IFFALSE 39676
// exit ;
39674: GO 39701
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
39676: LD_ADDR_EXP 77
39680: PUSH
39681: LD_EXP 77
39685: PPUSH
39686: LD_VAR 0 1
39690: PPUSH
39691: LD_VAR 0 2
39695: PPUSH
39696: CALL_OW 1
39700: ST_TO_ADDR
// end ;
39701: LD_VAR 0 3
39705: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
39706: LD_INT 0
39708: PPUSH
// if not mc_bases or not parking_area or not base then
39709: LD_EXP 50
39713: NOT
39714: PUSH
39715: LD_VAR 0 2
39719: NOT
39720: OR
39721: PUSH
39722: LD_VAR 0 1
39726: NOT
39727: OR
39728: IFFALSE 39732
// exit ;
39730: GO 39757
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
39732: LD_ADDR_EXP 74
39736: PUSH
39737: LD_EXP 74
39741: PPUSH
39742: LD_VAR 0 1
39746: PPUSH
39747: LD_VAR 0 2
39751: PPUSH
39752: CALL_OW 1
39756: ST_TO_ADDR
// end ;
39757: LD_VAR 0 3
39761: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
39762: LD_INT 0
39764: PPUSH
// if not mc_bases or not base or not scan_area then
39765: LD_EXP 50
39769: NOT
39770: PUSH
39771: LD_VAR 0 1
39775: NOT
39776: OR
39777: PUSH
39778: LD_VAR 0 2
39782: NOT
39783: OR
39784: IFFALSE 39788
// exit ;
39786: GO 39813
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
39788: LD_ADDR_EXP 75
39792: PUSH
39793: LD_EXP 75
39797: PPUSH
39798: LD_VAR 0 1
39802: PPUSH
39803: LD_VAR 0 2
39807: PPUSH
39808: CALL_OW 1
39812: ST_TO_ADDR
// end ;
39813: LD_VAR 0 3
39817: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
39818: LD_INT 0
39820: PPUSH
39821: PPUSH
// if not mc_bases or not base then
39822: LD_EXP 50
39826: NOT
39827: PUSH
39828: LD_VAR 0 1
39832: NOT
39833: OR
39834: IFFALSE 39838
// exit ;
39836: GO 39902
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
39838: LD_ADDR_VAR 0 3
39842: PUSH
39843: LD_INT 1
39845: PUSH
39846: LD_INT 2
39848: PUSH
39849: LD_INT 3
39851: PUSH
39852: LD_INT 4
39854: PUSH
39855: LD_INT 11
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: LIST
39862: LIST
39863: LIST
39864: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
39865: LD_ADDR_EXP 77
39869: PUSH
39870: LD_EXP 77
39874: PPUSH
39875: LD_VAR 0 1
39879: PPUSH
39880: LD_EXP 77
39884: PUSH
39885: LD_VAR 0 1
39889: ARRAY
39890: PUSH
39891: LD_VAR 0 3
39895: DIFF
39896: PPUSH
39897: CALL_OW 1
39901: ST_TO_ADDR
// end ; end_of_file
39902: LD_VAR 0 2
39906: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
39907: LD_INT 0
39909: PPUSH
39910: PPUSH
39911: PPUSH
// if not mc_bases then
39912: LD_EXP 50
39916: NOT
39917: IFFALSE 39921
// exit ;
39919: GO 40086
// for i = 1 to mc_bases do
39921: LD_ADDR_VAR 0 4
39925: PUSH
39926: DOUBLE
39927: LD_INT 1
39929: DEC
39930: ST_TO_ADDR
39931: LD_EXP 50
39935: PUSH
39936: FOR_TO
39937: IFFALSE 40084
// begin if sci in mc_bases [ i ] then
39939: LD_VAR 0 2
39943: PUSH
39944: LD_EXP 50
39948: PUSH
39949: LD_VAR 0 4
39953: ARRAY
39954: IN
39955: IFFALSE 40082
// begin mc_ape := Add ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
39957: LD_ADDR_EXP 79
39961: PUSH
39962: LD_EXP 79
39966: PPUSH
39967: LD_VAR 0 4
39971: PUSH
39972: LD_EXP 79
39976: PUSH
39977: LD_VAR 0 4
39981: ARRAY
39982: PUSH
39983: LD_INT 1
39985: PLUS
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PPUSH
39991: LD_VAR 0 1
39995: PPUSH
39996: CALL 51308 0 3
40000: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
40001: LD_ADDR_VAR 0 5
40005: PUSH
40006: LD_EXP 50
40010: PUSH
40011: LD_VAR 0 4
40015: ARRAY
40016: PPUSH
40017: LD_INT 2
40019: PUSH
40020: LD_INT 30
40022: PUSH
40023: LD_INT 0
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: PUSH
40030: LD_INT 30
40032: PUSH
40033: LD_INT 1
40035: PUSH
40036: EMPTY
40037: LIST
40038: LIST
40039: PUSH
40040: EMPTY
40041: LIST
40042: LIST
40043: LIST
40044: PPUSH
40045: CALL_OW 72
40049: PPUSH
40050: LD_VAR 0 1
40054: PPUSH
40055: CALL_OW 74
40059: ST_TO_ADDR
// if tmp then
40060: LD_VAR 0 5
40064: IFFALSE 40080
// ComStandNearbyBuilding ( ape , tmp ) ;
40066: LD_VAR 0 1
40070: PPUSH
40071: LD_VAR 0 5
40075: PPUSH
40076: CALL 45550 0 2
// break ;
40080: GO 40084
// end ; end ;
40082: GO 39936
40084: POP
40085: POP
// end ;
40086: LD_VAR 0 3
40090: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
40091: LD_INT 0
40093: PPUSH
40094: PPUSH
40095: PPUSH
// if not mc_bases then
40096: LD_EXP 50
40100: NOT
40101: IFFALSE 40105
// exit ;
40103: GO 40194
// for i = 1 to mc_bases do
40105: LD_ADDR_VAR 0 4
40109: PUSH
40110: DOUBLE
40111: LD_INT 1
40113: DEC
40114: ST_TO_ADDR
40115: LD_EXP 50
40119: PUSH
40120: FOR_TO
40121: IFFALSE 40192
// begin if building in mc_busy_turret_list [ i ] then
40123: LD_VAR 0 1
40127: PUSH
40128: LD_EXP 60
40132: PUSH
40133: LD_VAR 0 4
40137: ARRAY
40138: IN
40139: IFFALSE 40190
// begin tmp := mc_busy_turret_list [ i ] diff building ;
40141: LD_ADDR_VAR 0 5
40145: PUSH
40146: LD_EXP 60
40150: PUSH
40151: LD_VAR 0 4
40155: ARRAY
40156: PUSH
40157: LD_VAR 0 1
40161: DIFF
40162: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
40163: LD_ADDR_EXP 60
40167: PUSH
40168: LD_EXP 60
40172: PPUSH
40173: LD_VAR 0 4
40177: PPUSH
40178: LD_VAR 0 5
40182: PPUSH
40183: CALL_OW 1
40187: ST_TO_ADDR
// break ;
40188: GO 40192
// end ; end ;
40190: GO 40120
40192: POP
40193: POP
// end ;
40194: LD_VAR 0 3
40198: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
40199: LD_INT 0
40201: PPUSH
40202: PPUSH
40203: PPUSH
// if not mc_bases then
40204: LD_EXP 50
40208: NOT
40209: IFFALSE 40213
// exit ;
40211: GO 40412
// for i = 1 to mc_bases do
40213: LD_ADDR_VAR 0 5
40217: PUSH
40218: DOUBLE
40219: LD_INT 1
40221: DEC
40222: ST_TO_ADDR
40223: LD_EXP 50
40227: PUSH
40228: FOR_TO
40229: IFFALSE 40410
// if building in mc_bases [ i ] then
40231: LD_VAR 0 1
40235: PUSH
40236: LD_EXP 50
40240: PUSH
40241: LD_VAR 0 5
40245: ARRAY
40246: IN
40247: IFFALSE 40408
// begin tmp := mc_bases [ i ] diff building ;
40249: LD_ADDR_VAR 0 6
40253: PUSH
40254: LD_EXP 50
40258: PUSH
40259: LD_VAR 0 5
40263: ARRAY
40264: PUSH
40265: LD_VAR 0 1
40269: DIFF
40270: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
40271: LD_ADDR_EXP 50
40275: PUSH
40276: LD_EXP 50
40280: PPUSH
40281: LD_VAR 0 5
40285: PPUSH
40286: LD_VAR 0 6
40290: PPUSH
40291: CALL_OW 1
40295: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
40296: LD_VAR 0 1
40300: PUSH
40301: LD_EXP 58
40305: PUSH
40306: LD_VAR 0 5
40310: ARRAY
40311: IN
40312: IFFALSE 40351
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
40314: LD_ADDR_EXP 58
40318: PUSH
40319: LD_EXP 58
40323: PPUSH
40324: LD_VAR 0 5
40328: PPUSH
40329: LD_EXP 58
40333: PUSH
40334: LD_VAR 0 5
40338: ARRAY
40339: PUSH
40340: LD_VAR 0 1
40344: DIFF
40345: PPUSH
40346: CALL_OW 1
40350: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
40351: LD_VAR 0 1
40355: PUSH
40356: LD_EXP 59
40360: PUSH
40361: LD_VAR 0 5
40365: ARRAY
40366: IN
40367: IFFALSE 40406
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
40369: LD_ADDR_EXP 59
40373: PUSH
40374: LD_EXP 59
40378: PPUSH
40379: LD_VAR 0 5
40383: PPUSH
40384: LD_EXP 59
40388: PUSH
40389: LD_VAR 0 5
40393: ARRAY
40394: PUSH
40395: LD_VAR 0 1
40399: DIFF
40400: PPUSH
40401: CALL_OW 1
40405: ST_TO_ADDR
// break ;
40406: GO 40410
// end ;
40408: GO 40228
40410: POP
40411: POP
// end ;
40412: LD_VAR 0 4
40416: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
40417: LD_INT 0
40419: PPUSH
40420: PPUSH
40421: PPUSH
// if not mc_bases or not side in mc_sides then
40422: LD_EXP 50
40426: NOT
40427: PUSH
40428: LD_VAR 0 3
40432: PUSH
40433: LD_EXP 76
40437: IN
40438: NOT
40439: OR
40440: IFFALSE 40444
// exit ;
40442: GO 40567
// for i = 1 to mc_vehicles do
40444: LD_ADDR_VAR 0 6
40448: PUSH
40449: DOUBLE
40450: LD_INT 1
40452: DEC
40453: ST_TO_ADDR
40454: LD_EXP 69
40458: PUSH
40459: FOR_TO
40460: IFFALSE 40565
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
40462: LD_VAR 0 2
40466: PUSH
40467: LD_EXP 69
40471: PUSH
40472: LD_VAR 0 6
40476: ARRAY
40477: IN
40478: PUSH
40479: LD_VAR 0 1
40483: PUSH
40484: LD_EXP 69
40488: PUSH
40489: LD_VAR 0 6
40493: ARRAY
40494: IN
40495: OR
40496: IFFALSE 40563
// begin tmp := mc_vehicles [ i ] diff old ;
40498: LD_ADDR_VAR 0 7
40502: PUSH
40503: LD_EXP 69
40507: PUSH
40508: LD_VAR 0 6
40512: ARRAY
40513: PUSH
40514: LD_VAR 0 2
40518: DIFF
40519: ST_TO_ADDR
// tmp := tmp diff new ;
40520: LD_ADDR_VAR 0 7
40524: PUSH
40525: LD_VAR 0 7
40529: PUSH
40530: LD_VAR 0 1
40534: DIFF
40535: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
40536: LD_ADDR_EXP 69
40540: PUSH
40541: LD_EXP 69
40545: PPUSH
40546: LD_VAR 0 6
40550: PPUSH
40551: LD_VAR 0 7
40555: PPUSH
40556: CALL_OW 1
40560: ST_TO_ADDR
// break ;
40561: GO 40565
// end ;
40563: GO 40459
40565: POP
40566: POP
// end ;
40567: LD_VAR 0 5
40571: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
40572: LD_INT 0
40574: PPUSH
40575: PPUSH
40576: PPUSH
40577: PPUSH
// if not mc_bases then
40578: LD_EXP 50
40582: NOT
40583: IFFALSE 40587
// exit ;
40585: GO 40970
// side := GetSide ( vehicle ) ;
40587: LD_ADDR_VAR 0 5
40591: PUSH
40592: LD_VAR 0 1
40596: PPUSH
40597: CALL_OW 255
40601: ST_TO_ADDR
// for i = 1 to mc_bases do
40602: LD_ADDR_VAR 0 4
40606: PUSH
40607: DOUBLE
40608: LD_INT 1
40610: DEC
40611: ST_TO_ADDR
40612: LD_EXP 50
40616: PUSH
40617: FOR_TO
40618: IFFALSE 40968
// begin if factory in mc_bases [ i ] then
40620: LD_VAR 0 2
40624: PUSH
40625: LD_EXP 50
40629: PUSH
40630: LD_VAR 0 4
40634: ARRAY
40635: IN
40636: IFFALSE 40966
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
40638: LD_EXP 72
40642: PUSH
40643: LD_VAR 0 4
40647: ARRAY
40648: PUSH
40649: LD_EXP 61
40653: PUSH
40654: LD_VAR 0 4
40658: ARRAY
40659: LESS
40660: PUSH
40661: LD_VAR 0 1
40665: PPUSH
40666: CALL_OW 264
40670: PUSH
40671: LD_INT 31
40673: PUSH
40674: LD_INT 32
40676: PUSH
40677: LD_INT 51
40679: PUSH
40680: LD_EXP 94
40684: PUSH
40685: LD_INT 12
40687: PUSH
40688: LD_INT 30
40690: PUSH
40691: LD_EXP 93
40695: PUSH
40696: LD_INT 11
40698: PUSH
40699: LD_INT 53
40701: PUSH
40702: LD_INT 14
40704: PUSH
40705: LD_EXP 97
40709: PUSH
40710: LD_INT 29
40712: PUSH
40713: LD_EXP 95
40717: PUSH
40718: LD_INT 13
40720: PUSH
40721: LD_INT 52
40723: PUSH
40724: LD_INT 48
40726: PUSH
40727: LD_INT 8
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: LIST
40734: LIST
40735: LIST
40736: LIST
40737: LIST
40738: LIST
40739: LIST
40740: LIST
40741: LIST
40742: LIST
40743: LIST
40744: LIST
40745: LIST
40746: LIST
40747: LIST
40748: IN
40749: NOT
40750: AND
40751: IFFALSE 40792
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
40753: LD_ADDR_EXP 72
40757: PUSH
40758: LD_EXP 72
40762: PPUSH
40763: LD_VAR 0 4
40767: PPUSH
40768: LD_EXP 72
40772: PUSH
40773: LD_VAR 0 4
40777: ARRAY
40778: PUSH
40779: LD_VAR 0 1
40783: ADD
40784: PPUSH
40785: CALL_OW 1
40789: ST_TO_ADDR
40790: GO 40836
// mc_vehicles := Add ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
40792: LD_ADDR_EXP 69
40796: PUSH
40797: LD_EXP 69
40801: PPUSH
40802: LD_VAR 0 4
40806: PUSH
40807: LD_EXP 69
40811: PUSH
40812: LD_VAR 0 4
40816: ARRAY
40817: PUSH
40818: LD_INT 1
40820: PLUS
40821: PUSH
40822: EMPTY
40823: LIST
40824: LIST
40825: PPUSH
40826: LD_VAR 0 1
40830: PPUSH
40831: CALL 51308 0 3
40835: ST_TO_ADDR
// if not mc_scan [ i ] then
40836: LD_EXP 73
40840: PUSH
40841: LD_VAR 0 4
40845: ARRAY
40846: NOT
40847: IFFALSE 40966
// begin if GetControl ( vehicle ) = control_remote then
40849: LD_VAR 0 1
40853: PPUSH
40854: CALL_OW 263
40858: PUSH
40859: LD_INT 2
40861: EQUAL
40862: IFFALSE 40882
// repeat wait ( 0 0$1 ) ;
40864: LD_INT 35
40866: PPUSH
40867: CALL_OW 67
// until IsControledBy ( vehicle ) ;
40871: LD_VAR 0 1
40875: PPUSH
40876: CALL_OW 312
40880: IFFALSE 40864
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
40882: LD_VAR 0 1
40886: PPUSH
40887: LD_EXP 74
40891: PUSH
40892: LD_VAR 0 4
40896: ARRAY
40897: PPUSH
40898: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
40902: LD_VAR 0 1
40906: PPUSH
40907: CALL_OW 263
40911: PUSH
40912: LD_INT 1
40914: NONEQUAL
40915: IFFALSE 40919
// break ;
40917: GO 40968
// repeat wait ( 0 0$1 ) ;
40919: LD_INT 35
40921: PPUSH
40922: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
40926: LD_VAR 0 1
40930: PPUSH
40931: LD_EXP 74
40935: PUSH
40936: LD_VAR 0 4
40940: ARRAY
40941: PPUSH
40942: CALL_OW 308
40946: IFFALSE 40919
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
40948: LD_VAR 0 1
40952: PPUSH
40953: CALL_OW 311
40957: PPUSH
40958: CALL_OW 121
// exit ;
40962: POP
40963: POP
40964: GO 40970
// end ; end ; end ;
40966: GO 40617
40968: POP
40969: POP
// end ;
40970: LD_VAR 0 3
40974: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
40975: LD_INT 0
40977: PPUSH
40978: PPUSH
40979: PPUSH
40980: PPUSH
// if not mc_bases then
40981: LD_EXP 50
40985: NOT
40986: IFFALSE 40990
// exit ;
40988: GO 41343
// repeat wait ( 0 0$1 ) ;
40990: LD_INT 35
40992: PPUSH
40993: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
40997: LD_VAR 0 2
41001: PPUSH
41002: LD_VAR 0 3
41006: PPUSH
41007: CALL_OW 284
41011: IFFALSE 40990
// if GetResourceTypeXY ( x , y ) = mat_artefact then
41013: LD_VAR 0 2
41017: PPUSH
41018: LD_VAR 0 3
41022: PPUSH
41023: CALL_OW 283
41027: PUSH
41028: LD_INT 4
41030: EQUAL
41031: IFFALSE 41035
// exit ;
41033: GO 41343
// for i = 1 to mc_bases do
41035: LD_ADDR_VAR 0 7
41039: PUSH
41040: DOUBLE
41041: LD_INT 1
41043: DEC
41044: ST_TO_ADDR
41045: LD_EXP 50
41049: PUSH
41050: FOR_TO
41051: IFFALSE 41341
// begin if mc_crates_area [ i ] then
41053: LD_EXP 68
41057: PUSH
41058: LD_VAR 0 7
41062: ARRAY
41063: IFFALSE 41174
// for j in mc_crates_area [ i ] do
41065: LD_ADDR_VAR 0 8
41069: PUSH
41070: LD_EXP 68
41074: PUSH
41075: LD_VAR 0 7
41079: ARRAY
41080: PUSH
41081: FOR_IN
41082: IFFALSE 41172
// if InArea ( x , y , j ) then
41084: LD_VAR 0 2
41088: PPUSH
41089: LD_VAR 0 3
41093: PPUSH
41094: LD_VAR 0 8
41098: PPUSH
41099: CALL_OW 309
41103: IFFALSE 41170
// begin mc_crates := Add ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
41105: LD_ADDR_EXP 66
41109: PUSH
41110: LD_EXP 66
41114: PPUSH
41115: LD_VAR 0 7
41119: PUSH
41120: LD_EXP 66
41124: PUSH
41125: LD_VAR 0 7
41129: ARRAY
41130: PUSH
41131: LD_INT 1
41133: PLUS
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PPUSH
41139: LD_VAR 0 4
41143: PUSH
41144: LD_VAR 0 2
41148: PUSH
41149: LD_VAR 0 3
41153: PUSH
41154: EMPTY
41155: LIST
41156: LIST
41157: LIST
41158: PPUSH
41159: CALL 51308 0 3
41163: ST_TO_ADDR
// exit ;
41164: POP
41165: POP
41166: POP
41167: POP
41168: GO 41343
// end ;
41170: GO 41081
41172: POP
41173: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41174: LD_ADDR_VAR 0 9
41178: PUSH
41179: LD_EXP 50
41183: PUSH
41184: LD_VAR 0 7
41188: ARRAY
41189: PPUSH
41190: LD_INT 2
41192: PUSH
41193: LD_INT 30
41195: PUSH
41196: LD_INT 0
41198: PUSH
41199: EMPTY
41200: LIST
41201: LIST
41202: PUSH
41203: LD_INT 30
41205: PUSH
41206: LD_INT 1
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: LIST
41217: PPUSH
41218: CALL_OW 72
41222: ST_TO_ADDR
// if not depot then
41223: LD_VAR 0 9
41227: NOT
41228: IFFALSE 41232
// continue ;
41230: GO 41050
// for j in depot do
41232: LD_ADDR_VAR 0 8
41236: PUSH
41237: LD_VAR 0 9
41241: PUSH
41242: FOR_IN
41243: IFFALSE 41337
// if GetDistUnitXY ( j , x , y ) < 30 then
41245: LD_VAR 0 8
41249: PPUSH
41250: LD_VAR 0 2
41254: PPUSH
41255: LD_VAR 0 3
41259: PPUSH
41260: CALL_OW 297
41264: PUSH
41265: LD_INT 30
41267: LESS
41268: IFFALSE 41335
// begin mc_crates := Add ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
41270: LD_ADDR_EXP 66
41274: PUSH
41275: LD_EXP 66
41279: PPUSH
41280: LD_VAR 0 7
41284: PUSH
41285: LD_EXP 66
41289: PUSH
41290: LD_VAR 0 7
41294: ARRAY
41295: PUSH
41296: LD_INT 1
41298: PLUS
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PPUSH
41304: LD_VAR 0 4
41308: PUSH
41309: LD_VAR 0 2
41313: PUSH
41314: LD_VAR 0 3
41318: PUSH
41319: EMPTY
41320: LIST
41321: LIST
41322: LIST
41323: PPUSH
41324: CALL 51308 0 3
41328: ST_TO_ADDR
// exit ;
41329: POP
41330: POP
41331: POP
41332: POP
41333: GO 41343
// end ;
41335: GO 41242
41337: POP
41338: POP
// end ;
41339: GO 41050
41341: POP
41342: POP
// end ;
41343: LD_VAR 0 6
41347: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
41348: LD_INT 0
41350: PPUSH
41351: PPUSH
41352: PPUSH
41353: PPUSH
// side := GetSide ( lab ) ;
41354: LD_ADDR_VAR 0 4
41358: PUSH
41359: LD_VAR 0 2
41363: PPUSH
41364: CALL_OW 255
41368: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
41369: LD_VAR 0 4
41373: PUSH
41374: LD_EXP 76
41378: IN
41379: NOT
41380: PUSH
41381: LD_EXP 77
41385: NOT
41386: OR
41387: PUSH
41388: LD_EXP 50
41392: NOT
41393: OR
41394: IFFALSE 41398
// exit ;
41396: GO 41631
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
41398: LD_ADDR_EXP 77
41402: PUSH
41403: LD_EXP 77
41407: PPUSH
41408: LD_VAR 0 4
41412: PPUSH
41413: LD_EXP 77
41417: PUSH
41418: LD_VAR 0 4
41422: ARRAY
41423: PUSH
41424: LD_VAR 0 1
41428: DIFF
41429: PPUSH
41430: CALL_OW 1
41434: ST_TO_ADDR
// for i = 1 to mc_bases do
41435: LD_ADDR_VAR 0 5
41439: PUSH
41440: DOUBLE
41441: LD_INT 1
41443: DEC
41444: ST_TO_ADDR
41445: LD_EXP 50
41449: PUSH
41450: FOR_TO
41451: IFFALSE 41629
// begin if lab in mc_bases [ i ] then
41453: LD_VAR 0 2
41457: PUSH
41458: LD_EXP 50
41462: PUSH
41463: LD_VAR 0 5
41467: ARRAY
41468: IN
41469: IFFALSE 41627
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
41471: LD_VAR 0 1
41475: PUSH
41476: LD_INT 11
41478: PUSH
41479: LD_INT 4
41481: PUSH
41482: LD_INT 3
41484: PUSH
41485: LD_INT 2
41487: PUSH
41488: EMPTY
41489: LIST
41490: LIST
41491: LIST
41492: LIST
41493: IN
41494: PUSH
41495: LD_EXP 80
41499: PUSH
41500: LD_VAR 0 5
41504: ARRAY
41505: AND
41506: IFFALSE 41627
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
41508: LD_ADDR_VAR 0 6
41512: PUSH
41513: LD_EXP 80
41517: PUSH
41518: LD_VAR 0 5
41522: ARRAY
41523: PUSH
41524: LD_INT 1
41526: ARRAY
41527: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
41528: LD_ADDR_EXP 80
41532: PUSH
41533: LD_EXP 80
41537: PPUSH
41538: LD_VAR 0 5
41542: PPUSH
41543: EMPTY
41544: PPUSH
41545: CALL_OW 1
41549: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
41550: LD_VAR 0 6
41554: PPUSH
41555: LD_INT 0
41557: PPUSH
41558: CALL_OW 109
// ComExitBuilding ( tmp ) ;
41562: LD_VAR 0 6
41566: PPUSH
41567: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
41571: LD_ADDR_EXP 79
41575: PUSH
41576: LD_EXP 79
41580: PPUSH
41581: LD_VAR 0 5
41585: PPUSH
41586: LD_EXP 79
41590: PUSH
41591: LD_VAR 0 5
41595: ARRAY
41596: PPUSH
41597: LD_INT 1
41599: PPUSH
41600: LD_VAR 0 6
41604: PPUSH
41605: CALL_OW 2
41609: PPUSH
41610: CALL_OW 1
41614: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
41615: LD_VAR 0 5
41619: PPUSH
41620: LD_INT 112
41622: PPUSH
41623: CALL 19681 0 2
// end ; end ; end ;
41627: GO 41450
41629: POP
41630: POP
// end ;
41631: LD_VAR 0 3
41635: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
41636: LD_INT 0
41638: PPUSH
41639: PPUSH
41640: PPUSH
41641: PPUSH
41642: PPUSH
41643: PPUSH
41644: PPUSH
41645: PPUSH
// if not mc_bases then
41646: LD_EXP 50
41650: NOT
41651: IFFALSE 41655
// exit ;
41653: GO 42598
// for i = 1 to mc_bases do
41655: LD_ADDR_VAR 0 3
41659: PUSH
41660: DOUBLE
41661: LD_INT 1
41663: DEC
41664: ST_TO_ADDR
41665: LD_EXP 50
41669: PUSH
41670: FOR_TO
41671: IFFALSE 42596
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
41673: LD_VAR 0 1
41677: PUSH
41678: LD_EXP 50
41682: PUSH
41683: LD_VAR 0 3
41687: ARRAY
41688: IN
41689: PUSH
41690: LD_VAR 0 1
41694: PUSH
41695: LD_EXP 57
41699: PUSH
41700: LD_VAR 0 3
41704: ARRAY
41705: IN
41706: OR
41707: PUSH
41708: LD_VAR 0 1
41712: PUSH
41713: LD_EXP 69
41717: PUSH
41718: LD_VAR 0 3
41722: ARRAY
41723: IN
41724: OR
41725: PUSH
41726: LD_VAR 0 1
41730: PUSH
41731: LD_EXP 79
41735: PUSH
41736: LD_VAR 0 3
41740: ARRAY
41741: IN
41742: OR
41743: PUSH
41744: LD_VAR 0 1
41748: PUSH
41749: LD_EXP 80
41753: PUSH
41754: LD_VAR 0 3
41758: ARRAY
41759: IN
41760: OR
41761: IFFALSE 42594
// begin if un in mc_ape [ i ] then
41763: LD_VAR 0 1
41767: PUSH
41768: LD_EXP 79
41772: PUSH
41773: LD_VAR 0 3
41777: ARRAY
41778: IN
41779: IFFALSE 41818
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
41781: LD_ADDR_EXP 79
41785: PUSH
41786: LD_EXP 79
41790: PPUSH
41791: LD_VAR 0 3
41795: PPUSH
41796: LD_EXP 79
41800: PUSH
41801: LD_VAR 0 3
41805: ARRAY
41806: PUSH
41807: LD_VAR 0 1
41811: DIFF
41812: PPUSH
41813: CALL_OW 1
41817: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
41818: LD_VAR 0 1
41822: PUSH
41823: LD_EXP 80
41827: PUSH
41828: LD_VAR 0 3
41832: ARRAY
41833: IN
41834: IFFALSE 41858
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
41836: LD_ADDR_EXP 80
41840: PUSH
41841: LD_EXP 80
41845: PPUSH
41846: LD_VAR 0 3
41850: PPUSH
41851: EMPTY
41852: PPUSH
41853: CALL_OW 1
41857: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and GetTag ( un ) = 20 then
41858: LD_VAR 0 1
41862: PPUSH
41863: CALL_OW 247
41867: PUSH
41868: LD_INT 2
41870: EQUAL
41871: PUSH
41872: LD_VAR 0 1
41876: PPUSH
41877: CALL_OW 110
41881: PUSH
41882: LD_INT 20
41884: EQUAL
41885: AND
41886: IFFALSE 41989
// begin fac := MC_GetBuilding ( i , b_factory ) ;
41888: LD_ADDR_VAR 0 8
41892: PUSH
41893: LD_VAR 0 3
41897: PPUSH
41898: LD_INT 3
41900: PPUSH
41901: CALL 38924 0 2
41905: ST_TO_ADDR
// if fac then
41906: LD_VAR 0 8
41910: IFFALSE 41989
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
41912: LD_ADDR_VAR 0 9
41916: PUSH
41917: LD_VAR 0 8
41921: PPUSH
41922: LD_VAR 0 1
41926: PPUSH
41927: CALL_OW 265
41931: PPUSH
41932: LD_VAR 0 1
41936: PPUSH
41937: CALL_OW 262
41941: PPUSH
41942: LD_VAR 0 1
41946: PPUSH
41947: CALL_OW 263
41951: PPUSH
41952: LD_VAR 0 1
41956: PPUSH
41957: CALL_OW 264
41961: PPUSH
41962: CALL 48473 0 5
41966: ST_TO_ADDR
// if components then
41967: LD_VAR 0 9
41971: IFFALSE 41987
// MC_InsertProduceList ( i , components ) ;
41973: LD_VAR 0 3
41977: PPUSH
41978: LD_VAR 0 9
41982: PPUSH
41983: CALL 38494 0 2
// break ;
41987: GO 42596
// end ; end ; if GetType ( un ) = unit_building then
41989: LD_VAR 0 1
41993: PPUSH
41994: CALL_OW 247
41998: PUSH
41999: LD_INT 3
42001: EQUAL
42002: IFFALSE 42317
// begin btype := GetBType ( un ) ;
42004: LD_ADDR_VAR 0 5
42008: PUSH
42009: LD_VAR 0 1
42013: PPUSH
42014: CALL_OW 266
42018: ST_TO_ADDR
// if btype = b_warehouse then
42019: LD_VAR 0 5
42023: PUSH
42024: LD_INT 1
42026: EQUAL
42027: IFFALSE 42045
// begin btype := b_depot ;
42029: LD_ADDR_VAR 0 5
42033: PUSH
42034: LD_INT 0
42036: ST_TO_ADDR
// pos := 1 ;
42037: LD_ADDR_VAR 0 6
42041: PUSH
42042: LD_INT 1
42044: ST_TO_ADDR
// end ; if btype = b_factory then
42045: LD_VAR 0 5
42049: PUSH
42050: LD_INT 3
42052: EQUAL
42053: IFFALSE 42071
// begin btype := b_workshop ;
42055: LD_ADDR_VAR 0 5
42059: PUSH
42060: LD_INT 2
42062: ST_TO_ADDR
// pos := 1 ;
42063: LD_ADDR_VAR 0 6
42067: PUSH
42068: LD_INT 1
42070: ST_TO_ADDR
// end ; if btype = b_barracks then
42071: LD_VAR 0 5
42075: PUSH
42076: LD_INT 5
42078: EQUAL
42079: IFFALSE 42089
// btype := b_armoury ;
42081: LD_ADDR_VAR 0 5
42085: PUSH
42086: LD_INT 4
42088: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
42089: LD_VAR 0 5
42093: PUSH
42094: LD_INT 7
42096: PUSH
42097: LD_INT 8
42099: PUSH
42100: EMPTY
42101: LIST
42102: LIST
42103: IN
42104: IFFALSE 42114
// btype := b_lab ;
42106: LD_ADDR_VAR 0 5
42110: PUSH
42111: LD_INT 6
42113: ST_TO_ADDR
// mc_build_list := Add ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
42114: LD_ADDR_EXP 55
42118: PUSH
42119: LD_EXP 55
42123: PPUSH
42124: LD_VAR 0 3
42128: PUSH
42129: LD_EXP 55
42133: PUSH
42134: LD_VAR 0 3
42138: ARRAY
42139: PUSH
42140: LD_INT 1
42142: PLUS
42143: PUSH
42144: EMPTY
42145: LIST
42146: LIST
42147: PPUSH
42148: LD_VAR 0 5
42152: PUSH
42153: LD_VAR 0 1
42157: PPUSH
42158: CALL_OW 250
42162: PUSH
42163: LD_VAR 0 1
42167: PPUSH
42168: CALL_OW 251
42172: PUSH
42173: LD_VAR 0 1
42177: PPUSH
42178: CALL_OW 254
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: LIST
42187: LIST
42188: PPUSH
42189: CALL 51308 0 3
42193: ST_TO_ADDR
// if pos = 1 then
42194: LD_VAR 0 6
42198: PUSH
42199: LD_INT 1
42201: EQUAL
42202: IFFALSE 42317
// begin tmp := mc_build_list [ i ] ;
42204: LD_ADDR_VAR 0 7
42208: PUSH
42209: LD_EXP 55
42213: PUSH
42214: LD_VAR 0 3
42218: ARRAY
42219: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42220: LD_VAR 0 7
42224: PPUSH
42225: LD_INT 2
42227: PUSH
42228: LD_INT 30
42230: PUSH
42231: LD_INT 0
42233: PUSH
42234: EMPTY
42235: LIST
42236: LIST
42237: PUSH
42238: LD_INT 30
42240: PUSH
42241: LD_INT 1
42243: PUSH
42244: EMPTY
42245: LIST
42246: LIST
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: LIST
42252: PPUSH
42253: CALL_OW 72
42257: IFFALSE 42267
// pos := 2 ;
42259: LD_ADDR_VAR 0 6
42263: PUSH
42264: LD_INT 2
42266: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
42267: LD_ADDR_VAR 0 7
42271: PUSH
42272: LD_VAR 0 7
42276: PPUSH
42277: LD_VAR 0 6
42281: PPUSH
42282: LD_VAR 0 7
42286: PPUSH
42287: CALL 51199 0 3
42291: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
42292: LD_ADDR_EXP 55
42296: PUSH
42297: LD_EXP 55
42301: PPUSH
42302: LD_VAR 0 3
42306: PPUSH
42307: LD_VAR 0 7
42311: PPUSH
42312: CALL_OW 1
42316: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
42317: LD_VAR 0 1
42321: PUSH
42322: LD_EXP 50
42326: PUSH
42327: LD_VAR 0 3
42331: ARRAY
42332: IN
42333: IFFALSE 42372
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
42335: LD_ADDR_EXP 50
42339: PUSH
42340: LD_EXP 50
42344: PPUSH
42345: LD_VAR 0 3
42349: PPUSH
42350: LD_EXP 50
42354: PUSH
42355: LD_VAR 0 3
42359: ARRAY
42360: PUSH
42361: LD_VAR 0 1
42365: DIFF
42366: PPUSH
42367: CALL_OW 1
42371: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
42372: LD_VAR 0 1
42376: PUSH
42377: LD_EXP 57
42381: PUSH
42382: LD_VAR 0 3
42386: ARRAY
42387: IN
42388: IFFALSE 42427
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
42390: LD_ADDR_EXP 57
42394: PUSH
42395: LD_EXP 57
42399: PPUSH
42400: LD_VAR 0 3
42404: PPUSH
42405: LD_EXP 57
42409: PUSH
42410: LD_VAR 0 3
42414: ARRAY
42415: PUSH
42416: LD_VAR 0 1
42420: DIFF
42421: PPUSH
42422: CALL_OW 1
42426: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
42427: LD_VAR 0 1
42431: PUSH
42432: LD_EXP 69
42436: PUSH
42437: LD_VAR 0 3
42441: ARRAY
42442: IN
42443: IFFALSE 42482
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
42445: LD_ADDR_EXP 69
42449: PUSH
42450: LD_EXP 69
42454: PPUSH
42455: LD_VAR 0 3
42459: PPUSH
42460: LD_EXP 69
42464: PUSH
42465: LD_VAR 0 3
42469: ARRAY
42470: PUSH
42471: LD_VAR 0 1
42475: DIFF
42476: PPUSH
42477: CALL_OW 1
42481: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
42482: LD_VAR 0 1
42486: PUSH
42487: LD_EXP 59
42491: PUSH
42492: LD_VAR 0 3
42496: ARRAY
42497: IN
42498: IFFALSE 42537
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
42500: LD_ADDR_EXP 59
42504: PUSH
42505: LD_EXP 59
42509: PPUSH
42510: LD_VAR 0 3
42514: PPUSH
42515: LD_EXP 59
42519: PUSH
42520: LD_VAR 0 3
42524: ARRAY
42525: PUSH
42526: LD_VAR 0 1
42530: DIFF
42531: PPUSH
42532: CALL_OW 1
42536: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
42537: LD_VAR 0 1
42541: PUSH
42542: LD_EXP 58
42546: PUSH
42547: LD_VAR 0 3
42551: ARRAY
42552: IN
42553: IFFALSE 42592
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
42555: LD_ADDR_EXP 58
42559: PUSH
42560: LD_EXP 58
42564: PPUSH
42565: LD_VAR 0 3
42569: PPUSH
42570: LD_EXP 58
42574: PUSH
42575: LD_VAR 0 3
42579: ARRAY
42580: PUSH
42581: LD_VAR 0 1
42585: DIFF
42586: PPUSH
42587: CALL_OW 1
42591: ST_TO_ADDR
// end ; break ;
42592: GO 42596
// end ;
42594: GO 41670
42596: POP
42597: POP
// end ;
42598: LD_VAR 0 2
42602: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
42603: LD_INT 0
42605: PPUSH
42606: PPUSH
42607: PPUSH
// if not mc_bases then
42608: LD_EXP 50
42612: NOT
42613: IFFALSE 42617
// exit ;
42615: GO 42832
// for i = 1 to mc_bases do
42617: LD_ADDR_VAR 0 3
42621: PUSH
42622: DOUBLE
42623: LD_INT 1
42625: DEC
42626: ST_TO_ADDR
42627: LD_EXP 50
42631: PUSH
42632: FOR_TO
42633: IFFALSE 42830
// begin if building in mc_construct_list [ i ] then
42635: LD_VAR 0 1
42639: PUSH
42640: LD_EXP 57
42644: PUSH
42645: LD_VAR 0 3
42649: ARRAY
42650: IN
42651: IFFALSE 42828
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
42653: LD_ADDR_EXP 57
42657: PUSH
42658: LD_EXP 57
42662: PPUSH
42663: LD_VAR 0 3
42667: PPUSH
42668: LD_EXP 57
42672: PUSH
42673: LD_VAR 0 3
42677: ARRAY
42678: PUSH
42679: LD_VAR 0 1
42683: DIFF
42684: PPUSH
42685: CALL_OW 1
42689: ST_TO_ADDR
// if building in mc_lab [ i ] then
42690: LD_VAR 0 1
42694: PUSH
42695: LD_EXP 83
42699: PUSH
42700: LD_VAR 0 3
42704: ARRAY
42705: IN
42706: IFFALSE 42761
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
42708: LD_ADDR_EXP 84
42712: PUSH
42713: LD_EXP 84
42717: PPUSH
42718: LD_VAR 0 3
42722: PPUSH
42723: LD_EXP 84
42727: PUSH
42728: LD_VAR 0 3
42732: ARRAY
42733: PPUSH
42734: LD_INT 1
42736: PPUSH
42737: LD_EXP 84
42741: PUSH
42742: LD_VAR 0 3
42746: ARRAY
42747: PPUSH
42748: LD_INT 0
42750: PPUSH
42751: CALL 50291 0 4
42755: PPUSH
42756: CALL_OW 1
42760: ST_TO_ADDR
// if not building in mc_bases [ i ] then
42761: LD_VAR 0 1
42765: PUSH
42766: LD_EXP 50
42770: PUSH
42771: LD_VAR 0 3
42775: ARRAY
42776: IN
42777: NOT
42778: IFFALSE 42824
// mc_bases := Add ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
42780: LD_ADDR_EXP 50
42784: PUSH
42785: LD_EXP 50
42789: PPUSH
42790: LD_VAR 0 3
42794: PUSH
42795: LD_EXP 50
42799: PUSH
42800: LD_VAR 0 3
42804: ARRAY
42805: PUSH
42806: LD_INT 1
42808: PLUS
42809: PUSH
42810: EMPTY
42811: LIST
42812: LIST
42813: PPUSH
42814: LD_VAR 0 1
42818: PPUSH
42819: CALL 51308 0 3
42823: ST_TO_ADDR
// exit ;
42824: POP
42825: POP
42826: GO 42832
// end ; end ;
42828: GO 42632
42830: POP
42831: POP
// end ;
42832: LD_VAR 0 2
42836: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
42837: LD_INT 0
42839: PPUSH
42840: PPUSH
42841: PPUSH
42842: PPUSH
42843: PPUSH
42844: PPUSH
42845: PPUSH
// if not mc_bases then
42846: LD_EXP 50
42850: NOT
42851: IFFALSE 42855
// exit ;
42853: GO 43516
// for i = 1 to mc_bases do
42855: LD_ADDR_VAR 0 3
42859: PUSH
42860: DOUBLE
42861: LD_INT 1
42863: DEC
42864: ST_TO_ADDR
42865: LD_EXP 50
42869: PUSH
42870: FOR_TO
42871: IFFALSE 43514
// begin if building in mc_construct_list [ i ] then
42873: LD_VAR 0 1
42877: PUSH
42878: LD_EXP 57
42882: PUSH
42883: LD_VAR 0 3
42887: ARRAY
42888: IN
42889: IFFALSE 43512
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
42891: LD_ADDR_EXP 57
42895: PUSH
42896: LD_EXP 57
42900: PPUSH
42901: LD_VAR 0 3
42905: PPUSH
42906: LD_EXP 57
42910: PUSH
42911: LD_VAR 0 3
42915: ARRAY
42916: PUSH
42917: LD_VAR 0 1
42921: DIFF
42922: PPUSH
42923: CALL_OW 1
42927: ST_TO_ADDR
// mc_bases := Add ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
42928: LD_ADDR_EXP 50
42932: PUSH
42933: LD_EXP 50
42937: PPUSH
42938: LD_VAR 0 3
42942: PUSH
42943: LD_EXP 50
42947: PUSH
42948: LD_VAR 0 3
42952: ARRAY
42953: PUSH
42954: LD_INT 1
42956: PLUS
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: PPUSH
42962: LD_VAR 0 1
42966: PPUSH
42967: CALL 51308 0 3
42971: ST_TO_ADDR
// btype := GetBType ( building ) ;
42972: LD_ADDR_VAR 0 5
42976: PUSH
42977: LD_VAR 0 1
42981: PPUSH
42982: CALL_OW 266
42986: ST_TO_ADDR
// side := GetSide ( building ) ;
42987: LD_ADDR_VAR 0 8
42991: PUSH
42992: LD_VAR 0 1
42996: PPUSH
42997: CALL_OW 255
43001: ST_TO_ADDR
// if btype = b_lab then
43002: LD_VAR 0 5
43006: PUSH
43007: LD_INT 6
43009: EQUAL
43010: IFFALSE 43060
// begin mc_lab := Add ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
43012: LD_ADDR_EXP 83
43016: PUSH
43017: LD_EXP 83
43021: PPUSH
43022: LD_VAR 0 3
43026: PUSH
43027: LD_EXP 83
43031: PUSH
43032: LD_VAR 0 3
43036: ARRAY
43037: PUSH
43038: LD_INT 1
43040: PLUS
43041: PUSH
43042: EMPTY
43043: LIST
43044: LIST
43045: PPUSH
43046: LD_VAR 0 1
43050: PPUSH
43051: CALL 51308 0 3
43055: ST_TO_ADDR
// exit ;
43056: POP
43057: POP
43058: GO 43516
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
43060: LD_VAR 0 5
43064: PUSH
43065: LD_INT 0
43067: PUSH
43068: LD_INT 2
43070: PUSH
43071: LD_INT 4
43073: PUSH
43074: EMPTY
43075: LIST
43076: LIST
43077: LIST
43078: IN
43079: IFFALSE 43203
// begin if btype = b_armoury then
43081: LD_VAR 0 5
43085: PUSH
43086: LD_INT 4
43088: EQUAL
43089: IFFALSE 43099
// btype := b_barracks ;
43091: LD_ADDR_VAR 0 5
43095: PUSH
43096: LD_INT 5
43098: ST_TO_ADDR
// if btype = b_depot then
43099: LD_VAR 0 5
43103: PUSH
43104: LD_INT 0
43106: EQUAL
43107: IFFALSE 43117
// btype := b_warehouse ;
43109: LD_ADDR_VAR 0 5
43113: PUSH
43114: LD_INT 1
43116: ST_TO_ADDR
// if btype = b_workshop then
43117: LD_VAR 0 5
43121: PUSH
43122: LD_INT 2
43124: EQUAL
43125: IFFALSE 43135
// btype := b_factory ;
43127: LD_ADDR_VAR 0 5
43131: PUSH
43132: LD_INT 3
43134: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
43135: LD_VAR 0 5
43139: PPUSH
43140: LD_VAR 0 8
43144: PPUSH
43145: CALL_OW 323
43149: PUSH
43150: LD_INT 1
43152: EQUAL
43153: IFFALSE 43199
// mc_build_upgrade := Add ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
43155: LD_ADDR_EXP 82
43159: PUSH
43160: LD_EXP 82
43164: PPUSH
43165: LD_VAR 0 3
43169: PUSH
43170: LD_EXP 82
43174: PUSH
43175: LD_VAR 0 3
43179: ARRAY
43180: PUSH
43181: LD_INT 1
43183: PLUS
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PPUSH
43189: LD_VAR 0 1
43193: PPUSH
43194: CALL 51308 0 3
43198: ST_TO_ADDR
// exit ;
43199: POP
43200: POP
43201: GO 43516
// end ; if btype in [ b_bunker , b_turret ] then
43203: LD_VAR 0 5
43207: PUSH
43208: LD_INT 32
43210: PUSH
43211: LD_INT 33
43213: PUSH
43214: EMPTY
43215: LIST
43216: LIST
43217: IN
43218: IFFALSE 43508
// begin mc_turret_list := Add ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
43220: LD_ADDR_EXP 58
43224: PUSH
43225: LD_EXP 58
43229: PPUSH
43230: LD_VAR 0 3
43234: PUSH
43235: LD_EXP 58
43239: PUSH
43240: LD_VAR 0 3
43244: ARRAY
43245: PUSH
43246: LD_INT 1
43248: PLUS
43249: PUSH
43250: EMPTY
43251: LIST
43252: LIST
43253: PPUSH
43254: LD_VAR 0 1
43258: PPUSH
43259: CALL 51308 0 3
43263: ST_TO_ADDR
// if btype = b_bunker then
43264: LD_VAR 0 5
43268: PUSH
43269: LD_INT 32
43271: EQUAL
43272: IFFALSE 43508
// begin mc_empty_turret_list := Add ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
43274: LD_ADDR_EXP 59
43278: PUSH
43279: LD_EXP 59
43283: PPUSH
43284: LD_VAR 0 3
43288: PUSH
43289: LD_EXP 59
43293: PUSH
43294: LD_VAR 0 3
43298: ARRAY
43299: PUSH
43300: LD_INT 1
43302: PLUS
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PPUSH
43308: LD_VAR 0 1
43312: PPUSH
43313: CALL 51308 0 3
43317: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
43318: LD_ADDR_VAR 0 6
43322: PUSH
43323: LD_EXP 50
43327: PUSH
43328: LD_VAR 0 3
43332: ARRAY
43333: PPUSH
43334: LD_INT 25
43336: PUSH
43337: LD_INT 1
43339: PUSH
43340: EMPTY
43341: LIST
43342: LIST
43343: PUSH
43344: LD_INT 3
43346: PUSH
43347: LD_INT 54
43349: PUSH
43350: EMPTY
43351: LIST
43352: PUSH
43353: EMPTY
43354: LIST
43355: LIST
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PPUSH
43361: CALL_OW 72
43365: ST_TO_ADDR
// if tmp then
43366: LD_VAR 0 6
43370: IFFALSE 43376
// exit ;
43372: POP
43373: POP
43374: GO 43516
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
43376: LD_ADDR_VAR 0 6
43380: PUSH
43381: LD_EXP 50
43385: PUSH
43386: LD_VAR 0 3
43390: ARRAY
43391: PPUSH
43392: LD_INT 2
43394: PUSH
43395: LD_INT 30
43397: PUSH
43398: LD_INT 4
43400: PUSH
43401: EMPTY
43402: LIST
43403: LIST
43404: PUSH
43405: LD_INT 30
43407: PUSH
43408: LD_INT 5
43410: PUSH
43411: EMPTY
43412: LIST
43413: LIST
43414: PUSH
43415: EMPTY
43416: LIST
43417: LIST
43418: LIST
43419: PPUSH
43420: CALL_OW 72
43424: ST_TO_ADDR
// if not tmp then
43425: LD_VAR 0 6
43429: NOT
43430: IFFALSE 43436
// exit ;
43432: POP
43433: POP
43434: GO 43516
// for j in tmp do
43436: LD_ADDR_VAR 0 4
43440: PUSH
43441: LD_VAR 0 6
43445: PUSH
43446: FOR_IN
43447: IFFALSE 43506
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
43449: LD_ADDR_VAR 0 7
43453: PUSH
43454: LD_VAR 0 4
43458: PPUSH
43459: CALL_OW 313
43463: PPUSH
43464: LD_INT 25
43466: PUSH
43467: LD_INT 1
43469: PUSH
43470: EMPTY
43471: LIST
43472: LIST
43473: PPUSH
43474: CALL_OW 72
43478: ST_TO_ADDR
// if units then
43479: LD_VAR 0 7
43483: IFFALSE 43504
// begin ComExitBuilding ( units [ 1 ] ) ;
43485: LD_VAR 0 7
43489: PUSH
43490: LD_INT 1
43492: ARRAY
43493: PPUSH
43494: CALL_OW 122
// exit ;
43498: POP
43499: POP
43500: POP
43501: POP
43502: GO 43516
// end ; end ;
43504: GO 43446
43506: POP
43507: POP
// end ; end ; exit ;
43508: POP
43509: POP
43510: GO 43516
// end ; end ;
43512: GO 42870
43514: POP
43515: POP
// end ;
43516: LD_VAR 0 2
43520: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
43521: LD_INT 0
43523: PPUSH
43524: PPUSH
43525: PPUSH
43526: PPUSH
43527: PPUSH
43528: PPUSH
43529: PPUSH
// if not mc_bases then
43530: LD_EXP 50
43534: NOT
43535: IFFALSE 43539
// exit ;
43537: GO 43770
// btype := GetBType ( building ) ;
43539: LD_ADDR_VAR 0 6
43543: PUSH
43544: LD_VAR 0 1
43548: PPUSH
43549: CALL_OW 266
43553: ST_TO_ADDR
// x := GetX ( building ) ;
43554: LD_ADDR_VAR 0 7
43558: PUSH
43559: LD_VAR 0 1
43563: PPUSH
43564: CALL_OW 250
43568: ST_TO_ADDR
// y := GetY ( building ) ;
43569: LD_ADDR_VAR 0 8
43573: PUSH
43574: LD_VAR 0 1
43578: PPUSH
43579: CALL_OW 251
43583: ST_TO_ADDR
// d := GetDir ( building ) ;
43584: LD_ADDR_VAR 0 9
43588: PUSH
43589: LD_VAR 0 1
43593: PPUSH
43594: CALL_OW 254
43598: ST_TO_ADDR
// for i = 1 to mc_bases do
43599: LD_ADDR_VAR 0 4
43603: PUSH
43604: DOUBLE
43605: LD_INT 1
43607: DEC
43608: ST_TO_ADDR
43609: LD_EXP 50
43613: PUSH
43614: FOR_TO
43615: IFFALSE 43768
// begin if not mc_build_list [ i ] then
43617: LD_EXP 55
43621: PUSH
43622: LD_VAR 0 4
43626: ARRAY
43627: NOT
43628: IFFALSE 43632
// continue ;
43630: GO 43614
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
43632: LD_VAR 0 6
43636: PUSH
43637: LD_VAR 0 7
43641: PUSH
43642: LD_VAR 0 8
43646: PUSH
43647: LD_VAR 0 9
43651: PUSH
43652: EMPTY
43653: LIST
43654: LIST
43655: LIST
43656: LIST
43657: PPUSH
43658: LD_EXP 55
43662: PUSH
43663: LD_VAR 0 4
43667: ARRAY
43668: PUSH
43669: LD_INT 1
43671: ARRAY
43672: PPUSH
43673: CALL 56973 0 2
43677: IFFALSE 43766
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
43679: LD_ADDR_EXP 55
43683: PUSH
43684: LD_EXP 55
43688: PPUSH
43689: LD_VAR 0 4
43693: PPUSH
43694: LD_EXP 55
43698: PUSH
43699: LD_VAR 0 4
43703: ARRAY
43704: PPUSH
43705: LD_INT 1
43707: PPUSH
43708: CALL_OW 3
43712: PPUSH
43713: CALL_OW 1
43717: ST_TO_ADDR
// mc_construct_list := Add ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
43718: LD_ADDR_EXP 57
43722: PUSH
43723: LD_EXP 57
43727: PPUSH
43728: LD_VAR 0 4
43732: PUSH
43733: LD_EXP 57
43737: PUSH
43738: LD_VAR 0 4
43742: ARRAY
43743: PUSH
43744: LD_INT 1
43746: PLUS
43747: PUSH
43748: EMPTY
43749: LIST
43750: LIST
43751: PPUSH
43752: LD_VAR 0 1
43756: PPUSH
43757: CALL 51308 0 3
43761: ST_TO_ADDR
// exit ;
43762: POP
43763: POP
43764: GO 43770
// end ; end ;
43766: GO 43614
43768: POP
43769: POP
// end ;
43770: LD_VAR 0 3
43774: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
43775: LD_INT 0
43777: PPUSH
43778: PPUSH
43779: PPUSH
// if not mc_bases then
43780: LD_EXP 50
43784: NOT
43785: IFFALSE 43789
// exit ;
43787: GO 43979
// for i = 1 to mc_bases do
43789: LD_ADDR_VAR 0 4
43793: PUSH
43794: DOUBLE
43795: LD_INT 1
43797: DEC
43798: ST_TO_ADDR
43799: LD_EXP 50
43803: PUSH
43804: FOR_TO
43805: IFFALSE 43892
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
43807: LD_VAR 0 1
43811: PUSH
43812: LD_EXP 58
43816: PUSH
43817: LD_VAR 0 4
43821: ARRAY
43822: IN
43823: PUSH
43824: LD_VAR 0 1
43828: PUSH
43829: LD_EXP 59
43833: PUSH
43834: LD_VAR 0 4
43838: ARRAY
43839: IN
43840: NOT
43841: AND
43842: IFFALSE 43890
// begin mc_empty_turret_list := Add ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
43844: LD_ADDR_EXP 59
43848: PUSH
43849: LD_EXP 59
43853: PPUSH
43854: LD_VAR 0 4
43858: PUSH
43859: LD_EXP 59
43863: PUSH
43864: LD_VAR 0 4
43868: ARRAY
43869: PUSH
43870: LD_INT 1
43872: PLUS
43873: PUSH
43874: EMPTY
43875: LIST
43876: LIST
43877: PPUSH
43878: LD_VAR 0 1
43882: PPUSH
43883: CALL 51308 0 3
43887: ST_TO_ADDR
// break ;
43888: GO 43892
// end ; end ;
43890: GO 43804
43892: POP
43893: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
43894: LD_VAR 0 1
43898: PPUSH
43899: CALL_OW 257
43903: PUSH
43904: LD_EXP 76
43908: IN
43909: PUSH
43910: LD_VAR 0 1
43914: PPUSH
43915: CALL_OW 266
43919: PUSH
43920: LD_INT 5
43922: EQUAL
43923: AND
43924: PUSH
43925: LD_VAR 0 2
43929: PPUSH
43930: CALL_OW 110
43934: PUSH
43935: LD_INT 18
43937: NONEQUAL
43938: AND
43939: IFFALSE 43979
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
43941: LD_VAR 0 2
43945: PPUSH
43946: CALL_OW 257
43950: PUSH
43951: LD_INT 5
43953: PUSH
43954: LD_INT 8
43956: PUSH
43957: LD_INT 9
43959: PUSH
43960: EMPTY
43961: LIST
43962: LIST
43963: LIST
43964: IN
43965: IFFALSE 43979
// SetClass ( unit , 1 ) ;
43967: LD_VAR 0 2
43971: PPUSH
43972: LD_INT 1
43974: PPUSH
43975: CALL_OW 336
// end ;
43979: LD_VAR 0 3
43983: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
43984: LD_INT 0
43986: PPUSH
43987: PPUSH
// if not mc_bases then
43988: LD_EXP 50
43992: NOT
43993: IFFALSE 43997
// exit ;
43995: GO 44113
// if GetLives ( abandoned_vehicle ) > 250 then
43997: LD_VAR 0 2
44001: PPUSH
44002: CALL_OW 256
44006: PUSH
44007: LD_INT 250
44009: GREATER
44010: IFFALSE 44014
// exit ;
44012: GO 44113
// for i = 1 to mc_bases do
44014: LD_ADDR_VAR 0 6
44018: PUSH
44019: DOUBLE
44020: LD_INT 1
44022: DEC
44023: ST_TO_ADDR
44024: LD_EXP 50
44028: PUSH
44029: FOR_TO
44030: IFFALSE 44111
// begin if driver in mc_bases [ i ] then
44032: LD_VAR 0 1
44036: PUSH
44037: LD_EXP 50
44041: PUSH
44042: LD_VAR 0 6
44046: ARRAY
44047: IN
44048: IFFALSE 44109
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
44050: LD_VAR 0 1
44054: PPUSH
44055: LD_EXP 50
44059: PUSH
44060: LD_VAR 0 6
44064: ARRAY
44065: PPUSH
44066: LD_INT 2
44068: PUSH
44069: LD_INT 30
44071: PUSH
44072: LD_INT 0
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: PUSH
44079: LD_INT 30
44081: PUSH
44082: LD_INT 1
44084: PUSH
44085: EMPTY
44086: LIST
44087: LIST
44088: PUSH
44089: EMPTY
44090: LIST
44091: LIST
44092: LIST
44093: PPUSH
44094: CALL_OW 72
44098: PUSH
44099: LD_INT 1
44101: ARRAY
44102: PPUSH
44103: CALL_OW 112
// break ;
44107: GO 44111
// end ; end ;
44109: GO 44029
44111: POP
44112: POP
// end ; end_of_file
44113: LD_VAR 0 5
44117: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
44118: LD_INT 0
44120: PPUSH
44121: PPUSH
// if exist_mode then
44122: LD_VAR 0 2
44126: IFFALSE 44151
// unit := CreateCharacter ( prefix & ident ) else
44128: LD_ADDR_VAR 0 5
44132: PUSH
44133: LD_VAR 0 3
44137: PUSH
44138: LD_VAR 0 1
44142: STR
44143: PPUSH
44144: CALL_OW 34
44148: ST_TO_ADDR
44149: GO 44166
// unit := NewCharacter ( ident ) ;
44151: LD_ADDR_VAR 0 5
44155: PUSH
44156: LD_VAR 0 1
44160: PPUSH
44161: CALL_OW 25
44165: ST_TO_ADDR
// result := unit ;
44166: LD_ADDR_VAR 0 4
44170: PUSH
44171: LD_VAR 0 5
44175: ST_TO_ADDR
// end ;
44176: LD_VAR 0 4
44180: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
44181: LD_INT 0
44183: PPUSH
44184: PPUSH
// if not side or not nation then
44185: LD_VAR 0 1
44189: NOT
44190: PUSH
44191: LD_VAR 0 2
44195: NOT
44196: OR
44197: IFFALSE 44201
// exit ;
44199: GO 44837
// case nation of nation_american :
44201: LD_VAR 0 2
44205: PUSH
44206: LD_INT 1
44208: DOUBLE
44209: EQUAL
44210: IFTRUE 44214
44212: GO 44384
44214: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
44215: LD_ADDR_VAR 0 4
44219: PUSH
44220: LD_INT 35
44222: PUSH
44223: LD_INT 45
44225: PUSH
44226: LD_INT 46
44228: PUSH
44229: LD_INT 47
44231: PUSH
44232: LD_INT 1
44234: PUSH
44235: LD_INT 2
44237: PUSH
44238: LD_INT 6
44240: PUSH
44241: LD_INT 15
44243: PUSH
44244: LD_INT 16
44246: PUSH
44247: LD_INT 7
44249: PUSH
44250: LD_INT 12
44252: PUSH
44253: LD_INT 13
44255: PUSH
44256: LD_INT 10
44258: PUSH
44259: LD_INT 14
44261: PUSH
44262: LD_INT 20
44264: PUSH
44265: LD_INT 21
44267: PUSH
44268: LD_INT 22
44270: PUSH
44271: LD_INT 25
44273: PUSH
44274: LD_INT 32
44276: PUSH
44277: LD_INT 27
44279: PUSH
44280: LD_INT 36
44282: PUSH
44283: LD_INT 69
44285: PUSH
44286: LD_INT 39
44288: PUSH
44289: LD_INT 34
44291: PUSH
44292: LD_INT 40
44294: PUSH
44295: LD_INT 48
44297: PUSH
44298: LD_INT 49
44300: PUSH
44301: LD_INT 50
44303: PUSH
44304: LD_INT 51
44306: PUSH
44307: LD_INT 52
44309: PUSH
44310: LD_INT 53
44312: PUSH
44313: LD_INT 54
44315: PUSH
44316: LD_INT 55
44318: PUSH
44319: LD_INT 56
44321: PUSH
44322: LD_INT 57
44324: PUSH
44325: LD_INT 58
44327: PUSH
44328: LD_INT 59
44330: PUSH
44331: LD_INT 60
44333: PUSH
44334: LD_INT 61
44336: PUSH
44337: LD_INT 62
44339: PUSH
44340: EMPTY
44341: LIST
44342: LIST
44343: LIST
44344: LIST
44345: LIST
44346: LIST
44347: LIST
44348: LIST
44349: LIST
44350: LIST
44351: LIST
44352: LIST
44353: LIST
44354: LIST
44355: LIST
44356: LIST
44357: LIST
44358: LIST
44359: LIST
44360: LIST
44361: LIST
44362: LIST
44363: LIST
44364: LIST
44365: LIST
44366: LIST
44367: LIST
44368: LIST
44369: LIST
44370: LIST
44371: LIST
44372: LIST
44373: LIST
44374: LIST
44375: LIST
44376: LIST
44377: LIST
44378: LIST
44379: LIST
44380: LIST
44381: ST_TO_ADDR
44382: GO 44761
44384: LD_INT 2
44386: DOUBLE
44387: EQUAL
44388: IFTRUE 44392
44390: GO 44570
44392: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
44393: LD_ADDR_VAR 0 4
44397: PUSH
44398: LD_INT 35
44400: PUSH
44401: LD_INT 45
44403: PUSH
44404: LD_INT 46
44406: PUSH
44407: LD_INT 47
44409: PUSH
44410: LD_INT 70
44412: PUSH
44413: LD_INT 1
44415: PUSH
44416: LD_INT 11
44418: PUSH
44419: LD_INT 3
44421: PUSH
44422: LD_INT 4
44424: PUSH
44425: LD_INT 5
44427: PUSH
44428: LD_INT 6
44430: PUSH
44431: LD_INT 15
44433: PUSH
44434: LD_INT 18
44436: PUSH
44437: LD_INT 7
44439: PUSH
44440: LD_INT 17
44442: PUSH
44443: LD_INT 8
44445: PUSH
44446: LD_INT 20
44448: PUSH
44449: LD_INT 21
44451: PUSH
44452: LD_INT 22
44454: PUSH
44455: LD_INT 72
44457: PUSH
44458: LD_INT 26
44460: PUSH
44461: LD_INT 69
44463: PUSH
44464: LD_INT 39
44466: PUSH
44467: LD_INT 40
44469: PUSH
44470: LD_INT 41
44472: PUSH
44473: LD_INT 42
44475: PUSH
44476: LD_INT 43
44478: PUSH
44479: LD_INT 48
44481: PUSH
44482: LD_INT 49
44484: PUSH
44485: LD_INT 50
44487: PUSH
44488: LD_INT 51
44490: PUSH
44491: LD_INT 52
44493: PUSH
44494: LD_INT 53
44496: PUSH
44497: LD_INT 54
44499: PUSH
44500: LD_INT 55
44502: PUSH
44503: LD_INT 56
44505: PUSH
44506: LD_INT 60
44508: PUSH
44509: LD_INT 61
44511: PUSH
44512: LD_INT 62
44514: PUSH
44515: LD_INT 66
44517: PUSH
44518: LD_INT 67
44520: PUSH
44521: LD_INT 68
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: LIST
44528: LIST
44529: LIST
44530: LIST
44531: LIST
44532: LIST
44533: LIST
44534: LIST
44535: LIST
44536: LIST
44537: LIST
44538: LIST
44539: LIST
44540: LIST
44541: LIST
44542: LIST
44543: LIST
44544: LIST
44545: LIST
44546: LIST
44547: LIST
44548: LIST
44549: LIST
44550: LIST
44551: LIST
44552: LIST
44553: LIST
44554: LIST
44555: LIST
44556: LIST
44557: LIST
44558: LIST
44559: LIST
44560: LIST
44561: LIST
44562: LIST
44563: LIST
44564: LIST
44565: LIST
44566: LIST
44567: ST_TO_ADDR
44568: GO 44761
44570: LD_INT 3
44572: DOUBLE
44573: EQUAL
44574: IFTRUE 44578
44576: GO 44760
44578: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
44579: LD_ADDR_VAR 0 4
44583: PUSH
44584: LD_INT 46
44586: PUSH
44587: LD_INT 47
44589: PUSH
44590: LD_INT 1
44592: PUSH
44593: LD_INT 2
44595: PUSH
44596: LD_INT 11
44598: PUSH
44599: LD_INT 9
44601: PUSH
44602: LD_INT 20
44604: PUSH
44605: LD_INT 19
44607: PUSH
44608: LD_INT 21
44610: PUSH
44611: LD_INT 24
44613: PUSH
44614: LD_INT 22
44616: PUSH
44617: LD_INT 25
44619: PUSH
44620: LD_INT 28
44622: PUSH
44623: LD_INT 29
44625: PUSH
44626: LD_INT 30
44628: PUSH
44629: LD_INT 31
44631: PUSH
44632: LD_INT 37
44634: PUSH
44635: LD_INT 38
44637: PUSH
44638: LD_INT 32
44640: PUSH
44641: LD_INT 27
44643: PUSH
44644: LD_INT 33
44646: PUSH
44647: LD_INT 69
44649: PUSH
44650: LD_INT 39
44652: PUSH
44653: LD_INT 34
44655: PUSH
44656: LD_INT 40
44658: PUSH
44659: LD_INT 71
44661: PUSH
44662: LD_INT 23
44664: PUSH
44665: LD_INT 44
44667: PUSH
44668: LD_INT 48
44670: PUSH
44671: LD_INT 49
44673: PUSH
44674: LD_INT 50
44676: PUSH
44677: LD_INT 51
44679: PUSH
44680: LD_INT 52
44682: PUSH
44683: LD_INT 53
44685: PUSH
44686: LD_INT 54
44688: PUSH
44689: LD_INT 55
44691: PUSH
44692: LD_INT 56
44694: PUSH
44695: LD_INT 57
44697: PUSH
44698: LD_INT 58
44700: PUSH
44701: LD_INT 59
44703: PUSH
44704: LD_INT 63
44706: PUSH
44707: LD_INT 64
44709: PUSH
44710: LD_INT 65
44712: PUSH
44713: EMPTY
44714: LIST
44715: LIST
44716: LIST
44717: LIST
44718: LIST
44719: LIST
44720: LIST
44721: LIST
44722: LIST
44723: LIST
44724: LIST
44725: LIST
44726: LIST
44727: LIST
44728: LIST
44729: LIST
44730: LIST
44731: LIST
44732: LIST
44733: LIST
44734: LIST
44735: LIST
44736: LIST
44737: LIST
44738: LIST
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: LIST
44744: LIST
44745: LIST
44746: LIST
44747: LIST
44748: LIST
44749: LIST
44750: LIST
44751: LIST
44752: LIST
44753: LIST
44754: LIST
44755: LIST
44756: LIST
44757: ST_TO_ADDR
44758: GO 44761
44760: POP
// if state > - 1 and state < 3 then
44761: LD_VAR 0 3
44765: PUSH
44766: LD_INT 1
44768: NEG
44769: GREATER
44770: PUSH
44771: LD_VAR 0 3
44775: PUSH
44776: LD_INT 3
44778: LESS
44779: AND
44780: IFFALSE 44837
// for i in result do
44782: LD_ADDR_VAR 0 5
44786: PUSH
44787: LD_VAR 0 4
44791: PUSH
44792: FOR_IN
44793: IFFALSE 44835
// if GetTech ( i , side ) <> state then
44795: LD_VAR 0 5
44799: PPUSH
44800: LD_VAR 0 1
44804: PPUSH
44805: CALL_OW 321
44809: PUSH
44810: LD_VAR 0 3
44814: NONEQUAL
44815: IFFALSE 44833
// result := result diff i ;
44817: LD_ADDR_VAR 0 4
44821: PUSH
44822: LD_VAR 0 4
44826: PUSH
44827: LD_VAR 0 5
44831: DIFF
44832: ST_TO_ADDR
44833: GO 44792
44835: POP
44836: POP
// end ;
44837: LD_VAR 0 4
44841: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
44842: LD_INT 0
44844: PPUSH
44845: PPUSH
44846: PPUSH
// result := true ;
44847: LD_ADDR_VAR 0 3
44851: PUSH
44852: LD_INT 1
44854: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
44855: LD_ADDR_VAR 0 5
44859: PUSH
44860: LD_VAR 0 2
44864: PPUSH
44865: CALL_OW 480
44869: ST_TO_ADDR
// if not tmp then
44870: LD_VAR 0 5
44874: NOT
44875: IFFALSE 44879
// exit ;
44877: GO 44928
// for i in tmp do
44879: LD_ADDR_VAR 0 4
44883: PUSH
44884: LD_VAR 0 5
44888: PUSH
44889: FOR_IN
44890: IFFALSE 44926
// if GetTech ( i , side ) <> state_researched then
44892: LD_VAR 0 4
44896: PPUSH
44897: LD_VAR 0 1
44901: PPUSH
44902: CALL_OW 321
44906: PUSH
44907: LD_INT 2
44909: NONEQUAL
44910: IFFALSE 44924
// begin result := false ;
44912: LD_ADDR_VAR 0 3
44916: PUSH
44917: LD_INT 0
44919: ST_TO_ADDR
// exit ;
44920: POP
44921: POP
44922: GO 44928
// end ;
44924: GO 44889
44926: POP
44927: POP
// end ;
44928: LD_VAR 0 3
44932: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
44933: LD_INT 0
44935: PPUSH
44936: PPUSH
44937: PPUSH
44938: PPUSH
44939: PPUSH
44940: PPUSH
44941: PPUSH
44942: PPUSH
44943: PPUSH
44944: PPUSH
44945: PPUSH
44946: PPUSH
44947: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
44948: LD_VAR 0 1
44952: NOT
44953: PUSH
44954: LD_VAR 0 1
44958: PPUSH
44959: CALL_OW 257
44963: PUSH
44964: LD_INT 9
44966: NONEQUAL
44967: OR
44968: IFFALSE 44972
// exit ;
44970: GO 45545
// side := GetSide ( unit ) ;
44972: LD_ADDR_VAR 0 9
44976: PUSH
44977: LD_VAR 0 1
44981: PPUSH
44982: CALL_OW 255
44986: ST_TO_ADDR
// tech_space := tech_spacanom ;
44987: LD_ADDR_VAR 0 12
44991: PUSH
44992: LD_INT 29
44994: ST_TO_ADDR
// tech_time := tech_taurad ;
44995: LD_ADDR_VAR 0 13
44999: PUSH
45000: LD_INT 28
45002: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
45003: LD_ADDR_VAR 0 11
45007: PUSH
45008: LD_VAR 0 1
45012: PPUSH
45013: CALL_OW 310
45017: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
45018: LD_VAR 0 11
45022: PPUSH
45023: CALL_OW 247
45027: PUSH
45028: LD_INT 2
45030: EQUAL
45031: IFFALSE 45035
// exit ;
45033: GO 45545
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
45035: LD_ADDR_VAR 0 8
45039: PUSH
45040: LD_INT 81
45042: PUSH
45043: LD_VAR 0 9
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: PUSH
45052: LD_INT 3
45054: PUSH
45055: LD_INT 21
45057: PUSH
45058: LD_INT 3
45060: PUSH
45061: EMPTY
45062: LIST
45063: LIST
45064: PUSH
45065: EMPTY
45066: LIST
45067: LIST
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: PPUSH
45073: CALL_OW 69
45077: ST_TO_ADDR
// if not tmp then
45078: LD_VAR 0 8
45082: NOT
45083: IFFALSE 45087
// exit ;
45085: GO 45545
// if in_unit then
45087: LD_VAR 0 11
45091: IFFALSE 45115
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
45093: LD_ADDR_VAR 0 10
45097: PUSH
45098: LD_VAR 0 8
45102: PPUSH
45103: LD_VAR 0 11
45107: PPUSH
45108: CALL_OW 74
45112: ST_TO_ADDR
45113: GO 45135
// enemy := NearestUnitToUnit ( tmp , unit ) ;
45115: LD_ADDR_VAR 0 10
45119: PUSH
45120: LD_VAR 0 8
45124: PPUSH
45125: LD_VAR 0 1
45129: PPUSH
45130: CALL_OW 74
45134: ST_TO_ADDR
// if not enemy then
45135: LD_VAR 0 10
45139: NOT
45140: IFFALSE 45144
// exit ;
45142: GO 45545
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
45144: LD_VAR 0 11
45148: PUSH
45149: LD_VAR 0 11
45153: PPUSH
45154: LD_VAR 0 10
45158: PPUSH
45159: CALL_OW 296
45163: PUSH
45164: LD_INT 13
45166: GREATER
45167: AND
45168: PUSH
45169: LD_VAR 0 1
45173: PPUSH
45174: LD_VAR 0 10
45178: PPUSH
45179: CALL_OW 296
45183: PUSH
45184: LD_INT 12
45186: GREATER
45187: OR
45188: IFFALSE 45192
// exit ;
45190: GO 45545
// missile := [ 1 ] ;
45192: LD_ADDR_VAR 0 14
45196: PUSH
45197: LD_INT 1
45199: PUSH
45200: EMPTY
45201: LIST
45202: ST_TO_ADDR
// if Researched ( side , tech_space ) then
45203: LD_VAR 0 9
45207: PPUSH
45208: LD_VAR 0 12
45212: PPUSH
45213: CALL_OW 325
45217: IFFALSE 45246
// missile := Insert ( missile , missile + 1 , 2 ) ;
45219: LD_ADDR_VAR 0 14
45223: PUSH
45224: LD_VAR 0 14
45228: PPUSH
45229: LD_VAR 0 14
45233: PUSH
45234: LD_INT 1
45236: PLUS
45237: PPUSH
45238: LD_INT 2
45240: PPUSH
45241: CALL_OW 2
45245: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
45246: LD_VAR 0 9
45250: PPUSH
45251: LD_VAR 0 13
45255: PPUSH
45256: CALL_OW 325
45260: PUSH
45261: LD_VAR 0 10
45265: PPUSH
45266: CALL_OW 255
45270: PPUSH
45271: LD_VAR 0 13
45275: PPUSH
45276: CALL_OW 325
45280: NOT
45281: AND
45282: IFFALSE 45311
// missile := Insert ( missile , missile + 1 , 3 ) ;
45284: LD_ADDR_VAR 0 14
45288: PUSH
45289: LD_VAR 0 14
45293: PPUSH
45294: LD_VAR 0 14
45298: PUSH
45299: LD_INT 1
45301: PLUS
45302: PPUSH
45303: LD_INT 3
45305: PPUSH
45306: CALL_OW 2
45310: ST_TO_ADDR
// if missile < 2 then
45311: LD_VAR 0 14
45315: PUSH
45316: LD_INT 2
45318: LESS
45319: IFFALSE 45323
// exit ;
45321: GO 45545
// x := GetX ( enemy ) ;
45323: LD_ADDR_VAR 0 4
45327: PUSH
45328: LD_VAR 0 10
45332: PPUSH
45333: CALL_OW 250
45337: ST_TO_ADDR
// y := GetY ( enemy ) ;
45338: LD_ADDR_VAR 0 5
45342: PUSH
45343: LD_VAR 0 10
45347: PPUSH
45348: CALL_OW 251
45352: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
45353: LD_ADDR_VAR 0 6
45357: PUSH
45358: LD_VAR 0 4
45362: PUSH
45363: LD_INT 1
45365: NEG
45366: PPUSH
45367: LD_INT 1
45369: PPUSH
45370: CALL_OW 12
45374: PLUS
45375: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
45376: LD_ADDR_VAR 0 7
45380: PUSH
45381: LD_VAR 0 5
45385: PUSH
45386: LD_INT 1
45388: NEG
45389: PPUSH
45390: LD_INT 1
45392: PPUSH
45393: CALL_OW 12
45397: PLUS
45398: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
45399: LD_VAR 0 6
45403: PPUSH
45404: LD_VAR 0 7
45408: PPUSH
45409: CALL_OW 488
45413: NOT
45414: IFFALSE 45436
// begin _x := x ;
45416: LD_ADDR_VAR 0 6
45420: PUSH
45421: LD_VAR 0 4
45425: ST_TO_ADDR
// _y := y ;
45426: LD_ADDR_VAR 0 7
45430: PUSH
45431: LD_VAR 0 5
45435: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
45436: LD_ADDR_VAR 0 3
45440: PUSH
45441: LD_INT 1
45443: PPUSH
45444: LD_VAR 0 14
45448: PPUSH
45449: CALL_OW 12
45453: ST_TO_ADDR
// case i of 1 :
45454: LD_VAR 0 3
45458: PUSH
45459: LD_INT 1
45461: DOUBLE
45462: EQUAL
45463: IFTRUE 45467
45465: GO 45484
45467: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
45468: LD_VAR 0 1
45472: PPUSH
45473: LD_VAR 0 10
45477: PPUSH
45478: CALL_OW 115
45482: GO 45545
45484: LD_INT 2
45486: DOUBLE
45487: EQUAL
45488: IFTRUE 45492
45490: GO 45514
45492: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
45493: LD_VAR 0 1
45497: PPUSH
45498: LD_VAR 0 6
45502: PPUSH
45503: LD_VAR 0 7
45507: PPUSH
45508: CALL_OW 153
45512: GO 45545
45514: LD_INT 3
45516: DOUBLE
45517: EQUAL
45518: IFTRUE 45522
45520: GO 45544
45522: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
45523: LD_VAR 0 1
45527: PPUSH
45528: LD_VAR 0 6
45532: PPUSH
45533: LD_VAR 0 7
45537: PPUSH
45538: CALL_OW 154
45542: GO 45545
45544: POP
// end ;
45545: LD_VAR 0 2
45549: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
45550: LD_INT 0
45552: PPUSH
45553: PPUSH
45554: PPUSH
45555: PPUSH
45556: PPUSH
45557: PPUSH
// if not unit or not building then
45558: LD_VAR 0 1
45562: NOT
45563: PUSH
45564: LD_VAR 0 2
45568: NOT
45569: OR
45570: IFFALSE 45574
// exit ;
45572: GO 45732
// x := GetX ( building ) ;
45574: LD_ADDR_VAR 0 5
45578: PUSH
45579: LD_VAR 0 2
45583: PPUSH
45584: CALL_OW 250
45588: ST_TO_ADDR
// y := GetY ( building ) ;
45589: LD_ADDR_VAR 0 6
45593: PUSH
45594: LD_VAR 0 2
45598: PPUSH
45599: CALL_OW 251
45603: ST_TO_ADDR
// for i = 0 to 5 do
45604: LD_ADDR_VAR 0 4
45608: PUSH
45609: DOUBLE
45610: LD_INT 0
45612: DEC
45613: ST_TO_ADDR
45614: LD_INT 5
45616: PUSH
45617: FOR_TO
45618: IFFALSE 45730
// begin _x := ShiftX ( x , i , 3 ) ;
45620: LD_ADDR_VAR 0 7
45624: PUSH
45625: LD_VAR 0 5
45629: PPUSH
45630: LD_VAR 0 4
45634: PPUSH
45635: LD_INT 3
45637: PPUSH
45638: CALL_OW 272
45642: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
45643: LD_ADDR_VAR 0 8
45647: PUSH
45648: LD_VAR 0 6
45652: PPUSH
45653: LD_VAR 0 4
45657: PPUSH
45658: LD_INT 3
45660: PPUSH
45661: CALL_OW 273
45665: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
45666: LD_VAR 0 7
45670: PPUSH
45671: LD_VAR 0 8
45675: PPUSH
45676: CALL_OW 488
45680: NOT
45681: IFFALSE 45685
// continue ;
45683: GO 45617
// if HexInfo ( _x , _y ) = 0 then
45685: LD_VAR 0 7
45689: PPUSH
45690: LD_VAR 0 8
45694: PPUSH
45695: CALL_OW 428
45699: PUSH
45700: LD_INT 0
45702: EQUAL
45703: IFFALSE 45728
// begin ComMoveXY ( unit , _x , _y ) ;
45705: LD_VAR 0 1
45709: PPUSH
45710: LD_VAR 0 7
45714: PPUSH
45715: LD_VAR 0 8
45719: PPUSH
45720: CALL_OW 111
// exit ;
45724: POP
45725: POP
45726: GO 45732
// end ; end ;
45728: GO 45617
45730: POP
45731: POP
// end ;
45732: LD_VAR 0 3
45736: RET
// export function ScanBase ( side , base_area ) ; begin
45737: LD_INT 0
45739: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
45740: LD_ADDR_VAR 0 3
45744: PUSH
45745: LD_VAR 0 2
45749: PPUSH
45750: LD_INT 81
45752: PUSH
45753: LD_VAR 0 1
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PPUSH
45762: CALL_OW 70
45766: ST_TO_ADDR
// end ;
45767: LD_VAR 0 3
45771: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
45772: LD_INT 0
45774: PPUSH
45775: PPUSH
45776: PPUSH
45777: PPUSH
45778: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
45779: LD_VAR 0 1
45783: NOT
45784: PUSH
45785: LD_EXP 50
45789: PUSH
45790: LD_VAR 0 1
45794: ARRAY
45795: NOT
45796: OR
45797: PUSH
45798: LD_VAR 0 2
45802: NOT
45803: OR
45804: PUSH
45805: LD_VAR 0 3
45809: NOT
45810: OR
45811: IFFALSE 45815
// exit ;
45813: GO 46265
// side := mc_sides [ base ] ;
45815: LD_ADDR_VAR 0 6
45819: PUSH
45820: LD_EXP 76
45824: PUSH
45825: LD_VAR 0 1
45829: ARRAY
45830: ST_TO_ADDR
// if not side then
45831: LD_VAR 0 6
45835: NOT
45836: IFFALSE 45840
// exit ;
45838: GO 46265
// for i in solds do
45840: LD_ADDR_VAR 0 7
45844: PUSH
45845: LD_VAR 0 2
45849: PUSH
45850: FOR_IN
45851: IFFALSE 45912
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
45853: LD_VAR 0 7
45857: PPUSH
45858: CALL_OW 310
45862: PPUSH
45863: CALL_OW 266
45867: PUSH
45868: LD_INT 32
45870: PUSH
45871: LD_INT 31
45873: PUSH
45874: EMPTY
45875: LIST
45876: LIST
45877: IN
45878: IFFALSE 45898
// solds := solds diff i else
45880: LD_ADDR_VAR 0 2
45884: PUSH
45885: LD_VAR 0 2
45889: PUSH
45890: LD_VAR 0 7
45894: DIFF
45895: ST_TO_ADDR
45896: GO 45910
// SetTag ( i , 18 ) ;
45898: LD_VAR 0 7
45902: PPUSH
45903: LD_INT 18
45905: PPUSH
45906: CALL_OW 109
45910: GO 45850
45912: POP
45913: POP
// if not solds then
45914: LD_VAR 0 2
45918: NOT
45919: IFFALSE 45923
// exit ;
45921: GO 46265
// repeat wait ( 0 0$1 ) ;
45923: LD_INT 35
45925: PPUSH
45926: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
45930: LD_ADDR_VAR 0 5
45934: PUSH
45935: LD_VAR 0 6
45939: PPUSH
45940: LD_VAR 0 3
45944: PPUSH
45945: CALL 45737 0 2
45949: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
45950: LD_VAR 0 5
45954: NOT
45955: PUSH
45956: LD_VAR 0 5
45960: PUSH
45961: LD_INT 3
45963: GREATER
45964: OR
45965: PUSH
45966: LD_EXP 72
45970: PUSH
45971: LD_VAR 0 1
45975: ARRAY
45976: OR
45977: IFFALSE 46018
// begin for i in solds do
45979: LD_ADDR_VAR 0 7
45983: PUSH
45984: LD_VAR 0 2
45988: PUSH
45989: FOR_IN
45990: IFFALSE 46014
// if HasTask ( i ) then
45992: LD_VAR 0 7
45996: PPUSH
45997: CALL_OW 314
46001: IFFALSE 46012
// ComStop ( i ) ;
46003: LD_VAR 0 7
46007: PPUSH
46008: CALL_OW 141
46012: GO 45989
46014: POP
46015: POP
// break ;
46016: GO 46253
// end ; for i in solds do
46018: LD_ADDR_VAR 0 7
46022: PUSH
46023: LD_VAR 0 2
46027: PUSH
46028: FOR_IN
46029: IFFALSE 46245
// begin if IsInUnit ( i ) then
46031: LD_VAR 0 7
46035: PPUSH
46036: CALL_OW 310
46040: IFFALSE 46051
// ComExitBuilding ( i ) ;
46042: LD_VAR 0 7
46046: PPUSH
46047: CALL_OW 122
// if GetLives ( i ) > 333 then
46051: LD_VAR 0 7
46055: PPUSH
46056: CALL_OW 256
46060: PUSH
46061: LD_INT 333
46063: GREATER
46064: IFFALSE 46092
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
46066: LD_VAR 0 7
46070: PPUSH
46071: LD_VAR 0 5
46075: PPUSH
46076: LD_VAR 0 7
46080: PPUSH
46081: CALL_OW 74
46085: PPUSH
46086: CALL_OW 115
46090: GO 46243
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
46092: LD_ADDR_VAR 0 8
46096: PUSH
46097: LD_EXP 50
46101: PUSH
46102: LD_VAR 0 1
46106: ARRAY
46107: PPUSH
46108: LD_INT 2
46110: PUSH
46111: LD_INT 30
46113: PUSH
46114: LD_INT 0
46116: PUSH
46117: EMPTY
46118: LIST
46119: LIST
46120: PUSH
46121: LD_INT 30
46123: PUSH
46124: LD_INT 1
46126: PUSH
46127: EMPTY
46128: LIST
46129: LIST
46130: PUSH
46131: LD_INT 30
46133: PUSH
46134: LD_INT 6
46136: PUSH
46137: EMPTY
46138: LIST
46139: LIST
46140: PUSH
46141: EMPTY
46142: LIST
46143: LIST
46144: LIST
46145: LIST
46146: PPUSH
46147: CALL_OW 72
46151: PPUSH
46152: LD_VAR 0 7
46156: PPUSH
46157: CALL_OW 74
46161: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
46162: LD_VAR 0 7
46166: PPUSH
46167: LD_VAR 0 8
46171: PPUSH
46172: CALL_OW 250
46176: PPUSH
46177: LD_INT 3
46179: PPUSH
46180: LD_INT 5
46182: PPUSH
46183: CALL_OW 272
46187: PPUSH
46188: LD_VAR 0 8
46192: PPUSH
46193: CALL_OW 251
46197: PPUSH
46198: LD_INT 3
46200: PPUSH
46201: LD_INT 5
46203: PPUSH
46204: CALL_OW 273
46208: PPUSH
46209: CALL_OW 111
// SetTag ( i , 0 ) ;
46213: LD_VAR 0 7
46217: PPUSH
46218: LD_INT 0
46220: PPUSH
46221: CALL_OW 109
// solds := solds diff i ;
46225: LD_ADDR_VAR 0 2
46229: PUSH
46230: LD_VAR 0 2
46234: PUSH
46235: LD_VAR 0 7
46239: DIFF
46240: ST_TO_ADDR
// continue ;
46241: GO 46028
// end ; end ;
46243: GO 46028
46245: POP
46246: POP
// until solds ;
46247: LD_VAR 0 2
46251: IFFALSE 45923
// MC_Reset ( base , 18 ) ;
46253: LD_VAR 0 1
46257: PPUSH
46258: LD_INT 18
46260: PPUSH
46261: CALL 19681 0 2
// end ;
46265: LD_VAR 0 4
46269: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
46270: LD_INT 0
46272: PPUSH
46273: PPUSH
46274: PPUSH
46275: PPUSH
46276: PPUSH
46277: PPUSH
46278: PPUSH
46279: PPUSH
46280: PPUSH
46281: PPUSH
46282: PPUSH
46283: PPUSH
46284: PPUSH
46285: PPUSH
46286: PPUSH
46287: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
46288: LD_ADDR_VAR 0 12
46292: PUSH
46293: LD_EXP 50
46297: PUSH
46298: LD_VAR 0 1
46302: ARRAY
46303: PPUSH
46304: LD_INT 25
46306: PUSH
46307: LD_INT 3
46309: PUSH
46310: EMPTY
46311: LIST
46312: LIST
46313: PPUSH
46314: CALL_OW 72
46318: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
46319: LD_ADDR_VAR 0 8
46323: PUSH
46324: LD_EXP 50
46328: PUSH
46329: LD_VAR 0 1
46333: ARRAY
46334: PPUSH
46335: LD_INT 2
46337: PUSH
46338: LD_INT 25
46340: PUSH
46341: LD_INT 1
46343: PUSH
46344: EMPTY
46345: LIST
46346: LIST
46347: PUSH
46348: LD_INT 25
46350: PUSH
46351: LD_INT 5
46353: PUSH
46354: EMPTY
46355: LIST
46356: LIST
46357: PUSH
46358: LD_INT 25
46360: PUSH
46361: LD_INT 8
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: PUSH
46368: LD_INT 25
46370: PUSH
46371: LD_INT 9
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: PUSH
46378: EMPTY
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: PPUSH
46385: CALL_OW 72
46389: ST_TO_ADDR
// if not defenders and not solds then
46390: LD_VAR 0 2
46394: NOT
46395: PUSH
46396: LD_VAR 0 8
46400: NOT
46401: AND
46402: IFFALSE 46406
// exit ;
46404: GO 47772
// depot_under_attack := false ;
46406: LD_ADDR_VAR 0 16
46410: PUSH
46411: LD_INT 0
46413: ST_TO_ADDR
// sold_defenders := [ ] ;
46414: LD_ADDR_VAR 0 17
46418: PUSH
46419: EMPTY
46420: ST_TO_ADDR
// if mechs then
46421: LD_VAR 0 12
46425: IFFALSE 46554
// for i in defenders do
46427: LD_ADDR_VAR 0 5
46431: PUSH
46432: LD_VAR 0 2
46436: PUSH
46437: FOR_IN
46438: IFFALSE 46552
// begin SetTag ( i , 20 ) ;
46440: LD_VAR 0 5
46444: PPUSH
46445: LD_INT 20
46447: PPUSH
46448: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
46452: LD_VAR 0 5
46456: PPUSH
46457: CALL_OW 263
46461: PUSH
46462: LD_INT 1
46464: EQUAL
46465: PUSH
46466: LD_VAR 0 5
46470: PPUSH
46471: CALL_OW 311
46475: NOT
46476: AND
46477: PUSH
46478: LD_VAR 0 12
46482: AND
46483: IFFALSE 46550
// begin un := mechs [ 1 ] ;
46485: LD_ADDR_VAR 0 10
46489: PUSH
46490: LD_VAR 0 12
46494: PUSH
46495: LD_INT 1
46497: ARRAY
46498: ST_TO_ADDR
// ComExitBuilding ( un ) ;
46499: LD_VAR 0 10
46503: PPUSH
46504: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
46508: LD_VAR 0 10
46512: PPUSH
46513: LD_VAR 0 5
46517: PPUSH
46518: CALL_OW 180
// SetTag ( un , 19 ) ;
46522: LD_VAR 0 10
46526: PPUSH
46527: LD_INT 19
46529: PPUSH
46530: CALL_OW 109
// mechs := mechs diff un ;
46534: LD_ADDR_VAR 0 12
46538: PUSH
46539: LD_VAR 0 12
46543: PUSH
46544: LD_VAR 0 10
46548: DIFF
46549: ST_TO_ADDR
// end ; end ;
46550: GO 46437
46552: POP
46553: POP
// if solds then
46554: LD_VAR 0 8
46558: IFFALSE 46617
// for i in solds do
46560: LD_ADDR_VAR 0 5
46564: PUSH
46565: LD_VAR 0 8
46569: PUSH
46570: FOR_IN
46571: IFFALSE 46615
// if not GetTag ( i ) then
46573: LD_VAR 0 5
46577: PPUSH
46578: CALL_OW 110
46582: NOT
46583: IFFALSE 46613
// begin defenders := defenders union i ;
46585: LD_ADDR_VAR 0 2
46589: PUSH
46590: LD_VAR 0 2
46594: PUSH
46595: LD_VAR 0 5
46599: UNION
46600: ST_TO_ADDR
// SetTag ( i , 18 ) ;
46601: LD_VAR 0 5
46605: PPUSH
46606: LD_INT 18
46608: PPUSH
46609: CALL_OW 109
// end ;
46613: GO 46570
46615: POP
46616: POP
// repeat wait ( 0 0$1 ) ;
46617: LD_INT 35
46619: PPUSH
46620: CALL_OW 67
// enemy := mc_scan [ base ] ;
46624: LD_ADDR_VAR 0 3
46628: PUSH
46629: LD_EXP 73
46633: PUSH
46634: LD_VAR 0 1
46638: ARRAY
46639: ST_TO_ADDR
// for i in defenders do
46640: LD_ADDR_VAR 0 5
46644: PUSH
46645: LD_VAR 0 2
46649: PUSH
46650: FOR_IN
46651: IFFALSE 47336
// begin e := NearestUnitToUnit ( enemy , i ) ;
46653: LD_ADDR_VAR 0 13
46657: PUSH
46658: LD_VAR 0 3
46662: PPUSH
46663: LD_VAR 0 5
46667: PPUSH
46668: CALL_OW 74
46672: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
46673: LD_ADDR_VAR 0 16
46677: PUSH
46678: LD_EXP 50
46682: PUSH
46683: LD_VAR 0 1
46687: ARRAY
46688: PPUSH
46689: LD_INT 2
46691: PUSH
46692: LD_INT 30
46694: PUSH
46695: LD_INT 0
46697: PUSH
46698: EMPTY
46699: LIST
46700: LIST
46701: PUSH
46702: LD_INT 30
46704: PUSH
46705: LD_INT 1
46707: PUSH
46708: EMPTY
46709: LIST
46710: LIST
46711: PUSH
46712: EMPTY
46713: LIST
46714: LIST
46715: LIST
46716: PPUSH
46717: CALL_OW 72
46721: NOT
46722: PUSH
46723: LD_EXP 50
46727: PUSH
46728: LD_VAR 0 1
46732: ARRAY
46733: PPUSH
46734: LD_INT 2
46736: PUSH
46737: LD_INT 30
46739: PUSH
46740: LD_INT 0
46742: PUSH
46743: EMPTY
46744: LIST
46745: LIST
46746: PUSH
46747: LD_INT 30
46749: PUSH
46750: LD_INT 1
46752: PUSH
46753: EMPTY
46754: LIST
46755: LIST
46756: PUSH
46757: EMPTY
46758: LIST
46759: LIST
46760: LIST
46761: PPUSH
46762: CALL_OW 72
46766: PPUSH
46767: CALL_OW 256
46771: PUSH
46772: LD_INT 600
46774: LESS
46775: OR
46776: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
46777: LD_VAR 0 5
46781: PPUSH
46782: CALL_OW 247
46786: PUSH
46787: LD_INT 2
46789: DOUBLE
46790: EQUAL
46791: IFTRUE 46795
46793: GO 47042
46795: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
46796: LD_VAR 0 5
46800: PPUSH
46801: CALL_OW 256
46805: PUSH
46806: LD_INT 650
46808: GREATER
46809: PUSH
46810: LD_VAR 0 5
46814: PPUSH
46815: LD_VAR 0 13
46819: PPUSH
46820: CALL_OW 296
46824: PUSH
46825: LD_INT 40
46827: LESS
46828: AND
46829: IFFALSE 46847
// ComAttackUnit ( i , e ) else
46831: LD_VAR 0 5
46835: PPUSH
46836: LD_VAR 0 13
46840: PPUSH
46841: CALL_OW 115
46845: GO 46925
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
46847: LD_VAR 0 5
46851: PPUSH
46852: LD_VAR 0 13
46856: PPUSH
46857: CALL_OW 296
46861: PUSH
46862: LD_INT 30
46864: GREATEREQUAL
46865: PUSH
46866: LD_VAR 0 5
46870: PPUSH
46871: CALL_OW 256
46875: PUSH
46876: LD_INT 650
46878: LESSEQUAL
46879: OR
46880: PUSH
46881: LD_VAR 0 5
46885: PPUSH
46886: LD_EXP 74
46890: PUSH
46891: LD_VAR 0 1
46895: ARRAY
46896: PPUSH
46897: CALL_OW 308
46901: NOT
46902: AND
46903: IFFALSE 46925
// ComMoveToArea ( i , mc_parking [ base ] ) ;
46905: LD_VAR 0 5
46909: PPUSH
46910: LD_EXP 74
46914: PUSH
46915: LD_VAR 0 1
46919: ARRAY
46920: PPUSH
46921: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
46925: LD_VAR 0 5
46929: PPUSH
46930: CALL_OW 256
46934: PUSH
46935: LD_INT 998
46937: LESS
46938: PUSH
46939: LD_VAR 0 5
46943: PPUSH
46944: CALL_OW 263
46948: PUSH
46949: LD_INT 1
46951: EQUAL
46952: AND
46953: PUSH
46954: LD_VAR 0 5
46958: PPUSH
46959: CALL_OW 311
46963: AND
46964: PUSH
46965: LD_VAR 0 5
46969: PPUSH
46970: LD_EXP 74
46974: PUSH
46975: LD_VAR 0 1
46979: ARRAY
46980: PPUSH
46981: CALL_OW 308
46985: AND
46986: IFFALSE 47040
// begin mech := IsDrivenBy ( i ) ;
46988: LD_ADDR_VAR 0 9
46992: PUSH
46993: LD_VAR 0 5
46997: PPUSH
46998: CALL_OW 311
47002: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
47003: LD_VAR 0 9
47007: PPUSH
47008: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
47012: LD_VAR 0 9
47016: PPUSH
47017: LD_VAR 0 5
47021: PPUSH
47022: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
47026: LD_VAR 0 9
47030: PPUSH
47031: LD_VAR 0 5
47035: PPUSH
47036: CALL_OW 180
// end ; end ; unit_human :
47040: GO 47307
47042: LD_INT 1
47044: DOUBLE
47045: EQUAL
47046: IFTRUE 47050
47048: GO 47306
47050: POP
// begin b := IsInUnit ( i ) ;
47051: LD_ADDR_VAR 0 18
47055: PUSH
47056: LD_VAR 0 5
47060: PPUSH
47061: CALL_OW 310
47065: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
47066: LD_ADDR_VAR 0 19
47070: PUSH
47071: LD_VAR 0 18
47075: NOT
47076: PUSH
47077: LD_VAR 0 18
47081: PPUSH
47082: CALL_OW 266
47086: PUSH
47087: LD_INT 32
47089: PUSH
47090: LD_INT 31
47092: PUSH
47093: EMPTY
47094: LIST
47095: LIST
47096: IN
47097: OR
47098: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
47099: LD_VAR 0 16
47103: PUSH
47104: LD_VAR 0 2
47108: PPUSH
47109: LD_INT 21
47111: PUSH
47112: LD_INT 2
47114: PUSH
47115: EMPTY
47116: LIST
47117: LIST
47118: PPUSH
47119: CALL_OW 72
47123: PUSH
47124: LD_INT 1
47126: LESSEQUAL
47127: OR
47128: PUSH
47129: LD_VAR 0 19
47133: AND
47134: PUSH
47135: LD_VAR 0 5
47139: PUSH
47140: LD_VAR 0 17
47144: IN
47145: NOT
47146: AND
47147: IFFALSE 47240
// begin if b then
47149: LD_VAR 0 18
47153: IFFALSE 47202
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
47155: LD_VAR 0 18
47159: PPUSH
47160: LD_VAR 0 3
47164: PPUSH
47165: LD_VAR 0 18
47169: PPUSH
47170: CALL_OW 74
47174: PPUSH
47175: CALL_OW 296
47179: PUSH
47180: LD_INT 10
47182: LESS
47183: PUSH
47184: LD_VAR 0 18
47188: PPUSH
47189: CALL_OW 461
47193: PUSH
47194: LD_INT 7
47196: NONEQUAL
47197: AND
47198: IFFALSE 47202
// continue ;
47200: GO 46650
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
47202: LD_ADDR_VAR 0 17
47206: PUSH
47207: LD_VAR 0 17
47211: PPUSH
47212: LD_VAR 0 17
47216: PUSH
47217: LD_INT 1
47219: PLUS
47220: PPUSH
47221: LD_VAR 0 5
47225: PPUSH
47226: CALL_OW 1
47230: ST_TO_ADDR
// ComExitBuilding ( i ) ;
47231: LD_VAR 0 5
47235: PPUSH
47236: CALL_OW 122
// end ; if sold_defenders then
47240: LD_VAR 0 17
47244: IFFALSE 47304
// if i in sold_defenders then
47246: LD_VAR 0 5
47250: PUSH
47251: LD_VAR 0 17
47255: IN
47256: IFFALSE 47304
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
47258: LD_VAR 0 5
47262: PPUSH
47263: CALL_OW 314
47267: NOT
47268: PUSH
47269: LD_VAR 0 5
47273: PPUSH
47274: LD_VAR 0 13
47278: PPUSH
47279: CALL_OW 296
47283: PUSH
47284: LD_INT 30
47286: LESS
47287: AND
47288: IFFALSE 47304
// ComAttackUnit ( i , e ) ;
47290: LD_VAR 0 5
47294: PPUSH
47295: LD_VAR 0 13
47299: PPUSH
47300: CALL_OW 115
// end ; end ; end ;
47304: GO 47307
47306: POP
// if IsDead ( i ) then
47307: LD_VAR 0 5
47311: PPUSH
47312: CALL_OW 301
47316: IFFALSE 47334
// defenders := defenders diff i ;
47318: LD_ADDR_VAR 0 2
47322: PUSH
47323: LD_VAR 0 2
47327: PUSH
47328: LD_VAR 0 5
47332: DIFF
47333: ST_TO_ADDR
// end ;
47334: GO 46650
47336: POP
47337: POP
// until not enemy or not defenders ;
47338: LD_VAR 0 3
47342: NOT
47343: PUSH
47344: LD_VAR 0 2
47348: NOT
47349: OR
47350: IFFALSE 46617
// MC_Reset ( base , 18 ) ;
47352: LD_VAR 0 1
47356: PPUSH
47357: LD_INT 18
47359: PPUSH
47360: CALL 19681 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
47364: LD_ADDR_VAR 0 2
47368: PUSH
47369: LD_VAR 0 2
47373: PUSH
47374: LD_VAR 0 2
47378: PPUSH
47379: LD_INT 2
47381: PUSH
47382: LD_INT 25
47384: PUSH
47385: LD_INT 1
47387: PUSH
47388: EMPTY
47389: LIST
47390: LIST
47391: PUSH
47392: LD_INT 25
47394: PUSH
47395: LD_INT 5
47397: PUSH
47398: EMPTY
47399: LIST
47400: LIST
47401: PUSH
47402: LD_INT 25
47404: PUSH
47405: LD_INT 8
47407: PUSH
47408: EMPTY
47409: LIST
47410: LIST
47411: PUSH
47412: LD_INT 25
47414: PUSH
47415: LD_INT 9
47417: PUSH
47418: EMPTY
47419: LIST
47420: LIST
47421: PUSH
47422: EMPTY
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: PPUSH
47429: CALL_OW 72
47433: DIFF
47434: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
47435: LD_VAR 0 3
47439: NOT
47440: PUSH
47441: LD_VAR 0 2
47445: PPUSH
47446: LD_INT 21
47448: PUSH
47449: LD_INT 2
47451: PUSH
47452: EMPTY
47453: LIST
47454: LIST
47455: PPUSH
47456: CALL_OW 72
47460: AND
47461: IFFALSE 47723
// begin tmp := FilterByTag ( defenders , 19 ) ;
47463: LD_ADDR_VAR 0 11
47467: PUSH
47468: LD_VAR 0 2
47472: PPUSH
47473: LD_INT 19
47475: PPUSH
47476: CALL 83916 0 2
47480: ST_TO_ADDR
// if tmp then
47481: LD_VAR 0 11
47485: IFFALSE 47555
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
47487: LD_ADDR_VAR 0 11
47491: PUSH
47492: LD_VAR 0 11
47496: PPUSH
47497: LD_INT 25
47499: PUSH
47500: LD_INT 3
47502: PUSH
47503: EMPTY
47504: LIST
47505: LIST
47506: PPUSH
47507: CALL_OW 72
47511: ST_TO_ADDR
// if tmp then
47512: LD_VAR 0 11
47516: IFFALSE 47555
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
47518: LD_ADDR_EXP 62
47522: PUSH
47523: LD_EXP 62
47527: PPUSH
47528: LD_VAR 0 1
47532: PPUSH
47533: LD_EXP 62
47537: PUSH
47538: LD_VAR 0 1
47542: ARRAY
47543: PUSH
47544: LD_VAR 0 11
47548: UNION
47549: PPUSH
47550: CALL_OW 1
47554: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
47555: LD_VAR 0 1
47559: PPUSH
47560: LD_INT 19
47562: PPUSH
47563: CALL 19681 0 2
// repeat wait ( 0 0$1 ) ;
47567: LD_INT 35
47569: PPUSH
47570: CALL_OW 67
// for i in defenders do
47574: LD_ADDR_VAR 0 5
47578: PUSH
47579: LD_VAR 0 2
47583: PUSH
47584: FOR_IN
47585: IFFALSE 47674
// begin if not IsInArea ( i , mc_parking [ base ] ) then
47587: LD_VAR 0 5
47591: PPUSH
47592: LD_EXP 74
47596: PUSH
47597: LD_VAR 0 1
47601: ARRAY
47602: PPUSH
47603: CALL_OW 308
47607: NOT
47608: IFFALSE 47632
// ComMoveToArea ( i , mc_parking [ base ] ) else
47610: LD_VAR 0 5
47614: PPUSH
47615: LD_EXP 74
47619: PUSH
47620: LD_VAR 0 1
47624: ARRAY
47625: PPUSH
47626: CALL_OW 113
47630: GO 47672
// if GetControl ( i ) = control_manual then
47632: LD_VAR 0 5
47636: PPUSH
47637: CALL_OW 263
47641: PUSH
47642: LD_INT 1
47644: EQUAL
47645: IFFALSE 47672
// if IsDrivenBy ( i ) then
47647: LD_VAR 0 5
47651: PPUSH
47652: CALL_OW 311
47656: IFFALSE 47672
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
47658: LD_VAR 0 5
47662: PPUSH
47663: CALL_OW 311
47667: PPUSH
47668: CALL_OW 121
// end ;
47672: GO 47584
47674: POP
47675: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
47676: LD_VAR 0 2
47680: PPUSH
47681: LD_INT 95
47683: PUSH
47684: LD_EXP 74
47688: PUSH
47689: LD_VAR 0 1
47693: ARRAY
47694: PUSH
47695: EMPTY
47696: LIST
47697: LIST
47698: PPUSH
47699: CALL_OW 72
47703: PUSH
47704: LD_VAR 0 2
47708: EQUAL
47709: PUSH
47710: LD_EXP 73
47714: PUSH
47715: LD_VAR 0 1
47719: ARRAY
47720: OR
47721: IFFALSE 47567
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
47723: LD_ADDR_EXP 72
47727: PUSH
47728: LD_EXP 72
47732: PPUSH
47733: LD_VAR 0 1
47737: PPUSH
47738: LD_EXP 72
47742: PUSH
47743: LD_VAR 0 1
47747: ARRAY
47748: PUSH
47749: LD_VAR 0 2
47753: UNION
47754: PPUSH
47755: CALL_OW 1
47759: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
47760: LD_VAR 0 1
47764: PPUSH
47765: LD_INT 20
47767: PPUSH
47768: CALL 19681 0 2
// end ;
47772: LD_VAR 0 4
47776: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
47777: LD_INT 0
47779: PPUSH
47780: PPUSH
47781: PPUSH
47782: PPUSH
// result := false ;
47783: LD_ADDR_VAR 0 2
47787: PUSH
47788: LD_INT 0
47790: ST_TO_ADDR
// side := GetSide ( unit ) ;
47791: LD_ADDR_VAR 0 3
47795: PUSH
47796: LD_VAR 0 1
47800: PPUSH
47801: CALL_OW 255
47805: ST_TO_ADDR
// nat := GetNation ( unit ) ;
47806: LD_ADDR_VAR 0 4
47810: PUSH
47811: LD_VAR 0 1
47815: PPUSH
47816: CALL_OW 248
47820: ST_TO_ADDR
// case nat of 1 :
47821: LD_VAR 0 4
47825: PUSH
47826: LD_INT 1
47828: DOUBLE
47829: EQUAL
47830: IFTRUE 47834
47832: GO 47845
47834: POP
// tech := tech_lassight ; 2 :
47835: LD_ADDR_VAR 0 5
47839: PUSH
47840: LD_INT 12
47842: ST_TO_ADDR
47843: GO 47884
47845: LD_INT 2
47847: DOUBLE
47848: EQUAL
47849: IFTRUE 47853
47851: GO 47864
47853: POP
// tech := tech_mortar ; 3 :
47854: LD_ADDR_VAR 0 5
47858: PUSH
47859: LD_INT 41
47861: ST_TO_ADDR
47862: GO 47884
47864: LD_INT 3
47866: DOUBLE
47867: EQUAL
47868: IFTRUE 47872
47870: GO 47883
47872: POP
// tech := tech_bazooka ; end ;
47873: LD_ADDR_VAR 0 5
47877: PUSH
47878: LD_INT 44
47880: ST_TO_ADDR
47881: GO 47884
47883: POP
// if Researched ( side , tech ) then
47884: LD_VAR 0 3
47888: PPUSH
47889: LD_VAR 0 5
47893: PPUSH
47894: CALL_OW 325
47898: IFFALSE 47925
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
47900: LD_ADDR_VAR 0 2
47904: PUSH
47905: LD_INT 5
47907: PUSH
47908: LD_INT 8
47910: PUSH
47911: LD_INT 9
47913: PUSH
47914: EMPTY
47915: LIST
47916: LIST
47917: LIST
47918: PUSH
47919: LD_VAR 0 4
47923: ARRAY
47924: ST_TO_ADDR
// end ;
47925: LD_VAR 0 2
47929: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
47930: LD_INT 0
47932: PPUSH
47933: PPUSH
47934: PPUSH
// if not mines then
47935: LD_VAR 0 2
47939: NOT
47940: IFFALSE 47944
// exit ;
47942: GO 48088
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
47944: LD_ADDR_VAR 0 5
47948: PUSH
47949: LD_INT 81
47951: PUSH
47952: LD_VAR 0 1
47956: PUSH
47957: EMPTY
47958: LIST
47959: LIST
47960: PUSH
47961: LD_INT 3
47963: PUSH
47964: LD_INT 21
47966: PUSH
47967: LD_INT 3
47969: PUSH
47970: EMPTY
47971: LIST
47972: LIST
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: PUSH
47978: EMPTY
47979: LIST
47980: LIST
47981: PPUSH
47982: CALL_OW 69
47986: ST_TO_ADDR
// for i in mines do
47987: LD_ADDR_VAR 0 4
47991: PUSH
47992: LD_VAR 0 2
47996: PUSH
47997: FOR_IN
47998: IFFALSE 48086
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
48000: LD_VAR 0 4
48004: PUSH
48005: LD_INT 1
48007: ARRAY
48008: PPUSH
48009: LD_VAR 0 4
48013: PUSH
48014: LD_INT 2
48016: ARRAY
48017: PPUSH
48018: CALL_OW 458
48022: NOT
48023: IFFALSE 48027
// continue ;
48025: GO 47997
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
48027: LD_VAR 0 4
48031: PUSH
48032: LD_INT 1
48034: ARRAY
48035: PPUSH
48036: LD_VAR 0 4
48040: PUSH
48041: LD_INT 2
48043: ARRAY
48044: PPUSH
48045: CALL_OW 428
48049: PUSH
48050: LD_VAR 0 5
48054: IN
48055: IFFALSE 48084
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
48057: LD_VAR 0 4
48061: PUSH
48062: LD_INT 1
48064: ARRAY
48065: PPUSH
48066: LD_VAR 0 4
48070: PUSH
48071: LD_INT 2
48073: ARRAY
48074: PPUSH
48075: LD_VAR 0 1
48079: PPUSH
48080: CALL_OW 456
// end ;
48084: GO 47997
48086: POP
48087: POP
// end ;
48088: LD_VAR 0 3
48092: RET
// export function Count ( array ) ; var i ; begin
48093: LD_INT 0
48095: PPUSH
48096: PPUSH
// result := 0 ;
48097: LD_ADDR_VAR 0 2
48101: PUSH
48102: LD_INT 0
48104: ST_TO_ADDR
// for i in array do
48105: LD_ADDR_VAR 0 3
48109: PUSH
48110: LD_VAR 0 1
48114: PUSH
48115: FOR_IN
48116: IFFALSE 48140
// if i then
48118: LD_VAR 0 3
48122: IFFALSE 48138
// result := result + 1 ;
48124: LD_ADDR_VAR 0 2
48128: PUSH
48129: LD_VAR 0 2
48133: PUSH
48134: LD_INT 1
48136: PLUS
48137: ST_TO_ADDR
48138: GO 48115
48140: POP
48141: POP
// end ;
48142: LD_VAR 0 2
48146: RET
// export function IsEmpty ( building ) ; begin
48147: LD_INT 0
48149: PPUSH
// if not building then
48150: LD_VAR 0 1
48154: NOT
48155: IFFALSE 48159
// exit ;
48157: GO 48202
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
48159: LD_ADDR_VAR 0 2
48163: PUSH
48164: LD_VAR 0 1
48168: PUSH
48169: LD_INT 22
48171: PUSH
48172: LD_VAR 0 1
48176: PPUSH
48177: CALL_OW 255
48181: PUSH
48182: EMPTY
48183: LIST
48184: LIST
48185: PUSH
48186: LD_INT 58
48188: PUSH
48189: EMPTY
48190: LIST
48191: PUSH
48192: EMPTY
48193: LIST
48194: LIST
48195: PPUSH
48196: CALL_OW 69
48200: IN
48201: ST_TO_ADDR
// end ;
48202: LD_VAR 0 2
48206: RET
// export function IsNotFull ( building ) ; begin
48207: LD_INT 0
48209: PPUSH
// if not building then
48210: LD_VAR 0 1
48214: NOT
48215: IFFALSE 48219
// exit ;
48217: GO 48238
// result := UnitsInside ( building ) < 6 ;
48219: LD_ADDR_VAR 0 2
48223: PUSH
48224: LD_VAR 0 1
48228: PPUSH
48229: CALL_OW 313
48233: PUSH
48234: LD_INT 6
48236: LESS
48237: ST_TO_ADDR
// end ;
48238: LD_VAR 0 2
48242: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
48243: LD_INT 0
48245: PPUSH
48246: PPUSH
48247: PPUSH
48248: PPUSH
// tmp := [ ] ;
48249: LD_ADDR_VAR 0 3
48253: PUSH
48254: EMPTY
48255: ST_TO_ADDR
// list := [ ] ;
48256: LD_ADDR_VAR 0 5
48260: PUSH
48261: EMPTY
48262: ST_TO_ADDR
// for i = 16 to 25 do
48263: LD_ADDR_VAR 0 4
48267: PUSH
48268: DOUBLE
48269: LD_INT 16
48271: DEC
48272: ST_TO_ADDR
48273: LD_INT 25
48275: PUSH
48276: FOR_TO
48277: IFFALSE 48350
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
48279: LD_ADDR_VAR 0 3
48283: PUSH
48284: LD_VAR 0 3
48288: PUSH
48289: LD_INT 22
48291: PUSH
48292: LD_VAR 0 1
48296: PPUSH
48297: CALL_OW 255
48301: PUSH
48302: EMPTY
48303: LIST
48304: LIST
48305: PUSH
48306: LD_INT 91
48308: PUSH
48309: LD_VAR 0 1
48313: PUSH
48314: LD_INT 6
48316: PUSH
48317: EMPTY
48318: LIST
48319: LIST
48320: LIST
48321: PUSH
48322: LD_INT 30
48324: PUSH
48325: LD_VAR 0 4
48329: PUSH
48330: EMPTY
48331: LIST
48332: LIST
48333: PUSH
48334: EMPTY
48335: LIST
48336: LIST
48337: LIST
48338: PUSH
48339: EMPTY
48340: LIST
48341: PPUSH
48342: CALL_OW 69
48346: ADD
48347: ST_TO_ADDR
48348: GO 48276
48350: POP
48351: POP
// for i = 1 to tmp do
48352: LD_ADDR_VAR 0 4
48356: PUSH
48357: DOUBLE
48358: LD_INT 1
48360: DEC
48361: ST_TO_ADDR
48362: LD_VAR 0 3
48366: PUSH
48367: FOR_TO
48368: IFFALSE 48456
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
48370: LD_ADDR_VAR 0 5
48374: PUSH
48375: LD_VAR 0 5
48379: PUSH
48380: LD_VAR 0 3
48384: PUSH
48385: LD_VAR 0 4
48389: ARRAY
48390: PPUSH
48391: CALL_OW 266
48395: PUSH
48396: LD_VAR 0 3
48400: PUSH
48401: LD_VAR 0 4
48405: ARRAY
48406: PPUSH
48407: CALL_OW 250
48411: PUSH
48412: LD_VAR 0 3
48416: PUSH
48417: LD_VAR 0 4
48421: ARRAY
48422: PPUSH
48423: CALL_OW 251
48427: PUSH
48428: LD_VAR 0 3
48432: PUSH
48433: LD_VAR 0 4
48437: ARRAY
48438: PPUSH
48439: CALL_OW 254
48443: PUSH
48444: EMPTY
48445: LIST
48446: LIST
48447: LIST
48448: LIST
48449: PUSH
48450: EMPTY
48451: LIST
48452: ADD
48453: ST_TO_ADDR
48454: GO 48367
48456: POP
48457: POP
// result := list ;
48458: LD_ADDR_VAR 0 2
48462: PUSH
48463: LD_VAR 0 5
48467: ST_TO_ADDR
// end ;
48468: LD_VAR 0 2
48472: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
48473: LD_INT 0
48475: PPUSH
48476: PPUSH
48477: PPUSH
48478: PPUSH
48479: PPUSH
48480: PPUSH
48481: PPUSH
// if not factory then
48482: LD_VAR 0 1
48486: NOT
48487: IFFALSE 48491
// exit ;
48489: GO 49016
// if control = control_apeman then
48491: LD_VAR 0 4
48495: PUSH
48496: LD_INT 5
48498: EQUAL
48499: IFFALSE 48608
// begin tmp := UnitsInside ( factory ) ;
48501: LD_ADDR_VAR 0 8
48505: PUSH
48506: LD_VAR 0 1
48510: PPUSH
48511: CALL_OW 313
48515: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
48516: LD_VAR 0 8
48520: PPUSH
48521: LD_INT 25
48523: PUSH
48524: LD_INT 12
48526: PUSH
48527: EMPTY
48528: LIST
48529: LIST
48530: PPUSH
48531: CALL_OW 72
48535: NOT
48536: IFFALSE 48546
// control := control_manual ;
48538: LD_ADDR_VAR 0 4
48542: PUSH
48543: LD_INT 1
48545: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
48546: LD_ADDR_VAR 0 8
48550: PUSH
48551: LD_VAR 0 1
48555: PPUSH
48556: CALL 48243 0 1
48560: ST_TO_ADDR
// if tmp then
48561: LD_VAR 0 8
48565: IFFALSE 48608
// begin for i in tmp do
48567: LD_ADDR_VAR 0 7
48571: PUSH
48572: LD_VAR 0 8
48576: PUSH
48577: FOR_IN
48578: IFFALSE 48606
// if i [ 1 ] = b_ext_radar then
48580: LD_VAR 0 7
48584: PUSH
48585: LD_INT 1
48587: ARRAY
48588: PUSH
48589: LD_INT 20
48591: EQUAL
48592: IFFALSE 48604
// begin control := control_remote ;
48594: LD_ADDR_VAR 0 4
48598: PUSH
48599: LD_INT 2
48601: ST_TO_ADDR
// break ;
48602: GO 48606
// end ;
48604: GO 48577
48606: POP
48607: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
48608: LD_VAR 0 1
48612: PPUSH
48613: LD_VAR 0 2
48617: PPUSH
48618: LD_VAR 0 3
48622: PPUSH
48623: LD_VAR 0 4
48627: PPUSH
48628: LD_VAR 0 5
48632: PPUSH
48633: CALL_OW 448
48637: IFFALSE 48672
// begin result := [ chassis , engine , control , weapon ] ;
48639: LD_ADDR_VAR 0 6
48643: PUSH
48644: LD_VAR 0 2
48648: PUSH
48649: LD_VAR 0 3
48653: PUSH
48654: LD_VAR 0 4
48658: PUSH
48659: LD_VAR 0 5
48663: PUSH
48664: EMPTY
48665: LIST
48666: LIST
48667: LIST
48668: LIST
48669: ST_TO_ADDR
// exit ;
48670: GO 49016
// end ; _chassis := AvailableChassisList ( factory ) ;
48672: LD_ADDR_VAR 0 9
48676: PUSH
48677: LD_VAR 0 1
48681: PPUSH
48682: CALL_OW 475
48686: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
48687: LD_ADDR_VAR 0 11
48691: PUSH
48692: LD_VAR 0 1
48696: PPUSH
48697: CALL_OW 476
48701: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
48702: LD_ADDR_VAR 0 12
48706: PUSH
48707: LD_VAR 0 1
48711: PPUSH
48712: CALL_OW 477
48716: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
48717: LD_ADDR_VAR 0 10
48721: PUSH
48722: LD_VAR 0 1
48726: PPUSH
48727: CALL_OW 478
48731: ST_TO_ADDR
// if not chassis in _chassis then
48732: LD_VAR 0 2
48736: PUSH
48737: LD_VAR 0 9
48741: IN
48742: NOT
48743: IFFALSE 48769
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
48745: LD_ADDR_VAR 0 2
48749: PUSH
48750: LD_VAR 0 9
48754: PUSH
48755: LD_INT 1
48757: PPUSH
48758: LD_VAR 0 9
48762: PPUSH
48763: CALL_OW 12
48767: ARRAY
48768: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
48769: LD_VAR 0 2
48773: PPUSH
48774: LD_VAR 0 3
48778: PPUSH
48779: CALL 49021 0 2
48783: NOT
48784: IFFALSE 48843
// repeat engine := _engine [ 1 ] ;
48786: LD_ADDR_VAR 0 3
48790: PUSH
48791: LD_VAR 0 11
48795: PUSH
48796: LD_INT 1
48798: ARRAY
48799: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
48800: LD_ADDR_VAR 0 11
48804: PUSH
48805: LD_VAR 0 11
48809: PPUSH
48810: LD_INT 1
48812: PPUSH
48813: CALL_OW 3
48817: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
48818: LD_VAR 0 2
48822: PPUSH
48823: LD_VAR 0 3
48827: PPUSH
48828: CALL 49021 0 2
48832: PUSH
48833: LD_VAR 0 11
48837: PUSH
48838: EMPTY
48839: EQUAL
48840: OR
48841: IFFALSE 48786
// if not control in _control then
48843: LD_VAR 0 4
48847: PUSH
48848: LD_VAR 0 12
48852: IN
48853: NOT
48854: IFFALSE 48880
// control := _control [ rand ( 1 , _control ) ] ;
48856: LD_ADDR_VAR 0 4
48860: PUSH
48861: LD_VAR 0 12
48865: PUSH
48866: LD_INT 1
48868: PPUSH
48869: LD_VAR 0 12
48873: PPUSH
48874: CALL_OW 12
48878: ARRAY
48879: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
48880: LD_VAR 0 2
48884: PPUSH
48885: LD_VAR 0 5
48889: PPUSH
48890: CALL 49241 0 2
48894: NOT
48895: IFFALSE 48954
// repeat weapon := _weapon [ 1 ] ;
48897: LD_ADDR_VAR 0 5
48901: PUSH
48902: LD_VAR 0 10
48906: PUSH
48907: LD_INT 1
48909: ARRAY
48910: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
48911: LD_ADDR_VAR 0 10
48915: PUSH
48916: LD_VAR 0 10
48920: PPUSH
48921: LD_INT 1
48923: PPUSH
48924: CALL_OW 3
48928: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
48929: LD_VAR 0 2
48933: PPUSH
48934: LD_VAR 0 5
48938: PPUSH
48939: CALL 49241 0 2
48943: PUSH
48944: LD_VAR 0 10
48948: PUSH
48949: EMPTY
48950: EQUAL
48951: OR
48952: IFFALSE 48897
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
48954: LD_VAR 0 1
48958: PPUSH
48959: LD_VAR 0 2
48963: PPUSH
48964: LD_VAR 0 3
48968: PPUSH
48969: LD_VAR 0 4
48973: PPUSH
48974: LD_VAR 0 5
48978: PPUSH
48979: CALL_OW 448
48983: IFFALSE 49016
// result := [ chassis , engine , control , weapon ] ;
48985: LD_ADDR_VAR 0 6
48989: PUSH
48990: LD_VAR 0 2
48994: PUSH
48995: LD_VAR 0 3
48999: PUSH
49000: LD_VAR 0 4
49004: PUSH
49005: LD_VAR 0 5
49009: PUSH
49010: EMPTY
49011: LIST
49012: LIST
49013: LIST
49014: LIST
49015: ST_TO_ADDR
// end ;
49016: LD_VAR 0 6
49020: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
49021: LD_INT 0
49023: PPUSH
// if not chassis or not engine then
49024: LD_VAR 0 1
49028: NOT
49029: PUSH
49030: LD_VAR 0 2
49034: NOT
49035: OR
49036: IFFALSE 49040
// exit ;
49038: GO 49236
// case engine of engine_solar :
49040: LD_VAR 0 2
49044: PUSH
49045: LD_INT 2
49047: DOUBLE
49048: EQUAL
49049: IFTRUE 49053
49051: GO 49091
49053: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
49054: LD_ADDR_VAR 0 3
49058: PUSH
49059: LD_INT 11
49061: PUSH
49062: LD_INT 12
49064: PUSH
49065: LD_INT 13
49067: PUSH
49068: LD_INT 14
49070: PUSH
49071: LD_INT 1
49073: PUSH
49074: LD_INT 2
49076: PUSH
49077: LD_INT 3
49079: PUSH
49080: EMPTY
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: LIST
49086: LIST
49087: LIST
49088: ST_TO_ADDR
49089: GO 49220
49091: LD_INT 1
49093: DOUBLE
49094: EQUAL
49095: IFTRUE 49099
49097: GO 49161
49099: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
49100: LD_ADDR_VAR 0 3
49104: PUSH
49105: LD_INT 11
49107: PUSH
49108: LD_INT 12
49110: PUSH
49111: LD_INT 13
49113: PUSH
49114: LD_INT 14
49116: PUSH
49117: LD_INT 1
49119: PUSH
49120: LD_INT 2
49122: PUSH
49123: LD_INT 3
49125: PUSH
49126: LD_INT 4
49128: PUSH
49129: LD_INT 5
49131: PUSH
49132: LD_INT 21
49134: PUSH
49135: LD_INT 23
49137: PUSH
49138: LD_INT 22
49140: PUSH
49141: LD_INT 24
49143: PUSH
49144: EMPTY
49145: LIST
49146: LIST
49147: LIST
49148: LIST
49149: LIST
49150: LIST
49151: LIST
49152: LIST
49153: LIST
49154: LIST
49155: LIST
49156: LIST
49157: LIST
49158: ST_TO_ADDR
49159: GO 49220
49161: LD_INT 3
49163: DOUBLE
49164: EQUAL
49165: IFTRUE 49169
49167: GO 49219
49169: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
49170: LD_ADDR_VAR 0 3
49174: PUSH
49175: LD_INT 13
49177: PUSH
49178: LD_INT 14
49180: PUSH
49181: LD_INT 2
49183: PUSH
49184: LD_INT 3
49186: PUSH
49187: LD_INT 4
49189: PUSH
49190: LD_INT 5
49192: PUSH
49193: LD_INT 21
49195: PUSH
49196: LD_INT 22
49198: PUSH
49199: LD_INT 23
49201: PUSH
49202: LD_INT 24
49204: PUSH
49205: EMPTY
49206: LIST
49207: LIST
49208: LIST
49209: LIST
49210: LIST
49211: LIST
49212: LIST
49213: LIST
49214: LIST
49215: LIST
49216: ST_TO_ADDR
49217: GO 49220
49219: POP
// result := ( chassis in result ) ;
49220: LD_ADDR_VAR 0 3
49224: PUSH
49225: LD_VAR 0 1
49229: PUSH
49230: LD_VAR 0 3
49234: IN
49235: ST_TO_ADDR
// end ;
49236: LD_VAR 0 3
49240: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
49241: LD_INT 0
49243: PPUSH
// if not chassis or not weapon then
49244: LD_VAR 0 1
49248: NOT
49249: PUSH
49250: LD_VAR 0 2
49254: NOT
49255: OR
49256: IFFALSE 49260
// exit ;
49258: GO 50286
// case weapon of us_machine_gun :
49260: LD_VAR 0 2
49264: PUSH
49265: LD_INT 2
49267: DOUBLE
49268: EQUAL
49269: IFTRUE 49273
49271: GO 49303
49273: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
49274: LD_ADDR_VAR 0 3
49278: PUSH
49279: LD_INT 1
49281: PUSH
49282: LD_INT 2
49284: PUSH
49285: LD_INT 3
49287: PUSH
49288: LD_INT 4
49290: PUSH
49291: LD_INT 5
49293: PUSH
49294: EMPTY
49295: LIST
49296: LIST
49297: LIST
49298: LIST
49299: LIST
49300: ST_TO_ADDR
49301: GO 50270
49303: LD_INT 3
49305: DOUBLE
49306: EQUAL
49307: IFTRUE 49311
49309: GO 49341
49311: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
49312: LD_ADDR_VAR 0 3
49316: PUSH
49317: LD_INT 1
49319: PUSH
49320: LD_INT 2
49322: PUSH
49323: LD_INT 3
49325: PUSH
49326: LD_INT 4
49328: PUSH
49329: LD_INT 5
49331: PUSH
49332: EMPTY
49333: LIST
49334: LIST
49335: LIST
49336: LIST
49337: LIST
49338: ST_TO_ADDR
49339: GO 50270
49341: LD_INT 11
49343: DOUBLE
49344: EQUAL
49345: IFTRUE 49349
49347: GO 49379
49349: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
49350: LD_ADDR_VAR 0 3
49354: PUSH
49355: LD_INT 1
49357: PUSH
49358: LD_INT 2
49360: PUSH
49361: LD_INT 3
49363: PUSH
49364: LD_INT 4
49366: PUSH
49367: LD_INT 5
49369: PUSH
49370: EMPTY
49371: LIST
49372: LIST
49373: LIST
49374: LIST
49375: LIST
49376: ST_TO_ADDR
49377: GO 50270
49379: LD_INT 4
49381: DOUBLE
49382: EQUAL
49383: IFTRUE 49387
49385: GO 49413
49387: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
49388: LD_ADDR_VAR 0 3
49392: PUSH
49393: LD_INT 2
49395: PUSH
49396: LD_INT 3
49398: PUSH
49399: LD_INT 4
49401: PUSH
49402: LD_INT 5
49404: PUSH
49405: EMPTY
49406: LIST
49407: LIST
49408: LIST
49409: LIST
49410: ST_TO_ADDR
49411: GO 50270
49413: LD_INT 5
49415: DOUBLE
49416: EQUAL
49417: IFTRUE 49421
49419: GO 49447
49421: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
49422: LD_ADDR_VAR 0 3
49426: PUSH
49427: LD_INT 2
49429: PUSH
49430: LD_INT 3
49432: PUSH
49433: LD_INT 4
49435: PUSH
49436: LD_INT 5
49438: PUSH
49439: EMPTY
49440: LIST
49441: LIST
49442: LIST
49443: LIST
49444: ST_TO_ADDR
49445: GO 50270
49447: LD_INT 9
49449: DOUBLE
49450: EQUAL
49451: IFTRUE 49455
49453: GO 49481
49455: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
49456: LD_ADDR_VAR 0 3
49460: PUSH
49461: LD_INT 2
49463: PUSH
49464: LD_INT 3
49466: PUSH
49467: LD_INT 4
49469: PUSH
49470: LD_INT 5
49472: PUSH
49473: EMPTY
49474: LIST
49475: LIST
49476: LIST
49477: LIST
49478: ST_TO_ADDR
49479: GO 50270
49481: LD_INT 7
49483: DOUBLE
49484: EQUAL
49485: IFTRUE 49489
49487: GO 49515
49489: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
49490: LD_ADDR_VAR 0 3
49494: PUSH
49495: LD_INT 2
49497: PUSH
49498: LD_INT 3
49500: PUSH
49501: LD_INT 4
49503: PUSH
49504: LD_INT 5
49506: PUSH
49507: EMPTY
49508: LIST
49509: LIST
49510: LIST
49511: LIST
49512: ST_TO_ADDR
49513: GO 50270
49515: LD_INT 12
49517: DOUBLE
49518: EQUAL
49519: IFTRUE 49523
49521: GO 49549
49523: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
49524: LD_ADDR_VAR 0 3
49528: PUSH
49529: LD_INT 2
49531: PUSH
49532: LD_INT 3
49534: PUSH
49535: LD_INT 4
49537: PUSH
49538: LD_INT 5
49540: PUSH
49541: EMPTY
49542: LIST
49543: LIST
49544: LIST
49545: LIST
49546: ST_TO_ADDR
49547: GO 50270
49549: LD_INT 13
49551: DOUBLE
49552: EQUAL
49553: IFTRUE 49557
49555: GO 49583
49557: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
49558: LD_ADDR_VAR 0 3
49562: PUSH
49563: LD_INT 2
49565: PUSH
49566: LD_INT 3
49568: PUSH
49569: LD_INT 4
49571: PUSH
49572: LD_INT 5
49574: PUSH
49575: EMPTY
49576: LIST
49577: LIST
49578: LIST
49579: LIST
49580: ST_TO_ADDR
49581: GO 50270
49583: LD_INT 14
49585: DOUBLE
49586: EQUAL
49587: IFTRUE 49591
49589: GO 49609
49591: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
49592: LD_ADDR_VAR 0 3
49596: PUSH
49597: LD_INT 4
49599: PUSH
49600: LD_INT 5
49602: PUSH
49603: EMPTY
49604: LIST
49605: LIST
49606: ST_TO_ADDR
49607: GO 50270
49609: LD_INT 6
49611: DOUBLE
49612: EQUAL
49613: IFTRUE 49617
49615: GO 49635
49617: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
49618: LD_ADDR_VAR 0 3
49622: PUSH
49623: LD_INT 4
49625: PUSH
49626: LD_INT 5
49628: PUSH
49629: EMPTY
49630: LIST
49631: LIST
49632: ST_TO_ADDR
49633: GO 50270
49635: LD_INT 10
49637: DOUBLE
49638: EQUAL
49639: IFTRUE 49643
49641: GO 49661
49643: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
49644: LD_ADDR_VAR 0 3
49648: PUSH
49649: LD_INT 4
49651: PUSH
49652: LD_INT 5
49654: PUSH
49655: EMPTY
49656: LIST
49657: LIST
49658: ST_TO_ADDR
49659: GO 50270
49661: LD_INT 22
49663: DOUBLE
49664: EQUAL
49665: IFTRUE 49669
49667: GO 49695
49669: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
49670: LD_ADDR_VAR 0 3
49674: PUSH
49675: LD_INT 11
49677: PUSH
49678: LD_INT 12
49680: PUSH
49681: LD_INT 13
49683: PUSH
49684: LD_INT 14
49686: PUSH
49687: EMPTY
49688: LIST
49689: LIST
49690: LIST
49691: LIST
49692: ST_TO_ADDR
49693: GO 50270
49695: LD_INT 23
49697: DOUBLE
49698: EQUAL
49699: IFTRUE 49703
49701: GO 49729
49703: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
49704: LD_ADDR_VAR 0 3
49708: PUSH
49709: LD_INT 11
49711: PUSH
49712: LD_INT 12
49714: PUSH
49715: LD_INT 13
49717: PUSH
49718: LD_INT 14
49720: PUSH
49721: EMPTY
49722: LIST
49723: LIST
49724: LIST
49725: LIST
49726: ST_TO_ADDR
49727: GO 50270
49729: LD_INT 24
49731: DOUBLE
49732: EQUAL
49733: IFTRUE 49737
49735: GO 49763
49737: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
49738: LD_ADDR_VAR 0 3
49742: PUSH
49743: LD_INT 11
49745: PUSH
49746: LD_INT 12
49748: PUSH
49749: LD_INT 13
49751: PUSH
49752: LD_INT 14
49754: PUSH
49755: EMPTY
49756: LIST
49757: LIST
49758: LIST
49759: LIST
49760: ST_TO_ADDR
49761: GO 50270
49763: LD_INT 30
49765: DOUBLE
49766: EQUAL
49767: IFTRUE 49771
49769: GO 49797
49771: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
49772: LD_ADDR_VAR 0 3
49776: PUSH
49777: LD_INT 11
49779: PUSH
49780: LD_INT 12
49782: PUSH
49783: LD_INT 13
49785: PUSH
49786: LD_INT 14
49788: PUSH
49789: EMPTY
49790: LIST
49791: LIST
49792: LIST
49793: LIST
49794: ST_TO_ADDR
49795: GO 50270
49797: LD_INT 25
49799: DOUBLE
49800: EQUAL
49801: IFTRUE 49805
49803: GO 49823
49805: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
49806: LD_ADDR_VAR 0 3
49810: PUSH
49811: LD_INT 13
49813: PUSH
49814: LD_INT 14
49816: PUSH
49817: EMPTY
49818: LIST
49819: LIST
49820: ST_TO_ADDR
49821: GO 50270
49823: LD_INT 27
49825: DOUBLE
49826: EQUAL
49827: IFTRUE 49831
49829: GO 49849
49831: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
49832: LD_ADDR_VAR 0 3
49836: PUSH
49837: LD_INT 13
49839: PUSH
49840: LD_INT 14
49842: PUSH
49843: EMPTY
49844: LIST
49845: LIST
49846: ST_TO_ADDR
49847: GO 50270
49849: LD_INT 28
49851: DOUBLE
49852: EQUAL
49853: IFTRUE 49857
49855: GO 49875
49857: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
49858: LD_ADDR_VAR 0 3
49862: PUSH
49863: LD_INT 13
49865: PUSH
49866: LD_INT 14
49868: PUSH
49869: EMPTY
49870: LIST
49871: LIST
49872: ST_TO_ADDR
49873: GO 50270
49875: LD_INT 29
49877: DOUBLE
49878: EQUAL
49879: IFTRUE 49883
49881: GO 49901
49883: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
49884: LD_ADDR_VAR 0 3
49888: PUSH
49889: LD_INT 13
49891: PUSH
49892: LD_INT 14
49894: PUSH
49895: EMPTY
49896: LIST
49897: LIST
49898: ST_TO_ADDR
49899: GO 50270
49901: LD_INT 31
49903: DOUBLE
49904: EQUAL
49905: IFTRUE 49909
49907: GO 49927
49909: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
49910: LD_ADDR_VAR 0 3
49914: PUSH
49915: LD_INT 13
49917: PUSH
49918: LD_INT 14
49920: PUSH
49921: EMPTY
49922: LIST
49923: LIST
49924: ST_TO_ADDR
49925: GO 50270
49927: LD_INT 26
49929: DOUBLE
49930: EQUAL
49931: IFTRUE 49935
49933: GO 49953
49935: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
49936: LD_ADDR_VAR 0 3
49940: PUSH
49941: LD_INT 13
49943: PUSH
49944: LD_INT 14
49946: PUSH
49947: EMPTY
49948: LIST
49949: LIST
49950: ST_TO_ADDR
49951: GO 50270
49953: LD_INT 42
49955: DOUBLE
49956: EQUAL
49957: IFTRUE 49961
49959: GO 49987
49961: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
49962: LD_ADDR_VAR 0 3
49966: PUSH
49967: LD_INT 21
49969: PUSH
49970: LD_INT 22
49972: PUSH
49973: LD_INT 23
49975: PUSH
49976: LD_INT 24
49978: PUSH
49979: EMPTY
49980: LIST
49981: LIST
49982: LIST
49983: LIST
49984: ST_TO_ADDR
49985: GO 50270
49987: LD_INT 43
49989: DOUBLE
49990: EQUAL
49991: IFTRUE 49995
49993: GO 50021
49995: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
49996: LD_ADDR_VAR 0 3
50000: PUSH
50001: LD_INT 21
50003: PUSH
50004: LD_INT 22
50006: PUSH
50007: LD_INT 23
50009: PUSH
50010: LD_INT 24
50012: PUSH
50013: EMPTY
50014: LIST
50015: LIST
50016: LIST
50017: LIST
50018: ST_TO_ADDR
50019: GO 50270
50021: LD_INT 44
50023: DOUBLE
50024: EQUAL
50025: IFTRUE 50029
50027: GO 50055
50029: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
50030: LD_ADDR_VAR 0 3
50034: PUSH
50035: LD_INT 21
50037: PUSH
50038: LD_INT 22
50040: PUSH
50041: LD_INT 23
50043: PUSH
50044: LD_INT 24
50046: PUSH
50047: EMPTY
50048: LIST
50049: LIST
50050: LIST
50051: LIST
50052: ST_TO_ADDR
50053: GO 50270
50055: LD_INT 45
50057: DOUBLE
50058: EQUAL
50059: IFTRUE 50063
50061: GO 50089
50063: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
50064: LD_ADDR_VAR 0 3
50068: PUSH
50069: LD_INT 21
50071: PUSH
50072: LD_INT 22
50074: PUSH
50075: LD_INT 23
50077: PUSH
50078: LD_INT 24
50080: PUSH
50081: EMPTY
50082: LIST
50083: LIST
50084: LIST
50085: LIST
50086: ST_TO_ADDR
50087: GO 50270
50089: LD_INT 49
50091: DOUBLE
50092: EQUAL
50093: IFTRUE 50097
50095: GO 50123
50097: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
50098: LD_ADDR_VAR 0 3
50102: PUSH
50103: LD_INT 21
50105: PUSH
50106: LD_INT 22
50108: PUSH
50109: LD_INT 23
50111: PUSH
50112: LD_INT 24
50114: PUSH
50115: EMPTY
50116: LIST
50117: LIST
50118: LIST
50119: LIST
50120: ST_TO_ADDR
50121: GO 50270
50123: LD_INT 51
50125: DOUBLE
50126: EQUAL
50127: IFTRUE 50131
50129: GO 50157
50131: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
50132: LD_ADDR_VAR 0 3
50136: PUSH
50137: LD_INT 21
50139: PUSH
50140: LD_INT 22
50142: PUSH
50143: LD_INT 23
50145: PUSH
50146: LD_INT 24
50148: PUSH
50149: EMPTY
50150: LIST
50151: LIST
50152: LIST
50153: LIST
50154: ST_TO_ADDR
50155: GO 50270
50157: LD_INT 52
50159: DOUBLE
50160: EQUAL
50161: IFTRUE 50165
50163: GO 50191
50165: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
50166: LD_ADDR_VAR 0 3
50170: PUSH
50171: LD_INT 21
50173: PUSH
50174: LD_INT 22
50176: PUSH
50177: LD_INT 23
50179: PUSH
50180: LD_INT 24
50182: PUSH
50183: EMPTY
50184: LIST
50185: LIST
50186: LIST
50187: LIST
50188: ST_TO_ADDR
50189: GO 50270
50191: LD_INT 53
50193: DOUBLE
50194: EQUAL
50195: IFTRUE 50199
50197: GO 50217
50199: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
50200: LD_ADDR_VAR 0 3
50204: PUSH
50205: LD_INT 23
50207: PUSH
50208: LD_INT 24
50210: PUSH
50211: EMPTY
50212: LIST
50213: LIST
50214: ST_TO_ADDR
50215: GO 50270
50217: LD_INT 46
50219: DOUBLE
50220: EQUAL
50221: IFTRUE 50225
50223: GO 50243
50225: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
50226: LD_ADDR_VAR 0 3
50230: PUSH
50231: LD_INT 23
50233: PUSH
50234: LD_INT 24
50236: PUSH
50237: EMPTY
50238: LIST
50239: LIST
50240: ST_TO_ADDR
50241: GO 50270
50243: LD_INT 47
50245: DOUBLE
50246: EQUAL
50247: IFTRUE 50251
50249: GO 50269
50251: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
50252: LD_ADDR_VAR 0 3
50256: PUSH
50257: LD_INT 23
50259: PUSH
50260: LD_INT 24
50262: PUSH
50263: EMPTY
50264: LIST
50265: LIST
50266: ST_TO_ADDR
50267: GO 50270
50269: POP
// result := ( chassis in result ) ;
50270: LD_ADDR_VAR 0 3
50274: PUSH
50275: LD_VAR 0 1
50279: PUSH
50280: LD_VAR 0 3
50284: IN
50285: ST_TO_ADDR
// end ;
50286: LD_VAR 0 3
50290: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
50291: LD_INT 0
50293: PPUSH
50294: PPUSH
50295: PPUSH
50296: PPUSH
50297: PPUSH
50298: PPUSH
50299: PPUSH
// result := array ;
50300: LD_ADDR_VAR 0 5
50304: PUSH
50305: LD_VAR 0 1
50309: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
50310: LD_VAR 0 1
50314: NOT
50315: PUSH
50316: LD_VAR 0 2
50320: NOT
50321: OR
50322: PUSH
50323: LD_VAR 0 3
50327: NOT
50328: OR
50329: PUSH
50330: LD_VAR 0 2
50334: PUSH
50335: LD_VAR 0 1
50339: GREATER
50340: OR
50341: PUSH
50342: LD_VAR 0 3
50346: PUSH
50347: LD_VAR 0 1
50351: GREATER
50352: OR
50353: IFFALSE 50357
// exit ;
50355: GO 50653
// if direction then
50357: LD_VAR 0 4
50361: IFFALSE 50425
// begin d := 1 ;
50363: LD_ADDR_VAR 0 9
50367: PUSH
50368: LD_INT 1
50370: ST_TO_ADDR
// if i_from > i_to then
50371: LD_VAR 0 2
50375: PUSH
50376: LD_VAR 0 3
50380: GREATER
50381: IFFALSE 50407
// length := ( array - i_from ) + i_to else
50383: LD_ADDR_VAR 0 11
50387: PUSH
50388: LD_VAR 0 1
50392: PUSH
50393: LD_VAR 0 2
50397: MINUS
50398: PUSH
50399: LD_VAR 0 3
50403: PLUS
50404: ST_TO_ADDR
50405: GO 50423
// length := i_to - i_from ;
50407: LD_ADDR_VAR 0 11
50411: PUSH
50412: LD_VAR 0 3
50416: PUSH
50417: LD_VAR 0 2
50421: MINUS
50422: ST_TO_ADDR
// end else
50423: GO 50486
// begin d := - 1 ;
50425: LD_ADDR_VAR 0 9
50429: PUSH
50430: LD_INT 1
50432: NEG
50433: ST_TO_ADDR
// if i_from > i_to then
50434: LD_VAR 0 2
50438: PUSH
50439: LD_VAR 0 3
50443: GREATER
50444: IFFALSE 50464
// length := i_from - i_to else
50446: LD_ADDR_VAR 0 11
50450: PUSH
50451: LD_VAR 0 2
50455: PUSH
50456: LD_VAR 0 3
50460: MINUS
50461: ST_TO_ADDR
50462: GO 50486
// length := ( array - i_to ) + i_from ;
50464: LD_ADDR_VAR 0 11
50468: PUSH
50469: LD_VAR 0 1
50473: PUSH
50474: LD_VAR 0 3
50478: MINUS
50479: PUSH
50480: LD_VAR 0 2
50484: PLUS
50485: ST_TO_ADDR
// end ; if not length then
50486: LD_VAR 0 11
50490: NOT
50491: IFFALSE 50495
// exit ;
50493: GO 50653
// tmp := array ;
50495: LD_ADDR_VAR 0 10
50499: PUSH
50500: LD_VAR 0 1
50504: ST_TO_ADDR
// for i = 1 to length do
50505: LD_ADDR_VAR 0 6
50509: PUSH
50510: DOUBLE
50511: LD_INT 1
50513: DEC
50514: ST_TO_ADDR
50515: LD_VAR 0 11
50519: PUSH
50520: FOR_TO
50521: IFFALSE 50641
// begin for j = 1 to array do
50523: LD_ADDR_VAR 0 7
50527: PUSH
50528: DOUBLE
50529: LD_INT 1
50531: DEC
50532: ST_TO_ADDR
50533: LD_VAR 0 1
50537: PUSH
50538: FOR_TO
50539: IFFALSE 50627
// begin k := j + d ;
50541: LD_ADDR_VAR 0 8
50545: PUSH
50546: LD_VAR 0 7
50550: PUSH
50551: LD_VAR 0 9
50555: PLUS
50556: ST_TO_ADDR
// if k > array then
50557: LD_VAR 0 8
50561: PUSH
50562: LD_VAR 0 1
50566: GREATER
50567: IFFALSE 50577
// k := 1 ;
50569: LD_ADDR_VAR 0 8
50573: PUSH
50574: LD_INT 1
50576: ST_TO_ADDR
// if not k then
50577: LD_VAR 0 8
50581: NOT
50582: IFFALSE 50594
// k := array ;
50584: LD_ADDR_VAR 0 8
50588: PUSH
50589: LD_VAR 0 1
50593: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
50594: LD_ADDR_VAR 0 10
50598: PUSH
50599: LD_VAR 0 10
50603: PPUSH
50604: LD_VAR 0 8
50608: PPUSH
50609: LD_VAR 0 1
50613: PUSH
50614: LD_VAR 0 7
50618: ARRAY
50619: PPUSH
50620: CALL_OW 1
50624: ST_TO_ADDR
// end ;
50625: GO 50538
50627: POP
50628: POP
// array := tmp ;
50629: LD_ADDR_VAR 0 1
50633: PUSH
50634: LD_VAR 0 10
50638: ST_TO_ADDR
// end ;
50639: GO 50520
50641: POP
50642: POP
// result := array ;
50643: LD_ADDR_VAR 0 5
50647: PUSH
50648: LD_VAR 0 1
50652: ST_TO_ADDR
// end ;
50653: LD_VAR 0 5
50657: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
50658: LD_INT 0
50660: PPUSH
50661: PPUSH
// result := 0 ;
50662: LD_ADDR_VAR 0 3
50666: PUSH
50667: LD_INT 0
50669: ST_TO_ADDR
// if not array or not value in array then
50670: LD_VAR 0 1
50674: NOT
50675: PUSH
50676: LD_VAR 0 2
50680: PUSH
50681: LD_VAR 0 1
50685: IN
50686: NOT
50687: OR
50688: IFFALSE 50692
// exit ;
50690: GO 50746
// for i = 1 to array do
50692: LD_ADDR_VAR 0 4
50696: PUSH
50697: DOUBLE
50698: LD_INT 1
50700: DEC
50701: ST_TO_ADDR
50702: LD_VAR 0 1
50706: PUSH
50707: FOR_TO
50708: IFFALSE 50744
// if value = array [ i ] then
50710: LD_VAR 0 2
50714: PUSH
50715: LD_VAR 0 1
50719: PUSH
50720: LD_VAR 0 4
50724: ARRAY
50725: EQUAL
50726: IFFALSE 50742
// begin result := i ;
50728: LD_ADDR_VAR 0 3
50732: PUSH
50733: LD_VAR 0 4
50737: ST_TO_ADDR
// exit ;
50738: POP
50739: POP
50740: GO 50746
// end ;
50742: GO 50707
50744: POP
50745: POP
// end ;
50746: LD_VAR 0 3
50750: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
50751: LD_INT 0
50753: PPUSH
// vc_chassis := chassis ;
50754: LD_ADDR_OWVAR 37
50758: PUSH
50759: LD_VAR 0 1
50763: ST_TO_ADDR
// vc_engine := engine ;
50764: LD_ADDR_OWVAR 39
50768: PUSH
50769: LD_VAR 0 2
50773: ST_TO_ADDR
// vc_control := control ;
50774: LD_ADDR_OWVAR 38
50778: PUSH
50779: LD_VAR 0 3
50783: ST_TO_ADDR
// vc_weapon := weapon ;
50784: LD_ADDR_OWVAR 40
50788: PUSH
50789: LD_VAR 0 4
50793: ST_TO_ADDR
// vc_fuel_battery := fuel ;
50794: LD_ADDR_OWVAR 41
50798: PUSH
50799: LD_VAR 0 5
50803: ST_TO_ADDR
// end ;
50804: LD_VAR 0 6
50808: RET
// export function WantPlant ( unit ) ; var task ; begin
50809: LD_INT 0
50811: PPUSH
50812: PPUSH
// result := false ;
50813: LD_ADDR_VAR 0 2
50817: PUSH
50818: LD_INT 0
50820: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
50821: LD_ADDR_VAR 0 3
50825: PUSH
50826: LD_VAR 0 1
50830: PPUSH
50831: CALL_OW 437
50835: ST_TO_ADDR
// if task then
50836: LD_VAR 0 3
50840: IFFALSE 50868
// if task [ 1 ] [ 1 ] = p then
50842: LD_VAR 0 3
50846: PUSH
50847: LD_INT 1
50849: ARRAY
50850: PUSH
50851: LD_INT 1
50853: ARRAY
50854: PUSH
50855: LD_STRING p
50857: EQUAL
50858: IFFALSE 50868
// result := true ;
50860: LD_ADDR_VAR 0 2
50864: PUSH
50865: LD_INT 1
50867: ST_TO_ADDR
// end ;
50868: LD_VAR 0 2
50872: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
50873: LD_INT 0
50875: PPUSH
50876: PPUSH
50877: PPUSH
50878: PPUSH
// if pos < 1 then
50879: LD_VAR 0 2
50883: PUSH
50884: LD_INT 1
50886: LESS
50887: IFFALSE 50891
// exit ;
50889: GO 51194
// if pos = 1 then
50891: LD_VAR 0 2
50895: PUSH
50896: LD_INT 1
50898: EQUAL
50899: IFFALSE 50932
// result := Replace ( arr , pos [ 1 ] , value ) else
50901: LD_ADDR_VAR 0 4
50905: PUSH
50906: LD_VAR 0 1
50910: PPUSH
50911: LD_VAR 0 2
50915: PUSH
50916: LD_INT 1
50918: ARRAY
50919: PPUSH
50920: LD_VAR 0 3
50924: PPUSH
50925: CALL_OW 1
50929: ST_TO_ADDR
50930: GO 51194
// begin tmp := arr ;
50932: LD_ADDR_VAR 0 6
50936: PUSH
50937: LD_VAR 0 1
50941: ST_TO_ADDR
// s_arr := [ tmp ] ;
50942: LD_ADDR_VAR 0 7
50946: PUSH
50947: LD_VAR 0 6
50951: PUSH
50952: EMPTY
50953: LIST
50954: ST_TO_ADDR
// for i = 1 to pos - 1 do
50955: LD_ADDR_VAR 0 5
50959: PUSH
50960: DOUBLE
50961: LD_INT 1
50963: DEC
50964: ST_TO_ADDR
50965: LD_VAR 0 2
50969: PUSH
50970: LD_INT 1
50972: MINUS
50973: PUSH
50974: FOR_TO
50975: IFFALSE 51020
// begin tmp := tmp [ pos [ i ] ] ;
50977: LD_ADDR_VAR 0 6
50981: PUSH
50982: LD_VAR 0 6
50986: PUSH
50987: LD_VAR 0 2
50991: PUSH
50992: LD_VAR 0 5
50996: ARRAY
50997: ARRAY
50998: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
50999: LD_ADDR_VAR 0 7
51003: PUSH
51004: LD_VAR 0 7
51008: PUSH
51009: LD_VAR 0 6
51013: PUSH
51014: EMPTY
51015: LIST
51016: ADD
51017: ST_TO_ADDR
// end ;
51018: GO 50974
51020: POP
51021: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
51022: LD_ADDR_VAR 0 6
51026: PUSH
51027: LD_VAR 0 6
51031: PPUSH
51032: LD_VAR 0 2
51036: PUSH
51037: LD_VAR 0 2
51041: ARRAY
51042: PPUSH
51043: LD_VAR 0 3
51047: PPUSH
51048: CALL_OW 1
51052: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
51053: LD_ADDR_VAR 0 7
51057: PUSH
51058: LD_VAR 0 7
51062: PPUSH
51063: LD_VAR 0 7
51067: PPUSH
51068: LD_VAR 0 6
51072: PPUSH
51073: CALL_OW 1
51077: ST_TO_ADDR
// for i = s_arr downto 2 do
51078: LD_ADDR_VAR 0 5
51082: PUSH
51083: DOUBLE
51084: LD_VAR 0 7
51088: INC
51089: ST_TO_ADDR
51090: LD_INT 2
51092: PUSH
51093: FOR_DOWNTO
51094: IFFALSE 51178
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
51096: LD_ADDR_VAR 0 6
51100: PUSH
51101: LD_VAR 0 7
51105: PUSH
51106: LD_VAR 0 5
51110: PUSH
51111: LD_INT 1
51113: MINUS
51114: ARRAY
51115: PPUSH
51116: LD_VAR 0 2
51120: PUSH
51121: LD_VAR 0 5
51125: PUSH
51126: LD_INT 1
51128: MINUS
51129: ARRAY
51130: PPUSH
51131: LD_VAR 0 7
51135: PUSH
51136: LD_VAR 0 5
51140: ARRAY
51141: PPUSH
51142: CALL_OW 1
51146: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
51147: LD_ADDR_VAR 0 7
51151: PUSH
51152: LD_VAR 0 7
51156: PPUSH
51157: LD_VAR 0 5
51161: PUSH
51162: LD_INT 1
51164: MINUS
51165: PPUSH
51166: LD_VAR 0 6
51170: PPUSH
51171: CALL_OW 1
51175: ST_TO_ADDR
// end ;
51176: GO 51093
51178: POP
51179: POP
// result := s_arr [ 1 ] ;
51180: LD_ADDR_VAR 0 4
51184: PUSH
51185: LD_VAR 0 7
51189: PUSH
51190: LD_INT 1
51192: ARRAY
51193: ST_TO_ADDR
// end ; end ;
51194: LD_VAR 0 4
51198: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
51199: LD_INT 0
51201: PPUSH
51202: PPUSH
// if not list then
51203: LD_VAR 0 1
51207: NOT
51208: IFFALSE 51212
// exit ;
51210: GO 51303
// i := list [ pos1 ] ;
51212: LD_ADDR_VAR 0 5
51216: PUSH
51217: LD_VAR 0 1
51221: PUSH
51222: LD_VAR 0 2
51226: ARRAY
51227: ST_TO_ADDR
// if not i then
51228: LD_VAR 0 5
51232: NOT
51233: IFFALSE 51237
// exit ;
51235: GO 51303
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
51237: LD_ADDR_VAR 0 1
51241: PUSH
51242: LD_VAR 0 1
51246: PPUSH
51247: LD_VAR 0 2
51251: PPUSH
51252: LD_VAR 0 1
51256: PUSH
51257: LD_VAR 0 3
51261: ARRAY
51262: PPUSH
51263: CALL_OW 1
51267: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
51268: LD_ADDR_VAR 0 1
51272: PUSH
51273: LD_VAR 0 1
51277: PPUSH
51278: LD_VAR 0 3
51282: PPUSH
51283: LD_VAR 0 5
51287: PPUSH
51288: CALL_OW 1
51292: ST_TO_ADDR
// result := list ;
51293: LD_ADDR_VAR 0 4
51297: PUSH
51298: LD_VAR 0 1
51302: ST_TO_ADDR
// end ;
51303: LD_VAR 0 4
51307: RET
// export function Add ( list , pos , val ) ; begin
51308: LD_INT 0
51310: PPUSH
// result := ReplaceIn ( list , pos , val ) end ;
51311: LD_ADDR_VAR 0 4
51315: PUSH
51316: LD_VAR 0 1
51320: PPUSH
51321: LD_VAR 0 2
51325: PPUSH
51326: LD_VAR 0 3
51330: PPUSH
51331: CALL 50873 0 3
51335: ST_TO_ADDR
51336: LD_VAR 0 4
51340: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
51341: LD_INT 0
51343: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
51344: LD_ADDR_VAR 0 5
51348: PUSH
51349: LD_VAR 0 1
51353: PPUSH
51354: CALL_OW 250
51358: PPUSH
51359: LD_VAR 0 1
51363: PPUSH
51364: CALL_OW 251
51368: PPUSH
51369: LD_VAR 0 2
51373: PPUSH
51374: LD_VAR 0 3
51378: PPUSH
51379: LD_VAR 0 4
51383: PPUSH
51384: CALL 51394 0 5
51388: ST_TO_ADDR
// end ;
51389: LD_VAR 0 5
51393: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
51394: LD_INT 0
51396: PPUSH
51397: PPUSH
51398: PPUSH
51399: PPUSH
// if not list then
51400: LD_VAR 0 3
51404: NOT
51405: IFFALSE 51409
// exit ;
51407: GO 51797
// result := [ ] ;
51409: LD_ADDR_VAR 0 6
51413: PUSH
51414: EMPTY
51415: ST_TO_ADDR
// for i in list do
51416: LD_ADDR_VAR 0 7
51420: PUSH
51421: LD_VAR 0 3
51425: PUSH
51426: FOR_IN
51427: IFFALSE 51629
// begin tmp := GetDistUnitXY ( i , x , y ) ;
51429: LD_ADDR_VAR 0 9
51433: PUSH
51434: LD_VAR 0 7
51438: PPUSH
51439: LD_VAR 0 1
51443: PPUSH
51444: LD_VAR 0 2
51448: PPUSH
51449: CALL_OW 297
51453: ST_TO_ADDR
// if not result then
51454: LD_VAR 0 6
51458: NOT
51459: IFFALSE 51485
// result := [ [ i , tmp ] ] else
51461: LD_ADDR_VAR 0 6
51465: PUSH
51466: LD_VAR 0 7
51470: PUSH
51471: LD_VAR 0 9
51475: PUSH
51476: EMPTY
51477: LIST
51478: LIST
51479: PUSH
51480: EMPTY
51481: LIST
51482: ST_TO_ADDR
51483: GO 51627
// begin if result [ result ] [ 2 ] < tmp then
51485: LD_VAR 0 6
51489: PUSH
51490: LD_VAR 0 6
51494: ARRAY
51495: PUSH
51496: LD_INT 2
51498: ARRAY
51499: PUSH
51500: LD_VAR 0 9
51504: LESS
51505: IFFALSE 51547
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
51507: LD_ADDR_VAR 0 6
51511: PUSH
51512: LD_VAR 0 6
51516: PPUSH
51517: LD_VAR 0 6
51521: PUSH
51522: LD_INT 1
51524: PLUS
51525: PPUSH
51526: LD_VAR 0 7
51530: PUSH
51531: LD_VAR 0 9
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: PPUSH
51540: CALL_OW 2
51544: ST_TO_ADDR
51545: GO 51627
// for j = 1 to result do
51547: LD_ADDR_VAR 0 8
51551: PUSH
51552: DOUBLE
51553: LD_INT 1
51555: DEC
51556: ST_TO_ADDR
51557: LD_VAR 0 6
51561: PUSH
51562: FOR_TO
51563: IFFALSE 51625
// begin if tmp < result [ j ] [ 2 ] then
51565: LD_VAR 0 9
51569: PUSH
51570: LD_VAR 0 6
51574: PUSH
51575: LD_VAR 0 8
51579: ARRAY
51580: PUSH
51581: LD_INT 2
51583: ARRAY
51584: LESS
51585: IFFALSE 51623
// begin result := Insert ( result , j , [ i , tmp ] ) ;
51587: LD_ADDR_VAR 0 6
51591: PUSH
51592: LD_VAR 0 6
51596: PPUSH
51597: LD_VAR 0 8
51601: PPUSH
51602: LD_VAR 0 7
51606: PUSH
51607: LD_VAR 0 9
51611: PUSH
51612: EMPTY
51613: LIST
51614: LIST
51615: PPUSH
51616: CALL_OW 2
51620: ST_TO_ADDR
// break ;
51621: GO 51625
// end ; end ;
51623: GO 51562
51625: POP
51626: POP
// end ; end ;
51627: GO 51426
51629: POP
51630: POP
// if result and not asc then
51631: LD_VAR 0 6
51635: PUSH
51636: LD_VAR 0 4
51640: NOT
51641: AND
51642: IFFALSE 51717
// begin tmp := result ;
51644: LD_ADDR_VAR 0 9
51648: PUSH
51649: LD_VAR 0 6
51653: ST_TO_ADDR
// for i = tmp downto 1 do
51654: LD_ADDR_VAR 0 7
51658: PUSH
51659: DOUBLE
51660: LD_VAR 0 9
51664: INC
51665: ST_TO_ADDR
51666: LD_INT 1
51668: PUSH
51669: FOR_DOWNTO
51670: IFFALSE 51715
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
51672: LD_ADDR_VAR 0 6
51676: PUSH
51677: LD_VAR 0 6
51681: PPUSH
51682: LD_VAR 0 9
51686: PUSH
51687: LD_VAR 0 7
51691: MINUS
51692: PUSH
51693: LD_INT 1
51695: PLUS
51696: PPUSH
51697: LD_VAR 0 9
51701: PUSH
51702: LD_VAR 0 7
51706: ARRAY
51707: PPUSH
51708: CALL_OW 1
51712: ST_TO_ADDR
51713: GO 51669
51715: POP
51716: POP
// end ; tmp := [ ] ;
51717: LD_ADDR_VAR 0 9
51721: PUSH
51722: EMPTY
51723: ST_TO_ADDR
// if mode then
51724: LD_VAR 0 5
51728: IFFALSE 51797
// begin for i = 1 to result do
51730: LD_ADDR_VAR 0 7
51734: PUSH
51735: DOUBLE
51736: LD_INT 1
51738: DEC
51739: ST_TO_ADDR
51740: LD_VAR 0 6
51744: PUSH
51745: FOR_TO
51746: IFFALSE 51785
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
51748: LD_ADDR_VAR 0 9
51752: PUSH
51753: LD_VAR 0 9
51757: PPUSH
51758: LD_VAR 0 7
51762: PPUSH
51763: LD_VAR 0 6
51767: PUSH
51768: LD_VAR 0 7
51772: ARRAY
51773: PUSH
51774: LD_INT 1
51776: ARRAY
51777: PPUSH
51778: CALL_OW 1
51782: ST_TO_ADDR
51783: GO 51745
51785: POP
51786: POP
// result := tmp ;
51787: LD_ADDR_VAR 0 6
51791: PUSH
51792: LD_VAR 0 9
51796: ST_TO_ADDR
// end ; end ;
51797: LD_VAR 0 6
51801: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
51802: LD_INT 0
51804: PPUSH
51805: PPUSH
51806: PPUSH
51807: PPUSH
51808: PPUSH
51809: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
51810: LD_ADDR_VAR 0 5
51814: PUSH
51815: LD_INT 0
51817: PUSH
51818: LD_INT 0
51820: PUSH
51821: LD_INT 0
51823: PUSH
51824: EMPTY
51825: PUSH
51826: EMPTY
51827: LIST
51828: LIST
51829: LIST
51830: LIST
51831: ST_TO_ADDR
// if not x or not y then
51832: LD_VAR 0 2
51836: NOT
51837: PUSH
51838: LD_VAR 0 3
51842: NOT
51843: OR
51844: IFFALSE 51848
// exit ;
51846: GO 53494
// if not range then
51848: LD_VAR 0 4
51852: NOT
51853: IFFALSE 51863
// range := 10 ;
51855: LD_ADDR_VAR 0 4
51859: PUSH
51860: LD_INT 10
51862: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51863: LD_ADDR_VAR 0 8
51867: PUSH
51868: LD_INT 81
51870: PUSH
51871: LD_VAR 0 1
51875: PUSH
51876: EMPTY
51877: LIST
51878: LIST
51879: PUSH
51880: LD_INT 92
51882: PUSH
51883: LD_VAR 0 2
51887: PUSH
51888: LD_VAR 0 3
51892: PUSH
51893: LD_VAR 0 4
51897: PUSH
51898: EMPTY
51899: LIST
51900: LIST
51901: LIST
51902: LIST
51903: PUSH
51904: LD_INT 3
51906: PUSH
51907: LD_INT 21
51909: PUSH
51910: LD_INT 3
51912: PUSH
51913: EMPTY
51914: LIST
51915: LIST
51916: PUSH
51917: EMPTY
51918: LIST
51919: LIST
51920: PUSH
51921: EMPTY
51922: LIST
51923: LIST
51924: LIST
51925: PPUSH
51926: CALL_OW 69
51930: ST_TO_ADDR
// if not tmp then
51931: LD_VAR 0 8
51935: NOT
51936: IFFALSE 51940
// exit ;
51938: GO 53494
// for i in tmp do
51940: LD_ADDR_VAR 0 6
51944: PUSH
51945: LD_VAR 0 8
51949: PUSH
51950: FOR_IN
51951: IFFALSE 53469
// begin points := [ 0 , 0 , 0 ] ;
51953: LD_ADDR_VAR 0 9
51957: PUSH
51958: LD_INT 0
51960: PUSH
51961: LD_INT 0
51963: PUSH
51964: LD_INT 0
51966: PUSH
51967: EMPTY
51968: LIST
51969: LIST
51970: LIST
51971: ST_TO_ADDR
// bpoints := 1 ;
51972: LD_ADDR_VAR 0 10
51976: PUSH
51977: LD_INT 1
51979: ST_TO_ADDR
// case GetType ( i ) of unit_human :
51980: LD_VAR 0 6
51984: PPUSH
51985: CALL_OW 247
51989: PUSH
51990: LD_INT 1
51992: DOUBLE
51993: EQUAL
51994: IFTRUE 51998
51996: GO 52576
51998: POP
// begin if GetClass ( i ) = 1 then
51999: LD_VAR 0 6
52003: PPUSH
52004: CALL_OW 257
52008: PUSH
52009: LD_INT 1
52011: EQUAL
52012: IFFALSE 52033
// points := [ 10 , 5 , 3 ] ;
52014: LD_ADDR_VAR 0 9
52018: PUSH
52019: LD_INT 10
52021: PUSH
52022: LD_INT 5
52024: PUSH
52025: LD_INT 3
52027: PUSH
52028: EMPTY
52029: LIST
52030: LIST
52031: LIST
52032: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
52033: LD_VAR 0 6
52037: PPUSH
52038: CALL_OW 257
52042: PUSH
52043: LD_INT 2
52045: PUSH
52046: LD_INT 3
52048: PUSH
52049: LD_INT 4
52051: PUSH
52052: EMPTY
52053: LIST
52054: LIST
52055: LIST
52056: IN
52057: IFFALSE 52078
// points := [ 3 , 2 , 1 ] ;
52059: LD_ADDR_VAR 0 9
52063: PUSH
52064: LD_INT 3
52066: PUSH
52067: LD_INT 2
52069: PUSH
52070: LD_INT 1
52072: PUSH
52073: EMPTY
52074: LIST
52075: LIST
52076: LIST
52077: ST_TO_ADDR
// if GetClass ( i ) = 5 then
52078: LD_VAR 0 6
52082: PPUSH
52083: CALL_OW 257
52087: PUSH
52088: LD_INT 5
52090: EQUAL
52091: IFFALSE 52112
// points := [ 130 , 5 , 2 ] ;
52093: LD_ADDR_VAR 0 9
52097: PUSH
52098: LD_INT 130
52100: PUSH
52101: LD_INT 5
52103: PUSH
52104: LD_INT 2
52106: PUSH
52107: EMPTY
52108: LIST
52109: LIST
52110: LIST
52111: ST_TO_ADDR
// if GetClass ( i ) = 8 then
52112: LD_VAR 0 6
52116: PPUSH
52117: CALL_OW 257
52121: PUSH
52122: LD_INT 8
52124: EQUAL
52125: IFFALSE 52146
// points := [ 35 , 35 , 30 ] ;
52127: LD_ADDR_VAR 0 9
52131: PUSH
52132: LD_INT 35
52134: PUSH
52135: LD_INT 35
52137: PUSH
52138: LD_INT 30
52140: PUSH
52141: EMPTY
52142: LIST
52143: LIST
52144: LIST
52145: ST_TO_ADDR
// if GetClass ( i ) = 9 then
52146: LD_VAR 0 6
52150: PPUSH
52151: CALL_OW 257
52155: PUSH
52156: LD_INT 9
52158: EQUAL
52159: IFFALSE 52180
// points := [ 20 , 55 , 40 ] ;
52161: LD_ADDR_VAR 0 9
52165: PUSH
52166: LD_INT 20
52168: PUSH
52169: LD_INT 55
52171: PUSH
52172: LD_INT 40
52174: PUSH
52175: EMPTY
52176: LIST
52177: LIST
52178: LIST
52179: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
52180: LD_VAR 0 6
52184: PPUSH
52185: CALL_OW 257
52189: PUSH
52190: LD_INT 12
52192: PUSH
52193: LD_INT 16
52195: PUSH
52196: EMPTY
52197: LIST
52198: LIST
52199: IN
52200: IFFALSE 52221
// points := [ 5 , 3 , 2 ] ;
52202: LD_ADDR_VAR 0 9
52206: PUSH
52207: LD_INT 5
52209: PUSH
52210: LD_INT 3
52212: PUSH
52213: LD_INT 2
52215: PUSH
52216: EMPTY
52217: LIST
52218: LIST
52219: LIST
52220: ST_TO_ADDR
// if GetClass ( i ) = 17 then
52221: LD_VAR 0 6
52225: PPUSH
52226: CALL_OW 257
52230: PUSH
52231: LD_INT 17
52233: EQUAL
52234: IFFALSE 52255
// points := [ 100 , 50 , 75 ] ;
52236: LD_ADDR_VAR 0 9
52240: PUSH
52241: LD_INT 100
52243: PUSH
52244: LD_INT 50
52246: PUSH
52247: LD_INT 75
52249: PUSH
52250: EMPTY
52251: LIST
52252: LIST
52253: LIST
52254: ST_TO_ADDR
// if GetClass ( i ) = 15 then
52255: LD_VAR 0 6
52259: PPUSH
52260: CALL_OW 257
52264: PUSH
52265: LD_INT 15
52267: EQUAL
52268: IFFALSE 52289
// points := [ 10 , 5 , 3 ] ;
52270: LD_ADDR_VAR 0 9
52274: PUSH
52275: LD_INT 10
52277: PUSH
52278: LD_INT 5
52280: PUSH
52281: LD_INT 3
52283: PUSH
52284: EMPTY
52285: LIST
52286: LIST
52287: LIST
52288: ST_TO_ADDR
// if GetClass ( i ) = 14 then
52289: LD_VAR 0 6
52293: PPUSH
52294: CALL_OW 257
52298: PUSH
52299: LD_INT 14
52301: EQUAL
52302: IFFALSE 52323
// points := [ 10 , 0 , 0 ] ;
52304: LD_ADDR_VAR 0 9
52308: PUSH
52309: LD_INT 10
52311: PUSH
52312: LD_INT 0
52314: PUSH
52315: LD_INT 0
52317: PUSH
52318: EMPTY
52319: LIST
52320: LIST
52321: LIST
52322: ST_TO_ADDR
// if GetClass ( i ) = 11 then
52323: LD_VAR 0 6
52327: PPUSH
52328: CALL_OW 257
52332: PUSH
52333: LD_INT 11
52335: EQUAL
52336: IFFALSE 52357
// points := [ 30 , 10 , 5 ] ;
52338: LD_ADDR_VAR 0 9
52342: PUSH
52343: LD_INT 30
52345: PUSH
52346: LD_INT 10
52348: PUSH
52349: LD_INT 5
52351: PUSH
52352: EMPTY
52353: LIST
52354: LIST
52355: LIST
52356: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
52357: LD_VAR 0 1
52361: PPUSH
52362: LD_INT 5
52364: PPUSH
52365: CALL_OW 321
52369: PUSH
52370: LD_INT 2
52372: EQUAL
52373: IFFALSE 52390
// bpoints := bpoints * 1.8 ;
52375: LD_ADDR_VAR 0 10
52379: PUSH
52380: LD_VAR 0 10
52384: PUSH
52385: LD_REAL  1.80000000000000E+0000
52388: MUL
52389: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
52390: LD_VAR 0 6
52394: PPUSH
52395: CALL_OW 257
52399: PUSH
52400: LD_INT 1
52402: PUSH
52403: LD_INT 2
52405: PUSH
52406: LD_INT 3
52408: PUSH
52409: LD_INT 4
52411: PUSH
52412: EMPTY
52413: LIST
52414: LIST
52415: LIST
52416: LIST
52417: IN
52418: PUSH
52419: LD_VAR 0 1
52423: PPUSH
52424: LD_INT 51
52426: PPUSH
52427: CALL_OW 321
52431: PUSH
52432: LD_INT 2
52434: EQUAL
52435: AND
52436: IFFALSE 52453
// bpoints := bpoints * 1.2 ;
52438: LD_ADDR_VAR 0 10
52442: PUSH
52443: LD_VAR 0 10
52447: PUSH
52448: LD_REAL  1.20000000000000E+0000
52451: MUL
52452: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
52453: LD_VAR 0 6
52457: PPUSH
52458: CALL_OW 257
52462: PUSH
52463: LD_INT 5
52465: PUSH
52466: LD_INT 7
52468: PUSH
52469: LD_INT 9
52471: PUSH
52472: EMPTY
52473: LIST
52474: LIST
52475: LIST
52476: IN
52477: PUSH
52478: LD_VAR 0 1
52482: PPUSH
52483: LD_INT 52
52485: PPUSH
52486: CALL_OW 321
52490: PUSH
52491: LD_INT 2
52493: EQUAL
52494: AND
52495: IFFALSE 52512
// bpoints := bpoints * 1.5 ;
52497: LD_ADDR_VAR 0 10
52501: PUSH
52502: LD_VAR 0 10
52506: PUSH
52507: LD_REAL  1.50000000000000E+0000
52510: MUL
52511: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
52512: LD_VAR 0 1
52516: PPUSH
52517: LD_INT 66
52519: PPUSH
52520: CALL_OW 321
52524: PUSH
52525: LD_INT 2
52527: EQUAL
52528: IFFALSE 52545
// bpoints := bpoints * 1.1 ;
52530: LD_ADDR_VAR 0 10
52534: PUSH
52535: LD_VAR 0 10
52539: PUSH
52540: LD_REAL  1.10000000000000E+0000
52543: MUL
52544: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
52545: LD_ADDR_VAR 0 10
52549: PUSH
52550: LD_VAR 0 10
52554: PUSH
52555: LD_VAR 0 6
52559: PPUSH
52560: LD_INT 1
52562: PPUSH
52563: CALL_OW 259
52567: PUSH
52568: LD_REAL  1.15000000000000E+0000
52571: MUL
52572: MUL
52573: ST_TO_ADDR
// end ; unit_vehicle :
52574: GO 53398
52576: LD_INT 2
52578: DOUBLE
52579: EQUAL
52580: IFTRUE 52584
52582: GO 53386
52584: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
52585: LD_VAR 0 6
52589: PPUSH
52590: CALL_OW 264
52594: PUSH
52595: LD_INT 2
52597: PUSH
52598: LD_INT 42
52600: PUSH
52601: LD_INT 24
52603: PUSH
52604: EMPTY
52605: LIST
52606: LIST
52607: LIST
52608: IN
52609: IFFALSE 52630
// points := [ 25 , 5 , 3 ] ;
52611: LD_ADDR_VAR 0 9
52615: PUSH
52616: LD_INT 25
52618: PUSH
52619: LD_INT 5
52621: PUSH
52622: LD_INT 3
52624: PUSH
52625: EMPTY
52626: LIST
52627: LIST
52628: LIST
52629: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
52630: LD_VAR 0 6
52634: PPUSH
52635: CALL_OW 264
52639: PUSH
52640: LD_INT 4
52642: PUSH
52643: LD_INT 43
52645: PUSH
52646: LD_INT 25
52648: PUSH
52649: EMPTY
52650: LIST
52651: LIST
52652: LIST
52653: IN
52654: IFFALSE 52675
// points := [ 40 , 15 , 5 ] ;
52656: LD_ADDR_VAR 0 9
52660: PUSH
52661: LD_INT 40
52663: PUSH
52664: LD_INT 15
52666: PUSH
52667: LD_INT 5
52669: PUSH
52670: EMPTY
52671: LIST
52672: LIST
52673: LIST
52674: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
52675: LD_VAR 0 6
52679: PPUSH
52680: CALL_OW 264
52684: PUSH
52685: LD_INT 3
52687: PUSH
52688: LD_INT 23
52690: PUSH
52691: EMPTY
52692: LIST
52693: LIST
52694: IN
52695: IFFALSE 52716
// points := [ 7 , 25 , 8 ] ;
52697: LD_ADDR_VAR 0 9
52701: PUSH
52702: LD_INT 7
52704: PUSH
52705: LD_INT 25
52707: PUSH
52708: LD_INT 8
52710: PUSH
52711: EMPTY
52712: LIST
52713: LIST
52714: LIST
52715: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
52716: LD_VAR 0 6
52720: PPUSH
52721: CALL_OW 264
52725: PUSH
52726: LD_INT 5
52728: PUSH
52729: LD_INT 27
52731: PUSH
52732: LD_INT 44
52734: PUSH
52735: EMPTY
52736: LIST
52737: LIST
52738: LIST
52739: IN
52740: IFFALSE 52761
// points := [ 14 , 50 , 16 ] ;
52742: LD_ADDR_VAR 0 9
52746: PUSH
52747: LD_INT 14
52749: PUSH
52750: LD_INT 50
52752: PUSH
52753: LD_INT 16
52755: PUSH
52756: EMPTY
52757: LIST
52758: LIST
52759: LIST
52760: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
52761: LD_VAR 0 6
52765: PPUSH
52766: CALL_OW 264
52770: PUSH
52771: LD_INT 6
52773: PUSH
52774: LD_INT 46
52776: PUSH
52777: EMPTY
52778: LIST
52779: LIST
52780: IN
52781: IFFALSE 52802
// points := [ 32 , 120 , 70 ] ;
52783: LD_ADDR_VAR 0 9
52787: PUSH
52788: LD_INT 32
52790: PUSH
52791: LD_INT 120
52793: PUSH
52794: LD_INT 70
52796: PUSH
52797: EMPTY
52798: LIST
52799: LIST
52800: LIST
52801: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
52802: LD_VAR 0 6
52806: PPUSH
52807: CALL_OW 264
52811: PUSH
52812: LD_INT 7
52814: PUSH
52815: LD_INT 28
52817: PUSH
52818: LD_INT 45
52820: PUSH
52821: EMPTY
52822: LIST
52823: LIST
52824: LIST
52825: IN
52826: IFFALSE 52847
// points := [ 35 , 20 , 45 ] ;
52828: LD_ADDR_VAR 0 9
52832: PUSH
52833: LD_INT 35
52835: PUSH
52836: LD_INT 20
52838: PUSH
52839: LD_INT 45
52841: PUSH
52842: EMPTY
52843: LIST
52844: LIST
52845: LIST
52846: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
52847: LD_VAR 0 6
52851: PPUSH
52852: CALL_OW 264
52856: PUSH
52857: LD_INT 47
52859: PUSH
52860: EMPTY
52861: LIST
52862: IN
52863: IFFALSE 52884
// points := [ 67 , 45 , 75 ] ;
52865: LD_ADDR_VAR 0 9
52869: PUSH
52870: LD_INT 67
52872: PUSH
52873: LD_INT 45
52875: PUSH
52876: LD_INT 75
52878: PUSH
52879: EMPTY
52880: LIST
52881: LIST
52882: LIST
52883: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
52884: LD_VAR 0 6
52888: PPUSH
52889: CALL_OW 264
52893: PUSH
52894: LD_INT 26
52896: PUSH
52897: EMPTY
52898: LIST
52899: IN
52900: IFFALSE 52921
// points := [ 120 , 30 , 80 ] ;
52902: LD_ADDR_VAR 0 9
52906: PUSH
52907: LD_INT 120
52909: PUSH
52910: LD_INT 30
52912: PUSH
52913: LD_INT 80
52915: PUSH
52916: EMPTY
52917: LIST
52918: LIST
52919: LIST
52920: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
52921: LD_VAR 0 6
52925: PPUSH
52926: CALL_OW 264
52930: PUSH
52931: LD_INT 22
52933: PUSH
52934: EMPTY
52935: LIST
52936: IN
52937: IFFALSE 52958
// points := [ 40 , 1 , 1 ] ;
52939: LD_ADDR_VAR 0 9
52943: PUSH
52944: LD_INT 40
52946: PUSH
52947: LD_INT 1
52949: PUSH
52950: LD_INT 1
52952: PUSH
52953: EMPTY
52954: LIST
52955: LIST
52956: LIST
52957: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
52958: LD_VAR 0 6
52962: PPUSH
52963: CALL_OW 264
52967: PUSH
52968: LD_INT 29
52970: PUSH
52971: EMPTY
52972: LIST
52973: IN
52974: IFFALSE 52995
// points := [ 70 , 200 , 400 ] ;
52976: LD_ADDR_VAR 0 9
52980: PUSH
52981: LD_INT 70
52983: PUSH
52984: LD_INT 200
52986: PUSH
52987: LD_INT 400
52989: PUSH
52990: EMPTY
52991: LIST
52992: LIST
52993: LIST
52994: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
52995: LD_VAR 0 6
52999: PPUSH
53000: CALL_OW 264
53004: PUSH
53005: LD_INT 14
53007: PUSH
53008: LD_INT 53
53010: PUSH
53011: EMPTY
53012: LIST
53013: LIST
53014: IN
53015: IFFALSE 53036
// points := [ 40 , 10 , 20 ] ;
53017: LD_ADDR_VAR 0 9
53021: PUSH
53022: LD_INT 40
53024: PUSH
53025: LD_INT 10
53027: PUSH
53028: LD_INT 20
53030: PUSH
53031: EMPTY
53032: LIST
53033: LIST
53034: LIST
53035: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
53036: LD_VAR 0 6
53040: PPUSH
53041: CALL_OW 264
53045: PUSH
53046: LD_INT 9
53048: PUSH
53049: EMPTY
53050: LIST
53051: IN
53052: IFFALSE 53073
// points := [ 5 , 70 , 20 ] ;
53054: LD_ADDR_VAR 0 9
53058: PUSH
53059: LD_INT 5
53061: PUSH
53062: LD_INT 70
53064: PUSH
53065: LD_INT 20
53067: PUSH
53068: EMPTY
53069: LIST
53070: LIST
53071: LIST
53072: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
53073: LD_VAR 0 6
53077: PPUSH
53078: CALL_OW 264
53082: PUSH
53083: LD_INT 10
53085: PUSH
53086: EMPTY
53087: LIST
53088: IN
53089: IFFALSE 53110
// points := [ 35 , 110 , 70 ] ;
53091: LD_ADDR_VAR 0 9
53095: PUSH
53096: LD_INT 35
53098: PUSH
53099: LD_INT 110
53101: PUSH
53102: LD_INT 70
53104: PUSH
53105: EMPTY
53106: LIST
53107: LIST
53108: LIST
53109: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
53110: LD_VAR 0 6
53114: PPUSH
53115: CALL_OW 265
53119: PUSH
53120: LD_INT 25
53122: EQUAL
53123: IFFALSE 53144
// points := [ 80 , 65 , 100 ] ;
53125: LD_ADDR_VAR 0 9
53129: PUSH
53130: LD_INT 80
53132: PUSH
53133: LD_INT 65
53135: PUSH
53136: LD_INT 100
53138: PUSH
53139: EMPTY
53140: LIST
53141: LIST
53142: LIST
53143: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
53144: LD_VAR 0 6
53148: PPUSH
53149: CALL_OW 263
53153: PUSH
53154: LD_INT 1
53156: EQUAL
53157: IFFALSE 53192
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
53159: LD_ADDR_VAR 0 10
53163: PUSH
53164: LD_VAR 0 10
53168: PUSH
53169: LD_VAR 0 6
53173: PPUSH
53174: CALL_OW 311
53178: PPUSH
53179: LD_INT 3
53181: PPUSH
53182: CALL_OW 259
53186: PUSH
53187: LD_INT 4
53189: MUL
53190: MUL
53191: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
53192: LD_VAR 0 6
53196: PPUSH
53197: CALL_OW 263
53201: PUSH
53202: LD_INT 2
53204: EQUAL
53205: IFFALSE 53256
// begin j := IsControledBy ( i ) ;
53207: LD_ADDR_VAR 0 7
53211: PUSH
53212: LD_VAR 0 6
53216: PPUSH
53217: CALL_OW 312
53221: ST_TO_ADDR
// if j then
53222: LD_VAR 0 7
53226: IFFALSE 53256
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
53228: LD_ADDR_VAR 0 10
53232: PUSH
53233: LD_VAR 0 10
53237: PUSH
53238: LD_VAR 0 7
53242: PPUSH
53243: LD_INT 3
53245: PPUSH
53246: CALL_OW 259
53250: PUSH
53251: LD_INT 3
53253: MUL
53254: MUL
53255: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
53256: LD_VAR 0 6
53260: PPUSH
53261: CALL_OW 264
53265: PUSH
53266: LD_INT 5
53268: PUSH
53269: LD_INT 6
53271: PUSH
53272: LD_INT 46
53274: PUSH
53275: LD_INT 44
53277: PUSH
53278: LD_INT 47
53280: PUSH
53281: LD_INT 45
53283: PUSH
53284: LD_INT 28
53286: PUSH
53287: LD_INT 7
53289: PUSH
53290: LD_INT 27
53292: PUSH
53293: LD_INT 29
53295: PUSH
53296: EMPTY
53297: LIST
53298: LIST
53299: LIST
53300: LIST
53301: LIST
53302: LIST
53303: LIST
53304: LIST
53305: LIST
53306: LIST
53307: IN
53308: PUSH
53309: LD_VAR 0 1
53313: PPUSH
53314: LD_INT 52
53316: PPUSH
53317: CALL_OW 321
53321: PUSH
53322: LD_INT 2
53324: EQUAL
53325: AND
53326: IFFALSE 53343
// bpoints := bpoints * 1.2 ;
53328: LD_ADDR_VAR 0 10
53332: PUSH
53333: LD_VAR 0 10
53337: PUSH
53338: LD_REAL  1.20000000000000E+0000
53341: MUL
53342: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
53343: LD_VAR 0 6
53347: PPUSH
53348: CALL_OW 264
53352: PUSH
53353: LD_INT 6
53355: PUSH
53356: LD_INT 46
53358: PUSH
53359: LD_INT 47
53361: PUSH
53362: EMPTY
53363: LIST
53364: LIST
53365: LIST
53366: IN
53367: IFFALSE 53384
// bpoints := bpoints * 1.2 ;
53369: LD_ADDR_VAR 0 10
53373: PUSH
53374: LD_VAR 0 10
53378: PUSH
53379: LD_REAL  1.20000000000000E+0000
53382: MUL
53383: ST_TO_ADDR
// end ; unit_building :
53384: GO 53398
53386: LD_INT 3
53388: DOUBLE
53389: EQUAL
53390: IFTRUE 53394
53392: GO 53397
53394: POP
// ; end ;
53395: GO 53398
53397: POP
// for j = 1 to 3 do
53398: LD_ADDR_VAR 0 7
53402: PUSH
53403: DOUBLE
53404: LD_INT 1
53406: DEC
53407: ST_TO_ADDR
53408: LD_INT 3
53410: PUSH
53411: FOR_TO
53412: IFFALSE 53465
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
53414: LD_ADDR_VAR 0 5
53418: PUSH
53419: LD_VAR 0 5
53423: PPUSH
53424: LD_VAR 0 7
53428: PPUSH
53429: LD_VAR 0 5
53433: PUSH
53434: LD_VAR 0 7
53438: ARRAY
53439: PUSH
53440: LD_VAR 0 9
53444: PUSH
53445: LD_VAR 0 7
53449: ARRAY
53450: PUSH
53451: LD_VAR 0 10
53455: MUL
53456: PLUS
53457: PPUSH
53458: CALL_OW 1
53462: ST_TO_ADDR
53463: GO 53411
53465: POP
53466: POP
// end ;
53467: GO 51950
53469: POP
53470: POP
// result := Replace ( result , 4 , tmp ) ;
53471: LD_ADDR_VAR 0 5
53475: PUSH
53476: LD_VAR 0 5
53480: PPUSH
53481: LD_INT 4
53483: PPUSH
53484: LD_VAR 0 8
53488: PPUSH
53489: CALL_OW 1
53493: ST_TO_ADDR
// end ;
53494: LD_VAR 0 5
53498: RET
// export function DangerAtRange ( unit , range ) ; begin
53499: LD_INT 0
53501: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
53502: LD_ADDR_VAR 0 3
53506: PUSH
53507: LD_VAR 0 1
53511: PPUSH
53512: CALL_OW 255
53516: PPUSH
53517: LD_VAR 0 1
53521: PPUSH
53522: CALL_OW 250
53526: PPUSH
53527: LD_VAR 0 1
53531: PPUSH
53532: CALL_OW 251
53536: PPUSH
53537: LD_VAR 0 2
53541: PPUSH
53542: CALL 51802 0 4
53546: ST_TO_ADDR
// end ;
53547: LD_VAR 0 3
53551: RET
// export function DangerInArea ( side , area ) ; begin
53552: LD_INT 0
53554: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
53555: LD_ADDR_VAR 0 3
53559: PUSH
53560: LD_VAR 0 2
53564: PPUSH
53565: LD_INT 81
53567: PUSH
53568: LD_VAR 0 1
53572: PUSH
53573: EMPTY
53574: LIST
53575: LIST
53576: PPUSH
53577: CALL_OW 70
53581: ST_TO_ADDR
// end ;
53582: LD_VAR 0 3
53586: RET
// export function IsExtension ( b ) ; begin
53587: LD_INT 0
53589: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
53590: LD_ADDR_VAR 0 2
53594: PUSH
53595: LD_VAR 0 1
53599: PUSH
53600: LD_INT 23
53602: PUSH
53603: LD_INT 20
53605: PUSH
53606: LD_INT 22
53608: PUSH
53609: LD_INT 17
53611: PUSH
53612: LD_INT 24
53614: PUSH
53615: LD_INT 21
53617: PUSH
53618: LD_INT 19
53620: PUSH
53621: LD_INT 16
53623: PUSH
53624: LD_INT 25
53626: PUSH
53627: LD_INT 18
53629: PUSH
53630: EMPTY
53631: LIST
53632: LIST
53633: LIST
53634: LIST
53635: LIST
53636: LIST
53637: LIST
53638: LIST
53639: LIST
53640: LIST
53641: IN
53642: ST_TO_ADDR
// end ;
53643: LD_VAR 0 2
53647: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
53648: LD_INT 0
53650: PPUSH
53651: PPUSH
53652: PPUSH
// result := [ ] ;
53653: LD_ADDR_VAR 0 3
53657: PUSH
53658: EMPTY
53659: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
53660: LD_ADDR_VAR 0 4
53664: PUSH
53665: LD_VAR 0 2
53669: PPUSH
53670: LD_INT 21
53672: PUSH
53673: LD_INT 3
53675: PUSH
53676: EMPTY
53677: LIST
53678: LIST
53679: PPUSH
53680: CALL_OW 70
53684: ST_TO_ADDR
// if not tmp then
53685: LD_VAR 0 4
53689: NOT
53690: IFFALSE 53694
// exit ;
53692: GO 53752
// for i in tmp do
53694: LD_ADDR_VAR 0 5
53698: PUSH
53699: LD_VAR 0 4
53703: PUSH
53704: FOR_IN
53705: IFFALSE 53740
// if GetBase ( i ) <> base then
53707: LD_VAR 0 5
53711: PPUSH
53712: CALL_OW 274
53716: PUSH
53717: LD_VAR 0 1
53721: NONEQUAL
53722: IFFALSE 53738
// ComLinkToBase ( base , i ) ;
53724: LD_VAR 0 1
53728: PPUSH
53729: LD_VAR 0 5
53733: PPUSH
53734: CALL_OW 169
53738: GO 53704
53740: POP
53741: POP
// result := tmp ;
53742: LD_ADDR_VAR 0 3
53746: PUSH
53747: LD_VAR 0 4
53751: ST_TO_ADDR
// end ;
53752: LD_VAR 0 3
53756: RET
// export function ComComplete ( unit , b ) ; var i ; begin
53757: LD_INT 0
53759: PPUSH
53760: PPUSH
// if BuildingStatus ( b ) = bs_build then
53761: LD_VAR 0 2
53765: PPUSH
53766: CALL_OW 461
53770: PUSH
53771: LD_INT 1
53773: EQUAL
53774: IFFALSE 53834
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
53776: LD_VAR 0 1
53780: PPUSH
53781: LD_STRING h
53783: PUSH
53784: LD_VAR 0 2
53788: PPUSH
53789: CALL_OW 250
53793: PUSH
53794: LD_VAR 0 2
53798: PPUSH
53799: CALL_OW 251
53803: PUSH
53804: LD_VAR 0 2
53808: PUSH
53809: LD_INT 0
53811: PUSH
53812: LD_INT 0
53814: PUSH
53815: LD_INT 0
53817: PUSH
53818: EMPTY
53819: LIST
53820: LIST
53821: LIST
53822: LIST
53823: LIST
53824: LIST
53825: LIST
53826: PUSH
53827: EMPTY
53828: LIST
53829: PPUSH
53830: CALL_OW 446
// end ;
53834: LD_VAR 0 3
53838: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
53839: LD_INT 0
53841: PPUSH
53842: PPUSH
53843: PPUSH
53844: PPUSH
53845: PPUSH
53846: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
53847: LD_VAR 0 1
53851: NOT
53852: PUSH
53853: LD_VAR 0 1
53857: PPUSH
53858: CALL_OW 263
53862: PUSH
53863: LD_INT 2
53865: EQUAL
53866: NOT
53867: OR
53868: IFFALSE 53872
// exit ;
53870: GO 54188
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
53872: LD_ADDR_VAR 0 6
53876: PUSH
53877: LD_INT 22
53879: PUSH
53880: LD_VAR 0 1
53884: PPUSH
53885: CALL_OW 255
53889: PUSH
53890: EMPTY
53891: LIST
53892: LIST
53893: PUSH
53894: LD_INT 2
53896: PUSH
53897: LD_INT 30
53899: PUSH
53900: LD_INT 36
53902: PUSH
53903: EMPTY
53904: LIST
53905: LIST
53906: PUSH
53907: LD_INT 34
53909: PUSH
53910: LD_INT 31
53912: PUSH
53913: EMPTY
53914: LIST
53915: LIST
53916: PUSH
53917: EMPTY
53918: LIST
53919: LIST
53920: LIST
53921: PUSH
53922: EMPTY
53923: LIST
53924: LIST
53925: PPUSH
53926: CALL_OW 69
53930: ST_TO_ADDR
// if not tmp then
53931: LD_VAR 0 6
53935: NOT
53936: IFFALSE 53940
// exit ;
53938: GO 54188
// result := [ ] ;
53940: LD_ADDR_VAR 0 2
53944: PUSH
53945: EMPTY
53946: ST_TO_ADDR
// for i in tmp do
53947: LD_ADDR_VAR 0 3
53951: PUSH
53952: LD_VAR 0 6
53956: PUSH
53957: FOR_IN
53958: IFFALSE 54029
// begin t := UnitsInside ( i ) ;
53960: LD_ADDR_VAR 0 4
53964: PUSH
53965: LD_VAR 0 3
53969: PPUSH
53970: CALL_OW 313
53974: ST_TO_ADDR
// if t then
53975: LD_VAR 0 4
53979: IFFALSE 54027
// for j in t do
53981: LD_ADDR_VAR 0 7
53985: PUSH
53986: LD_VAR 0 4
53990: PUSH
53991: FOR_IN
53992: IFFALSE 54025
// result := Insert ( result , result + 1 , j ) ;
53994: LD_ADDR_VAR 0 2
53998: PUSH
53999: LD_VAR 0 2
54003: PPUSH
54004: LD_VAR 0 2
54008: PUSH
54009: LD_INT 1
54011: PLUS
54012: PPUSH
54013: LD_VAR 0 7
54017: PPUSH
54018: CALL_OW 2
54022: ST_TO_ADDR
54023: GO 53991
54025: POP
54026: POP
// end ;
54027: GO 53957
54029: POP
54030: POP
// if not result then
54031: LD_VAR 0 2
54035: NOT
54036: IFFALSE 54040
// exit ;
54038: GO 54188
// mech := result [ 1 ] ;
54040: LD_ADDR_VAR 0 5
54044: PUSH
54045: LD_VAR 0 2
54049: PUSH
54050: LD_INT 1
54052: ARRAY
54053: ST_TO_ADDR
// if result > 1 then
54054: LD_VAR 0 2
54058: PUSH
54059: LD_INT 1
54061: GREATER
54062: IFFALSE 54174
// for i = 2 to result do
54064: LD_ADDR_VAR 0 3
54068: PUSH
54069: DOUBLE
54070: LD_INT 2
54072: DEC
54073: ST_TO_ADDR
54074: LD_VAR 0 2
54078: PUSH
54079: FOR_TO
54080: IFFALSE 54172
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
54082: LD_ADDR_VAR 0 4
54086: PUSH
54087: LD_VAR 0 2
54091: PUSH
54092: LD_VAR 0 3
54096: ARRAY
54097: PPUSH
54098: LD_INT 3
54100: PPUSH
54101: CALL_OW 259
54105: PUSH
54106: LD_VAR 0 2
54110: PUSH
54111: LD_VAR 0 3
54115: ARRAY
54116: PPUSH
54117: CALL_OW 432
54121: MINUS
54122: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
54123: LD_VAR 0 4
54127: PUSH
54128: LD_VAR 0 5
54132: PPUSH
54133: LD_INT 3
54135: PPUSH
54136: CALL_OW 259
54140: PUSH
54141: LD_VAR 0 5
54145: PPUSH
54146: CALL_OW 432
54150: MINUS
54151: GREATEREQUAL
54152: IFFALSE 54170
// mech := result [ i ] ;
54154: LD_ADDR_VAR 0 5
54158: PUSH
54159: LD_VAR 0 2
54163: PUSH
54164: LD_VAR 0 3
54168: ARRAY
54169: ST_TO_ADDR
// end ;
54170: GO 54079
54172: POP
54173: POP
// ComLinkTo ( vehicle , mech ) ;
54174: LD_VAR 0 1
54178: PPUSH
54179: LD_VAR 0 5
54183: PPUSH
54184: CALL_OW 135
// end ;
54188: LD_VAR 0 2
54192: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
54193: LD_INT 0
54195: PPUSH
54196: PPUSH
54197: PPUSH
54198: PPUSH
54199: PPUSH
54200: PPUSH
54201: PPUSH
54202: PPUSH
54203: PPUSH
54204: PPUSH
54205: PPUSH
54206: PPUSH
54207: PPUSH
// result := [ ] ;
54208: LD_ADDR_VAR 0 7
54212: PUSH
54213: EMPTY
54214: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
54215: LD_VAR 0 1
54219: PPUSH
54220: CALL_OW 266
54224: PUSH
54225: LD_INT 0
54227: PUSH
54228: LD_INT 1
54230: PUSH
54231: EMPTY
54232: LIST
54233: LIST
54234: IN
54235: NOT
54236: IFFALSE 54240
// exit ;
54238: GO 55769
// if name then
54240: LD_VAR 0 3
54244: IFFALSE 54260
// SetBName ( base_dep , name ) ;
54246: LD_VAR 0 1
54250: PPUSH
54251: LD_VAR 0 3
54255: PPUSH
54256: CALL_OW 500
// base := GetBase ( base_dep ) ;
54260: LD_ADDR_VAR 0 15
54264: PUSH
54265: LD_VAR 0 1
54269: PPUSH
54270: CALL_OW 274
54274: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
54275: LD_ADDR_VAR 0 16
54279: PUSH
54280: LD_VAR 0 1
54284: PPUSH
54285: CALL_OW 255
54289: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
54290: LD_ADDR_VAR 0 17
54294: PUSH
54295: LD_VAR 0 1
54299: PPUSH
54300: CALL_OW 248
54304: ST_TO_ADDR
// if sources then
54305: LD_VAR 0 5
54309: IFFALSE 54356
// for i = 1 to 3 do
54311: LD_ADDR_VAR 0 8
54315: PUSH
54316: DOUBLE
54317: LD_INT 1
54319: DEC
54320: ST_TO_ADDR
54321: LD_INT 3
54323: PUSH
54324: FOR_TO
54325: IFFALSE 54354
// AddResourceType ( base , i , sources [ i ] ) ;
54327: LD_VAR 0 15
54331: PPUSH
54332: LD_VAR 0 8
54336: PPUSH
54337: LD_VAR 0 5
54341: PUSH
54342: LD_VAR 0 8
54346: ARRAY
54347: PPUSH
54348: CALL_OW 276
54352: GO 54324
54354: POP
54355: POP
// buildings := GetBaseBuildings ( base , area ) ;
54356: LD_ADDR_VAR 0 18
54360: PUSH
54361: LD_VAR 0 15
54365: PPUSH
54366: LD_VAR 0 2
54370: PPUSH
54371: CALL 53648 0 2
54375: ST_TO_ADDR
// InitHc ;
54376: CALL_OW 19
// InitUc ;
54380: CALL_OW 18
// uc_side := side ;
54384: LD_ADDR_OWVAR 20
54388: PUSH
54389: LD_VAR 0 16
54393: ST_TO_ADDR
// uc_nation := nation ;
54394: LD_ADDR_OWVAR 21
54398: PUSH
54399: LD_VAR 0 17
54403: ST_TO_ADDR
// if buildings then
54404: LD_VAR 0 18
54408: IFFALSE 55628
// begin if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
54410: LD_VAR 0 18
54414: PPUSH
54415: LD_INT 2
54417: PUSH
54418: LD_INT 30
54420: PUSH
54421: LD_INT 32
54423: PUSH
54424: EMPTY
54425: LIST
54426: LIST
54427: PUSH
54428: LD_INT 30
54430: PUSH
54431: LD_INT 33
54433: PUSH
54434: EMPTY
54435: LIST
54436: LIST
54437: PUSH
54438: EMPTY
54439: LIST
54440: LIST
54441: LIST
54442: PPUSH
54443: CALL_OW 72
54447: IFFALSE 54535
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
54449: LD_ADDR_VAR 0 8
54453: PUSH
54454: LD_VAR 0 18
54458: PPUSH
54459: LD_INT 2
54461: PUSH
54462: LD_INT 30
54464: PUSH
54465: LD_INT 32
54467: PUSH
54468: EMPTY
54469: LIST
54470: LIST
54471: PUSH
54472: LD_INT 30
54474: PUSH
54475: LD_INT 33
54477: PUSH
54478: EMPTY
54479: LIST
54480: LIST
54481: PUSH
54482: EMPTY
54483: LIST
54484: LIST
54485: LIST
54486: PPUSH
54487: CALL_OW 72
54491: PUSH
54492: FOR_IN
54493: IFFALSE 54533
// begin if not GetBWeapon ( i ) then
54495: LD_VAR 0 8
54499: PPUSH
54500: CALL_OW 269
54504: NOT
54505: IFFALSE 54531
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
54507: LD_VAR 0 8
54511: PPUSH
54512: LD_VAR 0 8
54516: PPUSH
54517: LD_VAR 0 2
54521: PPUSH
54522: CALL 55774 0 2
54526: PPUSH
54527: CALL_OW 431
// end ;
54531: GO 54492
54533: POP
54534: POP
// end ; for i = 1 to personel do
54535: LD_ADDR_VAR 0 8
54539: PUSH
54540: DOUBLE
54541: LD_INT 1
54543: DEC
54544: ST_TO_ADDR
54545: LD_VAR 0 6
54549: PUSH
54550: FOR_TO
54551: IFFALSE 55608
// begin if i > 4 then
54553: LD_VAR 0 8
54557: PUSH
54558: LD_INT 4
54560: GREATER
54561: IFFALSE 54565
// break ;
54563: GO 55608
// case i of 1 :
54565: LD_VAR 0 8
54569: PUSH
54570: LD_INT 1
54572: DOUBLE
54573: EQUAL
54574: IFTRUE 54578
54576: GO 54651
54578: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
54579: LD_ADDR_VAR 0 12
54583: PUSH
54584: LD_VAR 0 18
54588: PPUSH
54589: LD_INT 22
54591: PUSH
54592: LD_VAR 0 16
54596: PUSH
54597: EMPTY
54598: LIST
54599: LIST
54600: PUSH
54601: LD_INT 2
54603: PUSH
54604: LD_INT 30
54606: PUSH
54607: LD_INT 32
54609: PUSH
54610: EMPTY
54611: LIST
54612: LIST
54613: PUSH
54614: LD_INT 30
54616: PUSH
54617: LD_INT 4
54619: PUSH
54620: EMPTY
54621: LIST
54622: LIST
54623: PUSH
54624: LD_INT 30
54626: PUSH
54627: LD_INT 5
54629: PUSH
54630: EMPTY
54631: LIST
54632: LIST
54633: PUSH
54634: EMPTY
54635: LIST
54636: LIST
54637: LIST
54638: LIST
54639: PUSH
54640: EMPTY
54641: LIST
54642: LIST
54643: PPUSH
54644: CALL_OW 72
54648: ST_TO_ADDR
54649: GO 54873
54651: LD_INT 2
54653: DOUBLE
54654: EQUAL
54655: IFTRUE 54659
54657: GO 54721
54659: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
54660: LD_ADDR_VAR 0 12
54664: PUSH
54665: LD_VAR 0 18
54669: PPUSH
54670: LD_INT 22
54672: PUSH
54673: LD_VAR 0 16
54677: PUSH
54678: EMPTY
54679: LIST
54680: LIST
54681: PUSH
54682: LD_INT 2
54684: PUSH
54685: LD_INT 30
54687: PUSH
54688: LD_INT 0
54690: PUSH
54691: EMPTY
54692: LIST
54693: LIST
54694: PUSH
54695: LD_INT 30
54697: PUSH
54698: LD_INT 1
54700: PUSH
54701: EMPTY
54702: LIST
54703: LIST
54704: PUSH
54705: EMPTY
54706: LIST
54707: LIST
54708: LIST
54709: PUSH
54710: EMPTY
54711: LIST
54712: LIST
54713: PPUSH
54714: CALL_OW 72
54718: ST_TO_ADDR
54719: GO 54873
54721: LD_INT 3
54723: DOUBLE
54724: EQUAL
54725: IFTRUE 54729
54727: GO 54791
54729: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
54730: LD_ADDR_VAR 0 12
54734: PUSH
54735: LD_VAR 0 18
54739: PPUSH
54740: LD_INT 22
54742: PUSH
54743: LD_VAR 0 16
54747: PUSH
54748: EMPTY
54749: LIST
54750: LIST
54751: PUSH
54752: LD_INT 2
54754: PUSH
54755: LD_INT 30
54757: PUSH
54758: LD_INT 2
54760: PUSH
54761: EMPTY
54762: LIST
54763: LIST
54764: PUSH
54765: LD_INT 30
54767: PUSH
54768: LD_INT 3
54770: PUSH
54771: EMPTY
54772: LIST
54773: LIST
54774: PUSH
54775: EMPTY
54776: LIST
54777: LIST
54778: LIST
54779: PUSH
54780: EMPTY
54781: LIST
54782: LIST
54783: PPUSH
54784: CALL_OW 72
54788: ST_TO_ADDR
54789: GO 54873
54791: LD_INT 4
54793: DOUBLE
54794: EQUAL
54795: IFTRUE 54799
54797: GO 54872
54799: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
54800: LD_ADDR_VAR 0 12
54804: PUSH
54805: LD_VAR 0 18
54809: PPUSH
54810: LD_INT 22
54812: PUSH
54813: LD_VAR 0 16
54817: PUSH
54818: EMPTY
54819: LIST
54820: LIST
54821: PUSH
54822: LD_INT 2
54824: PUSH
54825: LD_INT 30
54827: PUSH
54828: LD_INT 6
54830: PUSH
54831: EMPTY
54832: LIST
54833: LIST
54834: PUSH
54835: LD_INT 30
54837: PUSH
54838: LD_INT 7
54840: PUSH
54841: EMPTY
54842: LIST
54843: LIST
54844: PUSH
54845: LD_INT 30
54847: PUSH
54848: LD_INT 8
54850: PUSH
54851: EMPTY
54852: LIST
54853: LIST
54854: PUSH
54855: EMPTY
54856: LIST
54857: LIST
54858: LIST
54859: LIST
54860: PUSH
54861: EMPTY
54862: LIST
54863: LIST
54864: PPUSH
54865: CALL_OW 72
54869: ST_TO_ADDR
54870: GO 54873
54872: POP
// if i = 1 then
54873: LD_VAR 0 8
54877: PUSH
54878: LD_INT 1
54880: EQUAL
54881: IFFALSE 54992
// begin tmp := [ ] ;
54883: LD_ADDR_VAR 0 19
54887: PUSH
54888: EMPTY
54889: ST_TO_ADDR
// for j in f do
54890: LD_ADDR_VAR 0 9
54894: PUSH
54895: LD_VAR 0 12
54899: PUSH
54900: FOR_IN
54901: IFFALSE 54974
// if GetBType ( j ) = b_bunker then
54903: LD_VAR 0 9
54907: PPUSH
54908: CALL_OW 266
54912: PUSH
54913: LD_INT 32
54915: EQUAL
54916: IFFALSE 54943
// tmp := Insert ( tmp , 1 , j ) else
54918: LD_ADDR_VAR 0 19
54922: PUSH
54923: LD_VAR 0 19
54927: PPUSH
54928: LD_INT 1
54930: PPUSH
54931: LD_VAR 0 9
54935: PPUSH
54936: CALL_OW 2
54940: ST_TO_ADDR
54941: GO 54972
// tmp := Insert ( tmp , tmp + 1 , j ) ;
54943: LD_ADDR_VAR 0 19
54947: PUSH
54948: LD_VAR 0 19
54952: PPUSH
54953: LD_VAR 0 19
54957: PUSH
54958: LD_INT 1
54960: PLUS
54961: PPUSH
54962: LD_VAR 0 9
54966: PPUSH
54967: CALL_OW 2
54971: ST_TO_ADDR
54972: GO 54900
54974: POP
54975: POP
// if tmp then
54976: LD_VAR 0 19
54980: IFFALSE 54992
// f := tmp ;
54982: LD_ADDR_VAR 0 12
54986: PUSH
54987: LD_VAR 0 19
54991: ST_TO_ADDR
// end ; x := personel [ i ] ;
54992: LD_ADDR_VAR 0 13
54996: PUSH
54997: LD_VAR 0 6
55001: PUSH
55002: LD_VAR 0 8
55006: ARRAY
55007: ST_TO_ADDR
// if x = - 1 then
55008: LD_VAR 0 13
55012: PUSH
55013: LD_INT 1
55015: NEG
55016: EQUAL
55017: IFFALSE 55226
// begin for j in f do
55019: LD_ADDR_VAR 0 9
55023: PUSH
55024: LD_VAR 0 12
55028: PUSH
55029: FOR_IN
55030: IFFALSE 55222
// repeat InitHc ;
55032: CALL_OW 19
// if GetBType ( j ) = b_barracks then
55036: LD_VAR 0 9
55040: PPUSH
55041: CALL_OW 266
55045: PUSH
55046: LD_INT 5
55048: EQUAL
55049: IFFALSE 55119
// begin if UnitsInside ( j ) < 3 then
55051: LD_VAR 0 9
55055: PPUSH
55056: CALL_OW 313
55060: PUSH
55061: LD_INT 3
55063: LESS
55064: IFFALSE 55100
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
55066: LD_INT 0
55068: PPUSH
55069: LD_INT 5
55071: PUSH
55072: LD_INT 8
55074: PUSH
55075: LD_INT 9
55077: PUSH
55078: EMPTY
55079: LIST
55080: LIST
55081: LIST
55082: PUSH
55083: LD_VAR 0 17
55087: ARRAY
55088: PPUSH
55089: LD_VAR 0 4
55093: PPUSH
55094: CALL_OW 380
55098: GO 55117
// PrepareHuman ( false , i , skill ) ;
55100: LD_INT 0
55102: PPUSH
55103: LD_VAR 0 8
55107: PPUSH
55108: LD_VAR 0 4
55112: PPUSH
55113: CALL_OW 380
// end else
55117: GO 55136
// PrepareHuman ( false , i , skill ) ;
55119: LD_INT 0
55121: PPUSH
55122: LD_VAR 0 8
55126: PPUSH
55127: LD_VAR 0 4
55131: PPUSH
55132: CALL_OW 380
// un := CreateHuman ;
55136: LD_ADDR_VAR 0 14
55140: PUSH
55141: CALL_OW 44
55145: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
55146: LD_ADDR_VAR 0 7
55150: PUSH
55151: LD_VAR 0 7
55155: PPUSH
55156: LD_INT 1
55158: PPUSH
55159: LD_VAR 0 14
55163: PPUSH
55164: CALL_OW 2
55168: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
55169: LD_VAR 0 14
55173: PPUSH
55174: LD_VAR 0 9
55178: PPUSH
55179: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
55183: LD_VAR 0 9
55187: PPUSH
55188: CALL_OW 313
55192: PUSH
55193: LD_INT 6
55195: EQUAL
55196: PUSH
55197: LD_VAR 0 9
55201: PPUSH
55202: CALL_OW 266
55206: PUSH
55207: LD_INT 32
55209: PUSH
55210: LD_INT 31
55212: PUSH
55213: EMPTY
55214: LIST
55215: LIST
55216: IN
55217: OR
55218: IFFALSE 55032
55220: GO 55029
55222: POP
55223: POP
// end else
55224: GO 55606
// for j = 1 to x do
55226: LD_ADDR_VAR 0 9
55230: PUSH
55231: DOUBLE
55232: LD_INT 1
55234: DEC
55235: ST_TO_ADDR
55236: LD_VAR 0 13
55240: PUSH
55241: FOR_TO
55242: IFFALSE 55604
// begin InitHc ;
55244: CALL_OW 19
// if not f then
55248: LD_VAR 0 12
55252: NOT
55253: IFFALSE 55342
// begin PrepareHuman ( false , i , skill ) ;
55255: LD_INT 0
55257: PPUSH
55258: LD_VAR 0 8
55262: PPUSH
55263: LD_VAR 0 4
55267: PPUSH
55268: CALL_OW 380
// un := CreateHuman ;
55272: LD_ADDR_VAR 0 14
55276: PUSH
55277: CALL_OW 44
55281: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
55282: LD_ADDR_VAR 0 7
55286: PUSH
55287: LD_VAR 0 7
55291: PPUSH
55292: LD_INT 1
55294: PPUSH
55295: LD_VAR 0 14
55299: PPUSH
55300: CALL_OW 2
55304: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
55305: LD_VAR 0 14
55309: PPUSH
55310: LD_VAR 0 1
55314: PPUSH
55315: CALL_OW 250
55319: PPUSH
55320: LD_VAR 0 1
55324: PPUSH
55325: CALL_OW 251
55329: PPUSH
55330: LD_INT 10
55332: PPUSH
55333: LD_INT 0
55335: PPUSH
55336: CALL_OW 50
// continue ;
55340: GO 55241
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
55342: LD_VAR 0 12
55346: PUSH
55347: LD_INT 1
55349: ARRAY
55350: PPUSH
55351: CALL_OW 313
55355: PUSH
55356: LD_VAR 0 12
55360: PUSH
55361: LD_INT 1
55363: ARRAY
55364: PPUSH
55365: CALL_OW 266
55369: PUSH
55370: LD_INT 32
55372: PUSH
55373: LD_INT 31
55375: PUSH
55376: EMPTY
55377: LIST
55378: LIST
55379: IN
55380: AND
55381: PUSH
55382: LD_VAR 0 12
55386: PUSH
55387: LD_INT 1
55389: ARRAY
55390: PPUSH
55391: CALL_OW 313
55395: PUSH
55396: LD_INT 6
55398: EQUAL
55399: OR
55400: IFFALSE 55420
// f := Delete ( f , 1 ) ;
55402: LD_ADDR_VAR 0 12
55406: PUSH
55407: LD_VAR 0 12
55411: PPUSH
55412: LD_INT 1
55414: PPUSH
55415: CALL_OW 3
55419: ST_TO_ADDR
// if not f then
55420: LD_VAR 0 12
55424: NOT
55425: IFFALSE 55443
// begin x := x + 2 ;
55427: LD_ADDR_VAR 0 13
55431: PUSH
55432: LD_VAR 0 13
55436: PUSH
55437: LD_INT 2
55439: PLUS
55440: ST_TO_ADDR
// continue ;
55441: GO 55241
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
55443: LD_VAR 0 12
55447: PUSH
55448: LD_INT 1
55450: ARRAY
55451: PPUSH
55452: CALL_OW 266
55456: PUSH
55457: LD_INT 5
55459: EQUAL
55460: IFFALSE 55534
// begin if UnitsInside ( f [ 1 ] ) < 3 then
55462: LD_VAR 0 12
55466: PUSH
55467: LD_INT 1
55469: ARRAY
55470: PPUSH
55471: CALL_OW 313
55475: PUSH
55476: LD_INT 3
55478: LESS
55479: IFFALSE 55515
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
55481: LD_INT 0
55483: PPUSH
55484: LD_INT 5
55486: PUSH
55487: LD_INT 8
55489: PUSH
55490: LD_INT 9
55492: PUSH
55493: EMPTY
55494: LIST
55495: LIST
55496: LIST
55497: PUSH
55498: LD_VAR 0 17
55502: ARRAY
55503: PPUSH
55504: LD_VAR 0 4
55508: PPUSH
55509: CALL_OW 380
55513: GO 55532
// PrepareHuman ( false , i , skill ) ;
55515: LD_INT 0
55517: PPUSH
55518: LD_VAR 0 8
55522: PPUSH
55523: LD_VAR 0 4
55527: PPUSH
55528: CALL_OW 380
// end else
55532: GO 55551
// PrepareHuman ( false , i , skill ) ;
55534: LD_INT 0
55536: PPUSH
55537: LD_VAR 0 8
55541: PPUSH
55542: LD_VAR 0 4
55546: PPUSH
55547: CALL_OW 380
// un := CreateHuman ;
55551: LD_ADDR_VAR 0 14
55555: PUSH
55556: CALL_OW 44
55560: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
55561: LD_ADDR_VAR 0 7
55565: PUSH
55566: LD_VAR 0 7
55570: PPUSH
55571: LD_INT 1
55573: PPUSH
55574: LD_VAR 0 14
55578: PPUSH
55579: CALL_OW 2
55583: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
55584: LD_VAR 0 14
55588: PPUSH
55589: LD_VAR 0 12
55593: PUSH
55594: LD_INT 1
55596: ARRAY
55597: PPUSH
55598: CALL_OW 52
// end ;
55602: GO 55241
55604: POP
55605: POP
// end ;
55606: GO 54550
55608: POP
55609: POP
// result := result ^ buildings ;
55610: LD_ADDR_VAR 0 7
55614: PUSH
55615: LD_VAR 0 7
55619: PUSH
55620: LD_VAR 0 18
55624: ADD
55625: ST_TO_ADDR
// end else
55626: GO 55769
// begin for i = 1 to personel do
55628: LD_ADDR_VAR 0 8
55632: PUSH
55633: DOUBLE
55634: LD_INT 1
55636: DEC
55637: ST_TO_ADDR
55638: LD_VAR 0 6
55642: PUSH
55643: FOR_TO
55644: IFFALSE 55767
// begin if i > 4 then
55646: LD_VAR 0 8
55650: PUSH
55651: LD_INT 4
55653: GREATER
55654: IFFALSE 55658
// break ;
55656: GO 55767
// x := personel [ i ] ;
55658: LD_ADDR_VAR 0 13
55662: PUSH
55663: LD_VAR 0 6
55667: PUSH
55668: LD_VAR 0 8
55672: ARRAY
55673: ST_TO_ADDR
// if x = - 1 then
55674: LD_VAR 0 13
55678: PUSH
55679: LD_INT 1
55681: NEG
55682: EQUAL
55683: IFFALSE 55687
// continue ;
55685: GO 55643
// PrepareHuman ( false , i , skill ) ;
55687: LD_INT 0
55689: PPUSH
55690: LD_VAR 0 8
55694: PPUSH
55695: LD_VAR 0 4
55699: PPUSH
55700: CALL_OW 380
// un := CreateHuman ;
55704: LD_ADDR_VAR 0 14
55708: PUSH
55709: CALL_OW 44
55713: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
55714: LD_VAR 0 14
55718: PPUSH
55719: LD_VAR 0 1
55723: PPUSH
55724: CALL_OW 250
55728: PPUSH
55729: LD_VAR 0 1
55733: PPUSH
55734: CALL_OW 251
55738: PPUSH
55739: LD_INT 10
55741: PPUSH
55742: LD_INT 0
55744: PPUSH
55745: CALL_OW 50
// result := result ^ un ;
55749: LD_ADDR_VAR 0 7
55753: PUSH
55754: LD_VAR 0 7
55758: PUSH
55759: LD_VAR 0 14
55763: ADD
55764: ST_TO_ADDR
// end ;
55765: GO 55643
55767: POP
55768: POP
// end ; end ;
55769: LD_VAR 0 7
55773: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
55774: LD_INT 0
55776: PPUSH
55777: PPUSH
55778: PPUSH
55779: PPUSH
55780: PPUSH
55781: PPUSH
55782: PPUSH
55783: PPUSH
55784: PPUSH
55785: PPUSH
55786: PPUSH
55787: PPUSH
55788: PPUSH
55789: PPUSH
55790: PPUSH
55791: PPUSH
// result := false ;
55792: LD_ADDR_VAR 0 3
55796: PUSH
55797: LD_INT 0
55799: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
55800: LD_VAR 0 1
55804: NOT
55805: PUSH
55806: LD_VAR 0 1
55810: PPUSH
55811: CALL_OW 266
55815: PUSH
55816: LD_INT 32
55818: PUSH
55819: LD_INT 33
55821: PUSH
55822: EMPTY
55823: LIST
55824: LIST
55825: IN
55826: NOT
55827: OR
55828: IFFALSE 55832
// exit ;
55830: GO 56968
// nat := GetNation ( tower ) ;
55832: LD_ADDR_VAR 0 12
55836: PUSH
55837: LD_VAR 0 1
55841: PPUSH
55842: CALL_OW 248
55846: ST_TO_ADDR
// side := GetSide ( tower ) ;
55847: LD_ADDR_VAR 0 16
55851: PUSH
55852: LD_VAR 0 1
55856: PPUSH
55857: CALL_OW 255
55861: ST_TO_ADDR
// x := GetX ( tower ) ;
55862: LD_ADDR_VAR 0 10
55866: PUSH
55867: LD_VAR 0 1
55871: PPUSH
55872: CALL_OW 250
55876: ST_TO_ADDR
// y := GetY ( tower ) ;
55877: LD_ADDR_VAR 0 11
55881: PUSH
55882: LD_VAR 0 1
55886: PPUSH
55887: CALL_OW 251
55891: ST_TO_ADDR
// if not x or not y then
55892: LD_VAR 0 10
55896: NOT
55897: PUSH
55898: LD_VAR 0 11
55902: NOT
55903: OR
55904: IFFALSE 55908
// exit ;
55906: GO 56968
// weapon := 0 ;
55908: LD_ADDR_VAR 0 18
55912: PUSH
55913: LD_INT 0
55915: ST_TO_ADDR
// fac_list := [ ] ;
55916: LD_ADDR_VAR 0 17
55920: PUSH
55921: EMPTY
55922: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
55923: LD_ADDR_VAR 0 6
55927: PUSH
55928: LD_VAR 0 1
55932: PPUSH
55933: CALL_OW 274
55937: PPUSH
55938: LD_VAR 0 2
55942: PPUSH
55943: CALL 53648 0 2
55947: PPUSH
55948: LD_INT 30
55950: PUSH
55951: LD_INT 3
55953: PUSH
55954: EMPTY
55955: LIST
55956: LIST
55957: PPUSH
55958: CALL_OW 72
55962: ST_TO_ADDR
// if not factories then
55963: LD_VAR 0 6
55967: NOT
55968: IFFALSE 55972
// exit ;
55970: GO 56968
// for i in factories do
55972: LD_ADDR_VAR 0 8
55976: PUSH
55977: LD_VAR 0 6
55981: PUSH
55982: FOR_IN
55983: IFFALSE 56008
// fac_list := fac_list union AvailableWeaponList ( i ) ;
55985: LD_ADDR_VAR 0 17
55989: PUSH
55990: LD_VAR 0 17
55994: PUSH
55995: LD_VAR 0 8
55999: PPUSH
56000: CALL_OW 478
56004: UNION
56005: ST_TO_ADDR
56006: GO 55982
56008: POP
56009: POP
// if not fac_list then
56010: LD_VAR 0 17
56014: NOT
56015: IFFALSE 56019
// exit ;
56017: GO 56968
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
56019: LD_ADDR_VAR 0 5
56023: PUSH
56024: LD_INT 4
56026: PUSH
56027: LD_INT 5
56029: PUSH
56030: LD_INT 9
56032: PUSH
56033: LD_INT 10
56035: PUSH
56036: LD_INT 6
56038: PUSH
56039: LD_INT 7
56041: PUSH
56042: LD_INT 11
56044: PUSH
56045: EMPTY
56046: LIST
56047: LIST
56048: LIST
56049: LIST
56050: LIST
56051: LIST
56052: LIST
56053: PUSH
56054: LD_INT 27
56056: PUSH
56057: LD_INT 28
56059: PUSH
56060: LD_INT 26
56062: PUSH
56063: LD_INT 30
56065: PUSH
56066: EMPTY
56067: LIST
56068: LIST
56069: LIST
56070: LIST
56071: PUSH
56072: LD_INT 43
56074: PUSH
56075: LD_INT 44
56077: PUSH
56078: LD_INT 46
56080: PUSH
56081: LD_INT 45
56083: PUSH
56084: LD_INT 47
56086: PUSH
56087: LD_INT 49
56089: PUSH
56090: EMPTY
56091: LIST
56092: LIST
56093: LIST
56094: LIST
56095: LIST
56096: LIST
56097: PUSH
56098: EMPTY
56099: LIST
56100: LIST
56101: LIST
56102: PUSH
56103: LD_VAR 0 12
56107: ARRAY
56108: ST_TO_ADDR
// for i in list do
56109: LD_ADDR_VAR 0 8
56113: PUSH
56114: LD_VAR 0 5
56118: PUSH
56119: FOR_IN
56120: IFFALSE 56153
// if not i in fac_list then
56122: LD_VAR 0 8
56126: PUSH
56127: LD_VAR 0 17
56131: IN
56132: NOT
56133: IFFALSE 56151
// list := list diff i ;
56135: LD_ADDR_VAR 0 5
56139: PUSH
56140: LD_VAR 0 5
56144: PUSH
56145: LD_VAR 0 8
56149: DIFF
56150: ST_TO_ADDR
56151: GO 56119
56153: POP
56154: POP
// if not list then
56155: LD_VAR 0 5
56159: NOT
56160: IFFALSE 56164
// exit ;
56162: GO 56968
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
56164: LD_VAR 0 12
56168: PUSH
56169: LD_INT 3
56171: EQUAL
56172: PUSH
56173: LD_INT 49
56175: PUSH
56176: LD_VAR 0 5
56180: IN
56181: AND
56182: PUSH
56183: LD_INT 31
56185: PPUSH
56186: LD_VAR 0 16
56190: PPUSH
56191: CALL_OW 321
56195: PUSH
56196: LD_INT 2
56198: EQUAL
56199: AND
56200: IFFALSE 56260
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
56202: LD_INT 22
56204: PUSH
56205: LD_VAR 0 16
56209: PUSH
56210: EMPTY
56211: LIST
56212: LIST
56213: PUSH
56214: LD_INT 35
56216: PUSH
56217: LD_INT 49
56219: PUSH
56220: EMPTY
56221: LIST
56222: LIST
56223: PUSH
56224: LD_INT 91
56226: PUSH
56227: LD_VAR 0 1
56231: PUSH
56232: LD_INT 10
56234: PUSH
56235: EMPTY
56236: LIST
56237: LIST
56238: LIST
56239: PUSH
56240: EMPTY
56241: LIST
56242: LIST
56243: LIST
56244: PPUSH
56245: CALL_OW 69
56249: NOT
56250: IFFALSE 56260
// weapon := ru_time_lapser ;
56252: LD_ADDR_VAR 0 18
56256: PUSH
56257: LD_INT 49
56259: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
56260: LD_VAR 0 12
56264: PUSH
56265: LD_INT 1
56267: PUSH
56268: LD_INT 2
56270: PUSH
56271: EMPTY
56272: LIST
56273: LIST
56274: IN
56275: PUSH
56276: LD_INT 11
56278: PUSH
56279: LD_VAR 0 5
56283: IN
56284: PUSH
56285: LD_INT 30
56287: PUSH
56288: LD_VAR 0 5
56292: IN
56293: OR
56294: AND
56295: PUSH
56296: LD_INT 6
56298: PPUSH
56299: LD_VAR 0 16
56303: PPUSH
56304: CALL_OW 321
56308: PUSH
56309: LD_INT 2
56311: EQUAL
56312: AND
56313: IFFALSE 56478
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
56315: LD_INT 22
56317: PUSH
56318: LD_VAR 0 16
56322: PUSH
56323: EMPTY
56324: LIST
56325: LIST
56326: PUSH
56327: LD_INT 2
56329: PUSH
56330: LD_INT 35
56332: PUSH
56333: LD_INT 11
56335: PUSH
56336: EMPTY
56337: LIST
56338: LIST
56339: PUSH
56340: LD_INT 35
56342: PUSH
56343: LD_INT 30
56345: PUSH
56346: EMPTY
56347: LIST
56348: LIST
56349: PUSH
56350: EMPTY
56351: LIST
56352: LIST
56353: LIST
56354: PUSH
56355: LD_INT 91
56357: PUSH
56358: LD_VAR 0 1
56362: PUSH
56363: LD_INT 18
56365: PUSH
56366: EMPTY
56367: LIST
56368: LIST
56369: LIST
56370: PUSH
56371: EMPTY
56372: LIST
56373: LIST
56374: LIST
56375: PPUSH
56376: CALL_OW 69
56380: NOT
56381: PUSH
56382: LD_INT 22
56384: PUSH
56385: LD_VAR 0 16
56389: PUSH
56390: EMPTY
56391: LIST
56392: LIST
56393: PUSH
56394: LD_INT 2
56396: PUSH
56397: LD_INT 30
56399: PUSH
56400: LD_INT 32
56402: PUSH
56403: EMPTY
56404: LIST
56405: LIST
56406: PUSH
56407: LD_INT 30
56409: PUSH
56410: LD_INT 33
56412: PUSH
56413: EMPTY
56414: LIST
56415: LIST
56416: PUSH
56417: EMPTY
56418: LIST
56419: LIST
56420: LIST
56421: PUSH
56422: LD_INT 91
56424: PUSH
56425: LD_VAR 0 1
56429: PUSH
56430: LD_INT 12
56432: PUSH
56433: EMPTY
56434: LIST
56435: LIST
56436: LIST
56437: PUSH
56438: EMPTY
56439: LIST
56440: LIST
56441: LIST
56442: PUSH
56443: EMPTY
56444: LIST
56445: PPUSH
56446: CALL_OW 69
56450: PUSH
56451: LD_INT 2
56453: GREATER
56454: AND
56455: IFFALSE 56478
// weapon := [ us_radar , ar_radar ] [ nat ] ;
56457: LD_ADDR_VAR 0 18
56461: PUSH
56462: LD_INT 11
56464: PUSH
56465: LD_INT 30
56467: PUSH
56468: EMPTY
56469: LIST
56470: LIST
56471: PUSH
56472: LD_VAR 0 12
56476: ARRAY
56477: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
56478: LD_VAR 0 18
56482: NOT
56483: PUSH
56484: LD_INT 40
56486: PPUSH
56487: LD_VAR 0 16
56491: PPUSH
56492: CALL_OW 321
56496: PUSH
56497: LD_INT 2
56499: EQUAL
56500: AND
56501: PUSH
56502: LD_INT 7
56504: PUSH
56505: LD_VAR 0 5
56509: IN
56510: PUSH
56511: LD_INT 28
56513: PUSH
56514: LD_VAR 0 5
56518: IN
56519: OR
56520: PUSH
56521: LD_INT 45
56523: PUSH
56524: LD_VAR 0 5
56528: IN
56529: OR
56530: AND
56531: IFFALSE 56785
// begin hex := GetHexInfo ( x , y ) ;
56533: LD_ADDR_VAR 0 4
56537: PUSH
56538: LD_VAR 0 10
56542: PPUSH
56543: LD_VAR 0 11
56547: PPUSH
56548: CALL_OW 546
56552: ST_TO_ADDR
// if hex [ 1 ] then
56553: LD_VAR 0 4
56557: PUSH
56558: LD_INT 1
56560: ARRAY
56561: IFFALSE 56565
// exit ;
56563: GO 56968
// height := hex [ 2 ] ;
56565: LD_ADDR_VAR 0 15
56569: PUSH
56570: LD_VAR 0 4
56574: PUSH
56575: LD_INT 2
56577: ARRAY
56578: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
56579: LD_ADDR_VAR 0 14
56583: PUSH
56584: LD_INT 0
56586: PUSH
56587: LD_INT 2
56589: PUSH
56590: LD_INT 3
56592: PUSH
56593: LD_INT 5
56595: PUSH
56596: EMPTY
56597: LIST
56598: LIST
56599: LIST
56600: LIST
56601: ST_TO_ADDR
// for i in tmp do
56602: LD_ADDR_VAR 0 8
56606: PUSH
56607: LD_VAR 0 14
56611: PUSH
56612: FOR_IN
56613: IFFALSE 56783
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
56615: LD_ADDR_VAR 0 9
56619: PUSH
56620: LD_VAR 0 10
56624: PPUSH
56625: LD_VAR 0 8
56629: PPUSH
56630: LD_INT 5
56632: PPUSH
56633: CALL_OW 272
56637: PUSH
56638: LD_VAR 0 11
56642: PPUSH
56643: LD_VAR 0 8
56647: PPUSH
56648: LD_INT 5
56650: PPUSH
56651: CALL_OW 273
56655: PUSH
56656: EMPTY
56657: LIST
56658: LIST
56659: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
56660: LD_VAR 0 9
56664: PUSH
56665: LD_INT 1
56667: ARRAY
56668: PPUSH
56669: LD_VAR 0 9
56673: PUSH
56674: LD_INT 2
56676: ARRAY
56677: PPUSH
56678: CALL_OW 488
56682: IFFALSE 56781
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
56684: LD_ADDR_VAR 0 4
56688: PUSH
56689: LD_VAR 0 9
56693: PUSH
56694: LD_INT 1
56696: ARRAY
56697: PPUSH
56698: LD_VAR 0 9
56702: PUSH
56703: LD_INT 2
56705: ARRAY
56706: PPUSH
56707: CALL_OW 546
56711: ST_TO_ADDR
// if hex [ 1 ] then
56712: LD_VAR 0 4
56716: PUSH
56717: LD_INT 1
56719: ARRAY
56720: IFFALSE 56724
// continue ;
56722: GO 56612
// h := hex [ 2 ] ;
56724: LD_ADDR_VAR 0 13
56728: PUSH
56729: LD_VAR 0 4
56733: PUSH
56734: LD_INT 2
56736: ARRAY
56737: ST_TO_ADDR
// if h + 7 < height then
56738: LD_VAR 0 13
56742: PUSH
56743: LD_INT 7
56745: PLUS
56746: PUSH
56747: LD_VAR 0 15
56751: LESS
56752: IFFALSE 56781
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
56754: LD_ADDR_VAR 0 18
56758: PUSH
56759: LD_INT 7
56761: PUSH
56762: LD_INT 28
56764: PUSH
56765: LD_INT 45
56767: PUSH
56768: EMPTY
56769: LIST
56770: LIST
56771: LIST
56772: PUSH
56773: LD_VAR 0 12
56777: ARRAY
56778: ST_TO_ADDR
// break ;
56779: GO 56783
// end ; end ; end ;
56781: GO 56612
56783: POP
56784: POP
// end ; if not weapon then
56785: LD_VAR 0 18
56789: NOT
56790: IFFALSE 56850
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
56792: LD_ADDR_VAR 0 5
56796: PUSH
56797: LD_VAR 0 5
56801: PUSH
56802: LD_INT 11
56804: PUSH
56805: LD_INT 30
56807: PUSH
56808: LD_INT 49
56810: PUSH
56811: EMPTY
56812: LIST
56813: LIST
56814: LIST
56815: DIFF
56816: ST_TO_ADDR
// if not list then
56817: LD_VAR 0 5
56821: NOT
56822: IFFALSE 56826
// exit ;
56824: GO 56968
// weapon := list [ rand ( 1 , list ) ] ;
56826: LD_ADDR_VAR 0 18
56830: PUSH
56831: LD_VAR 0 5
56835: PUSH
56836: LD_INT 1
56838: PPUSH
56839: LD_VAR 0 5
56843: PPUSH
56844: CALL_OW 12
56848: ARRAY
56849: ST_TO_ADDR
// end ; if weapon then
56850: LD_VAR 0 18
56854: IFFALSE 56968
// begin tmp := CostOfWeapon ( weapon ) ;
56856: LD_ADDR_VAR 0 14
56860: PUSH
56861: LD_VAR 0 18
56865: PPUSH
56866: CALL_OW 451
56870: ST_TO_ADDR
// j := GetBase ( tower ) ;
56871: LD_ADDR_VAR 0 9
56875: PUSH
56876: LD_VAR 0 1
56880: PPUSH
56881: CALL_OW 274
56885: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
56886: LD_VAR 0 9
56890: PPUSH
56891: LD_INT 1
56893: PPUSH
56894: CALL_OW 275
56898: PUSH
56899: LD_VAR 0 14
56903: PUSH
56904: LD_INT 1
56906: ARRAY
56907: GREATEREQUAL
56908: PUSH
56909: LD_VAR 0 9
56913: PPUSH
56914: LD_INT 2
56916: PPUSH
56917: CALL_OW 275
56921: PUSH
56922: LD_VAR 0 14
56926: PUSH
56927: LD_INT 2
56929: ARRAY
56930: GREATEREQUAL
56931: AND
56932: PUSH
56933: LD_VAR 0 9
56937: PPUSH
56938: LD_INT 3
56940: PPUSH
56941: CALL_OW 275
56945: PUSH
56946: LD_VAR 0 14
56950: PUSH
56951: LD_INT 3
56953: ARRAY
56954: GREATEREQUAL
56955: AND
56956: IFFALSE 56968
// result := weapon ;
56958: LD_ADDR_VAR 0 3
56962: PUSH
56963: LD_VAR 0 18
56967: ST_TO_ADDR
// end ; end ;
56968: LD_VAR 0 3
56972: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
56973: LD_INT 0
56975: PPUSH
56976: PPUSH
// result := true ;
56977: LD_ADDR_VAR 0 3
56981: PUSH
56982: LD_INT 1
56984: ST_TO_ADDR
// if array1 = array2 then
56985: LD_VAR 0 1
56989: PUSH
56990: LD_VAR 0 2
56994: EQUAL
56995: IFFALSE 57055
// begin for i = 1 to array1 do
56997: LD_ADDR_VAR 0 4
57001: PUSH
57002: DOUBLE
57003: LD_INT 1
57005: DEC
57006: ST_TO_ADDR
57007: LD_VAR 0 1
57011: PUSH
57012: FOR_TO
57013: IFFALSE 57051
// if array1 [ i ] <> array2 [ i ] then
57015: LD_VAR 0 1
57019: PUSH
57020: LD_VAR 0 4
57024: ARRAY
57025: PUSH
57026: LD_VAR 0 2
57030: PUSH
57031: LD_VAR 0 4
57035: ARRAY
57036: NONEQUAL
57037: IFFALSE 57049
// begin result := false ;
57039: LD_ADDR_VAR 0 3
57043: PUSH
57044: LD_INT 0
57046: ST_TO_ADDR
// break ;
57047: GO 57051
// end ;
57049: GO 57012
57051: POP
57052: POP
// end else
57053: GO 57063
// result := false ;
57055: LD_ADDR_VAR 0 3
57059: PUSH
57060: LD_INT 0
57062: ST_TO_ADDR
// end ;
57063: LD_VAR 0 3
57067: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
57068: LD_INT 0
57070: PPUSH
57071: PPUSH
57072: PPUSH
// pom := GetBase ( fac ) ;
57073: LD_ADDR_VAR 0 5
57077: PUSH
57078: LD_VAR 0 1
57082: PPUSH
57083: CALL_OW 274
57087: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
57088: LD_ADDR_VAR 0 4
57092: PUSH
57093: LD_VAR 0 2
57097: PUSH
57098: LD_INT 1
57100: ARRAY
57101: PPUSH
57102: LD_VAR 0 2
57106: PUSH
57107: LD_INT 2
57109: ARRAY
57110: PPUSH
57111: LD_VAR 0 2
57115: PUSH
57116: LD_INT 3
57118: ARRAY
57119: PPUSH
57120: LD_VAR 0 2
57124: PUSH
57125: LD_INT 4
57127: ARRAY
57128: PPUSH
57129: CALL_OW 449
57133: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
57134: LD_ADDR_VAR 0 3
57138: PUSH
57139: LD_VAR 0 5
57143: PPUSH
57144: LD_INT 1
57146: PPUSH
57147: CALL_OW 275
57151: PUSH
57152: LD_VAR 0 4
57156: PUSH
57157: LD_INT 1
57159: ARRAY
57160: GREATEREQUAL
57161: PUSH
57162: LD_VAR 0 5
57166: PPUSH
57167: LD_INT 2
57169: PPUSH
57170: CALL_OW 275
57174: PUSH
57175: LD_VAR 0 4
57179: PUSH
57180: LD_INT 2
57182: ARRAY
57183: GREATEREQUAL
57184: AND
57185: PUSH
57186: LD_VAR 0 5
57190: PPUSH
57191: LD_INT 3
57193: PPUSH
57194: CALL_OW 275
57198: PUSH
57199: LD_VAR 0 4
57203: PUSH
57204: LD_INT 3
57206: ARRAY
57207: GREATEREQUAL
57208: AND
57209: ST_TO_ADDR
// end ;
57210: LD_VAR 0 3
57214: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
57215: LD_INT 0
57217: PPUSH
57218: PPUSH
57219: PPUSH
57220: PPUSH
// pom := GetBase ( building ) ;
57221: LD_ADDR_VAR 0 3
57225: PUSH
57226: LD_VAR 0 1
57230: PPUSH
57231: CALL_OW 274
57235: ST_TO_ADDR
// if not pom then
57236: LD_VAR 0 3
57240: NOT
57241: IFFALSE 57245
// exit ;
57243: GO 57415
// btype := GetBType ( building ) ;
57245: LD_ADDR_VAR 0 5
57249: PUSH
57250: LD_VAR 0 1
57254: PPUSH
57255: CALL_OW 266
57259: ST_TO_ADDR
// if btype = b_armoury then
57260: LD_VAR 0 5
57264: PUSH
57265: LD_INT 4
57267: EQUAL
57268: IFFALSE 57278
// btype := b_barracks ;
57270: LD_ADDR_VAR 0 5
57274: PUSH
57275: LD_INT 5
57277: ST_TO_ADDR
// if btype = b_depot then
57278: LD_VAR 0 5
57282: PUSH
57283: LD_INT 0
57285: EQUAL
57286: IFFALSE 57296
// btype := b_warehouse ;
57288: LD_ADDR_VAR 0 5
57292: PUSH
57293: LD_INT 1
57295: ST_TO_ADDR
// if btype = b_workshop then
57296: LD_VAR 0 5
57300: PUSH
57301: LD_INT 2
57303: EQUAL
57304: IFFALSE 57314
// btype := b_factory ;
57306: LD_ADDR_VAR 0 5
57310: PUSH
57311: LD_INT 3
57313: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
57314: LD_ADDR_VAR 0 4
57318: PUSH
57319: LD_VAR 0 5
57323: PPUSH
57324: LD_VAR 0 1
57328: PPUSH
57329: CALL_OW 248
57333: PPUSH
57334: CALL_OW 450
57338: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
57339: LD_ADDR_VAR 0 2
57343: PUSH
57344: LD_VAR 0 3
57348: PPUSH
57349: LD_INT 1
57351: PPUSH
57352: CALL_OW 275
57356: PUSH
57357: LD_VAR 0 4
57361: PUSH
57362: LD_INT 1
57364: ARRAY
57365: GREATEREQUAL
57366: PUSH
57367: LD_VAR 0 3
57371: PPUSH
57372: LD_INT 2
57374: PPUSH
57375: CALL_OW 275
57379: PUSH
57380: LD_VAR 0 4
57384: PUSH
57385: LD_INT 2
57387: ARRAY
57388: GREATEREQUAL
57389: AND
57390: PUSH
57391: LD_VAR 0 3
57395: PPUSH
57396: LD_INT 3
57398: PPUSH
57399: CALL_OW 275
57403: PUSH
57404: LD_VAR 0 4
57408: PUSH
57409: LD_INT 3
57411: ARRAY
57412: GREATEREQUAL
57413: AND
57414: ST_TO_ADDR
// end ;
57415: LD_VAR 0 2
57419: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
57420: LD_INT 0
57422: PPUSH
57423: PPUSH
57424: PPUSH
// pom := GetBase ( building ) ;
57425: LD_ADDR_VAR 0 4
57429: PUSH
57430: LD_VAR 0 1
57434: PPUSH
57435: CALL_OW 274
57439: ST_TO_ADDR
// if not pom then
57440: LD_VAR 0 4
57444: NOT
57445: IFFALSE 57449
// exit ;
57447: GO 57550
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
57449: LD_ADDR_VAR 0 5
57453: PUSH
57454: LD_VAR 0 2
57458: PPUSH
57459: LD_VAR 0 1
57463: PPUSH
57464: CALL_OW 248
57468: PPUSH
57469: CALL_OW 450
57473: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
57474: LD_ADDR_VAR 0 3
57478: PUSH
57479: LD_VAR 0 4
57483: PPUSH
57484: LD_INT 1
57486: PPUSH
57487: CALL_OW 275
57491: PUSH
57492: LD_VAR 0 5
57496: PUSH
57497: LD_INT 1
57499: ARRAY
57500: GREATEREQUAL
57501: PUSH
57502: LD_VAR 0 4
57506: PPUSH
57507: LD_INT 2
57509: PPUSH
57510: CALL_OW 275
57514: PUSH
57515: LD_VAR 0 5
57519: PUSH
57520: LD_INT 2
57522: ARRAY
57523: GREATEREQUAL
57524: AND
57525: PUSH
57526: LD_VAR 0 4
57530: PPUSH
57531: LD_INT 3
57533: PPUSH
57534: CALL_OW 275
57538: PUSH
57539: LD_VAR 0 5
57543: PUSH
57544: LD_INT 3
57546: ARRAY
57547: GREATEREQUAL
57548: AND
57549: ST_TO_ADDR
// end ;
57550: LD_VAR 0 3
57554: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
57555: LD_INT 0
57557: PPUSH
57558: PPUSH
57559: PPUSH
57560: PPUSH
57561: PPUSH
57562: PPUSH
57563: PPUSH
57564: PPUSH
57565: PPUSH
57566: PPUSH
// result := false ;
57567: LD_ADDR_VAR 0 6
57571: PUSH
57572: LD_INT 0
57574: ST_TO_ADDR
// if not base or not btype or not x or not y then
57575: LD_VAR 0 1
57579: NOT
57580: PUSH
57581: LD_VAR 0 2
57585: NOT
57586: OR
57587: PUSH
57588: LD_VAR 0 3
57592: NOT
57593: OR
57594: PUSH
57595: LD_VAR 0 4
57599: NOT
57600: OR
57601: IFFALSE 57605
// exit ;
57603: GO 58119
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
57605: LD_ADDR_VAR 0 12
57609: PUSH
57610: LD_VAR 0 2
57614: PPUSH
57615: LD_VAR 0 3
57619: PPUSH
57620: LD_VAR 0 4
57624: PPUSH
57625: LD_VAR 0 5
57629: PPUSH
57630: LD_VAR 0 1
57634: PUSH
57635: LD_INT 1
57637: ARRAY
57638: PPUSH
57639: CALL_OW 248
57643: PPUSH
57644: LD_INT 0
57646: PPUSH
57647: CALL 58948 0 6
57651: ST_TO_ADDR
// if not hexes then
57652: LD_VAR 0 12
57656: NOT
57657: IFFALSE 57661
// exit ;
57659: GO 58119
// for i = 1 to hexes do
57661: LD_ADDR_VAR 0 7
57665: PUSH
57666: DOUBLE
57667: LD_INT 1
57669: DEC
57670: ST_TO_ADDR
57671: LD_VAR 0 12
57675: PUSH
57676: FOR_TO
57677: IFFALSE 58117
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
57679: LD_ADDR_VAR 0 11
57683: PUSH
57684: LD_VAR 0 12
57688: PUSH
57689: LD_VAR 0 7
57693: ARRAY
57694: PUSH
57695: LD_INT 1
57697: ARRAY
57698: PPUSH
57699: LD_VAR 0 12
57703: PUSH
57704: LD_VAR 0 7
57708: ARRAY
57709: PUSH
57710: LD_INT 2
57712: ARRAY
57713: PPUSH
57714: CALL_OW 428
57718: ST_TO_ADDR
// if not tmp or GetType ( tmp ) = unit_building then
57719: LD_VAR 0 11
57723: NOT
57724: PUSH
57725: LD_VAR 0 11
57729: PPUSH
57730: CALL_OW 247
57734: PUSH
57735: LD_INT 3
57737: EQUAL
57738: OR
57739: IFFALSE 57743
// continue ;
57741: GO 57676
// result := true ;
57743: LD_ADDR_VAR 0 6
57747: PUSH
57748: LD_INT 1
57750: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
57751: LD_ADDR_VAR 0 15
57755: PUSH
57756: LD_INT 22
57758: PUSH
57759: LD_VAR 0 11
57763: PPUSH
57764: CALL_OW 255
57768: PUSH
57769: EMPTY
57770: LIST
57771: LIST
57772: PUSH
57773: LD_INT 2
57775: PUSH
57776: LD_INT 30
57778: PUSH
57779: LD_INT 0
57781: PUSH
57782: EMPTY
57783: LIST
57784: LIST
57785: PUSH
57786: LD_INT 30
57788: PUSH
57789: LD_INT 1
57791: PUSH
57792: EMPTY
57793: LIST
57794: LIST
57795: PUSH
57796: EMPTY
57797: LIST
57798: LIST
57799: LIST
57800: PUSH
57801: EMPTY
57802: LIST
57803: LIST
57804: PPUSH
57805: CALL_OW 69
57809: ST_TO_ADDR
// if dep then
57810: LD_VAR 0 15
57814: IFFALSE 57950
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
57816: LD_ADDR_VAR 0 14
57820: PUSH
57821: LD_VAR 0 15
57825: PUSH
57826: LD_INT 1
57828: ARRAY
57829: PPUSH
57830: CALL_OW 250
57834: PPUSH
57835: LD_VAR 0 15
57839: PUSH
57840: LD_INT 1
57842: ARRAY
57843: PPUSH
57844: CALL_OW 254
57848: PPUSH
57849: LD_INT 5
57851: PPUSH
57852: CALL_OW 272
57856: PUSH
57857: LD_VAR 0 15
57861: PUSH
57862: LD_INT 1
57864: ARRAY
57865: PPUSH
57866: CALL_OW 251
57870: PPUSH
57871: LD_VAR 0 15
57875: PUSH
57876: LD_INT 1
57878: ARRAY
57879: PPUSH
57880: CALL_OW 254
57884: PPUSH
57885: LD_INT 5
57887: PPUSH
57888: CALL_OW 273
57892: PUSH
57893: EMPTY
57894: LIST
57895: LIST
57896: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
57897: LD_VAR 0 14
57901: PUSH
57902: LD_INT 1
57904: ARRAY
57905: PPUSH
57906: LD_VAR 0 14
57910: PUSH
57911: LD_INT 2
57913: ARRAY
57914: PPUSH
57915: CALL_OW 488
57919: IFFALSE 57950
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
57921: LD_VAR 0 11
57925: PPUSH
57926: LD_VAR 0 14
57930: PUSH
57931: LD_INT 1
57933: ARRAY
57934: PPUSH
57935: LD_VAR 0 14
57939: PUSH
57940: LD_INT 2
57942: ARRAY
57943: PPUSH
57944: CALL_OW 111
// continue ;
57948: GO 57676
// end ; end ; r := GetDir ( tmp ) ;
57950: LD_ADDR_VAR 0 13
57954: PUSH
57955: LD_VAR 0 11
57959: PPUSH
57960: CALL_OW 254
57964: ST_TO_ADDR
// if r = 5 then
57965: LD_VAR 0 13
57969: PUSH
57970: LD_INT 5
57972: EQUAL
57973: IFFALSE 57983
// r := 0 ;
57975: LD_ADDR_VAR 0 13
57979: PUSH
57980: LD_INT 0
57982: ST_TO_ADDR
// for j = r to 5 do
57983: LD_ADDR_VAR 0 8
57987: PUSH
57988: DOUBLE
57989: LD_VAR 0 13
57993: DEC
57994: ST_TO_ADDR
57995: LD_INT 5
57997: PUSH
57998: FOR_TO
57999: IFFALSE 58113
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
58001: LD_ADDR_VAR 0 9
58005: PUSH
58006: LD_VAR 0 11
58010: PPUSH
58011: CALL_OW 250
58015: PPUSH
58016: LD_VAR 0 8
58020: PPUSH
58021: LD_INT 2
58023: PPUSH
58024: CALL_OW 272
58028: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
58029: LD_ADDR_VAR 0 10
58033: PUSH
58034: LD_VAR 0 11
58038: PPUSH
58039: CALL_OW 251
58043: PPUSH
58044: LD_VAR 0 8
58048: PPUSH
58049: LD_INT 2
58051: PPUSH
58052: CALL_OW 273
58056: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
58057: LD_VAR 0 9
58061: PPUSH
58062: LD_VAR 0 10
58066: PPUSH
58067: CALL_OW 488
58071: PUSH
58072: LD_VAR 0 9
58076: PPUSH
58077: LD_VAR 0 10
58081: PPUSH
58082: CALL_OW 428
58086: NOT
58087: AND
58088: IFFALSE 58111
// begin ComMoveXY ( tmp , _x , _y ) ;
58090: LD_VAR 0 11
58094: PPUSH
58095: LD_VAR 0 9
58099: PPUSH
58100: LD_VAR 0 10
58104: PPUSH
58105: CALL_OW 111
// break ;
58109: GO 58113
// end ; end ;
58111: GO 57998
58113: POP
58114: POP
// end ;
58115: GO 57676
58117: POP
58118: POP
// end ;
58119: LD_VAR 0 6
58123: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , pom , cost , hexes , height , dist , hex ; begin
58124: LD_INT 0
58126: PPUSH
58127: PPUSH
58128: PPUSH
58129: PPUSH
58130: PPUSH
58131: PPUSH
58132: PPUSH
58133: PPUSH
58134: PPUSH
// result := false ;
58135: LD_ADDR_VAR 0 6
58139: PUSH
58140: LD_INT 0
58142: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
58143: LD_VAR 0 1
58147: NOT
58148: PUSH
58149: LD_VAR 0 1
58153: PPUSH
58154: CALL_OW 266
58158: PUSH
58159: LD_INT 0
58161: PUSH
58162: LD_INT 1
58164: PUSH
58165: EMPTY
58166: LIST
58167: LIST
58168: IN
58169: NOT
58170: OR
58171: PUSH
58172: LD_VAR 0 2
58176: NOT
58177: OR
58178: PUSH
58179: LD_VAR 0 5
58183: PUSH
58184: LD_INT 0
58186: PUSH
58187: LD_INT 1
58189: PUSH
58190: LD_INT 2
58192: PUSH
58193: LD_INT 3
58195: PUSH
58196: LD_INT 4
58198: PUSH
58199: LD_INT 5
58201: PUSH
58202: EMPTY
58203: LIST
58204: LIST
58205: LIST
58206: LIST
58207: LIST
58208: LIST
58209: IN
58210: NOT
58211: OR
58212: PUSH
58213: LD_VAR 0 3
58217: PPUSH
58218: LD_VAR 0 4
58222: PPUSH
58223: CALL_OW 488
58227: NOT
58228: OR
58229: IFFALSE 58233
// exit ;
58231: GO 58943
// pom := GetBase ( bdepot ) ;
58233: LD_ADDR_VAR 0 9
58237: PUSH
58238: LD_VAR 0 1
58242: PPUSH
58243: CALL_OW 274
58247: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
58248: LD_ADDR_VAR 0 10
58252: PUSH
58253: LD_VAR 0 2
58257: PPUSH
58258: LD_VAR 0 1
58262: PPUSH
58263: CALL_OW 248
58267: PPUSH
58268: CALL_OW 450
58272: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
58273: LD_VAR 0 9
58277: PPUSH
58278: LD_INT 1
58280: PPUSH
58281: CALL_OW 275
58285: PUSH
58286: LD_VAR 0 10
58290: PUSH
58291: LD_INT 1
58293: ARRAY
58294: GREATEREQUAL
58295: PUSH
58296: LD_VAR 0 9
58300: PPUSH
58301: LD_INT 2
58303: PPUSH
58304: CALL_OW 275
58308: PUSH
58309: LD_VAR 0 10
58313: PUSH
58314: LD_INT 2
58316: ARRAY
58317: GREATEREQUAL
58318: AND
58319: PUSH
58320: LD_VAR 0 9
58324: PPUSH
58325: LD_INT 3
58327: PPUSH
58328: CALL_OW 275
58332: PUSH
58333: LD_VAR 0 10
58337: PUSH
58338: LD_INT 3
58340: ARRAY
58341: GREATEREQUAL
58342: AND
58343: NOT
58344: IFFALSE 58348
// exit ;
58346: GO 58943
// if GetBType ( bdepot ) = b_depot then
58348: LD_VAR 0 1
58352: PPUSH
58353: CALL_OW 266
58357: PUSH
58358: LD_INT 0
58360: EQUAL
58361: IFFALSE 58373
// dist := 28 else
58363: LD_ADDR_VAR 0 13
58367: PUSH
58368: LD_INT 28
58370: ST_TO_ADDR
58371: GO 58381
// dist := 36 ;
58373: LD_ADDR_VAR 0 13
58377: PUSH
58378: LD_INT 36
58380: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
58381: LD_VAR 0 1
58385: PPUSH
58386: LD_VAR 0 3
58390: PPUSH
58391: LD_VAR 0 4
58395: PPUSH
58396: CALL_OW 297
58400: PUSH
58401: LD_VAR 0 13
58405: GREATER
58406: IFFALSE 58410
// exit ;
58408: GO 58943
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
58410: LD_ADDR_VAR 0 11
58414: PUSH
58415: LD_VAR 0 2
58419: PPUSH
58420: LD_VAR 0 3
58424: PPUSH
58425: LD_VAR 0 4
58429: PPUSH
58430: LD_VAR 0 5
58434: PPUSH
58435: LD_VAR 0 1
58439: PPUSH
58440: CALL_OW 248
58444: PPUSH
58445: LD_INT 0
58447: PPUSH
58448: CALL 58948 0 6
58452: ST_TO_ADDR
// if not hexes then
58453: LD_VAR 0 11
58457: NOT
58458: IFFALSE 58462
// exit ;
58460: GO 58943
// hex := GetHexInfo ( x , y ) ;
58462: LD_ADDR_VAR 0 14
58466: PUSH
58467: LD_VAR 0 3
58471: PPUSH
58472: LD_VAR 0 4
58476: PPUSH
58477: CALL_OW 546
58481: ST_TO_ADDR
// if hex [ 1 ] then
58482: LD_VAR 0 14
58486: PUSH
58487: LD_INT 1
58489: ARRAY
58490: IFFALSE 58494
// exit ;
58492: GO 58943
// height := hex [ 2 ] ;
58494: LD_ADDR_VAR 0 12
58498: PUSH
58499: LD_VAR 0 14
58503: PUSH
58504: LD_INT 2
58506: ARRAY
58507: ST_TO_ADDR
// for i = 1 to hexes do
58508: LD_ADDR_VAR 0 7
58512: PUSH
58513: DOUBLE
58514: LD_INT 1
58516: DEC
58517: ST_TO_ADDR
58518: LD_VAR 0 11
58522: PUSH
58523: FOR_TO
58524: IFFALSE 58852
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
58526: LD_VAR 0 11
58530: PUSH
58531: LD_VAR 0 7
58535: ARRAY
58536: PUSH
58537: LD_INT 1
58539: ARRAY
58540: PPUSH
58541: LD_VAR 0 11
58545: PUSH
58546: LD_VAR 0 7
58550: ARRAY
58551: PUSH
58552: LD_INT 2
58554: ARRAY
58555: PPUSH
58556: CALL_OW 488
58560: NOT
58561: IFFALSE 58565
// continue ;
58563: GO 58523
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
58565: LD_ADDR_VAR 0 8
58569: PUSH
58570: LD_VAR 0 11
58574: PUSH
58575: LD_VAR 0 7
58579: ARRAY
58580: PUSH
58581: LD_INT 1
58583: ARRAY
58584: PPUSH
58585: LD_VAR 0 11
58589: PUSH
58590: LD_VAR 0 7
58594: ARRAY
58595: PUSH
58596: LD_INT 2
58598: ARRAY
58599: PPUSH
58600: CALL_OW 546
58604: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
58605: LD_VAR 0 8
58609: PUSH
58610: LD_INT 1
58612: ARRAY
58613: PUSH
58614: LD_VAR 0 8
58618: PUSH
58619: LD_INT 2
58621: ARRAY
58622: PUSH
58623: LD_VAR 0 12
58627: PUSH
58628: LD_INT 2
58630: PLUS
58631: GREATER
58632: OR
58633: PUSH
58634: LD_VAR 0 8
58638: PUSH
58639: LD_INT 2
58641: ARRAY
58642: PUSH
58643: LD_VAR 0 12
58647: PUSH
58648: LD_INT 2
58650: MINUS
58651: LESS
58652: OR
58653: PUSH
58654: LD_VAR 0 8
58658: PUSH
58659: LD_INT 3
58661: ARRAY
58662: PUSH
58663: LD_INT 0
58665: PUSH
58666: LD_INT 8
58668: PUSH
58669: LD_INT 9
58671: PUSH
58672: LD_INT 10
58674: PUSH
58675: LD_INT 11
58677: PUSH
58678: LD_INT 12
58680: PUSH
58681: LD_INT 13
58683: PUSH
58684: LD_INT 16
58686: PUSH
58687: LD_INT 17
58689: PUSH
58690: LD_INT 18
58692: PUSH
58693: LD_INT 19
58695: PUSH
58696: LD_INT 20
58698: PUSH
58699: LD_INT 21
58701: PUSH
58702: EMPTY
58703: LIST
58704: LIST
58705: LIST
58706: LIST
58707: LIST
58708: LIST
58709: LIST
58710: LIST
58711: LIST
58712: LIST
58713: LIST
58714: LIST
58715: LIST
58716: IN
58717: NOT
58718: OR
58719: PUSH
58720: LD_VAR 0 8
58724: PUSH
58725: LD_INT 5
58727: ARRAY
58728: NOT
58729: OR
58730: PUSH
58731: LD_VAR 0 8
58735: PUSH
58736: LD_INT 6
58738: ARRAY
58739: PUSH
58740: LD_INT 1
58742: PUSH
58743: LD_INT 2
58745: PUSH
58746: LD_INT 7
58748: PUSH
58749: LD_INT 9
58751: PUSH
58752: LD_INT 10
58754: PUSH
58755: LD_INT 11
58757: PUSH
58758: EMPTY
58759: LIST
58760: LIST
58761: LIST
58762: LIST
58763: LIST
58764: LIST
58765: IN
58766: NOT
58767: OR
58768: PUSH
58769: LD_VAR 0 11
58773: PUSH
58774: LD_VAR 0 7
58778: ARRAY
58779: PUSH
58780: LD_INT 1
58782: ARRAY
58783: PPUSH
58784: LD_VAR 0 11
58788: PUSH
58789: LD_VAR 0 7
58793: ARRAY
58794: PUSH
58795: LD_INT 2
58797: ARRAY
58798: PPUSH
58799: CALL_OW 428
58803: PUSH
58804: LD_INT 0
58806: GREATER
58807: OR
58808: PUSH
58809: LD_VAR 0 11
58813: PUSH
58814: LD_VAR 0 7
58818: ARRAY
58819: PUSH
58820: LD_INT 1
58822: ARRAY
58823: PPUSH
58824: LD_VAR 0 11
58828: PUSH
58829: LD_VAR 0 7
58833: ARRAY
58834: PUSH
58835: LD_INT 2
58837: ARRAY
58838: PPUSH
58839: CALL_OW 351
58843: OR
58844: IFFALSE 58850
// exit ;
58846: POP
58847: POP
58848: GO 58943
// end ;
58850: GO 58523
58852: POP
58853: POP
// if DangerAtRangeXY ( GetSide ( bdepot ) , x , y , 20 ) [ 4 ] then
58854: LD_VAR 0 1
58858: PPUSH
58859: CALL_OW 255
58863: PPUSH
58864: LD_VAR 0 3
58868: PPUSH
58869: LD_VAR 0 4
58873: PPUSH
58874: LD_INT 20
58876: PPUSH
58877: CALL 51802 0 4
58881: PUSH
58882: LD_INT 4
58884: ARRAY
58885: IFFALSE 58889
// exit ;
58887: GO 58943
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , GetSide ( bdepot ) ) then
58889: LD_VAR 0 2
58893: PUSH
58894: LD_INT 29
58896: PUSH
58897: LD_INT 30
58899: PUSH
58900: EMPTY
58901: LIST
58902: LIST
58903: IN
58904: PUSH
58905: LD_VAR 0 3
58909: PPUSH
58910: LD_VAR 0 4
58914: PPUSH
58915: LD_VAR 0 1
58919: PPUSH
58920: CALL_OW 255
58924: PPUSH
58925: CALL_OW 440
58929: NOT
58930: AND
58931: IFFALSE 58935
// exit ;
58933: GO 58943
// result := true ;
58935: LD_ADDR_VAR 0 6
58939: PUSH
58940: LD_INT 1
58942: ST_TO_ADDR
// end ;
58943: LD_VAR 0 6
58947: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
58948: LD_INT 0
58950: PPUSH
58951: PPUSH
58952: PPUSH
58953: PPUSH
58954: PPUSH
58955: PPUSH
58956: PPUSH
58957: PPUSH
58958: PPUSH
58959: PPUSH
58960: PPUSH
58961: PPUSH
58962: PPUSH
58963: PPUSH
58964: PPUSH
58965: PPUSH
58966: PPUSH
58967: PPUSH
58968: PPUSH
58969: PPUSH
58970: PPUSH
58971: PPUSH
58972: PPUSH
58973: PPUSH
58974: PPUSH
58975: PPUSH
58976: PPUSH
58977: PPUSH
58978: PPUSH
58979: PPUSH
58980: PPUSH
58981: PPUSH
58982: PPUSH
58983: PPUSH
58984: PPUSH
58985: PPUSH
58986: PPUSH
58987: PPUSH
58988: PPUSH
58989: PPUSH
58990: PPUSH
58991: PPUSH
58992: PPUSH
58993: PPUSH
58994: PPUSH
58995: PPUSH
58996: PPUSH
58997: PPUSH
58998: PPUSH
58999: PPUSH
59000: PPUSH
59001: PPUSH
59002: PPUSH
59003: PPUSH
59004: PPUSH
59005: PPUSH
59006: PPUSH
59007: PPUSH
// result = [ ] ;
59008: LD_ADDR_VAR 0 7
59012: PUSH
59013: EMPTY
59014: ST_TO_ADDR
// temp_list = [ ] ;
59015: LD_ADDR_VAR 0 9
59019: PUSH
59020: EMPTY
59021: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
59022: LD_VAR 0 4
59026: PUSH
59027: LD_INT 0
59029: PUSH
59030: LD_INT 1
59032: PUSH
59033: LD_INT 2
59035: PUSH
59036: LD_INT 3
59038: PUSH
59039: LD_INT 4
59041: PUSH
59042: LD_INT 5
59044: PUSH
59045: EMPTY
59046: LIST
59047: LIST
59048: LIST
59049: LIST
59050: LIST
59051: LIST
59052: IN
59053: NOT
59054: PUSH
59055: LD_VAR 0 1
59059: PUSH
59060: LD_INT 0
59062: PUSH
59063: LD_INT 1
59065: PUSH
59066: EMPTY
59067: LIST
59068: LIST
59069: IN
59070: PUSH
59071: LD_VAR 0 5
59075: PUSH
59076: LD_INT 1
59078: PUSH
59079: LD_INT 2
59081: PUSH
59082: LD_INT 3
59084: PUSH
59085: EMPTY
59086: LIST
59087: LIST
59088: LIST
59089: IN
59090: NOT
59091: AND
59092: OR
59093: IFFALSE 59097
// exit ;
59095: GO 77482
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
59097: LD_VAR 0 1
59101: PUSH
59102: LD_INT 6
59104: PUSH
59105: LD_INT 7
59107: PUSH
59108: LD_INT 8
59110: PUSH
59111: LD_INT 13
59113: PUSH
59114: LD_INT 12
59116: PUSH
59117: LD_INT 15
59119: PUSH
59120: LD_INT 11
59122: PUSH
59123: LD_INT 14
59125: PUSH
59126: LD_INT 10
59128: PUSH
59129: EMPTY
59130: LIST
59131: LIST
59132: LIST
59133: LIST
59134: LIST
59135: LIST
59136: LIST
59137: LIST
59138: LIST
59139: IN
59140: IFFALSE 59150
// btype = b_lab ;
59142: LD_ADDR_VAR 0 1
59146: PUSH
59147: LD_INT 6
59149: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
59150: LD_VAR 0 6
59154: PUSH
59155: LD_INT 0
59157: PUSH
59158: LD_INT 1
59160: PUSH
59161: LD_INT 2
59163: PUSH
59164: EMPTY
59165: LIST
59166: LIST
59167: LIST
59168: IN
59169: NOT
59170: PUSH
59171: LD_VAR 0 1
59175: PUSH
59176: LD_INT 0
59178: PUSH
59179: LD_INT 1
59181: PUSH
59182: LD_INT 2
59184: PUSH
59185: LD_INT 3
59187: PUSH
59188: LD_INT 6
59190: PUSH
59191: LD_INT 36
59193: PUSH
59194: LD_INT 4
59196: PUSH
59197: LD_INT 5
59199: PUSH
59200: LD_INT 31
59202: PUSH
59203: LD_INT 32
59205: PUSH
59206: LD_INT 33
59208: PUSH
59209: EMPTY
59210: LIST
59211: LIST
59212: LIST
59213: LIST
59214: LIST
59215: LIST
59216: LIST
59217: LIST
59218: LIST
59219: LIST
59220: LIST
59221: IN
59222: NOT
59223: PUSH
59224: LD_VAR 0 6
59228: PUSH
59229: LD_INT 1
59231: EQUAL
59232: AND
59233: OR
59234: PUSH
59235: LD_VAR 0 1
59239: PUSH
59240: LD_INT 2
59242: PUSH
59243: LD_INT 3
59245: PUSH
59246: EMPTY
59247: LIST
59248: LIST
59249: IN
59250: NOT
59251: PUSH
59252: LD_VAR 0 6
59256: PUSH
59257: LD_INT 2
59259: EQUAL
59260: AND
59261: OR
59262: IFFALSE 59272
// mode = 0 ;
59264: LD_ADDR_VAR 0 6
59268: PUSH
59269: LD_INT 0
59271: ST_TO_ADDR
// case mode of 0 :
59272: LD_VAR 0 6
59276: PUSH
59277: LD_INT 0
59279: DOUBLE
59280: EQUAL
59281: IFTRUE 59285
59283: GO 70738
59285: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
59286: LD_ADDR_VAR 0 11
59290: PUSH
59291: LD_INT 0
59293: PUSH
59294: LD_INT 0
59296: PUSH
59297: EMPTY
59298: LIST
59299: LIST
59300: PUSH
59301: LD_INT 0
59303: PUSH
59304: LD_INT 1
59306: NEG
59307: PUSH
59308: EMPTY
59309: LIST
59310: LIST
59311: PUSH
59312: LD_INT 1
59314: PUSH
59315: LD_INT 0
59317: PUSH
59318: EMPTY
59319: LIST
59320: LIST
59321: PUSH
59322: LD_INT 1
59324: PUSH
59325: LD_INT 1
59327: PUSH
59328: EMPTY
59329: LIST
59330: LIST
59331: PUSH
59332: LD_INT 0
59334: PUSH
59335: LD_INT 1
59337: PUSH
59338: EMPTY
59339: LIST
59340: LIST
59341: PUSH
59342: LD_INT 1
59344: NEG
59345: PUSH
59346: LD_INT 0
59348: PUSH
59349: EMPTY
59350: LIST
59351: LIST
59352: PUSH
59353: LD_INT 1
59355: NEG
59356: PUSH
59357: LD_INT 1
59359: NEG
59360: PUSH
59361: EMPTY
59362: LIST
59363: LIST
59364: PUSH
59365: LD_INT 1
59367: NEG
59368: PUSH
59369: LD_INT 2
59371: NEG
59372: PUSH
59373: EMPTY
59374: LIST
59375: LIST
59376: PUSH
59377: LD_INT 0
59379: PUSH
59380: LD_INT 2
59382: NEG
59383: PUSH
59384: EMPTY
59385: LIST
59386: LIST
59387: PUSH
59388: LD_INT 1
59390: PUSH
59391: LD_INT 1
59393: NEG
59394: PUSH
59395: EMPTY
59396: LIST
59397: LIST
59398: PUSH
59399: LD_INT 1
59401: PUSH
59402: LD_INT 2
59404: PUSH
59405: EMPTY
59406: LIST
59407: LIST
59408: PUSH
59409: LD_INT 0
59411: PUSH
59412: LD_INT 2
59414: PUSH
59415: EMPTY
59416: LIST
59417: LIST
59418: PUSH
59419: LD_INT 1
59421: NEG
59422: PUSH
59423: LD_INT 1
59425: PUSH
59426: EMPTY
59427: LIST
59428: LIST
59429: PUSH
59430: LD_INT 1
59432: PUSH
59433: LD_INT 3
59435: PUSH
59436: EMPTY
59437: LIST
59438: LIST
59439: PUSH
59440: LD_INT 0
59442: PUSH
59443: LD_INT 3
59445: PUSH
59446: EMPTY
59447: LIST
59448: LIST
59449: PUSH
59450: LD_INT 1
59452: NEG
59453: PUSH
59454: LD_INT 2
59456: PUSH
59457: EMPTY
59458: LIST
59459: LIST
59460: PUSH
59461: EMPTY
59462: LIST
59463: LIST
59464: LIST
59465: LIST
59466: LIST
59467: LIST
59468: LIST
59469: LIST
59470: LIST
59471: LIST
59472: LIST
59473: LIST
59474: LIST
59475: LIST
59476: LIST
59477: LIST
59478: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
59479: LD_ADDR_VAR 0 12
59483: PUSH
59484: LD_INT 0
59486: PUSH
59487: LD_INT 0
59489: PUSH
59490: EMPTY
59491: LIST
59492: LIST
59493: PUSH
59494: LD_INT 0
59496: PUSH
59497: LD_INT 1
59499: NEG
59500: PUSH
59501: EMPTY
59502: LIST
59503: LIST
59504: PUSH
59505: LD_INT 1
59507: PUSH
59508: LD_INT 0
59510: PUSH
59511: EMPTY
59512: LIST
59513: LIST
59514: PUSH
59515: LD_INT 1
59517: PUSH
59518: LD_INT 1
59520: PUSH
59521: EMPTY
59522: LIST
59523: LIST
59524: PUSH
59525: LD_INT 0
59527: PUSH
59528: LD_INT 1
59530: PUSH
59531: EMPTY
59532: LIST
59533: LIST
59534: PUSH
59535: LD_INT 1
59537: NEG
59538: PUSH
59539: LD_INT 0
59541: PUSH
59542: EMPTY
59543: LIST
59544: LIST
59545: PUSH
59546: LD_INT 1
59548: NEG
59549: PUSH
59550: LD_INT 1
59552: NEG
59553: PUSH
59554: EMPTY
59555: LIST
59556: LIST
59557: PUSH
59558: LD_INT 1
59560: PUSH
59561: LD_INT 1
59563: NEG
59564: PUSH
59565: EMPTY
59566: LIST
59567: LIST
59568: PUSH
59569: LD_INT 2
59571: PUSH
59572: LD_INT 0
59574: PUSH
59575: EMPTY
59576: LIST
59577: LIST
59578: PUSH
59579: LD_INT 2
59581: PUSH
59582: LD_INT 1
59584: PUSH
59585: EMPTY
59586: LIST
59587: LIST
59588: PUSH
59589: LD_INT 1
59591: NEG
59592: PUSH
59593: LD_INT 1
59595: PUSH
59596: EMPTY
59597: LIST
59598: LIST
59599: PUSH
59600: LD_INT 2
59602: NEG
59603: PUSH
59604: LD_INT 0
59606: PUSH
59607: EMPTY
59608: LIST
59609: LIST
59610: PUSH
59611: LD_INT 2
59613: NEG
59614: PUSH
59615: LD_INT 1
59617: NEG
59618: PUSH
59619: EMPTY
59620: LIST
59621: LIST
59622: PUSH
59623: LD_INT 2
59625: NEG
59626: PUSH
59627: LD_INT 1
59629: PUSH
59630: EMPTY
59631: LIST
59632: LIST
59633: PUSH
59634: LD_INT 3
59636: NEG
59637: PUSH
59638: LD_INT 0
59640: PUSH
59641: EMPTY
59642: LIST
59643: LIST
59644: PUSH
59645: LD_INT 3
59647: NEG
59648: PUSH
59649: LD_INT 1
59651: NEG
59652: PUSH
59653: EMPTY
59654: LIST
59655: LIST
59656: PUSH
59657: EMPTY
59658: LIST
59659: LIST
59660: LIST
59661: LIST
59662: LIST
59663: LIST
59664: LIST
59665: LIST
59666: LIST
59667: LIST
59668: LIST
59669: LIST
59670: LIST
59671: LIST
59672: LIST
59673: LIST
59674: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
59675: LD_ADDR_VAR 0 13
59679: PUSH
59680: LD_INT 0
59682: PUSH
59683: LD_INT 0
59685: PUSH
59686: EMPTY
59687: LIST
59688: LIST
59689: PUSH
59690: LD_INT 0
59692: PUSH
59693: LD_INT 1
59695: NEG
59696: PUSH
59697: EMPTY
59698: LIST
59699: LIST
59700: PUSH
59701: LD_INT 1
59703: PUSH
59704: LD_INT 0
59706: PUSH
59707: EMPTY
59708: LIST
59709: LIST
59710: PUSH
59711: LD_INT 1
59713: PUSH
59714: LD_INT 1
59716: PUSH
59717: EMPTY
59718: LIST
59719: LIST
59720: PUSH
59721: LD_INT 0
59723: PUSH
59724: LD_INT 1
59726: PUSH
59727: EMPTY
59728: LIST
59729: LIST
59730: PUSH
59731: LD_INT 1
59733: NEG
59734: PUSH
59735: LD_INT 0
59737: PUSH
59738: EMPTY
59739: LIST
59740: LIST
59741: PUSH
59742: LD_INT 1
59744: NEG
59745: PUSH
59746: LD_INT 1
59748: NEG
59749: PUSH
59750: EMPTY
59751: LIST
59752: LIST
59753: PUSH
59754: LD_INT 1
59756: NEG
59757: PUSH
59758: LD_INT 2
59760: NEG
59761: PUSH
59762: EMPTY
59763: LIST
59764: LIST
59765: PUSH
59766: LD_INT 2
59768: PUSH
59769: LD_INT 1
59771: PUSH
59772: EMPTY
59773: LIST
59774: LIST
59775: PUSH
59776: LD_INT 2
59778: PUSH
59779: LD_INT 2
59781: PUSH
59782: EMPTY
59783: LIST
59784: LIST
59785: PUSH
59786: LD_INT 1
59788: PUSH
59789: LD_INT 2
59791: PUSH
59792: EMPTY
59793: LIST
59794: LIST
59795: PUSH
59796: LD_INT 2
59798: NEG
59799: PUSH
59800: LD_INT 1
59802: NEG
59803: PUSH
59804: EMPTY
59805: LIST
59806: LIST
59807: PUSH
59808: LD_INT 2
59810: NEG
59811: PUSH
59812: LD_INT 2
59814: NEG
59815: PUSH
59816: EMPTY
59817: LIST
59818: LIST
59819: PUSH
59820: LD_INT 2
59822: NEG
59823: PUSH
59824: LD_INT 3
59826: NEG
59827: PUSH
59828: EMPTY
59829: LIST
59830: LIST
59831: PUSH
59832: LD_INT 3
59834: NEG
59835: PUSH
59836: LD_INT 2
59838: NEG
59839: PUSH
59840: EMPTY
59841: LIST
59842: LIST
59843: PUSH
59844: LD_INT 3
59846: NEG
59847: PUSH
59848: LD_INT 3
59850: NEG
59851: PUSH
59852: EMPTY
59853: LIST
59854: LIST
59855: PUSH
59856: EMPTY
59857: LIST
59858: LIST
59859: LIST
59860: LIST
59861: LIST
59862: LIST
59863: LIST
59864: LIST
59865: LIST
59866: LIST
59867: LIST
59868: LIST
59869: LIST
59870: LIST
59871: LIST
59872: LIST
59873: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
59874: LD_ADDR_VAR 0 14
59878: PUSH
59879: LD_INT 0
59881: PUSH
59882: LD_INT 0
59884: PUSH
59885: EMPTY
59886: LIST
59887: LIST
59888: PUSH
59889: LD_INT 0
59891: PUSH
59892: LD_INT 1
59894: NEG
59895: PUSH
59896: EMPTY
59897: LIST
59898: LIST
59899: PUSH
59900: LD_INT 1
59902: PUSH
59903: LD_INT 0
59905: PUSH
59906: EMPTY
59907: LIST
59908: LIST
59909: PUSH
59910: LD_INT 1
59912: PUSH
59913: LD_INT 1
59915: PUSH
59916: EMPTY
59917: LIST
59918: LIST
59919: PUSH
59920: LD_INT 0
59922: PUSH
59923: LD_INT 1
59925: PUSH
59926: EMPTY
59927: LIST
59928: LIST
59929: PUSH
59930: LD_INT 1
59932: NEG
59933: PUSH
59934: LD_INT 0
59936: PUSH
59937: EMPTY
59938: LIST
59939: LIST
59940: PUSH
59941: LD_INT 1
59943: NEG
59944: PUSH
59945: LD_INT 1
59947: NEG
59948: PUSH
59949: EMPTY
59950: LIST
59951: LIST
59952: PUSH
59953: LD_INT 1
59955: NEG
59956: PUSH
59957: LD_INT 2
59959: NEG
59960: PUSH
59961: EMPTY
59962: LIST
59963: LIST
59964: PUSH
59965: LD_INT 0
59967: PUSH
59968: LD_INT 2
59970: NEG
59971: PUSH
59972: EMPTY
59973: LIST
59974: LIST
59975: PUSH
59976: LD_INT 1
59978: PUSH
59979: LD_INT 1
59981: NEG
59982: PUSH
59983: EMPTY
59984: LIST
59985: LIST
59986: PUSH
59987: LD_INT 1
59989: PUSH
59990: LD_INT 2
59992: PUSH
59993: EMPTY
59994: LIST
59995: LIST
59996: PUSH
59997: LD_INT 0
59999: PUSH
60000: LD_INT 2
60002: PUSH
60003: EMPTY
60004: LIST
60005: LIST
60006: PUSH
60007: LD_INT 1
60009: NEG
60010: PUSH
60011: LD_INT 1
60013: PUSH
60014: EMPTY
60015: LIST
60016: LIST
60017: PUSH
60018: LD_INT 1
60020: NEG
60021: PUSH
60022: LD_INT 3
60024: NEG
60025: PUSH
60026: EMPTY
60027: LIST
60028: LIST
60029: PUSH
60030: LD_INT 0
60032: PUSH
60033: LD_INT 3
60035: NEG
60036: PUSH
60037: EMPTY
60038: LIST
60039: LIST
60040: PUSH
60041: LD_INT 1
60043: PUSH
60044: LD_INT 2
60046: NEG
60047: PUSH
60048: EMPTY
60049: LIST
60050: LIST
60051: PUSH
60052: EMPTY
60053: LIST
60054: LIST
60055: LIST
60056: LIST
60057: LIST
60058: LIST
60059: LIST
60060: LIST
60061: LIST
60062: LIST
60063: LIST
60064: LIST
60065: LIST
60066: LIST
60067: LIST
60068: LIST
60069: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
60070: LD_ADDR_VAR 0 15
60074: PUSH
60075: LD_INT 0
60077: PUSH
60078: LD_INT 0
60080: PUSH
60081: EMPTY
60082: LIST
60083: LIST
60084: PUSH
60085: LD_INT 0
60087: PUSH
60088: LD_INT 1
60090: NEG
60091: PUSH
60092: EMPTY
60093: LIST
60094: LIST
60095: PUSH
60096: LD_INT 1
60098: PUSH
60099: LD_INT 0
60101: PUSH
60102: EMPTY
60103: LIST
60104: LIST
60105: PUSH
60106: LD_INT 1
60108: PUSH
60109: LD_INT 1
60111: PUSH
60112: EMPTY
60113: LIST
60114: LIST
60115: PUSH
60116: LD_INT 0
60118: PUSH
60119: LD_INT 1
60121: PUSH
60122: EMPTY
60123: LIST
60124: LIST
60125: PUSH
60126: LD_INT 1
60128: NEG
60129: PUSH
60130: LD_INT 0
60132: PUSH
60133: EMPTY
60134: LIST
60135: LIST
60136: PUSH
60137: LD_INT 1
60139: NEG
60140: PUSH
60141: LD_INT 1
60143: NEG
60144: PUSH
60145: EMPTY
60146: LIST
60147: LIST
60148: PUSH
60149: LD_INT 1
60151: PUSH
60152: LD_INT 1
60154: NEG
60155: PUSH
60156: EMPTY
60157: LIST
60158: LIST
60159: PUSH
60160: LD_INT 2
60162: PUSH
60163: LD_INT 0
60165: PUSH
60166: EMPTY
60167: LIST
60168: LIST
60169: PUSH
60170: LD_INT 2
60172: PUSH
60173: LD_INT 1
60175: PUSH
60176: EMPTY
60177: LIST
60178: LIST
60179: PUSH
60180: LD_INT 1
60182: NEG
60183: PUSH
60184: LD_INT 1
60186: PUSH
60187: EMPTY
60188: LIST
60189: LIST
60190: PUSH
60191: LD_INT 2
60193: NEG
60194: PUSH
60195: LD_INT 0
60197: PUSH
60198: EMPTY
60199: LIST
60200: LIST
60201: PUSH
60202: LD_INT 2
60204: NEG
60205: PUSH
60206: LD_INT 1
60208: NEG
60209: PUSH
60210: EMPTY
60211: LIST
60212: LIST
60213: PUSH
60214: LD_INT 2
60216: PUSH
60217: LD_INT 1
60219: NEG
60220: PUSH
60221: EMPTY
60222: LIST
60223: LIST
60224: PUSH
60225: LD_INT 3
60227: PUSH
60228: LD_INT 0
60230: PUSH
60231: EMPTY
60232: LIST
60233: LIST
60234: PUSH
60235: LD_INT 3
60237: PUSH
60238: LD_INT 1
60240: PUSH
60241: EMPTY
60242: LIST
60243: LIST
60244: PUSH
60245: EMPTY
60246: LIST
60247: LIST
60248: LIST
60249: LIST
60250: LIST
60251: LIST
60252: LIST
60253: LIST
60254: LIST
60255: LIST
60256: LIST
60257: LIST
60258: LIST
60259: LIST
60260: LIST
60261: LIST
60262: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
60263: LD_ADDR_VAR 0 16
60267: PUSH
60268: LD_INT 0
60270: PUSH
60271: LD_INT 0
60273: PUSH
60274: EMPTY
60275: LIST
60276: LIST
60277: PUSH
60278: LD_INT 0
60280: PUSH
60281: LD_INT 1
60283: NEG
60284: PUSH
60285: EMPTY
60286: LIST
60287: LIST
60288: PUSH
60289: LD_INT 1
60291: PUSH
60292: LD_INT 0
60294: PUSH
60295: EMPTY
60296: LIST
60297: LIST
60298: PUSH
60299: LD_INT 1
60301: PUSH
60302: LD_INT 1
60304: PUSH
60305: EMPTY
60306: LIST
60307: LIST
60308: PUSH
60309: LD_INT 0
60311: PUSH
60312: LD_INT 1
60314: PUSH
60315: EMPTY
60316: LIST
60317: LIST
60318: PUSH
60319: LD_INT 1
60321: NEG
60322: PUSH
60323: LD_INT 0
60325: PUSH
60326: EMPTY
60327: LIST
60328: LIST
60329: PUSH
60330: LD_INT 1
60332: NEG
60333: PUSH
60334: LD_INT 1
60336: NEG
60337: PUSH
60338: EMPTY
60339: LIST
60340: LIST
60341: PUSH
60342: LD_INT 1
60344: NEG
60345: PUSH
60346: LD_INT 2
60348: NEG
60349: PUSH
60350: EMPTY
60351: LIST
60352: LIST
60353: PUSH
60354: LD_INT 2
60356: PUSH
60357: LD_INT 1
60359: PUSH
60360: EMPTY
60361: LIST
60362: LIST
60363: PUSH
60364: LD_INT 2
60366: PUSH
60367: LD_INT 2
60369: PUSH
60370: EMPTY
60371: LIST
60372: LIST
60373: PUSH
60374: LD_INT 1
60376: PUSH
60377: LD_INT 2
60379: PUSH
60380: EMPTY
60381: LIST
60382: LIST
60383: PUSH
60384: LD_INT 2
60386: NEG
60387: PUSH
60388: LD_INT 1
60390: NEG
60391: PUSH
60392: EMPTY
60393: LIST
60394: LIST
60395: PUSH
60396: LD_INT 2
60398: NEG
60399: PUSH
60400: LD_INT 2
60402: NEG
60403: PUSH
60404: EMPTY
60405: LIST
60406: LIST
60407: PUSH
60408: LD_INT 3
60410: PUSH
60411: LD_INT 2
60413: PUSH
60414: EMPTY
60415: LIST
60416: LIST
60417: PUSH
60418: LD_INT 3
60420: PUSH
60421: LD_INT 3
60423: PUSH
60424: EMPTY
60425: LIST
60426: LIST
60427: PUSH
60428: LD_INT 2
60430: PUSH
60431: LD_INT 3
60433: PUSH
60434: EMPTY
60435: LIST
60436: LIST
60437: PUSH
60438: EMPTY
60439: LIST
60440: LIST
60441: LIST
60442: LIST
60443: LIST
60444: LIST
60445: LIST
60446: LIST
60447: LIST
60448: LIST
60449: LIST
60450: LIST
60451: LIST
60452: LIST
60453: LIST
60454: LIST
60455: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
60456: LD_ADDR_VAR 0 17
60460: PUSH
60461: LD_INT 0
60463: PUSH
60464: LD_INT 0
60466: PUSH
60467: EMPTY
60468: LIST
60469: LIST
60470: PUSH
60471: LD_INT 0
60473: PUSH
60474: LD_INT 1
60476: NEG
60477: PUSH
60478: EMPTY
60479: LIST
60480: LIST
60481: PUSH
60482: LD_INT 1
60484: PUSH
60485: LD_INT 0
60487: PUSH
60488: EMPTY
60489: LIST
60490: LIST
60491: PUSH
60492: LD_INT 1
60494: PUSH
60495: LD_INT 1
60497: PUSH
60498: EMPTY
60499: LIST
60500: LIST
60501: PUSH
60502: LD_INT 0
60504: PUSH
60505: LD_INT 1
60507: PUSH
60508: EMPTY
60509: LIST
60510: LIST
60511: PUSH
60512: LD_INT 1
60514: NEG
60515: PUSH
60516: LD_INT 0
60518: PUSH
60519: EMPTY
60520: LIST
60521: LIST
60522: PUSH
60523: LD_INT 1
60525: NEG
60526: PUSH
60527: LD_INT 1
60529: NEG
60530: PUSH
60531: EMPTY
60532: LIST
60533: LIST
60534: PUSH
60535: LD_INT 1
60537: NEG
60538: PUSH
60539: LD_INT 2
60541: NEG
60542: PUSH
60543: EMPTY
60544: LIST
60545: LIST
60546: PUSH
60547: LD_INT 0
60549: PUSH
60550: LD_INT 2
60552: NEG
60553: PUSH
60554: EMPTY
60555: LIST
60556: LIST
60557: PUSH
60558: LD_INT 1
60560: PUSH
60561: LD_INT 1
60563: NEG
60564: PUSH
60565: EMPTY
60566: LIST
60567: LIST
60568: PUSH
60569: LD_INT 2
60571: PUSH
60572: LD_INT 0
60574: PUSH
60575: EMPTY
60576: LIST
60577: LIST
60578: PUSH
60579: LD_INT 2
60581: PUSH
60582: LD_INT 1
60584: PUSH
60585: EMPTY
60586: LIST
60587: LIST
60588: PUSH
60589: LD_INT 2
60591: PUSH
60592: LD_INT 2
60594: PUSH
60595: EMPTY
60596: LIST
60597: LIST
60598: PUSH
60599: LD_INT 1
60601: PUSH
60602: LD_INT 2
60604: PUSH
60605: EMPTY
60606: LIST
60607: LIST
60608: PUSH
60609: LD_INT 0
60611: PUSH
60612: LD_INT 2
60614: PUSH
60615: EMPTY
60616: LIST
60617: LIST
60618: PUSH
60619: LD_INT 1
60621: NEG
60622: PUSH
60623: LD_INT 1
60625: PUSH
60626: EMPTY
60627: LIST
60628: LIST
60629: PUSH
60630: LD_INT 2
60632: NEG
60633: PUSH
60634: LD_INT 0
60636: PUSH
60637: EMPTY
60638: LIST
60639: LIST
60640: PUSH
60641: LD_INT 2
60643: NEG
60644: PUSH
60645: LD_INT 1
60647: NEG
60648: PUSH
60649: EMPTY
60650: LIST
60651: LIST
60652: PUSH
60653: LD_INT 2
60655: NEG
60656: PUSH
60657: LD_INT 2
60659: NEG
60660: PUSH
60661: EMPTY
60662: LIST
60663: LIST
60664: PUSH
60665: EMPTY
60666: LIST
60667: LIST
60668: LIST
60669: LIST
60670: LIST
60671: LIST
60672: LIST
60673: LIST
60674: LIST
60675: LIST
60676: LIST
60677: LIST
60678: LIST
60679: LIST
60680: LIST
60681: LIST
60682: LIST
60683: LIST
60684: LIST
60685: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
60686: LD_ADDR_VAR 0 18
60690: PUSH
60691: LD_INT 0
60693: PUSH
60694: LD_INT 0
60696: PUSH
60697: EMPTY
60698: LIST
60699: LIST
60700: PUSH
60701: LD_INT 0
60703: PUSH
60704: LD_INT 1
60706: NEG
60707: PUSH
60708: EMPTY
60709: LIST
60710: LIST
60711: PUSH
60712: LD_INT 1
60714: PUSH
60715: LD_INT 0
60717: PUSH
60718: EMPTY
60719: LIST
60720: LIST
60721: PUSH
60722: LD_INT 1
60724: PUSH
60725: LD_INT 1
60727: PUSH
60728: EMPTY
60729: LIST
60730: LIST
60731: PUSH
60732: LD_INT 0
60734: PUSH
60735: LD_INT 1
60737: PUSH
60738: EMPTY
60739: LIST
60740: LIST
60741: PUSH
60742: LD_INT 1
60744: NEG
60745: PUSH
60746: LD_INT 0
60748: PUSH
60749: EMPTY
60750: LIST
60751: LIST
60752: PUSH
60753: LD_INT 1
60755: NEG
60756: PUSH
60757: LD_INT 1
60759: NEG
60760: PUSH
60761: EMPTY
60762: LIST
60763: LIST
60764: PUSH
60765: LD_INT 1
60767: NEG
60768: PUSH
60769: LD_INT 2
60771: NEG
60772: PUSH
60773: EMPTY
60774: LIST
60775: LIST
60776: PUSH
60777: LD_INT 0
60779: PUSH
60780: LD_INT 2
60782: NEG
60783: PUSH
60784: EMPTY
60785: LIST
60786: LIST
60787: PUSH
60788: LD_INT 1
60790: PUSH
60791: LD_INT 1
60793: NEG
60794: PUSH
60795: EMPTY
60796: LIST
60797: LIST
60798: PUSH
60799: LD_INT 2
60801: PUSH
60802: LD_INT 0
60804: PUSH
60805: EMPTY
60806: LIST
60807: LIST
60808: PUSH
60809: LD_INT 2
60811: PUSH
60812: LD_INT 1
60814: PUSH
60815: EMPTY
60816: LIST
60817: LIST
60818: PUSH
60819: LD_INT 2
60821: PUSH
60822: LD_INT 2
60824: PUSH
60825: EMPTY
60826: LIST
60827: LIST
60828: PUSH
60829: LD_INT 1
60831: PUSH
60832: LD_INT 2
60834: PUSH
60835: EMPTY
60836: LIST
60837: LIST
60838: PUSH
60839: LD_INT 0
60841: PUSH
60842: LD_INT 2
60844: PUSH
60845: EMPTY
60846: LIST
60847: LIST
60848: PUSH
60849: LD_INT 1
60851: NEG
60852: PUSH
60853: LD_INT 1
60855: PUSH
60856: EMPTY
60857: LIST
60858: LIST
60859: PUSH
60860: LD_INT 2
60862: NEG
60863: PUSH
60864: LD_INT 0
60866: PUSH
60867: EMPTY
60868: LIST
60869: LIST
60870: PUSH
60871: LD_INT 2
60873: NEG
60874: PUSH
60875: LD_INT 1
60877: NEG
60878: PUSH
60879: EMPTY
60880: LIST
60881: LIST
60882: PUSH
60883: LD_INT 2
60885: NEG
60886: PUSH
60887: LD_INT 2
60889: NEG
60890: PUSH
60891: EMPTY
60892: LIST
60893: LIST
60894: PUSH
60895: EMPTY
60896: LIST
60897: LIST
60898: LIST
60899: LIST
60900: LIST
60901: LIST
60902: LIST
60903: LIST
60904: LIST
60905: LIST
60906: LIST
60907: LIST
60908: LIST
60909: LIST
60910: LIST
60911: LIST
60912: LIST
60913: LIST
60914: LIST
60915: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
60916: LD_ADDR_VAR 0 19
60920: PUSH
60921: LD_INT 0
60923: PUSH
60924: LD_INT 0
60926: PUSH
60927: EMPTY
60928: LIST
60929: LIST
60930: PUSH
60931: LD_INT 0
60933: PUSH
60934: LD_INT 1
60936: NEG
60937: PUSH
60938: EMPTY
60939: LIST
60940: LIST
60941: PUSH
60942: LD_INT 1
60944: PUSH
60945: LD_INT 0
60947: PUSH
60948: EMPTY
60949: LIST
60950: LIST
60951: PUSH
60952: LD_INT 1
60954: PUSH
60955: LD_INT 1
60957: PUSH
60958: EMPTY
60959: LIST
60960: LIST
60961: PUSH
60962: LD_INT 0
60964: PUSH
60965: LD_INT 1
60967: PUSH
60968: EMPTY
60969: LIST
60970: LIST
60971: PUSH
60972: LD_INT 1
60974: NEG
60975: PUSH
60976: LD_INT 0
60978: PUSH
60979: EMPTY
60980: LIST
60981: LIST
60982: PUSH
60983: LD_INT 1
60985: NEG
60986: PUSH
60987: LD_INT 1
60989: NEG
60990: PUSH
60991: EMPTY
60992: LIST
60993: LIST
60994: PUSH
60995: LD_INT 1
60997: NEG
60998: PUSH
60999: LD_INT 2
61001: NEG
61002: PUSH
61003: EMPTY
61004: LIST
61005: LIST
61006: PUSH
61007: LD_INT 0
61009: PUSH
61010: LD_INT 2
61012: NEG
61013: PUSH
61014: EMPTY
61015: LIST
61016: LIST
61017: PUSH
61018: LD_INT 1
61020: PUSH
61021: LD_INT 1
61023: NEG
61024: PUSH
61025: EMPTY
61026: LIST
61027: LIST
61028: PUSH
61029: LD_INT 2
61031: PUSH
61032: LD_INT 0
61034: PUSH
61035: EMPTY
61036: LIST
61037: LIST
61038: PUSH
61039: LD_INT 2
61041: PUSH
61042: LD_INT 1
61044: PUSH
61045: EMPTY
61046: LIST
61047: LIST
61048: PUSH
61049: LD_INT 2
61051: PUSH
61052: LD_INT 2
61054: PUSH
61055: EMPTY
61056: LIST
61057: LIST
61058: PUSH
61059: LD_INT 1
61061: PUSH
61062: LD_INT 2
61064: PUSH
61065: EMPTY
61066: LIST
61067: LIST
61068: PUSH
61069: LD_INT 0
61071: PUSH
61072: LD_INT 2
61074: PUSH
61075: EMPTY
61076: LIST
61077: LIST
61078: PUSH
61079: LD_INT 1
61081: NEG
61082: PUSH
61083: LD_INT 1
61085: PUSH
61086: EMPTY
61087: LIST
61088: LIST
61089: PUSH
61090: LD_INT 2
61092: NEG
61093: PUSH
61094: LD_INT 0
61096: PUSH
61097: EMPTY
61098: LIST
61099: LIST
61100: PUSH
61101: LD_INT 2
61103: NEG
61104: PUSH
61105: LD_INT 1
61107: NEG
61108: PUSH
61109: EMPTY
61110: LIST
61111: LIST
61112: PUSH
61113: LD_INT 2
61115: NEG
61116: PUSH
61117: LD_INT 2
61119: NEG
61120: PUSH
61121: EMPTY
61122: LIST
61123: LIST
61124: PUSH
61125: EMPTY
61126: LIST
61127: LIST
61128: LIST
61129: LIST
61130: LIST
61131: LIST
61132: LIST
61133: LIST
61134: LIST
61135: LIST
61136: LIST
61137: LIST
61138: LIST
61139: LIST
61140: LIST
61141: LIST
61142: LIST
61143: LIST
61144: LIST
61145: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
61146: LD_ADDR_VAR 0 20
61150: PUSH
61151: LD_INT 0
61153: PUSH
61154: LD_INT 0
61156: PUSH
61157: EMPTY
61158: LIST
61159: LIST
61160: PUSH
61161: LD_INT 0
61163: PUSH
61164: LD_INT 1
61166: NEG
61167: PUSH
61168: EMPTY
61169: LIST
61170: LIST
61171: PUSH
61172: LD_INT 1
61174: PUSH
61175: LD_INT 0
61177: PUSH
61178: EMPTY
61179: LIST
61180: LIST
61181: PUSH
61182: LD_INT 1
61184: PUSH
61185: LD_INT 1
61187: PUSH
61188: EMPTY
61189: LIST
61190: LIST
61191: PUSH
61192: LD_INT 0
61194: PUSH
61195: LD_INT 1
61197: PUSH
61198: EMPTY
61199: LIST
61200: LIST
61201: PUSH
61202: LD_INT 1
61204: NEG
61205: PUSH
61206: LD_INT 0
61208: PUSH
61209: EMPTY
61210: LIST
61211: LIST
61212: PUSH
61213: LD_INT 1
61215: NEG
61216: PUSH
61217: LD_INT 1
61219: NEG
61220: PUSH
61221: EMPTY
61222: LIST
61223: LIST
61224: PUSH
61225: LD_INT 1
61227: NEG
61228: PUSH
61229: LD_INT 2
61231: NEG
61232: PUSH
61233: EMPTY
61234: LIST
61235: LIST
61236: PUSH
61237: LD_INT 0
61239: PUSH
61240: LD_INT 2
61242: NEG
61243: PUSH
61244: EMPTY
61245: LIST
61246: LIST
61247: PUSH
61248: LD_INT 1
61250: PUSH
61251: LD_INT 1
61253: NEG
61254: PUSH
61255: EMPTY
61256: LIST
61257: LIST
61258: PUSH
61259: LD_INT 2
61261: PUSH
61262: LD_INT 0
61264: PUSH
61265: EMPTY
61266: LIST
61267: LIST
61268: PUSH
61269: LD_INT 2
61271: PUSH
61272: LD_INT 1
61274: PUSH
61275: EMPTY
61276: LIST
61277: LIST
61278: PUSH
61279: LD_INT 2
61281: PUSH
61282: LD_INT 2
61284: PUSH
61285: EMPTY
61286: LIST
61287: LIST
61288: PUSH
61289: LD_INT 1
61291: PUSH
61292: LD_INT 2
61294: PUSH
61295: EMPTY
61296: LIST
61297: LIST
61298: PUSH
61299: LD_INT 0
61301: PUSH
61302: LD_INT 2
61304: PUSH
61305: EMPTY
61306: LIST
61307: LIST
61308: PUSH
61309: LD_INT 1
61311: NEG
61312: PUSH
61313: LD_INT 1
61315: PUSH
61316: EMPTY
61317: LIST
61318: LIST
61319: PUSH
61320: LD_INT 2
61322: NEG
61323: PUSH
61324: LD_INT 0
61326: PUSH
61327: EMPTY
61328: LIST
61329: LIST
61330: PUSH
61331: LD_INT 2
61333: NEG
61334: PUSH
61335: LD_INT 1
61337: NEG
61338: PUSH
61339: EMPTY
61340: LIST
61341: LIST
61342: PUSH
61343: LD_INT 2
61345: NEG
61346: PUSH
61347: LD_INT 2
61349: NEG
61350: PUSH
61351: EMPTY
61352: LIST
61353: LIST
61354: PUSH
61355: EMPTY
61356: LIST
61357: LIST
61358: LIST
61359: LIST
61360: LIST
61361: LIST
61362: LIST
61363: LIST
61364: LIST
61365: LIST
61366: LIST
61367: LIST
61368: LIST
61369: LIST
61370: LIST
61371: LIST
61372: LIST
61373: LIST
61374: LIST
61375: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
61376: LD_ADDR_VAR 0 21
61380: PUSH
61381: LD_INT 0
61383: PUSH
61384: LD_INT 0
61386: PUSH
61387: EMPTY
61388: LIST
61389: LIST
61390: PUSH
61391: LD_INT 0
61393: PUSH
61394: LD_INT 1
61396: NEG
61397: PUSH
61398: EMPTY
61399: LIST
61400: LIST
61401: PUSH
61402: LD_INT 1
61404: PUSH
61405: LD_INT 0
61407: PUSH
61408: EMPTY
61409: LIST
61410: LIST
61411: PUSH
61412: LD_INT 1
61414: PUSH
61415: LD_INT 1
61417: PUSH
61418: EMPTY
61419: LIST
61420: LIST
61421: PUSH
61422: LD_INT 0
61424: PUSH
61425: LD_INT 1
61427: PUSH
61428: EMPTY
61429: LIST
61430: LIST
61431: PUSH
61432: LD_INT 1
61434: NEG
61435: PUSH
61436: LD_INT 0
61438: PUSH
61439: EMPTY
61440: LIST
61441: LIST
61442: PUSH
61443: LD_INT 1
61445: NEG
61446: PUSH
61447: LD_INT 1
61449: NEG
61450: PUSH
61451: EMPTY
61452: LIST
61453: LIST
61454: PUSH
61455: LD_INT 1
61457: NEG
61458: PUSH
61459: LD_INT 2
61461: NEG
61462: PUSH
61463: EMPTY
61464: LIST
61465: LIST
61466: PUSH
61467: LD_INT 0
61469: PUSH
61470: LD_INT 2
61472: NEG
61473: PUSH
61474: EMPTY
61475: LIST
61476: LIST
61477: PUSH
61478: LD_INT 1
61480: PUSH
61481: LD_INT 1
61483: NEG
61484: PUSH
61485: EMPTY
61486: LIST
61487: LIST
61488: PUSH
61489: LD_INT 2
61491: PUSH
61492: LD_INT 0
61494: PUSH
61495: EMPTY
61496: LIST
61497: LIST
61498: PUSH
61499: LD_INT 2
61501: PUSH
61502: LD_INT 1
61504: PUSH
61505: EMPTY
61506: LIST
61507: LIST
61508: PUSH
61509: LD_INT 2
61511: PUSH
61512: LD_INT 2
61514: PUSH
61515: EMPTY
61516: LIST
61517: LIST
61518: PUSH
61519: LD_INT 1
61521: PUSH
61522: LD_INT 2
61524: PUSH
61525: EMPTY
61526: LIST
61527: LIST
61528: PUSH
61529: LD_INT 0
61531: PUSH
61532: LD_INT 2
61534: PUSH
61535: EMPTY
61536: LIST
61537: LIST
61538: PUSH
61539: LD_INT 1
61541: NEG
61542: PUSH
61543: LD_INT 1
61545: PUSH
61546: EMPTY
61547: LIST
61548: LIST
61549: PUSH
61550: LD_INT 2
61552: NEG
61553: PUSH
61554: LD_INT 0
61556: PUSH
61557: EMPTY
61558: LIST
61559: LIST
61560: PUSH
61561: LD_INT 2
61563: NEG
61564: PUSH
61565: LD_INT 1
61567: NEG
61568: PUSH
61569: EMPTY
61570: LIST
61571: LIST
61572: PUSH
61573: LD_INT 2
61575: NEG
61576: PUSH
61577: LD_INT 2
61579: NEG
61580: PUSH
61581: EMPTY
61582: LIST
61583: LIST
61584: PUSH
61585: EMPTY
61586: LIST
61587: LIST
61588: LIST
61589: LIST
61590: LIST
61591: LIST
61592: LIST
61593: LIST
61594: LIST
61595: LIST
61596: LIST
61597: LIST
61598: LIST
61599: LIST
61600: LIST
61601: LIST
61602: LIST
61603: LIST
61604: LIST
61605: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
61606: LD_ADDR_VAR 0 22
61610: PUSH
61611: LD_INT 0
61613: PUSH
61614: LD_INT 0
61616: PUSH
61617: EMPTY
61618: LIST
61619: LIST
61620: PUSH
61621: LD_INT 0
61623: PUSH
61624: LD_INT 1
61626: NEG
61627: PUSH
61628: EMPTY
61629: LIST
61630: LIST
61631: PUSH
61632: LD_INT 1
61634: PUSH
61635: LD_INT 0
61637: PUSH
61638: EMPTY
61639: LIST
61640: LIST
61641: PUSH
61642: LD_INT 1
61644: PUSH
61645: LD_INT 1
61647: PUSH
61648: EMPTY
61649: LIST
61650: LIST
61651: PUSH
61652: LD_INT 0
61654: PUSH
61655: LD_INT 1
61657: PUSH
61658: EMPTY
61659: LIST
61660: LIST
61661: PUSH
61662: LD_INT 1
61664: NEG
61665: PUSH
61666: LD_INT 0
61668: PUSH
61669: EMPTY
61670: LIST
61671: LIST
61672: PUSH
61673: LD_INT 1
61675: NEG
61676: PUSH
61677: LD_INT 1
61679: NEG
61680: PUSH
61681: EMPTY
61682: LIST
61683: LIST
61684: PUSH
61685: LD_INT 1
61687: NEG
61688: PUSH
61689: LD_INT 2
61691: NEG
61692: PUSH
61693: EMPTY
61694: LIST
61695: LIST
61696: PUSH
61697: LD_INT 0
61699: PUSH
61700: LD_INT 2
61702: NEG
61703: PUSH
61704: EMPTY
61705: LIST
61706: LIST
61707: PUSH
61708: LD_INT 1
61710: PUSH
61711: LD_INT 1
61713: NEG
61714: PUSH
61715: EMPTY
61716: LIST
61717: LIST
61718: PUSH
61719: LD_INT 2
61721: PUSH
61722: LD_INT 0
61724: PUSH
61725: EMPTY
61726: LIST
61727: LIST
61728: PUSH
61729: LD_INT 2
61731: PUSH
61732: LD_INT 1
61734: PUSH
61735: EMPTY
61736: LIST
61737: LIST
61738: PUSH
61739: LD_INT 2
61741: PUSH
61742: LD_INT 2
61744: PUSH
61745: EMPTY
61746: LIST
61747: LIST
61748: PUSH
61749: LD_INT 1
61751: PUSH
61752: LD_INT 2
61754: PUSH
61755: EMPTY
61756: LIST
61757: LIST
61758: PUSH
61759: LD_INT 0
61761: PUSH
61762: LD_INT 2
61764: PUSH
61765: EMPTY
61766: LIST
61767: LIST
61768: PUSH
61769: LD_INT 1
61771: NEG
61772: PUSH
61773: LD_INT 1
61775: PUSH
61776: EMPTY
61777: LIST
61778: LIST
61779: PUSH
61780: LD_INT 2
61782: NEG
61783: PUSH
61784: LD_INT 0
61786: PUSH
61787: EMPTY
61788: LIST
61789: LIST
61790: PUSH
61791: LD_INT 2
61793: NEG
61794: PUSH
61795: LD_INT 1
61797: NEG
61798: PUSH
61799: EMPTY
61800: LIST
61801: LIST
61802: PUSH
61803: LD_INT 2
61805: NEG
61806: PUSH
61807: LD_INT 2
61809: NEG
61810: PUSH
61811: EMPTY
61812: LIST
61813: LIST
61814: PUSH
61815: EMPTY
61816: LIST
61817: LIST
61818: LIST
61819: LIST
61820: LIST
61821: LIST
61822: LIST
61823: LIST
61824: LIST
61825: LIST
61826: LIST
61827: LIST
61828: LIST
61829: LIST
61830: LIST
61831: LIST
61832: LIST
61833: LIST
61834: LIST
61835: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
61836: LD_ADDR_VAR 0 23
61840: PUSH
61841: LD_INT 0
61843: PUSH
61844: LD_INT 0
61846: PUSH
61847: EMPTY
61848: LIST
61849: LIST
61850: PUSH
61851: LD_INT 0
61853: PUSH
61854: LD_INT 1
61856: NEG
61857: PUSH
61858: EMPTY
61859: LIST
61860: LIST
61861: PUSH
61862: LD_INT 1
61864: PUSH
61865: LD_INT 0
61867: PUSH
61868: EMPTY
61869: LIST
61870: LIST
61871: PUSH
61872: LD_INT 1
61874: PUSH
61875: LD_INT 1
61877: PUSH
61878: EMPTY
61879: LIST
61880: LIST
61881: PUSH
61882: LD_INT 0
61884: PUSH
61885: LD_INT 1
61887: PUSH
61888: EMPTY
61889: LIST
61890: LIST
61891: PUSH
61892: LD_INT 1
61894: NEG
61895: PUSH
61896: LD_INT 0
61898: PUSH
61899: EMPTY
61900: LIST
61901: LIST
61902: PUSH
61903: LD_INT 1
61905: NEG
61906: PUSH
61907: LD_INT 1
61909: NEG
61910: PUSH
61911: EMPTY
61912: LIST
61913: LIST
61914: PUSH
61915: LD_INT 1
61917: NEG
61918: PUSH
61919: LD_INT 2
61921: NEG
61922: PUSH
61923: EMPTY
61924: LIST
61925: LIST
61926: PUSH
61927: LD_INT 0
61929: PUSH
61930: LD_INT 2
61932: NEG
61933: PUSH
61934: EMPTY
61935: LIST
61936: LIST
61937: PUSH
61938: LD_INT 1
61940: PUSH
61941: LD_INT 1
61943: NEG
61944: PUSH
61945: EMPTY
61946: LIST
61947: LIST
61948: PUSH
61949: LD_INT 2
61951: PUSH
61952: LD_INT 0
61954: PUSH
61955: EMPTY
61956: LIST
61957: LIST
61958: PUSH
61959: LD_INT 2
61961: PUSH
61962: LD_INT 1
61964: PUSH
61965: EMPTY
61966: LIST
61967: LIST
61968: PUSH
61969: LD_INT 2
61971: PUSH
61972: LD_INT 2
61974: PUSH
61975: EMPTY
61976: LIST
61977: LIST
61978: PUSH
61979: LD_INT 1
61981: PUSH
61982: LD_INT 2
61984: PUSH
61985: EMPTY
61986: LIST
61987: LIST
61988: PUSH
61989: LD_INT 0
61991: PUSH
61992: LD_INT 2
61994: PUSH
61995: EMPTY
61996: LIST
61997: LIST
61998: PUSH
61999: LD_INT 1
62001: NEG
62002: PUSH
62003: LD_INT 1
62005: PUSH
62006: EMPTY
62007: LIST
62008: LIST
62009: PUSH
62010: LD_INT 2
62012: NEG
62013: PUSH
62014: LD_INT 0
62016: PUSH
62017: EMPTY
62018: LIST
62019: LIST
62020: PUSH
62021: LD_INT 2
62023: NEG
62024: PUSH
62025: LD_INT 1
62027: NEG
62028: PUSH
62029: EMPTY
62030: LIST
62031: LIST
62032: PUSH
62033: LD_INT 2
62035: NEG
62036: PUSH
62037: LD_INT 2
62039: NEG
62040: PUSH
62041: EMPTY
62042: LIST
62043: LIST
62044: PUSH
62045: LD_INT 2
62047: NEG
62048: PUSH
62049: LD_INT 3
62051: NEG
62052: PUSH
62053: EMPTY
62054: LIST
62055: LIST
62056: PUSH
62057: LD_INT 1
62059: NEG
62060: PUSH
62061: LD_INT 3
62063: NEG
62064: PUSH
62065: EMPTY
62066: LIST
62067: LIST
62068: PUSH
62069: LD_INT 1
62071: PUSH
62072: LD_INT 2
62074: NEG
62075: PUSH
62076: EMPTY
62077: LIST
62078: LIST
62079: PUSH
62080: LD_INT 2
62082: PUSH
62083: LD_INT 1
62085: NEG
62086: PUSH
62087: EMPTY
62088: LIST
62089: LIST
62090: PUSH
62091: EMPTY
62092: LIST
62093: LIST
62094: LIST
62095: LIST
62096: LIST
62097: LIST
62098: LIST
62099: LIST
62100: LIST
62101: LIST
62102: LIST
62103: LIST
62104: LIST
62105: LIST
62106: LIST
62107: LIST
62108: LIST
62109: LIST
62110: LIST
62111: LIST
62112: LIST
62113: LIST
62114: LIST
62115: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
62116: LD_ADDR_VAR 0 24
62120: PUSH
62121: LD_INT 0
62123: PUSH
62124: LD_INT 0
62126: PUSH
62127: EMPTY
62128: LIST
62129: LIST
62130: PUSH
62131: LD_INT 0
62133: PUSH
62134: LD_INT 1
62136: NEG
62137: PUSH
62138: EMPTY
62139: LIST
62140: LIST
62141: PUSH
62142: LD_INT 1
62144: PUSH
62145: LD_INT 0
62147: PUSH
62148: EMPTY
62149: LIST
62150: LIST
62151: PUSH
62152: LD_INT 1
62154: PUSH
62155: LD_INT 1
62157: PUSH
62158: EMPTY
62159: LIST
62160: LIST
62161: PUSH
62162: LD_INT 0
62164: PUSH
62165: LD_INT 1
62167: PUSH
62168: EMPTY
62169: LIST
62170: LIST
62171: PUSH
62172: LD_INT 1
62174: NEG
62175: PUSH
62176: LD_INT 0
62178: PUSH
62179: EMPTY
62180: LIST
62181: LIST
62182: PUSH
62183: LD_INT 1
62185: NEG
62186: PUSH
62187: LD_INT 1
62189: NEG
62190: PUSH
62191: EMPTY
62192: LIST
62193: LIST
62194: PUSH
62195: LD_INT 1
62197: NEG
62198: PUSH
62199: LD_INT 2
62201: NEG
62202: PUSH
62203: EMPTY
62204: LIST
62205: LIST
62206: PUSH
62207: LD_INT 0
62209: PUSH
62210: LD_INT 2
62212: NEG
62213: PUSH
62214: EMPTY
62215: LIST
62216: LIST
62217: PUSH
62218: LD_INT 1
62220: PUSH
62221: LD_INT 1
62223: NEG
62224: PUSH
62225: EMPTY
62226: LIST
62227: LIST
62228: PUSH
62229: LD_INT 2
62231: PUSH
62232: LD_INT 0
62234: PUSH
62235: EMPTY
62236: LIST
62237: LIST
62238: PUSH
62239: LD_INT 2
62241: PUSH
62242: LD_INT 1
62244: PUSH
62245: EMPTY
62246: LIST
62247: LIST
62248: PUSH
62249: LD_INT 2
62251: PUSH
62252: LD_INT 2
62254: PUSH
62255: EMPTY
62256: LIST
62257: LIST
62258: PUSH
62259: LD_INT 1
62261: PUSH
62262: LD_INT 2
62264: PUSH
62265: EMPTY
62266: LIST
62267: LIST
62268: PUSH
62269: LD_INT 0
62271: PUSH
62272: LD_INT 2
62274: PUSH
62275: EMPTY
62276: LIST
62277: LIST
62278: PUSH
62279: LD_INT 1
62281: NEG
62282: PUSH
62283: LD_INT 1
62285: PUSH
62286: EMPTY
62287: LIST
62288: LIST
62289: PUSH
62290: LD_INT 2
62292: NEG
62293: PUSH
62294: LD_INT 0
62296: PUSH
62297: EMPTY
62298: LIST
62299: LIST
62300: PUSH
62301: LD_INT 2
62303: NEG
62304: PUSH
62305: LD_INT 1
62307: NEG
62308: PUSH
62309: EMPTY
62310: LIST
62311: LIST
62312: PUSH
62313: LD_INT 2
62315: NEG
62316: PUSH
62317: LD_INT 2
62319: NEG
62320: PUSH
62321: EMPTY
62322: LIST
62323: LIST
62324: PUSH
62325: LD_INT 1
62327: PUSH
62328: LD_INT 2
62330: NEG
62331: PUSH
62332: EMPTY
62333: LIST
62334: LIST
62335: PUSH
62336: LD_INT 2
62338: PUSH
62339: LD_INT 1
62341: NEG
62342: PUSH
62343: EMPTY
62344: LIST
62345: LIST
62346: PUSH
62347: LD_INT 3
62349: PUSH
62350: LD_INT 1
62352: PUSH
62353: EMPTY
62354: LIST
62355: LIST
62356: PUSH
62357: LD_INT 3
62359: PUSH
62360: LD_INT 2
62362: PUSH
62363: EMPTY
62364: LIST
62365: LIST
62366: PUSH
62367: EMPTY
62368: LIST
62369: LIST
62370: LIST
62371: LIST
62372: LIST
62373: LIST
62374: LIST
62375: LIST
62376: LIST
62377: LIST
62378: LIST
62379: LIST
62380: LIST
62381: LIST
62382: LIST
62383: LIST
62384: LIST
62385: LIST
62386: LIST
62387: LIST
62388: LIST
62389: LIST
62390: LIST
62391: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
62392: LD_ADDR_VAR 0 25
62396: PUSH
62397: LD_INT 0
62399: PUSH
62400: LD_INT 0
62402: PUSH
62403: EMPTY
62404: LIST
62405: LIST
62406: PUSH
62407: LD_INT 0
62409: PUSH
62410: LD_INT 1
62412: NEG
62413: PUSH
62414: EMPTY
62415: LIST
62416: LIST
62417: PUSH
62418: LD_INT 1
62420: PUSH
62421: LD_INT 0
62423: PUSH
62424: EMPTY
62425: LIST
62426: LIST
62427: PUSH
62428: LD_INT 1
62430: PUSH
62431: LD_INT 1
62433: PUSH
62434: EMPTY
62435: LIST
62436: LIST
62437: PUSH
62438: LD_INT 0
62440: PUSH
62441: LD_INT 1
62443: PUSH
62444: EMPTY
62445: LIST
62446: LIST
62447: PUSH
62448: LD_INT 1
62450: NEG
62451: PUSH
62452: LD_INT 0
62454: PUSH
62455: EMPTY
62456: LIST
62457: LIST
62458: PUSH
62459: LD_INT 1
62461: NEG
62462: PUSH
62463: LD_INT 1
62465: NEG
62466: PUSH
62467: EMPTY
62468: LIST
62469: LIST
62470: PUSH
62471: LD_INT 1
62473: NEG
62474: PUSH
62475: LD_INT 2
62477: NEG
62478: PUSH
62479: EMPTY
62480: LIST
62481: LIST
62482: PUSH
62483: LD_INT 0
62485: PUSH
62486: LD_INT 2
62488: NEG
62489: PUSH
62490: EMPTY
62491: LIST
62492: LIST
62493: PUSH
62494: LD_INT 1
62496: PUSH
62497: LD_INT 1
62499: NEG
62500: PUSH
62501: EMPTY
62502: LIST
62503: LIST
62504: PUSH
62505: LD_INT 2
62507: PUSH
62508: LD_INT 0
62510: PUSH
62511: EMPTY
62512: LIST
62513: LIST
62514: PUSH
62515: LD_INT 2
62517: PUSH
62518: LD_INT 1
62520: PUSH
62521: EMPTY
62522: LIST
62523: LIST
62524: PUSH
62525: LD_INT 2
62527: PUSH
62528: LD_INT 2
62530: PUSH
62531: EMPTY
62532: LIST
62533: LIST
62534: PUSH
62535: LD_INT 1
62537: PUSH
62538: LD_INT 2
62540: PUSH
62541: EMPTY
62542: LIST
62543: LIST
62544: PUSH
62545: LD_INT 0
62547: PUSH
62548: LD_INT 2
62550: PUSH
62551: EMPTY
62552: LIST
62553: LIST
62554: PUSH
62555: LD_INT 1
62557: NEG
62558: PUSH
62559: LD_INT 1
62561: PUSH
62562: EMPTY
62563: LIST
62564: LIST
62565: PUSH
62566: LD_INT 2
62568: NEG
62569: PUSH
62570: LD_INT 0
62572: PUSH
62573: EMPTY
62574: LIST
62575: LIST
62576: PUSH
62577: LD_INT 2
62579: NEG
62580: PUSH
62581: LD_INT 1
62583: NEG
62584: PUSH
62585: EMPTY
62586: LIST
62587: LIST
62588: PUSH
62589: LD_INT 2
62591: NEG
62592: PUSH
62593: LD_INT 2
62595: NEG
62596: PUSH
62597: EMPTY
62598: LIST
62599: LIST
62600: PUSH
62601: LD_INT 3
62603: PUSH
62604: LD_INT 1
62606: PUSH
62607: EMPTY
62608: LIST
62609: LIST
62610: PUSH
62611: LD_INT 3
62613: PUSH
62614: LD_INT 2
62616: PUSH
62617: EMPTY
62618: LIST
62619: LIST
62620: PUSH
62621: LD_INT 2
62623: PUSH
62624: LD_INT 3
62626: PUSH
62627: EMPTY
62628: LIST
62629: LIST
62630: PUSH
62631: LD_INT 1
62633: PUSH
62634: LD_INT 3
62636: PUSH
62637: EMPTY
62638: LIST
62639: LIST
62640: PUSH
62641: EMPTY
62642: LIST
62643: LIST
62644: LIST
62645: LIST
62646: LIST
62647: LIST
62648: LIST
62649: LIST
62650: LIST
62651: LIST
62652: LIST
62653: LIST
62654: LIST
62655: LIST
62656: LIST
62657: LIST
62658: LIST
62659: LIST
62660: LIST
62661: LIST
62662: LIST
62663: LIST
62664: LIST
62665: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
62666: LD_ADDR_VAR 0 26
62670: PUSH
62671: LD_INT 0
62673: PUSH
62674: LD_INT 0
62676: PUSH
62677: EMPTY
62678: LIST
62679: LIST
62680: PUSH
62681: LD_INT 0
62683: PUSH
62684: LD_INT 1
62686: NEG
62687: PUSH
62688: EMPTY
62689: LIST
62690: LIST
62691: PUSH
62692: LD_INT 1
62694: PUSH
62695: LD_INT 0
62697: PUSH
62698: EMPTY
62699: LIST
62700: LIST
62701: PUSH
62702: LD_INT 1
62704: PUSH
62705: LD_INT 1
62707: PUSH
62708: EMPTY
62709: LIST
62710: LIST
62711: PUSH
62712: LD_INT 0
62714: PUSH
62715: LD_INT 1
62717: PUSH
62718: EMPTY
62719: LIST
62720: LIST
62721: PUSH
62722: LD_INT 1
62724: NEG
62725: PUSH
62726: LD_INT 0
62728: PUSH
62729: EMPTY
62730: LIST
62731: LIST
62732: PUSH
62733: LD_INT 1
62735: NEG
62736: PUSH
62737: LD_INT 1
62739: NEG
62740: PUSH
62741: EMPTY
62742: LIST
62743: LIST
62744: PUSH
62745: LD_INT 1
62747: NEG
62748: PUSH
62749: LD_INT 2
62751: NEG
62752: PUSH
62753: EMPTY
62754: LIST
62755: LIST
62756: PUSH
62757: LD_INT 0
62759: PUSH
62760: LD_INT 2
62762: NEG
62763: PUSH
62764: EMPTY
62765: LIST
62766: LIST
62767: PUSH
62768: LD_INT 1
62770: PUSH
62771: LD_INT 1
62773: NEG
62774: PUSH
62775: EMPTY
62776: LIST
62777: LIST
62778: PUSH
62779: LD_INT 2
62781: PUSH
62782: LD_INT 0
62784: PUSH
62785: EMPTY
62786: LIST
62787: LIST
62788: PUSH
62789: LD_INT 2
62791: PUSH
62792: LD_INT 1
62794: PUSH
62795: EMPTY
62796: LIST
62797: LIST
62798: PUSH
62799: LD_INT 2
62801: PUSH
62802: LD_INT 2
62804: PUSH
62805: EMPTY
62806: LIST
62807: LIST
62808: PUSH
62809: LD_INT 1
62811: PUSH
62812: LD_INT 2
62814: PUSH
62815: EMPTY
62816: LIST
62817: LIST
62818: PUSH
62819: LD_INT 0
62821: PUSH
62822: LD_INT 2
62824: PUSH
62825: EMPTY
62826: LIST
62827: LIST
62828: PUSH
62829: LD_INT 1
62831: NEG
62832: PUSH
62833: LD_INT 1
62835: PUSH
62836: EMPTY
62837: LIST
62838: LIST
62839: PUSH
62840: LD_INT 2
62842: NEG
62843: PUSH
62844: LD_INT 0
62846: PUSH
62847: EMPTY
62848: LIST
62849: LIST
62850: PUSH
62851: LD_INT 2
62853: NEG
62854: PUSH
62855: LD_INT 1
62857: NEG
62858: PUSH
62859: EMPTY
62860: LIST
62861: LIST
62862: PUSH
62863: LD_INT 2
62865: NEG
62866: PUSH
62867: LD_INT 2
62869: NEG
62870: PUSH
62871: EMPTY
62872: LIST
62873: LIST
62874: PUSH
62875: LD_INT 2
62877: PUSH
62878: LD_INT 3
62880: PUSH
62881: EMPTY
62882: LIST
62883: LIST
62884: PUSH
62885: LD_INT 1
62887: PUSH
62888: LD_INT 3
62890: PUSH
62891: EMPTY
62892: LIST
62893: LIST
62894: PUSH
62895: LD_INT 1
62897: NEG
62898: PUSH
62899: LD_INT 2
62901: PUSH
62902: EMPTY
62903: LIST
62904: LIST
62905: PUSH
62906: LD_INT 2
62908: NEG
62909: PUSH
62910: LD_INT 1
62912: PUSH
62913: EMPTY
62914: LIST
62915: LIST
62916: PUSH
62917: EMPTY
62918: LIST
62919: LIST
62920: LIST
62921: LIST
62922: LIST
62923: LIST
62924: LIST
62925: LIST
62926: LIST
62927: LIST
62928: LIST
62929: LIST
62930: LIST
62931: LIST
62932: LIST
62933: LIST
62934: LIST
62935: LIST
62936: LIST
62937: LIST
62938: LIST
62939: LIST
62940: LIST
62941: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
62942: LD_ADDR_VAR 0 27
62946: PUSH
62947: LD_INT 0
62949: PUSH
62950: LD_INT 0
62952: PUSH
62953: EMPTY
62954: LIST
62955: LIST
62956: PUSH
62957: LD_INT 0
62959: PUSH
62960: LD_INT 1
62962: NEG
62963: PUSH
62964: EMPTY
62965: LIST
62966: LIST
62967: PUSH
62968: LD_INT 1
62970: PUSH
62971: LD_INT 0
62973: PUSH
62974: EMPTY
62975: LIST
62976: LIST
62977: PUSH
62978: LD_INT 1
62980: PUSH
62981: LD_INT 1
62983: PUSH
62984: EMPTY
62985: LIST
62986: LIST
62987: PUSH
62988: LD_INT 0
62990: PUSH
62991: LD_INT 1
62993: PUSH
62994: EMPTY
62995: LIST
62996: LIST
62997: PUSH
62998: LD_INT 1
63000: NEG
63001: PUSH
63002: LD_INT 0
63004: PUSH
63005: EMPTY
63006: LIST
63007: LIST
63008: PUSH
63009: LD_INT 1
63011: NEG
63012: PUSH
63013: LD_INT 1
63015: NEG
63016: PUSH
63017: EMPTY
63018: LIST
63019: LIST
63020: PUSH
63021: LD_INT 1
63023: NEG
63024: PUSH
63025: LD_INT 2
63027: NEG
63028: PUSH
63029: EMPTY
63030: LIST
63031: LIST
63032: PUSH
63033: LD_INT 0
63035: PUSH
63036: LD_INT 2
63038: NEG
63039: PUSH
63040: EMPTY
63041: LIST
63042: LIST
63043: PUSH
63044: LD_INT 1
63046: PUSH
63047: LD_INT 1
63049: NEG
63050: PUSH
63051: EMPTY
63052: LIST
63053: LIST
63054: PUSH
63055: LD_INT 2
63057: PUSH
63058: LD_INT 0
63060: PUSH
63061: EMPTY
63062: LIST
63063: LIST
63064: PUSH
63065: LD_INT 2
63067: PUSH
63068: LD_INT 1
63070: PUSH
63071: EMPTY
63072: LIST
63073: LIST
63074: PUSH
63075: LD_INT 2
63077: PUSH
63078: LD_INT 2
63080: PUSH
63081: EMPTY
63082: LIST
63083: LIST
63084: PUSH
63085: LD_INT 1
63087: PUSH
63088: LD_INT 2
63090: PUSH
63091: EMPTY
63092: LIST
63093: LIST
63094: PUSH
63095: LD_INT 0
63097: PUSH
63098: LD_INT 2
63100: PUSH
63101: EMPTY
63102: LIST
63103: LIST
63104: PUSH
63105: LD_INT 1
63107: NEG
63108: PUSH
63109: LD_INT 1
63111: PUSH
63112: EMPTY
63113: LIST
63114: LIST
63115: PUSH
63116: LD_INT 2
63118: NEG
63119: PUSH
63120: LD_INT 0
63122: PUSH
63123: EMPTY
63124: LIST
63125: LIST
63126: PUSH
63127: LD_INT 2
63129: NEG
63130: PUSH
63131: LD_INT 1
63133: NEG
63134: PUSH
63135: EMPTY
63136: LIST
63137: LIST
63138: PUSH
63139: LD_INT 2
63141: NEG
63142: PUSH
63143: LD_INT 2
63145: NEG
63146: PUSH
63147: EMPTY
63148: LIST
63149: LIST
63150: PUSH
63151: LD_INT 1
63153: NEG
63154: PUSH
63155: LD_INT 2
63157: PUSH
63158: EMPTY
63159: LIST
63160: LIST
63161: PUSH
63162: LD_INT 2
63164: NEG
63165: PUSH
63166: LD_INT 1
63168: PUSH
63169: EMPTY
63170: LIST
63171: LIST
63172: PUSH
63173: LD_INT 3
63175: NEG
63176: PUSH
63177: LD_INT 1
63179: NEG
63180: PUSH
63181: EMPTY
63182: LIST
63183: LIST
63184: PUSH
63185: LD_INT 3
63187: NEG
63188: PUSH
63189: LD_INT 2
63191: NEG
63192: PUSH
63193: EMPTY
63194: LIST
63195: LIST
63196: PUSH
63197: EMPTY
63198: LIST
63199: LIST
63200: LIST
63201: LIST
63202: LIST
63203: LIST
63204: LIST
63205: LIST
63206: LIST
63207: LIST
63208: LIST
63209: LIST
63210: LIST
63211: LIST
63212: LIST
63213: LIST
63214: LIST
63215: LIST
63216: LIST
63217: LIST
63218: LIST
63219: LIST
63220: LIST
63221: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
63222: LD_ADDR_VAR 0 28
63226: PUSH
63227: LD_INT 0
63229: PUSH
63230: LD_INT 0
63232: PUSH
63233: EMPTY
63234: LIST
63235: LIST
63236: PUSH
63237: LD_INT 0
63239: PUSH
63240: LD_INT 1
63242: NEG
63243: PUSH
63244: EMPTY
63245: LIST
63246: LIST
63247: PUSH
63248: LD_INT 1
63250: PUSH
63251: LD_INT 0
63253: PUSH
63254: EMPTY
63255: LIST
63256: LIST
63257: PUSH
63258: LD_INT 1
63260: PUSH
63261: LD_INT 1
63263: PUSH
63264: EMPTY
63265: LIST
63266: LIST
63267: PUSH
63268: LD_INT 0
63270: PUSH
63271: LD_INT 1
63273: PUSH
63274: EMPTY
63275: LIST
63276: LIST
63277: PUSH
63278: LD_INT 1
63280: NEG
63281: PUSH
63282: LD_INT 0
63284: PUSH
63285: EMPTY
63286: LIST
63287: LIST
63288: PUSH
63289: LD_INT 1
63291: NEG
63292: PUSH
63293: LD_INT 1
63295: NEG
63296: PUSH
63297: EMPTY
63298: LIST
63299: LIST
63300: PUSH
63301: LD_INT 1
63303: NEG
63304: PUSH
63305: LD_INT 2
63307: NEG
63308: PUSH
63309: EMPTY
63310: LIST
63311: LIST
63312: PUSH
63313: LD_INT 0
63315: PUSH
63316: LD_INT 2
63318: NEG
63319: PUSH
63320: EMPTY
63321: LIST
63322: LIST
63323: PUSH
63324: LD_INT 1
63326: PUSH
63327: LD_INT 1
63329: NEG
63330: PUSH
63331: EMPTY
63332: LIST
63333: LIST
63334: PUSH
63335: LD_INT 2
63337: PUSH
63338: LD_INT 0
63340: PUSH
63341: EMPTY
63342: LIST
63343: LIST
63344: PUSH
63345: LD_INT 2
63347: PUSH
63348: LD_INT 1
63350: PUSH
63351: EMPTY
63352: LIST
63353: LIST
63354: PUSH
63355: LD_INT 2
63357: PUSH
63358: LD_INT 2
63360: PUSH
63361: EMPTY
63362: LIST
63363: LIST
63364: PUSH
63365: LD_INT 1
63367: PUSH
63368: LD_INT 2
63370: PUSH
63371: EMPTY
63372: LIST
63373: LIST
63374: PUSH
63375: LD_INT 0
63377: PUSH
63378: LD_INT 2
63380: PUSH
63381: EMPTY
63382: LIST
63383: LIST
63384: PUSH
63385: LD_INT 1
63387: NEG
63388: PUSH
63389: LD_INT 1
63391: PUSH
63392: EMPTY
63393: LIST
63394: LIST
63395: PUSH
63396: LD_INT 2
63398: NEG
63399: PUSH
63400: LD_INT 0
63402: PUSH
63403: EMPTY
63404: LIST
63405: LIST
63406: PUSH
63407: LD_INT 2
63409: NEG
63410: PUSH
63411: LD_INT 1
63413: NEG
63414: PUSH
63415: EMPTY
63416: LIST
63417: LIST
63418: PUSH
63419: LD_INT 2
63421: NEG
63422: PUSH
63423: LD_INT 2
63425: NEG
63426: PUSH
63427: EMPTY
63428: LIST
63429: LIST
63430: PUSH
63431: LD_INT 2
63433: NEG
63434: PUSH
63435: LD_INT 3
63437: NEG
63438: PUSH
63439: EMPTY
63440: LIST
63441: LIST
63442: PUSH
63443: LD_INT 1
63445: NEG
63446: PUSH
63447: LD_INT 3
63449: NEG
63450: PUSH
63451: EMPTY
63452: LIST
63453: LIST
63454: PUSH
63455: LD_INT 3
63457: NEG
63458: PUSH
63459: LD_INT 1
63461: NEG
63462: PUSH
63463: EMPTY
63464: LIST
63465: LIST
63466: PUSH
63467: LD_INT 3
63469: NEG
63470: PUSH
63471: LD_INT 2
63473: NEG
63474: PUSH
63475: EMPTY
63476: LIST
63477: LIST
63478: PUSH
63479: EMPTY
63480: LIST
63481: LIST
63482: LIST
63483: LIST
63484: LIST
63485: LIST
63486: LIST
63487: LIST
63488: LIST
63489: LIST
63490: LIST
63491: LIST
63492: LIST
63493: LIST
63494: LIST
63495: LIST
63496: LIST
63497: LIST
63498: LIST
63499: LIST
63500: LIST
63501: LIST
63502: LIST
63503: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
63504: LD_ADDR_VAR 0 29
63508: PUSH
63509: LD_INT 0
63511: PUSH
63512: LD_INT 0
63514: PUSH
63515: EMPTY
63516: LIST
63517: LIST
63518: PUSH
63519: LD_INT 0
63521: PUSH
63522: LD_INT 1
63524: NEG
63525: PUSH
63526: EMPTY
63527: LIST
63528: LIST
63529: PUSH
63530: LD_INT 1
63532: PUSH
63533: LD_INT 0
63535: PUSH
63536: EMPTY
63537: LIST
63538: LIST
63539: PUSH
63540: LD_INT 1
63542: PUSH
63543: LD_INT 1
63545: PUSH
63546: EMPTY
63547: LIST
63548: LIST
63549: PUSH
63550: LD_INT 0
63552: PUSH
63553: LD_INT 1
63555: PUSH
63556: EMPTY
63557: LIST
63558: LIST
63559: PUSH
63560: LD_INT 1
63562: NEG
63563: PUSH
63564: LD_INT 0
63566: PUSH
63567: EMPTY
63568: LIST
63569: LIST
63570: PUSH
63571: LD_INT 1
63573: NEG
63574: PUSH
63575: LD_INT 1
63577: NEG
63578: PUSH
63579: EMPTY
63580: LIST
63581: LIST
63582: PUSH
63583: LD_INT 1
63585: NEG
63586: PUSH
63587: LD_INT 2
63589: NEG
63590: PUSH
63591: EMPTY
63592: LIST
63593: LIST
63594: PUSH
63595: LD_INT 0
63597: PUSH
63598: LD_INT 2
63600: NEG
63601: PUSH
63602: EMPTY
63603: LIST
63604: LIST
63605: PUSH
63606: LD_INT 1
63608: PUSH
63609: LD_INT 1
63611: NEG
63612: PUSH
63613: EMPTY
63614: LIST
63615: LIST
63616: PUSH
63617: LD_INT 2
63619: PUSH
63620: LD_INT 0
63622: PUSH
63623: EMPTY
63624: LIST
63625: LIST
63626: PUSH
63627: LD_INT 2
63629: PUSH
63630: LD_INT 1
63632: PUSH
63633: EMPTY
63634: LIST
63635: LIST
63636: PUSH
63637: LD_INT 1
63639: PUSH
63640: LD_INT 2
63642: PUSH
63643: EMPTY
63644: LIST
63645: LIST
63646: PUSH
63647: LD_INT 0
63649: PUSH
63650: LD_INT 2
63652: PUSH
63653: EMPTY
63654: LIST
63655: LIST
63656: PUSH
63657: LD_INT 1
63659: NEG
63660: PUSH
63661: LD_INT 1
63663: PUSH
63664: EMPTY
63665: LIST
63666: LIST
63667: PUSH
63668: LD_INT 2
63670: NEG
63671: PUSH
63672: LD_INT 1
63674: NEG
63675: PUSH
63676: EMPTY
63677: LIST
63678: LIST
63679: PUSH
63680: LD_INT 2
63682: NEG
63683: PUSH
63684: LD_INT 2
63686: NEG
63687: PUSH
63688: EMPTY
63689: LIST
63690: LIST
63691: PUSH
63692: LD_INT 2
63694: NEG
63695: PUSH
63696: LD_INT 3
63698: NEG
63699: PUSH
63700: EMPTY
63701: LIST
63702: LIST
63703: PUSH
63704: LD_INT 2
63706: PUSH
63707: LD_INT 1
63709: NEG
63710: PUSH
63711: EMPTY
63712: LIST
63713: LIST
63714: PUSH
63715: LD_INT 3
63717: PUSH
63718: LD_INT 1
63720: PUSH
63721: EMPTY
63722: LIST
63723: LIST
63724: PUSH
63725: LD_INT 1
63727: PUSH
63728: LD_INT 3
63730: PUSH
63731: EMPTY
63732: LIST
63733: LIST
63734: PUSH
63735: LD_INT 1
63737: NEG
63738: PUSH
63739: LD_INT 2
63741: PUSH
63742: EMPTY
63743: LIST
63744: LIST
63745: PUSH
63746: LD_INT 3
63748: NEG
63749: PUSH
63750: LD_INT 2
63752: NEG
63753: PUSH
63754: EMPTY
63755: LIST
63756: LIST
63757: PUSH
63758: EMPTY
63759: LIST
63760: LIST
63761: LIST
63762: LIST
63763: LIST
63764: LIST
63765: LIST
63766: LIST
63767: LIST
63768: LIST
63769: LIST
63770: LIST
63771: LIST
63772: LIST
63773: LIST
63774: LIST
63775: LIST
63776: LIST
63777: LIST
63778: LIST
63779: LIST
63780: LIST
63781: LIST
63782: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
63783: LD_ADDR_VAR 0 30
63787: PUSH
63788: LD_INT 0
63790: PUSH
63791: LD_INT 0
63793: PUSH
63794: EMPTY
63795: LIST
63796: LIST
63797: PUSH
63798: LD_INT 0
63800: PUSH
63801: LD_INT 1
63803: NEG
63804: PUSH
63805: EMPTY
63806: LIST
63807: LIST
63808: PUSH
63809: LD_INT 1
63811: PUSH
63812: LD_INT 0
63814: PUSH
63815: EMPTY
63816: LIST
63817: LIST
63818: PUSH
63819: LD_INT 1
63821: PUSH
63822: LD_INT 1
63824: PUSH
63825: EMPTY
63826: LIST
63827: LIST
63828: PUSH
63829: LD_INT 0
63831: PUSH
63832: LD_INT 1
63834: PUSH
63835: EMPTY
63836: LIST
63837: LIST
63838: PUSH
63839: LD_INT 1
63841: NEG
63842: PUSH
63843: LD_INT 0
63845: PUSH
63846: EMPTY
63847: LIST
63848: LIST
63849: PUSH
63850: LD_INT 1
63852: NEG
63853: PUSH
63854: LD_INT 1
63856: NEG
63857: PUSH
63858: EMPTY
63859: LIST
63860: LIST
63861: PUSH
63862: LD_INT 1
63864: NEG
63865: PUSH
63866: LD_INT 2
63868: NEG
63869: PUSH
63870: EMPTY
63871: LIST
63872: LIST
63873: PUSH
63874: LD_INT 0
63876: PUSH
63877: LD_INT 2
63879: NEG
63880: PUSH
63881: EMPTY
63882: LIST
63883: LIST
63884: PUSH
63885: LD_INT 1
63887: PUSH
63888: LD_INT 1
63890: NEG
63891: PUSH
63892: EMPTY
63893: LIST
63894: LIST
63895: PUSH
63896: LD_INT 2
63898: PUSH
63899: LD_INT 0
63901: PUSH
63902: EMPTY
63903: LIST
63904: LIST
63905: PUSH
63906: LD_INT 2
63908: PUSH
63909: LD_INT 1
63911: PUSH
63912: EMPTY
63913: LIST
63914: LIST
63915: PUSH
63916: LD_INT 2
63918: PUSH
63919: LD_INT 2
63921: PUSH
63922: EMPTY
63923: LIST
63924: LIST
63925: PUSH
63926: LD_INT 1
63928: PUSH
63929: LD_INT 2
63931: PUSH
63932: EMPTY
63933: LIST
63934: LIST
63935: PUSH
63936: LD_INT 1
63938: NEG
63939: PUSH
63940: LD_INT 1
63942: PUSH
63943: EMPTY
63944: LIST
63945: LIST
63946: PUSH
63947: LD_INT 2
63949: NEG
63950: PUSH
63951: LD_INT 0
63953: PUSH
63954: EMPTY
63955: LIST
63956: LIST
63957: PUSH
63958: LD_INT 2
63960: NEG
63961: PUSH
63962: LD_INT 1
63964: NEG
63965: PUSH
63966: EMPTY
63967: LIST
63968: LIST
63969: PUSH
63970: LD_INT 1
63972: NEG
63973: PUSH
63974: LD_INT 3
63976: NEG
63977: PUSH
63978: EMPTY
63979: LIST
63980: LIST
63981: PUSH
63982: LD_INT 1
63984: PUSH
63985: LD_INT 2
63987: NEG
63988: PUSH
63989: EMPTY
63990: LIST
63991: LIST
63992: PUSH
63993: LD_INT 3
63995: PUSH
63996: LD_INT 2
63998: PUSH
63999: EMPTY
64000: LIST
64001: LIST
64002: PUSH
64003: LD_INT 2
64005: PUSH
64006: LD_INT 3
64008: PUSH
64009: EMPTY
64010: LIST
64011: LIST
64012: PUSH
64013: LD_INT 2
64015: NEG
64016: PUSH
64017: LD_INT 1
64019: PUSH
64020: EMPTY
64021: LIST
64022: LIST
64023: PUSH
64024: LD_INT 3
64026: NEG
64027: PUSH
64028: LD_INT 1
64030: NEG
64031: PUSH
64032: EMPTY
64033: LIST
64034: LIST
64035: PUSH
64036: EMPTY
64037: LIST
64038: LIST
64039: LIST
64040: LIST
64041: LIST
64042: LIST
64043: LIST
64044: LIST
64045: LIST
64046: LIST
64047: LIST
64048: LIST
64049: LIST
64050: LIST
64051: LIST
64052: LIST
64053: LIST
64054: LIST
64055: LIST
64056: LIST
64057: LIST
64058: LIST
64059: LIST
64060: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
64061: LD_ADDR_VAR 0 31
64065: PUSH
64066: LD_INT 0
64068: PUSH
64069: LD_INT 0
64071: PUSH
64072: EMPTY
64073: LIST
64074: LIST
64075: PUSH
64076: LD_INT 0
64078: PUSH
64079: LD_INT 1
64081: NEG
64082: PUSH
64083: EMPTY
64084: LIST
64085: LIST
64086: PUSH
64087: LD_INT 1
64089: PUSH
64090: LD_INT 0
64092: PUSH
64093: EMPTY
64094: LIST
64095: LIST
64096: PUSH
64097: LD_INT 1
64099: PUSH
64100: LD_INT 1
64102: PUSH
64103: EMPTY
64104: LIST
64105: LIST
64106: PUSH
64107: LD_INT 0
64109: PUSH
64110: LD_INT 1
64112: PUSH
64113: EMPTY
64114: LIST
64115: LIST
64116: PUSH
64117: LD_INT 1
64119: NEG
64120: PUSH
64121: LD_INT 0
64123: PUSH
64124: EMPTY
64125: LIST
64126: LIST
64127: PUSH
64128: LD_INT 1
64130: NEG
64131: PUSH
64132: LD_INT 1
64134: NEG
64135: PUSH
64136: EMPTY
64137: LIST
64138: LIST
64139: PUSH
64140: LD_INT 1
64142: NEG
64143: PUSH
64144: LD_INT 2
64146: NEG
64147: PUSH
64148: EMPTY
64149: LIST
64150: LIST
64151: PUSH
64152: LD_INT 1
64154: PUSH
64155: LD_INT 1
64157: NEG
64158: PUSH
64159: EMPTY
64160: LIST
64161: LIST
64162: PUSH
64163: LD_INT 2
64165: PUSH
64166: LD_INT 0
64168: PUSH
64169: EMPTY
64170: LIST
64171: LIST
64172: PUSH
64173: LD_INT 2
64175: PUSH
64176: LD_INT 1
64178: PUSH
64179: EMPTY
64180: LIST
64181: LIST
64182: PUSH
64183: LD_INT 2
64185: PUSH
64186: LD_INT 2
64188: PUSH
64189: EMPTY
64190: LIST
64191: LIST
64192: PUSH
64193: LD_INT 1
64195: PUSH
64196: LD_INT 2
64198: PUSH
64199: EMPTY
64200: LIST
64201: LIST
64202: PUSH
64203: LD_INT 0
64205: PUSH
64206: LD_INT 2
64208: PUSH
64209: EMPTY
64210: LIST
64211: LIST
64212: PUSH
64213: LD_INT 1
64215: NEG
64216: PUSH
64217: LD_INT 1
64219: PUSH
64220: EMPTY
64221: LIST
64222: LIST
64223: PUSH
64224: LD_INT 2
64226: NEG
64227: PUSH
64228: LD_INT 1
64230: NEG
64231: PUSH
64232: EMPTY
64233: LIST
64234: LIST
64235: PUSH
64236: LD_INT 2
64238: NEG
64239: PUSH
64240: LD_INT 2
64242: NEG
64243: PUSH
64244: EMPTY
64245: LIST
64246: LIST
64247: PUSH
64248: LD_INT 2
64250: NEG
64251: PUSH
64252: LD_INT 3
64254: NEG
64255: PUSH
64256: EMPTY
64257: LIST
64258: LIST
64259: PUSH
64260: LD_INT 2
64262: PUSH
64263: LD_INT 1
64265: NEG
64266: PUSH
64267: EMPTY
64268: LIST
64269: LIST
64270: PUSH
64271: LD_INT 3
64273: PUSH
64274: LD_INT 1
64276: PUSH
64277: EMPTY
64278: LIST
64279: LIST
64280: PUSH
64281: LD_INT 1
64283: PUSH
64284: LD_INT 3
64286: PUSH
64287: EMPTY
64288: LIST
64289: LIST
64290: PUSH
64291: LD_INT 1
64293: NEG
64294: PUSH
64295: LD_INT 2
64297: PUSH
64298: EMPTY
64299: LIST
64300: LIST
64301: PUSH
64302: LD_INT 3
64304: NEG
64305: PUSH
64306: LD_INT 2
64308: NEG
64309: PUSH
64310: EMPTY
64311: LIST
64312: LIST
64313: PUSH
64314: EMPTY
64315: LIST
64316: LIST
64317: LIST
64318: LIST
64319: LIST
64320: LIST
64321: LIST
64322: LIST
64323: LIST
64324: LIST
64325: LIST
64326: LIST
64327: LIST
64328: LIST
64329: LIST
64330: LIST
64331: LIST
64332: LIST
64333: LIST
64334: LIST
64335: LIST
64336: LIST
64337: LIST
64338: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
64339: LD_ADDR_VAR 0 32
64343: PUSH
64344: LD_INT 0
64346: PUSH
64347: LD_INT 0
64349: PUSH
64350: EMPTY
64351: LIST
64352: LIST
64353: PUSH
64354: LD_INT 0
64356: PUSH
64357: LD_INT 1
64359: NEG
64360: PUSH
64361: EMPTY
64362: LIST
64363: LIST
64364: PUSH
64365: LD_INT 1
64367: PUSH
64368: LD_INT 0
64370: PUSH
64371: EMPTY
64372: LIST
64373: LIST
64374: PUSH
64375: LD_INT 1
64377: PUSH
64378: LD_INT 1
64380: PUSH
64381: EMPTY
64382: LIST
64383: LIST
64384: PUSH
64385: LD_INT 0
64387: PUSH
64388: LD_INT 1
64390: PUSH
64391: EMPTY
64392: LIST
64393: LIST
64394: PUSH
64395: LD_INT 1
64397: NEG
64398: PUSH
64399: LD_INT 0
64401: PUSH
64402: EMPTY
64403: LIST
64404: LIST
64405: PUSH
64406: LD_INT 1
64408: NEG
64409: PUSH
64410: LD_INT 1
64412: NEG
64413: PUSH
64414: EMPTY
64415: LIST
64416: LIST
64417: PUSH
64418: LD_INT 1
64420: NEG
64421: PUSH
64422: LD_INT 2
64424: NEG
64425: PUSH
64426: EMPTY
64427: LIST
64428: LIST
64429: PUSH
64430: LD_INT 0
64432: PUSH
64433: LD_INT 2
64435: NEG
64436: PUSH
64437: EMPTY
64438: LIST
64439: LIST
64440: PUSH
64441: LD_INT 1
64443: PUSH
64444: LD_INT 1
64446: NEG
64447: PUSH
64448: EMPTY
64449: LIST
64450: LIST
64451: PUSH
64452: LD_INT 2
64454: PUSH
64455: LD_INT 1
64457: PUSH
64458: EMPTY
64459: LIST
64460: LIST
64461: PUSH
64462: LD_INT 2
64464: PUSH
64465: LD_INT 2
64467: PUSH
64468: EMPTY
64469: LIST
64470: LIST
64471: PUSH
64472: LD_INT 1
64474: PUSH
64475: LD_INT 2
64477: PUSH
64478: EMPTY
64479: LIST
64480: LIST
64481: PUSH
64482: LD_INT 0
64484: PUSH
64485: LD_INT 2
64487: PUSH
64488: EMPTY
64489: LIST
64490: LIST
64491: PUSH
64492: LD_INT 1
64494: NEG
64495: PUSH
64496: LD_INT 1
64498: PUSH
64499: EMPTY
64500: LIST
64501: LIST
64502: PUSH
64503: LD_INT 2
64505: NEG
64506: PUSH
64507: LD_INT 0
64509: PUSH
64510: EMPTY
64511: LIST
64512: LIST
64513: PUSH
64514: LD_INT 2
64516: NEG
64517: PUSH
64518: LD_INT 1
64520: NEG
64521: PUSH
64522: EMPTY
64523: LIST
64524: LIST
64525: PUSH
64526: LD_INT 1
64528: NEG
64529: PUSH
64530: LD_INT 3
64532: NEG
64533: PUSH
64534: EMPTY
64535: LIST
64536: LIST
64537: PUSH
64538: LD_INT 1
64540: PUSH
64541: LD_INT 2
64543: NEG
64544: PUSH
64545: EMPTY
64546: LIST
64547: LIST
64548: PUSH
64549: LD_INT 3
64551: PUSH
64552: LD_INT 2
64554: PUSH
64555: EMPTY
64556: LIST
64557: LIST
64558: PUSH
64559: LD_INT 2
64561: PUSH
64562: LD_INT 3
64564: PUSH
64565: EMPTY
64566: LIST
64567: LIST
64568: PUSH
64569: LD_INT 2
64571: NEG
64572: PUSH
64573: LD_INT 1
64575: PUSH
64576: EMPTY
64577: LIST
64578: LIST
64579: PUSH
64580: LD_INT 3
64582: NEG
64583: PUSH
64584: LD_INT 1
64586: NEG
64587: PUSH
64588: EMPTY
64589: LIST
64590: LIST
64591: PUSH
64592: EMPTY
64593: LIST
64594: LIST
64595: LIST
64596: LIST
64597: LIST
64598: LIST
64599: LIST
64600: LIST
64601: LIST
64602: LIST
64603: LIST
64604: LIST
64605: LIST
64606: LIST
64607: LIST
64608: LIST
64609: LIST
64610: LIST
64611: LIST
64612: LIST
64613: LIST
64614: LIST
64615: LIST
64616: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
64617: LD_ADDR_VAR 0 33
64621: PUSH
64622: LD_INT 0
64624: PUSH
64625: LD_INT 0
64627: PUSH
64628: EMPTY
64629: LIST
64630: LIST
64631: PUSH
64632: LD_INT 0
64634: PUSH
64635: LD_INT 1
64637: NEG
64638: PUSH
64639: EMPTY
64640: LIST
64641: LIST
64642: PUSH
64643: LD_INT 1
64645: PUSH
64646: LD_INT 0
64648: PUSH
64649: EMPTY
64650: LIST
64651: LIST
64652: PUSH
64653: LD_INT 1
64655: PUSH
64656: LD_INT 1
64658: PUSH
64659: EMPTY
64660: LIST
64661: LIST
64662: PUSH
64663: LD_INT 0
64665: PUSH
64666: LD_INT 1
64668: PUSH
64669: EMPTY
64670: LIST
64671: LIST
64672: PUSH
64673: LD_INT 1
64675: NEG
64676: PUSH
64677: LD_INT 0
64679: PUSH
64680: EMPTY
64681: LIST
64682: LIST
64683: PUSH
64684: LD_INT 1
64686: NEG
64687: PUSH
64688: LD_INT 1
64690: NEG
64691: PUSH
64692: EMPTY
64693: LIST
64694: LIST
64695: PUSH
64696: LD_INT 1
64698: NEG
64699: PUSH
64700: LD_INT 2
64702: NEG
64703: PUSH
64704: EMPTY
64705: LIST
64706: LIST
64707: PUSH
64708: LD_INT 1
64710: PUSH
64711: LD_INT 1
64713: NEG
64714: PUSH
64715: EMPTY
64716: LIST
64717: LIST
64718: PUSH
64719: LD_INT 2
64721: PUSH
64722: LD_INT 0
64724: PUSH
64725: EMPTY
64726: LIST
64727: LIST
64728: PUSH
64729: LD_INT 2
64731: PUSH
64732: LD_INT 1
64734: PUSH
64735: EMPTY
64736: LIST
64737: LIST
64738: PUSH
64739: LD_INT 1
64741: PUSH
64742: LD_INT 2
64744: PUSH
64745: EMPTY
64746: LIST
64747: LIST
64748: PUSH
64749: LD_INT 0
64751: PUSH
64752: LD_INT 2
64754: PUSH
64755: EMPTY
64756: LIST
64757: LIST
64758: PUSH
64759: LD_INT 1
64761: NEG
64762: PUSH
64763: LD_INT 1
64765: PUSH
64766: EMPTY
64767: LIST
64768: LIST
64769: PUSH
64770: LD_INT 2
64772: NEG
64773: PUSH
64774: LD_INT 0
64776: PUSH
64777: EMPTY
64778: LIST
64779: LIST
64780: PUSH
64781: LD_INT 2
64783: NEG
64784: PUSH
64785: LD_INT 1
64787: NEG
64788: PUSH
64789: EMPTY
64790: LIST
64791: LIST
64792: PUSH
64793: LD_INT 2
64795: NEG
64796: PUSH
64797: LD_INT 2
64799: NEG
64800: PUSH
64801: EMPTY
64802: LIST
64803: LIST
64804: PUSH
64805: LD_INT 2
64807: NEG
64808: PUSH
64809: LD_INT 3
64811: NEG
64812: PUSH
64813: EMPTY
64814: LIST
64815: LIST
64816: PUSH
64817: LD_INT 2
64819: PUSH
64820: LD_INT 1
64822: NEG
64823: PUSH
64824: EMPTY
64825: LIST
64826: LIST
64827: PUSH
64828: LD_INT 3
64830: PUSH
64831: LD_INT 1
64833: PUSH
64834: EMPTY
64835: LIST
64836: LIST
64837: PUSH
64838: LD_INT 1
64840: PUSH
64841: LD_INT 3
64843: PUSH
64844: EMPTY
64845: LIST
64846: LIST
64847: PUSH
64848: LD_INT 1
64850: NEG
64851: PUSH
64852: LD_INT 2
64854: PUSH
64855: EMPTY
64856: LIST
64857: LIST
64858: PUSH
64859: LD_INT 3
64861: NEG
64862: PUSH
64863: LD_INT 2
64865: NEG
64866: PUSH
64867: EMPTY
64868: LIST
64869: LIST
64870: PUSH
64871: EMPTY
64872: LIST
64873: LIST
64874: LIST
64875: LIST
64876: LIST
64877: LIST
64878: LIST
64879: LIST
64880: LIST
64881: LIST
64882: LIST
64883: LIST
64884: LIST
64885: LIST
64886: LIST
64887: LIST
64888: LIST
64889: LIST
64890: LIST
64891: LIST
64892: LIST
64893: LIST
64894: LIST
64895: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
64896: LD_ADDR_VAR 0 34
64900: PUSH
64901: LD_INT 0
64903: PUSH
64904: LD_INT 0
64906: PUSH
64907: EMPTY
64908: LIST
64909: LIST
64910: PUSH
64911: LD_INT 0
64913: PUSH
64914: LD_INT 1
64916: NEG
64917: PUSH
64918: EMPTY
64919: LIST
64920: LIST
64921: PUSH
64922: LD_INT 1
64924: PUSH
64925: LD_INT 0
64927: PUSH
64928: EMPTY
64929: LIST
64930: LIST
64931: PUSH
64932: LD_INT 1
64934: PUSH
64935: LD_INT 1
64937: PUSH
64938: EMPTY
64939: LIST
64940: LIST
64941: PUSH
64942: LD_INT 0
64944: PUSH
64945: LD_INT 1
64947: PUSH
64948: EMPTY
64949: LIST
64950: LIST
64951: PUSH
64952: LD_INT 1
64954: NEG
64955: PUSH
64956: LD_INT 0
64958: PUSH
64959: EMPTY
64960: LIST
64961: LIST
64962: PUSH
64963: LD_INT 1
64965: NEG
64966: PUSH
64967: LD_INT 1
64969: NEG
64970: PUSH
64971: EMPTY
64972: LIST
64973: LIST
64974: PUSH
64975: LD_INT 1
64977: NEG
64978: PUSH
64979: LD_INT 2
64981: NEG
64982: PUSH
64983: EMPTY
64984: LIST
64985: LIST
64986: PUSH
64987: LD_INT 0
64989: PUSH
64990: LD_INT 2
64992: NEG
64993: PUSH
64994: EMPTY
64995: LIST
64996: LIST
64997: PUSH
64998: LD_INT 1
65000: PUSH
65001: LD_INT 1
65003: NEG
65004: PUSH
65005: EMPTY
65006: LIST
65007: LIST
65008: PUSH
65009: LD_INT 2
65011: PUSH
65012: LD_INT 1
65014: PUSH
65015: EMPTY
65016: LIST
65017: LIST
65018: PUSH
65019: LD_INT 2
65021: PUSH
65022: LD_INT 2
65024: PUSH
65025: EMPTY
65026: LIST
65027: LIST
65028: PUSH
65029: LD_INT 1
65031: PUSH
65032: LD_INT 2
65034: PUSH
65035: EMPTY
65036: LIST
65037: LIST
65038: PUSH
65039: LD_INT 1
65041: NEG
65042: PUSH
65043: LD_INT 1
65045: PUSH
65046: EMPTY
65047: LIST
65048: LIST
65049: PUSH
65050: LD_INT 2
65052: NEG
65053: PUSH
65054: LD_INT 0
65056: PUSH
65057: EMPTY
65058: LIST
65059: LIST
65060: PUSH
65061: LD_INT 2
65063: NEG
65064: PUSH
65065: LD_INT 1
65067: NEG
65068: PUSH
65069: EMPTY
65070: LIST
65071: LIST
65072: PUSH
65073: LD_INT 2
65075: NEG
65076: PUSH
65077: LD_INT 2
65079: NEG
65080: PUSH
65081: EMPTY
65082: LIST
65083: LIST
65084: PUSH
65085: LD_INT 1
65087: NEG
65088: PUSH
65089: LD_INT 3
65091: NEG
65092: PUSH
65093: EMPTY
65094: LIST
65095: LIST
65096: PUSH
65097: LD_INT 1
65099: PUSH
65100: LD_INT 2
65102: NEG
65103: PUSH
65104: EMPTY
65105: LIST
65106: LIST
65107: PUSH
65108: LD_INT 3
65110: PUSH
65111: LD_INT 2
65113: PUSH
65114: EMPTY
65115: LIST
65116: LIST
65117: PUSH
65118: LD_INT 2
65120: PUSH
65121: LD_INT 3
65123: PUSH
65124: EMPTY
65125: LIST
65126: LIST
65127: PUSH
65128: LD_INT 2
65130: NEG
65131: PUSH
65132: LD_INT 1
65134: PUSH
65135: EMPTY
65136: LIST
65137: LIST
65138: PUSH
65139: LD_INT 3
65141: NEG
65142: PUSH
65143: LD_INT 1
65145: NEG
65146: PUSH
65147: EMPTY
65148: LIST
65149: LIST
65150: PUSH
65151: EMPTY
65152: LIST
65153: LIST
65154: LIST
65155: LIST
65156: LIST
65157: LIST
65158: LIST
65159: LIST
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: LIST
65165: LIST
65166: LIST
65167: LIST
65168: LIST
65169: LIST
65170: LIST
65171: LIST
65172: LIST
65173: LIST
65174: LIST
65175: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
65176: LD_ADDR_VAR 0 35
65180: PUSH
65181: LD_INT 0
65183: PUSH
65184: LD_INT 0
65186: PUSH
65187: EMPTY
65188: LIST
65189: LIST
65190: PUSH
65191: LD_INT 0
65193: PUSH
65194: LD_INT 1
65196: NEG
65197: PUSH
65198: EMPTY
65199: LIST
65200: LIST
65201: PUSH
65202: LD_INT 1
65204: PUSH
65205: LD_INT 0
65207: PUSH
65208: EMPTY
65209: LIST
65210: LIST
65211: PUSH
65212: LD_INT 1
65214: PUSH
65215: LD_INT 1
65217: PUSH
65218: EMPTY
65219: LIST
65220: LIST
65221: PUSH
65222: LD_INT 0
65224: PUSH
65225: LD_INT 1
65227: PUSH
65228: EMPTY
65229: LIST
65230: LIST
65231: PUSH
65232: LD_INT 1
65234: NEG
65235: PUSH
65236: LD_INT 0
65238: PUSH
65239: EMPTY
65240: LIST
65241: LIST
65242: PUSH
65243: LD_INT 1
65245: NEG
65246: PUSH
65247: LD_INT 1
65249: NEG
65250: PUSH
65251: EMPTY
65252: LIST
65253: LIST
65254: PUSH
65255: LD_INT 2
65257: PUSH
65258: LD_INT 1
65260: PUSH
65261: EMPTY
65262: LIST
65263: LIST
65264: PUSH
65265: LD_INT 2
65267: NEG
65268: PUSH
65269: LD_INT 1
65271: NEG
65272: PUSH
65273: EMPTY
65274: LIST
65275: LIST
65276: PUSH
65277: EMPTY
65278: LIST
65279: LIST
65280: LIST
65281: LIST
65282: LIST
65283: LIST
65284: LIST
65285: LIST
65286: LIST
65287: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
65288: LD_ADDR_VAR 0 36
65292: PUSH
65293: LD_INT 0
65295: PUSH
65296: LD_INT 0
65298: PUSH
65299: EMPTY
65300: LIST
65301: LIST
65302: PUSH
65303: LD_INT 0
65305: PUSH
65306: LD_INT 1
65308: NEG
65309: PUSH
65310: EMPTY
65311: LIST
65312: LIST
65313: PUSH
65314: LD_INT 1
65316: PUSH
65317: LD_INT 0
65319: PUSH
65320: EMPTY
65321: LIST
65322: LIST
65323: PUSH
65324: LD_INT 1
65326: PUSH
65327: LD_INT 1
65329: PUSH
65330: EMPTY
65331: LIST
65332: LIST
65333: PUSH
65334: LD_INT 0
65336: PUSH
65337: LD_INT 1
65339: PUSH
65340: EMPTY
65341: LIST
65342: LIST
65343: PUSH
65344: LD_INT 1
65346: NEG
65347: PUSH
65348: LD_INT 0
65350: PUSH
65351: EMPTY
65352: LIST
65353: LIST
65354: PUSH
65355: LD_INT 1
65357: NEG
65358: PUSH
65359: LD_INT 1
65361: NEG
65362: PUSH
65363: EMPTY
65364: LIST
65365: LIST
65366: PUSH
65367: LD_INT 1
65369: NEG
65370: PUSH
65371: LD_INT 2
65373: NEG
65374: PUSH
65375: EMPTY
65376: LIST
65377: LIST
65378: PUSH
65379: LD_INT 1
65381: PUSH
65382: LD_INT 2
65384: PUSH
65385: EMPTY
65386: LIST
65387: LIST
65388: PUSH
65389: EMPTY
65390: LIST
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: LIST
65399: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
65400: LD_ADDR_VAR 0 37
65404: PUSH
65405: LD_INT 0
65407: PUSH
65408: LD_INT 0
65410: PUSH
65411: EMPTY
65412: LIST
65413: LIST
65414: PUSH
65415: LD_INT 0
65417: PUSH
65418: LD_INT 1
65420: NEG
65421: PUSH
65422: EMPTY
65423: LIST
65424: LIST
65425: PUSH
65426: LD_INT 1
65428: PUSH
65429: LD_INT 0
65431: PUSH
65432: EMPTY
65433: LIST
65434: LIST
65435: PUSH
65436: LD_INT 1
65438: PUSH
65439: LD_INT 1
65441: PUSH
65442: EMPTY
65443: LIST
65444: LIST
65445: PUSH
65446: LD_INT 0
65448: PUSH
65449: LD_INT 1
65451: PUSH
65452: EMPTY
65453: LIST
65454: LIST
65455: PUSH
65456: LD_INT 1
65458: NEG
65459: PUSH
65460: LD_INT 0
65462: PUSH
65463: EMPTY
65464: LIST
65465: LIST
65466: PUSH
65467: LD_INT 1
65469: NEG
65470: PUSH
65471: LD_INT 1
65473: NEG
65474: PUSH
65475: EMPTY
65476: LIST
65477: LIST
65478: PUSH
65479: LD_INT 1
65481: PUSH
65482: LD_INT 1
65484: NEG
65485: PUSH
65486: EMPTY
65487: LIST
65488: LIST
65489: PUSH
65490: LD_INT 1
65492: NEG
65493: PUSH
65494: LD_INT 1
65496: PUSH
65497: EMPTY
65498: LIST
65499: LIST
65500: PUSH
65501: EMPTY
65502: LIST
65503: LIST
65504: LIST
65505: LIST
65506: LIST
65507: LIST
65508: LIST
65509: LIST
65510: LIST
65511: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
65512: LD_ADDR_VAR 0 38
65516: PUSH
65517: LD_INT 0
65519: PUSH
65520: LD_INT 0
65522: PUSH
65523: EMPTY
65524: LIST
65525: LIST
65526: PUSH
65527: LD_INT 0
65529: PUSH
65530: LD_INT 1
65532: NEG
65533: PUSH
65534: EMPTY
65535: LIST
65536: LIST
65537: PUSH
65538: LD_INT 1
65540: PUSH
65541: LD_INT 0
65543: PUSH
65544: EMPTY
65545: LIST
65546: LIST
65547: PUSH
65548: LD_INT 1
65550: PUSH
65551: LD_INT 1
65553: PUSH
65554: EMPTY
65555: LIST
65556: LIST
65557: PUSH
65558: LD_INT 0
65560: PUSH
65561: LD_INT 1
65563: PUSH
65564: EMPTY
65565: LIST
65566: LIST
65567: PUSH
65568: LD_INT 1
65570: NEG
65571: PUSH
65572: LD_INT 0
65574: PUSH
65575: EMPTY
65576: LIST
65577: LIST
65578: PUSH
65579: LD_INT 1
65581: NEG
65582: PUSH
65583: LD_INT 1
65585: NEG
65586: PUSH
65587: EMPTY
65588: LIST
65589: LIST
65590: PUSH
65591: LD_INT 2
65593: PUSH
65594: LD_INT 1
65596: PUSH
65597: EMPTY
65598: LIST
65599: LIST
65600: PUSH
65601: LD_INT 2
65603: NEG
65604: PUSH
65605: LD_INT 1
65607: NEG
65608: PUSH
65609: EMPTY
65610: LIST
65611: LIST
65612: PUSH
65613: EMPTY
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: LIST
65621: LIST
65622: LIST
65623: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
65624: LD_ADDR_VAR 0 39
65628: PUSH
65629: LD_INT 0
65631: PUSH
65632: LD_INT 0
65634: PUSH
65635: EMPTY
65636: LIST
65637: LIST
65638: PUSH
65639: LD_INT 0
65641: PUSH
65642: LD_INT 1
65644: NEG
65645: PUSH
65646: EMPTY
65647: LIST
65648: LIST
65649: PUSH
65650: LD_INT 1
65652: PUSH
65653: LD_INT 0
65655: PUSH
65656: EMPTY
65657: LIST
65658: LIST
65659: PUSH
65660: LD_INT 1
65662: PUSH
65663: LD_INT 1
65665: PUSH
65666: EMPTY
65667: LIST
65668: LIST
65669: PUSH
65670: LD_INT 0
65672: PUSH
65673: LD_INT 1
65675: PUSH
65676: EMPTY
65677: LIST
65678: LIST
65679: PUSH
65680: LD_INT 1
65682: NEG
65683: PUSH
65684: LD_INT 0
65686: PUSH
65687: EMPTY
65688: LIST
65689: LIST
65690: PUSH
65691: LD_INT 1
65693: NEG
65694: PUSH
65695: LD_INT 1
65697: NEG
65698: PUSH
65699: EMPTY
65700: LIST
65701: LIST
65702: PUSH
65703: LD_INT 1
65705: NEG
65706: PUSH
65707: LD_INT 2
65709: NEG
65710: PUSH
65711: EMPTY
65712: LIST
65713: LIST
65714: PUSH
65715: LD_INT 1
65717: PUSH
65718: LD_INT 2
65720: PUSH
65721: EMPTY
65722: LIST
65723: LIST
65724: PUSH
65725: EMPTY
65726: LIST
65727: LIST
65728: LIST
65729: LIST
65730: LIST
65731: LIST
65732: LIST
65733: LIST
65734: LIST
65735: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
65736: LD_ADDR_VAR 0 40
65740: PUSH
65741: LD_INT 0
65743: PUSH
65744: LD_INT 0
65746: PUSH
65747: EMPTY
65748: LIST
65749: LIST
65750: PUSH
65751: LD_INT 0
65753: PUSH
65754: LD_INT 1
65756: NEG
65757: PUSH
65758: EMPTY
65759: LIST
65760: LIST
65761: PUSH
65762: LD_INT 1
65764: PUSH
65765: LD_INT 0
65767: PUSH
65768: EMPTY
65769: LIST
65770: LIST
65771: PUSH
65772: LD_INT 1
65774: PUSH
65775: LD_INT 1
65777: PUSH
65778: EMPTY
65779: LIST
65780: LIST
65781: PUSH
65782: LD_INT 0
65784: PUSH
65785: LD_INT 1
65787: PUSH
65788: EMPTY
65789: LIST
65790: LIST
65791: PUSH
65792: LD_INT 1
65794: NEG
65795: PUSH
65796: LD_INT 0
65798: PUSH
65799: EMPTY
65800: LIST
65801: LIST
65802: PUSH
65803: LD_INT 1
65805: NEG
65806: PUSH
65807: LD_INT 1
65809: NEG
65810: PUSH
65811: EMPTY
65812: LIST
65813: LIST
65814: PUSH
65815: LD_INT 1
65817: PUSH
65818: LD_INT 1
65820: NEG
65821: PUSH
65822: EMPTY
65823: LIST
65824: LIST
65825: PUSH
65826: LD_INT 1
65828: NEG
65829: PUSH
65830: LD_INT 1
65832: PUSH
65833: EMPTY
65834: LIST
65835: LIST
65836: PUSH
65837: EMPTY
65838: LIST
65839: LIST
65840: LIST
65841: LIST
65842: LIST
65843: LIST
65844: LIST
65845: LIST
65846: LIST
65847: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
65848: LD_ADDR_VAR 0 41
65852: PUSH
65853: LD_INT 0
65855: PUSH
65856: LD_INT 0
65858: PUSH
65859: EMPTY
65860: LIST
65861: LIST
65862: PUSH
65863: LD_INT 0
65865: PUSH
65866: LD_INT 1
65868: NEG
65869: PUSH
65870: EMPTY
65871: LIST
65872: LIST
65873: PUSH
65874: LD_INT 1
65876: PUSH
65877: LD_INT 0
65879: PUSH
65880: EMPTY
65881: LIST
65882: LIST
65883: PUSH
65884: LD_INT 1
65886: PUSH
65887: LD_INT 1
65889: PUSH
65890: EMPTY
65891: LIST
65892: LIST
65893: PUSH
65894: LD_INT 0
65896: PUSH
65897: LD_INT 1
65899: PUSH
65900: EMPTY
65901: LIST
65902: LIST
65903: PUSH
65904: LD_INT 1
65906: NEG
65907: PUSH
65908: LD_INT 0
65910: PUSH
65911: EMPTY
65912: LIST
65913: LIST
65914: PUSH
65915: LD_INT 1
65917: NEG
65918: PUSH
65919: LD_INT 1
65921: NEG
65922: PUSH
65923: EMPTY
65924: LIST
65925: LIST
65926: PUSH
65927: LD_INT 1
65929: NEG
65930: PUSH
65931: LD_INT 2
65933: NEG
65934: PUSH
65935: EMPTY
65936: LIST
65937: LIST
65938: PUSH
65939: LD_INT 1
65941: PUSH
65942: LD_INT 1
65944: NEG
65945: PUSH
65946: EMPTY
65947: LIST
65948: LIST
65949: PUSH
65950: LD_INT 2
65952: PUSH
65953: LD_INT 0
65955: PUSH
65956: EMPTY
65957: LIST
65958: LIST
65959: PUSH
65960: LD_INT 2
65962: PUSH
65963: LD_INT 1
65965: PUSH
65966: EMPTY
65967: LIST
65968: LIST
65969: PUSH
65970: LD_INT 2
65972: PUSH
65973: LD_INT 2
65975: PUSH
65976: EMPTY
65977: LIST
65978: LIST
65979: PUSH
65980: LD_INT 1
65982: PUSH
65983: LD_INT 2
65985: PUSH
65986: EMPTY
65987: LIST
65988: LIST
65989: PUSH
65990: LD_INT 1
65992: NEG
65993: PUSH
65994: LD_INT 1
65996: PUSH
65997: EMPTY
65998: LIST
65999: LIST
66000: PUSH
66001: LD_INT 2
66003: NEG
66004: PUSH
66005: LD_INT 0
66007: PUSH
66008: EMPTY
66009: LIST
66010: LIST
66011: PUSH
66012: LD_INT 2
66014: NEG
66015: PUSH
66016: LD_INT 1
66018: NEG
66019: PUSH
66020: EMPTY
66021: LIST
66022: LIST
66023: PUSH
66024: LD_INT 2
66026: NEG
66027: PUSH
66028: LD_INT 2
66030: NEG
66031: PUSH
66032: EMPTY
66033: LIST
66034: LIST
66035: PUSH
66036: LD_INT 2
66038: NEG
66039: PUSH
66040: LD_INT 3
66042: NEG
66043: PUSH
66044: EMPTY
66045: LIST
66046: LIST
66047: PUSH
66048: LD_INT 2
66050: PUSH
66051: LD_INT 1
66053: NEG
66054: PUSH
66055: EMPTY
66056: LIST
66057: LIST
66058: PUSH
66059: LD_INT 3
66061: PUSH
66062: LD_INT 0
66064: PUSH
66065: EMPTY
66066: LIST
66067: LIST
66068: PUSH
66069: LD_INT 3
66071: PUSH
66072: LD_INT 1
66074: PUSH
66075: EMPTY
66076: LIST
66077: LIST
66078: PUSH
66079: LD_INT 3
66081: PUSH
66082: LD_INT 2
66084: PUSH
66085: EMPTY
66086: LIST
66087: LIST
66088: PUSH
66089: LD_INT 3
66091: PUSH
66092: LD_INT 3
66094: PUSH
66095: EMPTY
66096: LIST
66097: LIST
66098: PUSH
66099: LD_INT 2
66101: PUSH
66102: LD_INT 3
66104: PUSH
66105: EMPTY
66106: LIST
66107: LIST
66108: PUSH
66109: LD_INT 2
66111: NEG
66112: PUSH
66113: LD_INT 1
66115: PUSH
66116: EMPTY
66117: LIST
66118: LIST
66119: PUSH
66120: LD_INT 3
66122: NEG
66123: PUSH
66124: LD_INT 0
66126: PUSH
66127: EMPTY
66128: LIST
66129: LIST
66130: PUSH
66131: LD_INT 3
66133: NEG
66134: PUSH
66135: LD_INT 1
66137: NEG
66138: PUSH
66139: EMPTY
66140: LIST
66141: LIST
66142: PUSH
66143: LD_INT 3
66145: NEG
66146: PUSH
66147: LD_INT 2
66149: NEG
66150: PUSH
66151: EMPTY
66152: LIST
66153: LIST
66154: PUSH
66155: LD_INT 3
66157: NEG
66158: PUSH
66159: LD_INT 3
66161: NEG
66162: PUSH
66163: EMPTY
66164: LIST
66165: LIST
66166: PUSH
66167: EMPTY
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: LIST
66175: LIST
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: LIST
66181: LIST
66182: LIST
66183: LIST
66184: LIST
66185: LIST
66186: LIST
66187: LIST
66188: LIST
66189: LIST
66190: LIST
66191: LIST
66192: LIST
66193: LIST
66194: LIST
66195: LIST
66196: LIST
66197: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66198: LD_ADDR_VAR 0 42
66202: PUSH
66203: LD_INT 0
66205: PUSH
66206: LD_INT 0
66208: PUSH
66209: EMPTY
66210: LIST
66211: LIST
66212: PUSH
66213: LD_INT 0
66215: PUSH
66216: LD_INT 1
66218: NEG
66219: PUSH
66220: EMPTY
66221: LIST
66222: LIST
66223: PUSH
66224: LD_INT 1
66226: PUSH
66227: LD_INT 0
66229: PUSH
66230: EMPTY
66231: LIST
66232: LIST
66233: PUSH
66234: LD_INT 1
66236: PUSH
66237: LD_INT 1
66239: PUSH
66240: EMPTY
66241: LIST
66242: LIST
66243: PUSH
66244: LD_INT 0
66246: PUSH
66247: LD_INT 1
66249: PUSH
66250: EMPTY
66251: LIST
66252: LIST
66253: PUSH
66254: LD_INT 1
66256: NEG
66257: PUSH
66258: LD_INT 0
66260: PUSH
66261: EMPTY
66262: LIST
66263: LIST
66264: PUSH
66265: LD_INT 1
66267: NEG
66268: PUSH
66269: LD_INT 1
66271: NEG
66272: PUSH
66273: EMPTY
66274: LIST
66275: LIST
66276: PUSH
66277: LD_INT 1
66279: NEG
66280: PUSH
66281: LD_INT 2
66283: NEG
66284: PUSH
66285: EMPTY
66286: LIST
66287: LIST
66288: PUSH
66289: LD_INT 0
66291: PUSH
66292: LD_INT 2
66294: NEG
66295: PUSH
66296: EMPTY
66297: LIST
66298: LIST
66299: PUSH
66300: LD_INT 1
66302: PUSH
66303: LD_INT 1
66305: NEG
66306: PUSH
66307: EMPTY
66308: LIST
66309: LIST
66310: PUSH
66311: LD_INT 2
66313: PUSH
66314: LD_INT 1
66316: PUSH
66317: EMPTY
66318: LIST
66319: LIST
66320: PUSH
66321: LD_INT 2
66323: PUSH
66324: LD_INT 2
66326: PUSH
66327: EMPTY
66328: LIST
66329: LIST
66330: PUSH
66331: LD_INT 1
66333: PUSH
66334: LD_INT 2
66336: PUSH
66337: EMPTY
66338: LIST
66339: LIST
66340: PUSH
66341: LD_INT 0
66343: PUSH
66344: LD_INT 2
66346: PUSH
66347: EMPTY
66348: LIST
66349: LIST
66350: PUSH
66351: LD_INT 1
66353: NEG
66354: PUSH
66355: LD_INT 1
66357: PUSH
66358: EMPTY
66359: LIST
66360: LIST
66361: PUSH
66362: LD_INT 2
66364: NEG
66365: PUSH
66366: LD_INT 1
66368: NEG
66369: PUSH
66370: EMPTY
66371: LIST
66372: LIST
66373: PUSH
66374: LD_INT 2
66376: NEG
66377: PUSH
66378: LD_INT 2
66380: NEG
66381: PUSH
66382: EMPTY
66383: LIST
66384: LIST
66385: PUSH
66386: LD_INT 2
66388: NEG
66389: PUSH
66390: LD_INT 3
66392: NEG
66393: PUSH
66394: EMPTY
66395: LIST
66396: LIST
66397: PUSH
66398: LD_INT 1
66400: NEG
66401: PUSH
66402: LD_INT 3
66404: NEG
66405: PUSH
66406: EMPTY
66407: LIST
66408: LIST
66409: PUSH
66410: LD_INT 0
66412: PUSH
66413: LD_INT 3
66415: NEG
66416: PUSH
66417: EMPTY
66418: LIST
66419: LIST
66420: PUSH
66421: LD_INT 1
66423: PUSH
66424: LD_INT 2
66426: NEG
66427: PUSH
66428: EMPTY
66429: LIST
66430: LIST
66431: PUSH
66432: LD_INT 3
66434: PUSH
66435: LD_INT 2
66437: PUSH
66438: EMPTY
66439: LIST
66440: LIST
66441: PUSH
66442: LD_INT 3
66444: PUSH
66445: LD_INT 3
66447: PUSH
66448: EMPTY
66449: LIST
66450: LIST
66451: PUSH
66452: LD_INT 2
66454: PUSH
66455: LD_INT 3
66457: PUSH
66458: EMPTY
66459: LIST
66460: LIST
66461: PUSH
66462: LD_INT 1
66464: PUSH
66465: LD_INT 3
66467: PUSH
66468: EMPTY
66469: LIST
66470: LIST
66471: PUSH
66472: LD_INT 0
66474: PUSH
66475: LD_INT 3
66477: PUSH
66478: EMPTY
66479: LIST
66480: LIST
66481: PUSH
66482: LD_INT 1
66484: NEG
66485: PUSH
66486: LD_INT 2
66488: PUSH
66489: EMPTY
66490: LIST
66491: LIST
66492: PUSH
66493: LD_INT 3
66495: NEG
66496: PUSH
66497: LD_INT 2
66499: NEG
66500: PUSH
66501: EMPTY
66502: LIST
66503: LIST
66504: PUSH
66505: LD_INT 3
66507: NEG
66508: PUSH
66509: LD_INT 3
66511: NEG
66512: PUSH
66513: EMPTY
66514: LIST
66515: LIST
66516: PUSH
66517: EMPTY
66518: LIST
66519: LIST
66520: LIST
66521: LIST
66522: LIST
66523: LIST
66524: LIST
66525: LIST
66526: LIST
66527: LIST
66528: LIST
66529: LIST
66530: LIST
66531: LIST
66532: LIST
66533: LIST
66534: LIST
66535: LIST
66536: LIST
66537: LIST
66538: LIST
66539: LIST
66540: LIST
66541: LIST
66542: LIST
66543: LIST
66544: LIST
66545: LIST
66546: LIST
66547: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66548: LD_ADDR_VAR 0 43
66552: PUSH
66553: LD_INT 0
66555: PUSH
66556: LD_INT 0
66558: PUSH
66559: EMPTY
66560: LIST
66561: LIST
66562: PUSH
66563: LD_INT 0
66565: PUSH
66566: LD_INT 1
66568: NEG
66569: PUSH
66570: EMPTY
66571: LIST
66572: LIST
66573: PUSH
66574: LD_INT 1
66576: PUSH
66577: LD_INT 0
66579: PUSH
66580: EMPTY
66581: LIST
66582: LIST
66583: PUSH
66584: LD_INT 1
66586: PUSH
66587: LD_INT 1
66589: PUSH
66590: EMPTY
66591: LIST
66592: LIST
66593: PUSH
66594: LD_INT 0
66596: PUSH
66597: LD_INT 1
66599: PUSH
66600: EMPTY
66601: LIST
66602: LIST
66603: PUSH
66604: LD_INT 1
66606: NEG
66607: PUSH
66608: LD_INT 0
66610: PUSH
66611: EMPTY
66612: LIST
66613: LIST
66614: PUSH
66615: LD_INT 1
66617: NEG
66618: PUSH
66619: LD_INT 1
66621: NEG
66622: PUSH
66623: EMPTY
66624: LIST
66625: LIST
66626: PUSH
66627: LD_INT 1
66629: NEG
66630: PUSH
66631: LD_INT 2
66633: NEG
66634: PUSH
66635: EMPTY
66636: LIST
66637: LIST
66638: PUSH
66639: LD_INT 0
66641: PUSH
66642: LD_INT 2
66644: NEG
66645: PUSH
66646: EMPTY
66647: LIST
66648: LIST
66649: PUSH
66650: LD_INT 1
66652: PUSH
66653: LD_INT 1
66655: NEG
66656: PUSH
66657: EMPTY
66658: LIST
66659: LIST
66660: PUSH
66661: LD_INT 2
66663: PUSH
66664: LD_INT 0
66666: PUSH
66667: EMPTY
66668: LIST
66669: LIST
66670: PUSH
66671: LD_INT 2
66673: PUSH
66674: LD_INT 1
66676: PUSH
66677: EMPTY
66678: LIST
66679: LIST
66680: PUSH
66681: LD_INT 1
66683: PUSH
66684: LD_INT 2
66686: PUSH
66687: EMPTY
66688: LIST
66689: LIST
66690: PUSH
66691: LD_INT 0
66693: PUSH
66694: LD_INT 2
66696: PUSH
66697: EMPTY
66698: LIST
66699: LIST
66700: PUSH
66701: LD_INT 1
66703: NEG
66704: PUSH
66705: LD_INT 1
66707: PUSH
66708: EMPTY
66709: LIST
66710: LIST
66711: PUSH
66712: LD_INT 2
66714: NEG
66715: PUSH
66716: LD_INT 0
66718: PUSH
66719: EMPTY
66720: LIST
66721: LIST
66722: PUSH
66723: LD_INT 2
66725: NEG
66726: PUSH
66727: LD_INT 1
66729: NEG
66730: PUSH
66731: EMPTY
66732: LIST
66733: LIST
66734: PUSH
66735: LD_INT 1
66737: NEG
66738: PUSH
66739: LD_INT 3
66741: NEG
66742: PUSH
66743: EMPTY
66744: LIST
66745: LIST
66746: PUSH
66747: LD_INT 0
66749: PUSH
66750: LD_INT 3
66752: NEG
66753: PUSH
66754: EMPTY
66755: LIST
66756: LIST
66757: PUSH
66758: LD_INT 1
66760: PUSH
66761: LD_INT 2
66763: NEG
66764: PUSH
66765: EMPTY
66766: LIST
66767: LIST
66768: PUSH
66769: LD_INT 2
66771: PUSH
66772: LD_INT 1
66774: NEG
66775: PUSH
66776: EMPTY
66777: LIST
66778: LIST
66779: PUSH
66780: LD_INT 3
66782: PUSH
66783: LD_INT 0
66785: PUSH
66786: EMPTY
66787: LIST
66788: LIST
66789: PUSH
66790: LD_INT 3
66792: PUSH
66793: LD_INT 1
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: PUSH
66800: LD_INT 1
66802: PUSH
66803: LD_INT 3
66805: PUSH
66806: EMPTY
66807: LIST
66808: LIST
66809: PUSH
66810: LD_INT 0
66812: PUSH
66813: LD_INT 3
66815: PUSH
66816: EMPTY
66817: LIST
66818: LIST
66819: PUSH
66820: LD_INT 1
66822: NEG
66823: PUSH
66824: LD_INT 2
66826: PUSH
66827: EMPTY
66828: LIST
66829: LIST
66830: PUSH
66831: LD_INT 2
66833: NEG
66834: PUSH
66835: LD_INT 1
66837: PUSH
66838: EMPTY
66839: LIST
66840: LIST
66841: PUSH
66842: LD_INT 3
66844: NEG
66845: PUSH
66846: LD_INT 0
66848: PUSH
66849: EMPTY
66850: LIST
66851: LIST
66852: PUSH
66853: LD_INT 3
66855: NEG
66856: PUSH
66857: LD_INT 1
66859: NEG
66860: PUSH
66861: EMPTY
66862: LIST
66863: LIST
66864: PUSH
66865: EMPTY
66866: LIST
66867: LIST
66868: LIST
66869: LIST
66870: LIST
66871: LIST
66872: LIST
66873: LIST
66874: LIST
66875: LIST
66876: LIST
66877: LIST
66878: LIST
66879: LIST
66880: LIST
66881: LIST
66882: LIST
66883: LIST
66884: LIST
66885: LIST
66886: LIST
66887: LIST
66888: LIST
66889: LIST
66890: LIST
66891: LIST
66892: LIST
66893: LIST
66894: LIST
66895: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66896: LD_ADDR_VAR 0 44
66900: PUSH
66901: LD_INT 0
66903: PUSH
66904: LD_INT 0
66906: PUSH
66907: EMPTY
66908: LIST
66909: LIST
66910: PUSH
66911: LD_INT 0
66913: PUSH
66914: LD_INT 1
66916: NEG
66917: PUSH
66918: EMPTY
66919: LIST
66920: LIST
66921: PUSH
66922: LD_INT 1
66924: PUSH
66925: LD_INT 0
66927: PUSH
66928: EMPTY
66929: LIST
66930: LIST
66931: PUSH
66932: LD_INT 1
66934: PUSH
66935: LD_INT 1
66937: PUSH
66938: EMPTY
66939: LIST
66940: LIST
66941: PUSH
66942: LD_INT 0
66944: PUSH
66945: LD_INT 1
66947: PUSH
66948: EMPTY
66949: LIST
66950: LIST
66951: PUSH
66952: LD_INT 1
66954: NEG
66955: PUSH
66956: LD_INT 0
66958: PUSH
66959: EMPTY
66960: LIST
66961: LIST
66962: PUSH
66963: LD_INT 1
66965: NEG
66966: PUSH
66967: LD_INT 1
66969: NEG
66970: PUSH
66971: EMPTY
66972: LIST
66973: LIST
66974: PUSH
66975: LD_INT 1
66977: NEG
66978: PUSH
66979: LD_INT 2
66981: NEG
66982: PUSH
66983: EMPTY
66984: LIST
66985: LIST
66986: PUSH
66987: LD_INT 1
66989: PUSH
66990: LD_INT 1
66992: NEG
66993: PUSH
66994: EMPTY
66995: LIST
66996: LIST
66997: PUSH
66998: LD_INT 2
67000: PUSH
67001: LD_INT 0
67003: PUSH
67004: EMPTY
67005: LIST
67006: LIST
67007: PUSH
67008: LD_INT 2
67010: PUSH
67011: LD_INT 1
67013: PUSH
67014: EMPTY
67015: LIST
67016: LIST
67017: PUSH
67018: LD_INT 2
67020: PUSH
67021: LD_INT 2
67023: PUSH
67024: EMPTY
67025: LIST
67026: LIST
67027: PUSH
67028: LD_INT 1
67030: PUSH
67031: LD_INT 2
67033: PUSH
67034: EMPTY
67035: LIST
67036: LIST
67037: PUSH
67038: LD_INT 1
67040: NEG
67041: PUSH
67042: LD_INT 1
67044: PUSH
67045: EMPTY
67046: LIST
67047: LIST
67048: PUSH
67049: LD_INT 2
67051: NEG
67052: PUSH
67053: LD_INT 0
67055: PUSH
67056: EMPTY
67057: LIST
67058: LIST
67059: PUSH
67060: LD_INT 2
67062: NEG
67063: PUSH
67064: LD_INT 1
67066: NEG
67067: PUSH
67068: EMPTY
67069: LIST
67070: LIST
67071: PUSH
67072: LD_INT 2
67074: NEG
67075: PUSH
67076: LD_INT 2
67078: NEG
67079: PUSH
67080: EMPTY
67081: LIST
67082: LIST
67083: PUSH
67084: LD_INT 2
67086: NEG
67087: PUSH
67088: LD_INT 3
67090: NEG
67091: PUSH
67092: EMPTY
67093: LIST
67094: LIST
67095: PUSH
67096: LD_INT 2
67098: PUSH
67099: LD_INT 1
67101: NEG
67102: PUSH
67103: EMPTY
67104: LIST
67105: LIST
67106: PUSH
67107: LD_INT 3
67109: PUSH
67110: LD_INT 0
67112: PUSH
67113: EMPTY
67114: LIST
67115: LIST
67116: PUSH
67117: LD_INT 3
67119: PUSH
67120: LD_INT 1
67122: PUSH
67123: EMPTY
67124: LIST
67125: LIST
67126: PUSH
67127: LD_INT 3
67129: PUSH
67130: LD_INT 2
67132: PUSH
67133: EMPTY
67134: LIST
67135: LIST
67136: PUSH
67137: LD_INT 3
67139: PUSH
67140: LD_INT 3
67142: PUSH
67143: EMPTY
67144: LIST
67145: LIST
67146: PUSH
67147: LD_INT 2
67149: PUSH
67150: LD_INT 3
67152: PUSH
67153: EMPTY
67154: LIST
67155: LIST
67156: PUSH
67157: LD_INT 2
67159: NEG
67160: PUSH
67161: LD_INT 1
67163: PUSH
67164: EMPTY
67165: LIST
67166: LIST
67167: PUSH
67168: LD_INT 3
67170: NEG
67171: PUSH
67172: LD_INT 0
67174: PUSH
67175: EMPTY
67176: LIST
67177: LIST
67178: PUSH
67179: LD_INT 3
67181: NEG
67182: PUSH
67183: LD_INT 1
67185: NEG
67186: PUSH
67187: EMPTY
67188: LIST
67189: LIST
67190: PUSH
67191: LD_INT 3
67193: NEG
67194: PUSH
67195: LD_INT 2
67197: NEG
67198: PUSH
67199: EMPTY
67200: LIST
67201: LIST
67202: PUSH
67203: LD_INT 3
67205: NEG
67206: PUSH
67207: LD_INT 3
67209: NEG
67210: PUSH
67211: EMPTY
67212: LIST
67213: LIST
67214: PUSH
67215: EMPTY
67216: LIST
67217: LIST
67218: LIST
67219: LIST
67220: LIST
67221: LIST
67222: LIST
67223: LIST
67224: LIST
67225: LIST
67226: LIST
67227: LIST
67228: LIST
67229: LIST
67230: LIST
67231: LIST
67232: LIST
67233: LIST
67234: LIST
67235: LIST
67236: LIST
67237: LIST
67238: LIST
67239: LIST
67240: LIST
67241: LIST
67242: LIST
67243: LIST
67244: LIST
67245: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67246: LD_ADDR_VAR 0 45
67250: PUSH
67251: LD_INT 0
67253: PUSH
67254: LD_INT 0
67256: PUSH
67257: EMPTY
67258: LIST
67259: LIST
67260: PUSH
67261: LD_INT 0
67263: PUSH
67264: LD_INT 1
67266: NEG
67267: PUSH
67268: EMPTY
67269: LIST
67270: LIST
67271: PUSH
67272: LD_INT 1
67274: PUSH
67275: LD_INT 0
67277: PUSH
67278: EMPTY
67279: LIST
67280: LIST
67281: PUSH
67282: LD_INT 1
67284: PUSH
67285: LD_INT 1
67287: PUSH
67288: EMPTY
67289: LIST
67290: LIST
67291: PUSH
67292: LD_INT 0
67294: PUSH
67295: LD_INT 1
67297: PUSH
67298: EMPTY
67299: LIST
67300: LIST
67301: PUSH
67302: LD_INT 1
67304: NEG
67305: PUSH
67306: LD_INT 0
67308: PUSH
67309: EMPTY
67310: LIST
67311: LIST
67312: PUSH
67313: LD_INT 1
67315: NEG
67316: PUSH
67317: LD_INT 1
67319: NEG
67320: PUSH
67321: EMPTY
67322: LIST
67323: LIST
67324: PUSH
67325: LD_INT 1
67327: NEG
67328: PUSH
67329: LD_INT 2
67331: NEG
67332: PUSH
67333: EMPTY
67334: LIST
67335: LIST
67336: PUSH
67337: LD_INT 0
67339: PUSH
67340: LD_INT 2
67342: NEG
67343: PUSH
67344: EMPTY
67345: LIST
67346: LIST
67347: PUSH
67348: LD_INT 1
67350: PUSH
67351: LD_INT 1
67353: NEG
67354: PUSH
67355: EMPTY
67356: LIST
67357: LIST
67358: PUSH
67359: LD_INT 2
67361: PUSH
67362: LD_INT 1
67364: PUSH
67365: EMPTY
67366: LIST
67367: LIST
67368: PUSH
67369: LD_INT 2
67371: PUSH
67372: LD_INT 2
67374: PUSH
67375: EMPTY
67376: LIST
67377: LIST
67378: PUSH
67379: LD_INT 1
67381: PUSH
67382: LD_INT 2
67384: PUSH
67385: EMPTY
67386: LIST
67387: LIST
67388: PUSH
67389: LD_INT 0
67391: PUSH
67392: LD_INT 2
67394: PUSH
67395: EMPTY
67396: LIST
67397: LIST
67398: PUSH
67399: LD_INT 1
67401: NEG
67402: PUSH
67403: LD_INT 1
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: PUSH
67410: LD_INT 2
67412: NEG
67413: PUSH
67414: LD_INT 1
67416: NEG
67417: PUSH
67418: EMPTY
67419: LIST
67420: LIST
67421: PUSH
67422: LD_INT 2
67424: NEG
67425: PUSH
67426: LD_INT 2
67428: NEG
67429: PUSH
67430: EMPTY
67431: LIST
67432: LIST
67433: PUSH
67434: LD_INT 2
67436: NEG
67437: PUSH
67438: LD_INT 3
67440: NEG
67441: PUSH
67442: EMPTY
67443: LIST
67444: LIST
67445: PUSH
67446: LD_INT 1
67448: NEG
67449: PUSH
67450: LD_INT 3
67452: NEG
67453: PUSH
67454: EMPTY
67455: LIST
67456: LIST
67457: PUSH
67458: LD_INT 0
67460: PUSH
67461: LD_INT 3
67463: NEG
67464: PUSH
67465: EMPTY
67466: LIST
67467: LIST
67468: PUSH
67469: LD_INT 1
67471: PUSH
67472: LD_INT 2
67474: NEG
67475: PUSH
67476: EMPTY
67477: LIST
67478: LIST
67479: PUSH
67480: LD_INT 3
67482: PUSH
67483: LD_INT 2
67485: PUSH
67486: EMPTY
67487: LIST
67488: LIST
67489: PUSH
67490: LD_INT 3
67492: PUSH
67493: LD_INT 3
67495: PUSH
67496: EMPTY
67497: LIST
67498: LIST
67499: PUSH
67500: LD_INT 2
67502: PUSH
67503: LD_INT 3
67505: PUSH
67506: EMPTY
67507: LIST
67508: LIST
67509: PUSH
67510: LD_INT 1
67512: PUSH
67513: LD_INT 3
67515: PUSH
67516: EMPTY
67517: LIST
67518: LIST
67519: PUSH
67520: LD_INT 0
67522: PUSH
67523: LD_INT 3
67525: PUSH
67526: EMPTY
67527: LIST
67528: LIST
67529: PUSH
67530: LD_INT 1
67532: NEG
67533: PUSH
67534: LD_INT 2
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: PUSH
67541: LD_INT 3
67543: NEG
67544: PUSH
67545: LD_INT 2
67547: NEG
67548: PUSH
67549: EMPTY
67550: LIST
67551: LIST
67552: PUSH
67553: LD_INT 3
67555: NEG
67556: PUSH
67557: LD_INT 3
67559: NEG
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PUSH
67565: EMPTY
67566: LIST
67567: LIST
67568: LIST
67569: LIST
67570: LIST
67571: LIST
67572: LIST
67573: LIST
67574: LIST
67575: LIST
67576: LIST
67577: LIST
67578: LIST
67579: LIST
67580: LIST
67581: LIST
67582: LIST
67583: LIST
67584: LIST
67585: LIST
67586: LIST
67587: LIST
67588: LIST
67589: LIST
67590: LIST
67591: LIST
67592: LIST
67593: LIST
67594: LIST
67595: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
67596: LD_ADDR_VAR 0 46
67600: PUSH
67601: LD_INT 0
67603: PUSH
67604: LD_INT 0
67606: PUSH
67607: EMPTY
67608: LIST
67609: LIST
67610: PUSH
67611: LD_INT 0
67613: PUSH
67614: LD_INT 1
67616: NEG
67617: PUSH
67618: EMPTY
67619: LIST
67620: LIST
67621: PUSH
67622: LD_INT 1
67624: PUSH
67625: LD_INT 0
67627: PUSH
67628: EMPTY
67629: LIST
67630: LIST
67631: PUSH
67632: LD_INT 1
67634: PUSH
67635: LD_INT 1
67637: PUSH
67638: EMPTY
67639: LIST
67640: LIST
67641: PUSH
67642: LD_INT 0
67644: PUSH
67645: LD_INT 1
67647: PUSH
67648: EMPTY
67649: LIST
67650: LIST
67651: PUSH
67652: LD_INT 1
67654: NEG
67655: PUSH
67656: LD_INT 0
67658: PUSH
67659: EMPTY
67660: LIST
67661: LIST
67662: PUSH
67663: LD_INT 1
67665: NEG
67666: PUSH
67667: LD_INT 1
67669: NEG
67670: PUSH
67671: EMPTY
67672: LIST
67673: LIST
67674: PUSH
67675: LD_INT 1
67677: NEG
67678: PUSH
67679: LD_INT 2
67681: NEG
67682: PUSH
67683: EMPTY
67684: LIST
67685: LIST
67686: PUSH
67687: LD_INT 0
67689: PUSH
67690: LD_INT 2
67692: NEG
67693: PUSH
67694: EMPTY
67695: LIST
67696: LIST
67697: PUSH
67698: LD_INT 1
67700: PUSH
67701: LD_INT 1
67703: NEG
67704: PUSH
67705: EMPTY
67706: LIST
67707: LIST
67708: PUSH
67709: LD_INT 2
67711: PUSH
67712: LD_INT 0
67714: PUSH
67715: EMPTY
67716: LIST
67717: LIST
67718: PUSH
67719: LD_INT 2
67721: PUSH
67722: LD_INT 1
67724: PUSH
67725: EMPTY
67726: LIST
67727: LIST
67728: PUSH
67729: LD_INT 1
67731: PUSH
67732: LD_INT 2
67734: PUSH
67735: EMPTY
67736: LIST
67737: LIST
67738: PUSH
67739: LD_INT 0
67741: PUSH
67742: LD_INT 2
67744: PUSH
67745: EMPTY
67746: LIST
67747: LIST
67748: PUSH
67749: LD_INT 1
67751: NEG
67752: PUSH
67753: LD_INT 1
67755: PUSH
67756: EMPTY
67757: LIST
67758: LIST
67759: PUSH
67760: LD_INT 2
67762: NEG
67763: PUSH
67764: LD_INT 0
67766: PUSH
67767: EMPTY
67768: LIST
67769: LIST
67770: PUSH
67771: LD_INT 2
67773: NEG
67774: PUSH
67775: LD_INT 1
67777: NEG
67778: PUSH
67779: EMPTY
67780: LIST
67781: LIST
67782: PUSH
67783: LD_INT 1
67785: NEG
67786: PUSH
67787: LD_INT 3
67789: NEG
67790: PUSH
67791: EMPTY
67792: LIST
67793: LIST
67794: PUSH
67795: LD_INT 0
67797: PUSH
67798: LD_INT 3
67800: NEG
67801: PUSH
67802: EMPTY
67803: LIST
67804: LIST
67805: PUSH
67806: LD_INT 1
67808: PUSH
67809: LD_INT 2
67811: NEG
67812: PUSH
67813: EMPTY
67814: LIST
67815: LIST
67816: PUSH
67817: LD_INT 2
67819: PUSH
67820: LD_INT 1
67822: NEG
67823: PUSH
67824: EMPTY
67825: LIST
67826: LIST
67827: PUSH
67828: LD_INT 3
67830: PUSH
67831: LD_INT 0
67833: PUSH
67834: EMPTY
67835: LIST
67836: LIST
67837: PUSH
67838: LD_INT 3
67840: PUSH
67841: LD_INT 1
67843: PUSH
67844: EMPTY
67845: LIST
67846: LIST
67847: PUSH
67848: LD_INT 1
67850: PUSH
67851: LD_INT 3
67853: PUSH
67854: EMPTY
67855: LIST
67856: LIST
67857: PUSH
67858: LD_INT 0
67860: PUSH
67861: LD_INT 3
67863: PUSH
67864: EMPTY
67865: LIST
67866: LIST
67867: PUSH
67868: LD_INT 1
67870: NEG
67871: PUSH
67872: LD_INT 2
67874: PUSH
67875: EMPTY
67876: LIST
67877: LIST
67878: PUSH
67879: LD_INT 2
67881: NEG
67882: PUSH
67883: LD_INT 1
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PUSH
67890: LD_INT 3
67892: NEG
67893: PUSH
67894: LD_INT 0
67896: PUSH
67897: EMPTY
67898: LIST
67899: LIST
67900: PUSH
67901: LD_INT 3
67903: NEG
67904: PUSH
67905: LD_INT 1
67907: NEG
67908: PUSH
67909: EMPTY
67910: LIST
67911: LIST
67912: PUSH
67913: EMPTY
67914: LIST
67915: LIST
67916: LIST
67917: LIST
67918: LIST
67919: LIST
67920: LIST
67921: LIST
67922: LIST
67923: LIST
67924: LIST
67925: LIST
67926: LIST
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: LIST
67935: LIST
67936: LIST
67937: LIST
67938: LIST
67939: LIST
67940: LIST
67941: LIST
67942: LIST
67943: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67944: LD_ADDR_VAR 0 47
67948: PUSH
67949: LD_INT 0
67951: PUSH
67952: LD_INT 0
67954: PUSH
67955: EMPTY
67956: LIST
67957: LIST
67958: PUSH
67959: LD_INT 0
67961: PUSH
67962: LD_INT 1
67964: NEG
67965: PUSH
67966: EMPTY
67967: LIST
67968: LIST
67969: PUSH
67970: LD_INT 1
67972: PUSH
67973: LD_INT 0
67975: PUSH
67976: EMPTY
67977: LIST
67978: LIST
67979: PUSH
67980: LD_INT 1
67982: PUSH
67983: LD_INT 1
67985: PUSH
67986: EMPTY
67987: LIST
67988: LIST
67989: PUSH
67990: LD_INT 0
67992: PUSH
67993: LD_INT 1
67995: PUSH
67996: EMPTY
67997: LIST
67998: LIST
67999: PUSH
68000: LD_INT 1
68002: NEG
68003: PUSH
68004: LD_INT 0
68006: PUSH
68007: EMPTY
68008: LIST
68009: LIST
68010: PUSH
68011: LD_INT 1
68013: NEG
68014: PUSH
68015: LD_INT 1
68017: NEG
68018: PUSH
68019: EMPTY
68020: LIST
68021: LIST
68022: PUSH
68023: LD_INT 1
68025: NEG
68026: PUSH
68027: LD_INT 2
68029: NEG
68030: PUSH
68031: EMPTY
68032: LIST
68033: LIST
68034: PUSH
68035: LD_INT 0
68037: PUSH
68038: LD_INT 2
68040: NEG
68041: PUSH
68042: EMPTY
68043: LIST
68044: LIST
68045: PUSH
68046: LD_INT 1
68048: PUSH
68049: LD_INT 1
68051: NEG
68052: PUSH
68053: EMPTY
68054: LIST
68055: LIST
68056: PUSH
68057: LD_INT 2
68059: NEG
68060: PUSH
68061: LD_INT 1
68063: NEG
68064: PUSH
68065: EMPTY
68066: LIST
68067: LIST
68068: PUSH
68069: LD_INT 2
68071: NEG
68072: PUSH
68073: LD_INT 2
68075: NEG
68076: PUSH
68077: EMPTY
68078: LIST
68079: LIST
68080: PUSH
68081: EMPTY
68082: LIST
68083: LIST
68084: LIST
68085: LIST
68086: LIST
68087: LIST
68088: LIST
68089: LIST
68090: LIST
68091: LIST
68092: LIST
68093: LIST
68094: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
68095: LD_ADDR_VAR 0 48
68099: PUSH
68100: LD_INT 0
68102: PUSH
68103: LD_INT 0
68105: PUSH
68106: EMPTY
68107: LIST
68108: LIST
68109: PUSH
68110: LD_INT 0
68112: PUSH
68113: LD_INT 1
68115: NEG
68116: PUSH
68117: EMPTY
68118: LIST
68119: LIST
68120: PUSH
68121: LD_INT 1
68123: PUSH
68124: LD_INT 0
68126: PUSH
68127: EMPTY
68128: LIST
68129: LIST
68130: PUSH
68131: LD_INT 1
68133: PUSH
68134: LD_INT 1
68136: PUSH
68137: EMPTY
68138: LIST
68139: LIST
68140: PUSH
68141: LD_INT 0
68143: PUSH
68144: LD_INT 1
68146: PUSH
68147: EMPTY
68148: LIST
68149: LIST
68150: PUSH
68151: LD_INT 1
68153: NEG
68154: PUSH
68155: LD_INT 0
68157: PUSH
68158: EMPTY
68159: LIST
68160: LIST
68161: PUSH
68162: LD_INT 1
68164: NEG
68165: PUSH
68166: LD_INT 1
68168: NEG
68169: PUSH
68170: EMPTY
68171: LIST
68172: LIST
68173: PUSH
68174: LD_INT 1
68176: NEG
68177: PUSH
68178: LD_INT 2
68180: NEG
68181: PUSH
68182: EMPTY
68183: LIST
68184: LIST
68185: PUSH
68186: LD_INT 0
68188: PUSH
68189: LD_INT 2
68191: NEG
68192: PUSH
68193: EMPTY
68194: LIST
68195: LIST
68196: PUSH
68197: LD_INT 1
68199: PUSH
68200: LD_INT 1
68202: NEG
68203: PUSH
68204: EMPTY
68205: LIST
68206: LIST
68207: PUSH
68208: LD_INT 2
68210: PUSH
68211: LD_INT 0
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: LD_INT 2
68220: PUSH
68221: LD_INT 1
68223: PUSH
68224: EMPTY
68225: LIST
68226: LIST
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: LIST
68232: LIST
68233: LIST
68234: LIST
68235: LIST
68236: LIST
68237: LIST
68238: LIST
68239: LIST
68240: LIST
68241: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
68242: LD_ADDR_VAR 0 49
68246: PUSH
68247: LD_INT 0
68249: PUSH
68250: LD_INT 0
68252: PUSH
68253: EMPTY
68254: LIST
68255: LIST
68256: PUSH
68257: LD_INT 0
68259: PUSH
68260: LD_INT 1
68262: NEG
68263: PUSH
68264: EMPTY
68265: LIST
68266: LIST
68267: PUSH
68268: LD_INT 1
68270: PUSH
68271: LD_INT 0
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: PUSH
68278: LD_INT 1
68280: PUSH
68281: LD_INT 1
68283: PUSH
68284: EMPTY
68285: LIST
68286: LIST
68287: PUSH
68288: LD_INT 0
68290: PUSH
68291: LD_INT 1
68293: PUSH
68294: EMPTY
68295: LIST
68296: LIST
68297: PUSH
68298: LD_INT 1
68300: NEG
68301: PUSH
68302: LD_INT 0
68304: PUSH
68305: EMPTY
68306: LIST
68307: LIST
68308: PUSH
68309: LD_INT 1
68311: NEG
68312: PUSH
68313: LD_INT 1
68315: NEG
68316: PUSH
68317: EMPTY
68318: LIST
68319: LIST
68320: PUSH
68321: LD_INT 1
68323: PUSH
68324: LD_INT 1
68326: NEG
68327: PUSH
68328: EMPTY
68329: LIST
68330: LIST
68331: PUSH
68332: LD_INT 2
68334: PUSH
68335: LD_INT 0
68337: PUSH
68338: EMPTY
68339: LIST
68340: LIST
68341: PUSH
68342: LD_INT 2
68344: PUSH
68345: LD_INT 1
68347: PUSH
68348: EMPTY
68349: LIST
68350: LIST
68351: PUSH
68352: LD_INT 2
68354: PUSH
68355: LD_INT 2
68357: PUSH
68358: EMPTY
68359: LIST
68360: LIST
68361: PUSH
68362: LD_INT 1
68364: PUSH
68365: LD_INT 2
68367: PUSH
68368: EMPTY
68369: LIST
68370: LIST
68371: PUSH
68372: EMPTY
68373: LIST
68374: LIST
68375: LIST
68376: LIST
68377: LIST
68378: LIST
68379: LIST
68380: LIST
68381: LIST
68382: LIST
68383: LIST
68384: LIST
68385: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
68386: LD_ADDR_VAR 0 50
68390: PUSH
68391: LD_INT 0
68393: PUSH
68394: LD_INT 0
68396: PUSH
68397: EMPTY
68398: LIST
68399: LIST
68400: PUSH
68401: LD_INT 0
68403: PUSH
68404: LD_INT 1
68406: NEG
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: PUSH
68412: LD_INT 1
68414: PUSH
68415: LD_INT 0
68417: PUSH
68418: EMPTY
68419: LIST
68420: LIST
68421: PUSH
68422: LD_INT 1
68424: PUSH
68425: LD_INT 1
68427: PUSH
68428: EMPTY
68429: LIST
68430: LIST
68431: PUSH
68432: LD_INT 0
68434: PUSH
68435: LD_INT 1
68437: PUSH
68438: EMPTY
68439: LIST
68440: LIST
68441: PUSH
68442: LD_INT 1
68444: NEG
68445: PUSH
68446: LD_INT 0
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: PUSH
68453: LD_INT 1
68455: NEG
68456: PUSH
68457: LD_INT 1
68459: NEG
68460: PUSH
68461: EMPTY
68462: LIST
68463: LIST
68464: PUSH
68465: LD_INT 2
68467: PUSH
68468: LD_INT 1
68470: PUSH
68471: EMPTY
68472: LIST
68473: LIST
68474: PUSH
68475: LD_INT 2
68477: PUSH
68478: LD_INT 2
68480: PUSH
68481: EMPTY
68482: LIST
68483: LIST
68484: PUSH
68485: LD_INT 1
68487: PUSH
68488: LD_INT 2
68490: PUSH
68491: EMPTY
68492: LIST
68493: LIST
68494: PUSH
68495: LD_INT 0
68497: PUSH
68498: LD_INT 2
68500: PUSH
68501: EMPTY
68502: LIST
68503: LIST
68504: PUSH
68505: LD_INT 1
68507: NEG
68508: PUSH
68509: LD_INT 1
68511: PUSH
68512: EMPTY
68513: LIST
68514: LIST
68515: PUSH
68516: EMPTY
68517: LIST
68518: LIST
68519: LIST
68520: LIST
68521: LIST
68522: LIST
68523: LIST
68524: LIST
68525: LIST
68526: LIST
68527: LIST
68528: LIST
68529: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
68530: LD_ADDR_VAR 0 51
68534: PUSH
68535: LD_INT 0
68537: PUSH
68538: LD_INT 0
68540: PUSH
68541: EMPTY
68542: LIST
68543: LIST
68544: PUSH
68545: LD_INT 0
68547: PUSH
68548: LD_INT 1
68550: NEG
68551: PUSH
68552: EMPTY
68553: LIST
68554: LIST
68555: PUSH
68556: LD_INT 1
68558: PUSH
68559: LD_INT 0
68561: PUSH
68562: EMPTY
68563: LIST
68564: LIST
68565: PUSH
68566: LD_INT 1
68568: PUSH
68569: LD_INT 1
68571: PUSH
68572: EMPTY
68573: LIST
68574: LIST
68575: PUSH
68576: LD_INT 0
68578: PUSH
68579: LD_INT 1
68581: PUSH
68582: EMPTY
68583: LIST
68584: LIST
68585: PUSH
68586: LD_INT 1
68588: NEG
68589: PUSH
68590: LD_INT 0
68592: PUSH
68593: EMPTY
68594: LIST
68595: LIST
68596: PUSH
68597: LD_INT 1
68599: NEG
68600: PUSH
68601: LD_INT 1
68603: NEG
68604: PUSH
68605: EMPTY
68606: LIST
68607: LIST
68608: PUSH
68609: LD_INT 1
68611: PUSH
68612: LD_INT 2
68614: PUSH
68615: EMPTY
68616: LIST
68617: LIST
68618: PUSH
68619: LD_INT 0
68621: PUSH
68622: LD_INT 2
68624: PUSH
68625: EMPTY
68626: LIST
68627: LIST
68628: PUSH
68629: LD_INT 1
68631: NEG
68632: PUSH
68633: LD_INT 1
68635: PUSH
68636: EMPTY
68637: LIST
68638: LIST
68639: PUSH
68640: LD_INT 2
68642: NEG
68643: PUSH
68644: LD_INT 0
68646: PUSH
68647: EMPTY
68648: LIST
68649: LIST
68650: PUSH
68651: LD_INT 2
68653: NEG
68654: PUSH
68655: LD_INT 1
68657: NEG
68658: PUSH
68659: EMPTY
68660: LIST
68661: LIST
68662: PUSH
68663: EMPTY
68664: LIST
68665: LIST
68666: LIST
68667: LIST
68668: LIST
68669: LIST
68670: LIST
68671: LIST
68672: LIST
68673: LIST
68674: LIST
68675: LIST
68676: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68677: LD_ADDR_VAR 0 52
68681: PUSH
68682: LD_INT 0
68684: PUSH
68685: LD_INT 0
68687: PUSH
68688: EMPTY
68689: LIST
68690: LIST
68691: PUSH
68692: LD_INT 0
68694: PUSH
68695: LD_INT 1
68697: NEG
68698: PUSH
68699: EMPTY
68700: LIST
68701: LIST
68702: PUSH
68703: LD_INT 1
68705: PUSH
68706: LD_INT 0
68708: PUSH
68709: EMPTY
68710: LIST
68711: LIST
68712: PUSH
68713: LD_INT 1
68715: PUSH
68716: LD_INT 1
68718: PUSH
68719: EMPTY
68720: LIST
68721: LIST
68722: PUSH
68723: LD_INT 0
68725: PUSH
68726: LD_INT 1
68728: PUSH
68729: EMPTY
68730: LIST
68731: LIST
68732: PUSH
68733: LD_INT 1
68735: NEG
68736: PUSH
68737: LD_INT 0
68739: PUSH
68740: EMPTY
68741: LIST
68742: LIST
68743: PUSH
68744: LD_INT 1
68746: NEG
68747: PUSH
68748: LD_INT 1
68750: NEG
68751: PUSH
68752: EMPTY
68753: LIST
68754: LIST
68755: PUSH
68756: LD_INT 1
68758: NEG
68759: PUSH
68760: LD_INT 2
68762: NEG
68763: PUSH
68764: EMPTY
68765: LIST
68766: LIST
68767: PUSH
68768: LD_INT 1
68770: NEG
68771: PUSH
68772: LD_INT 1
68774: PUSH
68775: EMPTY
68776: LIST
68777: LIST
68778: PUSH
68779: LD_INT 2
68781: NEG
68782: PUSH
68783: LD_INT 0
68785: PUSH
68786: EMPTY
68787: LIST
68788: LIST
68789: PUSH
68790: LD_INT 2
68792: NEG
68793: PUSH
68794: LD_INT 1
68796: NEG
68797: PUSH
68798: EMPTY
68799: LIST
68800: LIST
68801: PUSH
68802: LD_INT 2
68804: NEG
68805: PUSH
68806: LD_INT 2
68808: NEG
68809: PUSH
68810: EMPTY
68811: LIST
68812: LIST
68813: PUSH
68814: EMPTY
68815: LIST
68816: LIST
68817: LIST
68818: LIST
68819: LIST
68820: LIST
68821: LIST
68822: LIST
68823: LIST
68824: LIST
68825: LIST
68826: LIST
68827: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68828: LD_ADDR_VAR 0 53
68832: PUSH
68833: LD_INT 0
68835: PUSH
68836: LD_INT 0
68838: PUSH
68839: EMPTY
68840: LIST
68841: LIST
68842: PUSH
68843: LD_INT 0
68845: PUSH
68846: LD_INT 1
68848: NEG
68849: PUSH
68850: EMPTY
68851: LIST
68852: LIST
68853: PUSH
68854: LD_INT 1
68856: PUSH
68857: LD_INT 0
68859: PUSH
68860: EMPTY
68861: LIST
68862: LIST
68863: PUSH
68864: LD_INT 1
68866: PUSH
68867: LD_INT 1
68869: PUSH
68870: EMPTY
68871: LIST
68872: LIST
68873: PUSH
68874: LD_INT 0
68876: PUSH
68877: LD_INT 1
68879: PUSH
68880: EMPTY
68881: LIST
68882: LIST
68883: PUSH
68884: LD_INT 1
68886: NEG
68887: PUSH
68888: LD_INT 0
68890: PUSH
68891: EMPTY
68892: LIST
68893: LIST
68894: PUSH
68895: LD_INT 1
68897: NEG
68898: PUSH
68899: LD_INT 1
68901: NEG
68902: PUSH
68903: EMPTY
68904: LIST
68905: LIST
68906: PUSH
68907: LD_INT 1
68909: NEG
68910: PUSH
68911: LD_INT 2
68913: NEG
68914: PUSH
68915: EMPTY
68916: LIST
68917: LIST
68918: PUSH
68919: LD_INT 0
68921: PUSH
68922: LD_INT 2
68924: NEG
68925: PUSH
68926: EMPTY
68927: LIST
68928: LIST
68929: PUSH
68930: LD_INT 1
68932: PUSH
68933: LD_INT 1
68935: NEG
68936: PUSH
68937: EMPTY
68938: LIST
68939: LIST
68940: PUSH
68941: LD_INT 2
68943: PUSH
68944: LD_INT 0
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PUSH
68951: LD_INT 2
68953: PUSH
68954: LD_INT 1
68956: PUSH
68957: EMPTY
68958: LIST
68959: LIST
68960: PUSH
68961: LD_INT 2
68963: PUSH
68964: LD_INT 2
68966: PUSH
68967: EMPTY
68968: LIST
68969: LIST
68970: PUSH
68971: LD_INT 1
68973: PUSH
68974: LD_INT 2
68976: PUSH
68977: EMPTY
68978: LIST
68979: LIST
68980: PUSH
68981: LD_INT 0
68983: PUSH
68984: LD_INT 2
68986: PUSH
68987: EMPTY
68988: LIST
68989: LIST
68990: PUSH
68991: LD_INT 1
68993: NEG
68994: PUSH
68995: LD_INT 1
68997: PUSH
68998: EMPTY
68999: LIST
69000: LIST
69001: PUSH
69002: LD_INT 2
69004: NEG
69005: PUSH
69006: LD_INT 0
69008: PUSH
69009: EMPTY
69010: LIST
69011: LIST
69012: PUSH
69013: LD_INT 2
69015: NEG
69016: PUSH
69017: LD_INT 1
69019: NEG
69020: PUSH
69021: EMPTY
69022: LIST
69023: LIST
69024: PUSH
69025: LD_INT 2
69027: NEG
69028: PUSH
69029: LD_INT 2
69031: NEG
69032: PUSH
69033: EMPTY
69034: LIST
69035: LIST
69036: PUSH
69037: EMPTY
69038: LIST
69039: LIST
69040: LIST
69041: LIST
69042: LIST
69043: LIST
69044: LIST
69045: LIST
69046: LIST
69047: LIST
69048: LIST
69049: LIST
69050: LIST
69051: LIST
69052: LIST
69053: LIST
69054: LIST
69055: LIST
69056: LIST
69057: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69058: LD_ADDR_VAR 0 54
69062: PUSH
69063: LD_INT 0
69065: PUSH
69066: LD_INT 0
69068: PUSH
69069: EMPTY
69070: LIST
69071: LIST
69072: PUSH
69073: LD_INT 0
69075: PUSH
69076: LD_INT 1
69078: NEG
69079: PUSH
69080: EMPTY
69081: LIST
69082: LIST
69083: PUSH
69084: LD_INT 1
69086: PUSH
69087: LD_INT 0
69089: PUSH
69090: EMPTY
69091: LIST
69092: LIST
69093: PUSH
69094: LD_INT 1
69096: PUSH
69097: LD_INT 1
69099: PUSH
69100: EMPTY
69101: LIST
69102: LIST
69103: PUSH
69104: LD_INT 0
69106: PUSH
69107: LD_INT 1
69109: PUSH
69110: EMPTY
69111: LIST
69112: LIST
69113: PUSH
69114: LD_INT 1
69116: NEG
69117: PUSH
69118: LD_INT 0
69120: PUSH
69121: EMPTY
69122: LIST
69123: LIST
69124: PUSH
69125: LD_INT 1
69127: NEG
69128: PUSH
69129: LD_INT 1
69131: NEG
69132: PUSH
69133: EMPTY
69134: LIST
69135: LIST
69136: PUSH
69137: LD_INT 1
69139: NEG
69140: PUSH
69141: LD_INT 2
69143: NEG
69144: PUSH
69145: EMPTY
69146: LIST
69147: LIST
69148: PUSH
69149: LD_INT 0
69151: PUSH
69152: LD_INT 2
69154: NEG
69155: PUSH
69156: EMPTY
69157: LIST
69158: LIST
69159: PUSH
69160: LD_INT 1
69162: PUSH
69163: LD_INT 1
69165: NEG
69166: PUSH
69167: EMPTY
69168: LIST
69169: LIST
69170: PUSH
69171: LD_INT 2
69173: PUSH
69174: LD_INT 0
69176: PUSH
69177: EMPTY
69178: LIST
69179: LIST
69180: PUSH
69181: LD_INT 2
69183: PUSH
69184: LD_INT 1
69186: PUSH
69187: EMPTY
69188: LIST
69189: LIST
69190: PUSH
69191: LD_INT 2
69193: PUSH
69194: LD_INT 2
69196: PUSH
69197: EMPTY
69198: LIST
69199: LIST
69200: PUSH
69201: LD_INT 1
69203: PUSH
69204: LD_INT 2
69206: PUSH
69207: EMPTY
69208: LIST
69209: LIST
69210: PUSH
69211: LD_INT 0
69213: PUSH
69214: LD_INT 2
69216: PUSH
69217: EMPTY
69218: LIST
69219: LIST
69220: PUSH
69221: LD_INT 1
69223: NEG
69224: PUSH
69225: LD_INT 1
69227: PUSH
69228: EMPTY
69229: LIST
69230: LIST
69231: PUSH
69232: LD_INT 2
69234: NEG
69235: PUSH
69236: LD_INT 0
69238: PUSH
69239: EMPTY
69240: LIST
69241: LIST
69242: PUSH
69243: LD_INT 2
69245: NEG
69246: PUSH
69247: LD_INT 1
69249: NEG
69250: PUSH
69251: EMPTY
69252: LIST
69253: LIST
69254: PUSH
69255: LD_INT 2
69257: NEG
69258: PUSH
69259: LD_INT 2
69261: NEG
69262: PUSH
69263: EMPTY
69264: LIST
69265: LIST
69266: PUSH
69267: EMPTY
69268: LIST
69269: LIST
69270: LIST
69271: LIST
69272: LIST
69273: LIST
69274: LIST
69275: LIST
69276: LIST
69277: LIST
69278: LIST
69279: LIST
69280: LIST
69281: LIST
69282: LIST
69283: LIST
69284: LIST
69285: LIST
69286: LIST
69287: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69288: LD_ADDR_VAR 0 55
69292: PUSH
69293: LD_INT 0
69295: PUSH
69296: LD_INT 0
69298: PUSH
69299: EMPTY
69300: LIST
69301: LIST
69302: PUSH
69303: LD_INT 0
69305: PUSH
69306: LD_INT 1
69308: NEG
69309: PUSH
69310: EMPTY
69311: LIST
69312: LIST
69313: PUSH
69314: LD_INT 1
69316: PUSH
69317: LD_INT 0
69319: PUSH
69320: EMPTY
69321: LIST
69322: LIST
69323: PUSH
69324: LD_INT 1
69326: PUSH
69327: LD_INT 1
69329: PUSH
69330: EMPTY
69331: LIST
69332: LIST
69333: PUSH
69334: LD_INT 0
69336: PUSH
69337: LD_INT 1
69339: PUSH
69340: EMPTY
69341: LIST
69342: LIST
69343: PUSH
69344: LD_INT 1
69346: NEG
69347: PUSH
69348: LD_INT 0
69350: PUSH
69351: EMPTY
69352: LIST
69353: LIST
69354: PUSH
69355: LD_INT 1
69357: NEG
69358: PUSH
69359: LD_INT 1
69361: NEG
69362: PUSH
69363: EMPTY
69364: LIST
69365: LIST
69366: PUSH
69367: LD_INT 1
69369: NEG
69370: PUSH
69371: LD_INT 2
69373: NEG
69374: PUSH
69375: EMPTY
69376: LIST
69377: LIST
69378: PUSH
69379: LD_INT 0
69381: PUSH
69382: LD_INT 2
69384: NEG
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: PUSH
69390: LD_INT 1
69392: PUSH
69393: LD_INT 1
69395: NEG
69396: PUSH
69397: EMPTY
69398: LIST
69399: LIST
69400: PUSH
69401: LD_INT 2
69403: PUSH
69404: LD_INT 0
69406: PUSH
69407: EMPTY
69408: LIST
69409: LIST
69410: PUSH
69411: LD_INT 2
69413: PUSH
69414: LD_INT 1
69416: PUSH
69417: EMPTY
69418: LIST
69419: LIST
69420: PUSH
69421: LD_INT 2
69423: PUSH
69424: LD_INT 2
69426: PUSH
69427: EMPTY
69428: LIST
69429: LIST
69430: PUSH
69431: LD_INT 1
69433: PUSH
69434: LD_INT 2
69436: PUSH
69437: EMPTY
69438: LIST
69439: LIST
69440: PUSH
69441: LD_INT 0
69443: PUSH
69444: LD_INT 2
69446: PUSH
69447: EMPTY
69448: LIST
69449: LIST
69450: PUSH
69451: LD_INT 1
69453: NEG
69454: PUSH
69455: LD_INT 1
69457: PUSH
69458: EMPTY
69459: LIST
69460: LIST
69461: PUSH
69462: LD_INT 2
69464: NEG
69465: PUSH
69466: LD_INT 0
69468: PUSH
69469: EMPTY
69470: LIST
69471: LIST
69472: PUSH
69473: LD_INT 2
69475: NEG
69476: PUSH
69477: LD_INT 1
69479: NEG
69480: PUSH
69481: EMPTY
69482: LIST
69483: LIST
69484: PUSH
69485: LD_INT 2
69487: NEG
69488: PUSH
69489: LD_INT 2
69491: NEG
69492: PUSH
69493: EMPTY
69494: LIST
69495: LIST
69496: PUSH
69497: EMPTY
69498: LIST
69499: LIST
69500: LIST
69501: LIST
69502: LIST
69503: LIST
69504: LIST
69505: LIST
69506: LIST
69507: LIST
69508: LIST
69509: LIST
69510: LIST
69511: LIST
69512: LIST
69513: LIST
69514: LIST
69515: LIST
69516: LIST
69517: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69518: LD_ADDR_VAR 0 56
69522: PUSH
69523: LD_INT 0
69525: PUSH
69526: LD_INT 0
69528: PUSH
69529: EMPTY
69530: LIST
69531: LIST
69532: PUSH
69533: LD_INT 0
69535: PUSH
69536: LD_INT 1
69538: NEG
69539: PUSH
69540: EMPTY
69541: LIST
69542: LIST
69543: PUSH
69544: LD_INT 1
69546: PUSH
69547: LD_INT 0
69549: PUSH
69550: EMPTY
69551: LIST
69552: LIST
69553: PUSH
69554: LD_INT 1
69556: PUSH
69557: LD_INT 1
69559: PUSH
69560: EMPTY
69561: LIST
69562: LIST
69563: PUSH
69564: LD_INT 0
69566: PUSH
69567: LD_INT 1
69569: PUSH
69570: EMPTY
69571: LIST
69572: LIST
69573: PUSH
69574: LD_INT 1
69576: NEG
69577: PUSH
69578: LD_INT 0
69580: PUSH
69581: EMPTY
69582: LIST
69583: LIST
69584: PUSH
69585: LD_INT 1
69587: NEG
69588: PUSH
69589: LD_INT 1
69591: NEG
69592: PUSH
69593: EMPTY
69594: LIST
69595: LIST
69596: PUSH
69597: LD_INT 1
69599: NEG
69600: PUSH
69601: LD_INT 2
69603: NEG
69604: PUSH
69605: EMPTY
69606: LIST
69607: LIST
69608: PUSH
69609: LD_INT 0
69611: PUSH
69612: LD_INT 2
69614: NEG
69615: PUSH
69616: EMPTY
69617: LIST
69618: LIST
69619: PUSH
69620: LD_INT 1
69622: PUSH
69623: LD_INT 1
69625: NEG
69626: PUSH
69627: EMPTY
69628: LIST
69629: LIST
69630: PUSH
69631: LD_INT 2
69633: PUSH
69634: LD_INT 0
69636: PUSH
69637: EMPTY
69638: LIST
69639: LIST
69640: PUSH
69641: LD_INT 2
69643: PUSH
69644: LD_INT 1
69646: PUSH
69647: EMPTY
69648: LIST
69649: LIST
69650: PUSH
69651: LD_INT 2
69653: PUSH
69654: LD_INT 2
69656: PUSH
69657: EMPTY
69658: LIST
69659: LIST
69660: PUSH
69661: LD_INT 1
69663: PUSH
69664: LD_INT 2
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: PUSH
69671: LD_INT 0
69673: PUSH
69674: LD_INT 2
69676: PUSH
69677: EMPTY
69678: LIST
69679: LIST
69680: PUSH
69681: LD_INT 1
69683: NEG
69684: PUSH
69685: LD_INT 1
69687: PUSH
69688: EMPTY
69689: LIST
69690: LIST
69691: PUSH
69692: LD_INT 2
69694: NEG
69695: PUSH
69696: LD_INT 0
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: PUSH
69703: LD_INT 2
69705: NEG
69706: PUSH
69707: LD_INT 1
69709: NEG
69710: PUSH
69711: EMPTY
69712: LIST
69713: LIST
69714: PUSH
69715: LD_INT 2
69717: NEG
69718: PUSH
69719: LD_INT 2
69721: NEG
69722: PUSH
69723: EMPTY
69724: LIST
69725: LIST
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: LIST
69731: LIST
69732: LIST
69733: LIST
69734: LIST
69735: LIST
69736: LIST
69737: LIST
69738: LIST
69739: LIST
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69748: LD_ADDR_VAR 0 57
69752: PUSH
69753: LD_INT 0
69755: PUSH
69756: LD_INT 0
69758: PUSH
69759: EMPTY
69760: LIST
69761: LIST
69762: PUSH
69763: LD_INT 0
69765: PUSH
69766: LD_INT 1
69768: NEG
69769: PUSH
69770: EMPTY
69771: LIST
69772: LIST
69773: PUSH
69774: LD_INT 1
69776: PUSH
69777: LD_INT 0
69779: PUSH
69780: EMPTY
69781: LIST
69782: LIST
69783: PUSH
69784: LD_INT 1
69786: PUSH
69787: LD_INT 1
69789: PUSH
69790: EMPTY
69791: LIST
69792: LIST
69793: PUSH
69794: LD_INT 0
69796: PUSH
69797: LD_INT 1
69799: PUSH
69800: EMPTY
69801: LIST
69802: LIST
69803: PUSH
69804: LD_INT 1
69806: NEG
69807: PUSH
69808: LD_INT 0
69810: PUSH
69811: EMPTY
69812: LIST
69813: LIST
69814: PUSH
69815: LD_INT 1
69817: NEG
69818: PUSH
69819: LD_INT 1
69821: NEG
69822: PUSH
69823: EMPTY
69824: LIST
69825: LIST
69826: PUSH
69827: LD_INT 1
69829: NEG
69830: PUSH
69831: LD_INT 2
69833: NEG
69834: PUSH
69835: EMPTY
69836: LIST
69837: LIST
69838: PUSH
69839: LD_INT 0
69841: PUSH
69842: LD_INT 2
69844: NEG
69845: PUSH
69846: EMPTY
69847: LIST
69848: LIST
69849: PUSH
69850: LD_INT 1
69852: PUSH
69853: LD_INT 1
69855: NEG
69856: PUSH
69857: EMPTY
69858: LIST
69859: LIST
69860: PUSH
69861: LD_INT 2
69863: PUSH
69864: LD_INT 0
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: PUSH
69871: LD_INT 2
69873: PUSH
69874: LD_INT 1
69876: PUSH
69877: EMPTY
69878: LIST
69879: LIST
69880: PUSH
69881: LD_INT 2
69883: PUSH
69884: LD_INT 2
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PUSH
69891: LD_INT 1
69893: PUSH
69894: LD_INT 2
69896: PUSH
69897: EMPTY
69898: LIST
69899: LIST
69900: PUSH
69901: LD_INT 0
69903: PUSH
69904: LD_INT 2
69906: PUSH
69907: EMPTY
69908: LIST
69909: LIST
69910: PUSH
69911: LD_INT 1
69913: NEG
69914: PUSH
69915: LD_INT 1
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: PUSH
69922: LD_INT 2
69924: NEG
69925: PUSH
69926: LD_INT 0
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PUSH
69933: LD_INT 2
69935: NEG
69936: PUSH
69937: LD_INT 1
69939: NEG
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: LD_INT 2
69947: NEG
69948: PUSH
69949: LD_INT 2
69951: NEG
69952: PUSH
69953: EMPTY
69954: LIST
69955: LIST
69956: PUSH
69957: EMPTY
69958: LIST
69959: LIST
69960: LIST
69961: LIST
69962: LIST
69963: LIST
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69978: LD_ADDR_VAR 0 58
69982: PUSH
69983: LD_INT 0
69985: PUSH
69986: LD_INT 0
69988: PUSH
69989: EMPTY
69990: LIST
69991: LIST
69992: PUSH
69993: LD_INT 0
69995: PUSH
69996: LD_INT 1
69998: NEG
69999: PUSH
70000: EMPTY
70001: LIST
70002: LIST
70003: PUSH
70004: LD_INT 1
70006: PUSH
70007: LD_INT 0
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: PUSH
70014: LD_INT 1
70016: PUSH
70017: LD_INT 1
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: PUSH
70024: LD_INT 0
70026: PUSH
70027: LD_INT 1
70029: PUSH
70030: EMPTY
70031: LIST
70032: LIST
70033: PUSH
70034: LD_INT 1
70036: NEG
70037: PUSH
70038: LD_INT 0
70040: PUSH
70041: EMPTY
70042: LIST
70043: LIST
70044: PUSH
70045: LD_INT 1
70047: NEG
70048: PUSH
70049: LD_INT 1
70051: NEG
70052: PUSH
70053: EMPTY
70054: LIST
70055: LIST
70056: PUSH
70057: LD_INT 1
70059: NEG
70060: PUSH
70061: LD_INT 2
70063: NEG
70064: PUSH
70065: EMPTY
70066: LIST
70067: LIST
70068: PUSH
70069: LD_INT 0
70071: PUSH
70072: LD_INT 2
70074: NEG
70075: PUSH
70076: EMPTY
70077: LIST
70078: LIST
70079: PUSH
70080: LD_INT 1
70082: PUSH
70083: LD_INT 1
70085: NEG
70086: PUSH
70087: EMPTY
70088: LIST
70089: LIST
70090: PUSH
70091: LD_INT 2
70093: PUSH
70094: LD_INT 0
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: LD_INT 2
70103: PUSH
70104: LD_INT 1
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 2
70113: PUSH
70114: LD_INT 2
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: PUSH
70121: LD_INT 1
70123: PUSH
70124: LD_INT 2
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: PUSH
70131: LD_INT 0
70133: PUSH
70134: LD_INT 2
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: PUSH
70141: LD_INT 1
70143: NEG
70144: PUSH
70145: LD_INT 1
70147: PUSH
70148: EMPTY
70149: LIST
70150: LIST
70151: PUSH
70152: LD_INT 2
70154: NEG
70155: PUSH
70156: LD_INT 0
70158: PUSH
70159: EMPTY
70160: LIST
70161: LIST
70162: PUSH
70163: LD_INT 2
70165: NEG
70166: PUSH
70167: LD_INT 1
70169: NEG
70170: PUSH
70171: EMPTY
70172: LIST
70173: LIST
70174: PUSH
70175: LD_INT 2
70177: NEG
70178: PUSH
70179: LD_INT 2
70181: NEG
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: PUSH
70187: EMPTY
70188: LIST
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: LIST
70199: LIST
70200: LIST
70201: LIST
70202: LIST
70203: LIST
70204: LIST
70205: LIST
70206: LIST
70207: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
70208: LD_ADDR_VAR 0 59
70212: PUSH
70213: LD_INT 0
70215: PUSH
70216: LD_INT 0
70218: PUSH
70219: EMPTY
70220: LIST
70221: LIST
70222: PUSH
70223: LD_INT 0
70225: PUSH
70226: LD_INT 1
70228: NEG
70229: PUSH
70230: EMPTY
70231: LIST
70232: LIST
70233: PUSH
70234: LD_INT 1
70236: PUSH
70237: LD_INT 0
70239: PUSH
70240: EMPTY
70241: LIST
70242: LIST
70243: PUSH
70244: LD_INT 1
70246: PUSH
70247: LD_INT 1
70249: PUSH
70250: EMPTY
70251: LIST
70252: LIST
70253: PUSH
70254: LD_INT 0
70256: PUSH
70257: LD_INT 1
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PUSH
70264: LD_INT 1
70266: NEG
70267: PUSH
70268: LD_INT 0
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: PUSH
70275: LD_INT 1
70277: NEG
70278: PUSH
70279: LD_INT 1
70281: NEG
70282: PUSH
70283: EMPTY
70284: LIST
70285: LIST
70286: PUSH
70287: EMPTY
70288: LIST
70289: LIST
70290: LIST
70291: LIST
70292: LIST
70293: LIST
70294: LIST
70295: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
70296: LD_ADDR_VAR 0 60
70300: PUSH
70301: LD_INT 0
70303: PUSH
70304: LD_INT 0
70306: PUSH
70307: EMPTY
70308: LIST
70309: LIST
70310: PUSH
70311: LD_INT 0
70313: PUSH
70314: LD_INT 1
70316: NEG
70317: PUSH
70318: EMPTY
70319: LIST
70320: LIST
70321: PUSH
70322: LD_INT 1
70324: PUSH
70325: LD_INT 0
70327: PUSH
70328: EMPTY
70329: LIST
70330: LIST
70331: PUSH
70332: LD_INT 1
70334: PUSH
70335: LD_INT 1
70337: PUSH
70338: EMPTY
70339: LIST
70340: LIST
70341: PUSH
70342: LD_INT 0
70344: PUSH
70345: LD_INT 1
70347: PUSH
70348: EMPTY
70349: LIST
70350: LIST
70351: PUSH
70352: LD_INT 1
70354: NEG
70355: PUSH
70356: LD_INT 0
70358: PUSH
70359: EMPTY
70360: LIST
70361: LIST
70362: PUSH
70363: LD_INT 1
70365: NEG
70366: PUSH
70367: LD_INT 1
70369: NEG
70370: PUSH
70371: EMPTY
70372: LIST
70373: LIST
70374: PUSH
70375: EMPTY
70376: LIST
70377: LIST
70378: LIST
70379: LIST
70380: LIST
70381: LIST
70382: LIST
70383: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
70384: LD_ADDR_VAR 0 61
70388: PUSH
70389: LD_INT 0
70391: PUSH
70392: LD_INT 0
70394: PUSH
70395: EMPTY
70396: LIST
70397: LIST
70398: PUSH
70399: LD_INT 0
70401: PUSH
70402: LD_INT 1
70404: NEG
70405: PUSH
70406: EMPTY
70407: LIST
70408: LIST
70409: PUSH
70410: LD_INT 1
70412: PUSH
70413: LD_INT 0
70415: PUSH
70416: EMPTY
70417: LIST
70418: LIST
70419: PUSH
70420: LD_INT 1
70422: PUSH
70423: LD_INT 1
70425: PUSH
70426: EMPTY
70427: LIST
70428: LIST
70429: PUSH
70430: LD_INT 0
70432: PUSH
70433: LD_INT 1
70435: PUSH
70436: EMPTY
70437: LIST
70438: LIST
70439: PUSH
70440: LD_INT 1
70442: NEG
70443: PUSH
70444: LD_INT 0
70446: PUSH
70447: EMPTY
70448: LIST
70449: LIST
70450: PUSH
70451: LD_INT 1
70453: NEG
70454: PUSH
70455: LD_INT 1
70457: NEG
70458: PUSH
70459: EMPTY
70460: LIST
70461: LIST
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: LIST
70467: LIST
70468: LIST
70469: LIST
70470: LIST
70471: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
70472: LD_ADDR_VAR 0 62
70476: PUSH
70477: LD_INT 0
70479: PUSH
70480: LD_INT 0
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: PUSH
70487: LD_INT 0
70489: PUSH
70490: LD_INT 1
70492: NEG
70493: PUSH
70494: EMPTY
70495: LIST
70496: LIST
70497: PUSH
70498: LD_INT 1
70500: PUSH
70501: LD_INT 0
70503: PUSH
70504: EMPTY
70505: LIST
70506: LIST
70507: PUSH
70508: LD_INT 1
70510: PUSH
70511: LD_INT 1
70513: PUSH
70514: EMPTY
70515: LIST
70516: LIST
70517: PUSH
70518: LD_INT 0
70520: PUSH
70521: LD_INT 1
70523: PUSH
70524: EMPTY
70525: LIST
70526: LIST
70527: PUSH
70528: LD_INT 1
70530: NEG
70531: PUSH
70532: LD_INT 0
70534: PUSH
70535: EMPTY
70536: LIST
70537: LIST
70538: PUSH
70539: LD_INT 1
70541: NEG
70542: PUSH
70543: LD_INT 1
70545: NEG
70546: PUSH
70547: EMPTY
70548: LIST
70549: LIST
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: LIST
70555: LIST
70556: LIST
70557: LIST
70558: LIST
70559: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
70560: LD_ADDR_VAR 0 63
70564: PUSH
70565: LD_INT 0
70567: PUSH
70568: LD_INT 0
70570: PUSH
70571: EMPTY
70572: LIST
70573: LIST
70574: PUSH
70575: LD_INT 0
70577: PUSH
70578: LD_INT 1
70580: NEG
70581: PUSH
70582: EMPTY
70583: LIST
70584: LIST
70585: PUSH
70586: LD_INT 1
70588: PUSH
70589: LD_INT 0
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: PUSH
70596: LD_INT 1
70598: PUSH
70599: LD_INT 1
70601: PUSH
70602: EMPTY
70603: LIST
70604: LIST
70605: PUSH
70606: LD_INT 0
70608: PUSH
70609: LD_INT 1
70611: PUSH
70612: EMPTY
70613: LIST
70614: LIST
70615: PUSH
70616: LD_INT 1
70618: NEG
70619: PUSH
70620: LD_INT 0
70622: PUSH
70623: EMPTY
70624: LIST
70625: LIST
70626: PUSH
70627: LD_INT 1
70629: NEG
70630: PUSH
70631: LD_INT 1
70633: NEG
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: LIST
70643: LIST
70644: LIST
70645: LIST
70646: LIST
70647: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
70648: LD_ADDR_VAR 0 64
70652: PUSH
70653: LD_INT 0
70655: PUSH
70656: LD_INT 0
70658: PUSH
70659: EMPTY
70660: LIST
70661: LIST
70662: PUSH
70663: LD_INT 0
70665: PUSH
70666: LD_INT 1
70668: NEG
70669: PUSH
70670: EMPTY
70671: LIST
70672: LIST
70673: PUSH
70674: LD_INT 1
70676: PUSH
70677: LD_INT 0
70679: PUSH
70680: EMPTY
70681: LIST
70682: LIST
70683: PUSH
70684: LD_INT 1
70686: PUSH
70687: LD_INT 1
70689: PUSH
70690: EMPTY
70691: LIST
70692: LIST
70693: PUSH
70694: LD_INT 0
70696: PUSH
70697: LD_INT 1
70699: PUSH
70700: EMPTY
70701: LIST
70702: LIST
70703: PUSH
70704: LD_INT 1
70706: NEG
70707: PUSH
70708: LD_INT 0
70710: PUSH
70711: EMPTY
70712: LIST
70713: LIST
70714: PUSH
70715: LD_INT 1
70717: NEG
70718: PUSH
70719: LD_INT 1
70721: NEG
70722: PUSH
70723: EMPTY
70724: LIST
70725: LIST
70726: PUSH
70727: EMPTY
70728: LIST
70729: LIST
70730: LIST
70731: LIST
70732: LIST
70733: LIST
70734: LIST
70735: ST_TO_ADDR
// end ; 1 :
70736: GO 76633
70738: LD_INT 1
70740: DOUBLE
70741: EQUAL
70742: IFTRUE 70746
70744: GO 73369
70746: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
70747: LD_ADDR_VAR 0 11
70751: PUSH
70752: LD_INT 1
70754: NEG
70755: PUSH
70756: LD_INT 3
70758: NEG
70759: PUSH
70760: EMPTY
70761: LIST
70762: LIST
70763: PUSH
70764: LD_INT 0
70766: PUSH
70767: LD_INT 3
70769: NEG
70770: PUSH
70771: EMPTY
70772: LIST
70773: LIST
70774: PUSH
70775: LD_INT 1
70777: PUSH
70778: LD_INT 2
70780: NEG
70781: PUSH
70782: EMPTY
70783: LIST
70784: LIST
70785: PUSH
70786: EMPTY
70787: LIST
70788: LIST
70789: LIST
70790: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
70791: LD_ADDR_VAR 0 12
70795: PUSH
70796: LD_INT 2
70798: PUSH
70799: LD_INT 1
70801: NEG
70802: PUSH
70803: EMPTY
70804: LIST
70805: LIST
70806: PUSH
70807: LD_INT 3
70809: PUSH
70810: LD_INT 0
70812: PUSH
70813: EMPTY
70814: LIST
70815: LIST
70816: PUSH
70817: LD_INT 3
70819: PUSH
70820: LD_INT 1
70822: PUSH
70823: EMPTY
70824: LIST
70825: LIST
70826: PUSH
70827: EMPTY
70828: LIST
70829: LIST
70830: LIST
70831: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
70832: LD_ADDR_VAR 0 13
70836: PUSH
70837: LD_INT 3
70839: PUSH
70840: LD_INT 2
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: PUSH
70847: LD_INT 3
70849: PUSH
70850: LD_INT 3
70852: PUSH
70853: EMPTY
70854: LIST
70855: LIST
70856: PUSH
70857: LD_INT 2
70859: PUSH
70860: LD_INT 3
70862: PUSH
70863: EMPTY
70864: LIST
70865: LIST
70866: PUSH
70867: EMPTY
70868: LIST
70869: LIST
70870: LIST
70871: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
70872: LD_ADDR_VAR 0 14
70876: PUSH
70877: LD_INT 1
70879: PUSH
70880: LD_INT 3
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: PUSH
70887: LD_INT 0
70889: PUSH
70890: LD_INT 3
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: LD_INT 1
70899: NEG
70900: PUSH
70901: LD_INT 2
70903: PUSH
70904: EMPTY
70905: LIST
70906: LIST
70907: PUSH
70908: EMPTY
70909: LIST
70910: LIST
70911: LIST
70912: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70913: LD_ADDR_VAR 0 15
70917: PUSH
70918: LD_INT 2
70920: NEG
70921: PUSH
70922: LD_INT 1
70924: PUSH
70925: EMPTY
70926: LIST
70927: LIST
70928: PUSH
70929: LD_INT 3
70931: NEG
70932: PUSH
70933: LD_INT 0
70935: PUSH
70936: EMPTY
70937: LIST
70938: LIST
70939: PUSH
70940: LD_INT 3
70942: NEG
70943: PUSH
70944: LD_INT 1
70946: NEG
70947: PUSH
70948: EMPTY
70949: LIST
70950: LIST
70951: PUSH
70952: EMPTY
70953: LIST
70954: LIST
70955: LIST
70956: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70957: LD_ADDR_VAR 0 16
70961: PUSH
70962: LD_INT 2
70964: NEG
70965: PUSH
70966: LD_INT 3
70968: NEG
70969: PUSH
70970: EMPTY
70971: LIST
70972: LIST
70973: PUSH
70974: LD_INT 3
70976: NEG
70977: PUSH
70978: LD_INT 2
70980: NEG
70981: PUSH
70982: EMPTY
70983: LIST
70984: LIST
70985: PUSH
70986: LD_INT 3
70988: NEG
70989: PUSH
70990: LD_INT 3
70992: NEG
70993: PUSH
70994: EMPTY
70995: LIST
70996: LIST
70997: PUSH
70998: EMPTY
70999: LIST
71000: LIST
71001: LIST
71002: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
71003: LD_ADDR_VAR 0 17
71007: PUSH
71008: LD_INT 1
71010: NEG
71011: PUSH
71012: LD_INT 3
71014: NEG
71015: PUSH
71016: EMPTY
71017: LIST
71018: LIST
71019: PUSH
71020: LD_INT 0
71022: PUSH
71023: LD_INT 3
71025: NEG
71026: PUSH
71027: EMPTY
71028: LIST
71029: LIST
71030: PUSH
71031: LD_INT 1
71033: PUSH
71034: LD_INT 2
71036: NEG
71037: PUSH
71038: EMPTY
71039: LIST
71040: LIST
71041: PUSH
71042: EMPTY
71043: LIST
71044: LIST
71045: LIST
71046: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
71047: LD_ADDR_VAR 0 18
71051: PUSH
71052: LD_INT 2
71054: PUSH
71055: LD_INT 1
71057: NEG
71058: PUSH
71059: EMPTY
71060: LIST
71061: LIST
71062: PUSH
71063: LD_INT 3
71065: PUSH
71066: LD_INT 0
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: PUSH
71073: LD_INT 3
71075: PUSH
71076: LD_INT 1
71078: PUSH
71079: EMPTY
71080: LIST
71081: LIST
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: LIST
71087: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
71088: LD_ADDR_VAR 0 19
71092: PUSH
71093: LD_INT 3
71095: PUSH
71096: LD_INT 2
71098: PUSH
71099: EMPTY
71100: LIST
71101: LIST
71102: PUSH
71103: LD_INT 3
71105: PUSH
71106: LD_INT 3
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: PUSH
71113: LD_INT 2
71115: PUSH
71116: LD_INT 3
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: LIST
71127: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
71128: LD_ADDR_VAR 0 20
71132: PUSH
71133: LD_INT 1
71135: PUSH
71136: LD_INT 3
71138: PUSH
71139: EMPTY
71140: LIST
71141: LIST
71142: PUSH
71143: LD_INT 0
71145: PUSH
71146: LD_INT 3
71148: PUSH
71149: EMPTY
71150: LIST
71151: LIST
71152: PUSH
71153: LD_INT 1
71155: NEG
71156: PUSH
71157: LD_INT 2
71159: PUSH
71160: EMPTY
71161: LIST
71162: LIST
71163: PUSH
71164: EMPTY
71165: LIST
71166: LIST
71167: LIST
71168: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71169: LD_ADDR_VAR 0 21
71173: PUSH
71174: LD_INT 2
71176: NEG
71177: PUSH
71178: LD_INT 1
71180: PUSH
71181: EMPTY
71182: LIST
71183: LIST
71184: PUSH
71185: LD_INT 3
71187: NEG
71188: PUSH
71189: LD_INT 0
71191: PUSH
71192: EMPTY
71193: LIST
71194: LIST
71195: PUSH
71196: LD_INT 3
71198: NEG
71199: PUSH
71200: LD_INT 1
71202: NEG
71203: PUSH
71204: EMPTY
71205: LIST
71206: LIST
71207: PUSH
71208: EMPTY
71209: LIST
71210: LIST
71211: LIST
71212: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71213: LD_ADDR_VAR 0 22
71217: PUSH
71218: LD_INT 2
71220: NEG
71221: PUSH
71222: LD_INT 3
71224: NEG
71225: PUSH
71226: EMPTY
71227: LIST
71228: LIST
71229: PUSH
71230: LD_INT 3
71232: NEG
71233: PUSH
71234: LD_INT 2
71236: NEG
71237: PUSH
71238: EMPTY
71239: LIST
71240: LIST
71241: PUSH
71242: LD_INT 3
71244: NEG
71245: PUSH
71246: LD_INT 3
71248: NEG
71249: PUSH
71250: EMPTY
71251: LIST
71252: LIST
71253: PUSH
71254: EMPTY
71255: LIST
71256: LIST
71257: LIST
71258: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
71259: LD_ADDR_VAR 0 23
71263: PUSH
71264: LD_INT 0
71266: PUSH
71267: LD_INT 3
71269: NEG
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: PUSH
71275: LD_INT 1
71277: NEG
71278: PUSH
71279: LD_INT 4
71281: NEG
71282: PUSH
71283: EMPTY
71284: LIST
71285: LIST
71286: PUSH
71287: LD_INT 1
71289: PUSH
71290: LD_INT 3
71292: NEG
71293: PUSH
71294: EMPTY
71295: LIST
71296: LIST
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: LIST
71302: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
71303: LD_ADDR_VAR 0 24
71307: PUSH
71308: LD_INT 3
71310: PUSH
71311: LD_INT 0
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: PUSH
71318: LD_INT 3
71320: PUSH
71321: LD_INT 1
71323: NEG
71324: PUSH
71325: EMPTY
71326: LIST
71327: LIST
71328: PUSH
71329: LD_INT 4
71331: PUSH
71332: LD_INT 1
71334: PUSH
71335: EMPTY
71336: LIST
71337: LIST
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: LIST
71343: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
71344: LD_ADDR_VAR 0 25
71348: PUSH
71349: LD_INT 3
71351: PUSH
71352: LD_INT 3
71354: PUSH
71355: EMPTY
71356: LIST
71357: LIST
71358: PUSH
71359: LD_INT 4
71361: PUSH
71362: LD_INT 3
71364: PUSH
71365: EMPTY
71366: LIST
71367: LIST
71368: PUSH
71369: LD_INT 3
71371: PUSH
71372: LD_INT 4
71374: PUSH
71375: EMPTY
71376: LIST
71377: LIST
71378: PUSH
71379: EMPTY
71380: LIST
71381: LIST
71382: LIST
71383: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
71384: LD_ADDR_VAR 0 26
71388: PUSH
71389: LD_INT 0
71391: PUSH
71392: LD_INT 3
71394: PUSH
71395: EMPTY
71396: LIST
71397: LIST
71398: PUSH
71399: LD_INT 1
71401: PUSH
71402: LD_INT 4
71404: PUSH
71405: EMPTY
71406: LIST
71407: LIST
71408: PUSH
71409: LD_INT 1
71411: NEG
71412: PUSH
71413: LD_INT 3
71415: PUSH
71416: EMPTY
71417: LIST
71418: LIST
71419: PUSH
71420: EMPTY
71421: LIST
71422: LIST
71423: LIST
71424: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
71425: LD_ADDR_VAR 0 27
71429: PUSH
71430: LD_INT 3
71432: NEG
71433: PUSH
71434: LD_INT 0
71436: PUSH
71437: EMPTY
71438: LIST
71439: LIST
71440: PUSH
71441: LD_INT 3
71443: NEG
71444: PUSH
71445: LD_INT 1
71447: PUSH
71448: EMPTY
71449: LIST
71450: LIST
71451: PUSH
71452: LD_INT 4
71454: NEG
71455: PUSH
71456: LD_INT 1
71458: NEG
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: PUSH
71464: EMPTY
71465: LIST
71466: LIST
71467: LIST
71468: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
71469: LD_ADDR_VAR 0 28
71473: PUSH
71474: LD_INT 3
71476: NEG
71477: PUSH
71478: LD_INT 3
71480: NEG
71481: PUSH
71482: EMPTY
71483: LIST
71484: LIST
71485: PUSH
71486: LD_INT 3
71488: NEG
71489: PUSH
71490: LD_INT 4
71492: NEG
71493: PUSH
71494: EMPTY
71495: LIST
71496: LIST
71497: PUSH
71498: LD_INT 4
71500: NEG
71501: PUSH
71502: LD_INT 3
71504: NEG
71505: PUSH
71506: EMPTY
71507: LIST
71508: LIST
71509: PUSH
71510: EMPTY
71511: LIST
71512: LIST
71513: LIST
71514: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
71515: LD_ADDR_VAR 0 29
71519: PUSH
71520: LD_INT 1
71522: NEG
71523: PUSH
71524: LD_INT 3
71526: NEG
71527: PUSH
71528: EMPTY
71529: LIST
71530: LIST
71531: PUSH
71532: LD_INT 0
71534: PUSH
71535: LD_INT 3
71537: NEG
71538: PUSH
71539: EMPTY
71540: LIST
71541: LIST
71542: PUSH
71543: LD_INT 1
71545: PUSH
71546: LD_INT 2
71548: NEG
71549: PUSH
71550: EMPTY
71551: LIST
71552: LIST
71553: PUSH
71554: LD_INT 1
71556: NEG
71557: PUSH
71558: LD_INT 4
71560: NEG
71561: PUSH
71562: EMPTY
71563: LIST
71564: LIST
71565: PUSH
71566: LD_INT 0
71568: PUSH
71569: LD_INT 4
71571: NEG
71572: PUSH
71573: EMPTY
71574: LIST
71575: LIST
71576: PUSH
71577: LD_INT 1
71579: PUSH
71580: LD_INT 3
71582: NEG
71583: PUSH
71584: EMPTY
71585: LIST
71586: LIST
71587: PUSH
71588: LD_INT 1
71590: NEG
71591: PUSH
71592: LD_INT 5
71594: NEG
71595: PUSH
71596: EMPTY
71597: LIST
71598: LIST
71599: PUSH
71600: LD_INT 0
71602: PUSH
71603: LD_INT 5
71605: NEG
71606: PUSH
71607: EMPTY
71608: LIST
71609: LIST
71610: PUSH
71611: LD_INT 1
71613: PUSH
71614: LD_INT 4
71616: NEG
71617: PUSH
71618: EMPTY
71619: LIST
71620: LIST
71621: PUSH
71622: LD_INT 1
71624: NEG
71625: PUSH
71626: LD_INT 6
71628: NEG
71629: PUSH
71630: EMPTY
71631: LIST
71632: LIST
71633: PUSH
71634: LD_INT 0
71636: PUSH
71637: LD_INT 6
71639: NEG
71640: PUSH
71641: EMPTY
71642: LIST
71643: LIST
71644: PUSH
71645: LD_INT 1
71647: PUSH
71648: LD_INT 5
71650: NEG
71651: PUSH
71652: EMPTY
71653: LIST
71654: LIST
71655: PUSH
71656: EMPTY
71657: LIST
71658: LIST
71659: LIST
71660: LIST
71661: LIST
71662: LIST
71663: LIST
71664: LIST
71665: LIST
71666: LIST
71667: LIST
71668: LIST
71669: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
71670: LD_ADDR_VAR 0 30
71674: PUSH
71675: LD_INT 2
71677: PUSH
71678: LD_INT 1
71680: NEG
71681: PUSH
71682: EMPTY
71683: LIST
71684: LIST
71685: PUSH
71686: LD_INT 3
71688: PUSH
71689: LD_INT 0
71691: PUSH
71692: EMPTY
71693: LIST
71694: LIST
71695: PUSH
71696: LD_INT 3
71698: PUSH
71699: LD_INT 1
71701: PUSH
71702: EMPTY
71703: LIST
71704: LIST
71705: PUSH
71706: LD_INT 3
71708: PUSH
71709: LD_INT 1
71711: NEG
71712: PUSH
71713: EMPTY
71714: LIST
71715: LIST
71716: PUSH
71717: LD_INT 4
71719: PUSH
71720: LD_INT 0
71722: PUSH
71723: EMPTY
71724: LIST
71725: LIST
71726: PUSH
71727: LD_INT 4
71729: PUSH
71730: LD_INT 1
71732: PUSH
71733: EMPTY
71734: LIST
71735: LIST
71736: PUSH
71737: LD_INT 4
71739: PUSH
71740: LD_INT 1
71742: NEG
71743: PUSH
71744: EMPTY
71745: LIST
71746: LIST
71747: PUSH
71748: LD_INT 5
71750: PUSH
71751: LD_INT 0
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: PUSH
71758: LD_INT 5
71760: PUSH
71761: LD_INT 1
71763: PUSH
71764: EMPTY
71765: LIST
71766: LIST
71767: PUSH
71768: LD_INT 5
71770: PUSH
71771: LD_INT 1
71773: NEG
71774: PUSH
71775: EMPTY
71776: LIST
71777: LIST
71778: PUSH
71779: LD_INT 6
71781: PUSH
71782: LD_INT 0
71784: PUSH
71785: EMPTY
71786: LIST
71787: LIST
71788: PUSH
71789: LD_INT 6
71791: PUSH
71792: LD_INT 1
71794: PUSH
71795: EMPTY
71796: LIST
71797: LIST
71798: PUSH
71799: EMPTY
71800: LIST
71801: LIST
71802: LIST
71803: LIST
71804: LIST
71805: LIST
71806: LIST
71807: LIST
71808: LIST
71809: LIST
71810: LIST
71811: LIST
71812: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
71813: LD_ADDR_VAR 0 31
71817: PUSH
71818: LD_INT 3
71820: PUSH
71821: LD_INT 2
71823: PUSH
71824: EMPTY
71825: LIST
71826: LIST
71827: PUSH
71828: LD_INT 3
71830: PUSH
71831: LD_INT 3
71833: PUSH
71834: EMPTY
71835: LIST
71836: LIST
71837: PUSH
71838: LD_INT 2
71840: PUSH
71841: LD_INT 3
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: PUSH
71848: LD_INT 4
71850: PUSH
71851: LD_INT 3
71853: PUSH
71854: EMPTY
71855: LIST
71856: LIST
71857: PUSH
71858: LD_INT 4
71860: PUSH
71861: LD_INT 4
71863: PUSH
71864: EMPTY
71865: LIST
71866: LIST
71867: PUSH
71868: LD_INT 3
71870: PUSH
71871: LD_INT 4
71873: PUSH
71874: EMPTY
71875: LIST
71876: LIST
71877: PUSH
71878: LD_INT 5
71880: PUSH
71881: LD_INT 4
71883: PUSH
71884: EMPTY
71885: LIST
71886: LIST
71887: PUSH
71888: LD_INT 5
71890: PUSH
71891: LD_INT 5
71893: PUSH
71894: EMPTY
71895: LIST
71896: LIST
71897: PUSH
71898: LD_INT 4
71900: PUSH
71901: LD_INT 5
71903: PUSH
71904: EMPTY
71905: LIST
71906: LIST
71907: PUSH
71908: LD_INT 6
71910: PUSH
71911: LD_INT 5
71913: PUSH
71914: EMPTY
71915: LIST
71916: LIST
71917: PUSH
71918: LD_INT 6
71920: PUSH
71921: LD_INT 6
71923: PUSH
71924: EMPTY
71925: LIST
71926: LIST
71927: PUSH
71928: LD_INT 5
71930: PUSH
71931: LD_INT 6
71933: PUSH
71934: EMPTY
71935: LIST
71936: LIST
71937: PUSH
71938: EMPTY
71939: LIST
71940: LIST
71941: LIST
71942: LIST
71943: LIST
71944: LIST
71945: LIST
71946: LIST
71947: LIST
71948: LIST
71949: LIST
71950: LIST
71951: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
71952: LD_ADDR_VAR 0 32
71956: PUSH
71957: LD_INT 1
71959: PUSH
71960: LD_INT 3
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: PUSH
71967: LD_INT 0
71969: PUSH
71970: LD_INT 3
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: PUSH
71977: LD_INT 1
71979: NEG
71980: PUSH
71981: LD_INT 2
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: PUSH
71988: LD_INT 1
71990: PUSH
71991: LD_INT 4
71993: PUSH
71994: EMPTY
71995: LIST
71996: LIST
71997: PUSH
71998: LD_INT 0
72000: PUSH
72001: LD_INT 4
72003: PUSH
72004: EMPTY
72005: LIST
72006: LIST
72007: PUSH
72008: LD_INT 1
72010: NEG
72011: PUSH
72012: LD_INT 3
72014: PUSH
72015: EMPTY
72016: LIST
72017: LIST
72018: PUSH
72019: LD_INT 1
72021: PUSH
72022: LD_INT 5
72024: PUSH
72025: EMPTY
72026: LIST
72027: LIST
72028: PUSH
72029: LD_INT 0
72031: PUSH
72032: LD_INT 5
72034: PUSH
72035: EMPTY
72036: LIST
72037: LIST
72038: PUSH
72039: LD_INT 1
72041: NEG
72042: PUSH
72043: LD_INT 4
72045: PUSH
72046: EMPTY
72047: LIST
72048: LIST
72049: PUSH
72050: LD_INT 1
72052: PUSH
72053: LD_INT 6
72055: PUSH
72056: EMPTY
72057: LIST
72058: LIST
72059: PUSH
72060: LD_INT 0
72062: PUSH
72063: LD_INT 6
72065: PUSH
72066: EMPTY
72067: LIST
72068: LIST
72069: PUSH
72070: LD_INT 1
72072: NEG
72073: PUSH
72074: LD_INT 5
72076: PUSH
72077: EMPTY
72078: LIST
72079: LIST
72080: PUSH
72081: EMPTY
72082: LIST
72083: LIST
72084: LIST
72085: LIST
72086: LIST
72087: LIST
72088: LIST
72089: LIST
72090: LIST
72091: LIST
72092: LIST
72093: LIST
72094: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
72095: LD_ADDR_VAR 0 33
72099: PUSH
72100: LD_INT 2
72102: NEG
72103: PUSH
72104: LD_INT 1
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 3
72113: NEG
72114: PUSH
72115: LD_INT 0
72117: PUSH
72118: EMPTY
72119: LIST
72120: LIST
72121: PUSH
72122: LD_INT 3
72124: NEG
72125: PUSH
72126: LD_INT 1
72128: NEG
72129: PUSH
72130: EMPTY
72131: LIST
72132: LIST
72133: PUSH
72134: LD_INT 3
72136: NEG
72137: PUSH
72138: LD_INT 1
72140: PUSH
72141: EMPTY
72142: LIST
72143: LIST
72144: PUSH
72145: LD_INT 4
72147: NEG
72148: PUSH
72149: LD_INT 0
72151: PUSH
72152: EMPTY
72153: LIST
72154: LIST
72155: PUSH
72156: LD_INT 4
72158: NEG
72159: PUSH
72160: LD_INT 1
72162: NEG
72163: PUSH
72164: EMPTY
72165: LIST
72166: LIST
72167: PUSH
72168: LD_INT 4
72170: NEG
72171: PUSH
72172: LD_INT 1
72174: PUSH
72175: EMPTY
72176: LIST
72177: LIST
72178: PUSH
72179: LD_INT 5
72181: NEG
72182: PUSH
72183: LD_INT 0
72185: PUSH
72186: EMPTY
72187: LIST
72188: LIST
72189: PUSH
72190: LD_INT 5
72192: NEG
72193: PUSH
72194: LD_INT 1
72196: NEG
72197: PUSH
72198: EMPTY
72199: LIST
72200: LIST
72201: PUSH
72202: LD_INT 5
72204: NEG
72205: PUSH
72206: LD_INT 1
72208: PUSH
72209: EMPTY
72210: LIST
72211: LIST
72212: PUSH
72213: LD_INT 6
72215: NEG
72216: PUSH
72217: LD_INT 0
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: PUSH
72224: LD_INT 6
72226: NEG
72227: PUSH
72228: LD_INT 1
72230: NEG
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: PUSH
72236: EMPTY
72237: LIST
72238: LIST
72239: LIST
72240: LIST
72241: LIST
72242: LIST
72243: LIST
72244: LIST
72245: LIST
72246: LIST
72247: LIST
72248: LIST
72249: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
72250: LD_ADDR_VAR 0 34
72254: PUSH
72255: LD_INT 2
72257: NEG
72258: PUSH
72259: LD_INT 3
72261: NEG
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: PUSH
72267: LD_INT 3
72269: NEG
72270: PUSH
72271: LD_INT 2
72273: NEG
72274: PUSH
72275: EMPTY
72276: LIST
72277: LIST
72278: PUSH
72279: LD_INT 3
72281: NEG
72282: PUSH
72283: LD_INT 3
72285: NEG
72286: PUSH
72287: EMPTY
72288: LIST
72289: LIST
72290: PUSH
72291: LD_INT 3
72293: NEG
72294: PUSH
72295: LD_INT 4
72297: NEG
72298: PUSH
72299: EMPTY
72300: LIST
72301: LIST
72302: PUSH
72303: LD_INT 4
72305: NEG
72306: PUSH
72307: LD_INT 3
72309: NEG
72310: PUSH
72311: EMPTY
72312: LIST
72313: LIST
72314: PUSH
72315: LD_INT 4
72317: NEG
72318: PUSH
72319: LD_INT 4
72321: NEG
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: PUSH
72327: LD_INT 4
72329: NEG
72330: PUSH
72331: LD_INT 5
72333: NEG
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: PUSH
72339: LD_INT 5
72341: NEG
72342: PUSH
72343: LD_INT 4
72345: NEG
72346: PUSH
72347: EMPTY
72348: LIST
72349: LIST
72350: PUSH
72351: LD_INT 5
72353: NEG
72354: PUSH
72355: LD_INT 5
72357: NEG
72358: PUSH
72359: EMPTY
72360: LIST
72361: LIST
72362: PUSH
72363: LD_INT 5
72365: NEG
72366: PUSH
72367: LD_INT 6
72369: NEG
72370: PUSH
72371: EMPTY
72372: LIST
72373: LIST
72374: PUSH
72375: LD_INT 6
72377: NEG
72378: PUSH
72379: LD_INT 5
72381: NEG
72382: PUSH
72383: EMPTY
72384: LIST
72385: LIST
72386: PUSH
72387: LD_INT 6
72389: NEG
72390: PUSH
72391: LD_INT 6
72393: NEG
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: EMPTY
72400: LIST
72401: LIST
72402: LIST
72403: LIST
72404: LIST
72405: LIST
72406: LIST
72407: LIST
72408: LIST
72409: LIST
72410: LIST
72411: LIST
72412: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
72413: LD_ADDR_VAR 0 41
72417: PUSH
72418: LD_INT 0
72420: PUSH
72421: LD_INT 2
72423: NEG
72424: PUSH
72425: EMPTY
72426: LIST
72427: LIST
72428: PUSH
72429: LD_INT 1
72431: NEG
72432: PUSH
72433: LD_INT 3
72435: NEG
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: PUSH
72441: LD_INT 1
72443: PUSH
72444: LD_INT 2
72446: NEG
72447: PUSH
72448: EMPTY
72449: LIST
72450: LIST
72451: PUSH
72452: EMPTY
72453: LIST
72454: LIST
72455: LIST
72456: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
72457: LD_ADDR_VAR 0 42
72461: PUSH
72462: LD_INT 2
72464: PUSH
72465: LD_INT 0
72467: PUSH
72468: EMPTY
72469: LIST
72470: LIST
72471: PUSH
72472: LD_INT 2
72474: PUSH
72475: LD_INT 1
72477: NEG
72478: PUSH
72479: EMPTY
72480: LIST
72481: LIST
72482: PUSH
72483: LD_INT 3
72485: PUSH
72486: LD_INT 1
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: PUSH
72493: EMPTY
72494: LIST
72495: LIST
72496: LIST
72497: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
72498: LD_ADDR_VAR 0 43
72502: PUSH
72503: LD_INT 2
72505: PUSH
72506: LD_INT 2
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PUSH
72513: LD_INT 3
72515: PUSH
72516: LD_INT 2
72518: PUSH
72519: EMPTY
72520: LIST
72521: LIST
72522: PUSH
72523: LD_INT 2
72525: PUSH
72526: LD_INT 3
72528: PUSH
72529: EMPTY
72530: LIST
72531: LIST
72532: PUSH
72533: EMPTY
72534: LIST
72535: LIST
72536: LIST
72537: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
72538: LD_ADDR_VAR 0 44
72542: PUSH
72543: LD_INT 0
72545: PUSH
72546: LD_INT 2
72548: PUSH
72549: EMPTY
72550: LIST
72551: LIST
72552: PUSH
72553: LD_INT 1
72555: PUSH
72556: LD_INT 3
72558: PUSH
72559: EMPTY
72560: LIST
72561: LIST
72562: PUSH
72563: LD_INT 1
72565: NEG
72566: PUSH
72567: LD_INT 2
72569: PUSH
72570: EMPTY
72571: LIST
72572: LIST
72573: PUSH
72574: EMPTY
72575: LIST
72576: LIST
72577: LIST
72578: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72579: LD_ADDR_VAR 0 45
72583: PUSH
72584: LD_INT 2
72586: NEG
72587: PUSH
72588: LD_INT 0
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: PUSH
72595: LD_INT 2
72597: NEG
72598: PUSH
72599: LD_INT 1
72601: PUSH
72602: EMPTY
72603: LIST
72604: LIST
72605: PUSH
72606: LD_INT 3
72608: NEG
72609: PUSH
72610: LD_INT 1
72612: NEG
72613: PUSH
72614: EMPTY
72615: LIST
72616: LIST
72617: PUSH
72618: EMPTY
72619: LIST
72620: LIST
72621: LIST
72622: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
72623: LD_ADDR_VAR 0 46
72627: PUSH
72628: LD_INT 2
72630: NEG
72631: PUSH
72632: LD_INT 2
72634: NEG
72635: PUSH
72636: EMPTY
72637: LIST
72638: LIST
72639: PUSH
72640: LD_INT 2
72642: NEG
72643: PUSH
72644: LD_INT 3
72646: NEG
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: PUSH
72652: LD_INT 3
72654: NEG
72655: PUSH
72656: LD_INT 2
72658: NEG
72659: PUSH
72660: EMPTY
72661: LIST
72662: LIST
72663: PUSH
72664: EMPTY
72665: LIST
72666: LIST
72667: LIST
72668: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
72669: LD_ADDR_VAR 0 47
72673: PUSH
72674: LD_INT 2
72676: NEG
72677: PUSH
72678: LD_INT 3
72680: NEG
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: PUSH
72686: LD_INT 1
72688: NEG
72689: PUSH
72690: LD_INT 3
72692: NEG
72693: PUSH
72694: EMPTY
72695: LIST
72696: LIST
72697: PUSH
72698: EMPTY
72699: LIST
72700: LIST
72701: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
72702: LD_ADDR_VAR 0 48
72706: PUSH
72707: LD_INT 1
72709: PUSH
72710: LD_INT 2
72712: NEG
72713: PUSH
72714: EMPTY
72715: LIST
72716: LIST
72717: PUSH
72718: LD_INT 2
72720: PUSH
72721: LD_INT 1
72723: NEG
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: PUSH
72729: EMPTY
72730: LIST
72731: LIST
72732: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
72733: LD_ADDR_VAR 0 49
72737: PUSH
72738: LD_INT 3
72740: PUSH
72741: LD_INT 1
72743: PUSH
72744: EMPTY
72745: LIST
72746: LIST
72747: PUSH
72748: LD_INT 3
72750: PUSH
72751: LD_INT 2
72753: PUSH
72754: EMPTY
72755: LIST
72756: LIST
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
72762: LD_ADDR_VAR 0 50
72766: PUSH
72767: LD_INT 2
72769: PUSH
72770: LD_INT 3
72772: PUSH
72773: EMPTY
72774: LIST
72775: LIST
72776: PUSH
72777: LD_INT 1
72779: PUSH
72780: LD_INT 3
72782: PUSH
72783: EMPTY
72784: LIST
72785: LIST
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
72791: LD_ADDR_VAR 0 51
72795: PUSH
72796: LD_INT 1
72798: NEG
72799: PUSH
72800: LD_INT 2
72802: PUSH
72803: EMPTY
72804: LIST
72805: LIST
72806: PUSH
72807: LD_INT 2
72809: NEG
72810: PUSH
72811: LD_INT 1
72813: PUSH
72814: EMPTY
72815: LIST
72816: LIST
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
72822: LD_ADDR_VAR 0 52
72826: PUSH
72827: LD_INT 3
72829: NEG
72830: PUSH
72831: LD_INT 1
72833: NEG
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PUSH
72839: LD_INT 3
72841: NEG
72842: PUSH
72843: LD_INT 2
72845: NEG
72846: PUSH
72847: EMPTY
72848: LIST
72849: LIST
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
72855: LD_ADDR_VAR 0 53
72859: PUSH
72860: LD_INT 1
72862: NEG
72863: PUSH
72864: LD_INT 3
72866: NEG
72867: PUSH
72868: EMPTY
72869: LIST
72870: LIST
72871: PUSH
72872: LD_INT 0
72874: PUSH
72875: LD_INT 3
72877: NEG
72878: PUSH
72879: EMPTY
72880: LIST
72881: LIST
72882: PUSH
72883: LD_INT 1
72885: PUSH
72886: LD_INT 2
72888: NEG
72889: PUSH
72890: EMPTY
72891: LIST
72892: LIST
72893: PUSH
72894: EMPTY
72895: LIST
72896: LIST
72897: LIST
72898: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
72899: LD_ADDR_VAR 0 54
72903: PUSH
72904: LD_INT 2
72906: PUSH
72907: LD_INT 1
72909: NEG
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: PUSH
72915: LD_INT 3
72917: PUSH
72918: LD_INT 0
72920: PUSH
72921: EMPTY
72922: LIST
72923: LIST
72924: PUSH
72925: LD_INT 3
72927: PUSH
72928: LD_INT 1
72930: PUSH
72931: EMPTY
72932: LIST
72933: LIST
72934: PUSH
72935: EMPTY
72936: LIST
72937: LIST
72938: LIST
72939: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
72940: LD_ADDR_VAR 0 55
72944: PUSH
72945: LD_INT 3
72947: PUSH
72948: LD_INT 2
72950: PUSH
72951: EMPTY
72952: LIST
72953: LIST
72954: PUSH
72955: LD_INT 3
72957: PUSH
72958: LD_INT 3
72960: PUSH
72961: EMPTY
72962: LIST
72963: LIST
72964: PUSH
72965: LD_INT 2
72967: PUSH
72968: LD_INT 3
72970: PUSH
72971: EMPTY
72972: LIST
72973: LIST
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: LIST
72979: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
72980: LD_ADDR_VAR 0 56
72984: PUSH
72985: LD_INT 1
72987: PUSH
72988: LD_INT 3
72990: PUSH
72991: EMPTY
72992: LIST
72993: LIST
72994: PUSH
72995: LD_INT 0
72997: PUSH
72998: LD_INT 3
73000: PUSH
73001: EMPTY
73002: LIST
73003: LIST
73004: PUSH
73005: LD_INT 1
73007: NEG
73008: PUSH
73009: LD_INT 2
73011: PUSH
73012: EMPTY
73013: LIST
73014: LIST
73015: PUSH
73016: EMPTY
73017: LIST
73018: LIST
73019: LIST
73020: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73021: LD_ADDR_VAR 0 57
73025: PUSH
73026: LD_INT 2
73028: NEG
73029: PUSH
73030: LD_INT 1
73032: PUSH
73033: EMPTY
73034: LIST
73035: LIST
73036: PUSH
73037: LD_INT 3
73039: NEG
73040: PUSH
73041: LD_INT 0
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: PUSH
73048: LD_INT 3
73050: NEG
73051: PUSH
73052: LD_INT 1
73054: NEG
73055: PUSH
73056: EMPTY
73057: LIST
73058: LIST
73059: PUSH
73060: EMPTY
73061: LIST
73062: LIST
73063: LIST
73064: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73065: LD_ADDR_VAR 0 58
73069: PUSH
73070: LD_INT 2
73072: NEG
73073: PUSH
73074: LD_INT 3
73076: NEG
73077: PUSH
73078: EMPTY
73079: LIST
73080: LIST
73081: PUSH
73082: LD_INT 3
73084: NEG
73085: PUSH
73086: LD_INT 2
73088: NEG
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: PUSH
73094: LD_INT 3
73096: NEG
73097: PUSH
73098: LD_INT 3
73100: NEG
73101: PUSH
73102: EMPTY
73103: LIST
73104: LIST
73105: PUSH
73106: EMPTY
73107: LIST
73108: LIST
73109: LIST
73110: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
73111: LD_ADDR_VAR 0 59
73115: PUSH
73116: LD_INT 1
73118: NEG
73119: PUSH
73120: LD_INT 2
73122: NEG
73123: PUSH
73124: EMPTY
73125: LIST
73126: LIST
73127: PUSH
73128: LD_INT 0
73130: PUSH
73131: LD_INT 2
73133: NEG
73134: PUSH
73135: EMPTY
73136: LIST
73137: LIST
73138: PUSH
73139: LD_INT 1
73141: PUSH
73142: LD_INT 1
73144: NEG
73145: PUSH
73146: EMPTY
73147: LIST
73148: LIST
73149: PUSH
73150: EMPTY
73151: LIST
73152: LIST
73153: LIST
73154: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
73155: LD_ADDR_VAR 0 60
73159: PUSH
73160: LD_INT 1
73162: PUSH
73163: LD_INT 1
73165: NEG
73166: PUSH
73167: EMPTY
73168: LIST
73169: LIST
73170: PUSH
73171: LD_INT 2
73173: PUSH
73174: LD_INT 0
73176: PUSH
73177: EMPTY
73178: LIST
73179: LIST
73180: PUSH
73181: LD_INT 2
73183: PUSH
73184: LD_INT 1
73186: PUSH
73187: EMPTY
73188: LIST
73189: LIST
73190: PUSH
73191: EMPTY
73192: LIST
73193: LIST
73194: LIST
73195: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
73196: LD_ADDR_VAR 0 61
73200: PUSH
73201: LD_INT 2
73203: PUSH
73204: LD_INT 1
73206: PUSH
73207: EMPTY
73208: LIST
73209: LIST
73210: PUSH
73211: LD_INT 2
73213: PUSH
73214: LD_INT 2
73216: PUSH
73217: EMPTY
73218: LIST
73219: LIST
73220: PUSH
73221: LD_INT 1
73223: PUSH
73224: LD_INT 2
73226: PUSH
73227: EMPTY
73228: LIST
73229: LIST
73230: PUSH
73231: EMPTY
73232: LIST
73233: LIST
73234: LIST
73235: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
73236: LD_ADDR_VAR 0 62
73240: PUSH
73241: LD_INT 1
73243: PUSH
73244: LD_INT 2
73246: PUSH
73247: EMPTY
73248: LIST
73249: LIST
73250: PUSH
73251: LD_INT 0
73253: PUSH
73254: LD_INT 2
73256: PUSH
73257: EMPTY
73258: LIST
73259: LIST
73260: PUSH
73261: LD_INT 1
73263: NEG
73264: PUSH
73265: LD_INT 1
73267: PUSH
73268: EMPTY
73269: LIST
73270: LIST
73271: PUSH
73272: EMPTY
73273: LIST
73274: LIST
73275: LIST
73276: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
73277: LD_ADDR_VAR 0 63
73281: PUSH
73282: LD_INT 1
73284: NEG
73285: PUSH
73286: LD_INT 1
73288: PUSH
73289: EMPTY
73290: LIST
73291: LIST
73292: PUSH
73293: LD_INT 2
73295: NEG
73296: PUSH
73297: LD_INT 0
73299: PUSH
73300: EMPTY
73301: LIST
73302: LIST
73303: PUSH
73304: LD_INT 2
73306: NEG
73307: PUSH
73308: LD_INT 1
73310: NEG
73311: PUSH
73312: EMPTY
73313: LIST
73314: LIST
73315: PUSH
73316: EMPTY
73317: LIST
73318: LIST
73319: LIST
73320: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73321: LD_ADDR_VAR 0 64
73325: PUSH
73326: LD_INT 1
73328: NEG
73329: PUSH
73330: LD_INT 2
73332: NEG
73333: PUSH
73334: EMPTY
73335: LIST
73336: LIST
73337: PUSH
73338: LD_INT 2
73340: NEG
73341: PUSH
73342: LD_INT 1
73344: NEG
73345: PUSH
73346: EMPTY
73347: LIST
73348: LIST
73349: PUSH
73350: LD_INT 2
73352: NEG
73353: PUSH
73354: LD_INT 2
73356: NEG
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: LIST
73366: ST_TO_ADDR
// end ; 2 :
73367: GO 76633
73369: LD_INT 2
73371: DOUBLE
73372: EQUAL
73373: IFTRUE 73377
73375: GO 76632
73377: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
73378: LD_ADDR_VAR 0 29
73382: PUSH
73383: LD_INT 4
73385: PUSH
73386: LD_INT 0
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: PUSH
73393: LD_INT 4
73395: PUSH
73396: LD_INT 1
73398: NEG
73399: PUSH
73400: EMPTY
73401: LIST
73402: LIST
73403: PUSH
73404: LD_INT 5
73406: PUSH
73407: LD_INT 0
73409: PUSH
73410: EMPTY
73411: LIST
73412: LIST
73413: PUSH
73414: LD_INT 5
73416: PUSH
73417: LD_INT 1
73419: PUSH
73420: EMPTY
73421: LIST
73422: LIST
73423: PUSH
73424: LD_INT 4
73426: PUSH
73427: LD_INT 1
73429: PUSH
73430: EMPTY
73431: LIST
73432: LIST
73433: PUSH
73434: LD_INT 3
73436: PUSH
73437: LD_INT 0
73439: PUSH
73440: EMPTY
73441: LIST
73442: LIST
73443: PUSH
73444: LD_INT 3
73446: PUSH
73447: LD_INT 1
73449: NEG
73450: PUSH
73451: EMPTY
73452: LIST
73453: LIST
73454: PUSH
73455: LD_INT 3
73457: PUSH
73458: LD_INT 2
73460: NEG
73461: PUSH
73462: EMPTY
73463: LIST
73464: LIST
73465: PUSH
73466: LD_INT 5
73468: PUSH
73469: LD_INT 2
73471: PUSH
73472: EMPTY
73473: LIST
73474: LIST
73475: PUSH
73476: LD_INT 3
73478: PUSH
73479: LD_INT 3
73481: PUSH
73482: EMPTY
73483: LIST
73484: LIST
73485: PUSH
73486: LD_INT 3
73488: PUSH
73489: LD_INT 2
73491: PUSH
73492: EMPTY
73493: LIST
73494: LIST
73495: PUSH
73496: LD_INT 4
73498: PUSH
73499: LD_INT 3
73501: PUSH
73502: EMPTY
73503: LIST
73504: LIST
73505: PUSH
73506: LD_INT 4
73508: PUSH
73509: LD_INT 4
73511: PUSH
73512: EMPTY
73513: LIST
73514: LIST
73515: PUSH
73516: LD_INT 3
73518: PUSH
73519: LD_INT 4
73521: PUSH
73522: EMPTY
73523: LIST
73524: LIST
73525: PUSH
73526: LD_INT 2
73528: PUSH
73529: LD_INT 3
73531: PUSH
73532: EMPTY
73533: LIST
73534: LIST
73535: PUSH
73536: LD_INT 2
73538: PUSH
73539: LD_INT 2
73541: PUSH
73542: EMPTY
73543: LIST
73544: LIST
73545: PUSH
73546: LD_INT 4
73548: PUSH
73549: LD_INT 2
73551: PUSH
73552: EMPTY
73553: LIST
73554: LIST
73555: PUSH
73556: LD_INT 2
73558: PUSH
73559: LD_INT 4
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: PUSH
73566: LD_INT 0
73568: PUSH
73569: LD_INT 4
73571: PUSH
73572: EMPTY
73573: LIST
73574: LIST
73575: PUSH
73576: LD_INT 0
73578: PUSH
73579: LD_INT 3
73581: PUSH
73582: EMPTY
73583: LIST
73584: LIST
73585: PUSH
73586: LD_INT 1
73588: PUSH
73589: LD_INT 4
73591: PUSH
73592: EMPTY
73593: LIST
73594: LIST
73595: PUSH
73596: LD_INT 1
73598: PUSH
73599: LD_INT 5
73601: PUSH
73602: EMPTY
73603: LIST
73604: LIST
73605: PUSH
73606: LD_INT 0
73608: PUSH
73609: LD_INT 5
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: PUSH
73616: LD_INT 1
73618: NEG
73619: PUSH
73620: LD_INT 4
73622: PUSH
73623: EMPTY
73624: LIST
73625: LIST
73626: PUSH
73627: LD_INT 1
73629: NEG
73630: PUSH
73631: LD_INT 3
73633: PUSH
73634: EMPTY
73635: LIST
73636: LIST
73637: PUSH
73638: LD_INT 2
73640: PUSH
73641: LD_INT 5
73643: PUSH
73644: EMPTY
73645: LIST
73646: LIST
73647: PUSH
73648: LD_INT 2
73650: NEG
73651: PUSH
73652: LD_INT 3
73654: PUSH
73655: EMPTY
73656: LIST
73657: LIST
73658: PUSH
73659: LD_INT 3
73661: NEG
73662: PUSH
73663: LD_INT 0
73665: PUSH
73666: EMPTY
73667: LIST
73668: LIST
73669: PUSH
73670: LD_INT 3
73672: NEG
73673: PUSH
73674: LD_INT 1
73676: NEG
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PUSH
73682: LD_INT 2
73684: NEG
73685: PUSH
73686: LD_INT 0
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: LD_INT 2
73695: NEG
73696: PUSH
73697: LD_INT 1
73699: PUSH
73700: EMPTY
73701: LIST
73702: LIST
73703: PUSH
73704: LD_INT 3
73706: NEG
73707: PUSH
73708: LD_INT 1
73710: PUSH
73711: EMPTY
73712: LIST
73713: LIST
73714: PUSH
73715: LD_INT 4
73717: NEG
73718: PUSH
73719: LD_INT 0
73721: PUSH
73722: EMPTY
73723: LIST
73724: LIST
73725: PUSH
73726: LD_INT 4
73728: NEG
73729: PUSH
73730: LD_INT 1
73732: NEG
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: PUSH
73738: LD_INT 4
73740: NEG
73741: PUSH
73742: LD_INT 2
73744: NEG
73745: PUSH
73746: EMPTY
73747: LIST
73748: LIST
73749: PUSH
73750: LD_INT 2
73752: NEG
73753: PUSH
73754: LD_INT 2
73756: PUSH
73757: EMPTY
73758: LIST
73759: LIST
73760: PUSH
73761: LD_INT 4
73763: NEG
73764: PUSH
73765: LD_INT 4
73767: NEG
73768: PUSH
73769: EMPTY
73770: LIST
73771: LIST
73772: PUSH
73773: LD_INT 4
73775: NEG
73776: PUSH
73777: LD_INT 5
73779: NEG
73780: PUSH
73781: EMPTY
73782: LIST
73783: LIST
73784: PUSH
73785: LD_INT 3
73787: NEG
73788: PUSH
73789: LD_INT 4
73791: NEG
73792: PUSH
73793: EMPTY
73794: LIST
73795: LIST
73796: PUSH
73797: LD_INT 3
73799: NEG
73800: PUSH
73801: LD_INT 3
73803: NEG
73804: PUSH
73805: EMPTY
73806: LIST
73807: LIST
73808: PUSH
73809: LD_INT 4
73811: NEG
73812: PUSH
73813: LD_INT 3
73815: NEG
73816: PUSH
73817: EMPTY
73818: LIST
73819: LIST
73820: PUSH
73821: LD_INT 5
73823: NEG
73824: PUSH
73825: LD_INT 4
73827: NEG
73828: PUSH
73829: EMPTY
73830: LIST
73831: LIST
73832: PUSH
73833: LD_INT 5
73835: NEG
73836: PUSH
73837: LD_INT 5
73839: NEG
73840: PUSH
73841: EMPTY
73842: LIST
73843: LIST
73844: PUSH
73845: LD_INT 3
73847: NEG
73848: PUSH
73849: LD_INT 5
73851: NEG
73852: PUSH
73853: EMPTY
73854: LIST
73855: LIST
73856: PUSH
73857: LD_INT 5
73859: NEG
73860: PUSH
73861: LD_INT 3
73863: NEG
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: PUSH
73869: EMPTY
73870: LIST
73871: LIST
73872: LIST
73873: LIST
73874: LIST
73875: LIST
73876: LIST
73877: LIST
73878: LIST
73879: LIST
73880: LIST
73881: LIST
73882: LIST
73883: LIST
73884: LIST
73885: LIST
73886: LIST
73887: LIST
73888: LIST
73889: LIST
73890: LIST
73891: LIST
73892: LIST
73893: LIST
73894: LIST
73895: LIST
73896: LIST
73897: LIST
73898: LIST
73899: LIST
73900: LIST
73901: LIST
73902: LIST
73903: LIST
73904: LIST
73905: LIST
73906: LIST
73907: LIST
73908: LIST
73909: LIST
73910: LIST
73911: LIST
73912: LIST
73913: LIST
73914: LIST
73915: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
73916: LD_ADDR_VAR 0 30
73920: PUSH
73921: LD_INT 4
73923: PUSH
73924: LD_INT 4
73926: PUSH
73927: EMPTY
73928: LIST
73929: LIST
73930: PUSH
73931: LD_INT 4
73933: PUSH
73934: LD_INT 3
73936: PUSH
73937: EMPTY
73938: LIST
73939: LIST
73940: PUSH
73941: LD_INT 5
73943: PUSH
73944: LD_INT 4
73946: PUSH
73947: EMPTY
73948: LIST
73949: LIST
73950: PUSH
73951: LD_INT 5
73953: PUSH
73954: LD_INT 5
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: LD_INT 4
73963: PUSH
73964: LD_INT 5
73966: PUSH
73967: EMPTY
73968: LIST
73969: LIST
73970: PUSH
73971: LD_INT 3
73973: PUSH
73974: LD_INT 4
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: PUSH
73981: LD_INT 3
73983: PUSH
73984: LD_INT 3
73986: PUSH
73987: EMPTY
73988: LIST
73989: LIST
73990: PUSH
73991: LD_INT 5
73993: PUSH
73994: LD_INT 3
73996: PUSH
73997: EMPTY
73998: LIST
73999: LIST
74000: PUSH
74001: LD_INT 3
74003: PUSH
74004: LD_INT 5
74006: PUSH
74007: EMPTY
74008: LIST
74009: LIST
74010: PUSH
74011: LD_INT 0
74013: PUSH
74014: LD_INT 3
74016: PUSH
74017: EMPTY
74018: LIST
74019: LIST
74020: PUSH
74021: LD_INT 0
74023: PUSH
74024: LD_INT 2
74026: PUSH
74027: EMPTY
74028: LIST
74029: LIST
74030: PUSH
74031: LD_INT 1
74033: PUSH
74034: LD_INT 3
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: PUSH
74041: LD_INT 1
74043: PUSH
74044: LD_INT 4
74046: PUSH
74047: EMPTY
74048: LIST
74049: LIST
74050: PUSH
74051: LD_INT 0
74053: PUSH
74054: LD_INT 4
74056: PUSH
74057: EMPTY
74058: LIST
74059: LIST
74060: PUSH
74061: LD_INT 1
74063: NEG
74064: PUSH
74065: LD_INT 3
74067: PUSH
74068: EMPTY
74069: LIST
74070: LIST
74071: PUSH
74072: LD_INT 1
74074: NEG
74075: PUSH
74076: LD_INT 2
74078: PUSH
74079: EMPTY
74080: LIST
74081: LIST
74082: PUSH
74083: LD_INT 2
74085: PUSH
74086: LD_INT 4
74088: PUSH
74089: EMPTY
74090: LIST
74091: LIST
74092: PUSH
74093: LD_INT 2
74095: NEG
74096: PUSH
74097: LD_INT 2
74099: PUSH
74100: EMPTY
74101: LIST
74102: LIST
74103: PUSH
74104: LD_INT 4
74106: NEG
74107: PUSH
74108: LD_INT 0
74110: PUSH
74111: EMPTY
74112: LIST
74113: LIST
74114: PUSH
74115: LD_INT 4
74117: NEG
74118: PUSH
74119: LD_INT 1
74121: NEG
74122: PUSH
74123: EMPTY
74124: LIST
74125: LIST
74126: PUSH
74127: LD_INT 3
74129: NEG
74130: PUSH
74131: LD_INT 0
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: PUSH
74138: LD_INT 3
74140: NEG
74141: PUSH
74142: LD_INT 1
74144: PUSH
74145: EMPTY
74146: LIST
74147: LIST
74148: PUSH
74149: LD_INT 4
74151: NEG
74152: PUSH
74153: LD_INT 1
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: PUSH
74160: LD_INT 5
74162: NEG
74163: PUSH
74164: LD_INT 0
74166: PUSH
74167: EMPTY
74168: LIST
74169: LIST
74170: PUSH
74171: LD_INT 5
74173: NEG
74174: PUSH
74175: LD_INT 1
74177: NEG
74178: PUSH
74179: EMPTY
74180: LIST
74181: LIST
74182: PUSH
74183: LD_INT 5
74185: NEG
74186: PUSH
74187: LD_INT 2
74189: NEG
74190: PUSH
74191: EMPTY
74192: LIST
74193: LIST
74194: PUSH
74195: LD_INT 3
74197: NEG
74198: PUSH
74199: LD_INT 2
74201: PUSH
74202: EMPTY
74203: LIST
74204: LIST
74205: PUSH
74206: LD_INT 3
74208: NEG
74209: PUSH
74210: LD_INT 3
74212: NEG
74213: PUSH
74214: EMPTY
74215: LIST
74216: LIST
74217: PUSH
74218: LD_INT 3
74220: NEG
74221: PUSH
74222: LD_INT 4
74224: NEG
74225: PUSH
74226: EMPTY
74227: LIST
74228: LIST
74229: PUSH
74230: LD_INT 2
74232: NEG
74233: PUSH
74234: LD_INT 3
74236: NEG
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: PUSH
74242: LD_INT 2
74244: NEG
74245: PUSH
74246: LD_INT 2
74248: NEG
74249: PUSH
74250: EMPTY
74251: LIST
74252: LIST
74253: PUSH
74254: LD_INT 3
74256: NEG
74257: PUSH
74258: LD_INT 2
74260: NEG
74261: PUSH
74262: EMPTY
74263: LIST
74264: LIST
74265: PUSH
74266: LD_INT 4
74268: NEG
74269: PUSH
74270: LD_INT 3
74272: NEG
74273: PUSH
74274: EMPTY
74275: LIST
74276: LIST
74277: PUSH
74278: LD_INT 4
74280: NEG
74281: PUSH
74282: LD_INT 4
74284: NEG
74285: PUSH
74286: EMPTY
74287: LIST
74288: LIST
74289: PUSH
74290: LD_INT 2
74292: NEG
74293: PUSH
74294: LD_INT 4
74296: NEG
74297: PUSH
74298: EMPTY
74299: LIST
74300: LIST
74301: PUSH
74302: LD_INT 4
74304: NEG
74305: PUSH
74306: LD_INT 2
74308: NEG
74309: PUSH
74310: EMPTY
74311: LIST
74312: LIST
74313: PUSH
74314: LD_INT 0
74316: PUSH
74317: LD_INT 4
74319: NEG
74320: PUSH
74321: EMPTY
74322: LIST
74323: LIST
74324: PUSH
74325: LD_INT 0
74327: PUSH
74328: LD_INT 5
74330: NEG
74331: PUSH
74332: EMPTY
74333: LIST
74334: LIST
74335: PUSH
74336: LD_INT 1
74338: PUSH
74339: LD_INT 4
74341: NEG
74342: PUSH
74343: EMPTY
74344: LIST
74345: LIST
74346: PUSH
74347: LD_INT 1
74349: PUSH
74350: LD_INT 3
74352: NEG
74353: PUSH
74354: EMPTY
74355: LIST
74356: LIST
74357: PUSH
74358: LD_INT 0
74360: PUSH
74361: LD_INT 3
74363: NEG
74364: PUSH
74365: EMPTY
74366: LIST
74367: LIST
74368: PUSH
74369: LD_INT 1
74371: NEG
74372: PUSH
74373: LD_INT 4
74375: NEG
74376: PUSH
74377: EMPTY
74378: LIST
74379: LIST
74380: PUSH
74381: LD_INT 1
74383: NEG
74384: PUSH
74385: LD_INT 5
74387: NEG
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: PUSH
74393: LD_INT 2
74395: PUSH
74396: LD_INT 3
74398: NEG
74399: PUSH
74400: EMPTY
74401: LIST
74402: LIST
74403: PUSH
74404: LD_INT 2
74406: NEG
74407: PUSH
74408: LD_INT 5
74410: NEG
74411: PUSH
74412: EMPTY
74413: LIST
74414: LIST
74415: PUSH
74416: EMPTY
74417: LIST
74418: LIST
74419: LIST
74420: LIST
74421: LIST
74422: LIST
74423: LIST
74424: LIST
74425: LIST
74426: LIST
74427: LIST
74428: LIST
74429: LIST
74430: LIST
74431: LIST
74432: LIST
74433: LIST
74434: LIST
74435: LIST
74436: LIST
74437: LIST
74438: LIST
74439: LIST
74440: LIST
74441: LIST
74442: LIST
74443: LIST
74444: LIST
74445: LIST
74446: LIST
74447: LIST
74448: LIST
74449: LIST
74450: LIST
74451: LIST
74452: LIST
74453: LIST
74454: LIST
74455: LIST
74456: LIST
74457: LIST
74458: LIST
74459: LIST
74460: LIST
74461: LIST
74462: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
74463: LD_ADDR_VAR 0 31
74467: PUSH
74468: LD_INT 0
74470: PUSH
74471: LD_INT 4
74473: PUSH
74474: EMPTY
74475: LIST
74476: LIST
74477: PUSH
74478: LD_INT 0
74480: PUSH
74481: LD_INT 3
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: LD_INT 1
74490: PUSH
74491: LD_INT 4
74493: PUSH
74494: EMPTY
74495: LIST
74496: LIST
74497: PUSH
74498: LD_INT 1
74500: PUSH
74501: LD_INT 5
74503: PUSH
74504: EMPTY
74505: LIST
74506: LIST
74507: PUSH
74508: LD_INT 0
74510: PUSH
74511: LD_INT 5
74513: PUSH
74514: EMPTY
74515: LIST
74516: LIST
74517: PUSH
74518: LD_INT 1
74520: NEG
74521: PUSH
74522: LD_INT 4
74524: PUSH
74525: EMPTY
74526: LIST
74527: LIST
74528: PUSH
74529: LD_INT 1
74531: NEG
74532: PUSH
74533: LD_INT 3
74535: PUSH
74536: EMPTY
74537: LIST
74538: LIST
74539: PUSH
74540: LD_INT 2
74542: PUSH
74543: LD_INT 5
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: PUSH
74550: LD_INT 2
74552: NEG
74553: PUSH
74554: LD_INT 3
74556: PUSH
74557: EMPTY
74558: LIST
74559: LIST
74560: PUSH
74561: LD_INT 3
74563: NEG
74564: PUSH
74565: LD_INT 0
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PUSH
74572: LD_INT 3
74574: NEG
74575: PUSH
74576: LD_INT 1
74578: NEG
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PUSH
74584: LD_INT 2
74586: NEG
74587: PUSH
74588: LD_INT 0
74590: PUSH
74591: EMPTY
74592: LIST
74593: LIST
74594: PUSH
74595: LD_INT 2
74597: NEG
74598: PUSH
74599: LD_INT 1
74601: PUSH
74602: EMPTY
74603: LIST
74604: LIST
74605: PUSH
74606: LD_INT 3
74608: NEG
74609: PUSH
74610: LD_INT 1
74612: PUSH
74613: EMPTY
74614: LIST
74615: LIST
74616: PUSH
74617: LD_INT 4
74619: NEG
74620: PUSH
74621: LD_INT 0
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: PUSH
74628: LD_INT 4
74630: NEG
74631: PUSH
74632: LD_INT 1
74634: NEG
74635: PUSH
74636: EMPTY
74637: LIST
74638: LIST
74639: PUSH
74640: LD_INT 4
74642: NEG
74643: PUSH
74644: LD_INT 2
74646: NEG
74647: PUSH
74648: EMPTY
74649: LIST
74650: LIST
74651: PUSH
74652: LD_INT 2
74654: NEG
74655: PUSH
74656: LD_INT 2
74658: PUSH
74659: EMPTY
74660: LIST
74661: LIST
74662: PUSH
74663: LD_INT 4
74665: NEG
74666: PUSH
74667: LD_INT 4
74669: NEG
74670: PUSH
74671: EMPTY
74672: LIST
74673: LIST
74674: PUSH
74675: LD_INT 4
74677: NEG
74678: PUSH
74679: LD_INT 5
74681: NEG
74682: PUSH
74683: EMPTY
74684: LIST
74685: LIST
74686: PUSH
74687: LD_INT 3
74689: NEG
74690: PUSH
74691: LD_INT 4
74693: NEG
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: LD_INT 3
74701: NEG
74702: PUSH
74703: LD_INT 3
74705: NEG
74706: PUSH
74707: EMPTY
74708: LIST
74709: LIST
74710: PUSH
74711: LD_INT 4
74713: NEG
74714: PUSH
74715: LD_INT 3
74717: NEG
74718: PUSH
74719: EMPTY
74720: LIST
74721: LIST
74722: PUSH
74723: LD_INT 5
74725: NEG
74726: PUSH
74727: LD_INT 4
74729: NEG
74730: PUSH
74731: EMPTY
74732: LIST
74733: LIST
74734: PUSH
74735: LD_INT 5
74737: NEG
74738: PUSH
74739: LD_INT 5
74741: NEG
74742: PUSH
74743: EMPTY
74744: LIST
74745: LIST
74746: PUSH
74747: LD_INT 3
74749: NEG
74750: PUSH
74751: LD_INT 5
74753: NEG
74754: PUSH
74755: EMPTY
74756: LIST
74757: LIST
74758: PUSH
74759: LD_INT 5
74761: NEG
74762: PUSH
74763: LD_INT 3
74765: NEG
74766: PUSH
74767: EMPTY
74768: LIST
74769: LIST
74770: PUSH
74771: LD_INT 0
74773: PUSH
74774: LD_INT 3
74776: NEG
74777: PUSH
74778: EMPTY
74779: LIST
74780: LIST
74781: PUSH
74782: LD_INT 0
74784: PUSH
74785: LD_INT 4
74787: NEG
74788: PUSH
74789: EMPTY
74790: LIST
74791: LIST
74792: PUSH
74793: LD_INT 1
74795: PUSH
74796: LD_INT 3
74798: NEG
74799: PUSH
74800: EMPTY
74801: LIST
74802: LIST
74803: PUSH
74804: LD_INT 1
74806: PUSH
74807: LD_INT 2
74809: NEG
74810: PUSH
74811: EMPTY
74812: LIST
74813: LIST
74814: PUSH
74815: LD_INT 0
74817: PUSH
74818: LD_INT 2
74820: NEG
74821: PUSH
74822: EMPTY
74823: LIST
74824: LIST
74825: PUSH
74826: LD_INT 1
74828: NEG
74829: PUSH
74830: LD_INT 3
74832: NEG
74833: PUSH
74834: EMPTY
74835: LIST
74836: LIST
74837: PUSH
74838: LD_INT 1
74840: NEG
74841: PUSH
74842: LD_INT 4
74844: NEG
74845: PUSH
74846: EMPTY
74847: LIST
74848: LIST
74849: PUSH
74850: LD_INT 2
74852: PUSH
74853: LD_INT 2
74855: NEG
74856: PUSH
74857: EMPTY
74858: LIST
74859: LIST
74860: PUSH
74861: LD_INT 2
74863: NEG
74864: PUSH
74865: LD_INT 4
74867: NEG
74868: PUSH
74869: EMPTY
74870: LIST
74871: LIST
74872: PUSH
74873: LD_INT 4
74875: PUSH
74876: LD_INT 0
74878: PUSH
74879: EMPTY
74880: LIST
74881: LIST
74882: PUSH
74883: LD_INT 4
74885: PUSH
74886: LD_INT 1
74888: NEG
74889: PUSH
74890: EMPTY
74891: LIST
74892: LIST
74893: PUSH
74894: LD_INT 5
74896: PUSH
74897: LD_INT 0
74899: PUSH
74900: EMPTY
74901: LIST
74902: LIST
74903: PUSH
74904: LD_INT 5
74906: PUSH
74907: LD_INT 1
74909: PUSH
74910: EMPTY
74911: LIST
74912: LIST
74913: PUSH
74914: LD_INT 4
74916: PUSH
74917: LD_INT 1
74919: PUSH
74920: EMPTY
74921: LIST
74922: LIST
74923: PUSH
74924: LD_INT 3
74926: PUSH
74927: LD_INT 0
74929: PUSH
74930: EMPTY
74931: LIST
74932: LIST
74933: PUSH
74934: LD_INT 3
74936: PUSH
74937: LD_INT 1
74939: NEG
74940: PUSH
74941: EMPTY
74942: LIST
74943: LIST
74944: PUSH
74945: LD_INT 3
74947: PUSH
74948: LD_INT 2
74950: NEG
74951: PUSH
74952: EMPTY
74953: LIST
74954: LIST
74955: PUSH
74956: LD_INT 5
74958: PUSH
74959: LD_INT 2
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: PUSH
74966: EMPTY
74967: LIST
74968: LIST
74969: LIST
74970: LIST
74971: LIST
74972: LIST
74973: LIST
74974: LIST
74975: LIST
74976: LIST
74977: LIST
74978: LIST
74979: LIST
74980: LIST
74981: LIST
74982: LIST
74983: LIST
74984: LIST
74985: LIST
74986: LIST
74987: LIST
74988: LIST
74989: LIST
74990: LIST
74991: LIST
74992: LIST
74993: LIST
74994: LIST
74995: LIST
74996: LIST
74997: LIST
74998: LIST
74999: LIST
75000: LIST
75001: LIST
75002: LIST
75003: LIST
75004: LIST
75005: LIST
75006: LIST
75007: LIST
75008: LIST
75009: LIST
75010: LIST
75011: LIST
75012: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
75013: LD_ADDR_VAR 0 32
75017: PUSH
75018: LD_INT 4
75020: NEG
75021: PUSH
75022: LD_INT 0
75024: PUSH
75025: EMPTY
75026: LIST
75027: LIST
75028: PUSH
75029: LD_INT 4
75031: NEG
75032: PUSH
75033: LD_INT 1
75035: NEG
75036: PUSH
75037: EMPTY
75038: LIST
75039: LIST
75040: PUSH
75041: LD_INT 3
75043: NEG
75044: PUSH
75045: LD_INT 0
75047: PUSH
75048: EMPTY
75049: LIST
75050: LIST
75051: PUSH
75052: LD_INT 3
75054: NEG
75055: PUSH
75056: LD_INT 1
75058: PUSH
75059: EMPTY
75060: LIST
75061: LIST
75062: PUSH
75063: LD_INT 4
75065: NEG
75066: PUSH
75067: LD_INT 1
75069: PUSH
75070: EMPTY
75071: LIST
75072: LIST
75073: PUSH
75074: LD_INT 5
75076: NEG
75077: PUSH
75078: LD_INT 0
75080: PUSH
75081: EMPTY
75082: LIST
75083: LIST
75084: PUSH
75085: LD_INT 5
75087: NEG
75088: PUSH
75089: LD_INT 1
75091: NEG
75092: PUSH
75093: EMPTY
75094: LIST
75095: LIST
75096: PUSH
75097: LD_INT 5
75099: NEG
75100: PUSH
75101: LD_INT 2
75103: NEG
75104: PUSH
75105: EMPTY
75106: LIST
75107: LIST
75108: PUSH
75109: LD_INT 3
75111: NEG
75112: PUSH
75113: LD_INT 2
75115: PUSH
75116: EMPTY
75117: LIST
75118: LIST
75119: PUSH
75120: LD_INT 3
75122: NEG
75123: PUSH
75124: LD_INT 3
75126: NEG
75127: PUSH
75128: EMPTY
75129: LIST
75130: LIST
75131: PUSH
75132: LD_INT 3
75134: NEG
75135: PUSH
75136: LD_INT 4
75138: NEG
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: PUSH
75144: LD_INT 2
75146: NEG
75147: PUSH
75148: LD_INT 3
75150: NEG
75151: PUSH
75152: EMPTY
75153: LIST
75154: LIST
75155: PUSH
75156: LD_INT 2
75158: NEG
75159: PUSH
75160: LD_INT 2
75162: NEG
75163: PUSH
75164: EMPTY
75165: LIST
75166: LIST
75167: PUSH
75168: LD_INT 3
75170: NEG
75171: PUSH
75172: LD_INT 2
75174: NEG
75175: PUSH
75176: EMPTY
75177: LIST
75178: LIST
75179: PUSH
75180: LD_INT 4
75182: NEG
75183: PUSH
75184: LD_INT 3
75186: NEG
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: PUSH
75192: LD_INT 4
75194: NEG
75195: PUSH
75196: LD_INT 4
75198: NEG
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: PUSH
75204: LD_INT 2
75206: NEG
75207: PUSH
75208: LD_INT 4
75210: NEG
75211: PUSH
75212: EMPTY
75213: LIST
75214: LIST
75215: PUSH
75216: LD_INT 4
75218: NEG
75219: PUSH
75220: LD_INT 2
75222: NEG
75223: PUSH
75224: EMPTY
75225: LIST
75226: LIST
75227: PUSH
75228: LD_INT 0
75230: PUSH
75231: LD_INT 4
75233: NEG
75234: PUSH
75235: EMPTY
75236: LIST
75237: LIST
75238: PUSH
75239: LD_INT 0
75241: PUSH
75242: LD_INT 5
75244: NEG
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PUSH
75250: LD_INT 1
75252: PUSH
75253: LD_INT 4
75255: NEG
75256: PUSH
75257: EMPTY
75258: LIST
75259: LIST
75260: PUSH
75261: LD_INT 1
75263: PUSH
75264: LD_INT 3
75266: NEG
75267: PUSH
75268: EMPTY
75269: LIST
75270: LIST
75271: PUSH
75272: LD_INT 0
75274: PUSH
75275: LD_INT 3
75277: NEG
75278: PUSH
75279: EMPTY
75280: LIST
75281: LIST
75282: PUSH
75283: LD_INT 1
75285: NEG
75286: PUSH
75287: LD_INT 4
75289: NEG
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: PUSH
75295: LD_INT 1
75297: NEG
75298: PUSH
75299: LD_INT 5
75301: NEG
75302: PUSH
75303: EMPTY
75304: LIST
75305: LIST
75306: PUSH
75307: LD_INT 2
75309: PUSH
75310: LD_INT 3
75312: NEG
75313: PUSH
75314: EMPTY
75315: LIST
75316: LIST
75317: PUSH
75318: LD_INT 2
75320: NEG
75321: PUSH
75322: LD_INT 5
75324: NEG
75325: PUSH
75326: EMPTY
75327: LIST
75328: LIST
75329: PUSH
75330: LD_INT 3
75332: PUSH
75333: LD_INT 0
75335: PUSH
75336: EMPTY
75337: LIST
75338: LIST
75339: PUSH
75340: LD_INT 3
75342: PUSH
75343: LD_INT 1
75345: NEG
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: PUSH
75351: LD_INT 4
75353: PUSH
75354: LD_INT 0
75356: PUSH
75357: EMPTY
75358: LIST
75359: LIST
75360: PUSH
75361: LD_INT 4
75363: PUSH
75364: LD_INT 1
75366: PUSH
75367: EMPTY
75368: LIST
75369: LIST
75370: PUSH
75371: LD_INT 3
75373: PUSH
75374: LD_INT 1
75376: PUSH
75377: EMPTY
75378: LIST
75379: LIST
75380: PUSH
75381: LD_INT 2
75383: PUSH
75384: LD_INT 0
75386: PUSH
75387: EMPTY
75388: LIST
75389: LIST
75390: PUSH
75391: LD_INT 2
75393: PUSH
75394: LD_INT 1
75396: NEG
75397: PUSH
75398: EMPTY
75399: LIST
75400: LIST
75401: PUSH
75402: LD_INT 2
75404: PUSH
75405: LD_INT 2
75407: NEG
75408: PUSH
75409: EMPTY
75410: LIST
75411: LIST
75412: PUSH
75413: LD_INT 4
75415: PUSH
75416: LD_INT 2
75418: PUSH
75419: EMPTY
75420: LIST
75421: LIST
75422: PUSH
75423: LD_INT 4
75425: PUSH
75426: LD_INT 4
75428: PUSH
75429: EMPTY
75430: LIST
75431: LIST
75432: PUSH
75433: LD_INT 4
75435: PUSH
75436: LD_INT 3
75438: PUSH
75439: EMPTY
75440: LIST
75441: LIST
75442: PUSH
75443: LD_INT 5
75445: PUSH
75446: LD_INT 4
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: PUSH
75453: LD_INT 5
75455: PUSH
75456: LD_INT 5
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: LD_INT 4
75465: PUSH
75466: LD_INT 5
75468: PUSH
75469: EMPTY
75470: LIST
75471: LIST
75472: PUSH
75473: LD_INT 3
75475: PUSH
75476: LD_INT 4
75478: PUSH
75479: EMPTY
75480: LIST
75481: LIST
75482: PUSH
75483: LD_INT 3
75485: PUSH
75486: LD_INT 3
75488: PUSH
75489: EMPTY
75490: LIST
75491: LIST
75492: PUSH
75493: LD_INT 5
75495: PUSH
75496: LD_INT 3
75498: PUSH
75499: EMPTY
75500: LIST
75501: LIST
75502: PUSH
75503: LD_INT 3
75505: PUSH
75506: LD_INT 5
75508: PUSH
75509: EMPTY
75510: LIST
75511: LIST
75512: PUSH
75513: EMPTY
75514: LIST
75515: LIST
75516: LIST
75517: LIST
75518: LIST
75519: LIST
75520: LIST
75521: LIST
75522: LIST
75523: LIST
75524: LIST
75525: LIST
75526: LIST
75527: LIST
75528: LIST
75529: LIST
75530: LIST
75531: LIST
75532: LIST
75533: LIST
75534: LIST
75535: LIST
75536: LIST
75537: LIST
75538: LIST
75539: LIST
75540: LIST
75541: LIST
75542: LIST
75543: LIST
75544: LIST
75545: LIST
75546: LIST
75547: LIST
75548: LIST
75549: LIST
75550: LIST
75551: LIST
75552: LIST
75553: LIST
75554: LIST
75555: LIST
75556: LIST
75557: LIST
75558: LIST
75559: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
75560: LD_ADDR_VAR 0 33
75564: PUSH
75565: LD_INT 4
75567: NEG
75568: PUSH
75569: LD_INT 4
75571: NEG
75572: PUSH
75573: EMPTY
75574: LIST
75575: LIST
75576: PUSH
75577: LD_INT 4
75579: NEG
75580: PUSH
75581: LD_INT 5
75583: NEG
75584: PUSH
75585: EMPTY
75586: LIST
75587: LIST
75588: PUSH
75589: LD_INT 3
75591: NEG
75592: PUSH
75593: LD_INT 4
75595: NEG
75596: PUSH
75597: EMPTY
75598: LIST
75599: LIST
75600: PUSH
75601: LD_INT 3
75603: NEG
75604: PUSH
75605: LD_INT 3
75607: NEG
75608: PUSH
75609: EMPTY
75610: LIST
75611: LIST
75612: PUSH
75613: LD_INT 4
75615: NEG
75616: PUSH
75617: LD_INT 3
75619: NEG
75620: PUSH
75621: EMPTY
75622: LIST
75623: LIST
75624: PUSH
75625: LD_INT 5
75627: NEG
75628: PUSH
75629: LD_INT 4
75631: NEG
75632: PUSH
75633: EMPTY
75634: LIST
75635: LIST
75636: PUSH
75637: LD_INT 5
75639: NEG
75640: PUSH
75641: LD_INT 5
75643: NEG
75644: PUSH
75645: EMPTY
75646: LIST
75647: LIST
75648: PUSH
75649: LD_INT 3
75651: NEG
75652: PUSH
75653: LD_INT 5
75655: NEG
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: PUSH
75661: LD_INT 5
75663: NEG
75664: PUSH
75665: LD_INT 3
75667: NEG
75668: PUSH
75669: EMPTY
75670: LIST
75671: LIST
75672: PUSH
75673: LD_INT 0
75675: PUSH
75676: LD_INT 3
75678: NEG
75679: PUSH
75680: EMPTY
75681: LIST
75682: LIST
75683: PUSH
75684: LD_INT 0
75686: PUSH
75687: LD_INT 4
75689: NEG
75690: PUSH
75691: EMPTY
75692: LIST
75693: LIST
75694: PUSH
75695: LD_INT 1
75697: PUSH
75698: LD_INT 3
75700: NEG
75701: PUSH
75702: EMPTY
75703: LIST
75704: LIST
75705: PUSH
75706: LD_INT 1
75708: PUSH
75709: LD_INT 2
75711: NEG
75712: PUSH
75713: EMPTY
75714: LIST
75715: LIST
75716: PUSH
75717: LD_INT 0
75719: PUSH
75720: LD_INT 2
75722: NEG
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: PUSH
75728: LD_INT 1
75730: NEG
75731: PUSH
75732: LD_INT 3
75734: NEG
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 1
75742: NEG
75743: PUSH
75744: LD_INT 4
75746: NEG
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: LD_INT 2
75754: PUSH
75755: LD_INT 2
75757: NEG
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: PUSH
75763: LD_INT 2
75765: NEG
75766: PUSH
75767: LD_INT 4
75769: NEG
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 4
75777: PUSH
75778: LD_INT 0
75780: PUSH
75781: EMPTY
75782: LIST
75783: LIST
75784: PUSH
75785: LD_INT 4
75787: PUSH
75788: LD_INT 1
75790: NEG
75791: PUSH
75792: EMPTY
75793: LIST
75794: LIST
75795: PUSH
75796: LD_INT 5
75798: PUSH
75799: LD_INT 0
75801: PUSH
75802: EMPTY
75803: LIST
75804: LIST
75805: PUSH
75806: LD_INT 5
75808: PUSH
75809: LD_INT 1
75811: PUSH
75812: EMPTY
75813: LIST
75814: LIST
75815: PUSH
75816: LD_INT 4
75818: PUSH
75819: LD_INT 1
75821: PUSH
75822: EMPTY
75823: LIST
75824: LIST
75825: PUSH
75826: LD_INT 3
75828: PUSH
75829: LD_INT 0
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: PUSH
75836: LD_INT 3
75838: PUSH
75839: LD_INT 1
75841: NEG
75842: PUSH
75843: EMPTY
75844: LIST
75845: LIST
75846: PUSH
75847: LD_INT 3
75849: PUSH
75850: LD_INT 2
75852: NEG
75853: PUSH
75854: EMPTY
75855: LIST
75856: LIST
75857: PUSH
75858: LD_INT 5
75860: PUSH
75861: LD_INT 2
75863: PUSH
75864: EMPTY
75865: LIST
75866: LIST
75867: PUSH
75868: LD_INT 3
75870: PUSH
75871: LD_INT 3
75873: PUSH
75874: EMPTY
75875: LIST
75876: LIST
75877: PUSH
75878: LD_INT 3
75880: PUSH
75881: LD_INT 2
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: PUSH
75888: LD_INT 4
75890: PUSH
75891: LD_INT 3
75893: PUSH
75894: EMPTY
75895: LIST
75896: LIST
75897: PUSH
75898: LD_INT 4
75900: PUSH
75901: LD_INT 4
75903: PUSH
75904: EMPTY
75905: LIST
75906: LIST
75907: PUSH
75908: LD_INT 3
75910: PUSH
75911: LD_INT 4
75913: PUSH
75914: EMPTY
75915: LIST
75916: LIST
75917: PUSH
75918: LD_INT 2
75920: PUSH
75921: LD_INT 3
75923: PUSH
75924: EMPTY
75925: LIST
75926: LIST
75927: PUSH
75928: LD_INT 2
75930: PUSH
75931: LD_INT 2
75933: PUSH
75934: EMPTY
75935: LIST
75936: LIST
75937: PUSH
75938: LD_INT 4
75940: PUSH
75941: LD_INT 2
75943: PUSH
75944: EMPTY
75945: LIST
75946: LIST
75947: PUSH
75948: LD_INT 2
75950: PUSH
75951: LD_INT 4
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: PUSH
75958: LD_INT 0
75960: PUSH
75961: LD_INT 4
75963: PUSH
75964: EMPTY
75965: LIST
75966: LIST
75967: PUSH
75968: LD_INT 0
75970: PUSH
75971: LD_INT 3
75973: PUSH
75974: EMPTY
75975: LIST
75976: LIST
75977: PUSH
75978: LD_INT 1
75980: PUSH
75981: LD_INT 4
75983: PUSH
75984: EMPTY
75985: LIST
75986: LIST
75987: PUSH
75988: LD_INT 1
75990: PUSH
75991: LD_INT 5
75993: PUSH
75994: EMPTY
75995: LIST
75996: LIST
75997: PUSH
75998: LD_INT 0
76000: PUSH
76001: LD_INT 5
76003: PUSH
76004: EMPTY
76005: LIST
76006: LIST
76007: PUSH
76008: LD_INT 1
76010: NEG
76011: PUSH
76012: LD_INT 4
76014: PUSH
76015: EMPTY
76016: LIST
76017: LIST
76018: PUSH
76019: LD_INT 1
76021: NEG
76022: PUSH
76023: LD_INT 3
76025: PUSH
76026: EMPTY
76027: LIST
76028: LIST
76029: PUSH
76030: LD_INT 2
76032: PUSH
76033: LD_INT 5
76035: PUSH
76036: EMPTY
76037: LIST
76038: LIST
76039: PUSH
76040: LD_INT 2
76042: NEG
76043: PUSH
76044: LD_INT 3
76046: PUSH
76047: EMPTY
76048: LIST
76049: LIST
76050: PUSH
76051: EMPTY
76052: LIST
76053: LIST
76054: LIST
76055: LIST
76056: LIST
76057: LIST
76058: LIST
76059: LIST
76060: LIST
76061: LIST
76062: LIST
76063: LIST
76064: LIST
76065: LIST
76066: LIST
76067: LIST
76068: LIST
76069: LIST
76070: LIST
76071: LIST
76072: LIST
76073: LIST
76074: LIST
76075: LIST
76076: LIST
76077: LIST
76078: LIST
76079: LIST
76080: LIST
76081: LIST
76082: LIST
76083: LIST
76084: LIST
76085: LIST
76086: LIST
76087: LIST
76088: LIST
76089: LIST
76090: LIST
76091: LIST
76092: LIST
76093: LIST
76094: LIST
76095: LIST
76096: LIST
76097: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
76098: LD_ADDR_VAR 0 34
76102: PUSH
76103: LD_INT 0
76105: PUSH
76106: LD_INT 4
76108: NEG
76109: PUSH
76110: EMPTY
76111: LIST
76112: LIST
76113: PUSH
76114: LD_INT 0
76116: PUSH
76117: LD_INT 5
76119: NEG
76120: PUSH
76121: EMPTY
76122: LIST
76123: LIST
76124: PUSH
76125: LD_INT 1
76127: PUSH
76128: LD_INT 4
76130: NEG
76131: PUSH
76132: EMPTY
76133: LIST
76134: LIST
76135: PUSH
76136: LD_INT 1
76138: PUSH
76139: LD_INT 3
76141: NEG
76142: PUSH
76143: EMPTY
76144: LIST
76145: LIST
76146: PUSH
76147: LD_INT 0
76149: PUSH
76150: LD_INT 3
76152: NEG
76153: PUSH
76154: EMPTY
76155: LIST
76156: LIST
76157: PUSH
76158: LD_INT 1
76160: NEG
76161: PUSH
76162: LD_INT 4
76164: NEG
76165: PUSH
76166: EMPTY
76167: LIST
76168: LIST
76169: PUSH
76170: LD_INT 1
76172: NEG
76173: PUSH
76174: LD_INT 5
76176: NEG
76177: PUSH
76178: EMPTY
76179: LIST
76180: LIST
76181: PUSH
76182: LD_INT 2
76184: PUSH
76185: LD_INT 3
76187: NEG
76188: PUSH
76189: EMPTY
76190: LIST
76191: LIST
76192: PUSH
76193: LD_INT 2
76195: NEG
76196: PUSH
76197: LD_INT 5
76199: NEG
76200: PUSH
76201: EMPTY
76202: LIST
76203: LIST
76204: PUSH
76205: LD_INT 3
76207: PUSH
76208: LD_INT 0
76210: PUSH
76211: EMPTY
76212: LIST
76213: LIST
76214: PUSH
76215: LD_INT 3
76217: PUSH
76218: LD_INT 1
76220: NEG
76221: PUSH
76222: EMPTY
76223: LIST
76224: LIST
76225: PUSH
76226: LD_INT 4
76228: PUSH
76229: LD_INT 0
76231: PUSH
76232: EMPTY
76233: LIST
76234: LIST
76235: PUSH
76236: LD_INT 4
76238: PUSH
76239: LD_INT 1
76241: PUSH
76242: EMPTY
76243: LIST
76244: LIST
76245: PUSH
76246: LD_INT 3
76248: PUSH
76249: LD_INT 1
76251: PUSH
76252: EMPTY
76253: LIST
76254: LIST
76255: PUSH
76256: LD_INT 2
76258: PUSH
76259: LD_INT 0
76261: PUSH
76262: EMPTY
76263: LIST
76264: LIST
76265: PUSH
76266: LD_INT 2
76268: PUSH
76269: LD_INT 1
76271: NEG
76272: PUSH
76273: EMPTY
76274: LIST
76275: LIST
76276: PUSH
76277: LD_INT 2
76279: PUSH
76280: LD_INT 2
76282: NEG
76283: PUSH
76284: EMPTY
76285: LIST
76286: LIST
76287: PUSH
76288: LD_INT 4
76290: PUSH
76291: LD_INT 2
76293: PUSH
76294: EMPTY
76295: LIST
76296: LIST
76297: PUSH
76298: LD_INT 4
76300: PUSH
76301: LD_INT 4
76303: PUSH
76304: EMPTY
76305: LIST
76306: LIST
76307: PUSH
76308: LD_INT 4
76310: PUSH
76311: LD_INT 3
76313: PUSH
76314: EMPTY
76315: LIST
76316: LIST
76317: PUSH
76318: LD_INT 5
76320: PUSH
76321: LD_INT 4
76323: PUSH
76324: EMPTY
76325: LIST
76326: LIST
76327: PUSH
76328: LD_INT 5
76330: PUSH
76331: LD_INT 5
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: PUSH
76338: LD_INT 4
76340: PUSH
76341: LD_INT 5
76343: PUSH
76344: EMPTY
76345: LIST
76346: LIST
76347: PUSH
76348: LD_INT 3
76350: PUSH
76351: LD_INT 4
76353: PUSH
76354: EMPTY
76355: LIST
76356: LIST
76357: PUSH
76358: LD_INT 3
76360: PUSH
76361: LD_INT 3
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: PUSH
76368: LD_INT 5
76370: PUSH
76371: LD_INT 3
76373: PUSH
76374: EMPTY
76375: LIST
76376: LIST
76377: PUSH
76378: LD_INT 3
76380: PUSH
76381: LD_INT 5
76383: PUSH
76384: EMPTY
76385: LIST
76386: LIST
76387: PUSH
76388: LD_INT 0
76390: PUSH
76391: LD_INT 3
76393: PUSH
76394: EMPTY
76395: LIST
76396: LIST
76397: PUSH
76398: LD_INT 0
76400: PUSH
76401: LD_INT 2
76403: PUSH
76404: EMPTY
76405: LIST
76406: LIST
76407: PUSH
76408: LD_INT 1
76410: PUSH
76411: LD_INT 3
76413: PUSH
76414: EMPTY
76415: LIST
76416: LIST
76417: PUSH
76418: LD_INT 1
76420: PUSH
76421: LD_INT 4
76423: PUSH
76424: EMPTY
76425: LIST
76426: LIST
76427: PUSH
76428: LD_INT 0
76430: PUSH
76431: LD_INT 4
76433: PUSH
76434: EMPTY
76435: LIST
76436: LIST
76437: PUSH
76438: LD_INT 1
76440: NEG
76441: PUSH
76442: LD_INT 3
76444: PUSH
76445: EMPTY
76446: LIST
76447: LIST
76448: PUSH
76449: LD_INT 1
76451: NEG
76452: PUSH
76453: LD_INT 2
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 2
76462: PUSH
76463: LD_INT 4
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: PUSH
76470: LD_INT 2
76472: NEG
76473: PUSH
76474: LD_INT 2
76476: PUSH
76477: EMPTY
76478: LIST
76479: LIST
76480: PUSH
76481: LD_INT 4
76483: NEG
76484: PUSH
76485: LD_INT 0
76487: PUSH
76488: EMPTY
76489: LIST
76490: LIST
76491: PUSH
76492: LD_INT 4
76494: NEG
76495: PUSH
76496: LD_INT 1
76498: NEG
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: PUSH
76504: LD_INT 3
76506: NEG
76507: PUSH
76508: LD_INT 0
76510: PUSH
76511: EMPTY
76512: LIST
76513: LIST
76514: PUSH
76515: LD_INT 3
76517: NEG
76518: PUSH
76519: LD_INT 1
76521: PUSH
76522: EMPTY
76523: LIST
76524: LIST
76525: PUSH
76526: LD_INT 4
76528: NEG
76529: PUSH
76530: LD_INT 1
76532: PUSH
76533: EMPTY
76534: LIST
76535: LIST
76536: PUSH
76537: LD_INT 5
76539: NEG
76540: PUSH
76541: LD_INT 0
76543: PUSH
76544: EMPTY
76545: LIST
76546: LIST
76547: PUSH
76548: LD_INT 5
76550: NEG
76551: PUSH
76552: LD_INT 1
76554: NEG
76555: PUSH
76556: EMPTY
76557: LIST
76558: LIST
76559: PUSH
76560: LD_INT 5
76562: NEG
76563: PUSH
76564: LD_INT 2
76566: NEG
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: PUSH
76572: LD_INT 3
76574: NEG
76575: PUSH
76576: LD_INT 2
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: PUSH
76583: EMPTY
76584: LIST
76585: LIST
76586: LIST
76587: LIST
76588: LIST
76589: LIST
76590: LIST
76591: LIST
76592: LIST
76593: LIST
76594: LIST
76595: LIST
76596: LIST
76597: LIST
76598: LIST
76599: LIST
76600: LIST
76601: LIST
76602: LIST
76603: LIST
76604: LIST
76605: LIST
76606: LIST
76607: LIST
76608: LIST
76609: LIST
76610: LIST
76611: LIST
76612: LIST
76613: LIST
76614: LIST
76615: LIST
76616: LIST
76617: LIST
76618: LIST
76619: LIST
76620: LIST
76621: LIST
76622: LIST
76623: LIST
76624: LIST
76625: LIST
76626: LIST
76627: LIST
76628: LIST
76629: ST_TO_ADDR
// end ; end ;
76630: GO 76633
76632: POP
// case btype of b_depot , b_warehouse :
76633: LD_VAR 0 1
76637: PUSH
76638: LD_INT 0
76640: DOUBLE
76641: EQUAL
76642: IFTRUE 76652
76644: LD_INT 1
76646: DOUBLE
76647: EQUAL
76648: IFTRUE 76652
76650: GO 76853
76652: POP
// case nation of nation_american :
76653: LD_VAR 0 5
76657: PUSH
76658: LD_INT 1
76660: DOUBLE
76661: EQUAL
76662: IFTRUE 76666
76664: GO 76722
76666: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
76667: LD_ADDR_VAR 0 9
76671: PUSH
76672: LD_VAR 0 11
76676: PUSH
76677: LD_VAR 0 12
76681: PUSH
76682: LD_VAR 0 13
76686: PUSH
76687: LD_VAR 0 14
76691: PUSH
76692: LD_VAR 0 15
76696: PUSH
76697: LD_VAR 0 16
76701: PUSH
76702: EMPTY
76703: LIST
76704: LIST
76705: LIST
76706: LIST
76707: LIST
76708: LIST
76709: PUSH
76710: LD_VAR 0 4
76714: PUSH
76715: LD_INT 1
76717: PLUS
76718: ARRAY
76719: ST_TO_ADDR
76720: GO 76851
76722: LD_INT 2
76724: DOUBLE
76725: EQUAL
76726: IFTRUE 76730
76728: GO 76786
76730: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
76731: LD_ADDR_VAR 0 9
76735: PUSH
76736: LD_VAR 0 17
76740: PUSH
76741: LD_VAR 0 18
76745: PUSH
76746: LD_VAR 0 19
76750: PUSH
76751: LD_VAR 0 20
76755: PUSH
76756: LD_VAR 0 21
76760: PUSH
76761: LD_VAR 0 22
76765: PUSH
76766: EMPTY
76767: LIST
76768: LIST
76769: LIST
76770: LIST
76771: LIST
76772: LIST
76773: PUSH
76774: LD_VAR 0 4
76778: PUSH
76779: LD_INT 1
76781: PLUS
76782: ARRAY
76783: ST_TO_ADDR
76784: GO 76851
76786: LD_INT 3
76788: DOUBLE
76789: EQUAL
76790: IFTRUE 76794
76792: GO 76850
76794: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
76795: LD_ADDR_VAR 0 9
76799: PUSH
76800: LD_VAR 0 23
76804: PUSH
76805: LD_VAR 0 24
76809: PUSH
76810: LD_VAR 0 25
76814: PUSH
76815: LD_VAR 0 26
76819: PUSH
76820: LD_VAR 0 27
76824: PUSH
76825: LD_VAR 0 28
76829: PUSH
76830: EMPTY
76831: LIST
76832: LIST
76833: LIST
76834: LIST
76835: LIST
76836: LIST
76837: PUSH
76838: LD_VAR 0 4
76842: PUSH
76843: LD_INT 1
76845: PLUS
76846: ARRAY
76847: ST_TO_ADDR
76848: GO 76851
76850: POP
76851: GO 77400
76853: LD_INT 2
76855: DOUBLE
76856: EQUAL
76857: IFTRUE 76867
76859: LD_INT 3
76861: DOUBLE
76862: EQUAL
76863: IFTRUE 76867
76865: GO 76923
76867: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
76868: LD_ADDR_VAR 0 9
76872: PUSH
76873: LD_VAR 0 29
76877: PUSH
76878: LD_VAR 0 30
76882: PUSH
76883: LD_VAR 0 31
76887: PUSH
76888: LD_VAR 0 32
76892: PUSH
76893: LD_VAR 0 33
76897: PUSH
76898: LD_VAR 0 34
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: LIST
76907: LIST
76908: LIST
76909: LIST
76910: PUSH
76911: LD_VAR 0 4
76915: PUSH
76916: LD_INT 1
76918: PLUS
76919: ARRAY
76920: ST_TO_ADDR
76921: GO 77400
76923: LD_INT 16
76925: DOUBLE
76926: EQUAL
76927: IFTRUE 76979
76929: LD_INT 17
76931: DOUBLE
76932: EQUAL
76933: IFTRUE 76979
76935: LD_INT 18
76937: DOUBLE
76938: EQUAL
76939: IFTRUE 76979
76941: LD_INT 19
76943: DOUBLE
76944: EQUAL
76945: IFTRUE 76979
76947: LD_INT 20
76949: DOUBLE
76950: EQUAL
76951: IFTRUE 76979
76953: LD_INT 21
76955: DOUBLE
76956: EQUAL
76957: IFTRUE 76979
76959: LD_INT 23
76961: DOUBLE
76962: EQUAL
76963: IFTRUE 76979
76965: LD_INT 24
76967: DOUBLE
76968: EQUAL
76969: IFTRUE 76979
76971: LD_INT 25
76973: DOUBLE
76974: EQUAL
76975: IFTRUE 76979
76977: GO 77035
76979: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
76980: LD_ADDR_VAR 0 9
76984: PUSH
76985: LD_VAR 0 35
76989: PUSH
76990: LD_VAR 0 36
76994: PUSH
76995: LD_VAR 0 37
76999: PUSH
77000: LD_VAR 0 38
77004: PUSH
77005: LD_VAR 0 39
77009: PUSH
77010: LD_VAR 0 40
77014: PUSH
77015: EMPTY
77016: LIST
77017: LIST
77018: LIST
77019: LIST
77020: LIST
77021: LIST
77022: PUSH
77023: LD_VAR 0 4
77027: PUSH
77028: LD_INT 1
77030: PLUS
77031: ARRAY
77032: ST_TO_ADDR
77033: GO 77400
77035: LD_INT 6
77037: DOUBLE
77038: EQUAL
77039: IFTRUE 77091
77041: LD_INT 7
77043: DOUBLE
77044: EQUAL
77045: IFTRUE 77091
77047: LD_INT 8
77049: DOUBLE
77050: EQUAL
77051: IFTRUE 77091
77053: LD_INT 13
77055: DOUBLE
77056: EQUAL
77057: IFTRUE 77091
77059: LD_INT 12
77061: DOUBLE
77062: EQUAL
77063: IFTRUE 77091
77065: LD_INT 15
77067: DOUBLE
77068: EQUAL
77069: IFTRUE 77091
77071: LD_INT 11
77073: DOUBLE
77074: EQUAL
77075: IFTRUE 77091
77077: LD_INT 14
77079: DOUBLE
77080: EQUAL
77081: IFTRUE 77091
77083: LD_INT 10
77085: DOUBLE
77086: EQUAL
77087: IFTRUE 77091
77089: GO 77147
77091: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
77092: LD_ADDR_VAR 0 9
77096: PUSH
77097: LD_VAR 0 41
77101: PUSH
77102: LD_VAR 0 42
77106: PUSH
77107: LD_VAR 0 43
77111: PUSH
77112: LD_VAR 0 44
77116: PUSH
77117: LD_VAR 0 45
77121: PUSH
77122: LD_VAR 0 46
77126: PUSH
77127: EMPTY
77128: LIST
77129: LIST
77130: LIST
77131: LIST
77132: LIST
77133: LIST
77134: PUSH
77135: LD_VAR 0 4
77139: PUSH
77140: LD_INT 1
77142: PLUS
77143: ARRAY
77144: ST_TO_ADDR
77145: GO 77400
77147: LD_INT 36
77149: DOUBLE
77150: EQUAL
77151: IFTRUE 77155
77153: GO 77211
77155: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
77156: LD_ADDR_VAR 0 9
77160: PUSH
77161: LD_VAR 0 47
77165: PUSH
77166: LD_VAR 0 48
77170: PUSH
77171: LD_VAR 0 49
77175: PUSH
77176: LD_VAR 0 50
77180: PUSH
77181: LD_VAR 0 51
77185: PUSH
77186: LD_VAR 0 52
77190: PUSH
77191: EMPTY
77192: LIST
77193: LIST
77194: LIST
77195: LIST
77196: LIST
77197: LIST
77198: PUSH
77199: LD_VAR 0 4
77203: PUSH
77204: LD_INT 1
77206: PLUS
77207: ARRAY
77208: ST_TO_ADDR
77209: GO 77400
77211: LD_INT 4
77213: DOUBLE
77214: EQUAL
77215: IFTRUE 77237
77217: LD_INT 5
77219: DOUBLE
77220: EQUAL
77221: IFTRUE 77237
77223: LD_INT 34
77225: DOUBLE
77226: EQUAL
77227: IFTRUE 77237
77229: LD_INT 37
77231: DOUBLE
77232: EQUAL
77233: IFTRUE 77237
77235: GO 77293
77237: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
77238: LD_ADDR_VAR 0 9
77242: PUSH
77243: LD_VAR 0 53
77247: PUSH
77248: LD_VAR 0 54
77252: PUSH
77253: LD_VAR 0 55
77257: PUSH
77258: LD_VAR 0 56
77262: PUSH
77263: LD_VAR 0 57
77267: PUSH
77268: LD_VAR 0 58
77272: PUSH
77273: EMPTY
77274: LIST
77275: LIST
77276: LIST
77277: LIST
77278: LIST
77279: LIST
77280: PUSH
77281: LD_VAR 0 4
77285: PUSH
77286: LD_INT 1
77288: PLUS
77289: ARRAY
77290: ST_TO_ADDR
77291: GO 77400
77293: LD_INT 31
77295: DOUBLE
77296: EQUAL
77297: IFTRUE 77343
77299: LD_INT 32
77301: DOUBLE
77302: EQUAL
77303: IFTRUE 77343
77305: LD_INT 33
77307: DOUBLE
77308: EQUAL
77309: IFTRUE 77343
77311: LD_INT 27
77313: DOUBLE
77314: EQUAL
77315: IFTRUE 77343
77317: LD_INT 26
77319: DOUBLE
77320: EQUAL
77321: IFTRUE 77343
77323: LD_INT 28
77325: DOUBLE
77326: EQUAL
77327: IFTRUE 77343
77329: LD_INT 29
77331: DOUBLE
77332: EQUAL
77333: IFTRUE 77343
77335: LD_INT 30
77337: DOUBLE
77338: EQUAL
77339: IFTRUE 77343
77341: GO 77399
77343: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
77344: LD_ADDR_VAR 0 9
77348: PUSH
77349: LD_VAR 0 59
77353: PUSH
77354: LD_VAR 0 60
77358: PUSH
77359: LD_VAR 0 61
77363: PUSH
77364: LD_VAR 0 62
77368: PUSH
77369: LD_VAR 0 63
77373: PUSH
77374: LD_VAR 0 64
77378: PUSH
77379: EMPTY
77380: LIST
77381: LIST
77382: LIST
77383: LIST
77384: LIST
77385: LIST
77386: PUSH
77387: LD_VAR 0 4
77391: PUSH
77392: LD_INT 1
77394: PLUS
77395: ARRAY
77396: ST_TO_ADDR
77397: GO 77400
77399: POP
// temp_list2 = [ ] ;
77400: LD_ADDR_VAR 0 10
77404: PUSH
77405: EMPTY
77406: ST_TO_ADDR
// for i in temp_list do
77407: LD_ADDR_VAR 0 8
77411: PUSH
77412: LD_VAR 0 9
77416: PUSH
77417: FOR_IN
77418: IFFALSE 77470
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
77420: LD_ADDR_VAR 0 10
77424: PUSH
77425: LD_VAR 0 10
77429: PUSH
77430: LD_VAR 0 8
77434: PUSH
77435: LD_INT 1
77437: ARRAY
77438: PUSH
77439: LD_VAR 0 2
77443: PLUS
77444: PUSH
77445: LD_VAR 0 8
77449: PUSH
77450: LD_INT 2
77452: ARRAY
77453: PUSH
77454: LD_VAR 0 3
77458: PLUS
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: PUSH
77464: EMPTY
77465: LIST
77466: ADD
77467: ST_TO_ADDR
77468: GO 77417
77470: POP
77471: POP
// result = temp_list2 ;
77472: LD_ADDR_VAR 0 7
77476: PUSH
77477: LD_VAR 0 10
77481: ST_TO_ADDR
// end ;
77482: LD_VAR 0 7
77486: RET
// export function EnemyInRange ( unit , dist ) ; begin
77487: LD_INT 0
77489: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
77490: LD_ADDR_VAR 0 3
77494: PUSH
77495: LD_VAR 0 1
77499: PPUSH
77500: CALL_OW 255
77504: PPUSH
77505: LD_VAR 0 1
77509: PPUSH
77510: CALL_OW 250
77514: PPUSH
77515: LD_VAR 0 1
77519: PPUSH
77520: CALL_OW 251
77524: PPUSH
77525: LD_VAR 0 2
77529: PPUSH
77530: CALL 51802 0 4
77534: PUSH
77535: LD_INT 4
77537: ARRAY
77538: ST_TO_ADDR
// end ;
77539: LD_VAR 0 3
77543: RET
// export function PlayerSeeMe ( unit ) ; begin
77544: LD_INT 0
77546: PPUSH
// result := See ( your_side , unit ) ;
77547: LD_ADDR_VAR 0 2
77551: PUSH
77552: LD_OWVAR 2
77556: PPUSH
77557: LD_VAR 0 1
77561: PPUSH
77562: CALL_OW 292
77566: ST_TO_ADDR
// end ;
77567: LD_VAR 0 2
77571: RET
// export function ReverseDir ( unit ) ; begin
77572: LD_INT 0
77574: PPUSH
// if not unit then
77575: LD_VAR 0 1
77579: NOT
77580: IFFALSE 77584
// exit ;
77582: GO 77630
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
77584: LD_ADDR_VAR 0 2
77588: PUSH
77589: LD_INT 3
77591: PUSH
77592: LD_INT 4
77594: PUSH
77595: LD_INT 5
77597: PUSH
77598: LD_INT 0
77600: PUSH
77601: LD_INT 1
77603: PUSH
77604: LD_INT 2
77606: PUSH
77607: EMPTY
77608: LIST
77609: LIST
77610: LIST
77611: LIST
77612: LIST
77613: LIST
77614: PUSH
77615: LD_VAR 0 1
77619: PPUSH
77620: CALL_OW 254
77624: PUSH
77625: LD_INT 1
77627: PLUS
77628: ARRAY
77629: ST_TO_ADDR
// end ;
77630: LD_VAR 0 2
77634: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
77635: LD_INT 0
77637: PPUSH
77638: PPUSH
77639: PPUSH
77640: PPUSH
77641: PPUSH
// if not hexes then
77642: LD_VAR 0 2
77646: NOT
77647: IFFALSE 77651
// exit ;
77649: GO 77799
// dist := 9999 ;
77651: LD_ADDR_VAR 0 5
77655: PUSH
77656: LD_INT 9999
77658: ST_TO_ADDR
// for i = 1 to hexes do
77659: LD_ADDR_VAR 0 4
77663: PUSH
77664: DOUBLE
77665: LD_INT 1
77667: DEC
77668: ST_TO_ADDR
77669: LD_VAR 0 2
77673: PUSH
77674: FOR_TO
77675: IFFALSE 77787
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
77677: LD_VAR 0 1
77681: PPUSH
77682: LD_VAR 0 2
77686: PUSH
77687: LD_VAR 0 4
77691: ARRAY
77692: PUSH
77693: LD_INT 1
77695: ARRAY
77696: PPUSH
77697: LD_VAR 0 2
77701: PUSH
77702: LD_VAR 0 4
77706: ARRAY
77707: PUSH
77708: LD_INT 2
77710: ARRAY
77711: PPUSH
77712: CALL_OW 297
77716: PUSH
77717: LD_VAR 0 5
77721: LESS
77722: IFFALSE 77785
// begin hex := hexes [ i ] ;
77724: LD_ADDR_VAR 0 7
77728: PUSH
77729: LD_VAR 0 2
77733: PUSH
77734: LD_VAR 0 4
77738: ARRAY
77739: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77740: LD_ADDR_VAR 0 5
77744: PUSH
77745: LD_VAR 0 1
77749: PPUSH
77750: LD_VAR 0 2
77754: PUSH
77755: LD_VAR 0 4
77759: ARRAY
77760: PUSH
77761: LD_INT 1
77763: ARRAY
77764: PPUSH
77765: LD_VAR 0 2
77769: PUSH
77770: LD_VAR 0 4
77774: ARRAY
77775: PUSH
77776: LD_INT 2
77778: ARRAY
77779: PPUSH
77780: CALL_OW 297
77784: ST_TO_ADDR
// end ; end ;
77785: GO 77674
77787: POP
77788: POP
// result := hex ;
77789: LD_ADDR_VAR 0 3
77793: PUSH
77794: LD_VAR 0 7
77798: ST_TO_ADDR
// end ;
77799: LD_VAR 0 3
77803: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
77804: LD_INT 0
77806: PPUSH
77807: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
77808: LD_VAR 0 1
77812: NOT
77813: PUSH
77814: LD_VAR 0 1
77818: PUSH
77819: LD_INT 21
77821: PUSH
77822: LD_INT 2
77824: PUSH
77825: EMPTY
77826: LIST
77827: LIST
77828: PUSH
77829: LD_INT 23
77831: PUSH
77832: LD_INT 2
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: PUSH
77839: EMPTY
77840: LIST
77841: LIST
77842: PPUSH
77843: CALL_OW 69
77847: IN
77848: NOT
77849: OR
77850: IFFALSE 77854
// exit ;
77852: GO 77901
// for i = 1 to 3 do
77854: LD_ADDR_VAR 0 3
77858: PUSH
77859: DOUBLE
77860: LD_INT 1
77862: DEC
77863: ST_TO_ADDR
77864: LD_INT 3
77866: PUSH
77867: FOR_TO
77868: IFFALSE 77899
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
77870: LD_VAR 0 1
77874: PPUSH
77875: CALL_OW 250
77879: PPUSH
77880: LD_VAR 0 1
77884: PPUSH
77885: CALL_OW 251
77889: PPUSH
77890: LD_INT 1
77892: PPUSH
77893: CALL_OW 453
77897: GO 77867
77899: POP
77900: POP
// end ;
77901: LD_VAR 0 2
77905: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
77906: LD_INT 0
77908: PPUSH
77909: PPUSH
77910: PPUSH
77911: PPUSH
77912: PPUSH
77913: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
77914: LD_VAR 0 1
77918: NOT
77919: PUSH
77920: LD_VAR 0 2
77924: NOT
77925: OR
77926: PUSH
77927: LD_VAR 0 1
77931: PPUSH
77932: CALL_OW 314
77936: OR
77937: IFFALSE 77941
// exit ;
77939: GO 78382
// x := GetX ( enemy_unit ) ;
77941: LD_ADDR_VAR 0 7
77945: PUSH
77946: LD_VAR 0 2
77950: PPUSH
77951: CALL_OW 250
77955: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
77956: LD_ADDR_VAR 0 8
77960: PUSH
77961: LD_VAR 0 2
77965: PPUSH
77966: CALL_OW 251
77970: ST_TO_ADDR
// if not x or not y then
77971: LD_VAR 0 7
77975: NOT
77976: PUSH
77977: LD_VAR 0 8
77981: NOT
77982: OR
77983: IFFALSE 77987
// exit ;
77985: GO 78382
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
77987: LD_ADDR_VAR 0 6
77991: PUSH
77992: LD_VAR 0 7
77996: PPUSH
77997: LD_INT 0
77999: PPUSH
78000: LD_INT 4
78002: PPUSH
78003: CALL_OW 272
78007: PUSH
78008: LD_VAR 0 8
78012: PPUSH
78013: LD_INT 0
78015: PPUSH
78016: LD_INT 4
78018: PPUSH
78019: CALL_OW 273
78023: PUSH
78024: EMPTY
78025: LIST
78026: LIST
78027: PUSH
78028: LD_VAR 0 7
78032: PPUSH
78033: LD_INT 1
78035: PPUSH
78036: LD_INT 4
78038: PPUSH
78039: CALL_OW 272
78043: PUSH
78044: LD_VAR 0 8
78048: PPUSH
78049: LD_INT 1
78051: PPUSH
78052: LD_INT 4
78054: PPUSH
78055: CALL_OW 273
78059: PUSH
78060: EMPTY
78061: LIST
78062: LIST
78063: PUSH
78064: LD_VAR 0 7
78068: PPUSH
78069: LD_INT 2
78071: PPUSH
78072: LD_INT 4
78074: PPUSH
78075: CALL_OW 272
78079: PUSH
78080: LD_VAR 0 8
78084: PPUSH
78085: LD_INT 2
78087: PPUSH
78088: LD_INT 4
78090: PPUSH
78091: CALL_OW 273
78095: PUSH
78096: EMPTY
78097: LIST
78098: LIST
78099: PUSH
78100: LD_VAR 0 7
78104: PPUSH
78105: LD_INT 3
78107: PPUSH
78108: LD_INT 4
78110: PPUSH
78111: CALL_OW 272
78115: PUSH
78116: LD_VAR 0 8
78120: PPUSH
78121: LD_INT 3
78123: PPUSH
78124: LD_INT 4
78126: PPUSH
78127: CALL_OW 273
78131: PUSH
78132: EMPTY
78133: LIST
78134: LIST
78135: PUSH
78136: LD_VAR 0 7
78140: PPUSH
78141: LD_INT 4
78143: PPUSH
78144: LD_INT 4
78146: PPUSH
78147: CALL_OW 272
78151: PUSH
78152: LD_VAR 0 8
78156: PPUSH
78157: LD_INT 4
78159: PPUSH
78160: LD_INT 4
78162: PPUSH
78163: CALL_OW 273
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: PUSH
78172: LD_VAR 0 7
78176: PPUSH
78177: LD_INT 5
78179: PPUSH
78180: LD_INT 4
78182: PPUSH
78183: CALL_OW 272
78187: PUSH
78188: LD_VAR 0 8
78192: PPUSH
78193: LD_INT 5
78195: PPUSH
78196: LD_INT 4
78198: PPUSH
78199: CALL_OW 273
78203: PUSH
78204: EMPTY
78205: LIST
78206: LIST
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: LIST
78212: LIST
78213: LIST
78214: LIST
78215: ST_TO_ADDR
// for i = tmp downto 1 do
78216: LD_ADDR_VAR 0 4
78220: PUSH
78221: DOUBLE
78222: LD_VAR 0 6
78226: INC
78227: ST_TO_ADDR
78228: LD_INT 1
78230: PUSH
78231: FOR_DOWNTO
78232: IFFALSE 78333
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
78234: LD_VAR 0 6
78238: PUSH
78239: LD_VAR 0 4
78243: ARRAY
78244: PUSH
78245: LD_INT 1
78247: ARRAY
78248: PPUSH
78249: LD_VAR 0 6
78253: PUSH
78254: LD_VAR 0 4
78258: ARRAY
78259: PUSH
78260: LD_INT 2
78262: ARRAY
78263: PPUSH
78264: CALL_OW 488
78268: NOT
78269: PUSH
78270: LD_VAR 0 6
78274: PUSH
78275: LD_VAR 0 4
78279: ARRAY
78280: PUSH
78281: LD_INT 1
78283: ARRAY
78284: PPUSH
78285: LD_VAR 0 6
78289: PUSH
78290: LD_VAR 0 4
78294: ARRAY
78295: PUSH
78296: LD_INT 2
78298: ARRAY
78299: PPUSH
78300: CALL_OW 428
78304: PUSH
78305: LD_INT 0
78307: NONEQUAL
78308: OR
78309: IFFALSE 78331
// tmp := Delete ( tmp , i ) ;
78311: LD_ADDR_VAR 0 6
78315: PUSH
78316: LD_VAR 0 6
78320: PPUSH
78321: LD_VAR 0 4
78325: PPUSH
78326: CALL_OW 3
78330: ST_TO_ADDR
78331: GO 78231
78333: POP
78334: POP
// j := GetClosestHex ( unit , tmp ) ;
78335: LD_ADDR_VAR 0 5
78339: PUSH
78340: LD_VAR 0 1
78344: PPUSH
78345: LD_VAR 0 6
78349: PPUSH
78350: CALL 77635 0 2
78354: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
78355: LD_VAR 0 1
78359: PPUSH
78360: LD_VAR 0 5
78364: PUSH
78365: LD_INT 1
78367: ARRAY
78368: PPUSH
78369: LD_VAR 0 5
78373: PUSH
78374: LD_INT 2
78376: ARRAY
78377: PPUSH
78378: CALL_OW 111
// end ;
78382: LD_VAR 0 3
78386: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
78387: LD_INT 0
78389: PPUSH
78390: PPUSH
78391: PPUSH
// uc_side = 0 ;
78392: LD_ADDR_OWVAR 20
78396: PUSH
78397: LD_INT 0
78399: ST_TO_ADDR
// uc_nation = 0 ;
78400: LD_ADDR_OWVAR 21
78404: PUSH
78405: LD_INT 0
78407: ST_TO_ADDR
// InitHc ;
78408: CALL_OW 19
// InitVc ;
78412: CALL_OW 20
// if mastodonts then
78416: LD_VAR 0 6
78420: IFFALSE 78487
// for i = 1 to mastodonts do
78422: LD_ADDR_VAR 0 11
78426: PUSH
78427: DOUBLE
78428: LD_INT 1
78430: DEC
78431: ST_TO_ADDR
78432: LD_VAR 0 6
78436: PUSH
78437: FOR_TO
78438: IFFALSE 78485
// begin vc_chassis := 31 ;
78440: LD_ADDR_OWVAR 37
78444: PUSH
78445: LD_INT 31
78447: ST_TO_ADDR
// vc_control := control_rider ;
78448: LD_ADDR_OWVAR 38
78452: PUSH
78453: LD_INT 4
78455: ST_TO_ADDR
// animal := CreateVehicle ;
78456: LD_ADDR_VAR 0 12
78460: PUSH
78461: CALL_OW 45
78465: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
78466: LD_VAR 0 12
78470: PPUSH
78471: LD_VAR 0 8
78475: PPUSH
78476: LD_INT 0
78478: PPUSH
78479: CALL 85193 0 3
// end ;
78483: GO 78437
78485: POP
78486: POP
// if horses then
78487: LD_VAR 0 5
78491: IFFALSE 78558
// for i = 1 to horses do
78493: LD_ADDR_VAR 0 11
78497: PUSH
78498: DOUBLE
78499: LD_INT 1
78501: DEC
78502: ST_TO_ADDR
78503: LD_VAR 0 5
78507: PUSH
78508: FOR_TO
78509: IFFALSE 78556
// begin hc_class := 21 ;
78511: LD_ADDR_OWVAR 28
78515: PUSH
78516: LD_INT 21
78518: ST_TO_ADDR
// hc_gallery :=  ;
78519: LD_ADDR_OWVAR 33
78523: PUSH
78524: LD_STRING 
78526: ST_TO_ADDR
// animal := CreateHuman ;
78527: LD_ADDR_VAR 0 12
78531: PUSH
78532: CALL_OW 44
78536: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
78537: LD_VAR 0 12
78541: PPUSH
78542: LD_VAR 0 8
78546: PPUSH
78547: LD_INT 0
78549: PPUSH
78550: CALL 85193 0 3
// end ;
78554: GO 78508
78556: POP
78557: POP
// if birds then
78558: LD_VAR 0 1
78562: IFFALSE 78629
// for i = 1 to birds do
78564: LD_ADDR_VAR 0 11
78568: PUSH
78569: DOUBLE
78570: LD_INT 1
78572: DEC
78573: ST_TO_ADDR
78574: LD_VAR 0 1
78578: PUSH
78579: FOR_TO
78580: IFFALSE 78627
// begin hc_class = 18 ;
78582: LD_ADDR_OWVAR 28
78586: PUSH
78587: LD_INT 18
78589: ST_TO_ADDR
// hc_gallery =  ;
78590: LD_ADDR_OWVAR 33
78594: PUSH
78595: LD_STRING 
78597: ST_TO_ADDR
// animal := CreateHuman ;
78598: LD_ADDR_VAR 0 12
78602: PUSH
78603: CALL_OW 44
78607: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
78608: LD_VAR 0 12
78612: PPUSH
78613: LD_VAR 0 8
78617: PPUSH
78618: LD_INT 0
78620: PPUSH
78621: CALL 85193 0 3
// end ;
78625: GO 78579
78627: POP
78628: POP
// if tigers then
78629: LD_VAR 0 2
78633: IFFALSE 78717
// for i = 1 to tigers do
78635: LD_ADDR_VAR 0 11
78639: PUSH
78640: DOUBLE
78641: LD_INT 1
78643: DEC
78644: ST_TO_ADDR
78645: LD_VAR 0 2
78649: PUSH
78650: FOR_TO
78651: IFFALSE 78715
// begin hc_class = class_tiger ;
78653: LD_ADDR_OWVAR 28
78657: PUSH
78658: LD_INT 14
78660: ST_TO_ADDR
// hc_gallery =  ;
78661: LD_ADDR_OWVAR 33
78665: PUSH
78666: LD_STRING 
78668: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
78669: LD_ADDR_OWVAR 35
78673: PUSH
78674: LD_INT 7
78676: NEG
78677: PPUSH
78678: LD_INT 7
78680: PPUSH
78681: CALL_OW 12
78685: ST_TO_ADDR
// animal := CreateHuman ;
78686: LD_ADDR_VAR 0 12
78690: PUSH
78691: CALL_OW 44
78695: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
78696: LD_VAR 0 12
78700: PPUSH
78701: LD_VAR 0 8
78705: PPUSH
78706: LD_INT 0
78708: PPUSH
78709: CALL 85193 0 3
// end ;
78713: GO 78650
78715: POP
78716: POP
// if apemans then
78717: LD_VAR 0 3
78721: IFFALSE 78844
// for i = 1 to apemans do
78723: LD_ADDR_VAR 0 11
78727: PUSH
78728: DOUBLE
78729: LD_INT 1
78731: DEC
78732: ST_TO_ADDR
78733: LD_VAR 0 3
78737: PUSH
78738: FOR_TO
78739: IFFALSE 78842
// begin hc_class = class_apeman ;
78741: LD_ADDR_OWVAR 28
78745: PUSH
78746: LD_INT 12
78748: ST_TO_ADDR
// hc_gallery =  ;
78749: LD_ADDR_OWVAR 33
78753: PUSH
78754: LD_STRING 
78756: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
78757: LD_ADDR_OWVAR 35
78761: PUSH
78762: LD_INT 5
78764: NEG
78765: PPUSH
78766: LD_INT 5
78768: PPUSH
78769: CALL_OW 12
78773: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
78774: LD_ADDR_OWVAR 31
78778: PUSH
78779: LD_INT 1
78781: PPUSH
78782: LD_INT 3
78784: PPUSH
78785: CALL_OW 12
78789: PUSH
78790: LD_INT 1
78792: PPUSH
78793: LD_INT 3
78795: PPUSH
78796: CALL_OW 12
78800: PUSH
78801: LD_INT 0
78803: PUSH
78804: LD_INT 0
78806: PUSH
78807: EMPTY
78808: LIST
78809: LIST
78810: LIST
78811: LIST
78812: ST_TO_ADDR
// animal := CreateHuman ;
78813: LD_ADDR_VAR 0 12
78817: PUSH
78818: CALL_OW 44
78822: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
78823: LD_VAR 0 12
78827: PPUSH
78828: LD_VAR 0 8
78832: PPUSH
78833: LD_INT 0
78835: PPUSH
78836: CALL 85193 0 3
// end ;
78840: GO 78738
78842: POP
78843: POP
// if enchidnas then
78844: LD_VAR 0 4
78848: IFFALSE 78915
// for i = 1 to enchidnas do
78850: LD_ADDR_VAR 0 11
78854: PUSH
78855: DOUBLE
78856: LD_INT 1
78858: DEC
78859: ST_TO_ADDR
78860: LD_VAR 0 4
78864: PUSH
78865: FOR_TO
78866: IFFALSE 78913
// begin hc_class = 13 ;
78868: LD_ADDR_OWVAR 28
78872: PUSH
78873: LD_INT 13
78875: ST_TO_ADDR
// hc_gallery =  ;
78876: LD_ADDR_OWVAR 33
78880: PUSH
78881: LD_STRING 
78883: ST_TO_ADDR
// animal := CreateHuman ;
78884: LD_ADDR_VAR 0 12
78888: PUSH
78889: CALL_OW 44
78893: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
78894: LD_VAR 0 12
78898: PPUSH
78899: LD_VAR 0 8
78903: PPUSH
78904: LD_INT 0
78906: PPUSH
78907: CALL 85193 0 3
// end ;
78911: GO 78865
78913: POP
78914: POP
// if fishes then
78915: LD_VAR 0 7
78919: IFFALSE 78986
// for i = 1 to fishes do
78921: LD_ADDR_VAR 0 11
78925: PUSH
78926: DOUBLE
78927: LD_INT 1
78929: DEC
78930: ST_TO_ADDR
78931: LD_VAR 0 7
78935: PUSH
78936: FOR_TO
78937: IFFALSE 78984
// begin hc_class = 20 ;
78939: LD_ADDR_OWVAR 28
78943: PUSH
78944: LD_INT 20
78946: ST_TO_ADDR
// hc_gallery =  ;
78947: LD_ADDR_OWVAR 33
78951: PUSH
78952: LD_STRING 
78954: ST_TO_ADDR
// animal := CreateHuman ;
78955: LD_ADDR_VAR 0 12
78959: PUSH
78960: CALL_OW 44
78964: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
78965: LD_VAR 0 12
78969: PPUSH
78970: LD_VAR 0 9
78974: PPUSH
78975: LD_INT 0
78977: PPUSH
78978: CALL 85193 0 3
// end ;
78982: GO 78936
78984: POP
78985: POP
// end ;
78986: LD_VAR 0 10
78990: RET
// export function WantHeal ( sci , unit ) ; begin
78991: LD_INT 0
78993: PPUSH
// if GetTaskList ( sci ) > 0 then
78994: LD_VAR 0 1
78998: PPUSH
78999: CALL_OW 437
79003: PUSH
79004: LD_INT 0
79006: GREATER
79007: IFFALSE 79077
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
79009: LD_VAR 0 1
79013: PPUSH
79014: CALL_OW 437
79018: PUSH
79019: LD_INT 1
79021: ARRAY
79022: PUSH
79023: LD_INT 1
79025: ARRAY
79026: PUSH
79027: LD_STRING l
79029: EQUAL
79030: PUSH
79031: LD_VAR 0 1
79035: PPUSH
79036: CALL_OW 437
79040: PUSH
79041: LD_INT 1
79043: ARRAY
79044: PUSH
79045: LD_INT 4
79047: ARRAY
79048: PUSH
79049: LD_VAR 0 2
79053: EQUAL
79054: AND
79055: IFFALSE 79067
// result := true else
79057: LD_ADDR_VAR 0 3
79061: PUSH
79062: LD_INT 1
79064: ST_TO_ADDR
79065: GO 79075
// result := false ;
79067: LD_ADDR_VAR 0 3
79071: PUSH
79072: LD_INT 0
79074: ST_TO_ADDR
// end else
79075: GO 79085
// result := false ;
79077: LD_ADDR_VAR 0 3
79081: PUSH
79082: LD_INT 0
79084: ST_TO_ADDR
// end ;
79085: LD_VAR 0 3
79089: RET
// export function HealTarget ( sci ) ; begin
79090: LD_INT 0
79092: PPUSH
// if not sci then
79093: LD_VAR 0 1
79097: NOT
79098: IFFALSE 79102
// exit ;
79100: GO 79167
// result := 0 ;
79102: LD_ADDR_VAR 0 2
79106: PUSH
79107: LD_INT 0
79109: ST_TO_ADDR
// if GetTaskList ( sci ) then
79110: LD_VAR 0 1
79114: PPUSH
79115: CALL_OW 437
79119: IFFALSE 79167
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
79121: LD_VAR 0 1
79125: PPUSH
79126: CALL_OW 437
79130: PUSH
79131: LD_INT 1
79133: ARRAY
79134: PUSH
79135: LD_INT 1
79137: ARRAY
79138: PUSH
79139: LD_STRING l
79141: EQUAL
79142: IFFALSE 79167
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
79144: LD_ADDR_VAR 0 2
79148: PUSH
79149: LD_VAR 0 1
79153: PPUSH
79154: CALL_OW 437
79158: PUSH
79159: LD_INT 1
79161: ARRAY
79162: PUSH
79163: LD_INT 4
79165: ARRAY
79166: ST_TO_ADDR
// end ;
79167: LD_VAR 0 2
79171: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
79172: LD_INT 0
79174: PPUSH
79175: PPUSH
79176: PPUSH
79177: PPUSH
79178: PPUSH
79179: PPUSH
79180: PPUSH
79181: PPUSH
79182: PPUSH
79183: PPUSH
79184: PPUSH
79185: PPUSH
79186: PPUSH
79187: PPUSH
79188: PPUSH
79189: PPUSH
79190: PPUSH
79191: PPUSH
79192: PPUSH
79193: PPUSH
79194: PPUSH
79195: PPUSH
79196: PPUSH
79197: PPUSH
79198: PPUSH
79199: PPUSH
79200: PPUSH
79201: PPUSH
79202: PPUSH
79203: PPUSH
79204: PPUSH
79205: PPUSH
79206: PPUSH
// if not list then
79207: LD_VAR 0 1
79211: NOT
79212: IFFALSE 79216
// exit ;
79214: GO 83804
// base := list [ 1 ] ;
79216: LD_ADDR_VAR 0 3
79220: PUSH
79221: LD_VAR 0 1
79225: PUSH
79226: LD_INT 1
79228: ARRAY
79229: ST_TO_ADDR
// group := list [ 2 ] ;
79230: LD_ADDR_VAR 0 4
79234: PUSH
79235: LD_VAR 0 1
79239: PUSH
79240: LD_INT 2
79242: ARRAY
79243: ST_TO_ADDR
// path := list [ 3 ] ;
79244: LD_ADDR_VAR 0 5
79248: PUSH
79249: LD_VAR 0 1
79253: PUSH
79254: LD_INT 3
79256: ARRAY
79257: ST_TO_ADDR
// flags := list [ 4 ] ;
79258: LD_ADDR_VAR 0 6
79262: PUSH
79263: LD_VAR 0 1
79267: PUSH
79268: LD_INT 4
79270: ARRAY
79271: ST_TO_ADDR
// mined := [ ] ;
79272: LD_ADDR_VAR 0 27
79276: PUSH
79277: EMPTY
79278: ST_TO_ADDR
// bombed := [ ] ;
79279: LD_ADDR_VAR 0 28
79283: PUSH
79284: EMPTY
79285: ST_TO_ADDR
// healers := [ ] ;
79286: LD_ADDR_VAR 0 31
79290: PUSH
79291: EMPTY
79292: ST_TO_ADDR
// to_heal := [ ] ;
79293: LD_ADDR_VAR 0 30
79297: PUSH
79298: EMPTY
79299: ST_TO_ADDR
// repairs := [ ] ;
79300: LD_ADDR_VAR 0 33
79304: PUSH
79305: EMPTY
79306: ST_TO_ADDR
// to_repair := [ ] ;
79307: LD_ADDR_VAR 0 32
79311: PUSH
79312: EMPTY
79313: ST_TO_ADDR
// if not group or not path then
79314: LD_VAR 0 4
79318: NOT
79319: PUSH
79320: LD_VAR 0 5
79324: NOT
79325: OR
79326: IFFALSE 79330
// exit ;
79328: GO 83804
// if flags then
79330: LD_VAR 0 6
79334: IFFALSE 79478
// begin f_ignore_area := flags [ 1 ] ;
79336: LD_ADDR_VAR 0 17
79340: PUSH
79341: LD_VAR 0 6
79345: PUSH
79346: LD_INT 1
79348: ARRAY
79349: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
79350: LD_ADDR_VAR 0 18
79354: PUSH
79355: LD_VAR 0 6
79359: PUSH
79360: LD_INT 2
79362: ARRAY
79363: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
79364: LD_ADDR_VAR 0 19
79368: PUSH
79369: LD_VAR 0 6
79373: PUSH
79374: LD_INT 3
79376: ARRAY
79377: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
79378: LD_ADDR_VAR 0 20
79382: PUSH
79383: LD_VAR 0 6
79387: PUSH
79388: LD_INT 4
79390: ARRAY
79391: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
79392: LD_ADDR_VAR 0 21
79396: PUSH
79397: LD_VAR 0 6
79401: PUSH
79402: LD_INT 5
79404: ARRAY
79405: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
79406: LD_ADDR_VAR 0 22
79410: PUSH
79411: LD_VAR 0 6
79415: PUSH
79416: LD_INT 6
79418: ARRAY
79419: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
79420: LD_ADDR_VAR 0 23
79424: PUSH
79425: LD_VAR 0 6
79429: PUSH
79430: LD_INT 7
79432: ARRAY
79433: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
79434: LD_ADDR_VAR 0 24
79438: PUSH
79439: LD_VAR 0 6
79443: PUSH
79444: LD_INT 8
79446: ARRAY
79447: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
79448: LD_ADDR_VAR 0 25
79452: PUSH
79453: LD_VAR 0 6
79457: PUSH
79458: LD_INT 9
79460: ARRAY
79461: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
79462: LD_ADDR_VAR 0 26
79466: PUSH
79467: LD_VAR 0 6
79471: PUSH
79472: LD_INT 10
79474: ARRAY
79475: ST_TO_ADDR
// end else
79476: GO 79558
// begin f_ignore_area := false ;
79478: LD_ADDR_VAR 0 17
79482: PUSH
79483: LD_INT 0
79485: ST_TO_ADDR
// f_capture := false ;
79486: LD_ADDR_VAR 0 18
79490: PUSH
79491: LD_INT 0
79493: ST_TO_ADDR
// f_ignore_civ := false ;
79494: LD_ADDR_VAR 0 19
79498: PUSH
79499: LD_INT 0
79501: ST_TO_ADDR
// f_murder := false ;
79502: LD_ADDR_VAR 0 20
79506: PUSH
79507: LD_INT 0
79509: ST_TO_ADDR
// f_mines := false ;
79510: LD_ADDR_VAR 0 21
79514: PUSH
79515: LD_INT 0
79517: ST_TO_ADDR
// f_repair := false ;
79518: LD_ADDR_VAR 0 22
79522: PUSH
79523: LD_INT 0
79525: ST_TO_ADDR
// f_heal := false ;
79526: LD_ADDR_VAR 0 23
79530: PUSH
79531: LD_INT 0
79533: ST_TO_ADDR
// f_spacetime := false ;
79534: LD_ADDR_VAR 0 24
79538: PUSH
79539: LD_INT 0
79541: ST_TO_ADDR
// f_attack_depot := false ;
79542: LD_ADDR_VAR 0 25
79546: PUSH
79547: LD_INT 0
79549: ST_TO_ADDR
// f_crawl := false ;
79550: LD_ADDR_VAR 0 26
79554: PUSH
79555: LD_INT 0
79557: ST_TO_ADDR
// end ; if f_heal then
79558: LD_VAR 0 23
79562: IFFALSE 79589
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
79564: LD_ADDR_VAR 0 31
79568: PUSH
79569: LD_VAR 0 4
79573: PPUSH
79574: LD_INT 25
79576: PUSH
79577: LD_INT 4
79579: PUSH
79580: EMPTY
79581: LIST
79582: LIST
79583: PPUSH
79584: CALL_OW 72
79588: ST_TO_ADDR
// if f_repair then
79589: LD_VAR 0 22
79593: IFFALSE 79620
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
79595: LD_ADDR_VAR 0 33
79599: PUSH
79600: LD_VAR 0 4
79604: PPUSH
79605: LD_INT 25
79607: PUSH
79608: LD_INT 3
79610: PUSH
79611: EMPTY
79612: LIST
79613: LIST
79614: PPUSH
79615: CALL_OW 72
79619: ST_TO_ADDR
// units_path := [ ] ;
79620: LD_ADDR_VAR 0 16
79624: PUSH
79625: EMPTY
79626: ST_TO_ADDR
// for i = 1 to group do
79627: LD_ADDR_VAR 0 7
79631: PUSH
79632: DOUBLE
79633: LD_INT 1
79635: DEC
79636: ST_TO_ADDR
79637: LD_VAR 0 4
79641: PUSH
79642: FOR_TO
79643: IFFALSE 79672
// units_path := Replace ( units_path , i , path ) ;
79645: LD_ADDR_VAR 0 16
79649: PUSH
79650: LD_VAR 0 16
79654: PPUSH
79655: LD_VAR 0 7
79659: PPUSH
79660: LD_VAR 0 5
79664: PPUSH
79665: CALL_OW 1
79669: ST_TO_ADDR
79670: GO 79642
79672: POP
79673: POP
// repeat for i = group downto 1 do
79674: LD_ADDR_VAR 0 7
79678: PUSH
79679: DOUBLE
79680: LD_VAR 0 4
79684: INC
79685: ST_TO_ADDR
79686: LD_INT 1
79688: PUSH
79689: FOR_DOWNTO
79690: IFFALSE 83786
// begin wait ( 5 ) ;
79692: LD_INT 5
79694: PPUSH
79695: CALL_OW 67
// tmp := [ ] ;
79699: LD_ADDR_VAR 0 14
79703: PUSH
79704: EMPTY
79705: ST_TO_ADDR
// attacking := false ;
79706: LD_ADDR_VAR 0 29
79710: PUSH
79711: LD_INT 0
79713: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
79714: LD_VAR 0 4
79718: PUSH
79719: LD_VAR 0 7
79723: ARRAY
79724: PPUSH
79725: CALL_OW 301
79729: PUSH
79730: LD_VAR 0 4
79734: PUSH
79735: LD_VAR 0 7
79739: ARRAY
79740: NOT
79741: OR
79742: IFFALSE 79851
// begin if GetType ( group [ i ] ) = unit_human then
79744: LD_VAR 0 4
79748: PUSH
79749: LD_VAR 0 7
79753: ARRAY
79754: PPUSH
79755: CALL_OW 247
79759: PUSH
79760: LD_INT 1
79762: EQUAL
79763: IFFALSE 79809
// begin to_heal := to_heal diff group [ i ] ;
79765: LD_ADDR_VAR 0 30
79769: PUSH
79770: LD_VAR 0 30
79774: PUSH
79775: LD_VAR 0 4
79779: PUSH
79780: LD_VAR 0 7
79784: ARRAY
79785: DIFF
79786: ST_TO_ADDR
// healers := healers diff group [ i ] ;
79787: LD_ADDR_VAR 0 31
79791: PUSH
79792: LD_VAR 0 31
79796: PUSH
79797: LD_VAR 0 4
79801: PUSH
79802: LD_VAR 0 7
79806: ARRAY
79807: DIFF
79808: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
79809: LD_ADDR_VAR 0 4
79813: PUSH
79814: LD_VAR 0 4
79818: PPUSH
79819: LD_VAR 0 7
79823: PPUSH
79824: CALL_OW 3
79828: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
79829: LD_ADDR_VAR 0 16
79833: PUSH
79834: LD_VAR 0 16
79838: PPUSH
79839: LD_VAR 0 7
79843: PPUSH
79844: CALL_OW 3
79848: ST_TO_ADDR
// continue ;
79849: GO 79689
// end ; if f_repair then
79851: LD_VAR 0 22
79855: IFFALSE 80344
// begin if GetType ( group [ i ] ) = unit_vehicle then
79857: LD_VAR 0 4
79861: PUSH
79862: LD_VAR 0 7
79866: ARRAY
79867: PPUSH
79868: CALL_OW 247
79872: PUSH
79873: LD_INT 2
79875: EQUAL
79876: IFFALSE 80066
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
79878: LD_VAR 0 4
79882: PUSH
79883: LD_VAR 0 7
79887: ARRAY
79888: PPUSH
79889: CALL_OW 256
79893: PUSH
79894: LD_INT 700
79896: LESS
79897: PUSH
79898: LD_VAR 0 4
79902: PUSH
79903: LD_VAR 0 7
79907: ARRAY
79908: PUSH
79909: LD_VAR 0 32
79913: IN
79914: NOT
79915: AND
79916: IFFALSE 79940
// to_repair := to_repair union group [ i ] ;
79918: LD_ADDR_VAR 0 32
79922: PUSH
79923: LD_VAR 0 32
79927: PUSH
79928: LD_VAR 0 4
79932: PUSH
79933: LD_VAR 0 7
79937: ARRAY
79938: UNION
79939: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
79940: LD_VAR 0 4
79944: PUSH
79945: LD_VAR 0 7
79949: ARRAY
79950: PPUSH
79951: CALL_OW 256
79955: PUSH
79956: LD_INT 1000
79958: EQUAL
79959: PUSH
79960: LD_VAR 0 4
79964: PUSH
79965: LD_VAR 0 7
79969: ARRAY
79970: PUSH
79971: LD_VAR 0 32
79975: IN
79976: AND
79977: IFFALSE 80001
// to_repair := to_repair diff group [ i ] ;
79979: LD_ADDR_VAR 0 32
79983: PUSH
79984: LD_VAR 0 32
79988: PUSH
79989: LD_VAR 0 4
79993: PUSH
79994: LD_VAR 0 7
79998: ARRAY
79999: DIFF
80000: ST_TO_ADDR
// if group [ i ] in to_repair then
80001: LD_VAR 0 4
80005: PUSH
80006: LD_VAR 0 7
80010: ARRAY
80011: PUSH
80012: LD_VAR 0 32
80016: IN
80017: IFFALSE 80064
// begin if not IsInArea ( group [ i ] , f_repair ) then
80019: LD_VAR 0 4
80023: PUSH
80024: LD_VAR 0 7
80028: ARRAY
80029: PPUSH
80030: LD_VAR 0 22
80034: PPUSH
80035: CALL_OW 308
80039: NOT
80040: IFFALSE 80062
// ComMoveToArea ( group [ i ] , f_repair ) ;
80042: LD_VAR 0 4
80046: PUSH
80047: LD_VAR 0 7
80051: ARRAY
80052: PPUSH
80053: LD_VAR 0 22
80057: PPUSH
80058: CALL_OW 113
// continue ;
80062: GO 79689
// end ; end else
80064: GO 80344
// if group [ i ] in repairs then
80066: LD_VAR 0 4
80070: PUSH
80071: LD_VAR 0 7
80075: ARRAY
80076: PUSH
80077: LD_VAR 0 33
80081: IN
80082: IFFALSE 80344
// begin if IsInUnit ( group [ i ] ) then
80084: LD_VAR 0 4
80088: PUSH
80089: LD_VAR 0 7
80093: ARRAY
80094: PPUSH
80095: CALL_OW 310
80099: IFFALSE 80167
// begin z := IsInUnit ( group [ i ] ) ;
80101: LD_ADDR_VAR 0 13
80105: PUSH
80106: LD_VAR 0 4
80110: PUSH
80111: LD_VAR 0 7
80115: ARRAY
80116: PPUSH
80117: CALL_OW 310
80121: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
80122: LD_VAR 0 13
80126: PUSH
80127: LD_VAR 0 32
80131: IN
80132: PUSH
80133: LD_VAR 0 13
80137: PPUSH
80138: LD_VAR 0 22
80142: PPUSH
80143: CALL_OW 308
80147: AND
80148: IFFALSE 80165
// ComExitVehicle ( group [ i ] ) ;
80150: LD_VAR 0 4
80154: PUSH
80155: LD_VAR 0 7
80159: ARRAY
80160: PPUSH
80161: CALL_OW 121
// end else
80165: GO 80344
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
80167: LD_ADDR_VAR 0 13
80171: PUSH
80172: LD_VAR 0 4
80176: PPUSH
80177: LD_INT 95
80179: PUSH
80180: LD_VAR 0 22
80184: PUSH
80185: EMPTY
80186: LIST
80187: LIST
80188: PUSH
80189: LD_INT 58
80191: PUSH
80192: EMPTY
80193: LIST
80194: PUSH
80195: EMPTY
80196: LIST
80197: LIST
80198: PPUSH
80199: CALL_OW 72
80203: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
80204: LD_VAR 0 4
80208: PUSH
80209: LD_VAR 0 7
80213: ARRAY
80214: PPUSH
80215: CALL_OW 314
80219: NOT
80220: IFFALSE 80342
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
80222: LD_ADDR_VAR 0 10
80226: PUSH
80227: LD_VAR 0 13
80231: PPUSH
80232: LD_VAR 0 4
80236: PUSH
80237: LD_VAR 0 7
80241: ARRAY
80242: PPUSH
80243: CALL_OW 74
80247: ST_TO_ADDR
// if not x then
80248: LD_VAR 0 10
80252: NOT
80253: IFFALSE 80257
// continue ;
80255: GO 79689
// if GetLives ( x ) < 1000 then
80257: LD_VAR 0 10
80261: PPUSH
80262: CALL_OW 256
80266: PUSH
80267: LD_INT 1000
80269: LESS
80270: IFFALSE 80294
// ComRepairVehicle ( group [ i ] , x ) else
80272: LD_VAR 0 4
80276: PUSH
80277: LD_VAR 0 7
80281: ARRAY
80282: PPUSH
80283: LD_VAR 0 10
80287: PPUSH
80288: CALL_OW 129
80292: GO 80342
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
80294: LD_VAR 0 23
80298: PUSH
80299: LD_VAR 0 4
80303: PUSH
80304: LD_VAR 0 7
80308: ARRAY
80309: PPUSH
80310: CALL_OW 256
80314: PUSH
80315: LD_INT 1000
80317: LESS
80318: AND
80319: NOT
80320: IFFALSE 80342
// ComEnterUnit ( group [ i ] , x ) ;
80322: LD_VAR 0 4
80326: PUSH
80327: LD_VAR 0 7
80331: ARRAY
80332: PPUSH
80333: LD_VAR 0 10
80337: PPUSH
80338: CALL_OW 120
// end ; continue ;
80342: GO 79689
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
80344: LD_VAR 0 23
80348: PUSH
80349: LD_VAR 0 4
80353: PUSH
80354: LD_VAR 0 7
80358: ARRAY
80359: PPUSH
80360: CALL_OW 247
80364: PUSH
80365: LD_INT 1
80367: EQUAL
80368: AND
80369: IFFALSE 80847
// begin if group [ i ] in healers then
80371: LD_VAR 0 4
80375: PUSH
80376: LD_VAR 0 7
80380: ARRAY
80381: PUSH
80382: LD_VAR 0 31
80386: IN
80387: IFFALSE 80660
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
80389: LD_VAR 0 4
80393: PUSH
80394: LD_VAR 0 7
80398: ARRAY
80399: PPUSH
80400: LD_VAR 0 23
80404: PPUSH
80405: CALL_OW 308
80409: NOT
80410: PUSH
80411: LD_VAR 0 4
80415: PUSH
80416: LD_VAR 0 7
80420: ARRAY
80421: PPUSH
80422: CALL_OW 314
80426: NOT
80427: AND
80428: IFFALSE 80452
// ComMoveToArea ( group [ i ] , f_heal ) else
80430: LD_VAR 0 4
80434: PUSH
80435: LD_VAR 0 7
80439: ARRAY
80440: PPUSH
80441: LD_VAR 0 23
80445: PPUSH
80446: CALL_OW 113
80450: GO 80658
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
80452: LD_VAR 0 4
80456: PUSH
80457: LD_VAR 0 7
80461: ARRAY
80462: PPUSH
80463: CALL 79090 0 1
80467: PPUSH
80468: CALL_OW 256
80472: PUSH
80473: LD_INT 1000
80475: EQUAL
80476: IFFALSE 80495
// ComStop ( group [ i ] ) else
80478: LD_VAR 0 4
80482: PUSH
80483: LD_VAR 0 7
80487: ARRAY
80488: PPUSH
80489: CALL_OW 141
80493: GO 80658
// if not HasTask ( group [ i ] ) and to_heal then
80495: LD_VAR 0 4
80499: PUSH
80500: LD_VAR 0 7
80504: ARRAY
80505: PPUSH
80506: CALL_OW 314
80510: NOT
80511: PUSH
80512: LD_VAR 0 30
80516: AND
80517: IFFALSE 80658
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
80519: LD_ADDR_VAR 0 13
80523: PUSH
80524: LD_VAR 0 30
80528: PPUSH
80529: LD_INT 3
80531: PUSH
80532: LD_INT 54
80534: PUSH
80535: EMPTY
80536: LIST
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: PPUSH
80542: CALL_OW 72
80546: PPUSH
80547: LD_VAR 0 4
80551: PUSH
80552: LD_VAR 0 7
80556: ARRAY
80557: PPUSH
80558: CALL_OW 74
80562: ST_TO_ADDR
// if z then
80563: LD_VAR 0 13
80567: IFFALSE 80658
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
80569: LD_INT 91
80571: PUSH
80572: LD_VAR 0 13
80576: PUSH
80577: LD_INT 10
80579: PUSH
80580: EMPTY
80581: LIST
80582: LIST
80583: LIST
80584: PUSH
80585: LD_INT 81
80587: PUSH
80588: LD_VAR 0 13
80592: PPUSH
80593: CALL_OW 255
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: PUSH
80602: EMPTY
80603: LIST
80604: LIST
80605: PPUSH
80606: CALL_OW 69
80610: PUSH
80611: LD_INT 0
80613: EQUAL
80614: IFFALSE 80638
// ComHeal ( group [ i ] , z ) else
80616: LD_VAR 0 4
80620: PUSH
80621: LD_VAR 0 7
80625: ARRAY
80626: PPUSH
80627: LD_VAR 0 13
80631: PPUSH
80632: CALL_OW 128
80636: GO 80658
// ComMoveToArea ( group [ i ] , f_heal ) ;
80638: LD_VAR 0 4
80642: PUSH
80643: LD_VAR 0 7
80647: ARRAY
80648: PPUSH
80649: LD_VAR 0 23
80653: PPUSH
80654: CALL_OW 113
// end ; continue ;
80658: GO 79689
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
80660: LD_VAR 0 4
80664: PUSH
80665: LD_VAR 0 7
80669: ARRAY
80670: PPUSH
80671: CALL_OW 256
80675: PUSH
80676: LD_INT 700
80678: LESS
80679: PUSH
80680: LD_VAR 0 4
80684: PUSH
80685: LD_VAR 0 7
80689: ARRAY
80690: PUSH
80691: LD_VAR 0 30
80695: IN
80696: NOT
80697: AND
80698: IFFALSE 80722
// to_heal := to_heal union group [ i ] ;
80700: LD_ADDR_VAR 0 30
80704: PUSH
80705: LD_VAR 0 30
80709: PUSH
80710: LD_VAR 0 4
80714: PUSH
80715: LD_VAR 0 7
80719: ARRAY
80720: UNION
80721: ST_TO_ADDR
// if group [ i ] in to_heal then
80722: LD_VAR 0 4
80726: PUSH
80727: LD_VAR 0 7
80731: ARRAY
80732: PUSH
80733: LD_VAR 0 30
80737: IN
80738: IFFALSE 80847
// begin if GetLives ( group [ i ] ) = 1000 then
80740: LD_VAR 0 4
80744: PUSH
80745: LD_VAR 0 7
80749: ARRAY
80750: PPUSH
80751: CALL_OW 256
80755: PUSH
80756: LD_INT 1000
80758: EQUAL
80759: IFFALSE 80785
// to_heal := to_heal diff group [ i ] else
80761: LD_ADDR_VAR 0 30
80765: PUSH
80766: LD_VAR 0 30
80770: PUSH
80771: LD_VAR 0 4
80775: PUSH
80776: LD_VAR 0 7
80780: ARRAY
80781: DIFF
80782: ST_TO_ADDR
80783: GO 80847
// begin if not IsInArea ( group [ i ] , to_heal ) then
80785: LD_VAR 0 4
80789: PUSH
80790: LD_VAR 0 7
80794: ARRAY
80795: PPUSH
80796: LD_VAR 0 30
80800: PPUSH
80801: CALL_OW 308
80805: NOT
80806: IFFALSE 80830
// ComMoveToArea ( group [ i ] , f_heal ) else
80808: LD_VAR 0 4
80812: PUSH
80813: LD_VAR 0 7
80817: ARRAY
80818: PPUSH
80819: LD_VAR 0 23
80823: PPUSH
80824: CALL_OW 113
80828: GO 80845
// ComHold ( group [ i ] ) ;
80830: LD_VAR 0 4
80834: PUSH
80835: LD_VAR 0 7
80839: ARRAY
80840: PPUSH
80841: CALL_OW 140
// continue ;
80845: GO 79689
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
80847: LD_VAR 0 4
80851: PUSH
80852: LD_VAR 0 7
80856: ARRAY
80857: PPUSH
80858: LD_INT 10
80860: PPUSH
80861: CALL 77487 0 2
80865: NOT
80866: PUSH
80867: LD_VAR 0 16
80871: PUSH
80872: LD_VAR 0 7
80876: ARRAY
80877: PUSH
80878: EMPTY
80879: EQUAL
80880: NOT
80881: AND
80882: IFFALSE 81148
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
80884: LD_VAR 0 4
80888: PUSH
80889: LD_VAR 0 7
80893: ARRAY
80894: PPUSH
80895: CALL_OW 262
80899: PUSH
80900: LD_INT 1
80902: PUSH
80903: LD_INT 2
80905: PUSH
80906: EMPTY
80907: LIST
80908: LIST
80909: IN
80910: IFFALSE 80951
// if GetFuel ( group [ i ] ) < 10 then
80912: LD_VAR 0 4
80916: PUSH
80917: LD_VAR 0 7
80921: ARRAY
80922: PPUSH
80923: CALL_OW 261
80927: PUSH
80928: LD_INT 10
80930: LESS
80931: IFFALSE 80951
// SetFuel ( group [ i ] , 12 ) ;
80933: LD_VAR 0 4
80937: PUSH
80938: LD_VAR 0 7
80942: ARRAY
80943: PPUSH
80944: LD_INT 12
80946: PPUSH
80947: CALL_OW 240
// if units_path [ i ] then
80951: LD_VAR 0 16
80955: PUSH
80956: LD_VAR 0 7
80960: ARRAY
80961: IFFALSE 81146
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
80963: LD_VAR 0 4
80967: PUSH
80968: LD_VAR 0 7
80972: ARRAY
80973: PPUSH
80974: LD_VAR 0 16
80978: PUSH
80979: LD_VAR 0 7
80983: ARRAY
80984: PUSH
80985: LD_INT 1
80987: ARRAY
80988: PUSH
80989: LD_INT 1
80991: ARRAY
80992: PPUSH
80993: LD_VAR 0 16
80997: PUSH
80998: LD_VAR 0 7
81002: ARRAY
81003: PUSH
81004: LD_INT 1
81006: ARRAY
81007: PUSH
81008: LD_INT 2
81010: ARRAY
81011: PPUSH
81012: CALL_OW 297
81016: PUSH
81017: LD_INT 6
81019: GREATER
81020: IFFALSE 81095
// begin if not HasTask ( group [ i ] ) then
81022: LD_VAR 0 4
81026: PUSH
81027: LD_VAR 0 7
81031: ARRAY
81032: PPUSH
81033: CALL_OW 314
81037: NOT
81038: IFFALSE 81093
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
81040: LD_VAR 0 4
81044: PUSH
81045: LD_VAR 0 7
81049: ARRAY
81050: PPUSH
81051: LD_VAR 0 16
81055: PUSH
81056: LD_VAR 0 7
81060: ARRAY
81061: PUSH
81062: LD_INT 1
81064: ARRAY
81065: PUSH
81066: LD_INT 1
81068: ARRAY
81069: PPUSH
81070: LD_VAR 0 16
81074: PUSH
81075: LD_VAR 0 7
81079: ARRAY
81080: PUSH
81081: LD_INT 1
81083: ARRAY
81084: PUSH
81085: LD_INT 2
81087: ARRAY
81088: PPUSH
81089: CALL_OW 114
// end else
81093: GO 81146
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
81095: LD_ADDR_VAR 0 15
81099: PUSH
81100: LD_VAR 0 16
81104: PUSH
81105: LD_VAR 0 7
81109: ARRAY
81110: PPUSH
81111: LD_INT 1
81113: PPUSH
81114: CALL_OW 3
81118: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
81119: LD_ADDR_VAR 0 16
81123: PUSH
81124: LD_VAR 0 16
81128: PPUSH
81129: LD_VAR 0 7
81133: PPUSH
81134: LD_VAR 0 15
81138: PPUSH
81139: CALL_OW 1
81143: ST_TO_ADDR
// continue ;
81144: GO 79689
// end ; end ; end else
81146: GO 83784
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
81148: LD_ADDR_VAR 0 14
81152: PUSH
81153: LD_INT 81
81155: PUSH
81156: LD_VAR 0 4
81160: PUSH
81161: LD_VAR 0 7
81165: ARRAY
81166: PPUSH
81167: CALL_OW 255
81171: PUSH
81172: EMPTY
81173: LIST
81174: LIST
81175: PPUSH
81176: CALL_OW 69
81180: ST_TO_ADDR
// if not tmp then
81181: LD_VAR 0 14
81185: NOT
81186: IFFALSE 81190
// continue ;
81188: GO 79689
// if f_ignore_area then
81190: LD_VAR 0 17
81194: IFFALSE 81282
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
81196: LD_ADDR_VAR 0 15
81200: PUSH
81201: LD_VAR 0 14
81205: PPUSH
81206: LD_INT 3
81208: PUSH
81209: LD_INT 92
81211: PUSH
81212: LD_VAR 0 17
81216: PUSH
81217: LD_INT 1
81219: ARRAY
81220: PUSH
81221: LD_VAR 0 17
81225: PUSH
81226: LD_INT 2
81228: ARRAY
81229: PUSH
81230: LD_VAR 0 17
81234: PUSH
81235: LD_INT 3
81237: ARRAY
81238: PUSH
81239: EMPTY
81240: LIST
81241: LIST
81242: LIST
81243: LIST
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: PPUSH
81249: CALL_OW 72
81253: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
81254: LD_VAR 0 14
81258: PUSH
81259: LD_VAR 0 15
81263: DIFF
81264: IFFALSE 81282
// tmp := tmp diff tmp2 ;
81266: LD_ADDR_VAR 0 14
81270: PUSH
81271: LD_VAR 0 14
81275: PUSH
81276: LD_VAR 0 15
81280: DIFF
81281: ST_TO_ADDR
// end ; if not f_murder then
81282: LD_VAR 0 20
81286: NOT
81287: IFFALSE 81345
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
81289: LD_ADDR_VAR 0 15
81293: PUSH
81294: LD_VAR 0 14
81298: PPUSH
81299: LD_INT 3
81301: PUSH
81302: LD_INT 50
81304: PUSH
81305: EMPTY
81306: LIST
81307: PUSH
81308: EMPTY
81309: LIST
81310: LIST
81311: PPUSH
81312: CALL_OW 72
81316: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
81317: LD_VAR 0 14
81321: PUSH
81322: LD_VAR 0 15
81326: DIFF
81327: IFFALSE 81345
// tmp := tmp diff tmp2 ;
81329: LD_ADDR_VAR 0 14
81333: PUSH
81334: LD_VAR 0 14
81338: PUSH
81339: LD_VAR 0 15
81343: DIFF
81344: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
81345: LD_ADDR_VAR 0 14
81349: PUSH
81350: LD_VAR 0 4
81354: PUSH
81355: LD_VAR 0 7
81359: ARRAY
81360: PPUSH
81361: LD_VAR 0 14
81365: PPUSH
81366: LD_INT 1
81368: PPUSH
81369: LD_INT 1
81371: PPUSH
81372: CALL 51341 0 4
81376: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
81377: LD_VAR 0 4
81381: PUSH
81382: LD_VAR 0 7
81386: ARRAY
81387: PPUSH
81388: CALL_OW 257
81392: PUSH
81393: LD_INT 1
81395: EQUAL
81396: IFFALSE 81844
// begin if WantPlant ( group [ i ] ) then
81398: LD_VAR 0 4
81402: PUSH
81403: LD_VAR 0 7
81407: ARRAY
81408: PPUSH
81409: CALL 50809 0 1
81413: IFFALSE 81417
// continue ;
81415: GO 79689
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
81417: LD_VAR 0 18
81421: PUSH
81422: LD_VAR 0 4
81426: PUSH
81427: LD_VAR 0 7
81431: ARRAY
81432: PPUSH
81433: CALL_OW 310
81437: NOT
81438: AND
81439: PUSH
81440: LD_VAR 0 14
81444: PUSH
81445: LD_INT 1
81447: ARRAY
81448: PUSH
81449: LD_VAR 0 14
81453: PPUSH
81454: LD_INT 21
81456: PUSH
81457: LD_INT 2
81459: PUSH
81460: EMPTY
81461: LIST
81462: LIST
81463: PUSH
81464: LD_INT 58
81466: PUSH
81467: EMPTY
81468: LIST
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PPUSH
81474: CALL_OW 72
81478: IN
81479: AND
81480: IFFALSE 81516
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
81482: LD_VAR 0 4
81486: PUSH
81487: LD_VAR 0 7
81491: ARRAY
81492: PPUSH
81493: LD_VAR 0 14
81497: PUSH
81498: LD_INT 1
81500: ARRAY
81501: PPUSH
81502: CALL_OW 120
// attacking := true ;
81506: LD_ADDR_VAR 0 29
81510: PUSH
81511: LD_INT 1
81513: ST_TO_ADDR
// continue ;
81514: GO 79689
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
81516: LD_VAR 0 26
81520: PUSH
81521: LD_VAR 0 4
81525: PUSH
81526: LD_VAR 0 7
81530: ARRAY
81531: PPUSH
81532: CALL_OW 257
81536: PUSH
81537: LD_INT 1
81539: EQUAL
81540: AND
81541: PUSH
81542: LD_VAR 0 4
81546: PUSH
81547: LD_VAR 0 7
81551: ARRAY
81552: PPUSH
81553: CALL_OW 256
81557: PUSH
81558: LD_INT 800
81560: LESS
81561: AND
81562: PUSH
81563: LD_VAR 0 4
81567: PUSH
81568: LD_VAR 0 7
81572: ARRAY
81573: PPUSH
81574: CALL_OW 318
81578: NOT
81579: AND
81580: IFFALSE 81597
// ComCrawl ( group [ i ] ) ;
81582: LD_VAR 0 4
81586: PUSH
81587: LD_VAR 0 7
81591: ARRAY
81592: PPUSH
81593: CALL_OW 137
// if f_mines then
81597: LD_VAR 0 21
81601: IFFALSE 81844
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
81603: LD_VAR 0 14
81607: PUSH
81608: LD_INT 1
81610: ARRAY
81611: PPUSH
81612: CALL_OW 247
81616: PUSH
81617: LD_INT 3
81619: EQUAL
81620: PUSH
81621: LD_VAR 0 14
81625: PUSH
81626: LD_INT 1
81628: ARRAY
81629: PUSH
81630: LD_VAR 0 27
81634: IN
81635: NOT
81636: AND
81637: IFFALSE 81844
// begin x := GetX ( tmp [ 1 ] ) ;
81639: LD_ADDR_VAR 0 10
81643: PUSH
81644: LD_VAR 0 14
81648: PUSH
81649: LD_INT 1
81651: ARRAY
81652: PPUSH
81653: CALL_OW 250
81657: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
81658: LD_ADDR_VAR 0 11
81662: PUSH
81663: LD_VAR 0 14
81667: PUSH
81668: LD_INT 1
81670: ARRAY
81671: PPUSH
81672: CALL_OW 251
81676: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
81677: LD_ADDR_VAR 0 12
81681: PUSH
81682: LD_VAR 0 4
81686: PUSH
81687: LD_VAR 0 7
81691: ARRAY
81692: PPUSH
81693: CALL 77572 0 1
81697: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
81698: LD_VAR 0 4
81702: PUSH
81703: LD_VAR 0 7
81707: ARRAY
81708: PPUSH
81709: LD_VAR 0 10
81713: PPUSH
81714: LD_VAR 0 11
81718: PPUSH
81719: LD_VAR 0 14
81723: PUSH
81724: LD_INT 1
81726: ARRAY
81727: PPUSH
81728: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
81732: LD_VAR 0 4
81736: PUSH
81737: LD_VAR 0 7
81741: ARRAY
81742: PPUSH
81743: LD_VAR 0 10
81747: PPUSH
81748: LD_VAR 0 12
81752: PPUSH
81753: LD_INT 7
81755: PPUSH
81756: CALL_OW 272
81760: PPUSH
81761: LD_VAR 0 11
81765: PPUSH
81766: LD_VAR 0 12
81770: PPUSH
81771: LD_INT 7
81773: PPUSH
81774: CALL_OW 273
81778: PPUSH
81779: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
81783: LD_VAR 0 4
81787: PUSH
81788: LD_VAR 0 7
81792: ARRAY
81793: PPUSH
81794: LD_INT 71
81796: PPUSH
81797: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
81801: LD_ADDR_VAR 0 27
81805: PUSH
81806: LD_VAR 0 27
81810: PPUSH
81811: LD_VAR 0 27
81815: PUSH
81816: LD_INT 1
81818: PLUS
81819: PPUSH
81820: LD_VAR 0 14
81824: PUSH
81825: LD_INT 1
81827: ARRAY
81828: PPUSH
81829: CALL_OW 1
81833: ST_TO_ADDR
// attacking := true ;
81834: LD_ADDR_VAR 0 29
81838: PUSH
81839: LD_INT 1
81841: ST_TO_ADDR
// continue ;
81842: GO 79689
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
81844: LD_VAR 0 4
81848: PUSH
81849: LD_VAR 0 7
81853: ARRAY
81854: PPUSH
81855: CALL_OW 257
81859: PUSH
81860: LD_INT 17
81862: EQUAL
81863: PUSH
81864: LD_VAR 0 4
81868: PUSH
81869: LD_VAR 0 7
81873: ARRAY
81874: PPUSH
81875: CALL_OW 110
81879: PUSH
81880: LD_INT 71
81882: EQUAL
81883: NOT
81884: AND
81885: IFFALSE 82031
// begin attacking := false ;
81887: LD_ADDR_VAR 0 29
81891: PUSH
81892: LD_INT 0
81894: ST_TO_ADDR
// k := 5 ;
81895: LD_ADDR_VAR 0 9
81899: PUSH
81900: LD_INT 5
81902: ST_TO_ADDR
// if tmp < k then
81903: LD_VAR 0 14
81907: PUSH
81908: LD_VAR 0 9
81912: LESS
81913: IFFALSE 81925
// k := tmp ;
81915: LD_ADDR_VAR 0 9
81919: PUSH
81920: LD_VAR 0 14
81924: ST_TO_ADDR
// for j = 1 to k do
81925: LD_ADDR_VAR 0 8
81929: PUSH
81930: DOUBLE
81931: LD_INT 1
81933: DEC
81934: ST_TO_ADDR
81935: LD_VAR 0 9
81939: PUSH
81940: FOR_TO
81941: IFFALSE 82029
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
81943: LD_VAR 0 14
81947: PUSH
81948: LD_VAR 0 8
81952: ARRAY
81953: PUSH
81954: LD_VAR 0 14
81958: PPUSH
81959: LD_INT 58
81961: PUSH
81962: EMPTY
81963: LIST
81964: PPUSH
81965: CALL_OW 72
81969: IN
81970: NOT
81971: IFFALSE 82027
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81973: LD_VAR 0 4
81977: PUSH
81978: LD_VAR 0 7
81982: ARRAY
81983: PPUSH
81984: LD_VAR 0 14
81988: PUSH
81989: LD_VAR 0 8
81993: ARRAY
81994: PPUSH
81995: CALL_OW 115
// attacking := true ;
81999: LD_ADDR_VAR 0 29
82003: PUSH
82004: LD_INT 1
82006: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
82007: LD_VAR 0 4
82011: PUSH
82012: LD_VAR 0 7
82016: ARRAY
82017: PPUSH
82018: LD_INT 71
82020: PPUSH
82021: CALL_OW 109
// continue ;
82025: GO 81940
// end ; end ;
82027: GO 81940
82029: POP
82030: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
82031: LD_VAR 0 4
82035: PUSH
82036: LD_VAR 0 7
82040: ARRAY
82041: PPUSH
82042: CALL_OW 257
82046: PUSH
82047: LD_INT 8
82049: EQUAL
82050: PUSH
82051: LD_VAR 0 4
82055: PUSH
82056: LD_VAR 0 7
82060: ARRAY
82061: PPUSH
82062: CALL_OW 264
82066: PUSH
82067: LD_INT 28
82069: PUSH
82070: LD_INT 45
82072: PUSH
82073: LD_INT 7
82075: PUSH
82076: LD_INT 47
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: LIST
82083: LIST
82084: IN
82085: OR
82086: IFFALSE 82316
// begin attacking := false ;
82088: LD_ADDR_VAR 0 29
82092: PUSH
82093: LD_INT 0
82095: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
82096: LD_VAR 0 14
82100: PUSH
82101: LD_INT 1
82103: ARRAY
82104: PPUSH
82105: CALL_OW 266
82109: PUSH
82110: LD_INT 32
82112: PUSH
82113: LD_INT 31
82115: PUSH
82116: LD_INT 33
82118: PUSH
82119: LD_INT 4
82121: PUSH
82122: LD_INT 5
82124: PUSH
82125: EMPTY
82126: LIST
82127: LIST
82128: LIST
82129: LIST
82130: LIST
82131: IN
82132: IFFALSE 82316
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
82134: LD_ADDR_VAR 0 9
82138: PUSH
82139: LD_VAR 0 14
82143: PUSH
82144: LD_INT 1
82146: ARRAY
82147: PPUSH
82148: CALL_OW 266
82152: PPUSH
82153: LD_VAR 0 14
82157: PUSH
82158: LD_INT 1
82160: ARRAY
82161: PPUSH
82162: CALL_OW 250
82166: PPUSH
82167: LD_VAR 0 14
82171: PUSH
82172: LD_INT 1
82174: ARRAY
82175: PPUSH
82176: CALL_OW 251
82180: PPUSH
82181: LD_VAR 0 14
82185: PUSH
82186: LD_INT 1
82188: ARRAY
82189: PPUSH
82190: CALL_OW 254
82194: PPUSH
82195: LD_VAR 0 14
82199: PUSH
82200: LD_INT 1
82202: ARRAY
82203: PPUSH
82204: CALL_OW 248
82208: PPUSH
82209: LD_INT 0
82211: PPUSH
82212: CALL 58948 0 6
82216: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
82217: LD_ADDR_VAR 0 8
82221: PUSH
82222: LD_VAR 0 4
82226: PUSH
82227: LD_VAR 0 7
82231: ARRAY
82232: PPUSH
82233: LD_VAR 0 9
82237: PPUSH
82238: CALL 77635 0 2
82242: ST_TO_ADDR
// if j then
82243: LD_VAR 0 8
82247: IFFALSE 82316
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
82249: LD_VAR 0 8
82253: PUSH
82254: LD_INT 1
82256: ARRAY
82257: PPUSH
82258: LD_VAR 0 8
82262: PUSH
82263: LD_INT 2
82265: ARRAY
82266: PPUSH
82267: CALL_OW 488
82271: IFFALSE 82316
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
82273: LD_VAR 0 4
82277: PUSH
82278: LD_VAR 0 7
82282: ARRAY
82283: PPUSH
82284: LD_VAR 0 8
82288: PUSH
82289: LD_INT 1
82291: ARRAY
82292: PPUSH
82293: LD_VAR 0 8
82297: PUSH
82298: LD_INT 2
82300: ARRAY
82301: PPUSH
82302: CALL_OW 116
// attacking := true ;
82306: LD_ADDR_VAR 0 29
82310: PUSH
82311: LD_INT 1
82313: ST_TO_ADDR
// continue ;
82314: GO 79689
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
82316: LD_VAR 0 4
82320: PUSH
82321: LD_VAR 0 7
82325: ARRAY
82326: PPUSH
82327: CALL_OW 265
82331: PUSH
82332: LD_INT 11
82334: EQUAL
82335: IFFALSE 82613
// begin k := 10 ;
82337: LD_ADDR_VAR 0 9
82341: PUSH
82342: LD_INT 10
82344: ST_TO_ADDR
// x := 0 ;
82345: LD_ADDR_VAR 0 10
82349: PUSH
82350: LD_INT 0
82352: ST_TO_ADDR
// if tmp < k then
82353: LD_VAR 0 14
82357: PUSH
82358: LD_VAR 0 9
82362: LESS
82363: IFFALSE 82375
// k := tmp ;
82365: LD_ADDR_VAR 0 9
82369: PUSH
82370: LD_VAR 0 14
82374: ST_TO_ADDR
// for j = k downto 1 do
82375: LD_ADDR_VAR 0 8
82379: PUSH
82380: DOUBLE
82381: LD_VAR 0 9
82385: INC
82386: ST_TO_ADDR
82387: LD_INT 1
82389: PUSH
82390: FOR_DOWNTO
82391: IFFALSE 82466
// begin if GetType ( tmp [ j ] ) = unit_human then
82393: LD_VAR 0 14
82397: PUSH
82398: LD_VAR 0 8
82402: ARRAY
82403: PPUSH
82404: CALL_OW 247
82408: PUSH
82409: LD_INT 1
82411: EQUAL
82412: IFFALSE 82464
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
82414: LD_VAR 0 4
82418: PUSH
82419: LD_VAR 0 7
82423: ARRAY
82424: PPUSH
82425: LD_VAR 0 14
82429: PUSH
82430: LD_VAR 0 8
82434: ARRAY
82435: PPUSH
82436: CALL 77906 0 2
// x := tmp [ j ] ;
82440: LD_ADDR_VAR 0 10
82444: PUSH
82445: LD_VAR 0 14
82449: PUSH
82450: LD_VAR 0 8
82454: ARRAY
82455: ST_TO_ADDR
// attacking := true ;
82456: LD_ADDR_VAR 0 29
82460: PUSH
82461: LD_INT 1
82463: ST_TO_ADDR
// end ; end ;
82464: GO 82390
82466: POP
82467: POP
// if not x then
82468: LD_VAR 0 10
82472: NOT
82473: IFFALSE 82613
// begin attacking := true ;
82475: LD_ADDR_VAR 0 29
82479: PUSH
82480: LD_INT 1
82482: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
82483: LD_VAR 0 4
82487: PUSH
82488: LD_VAR 0 7
82492: ARRAY
82493: PPUSH
82494: CALL_OW 250
82498: PPUSH
82499: LD_VAR 0 4
82503: PUSH
82504: LD_VAR 0 7
82508: ARRAY
82509: PPUSH
82510: CALL_OW 251
82514: PPUSH
82515: CALL_OW 546
82519: PUSH
82520: LD_INT 2
82522: ARRAY
82523: PUSH
82524: LD_VAR 0 14
82528: PUSH
82529: LD_INT 1
82531: ARRAY
82532: PPUSH
82533: CALL_OW 250
82537: PPUSH
82538: LD_VAR 0 14
82542: PUSH
82543: LD_INT 1
82545: ARRAY
82546: PPUSH
82547: CALL_OW 251
82551: PPUSH
82552: CALL_OW 546
82556: PUSH
82557: LD_INT 2
82559: ARRAY
82560: EQUAL
82561: IFFALSE 82589
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
82563: LD_VAR 0 4
82567: PUSH
82568: LD_VAR 0 7
82572: ARRAY
82573: PPUSH
82574: LD_VAR 0 14
82578: PUSH
82579: LD_INT 1
82581: ARRAY
82582: PPUSH
82583: CALL 77906 0 2
82587: GO 82613
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82589: LD_VAR 0 4
82593: PUSH
82594: LD_VAR 0 7
82598: ARRAY
82599: PPUSH
82600: LD_VAR 0 14
82604: PUSH
82605: LD_INT 1
82607: ARRAY
82608: PPUSH
82609: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
82613: LD_VAR 0 4
82617: PUSH
82618: LD_VAR 0 7
82622: ARRAY
82623: PPUSH
82624: CALL_OW 264
82628: PUSH
82629: LD_INT 29
82631: EQUAL
82632: IFFALSE 82998
// begin if WantsToAttack ( group [ i ] ) in bombed then
82634: LD_VAR 0 4
82638: PUSH
82639: LD_VAR 0 7
82643: ARRAY
82644: PPUSH
82645: CALL_OW 319
82649: PUSH
82650: LD_VAR 0 28
82654: IN
82655: IFFALSE 82659
// continue ;
82657: GO 79689
// k := 8 ;
82659: LD_ADDR_VAR 0 9
82663: PUSH
82664: LD_INT 8
82666: ST_TO_ADDR
// x := 0 ;
82667: LD_ADDR_VAR 0 10
82671: PUSH
82672: LD_INT 0
82674: ST_TO_ADDR
// if tmp < k then
82675: LD_VAR 0 14
82679: PUSH
82680: LD_VAR 0 9
82684: LESS
82685: IFFALSE 82697
// k := tmp ;
82687: LD_ADDR_VAR 0 9
82691: PUSH
82692: LD_VAR 0 14
82696: ST_TO_ADDR
// for j = 1 to k do
82697: LD_ADDR_VAR 0 8
82701: PUSH
82702: DOUBLE
82703: LD_INT 1
82705: DEC
82706: ST_TO_ADDR
82707: LD_VAR 0 9
82711: PUSH
82712: FOR_TO
82713: IFFALSE 82845
// begin if GetType ( tmp [ j ] ) = unit_building then
82715: LD_VAR 0 14
82719: PUSH
82720: LD_VAR 0 8
82724: ARRAY
82725: PPUSH
82726: CALL_OW 247
82730: PUSH
82731: LD_INT 3
82733: EQUAL
82734: IFFALSE 82843
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
82736: LD_VAR 0 14
82740: PUSH
82741: LD_VAR 0 8
82745: ARRAY
82746: PUSH
82747: LD_VAR 0 28
82751: IN
82752: NOT
82753: PUSH
82754: LD_VAR 0 14
82758: PUSH
82759: LD_VAR 0 8
82763: ARRAY
82764: PPUSH
82765: CALL_OW 313
82769: AND
82770: IFFALSE 82843
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
82772: LD_VAR 0 4
82776: PUSH
82777: LD_VAR 0 7
82781: ARRAY
82782: PPUSH
82783: LD_VAR 0 14
82787: PUSH
82788: LD_VAR 0 8
82792: ARRAY
82793: PPUSH
82794: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
82798: LD_ADDR_VAR 0 28
82802: PUSH
82803: LD_VAR 0 28
82807: PPUSH
82808: LD_VAR 0 28
82812: PUSH
82813: LD_INT 1
82815: PLUS
82816: PPUSH
82817: LD_VAR 0 14
82821: PUSH
82822: LD_VAR 0 8
82826: ARRAY
82827: PPUSH
82828: CALL_OW 1
82832: ST_TO_ADDR
// attacking := true ;
82833: LD_ADDR_VAR 0 29
82837: PUSH
82838: LD_INT 1
82840: ST_TO_ADDR
// break ;
82841: GO 82845
// end ; end ;
82843: GO 82712
82845: POP
82846: POP
// if not attacking and f_attack_depot then
82847: LD_VAR 0 29
82851: NOT
82852: PUSH
82853: LD_VAR 0 25
82857: AND
82858: IFFALSE 82953
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82860: LD_ADDR_VAR 0 13
82864: PUSH
82865: LD_VAR 0 14
82869: PPUSH
82870: LD_INT 2
82872: PUSH
82873: LD_INT 30
82875: PUSH
82876: LD_INT 0
82878: PUSH
82879: EMPTY
82880: LIST
82881: LIST
82882: PUSH
82883: LD_INT 30
82885: PUSH
82886: LD_INT 1
82888: PUSH
82889: EMPTY
82890: LIST
82891: LIST
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: LIST
82897: PPUSH
82898: CALL_OW 72
82902: ST_TO_ADDR
// if z then
82903: LD_VAR 0 13
82907: IFFALSE 82953
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
82909: LD_VAR 0 4
82913: PUSH
82914: LD_VAR 0 7
82918: ARRAY
82919: PPUSH
82920: LD_VAR 0 13
82924: PPUSH
82925: LD_VAR 0 4
82929: PUSH
82930: LD_VAR 0 7
82934: ARRAY
82935: PPUSH
82936: CALL_OW 74
82940: PPUSH
82941: CALL_OW 115
// attacking := true ;
82945: LD_ADDR_VAR 0 29
82949: PUSH
82950: LD_INT 1
82952: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
82953: LD_VAR 0 4
82957: PUSH
82958: LD_VAR 0 7
82962: ARRAY
82963: PPUSH
82964: CALL_OW 256
82968: PUSH
82969: LD_INT 500
82971: LESS
82972: IFFALSE 82998
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82974: LD_VAR 0 4
82978: PUSH
82979: LD_VAR 0 7
82983: ARRAY
82984: PPUSH
82985: LD_VAR 0 14
82989: PUSH
82990: LD_INT 1
82992: ARRAY
82993: PPUSH
82994: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
82998: LD_VAR 0 4
83002: PUSH
83003: LD_VAR 0 7
83007: ARRAY
83008: PPUSH
83009: CALL_OW 264
83013: PUSH
83014: LD_INT 49
83016: EQUAL
83017: IFFALSE 83138
// begin if not HasTask ( group [ i ] ) then
83019: LD_VAR 0 4
83023: PUSH
83024: LD_VAR 0 7
83028: ARRAY
83029: PPUSH
83030: CALL_OW 314
83034: NOT
83035: IFFALSE 83138
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
83037: LD_ADDR_VAR 0 9
83041: PUSH
83042: LD_INT 81
83044: PUSH
83045: LD_VAR 0 4
83049: PUSH
83050: LD_VAR 0 7
83054: ARRAY
83055: PPUSH
83056: CALL_OW 255
83060: PUSH
83061: EMPTY
83062: LIST
83063: LIST
83064: PPUSH
83065: CALL_OW 69
83069: PPUSH
83070: LD_VAR 0 4
83074: PUSH
83075: LD_VAR 0 7
83079: ARRAY
83080: PPUSH
83081: CALL_OW 74
83085: ST_TO_ADDR
// if k then
83086: LD_VAR 0 9
83090: IFFALSE 83138
// if GetDistUnits ( group [ i ] , k ) > 10 then
83092: LD_VAR 0 4
83096: PUSH
83097: LD_VAR 0 7
83101: ARRAY
83102: PPUSH
83103: LD_VAR 0 9
83107: PPUSH
83108: CALL_OW 296
83112: PUSH
83113: LD_INT 10
83115: GREATER
83116: IFFALSE 83138
// ComMoveUnit ( group [ i ] , k ) ;
83118: LD_VAR 0 4
83122: PUSH
83123: LD_VAR 0 7
83127: ARRAY
83128: PPUSH
83129: LD_VAR 0 9
83133: PPUSH
83134: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
83138: LD_VAR 0 4
83142: PUSH
83143: LD_VAR 0 7
83147: ARRAY
83148: PPUSH
83149: CALL_OW 256
83153: PUSH
83154: LD_INT 250
83156: LESS
83157: PUSH
83158: LD_VAR 0 4
83162: PUSH
83163: LD_VAR 0 7
83167: ARRAY
83168: PUSH
83169: LD_INT 21
83171: PUSH
83172: LD_INT 2
83174: PUSH
83175: EMPTY
83176: LIST
83177: LIST
83178: PUSH
83179: LD_INT 23
83181: PUSH
83182: LD_INT 2
83184: PUSH
83185: EMPTY
83186: LIST
83187: LIST
83188: PUSH
83189: EMPTY
83190: LIST
83191: LIST
83192: PPUSH
83193: CALL_OW 69
83197: IN
83198: AND
83199: IFFALSE 83324
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
83201: LD_ADDR_VAR 0 9
83205: PUSH
83206: LD_OWVAR 3
83210: PUSH
83211: LD_VAR 0 4
83215: PUSH
83216: LD_VAR 0 7
83220: ARRAY
83221: DIFF
83222: PPUSH
83223: LD_VAR 0 4
83227: PUSH
83228: LD_VAR 0 7
83232: ARRAY
83233: PPUSH
83234: CALL_OW 74
83238: ST_TO_ADDR
// if not k then
83239: LD_VAR 0 9
83243: NOT
83244: IFFALSE 83248
// continue ;
83246: GO 79689
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
83248: LD_VAR 0 9
83252: PUSH
83253: LD_INT 81
83255: PUSH
83256: LD_VAR 0 4
83260: PUSH
83261: LD_VAR 0 7
83265: ARRAY
83266: PPUSH
83267: CALL_OW 255
83271: PUSH
83272: EMPTY
83273: LIST
83274: LIST
83275: PPUSH
83276: CALL_OW 69
83280: IN
83281: PUSH
83282: LD_VAR 0 9
83286: PPUSH
83287: LD_VAR 0 4
83291: PUSH
83292: LD_VAR 0 7
83296: ARRAY
83297: PPUSH
83298: CALL_OW 296
83302: PUSH
83303: LD_INT 5
83305: LESS
83306: AND
83307: IFFALSE 83324
// ComAutodestruct ( group [ i ] ) ;
83309: LD_VAR 0 4
83313: PUSH
83314: LD_VAR 0 7
83318: ARRAY
83319: PPUSH
83320: CALL 77804 0 1
// end ; if f_attack_depot then
83324: LD_VAR 0 25
83328: IFFALSE 83440
// begin k := 6 ;
83330: LD_ADDR_VAR 0 9
83334: PUSH
83335: LD_INT 6
83337: ST_TO_ADDR
// if tmp < k then
83338: LD_VAR 0 14
83342: PUSH
83343: LD_VAR 0 9
83347: LESS
83348: IFFALSE 83360
// k := tmp ;
83350: LD_ADDR_VAR 0 9
83354: PUSH
83355: LD_VAR 0 14
83359: ST_TO_ADDR
// for j = 1 to k do
83360: LD_ADDR_VAR 0 8
83364: PUSH
83365: DOUBLE
83366: LD_INT 1
83368: DEC
83369: ST_TO_ADDR
83370: LD_VAR 0 9
83374: PUSH
83375: FOR_TO
83376: IFFALSE 83438
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
83378: LD_VAR 0 8
83382: PPUSH
83383: CALL_OW 266
83387: PUSH
83388: LD_INT 0
83390: PUSH
83391: LD_INT 1
83393: PUSH
83394: EMPTY
83395: LIST
83396: LIST
83397: IN
83398: IFFALSE 83436
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83400: LD_VAR 0 4
83404: PUSH
83405: LD_VAR 0 7
83409: ARRAY
83410: PPUSH
83411: LD_VAR 0 14
83415: PUSH
83416: LD_VAR 0 8
83420: ARRAY
83421: PPUSH
83422: CALL_OW 115
// attacking := true ;
83426: LD_ADDR_VAR 0 29
83430: PUSH
83431: LD_INT 1
83433: ST_TO_ADDR
// break ;
83434: GO 83438
// end ;
83436: GO 83375
83438: POP
83439: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
83440: LD_VAR 0 4
83444: PUSH
83445: LD_VAR 0 7
83449: ARRAY
83450: PPUSH
83451: CALL_OW 302
83455: PUSH
83456: LD_VAR 0 29
83460: NOT
83461: AND
83462: IFFALSE 83784
// begin if GetTag ( group [ i ] ) = 71 then
83464: LD_VAR 0 4
83468: PUSH
83469: LD_VAR 0 7
83473: ARRAY
83474: PPUSH
83475: CALL_OW 110
83479: PUSH
83480: LD_INT 71
83482: EQUAL
83483: IFFALSE 83524
// begin if HasTask ( group [ i ] ) then
83485: LD_VAR 0 4
83489: PUSH
83490: LD_VAR 0 7
83494: ARRAY
83495: PPUSH
83496: CALL_OW 314
83500: IFFALSE 83506
// continue else
83502: GO 79689
83504: GO 83524
// SetTag ( group [ i ] , 0 ) ;
83506: LD_VAR 0 4
83510: PUSH
83511: LD_VAR 0 7
83515: ARRAY
83516: PPUSH
83517: LD_INT 0
83519: PPUSH
83520: CALL_OW 109
// end ; k := 8 ;
83524: LD_ADDR_VAR 0 9
83528: PUSH
83529: LD_INT 8
83531: ST_TO_ADDR
// x := 0 ;
83532: LD_ADDR_VAR 0 10
83536: PUSH
83537: LD_INT 0
83539: ST_TO_ADDR
// if tmp < k then
83540: LD_VAR 0 14
83544: PUSH
83545: LD_VAR 0 9
83549: LESS
83550: IFFALSE 83562
// k := tmp ;
83552: LD_ADDR_VAR 0 9
83556: PUSH
83557: LD_VAR 0 14
83561: ST_TO_ADDR
// for j = 1 to k do
83562: LD_ADDR_VAR 0 8
83566: PUSH
83567: DOUBLE
83568: LD_INT 1
83570: DEC
83571: ST_TO_ADDR
83572: LD_VAR 0 9
83576: PUSH
83577: FOR_TO
83578: IFFALSE 83676
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
83580: LD_VAR 0 14
83584: PUSH
83585: LD_VAR 0 8
83589: ARRAY
83590: PPUSH
83591: CALL_OW 247
83595: PUSH
83596: LD_INT 1
83598: EQUAL
83599: PUSH
83600: LD_VAR 0 14
83604: PUSH
83605: LD_VAR 0 8
83609: ARRAY
83610: PPUSH
83611: CALL_OW 256
83615: PUSH
83616: LD_INT 250
83618: LESS
83619: PUSH
83620: LD_VAR 0 20
83624: AND
83625: PUSH
83626: LD_VAR 0 20
83630: NOT
83631: PUSH
83632: LD_VAR 0 14
83636: PUSH
83637: LD_VAR 0 8
83641: ARRAY
83642: PPUSH
83643: CALL_OW 256
83647: PUSH
83648: LD_INT 250
83650: GREATEREQUAL
83651: AND
83652: OR
83653: AND
83654: IFFALSE 83674
// begin x := tmp [ j ] ;
83656: LD_ADDR_VAR 0 10
83660: PUSH
83661: LD_VAR 0 14
83665: PUSH
83666: LD_VAR 0 8
83670: ARRAY
83671: ST_TO_ADDR
// break ;
83672: GO 83676
// end ;
83674: GO 83577
83676: POP
83677: POP
// if x then
83678: LD_VAR 0 10
83682: IFFALSE 83706
// ComAttackUnit ( group [ i ] , x ) else
83684: LD_VAR 0 4
83688: PUSH
83689: LD_VAR 0 7
83693: ARRAY
83694: PPUSH
83695: LD_VAR 0 10
83699: PPUSH
83700: CALL_OW 115
83704: GO 83730
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83706: LD_VAR 0 4
83710: PUSH
83711: LD_VAR 0 7
83715: ARRAY
83716: PPUSH
83717: LD_VAR 0 14
83721: PUSH
83722: LD_INT 1
83724: ARRAY
83725: PPUSH
83726: CALL_OW 115
// if not HasTask ( group [ i ] ) then
83730: LD_VAR 0 4
83734: PUSH
83735: LD_VAR 0 7
83739: ARRAY
83740: PPUSH
83741: CALL_OW 314
83745: NOT
83746: IFFALSE 83784
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
83748: LD_VAR 0 4
83752: PUSH
83753: LD_VAR 0 7
83757: ARRAY
83758: PPUSH
83759: LD_VAR 0 14
83763: PPUSH
83764: LD_VAR 0 4
83768: PUSH
83769: LD_VAR 0 7
83773: ARRAY
83774: PPUSH
83775: CALL_OW 74
83779: PPUSH
83780: CALL_OW 115
// end ; end ; end ;
83784: GO 79689
83786: POP
83787: POP
// wait ( 0 0$1 ) ;
83788: LD_INT 35
83790: PPUSH
83791: CALL_OW 67
// until group = [ ] ;
83795: LD_VAR 0 4
83799: PUSH
83800: EMPTY
83801: EQUAL
83802: IFFALSE 79674
// end ;
83804: LD_VAR 0 2
83808: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
83809: LD_INT 0
83811: PPUSH
83812: PPUSH
83813: PPUSH
83814: PPUSH
// if not base_units then
83815: LD_VAR 0 1
83819: NOT
83820: IFFALSE 83824
// exit ;
83822: GO 83911
// result := false ;
83824: LD_ADDR_VAR 0 2
83828: PUSH
83829: LD_INT 0
83831: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
83832: LD_ADDR_VAR 0 5
83836: PUSH
83837: LD_VAR 0 1
83841: PPUSH
83842: LD_INT 21
83844: PUSH
83845: LD_INT 3
83847: PUSH
83848: EMPTY
83849: LIST
83850: LIST
83851: PPUSH
83852: CALL_OW 72
83856: ST_TO_ADDR
// if not tmp then
83857: LD_VAR 0 5
83861: NOT
83862: IFFALSE 83866
// exit ;
83864: GO 83911
// for i in tmp do
83866: LD_ADDR_VAR 0 3
83870: PUSH
83871: LD_VAR 0 5
83875: PUSH
83876: FOR_IN
83877: IFFALSE 83909
// begin result := EnemyInRange ( i , 22 ) ;
83879: LD_ADDR_VAR 0 2
83883: PUSH
83884: LD_VAR 0 3
83888: PPUSH
83889: LD_INT 22
83891: PPUSH
83892: CALL 77487 0 2
83896: ST_TO_ADDR
// if result then
83897: LD_VAR 0 2
83901: IFFALSE 83907
// exit ;
83903: POP
83904: POP
83905: GO 83911
// end ;
83907: GO 83876
83909: POP
83910: POP
// end ;
83911: LD_VAR 0 2
83915: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
83916: LD_INT 0
83918: PPUSH
83919: PPUSH
// if not units then
83920: LD_VAR 0 1
83924: NOT
83925: IFFALSE 83929
// exit ;
83927: GO 83999
// result := [ ] ;
83929: LD_ADDR_VAR 0 3
83933: PUSH
83934: EMPTY
83935: ST_TO_ADDR
// for i in units do
83936: LD_ADDR_VAR 0 4
83940: PUSH
83941: LD_VAR 0 1
83945: PUSH
83946: FOR_IN
83947: IFFALSE 83997
// if GetTag ( i ) = tag then
83949: LD_VAR 0 4
83953: PPUSH
83954: CALL_OW 110
83958: PUSH
83959: LD_VAR 0 2
83963: EQUAL
83964: IFFALSE 83995
// result := Insert ( result , result + 1 , i ) ;
83966: LD_ADDR_VAR 0 3
83970: PUSH
83971: LD_VAR 0 3
83975: PPUSH
83976: LD_VAR 0 3
83980: PUSH
83981: LD_INT 1
83983: PLUS
83984: PPUSH
83985: LD_VAR 0 4
83989: PPUSH
83990: CALL_OW 2
83994: ST_TO_ADDR
83995: GO 83946
83997: POP
83998: POP
// end ;
83999: LD_VAR 0 3
84003: RET
// export function IsDriver ( un ) ; begin
84004: LD_INT 0
84006: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84007: LD_ADDR_VAR 0 2
84011: PUSH
84012: LD_VAR 0 1
84016: PUSH
84017: LD_INT 55
84019: PUSH
84020: EMPTY
84021: LIST
84022: PPUSH
84023: CALL_OW 69
84027: IN
84028: ST_TO_ADDR
// end ;
84029: LD_VAR 0 2
84033: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84034: LD_INT 0
84036: PPUSH
84037: PPUSH
// list := [ ] ;
84038: LD_ADDR_VAR 0 5
84042: PUSH
84043: EMPTY
84044: ST_TO_ADDR
// case d of 0 :
84045: LD_VAR 0 3
84049: PUSH
84050: LD_INT 0
84052: DOUBLE
84053: EQUAL
84054: IFTRUE 84058
84056: GO 84191
84058: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84059: LD_ADDR_VAR 0 5
84063: PUSH
84064: LD_VAR 0 1
84068: PUSH
84069: LD_INT 4
84071: MINUS
84072: PUSH
84073: LD_VAR 0 2
84077: PUSH
84078: LD_INT 4
84080: MINUS
84081: PUSH
84082: LD_INT 2
84084: PUSH
84085: EMPTY
84086: LIST
84087: LIST
84088: LIST
84089: PUSH
84090: LD_VAR 0 1
84094: PUSH
84095: LD_INT 3
84097: MINUS
84098: PUSH
84099: LD_VAR 0 2
84103: PUSH
84104: LD_INT 1
84106: PUSH
84107: EMPTY
84108: LIST
84109: LIST
84110: LIST
84111: PUSH
84112: LD_VAR 0 1
84116: PUSH
84117: LD_INT 4
84119: PLUS
84120: PUSH
84121: LD_VAR 0 2
84125: PUSH
84126: LD_INT 4
84128: PUSH
84129: EMPTY
84130: LIST
84131: LIST
84132: LIST
84133: PUSH
84134: LD_VAR 0 1
84138: PUSH
84139: LD_INT 3
84141: PLUS
84142: PUSH
84143: LD_VAR 0 2
84147: PUSH
84148: LD_INT 3
84150: PLUS
84151: PUSH
84152: LD_INT 5
84154: PUSH
84155: EMPTY
84156: LIST
84157: LIST
84158: LIST
84159: PUSH
84160: LD_VAR 0 1
84164: PUSH
84165: LD_VAR 0 2
84169: PUSH
84170: LD_INT 4
84172: PLUS
84173: PUSH
84174: LD_INT 0
84176: PUSH
84177: EMPTY
84178: LIST
84179: LIST
84180: LIST
84181: PUSH
84182: EMPTY
84183: LIST
84184: LIST
84185: LIST
84186: LIST
84187: LIST
84188: ST_TO_ADDR
// end ; 1 :
84189: GO 84889
84191: LD_INT 1
84193: DOUBLE
84194: EQUAL
84195: IFTRUE 84199
84197: GO 84332
84199: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84200: LD_ADDR_VAR 0 5
84204: PUSH
84205: LD_VAR 0 1
84209: PUSH
84210: LD_VAR 0 2
84214: PUSH
84215: LD_INT 4
84217: MINUS
84218: PUSH
84219: LD_INT 3
84221: PUSH
84222: EMPTY
84223: LIST
84224: LIST
84225: LIST
84226: PUSH
84227: LD_VAR 0 1
84231: PUSH
84232: LD_INT 3
84234: MINUS
84235: PUSH
84236: LD_VAR 0 2
84240: PUSH
84241: LD_INT 3
84243: MINUS
84244: PUSH
84245: LD_INT 2
84247: PUSH
84248: EMPTY
84249: LIST
84250: LIST
84251: LIST
84252: PUSH
84253: LD_VAR 0 1
84257: PUSH
84258: LD_INT 4
84260: MINUS
84261: PUSH
84262: LD_VAR 0 2
84266: PUSH
84267: LD_INT 1
84269: PUSH
84270: EMPTY
84271: LIST
84272: LIST
84273: LIST
84274: PUSH
84275: LD_VAR 0 1
84279: PUSH
84280: LD_VAR 0 2
84284: PUSH
84285: LD_INT 3
84287: PLUS
84288: PUSH
84289: LD_INT 0
84291: PUSH
84292: EMPTY
84293: LIST
84294: LIST
84295: LIST
84296: PUSH
84297: LD_VAR 0 1
84301: PUSH
84302: LD_INT 4
84304: PLUS
84305: PUSH
84306: LD_VAR 0 2
84310: PUSH
84311: LD_INT 4
84313: PLUS
84314: PUSH
84315: LD_INT 5
84317: PUSH
84318: EMPTY
84319: LIST
84320: LIST
84321: LIST
84322: PUSH
84323: EMPTY
84324: LIST
84325: LIST
84326: LIST
84327: LIST
84328: LIST
84329: ST_TO_ADDR
// end ; 2 :
84330: GO 84889
84332: LD_INT 2
84334: DOUBLE
84335: EQUAL
84336: IFTRUE 84340
84338: GO 84469
84340: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84341: LD_ADDR_VAR 0 5
84345: PUSH
84346: LD_VAR 0 1
84350: PUSH
84351: LD_VAR 0 2
84355: PUSH
84356: LD_INT 3
84358: MINUS
84359: PUSH
84360: LD_INT 3
84362: PUSH
84363: EMPTY
84364: LIST
84365: LIST
84366: LIST
84367: PUSH
84368: LD_VAR 0 1
84372: PUSH
84373: LD_INT 4
84375: PLUS
84376: PUSH
84377: LD_VAR 0 2
84381: PUSH
84382: LD_INT 4
84384: PUSH
84385: EMPTY
84386: LIST
84387: LIST
84388: LIST
84389: PUSH
84390: LD_VAR 0 1
84394: PUSH
84395: LD_VAR 0 2
84399: PUSH
84400: LD_INT 4
84402: PLUS
84403: PUSH
84404: LD_INT 0
84406: PUSH
84407: EMPTY
84408: LIST
84409: LIST
84410: LIST
84411: PUSH
84412: LD_VAR 0 1
84416: PUSH
84417: LD_INT 3
84419: MINUS
84420: PUSH
84421: LD_VAR 0 2
84425: PUSH
84426: LD_INT 1
84428: PUSH
84429: EMPTY
84430: LIST
84431: LIST
84432: LIST
84433: PUSH
84434: LD_VAR 0 1
84438: PUSH
84439: LD_INT 4
84441: MINUS
84442: PUSH
84443: LD_VAR 0 2
84447: PUSH
84448: LD_INT 4
84450: MINUS
84451: PUSH
84452: LD_INT 2
84454: PUSH
84455: EMPTY
84456: LIST
84457: LIST
84458: LIST
84459: PUSH
84460: EMPTY
84461: LIST
84462: LIST
84463: LIST
84464: LIST
84465: LIST
84466: ST_TO_ADDR
// end ; 3 :
84467: GO 84889
84469: LD_INT 3
84471: DOUBLE
84472: EQUAL
84473: IFTRUE 84477
84475: GO 84610
84477: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84478: LD_ADDR_VAR 0 5
84482: PUSH
84483: LD_VAR 0 1
84487: PUSH
84488: LD_INT 3
84490: PLUS
84491: PUSH
84492: LD_VAR 0 2
84496: PUSH
84497: LD_INT 4
84499: PUSH
84500: EMPTY
84501: LIST
84502: LIST
84503: LIST
84504: PUSH
84505: LD_VAR 0 1
84509: PUSH
84510: LD_INT 4
84512: PLUS
84513: PUSH
84514: LD_VAR 0 2
84518: PUSH
84519: LD_INT 4
84521: PLUS
84522: PUSH
84523: LD_INT 5
84525: PUSH
84526: EMPTY
84527: LIST
84528: LIST
84529: LIST
84530: PUSH
84531: LD_VAR 0 1
84535: PUSH
84536: LD_INT 4
84538: MINUS
84539: PUSH
84540: LD_VAR 0 2
84544: PUSH
84545: LD_INT 1
84547: PUSH
84548: EMPTY
84549: LIST
84550: LIST
84551: LIST
84552: PUSH
84553: LD_VAR 0 1
84557: PUSH
84558: LD_VAR 0 2
84562: PUSH
84563: LD_INT 4
84565: MINUS
84566: PUSH
84567: LD_INT 3
84569: PUSH
84570: EMPTY
84571: LIST
84572: LIST
84573: LIST
84574: PUSH
84575: LD_VAR 0 1
84579: PUSH
84580: LD_INT 3
84582: MINUS
84583: PUSH
84584: LD_VAR 0 2
84588: PUSH
84589: LD_INT 3
84591: MINUS
84592: PUSH
84593: LD_INT 2
84595: PUSH
84596: EMPTY
84597: LIST
84598: LIST
84599: LIST
84600: PUSH
84601: EMPTY
84602: LIST
84603: LIST
84604: LIST
84605: LIST
84606: LIST
84607: ST_TO_ADDR
// end ; 4 :
84608: GO 84889
84610: LD_INT 4
84612: DOUBLE
84613: EQUAL
84614: IFTRUE 84618
84616: GO 84751
84618: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84619: LD_ADDR_VAR 0 5
84623: PUSH
84624: LD_VAR 0 1
84628: PUSH
84629: LD_VAR 0 2
84633: PUSH
84634: LD_INT 4
84636: PLUS
84637: PUSH
84638: LD_INT 0
84640: PUSH
84641: EMPTY
84642: LIST
84643: LIST
84644: LIST
84645: PUSH
84646: LD_VAR 0 1
84650: PUSH
84651: LD_INT 3
84653: PLUS
84654: PUSH
84655: LD_VAR 0 2
84659: PUSH
84660: LD_INT 3
84662: PLUS
84663: PUSH
84664: LD_INT 5
84666: PUSH
84667: EMPTY
84668: LIST
84669: LIST
84670: LIST
84671: PUSH
84672: LD_VAR 0 1
84676: PUSH
84677: LD_INT 4
84679: PLUS
84680: PUSH
84681: LD_VAR 0 2
84685: PUSH
84686: LD_INT 4
84688: PUSH
84689: EMPTY
84690: LIST
84691: LIST
84692: LIST
84693: PUSH
84694: LD_VAR 0 1
84698: PUSH
84699: LD_VAR 0 2
84703: PUSH
84704: LD_INT 3
84706: MINUS
84707: PUSH
84708: LD_INT 3
84710: PUSH
84711: EMPTY
84712: LIST
84713: LIST
84714: LIST
84715: PUSH
84716: LD_VAR 0 1
84720: PUSH
84721: LD_INT 4
84723: MINUS
84724: PUSH
84725: LD_VAR 0 2
84729: PUSH
84730: LD_INT 4
84732: MINUS
84733: PUSH
84734: LD_INT 2
84736: PUSH
84737: EMPTY
84738: LIST
84739: LIST
84740: LIST
84741: PUSH
84742: EMPTY
84743: LIST
84744: LIST
84745: LIST
84746: LIST
84747: LIST
84748: ST_TO_ADDR
// end ; 5 :
84749: GO 84889
84751: LD_INT 5
84753: DOUBLE
84754: EQUAL
84755: IFTRUE 84759
84757: GO 84888
84759: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
84760: LD_ADDR_VAR 0 5
84764: PUSH
84765: LD_VAR 0 1
84769: PUSH
84770: LD_INT 4
84772: MINUS
84773: PUSH
84774: LD_VAR 0 2
84778: PUSH
84779: LD_INT 1
84781: PUSH
84782: EMPTY
84783: LIST
84784: LIST
84785: LIST
84786: PUSH
84787: LD_VAR 0 1
84791: PUSH
84792: LD_VAR 0 2
84796: PUSH
84797: LD_INT 4
84799: MINUS
84800: PUSH
84801: LD_INT 3
84803: PUSH
84804: EMPTY
84805: LIST
84806: LIST
84807: LIST
84808: PUSH
84809: LD_VAR 0 1
84813: PUSH
84814: LD_INT 4
84816: PLUS
84817: PUSH
84818: LD_VAR 0 2
84822: PUSH
84823: LD_INT 4
84825: PLUS
84826: PUSH
84827: LD_INT 5
84829: PUSH
84830: EMPTY
84831: LIST
84832: LIST
84833: LIST
84834: PUSH
84835: LD_VAR 0 1
84839: PUSH
84840: LD_INT 3
84842: PLUS
84843: PUSH
84844: LD_VAR 0 2
84848: PUSH
84849: LD_INT 4
84851: PUSH
84852: EMPTY
84853: LIST
84854: LIST
84855: LIST
84856: PUSH
84857: LD_VAR 0 1
84861: PUSH
84862: LD_VAR 0 2
84866: PUSH
84867: LD_INT 3
84869: PLUS
84870: PUSH
84871: LD_INT 0
84873: PUSH
84874: EMPTY
84875: LIST
84876: LIST
84877: LIST
84878: PUSH
84879: EMPTY
84880: LIST
84881: LIST
84882: LIST
84883: LIST
84884: LIST
84885: ST_TO_ADDR
// end ; end ;
84886: GO 84889
84888: POP
// result := list ;
84889: LD_ADDR_VAR 0 4
84893: PUSH
84894: LD_VAR 0 5
84898: ST_TO_ADDR
// end ;
84899: LD_VAR 0 4
84903: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
84904: LD_INT 0
84906: PPUSH
84907: PPUSH
84908: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
84909: LD_VAR 0 1
84913: NOT
84914: PUSH
84915: LD_VAR 0 2
84919: PUSH
84920: LD_INT 1
84922: PUSH
84923: LD_INT 2
84925: PUSH
84926: LD_INT 3
84928: PUSH
84929: LD_INT 4
84931: PUSH
84932: EMPTY
84933: LIST
84934: LIST
84935: LIST
84936: LIST
84937: IN
84938: NOT
84939: OR
84940: IFFALSE 84944
// exit ;
84942: GO 85036
// tmp := [ ] ;
84944: LD_ADDR_VAR 0 5
84948: PUSH
84949: EMPTY
84950: ST_TO_ADDR
// for i in units do
84951: LD_ADDR_VAR 0 4
84955: PUSH
84956: LD_VAR 0 1
84960: PUSH
84961: FOR_IN
84962: IFFALSE 85005
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
84964: LD_ADDR_VAR 0 5
84968: PUSH
84969: LD_VAR 0 5
84973: PPUSH
84974: LD_VAR 0 5
84978: PUSH
84979: LD_INT 1
84981: PLUS
84982: PPUSH
84983: LD_VAR 0 4
84987: PPUSH
84988: LD_VAR 0 2
84992: PPUSH
84993: CALL_OW 259
84997: PPUSH
84998: CALL_OW 2
85002: ST_TO_ADDR
85003: GO 84961
85005: POP
85006: POP
// if not tmp then
85007: LD_VAR 0 5
85011: NOT
85012: IFFALSE 85016
// exit ;
85014: GO 85036
// result := SortListByListDesc ( units , tmp ) ;
85016: LD_ADDR_VAR 0 3
85020: PUSH
85021: LD_VAR 0 1
85025: PPUSH
85026: LD_VAR 0 5
85030: PPUSH
85031: CALL_OW 77
85035: ST_TO_ADDR
// end ;
85036: LD_VAR 0 3
85040: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85041: LD_INT 0
85043: PPUSH
85044: PPUSH
85045: PPUSH
// x := GetX ( building ) ;
85046: LD_ADDR_VAR 0 4
85050: PUSH
85051: LD_VAR 0 2
85055: PPUSH
85056: CALL_OW 250
85060: ST_TO_ADDR
// y := GetY ( building ) ;
85061: LD_ADDR_VAR 0 5
85065: PUSH
85066: LD_VAR 0 2
85070: PPUSH
85071: CALL_OW 251
85075: ST_TO_ADDR
// if GetTaskList ( unit ) then
85076: LD_VAR 0 1
85080: PPUSH
85081: CALL_OW 437
85085: IFFALSE 85180
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85087: LD_STRING e
85089: PUSH
85090: LD_VAR 0 1
85094: PPUSH
85095: CALL_OW 437
85099: PUSH
85100: LD_INT 1
85102: ARRAY
85103: PUSH
85104: LD_INT 1
85106: ARRAY
85107: EQUAL
85108: PUSH
85109: LD_VAR 0 4
85113: PUSH
85114: LD_VAR 0 1
85118: PPUSH
85119: CALL_OW 437
85123: PUSH
85124: LD_INT 1
85126: ARRAY
85127: PUSH
85128: LD_INT 2
85130: ARRAY
85131: EQUAL
85132: AND
85133: PUSH
85134: LD_VAR 0 5
85138: PUSH
85139: LD_VAR 0 1
85143: PPUSH
85144: CALL_OW 437
85148: PUSH
85149: LD_INT 1
85151: ARRAY
85152: PUSH
85153: LD_INT 3
85155: ARRAY
85156: EQUAL
85157: AND
85158: IFFALSE 85170
// result := true else
85160: LD_ADDR_VAR 0 3
85164: PUSH
85165: LD_INT 1
85167: ST_TO_ADDR
85168: GO 85178
// result := false ;
85170: LD_ADDR_VAR 0 3
85174: PUSH
85175: LD_INT 0
85177: ST_TO_ADDR
// end else
85178: GO 85188
// result := false ;
85180: LD_ADDR_VAR 0 3
85184: PUSH
85185: LD_INT 0
85187: ST_TO_ADDR
// end ;
85188: LD_VAR 0 3
85192: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85193: LD_INT 0
85195: PPUSH
85196: PPUSH
85197: PPUSH
85198: PPUSH
// if not unit or not area then
85199: LD_VAR 0 1
85203: NOT
85204: PUSH
85205: LD_VAR 0 2
85209: NOT
85210: OR
85211: IFFALSE 85215
// exit ;
85213: GO 85380
// tmp := AreaToList ( area , i ) ;
85215: LD_ADDR_VAR 0 6
85219: PUSH
85220: LD_VAR 0 2
85224: PPUSH
85225: LD_VAR 0 5
85229: PPUSH
85230: CALL_OW 517
85234: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85235: LD_ADDR_VAR 0 5
85239: PUSH
85240: DOUBLE
85241: LD_INT 1
85243: DEC
85244: ST_TO_ADDR
85245: LD_VAR 0 6
85249: PUSH
85250: LD_INT 1
85252: ARRAY
85253: PUSH
85254: FOR_TO
85255: IFFALSE 85370
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85257: LD_ADDR_VAR 0 7
85261: PUSH
85262: LD_VAR 0 6
85266: PUSH
85267: LD_INT 1
85269: ARRAY
85270: PUSH
85271: LD_VAR 0 5
85275: ARRAY
85276: PUSH
85277: LD_VAR 0 6
85281: PUSH
85282: LD_INT 2
85284: ARRAY
85285: PUSH
85286: LD_VAR 0 5
85290: ARRAY
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
85296: LD_VAR 0 7
85300: PUSH
85301: LD_INT 1
85303: ARRAY
85304: PPUSH
85305: LD_VAR 0 7
85309: PUSH
85310: LD_INT 2
85312: ARRAY
85313: PPUSH
85314: CALL_OW 428
85318: PUSH
85319: LD_INT 0
85321: EQUAL
85322: IFFALSE 85368
// begin result := true ;
85324: LD_ADDR_VAR 0 4
85328: PUSH
85329: LD_INT 1
85331: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85332: LD_VAR 0 1
85336: PPUSH
85337: LD_VAR 0 7
85341: PUSH
85342: LD_INT 1
85344: ARRAY
85345: PPUSH
85346: LD_VAR 0 7
85350: PUSH
85351: LD_INT 2
85353: ARRAY
85354: PPUSH
85355: LD_VAR 0 3
85359: PPUSH
85360: CALL_OW 48
// exit ;
85364: POP
85365: POP
85366: GO 85380
// end ; end ;
85368: GO 85254
85370: POP
85371: POP
// result := false ;
85372: LD_ADDR_VAR 0 4
85376: PUSH
85377: LD_INT 0
85379: ST_TO_ADDR
// end ;
85380: LD_VAR 0 4
85384: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85385: LD_INT 0
85387: PPUSH
85388: PPUSH
85389: PPUSH
// if not side or side > 8 then
85390: LD_VAR 0 1
85394: NOT
85395: PUSH
85396: LD_VAR 0 1
85400: PUSH
85401: LD_INT 8
85403: GREATER
85404: OR
85405: IFFALSE 85409
// exit ;
85407: GO 85596
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85409: LD_ADDR_VAR 0 4
85413: PUSH
85414: LD_INT 22
85416: PUSH
85417: LD_VAR 0 1
85421: PUSH
85422: EMPTY
85423: LIST
85424: LIST
85425: PUSH
85426: LD_INT 21
85428: PUSH
85429: LD_INT 3
85431: PUSH
85432: EMPTY
85433: LIST
85434: LIST
85435: PUSH
85436: EMPTY
85437: LIST
85438: LIST
85439: PPUSH
85440: CALL_OW 69
85444: ST_TO_ADDR
// if not tmp then
85445: LD_VAR 0 4
85449: NOT
85450: IFFALSE 85454
// exit ;
85452: GO 85596
// enable_addtolog := true ;
85454: LD_ADDR_OWVAR 81
85458: PUSH
85459: LD_INT 1
85461: ST_TO_ADDR
// AddToLog ( [ ) ;
85462: LD_STRING [
85464: PPUSH
85465: CALL_OW 561
// for i in tmp do
85469: LD_ADDR_VAR 0 3
85473: PUSH
85474: LD_VAR 0 4
85478: PUSH
85479: FOR_IN
85480: IFFALSE 85587
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85482: LD_STRING [
85484: PUSH
85485: LD_VAR 0 3
85489: PPUSH
85490: CALL_OW 266
85494: STR
85495: PUSH
85496: LD_STRING , 
85498: STR
85499: PUSH
85500: LD_VAR 0 3
85504: PPUSH
85505: CALL_OW 250
85509: STR
85510: PUSH
85511: LD_STRING , 
85513: STR
85514: PUSH
85515: LD_VAR 0 3
85519: PPUSH
85520: CALL_OW 251
85524: STR
85525: PUSH
85526: LD_STRING , 
85528: STR
85529: PUSH
85530: LD_VAR 0 3
85534: PPUSH
85535: CALL_OW 254
85539: STR
85540: PUSH
85541: LD_STRING , 
85543: STR
85544: PUSH
85545: LD_VAR 0 3
85549: PPUSH
85550: LD_INT 1
85552: PPUSH
85553: CALL_OW 268
85557: STR
85558: PUSH
85559: LD_STRING , 
85561: STR
85562: PUSH
85563: LD_VAR 0 3
85567: PPUSH
85568: LD_INT 2
85570: PPUSH
85571: CALL_OW 268
85575: STR
85576: PUSH
85577: LD_STRING ],
85579: STR
85580: PPUSH
85581: CALL_OW 561
// end ;
85585: GO 85479
85587: POP
85588: POP
// AddToLog ( ]; ) ;
85589: LD_STRING ];
85591: PPUSH
85592: CALL_OW 561
// end ;
85596: LD_VAR 0 2
85600: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85601: LD_INT 0
85603: PPUSH
85604: PPUSH
85605: PPUSH
85606: PPUSH
85607: PPUSH
// if not area or not rate or not max then
85608: LD_VAR 0 1
85612: NOT
85613: PUSH
85614: LD_VAR 0 2
85618: NOT
85619: OR
85620: PUSH
85621: LD_VAR 0 4
85625: NOT
85626: OR
85627: IFFALSE 85631
// exit ;
85629: GO 85823
// while 1 do
85631: LD_INT 1
85633: IFFALSE 85823
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85635: LD_ADDR_VAR 0 9
85639: PUSH
85640: LD_VAR 0 1
85644: PPUSH
85645: LD_INT 1
85647: PPUSH
85648: CALL_OW 287
85652: PUSH
85653: LD_INT 10
85655: MUL
85656: ST_TO_ADDR
// r := rate / 10 ;
85657: LD_ADDR_VAR 0 7
85661: PUSH
85662: LD_VAR 0 2
85666: PUSH
85667: LD_INT 10
85669: DIVREAL
85670: ST_TO_ADDR
// time := 1 1$00 ;
85671: LD_ADDR_VAR 0 8
85675: PUSH
85676: LD_INT 2100
85678: ST_TO_ADDR
// if amount < min then
85679: LD_VAR 0 9
85683: PUSH
85684: LD_VAR 0 3
85688: LESS
85689: IFFALSE 85707
// r := r * 2 else
85691: LD_ADDR_VAR 0 7
85695: PUSH
85696: LD_VAR 0 7
85700: PUSH
85701: LD_INT 2
85703: MUL
85704: ST_TO_ADDR
85705: GO 85733
// if amount > max then
85707: LD_VAR 0 9
85711: PUSH
85712: LD_VAR 0 4
85716: GREATER
85717: IFFALSE 85733
// r := r / 2 ;
85719: LD_ADDR_VAR 0 7
85723: PUSH
85724: LD_VAR 0 7
85728: PUSH
85729: LD_INT 2
85731: DIVREAL
85732: ST_TO_ADDR
// time := time / r ;
85733: LD_ADDR_VAR 0 8
85737: PUSH
85738: LD_VAR 0 8
85742: PUSH
85743: LD_VAR 0 7
85747: DIVREAL
85748: ST_TO_ADDR
// if time < 0 then
85749: LD_VAR 0 8
85753: PUSH
85754: LD_INT 0
85756: LESS
85757: IFFALSE 85774
// time := time * - 1 ;
85759: LD_ADDR_VAR 0 8
85763: PUSH
85764: LD_VAR 0 8
85768: PUSH
85769: LD_INT 1
85771: NEG
85772: MUL
85773: ST_TO_ADDR
// wait ( time ) ;
85774: LD_VAR 0 8
85778: PPUSH
85779: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
85783: LD_INT 35
85785: PPUSH
85786: LD_INT 875
85788: PPUSH
85789: CALL_OW 12
85793: PPUSH
85794: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
85798: LD_INT 1
85800: PPUSH
85801: LD_INT 5
85803: PPUSH
85804: CALL_OW 12
85808: PPUSH
85809: LD_VAR 0 1
85813: PPUSH
85814: LD_INT 1
85816: PPUSH
85817: CALL_OW 55
// end ;
85821: GO 85631
// end ;
85823: LD_VAR 0 5
85827: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
85828: LD_INT 0
85830: PPUSH
85831: PPUSH
85832: PPUSH
85833: PPUSH
85834: PPUSH
85835: PPUSH
85836: PPUSH
85837: PPUSH
// if not turrets or not factories then
85838: LD_VAR 0 1
85842: NOT
85843: PUSH
85844: LD_VAR 0 2
85848: NOT
85849: OR
85850: IFFALSE 85854
// exit ;
85852: GO 86161
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
85854: LD_ADDR_VAR 0 10
85858: PUSH
85859: LD_INT 5
85861: PUSH
85862: LD_INT 6
85864: PUSH
85865: EMPTY
85866: LIST
85867: LIST
85868: PUSH
85869: LD_INT 2
85871: PUSH
85872: LD_INT 4
85874: PUSH
85875: EMPTY
85876: LIST
85877: LIST
85878: PUSH
85879: LD_INT 3
85881: PUSH
85882: LD_INT 5
85884: PUSH
85885: EMPTY
85886: LIST
85887: LIST
85888: PUSH
85889: EMPTY
85890: LIST
85891: LIST
85892: LIST
85893: PUSH
85894: LD_INT 24
85896: PUSH
85897: LD_INT 25
85899: PUSH
85900: EMPTY
85901: LIST
85902: LIST
85903: PUSH
85904: LD_INT 23
85906: PUSH
85907: LD_INT 27
85909: PUSH
85910: EMPTY
85911: LIST
85912: LIST
85913: PUSH
85914: EMPTY
85915: LIST
85916: LIST
85917: PUSH
85918: LD_INT 42
85920: PUSH
85921: LD_INT 43
85923: PUSH
85924: EMPTY
85925: LIST
85926: LIST
85927: PUSH
85928: LD_INT 44
85930: PUSH
85931: LD_INT 46
85933: PUSH
85934: EMPTY
85935: LIST
85936: LIST
85937: PUSH
85938: LD_INT 45
85940: PUSH
85941: LD_INT 47
85943: PUSH
85944: EMPTY
85945: LIST
85946: LIST
85947: PUSH
85948: EMPTY
85949: LIST
85950: LIST
85951: LIST
85952: PUSH
85953: EMPTY
85954: LIST
85955: LIST
85956: LIST
85957: ST_TO_ADDR
// result := [ ] ;
85958: LD_ADDR_VAR 0 3
85962: PUSH
85963: EMPTY
85964: ST_TO_ADDR
// for i in turrets do
85965: LD_ADDR_VAR 0 4
85969: PUSH
85970: LD_VAR 0 1
85974: PUSH
85975: FOR_IN
85976: IFFALSE 86159
// begin nat := GetNation ( i ) ;
85978: LD_ADDR_VAR 0 7
85982: PUSH
85983: LD_VAR 0 4
85987: PPUSH
85988: CALL_OW 248
85992: ST_TO_ADDR
// weapon := 0 ;
85993: LD_ADDR_VAR 0 8
85997: PUSH
85998: LD_INT 0
86000: ST_TO_ADDR
// if not nat then
86001: LD_VAR 0 7
86005: NOT
86006: IFFALSE 86010
// continue ;
86008: GO 85975
// for j in list [ nat ] do
86010: LD_ADDR_VAR 0 5
86014: PUSH
86015: LD_VAR 0 10
86019: PUSH
86020: LD_VAR 0 7
86024: ARRAY
86025: PUSH
86026: FOR_IN
86027: IFFALSE 86068
// if GetBWeapon ( i ) = j [ 1 ] then
86029: LD_VAR 0 4
86033: PPUSH
86034: CALL_OW 269
86038: PUSH
86039: LD_VAR 0 5
86043: PUSH
86044: LD_INT 1
86046: ARRAY
86047: EQUAL
86048: IFFALSE 86066
// begin weapon := j [ 2 ] ;
86050: LD_ADDR_VAR 0 8
86054: PUSH
86055: LD_VAR 0 5
86059: PUSH
86060: LD_INT 2
86062: ARRAY
86063: ST_TO_ADDR
// break ;
86064: GO 86068
// end ;
86066: GO 86026
86068: POP
86069: POP
// if not weapon then
86070: LD_VAR 0 8
86074: NOT
86075: IFFALSE 86079
// continue ;
86077: GO 85975
// for k in factories do
86079: LD_ADDR_VAR 0 6
86083: PUSH
86084: LD_VAR 0 2
86088: PUSH
86089: FOR_IN
86090: IFFALSE 86155
// begin weapons := AvailableWeaponList ( k ) ;
86092: LD_ADDR_VAR 0 9
86096: PUSH
86097: LD_VAR 0 6
86101: PPUSH
86102: CALL_OW 478
86106: ST_TO_ADDR
// if not weapons then
86107: LD_VAR 0 9
86111: NOT
86112: IFFALSE 86116
// continue ;
86114: GO 86089
// if weapon in weapons then
86116: LD_VAR 0 8
86120: PUSH
86121: LD_VAR 0 9
86125: IN
86126: IFFALSE 86153
// begin result := [ i , weapon ] ;
86128: LD_ADDR_VAR 0 3
86132: PUSH
86133: LD_VAR 0 4
86137: PUSH
86138: LD_VAR 0 8
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: ST_TO_ADDR
// exit ;
86147: POP
86148: POP
86149: POP
86150: POP
86151: GO 86161
// end ; end ;
86153: GO 86089
86155: POP
86156: POP
// end ;
86157: GO 85975
86159: POP
86160: POP
// end ; end_of_file
86161: LD_VAR 0 3
86165: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
86166: GO 86168
86168: DISABLE
// begin ru_radar := 98 ;
86169: LD_ADDR_EXP 93
86173: PUSH
86174: LD_INT 98
86176: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
86177: LD_ADDR_EXP 94
86181: PUSH
86182: LD_INT 89
86184: ST_TO_ADDR
// us_hack := 99 ;
86185: LD_ADDR_EXP 95
86189: PUSH
86190: LD_INT 99
86192: ST_TO_ADDR
// us_artillery := 97 ;
86193: LD_ADDR_EXP 96
86197: PUSH
86198: LD_INT 97
86200: ST_TO_ADDR
// ar_bio_bomb := 91 ;
86201: LD_ADDR_EXP 97
86205: PUSH
86206: LD_INT 91
86208: ST_TO_ADDR
// end ;
86209: END
