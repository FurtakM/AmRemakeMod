// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 72 0 0
// InitRestrictions ;
  12: CALL 192 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 26
// DebugMode ;
  22: CALL 273 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  26: LD_INT 12
  28: PPUSH
  29: LD_INT 2
  31: PPUSH
  32: CALL 527 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 6 ] [ Difficulty ] ) ;
  36: LD_INT 11
  38: PPUSH
  39: LD_INT 10
  41: PUSH
  42: LD_INT 8
  44: PUSH
  45: LD_INT 6
  47: PUSH
  48: EMPTY
  49: LIST
  50: LIST
  51: LIST
  52: PUSH
  53: LD_OWVAR 67
  57: ARRAY
  58: PPUSH
  59: CALL 527 0 2
// PrepareAmericans ;
  63: CALL 1074 0 0
// Action ;
  67: CALL 1972 0 0
// end ;
  71: END
// export debug ; export mission_prefix , mission_prefix_prev ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed , apeman_army , radar_researched , radar_builded ; export apeman_counter , arab_spotted , end_mission ; function Init ; begin
  72: LD_INT 0
  74: PPUSH
// debug := false ;
  75: LD_ADDR_EXP 1
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// mission_prefix := 05_ ;
  83: LD_ADDR_EXP 2
  87: PUSH
  88: LD_STRING 05_
  90: ST_TO_ADDR
// mission_prefix_prev := 04_ ;
  91: LD_ADDR_EXP 3
  95: PUSH
  96: LD_STRING 04_
  98: ST_TO_ADDR
// deltaBuilded := false ;
  99: LD_ADDR_EXP 4
 103: PUSH
 104: LD_INT 0
 106: ST_TO_ADDR
// denisArrives := false ;
 107: LD_ADDR_EXP 5
 111: PUSH
 112: LD_INT 0
 114: ST_TO_ADDR
// radar_allowed := false ;
 115: LD_ADDR_EXP 7
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// first_apeman_tamed := false ;
 123: LD_ADDR_EXP 8
 127: PUSH
 128: LD_INT 0
 130: ST_TO_ADDR
// arab_spotted := false ;
 131: LD_ADDR_EXP 13
 135: PUSH
 136: LD_INT 0
 138: ST_TO_ADDR
// end_mission := false ;
 139: LD_ADDR_EXP 14
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// apeman_army := false ;
 147: LD_ADDR_EXP 9
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// radar_researched := false ;
 155: LD_ADDR_EXP 10
 159: PUSH
 160: LD_INT 0
 162: ST_TO_ADDR
// radar_builded := false ;
 163: LD_ADDR_EXP 11
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// apeman_counter := 0 ;
 171: LD_ADDR_EXP 12
 175: PUSH
 176: LD_INT 0
 178: ST_TO_ADDR
// Delta := 0 ;
 179: LD_ADDR_EXP 6
 183: PUSH
 184: LD_INT 0
 186: ST_TO_ADDR
// end ;
 187: LD_VAR 0 1
 191: RET
// function InitRestrictions ; begin
 192: LD_INT 0
 194: PPUSH
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
 195: LD_INT 7
 197: PPUSH
 198: LD_INT 1
 200: PPUSH
 201: LD_INT 1
 203: PPUSH
 204: CALL_OW 324
// SetRestrict ( b_lab_full , 1 , state_enabled ) ;
 208: LD_INT 8
 210: PPUSH
 211: LD_INT 1
 213: PPUSH
 214: LD_INT 1
 216: PPUSH
 217: CALL_OW 324
// SetRestrict ( b_lab_weapon , 1 , state_enabled ) ;
 221: LD_INT 10
 223: PPUSH
 224: LD_INT 1
 226: PPUSH
 227: LD_INT 1
 229: PPUSH
 230: CALL_OW 324
// SetTech ( tech_gatling , 1 , LoadVariable ( GatlingInGamma , 1 ) ) ;
 234: LD_INT 69
 236: PPUSH
 237: LD_INT 1
 239: PPUSH
 240: LD_STRING GatlingInGamma
 242: PPUSH
 243: LD_INT 1
 245: PPUSH
 246: CALL_OW 30
 250: PPUSH
 251: CALL_OW 322
// SetTech ( tech_weap1 , 1 , state_enabled ) ;
 255: LD_INT 51
 257: PPUSH
 258: LD_INT 1
 260: PPUSH
 261: LD_INT 1
 263: PPUSH
 264: CALL_OW 322
// end ;
 268: LD_VAR 0 1
 272: RET
// function DebugMode ; begin
 273: LD_INT 0
 275: PPUSH
// FogOff ( 1 ) ;
 276: LD_INT 1
 278: PPUSH
 279: CALL_OW 344
// Difficulty := 2 ;
 283: LD_ADDR_OWVAR 67
 287: PUSH
 288: LD_INT 2
 290: ST_TO_ADDR
// end ; end_of_file
 291: LD_VAR 0 1
 295: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 296: LD_INT 0
 298: PPUSH
 299: PPUSH
// if exist_mode then
 300: LD_VAR 0 2
 304: IFFALSE 329
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 306: LD_ADDR_VAR 0 4
 310: PUSH
 311: LD_EXP 3
 315: PUSH
 316: LD_VAR 0 1
 320: STR
 321: PPUSH
 322: CALL_OW 34
 326: ST_TO_ADDR
 327: GO 344
// unit := NewCharacter ( ident ) ;
 329: LD_ADDR_VAR 0 4
 333: PUSH
 334: LD_VAR 0 1
 338: PPUSH
 339: CALL_OW 25
 343: ST_TO_ADDR
// result := unit ;
 344: LD_ADDR_VAR 0 3
 348: PUSH
 349: LD_VAR 0 4
 353: ST_TO_ADDR
// end ;
 354: LD_VAR 0 3
 358: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 359: LD_INT 0
 361: PPUSH
// uc_side := side ;
 362: LD_ADDR_OWVAR 20
 366: PUSH
 367: LD_VAR 0 1
 371: ST_TO_ADDR
// uc_nation := nation ;
 372: LD_ADDR_OWVAR 21
 376: PUSH
 377: LD_VAR 0 2
 381: ST_TO_ADDR
// vc_chassis := chassis ;
 382: LD_ADDR_OWVAR 37
 386: PUSH
 387: LD_VAR 0 3
 391: ST_TO_ADDR
// vc_engine := engine ;
 392: LD_ADDR_OWVAR 39
 396: PUSH
 397: LD_VAR 0 4
 401: ST_TO_ADDR
// vc_control := control ;
 402: LD_ADDR_OWVAR 38
 406: PUSH
 407: LD_VAR 0 5
 411: ST_TO_ADDR
// vc_weapon := weapon ;
 412: LD_ADDR_OWVAR 40
 416: PUSH
 417: LD_VAR 0 6
 421: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 422: LD_ADDR_OWVAR 41
 426: PUSH
 427: LD_VAR 0 7
 431: ST_TO_ADDR
// result := CreateVehicle ;
 432: LD_ADDR_VAR 0 8
 436: PUSH
 437: CALL_OW 45
 441: ST_TO_ADDR
// end ;
 442: LD_VAR 0 8
 446: RET
// export function SayX ( units , ident ) ; var i ; begin
 447: LD_INT 0
 449: PPUSH
 450: PPUSH
// result := false ;
 451: LD_ADDR_VAR 0 3
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// if not units then
 459: LD_VAR 0 1
 463: NOT
 464: IFFALSE 468
// exit ;
 466: GO 522
// for i in units do
 468: LD_ADDR_VAR 0 4
 472: PUSH
 473: LD_VAR 0 1
 477: PUSH
 478: FOR_IN
 479: IFFALSE 520
// if IsOk ( i ) then
 481: LD_VAR 0 4
 485: PPUSH
 486: CALL_OW 302
 490: IFFALSE 518
// begin Say ( i , ident ) ;
 492: LD_VAR 0 4
 496: PPUSH
 497: LD_VAR 0 2
 501: PPUSH
 502: CALL_OW 88
// result := i ;
 506: LD_ADDR_VAR 0 3
 510: PUSH
 511: LD_VAR 0 4
 515: ST_TO_ADDR
// break ;
 516: GO 520
// end ;
 518: GO 478
 520: POP
 521: POP
// end ;
 522: LD_VAR 0 3
 526: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 527: LD_INT 0
 529: PPUSH
 530: PPUSH
// InitUc ;
 531: CALL_OW 18
// InitHc ;
 535: CALL_OW 19
// uc_side := 0 ;
 539: LD_ADDR_OWVAR 20
 543: PUSH
 544: LD_INT 0
 546: ST_TO_ADDR
// uc_nation := 0 ;
 547: LD_ADDR_OWVAR 21
 551: PUSH
 552: LD_INT 0
 554: ST_TO_ADDR
// for i = 1 to amount do
 555: LD_ADDR_VAR 0 4
 559: PUSH
 560: DOUBLE
 561: LD_INT 1
 563: DEC
 564: ST_TO_ADDR
 565: LD_VAR 0 2
 569: PUSH
 570: FOR_TO
 571: IFFALSE 605
// begin PrepareHuman ( false , class_apeman , 1 ) ;
 573: LD_INT 0
 575: PPUSH
 576: LD_INT 12
 578: PPUSH
 579: LD_INT 1
 581: PPUSH
 582: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 586: CALL_OW 44
 590: PPUSH
 591: LD_VAR 0 1
 595: PPUSH
 596: LD_INT 0
 598: PPUSH
 599: CALL_OW 49
// end ;
 603: GO 570
 605: POP
 606: POP
// end ;
 607: LD_VAR 0 3
 611: RET
// export function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
 612: LD_INT 0
 614: PPUSH
 615: PPUSH
 616: PPUSH
// if not unit then
 617: LD_VAR 0 1
 621: NOT
 622: IFFALSE 626
// exit ;
 624: GO 1069
// if IsInUnit ( unit ) then
 626: LD_VAR 0 1
 630: PPUSH
 631: CALL_OW 310
 635: IFFALSE 652
// unit := IsDrivenBy ( unit ) ;
 637: LD_ADDR_VAR 0 1
 641: PUSH
 642: LD_VAR 0 1
 646: PPUSH
 647: CALL_OW 311
 651: ST_TO_ADDR
// targets_list := [ ] ;
 652: LD_ADDR_VAR 0 5
 656: PUSH
 657: EMPTY
 658: ST_TO_ADDR
// target := UnitFilter ( enemy_list , [ [ f_lives , 250 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 659: LD_ADDR_VAR 0 4
 663: PUSH
 664: LD_VAR 0 2
 668: PPUSH
 669: LD_INT 24
 671: PUSH
 672: LD_INT 250
 674: PUSH
 675: EMPTY
 676: LIST
 677: LIST
 678: PUSH
 679: LD_INT 3
 681: PUSH
 682: LD_INT 34
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PUSH
 692: EMPTY
 693: LIST
 694: LIST
 695: PUSH
 696: LD_INT 21
 698: PUSH
 699: LD_INT 2
 701: PUSH
 702: EMPTY
 703: LIST
 704: LIST
 705: PUSH
 706: LD_INT 58
 708: PUSH
 709: EMPTY
 710: LIST
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PPUSH
 718: CALL_OW 72
 722: ST_TO_ADDR
// if GetDistUnits ( NearestUnitToUnit ( target , unit ) , unit ) < 11 and not IsInUnit ( unit ) then
 723: LD_VAR 0 4
 727: PPUSH
 728: LD_VAR 0 1
 732: PPUSH
 733: CALL_OW 74
 737: PPUSH
 738: LD_VAR 0 1
 742: PPUSH
 743: CALL_OW 296
 747: PUSH
 748: LD_INT 11
 750: LESS
 751: PUSH
 752: LD_VAR 0 1
 756: PPUSH
 757: CALL_OW 310
 761: NOT
 762: AND
 763: IFFALSE 791
// begin ComEnterUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 765: LD_VAR 0 1
 769: PPUSH
 770: LD_VAR 0 4
 774: PPUSH
 775: LD_VAR 0 1
 779: PPUSH
 780: CALL_OW 74
 784: PPUSH
 785: CALL_OW 120
// exit ;
 789: GO 1069
// end ; targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
 791: LD_ADDR_VAR 0 5
 795: PUSH
 796: LD_VAR 0 2
 800: PPUSH
 801: LD_INT 21
 803: PUSH
 804: LD_INT 1
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 54
 816: PUSH
 817: EMPTY
 818: LIST
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: PUSH
 824: EMPTY
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL_OW 72
 832: PUSH
 833: LD_VAR 0 2
 837: PPUSH
 838: LD_INT 21
 840: PUSH
 841: LD_INT 2
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: PPUSH
 848: CALL_OW 72
 852: PUSH
 853: LD_VAR 0 2
 857: PPUSH
 858: LD_INT 21
 860: PUSH
 861: LD_INT 3
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: LD_INT 3
 870: PUSH
 871: LD_INT 58
 873: PUSH
 874: EMPTY
 875: LIST
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: PUSH
 881: EMPTY
 882: LIST
 883: LIST
 884: PPUSH
 885: CALL_OW 72
 889: PUSH
 890: LD_VAR 0 2
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: ST_TO_ADDR
// for target in targets_list do
 901: LD_ADDR_VAR 0 4
 905: PUSH
 906: LD_VAR 0 5
 910: PUSH
 911: FOR_IN
 912: IFFALSE 1067
// begin if target then
 914: LD_VAR 0 4
 918: IFFALSE 1065
// if GetTag ( unit ) = 11 and ( GetType ( NearestUnitToUnit ( target , unit ) ) = unit_building or GetWeapon ( NearestUnitToUnit ( target , unit ) ) = us_cargo_bay ) then
 920: LD_VAR 0 1
 924: PPUSH
 925: CALL_OW 110
 929: PUSH
 930: LD_INT 11
 932: EQUAL
 933: PUSH
 934: LD_VAR 0 4
 938: PPUSH
 939: LD_VAR 0 1
 943: PPUSH
 944: CALL_OW 74
 948: PPUSH
 949: CALL_OW 247
 953: PUSH
 954: LD_INT 3
 956: EQUAL
 957: PUSH
 958: LD_VAR 0 4
 962: PPUSH
 963: LD_VAR 0 1
 967: PPUSH
 968: CALL_OW 74
 972: PPUSH
 973: CALL_OW 264
 977: PUSH
 978: LD_INT 12
 980: EQUAL
 981: OR
 982: AND
 983: IFFALSE 1029
// begin ComPlaceDelayedCharge ( unit , 0 , 0 , NearestUnitToUnit ( target , unit ) ) ;
 985: LD_VAR 0 1
 989: PPUSH
 990: LD_INT 0
 992: PPUSH
 993: LD_INT 0
 995: PPUSH
 996: LD_VAR 0 4
1000: PPUSH
1001: LD_VAR 0 1
1005: PPUSH
1006: CALL_OW 74
1010: PPUSH
1011: CALL_OW 132
// SetTag ( unit , 0 ) ;
1015: LD_VAR 0 1
1019: PPUSH
1020: LD_INT 0
1022: PPUSH
1023: CALL_OW 109
// end else
1027: GO 1065
// if not HasTask ( unit ) then
1029: LD_VAR 0 1
1033: PPUSH
1034: CALL_OW 314
1038: NOT
1039: IFFALSE 1065
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
1041: LD_VAR 0 1
1045: PPUSH
1046: LD_VAR 0 4
1050: PPUSH
1051: LD_VAR 0 1
1055: PPUSH
1056: CALL_OW 74
1060: PPUSH
1061: CALL_OW 115
// end ;
1065: GO 911
1067: POP
1068: POP
// end ; end_of_file
1069: LD_VAR 0 3
1073: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
1074: LD_INT 0
1076: PPUSH
1077: PPUSH
1078: PPUSH
1079: PPUSH
1080: PPUSH
// uc_nation := 1 ;
1081: LD_ADDR_OWVAR 21
1085: PUSH
1086: LD_INT 1
1088: ST_TO_ADDR
// uc_side := 4 ;
1089: LD_ADDR_OWVAR 20
1093: PUSH
1094: LD_INT 4
1096: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
1097: LD_ADDR_EXP 18
1101: PUSH
1102: LD_STRING Denis
1104: PPUSH
1105: LD_INT 0
1107: PPUSH
1108: CALL 296 0 2
1112: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
1113: LD_ADDR_EXP 17
1117: PUSH
1118: LD_STRING Harisson
1120: PPUSH
1121: LD_INT 0
1123: PPUSH
1124: CALL 296 0 2
1128: ST_TO_ADDR
// uc_side := 1 ;
1129: LD_ADDR_OWVAR 20
1133: PUSH
1134: LD_INT 1
1136: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1137: LD_ADDR_EXP 15
1141: PUSH
1142: LD_STRING JMM
1144: PPUSH
1145: LD_EXP 1
1149: NOT
1150: PPUSH
1151: CALL 296 0 2
1155: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
1156: LD_ADDR_EXP 16
1160: PUSH
1161: LD_STRING Gladstone
1163: PPUSH
1164: LD_INT 0
1166: PPUSH
1167: CALL 296 0 2
1171: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
1172: LD_STRING BrownInDelta
1174: PPUSH
1175: LD_EXP 1
1179: PPUSH
1180: CALL_OW 30
1184: IFFALSE 1221
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1186: LD_ADDR_EXP 19
1190: PUSH
1191: LD_STRING Brown
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: CALL 296 0 2
1204: ST_TO_ADDR
// tmp := tmp ^ Brown ;
1205: LD_ADDR_VAR 0 5
1209: PUSH
1210: LD_VAR 0 5
1214: PUSH
1215: LD_EXP 19
1219: ADD
1220: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , 0 ) then
1221: LD_STRING DonaldsonInDelta
1223: PPUSH
1224: LD_INT 0
1226: PPUSH
1227: CALL_OW 30
1231: IFFALSE 1268
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1233: LD_ADDR_EXP 20
1237: PUSH
1238: LD_STRING Donaldson
1240: PPUSH
1241: LD_EXP 1
1245: NOT
1246: PPUSH
1247: CALL 296 0 2
1251: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
1252: LD_ADDR_VAR 0 5
1256: PUSH
1257: LD_VAR 0 5
1261: PUSH
1262: LD_EXP 20
1266: ADD
1267: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
1268: LD_STRING LisaInDelta
1270: PPUSH
1271: LD_EXP 1
1275: PPUSH
1276: CALL_OW 30
1280: IFFALSE 1317
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1282: LD_ADDR_EXP 21
1286: PUSH
1287: LD_STRING Lisa
1289: PPUSH
1290: LD_EXP 1
1294: NOT
1295: PPUSH
1296: CALL 296 0 2
1300: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
1301: LD_ADDR_VAR 0 5
1305: PUSH
1306: LD_VAR 0 5
1310: PUSH
1311: LD_EXP 21
1315: ADD
1316: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
1317: LD_STRING FrankInDelta
1319: PPUSH
1320: LD_EXP 1
1324: PPUSH
1325: CALL_OW 30
1329: IFFALSE 1366
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
1331: LD_ADDR_EXP 22
1335: PUSH
1336: LD_STRING Frank
1338: PPUSH
1339: LD_EXP 1
1343: NOT
1344: PPUSH
1345: CALL 296 0 2
1349: ST_TO_ADDR
// tmp := tmp ^ Frank ;
1350: LD_ADDR_VAR 0 5
1354: PUSH
1355: LD_VAR 0 5
1359: PUSH
1360: LD_EXP 22
1364: ADD
1365: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
1366: LD_STRING BobbyInDelta
1368: PPUSH
1369: LD_INT 0
1371: PPUSH
1372: CALL_OW 30
1376: IFFALSE 1413
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1378: LD_ADDR_EXP 23
1382: PUSH
1383: LD_STRING Bobby
1385: PPUSH
1386: LD_EXP 1
1390: NOT
1391: PPUSH
1392: CALL 296 0 2
1396: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
1397: LD_ADDR_VAR 0 5
1401: PUSH
1402: LD_VAR 0 5
1406: PUSH
1407: LD_EXP 23
1411: ADD
1412: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
1413: LD_STRING CyrusInDelta
1415: PPUSH
1416: LD_INT 0
1418: PPUSH
1419: CALL_OW 30
1423: IFFALSE 1460
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1425: LD_ADDR_EXP 24
1429: PUSH
1430: LD_STRING Cyrus
1432: PPUSH
1433: LD_EXP 1
1437: NOT
1438: PPUSH
1439: CALL 296 0 2
1443: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
1444: LD_ADDR_VAR 0 5
1448: PUSH
1449: LD_VAR 0 5
1453: PUSH
1454: LD_EXP 24
1458: ADD
1459: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
1460: LD_ADDR_EXP 25
1464: PUSH
1465: LD_STRING othersDelta
1467: PPUSH
1468: CALL_OW 31
1472: ST_TO_ADDR
// if not others and debug then
1473: LD_EXP 25
1477: NOT
1478: PUSH
1479: LD_EXP 1
1483: AND
1484: IFFALSE 1549
// begin InitHc ;
1486: CALL_OW 19
// for i = 1 to 2 do
1490: LD_ADDR_VAR 0 2
1494: PUSH
1495: DOUBLE
1496: LD_INT 1
1498: DEC
1499: ST_TO_ADDR
1500: LD_INT 2
1502: PUSH
1503: FOR_TO
1504: IFFALSE 1547
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
1506: LD_INT 0
1508: PPUSH
1509: LD_VAR 0 2
1513: PUSH
1514: LD_INT 4
1516: MOD
1517: PUSH
1518: LD_INT 1
1520: PLUS
1521: PPUSH
1522: LD_INT 3
1524: PPUSH
1525: CALL_OW 380
// others := others ^ CreateHuman ;
1529: LD_ADDR_EXP 25
1533: PUSH
1534: LD_EXP 25
1538: PUSH
1539: CALL_OW 44
1543: ADD
1544: ST_TO_ADDR
// end ;
1545: GO 1503
1547: POP
1548: POP
// end ; if others then
1549: LD_EXP 25
1553: IFFALSE 1571
// tmp := tmp ^ others ;
1555: LD_ADDR_VAR 0 5
1559: PUSH
1560: LD_VAR 0 5
1564: PUSH
1565: LD_EXP 25
1569: ADD
1570: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
1571: LD_ADDR_VAR 0 3
1575: PUSH
1576: LD_INT 28
1578: PUSH
1579: LD_INT 49
1581: PUSH
1582: EMPTY
1583: LIST
1584: LIST
1585: PUSH
1586: LD_INT 33
1588: PUSH
1589: LD_INT 54
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PUSH
1596: LD_INT 38
1598: PUSH
1599: LD_INT 56
1601: PUSH
1602: EMPTY
1603: LIST
1604: LIST
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: LIST
1610: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1611: LD_ADDR_VAR 0 4
1615: PUSH
1616: LD_INT 1
1618: PPUSH
1619: LD_INT 1
1621: PPUSH
1622: LD_INT 2
1624: PPUSH
1625: LD_INT 2
1627: PPUSH
1628: LD_INT 1
1630: PPUSH
1631: LD_INT 12
1633: PPUSH
1634: LD_INT 80
1636: PPUSH
1637: CALL 359 0 7
1641: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1642: LD_VAR 0 4
1646: PPUSH
1647: LD_INT 1
1649: PPUSH
1650: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1654: LD_VAR 0 4
1658: PPUSH
1659: LD_VAR 0 3
1663: PUSH
1664: LD_INT 1
1666: ARRAY
1667: PUSH
1668: LD_INT 1
1670: ARRAY
1671: PPUSH
1672: LD_VAR 0 3
1676: PUSH
1677: LD_INT 1
1679: ARRAY
1680: PUSH
1681: LD_INT 2
1683: ARRAY
1684: PPUSH
1685: LD_INT 0
1687: PPUSH
1688: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1692: LD_VAR 0 4
1696: PPUSH
1697: LD_INT 1
1699: PPUSH
1700: LD_INT 100
1702: PPUSH
1703: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1707: LD_EXP 25
1711: PUSH
1712: LD_INT 1
1714: ARRAY
1715: PPUSH
1716: LD_VAR 0 4
1720: PPUSH
1721: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1725: LD_ADDR_VAR 0 4
1729: PUSH
1730: LD_INT 1
1732: PPUSH
1733: LD_INT 1
1735: PPUSH
1736: LD_INT 1
1738: PPUSH
1739: LD_INT 2
1741: PPUSH
1742: LD_INT 1
1744: PPUSH
1745: LD_INT 2
1747: PPUSH
1748: LD_INT 80
1750: PPUSH
1751: CALL 359 0 7
1755: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1756: LD_VAR 0 4
1760: PPUSH
1761: LD_INT 1
1763: PPUSH
1764: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1768: LD_VAR 0 4
1772: PPUSH
1773: LD_VAR 0 3
1777: PUSH
1778: LD_INT 2
1780: ARRAY
1781: PUSH
1782: LD_INT 1
1784: ARRAY
1785: PPUSH
1786: LD_VAR 0 3
1790: PUSH
1791: LD_INT 2
1793: ARRAY
1794: PUSH
1795: LD_INT 2
1797: ARRAY
1798: PPUSH
1799: LD_INT 0
1801: PPUSH
1802: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1806: LD_EXP 16
1810: PPUSH
1811: LD_VAR 0 4
1815: PPUSH
1816: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
1820: LD_ADDR_VAR 0 4
1824: PUSH
1825: LD_INT 1
1827: PPUSH
1828: LD_INT 1
1830: PPUSH
1831: LD_INT 1
1833: PPUSH
1834: LD_INT 2
1836: PPUSH
1837: LD_INT 1
1839: PPUSH
1840: LD_INT 3
1842: PPUSH
1843: LD_INT 80
1845: PPUSH
1846: CALL 359 0 7
1850: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1851: LD_VAR 0 4
1855: PPUSH
1856: LD_INT 1
1858: PPUSH
1859: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
1863: LD_VAR 0 4
1867: PPUSH
1868: LD_VAR 0 3
1872: PUSH
1873: LD_INT 3
1875: ARRAY
1876: PUSH
1877: LD_INT 1
1879: ARRAY
1880: PPUSH
1881: LD_VAR 0 3
1885: PUSH
1886: LD_INT 3
1888: ARRAY
1889: PUSH
1890: LD_INT 2
1892: ARRAY
1893: PPUSH
1894: LD_INT 0
1896: PPUSH
1897: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1901: LD_EXP 15
1905: PPUSH
1906: LD_VAR 0 4
1910: PPUSH
1911: CALL_OW 52
// if others > 1 then
1915: LD_EXP 25
1919: PUSH
1920: LD_INT 1
1922: GREATER
1923: IFFALSE 1967
// for i in tmp diff others [ 1 ] do
1925: LD_ADDR_VAR 0 2
1929: PUSH
1930: LD_VAR 0 5
1934: PUSH
1935: LD_EXP 25
1939: PUSH
1940: LD_INT 1
1942: ARRAY
1943: DIFF
1944: PUSH
1945: FOR_IN
1946: IFFALSE 1965
// PlaceUnitArea ( i , startArea , false ) ;
1948: LD_VAR 0 2
1952: PPUSH
1953: LD_INT 5
1955: PPUSH
1956: LD_INT 0
1958: PPUSH
1959: CALL_OW 49
1963: GO 1945
1965: POP
1966: POP
// end ; end_of_file
1967: LD_VAR 0 1
1971: RET
// export function Action ; var m ; begin
1972: LD_INT 0
1974: PPUSH
1975: PPUSH
// InGameOn ;
1976: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
1980: LD_INT 28
1982: PPUSH
1983: LD_INT 51
1985: PPUSH
1986: CALL_OW 86
// Wait ( 3 ) ;
1990: LD_INT 3
1992: PPUSH
1993: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
1997: LD_EXP 15
2001: PPUSH
2002: LD_STRING D1d-JMM-1a
2004: PPUSH
2005: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
2009: LD_EXP 17
2013: PPUSH
2014: LD_STRING D1d-Har-1
2016: PPUSH
2017: CALL_OW 94
// InGameOff ;
2021: CALL_OW 9
// SaveForQuickRestart ;
2025: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
2029: LD_STRING M1
2031: PPUSH
2032: CALL_OW 337
// Wait ( 0 0$2 ) ;
2036: LD_INT 70
2038: PPUSH
2039: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
2043: LD_EXP 15
2047: PPUSH
2048: LD_STRING D2-JMM-1
2050: PPUSH
2051: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
2055: LD_EXP 16
2059: PPUSH
2060: LD_STRING D2-Glad-1
2062: PPUSH
2063: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2067: LD_EXP 15
2071: PPUSH
2072: LD_STRING D2-JMM-2
2074: PPUSH
2075: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
2079: LD_EXP 16
2083: PPUSH
2084: LD_STRING D2-Glad-2
2086: PPUSH
2087: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2091: LD_EXP 15
2095: PPUSH
2096: LD_STRING D2-JMM-3
2098: PPUSH
2099: CALL_OW 88
// Wait ( rand ( 0 0$30 , 1 1$00 ) ) ;
2103: LD_INT 1050
2105: PPUSH
2106: LD_INT 2100
2108: PPUSH
2109: CALL_OW 12
2113: PPUSH
2114: CALL_OW 67
// SetWeather ( 2 , 90 , 150 ) ;
2118: LD_INT 2
2120: PPUSH
2121: LD_INT 90
2123: PPUSH
2124: LD_INT 150
2126: PPUSH
2127: CALL_OW 550
// Wait ( rand ( 3 3$00 , 5 5$00 ) ) ;
2131: LD_INT 6300
2133: PPUSH
2134: LD_INT 10500
2136: PPUSH
2137: CALL_OW 12
2141: PPUSH
2142: CALL_OW 67
// SetWeather ( 0 , 90 , 150 ) ;
2146: LD_INT 0
2148: PPUSH
2149: LD_INT 90
2151: PPUSH
2152: LD_INT 150
2154: PPUSH
2155: CALL_OW 550
// end ;
2159: LD_VAR 0 1
2163: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
2164: LD_INT 22
2166: PUSH
2167: LD_INT 1
2169: PUSH
2170: EMPTY
2171: LIST
2172: LIST
2173: PUSH
2174: LD_INT 3
2176: PUSH
2177: LD_INT 57
2179: PUSH
2180: EMPTY
2181: LIST
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 30
2189: PUSH
2190: LD_INT 0
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: EMPTY
2198: LIST
2199: LIST
2200: LIST
2201: PUSH
2202: EMPTY
2203: LIST
2204: PPUSH
2205: CALL_OW 69
2209: PUSH
2210: LD_EXP 4
2214: NOT
2215: AND
2216: IFFALSE 2229
2218: GO 2220
2220: DISABLE
// begin deltaBuilded := true ;
2221: LD_ADDR_EXP 4
2225: PUSH
2226: LD_INT 1
2228: ST_TO_ADDR
// end ;
2229: END
// every 0 0$01 trigger not Delta and deltaBuilded and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) do
2230: LD_EXP 6
2234: NOT
2235: PUSH
2236: LD_EXP 4
2240: AND
2241: PUSH
2242: LD_INT 22
2244: PUSH
2245: LD_INT 1
2247: PUSH
2248: EMPTY
2249: LIST
2250: LIST
2251: PUSH
2252: LD_INT 3
2254: PUSH
2255: LD_INT 57
2257: PUSH
2258: EMPTY
2259: LIST
2260: PUSH
2261: EMPTY
2262: LIST
2263: LIST
2264: PUSH
2265: LD_INT 30
2267: PUSH
2268: LD_INT 0
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: PUSH
2280: EMPTY
2281: LIST
2282: PPUSH
2283: CALL_OW 69
2287: AND
2288: IFFALSE 2361
2290: GO 2292
2292: DISABLE
// begin enable ;
2293: ENABLE
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
2294: LD_ADDR_EXP 6
2298: PUSH
2299: LD_INT 22
2301: PUSH
2302: LD_INT 1
2304: PUSH
2305: EMPTY
2306: LIST
2307: LIST
2308: PUSH
2309: LD_INT 3
2311: PUSH
2312: LD_INT 57
2314: PUSH
2315: EMPTY
2316: LIST
2317: PUSH
2318: EMPTY
2319: LIST
2320: LIST
2321: PUSH
2322: LD_INT 30
2324: PUSH
2325: LD_INT 0
2327: PUSH
2328: EMPTY
2329: LIST
2330: LIST
2331: PUSH
2332: EMPTY
2333: LIST
2334: LIST
2335: LIST
2336: PUSH
2337: EMPTY
2338: LIST
2339: PPUSH
2340: CALL_OW 69
2344: PUSH
2345: LD_INT 1
2347: ARRAY
2348: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
2349: LD_EXP 6
2353: PPUSH
2354: LD_STRING Delta
2356: PPUSH
2357: CALL_OW 500
// end ;
2361: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched do
2362: LD_INT 1
2364: PPUSH
2365: LD_INT 1
2367: PPUSH
2368: CALL_OW 321
2372: PUSH
2373: LD_INT 2
2375: EQUAL
2376: IFFALSE 2437
2378: GO 2380
2380: DISABLE
// begin DialogueOn ;
2381: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
2385: LD_EXP 16
2389: PPUSH
2390: LD_STRING D3-Glad-1
2392: PPUSH
2393: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2397: LD_EXP 15
2401: PPUSH
2402: LD_STRING D3-JMM-1
2404: PPUSH
2405: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
2409: LD_EXP 16
2413: PPUSH
2414: LD_STRING D3-Glad-2
2416: PPUSH
2417: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
2421: LD_EXP 15
2425: PPUSH
2426: LD_STRING D3-JMM-2
2428: PPUSH
2429: CALL_OW 88
// DialogueOff ;
2433: CALL_OW 7
// end ;
2437: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
2438: LD_INT 2
2440: PPUSH
2441: LD_INT 1
2443: PPUSH
2444: CALL_OW 321
2448: PUSH
2449: LD_INT 2
2451: EQUAL
2452: IFFALSE 2629
2454: GO 2456
2456: DISABLE
2457: LD_INT 0
2459: PPUSH
// begin DialogueOn ;
2460: CALL_OW 6
// if Frank then
2464: LD_EXP 22
2468: IFFALSE 2482
// Say ( Frank , D8a-Frank-1 ) ;
2470: LD_EXP 22
2474: PPUSH
2475: LD_STRING D8a-Frank-1
2477: PPUSH
2478: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
2482: LD_ADDR_VAR 0 1
2486: PUSH
2487: LD_EXP 25
2491: PPUSH
2492: LD_INT 26
2494: PUSH
2495: LD_INT 1
2497: PUSH
2498: EMPTY
2499: LIST
2500: LIST
2501: PPUSH
2502: CALL_OW 72
2506: PPUSH
2507: LD_STRING D8a-Sol1-1
2509: PPUSH
2510: CALL 447 0 2
2514: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2515: LD_EXP 18
2519: PUSH
2520: LD_EXP 18
2524: PPUSH
2525: CALL_OW 255
2529: PUSH
2530: LD_INT 1
2532: EQUAL
2533: AND
2534: IFFALSE 2548
// Say ( Denis , D8a-Den-1 ) ;
2536: LD_EXP 18
2540: PPUSH
2541: LD_STRING D8a-Den-1
2543: PPUSH
2544: CALL_OW 88
// if sol or Denis or Frank then
2548: LD_VAR 0 1
2552: PUSH
2553: LD_EXP 18
2557: OR
2558: PUSH
2559: LD_EXP 22
2563: OR
2564: IFFALSE 2625
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2566: LD_EXP 25
2570: PPUSH
2571: LD_INT 25
2573: PUSH
2574: LD_INT 4
2576: PUSH
2577: EMPTY
2578: LIST
2579: LIST
2580: PUSH
2581: LD_INT 26
2583: PUSH
2584: LD_INT 1
2586: PUSH
2587: EMPTY
2588: LIST
2589: LIST
2590: PUSH
2591: EMPTY
2592: LIST
2593: LIST
2594: PPUSH
2595: CALL_OW 72
2599: PUSH
2600: LD_VAR 0 1
2604: DIFF
2605: PPUSH
2606: LD_STRING D8a-Sci1-1
2608: PPUSH
2609: CALL 447 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2613: LD_EXP 15
2617: PPUSH
2618: LD_STRING D8a-JMM-1
2620: PPUSH
2621: CALL_OW 88
// end ; DialogueOff ;
2625: CALL_OW 7
// end ;
2629: PPOPN 1
2631: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2632: LD_INT 22
2634: PUSH
2635: LD_INT 1
2637: PUSH
2638: EMPTY
2639: LIST
2640: LIST
2641: PUSH
2642: LD_INT 25
2644: PUSH
2645: LD_INT 16
2647: PUSH
2648: EMPTY
2649: LIST
2650: LIST
2651: PUSH
2652: EMPTY
2653: LIST
2654: LIST
2655: PPUSH
2656: CALL_OW 69
2660: IFFALSE 2719
2662: GO 2664
2664: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2665: LD_STRING M1a
2667: PPUSH
2668: CALL_OW 337
// case Query ( Q2 ) of 1 :
2672: LD_STRING Q2
2674: PPUSH
2675: CALL_OW 97
2679: PUSH
2680: LD_INT 1
2682: DOUBLE
2683: EQUAL
2684: IFTRUE 2688
2686: GO 2699
2688: POP
// end_mission := true ; 2 :
2689: LD_ADDR_EXP 14
2693: PUSH
2694: LD_INT 1
2696: ST_TO_ADDR
2697: GO 2719
2699: LD_INT 2
2701: DOUBLE
2702: EQUAL
2703: IFTRUE 2707
2705: GO 2718
2707: POP
// end_the_mission_allowed := true ; end ;
2708: LD_ADDR_OWVAR 57
2712: PUSH
2713: LD_INT 1
2715: ST_TO_ADDR
2716: GO 2719
2718: POP
// end ;
2719: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) and Delta do
2720: LD_INT 22
2722: PUSH
2723: LD_INT 1
2725: PUSH
2726: EMPTY
2727: LIST
2728: LIST
2729: PUSH
2730: LD_INT 2
2732: PUSH
2733: LD_INT 30
2735: PUSH
2736: LD_INT 6
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PUSH
2743: LD_INT 30
2745: PUSH
2746: LD_INT 7
2748: PUSH
2749: EMPTY
2750: LIST
2751: LIST
2752: PUSH
2753: EMPTY
2754: LIST
2755: LIST
2756: LIST
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: PPUSH
2762: CALL_OW 69
2766: PUSH
2767: LD_INT 22
2769: PUSH
2770: LD_INT 1
2772: PUSH
2773: EMPTY
2774: LIST
2775: LIST
2776: PUSH
2777: LD_INT 2
2779: PUSH
2780: LD_INT 30
2782: PUSH
2783: LD_INT 2
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: LD_INT 30
2792: PUSH
2793: LD_INT 3
2795: PUSH
2796: EMPTY
2797: LIST
2798: LIST
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: LIST
2804: PUSH
2805: EMPTY
2806: LIST
2807: LIST
2808: PPUSH
2809: CALL_OW 69
2813: AND
2814: PUSH
2815: LD_EXP 6
2819: AND
2820: IFFALSE 3247
2822: GO 2824
2824: DISABLE
// begin Wait ( rand ( 0 0$20 , 0 0$40 ) ) ;
2825: LD_INT 700
2827: PPUSH
2828: LD_INT 1400
2830: PPUSH
2831: CALL_OW 12
2835: PPUSH
2836: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
2840: LD_EXP 18
2844: PPUSH
2845: LD_INT 6
2847: PUSH
2848: LD_INT 9
2850: PUSH
2851: LD_INT 10
2853: PUSH
2854: EMPTY
2855: LIST
2856: LIST
2857: LIST
2858: PUSH
2859: LD_OWVAR 67
2863: ARRAY
2864: PPUSH
2865: LD_INT 0
2867: PPUSH
2868: CALL_OW 49
// ComHold ( Denis ) ;
2872: LD_EXP 18
2876: PPUSH
2877: CALL_OW 140
// InGameOn ;
2881: CALL_OW 8
// DialogueOn ;
2885: CALL_OW 6
// if Delta then
2889: LD_EXP 6
2893: IFFALSE 2906
// CenterNowOnUnits ( Delta ) else
2895: LD_EXP 6
2899: PPUSH
2900: CALL_OW 87
2904: GO 2915
// CenterNowOnUnits ( JMM ) ;
2906: LD_EXP 15
2910: PPUSH
2911: CALL_OW 87
// Say ( Denis , DD-Den-1 ) ;
2915: LD_EXP 18
2919: PPUSH
2920: LD_STRING DD-Den-1
2922: PPUSH
2923: CALL_OW 88
// Say ( JMM , DD-JMM-1 ) ;
2927: LD_EXP 15
2931: PPUSH
2932: LD_STRING DD-JMM-1
2934: PPUSH
2935: CALL_OW 88
// Say ( Denis , DD-Den-2 ) ;
2939: LD_EXP 18
2943: PPUSH
2944: LD_STRING DD-Den-2
2946: PPUSH
2947: CALL_OW 88
// Wait ( 3 ) ;
2951: LD_INT 3
2953: PPUSH
2954: CALL_OW 67
// DialogueOff ;
2958: CALL_OW 7
// InGameOff ;
2962: CALL_OW 9
// repeat wait ( 0 0$01 ) ;
2966: LD_INT 35
2968: PPUSH
2969: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
2973: LD_INT 1
2975: PPUSH
2976: LD_EXP 18
2980: PPUSH
2981: CALL_OW 292
2985: PUSH
2986: LD_EXP 18
2990: PPUSH
2991: CALL_OW 301
2995: OR
2996: IFFALSE 2966
// if IsDead ( Denis ) then
2998: LD_EXP 18
3002: PPUSH
3003: CALL_OW 301
3007: IFFALSE 3011
// exit ;
3009: GO 3247
// SetSide ( Denis , 1 ) ;
3011: LD_EXP 18
3015: PPUSH
3016: LD_INT 1
3018: PPUSH
3019: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
3023: LD_EXP 18
3027: PPUSH
3028: LD_STRING DD-Den-2a
3030: PPUSH
3031: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
3035: LD_INT 35
3037: PPUSH
3038: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
3042: LD_EXP 18
3046: PPUSH
3047: CALL_OW 310
3051: PPUSH
3052: CALL_OW 266
3056: PUSH
3057: LD_INT 6
3059: PUSH
3060: LD_INT 7
3062: PUSH
3063: LD_INT 8
3065: PUSH
3066: EMPTY
3067: LIST
3068: LIST
3069: LIST
3070: IN
3071: PUSH
3072: LD_EXP 18
3076: PPUSH
3077: CALL_OW 301
3081: OR
3082: IFFALSE 3035
// if IsDead ( Denis ) then
3084: LD_EXP 18
3088: PPUSH
3089: CALL_OW 301
3093: IFFALSE 3097
// exit ;
3095: GO 3247
// Say ( Denis , DD-Den-2b ) ;
3097: LD_EXP 18
3101: PPUSH
3102: LD_STRING DD-Den-2b
3104: PPUSH
3105: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
3109: LD_EXP 18
3113: PPUSH
3114: LD_INT 4
3116: PPUSH
3117: CALL_OW 123
// Wait ( 0 0$02 ) ;
3121: LD_INT 70
3123: PPUSH
3124: CALL_OW 67
// DialogueOn ;
3128: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
3132: LD_EXP 18
3136: PPUSH
3137: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3141: LD_EXP 15
3145: PPUSH
3146: LD_STRING D4-JMM-1
3148: PPUSH
3149: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
3153: LD_EXP 18
3157: PPUSH
3158: LD_STRING D4-Den-1
3160: PPUSH
3161: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
3165: LD_EXP 15
3169: PPUSH
3170: LD_STRING D4-JMM-2
3172: PPUSH
3173: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
3177: LD_EXP 18
3181: PPUSH
3182: LD_STRING D4-Den-2
3184: PPUSH
3185: CALL_OW 88
// DialogueOff ;
3189: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
3193: LD_STRING M2
3195: PPUSH
3196: CALL_OW 337
// radar_allowed := true ;
3200: LD_ADDR_EXP 7
3204: PUSH
3205: LD_INT 1
3207: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
3208: LD_INT 6
3210: PPUSH
3211: LD_INT 1
3213: PPUSH
3214: LD_INT 1
3216: PPUSH
3217: CALL_OW 322
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
3221: LD_INT 15
3223: PPUSH
3224: LD_INT 1
3226: PPUSH
3227: LD_INT 1
3229: PPUSH
3230: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
3234: LD_INT 20
3236: PPUSH
3237: LD_INT 1
3239: PPUSH
3240: LD_INT 1
3242: PPUSH
3243: CALL_OW 324
// end ;
3247: END
// every 0 0$1 trigger arab_spotted do var sol , sol2 ;
3248: LD_EXP 13
3252: IFFALSE 3875
3254: GO 3256
3256: DISABLE
3257: LD_INT 0
3259: PPUSH
3260: PPUSH
// begin sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D5-Sol1-1 ) ;
3261: LD_ADDR_VAR 0 1
3265: PUSH
3266: LD_EXP 25
3270: PPUSH
3271: LD_INT 26
3273: PUSH
3274: LD_INT 1
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: PPUSH
3281: CALL_OW 72
3285: PPUSH
3286: LD_STRING D5-Sol1-1
3288: PPUSH
3289: CALL 447 0 2
3293: ST_TO_ADDR
// if not sol then
3294: LD_VAR 0 1
3298: NOT
3299: IFFALSE 3303
// exit ;
3301: GO 3875
// repeat wait ( 0 0$01 ) ;
3303: LD_INT 35
3305: PPUSH
3306: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
3310: LD_INT 22
3312: PUSH
3313: LD_INT 2
3315: PUSH
3316: EMPTY
3317: LIST
3318: LIST
3319: PUSH
3320: LD_INT 21
3322: PUSH
3323: LD_INT 1
3325: PUSH
3326: EMPTY
3327: LIST
3328: LIST
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PPUSH
3334: CALL_OW 69
3338: PUSH
3339: LD_INT 0
3341: EQUAL
3342: IFFALSE 3303
// if IsOk ( sol ) then
3344: LD_VAR 0 1
3348: PPUSH
3349: CALL_OW 302
3353: IFFALSE 3373
// begin sol2 := others diff sol ;
3355: LD_ADDR_VAR 0 2
3359: PUSH
3360: LD_EXP 25
3364: PUSH
3365: LD_VAR 0 1
3369: DIFF
3370: ST_TO_ADDR
// end else
3371: GO 3375
// exit ;
3373: GO 3875
// if not Lisa and not sol2 then
3375: LD_EXP 21
3379: NOT
3380: PUSH
3381: LD_VAR 0 2
3385: NOT
3386: AND
3387: IFFALSE 3391
// exit ;
3389: GO 3875
// DialogueOn ;
3391: CALL_OW 6
// if Lisa then
3395: LD_EXP 21
3399: IFFALSE 3415
// Say ( Lisa , D5a-Lisa-1 ) else
3401: LD_EXP 21
3405: PPUSH
3406: LD_STRING D5a-Lisa-1
3408: PPUSH
3409: CALL_OW 88
3413: GO 3490
// if sol2 then
3415: LD_VAR 0 2
3419: IFFALSE 3490
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3421: LD_VAR 0 2
3425: PUSH
3426: LD_INT 1
3428: ARRAY
3429: PPUSH
3430: CALL_OW 258
3434: PUSH
3435: LD_INT 1
3437: DOUBLE
3438: EQUAL
3439: IFTRUE 3443
3441: GO 3462
3443: POP
// Say ( sol2 [ 1 ] , D5-Sol2-1 ) ; sex_female :
3444: LD_VAR 0 2
3448: PUSH
3449: LD_INT 1
3451: ARRAY
3452: PPUSH
3453: LD_STRING D5-Sol2-1
3455: PPUSH
3456: CALL_OW 88
3460: GO 3490
3462: LD_INT 2
3464: DOUBLE
3465: EQUAL
3466: IFTRUE 3470
3468: GO 3489
3470: POP
// Say ( sol2 [ 1 ] , D5-FSol2-1 ) ; end ;
3471: LD_VAR 0 2
3475: PUSH
3476: LD_INT 1
3478: ARRAY
3479: PPUSH
3480: LD_STRING D5-FSol2-1
3482: PPUSH
3483: CALL_OW 88
3487: GO 3490
3489: POP
// Say ( sol , D5-Sol1-2 ) ;
3490: LD_VAR 0 1
3494: PPUSH
3495: LD_STRING D5-Sol1-2
3497: PPUSH
3498: CALL_OW 88
// if Lisa then
3502: LD_EXP 21
3506: IFFALSE 3522
// Say ( Lisa , D5a-Lisa-2 ) else
3508: LD_EXP 21
3512: PPUSH
3513: LD_STRING D5a-Lisa-2
3515: PPUSH
3516: CALL_OW 88
3520: GO 3597
// if sol2 then
3522: LD_VAR 0 2
3526: IFFALSE 3597
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3528: LD_VAR 0 2
3532: PUSH
3533: LD_INT 1
3535: ARRAY
3536: PPUSH
3537: CALL_OW 258
3541: PUSH
3542: LD_INT 1
3544: DOUBLE
3545: EQUAL
3546: IFTRUE 3550
3548: GO 3569
3550: POP
// Say ( sol2 [ 1 ] , D5-Sol2-2 ) ; sex_female :
3551: LD_VAR 0 2
3555: PUSH
3556: LD_INT 1
3558: ARRAY
3559: PPUSH
3560: LD_STRING D5-Sol2-2
3562: PPUSH
3563: CALL_OW 88
3567: GO 3597
3569: LD_INT 2
3571: DOUBLE
3572: EQUAL
3573: IFTRUE 3577
3575: GO 3596
3577: POP
// Say ( sol2 [ 1 ] , D5-FSol2-2 ) ; end ;
3578: LD_VAR 0 2
3582: PUSH
3583: LD_INT 1
3585: ARRAY
3586: PPUSH
3587: LD_STRING D5-FSol2-2
3589: PPUSH
3590: CALL_OW 88
3594: GO 3597
3596: POP
// Say ( sol , D5a-Sol1-3 ) ;
3597: LD_VAR 0 1
3601: PPUSH
3602: LD_STRING D5a-Sol1-3
3604: PPUSH
3605: CALL_OW 88
// if Lisa then
3609: LD_EXP 21
3613: IFFALSE 3627
// Say ( Lisa , D5a-Lisa-3 ) ;
3615: LD_EXP 21
3619: PPUSH
3620: LD_STRING D5a-Lisa-3
3622: PPUSH
3623: CALL_OW 88
// if not sol2 then
3627: LD_VAR 0 2
3631: NOT
3632: IFFALSE 3640
// begin DialogueOff ;
3634: CALL_OW 7
// exit ;
3638: GO 3875
// end ; case GetSex ( sol2 [ 1 ] ) of sex_male :
3640: LD_VAR 0 2
3644: PUSH
3645: LD_INT 1
3647: ARRAY
3648: PPUSH
3649: CALL_OW 258
3653: PUSH
3654: LD_INT 1
3656: DOUBLE
3657: EQUAL
3658: IFTRUE 3662
3660: GO 3681
3662: POP
// Say ( sol2 [ 1 ] , D5-Sol2-3 ) ; sex_female :
3663: LD_VAR 0 2
3667: PUSH
3668: LD_INT 1
3670: ARRAY
3671: PPUSH
3672: LD_STRING D5-Sol2-3
3674: PPUSH
3675: CALL_OW 88
3679: GO 3709
3681: LD_INT 2
3683: DOUBLE
3684: EQUAL
3685: IFTRUE 3689
3687: GO 3708
3689: POP
// Say ( sol2 [ 1 ] , D5-FSol2-3 ) ; end ;
3690: LD_VAR 0 2
3694: PUSH
3695: LD_INT 1
3697: ARRAY
3698: PPUSH
3699: LD_STRING D5-FSol2-3
3701: PPUSH
3702: CALL_OW 88
3706: GO 3709
3708: POP
// Say ( sol , D5-Sol1-4 ) ;
3709: LD_VAR 0 1
3713: PPUSH
3714: LD_STRING D5-Sol1-4
3716: PPUSH
3717: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3721: LD_VAR 0 2
3725: PUSH
3726: LD_INT 1
3728: ARRAY
3729: PPUSH
3730: CALL_OW 258
3734: PUSH
3735: LD_INT 1
3737: DOUBLE
3738: EQUAL
3739: IFTRUE 3743
3741: GO 3762
3743: POP
// Say ( sol2 [ 1 ] , D5-Sol2-4 ) ; sex_female :
3744: LD_VAR 0 2
3748: PUSH
3749: LD_INT 1
3751: ARRAY
3752: PPUSH
3753: LD_STRING D5-Sol2-4
3755: PPUSH
3756: CALL_OW 88
3760: GO 3790
3762: LD_INT 2
3764: DOUBLE
3765: EQUAL
3766: IFTRUE 3770
3768: GO 3789
3770: POP
// Say ( sol2 [ 1 ] , D5-FSol2-4 ) ; end ;
3771: LD_VAR 0 2
3775: PUSH
3776: LD_INT 1
3778: ARRAY
3779: PPUSH
3780: LD_STRING D5-FSol2-4
3782: PPUSH
3783: CALL_OW 88
3787: GO 3790
3789: POP
// Say ( sol , D5-Sol1-5 ) ;
3790: LD_VAR 0 1
3794: PPUSH
3795: LD_STRING D5-Sol1-5
3797: PPUSH
3798: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3802: LD_VAR 0 2
3806: PUSH
3807: LD_INT 1
3809: ARRAY
3810: PPUSH
3811: CALL_OW 258
3815: PUSH
3816: LD_INT 1
3818: DOUBLE
3819: EQUAL
3820: IFTRUE 3824
3822: GO 3843
3824: POP
// Say ( sol2 [ 1 ] , D5-Sol2-5 ) ; sex_female :
3825: LD_VAR 0 2
3829: PUSH
3830: LD_INT 1
3832: ARRAY
3833: PPUSH
3834: LD_STRING D5-Sol2-5
3836: PPUSH
3837: CALL_OW 88
3841: GO 3871
3843: LD_INT 2
3845: DOUBLE
3846: EQUAL
3847: IFTRUE 3851
3849: GO 3870
3851: POP
// Say ( sol2 [ 1 ] , D5-FSol2-5 ) ; end ;
3852: LD_VAR 0 2
3856: PUSH
3857: LD_INT 1
3859: ARRAY
3860: PPUSH
3861: LD_STRING D5-FSol2-5
3863: PPUSH
3864: CALL_OW 88
3868: GO 3871
3870: POP
// DialogueOff ;
3871: CALL_OW 7
// end ;
3875: PPOPN 2
3877: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 5 do
3878: LD_INT 22
3880: PUSH
3881: LD_INT 1
3883: PUSH
3884: EMPTY
3885: LIST
3886: LIST
3887: PUSH
3888: LD_INT 25
3890: PUSH
3891: LD_INT 16
3893: PUSH
3894: EMPTY
3895: LIST
3896: LIST
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: PPUSH
3902: CALL_OW 69
3906: PUSH
3907: LD_INT 5
3909: GREATEREQUAL
3910: IFFALSE 3930
3912: GO 3914
3914: DISABLE
// begin ChangeMissionObjectives ( M1b ) ;
3915: LD_STRING M1b
3917: PPUSH
3918: CALL_OW 337
// apeman_army := true ;
3922: LD_ADDR_EXP 9
3926: PUSH
3927: LD_INT 1
3929: ST_TO_ADDR
// end ;
3930: END
// every 0 0$1 trigger GetTech ( tech_radar , 1 ) = state_researched do
3931: LD_INT 6
3933: PPUSH
3934: LD_INT 1
3936: PPUSH
3937: CALL_OW 321
3941: PUSH
3942: LD_INT 2
3944: EQUAL
3945: IFFALSE 3965
3947: GO 3949
3949: DISABLE
// begin ChangeMissionObjectives ( M2a ) ;
3950: LD_STRING M2a
3952: PPUSH
3953: CALL_OW 337
// radar_researched := true ;
3957: LD_ADDR_EXP 10
3961: PUSH
3962: LD_INT 1
3964: ST_TO_ADDR
// end ;
3965: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_weapon , us_radar ] , [ f_bweapon , us_radar ] ] ] ) do
3966: LD_INT 22
3968: PUSH
3969: LD_INT 1
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: PUSH
3976: LD_INT 2
3978: PUSH
3979: LD_INT 34
3981: PUSH
3982: LD_INT 11
3984: PUSH
3985: EMPTY
3986: LIST
3987: LIST
3988: PUSH
3989: LD_INT 35
3991: PUSH
3992: LD_INT 11
3994: PUSH
3995: EMPTY
3996: LIST
3997: LIST
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: PUSH
4004: EMPTY
4005: LIST
4006: LIST
4007: PPUSH
4008: CALL_OW 69
4012: IFFALSE 4032
4014: GO 4016
4016: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
4017: LD_STRING M2b
4019: PPUSH
4020: CALL_OW 337
// radar_builded := true ;
4024: LD_ADDR_EXP 11
4028: PUSH
4029: LD_INT 1
4031: ST_TO_ADDR
// end ;
4032: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 and not first_apeman_tamed do
4033: LD_INT 22
4035: PUSH
4036: LD_INT 0
4038: PUSH
4039: EMPTY
4040: LIST
4041: LIST
4042: PUSH
4043: LD_INT 25
4045: PUSH
4046: LD_INT 12
4048: PUSH
4049: EMPTY
4050: LIST
4051: LIST
4052: PUSH
4053: EMPTY
4054: LIST
4055: LIST
4056: PPUSH
4057: CALL_OW 69
4061: PUSH
4062: LD_INT 0
4064: EQUAL
4065: PUSH
4066: LD_EXP 8
4070: NOT
4071: AND
4072: IFFALSE 4084
4074: GO 4076
4076: DISABLE
// YouLost ( Apeman ) ;
4077: LD_STRING Apeman
4079: PPUSH
4080: CALL_OW 104
4084: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 7 do var i , filter ;
4085: LD_INT 22
4087: PUSH
4088: LD_INT 1
4090: PUSH
4091: EMPTY
4092: LIST
4093: LIST
4094: PUSH
4095: LD_INT 25
4097: PUSH
4098: LD_INT 16
4100: PUSH
4101: EMPTY
4102: LIST
4103: LIST
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: PPUSH
4109: CALL_OW 69
4113: PUSH
4114: LD_INT 7
4116: GREATEREQUAL
4117: IFFALSE 4215
4119: GO 4121
4121: DISABLE
4122: LD_INT 0
4124: PPUSH
4125: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ^ JMM ;
4126: LD_ADDR_VAR 0 2
4130: PUSH
4131: LD_INT 22
4133: PUSH
4134: LD_INT 1
4136: PUSH
4137: EMPTY
4138: LIST
4139: LIST
4140: PUSH
4141: LD_INT 21
4143: PUSH
4144: LD_INT 1
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: PUSH
4151: LD_INT 25
4153: PUSH
4154: LD_INT 4
4156: PUSH
4157: EMPTY
4158: LIST
4159: LIST
4160: PUSH
4161: EMPTY
4162: LIST
4163: LIST
4164: LIST
4165: PPUSH
4166: CALL_OW 69
4170: PUSH
4171: LD_EXP 15
4175: ADD
4176: ST_TO_ADDR
// if filter then
4177: LD_VAR 0 2
4181: IFFALSE 4215
// for i in filter do
4183: LD_ADDR_VAR 0 1
4187: PUSH
4188: LD_VAR 0 2
4192: PUSH
4193: FOR_IN
4194: IFFALSE 4213
// AddExperience ( i , 4 , 3500 ) ;
4196: LD_VAR 0 1
4200: PPUSH
4201: LD_INT 4
4203: PPUSH
4204: LD_INT 3500
4206: PPUSH
4207: CALL_OW 492
4211: GO 4193
4213: POP
4214: POP
// end ;
4215: PPOPN 2
4217: END
// every 0 0$1 trigger end_mission do var i , tmp ;
4218: LD_EXP 14
4222: IFFALSE 5233
4224: GO 4226
4226: DISABLE
4227: LD_INT 0
4229: PPUSH
4230: PPUSH
// begin if FilterAllUnits ( [ f_side , 2 ] ) then
4231: LD_INT 22
4233: PUSH
4234: LD_INT 2
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PPUSH
4241: CALL_OW 69
4245: IFFALSE 4283
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
4247: LD_ADDR_VAR 0 1
4251: PUSH
4252: LD_INT 22
4254: PUSH
4255: LD_INT 2
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: PPUSH
4262: CALL_OW 69
4266: PUSH
4267: FOR_IN
4268: IFFALSE 4281
// RemoveUnit ( i ) ;
4270: LD_VAR 0 1
4274: PPUSH
4275: CALL_OW 64
4279: GO 4267
4281: POP
4282: POP
// if apeman_army then
4283: LD_EXP 9
4287: IFFALSE 4301
// AddMedal ( Tame , 1 ) else
4289: LD_STRING Tame
4291: PPUSH
4292: LD_INT 1
4294: PPUSH
4295: CALL_OW 101
4299: GO 4312
// AddMedal ( Tame , - 1 ) ;
4301: LD_STRING Tame
4303: PPUSH
4304: LD_INT 1
4306: NEG
4307: PPUSH
4308: CALL_OW 101
// if radar_researched then
4312: LD_EXP 10
4316: IFFALSE 4340
// begin SaveVariable ( true , radarResInDelta ) ;
4318: LD_INT 1
4320: PPUSH
4321: LD_STRING radarResInDelta
4323: PPUSH
4324: CALL_OW 39
// AddMedal ( Radar , 1 ) ;
4328: LD_STRING Radar
4330: PPUSH
4331: LD_INT 1
4333: PPUSH
4334: CALL_OW 101
// end else
4338: GO 4370
// if radar_allowed then
4340: LD_EXP 7
4344: IFFALSE 4359
// AddMedal ( Radar , - 2 ) else
4346: LD_STRING Radar
4348: PPUSH
4349: LD_INT 2
4351: NEG
4352: PPUSH
4353: CALL_OW 101
4357: GO 4370
// AddMedal ( Radar , - 1 ) ;
4359: LD_STRING Radar
4361: PPUSH
4362: LD_INT 1
4364: NEG
4365: PPUSH
4366: CALL_OW 101
// if radar_builded then
4370: LD_EXP 11
4374: IFFALSE 4388
// AddMedal ( BuildRadar , 1 ) else
4376: LD_STRING BuildRadar
4378: PPUSH
4379: LD_INT 1
4381: PPUSH
4382: CALL_OW 101
4386: GO 4399
// AddMedal ( BuildRadar , - 1 ) ;
4388: LD_STRING BuildRadar
4390: PPUSH
4391: LD_INT 1
4393: NEG
4394: PPUSH
4395: CALL_OW 101
// GiveMedals ( MAIN ) ;
4399: LD_STRING MAIN
4401: PPUSH
4402: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
4406: LD_ADDR_VAR 0 2
4410: PUSH
4411: LD_INT 22
4413: PUSH
4414: LD_INT 1
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PUSH
4421: LD_INT 21
4423: PUSH
4424: LD_INT 1
4426: PUSH
4427: EMPTY
4428: LIST
4429: LIST
4430: PUSH
4431: LD_INT 2
4433: PUSH
4434: LD_INT 25
4436: PUSH
4437: LD_INT 1
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: PUSH
4444: LD_INT 25
4446: PUSH
4447: LD_INT 2
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: PUSH
4454: LD_INT 25
4456: PUSH
4457: LD_INT 3
4459: PUSH
4460: EMPTY
4461: LIST
4462: LIST
4463: PUSH
4464: LD_INT 25
4466: PUSH
4467: LD_INT 4
4469: PUSH
4470: EMPTY
4471: LIST
4472: LIST
4473: PUSH
4474: EMPTY
4475: LIST
4476: LIST
4477: LIST
4478: LIST
4479: LIST
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL_OW 69
4490: ST_TO_ADDR
// RewardPeople ( tmp ) ;
4491: LD_VAR 0 2
4495: PPUSH
4496: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
4500: LD_EXP 15
4504: PPUSH
4505: LD_EXP 2
4509: PUSH
4510: LD_STRING JMM
4512: STR
4513: PPUSH
4514: CALL_OW 38
// if IsOk ( Gladstone ) then
4518: LD_EXP 16
4522: PPUSH
4523: CALL_OW 302
4527: IFFALSE 4547
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
4529: LD_EXP 16
4533: PPUSH
4534: LD_EXP 2
4538: PUSH
4539: LD_STRING Gladstone
4541: STR
4542: PPUSH
4543: CALL_OW 38
// end ; if IsOk ( Denis ) and GetSide ( Denis ) = 1 then
4547: LD_EXP 18
4551: PPUSH
4552: CALL_OW 302
4556: PUSH
4557: LD_EXP 18
4561: PPUSH
4562: CALL_OW 255
4566: PUSH
4567: LD_INT 1
4569: EQUAL
4570: AND
4571: IFFALSE 4601
// begin SaveCharacters ( Denis , mission_prefix & Denis ) ;
4573: LD_EXP 18
4577: PPUSH
4578: LD_EXP 2
4582: PUSH
4583: LD_STRING Denis
4585: STR
4586: PPUSH
4587: CALL_OW 38
// SaveVariable ( true , DenisInDelta ) ;
4591: LD_INT 1
4593: PPUSH
4594: LD_STRING DenisInDelta
4596: PPUSH
4597: CALL_OW 39
// end ; if IsOk ( Lisa ) then
4601: LD_EXP 21
4605: PPUSH
4606: CALL_OW 302
4610: IFFALSE 4630
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
4612: LD_EXP 21
4616: PPUSH
4617: LD_EXP 2
4621: PUSH
4622: LD_STRING Lisa
4624: STR
4625: PPUSH
4626: CALL_OW 38
// end ; if IsOk ( Frank ) then
4630: LD_EXP 22
4634: PPUSH
4635: CALL_OW 302
4639: IFFALSE 4659
// begin SaveCharacters ( Frank , mission_prefix & Frank ) ;
4641: LD_EXP 22
4645: PPUSH
4646: LD_EXP 2
4650: PUSH
4651: LD_STRING Frank
4653: STR
4654: PPUSH
4655: CALL_OW 38
// end ; if IsOk ( Bobby ) then
4659: LD_EXP 23
4663: PPUSH
4664: CALL_OW 302
4668: IFFALSE 4688
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
4670: LD_EXP 23
4674: PPUSH
4675: LD_EXP 2
4679: PUSH
4680: LD_STRING Bobby
4682: STR
4683: PPUSH
4684: CALL_OW 38
// end ; if IsOk ( Cyrus ) then
4688: LD_EXP 24
4692: PPUSH
4693: CALL_OW 302
4697: IFFALSE 4717
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
4699: LD_EXP 24
4703: PPUSH
4704: LD_EXP 2
4708: PUSH
4709: LD_STRING Cyrus
4711: STR
4712: PPUSH
4713: CALL_OW 38
// end ; if IsOk ( Brown ) then
4717: LD_EXP 19
4721: PPUSH
4722: CALL_OW 302
4726: IFFALSE 4746
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
4728: LD_EXP 19
4732: PPUSH
4733: LD_EXP 2
4737: PUSH
4738: LD_STRING Brown
4740: STR
4741: PPUSH
4742: CALL_OW 38
// end ; if IsOk ( Donaldson ) then
4746: LD_EXP 20
4750: PPUSH
4751: CALL_OW 302
4755: IFFALSE 4775
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
4757: LD_EXP 20
4761: PPUSH
4762: LD_EXP 2
4766: PUSH
4767: LD_STRING Donaldson
4769: STR
4770: PPUSH
4771: CALL_OW 38
// end ; if others then
4775: LD_EXP 25
4779: IFFALSE 4793
// SaveCharacters ( others , othersInDelta ) ;
4781: LD_EXP 25
4785: PPUSH
4786: LD_STRING othersInDelta
4788: PPUSH
4789: CALL_OW 38
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) then
4793: LD_INT 22
4795: PUSH
4796: LD_INT 1
4798: PUSH
4799: EMPTY
4800: LIST
4801: LIST
4802: PUSH
4803: LD_INT 25
4805: PUSH
4806: LD_INT 16
4808: PUSH
4809: EMPTY
4810: LIST
4811: LIST
4812: PUSH
4813: EMPTY
4814: LIST
4815: LIST
4816: PPUSH
4817: CALL_OW 69
4821: IFFALSE 4859
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) , apeInDelta ) ;
4823: LD_INT 22
4825: PUSH
4826: LD_INT 1
4828: PUSH
4829: EMPTY
4830: LIST
4831: LIST
4832: PUSH
4833: LD_INT 25
4835: PUSH
4836: LD_INT 16
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PPUSH
4847: CALL_OW 69
4851: PPUSH
4852: LD_STRING apeInDelta
4854: PPUSH
4855: CALL_OW 38
// tmp := [ ] ;
4859: LD_ADDR_VAR 0 2
4863: PUSH
4864: EMPTY
4865: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) then
4866: LD_INT 22
4868: PUSH
4869: LD_INT 1
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: PUSH
4876: LD_INT 21
4878: PUSH
4879: LD_INT 2
4881: PUSH
4882: EMPTY
4883: LIST
4884: LIST
4885: PUSH
4886: EMPTY
4887: LIST
4888: LIST
4889: PPUSH
4890: CALL_OW 69
4894: IFFALSE 5005
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
4896: LD_ADDR_VAR 0 1
4900: PUSH
4901: LD_INT 22
4903: PUSH
4904: LD_INT 1
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PUSH
4911: LD_INT 21
4913: PUSH
4914: LD_INT 2
4916: PUSH
4917: EMPTY
4918: LIST
4919: LIST
4920: PUSH
4921: EMPTY
4922: LIST
4923: LIST
4924: PPUSH
4925: CALL_OW 69
4929: PUSH
4930: FOR_IN
4931: IFFALSE 5003
// tmp := tmp ^ [ GetNation ( i ) , GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
4933: LD_ADDR_VAR 0 2
4937: PUSH
4938: LD_VAR 0 2
4942: PUSH
4943: LD_VAR 0 1
4947: PPUSH
4948: CALL_OW 248
4952: PUSH
4953: LD_VAR 0 1
4957: PPUSH
4958: CALL_OW 265
4962: PUSH
4963: LD_VAR 0 1
4967: PPUSH
4968: CALL_OW 262
4972: PUSH
4973: LD_VAR 0 1
4977: PPUSH
4978: CALL_OW 263
4982: PUSH
4983: LD_VAR 0 1
4987: PPUSH
4988: CALL_OW 264
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: LIST
4997: LIST
4998: LIST
4999: ADD
5000: ST_TO_ADDR
5001: GO 4930
5003: POP
5004: POP
// if tmp then
5005: LD_VAR 0 2
5009: IFFALSE 5023
// SaveVariable ( tmp , vehiclesInDelta ) ;
5011: LD_VAR 0 2
5015: PPUSH
5016: LD_STRING vehiclesInDelta
5018: PPUSH
5019: CALL_OW 39
// tmp := [ ] ;
5023: LD_ADDR_VAR 0 2
5027: PUSH
5028: EMPTY
5029: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
5030: LD_INT 22
5032: PUSH
5033: LD_INT 1
5035: PUSH
5036: EMPTY
5037: LIST
5038: LIST
5039: PUSH
5040: LD_INT 21
5042: PUSH
5043: LD_INT 3
5045: PUSH
5046: EMPTY
5047: LIST
5048: LIST
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: PPUSH
5054: CALL_OW 69
5058: IFFALSE 5211
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5060: LD_ADDR_VAR 0 1
5064: PUSH
5065: LD_INT 22
5067: PUSH
5068: LD_INT 1
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PUSH
5075: LD_INT 21
5077: PUSH
5078: LD_INT 3
5080: PUSH
5081: EMPTY
5082: LIST
5083: LIST
5084: PUSH
5085: EMPTY
5086: LIST
5087: LIST
5088: PPUSH
5089: CALL_OW 69
5093: PUSH
5094: FOR_IN
5095: IFFALSE 5209
// tmp := tmp ^ [ [ GetBType ( i ) , GetBLevel ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
5097: LD_ADDR_VAR 0 2
5101: PUSH
5102: LD_VAR 0 2
5106: PUSH
5107: LD_VAR 0 1
5111: PPUSH
5112: CALL_OW 266
5116: PUSH
5117: LD_VAR 0 1
5121: PPUSH
5122: CALL_OW 267
5126: PUSH
5127: LD_VAR 0 1
5131: PPUSH
5132: CALL_OW 250
5136: PUSH
5137: LD_VAR 0 1
5141: PPUSH
5142: CALL_OW 251
5146: PUSH
5147: LD_VAR 0 1
5151: PPUSH
5152: CALL_OW 254
5156: PUSH
5157: LD_VAR 0 1
5161: PPUSH
5162: LD_INT 1
5164: PPUSH
5165: CALL_OW 268
5169: PUSH
5170: LD_VAR 0 1
5174: PPUSH
5175: LD_INT 2
5177: PPUSH
5178: CALL_OW 268
5182: PUSH
5183: LD_VAR 0 1
5187: PPUSH
5188: CALL_OW 269
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: LIST
5197: LIST
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: PUSH
5203: EMPTY
5204: LIST
5205: ADD
5206: ST_TO_ADDR
5207: GO 5094
5209: POP
5210: POP
// if tmp then
5211: LD_VAR 0 2
5215: IFFALSE 5229
// SaveVariable ( tmp , buildingsInDelta ) ;
5217: LD_VAR 0 2
5221: PPUSH
5222: LD_STRING buildingsInDelta
5224: PPUSH
5225: CALL_OW 39
// YouWin ;
5229: CALL_OW 103
// end ; end_of_file
5233: PPOPN 2
5235: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un , tmp ; begin
5236: LD_INT 0
5238: PPUSH
5239: PPUSH
5240: PPUSH
5241: PPUSH
// InitHc ;
5242: CALL_OW 19
// InitUc ;
5246: CALL_OW 18
// uc_side := 2 ;
5250: LD_ADDR_OWVAR 20
5254: PUSH
5255: LD_INT 2
5257: ST_TO_ADDR
// uc_nation := 2 ;
5258: LD_ADDR_OWVAR 21
5262: PUSH
5263: LD_INT 2
5265: ST_TO_ADDR
// if not amount then
5266: LD_VAR 0 1
5270: NOT
5271: IFFALSE 5275
// exit ;
5273: GO 5398
// for i = 1 to amount do
5275: LD_ADDR_VAR 0 5
5279: PUSH
5280: DOUBLE
5281: LD_INT 1
5283: DEC
5284: ST_TO_ADDR
5285: LD_VAR 0 1
5289: PUSH
5290: FOR_TO
5291: IFFALSE 5386
// begin PrepareHuman ( false , 1 , skill ) ;
5293: LD_INT 0
5295: PPUSH
5296: LD_INT 1
5298: PPUSH
5299: LD_VAR 0 2
5303: PPUSH
5304: CALL_OW 380
// un := CreateHuman ;
5308: LD_ADDR_VAR 0 6
5312: PUSH
5313: CALL_OW 44
5317: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
5318: LD_ADDR_VAR 0 7
5322: PUSH
5323: LD_VAR 0 7
5327: PPUSH
5328: LD_INT 1
5330: PPUSH
5331: LD_VAR 0 6
5335: PPUSH
5336: CALL_OW 2
5340: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5341: LD_VAR 0 6
5345: PPUSH
5346: LD_VAR 0 3
5350: PPUSH
5351: LD_INT 0
5353: PPUSH
5354: CALL_OW 49
// if i mod 2 = 0 then
5358: LD_VAR 0 5
5362: PUSH
5363: LD_INT 2
5365: MOD
5366: PUSH
5367: LD_INT 0
5369: EQUAL
5370: IFFALSE 5384
// SetTag ( un , 11 ) ;
5372: LD_VAR 0 6
5376: PPUSH
5377: LD_INT 11
5379: PPUSH
5380: CALL_OW 109
// end ;
5384: GO 5290
5386: POP
5387: POP
// result := tmp ;
5388: LD_ADDR_VAR 0 4
5392: PUSH
5393: LD_VAR 0 7
5397: ST_TO_ADDR
// end ;
5398: LD_VAR 0 4
5402: RET
// export ar_forces , ap_killers ; every 0 0$1 trigger Delta do var i , timer , more_troops , skill , eng , un , veh , force ;
5403: LD_EXP 6
5407: IFFALSE 6267
5409: GO 5411
5411: DISABLE
5412: LD_INT 0
5414: PPUSH
5415: PPUSH
5416: PPUSH
5417: PPUSH
5418: PPUSH
5419: PPUSH
5420: PPUSH
5421: PPUSH
// begin more_troops := false ;
5422: LD_ADDR_VAR 0 3
5426: PUSH
5427: LD_INT 0
5429: ST_TO_ADDR
// skill := [ 3 , 4 , 5 ] [ Difficulty ] ;
5430: LD_ADDR_VAR 0 4
5434: PUSH
5435: LD_INT 3
5437: PUSH
5438: LD_INT 4
5440: PUSH
5441: LD_INT 5
5443: PUSH
5444: EMPTY
5445: LIST
5446: LIST
5447: LIST
5448: PUSH
5449: LD_OWVAR 67
5453: ARRAY
5454: ST_TO_ADDR
// timer := [ 5 5$00 , 4 4$00 , 3 3$00 ] [ Difficulty ] ;
5455: LD_ADDR_VAR 0 2
5459: PUSH
5460: LD_INT 10500
5462: PUSH
5463: LD_INT 8400
5465: PUSH
5466: LD_INT 6300
5468: PUSH
5469: EMPTY
5470: LIST
5471: LIST
5472: LIST
5473: PUSH
5474: LD_OWVAR 67
5478: ARRAY
5479: ST_TO_ADDR
// force := [ ] ;
5480: LD_ADDR_VAR 0 8
5484: PUSH
5485: EMPTY
5486: ST_TO_ADDR
// ar_forces := [ ] ;
5487: LD_ADDR_EXP 26
5491: PUSH
5492: EMPTY
5493: ST_TO_ADDR
// ap_killers := [ ] ;
5494: LD_ADDR_EXP 27
5498: PUSH
5499: EMPTY
5500: ST_TO_ADDR
// Wait ( timer ) ;
5501: LD_VAR 0 2
5505: PPUSH
5506: CALL_OW 67
// if Denis and GetSide ( Denis ) = 4 then
5510: LD_EXP 18
5514: PUSH
5515: LD_EXP 18
5519: PPUSH
5520: CALL_OW 255
5524: PUSH
5525: LD_INT 4
5527: EQUAL
5528: AND
5529: IFFALSE 5538
// Wait ( 0 0$45 ) ;
5531: LD_INT 1575
5533: PPUSH
5534: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) then
5538: LD_INT 22
5540: PUSH
5541: LD_INT 1
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: PUSH
5548: LD_INT 30
5550: PUSH
5551: LD_INT 4
5553: PUSH
5554: EMPTY
5555: LIST
5556: LIST
5557: PUSH
5558: EMPTY
5559: LIST
5560: LIST
5561: PPUSH
5562: CALL_OW 69
5566: IFFALSE 5583
// begin Wait ( 1 1$25 ) ;
5568: LD_INT 2975
5570: PPUSH
5571: CALL_OW 67
// more_troops := true ;
5575: LD_ADDR_VAR 0 3
5579: PUSH
5580: LD_INT 1
5582: ST_TO_ADDR
// end ; if more_troops then
5583: LD_VAR 0 3
5587: IFFALSE 5775
// begin force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , arArea2 ) ;
5589: LD_ADDR_VAR 0 8
5593: PUSH
5594: LD_INT 4
5596: PUSH
5597: LD_INT 5
5599: PUSH
5600: LD_INT 6
5602: PUSH
5603: EMPTY
5604: LIST
5605: LIST
5606: LIST
5607: PUSH
5608: LD_OWVAR 67
5612: ARRAY
5613: PPUSH
5614: LD_VAR 0 4
5618: PPUSH
5619: LD_INT 14
5621: PPUSH
5622: CALL 5236 0 3
5626: ST_TO_ADDR
// veh := PrepareTank ( 2 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ Difficulty ] , 90 ) ;
5627: LD_ADDR_VAR 0 7
5631: PUSH
5632: LD_INT 2
5634: PPUSH
5635: LD_INT 3
5637: PPUSH
5638: LD_INT 22
5640: PPUSH
5641: LD_INT 1
5643: PPUSH
5644: LD_INT 1
5646: PPUSH
5647: LD_INT 42
5649: PUSH
5650: LD_INT 42
5652: PUSH
5653: LD_INT 43
5655: PUSH
5656: EMPTY
5657: LIST
5658: LIST
5659: LIST
5660: PUSH
5661: LD_OWVAR 67
5665: ARRAY
5666: PPUSH
5667: LD_INT 90
5669: PPUSH
5670: CALL 359 0 7
5674: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5675: LD_VAR 0 7
5679: PPUSH
5680: LD_INT 4
5682: PPUSH
5683: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
5687: LD_VAR 0 7
5691: PPUSH
5692: LD_INT 13
5694: PPUSH
5695: LD_INT 0
5697: PPUSH
5698: CALL_OW 49
// uc_side := 2 ;
5702: LD_ADDR_OWVAR 20
5706: PUSH
5707: LD_INT 2
5709: ST_TO_ADDR
// uc_nation := 2 ;
5710: LD_ADDR_OWVAR 21
5714: PUSH
5715: LD_INT 2
5717: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5718: LD_INT 0
5720: PPUSH
5721: LD_INT 1
5723: PPUSH
5724: LD_VAR 0 4
5728: PPUSH
5729: CALL_OW 380
// un := CreateHuman ;
5733: LD_ADDR_VAR 0 6
5737: PUSH
5738: CALL_OW 44
5742: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
5743: LD_VAR 0 6
5747: PPUSH
5748: LD_VAR 0 7
5752: PPUSH
5753: CALL_OW 52
// force := force ^ un ;
5757: LD_ADDR_VAR 0 8
5761: PUSH
5762: LD_VAR 0 8
5766: PUSH
5767: LD_VAR 0 6
5771: ADD
5772: ST_TO_ADDR
// end else
5773: GO 5813
// begin force := PrepareArabianTroops ( [ 3 , 4 , 5 ] [ Difficulty ] , skill , arArea2 ) ;
5775: LD_ADDR_VAR 0 8
5779: PUSH
5780: LD_INT 3
5782: PUSH
5783: LD_INT 4
5785: PUSH
5786: LD_INT 5
5788: PUSH
5789: EMPTY
5790: LIST
5791: LIST
5792: LIST
5793: PUSH
5794: LD_OWVAR 67
5798: ARRAY
5799: PPUSH
5800: LD_VAR 0 4
5804: PPUSH
5805: LD_INT 14
5807: PPUSH
5808: CALL 5236 0 3
5812: ST_TO_ADDR
// end ; if force then
5813: LD_VAR 0 8
5817: IFFALSE 5829
// ar_forces := force ;
5819: LD_ADDR_EXP 26
5823: PUSH
5824: LD_VAR 0 8
5828: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5829: LD_INT 35
5831: PPUSH
5832: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
5836: LD_INT 22
5838: PUSH
5839: LD_INT 2
5841: PUSH
5842: EMPTY
5843: LIST
5844: LIST
5845: PUSH
5846: LD_INT 21
5848: PUSH
5849: LD_INT 1
5851: PUSH
5852: EMPTY
5853: LIST
5854: LIST
5855: PUSH
5856: EMPTY
5857: LIST
5858: LIST
5859: PPUSH
5860: CALL_OW 69
5864: PUSH
5865: LD_INT 0
5867: EQUAL
5868: IFFALSE 5829
// Wait ( timer ) ;
5870: LD_VAR 0 2
5874: PPUSH
5875: CALL_OW 67
// force := PrepareArabianTroops ( [ 5 , 6 , 6 ] [ Difficulty ] , skill , [ arArea1 , arArea2 ] [ rand ( 1 , 2 ) ] ) ;
5879: LD_ADDR_VAR 0 8
5883: PUSH
5884: LD_INT 5
5886: PUSH
5887: LD_INT 6
5889: PUSH
5890: LD_INT 6
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: LIST
5897: PUSH
5898: LD_OWVAR 67
5902: ARRAY
5903: PPUSH
5904: LD_VAR 0 4
5908: PPUSH
5909: LD_INT 13
5911: PUSH
5912: LD_INT 14
5914: PUSH
5915: EMPTY
5916: LIST
5917: LIST
5918: PUSH
5919: LD_INT 1
5921: PPUSH
5922: LD_INT 2
5924: PPUSH
5925: CALL_OW 12
5929: ARRAY
5930: PPUSH
5931: CALL 5236 0 3
5935: ST_TO_ADDR
// if Difficulty > 1 and Delta then
5936: LD_OWVAR 67
5940: PUSH
5941: LD_INT 1
5943: GREATER
5944: PUSH
5945: LD_EXP 6
5949: AND
5950: IFFALSE 6029
// begin uc_side := 2 ;
5952: LD_ADDR_OWVAR 20
5956: PUSH
5957: LD_INT 2
5959: ST_TO_ADDR
// uc_nation := 2 ;
5960: LD_ADDR_OWVAR 21
5964: PUSH
5965: LD_INT 2
5967: ST_TO_ADDR
// PrepareHuman ( false , 2 , skill ) ;
5968: LD_INT 0
5970: PPUSH
5971: LD_INT 2
5973: PPUSH
5974: LD_VAR 0 4
5978: PPUSH
5979: CALL_OW 380
// eng := CreateHuman ;
5983: LD_ADDR_VAR 0 5
5987: PUSH
5988: CALL_OW 44
5992: ST_TO_ADDR
// PlaceUnitArea ( eng , arArea1 , false ) ;
5993: LD_VAR 0 5
5997: PPUSH
5998: LD_INT 13
6000: PPUSH
6001: LD_INT 0
6003: PPUSH
6004: CALL_OW 49
// Wait ( 3 ) ;
6008: LD_INT 3
6010: PPUSH
6011: CALL_OW 67
// AddComEnterUnit ( eng , Delta ) ;
6015: LD_VAR 0 5
6019: PPUSH
6020: LD_EXP 6
6024: PPUSH
6025: CALL_OW 180
// end ; if force then
6029: LD_VAR 0 8
6033: IFFALSE 6045
// ar_forces := force ;
6035: LD_ADDR_EXP 26
6039: PUSH
6040: LD_VAR 0 8
6044: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6045: LD_INT 35
6047: PPUSH
6048: CALL_OW 67
// if eng then
6052: LD_VAR 0 5
6056: IFFALSE 6110
// if GetSide ( Delta ) = 2 and IsOk ( eng ) and not IsInUnit ( eng ) then
6058: LD_EXP 6
6062: PPUSH
6063: CALL_OW 255
6067: PUSH
6068: LD_INT 2
6070: EQUAL
6071: PUSH
6072: LD_VAR 0 5
6076: PPUSH
6077: CALL_OW 302
6081: AND
6082: PUSH
6083: LD_VAR 0 5
6087: PPUSH
6088: CALL_OW 310
6092: NOT
6093: AND
6094: IFFALSE 6110
// ComEnterUnit ( eng , Delta ) ;
6096: LD_VAR 0 5
6100: PPUSH
6101: LD_EXP 6
6105: PPUSH
6106: CALL_OW 120
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6110: LD_INT 22
6112: PUSH
6113: LD_INT 2
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 21
6122: PUSH
6123: LD_INT 1
6125: PUSH
6126: EMPTY
6127: LIST
6128: LIST
6129: PUSH
6130: EMPTY
6131: LIST
6132: LIST
6133: PPUSH
6134: CALL_OW 69
6138: PUSH
6139: LD_INT 0
6141: EQUAL
6142: IFFALSE 6045
// ap_killers := PrepareArabianTroops ( [ 1 , 2 , 2 ] [ Difficulty ] , skill , arArea1 ) ;
6144: LD_ADDR_EXP 27
6148: PUSH
6149: LD_INT 1
6151: PUSH
6152: LD_INT 2
6154: PUSH
6155: LD_INT 2
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: LIST
6162: PUSH
6163: LD_OWVAR 67
6167: ARRAY
6168: PPUSH
6169: LD_VAR 0 4
6173: PPUSH
6174: LD_INT 13
6176: PPUSH
6177: CALL 5236 0 3
6181: ST_TO_ADDR
// Wait ( timer * 2 ) ;
6182: LD_VAR 0 2
6186: PUSH
6187: LD_INT 2
6189: MUL
6190: PPUSH
6191: CALL_OW 67
// ar_forces := PrepareArabianTroops ( [ 5 , 6 , 7 ] [ Difficulty ] , skill , arArea1 ) ^ PrepareArabianTroops ( [ 3 , 4 , 4 ] [ Difficulty ] , skill , arArea2 ) ;
6195: LD_ADDR_EXP 26
6199: PUSH
6200: LD_INT 5
6202: PUSH
6203: LD_INT 6
6205: PUSH
6206: LD_INT 7
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: LIST
6213: PUSH
6214: LD_OWVAR 67
6218: ARRAY
6219: PPUSH
6220: LD_VAR 0 4
6224: PPUSH
6225: LD_INT 13
6227: PPUSH
6228: CALL 5236 0 3
6232: PUSH
6233: LD_INT 3
6235: PUSH
6236: LD_INT 4
6238: PUSH
6239: LD_INT 4
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: LIST
6246: PUSH
6247: LD_OWVAR 67
6251: ARRAY
6252: PPUSH
6253: LD_VAR 0 4
6257: PPUSH
6258: LD_INT 14
6260: PPUSH
6261: CALL 5236 0 3
6265: ADD
6266: ST_TO_ADDR
// end ;
6267: PPOPN 8
6269: END
// every 0 0$03 trigger ar_forces do var i , target ;
6270: LD_EXP 26
6274: IFFALSE 6413
6276: GO 6278
6278: DISABLE
6279: LD_INT 0
6281: PPUSH
6282: PPUSH
// begin enable ;
6283: ENABLE
// if not ar_forces then
6284: LD_EXP 26
6288: NOT
6289: IFFALSE 6293
// exit ;
6291: GO 6413
// if Delta then
6293: LD_EXP 6
6297: IFFALSE 6311
// target := Delta else
6299: LD_ADDR_VAR 0 2
6303: PUSH
6304: LD_EXP 6
6308: ST_TO_ADDR
6309: GO 6321
// target := JMM ;
6311: LD_ADDR_VAR 0 2
6315: PUSH
6316: LD_EXP 15
6320: ST_TO_ADDR
// for i in ar_forces do
6321: LD_ADDR_VAR 0 1
6325: PUSH
6326: LD_EXP 26
6330: PUSH
6331: FOR_IN
6332: IFFALSE 6411
// begin if GetDistUnits ( i , target ) > 30 then
6334: LD_VAR 0 1
6338: PPUSH
6339: LD_VAR 0 2
6343: PPUSH
6344: CALL_OW 296
6348: PUSH
6349: LD_INT 30
6351: GREATER
6352: IFFALSE 6385
// ComAgressiveMove ( i , GetX ( target ) , GetY ( target ) ) else
6354: LD_VAR 0 1
6358: PPUSH
6359: LD_VAR 0 2
6363: PPUSH
6364: CALL_OW 250
6368: PPUSH
6369: LD_VAR 0 2
6373: PPUSH
6374: CALL_OW 251
6378: PPUSH
6379: CALL_OW 114
6383: GO 6409
// Attack ( i , FilterAllUnits ( [ f_enemy , 2 ] ) ) ;
6385: LD_VAR 0 1
6389: PPUSH
6390: LD_INT 81
6392: PUSH
6393: LD_INT 2
6395: PUSH
6396: EMPTY
6397: LIST
6398: LIST
6399: PPUSH
6400: CALL_OW 69
6404: PPUSH
6405: CALL 612 0 2
// end ;
6409: GO 6331
6411: POP
6412: POP
// end ;
6413: PPOPN 2
6415: END
// every 0 0$01 trigger ap_killers do var filter , i , target ;
6416: LD_EXP 27
6420: IFFALSE 6580
6422: GO 6424
6424: DISABLE
6425: LD_INT 0
6427: PPUSH
6428: PPUSH
6429: PPUSH
// begin enable ;
6430: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6431: LD_ADDR_VAR 0 1
6435: PUSH
6436: LD_INT 22
6438: PUSH
6439: LD_INT 0
6441: PUSH
6442: EMPTY
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 25
6448: PUSH
6449: LD_INT 12
6451: PUSH
6452: EMPTY
6453: LIST
6454: LIST
6455: PUSH
6456: EMPTY
6457: LIST
6458: LIST
6459: PPUSH
6460: CALL_OW 69
6464: ST_TO_ADDR
// if not filter then
6465: LD_VAR 0 1
6469: NOT
6470: IFFALSE 6497
// begin ar_forces := ar_forces ^ ap_killers ;
6472: LD_ADDR_EXP 26
6476: PUSH
6477: LD_EXP 26
6481: PUSH
6482: LD_EXP 27
6486: ADD
6487: ST_TO_ADDR
// ap_killers := [ ] ;
6488: LD_ADDR_EXP 27
6492: PUSH
6493: EMPTY
6494: ST_TO_ADDR
// exit ;
6495: GO 6580
// end ; for i in ap_killers do
6497: LD_ADDR_VAR 0 2
6501: PUSH
6502: LD_EXP 27
6506: PUSH
6507: FOR_IN
6508: IFFALSE 6578
// begin if not IsOk ( i ) then
6510: LD_VAR 0 2
6514: PPUSH
6515: CALL_OW 302
6519: NOT
6520: IFFALSE 6524
// continue ;
6522: GO 6507
// if not HasTask ( i ) then
6524: LD_VAR 0 2
6528: PPUSH
6529: CALL_OW 314
6533: NOT
6534: IFFALSE 6556
// target := NearestUnitToUnit ( filter , i ) ;
6536: LD_ADDR_VAR 0 3
6540: PUSH
6541: LD_VAR 0 1
6545: PPUSH
6546: LD_VAR 0 2
6550: PPUSH
6551: CALL_OW 74
6555: ST_TO_ADDR
// if target then
6556: LD_VAR 0 3
6560: IFFALSE 6576
// ComAttackUnit ( i , target ) ;
6562: LD_VAR 0 2
6566: PPUSH
6567: LD_VAR 0 3
6571: PPUSH
6572: CALL_OW 115
// end ;
6576: GO 6507
6578: POP
6579: POP
// end ; end_of_file
6580: PPOPN 3
6582: END
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
6583: LD_EXP 6
6587: IFFALSE 6719
6589: GO 6591
6591: DISABLE
6592: LD_INT 0
6594: PPUSH
6595: PPUSH
6596: PPUSH
// begin counter := [ 500 , 400 , 300 ] [ Difficulty ] ;
6597: LD_ADDR_VAR 0 2
6601: PUSH
6602: LD_INT 500
6604: PUSH
6605: LD_INT 400
6607: PUSH
6608: LD_INT 300
6610: PUSH
6611: EMPTY
6612: LIST
6613: LIST
6614: LIST
6615: PUSH
6616: LD_OWVAR 67
6620: ARRAY
6621: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
6622: LD_INT 1
6624: PPUSH
6625: LD_INT 3
6627: PPUSH
6628: CALL_OW 12
6632: PPUSH
6633: LD_INT 7
6635: PPUSH
6636: LD_INT 1
6638: PPUSH
6639: CALL_OW 55
// repeat wait ( rand ( 1 1$30 , 2 2$20 ) ) ;
6643: LD_INT 3150
6645: PPUSH
6646: LD_INT 4900
6648: PPUSH
6649: CALL_OW 12
6653: PPUSH
6654: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
6658: LD_ADDR_VAR 0 3
6662: PUSH
6663: LD_INT 1
6665: PPUSH
6666: LD_INT 5
6668: PPUSH
6669: CALL_OW 12
6673: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
6674: LD_VAR 0 3
6678: PPUSH
6679: LD_INT 7
6681: PPUSH
6682: LD_INT 1
6684: PPUSH
6685: CALL_OW 55
// counter := counter - cr * 10 ;
6689: LD_ADDR_VAR 0 2
6693: PUSH
6694: LD_VAR 0 2
6698: PUSH
6699: LD_VAR 0 3
6703: PUSH
6704: LD_INT 10
6706: MUL
6707: MINUS
6708: ST_TO_ADDR
// until counter <= 0 ;
6709: LD_VAR 0 2
6713: PUSH
6714: LD_INT 0
6716: LESSEQUAL
6717: IFFALSE 6643
// end ;
6719: PPOPN 3
6721: END
// every 0 0$03 trigger not Delta do var i ;
6722: LD_EXP 6
6726: NOT
6727: IFFALSE 6797
6729: GO 6731
6731: DISABLE
6732: LD_INT 0
6734: PPUSH
// begin for i = 1 to 4 - Difficulty do
6735: LD_ADDR_VAR 0 1
6739: PUSH
6740: DOUBLE
6741: LD_INT 1
6743: DEC
6744: ST_TO_ADDR
6745: LD_INT 4
6747: PUSH
6748: LD_OWVAR 67
6752: MINUS
6753: PUSH
6754: FOR_TO
6755: IFFALSE 6795
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
6757: LD_INT 2
6759: PPUSH
6760: LD_INT 5
6762: PPUSH
6763: CALL_OW 12
6767: PPUSH
6768: LD_INT 8
6770: PPUSH
6771: LD_INT 1
6773: PPUSH
6774: CALL_OW 55
// Wait ( rand ( 0 0$16 , 0 0$39 ) ) ;
6778: LD_INT 560
6780: PPUSH
6781: LD_INT 1365
6783: PPUSH
6784: CALL_OW 12
6788: PPUSH
6789: CALL_OW 67
// end ;
6793: GO 6754
6795: POP
6796: POP
// end ;
6797: PPOPN 1
6799: END
// every 2 2$00 trigger tick < 15 15$00 do
6800: LD_OWVAR 1
6804: PUSH
6805: LD_INT 31500
6807: LESS
6808: IFFALSE 6868
6810: GO 6812
6812: DISABLE
// begin enable ;
6813: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
6814: LD_INT 1
6816: PPUSH
6817: LD_INT 3
6819: PPUSH
6820: CALL_OW 12
6824: PPUSH
6825: LD_INT 1
6827: PPUSH
6828: CALL_OW 57
// Wait ( rand ( 0 0$38 , 0 0$59 ) ) ;
6832: LD_INT 1330
6834: PPUSH
6835: LD_INT 2065
6837: PPUSH
6838: CALL_OW 12
6842: PPUSH
6843: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 4 ) , riverArea , true ) ;
6847: LD_INT 1
6849: PPUSH
6850: LD_INT 4
6852: PPUSH
6853: CALL_OW 12
6857: PPUSH
6858: LD_INT 15
6860: PPUSH
6861: LD_INT 1
6863: PPUSH
6864: CALL_OW 55
// end ; end_of_file
6868: END
// on UnitDestroyed ( un ) do begin if un = JMM then
6869: LD_VAR 0 1
6873: PUSH
6874: LD_EXP 15
6878: EQUAL
6879: IFFALSE 6888
// YouLost ( JMM ) ;
6881: LD_STRING JMM
6883: PPUSH
6884: CALL_OW 104
// if un = Delta then
6888: LD_VAR 0 1
6892: PUSH
6893: LD_EXP 6
6897: EQUAL
6898: IFFALSE 6908
// Delta := 0 ;
6900: LD_ADDR_EXP 6
6904: PUSH
6905: LD_INT 0
6907: ST_TO_ADDR
// if un in ar_forces then
6908: LD_VAR 0 1
6912: PUSH
6913: LD_EXP 26
6917: IN
6918: IFFALSE 6936
// ar_forces := ar_forces diff un ;
6920: LD_ADDR_EXP 26
6924: PUSH
6925: LD_EXP 26
6929: PUSH
6930: LD_VAR 0 1
6934: DIFF
6935: ST_TO_ADDR
// if un in ap_killers then
6936: LD_VAR 0 1
6940: PUSH
6941: LD_EXP 27
6945: IN
6946: IFFALSE 6964
// ap_killers := ap_killers diff un ;
6948: LD_ADDR_EXP 27
6952: PUSH
6953: LD_EXP 27
6957: PUSH
6958: LD_VAR 0 1
6962: DIFF
6963: ST_TO_ADDR
// end ;
6964: PPOPN 1
6966: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
6967: LD_VAR 0 1
6971: PUSH
6972: LD_INT 1
6974: EQUAL
6975: PUSH
6976: LD_VAR 0 2
6980: PUSH
6981: LD_INT 2
6983: EQUAL
6984: AND
6985: PUSH
6986: LD_EXP 13
6990: NOT
6991: AND
6992: IFFALSE 7002
// arab_spotted := true ;
6994: LD_ADDR_EXP 13
6998: PUSH
6999: LD_INT 1
7001: ST_TO_ADDR
7002: PPOPN 2
7004: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
7005: LD_ADDR_OWVAR 57
7009: PUSH
7010: LD_INT 0
7012: ST_TO_ADDR
// end_mission := true ;
7013: LD_ADDR_EXP 14
7017: PUSH
7018: LD_INT 1
7020: ST_TO_ADDR
// end ;
7021: PPOPN 1
7023: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
7024: LD_VAR 0 2
7028: PPUSH
7029: CALL_OW 255
7033: PUSH
7034: LD_INT 1
7036: EQUAL
7037: IFFALSE 7053
// apeman_counter := apeman_counter + 1 ;
7039: LD_ADDR_EXP 12
7043: PUSH
7044: LD_EXP 12
7048: PUSH
7049: LD_INT 1
7051: PLUS
7052: ST_TO_ADDR
// if not first_apeman_tamed then
7053: LD_EXP 8
7057: NOT
7058: IFFALSE 7258
// begin first_apeman_tamed := true ;
7060: LD_ADDR_EXP 8
7064: PUSH
7065: LD_INT 1
7067: ST_TO_ADDR
// if sci = Gladstone then
7068: LD_VAR 0 2
7072: PUSH
7073: LD_EXP 16
7077: EQUAL
7078: IFFALSE 7092
// Say ( Gladstone , D7b-Glad-1 ) ;
7080: LD_EXP 16
7084: PPUSH
7085: LD_STRING D7b-Glad-1
7087: PPUSH
7088: CALL_OW 88
// if sci = Denis then
7092: LD_VAR 0 2
7096: PUSH
7097: LD_EXP 18
7101: EQUAL
7102: IFFALSE 7116
// Say ( Denis , D7a-Den-1 ) ;
7104: LD_EXP 18
7108: PPUSH
7109: LD_STRING D7a-Den-1
7111: PPUSH
7112: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
7116: LD_VAR 0 2
7120: PUSH
7121: LD_EXP 15
7125: PUSH
7126: LD_EXP 16
7130: PUSH
7131: LD_EXP 18
7135: PUSH
7136: LD_EXP 21
7140: PUSH
7141: LD_EXP 22
7145: PUSH
7146: LD_EXP 23
7150: PUSH
7151: LD_EXP 24
7155: PUSH
7156: LD_EXP 20
7160: PUSH
7161: EMPTY
7162: LIST
7163: LIST
7164: LIST
7165: LIST
7166: LIST
7167: LIST
7168: LIST
7169: LIST
7170: IN
7171: NOT
7172: IFFALSE 7215
// begin if GetSex ( sci ) = sex_male then
7174: LD_VAR 0 2
7178: PPUSH
7179: CALL_OW 258
7183: PUSH
7184: LD_INT 1
7186: EQUAL
7187: IFFALSE 7203
// Say ( sci , D7c-Sci1-1 ) else
7189: LD_VAR 0 2
7193: PPUSH
7194: LD_STRING D7c-Sci1-1
7196: PPUSH
7197: CALL_OW 88
7201: GO 7215
// Say ( sci , D7c-FSci1-1 ) ;
7203: LD_VAR 0 2
7207: PPUSH
7208: LD_STRING D7c-FSci1-1
7210: PPUSH
7211: CALL_OW 88
// end ; if not sci = Gladstone then
7215: LD_VAR 0 2
7219: PUSH
7220: LD_EXP 16
7224: EQUAL
7225: NOT
7226: IFFALSE 7240
// Say ( Gladstone , D7c-Glad-1 ) ;
7228: LD_EXP 16
7232: PPUSH
7233: LD_STRING D7c-Glad-1
7235: PPUSH
7236: CALL_OW 88
// if Lisa then
7240: LD_EXP 21
7244: IFFALSE 7258
// Say ( Lisa , D8-Lisa-1 ) ;
7246: LD_EXP 21
7250: PPUSH
7251: LD_STRING D8-Lisa-1
7253: PPUSH
7254: CALL_OW 88
// end ; end ;
7258: PPOPN 2
7260: END
