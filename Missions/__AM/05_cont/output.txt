// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 72 0 0
// InitRestrictions ;
  12: CALL 192 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 26
// DebugMode ;
  22: CALL 273 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  26: LD_INT 12
  28: PPUSH
  29: LD_INT 2
  31: PPUSH
  32: CALL 527 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 6 ] [ Difficulty ] ) ;
  36: LD_INT 11
  38: PPUSH
  39: LD_INT 10
  41: PUSH
  42: LD_INT 8
  44: PUSH
  45: LD_INT 6
  47: PUSH
  48: EMPTY
  49: LIST
  50: LIST
  51: LIST
  52: PUSH
  53: LD_OWVAR 67
  57: ARRAY
  58: PPUSH
  59: CALL 527 0 2
// PrepareAmericans ;
  63: CALL 1074 0 0
// Action ;
  67: CALL 1972 0 0
// end ;
  71: END
// export debug ; export mission_prefix , mission_prefix_prev ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed , apeman_army , radar_researched , radar_builded ; export apeman_counter , arab_spotted , end_mission ; function Init ; begin
  72: LD_INT 0
  74: PPUSH
// debug := false ;
  75: LD_ADDR_EXP 1
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// mission_prefix := 05_ ;
  83: LD_ADDR_EXP 2
  87: PUSH
  88: LD_STRING 05_
  90: ST_TO_ADDR
// mission_prefix_prev := 04_ ;
  91: LD_ADDR_EXP 3
  95: PUSH
  96: LD_STRING 04_
  98: ST_TO_ADDR
// deltaBuilded := false ;
  99: LD_ADDR_EXP 4
 103: PUSH
 104: LD_INT 0
 106: ST_TO_ADDR
// denisArrives := false ;
 107: LD_ADDR_EXP 5
 111: PUSH
 112: LD_INT 0
 114: ST_TO_ADDR
// radar_allowed := false ;
 115: LD_ADDR_EXP 7
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// first_apeman_tamed := false ;
 123: LD_ADDR_EXP 8
 127: PUSH
 128: LD_INT 0
 130: ST_TO_ADDR
// arab_spotted := false ;
 131: LD_ADDR_EXP 13
 135: PUSH
 136: LD_INT 0
 138: ST_TO_ADDR
// end_mission := false ;
 139: LD_ADDR_EXP 14
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// apeman_army := false ;
 147: LD_ADDR_EXP 9
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// radar_researched := false ;
 155: LD_ADDR_EXP 10
 159: PUSH
 160: LD_INT 0
 162: ST_TO_ADDR
// radar_builded := false ;
 163: LD_ADDR_EXP 11
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// apeman_counter := 0 ;
 171: LD_ADDR_EXP 12
 175: PUSH
 176: LD_INT 0
 178: ST_TO_ADDR
// Delta := 0 ;
 179: LD_ADDR_EXP 6
 183: PUSH
 184: LD_INT 0
 186: ST_TO_ADDR
// end ;
 187: LD_VAR 0 1
 191: RET
// function InitRestrictions ; begin
 192: LD_INT 0
 194: PPUSH
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
 195: LD_INT 7
 197: PPUSH
 198: LD_INT 1
 200: PPUSH
 201: LD_INT 1
 203: PPUSH
 204: CALL_OW 324
// SetRestrict ( b_lab_full , 1 , state_enabled ) ;
 208: LD_INT 8
 210: PPUSH
 211: LD_INT 1
 213: PPUSH
 214: LD_INT 1
 216: PPUSH
 217: CALL_OW 324
// SetRestrict ( b_lab_weapon , 1 , state_enabled ) ;
 221: LD_INT 10
 223: PPUSH
 224: LD_INT 1
 226: PPUSH
 227: LD_INT 1
 229: PPUSH
 230: CALL_OW 324
// SetTech ( tech_gatling , 1 , LoadVariable ( GatlingInGamma , 1 ) ) ;
 234: LD_INT 69
 236: PPUSH
 237: LD_INT 1
 239: PPUSH
 240: LD_STRING GatlingInGamma
 242: PPUSH
 243: LD_INT 1
 245: PPUSH
 246: CALL_OW 30
 250: PPUSH
 251: CALL_OW 322
// SetTech ( tech_weap1 , 1 , state_enabled ) ;
 255: LD_INT 51
 257: PPUSH
 258: LD_INT 1
 260: PPUSH
 261: LD_INT 1
 263: PPUSH
 264: CALL_OW 322
// end ;
 268: LD_VAR 0 1
 272: RET
// function DebugMode ; begin
 273: LD_INT 0
 275: PPUSH
// FogOff ( 1 ) ;
 276: LD_INT 1
 278: PPUSH
 279: CALL_OW 344
// Difficulty := 2 ;
 283: LD_ADDR_OWVAR 67
 287: PUSH
 288: LD_INT 2
 290: ST_TO_ADDR
// end ; end_of_file
 291: LD_VAR 0 1
 295: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 296: LD_INT 0
 298: PPUSH
 299: PPUSH
// if exist_mode then
 300: LD_VAR 0 2
 304: IFFALSE 329
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 306: LD_ADDR_VAR 0 4
 310: PUSH
 311: LD_EXP 3
 315: PUSH
 316: LD_VAR 0 1
 320: STR
 321: PPUSH
 322: CALL_OW 34
 326: ST_TO_ADDR
 327: GO 344
// unit := NewCharacter ( ident ) ;
 329: LD_ADDR_VAR 0 4
 333: PUSH
 334: LD_VAR 0 1
 338: PPUSH
 339: CALL_OW 25
 343: ST_TO_ADDR
// result := unit ;
 344: LD_ADDR_VAR 0 3
 348: PUSH
 349: LD_VAR 0 4
 353: ST_TO_ADDR
// end ;
 354: LD_VAR 0 3
 358: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 359: LD_INT 0
 361: PPUSH
// uc_side := side ;
 362: LD_ADDR_OWVAR 20
 366: PUSH
 367: LD_VAR 0 1
 371: ST_TO_ADDR
// uc_nation := nation ;
 372: LD_ADDR_OWVAR 21
 376: PUSH
 377: LD_VAR 0 2
 381: ST_TO_ADDR
// vc_chassis := chassis ;
 382: LD_ADDR_OWVAR 37
 386: PUSH
 387: LD_VAR 0 3
 391: ST_TO_ADDR
// vc_engine := engine ;
 392: LD_ADDR_OWVAR 39
 396: PUSH
 397: LD_VAR 0 4
 401: ST_TO_ADDR
// vc_control := control ;
 402: LD_ADDR_OWVAR 38
 406: PUSH
 407: LD_VAR 0 5
 411: ST_TO_ADDR
// vc_weapon := weapon ;
 412: LD_ADDR_OWVAR 40
 416: PUSH
 417: LD_VAR 0 6
 421: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 422: LD_ADDR_OWVAR 41
 426: PUSH
 427: LD_VAR 0 7
 431: ST_TO_ADDR
// result := CreateVehicle ;
 432: LD_ADDR_VAR 0 8
 436: PUSH
 437: CALL_OW 45
 441: ST_TO_ADDR
// end ;
 442: LD_VAR 0 8
 446: RET
// export function SayX ( units , ident ) ; var i ; begin
 447: LD_INT 0
 449: PPUSH
 450: PPUSH
// result := false ;
 451: LD_ADDR_VAR 0 3
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// if not units then
 459: LD_VAR 0 1
 463: NOT
 464: IFFALSE 468
// exit ;
 466: GO 522
// for i in units do
 468: LD_ADDR_VAR 0 4
 472: PUSH
 473: LD_VAR 0 1
 477: PUSH
 478: FOR_IN
 479: IFFALSE 520
// if IsOk ( i ) then
 481: LD_VAR 0 4
 485: PPUSH
 486: CALL_OW 302
 490: IFFALSE 518
// begin Say ( i , ident ) ;
 492: LD_VAR 0 4
 496: PPUSH
 497: LD_VAR 0 2
 501: PPUSH
 502: CALL_OW 88
// result := i ;
 506: LD_ADDR_VAR 0 3
 510: PUSH
 511: LD_VAR 0 4
 515: ST_TO_ADDR
// break ;
 516: GO 520
// end ;
 518: GO 478
 520: POP
 521: POP
// end ;
 522: LD_VAR 0 3
 526: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 527: LD_INT 0
 529: PPUSH
 530: PPUSH
// InitUc ;
 531: CALL_OW 18
// InitHc ;
 535: CALL_OW 19
// uc_side := 0 ;
 539: LD_ADDR_OWVAR 20
 543: PUSH
 544: LD_INT 0
 546: ST_TO_ADDR
// uc_nation := 0 ;
 547: LD_ADDR_OWVAR 21
 551: PUSH
 552: LD_INT 0
 554: ST_TO_ADDR
// for i = 1 to amount do
 555: LD_ADDR_VAR 0 4
 559: PUSH
 560: DOUBLE
 561: LD_INT 1
 563: DEC
 564: ST_TO_ADDR
 565: LD_VAR 0 2
 569: PUSH
 570: FOR_TO
 571: IFFALSE 605
// begin PrepareHuman ( false , class_apeman , 1 ) ;
 573: LD_INT 0
 575: PPUSH
 576: LD_INT 12
 578: PPUSH
 579: LD_INT 1
 581: PPUSH
 582: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 586: CALL_OW 44
 590: PPUSH
 591: LD_VAR 0 1
 595: PPUSH
 596: LD_INT 0
 598: PPUSH
 599: CALL_OW 49
// end ;
 603: GO 570
 605: POP
 606: POP
// end ;
 607: LD_VAR 0 3
 611: RET
// export function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
 612: LD_INT 0
 614: PPUSH
 615: PPUSH
 616: PPUSH
// if not unit then
 617: LD_VAR 0 1
 621: NOT
 622: IFFALSE 626
// exit ;
 624: GO 1069
// if IsInUnit ( unit ) then
 626: LD_VAR 0 1
 630: PPUSH
 631: CALL_OW 310
 635: IFFALSE 652
// unit := IsDrivenBy ( unit ) ;
 637: LD_ADDR_VAR 0 1
 641: PUSH
 642: LD_VAR 0 1
 646: PPUSH
 647: CALL_OW 311
 651: ST_TO_ADDR
// targets_list := [ ] ;
 652: LD_ADDR_VAR 0 5
 656: PUSH
 657: EMPTY
 658: ST_TO_ADDR
// target := UnitFilter ( enemy_list , [ [ f_lives , 250 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 659: LD_ADDR_VAR 0 4
 663: PUSH
 664: LD_VAR 0 2
 668: PPUSH
 669: LD_INT 24
 671: PUSH
 672: LD_INT 250
 674: PUSH
 675: EMPTY
 676: LIST
 677: LIST
 678: PUSH
 679: LD_INT 3
 681: PUSH
 682: LD_INT 34
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PUSH
 692: EMPTY
 693: LIST
 694: LIST
 695: PUSH
 696: LD_INT 21
 698: PUSH
 699: LD_INT 2
 701: PUSH
 702: EMPTY
 703: LIST
 704: LIST
 705: PUSH
 706: LD_INT 58
 708: PUSH
 709: EMPTY
 710: LIST
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PPUSH
 718: CALL_OW 72
 722: ST_TO_ADDR
// if GetDistUnits ( NearestUnitToUnit ( target , unit ) , unit ) < 11 and not IsInUnit ( unit ) then
 723: LD_VAR 0 4
 727: PPUSH
 728: LD_VAR 0 1
 732: PPUSH
 733: CALL_OW 74
 737: PPUSH
 738: LD_VAR 0 1
 742: PPUSH
 743: CALL_OW 296
 747: PUSH
 748: LD_INT 11
 750: LESS
 751: PUSH
 752: LD_VAR 0 1
 756: PPUSH
 757: CALL_OW 310
 761: NOT
 762: AND
 763: IFFALSE 791
// begin ComEnterUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 765: LD_VAR 0 1
 769: PPUSH
 770: LD_VAR 0 4
 774: PPUSH
 775: LD_VAR 0 1
 779: PPUSH
 780: CALL_OW 74
 784: PPUSH
 785: CALL_OW 120
// exit ;
 789: GO 1069
// end ; targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
 791: LD_ADDR_VAR 0 5
 795: PUSH
 796: LD_VAR 0 2
 800: PPUSH
 801: LD_INT 21
 803: PUSH
 804: LD_INT 1
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 54
 816: PUSH
 817: EMPTY
 818: LIST
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: PUSH
 824: EMPTY
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL_OW 72
 832: PUSH
 833: LD_VAR 0 2
 837: PPUSH
 838: LD_INT 21
 840: PUSH
 841: LD_INT 2
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: PPUSH
 848: CALL_OW 72
 852: PUSH
 853: LD_VAR 0 2
 857: PPUSH
 858: LD_INT 21
 860: PUSH
 861: LD_INT 3
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: LD_INT 3
 870: PUSH
 871: LD_INT 58
 873: PUSH
 874: EMPTY
 875: LIST
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: PUSH
 881: EMPTY
 882: LIST
 883: LIST
 884: PPUSH
 885: CALL_OW 72
 889: PUSH
 890: LD_VAR 0 2
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: ST_TO_ADDR
// for target in targets_list do
 901: LD_ADDR_VAR 0 4
 905: PUSH
 906: LD_VAR 0 5
 910: PUSH
 911: FOR_IN
 912: IFFALSE 1067
// begin if target then
 914: LD_VAR 0 4
 918: IFFALSE 1065
// if GetTag ( unit ) = 11 and ( GetType ( NearestUnitToUnit ( target , unit ) ) = unit_building or GetWeapon ( NearestUnitToUnit ( target , unit ) ) = us_cargo_bay ) then
 920: LD_VAR 0 1
 924: PPUSH
 925: CALL_OW 110
 929: PUSH
 930: LD_INT 11
 932: EQUAL
 933: PUSH
 934: LD_VAR 0 4
 938: PPUSH
 939: LD_VAR 0 1
 943: PPUSH
 944: CALL_OW 74
 948: PPUSH
 949: CALL_OW 247
 953: PUSH
 954: LD_INT 3
 956: EQUAL
 957: PUSH
 958: LD_VAR 0 4
 962: PPUSH
 963: LD_VAR 0 1
 967: PPUSH
 968: CALL_OW 74
 972: PPUSH
 973: CALL_OW 264
 977: PUSH
 978: LD_INT 12
 980: EQUAL
 981: OR
 982: AND
 983: IFFALSE 1029
// begin ComPlaceDelayedCharge ( unit , 0 , 0 , NearestUnitToUnit ( target , unit ) ) ;
 985: LD_VAR 0 1
 989: PPUSH
 990: LD_INT 0
 992: PPUSH
 993: LD_INT 0
 995: PPUSH
 996: LD_VAR 0 4
1000: PPUSH
1001: LD_VAR 0 1
1005: PPUSH
1006: CALL_OW 74
1010: PPUSH
1011: CALL_OW 132
// SetTag ( unit , 0 ) ;
1015: LD_VAR 0 1
1019: PPUSH
1020: LD_INT 0
1022: PPUSH
1023: CALL_OW 109
// end else
1027: GO 1065
// if not HasTask ( unit ) then
1029: LD_VAR 0 1
1033: PPUSH
1034: CALL_OW 314
1038: NOT
1039: IFFALSE 1065
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
1041: LD_VAR 0 1
1045: PPUSH
1046: LD_VAR 0 4
1050: PPUSH
1051: LD_VAR 0 1
1055: PPUSH
1056: CALL_OW 74
1060: PPUSH
1061: CALL_OW 115
// end ;
1065: GO 911
1067: POP
1068: POP
// end ; end_of_file
1069: LD_VAR 0 3
1073: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
1074: LD_INT 0
1076: PPUSH
1077: PPUSH
1078: PPUSH
1079: PPUSH
1080: PPUSH
// uc_nation := 1 ;
1081: LD_ADDR_OWVAR 21
1085: PUSH
1086: LD_INT 1
1088: ST_TO_ADDR
// uc_side := 4 ;
1089: LD_ADDR_OWVAR 20
1093: PUSH
1094: LD_INT 4
1096: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
1097: LD_ADDR_EXP 18
1101: PUSH
1102: LD_STRING Denis
1104: PPUSH
1105: LD_INT 0
1107: PPUSH
1108: CALL 296 0 2
1112: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
1113: LD_ADDR_EXP 17
1117: PUSH
1118: LD_STRING Harisson
1120: PPUSH
1121: LD_INT 0
1123: PPUSH
1124: CALL 296 0 2
1128: ST_TO_ADDR
// uc_side := 1 ;
1129: LD_ADDR_OWVAR 20
1133: PUSH
1134: LD_INT 1
1136: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1137: LD_ADDR_EXP 15
1141: PUSH
1142: LD_STRING JMM
1144: PPUSH
1145: LD_EXP 1
1149: NOT
1150: PPUSH
1151: CALL 296 0 2
1155: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
1156: LD_ADDR_EXP 16
1160: PUSH
1161: LD_STRING Gladstone
1163: PPUSH
1164: LD_INT 0
1166: PPUSH
1167: CALL 296 0 2
1171: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
1172: LD_STRING BrownInDelta
1174: PPUSH
1175: LD_EXP 1
1179: PPUSH
1180: CALL_OW 30
1184: IFFALSE 1221
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1186: LD_ADDR_EXP 19
1190: PUSH
1191: LD_STRING Brown
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: CALL 296 0 2
1204: ST_TO_ADDR
// tmp := tmp ^ Brown ;
1205: LD_ADDR_VAR 0 5
1209: PUSH
1210: LD_VAR 0 5
1214: PUSH
1215: LD_EXP 19
1219: ADD
1220: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , 0 ) then
1221: LD_STRING DonaldsonInDelta
1223: PPUSH
1224: LD_INT 0
1226: PPUSH
1227: CALL_OW 30
1231: IFFALSE 1268
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1233: LD_ADDR_EXP 20
1237: PUSH
1238: LD_STRING Donaldson
1240: PPUSH
1241: LD_EXP 1
1245: NOT
1246: PPUSH
1247: CALL 296 0 2
1251: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
1252: LD_ADDR_VAR 0 5
1256: PUSH
1257: LD_VAR 0 5
1261: PUSH
1262: LD_EXP 20
1266: ADD
1267: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
1268: LD_STRING LisaInDelta
1270: PPUSH
1271: LD_EXP 1
1275: PPUSH
1276: CALL_OW 30
1280: IFFALSE 1317
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1282: LD_ADDR_EXP 21
1286: PUSH
1287: LD_STRING Lisa
1289: PPUSH
1290: LD_EXP 1
1294: NOT
1295: PPUSH
1296: CALL 296 0 2
1300: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
1301: LD_ADDR_VAR 0 5
1305: PUSH
1306: LD_VAR 0 5
1310: PUSH
1311: LD_EXP 21
1315: ADD
1316: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
1317: LD_STRING FrankInDelta
1319: PPUSH
1320: LD_EXP 1
1324: PPUSH
1325: CALL_OW 30
1329: IFFALSE 1366
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
1331: LD_ADDR_EXP 22
1335: PUSH
1336: LD_STRING Frank
1338: PPUSH
1339: LD_EXP 1
1343: NOT
1344: PPUSH
1345: CALL 296 0 2
1349: ST_TO_ADDR
// tmp := tmp ^ Frank ;
1350: LD_ADDR_VAR 0 5
1354: PUSH
1355: LD_VAR 0 5
1359: PUSH
1360: LD_EXP 22
1364: ADD
1365: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
1366: LD_STRING BobbyInDelta
1368: PPUSH
1369: LD_INT 0
1371: PPUSH
1372: CALL_OW 30
1376: IFFALSE 1413
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1378: LD_ADDR_EXP 23
1382: PUSH
1383: LD_STRING Bobby
1385: PPUSH
1386: LD_EXP 1
1390: NOT
1391: PPUSH
1392: CALL 296 0 2
1396: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
1397: LD_ADDR_VAR 0 5
1401: PUSH
1402: LD_VAR 0 5
1406: PUSH
1407: LD_EXP 23
1411: ADD
1412: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
1413: LD_STRING CyrusInDelta
1415: PPUSH
1416: LD_INT 0
1418: PPUSH
1419: CALL_OW 30
1423: IFFALSE 1460
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1425: LD_ADDR_EXP 24
1429: PUSH
1430: LD_STRING Cyrus
1432: PPUSH
1433: LD_EXP 1
1437: NOT
1438: PPUSH
1439: CALL 296 0 2
1443: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
1444: LD_ADDR_VAR 0 5
1448: PUSH
1449: LD_VAR 0 5
1453: PUSH
1454: LD_EXP 24
1458: ADD
1459: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
1460: LD_ADDR_EXP 25
1464: PUSH
1465: LD_STRING othersDelta
1467: PPUSH
1468: CALL_OW 31
1472: ST_TO_ADDR
// if not others and debug then
1473: LD_EXP 25
1477: NOT
1478: PUSH
1479: LD_EXP 1
1483: AND
1484: IFFALSE 1549
// begin InitHc ;
1486: CALL_OW 19
// for i = 1 to 2 do
1490: LD_ADDR_VAR 0 2
1494: PUSH
1495: DOUBLE
1496: LD_INT 1
1498: DEC
1499: ST_TO_ADDR
1500: LD_INT 2
1502: PUSH
1503: FOR_TO
1504: IFFALSE 1547
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
1506: LD_INT 0
1508: PPUSH
1509: LD_VAR 0 2
1513: PUSH
1514: LD_INT 4
1516: MOD
1517: PUSH
1518: LD_INT 1
1520: PLUS
1521: PPUSH
1522: LD_INT 3
1524: PPUSH
1525: CALL_OW 380
// others := others ^ CreateHuman ;
1529: LD_ADDR_EXP 25
1533: PUSH
1534: LD_EXP 25
1538: PUSH
1539: CALL_OW 44
1543: ADD
1544: ST_TO_ADDR
// end ;
1545: GO 1503
1547: POP
1548: POP
// end ; if others then
1549: LD_EXP 25
1553: IFFALSE 1571
// tmp := tmp ^ others ;
1555: LD_ADDR_VAR 0 5
1559: PUSH
1560: LD_VAR 0 5
1564: PUSH
1565: LD_EXP 25
1569: ADD
1570: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
1571: LD_ADDR_VAR 0 3
1575: PUSH
1576: LD_INT 28
1578: PUSH
1579: LD_INT 49
1581: PUSH
1582: EMPTY
1583: LIST
1584: LIST
1585: PUSH
1586: LD_INT 33
1588: PUSH
1589: LD_INT 54
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PUSH
1596: LD_INT 38
1598: PUSH
1599: LD_INT 56
1601: PUSH
1602: EMPTY
1603: LIST
1604: LIST
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: LIST
1610: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1611: LD_ADDR_VAR 0 4
1615: PUSH
1616: LD_INT 1
1618: PPUSH
1619: LD_INT 1
1621: PPUSH
1622: LD_INT 2
1624: PPUSH
1625: LD_INT 2
1627: PPUSH
1628: LD_INT 1
1630: PPUSH
1631: LD_INT 12
1633: PPUSH
1634: LD_INT 80
1636: PPUSH
1637: CALL 359 0 7
1641: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1642: LD_VAR 0 4
1646: PPUSH
1647: LD_INT 1
1649: PPUSH
1650: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1654: LD_VAR 0 4
1658: PPUSH
1659: LD_VAR 0 3
1663: PUSH
1664: LD_INT 1
1666: ARRAY
1667: PUSH
1668: LD_INT 1
1670: ARRAY
1671: PPUSH
1672: LD_VAR 0 3
1676: PUSH
1677: LD_INT 1
1679: ARRAY
1680: PUSH
1681: LD_INT 2
1683: ARRAY
1684: PPUSH
1685: LD_INT 0
1687: PPUSH
1688: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1692: LD_VAR 0 4
1696: PPUSH
1697: LD_INT 1
1699: PPUSH
1700: LD_INT 100
1702: PPUSH
1703: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1707: LD_EXP 25
1711: PUSH
1712: LD_INT 1
1714: ARRAY
1715: PPUSH
1716: LD_VAR 0 4
1720: PPUSH
1721: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1725: LD_ADDR_VAR 0 4
1729: PUSH
1730: LD_INT 1
1732: PPUSH
1733: LD_INT 1
1735: PPUSH
1736: LD_INT 1
1738: PPUSH
1739: LD_INT 2
1741: PPUSH
1742: LD_INT 1
1744: PPUSH
1745: LD_INT 2
1747: PPUSH
1748: LD_INT 80
1750: PPUSH
1751: CALL 359 0 7
1755: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1756: LD_VAR 0 4
1760: PPUSH
1761: LD_INT 1
1763: PPUSH
1764: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1768: LD_VAR 0 4
1772: PPUSH
1773: LD_VAR 0 3
1777: PUSH
1778: LD_INT 2
1780: ARRAY
1781: PUSH
1782: LD_INT 1
1784: ARRAY
1785: PPUSH
1786: LD_VAR 0 3
1790: PUSH
1791: LD_INT 2
1793: ARRAY
1794: PUSH
1795: LD_INT 2
1797: ARRAY
1798: PPUSH
1799: LD_INT 0
1801: PPUSH
1802: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1806: LD_EXP 16
1810: PPUSH
1811: LD_VAR 0 4
1815: PPUSH
1816: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
1820: LD_ADDR_VAR 0 4
1824: PUSH
1825: LD_INT 1
1827: PPUSH
1828: LD_INT 1
1830: PPUSH
1831: LD_INT 1
1833: PPUSH
1834: LD_INT 2
1836: PPUSH
1837: LD_INT 1
1839: PPUSH
1840: LD_INT 3
1842: PPUSH
1843: LD_INT 80
1845: PPUSH
1846: CALL 359 0 7
1850: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1851: LD_VAR 0 4
1855: PPUSH
1856: LD_INT 1
1858: PPUSH
1859: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
1863: LD_VAR 0 4
1867: PPUSH
1868: LD_VAR 0 3
1872: PUSH
1873: LD_INT 3
1875: ARRAY
1876: PUSH
1877: LD_INT 1
1879: ARRAY
1880: PPUSH
1881: LD_VAR 0 3
1885: PUSH
1886: LD_INT 3
1888: ARRAY
1889: PUSH
1890: LD_INT 2
1892: ARRAY
1893: PPUSH
1894: LD_INT 0
1896: PPUSH
1897: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1901: LD_EXP 15
1905: PPUSH
1906: LD_VAR 0 4
1910: PPUSH
1911: CALL_OW 52
// if others > 1 then
1915: LD_EXP 25
1919: PUSH
1920: LD_INT 1
1922: GREATER
1923: IFFALSE 1967
// for i in tmp diff others [ 1 ] do
1925: LD_ADDR_VAR 0 2
1929: PUSH
1930: LD_VAR 0 5
1934: PUSH
1935: LD_EXP 25
1939: PUSH
1940: LD_INT 1
1942: ARRAY
1943: DIFF
1944: PUSH
1945: FOR_IN
1946: IFFALSE 1965
// PlaceUnitArea ( i , startArea , false ) ;
1948: LD_VAR 0 2
1952: PPUSH
1953: LD_INT 5
1955: PPUSH
1956: LD_INT 0
1958: PPUSH
1959: CALL_OW 49
1963: GO 1945
1965: POP
1966: POP
// end ; end_of_file
1967: LD_VAR 0 1
1971: RET
// export function Action ; var m ; begin
1972: LD_INT 0
1974: PPUSH
1975: PPUSH
// InGameOn ;
1976: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
1980: LD_INT 28
1982: PPUSH
1983: LD_INT 51
1985: PPUSH
1986: CALL_OW 86
// Wait ( 3 ) ;
1990: LD_INT 3
1992: PPUSH
1993: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
1997: LD_EXP 15
2001: PPUSH
2002: LD_STRING D1d-JMM-1a
2004: PPUSH
2005: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
2009: LD_EXP 17
2013: PPUSH
2014: LD_STRING D1d-Har-1
2016: PPUSH
2017: CALL_OW 94
// InGameOff ;
2021: CALL_OW 9
// SaveForQuickRestart ;
2025: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
2029: LD_STRING M1
2031: PPUSH
2032: CALL_OW 337
// Wait ( 0 0$2 ) ;
2036: LD_INT 70
2038: PPUSH
2039: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
2043: LD_EXP 15
2047: PPUSH
2048: LD_STRING D2-JMM-1
2050: PPUSH
2051: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
2055: LD_EXP 16
2059: PPUSH
2060: LD_STRING D2-Glad-1
2062: PPUSH
2063: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2067: LD_EXP 15
2071: PPUSH
2072: LD_STRING D2-JMM-2
2074: PPUSH
2075: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
2079: LD_EXP 16
2083: PPUSH
2084: LD_STRING D2-Glad-2
2086: PPUSH
2087: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2091: LD_EXP 15
2095: PPUSH
2096: LD_STRING D2-JMM-3
2098: PPUSH
2099: CALL_OW 88
// Wait ( rand ( 0 0$30 , 1 1$00 ) ) ;
2103: LD_INT 1050
2105: PPUSH
2106: LD_INT 2100
2108: PPUSH
2109: CALL_OW 12
2113: PPUSH
2114: CALL_OW 67
// SetWeather ( 2 , 90 , 150 ) ;
2118: LD_INT 2
2120: PPUSH
2121: LD_INT 90
2123: PPUSH
2124: LD_INT 150
2126: PPUSH
2127: CALL_OW 550
// Wait ( rand ( 3 3$00 , 5 5$00 ) ) ;
2131: LD_INT 6300
2133: PPUSH
2134: LD_INT 10500
2136: PPUSH
2137: CALL_OW 12
2141: PPUSH
2142: CALL_OW 67
// SetWeather ( 0 , 90 , 150 ) ;
2146: LD_INT 0
2148: PPUSH
2149: LD_INT 90
2151: PPUSH
2152: LD_INT 150
2154: PPUSH
2155: CALL_OW 550
// end ;
2159: LD_VAR 0 1
2163: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
2164: LD_INT 22
2166: PUSH
2167: LD_INT 1
2169: PUSH
2170: EMPTY
2171: LIST
2172: LIST
2173: PUSH
2174: LD_INT 3
2176: PUSH
2177: LD_INT 57
2179: PUSH
2180: EMPTY
2181: LIST
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 30
2189: PUSH
2190: LD_INT 0
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: EMPTY
2198: LIST
2199: LIST
2200: LIST
2201: PUSH
2202: EMPTY
2203: LIST
2204: PPUSH
2205: CALL_OW 69
2209: PUSH
2210: LD_EXP 4
2214: NOT
2215: AND
2216: IFFALSE 2229
2218: GO 2220
2220: DISABLE
// begin deltaBuilded := true ;
2221: LD_ADDR_EXP 4
2225: PUSH
2226: LD_INT 1
2228: ST_TO_ADDR
// end ;
2229: END
// every 0 0$01 trigger not Delta and deltaBuilded and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) do
2230: LD_EXP 6
2234: NOT
2235: PUSH
2236: LD_EXP 4
2240: AND
2241: PUSH
2242: LD_INT 22
2244: PUSH
2245: LD_INT 1
2247: PUSH
2248: EMPTY
2249: LIST
2250: LIST
2251: PUSH
2252: LD_INT 3
2254: PUSH
2255: LD_INT 57
2257: PUSH
2258: EMPTY
2259: LIST
2260: PUSH
2261: EMPTY
2262: LIST
2263: LIST
2264: PUSH
2265: LD_INT 30
2267: PUSH
2268: LD_INT 0
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: PUSH
2280: EMPTY
2281: LIST
2282: PPUSH
2283: CALL_OW 69
2287: AND
2288: IFFALSE 2361
2290: GO 2292
2292: DISABLE
// begin enable ;
2293: ENABLE
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
2294: LD_ADDR_EXP 6
2298: PUSH
2299: LD_INT 22
2301: PUSH
2302: LD_INT 1
2304: PUSH
2305: EMPTY
2306: LIST
2307: LIST
2308: PUSH
2309: LD_INT 3
2311: PUSH
2312: LD_INT 57
2314: PUSH
2315: EMPTY
2316: LIST
2317: PUSH
2318: EMPTY
2319: LIST
2320: LIST
2321: PUSH
2322: LD_INT 30
2324: PUSH
2325: LD_INT 0
2327: PUSH
2328: EMPTY
2329: LIST
2330: LIST
2331: PUSH
2332: EMPTY
2333: LIST
2334: LIST
2335: LIST
2336: PUSH
2337: EMPTY
2338: LIST
2339: PPUSH
2340: CALL_OW 69
2344: PUSH
2345: LD_INT 1
2347: ARRAY
2348: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
2349: LD_EXP 6
2353: PPUSH
2354: LD_STRING Delta
2356: PPUSH
2357: CALL_OW 500
// end ;
2361: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched do
2362: LD_INT 1
2364: PPUSH
2365: LD_INT 1
2367: PPUSH
2368: CALL_OW 321
2372: PUSH
2373: LD_INT 2
2375: EQUAL
2376: IFFALSE 2437
2378: GO 2380
2380: DISABLE
// begin DialogueOn ;
2381: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
2385: LD_EXP 16
2389: PPUSH
2390: LD_STRING D3-Glad-1
2392: PPUSH
2393: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2397: LD_EXP 15
2401: PPUSH
2402: LD_STRING D3-JMM-1
2404: PPUSH
2405: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
2409: LD_EXP 16
2413: PPUSH
2414: LD_STRING D3-Glad-2
2416: PPUSH
2417: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
2421: LD_EXP 15
2425: PPUSH
2426: LD_STRING D3-JMM-2
2428: PPUSH
2429: CALL_OW 88
// DialogueOff ;
2433: CALL_OW 7
// end ;
2437: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
2438: LD_INT 2
2440: PPUSH
2441: LD_INT 1
2443: PPUSH
2444: CALL_OW 321
2448: PUSH
2449: LD_INT 2
2451: EQUAL
2452: IFFALSE 2629
2454: GO 2456
2456: DISABLE
2457: LD_INT 0
2459: PPUSH
// begin DialogueOn ;
2460: CALL_OW 6
// if Frank then
2464: LD_EXP 22
2468: IFFALSE 2482
// Say ( Frank , D8a-Frank-1 ) ;
2470: LD_EXP 22
2474: PPUSH
2475: LD_STRING D8a-Frank-1
2477: PPUSH
2478: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
2482: LD_ADDR_VAR 0 1
2486: PUSH
2487: LD_EXP 25
2491: PPUSH
2492: LD_INT 26
2494: PUSH
2495: LD_INT 1
2497: PUSH
2498: EMPTY
2499: LIST
2500: LIST
2501: PPUSH
2502: CALL_OW 72
2506: PPUSH
2507: LD_STRING D8a-Sol1-1
2509: PPUSH
2510: CALL 447 0 2
2514: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2515: LD_EXP 18
2519: PUSH
2520: LD_EXP 18
2524: PPUSH
2525: CALL_OW 255
2529: PUSH
2530: LD_INT 1
2532: EQUAL
2533: AND
2534: IFFALSE 2548
// Say ( Denis , D8a-Den-1 ) ;
2536: LD_EXP 18
2540: PPUSH
2541: LD_STRING D8a-Den-1
2543: PPUSH
2544: CALL_OW 88
// if sol or Denis or Frank then
2548: LD_VAR 0 1
2552: PUSH
2553: LD_EXP 18
2557: OR
2558: PUSH
2559: LD_EXP 22
2563: OR
2564: IFFALSE 2625
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2566: LD_EXP 25
2570: PPUSH
2571: LD_INT 25
2573: PUSH
2574: LD_INT 4
2576: PUSH
2577: EMPTY
2578: LIST
2579: LIST
2580: PUSH
2581: LD_INT 26
2583: PUSH
2584: LD_INT 1
2586: PUSH
2587: EMPTY
2588: LIST
2589: LIST
2590: PUSH
2591: EMPTY
2592: LIST
2593: LIST
2594: PPUSH
2595: CALL_OW 72
2599: PUSH
2600: LD_VAR 0 1
2604: DIFF
2605: PPUSH
2606: LD_STRING D8a-Sci1-1
2608: PPUSH
2609: CALL 447 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2613: LD_EXP 15
2617: PPUSH
2618: LD_STRING D8a-JMM-1
2620: PPUSH
2621: CALL_OW 88
// end ; DialogueOff ;
2625: CALL_OW 7
// end ;
2629: PPOPN 1
2631: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2632: LD_INT 22
2634: PUSH
2635: LD_INT 1
2637: PUSH
2638: EMPTY
2639: LIST
2640: LIST
2641: PUSH
2642: LD_INT 25
2644: PUSH
2645: LD_INT 16
2647: PUSH
2648: EMPTY
2649: LIST
2650: LIST
2651: PUSH
2652: EMPTY
2653: LIST
2654: LIST
2655: PPUSH
2656: CALL_OW 69
2660: IFFALSE 2719
2662: GO 2664
2664: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2665: LD_STRING M1a
2667: PPUSH
2668: CALL_OW 337
// case Query ( Q2 ) of 1 :
2672: LD_STRING Q2
2674: PPUSH
2675: CALL_OW 97
2679: PUSH
2680: LD_INT 1
2682: DOUBLE
2683: EQUAL
2684: IFTRUE 2688
2686: GO 2699
2688: POP
// end_mission := true ; 2 :
2689: LD_ADDR_EXP 14
2693: PUSH
2694: LD_INT 1
2696: ST_TO_ADDR
2697: GO 2719
2699: LD_INT 2
2701: DOUBLE
2702: EQUAL
2703: IFTRUE 2707
2705: GO 2718
2707: POP
// end_the_mission_allowed := true ; end ;
2708: LD_ADDR_OWVAR 57
2712: PUSH
2713: LD_INT 1
2715: ST_TO_ADDR
2716: GO 2719
2718: POP
// end ;
2719: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) and Delta do
2720: LD_INT 22
2722: PUSH
2723: LD_INT 1
2725: PUSH
2726: EMPTY
2727: LIST
2728: LIST
2729: PUSH
2730: LD_INT 2
2732: PUSH
2733: LD_INT 30
2735: PUSH
2736: LD_INT 6
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PUSH
2743: LD_INT 30
2745: PUSH
2746: LD_INT 7
2748: PUSH
2749: EMPTY
2750: LIST
2751: LIST
2752: PUSH
2753: EMPTY
2754: LIST
2755: LIST
2756: LIST
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: PPUSH
2762: CALL_OW 69
2766: PUSH
2767: LD_INT 22
2769: PUSH
2770: LD_INT 1
2772: PUSH
2773: EMPTY
2774: LIST
2775: LIST
2776: PUSH
2777: LD_INT 2
2779: PUSH
2780: LD_INT 30
2782: PUSH
2783: LD_INT 2
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: LD_INT 30
2792: PUSH
2793: LD_INT 3
2795: PUSH
2796: EMPTY
2797: LIST
2798: LIST
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: LIST
2804: PUSH
2805: EMPTY
2806: LIST
2807: LIST
2808: PPUSH
2809: CALL_OW 69
2813: AND
2814: PUSH
2815: LD_EXP 6
2819: AND
2820: IFFALSE 3247
2822: GO 2824
2824: DISABLE
// begin Wait ( rand ( 0 0$20 , 0 0$40 ) ) ;
2825: LD_INT 700
2827: PPUSH
2828: LD_INT 1400
2830: PPUSH
2831: CALL_OW 12
2835: PPUSH
2836: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
2840: LD_EXP 18
2844: PPUSH
2845: LD_INT 6
2847: PUSH
2848: LD_INT 9
2850: PUSH
2851: LD_INT 10
2853: PUSH
2854: EMPTY
2855: LIST
2856: LIST
2857: LIST
2858: PUSH
2859: LD_OWVAR 67
2863: ARRAY
2864: PPUSH
2865: LD_INT 0
2867: PPUSH
2868: CALL_OW 49
// ComHold ( Denis ) ;
2872: LD_EXP 18
2876: PPUSH
2877: CALL_OW 140
// InGameOn ;
2881: CALL_OW 8
// DialogueOn ;
2885: CALL_OW 6
// if Delta then
2889: LD_EXP 6
2893: IFFALSE 2906
// CenterNowOnUnits ( Delta ) else
2895: LD_EXP 6
2899: PPUSH
2900: CALL_OW 87
2904: GO 2915
// CenterNowOnUnits ( JMM ) ;
2906: LD_EXP 15
2910: PPUSH
2911: CALL_OW 87
// Say ( Denis , DD-Den-1 ) ;
2915: LD_EXP 18
2919: PPUSH
2920: LD_STRING DD-Den-1
2922: PPUSH
2923: CALL_OW 88
// Say ( JMM , DD-JMM-1 ) ;
2927: LD_EXP 15
2931: PPUSH
2932: LD_STRING DD-JMM-1
2934: PPUSH
2935: CALL_OW 88
// Say ( Denis , DD-Den-2 ) ;
2939: LD_EXP 18
2943: PPUSH
2944: LD_STRING DD-Den-2
2946: PPUSH
2947: CALL_OW 88
// Wait ( 3 ) ;
2951: LD_INT 3
2953: PPUSH
2954: CALL_OW 67
// DialogueOff ;
2958: CALL_OW 7
// InGameOff ;
2962: CALL_OW 9
// repeat wait ( 0 0$01 ) ;
2966: LD_INT 35
2968: PPUSH
2969: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
2973: LD_INT 1
2975: PPUSH
2976: LD_EXP 18
2980: PPUSH
2981: CALL_OW 292
2985: PUSH
2986: LD_EXP 18
2990: PPUSH
2991: CALL_OW 301
2995: OR
2996: IFFALSE 2966
// if IsDead ( Denis ) then
2998: LD_EXP 18
3002: PPUSH
3003: CALL_OW 301
3007: IFFALSE 3011
// exit ;
3009: GO 3247
// SetSide ( Denis , 1 ) ;
3011: LD_EXP 18
3015: PPUSH
3016: LD_INT 1
3018: PPUSH
3019: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
3023: LD_EXP 18
3027: PPUSH
3028: LD_STRING DD-Den-2a
3030: PPUSH
3031: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
3035: LD_INT 35
3037: PPUSH
3038: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
3042: LD_EXP 18
3046: PPUSH
3047: CALL_OW 310
3051: PPUSH
3052: CALL_OW 266
3056: PUSH
3057: LD_INT 6
3059: PUSH
3060: LD_INT 7
3062: PUSH
3063: LD_INT 8
3065: PUSH
3066: EMPTY
3067: LIST
3068: LIST
3069: LIST
3070: IN
3071: PUSH
3072: LD_EXP 18
3076: PPUSH
3077: CALL_OW 301
3081: OR
3082: IFFALSE 3035
// if IsDead ( Denis ) then
3084: LD_EXP 18
3088: PPUSH
3089: CALL_OW 301
3093: IFFALSE 3097
// exit ;
3095: GO 3247
// Say ( Denis , DD-Den-2b ) ;
3097: LD_EXP 18
3101: PPUSH
3102: LD_STRING DD-Den-2b
3104: PPUSH
3105: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
3109: LD_EXP 18
3113: PPUSH
3114: LD_INT 4
3116: PPUSH
3117: CALL_OW 123
// Wait ( 0 0$02 ) ;
3121: LD_INT 70
3123: PPUSH
3124: CALL_OW 67
// DialogueOn ;
3128: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
3132: LD_EXP 18
3136: PPUSH
3137: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3141: LD_EXP 15
3145: PPUSH
3146: LD_STRING D4-JMM-1
3148: PPUSH
3149: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
3153: LD_EXP 18
3157: PPUSH
3158: LD_STRING D4-Den-1
3160: PPUSH
3161: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
3165: LD_EXP 15
3169: PPUSH
3170: LD_STRING D4-JMM-2
3172: PPUSH
3173: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
3177: LD_EXP 18
3181: PPUSH
3182: LD_STRING D4-Den-2
3184: PPUSH
3185: CALL_OW 88
// DialogueOff ;
3189: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
3193: LD_STRING M2
3195: PPUSH
3196: CALL_OW 337
// radar_allowed := true ;
3200: LD_ADDR_EXP 7
3204: PUSH
3205: LD_INT 1
3207: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
3208: LD_INT 6
3210: PPUSH
3211: LD_INT 1
3213: PPUSH
3214: LD_INT 1
3216: PPUSH
3217: CALL_OW 322
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
3221: LD_INT 15
3223: PPUSH
3224: LD_INT 1
3226: PPUSH
3227: LD_INT 1
3229: PPUSH
3230: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
3234: LD_INT 20
3236: PPUSH
3237: LD_INT 1
3239: PPUSH
3240: LD_INT 1
3242: PPUSH
3243: CALL_OW 324
// end ;
3247: END
// every 0 0$1 trigger arab_spotted do var sol , sol2 ;
3248: LD_EXP 13
3252: IFFALSE 3875
3254: GO 3256
3256: DISABLE
3257: LD_INT 0
3259: PPUSH
3260: PPUSH
// begin sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D5-Sol1-1 ) ;
3261: LD_ADDR_VAR 0 1
3265: PUSH
3266: LD_EXP 25
3270: PPUSH
3271: LD_INT 26
3273: PUSH
3274: LD_INT 1
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: PPUSH
3281: CALL_OW 72
3285: PPUSH
3286: LD_STRING D5-Sol1-1
3288: PPUSH
3289: CALL 447 0 2
3293: ST_TO_ADDR
// if not sol then
3294: LD_VAR 0 1
3298: NOT
3299: IFFALSE 3303
// exit ;
3301: GO 3875
// repeat wait ( 0 0$01 ) ;
3303: LD_INT 35
3305: PPUSH
3306: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
3310: LD_INT 22
3312: PUSH
3313: LD_INT 2
3315: PUSH
3316: EMPTY
3317: LIST
3318: LIST
3319: PUSH
3320: LD_INT 21
3322: PUSH
3323: LD_INT 1
3325: PUSH
3326: EMPTY
3327: LIST
3328: LIST
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PPUSH
3334: CALL_OW 69
3338: PUSH
3339: LD_INT 0
3341: EQUAL
3342: IFFALSE 3303
// if IsOk ( sol ) then
3344: LD_VAR 0 1
3348: PPUSH
3349: CALL_OW 302
3353: IFFALSE 3373
// begin sol2 := others diff sol ;
3355: LD_ADDR_VAR 0 2
3359: PUSH
3360: LD_EXP 25
3364: PUSH
3365: LD_VAR 0 1
3369: DIFF
3370: ST_TO_ADDR
// end else
3371: GO 3375
// exit ;
3373: GO 3875
// if not Lisa and not sol2 then
3375: LD_EXP 21
3379: NOT
3380: PUSH
3381: LD_VAR 0 2
3385: NOT
3386: AND
3387: IFFALSE 3391
// exit ;
3389: GO 3875
// DialogueOn ;
3391: CALL_OW 6
// if Lisa then
3395: LD_EXP 21
3399: IFFALSE 3415
// Say ( Lisa , D5a-Lisa-1 ) else
3401: LD_EXP 21
3405: PPUSH
3406: LD_STRING D5a-Lisa-1
3408: PPUSH
3409: CALL_OW 88
3413: GO 3490
// if sol2 then
3415: LD_VAR 0 2
3419: IFFALSE 3490
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3421: LD_VAR 0 2
3425: PUSH
3426: LD_INT 1
3428: ARRAY
3429: PPUSH
3430: CALL_OW 258
3434: PUSH
3435: LD_INT 1
3437: DOUBLE
3438: EQUAL
3439: IFTRUE 3443
3441: GO 3462
3443: POP
// Say ( sol2 [ 1 ] , D5-Sol2-1 ) ; sex_female :
3444: LD_VAR 0 2
3448: PUSH
3449: LD_INT 1
3451: ARRAY
3452: PPUSH
3453: LD_STRING D5-Sol2-1
3455: PPUSH
3456: CALL_OW 88
3460: GO 3490
3462: LD_INT 2
3464: DOUBLE
3465: EQUAL
3466: IFTRUE 3470
3468: GO 3489
3470: POP
// Say ( sol2 [ 1 ] , D5-FSol2-1 ) ; end ;
3471: LD_VAR 0 2
3475: PUSH
3476: LD_INT 1
3478: ARRAY
3479: PPUSH
3480: LD_STRING D5-FSol2-1
3482: PPUSH
3483: CALL_OW 88
3487: GO 3490
3489: POP
// Say ( sol , D5-Sol1-2 ) ;
3490: LD_VAR 0 1
3494: PPUSH
3495: LD_STRING D5-Sol1-2
3497: PPUSH
3498: CALL_OW 88
// if Lisa then
3502: LD_EXP 21
3506: IFFALSE 3522
// Say ( Lisa , D5a-Lisa-2 ) else
3508: LD_EXP 21
3512: PPUSH
3513: LD_STRING D5a-Lisa-2
3515: PPUSH
3516: CALL_OW 88
3520: GO 3597
// if sol2 then
3522: LD_VAR 0 2
3526: IFFALSE 3597
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3528: LD_VAR 0 2
3532: PUSH
3533: LD_INT 1
3535: ARRAY
3536: PPUSH
3537: CALL_OW 258
3541: PUSH
3542: LD_INT 1
3544: DOUBLE
3545: EQUAL
3546: IFTRUE 3550
3548: GO 3569
3550: POP
// Say ( sol2 [ 1 ] , D5-Sol2-2 ) ; sex_female :
3551: LD_VAR 0 2
3555: PUSH
3556: LD_INT 1
3558: ARRAY
3559: PPUSH
3560: LD_STRING D5-Sol2-2
3562: PPUSH
3563: CALL_OW 88
3567: GO 3597
3569: LD_INT 2
3571: DOUBLE
3572: EQUAL
3573: IFTRUE 3577
3575: GO 3596
3577: POP
// Say ( sol2 [ 1 ] , D5-FSol2-2 ) ; end ;
3578: LD_VAR 0 2
3582: PUSH
3583: LD_INT 1
3585: ARRAY
3586: PPUSH
3587: LD_STRING D5-FSol2-2
3589: PPUSH
3590: CALL_OW 88
3594: GO 3597
3596: POP
// Say ( sol , D5a-Sol1-3 ) ;
3597: LD_VAR 0 1
3601: PPUSH
3602: LD_STRING D5a-Sol1-3
3604: PPUSH
3605: CALL_OW 88
// if Lisa then
3609: LD_EXP 21
3613: IFFALSE 3627
// Say ( Lisa , D5a-Lisa-3 ) ;
3615: LD_EXP 21
3619: PPUSH
3620: LD_STRING D5a-Lisa-3
3622: PPUSH
3623: CALL_OW 88
// if not sol2 then
3627: LD_VAR 0 2
3631: NOT
3632: IFFALSE 3640
// begin DialogueOff ;
3634: CALL_OW 7
// exit ;
3638: GO 3875
// end ; case GetSex ( sol2 [ 1 ] ) of sex_male :
3640: LD_VAR 0 2
3644: PUSH
3645: LD_INT 1
3647: ARRAY
3648: PPUSH
3649: CALL_OW 258
3653: PUSH
3654: LD_INT 1
3656: DOUBLE
3657: EQUAL
3658: IFTRUE 3662
3660: GO 3681
3662: POP
// Say ( sol2 [ 1 ] , D5-Sol2-3 ) ; sex_female :
3663: LD_VAR 0 2
3667: PUSH
3668: LD_INT 1
3670: ARRAY
3671: PPUSH
3672: LD_STRING D5-Sol2-3
3674: PPUSH
3675: CALL_OW 88
3679: GO 3709
3681: LD_INT 2
3683: DOUBLE
3684: EQUAL
3685: IFTRUE 3689
3687: GO 3708
3689: POP
// Say ( sol2 [ 1 ] , D5-FSol2-3 ) ; end ;
3690: LD_VAR 0 2
3694: PUSH
3695: LD_INT 1
3697: ARRAY
3698: PPUSH
3699: LD_STRING D5-FSol2-3
3701: PPUSH
3702: CALL_OW 88
3706: GO 3709
3708: POP
// Say ( sol , D5-Sol1-4 ) ;
3709: LD_VAR 0 1
3713: PPUSH
3714: LD_STRING D5-Sol1-4
3716: PPUSH
3717: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3721: LD_VAR 0 2
3725: PUSH
3726: LD_INT 1
3728: ARRAY
3729: PPUSH
3730: CALL_OW 258
3734: PUSH
3735: LD_INT 1
3737: DOUBLE
3738: EQUAL
3739: IFTRUE 3743
3741: GO 3762
3743: POP
// Say ( sol2 [ 1 ] , D5-Sol2-4 ) ; sex_female :
3744: LD_VAR 0 2
3748: PUSH
3749: LD_INT 1
3751: ARRAY
3752: PPUSH
3753: LD_STRING D5-Sol2-4
3755: PPUSH
3756: CALL_OW 88
3760: GO 3790
3762: LD_INT 2
3764: DOUBLE
3765: EQUAL
3766: IFTRUE 3770
3768: GO 3789
3770: POP
// Say ( sol2 [ 1 ] , D5-FSol2-4 ) ; end ;
3771: LD_VAR 0 2
3775: PUSH
3776: LD_INT 1
3778: ARRAY
3779: PPUSH
3780: LD_STRING D5-FSol2-4
3782: PPUSH
3783: CALL_OW 88
3787: GO 3790
3789: POP
// Say ( sol , D5-Sol1-5 ) ;
3790: LD_VAR 0 1
3794: PPUSH
3795: LD_STRING D5-Sol1-5
3797: PPUSH
3798: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3802: LD_VAR 0 2
3806: PUSH
3807: LD_INT 1
3809: ARRAY
3810: PPUSH
3811: CALL_OW 258
3815: PUSH
3816: LD_INT 1
3818: DOUBLE
3819: EQUAL
3820: IFTRUE 3824
3822: GO 3843
3824: POP
// Say ( sol2 [ 1 ] , D5-Sol2-5 ) ; sex_female :
3825: LD_VAR 0 2
3829: PUSH
3830: LD_INT 1
3832: ARRAY
3833: PPUSH
3834: LD_STRING D5-Sol2-5
3836: PPUSH
3837: CALL_OW 88
3841: GO 3871
3843: LD_INT 2
3845: DOUBLE
3846: EQUAL
3847: IFTRUE 3851
3849: GO 3870
3851: POP
// Say ( sol2 [ 1 ] , D5-FSol2-5 ) ; end ;
3852: LD_VAR 0 2
3856: PUSH
3857: LD_INT 1
3859: ARRAY
3860: PPUSH
3861: LD_STRING D5-FSol2-5
3863: PPUSH
3864: CALL_OW 88
3868: GO 3871
3870: POP
// DialogueOff ;
3871: CALL_OW 7
// end ;
3875: PPOPN 2
3877: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 5 do
3878: LD_INT 22
3880: PUSH
3881: LD_INT 1
3883: PUSH
3884: EMPTY
3885: LIST
3886: LIST
3887: PUSH
3888: LD_INT 25
3890: PUSH
3891: LD_INT 16
3893: PUSH
3894: EMPTY
3895: LIST
3896: LIST
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: PPUSH
3902: CALL_OW 69
3906: PUSH
3907: LD_INT 5
3909: GREATEREQUAL
3910: IFFALSE 3930
3912: GO 3914
3914: DISABLE
// begin ChangeMissionObjectives ( M1b ) ;
3915: LD_STRING M1b
3917: PPUSH
3918: CALL_OW 337
// apeman_army := true ;
3922: LD_ADDR_EXP 9
3926: PUSH
3927: LD_INT 1
3929: ST_TO_ADDR
// end ;
3930: END
// every 0 0$1 trigger GetTech ( tech_radar , 1 ) = state_researched do
3931: LD_INT 6
3933: PPUSH
3934: LD_INT 1
3936: PPUSH
3937: CALL_OW 321
3941: PUSH
3942: LD_INT 2
3944: EQUAL
3945: IFFALSE 3965
3947: GO 3949
3949: DISABLE
// begin ChangeMissionObjectives ( M2a ) ;
3950: LD_STRING M2a
3952: PPUSH
3953: CALL_OW 337
// radar_researched := true ;
3957: LD_ADDR_EXP 10
3961: PUSH
3962: LD_INT 1
3964: ST_TO_ADDR
// end ;
3965: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_weapon , us_radar ] , [ f_bweapon , us_radar ] ] ] ) do
3966: LD_INT 22
3968: PUSH
3969: LD_INT 1
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: PUSH
3976: LD_INT 2
3978: PUSH
3979: LD_INT 34
3981: PUSH
3982: LD_INT 11
3984: PUSH
3985: EMPTY
3986: LIST
3987: LIST
3988: PUSH
3989: LD_INT 35
3991: PUSH
3992: LD_INT 11
3994: PUSH
3995: EMPTY
3996: LIST
3997: LIST
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: PUSH
4004: EMPTY
4005: LIST
4006: LIST
4007: PPUSH
4008: CALL_OW 69
4012: IFFALSE 4032
4014: GO 4016
4016: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
4017: LD_STRING M2b
4019: PPUSH
4020: CALL_OW 337
// radar_builded := true ;
4024: LD_ADDR_EXP 11
4028: PUSH
4029: LD_INT 1
4031: ST_TO_ADDR
// end ;
4032: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 and not first_apeman_tamed do
4033: LD_INT 22
4035: PUSH
4036: LD_INT 0
4038: PUSH
4039: EMPTY
4040: LIST
4041: LIST
4042: PUSH
4043: LD_INT 25
4045: PUSH
4046: LD_INT 12
4048: PUSH
4049: EMPTY
4050: LIST
4051: LIST
4052: PUSH
4053: EMPTY
4054: LIST
4055: LIST
4056: PPUSH
4057: CALL_OW 69
4061: PUSH
4062: LD_INT 0
4064: EQUAL
4065: PUSH
4066: LD_EXP 8
4070: NOT
4071: AND
4072: IFFALSE 4084
4074: GO 4076
4076: DISABLE
// YouLost ( Apeman ) ;
4077: LD_STRING Apeman
4079: PPUSH
4080: CALL_OW 104
4084: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 7 do var i , filter ;
4085: LD_INT 22
4087: PUSH
4088: LD_INT 1
4090: PUSH
4091: EMPTY
4092: LIST
4093: LIST
4094: PUSH
4095: LD_INT 25
4097: PUSH
4098: LD_INT 16
4100: PUSH
4101: EMPTY
4102: LIST
4103: LIST
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: PPUSH
4109: CALL_OW 69
4113: PUSH
4114: LD_INT 7
4116: GREATEREQUAL
4117: IFFALSE 4215
4119: GO 4121
4121: DISABLE
4122: LD_INT 0
4124: PPUSH
4125: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ^ JMM ;
4126: LD_ADDR_VAR 0 2
4130: PUSH
4131: LD_INT 22
4133: PUSH
4134: LD_INT 1
4136: PUSH
4137: EMPTY
4138: LIST
4139: LIST
4140: PUSH
4141: LD_INT 21
4143: PUSH
4144: LD_INT 1
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: PUSH
4151: LD_INT 25
4153: PUSH
4154: LD_INT 4
4156: PUSH
4157: EMPTY
4158: LIST
4159: LIST
4160: PUSH
4161: EMPTY
4162: LIST
4163: LIST
4164: LIST
4165: PPUSH
4166: CALL_OW 69
4170: PUSH
4171: LD_EXP 15
4175: ADD
4176: ST_TO_ADDR
// if filter then
4177: LD_VAR 0 2
4181: IFFALSE 4215
// for i in filter do
4183: LD_ADDR_VAR 0 1
4187: PUSH
4188: LD_VAR 0 2
4192: PUSH
4193: FOR_IN
4194: IFFALSE 4213
// AddExperience ( i , 4 , 3500 ) ;
4196: LD_VAR 0 1
4200: PPUSH
4201: LD_INT 4
4203: PPUSH
4204: LD_INT 3500
4206: PPUSH
4207: CALL_OW 492
4211: GO 4193
4213: POP
4214: POP
// end ;
4215: PPOPN 2
4217: END
// every 0 0$1 trigger end_mission do var i , tmp ;
4218: LD_EXP 14
4222: IFFALSE 5165
4224: GO 4226
4226: DISABLE
4227: LD_INT 0
4229: PPUSH
4230: PPUSH
// begin if FilterAllUnits ( [ f_side , 2 ] ) then
4231: LD_INT 22
4233: PUSH
4234: LD_INT 2
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PPUSH
4241: CALL_OW 69
4245: IFFALSE 4283
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
4247: LD_ADDR_VAR 0 1
4251: PUSH
4252: LD_INT 22
4254: PUSH
4255: LD_INT 2
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: PPUSH
4262: CALL_OW 69
4266: PUSH
4267: FOR_IN
4268: IFFALSE 4281
// RemoveUnit ( i ) ;
4270: LD_VAR 0 1
4274: PPUSH
4275: CALL_OW 64
4279: GO 4267
4281: POP
4282: POP
// if apeman_army then
4283: LD_EXP 9
4287: IFFALSE 4301
// AddMedal ( Tame , 1 ) else
4289: LD_STRING Tame
4291: PPUSH
4292: LD_INT 1
4294: PPUSH
4295: CALL_OW 101
4299: GO 4312
// AddMedal ( Tame , - 1 ) ;
4301: LD_STRING Tame
4303: PPUSH
4304: LD_INT 1
4306: NEG
4307: PPUSH
4308: CALL_OW 101
// if radar_researched then
4312: LD_EXP 10
4316: IFFALSE 4340
// begin SaveVariable ( true , radarResInDelta ) ;
4318: LD_INT 1
4320: PPUSH
4321: LD_STRING radarResInDelta
4323: PPUSH
4324: CALL_OW 39
// AddMedal ( Radar , 1 ) ;
4328: LD_STRING Radar
4330: PPUSH
4331: LD_INT 1
4333: PPUSH
4334: CALL_OW 101
// end else
4338: GO 4370
// if radar_allowed then
4340: LD_EXP 7
4344: IFFALSE 4359
// AddMedal ( Radar , - 2 ) else
4346: LD_STRING Radar
4348: PPUSH
4349: LD_INT 2
4351: NEG
4352: PPUSH
4353: CALL_OW 101
4357: GO 4370
// AddMedal ( Radar , - 1 ) ;
4359: LD_STRING Radar
4361: PPUSH
4362: LD_INT 1
4364: NEG
4365: PPUSH
4366: CALL_OW 101
// if radar_builded then
4370: LD_EXP 11
4374: IFFALSE 4388
// AddMedal ( BuildRadar , 1 ) else
4376: LD_STRING BuildRadar
4378: PPUSH
4379: LD_INT 1
4381: PPUSH
4382: CALL_OW 101
4386: GO 4399
// AddMedal ( BuildRadar , - 1 ) ;
4388: LD_STRING BuildRadar
4390: PPUSH
4391: LD_INT 1
4393: NEG
4394: PPUSH
4395: CALL_OW 101
// GiveMedals ( MAIN ) ;
4399: LD_STRING MAIN
4401: PPUSH
4402: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
4406: LD_ADDR_VAR 0 2
4410: PUSH
4411: LD_INT 22
4413: PUSH
4414: LD_INT 1
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PUSH
4421: LD_INT 21
4423: PUSH
4424: LD_INT 1
4426: PUSH
4427: EMPTY
4428: LIST
4429: LIST
4430: PUSH
4431: LD_INT 2
4433: PUSH
4434: LD_INT 25
4436: PUSH
4437: LD_INT 1
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: PUSH
4444: LD_INT 25
4446: PUSH
4447: LD_INT 2
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: PUSH
4454: LD_INT 25
4456: PUSH
4457: LD_INT 3
4459: PUSH
4460: EMPTY
4461: LIST
4462: LIST
4463: PUSH
4464: LD_INT 25
4466: PUSH
4467: LD_INT 4
4469: PUSH
4470: EMPTY
4471: LIST
4472: LIST
4473: PUSH
4474: EMPTY
4475: LIST
4476: LIST
4477: LIST
4478: LIST
4479: LIST
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL_OW 69
4490: ST_TO_ADDR
// RewardPeople ( tmp ) ;
4491: LD_VAR 0 2
4495: PPUSH
4496: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
4500: LD_EXP 15
4504: PPUSH
4505: LD_EXP 2
4509: PUSH
4510: LD_STRING JMM
4512: STR
4513: PPUSH
4514: CALL_OW 38
// if IsOk ( Gladstone ) then
4518: LD_EXP 16
4522: PPUSH
4523: CALL_OW 302
4527: IFFALSE 4547
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
4529: LD_EXP 16
4533: PPUSH
4534: LD_EXP 2
4538: PUSH
4539: LD_STRING Gladstone
4541: STR
4542: PPUSH
4543: CALL_OW 38
// end ; if IsOk ( Denis ) and GetSide ( Denis ) = 1 then
4547: LD_EXP 18
4551: PPUSH
4552: CALL_OW 302
4556: PUSH
4557: LD_EXP 18
4561: PPUSH
4562: CALL_OW 255
4566: PUSH
4567: LD_INT 1
4569: EQUAL
4570: AND
4571: IFFALSE 4591
// begin SaveCharacters ( Denis , mission_prefix & Denis ) ;
4573: LD_EXP 18
4577: PPUSH
4578: LD_EXP 2
4582: PUSH
4583: LD_STRING Denis
4585: STR
4586: PPUSH
4587: CALL_OW 38
// end ; if IsOk ( Lisa ) then
4591: LD_EXP 21
4595: PPUSH
4596: CALL_OW 302
4600: IFFALSE 4620
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
4602: LD_EXP 21
4606: PPUSH
4607: LD_EXP 2
4611: PUSH
4612: LD_STRING Lisa
4614: STR
4615: PPUSH
4616: CALL_OW 38
// end ; if IsOk ( Frank ) then
4620: LD_EXP 22
4624: PPUSH
4625: CALL_OW 302
4629: IFFALSE 4649
// begin SaveCharacters ( Frank , mission_prefix & Frank ) ;
4631: LD_EXP 22
4635: PPUSH
4636: LD_EXP 2
4640: PUSH
4641: LD_STRING Frank
4643: STR
4644: PPUSH
4645: CALL_OW 38
// end ; if IsOk ( Bobby ) then
4649: LD_EXP 23
4653: PPUSH
4654: CALL_OW 302
4658: IFFALSE 4678
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
4660: LD_EXP 23
4664: PPUSH
4665: LD_EXP 2
4669: PUSH
4670: LD_STRING Bobby
4672: STR
4673: PPUSH
4674: CALL_OW 38
// end ; if IsOk ( Cyrus ) then
4678: LD_EXP 24
4682: PPUSH
4683: CALL_OW 302
4687: IFFALSE 4707
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
4689: LD_EXP 24
4693: PPUSH
4694: LD_EXP 2
4698: PUSH
4699: LD_STRING Cyrus
4701: STR
4702: PPUSH
4703: CALL_OW 38
// end ; if others then
4707: LD_EXP 25
4711: IFFALSE 4725
// SaveCharacters ( others , othersInDelta ) ;
4713: LD_EXP 25
4717: PPUSH
4718: LD_STRING othersInDelta
4720: PPUSH
4721: CALL_OW 38
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) then
4725: LD_INT 22
4727: PUSH
4728: LD_INT 1
4730: PUSH
4731: EMPTY
4732: LIST
4733: LIST
4734: PUSH
4735: LD_INT 25
4737: PUSH
4738: LD_INT 16
4740: PUSH
4741: EMPTY
4742: LIST
4743: LIST
4744: PUSH
4745: EMPTY
4746: LIST
4747: LIST
4748: PPUSH
4749: CALL_OW 69
4753: IFFALSE 4791
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) , apeInDelta ) ;
4755: LD_INT 22
4757: PUSH
4758: LD_INT 1
4760: PUSH
4761: EMPTY
4762: LIST
4763: LIST
4764: PUSH
4765: LD_INT 25
4767: PUSH
4768: LD_INT 16
4770: PUSH
4771: EMPTY
4772: LIST
4773: LIST
4774: PUSH
4775: EMPTY
4776: LIST
4777: LIST
4778: PPUSH
4779: CALL_OW 69
4783: PPUSH
4784: LD_STRING apeInDelta
4786: PPUSH
4787: CALL_OW 38
// tmp := [ ] ;
4791: LD_ADDR_VAR 0 2
4795: PUSH
4796: EMPTY
4797: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) then
4798: LD_INT 22
4800: PUSH
4801: LD_INT 1
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PUSH
4808: LD_INT 21
4810: PUSH
4811: LD_INT 2
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: EMPTY
4819: LIST
4820: LIST
4821: PPUSH
4822: CALL_OW 69
4826: IFFALSE 4937
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
4828: LD_ADDR_VAR 0 1
4832: PUSH
4833: LD_INT 22
4835: PUSH
4836: LD_INT 1
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: LD_INT 21
4845: PUSH
4846: LD_INT 2
4848: PUSH
4849: EMPTY
4850: LIST
4851: LIST
4852: PUSH
4853: EMPTY
4854: LIST
4855: LIST
4856: PPUSH
4857: CALL_OW 69
4861: PUSH
4862: FOR_IN
4863: IFFALSE 4935
// tmp := tmp ^ [ GetNation ( i ) , GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
4865: LD_ADDR_VAR 0 2
4869: PUSH
4870: LD_VAR 0 2
4874: PUSH
4875: LD_VAR 0 1
4879: PPUSH
4880: CALL_OW 248
4884: PUSH
4885: LD_VAR 0 1
4889: PPUSH
4890: CALL_OW 265
4894: PUSH
4895: LD_VAR 0 1
4899: PPUSH
4900: CALL_OW 262
4904: PUSH
4905: LD_VAR 0 1
4909: PPUSH
4910: CALL_OW 263
4914: PUSH
4915: LD_VAR 0 1
4919: PPUSH
4920: CALL_OW 264
4924: PUSH
4925: EMPTY
4926: LIST
4927: LIST
4928: LIST
4929: LIST
4930: LIST
4931: ADD
4932: ST_TO_ADDR
4933: GO 4862
4935: POP
4936: POP
// if tmp then
4937: LD_VAR 0 2
4941: IFFALSE 4955
// SaveVariable ( tmp , vehiclesInDelta ) ;
4943: LD_VAR 0 2
4947: PPUSH
4948: LD_STRING vehiclesInDelta
4950: PPUSH
4951: CALL_OW 39
// tmp := [ ] ;
4955: LD_ADDR_VAR 0 2
4959: PUSH
4960: EMPTY
4961: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
4962: LD_INT 22
4964: PUSH
4965: LD_INT 1
4967: PUSH
4968: EMPTY
4969: LIST
4970: LIST
4971: PUSH
4972: LD_INT 21
4974: PUSH
4975: LD_INT 3
4977: PUSH
4978: EMPTY
4979: LIST
4980: LIST
4981: PUSH
4982: EMPTY
4983: LIST
4984: LIST
4985: PPUSH
4986: CALL_OW 69
4990: IFFALSE 5143
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4992: LD_ADDR_VAR 0 1
4996: PUSH
4997: LD_INT 22
4999: PUSH
5000: LD_INT 1
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: PUSH
5007: LD_INT 21
5009: PUSH
5010: LD_INT 3
5012: PUSH
5013: EMPTY
5014: LIST
5015: LIST
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: PPUSH
5021: CALL_OW 69
5025: PUSH
5026: FOR_IN
5027: IFFALSE 5141
// tmp := tmp ^ [ [ GetBType ( i ) , GetBLevel ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
5029: LD_ADDR_VAR 0 2
5033: PUSH
5034: LD_VAR 0 2
5038: PUSH
5039: LD_VAR 0 1
5043: PPUSH
5044: CALL_OW 266
5048: PUSH
5049: LD_VAR 0 1
5053: PPUSH
5054: CALL_OW 267
5058: PUSH
5059: LD_VAR 0 1
5063: PPUSH
5064: CALL_OW 250
5068: PUSH
5069: LD_VAR 0 1
5073: PPUSH
5074: CALL_OW 251
5078: PUSH
5079: LD_VAR 0 1
5083: PPUSH
5084: CALL_OW 254
5088: PUSH
5089: LD_VAR 0 1
5093: PPUSH
5094: LD_INT 1
5096: PPUSH
5097: CALL_OW 268
5101: PUSH
5102: LD_VAR 0 1
5106: PPUSH
5107: LD_INT 2
5109: PPUSH
5110: CALL_OW 268
5114: PUSH
5115: LD_VAR 0 1
5119: PPUSH
5120: CALL_OW 269
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: LIST
5129: LIST
5130: LIST
5131: LIST
5132: LIST
5133: LIST
5134: PUSH
5135: EMPTY
5136: LIST
5137: ADD
5138: ST_TO_ADDR
5139: GO 5026
5141: POP
5142: POP
// if tmp then
5143: LD_VAR 0 2
5147: IFFALSE 5161
// SaveVariable ( tmp , buildingsInDelta ) ;
5149: LD_VAR 0 2
5153: PPUSH
5154: LD_STRING buildingsInDelta
5156: PPUSH
5157: CALL_OW 39
// YouWin ;
5161: CALL_OW 103
// end ; end_of_file
5165: PPOPN 2
5167: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un , tmp ; begin
5168: LD_INT 0
5170: PPUSH
5171: PPUSH
5172: PPUSH
5173: PPUSH
// InitHc ;
5174: CALL_OW 19
// InitUc ;
5178: CALL_OW 18
// uc_side := 2 ;
5182: LD_ADDR_OWVAR 20
5186: PUSH
5187: LD_INT 2
5189: ST_TO_ADDR
// uc_nation := 2 ;
5190: LD_ADDR_OWVAR 21
5194: PUSH
5195: LD_INT 2
5197: ST_TO_ADDR
// if not amount then
5198: LD_VAR 0 1
5202: NOT
5203: IFFALSE 5207
// exit ;
5205: GO 5330
// for i = 1 to amount do
5207: LD_ADDR_VAR 0 5
5211: PUSH
5212: DOUBLE
5213: LD_INT 1
5215: DEC
5216: ST_TO_ADDR
5217: LD_VAR 0 1
5221: PUSH
5222: FOR_TO
5223: IFFALSE 5318
// begin PrepareHuman ( false , 1 , skill ) ;
5225: LD_INT 0
5227: PPUSH
5228: LD_INT 1
5230: PPUSH
5231: LD_VAR 0 2
5235: PPUSH
5236: CALL_OW 380
// un := CreateHuman ;
5240: LD_ADDR_VAR 0 6
5244: PUSH
5245: CALL_OW 44
5249: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
5250: LD_ADDR_VAR 0 7
5254: PUSH
5255: LD_VAR 0 7
5259: PPUSH
5260: LD_INT 1
5262: PPUSH
5263: LD_VAR 0 6
5267: PPUSH
5268: CALL_OW 2
5272: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5273: LD_VAR 0 6
5277: PPUSH
5278: LD_VAR 0 3
5282: PPUSH
5283: LD_INT 0
5285: PPUSH
5286: CALL_OW 49
// if i mod 2 = 0 then
5290: LD_VAR 0 5
5294: PUSH
5295: LD_INT 2
5297: MOD
5298: PUSH
5299: LD_INT 0
5301: EQUAL
5302: IFFALSE 5316
// SetTag ( un , 11 ) ;
5304: LD_VAR 0 6
5308: PPUSH
5309: LD_INT 11
5311: PPUSH
5312: CALL_OW 109
// end ;
5316: GO 5222
5318: POP
5319: POP
// result := tmp ;
5320: LD_ADDR_VAR 0 4
5324: PUSH
5325: LD_VAR 0 7
5329: ST_TO_ADDR
// end ;
5330: LD_VAR 0 4
5334: RET
// export ar_forces , ap_killers ; every 0 0$1 trigger Delta do var i , timer , more_troops , skill , eng , un , veh , force ;
5335: LD_EXP 6
5339: IFFALSE 6199
5341: GO 5343
5343: DISABLE
5344: LD_INT 0
5346: PPUSH
5347: PPUSH
5348: PPUSH
5349: PPUSH
5350: PPUSH
5351: PPUSH
5352: PPUSH
5353: PPUSH
// begin more_troops := false ;
5354: LD_ADDR_VAR 0 3
5358: PUSH
5359: LD_INT 0
5361: ST_TO_ADDR
// skill := [ 3 , 4 , 5 ] [ Difficulty ] ;
5362: LD_ADDR_VAR 0 4
5366: PUSH
5367: LD_INT 3
5369: PUSH
5370: LD_INT 4
5372: PUSH
5373: LD_INT 5
5375: PUSH
5376: EMPTY
5377: LIST
5378: LIST
5379: LIST
5380: PUSH
5381: LD_OWVAR 67
5385: ARRAY
5386: ST_TO_ADDR
// timer := [ 5 5$00 , 4 4$00 , 3 3$00 ] [ Difficulty ] ;
5387: LD_ADDR_VAR 0 2
5391: PUSH
5392: LD_INT 10500
5394: PUSH
5395: LD_INT 8400
5397: PUSH
5398: LD_INT 6300
5400: PUSH
5401: EMPTY
5402: LIST
5403: LIST
5404: LIST
5405: PUSH
5406: LD_OWVAR 67
5410: ARRAY
5411: ST_TO_ADDR
// force := [ ] ;
5412: LD_ADDR_VAR 0 8
5416: PUSH
5417: EMPTY
5418: ST_TO_ADDR
// ar_forces := [ ] ;
5419: LD_ADDR_EXP 26
5423: PUSH
5424: EMPTY
5425: ST_TO_ADDR
// ap_killers := [ ] ;
5426: LD_ADDR_EXP 27
5430: PUSH
5431: EMPTY
5432: ST_TO_ADDR
// Wait ( timer ) ;
5433: LD_VAR 0 2
5437: PPUSH
5438: CALL_OW 67
// if Denis and GetSide ( Denis ) = 4 then
5442: LD_EXP 18
5446: PUSH
5447: LD_EXP 18
5451: PPUSH
5452: CALL_OW 255
5456: PUSH
5457: LD_INT 4
5459: EQUAL
5460: AND
5461: IFFALSE 5470
// Wait ( 0 0$45 ) ;
5463: LD_INT 1575
5465: PPUSH
5466: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) then
5470: LD_INT 22
5472: PUSH
5473: LD_INT 1
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 30
5482: PUSH
5483: LD_INT 4
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: PPUSH
5494: CALL_OW 69
5498: IFFALSE 5515
// begin Wait ( 1 1$25 ) ;
5500: LD_INT 2975
5502: PPUSH
5503: CALL_OW 67
// more_troops := true ;
5507: LD_ADDR_VAR 0 3
5511: PUSH
5512: LD_INT 1
5514: ST_TO_ADDR
// end ; if more_troops then
5515: LD_VAR 0 3
5519: IFFALSE 5707
// begin force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , arArea2 ) ;
5521: LD_ADDR_VAR 0 8
5525: PUSH
5526: LD_INT 4
5528: PUSH
5529: LD_INT 5
5531: PUSH
5532: LD_INT 6
5534: PUSH
5535: EMPTY
5536: LIST
5537: LIST
5538: LIST
5539: PUSH
5540: LD_OWVAR 67
5544: ARRAY
5545: PPUSH
5546: LD_VAR 0 4
5550: PPUSH
5551: LD_INT 14
5553: PPUSH
5554: CALL 5168 0 3
5558: ST_TO_ADDR
// veh := PrepareTank ( 2 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ Difficulty ] , 90 ) ;
5559: LD_ADDR_VAR 0 7
5563: PUSH
5564: LD_INT 2
5566: PPUSH
5567: LD_INT 3
5569: PPUSH
5570: LD_INT 22
5572: PPUSH
5573: LD_INT 1
5575: PPUSH
5576: LD_INT 1
5578: PPUSH
5579: LD_INT 42
5581: PUSH
5582: LD_INT 42
5584: PUSH
5585: LD_INT 43
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: LIST
5592: PUSH
5593: LD_OWVAR 67
5597: ARRAY
5598: PPUSH
5599: LD_INT 90
5601: PPUSH
5602: CALL 359 0 7
5606: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5607: LD_VAR 0 7
5611: PPUSH
5612: LD_INT 4
5614: PPUSH
5615: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
5619: LD_VAR 0 7
5623: PPUSH
5624: LD_INT 13
5626: PPUSH
5627: LD_INT 0
5629: PPUSH
5630: CALL_OW 49
// uc_side := 2 ;
5634: LD_ADDR_OWVAR 20
5638: PUSH
5639: LD_INT 2
5641: ST_TO_ADDR
// uc_nation := 2 ;
5642: LD_ADDR_OWVAR 21
5646: PUSH
5647: LD_INT 2
5649: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5650: LD_INT 0
5652: PPUSH
5653: LD_INT 1
5655: PPUSH
5656: LD_VAR 0 4
5660: PPUSH
5661: CALL_OW 380
// un := CreateHuman ;
5665: LD_ADDR_VAR 0 6
5669: PUSH
5670: CALL_OW 44
5674: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
5675: LD_VAR 0 6
5679: PPUSH
5680: LD_VAR 0 7
5684: PPUSH
5685: CALL_OW 52
// force := force ^ un ;
5689: LD_ADDR_VAR 0 8
5693: PUSH
5694: LD_VAR 0 8
5698: PUSH
5699: LD_VAR 0 6
5703: ADD
5704: ST_TO_ADDR
// end else
5705: GO 5745
// begin force := PrepareArabianTroops ( [ 3 , 4 , 5 ] [ Difficulty ] , skill , arArea2 ) ;
5707: LD_ADDR_VAR 0 8
5711: PUSH
5712: LD_INT 3
5714: PUSH
5715: LD_INT 4
5717: PUSH
5718: LD_INT 5
5720: PUSH
5721: EMPTY
5722: LIST
5723: LIST
5724: LIST
5725: PUSH
5726: LD_OWVAR 67
5730: ARRAY
5731: PPUSH
5732: LD_VAR 0 4
5736: PPUSH
5737: LD_INT 14
5739: PPUSH
5740: CALL 5168 0 3
5744: ST_TO_ADDR
// end ; if force then
5745: LD_VAR 0 8
5749: IFFALSE 5761
// ar_forces := force ;
5751: LD_ADDR_EXP 26
5755: PUSH
5756: LD_VAR 0 8
5760: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5761: LD_INT 35
5763: PPUSH
5764: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
5768: LD_INT 22
5770: PUSH
5771: LD_INT 2
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: PUSH
5778: LD_INT 21
5780: PUSH
5781: LD_INT 1
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: PPUSH
5792: CALL_OW 69
5796: PUSH
5797: LD_INT 0
5799: EQUAL
5800: IFFALSE 5761
// Wait ( timer ) ;
5802: LD_VAR 0 2
5806: PPUSH
5807: CALL_OW 67
// force := PrepareArabianTroops ( [ 5 , 6 , 6 ] [ Difficulty ] , skill , [ arArea1 , arArea2 ] [ rand ( 1 , 2 ) ] ) ;
5811: LD_ADDR_VAR 0 8
5815: PUSH
5816: LD_INT 5
5818: PUSH
5819: LD_INT 6
5821: PUSH
5822: LD_INT 6
5824: PUSH
5825: EMPTY
5826: LIST
5827: LIST
5828: LIST
5829: PUSH
5830: LD_OWVAR 67
5834: ARRAY
5835: PPUSH
5836: LD_VAR 0 4
5840: PPUSH
5841: LD_INT 13
5843: PUSH
5844: LD_INT 14
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: PUSH
5851: LD_INT 1
5853: PPUSH
5854: LD_INT 2
5856: PPUSH
5857: CALL_OW 12
5861: ARRAY
5862: PPUSH
5863: CALL 5168 0 3
5867: ST_TO_ADDR
// if Difficulty > 1 and Delta then
5868: LD_OWVAR 67
5872: PUSH
5873: LD_INT 1
5875: GREATER
5876: PUSH
5877: LD_EXP 6
5881: AND
5882: IFFALSE 5961
// begin uc_side := 2 ;
5884: LD_ADDR_OWVAR 20
5888: PUSH
5889: LD_INT 2
5891: ST_TO_ADDR
// uc_nation := 2 ;
5892: LD_ADDR_OWVAR 21
5896: PUSH
5897: LD_INT 2
5899: ST_TO_ADDR
// PrepareHuman ( false , 2 , skill ) ;
5900: LD_INT 0
5902: PPUSH
5903: LD_INT 2
5905: PPUSH
5906: LD_VAR 0 4
5910: PPUSH
5911: CALL_OW 380
// eng := CreateHuman ;
5915: LD_ADDR_VAR 0 5
5919: PUSH
5920: CALL_OW 44
5924: ST_TO_ADDR
// PlaceUnitArea ( eng , arArea1 , false ) ;
5925: LD_VAR 0 5
5929: PPUSH
5930: LD_INT 13
5932: PPUSH
5933: LD_INT 0
5935: PPUSH
5936: CALL_OW 49
// Wait ( 3 ) ;
5940: LD_INT 3
5942: PPUSH
5943: CALL_OW 67
// AddComEnterUnit ( eng , Delta ) ;
5947: LD_VAR 0 5
5951: PPUSH
5952: LD_EXP 6
5956: PPUSH
5957: CALL_OW 180
// end ; if force then
5961: LD_VAR 0 8
5965: IFFALSE 5977
// ar_forces := force ;
5967: LD_ADDR_EXP 26
5971: PUSH
5972: LD_VAR 0 8
5976: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5977: LD_INT 35
5979: PPUSH
5980: CALL_OW 67
// if eng then
5984: LD_VAR 0 5
5988: IFFALSE 6042
// if GetSide ( Delta ) = 2 and IsOk ( eng ) and not IsInUnit ( eng ) then
5990: LD_EXP 6
5994: PPUSH
5995: CALL_OW 255
5999: PUSH
6000: LD_INT 2
6002: EQUAL
6003: PUSH
6004: LD_VAR 0 5
6008: PPUSH
6009: CALL_OW 302
6013: AND
6014: PUSH
6015: LD_VAR 0 5
6019: PPUSH
6020: CALL_OW 310
6024: NOT
6025: AND
6026: IFFALSE 6042
// ComEnterUnit ( eng , Delta ) ;
6028: LD_VAR 0 5
6032: PPUSH
6033: LD_EXP 6
6037: PPUSH
6038: CALL_OW 120
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6042: LD_INT 22
6044: PUSH
6045: LD_INT 2
6047: PUSH
6048: EMPTY
6049: LIST
6050: LIST
6051: PUSH
6052: LD_INT 21
6054: PUSH
6055: LD_INT 1
6057: PUSH
6058: EMPTY
6059: LIST
6060: LIST
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: PPUSH
6066: CALL_OW 69
6070: PUSH
6071: LD_INT 0
6073: EQUAL
6074: IFFALSE 5977
// ap_killers := PrepareArabianTroops ( [ 1 , 2 , 2 ] [ Difficulty ] , skill , arArea1 ) ;
6076: LD_ADDR_EXP 27
6080: PUSH
6081: LD_INT 1
6083: PUSH
6084: LD_INT 2
6086: PUSH
6087: LD_INT 2
6089: PUSH
6090: EMPTY
6091: LIST
6092: LIST
6093: LIST
6094: PUSH
6095: LD_OWVAR 67
6099: ARRAY
6100: PPUSH
6101: LD_VAR 0 4
6105: PPUSH
6106: LD_INT 13
6108: PPUSH
6109: CALL 5168 0 3
6113: ST_TO_ADDR
// Wait ( timer * 2 ) ;
6114: LD_VAR 0 2
6118: PUSH
6119: LD_INT 2
6121: MUL
6122: PPUSH
6123: CALL_OW 67
// ar_forces := PrepareArabianTroops ( [ 5 , 6 , 7 ] [ Difficulty ] , skill , arArea1 ) ^ PrepareArabianTroops ( [ 3 , 4 , 4 ] [ Difficulty ] , skill , arArea2 ) ;
6127: LD_ADDR_EXP 26
6131: PUSH
6132: LD_INT 5
6134: PUSH
6135: LD_INT 6
6137: PUSH
6138: LD_INT 7
6140: PUSH
6141: EMPTY
6142: LIST
6143: LIST
6144: LIST
6145: PUSH
6146: LD_OWVAR 67
6150: ARRAY
6151: PPUSH
6152: LD_VAR 0 4
6156: PPUSH
6157: LD_INT 13
6159: PPUSH
6160: CALL 5168 0 3
6164: PUSH
6165: LD_INT 3
6167: PUSH
6168: LD_INT 4
6170: PUSH
6171: LD_INT 4
6173: PUSH
6174: EMPTY
6175: LIST
6176: LIST
6177: LIST
6178: PUSH
6179: LD_OWVAR 67
6183: ARRAY
6184: PPUSH
6185: LD_VAR 0 4
6189: PPUSH
6190: LD_INT 14
6192: PPUSH
6193: CALL 5168 0 3
6197: ADD
6198: ST_TO_ADDR
// end ;
6199: PPOPN 8
6201: END
// every 0 0$03 trigger ar_forces do var i , target ;
6202: LD_EXP 26
6206: IFFALSE 6345
6208: GO 6210
6210: DISABLE
6211: LD_INT 0
6213: PPUSH
6214: PPUSH
// begin enable ;
6215: ENABLE
// if not ar_forces then
6216: LD_EXP 26
6220: NOT
6221: IFFALSE 6225
// exit ;
6223: GO 6345
// if Delta then
6225: LD_EXP 6
6229: IFFALSE 6243
// target := Delta else
6231: LD_ADDR_VAR 0 2
6235: PUSH
6236: LD_EXP 6
6240: ST_TO_ADDR
6241: GO 6253
// target := JMM ;
6243: LD_ADDR_VAR 0 2
6247: PUSH
6248: LD_EXP 15
6252: ST_TO_ADDR
// for i in ar_forces do
6253: LD_ADDR_VAR 0 1
6257: PUSH
6258: LD_EXP 26
6262: PUSH
6263: FOR_IN
6264: IFFALSE 6343
// begin if GetDistUnits ( i , target ) > 30 then
6266: LD_VAR 0 1
6270: PPUSH
6271: LD_VAR 0 2
6275: PPUSH
6276: CALL_OW 296
6280: PUSH
6281: LD_INT 30
6283: GREATER
6284: IFFALSE 6317
// ComAgressiveMove ( i , GetX ( target ) , GetY ( target ) ) else
6286: LD_VAR 0 1
6290: PPUSH
6291: LD_VAR 0 2
6295: PPUSH
6296: CALL_OW 250
6300: PPUSH
6301: LD_VAR 0 2
6305: PPUSH
6306: CALL_OW 251
6310: PPUSH
6311: CALL_OW 114
6315: GO 6341
// Attack ( i , FilterAllUnits ( [ f_enemy , 2 ] ) ) ;
6317: LD_VAR 0 1
6321: PPUSH
6322: LD_INT 81
6324: PUSH
6325: LD_INT 2
6327: PUSH
6328: EMPTY
6329: LIST
6330: LIST
6331: PPUSH
6332: CALL_OW 69
6336: PPUSH
6337: CALL 612 0 2
// end ;
6341: GO 6263
6343: POP
6344: POP
// end ;
6345: PPOPN 2
6347: END
// every 0 0$01 trigger ap_killers do var filter , i , target ;
6348: LD_EXP 27
6352: IFFALSE 6512
6354: GO 6356
6356: DISABLE
6357: LD_INT 0
6359: PPUSH
6360: PPUSH
6361: PPUSH
// begin enable ;
6362: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6363: LD_ADDR_VAR 0 1
6367: PUSH
6368: LD_INT 22
6370: PUSH
6371: LD_INT 0
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: PUSH
6378: LD_INT 25
6380: PUSH
6381: LD_INT 12
6383: PUSH
6384: EMPTY
6385: LIST
6386: LIST
6387: PUSH
6388: EMPTY
6389: LIST
6390: LIST
6391: PPUSH
6392: CALL_OW 69
6396: ST_TO_ADDR
// if not filter then
6397: LD_VAR 0 1
6401: NOT
6402: IFFALSE 6429
// begin ar_forces := ar_forces ^ ap_killers ;
6404: LD_ADDR_EXP 26
6408: PUSH
6409: LD_EXP 26
6413: PUSH
6414: LD_EXP 27
6418: ADD
6419: ST_TO_ADDR
// ap_killers := [ ] ;
6420: LD_ADDR_EXP 27
6424: PUSH
6425: EMPTY
6426: ST_TO_ADDR
// exit ;
6427: GO 6512
// end ; for i in ap_killers do
6429: LD_ADDR_VAR 0 2
6433: PUSH
6434: LD_EXP 27
6438: PUSH
6439: FOR_IN
6440: IFFALSE 6510
// begin if not IsOk ( i ) then
6442: LD_VAR 0 2
6446: PPUSH
6447: CALL_OW 302
6451: NOT
6452: IFFALSE 6456
// continue ;
6454: GO 6439
// if not HasTask ( i ) then
6456: LD_VAR 0 2
6460: PPUSH
6461: CALL_OW 314
6465: NOT
6466: IFFALSE 6488
// target := NearestUnitToUnit ( filter , i ) ;
6468: LD_ADDR_VAR 0 3
6472: PUSH
6473: LD_VAR 0 1
6477: PPUSH
6478: LD_VAR 0 2
6482: PPUSH
6483: CALL_OW 74
6487: ST_TO_ADDR
// if target then
6488: LD_VAR 0 3
6492: IFFALSE 6508
// ComAttackUnit ( i , target ) ;
6494: LD_VAR 0 2
6498: PPUSH
6499: LD_VAR 0 3
6503: PPUSH
6504: CALL_OW 115
// end ;
6508: GO 6439
6510: POP
6511: POP
// end ; end_of_file
6512: PPOPN 3
6514: END
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
6515: LD_EXP 6
6519: IFFALSE 6651
6521: GO 6523
6523: DISABLE
6524: LD_INT 0
6526: PPUSH
6527: PPUSH
6528: PPUSH
// begin counter := [ 500 , 400 , 300 ] [ Difficulty ] ;
6529: LD_ADDR_VAR 0 2
6533: PUSH
6534: LD_INT 500
6536: PUSH
6537: LD_INT 400
6539: PUSH
6540: LD_INT 300
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: LIST
6547: PUSH
6548: LD_OWVAR 67
6552: ARRAY
6553: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
6554: LD_INT 1
6556: PPUSH
6557: LD_INT 3
6559: PPUSH
6560: CALL_OW 12
6564: PPUSH
6565: LD_INT 7
6567: PPUSH
6568: LD_INT 1
6570: PPUSH
6571: CALL_OW 55
// repeat wait ( rand ( 1 1$30 , 2 2$20 ) ) ;
6575: LD_INT 3150
6577: PPUSH
6578: LD_INT 4900
6580: PPUSH
6581: CALL_OW 12
6585: PPUSH
6586: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
6590: LD_ADDR_VAR 0 3
6594: PUSH
6595: LD_INT 1
6597: PPUSH
6598: LD_INT 5
6600: PPUSH
6601: CALL_OW 12
6605: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
6606: LD_VAR 0 3
6610: PPUSH
6611: LD_INT 7
6613: PPUSH
6614: LD_INT 1
6616: PPUSH
6617: CALL_OW 55
// counter := counter - cr * 10 ;
6621: LD_ADDR_VAR 0 2
6625: PUSH
6626: LD_VAR 0 2
6630: PUSH
6631: LD_VAR 0 3
6635: PUSH
6636: LD_INT 10
6638: MUL
6639: MINUS
6640: ST_TO_ADDR
// until counter <= 0 ;
6641: LD_VAR 0 2
6645: PUSH
6646: LD_INT 0
6648: LESSEQUAL
6649: IFFALSE 6575
// end ;
6651: PPOPN 3
6653: END
// every 0 0$03 trigger not Delta do var i ;
6654: LD_EXP 6
6658: NOT
6659: IFFALSE 6729
6661: GO 6663
6663: DISABLE
6664: LD_INT 0
6666: PPUSH
// begin for i = 1 to 4 - Difficulty do
6667: LD_ADDR_VAR 0 1
6671: PUSH
6672: DOUBLE
6673: LD_INT 1
6675: DEC
6676: ST_TO_ADDR
6677: LD_INT 4
6679: PUSH
6680: LD_OWVAR 67
6684: MINUS
6685: PUSH
6686: FOR_TO
6687: IFFALSE 6727
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
6689: LD_INT 2
6691: PPUSH
6692: LD_INT 5
6694: PPUSH
6695: CALL_OW 12
6699: PPUSH
6700: LD_INT 8
6702: PPUSH
6703: LD_INT 1
6705: PPUSH
6706: CALL_OW 55
// Wait ( rand ( 0 0$16 , 0 0$39 ) ) ;
6710: LD_INT 560
6712: PPUSH
6713: LD_INT 1365
6715: PPUSH
6716: CALL_OW 12
6720: PPUSH
6721: CALL_OW 67
// end ;
6725: GO 6686
6727: POP
6728: POP
// end ;
6729: PPOPN 1
6731: END
// every 2 2$00 trigger tick < 15 15$00 do
6732: LD_OWVAR 1
6736: PUSH
6737: LD_INT 31500
6739: LESS
6740: IFFALSE 6800
6742: GO 6744
6744: DISABLE
// begin enable ;
6745: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
6746: LD_INT 1
6748: PPUSH
6749: LD_INT 3
6751: PPUSH
6752: CALL_OW 12
6756: PPUSH
6757: LD_INT 1
6759: PPUSH
6760: CALL_OW 57
// Wait ( rand ( 0 0$38 , 0 0$59 ) ) ;
6764: LD_INT 1330
6766: PPUSH
6767: LD_INT 2065
6769: PPUSH
6770: CALL_OW 12
6774: PPUSH
6775: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 4 ) , riverArea , true ) ;
6779: LD_INT 1
6781: PPUSH
6782: LD_INT 4
6784: PPUSH
6785: CALL_OW 12
6789: PPUSH
6790: LD_INT 15
6792: PPUSH
6793: LD_INT 1
6795: PPUSH
6796: CALL_OW 55
// end ; end_of_file
6800: END
// on UnitDestroyed ( un ) do begin if un = JMM then
6801: LD_VAR 0 1
6805: PUSH
6806: LD_EXP 15
6810: EQUAL
6811: IFFALSE 6820
// YouLost ( JMM ) ;
6813: LD_STRING JMM
6815: PPUSH
6816: CALL_OW 104
// if un = Delta then
6820: LD_VAR 0 1
6824: PUSH
6825: LD_EXP 6
6829: EQUAL
6830: IFFALSE 6840
// Delta := 0 ;
6832: LD_ADDR_EXP 6
6836: PUSH
6837: LD_INT 0
6839: ST_TO_ADDR
// if un in ar_forces then
6840: LD_VAR 0 1
6844: PUSH
6845: LD_EXP 26
6849: IN
6850: IFFALSE 6868
// ar_forces := ar_forces diff un ;
6852: LD_ADDR_EXP 26
6856: PUSH
6857: LD_EXP 26
6861: PUSH
6862: LD_VAR 0 1
6866: DIFF
6867: ST_TO_ADDR
// if un in ap_killers then
6868: LD_VAR 0 1
6872: PUSH
6873: LD_EXP 27
6877: IN
6878: IFFALSE 6896
// ap_killers := ap_killers diff un ;
6880: LD_ADDR_EXP 27
6884: PUSH
6885: LD_EXP 27
6889: PUSH
6890: LD_VAR 0 1
6894: DIFF
6895: ST_TO_ADDR
// end ;
6896: PPOPN 1
6898: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
6899: LD_VAR 0 1
6903: PUSH
6904: LD_INT 1
6906: EQUAL
6907: PUSH
6908: LD_VAR 0 2
6912: PUSH
6913: LD_INT 2
6915: EQUAL
6916: AND
6917: PUSH
6918: LD_EXP 13
6922: NOT
6923: AND
6924: IFFALSE 6934
// arab_spotted := true ;
6926: LD_ADDR_EXP 13
6930: PUSH
6931: LD_INT 1
6933: ST_TO_ADDR
6934: PPOPN 2
6936: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
6937: LD_ADDR_OWVAR 57
6941: PUSH
6942: LD_INT 0
6944: ST_TO_ADDR
// end_mission := true ;
6945: LD_ADDR_EXP 14
6949: PUSH
6950: LD_INT 1
6952: ST_TO_ADDR
// end ;
6953: PPOPN 1
6955: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
6956: LD_VAR 0 2
6960: PPUSH
6961: CALL_OW 255
6965: PUSH
6966: LD_INT 1
6968: EQUAL
6969: IFFALSE 6985
// apeman_counter := apeman_counter + 1 ;
6971: LD_ADDR_EXP 12
6975: PUSH
6976: LD_EXP 12
6980: PUSH
6981: LD_INT 1
6983: PLUS
6984: ST_TO_ADDR
// if not first_apeman_tamed then
6985: LD_EXP 8
6989: NOT
6990: IFFALSE 7190
// begin first_apeman_tamed := true ;
6992: LD_ADDR_EXP 8
6996: PUSH
6997: LD_INT 1
6999: ST_TO_ADDR
// if sci = Gladstone then
7000: LD_VAR 0 2
7004: PUSH
7005: LD_EXP 16
7009: EQUAL
7010: IFFALSE 7024
// Say ( Gladstone , D7b-Glad-1 ) ;
7012: LD_EXP 16
7016: PPUSH
7017: LD_STRING D7b-Glad-1
7019: PPUSH
7020: CALL_OW 88
// if sci = Denis then
7024: LD_VAR 0 2
7028: PUSH
7029: LD_EXP 18
7033: EQUAL
7034: IFFALSE 7048
// Say ( Denis , D7a-Den-1 ) ;
7036: LD_EXP 18
7040: PPUSH
7041: LD_STRING D7a-Den-1
7043: PPUSH
7044: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
7048: LD_VAR 0 2
7052: PUSH
7053: LD_EXP 15
7057: PUSH
7058: LD_EXP 16
7062: PUSH
7063: LD_EXP 18
7067: PUSH
7068: LD_EXP 21
7072: PUSH
7073: LD_EXP 22
7077: PUSH
7078: LD_EXP 23
7082: PUSH
7083: LD_EXP 24
7087: PUSH
7088: LD_EXP 20
7092: PUSH
7093: EMPTY
7094: LIST
7095: LIST
7096: LIST
7097: LIST
7098: LIST
7099: LIST
7100: LIST
7101: LIST
7102: IN
7103: NOT
7104: IFFALSE 7147
// begin if GetSex ( sci ) = sex_male then
7106: LD_VAR 0 2
7110: PPUSH
7111: CALL_OW 258
7115: PUSH
7116: LD_INT 1
7118: EQUAL
7119: IFFALSE 7135
// Say ( sci , D7c-Sci1-1 ) else
7121: LD_VAR 0 2
7125: PPUSH
7126: LD_STRING D7c-Sci1-1
7128: PPUSH
7129: CALL_OW 88
7133: GO 7147
// Say ( sci , D7c-FSci1-1 ) ;
7135: LD_VAR 0 2
7139: PPUSH
7140: LD_STRING D7c-FSci1-1
7142: PPUSH
7143: CALL_OW 88
// end ; if not sci = Gladstone then
7147: LD_VAR 0 2
7151: PUSH
7152: LD_EXP 16
7156: EQUAL
7157: NOT
7158: IFFALSE 7172
// Say ( Gladstone , D7c-Glad-1 ) ;
7160: LD_EXP 16
7164: PPUSH
7165: LD_STRING D7c-Glad-1
7167: PPUSH
7168: CALL_OW 88
// if Lisa then
7172: LD_EXP 21
7176: IFFALSE 7190
// Say ( Lisa , D8-Lisa-1 ) ;
7178: LD_EXP 21
7182: PPUSH
7183: LD_STRING D8-Lisa-1
7185: PPUSH
7186: CALL_OW 88
// end ; end ;
7190: PPOPN 2
7192: END
