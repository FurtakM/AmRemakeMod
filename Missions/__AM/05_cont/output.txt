// export you , you2 , russians , arabians , neutral ; export apemans ; export oma ; export om ; export arabs_cars ; export JMM ; export Glad ; export Har ; export Den , Lisa , Frank ; export Don , Brown ; export Bobby , Cyrus ; export Denis ; export Sol1 , Sol2 , Sci ; export Car1 , Car2 , Car3 ; export CameFromXY ; export map_size_x , map_size_y ; export first_ape ; export was_first_attack ; export away_from_last_attack ; export first_attack ; export mine_attack ; export thief_attack ; export lonely_attack ; export next_attack ; export attacking ; export attacky ; export opic ; export cil_mit_1_ape_eng_splnen ; export cil_mit_5_ape_eng_splnen ; export zasilka_muze ; export zasilka_landed ; export denis_can_come ; export RadarBuild ; export tvoji_lidi ; export not_char ; export opicaci ; export ztraty ; export uz_je_cas ; export added_apes ; export max_added_apes ; export mat_crates ; export all , used , other ; export Gamma2Commander ; starting begin map_size_x := 100 ;
   0: LD_ADDR_EXP 28
   4: PUSH
   5: LD_INT 100
   7: ST_TO_ADDR
// map_size_y := 80 ;
   8: LD_ADDR_EXP 29
  12: PUSH
  13: LD_INT 80
  15: ST_TO_ADDR
// prepare_sides ;
  16: CALL 966 0 0
// prepare_yours_cars ;
  20: CALL 285 0 0
// load_units ;
  24: CALL 467 0 0
// SetDifficulty ;
  28: CALL 1034 0 0
// apemans := FilterAllUnits ( [ [ f_nation , nation_nature ] ] ) ;
  32: LD_ADDR_EXP 6
  36: PUSH
  37: LD_INT 23
  39: PUSH
  40: LD_INT 0
  42: PUSH
  43: EMPTY
  44: LIST
  45: LIST
  46: PUSH
  47: EMPTY
  48: LIST
  49: PPUSH
  50: CALL_OW 69
  54: ST_TO_ADDR
// was_first_attack := false ;
  55: LD_ADDR_EXP 31
  59: PUSH
  60: LD_INT 0
  62: ST_TO_ADDR
// first_attack := false ;
  63: LD_ADDR_EXP 33
  67: PUSH
  68: LD_INT 0
  70: ST_TO_ADDR
// mine_attack := false ;
  71: LD_ADDR_EXP 34
  75: PUSH
  76: LD_INT 0
  78: ST_TO_ADDR
// thief_attack := false ;
  79: LD_ADDR_EXP 35
  83: PUSH
  84: LD_INT 0
  86: ST_TO_ADDR
// lonely_attack := false ;
  87: LD_ADDR_EXP 36
  91: PUSH
  92: LD_INT 0
  94: ST_TO_ADDR
// next_attack := false ;
  95: LD_ADDR_EXP 37
  99: PUSH
 100: LD_INT 0
 102: ST_TO_ADDR
// attacking := false ;
 103: LD_ADDR_EXP 38
 107: PUSH
 108: LD_INT 0
 110: ST_TO_ADDR
// attacky := 0 ;
 111: LD_ADDR_EXP 39
 115: PUSH
 116: LD_INT 0
 118: ST_TO_ADDR
// CameFromXY := [ [ 110 , 31 ] , [ 106 , 23 ] , [ 123 , 74 ] , [ 120 , 74 ] , [ 74 , 6 ] , [ 83 , 75 ] , [ 39 , 4 ] ] ;
 119: LD_ADDR_EXP 27
 123: PUSH
 124: LD_INT 110
 126: PUSH
 127: LD_INT 31
 129: PUSH
 130: EMPTY
 131: LIST
 132: LIST
 133: PUSH
 134: LD_INT 106
 136: PUSH
 137: LD_INT 23
 139: PUSH
 140: EMPTY
 141: LIST
 142: LIST
 143: PUSH
 144: LD_INT 123
 146: PUSH
 147: LD_INT 74
 149: PUSH
 150: EMPTY
 151: LIST
 152: LIST
 153: PUSH
 154: LD_INT 120
 156: PUSH
 157: LD_INT 74
 159: PUSH
 160: EMPTY
 161: LIST
 162: LIST
 163: PUSH
 164: LD_INT 74
 166: PUSH
 167: LD_INT 6
 169: PUSH
 170: EMPTY
 171: LIST
 172: LIST
 173: PUSH
 174: LD_INT 83
 176: PUSH
 177: LD_INT 75
 179: PUSH
 180: EMPTY
 181: LIST
 182: LIST
 183: PUSH
 184: LD_INT 39
 186: PUSH
 187: LD_INT 4
 189: PUSH
 190: EMPTY
 191: LIST
 192: LIST
 193: PUSH
 194: EMPTY
 195: LIST
 196: LIST
 197: LIST
 198: LIST
 199: LIST
 200: LIST
 201: LIST
 202: ST_TO_ADDR
// opic := 0 ;
 203: LD_ADDR_EXP 40
 207: PUSH
 208: LD_INT 0
 210: ST_TO_ADDR
// zasilka_muze := false ;
 211: LD_ADDR_EXP 43
 215: PUSH
 216: LD_INT 0
 218: ST_TO_ADDR
// denis_can_come := false ;
 219: LD_ADDR_EXP 45
 223: PUSH
 224: LD_INT 0
 226: ST_TO_ADDR
// budovy := [ ] ;
 227: LD_ADDR_EXP 63
 231: PUSH
 232: EMPTY
 233: ST_TO_ADDR
// laboratore := [ ] ;
 234: LD_ADDR_EXP 62
 238: PUSH
 239: EMPTY
 240: ST_TO_ADDR
// tvoji_lidi := [ ] ;
 241: LD_ADDR_EXP 47
 245: PUSH
 246: EMPTY
 247: ST_TO_ADDR
// ztraty := 0 ;
 248: LD_ADDR_EXP 50
 252: PUSH
 253: LD_INT 0
 255: ST_TO_ADDR
// added_apes := 0 ;
 256: LD_ADDR_EXP 52
 260: PUSH
 261: LD_INT 0
 263: ST_TO_ADDR
// max_added_apes := 10 ;
 264: LD_ADDR_EXP 53
 268: PUSH
 269: LD_INT 10
 271: ST_TO_ADDR
// uz_je_cas := false ;
 272: LD_ADDR_EXP 51
 276: PUSH
 277: LD_INT 0
 279: ST_TO_ADDR
// Dialog1 ;
 280: CALL 3301 0 0
// end ;
 284: END
// function prepare_yours_cars ; begin
 285: LD_INT 0
 287: PPUSH
// InitUc ;
 288: CALL_OW 18
// InitHc ;
 292: CALL_OW 19
// InitVc ;
 296: CALL_OW 20
// uc_side := you ;
 300: LD_ADDR_OWVAR 20
 304: PUSH
 305: LD_EXP 1
 309: ST_TO_ADDR
// uc_nation := nation_american ;
 310: LD_ADDR_OWVAR 21
 314: PUSH
 315: LD_INT 1
 317: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
 318: LD_ADDR_OWVAR 37
 322: PUSH
 323: LD_INT 1
 325: ST_TO_ADDR
// vc_control := control_manual ;
 326: LD_ADDR_OWVAR 38
 330: PUSH
 331: LD_INT 1
 333: ST_TO_ADDR
// vc_engine := engine_solar ;
 334: LD_ADDR_OWVAR 39
 338: PUSH
 339: LD_INT 2
 341: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
 342: LD_ADDR_OWVAR 40
 346: PUSH
 347: LD_INT 2
 349: ST_TO_ADDR
// Car1 := CreateVehicle ;
 350: LD_ADDR_EXP 24
 354: PUSH
 355: CALL_OW 45
 359: ST_TO_ADDR
// vc_chassis := us_light_wheeled ;
 360: LD_ADDR_OWVAR 37
 364: PUSH
 365: LD_INT 1
 367: ST_TO_ADDR
// vc_control := control_manual ;
 368: LD_ADDR_OWVAR 38
 372: PUSH
 373: LD_INT 1
 375: ST_TO_ADDR
// vc_engine := engine_solar ;
 376: LD_ADDR_OWVAR 39
 380: PUSH
 381: LD_INT 2
 383: ST_TO_ADDR
// vc_weapon := us_machine_gun ;
 384: LD_ADDR_OWVAR 40
 388: PUSH
 389: LD_INT 2
 391: ST_TO_ADDR
// Car2 := CreateVehicle ;
 392: LD_ADDR_EXP 25
 396: PUSH
 397: CALL_OW 45
 401: ST_TO_ADDR
// vc_chassis := us_medium_wheeled ;
 402: LD_ADDR_OWVAR 37
 406: PUSH
 407: LD_INT 2
 409: ST_TO_ADDR
// vc_control := control_manual ;
 410: LD_ADDR_OWVAR 38
 414: PUSH
 415: LD_INT 1
 417: ST_TO_ADDR
// vc_engine := engine_solar ;
 418: LD_ADDR_OWVAR 39
 422: PUSH
 423: LD_INT 2
 425: ST_TO_ADDR
// vc_weapon := us_cargo_bay ;
 426: LD_ADDR_OWVAR 40
 430: PUSH
 431: LD_INT 12
 433: ST_TO_ADDR
// Car3 := CreateVehicle ;
 434: LD_ADDR_EXP 26
 438: PUSH
 439: CALL_OW 45
 443: ST_TO_ADDR
// SetCargo ( [ Car3 ] , mat_cans , 100 ) ;
 444: LD_EXP 26
 448: PUSH
 449: EMPTY
 450: LIST
 451: PPUSH
 452: LD_INT 1
 454: PPUSH
 455: LD_INT 100
 457: PPUSH
 458: CALL_OW 290
// end ;
 462: LD_VAR 0 1
 466: RET
// function load_units ; begin
 467: LD_INT 0
 469: PPUSH
// InitUc ;
 470: CALL_OW 18
// InitHc ;
 474: CALL_OW 19
// InitVc ;
 478: CALL_OW 20
// uc_side := you ;
 482: LD_ADDR_OWVAR 20
 486: PUSH
 487: LD_EXP 1
 491: ST_TO_ADDR
// uc_nation := nation_american ;
 492: LD_ADDR_OWVAR 21
 496: PUSH
 497: LD_INT 1
 499: ST_TO_ADDR
// JMM := CreateCharacter ( JMM ) ;
 500: LD_ADDR_EXP 10
 504: PUSH
 505: LD_STRING JMM
 507: PPUSH
 508: CALL_OW 34
 512: ST_TO_ADDR
// Glad := CreateCharacter ( Gladstone ) ;
 513: LD_ADDR_EXP 11
 517: PUSH
 518: LD_STRING Gladstone
 520: PPUSH
 521: CALL_OW 34
 525: ST_TO_ADDR
// Har := NewCharacter ( Harisson ) ;
 526: LD_ADDR_EXP 12
 530: PUSH
 531: LD_STRING Harisson
 533: PPUSH
 534: CALL_OW 25
 538: ST_TO_ADDR
// Denis := NewCharacter ( Denis ) ;
 539: LD_ADDR_EXP 20
 543: PUSH
 544: LD_STRING Denis
 546: PPUSH
 547: CALL_OW 25
 551: ST_TO_ADDR
// if TestCharacters ( otherDelta ) then
 552: LD_STRING otherDelta
 554: PPUSH
 555: CALL_OW 28
 559: IFFALSE 576
// used := CreateCharacterSet ( otherDelta ) else
 561: LD_ADDR_EXP 56
 565: PUSH
 566: LD_STRING otherDelta
 568: PPUSH
 569: CALL_OW 31
 573: ST_TO_ADDR
 574: GO 583
// used := [ ] ;
 576: LD_ADDR_EXP 56
 580: PUSH
 581: EMPTY
 582: ST_TO_ADDR
// Lisa := 0 ;
 583: LD_ADDR_EXP 14
 587: PUSH
 588: LD_INT 0
 590: ST_TO_ADDR
// if CheckCharacterSet ( Lisa ) then
 591: LD_STRING Lisa
 593: PPUSH
 594: CALL_OW 29
 598: IFFALSE 629
// if LoadVariable ( LisaLoc , 0 ) = 3 then
 600: LD_STRING LisaLoc
 602: PPUSH
 603: LD_INT 0
 605: PPUSH
 606: CALL_OW 30
 610: PUSH
 611: LD_INT 3
 613: EQUAL
 614: IFFALSE 629
// Lisa := CreateCharacter ( Lisa ) ;
 616: LD_ADDR_EXP 14
 620: PUSH
 621: LD_STRING Lisa
 623: PPUSH
 624: CALL_OW 34
 628: ST_TO_ADDR
// Cyrus := 0 ;
 629: LD_ADDR_EXP 19
 633: PUSH
 634: LD_INT 0
 636: ST_TO_ADDR
// if CheckCharacterSet ( Cyrus ) then
 637: LD_STRING Cyrus
 639: PPUSH
 640: CALL_OW 29
 644: IFFALSE 675
// if LoadVariable ( CyrusLoc , 0 ) = 3 then
 646: LD_STRING CyrusLoc
 648: PPUSH
 649: LD_INT 0
 651: PPUSH
 652: CALL_OW 30
 656: PUSH
 657: LD_INT 3
 659: EQUAL
 660: IFFALSE 675
// Cyrus := CreateCharacter ( Cyrus ) ;
 662: LD_ADDR_EXP 19
 666: PUSH
 667: LD_STRING Cyrus
 669: PPUSH
 670: CALL_OW 34
 674: ST_TO_ADDR
// Bobby := 0 ;
 675: LD_ADDR_EXP 18
 679: PUSH
 680: LD_INT 0
 682: ST_TO_ADDR
// if CheckCharacterSet ( Bobby ) then
 683: LD_STRING Bobby
 685: PPUSH
 686: CALL_OW 29
 690: IFFALSE 721
// if LoadVariable ( BobbyLoc , 0 ) = 3 then
 692: LD_STRING BobbyLoc
 694: PPUSH
 695: LD_INT 0
 697: PPUSH
 698: CALL_OW 30
 702: PUSH
 703: LD_INT 3
 705: EQUAL
 706: IFFALSE 721
// Bobby := CreateCharacter ( Bobby ) ;
 708: LD_ADDR_EXP 18
 712: PUSH
 713: LD_STRING Bobby
 715: PPUSH
 716: CALL_OW 34
 720: ST_TO_ADDR
// Frank := 0 ;
 721: LD_ADDR_EXP 15
 725: PUSH
 726: LD_INT 0
 728: ST_TO_ADDR
// if CheckCharacterSet ( Frank ) then
 729: LD_STRING Frank
 731: PPUSH
 732: CALL_OW 29
 736: IFFALSE 767
// if LoadVariable ( FrankLoc , 0 ) = 3 then
 738: LD_STRING FrankLoc
 740: PPUSH
 741: LD_INT 0
 743: PPUSH
 744: CALL_OW 30
 748: PUSH
 749: LD_INT 3
 751: EQUAL
 752: IFFALSE 767
// Frank := CreateCharacter ( Frank ) ;
 754: LD_ADDR_EXP 15
 758: PUSH
 759: LD_STRING Frank
 761: PPUSH
 762: CALL_OW 34
 766: ST_TO_ADDR
// Don := 0 ;
 767: LD_ADDR_EXP 16
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// if CheckCharacterSet ( Donaldson ) then
 775: LD_STRING Donaldson
 777: PPUSH
 778: CALL_OW 29
 782: IFFALSE 813
// if LoadVariable ( DonaldsonLoc , 0 ) = 3 then
 784: LD_STRING DonaldsonLoc
 786: PPUSH
 787: LD_INT 0
 789: PPUSH
 790: CALL_OW 30
 794: PUSH
 795: LD_INT 3
 797: EQUAL
 798: IFFALSE 813
// Don := CreateCharacter ( Donaldson ) ;
 800: LD_ADDR_EXP 16
 804: PUSH
 805: LD_STRING Donaldson
 807: PPUSH
 808: CALL_OW 34
 812: ST_TO_ADDR
// Brown := 0 ;
 813: LD_ADDR_EXP 17
 817: PUSH
 818: LD_INT 0
 820: ST_TO_ADDR
// if CheckCharacterSet ( Brown ) then
 821: LD_STRING Brown
 823: PPUSH
 824: CALL_OW 29
 828: IFFALSE 859
// if LoadVariable ( BrownLoc , 0 ) = 3 then
 830: LD_STRING BrownLoc
 832: PPUSH
 833: LD_INT 0
 835: PPUSH
 836: CALL_OW 30
 840: PUSH
 841: LD_INT 3
 843: EQUAL
 844: IFFALSE 859
// Brown := CreateCharacter ( Brown ) ;
 846: LD_ADDR_EXP 17
 850: PUSH
 851: LD_STRING Brown
 853: PPUSH
 854: CALL_OW 34
 858: ST_TO_ADDR
// used := ( [ JMM , Glad , Lisa , Cyrus , Bobby , Frank , Don , Brown ] diff [ 0 ] ) ^ used ;
 859: LD_ADDR_EXP 56
 863: PUSH
 864: LD_EXP 10
 868: PUSH
 869: LD_EXP 11
 873: PUSH
 874: LD_EXP 14
 878: PUSH
 879: LD_EXP 19
 883: PUSH
 884: LD_EXP 18
 888: PUSH
 889: LD_EXP 15
 893: PUSH
 894: LD_EXP 16
 898: PUSH
 899: LD_EXP 17
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: PUSH
 914: LD_INT 0
 916: PUSH
 917: EMPTY
 918: LIST
 919: DIFF
 920: PUSH
 921: LD_EXP 56
 925: ADD
 926: ST_TO_ADDR
// if not UnitFilter ( used , [ f_class , class_engineer ] ) then
 927: LD_EXP 56
 931: PPUSH
 932: LD_INT 25
 934: PUSH
 935: LD_INT 2
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: PPUSH
 942: CALL_OW 72
 946: NOT
 947: IFFALSE 961
// SetClass ( JMM , class_engineer ) ;
 949: LD_EXP 10
 953: PPUSH
 954: LD_INT 2
 956: PPUSH
 957: CALL_OW 336
// end ;
 961: LD_VAR 0 1
 965: RET
// function prepare_sides ; begin
 966: LD_INT 0
 968: PPUSH
// you := 1 ;
 969: LD_ADDR_EXP 1
 973: PUSH
 974: LD_INT 1
 976: ST_TO_ADDR
// you2 := 4 ;
 977: LD_ADDR_EXP 2
 981: PUSH
 982: LD_INT 4
 984: ST_TO_ADDR
// arabians := 2 ;
 985: LD_ADDR_EXP 4
 989: PUSH
 990: LD_INT 2
 992: ST_TO_ADDR
// russians := 3 ;
 993: LD_ADDR_EXP 3
 997: PUSH
 998: LD_INT 3
1000: ST_TO_ADDR
// neutral := 0 ;
1001: LD_ADDR_EXP 5
1005: PUSH
1006: LD_INT 0
1008: ST_TO_ADDR
// SetAttitude ( arabians , you , att_enemy , true ) ;
1009: LD_EXP 4
1013: PPUSH
1014: LD_EXP 1
1018: PPUSH
1019: LD_INT 2
1021: PPUSH
1022: LD_INT 1
1024: PPUSH
1025: CALL_OW 80
// end ;
1029: LD_VAR 0 1
1033: RET
// export wait_first_attack ; export utoku ; function SetDifficulty ; begin
1034: LD_INT 0
1036: PPUSH
// wait_first_attack := [ 1 1$20 , 0 0$50 , 0 0$35 ] [ difficulty ] ;
1037: LD_ADDR_EXP 59
1041: PUSH
1042: LD_INT 2800
1044: PUSH
1045: LD_INT 1750
1047: PUSH
1048: LD_INT 1225
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: PUSH
1056: LD_OWVAR 67
1060: ARRAY
1061: ST_TO_ADDR
// utoku := [ 9 , 12 , 19 ] [ difficulty ] ;
1062: LD_ADDR_EXP 60
1066: PUSH
1067: LD_INT 9
1069: PUSH
1070: LD_INT 12
1072: PUSH
1073: LD_INT 19
1075: PUSH
1076: EMPTY
1077: LIST
1078: LIST
1079: LIST
1080: PUSH
1081: LD_OWVAR 67
1085: ARRAY
1086: ST_TO_ADDR
// end ;
1087: LD_VAR 0 1
1091: RET
// export function make_arabs ( pocet , unitclass ) ; var list , arab , d ; begin
1092: LD_INT 0
1094: PPUSH
1095: PPUSH
1096: PPUSH
1097: PPUSH
// InitUc ;
1098: CALL_OW 18
// InitHc ;
1102: CALL_OW 19
// uc_side := arabians ;
1106: LD_ADDR_OWVAR 20
1110: PUSH
1111: LD_EXP 4
1115: ST_TO_ADDR
// uc_nation := nation_arabian ;
1116: LD_ADDR_OWVAR 21
1120: PUSH
1121: LD_INT 2
1123: ST_TO_ADDR
// d := difficulty - 1 ;
1124: LD_ADDR_VAR 0 6
1128: PUSH
1129: LD_OWVAR 67
1133: PUSH
1134: LD_INT 1
1136: MINUS
1137: ST_TO_ADDR
// while pocet > 0 do
1138: LD_VAR 0 1
1142: PUSH
1143: LD_INT 0
1145: GREATER
1146: IFFALSE 1790
// begin hc_class := unitclass ;
1148: LD_ADDR_OWVAR 28
1152: PUSH
1153: LD_VAR 0 2
1157: ST_TO_ADDR
// if Rand ( 1 , 10 ) >= 4 then
1158: LD_INT 1
1160: PPUSH
1161: LD_INT 10
1163: PPUSH
1164: CALL_OW 12
1168: PUSH
1169: LD_INT 4
1171: GREATEREQUAL
1172: IFFALSE 1184
// hc_sex := sex_female else
1174: LD_ADDR_OWVAR 27
1178: PUSH
1179: LD_INT 2
1181: ST_TO_ADDR
1182: GO 1192
// hc_sex := sex_male ;
1184: LD_ADDR_OWVAR 27
1188: PUSH
1189: LD_INT 1
1191: ST_TO_ADDR
// case unitclass of class_soldier :
1192: LD_VAR 0 2
1196: PUSH
1197: LD_INT 1
1199: DOUBLE
1200: EQUAL
1201: IFTRUE 1205
1203: GO 1330
1205: POP
// begin hc_attr := [ Rand ( 8 , 10 ) + d , Rand ( 8 , 10 ) + d ] ;
1206: LD_ADDR_OWVAR 29
1210: PUSH
1211: LD_INT 8
1213: PPUSH
1214: LD_INT 10
1216: PPUSH
1217: CALL_OW 12
1221: PUSH
1222: LD_VAR 0 6
1226: PLUS
1227: PUSH
1228: LD_INT 8
1230: PPUSH
1231: LD_INT 10
1233: PPUSH
1234: CALL_OW 12
1238: PUSH
1239: LD_VAR 0 6
1243: PLUS
1244: PUSH
1245: EMPTY
1246: LIST
1247: LIST
1248: ST_TO_ADDR
// hc_skills := [ Rand ( 2 , 3 ) + d , Rand ( 0 , 1 ) + d , Rand ( 0 , 1 ) + d , Rand ( 0 , 0 ) + d ] ;
1249: LD_ADDR_OWVAR 31
1253: PUSH
1254: LD_INT 2
1256: PPUSH
1257: LD_INT 3
1259: PPUSH
1260: CALL_OW 12
1264: PUSH
1265: LD_VAR 0 6
1269: PLUS
1270: PUSH
1271: LD_INT 0
1273: PPUSH
1274: LD_INT 1
1276: PPUSH
1277: CALL_OW 12
1281: PUSH
1282: LD_VAR 0 6
1286: PLUS
1287: PUSH
1288: LD_INT 0
1290: PPUSH
1291: LD_INT 1
1293: PPUSH
1294: CALL_OW 12
1298: PUSH
1299: LD_VAR 0 6
1303: PLUS
1304: PUSH
1305: LD_INT 0
1307: PPUSH
1308: LD_INT 0
1310: PPUSH
1311: CALL_OW 12
1315: PUSH
1316: LD_VAR 0 6
1320: PLUS
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: LIST
1326: LIST
1327: ST_TO_ADDR
// end ; class_engineer :
1328: GO 1730
1330: LD_INT 2
1332: DOUBLE
1333: EQUAL
1334: IFTRUE 1338
1336: GO 1463
1338: POP
// begin hc_attr := [ Rand ( 8 , 9 ) + d , Rand ( 8 , 9 ) + d ] ;
1339: LD_ADDR_OWVAR 29
1343: PUSH
1344: LD_INT 8
1346: PPUSH
1347: LD_INT 9
1349: PPUSH
1350: CALL_OW 12
1354: PUSH
1355: LD_VAR 0 6
1359: PLUS
1360: PUSH
1361: LD_INT 8
1363: PPUSH
1364: LD_INT 9
1366: PPUSH
1367: CALL_OW 12
1371: PUSH
1372: LD_VAR 0 6
1376: PLUS
1377: PUSH
1378: EMPTY
1379: LIST
1380: LIST
1381: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 1 ) + d , Rand ( 2 , 3 ) + d , Rand ( 0 , 1 ) + d , Rand ( 0 , 0 ) + d ] ;
1382: LD_ADDR_OWVAR 31
1386: PUSH
1387: LD_INT 0
1389: PPUSH
1390: LD_INT 1
1392: PPUSH
1393: CALL_OW 12
1397: PUSH
1398: LD_VAR 0 6
1402: PLUS
1403: PUSH
1404: LD_INT 2
1406: PPUSH
1407: LD_INT 3
1409: PPUSH
1410: CALL_OW 12
1414: PUSH
1415: LD_VAR 0 6
1419: PLUS
1420: PUSH
1421: LD_INT 0
1423: PPUSH
1424: LD_INT 1
1426: PPUSH
1427: CALL_OW 12
1431: PUSH
1432: LD_VAR 0 6
1436: PLUS
1437: PUSH
1438: LD_INT 0
1440: PPUSH
1441: LD_INT 0
1443: PPUSH
1444: CALL_OW 12
1448: PUSH
1449: LD_VAR 0 6
1453: PLUS
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: ST_TO_ADDR
// end ; class_mechanic :
1461: GO 1730
1463: LD_INT 3
1465: DOUBLE
1466: EQUAL
1467: IFTRUE 1471
1469: GO 1596
1471: POP
// begin hc_attr := [ Rand ( 8 , 9 ) + d , Rand ( 8 , 9 ) + d ] ;
1472: LD_ADDR_OWVAR 29
1476: PUSH
1477: LD_INT 8
1479: PPUSH
1480: LD_INT 9
1482: PPUSH
1483: CALL_OW 12
1487: PUSH
1488: LD_VAR 0 6
1492: PLUS
1493: PUSH
1494: LD_INT 8
1496: PPUSH
1497: LD_INT 9
1499: PPUSH
1500: CALL_OW 12
1504: PUSH
1505: LD_VAR 0 6
1509: PLUS
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 0 ) + d , Rand ( 0 , 1 ) + d , Rand ( 2 , 3 ) + d , Rand ( 0 , 0 ) + d ] ;
1515: LD_ADDR_OWVAR 31
1519: PUSH
1520: LD_INT 0
1522: PPUSH
1523: LD_INT 0
1525: PPUSH
1526: CALL_OW 12
1530: PUSH
1531: LD_VAR 0 6
1535: PLUS
1536: PUSH
1537: LD_INT 0
1539: PPUSH
1540: LD_INT 1
1542: PPUSH
1543: CALL_OW 12
1547: PUSH
1548: LD_VAR 0 6
1552: PLUS
1553: PUSH
1554: LD_INT 2
1556: PPUSH
1557: LD_INT 3
1559: PPUSH
1560: CALL_OW 12
1564: PUSH
1565: LD_VAR 0 6
1569: PLUS
1570: PUSH
1571: LD_INT 0
1573: PPUSH
1574: LD_INT 0
1576: PPUSH
1577: CALL_OW 12
1581: PUSH
1582: LD_VAR 0 6
1586: PLUS
1587: PUSH
1588: EMPTY
1589: LIST
1590: LIST
1591: LIST
1592: LIST
1593: ST_TO_ADDR
// end ; class_scientistic :
1594: GO 1730
1596: LD_INT 4
1598: DOUBLE
1599: EQUAL
1600: IFTRUE 1604
1602: GO 1729
1604: POP
// begin hc_attr := [ Rand ( 8 , 8 ) + d , Rand ( 8 , 8 ) + d ] ;
1605: LD_ADDR_OWVAR 29
1609: PUSH
1610: LD_INT 8
1612: PPUSH
1613: LD_INT 8
1615: PPUSH
1616: CALL_OW 12
1620: PUSH
1621: LD_VAR 0 6
1625: PLUS
1626: PUSH
1627: LD_INT 8
1629: PPUSH
1630: LD_INT 8
1632: PPUSH
1633: CALL_OW 12
1637: PUSH
1638: LD_VAR 0 6
1642: PLUS
1643: PUSH
1644: EMPTY
1645: LIST
1646: LIST
1647: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 1 ) + d , Rand ( 0 , 1 ) + d , Rand ( 1 , 2 ) + d , Rand ( 2 , 3 ) + d ] ;
1648: LD_ADDR_OWVAR 31
1652: PUSH
1653: LD_INT 0
1655: PPUSH
1656: LD_INT 1
1658: PPUSH
1659: CALL_OW 12
1663: PUSH
1664: LD_VAR 0 6
1668: PLUS
1669: PUSH
1670: LD_INT 0
1672: PPUSH
1673: LD_INT 1
1675: PPUSH
1676: CALL_OW 12
1680: PUSH
1681: LD_VAR 0 6
1685: PLUS
1686: PUSH
1687: LD_INT 1
1689: PPUSH
1690: LD_INT 2
1692: PPUSH
1693: CALL_OW 12
1697: PUSH
1698: LD_VAR 0 6
1702: PLUS
1703: PUSH
1704: LD_INT 2
1706: PPUSH
1707: LD_INT 3
1709: PPUSH
1710: CALL_OW 12
1714: PUSH
1715: LD_VAR 0 6
1719: PLUS
1720: PUSH
1721: EMPTY
1722: LIST
1723: LIST
1724: LIST
1725: LIST
1726: ST_TO_ADDR
// end ; end ;
1727: GO 1730
1729: POP
// arab := CreateHuman ;
1730: LD_ADDR_VAR 0 5
1734: PUSH
1735: CALL_OW 44
1739: ST_TO_ADDR
// if list then
1740: LD_VAR 0 4
1744: IFFALSE 1764
// list := list ^ arab else
1746: LD_ADDR_VAR 0 4
1750: PUSH
1751: LD_VAR 0 4
1755: PUSH
1756: LD_VAR 0 5
1760: ADD
1761: ST_TO_ADDR
1762: GO 1774
// list := arab ;
1764: LD_ADDR_VAR 0 4
1768: PUSH
1769: LD_VAR 0 5
1773: ST_TO_ADDR
// pocet := pocet - 1 ;
1774: LD_ADDR_VAR 0 1
1778: PUSH
1779: LD_VAR 0 1
1783: PUSH
1784: LD_INT 1
1786: MINUS
1787: ST_TO_ADDR
// end ;
1788: GO 1138
// result := list ;
1790: LD_ADDR_VAR 0 3
1794: PUSH
1795: LD_VAR 0 4
1799: ST_TO_ADDR
// end ;
1800: LD_VAR 0 3
1804: RET
// every 0 0$2 trigger not cil_mit_1_ape_eng_splnen and UnitFilter ( apemans , [ f_side , neutral ] ) + ( max_added_apes - added_apes ) < ( 2 - opic ) do
1805: LD_EXP 41
1809: NOT
1810: PUSH
1811: LD_EXP 6
1815: PPUSH
1816: LD_INT 22
1818: PUSH
1819: LD_EXP 5
1823: PUSH
1824: EMPTY
1825: LIST
1826: LIST
1827: PPUSH
1828: CALL_OW 72
1832: PUSH
1833: LD_EXP 53
1837: PUSH
1838: LD_EXP 52
1842: MINUS
1843: PLUS
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: LD_EXP 40
1852: MINUS
1853: LESS
1854: AND
1855: IFFALSE 1870
1857: GO 1859
1859: DISABLE
// begin disable ( 0 ) ;
1860: LD_INT 0
1862: DISABLE_MARKED
// YouLost ( Apeman ) ;
1863: LD_STRING Apeman
1865: PPUSH
1866: CALL_OW 104
// end ;
1870: END
// every 0 0$2 trigger not GetTech ( tech_ApePsych , you ) = state_researched and not laboratore and KolikCrates < 20 and mat_crates = 3 do
1871: LD_INT 2
1873: PPUSH
1874: LD_EXP 1
1878: PPUSH
1879: CALL_OW 321
1883: PUSH
1884: LD_INT 2
1886: EQUAL
1887: NOT
1888: PUSH
1889: LD_EXP 62
1893: NOT
1894: AND
1895: PUSH
1896: CALL 3066 0 0
1900: PUSH
1901: LD_INT 20
1903: LESS
1904: AND
1905: PUSH
1906: LD_EXP 54
1910: PUSH
1911: LD_INT 3
1913: EQUAL
1914: AND
1915: IFFALSE 1930
1917: GO 1919
1919: DISABLE
// begin disable ( 0 ) ;
1920: LD_INT 0
1922: DISABLE_MARKED
// YouLost ( Resources ) ;
1923: LD_STRING Resources
1925: PPUSH
1926: CALL_OW 104
// end ;
1930: END
// every 0 0$10 trigger RadarBuild and cil_mit_5_ape_eng_splnen do
1931: LD_EXP 46
1935: PUSH
1936: LD_EXP 42
1940: AND
1941: IFFALSE 1957
1943: GO 1945
1945: DISABLE
// begin wait ( 0 0$8 ) ;
1946: LD_INT 280
1948: PPUSH
1949: CALL_OW 67
// Vyhra ;
1953: CALL 3191 0 0
// end ;
1957: END
// export function Save ; var Delta , tmp , t ; begin
1958: LD_INT 0
1960: PPUSH
1961: PPUSH
1962: PPUSH
1963: PPUSH
// SaveCharacters ( JMM , JMM ) ;
1964: LD_EXP 10
1968: PPUSH
1969: LD_STRING JMM
1971: PPUSH
1972: CALL_OW 38
// if Lisa then
1976: LD_EXP 14
1980: IFFALSE 2015
// begin SaveCharacters ( Lisa , Lisa ) ;
1982: LD_EXP 14
1986: PPUSH
1987: LD_STRING Lisa
1989: PPUSH
1990: CALL_OW 38
// if IsDead ( Lisa ) then
1994: LD_EXP 14
1998: PPUSH
1999: CALL_OW 301
2003: IFFALSE 2015
// SaveVariable ( 0 , LisaLoc ) ;
2005: LD_INT 0
2007: PPUSH
2008: LD_STRING LisaLoc
2010: PPUSH
2011: CALL_OW 39
// end ; if Frank then
2015: LD_EXP 15
2019: IFFALSE 2054
// begin SaveCharacters ( Frank , Frank ) ;
2021: LD_EXP 15
2025: PPUSH
2026: LD_STRING Frank
2028: PPUSH
2029: CALL_OW 38
// if IsDead ( Frank ) then
2033: LD_EXP 15
2037: PPUSH
2038: CALL_OW 301
2042: IFFALSE 2054
// SaveVariable ( 0 , FrankLoc ) ;
2044: LD_INT 0
2046: PPUSH
2047: LD_STRING FrankLoc
2049: PPUSH
2050: CALL_OW 39
// end ; if Don then
2054: LD_EXP 16
2058: IFFALSE 2093
// begin SaveCharacters ( Don , Donaldson ) ;
2060: LD_EXP 16
2064: PPUSH
2065: LD_STRING Donaldson
2067: PPUSH
2068: CALL_OW 38
// if IsDead ( Don ) then
2072: LD_EXP 16
2076: PPUSH
2077: CALL_OW 301
2081: IFFALSE 2093
// SaveVariable ( 0 , DonaldsonLoc ) ;
2083: LD_INT 0
2085: PPUSH
2086: LD_STRING DonaldsonLoc
2088: PPUSH
2089: CALL_OW 39
// end ; if Brown then
2093: LD_EXP 17
2097: IFFALSE 2132
// begin SaveCharacters ( Brown , Brown ) ;
2099: LD_EXP 17
2103: PPUSH
2104: LD_STRING Brown
2106: PPUSH
2107: CALL_OW 38
// if IsDead ( Brown ) then
2111: LD_EXP 17
2115: PPUSH
2116: CALL_OW 301
2120: IFFALSE 2132
// SaveVariable ( 0 , BrownLoc ) ;
2122: LD_INT 0
2124: PPUSH
2125: LD_STRING BrownLoc
2127: PPUSH
2128: CALL_OW 39
// end ; if Glad then
2132: LD_EXP 11
2136: IFFALSE 2183
// begin SaveCharacters ( Glad , Gladstone ) ;
2138: LD_EXP 11
2142: PPUSH
2143: LD_STRING Gladstone
2145: PPUSH
2146: CALL_OW 38
// if IsDead ( Glad ) then
2150: LD_EXP 11
2154: PPUSH
2155: CALL_OW 301
2159: IFFALSE 2173
// SaveVariable ( 0 , GladstoneLoc ) else
2161: LD_INT 0
2163: PPUSH
2164: LD_STRING GladstoneLoc
2166: PPUSH
2167: CALL_OW 39
2171: GO 2183
// SaveVariable ( 3 , GladstoneLoc ) ;
2173: LD_INT 3
2175: PPUSH
2176: LD_STRING GladstoneLoc
2178: PPUSH
2179: CALL_OW 39
// end ; if Denis then
2183: LD_EXP 20
2187: IFFALSE 2234
// begin SaveCharacters ( Den , Denis ) ;
2189: LD_EXP 13
2193: PPUSH
2194: LD_STRING Denis
2196: PPUSH
2197: CALL_OW 38
// if IsDead ( Den ) then
2201: LD_EXP 13
2205: PPUSH
2206: CALL_OW 301
2210: IFFALSE 2224
// SaveVariable ( 0 , DenisLoc ) else
2212: LD_INT 0
2214: PPUSH
2215: LD_STRING DenisLoc
2217: PPUSH
2218: CALL_OW 39
2222: GO 2234
// SaveVariable ( 3 , DenisLoc ) ;
2224: LD_INT 3
2226: PPUSH
2227: LD_STRING DenisLoc
2229: PPUSH
2230: CALL_OW 39
// end ; if Bobby then
2234: LD_EXP 18
2238: IFFALSE 2273
// begin SaveCharacters ( Bobby , Bobby ) ;
2240: LD_EXP 18
2244: PPUSH
2245: LD_STRING Bobby
2247: PPUSH
2248: CALL_OW 38
// if IsDead ( Bobby ) then
2252: LD_EXP 18
2256: PPUSH
2257: CALL_OW 301
2261: IFFALSE 2273
// SaveVariable ( 0 , BobbyLoc ) ;
2263: LD_INT 0
2265: PPUSH
2266: LD_STRING BobbyLoc
2268: PPUSH
2269: CALL_OW 39
// end ; if Cyrus then
2273: LD_EXP 19
2277: IFFALSE 2312
// begin SaveCharacters ( Cyrus , Cyrus ) ;
2279: LD_EXP 19
2283: PPUSH
2284: LD_STRING Cyrus
2286: PPUSH
2287: CALL_OW 38
// if IsDead ( Cyrus ) then
2291: LD_EXP 19
2295: PPUSH
2296: CALL_OW 301
2300: IFFALSE 2312
// SaveVariable ( 0 , CyrusLoc ) ;
2302: LD_INT 0
2304: PPUSH
2305: LD_STRING CyrusLoc
2307: PPUSH
2308: CALL_OW 39
// end ; SaveCharacters ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) diff [ JMM , Lisa , Frank , Don , Brown , Glad , Den , Bobby , Cyrus , 0 ] , otherDelta ) ;
2312: LD_INT 22
2314: PUSH
2315: LD_EXP 1
2319: PUSH
2320: EMPTY
2321: LIST
2322: LIST
2323: PUSH
2324: LD_INT 21
2326: PUSH
2327: LD_INT 1
2329: PUSH
2330: EMPTY
2331: LIST
2332: LIST
2333: PUSH
2334: LD_INT 23
2336: PUSH
2337: LD_INT 1
2339: PUSH
2340: EMPTY
2341: LIST
2342: LIST
2343: PUSH
2344: EMPTY
2345: LIST
2346: LIST
2347: LIST
2348: PPUSH
2349: CALL_OW 69
2353: PUSH
2354: LD_EXP 10
2358: PUSH
2359: LD_EXP 14
2363: PUSH
2364: LD_EXP 15
2368: PUSH
2369: LD_EXP 16
2373: PUSH
2374: LD_EXP 17
2378: PUSH
2379: LD_EXP 11
2383: PUSH
2384: LD_EXP 13
2388: PUSH
2389: LD_EXP 18
2393: PUSH
2394: LD_EXP 19
2398: PUSH
2399: LD_INT 0
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: LIST
2406: LIST
2407: LIST
2408: LIST
2409: LIST
2410: LIST
2411: LIST
2412: LIST
2413: DIFF
2414: PPUSH
2415: LD_STRING otherDelta
2417: PPUSH
2418: CALL_OW 38
// SaveCharacters ( FilterAllUnits ( [ [ f_side , you ] , [ f_nation , nation_nature ] ] ) , opicaci ) ;
2422: LD_INT 22
2424: PUSH
2425: LD_EXP 1
2429: PUSH
2430: EMPTY
2431: LIST
2432: LIST
2433: PUSH
2434: LD_INT 23
2436: PUSH
2437: LD_INT 0
2439: PUSH
2440: EMPTY
2441: LIST
2442: LIST
2443: PUSH
2444: EMPTY
2445: LIST
2446: LIST
2447: PPUSH
2448: CALL_OW 69
2452: PPUSH
2453: LD_STRING opicaci
2455: PPUSH
2456: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_building ] ] ) ;
2460: LD_ADDR_VAR 0 3
2464: PUSH
2465: LD_INT 22
2467: PUSH
2468: LD_EXP 1
2472: PUSH
2473: EMPTY
2474: LIST
2475: LIST
2476: PUSH
2477: LD_INT 21
2479: PUSH
2480: LD_INT 3
2482: PUSH
2483: EMPTY
2484: LIST
2485: LIST
2486: PUSH
2487: EMPTY
2488: LIST
2489: LIST
2490: PPUSH
2491: CALL_OW 69
2495: ST_TO_ADDR
// Delta := [ ] ;
2496: LD_ADDR_VAR 0 2
2500: PUSH
2501: EMPTY
2502: ST_TO_ADDR
// for t in tmp do
2503: LD_ADDR_VAR 0 4
2507: PUSH
2508: LD_VAR 0 3
2512: PUSH
2513: FOR_IN
2514: IFFALSE 2868
// begin case getbtype ( t ) of b_lab_basic , b_lab_weapon , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime :
2516: LD_VAR 0 4
2520: PPUSH
2521: CALL_OW 266
2525: PUSH
2526: LD_INT 9
2528: DOUBLE
2529: EQUAL
2530: IFTRUE 2570
2532: LD_INT 10
2534: DOUBLE
2535: EQUAL
2536: IFTRUE 2570
2538: LD_INT 13
2540: DOUBLE
2541: EQUAL
2542: IFTRUE 2570
2544: LD_INT 12
2546: DOUBLE
2547: EQUAL
2548: IFTRUE 2570
2550: LD_INT 15
2552: DOUBLE
2553: EQUAL
2554: IFTRUE 2570
2556: LD_INT 11
2558: DOUBLE
2559: EQUAL
2560: IFTRUE 2570
2562: LD_INT 14
2564: DOUBLE
2565: EQUAL
2566: IFTRUE 2570
2568: GO 2573
2570: POP
// begin end ; b_lab , b_lab_half , b_lab_full :
2571: GO 2866
2573: LD_INT 6
2575: DOUBLE
2576: EQUAL
2577: IFTRUE 2593
2579: LD_INT 7
2581: DOUBLE
2582: EQUAL
2583: IFTRUE 2593
2585: LD_INT 8
2587: DOUBLE
2588: EQUAL
2589: IFTRUE 2593
2591: GO 2695
2593: POP
// Delta := Delta ^ [ [ GetX ( t ) , GetY ( t ) , GetDir ( t ) , GetBType ( t ) , GetBLevel ( t ) , GetLabKind ( t , 1 ) , GetLabKind ( t , 2 ) ] ] ; b_bunker , b_turret :
2594: LD_ADDR_VAR 0 2
2598: PUSH
2599: LD_VAR 0 2
2603: PUSH
2604: LD_VAR 0 4
2608: PPUSH
2609: CALL_OW 250
2613: PUSH
2614: LD_VAR 0 4
2618: PPUSH
2619: CALL_OW 251
2623: PUSH
2624: LD_VAR 0 4
2628: PPUSH
2629: CALL_OW 254
2633: PUSH
2634: LD_VAR 0 4
2638: PPUSH
2639: CALL_OW 266
2643: PUSH
2644: LD_VAR 0 4
2648: PPUSH
2649: CALL_OW 267
2653: PUSH
2654: LD_VAR 0 4
2658: PPUSH
2659: LD_INT 1
2661: PPUSH
2662: CALL_OW 268
2666: PUSH
2667: LD_VAR 0 4
2671: PPUSH
2672: LD_INT 2
2674: PPUSH
2675: CALL_OW 268
2679: PUSH
2680: EMPTY
2681: LIST
2682: LIST
2683: LIST
2684: LIST
2685: LIST
2686: LIST
2687: LIST
2688: PUSH
2689: EMPTY
2690: LIST
2691: ADD
2692: ST_TO_ADDR
2693: GO 2866
2695: LD_INT 32
2697: DOUBLE
2698: EQUAL
2699: IFTRUE 2709
2701: LD_INT 33
2703: DOUBLE
2704: EQUAL
2705: IFTRUE 2709
2707: GO 2794
2709: POP
// Delta := Delta ^ [ [ GetX ( t ) , GetY ( t ) , GetDir ( t ) , GetBType ( t ) , GetBLevel ( t ) , GetBWeapon ( t ) ] ] ; else
2710: LD_ADDR_VAR 0 2
2714: PUSH
2715: LD_VAR 0 2
2719: PUSH
2720: LD_VAR 0 4
2724: PPUSH
2725: CALL_OW 250
2729: PUSH
2730: LD_VAR 0 4
2734: PPUSH
2735: CALL_OW 251
2739: PUSH
2740: LD_VAR 0 4
2744: PPUSH
2745: CALL_OW 254
2749: PUSH
2750: LD_VAR 0 4
2754: PPUSH
2755: CALL_OW 266
2759: PUSH
2760: LD_VAR 0 4
2764: PPUSH
2765: CALL_OW 267
2769: PUSH
2770: LD_VAR 0 4
2774: PPUSH
2775: CALL_OW 269
2779: PUSH
2780: EMPTY
2781: LIST
2782: LIST
2783: LIST
2784: LIST
2785: LIST
2786: LIST
2787: PUSH
2788: EMPTY
2789: LIST
2790: ADD
2791: ST_TO_ADDR
2792: GO 2866
2794: POP
// Delta := Delta ^ [ [ GetX ( t ) , GetY ( t ) , GetDir ( t ) , GetBType ( t ) , GetBLevel ( t ) ] ] ; end ;
2795: LD_ADDR_VAR 0 2
2799: PUSH
2800: LD_VAR 0 2
2804: PUSH
2805: LD_VAR 0 4
2809: PPUSH
2810: CALL_OW 250
2814: PUSH
2815: LD_VAR 0 4
2819: PPUSH
2820: CALL_OW 251
2824: PUSH
2825: LD_VAR 0 4
2829: PPUSH
2830: CALL_OW 254
2834: PUSH
2835: LD_VAR 0 4
2839: PPUSH
2840: CALL_OW 266
2844: PUSH
2845: LD_VAR 0 4
2849: PPUSH
2850: CALL_OW 267
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: LIST
2859: LIST
2860: LIST
2861: PUSH
2862: EMPTY
2863: LIST
2864: ADD
2865: ST_TO_ADDR
// end ;
2866: GO 2513
2868: POP
2869: POP
// SaveVariable ( Delta , Delta ) ;
2870: LD_VAR 0 2
2874: PPUSH
2875: LD_STRING Delta
2877: PPUSH
2878: CALL_OW 39
// SaveVariable ( Researched ( you , tech_radar ) , RadarDeveloped ) ;
2882: LD_EXP 1
2886: PPUSH
2887: LD_INT 6
2889: PPUSH
2890: CALL_OW 325
2894: PPUSH
2895: LD_STRING RadarDeveloped
2897: PPUSH
2898: CALL_OW 39
// end ;
2902: LD_VAR 0 1
2906: RET
// export function SetMedals ; begin
2907: LD_INT 0
2909: PPUSH
// AddMedal ( Tame , cil_mit_5_ape_eng_splnen ) ;
2910: LD_STRING Tame
2912: PPUSH
2913: LD_EXP 42
2917: PPUSH
2918: CALL_OW 101
// case GetTech ( tech_Radar , you ) of state_researched :
2922: LD_INT 6
2924: PPUSH
2925: LD_EXP 1
2929: PPUSH
2930: CALL_OW 321
2934: PUSH
2935: LD_INT 2
2937: DOUBLE
2938: EQUAL
2939: IFTRUE 2943
2941: GO 2956
2943: POP
// AddMedal ( Radar , 1 ) ; state_disabled :
2944: LD_STRING Radar
2946: PPUSH
2947: LD_INT 1
2949: PPUSH
2950: CALL_OW 101
2954: GO 3001
2956: LD_INT 0
2958: DOUBLE
2959: EQUAL
2960: IFTRUE 2964
2962: GO 2978
2964: POP
// AddMedal ( Radar , - 1 ) ; state_enabled :
2965: LD_STRING Radar
2967: PPUSH
2968: LD_INT 1
2970: NEG
2971: PPUSH
2972: CALL_OW 101
2976: GO 3001
2978: LD_INT 1
2980: DOUBLE
2981: EQUAL
2982: IFTRUE 2986
2984: GO 3000
2986: POP
// AddMedal ( Radar , - 2 ) ; end ;
2987: LD_STRING Radar
2989: PPUSH
2990: LD_INT 2
2992: NEG
2993: PPUSH
2994: CALL_OW 101
2998: GO 3001
3000: POP
// if GetTech ( tech_Radar , you ) = state_disabled then
3001: LD_INT 6
3003: PPUSH
3004: LD_EXP 1
3008: PPUSH
3009: CALL_OW 321
3013: PUSH
3014: LD_INT 0
3016: EQUAL
3017: IFFALSE 3032
// begin AddMedal ( buildRadar , - 1 ) ;
3019: LD_STRING buildRadar
3021: PPUSH
3022: LD_INT 1
3024: NEG
3025: PPUSH
3026: CALL_OW 101
// end else
3030: GO 3061
// begin if RadarBuild then
3032: LD_EXP 46
3036: IFFALSE 3050
// AddMedal ( buildRadar , 1 ) else
3038: LD_STRING buildRadar
3040: PPUSH
3041: LD_INT 1
3043: PPUSH
3044: CALL_OW 101
3048: GO 3061
// AddMedal ( buildRadar , - 2 ) ;
3050: LD_STRING buildRadar
3052: PPUSH
3053: LD_INT 2
3055: NEG
3056: PPUSH
3057: CALL_OW 101
// end ; end ;
3061: LD_VAR 0 1
3065: RET
// function KolikCrates ; var base ; begin
3066: LD_INT 0
3068: PPUSH
3069: PPUSH
// result := GetCargo ( FilterAllUnits ( [ f_side , you ] ) , mat_cans ) + GetResourceArea ( all_map , mat_cans ) ;
3070: LD_ADDR_VAR 0 1
3074: PUSH
3075: LD_INT 22
3077: PUSH
3078: LD_EXP 1
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: PPUSH
3087: CALL_OW 69
3091: PPUSH
3092: LD_INT 1
3094: PPUSH
3095: CALL_OW 289
3099: PUSH
3100: LD_INT 8
3102: PPUSH
3103: LD_INT 1
3105: PPUSH
3106: CALL_OW 287
3110: PLUS
3111: ST_TO_ADDR
// base := FilterAllUnits ( [ f_type , unit_building ] ) ;
3112: LD_ADDR_VAR 0 2
3116: PUSH
3117: LD_INT 21
3119: PUSH
3120: LD_INT 3
3122: PUSH
3123: EMPTY
3124: LIST
3125: LIST
3126: PPUSH
3127: CALL_OW 69
3131: ST_TO_ADDR
// if base then
3132: LD_VAR 0 2
3136: IFFALSE 3171
// result := result + GetResourceType ( GetBase ( base [ 1 ] ) , mat_cans ) ;
3138: LD_ADDR_VAR 0 1
3142: PUSH
3143: LD_VAR 0 1
3147: PUSH
3148: LD_VAR 0 2
3152: PUSH
3153: LD_INT 1
3155: ARRAY
3156: PPUSH
3157: CALL_OW 274
3161: PPUSH
3162: LD_INT 1
3164: PPUSH
3165: CALL_OW 275
3169: PLUS
3170: ST_TO_ADDR
// end ;
3171: LD_VAR 0 1
3175: RET
// on EndTheMissionRaised ( x ) do begin end_the_mission_allowed := false ;
3176: LD_ADDR_OWVAR 57
3180: PUSH
3181: LD_INT 0
3183: ST_TO_ADDR
// Vyhra ;
3184: CALL 3191 0 0
// end ;
3188: PPOPN 1
3190: END
// export function Vyhra ; begin
3191: LD_INT 0
3193: PPUSH
// disable ( 0 ) ;
3194: LD_INT 0
3196: DISABLE_MARKED
// SetMedals ;
3197: CALL 2907 0 0
// GiveMedals ( Main ) ;
3201: LD_STRING Main
3203: PPUSH
3204: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_nation , nation_american ] ] ) ) ;
3208: LD_INT 22
3210: PUSH
3211: LD_EXP 1
3215: PUSH
3216: EMPTY
3217: LIST
3218: LIST
3219: PUSH
3220: LD_INT 21
3222: PUSH
3223: LD_INT 1
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: PUSH
3230: LD_INT 23
3232: PUSH
3233: LD_INT 1
3235: PUSH
3236: EMPTY
3237: LIST
3238: LIST
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: LIST
3244: PPUSH
3245: CALL_OW 69
3249: PPUSH
3250: CALL_OW 43
// Save ;
3254: CALL 1958 0 0
// YouWin ;
3258: CALL_OW 103
// end ;
3262: LD_VAR 0 1
3266: RET
// on UpgradeComplete ( build ) do begin if UnitFilter ( build , [ [ f_btype , b_lab_half ] ] ) then
3267: LD_VAR 0 1
3271: PPUSH
3272: LD_INT 30
3274: PUSH
3275: LD_INT 7
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: PUSH
3282: EMPTY
3283: LIST
3284: PPUSH
3285: CALL_OW 72
3289: IFFALSE 3298
// MyHint ( UpgradeLab ) ;
3291: LD_STRING UpgradeLab
3293: PPUSH
3294: CALL 15083 0 1
// end ; end_of_file
3298: PPOPN 1
3300: END
// var startx , starty , startd ; export function Dialog1 ; var qr , i , mechs , sols ; begin
3301: LD_INT 0
3303: PPUSH
3304: PPUSH
3305: PPUSH
3306: PPUSH
3307: PPUSH
// InGameOn ;
3308: CALL_OW 8
// startx := 27 ;
3312: LD_ADDR_LOC 1
3316: PUSH
3317: LD_INT 27
3319: ST_TO_ADDR
// starty := 50 ;
3320: LD_ADDR_LOC 2
3324: PUSH
3325: LD_INT 50
3327: ST_TO_ADDR
// startd := 5 ;
3328: LD_ADDR_LOC 3
3332: PUSH
3333: LD_INT 5
3335: ST_TO_ADDR
// InitUc ;
3336: CALL_OW 18
// InitHc ;
3340: CALL_OW 19
// InitVc ;
3344: CALL_OW 20
// uc_side := you ;
3348: LD_ADDR_OWVAR 20
3352: PUSH
3353: LD_EXP 1
3357: ST_TO_ADDR
// uc_nation := nation_american ;
3358: LD_ADDR_OWVAR 21
3362: PUSH
3363: LD_INT 1
3365: ST_TO_ADDR
// not_char := used diff [ JMM , Glad , Lisa , Frank ] ;
3366: LD_ADDR_EXP 48
3370: PUSH
3371: LD_EXP 56
3375: PUSH
3376: LD_EXP 10
3380: PUSH
3381: LD_EXP 11
3385: PUSH
3386: LD_EXP 14
3390: PUSH
3391: LD_EXP 15
3395: PUSH
3396: EMPTY
3397: LIST
3398: LIST
3399: LIST
3400: LIST
3401: DIFF
3402: ST_TO_ADDR
// not_char := not_char diff [ Cyrus , Bobby , Brown , Don ] ;
3403: LD_ADDR_EXP 48
3407: PUSH
3408: LD_EXP 48
3412: PUSH
3413: LD_EXP 19
3417: PUSH
3418: LD_EXP 18
3422: PUSH
3423: LD_EXP 17
3427: PUSH
3428: LD_EXP 16
3432: PUSH
3433: EMPTY
3434: LIST
3435: LIST
3436: LIST
3437: LIST
3438: DIFF
3439: ST_TO_ADDR
// if Brown in used then
3440: LD_EXP 17
3444: PUSH
3445: LD_EXP 56
3449: IN
3450: IFFALSE 3471
// not_char := not_char ^ [ Brown ] ;
3452: LD_ADDR_EXP 48
3456: PUSH
3457: LD_EXP 48
3461: PUSH
3462: LD_EXP 17
3466: PUSH
3467: EMPTY
3468: LIST
3469: ADD
3470: ST_TO_ADDR
// if Don in used then
3471: LD_EXP 16
3475: PUSH
3476: LD_EXP 56
3480: IN
3481: IFFALSE 3502
// not_char := not_char ^ [ Don ] ;
3483: LD_ADDR_EXP 48
3487: PUSH
3488: LD_EXP 48
3492: PUSH
3493: LD_EXP 16
3497: PUSH
3498: EMPTY
3499: LIST
3500: ADD
3501: ST_TO_ADDR
// if Cyrus in used then
3502: LD_EXP 19
3506: PUSH
3507: LD_EXP 56
3511: IN
3512: IFFALSE 3533
// not_char := not_char ^ [ Cyrus ] ;
3514: LD_ADDR_EXP 48
3518: PUSH
3519: LD_EXP 48
3523: PUSH
3524: LD_EXP 19
3528: PUSH
3529: EMPTY
3530: LIST
3531: ADD
3532: ST_TO_ADDR
// if Bobby in used then
3533: LD_EXP 18
3537: PUSH
3538: LD_EXP 56
3542: IN
3543: IFFALSE 3564
// not_char := not_char ^ [ Bobby ] ;
3545: LD_ADDR_EXP 48
3549: PUSH
3550: LD_EXP 48
3554: PUSH
3555: LD_EXP 18
3559: PUSH
3560: EMPTY
3561: LIST
3562: ADD
3563: ST_TO_ADDR
// mechs := UnitFilter ( used , [ [ f_class , class_mechanic ] ] ) ;
3564: LD_ADDR_VAR 0 4
3568: PUSH
3569: LD_EXP 56
3573: PPUSH
3574: LD_INT 25
3576: PUSH
3577: LD_INT 3
3579: PUSH
3580: EMPTY
3581: LIST
3582: LIST
3583: PUSH
3584: EMPTY
3585: LIST
3586: PPUSH
3587: CALL_OW 72
3591: ST_TO_ADDR
// sols := UnitFilter ( used , [ [ f_class , class_soldier ] ] ) ;
3592: LD_ADDR_VAR 0 5
3596: PUSH
3597: LD_EXP 56
3601: PPUSH
3602: LD_INT 25
3604: PUSH
3605: LD_INT 1
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: PUSH
3612: EMPTY
3613: LIST
3614: PPUSH
3615: CALL_OW 72
3619: ST_TO_ADDR
// used := mechs ^ sols ^ ( used diff ( mechs ^ sols ) ) ;
3620: LD_ADDR_EXP 56
3624: PUSH
3625: LD_VAR 0 4
3629: PUSH
3630: LD_VAR 0 5
3634: ADD
3635: PUSH
3636: LD_EXP 56
3640: PUSH
3641: LD_VAR 0 4
3645: PUSH
3646: LD_VAR 0 5
3650: ADD
3651: DIFF
3652: ADD
3653: ST_TO_ADDR
// Wait ( 0 0$1.0 ) ;
3654: LD_INT 35
3656: PPUSH
3657: CALL_OW 67
// PlaceHumanInUnit ( used [ 1 ] , Car1 ) ;
3661: LD_EXP 56
3665: PUSH
3666: LD_INT 1
3668: ARRAY
3669: PPUSH
3670: LD_EXP 24
3674: PPUSH
3675: CALL_OW 52
// PlaceHumanInUnit ( used [ 2 ] , Car2 ) ;
3679: LD_EXP 56
3683: PUSH
3684: LD_INT 2
3686: ARRAY
3687: PPUSH
3688: LD_EXP 25
3692: PPUSH
3693: CALL_OW 52
// PlaceHumanInUnit ( used [ 3 ] , Car3 ) ;
3697: LD_EXP 56
3701: PUSH
3702: LD_INT 3
3704: ARRAY
3705: PPUSH
3706: LD_EXP 26
3710: PPUSH
3711: CALL_OW 52
// PlaceUnitXYR ( Car1 , startx , starty , startd , false ) ;
3715: LD_EXP 24
3719: PPUSH
3720: LD_LOC 1
3724: PPUSH
3725: LD_LOC 2
3729: PPUSH
3730: LD_LOC 3
3734: PPUSH
3735: LD_INT 0
3737: PPUSH
3738: CALL_OW 50
// PlaceUnitXYR ( Car2 , startx , starty , startd , false ) ;
3742: LD_EXP 25
3746: PPUSH
3747: LD_LOC 1
3751: PPUSH
3752: LD_LOC 2
3756: PPUSH
3757: LD_LOC 3
3761: PPUSH
3762: LD_INT 0
3764: PPUSH
3765: CALL_OW 50
// PlaceUnitXYR ( Car3 , startx , starty , startd , false ) ;
3769: LD_EXP 26
3773: PPUSH
3774: LD_LOC 1
3778: PPUSH
3779: LD_LOC 2
3783: PPUSH
3784: LD_LOC 3
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 50
// for i := 4 to used do
3796: LD_ADDR_VAR 0 3
3800: PUSH
3801: DOUBLE
3802: LD_INT 4
3804: DEC
3805: ST_TO_ADDR
3806: LD_EXP 56
3810: PUSH
3811: FOR_TO
3812: IFFALSE 3849
// PlaceUnitXYR ( used [ i ] , startx , starty , startd , false ) ;
3814: LD_EXP 56
3818: PUSH
3819: LD_VAR 0 3
3823: ARRAY
3824: PPUSH
3825: LD_LOC 1
3829: PPUSH
3830: LD_LOC 2
3834: PPUSH
3835: LD_LOC 3
3839: PPUSH
3840: LD_INT 0
3842: PPUSH
3843: CALL_OW 50
3847: GO 3811
3849: POP
3850: POP
// tvoji_lidi := used ;
3851: LD_ADDR_EXP 47
3855: PUSH
3856: LD_EXP 56
3860: ST_TO_ADDR
// Wait ( 0 0$1 ) ;
3861: LD_INT 35
3863: PPUSH
3864: CALL_OW 67
// CenterNowOnXY ( startx , starty ) ;
3868: LD_LOC 1
3872: PPUSH
3873: LD_LOC 2
3877: PPUSH
3878: CALL_OW 86
// Say ( JMM , D1d-JMM-1a ) ;
3882: LD_EXP 10
3886: PPUSH
3887: LD_STRING D1d-JMM-1a
3889: PPUSH
3890: CALL_OW 88
// SayRadio ( Har , D1d-Har-1 ) ;
3894: LD_EXP 12
3898: PPUSH
3899: LD_STRING D1d-Har-1
3901: PPUSH
3902: CALL_OW 94
// InGameOff ;
3906: CALL_OW 9
// SaveForQuickRestart ;
3910: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
3914: LD_STRING M1
3916: PPUSH
3917: CALL_OW 337
// Wait ( 0 0$1.0 ) ;
3921: LD_INT 35
3923: PPUSH
3924: CALL_OW 67
// TalkOn ;
3928: CALL 14735 0 0
// if Say ( JMM , D2-JMM-1 ) then
3932: LD_EXP 10
3936: PPUSH
3937: LD_STRING D2-JMM-1
3939: PPUSH
3940: CALL_OW 88
3944: IFFALSE 4000
// if Say ( Glad , D2-Glad-1 ) then
3946: LD_EXP 11
3950: PPUSH
3951: LD_STRING D2-Glad-1
3953: PPUSH
3954: CALL_OW 88
3958: IFFALSE 4000
// if Say ( JMM , D2-JMM-2 ) then
3960: LD_EXP 10
3964: PPUSH
3965: LD_STRING D2-JMM-2
3967: PPUSH
3968: CALL_OW 88
3972: IFFALSE 4000
// if Say ( Glad , D2-Glad-2 ) then
3974: LD_EXP 11
3978: PPUSH
3979: LD_STRING D2-Glad-2
3981: PPUSH
3982: CALL_OW 88
3986: IFFALSE 4000
// Say ( JMM , D2-JMM-3 ) ;
3988: LD_EXP 10
3992: PPUSH
3993: LD_STRING D2-JMM-3
3995: PPUSH
3996: CALL_OW 88
// TalkOff ;
4000: CALL 14743 0 0
// end ;
4004: LD_VAR 0 1
4008: RET
// every 0 0$10 trigger denis_can_come and laboratore do var a , mytick ;
4009: LD_EXP 45
4013: PUSH
4014: LD_EXP 62
4018: AND
4019: IFFALSE 4399
4021: GO 4023
4023: DISABLE
4024: LD_INT 0
4026: PPUSH
4027: PPUSH
// begin mytick := tick + 0 0$55 ;
4028: LD_ADDR_VAR 0 2
4032: PUSH
4033: LD_OWVAR 1
4037: PUSH
4038: LD_INT 1925
4040: PLUS
4041: ST_TO_ADDR
// while mytick > tick and GetTechProgress ( tech_ApePsych , you ) < 40 do
4042: LD_VAR 0 2
4046: PUSH
4047: LD_OWVAR 1
4051: GREATER
4052: PUSH
4053: LD_INT 2
4055: PPUSH
4056: LD_EXP 1
4060: PPUSH
4061: CALL_OW 326
4065: PUSH
4066: LD_INT 40
4068: LESS
4069: AND
4070: IFFALSE 4081
// wait ( 0 0$1 ) ;
4072: LD_INT 35
4074: PPUSH
4075: CALL_OW 67
4079: GO 4042
// SetSide ( Denis , you2 ) ;
4081: LD_EXP 20
4085: PPUSH
4086: LD_EXP 2
4090: PPUSH
4091: CALL_OW 235
// PlaceUnitXYR ( Denis , 20 , 35 , 5 , false ) ;
4095: LD_EXP 20
4099: PPUSH
4100: LD_INT 20
4102: PPUSH
4103: LD_INT 35
4105: PPUSH
4106: LD_INT 5
4108: PPUSH
4109: LD_INT 0
4111: PPUSH
4112: CALL_OW 50
// Wait ( 0 0$2 ) ;
4116: LD_INT 70
4118: PPUSH
4119: CALL_OW 67
// Den := Denis ;
4123: LD_ADDR_EXP 13
4127: PUSH
4128: LD_EXP 20
4132: ST_TO_ADDR
// DialogueOn ;
4133: CALL_OW 6
// CenterOnUnits ( Den ) ;
4137: LD_EXP 13
4141: PPUSH
4142: CALL_OW 85
// if Say ( Den , DD-Den-1 ) then
4146: LD_EXP 13
4150: PPUSH
4151: LD_STRING DD-Den-1
4153: PPUSH
4154: CALL_OW 88
4158: IFFALSE 4186
// if Say ( JMM , DD-JMM-1 ) then
4160: LD_EXP 10
4164: PPUSH
4165: LD_STRING DD-JMM-1
4167: PPUSH
4168: CALL_OW 88
4172: IFFALSE 4186
// Say ( Den , DD-Den-2 ) ;
4174: LD_EXP 13
4178: PPUSH
4179: LD_STRING DD-Den-2
4181: PPUSH
4182: CALL_OW 88
// DialogueOff ;
4186: CALL_OW 7
// if laboratore then
4190: LD_EXP 62
4194: IFFALSE 4212
// a := laboratore [ 1 ] else
4196: LD_ADDR_VAR 0 1
4200: PUSH
4201: LD_EXP 62
4205: PUSH
4206: LD_INT 1
4208: ARRAY
4209: ST_TO_ADDR
4210: GO 4226
// a := budovy [ 1 ] ;
4212: LD_ADDR_VAR 0 1
4216: PUSH
4217: LD_EXP 63
4221: PUSH
4222: LD_INT 1
4224: ARRAY
4225: ST_TO_ADDR
// ComMoveUnit ( Den , a ) ;
4226: LD_EXP 13
4230: PPUSH
4231: LD_VAR 0 1
4235: PPUSH
4236: CALL_OW 112
// Say ( Den , DD-Den-2a ) ;
4240: LD_EXP 13
4244: PPUSH
4245: LD_STRING DD-Den-2a
4247: PPUSH
4248: CALL_OW 88
// mytick := tick + 0 0$20 ;
4252: LD_ADDR_VAR 0 2
4256: PUSH
4257: LD_OWVAR 1
4261: PUSH
4262: LD_INT 700
4264: PLUS
4265: ST_TO_ADDR
// while GetDistUnits ( den , a ) > 4 and IsLive ( a ) and mytick > tick do
4266: LD_EXP 13
4270: PPUSH
4271: LD_VAR 0 1
4275: PPUSH
4276: CALL_OW 296
4280: PUSH
4281: LD_INT 4
4283: GREATER
4284: PUSH
4285: LD_VAR 0 1
4289: PPUSH
4290: CALL_OW 300
4294: AND
4295: PUSH
4296: LD_VAR 0 2
4300: PUSH
4301: LD_OWVAR 1
4305: GREATER
4306: AND
4307: IFFALSE 4318
// wait ( 0 0$0.6 ) ;
4309: LD_INT 21
4311: PPUSH
4312: CALL_OW 67
4316: GO 4266
// SetSide ( Den , you ) ;
4318: LD_EXP 13
4322: PPUSH
4323: LD_EXP 1
4327: PPUSH
4328: CALL_OW 235
// tvoji_lidi := tvoji_lidi union Den ;
4332: LD_ADDR_EXP 47
4336: PUSH
4337: LD_EXP 47
4341: PUSH
4342: LD_EXP 13
4346: UNION
4347: ST_TO_ADDR
// if laboratore then
4348: LD_EXP 62
4352: IFFALSE 4399
// begin ComEnterUnit ( Den , a ) ;
4354: LD_EXP 13
4358: PPUSH
4359: LD_VAR 0 1
4363: PPUSH
4364: CALL_OW 120
// AddComChangeProfession ( Den , class_scientistic ) ;
4368: LD_EXP 13
4372: PPUSH
4373: LD_INT 4
4375: PPUSH
4376: CALL_OW 183
// Wait ( 0 0$2 ) ;
4380: LD_INT 70
4382: PPUSH
4383: CALL_OW 67
// Say ( Den , DD-Den-2b ) ;
4387: LD_EXP 13
4391: PPUSH
4392: LD_STRING DD-Den-2b
4394: PPUSH
4395: CALL_OW 88
// end ; end ;
4399: PPOPN 2
4401: END
// on ResearchComplete ( tech , lab ) do var qr ;
4402: LD_INT 0
4404: PPUSH
// begin if ( GetSide ( lab ) = you ) then
4405: LD_VAR 0 2
4409: PPUSH
4410: CALL_OW 255
4414: PUSH
4415: LD_EXP 1
4419: EQUAL
4420: IFFALSE 4722
// begin wait ( 0 0$1 ) ;
4422: LD_INT 35
4424: PPUSH
4425: CALL_OW 67
// if tech = tech_ApeLang then
4429: LD_VAR 0 1
4433: PUSH
4434: LD_INT 1
4436: EQUAL
4437: IFFALSE 4528
// begin zasilka_muze := true ;
4439: LD_ADDR_EXP 43
4443: PUSH
4444: LD_INT 1
4446: ST_TO_ADDR
// if IsLive ( Glad ) then
4447: LD_EXP 11
4451: PPUSH
4452: CALL_OW 300
4456: IFFALSE 4521
// begin Wait ( 0 0$1 ) ;
4458: LD_INT 35
4460: PPUSH
4461: CALL_OW 67
// DialogueOn ;
4465: CALL_OW 6
// Say ( Glad , D3-Glad-1 ) ;
4469: LD_EXP 11
4473: PPUSH
4474: LD_STRING D3-Glad-1
4476: PPUSH
4477: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
4481: LD_EXP 10
4485: PPUSH
4486: LD_STRING D3-JMM-1
4488: PPUSH
4489: CALL_OW 88
// Say ( Glad , D3-Glad-2 ) ;
4493: LD_EXP 11
4497: PPUSH
4498: LD_STRING D3-Glad-2
4500: PPUSH
4501: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
4505: LD_EXP 10
4509: PPUSH
4510: LD_STRING D3-JMM-2
4512: PPUSH
4513: CALL_OW 88
// DialogueOff ;
4517: CALL_OW 7
// end ; MyHint ( ApemenTaming ) ;
4521: LD_STRING ApemenTaming
4523: PPUSH
4524: CALL 15083 0 1
// end ; if tech = tech_ApePsych then
4528: LD_VAR 0 1
4532: PUSH
4533: LD_INT 2
4535: EQUAL
4536: IFFALSE 4683
// begin Wait ( 0 0$1 ) ;
4538: LD_INT 35
4540: PPUSH
4541: CALL_OW 67
// while opic <= 0 do
4545: LD_EXP 40
4549: PUSH
4550: LD_INT 0
4552: LESSEQUAL
4553: IFFALSE 4564
// wait ( 0 0$2 ) ;
4555: LD_INT 70
4557: PPUSH
4558: CALL_OW 67
4562: GO 4545
// DialogueOn ;
4564: CALL_OW 6
// if Frank then
4568: LD_EXP 15
4572: IFFALSE 4588
// Say ( Frank , D8a-Frank-1 ) else
4574: LD_EXP 15
4578: PPUSH
4579: LD_STRING D8a-Frank-1
4581: PPUSH
4582: CALL_OW 88
4586: GO 4614
// SayAny ( not_char , D8a-Sol1-1 , you , sex_male , 0 , 0 ) ;
4588: LD_EXP 48
4592: PPUSH
4593: LD_STRING D8a-Sol1-1
4595: PPUSH
4596: LD_EXP 1
4600: PPUSH
4601: LD_INT 1
4603: PPUSH
4604: LD_INT 0
4606: PPUSH
4607: LD_INT 0
4609: PPUSH
4610: CALL 14809 0 6
// if Den then
4614: LD_EXP 13
4618: IFFALSE 4634
// Say ( Den , D8a-Den-1 ) else
4620: LD_EXP 13
4624: PPUSH
4625: LD_STRING D8a-Den-1
4627: PPUSH
4628: CALL_OW 88
4632: GO 4660
// SayAny ( not_char , D8a-Sci1-1 , you , sex_male , class_scientistic , 0 ) ;
4634: LD_EXP 48
4638: PPUSH
4639: LD_STRING D8a-Sci1-1
4641: PPUSH
4642: LD_EXP 1
4646: PPUSH
4647: LD_INT 1
4649: PPUSH
4650: LD_INT 4
4652: PPUSH
4653: LD_INT 0
4655: PPUSH
4656: CALL 14809 0 6
// Say ( JMM , D8a-JMM-1 ) ;
4660: LD_EXP 10
4664: PPUSH
4665: LD_STRING D8a-JMM-1
4667: PPUSH
4668: CALL_OW 88
// DialogueOff ;
4672: CALL_OW 7
// MyHint ( ApemenPsychology ) ;
4676: LD_STRING ApemenPsychology
4678: PPUSH
4679: CALL 15083 0 1
// end ; if tech = tech_Radar then
4683: LD_VAR 0 1
4687: PUSH
4688: LD_INT 6
4690: EQUAL
4691: IFFALSE 4722
// begin ChangeMissionObjectives ( M2a ) ;
4693: LD_STRING M2a
4695: PPUSH
4696: CALL_OW 337
// SetRestrict ( b_ext_radar , you , state_enabled ) ;
4700: LD_INT 20
4702: PPUSH
4703: LD_EXP 1
4707: PPUSH
4708: LD_INT 1
4710: PPUSH
4711: CALL_OW 324
// MyHint ( Extensions ) ;
4715: LD_STRING Extensions
4717: PPUSH
4718: CALL 15083 0 1
// end ; end ; end ;
4722: PPOPN 3
4724: END
// every 0 0$5 trigger FilterAllUnits ( [ f_class , class_apeman_engineer ] ) >= 5 do
4725: LD_INT 25
4727: PUSH
4728: LD_INT 16
4730: PUSH
4731: EMPTY
4732: LIST
4733: LIST
4734: PPUSH
4735: CALL_OW 69
4739: PUSH
4740: LD_INT 5
4742: GREATEREQUAL
4743: IFFALSE 4763
4745: GO 4747
4747: DISABLE
// begin cil_mit_5_ape_eng_splnen := true ;
4748: LD_ADDR_EXP 42
4752: PUSH
4753: LD_INT 1
4755: ST_TO_ADDR
// ChangeMissionObjectives ( M1b ) ;
4756: LD_STRING M1b
4758: PPUSH
4759: CALL_OW 337
// end ;
4763: END
// every 0 0$5 trigger FilterAllUnits ( [ f_class , class_apeman_engineer ] ) do
4764: LD_INT 25
4766: PUSH
4767: LD_INT 16
4769: PUSH
4770: EMPTY
4771: LIST
4772: LIST
4773: PPUSH
4774: CALL_OW 69
4778: IFFALSE 4798
4780: GO 4782
4782: DISABLE
// begin cil_mit_1_ape_eng_splnen := true ;
4783: LD_ADDR_EXP 41
4787: PUSH
4788: LD_INT 1
4790: ST_TO_ADDR
// ChangeMissionObjectives ( M1a ) ;
4791: LD_STRING M1a
4793: PPUSH
4794: CALL_OW 337
// end ;
4798: END
// every 0 0$3 trigger FilterAllUnits ( [ f_weapon , us_radar ] ) or ma_radar do
4799: LD_INT 34
4801: PUSH
4802: LD_INT 11
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: PPUSH
4809: CALL_OW 69
4813: PUSH
4814: CALL 4840 0 0
4818: OR
4819: IFFALSE 4839
4821: GO 4823
4823: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
4824: LD_STRING M2b
4826: PPUSH
4827: CALL_OW 337
// RadarBuild := true ;
4831: LD_ADDR_EXP 46
4835: PUSH
4836: LD_INT 1
4838: ST_TO_ADDR
// end ;
4839: END
// function ma_radar ; var i ; begin
4840: LD_INT 0
4842: PPUSH
4843: PPUSH
// result := false ;
4844: LD_ADDR_VAR 0 1
4848: PUSH
4849: LD_INT 0
4851: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
4852: LD_ADDR_VAR 0 2
4856: PUSH
4857: LD_INT 21
4859: PUSH
4860: LD_INT 3
4862: PUSH
4863: EMPTY
4864: LIST
4865: LIST
4866: PPUSH
4867: CALL_OW 69
4871: PUSH
4872: FOR_IN
4873: IFFALSE 4902
// begin if GetBWeapon ( i ) = us_radar then
4875: LD_VAR 0 2
4879: PPUSH
4880: CALL_OW 269
4884: PUSH
4885: LD_INT 11
4887: EQUAL
4888: IFFALSE 4900
// begin result := true ;
4890: LD_ADDR_VAR 0 1
4894: PUSH
4895: LD_INT 1
4897: ST_TO_ADDR
// break ;
4898: GO 4902
// end ; end ;
4900: GO 4872
4902: POP
4903: POP
// end ;
4904: LD_VAR 0 1
4908: RET
// every 7 7$0 do var hex , depot ;
4909: GO 4911
4911: DISABLE
4912: LD_INT 0
4914: PPUSH
4915: PPUSH
// begin depot := FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ [ f_btype , b_warehouse ] ] ] ) ;
4916: LD_ADDR_VAR 0 2
4920: PUSH
4921: LD_INT 2
4923: PUSH
4924: LD_INT 30
4926: PUSH
4927: LD_INT 0
4929: PUSH
4930: EMPTY
4931: LIST
4932: LIST
4933: PUSH
4934: LD_INT 30
4936: PUSH
4937: LD_INT 1
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: PUSH
4944: EMPTY
4945: LIST
4946: PUSH
4947: EMPTY
4948: LIST
4949: LIST
4950: LIST
4951: PPUSH
4952: CALL_OW 69
4956: ST_TO_ADDR
// if depot then
4957: LD_VAR 0 2
4961: IFFALSE 4979
// depot := depot [ 1 ] else
4963: LD_ADDR_VAR 0 2
4967: PUSH
4968: LD_VAR 0 2
4972: PUSH
4973: LD_INT 1
4975: ARRAY
4976: ST_TO_ADDR
4977: GO 4989
// depot := JMM ;
4979: LD_ADDR_VAR 0 2
4983: PUSH
4984: LD_EXP 10
4988: ST_TO_ADDR
// repeat hex := RandHex ( false ) ;
4989: LD_ADDR_VAR 0 1
4993: PUSH
4994: LD_INT 0
4996: PPUSH
4997: CALL_OW 15
5001: ST_TO_ADDR
// until GetDistUnitXY ( depot , hex [ 1 ] , hex [ 2 ] ) > 10 and GetDistUnitXY ( depot , hex [ 1 ] , hex [ 2 ] ) < 20 ;
5002: LD_VAR 0 2
5006: PPUSH
5007: LD_VAR 0 1
5011: PUSH
5012: LD_INT 1
5014: ARRAY
5015: PPUSH
5016: LD_VAR 0 1
5020: PUSH
5021: LD_INT 2
5023: ARRAY
5024: PPUSH
5025: CALL_OW 297
5029: PUSH
5030: LD_INT 10
5032: GREATER
5033: PUSH
5034: LD_VAR 0 2
5038: PPUSH
5039: LD_VAR 0 1
5043: PUSH
5044: LD_INT 1
5046: ARRAY
5047: PPUSH
5048: LD_VAR 0 1
5052: PUSH
5053: LD_INT 2
5055: ARRAY
5056: PPUSH
5057: CALL_OW 297
5061: PUSH
5062: LD_INT 20
5064: LESS
5065: AND
5066: IFFALSE 4989
// CreateCratesXYR ( 5 , hex [ 1 ] , hex [ 2 ] , 5 , true ) ;
5068: LD_INT 5
5070: PPUSH
5071: LD_VAR 0 1
5075: PUSH
5076: LD_INT 1
5078: ARRAY
5079: PPUSH
5080: LD_VAR 0 1
5084: PUSH
5085: LD_INT 2
5087: ARRAY
5088: PPUSH
5089: LD_INT 5
5091: PPUSH
5092: LD_INT 1
5094: PPUSH
5095: CALL_OW 56
// mat_crates := mat_crates + 1 ;
5099: LD_ADDR_EXP 54
5103: PUSH
5104: LD_EXP 54
5108: PUSH
5109: LD_INT 1
5111: PLUS
5112: ST_TO_ADDR
// end ;
5113: PPOPN 2
5115: END
// every 0 0$10 trigger zasilka_muze do var hex , depot ;
5116: LD_EXP 43
5120: IFFALSE 5337
5122: GO 5124
5124: DISABLE
5125: LD_INT 0
5127: PPUSH
5128: PPUSH
// begin wait ( 10 10$0 ) ;
5129: LD_INT 21000
5131: PPUSH
5132: CALL_OW 67
// depot := FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ [ f_btype , b_warehouse ] ] ] ) [ 1 ] ;
5136: LD_ADDR_VAR 0 2
5140: PUSH
5141: LD_INT 2
5143: PUSH
5144: LD_INT 30
5146: PUSH
5147: LD_INT 0
5149: PUSH
5150: EMPTY
5151: LIST
5152: LIST
5153: PUSH
5154: LD_INT 30
5156: PUSH
5157: LD_INT 1
5159: PUSH
5160: EMPTY
5161: LIST
5162: LIST
5163: PUSH
5164: EMPTY
5165: LIST
5166: PUSH
5167: EMPTY
5168: LIST
5169: LIST
5170: LIST
5171: PPUSH
5172: CALL_OW 69
5176: PUSH
5177: LD_INT 1
5179: ARRAY
5180: ST_TO_ADDR
// if depot then
5181: LD_VAR 0 2
5185: IFFALSE 5203
// depot := depot [ 1 ] else
5187: LD_ADDR_VAR 0 2
5191: PUSH
5192: LD_VAR 0 2
5196: PUSH
5197: LD_INT 1
5199: ARRAY
5200: ST_TO_ADDR
5201: GO 5213
// depot := JMM ;
5203: LD_ADDR_VAR 0 2
5207: PUSH
5208: LD_EXP 10
5212: ST_TO_ADDR
// repeat hex := RandHex ( false ) ;
5213: LD_ADDR_VAR 0 1
5217: PUSH
5218: LD_INT 0
5220: PPUSH
5221: CALL_OW 15
5225: ST_TO_ADDR
// until GetDistUnitXY ( depot , hex [ 1 ] , hex [ 2 ] ) > 10 and GetDistUnitXY ( depot , hex [ 1 ] , hex [ 2 ] ) < 20 ;
5226: LD_VAR 0 2
5230: PPUSH
5231: LD_VAR 0 1
5235: PUSH
5236: LD_INT 1
5238: ARRAY
5239: PPUSH
5240: LD_VAR 0 1
5244: PUSH
5245: LD_INT 2
5247: ARRAY
5248: PPUSH
5249: CALL_OW 297
5253: PUSH
5254: LD_INT 10
5256: GREATER
5257: PUSH
5258: LD_VAR 0 2
5262: PPUSH
5263: LD_VAR 0 1
5267: PUSH
5268: LD_INT 1
5270: ARRAY
5271: PPUSH
5272: LD_VAR 0 1
5276: PUSH
5277: LD_INT 2
5279: ARRAY
5280: PPUSH
5281: CALL_OW 297
5285: PUSH
5286: LD_INT 20
5288: LESS
5289: AND
5290: IFFALSE 5213
// CreateCratesXYR ( 5 , hex [ 1 ] , hex [ 2 ] , 5 , true ) ;
5292: LD_INT 5
5294: PPUSH
5295: LD_VAR 0 1
5299: PUSH
5300: LD_INT 1
5302: ARRAY
5303: PPUSH
5304: LD_VAR 0 1
5308: PUSH
5309: LD_INT 2
5311: ARRAY
5312: PPUSH
5313: LD_INT 5
5315: PPUSH
5316: LD_INT 1
5318: PPUSH
5319: CALL_OW 56
// mat_crates := mat_crates + 1 ;
5323: LD_ADDR_EXP 54
5327: PUSH
5328: LD_EXP 54
5332: PUSH
5333: LD_INT 1
5335: PLUS
5336: ST_TO_ADDR
// end ;
5337: PPOPN 2
5339: END
// every 0 0$1 trigger zasilka_muze and Den do var cekani , budova , x , y , mytick ;
5340: LD_EXP 43
5344: PUSH
5345: LD_EXP 13
5349: AND
5350: IFFALSE 5800
5352: GO 5354
5354: DISABLE
5355: LD_INT 0
5357: PPUSH
5358: PPUSH
5359: PPUSH
5360: PPUSH
5361: PPUSH
// begin cekani := [ 1 1$30 , 1 1$50 , 2 2$10 , 2 2$30 ] [ rand ( 1 , 4 ) ] ;
5362: LD_ADDR_VAR 0 1
5366: PUSH
5367: LD_INT 3150
5369: PUSH
5370: LD_INT 3850
5372: PUSH
5373: LD_INT 4550
5375: PUSH
5376: LD_INT 5250
5378: PUSH
5379: EMPTY
5380: LIST
5381: LIST
5382: LIST
5383: LIST
5384: PUSH
5385: LD_INT 1
5387: PPUSH
5388: LD_INT 4
5390: PPUSH
5391: CALL_OW 12
5395: ARRAY
5396: ST_TO_ADDR
// mytick := tick + cekani ;
5397: LD_ADDR_VAR 0 5
5401: PUSH
5402: LD_OWVAR 1
5406: PUSH
5407: LD_VAR 0 1
5411: PLUS
5412: ST_TO_ADDR
// while tick < mytick and GetTechProgress ( tech_ApePsych , you ) < 70 do
5413: LD_OWVAR 1
5417: PUSH
5418: LD_VAR 0 5
5422: LESS
5423: PUSH
5424: LD_INT 2
5426: PPUSH
5427: LD_EXP 1
5431: PPUSH
5432: CALL_OW 326
5436: PUSH
5437: LD_INT 70
5439: LESS
5440: AND
5441: IFFALSE 5452
// Wait ( 0 0$1 ) ;
5443: LD_INT 35
5445: PPUSH
5446: CALL_OW 67
5450: GO 5413
// budova := FilterAllUnits ( [ f_btype , b_depot ] ) ;
5452: LD_ADDR_VAR 0 2
5456: PUSH
5457: LD_INT 30
5459: PUSH
5460: LD_INT 0
5462: PUSH
5463: EMPTY
5464: LIST
5465: LIST
5466: PPUSH
5467: CALL_OW 69
5471: ST_TO_ADDR
// if budova then
5472: LD_VAR 0 2
5476: IFFALSE 5524
// begin budova := budova [ 1 ] ;
5478: LD_ADDR_VAR 0 2
5482: PUSH
5483: LD_VAR 0 2
5487: PUSH
5488: LD_INT 1
5490: ARRAY
5491: ST_TO_ADDR
// x := GetX ( budova ) ;
5492: LD_ADDR_VAR 0 3
5496: PUSH
5497: LD_VAR 0 2
5501: PPUSH
5502: CALL_OW 250
5506: ST_TO_ADDR
// y := GetY ( budova ) ;
5507: LD_ADDR_VAR 0 4
5511: PUSH
5512: LD_VAR 0 2
5516: PPUSH
5517: CALL_OW 251
5521: ST_TO_ADDR
// end else
5522: GO 5540
// begin x := 41 ;
5524: LD_ADDR_VAR 0 3
5528: PUSH
5529: LD_INT 41
5531: ST_TO_ADDR
// y := 24 ;
5532: LD_ADDR_VAR 0 4
5536: PUSH
5537: LD_INT 24
5539: ST_TO_ADDR
// end ; CreateCratesXYR ( 5 , x , y , 10 , true ) ;
5540: LD_INT 5
5542: PPUSH
5543: LD_VAR 0 3
5547: PPUSH
5548: LD_VAR 0 4
5552: PPUSH
5553: LD_INT 10
5555: PPUSH
5556: LD_INT 1
5558: PPUSH
5559: CALL_OW 56
// mat_crates := mat_crates + 1 ;
5563: LD_ADDR_EXP 54
5567: PUSH
5568: LD_EXP 54
5572: PUSH
5573: LD_INT 1
5575: PLUS
5576: ST_TO_ADDR
// Wait ( 0 0$6 ) ;
5577: LD_INT 210
5579: PPUSH
5580: CALL_OW 67
// DialogueOn ;
5584: CALL_OW 6
// Say ( JMM , D4-JMM-1 ) ;
5588: LD_EXP 10
5592: PPUSH
5593: LD_STRING D4-JMM-1
5595: PPUSH
5596: CALL_OW 88
// if Say ( Den , D4-Den-1 ) then
5600: LD_EXP 13
5604: PPUSH
5605: LD_STRING D4-Den-1
5607: PPUSH
5608: CALL_OW 88
5612: IFFALSE 5640
// if Say ( JMM , D4-JMM-2 ) then
5614: LD_EXP 10
5618: PPUSH
5619: LD_STRING D4-JMM-2
5621: PPUSH
5622: CALL_OW 88
5626: IFFALSE 5640
// Say ( Den , D4-Den-2 ) ;
5628: LD_EXP 13
5632: PPUSH
5633: LD_STRING D4-Den-2
5635: PPUSH
5636: CALL_OW 88
// DialogueOff ;
5640: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
5644: LD_STRING M2
5646: PPUSH
5647: CALL_OW 337
// SetTech ( tech_Radar , you , state_enabled ) ;
5651: LD_INT 6
5653: PPUSH
5654: LD_EXP 1
5658: PPUSH
5659: LD_INT 1
5661: PPUSH
5662: CALL_OW 322
// SetRestrict ( b_lab_half , you , state_enabled ) ;
5666: LD_INT 7
5668: PPUSH
5669: LD_EXP 1
5673: PPUSH
5674: LD_INT 1
5676: PPUSH
5677: CALL_OW 324
// SetRestrict ( b_lab_opto , you , state_enabled ) ;
5681: LD_INT 15
5683: PPUSH
5684: LD_EXP 1
5688: PPUSH
5689: LD_INT 1
5691: PPUSH
5692: CALL_OW 324
// zasilka_landed := true ;
5696: LD_ADDR_EXP 44
5700: PUSH
5701: LD_INT 1
5703: ST_TO_ADDR
// if difficulty <= 2 then
5704: LD_OWVAR 67
5708: PUSH
5709: LD_INT 2
5711: LESSEQUAL
5712: IFFALSE 5800
// begin wait ( Rand ( 0 0$50 , 1 1$30 ) ) ;
5714: LD_INT 1750
5716: PPUSH
5717: LD_INT 3150
5719: PPUSH
5720: CALL_OW 12
5724: PPUSH
5725: CALL_OW 67
// CreateCratesXYR ( 5 , x , y , 10 , true ) ;
5729: LD_INT 5
5731: PPUSH
5732: LD_VAR 0 3
5736: PPUSH
5737: LD_VAR 0 4
5741: PPUSH
5742: LD_INT 10
5744: PPUSH
5745: LD_INT 1
5747: PPUSH
5748: CALL_OW 56
// if difficulty <= 1 then
5752: LD_OWVAR 67
5756: PUSH
5757: LD_INT 1
5759: LESSEQUAL
5760: IFFALSE 5800
// begin wait ( Rand ( 0 0$30 , 1 1$0 ) ) ;
5762: LD_INT 1050
5764: PPUSH
5765: LD_INT 2100
5767: PPUSH
5768: CALL_OW 12
5772: PPUSH
5773: CALL_OW 67
// CreateCratesXYR ( 5 , x , y , 10 , true ) ;
5777: LD_INT 5
5779: PPUSH
5780: LD_VAR 0 3
5784: PPUSH
5785: LD_VAR 0 4
5789: PPUSH
5790: LD_INT 10
5792: PPUSH
5793: LD_INT 1
5795: PPUSH
5796: CALL_OW 56
// end ; end ; end ;
5800: PPOPN 5
5802: END
// every 0 0$3.0 trigger attacking and see_any ( you , oma ) do var dia1 , kdo1 , kdo2 , kdo3 , cvidi ;
5803: LD_EXP 38
5807: PUSH
5808: LD_EXP 1
5812: PPUSH
5813: LD_EXP 7
5817: PPUSH
5818: CALL 13786 0 2
5822: AND
5823: IFFALSE 6381
5825: GO 5827
5827: DISABLE
5828: LD_INT 0
5830: PPUSH
5831: PPUSH
5832: PPUSH
5833: PPUSH
5834: PPUSH
// begin while cvidi < 5 do
5835: LD_VAR 0 5
5839: PUSH
5840: LD_INT 5
5842: LESS
5843: IFFALSE 5893
// begin while see_any ( you , oma ) do
5845: LD_EXP 1
5849: PPUSH
5850: LD_EXP 7
5854: PPUSH
5855: CALL 13786 0 2
5859: IFFALSE 5884
// begin Wait ( 0 0$1 ) ;
5861: LD_INT 35
5863: PPUSH
5864: CALL_OW 67
// cvidi := cvidi + 1 ;
5868: LD_ADDR_VAR 0 5
5872: PUSH
5873: LD_VAR 0 5
5877: PUSH
5878: LD_INT 1
5880: PLUS
5881: ST_TO_ADDR
// end ;
5882: GO 5845
// Wait ( 0 0$1 ) ;
5884: LD_INT 35
5886: PPUSH
5887: CALL_OW 67
// end ;
5891: GO 5835
// for dia1 := 1 to 5 do
5893: LD_ADDR_VAR 0 1
5897: PUSH
5898: DOUBLE
5899: LD_INT 1
5901: DEC
5902: ST_TO_ADDR
5903: LD_INT 5
5905: PUSH
5906: FOR_TO
5907: IFFALSE 5943
// begin while see_any ( you , oma ) do
5909: LD_EXP 1
5913: PPUSH
5914: LD_EXP 7
5918: PPUSH
5919: CALL 13786 0 2
5923: IFFALSE 5934
// Wait ( 0 0$1 ) ;
5925: LD_INT 35
5927: PPUSH
5928: CALL_OW 67
5932: GO 5909
// Wait ( 0 0$1 ) ;
5934: LD_INT 35
5936: PPUSH
5937: CALL_OW 67
// end ;
5941: GO 5906
5943: POP
5944: POP
// if IsLive ( Lisa ) then
5945: LD_EXP 14
5949: PPUSH
5950: CALL_OW 300
5954: IFFALSE 6073
// begin kdo1 := WhoSayAny ( not_char , you , sex_male , 0 , 0 ) ;
5956: LD_ADDR_VAR 0 2
5960: PUSH
5961: LD_EXP 48
5965: PPUSH
5966: LD_EXP 1
5970: PPUSH
5971: LD_INT 1
5973: PPUSH
5974: LD_INT 0
5976: PPUSH
5977: LD_INT 0
5979: PPUSH
5980: CALL 14889 0 5
5984: ST_TO_ADDR
// DialogueOn ;
5985: CALL_OW 6
// if Say ( kdo1 , D5a-Sol1-1 ) then
5989: LD_VAR 0 2
5993: PPUSH
5994: LD_STRING D5a-Sol1-1
5996: PPUSH
5997: CALL_OW 88
6001: IFFALSE 6015
// Say ( Lisa , D5a-Lisa-1 ) ;
6003: LD_EXP 14
6007: PPUSH
6008: LD_STRING D5a-Lisa-1
6010: PPUSH
6011: CALL_OW 88
// if Say ( kdo1 , D5a-Sol1-2 ) then
6015: LD_VAR 0 2
6019: PPUSH
6020: LD_STRING D5a-Sol1-2
6022: PPUSH
6023: CALL_OW 88
6027: IFFALSE 6041
// Say ( Lisa , D5a-Lisa-2 ) ;
6029: LD_EXP 14
6033: PPUSH
6034: LD_STRING D5a-Lisa-2
6036: PPUSH
6037: CALL_OW 88
// if Say ( kdo1 , D5a-Sol1-3 ) then
6041: LD_VAR 0 2
6045: PPUSH
6046: LD_STRING D5a-Sol1-3
6048: PPUSH
6049: CALL_OW 88
6053: IFFALSE 6067
// Say ( Lisa , D5a-Lisa-3 ) ;
6055: LD_EXP 14
6059: PPUSH
6060: LD_STRING D5a-Lisa-3
6062: PPUSH
6063: CALL_OW 88
// DialogueOff ;
6067: CALL_OW 7
// end else
6071: GO 6373
// begin DialogueOn ;
6073: CALL_OW 6
// kdo1 := WhoSayAny ( not_char , you , sex_male , 0 , 1 ) ;
6077: LD_ADDR_VAR 0 2
6081: PUSH
6082: LD_EXP 48
6086: PPUSH
6087: LD_EXP 1
6091: PPUSH
6092: LD_INT 1
6094: PPUSH
6095: LD_INT 0
6097: PPUSH
6098: LD_INT 1
6100: PPUSH
6101: CALL 14889 0 5
6105: ST_TO_ADDR
// kdo2 := WhoSayAny ( not_char , you , sex_male , 0 , 2 ) ;
6106: LD_ADDR_VAR 0 3
6110: PUSH
6111: LD_EXP 48
6115: PPUSH
6116: LD_EXP 1
6120: PPUSH
6121: LD_INT 1
6123: PPUSH
6124: LD_INT 0
6126: PPUSH
6127: LD_INT 2
6129: PPUSH
6130: CALL 14889 0 5
6134: ST_TO_ADDR
// kdo3 := WhoSayAny ( not_char , you , sex_female , 0 , 1 ) ;
6135: LD_ADDR_VAR 0 4
6139: PUSH
6140: LD_EXP 48
6144: PPUSH
6145: LD_EXP 1
6149: PPUSH
6150: LD_INT 2
6152: PPUSH
6153: LD_INT 0
6155: PPUSH
6156: LD_INT 1
6158: PPUSH
6159: CALL 14889 0 5
6163: ST_TO_ADDR
// if Say ( kdo1 , D5-Sol1-1 ) then
6164: LD_VAR 0 2
6168: PPUSH
6169: LD_STRING D5-Sol1-1
6171: PPUSH
6172: CALL_OW 88
6176: IFFALSE 6205
// if not Say ( kdo2 , D5-Sol2-1 ) then
6178: LD_VAR 0 3
6182: PPUSH
6183: LD_STRING D5-Sol2-1
6185: PPUSH
6186: CALL_OW 88
6190: NOT
6191: IFFALSE 6205
// Say ( kdo3 , D5-FSol2-1 ) ;
6193: LD_VAR 0 4
6197: PPUSH
6198: LD_STRING D5-FSol2-1
6200: PPUSH
6201: CALL_OW 88
// if Say ( kdo1 , D5-Sol1-2 ) then
6205: LD_VAR 0 2
6209: PPUSH
6210: LD_STRING D5-Sol1-2
6212: PPUSH
6213: CALL_OW 88
6217: IFFALSE 6246
// if not Say ( kdo2 , D5-Sol2-2 ) then
6219: LD_VAR 0 3
6223: PPUSH
6224: LD_STRING D5-Sol2-2
6226: PPUSH
6227: CALL_OW 88
6231: NOT
6232: IFFALSE 6246
// Say ( kdo3 , D5-FSol2-2 ) ;
6234: LD_VAR 0 4
6238: PPUSH
6239: LD_STRING D5-FSol2-2
6241: PPUSH
6242: CALL_OW 88
// if Say ( kdo1 , D5-Sol1-3 ) then
6246: LD_VAR 0 2
6250: PPUSH
6251: LD_STRING D5-Sol1-3
6253: PPUSH
6254: CALL_OW 88
6258: IFFALSE 6287
// if not Say ( kdo2 , D5-Sol2-3 ) then
6260: LD_VAR 0 3
6264: PPUSH
6265: LD_STRING D5-Sol2-3
6267: PPUSH
6268: CALL_OW 88
6272: NOT
6273: IFFALSE 6287
// Say ( kdo3 , D5-FSol2-3 ) ;
6275: LD_VAR 0 4
6279: PPUSH
6280: LD_STRING D5-FSol2-3
6282: PPUSH
6283: CALL_OW 88
// if Say ( kdo1 , D5-Sol1-4 ) then
6287: LD_VAR 0 2
6291: PPUSH
6292: LD_STRING D5-Sol1-4
6294: PPUSH
6295: CALL_OW 88
6299: IFFALSE 6328
// if not Say ( kdo2 , D5-Sol2-4 ) then
6301: LD_VAR 0 3
6305: PPUSH
6306: LD_STRING D5-Sol2-4
6308: PPUSH
6309: CALL_OW 88
6313: NOT
6314: IFFALSE 6328
// Say ( kdo3 , D5-FSol2-4 ) ;
6316: LD_VAR 0 4
6320: PPUSH
6321: LD_STRING D5-FSol2-4
6323: PPUSH
6324: CALL_OW 88
// if Say ( kdo1 , D5-Sol1-5 ) then
6328: LD_VAR 0 2
6332: PPUSH
6333: LD_STRING D5-Sol1-5
6335: PPUSH
6336: CALL_OW 88
6340: IFFALSE 6369
// if not Say ( kdo2 , D5-Sol2-5 ) then
6342: LD_VAR 0 3
6346: PPUSH
6347: LD_STRING D5-Sol2-5
6349: PPUSH
6350: CALL_OW 88
6354: NOT
6355: IFFALSE 6369
// Say ( kdo3 , D5-FSol2-5 ) ;
6357: LD_VAR 0 4
6361: PPUSH
6362: LD_STRING D5-FSol2-5
6364: PPUSH
6365: CALL_OW 88
// DialogueOff ;
6369: CALL_OW 7
// end ; denis_can_come := true ;
6373: LD_ADDR_EXP 45
6377: PUSH
6378: LD_INT 1
6380: ST_TO_ADDR
// end ;
6381: PPOPN 5
6383: END
// var den_uz_ochocil ; on ApemanTamed ( ktery , kym ) do begin if ( GetSide ( kym ) = you ) then
6384: LD_VAR 0 2
6388: PPUSH
6389: CALL_OW 255
6393: PUSH
6394: LD_EXP 1
6398: EQUAL
6399: IFFALSE 6648
// begin opic := opic + 1 ;
6401: LD_ADDR_EXP 40
6405: PUSH
6406: LD_EXP 40
6410: PUSH
6411: LD_INT 1
6413: PLUS
6414: ST_TO_ADDR
// if kym = Den and not den_uz_ochocil then
6415: LD_VAR 0 2
6419: PUSH
6420: LD_EXP 13
6424: EQUAL
6425: PUSH
6426: LD_LOC 4
6430: NOT
6431: AND
6432: IFFALSE 6464
// begin TalkOn ;
6434: CALL 14735 0 0
// Say ( Den , D7a-Den-1 ) ;
6438: LD_EXP 13
6442: PPUSH
6443: LD_STRING D7a-Den-1
6445: PPUSH
6446: CALL_OW 88
// TalkOff ;
6450: CALL 14743 0 0
// den_uz_ochocil := true ;
6454: LD_ADDR_LOC 4
6458: PUSH
6459: LD_INT 1
6461: ST_TO_ADDR
// end else
6462: GO 6590
// if not first_ape then
6464: LD_EXP 30
6468: NOT
6469: IFFALSE 6590
// begin if kym = Glad then
6471: LD_VAR 0 2
6475: PUSH
6476: LD_EXP 11
6480: EQUAL
6481: IFFALSE 6505
// begin TalkOn ;
6483: CALL 14735 0 0
// Say ( Glad , D7b-Glad-1 ) ;
6487: LD_EXP 11
6491: PPUSH
6492: LD_STRING D7b-Glad-1
6494: PPUSH
6495: CALL_OW 88
// TalkOff ;
6499: CALL 14743 0 0
// end else
6503: GO 6590
// begin if GetSex ( kym ) = sex_male then
6505: LD_VAR 0 2
6509: PPUSH
6510: CALL_OW 258
6514: PUSH
6515: LD_INT 1
6517: EQUAL
6518: IFFALSE 6556
// begin TalkOn ;
6520: CALL 14735 0 0
// SayAny ( not_char , D7c-Sci1-1 , you , sex_male , class_scientistic , 0 ) ;
6524: LD_EXP 48
6528: PPUSH
6529: LD_STRING D7c-Sci1-1
6531: PPUSH
6532: LD_EXP 1
6536: PPUSH
6537: LD_INT 1
6539: PPUSH
6540: LD_INT 4
6542: PPUSH
6543: LD_INT 0
6545: PPUSH
6546: CALL 14809 0 6
// TalkOff ;
6550: CALL 14743 0 0
// end else
6554: GO 6590
// begin TalkOn ;
6556: CALL 14735 0 0
// SayAny ( not_char , D7c-FSci1-1 , you , sex_female , class_scientistic , 0 ) ;
6560: LD_EXP 48
6564: PPUSH
6565: LD_STRING D7c-FSci1-1
6567: PPUSH
6568: LD_EXP 1
6572: PPUSH
6573: LD_INT 2
6575: PPUSH
6576: LD_INT 4
6578: PPUSH
6579: LD_INT 0
6581: PPUSH
6582: CALL 14809 0 6
// TalkOff ;
6586: CALL 14743 0 0
// end ; end ; end ; if not first_ape then
6590: LD_EXP 30
6594: NOT
6595: IFFALSE 6648
// begin first_ape := true ;
6597: LD_ADDR_EXP 30
6601: PUSH
6602: LD_INT 1
6604: ST_TO_ADDR
// if kym <> Glad and IsLive ( Glad ) then
6605: LD_VAR 0 2
6609: PUSH
6610: LD_EXP 11
6614: NONEQUAL
6615: PUSH
6616: LD_EXP 11
6620: PPUSH
6621: CALL_OW 300
6625: AND
6626: IFFALSE 6648
// begin TalkOn ;
6628: CALL 14735 0 0
// Say ( Glad , D7c-Glad-1 ) ;
6632: LD_EXP 11
6636: PPUSH
6637: LD_STRING D7c-Glad-1
6639: PPUSH
6640: CALL_OW 88
// TalkOff ;
6644: CALL 14743 0 0
// end ; end ; end ; end ;
6648: PPOPN 2
6650: END
// every 0 0$2 trigger not FilterAllUnits ( [ [ f_side , you ] , [ f_see , arabians ] ] ) and GetDistUnits ( NearestUnitToUnit ( UnitFilter ( apemans , [ f_side , you ] ) , Lisa ) , Lisa ) < 6 do
6651: LD_INT 22
6653: PUSH
6654: LD_EXP 1
6658: PUSH
6659: EMPTY
6660: LIST
6661: LIST
6662: PUSH
6663: LD_INT 101
6665: PUSH
6666: LD_EXP 4
6670: PUSH
6671: EMPTY
6672: LIST
6673: LIST
6674: PUSH
6675: EMPTY
6676: LIST
6677: LIST
6678: PPUSH
6679: CALL_OW 69
6683: NOT
6684: PUSH
6685: LD_EXP 6
6689: PPUSH
6690: LD_INT 22
6692: PUSH
6693: LD_EXP 1
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PPUSH
6702: CALL_OW 72
6706: PPUSH
6707: LD_EXP 14
6711: PPUSH
6712: CALL_OW 74
6716: PPUSH
6717: LD_EXP 14
6721: PPUSH
6722: CALL_OW 296
6726: PUSH
6727: LD_INT 6
6729: LESS
6730: AND
6731: IFFALSE 6756
6733: GO 6735
6735: DISABLE
// begin TalkOn ;
6736: CALL 14735 0 0
// Say ( Lisa , D8-Lisa-1 ) ;
6740: LD_EXP 14
6744: PPUSH
6745: LD_STRING D8-Lisa-1
6747: PPUSH
6748: CALL_OW 88
// TalkOff ;
6752: CALL 14743 0 0
// end ;
6756: END
// every 0 0$10 trigger cil_mit_1_ape_eng_splnen do var qr ;
6757: LD_EXP 41
6761: IFFALSE 6804
6763: GO 6765
6765: DISABLE
6766: LD_INT 0
6768: PPUSH
// begin qr := Query ( Q2 ) ;
6769: LD_ADDR_VAR 0 1
6773: PUSH
6774: LD_STRING Q2
6776: PPUSH
6777: CALL_OW 97
6781: ST_TO_ADDR
// end_the_mission_allowed := true ;
6782: LD_ADDR_OWVAR 57
6786: PUSH
6787: LD_INT 1
6789: ST_TO_ADDR
// if qr = 1 then
6790: LD_VAR 0 1
6794: PUSH
6795: LD_INT 1
6797: EQUAL
6798: IFFALSE 6804
// begin Vyhra ;
6800: CALL 3191 0 0
// end ; end ; end_of_file
6804: PPOPN 1
6806: END
// export depot , laboratore , budovy ; on BuildingComplete ( build ) do begin budovy := budovy union build ;
6807: LD_ADDR_EXP 63
6811: PUSH
6812: LD_EXP 63
6816: PUSH
6817: LD_VAR 0 1
6821: UNION
6822: ST_TO_ADDR
// if GetBType ( build ) = b_lab then
6823: LD_VAR 0 1
6827: PPUSH
6828: CALL_OW 266
6832: PUSH
6833: LD_INT 6
6835: EQUAL
6836: IFFALSE 6854
// laboratore := laboratore union build ;
6838: LD_ADDR_EXP 62
6842: PUSH
6843: LD_EXP 62
6847: PUSH
6848: LD_VAR 0 1
6852: UNION
6853: ST_TO_ADDR
// if GetBType ( build ) = b_depot then
6854: LD_VAR 0 1
6858: PPUSH
6859: CALL_OW 266
6863: PUSH
6864: LD_INT 0
6866: EQUAL
6867: IFFALSE 6891
// begin depot := build ;
6869: LD_ADDR_EXP 61
6873: PUSH
6874: LD_VAR 0 1
6878: ST_TO_ADDR
// SetBName ( build , delta ) ;
6879: LD_VAR 0 1
6883: PPUSH
6884: LD_STRING delta
6886: PPUSH
6887: CALL_OW 500
// end ; if GetBType ( build ) = b_workshop then
6891: LD_VAR 0 1
6895: PPUSH
6896: CALL_OW 266
6900: PUSH
6901: LD_INT 2
6903: EQUAL
6904: IFFALSE 6913
// MyHint ( Recycle ) ;
6906: LD_STRING Recycle
6908: PPUSH
6909: CALL 15083 0 1
// if GetBType ( build ) = b_ext_radar then
6913: LD_VAR 0 1
6917: PPUSH
6918: CALL_OW 266
6922: PUSH
6923: LD_INT 20
6925: EQUAL
6926: IFFALSE 6935
// MyHint ( Radar ) ;
6928: LD_STRING Radar
6930: PPUSH
6931: CALL 15083 0 1
// end ;
6935: PPOPN 1
6937: END
// on UnitDestroyed ( un ) do begin if un in budovy then
6938: LD_VAR 0 1
6942: PUSH
6943: LD_EXP 63
6947: IN
6948: IFFALSE 6966
// budovy := budovy diff un ;
6950: LD_ADDR_EXP 63
6954: PUSH
6955: LD_EXP 63
6959: PUSH
6960: LD_VAR 0 1
6964: DIFF
6965: ST_TO_ADDR
// if un in laboratore then
6966: LD_VAR 0 1
6970: PUSH
6971: LD_EXP 62
6975: IN
6976: IFFALSE 6994
// laboratore := laboratore diff un ;
6978: LD_ADDR_EXP 62
6982: PUSH
6983: LD_EXP 62
6987: PUSH
6988: LD_VAR 0 1
6992: DIFF
6993: ST_TO_ADDR
// if un in tvoji_lidi then
6994: LD_VAR 0 1
6998: PUSH
6999: LD_EXP 47
7003: IN
7004: IFFALSE 7036
// begin tvoji_lidi := tvoji_lidi diff un ;
7006: LD_ADDR_EXP 47
7010: PUSH
7011: LD_EXP 47
7015: PUSH
7016: LD_VAR 0 1
7020: DIFF
7021: ST_TO_ADDR
// ztraty := ztraty + 1 ;
7022: LD_ADDR_EXP 50
7026: PUSH
7027: LD_EXP 50
7031: PUSH
7032: LD_INT 1
7034: PLUS
7035: ST_TO_ADDR
// end ; if un in oma then
7036: LD_VAR 0 1
7040: PUSH
7041: LD_EXP 7
7045: IN
7046: IFFALSE 7064
// oma := oma diff un ;
7048: LD_ADDR_EXP 7
7052: PUSH
7053: LD_EXP 7
7057: PUSH
7058: LD_VAR 0 1
7062: DIFF
7063: ST_TO_ADDR
// if un in arabs_cars then
7064: LD_VAR 0 1
7068: PUSH
7069: LD_EXP 9
7073: IN
7074: IFFALSE 7092
// arabs_cars := arabs_cars diff un ;
7076: LD_ADDR_EXP 9
7080: PUSH
7081: LD_EXP 9
7085: PUSH
7086: LD_VAR 0 1
7090: DIFF
7091: ST_TO_ADDR
// if un in apemans then
7092: LD_VAR 0 1
7096: PUSH
7097: LD_EXP 6
7101: IN
7102: IFFALSE 7120
// apemans := apemans diff un ;
7104: LD_ADDR_EXP 6
7108: PUSH
7109: LD_EXP 6
7113: PUSH
7114: LD_VAR 0 1
7118: DIFF
7119: ST_TO_ADDR
// if un = JMM then
7120: LD_VAR 0 1
7124: PUSH
7125: LD_EXP 10
7129: EQUAL
7130: IFFALSE 7142
// begin disable ( 0 ) ;
7132: LD_INT 0
7134: DISABLE_MARKED
// YouLost ( JMM ) ;
7135: LD_STRING JMM
7137: PPUSH
7138: CALL_OW 104
// end ; if UnitFilter ( un , [ [ f_side , you ] , [ f_nation , nation_nature ] ] ) then
7142: LD_VAR 0 1
7146: PPUSH
7147: LD_INT 22
7149: PUSH
7150: LD_EXP 1
7154: PUSH
7155: EMPTY
7156: LIST
7157: LIST
7158: PUSH
7159: LD_INT 23
7161: PUSH
7162: LD_INT 0
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: PUSH
7169: EMPTY
7170: LIST
7171: LIST
7172: PPUSH
7173: CALL_OW 72
7177: IFFALSE 7193
// begin opic := opic - 1 ;
7179: LD_ADDR_EXP 40
7183: PUSH
7184: LD_EXP 40
7188: PUSH
7189: LD_INT 1
7191: MINUS
7192: ST_TO_ADDR
// end ; end ;
7193: PPOPN 1
7195: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if origside = you then
7196: LD_VAR 0 3
7200: PUSH
7201: LD_EXP 1
7205: EQUAL
7206: IFFALSE 7239
// begin arabs_cars := arabs_cars union vehnew ;
7208: LD_ADDR_EXP 9
7212: PUSH
7213: LD_EXP 9
7217: PUSH
7218: LD_VAR 0 1
7222: UNION
7223: ST_TO_ADDR
// evade_shortest_way ( vehnew , false , true ) ;
7224: LD_VAR 0 1
7228: PPUSH
7229: LD_INT 0
7231: PPUSH
7232: LD_INT 1
7234: PPUSH
7235: CALL 12750 0 3
// end ; if origside = arabians then
7239: LD_VAR 0 3
7243: PUSH
7244: LD_EXP 4
7248: EQUAL
7249: IFFALSE 7267
// begin arabs_cars := arabs_cars diff vehold ;
7251: LD_ADDR_EXP 9
7255: PUSH
7256: LD_EXP 9
7260: PUSH
7261: LD_VAR 0 2
7265: DIFF
7266: ST_TO_ADDR
// end ; end ;
7267: PPOPN 4
7269: END
// every 0 0$10 do
7270: GO 7272
7272: DISABLE
// Randomize ;
7273: CALL_OW 10
7277: END
// every 0 0$10 trigger apemans < 5 do var op ;
7278: LD_EXP 6
7282: PUSH
7283: LD_INT 5
7285: LESS
7286: IFFALSE 7552
7288: GO 7290
7290: DISABLE
7291: LD_INT 0
7293: PPUSH
// begin InitUc ;
7294: CALL_OW 18
// InitHc ;
7298: CALL_OW 19
// uc_nation := nation_nature ;
7302: LD_ADDR_OWVAR 21
7306: PUSH
7307: LD_INT 0
7309: ST_TO_ADDR
// uc_side := 0 ;
7310: LD_ADDR_OWVAR 20
7314: PUSH
7315: LD_INT 0
7317: ST_TO_ADDR
// hc_class := class_apeman ;
7318: LD_ADDR_OWVAR 28
7322: PUSH
7323: LD_INT 12
7325: ST_TO_ADDR
// hc_agressivity := Rand ( - 5 , 10 ) ;
7326: LD_ADDR_OWVAR 35
7330: PUSH
7331: LD_INT 5
7333: NEG
7334: PPUSH
7335: LD_INT 10
7337: PPUSH
7338: CALL_OW 12
7342: ST_TO_ADDR
// hc_sex := Rand ( 1 , 2 ) ;
7343: LD_ADDR_OWVAR 27
7347: PUSH
7348: LD_INT 1
7350: PPUSH
7351: LD_INT 2
7353: PPUSH
7354: CALL_OW 12
7358: ST_TO_ADDR
// op := CreateHuman ;
7359: LD_ADDR_VAR 0 1
7363: PUSH
7364: CALL_OW 44
7368: ST_TO_ADDR
// case rand ( 1 , 4 ) of 1 :
7369: LD_INT 1
7371: PPUSH
7372: LD_INT 4
7374: PPUSH
7375: CALL_OW 12
7379: PUSH
7380: LD_INT 1
7382: DOUBLE
7383: EQUAL
7384: IFTRUE 7388
7386: GO 7412
7388: POP
// PlaceUnitXYR ( op , 16 , 1 , 5 , false ) ; 2 :
7389: LD_VAR 0 1
7393: PPUSH
7394: LD_INT 16
7396: PPUSH
7397: LD_INT 1
7399: PPUSH
7400: LD_INT 5
7402: PPUSH
7403: LD_INT 0
7405: PPUSH
7406: CALL_OW 50
7410: GO 7509
7412: LD_INT 2
7414: DOUBLE
7415: EQUAL
7416: IFTRUE 7420
7418: GO 7444
7420: POP
// PlaceUnitXYR ( op , 46 , 1 , 5 , false ) ; 3 :
7421: LD_VAR 0 1
7425: PPUSH
7426: LD_INT 46
7428: PPUSH
7429: LD_INT 1
7431: PPUSH
7432: LD_INT 5
7434: PPUSH
7435: LD_INT 0
7437: PPUSH
7438: CALL_OW 50
7442: GO 7509
7444: LD_INT 3
7446: DOUBLE
7447: EQUAL
7448: IFTRUE 7452
7450: GO 7476
7452: POP
// PlaceUnitXYR ( op , 1 , 23 , 5 , false ) ; 4 :
7453: LD_VAR 0 1
7457: PPUSH
7458: LD_INT 1
7460: PPUSH
7461: LD_INT 23
7463: PPUSH
7464: LD_INT 5
7466: PPUSH
7467: LD_INT 0
7469: PPUSH
7470: CALL_OW 50
7474: GO 7509
7476: LD_INT 4
7478: DOUBLE
7479: EQUAL
7480: IFTRUE 7484
7482: GO 7508
7484: POP
// PlaceUnitXYR ( op , 80 , 1 , 5 , false ) ; end ;
7485: LD_VAR 0 1
7489: PPUSH
7490: LD_INT 80
7492: PPUSH
7493: LD_INT 1
7495: PPUSH
7496: LD_INT 5
7498: PPUSH
7499: LD_INT 0
7501: PPUSH
7502: CALL_OW 50
7506: GO 7509
7508: POP
// apemans := apemans union op ;
7509: LD_ADDR_EXP 6
7513: PUSH
7514: LD_EXP 6
7518: PUSH
7519: LD_VAR 0 1
7523: UNION
7524: ST_TO_ADDR
// added_apes := added_apes + 1 ;
7525: LD_ADDR_EXP 52
7529: PUSH
7530: LD_EXP 52
7534: PUSH
7535: LD_INT 1
7537: PLUS
7538: ST_TO_ADDR
// if added_apes < max_added_apes then
7539: LD_EXP 52
7543: PUSH
7544: LD_EXP 53
7548: LESS
7549: IFFALSE 7552
// enable ;
7551: ENABLE
// end ; end_of_file
7552: PPOPN 1
7554: END
// var amici_v ; var amici_h ; var amici_b ; on DestinationUnreachable ( un ) do begin if GetSide ( un ) = arabians then
7555: LD_VAR 0 1
7559: PPUSH
7560: CALL_OW 255
7564: PUSH
7565: LD_EXP 4
7569: EQUAL
7570: IFFALSE 7653
// begin if attacking and laboratore then
7572: LD_EXP 38
7576: PUSH
7577: LD_EXP 62
7581: AND
7582: IFFALSE 7641
// begin ComAgressiveMove ( un , GetX ( laboratore [ 1 ] ) , GetY ( laboratore [ 1 ] ) ) ;
7584: LD_VAR 0 1
7588: PPUSH
7589: LD_EXP 62
7593: PUSH
7594: LD_INT 1
7596: ARRAY
7597: PPUSH
7598: CALL_OW 250
7602: PPUSH
7603: LD_EXP 62
7607: PUSH
7608: LD_INT 1
7610: ARRAY
7611: PPUSH
7612: CALL_OW 251
7616: PPUSH
7617: CALL_OW 114
// AddComAttackUnit ( un , laboratore [ 1 ] ) ;
7621: LD_VAR 0 1
7625: PPUSH
7626: LD_EXP 62
7630: PUSH
7631: LD_INT 1
7633: ARRAY
7634: PPUSH
7635: CALL_OW 175
// end else
7639: GO 7653
// ComMoveToArea ( un , border ) ;
7641: LD_VAR 0 1
7645: PPUSH
7646: LD_INT 7
7648: PPUSH
7649: CALL_OW 113
// end ; end ;
7653: PPOPN 1
7655: END
// every 0 0$50 do
7656: GO 7658
7658: DISABLE
// begin Wait ( wait_first_attack ) ;
7659: LD_EXP 59
7663: PPUSH
7664: CALL_OW 67
// attacky := attacky + 1 ;
7668: LD_ADDR_EXP 39
7672: PUSH
7673: LD_EXP 39
7677: PUSH
7678: LD_INT 1
7680: PLUS
7681: ST_TO_ADDR
// attacking := true ;
7682: LD_ADDR_EXP 38
7686: PUSH
7687: LD_INT 1
7689: ST_TO_ADDR
// F_first_attack ;
7690: CALL 9221 0 0
// oma := FilterAllUnits ( [ f_side , arabians ] ) ;
7694: LD_ADDR_EXP 7
7698: PUSH
7699: LD_INT 22
7701: PUSH
7702: LD_EXP 4
7706: PUSH
7707: EMPTY
7708: LIST
7709: LIST
7710: PPUSH
7711: CALL_OW 69
7715: ST_TO_ADDR
// end ;
7716: END
// every 0 0$1 do var i ;
7717: GO 7719
7719: DISABLE
7720: LD_INT 0
7722: PPUSH
// begin om := FilterAllUnits ( [ f_side , arabians ] ) ;
7723: LD_ADDR_EXP 8
7727: PUSH
7728: LD_INT 22
7730: PUSH
7731: LD_EXP 4
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PPUSH
7740: CALL_OW 69
7744: ST_TO_ADDR
// for i in om do
7745: LD_ADDR_VAR 0 1
7749: PUSH
7750: LD_EXP 8
7754: PUSH
7755: FOR_IN
7756: IFFALSE 7792
// if IsIdle ( i ) then
7758: LD_VAR 0 1
7762: PPUSH
7763: CALL_OW 316
7767: IFFALSE 7790
// begin RaiseSailEvent ( i ) ;
7769: LD_VAR 0 1
7773: PPUSH
7774: CALL_OW 427
// ComMoveToArea ( i , border ) ;
7778: LD_VAR 0 1
7782: PPUSH
7783: LD_INT 7
7785: PPUSH
7786: CALL_OW 113
// end ;
7790: GO 7755
7792: POP
7793: POP
// enable ;
7794: ENABLE
// end ;
7795: PPOPN 1
7797: END
// on SailEvent ( x ) do var k ;
7798: LD_INT 0
7800: PPUSH
// begin k := 0 ;
7801: LD_ADDR_VAR 0 2
7805: PUSH
7806: LD_INT 0
7808: ST_TO_ADDR
// while k < 3 and IsLive ( x ) do
7809: LD_VAR 0 2
7813: PUSH
7814: LD_INT 3
7816: LESS
7817: PUSH
7818: LD_VAR 0 1
7822: PPUSH
7823: CALL_OW 300
7827: AND
7828: IFFALSE 7864
// begin wait ( 0 0$1 ) ;
7830: LD_INT 35
7832: PPUSH
7833: CALL_OW 67
// if IsIdle ( x ) then
7837: LD_VAR 0 1
7841: PPUSH
7842: CALL_OW 316
7846: IFFALSE 7862
// k := k + 1 ;
7848: LD_ADDR_VAR 0 2
7852: PUSH
7853: LD_VAR 0 2
7857: PUSH
7858: LD_INT 1
7860: PLUS
7861: ST_TO_ADDR
// end ;
7862: GO 7809
// ComMoveToArea ( x , border ) ;
7864: LD_VAR 0 1
7868: PPUSH
7869: LD_INT 7
7871: PPUSH
7872: CALL_OW 113
// AddComWait ( x , 0 0$10 ) ;
7876: LD_VAR 0 1
7880: PPUSH
7881: LD_INT 350
7883: PPUSH
7884: CALL_OW 202
// if laboratore then
7888: LD_EXP 62
7892: IFFALSE 7931
// AddComAgressiveMove ( x , GetX ( laboratore [ 1 ] ) , GetY ( laboratore [ 1 ] ) ) ;
7894: LD_VAR 0 1
7898: PPUSH
7899: LD_EXP 62
7903: PUSH
7904: LD_INT 1
7906: ARRAY
7907: PPUSH
7908: CALL_OW 250
7912: PPUSH
7913: LD_EXP 62
7917: PUSH
7918: LD_INT 1
7920: ARRAY
7921: PPUSH
7922: CALL_OW 251
7926: PPUSH
7927: CALL_OW 174
// end ;
7931: PPOPN 2
7933: END
// export last_attack_was ; every 3 3$50.0 + 3 3$0 trigger budovy and not attacking do
7934: LD_EXP 63
7938: PUSH
7939: LD_EXP 38
7943: NOT
7944: AND
7945: IFFALSE 7975
7947: GO 7949
7949: DISABLE
// begin if difficulty = 1 then
7950: LD_OWVAR 67
7954: PUSH
7955: LD_INT 1
7957: EQUAL
7958: IFFALSE 7975
// begin last_attack_was := tick ;
7960: LD_ADDR_EXP 64
7964: PUSH
7965: LD_OWVAR 1
7969: ST_TO_ADDR
// WhichAttack ;
7970: CALL 8195 0 0
// enable ;
7974: ENABLE
// end ; end ;
7975: END
// every 3 3$10.0 + 2 2$0 trigger budovy and not attacking do
7976: LD_EXP 63
7980: PUSH
7981: LD_EXP 38
7985: NOT
7986: AND
7987: IFFALSE 8017
7989: GO 7991
7991: DISABLE
// begin if difficulty = 2 then
7992: LD_OWVAR 67
7996: PUSH
7997: LD_INT 2
7999: EQUAL
8000: IFFALSE 8017
// begin last_attack_was := tick ;
8002: LD_ADDR_EXP 64
8006: PUSH
8007: LD_OWVAR 1
8011: ST_TO_ADDR
// WhichAttack ;
8012: CALL 8195 0 0
// enable ;
8016: ENABLE
// end ; end ;
8017: END
// every 2 2$30.0 + 1 1$30 trigger budovy and not attacking do
8018: LD_EXP 63
8022: PUSH
8023: LD_EXP 38
8027: NOT
8028: AND
8029: IFFALSE 8059
8031: GO 8033
8033: DISABLE
// begin if difficulty = 3 then
8034: LD_OWVAR 67
8038: PUSH
8039: LD_INT 3
8041: EQUAL
8042: IFFALSE 8059
// begin last_attack_was := tick ;
8044: LD_ADDR_EXP 64
8048: PUSH
8049: LD_OWVAR 1
8053: ST_TO_ADDR
// WhichAttack ;
8054: CALL 8195 0 0
// enable ;
8058: ENABLE
// end ; end ;
8059: END
// function free_cars ; var i ; begin
8060: LD_INT 0
8062: PPUSH
8063: PPUSH
// for i in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , you ] ] ) do
8064: LD_ADDR_VAR 0 2
8068: PUSH
8069: LD_INT 21
8071: PUSH
8072: LD_INT 2
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: PUSH
8079: LD_INT 22
8081: PUSH
8082: LD_EXP 1
8086: PUSH
8087: EMPTY
8088: LIST
8089: LIST
8090: PUSH
8091: EMPTY
8092: LIST
8093: LIST
8094: PPUSH
8095: CALL_OW 69
8099: PUSH
8100: FOR_IN
8101: IFFALSE 8127
// begin if not IsDrivenBy ( i ) then
8103: LD_VAR 0 2
8107: PPUSH
8108: CALL_OW 311
8112: NOT
8113: IFFALSE 8125
// begin result := true ;
8115: LD_ADDR_VAR 0 1
8119: PUSH
8120: LD_INT 1
8122: ST_TO_ADDR
// break ;
8123: GO 8127
// end ; end ;
8125: GO 8100
8127: POP
8128: POP
// end ;
8129: LD_VAR 0 1
8133: RET
// function lonely ; begin
8134: LD_INT 0
8136: PPUSH
// result := FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_human ] , [ f_dist , depot , 16 ] ] ) ;
8137: LD_ADDR_VAR 0 1
8141: PUSH
8142: LD_INT 22
8144: PUSH
8145: LD_EXP 1
8149: PUSH
8150: EMPTY
8151: LIST
8152: LIST
8153: PUSH
8154: LD_INT 21
8156: PUSH
8157: LD_INT 1
8159: PUSH
8160: EMPTY
8161: LIST
8162: LIST
8163: PUSH
8164: LD_INT 91
8166: PUSH
8167: LD_EXP 61
8171: PUSH
8172: LD_INT 16
8174: PUSH
8175: EMPTY
8176: LIST
8177: LIST
8178: LIST
8179: PUSH
8180: EMPTY
8181: LIST
8182: LIST
8183: LIST
8184: PPUSH
8185: CALL_OW 69
8189: ST_TO_ADDR
// end ;
8190: LD_VAR 0 1
8194: RET
// function WhichAttack ; var l ; begin
8195: LD_INT 0
8197: PPUSH
8198: PPUSH
// attacky := attacky + 1 ;
8199: LD_ADDR_EXP 39
8203: PUSH
8204: LD_EXP 39
8208: PUSH
8209: LD_INT 1
8211: PLUS
8212: ST_TO_ADDR
// attacking := true ;
8213: LD_ADDR_EXP 38
8217: PUSH
8218: LD_INT 1
8220: ST_TO_ADDR
// l := lonely ;
8221: LD_ADDR_VAR 0 2
8225: PUSH
8226: CALL 8134 0 0
8230: ST_TO_ADDR
// case true of l :
8231: LD_INT 1
8233: PUSH
8234: LD_VAR 0 2
8238: DOUBLE
8239: EQUAL
8240: IFTRUE 8244
8242: GO 8256
8244: POP
// F_lonely_attack ( l ) ; free_cars and rand ( 1 , 3 ) = 1 :
8245: LD_VAR 0 2
8249: PPUSH
8250: CALL 11235 0 1
8254: GO 8327
8256: CALL 8060 0 0
8260: PUSH
8261: LD_INT 1
8263: PPUSH
8264: LD_INT 3
8266: PPUSH
8267: CALL_OW 12
8271: PUSH
8272: LD_INT 1
8274: EQUAL
8275: AND
8276: DOUBLE
8277: EQUAL
8278: IFTRUE 8282
8280: GO 8289
8282: POP
// F_thief_attack ; budovy and rand ( 1 , 2 ) = 1 :
8283: CALL 10491 0 0
8287: GO 8327
8289: LD_EXP 63
8293: PUSH
8294: LD_INT 1
8296: PPUSH
8297: LD_INT 2
8299: PPUSH
8300: CALL_OW 12
8304: PUSH
8305: LD_INT 1
8307: EQUAL
8308: AND
8309: DOUBLE
8310: EQUAL
8311: IFTRUE 8315
8313: GO 8322
8315: POP
// F_mine_attack ; else
8316: CALL 9755 0 0
8320: GO 8327
8322: POP
// F_next_attack ; end ;
8323: CALL 11588 0 0
// if attacky < utoku then
8327: LD_EXP 39
8331: PUSH
8332: LD_EXP 60
8336: LESS
8337: IFFALSE 8340
// enable ;
8339: ENABLE
// oma := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_human ] ] ) ;
8340: LD_ADDR_EXP 7
8344: PUSH
8345: LD_INT 22
8347: PUSH
8348: LD_EXP 4
8352: PUSH
8353: EMPTY
8354: LIST
8355: LIST
8356: PUSH
8357: LD_INT 21
8359: PUSH
8360: LD_INT 1
8362: PUSH
8363: EMPTY
8364: LIST
8365: LIST
8366: PUSH
8367: EMPTY
8368: LIST
8369: LIST
8370: PPUSH
8371: CALL_OW 69
8375: ST_TO_ADDR
// end ;
8376: LD_VAR 0 1
8380: RET
// every 0 0$1.0 do var i , a ;
8381: GO 8383
8383: DISABLE
8384: LD_INT 0
8386: PPUSH
8387: PPUSH
// begin oma := FilterAllUnits ( [ [ f_side , arabians ] , [ f_type , unit_human ] ] ) ;
8388: LD_ADDR_EXP 7
8392: PUSH
8393: LD_INT 22
8395: PUSH
8396: LD_EXP 4
8400: PUSH
8401: EMPTY
8402: LIST
8403: LIST
8404: PUSH
8405: LD_INT 21
8407: PUSH
8408: LD_INT 1
8410: PUSH
8411: EMPTY
8412: LIST
8413: LIST
8414: PUSH
8415: EMPTY
8416: LIST
8417: LIST
8418: PPUSH
8419: CALL_OW 69
8423: ST_TO_ADDR
// if oma then
8424: LD_EXP 7
8428: IFFALSE 8737
// begin a := oma [ rand ( 1 , oma ) ] ;
8430: LD_ADDR_VAR 0 2
8434: PUSH
8435: LD_EXP 7
8439: PUSH
8440: LD_INT 1
8442: PPUSH
8443: LD_EXP 7
8447: PPUSH
8448: CALL_OW 12
8452: ARRAY
8453: ST_TO_ADDR
// if ( tick - last_attack_was ) > 5 5$0 then
8454: LD_OWVAR 1
8458: PUSH
8459: LD_EXP 64
8463: MINUS
8464: PUSH
8465: LD_INT 10500
8467: GREATER
8468: IFFALSE 8520
// ComAttackUnit ( oma , NearestUnitToUnit ( FilterAllUnits ( [ f_side , you ] ) , oma [ Rand ( 1 , oma ) ] ) ) ;
8470: LD_EXP 7
8474: PPUSH
8475: LD_INT 22
8477: PUSH
8478: LD_EXP 1
8482: PUSH
8483: EMPTY
8484: LIST
8485: LIST
8486: PPUSH
8487: CALL_OW 69
8491: PPUSH
8492: LD_EXP 7
8496: PUSH
8497: LD_INT 1
8499: PPUSH
8500: LD_EXP 7
8504: PPUSH
8505: CALL_OW 12
8509: ARRAY
8510: PPUSH
8511: CALL_OW 74
8515: PPUSH
8516: CALL_OW 115
// if ( tick - last_attack_was ) > 7 7$0 then
8520: LD_OWVAR 1
8524: PUSH
8525: LD_EXP 64
8529: MINUS
8530: PUSH
8531: LD_INT 14700
8533: GREATER
8534: IFFALSE 8571
// evade_shortest_way_from_xy ( getx ( a ) , gety ( a ) , oma , true , true ) ;
8536: LD_VAR 0 2
8540: PPUSH
8541: CALL_OW 250
8545: PPUSH
8546: LD_VAR 0 2
8550: PPUSH
8551: CALL_OW 251
8555: PPUSH
8556: LD_EXP 7
8560: PPUSH
8561: LD_INT 1
8563: PPUSH
8564: LD_INT 1
8566: PPUSH
8567: CALL 12837 0 5
// for i in oma do
8571: LD_ADDR_VAR 0 1
8575: PUSH
8576: LD_EXP 7
8580: PUSH
8581: FOR_IN
8582: IFFALSE 8735
// begin if IsIdle ( i ) and IsInArea ( i , border ) then
8584: LD_VAR 0 1
8588: PPUSH
8589: CALL_OW 316
8593: PUSH
8594: LD_VAR 0 1
8598: PPUSH
8599: LD_INT 7
8601: PPUSH
8602: CALL_OW 308
8606: AND
8607: IFFALSE 8733
// begin if IsInUnit ( i ) then
8609: LD_VAR 0 1
8613: PPUSH
8614: CALL_OW 310
8618: IFFALSE 8663
// arabs_cars := arabs_cars union UnitFilter ( IsInUnit ( i ) , [ f_not , [ f_weapon , us_cargo_bay ] ] ) ;
8620: LD_ADDR_EXP 9
8624: PUSH
8625: LD_EXP 9
8629: PUSH
8630: LD_VAR 0 1
8634: PPUSH
8635: CALL_OW 310
8639: PPUSH
8640: LD_INT 3
8642: PUSH
8643: LD_INT 34
8645: PUSH
8646: LD_INT 12
8648: PUSH
8649: EMPTY
8650: LIST
8651: LIST
8652: PUSH
8653: EMPTY
8654: LIST
8655: LIST
8656: PPUSH
8657: CALL_OW 72
8661: UNION
8662: ST_TO_ADDR
// RemoveUnit ( IsInUnit ( i ) ) ;
8663: LD_VAR 0 1
8667: PPUSH
8668: CALL_OW 310
8672: PPUSH
8673: CALL_OW 64
// SetLives ( IsInUnit ( i ) , 1000 ) ;
8677: LD_VAR 0 1
8681: PPUSH
8682: CALL_OW 310
8686: PPUSH
8687: LD_INT 1000
8689: PPUSH
8690: CALL_OW 234
// DestroyUnit ( i ) ;
8694: LD_VAR 0 1
8698: PPUSH
8699: CALL_OW 65
// oma := oma diff i ;
8703: LD_ADDR_EXP 7
8707: PUSH
8708: LD_EXP 7
8712: PUSH
8713: LD_VAR 0 1
8717: DIFF
8718: ST_TO_ADDR
// away_from_last_attack := away_from_last_attack + 1 ;
8719: LD_ADDR_EXP 32
8723: PUSH
8724: LD_EXP 32
8728: PUSH
8729: LD_INT 1
8731: PLUS
8732: ST_TO_ADDR
// end ; end ;
8733: GO 8581
8735: POP
8736: POP
// end ; enable ;
8737: ENABLE
// end ;
8738: PPOPN 2
8740: END
// every 0 0$2 trigger attacking do var aro , ar , uso , us , a , i ;
8741: LD_EXP 38
8745: IFFALSE 9007
8747: GO 8749
8749: DISABLE
8750: LD_INT 0
8752: PPUSH
8753: PPUSH
8754: PPUSH
8755: PPUSH
8756: PPUSH
8757: PPUSH
// begin aro := GetLives ( FilterAllUnits ( [ f_side , arabians ] ) ) ;
8758: LD_ADDR_VAR 0 1
8762: PUSH
8763: LD_INT 22
8765: PUSH
8766: LD_EXP 4
8770: PUSH
8771: EMPTY
8772: LIST
8773: LIST
8774: PPUSH
8775: CALL_OW 69
8779: PPUSH
8780: CALL_OW 256
8784: ST_TO_ADDR
// uso := GetLives ( FilterAllUnits ( [ f_side , you ] ) ) ;
8785: LD_ADDR_VAR 0 3
8789: PUSH
8790: LD_INT 22
8792: PUSH
8793: LD_EXP 1
8797: PUSH
8798: EMPTY
8799: LIST
8800: LIST
8801: PPUSH
8802: CALL_OW 69
8806: PPUSH
8807: CALL_OW 256
8811: ST_TO_ADDR
// wait ( 0 0$2 ) ;
8812: LD_INT 70
8814: PPUSH
8815: CALL_OW 67
// while attacking do
8819: LD_EXP 38
8823: IFFALSE 9006
// begin ar := GetLives ( FilterAllUnits ( [ f_side , arabians ] ) ) ;
8825: LD_ADDR_VAR 0 2
8829: PUSH
8830: LD_INT 22
8832: PUSH
8833: LD_EXP 4
8837: PUSH
8838: EMPTY
8839: LIST
8840: LIST
8841: PPUSH
8842: CALL_OW 69
8846: PPUSH
8847: CALL_OW 256
8851: ST_TO_ADDR
// us := GetLives ( FilterAllUnits ( [ f_side , you ] ) ) ;
8852: LD_ADDR_VAR 0 4
8856: PUSH
8857: LD_INT 22
8859: PUSH
8860: LD_EXP 1
8864: PUSH
8865: EMPTY
8866: LIST
8867: LIST
8868: PPUSH
8869: CALL_OW 69
8873: PPUSH
8874: CALL_OW 256
8878: ST_TO_ADDR
// if ( aro - ar ) * 1.2 < uso - us then
8879: LD_VAR 0 1
8883: PUSH
8884: LD_VAR 0 2
8888: MINUS
8889: PUSH
8890: LD_REAL  1.20000000000000E+0000
8893: MUL
8894: PUSH
8895: LD_VAR 0 3
8899: PUSH
8900: LD_VAR 0 4
8904: MINUS
8905: LESS
8906: IFFALSE 8977
// begin a := FilterAllUnits ( [ f_side , arabians ] ) ;
8908: LD_ADDR_VAR 0 5
8912: PUSH
8913: LD_INT 22
8915: PUSH
8916: LD_EXP 4
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PPUSH
8925: CALL_OW 69
8929: ST_TO_ADDR
// for i in a do
8930: LD_ADDR_VAR 0 6
8934: PUSH
8935: LD_VAR 0 5
8939: PUSH
8940: FOR_IN
8941: IFFALSE 8975
// if GetLives ( i ) < 400 then
8943: LD_VAR 0 6
8947: PPUSH
8948: CALL_OW 256
8952: PUSH
8953: LD_INT 400
8955: LESS
8956: IFFALSE 8973
// evade_shortest_way ( i , false , true ) ;
8958: LD_VAR 0 6
8962: PPUSH
8963: LD_INT 0
8965: PPUSH
8966: LD_INT 1
8968: PPUSH
8969: CALL 12750 0 3
8973: GO 8940
8975: POP
8976: POP
// end ; wait ( 0 0$0.5 ) ;
8977: LD_INT 18
8979: PPUSH
8980: CALL_OW 67
// aro := ar ;
8984: LD_ADDR_VAR 0 1
8988: PUSH
8989: LD_VAR 0 2
8993: ST_TO_ADDR
// uso := us ;
8994: LD_ADDR_VAR 0 3
8998: PUSH
8999: LD_VAR 0 4
9003: ST_TO_ADDR
// end ;
9004: GO 8819
// enable ;
9006: ENABLE
// end ;
9007: PPOPN 6
9009: END
// every 0 0$1.0 trigger not oma do
9010: LD_EXP 7
9014: NOT
9015: IFFALSE 9069
9017: GO 9019
9019: DISABLE
// begin attacking := false ;
9020: LD_ADDR_EXP 38
9024: PUSH
9025: LD_INT 0
9027: ST_TO_ADDR
// first_attack := false ;
9028: LD_ADDR_EXP 33
9032: PUSH
9033: LD_INT 0
9035: ST_TO_ADDR
// mine_attack := false ;
9036: LD_ADDR_EXP 34
9040: PUSH
9041: LD_INT 0
9043: ST_TO_ADDR
// thief_attack := false ;
9044: LD_ADDR_EXP 35
9048: PUSH
9049: LD_INT 0
9051: ST_TO_ADDR
// lonely_attack := false ;
9052: LD_ADDR_EXP 36
9056: PUSH
9057: LD_INT 0
9059: ST_TO_ADDR
// next_attack := false ;
9060: LD_ADDR_EXP 37
9064: PUSH
9065: LD_INT 0
9067: ST_TO_ADDR
// enable ;
9068: ENABLE
// end ;
9069: END
// every 0 0$1 do var a ;
9070: GO 9072
9072: DISABLE
9073: LD_INT 0
9075: PPUSH
// begin a :=  ;
9076: LD_ADDR_VAR 0 1
9080: PUSH
9081: LD_STRING 
9083: ST_TO_ADDR
// if attacking then
9084: LD_EXP 38
9088: IFFALSE 9104
// a := a &  attacking ;
9090: LD_ADDR_VAR 0 1
9094: PUSH
9095: LD_VAR 0 1
9099: PUSH
9100: LD_STRING  attacking
9102: STR
9103: ST_TO_ADDR
// if first_attack then
9104: LD_EXP 33
9108: IFFALSE 9124
// a := a &  first ;
9110: LD_ADDR_VAR 0 1
9114: PUSH
9115: LD_VAR 0 1
9119: PUSH
9120: LD_STRING  first
9122: STR
9123: ST_TO_ADDR
// if mine_attack then
9124: LD_EXP 34
9128: IFFALSE 9144
// a := a &  mine ;
9130: LD_ADDR_VAR 0 1
9134: PUSH
9135: LD_VAR 0 1
9139: PUSH
9140: LD_STRING  mine
9142: STR
9143: ST_TO_ADDR
// if thief_attack then
9144: LD_EXP 35
9148: IFFALSE 9164
// a := a &  thief ;
9150: LD_ADDR_VAR 0 1
9154: PUSH
9155: LD_VAR 0 1
9159: PUSH
9160: LD_STRING  thief
9162: STR
9163: ST_TO_ADDR
// if lonely_attack then
9164: LD_EXP 36
9168: IFFALSE 9184
// a := a &  lonely ;
9170: LD_ADDR_VAR 0 1
9174: PUSH
9175: LD_VAR 0 1
9179: PUSH
9180: LD_STRING  lonely
9182: STR
9183: ST_TO_ADDR
// if next_attack then
9184: LD_EXP 37
9188: IFFALSE 9204
// a := a &  next ;
9190: LD_ADDR_VAR 0 1
9194: PUSH
9195: LD_VAR 0 1
9199: PUSH
9200: LD_STRING  next
9202: STR
9203: ST_TO_ADDR
// debug_strings := [ a ] ;
9204: LD_ADDR_OWVAR 48
9208: PUSH
9209: LD_VAR 0 1
9213: PUSH
9214: EMPTY
9215: LIST
9216: ST_TO_ADDR
// enable ;
9217: ENABLE
// end ;
9218: PPOPN 1
9220: END
// function F_first_attack ; var i , r , amici , x , y , units , a , b ; begin
9221: LD_INT 0
9223: PPUSH
9224: PPUSH
9225: PPUSH
9226: PPUSH
9227: PPUSH
9228: PPUSH
9229: PPUSH
9230: PPUSH
9231: PPUSH
// r := Rand ( 1 , CameFromXY ) ;
9232: LD_ADDR_VAR 0 3
9236: PUSH
9237: LD_INT 1
9239: PPUSH
9240: LD_EXP 27
9244: PPUSH
9245: CALL_OW 12
9249: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
9250: LD_ADDR_VAR 0 5
9254: PUSH
9255: LD_EXP 27
9259: PUSH
9260: LD_VAR 0 3
9264: ARRAY
9265: PUSH
9266: LD_INT 1
9268: ARRAY
9269: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
9270: LD_ADDR_VAR 0 6
9274: PUSH
9275: LD_EXP 27
9279: PUSH
9280: LD_VAR 0 3
9284: ARRAY
9285: PUSH
9286: LD_INT 2
9288: ARRAY
9289: ST_TO_ADDR
// units := 2 ;
9290: LD_ADDR_VAR 0 7
9294: PUSH
9295: LD_INT 2
9297: ST_TO_ADDR
// a := make_arabs ( units , class_soldier ) ;
9298: LD_ADDR_VAR 0 8
9302: PUSH
9303: LD_VAR 0 7
9307: PPUSH
9308: LD_INT 1
9310: PPUSH
9311: CALL 1092 0 2
9315: ST_TO_ADDR
// for i in a do
9316: LD_ADDR_VAR 0 2
9320: PUSH
9321: LD_VAR 0 8
9325: PUSH
9326: FOR_IN
9327: IFFALSE 9356
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
9329: LD_VAR 0 2
9333: PPUSH
9334: LD_VAR 0 5
9338: PPUSH
9339: LD_VAR 0 6
9343: PPUSH
9344: LD_INT 5
9346: PPUSH
9347: LD_INT 0
9349: PPUSH
9350: CALL_OW 50
9354: GO 9326
9356: POP
9357: POP
// r := Rand ( 1 , CameFromXY ) ;
9358: LD_ADDR_VAR 0 3
9362: PUSH
9363: LD_INT 1
9365: PPUSH
9366: LD_EXP 27
9370: PPUSH
9371: CALL_OW 12
9375: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
9376: LD_ADDR_VAR 0 5
9380: PUSH
9381: LD_EXP 27
9385: PUSH
9386: LD_VAR 0 3
9390: ARRAY
9391: PUSH
9392: LD_INT 1
9394: ARRAY
9395: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
9396: LD_ADDR_VAR 0 6
9400: PUSH
9401: LD_EXP 27
9405: PUSH
9406: LD_VAR 0 3
9410: ARRAY
9411: PUSH
9412: LD_INT 2
9414: ARRAY
9415: ST_TO_ADDR
// units := difficulty + 1 ;
9416: LD_ADDR_VAR 0 7
9420: PUSH
9421: LD_OWVAR 67
9425: PUSH
9426: LD_INT 1
9428: PLUS
9429: ST_TO_ADDR
// b := make_arabs ( units , class_soldier ) ;
9430: LD_ADDR_VAR 0 9
9434: PUSH
9435: LD_VAR 0 7
9439: PPUSH
9440: LD_INT 1
9442: PPUSH
9443: CALL 1092 0 2
9447: ST_TO_ADDR
// for i in b do
9448: LD_ADDR_VAR 0 2
9452: PUSH
9453: LD_VAR 0 9
9457: PUSH
9458: FOR_IN
9459: IFFALSE 9488
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
9461: LD_VAR 0 2
9465: PPUSH
9466: LD_VAR 0 5
9470: PPUSH
9471: LD_VAR 0 6
9475: PPUSH
9476: LD_INT 5
9478: PPUSH
9479: LD_INT 0
9481: PPUSH
9482: CALL_OW 50
9486: GO 9458
9488: POP
9489: POP
// amici_b := budovy ;
9490: LD_ADDR_LOC 7
9494: PUSH
9495: LD_EXP 63
9499: ST_TO_ADDR
// amici_h := FilterAllUnits ( [ f_side , you ] ) ;
9500: LD_ADDR_LOC 6
9504: PUSH
9505: LD_INT 22
9507: PUSH
9508: LD_EXP 1
9512: PUSH
9513: EMPTY
9514: LIST
9515: LIST
9516: PPUSH
9517: CALL_OW 69
9521: ST_TO_ADDR
// away_from_last_attack := 0 ;
9522: LD_ADDR_EXP 32
9526: PUSH
9527: LD_INT 0
9529: ST_TO_ADDR
// make_mess := a ^ b ;
9530: LD_ADDR_LOC 9
9534: PUSH
9535: LD_VAR 0 8
9539: PUSH
9540: LD_VAR 0 9
9544: ADD
9545: ST_TO_ADDR
// if amici_b then
9546: LD_LOC 7
9550: IFFALSE 9591
// ComAgressiveMove ( make_mess , GetX ( amici_b [ 1 ] ) , GetY ( amici_b [ 1 ] ) ) else
9552: LD_LOC 9
9556: PPUSH
9557: LD_LOC 7
9561: PUSH
9562: LD_INT 1
9564: ARRAY
9565: PPUSH
9566: CALL_OW 250
9570: PPUSH
9571: LD_LOC 7
9575: PUSH
9576: LD_INT 1
9578: ARRAY
9579: PPUSH
9580: CALL_OW 251
9584: PPUSH
9585: CALL_OW 114
9589: GO 9628
// ComAgressiveMove ( make_mess , GetX ( amici_h [ 1 ] ) , GetY ( amici_h [ 1 ] ) ) ;
9591: LD_LOC 9
9595: PPUSH
9596: LD_LOC 6
9600: PUSH
9601: LD_INT 1
9603: ARRAY
9604: PPUSH
9605: CALL_OW 250
9609: PPUSH
9610: LD_LOC 6
9614: PUSH
9615: LD_INT 1
9617: ARRAY
9618: PPUSH
9619: CALL_OW 251
9623: PPUSH
9624: CALL_OW 114
// was_first_attack := true ;
9628: LD_ADDR_EXP 31
9632: PUSH
9633: LD_INT 1
9635: ST_TO_ADDR
// first_attack := true ;
9636: LD_ADDR_EXP 33
9640: PUSH
9641: LD_INT 1
9643: ST_TO_ADDR
// while see_any ( you , make_mess ) do
9644: LD_EXP 1
9648: PPUSH
9649: LD_LOC 9
9653: PPUSH
9654: CALL 13786 0 2
9658: IFFALSE 9669
// wait ( 0 0$0.5 ) ;
9660: LD_INT 18
9662: PPUSH
9663: CALL_OW 67
9667: GO 9644
// amici := FilterAllUnits ( [ [ f_side , you ] , [ f_see , arabians ] ] ) ;
9669: LD_ADDR_VAR 0 4
9673: PUSH
9674: LD_INT 22
9676: PUSH
9677: LD_EXP 1
9681: PUSH
9682: EMPTY
9683: LIST
9684: LIST
9685: PUSH
9686: LD_INT 101
9688: PUSH
9689: LD_EXP 4
9693: PUSH
9694: EMPTY
9695: LIST
9696: LIST
9697: PUSH
9698: EMPTY
9699: LIST
9700: LIST
9701: PPUSH
9702: CALL_OW 69
9706: ST_TO_ADDR
// if amici then
9707: LD_VAR 0 4
9711: IFFALSE 9750
// begin ComAgressiveMove ( make_mess , GetX ( amici [ 1 ] ) , GetY ( amici [ 1 ] ) ) ;
9713: LD_LOC 9
9717: PPUSH
9718: LD_VAR 0 4
9722: PUSH
9723: LD_INT 1
9725: ARRAY
9726: PPUSH
9727: CALL_OW 250
9731: PPUSH
9732: LD_VAR 0 4
9736: PUSH
9737: LD_INT 1
9739: ARRAY
9740: PPUSH
9741: CALL_OW 251
9745: PPUSH
9746: CALL_OW 114
// end ; end ;
9750: LD_VAR 0 1
9754: RET
// var set_charge , make_mess ; function F_mine_attack ; var i , r , amici , x , y , units , w_b , amici_b ; begin
9755: LD_INT 0
9757: PPUSH
9758: PPUSH
9759: PPUSH
9760: PPUSH
9761: PPUSH
9762: PPUSH
9763: PPUSH
9764: PPUSH
9765: PPUSH
// r := Rand ( 1 , CameFromXY ) ;
9766: LD_ADDR_VAR 0 3
9770: PUSH
9771: LD_INT 1
9773: PPUSH
9774: LD_EXP 27
9778: PPUSH
9779: CALL_OW 12
9783: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
9784: LD_ADDR_VAR 0 5
9788: PUSH
9789: LD_EXP 27
9793: PUSH
9794: LD_VAR 0 3
9798: ARRAY
9799: PUSH
9800: LD_INT 1
9802: ARRAY
9803: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
9804: LD_ADDR_VAR 0 6
9808: PUSH
9809: LD_EXP 27
9813: PUSH
9814: LD_VAR 0 3
9818: ARRAY
9819: PUSH
9820: LD_INT 2
9822: ARRAY
9823: ST_TO_ADDR
// units := difficulty * 2 ;
9824: LD_ADDR_VAR 0 7
9828: PUSH
9829: LD_OWVAR 67
9833: PUSH
9834: LD_INT 2
9836: MUL
9837: ST_TO_ADDR
// amici_b := budovy ;
9838: LD_ADDR_VAR 0 9
9842: PUSH
9843: LD_EXP 63
9847: ST_TO_ADDR
// w_b := Rand ( 1 , ( amici_b + 0 ) ) ;
9848: LD_ADDR_VAR 0 8
9852: PUSH
9853: LD_INT 1
9855: PPUSH
9856: LD_VAR 0 9
9860: PUSH
9861: LD_INT 0
9863: PLUS
9864: PPUSH
9865: CALL_OW 12
9869: ST_TO_ADDR
// if amici_b then
9870: LD_VAR 0 9
9874: IFFALSE 10486
// begin make_mess := make_arabs ( units , class_soldier ) ;
9876: LD_ADDR_LOC 9
9880: PUSH
9881: LD_VAR 0 7
9885: PPUSH
9886: LD_INT 1
9888: PPUSH
9889: CALL 1092 0 2
9893: ST_TO_ADDR
// units := ( make_mess + 0 ) ;
9894: LD_ADDR_VAR 0 7
9898: PUSH
9899: LD_LOC 9
9903: PUSH
9904: LD_INT 0
9906: PLUS
9907: ST_TO_ADDR
// for i in make_mess do
9908: LD_ADDR_VAR 0 2
9912: PUSH
9913: LD_LOC 9
9917: PUSH
9918: FOR_IN
9919: IFFALSE 9948
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
9921: LD_VAR 0 2
9925: PPUSH
9926: LD_VAR 0 5
9930: PPUSH
9931: LD_VAR 0 6
9935: PPUSH
9936: LD_INT 5
9938: PPUSH
9939: LD_INT 0
9941: PPUSH
9942: CALL_OW 50
9946: GO 9918
9948: POP
9949: POP
// away_from_last_attack := 0 ;
9950: LD_ADDR_EXP 32
9954: PUSH
9955: LD_INT 0
9957: ST_TO_ADDR
// set_charge := get_live_from_list ( make_mess , 0 , difficulty ) ;
9958: LD_ADDR_LOC 8
9962: PUSH
9963: LD_LOC 9
9967: PPUSH
9968: LD_INT 0
9970: PPUSH
9971: LD_OWVAR 67
9975: PPUSH
9976: CALL 13580 0 3
9980: ST_TO_ADDR
// make_mess := get_live_from_list ( make_mess , difficulty , units - difficulty ) ;
9981: LD_ADDR_LOC 9
9985: PUSH
9986: LD_LOC 9
9990: PPUSH
9991: LD_OWVAR 67
9995: PPUSH
9996: LD_VAR 0 7
10000: PUSH
10001: LD_OWVAR 67
10005: MINUS
10006: PPUSH
10007: CALL 13580 0 3
10011: ST_TO_ADDR
// ComAgressiveMove ( make_mess , GetX ( amici_b [ w_b ] ) , GetY ( amici_b [ w_b ] ) ) ;
10012: LD_LOC 9
10016: PPUSH
10017: LD_VAR 0 9
10021: PUSH
10022: LD_VAR 0 8
10026: ARRAY
10027: PPUSH
10028: CALL_OW 250
10032: PPUSH
10033: LD_VAR 0 9
10037: PUSH
10038: LD_VAR 0 8
10042: ARRAY
10043: PPUSH
10044: CALL_OW 251
10048: PPUSH
10049: CALL_OW 114
// find_easiest_way ( GetX ( amici_b [ w_b ] ) , GetY ( amici_b [ w_b ] ) , 7 , 3 , set_charge , you , false ) ;
10053: LD_VAR 0 9
10057: PUSH
10058: LD_VAR 0 8
10062: ARRAY
10063: PPUSH
10064: CALL_OW 250
10068: PPUSH
10069: LD_VAR 0 9
10073: PUSH
10074: LD_VAR 0 8
10078: ARRAY
10079: PPUSH
10080: CALL_OW 251
10084: PPUSH
10085: LD_INT 7
10087: PPUSH
10088: LD_INT 3
10090: PPUSH
10091: LD_LOC 8
10095: PPUSH
10096: LD_EXP 1
10100: PPUSH
10101: LD_INT 0
10103: PPUSH
10104: CALL 12208 0 7
// AddComPlaceDelayedCharge ( set_charge , GetX ( amici_b [ w_b ] ) , GetY ( amici_b [ w_b ] ) , amici_b [ w_b ] ) ;
10108: LD_LOC 8
10112: PPUSH
10113: LD_VAR 0 9
10117: PUSH
10118: LD_VAR 0 8
10122: ARRAY
10123: PPUSH
10124: CALL_OW 250
10128: PPUSH
10129: LD_VAR 0 9
10133: PUSH
10134: LD_VAR 0 8
10138: ARRAY
10139: PPUSH
10140: CALL_OW 251
10144: PPUSH
10145: LD_VAR 0 9
10149: PUSH
10150: LD_VAR 0 8
10154: ARRAY
10155: PPUSH
10156: CALL_OW 192
// evade_shortest_way_from_xy ( GetX ( amici_b [ w_b ] ) , GetY ( amici_b [ w_b ] ) , set_charge , true , true ) ;
10160: LD_VAR 0 9
10164: PUSH
10165: LD_VAR 0 8
10169: ARRAY
10170: PPUSH
10171: CALL_OW 250
10175: PPUSH
10176: LD_VAR 0 9
10180: PUSH
10181: LD_VAR 0 8
10185: ARRAY
10186: PPUSH
10187: CALL_OW 251
10191: PPUSH
10192: LD_LOC 8
10196: PPUSH
10197: LD_INT 1
10199: PPUSH
10200: LD_INT 1
10202: PPUSH
10203: CALL 12837 0 5
// mine_attack := true ;
10207: LD_ADDR_EXP 34
10211: PUSH
10212: LD_INT 1
10214: ST_TO_ADDR
// while not see_any ( you , make_mess ) do
10215: LD_EXP 1
10219: PPUSH
10220: LD_LOC 9
10224: PPUSH
10225: CALL 13786 0 2
10229: NOT
10230: IFFALSE 10241
// wait ( 0 0$0.5 ) ;
10232: LD_INT 18
10234: PPUSH
10235: CALL_OW 67
10239: GO 10215
// amici := FilterAllUnits ( [ [ f_side , you ] , [ f_see , arabians ] , [ f_type , unit_human ] ] ) ;
10241: LD_ADDR_VAR 0 4
10245: PUSH
10246: LD_INT 22
10248: PUSH
10249: LD_EXP 1
10253: PUSH
10254: EMPTY
10255: LIST
10256: LIST
10257: PUSH
10258: LD_INT 101
10260: PUSH
10261: LD_EXP 4
10265: PUSH
10266: EMPTY
10267: LIST
10268: LIST
10269: PUSH
10270: LD_INT 21
10272: PUSH
10273: LD_INT 1
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PUSH
10280: EMPTY
10281: LIST
10282: LIST
10283: LIST
10284: PPUSH
10285: CALL_OW 69
10289: ST_TO_ADDR
// if amici then
10290: LD_VAR 0 4
10294: IFFALSE 10413
// begin ComAgressiveMove ( make_mess , GetX ( amici [ 1 ] ) , GetY ( amici [ 1 ] ) ) ;
10296: LD_LOC 9
10300: PPUSH
10301: LD_VAR 0 4
10305: PUSH
10306: LD_INT 1
10308: ARRAY
10309: PPUSH
10310: CALL_OW 250
10314: PPUSH
10315: LD_VAR 0 4
10319: PUSH
10320: LD_INT 1
10322: ARRAY
10323: PPUSH
10324: CALL_OW 251
10328: PPUSH
10329: CALL_OW 114
// for i := 1 to amici do
10333: LD_ADDR_VAR 0 2
10337: PUSH
10338: DOUBLE
10339: LD_INT 1
10341: DEC
10342: ST_TO_ADDR
10343: LD_VAR 0 4
10347: PUSH
10348: FOR_TO
10349: IFFALSE 10394
// begin AddComAgressiveMove ( make_mess , GetX ( amici [ i ] ) , GetY ( amici [ i ] ) ) ;
10351: LD_LOC 9
10355: PPUSH
10356: LD_VAR 0 4
10360: PUSH
10361: LD_VAR 0 2
10365: ARRAY
10366: PPUSH
10367: CALL_OW 250
10371: PPUSH
10372: LD_VAR 0 4
10376: PUSH
10377: LD_VAR 0 2
10381: ARRAY
10382: PPUSH
10383: CALL_OW 251
10387: PPUSH
10388: CALL_OW 174
// end ;
10392: GO 10348
10394: POP
10395: POP
// evade_shortest_way ( make_mess , true , true ) ;
10396: LD_LOC 9
10400: PPUSH
10401: LD_INT 1
10403: PPUSH
10404: LD_INT 1
10406: PPUSH
10407: CALL 12750 0 3
// end else
10411: GO 10486
// begin if IsOk ( amici_b [ w_b ] ) then
10413: LD_VAR 0 9
10417: PUSH
10418: LD_VAR 0 8
10422: ARRAY
10423: PPUSH
10424: CALL_OW 302
10428: IFFALSE 10471
// ComAgressiveMove ( make_mess , GetX ( amici_b [ w_b ] ) , GetY ( amici_b [ w_b ] ) ) ;
10430: LD_LOC 9
10434: PPUSH
10435: LD_VAR 0 9
10439: PUSH
10440: LD_VAR 0 8
10444: ARRAY
10445: PPUSH
10446: CALL_OW 250
10450: PPUSH
10451: LD_VAR 0 9
10455: PUSH
10456: LD_VAR 0 8
10460: ARRAY
10461: PPUSH
10462: CALL_OW 251
10466: PPUSH
10467: CALL_OW 114
// evade_shortest_way ( make_mess , true , true ) ;
10471: LD_LOC 9
10475: PPUSH
10476: LD_INT 1
10478: PPUSH
10479: LD_INT 1
10481: PPUSH
10482: CALL 12750 0 3
// end ; end ; end ;
10486: LD_VAR 0 1
10490: RET
// var capcar1 , capcar2 ; var steal_car ; function F_thief_attack ; var i , r , x , y , units , amici3 ; begin
10491: LD_INT 0
10493: PPUSH
10494: PPUSH
10495: PPUSH
10496: PPUSH
10497: PPUSH
10498: PPUSH
10499: PPUSH
// r := Rand ( 1 , CameFromXY ) ;
10500: LD_ADDR_VAR 0 3
10504: PUSH
10505: LD_INT 1
10507: PPUSH
10508: LD_EXP 27
10512: PPUSH
10513: CALL_OW 12
10517: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
10518: LD_ADDR_VAR 0 4
10522: PUSH
10523: LD_EXP 27
10527: PUSH
10528: LD_VAR 0 3
10532: ARRAY
10533: PUSH
10534: LD_INT 1
10536: ARRAY
10537: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
10538: LD_ADDR_VAR 0 5
10542: PUSH
10543: LD_EXP 27
10547: PUSH
10548: LD_VAR 0 3
10552: ARRAY
10553: PUSH
10554: LD_INT 2
10556: ARRAY
10557: ST_TO_ADDR
// units := 3 + difficulty + attacky div 7 + away_from_last_attack div 4 ;
10558: LD_ADDR_VAR 0 6
10562: PUSH
10563: LD_INT 3
10565: PUSH
10566: LD_OWVAR 67
10570: PLUS
10571: PUSH
10572: LD_EXP 39
10576: PUSH
10577: LD_INT 7
10579: DIV
10580: PLUS
10581: PUSH
10582: LD_EXP 32
10586: PUSH
10587: LD_INT 4
10589: DIV
10590: PLUS
10591: ST_TO_ADDR
// amici_v := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , you ] ] ) ;
10592: LD_ADDR_LOC 5
10596: PUSH
10597: LD_INT 21
10599: PUSH
10600: LD_INT 2
10602: PUSH
10603: EMPTY
10604: LIST
10605: LIST
10606: PUSH
10607: LD_INT 22
10609: PUSH
10610: LD_EXP 1
10614: PUSH
10615: EMPTY
10616: LIST
10617: LIST
10618: PUSH
10619: EMPTY
10620: LIST
10621: LIST
10622: PPUSH
10623: CALL_OW 69
10627: ST_TO_ADDR
// if amici_v then
10628: LD_LOC 5
10632: IFFALSE 11230
// begin make_mess := make_arabs ( units , class_soldier ) ;
10634: LD_ADDR_LOC 9
10638: PUSH
10639: LD_VAR 0 6
10643: PPUSH
10644: LD_INT 1
10646: PPUSH
10647: CALL 1092 0 2
10651: ST_TO_ADDR
// units := ( make_mess + 0 ) ;
10652: LD_ADDR_VAR 0 6
10656: PUSH
10657: LD_LOC 9
10661: PUSH
10662: LD_INT 0
10664: PLUS
10665: ST_TO_ADDR
// for i in make_mess do
10666: LD_ADDR_VAR 0 2
10670: PUSH
10671: LD_LOC 9
10675: PUSH
10676: FOR_IN
10677: IFFALSE 10706
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
10679: LD_VAR 0 2
10683: PPUSH
10684: LD_VAR 0 4
10688: PPUSH
10689: LD_VAR 0 5
10693: PPUSH
10694: LD_INT 5
10696: PPUSH
10697: LD_INT 0
10699: PPUSH
10700: CALL_OW 50
10704: GO 10676
10706: POP
10707: POP
// away_from_last_attack := 0 ;
10708: LD_ADDR_EXP 32
10712: PUSH
10713: LD_INT 0
10715: ST_TO_ADDR
// if difficulty > 1 then
10716: LD_OWVAR 67
10720: PUSH
10721: LD_INT 1
10723: GREATER
10724: IFFALSE 10776
// begin steal_car := get_live_from_list ( make_mess , 0 , 2 ) ;
10726: LD_ADDR_LOC 12
10730: PUSH
10731: LD_LOC 9
10735: PPUSH
10736: LD_INT 0
10738: PPUSH
10739: LD_INT 2
10741: PPUSH
10742: CALL 13580 0 3
10746: ST_TO_ADDR
// make_mess := get_live_from_list ( make_mess , 2 , units - 2 ) ;
10747: LD_ADDR_LOC 9
10751: PUSH
10752: LD_LOC 9
10756: PPUSH
10757: LD_INT 2
10759: PPUSH
10760: LD_VAR 0 6
10764: PUSH
10765: LD_INT 2
10767: MINUS
10768: PPUSH
10769: CALL 13580 0 3
10773: ST_TO_ADDR
// end else
10774: GO 10824
// begin steal_car := get_live_from_list ( make_mess , 0 , 1 ) ;
10776: LD_ADDR_LOC 12
10780: PUSH
10781: LD_LOC 9
10785: PPUSH
10786: LD_INT 0
10788: PPUSH
10789: LD_INT 1
10791: PPUSH
10792: CALL 13580 0 3
10796: ST_TO_ADDR
// make_mess := get_live_from_list ( make_mess , 1 , units - 1 ) ;
10797: LD_ADDR_LOC 9
10801: PUSH
10802: LD_LOC 9
10806: PPUSH
10807: LD_INT 1
10809: PPUSH
10810: LD_VAR 0 6
10814: PUSH
10815: LD_INT 1
10817: MINUS
10818: PPUSH
10819: CALL 13580 0 3
10823: ST_TO_ADDR
// end ; ComAgressiveMove ( make_mess , GetX ( amici_v [ 1 ] ) , GetY ( amici_v [ 1 ] ) ) ;
10824: LD_LOC 9
10828: PPUSH
10829: LD_LOC 5
10833: PUSH
10834: LD_INT 1
10836: ARRAY
10837: PPUSH
10838: CALL_OW 250
10842: PPUSH
10843: LD_LOC 5
10847: PUSH
10848: LD_INT 1
10850: ARRAY
10851: PPUSH
10852: CALL_OW 251
10856: PPUSH
10857: CALL_OW 114
// find_easiest_way ( GetX ( amici_v [ 1 ] ) , GetY ( amici_v [ 1 ] ) , 7 , 3 , steal_car , you , false ) ;
10861: LD_LOC 5
10865: PUSH
10866: LD_INT 1
10868: ARRAY
10869: PPUSH
10870: CALL_OW 250
10874: PPUSH
10875: LD_LOC 5
10879: PUSH
10880: LD_INT 1
10882: ARRAY
10883: PPUSH
10884: CALL_OW 251
10888: PPUSH
10889: LD_INT 7
10891: PPUSH
10892: LD_INT 3
10894: PPUSH
10895: LD_LOC 12
10899: PPUSH
10900: LD_EXP 1
10904: PPUSH
10905: LD_INT 0
10907: PPUSH
10908: CALL 12208 0 7
// com_queue := true ;
10912: LD_ADDR_OWVAR 49
10916: PUSH
10917: LD_INT 1
10919: ST_TO_ADDR
// AddComEnterUnit ( steal_car , amici_v [ 1 ] ) ;
10920: LD_LOC 12
10924: PPUSH
10925: LD_LOC 5
10929: PUSH
10930: LD_INT 1
10932: ARRAY
10933: PPUSH
10934: CALL_OW 180
// com_queue := false ;
10938: LD_ADDR_OWVAR 49
10942: PUSH
10943: LD_INT 0
10945: ST_TO_ADDR
// evade_shortest_way_from_xy ( GetX ( amici_v [ 1 ] ) , GetY ( amici_v [ 1 ] ) , steal_car , true , true ) ;
10946: LD_LOC 5
10950: PUSH
10951: LD_INT 1
10953: ARRAY
10954: PPUSH
10955: CALL_OW 250
10959: PPUSH
10960: LD_LOC 5
10964: PUSH
10965: LD_INT 1
10967: ARRAY
10968: PPUSH
10969: CALL_OW 251
10973: PPUSH
10974: LD_LOC 12
10978: PPUSH
10979: LD_INT 1
10981: PPUSH
10982: LD_INT 1
10984: PPUSH
10985: CALL 12837 0 5
// thief_attack := true ;
10989: LD_ADDR_EXP 35
10993: PUSH
10994: LD_INT 1
10996: ST_TO_ADDR
// while not see_any ( you , make_mess ) do
10997: LD_EXP 1
11001: PPUSH
11002: LD_LOC 9
11006: PPUSH
11007: CALL 13786 0 2
11011: NOT
11012: IFFALSE 11023
// wait ( 0 0$0.5 ) ;
11014: LD_INT 18
11016: PPUSH
11017: CALL_OW 67
11021: GO 10997
// amici_b := FilterAllUnits ( [ f_type , unit_building ] ) ;
11023: LD_ADDR_LOC 7
11027: PUSH
11028: LD_INT 21
11030: PUSH
11031: LD_INT 3
11033: PUSH
11034: EMPTY
11035: LIST
11036: LIST
11037: PPUSH
11038: CALL_OW 69
11042: ST_TO_ADDR
// amici3 := FilterAllUnits ( [ [ f_side , you ] , [ f_see , arabians ] , [ f_type , unit_human ] ] ) ;
11043: LD_ADDR_VAR 0 7
11047: PUSH
11048: LD_INT 22
11050: PUSH
11051: LD_EXP 1
11055: PUSH
11056: EMPTY
11057: LIST
11058: LIST
11059: PUSH
11060: LD_INT 101
11062: PUSH
11063: LD_EXP 4
11067: PUSH
11068: EMPTY
11069: LIST
11070: LIST
11071: PUSH
11072: LD_INT 21
11074: PUSH
11075: LD_INT 1
11077: PUSH
11078: EMPTY
11079: LIST
11080: LIST
11081: PUSH
11082: EMPTY
11083: LIST
11084: LIST
11085: LIST
11086: PPUSH
11087: CALL_OW 69
11091: ST_TO_ADDR
// if amici3 then
11092: LD_VAR 0 7
11096: IFFALSE 11191
// begin ComAttackUnit ( make_mess , amici3 [ 1 ] ) ;
11098: LD_LOC 9
11102: PPUSH
11103: LD_VAR 0 7
11107: PUSH
11108: LD_INT 1
11110: ARRAY
11111: PPUSH
11112: CALL_OW 115
// for i := 2 to amici3 do
11116: LD_ADDR_VAR 0 2
11120: PUSH
11121: DOUBLE
11122: LD_INT 2
11124: DEC
11125: ST_TO_ADDR
11126: LD_VAR 0 7
11130: PUSH
11131: FOR_TO
11132: IFFALSE 11172
// begin com_queue := true ;
11134: LD_ADDR_OWVAR 49
11138: PUSH
11139: LD_INT 1
11141: ST_TO_ADDR
// ComAttackUnit ( make_mess , amici3 [ i ] ) ;
11142: LD_LOC 9
11146: PPUSH
11147: LD_VAR 0 7
11151: PUSH
11152: LD_VAR 0 2
11156: ARRAY
11157: PPUSH
11158: CALL_OW 115
// com_queue := false ;
11162: LD_ADDR_OWVAR 49
11166: PUSH
11167: LD_INT 0
11169: ST_TO_ADDR
// end ;
11170: GO 11131
11172: POP
11173: POP
// evade_shortest_way ( make_mess , true , true ) ;
11174: LD_LOC 9
11178: PPUSH
11179: LD_INT 1
11181: PPUSH
11182: LD_INT 1
11184: PPUSH
11185: CALL 12750 0 3
// end else
11189: GO 11230
// begin if amici_b then
11191: LD_LOC 7
11195: IFFALSE 11215
// ComAttackUnit ( make_mess , amici_b [ 1 ] ) ;
11197: LD_LOC 9
11201: PPUSH
11202: LD_LOC 7
11206: PUSH
11207: LD_INT 1
11209: ARRAY
11210: PPUSH
11211: CALL_OW 115
// evade_shortest_way ( make_mess , true , true ) ;
11215: LD_LOC 9
11219: PPUSH
11220: LD_INT 1
11222: PPUSH
11223: LD_INT 1
11225: PPUSH
11226: CALL 12750 0 3
// end ; end ; end ;
11230: LD_VAR 0 1
11234: RET
// function F_lonely_attack ( daleko ) ; var i , r , x , y , units ; begin
11235: LD_INT 0
11237: PPUSH
11238: PPUSH
11239: PPUSH
11240: PPUSH
11241: PPUSH
11242: PPUSH
// r := Rand ( 1 , CameFromXY ) ;
11243: LD_ADDR_VAR 0 4
11247: PUSH
11248: LD_INT 1
11250: PPUSH
11251: LD_EXP 27
11255: PPUSH
11256: CALL_OW 12
11260: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
11261: LD_ADDR_VAR 0 5
11265: PUSH
11266: LD_EXP 27
11270: PUSH
11271: LD_VAR 0 4
11275: ARRAY
11276: PUSH
11277: LD_INT 1
11279: ARRAY
11280: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
11281: LD_ADDR_VAR 0 6
11285: PUSH
11286: LD_EXP 27
11290: PUSH
11291: LD_VAR 0 4
11295: ARRAY
11296: PUSH
11297: LD_INT 2
11299: ARRAY
11300: ST_TO_ADDR
// units := 1 + difficulty ;
11301: LD_ADDR_VAR 0 7
11305: PUSH
11306: LD_INT 1
11308: PUSH
11309: LD_OWVAR 67
11313: PLUS
11314: ST_TO_ADDR
// if daleko then
11315: LD_VAR 0 1
11319: IFFALSE 11583
// begin make_mess := make_arabs ( units , class_soldier ) ;
11321: LD_ADDR_LOC 9
11325: PUSH
11326: LD_VAR 0 7
11330: PPUSH
11331: LD_INT 1
11333: PPUSH
11334: CALL 1092 0 2
11338: ST_TO_ADDR
// units := ( make_mess + 0 ) ;
11339: LD_ADDR_VAR 0 7
11343: PUSH
11344: LD_LOC 9
11348: PUSH
11349: LD_INT 0
11351: PLUS
11352: ST_TO_ADDR
// for i in make_mess do
11353: LD_ADDR_VAR 0 3
11357: PUSH
11358: LD_LOC 9
11362: PUSH
11363: FOR_IN
11364: IFFALSE 11393
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
11366: LD_VAR 0 3
11370: PPUSH
11371: LD_VAR 0 5
11375: PPUSH
11376: LD_VAR 0 6
11380: PPUSH
11381: LD_INT 5
11383: PPUSH
11384: LD_INT 0
11386: PPUSH
11387: CALL_OW 50
11391: GO 11363
11393: POP
11394: POP
// away_from_last_attack := 0 ;
11395: LD_ADDR_EXP 32
11399: PUSH
11400: LD_INT 0
11402: ST_TO_ADDR
// make_mess := make_mess ;
11403: LD_ADDR_LOC 9
11407: PUSH
11408: LD_LOC 9
11412: ST_TO_ADDR
// find_easiest_way ( GetX ( daleko [ 1 ] ) , GetY ( daleko [ 1 ] ) , 7 , 3 , make_mess , you , true ) ;
11413: LD_VAR 0 1
11417: PUSH
11418: LD_INT 1
11420: ARRAY
11421: PPUSH
11422: CALL_OW 250
11426: PPUSH
11427: LD_VAR 0 1
11431: PUSH
11432: LD_INT 1
11434: ARRAY
11435: PPUSH
11436: CALL_OW 251
11440: PPUSH
11441: LD_INT 7
11443: PPUSH
11444: LD_INT 3
11446: PPUSH
11447: LD_LOC 9
11451: PPUSH
11452: LD_EXP 1
11456: PPUSH
11457: LD_INT 1
11459: PPUSH
11460: CALL 12208 0 7
// AddComAttackUnit ( make_mess , daleko [ 1 ] ) ;
11464: LD_LOC 9
11468: PPUSH
11469: LD_VAR 0 1
11473: PUSH
11474: LD_INT 1
11476: ARRAY
11477: PPUSH
11478: CALL_OW 175
// if daleko >= 2 then
11482: LD_VAR 0 1
11486: PUSH
11487: LD_INT 2
11489: GREATEREQUAL
11490: IFFALSE 11538
// begin AddComAttackUnit ( make_mess , daleko [ 2 ] ) ;
11492: LD_LOC 9
11496: PPUSH
11497: LD_VAR 0 1
11501: PUSH
11502: LD_INT 2
11504: ARRAY
11505: PPUSH
11506: CALL_OW 175
// if daleko >= 3 then
11510: LD_VAR 0 1
11514: PUSH
11515: LD_INT 3
11517: GREATEREQUAL
11518: IFFALSE 11538
// begin AddComAttackUnit ( make_mess , daleko [ 3 ] ) ;
11520: LD_LOC 9
11524: PPUSH
11525: LD_VAR 0 1
11529: PUSH
11530: LD_INT 3
11532: ARRAY
11533: PPUSH
11534: CALL_OW 175
// end ; end ; evade_shortest_way ( make_mess , true , true ) ;
11538: LD_LOC 9
11542: PPUSH
11543: LD_INT 1
11545: PPUSH
11546: LD_INT 1
11548: PPUSH
11549: CALL 12750 0 3
// attacky := attacky + 1 ;
11553: LD_ADDR_EXP 39
11557: PUSH
11558: LD_EXP 39
11562: PUSH
11563: LD_INT 1
11565: PLUS
11566: ST_TO_ADDR
// lonely_attack := true ;
11567: LD_ADDR_EXP 36
11571: PUSH
11572: LD_INT 1
11574: ST_TO_ADDR
// attacking := true ;
11575: LD_ADDR_EXP 38
11579: PUSH
11580: LD_INT 1
11582: ST_TO_ADDR
// end ; end ;
11583: LD_VAR 0 2
11587: RET
// function F_next_attack ; var i , a , r , x , y , units , amici ; begin
11588: LD_INT 0
11590: PPUSH
11591: PPUSH
11592: PPUSH
11593: PPUSH
11594: PPUSH
11595: PPUSH
11596: PPUSH
11597: PPUSH
// r := Rand ( 1 , CameFromXY ) ;
11598: LD_ADDR_VAR 0 4
11602: PUSH
11603: LD_INT 1
11605: PPUSH
11606: LD_EXP 27
11610: PPUSH
11611: CALL_OW 12
11615: ST_TO_ADDR
// x := CameFromXY [ r ] [ 1 ] ;
11616: LD_ADDR_VAR 0 5
11620: PUSH
11621: LD_EXP 27
11625: PUSH
11626: LD_VAR 0 4
11630: ARRAY
11631: PUSH
11632: LD_INT 1
11634: ARRAY
11635: ST_TO_ADDR
// y := CameFromXY [ r ] [ 2 ] ;
11636: LD_ADDR_VAR 0 6
11640: PUSH
11641: LD_EXP 27
11645: PUSH
11646: LD_VAR 0 4
11650: ARRAY
11651: PUSH
11652: LD_INT 2
11654: ARRAY
11655: ST_TO_ADDR
// units := 2 + difficulty + away_from_last_attack div 8 + attacky div 8 ;
11656: LD_ADDR_VAR 0 7
11660: PUSH
11661: LD_INT 2
11663: PUSH
11664: LD_OWVAR 67
11668: PLUS
11669: PUSH
11670: LD_EXP 32
11674: PUSH
11675: LD_INT 8
11677: DIV
11678: PLUS
11679: PUSH
11680: LD_EXP 39
11684: PUSH
11685: LD_INT 8
11687: DIV
11688: PLUS
11689: ST_TO_ADDR
// make_mess := make_arabs ( units , class_soldier ) ;
11690: LD_ADDR_LOC 9
11694: PUSH
11695: LD_VAR 0 7
11699: PPUSH
11700: LD_INT 1
11702: PPUSH
11703: CALL 1092 0 2
11707: ST_TO_ADDR
// units := ( make_mess + 0 ) ;
11708: LD_ADDR_VAR 0 7
11712: PUSH
11713: LD_LOC 9
11717: PUSH
11718: LD_INT 0
11720: PLUS
11721: ST_TO_ADDR
// for i in make_mess do
11722: LD_ADDR_VAR 0 2
11726: PUSH
11727: LD_LOC 9
11731: PUSH
11732: FOR_IN
11733: IFFALSE 11762
// PlaceUnitXYR ( i , x , y , 5 , false ) ;
11735: LD_VAR 0 2
11739: PPUSH
11740: LD_VAR 0 5
11744: PPUSH
11745: LD_VAR 0 6
11749: PPUSH
11750: LD_INT 5
11752: PPUSH
11753: LD_INT 0
11755: PPUSH
11756: CALL_OW 50
11760: GO 11732
11762: POP
11763: POP
// away_from_last_attack := 0 ;
11764: LD_ADDR_EXP 32
11768: PUSH
11769: LD_INT 0
11771: ST_TO_ADDR
// make_mess := make_mess ;
11772: LD_ADDR_LOC 9
11776: PUSH
11777: LD_LOC 9
11781: ST_TO_ADDR
// a := Rand ( 1 , budovy ) ;
11782: LD_ADDR_VAR 0 3
11786: PUSH
11787: LD_INT 1
11789: PPUSH
11790: LD_EXP 63
11794: PPUSH
11795: CALL_OW 12
11799: ST_TO_ADDR
// if budovy then
11800: LD_EXP 63
11804: IFFALSE 11849
// ComAgressiveMove ( make_mess , GetX ( budovy [ a ] ) , GetY ( budovy [ a ] ) ) else
11806: LD_LOC 9
11810: PPUSH
11811: LD_EXP 63
11815: PUSH
11816: LD_VAR 0 3
11820: ARRAY
11821: PPUSH
11822: CALL_OW 250
11826: PPUSH
11827: LD_EXP 63
11831: PUSH
11832: LD_VAR 0 3
11836: ARRAY
11837: PPUSH
11838: CALL_OW 251
11842: PPUSH
11843: CALL_OW 114
11847: GO 11886
// ComAgressiveMove ( make_mess , GetX ( tvoji_lidi [ 1 ] ) , GetY ( tvoji_lidi [ 1 ] ) ) ;
11849: LD_LOC 9
11853: PPUSH
11854: LD_EXP 47
11858: PUSH
11859: LD_INT 1
11861: ARRAY
11862: PPUSH
11863: CALL_OW 250
11867: PPUSH
11868: LD_EXP 47
11872: PUSH
11873: LD_INT 1
11875: ARRAY
11876: PPUSH
11877: CALL_OW 251
11881: PPUSH
11882: CALL_OW 114
// next_attack := true ;
11886: LD_ADDR_EXP 37
11890: PUSH
11891: LD_INT 1
11893: ST_TO_ADDR
// attacky := attacky + 1 ;
11894: LD_ADDR_EXP 39
11898: PUSH
11899: LD_EXP 39
11903: PUSH
11904: LD_INT 1
11906: PLUS
11907: ST_TO_ADDR
// attacking := true ;
11908: LD_ADDR_EXP 38
11912: PUSH
11913: LD_INT 1
11915: ST_TO_ADDR
// while not see_any ( you , make_mess ) do
11916: LD_EXP 1
11920: PPUSH
11921: LD_LOC 9
11925: PPUSH
11926: CALL 13786 0 2
11930: NOT
11931: IFFALSE 11942
// wait ( 0 0$0.5 ) ;
11933: LD_INT 18
11935: PPUSH
11936: CALL_OW 67
11940: GO 11916
// amici := FilterAllUnits ( [ [ f_side , you ] , [ f_see , arabians ] ] ) ;
11942: LD_ADDR_VAR 0 8
11946: PUSH
11947: LD_INT 22
11949: PUSH
11950: LD_EXP 1
11954: PUSH
11955: EMPTY
11956: LIST
11957: LIST
11958: PUSH
11959: LD_INT 101
11961: PUSH
11962: LD_EXP 4
11966: PUSH
11967: EMPTY
11968: LIST
11969: LIST
11970: PUSH
11971: EMPTY
11972: LIST
11973: LIST
11974: PPUSH
11975: CALL_OW 69
11979: ST_TO_ADDR
// if amici then
11980: LD_VAR 0 8
11984: IFFALSE 12025
// begin ComAgressiveMove ( make_mess , GetX ( amici [ 1 ] ) , GetY ( amici [ 1 ] ) ) ;
11986: LD_LOC 9
11990: PPUSH
11991: LD_VAR 0 8
11995: PUSH
11996: LD_INT 1
11998: ARRAY
11999: PPUSH
12000: CALL_OW 250
12004: PPUSH
12005: LD_VAR 0 8
12009: PUSH
12010: LD_INT 1
12012: ARRAY
12013: PPUSH
12014: CALL_OW 251
12018: PPUSH
12019: CALL_OW 114
// end else
12023: GO 12056
// begin ComMoveXY ( make_mess , x , y ) ;
12025: LD_LOC 9
12029: PPUSH
12030: LD_VAR 0 5
12034: PPUSH
12035: LD_VAR 0 6
12039: PPUSH
12040: CALL_OW 111
// AddComMoveToArea ( make_mess , border ) ;
12044: LD_LOC 9
12048: PPUSH
12049: LD_INT 7
12051: PPUSH
12052: CALL_OW 173
// end ; end ;
12056: LD_VAR 0 1
12060: RET
// every 0 0$1.0 do
12061: GO 12063
12063: DISABLE
// begin enter_near_vehicle ( make_mess , 4 , FilterAllUnits ( [ [ f_side , you ] , [ f_type , unit_vehicle ] ] ) ) ;
12064: LD_LOC 9
12068: PPUSH
12069: LD_INT 4
12071: PPUSH
12072: LD_INT 22
12074: PUSH
12075: LD_EXP 1
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PUSH
12084: LD_INT 21
12086: PUSH
12087: LD_INT 2
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: PUSH
12094: EMPTY
12095: LIST
12096: LIST
12097: PPUSH
12098: CALL_OW 69
12102: PPUSH
12103: CALL 13857 0 3
// arabs_cars := FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_side , arabians ] ] ) ;
12107: LD_ADDR_EXP 9
12111: PUSH
12112: LD_INT 21
12114: PUSH
12115: LD_INT 2
12117: PUSH
12118: EMPTY
12119: LIST
12120: LIST
12121: PUSH
12122: LD_INT 22
12124: PUSH
12125: LD_EXP 4
12129: PUSH
12130: EMPTY
12131: LIST
12132: LIST
12133: PUSH
12134: EMPTY
12135: LIST
12136: LIST
12137: PPUSH
12138: CALL_OW 69
12142: ST_TO_ADDR
// if arabs_cars then
12143: LD_EXP 9
12147: IFFALSE 12206
// begin if GetWeapon ( arabs_cars [ 1 ] ) <> us_cargo_bay then
12149: LD_EXP 9
12153: PUSH
12154: LD_INT 1
12156: ARRAY
12157: PPUSH
12158: CALL_OW 264
12162: PUSH
12163: LD_INT 12
12165: NONEQUAL
12166: IFFALSE 12194
// begin ComWait ( arabs_cars , 0 0$12 ) ;
12168: LD_EXP 9
12172: PPUSH
12173: LD_INT 420
12175: PPUSH
12176: CALL_OW 142
// AddComMoveToArea ( arabs_cars , border ) ;
12180: LD_EXP 9
12184: PPUSH
12185: LD_INT 7
12187: PPUSH
12188: CALL_OW 173
// end else
12192: GO 12206
// ComMoveToArea ( arabs_cars , border ) ;
12194: LD_EXP 9
12198: PPUSH
12199: LD_INT 7
12201: PPUSH
12202: CALL_OW 113
// end ; enable ;
12206: ENABLE
// end ; end_of_file
12207: END
// export function find_easiest_way ( px , py , hloubka , krok , for_units , host_side , queue ) ; var x , y ; var x2 , y2 ; var lx , ly ; var howgood , smer ; var i2 , j2 , size2 ; var hsee , kolem ; var for_unit ; begin
12208: LD_INT 0
12210: PPUSH
12211: PPUSH
12212: PPUSH
12213: PPUSH
12214: PPUSH
12215: PPUSH
12216: PPUSH
12217: PPUSH
12218: PPUSH
12219: PPUSH
12220: PPUSH
12221: PPUSH
12222: PPUSH
12223: PPUSH
12224: PPUSH
// for for_unit in for_units do
12225: LD_ADDR_VAR 0 22
12229: PUSH
12230: LD_VAR 0 5
12234: PUSH
12235: FOR_IN
12236: IFFALSE 12743
// begin x := px ;
12238: LD_ADDR_VAR 0 9
12242: PUSH
12243: LD_VAR 0 1
12247: ST_TO_ADDR
// y := py ;
12248: LD_ADDR_VAR 0 10
12252: PUSH
12253: LD_VAR 0 2
12257: ST_TO_ADDR
// lx := px ;
12258: LD_ADDR_VAR 0 13
12262: PUSH
12263: LD_VAR 0 1
12267: ST_TO_ADDR
// ly := py ;
12268: LD_ADDR_VAR 0 14
12272: PUSH
12273: LD_VAR 0 2
12277: ST_TO_ADDR
// for j2 := 1 to hloubka do
12278: LD_ADDR_VAR 0 18
12282: PUSH
12283: DOUBLE
12284: LD_INT 1
12286: DEC
12287: ST_TO_ADDR
12288: LD_VAR 0 3
12292: PUSH
12293: FOR_TO
12294: IFFALSE 12626
// begin howgood := 50000 ;
12296: LD_ADDR_VAR 0 15
12300: PUSH
12301: LD_INT 50000
12303: ST_TO_ADDR
// smer := 0 ;
12304: LD_ADDR_VAR 0 16
12308: PUSH
12309: LD_INT 0
12311: ST_TO_ADDR
// kolem := 0 ;
12312: LD_ADDR_VAR 0 21
12316: PUSH
12317: LD_INT 0
12319: ST_TO_ADDR
// for i2 := 0 to 4 do
12320: LD_ADDR_VAR 0 17
12324: PUSH
12325: DOUBLE
12326: LD_INT 0
12328: DEC
12329: ST_TO_ADDR
12330: LD_INT 4
12332: PUSH
12333: FOR_TO
12334: IFFALSE 12528
// begin x2 := ShiftX ( x , i2 , krok ) ;
12336: LD_ADDR_VAR 0 11
12340: PUSH
12341: LD_VAR 0 9
12345: PPUSH
12346: LD_VAR 0 17
12350: PPUSH
12351: LD_VAR 0 4
12355: PPUSH
12356: CALL_OW 272
12360: ST_TO_ADDR
// y2 := ShiftY ( y , i2 , krok ) ;
12361: LD_ADDR_VAR 0 12
12365: PUSH
12366: LD_VAR 0 10
12370: PPUSH
12371: LD_VAR 0 17
12375: PPUSH
12376: LD_VAR 0 4
12380: PPUSH
12381: CALL_OW 273
12385: ST_TO_ADDR
// hsee := SeeXY ( host_side , x2 , y2 ) ;
12386: LD_ADDR_VAR 0 20
12390: PUSH
12391: LD_VAR 0 6
12395: PPUSH
12396: LD_VAR 0 11
12400: PPUSH
12401: LD_VAR 0 12
12405: PPUSH
12406: CALL_OW 293
12410: ST_TO_ADDR
// if hsee < howgood and GetDistXY ( px , py , x , y ) < GetDistXY ( px , py , x2 , y2 ) then
12411: LD_VAR 0 20
12415: PUSH
12416: LD_VAR 0 15
12420: LESS
12421: PUSH
12422: LD_VAR 0 1
12426: PPUSH
12427: LD_VAR 0 2
12431: PPUSH
12432: LD_VAR 0 9
12436: PPUSH
12437: LD_VAR 0 10
12441: PPUSH
12442: CALL_OW 298
12446: PUSH
12447: LD_VAR 0 1
12451: PPUSH
12452: LD_VAR 0 2
12456: PPUSH
12457: LD_VAR 0 11
12461: PPUSH
12462: LD_VAR 0 12
12466: PPUSH
12467: CALL_OW 298
12471: LESS
12472: AND
12473: IFFALSE 12510
// begin howgood := SeeXY ( host_side , x2 , y2 ) ;
12475: LD_ADDR_VAR 0 15
12479: PUSH
12480: LD_VAR 0 6
12484: PPUSH
12485: LD_VAR 0 11
12489: PPUSH
12490: LD_VAR 0 12
12494: PPUSH
12495: CALL_OW 293
12499: ST_TO_ADDR
// smer := i2 ;
12500: LD_ADDR_VAR 0 16
12504: PUSH
12505: LD_VAR 0 17
12509: ST_TO_ADDR
// end ; kolem := kolem + hsee ;
12510: LD_ADDR_VAR 0 21
12514: PUSH
12515: LD_VAR 0 21
12519: PUSH
12520: LD_VAR 0 20
12524: PLUS
12525: ST_TO_ADDR
// end ;
12526: GO 12333
12528: POP
12529: POP
// x := ShiftX ( x , smer , krok ) ;
12530: LD_ADDR_VAR 0 9
12534: PUSH
12535: LD_VAR 0 9
12539: PPUSH
12540: LD_VAR 0 16
12544: PPUSH
12545: LD_VAR 0 4
12549: PPUSH
12550: CALL_OW 272
12554: ST_TO_ADDR
// y := ShiftY ( y , smer , krok ) ;
12555: LD_ADDR_VAR 0 10
12559: PUSH
12560: LD_VAR 0 10
12564: PPUSH
12565: LD_VAR 0 16
12569: PPUSH
12570: LD_VAR 0 4
12574: PPUSH
12575: CALL_OW 273
12579: ST_TO_ADDR
// lx := lx ^ x ;
12580: LD_ADDR_VAR 0 13
12584: PUSH
12585: LD_VAR 0 13
12589: PUSH
12590: LD_VAR 0 9
12594: ADD
12595: ST_TO_ADDR
// ly := ly ^ y ;
12596: LD_ADDR_VAR 0 14
12600: PUSH
12601: LD_VAR 0 14
12605: PUSH
12606: LD_VAR 0 10
12610: ADD
12611: ST_TO_ADDR
// if kolem = 0 then
12612: LD_VAR 0 21
12616: PUSH
12617: LD_INT 0
12619: EQUAL
12620: IFFALSE 12624
// break ;
12622: GO 12626
// end ;
12624: GO 12293
12626: POP
12627: POP
// for j2 := ( lx + 0 ) downto 1 do
12628: LD_ADDR_VAR 0 18
12632: PUSH
12633: DOUBLE
12634: LD_VAR 0 13
12638: PUSH
12639: LD_INT 0
12641: PLUS
12642: INC
12643: ST_TO_ADDR
12644: LD_INT 1
12646: PUSH
12647: FOR_DOWNTO
12648: IFFALSE 12739
// begin if not queue and j2 = ( lx + 0 ) then
12650: LD_VAR 0 7
12654: NOT
12655: PUSH
12656: LD_VAR 0 18
12660: PUSH
12661: LD_VAR 0 13
12665: PUSH
12666: LD_INT 0
12668: PLUS
12669: EQUAL
12670: AND
12671: IFFALSE 12706
// ComMoveXY ( for_unit , lx [ j2 ] , ly [ j2 ] ) else
12673: LD_VAR 0 22
12677: PPUSH
12678: LD_VAR 0 13
12682: PUSH
12683: LD_VAR 0 18
12687: ARRAY
12688: PPUSH
12689: LD_VAR 0 14
12693: PUSH
12694: LD_VAR 0 18
12698: ARRAY
12699: PPUSH
12700: CALL_OW 111
12704: GO 12737
// begin AddComMoveXY ( for_unit , lx [ j2 ] , ly [ j2 ] ) ;
12706: LD_VAR 0 22
12710: PPUSH
12711: LD_VAR 0 13
12715: PUSH
12716: LD_VAR 0 18
12720: ARRAY
12721: PPUSH
12722: LD_VAR 0 14
12726: PUSH
12727: LD_VAR 0 18
12731: ARRAY
12732: PPUSH
12733: CALL_OW 171
// end ; end ;
12737: GO 12647
12739: POP
12740: POP
// end ;
12741: GO 12235
12743: POP
12744: POP
// end ;
12745: LD_VAR 0 8
12749: RET
// export function evade_shortest_way ( for_units , queue , agressive ) ; var for_unit ; var unx , uny ; begin
12750: LD_INT 0
12752: PPUSH
12753: PPUSH
12754: PPUSH
12755: PPUSH
// for for_unit in for_units do
12756: LD_ADDR_VAR 0 5
12760: PUSH
12761: LD_VAR 0 1
12765: PUSH
12766: FOR_IN
12767: IFFALSE 12830
// begin unx := GetX ( for_unit ) ;
12769: LD_ADDR_VAR 0 6
12773: PUSH
12774: LD_VAR 0 5
12778: PPUSH
12779: CALL_OW 250
12783: ST_TO_ADDR
// uny := GetY ( for_unit ) ;
12784: LD_ADDR_VAR 0 7
12788: PUSH
12789: LD_VAR 0 5
12793: PPUSH
12794: CALL_OW 251
12798: ST_TO_ADDR
// evade_shortest_way_from_xy ( unx , uny , for_unit , queue , agressive ) ;
12799: LD_VAR 0 6
12803: PPUSH
12804: LD_VAR 0 7
12808: PPUSH
12809: LD_VAR 0 5
12813: PPUSH
12814: LD_VAR 0 2
12818: PPUSH
12819: LD_VAR 0 3
12823: PPUSH
12824: CALL 12837 0 5
// end ;
12828: GO 12766
12830: POP
12831: POP
// end ;
12832: LD_VAR 0 4
12836: RET
// export function evade_shortest_way_from_xy ( unx , uny , for_units , queue , agressive ) ; var foundswX , foundswY , foundswD ; var eswTX , eswTY ; var for_unit ; begin
12837: LD_INT 0
12839: PPUSH
12840: PPUSH
12841: PPUSH
12842: PPUSH
12843: PPUSH
12844: PPUSH
12845: PPUSH
// for for_unit in for_units do
12846: LD_ADDR_VAR 0 12
12850: PUSH
12851: LD_VAR 0 3
12855: PUSH
12856: FOR_IN
12857: IFFALSE 13573
// begin foundswD := 50000 ;
12859: LD_ADDR_VAR 0 9
12863: PUSH
12864: LD_INT 50000
12866: ST_TO_ADDR
// eswTX := 0 ;
12867: LD_ADDR_VAR 0 10
12871: PUSH
12872: LD_INT 0
12874: ST_TO_ADDR
// eswTY := 0 ;
12875: LD_ADDR_VAR 0 11
12879: PUSH
12880: LD_INT 0
12882: ST_TO_ADDR
// while eswTX < map_size_x do
12883: LD_VAR 0 10
12887: PUSH
12888: LD_EXP 28
12892: LESS
12893: IFFALSE 12993
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
12895: LD_VAR 0 1
12899: PPUSH
12900: LD_VAR 0 2
12904: PPUSH
12905: LD_VAR 0 10
12909: PPUSH
12910: LD_VAR 0 11
12914: PPUSH
12915: CALL_OW 298
12919: PUSH
12920: LD_VAR 0 9
12924: LESS
12925: IFFALSE 12977
// begin foundswX := eswTX ;
12927: LD_ADDR_VAR 0 7
12931: PUSH
12932: LD_VAR 0 10
12936: ST_TO_ADDR
// foundswY := eswTY ;
12937: LD_ADDR_VAR 0 8
12941: PUSH
12942: LD_VAR 0 11
12946: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
12947: LD_ADDR_VAR 0 9
12951: PUSH
12952: LD_VAR 0 1
12956: PPUSH
12957: LD_VAR 0 2
12961: PPUSH
12962: LD_VAR 0 10
12966: PPUSH
12967: LD_VAR 0 11
12971: PPUSH
12972: CALL_OW 298
12976: ST_TO_ADDR
// end ; eswTX := eswTX + 10 ;
12977: LD_ADDR_VAR 0 10
12981: PUSH
12982: LD_VAR 0 10
12986: PUSH
12987: LD_INT 10
12989: PLUS
12990: ST_TO_ADDR
// end ;
12991: GO 12883
// eswTX := map_size_x div 2 ;
12993: LD_ADDR_VAR 0 10
12997: PUSH
12998: LD_EXP 28
13002: PUSH
13003: LD_INT 2
13005: DIV
13006: ST_TO_ADDR
// eswTY := map_size_y - 1 ;
13007: LD_ADDR_VAR 0 11
13011: PUSH
13012: LD_EXP 29
13016: PUSH
13017: LD_INT 1
13019: MINUS
13020: ST_TO_ADDR
// while eswTX < ( map_size_x + map_size_x div 2 ) do
13021: LD_VAR 0 10
13025: PUSH
13026: LD_EXP 28
13030: PUSH
13031: LD_EXP 28
13035: PUSH
13036: LD_INT 2
13038: DIV
13039: PLUS
13040: LESS
13041: IFFALSE 13141
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
13043: LD_VAR 0 1
13047: PPUSH
13048: LD_VAR 0 2
13052: PPUSH
13053: LD_VAR 0 10
13057: PPUSH
13058: LD_VAR 0 11
13062: PPUSH
13063: CALL_OW 298
13067: PUSH
13068: LD_VAR 0 9
13072: LESS
13073: IFFALSE 13125
// begin foundswX := eswTX ;
13075: LD_ADDR_VAR 0 7
13079: PUSH
13080: LD_VAR 0 10
13084: ST_TO_ADDR
// foundswY := eswTY ;
13085: LD_ADDR_VAR 0 8
13089: PUSH
13090: LD_VAR 0 11
13094: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
13095: LD_ADDR_VAR 0 9
13099: PUSH
13100: LD_VAR 0 1
13104: PPUSH
13105: LD_VAR 0 2
13109: PPUSH
13110: LD_VAR 0 10
13114: PPUSH
13115: LD_VAR 0 11
13119: PPUSH
13120: CALL_OW 298
13124: ST_TO_ADDR
// end ; eswTX := eswTX + 10 ;
13125: LD_ADDR_VAR 0 10
13129: PUSH
13130: LD_VAR 0 10
13134: PUSH
13135: LD_INT 10
13137: PLUS
13138: ST_TO_ADDR
// end ;
13139: GO 13021
// eswTX := 0 ;
13141: LD_ADDR_VAR 0 10
13145: PUSH
13146: LD_INT 0
13148: ST_TO_ADDR
// eswTY := 0 ;
13149: LD_ADDR_VAR 0 11
13153: PUSH
13154: LD_INT 0
13156: ST_TO_ADDR
// while eswTY < ( map_size_y ) do
13157: LD_VAR 0 11
13161: PUSH
13162: LD_EXP 29
13166: LESS
13167: IFFALSE 13281
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
13169: LD_VAR 0 1
13173: PPUSH
13174: LD_VAR 0 2
13178: PPUSH
13179: LD_VAR 0 10
13183: PPUSH
13184: LD_VAR 0 11
13188: PPUSH
13189: CALL_OW 298
13193: PUSH
13194: LD_VAR 0 9
13198: LESS
13199: IFFALSE 13251
// begin foundswX := eswTX ;
13201: LD_ADDR_VAR 0 7
13205: PUSH
13206: LD_VAR 0 10
13210: ST_TO_ADDR
// foundswY := eswTY ;
13211: LD_ADDR_VAR 0 8
13215: PUSH
13216: LD_VAR 0 11
13220: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
13221: LD_ADDR_VAR 0 9
13225: PUSH
13226: LD_VAR 0 1
13230: PPUSH
13231: LD_VAR 0 2
13235: PPUSH
13236: LD_VAR 0 10
13240: PPUSH
13241: LD_VAR 0 11
13245: PPUSH
13246: CALL_OW 298
13250: ST_TO_ADDR
// end ; eswTY := eswTY + 10 ;
13251: LD_ADDR_VAR 0 11
13255: PUSH
13256: LD_VAR 0 11
13260: PUSH
13261: LD_INT 10
13263: PLUS
13264: ST_TO_ADDR
// eswTX := eswTX + 5 ;
13265: LD_ADDR_VAR 0 10
13269: PUSH
13270: LD_VAR 0 10
13274: PUSH
13275: LD_INT 5
13277: PLUS
13278: ST_TO_ADDR
// end ;
13279: GO 13157
// eswTX := map_size_x ;
13281: LD_ADDR_VAR 0 10
13285: PUSH
13286: LD_EXP 28
13290: ST_TO_ADDR
// eswTY := 1 ;
13291: LD_ADDR_VAR 0 11
13295: PUSH
13296: LD_INT 1
13298: ST_TO_ADDR
// while eswTY < ( map_size_y ) do
13299: LD_VAR 0 11
13303: PUSH
13304: LD_EXP 29
13308: LESS
13309: IFFALSE 13423
// begin if GetDistXY ( unx , uny , eswTX , eswTY ) < foundswD then
13311: LD_VAR 0 1
13315: PPUSH
13316: LD_VAR 0 2
13320: PPUSH
13321: LD_VAR 0 10
13325: PPUSH
13326: LD_VAR 0 11
13330: PPUSH
13331: CALL_OW 298
13335: PUSH
13336: LD_VAR 0 9
13340: LESS
13341: IFFALSE 13393
// begin foundswX := eswTX ;
13343: LD_ADDR_VAR 0 7
13347: PUSH
13348: LD_VAR 0 10
13352: ST_TO_ADDR
// foundswY := eswTY ;
13353: LD_ADDR_VAR 0 8
13357: PUSH
13358: LD_VAR 0 11
13362: ST_TO_ADDR
// foundswD := GetDistXY ( unx , uny , eswTX , eswTY ) ;
13363: LD_ADDR_VAR 0 9
13367: PUSH
13368: LD_VAR 0 1
13372: PPUSH
13373: LD_VAR 0 2
13377: PPUSH
13378: LD_VAR 0 10
13382: PPUSH
13383: LD_VAR 0 11
13387: PPUSH
13388: CALL_OW 298
13392: ST_TO_ADDR
// end ; eswTY := eswTY + 10 ;
13393: LD_ADDR_VAR 0 11
13397: PUSH
13398: LD_VAR 0 11
13402: PUSH
13403: LD_INT 10
13405: PLUS
13406: ST_TO_ADDR
// eswTX := eswTX + 5 ;
13407: LD_ADDR_VAR 0 10
13411: PUSH
13412: LD_VAR 0 10
13416: PUSH
13417: LD_INT 5
13419: PLUS
13420: ST_TO_ADDR
// end ;
13421: GO 13299
// if queue then
13423: LD_VAR 0 4
13427: IFFALSE 13501
// begin if agressive then
13429: LD_VAR 0 5
13433: IFFALSE 13468
// begin AddComAgressiveMove ( for_unit , foundswX , foundswY ) ;
13435: LD_VAR 0 12
13439: PPUSH
13440: LD_VAR 0 7
13444: PPUSH
13445: LD_VAR 0 8
13449: PPUSH
13450: CALL_OW 174
// AddComMoveToArea ( for_unit , border ) ;
13454: LD_VAR 0 12
13458: PPUSH
13459: LD_INT 7
13461: PPUSH
13462: CALL_OW 173
// end else
13466: GO 13499
// begin AddComMoveXY ( for_unit , foundswX , foundswY ) ;
13468: LD_VAR 0 12
13472: PPUSH
13473: LD_VAR 0 7
13477: PPUSH
13478: LD_VAR 0 8
13482: PPUSH
13483: CALL_OW 171
// AddComMoveToArea ( for_unit , border ) ;
13487: LD_VAR 0 12
13491: PPUSH
13492: LD_INT 7
13494: PPUSH
13495: CALL_OW 173
// end ; end else
13499: GO 13571
// begin if agressive then
13501: LD_VAR 0 5
13505: IFFALSE 13540
// begin ComAgressiveMove ( for_unit , foundswX , foundswY ) ;
13507: LD_VAR 0 12
13511: PPUSH
13512: LD_VAR 0 7
13516: PPUSH
13517: LD_VAR 0 8
13521: PPUSH
13522: CALL_OW 114
// AddComMoveToArea ( for_unit , border ) ;
13526: LD_VAR 0 12
13530: PPUSH
13531: LD_INT 7
13533: PPUSH
13534: CALL_OW 173
// end else
13538: GO 13571
// begin ComMoveXY ( for_unit , foundswX , foundswY ) ;
13540: LD_VAR 0 12
13544: PPUSH
13545: LD_VAR 0 7
13549: PPUSH
13550: LD_VAR 0 8
13554: PPUSH
13555: CALL_OW 111
// AddComMoveToArea ( for_unit , border ) ;
13559: LD_VAR 0 12
13563: PPUSH
13564: LD_INT 7
13566: PPUSH
13567: CALL_OW 173
// end ; end ; end ;
13571: GO 12856
13573: POP
13574: POP
// end ;
13575: LD_VAR 0 6
13579: RET
// export function get_live_from_list ( sez1 , skip , pocet ) ; var un1 , count , max , skiped ; var list ; begin
13580: LD_INT 0
13582: PPUSH
13583: PPUSH
13584: PPUSH
13585: PPUSH
13586: PPUSH
13587: PPUSH
// un1 := 1 ;
13588: LD_ADDR_VAR 0 5
13592: PUSH
13593: LD_INT 1
13595: ST_TO_ADDR
// count := 0 ;
13596: LD_ADDR_VAR 0 6
13600: PUSH
13601: LD_INT 0
13603: ST_TO_ADDR
// skiped := 0 ;
13604: LD_ADDR_VAR 0 8
13608: PUSH
13609: LD_INT 0
13611: ST_TO_ADDR
// max := ( sez1 + 0 ) ;
13612: LD_ADDR_VAR 0 7
13616: PUSH
13617: LD_VAR 0 1
13621: PUSH
13622: LD_INT 0
13624: PLUS
13625: ST_TO_ADDR
// while un1 <= max and count < pocet do
13626: LD_VAR 0 5
13630: PUSH
13631: LD_VAR 0 7
13635: LESSEQUAL
13636: PUSH
13637: LD_VAR 0 6
13641: PUSH
13642: LD_VAR 0 3
13646: LESS
13647: AND
13648: IFFALSE 13771
// begin if IsLive ( sez1 [ un1 ] ) then
13650: LD_VAR 0 1
13654: PUSH
13655: LD_VAR 0 5
13659: ARRAY
13660: PPUSH
13661: CALL_OW 300
13665: IFFALSE 13755
// begin if skiped >= skip then
13667: LD_VAR 0 8
13671: PUSH
13672: LD_VAR 0 2
13676: GREATEREQUAL
13677: IFFALSE 13741
// begin if list then
13679: LD_VAR 0 9
13683: IFFALSE 13709
// list := list ^ sez1 [ un1 ] else
13685: LD_ADDR_VAR 0 9
13689: PUSH
13690: LD_VAR 0 9
13694: PUSH
13695: LD_VAR 0 1
13699: PUSH
13700: LD_VAR 0 5
13704: ARRAY
13705: ADD
13706: ST_TO_ADDR
13707: GO 13725
// list := sez1 [ un1 ] ;
13709: LD_ADDR_VAR 0 9
13713: PUSH
13714: LD_VAR 0 1
13718: PUSH
13719: LD_VAR 0 5
13723: ARRAY
13724: ST_TO_ADDR
// count := count + 1 ;
13725: LD_ADDR_VAR 0 6
13729: PUSH
13730: LD_VAR 0 6
13734: PUSH
13735: LD_INT 1
13737: PLUS
13738: ST_TO_ADDR
// end else
13739: GO 13755
// begin skiped := skiped + 1 ;
13741: LD_ADDR_VAR 0 8
13745: PUSH
13746: LD_VAR 0 8
13750: PUSH
13751: LD_INT 1
13753: PLUS
13754: ST_TO_ADDR
// end ; end ; un1 := un1 + 1 ;
13755: LD_ADDR_VAR 0 5
13759: PUSH
13760: LD_VAR 0 5
13764: PUSH
13765: LD_INT 1
13767: PLUS
13768: ST_TO_ADDR
// end ;
13769: GO 13626
// result := list ;
13771: LD_ADDR_VAR 0 4
13775: PUSH
13776: LD_VAR 0 9
13780: ST_TO_ADDR
// end ;
13781: LD_VAR 0 4
13785: RET
// export function see_any ( strana , sez2 ) ; var sai , see_any_r ; begin
13786: LD_INT 0
13788: PPUSH
13789: PPUSH
13790: PPUSH
// see_any_r := false ;
13791: LD_ADDR_VAR 0 5
13795: PUSH
13796: LD_INT 0
13798: ST_TO_ADDR
// for sai in sez2 do
13799: LD_ADDR_VAR 0 4
13803: PUSH
13804: LD_VAR 0 2
13808: PUSH
13809: FOR_IN
13810: IFFALSE 13840
// if See ( strana , sai ) then
13812: LD_VAR 0 1
13816: PPUSH
13817: LD_VAR 0 4
13821: PPUSH
13822: CALL_OW 292
13826: IFFALSE 13838
// begin see_any_r := true ;
13828: LD_ADDR_VAR 0 5
13832: PUSH
13833: LD_INT 1
13835: ST_TO_ADDR
// break ;
13836: GO 13840
// end ;
13838: GO 13809
13840: POP
13841: POP
// ; result := see_any_r ;
13842: LD_ADDR_VAR 0 3
13846: PUSH
13847: LD_VAR 0 5
13851: ST_TO_ADDR
// end ;
13852: LD_VAR 0 3
13856: RET
// export function enter_near_vehicle ( who , dist , what ) ; var add , i , j ; begin
13857: LD_INT 0
13859: PPUSH
13860: PPUSH
13861: PPUSH
13862: PPUSH
// for i in who do
13863: LD_ADDR_VAR 0 6
13867: PUSH
13868: LD_VAR 0 1
13872: PUSH
13873: FOR_IN
13874: IFFALSE 13945
// begin for j in what do
13876: LD_ADDR_VAR 0 7
13880: PUSH
13881: LD_VAR 0 3
13885: PUSH
13886: FOR_IN
13887: IFFALSE 13941
// begin if not IsDrivenBy ( j ) and GetDistUnits ( i , j ) <= dist then
13889: LD_VAR 0 7
13893: PPUSH
13894: CALL_OW 311
13898: NOT
13899: PUSH
13900: LD_VAR 0 6
13904: PPUSH
13905: LD_VAR 0 7
13909: PPUSH
13910: CALL_OW 296
13914: PUSH
13915: LD_VAR 0 2
13919: LESSEQUAL
13920: AND
13921: IFFALSE 13939
// begin ComEnterUnit ( i , j ) ;
13923: LD_VAR 0 6
13927: PPUSH
13928: LD_VAR 0 7
13932: PPUSH
13933: CALL_OW 120
// break ;
13937: GO 13941
// end ; end ;
13939: GO 13886
13941: POP
13942: POP
// end ;
13943: GO 13873
13945: POP
13946: POP
// end ;
13947: LD_VAR 0 4
13951: RET
// export function any_near ( who , dist , what ) ; var add , i , j ; begin
13952: LD_INT 0
13954: PPUSH
13955: PPUSH
13956: PPUSH
13957: PPUSH
// for i in who do
13958: LD_ADDR_VAR 0 6
13962: PUSH
13963: LD_VAR 0 1
13967: PUSH
13968: FOR_IN
13969: IFFALSE 14068
// begin add := false ;
13971: LD_ADDR_VAR 0 5
13975: PUSH
13976: LD_INT 0
13978: ST_TO_ADDR
// for j in what do
13979: LD_ADDR_VAR 0 7
13983: PUSH
13984: LD_VAR 0 3
13988: PUSH
13989: FOR_IN
13990: IFFALSE 14024
// begin if GetDistUnits ( i , j ) <= dist then
13992: LD_VAR 0 6
13996: PPUSH
13997: LD_VAR 0 7
14001: PPUSH
14002: CALL_OW 296
14006: PUSH
14007: LD_VAR 0 2
14011: LESSEQUAL
14012: IFFALSE 14022
// begin add := true ;
14014: LD_ADDR_VAR 0 5
14018: PUSH
14019: LD_INT 1
14021: ST_TO_ADDR
// end ; end ;
14022: GO 13989
14024: POP
14025: POP
// if add then
14026: LD_VAR 0 5
14030: IFFALSE 14066
// begin if result then
14032: LD_VAR 0 4
14036: IFFALSE 14056
// result := result ^ i else
14038: LD_ADDR_VAR 0 4
14042: PUSH
14043: LD_VAR 0 4
14047: PUSH
14048: LD_VAR 0 6
14052: ADD
14053: ST_TO_ADDR
14054: GO 14066
// result := i ;
14056: LD_ADDR_VAR 0 4
14060: PUSH
14061: LD_VAR 0 6
14065: ST_TO_ADDR
// end ; end ;
14066: GO 13968
14068: POP
14069: POP
// end ;
14070: LD_VAR 0 4
14074: RET
// export function comqb ; begin
14075: LD_INT 0
14077: PPUSH
// com_queue := true ;
14078: LD_ADDR_OWVAR 49
14082: PUSH
14083: LD_INT 1
14085: ST_TO_ADDR
// end ;
14086: LD_VAR 0 1
14090: RET
// export function comqe ; begin
14091: LD_INT 0
14093: PPUSH
// com_queue := false ;
14094: LD_ADDR_OWVAR 49
14098: PUSH
14099: LD_INT 0
14101: ST_TO_ADDR
// end ;
14102: LD_VAR 0 1
14106: RET
// export function take_path ( for_units , path , agressive ) ; var i1 ; var a ; begin
14107: LD_INT 0
14109: PPUSH
14110: PPUSH
14111: PPUSH
// i1 := 1 ;
14112: LD_ADDR_VAR 0 5
14116: PUSH
14117: LD_INT 1
14119: ST_TO_ADDR
// while i1 <= path do
14120: LD_VAR 0 5
14124: PUSH
14125: LD_VAR 0 2
14129: LESSEQUAL
14130: IFFALSE 14377
// begin a := path [ i1 ] ;
14132: LD_ADDR_VAR 0 6
14136: PUSH
14137: LD_VAR 0 2
14141: PUSH
14142: LD_VAR 0 5
14146: ARRAY
14147: ST_TO_ADDR
// if a < 0 then
14148: LD_VAR 0 6
14152: PUSH
14153: LD_INT 0
14155: LESS
14156: IFFALSE 14213
// begin while a <= - 1 do
14158: LD_VAR 0 6
14162: PUSH
14163: LD_INT 1
14165: NEG
14166: LESSEQUAL
14167: IFFALSE 14197
// begin a := a + 1 ;
14169: LD_ADDR_VAR 0 6
14173: PUSH
14174: LD_VAR 0 6
14178: PUSH
14179: LD_INT 1
14181: PLUS
14182: ST_TO_ADDR
// AddComWait ( for_units , 0 0$1 ) ;
14183: LD_VAR 0 1
14187: PPUSH
14188: LD_INT 35
14190: PPUSH
14191: CALL_OW 202
// end ;
14195: GO 14158
// i1 := i1 + 1 ;
14197: LD_ADDR_VAR 0 5
14201: PUSH
14202: LD_VAR 0 5
14206: PUSH
14207: LD_INT 1
14209: PLUS
14210: ST_TO_ADDR
// end else
14211: GO 14375
// begin if a = 0 then
14213: LD_VAR 0 6
14217: PUSH
14218: LD_INT 0
14220: EQUAL
14221: IFFALSE 14283
// begin a := path [ i1 + 1 ] ;
14223: LD_ADDR_VAR 0 6
14227: PUSH
14228: LD_VAR 0 2
14232: PUSH
14233: LD_VAR 0 5
14237: PUSH
14238: LD_INT 1
14240: PLUS
14241: ARRAY
14242: ST_TO_ADDR
// if a = 0 then
14243: LD_VAR 0 6
14247: PUSH
14248: LD_INT 0
14250: EQUAL
14251: IFFALSE 14262
// AddComReturn ( for_units ) ;
14253: LD_VAR 0 1
14257: PPUSH
14258: CALL_OW 204
// if a = 1 then
14262: LD_VAR 0 6
14266: PUSH
14267: LD_INT 1
14269: EQUAL
14270: IFFALSE 14281
// AddComRemember ( for_units ) ;
14272: LD_VAR 0 1
14276: PPUSH
14277: CALL_OW 203
// end else
14281: GO 14361
// begin if agressive then
14283: LD_VAR 0 3
14287: IFFALSE 14326
// AddComAgressiveMove ( for_units , path [ i1 ] , path [ i1 + 1 ] ) else
14289: LD_VAR 0 1
14293: PPUSH
14294: LD_VAR 0 2
14298: PUSH
14299: LD_VAR 0 5
14303: ARRAY
14304: PPUSH
14305: LD_VAR 0 2
14309: PUSH
14310: LD_VAR 0 5
14314: PUSH
14315: LD_INT 1
14317: PLUS
14318: ARRAY
14319: PPUSH
14320: CALL_OW 174
14324: GO 14361
// AddComMoveXY ( for_units , path [ i1 ] , path [ i1 + 1 ] ) ;
14326: LD_VAR 0 1
14330: PPUSH
14331: LD_VAR 0 2
14335: PUSH
14336: LD_VAR 0 5
14340: ARRAY
14341: PPUSH
14342: LD_VAR 0 2
14346: PUSH
14347: LD_VAR 0 5
14351: PUSH
14352: LD_INT 1
14354: PLUS
14355: ARRAY
14356: PPUSH
14357: CALL_OW 171
// end ; i1 := i1 + 2 ;
14361: LD_ADDR_VAR 0 5
14365: PUSH
14366: LD_VAR 0 5
14370: PUSH
14371: LD_INT 2
14373: PLUS
14374: ST_TO_ADDR
// end ; end ;
14375: GO 14120
// end ;
14377: LD_VAR 0 4
14381: RET
// export function find_drivers ( cars , drivers ) ; var empty , free , i , konec ; begin
14382: LD_INT 0
14384: PPUSH
14385: PPUSH
14386: PPUSH
14387: PPUSH
14388: PPUSH
// cars := cars union [ ] ;
14389: LD_ADDR_VAR 0 1
14393: PUSH
14394: LD_VAR 0 1
14398: PUSH
14399: EMPTY
14400: UNION
14401: ST_TO_ADDR
// drivers := drivers union [ ] ;
14402: LD_ADDR_VAR 0 2
14406: PUSH
14407: LD_VAR 0 2
14411: PUSH
14412: EMPTY
14413: UNION
14414: ST_TO_ADDR
// for i in cars do
14415: LD_ADDR_VAR 0 6
14419: PUSH
14420: LD_VAR 0 1
14424: PUSH
14425: FOR_IN
14426: IFFALSE 14462
// if not IsDrivenBy ( i ) then
14428: LD_VAR 0 6
14432: PPUSH
14433: CALL_OW 311
14437: NOT
14438: IFFALSE 14460
// empty := add ( empty , i ) ;
14440: LD_ADDR_VAR 0 4
14444: PUSH
14445: LD_VAR 0 4
14449: PPUSH
14450: LD_VAR 0 6
14454: PPUSH
14455: CALL 14751 0 2
14459: ST_TO_ADDR
14460: GO 14425
14462: POP
14463: POP
// for i in drivers do
14464: LD_ADDR_VAR 0 6
14468: PUSH
14469: LD_VAR 0 2
14473: PUSH
14474: FOR_IN
14475: IFFALSE 14511
// if not IsInUnit ( i ) then
14477: LD_VAR 0 6
14481: PPUSH
14482: CALL_OW 310
14486: NOT
14487: IFFALSE 14509
// free := add ( free , i ) ;
14489: LD_ADDR_VAR 0 5
14493: PUSH
14494: LD_VAR 0 5
14498: PPUSH
14499: LD_VAR 0 6
14503: PPUSH
14504: CALL 14751 0 2
14508: ST_TO_ADDR
14509: GO 14474
14511: POP
14512: POP
// result := cars diff empty ;
14513: LD_ADDR_VAR 0 3
14517: PUSH
14518: LD_VAR 0 1
14522: PUSH
14523: LD_VAR 0 4
14527: DIFF
14528: ST_TO_ADDR
// if empty <= free then
14529: LD_VAR 0 4
14533: PUSH
14534: LD_VAR 0 5
14538: LESSEQUAL
14539: IFFALSE 14553
// konec := empty else
14541: LD_ADDR_VAR 0 7
14545: PUSH
14546: LD_VAR 0 4
14550: ST_TO_ADDR
14551: GO 14563
// konec := free ;
14553: LD_ADDR_VAR 0 7
14557: PUSH
14558: LD_VAR 0 5
14562: ST_TO_ADDR
// for i := 1 to konec do
14563: LD_ADDR_VAR 0 6
14567: PUSH
14568: DOUBLE
14569: LD_INT 1
14571: DEC
14572: ST_TO_ADDR
14573: LD_VAR 0 7
14577: PUSH
14578: FOR_TO
14579: IFFALSE 14635
// begin ComEnterUnit ( free [ i ] , empty [ i ] ) ;
14581: LD_VAR 0 5
14585: PUSH
14586: LD_VAR 0 6
14590: ARRAY
14591: PPUSH
14592: LD_VAR 0 4
14596: PUSH
14597: LD_VAR 0 6
14601: ARRAY
14602: PPUSH
14603: CALL_OW 120
// result := add ( result , empty [ i ] ) ;
14607: LD_ADDR_VAR 0 3
14611: PUSH
14612: LD_VAR 0 3
14616: PPUSH
14617: LD_VAR 0 4
14621: PUSH
14622: LD_VAR 0 6
14626: ARRAY
14627: PPUSH
14628: CALL 14751 0 2
14632: ST_TO_ADDR
// end ;
14633: GO 14578
14635: POP
14636: POP
// end ;
14637: LD_VAR 0 3
14641: RET
// export function rand_xy_in_map ; var x , y ; begin
14642: LD_INT 0
14644: PPUSH
14645: PPUSH
14646: PPUSH
// y := Rand ( 2 , map_size_y - 2 ) ;
14647: LD_ADDR_VAR 0 3
14651: PUSH
14652: LD_INT 2
14654: PPUSH
14655: LD_EXP 29
14659: PUSH
14660: LD_INT 2
14662: MINUS
14663: PPUSH
14664: CALL_OW 12
14668: ST_TO_ADDR
// x := Rand ( y div 2 + 2 , map_size_x + y div 2 - 2 ) ;
14669: LD_ADDR_VAR 0 2
14673: PUSH
14674: LD_VAR 0 3
14678: PUSH
14679: LD_INT 2
14681: DIV
14682: PUSH
14683: LD_INT 2
14685: PLUS
14686: PPUSH
14687: LD_EXP 28
14691: PUSH
14692: LD_VAR 0 3
14696: PUSH
14697: LD_INT 2
14699: DIV
14700: PLUS
14701: PUSH
14702: LD_INT 2
14704: MINUS
14705: PPUSH
14706: CALL_OW 12
14710: ST_TO_ADDR
// result := [ x , y ] ;
14711: LD_ADDR_VAR 0 1
14715: PUSH
14716: LD_VAR 0 2
14720: PUSH
14721: LD_VAR 0 3
14725: PUSH
14726: EMPTY
14727: LIST
14728: LIST
14729: ST_TO_ADDR
// end ;
14730: LD_VAR 0 1
14734: RET
// export function TalkOn ; begin
14735: LD_INT 0
14737: PPUSH
// end ;
14738: LD_VAR 0 1
14742: RET
// export function TalkOff ; begin
14743: LD_INT 0
14745: PPUSH
// end ;
14746: LD_VAR 0 1
14750: RET
// export function add ( list , list1 ) ; begin
14751: LD_INT 0
14753: PPUSH
// if list = 0 then
14754: LD_VAR 0 1
14758: PUSH
14759: LD_INT 0
14761: EQUAL
14762: IFFALSE 14771
// list := [ ] ;
14764: LD_ADDR_VAR 0 1
14768: PUSH
14769: EMPTY
14770: ST_TO_ADDR
// if list1 = 0 then
14771: LD_VAR 0 2
14775: PUSH
14776: LD_INT 0
14778: EQUAL
14779: IFFALSE 14788
// list1 := [ ] ;
14781: LD_ADDR_VAR 0 2
14785: PUSH
14786: EMPTY
14787: ST_TO_ADDR
// result := list ^ list1 ;
14788: LD_ADDR_VAR 0 3
14792: PUSH
14793: LD_VAR 0 1
14797: PUSH
14798: LD_VAR 0 2
14802: ADD
14803: ST_TO_ADDR
// end ;
14804: LD_VAR 0 3
14808: RET
// export function SayAny ( lidi , ident , side , sex , Hclass , index ) ; var kdo ; begin
14809: LD_INT 0
14811: PPUSH
14812: PPUSH
// kdo := WhoSayAny ( lidi , side , sex , Hclass , index ) ;
14813: LD_ADDR_VAR 0 8
14817: PUSH
14818: LD_VAR 0 1
14822: PPUSH
14823: LD_VAR 0 3
14827: PPUSH
14828: LD_VAR 0 4
14832: PPUSH
14833: LD_VAR 0 5
14837: PPUSH
14838: LD_VAR 0 6
14842: PPUSH
14843: CALL 14889 0 5
14847: ST_TO_ADDR
// if kdo then
14848: LD_VAR 0 8
14852: IFFALSE 14876
// result := Say ( kdo , ident ) else
14854: LD_ADDR_VAR 0 7
14858: PUSH
14859: LD_VAR 0 8
14863: PPUSH
14864: LD_VAR 0 2
14868: PPUSH
14869: CALL_OW 88
14873: ST_TO_ADDR
14874: GO 14884
// result := false ;
14876: LD_ADDR_VAR 0 7
14880: PUSH
14881: LD_INT 0
14883: ST_TO_ADDR
// end ;
14884: LD_VAR 0 7
14888: RET
// export function WhoSayAny ( lidi , side , sex , Hclass , index ) ; begin
14889: LD_INT 0
14891: PPUSH
// lidi := UnitFilter ( lidi , [ [ f_type , unit_human ] , [ f_side , side ] , f_not , [ f_nation , nation_nature ] ] ) ;
14892: LD_ADDR_VAR 0 1
14896: PUSH
14897: LD_VAR 0 1
14901: PPUSH
14902: LD_INT 21
14904: PUSH
14905: LD_INT 1
14907: PUSH
14908: EMPTY
14909: LIST
14910: LIST
14911: PUSH
14912: LD_INT 22
14914: PUSH
14915: LD_VAR 0 2
14919: PUSH
14920: EMPTY
14921: LIST
14922: LIST
14923: PUSH
14924: LD_INT 3
14926: PUSH
14927: LD_INT 23
14929: PUSH
14930: LD_INT 0
14932: PUSH
14933: EMPTY
14934: LIST
14935: LIST
14936: PUSH
14937: EMPTY
14938: LIST
14939: LIST
14940: LIST
14941: LIST
14942: PPUSH
14943: CALL_OW 72
14947: ST_TO_ADDR
// if sex <> 0 then
14948: LD_VAR 0 3
14952: PUSH
14953: LD_INT 0
14955: NONEQUAL
14956: IFFALSE 14985
// lidi := UnitFilter ( lidi , [ f_sex , sex ] ) ;
14958: LD_ADDR_VAR 0 1
14962: PUSH
14963: LD_VAR 0 1
14967: PPUSH
14968: LD_INT 26
14970: PUSH
14971: LD_VAR 0 3
14975: PUSH
14976: EMPTY
14977: LIST
14978: LIST
14979: PPUSH
14980: CALL_OW 72
14984: ST_TO_ADDR
// if Hclass <> 0 then
14985: LD_VAR 0 4
14989: PUSH
14990: LD_INT 0
14992: NONEQUAL
14993: IFFALSE 15022
// lidi := UnitFilter ( lidi , [ f_class , Hclass ] ) ;
14995: LD_ADDR_VAR 0 1
14999: PUSH
15000: LD_VAR 0 1
15004: PPUSH
15005: LD_INT 25
15007: PUSH
15008: LD_VAR 0 4
15012: PUSH
15013: EMPTY
15014: LIST
15015: LIST
15016: PPUSH
15017: CALL_OW 72
15021: ST_TO_ADDR
// if index <= 0 then
15022: LD_VAR 0 5
15026: PUSH
15027: LD_INT 0
15029: LESSEQUAL
15030: IFFALSE 15040
// index := 1 ;
15032: LD_ADDR_VAR 0 5
15036: PUSH
15037: LD_INT 1
15039: ST_TO_ADDR
// if lidi >= index then
15040: LD_VAR 0 1
15044: PUSH
15045: LD_VAR 0 5
15049: GREATEREQUAL
15050: IFFALSE 15070
// result := lidi [ index ] else
15052: LD_ADDR_VAR 0 6
15056: PUSH
15057: LD_VAR 0 1
15061: PUSH
15062: LD_VAR 0 5
15066: ARRAY
15067: ST_TO_ADDR
15068: GO 15078
// result := 0 ;
15070: LD_ADDR_VAR 0 6
15074: PUSH
15075: LD_INT 0
15077: ST_TO_ADDR
// end ;
15078: LD_VAR 0 6
15082: RET
// export hinty_co_byli ; export function MyHint ( ident ) ; begin
15083: LD_INT 0
15085: PPUSH
// if not hinty_co_byli then
15086: LD_EXP 65
15090: NOT
15091: IFFALSE 15100
// hinty_co_byli := [ ] ;
15093: LD_ADDR_EXP 65
15097: PUSH
15098: EMPTY
15099: ST_TO_ADDR
// if not ( ident in hinty_co_byli ) then
15100: LD_VAR 0 1
15104: PUSH
15105: LD_EXP 65
15109: IN
15110: NOT
15111: IFFALSE 15138
// begin hinty_co_byli := hinty_co_byli ^ ident ;
15113: LD_ADDR_EXP 65
15117: PUSH
15118: LD_EXP 65
15122: PUSH
15123: LD_VAR 0 1
15127: ADD
15128: ST_TO_ADDR
// Hint ( ident ) ;
15129: LD_VAR 0 1
15133: PPUSH
15134: CALL_OW 339
// end ; end ; end_of_file
15138: LD_VAR 0 2
15142: RET
// every 0 0$2 + 0 0$0.1 do
15143: GO 15145
15145: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
15146: LD_INT 22
15148: PUSH
15149: LD_INT 1
15151: PUSH
15152: EMPTY
15153: LIST
15154: LIST
15155: PUSH
15156: LD_INT 2
15158: PUSH
15159: LD_INT 25
15161: PUSH
15162: LD_INT 12
15164: PUSH
15165: EMPTY
15166: LIST
15167: LIST
15168: PUSH
15169: LD_INT 25
15171: PUSH
15172: LD_INT 16
15174: PUSH
15175: EMPTY
15176: LIST
15177: LIST
15178: PUSH
15179: LD_INT 25
15181: PUSH
15182: LD_INT 15
15184: PUSH
15185: EMPTY
15186: LIST
15187: LIST
15188: PUSH
15189: LD_INT 25
15191: PUSH
15192: LD_INT 17
15194: PUSH
15195: EMPTY
15196: LIST
15197: LIST
15198: PUSH
15199: EMPTY
15200: LIST
15201: LIST
15202: LIST
15203: LIST
15204: LIST
15205: PUSH
15206: EMPTY
15207: LIST
15208: LIST
15209: PPUSH
15210: CALL_OW 69
15214: PUSH
15215: LD_INT 22
15217: PUSH
15218: LD_INT 1
15220: PUSH
15221: EMPTY
15222: LIST
15223: LIST
15224: PUSH
15225: LD_INT 21
15227: PUSH
15228: LD_INT 1
15230: PUSH
15231: EMPTY
15232: LIST
15233: LIST
15234: PUSH
15235: LD_INT 3
15237: PUSH
15238: LD_INT 2
15240: PUSH
15241: LD_INT 25
15243: PUSH
15244: LD_INT 12
15246: PUSH
15247: EMPTY
15248: LIST
15249: LIST
15250: PUSH
15251: LD_INT 25
15253: PUSH
15254: LD_INT 16
15256: PUSH
15257: EMPTY
15258: LIST
15259: LIST
15260: PUSH
15261: LD_INT 25
15263: PUSH
15264: LD_INT 15
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: PUSH
15271: LD_INT 25
15273: PUSH
15274: LD_INT 17
15276: PUSH
15277: EMPTY
15278: LIST
15279: LIST
15280: PUSH
15281: EMPTY
15282: LIST
15283: LIST
15284: LIST
15285: LIST
15286: LIST
15287: PUSH
15288: EMPTY
15289: LIST
15290: LIST
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: LIST
15296: PPUSH
15297: CALL_OW 69
15301: GREATER
15302: IFFALSE 15313
// begin SetAchievement ( ACH_POTA ) ;
15304: LD_STRING ACH_POTA
15306: PPUSH
15307: CALL_OW 543
// exit ;
15311: GO 15314
// end ; enable ;
15313: ENABLE
// end ;
15314: END
