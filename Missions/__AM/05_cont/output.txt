// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 72 0 0
// InitRestrictions ;
  12: CALL 176 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 26
// DebugMode ;
  22: CALL 257 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  26: LD_INT 12
  28: PPUSH
  29: LD_INT 2
  31: PPUSH
  32: CALL 505 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 6 ] [ Difficulty ] ) ;
  36: LD_INT 11
  38: PPUSH
  39: LD_INT 10
  41: PUSH
  42: LD_INT 8
  44: PUSH
  45: LD_INT 6
  47: PUSH
  48: EMPTY
  49: LIST
  50: LIST
  51: LIST
  52: PUSH
  53: LD_OWVAR 67
  57: ARRAY
  58: PPUSH
  59: CALL 505 0 2
// PrepareAmericans ;
  63: CALL 978 0 0
// Action ;
  67: CALL 1876 0 0
// end ;
  71: END
// export debug ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed , apeman_army , radar_researched , radar_builded ; export apeman_counter , arab_spotted , end_mission ; function Init ; begin
  72: LD_INT 0
  74: PPUSH
// debug := true ;
  75: LD_ADDR_EXP 1
  79: PUSH
  80: LD_INT 1
  82: ST_TO_ADDR
// deltaBuilded := false ;
  83: LD_ADDR_EXP 2
  87: PUSH
  88: LD_INT 0
  90: ST_TO_ADDR
// denisArrives := false ;
  91: LD_ADDR_EXP 3
  95: PUSH
  96: LD_INT 0
  98: ST_TO_ADDR
// radar_allowed := false ;
  99: LD_ADDR_EXP 5
 103: PUSH
 104: LD_INT 0
 106: ST_TO_ADDR
// first_apeman_tamed := false ;
 107: LD_ADDR_EXP 6
 111: PUSH
 112: LD_INT 0
 114: ST_TO_ADDR
// arab_spotted := false ;
 115: LD_ADDR_EXP 11
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// end_mission := false ;
 123: LD_ADDR_EXP 12
 127: PUSH
 128: LD_INT 0
 130: ST_TO_ADDR
// apeman_army := false ;
 131: LD_ADDR_EXP 7
 135: PUSH
 136: LD_INT 0
 138: ST_TO_ADDR
// radar_researched := false ;
 139: LD_ADDR_EXP 8
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// radar_builded := false ;
 147: LD_ADDR_EXP 9
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// apeman_counter := 0 ;
 155: LD_ADDR_EXP 10
 159: PUSH
 160: LD_INT 0
 162: ST_TO_ADDR
// Delta := 0 ;
 163: LD_ADDR_EXP 4
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// end ;
 171: LD_VAR 0 1
 175: RET
// function InitRestrictions ; begin
 176: LD_INT 0
 178: PPUSH
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
 179: LD_INT 7
 181: PPUSH
 182: LD_INT 1
 184: PPUSH
 185: LD_INT 1
 187: PPUSH
 188: CALL_OW 324
// SetRestrict ( b_lab_full , 1 , state_enabled ) ;
 192: LD_INT 8
 194: PPUSH
 195: LD_INT 1
 197: PPUSH
 198: LD_INT 1
 200: PPUSH
 201: CALL_OW 324
// SetRestrict ( b_lab_weapon , 1 , state_enabled ) ;
 205: LD_INT 10
 207: PPUSH
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 1
 213: PPUSH
 214: CALL_OW 324
// SetTech ( tech_gatling , 1 , LoadVariable ( GatlingInGamma , 1 ) ) ;
 218: LD_INT 69
 220: PPUSH
 221: LD_INT 1
 223: PPUSH
 224: LD_STRING GatlingInGamma
 226: PPUSH
 227: LD_INT 1
 229: PPUSH
 230: CALL_OW 30
 234: PPUSH
 235: CALL_OW 322
// SetTech ( tech_weap1 , 1 , state_enabled ) ;
 239: LD_INT 51
 241: PPUSH
 242: LD_INT 1
 244: PPUSH
 245: LD_INT 1
 247: PPUSH
 248: CALL_OW 322
// end ;
 252: LD_VAR 0 1
 256: RET
// function DebugMode ; begin
 257: LD_INT 0
 259: PPUSH
// FogOff ( 1 ) ;
 260: LD_INT 1
 262: PPUSH
 263: CALL_OW 344
// Difficulty := 2 ;
 267: LD_ADDR_OWVAR 67
 271: PUSH
 272: LD_INT 2
 274: ST_TO_ADDR
// end ; end_of_file
 275: LD_VAR 0 1
 279: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 280: LD_INT 0
 282: PPUSH
 283: PPUSH
// if exist_mode then
 284: LD_VAR 0 2
 288: IFFALSE 307
// unit := CreateCharacter ( ident ) else
 290: LD_ADDR_VAR 0 4
 294: PUSH
 295: LD_VAR 0 1
 299: PPUSH
 300: CALL_OW 34
 304: ST_TO_ADDR
 305: GO 322
// unit := NewCharacter ( ident ) ;
 307: LD_ADDR_VAR 0 4
 311: PUSH
 312: LD_VAR 0 1
 316: PPUSH
 317: CALL_OW 25
 321: ST_TO_ADDR
// result := unit ;
 322: LD_ADDR_VAR 0 3
 326: PUSH
 327: LD_VAR 0 4
 331: ST_TO_ADDR
// end ;
 332: LD_VAR 0 3
 336: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 337: LD_INT 0
 339: PPUSH
// uc_side := side ;
 340: LD_ADDR_OWVAR 20
 344: PUSH
 345: LD_VAR 0 1
 349: ST_TO_ADDR
// uc_nation := nation ;
 350: LD_ADDR_OWVAR 21
 354: PUSH
 355: LD_VAR 0 2
 359: ST_TO_ADDR
// vc_chassis := chassis ;
 360: LD_ADDR_OWVAR 37
 364: PUSH
 365: LD_VAR 0 3
 369: ST_TO_ADDR
// vc_engine := engine ;
 370: LD_ADDR_OWVAR 39
 374: PUSH
 375: LD_VAR 0 4
 379: ST_TO_ADDR
// vc_control := control ;
 380: LD_ADDR_OWVAR 38
 384: PUSH
 385: LD_VAR 0 5
 389: ST_TO_ADDR
// vc_weapon := weapon ;
 390: LD_ADDR_OWVAR 40
 394: PUSH
 395: LD_VAR 0 6
 399: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 400: LD_ADDR_OWVAR 41
 404: PUSH
 405: LD_VAR 0 7
 409: ST_TO_ADDR
// result := CreateVehicle ;
 410: LD_ADDR_VAR 0 8
 414: PUSH
 415: CALL_OW 45
 419: ST_TO_ADDR
// end ;
 420: LD_VAR 0 8
 424: RET
// export function SayX ( units , ident ) ; var i ; begin
 425: LD_INT 0
 427: PPUSH
 428: PPUSH
// result := false ;
 429: LD_ADDR_VAR 0 3
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// if not units then
 437: LD_VAR 0 1
 441: NOT
 442: IFFALSE 446
// exit ;
 444: GO 500
// for i in units do
 446: LD_ADDR_VAR 0 4
 450: PUSH
 451: LD_VAR 0 1
 455: PUSH
 456: FOR_IN
 457: IFFALSE 498
// if IsOk ( i ) then
 459: LD_VAR 0 4
 463: PPUSH
 464: CALL_OW 302
 468: IFFALSE 496
// begin Say ( i , ident ) ;
 470: LD_VAR 0 4
 474: PPUSH
 475: LD_VAR 0 2
 479: PPUSH
 480: CALL_OW 88
// result := i ;
 484: LD_ADDR_VAR 0 3
 488: PUSH
 489: LD_VAR 0 4
 493: ST_TO_ADDR
// break ;
 494: GO 498
// end ;
 496: GO 456
 498: POP
 499: POP
// end ;
 500: LD_VAR 0 3
 504: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 505: LD_INT 0
 507: PPUSH
 508: PPUSH
// InitUc ;
 509: CALL_OW 18
// InitHc ;
 513: CALL_OW 19
// uc_side := 0 ;
 517: LD_ADDR_OWVAR 20
 521: PUSH
 522: LD_INT 0
 524: ST_TO_ADDR
// uc_nation := 0 ;
 525: LD_ADDR_OWVAR 21
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// for i = 1 to amount do
 533: LD_ADDR_VAR 0 4
 537: PUSH
 538: DOUBLE
 539: LD_INT 1
 541: DEC
 542: ST_TO_ADDR
 543: LD_VAR 0 2
 547: PUSH
 548: FOR_TO
 549: IFFALSE 583
// begin PrepareHuman ( false , class_apeman , 1 ) ;
 551: LD_INT 0
 553: PPUSH
 554: LD_INT 12
 556: PPUSH
 557: LD_INT 1
 559: PPUSH
 560: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 564: CALL_OW 44
 568: PPUSH
 569: LD_VAR 0 1
 573: PPUSH
 574: LD_INT 0
 576: PPUSH
 577: CALL_OW 49
// end ;
 581: GO 548
 583: POP
 584: POP
// end ;
 585: LD_VAR 0 3
 589: RET
// export function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
 590: LD_INT 0
 592: PPUSH
 593: PPUSH
 594: PPUSH
// if not unit then
 595: LD_VAR 0 1
 599: NOT
 600: IFFALSE 604
// exit ;
 602: GO 973
// targets_list := [ ] ;
 604: LD_ADDR_VAR 0 5
 608: PUSH
 609: EMPTY
 610: ST_TO_ADDR
// target := UnitFilter ( enemy_list , [ [ f_lives , 250 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 611: LD_ADDR_VAR 0 4
 615: PUSH
 616: LD_VAR 0 2
 620: PPUSH
 621: LD_INT 24
 623: PUSH
 624: LD_INT 250
 626: PUSH
 627: EMPTY
 628: LIST
 629: LIST
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 34
 636: PUSH
 637: LD_INT 12
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: PUSH
 644: EMPTY
 645: LIST
 646: LIST
 647: PUSH
 648: LD_INT 21
 650: PUSH
 651: LD_INT 2
 653: PUSH
 654: EMPTY
 655: LIST
 656: LIST
 657: PUSH
 658: LD_INT 58
 660: PUSH
 661: EMPTY
 662: LIST
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PPUSH
 670: CALL_OW 72
 674: ST_TO_ADDR
// if target and not IsInUnit ( unit ) then
 675: LD_VAR 0 4
 679: PUSH
 680: LD_VAR 0 1
 684: PPUSH
 685: CALL_OW 310
 689: NOT
 690: AND
 691: IFFALSE 719
// begin ComEnterUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 693: LD_VAR 0 1
 697: PPUSH
 698: LD_VAR 0 4
 702: PPUSH
 703: LD_VAR 0 1
 707: PPUSH
 708: CALL_OW 74
 712: PPUSH
 713: CALL_OW 120
// exit ;
 717: GO 973
// end ; targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
 719: LD_ADDR_VAR 0 5
 723: PUSH
 724: LD_VAR 0 2
 728: PPUSH
 729: LD_INT 21
 731: PUSH
 732: LD_INT 1
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: PUSH
 739: LD_INT 3
 741: PUSH
 742: LD_INT 54
 744: PUSH
 745: EMPTY
 746: LIST
 747: PUSH
 748: EMPTY
 749: LIST
 750: LIST
 751: PUSH
 752: EMPTY
 753: LIST
 754: LIST
 755: PPUSH
 756: CALL_OW 72
 760: PUSH
 761: LD_VAR 0 2
 765: PPUSH
 766: LD_INT 21
 768: PUSH
 769: LD_INT 2
 771: PUSH
 772: EMPTY
 773: LIST
 774: LIST
 775: PPUSH
 776: CALL_OW 72
 780: PUSH
 781: LD_VAR 0 2
 785: PPUSH
 786: LD_INT 21
 788: PUSH
 789: LD_INT 3
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 3
 798: PUSH
 799: LD_INT 58
 801: PUSH
 802: EMPTY
 803: LIST
 804: PUSH
 805: EMPTY
 806: LIST
 807: LIST
 808: PUSH
 809: EMPTY
 810: LIST
 811: LIST
 812: PPUSH
 813: CALL_OW 72
 817: PUSH
 818: LD_VAR 0 2
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: LIST
 827: LIST
 828: ST_TO_ADDR
// for target in targets_list do
 829: LD_ADDR_VAR 0 4
 833: PUSH
 834: LD_VAR 0 5
 838: PUSH
 839: FOR_IN
 840: IFFALSE 971
// begin if target then
 842: LD_VAR 0 4
 846: IFFALSE 969
// if GetTag ( unit ) = 11 and ( GetType ( NearestUnitToUnit ( target , unit ) ) = unit_building or GetWeapon ( NearestUnitToUnit ( target , unit ) ) = us_cargo_bay ) then
 848: LD_VAR 0 1
 852: PPUSH
 853: CALL_OW 110
 857: PUSH
 858: LD_INT 11
 860: EQUAL
 861: PUSH
 862: LD_VAR 0 4
 866: PPUSH
 867: LD_VAR 0 1
 871: PPUSH
 872: CALL_OW 74
 876: PPUSH
 877: CALL_OW 247
 881: PUSH
 882: LD_INT 3
 884: EQUAL
 885: PUSH
 886: LD_VAR 0 4
 890: PPUSH
 891: LD_VAR 0 1
 895: PPUSH
 896: CALL_OW 74
 900: PPUSH
 901: CALL_OW 264
 905: PUSH
 906: LD_INT 12
 908: EQUAL
 909: OR
 910: AND
 911: IFFALSE 945
// ComPlaceDelayedCharge ( unit , 0 , 0 , NearestUnitToUnit ( target , unit ) ) else
 913: LD_VAR 0 1
 917: PPUSH
 918: LD_INT 0
 920: PPUSH
 921: LD_INT 0
 923: PPUSH
 924: LD_VAR 0 4
 928: PPUSH
 929: LD_VAR 0 1
 933: PPUSH
 934: CALL_OW 74
 938: PPUSH
 939: CALL_OW 132
 943: GO 969
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 945: LD_VAR 0 1
 949: PPUSH
 950: LD_VAR 0 4
 954: PPUSH
 955: LD_VAR 0 1
 959: PPUSH
 960: CALL_OW 74
 964: PPUSH
 965: CALL_OW 115
// end ;
 969: GO 839
 971: POP
 972: POP
// end ; end_of_file
 973: LD_VAR 0 3
 977: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
 978: LD_INT 0
 980: PPUSH
 981: PPUSH
 982: PPUSH
 983: PPUSH
 984: PPUSH
// uc_nation := 1 ;
 985: LD_ADDR_OWVAR 21
 989: PUSH
 990: LD_INT 1
 992: ST_TO_ADDR
// uc_side := 4 ;
 993: LD_ADDR_OWVAR 20
 997: PUSH
 998: LD_INT 4
1000: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
1001: LD_ADDR_EXP 16
1005: PUSH
1006: LD_STRING Denis
1008: PPUSH
1009: LD_INT 0
1011: PPUSH
1012: CALL 280 0 2
1016: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
1017: LD_ADDR_EXP 15
1021: PUSH
1022: LD_STRING Harisson
1024: PPUSH
1025: LD_INT 0
1027: PPUSH
1028: CALL 280 0 2
1032: ST_TO_ADDR
// uc_side := 1 ;
1033: LD_ADDR_OWVAR 20
1037: PUSH
1038: LD_INT 1
1040: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1041: LD_ADDR_EXP 13
1045: PUSH
1046: LD_STRING JMM
1048: PPUSH
1049: LD_EXP 1
1053: NOT
1054: PPUSH
1055: CALL 280 0 2
1059: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
1060: LD_ADDR_EXP 14
1064: PUSH
1065: LD_STRING Gladstone
1067: PPUSH
1068: LD_INT 0
1070: PPUSH
1071: CALL 280 0 2
1075: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
1076: LD_STRING BrownInDelta
1078: PPUSH
1079: LD_EXP 1
1083: PPUSH
1084: CALL_OW 30
1088: IFFALSE 1125
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1090: LD_ADDR_EXP 17
1094: PUSH
1095: LD_STRING Brown
1097: PPUSH
1098: LD_EXP 1
1102: NOT
1103: PPUSH
1104: CALL 280 0 2
1108: ST_TO_ADDR
// tmp := tmp ^ Brown ;
1109: LD_ADDR_VAR 0 5
1113: PUSH
1114: LD_VAR 0 5
1118: PUSH
1119: LD_EXP 17
1123: ADD
1124: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , 0 ) then
1125: LD_STRING DonaldsonInDelta
1127: PPUSH
1128: LD_INT 0
1130: PPUSH
1131: CALL_OW 30
1135: IFFALSE 1172
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1137: LD_ADDR_EXP 18
1141: PUSH
1142: LD_STRING Donaldson
1144: PPUSH
1145: LD_EXP 1
1149: NOT
1150: PPUSH
1151: CALL 280 0 2
1155: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
1156: LD_ADDR_VAR 0 5
1160: PUSH
1161: LD_VAR 0 5
1165: PUSH
1166: LD_EXP 18
1170: ADD
1171: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
1172: LD_STRING LisaInDelta
1174: PPUSH
1175: LD_EXP 1
1179: PPUSH
1180: CALL_OW 30
1184: IFFALSE 1221
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1186: LD_ADDR_EXP 19
1190: PUSH
1191: LD_STRING Lisa
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: CALL 280 0 2
1204: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
1205: LD_ADDR_VAR 0 5
1209: PUSH
1210: LD_VAR 0 5
1214: PUSH
1215: LD_EXP 19
1219: ADD
1220: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
1221: LD_STRING FrankInDelta
1223: PPUSH
1224: LD_EXP 1
1228: PPUSH
1229: CALL_OW 30
1233: IFFALSE 1270
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
1235: LD_ADDR_EXP 20
1239: PUSH
1240: LD_STRING Frank
1242: PPUSH
1243: LD_EXP 1
1247: NOT
1248: PPUSH
1249: CALL 280 0 2
1253: ST_TO_ADDR
// tmp := tmp ^ Frank ;
1254: LD_ADDR_VAR 0 5
1258: PUSH
1259: LD_VAR 0 5
1263: PUSH
1264: LD_EXP 20
1268: ADD
1269: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
1270: LD_STRING BobbyInDelta
1272: PPUSH
1273: LD_INT 0
1275: PPUSH
1276: CALL_OW 30
1280: IFFALSE 1317
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1282: LD_ADDR_EXP 21
1286: PUSH
1287: LD_STRING Bobby
1289: PPUSH
1290: LD_EXP 1
1294: NOT
1295: PPUSH
1296: CALL 280 0 2
1300: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
1301: LD_ADDR_VAR 0 5
1305: PUSH
1306: LD_VAR 0 5
1310: PUSH
1311: LD_EXP 21
1315: ADD
1316: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
1317: LD_STRING CyrusInDelta
1319: PPUSH
1320: LD_INT 0
1322: PPUSH
1323: CALL_OW 30
1327: IFFALSE 1364
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1329: LD_ADDR_EXP 22
1333: PUSH
1334: LD_STRING Cyrus
1336: PPUSH
1337: LD_EXP 1
1341: NOT
1342: PPUSH
1343: CALL 280 0 2
1347: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
1348: LD_ADDR_VAR 0 5
1352: PUSH
1353: LD_VAR 0 5
1357: PUSH
1358: LD_EXP 22
1362: ADD
1363: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
1364: LD_ADDR_EXP 23
1368: PUSH
1369: LD_STRING othersDelta
1371: PPUSH
1372: CALL_OW 31
1376: ST_TO_ADDR
// if not others and debug then
1377: LD_EXP 23
1381: NOT
1382: PUSH
1383: LD_EXP 1
1387: AND
1388: IFFALSE 1453
// begin InitHc ;
1390: CALL_OW 19
// for i = 1 to 2 do
1394: LD_ADDR_VAR 0 2
1398: PUSH
1399: DOUBLE
1400: LD_INT 1
1402: DEC
1403: ST_TO_ADDR
1404: LD_INT 2
1406: PUSH
1407: FOR_TO
1408: IFFALSE 1451
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
1410: LD_INT 0
1412: PPUSH
1413: LD_VAR 0 2
1417: PUSH
1418: LD_INT 4
1420: MOD
1421: PUSH
1422: LD_INT 1
1424: PLUS
1425: PPUSH
1426: LD_INT 3
1428: PPUSH
1429: CALL_OW 380
// others := others ^ CreateHuman ;
1433: LD_ADDR_EXP 23
1437: PUSH
1438: LD_EXP 23
1442: PUSH
1443: CALL_OW 44
1447: ADD
1448: ST_TO_ADDR
// end ;
1449: GO 1407
1451: POP
1452: POP
// end ; if others then
1453: LD_EXP 23
1457: IFFALSE 1475
// tmp := tmp ^ others ;
1459: LD_ADDR_VAR 0 5
1463: PUSH
1464: LD_VAR 0 5
1468: PUSH
1469: LD_EXP 23
1473: ADD
1474: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
1475: LD_ADDR_VAR 0 3
1479: PUSH
1480: LD_INT 28
1482: PUSH
1483: LD_INT 49
1485: PUSH
1486: EMPTY
1487: LIST
1488: LIST
1489: PUSH
1490: LD_INT 33
1492: PUSH
1493: LD_INT 54
1495: PUSH
1496: EMPTY
1497: LIST
1498: LIST
1499: PUSH
1500: LD_INT 38
1502: PUSH
1503: LD_INT 56
1505: PUSH
1506: EMPTY
1507: LIST
1508: LIST
1509: PUSH
1510: EMPTY
1511: LIST
1512: LIST
1513: LIST
1514: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1515: LD_ADDR_VAR 0 4
1519: PUSH
1520: LD_INT 1
1522: PPUSH
1523: LD_INT 1
1525: PPUSH
1526: LD_INT 2
1528: PPUSH
1529: LD_INT 2
1531: PPUSH
1532: LD_INT 1
1534: PPUSH
1535: LD_INT 12
1537: PPUSH
1538: LD_INT 80
1540: PPUSH
1541: CALL 337 0 7
1545: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1546: LD_VAR 0 4
1550: PPUSH
1551: LD_INT 1
1553: PPUSH
1554: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1558: LD_VAR 0 4
1562: PPUSH
1563: LD_VAR 0 3
1567: PUSH
1568: LD_INT 1
1570: ARRAY
1571: PUSH
1572: LD_INT 1
1574: ARRAY
1575: PPUSH
1576: LD_VAR 0 3
1580: PUSH
1581: LD_INT 1
1583: ARRAY
1584: PUSH
1585: LD_INT 2
1587: ARRAY
1588: PPUSH
1589: LD_INT 0
1591: PPUSH
1592: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1596: LD_VAR 0 4
1600: PPUSH
1601: LD_INT 1
1603: PPUSH
1604: LD_INT 100
1606: PPUSH
1607: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1611: LD_EXP 23
1615: PUSH
1616: LD_INT 1
1618: ARRAY
1619: PPUSH
1620: LD_VAR 0 4
1624: PPUSH
1625: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1629: LD_ADDR_VAR 0 4
1633: PUSH
1634: LD_INT 1
1636: PPUSH
1637: LD_INT 1
1639: PPUSH
1640: LD_INT 1
1642: PPUSH
1643: LD_INT 2
1645: PPUSH
1646: LD_INT 1
1648: PPUSH
1649: LD_INT 2
1651: PPUSH
1652: LD_INT 80
1654: PPUSH
1655: CALL 337 0 7
1659: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1660: LD_VAR 0 4
1664: PPUSH
1665: LD_INT 1
1667: PPUSH
1668: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1672: LD_VAR 0 4
1676: PPUSH
1677: LD_VAR 0 3
1681: PUSH
1682: LD_INT 2
1684: ARRAY
1685: PUSH
1686: LD_INT 1
1688: ARRAY
1689: PPUSH
1690: LD_VAR 0 3
1694: PUSH
1695: LD_INT 2
1697: ARRAY
1698: PUSH
1699: LD_INT 2
1701: ARRAY
1702: PPUSH
1703: LD_INT 0
1705: PPUSH
1706: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1710: LD_EXP 14
1714: PPUSH
1715: LD_VAR 0 4
1719: PPUSH
1720: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
1724: LD_ADDR_VAR 0 4
1728: PUSH
1729: LD_INT 1
1731: PPUSH
1732: LD_INT 1
1734: PPUSH
1735: LD_INT 1
1737: PPUSH
1738: LD_INT 2
1740: PPUSH
1741: LD_INT 1
1743: PPUSH
1744: LD_INT 3
1746: PPUSH
1747: LD_INT 80
1749: PPUSH
1750: CALL 337 0 7
1754: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1755: LD_VAR 0 4
1759: PPUSH
1760: LD_INT 1
1762: PPUSH
1763: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
1767: LD_VAR 0 4
1771: PPUSH
1772: LD_VAR 0 3
1776: PUSH
1777: LD_INT 3
1779: ARRAY
1780: PUSH
1781: LD_INT 1
1783: ARRAY
1784: PPUSH
1785: LD_VAR 0 3
1789: PUSH
1790: LD_INT 3
1792: ARRAY
1793: PUSH
1794: LD_INT 2
1796: ARRAY
1797: PPUSH
1798: LD_INT 0
1800: PPUSH
1801: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1805: LD_EXP 13
1809: PPUSH
1810: LD_VAR 0 4
1814: PPUSH
1815: CALL_OW 52
// if others > 1 then
1819: LD_EXP 23
1823: PUSH
1824: LD_INT 1
1826: GREATER
1827: IFFALSE 1871
// for i in tmp diff others [ 1 ] do
1829: LD_ADDR_VAR 0 2
1833: PUSH
1834: LD_VAR 0 5
1838: PUSH
1839: LD_EXP 23
1843: PUSH
1844: LD_INT 1
1846: ARRAY
1847: DIFF
1848: PUSH
1849: FOR_IN
1850: IFFALSE 1869
// PlaceUnitArea ( i , startArea , false ) ;
1852: LD_VAR 0 2
1856: PPUSH
1857: LD_INT 5
1859: PPUSH
1860: LD_INT 0
1862: PPUSH
1863: CALL_OW 49
1867: GO 1849
1869: POP
1870: POP
// end ; end_of_file
1871: LD_VAR 0 1
1875: RET
// export function Action ; begin
1876: LD_INT 0
1878: PPUSH
// InGameOn ;
1879: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
1883: LD_INT 28
1885: PPUSH
1886: LD_INT 51
1888: PPUSH
1889: CALL_OW 86
// Wait ( 3 ) ;
1893: LD_INT 3
1895: PPUSH
1896: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
1900: LD_EXP 13
1904: PPUSH
1905: LD_STRING D1d-JMM-1a
1907: PPUSH
1908: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
1912: LD_EXP 15
1916: PPUSH
1917: LD_STRING D1d-Har-1
1919: PPUSH
1920: CALL_OW 94
// InGameOff ;
1924: CALL_OW 9
// SaveForQuickRestart ;
1928: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
1932: LD_STRING M1
1934: PPUSH
1935: CALL_OW 337
// Wait ( 0 0$2 ) ;
1939: LD_INT 70
1941: PPUSH
1942: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
1946: LD_EXP 13
1950: PPUSH
1951: LD_STRING D2-JMM-1
1953: PPUSH
1954: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
1958: LD_EXP 14
1962: PPUSH
1963: LD_STRING D2-Glad-1
1965: PPUSH
1966: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
1970: LD_EXP 13
1974: PPUSH
1975: LD_STRING D2-JMM-2
1977: PPUSH
1978: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
1982: LD_EXP 14
1986: PPUSH
1987: LD_STRING D2-Glad-2
1989: PPUSH
1990: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
1994: LD_EXP 13
1998: PPUSH
1999: LD_STRING D2-JMM-3
2001: PPUSH
2002: CALL_OW 88
// SetWeather ( 1 , 30 , 50 ) ;
2006: LD_INT 1
2008: PPUSH
2009: LD_INT 30
2011: PPUSH
2012: LD_INT 50
2014: PPUSH
2015: CALL_OW 550
// Wait ( rand ( 4 4$00 , 5 5$00 ) ) ;
2019: LD_INT 8400
2021: PPUSH
2022: LD_INT 10500
2024: PPUSH
2025: CALL_OW 12
2029: PPUSH
2030: CALL_OW 67
// SetWeather ( 0 , 30 , 50 ) ;
2034: LD_INT 0
2036: PPUSH
2037: LD_INT 30
2039: PPUSH
2040: LD_INT 50
2042: PPUSH
2043: CALL_OW 550
// end ;
2047: LD_VAR 0 1
2051: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
2052: LD_INT 22
2054: PUSH
2055: LD_INT 1
2057: PUSH
2058: EMPTY
2059: LIST
2060: LIST
2061: PUSH
2062: LD_INT 3
2064: PUSH
2065: LD_INT 57
2067: PUSH
2068: EMPTY
2069: LIST
2070: PUSH
2071: EMPTY
2072: LIST
2073: LIST
2074: PUSH
2075: LD_INT 30
2077: PUSH
2078: LD_INT 0
2080: PUSH
2081: EMPTY
2082: LIST
2083: LIST
2084: PUSH
2085: EMPTY
2086: LIST
2087: LIST
2088: LIST
2089: PUSH
2090: EMPTY
2091: LIST
2092: PPUSH
2093: CALL_OW 69
2097: PUSH
2098: LD_EXP 2
2102: NOT
2103: AND
2104: IFFALSE 2117
2106: GO 2108
2108: DISABLE
// begin deltaBuilded := true ;
2109: LD_ADDR_EXP 2
2113: PUSH
2114: LD_INT 1
2116: ST_TO_ADDR
// end ;
2117: END
// every 0 0$01 trigger not Delta and deltaBuilded and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) do
2118: LD_EXP 4
2122: NOT
2123: PUSH
2124: LD_EXP 2
2128: AND
2129: PUSH
2130: LD_INT 22
2132: PUSH
2133: LD_INT 1
2135: PUSH
2136: EMPTY
2137: LIST
2138: LIST
2139: PUSH
2140: LD_INT 3
2142: PUSH
2143: LD_INT 57
2145: PUSH
2146: EMPTY
2147: LIST
2148: PUSH
2149: EMPTY
2150: LIST
2151: LIST
2152: PUSH
2153: LD_INT 30
2155: PUSH
2156: LD_INT 0
2158: PUSH
2159: EMPTY
2160: LIST
2161: LIST
2162: PUSH
2163: EMPTY
2164: LIST
2165: LIST
2166: LIST
2167: PUSH
2168: EMPTY
2169: LIST
2170: PPUSH
2171: CALL_OW 69
2175: AND
2176: IFFALSE 2249
2178: GO 2180
2180: DISABLE
// begin enable ;
2181: ENABLE
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
2182: LD_ADDR_EXP 4
2186: PUSH
2187: LD_INT 22
2189: PUSH
2190: LD_INT 1
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 3
2199: PUSH
2200: LD_INT 57
2202: PUSH
2203: EMPTY
2204: LIST
2205: PUSH
2206: EMPTY
2207: LIST
2208: LIST
2209: PUSH
2210: LD_INT 30
2212: PUSH
2213: LD_INT 0
2215: PUSH
2216: EMPTY
2217: LIST
2218: LIST
2219: PUSH
2220: EMPTY
2221: LIST
2222: LIST
2223: LIST
2224: PUSH
2225: EMPTY
2226: LIST
2227: PPUSH
2228: CALL_OW 69
2232: PUSH
2233: LD_INT 1
2235: ARRAY
2236: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
2237: LD_EXP 4
2241: PPUSH
2242: LD_STRING Delta
2244: PPUSH
2245: CALL_OW 500
// end ;
2249: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched do
2250: LD_INT 1
2252: PPUSH
2253: LD_INT 1
2255: PPUSH
2256: CALL_OW 321
2260: PUSH
2261: LD_INT 2
2263: EQUAL
2264: IFFALSE 2325
2266: GO 2268
2268: DISABLE
// begin DialogueOn ;
2269: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
2273: LD_EXP 14
2277: PPUSH
2278: LD_STRING D3-Glad-1
2280: PPUSH
2281: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2285: LD_EXP 13
2289: PPUSH
2290: LD_STRING D3-JMM-1
2292: PPUSH
2293: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
2297: LD_EXP 14
2301: PPUSH
2302: LD_STRING D3-Glad-2
2304: PPUSH
2305: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
2309: LD_EXP 13
2313: PPUSH
2314: LD_STRING D3-JMM-2
2316: PPUSH
2317: CALL_OW 88
// DialogueOff ;
2321: CALL_OW 7
// end ;
2325: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
2326: LD_INT 2
2328: PPUSH
2329: LD_INT 1
2331: PPUSH
2332: CALL_OW 321
2336: PUSH
2337: LD_INT 2
2339: EQUAL
2340: IFFALSE 2517
2342: GO 2344
2344: DISABLE
2345: LD_INT 0
2347: PPUSH
// begin DialogueOn ;
2348: CALL_OW 6
// if Frank then
2352: LD_EXP 20
2356: IFFALSE 2370
// Say ( Frank , D8a-Frank-1 ) ;
2358: LD_EXP 20
2362: PPUSH
2363: LD_STRING D8a-Frank-1
2365: PPUSH
2366: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
2370: LD_ADDR_VAR 0 1
2374: PUSH
2375: LD_EXP 23
2379: PPUSH
2380: LD_INT 26
2382: PUSH
2383: LD_INT 1
2385: PUSH
2386: EMPTY
2387: LIST
2388: LIST
2389: PPUSH
2390: CALL_OW 72
2394: PPUSH
2395: LD_STRING D8a-Sol1-1
2397: PPUSH
2398: CALL 425 0 2
2402: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2403: LD_EXP 16
2407: PUSH
2408: LD_EXP 16
2412: PPUSH
2413: CALL_OW 255
2417: PUSH
2418: LD_INT 1
2420: EQUAL
2421: AND
2422: IFFALSE 2436
// Say ( Denis , D8a-Den-1 ) ;
2424: LD_EXP 16
2428: PPUSH
2429: LD_STRING D8a-Den-1
2431: PPUSH
2432: CALL_OW 88
// if sol or Denis or Frank then
2436: LD_VAR 0 1
2440: PUSH
2441: LD_EXP 16
2445: OR
2446: PUSH
2447: LD_EXP 20
2451: OR
2452: IFFALSE 2513
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2454: LD_EXP 23
2458: PPUSH
2459: LD_INT 25
2461: PUSH
2462: LD_INT 4
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: PUSH
2469: LD_INT 26
2471: PUSH
2472: LD_INT 1
2474: PUSH
2475: EMPTY
2476: LIST
2477: LIST
2478: PUSH
2479: EMPTY
2480: LIST
2481: LIST
2482: PPUSH
2483: CALL_OW 72
2487: PUSH
2488: LD_VAR 0 1
2492: DIFF
2493: PPUSH
2494: LD_STRING D8a-Sci1-1
2496: PPUSH
2497: CALL 425 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2501: LD_EXP 13
2505: PPUSH
2506: LD_STRING D8a-JMM-1
2508: PPUSH
2509: CALL_OW 88
// end ; DialogueOff ;
2513: CALL_OW 7
// end ;
2517: PPOPN 1
2519: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2520: LD_INT 22
2522: PUSH
2523: LD_INT 1
2525: PUSH
2526: EMPTY
2527: LIST
2528: LIST
2529: PUSH
2530: LD_INT 25
2532: PUSH
2533: LD_INT 16
2535: PUSH
2536: EMPTY
2537: LIST
2538: LIST
2539: PUSH
2540: EMPTY
2541: LIST
2542: LIST
2543: PPUSH
2544: CALL_OW 69
2548: IFFALSE 2607
2550: GO 2552
2552: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2553: LD_STRING M1a
2555: PPUSH
2556: CALL_OW 337
// case Query ( Q2 ) of 1 :
2560: LD_STRING Q2
2562: PPUSH
2563: CALL_OW 97
2567: PUSH
2568: LD_INT 1
2570: DOUBLE
2571: EQUAL
2572: IFTRUE 2576
2574: GO 2587
2576: POP
// end_mission := true ; 2 :
2577: LD_ADDR_EXP 12
2581: PUSH
2582: LD_INT 1
2584: ST_TO_ADDR
2585: GO 2607
2587: LD_INT 2
2589: DOUBLE
2590: EQUAL
2591: IFTRUE 2595
2593: GO 2606
2595: POP
// end_the_mission_allowed := true ; end ;
2596: LD_ADDR_OWVAR 57
2600: PUSH
2601: LD_INT 1
2603: ST_TO_ADDR
2604: GO 2607
2606: POP
// end ;
2607: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_lab ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_workshop ] ] ) and Delta do
2608: LD_INT 22
2610: PUSH
2611: LD_INT 1
2613: PUSH
2614: EMPTY
2615: LIST
2616: LIST
2617: PUSH
2618: LD_INT 30
2620: PUSH
2621: LD_INT 6
2623: PUSH
2624: EMPTY
2625: LIST
2626: LIST
2627: PUSH
2628: EMPTY
2629: LIST
2630: LIST
2631: PPUSH
2632: CALL_OW 69
2636: PUSH
2637: LD_INT 22
2639: PUSH
2640: LD_INT 1
2642: PUSH
2643: EMPTY
2644: LIST
2645: LIST
2646: PUSH
2647: LD_INT 30
2649: PUSH
2650: LD_INT 2
2652: PUSH
2653: EMPTY
2654: LIST
2655: LIST
2656: PUSH
2657: EMPTY
2658: LIST
2659: LIST
2660: PPUSH
2661: CALL_OW 69
2665: AND
2666: PUSH
2667: LD_EXP 4
2671: AND
2672: IFFALSE 3082
2674: GO 2676
2676: DISABLE
// begin Wait ( rand ( 0 0$20 , 0 0$40 ) ) ;
2677: LD_INT 700
2679: PPUSH
2680: LD_INT 1400
2682: PPUSH
2683: CALL_OW 12
2687: PPUSH
2688: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
2692: LD_EXP 16
2696: PPUSH
2697: LD_INT 6
2699: PUSH
2700: LD_INT 9
2702: PUSH
2703: LD_INT 10
2705: PUSH
2706: EMPTY
2707: LIST
2708: LIST
2709: LIST
2710: PUSH
2711: LD_OWVAR 67
2715: ARRAY
2716: PPUSH
2717: LD_INT 0
2719: PPUSH
2720: CALL_OW 49
// ComHold ( Denis ) ;
2724: LD_EXP 16
2728: PPUSH
2729: CALL_OW 140
// InGameOn ;
2733: CALL_OW 8
// DialogueOn ;
2737: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
2741: LD_EXP 13
2745: PPUSH
2746: CALL_OW 87
// Say ( Denis , DD-Den-1 ) ;
2750: LD_EXP 16
2754: PPUSH
2755: LD_STRING DD-Den-1
2757: PPUSH
2758: CALL_OW 88
// Say ( JMM , DD-JMM-1 ) ;
2762: LD_EXP 13
2766: PPUSH
2767: LD_STRING DD-JMM-1
2769: PPUSH
2770: CALL_OW 88
// Say ( Denis , DD-Den-2 ) ;
2774: LD_EXP 16
2778: PPUSH
2779: LD_STRING DD-Den-2
2781: PPUSH
2782: CALL_OW 88
// Wait ( 3 ) ;
2786: LD_INT 3
2788: PPUSH
2789: CALL_OW 67
// DialogueOff ;
2793: CALL_OW 7
// InGameOff ;
2797: CALL_OW 9
// repeat wait ( 0 0$01 ) ;
2801: LD_INT 35
2803: PPUSH
2804: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
2808: LD_INT 1
2810: PPUSH
2811: LD_EXP 16
2815: PPUSH
2816: CALL_OW 292
2820: PUSH
2821: LD_EXP 16
2825: PPUSH
2826: CALL_OW 301
2830: OR
2831: IFFALSE 2801
// if IsDead ( Denis ) then
2833: LD_EXP 16
2837: PPUSH
2838: CALL_OW 301
2842: IFFALSE 2846
// exit ;
2844: GO 3082
// SetSide ( Denis , 1 ) ;
2846: LD_EXP 16
2850: PPUSH
2851: LD_INT 1
2853: PPUSH
2854: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
2858: LD_EXP 16
2862: PPUSH
2863: LD_STRING DD-Den-2a
2865: PPUSH
2866: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
2870: LD_INT 35
2872: PPUSH
2873: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
2877: LD_EXP 16
2881: PPUSH
2882: CALL_OW 310
2886: PPUSH
2887: CALL_OW 266
2891: PUSH
2892: LD_INT 6
2894: PUSH
2895: LD_INT 7
2897: PUSH
2898: LD_INT 8
2900: PUSH
2901: EMPTY
2902: LIST
2903: LIST
2904: LIST
2905: IN
2906: PUSH
2907: LD_EXP 16
2911: PPUSH
2912: CALL_OW 301
2916: OR
2917: IFFALSE 2870
// if IsDead ( Denis ) then
2919: LD_EXP 16
2923: PPUSH
2924: CALL_OW 301
2928: IFFALSE 2932
// exit ;
2930: GO 3082
// Say ( Denis , DD-Den-2b ) ;
2932: LD_EXP 16
2936: PPUSH
2937: LD_STRING DD-Den-2b
2939: PPUSH
2940: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
2944: LD_EXP 16
2948: PPUSH
2949: LD_INT 4
2951: PPUSH
2952: CALL_OW 123
// Wait ( 0 0$02 ) ;
2956: LD_INT 70
2958: PPUSH
2959: CALL_OW 67
// DialogueOn ;
2963: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
2967: LD_EXP 16
2971: PPUSH
2972: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
2976: LD_EXP 13
2980: PPUSH
2981: LD_STRING D4-JMM-1
2983: PPUSH
2984: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
2988: LD_EXP 16
2992: PPUSH
2993: LD_STRING D4-Den-1
2995: PPUSH
2996: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
3000: LD_EXP 13
3004: PPUSH
3005: LD_STRING D4-JMM-2
3007: PPUSH
3008: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
3012: LD_EXP 16
3016: PPUSH
3017: LD_STRING D4-Den-2
3019: PPUSH
3020: CALL_OW 88
// DialogueOff ;
3024: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
3028: LD_STRING M2
3030: PPUSH
3031: CALL_OW 337
// radar_allowed := true ;
3035: LD_ADDR_EXP 5
3039: PUSH
3040: LD_INT 1
3042: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
3043: LD_INT 6
3045: PPUSH
3046: LD_INT 1
3048: PPUSH
3049: LD_INT 1
3051: PPUSH
3052: CALL_OW 322
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
3056: LD_INT 15
3058: PPUSH
3059: LD_INT 1
3061: PPUSH
3062: LD_INT 1
3064: PPUSH
3065: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
3069: LD_INT 20
3071: PPUSH
3072: LD_INT 1
3074: PPUSH
3075: LD_INT 1
3077: PPUSH
3078: CALL_OW 324
// end ;
3082: END
// every 0 0$1 trigger arab_spotted do var sol , sol2 ;
3083: LD_EXP 11
3087: IFFALSE 3683
3089: GO 3091
3091: DISABLE
3092: LD_INT 0
3094: PPUSH
3095: PPUSH
// begin sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D5-Sol1-1 ) ;
3096: LD_ADDR_VAR 0 1
3100: PUSH
3101: LD_EXP 23
3105: PPUSH
3106: LD_INT 26
3108: PUSH
3109: LD_INT 1
3111: PUSH
3112: EMPTY
3113: LIST
3114: LIST
3115: PPUSH
3116: CALL_OW 72
3120: PPUSH
3121: LD_STRING D5-Sol1-1
3123: PPUSH
3124: CALL 425 0 2
3128: ST_TO_ADDR
// if not sol then
3129: LD_VAR 0 1
3133: NOT
3134: IFFALSE 3138
// exit ;
3136: GO 3683
// repeat wait ( 0 0$01 ) ;
3138: LD_INT 35
3140: PPUSH
3141: CALL_OW 67
// until not ar_forces ;
3145: LD_EXP 24
3149: NOT
3150: IFFALSE 3138
// if IsOk ( sol ) then
3152: LD_VAR 0 1
3156: PPUSH
3157: CALL_OW 302
3161: IFFALSE 3181
// begin sol2 := others diff sol ;
3163: LD_ADDR_VAR 0 2
3167: PUSH
3168: LD_EXP 23
3172: PUSH
3173: LD_VAR 0 1
3177: DIFF
3178: ST_TO_ADDR
// end else
3179: GO 3183
// exit ;
3181: GO 3683
// if not Lisa and not sol2 then
3183: LD_EXP 19
3187: NOT
3188: PUSH
3189: LD_VAR 0 2
3193: NOT
3194: AND
3195: IFFALSE 3199
// exit ;
3197: GO 3683
// DialogueOn ;
3199: CALL_OW 6
// if Lisa then
3203: LD_EXP 19
3207: IFFALSE 3223
// Say ( Lisa , D5a-Lisa-1 ) else
3209: LD_EXP 19
3213: PPUSH
3214: LD_STRING D5a-Lisa-1
3216: PPUSH
3217: CALL_OW 88
3221: GO 3298
// if sol2 then
3223: LD_VAR 0 2
3227: IFFALSE 3298
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3229: LD_VAR 0 2
3233: PUSH
3234: LD_INT 1
3236: ARRAY
3237: PPUSH
3238: CALL_OW 258
3242: PUSH
3243: LD_INT 1
3245: DOUBLE
3246: EQUAL
3247: IFTRUE 3251
3249: GO 3270
3251: POP
// Say ( sol2 [ 1 ] , D5-Sol2-1 ) ; sex_female :
3252: LD_VAR 0 2
3256: PUSH
3257: LD_INT 1
3259: ARRAY
3260: PPUSH
3261: LD_STRING D5-Sol2-1
3263: PPUSH
3264: CALL_OW 88
3268: GO 3298
3270: LD_INT 2
3272: DOUBLE
3273: EQUAL
3274: IFTRUE 3278
3276: GO 3297
3278: POP
// Say ( sol2 [ 1 ] , D5-FSol2-1 ) ; end ;
3279: LD_VAR 0 2
3283: PUSH
3284: LD_INT 1
3286: ARRAY
3287: PPUSH
3288: LD_STRING D5-FSol2-1
3290: PPUSH
3291: CALL_OW 88
3295: GO 3298
3297: POP
// Say ( sol , D5-Sol1-2 ) ;
3298: LD_VAR 0 1
3302: PPUSH
3303: LD_STRING D5-Sol1-2
3305: PPUSH
3306: CALL_OW 88
// if Lisa then
3310: LD_EXP 19
3314: IFFALSE 3330
// Say ( Lisa , D5a-Lisa-2 ) else
3316: LD_EXP 19
3320: PPUSH
3321: LD_STRING D5a-Lisa-2
3323: PPUSH
3324: CALL_OW 88
3328: GO 3405
// if sol2 then
3330: LD_VAR 0 2
3334: IFFALSE 3405
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3336: LD_VAR 0 2
3340: PUSH
3341: LD_INT 1
3343: ARRAY
3344: PPUSH
3345: CALL_OW 258
3349: PUSH
3350: LD_INT 1
3352: DOUBLE
3353: EQUAL
3354: IFTRUE 3358
3356: GO 3377
3358: POP
// Say ( sol2 [ 1 ] , D5-Sol2-2 ) ; sex_female :
3359: LD_VAR 0 2
3363: PUSH
3364: LD_INT 1
3366: ARRAY
3367: PPUSH
3368: LD_STRING D5-Sol2-2
3370: PPUSH
3371: CALL_OW 88
3375: GO 3405
3377: LD_INT 2
3379: DOUBLE
3380: EQUAL
3381: IFTRUE 3385
3383: GO 3404
3385: POP
// Say ( sol2 [ 1 ] , D5-FSol2-2 ) ; end ;
3386: LD_VAR 0 2
3390: PUSH
3391: LD_INT 1
3393: ARRAY
3394: PPUSH
3395: LD_STRING D5-FSol2-2
3397: PPUSH
3398: CALL_OW 88
3402: GO 3405
3404: POP
// Say ( sol , D5a-Sol1-3 ) ;
3405: LD_VAR 0 1
3409: PPUSH
3410: LD_STRING D5a-Sol1-3
3412: PPUSH
3413: CALL_OW 88
// if Lisa then
3417: LD_EXP 19
3421: IFFALSE 3435
// Say ( Lisa , D5a-Lisa-3 ) ;
3423: LD_EXP 19
3427: PPUSH
3428: LD_STRING D5a-Lisa-3
3430: PPUSH
3431: CALL_OW 88
// if not sol2 then
3435: LD_VAR 0 2
3439: NOT
3440: IFFALSE 3448
// begin DialogueOff ;
3442: CALL_OW 7
// exit ;
3446: GO 3683
// end ; case GetSex ( sol2 [ 1 ] ) of sex_male :
3448: LD_VAR 0 2
3452: PUSH
3453: LD_INT 1
3455: ARRAY
3456: PPUSH
3457: CALL_OW 258
3461: PUSH
3462: LD_INT 1
3464: DOUBLE
3465: EQUAL
3466: IFTRUE 3470
3468: GO 3489
3470: POP
// Say ( sol2 [ 1 ] , D5-Sol2-3 ) ; sex_female :
3471: LD_VAR 0 2
3475: PUSH
3476: LD_INT 1
3478: ARRAY
3479: PPUSH
3480: LD_STRING D5-Sol2-3
3482: PPUSH
3483: CALL_OW 88
3487: GO 3517
3489: LD_INT 2
3491: DOUBLE
3492: EQUAL
3493: IFTRUE 3497
3495: GO 3516
3497: POP
// Say ( sol2 [ 1 ] , D5-FSol2-3 ) ; end ;
3498: LD_VAR 0 2
3502: PUSH
3503: LD_INT 1
3505: ARRAY
3506: PPUSH
3507: LD_STRING D5-FSol2-3
3509: PPUSH
3510: CALL_OW 88
3514: GO 3517
3516: POP
// Say ( sol , D5-Sol1-4 ) ;
3517: LD_VAR 0 1
3521: PPUSH
3522: LD_STRING D5-Sol1-4
3524: PPUSH
3525: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3529: LD_VAR 0 2
3533: PUSH
3534: LD_INT 1
3536: ARRAY
3537: PPUSH
3538: CALL_OW 258
3542: PUSH
3543: LD_INT 1
3545: DOUBLE
3546: EQUAL
3547: IFTRUE 3551
3549: GO 3570
3551: POP
// Say ( sol2 [ 1 ] , D5-Sol2-4 ) ; sex_female :
3552: LD_VAR 0 2
3556: PUSH
3557: LD_INT 1
3559: ARRAY
3560: PPUSH
3561: LD_STRING D5-Sol2-4
3563: PPUSH
3564: CALL_OW 88
3568: GO 3598
3570: LD_INT 2
3572: DOUBLE
3573: EQUAL
3574: IFTRUE 3578
3576: GO 3597
3578: POP
// Say ( sol2 [ 1 ] , D5-FSol2-4 ) ; end ;
3579: LD_VAR 0 2
3583: PUSH
3584: LD_INT 1
3586: ARRAY
3587: PPUSH
3588: LD_STRING D5-FSol2-4
3590: PPUSH
3591: CALL_OW 88
3595: GO 3598
3597: POP
// Say ( sol , D5-Sol1-5 ) ;
3598: LD_VAR 0 1
3602: PPUSH
3603: LD_STRING D5-Sol1-5
3605: PPUSH
3606: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3610: LD_VAR 0 2
3614: PUSH
3615: LD_INT 1
3617: ARRAY
3618: PPUSH
3619: CALL_OW 258
3623: PUSH
3624: LD_INT 1
3626: DOUBLE
3627: EQUAL
3628: IFTRUE 3632
3630: GO 3651
3632: POP
// Say ( sol2 [ 1 ] , D5-Sol2-5 ) ; sex_female :
3633: LD_VAR 0 2
3637: PUSH
3638: LD_INT 1
3640: ARRAY
3641: PPUSH
3642: LD_STRING D5-Sol2-5
3644: PPUSH
3645: CALL_OW 88
3649: GO 3679
3651: LD_INT 2
3653: DOUBLE
3654: EQUAL
3655: IFTRUE 3659
3657: GO 3678
3659: POP
// Say ( sol2 [ 1 ] , D5-FSol2-5 ) ; end ;
3660: LD_VAR 0 2
3664: PUSH
3665: LD_INT 1
3667: ARRAY
3668: PPUSH
3669: LD_STRING D5-FSol2-5
3671: PPUSH
3672: CALL_OW 88
3676: GO 3679
3678: POP
// DialogueOff ;
3679: CALL_OW 7
// end ;
3683: PPOPN 2
3685: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 5 do
3686: LD_INT 22
3688: PUSH
3689: LD_INT 1
3691: PUSH
3692: EMPTY
3693: LIST
3694: LIST
3695: PUSH
3696: LD_INT 25
3698: PUSH
3699: LD_INT 16
3701: PUSH
3702: EMPTY
3703: LIST
3704: LIST
3705: PUSH
3706: EMPTY
3707: LIST
3708: LIST
3709: PPUSH
3710: CALL_OW 69
3714: PUSH
3715: LD_INT 5
3717: GREATEREQUAL
3718: IFFALSE 3738
3720: GO 3722
3722: DISABLE
// begin ChangeMissionObjectives ( M1b ) ;
3723: LD_STRING M1b
3725: PPUSH
3726: CALL_OW 337
// apeman_army := true ;
3730: LD_ADDR_EXP 7
3734: PUSH
3735: LD_INT 1
3737: ST_TO_ADDR
// end ;
3738: END
// every 0 0$1 trigger GetTech ( tech_radar , 1 ) = state_researched do
3739: LD_INT 6
3741: PPUSH
3742: LD_INT 1
3744: PPUSH
3745: CALL_OW 321
3749: PUSH
3750: LD_INT 2
3752: EQUAL
3753: IFFALSE 3773
3755: GO 3757
3757: DISABLE
// begin ChangeMissionObjectives ( M2a ) ;
3758: LD_STRING M2a
3760: PPUSH
3761: CALL_OW 337
// radar_researched := true ;
3765: LD_ADDR_EXP 8
3769: PUSH
3770: LD_INT 1
3772: ST_TO_ADDR
// end ;
3773: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_weapon , us_radar ] , [ f_bweapon , us_radar ] ] ] ) do
3774: LD_INT 22
3776: PUSH
3777: LD_INT 1
3779: PUSH
3780: EMPTY
3781: LIST
3782: LIST
3783: PUSH
3784: LD_INT 2
3786: PUSH
3787: LD_INT 34
3789: PUSH
3790: LD_INT 11
3792: PUSH
3793: EMPTY
3794: LIST
3795: LIST
3796: PUSH
3797: LD_INT 35
3799: PUSH
3800: LD_INT 11
3802: PUSH
3803: EMPTY
3804: LIST
3805: LIST
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: LIST
3811: PUSH
3812: EMPTY
3813: LIST
3814: LIST
3815: PPUSH
3816: CALL_OW 69
3820: IFFALSE 3840
3822: GO 3824
3824: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
3825: LD_STRING M2b
3827: PPUSH
3828: CALL_OW 337
// radar_builded := true ;
3832: LD_ADDR_EXP 9
3836: PUSH
3837: LD_INT 1
3839: ST_TO_ADDR
// end ;
3840: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 and not first_apeman_tamed do
3841: LD_INT 22
3843: PUSH
3844: LD_INT 0
3846: PUSH
3847: EMPTY
3848: LIST
3849: LIST
3850: PUSH
3851: LD_INT 25
3853: PUSH
3854: LD_INT 12
3856: PUSH
3857: EMPTY
3858: LIST
3859: LIST
3860: PUSH
3861: EMPTY
3862: LIST
3863: LIST
3864: PPUSH
3865: CALL_OW 69
3869: PUSH
3870: LD_INT 0
3872: EQUAL
3873: PUSH
3874: LD_EXP 6
3878: NOT
3879: AND
3880: IFFALSE 3892
3882: GO 3884
3884: DISABLE
// YouLost ( Apeman ) ;
3885: LD_STRING Apeman
3887: PPUSH
3888: CALL_OW 104
3892: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 7 do var i , filter ;
3893: LD_INT 22
3895: PUSH
3896: LD_INT 1
3898: PUSH
3899: EMPTY
3900: LIST
3901: LIST
3902: PUSH
3903: LD_INT 25
3905: PUSH
3906: LD_INT 16
3908: PUSH
3909: EMPTY
3910: LIST
3911: LIST
3912: PUSH
3913: EMPTY
3914: LIST
3915: LIST
3916: PPUSH
3917: CALL_OW 69
3921: PUSH
3922: LD_INT 7
3924: GREATEREQUAL
3925: IFFALSE 4023
3927: GO 3929
3929: DISABLE
3930: LD_INT 0
3932: PPUSH
3933: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ^ JMM ;
3934: LD_ADDR_VAR 0 2
3938: PUSH
3939: LD_INT 22
3941: PUSH
3942: LD_INT 1
3944: PUSH
3945: EMPTY
3946: LIST
3947: LIST
3948: PUSH
3949: LD_INT 21
3951: PUSH
3952: LD_INT 1
3954: PUSH
3955: EMPTY
3956: LIST
3957: LIST
3958: PUSH
3959: LD_INT 25
3961: PUSH
3962: LD_INT 4
3964: PUSH
3965: EMPTY
3966: LIST
3967: LIST
3968: PUSH
3969: EMPTY
3970: LIST
3971: LIST
3972: LIST
3973: PPUSH
3974: CALL_OW 69
3978: PUSH
3979: LD_EXP 13
3983: ADD
3984: ST_TO_ADDR
// if filter then
3985: LD_VAR 0 2
3989: IFFALSE 4023
// for i in filter do
3991: LD_ADDR_VAR 0 1
3995: PUSH
3996: LD_VAR 0 2
4000: PUSH
4001: FOR_IN
4002: IFFALSE 4021
// AddExperience ( i , 4 , 12500 ) ;
4004: LD_VAR 0 1
4008: PPUSH
4009: LD_INT 4
4011: PPUSH
4012: LD_INT 12500
4014: PPUSH
4015: CALL_OW 492
4019: GO 4001
4021: POP
4022: POP
// end ;
4023: PPOPN 2
4025: END
// every 0 0$1 trigger end_mission do var i , tmp ;
4026: LD_EXP 12
4030: IFFALSE 4970
4032: GO 4034
4034: DISABLE
4035: LD_INT 0
4037: PPUSH
4038: PPUSH
// begin if FilterAllUnits ( [ f_side , 2 ] ) then
4039: LD_INT 22
4041: PUSH
4042: LD_INT 2
4044: PUSH
4045: EMPTY
4046: LIST
4047: LIST
4048: PPUSH
4049: CALL_OW 69
4053: IFFALSE 4091
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
4055: LD_ADDR_VAR 0 1
4059: PUSH
4060: LD_INT 22
4062: PUSH
4063: LD_INT 2
4065: PUSH
4066: EMPTY
4067: LIST
4068: LIST
4069: PPUSH
4070: CALL_OW 69
4074: PUSH
4075: FOR_IN
4076: IFFALSE 4089
// RemoveUnit ( i ) ;
4078: LD_VAR 0 1
4082: PPUSH
4083: CALL_OW 64
4087: GO 4075
4089: POP
4090: POP
// if apeman_army then
4091: LD_EXP 7
4095: IFFALSE 4109
// AddMedal ( Tame , 1 ) else
4097: LD_STRING Tame
4099: PPUSH
4100: LD_INT 1
4102: PPUSH
4103: CALL_OW 101
4107: GO 4120
// AddMedal ( Tame , - 1 ) ;
4109: LD_STRING Tame
4111: PPUSH
4112: LD_INT 1
4114: NEG
4115: PPUSH
4116: CALL_OW 101
// if radar_researched then
4120: LD_EXP 8
4124: IFFALSE 4148
// begin SaveVariable ( true , radarResInDelta ) ;
4126: LD_INT 1
4128: PPUSH
4129: LD_STRING radarResInDelta
4131: PPUSH
4132: CALL_OW 39
// AddMedal ( Radar , 1 ) ;
4136: LD_STRING Radar
4138: PPUSH
4139: LD_INT 1
4141: PPUSH
4142: CALL_OW 101
// end else
4146: GO 4178
// if radar_allowed then
4148: LD_EXP 5
4152: IFFALSE 4167
// AddMedal ( Radar , - 2 ) else
4154: LD_STRING Radar
4156: PPUSH
4157: LD_INT 2
4159: NEG
4160: PPUSH
4161: CALL_OW 101
4165: GO 4178
// AddMedal ( Radar , - 1 ) ;
4167: LD_STRING Radar
4169: PPUSH
4170: LD_INT 1
4172: NEG
4173: PPUSH
4174: CALL_OW 101
// if radar_builded then
4178: LD_EXP 9
4182: IFFALSE 4196
// AddMedal ( BuildRadar , 1 ) else
4184: LD_STRING BuildRadar
4186: PPUSH
4187: LD_INT 1
4189: PPUSH
4190: CALL_OW 101
4194: GO 4207
// AddMedal ( BuildRadar , - 1 ) ;
4196: LD_STRING BuildRadar
4198: PPUSH
4199: LD_INT 1
4201: NEG
4202: PPUSH
4203: CALL_OW 101
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
4207: LD_ADDR_VAR 0 2
4211: PUSH
4212: LD_INT 22
4214: PUSH
4215: LD_INT 1
4217: PUSH
4218: EMPTY
4219: LIST
4220: LIST
4221: PUSH
4222: LD_INT 21
4224: PUSH
4225: LD_INT 1
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 2
4234: PUSH
4235: LD_INT 25
4237: PUSH
4238: LD_INT 1
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: PUSH
4245: LD_INT 25
4247: PUSH
4248: LD_INT 2
4250: PUSH
4251: EMPTY
4252: LIST
4253: LIST
4254: PUSH
4255: LD_INT 25
4257: PUSH
4258: LD_INT 3
4260: PUSH
4261: EMPTY
4262: LIST
4263: LIST
4264: PUSH
4265: LD_INT 25
4267: PUSH
4268: LD_INT 4
4270: PUSH
4271: EMPTY
4272: LIST
4273: LIST
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: LIST
4279: LIST
4280: LIST
4281: PUSH
4282: EMPTY
4283: LIST
4284: LIST
4285: LIST
4286: PPUSH
4287: CALL_OW 69
4291: ST_TO_ADDR
// RewardPeople ( tmp ) ;
4292: LD_VAR 0 2
4296: PPUSH
4297: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
4301: LD_EXP 13
4305: PPUSH
4306: LD_STRING JMM
4308: PPUSH
4309: CALL_OW 38
// if IsOk ( Gladstone ) then
4313: LD_EXP 14
4317: PPUSH
4318: CALL_OW 302
4322: IFFALSE 4346
// begin SaveCharacters ( Gladstone , Gladstone ) ;
4324: LD_EXP 14
4328: PPUSH
4329: LD_STRING Gladstone
4331: PPUSH
4332: CALL_OW 38
// SaveVariable ( true , GladstoneInDelta ) ;
4336: LD_INT 1
4338: PPUSH
4339: LD_STRING GladstoneInDelta
4341: PPUSH
4342: CALL_OW 39
// end ; if IsOk ( Denis ) and GetSide ( Denis ) = 1 then
4346: LD_EXP 16
4350: PPUSH
4351: CALL_OW 302
4355: PUSH
4356: LD_EXP 16
4360: PPUSH
4361: CALL_OW 255
4365: PUSH
4366: LD_INT 1
4368: EQUAL
4369: AND
4370: IFFALSE 4394
// begin SaveCharacters ( Denis , Denis ) ;
4372: LD_EXP 16
4376: PPUSH
4377: LD_STRING Denis
4379: PPUSH
4380: CALL_OW 38
// SaveVariable ( true , DenisInDelta ) ;
4384: LD_INT 1
4386: PPUSH
4387: LD_STRING DenisInDelta
4389: PPUSH
4390: CALL_OW 39
// end ; if IsOk ( Lisa ) then
4394: LD_EXP 19
4398: PPUSH
4399: CALL_OW 302
4403: IFFALSE 4427
// begin SaveCharacters ( Lisa , Lisa ) ;
4405: LD_EXP 19
4409: PPUSH
4410: LD_STRING Lisa
4412: PPUSH
4413: CALL_OW 38
// SaveVariable ( true , LisaInDelta ) ;
4417: LD_INT 1
4419: PPUSH
4420: LD_STRING LisaInDelta
4422: PPUSH
4423: CALL_OW 39
// end ; if IsOk ( Frank ) then
4427: LD_EXP 20
4431: PPUSH
4432: CALL_OW 302
4436: IFFALSE 4460
// begin SaveCharacters ( Frank , Frank ) ;
4438: LD_EXP 20
4442: PPUSH
4443: LD_STRING Frank
4445: PPUSH
4446: CALL_OW 38
// SaveVariable ( true , FrankInDelta ) ;
4450: LD_INT 1
4452: PPUSH
4453: LD_STRING FrankInDelta
4455: PPUSH
4456: CALL_OW 39
// end ; if IsOk ( Bobby ) then
4460: LD_EXP 21
4464: PPUSH
4465: CALL_OW 302
4469: IFFALSE 4493
// begin SaveCharacters ( Bobby , Bobby ) ;
4471: LD_EXP 21
4475: PPUSH
4476: LD_STRING Bobby
4478: PPUSH
4479: CALL_OW 38
// SaveVariable ( true , BobbyInDelta ) ;
4483: LD_INT 1
4485: PPUSH
4486: LD_STRING BobbyInDelta
4488: PPUSH
4489: CALL_OW 39
// end ; if IsOk ( Cyrus ) then
4493: LD_EXP 22
4497: PPUSH
4498: CALL_OW 302
4502: IFFALSE 4526
// begin SaveCharacters ( Cyrus , Cyrus ) ;
4504: LD_EXP 22
4508: PPUSH
4509: LD_STRING Cyrus
4511: PPUSH
4512: CALL_OW 38
// SaveVariable ( true , CyrusInDelta ) ;
4516: LD_INT 1
4518: PPUSH
4519: LD_STRING CyrusInDelta
4521: PPUSH
4522: CALL_OW 39
// end ; if others then
4526: LD_EXP 23
4530: IFFALSE 4544
// SaveCharacters ( others , othersInDelta ) ;
4532: LD_EXP 23
4536: PPUSH
4537: LD_STRING othersInDelta
4539: PPUSH
4540: CALL_OW 38
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) then
4544: LD_INT 22
4546: PUSH
4547: LD_INT 1
4549: PUSH
4550: EMPTY
4551: LIST
4552: LIST
4553: PUSH
4554: LD_INT 25
4556: PUSH
4557: LD_INT 16
4559: PUSH
4560: EMPTY
4561: LIST
4562: LIST
4563: PUSH
4564: EMPTY
4565: LIST
4566: LIST
4567: PPUSH
4568: CALL_OW 69
4572: IFFALSE 4610
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) , apeInDelta ) ;
4574: LD_INT 22
4576: PUSH
4577: LD_INT 1
4579: PUSH
4580: EMPTY
4581: LIST
4582: LIST
4583: PUSH
4584: LD_INT 25
4586: PUSH
4587: LD_INT 16
4589: PUSH
4590: EMPTY
4591: LIST
4592: LIST
4593: PUSH
4594: EMPTY
4595: LIST
4596: LIST
4597: PPUSH
4598: CALL_OW 69
4602: PPUSH
4603: LD_STRING apeInDelta
4605: PPUSH
4606: CALL_OW 38
// tmp := [ ] ;
4610: LD_ADDR_VAR 0 2
4614: PUSH
4615: EMPTY
4616: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) then
4617: LD_INT 22
4619: PUSH
4620: LD_INT 1
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: PUSH
4627: LD_INT 21
4629: PUSH
4630: LD_INT 2
4632: PUSH
4633: EMPTY
4634: LIST
4635: LIST
4636: PUSH
4637: EMPTY
4638: LIST
4639: LIST
4640: PPUSH
4641: CALL_OW 69
4645: IFFALSE 4756
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
4647: LD_ADDR_VAR 0 1
4651: PUSH
4652: LD_INT 22
4654: PUSH
4655: LD_INT 1
4657: PUSH
4658: EMPTY
4659: LIST
4660: LIST
4661: PUSH
4662: LD_INT 21
4664: PUSH
4665: LD_INT 2
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PPUSH
4676: CALL_OW 69
4680: PUSH
4681: FOR_IN
4682: IFFALSE 4754
// tmp := tmp ^ [ GetNation ( i ) , GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
4684: LD_ADDR_VAR 0 2
4688: PUSH
4689: LD_VAR 0 2
4693: PUSH
4694: LD_VAR 0 1
4698: PPUSH
4699: CALL_OW 248
4703: PUSH
4704: LD_VAR 0 1
4708: PPUSH
4709: CALL_OW 265
4713: PUSH
4714: LD_VAR 0 1
4718: PPUSH
4719: CALL_OW 262
4723: PUSH
4724: LD_VAR 0 1
4728: PPUSH
4729: CALL_OW 263
4733: PUSH
4734: LD_VAR 0 1
4738: PPUSH
4739: CALL_OW 264
4743: PUSH
4744: EMPTY
4745: LIST
4746: LIST
4747: LIST
4748: LIST
4749: LIST
4750: ADD
4751: ST_TO_ADDR
4752: GO 4681
4754: POP
4755: POP
// if tmp then
4756: LD_VAR 0 2
4760: IFFALSE 4774
// SaveVariable ( tmp , vehiclesInDelta ) ;
4762: LD_VAR 0 2
4766: PPUSH
4767: LD_STRING vehiclesInDelta
4769: PPUSH
4770: CALL_OW 39
// tmp := [ ] ;
4774: LD_ADDR_VAR 0 2
4778: PUSH
4779: EMPTY
4780: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
4781: LD_INT 22
4783: PUSH
4784: LD_INT 1
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: PUSH
4791: LD_INT 21
4793: PUSH
4794: LD_INT 3
4796: PUSH
4797: EMPTY
4798: LIST
4799: LIST
4800: PUSH
4801: EMPTY
4802: LIST
4803: LIST
4804: PPUSH
4805: CALL_OW 69
4809: IFFALSE 4948
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4811: LD_ADDR_VAR 0 1
4815: PUSH
4816: LD_INT 22
4818: PUSH
4819: LD_INT 1
4821: PUSH
4822: EMPTY
4823: LIST
4824: LIST
4825: PUSH
4826: LD_INT 21
4828: PUSH
4829: LD_INT 3
4831: PUSH
4832: EMPTY
4833: LIST
4834: LIST
4835: PUSH
4836: EMPTY
4837: LIST
4838: LIST
4839: PPUSH
4840: CALL_OW 69
4844: PUSH
4845: FOR_IN
4846: IFFALSE 4946
// tmp := tmp ^ [ GetBType ( i ) , GetBLevel ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) ] ;
4848: LD_ADDR_VAR 0 2
4852: PUSH
4853: LD_VAR 0 2
4857: PUSH
4858: LD_VAR 0 1
4862: PPUSH
4863: CALL_OW 266
4867: PUSH
4868: LD_VAR 0 1
4872: PPUSH
4873: CALL_OW 267
4877: PUSH
4878: LD_VAR 0 1
4882: PPUSH
4883: CALL_OW 250
4887: PUSH
4888: LD_VAR 0 1
4892: PPUSH
4893: CALL_OW 251
4897: PUSH
4898: LD_VAR 0 1
4902: PPUSH
4903: CALL_OW 254
4907: PUSH
4908: LD_VAR 0 1
4912: PPUSH
4913: LD_INT 1
4915: PPUSH
4916: CALL_OW 268
4920: PUSH
4921: LD_VAR 0 1
4925: PPUSH
4926: LD_INT 2
4928: PPUSH
4929: CALL_OW 268
4933: PUSH
4934: EMPTY
4935: LIST
4936: LIST
4937: LIST
4938: LIST
4939: LIST
4940: LIST
4941: LIST
4942: ADD
4943: ST_TO_ADDR
4944: GO 4845
4946: POP
4947: POP
// if tmp then
4948: LD_VAR 0 2
4952: IFFALSE 4966
// SaveVariable ( tmp , buildingsInDelta ) ;
4954: LD_VAR 0 2
4958: PPUSH
4959: LD_STRING buildingsInDelta
4961: PPUSH
4962: CALL_OW 39
// YouWin ;
4966: CALL_OW 103
// end ; end_of_file
4970: PPOPN 2
4972: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un , tmp ; begin
4973: LD_INT 0
4975: PPUSH
4976: PPUSH
4977: PPUSH
4978: PPUSH
// InitHc ;
4979: CALL_OW 19
// InitUc ;
4983: CALL_OW 18
// uc_side := 2 ;
4987: LD_ADDR_OWVAR 20
4991: PUSH
4992: LD_INT 2
4994: ST_TO_ADDR
// uc_nation := 2 ;
4995: LD_ADDR_OWVAR 21
4999: PUSH
5000: LD_INT 2
5002: ST_TO_ADDR
// if not amount then
5003: LD_VAR 0 1
5007: NOT
5008: IFFALSE 5012
// exit ;
5010: GO 5135
// for i = 1 to amount do
5012: LD_ADDR_VAR 0 5
5016: PUSH
5017: DOUBLE
5018: LD_INT 1
5020: DEC
5021: ST_TO_ADDR
5022: LD_VAR 0 1
5026: PUSH
5027: FOR_TO
5028: IFFALSE 5123
// begin PrepareHuman ( false , 1 , skill ) ;
5030: LD_INT 0
5032: PPUSH
5033: LD_INT 1
5035: PPUSH
5036: LD_VAR 0 2
5040: PPUSH
5041: CALL_OW 380
// un := CreateHuman ;
5045: LD_ADDR_VAR 0 6
5049: PUSH
5050: CALL_OW 44
5054: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
5055: LD_ADDR_VAR 0 7
5059: PUSH
5060: LD_VAR 0 7
5064: PPUSH
5065: LD_INT 1
5067: PPUSH
5068: LD_VAR 0 6
5072: PPUSH
5073: CALL_OW 2
5077: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5078: LD_VAR 0 6
5082: PPUSH
5083: LD_VAR 0 3
5087: PPUSH
5088: LD_INT 0
5090: PPUSH
5091: CALL_OW 49
// if i mod 3 = 0 then
5095: LD_VAR 0 5
5099: PUSH
5100: LD_INT 3
5102: MOD
5103: PUSH
5104: LD_INT 0
5106: EQUAL
5107: IFFALSE 5121
// SetTag ( i , 11 ) ;
5109: LD_VAR 0 5
5113: PPUSH
5114: LD_INT 11
5116: PPUSH
5117: CALL_OW 109
// end ;
5121: GO 5027
5123: POP
5124: POP
// result := tmp ;
5125: LD_ADDR_VAR 0 4
5129: PUSH
5130: LD_VAR 0 7
5134: ST_TO_ADDR
// end ;
5135: LD_VAR 0 4
5139: RET
// export ar_forces , ap_killers ; every 0 0$1 trigger Delta do var i , timer , more_troops , skill , eng , un , veh , force ;
5140: LD_EXP 4
5144: IFFALSE 6013
5146: GO 5148
5148: DISABLE
5149: LD_INT 0
5151: PPUSH
5152: PPUSH
5153: PPUSH
5154: PPUSH
5155: PPUSH
5156: PPUSH
5157: PPUSH
5158: PPUSH
// begin more_troops := false ;
5159: LD_ADDR_VAR 0 3
5163: PUSH
5164: LD_INT 0
5166: ST_TO_ADDR
// skill := [ 3 , 4 , 5 ] [ Difficulty ] ;
5167: LD_ADDR_VAR 0 4
5171: PUSH
5172: LD_INT 3
5174: PUSH
5175: LD_INT 4
5177: PUSH
5178: LD_INT 5
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: LIST
5185: PUSH
5186: LD_OWVAR 67
5190: ARRAY
5191: ST_TO_ADDR
// timer := [ 5 5$00 , 4 4$00 , 3 3$00 ] [ Difficulty ] ;
5192: LD_ADDR_VAR 0 2
5196: PUSH
5197: LD_INT 10500
5199: PUSH
5200: LD_INT 8400
5202: PUSH
5203: LD_INT 6300
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: LIST
5210: PUSH
5211: LD_OWVAR 67
5215: ARRAY
5216: ST_TO_ADDR
// force := [ ] ;
5217: LD_ADDR_VAR 0 8
5221: PUSH
5222: EMPTY
5223: ST_TO_ADDR
// ar_forces := [ ] ;
5224: LD_ADDR_EXP 24
5228: PUSH
5229: EMPTY
5230: ST_TO_ADDR
// ap_killers := [ ] ;
5231: LD_ADDR_EXP 25
5235: PUSH
5236: EMPTY
5237: ST_TO_ADDR
// Wait ( timer ) ;
5238: LD_VAR 0 2
5242: PPUSH
5243: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) then
5247: LD_INT 22
5249: PUSH
5250: LD_INT 1
5252: PUSH
5253: EMPTY
5254: LIST
5255: LIST
5256: PUSH
5257: LD_INT 30
5259: PUSH
5260: LD_INT 4
5262: PUSH
5263: EMPTY
5264: LIST
5265: LIST
5266: PUSH
5267: EMPTY
5268: LIST
5269: LIST
5270: PPUSH
5271: CALL_OW 69
5275: IFFALSE 5292
// begin Wait ( 1 1$25 ) ;
5277: LD_INT 2975
5279: PPUSH
5280: CALL_OW 67
// more_troops := true ;
5284: LD_ADDR_VAR 0 3
5288: PUSH
5289: LD_INT 1
5291: ST_TO_ADDR
// end ; if more_troops then
5292: LD_VAR 0 3
5296: IFFALSE 5491
// begin force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , arArea1 ) ;
5298: LD_ADDR_VAR 0 8
5302: PUSH
5303: LD_INT 4
5305: PUSH
5306: LD_INT 5
5308: PUSH
5309: LD_INT 6
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: LIST
5316: PUSH
5317: LD_OWVAR 67
5321: ARRAY
5322: PPUSH
5323: LD_VAR 0 4
5327: PPUSH
5328: LD_INT 13
5330: PPUSH
5331: CALL 4973 0 3
5335: ST_TO_ADDR
// veh := PrepareTank ( 2 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ Difficulty ] , 90 ) ;
5336: LD_ADDR_VAR 0 7
5340: PUSH
5341: LD_INT 2
5343: PPUSH
5344: LD_INT 3
5346: PPUSH
5347: LD_INT 22
5349: PPUSH
5350: LD_INT 1
5352: PPUSH
5353: LD_INT 1
5355: PPUSH
5356: LD_INT 42
5358: PUSH
5359: LD_INT 42
5361: PUSH
5362: LD_INT 43
5364: PUSH
5365: EMPTY
5366: LIST
5367: LIST
5368: LIST
5369: PUSH
5370: LD_OWVAR 67
5374: ARRAY
5375: PPUSH
5376: LD_INT 90
5378: PPUSH
5379: CALL 337 0 7
5383: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5384: LD_VAR 0 7
5388: PPUSH
5389: LD_INT 4
5391: PPUSH
5392: CALL_OW 233
// PlaceUnitArea ( veh , arArea2 , false ) ;
5396: LD_VAR 0 7
5400: PPUSH
5401: LD_INT 14
5403: PPUSH
5404: LD_INT 0
5406: PPUSH
5407: CALL_OW 49
// uc_side := 2 ;
5411: LD_ADDR_OWVAR 20
5415: PUSH
5416: LD_INT 2
5418: ST_TO_ADDR
// uc_nation := 2 ;
5419: LD_ADDR_OWVAR 21
5423: PUSH
5424: LD_INT 2
5426: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5427: LD_INT 0
5429: PPUSH
5430: LD_INT 1
5432: PPUSH
5433: LD_VAR 0 4
5437: PPUSH
5438: CALL_OW 380
// un := CreateHuman ;
5442: LD_ADDR_VAR 0 6
5446: PUSH
5447: CALL_OW 44
5451: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
5452: LD_VAR 0 6
5456: PPUSH
5457: LD_VAR 0 7
5461: PPUSH
5462: CALL_OW 52
// force := Insert ( force , 1 , un ) ;
5466: LD_ADDR_VAR 0 8
5470: PUSH
5471: LD_VAR 0 8
5475: PPUSH
5476: LD_INT 1
5478: PPUSH
5479: LD_VAR 0 6
5483: PPUSH
5484: CALL_OW 2
5488: ST_TO_ADDR
// end else
5489: GO 5529
// begin force := PrepareArabianTroops ( [ 3 , 4 , 5 ] [ Difficulty ] , skill , arArea2 ) ;
5491: LD_ADDR_VAR 0 8
5495: PUSH
5496: LD_INT 3
5498: PUSH
5499: LD_INT 4
5501: PUSH
5502: LD_INT 5
5504: PUSH
5505: EMPTY
5506: LIST
5507: LIST
5508: LIST
5509: PUSH
5510: LD_OWVAR 67
5514: ARRAY
5515: PPUSH
5516: LD_VAR 0 4
5520: PPUSH
5521: LD_INT 14
5523: PPUSH
5524: CALL 4973 0 3
5528: ST_TO_ADDR
// end ; if force then
5529: LD_VAR 0 8
5533: IFFALSE 5545
// ar_forces := force ;
5535: LD_ADDR_EXP 24
5539: PUSH
5540: LD_VAR 0 8
5544: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5545: LD_INT 35
5547: PPUSH
5548: CALL_OW 67
// until ar_forces = [ ] ;
5552: LD_EXP 24
5556: PUSH
5557: EMPTY
5558: EQUAL
5559: IFFALSE 5545
// Wait ( timer ) ;
5561: LD_VAR 0 2
5565: PPUSH
5566: CALL_OW 67
// force := PrepareArabianTroops ( [ 5 , 6 , 6 ] [ Difficulty ] , skill , [ arArea1 , arArea2 ] [ rand ( 1 , 2 ) ] ) ;
5570: LD_ADDR_VAR 0 8
5574: PUSH
5575: LD_INT 5
5577: PUSH
5578: LD_INT 6
5580: PUSH
5581: LD_INT 6
5583: PUSH
5584: EMPTY
5585: LIST
5586: LIST
5587: LIST
5588: PUSH
5589: LD_OWVAR 67
5593: ARRAY
5594: PPUSH
5595: LD_VAR 0 4
5599: PPUSH
5600: LD_INT 13
5602: PUSH
5603: LD_INT 14
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: PUSH
5610: LD_INT 1
5612: PPUSH
5613: LD_INT 2
5615: PPUSH
5616: CALL_OW 12
5620: ARRAY
5621: PPUSH
5622: CALL 4973 0 3
5626: ST_TO_ADDR
// if Difficulty > 1 and Delta then
5627: LD_OWVAR 67
5631: PUSH
5632: LD_INT 1
5634: GREATER
5635: PUSH
5636: LD_EXP 4
5640: AND
5641: IFFALSE 5800
// begin veh := PrepareTank ( 2 , 2 , ar_light_trike , engine_solar , control_manual , 22 , 100 ) ;
5643: LD_ADDR_VAR 0 7
5647: PUSH
5648: LD_INT 2
5650: PPUSH
5651: LD_INT 2
5653: PPUSH
5654: LD_INT 12
5656: PPUSH
5657: LD_INT 2
5659: PPUSH
5660: LD_INT 1
5662: PPUSH
5663: LD_INT 22
5665: PPUSH
5666: LD_INT 100
5668: PPUSH
5669: CALL 337 0 7
5673: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5674: LD_VAR 0 7
5678: PPUSH
5679: LD_INT 4
5681: PPUSH
5682: CALL_OW 233
// PlaceUnitArea ( veh , arArea2 , false ) ;
5686: LD_VAR 0 7
5690: PPUSH
5691: LD_INT 14
5693: PPUSH
5694: LD_INT 0
5696: PPUSH
5697: CALL_OW 49
// uc_side := 2 ;
5701: LD_ADDR_OWVAR 20
5705: PUSH
5706: LD_INT 2
5708: ST_TO_ADDR
// uc_nation := 2 ;
5709: LD_ADDR_OWVAR 21
5713: PUSH
5714: LD_INT 2
5716: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5717: LD_INT 0
5719: PPUSH
5720: LD_INT 1
5722: PPUSH
5723: LD_VAR 0 4
5727: PPUSH
5728: CALL_OW 380
// eng := CreateHuman ;
5732: LD_ADDR_VAR 0 5
5736: PUSH
5737: CALL_OW 44
5741: ST_TO_ADDR
// PlaceHumanInUnit ( eng , veh ) ;
5742: LD_VAR 0 5
5746: PPUSH
5747: LD_VAR 0 7
5751: PPUSH
5752: CALL_OW 52
// Wait ( 3 ) ;
5756: LD_INT 3
5758: PPUSH
5759: CALL_OW 67
// ComMoveUnit ( eng , Delta ) ;
5763: LD_VAR 0 5
5767: PPUSH
5768: LD_EXP 4
5772: PPUSH
5773: CALL_OW 112
// AddComExitVehicle ( eng ) ;
5777: LD_VAR 0 5
5781: PPUSH
5782: CALL_OW 181
// AddComEnterUnit ( eng , Delta ) ;
5786: LD_VAR 0 5
5790: PPUSH
5791: LD_EXP 4
5795: PPUSH
5796: CALL_OW 180
// end ; if force then
5800: LD_VAR 0 8
5804: IFFALSE 5816
// ar_forces := force ;
5806: LD_ADDR_EXP 24
5810: PUSH
5811: LD_VAR 0 8
5815: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5816: LD_INT 35
5818: PPUSH
5819: CALL_OW 67
// if eng then
5823: LD_VAR 0 5
5827: IFFALSE 5881
// if GetSide ( Delta ) = 2 and IsOk ( eng ) and not IsInUnit ( eng ) then
5829: LD_EXP 4
5833: PPUSH
5834: CALL_OW 255
5838: PUSH
5839: LD_INT 2
5841: EQUAL
5842: PUSH
5843: LD_VAR 0 5
5847: PPUSH
5848: CALL_OW 302
5852: AND
5853: PUSH
5854: LD_VAR 0 5
5858: PPUSH
5859: CALL_OW 310
5863: NOT
5864: AND
5865: IFFALSE 5881
// ComEnterUnit ( eng , Delta ) ;
5867: LD_VAR 0 5
5871: PPUSH
5872: LD_EXP 4
5876: PPUSH
5877: CALL_OW 120
// until ar_forces = [ ] ;
5881: LD_EXP 24
5885: PUSH
5886: EMPTY
5887: EQUAL
5888: IFFALSE 5816
// ap_killers := PrepareArabianTroops ( [ 1 , 2 , 2 ] [ Difficulty ] , skill , arArea1 ) ;
5890: LD_ADDR_EXP 25
5894: PUSH
5895: LD_INT 1
5897: PUSH
5898: LD_INT 2
5900: PUSH
5901: LD_INT 2
5903: PUSH
5904: EMPTY
5905: LIST
5906: LIST
5907: LIST
5908: PUSH
5909: LD_OWVAR 67
5913: ARRAY
5914: PPUSH
5915: LD_VAR 0 4
5919: PPUSH
5920: LD_INT 13
5922: PPUSH
5923: CALL 4973 0 3
5927: ST_TO_ADDR
// Wait ( timer * 2 ) ;
5928: LD_VAR 0 2
5932: PUSH
5933: LD_INT 2
5935: MUL
5936: PPUSH
5937: CALL_OW 67
// ar_forces := PrepareArabianTroops ( [ 5 , 6 , 7 ] [ Difficulty ] , skill , arArea1 ) ^ PrepareArabianTroops ( [ 3 , 4 , 4 ] [ Difficulty ] , skill , arArea2 ) ;
5941: LD_ADDR_EXP 24
5945: PUSH
5946: LD_INT 5
5948: PUSH
5949: LD_INT 6
5951: PUSH
5952: LD_INT 7
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: PUSH
5960: LD_OWVAR 67
5964: ARRAY
5965: PPUSH
5966: LD_VAR 0 4
5970: PPUSH
5971: LD_INT 13
5973: PPUSH
5974: CALL 4973 0 3
5978: PUSH
5979: LD_INT 3
5981: PUSH
5982: LD_INT 4
5984: PUSH
5985: LD_INT 4
5987: PUSH
5988: EMPTY
5989: LIST
5990: LIST
5991: LIST
5992: PUSH
5993: LD_OWVAR 67
5997: ARRAY
5998: PPUSH
5999: LD_VAR 0 4
6003: PPUSH
6004: LD_INT 14
6006: PPUSH
6007: CALL 4973 0 3
6011: ADD
6012: ST_TO_ADDR
// end ;
6013: PPOPN 8
6015: END
// every 0 0$01 trigger ar_forces do var i , target ;
6016: LD_EXP 24
6020: IFFALSE 6159
6022: GO 6024
6024: DISABLE
6025: LD_INT 0
6027: PPUSH
6028: PPUSH
// begin enable ;
6029: ENABLE
// if not ar_forces then
6030: LD_EXP 24
6034: NOT
6035: IFFALSE 6039
// exit ;
6037: GO 6159
// if Delta then
6039: LD_EXP 4
6043: IFFALSE 6057
// target := Delta else
6045: LD_ADDR_VAR 0 2
6049: PUSH
6050: LD_EXP 4
6054: ST_TO_ADDR
6055: GO 6067
// target := JMM ;
6057: LD_ADDR_VAR 0 2
6061: PUSH
6062: LD_EXP 13
6066: ST_TO_ADDR
// for i in ar_forces do
6067: LD_ADDR_VAR 0 1
6071: PUSH
6072: LD_EXP 24
6076: PUSH
6077: FOR_IN
6078: IFFALSE 6157
// begin if GetDistUnits ( i , target ) > 30 then
6080: LD_VAR 0 1
6084: PPUSH
6085: LD_VAR 0 2
6089: PPUSH
6090: CALL_OW 296
6094: PUSH
6095: LD_INT 30
6097: GREATER
6098: IFFALSE 6131
// ComAgressiveMove ( i , GetX ( target ) , GetY ( target ) ) else
6100: LD_VAR 0 1
6104: PPUSH
6105: LD_VAR 0 2
6109: PPUSH
6110: CALL_OW 250
6114: PPUSH
6115: LD_VAR 0 2
6119: PPUSH
6120: CALL_OW 251
6124: PPUSH
6125: CALL_OW 114
6129: GO 6155
// Attack ( i , FilterAllUnits ( [ f_enemy , 2 ] ) ) ;
6131: LD_VAR 0 1
6135: PPUSH
6136: LD_INT 81
6138: PUSH
6139: LD_INT 2
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: PPUSH
6146: CALL_OW 69
6150: PPUSH
6151: CALL 590 0 2
// end ;
6155: GO 6077
6157: POP
6158: POP
// end ;
6159: PPOPN 2
6161: END
// every 0 0$01 trigger ap_killers do var filter , i , target ;
6162: LD_EXP 25
6166: IFFALSE 6326
6168: GO 6170
6170: DISABLE
6171: LD_INT 0
6173: PPUSH
6174: PPUSH
6175: PPUSH
// begin enable ;
6176: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6177: LD_ADDR_VAR 0 1
6181: PUSH
6182: LD_INT 22
6184: PUSH
6185: LD_INT 0
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 25
6194: PUSH
6195: LD_INT 12
6197: PUSH
6198: EMPTY
6199: LIST
6200: LIST
6201: PUSH
6202: EMPTY
6203: LIST
6204: LIST
6205: PPUSH
6206: CALL_OW 69
6210: ST_TO_ADDR
// if not filter then
6211: LD_VAR 0 1
6215: NOT
6216: IFFALSE 6243
// begin ar_forces := ar_forces ^ ap_killers ;
6218: LD_ADDR_EXP 24
6222: PUSH
6223: LD_EXP 24
6227: PUSH
6228: LD_EXP 25
6232: ADD
6233: ST_TO_ADDR
// ap_killers := [ ] ;
6234: LD_ADDR_EXP 25
6238: PUSH
6239: EMPTY
6240: ST_TO_ADDR
// exit ;
6241: GO 6326
// end ; for i in ap_killers do
6243: LD_ADDR_VAR 0 2
6247: PUSH
6248: LD_EXP 25
6252: PUSH
6253: FOR_IN
6254: IFFALSE 6324
// begin if not IsOk ( i ) then
6256: LD_VAR 0 2
6260: PPUSH
6261: CALL_OW 302
6265: NOT
6266: IFFALSE 6270
// continue ;
6268: GO 6253
// if not HasTask ( i ) then
6270: LD_VAR 0 2
6274: PPUSH
6275: CALL_OW 314
6279: NOT
6280: IFFALSE 6302
// target := NearestUnitToUnit ( filter , i ) ;
6282: LD_ADDR_VAR 0 3
6286: PUSH
6287: LD_VAR 0 1
6291: PPUSH
6292: LD_VAR 0 2
6296: PPUSH
6297: CALL_OW 74
6301: ST_TO_ADDR
// if target then
6302: LD_VAR 0 3
6306: IFFALSE 6322
// ComAttackUnit ( i , target ) ;
6308: LD_VAR 0 2
6312: PPUSH
6313: LD_VAR 0 3
6317: PPUSH
6318: CALL_OW 115
// end ;
6322: GO 6253
6324: POP
6325: POP
// end ; end_of_file
6326: PPOPN 3
6328: END
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
6329: LD_EXP 4
6333: IFFALSE 6465
6335: GO 6337
6337: DISABLE
6338: LD_INT 0
6340: PPUSH
6341: PPUSH
6342: PPUSH
// begin counter := [ 700 , 600 , 500 ] [ Difficulty ] ;
6343: LD_ADDR_VAR 0 2
6347: PUSH
6348: LD_INT 700
6350: PUSH
6351: LD_INT 600
6353: PUSH
6354: LD_INT 500
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: LIST
6361: PUSH
6362: LD_OWVAR 67
6366: ARRAY
6367: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
6368: LD_INT 1
6370: PPUSH
6371: LD_INT 3
6373: PPUSH
6374: CALL_OW 12
6378: PPUSH
6379: LD_INT 7
6381: PPUSH
6382: LD_INT 1
6384: PPUSH
6385: CALL_OW 55
// repeat wait ( rand ( 1 1$30 , 2 2$20 ) ) ;
6389: LD_INT 3150
6391: PPUSH
6392: LD_INT 4900
6394: PPUSH
6395: CALL_OW 12
6399: PPUSH
6400: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
6404: LD_ADDR_VAR 0 3
6408: PUSH
6409: LD_INT 1
6411: PPUSH
6412: LD_INT 5
6414: PPUSH
6415: CALL_OW 12
6419: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
6420: LD_VAR 0 3
6424: PPUSH
6425: LD_INT 7
6427: PPUSH
6428: LD_INT 1
6430: PPUSH
6431: CALL_OW 55
// counter := counter - cr * 10 ;
6435: LD_ADDR_VAR 0 2
6439: PUSH
6440: LD_VAR 0 2
6444: PUSH
6445: LD_VAR 0 3
6449: PUSH
6450: LD_INT 10
6452: MUL
6453: MINUS
6454: ST_TO_ADDR
// until counter <= 0 ;
6455: LD_VAR 0 2
6459: PUSH
6460: LD_INT 0
6462: LESSEQUAL
6463: IFFALSE 6389
// end ;
6465: PPOPN 3
6467: END
// every 0 0$03 trigger not Delta do var i ;
6468: LD_EXP 4
6472: NOT
6473: IFFALSE 6543
6475: GO 6477
6477: DISABLE
6478: LD_INT 0
6480: PPUSH
// begin for i = 1 to 4 - Difficulty do
6481: LD_ADDR_VAR 0 1
6485: PUSH
6486: DOUBLE
6487: LD_INT 1
6489: DEC
6490: ST_TO_ADDR
6491: LD_INT 4
6493: PUSH
6494: LD_OWVAR 67
6498: MINUS
6499: PUSH
6500: FOR_TO
6501: IFFALSE 6541
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
6503: LD_INT 2
6505: PPUSH
6506: LD_INT 5
6508: PPUSH
6509: CALL_OW 12
6513: PPUSH
6514: LD_INT 8
6516: PPUSH
6517: LD_INT 1
6519: PPUSH
6520: CALL_OW 55
// Wait ( rand ( 0 0$16 , 0 0$39 ) ) ;
6524: LD_INT 560
6526: PPUSH
6527: LD_INT 1365
6529: PPUSH
6530: CALL_OW 12
6534: PPUSH
6535: CALL_OW 67
// end ;
6539: GO 6500
6541: POP
6542: POP
// end ;
6543: PPOPN 1
6545: END
// every 2 2$00 do
6546: GO 6548
6548: DISABLE
// begin enable ;
6549: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
6550: LD_INT 1
6552: PPUSH
6553: LD_INT 3
6555: PPUSH
6556: CALL_OW 12
6560: PPUSH
6561: LD_INT 1
6563: PPUSH
6564: CALL_OW 57
// end ; end_of_file
6568: END
// on UnitDestroyed ( un ) do begin if un = JMM then
6569: LD_VAR 0 1
6573: PUSH
6574: LD_EXP 13
6578: EQUAL
6579: IFFALSE 6588
// YouLost ( JMM ) ;
6581: LD_STRING JMM
6583: PPUSH
6584: CALL_OW 104
// if un = Delta then
6588: LD_VAR 0 1
6592: PUSH
6593: LD_EXP 4
6597: EQUAL
6598: IFFALSE 6608
// Delta := 0 ;
6600: LD_ADDR_EXP 4
6604: PUSH
6605: LD_INT 0
6607: ST_TO_ADDR
// if un in ar_forces then
6608: LD_VAR 0 1
6612: PUSH
6613: LD_EXP 24
6617: IN
6618: IFFALSE 6636
// ar_forces := ar_forces diff un ;
6620: LD_ADDR_EXP 24
6624: PUSH
6625: LD_EXP 24
6629: PUSH
6630: LD_VAR 0 1
6634: DIFF
6635: ST_TO_ADDR
// if un in ap_killers then
6636: LD_VAR 0 1
6640: PUSH
6641: LD_EXP 25
6645: IN
6646: IFFALSE 6664
// ap_killers := ap_killers diff un ;
6648: LD_ADDR_EXP 25
6652: PUSH
6653: LD_EXP 25
6657: PUSH
6658: LD_VAR 0 1
6662: DIFF
6663: ST_TO_ADDR
// end ;
6664: PPOPN 1
6666: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
6667: LD_VAR 0 1
6671: PUSH
6672: LD_INT 1
6674: EQUAL
6675: PUSH
6676: LD_VAR 0 2
6680: PUSH
6681: LD_INT 2
6683: EQUAL
6684: AND
6685: PUSH
6686: LD_EXP 11
6690: NOT
6691: AND
6692: IFFALSE 6702
// arab_spotted := true ;
6694: LD_ADDR_EXP 11
6698: PUSH
6699: LD_INT 1
6701: ST_TO_ADDR
6702: PPOPN 2
6704: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
6705: LD_ADDR_OWVAR 57
6709: PUSH
6710: LD_INT 0
6712: ST_TO_ADDR
// end_mission := true ;
6713: LD_ADDR_EXP 12
6717: PUSH
6718: LD_INT 1
6720: ST_TO_ADDR
// end ;
6721: PPOPN 1
6723: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
6724: LD_VAR 0 2
6728: PPUSH
6729: CALL_OW 255
6733: PUSH
6734: LD_INT 1
6736: EQUAL
6737: IFFALSE 6753
// apeman_counter := apeman_counter + 1 ;
6739: LD_ADDR_EXP 10
6743: PUSH
6744: LD_EXP 10
6748: PUSH
6749: LD_INT 1
6751: PLUS
6752: ST_TO_ADDR
// if not first_apeman_tamed then
6753: LD_EXP 6
6757: NOT
6758: IFFALSE 6958
// begin first_apeman_tamed := true ;
6760: LD_ADDR_EXP 6
6764: PUSH
6765: LD_INT 1
6767: ST_TO_ADDR
// if sci = Gladstone then
6768: LD_VAR 0 2
6772: PUSH
6773: LD_EXP 14
6777: EQUAL
6778: IFFALSE 6792
// Say ( Gladstone , D7b-Glad-1 ) ;
6780: LD_EXP 14
6784: PPUSH
6785: LD_STRING D7b-Glad-1
6787: PPUSH
6788: CALL_OW 88
// if sci = Denis then
6792: LD_VAR 0 2
6796: PUSH
6797: LD_EXP 16
6801: EQUAL
6802: IFFALSE 6816
// Say ( Denis , D7a-Den-1 ) ;
6804: LD_EXP 16
6808: PPUSH
6809: LD_STRING D7a-Den-1
6811: PPUSH
6812: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
6816: LD_VAR 0 2
6820: PUSH
6821: LD_EXP 13
6825: PUSH
6826: LD_EXP 14
6830: PUSH
6831: LD_EXP 16
6835: PUSH
6836: LD_EXP 19
6840: PUSH
6841: LD_EXP 20
6845: PUSH
6846: LD_EXP 21
6850: PUSH
6851: LD_EXP 22
6855: PUSH
6856: LD_EXP 18
6860: PUSH
6861: EMPTY
6862: LIST
6863: LIST
6864: LIST
6865: LIST
6866: LIST
6867: LIST
6868: LIST
6869: LIST
6870: IN
6871: NOT
6872: IFFALSE 6915
// begin if GetSex ( sci ) = sex_male then
6874: LD_VAR 0 2
6878: PPUSH
6879: CALL_OW 258
6883: PUSH
6884: LD_INT 1
6886: EQUAL
6887: IFFALSE 6903
// Say ( sci , D7c-Sci1-1 ) else
6889: LD_VAR 0 2
6893: PPUSH
6894: LD_STRING D7c-Sci1-1
6896: PPUSH
6897: CALL_OW 88
6901: GO 6915
// Say ( sci , D7c-FSci1-1 ) ;
6903: LD_VAR 0 2
6907: PPUSH
6908: LD_STRING D7c-FSci1-1
6910: PPUSH
6911: CALL_OW 88
// end ; if not sci = Gladstone then
6915: LD_VAR 0 2
6919: PUSH
6920: LD_EXP 14
6924: EQUAL
6925: NOT
6926: IFFALSE 6940
// Say ( Gladstone , D7c-Glad-1 ) ;
6928: LD_EXP 14
6932: PPUSH
6933: LD_STRING D7c-Glad-1
6935: PPUSH
6936: CALL_OW 88
// if Lisa then
6940: LD_EXP 19
6944: IFFALSE 6958
// Say ( Lisa , D8-Lisa-1 ) ;
6946: LD_EXP 19
6950: PPUSH
6951: LD_STRING D8-Lisa-1
6953: PPUSH
6954: CALL_OW 88
// end ; end ;
6958: PPOPN 2
6960: END
