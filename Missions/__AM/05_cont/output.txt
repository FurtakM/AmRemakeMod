// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 68 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 148 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  22: LD_INT 12
  24: PPUSH
  25: LD_INT 2
  27: PPUSH
  28: CALL 396 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 6 ] [ Difficulty ] ) ;
  32: LD_INT 11
  34: PPUSH
  35: LD_INT 10
  37: PUSH
  38: LD_INT 8
  40: PUSH
  41: LD_INT 6
  43: PUSH
  44: EMPTY
  45: LIST
  46: LIST
  47: LIST
  48: PUSH
  49: LD_OWVAR 67
  53: ARRAY
  54: PPUSH
  55: CALL 396 0 2
// PrepareAmericans ;
  59: CALL 481 0 0
// Action ;
  63: CALL 1379 0 0
// end ;
  67: END
// export debug ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed ; export apeman_counter , arab_spotted , end_mission ; function Init ; begin
  68: LD_INT 0
  70: PPUSH
// debug := true ;
  71: LD_ADDR_EXP 1
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// deltaBuilded := false ;
  79: LD_ADDR_EXP 2
  83: PUSH
  84: LD_INT 0
  86: ST_TO_ADDR
// denisArrives := false ;
  87: LD_ADDR_EXP 3
  91: PUSH
  92: LD_INT 0
  94: ST_TO_ADDR
// radar_allowed := false ;
  95: LD_ADDR_EXP 5
  99: PUSH
 100: LD_INT 0
 102: ST_TO_ADDR
// first_apeman_tamed := false ;
 103: LD_ADDR_EXP 6
 107: PUSH
 108: LD_INT 0
 110: ST_TO_ADDR
// arab_spotted := false ;
 111: LD_ADDR_EXP 8
 115: PUSH
 116: LD_INT 0
 118: ST_TO_ADDR
// end_mission := false ;
 119: LD_ADDR_EXP 9
 123: PUSH
 124: LD_INT 0
 126: ST_TO_ADDR
// apeman_counter := 0 ;
 127: LD_ADDR_EXP 7
 131: PUSH
 132: LD_INT 0
 134: ST_TO_ADDR
// Delta := 0 ;
 135: LD_ADDR_EXP 4
 139: PUSH
 140: LD_INT 0
 142: ST_TO_ADDR
// end ;
 143: LD_VAR 0 1
 147: RET
// function DebugMode ; begin
 148: LD_INT 0
 150: PPUSH
// FogOff ( 1 ) ;
 151: LD_INT 1
 153: PPUSH
 154: CALL_OW 344
// Difficulty := 2 ;
 158: LD_ADDR_OWVAR 67
 162: PUSH
 163: LD_INT 2
 165: ST_TO_ADDR
// end ; end_of_file
 166: LD_VAR 0 1
 170: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 171: LD_INT 0
 173: PPUSH
 174: PPUSH
// if exist_mode then
 175: LD_VAR 0 2
 179: IFFALSE 198
// unit := CreateCharacter ( ident ) else
 181: LD_ADDR_VAR 0 4
 185: PUSH
 186: LD_VAR 0 1
 190: PPUSH
 191: CALL_OW 34
 195: ST_TO_ADDR
 196: GO 213
// unit := NewCharacter ( ident ) ;
 198: LD_ADDR_VAR 0 4
 202: PUSH
 203: LD_VAR 0 1
 207: PPUSH
 208: CALL_OW 25
 212: ST_TO_ADDR
// result := unit ;
 213: LD_ADDR_VAR 0 3
 217: PUSH
 218: LD_VAR 0 4
 222: ST_TO_ADDR
// end ;
 223: LD_VAR 0 3
 227: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 228: LD_INT 0
 230: PPUSH
// uc_side := side ;
 231: LD_ADDR_OWVAR 20
 235: PUSH
 236: LD_VAR 0 1
 240: ST_TO_ADDR
// uc_nation := nation ;
 241: LD_ADDR_OWVAR 21
 245: PUSH
 246: LD_VAR 0 2
 250: ST_TO_ADDR
// vc_chassis := chassis ;
 251: LD_ADDR_OWVAR 37
 255: PUSH
 256: LD_VAR 0 3
 260: ST_TO_ADDR
// vc_engine := engine ;
 261: LD_ADDR_OWVAR 39
 265: PUSH
 266: LD_VAR 0 4
 270: ST_TO_ADDR
// vc_control := control ;
 271: LD_ADDR_OWVAR 38
 275: PUSH
 276: LD_VAR 0 5
 280: ST_TO_ADDR
// vc_weapon := weapon ;
 281: LD_ADDR_OWVAR 40
 285: PUSH
 286: LD_VAR 0 6
 290: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 291: LD_ADDR_OWVAR 41
 295: PUSH
 296: LD_VAR 0 7
 300: ST_TO_ADDR
// result := CreateVehicle ;
 301: LD_ADDR_VAR 0 8
 305: PUSH
 306: CALL_OW 45
 310: ST_TO_ADDR
// end ;
 311: LD_VAR 0 8
 315: RET
// export function SayX ( units , ident ) ; var i ; begin
 316: LD_INT 0
 318: PPUSH
 319: PPUSH
// result := false ;
 320: LD_ADDR_VAR 0 3
 324: PUSH
 325: LD_INT 0
 327: ST_TO_ADDR
// if not units then
 328: LD_VAR 0 1
 332: NOT
 333: IFFALSE 337
// exit ;
 335: GO 391
// for i in units do
 337: LD_ADDR_VAR 0 4
 341: PUSH
 342: LD_VAR 0 1
 346: PUSH
 347: FOR_IN
 348: IFFALSE 389
// if IsOk ( i ) then
 350: LD_VAR 0 4
 354: PPUSH
 355: CALL_OW 302
 359: IFFALSE 387
// begin Say ( i , ident ) ;
 361: LD_VAR 0 4
 365: PPUSH
 366: LD_VAR 0 2
 370: PPUSH
 371: CALL_OW 88
// result := i ;
 375: LD_ADDR_VAR 0 3
 379: PUSH
 380: LD_VAR 0 4
 384: ST_TO_ADDR
// break ;
 385: GO 389
// end ;
 387: GO 347
 389: POP
 390: POP
// end ;
 391: LD_VAR 0 3
 395: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 396: LD_INT 0
 398: PPUSH
 399: PPUSH
// InitUc ;
 400: CALL_OW 18
// InitHc ;
 404: CALL_OW 19
// uc_side := 0 ;
 408: LD_ADDR_OWVAR 20
 412: PUSH
 413: LD_INT 0
 415: ST_TO_ADDR
// uc_nation := 0 ;
 416: LD_ADDR_OWVAR 21
 420: PUSH
 421: LD_INT 0
 423: ST_TO_ADDR
// for i = 1 to amount do
 424: LD_ADDR_VAR 0 4
 428: PUSH
 429: DOUBLE
 430: LD_INT 1
 432: DEC
 433: ST_TO_ADDR
 434: LD_VAR 0 2
 438: PUSH
 439: FOR_TO
 440: IFFALSE 474
// begin PrepareHuman ( false , class_apeman , 1 ) ;
 442: LD_INT 0
 444: PPUSH
 445: LD_INT 12
 447: PPUSH
 448: LD_INT 1
 450: PPUSH
 451: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 455: CALL_OW 44
 459: PPUSH
 460: LD_VAR 0 1
 464: PPUSH
 465: LD_INT 0
 467: PPUSH
 468: CALL_OW 49
// end ;
 472: GO 439
 474: POP
 475: POP
// end ; end_of_file
 476: LD_VAR 0 3
 480: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
 481: LD_INT 0
 483: PPUSH
 484: PPUSH
 485: PPUSH
 486: PPUSH
 487: PPUSH
// uc_nation := 1 ;
 488: LD_ADDR_OWVAR 21
 492: PUSH
 493: LD_INT 1
 495: ST_TO_ADDR
// uc_side := 4 ;
 496: LD_ADDR_OWVAR 20
 500: PUSH
 501: LD_INT 4
 503: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
 504: LD_ADDR_EXP 13
 508: PUSH
 509: LD_STRING Denis
 511: PPUSH
 512: LD_INT 0
 514: PPUSH
 515: CALL 171 0 2
 519: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
 520: LD_ADDR_EXP 12
 524: PUSH
 525: LD_STRING Harisson
 527: PPUSH
 528: LD_INT 0
 530: PPUSH
 531: CALL 171 0 2
 535: ST_TO_ADDR
// uc_side := 1 ;
 536: LD_ADDR_OWVAR 20
 540: PUSH
 541: LD_INT 1
 543: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
 544: LD_ADDR_EXP 10
 548: PUSH
 549: LD_STRING JMM
 551: PPUSH
 552: LD_EXP 1
 556: NOT
 557: PPUSH
 558: CALL 171 0 2
 562: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
 563: LD_ADDR_EXP 11
 567: PUSH
 568: LD_STRING Gladstone
 570: PPUSH
 571: LD_INT 0
 573: PPUSH
 574: CALL 171 0 2
 578: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
 579: LD_STRING BrownInDelta
 581: PPUSH
 582: LD_EXP 1
 586: PPUSH
 587: CALL_OW 30
 591: IFFALSE 628
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
 593: LD_ADDR_EXP 14
 597: PUSH
 598: LD_STRING Brown
 600: PPUSH
 601: LD_EXP 1
 605: NOT
 606: PPUSH
 607: CALL 171 0 2
 611: ST_TO_ADDR
// tmp := tmp ^ Brown ;
 612: LD_ADDR_VAR 0 5
 616: PUSH
 617: LD_VAR 0 5
 621: PUSH
 622: LD_EXP 14
 626: ADD
 627: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , 0 ) then
 628: LD_STRING DonaldsonInDelta
 630: PPUSH
 631: LD_INT 0
 633: PPUSH
 634: CALL_OW 30
 638: IFFALSE 675
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
 640: LD_ADDR_EXP 15
 644: PUSH
 645: LD_STRING Donaldson
 647: PPUSH
 648: LD_EXP 1
 652: NOT
 653: PPUSH
 654: CALL 171 0 2
 658: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
 659: LD_ADDR_VAR 0 5
 663: PUSH
 664: LD_VAR 0 5
 668: PUSH
 669: LD_EXP 15
 673: ADD
 674: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
 675: LD_STRING LisaInDelta
 677: PPUSH
 678: LD_EXP 1
 682: PPUSH
 683: CALL_OW 30
 687: IFFALSE 724
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
 689: LD_ADDR_EXP 16
 693: PUSH
 694: LD_STRING Lisa
 696: PPUSH
 697: LD_EXP 1
 701: NOT
 702: PPUSH
 703: CALL 171 0 2
 707: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
 708: LD_ADDR_VAR 0 5
 712: PUSH
 713: LD_VAR 0 5
 717: PUSH
 718: LD_EXP 16
 722: ADD
 723: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
 724: LD_STRING FrankInDelta
 726: PPUSH
 727: LD_EXP 1
 731: PPUSH
 732: CALL_OW 30
 736: IFFALSE 773
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
 738: LD_ADDR_EXP 17
 742: PUSH
 743: LD_STRING Frank
 745: PPUSH
 746: LD_EXP 1
 750: NOT
 751: PPUSH
 752: CALL 171 0 2
 756: ST_TO_ADDR
// tmp := tmp ^ Frank ;
 757: LD_ADDR_VAR 0 5
 761: PUSH
 762: LD_VAR 0 5
 766: PUSH
 767: LD_EXP 17
 771: ADD
 772: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
 773: LD_STRING BobbyInDelta
 775: PPUSH
 776: LD_INT 0
 778: PPUSH
 779: CALL_OW 30
 783: IFFALSE 820
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
 785: LD_ADDR_EXP 18
 789: PUSH
 790: LD_STRING Bobby
 792: PPUSH
 793: LD_EXP 1
 797: NOT
 798: PPUSH
 799: CALL 171 0 2
 803: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
 804: LD_ADDR_VAR 0 5
 808: PUSH
 809: LD_VAR 0 5
 813: PUSH
 814: LD_EXP 18
 818: ADD
 819: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
 820: LD_STRING CyrusInDelta
 822: PPUSH
 823: LD_INT 0
 825: PPUSH
 826: CALL_OW 30
 830: IFFALSE 867
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
 832: LD_ADDR_EXP 19
 836: PUSH
 837: LD_STRING Cyrus
 839: PPUSH
 840: LD_EXP 1
 844: NOT
 845: PPUSH
 846: CALL 171 0 2
 850: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
 851: LD_ADDR_VAR 0 5
 855: PUSH
 856: LD_VAR 0 5
 860: PUSH
 861: LD_EXP 19
 865: ADD
 866: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
 867: LD_ADDR_EXP 20
 871: PUSH
 872: LD_STRING othersDelta
 874: PPUSH
 875: CALL_OW 31
 879: ST_TO_ADDR
// if not others and debug then
 880: LD_EXP 20
 884: NOT
 885: PUSH
 886: LD_EXP 1
 890: AND
 891: IFFALSE 956
// begin InitHc ;
 893: CALL_OW 19
// for i = 1 to 2 do
 897: LD_ADDR_VAR 0 2
 901: PUSH
 902: DOUBLE
 903: LD_INT 1
 905: DEC
 906: ST_TO_ADDR
 907: LD_INT 2
 909: PUSH
 910: FOR_TO
 911: IFFALSE 954
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
 913: LD_INT 0
 915: PPUSH
 916: LD_VAR 0 2
 920: PUSH
 921: LD_INT 4
 923: MOD
 924: PUSH
 925: LD_INT 1
 927: PLUS
 928: PPUSH
 929: LD_INT 3
 931: PPUSH
 932: CALL_OW 380
// others := others ^ CreateHuman ;
 936: LD_ADDR_EXP 20
 940: PUSH
 941: LD_EXP 20
 945: PUSH
 946: CALL_OW 44
 950: ADD
 951: ST_TO_ADDR
// end ;
 952: GO 910
 954: POP
 955: POP
// end ; if others then
 956: LD_EXP 20
 960: IFFALSE 978
// tmp := tmp ^ others ;
 962: LD_ADDR_VAR 0 5
 966: PUSH
 967: LD_VAR 0 5
 971: PUSH
 972: LD_EXP 20
 976: ADD
 977: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
 978: LD_ADDR_VAR 0 3
 982: PUSH
 983: LD_INT 28
 985: PUSH
 986: LD_INT 49
 988: PUSH
 989: EMPTY
 990: LIST
 991: LIST
 992: PUSH
 993: LD_INT 33
 995: PUSH
 996: LD_INT 54
 998: PUSH
 999: EMPTY
1000: LIST
1001: LIST
1002: PUSH
1003: LD_INT 38
1005: PUSH
1006: LD_INT 56
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: LIST
1017: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1018: LD_ADDR_VAR 0 4
1022: PUSH
1023: LD_INT 1
1025: PPUSH
1026: LD_INT 1
1028: PPUSH
1029: LD_INT 2
1031: PPUSH
1032: LD_INT 2
1034: PPUSH
1035: LD_INT 1
1037: PPUSH
1038: LD_INT 12
1040: PPUSH
1041: LD_INT 80
1043: PPUSH
1044: CALL 228 0 7
1048: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1049: LD_VAR 0 4
1053: PPUSH
1054: LD_INT 1
1056: PPUSH
1057: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1061: LD_VAR 0 4
1065: PPUSH
1066: LD_VAR 0 3
1070: PUSH
1071: LD_INT 1
1073: ARRAY
1074: PUSH
1075: LD_INT 1
1077: ARRAY
1078: PPUSH
1079: LD_VAR 0 3
1083: PUSH
1084: LD_INT 1
1086: ARRAY
1087: PUSH
1088: LD_INT 2
1090: ARRAY
1091: PPUSH
1092: LD_INT 0
1094: PPUSH
1095: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1099: LD_VAR 0 4
1103: PPUSH
1104: LD_INT 1
1106: PPUSH
1107: LD_INT 100
1109: PPUSH
1110: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1114: LD_EXP 20
1118: PUSH
1119: LD_INT 1
1121: ARRAY
1122: PPUSH
1123: LD_VAR 0 4
1127: PPUSH
1128: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1132: LD_ADDR_VAR 0 4
1136: PUSH
1137: LD_INT 1
1139: PPUSH
1140: LD_INT 1
1142: PPUSH
1143: LD_INT 1
1145: PPUSH
1146: LD_INT 2
1148: PPUSH
1149: LD_INT 1
1151: PPUSH
1152: LD_INT 2
1154: PPUSH
1155: LD_INT 80
1157: PPUSH
1158: CALL 228 0 7
1162: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1163: LD_VAR 0 4
1167: PPUSH
1168: LD_INT 1
1170: PPUSH
1171: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1175: LD_VAR 0 4
1179: PPUSH
1180: LD_VAR 0 3
1184: PUSH
1185: LD_INT 2
1187: ARRAY
1188: PUSH
1189: LD_INT 1
1191: ARRAY
1192: PPUSH
1193: LD_VAR 0 3
1197: PUSH
1198: LD_INT 2
1200: ARRAY
1201: PUSH
1202: LD_INT 2
1204: ARRAY
1205: PPUSH
1206: LD_INT 0
1208: PPUSH
1209: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1213: LD_EXP 11
1217: PPUSH
1218: LD_VAR 0 4
1222: PPUSH
1223: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
1227: LD_ADDR_VAR 0 4
1231: PUSH
1232: LD_INT 1
1234: PPUSH
1235: LD_INT 1
1237: PPUSH
1238: LD_INT 1
1240: PPUSH
1241: LD_INT 2
1243: PPUSH
1244: LD_INT 1
1246: PPUSH
1247: LD_INT 3
1249: PPUSH
1250: LD_INT 80
1252: PPUSH
1253: CALL 228 0 7
1257: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1258: LD_VAR 0 4
1262: PPUSH
1263: LD_INT 1
1265: PPUSH
1266: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
1270: LD_VAR 0 4
1274: PPUSH
1275: LD_VAR 0 3
1279: PUSH
1280: LD_INT 3
1282: ARRAY
1283: PUSH
1284: LD_INT 1
1286: ARRAY
1287: PPUSH
1288: LD_VAR 0 3
1292: PUSH
1293: LD_INT 3
1295: ARRAY
1296: PUSH
1297: LD_INT 2
1299: ARRAY
1300: PPUSH
1301: LD_INT 0
1303: PPUSH
1304: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1308: LD_EXP 10
1312: PPUSH
1313: LD_VAR 0 4
1317: PPUSH
1318: CALL_OW 52
// if others > 1 then
1322: LD_EXP 20
1326: PUSH
1327: LD_INT 1
1329: GREATER
1330: IFFALSE 1374
// for i in tmp diff others [ 1 ] do
1332: LD_ADDR_VAR 0 2
1336: PUSH
1337: LD_VAR 0 5
1341: PUSH
1342: LD_EXP 20
1346: PUSH
1347: LD_INT 1
1349: ARRAY
1350: DIFF
1351: PUSH
1352: FOR_IN
1353: IFFALSE 1372
// PlaceUnitArea ( i , startArea , false ) ;
1355: LD_VAR 0 2
1359: PPUSH
1360: LD_INT 5
1362: PPUSH
1363: LD_INT 0
1365: PPUSH
1366: CALL_OW 49
1370: GO 1352
1372: POP
1373: POP
// end ; end_of_file
1374: LD_VAR 0 1
1378: RET
// export function Action ; begin
1379: LD_INT 0
1381: PPUSH
// InGameOn ;
1382: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
1386: LD_INT 28
1388: PPUSH
1389: LD_INT 51
1391: PPUSH
1392: CALL_OW 86
// Wait ( 3 ) ;
1396: LD_INT 3
1398: PPUSH
1399: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
1403: LD_EXP 10
1407: PPUSH
1408: LD_STRING D1d-JMM-1a
1410: PPUSH
1411: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
1415: LD_EXP 12
1419: PPUSH
1420: LD_STRING D1d-Har-1
1422: PPUSH
1423: CALL_OW 94
// InGameOff ;
1427: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
1431: LD_STRING M1
1433: PPUSH
1434: CALL_OW 337
// Wait ( 0 0$2 ) ;
1438: LD_INT 70
1440: PPUSH
1441: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
1445: LD_EXP 10
1449: PPUSH
1450: LD_STRING D2-JMM-1
1452: PPUSH
1453: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
1457: LD_EXP 11
1461: PPUSH
1462: LD_STRING D2-Glad-1
1464: PPUSH
1465: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
1469: LD_EXP 10
1473: PPUSH
1474: LD_STRING D2-JMM-2
1476: PPUSH
1477: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
1481: LD_EXP 11
1485: PPUSH
1486: LD_STRING D2-Glad-2
1488: PPUSH
1489: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
1493: LD_EXP 10
1497: PPUSH
1498: LD_STRING D2-JMM-3
1500: PPUSH
1501: CALL_OW 88
// end ;
1505: LD_VAR 0 1
1509: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
1510: LD_INT 22
1512: PUSH
1513: LD_INT 1
1515: PUSH
1516: EMPTY
1517: LIST
1518: LIST
1519: PUSH
1520: LD_INT 3
1522: PUSH
1523: LD_INT 57
1525: PUSH
1526: EMPTY
1527: LIST
1528: PUSH
1529: EMPTY
1530: LIST
1531: LIST
1532: PUSH
1533: LD_INT 30
1535: PUSH
1536: LD_INT 0
1538: PUSH
1539: EMPTY
1540: LIST
1541: LIST
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: LIST
1547: PUSH
1548: EMPTY
1549: LIST
1550: PPUSH
1551: CALL_OW 69
1555: PUSH
1556: LD_EXP 2
1560: NOT
1561: AND
1562: IFFALSE 1642
1564: GO 1566
1566: DISABLE
// begin deltaBuilded := true ;
1567: LD_ADDR_EXP 2
1571: PUSH
1572: LD_INT 1
1574: ST_TO_ADDR
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
1575: LD_ADDR_EXP 4
1579: PUSH
1580: LD_INT 22
1582: PUSH
1583: LD_INT 1
1585: PUSH
1586: EMPTY
1587: LIST
1588: LIST
1589: PUSH
1590: LD_INT 3
1592: PUSH
1593: LD_INT 57
1595: PUSH
1596: EMPTY
1597: LIST
1598: PUSH
1599: EMPTY
1600: LIST
1601: LIST
1602: PUSH
1603: LD_INT 30
1605: PUSH
1606: LD_INT 0
1608: PUSH
1609: EMPTY
1610: LIST
1611: LIST
1612: PUSH
1613: EMPTY
1614: LIST
1615: LIST
1616: LIST
1617: PUSH
1618: EMPTY
1619: LIST
1620: PPUSH
1621: CALL_OW 69
1625: PUSH
1626: LD_INT 1
1628: ARRAY
1629: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
1630: LD_EXP 4
1634: PPUSH
1635: LD_STRING Delta
1637: PPUSH
1638: CALL_OW 500
// end ;
1642: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched do
1643: LD_INT 1
1645: PPUSH
1646: LD_INT 1
1648: PPUSH
1649: CALL_OW 321
1653: PUSH
1654: LD_INT 2
1656: EQUAL
1657: IFFALSE 1718
1659: GO 1661
1661: DISABLE
// begin DialogueOn ;
1662: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
1666: LD_EXP 11
1670: PPUSH
1671: LD_STRING D3-Glad-1
1673: PPUSH
1674: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
1678: LD_EXP 10
1682: PPUSH
1683: LD_STRING D3-JMM-1
1685: PPUSH
1686: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
1690: LD_EXP 11
1694: PPUSH
1695: LD_STRING D3-Glad-2
1697: PPUSH
1698: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
1702: LD_EXP 10
1706: PPUSH
1707: LD_STRING D3-JMM-2
1709: PPUSH
1710: CALL_OW 88
// DialogueOff ;
1714: CALL_OW 7
// end ;
1718: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
1719: LD_VAR 0 2
1723: PPUSH
1724: CALL_OW 255
1728: PUSH
1729: LD_INT 1
1731: EQUAL
1732: IFFALSE 1748
// apeman_counter := apeman_counter + 1 ;
1734: LD_ADDR_EXP 7
1738: PUSH
1739: LD_EXP 7
1743: PUSH
1744: LD_INT 1
1746: PLUS
1747: ST_TO_ADDR
// if not first_apeman_tamed then
1748: LD_EXP 6
1752: NOT
1753: IFFALSE 1940
// begin first_apeman_tamed := true ;
1755: LD_ADDR_EXP 6
1759: PUSH
1760: LD_INT 1
1762: ST_TO_ADDR
// if sci = Gladstone then
1763: LD_VAR 0 2
1767: PUSH
1768: LD_EXP 11
1772: EQUAL
1773: IFFALSE 1787
// Say ( Gladstone , D7b-Glad-1 ) ;
1775: LD_EXP 11
1779: PPUSH
1780: LD_STRING D7b-Glad-1
1782: PPUSH
1783: CALL_OW 88
// if sci = Denis then
1787: LD_VAR 0 2
1791: PUSH
1792: LD_EXP 13
1796: EQUAL
1797: IFFALSE 1811
// Say ( Denis , D7a-Den-1 ) ;
1799: LD_EXP 13
1803: PPUSH
1804: LD_STRING D7a-Den-1
1806: PPUSH
1807: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
1811: LD_VAR 0 2
1815: PUSH
1816: LD_EXP 10
1820: PUSH
1821: LD_EXP 11
1825: PUSH
1826: LD_EXP 13
1830: PUSH
1831: LD_EXP 16
1835: PUSH
1836: LD_EXP 17
1840: PUSH
1841: LD_EXP 18
1845: PUSH
1846: LD_EXP 19
1850: PUSH
1851: LD_EXP 15
1855: PUSH
1856: EMPTY
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: IN
1866: NOT
1867: IFFALSE 1922
// begin if GetSex ( sci ) = sex_male then
1869: LD_VAR 0 2
1873: PPUSH
1874: CALL_OW 258
1878: PUSH
1879: LD_INT 1
1881: EQUAL
1882: IFFALSE 1898
// Say ( sci , D7c-Sci1-1 ) else
1884: LD_VAR 0 2
1888: PPUSH
1889: LD_STRING D7c-Sci1-1
1891: PPUSH
1892: CALL_OW 88
1896: GO 1910
// Say ( sci , D7c-FSci1-1 ) ;
1898: LD_VAR 0 2
1902: PPUSH
1903: LD_STRING D7c-FSci1-1
1905: PPUSH
1906: CALL_OW 88
// Say ( Gladstone , D7c-Glad-1 ) ;
1910: LD_EXP 11
1914: PPUSH
1915: LD_STRING D7c-Glad-1
1917: PPUSH
1918: CALL_OW 88
// end ; if Lisa then
1922: LD_EXP 16
1926: IFFALSE 1940
// Say ( Lisa , D8-Lisa-1 ) ;
1928: LD_EXP 16
1932: PPUSH
1933: LD_STRING D8-Lisa-1
1935: PPUSH
1936: CALL_OW 88
// end ; end ;
1940: PPOPN 2
1942: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
1943: LD_INT 2
1945: PPUSH
1946: LD_INT 1
1948: PPUSH
1949: CALL_OW 321
1953: PUSH
1954: LD_INT 2
1956: EQUAL
1957: IFFALSE 2134
1959: GO 1961
1961: DISABLE
1962: LD_INT 0
1964: PPUSH
// begin DialogueOn ;
1965: CALL_OW 6
// if Frank then
1969: LD_EXP 17
1973: IFFALSE 1987
// Say ( Frank , D8a-Frank-1 ) ;
1975: LD_EXP 17
1979: PPUSH
1980: LD_STRING D8a-Frank-1
1982: PPUSH
1983: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
1987: LD_ADDR_VAR 0 1
1991: PUSH
1992: LD_EXP 20
1996: PPUSH
1997: LD_INT 26
1999: PUSH
2000: LD_INT 1
2002: PUSH
2003: EMPTY
2004: LIST
2005: LIST
2006: PPUSH
2007: CALL_OW 72
2011: PPUSH
2012: LD_STRING D8a-Sol1-1
2014: PPUSH
2015: CALL 316 0 2
2019: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2020: LD_EXP 13
2024: PUSH
2025: LD_EXP 13
2029: PPUSH
2030: CALL_OW 255
2034: PUSH
2035: LD_INT 1
2037: EQUAL
2038: AND
2039: IFFALSE 2053
// Say ( Denis , D8a-Den-1 ) ;
2041: LD_EXP 13
2045: PPUSH
2046: LD_STRING D8a-Den-1
2048: PPUSH
2049: CALL_OW 88
// if sol or Denis or Frank then
2053: LD_VAR 0 1
2057: PUSH
2058: LD_EXP 13
2062: OR
2063: PUSH
2064: LD_EXP 17
2068: OR
2069: IFFALSE 2130
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2071: LD_EXP 20
2075: PPUSH
2076: LD_INT 25
2078: PUSH
2079: LD_INT 4
2081: PUSH
2082: EMPTY
2083: LIST
2084: LIST
2085: PUSH
2086: LD_INT 26
2088: PUSH
2089: LD_INT 1
2091: PUSH
2092: EMPTY
2093: LIST
2094: LIST
2095: PUSH
2096: EMPTY
2097: LIST
2098: LIST
2099: PPUSH
2100: CALL_OW 72
2104: PUSH
2105: LD_VAR 0 1
2109: DIFF
2110: PPUSH
2111: LD_STRING D8a-Sci1-1
2113: PPUSH
2114: CALL 316 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2118: LD_EXP 10
2122: PPUSH
2123: LD_STRING D8a-JMM-1
2125: PPUSH
2126: CALL_OW 88
// end ; DialogueOff ;
2130: CALL_OW 7
// end ;
2134: PPOPN 1
2136: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2137: LD_INT 22
2139: PUSH
2140: LD_INT 1
2142: PUSH
2143: EMPTY
2144: LIST
2145: LIST
2146: PUSH
2147: LD_INT 25
2149: PUSH
2150: LD_INT 16
2152: PUSH
2153: EMPTY
2154: LIST
2155: LIST
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PPUSH
2161: CALL_OW 69
2165: IFFALSE 2224
2167: GO 2169
2169: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2170: LD_STRING M1a
2172: PPUSH
2173: CALL_OW 337
// case Query ( Q2 ) of 1 :
2177: LD_STRING Q2
2179: PPUSH
2180: CALL_OW 97
2184: PUSH
2185: LD_INT 1
2187: DOUBLE
2188: EQUAL
2189: IFTRUE 2193
2191: GO 2204
2193: POP
// end_mission := true ; 2 :
2194: LD_ADDR_EXP 9
2198: PUSH
2199: LD_INT 1
2201: ST_TO_ADDR
2202: GO 2224
2204: LD_INT 2
2206: DOUBLE
2207: EQUAL
2208: IFTRUE 2212
2210: GO 2223
2212: POP
// end_the_mission_allowed := true ; end ;
2213: LD_ADDR_OWVAR 57
2217: PUSH
2218: LD_INT 1
2220: ST_TO_ADDR
2221: GO 2224
2223: POP
// end ;
2224: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_lab ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_workshop ] ] ) and Delta do
2225: LD_INT 22
2227: PUSH
2228: LD_INT 1
2230: PUSH
2231: EMPTY
2232: LIST
2233: LIST
2234: PUSH
2235: LD_INT 30
2237: PUSH
2238: LD_INT 6
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PPUSH
2249: CALL_OW 69
2253: PUSH
2254: LD_INT 22
2256: PUSH
2257: LD_INT 1
2259: PUSH
2260: EMPTY
2261: LIST
2262: LIST
2263: PUSH
2264: LD_INT 30
2266: PUSH
2267: LD_INT 2
2269: PUSH
2270: EMPTY
2271: LIST
2272: LIST
2273: PUSH
2274: EMPTY
2275: LIST
2276: LIST
2277: PPUSH
2278: CALL_OW 69
2282: AND
2283: PUSH
2284: LD_EXP 4
2288: AND
2289: IFFALSE 2712
2291: GO 2293
2293: DISABLE
// begin Wait ( rand ( 0 0$20 , 0 0$40 ) ) ;
2294: LD_INT 700
2296: PPUSH
2297: LD_INT 1400
2299: PPUSH
2300: CALL_OW 12
2304: PPUSH
2305: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
2309: LD_EXP 13
2313: PPUSH
2314: LD_INT 6
2316: PUSH
2317: LD_INT 9
2319: PUSH
2320: LD_INT 10
2322: PUSH
2323: EMPTY
2324: LIST
2325: LIST
2326: LIST
2327: PUSH
2328: LD_OWVAR 67
2332: ARRAY
2333: PPUSH
2334: LD_INT 0
2336: PPUSH
2337: CALL_OW 49
// ComHold ( Denis ) ;
2341: LD_EXP 13
2345: PPUSH
2346: CALL_OW 140
// InGameOn ;
2350: CALL_OW 8
// DialogueOn ;
2354: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
2358: LD_EXP 10
2362: PPUSH
2363: CALL_OW 87
// Say ( Denis , DD-Den-1 ) ;
2367: LD_EXP 13
2371: PPUSH
2372: LD_STRING DD-Den-1
2374: PPUSH
2375: CALL_OW 88
// Say ( JMM , DD-JMM-1 ) ;
2379: LD_EXP 10
2383: PPUSH
2384: LD_STRING DD-JMM-1
2386: PPUSH
2387: CALL_OW 88
// Say ( Denis , DD-Den-2 ) ;
2391: LD_EXP 13
2395: PPUSH
2396: LD_STRING DD-Den-2
2398: PPUSH
2399: CALL_OW 88
// Wait ( 3 ) ;
2403: LD_INT 3
2405: PPUSH
2406: CALL_OW 67
// DialogueOff ;
2410: CALL_OW 7
// InGameOff ;
2414: CALL_OW 9
// repeat wait ( 0 0$01 ) ;
2418: LD_INT 35
2420: PPUSH
2421: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
2425: LD_INT 1
2427: PPUSH
2428: LD_EXP 13
2432: PPUSH
2433: CALL_OW 292
2437: PUSH
2438: LD_EXP 13
2442: PPUSH
2443: CALL_OW 301
2447: OR
2448: IFFALSE 2418
// if IsDead ( Denis ) then
2450: LD_EXP 13
2454: PPUSH
2455: CALL_OW 301
2459: IFFALSE 2463
// exit ;
2461: GO 2712
// SetSide ( Denis , 1 ) ;
2463: LD_EXP 13
2467: PPUSH
2468: LD_INT 1
2470: PPUSH
2471: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
2475: LD_EXP 13
2479: PPUSH
2480: LD_STRING DD-Den-2a
2482: PPUSH
2483: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
2487: LD_INT 35
2489: PPUSH
2490: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
2494: LD_EXP 13
2498: PPUSH
2499: CALL_OW 310
2503: PPUSH
2504: CALL_OW 266
2508: PUSH
2509: LD_INT 6
2511: PUSH
2512: LD_INT 7
2514: PUSH
2515: LD_INT 8
2517: PUSH
2518: EMPTY
2519: LIST
2520: LIST
2521: LIST
2522: IN
2523: PUSH
2524: LD_EXP 13
2528: PPUSH
2529: CALL_OW 301
2533: OR
2534: IFFALSE 2487
// if IsDead ( Denis ) then
2536: LD_EXP 13
2540: PPUSH
2541: CALL_OW 301
2545: IFFALSE 2549
// exit ;
2547: GO 2712
// Say ( Denis , DD-Den-2b ) ;
2549: LD_EXP 13
2553: PPUSH
2554: LD_STRING DD-Den-2b
2556: PPUSH
2557: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
2561: LD_EXP 13
2565: PPUSH
2566: LD_INT 4
2568: PPUSH
2569: CALL_OW 123
// Wait ( 0 0$02 ) ;
2573: LD_INT 70
2575: PPUSH
2576: CALL_OW 67
// DialogueOn ;
2580: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
2584: LD_EXP 13
2588: PPUSH
2589: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
2593: LD_EXP 10
2597: PPUSH
2598: LD_STRING D4-JMM-1
2600: PPUSH
2601: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
2605: LD_EXP 13
2609: PPUSH
2610: LD_STRING D4-Den-1
2612: PPUSH
2613: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
2617: LD_EXP 10
2621: PPUSH
2622: LD_STRING D4-JMM-2
2624: PPUSH
2625: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
2629: LD_EXP 13
2633: PPUSH
2634: LD_STRING D4-Den-2
2636: PPUSH
2637: CALL_OW 88
// DialogueOff ;
2641: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
2645: LD_STRING M2
2647: PPUSH
2648: CALL_OW 337
// radar_allowed := true ;
2652: LD_ADDR_EXP 5
2656: PUSH
2657: LD_INT 1
2659: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
2660: LD_INT 6
2662: PPUSH
2663: LD_INT 1
2665: PPUSH
2666: LD_INT 1
2668: PPUSH
2669: CALL_OW 322
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
2673: LD_INT 7
2675: PPUSH
2676: LD_INT 1
2678: PPUSH
2679: LD_INT 1
2681: PPUSH
2682: CALL_OW 324
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
2686: LD_INT 15
2688: PPUSH
2689: LD_INT 1
2691: PPUSH
2692: LD_INT 1
2694: PPUSH
2695: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
2699: LD_INT 20
2701: PPUSH
2702: LD_INT 1
2704: PPUSH
2705: LD_INT 1
2707: PPUSH
2708: CALL_OW 324
// end ;
2712: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
2713: LD_VAR 0 1
2717: PUSH
2718: LD_INT 1
2720: EQUAL
2721: PUSH
2722: LD_VAR 0 2
2726: PUSH
2727: LD_INT 2
2729: EQUAL
2730: AND
2731: PUSH
2732: LD_EXP 8
2736: NOT
2737: AND
2738: IFFALSE 2748
// arab_spotted := true ;
2740: LD_ADDR_EXP 8
2744: PUSH
2745: LD_INT 1
2747: ST_TO_ADDR
2748: PPOPN 2
2750: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
2751: LD_ADDR_OWVAR 57
2755: PUSH
2756: LD_INT 0
2758: ST_TO_ADDR
// end_mission := true ;
2759: LD_ADDR_EXP 9
2763: PUSH
2764: LD_INT 1
2766: ST_TO_ADDR
// end ;
2767: PPOPN 1
2769: END
// every 0 0$1 trigger end_mission do
2770: LD_EXP 9
2774: IFFALSE 2779
2776: GO 2778
2778: DISABLE
// begin end ; end_of_file
2779: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un ; begin
2780: LD_INT 0
2782: PPUSH
2783: PPUSH
2784: PPUSH
// InitHc ;
2785: CALL_OW 19
// InitUc ;
2789: CALL_OW 18
// uc_side := 2 ;
2793: LD_ADDR_OWVAR 20
2797: PUSH
2798: LD_INT 2
2800: ST_TO_ADDR
// uc_nation := 2 ;
2801: LD_ADDR_OWVAR 21
2805: PUSH
2806: LD_INT 2
2808: ST_TO_ADDR
// for i = 1 to amount do
2809: LD_ADDR_VAR 0 5
2813: PUSH
2814: DOUBLE
2815: LD_INT 1
2817: DEC
2818: ST_TO_ADDR
2819: LD_VAR 0 1
2823: PUSH
2824: FOR_TO
2825: IFFALSE 2861
// begin PrepareHuman ( false , 1 , skill ) ;
2827: LD_INT 0
2829: PPUSH
2830: LD_INT 1
2832: PPUSH
2833: LD_VAR 0 2
2837: PPUSH
2838: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
2842: CALL_OW 44
2846: PPUSH
2847: LD_VAR 0 3
2851: PPUSH
2852: LD_INT 0
2854: PPUSH
2855: CALL_OW 49
// end ;
2859: GO 2824
2861: POP
2862: POP
// end ; end_of_file
2863: LD_VAR 0 4
2867: RET
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
2868: LD_EXP 4
2872: IFFALSE 3004
2874: GO 2876
2876: DISABLE
2877: LD_INT 0
2879: PPUSH
2880: PPUSH
2881: PPUSH
// begin counter := [ 700 , 600 , 500 ] [ Difficulty ] ;
2882: LD_ADDR_VAR 0 2
2886: PUSH
2887: LD_INT 700
2889: PUSH
2890: LD_INT 600
2892: PUSH
2893: LD_INT 500
2895: PUSH
2896: EMPTY
2897: LIST
2898: LIST
2899: LIST
2900: PUSH
2901: LD_OWVAR 67
2905: ARRAY
2906: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
2907: LD_INT 1
2909: PPUSH
2910: LD_INT 3
2912: PPUSH
2913: CALL_OW 12
2917: PPUSH
2918: LD_INT 7
2920: PPUSH
2921: LD_INT 1
2923: PPUSH
2924: CALL_OW 55
// repeat wait ( rand ( 0 0$30 , 1 1$20 ) ) ;
2928: LD_INT 1050
2930: PPUSH
2931: LD_INT 2800
2933: PPUSH
2934: CALL_OW 12
2938: PPUSH
2939: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
2943: LD_ADDR_VAR 0 3
2947: PUSH
2948: LD_INT 1
2950: PPUSH
2951: LD_INT 5
2953: PPUSH
2954: CALL_OW 12
2958: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
2959: LD_VAR 0 3
2963: PPUSH
2964: LD_INT 7
2966: PPUSH
2967: LD_INT 1
2969: PPUSH
2970: CALL_OW 55
// counter := counter - cr * 10 ;
2974: LD_ADDR_VAR 0 2
2978: PUSH
2979: LD_VAR 0 2
2983: PUSH
2984: LD_VAR 0 3
2988: PUSH
2989: LD_INT 10
2991: MUL
2992: MINUS
2993: ST_TO_ADDR
// until counter <= 0 ;
2994: LD_VAR 0 2
2998: PUSH
2999: LD_INT 0
3001: LESSEQUAL
3002: IFFALSE 2928
// end ;
3004: PPOPN 3
3006: END
// every 0 0$03 trigger not Delta do var i ;
3007: LD_EXP 4
3011: NOT
3012: IFFALSE 3082
3014: GO 3016
3016: DISABLE
3017: LD_INT 0
3019: PPUSH
// begin for i = 1 to 4 - Difficulty do
3020: LD_ADDR_VAR 0 1
3024: PUSH
3025: DOUBLE
3026: LD_INT 1
3028: DEC
3029: ST_TO_ADDR
3030: LD_INT 4
3032: PUSH
3033: LD_OWVAR 67
3037: MINUS
3038: PUSH
3039: FOR_TO
3040: IFFALSE 3080
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
3042: LD_INT 2
3044: PPUSH
3045: LD_INT 5
3047: PPUSH
3048: CALL_OW 12
3052: PPUSH
3053: LD_INT 8
3055: PPUSH
3056: LD_INT 1
3058: PPUSH
3059: CALL_OW 55
// Wait ( rand ( 0 0$06 , 0 0$09 ) ) ;
3063: LD_INT 210
3065: PPUSH
3066: LD_INT 315
3068: PPUSH
3069: CALL_OW 12
3073: PPUSH
3074: CALL_OW 67
// end ;
3078: GO 3039
3080: POP
3081: POP
// end ;
3082: PPOPN 1
3084: END
// every 2 2$00 do
3085: GO 3087
3087: DISABLE
// begin enable ;
3088: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
3089: LD_INT 1
3091: PPUSH
3092: LD_INT 3
3094: PPUSH
3095: CALL_OW 12
3099: PPUSH
3100: LD_INT 1
3102: PPUSH
3103: CALL_OW 57
// end ;
3107: END
