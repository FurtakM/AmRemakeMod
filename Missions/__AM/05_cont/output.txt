// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 72 0 0
// InitRestrictions ;
  12: CALL 176 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 26
// DebugMode ;
  22: CALL 257 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  26: LD_INT 12
  28: PPUSH
  29: LD_INT 2
  31: PPUSH
  32: CALL 505 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 6 ] [ Difficulty ] ) ;
  36: LD_INT 11
  38: PPUSH
  39: LD_INT 10
  41: PUSH
  42: LD_INT 8
  44: PUSH
  45: LD_INT 6
  47: PUSH
  48: EMPTY
  49: LIST
  50: LIST
  51: LIST
  52: PUSH
  53: LD_OWVAR 67
  57: ARRAY
  58: PPUSH
  59: CALL 505 0 2
// PrepareAmericans ;
  63: CALL 1040 0 0
// Action ;
  67: CALL 1938 0 0
// end ;
  71: END
// export debug ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed , apeman_army , radar_researched , radar_builded ; export apeman_counter , arab_spotted , end_mission ; function Init ; begin
  72: LD_INT 0
  74: PPUSH
// debug := true ;
  75: LD_ADDR_EXP 1
  79: PUSH
  80: LD_INT 1
  82: ST_TO_ADDR
// deltaBuilded := false ;
  83: LD_ADDR_EXP 2
  87: PUSH
  88: LD_INT 0
  90: ST_TO_ADDR
// denisArrives := false ;
  91: LD_ADDR_EXP 3
  95: PUSH
  96: LD_INT 0
  98: ST_TO_ADDR
// radar_allowed := false ;
  99: LD_ADDR_EXP 5
 103: PUSH
 104: LD_INT 0
 106: ST_TO_ADDR
// first_apeman_tamed := false ;
 107: LD_ADDR_EXP 6
 111: PUSH
 112: LD_INT 0
 114: ST_TO_ADDR
// arab_spotted := false ;
 115: LD_ADDR_EXP 11
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// end_mission := false ;
 123: LD_ADDR_EXP 12
 127: PUSH
 128: LD_INT 0
 130: ST_TO_ADDR
// apeman_army := false ;
 131: LD_ADDR_EXP 7
 135: PUSH
 136: LD_INT 0
 138: ST_TO_ADDR
// radar_researched := false ;
 139: LD_ADDR_EXP 8
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// radar_builded := false ;
 147: LD_ADDR_EXP 9
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// apeman_counter := 0 ;
 155: LD_ADDR_EXP 10
 159: PUSH
 160: LD_INT 0
 162: ST_TO_ADDR
// Delta := 0 ;
 163: LD_ADDR_EXP 4
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// end ;
 171: LD_VAR 0 1
 175: RET
// function InitRestrictions ; begin
 176: LD_INT 0
 178: PPUSH
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
 179: LD_INT 7
 181: PPUSH
 182: LD_INT 1
 184: PPUSH
 185: LD_INT 1
 187: PPUSH
 188: CALL_OW 324
// SetRestrict ( b_lab_full , 1 , state_enabled ) ;
 192: LD_INT 8
 194: PPUSH
 195: LD_INT 1
 197: PPUSH
 198: LD_INT 1
 200: PPUSH
 201: CALL_OW 324
// SetRestrict ( b_lab_weapon , 1 , state_enabled ) ;
 205: LD_INT 10
 207: PPUSH
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 1
 213: PPUSH
 214: CALL_OW 324
// SetTech ( tech_gatling , 1 , LoadVariable ( GatlingInGamma , 1 ) ) ;
 218: LD_INT 69
 220: PPUSH
 221: LD_INT 1
 223: PPUSH
 224: LD_STRING GatlingInGamma
 226: PPUSH
 227: LD_INT 1
 229: PPUSH
 230: CALL_OW 30
 234: PPUSH
 235: CALL_OW 322
// SetTech ( tech_weap1 , 1 , state_enabled ) ;
 239: LD_INT 51
 241: PPUSH
 242: LD_INT 1
 244: PPUSH
 245: LD_INT 1
 247: PPUSH
 248: CALL_OW 322
// end ;
 252: LD_VAR 0 1
 256: RET
// function DebugMode ; begin
 257: LD_INT 0
 259: PPUSH
// FogOff ( 1 ) ;
 260: LD_INT 1
 262: PPUSH
 263: CALL_OW 344
// Difficulty := 2 ;
 267: LD_ADDR_OWVAR 67
 271: PUSH
 272: LD_INT 2
 274: ST_TO_ADDR
// end ; end_of_file
 275: LD_VAR 0 1
 279: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 280: LD_INT 0
 282: PPUSH
 283: PPUSH
// if exist_mode then
 284: LD_VAR 0 2
 288: IFFALSE 307
// unit := CreateCharacter ( ident ) else
 290: LD_ADDR_VAR 0 4
 294: PUSH
 295: LD_VAR 0 1
 299: PPUSH
 300: CALL_OW 34
 304: ST_TO_ADDR
 305: GO 322
// unit := NewCharacter ( ident ) ;
 307: LD_ADDR_VAR 0 4
 311: PUSH
 312: LD_VAR 0 1
 316: PPUSH
 317: CALL_OW 25
 321: ST_TO_ADDR
// result := unit ;
 322: LD_ADDR_VAR 0 3
 326: PUSH
 327: LD_VAR 0 4
 331: ST_TO_ADDR
// end ;
 332: LD_VAR 0 3
 336: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 337: LD_INT 0
 339: PPUSH
// uc_side := side ;
 340: LD_ADDR_OWVAR 20
 344: PUSH
 345: LD_VAR 0 1
 349: ST_TO_ADDR
// uc_nation := nation ;
 350: LD_ADDR_OWVAR 21
 354: PUSH
 355: LD_VAR 0 2
 359: ST_TO_ADDR
// vc_chassis := chassis ;
 360: LD_ADDR_OWVAR 37
 364: PUSH
 365: LD_VAR 0 3
 369: ST_TO_ADDR
// vc_engine := engine ;
 370: LD_ADDR_OWVAR 39
 374: PUSH
 375: LD_VAR 0 4
 379: ST_TO_ADDR
// vc_control := control ;
 380: LD_ADDR_OWVAR 38
 384: PUSH
 385: LD_VAR 0 5
 389: ST_TO_ADDR
// vc_weapon := weapon ;
 390: LD_ADDR_OWVAR 40
 394: PUSH
 395: LD_VAR 0 6
 399: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 400: LD_ADDR_OWVAR 41
 404: PUSH
 405: LD_VAR 0 7
 409: ST_TO_ADDR
// result := CreateVehicle ;
 410: LD_ADDR_VAR 0 8
 414: PUSH
 415: CALL_OW 45
 419: ST_TO_ADDR
// end ;
 420: LD_VAR 0 8
 424: RET
// export function SayX ( units , ident ) ; var i ; begin
 425: LD_INT 0
 427: PPUSH
 428: PPUSH
// result := false ;
 429: LD_ADDR_VAR 0 3
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// if not units then
 437: LD_VAR 0 1
 441: NOT
 442: IFFALSE 446
// exit ;
 444: GO 500
// for i in units do
 446: LD_ADDR_VAR 0 4
 450: PUSH
 451: LD_VAR 0 1
 455: PUSH
 456: FOR_IN
 457: IFFALSE 498
// if IsOk ( i ) then
 459: LD_VAR 0 4
 463: PPUSH
 464: CALL_OW 302
 468: IFFALSE 496
// begin Say ( i , ident ) ;
 470: LD_VAR 0 4
 474: PPUSH
 475: LD_VAR 0 2
 479: PPUSH
 480: CALL_OW 88
// result := i ;
 484: LD_ADDR_VAR 0 3
 488: PUSH
 489: LD_VAR 0 4
 493: ST_TO_ADDR
// break ;
 494: GO 498
// end ;
 496: GO 456
 498: POP
 499: POP
// end ;
 500: LD_VAR 0 3
 504: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 505: LD_INT 0
 507: PPUSH
 508: PPUSH
// InitUc ;
 509: CALL_OW 18
// InitHc ;
 513: CALL_OW 19
// uc_side := 0 ;
 517: LD_ADDR_OWVAR 20
 521: PUSH
 522: LD_INT 0
 524: ST_TO_ADDR
// uc_nation := 0 ;
 525: LD_ADDR_OWVAR 21
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// for i = 1 to amount do
 533: LD_ADDR_VAR 0 4
 537: PUSH
 538: DOUBLE
 539: LD_INT 1
 541: DEC
 542: ST_TO_ADDR
 543: LD_VAR 0 2
 547: PUSH
 548: FOR_TO
 549: IFFALSE 583
// begin PrepareHuman ( false , class_apeman , 1 ) ;
 551: LD_INT 0
 553: PPUSH
 554: LD_INT 12
 556: PPUSH
 557: LD_INT 1
 559: PPUSH
 560: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 564: CALL_OW 44
 568: PPUSH
 569: LD_VAR 0 1
 573: PPUSH
 574: LD_INT 0
 576: PPUSH
 577: CALL_OW 49
// end ;
 581: GO 548
 583: POP
 584: POP
// end ;
 585: LD_VAR 0 3
 589: RET
// export function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
 590: LD_INT 0
 592: PPUSH
 593: PPUSH
 594: PPUSH
// if not unit then
 595: LD_VAR 0 1
 599: NOT
 600: IFFALSE 604
// exit ;
 602: GO 1035
// if IsInUnit ( unit ) then
 604: LD_VAR 0 1
 608: PPUSH
 609: CALL_OW 310
 613: IFFALSE 630
// unit := IsDrivenBy ( unit ) ;
 615: LD_ADDR_VAR 0 1
 619: PUSH
 620: LD_VAR 0 1
 624: PPUSH
 625: CALL_OW 311
 629: ST_TO_ADDR
// targets_list := [ ] ;
 630: LD_ADDR_VAR 0 5
 634: PUSH
 635: EMPTY
 636: ST_TO_ADDR
// target := UnitFilter ( enemy_list , [ [ f_lives , 250 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 637: LD_ADDR_VAR 0 4
 641: PUSH
 642: LD_VAR 0 2
 646: PPUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 250
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: PUSH
 657: LD_INT 3
 659: PUSH
 660: LD_INT 34
 662: PUSH
 663: LD_INT 12
 665: PUSH
 666: EMPTY
 667: LIST
 668: LIST
 669: PUSH
 670: EMPTY
 671: LIST
 672: LIST
 673: PUSH
 674: LD_INT 21
 676: PUSH
 677: LD_INT 2
 679: PUSH
 680: EMPTY
 681: LIST
 682: LIST
 683: PUSH
 684: LD_INT 58
 686: PUSH
 687: EMPTY
 688: LIST
 689: PUSH
 690: EMPTY
 691: LIST
 692: LIST
 693: LIST
 694: LIST
 695: PPUSH
 696: CALL_OW 72
 700: ST_TO_ADDR
// if GetDistUnits ( NearestUnitToUnit ( target , unit ) , unit ) < 11 and not IsInUnit ( unit ) then
 701: LD_VAR 0 4
 705: PPUSH
 706: LD_VAR 0 1
 710: PPUSH
 711: CALL_OW 74
 715: PPUSH
 716: LD_VAR 0 1
 720: PPUSH
 721: CALL_OW 296
 725: PUSH
 726: LD_INT 11
 728: LESS
 729: PUSH
 730: LD_VAR 0 1
 734: PPUSH
 735: CALL_OW 310
 739: NOT
 740: AND
 741: IFFALSE 769
// begin ComEnterUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 743: LD_VAR 0 1
 747: PPUSH
 748: LD_VAR 0 4
 752: PPUSH
 753: LD_VAR 0 1
 757: PPUSH
 758: CALL_OW 74
 762: PPUSH
 763: CALL_OW 120
// exit ;
 767: GO 1035
// end ; targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
 769: LD_ADDR_VAR 0 5
 773: PUSH
 774: LD_VAR 0 2
 778: PPUSH
 779: LD_INT 21
 781: PUSH
 782: LD_INT 1
 784: PUSH
 785: EMPTY
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 3
 791: PUSH
 792: LD_INT 54
 794: PUSH
 795: EMPTY
 796: LIST
 797: PUSH
 798: EMPTY
 799: LIST
 800: LIST
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: PPUSH
 806: CALL_OW 72
 810: PUSH
 811: LD_VAR 0 2
 815: PPUSH
 816: LD_INT 21
 818: PUSH
 819: LD_INT 2
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: PPUSH
 826: CALL_OW 72
 830: PUSH
 831: LD_VAR 0 2
 835: PPUSH
 836: LD_INT 21
 838: PUSH
 839: LD_INT 3
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 58
 851: PUSH
 852: EMPTY
 853: LIST
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL_OW 72
 867: PUSH
 868: LD_VAR 0 2
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: ST_TO_ADDR
// for target in targets_list do
 879: LD_ADDR_VAR 0 4
 883: PUSH
 884: LD_VAR 0 5
 888: PUSH
 889: FOR_IN
 890: IFFALSE 1033
// begin if target then
 892: LD_VAR 0 4
 896: IFFALSE 1031
// if GetTag ( unit ) = 11 and ( GetType ( NearestUnitToUnit ( target , unit ) ) = unit_building or GetWeapon ( NearestUnitToUnit ( target , unit ) ) = us_cargo_bay ) then
 898: LD_VAR 0 1
 902: PPUSH
 903: CALL_OW 110
 907: PUSH
 908: LD_INT 11
 910: EQUAL
 911: PUSH
 912: LD_VAR 0 4
 916: PPUSH
 917: LD_VAR 0 1
 921: PPUSH
 922: CALL_OW 74
 926: PPUSH
 927: CALL_OW 247
 931: PUSH
 932: LD_INT 3
 934: EQUAL
 935: PUSH
 936: LD_VAR 0 4
 940: PPUSH
 941: LD_VAR 0 1
 945: PPUSH
 946: CALL_OW 74
 950: PPUSH
 951: CALL_OW 264
 955: PUSH
 956: LD_INT 12
 958: EQUAL
 959: OR
 960: AND
 961: IFFALSE 1007
// begin ComPlaceDelayedCharge ( unit , 0 , 0 , NearestUnitToUnit ( target , unit ) ) ;
 963: LD_VAR 0 1
 967: PPUSH
 968: LD_INT 0
 970: PPUSH
 971: LD_INT 0
 973: PPUSH
 974: LD_VAR 0 4
 978: PPUSH
 979: LD_VAR 0 1
 983: PPUSH
 984: CALL_OW 74
 988: PPUSH
 989: CALL_OW 132
// AddComWait ( unit , 0 0$02 ) ;
 993: LD_VAR 0 1
 997: PPUSH
 998: LD_INT 70
1000: PPUSH
1001: CALL_OW 202
// end else
1005: GO 1031
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
1007: LD_VAR 0 1
1011: PPUSH
1012: LD_VAR 0 4
1016: PPUSH
1017: LD_VAR 0 1
1021: PPUSH
1022: CALL_OW 74
1026: PPUSH
1027: CALL_OW 115
// end ;
1031: GO 889
1033: POP
1034: POP
// end ; end_of_file
1035: LD_VAR 0 3
1039: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
1040: LD_INT 0
1042: PPUSH
1043: PPUSH
1044: PPUSH
1045: PPUSH
1046: PPUSH
// uc_nation := 1 ;
1047: LD_ADDR_OWVAR 21
1051: PUSH
1052: LD_INT 1
1054: ST_TO_ADDR
// uc_side := 4 ;
1055: LD_ADDR_OWVAR 20
1059: PUSH
1060: LD_INT 4
1062: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
1063: LD_ADDR_EXP 16
1067: PUSH
1068: LD_STRING Denis
1070: PPUSH
1071: LD_INT 0
1073: PPUSH
1074: CALL 280 0 2
1078: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
1079: LD_ADDR_EXP 15
1083: PUSH
1084: LD_STRING Harisson
1086: PPUSH
1087: LD_INT 0
1089: PPUSH
1090: CALL 280 0 2
1094: ST_TO_ADDR
// uc_side := 1 ;
1095: LD_ADDR_OWVAR 20
1099: PUSH
1100: LD_INT 1
1102: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1103: LD_ADDR_EXP 13
1107: PUSH
1108: LD_STRING JMM
1110: PPUSH
1111: LD_EXP 1
1115: NOT
1116: PPUSH
1117: CALL 280 0 2
1121: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
1122: LD_ADDR_EXP 14
1126: PUSH
1127: LD_STRING Gladstone
1129: PPUSH
1130: LD_INT 0
1132: PPUSH
1133: CALL 280 0 2
1137: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
1138: LD_STRING BrownInDelta
1140: PPUSH
1141: LD_EXP 1
1145: PPUSH
1146: CALL_OW 30
1150: IFFALSE 1187
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1152: LD_ADDR_EXP 17
1156: PUSH
1157: LD_STRING Brown
1159: PPUSH
1160: LD_EXP 1
1164: NOT
1165: PPUSH
1166: CALL 280 0 2
1170: ST_TO_ADDR
// tmp := tmp ^ Brown ;
1171: LD_ADDR_VAR 0 5
1175: PUSH
1176: LD_VAR 0 5
1180: PUSH
1181: LD_EXP 17
1185: ADD
1186: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , 0 ) then
1187: LD_STRING DonaldsonInDelta
1189: PPUSH
1190: LD_INT 0
1192: PPUSH
1193: CALL_OW 30
1197: IFFALSE 1234
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1199: LD_ADDR_EXP 18
1203: PUSH
1204: LD_STRING Donaldson
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: CALL 280 0 2
1217: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
1218: LD_ADDR_VAR 0 5
1222: PUSH
1223: LD_VAR 0 5
1227: PUSH
1228: LD_EXP 18
1232: ADD
1233: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
1234: LD_STRING LisaInDelta
1236: PPUSH
1237: LD_EXP 1
1241: PPUSH
1242: CALL_OW 30
1246: IFFALSE 1283
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1248: LD_ADDR_EXP 19
1252: PUSH
1253: LD_STRING Lisa
1255: PPUSH
1256: LD_EXP 1
1260: NOT
1261: PPUSH
1262: CALL 280 0 2
1266: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
1267: LD_ADDR_VAR 0 5
1271: PUSH
1272: LD_VAR 0 5
1276: PUSH
1277: LD_EXP 19
1281: ADD
1282: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
1283: LD_STRING FrankInDelta
1285: PPUSH
1286: LD_EXP 1
1290: PPUSH
1291: CALL_OW 30
1295: IFFALSE 1332
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
1297: LD_ADDR_EXP 20
1301: PUSH
1302: LD_STRING Frank
1304: PPUSH
1305: LD_EXP 1
1309: NOT
1310: PPUSH
1311: CALL 280 0 2
1315: ST_TO_ADDR
// tmp := tmp ^ Frank ;
1316: LD_ADDR_VAR 0 5
1320: PUSH
1321: LD_VAR 0 5
1325: PUSH
1326: LD_EXP 20
1330: ADD
1331: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
1332: LD_STRING BobbyInDelta
1334: PPUSH
1335: LD_INT 0
1337: PPUSH
1338: CALL_OW 30
1342: IFFALSE 1379
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1344: LD_ADDR_EXP 21
1348: PUSH
1349: LD_STRING Bobby
1351: PPUSH
1352: LD_EXP 1
1356: NOT
1357: PPUSH
1358: CALL 280 0 2
1362: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
1363: LD_ADDR_VAR 0 5
1367: PUSH
1368: LD_VAR 0 5
1372: PUSH
1373: LD_EXP 21
1377: ADD
1378: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
1379: LD_STRING CyrusInDelta
1381: PPUSH
1382: LD_INT 0
1384: PPUSH
1385: CALL_OW 30
1389: IFFALSE 1426
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1391: LD_ADDR_EXP 22
1395: PUSH
1396: LD_STRING Cyrus
1398: PPUSH
1399: LD_EXP 1
1403: NOT
1404: PPUSH
1405: CALL 280 0 2
1409: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
1410: LD_ADDR_VAR 0 5
1414: PUSH
1415: LD_VAR 0 5
1419: PUSH
1420: LD_EXP 22
1424: ADD
1425: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
1426: LD_ADDR_EXP 23
1430: PUSH
1431: LD_STRING othersDelta
1433: PPUSH
1434: CALL_OW 31
1438: ST_TO_ADDR
// if not others and debug then
1439: LD_EXP 23
1443: NOT
1444: PUSH
1445: LD_EXP 1
1449: AND
1450: IFFALSE 1515
// begin InitHc ;
1452: CALL_OW 19
// for i = 1 to 2 do
1456: LD_ADDR_VAR 0 2
1460: PUSH
1461: DOUBLE
1462: LD_INT 1
1464: DEC
1465: ST_TO_ADDR
1466: LD_INT 2
1468: PUSH
1469: FOR_TO
1470: IFFALSE 1513
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
1472: LD_INT 0
1474: PPUSH
1475: LD_VAR 0 2
1479: PUSH
1480: LD_INT 4
1482: MOD
1483: PUSH
1484: LD_INT 1
1486: PLUS
1487: PPUSH
1488: LD_INT 3
1490: PPUSH
1491: CALL_OW 380
// others := others ^ CreateHuman ;
1495: LD_ADDR_EXP 23
1499: PUSH
1500: LD_EXP 23
1504: PUSH
1505: CALL_OW 44
1509: ADD
1510: ST_TO_ADDR
// end ;
1511: GO 1469
1513: POP
1514: POP
// end ; if others then
1515: LD_EXP 23
1519: IFFALSE 1537
// tmp := tmp ^ others ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_EXP 23
1535: ADD
1536: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
1537: LD_ADDR_VAR 0 3
1541: PUSH
1542: LD_INT 28
1544: PUSH
1545: LD_INT 49
1547: PUSH
1548: EMPTY
1549: LIST
1550: LIST
1551: PUSH
1552: LD_INT 33
1554: PUSH
1555: LD_INT 54
1557: PUSH
1558: EMPTY
1559: LIST
1560: LIST
1561: PUSH
1562: LD_INT 38
1564: PUSH
1565: LD_INT 56
1567: PUSH
1568: EMPTY
1569: LIST
1570: LIST
1571: PUSH
1572: EMPTY
1573: LIST
1574: LIST
1575: LIST
1576: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1577: LD_ADDR_VAR 0 4
1581: PUSH
1582: LD_INT 1
1584: PPUSH
1585: LD_INT 1
1587: PPUSH
1588: LD_INT 2
1590: PPUSH
1591: LD_INT 2
1593: PPUSH
1594: LD_INT 1
1596: PPUSH
1597: LD_INT 12
1599: PPUSH
1600: LD_INT 80
1602: PPUSH
1603: CALL 337 0 7
1607: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1608: LD_VAR 0 4
1612: PPUSH
1613: LD_INT 1
1615: PPUSH
1616: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1620: LD_VAR 0 4
1624: PPUSH
1625: LD_VAR 0 3
1629: PUSH
1630: LD_INT 1
1632: ARRAY
1633: PUSH
1634: LD_INT 1
1636: ARRAY
1637: PPUSH
1638: LD_VAR 0 3
1642: PUSH
1643: LD_INT 1
1645: ARRAY
1646: PUSH
1647: LD_INT 2
1649: ARRAY
1650: PPUSH
1651: LD_INT 0
1653: PPUSH
1654: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1658: LD_VAR 0 4
1662: PPUSH
1663: LD_INT 1
1665: PPUSH
1666: LD_INT 100
1668: PPUSH
1669: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1673: LD_EXP 23
1677: PUSH
1678: LD_INT 1
1680: ARRAY
1681: PPUSH
1682: LD_VAR 0 4
1686: PPUSH
1687: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1691: LD_ADDR_VAR 0 4
1695: PUSH
1696: LD_INT 1
1698: PPUSH
1699: LD_INT 1
1701: PPUSH
1702: LD_INT 1
1704: PPUSH
1705: LD_INT 2
1707: PPUSH
1708: LD_INT 1
1710: PPUSH
1711: LD_INT 2
1713: PPUSH
1714: LD_INT 80
1716: PPUSH
1717: CALL 337 0 7
1721: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1722: LD_VAR 0 4
1726: PPUSH
1727: LD_INT 1
1729: PPUSH
1730: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1734: LD_VAR 0 4
1738: PPUSH
1739: LD_VAR 0 3
1743: PUSH
1744: LD_INT 2
1746: ARRAY
1747: PUSH
1748: LD_INT 1
1750: ARRAY
1751: PPUSH
1752: LD_VAR 0 3
1756: PUSH
1757: LD_INT 2
1759: ARRAY
1760: PUSH
1761: LD_INT 2
1763: ARRAY
1764: PPUSH
1765: LD_INT 0
1767: PPUSH
1768: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1772: LD_EXP 14
1776: PPUSH
1777: LD_VAR 0 4
1781: PPUSH
1782: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
1786: LD_ADDR_VAR 0 4
1790: PUSH
1791: LD_INT 1
1793: PPUSH
1794: LD_INT 1
1796: PPUSH
1797: LD_INT 1
1799: PPUSH
1800: LD_INT 2
1802: PPUSH
1803: LD_INT 1
1805: PPUSH
1806: LD_INT 3
1808: PPUSH
1809: LD_INT 80
1811: PPUSH
1812: CALL 337 0 7
1816: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1817: LD_VAR 0 4
1821: PPUSH
1822: LD_INT 1
1824: PPUSH
1825: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
1829: LD_VAR 0 4
1833: PPUSH
1834: LD_VAR 0 3
1838: PUSH
1839: LD_INT 3
1841: ARRAY
1842: PUSH
1843: LD_INT 1
1845: ARRAY
1846: PPUSH
1847: LD_VAR 0 3
1851: PUSH
1852: LD_INT 3
1854: ARRAY
1855: PUSH
1856: LD_INT 2
1858: ARRAY
1859: PPUSH
1860: LD_INT 0
1862: PPUSH
1863: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1867: LD_EXP 13
1871: PPUSH
1872: LD_VAR 0 4
1876: PPUSH
1877: CALL_OW 52
// if others > 1 then
1881: LD_EXP 23
1885: PUSH
1886: LD_INT 1
1888: GREATER
1889: IFFALSE 1933
// for i in tmp diff others [ 1 ] do
1891: LD_ADDR_VAR 0 2
1895: PUSH
1896: LD_VAR 0 5
1900: PUSH
1901: LD_EXP 23
1905: PUSH
1906: LD_INT 1
1908: ARRAY
1909: DIFF
1910: PUSH
1911: FOR_IN
1912: IFFALSE 1931
// PlaceUnitArea ( i , startArea , false ) ;
1914: LD_VAR 0 2
1918: PPUSH
1919: LD_INT 5
1921: PPUSH
1922: LD_INT 0
1924: PPUSH
1925: CALL_OW 49
1929: GO 1911
1931: POP
1932: POP
// end ; end_of_file
1933: LD_VAR 0 1
1937: RET
// export function Action ; begin
1938: LD_INT 0
1940: PPUSH
// InGameOn ;
1941: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
1945: LD_INT 28
1947: PPUSH
1948: LD_INT 51
1950: PPUSH
1951: CALL_OW 86
// Wait ( 3 ) ;
1955: LD_INT 3
1957: PPUSH
1958: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
1962: LD_EXP 13
1966: PPUSH
1967: LD_STRING D1d-JMM-1a
1969: PPUSH
1970: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
1974: LD_EXP 15
1978: PPUSH
1979: LD_STRING D1d-Har-1
1981: PPUSH
1982: CALL_OW 94
// InGameOff ;
1986: CALL_OW 9
// SaveForQuickRestart ;
1990: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
1994: LD_STRING M1
1996: PPUSH
1997: CALL_OW 337
// Wait ( 0 0$2 ) ;
2001: LD_INT 70
2003: PPUSH
2004: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
2008: LD_EXP 13
2012: PPUSH
2013: LD_STRING D2-JMM-1
2015: PPUSH
2016: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
2020: LD_EXP 14
2024: PPUSH
2025: LD_STRING D2-Glad-1
2027: PPUSH
2028: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2032: LD_EXP 13
2036: PPUSH
2037: LD_STRING D2-JMM-2
2039: PPUSH
2040: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
2044: LD_EXP 14
2048: PPUSH
2049: LD_STRING D2-Glad-2
2051: PPUSH
2052: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2056: LD_EXP 13
2060: PPUSH
2061: LD_STRING D2-JMM-3
2063: PPUSH
2064: CALL_OW 88
// SetWeather ( 2 , 100 , 150 ) ;
2068: LD_INT 2
2070: PPUSH
2071: LD_INT 100
2073: PPUSH
2074: LD_INT 150
2076: PPUSH
2077: CALL_OW 550
// Wait ( rand ( 4 4$00 , 5 5$00 ) ) ;
2081: LD_INT 8400
2083: PPUSH
2084: LD_INT 10500
2086: PPUSH
2087: CALL_OW 12
2091: PPUSH
2092: CALL_OW 67
// SetWeather ( 0 , 100 , 150 ) ;
2096: LD_INT 0
2098: PPUSH
2099: LD_INT 100
2101: PPUSH
2102: LD_INT 150
2104: PPUSH
2105: CALL_OW 550
// end ;
2109: LD_VAR 0 1
2113: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
2114: LD_INT 22
2116: PUSH
2117: LD_INT 1
2119: PUSH
2120: EMPTY
2121: LIST
2122: LIST
2123: PUSH
2124: LD_INT 3
2126: PUSH
2127: LD_INT 57
2129: PUSH
2130: EMPTY
2131: LIST
2132: PUSH
2133: EMPTY
2134: LIST
2135: LIST
2136: PUSH
2137: LD_INT 30
2139: PUSH
2140: LD_INT 0
2142: PUSH
2143: EMPTY
2144: LIST
2145: LIST
2146: PUSH
2147: EMPTY
2148: LIST
2149: LIST
2150: LIST
2151: PUSH
2152: EMPTY
2153: LIST
2154: PPUSH
2155: CALL_OW 69
2159: PUSH
2160: LD_EXP 2
2164: NOT
2165: AND
2166: IFFALSE 2179
2168: GO 2170
2170: DISABLE
// begin deltaBuilded := true ;
2171: LD_ADDR_EXP 2
2175: PUSH
2176: LD_INT 1
2178: ST_TO_ADDR
// end ;
2179: END
// every 0 0$01 trigger not Delta and deltaBuilded and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) do
2180: LD_EXP 4
2184: NOT
2185: PUSH
2186: LD_EXP 2
2190: AND
2191: PUSH
2192: LD_INT 22
2194: PUSH
2195: LD_INT 1
2197: PUSH
2198: EMPTY
2199: LIST
2200: LIST
2201: PUSH
2202: LD_INT 3
2204: PUSH
2205: LD_INT 57
2207: PUSH
2208: EMPTY
2209: LIST
2210: PUSH
2211: EMPTY
2212: LIST
2213: LIST
2214: PUSH
2215: LD_INT 30
2217: PUSH
2218: LD_INT 0
2220: PUSH
2221: EMPTY
2222: LIST
2223: LIST
2224: PUSH
2225: EMPTY
2226: LIST
2227: LIST
2228: LIST
2229: PUSH
2230: EMPTY
2231: LIST
2232: PPUSH
2233: CALL_OW 69
2237: AND
2238: IFFALSE 2311
2240: GO 2242
2242: DISABLE
// begin enable ;
2243: ENABLE
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
2244: LD_ADDR_EXP 4
2248: PUSH
2249: LD_INT 22
2251: PUSH
2252: LD_INT 1
2254: PUSH
2255: EMPTY
2256: LIST
2257: LIST
2258: PUSH
2259: LD_INT 3
2261: PUSH
2262: LD_INT 57
2264: PUSH
2265: EMPTY
2266: LIST
2267: PUSH
2268: EMPTY
2269: LIST
2270: LIST
2271: PUSH
2272: LD_INT 30
2274: PUSH
2275: LD_INT 0
2277: PUSH
2278: EMPTY
2279: LIST
2280: LIST
2281: PUSH
2282: EMPTY
2283: LIST
2284: LIST
2285: LIST
2286: PUSH
2287: EMPTY
2288: LIST
2289: PPUSH
2290: CALL_OW 69
2294: PUSH
2295: LD_INT 1
2297: ARRAY
2298: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
2299: LD_EXP 4
2303: PPUSH
2304: LD_STRING Delta
2306: PPUSH
2307: CALL_OW 500
// end ;
2311: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched do
2312: LD_INT 1
2314: PPUSH
2315: LD_INT 1
2317: PPUSH
2318: CALL_OW 321
2322: PUSH
2323: LD_INT 2
2325: EQUAL
2326: IFFALSE 2387
2328: GO 2330
2330: DISABLE
// begin DialogueOn ;
2331: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
2335: LD_EXP 14
2339: PPUSH
2340: LD_STRING D3-Glad-1
2342: PPUSH
2343: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2347: LD_EXP 13
2351: PPUSH
2352: LD_STRING D3-JMM-1
2354: PPUSH
2355: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
2359: LD_EXP 14
2363: PPUSH
2364: LD_STRING D3-Glad-2
2366: PPUSH
2367: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
2371: LD_EXP 13
2375: PPUSH
2376: LD_STRING D3-JMM-2
2378: PPUSH
2379: CALL_OW 88
// DialogueOff ;
2383: CALL_OW 7
// end ;
2387: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
2388: LD_INT 2
2390: PPUSH
2391: LD_INT 1
2393: PPUSH
2394: CALL_OW 321
2398: PUSH
2399: LD_INT 2
2401: EQUAL
2402: IFFALSE 2579
2404: GO 2406
2406: DISABLE
2407: LD_INT 0
2409: PPUSH
// begin DialogueOn ;
2410: CALL_OW 6
// if Frank then
2414: LD_EXP 20
2418: IFFALSE 2432
// Say ( Frank , D8a-Frank-1 ) ;
2420: LD_EXP 20
2424: PPUSH
2425: LD_STRING D8a-Frank-1
2427: PPUSH
2428: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
2432: LD_ADDR_VAR 0 1
2436: PUSH
2437: LD_EXP 23
2441: PPUSH
2442: LD_INT 26
2444: PUSH
2445: LD_INT 1
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: PPUSH
2452: CALL_OW 72
2456: PPUSH
2457: LD_STRING D8a-Sol1-1
2459: PPUSH
2460: CALL 425 0 2
2464: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2465: LD_EXP 16
2469: PUSH
2470: LD_EXP 16
2474: PPUSH
2475: CALL_OW 255
2479: PUSH
2480: LD_INT 1
2482: EQUAL
2483: AND
2484: IFFALSE 2498
// Say ( Denis , D8a-Den-1 ) ;
2486: LD_EXP 16
2490: PPUSH
2491: LD_STRING D8a-Den-1
2493: PPUSH
2494: CALL_OW 88
// if sol or Denis or Frank then
2498: LD_VAR 0 1
2502: PUSH
2503: LD_EXP 16
2507: OR
2508: PUSH
2509: LD_EXP 20
2513: OR
2514: IFFALSE 2575
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2516: LD_EXP 23
2520: PPUSH
2521: LD_INT 25
2523: PUSH
2524: LD_INT 4
2526: PUSH
2527: EMPTY
2528: LIST
2529: LIST
2530: PUSH
2531: LD_INT 26
2533: PUSH
2534: LD_INT 1
2536: PUSH
2537: EMPTY
2538: LIST
2539: LIST
2540: PUSH
2541: EMPTY
2542: LIST
2543: LIST
2544: PPUSH
2545: CALL_OW 72
2549: PUSH
2550: LD_VAR 0 1
2554: DIFF
2555: PPUSH
2556: LD_STRING D8a-Sci1-1
2558: PPUSH
2559: CALL 425 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2563: LD_EXP 13
2567: PPUSH
2568: LD_STRING D8a-JMM-1
2570: PPUSH
2571: CALL_OW 88
// end ; DialogueOff ;
2575: CALL_OW 7
// end ;
2579: PPOPN 1
2581: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2582: LD_INT 22
2584: PUSH
2585: LD_INT 1
2587: PUSH
2588: EMPTY
2589: LIST
2590: LIST
2591: PUSH
2592: LD_INT 25
2594: PUSH
2595: LD_INT 16
2597: PUSH
2598: EMPTY
2599: LIST
2600: LIST
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: PPUSH
2606: CALL_OW 69
2610: IFFALSE 2669
2612: GO 2614
2614: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2615: LD_STRING M1a
2617: PPUSH
2618: CALL_OW 337
// case Query ( Q2 ) of 1 :
2622: LD_STRING Q2
2624: PPUSH
2625: CALL_OW 97
2629: PUSH
2630: LD_INT 1
2632: DOUBLE
2633: EQUAL
2634: IFTRUE 2638
2636: GO 2649
2638: POP
// end_mission := true ; 2 :
2639: LD_ADDR_EXP 12
2643: PUSH
2644: LD_INT 1
2646: ST_TO_ADDR
2647: GO 2669
2649: LD_INT 2
2651: DOUBLE
2652: EQUAL
2653: IFTRUE 2657
2655: GO 2668
2657: POP
// end_the_mission_allowed := true ; end ;
2658: LD_ADDR_OWVAR 57
2662: PUSH
2663: LD_INT 1
2665: ST_TO_ADDR
2666: GO 2669
2668: POP
// end ;
2669: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_lab ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_workshop ] ] ) and Delta do
2670: LD_INT 22
2672: PUSH
2673: LD_INT 1
2675: PUSH
2676: EMPTY
2677: LIST
2678: LIST
2679: PUSH
2680: LD_INT 30
2682: PUSH
2683: LD_INT 6
2685: PUSH
2686: EMPTY
2687: LIST
2688: LIST
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: PPUSH
2694: CALL_OW 69
2698: PUSH
2699: LD_INT 22
2701: PUSH
2702: LD_INT 1
2704: PUSH
2705: EMPTY
2706: LIST
2707: LIST
2708: PUSH
2709: LD_INT 30
2711: PUSH
2712: LD_INT 2
2714: PUSH
2715: EMPTY
2716: LIST
2717: LIST
2718: PUSH
2719: EMPTY
2720: LIST
2721: LIST
2722: PPUSH
2723: CALL_OW 69
2727: AND
2728: PUSH
2729: LD_EXP 4
2733: AND
2734: IFFALSE 3144
2736: GO 2738
2738: DISABLE
// begin Wait ( rand ( 0 0$20 , 0 0$40 ) ) ;
2739: LD_INT 700
2741: PPUSH
2742: LD_INT 1400
2744: PPUSH
2745: CALL_OW 12
2749: PPUSH
2750: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
2754: LD_EXP 16
2758: PPUSH
2759: LD_INT 6
2761: PUSH
2762: LD_INT 9
2764: PUSH
2765: LD_INT 10
2767: PUSH
2768: EMPTY
2769: LIST
2770: LIST
2771: LIST
2772: PUSH
2773: LD_OWVAR 67
2777: ARRAY
2778: PPUSH
2779: LD_INT 0
2781: PPUSH
2782: CALL_OW 49
// ComHold ( Denis ) ;
2786: LD_EXP 16
2790: PPUSH
2791: CALL_OW 140
// InGameOn ;
2795: CALL_OW 8
// DialogueOn ;
2799: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
2803: LD_EXP 13
2807: PPUSH
2808: CALL_OW 87
// Say ( Denis , DD-Den-1 ) ;
2812: LD_EXP 16
2816: PPUSH
2817: LD_STRING DD-Den-1
2819: PPUSH
2820: CALL_OW 88
// Say ( JMM , DD-JMM-1 ) ;
2824: LD_EXP 13
2828: PPUSH
2829: LD_STRING DD-JMM-1
2831: PPUSH
2832: CALL_OW 88
// Say ( Denis , DD-Den-2 ) ;
2836: LD_EXP 16
2840: PPUSH
2841: LD_STRING DD-Den-2
2843: PPUSH
2844: CALL_OW 88
// Wait ( 3 ) ;
2848: LD_INT 3
2850: PPUSH
2851: CALL_OW 67
// DialogueOff ;
2855: CALL_OW 7
// InGameOff ;
2859: CALL_OW 9
// repeat wait ( 0 0$01 ) ;
2863: LD_INT 35
2865: PPUSH
2866: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
2870: LD_INT 1
2872: PPUSH
2873: LD_EXP 16
2877: PPUSH
2878: CALL_OW 292
2882: PUSH
2883: LD_EXP 16
2887: PPUSH
2888: CALL_OW 301
2892: OR
2893: IFFALSE 2863
// if IsDead ( Denis ) then
2895: LD_EXP 16
2899: PPUSH
2900: CALL_OW 301
2904: IFFALSE 2908
// exit ;
2906: GO 3144
// SetSide ( Denis , 1 ) ;
2908: LD_EXP 16
2912: PPUSH
2913: LD_INT 1
2915: PPUSH
2916: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
2920: LD_EXP 16
2924: PPUSH
2925: LD_STRING DD-Den-2a
2927: PPUSH
2928: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
2932: LD_INT 35
2934: PPUSH
2935: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
2939: LD_EXP 16
2943: PPUSH
2944: CALL_OW 310
2948: PPUSH
2949: CALL_OW 266
2953: PUSH
2954: LD_INT 6
2956: PUSH
2957: LD_INT 7
2959: PUSH
2960: LD_INT 8
2962: PUSH
2963: EMPTY
2964: LIST
2965: LIST
2966: LIST
2967: IN
2968: PUSH
2969: LD_EXP 16
2973: PPUSH
2974: CALL_OW 301
2978: OR
2979: IFFALSE 2932
// if IsDead ( Denis ) then
2981: LD_EXP 16
2985: PPUSH
2986: CALL_OW 301
2990: IFFALSE 2994
// exit ;
2992: GO 3144
// Say ( Denis , DD-Den-2b ) ;
2994: LD_EXP 16
2998: PPUSH
2999: LD_STRING DD-Den-2b
3001: PPUSH
3002: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
3006: LD_EXP 16
3010: PPUSH
3011: LD_INT 4
3013: PPUSH
3014: CALL_OW 123
// Wait ( 0 0$02 ) ;
3018: LD_INT 70
3020: PPUSH
3021: CALL_OW 67
// DialogueOn ;
3025: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
3029: LD_EXP 16
3033: PPUSH
3034: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3038: LD_EXP 13
3042: PPUSH
3043: LD_STRING D4-JMM-1
3045: PPUSH
3046: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
3050: LD_EXP 16
3054: PPUSH
3055: LD_STRING D4-Den-1
3057: PPUSH
3058: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
3062: LD_EXP 13
3066: PPUSH
3067: LD_STRING D4-JMM-2
3069: PPUSH
3070: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
3074: LD_EXP 16
3078: PPUSH
3079: LD_STRING D4-Den-2
3081: PPUSH
3082: CALL_OW 88
// DialogueOff ;
3086: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
3090: LD_STRING M2
3092: PPUSH
3093: CALL_OW 337
// radar_allowed := true ;
3097: LD_ADDR_EXP 5
3101: PUSH
3102: LD_INT 1
3104: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
3105: LD_INT 6
3107: PPUSH
3108: LD_INT 1
3110: PPUSH
3111: LD_INT 1
3113: PPUSH
3114: CALL_OW 322
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
3118: LD_INT 15
3120: PPUSH
3121: LD_INT 1
3123: PPUSH
3124: LD_INT 1
3126: PPUSH
3127: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
3131: LD_INT 20
3133: PPUSH
3134: LD_INT 1
3136: PPUSH
3137: LD_INT 1
3139: PPUSH
3140: CALL_OW 324
// end ;
3144: END
// every 0 0$1 trigger arab_spotted do var sol , sol2 ;
3145: LD_EXP 11
3149: IFFALSE 3772
3151: GO 3153
3153: DISABLE
3154: LD_INT 0
3156: PPUSH
3157: PPUSH
// begin sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D5-Sol1-1 ) ;
3158: LD_ADDR_VAR 0 1
3162: PUSH
3163: LD_EXP 23
3167: PPUSH
3168: LD_INT 26
3170: PUSH
3171: LD_INT 1
3173: PUSH
3174: EMPTY
3175: LIST
3176: LIST
3177: PPUSH
3178: CALL_OW 72
3182: PPUSH
3183: LD_STRING D5-Sol1-1
3185: PPUSH
3186: CALL 425 0 2
3190: ST_TO_ADDR
// if not sol then
3191: LD_VAR 0 1
3195: NOT
3196: IFFALSE 3200
// exit ;
3198: GO 3772
// repeat wait ( 0 0$01 ) ;
3200: LD_INT 35
3202: PPUSH
3203: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) = 0 ;
3207: LD_INT 22
3209: PUSH
3210: LD_INT 2
3212: PUSH
3213: EMPTY
3214: LIST
3215: LIST
3216: PUSH
3217: LD_INT 21
3219: PUSH
3220: LD_INT 2
3222: PUSH
3223: EMPTY
3224: LIST
3225: LIST
3226: PUSH
3227: EMPTY
3228: LIST
3229: LIST
3230: PPUSH
3231: CALL_OW 69
3235: PUSH
3236: LD_INT 0
3238: EQUAL
3239: IFFALSE 3200
// if IsOk ( sol ) then
3241: LD_VAR 0 1
3245: PPUSH
3246: CALL_OW 302
3250: IFFALSE 3270
// begin sol2 := others diff sol ;
3252: LD_ADDR_VAR 0 2
3256: PUSH
3257: LD_EXP 23
3261: PUSH
3262: LD_VAR 0 1
3266: DIFF
3267: ST_TO_ADDR
// end else
3268: GO 3272
// exit ;
3270: GO 3772
// if not Lisa and not sol2 then
3272: LD_EXP 19
3276: NOT
3277: PUSH
3278: LD_VAR 0 2
3282: NOT
3283: AND
3284: IFFALSE 3288
// exit ;
3286: GO 3772
// DialogueOn ;
3288: CALL_OW 6
// if Lisa then
3292: LD_EXP 19
3296: IFFALSE 3312
// Say ( Lisa , D5a-Lisa-1 ) else
3298: LD_EXP 19
3302: PPUSH
3303: LD_STRING D5a-Lisa-1
3305: PPUSH
3306: CALL_OW 88
3310: GO 3387
// if sol2 then
3312: LD_VAR 0 2
3316: IFFALSE 3387
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3318: LD_VAR 0 2
3322: PUSH
3323: LD_INT 1
3325: ARRAY
3326: PPUSH
3327: CALL_OW 258
3331: PUSH
3332: LD_INT 1
3334: DOUBLE
3335: EQUAL
3336: IFTRUE 3340
3338: GO 3359
3340: POP
// Say ( sol2 [ 1 ] , D5-Sol2-1 ) ; sex_female :
3341: LD_VAR 0 2
3345: PUSH
3346: LD_INT 1
3348: ARRAY
3349: PPUSH
3350: LD_STRING D5-Sol2-1
3352: PPUSH
3353: CALL_OW 88
3357: GO 3387
3359: LD_INT 2
3361: DOUBLE
3362: EQUAL
3363: IFTRUE 3367
3365: GO 3386
3367: POP
// Say ( sol2 [ 1 ] , D5-FSol2-1 ) ; end ;
3368: LD_VAR 0 2
3372: PUSH
3373: LD_INT 1
3375: ARRAY
3376: PPUSH
3377: LD_STRING D5-FSol2-1
3379: PPUSH
3380: CALL_OW 88
3384: GO 3387
3386: POP
// Say ( sol , D5-Sol1-2 ) ;
3387: LD_VAR 0 1
3391: PPUSH
3392: LD_STRING D5-Sol1-2
3394: PPUSH
3395: CALL_OW 88
// if Lisa then
3399: LD_EXP 19
3403: IFFALSE 3419
// Say ( Lisa , D5a-Lisa-2 ) else
3405: LD_EXP 19
3409: PPUSH
3410: LD_STRING D5a-Lisa-2
3412: PPUSH
3413: CALL_OW 88
3417: GO 3494
// if sol2 then
3419: LD_VAR 0 2
3423: IFFALSE 3494
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3425: LD_VAR 0 2
3429: PUSH
3430: LD_INT 1
3432: ARRAY
3433: PPUSH
3434: CALL_OW 258
3438: PUSH
3439: LD_INT 1
3441: DOUBLE
3442: EQUAL
3443: IFTRUE 3447
3445: GO 3466
3447: POP
// Say ( sol2 [ 1 ] , D5-Sol2-2 ) ; sex_female :
3448: LD_VAR 0 2
3452: PUSH
3453: LD_INT 1
3455: ARRAY
3456: PPUSH
3457: LD_STRING D5-Sol2-2
3459: PPUSH
3460: CALL_OW 88
3464: GO 3494
3466: LD_INT 2
3468: DOUBLE
3469: EQUAL
3470: IFTRUE 3474
3472: GO 3493
3474: POP
// Say ( sol2 [ 1 ] , D5-FSol2-2 ) ; end ;
3475: LD_VAR 0 2
3479: PUSH
3480: LD_INT 1
3482: ARRAY
3483: PPUSH
3484: LD_STRING D5-FSol2-2
3486: PPUSH
3487: CALL_OW 88
3491: GO 3494
3493: POP
// Say ( sol , D5a-Sol1-3 ) ;
3494: LD_VAR 0 1
3498: PPUSH
3499: LD_STRING D5a-Sol1-3
3501: PPUSH
3502: CALL_OW 88
// if Lisa then
3506: LD_EXP 19
3510: IFFALSE 3524
// Say ( Lisa , D5a-Lisa-3 ) ;
3512: LD_EXP 19
3516: PPUSH
3517: LD_STRING D5a-Lisa-3
3519: PPUSH
3520: CALL_OW 88
// if not sol2 then
3524: LD_VAR 0 2
3528: NOT
3529: IFFALSE 3537
// begin DialogueOff ;
3531: CALL_OW 7
// exit ;
3535: GO 3772
// end ; case GetSex ( sol2 [ 1 ] ) of sex_male :
3537: LD_VAR 0 2
3541: PUSH
3542: LD_INT 1
3544: ARRAY
3545: PPUSH
3546: CALL_OW 258
3550: PUSH
3551: LD_INT 1
3553: DOUBLE
3554: EQUAL
3555: IFTRUE 3559
3557: GO 3578
3559: POP
// Say ( sol2 [ 1 ] , D5-Sol2-3 ) ; sex_female :
3560: LD_VAR 0 2
3564: PUSH
3565: LD_INT 1
3567: ARRAY
3568: PPUSH
3569: LD_STRING D5-Sol2-3
3571: PPUSH
3572: CALL_OW 88
3576: GO 3606
3578: LD_INT 2
3580: DOUBLE
3581: EQUAL
3582: IFTRUE 3586
3584: GO 3605
3586: POP
// Say ( sol2 [ 1 ] , D5-FSol2-3 ) ; end ;
3587: LD_VAR 0 2
3591: PUSH
3592: LD_INT 1
3594: ARRAY
3595: PPUSH
3596: LD_STRING D5-FSol2-3
3598: PPUSH
3599: CALL_OW 88
3603: GO 3606
3605: POP
// Say ( sol , D5-Sol1-4 ) ;
3606: LD_VAR 0 1
3610: PPUSH
3611: LD_STRING D5-Sol1-4
3613: PPUSH
3614: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3618: LD_VAR 0 2
3622: PUSH
3623: LD_INT 1
3625: ARRAY
3626: PPUSH
3627: CALL_OW 258
3631: PUSH
3632: LD_INT 1
3634: DOUBLE
3635: EQUAL
3636: IFTRUE 3640
3638: GO 3659
3640: POP
// Say ( sol2 [ 1 ] , D5-Sol2-4 ) ; sex_female :
3641: LD_VAR 0 2
3645: PUSH
3646: LD_INT 1
3648: ARRAY
3649: PPUSH
3650: LD_STRING D5-Sol2-4
3652: PPUSH
3653: CALL_OW 88
3657: GO 3687
3659: LD_INT 2
3661: DOUBLE
3662: EQUAL
3663: IFTRUE 3667
3665: GO 3686
3667: POP
// Say ( sol2 [ 1 ] , D5-FSol2-4 ) ; end ;
3668: LD_VAR 0 2
3672: PUSH
3673: LD_INT 1
3675: ARRAY
3676: PPUSH
3677: LD_STRING D5-FSol2-4
3679: PPUSH
3680: CALL_OW 88
3684: GO 3687
3686: POP
// Say ( sol , D5-Sol1-5 ) ;
3687: LD_VAR 0 1
3691: PPUSH
3692: LD_STRING D5-Sol1-5
3694: PPUSH
3695: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3699: LD_VAR 0 2
3703: PUSH
3704: LD_INT 1
3706: ARRAY
3707: PPUSH
3708: CALL_OW 258
3712: PUSH
3713: LD_INT 1
3715: DOUBLE
3716: EQUAL
3717: IFTRUE 3721
3719: GO 3740
3721: POP
// Say ( sol2 [ 1 ] , D5-Sol2-5 ) ; sex_female :
3722: LD_VAR 0 2
3726: PUSH
3727: LD_INT 1
3729: ARRAY
3730: PPUSH
3731: LD_STRING D5-Sol2-5
3733: PPUSH
3734: CALL_OW 88
3738: GO 3768
3740: LD_INT 2
3742: DOUBLE
3743: EQUAL
3744: IFTRUE 3748
3746: GO 3767
3748: POP
// Say ( sol2 [ 1 ] , D5-FSol2-5 ) ; end ;
3749: LD_VAR 0 2
3753: PUSH
3754: LD_INT 1
3756: ARRAY
3757: PPUSH
3758: LD_STRING D5-FSol2-5
3760: PPUSH
3761: CALL_OW 88
3765: GO 3768
3767: POP
// DialogueOff ;
3768: CALL_OW 7
// end ;
3772: PPOPN 2
3774: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 5 do
3775: LD_INT 22
3777: PUSH
3778: LD_INT 1
3780: PUSH
3781: EMPTY
3782: LIST
3783: LIST
3784: PUSH
3785: LD_INT 25
3787: PUSH
3788: LD_INT 16
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: PUSH
3795: EMPTY
3796: LIST
3797: LIST
3798: PPUSH
3799: CALL_OW 69
3803: PUSH
3804: LD_INT 5
3806: GREATEREQUAL
3807: IFFALSE 3827
3809: GO 3811
3811: DISABLE
// begin ChangeMissionObjectives ( M1b ) ;
3812: LD_STRING M1b
3814: PPUSH
3815: CALL_OW 337
// apeman_army := true ;
3819: LD_ADDR_EXP 7
3823: PUSH
3824: LD_INT 1
3826: ST_TO_ADDR
// end ;
3827: END
// every 0 0$1 trigger GetTech ( tech_radar , 1 ) = state_researched do
3828: LD_INT 6
3830: PPUSH
3831: LD_INT 1
3833: PPUSH
3834: CALL_OW 321
3838: PUSH
3839: LD_INT 2
3841: EQUAL
3842: IFFALSE 3862
3844: GO 3846
3846: DISABLE
// begin ChangeMissionObjectives ( M2a ) ;
3847: LD_STRING M2a
3849: PPUSH
3850: CALL_OW 337
// radar_researched := true ;
3854: LD_ADDR_EXP 8
3858: PUSH
3859: LD_INT 1
3861: ST_TO_ADDR
// end ;
3862: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_weapon , us_radar ] , [ f_bweapon , us_radar ] ] ] ) do
3863: LD_INT 22
3865: PUSH
3866: LD_INT 1
3868: PUSH
3869: EMPTY
3870: LIST
3871: LIST
3872: PUSH
3873: LD_INT 2
3875: PUSH
3876: LD_INT 34
3878: PUSH
3879: LD_INT 11
3881: PUSH
3882: EMPTY
3883: LIST
3884: LIST
3885: PUSH
3886: LD_INT 35
3888: PUSH
3889: LD_INT 11
3891: PUSH
3892: EMPTY
3893: LIST
3894: LIST
3895: PUSH
3896: EMPTY
3897: LIST
3898: LIST
3899: LIST
3900: PUSH
3901: EMPTY
3902: LIST
3903: LIST
3904: PPUSH
3905: CALL_OW 69
3909: IFFALSE 3929
3911: GO 3913
3913: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
3914: LD_STRING M2b
3916: PPUSH
3917: CALL_OW 337
// radar_builded := true ;
3921: LD_ADDR_EXP 9
3925: PUSH
3926: LD_INT 1
3928: ST_TO_ADDR
// end ;
3929: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 and not first_apeman_tamed do
3930: LD_INT 22
3932: PUSH
3933: LD_INT 0
3935: PUSH
3936: EMPTY
3937: LIST
3938: LIST
3939: PUSH
3940: LD_INT 25
3942: PUSH
3943: LD_INT 12
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: PUSH
3950: EMPTY
3951: LIST
3952: LIST
3953: PPUSH
3954: CALL_OW 69
3958: PUSH
3959: LD_INT 0
3961: EQUAL
3962: PUSH
3963: LD_EXP 6
3967: NOT
3968: AND
3969: IFFALSE 3981
3971: GO 3973
3973: DISABLE
// YouLost ( Apeman ) ;
3974: LD_STRING Apeman
3976: PPUSH
3977: CALL_OW 104
3981: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 7 do var i , filter ;
3982: LD_INT 22
3984: PUSH
3985: LD_INT 1
3987: PUSH
3988: EMPTY
3989: LIST
3990: LIST
3991: PUSH
3992: LD_INT 25
3994: PUSH
3995: LD_INT 16
3997: PUSH
3998: EMPTY
3999: LIST
4000: LIST
4001: PUSH
4002: EMPTY
4003: LIST
4004: LIST
4005: PPUSH
4006: CALL_OW 69
4010: PUSH
4011: LD_INT 7
4013: GREATEREQUAL
4014: IFFALSE 4112
4016: GO 4018
4018: DISABLE
4019: LD_INT 0
4021: PPUSH
4022: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ^ JMM ;
4023: LD_ADDR_VAR 0 2
4027: PUSH
4028: LD_INT 22
4030: PUSH
4031: LD_INT 1
4033: PUSH
4034: EMPTY
4035: LIST
4036: LIST
4037: PUSH
4038: LD_INT 21
4040: PUSH
4041: LD_INT 1
4043: PUSH
4044: EMPTY
4045: LIST
4046: LIST
4047: PUSH
4048: LD_INT 25
4050: PUSH
4051: LD_INT 4
4053: PUSH
4054: EMPTY
4055: LIST
4056: LIST
4057: PUSH
4058: EMPTY
4059: LIST
4060: LIST
4061: LIST
4062: PPUSH
4063: CALL_OW 69
4067: PUSH
4068: LD_EXP 13
4072: ADD
4073: ST_TO_ADDR
// if filter then
4074: LD_VAR 0 2
4078: IFFALSE 4112
// for i in filter do
4080: LD_ADDR_VAR 0 1
4084: PUSH
4085: LD_VAR 0 2
4089: PUSH
4090: FOR_IN
4091: IFFALSE 4110
// AddExperience ( i , 4 , 12500 ) ;
4093: LD_VAR 0 1
4097: PPUSH
4098: LD_INT 4
4100: PPUSH
4101: LD_INT 12500
4103: PPUSH
4104: CALL_OW 492
4108: GO 4090
4110: POP
4111: POP
// end ;
4112: PPOPN 2
4114: END
// every 0 0$1 trigger end_mission do var i , tmp ;
4115: LD_EXP 12
4119: IFFALSE 5077
4121: GO 4123
4123: DISABLE
4124: LD_INT 0
4126: PPUSH
4127: PPUSH
// begin if FilterAllUnits ( [ f_side , 2 ] ) then
4128: LD_INT 22
4130: PUSH
4131: LD_INT 2
4133: PUSH
4134: EMPTY
4135: LIST
4136: LIST
4137: PPUSH
4138: CALL_OW 69
4142: IFFALSE 4180
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
4144: LD_ADDR_VAR 0 1
4148: PUSH
4149: LD_INT 22
4151: PUSH
4152: LD_INT 2
4154: PUSH
4155: EMPTY
4156: LIST
4157: LIST
4158: PPUSH
4159: CALL_OW 69
4163: PUSH
4164: FOR_IN
4165: IFFALSE 4178
// RemoveUnit ( i ) ;
4167: LD_VAR 0 1
4171: PPUSH
4172: CALL_OW 64
4176: GO 4164
4178: POP
4179: POP
// if apeman_army then
4180: LD_EXP 7
4184: IFFALSE 4198
// AddMedal ( Tame , 1 ) else
4186: LD_STRING Tame
4188: PPUSH
4189: LD_INT 1
4191: PPUSH
4192: CALL_OW 101
4196: GO 4209
// AddMedal ( Tame , - 1 ) ;
4198: LD_STRING Tame
4200: PPUSH
4201: LD_INT 1
4203: NEG
4204: PPUSH
4205: CALL_OW 101
// if radar_researched then
4209: LD_EXP 8
4213: IFFALSE 4237
// begin SaveVariable ( true , radarResInDelta ) ;
4215: LD_INT 1
4217: PPUSH
4218: LD_STRING radarResInDelta
4220: PPUSH
4221: CALL_OW 39
// AddMedal ( Radar , 1 ) ;
4225: LD_STRING Radar
4227: PPUSH
4228: LD_INT 1
4230: PPUSH
4231: CALL_OW 101
// end else
4235: GO 4267
// if radar_allowed then
4237: LD_EXP 5
4241: IFFALSE 4256
// AddMedal ( Radar , - 2 ) else
4243: LD_STRING Radar
4245: PPUSH
4246: LD_INT 2
4248: NEG
4249: PPUSH
4250: CALL_OW 101
4254: GO 4267
// AddMedal ( Radar , - 1 ) ;
4256: LD_STRING Radar
4258: PPUSH
4259: LD_INT 1
4261: NEG
4262: PPUSH
4263: CALL_OW 101
// if radar_builded then
4267: LD_EXP 9
4271: IFFALSE 4285
// AddMedal ( BuildRadar , 1 ) else
4273: LD_STRING BuildRadar
4275: PPUSH
4276: LD_INT 1
4278: PPUSH
4279: CALL_OW 101
4283: GO 4296
// AddMedal ( BuildRadar , - 1 ) ;
4285: LD_STRING BuildRadar
4287: PPUSH
4288: LD_INT 1
4290: NEG
4291: PPUSH
4292: CALL_OW 101
// GiveMedals ( MAIN ) ;
4296: LD_STRING MAIN
4298: PPUSH
4299: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
4303: LD_ADDR_VAR 0 2
4307: PUSH
4308: LD_INT 22
4310: PUSH
4311: LD_INT 1
4313: PUSH
4314: EMPTY
4315: LIST
4316: LIST
4317: PUSH
4318: LD_INT 21
4320: PUSH
4321: LD_INT 1
4323: PUSH
4324: EMPTY
4325: LIST
4326: LIST
4327: PUSH
4328: LD_INT 2
4330: PUSH
4331: LD_INT 25
4333: PUSH
4334: LD_INT 1
4336: PUSH
4337: EMPTY
4338: LIST
4339: LIST
4340: PUSH
4341: LD_INT 25
4343: PUSH
4344: LD_INT 2
4346: PUSH
4347: EMPTY
4348: LIST
4349: LIST
4350: PUSH
4351: LD_INT 25
4353: PUSH
4354: LD_INT 3
4356: PUSH
4357: EMPTY
4358: LIST
4359: LIST
4360: PUSH
4361: LD_INT 25
4363: PUSH
4364: LD_INT 4
4366: PUSH
4367: EMPTY
4368: LIST
4369: LIST
4370: PUSH
4371: EMPTY
4372: LIST
4373: LIST
4374: LIST
4375: LIST
4376: LIST
4377: PUSH
4378: EMPTY
4379: LIST
4380: LIST
4381: LIST
4382: PPUSH
4383: CALL_OW 69
4387: ST_TO_ADDR
// RewardPeople ( tmp ) ;
4388: LD_VAR 0 2
4392: PPUSH
4393: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
4397: LD_EXP 13
4401: PPUSH
4402: LD_STRING JMM
4404: PPUSH
4405: CALL_OW 38
// if IsOk ( Gladstone ) then
4409: LD_EXP 14
4413: PPUSH
4414: CALL_OW 302
4418: IFFALSE 4442
// begin SaveCharacters ( Gladstone , Gladstone ) ;
4420: LD_EXP 14
4424: PPUSH
4425: LD_STRING Gladstone
4427: PPUSH
4428: CALL_OW 38
// SaveVariable ( true , GladstoneInDelta ) ;
4432: LD_INT 1
4434: PPUSH
4435: LD_STRING GladstoneInDelta
4437: PPUSH
4438: CALL_OW 39
// end ; if IsOk ( Denis ) and GetSide ( Denis ) = 1 then
4442: LD_EXP 16
4446: PPUSH
4447: CALL_OW 302
4451: PUSH
4452: LD_EXP 16
4456: PPUSH
4457: CALL_OW 255
4461: PUSH
4462: LD_INT 1
4464: EQUAL
4465: AND
4466: IFFALSE 4490
// begin SaveCharacters ( Denis , Denis ) ;
4468: LD_EXP 16
4472: PPUSH
4473: LD_STRING Denis
4475: PPUSH
4476: CALL_OW 38
// SaveVariable ( true , DenisInDelta ) ;
4480: LD_INT 1
4482: PPUSH
4483: LD_STRING DenisInDelta
4485: PPUSH
4486: CALL_OW 39
// end ; if IsOk ( Lisa ) then
4490: LD_EXP 19
4494: PPUSH
4495: CALL_OW 302
4499: IFFALSE 4523
// begin SaveCharacters ( Lisa , Lisa ) ;
4501: LD_EXP 19
4505: PPUSH
4506: LD_STRING Lisa
4508: PPUSH
4509: CALL_OW 38
// SaveVariable ( true , LisaInDelta ) ;
4513: LD_INT 1
4515: PPUSH
4516: LD_STRING LisaInDelta
4518: PPUSH
4519: CALL_OW 39
// end ; if IsOk ( Frank ) then
4523: LD_EXP 20
4527: PPUSH
4528: CALL_OW 302
4532: IFFALSE 4556
// begin SaveCharacters ( Frank , Frank ) ;
4534: LD_EXP 20
4538: PPUSH
4539: LD_STRING Frank
4541: PPUSH
4542: CALL_OW 38
// SaveVariable ( true , FrankInDelta ) ;
4546: LD_INT 1
4548: PPUSH
4549: LD_STRING FrankInDelta
4551: PPUSH
4552: CALL_OW 39
// end ; if IsOk ( Bobby ) then
4556: LD_EXP 21
4560: PPUSH
4561: CALL_OW 302
4565: IFFALSE 4589
// begin SaveCharacters ( Bobby , Bobby ) ;
4567: LD_EXP 21
4571: PPUSH
4572: LD_STRING Bobby
4574: PPUSH
4575: CALL_OW 38
// SaveVariable ( true , BobbyInDelta ) ;
4579: LD_INT 1
4581: PPUSH
4582: LD_STRING BobbyInDelta
4584: PPUSH
4585: CALL_OW 39
// end ; if IsOk ( Cyrus ) then
4589: LD_EXP 22
4593: PPUSH
4594: CALL_OW 302
4598: IFFALSE 4622
// begin SaveCharacters ( Cyrus , Cyrus ) ;
4600: LD_EXP 22
4604: PPUSH
4605: LD_STRING Cyrus
4607: PPUSH
4608: CALL_OW 38
// SaveVariable ( true , CyrusInDelta ) ;
4612: LD_INT 1
4614: PPUSH
4615: LD_STRING CyrusInDelta
4617: PPUSH
4618: CALL_OW 39
// end ; if others then
4622: LD_EXP 23
4626: IFFALSE 4640
// SaveCharacters ( others , othersInDelta ) ;
4628: LD_EXP 23
4632: PPUSH
4633: LD_STRING othersInDelta
4635: PPUSH
4636: CALL_OW 38
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) then
4640: LD_INT 22
4642: PUSH
4643: LD_INT 1
4645: PUSH
4646: EMPTY
4647: LIST
4648: LIST
4649: PUSH
4650: LD_INT 25
4652: PUSH
4653: LD_INT 16
4655: PUSH
4656: EMPTY
4657: LIST
4658: LIST
4659: PUSH
4660: EMPTY
4661: LIST
4662: LIST
4663: PPUSH
4664: CALL_OW 69
4668: IFFALSE 4706
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) , apeInDelta ) ;
4670: LD_INT 22
4672: PUSH
4673: LD_INT 1
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: PUSH
4680: LD_INT 25
4682: PUSH
4683: LD_INT 16
4685: PUSH
4686: EMPTY
4687: LIST
4688: LIST
4689: PUSH
4690: EMPTY
4691: LIST
4692: LIST
4693: PPUSH
4694: CALL_OW 69
4698: PPUSH
4699: LD_STRING apeInDelta
4701: PPUSH
4702: CALL_OW 38
// tmp := [ ] ;
4706: LD_ADDR_VAR 0 2
4710: PUSH
4711: EMPTY
4712: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) then
4713: LD_INT 22
4715: PUSH
4716: LD_INT 1
4718: PUSH
4719: EMPTY
4720: LIST
4721: LIST
4722: PUSH
4723: LD_INT 21
4725: PUSH
4726: LD_INT 2
4728: PUSH
4729: EMPTY
4730: LIST
4731: LIST
4732: PUSH
4733: EMPTY
4734: LIST
4735: LIST
4736: PPUSH
4737: CALL_OW 69
4741: IFFALSE 4852
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
4743: LD_ADDR_VAR 0 1
4747: PUSH
4748: LD_INT 22
4750: PUSH
4751: LD_INT 1
4753: PUSH
4754: EMPTY
4755: LIST
4756: LIST
4757: PUSH
4758: LD_INT 21
4760: PUSH
4761: LD_INT 2
4763: PUSH
4764: EMPTY
4765: LIST
4766: LIST
4767: PUSH
4768: EMPTY
4769: LIST
4770: LIST
4771: PPUSH
4772: CALL_OW 69
4776: PUSH
4777: FOR_IN
4778: IFFALSE 4850
// tmp := tmp ^ [ GetNation ( i ) , GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
4780: LD_ADDR_VAR 0 2
4784: PUSH
4785: LD_VAR 0 2
4789: PUSH
4790: LD_VAR 0 1
4794: PPUSH
4795: CALL_OW 248
4799: PUSH
4800: LD_VAR 0 1
4804: PPUSH
4805: CALL_OW 265
4809: PUSH
4810: LD_VAR 0 1
4814: PPUSH
4815: CALL_OW 262
4819: PUSH
4820: LD_VAR 0 1
4824: PPUSH
4825: CALL_OW 263
4829: PUSH
4830: LD_VAR 0 1
4834: PPUSH
4835: CALL_OW 264
4839: PUSH
4840: EMPTY
4841: LIST
4842: LIST
4843: LIST
4844: LIST
4845: LIST
4846: ADD
4847: ST_TO_ADDR
4848: GO 4777
4850: POP
4851: POP
// if tmp then
4852: LD_VAR 0 2
4856: IFFALSE 4870
// SaveVariable ( tmp , vehiclesInDelta ) ;
4858: LD_VAR 0 2
4862: PPUSH
4863: LD_STRING vehiclesInDelta
4865: PPUSH
4866: CALL_OW 39
// tmp := [ ] ;
4870: LD_ADDR_VAR 0 2
4874: PUSH
4875: EMPTY
4876: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
4877: LD_INT 22
4879: PUSH
4880: LD_INT 1
4882: PUSH
4883: EMPTY
4884: LIST
4885: LIST
4886: PUSH
4887: LD_INT 21
4889: PUSH
4890: LD_INT 3
4892: PUSH
4893: EMPTY
4894: LIST
4895: LIST
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: PPUSH
4901: CALL_OW 69
4905: IFFALSE 5055
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4907: LD_ADDR_VAR 0 1
4911: PUSH
4912: LD_INT 22
4914: PUSH
4915: LD_INT 1
4917: PUSH
4918: EMPTY
4919: LIST
4920: LIST
4921: PUSH
4922: LD_INT 21
4924: PUSH
4925: LD_INT 3
4927: PUSH
4928: EMPTY
4929: LIST
4930: LIST
4931: PUSH
4932: EMPTY
4933: LIST
4934: LIST
4935: PPUSH
4936: CALL_OW 69
4940: PUSH
4941: FOR_IN
4942: IFFALSE 5053
// tmp := tmp ^ [ GetBType ( i ) , GetBLevel ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ;
4944: LD_ADDR_VAR 0 2
4948: PUSH
4949: LD_VAR 0 2
4953: PUSH
4954: LD_VAR 0 1
4958: PPUSH
4959: CALL_OW 266
4963: PUSH
4964: LD_VAR 0 1
4968: PPUSH
4969: CALL_OW 267
4973: PUSH
4974: LD_VAR 0 1
4978: PPUSH
4979: CALL_OW 250
4983: PUSH
4984: LD_VAR 0 1
4988: PPUSH
4989: CALL_OW 251
4993: PUSH
4994: LD_VAR 0 1
4998: PPUSH
4999: CALL_OW 254
5003: PUSH
5004: LD_VAR 0 1
5008: PPUSH
5009: LD_INT 1
5011: PPUSH
5012: CALL_OW 268
5016: PUSH
5017: LD_VAR 0 1
5021: PPUSH
5022: LD_INT 2
5024: PPUSH
5025: CALL_OW 268
5029: PUSH
5030: LD_VAR 0 1
5034: PPUSH
5035: CALL_OW 269
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: LIST
5044: LIST
5045: LIST
5046: LIST
5047: LIST
5048: LIST
5049: ADD
5050: ST_TO_ADDR
5051: GO 4941
5053: POP
5054: POP
// if tmp then
5055: LD_VAR 0 2
5059: IFFALSE 5073
// SaveVariable ( tmp , buildingsInDelta ) ;
5061: LD_VAR 0 2
5065: PPUSH
5066: LD_STRING buildingsInDelta
5068: PPUSH
5069: CALL_OW 39
// YouWin ;
5073: CALL_OW 103
// end ; end_of_file
5077: PPOPN 2
5079: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un , tmp ; begin
5080: LD_INT 0
5082: PPUSH
5083: PPUSH
5084: PPUSH
5085: PPUSH
// InitHc ;
5086: CALL_OW 19
// InitUc ;
5090: CALL_OW 18
// uc_side := 2 ;
5094: LD_ADDR_OWVAR 20
5098: PUSH
5099: LD_INT 2
5101: ST_TO_ADDR
// uc_nation := 2 ;
5102: LD_ADDR_OWVAR 21
5106: PUSH
5107: LD_INT 2
5109: ST_TO_ADDR
// if not amount then
5110: LD_VAR 0 1
5114: NOT
5115: IFFALSE 5119
// exit ;
5117: GO 5242
// for i = 1 to amount do
5119: LD_ADDR_VAR 0 5
5123: PUSH
5124: DOUBLE
5125: LD_INT 1
5127: DEC
5128: ST_TO_ADDR
5129: LD_VAR 0 1
5133: PUSH
5134: FOR_TO
5135: IFFALSE 5230
// begin PrepareHuman ( false , 1 , skill ) ;
5137: LD_INT 0
5139: PPUSH
5140: LD_INT 1
5142: PPUSH
5143: LD_VAR 0 2
5147: PPUSH
5148: CALL_OW 380
// un := CreateHuman ;
5152: LD_ADDR_VAR 0 6
5156: PUSH
5157: CALL_OW 44
5161: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
5162: LD_ADDR_VAR 0 7
5166: PUSH
5167: LD_VAR 0 7
5171: PPUSH
5172: LD_INT 1
5174: PPUSH
5175: LD_VAR 0 6
5179: PPUSH
5180: CALL_OW 2
5184: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5185: LD_VAR 0 6
5189: PPUSH
5190: LD_VAR 0 3
5194: PPUSH
5195: LD_INT 0
5197: PPUSH
5198: CALL_OW 49
// if i mod 3 = 0 then
5202: LD_VAR 0 5
5206: PUSH
5207: LD_INT 3
5209: MOD
5210: PUSH
5211: LD_INT 0
5213: EQUAL
5214: IFFALSE 5228
// SetTag ( un , 11 ) ;
5216: LD_VAR 0 6
5220: PPUSH
5221: LD_INT 11
5223: PPUSH
5224: CALL_OW 109
// end ;
5228: GO 5134
5230: POP
5231: POP
// result := tmp ;
5232: LD_ADDR_VAR 0 4
5236: PUSH
5237: LD_VAR 0 7
5241: ST_TO_ADDR
// end ;
5242: LD_VAR 0 4
5246: RET
// export ar_forces , ap_killers ; every 0 0$1 trigger Delta do var i , timer , more_troops , skill , eng , un , veh , force ;
5247: LD_EXP 4
5251: IFFALSE 6135
5253: GO 5255
5255: DISABLE
5256: LD_INT 0
5258: PPUSH
5259: PPUSH
5260: PPUSH
5261: PPUSH
5262: PPUSH
5263: PPUSH
5264: PPUSH
5265: PPUSH
// begin more_troops := false ;
5266: LD_ADDR_VAR 0 3
5270: PUSH
5271: LD_INT 0
5273: ST_TO_ADDR
// skill := [ 3 , 4 , 5 ] [ Difficulty ] ;
5274: LD_ADDR_VAR 0 4
5278: PUSH
5279: LD_INT 3
5281: PUSH
5282: LD_INT 4
5284: PUSH
5285: LD_INT 5
5287: PUSH
5288: EMPTY
5289: LIST
5290: LIST
5291: LIST
5292: PUSH
5293: LD_OWVAR 67
5297: ARRAY
5298: ST_TO_ADDR
// timer := [ 5 5$00 , 4 4$00 , 3 3$00 ] [ Difficulty ] ;
5299: LD_ADDR_VAR 0 2
5303: PUSH
5304: LD_INT 10500
5306: PUSH
5307: LD_INT 8400
5309: PUSH
5310: LD_INT 6300
5312: PUSH
5313: EMPTY
5314: LIST
5315: LIST
5316: LIST
5317: PUSH
5318: LD_OWVAR 67
5322: ARRAY
5323: ST_TO_ADDR
// force := [ ] ;
5324: LD_ADDR_VAR 0 8
5328: PUSH
5329: EMPTY
5330: ST_TO_ADDR
// ar_forces := [ ] ;
5331: LD_ADDR_EXP 24
5335: PUSH
5336: EMPTY
5337: ST_TO_ADDR
// ap_killers := [ ] ;
5338: LD_ADDR_EXP 25
5342: PUSH
5343: EMPTY
5344: ST_TO_ADDR
// Wait ( timer ) ;
5345: LD_VAR 0 2
5349: PPUSH
5350: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) then
5354: LD_INT 22
5356: PUSH
5357: LD_INT 1
5359: PUSH
5360: EMPTY
5361: LIST
5362: LIST
5363: PUSH
5364: LD_INT 30
5366: PUSH
5367: LD_INT 4
5369: PUSH
5370: EMPTY
5371: LIST
5372: LIST
5373: PUSH
5374: EMPTY
5375: LIST
5376: LIST
5377: PPUSH
5378: CALL_OW 69
5382: IFFALSE 5399
// begin Wait ( 1 1$25 ) ;
5384: LD_INT 2975
5386: PPUSH
5387: CALL_OW 67
// more_troops := true ;
5391: LD_ADDR_VAR 0 3
5395: PUSH
5396: LD_INT 1
5398: ST_TO_ADDR
// end ; if more_troops then
5399: LD_VAR 0 3
5403: IFFALSE 5591
// begin force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , arArea2 ) ;
5405: LD_ADDR_VAR 0 8
5409: PUSH
5410: LD_INT 4
5412: PUSH
5413: LD_INT 5
5415: PUSH
5416: LD_INT 6
5418: PUSH
5419: EMPTY
5420: LIST
5421: LIST
5422: LIST
5423: PUSH
5424: LD_OWVAR 67
5428: ARRAY
5429: PPUSH
5430: LD_VAR 0 4
5434: PPUSH
5435: LD_INT 14
5437: PPUSH
5438: CALL 5080 0 3
5442: ST_TO_ADDR
// veh := PrepareTank ( 2 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ Difficulty ] , 90 ) ;
5443: LD_ADDR_VAR 0 7
5447: PUSH
5448: LD_INT 2
5450: PPUSH
5451: LD_INT 3
5453: PPUSH
5454: LD_INT 22
5456: PPUSH
5457: LD_INT 1
5459: PPUSH
5460: LD_INT 1
5462: PPUSH
5463: LD_INT 42
5465: PUSH
5466: LD_INT 42
5468: PUSH
5469: LD_INT 43
5471: PUSH
5472: EMPTY
5473: LIST
5474: LIST
5475: LIST
5476: PUSH
5477: LD_OWVAR 67
5481: ARRAY
5482: PPUSH
5483: LD_INT 90
5485: PPUSH
5486: CALL 337 0 7
5490: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5491: LD_VAR 0 7
5495: PPUSH
5496: LD_INT 4
5498: PPUSH
5499: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
5503: LD_VAR 0 7
5507: PPUSH
5508: LD_INT 13
5510: PPUSH
5511: LD_INT 0
5513: PPUSH
5514: CALL_OW 49
// uc_side := 2 ;
5518: LD_ADDR_OWVAR 20
5522: PUSH
5523: LD_INT 2
5525: ST_TO_ADDR
// uc_nation := 2 ;
5526: LD_ADDR_OWVAR 21
5530: PUSH
5531: LD_INT 2
5533: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5534: LD_INT 0
5536: PPUSH
5537: LD_INT 1
5539: PPUSH
5540: LD_VAR 0 4
5544: PPUSH
5545: CALL_OW 380
// un := CreateHuman ;
5549: LD_ADDR_VAR 0 6
5553: PUSH
5554: CALL_OW 44
5558: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
5559: LD_VAR 0 6
5563: PPUSH
5564: LD_VAR 0 7
5568: PPUSH
5569: CALL_OW 52
// force := force ^ un ;
5573: LD_ADDR_VAR 0 8
5577: PUSH
5578: LD_VAR 0 8
5582: PUSH
5583: LD_VAR 0 6
5587: ADD
5588: ST_TO_ADDR
// end else
5589: GO 5629
// begin force := PrepareArabianTroops ( [ 3 , 4 , 5 ] [ Difficulty ] , skill , arArea2 ) ;
5591: LD_ADDR_VAR 0 8
5595: PUSH
5596: LD_INT 3
5598: PUSH
5599: LD_INT 4
5601: PUSH
5602: LD_INT 5
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: LIST
5609: PUSH
5610: LD_OWVAR 67
5614: ARRAY
5615: PPUSH
5616: LD_VAR 0 4
5620: PPUSH
5621: LD_INT 14
5623: PPUSH
5624: CALL 5080 0 3
5628: ST_TO_ADDR
// end ; if force then
5629: LD_VAR 0 8
5633: IFFALSE 5645
// ar_forces := force ;
5635: LD_ADDR_EXP 24
5639: PUSH
5640: LD_VAR 0 8
5644: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5645: LD_INT 35
5647: PPUSH
5648: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
5652: LD_INT 22
5654: PUSH
5655: LD_INT 2
5657: PUSH
5658: EMPTY
5659: LIST
5660: LIST
5661: PPUSH
5662: CALL_OW 69
5666: PUSH
5667: LD_INT 0
5669: EQUAL
5670: IFFALSE 5645
// Wait ( timer ) ;
5672: LD_VAR 0 2
5676: PPUSH
5677: CALL_OW 67
// force := PrepareArabianTroops ( [ 5 , 6 , 6 ] [ Difficulty ] , skill , [ arArea1 , arArea2 ] [ rand ( 1 , 2 ) ] ) ;
5681: LD_ADDR_VAR 0 8
5685: PUSH
5686: LD_INT 5
5688: PUSH
5689: LD_INT 6
5691: PUSH
5692: LD_INT 6
5694: PUSH
5695: EMPTY
5696: LIST
5697: LIST
5698: LIST
5699: PUSH
5700: LD_OWVAR 67
5704: ARRAY
5705: PPUSH
5706: LD_VAR 0 4
5710: PPUSH
5711: LD_INT 13
5713: PUSH
5714: LD_INT 14
5716: PUSH
5717: EMPTY
5718: LIST
5719: LIST
5720: PUSH
5721: LD_INT 1
5723: PPUSH
5724: LD_INT 2
5726: PPUSH
5727: CALL_OW 12
5731: ARRAY
5732: PPUSH
5733: CALL 5080 0 3
5737: ST_TO_ADDR
// if Difficulty > 1 and Delta then
5738: LD_OWVAR 67
5742: PUSH
5743: LD_INT 1
5745: GREATER
5746: PUSH
5747: LD_EXP 4
5751: AND
5752: IFFALSE 5911
// begin veh := PrepareTank ( 2 , 2 , ar_light_trike , engine_solar , control_manual , 22 , 100 ) ;
5754: LD_ADDR_VAR 0 7
5758: PUSH
5759: LD_INT 2
5761: PPUSH
5762: LD_INT 2
5764: PPUSH
5765: LD_INT 12
5767: PPUSH
5768: LD_INT 2
5770: PPUSH
5771: LD_INT 1
5773: PPUSH
5774: LD_INT 22
5776: PPUSH
5777: LD_INT 100
5779: PPUSH
5780: CALL 337 0 7
5784: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5785: LD_VAR 0 7
5789: PPUSH
5790: LD_INT 4
5792: PPUSH
5793: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
5797: LD_VAR 0 7
5801: PPUSH
5802: LD_INT 13
5804: PPUSH
5805: LD_INT 0
5807: PPUSH
5808: CALL_OW 49
// uc_side := 2 ;
5812: LD_ADDR_OWVAR 20
5816: PUSH
5817: LD_INT 2
5819: ST_TO_ADDR
// uc_nation := 2 ;
5820: LD_ADDR_OWVAR 21
5824: PUSH
5825: LD_INT 2
5827: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5828: LD_INT 0
5830: PPUSH
5831: LD_INT 1
5833: PPUSH
5834: LD_VAR 0 4
5838: PPUSH
5839: CALL_OW 380
// eng := CreateHuman ;
5843: LD_ADDR_VAR 0 5
5847: PUSH
5848: CALL_OW 44
5852: ST_TO_ADDR
// PlaceHumanInUnit ( eng , veh ) ;
5853: LD_VAR 0 5
5857: PPUSH
5858: LD_VAR 0 7
5862: PPUSH
5863: CALL_OW 52
// Wait ( 3 ) ;
5867: LD_INT 3
5869: PPUSH
5870: CALL_OW 67
// ComMoveUnit ( eng , Delta ) ;
5874: LD_VAR 0 5
5878: PPUSH
5879: LD_EXP 4
5883: PPUSH
5884: CALL_OW 112
// AddComExitVehicle ( eng ) ;
5888: LD_VAR 0 5
5892: PPUSH
5893: CALL_OW 181
// AddComEnterUnit ( eng , Delta ) ;
5897: LD_VAR 0 5
5901: PPUSH
5902: LD_EXP 4
5906: PPUSH
5907: CALL_OW 180
// end ; if force then
5911: LD_VAR 0 8
5915: IFFALSE 5927
// ar_forces := force ;
5917: LD_ADDR_EXP 24
5921: PUSH
5922: LD_VAR 0 8
5926: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5927: LD_INT 35
5929: PPUSH
5930: CALL_OW 67
// if eng then
5934: LD_VAR 0 5
5938: IFFALSE 5992
// if GetSide ( Delta ) = 2 and IsOk ( eng ) and not IsInUnit ( eng ) then
5940: LD_EXP 4
5944: PPUSH
5945: CALL_OW 255
5949: PUSH
5950: LD_INT 2
5952: EQUAL
5953: PUSH
5954: LD_VAR 0 5
5958: PPUSH
5959: CALL_OW 302
5963: AND
5964: PUSH
5965: LD_VAR 0 5
5969: PPUSH
5970: CALL_OW 310
5974: NOT
5975: AND
5976: IFFALSE 5992
// ComEnterUnit ( eng , Delta ) ;
5978: LD_VAR 0 5
5982: PPUSH
5983: LD_EXP 4
5987: PPUSH
5988: CALL_OW 120
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
5992: LD_INT 22
5994: PUSH
5995: LD_INT 2
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: PPUSH
6002: CALL_OW 69
6006: PUSH
6007: LD_INT 0
6009: EQUAL
6010: IFFALSE 5927
// ap_killers := PrepareArabianTroops ( [ 1 , 2 , 2 ] [ Difficulty ] , skill , arArea1 ) ;
6012: LD_ADDR_EXP 25
6016: PUSH
6017: LD_INT 1
6019: PUSH
6020: LD_INT 2
6022: PUSH
6023: LD_INT 2
6025: PUSH
6026: EMPTY
6027: LIST
6028: LIST
6029: LIST
6030: PUSH
6031: LD_OWVAR 67
6035: ARRAY
6036: PPUSH
6037: LD_VAR 0 4
6041: PPUSH
6042: LD_INT 13
6044: PPUSH
6045: CALL 5080 0 3
6049: ST_TO_ADDR
// Wait ( timer * 2 ) ;
6050: LD_VAR 0 2
6054: PUSH
6055: LD_INT 2
6057: MUL
6058: PPUSH
6059: CALL_OW 67
// ar_forces := PrepareArabianTroops ( [ 5 , 6 , 7 ] [ Difficulty ] , skill , arArea1 ) ^ PrepareArabianTroops ( [ 3 , 4 , 4 ] [ Difficulty ] , skill , arArea2 ) ;
6063: LD_ADDR_EXP 24
6067: PUSH
6068: LD_INT 5
6070: PUSH
6071: LD_INT 6
6073: PUSH
6074: LD_INT 7
6076: PUSH
6077: EMPTY
6078: LIST
6079: LIST
6080: LIST
6081: PUSH
6082: LD_OWVAR 67
6086: ARRAY
6087: PPUSH
6088: LD_VAR 0 4
6092: PPUSH
6093: LD_INT 13
6095: PPUSH
6096: CALL 5080 0 3
6100: PUSH
6101: LD_INT 3
6103: PUSH
6104: LD_INT 4
6106: PUSH
6107: LD_INT 4
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: LIST
6114: PUSH
6115: LD_OWVAR 67
6119: ARRAY
6120: PPUSH
6121: LD_VAR 0 4
6125: PPUSH
6126: LD_INT 14
6128: PPUSH
6129: CALL 5080 0 3
6133: ADD
6134: ST_TO_ADDR
// end ;
6135: PPOPN 8
6137: END
// every 0 0$01 trigger ar_forces do var i , target ;
6138: LD_EXP 24
6142: IFFALSE 6281
6144: GO 6146
6146: DISABLE
6147: LD_INT 0
6149: PPUSH
6150: PPUSH
// begin enable ;
6151: ENABLE
// if not ar_forces then
6152: LD_EXP 24
6156: NOT
6157: IFFALSE 6161
// exit ;
6159: GO 6281
// if Delta then
6161: LD_EXP 4
6165: IFFALSE 6179
// target := Delta else
6167: LD_ADDR_VAR 0 2
6171: PUSH
6172: LD_EXP 4
6176: ST_TO_ADDR
6177: GO 6189
// target := JMM ;
6179: LD_ADDR_VAR 0 2
6183: PUSH
6184: LD_EXP 13
6188: ST_TO_ADDR
// for i in ar_forces do
6189: LD_ADDR_VAR 0 1
6193: PUSH
6194: LD_EXP 24
6198: PUSH
6199: FOR_IN
6200: IFFALSE 6279
// begin if GetDistUnits ( i , target ) > 30 then
6202: LD_VAR 0 1
6206: PPUSH
6207: LD_VAR 0 2
6211: PPUSH
6212: CALL_OW 296
6216: PUSH
6217: LD_INT 30
6219: GREATER
6220: IFFALSE 6253
// ComAgressiveMove ( i , GetX ( target ) , GetY ( target ) ) else
6222: LD_VAR 0 1
6226: PPUSH
6227: LD_VAR 0 2
6231: PPUSH
6232: CALL_OW 250
6236: PPUSH
6237: LD_VAR 0 2
6241: PPUSH
6242: CALL_OW 251
6246: PPUSH
6247: CALL_OW 114
6251: GO 6277
// Attack ( i , FilterAllUnits ( [ f_enemy , 2 ] ) ) ;
6253: LD_VAR 0 1
6257: PPUSH
6258: LD_INT 81
6260: PUSH
6261: LD_INT 2
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: PPUSH
6268: CALL_OW 69
6272: PPUSH
6273: CALL 590 0 2
// end ;
6277: GO 6199
6279: POP
6280: POP
// end ;
6281: PPOPN 2
6283: END
// every 0 0$01 trigger ap_killers do var filter , i , target ;
6284: LD_EXP 25
6288: IFFALSE 6448
6290: GO 6292
6292: DISABLE
6293: LD_INT 0
6295: PPUSH
6296: PPUSH
6297: PPUSH
// begin enable ;
6298: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6299: LD_ADDR_VAR 0 1
6303: PUSH
6304: LD_INT 22
6306: PUSH
6307: LD_INT 0
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: PUSH
6314: LD_INT 25
6316: PUSH
6317: LD_INT 12
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: PUSH
6324: EMPTY
6325: LIST
6326: LIST
6327: PPUSH
6328: CALL_OW 69
6332: ST_TO_ADDR
// if not filter then
6333: LD_VAR 0 1
6337: NOT
6338: IFFALSE 6365
// begin ar_forces := ar_forces ^ ap_killers ;
6340: LD_ADDR_EXP 24
6344: PUSH
6345: LD_EXP 24
6349: PUSH
6350: LD_EXP 25
6354: ADD
6355: ST_TO_ADDR
// ap_killers := [ ] ;
6356: LD_ADDR_EXP 25
6360: PUSH
6361: EMPTY
6362: ST_TO_ADDR
// exit ;
6363: GO 6448
// end ; for i in ap_killers do
6365: LD_ADDR_VAR 0 2
6369: PUSH
6370: LD_EXP 25
6374: PUSH
6375: FOR_IN
6376: IFFALSE 6446
// begin if not IsOk ( i ) then
6378: LD_VAR 0 2
6382: PPUSH
6383: CALL_OW 302
6387: NOT
6388: IFFALSE 6392
// continue ;
6390: GO 6375
// if not HasTask ( i ) then
6392: LD_VAR 0 2
6396: PPUSH
6397: CALL_OW 314
6401: NOT
6402: IFFALSE 6424
// target := NearestUnitToUnit ( filter , i ) ;
6404: LD_ADDR_VAR 0 3
6408: PUSH
6409: LD_VAR 0 1
6413: PPUSH
6414: LD_VAR 0 2
6418: PPUSH
6419: CALL_OW 74
6423: ST_TO_ADDR
// if target then
6424: LD_VAR 0 3
6428: IFFALSE 6444
// ComAttackUnit ( i , target ) ;
6430: LD_VAR 0 2
6434: PPUSH
6435: LD_VAR 0 3
6439: PPUSH
6440: CALL_OW 115
// end ;
6444: GO 6375
6446: POP
6447: POP
// end ; end_of_file
6448: PPOPN 3
6450: END
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
6451: LD_EXP 4
6455: IFFALSE 6587
6457: GO 6459
6459: DISABLE
6460: LD_INT 0
6462: PPUSH
6463: PPUSH
6464: PPUSH
// begin counter := [ 700 , 600 , 500 ] [ Difficulty ] ;
6465: LD_ADDR_VAR 0 2
6469: PUSH
6470: LD_INT 700
6472: PUSH
6473: LD_INT 600
6475: PUSH
6476: LD_INT 500
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: LIST
6483: PUSH
6484: LD_OWVAR 67
6488: ARRAY
6489: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
6490: LD_INT 1
6492: PPUSH
6493: LD_INT 3
6495: PPUSH
6496: CALL_OW 12
6500: PPUSH
6501: LD_INT 7
6503: PPUSH
6504: LD_INT 1
6506: PPUSH
6507: CALL_OW 55
// repeat wait ( rand ( 1 1$30 , 2 2$20 ) ) ;
6511: LD_INT 3150
6513: PPUSH
6514: LD_INT 4900
6516: PPUSH
6517: CALL_OW 12
6521: PPUSH
6522: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
6526: LD_ADDR_VAR 0 3
6530: PUSH
6531: LD_INT 1
6533: PPUSH
6534: LD_INT 5
6536: PPUSH
6537: CALL_OW 12
6541: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
6542: LD_VAR 0 3
6546: PPUSH
6547: LD_INT 7
6549: PPUSH
6550: LD_INT 1
6552: PPUSH
6553: CALL_OW 55
// counter := counter - cr * 10 ;
6557: LD_ADDR_VAR 0 2
6561: PUSH
6562: LD_VAR 0 2
6566: PUSH
6567: LD_VAR 0 3
6571: PUSH
6572: LD_INT 10
6574: MUL
6575: MINUS
6576: ST_TO_ADDR
// until counter <= 0 ;
6577: LD_VAR 0 2
6581: PUSH
6582: LD_INT 0
6584: LESSEQUAL
6585: IFFALSE 6511
// end ;
6587: PPOPN 3
6589: END
// every 0 0$03 trigger not Delta do var i ;
6590: LD_EXP 4
6594: NOT
6595: IFFALSE 6665
6597: GO 6599
6599: DISABLE
6600: LD_INT 0
6602: PPUSH
// begin for i = 1 to 4 - Difficulty do
6603: LD_ADDR_VAR 0 1
6607: PUSH
6608: DOUBLE
6609: LD_INT 1
6611: DEC
6612: ST_TO_ADDR
6613: LD_INT 4
6615: PUSH
6616: LD_OWVAR 67
6620: MINUS
6621: PUSH
6622: FOR_TO
6623: IFFALSE 6663
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
6625: LD_INT 2
6627: PPUSH
6628: LD_INT 5
6630: PPUSH
6631: CALL_OW 12
6635: PPUSH
6636: LD_INT 8
6638: PPUSH
6639: LD_INT 1
6641: PPUSH
6642: CALL_OW 55
// Wait ( rand ( 0 0$16 , 0 0$39 ) ) ;
6646: LD_INT 560
6648: PPUSH
6649: LD_INT 1365
6651: PPUSH
6652: CALL_OW 12
6656: PPUSH
6657: CALL_OW 67
// end ;
6661: GO 6622
6663: POP
6664: POP
// end ;
6665: PPOPN 1
6667: END
// every 2 2$00 do
6668: GO 6670
6670: DISABLE
// begin enable ;
6671: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
6672: LD_INT 1
6674: PPUSH
6675: LD_INT 3
6677: PPUSH
6678: CALL_OW 12
6682: PPUSH
6683: LD_INT 1
6685: PPUSH
6686: CALL_OW 57
// Wait ( rand ( 0 0$38 , 0 0$59 ) ) ;
6690: LD_INT 1330
6692: PPUSH
6693: LD_INT 2065
6695: PPUSH
6696: CALL_OW 12
6700: PPUSH
6701: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 4 ) , riverArea , true ) ;
6705: LD_INT 1
6707: PPUSH
6708: LD_INT 4
6710: PPUSH
6711: CALL_OW 12
6715: PPUSH
6716: LD_INT 15
6718: PPUSH
6719: LD_INT 1
6721: PPUSH
6722: CALL_OW 55
// end ; end_of_file
6726: END
// on UnitDestroyed ( un ) do begin if un = JMM then
6727: LD_VAR 0 1
6731: PUSH
6732: LD_EXP 13
6736: EQUAL
6737: IFFALSE 6746
// YouLost ( JMM ) ;
6739: LD_STRING JMM
6741: PPUSH
6742: CALL_OW 104
// if un = Delta then
6746: LD_VAR 0 1
6750: PUSH
6751: LD_EXP 4
6755: EQUAL
6756: IFFALSE 6766
// Delta := 0 ;
6758: LD_ADDR_EXP 4
6762: PUSH
6763: LD_INT 0
6765: ST_TO_ADDR
// if un in ar_forces then
6766: LD_VAR 0 1
6770: PUSH
6771: LD_EXP 24
6775: IN
6776: IFFALSE 6794
// ar_forces := ar_forces diff un ;
6778: LD_ADDR_EXP 24
6782: PUSH
6783: LD_EXP 24
6787: PUSH
6788: LD_VAR 0 1
6792: DIFF
6793: ST_TO_ADDR
// if un in ap_killers then
6794: LD_VAR 0 1
6798: PUSH
6799: LD_EXP 25
6803: IN
6804: IFFALSE 6822
// ap_killers := ap_killers diff un ;
6806: LD_ADDR_EXP 25
6810: PUSH
6811: LD_EXP 25
6815: PUSH
6816: LD_VAR 0 1
6820: DIFF
6821: ST_TO_ADDR
// end ;
6822: PPOPN 1
6824: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
6825: LD_VAR 0 1
6829: PUSH
6830: LD_INT 1
6832: EQUAL
6833: PUSH
6834: LD_VAR 0 2
6838: PUSH
6839: LD_INT 2
6841: EQUAL
6842: AND
6843: PUSH
6844: LD_EXP 11
6848: NOT
6849: AND
6850: IFFALSE 6860
// arab_spotted := true ;
6852: LD_ADDR_EXP 11
6856: PUSH
6857: LD_INT 1
6859: ST_TO_ADDR
6860: PPOPN 2
6862: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
6863: LD_ADDR_OWVAR 57
6867: PUSH
6868: LD_INT 0
6870: ST_TO_ADDR
// end_mission := true ;
6871: LD_ADDR_EXP 12
6875: PUSH
6876: LD_INT 1
6878: ST_TO_ADDR
// end ;
6879: PPOPN 1
6881: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
6882: LD_VAR 0 2
6886: PPUSH
6887: CALL_OW 255
6891: PUSH
6892: LD_INT 1
6894: EQUAL
6895: IFFALSE 6911
// apeman_counter := apeman_counter + 1 ;
6897: LD_ADDR_EXP 10
6901: PUSH
6902: LD_EXP 10
6906: PUSH
6907: LD_INT 1
6909: PLUS
6910: ST_TO_ADDR
// if not first_apeman_tamed then
6911: LD_EXP 6
6915: NOT
6916: IFFALSE 7116
// begin first_apeman_tamed := true ;
6918: LD_ADDR_EXP 6
6922: PUSH
6923: LD_INT 1
6925: ST_TO_ADDR
// if sci = Gladstone then
6926: LD_VAR 0 2
6930: PUSH
6931: LD_EXP 14
6935: EQUAL
6936: IFFALSE 6950
// Say ( Gladstone , D7b-Glad-1 ) ;
6938: LD_EXP 14
6942: PPUSH
6943: LD_STRING D7b-Glad-1
6945: PPUSH
6946: CALL_OW 88
// if sci = Denis then
6950: LD_VAR 0 2
6954: PUSH
6955: LD_EXP 16
6959: EQUAL
6960: IFFALSE 6974
// Say ( Denis , D7a-Den-1 ) ;
6962: LD_EXP 16
6966: PPUSH
6967: LD_STRING D7a-Den-1
6969: PPUSH
6970: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
6974: LD_VAR 0 2
6978: PUSH
6979: LD_EXP 13
6983: PUSH
6984: LD_EXP 14
6988: PUSH
6989: LD_EXP 16
6993: PUSH
6994: LD_EXP 19
6998: PUSH
6999: LD_EXP 20
7003: PUSH
7004: LD_EXP 21
7008: PUSH
7009: LD_EXP 22
7013: PUSH
7014: LD_EXP 18
7018: PUSH
7019: EMPTY
7020: LIST
7021: LIST
7022: LIST
7023: LIST
7024: LIST
7025: LIST
7026: LIST
7027: LIST
7028: IN
7029: NOT
7030: IFFALSE 7073
// begin if GetSex ( sci ) = sex_male then
7032: LD_VAR 0 2
7036: PPUSH
7037: CALL_OW 258
7041: PUSH
7042: LD_INT 1
7044: EQUAL
7045: IFFALSE 7061
// Say ( sci , D7c-Sci1-1 ) else
7047: LD_VAR 0 2
7051: PPUSH
7052: LD_STRING D7c-Sci1-1
7054: PPUSH
7055: CALL_OW 88
7059: GO 7073
// Say ( sci , D7c-FSci1-1 ) ;
7061: LD_VAR 0 2
7065: PPUSH
7066: LD_STRING D7c-FSci1-1
7068: PPUSH
7069: CALL_OW 88
// end ; if not sci = Gladstone then
7073: LD_VAR 0 2
7077: PUSH
7078: LD_EXP 14
7082: EQUAL
7083: NOT
7084: IFFALSE 7098
// Say ( Gladstone , D7c-Glad-1 ) ;
7086: LD_EXP 14
7090: PPUSH
7091: LD_STRING D7c-Glad-1
7093: PPUSH
7094: CALL_OW 88
// if Lisa then
7098: LD_EXP 19
7102: IFFALSE 7116
// Say ( Lisa , D8-Lisa-1 ) ;
7104: LD_EXP 19
7108: PPUSH
7109: LD_STRING D8-Lisa-1
7111: PPUSH
7112: CALL_OW 88
// end ; end ;
7116: PPOPN 2
7118: END
