// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 72 0 0
// InitRestrictions ;
  12: CALL 192 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 26
// DebugMode ;
  22: CALL 273 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  26: LD_INT 12
  28: PPUSH
  29: LD_INT 2
  31: PPUSH
  32: CALL 527 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 6 ] [ Difficulty ] ) ;
  36: LD_INT 11
  38: PPUSH
  39: LD_INT 10
  41: PUSH
  42: LD_INT 8
  44: PUSH
  45: LD_INT 6
  47: PUSH
  48: EMPTY
  49: LIST
  50: LIST
  51: LIST
  52: PUSH
  53: LD_OWVAR 67
  57: ARRAY
  58: PPUSH
  59: CALL 527 0 2
// PrepareAmericans ;
  63: CALL 1074 0 0
// Action ;
  67: CALL 1972 0 0
// end ;
  71: END
// export debug ; export mission_prefix , mission_prefix_prev ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed , apeman_army , radar_researched , radar_builded ; export apeman_counter , arab_spotted , end_mission ; function Init ; begin
  72: LD_INT 0
  74: PPUSH
// debug := false ;
  75: LD_ADDR_EXP 1
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// mission_prefix := 05_ ;
  83: LD_ADDR_EXP 2
  87: PUSH
  88: LD_STRING 05_
  90: ST_TO_ADDR
// mission_prefix_prev := 04_ ;
  91: LD_ADDR_EXP 3
  95: PUSH
  96: LD_STRING 04_
  98: ST_TO_ADDR
// deltaBuilded := false ;
  99: LD_ADDR_EXP 4
 103: PUSH
 104: LD_INT 0
 106: ST_TO_ADDR
// denisArrives := false ;
 107: LD_ADDR_EXP 5
 111: PUSH
 112: LD_INT 0
 114: ST_TO_ADDR
// radar_allowed := false ;
 115: LD_ADDR_EXP 7
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// first_apeman_tamed := false ;
 123: LD_ADDR_EXP 8
 127: PUSH
 128: LD_INT 0
 130: ST_TO_ADDR
// arab_spotted := false ;
 131: LD_ADDR_EXP 13
 135: PUSH
 136: LD_INT 0
 138: ST_TO_ADDR
// end_mission := false ;
 139: LD_ADDR_EXP 14
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// apeman_army := false ;
 147: LD_ADDR_EXP 9
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// radar_researched := false ;
 155: LD_ADDR_EXP 10
 159: PUSH
 160: LD_INT 0
 162: ST_TO_ADDR
// radar_builded := false ;
 163: LD_ADDR_EXP 11
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// apeman_counter := 0 ;
 171: LD_ADDR_EXP 12
 175: PUSH
 176: LD_INT 0
 178: ST_TO_ADDR
// Delta := 0 ;
 179: LD_ADDR_EXP 6
 183: PUSH
 184: LD_INT 0
 186: ST_TO_ADDR
// end ;
 187: LD_VAR 0 1
 191: RET
// function InitRestrictions ; begin
 192: LD_INT 0
 194: PPUSH
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
 195: LD_INT 7
 197: PPUSH
 198: LD_INT 1
 200: PPUSH
 201: LD_INT 1
 203: PPUSH
 204: CALL_OW 324
// SetRestrict ( b_lab_full , 1 , state_enabled ) ;
 208: LD_INT 8
 210: PPUSH
 211: LD_INT 1
 213: PPUSH
 214: LD_INT 1
 216: PPUSH
 217: CALL_OW 324
// SetRestrict ( b_lab_weapon , 1 , state_enabled ) ;
 221: LD_INT 10
 223: PPUSH
 224: LD_INT 1
 226: PPUSH
 227: LD_INT 1
 229: PPUSH
 230: CALL_OW 324
// SetTech ( tech_gatling , 1 , LoadVariable ( GatlingInGamma , 1 ) ) ;
 234: LD_INT 69
 236: PPUSH
 237: LD_INT 1
 239: PPUSH
 240: LD_STRING GatlingInGamma
 242: PPUSH
 243: LD_INT 1
 245: PPUSH
 246: CALL_OW 30
 250: PPUSH
 251: CALL_OW 322
// SetTech ( tech_weap1 , 1 , state_enabled ) ;
 255: LD_INT 51
 257: PPUSH
 258: LD_INT 1
 260: PPUSH
 261: LD_INT 1
 263: PPUSH
 264: CALL_OW 322
// end ;
 268: LD_VAR 0 1
 272: RET
// function DebugMode ; begin
 273: LD_INT 0
 275: PPUSH
// FogOff ( 1 ) ;
 276: LD_INT 1
 278: PPUSH
 279: CALL_OW 344
// Difficulty := 2 ;
 283: LD_ADDR_OWVAR 67
 287: PUSH
 288: LD_INT 2
 290: ST_TO_ADDR
// end ; end_of_file
 291: LD_VAR 0 1
 295: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 296: LD_INT 0
 298: PPUSH
 299: PPUSH
// if exist_mode then
 300: LD_VAR 0 2
 304: IFFALSE 329
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 306: LD_ADDR_VAR 0 4
 310: PUSH
 311: LD_EXP 3
 315: PUSH
 316: LD_VAR 0 1
 320: STR
 321: PPUSH
 322: CALL_OW 34
 326: ST_TO_ADDR
 327: GO 344
// unit := NewCharacter ( ident ) ;
 329: LD_ADDR_VAR 0 4
 333: PUSH
 334: LD_VAR 0 1
 338: PPUSH
 339: CALL_OW 25
 343: ST_TO_ADDR
// result := unit ;
 344: LD_ADDR_VAR 0 3
 348: PUSH
 349: LD_VAR 0 4
 353: ST_TO_ADDR
// end ;
 354: LD_VAR 0 3
 358: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 359: LD_INT 0
 361: PPUSH
// uc_side := side ;
 362: LD_ADDR_OWVAR 20
 366: PUSH
 367: LD_VAR 0 1
 371: ST_TO_ADDR
// uc_nation := nation ;
 372: LD_ADDR_OWVAR 21
 376: PUSH
 377: LD_VAR 0 2
 381: ST_TO_ADDR
// vc_chassis := chassis ;
 382: LD_ADDR_OWVAR 37
 386: PUSH
 387: LD_VAR 0 3
 391: ST_TO_ADDR
// vc_engine := engine ;
 392: LD_ADDR_OWVAR 39
 396: PUSH
 397: LD_VAR 0 4
 401: ST_TO_ADDR
// vc_control := control ;
 402: LD_ADDR_OWVAR 38
 406: PUSH
 407: LD_VAR 0 5
 411: ST_TO_ADDR
// vc_weapon := weapon ;
 412: LD_ADDR_OWVAR 40
 416: PUSH
 417: LD_VAR 0 6
 421: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 422: LD_ADDR_OWVAR 41
 426: PUSH
 427: LD_VAR 0 7
 431: ST_TO_ADDR
// result := CreateVehicle ;
 432: LD_ADDR_VAR 0 8
 436: PUSH
 437: CALL_OW 45
 441: ST_TO_ADDR
// end ;
 442: LD_VAR 0 8
 446: RET
// export function SayX ( units , ident ) ; var i ; begin
 447: LD_INT 0
 449: PPUSH
 450: PPUSH
// result := false ;
 451: LD_ADDR_VAR 0 3
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// if not units then
 459: LD_VAR 0 1
 463: NOT
 464: IFFALSE 468
// exit ;
 466: GO 522
// for i in units do
 468: LD_ADDR_VAR 0 4
 472: PUSH
 473: LD_VAR 0 1
 477: PUSH
 478: FOR_IN
 479: IFFALSE 520
// if IsOk ( i ) then
 481: LD_VAR 0 4
 485: PPUSH
 486: CALL_OW 302
 490: IFFALSE 518
// begin Say ( i , ident ) ;
 492: LD_VAR 0 4
 496: PPUSH
 497: LD_VAR 0 2
 501: PPUSH
 502: CALL_OW 88
// result := i ;
 506: LD_ADDR_VAR 0 3
 510: PUSH
 511: LD_VAR 0 4
 515: ST_TO_ADDR
// break ;
 516: GO 520
// end ;
 518: GO 478
 520: POP
 521: POP
// end ;
 522: LD_VAR 0 3
 526: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 527: LD_INT 0
 529: PPUSH
 530: PPUSH
// InitUc ;
 531: CALL_OW 18
// InitHc ;
 535: CALL_OW 19
// uc_side := 0 ;
 539: LD_ADDR_OWVAR 20
 543: PUSH
 544: LD_INT 0
 546: ST_TO_ADDR
// uc_nation := 0 ;
 547: LD_ADDR_OWVAR 21
 551: PUSH
 552: LD_INT 0
 554: ST_TO_ADDR
// for i = 1 to amount do
 555: LD_ADDR_VAR 0 4
 559: PUSH
 560: DOUBLE
 561: LD_INT 1
 563: DEC
 564: ST_TO_ADDR
 565: LD_VAR 0 2
 569: PUSH
 570: FOR_TO
 571: IFFALSE 605
// begin PrepareHuman ( false , class_apeman , 1 ) ;
 573: LD_INT 0
 575: PPUSH
 576: LD_INT 12
 578: PPUSH
 579: LD_INT 1
 581: PPUSH
 582: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 586: CALL_OW 44
 590: PPUSH
 591: LD_VAR 0 1
 595: PPUSH
 596: LD_INT 0
 598: PPUSH
 599: CALL_OW 49
// end ;
 603: GO 570
 605: POP
 606: POP
// end ;
 607: LD_VAR 0 3
 611: RET
// export function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
 612: LD_INT 0
 614: PPUSH
 615: PPUSH
 616: PPUSH
// if not unit then
 617: LD_VAR 0 1
 621: NOT
 622: IFFALSE 626
// exit ;
 624: GO 1069
// if IsInUnit ( unit ) then
 626: LD_VAR 0 1
 630: PPUSH
 631: CALL_OW 310
 635: IFFALSE 652
// unit := IsDrivenBy ( unit ) ;
 637: LD_ADDR_VAR 0 1
 641: PUSH
 642: LD_VAR 0 1
 646: PPUSH
 647: CALL_OW 311
 651: ST_TO_ADDR
// targets_list := [ ] ;
 652: LD_ADDR_VAR 0 5
 656: PUSH
 657: EMPTY
 658: ST_TO_ADDR
// target := UnitFilter ( enemy_list , [ [ f_lives , 250 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 659: LD_ADDR_VAR 0 4
 663: PUSH
 664: LD_VAR 0 2
 668: PPUSH
 669: LD_INT 24
 671: PUSH
 672: LD_INT 250
 674: PUSH
 675: EMPTY
 676: LIST
 677: LIST
 678: PUSH
 679: LD_INT 3
 681: PUSH
 682: LD_INT 34
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PUSH
 692: EMPTY
 693: LIST
 694: LIST
 695: PUSH
 696: LD_INT 21
 698: PUSH
 699: LD_INT 2
 701: PUSH
 702: EMPTY
 703: LIST
 704: LIST
 705: PUSH
 706: LD_INT 58
 708: PUSH
 709: EMPTY
 710: LIST
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PPUSH
 718: CALL_OW 72
 722: ST_TO_ADDR
// if GetDistUnits ( NearestUnitToUnit ( target , unit ) , unit ) < 11 and not IsInUnit ( unit ) then
 723: LD_VAR 0 4
 727: PPUSH
 728: LD_VAR 0 1
 732: PPUSH
 733: CALL_OW 74
 737: PPUSH
 738: LD_VAR 0 1
 742: PPUSH
 743: CALL_OW 296
 747: PUSH
 748: LD_INT 11
 750: LESS
 751: PUSH
 752: LD_VAR 0 1
 756: PPUSH
 757: CALL_OW 310
 761: NOT
 762: AND
 763: IFFALSE 791
// begin ComEnterUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 765: LD_VAR 0 1
 769: PPUSH
 770: LD_VAR 0 4
 774: PPUSH
 775: LD_VAR 0 1
 779: PPUSH
 780: CALL_OW 74
 784: PPUSH
 785: CALL_OW 120
// exit ;
 789: GO 1069
// end ; targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
 791: LD_ADDR_VAR 0 5
 795: PUSH
 796: LD_VAR 0 2
 800: PPUSH
 801: LD_INT 21
 803: PUSH
 804: LD_INT 1
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 54
 816: PUSH
 817: EMPTY
 818: LIST
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: PUSH
 824: EMPTY
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL_OW 72
 832: PUSH
 833: LD_VAR 0 2
 837: PPUSH
 838: LD_INT 21
 840: PUSH
 841: LD_INT 2
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: PPUSH
 848: CALL_OW 72
 852: PUSH
 853: LD_VAR 0 2
 857: PPUSH
 858: LD_INT 21
 860: PUSH
 861: LD_INT 3
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: LD_INT 3
 870: PUSH
 871: LD_INT 58
 873: PUSH
 874: EMPTY
 875: LIST
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: PUSH
 881: EMPTY
 882: LIST
 883: LIST
 884: PPUSH
 885: CALL_OW 72
 889: PUSH
 890: LD_VAR 0 2
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: ST_TO_ADDR
// for target in targets_list do
 901: LD_ADDR_VAR 0 4
 905: PUSH
 906: LD_VAR 0 5
 910: PUSH
 911: FOR_IN
 912: IFFALSE 1067
// begin if target then
 914: LD_VAR 0 4
 918: IFFALSE 1065
// if GetTag ( unit ) = 11 and ( GetType ( NearestUnitToUnit ( target , unit ) ) = unit_building or GetWeapon ( NearestUnitToUnit ( target , unit ) ) = us_cargo_bay ) then
 920: LD_VAR 0 1
 924: PPUSH
 925: CALL_OW 110
 929: PUSH
 930: LD_INT 11
 932: EQUAL
 933: PUSH
 934: LD_VAR 0 4
 938: PPUSH
 939: LD_VAR 0 1
 943: PPUSH
 944: CALL_OW 74
 948: PPUSH
 949: CALL_OW 247
 953: PUSH
 954: LD_INT 3
 956: EQUAL
 957: PUSH
 958: LD_VAR 0 4
 962: PPUSH
 963: LD_VAR 0 1
 967: PPUSH
 968: CALL_OW 74
 972: PPUSH
 973: CALL_OW 264
 977: PUSH
 978: LD_INT 12
 980: EQUAL
 981: OR
 982: AND
 983: IFFALSE 1029
// begin ComPlaceDelayedCharge ( unit , 0 , 0 , NearestUnitToUnit ( target , unit ) ) ;
 985: LD_VAR 0 1
 989: PPUSH
 990: LD_INT 0
 992: PPUSH
 993: LD_INT 0
 995: PPUSH
 996: LD_VAR 0 4
1000: PPUSH
1001: LD_VAR 0 1
1005: PPUSH
1006: CALL_OW 74
1010: PPUSH
1011: CALL_OW 132
// SetTag ( unit , 0 ) ;
1015: LD_VAR 0 1
1019: PPUSH
1020: LD_INT 0
1022: PPUSH
1023: CALL_OW 109
// end else
1027: GO 1065
// if not HasTask ( unit ) then
1029: LD_VAR 0 1
1033: PPUSH
1034: CALL_OW 314
1038: NOT
1039: IFFALSE 1065
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
1041: LD_VAR 0 1
1045: PPUSH
1046: LD_VAR 0 4
1050: PPUSH
1051: LD_VAR 0 1
1055: PPUSH
1056: CALL_OW 74
1060: PPUSH
1061: CALL_OW 115
// end ;
1065: GO 911
1067: POP
1068: POP
// end ; end_of_file
1069: LD_VAR 0 3
1073: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
1074: LD_INT 0
1076: PPUSH
1077: PPUSH
1078: PPUSH
1079: PPUSH
1080: PPUSH
// uc_nation := 1 ;
1081: LD_ADDR_OWVAR 21
1085: PUSH
1086: LD_INT 1
1088: ST_TO_ADDR
// uc_side := 4 ;
1089: LD_ADDR_OWVAR 20
1093: PUSH
1094: LD_INT 4
1096: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
1097: LD_ADDR_EXP 18
1101: PUSH
1102: LD_STRING Denis
1104: PPUSH
1105: LD_INT 0
1107: PPUSH
1108: CALL 296 0 2
1112: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
1113: LD_ADDR_EXP 17
1117: PUSH
1118: LD_STRING Harisson
1120: PPUSH
1121: LD_INT 0
1123: PPUSH
1124: CALL 296 0 2
1128: ST_TO_ADDR
// uc_side := 1 ;
1129: LD_ADDR_OWVAR 20
1133: PUSH
1134: LD_INT 1
1136: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1137: LD_ADDR_EXP 15
1141: PUSH
1142: LD_STRING JMM
1144: PPUSH
1145: LD_EXP 1
1149: NOT
1150: PPUSH
1151: CALL 296 0 2
1155: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
1156: LD_ADDR_EXP 16
1160: PUSH
1161: LD_STRING Gladstone
1163: PPUSH
1164: LD_INT 0
1166: PPUSH
1167: CALL 296 0 2
1171: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
1172: LD_STRING BrownInDelta
1174: PPUSH
1175: LD_EXP 1
1179: PPUSH
1180: CALL_OW 30
1184: IFFALSE 1221
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1186: LD_ADDR_EXP 19
1190: PUSH
1191: LD_STRING Brown
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: CALL 296 0 2
1204: ST_TO_ADDR
// tmp := tmp ^ Brown ;
1205: LD_ADDR_VAR 0 5
1209: PUSH
1210: LD_VAR 0 5
1214: PUSH
1215: LD_EXP 19
1219: ADD
1220: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , 0 ) then
1221: LD_STRING DonaldsonInDelta
1223: PPUSH
1224: LD_INT 0
1226: PPUSH
1227: CALL_OW 30
1231: IFFALSE 1268
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1233: LD_ADDR_EXP 20
1237: PUSH
1238: LD_STRING Donaldson
1240: PPUSH
1241: LD_EXP 1
1245: NOT
1246: PPUSH
1247: CALL 296 0 2
1251: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
1252: LD_ADDR_VAR 0 5
1256: PUSH
1257: LD_VAR 0 5
1261: PUSH
1262: LD_EXP 20
1266: ADD
1267: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
1268: LD_STRING LisaInDelta
1270: PPUSH
1271: LD_EXP 1
1275: PPUSH
1276: CALL_OW 30
1280: IFFALSE 1317
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1282: LD_ADDR_EXP 21
1286: PUSH
1287: LD_STRING Lisa
1289: PPUSH
1290: LD_EXP 1
1294: NOT
1295: PPUSH
1296: CALL 296 0 2
1300: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
1301: LD_ADDR_VAR 0 5
1305: PUSH
1306: LD_VAR 0 5
1310: PUSH
1311: LD_EXP 21
1315: ADD
1316: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
1317: LD_STRING FrankInDelta
1319: PPUSH
1320: LD_EXP 1
1324: PPUSH
1325: CALL_OW 30
1329: IFFALSE 1366
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
1331: LD_ADDR_EXP 22
1335: PUSH
1336: LD_STRING Frank
1338: PPUSH
1339: LD_EXP 1
1343: NOT
1344: PPUSH
1345: CALL 296 0 2
1349: ST_TO_ADDR
// tmp := tmp ^ Frank ;
1350: LD_ADDR_VAR 0 5
1354: PUSH
1355: LD_VAR 0 5
1359: PUSH
1360: LD_EXP 22
1364: ADD
1365: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
1366: LD_STRING BobbyInDelta
1368: PPUSH
1369: LD_INT 0
1371: PPUSH
1372: CALL_OW 30
1376: IFFALSE 1413
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1378: LD_ADDR_EXP 23
1382: PUSH
1383: LD_STRING Bobby
1385: PPUSH
1386: LD_EXP 1
1390: NOT
1391: PPUSH
1392: CALL 296 0 2
1396: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
1397: LD_ADDR_VAR 0 5
1401: PUSH
1402: LD_VAR 0 5
1406: PUSH
1407: LD_EXP 23
1411: ADD
1412: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
1413: LD_STRING CyrusInDelta
1415: PPUSH
1416: LD_INT 0
1418: PPUSH
1419: CALL_OW 30
1423: IFFALSE 1460
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1425: LD_ADDR_EXP 24
1429: PUSH
1430: LD_STRING Cyrus
1432: PPUSH
1433: LD_EXP 1
1437: NOT
1438: PPUSH
1439: CALL 296 0 2
1443: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
1444: LD_ADDR_VAR 0 5
1448: PUSH
1449: LD_VAR 0 5
1453: PUSH
1454: LD_EXP 24
1458: ADD
1459: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
1460: LD_ADDR_EXP 25
1464: PUSH
1465: LD_STRING othersDelta
1467: PPUSH
1468: CALL_OW 31
1472: ST_TO_ADDR
// if not others and debug then
1473: LD_EXP 25
1477: NOT
1478: PUSH
1479: LD_EXP 1
1483: AND
1484: IFFALSE 1549
// begin InitHc ;
1486: CALL_OW 19
// for i = 1 to 2 do
1490: LD_ADDR_VAR 0 2
1494: PUSH
1495: DOUBLE
1496: LD_INT 1
1498: DEC
1499: ST_TO_ADDR
1500: LD_INT 2
1502: PUSH
1503: FOR_TO
1504: IFFALSE 1547
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
1506: LD_INT 0
1508: PPUSH
1509: LD_VAR 0 2
1513: PUSH
1514: LD_INT 4
1516: MOD
1517: PUSH
1518: LD_INT 1
1520: PLUS
1521: PPUSH
1522: LD_INT 3
1524: PPUSH
1525: CALL_OW 380
// others := others ^ CreateHuman ;
1529: LD_ADDR_EXP 25
1533: PUSH
1534: LD_EXP 25
1538: PUSH
1539: CALL_OW 44
1543: ADD
1544: ST_TO_ADDR
// end ;
1545: GO 1503
1547: POP
1548: POP
// end ; if others then
1549: LD_EXP 25
1553: IFFALSE 1571
// tmp := tmp ^ others ;
1555: LD_ADDR_VAR 0 5
1559: PUSH
1560: LD_VAR 0 5
1564: PUSH
1565: LD_EXP 25
1569: ADD
1570: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
1571: LD_ADDR_VAR 0 3
1575: PUSH
1576: LD_INT 28
1578: PUSH
1579: LD_INT 49
1581: PUSH
1582: EMPTY
1583: LIST
1584: LIST
1585: PUSH
1586: LD_INT 33
1588: PUSH
1589: LD_INT 54
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PUSH
1596: LD_INT 38
1598: PUSH
1599: LD_INT 56
1601: PUSH
1602: EMPTY
1603: LIST
1604: LIST
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: LIST
1610: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1611: LD_ADDR_VAR 0 4
1615: PUSH
1616: LD_INT 1
1618: PPUSH
1619: LD_INT 1
1621: PPUSH
1622: LD_INT 2
1624: PPUSH
1625: LD_INT 2
1627: PPUSH
1628: LD_INT 1
1630: PPUSH
1631: LD_INT 12
1633: PPUSH
1634: LD_INT 80
1636: PPUSH
1637: CALL 359 0 7
1641: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1642: LD_VAR 0 4
1646: PPUSH
1647: LD_INT 1
1649: PPUSH
1650: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1654: LD_VAR 0 4
1658: PPUSH
1659: LD_VAR 0 3
1663: PUSH
1664: LD_INT 1
1666: ARRAY
1667: PUSH
1668: LD_INT 1
1670: ARRAY
1671: PPUSH
1672: LD_VAR 0 3
1676: PUSH
1677: LD_INT 1
1679: ARRAY
1680: PUSH
1681: LD_INT 2
1683: ARRAY
1684: PPUSH
1685: LD_INT 0
1687: PPUSH
1688: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1692: LD_VAR 0 4
1696: PPUSH
1697: LD_INT 1
1699: PPUSH
1700: LD_INT 100
1702: PPUSH
1703: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1707: LD_EXP 25
1711: PUSH
1712: LD_INT 1
1714: ARRAY
1715: PPUSH
1716: LD_VAR 0 4
1720: PPUSH
1721: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1725: LD_ADDR_VAR 0 4
1729: PUSH
1730: LD_INT 1
1732: PPUSH
1733: LD_INT 1
1735: PPUSH
1736: LD_INT 1
1738: PPUSH
1739: LD_INT 2
1741: PPUSH
1742: LD_INT 1
1744: PPUSH
1745: LD_INT 2
1747: PPUSH
1748: LD_INT 80
1750: PPUSH
1751: CALL 359 0 7
1755: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1756: LD_VAR 0 4
1760: PPUSH
1761: LD_INT 1
1763: PPUSH
1764: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1768: LD_VAR 0 4
1772: PPUSH
1773: LD_VAR 0 3
1777: PUSH
1778: LD_INT 2
1780: ARRAY
1781: PUSH
1782: LD_INT 1
1784: ARRAY
1785: PPUSH
1786: LD_VAR 0 3
1790: PUSH
1791: LD_INT 2
1793: ARRAY
1794: PUSH
1795: LD_INT 2
1797: ARRAY
1798: PPUSH
1799: LD_INT 0
1801: PPUSH
1802: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1806: LD_EXP 16
1810: PPUSH
1811: LD_VAR 0 4
1815: PPUSH
1816: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
1820: LD_ADDR_VAR 0 4
1824: PUSH
1825: LD_INT 1
1827: PPUSH
1828: LD_INT 1
1830: PPUSH
1831: LD_INT 1
1833: PPUSH
1834: LD_INT 2
1836: PPUSH
1837: LD_INT 1
1839: PPUSH
1840: LD_INT 3
1842: PPUSH
1843: LD_INT 80
1845: PPUSH
1846: CALL 359 0 7
1850: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1851: LD_VAR 0 4
1855: PPUSH
1856: LD_INT 1
1858: PPUSH
1859: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
1863: LD_VAR 0 4
1867: PPUSH
1868: LD_VAR 0 3
1872: PUSH
1873: LD_INT 3
1875: ARRAY
1876: PUSH
1877: LD_INT 1
1879: ARRAY
1880: PPUSH
1881: LD_VAR 0 3
1885: PUSH
1886: LD_INT 3
1888: ARRAY
1889: PUSH
1890: LD_INT 2
1892: ARRAY
1893: PPUSH
1894: LD_INT 0
1896: PPUSH
1897: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1901: LD_EXP 15
1905: PPUSH
1906: LD_VAR 0 4
1910: PPUSH
1911: CALL_OW 52
// if others > 1 then
1915: LD_EXP 25
1919: PUSH
1920: LD_INT 1
1922: GREATER
1923: IFFALSE 1967
// for i in tmp diff others [ 1 ] do
1925: LD_ADDR_VAR 0 2
1929: PUSH
1930: LD_VAR 0 5
1934: PUSH
1935: LD_EXP 25
1939: PUSH
1940: LD_INT 1
1942: ARRAY
1943: DIFF
1944: PUSH
1945: FOR_IN
1946: IFFALSE 1965
// PlaceUnitArea ( i , startArea , false ) ;
1948: LD_VAR 0 2
1952: PPUSH
1953: LD_INT 5
1955: PPUSH
1956: LD_INT 0
1958: PPUSH
1959: CALL_OW 49
1963: GO 1945
1965: POP
1966: POP
// end ; end_of_file
1967: LD_VAR 0 1
1971: RET
// export function Action ; var m ; begin
1972: LD_INT 0
1974: PPUSH
1975: PPUSH
// InGameOn ;
1976: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
1980: LD_INT 28
1982: PPUSH
1983: LD_INT 51
1985: PPUSH
1986: CALL_OW 86
// Wait ( 3 ) ;
1990: LD_INT 3
1992: PPUSH
1993: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
1997: LD_EXP 15
2001: PPUSH
2002: LD_STRING D1d-JMM-1a
2004: PPUSH
2005: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
2009: LD_EXP 17
2013: PPUSH
2014: LD_STRING D1d-Har-1
2016: PPUSH
2017: CALL_OW 94
// InGameOff ;
2021: CALL_OW 9
// SaveForQuickRestart ;
2025: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
2029: LD_STRING M1
2031: PPUSH
2032: CALL_OW 337
// Wait ( 0 0$2 ) ;
2036: LD_INT 70
2038: PPUSH
2039: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
2043: LD_EXP 15
2047: PPUSH
2048: LD_STRING D2-JMM-1
2050: PPUSH
2051: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
2055: LD_EXP 16
2059: PPUSH
2060: LD_STRING D2-Glad-1
2062: PPUSH
2063: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2067: LD_EXP 15
2071: PPUSH
2072: LD_STRING D2-JMM-2
2074: PPUSH
2075: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
2079: LD_EXP 16
2083: PPUSH
2084: LD_STRING D2-Glad-2
2086: PPUSH
2087: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2091: LD_EXP 15
2095: PPUSH
2096: LD_STRING D2-JMM-3
2098: PPUSH
2099: CALL_OW 88
// Wait ( rand ( 0 0$30 , 1 1$00 ) ) ;
2103: LD_INT 1050
2105: PPUSH
2106: LD_INT 2100
2108: PPUSH
2109: CALL_OW 12
2113: PPUSH
2114: CALL_OW 67
// SetWeather ( 2 , 90 , 150 ) ;
2118: LD_INT 2
2120: PPUSH
2121: LD_INT 90
2123: PPUSH
2124: LD_INT 150
2126: PPUSH
2127: CALL_OW 550
// Wait ( rand ( 3 3$00 , 5 5$00 ) ) ;
2131: LD_INT 6300
2133: PPUSH
2134: LD_INT 10500
2136: PPUSH
2137: CALL_OW 12
2141: PPUSH
2142: CALL_OW 67
// SetWeather ( 0 , 90 , 150 ) ;
2146: LD_INT 0
2148: PPUSH
2149: LD_INT 90
2151: PPUSH
2152: LD_INT 150
2154: PPUSH
2155: CALL_OW 550
// end ;
2159: LD_VAR 0 1
2163: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
2164: LD_INT 22
2166: PUSH
2167: LD_INT 1
2169: PUSH
2170: EMPTY
2171: LIST
2172: LIST
2173: PUSH
2174: LD_INT 3
2176: PUSH
2177: LD_INT 57
2179: PUSH
2180: EMPTY
2181: LIST
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 30
2189: PUSH
2190: LD_INT 0
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: EMPTY
2198: LIST
2199: LIST
2200: LIST
2201: PUSH
2202: EMPTY
2203: LIST
2204: PPUSH
2205: CALL_OW 69
2209: PUSH
2210: LD_EXP 4
2214: NOT
2215: AND
2216: IFFALSE 2229
2218: GO 2220
2220: DISABLE
// begin deltaBuilded := true ;
2221: LD_ADDR_EXP 4
2225: PUSH
2226: LD_INT 1
2228: ST_TO_ADDR
// end ;
2229: END
// every 0 0$01 trigger not Delta and deltaBuilded and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) do
2230: LD_EXP 6
2234: NOT
2235: PUSH
2236: LD_EXP 4
2240: AND
2241: PUSH
2242: LD_INT 22
2244: PUSH
2245: LD_INT 1
2247: PUSH
2248: EMPTY
2249: LIST
2250: LIST
2251: PUSH
2252: LD_INT 3
2254: PUSH
2255: LD_INT 57
2257: PUSH
2258: EMPTY
2259: LIST
2260: PUSH
2261: EMPTY
2262: LIST
2263: LIST
2264: PUSH
2265: LD_INT 30
2267: PUSH
2268: LD_INT 0
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: PUSH
2280: EMPTY
2281: LIST
2282: PPUSH
2283: CALL_OW 69
2287: AND
2288: IFFALSE 2361
2290: GO 2292
2292: DISABLE
// begin enable ;
2293: ENABLE
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
2294: LD_ADDR_EXP 6
2298: PUSH
2299: LD_INT 22
2301: PUSH
2302: LD_INT 1
2304: PUSH
2305: EMPTY
2306: LIST
2307: LIST
2308: PUSH
2309: LD_INT 3
2311: PUSH
2312: LD_INT 57
2314: PUSH
2315: EMPTY
2316: LIST
2317: PUSH
2318: EMPTY
2319: LIST
2320: LIST
2321: PUSH
2322: LD_INT 30
2324: PUSH
2325: LD_INT 0
2327: PUSH
2328: EMPTY
2329: LIST
2330: LIST
2331: PUSH
2332: EMPTY
2333: LIST
2334: LIST
2335: LIST
2336: PUSH
2337: EMPTY
2338: LIST
2339: PPUSH
2340: CALL_OW 69
2344: PUSH
2345: LD_INT 1
2347: ARRAY
2348: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
2349: LD_EXP 6
2353: PPUSH
2354: LD_STRING Delta
2356: PPUSH
2357: CALL_OW 500
// end ;
2361: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched do
2362: LD_INT 1
2364: PPUSH
2365: LD_INT 1
2367: PPUSH
2368: CALL_OW 321
2372: PUSH
2373: LD_INT 2
2375: EQUAL
2376: IFFALSE 2437
2378: GO 2380
2380: DISABLE
// begin DialogueOn ;
2381: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
2385: LD_EXP 16
2389: PPUSH
2390: LD_STRING D3-Glad-1
2392: PPUSH
2393: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2397: LD_EXP 15
2401: PPUSH
2402: LD_STRING D3-JMM-1
2404: PPUSH
2405: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
2409: LD_EXP 16
2413: PPUSH
2414: LD_STRING D3-Glad-2
2416: PPUSH
2417: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
2421: LD_EXP 15
2425: PPUSH
2426: LD_STRING D3-JMM-2
2428: PPUSH
2429: CALL_OW 88
// DialogueOff ;
2433: CALL_OW 7
// end ;
2437: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
2438: LD_INT 2
2440: PPUSH
2441: LD_INT 1
2443: PPUSH
2444: CALL_OW 321
2448: PUSH
2449: LD_INT 2
2451: EQUAL
2452: IFFALSE 2629
2454: GO 2456
2456: DISABLE
2457: LD_INT 0
2459: PPUSH
// begin DialogueOn ;
2460: CALL_OW 6
// if Frank then
2464: LD_EXP 22
2468: IFFALSE 2482
// Say ( Frank , D8a-Frank-1 ) ;
2470: LD_EXP 22
2474: PPUSH
2475: LD_STRING D8a-Frank-1
2477: PPUSH
2478: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
2482: LD_ADDR_VAR 0 1
2486: PUSH
2487: LD_EXP 25
2491: PPUSH
2492: LD_INT 26
2494: PUSH
2495: LD_INT 1
2497: PUSH
2498: EMPTY
2499: LIST
2500: LIST
2501: PPUSH
2502: CALL_OW 72
2506: PPUSH
2507: LD_STRING D8a-Sol1-1
2509: PPUSH
2510: CALL 447 0 2
2514: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2515: LD_EXP 18
2519: PUSH
2520: LD_EXP 18
2524: PPUSH
2525: CALL_OW 255
2529: PUSH
2530: LD_INT 1
2532: EQUAL
2533: AND
2534: IFFALSE 2548
// Say ( Denis , D8a-Den-1 ) ;
2536: LD_EXP 18
2540: PPUSH
2541: LD_STRING D8a-Den-1
2543: PPUSH
2544: CALL_OW 88
// if sol or Denis or Frank then
2548: LD_VAR 0 1
2552: PUSH
2553: LD_EXP 18
2557: OR
2558: PUSH
2559: LD_EXP 22
2563: OR
2564: IFFALSE 2625
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2566: LD_EXP 25
2570: PPUSH
2571: LD_INT 25
2573: PUSH
2574: LD_INT 4
2576: PUSH
2577: EMPTY
2578: LIST
2579: LIST
2580: PUSH
2581: LD_INT 26
2583: PUSH
2584: LD_INT 1
2586: PUSH
2587: EMPTY
2588: LIST
2589: LIST
2590: PUSH
2591: EMPTY
2592: LIST
2593: LIST
2594: PPUSH
2595: CALL_OW 72
2599: PUSH
2600: LD_VAR 0 1
2604: DIFF
2605: PPUSH
2606: LD_STRING D8a-Sci1-1
2608: PPUSH
2609: CALL 447 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2613: LD_EXP 15
2617: PPUSH
2618: LD_STRING D8a-JMM-1
2620: PPUSH
2621: CALL_OW 88
// end ; DialogueOff ;
2625: CALL_OW 7
// end ;
2629: PPOPN 1
2631: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2632: LD_INT 22
2634: PUSH
2635: LD_INT 1
2637: PUSH
2638: EMPTY
2639: LIST
2640: LIST
2641: PUSH
2642: LD_INT 25
2644: PUSH
2645: LD_INT 16
2647: PUSH
2648: EMPTY
2649: LIST
2650: LIST
2651: PUSH
2652: EMPTY
2653: LIST
2654: LIST
2655: PPUSH
2656: CALL_OW 69
2660: IFFALSE 2719
2662: GO 2664
2664: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2665: LD_STRING M1a
2667: PPUSH
2668: CALL_OW 337
// case Query ( Q2 ) of 1 :
2672: LD_STRING Q2
2674: PPUSH
2675: CALL_OW 97
2679: PUSH
2680: LD_INT 1
2682: DOUBLE
2683: EQUAL
2684: IFTRUE 2688
2686: GO 2699
2688: POP
// end_mission := true ; 2 :
2689: LD_ADDR_EXP 14
2693: PUSH
2694: LD_INT 1
2696: ST_TO_ADDR
2697: GO 2719
2699: LD_INT 2
2701: DOUBLE
2702: EQUAL
2703: IFTRUE 2707
2705: GO 2718
2707: POP
// end_the_mission_allowed := true ; end ;
2708: LD_ADDR_OWVAR 57
2712: PUSH
2713: LD_INT 1
2715: ST_TO_ADDR
2716: GO 2719
2718: POP
// end ;
2719: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) and Delta do
2720: LD_INT 22
2722: PUSH
2723: LD_INT 1
2725: PUSH
2726: EMPTY
2727: LIST
2728: LIST
2729: PUSH
2730: LD_INT 2
2732: PUSH
2733: LD_INT 30
2735: PUSH
2736: LD_INT 6
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PUSH
2743: LD_INT 30
2745: PUSH
2746: LD_INT 7
2748: PUSH
2749: EMPTY
2750: LIST
2751: LIST
2752: PUSH
2753: EMPTY
2754: LIST
2755: LIST
2756: LIST
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: PPUSH
2762: CALL_OW 69
2766: PUSH
2767: LD_INT 22
2769: PUSH
2770: LD_INT 1
2772: PUSH
2773: EMPTY
2774: LIST
2775: LIST
2776: PUSH
2777: LD_INT 2
2779: PUSH
2780: LD_INT 30
2782: PUSH
2783: LD_INT 2
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: LD_INT 30
2792: PUSH
2793: LD_INT 3
2795: PUSH
2796: EMPTY
2797: LIST
2798: LIST
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: LIST
2804: PUSH
2805: EMPTY
2806: LIST
2807: LIST
2808: PPUSH
2809: CALL_OW 69
2813: AND
2814: PUSH
2815: LD_EXP 6
2819: AND
2820: IFFALSE 3247
2822: GO 2824
2824: DISABLE
// begin Wait ( rand ( 0 0$20 , 0 0$40 ) ) ;
2825: LD_INT 700
2827: PPUSH
2828: LD_INT 1400
2830: PPUSH
2831: CALL_OW 12
2835: PPUSH
2836: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
2840: LD_EXP 18
2844: PPUSH
2845: LD_INT 6
2847: PUSH
2848: LD_INT 9
2850: PUSH
2851: LD_INT 10
2853: PUSH
2854: EMPTY
2855: LIST
2856: LIST
2857: LIST
2858: PUSH
2859: LD_OWVAR 67
2863: ARRAY
2864: PPUSH
2865: LD_INT 0
2867: PPUSH
2868: CALL_OW 49
// ComHold ( Denis ) ;
2872: LD_EXP 18
2876: PPUSH
2877: CALL_OW 140
// InGameOn ;
2881: CALL_OW 8
// DialogueOn ;
2885: CALL_OW 6
// if Delta then
2889: LD_EXP 6
2893: IFFALSE 2906
// CenterNowOnUnits ( Delta ) else
2895: LD_EXP 6
2899: PPUSH
2900: CALL_OW 87
2904: GO 2915
// CenterNowOnUnits ( JMM ) ;
2906: LD_EXP 15
2910: PPUSH
2911: CALL_OW 87
// Say ( Denis , DD-Den-1 ) ;
2915: LD_EXP 18
2919: PPUSH
2920: LD_STRING DD-Den-1
2922: PPUSH
2923: CALL_OW 88
// Say ( JMM , DD-JMM-1 ) ;
2927: LD_EXP 15
2931: PPUSH
2932: LD_STRING DD-JMM-1
2934: PPUSH
2935: CALL_OW 88
// Say ( Denis , DD-Den-2 ) ;
2939: LD_EXP 18
2943: PPUSH
2944: LD_STRING DD-Den-2
2946: PPUSH
2947: CALL_OW 88
// Wait ( 3 ) ;
2951: LD_INT 3
2953: PPUSH
2954: CALL_OW 67
// DialogueOff ;
2958: CALL_OW 7
// InGameOff ;
2962: CALL_OW 9
// repeat wait ( 0 0$01 ) ;
2966: LD_INT 35
2968: PPUSH
2969: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
2973: LD_INT 1
2975: PPUSH
2976: LD_EXP 18
2980: PPUSH
2981: CALL_OW 292
2985: PUSH
2986: LD_EXP 18
2990: PPUSH
2991: CALL_OW 301
2995: OR
2996: IFFALSE 2966
// if IsDead ( Denis ) then
2998: LD_EXP 18
3002: PPUSH
3003: CALL_OW 301
3007: IFFALSE 3011
// exit ;
3009: GO 3247
// SetSide ( Denis , 1 ) ;
3011: LD_EXP 18
3015: PPUSH
3016: LD_INT 1
3018: PPUSH
3019: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
3023: LD_EXP 18
3027: PPUSH
3028: LD_STRING DD-Den-2a
3030: PPUSH
3031: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
3035: LD_INT 35
3037: PPUSH
3038: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
3042: LD_EXP 18
3046: PPUSH
3047: CALL_OW 310
3051: PPUSH
3052: CALL_OW 266
3056: PUSH
3057: LD_INT 6
3059: PUSH
3060: LD_INT 7
3062: PUSH
3063: LD_INT 8
3065: PUSH
3066: EMPTY
3067: LIST
3068: LIST
3069: LIST
3070: IN
3071: PUSH
3072: LD_EXP 18
3076: PPUSH
3077: CALL_OW 301
3081: OR
3082: IFFALSE 3035
// if IsDead ( Denis ) then
3084: LD_EXP 18
3088: PPUSH
3089: CALL_OW 301
3093: IFFALSE 3097
// exit ;
3095: GO 3247
// Say ( Denis , DD-Den-2b ) ;
3097: LD_EXP 18
3101: PPUSH
3102: LD_STRING DD-Den-2b
3104: PPUSH
3105: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
3109: LD_EXP 18
3113: PPUSH
3114: LD_INT 4
3116: PPUSH
3117: CALL_OW 123
// Wait ( 0 0$02 ) ;
3121: LD_INT 70
3123: PPUSH
3124: CALL_OW 67
// DialogueOn ;
3128: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
3132: LD_EXP 18
3136: PPUSH
3137: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3141: LD_EXP 15
3145: PPUSH
3146: LD_STRING D4-JMM-1
3148: PPUSH
3149: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
3153: LD_EXP 18
3157: PPUSH
3158: LD_STRING D4-Den-1
3160: PPUSH
3161: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
3165: LD_EXP 15
3169: PPUSH
3170: LD_STRING D4-JMM-2
3172: PPUSH
3173: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
3177: LD_EXP 18
3181: PPUSH
3182: LD_STRING D4-Den-2
3184: PPUSH
3185: CALL_OW 88
// DialogueOff ;
3189: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
3193: LD_STRING M2
3195: PPUSH
3196: CALL_OW 337
// radar_allowed := true ;
3200: LD_ADDR_EXP 7
3204: PUSH
3205: LD_INT 1
3207: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
3208: LD_INT 6
3210: PPUSH
3211: LD_INT 1
3213: PPUSH
3214: LD_INT 1
3216: PPUSH
3217: CALL_OW 322
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
3221: LD_INT 15
3223: PPUSH
3224: LD_INT 1
3226: PPUSH
3227: LD_INT 1
3229: PPUSH
3230: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
3234: LD_INT 20
3236: PPUSH
3237: LD_INT 1
3239: PPUSH
3240: LD_INT 1
3242: PPUSH
3243: CALL_OW 324
// end ;
3247: END
// every 0 0$1 trigger arab_spotted do var sol , sol2 ;
3248: LD_EXP 13
3252: IFFALSE 3875
3254: GO 3256
3256: DISABLE
3257: LD_INT 0
3259: PPUSH
3260: PPUSH
// begin sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D5-Sol1-1 ) ;
3261: LD_ADDR_VAR 0 1
3265: PUSH
3266: LD_EXP 25
3270: PPUSH
3271: LD_INT 26
3273: PUSH
3274: LD_INT 1
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: PPUSH
3281: CALL_OW 72
3285: PPUSH
3286: LD_STRING D5-Sol1-1
3288: PPUSH
3289: CALL 447 0 2
3293: ST_TO_ADDR
// if not sol then
3294: LD_VAR 0 1
3298: NOT
3299: IFFALSE 3303
// exit ;
3301: GO 3875
// repeat wait ( 0 0$01 ) ;
3303: LD_INT 35
3305: PPUSH
3306: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
3310: LD_INT 22
3312: PUSH
3313: LD_INT 2
3315: PUSH
3316: EMPTY
3317: LIST
3318: LIST
3319: PUSH
3320: LD_INT 21
3322: PUSH
3323: LD_INT 1
3325: PUSH
3326: EMPTY
3327: LIST
3328: LIST
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PPUSH
3334: CALL_OW 69
3338: PUSH
3339: LD_INT 0
3341: EQUAL
3342: IFFALSE 3303
// if IsOk ( sol ) then
3344: LD_VAR 0 1
3348: PPUSH
3349: CALL_OW 302
3353: IFFALSE 3373
// begin sol2 := others diff sol ;
3355: LD_ADDR_VAR 0 2
3359: PUSH
3360: LD_EXP 25
3364: PUSH
3365: LD_VAR 0 1
3369: DIFF
3370: ST_TO_ADDR
// end else
3371: GO 3375
// exit ;
3373: GO 3875
// if not Lisa and not sol2 then
3375: LD_EXP 21
3379: NOT
3380: PUSH
3381: LD_VAR 0 2
3385: NOT
3386: AND
3387: IFFALSE 3391
// exit ;
3389: GO 3875
// DialogueOn ;
3391: CALL_OW 6
// if Lisa then
3395: LD_EXP 21
3399: IFFALSE 3415
// Say ( Lisa , D5a-Lisa-1 ) else
3401: LD_EXP 21
3405: PPUSH
3406: LD_STRING D5a-Lisa-1
3408: PPUSH
3409: CALL_OW 88
3413: GO 3490
// if sol2 then
3415: LD_VAR 0 2
3419: IFFALSE 3490
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3421: LD_VAR 0 2
3425: PUSH
3426: LD_INT 1
3428: ARRAY
3429: PPUSH
3430: CALL_OW 258
3434: PUSH
3435: LD_INT 1
3437: DOUBLE
3438: EQUAL
3439: IFTRUE 3443
3441: GO 3462
3443: POP
// Say ( sol2 [ 1 ] , D5-Sol2-1 ) ; sex_female :
3444: LD_VAR 0 2
3448: PUSH
3449: LD_INT 1
3451: ARRAY
3452: PPUSH
3453: LD_STRING D5-Sol2-1
3455: PPUSH
3456: CALL_OW 88
3460: GO 3490
3462: LD_INT 2
3464: DOUBLE
3465: EQUAL
3466: IFTRUE 3470
3468: GO 3489
3470: POP
// Say ( sol2 [ 1 ] , D5-FSol2-1 ) ; end ;
3471: LD_VAR 0 2
3475: PUSH
3476: LD_INT 1
3478: ARRAY
3479: PPUSH
3480: LD_STRING D5-FSol2-1
3482: PPUSH
3483: CALL_OW 88
3487: GO 3490
3489: POP
// Say ( sol , D5-Sol1-2 ) ;
3490: LD_VAR 0 1
3494: PPUSH
3495: LD_STRING D5-Sol1-2
3497: PPUSH
3498: CALL_OW 88
// if Lisa then
3502: LD_EXP 21
3506: IFFALSE 3522
// Say ( Lisa , D5a-Lisa-2 ) else
3508: LD_EXP 21
3512: PPUSH
3513: LD_STRING D5a-Lisa-2
3515: PPUSH
3516: CALL_OW 88
3520: GO 3597
// if sol2 then
3522: LD_VAR 0 2
3526: IFFALSE 3597
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3528: LD_VAR 0 2
3532: PUSH
3533: LD_INT 1
3535: ARRAY
3536: PPUSH
3537: CALL_OW 258
3541: PUSH
3542: LD_INT 1
3544: DOUBLE
3545: EQUAL
3546: IFTRUE 3550
3548: GO 3569
3550: POP
// Say ( sol2 [ 1 ] , D5-Sol2-2 ) ; sex_female :
3551: LD_VAR 0 2
3555: PUSH
3556: LD_INT 1
3558: ARRAY
3559: PPUSH
3560: LD_STRING D5-Sol2-2
3562: PPUSH
3563: CALL_OW 88
3567: GO 3597
3569: LD_INT 2
3571: DOUBLE
3572: EQUAL
3573: IFTRUE 3577
3575: GO 3596
3577: POP
// Say ( sol2 [ 1 ] , D5-FSol2-2 ) ; end ;
3578: LD_VAR 0 2
3582: PUSH
3583: LD_INT 1
3585: ARRAY
3586: PPUSH
3587: LD_STRING D5-FSol2-2
3589: PPUSH
3590: CALL_OW 88
3594: GO 3597
3596: POP
// Say ( sol , D5a-Sol1-3 ) ;
3597: LD_VAR 0 1
3601: PPUSH
3602: LD_STRING D5a-Sol1-3
3604: PPUSH
3605: CALL_OW 88
// if Lisa then
3609: LD_EXP 21
3613: IFFALSE 3627
// Say ( Lisa , D5a-Lisa-3 ) ;
3615: LD_EXP 21
3619: PPUSH
3620: LD_STRING D5a-Lisa-3
3622: PPUSH
3623: CALL_OW 88
// if not sol2 then
3627: LD_VAR 0 2
3631: NOT
3632: IFFALSE 3640
// begin DialogueOff ;
3634: CALL_OW 7
// exit ;
3638: GO 3875
// end ; case GetSex ( sol2 [ 1 ] ) of sex_male :
3640: LD_VAR 0 2
3644: PUSH
3645: LD_INT 1
3647: ARRAY
3648: PPUSH
3649: CALL_OW 258
3653: PUSH
3654: LD_INT 1
3656: DOUBLE
3657: EQUAL
3658: IFTRUE 3662
3660: GO 3681
3662: POP
// Say ( sol2 [ 1 ] , D5-Sol2-3 ) ; sex_female :
3663: LD_VAR 0 2
3667: PUSH
3668: LD_INT 1
3670: ARRAY
3671: PPUSH
3672: LD_STRING D5-Sol2-3
3674: PPUSH
3675: CALL_OW 88
3679: GO 3709
3681: LD_INT 2
3683: DOUBLE
3684: EQUAL
3685: IFTRUE 3689
3687: GO 3708
3689: POP
// Say ( sol2 [ 1 ] , D5-FSol2-3 ) ; end ;
3690: LD_VAR 0 2
3694: PUSH
3695: LD_INT 1
3697: ARRAY
3698: PPUSH
3699: LD_STRING D5-FSol2-3
3701: PPUSH
3702: CALL_OW 88
3706: GO 3709
3708: POP
// Say ( sol , D5-Sol1-4 ) ;
3709: LD_VAR 0 1
3713: PPUSH
3714: LD_STRING D5-Sol1-4
3716: PPUSH
3717: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3721: LD_VAR 0 2
3725: PUSH
3726: LD_INT 1
3728: ARRAY
3729: PPUSH
3730: CALL_OW 258
3734: PUSH
3735: LD_INT 1
3737: DOUBLE
3738: EQUAL
3739: IFTRUE 3743
3741: GO 3762
3743: POP
// Say ( sol2 [ 1 ] , D5-Sol2-4 ) ; sex_female :
3744: LD_VAR 0 2
3748: PUSH
3749: LD_INT 1
3751: ARRAY
3752: PPUSH
3753: LD_STRING D5-Sol2-4
3755: PPUSH
3756: CALL_OW 88
3760: GO 3790
3762: LD_INT 2
3764: DOUBLE
3765: EQUAL
3766: IFTRUE 3770
3768: GO 3789
3770: POP
// Say ( sol2 [ 1 ] , D5-FSol2-4 ) ; end ;
3771: LD_VAR 0 2
3775: PUSH
3776: LD_INT 1
3778: ARRAY
3779: PPUSH
3780: LD_STRING D5-FSol2-4
3782: PPUSH
3783: CALL_OW 88
3787: GO 3790
3789: POP
// Say ( sol , D5-Sol1-5 ) ;
3790: LD_VAR 0 1
3794: PPUSH
3795: LD_STRING D5-Sol1-5
3797: PPUSH
3798: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3802: LD_VAR 0 2
3806: PUSH
3807: LD_INT 1
3809: ARRAY
3810: PPUSH
3811: CALL_OW 258
3815: PUSH
3816: LD_INT 1
3818: DOUBLE
3819: EQUAL
3820: IFTRUE 3824
3822: GO 3843
3824: POP
// Say ( sol2 [ 1 ] , D5-Sol2-5 ) ; sex_female :
3825: LD_VAR 0 2
3829: PUSH
3830: LD_INT 1
3832: ARRAY
3833: PPUSH
3834: LD_STRING D5-Sol2-5
3836: PPUSH
3837: CALL_OW 88
3841: GO 3871
3843: LD_INT 2
3845: DOUBLE
3846: EQUAL
3847: IFTRUE 3851
3849: GO 3870
3851: POP
// Say ( sol2 [ 1 ] , D5-FSol2-5 ) ; end ;
3852: LD_VAR 0 2
3856: PUSH
3857: LD_INT 1
3859: ARRAY
3860: PPUSH
3861: LD_STRING D5-FSol2-5
3863: PPUSH
3864: CALL_OW 88
3868: GO 3871
3870: POP
// DialogueOff ;
3871: CALL_OW 7
// end ;
3875: PPOPN 2
3877: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 5 do
3878: LD_INT 22
3880: PUSH
3881: LD_INT 1
3883: PUSH
3884: EMPTY
3885: LIST
3886: LIST
3887: PUSH
3888: LD_INT 25
3890: PUSH
3891: LD_INT 16
3893: PUSH
3894: EMPTY
3895: LIST
3896: LIST
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: PPUSH
3902: CALL_OW 69
3906: PUSH
3907: LD_INT 5
3909: GREATEREQUAL
3910: IFFALSE 3930
3912: GO 3914
3914: DISABLE
// begin ChangeMissionObjectives ( M1b ) ;
3915: LD_STRING M1b
3917: PPUSH
3918: CALL_OW 337
// apeman_army := true ;
3922: LD_ADDR_EXP 9
3926: PUSH
3927: LD_INT 1
3929: ST_TO_ADDR
// end ;
3930: END
// every 0 0$1 trigger GetTech ( tech_radar , 1 ) = state_researched do
3931: LD_INT 6
3933: PPUSH
3934: LD_INT 1
3936: PPUSH
3937: CALL_OW 321
3941: PUSH
3942: LD_INT 2
3944: EQUAL
3945: IFFALSE 3965
3947: GO 3949
3949: DISABLE
// begin ChangeMissionObjectives ( M2a ) ;
3950: LD_STRING M2a
3952: PPUSH
3953: CALL_OW 337
// radar_researched := true ;
3957: LD_ADDR_EXP 10
3961: PUSH
3962: LD_INT 1
3964: ST_TO_ADDR
// end ;
3965: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_weapon , us_radar ] , [ f_bweapon , us_radar ] ] ] ) do
3966: LD_INT 22
3968: PUSH
3969: LD_INT 1
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: PUSH
3976: LD_INT 2
3978: PUSH
3979: LD_INT 34
3981: PUSH
3982: LD_INT 11
3984: PUSH
3985: EMPTY
3986: LIST
3987: LIST
3988: PUSH
3989: LD_INT 35
3991: PUSH
3992: LD_INT 11
3994: PUSH
3995: EMPTY
3996: LIST
3997: LIST
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: PUSH
4004: EMPTY
4005: LIST
4006: LIST
4007: PPUSH
4008: CALL_OW 69
4012: IFFALSE 4032
4014: GO 4016
4016: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
4017: LD_STRING M2b
4019: PPUSH
4020: CALL_OW 337
// radar_builded := true ;
4024: LD_ADDR_EXP 11
4028: PUSH
4029: LD_INT 1
4031: ST_TO_ADDR
// end ;
4032: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 and not first_apeman_tamed do
4033: LD_INT 22
4035: PUSH
4036: LD_INT 0
4038: PUSH
4039: EMPTY
4040: LIST
4041: LIST
4042: PUSH
4043: LD_INT 25
4045: PUSH
4046: LD_INT 12
4048: PUSH
4049: EMPTY
4050: LIST
4051: LIST
4052: PUSH
4053: EMPTY
4054: LIST
4055: LIST
4056: PPUSH
4057: CALL_OW 69
4061: PUSH
4062: LD_INT 0
4064: EQUAL
4065: PUSH
4066: LD_EXP 8
4070: NOT
4071: AND
4072: IFFALSE 4084
4074: GO 4076
4076: DISABLE
// YouLost ( Apeman ) ;
4077: LD_STRING Apeman
4079: PPUSH
4080: CALL_OW 104
4084: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 7 do var i , filter ;
4085: LD_INT 22
4087: PUSH
4088: LD_INT 1
4090: PUSH
4091: EMPTY
4092: LIST
4093: LIST
4094: PUSH
4095: LD_INT 25
4097: PUSH
4098: LD_INT 16
4100: PUSH
4101: EMPTY
4102: LIST
4103: LIST
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: PPUSH
4109: CALL_OW 69
4113: PUSH
4114: LD_INT 7
4116: GREATEREQUAL
4117: IFFALSE 4215
4119: GO 4121
4121: DISABLE
4122: LD_INT 0
4124: PPUSH
4125: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ^ JMM ;
4126: LD_ADDR_VAR 0 2
4130: PUSH
4131: LD_INT 22
4133: PUSH
4134: LD_INT 1
4136: PUSH
4137: EMPTY
4138: LIST
4139: LIST
4140: PUSH
4141: LD_INT 21
4143: PUSH
4144: LD_INT 1
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: PUSH
4151: LD_INT 25
4153: PUSH
4154: LD_INT 4
4156: PUSH
4157: EMPTY
4158: LIST
4159: LIST
4160: PUSH
4161: EMPTY
4162: LIST
4163: LIST
4164: LIST
4165: PPUSH
4166: CALL_OW 69
4170: PUSH
4171: LD_EXP 15
4175: ADD
4176: ST_TO_ADDR
// if filter then
4177: LD_VAR 0 2
4181: IFFALSE 4215
// for i in filter do
4183: LD_ADDR_VAR 0 1
4187: PUSH
4188: LD_VAR 0 2
4192: PUSH
4193: FOR_IN
4194: IFFALSE 4213
// AddExperience ( i , 4 , 3500 ) ;
4196: LD_VAR 0 1
4200: PPUSH
4201: LD_INT 4
4203: PPUSH
4204: LD_INT 3500
4206: PPUSH
4207: CALL_OW 492
4211: GO 4193
4213: POP
4214: POP
// end ;
4215: PPOPN 2
4217: END
// every 0 0$1 trigger end_mission do var i , tmp ;
4218: LD_EXP 14
4222: IFFALSE 5223
4224: GO 4226
4226: DISABLE
4227: LD_INT 0
4229: PPUSH
4230: PPUSH
// begin if FilterAllUnits ( [ f_side , 2 ] ) then
4231: LD_INT 22
4233: PUSH
4234: LD_INT 2
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PPUSH
4241: CALL_OW 69
4245: IFFALSE 4283
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
4247: LD_ADDR_VAR 0 1
4251: PUSH
4252: LD_INT 22
4254: PUSH
4255: LD_INT 2
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: PPUSH
4262: CALL_OW 69
4266: PUSH
4267: FOR_IN
4268: IFFALSE 4281
// RemoveUnit ( i ) ;
4270: LD_VAR 0 1
4274: PPUSH
4275: CALL_OW 64
4279: GO 4267
4281: POP
4282: POP
// if apeman_army then
4283: LD_EXP 9
4287: IFFALSE 4301
// AddMedal ( Tame , 1 ) else
4289: LD_STRING Tame
4291: PPUSH
4292: LD_INT 1
4294: PPUSH
4295: CALL_OW 101
4299: GO 4312
// AddMedal ( Tame , - 1 ) ;
4301: LD_STRING Tame
4303: PPUSH
4304: LD_INT 1
4306: NEG
4307: PPUSH
4308: CALL_OW 101
// if radar_researched then
4312: LD_EXP 10
4316: IFFALSE 4340
// begin SaveVariable ( true , radarResInDelta ) ;
4318: LD_INT 1
4320: PPUSH
4321: LD_STRING radarResInDelta
4323: PPUSH
4324: CALL_OW 39
// AddMedal ( Radar , 1 ) ;
4328: LD_STRING Radar
4330: PPUSH
4331: LD_INT 1
4333: PPUSH
4334: CALL_OW 101
// end else
4338: GO 4370
// if radar_allowed then
4340: LD_EXP 7
4344: IFFALSE 4359
// AddMedal ( Radar , - 2 ) else
4346: LD_STRING Radar
4348: PPUSH
4349: LD_INT 2
4351: NEG
4352: PPUSH
4353: CALL_OW 101
4357: GO 4370
// AddMedal ( Radar , - 1 ) ;
4359: LD_STRING Radar
4361: PPUSH
4362: LD_INT 1
4364: NEG
4365: PPUSH
4366: CALL_OW 101
// if radar_builded then
4370: LD_EXP 11
4374: IFFALSE 4388
// AddMedal ( BuildRadar , 1 ) else
4376: LD_STRING BuildRadar
4378: PPUSH
4379: LD_INT 1
4381: PPUSH
4382: CALL_OW 101
4386: GO 4399
// AddMedal ( BuildRadar , - 1 ) ;
4388: LD_STRING BuildRadar
4390: PPUSH
4391: LD_INT 1
4393: NEG
4394: PPUSH
4395: CALL_OW 101
// GiveMedals ( MAIN ) ;
4399: LD_STRING MAIN
4401: PPUSH
4402: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
4406: LD_ADDR_VAR 0 2
4410: PUSH
4411: LD_INT 22
4413: PUSH
4414: LD_INT 1
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PUSH
4421: LD_INT 21
4423: PUSH
4424: LD_INT 1
4426: PUSH
4427: EMPTY
4428: LIST
4429: LIST
4430: PUSH
4431: LD_INT 2
4433: PUSH
4434: LD_INT 25
4436: PUSH
4437: LD_INT 1
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: PUSH
4444: LD_INT 25
4446: PUSH
4447: LD_INT 2
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: PUSH
4454: LD_INT 25
4456: PUSH
4457: LD_INT 3
4459: PUSH
4460: EMPTY
4461: LIST
4462: LIST
4463: PUSH
4464: LD_INT 25
4466: PUSH
4467: LD_INT 4
4469: PUSH
4470: EMPTY
4471: LIST
4472: LIST
4473: PUSH
4474: EMPTY
4475: LIST
4476: LIST
4477: LIST
4478: LIST
4479: LIST
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL_OW 69
4490: ST_TO_ADDR
// RewardPeople ( tmp ) ;
4491: LD_VAR 0 2
4495: PPUSH
4496: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
4500: LD_EXP 15
4504: PPUSH
4505: LD_EXP 2
4509: PUSH
4510: LD_STRING JMM
4512: STR
4513: PPUSH
4514: CALL_OW 38
// if IsOk ( Gladstone ) then
4518: LD_EXP 16
4522: PPUSH
4523: CALL_OW 302
4527: IFFALSE 4547
// begin SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
4529: LD_EXP 16
4533: PPUSH
4534: LD_EXP 2
4538: PUSH
4539: LD_STRING Gladstone
4541: STR
4542: PPUSH
4543: CALL_OW 38
// end ; if IsOk ( Denis ) and GetSide ( Denis ) = 1 then
4547: LD_EXP 18
4551: PPUSH
4552: CALL_OW 302
4556: PUSH
4557: LD_EXP 18
4561: PPUSH
4562: CALL_OW 255
4566: PUSH
4567: LD_INT 1
4569: EQUAL
4570: AND
4571: IFFALSE 4591
// begin SaveCharacters ( Denis , mission_prefix & Denis ) ;
4573: LD_EXP 18
4577: PPUSH
4578: LD_EXP 2
4582: PUSH
4583: LD_STRING Denis
4585: STR
4586: PPUSH
4587: CALL_OW 38
// end ; if IsOk ( Lisa ) then
4591: LD_EXP 21
4595: PPUSH
4596: CALL_OW 302
4600: IFFALSE 4620
// begin SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
4602: LD_EXP 21
4606: PPUSH
4607: LD_EXP 2
4611: PUSH
4612: LD_STRING Lisa
4614: STR
4615: PPUSH
4616: CALL_OW 38
// end ; if IsOk ( Frank ) then
4620: LD_EXP 22
4624: PPUSH
4625: CALL_OW 302
4629: IFFALSE 4649
// begin SaveCharacters ( Frank , mission_prefix & Frank ) ;
4631: LD_EXP 22
4635: PPUSH
4636: LD_EXP 2
4640: PUSH
4641: LD_STRING Frank
4643: STR
4644: PPUSH
4645: CALL_OW 38
// end ; if IsOk ( Bobby ) then
4649: LD_EXP 23
4653: PPUSH
4654: CALL_OW 302
4658: IFFALSE 4678
// begin SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
4660: LD_EXP 23
4664: PPUSH
4665: LD_EXP 2
4669: PUSH
4670: LD_STRING Bobby
4672: STR
4673: PPUSH
4674: CALL_OW 38
// end ; if IsOk ( Cyrus ) then
4678: LD_EXP 24
4682: PPUSH
4683: CALL_OW 302
4687: IFFALSE 4707
// begin SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
4689: LD_EXP 24
4693: PPUSH
4694: LD_EXP 2
4698: PUSH
4699: LD_STRING Cyrus
4701: STR
4702: PPUSH
4703: CALL_OW 38
// end ; if IsOk ( Brown ) then
4707: LD_EXP 19
4711: PPUSH
4712: CALL_OW 302
4716: IFFALSE 4736
// begin SaveCharacters ( Brown , mission_prefix & Brown ) ;
4718: LD_EXP 19
4722: PPUSH
4723: LD_EXP 2
4727: PUSH
4728: LD_STRING Brown
4730: STR
4731: PPUSH
4732: CALL_OW 38
// end ; if IsOk ( Donaldson ) then
4736: LD_EXP 20
4740: PPUSH
4741: CALL_OW 302
4745: IFFALSE 4765
// begin SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
4747: LD_EXP 20
4751: PPUSH
4752: LD_EXP 2
4756: PUSH
4757: LD_STRING Donaldson
4759: STR
4760: PPUSH
4761: CALL_OW 38
// end ; if others then
4765: LD_EXP 25
4769: IFFALSE 4783
// SaveCharacters ( others , othersInDelta ) ;
4771: LD_EXP 25
4775: PPUSH
4776: LD_STRING othersInDelta
4778: PPUSH
4779: CALL_OW 38
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) then
4783: LD_INT 22
4785: PUSH
4786: LD_INT 1
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: LD_INT 25
4795: PUSH
4796: LD_INT 16
4798: PUSH
4799: EMPTY
4800: LIST
4801: LIST
4802: PUSH
4803: EMPTY
4804: LIST
4805: LIST
4806: PPUSH
4807: CALL_OW 69
4811: IFFALSE 4849
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) , apeInDelta ) ;
4813: LD_INT 22
4815: PUSH
4816: LD_INT 1
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: LD_INT 25
4825: PUSH
4826: LD_INT 16
4828: PUSH
4829: EMPTY
4830: LIST
4831: LIST
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: PPUSH
4837: CALL_OW 69
4841: PPUSH
4842: LD_STRING apeInDelta
4844: PPUSH
4845: CALL_OW 38
// tmp := [ ] ;
4849: LD_ADDR_VAR 0 2
4853: PUSH
4854: EMPTY
4855: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) then
4856: LD_INT 22
4858: PUSH
4859: LD_INT 1
4861: PUSH
4862: EMPTY
4863: LIST
4864: LIST
4865: PUSH
4866: LD_INT 21
4868: PUSH
4869: LD_INT 2
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: PUSH
4876: EMPTY
4877: LIST
4878: LIST
4879: PPUSH
4880: CALL_OW 69
4884: IFFALSE 4995
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
4886: LD_ADDR_VAR 0 1
4890: PUSH
4891: LD_INT 22
4893: PUSH
4894: LD_INT 1
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: PUSH
4901: LD_INT 21
4903: PUSH
4904: LD_INT 2
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PPUSH
4915: CALL_OW 69
4919: PUSH
4920: FOR_IN
4921: IFFALSE 4993
// tmp := tmp ^ [ GetNation ( i ) , GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
4923: LD_ADDR_VAR 0 2
4927: PUSH
4928: LD_VAR 0 2
4932: PUSH
4933: LD_VAR 0 1
4937: PPUSH
4938: CALL_OW 248
4942: PUSH
4943: LD_VAR 0 1
4947: PPUSH
4948: CALL_OW 265
4952: PUSH
4953: LD_VAR 0 1
4957: PPUSH
4958: CALL_OW 262
4962: PUSH
4963: LD_VAR 0 1
4967: PPUSH
4968: CALL_OW 263
4972: PUSH
4973: LD_VAR 0 1
4977: PPUSH
4978: CALL_OW 264
4982: PUSH
4983: EMPTY
4984: LIST
4985: LIST
4986: LIST
4987: LIST
4988: LIST
4989: ADD
4990: ST_TO_ADDR
4991: GO 4920
4993: POP
4994: POP
// if tmp then
4995: LD_VAR 0 2
4999: IFFALSE 5013
// SaveVariable ( tmp , vehiclesInDelta ) ;
5001: LD_VAR 0 2
5005: PPUSH
5006: LD_STRING vehiclesInDelta
5008: PPUSH
5009: CALL_OW 39
// tmp := [ ] ;
5013: LD_ADDR_VAR 0 2
5017: PUSH
5018: EMPTY
5019: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
5020: LD_INT 22
5022: PUSH
5023: LD_INT 1
5025: PUSH
5026: EMPTY
5027: LIST
5028: LIST
5029: PUSH
5030: LD_INT 21
5032: PUSH
5033: LD_INT 3
5035: PUSH
5036: EMPTY
5037: LIST
5038: LIST
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: PPUSH
5044: CALL_OW 69
5048: IFFALSE 5201
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5050: LD_ADDR_VAR 0 1
5054: PUSH
5055: LD_INT 22
5057: PUSH
5058: LD_INT 1
5060: PUSH
5061: EMPTY
5062: LIST
5063: LIST
5064: PUSH
5065: LD_INT 21
5067: PUSH
5068: LD_INT 3
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: PPUSH
5079: CALL_OW 69
5083: PUSH
5084: FOR_IN
5085: IFFALSE 5199
// tmp := tmp ^ [ [ GetBType ( i ) , GetBLevel ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
5087: LD_ADDR_VAR 0 2
5091: PUSH
5092: LD_VAR 0 2
5096: PUSH
5097: LD_VAR 0 1
5101: PPUSH
5102: CALL_OW 266
5106: PUSH
5107: LD_VAR 0 1
5111: PPUSH
5112: CALL_OW 267
5116: PUSH
5117: LD_VAR 0 1
5121: PPUSH
5122: CALL_OW 250
5126: PUSH
5127: LD_VAR 0 1
5131: PPUSH
5132: CALL_OW 251
5136: PUSH
5137: LD_VAR 0 1
5141: PPUSH
5142: CALL_OW 254
5146: PUSH
5147: LD_VAR 0 1
5151: PPUSH
5152: LD_INT 1
5154: PPUSH
5155: CALL_OW 268
5159: PUSH
5160: LD_VAR 0 1
5164: PPUSH
5165: LD_INT 2
5167: PPUSH
5168: CALL_OW 268
5172: PUSH
5173: LD_VAR 0 1
5177: PPUSH
5178: CALL_OW 269
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: LIST
5187: LIST
5188: LIST
5189: LIST
5190: LIST
5191: LIST
5192: PUSH
5193: EMPTY
5194: LIST
5195: ADD
5196: ST_TO_ADDR
5197: GO 5084
5199: POP
5200: POP
// if tmp then
5201: LD_VAR 0 2
5205: IFFALSE 5219
// SaveVariable ( tmp , buildingsInDelta ) ;
5207: LD_VAR 0 2
5211: PPUSH
5212: LD_STRING buildingsInDelta
5214: PPUSH
5215: CALL_OW 39
// YouWin ;
5219: CALL_OW 103
// end ; end_of_file
5223: PPOPN 2
5225: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un , tmp ; begin
5226: LD_INT 0
5228: PPUSH
5229: PPUSH
5230: PPUSH
5231: PPUSH
// InitHc ;
5232: CALL_OW 19
// InitUc ;
5236: CALL_OW 18
// uc_side := 2 ;
5240: LD_ADDR_OWVAR 20
5244: PUSH
5245: LD_INT 2
5247: ST_TO_ADDR
// uc_nation := 2 ;
5248: LD_ADDR_OWVAR 21
5252: PUSH
5253: LD_INT 2
5255: ST_TO_ADDR
// if not amount then
5256: LD_VAR 0 1
5260: NOT
5261: IFFALSE 5265
// exit ;
5263: GO 5388
// for i = 1 to amount do
5265: LD_ADDR_VAR 0 5
5269: PUSH
5270: DOUBLE
5271: LD_INT 1
5273: DEC
5274: ST_TO_ADDR
5275: LD_VAR 0 1
5279: PUSH
5280: FOR_TO
5281: IFFALSE 5376
// begin PrepareHuman ( false , 1 , skill ) ;
5283: LD_INT 0
5285: PPUSH
5286: LD_INT 1
5288: PPUSH
5289: LD_VAR 0 2
5293: PPUSH
5294: CALL_OW 380
// un := CreateHuman ;
5298: LD_ADDR_VAR 0 6
5302: PUSH
5303: CALL_OW 44
5307: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
5308: LD_ADDR_VAR 0 7
5312: PUSH
5313: LD_VAR 0 7
5317: PPUSH
5318: LD_INT 1
5320: PPUSH
5321: LD_VAR 0 6
5325: PPUSH
5326: CALL_OW 2
5330: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5331: LD_VAR 0 6
5335: PPUSH
5336: LD_VAR 0 3
5340: PPUSH
5341: LD_INT 0
5343: PPUSH
5344: CALL_OW 49
// if i mod 2 = 0 then
5348: LD_VAR 0 5
5352: PUSH
5353: LD_INT 2
5355: MOD
5356: PUSH
5357: LD_INT 0
5359: EQUAL
5360: IFFALSE 5374
// SetTag ( un , 11 ) ;
5362: LD_VAR 0 6
5366: PPUSH
5367: LD_INT 11
5369: PPUSH
5370: CALL_OW 109
// end ;
5374: GO 5280
5376: POP
5377: POP
// result := tmp ;
5378: LD_ADDR_VAR 0 4
5382: PUSH
5383: LD_VAR 0 7
5387: ST_TO_ADDR
// end ;
5388: LD_VAR 0 4
5392: RET
// export ar_forces , ap_killers ; every 0 0$1 trigger Delta do var i , timer , more_troops , skill , eng , un , veh , force ;
5393: LD_EXP 6
5397: IFFALSE 6257
5399: GO 5401
5401: DISABLE
5402: LD_INT 0
5404: PPUSH
5405: PPUSH
5406: PPUSH
5407: PPUSH
5408: PPUSH
5409: PPUSH
5410: PPUSH
5411: PPUSH
// begin more_troops := false ;
5412: LD_ADDR_VAR 0 3
5416: PUSH
5417: LD_INT 0
5419: ST_TO_ADDR
// skill := [ 3 , 4 , 5 ] [ Difficulty ] ;
5420: LD_ADDR_VAR 0 4
5424: PUSH
5425: LD_INT 3
5427: PUSH
5428: LD_INT 4
5430: PUSH
5431: LD_INT 5
5433: PUSH
5434: EMPTY
5435: LIST
5436: LIST
5437: LIST
5438: PUSH
5439: LD_OWVAR 67
5443: ARRAY
5444: ST_TO_ADDR
// timer := [ 5 5$00 , 4 4$00 , 3 3$00 ] [ Difficulty ] ;
5445: LD_ADDR_VAR 0 2
5449: PUSH
5450: LD_INT 10500
5452: PUSH
5453: LD_INT 8400
5455: PUSH
5456: LD_INT 6300
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: LIST
5463: PUSH
5464: LD_OWVAR 67
5468: ARRAY
5469: ST_TO_ADDR
// force := [ ] ;
5470: LD_ADDR_VAR 0 8
5474: PUSH
5475: EMPTY
5476: ST_TO_ADDR
// ar_forces := [ ] ;
5477: LD_ADDR_EXP 26
5481: PUSH
5482: EMPTY
5483: ST_TO_ADDR
// ap_killers := [ ] ;
5484: LD_ADDR_EXP 27
5488: PUSH
5489: EMPTY
5490: ST_TO_ADDR
// Wait ( timer ) ;
5491: LD_VAR 0 2
5495: PPUSH
5496: CALL_OW 67
// if Denis and GetSide ( Denis ) = 4 then
5500: LD_EXP 18
5504: PUSH
5505: LD_EXP 18
5509: PPUSH
5510: CALL_OW 255
5514: PUSH
5515: LD_INT 4
5517: EQUAL
5518: AND
5519: IFFALSE 5528
// Wait ( 0 0$45 ) ;
5521: LD_INT 1575
5523: PPUSH
5524: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) then
5528: LD_INT 22
5530: PUSH
5531: LD_INT 1
5533: PUSH
5534: EMPTY
5535: LIST
5536: LIST
5537: PUSH
5538: LD_INT 30
5540: PUSH
5541: LD_INT 4
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: PUSH
5548: EMPTY
5549: LIST
5550: LIST
5551: PPUSH
5552: CALL_OW 69
5556: IFFALSE 5573
// begin Wait ( 1 1$25 ) ;
5558: LD_INT 2975
5560: PPUSH
5561: CALL_OW 67
// more_troops := true ;
5565: LD_ADDR_VAR 0 3
5569: PUSH
5570: LD_INT 1
5572: ST_TO_ADDR
// end ; if more_troops then
5573: LD_VAR 0 3
5577: IFFALSE 5765
// begin force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , arArea2 ) ;
5579: LD_ADDR_VAR 0 8
5583: PUSH
5584: LD_INT 4
5586: PUSH
5587: LD_INT 5
5589: PUSH
5590: LD_INT 6
5592: PUSH
5593: EMPTY
5594: LIST
5595: LIST
5596: LIST
5597: PUSH
5598: LD_OWVAR 67
5602: ARRAY
5603: PPUSH
5604: LD_VAR 0 4
5608: PPUSH
5609: LD_INT 14
5611: PPUSH
5612: CALL 5226 0 3
5616: ST_TO_ADDR
// veh := PrepareTank ( 2 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ Difficulty ] , 90 ) ;
5617: LD_ADDR_VAR 0 7
5621: PUSH
5622: LD_INT 2
5624: PPUSH
5625: LD_INT 3
5627: PPUSH
5628: LD_INT 22
5630: PPUSH
5631: LD_INT 1
5633: PPUSH
5634: LD_INT 1
5636: PPUSH
5637: LD_INT 42
5639: PUSH
5640: LD_INT 42
5642: PUSH
5643: LD_INT 43
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: LIST
5650: PUSH
5651: LD_OWVAR 67
5655: ARRAY
5656: PPUSH
5657: LD_INT 90
5659: PPUSH
5660: CALL 359 0 7
5664: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5665: LD_VAR 0 7
5669: PPUSH
5670: LD_INT 4
5672: PPUSH
5673: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
5677: LD_VAR 0 7
5681: PPUSH
5682: LD_INT 13
5684: PPUSH
5685: LD_INT 0
5687: PPUSH
5688: CALL_OW 49
// uc_side := 2 ;
5692: LD_ADDR_OWVAR 20
5696: PUSH
5697: LD_INT 2
5699: ST_TO_ADDR
// uc_nation := 2 ;
5700: LD_ADDR_OWVAR 21
5704: PUSH
5705: LD_INT 2
5707: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5708: LD_INT 0
5710: PPUSH
5711: LD_INT 1
5713: PPUSH
5714: LD_VAR 0 4
5718: PPUSH
5719: CALL_OW 380
// un := CreateHuman ;
5723: LD_ADDR_VAR 0 6
5727: PUSH
5728: CALL_OW 44
5732: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
5733: LD_VAR 0 6
5737: PPUSH
5738: LD_VAR 0 7
5742: PPUSH
5743: CALL_OW 52
// force := force ^ un ;
5747: LD_ADDR_VAR 0 8
5751: PUSH
5752: LD_VAR 0 8
5756: PUSH
5757: LD_VAR 0 6
5761: ADD
5762: ST_TO_ADDR
// end else
5763: GO 5803
// begin force := PrepareArabianTroops ( [ 3 , 4 , 5 ] [ Difficulty ] , skill , arArea2 ) ;
5765: LD_ADDR_VAR 0 8
5769: PUSH
5770: LD_INT 3
5772: PUSH
5773: LD_INT 4
5775: PUSH
5776: LD_INT 5
5778: PUSH
5779: EMPTY
5780: LIST
5781: LIST
5782: LIST
5783: PUSH
5784: LD_OWVAR 67
5788: ARRAY
5789: PPUSH
5790: LD_VAR 0 4
5794: PPUSH
5795: LD_INT 14
5797: PPUSH
5798: CALL 5226 0 3
5802: ST_TO_ADDR
// end ; if force then
5803: LD_VAR 0 8
5807: IFFALSE 5819
// ar_forces := force ;
5809: LD_ADDR_EXP 26
5813: PUSH
5814: LD_VAR 0 8
5818: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5819: LD_INT 35
5821: PPUSH
5822: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
5826: LD_INT 22
5828: PUSH
5829: LD_INT 2
5831: PUSH
5832: EMPTY
5833: LIST
5834: LIST
5835: PUSH
5836: LD_INT 21
5838: PUSH
5839: LD_INT 1
5841: PUSH
5842: EMPTY
5843: LIST
5844: LIST
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: PPUSH
5850: CALL_OW 69
5854: PUSH
5855: LD_INT 0
5857: EQUAL
5858: IFFALSE 5819
// Wait ( timer ) ;
5860: LD_VAR 0 2
5864: PPUSH
5865: CALL_OW 67
// force := PrepareArabianTroops ( [ 5 , 6 , 6 ] [ Difficulty ] , skill , [ arArea1 , arArea2 ] [ rand ( 1 , 2 ) ] ) ;
5869: LD_ADDR_VAR 0 8
5873: PUSH
5874: LD_INT 5
5876: PUSH
5877: LD_INT 6
5879: PUSH
5880: LD_INT 6
5882: PUSH
5883: EMPTY
5884: LIST
5885: LIST
5886: LIST
5887: PUSH
5888: LD_OWVAR 67
5892: ARRAY
5893: PPUSH
5894: LD_VAR 0 4
5898: PPUSH
5899: LD_INT 13
5901: PUSH
5902: LD_INT 14
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: PUSH
5909: LD_INT 1
5911: PPUSH
5912: LD_INT 2
5914: PPUSH
5915: CALL_OW 12
5919: ARRAY
5920: PPUSH
5921: CALL 5226 0 3
5925: ST_TO_ADDR
// if Difficulty > 1 and Delta then
5926: LD_OWVAR 67
5930: PUSH
5931: LD_INT 1
5933: GREATER
5934: PUSH
5935: LD_EXP 6
5939: AND
5940: IFFALSE 6019
// begin uc_side := 2 ;
5942: LD_ADDR_OWVAR 20
5946: PUSH
5947: LD_INT 2
5949: ST_TO_ADDR
// uc_nation := 2 ;
5950: LD_ADDR_OWVAR 21
5954: PUSH
5955: LD_INT 2
5957: ST_TO_ADDR
// PrepareHuman ( false , 2 , skill ) ;
5958: LD_INT 0
5960: PPUSH
5961: LD_INT 2
5963: PPUSH
5964: LD_VAR 0 4
5968: PPUSH
5969: CALL_OW 380
// eng := CreateHuman ;
5973: LD_ADDR_VAR 0 5
5977: PUSH
5978: CALL_OW 44
5982: ST_TO_ADDR
// PlaceUnitArea ( eng , arArea1 , false ) ;
5983: LD_VAR 0 5
5987: PPUSH
5988: LD_INT 13
5990: PPUSH
5991: LD_INT 0
5993: PPUSH
5994: CALL_OW 49
// Wait ( 3 ) ;
5998: LD_INT 3
6000: PPUSH
6001: CALL_OW 67
// AddComEnterUnit ( eng , Delta ) ;
6005: LD_VAR 0 5
6009: PPUSH
6010: LD_EXP 6
6014: PPUSH
6015: CALL_OW 180
// end ; if force then
6019: LD_VAR 0 8
6023: IFFALSE 6035
// ar_forces := force ;
6025: LD_ADDR_EXP 26
6029: PUSH
6030: LD_VAR 0 8
6034: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6035: LD_INT 35
6037: PPUSH
6038: CALL_OW 67
// if eng then
6042: LD_VAR 0 5
6046: IFFALSE 6100
// if GetSide ( Delta ) = 2 and IsOk ( eng ) and not IsInUnit ( eng ) then
6048: LD_EXP 6
6052: PPUSH
6053: CALL_OW 255
6057: PUSH
6058: LD_INT 2
6060: EQUAL
6061: PUSH
6062: LD_VAR 0 5
6066: PPUSH
6067: CALL_OW 302
6071: AND
6072: PUSH
6073: LD_VAR 0 5
6077: PPUSH
6078: CALL_OW 310
6082: NOT
6083: AND
6084: IFFALSE 6100
// ComEnterUnit ( eng , Delta ) ;
6086: LD_VAR 0 5
6090: PPUSH
6091: LD_EXP 6
6095: PPUSH
6096: CALL_OW 120
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
6100: LD_INT 22
6102: PUSH
6103: LD_INT 2
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: PUSH
6110: LD_INT 21
6112: PUSH
6113: LD_INT 1
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: PPUSH
6124: CALL_OW 69
6128: PUSH
6129: LD_INT 0
6131: EQUAL
6132: IFFALSE 6035
// ap_killers := PrepareArabianTroops ( [ 1 , 2 , 2 ] [ Difficulty ] , skill , arArea1 ) ;
6134: LD_ADDR_EXP 27
6138: PUSH
6139: LD_INT 1
6141: PUSH
6142: LD_INT 2
6144: PUSH
6145: LD_INT 2
6147: PUSH
6148: EMPTY
6149: LIST
6150: LIST
6151: LIST
6152: PUSH
6153: LD_OWVAR 67
6157: ARRAY
6158: PPUSH
6159: LD_VAR 0 4
6163: PPUSH
6164: LD_INT 13
6166: PPUSH
6167: CALL 5226 0 3
6171: ST_TO_ADDR
// Wait ( timer * 2 ) ;
6172: LD_VAR 0 2
6176: PUSH
6177: LD_INT 2
6179: MUL
6180: PPUSH
6181: CALL_OW 67
// ar_forces := PrepareArabianTroops ( [ 5 , 6 , 7 ] [ Difficulty ] , skill , arArea1 ) ^ PrepareArabianTroops ( [ 3 , 4 , 4 ] [ Difficulty ] , skill , arArea2 ) ;
6185: LD_ADDR_EXP 26
6189: PUSH
6190: LD_INT 5
6192: PUSH
6193: LD_INT 6
6195: PUSH
6196: LD_INT 7
6198: PUSH
6199: EMPTY
6200: LIST
6201: LIST
6202: LIST
6203: PUSH
6204: LD_OWVAR 67
6208: ARRAY
6209: PPUSH
6210: LD_VAR 0 4
6214: PPUSH
6215: LD_INT 13
6217: PPUSH
6218: CALL 5226 0 3
6222: PUSH
6223: LD_INT 3
6225: PUSH
6226: LD_INT 4
6228: PUSH
6229: LD_INT 4
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: LIST
6236: PUSH
6237: LD_OWVAR 67
6241: ARRAY
6242: PPUSH
6243: LD_VAR 0 4
6247: PPUSH
6248: LD_INT 14
6250: PPUSH
6251: CALL 5226 0 3
6255: ADD
6256: ST_TO_ADDR
// end ;
6257: PPOPN 8
6259: END
// every 0 0$03 trigger ar_forces do var i , target ;
6260: LD_EXP 26
6264: IFFALSE 6403
6266: GO 6268
6268: DISABLE
6269: LD_INT 0
6271: PPUSH
6272: PPUSH
// begin enable ;
6273: ENABLE
// if not ar_forces then
6274: LD_EXP 26
6278: NOT
6279: IFFALSE 6283
// exit ;
6281: GO 6403
// if Delta then
6283: LD_EXP 6
6287: IFFALSE 6301
// target := Delta else
6289: LD_ADDR_VAR 0 2
6293: PUSH
6294: LD_EXP 6
6298: ST_TO_ADDR
6299: GO 6311
// target := JMM ;
6301: LD_ADDR_VAR 0 2
6305: PUSH
6306: LD_EXP 15
6310: ST_TO_ADDR
// for i in ar_forces do
6311: LD_ADDR_VAR 0 1
6315: PUSH
6316: LD_EXP 26
6320: PUSH
6321: FOR_IN
6322: IFFALSE 6401
// begin if GetDistUnits ( i , target ) > 30 then
6324: LD_VAR 0 1
6328: PPUSH
6329: LD_VAR 0 2
6333: PPUSH
6334: CALL_OW 296
6338: PUSH
6339: LD_INT 30
6341: GREATER
6342: IFFALSE 6375
// ComAgressiveMove ( i , GetX ( target ) , GetY ( target ) ) else
6344: LD_VAR 0 1
6348: PPUSH
6349: LD_VAR 0 2
6353: PPUSH
6354: CALL_OW 250
6358: PPUSH
6359: LD_VAR 0 2
6363: PPUSH
6364: CALL_OW 251
6368: PPUSH
6369: CALL_OW 114
6373: GO 6399
// Attack ( i , FilterAllUnits ( [ f_enemy , 2 ] ) ) ;
6375: LD_VAR 0 1
6379: PPUSH
6380: LD_INT 81
6382: PUSH
6383: LD_INT 2
6385: PUSH
6386: EMPTY
6387: LIST
6388: LIST
6389: PPUSH
6390: CALL_OW 69
6394: PPUSH
6395: CALL 612 0 2
// end ;
6399: GO 6321
6401: POP
6402: POP
// end ;
6403: PPOPN 2
6405: END
// every 0 0$01 trigger ap_killers do var filter , i , target ;
6406: LD_EXP 27
6410: IFFALSE 6570
6412: GO 6414
6414: DISABLE
6415: LD_INT 0
6417: PPUSH
6418: PPUSH
6419: PPUSH
// begin enable ;
6420: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6421: LD_ADDR_VAR 0 1
6425: PUSH
6426: LD_INT 22
6428: PUSH
6429: LD_INT 0
6431: PUSH
6432: EMPTY
6433: LIST
6434: LIST
6435: PUSH
6436: LD_INT 25
6438: PUSH
6439: LD_INT 12
6441: PUSH
6442: EMPTY
6443: LIST
6444: LIST
6445: PUSH
6446: EMPTY
6447: LIST
6448: LIST
6449: PPUSH
6450: CALL_OW 69
6454: ST_TO_ADDR
// if not filter then
6455: LD_VAR 0 1
6459: NOT
6460: IFFALSE 6487
// begin ar_forces := ar_forces ^ ap_killers ;
6462: LD_ADDR_EXP 26
6466: PUSH
6467: LD_EXP 26
6471: PUSH
6472: LD_EXP 27
6476: ADD
6477: ST_TO_ADDR
// ap_killers := [ ] ;
6478: LD_ADDR_EXP 27
6482: PUSH
6483: EMPTY
6484: ST_TO_ADDR
// exit ;
6485: GO 6570
// end ; for i in ap_killers do
6487: LD_ADDR_VAR 0 2
6491: PUSH
6492: LD_EXP 27
6496: PUSH
6497: FOR_IN
6498: IFFALSE 6568
// begin if not IsOk ( i ) then
6500: LD_VAR 0 2
6504: PPUSH
6505: CALL_OW 302
6509: NOT
6510: IFFALSE 6514
// continue ;
6512: GO 6497
// if not HasTask ( i ) then
6514: LD_VAR 0 2
6518: PPUSH
6519: CALL_OW 314
6523: NOT
6524: IFFALSE 6546
// target := NearestUnitToUnit ( filter , i ) ;
6526: LD_ADDR_VAR 0 3
6530: PUSH
6531: LD_VAR 0 1
6535: PPUSH
6536: LD_VAR 0 2
6540: PPUSH
6541: CALL_OW 74
6545: ST_TO_ADDR
// if target then
6546: LD_VAR 0 3
6550: IFFALSE 6566
// ComAttackUnit ( i , target ) ;
6552: LD_VAR 0 2
6556: PPUSH
6557: LD_VAR 0 3
6561: PPUSH
6562: CALL_OW 115
// end ;
6566: GO 6497
6568: POP
6569: POP
// end ; end_of_file
6570: PPOPN 3
6572: END
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
6573: LD_EXP 6
6577: IFFALSE 6709
6579: GO 6581
6581: DISABLE
6582: LD_INT 0
6584: PPUSH
6585: PPUSH
6586: PPUSH
// begin counter := [ 500 , 400 , 300 ] [ Difficulty ] ;
6587: LD_ADDR_VAR 0 2
6591: PUSH
6592: LD_INT 500
6594: PUSH
6595: LD_INT 400
6597: PUSH
6598: LD_INT 300
6600: PUSH
6601: EMPTY
6602: LIST
6603: LIST
6604: LIST
6605: PUSH
6606: LD_OWVAR 67
6610: ARRAY
6611: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
6612: LD_INT 1
6614: PPUSH
6615: LD_INT 3
6617: PPUSH
6618: CALL_OW 12
6622: PPUSH
6623: LD_INT 7
6625: PPUSH
6626: LD_INT 1
6628: PPUSH
6629: CALL_OW 55
// repeat wait ( rand ( 1 1$30 , 2 2$20 ) ) ;
6633: LD_INT 3150
6635: PPUSH
6636: LD_INT 4900
6638: PPUSH
6639: CALL_OW 12
6643: PPUSH
6644: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
6648: LD_ADDR_VAR 0 3
6652: PUSH
6653: LD_INT 1
6655: PPUSH
6656: LD_INT 5
6658: PPUSH
6659: CALL_OW 12
6663: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
6664: LD_VAR 0 3
6668: PPUSH
6669: LD_INT 7
6671: PPUSH
6672: LD_INT 1
6674: PPUSH
6675: CALL_OW 55
// counter := counter - cr * 10 ;
6679: LD_ADDR_VAR 0 2
6683: PUSH
6684: LD_VAR 0 2
6688: PUSH
6689: LD_VAR 0 3
6693: PUSH
6694: LD_INT 10
6696: MUL
6697: MINUS
6698: ST_TO_ADDR
// until counter <= 0 ;
6699: LD_VAR 0 2
6703: PUSH
6704: LD_INT 0
6706: LESSEQUAL
6707: IFFALSE 6633
// end ;
6709: PPOPN 3
6711: END
// every 0 0$03 trigger not Delta do var i ;
6712: LD_EXP 6
6716: NOT
6717: IFFALSE 6787
6719: GO 6721
6721: DISABLE
6722: LD_INT 0
6724: PPUSH
// begin for i = 1 to 4 - Difficulty do
6725: LD_ADDR_VAR 0 1
6729: PUSH
6730: DOUBLE
6731: LD_INT 1
6733: DEC
6734: ST_TO_ADDR
6735: LD_INT 4
6737: PUSH
6738: LD_OWVAR 67
6742: MINUS
6743: PUSH
6744: FOR_TO
6745: IFFALSE 6785
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
6747: LD_INT 2
6749: PPUSH
6750: LD_INT 5
6752: PPUSH
6753: CALL_OW 12
6757: PPUSH
6758: LD_INT 8
6760: PPUSH
6761: LD_INT 1
6763: PPUSH
6764: CALL_OW 55
// Wait ( rand ( 0 0$16 , 0 0$39 ) ) ;
6768: LD_INT 560
6770: PPUSH
6771: LD_INT 1365
6773: PPUSH
6774: CALL_OW 12
6778: PPUSH
6779: CALL_OW 67
// end ;
6783: GO 6744
6785: POP
6786: POP
// end ;
6787: PPOPN 1
6789: END
// every 2 2$00 trigger tick < 15 15$00 do
6790: LD_OWVAR 1
6794: PUSH
6795: LD_INT 31500
6797: LESS
6798: IFFALSE 6858
6800: GO 6802
6802: DISABLE
// begin enable ;
6803: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
6804: LD_INT 1
6806: PPUSH
6807: LD_INT 3
6809: PPUSH
6810: CALL_OW 12
6814: PPUSH
6815: LD_INT 1
6817: PPUSH
6818: CALL_OW 57
// Wait ( rand ( 0 0$38 , 0 0$59 ) ) ;
6822: LD_INT 1330
6824: PPUSH
6825: LD_INT 2065
6827: PPUSH
6828: CALL_OW 12
6832: PPUSH
6833: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 4 ) , riverArea , true ) ;
6837: LD_INT 1
6839: PPUSH
6840: LD_INT 4
6842: PPUSH
6843: CALL_OW 12
6847: PPUSH
6848: LD_INT 15
6850: PPUSH
6851: LD_INT 1
6853: PPUSH
6854: CALL_OW 55
// end ; end_of_file
6858: END
// on UnitDestroyed ( un ) do begin if un = JMM then
6859: LD_VAR 0 1
6863: PUSH
6864: LD_EXP 15
6868: EQUAL
6869: IFFALSE 6878
// YouLost ( JMM ) ;
6871: LD_STRING JMM
6873: PPUSH
6874: CALL_OW 104
// if un = Delta then
6878: LD_VAR 0 1
6882: PUSH
6883: LD_EXP 6
6887: EQUAL
6888: IFFALSE 6898
// Delta := 0 ;
6890: LD_ADDR_EXP 6
6894: PUSH
6895: LD_INT 0
6897: ST_TO_ADDR
// if un in ar_forces then
6898: LD_VAR 0 1
6902: PUSH
6903: LD_EXP 26
6907: IN
6908: IFFALSE 6926
// ar_forces := ar_forces diff un ;
6910: LD_ADDR_EXP 26
6914: PUSH
6915: LD_EXP 26
6919: PUSH
6920: LD_VAR 0 1
6924: DIFF
6925: ST_TO_ADDR
// if un in ap_killers then
6926: LD_VAR 0 1
6930: PUSH
6931: LD_EXP 27
6935: IN
6936: IFFALSE 6954
// ap_killers := ap_killers diff un ;
6938: LD_ADDR_EXP 27
6942: PUSH
6943: LD_EXP 27
6947: PUSH
6948: LD_VAR 0 1
6952: DIFF
6953: ST_TO_ADDR
// end ;
6954: PPOPN 1
6956: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
6957: LD_VAR 0 1
6961: PUSH
6962: LD_INT 1
6964: EQUAL
6965: PUSH
6966: LD_VAR 0 2
6970: PUSH
6971: LD_INT 2
6973: EQUAL
6974: AND
6975: PUSH
6976: LD_EXP 13
6980: NOT
6981: AND
6982: IFFALSE 6992
// arab_spotted := true ;
6984: LD_ADDR_EXP 13
6988: PUSH
6989: LD_INT 1
6991: ST_TO_ADDR
6992: PPOPN 2
6994: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
6995: LD_ADDR_OWVAR 57
6999: PUSH
7000: LD_INT 0
7002: ST_TO_ADDR
// end_mission := true ;
7003: LD_ADDR_EXP 14
7007: PUSH
7008: LD_INT 1
7010: ST_TO_ADDR
// end ;
7011: PPOPN 1
7013: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
7014: LD_VAR 0 2
7018: PPUSH
7019: CALL_OW 255
7023: PUSH
7024: LD_INT 1
7026: EQUAL
7027: IFFALSE 7043
// apeman_counter := apeman_counter + 1 ;
7029: LD_ADDR_EXP 12
7033: PUSH
7034: LD_EXP 12
7038: PUSH
7039: LD_INT 1
7041: PLUS
7042: ST_TO_ADDR
// if not first_apeman_tamed then
7043: LD_EXP 8
7047: NOT
7048: IFFALSE 7248
// begin first_apeman_tamed := true ;
7050: LD_ADDR_EXP 8
7054: PUSH
7055: LD_INT 1
7057: ST_TO_ADDR
// if sci = Gladstone then
7058: LD_VAR 0 2
7062: PUSH
7063: LD_EXP 16
7067: EQUAL
7068: IFFALSE 7082
// Say ( Gladstone , D7b-Glad-1 ) ;
7070: LD_EXP 16
7074: PPUSH
7075: LD_STRING D7b-Glad-1
7077: PPUSH
7078: CALL_OW 88
// if sci = Denis then
7082: LD_VAR 0 2
7086: PUSH
7087: LD_EXP 18
7091: EQUAL
7092: IFFALSE 7106
// Say ( Denis , D7a-Den-1 ) ;
7094: LD_EXP 18
7098: PPUSH
7099: LD_STRING D7a-Den-1
7101: PPUSH
7102: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
7106: LD_VAR 0 2
7110: PUSH
7111: LD_EXP 15
7115: PUSH
7116: LD_EXP 16
7120: PUSH
7121: LD_EXP 18
7125: PUSH
7126: LD_EXP 21
7130: PUSH
7131: LD_EXP 22
7135: PUSH
7136: LD_EXP 23
7140: PUSH
7141: LD_EXP 24
7145: PUSH
7146: LD_EXP 20
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: LIST
7155: LIST
7156: LIST
7157: LIST
7158: LIST
7159: LIST
7160: IN
7161: NOT
7162: IFFALSE 7205
// begin if GetSex ( sci ) = sex_male then
7164: LD_VAR 0 2
7168: PPUSH
7169: CALL_OW 258
7173: PUSH
7174: LD_INT 1
7176: EQUAL
7177: IFFALSE 7193
// Say ( sci , D7c-Sci1-1 ) else
7179: LD_VAR 0 2
7183: PPUSH
7184: LD_STRING D7c-Sci1-1
7186: PPUSH
7187: CALL_OW 88
7191: GO 7205
// Say ( sci , D7c-FSci1-1 ) ;
7193: LD_VAR 0 2
7197: PPUSH
7198: LD_STRING D7c-FSci1-1
7200: PPUSH
7201: CALL_OW 88
// end ; if not sci = Gladstone then
7205: LD_VAR 0 2
7209: PUSH
7210: LD_EXP 16
7214: EQUAL
7215: NOT
7216: IFFALSE 7230
// Say ( Gladstone , D7c-Glad-1 ) ;
7218: LD_EXP 16
7222: PPUSH
7223: LD_STRING D7c-Glad-1
7225: PPUSH
7226: CALL_OW 88
// if Lisa then
7230: LD_EXP 21
7234: IFFALSE 7248
// Say ( Lisa , D8-Lisa-1 ) ;
7236: LD_EXP 21
7240: PPUSH
7241: LD_STRING D8-Lisa-1
7243: PPUSH
7244: CALL_OW 88
// end ; end ;
7248: PPOPN 2
7250: END
