// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 72 0 0
// InitRestrictions ;
  12: CALL 176 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 26
// DebugMode ;
  22: CALL 257 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  26: LD_INT 12
  28: PPUSH
  29: LD_INT 2
  31: PPUSH
  32: CALL 505 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 6 ] [ Difficulty ] ) ;
  36: LD_INT 11
  38: PPUSH
  39: LD_INT 10
  41: PUSH
  42: LD_INT 8
  44: PUSH
  45: LD_INT 6
  47: PUSH
  48: EMPTY
  49: LIST
  50: LIST
  51: LIST
  52: PUSH
  53: LD_OWVAR 67
  57: ARRAY
  58: PPUSH
  59: CALL 505 0 2
// PrepareAmericans ;
  63: CALL 1052 0 0
// Action ;
  67: CALL 1950 0 0
// end ;
  71: END
// export debug ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed , apeman_army , radar_researched , radar_builded ; export apeman_counter , arab_spotted , end_mission ; function Init ; begin
  72: LD_INT 0
  74: PPUSH
// debug := false ;
  75: LD_ADDR_EXP 1
  79: PUSH
  80: LD_INT 0
  82: ST_TO_ADDR
// deltaBuilded := false ;
  83: LD_ADDR_EXP 2
  87: PUSH
  88: LD_INT 0
  90: ST_TO_ADDR
// denisArrives := false ;
  91: LD_ADDR_EXP 3
  95: PUSH
  96: LD_INT 0
  98: ST_TO_ADDR
// radar_allowed := false ;
  99: LD_ADDR_EXP 5
 103: PUSH
 104: LD_INT 0
 106: ST_TO_ADDR
// first_apeman_tamed := false ;
 107: LD_ADDR_EXP 6
 111: PUSH
 112: LD_INT 0
 114: ST_TO_ADDR
// arab_spotted := false ;
 115: LD_ADDR_EXP 11
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// end_mission := false ;
 123: LD_ADDR_EXP 12
 127: PUSH
 128: LD_INT 0
 130: ST_TO_ADDR
// apeman_army := false ;
 131: LD_ADDR_EXP 7
 135: PUSH
 136: LD_INT 0
 138: ST_TO_ADDR
// radar_researched := false ;
 139: LD_ADDR_EXP 8
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// radar_builded := false ;
 147: LD_ADDR_EXP 9
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// apeman_counter := 0 ;
 155: LD_ADDR_EXP 10
 159: PUSH
 160: LD_INT 0
 162: ST_TO_ADDR
// Delta := 0 ;
 163: LD_ADDR_EXP 4
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// end ;
 171: LD_VAR 0 1
 175: RET
// function InitRestrictions ; begin
 176: LD_INT 0
 178: PPUSH
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
 179: LD_INT 7
 181: PPUSH
 182: LD_INT 1
 184: PPUSH
 185: LD_INT 1
 187: PPUSH
 188: CALL_OW 324
// SetRestrict ( b_lab_full , 1 , state_enabled ) ;
 192: LD_INT 8
 194: PPUSH
 195: LD_INT 1
 197: PPUSH
 198: LD_INT 1
 200: PPUSH
 201: CALL_OW 324
// SetRestrict ( b_lab_weapon , 1 , state_enabled ) ;
 205: LD_INT 10
 207: PPUSH
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 1
 213: PPUSH
 214: CALL_OW 324
// SetTech ( tech_gatling , 1 , LoadVariable ( GatlingInGamma , 1 ) ) ;
 218: LD_INT 69
 220: PPUSH
 221: LD_INT 1
 223: PPUSH
 224: LD_STRING GatlingInGamma
 226: PPUSH
 227: LD_INT 1
 229: PPUSH
 230: CALL_OW 30
 234: PPUSH
 235: CALL_OW 322
// SetTech ( tech_weap1 , 1 , state_enabled ) ;
 239: LD_INT 51
 241: PPUSH
 242: LD_INT 1
 244: PPUSH
 245: LD_INT 1
 247: PPUSH
 248: CALL_OW 322
// end ;
 252: LD_VAR 0 1
 256: RET
// function DebugMode ; begin
 257: LD_INT 0
 259: PPUSH
// FogOff ( 1 ) ;
 260: LD_INT 1
 262: PPUSH
 263: CALL_OW 344
// Difficulty := 2 ;
 267: LD_ADDR_OWVAR 67
 271: PUSH
 272: LD_INT 2
 274: ST_TO_ADDR
// end ; end_of_file
 275: LD_VAR 0 1
 279: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 280: LD_INT 0
 282: PPUSH
 283: PPUSH
// if exist_mode then
 284: LD_VAR 0 2
 288: IFFALSE 307
// unit := CreateCharacter ( ident ) else
 290: LD_ADDR_VAR 0 4
 294: PUSH
 295: LD_VAR 0 1
 299: PPUSH
 300: CALL_OW 34
 304: ST_TO_ADDR
 305: GO 322
// unit := NewCharacter ( ident ) ;
 307: LD_ADDR_VAR 0 4
 311: PUSH
 312: LD_VAR 0 1
 316: PPUSH
 317: CALL_OW 25
 321: ST_TO_ADDR
// result := unit ;
 322: LD_ADDR_VAR 0 3
 326: PUSH
 327: LD_VAR 0 4
 331: ST_TO_ADDR
// end ;
 332: LD_VAR 0 3
 336: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 337: LD_INT 0
 339: PPUSH
// uc_side := side ;
 340: LD_ADDR_OWVAR 20
 344: PUSH
 345: LD_VAR 0 1
 349: ST_TO_ADDR
// uc_nation := nation ;
 350: LD_ADDR_OWVAR 21
 354: PUSH
 355: LD_VAR 0 2
 359: ST_TO_ADDR
// vc_chassis := chassis ;
 360: LD_ADDR_OWVAR 37
 364: PUSH
 365: LD_VAR 0 3
 369: ST_TO_ADDR
// vc_engine := engine ;
 370: LD_ADDR_OWVAR 39
 374: PUSH
 375: LD_VAR 0 4
 379: ST_TO_ADDR
// vc_control := control ;
 380: LD_ADDR_OWVAR 38
 384: PUSH
 385: LD_VAR 0 5
 389: ST_TO_ADDR
// vc_weapon := weapon ;
 390: LD_ADDR_OWVAR 40
 394: PUSH
 395: LD_VAR 0 6
 399: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 400: LD_ADDR_OWVAR 41
 404: PUSH
 405: LD_VAR 0 7
 409: ST_TO_ADDR
// result := CreateVehicle ;
 410: LD_ADDR_VAR 0 8
 414: PUSH
 415: CALL_OW 45
 419: ST_TO_ADDR
// end ;
 420: LD_VAR 0 8
 424: RET
// export function SayX ( units , ident ) ; var i ; begin
 425: LD_INT 0
 427: PPUSH
 428: PPUSH
// result := false ;
 429: LD_ADDR_VAR 0 3
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// if not units then
 437: LD_VAR 0 1
 441: NOT
 442: IFFALSE 446
// exit ;
 444: GO 500
// for i in units do
 446: LD_ADDR_VAR 0 4
 450: PUSH
 451: LD_VAR 0 1
 455: PUSH
 456: FOR_IN
 457: IFFALSE 498
// if IsOk ( i ) then
 459: LD_VAR 0 4
 463: PPUSH
 464: CALL_OW 302
 468: IFFALSE 496
// begin Say ( i , ident ) ;
 470: LD_VAR 0 4
 474: PPUSH
 475: LD_VAR 0 2
 479: PPUSH
 480: CALL_OW 88
// result := i ;
 484: LD_ADDR_VAR 0 3
 488: PUSH
 489: LD_VAR 0 4
 493: ST_TO_ADDR
// break ;
 494: GO 498
// end ;
 496: GO 456
 498: POP
 499: POP
// end ;
 500: LD_VAR 0 3
 504: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 505: LD_INT 0
 507: PPUSH
 508: PPUSH
// InitUc ;
 509: CALL_OW 18
// InitHc ;
 513: CALL_OW 19
// uc_side := 0 ;
 517: LD_ADDR_OWVAR 20
 521: PUSH
 522: LD_INT 0
 524: ST_TO_ADDR
// uc_nation := 0 ;
 525: LD_ADDR_OWVAR 21
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// for i = 1 to amount do
 533: LD_ADDR_VAR 0 4
 537: PUSH
 538: DOUBLE
 539: LD_INT 1
 541: DEC
 542: ST_TO_ADDR
 543: LD_VAR 0 2
 547: PUSH
 548: FOR_TO
 549: IFFALSE 583
// begin PrepareHuman ( false , class_apeman , 1 ) ;
 551: LD_INT 0
 553: PPUSH
 554: LD_INT 12
 556: PPUSH
 557: LD_INT 1
 559: PPUSH
 560: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 564: CALL_OW 44
 568: PPUSH
 569: LD_VAR 0 1
 573: PPUSH
 574: LD_INT 0
 576: PPUSH
 577: CALL_OW 49
// end ;
 581: GO 548
 583: POP
 584: POP
// end ;
 585: LD_VAR 0 3
 589: RET
// export function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
 590: LD_INT 0
 592: PPUSH
 593: PPUSH
 594: PPUSH
// if not unit then
 595: LD_VAR 0 1
 599: NOT
 600: IFFALSE 604
// exit ;
 602: GO 1047
// if IsInUnit ( unit ) then
 604: LD_VAR 0 1
 608: PPUSH
 609: CALL_OW 310
 613: IFFALSE 630
// unit := IsDrivenBy ( unit ) ;
 615: LD_ADDR_VAR 0 1
 619: PUSH
 620: LD_VAR 0 1
 624: PPUSH
 625: CALL_OW 311
 629: ST_TO_ADDR
// targets_list := [ ] ;
 630: LD_ADDR_VAR 0 5
 634: PUSH
 635: EMPTY
 636: ST_TO_ADDR
// target := UnitFilter ( enemy_list , [ [ f_lives , 250 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 637: LD_ADDR_VAR 0 4
 641: PUSH
 642: LD_VAR 0 2
 646: PPUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 250
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: PUSH
 657: LD_INT 3
 659: PUSH
 660: LD_INT 34
 662: PUSH
 663: LD_INT 12
 665: PUSH
 666: EMPTY
 667: LIST
 668: LIST
 669: PUSH
 670: EMPTY
 671: LIST
 672: LIST
 673: PUSH
 674: LD_INT 21
 676: PUSH
 677: LD_INT 2
 679: PUSH
 680: EMPTY
 681: LIST
 682: LIST
 683: PUSH
 684: LD_INT 58
 686: PUSH
 687: EMPTY
 688: LIST
 689: PUSH
 690: EMPTY
 691: LIST
 692: LIST
 693: LIST
 694: LIST
 695: PPUSH
 696: CALL_OW 72
 700: ST_TO_ADDR
// if GetDistUnits ( NearestUnitToUnit ( target , unit ) , unit ) < 11 and not IsInUnit ( unit ) then
 701: LD_VAR 0 4
 705: PPUSH
 706: LD_VAR 0 1
 710: PPUSH
 711: CALL_OW 74
 715: PPUSH
 716: LD_VAR 0 1
 720: PPUSH
 721: CALL_OW 296
 725: PUSH
 726: LD_INT 11
 728: LESS
 729: PUSH
 730: LD_VAR 0 1
 734: PPUSH
 735: CALL_OW 310
 739: NOT
 740: AND
 741: IFFALSE 769
// begin ComEnterUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 743: LD_VAR 0 1
 747: PPUSH
 748: LD_VAR 0 4
 752: PPUSH
 753: LD_VAR 0 1
 757: PPUSH
 758: CALL_OW 74
 762: PPUSH
 763: CALL_OW 120
// exit ;
 767: GO 1047
// end ; targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
 769: LD_ADDR_VAR 0 5
 773: PUSH
 774: LD_VAR 0 2
 778: PPUSH
 779: LD_INT 21
 781: PUSH
 782: LD_INT 1
 784: PUSH
 785: EMPTY
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 3
 791: PUSH
 792: LD_INT 54
 794: PUSH
 795: EMPTY
 796: LIST
 797: PUSH
 798: EMPTY
 799: LIST
 800: LIST
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: PPUSH
 806: CALL_OW 72
 810: PUSH
 811: LD_VAR 0 2
 815: PPUSH
 816: LD_INT 21
 818: PUSH
 819: LD_INT 2
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: PPUSH
 826: CALL_OW 72
 830: PUSH
 831: LD_VAR 0 2
 835: PPUSH
 836: LD_INT 21
 838: PUSH
 839: LD_INT 3
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 58
 851: PUSH
 852: EMPTY
 853: LIST
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL_OW 72
 867: PUSH
 868: LD_VAR 0 2
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: ST_TO_ADDR
// for target in targets_list do
 879: LD_ADDR_VAR 0 4
 883: PUSH
 884: LD_VAR 0 5
 888: PUSH
 889: FOR_IN
 890: IFFALSE 1045
// begin if target then
 892: LD_VAR 0 4
 896: IFFALSE 1043
// if GetTag ( unit ) = 11 and ( GetType ( NearestUnitToUnit ( target , unit ) ) = unit_building or GetWeapon ( NearestUnitToUnit ( target , unit ) ) = us_cargo_bay ) then
 898: LD_VAR 0 1
 902: PPUSH
 903: CALL_OW 110
 907: PUSH
 908: LD_INT 11
 910: EQUAL
 911: PUSH
 912: LD_VAR 0 4
 916: PPUSH
 917: LD_VAR 0 1
 921: PPUSH
 922: CALL_OW 74
 926: PPUSH
 927: CALL_OW 247
 931: PUSH
 932: LD_INT 3
 934: EQUAL
 935: PUSH
 936: LD_VAR 0 4
 940: PPUSH
 941: LD_VAR 0 1
 945: PPUSH
 946: CALL_OW 74
 950: PPUSH
 951: CALL_OW 264
 955: PUSH
 956: LD_INT 12
 958: EQUAL
 959: OR
 960: AND
 961: IFFALSE 1007
// begin ComPlaceDelayedCharge ( unit , 0 , 0 , NearestUnitToUnit ( target , unit ) ) ;
 963: LD_VAR 0 1
 967: PPUSH
 968: LD_INT 0
 970: PPUSH
 971: LD_INT 0
 973: PPUSH
 974: LD_VAR 0 4
 978: PPUSH
 979: LD_VAR 0 1
 983: PPUSH
 984: CALL_OW 74
 988: PPUSH
 989: CALL_OW 132
// SetTag ( unit , 0 ) ;
 993: LD_VAR 0 1
 997: PPUSH
 998: LD_INT 0
1000: PPUSH
1001: CALL_OW 109
// end else
1005: GO 1043
// if not HasTask ( unit ) then
1007: LD_VAR 0 1
1011: PPUSH
1012: CALL_OW 314
1016: NOT
1017: IFFALSE 1043
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
1019: LD_VAR 0 1
1023: PPUSH
1024: LD_VAR 0 4
1028: PPUSH
1029: LD_VAR 0 1
1033: PPUSH
1034: CALL_OW 74
1038: PPUSH
1039: CALL_OW 115
// end ;
1043: GO 889
1045: POP
1046: POP
// end ; end_of_file
1047: LD_VAR 0 3
1051: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
1052: LD_INT 0
1054: PPUSH
1055: PPUSH
1056: PPUSH
1057: PPUSH
1058: PPUSH
// uc_nation := 1 ;
1059: LD_ADDR_OWVAR 21
1063: PUSH
1064: LD_INT 1
1066: ST_TO_ADDR
// uc_side := 4 ;
1067: LD_ADDR_OWVAR 20
1071: PUSH
1072: LD_INT 4
1074: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
1075: LD_ADDR_EXP 16
1079: PUSH
1080: LD_STRING Denis
1082: PPUSH
1083: LD_INT 0
1085: PPUSH
1086: CALL 280 0 2
1090: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
1091: LD_ADDR_EXP 15
1095: PUSH
1096: LD_STRING Harisson
1098: PPUSH
1099: LD_INT 0
1101: PPUSH
1102: CALL 280 0 2
1106: ST_TO_ADDR
// uc_side := 1 ;
1107: LD_ADDR_OWVAR 20
1111: PUSH
1112: LD_INT 1
1114: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1115: LD_ADDR_EXP 13
1119: PUSH
1120: LD_STRING JMM
1122: PPUSH
1123: LD_EXP 1
1127: NOT
1128: PPUSH
1129: CALL 280 0 2
1133: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
1134: LD_ADDR_EXP 14
1138: PUSH
1139: LD_STRING Gladstone
1141: PPUSH
1142: LD_INT 0
1144: PPUSH
1145: CALL 280 0 2
1149: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
1150: LD_STRING BrownInDelta
1152: PPUSH
1153: LD_EXP 1
1157: PPUSH
1158: CALL_OW 30
1162: IFFALSE 1199
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1164: LD_ADDR_EXP 17
1168: PUSH
1169: LD_STRING Brown
1171: PPUSH
1172: LD_EXP 1
1176: NOT
1177: PPUSH
1178: CALL 280 0 2
1182: ST_TO_ADDR
// tmp := tmp ^ Brown ;
1183: LD_ADDR_VAR 0 5
1187: PUSH
1188: LD_VAR 0 5
1192: PUSH
1193: LD_EXP 17
1197: ADD
1198: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , 0 ) then
1199: LD_STRING DonaldsonInDelta
1201: PPUSH
1202: LD_INT 0
1204: PPUSH
1205: CALL_OW 30
1209: IFFALSE 1246
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1211: LD_ADDR_EXP 18
1215: PUSH
1216: LD_STRING Donaldson
1218: PPUSH
1219: LD_EXP 1
1223: NOT
1224: PPUSH
1225: CALL 280 0 2
1229: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
1230: LD_ADDR_VAR 0 5
1234: PUSH
1235: LD_VAR 0 5
1239: PUSH
1240: LD_EXP 18
1244: ADD
1245: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
1246: LD_STRING LisaInDelta
1248: PPUSH
1249: LD_EXP 1
1253: PPUSH
1254: CALL_OW 30
1258: IFFALSE 1295
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1260: LD_ADDR_EXP 19
1264: PUSH
1265: LD_STRING Lisa
1267: PPUSH
1268: LD_EXP 1
1272: NOT
1273: PPUSH
1274: CALL 280 0 2
1278: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
1279: LD_ADDR_VAR 0 5
1283: PUSH
1284: LD_VAR 0 5
1288: PUSH
1289: LD_EXP 19
1293: ADD
1294: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
1295: LD_STRING FrankInDelta
1297: PPUSH
1298: LD_EXP 1
1302: PPUSH
1303: CALL_OW 30
1307: IFFALSE 1344
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
1309: LD_ADDR_EXP 20
1313: PUSH
1314: LD_STRING Frank
1316: PPUSH
1317: LD_EXP 1
1321: NOT
1322: PPUSH
1323: CALL 280 0 2
1327: ST_TO_ADDR
// tmp := tmp ^ Frank ;
1328: LD_ADDR_VAR 0 5
1332: PUSH
1333: LD_VAR 0 5
1337: PUSH
1338: LD_EXP 20
1342: ADD
1343: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
1344: LD_STRING BobbyInDelta
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL_OW 30
1354: IFFALSE 1391
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1356: LD_ADDR_EXP 21
1360: PUSH
1361: LD_STRING Bobby
1363: PPUSH
1364: LD_EXP 1
1368: NOT
1369: PPUSH
1370: CALL 280 0 2
1374: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
1375: LD_ADDR_VAR 0 5
1379: PUSH
1380: LD_VAR 0 5
1384: PUSH
1385: LD_EXP 21
1389: ADD
1390: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
1391: LD_STRING CyrusInDelta
1393: PPUSH
1394: LD_INT 0
1396: PPUSH
1397: CALL_OW 30
1401: IFFALSE 1438
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1403: LD_ADDR_EXP 22
1407: PUSH
1408: LD_STRING Cyrus
1410: PPUSH
1411: LD_EXP 1
1415: NOT
1416: PPUSH
1417: CALL 280 0 2
1421: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
1422: LD_ADDR_VAR 0 5
1426: PUSH
1427: LD_VAR 0 5
1431: PUSH
1432: LD_EXP 22
1436: ADD
1437: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
1438: LD_ADDR_EXP 23
1442: PUSH
1443: LD_STRING othersDelta
1445: PPUSH
1446: CALL_OW 31
1450: ST_TO_ADDR
// if not others and debug then
1451: LD_EXP 23
1455: NOT
1456: PUSH
1457: LD_EXP 1
1461: AND
1462: IFFALSE 1527
// begin InitHc ;
1464: CALL_OW 19
// for i = 1 to 2 do
1468: LD_ADDR_VAR 0 2
1472: PUSH
1473: DOUBLE
1474: LD_INT 1
1476: DEC
1477: ST_TO_ADDR
1478: LD_INT 2
1480: PUSH
1481: FOR_TO
1482: IFFALSE 1525
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
1484: LD_INT 0
1486: PPUSH
1487: LD_VAR 0 2
1491: PUSH
1492: LD_INT 4
1494: MOD
1495: PUSH
1496: LD_INT 1
1498: PLUS
1499: PPUSH
1500: LD_INT 3
1502: PPUSH
1503: CALL_OW 380
// others := others ^ CreateHuman ;
1507: LD_ADDR_EXP 23
1511: PUSH
1512: LD_EXP 23
1516: PUSH
1517: CALL_OW 44
1521: ADD
1522: ST_TO_ADDR
// end ;
1523: GO 1481
1525: POP
1526: POP
// end ; if others then
1527: LD_EXP 23
1531: IFFALSE 1549
// tmp := tmp ^ others ;
1533: LD_ADDR_VAR 0 5
1537: PUSH
1538: LD_VAR 0 5
1542: PUSH
1543: LD_EXP 23
1547: ADD
1548: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
1549: LD_ADDR_VAR 0 3
1553: PUSH
1554: LD_INT 28
1556: PUSH
1557: LD_INT 49
1559: PUSH
1560: EMPTY
1561: LIST
1562: LIST
1563: PUSH
1564: LD_INT 33
1566: PUSH
1567: LD_INT 54
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: PUSH
1574: LD_INT 38
1576: PUSH
1577: LD_INT 56
1579: PUSH
1580: EMPTY
1581: LIST
1582: LIST
1583: PUSH
1584: EMPTY
1585: LIST
1586: LIST
1587: LIST
1588: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1589: LD_ADDR_VAR 0 4
1593: PUSH
1594: LD_INT 1
1596: PPUSH
1597: LD_INT 1
1599: PPUSH
1600: LD_INT 2
1602: PPUSH
1603: LD_INT 2
1605: PPUSH
1606: LD_INT 1
1608: PPUSH
1609: LD_INT 12
1611: PPUSH
1612: LD_INT 80
1614: PPUSH
1615: CALL 337 0 7
1619: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1620: LD_VAR 0 4
1624: PPUSH
1625: LD_INT 1
1627: PPUSH
1628: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1632: LD_VAR 0 4
1636: PPUSH
1637: LD_VAR 0 3
1641: PUSH
1642: LD_INT 1
1644: ARRAY
1645: PUSH
1646: LD_INT 1
1648: ARRAY
1649: PPUSH
1650: LD_VAR 0 3
1654: PUSH
1655: LD_INT 1
1657: ARRAY
1658: PUSH
1659: LD_INT 2
1661: ARRAY
1662: PPUSH
1663: LD_INT 0
1665: PPUSH
1666: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1670: LD_VAR 0 4
1674: PPUSH
1675: LD_INT 1
1677: PPUSH
1678: LD_INT 100
1680: PPUSH
1681: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1685: LD_EXP 23
1689: PUSH
1690: LD_INT 1
1692: ARRAY
1693: PPUSH
1694: LD_VAR 0 4
1698: PPUSH
1699: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1703: LD_ADDR_VAR 0 4
1707: PUSH
1708: LD_INT 1
1710: PPUSH
1711: LD_INT 1
1713: PPUSH
1714: LD_INT 1
1716: PPUSH
1717: LD_INT 2
1719: PPUSH
1720: LD_INT 1
1722: PPUSH
1723: LD_INT 2
1725: PPUSH
1726: LD_INT 80
1728: PPUSH
1729: CALL 337 0 7
1733: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1734: LD_VAR 0 4
1738: PPUSH
1739: LD_INT 1
1741: PPUSH
1742: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1746: LD_VAR 0 4
1750: PPUSH
1751: LD_VAR 0 3
1755: PUSH
1756: LD_INT 2
1758: ARRAY
1759: PUSH
1760: LD_INT 1
1762: ARRAY
1763: PPUSH
1764: LD_VAR 0 3
1768: PUSH
1769: LD_INT 2
1771: ARRAY
1772: PUSH
1773: LD_INT 2
1775: ARRAY
1776: PPUSH
1777: LD_INT 0
1779: PPUSH
1780: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1784: LD_EXP 14
1788: PPUSH
1789: LD_VAR 0 4
1793: PPUSH
1794: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
1798: LD_ADDR_VAR 0 4
1802: PUSH
1803: LD_INT 1
1805: PPUSH
1806: LD_INT 1
1808: PPUSH
1809: LD_INT 1
1811: PPUSH
1812: LD_INT 2
1814: PPUSH
1815: LD_INT 1
1817: PPUSH
1818: LD_INT 3
1820: PPUSH
1821: LD_INT 80
1823: PPUSH
1824: CALL 337 0 7
1828: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1829: LD_VAR 0 4
1833: PPUSH
1834: LD_INT 1
1836: PPUSH
1837: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
1841: LD_VAR 0 4
1845: PPUSH
1846: LD_VAR 0 3
1850: PUSH
1851: LD_INT 3
1853: ARRAY
1854: PUSH
1855: LD_INT 1
1857: ARRAY
1858: PPUSH
1859: LD_VAR 0 3
1863: PUSH
1864: LD_INT 3
1866: ARRAY
1867: PUSH
1868: LD_INT 2
1870: ARRAY
1871: PPUSH
1872: LD_INT 0
1874: PPUSH
1875: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1879: LD_EXP 13
1883: PPUSH
1884: LD_VAR 0 4
1888: PPUSH
1889: CALL_OW 52
// if others > 1 then
1893: LD_EXP 23
1897: PUSH
1898: LD_INT 1
1900: GREATER
1901: IFFALSE 1945
// for i in tmp diff others [ 1 ] do
1903: LD_ADDR_VAR 0 2
1907: PUSH
1908: LD_VAR 0 5
1912: PUSH
1913: LD_EXP 23
1917: PUSH
1918: LD_INT 1
1920: ARRAY
1921: DIFF
1922: PUSH
1923: FOR_IN
1924: IFFALSE 1943
// PlaceUnitArea ( i , startArea , false ) ;
1926: LD_VAR 0 2
1930: PPUSH
1931: LD_INT 5
1933: PPUSH
1934: LD_INT 0
1936: PPUSH
1937: CALL_OW 49
1941: GO 1923
1943: POP
1944: POP
// end ; end_of_file
1945: LD_VAR 0 1
1949: RET
// export function Action ; begin
1950: LD_INT 0
1952: PPUSH
// InGameOn ;
1953: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
1957: LD_INT 28
1959: PPUSH
1960: LD_INT 51
1962: PPUSH
1963: CALL_OW 86
// Wait ( 3 ) ;
1967: LD_INT 3
1969: PPUSH
1970: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
1974: LD_EXP 13
1978: PPUSH
1979: LD_STRING D1d-JMM-1a
1981: PPUSH
1982: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
1986: LD_EXP 15
1990: PPUSH
1991: LD_STRING D1d-Har-1
1993: PPUSH
1994: CALL_OW 94
// InGameOff ;
1998: CALL_OW 9
// SaveForQuickRestart ;
2002: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
2006: LD_STRING M1
2008: PPUSH
2009: CALL_OW 337
// Wait ( 0 0$2 ) ;
2013: LD_INT 70
2015: PPUSH
2016: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
2020: LD_EXP 13
2024: PPUSH
2025: LD_STRING D2-JMM-1
2027: PPUSH
2028: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
2032: LD_EXP 14
2036: PPUSH
2037: LD_STRING D2-Glad-1
2039: PPUSH
2040: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2044: LD_EXP 13
2048: PPUSH
2049: LD_STRING D2-JMM-2
2051: PPUSH
2052: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
2056: LD_EXP 14
2060: PPUSH
2061: LD_STRING D2-Glad-2
2063: PPUSH
2064: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2068: LD_EXP 13
2072: PPUSH
2073: LD_STRING D2-JMM-3
2075: PPUSH
2076: CALL_OW 88
// end ;
2080: LD_VAR 0 1
2084: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
2085: LD_INT 22
2087: PUSH
2088: LD_INT 1
2090: PUSH
2091: EMPTY
2092: LIST
2093: LIST
2094: PUSH
2095: LD_INT 3
2097: PUSH
2098: LD_INT 57
2100: PUSH
2101: EMPTY
2102: LIST
2103: PUSH
2104: EMPTY
2105: LIST
2106: LIST
2107: PUSH
2108: LD_INT 30
2110: PUSH
2111: LD_INT 0
2113: PUSH
2114: EMPTY
2115: LIST
2116: LIST
2117: PUSH
2118: EMPTY
2119: LIST
2120: LIST
2121: LIST
2122: PUSH
2123: EMPTY
2124: LIST
2125: PPUSH
2126: CALL_OW 69
2130: PUSH
2131: LD_EXP 2
2135: NOT
2136: AND
2137: IFFALSE 2150
2139: GO 2141
2141: DISABLE
// begin deltaBuilded := true ;
2142: LD_ADDR_EXP 2
2146: PUSH
2147: LD_INT 1
2149: ST_TO_ADDR
// end ;
2150: END
// every 0 0$01 trigger not Delta and deltaBuilded and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) do
2151: LD_EXP 4
2155: NOT
2156: PUSH
2157: LD_EXP 2
2161: AND
2162: PUSH
2163: LD_INT 22
2165: PUSH
2166: LD_INT 1
2168: PUSH
2169: EMPTY
2170: LIST
2171: LIST
2172: PUSH
2173: LD_INT 3
2175: PUSH
2176: LD_INT 57
2178: PUSH
2179: EMPTY
2180: LIST
2181: PUSH
2182: EMPTY
2183: LIST
2184: LIST
2185: PUSH
2186: LD_INT 30
2188: PUSH
2189: LD_INT 0
2191: PUSH
2192: EMPTY
2193: LIST
2194: LIST
2195: PUSH
2196: EMPTY
2197: LIST
2198: LIST
2199: LIST
2200: PUSH
2201: EMPTY
2202: LIST
2203: PPUSH
2204: CALL_OW 69
2208: AND
2209: IFFALSE 2282
2211: GO 2213
2213: DISABLE
// begin enable ;
2214: ENABLE
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
2215: LD_ADDR_EXP 4
2219: PUSH
2220: LD_INT 22
2222: PUSH
2223: LD_INT 1
2225: PUSH
2226: EMPTY
2227: LIST
2228: LIST
2229: PUSH
2230: LD_INT 3
2232: PUSH
2233: LD_INT 57
2235: PUSH
2236: EMPTY
2237: LIST
2238: PUSH
2239: EMPTY
2240: LIST
2241: LIST
2242: PUSH
2243: LD_INT 30
2245: PUSH
2246: LD_INT 0
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: PUSH
2253: EMPTY
2254: LIST
2255: LIST
2256: LIST
2257: PUSH
2258: EMPTY
2259: LIST
2260: PPUSH
2261: CALL_OW 69
2265: PUSH
2266: LD_INT 1
2268: ARRAY
2269: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
2270: LD_EXP 4
2274: PPUSH
2275: LD_STRING Delta
2277: PPUSH
2278: CALL_OW 500
// end ;
2282: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched do
2283: LD_INT 1
2285: PPUSH
2286: LD_INT 1
2288: PPUSH
2289: CALL_OW 321
2293: PUSH
2294: LD_INT 2
2296: EQUAL
2297: IFFALSE 2358
2299: GO 2301
2301: DISABLE
// begin DialogueOn ;
2302: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
2306: LD_EXP 14
2310: PPUSH
2311: LD_STRING D3-Glad-1
2313: PPUSH
2314: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2318: LD_EXP 13
2322: PPUSH
2323: LD_STRING D3-JMM-1
2325: PPUSH
2326: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
2330: LD_EXP 14
2334: PPUSH
2335: LD_STRING D3-Glad-2
2337: PPUSH
2338: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
2342: LD_EXP 13
2346: PPUSH
2347: LD_STRING D3-JMM-2
2349: PPUSH
2350: CALL_OW 88
// DialogueOff ;
2354: CALL_OW 7
// end ;
2358: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
2359: LD_INT 2
2361: PPUSH
2362: LD_INT 1
2364: PPUSH
2365: CALL_OW 321
2369: PUSH
2370: LD_INT 2
2372: EQUAL
2373: IFFALSE 2550
2375: GO 2377
2377: DISABLE
2378: LD_INT 0
2380: PPUSH
// begin DialogueOn ;
2381: CALL_OW 6
// if Frank then
2385: LD_EXP 20
2389: IFFALSE 2403
// Say ( Frank , D8a-Frank-1 ) ;
2391: LD_EXP 20
2395: PPUSH
2396: LD_STRING D8a-Frank-1
2398: PPUSH
2399: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
2403: LD_ADDR_VAR 0 1
2407: PUSH
2408: LD_EXP 23
2412: PPUSH
2413: LD_INT 26
2415: PUSH
2416: LD_INT 1
2418: PUSH
2419: EMPTY
2420: LIST
2421: LIST
2422: PPUSH
2423: CALL_OW 72
2427: PPUSH
2428: LD_STRING D8a-Sol1-1
2430: PPUSH
2431: CALL 425 0 2
2435: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2436: LD_EXP 16
2440: PUSH
2441: LD_EXP 16
2445: PPUSH
2446: CALL_OW 255
2450: PUSH
2451: LD_INT 1
2453: EQUAL
2454: AND
2455: IFFALSE 2469
// Say ( Denis , D8a-Den-1 ) ;
2457: LD_EXP 16
2461: PPUSH
2462: LD_STRING D8a-Den-1
2464: PPUSH
2465: CALL_OW 88
// if sol or Denis or Frank then
2469: LD_VAR 0 1
2473: PUSH
2474: LD_EXP 16
2478: OR
2479: PUSH
2480: LD_EXP 20
2484: OR
2485: IFFALSE 2546
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2487: LD_EXP 23
2491: PPUSH
2492: LD_INT 25
2494: PUSH
2495: LD_INT 4
2497: PUSH
2498: EMPTY
2499: LIST
2500: LIST
2501: PUSH
2502: LD_INT 26
2504: PUSH
2505: LD_INT 1
2507: PUSH
2508: EMPTY
2509: LIST
2510: LIST
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: PPUSH
2516: CALL_OW 72
2520: PUSH
2521: LD_VAR 0 1
2525: DIFF
2526: PPUSH
2527: LD_STRING D8a-Sci1-1
2529: PPUSH
2530: CALL 425 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2534: LD_EXP 13
2538: PPUSH
2539: LD_STRING D8a-JMM-1
2541: PPUSH
2542: CALL_OW 88
// end ; DialogueOff ;
2546: CALL_OW 7
// end ;
2550: PPOPN 1
2552: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2553: LD_INT 22
2555: PUSH
2556: LD_INT 1
2558: PUSH
2559: EMPTY
2560: LIST
2561: LIST
2562: PUSH
2563: LD_INT 25
2565: PUSH
2566: LD_INT 16
2568: PUSH
2569: EMPTY
2570: LIST
2571: LIST
2572: PUSH
2573: EMPTY
2574: LIST
2575: LIST
2576: PPUSH
2577: CALL_OW 69
2581: IFFALSE 2640
2583: GO 2585
2585: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2586: LD_STRING M1a
2588: PPUSH
2589: CALL_OW 337
// case Query ( Q2 ) of 1 :
2593: LD_STRING Q2
2595: PPUSH
2596: CALL_OW 97
2600: PUSH
2601: LD_INT 1
2603: DOUBLE
2604: EQUAL
2605: IFTRUE 2609
2607: GO 2620
2609: POP
// end_mission := true ; 2 :
2610: LD_ADDR_EXP 12
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
2618: GO 2640
2620: LD_INT 2
2622: DOUBLE
2623: EQUAL
2624: IFTRUE 2628
2626: GO 2639
2628: POP
// end_the_mission_allowed := true ; end ;
2629: LD_ADDR_OWVAR 57
2633: PUSH
2634: LD_INT 1
2636: ST_TO_ADDR
2637: GO 2640
2639: POP
// end ;
2640: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) and Delta do
2641: LD_INT 22
2643: PUSH
2644: LD_INT 1
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: PUSH
2651: LD_INT 2
2653: PUSH
2654: LD_INT 30
2656: PUSH
2657: LD_INT 6
2659: PUSH
2660: EMPTY
2661: LIST
2662: LIST
2663: PUSH
2664: LD_INT 30
2666: PUSH
2667: LD_INT 7
2669: PUSH
2670: EMPTY
2671: LIST
2672: LIST
2673: PUSH
2674: EMPTY
2675: LIST
2676: LIST
2677: LIST
2678: PUSH
2679: EMPTY
2680: LIST
2681: LIST
2682: PPUSH
2683: CALL_OW 69
2687: PUSH
2688: LD_INT 22
2690: PUSH
2691: LD_INT 1
2693: PUSH
2694: EMPTY
2695: LIST
2696: LIST
2697: PUSH
2698: LD_INT 2
2700: PUSH
2701: LD_INT 30
2703: PUSH
2704: LD_INT 2
2706: PUSH
2707: EMPTY
2708: LIST
2709: LIST
2710: PUSH
2711: LD_INT 30
2713: PUSH
2714: LD_INT 3
2716: PUSH
2717: EMPTY
2718: LIST
2719: LIST
2720: PUSH
2721: EMPTY
2722: LIST
2723: LIST
2724: LIST
2725: PUSH
2726: EMPTY
2727: LIST
2728: LIST
2729: PPUSH
2730: CALL_OW 69
2734: AND
2735: PUSH
2736: LD_EXP 4
2740: AND
2741: IFFALSE 3168
2743: GO 2745
2745: DISABLE
// begin Wait ( rand ( 0 0$20 , 0 0$40 ) ) ;
2746: LD_INT 700
2748: PPUSH
2749: LD_INT 1400
2751: PPUSH
2752: CALL_OW 12
2756: PPUSH
2757: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
2761: LD_EXP 16
2765: PPUSH
2766: LD_INT 6
2768: PUSH
2769: LD_INT 9
2771: PUSH
2772: LD_INT 10
2774: PUSH
2775: EMPTY
2776: LIST
2777: LIST
2778: LIST
2779: PUSH
2780: LD_OWVAR 67
2784: ARRAY
2785: PPUSH
2786: LD_INT 0
2788: PPUSH
2789: CALL_OW 49
// ComHold ( Denis ) ;
2793: LD_EXP 16
2797: PPUSH
2798: CALL_OW 140
// InGameOn ;
2802: CALL_OW 8
// DialogueOn ;
2806: CALL_OW 6
// if Delta then
2810: LD_EXP 4
2814: IFFALSE 2827
// CenterNowOnUnits ( Delta ) else
2816: LD_EXP 4
2820: PPUSH
2821: CALL_OW 87
2825: GO 2836
// CenterNowOnUnits ( JMM ) ;
2827: LD_EXP 13
2831: PPUSH
2832: CALL_OW 87
// Say ( Denis , DD-Den-1 ) ;
2836: LD_EXP 16
2840: PPUSH
2841: LD_STRING DD-Den-1
2843: PPUSH
2844: CALL_OW 88
// Say ( JMM , DD-JMM-1 ) ;
2848: LD_EXP 13
2852: PPUSH
2853: LD_STRING DD-JMM-1
2855: PPUSH
2856: CALL_OW 88
// Say ( Denis , DD-Den-2 ) ;
2860: LD_EXP 16
2864: PPUSH
2865: LD_STRING DD-Den-2
2867: PPUSH
2868: CALL_OW 88
// Wait ( 3 ) ;
2872: LD_INT 3
2874: PPUSH
2875: CALL_OW 67
// DialogueOff ;
2879: CALL_OW 7
// InGameOff ;
2883: CALL_OW 9
// repeat wait ( 0 0$01 ) ;
2887: LD_INT 35
2889: PPUSH
2890: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
2894: LD_INT 1
2896: PPUSH
2897: LD_EXP 16
2901: PPUSH
2902: CALL_OW 292
2906: PUSH
2907: LD_EXP 16
2911: PPUSH
2912: CALL_OW 301
2916: OR
2917: IFFALSE 2887
// if IsDead ( Denis ) then
2919: LD_EXP 16
2923: PPUSH
2924: CALL_OW 301
2928: IFFALSE 2932
// exit ;
2930: GO 3168
// SetSide ( Denis , 1 ) ;
2932: LD_EXP 16
2936: PPUSH
2937: LD_INT 1
2939: PPUSH
2940: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
2944: LD_EXP 16
2948: PPUSH
2949: LD_STRING DD-Den-2a
2951: PPUSH
2952: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
2956: LD_INT 35
2958: PPUSH
2959: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
2963: LD_EXP 16
2967: PPUSH
2968: CALL_OW 310
2972: PPUSH
2973: CALL_OW 266
2977: PUSH
2978: LD_INT 6
2980: PUSH
2981: LD_INT 7
2983: PUSH
2984: LD_INT 8
2986: PUSH
2987: EMPTY
2988: LIST
2989: LIST
2990: LIST
2991: IN
2992: PUSH
2993: LD_EXP 16
2997: PPUSH
2998: CALL_OW 301
3002: OR
3003: IFFALSE 2956
// if IsDead ( Denis ) then
3005: LD_EXP 16
3009: PPUSH
3010: CALL_OW 301
3014: IFFALSE 3018
// exit ;
3016: GO 3168
// Say ( Denis , DD-Den-2b ) ;
3018: LD_EXP 16
3022: PPUSH
3023: LD_STRING DD-Den-2b
3025: PPUSH
3026: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
3030: LD_EXP 16
3034: PPUSH
3035: LD_INT 4
3037: PPUSH
3038: CALL_OW 123
// Wait ( 0 0$02 ) ;
3042: LD_INT 70
3044: PPUSH
3045: CALL_OW 67
// DialogueOn ;
3049: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
3053: LD_EXP 16
3057: PPUSH
3058: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3062: LD_EXP 13
3066: PPUSH
3067: LD_STRING D4-JMM-1
3069: PPUSH
3070: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
3074: LD_EXP 16
3078: PPUSH
3079: LD_STRING D4-Den-1
3081: PPUSH
3082: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
3086: LD_EXP 13
3090: PPUSH
3091: LD_STRING D4-JMM-2
3093: PPUSH
3094: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
3098: LD_EXP 16
3102: PPUSH
3103: LD_STRING D4-Den-2
3105: PPUSH
3106: CALL_OW 88
// DialogueOff ;
3110: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
3114: LD_STRING M2
3116: PPUSH
3117: CALL_OW 337
// radar_allowed := true ;
3121: LD_ADDR_EXP 5
3125: PUSH
3126: LD_INT 1
3128: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
3129: LD_INT 6
3131: PPUSH
3132: LD_INT 1
3134: PPUSH
3135: LD_INT 1
3137: PPUSH
3138: CALL_OW 322
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
3142: LD_INT 15
3144: PPUSH
3145: LD_INT 1
3147: PPUSH
3148: LD_INT 1
3150: PPUSH
3151: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
3155: LD_INT 20
3157: PPUSH
3158: LD_INT 1
3160: PPUSH
3161: LD_INT 1
3163: PPUSH
3164: CALL_OW 324
// end ;
3168: END
// every 0 0$1 trigger arab_spotted do var sol , sol2 ;
3169: LD_EXP 11
3173: IFFALSE 3796
3175: GO 3177
3177: DISABLE
3178: LD_INT 0
3180: PPUSH
3181: PPUSH
// begin sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D5-Sol1-1 ) ;
3182: LD_ADDR_VAR 0 1
3186: PUSH
3187: LD_EXP 23
3191: PPUSH
3192: LD_INT 26
3194: PUSH
3195: LD_INT 1
3197: PUSH
3198: EMPTY
3199: LIST
3200: LIST
3201: PPUSH
3202: CALL_OW 72
3206: PPUSH
3207: LD_STRING D5-Sol1-1
3209: PPUSH
3210: CALL 425 0 2
3214: ST_TO_ADDR
// if not sol then
3215: LD_VAR 0 1
3219: NOT
3220: IFFALSE 3224
// exit ;
3222: GO 3796
// repeat wait ( 0 0$01 ) ;
3224: LD_INT 35
3226: PPUSH
3227: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
3231: LD_INT 22
3233: PUSH
3234: LD_INT 2
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: PUSH
3241: LD_INT 21
3243: PUSH
3244: LD_INT 1
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: PUSH
3251: EMPTY
3252: LIST
3253: LIST
3254: PPUSH
3255: CALL_OW 69
3259: PUSH
3260: LD_INT 0
3262: EQUAL
3263: IFFALSE 3224
// if IsOk ( sol ) then
3265: LD_VAR 0 1
3269: PPUSH
3270: CALL_OW 302
3274: IFFALSE 3294
// begin sol2 := others diff sol ;
3276: LD_ADDR_VAR 0 2
3280: PUSH
3281: LD_EXP 23
3285: PUSH
3286: LD_VAR 0 1
3290: DIFF
3291: ST_TO_ADDR
// end else
3292: GO 3296
// exit ;
3294: GO 3796
// if not Lisa and not sol2 then
3296: LD_EXP 19
3300: NOT
3301: PUSH
3302: LD_VAR 0 2
3306: NOT
3307: AND
3308: IFFALSE 3312
// exit ;
3310: GO 3796
// DialogueOn ;
3312: CALL_OW 6
// if Lisa then
3316: LD_EXP 19
3320: IFFALSE 3336
// Say ( Lisa , D5a-Lisa-1 ) else
3322: LD_EXP 19
3326: PPUSH
3327: LD_STRING D5a-Lisa-1
3329: PPUSH
3330: CALL_OW 88
3334: GO 3411
// if sol2 then
3336: LD_VAR 0 2
3340: IFFALSE 3411
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3342: LD_VAR 0 2
3346: PUSH
3347: LD_INT 1
3349: ARRAY
3350: PPUSH
3351: CALL_OW 258
3355: PUSH
3356: LD_INT 1
3358: DOUBLE
3359: EQUAL
3360: IFTRUE 3364
3362: GO 3383
3364: POP
// Say ( sol2 [ 1 ] , D5-Sol2-1 ) ; sex_female :
3365: LD_VAR 0 2
3369: PUSH
3370: LD_INT 1
3372: ARRAY
3373: PPUSH
3374: LD_STRING D5-Sol2-1
3376: PPUSH
3377: CALL_OW 88
3381: GO 3411
3383: LD_INT 2
3385: DOUBLE
3386: EQUAL
3387: IFTRUE 3391
3389: GO 3410
3391: POP
// Say ( sol2 [ 1 ] , D5-FSol2-1 ) ; end ;
3392: LD_VAR 0 2
3396: PUSH
3397: LD_INT 1
3399: ARRAY
3400: PPUSH
3401: LD_STRING D5-FSol2-1
3403: PPUSH
3404: CALL_OW 88
3408: GO 3411
3410: POP
// Say ( sol , D5-Sol1-2 ) ;
3411: LD_VAR 0 1
3415: PPUSH
3416: LD_STRING D5-Sol1-2
3418: PPUSH
3419: CALL_OW 88
// if Lisa then
3423: LD_EXP 19
3427: IFFALSE 3443
// Say ( Lisa , D5a-Lisa-2 ) else
3429: LD_EXP 19
3433: PPUSH
3434: LD_STRING D5a-Lisa-2
3436: PPUSH
3437: CALL_OW 88
3441: GO 3518
// if sol2 then
3443: LD_VAR 0 2
3447: IFFALSE 3518
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3449: LD_VAR 0 2
3453: PUSH
3454: LD_INT 1
3456: ARRAY
3457: PPUSH
3458: CALL_OW 258
3462: PUSH
3463: LD_INT 1
3465: DOUBLE
3466: EQUAL
3467: IFTRUE 3471
3469: GO 3490
3471: POP
// Say ( sol2 [ 1 ] , D5-Sol2-2 ) ; sex_female :
3472: LD_VAR 0 2
3476: PUSH
3477: LD_INT 1
3479: ARRAY
3480: PPUSH
3481: LD_STRING D5-Sol2-2
3483: PPUSH
3484: CALL_OW 88
3488: GO 3518
3490: LD_INT 2
3492: DOUBLE
3493: EQUAL
3494: IFTRUE 3498
3496: GO 3517
3498: POP
// Say ( sol2 [ 1 ] , D5-FSol2-2 ) ; end ;
3499: LD_VAR 0 2
3503: PUSH
3504: LD_INT 1
3506: ARRAY
3507: PPUSH
3508: LD_STRING D5-FSol2-2
3510: PPUSH
3511: CALL_OW 88
3515: GO 3518
3517: POP
// Say ( sol , D5a-Sol1-3 ) ;
3518: LD_VAR 0 1
3522: PPUSH
3523: LD_STRING D5a-Sol1-3
3525: PPUSH
3526: CALL_OW 88
// if Lisa then
3530: LD_EXP 19
3534: IFFALSE 3548
// Say ( Lisa , D5a-Lisa-3 ) ;
3536: LD_EXP 19
3540: PPUSH
3541: LD_STRING D5a-Lisa-3
3543: PPUSH
3544: CALL_OW 88
// if not sol2 then
3548: LD_VAR 0 2
3552: NOT
3553: IFFALSE 3561
// begin DialogueOff ;
3555: CALL_OW 7
// exit ;
3559: GO 3796
// end ; case GetSex ( sol2 [ 1 ] ) of sex_male :
3561: LD_VAR 0 2
3565: PUSH
3566: LD_INT 1
3568: ARRAY
3569: PPUSH
3570: CALL_OW 258
3574: PUSH
3575: LD_INT 1
3577: DOUBLE
3578: EQUAL
3579: IFTRUE 3583
3581: GO 3602
3583: POP
// Say ( sol2 [ 1 ] , D5-Sol2-3 ) ; sex_female :
3584: LD_VAR 0 2
3588: PUSH
3589: LD_INT 1
3591: ARRAY
3592: PPUSH
3593: LD_STRING D5-Sol2-3
3595: PPUSH
3596: CALL_OW 88
3600: GO 3630
3602: LD_INT 2
3604: DOUBLE
3605: EQUAL
3606: IFTRUE 3610
3608: GO 3629
3610: POP
// Say ( sol2 [ 1 ] , D5-FSol2-3 ) ; end ;
3611: LD_VAR 0 2
3615: PUSH
3616: LD_INT 1
3618: ARRAY
3619: PPUSH
3620: LD_STRING D5-FSol2-3
3622: PPUSH
3623: CALL_OW 88
3627: GO 3630
3629: POP
// Say ( sol , D5-Sol1-4 ) ;
3630: LD_VAR 0 1
3634: PPUSH
3635: LD_STRING D5-Sol1-4
3637: PPUSH
3638: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3642: LD_VAR 0 2
3646: PUSH
3647: LD_INT 1
3649: ARRAY
3650: PPUSH
3651: CALL_OW 258
3655: PUSH
3656: LD_INT 1
3658: DOUBLE
3659: EQUAL
3660: IFTRUE 3664
3662: GO 3683
3664: POP
// Say ( sol2 [ 1 ] , D5-Sol2-4 ) ; sex_female :
3665: LD_VAR 0 2
3669: PUSH
3670: LD_INT 1
3672: ARRAY
3673: PPUSH
3674: LD_STRING D5-Sol2-4
3676: PPUSH
3677: CALL_OW 88
3681: GO 3711
3683: LD_INT 2
3685: DOUBLE
3686: EQUAL
3687: IFTRUE 3691
3689: GO 3710
3691: POP
// Say ( sol2 [ 1 ] , D5-FSol2-4 ) ; end ;
3692: LD_VAR 0 2
3696: PUSH
3697: LD_INT 1
3699: ARRAY
3700: PPUSH
3701: LD_STRING D5-FSol2-4
3703: PPUSH
3704: CALL_OW 88
3708: GO 3711
3710: POP
// Say ( sol , D5-Sol1-5 ) ;
3711: LD_VAR 0 1
3715: PPUSH
3716: LD_STRING D5-Sol1-5
3718: PPUSH
3719: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3723: LD_VAR 0 2
3727: PUSH
3728: LD_INT 1
3730: ARRAY
3731: PPUSH
3732: CALL_OW 258
3736: PUSH
3737: LD_INT 1
3739: DOUBLE
3740: EQUAL
3741: IFTRUE 3745
3743: GO 3764
3745: POP
// Say ( sol2 [ 1 ] , D5-Sol2-5 ) ; sex_female :
3746: LD_VAR 0 2
3750: PUSH
3751: LD_INT 1
3753: ARRAY
3754: PPUSH
3755: LD_STRING D5-Sol2-5
3757: PPUSH
3758: CALL_OW 88
3762: GO 3792
3764: LD_INT 2
3766: DOUBLE
3767: EQUAL
3768: IFTRUE 3772
3770: GO 3791
3772: POP
// Say ( sol2 [ 1 ] , D5-FSol2-5 ) ; end ;
3773: LD_VAR 0 2
3777: PUSH
3778: LD_INT 1
3780: ARRAY
3781: PPUSH
3782: LD_STRING D5-FSol2-5
3784: PPUSH
3785: CALL_OW 88
3789: GO 3792
3791: POP
// DialogueOff ;
3792: CALL_OW 7
// end ;
3796: PPOPN 2
3798: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 5 do
3799: LD_INT 22
3801: PUSH
3802: LD_INT 1
3804: PUSH
3805: EMPTY
3806: LIST
3807: LIST
3808: PUSH
3809: LD_INT 25
3811: PUSH
3812: LD_INT 16
3814: PUSH
3815: EMPTY
3816: LIST
3817: LIST
3818: PUSH
3819: EMPTY
3820: LIST
3821: LIST
3822: PPUSH
3823: CALL_OW 69
3827: PUSH
3828: LD_INT 5
3830: GREATEREQUAL
3831: IFFALSE 3851
3833: GO 3835
3835: DISABLE
// begin ChangeMissionObjectives ( M1b ) ;
3836: LD_STRING M1b
3838: PPUSH
3839: CALL_OW 337
// apeman_army := true ;
3843: LD_ADDR_EXP 7
3847: PUSH
3848: LD_INT 1
3850: ST_TO_ADDR
// end ;
3851: END
// every 0 0$1 trigger GetTech ( tech_radar , 1 ) = state_researched do
3852: LD_INT 6
3854: PPUSH
3855: LD_INT 1
3857: PPUSH
3858: CALL_OW 321
3862: PUSH
3863: LD_INT 2
3865: EQUAL
3866: IFFALSE 3886
3868: GO 3870
3870: DISABLE
// begin ChangeMissionObjectives ( M2a ) ;
3871: LD_STRING M2a
3873: PPUSH
3874: CALL_OW 337
// radar_researched := true ;
3878: LD_ADDR_EXP 8
3882: PUSH
3883: LD_INT 1
3885: ST_TO_ADDR
// end ;
3886: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_weapon , us_radar ] , [ f_bweapon , us_radar ] ] ] ) do
3887: LD_INT 22
3889: PUSH
3890: LD_INT 1
3892: PUSH
3893: EMPTY
3894: LIST
3895: LIST
3896: PUSH
3897: LD_INT 2
3899: PUSH
3900: LD_INT 34
3902: PUSH
3903: LD_INT 11
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 35
3912: PUSH
3913: LD_INT 11
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PUSH
3920: EMPTY
3921: LIST
3922: LIST
3923: LIST
3924: PUSH
3925: EMPTY
3926: LIST
3927: LIST
3928: PPUSH
3929: CALL_OW 69
3933: IFFALSE 3953
3935: GO 3937
3937: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
3938: LD_STRING M2b
3940: PPUSH
3941: CALL_OW 337
// radar_builded := true ;
3945: LD_ADDR_EXP 9
3949: PUSH
3950: LD_INT 1
3952: ST_TO_ADDR
// end ;
3953: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 and not first_apeman_tamed do
3954: LD_INT 22
3956: PUSH
3957: LD_INT 0
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PUSH
3964: LD_INT 25
3966: PUSH
3967: LD_INT 12
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PPUSH
3978: CALL_OW 69
3982: PUSH
3983: LD_INT 0
3985: EQUAL
3986: PUSH
3987: LD_EXP 6
3991: NOT
3992: AND
3993: IFFALSE 4005
3995: GO 3997
3997: DISABLE
// YouLost ( Apeman ) ;
3998: LD_STRING Apeman
4000: PPUSH
4001: CALL_OW 104
4005: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 7 do var i , filter ;
4006: LD_INT 22
4008: PUSH
4009: LD_INT 1
4011: PUSH
4012: EMPTY
4013: LIST
4014: LIST
4015: PUSH
4016: LD_INT 25
4018: PUSH
4019: LD_INT 16
4021: PUSH
4022: EMPTY
4023: LIST
4024: LIST
4025: PUSH
4026: EMPTY
4027: LIST
4028: LIST
4029: PPUSH
4030: CALL_OW 69
4034: PUSH
4035: LD_INT 7
4037: GREATEREQUAL
4038: IFFALSE 4136
4040: GO 4042
4042: DISABLE
4043: LD_INT 0
4045: PPUSH
4046: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ^ JMM ;
4047: LD_ADDR_VAR 0 2
4051: PUSH
4052: LD_INT 22
4054: PUSH
4055: LD_INT 1
4057: PUSH
4058: EMPTY
4059: LIST
4060: LIST
4061: PUSH
4062: LD_INT 21
4064: PUSH
4065: LD_INT 1
4067: PUSH
4068: EMPTY
4069: LIST
4070: LIST
4071: PUSH
4072: LD_INT 25
4074: PUSH
4075: LD_INT 4
4077: PUSH
4078: EMPTY
4079: LIST
4080: LIST
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: LIST
4086: PPUSH
4087: CALL_OW 69
4091: PUSH
4092: LD_EXP 13
4096: ADD
4097: ST_TO_ADDR
// if filter then
4098: LD_VAR 0 2
4102: IFFALSE 4136
// for i in filter do
4104: LD_ADDR_VAR 0 1
4108: PUSH
4109: LD_VAR 0 2
4113: PUSH
4114: FOR_IN
4115: IFFALSE 4134
// AddExperience ( i , 4 , 3500 ) ;
4117: LD_VAR 0 1
4121: PPUSH
4122: LD_INT 4
4124: PPUSH
4125: LD_INT 3500
4127: PPUSH
4128: CALL_OW 492
4132: GO 4114
4134: POP
4135: POP
// end ;
4136: PPOPN 2
4138: END
// every 0 0$1 trigger end_mission do var i , tmp ;
4139: LD_EXP 12
4143: IFFALSE 5104
4145: GO 4147
4147: DISABLE
4148: LD_INT 0
4150: PPUSH
4151: PPUSH
// begin if FilterAllUnits ( [ f_side , 2 ] ) then
4152: LD_INT 22
4154: PUSH
4155: LD_INT 2
4157: PUSH
4158: EMPTY
4159: LIST
4160: LIST
4161: PPUSH
4162: CALL_OW 69
4166: IFFALSE 4204
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
4168: LD_ADDR_VAR 0 1
4172: PUSH
4173: LD_INT 22
4175: PUSH
4176: LD_INT 2
4178: PUSH
4179: EMPTY
4180: LIST
4181: LIST
4182: PPUSH
4183: CALL_OW 69
4187: PUSH
4188: FOR_IN
4189: IFFALSE 4202
// RemoveUnit ( i ) ;
4191: LD_VAR 0 1
4195: PPUSH
4196: CALL_OW 64
4200: GO 4188
4202: POP
4203: POP
// if apeman_army then
4204: LD_EXP 7
4208: IFFALSE 4222
// AddMedal ( Tame , 1 ) else
4210: LD_STRING Tame
4212: PPUSH
4213: LD_INT 1
4215: PPUSH
4216: CALL_OW 101
4220: GO 4233
// AddMedal ( Tame , - 1 ) ;
4222: LD_STRING Tame
4224: PPUSH
4225: LD_INT 1
4227: NEG
4228: PPUSH
4229: CALL_OW 101
// if radar_researched then
4233: LD_EXP 8
4237: IFFALSE 4261
// begin SaveVariable ( true , radarResInDelta ) ;
4239: LD_INT 1
4241: PPUSH
4242: LD_STRING radarResInDelta
4244: PPUSH
4245: CALL_OW 39
// AddMedal ( Radar , 1 ) ;
4249: LD_STRING Radar
4251: PPUSH
4252: LD_INT 1
4254: PPUSH
4255: CALL_OW 101
// end else
4259: GO 4291
// if radar_allowed then
4261: LD_EXP 5
4265: IFFALSE 4280
// AddMedal ( Radar , - 2 ) else
4267: LD_STRING Radar
4269: PPUSH
4270: LD_INT 2
4272: NEG
4273: PPUSH
4274: CALL_OW 101
4278: GO 4291
// AddMedal ( Radar , - 1 ) ;
4280: LD_STRING Radar
4282: PPUSH
4283: LD_INT 1
4285: NEG
4286: PPUSH
4287: CALL_OW 101
// if radar_builded then
4291: LD_EXP 9
4295: IFFALSE 4309
// AddMedal ( BuildRadar , 1 ) else
4297: LD_STRING BuildRadar
4299: PPUSH
4300: LD_INT 1
4302: PPUSH
4303: CALL_OW 101
4307: GO 4320
// AddMedal ( BuildRadar , - 1 ) ;
4309: LD_STRING BuildRadar
4311: PPUSH
4312: LD_INT 1
4314: NEG
4315: PPUSH
4316: CALL_OW 101
// GiveMedals ( MAIN ) ;
4320: LD_STRING MAIN
4322: PPUSH
4323: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
4327: LD_ADDR_VAR 0 2
4331: PUSH
4332: LD_INT 22
4334: PUSH
4335: LD_INT 1
4337: PUSH
4338: EMPTY
4339: LIST
4340: LIST
4341: PUSH
4342: LD_INT 21
4344: PUSH
4345: LD_INT 1
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: PUSH
4352: LD_INT 2
4354: PUSH
4355: LD_INT 25
4357: PUSH
4358: LD_INT 1
4360: PUSH
4361: EMPTY
4362: LIST
4363: LIST
4364: PUSH
4365: LD_INT 25
4367: PUSH
4368: LD_INT 2
4370: PUSH
4371: EMPTY
4372: LIST
4373: LIST
4374: PUSH
4375: LD_INT 25
4377: PUSH
4378: LD_INT 3
4380: PUSH
4381: EMPTY
4382: LIST
4383: LIST
4384: PUSH
4385: LD_INT 25
4387: PUSH
4388: LD_INT 4
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: LIST
4399: LIST
4400: LIST
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: LIST
4406: PPUSH
4407: CALL_OW 69
4411: ST_TO_ADDR
// RewardPeople ( tmp ) ;
4412: LD_VAR 0 2
4416: PPUSH
4417: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
4421: LD_EXP 13
4425: PPUSH
4426: LD_STRING JMM
4428: PPUSH
4429: CALL_OW 38
// if IsOk ( Gladstone ) then
4433: LD_EXP 14
4437: PPUSH
4438: CALL_OW 302
4442: IFFALSE 4466
// begin SaveCharacters ( Gladstone , Gladstone ) ;
4444: LD_EXP 14
4448: PPUSH
4449: LD_STRING Gladstone
4451: PPUSH
4452: CALL_OW 38
// SaveVariable ( true , GladstoneInDelta ) ;
4456: LD_INT 1
4458: PPUSH
4459: LD_STRING GladstoneInDelta
4461: PPUSH
4462: CALL_OW 39
// end ; if IsOk ( Denis ) and GetSide ( Denis ) = 1 then
4466: LD_EXP 16
4470: PPUSH
4471: CALL_OW 302
4475: PUSH
4476: LD_EXP 16
4480: PPUSH
4481: CALL_OW 255
4485: PUSH
4486: LD_INT 1
4488: EQUAL
4489: AND
4490: IFFALSE 4514
// begin SaveCharacters ( Denis , Denis ) ;
4492: LD_EXP 16
4496: PPUSH
4497: LD_STRING Denis
4499: PPUSH
4500: CALL_OW 38
// SaveVariable ( true , DenisInDelta ) ;
4504: LD_INT 1
4506: PPUSH
4507: LD_STRING DenisInDelta
4509: PPUSH
4510: CALL_OW 39
// end ; if IsOk ( Lisa ) then
4514: LD_EXP 19
4518: PPUSH
4519: CALL_OW 302
4523: IFFALSE 4547
// begin SaveCharacters ( Lisa , Lisa ) ;
4525: LD_EXP 19
4529: PPUSH
4530: LD_STRING Lisa
4532: PPUSH
4533: CALL_OW 38
// SaveVariable ( true , LisaInDelta ) ;
4537: LD_INT 1
4539: PPUSH
4540: LD_STRING LisaInDelta
4542: PPUSH
4543: CALL_OW 39
// end ; if IsOk ( Frank ) then
4547: LD_EXP 20
4551: PPUSH
4552: CALL_OW 302
4556: IFFALSE 4580
// begin SaveCharacters ( Frank , Frank ) ;
4558: LD_EXP 20
4562: PPUSH
4563: LD_STRING Frank
4565: PPUSH
4566: CALL_OW 38
// SaveVariable ( true , FrankInDelta ) ;
4570: LD_INT 1
4572: PPUSH
4573: LD_STRING FrankInDelta
4575: PPUSH
4576: CALL_OW 39
// end ; if IsOk ( Bobby ) then
4580: LD_EXP 21
4584: PPUSH
4585: CALL_OW 302
4589: IFFALSE 4613
// begin SaveCharacters ( Bobby , Bobby ) ;
4591: LD_EXP 21
4595: PPUSH
4596: LD_STRING Bobby
4598: PPUSH
4599: CALL_OW 38
// SaveVariable ( true , BobbyInDelta ) ;
4603: LD_INT 1
4605: PPUSH
4606: LD_STRING BobbyInDelta
4608: PPUSH
4609: CALL_OW 39
// end ; if IsOk ( Cyrus ) then
4613: LD_EXP 22
4617: PPUSH
4618: CALL_OW 302
4622: IFFALSE 4646
// begin SaveCharacters ( Cyrus , Cyrus ) ;
4624: LD_EXP 22
4628: PPUSH
4629: LD_STRING Cyrus
4631: PPUSH
4632: CALL_OW 38
// SaveVariable ( true , CyrusInDelta ) ;
4636: LD_INT 1
4638: PPUSH
4639: LD_STRING CyrusInDelta
4641: PPUSH
4642: CALL_OW 39
// end ; if others then
4646: LD_EXP 23
4650: IFFALSE 4664
// SaveCharacters ( others , othersInDelta ) ;
4652: LD_EXP 23
4656: PPUSH
4657: LD_STRING othersInDelta
4659: PPUSH
4660: CALL_OW 38
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) then
4664: LD_INT 22
4666: PUSH
4667: LD_INT 1
4669: PUSH
4670: EMPTY
4671: LIST
4672: LIST
4673: PUSH
4674: LD_INT 25
4676: PUSH
4677: LD_INT 16
4679: PUSH
4680: EMPTY
4681: LIST
4682: LIST
4683: PUSH
4684: EMPTY
4685: LIST
4686: LIST
4687: PPUSH
4688: CALL_OW 69
4692: IFFALSE 4730
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) , apeInDelta ) ;
4694: LD_INT 22
4696: PUSH
4697: LD_INT 1
4699: PUSH
4700: EMPTY
4701: LIST
4702: LIST
4703: PUSH
4704: LD_INT 25
4706: PUSH
4707: LD_INT 16
4709: PUSH
4710: EMPTY
4711: LIST
4712: LIST
4713: PUSH
4714: EMPTY
4715: LIST
4716: LIST
4717: PPUSH
4718: CALL_OW 69
4722: PPUSH
4723: LD_STRING apeInDelta
4725: PPUSH
4726: CALL_OW 38
// tmp := [ ] ;
4730: LD_ADDR_VAR 0 2
4734: PUSH
4735: EMPTY
4736: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) then
4737: LD_INT 22
4739: PUSH
4740: LD_INT 1
4742: PUSH
4743: EMPTY
4744: LIST
4745: LIST
4746: PUSH
4747: LD_INT 21
4749: PUSH
4750: LD_INT 2
4752: PUSH
4753: EMPTY
4754: LIST
4755: LIST
4756: PUSH
4757: EMPTY
4758: LIST
4759: LIST
4760: PPUSH
4761: CALL_OW 69
4765: IFFALSE 4876
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
4767: LD_ADDR_VAR 0 1
4771: PUSH
4772: LD_INT 22
4774: PUSH
4775: LD_INT 1
4777: PUSH
4778: EMPTY
4779: LIST
4780: LIST
4781: PUSH
4782: LD_INT 21
4784: PUSH
4785: LD_INT 2
4787: PUSH
4788: EMPTY
4789: LIST
4790: LIST
4791: PUSH
4792: EMPTY
4793: LIST
4794: LIST
4795: PPUSH
4796: CALL_OW 69
4800: PUSH
4801: FOR_IN
4802: IFFALSE 4874
// tmp := tmp ^ [ GetNation ( i ) , GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
4804: LD_ADDR_VAR 0 2
4808: PUSH
4809: LD_VAR 0 2
4813: PUSH
4814: LD_VAR 0 1
4818: PPUSH
4819: CALL_OW 248
4823: PUSH
4824: LD_VAR 0 1
4828: PPUSH
4829: CALL_OW 265
4833: PUSH
4834: LD_VAR 0 1
4838: PPUSH
4839: CALL_OW 262
4843: PUSH
4844: LD_VAR 0 1
4848: PPUSH
4849: CALL_OW 263
4853: PUSH
4854: LD_VAR 0 1
4858: PPUSH
4859: CALL_OW 264
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: ADD
4871: ST_TO_ADDR
4872: GO 4801
4874: POP
4875: POP
// if tmp then
4876: LD_VAR 0 2
4880: IFFALSE 4894
// SaveVariable ( tmp , vehiclesInDelta ) ;
4882: LD_VAR 0 2
4886: PPUSH
4887: LD_STRING vehiclesInDelta
4889: PPUSH
4890: CALL_OW 39
// tmp := [ ] ;
4894: LD_ADDR_VAR 0 2
4898: PUSH
4899: EMPTY
4900: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
4901: LD_INT 22
4903: PUSH
4904: LD_INT 1
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PUSH
4911: LD_INT 21
4913: PUSH
4914: LD_INT 3
4916: PUSH
4917: EMPTY
4918: LIST
4919: LIST
4920: PUSH
4921: EMPTY
4922: LIST
4923: LIST
4924: PPUSH
4925: CALL_OW 69
4929: IFFALSE 5082
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4931: LD_ADDR_VAR 0 1
4935: PUSH
4936: LD_INT 22
4938: PUSH
4939: LD_INT 1
4941: PUSH
4942: EMPTY
4943: LIST
4944: LIST
4945: PUSH
4946: LD_INT 21
4948: PUSH
4949: LD_INT 3
4951: PUSH
4952: EMPTY
4953: LIST
4954: LIST
4955: PUSH
4956: EMPTY
4957: LIST
4958: LIST
4959: PPUSH
4960: CALL_OW 69
4964: PUSH
4965: FOR_IN
4966: IFFALSE 5080
// tmp := tmp ^ [ [ GetBType ( i ) , GetBLevel ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
4968: LD_ADDR_VAR 0 2
4972: PUSH
4973: LD_VAR 0 2
4977: PUSH
4978: LD_VAR 0 1
4982: PPUSH
4983: CALL_OW 266
4987: PUSH
4988: LD_VAR 0 1
4992: PPUSH
4993: CALL_OW 267
4997: PUSH
4998: LD_VAR 0 1
5002: PPUSH
5003: CALL_OW 250
5007: PUSH
5008: LD_VAR 0 1
5012: PPUSH
5013: CALL_OW 251
5017: PUSH
5018: LD_VAR 0 1
5022: PPUSH
5023: CALL_OW 254
5027: PUSH
5028: LD_VAR 0 1
5032: PPUSH
5033: LD_INT 1
5035: PPUSH
5036: CALL_OW 268
5040: PUSH
5041: LD_VAR 0 1
5045: PPUSH
5046: LD_INT 2
5048: PPUSH
5049: CALL_OW 268
5053: PUSH
5054: LD_VAR 0 1
5058: PPUSH
5059: CALL_OW 269
5063: PUSH
5064: EMPTY
5065: LIST
5066: LIST
5067: LIST
5068: LIST
5069: LIST
5070: LIST
5071: LIST
5072: LIST
5073: PUSH
5074: EMPTY
5075: LIST
5076: ADD
5077: ST_TO_ADDR
5078: GO 4965
5080: POP
5081: POP
// if tmp then
5082: LD_VAR 0 2
5086: IFFALSE 5100
// SaveVariable ( tmp , buildingsInDelta ) ;
5088: LD_VAR 0 2
5092: PPUSH
5093: LD_STRING buildingsInDelta
5095: PPUSH
5096: CALL_OW 39
// YouWin ;
5100: CALL_OW 103
// end ; end_of_file
5104: PPOPN 2
5106: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un , tmp ; begin
5107: LD_INT 0
5109: PPUSH
5110: PPUSH
5111: PPUSH
5112: PPUSH
// InitHc ;
5113: CALL_OW 19
// InitUc ;
5117: CALL_OW 18
// uc_side := 2 ;
5121: LD_ADDR_OWVAR 20
5125: PUSH
5126: LD_INT 2
5128: ST_TO_ADDR
// uc_nation := 2 ;
5129: LD_ADDR_OWVAR 21
5133: PUSH
5134: LD_INT 2
5136: ST_TO_ADDR
// if not amount then
5137: LD_VAR 0 1
5141: NOT
5142: IFFALSE 5146
// exit ;
5144: GO 5269
// for i = 1 to amount do
5146: LD_ADDR_VAR 0 5
5150: PUSH
5151: DOUBLE
5152: LD_INT 1
5154: DEC
5155: ST_TO_ADDR
5156: LD_VAR 0 1
5160: PUSH
5161: FOR_TO
5162: IFFALSE 5257
// begin PrepareHuman ( false , 1 , skill ) ;
5164: LD_INT 0
5166: PPUSH
5167: LD_INT 1
5169: PPUSH
5170: LD_VAR 0 2
5174: PPUSH
5175: CALL_OW 380
// un := CreateHuman ;
5179: LD_ADDR_VAR 0 6
5183: PUSH
5184: CALL_OW 44
5188: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
5189: LD_ADDR_VAR 0 7
5193: PUSH
5194: LD_VAR 0 7
5198: PPUSH
5199: LD_INT 1
5201: PPUSH
5202: LD_VAR 0 6
5206: PPUSH
5207: CALL_OW 2
5211: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5212: LD_VAR 0 6
5216: PPUSH
5217: LD_VAR 0 3
5221: PPUSH
5222: LD_INT 0
5224: PPUSH
5225: CALL_OW 49
// if i mod 2 = 0 then
5229: LD_VAR 0 5
5233: PUSH
5234: LD_INT 2
5236: MOD
5237: PUSH
5238: LD_INT 0
5240: EQUAL
5241: IFFALSE 5255
// SetTag ( un , 11 ) ;
5243: LD_VAR 0 6
5247: PPUSH
5248: LD_INT 11
5250: PPUSH
5251: CALL_OW 109
// end ;
5255: GO 5161
5257: POP
5258: POP
// result := tmp ;
5259: LD_ADDR_VAR 0 4
5263: PUSH
5264: LD_VAR 0 7
5268: ST_TO_ADDR
// end ;
5269: LD_VAR 0 4
5273: RET
// export ar_forces , ap_killers ; every 0 0$1 trigger Delta do var i , timer , more_troops , skill , eng , un , veh , force ;
5274: LD_EXP 4
5278: IFFALSE 6138
5280: GO 5282
5282: DISABLE
5283: LD_INT 0
5285: PPUSH
5286: PPUSH
5287: PPUSH
5288: PPUSH
5289: PPUSH
5290: PPUSH
5291: PPUSH
5292: PPUSH
// begin more_troops := false ;
5293: LD_ADDR_VAR 0 3
5297: PUSH
5298: LD_INT 0
5300: ST_TO_ADDR
// skill := [ 3 , 4 , 5 ] [ Difficulty ] ;
5301: LD_ADDR_VAR 0 4
5305: PUSH
5306: LD_INT 3
5308: PUSH
5309: LD_INT 4
5311: PUSH
5312: LD_INT 5
5314: PUSH
5315: EMPTY
5316: LIST
5317: LIST
5318: LIST
5319: PUSH
5320: LD_OWVAR 67
5324: ARRAY
5325: ST_TO_ADDR
// timer := [ 5 5$00 , 4 4$00 , 3 3$00 ] [ Difficulty ] ;
5326: LD_ADDR_VAR 0 2
5330: PUSH
5331: LD_INT 10500
5333: PUSH
5334: LD_INT 8400
5336: PUSH
5337: LD_INT 6300
5339: PUSH
5340: EMPTY
5341: LIST
5342: LIST
5343: LIST
5344: PUSH
5345: LD_OWVAR 67
5349: ARRAY
5350: ST_TO_ADDR
// force := [ ] ;
5351: LD_ADDR_VAR 0 8
5355: PUSH
5356: EMPTY
5357: ST_TO_ADDR
// ar_forces := [ ] ;
5358: LD_ADDR_EXP 24
5362: PUSH
5363: EMPTY
5364: ST_TO_ADDR
// ap_killers := [ ] ;
5365: LD_ADDR_EXP 25
5369: PUSH
5370: EMPTY
5371: ST_TO_ADDR
// Wait ( timer ) ;
5372: LD_VAR 0 2
5376: PPUSH
5377: CALL_OW 67
// if Denis and GetSide ( Denis ) = 4 then
5381: LD_EXP 16
5385: PUSH
5386: LD_EXP 16
5390: PPUSH
5391: CALL_OW 255
5395: PUSH
5396: LD_INT 4
5398: EQUAL
5399: AND
5400: IFFALSE 5409
// Wait ( 0 0$45 ) ;
5402: LD_INT 1575
5404: PPUSH
5405: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) then
5409: LD_INT 22
5411: PUSH
5412: LD_INT 1
5414: PUSH
5415: EMPTY
5416: LIST
5417: LIST
5418: PUSH
5419: LD_INT 30
5421: PUSH
5422: LD_INT 4
5424: PUSH
5425: EMPTY
5426: LIST
5427: LIST
5428: PUSH
5429: EMPTY
5430: LIST
5431: LIST
5432: PPUSH
5433: CALL_OW 69
5437: IFFALSE 5454
// begin Wait ( 1 1$25 ) ;
5439: LD_INT 2975
5441: PPUSH
5442: CALL_OW 67
// more_troops := true ;
5446: LD_ADDR_VAR 0 3
5450: PUSH
5451: LD_INT 1
5453: ST_TO_ADDR
// end ; if more_troops then
5454: LD_VAR 0 3
5458: IFFALSE 5646
// begin force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , arArea2 ) ;
5460: LD_ADDR_VAR 0 8
5464: PUSH
5465: LD_INT 4
5467: PUSH
5468: LD_INT 5
5470: PUSH
5471: LD_INT 6
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: LIST
5478: PUSH
5479: LD_OWVAR 67
5483: ARRAY
5484: PPUSH
5485: LD_VAR 0 4
5489: PPUSH
5490: LD_INT 14
5492: PPUSH
5493: CALL 5107 0 3
5497: ST_TO_ADDR
// veh := PrepareTank ( 2 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ Difficulty ] , 90 ) ;
5498: LD_ADDR_VAR 0 7
5502: PUSH
5503: LD_INT 2
5505: PPUSH
5506: LD_INT 3
5508: PPUSH
5509: LD_INT 22
5511: PPUSH
5512: LD_INT 1
5514: PPUSH
5515: LD_INT 1
5517: PPUSH
5518: LD_INT 42
5520: PUSH
5521: LD_INT 42
5523: PUSH
5524: LD_INT 43
5526: PUSH
5527: EMPTY
5528: LIST
5529: LIST
5530: LIST
5531: PUSH
5532: LD_OWVAR 67
5536: ARRAY
5537: PPUSH
5538: LD_INT 90
5540: PPUSH
5541: CALL 337 0 7
5545: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5546: LD_VAR 0 7
5550: PPUSH
5551: LD_INT 4
5553: PPUSH
5554: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
5558: LD_VAR 0 7
5562: PPUSH
5563: LD_INT 13
5565: PPUSH
5566: LD_INT 0
5568: PPUSH
5569: CALL_OW 49
// uc_side := 2 ;
5573: LD_ADDR_OWVAR 20
5577: PUSH
5578: LD_INT 2
5580: ST_TO_ADDR
// uc_nation := 2 ;
5581: LD_ADDR_OWVAR 21
5585: PUSH
5586: LD_INT 2
5588: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5589: LD_INT 0
5591: PPUSH
5592: LD_INT 1
5594: PPUSH
5595: LD_VAR 0 4
5599: PPUSH
5600: CALL_OW 380
// un := CreateHuman ;
5604: LD_ADDR_VAR 0 6
5608: PUSH
5609: CALL_OW 44
5613: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
5614: LD_VAR 0 6
5618: PPUSH
5619: LD_VAR 0 7
5623: PPUSH
5624: CALL_OW 52
// force := force ^ un ;
5628: LD_ADDR_VAR 0 8
5632: PUSH
5633: LD_VAR 0 8
5637: PUSH
5638: LD_VAR 0 6
5642: ADD
5643: ST_TO_ADDR
// end else
5644: GO 5684
// begin force := PrepareArabianTroops ( [ 3 , 4 , 5 ] [ Difficulty ] , skill , arArea2 ) ;
5646: LD_ADDR_VAR 0 8
5650: PUSH
5651: LD_INT 3
5653: PUSH
5654: LD_INT 4
5656: PUSH
5657: LD_INT 5
5659: PUSH
5660: EMPTY
5661: LIST
5662: LIST
5663: LIST
5664: PUSH
5665: LD_OWVAR 67
5669: ARRAY
5670: PPUSH
5671: LD_VAR 0 4
5675: PPUSH
5676: LD_INT 14
5678: PPUSH
5679: CALL 5107 0 3
5683: ST_TO_ADDR
// end ; if force then
5684: LD_VAR 0 8
5688: IFFALSE 5700
// ar_forces := force ;
5690: LD_ADDR_EXP 24
5694: PUSH
5695: LD_VAR 0 8
5699: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5700: LD_INT 35
5702: PPUSH
5703: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
5707: LD_INT 22
5709: PUSH
5710: LD_INT 2
5712: PUSH
5713: EMPTY
5714: LIST
5715: LIST
5716: PUSH
5717: LD_INT 21
5719: PUSH
5720: LD_INT 1
5722: PUSH
5723: EMPTY
5724: LIST
5725: LIST
5726: PUSH
5727: EMPTY
5728: LIST
5729: LIST
5730: PPUSH
5731: CALL_OW 69
5735: PUSH
5736: LD_INT 0
5738: EQUAL
5739: IFFALSE 5700
// Wait ( timer ) ;
5741: LD_VAR 0 2
5745: PPUSH
5746: CALL_OW 67
// force := PrepareArabianTroops ( [ 5 , 6 , 6 ] [ Difficulty ] , skill , [ arArea1 , arArea2 ] [ rand ( 1 , 2 ) ] ) ;
5750: LD_ADDR_VAR 0 8
5754: PUSH
5755: LD_INT 5
5757: PUSH
5758: LD_INT 6
5760: PUSH
5761: LD_INT 6
5763: PUSH
5764: EMPTY
5765: LIST
5766: LIST
5767: LIST
5768: PUSH
5769: LD_OWVAR 67
5773: ARRAY
5774: PPUSH
5775: LD_VAR 0 4
5779: PPUSH
5780: LD_INT 13
5782: PUSH
5783: LD_INT 14
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: PUSH
5790: LD_INT 1
5792: PPUSH
5793: LD_INT 2
5795: PPUSH
5796: CALL_OW 12
5800: ARRAY
5801: PPUSH
5802: CALL 5107 0 3
5806: ST_TO_ADDR
// if Difficulty > 1 and Delta then
5807: LD_OWVAR 67
5811: PUSH
5812: LD_INT 1
5814: GREATER
5815: PUSH
5816: LD_EXP 4
5820: AND
5821: IFFALSE 5900
// begin uc_side := 2 ;
5823: LD_ADDR_OWVAR 20
5827: PUSH
5828: LD_INT 2
5830: ST_TO_ADDR
// uc_nation := 2 ;
5831: LD_ADDR_OWVAR 21
5835: PUSH
5836: LD_INT 2
5838: ST_TO_ADDR
// PrepareHuman ( false , 2 , skill ) ;
5839: LD_INT 0
5841: PPUSH
5842: LD_INT 2
5844: PPUSH
5845: LD_VAR 0 4
5849: PPUSH
5850: CALL_OW 380
// eng := CreateHuman ;
5854: LD_ADDR_VAR 0 5
5858: PUSH
5859: CALL_OW 44
5863: ST_TO_ADDR
// PlaceUnitArea ( eng , arArea1 , false ) ;
5864: LD_VAR 0 5
5868: PPUSH
5869: LD_INT 13
5871: PPUSH
5872: LD_INT 0
5874: PPUSH
5875: CALL_OW 49
// Wait ( 3 ) ;
5879: LD_INT 3
5881: PPUSH
5882: CALL_OW 67
// AddComEnterUnit ( eng , Delta ) ;
5886: LD_VAR 0 5
5890: PPUSH
5891: LD_EXP 4
5895: PPUSH
5896: CALL_OW 180
// end ; if force then
5900: LD_VAR 0 8
5904: IFFALSE 5916
// ar_forces := force ;
5906: LD_ADDR_EXP 24
5910: PUSH
5911: LD_VAR 0 8
5915: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5916: LD_INT 35
5918: PPUSH
5919: CALL_OW 67
// if eng then
5923: LD_VAR 0 5
5927: IFFALSE 5981
// if GetSide ( Delta ) = 2 and IsOk ( eng ) and not IsInUnit ( eng ) then
5929: LD_EXP 4
5933: PPUSH
5934: CALL_OW 255
5938: PUSH
5939: LD_INT 2
5941: EQUAL
5942: PUSH
5943: LD_VAR 0 5
5947: PPUSH
5948: CALL_OW 302
5952: AND
5953: PUSH
5954: LD_VAR 0 5
5958: PPUSH
5959: CALL_OW 310
5963: NOT
5964: AND
5965: IFFALSE 5981
// ComEnterUnit ( eng , Delta ) ;
5967: LD_VAR 0 5
5971: PPUSH
5972: LD_EXP 4
5976: PPUSH
5977: CALL_OW 120
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 ;
5981: LD_INT 22
5983: PUSH
5984: LD_INT 2
5986: PUSH
5987: EMPTY
5988: LIST
5989: LIST
5990: PUSH
5991: LD_INT 21
5993: PUSH
5994: LD_INT 1
5996: PUSH
5997: EMPTY
5998: LIST
5999: LIST
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: PPUSH
6005: CALL_OW 69
6009: PUSH
6010: LD_INT 0
6012: EQUAL
6013: IFFALSE 5916
// ap_killers := PrepareArabianTroops ( [ 1 , 2 , 2 ] [ Difficulty ] , skill , arArea1 ) ;
6015: LD_ADDR_EXP 25
6019: PUSH
6020: LD_INT 1
6022: PUSH
6023: LD_INT 2
6025: PUSH
6026: LD_INT 2
6028: PUSH
6029: EMPTY
6030: LIST
6031: LIST
6032: LIST
6033: PUSH
6034: LD_OWVAR 67
6038: ARRAY
6039: PPUSH
6040: LD_VAR 0 4
6044: PPUSH
6045: LD_INT 13
6047: PPUSH
6048: CALL 5107 0 3
6052: ST_TO_ADDR
// Wait ( timer * 2 ) ;
6053: LD_VAR 0 2
6057: PUSH
6058: LD_INT 2
6060: MUL
6061: PPUSH
6062: CALL_OW 67
// ar_forces := PrepareArabianTroops ( [ 5 , 6 , 7 ] [ Difficulty ] , skill , arArea1 ) ^ PrepareArabianTroops ( [ 3 , 4 , 4 ] [ Difficulty ] , skill , arArea2 ) ;
6066: LD_ADDR_EXP 24
6070: PUSH
6071: LD_INT 5
6073: PUSH
6074: LD_INT 6
6076: PUSH
6077: LD_INT 7
6079: PUSH
6080: EMPTY
6081: LIST
6082: LIST
6083: LIST
6084: PUSH
6085: LD_OWVAR 67
6089: ARRAY
6090: PPUSH
6091: LD_VAR 0 4
6095: PPUSH
6096: LD_INT 13
6098: PPUSH
6099: CALL 5107 0 3
6103: PUSH
6104: LD_INT 3
6106: PUSH
6107: LD_INT 4
6109: PUSH
6110: LD_INT 4
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: PUSH
6118: LD_OWVAR 67
6122: ARRAY
6123: PPUSH
6124: LD_VAR 0 4
6128: PPUSH
6129: LD_INT 14
6131: PPUSH
6132: CALL 5107 0 3
6136: ADD
6137: ST_TO_ADDR
// end ;
6138: PPOPN 8
6140: END
// every 0 0$03 trigger ar_forces do var i , target ;
6141: LD_EXP 24
6145: IFFALSE 6284
6147: GO 6149
6149: DISABLE
6150: LD_INT 0
6152: PPUSH
6153: PPUSH
// begin enable ;
6154: ENABLE
// if not ar_forces then
6155: LD_EXP 24
6159: NOT
6160: IFFALSE 6164
// exit ;
6162: GO 6284
// if Delta then
6164: LD_EXP 4
6168: IFFALSE 6182
// target := Delta else
6170: LD_ADDR_VAR 0 2
6174: PUSH
6175: LD_EXP 4
6179: ST_TO_ADDR
6180: GO 6192
// target := JMM ;
6182: LD_ADDR_VAR 0 2
6186: PUSH
6187: LD_EXP 13
6191: ST_TO_ADDR
// for i in ar_forces do
6192: LD_ADDR_VAR 0 1
6196: PUSH
6197: LD_EXP 24
6201: PUSH
6202: FOR_IN
6203: IFFALSE 6282
// begin if GetDistUnits ( i , target ) > 30 then
6205: LD_VAR 0 1
6209: PPUSH
6210: LD_VAR 0 2
6214: PPUSH
6215: CALL_OW 296
6219: PUSH
6220: LD_INT 30
6222: GREATER
6223: IFFALSE 6256
// ComAgressiveMove ( i , GetX ( target ) , GetY ( target ) ) else
6225: LD_VAR 0 1
6229: PPUSH
6230: LD_VAR 0 2
6234: PPUSH
6235: CALL_OW 250
6239: PPUSH
6240: LD_VAR 0 2
6244: PPUSH
6245: CALL_OW 251
6249: PPUSH
6250: CALL_OW 114
6254: GO 6280
// Attack ( i , FilterAllUnits ( [ f_enemy , 2 ] ) ) ;
6256: LD_VAR 0 1
6260: PPUSH
6261: LD_INT 81
6263: PUSH
6264: LD_INT 2
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: PPUSH
6271: CALL_OW 69
6275: PPUSH
6276: CALL 590 0 2
// end ;
6280: GO 6202
6282: POP
6283: POP
// end ;
6284: PPOPN 2
6286: END
// every 0 0$01 trigger ap_killers do var filter , i , target ;
6287: LD_EXP 25
6291: IFFALSE 6451
6293: GO 6295
6295: DISABLE
6296: LD_INT 0
6298: PPUSH
6299: PPUSH
6300: PPUSH
// begin enable ;
6301: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6302: LD_ADDR_VAR 0 1
6306: PUSH
6307: LD_INT 22
6309: PUSH
6310: LD_INT 0
6312: PUSH
6313: EMPTY
6314: LIST
6315: LIST
6316: PUSH
6317: LD_INT 25
6319: PUSH
6320: LD_INT 12
6322: PUSH
6323: EMPTY
6324: LIST
6325: LIST
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: PPUSH
6331: CALL_OW 69
6335: ST_TO_ADDR
// if not filter then
6336: LD_VAR 0 1
6340: NOT
6341: IFFALSE 6368
// begin ar_forces := ar_forces ^ ap_killers ;
6343: LD_ADDR_EXP 24
6347: PUSH
6348: LD_EXP 24
6352: PUSH
6353: LD_EXP 25
6357: ADD
6358: ST_TO_ADDR
// ap_killers := [ ] ;
6359: LD_ADDR_EXP 25
6363: PUSH
6364: EMPTY
6365: ST_TO_ADDR
// exit ;
6366: GO 6451
// end ; for i in ap_killers do
6368: LD_ADDR_VAR 0 2
6372: PUSH
6373: LD_EXP 25
6377: PUSH
6378: FOR_IN
6379: IFFALSE 6449
// begin if not IsOk ( i ) then
6381: LD_VAR 0 2
6385: PPUSH
6386: CALL_OW 302
6390: NOT
6391: IFFALSE 6395
// continue ;
6393: GO 6378
// if not HasTask ( i ) then
6395: LD_VAR 0 2
6399: PPUSH
6400: CALL_OW 314
6404: NOT
6405: IFFALSE 6427
// target := NearestUnitToUnit ( filter , i ) ;
6407: LD_ADDR_VAR 0 3
6411: PUSH
6412: LD_VAR 0 1
6416: PPUSH
6417: LD_VAR 0 2
6421: PPUSH
6422: CALL_OW 74
6426: ST_TO_ADDR
// if target then
6427: LD_VAR 0 3
6431: IFFALSE 6447
// ComAttackUnit ( i , target ) ;
6433: LD_VAR 0 2
6437: PPUSH
6438: LD_VAR 0 3
6442: PPUSH
6443: CALL_OW 115
// end ;
6447: GO 6378
6449: POP
6450: POP
// end ; end_of_file
6451: PPOPN 3
6453: END
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
6454: LD_EXP 4
6458: IFFALSE 6590
6460: GO 6462
6462: DISABLE
6463: LD_INT 0
6465: PPUSH
6466: PPUSH
6467: PPUSH
// begin counter := [ 700 , 600 , 500 ] [ Difficulty ] ;
6468: LD_ADDR_VAR 0 2
6472: PUSH
6473: LD_INT 700
6475: PUSH
6476: LD_INT 600
6478: PUSH
6479: LD_INT 500
6481: PUSH
6482: EMPTY
6483: LIST
6484: LIST
6485: LIST
6486: PUSH
6487: LD_OWVAR 67
6491: ARRAY
6492: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
6493: LD_INT 1
6495: PPUSH
6496: LD_INT 3
6498: PPUSH
6499: CALL_OW 12
6503: PPUSH
6504: LD_INT 7
6506: PPUSH
6507: LD_INT 1
6509: PPUSH
6510: CALL_OW 55
// repeat wait ( rand ( 1 1$30 , 2 2$20 ) ) ;
6514: LD_INT 3150
6516: PPUSH
6517: LD_INT 4900
6519: PPUSH
6520: CALL_OW 12
6524: PPUSH
6525: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
6529: LD_ADDR_VAR 0 3
6533: PUSH
6534: LD_INT 1
6536: PPUSH
6537: LD_INT 5
6539: PPUSH
6540: CALL_OW 12
6544: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
6545: LD_VAR 0 3
6549: PPUSH
6550: LD_INT 7
6552: PPUSH
6553: LD_INT 1
6555: PPUSH
6556: CALL_OW 55
// counter := counter - cr * 10 ;
6560: LD_ADDR_VAR 0 2
6564: PUSH
6565: LD_VAR 0 2
6569: PUSH
6570: LD_VAR 0 3
6574: PUSH
6575: LD_INT 10
6577: MUL
6578: MINUS
6579: ST_TO_ADDR
// until counter <= 0 ;
6580: LD_VAR 0 2
6584: PUSH
6585: LD_INT 0
6587: LESSEQUAL
6588: IFFALSE 6514
// end ;
6590: PPOPN 3
6592: END
// every 0 0$03 trigger not Delta do var i ;
6593: LD_EXP 4
6597: NOT
6598: IFFALSE 6668
6600: GO 6602
6602: DISABLE
6603: LD_INT 0
6605: PPUSH
// begin for i = 1 to 4 - Difficulty do
6606: LD_ADDR_VAR 0 1
6610: PUSH
6611: DOUBLE
6612: LD_INT 1
6614: DEC
6615: ST_TO_ADDR
6616: LD_INT 4
6618: PUSH
6619: LD_OWVAR 67
6623: MINUS
6624: PUSH
6625: FOR_TO
6626: IFFALSE 6666
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
6628: LD_INT 2
6630: PPUSH
6631: LD_INT 5
6633: PPUSH
6634: CALL_OW 12
6638: PPUSH
6639: LD_INT 8
6641: PPUSH
6642: LD_INT 1
6644: PPUSH
6645: CALL_OW 55
// Wait ( rand ( 0 0$16 , 0 0$39 ) ) ;
6649: LD_INT 560
6651: PPUSH
6652: LD_INT 1365
6654: PPUSH
6655: CALL_OW 12
6659: PPUSH
6660: CALL_OW 67
// end ;
6664: GO 6625
6666: POP
6667: POP
// end ;
6668: PPOPN 1
6670: END
// every 2 2$00 do
6671: GO 6673
6673: DISABLE
// begin enable ;
6674: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
6675: LD_INT 1
6677: PPUSH
6678: LD_INT 3
6680: PPUSH
6681: CALL_OW 12
6685: PPUSH
6686: LD_INT 1
6688: PPUSH
6689: CALL_OW 57
// Wait ( rand ( 0 0$38 , 0 0$59 ) ) ;
6693: LD_INT 1330
6695: PPUSH
6696: LD_INT 2065
6698: PPUSH
6699: CALL_OW 12
6703: PPUSH
6704: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 4 ) , riverArea , true ) ;
6708: LD_INT 1
6710: PPUSH
6711: LD_INT 4
6713: PPUSH
6714: CALL_OW 12
6718: PPUSH
6719: LD_INT 15
6721: PPUSH
6722: LD_INT 1
6724: PPUSH
6725: CALL_OW 55
// end ; end_of_file
6729: END
// on UnitDestroyed ( un ) do begin if un = JMM then
6730: LD_VAR 0 1
6734: PUSH
6735: LD_EXP 13
6739: EQUAL
6740: IFFALSE 6749
// YouLost ( JMM ) ;
6742: LD_STRING JMM
6744: PPUSH
6745: CALL_OW 104
// if un = Delta then
6749: LD_VAR 0 1
6753: PUSH
6754: LD_EXP 4
6758: EQUAL
6759: IFFALSE 6769
// Delta := 0 ;
6761: LD_ADDR_EXP 4
6765: PUSH
6766: LD_INT 0
6768: ST_TO_ADDR
// if un in ar_forces then
6769: LD_VAR 0 1
6773: PUSH
6774: LD_EXP 24
6778: IN
6779: IFFALSE 6797
// ar_forces := ar_forces diff un ;
6781: LD_ADDR_EXP 24
6785: PUSH
6786: LD_EXP 24
6790: PUSH
6791: LD_VAR 0 1
6795: DIFF
6796: ST_TO_ADDR
// if un in ap_killers then
6797: LD_VAR 0 1
6801: PUSH
6802: LD_EXP 25
6806: IN
6807: IFFALSE 6825
// ap_killers := ap_killers diff un ;
6809: LD_ADDR_EXP 25
6813: PUSH
6814: LD_EXP 25
6818: PUSH
6819: LD_VAR 0 1
6823: DIFF
6824: ST_TO_ADDR
// end ;
6825: PPOPN 1
6827: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
6828: LD_VAR 0 1
6832: PUSH
6833: LD_INT 1
6835: EQUAL
6836: PUSH
6837: LD_VAR 0 2
6841: PUSH
6842: LD_INT 2
6844: EQUAL
6845: AND
6846: PUSH
6847: LD_EXP 11
6851: NOT
6852: AND
6853: IFFALSE 6863
// arab_spotted := true ;
6855: LD_ADDR_EXP 11
6859: PUSH
6860: LD_INT 1
6862: ST_TO_ADDR
6863: PPOPN 2
6865: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
6866: LD_ADDR_OWVAR 57
6870: PUSH
6871: LD_INT 0
6873: ST_TO_ADDR
// end_mission := true ;
6874: LD_ADDR_EXP 12
6878: PUSH
6879: LD_INT 1
6881: ST_TO_ADDR
// end ;
6882: PPOPN 1
6884: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
6885: LD_VAR 0 2
6889: PPUSH
6890: CALL_OW 255
6894: PUSH
6895: LD_INT 1
6897: EQUAL
6898: IFFALSE 6914
// apeman_counter := apeman_counter + 1 ;
6900: LD_ADDR_EXP 10
6904: PUSH
6905: LD_EXP 10
6909: PUSH
6910: LD_INT 1
6912: PLUS
6913: ST_TO_ADDR
// if not first_apeman_tamed then
6914: LD_EXP 6
6918: NOT
6919: IFFALSE 7119
// begin first_apeman_tamed := true ;
6921: LD_ADDR_EXP 6
6925: PUSH
6926: LD_INT 1
6928: ST_TO_ADDR
// if sci = Gladstone then
6929: LD_VAR 0 2
6933: PUSH
6934: LD_EXP 14
6938: EQUAL
6939: IFFALSE 6953
// Say ( Gladstone , D7b-Glad-1 ) ;
6941: LD_EXP 14
6945: PPUSH
6946: LD_STRING D7b-Glad-1
6948: PPUSH
6949: CALL_OW 88
// if sci = Denis then
6953: LD_VAR 0 2
6957: PUSH
6958: LD_EXP 16
6962: EQUAL
6963: IFFALSE 6977
// Say ( Denis , D7a-Den-1 ) ;
6965: LD_EXP 16
6969: PPUSH
6970: LD_STRING D7a-Den-1
6972: PPUSH
6973: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
6977: LD_VAR 0 2
6981: PUSH
6982: LD_EXP 13
6986: PUSH
6987: LD_EXP 14
6991: PUSH
6992: LD_EXP 16
6996: PUSH
6997: LD_EXP 19
7001: PUSH
7002: LD_EXP 20
7006: PUSH
7007: LD_EXP 21
7011: PUSH
7012: LD_EXP 22
7016: PUSH
7017: LD_EXP 18
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: LIST
7026: LIST
7027: LIST
7028: LIST
7029: LIST
7030: LIST
7031: IN
7032: NOT
7033: IFFALSE 7076
// begin if GetSex ( sci ) = sex_male then
7035: LD_VAR 0 2
7039: PPUSH
7040: CALL_OW 258
7044: PUSH
7045: LD_INT 1
7047: EQUAL
7048: IFFALSE 7064
// Say ( sci , D7c-Sci1-1 ) else
7050: LD_VAR 0 2
7054: PPUSH
7055: LD_STRING D7c-Sci1-1
7057: PPUSH
7058: CALL_OW 88
7062: GO 7076
// Say ( sci , D7c-FSci1-1 ) ;
7064: LD_VAR 0 2
7068: PPUSH
7069: LD_STRING D7c-FSci1-1
7071: PPUSH
7072: CALL_OW 88
// end ; if not sci = Gladstone then
7076: LD_VAR 0 2
7080: PUSH
7081: LD_EXP 14
7085: EQUAL
7086: NOT
7087: IFFALSE 7101
// Say ( Gladstone , D7c-Glad-1 ) ;
7089: LD_EXP 14
7093: PPUSH
7094: LD_STRING D7c-Glad-1
7096: PPUSH
7097: CALL_OW 88
// if Lisa then
7101: LD_EXP 19
7105: IFFALSE 7119
// Say ( Lisa , D8-Lisa-1 ) ;
7107: LD_EXP 19
7111: PPUSH
7112: LD_STRING D8-Lisa-1
7114: PPUSH
7115: CALL_OW 88
// end ; end ;
7119: PPOPN 2
7121: END
