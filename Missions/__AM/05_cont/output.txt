// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 72 0 0
// InitRestrictions ;
  12: CALL 176 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 26
// DebugMode ;
  22: CALL 257 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  26: LD_INT 12
  28: PPUSH
  29: LD_INT 2
  31: PPUSH
  32: CALL 505 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 6 ] [ Difficulty ] ) ;
  36: LD_INT 11
  38: PPUSH
  39: LD_INT 10
  41: PUSH
  42: LD_INT 8
  44: PUSH
  45: LD_INT 6
  47: PUSH
  48: EMPTY
  49: LIST
  50: LIST
  51: LIST
  52: PUSH
  53: LD_OWVAR 67
  57: ARRAY
  58: PPUSH
  59: CALL 505 0 2
// PrepareAmericans ;
  63: CALL 1040 0 0
// Action ;
  67: CALL 1938 0 0
// end ;
  71: END
// export debug ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed , apeman_army , radar_researched , radar_builded ; export apeman_counter , arab_spotted , end_mission ; function Init ; begin
  72: LD_INT 0
  74: PPUSH
// debug := true ;
  75: LD_ADDR_EXP 1
  79: PUSH
  80: LD_INT 1
  82: ST_TO_ADDR
// deltaBuilded := false ;
  83: LD_ADDR_EXP 2
  87: PUSH
  88: LD_INT 0
  90: ST_TO_ADDR
// denisArrives := false ;
  91: LD_ADDR_EXP 3
  95: PUSH
  96: LD_INT 0
  98: ST_TO_ADDR
// radar_allowed := false ;
  99: LD_ADDR_EXP 5
 103: PUSH
 104: LD_INT 0
 106: ST_TO_ADDR
// first_apeman_tamed := false ;
 107: LD_ADDR_EXP 6
 111: PUSH
 112: LD_INT 0
 114: ST_TO_ADDR
// arab_spotted := false ;
 115: LD_ADDR_EXP 11
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// end_mission := false ;
 123: LD_ADDR_EXP 12
 127: PUSH
 128: LD_INT 0
 130: ST_TO_ADDR
// apeman_army := false ;
 131: LD_ADDR_EXP 7
 135: PUSH
 136: LD_INT 0
 138: ST_TO_ADDR
// radar_researched := false ;
 139: LD_ADDR_EXP 8
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// radar_builded := false ;
 147: LD_ADDR_EXP 9
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// apeman_counter := 0 ;
 155: LD_ADDR_EXP 10
 159: PUSH
 160: LD_INT 0
 162: ST_TO_ADDR
// Delta := 0 ;
 163: LD_ADDR_EXP 4
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// end ;
 171: LD_VAR 0 1
 175: RET
// function InitRestrictions ; begin
 176: LD_INT 0
 178: PPUSH
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
 179: LD_INT 7
 181: PPUSH
 182: LD_INT 1
 184: PPUSH
 185: LD_INT 1
 187: PPUSH
 188: CALL_OW 324
// SetRestrict ( b_lab_full , 1 , state_enabled ) ;
 192: LD_INT 8
 194: PPUSH
 195: LD_INT 1
 197: PPUSH
 198: LD_INT 1
 200: PPUSH
 201: CALL_OW 324
// SetRestrict ( b_lab_weapon , 1 , state_enabled ) ;
 205: LD_INT 10
 207: PPUSH
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 1
 213: PPUSH
 214: CALL_OW 324
// SetTech ( tech_gatling , 1 , LoadVariable ( GatlingInGamma , 1 ) ) ;
 218: LD_INT 69
 220: PPUSH
 221: LD_INT 1
 223: PPUSH
 224: LD_STRING GatlingInGamma
 226: PPUSH
 227: LD_INT 1
 229: PPUSH
 230: CALL_OW 30
 234: PPUSH
 235: CALL_OW 322
// SetTech ( tech_weap1 , 1 , state_enabled ) ;
 239: LD_INT 51
 241: PPUSH
 242: LD_INT 1
 244: PPUSH
 245: LD_INT 1
 247: PPUSH
 248: CALL_OW 322
// end ;
 252: LD_VAR 0 1
 256: RET
// function DebugMode ; begin
 257: LD_INT 0
 259: PPUSH
// FogOff ( 1 ) ;
 260: LD_INT 1
 262: PPUSH
 263: CALL_OW 344
// Difficulty := 2 ;
 267: LD_ADDR_OWVAR 67
 271: PUSH
 272: LD_INT 2
 274: ST_TO_ADDR
// end ; end_of_file
 275: LD_VAR 0 1
 279: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 280: LD_INT 0
 282: PPUSH
 283: PPUSH
// if exist_mode then
 284: LD_VAR 0 2
 288: IFFALSE 307
// unit := CreateCharacter ( ident ) else
 290: LD_ADDR_VAR 0 4
 294: PUSH
 295: LD_VAR 0 1
 299: PPUSH
 300: CALL_OW 34
 304: ST_TO_ADDR
 305: GO 322
// unit := NewCharacter ( ident ) ;
 307: LD_ADDR_VAR 0 4
 311: PUSH
 312: LD_VAR 0 1
 316: PPUSH
 317: CALL_OW 25
 321: ST_TO_ADDR
// result := unit ;
 322: LD_ADDR_VAR 0 3
 326: PUSH
 327: LD_VAR 0 4
 331: ST_TO_ADDR
// end ;
 332: LD_VAR 0 3
 336: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 337: LD_INT 0
 339: PPUSH
// uc_side := side ;
 340: LD_ADDR_OWVAR 20
 344: PUSH
 345: LD_VAR 0 1
 349: ST_TO_ADDR
// uc_nation := nation ;
 350: LD_ADDR_OWVAR 21
 354: PUSH
 355: LD_VAR 0 2
 359: ST_TO_ADDR
// vc_chassis := chassis ;
 360: LD_ADDR_OWVAR 37
 364: PUSH
 365: LD_VAR 0 3
 369: ST_TO_ADDR
// vc_engine := engine ;
 370: LD_ADDR_OWVAR 39
 374: PUSH
 375: LD_VAR 0 4
 379: ST_TO_ADDR
// vc_control := control ;
 380: LD_ADDR_OWVAR 38
 384: PUSH
 385: LD_VAR 0 5
 389: ST_TO_ADDR
// vc_weapon := weapon ;
 390: LD_ADDR_OWVAR 40
 394: PUSH
 395: LD_VAR 0 6
 399: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 400: LD_ADDR_OWVAR 41
 404: PUSH
 405: LD_VAR 0 7
 409: ST_TO_ADDR
// result := CreateVehicle ;
 410: LD_ADDR_VAR 0 8
 414: PUSH
 415: CALL_OW 45
 419: ST_TO_ADDR
// end ;
 420: LD_VAR 0 8
 424: RET
// export function SayX ( units , ident ) ; var i ; begin
 425: LD_INT 0
 427: PPUSH
 428: PPUSH
// result := false ;
 429: LD_ADDR_VAR 0 3
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// if not units then
 437: LD_VAR 0 1
 441: NOT
 442: IFFALSE 446
// exit ;
 444: GO 500
// for i in units do
 446: LD_ADDR_VAR 0 4
 450: PUSH
 451: LD_VAR 0 1
 455: PUSH
 456: FOR_IN
 457: IFFALSE 498
// if IsOk ( i ) then
 459: LD_VAR 0 4
 463: PPUSH
 464: CALL_OW 302
 468: IFFALSE 496
// begin Say ( i , ident ) ;
 470: LD_VAR 0 4
 474: PPUSH
 475: LD_VAR 0 2
 479: PPUSH
 480: CALL_OW 88
// result := i ;
 484: LD_ADDR_VAR 0 3
 488: PUSH
 489: LD_VAR 0 4
 493: ST_TO_ADDR
// break ;
 494: GO 498
// end ;
 496: GO 456
 498: POP
 499: POP
// end ;
 500: LD_VAR 0 3
 504: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 505: LD_INT 0
 507: PPUSH
 508: PPUSH
// InitUc ;
 509: CALL_OW 18
// InitHc ;
 513: CALL_OW 19
// uc_side := 0 ;
 517: LD_ADDR_OWVAR 20
 521: PUSH
 522: LD_INT 0
 524: ST_TO_ADDR
// uc_nation := 0 ;
 525: LD_ADDR_OWVAR 21
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// for i = 1 to amount do
 533: LD_ADDR_VAR 0 4
 537: PUSH
 538: DOUBLE
 539: LD_INT 1
 541: DEC
 542: ST_TO_ADDR
 543: LD_VAR 0 2
 547: PUSH
 548: FOR_TO
 549: IFFALSE 583
// begin PrepareHuman ( false , class_apeman , 1 ) ;
 551: LD_INT 0
 553: PPUSH
 554: LD_INT 12
 556: PPUSH
 557: LD_INT 1
 559: PPUSH
 560: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 564: CALL_OW 44
 568: PPUSH
 569: LD_VAR 0 1
 573: PPUSH
 574: LD_INT 0
 576: PPUSH
 577: CALL_OW 49
// end ;
 581: GO 548
 583: POP
 584: POP
// end ;
 585: LD_VAR 0 3
 589: RET
// export function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
 590: LD_INT 0
 592: PPUSH
 593: PPUSH
 594: PPUSH
// if not unit then
 595: LD_VAR 0 1
 599: NOT
 600: IFFALSE 604
// exit ;
 602: GO 1035
// if IsInUnit ( unit ) then
 604: LD_VAR 0 1
 608: PPUSH
 609: CALL_OW 310
 613: IFFALSE 630
// unit := IsDrivenBy ( unit ) ;
 615: LD_ADDR_VAR 0 1
 619: PUSH
 620: LD_VAR 0 1
 624: PPUSH
 625: CALL_OW 311
 629: ST_TO_ADDR
// targets_list := [ ] ;
 630: LD_ADDR_VAR 0 5
 634: PUSH
 635: EMPTY
 636: ST_TO_ADDR
// target := UnitFilter ( enemy_list , [ [ f_lives , 250 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 637: LD_ADDR_VAR 0 4
 641: PUSH
 642: LD_VAR 0 2
 646: PPUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 250
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: PUSH
 657: LD_INT 3
 659: PUSH
 660: LD_INT 34
 662: PUSH
 663: LD_INT 12
 665: PUSH
 666: EMPTY
 667: LIST
 668: LIST
 669: PUSH
 670: EMPTY
 671: LIST
 672: LIST
 673: PUSH
 674: LD_INT 21
 676: PUSH
 677: LD_INT 2
 679: PUSH
 680: EMPTY
 681: LIST
 682: LIST
 683: PUSH
 684: LD_INT 58
 686: PUSH
 687: EMPTY
 688: LIST
 689: PUSH
 690: EMPTY
 691: LIST
 692: LIST
 693: LIST
 694: LIST
 695: PPUSH
 696: CALL_OW 72
 700: ST_TO_ADDR
// if GetDistUnits ( NearestUnitToUnit ( target , unit ) , unit ) < 11 and not IsInUnit ( unit ) then
 701: LD_VAR 0 4
 705: PPUSH
 706: LD_VAR 0 1
 710: PPUSH
 711: CALL_OW 74
 715: PPUSH
 716: LD_VAR 0 1
 720: PPUSH
 721: CALL_OW 296
 725: PUSH
 726: LD_INT 11
 728: LESS
 729: PUSH
 730: LD_VAR 0 1
 734: PPUSH
 735: CALL_OW 310
 739: NOT
 740: AND
 741: IFFALSE 769
// begin ComEnterUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 743: LD_VAR 0 1
 747: PPUSH
 748: LD_VAR 0 4
 752: PPUSH
 753: LD_VAR 0 1
 757: PPUSH
 758: CALL_OW 74
 762: PPUSH
 763: CALL_OW 120
// exit ;
 767: GO 1035
// end ; targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
 769: LD_ADDR_VAR 0 5
 773: PUSH
 774: LD_VAR 0 2
 778: PPUSH
 779: LD_INT 21
 781: PUSH
 782: LD_INT 1
 784: PUSH
 785: EMPTY
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 3
 791: PUSH
 792: LD_INT 54
 794: PUSH
 795: EMPTY
 796: LIST
 797: PUSH
 798: EMPTY
 799: LIST
 800: LIST
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: PPUSH
 806: CALL_OW 72
 810: PUSH
 811: LD_VAR 0 2
 815: PPUSH
 816: LD_INT 21
 818: PUSH
 819: LD_INT 2
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: PPUSH
 826: CALL_OW 72
 830: PUSH
 831: LD_VAR 0 2
 835: PPUSH
 836: LD_INT 21
 838: PUSH
 839: LD_INT 3
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 58
 851: PUSH
 852: EMPTY
 853: LIST
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL_OW 72
 867: PUSH
 868: LD_VAR 0 2
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: ST_TO_ADDR
// for target in targets_list do
 879: LD_ADDR_VAR 0 4
 883: PUSH
 884: LD_VAR 0 5
 888: PUSH
 889: FOR_IN
 890: IFFALSE 1033
// begin if target then
 892: LD_VAR 0 4
 896: IFFALSE 1031
// if GetTag ( unit ) = 11 and ( GetType ( NearestUnitToUnit ( target , unit ) ) = unit_building or GetWeapon ( NearestUnitToUnit ( target , unit ) ) = us_cargo_bay ) then
 898: LD_VAR 0 1
 902: PPUSH
 903: CALL_OW 110
 907: PUSH
 908: LD_INT 11
 910: EQUAL
 911: PUSH
 912: LD_VAR 0 4
 916: PPUSH
 917: LD_VAR 0 1
 921: PPUSH
 922: CALL_OW 74
 926: PPUSH
 927: CALL_OW 247
 931: PUSH
 932: LD_INT 3
 934: EQUAL
 935: PUSH
 936: LD_VAR 0 4
 940: PPUSH
 941: LD_VAR 0 1
 945: PPUSH
 946: CALL_OW 74
 950: PPUSH
 951: CALL_OW 264
 955: PUSH
 956: LD_INT 12
 958: EQUAL
 959: OR
 960: AND
 961: IFFALSE 1007
// begin ComPlaceDelayedCharge ( unit , 0 , 0 , NearestUnitToUnit ( target , unit ) ) ;
 963: LD_VAR 0 1
 967: PPUSH
 968: LD_INT 0
 970: PPUSH
 971: LD_INT 0
 973: PPUSH
 974: LD_VAR 0 4
 978: PPUSH
 979: LD_VAR 0 1
 983: PPUSH
 984: CALL_OW 74
 988: PPUSH
 989: CALL_OW 132
// SetTag ( unit , 0 ) ;
 993: LD_VAR 0 1
 997: PPUSH
 998: LD_INT 0
1000: PPUSH
1001: CALL_OW 109
// end else
1005: GO 1031
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
1007: LD_VAR 0 1
1011: PPUSH
1012: LD_VAR 0 4
1016: PPUSH
1017: LD_VAR 0 1
1021: PPUSH
1022: CALL_OW 74
1026: PPUSH
1027: CALL_OW 115
// end ;
1031: GO 889
1033: POP
1034: POP
// end ; end_of_file
1035: LD_VAR 0 3
1039: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
1040: LD_INT 0
1042: PPUSH
1043: PPUSH
1044: PPUSH
1045: PPUSH
1046: PPUSH
// uc_nation := 1 ;
1047: LD_ADDR_OWVAR 21
1051: PUSH
1052: LD_INT 1
1054: ST_TO_ADDR
// uc_side := 4 ;
1055: LD_ADDR_OWVAR 20
1059: PUSH
1060: LD_INT 4
1062: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
1063: LD_ADDR_EXP 16
1067: PUSH
1068: LD_STRING Denis
1070: PPUSH
1071: LD_INT 0
1073: PPUSH
1074: CALL 280 0 2
1078: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
1079: LD_ADDR_EXP 15
1083: PUSH
1084: LD_STRING Harisson
1086: PPUSH
1087: LD_INT 0
1089: PPUSH
1090: CALL 280 0 2
1094: ST_TO_ADDR
// uc_side := 1 ;
1095: LD_ADDR_OWVAR 20
1099: PUSH
1100: LD_INT 1
1102: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1103: LD_ADDR_EXP 13
1107: PUSH
1108: LD_STRING JMM
1110: PPUSH
1111: LD_EXP 1
1115: NOT
1116: PPUSH
1117: CALL 280 0 2
1121: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
1122: LD_ADDR_EXP 14
1126: PUSH
1127: LD_STRING Gladstone
1129: PPUSH
1130: LD_INT 0
1132: PPUSH
1133: CALL 280 0 2
1137: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
1138: LD_STRING BrownInDelta
1140: PPUSH
1141: LD_EXP 1
1145: PPUSH
1146: CALL_OW 30
1150: IFFALSE 1187
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1152: LD_ADDR_EXP 17
1156: PUSH
1157: LD_STRING Brown
1159: PPUSH
1160: LD_EXP 1
1164: NOT
1165: PPUSH
1166: CALL 280 0 2
1170: ST_TO_ADDR
// tmp := tmp ^ Brown ;
1171: LD_ADDR_VAR 0 5
1175: PUSH
1176: LD_VAR 0 5
1180: PUSH
1181: LD_EXP 17
1185: ADD
1186: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , 0 ) then
1187: LD_STRING DonaldsonInDelta
1189: PPUSH
1190: LD_INT 0
1192: PPUSH
1193: CALL_OW 30
1197: IFFALSE 1234
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1199: LD_ADDR_EXP 18
1203: PUSH
1204: LD_STRING Donaldson
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: CALL 280 0 2
1217: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
1218: LD_ADDR_VAR 0 5
1222: PUSH
1223: LD_VAR 0 5
1227: PUSH
1228: LD_EXP 18
1232: ADD
1233: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
1234: LD_STRING LisaInDelta
1236: PPUSH
1237: LD_EXP 1
1241: PPUSH
1242: CALL_OW 30
1246: IFFALSE 1283
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1248: LD_ADDR_EXP 19
1252: PUSH
1253: LD_STRING Lisa
1255: PPUSH
1256: LD_EXP 1
1260: NOT
1261: PPUSH
1262: CALL 280 0 2
1266: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
1267: LD_ADDR_VAR 0 5
1271: PUSH
1272: LD_VAR 0 5
1276: PUSH
1277: LD_EXP 19
1281: ADD
1282: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
1283: LD_STRING FrankInDelta
1285: PPUSH
1286: LD_EXP 1
1290: PPUSH
1291: CALL_OW 30
1295: IFFALSE 1332
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
1297: LD_ADDR_EXP 20
1301: PUSH
1302: LD_STRING Frank
1304: PPUSH
1305: LD_EXP 1
1309: NOT
1310: PPUSH
1311: CALL 280 0 2
1315: ST_TO_ADDR
// tmp := tmp ^ Frank ;
1316: LD_ADDR_VAR 0 5
1320: PUSH
1321: LD_VAR 0 5
1325: PUSH
1326: LD_EXP 20
1330: ADD
1331: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
1332: LD_STRING BobbyInDelta
1334: PPUSH
1335: LD_INT 0
1337: PPUSH
1338: CALL_OW 30
1342: IFFALSE 1379
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1344: LD_ADDR_EXP 21
1348: PUSH
1349: LD_STRING Bobby
1351: PPUSH
1352: LD_EXP 1
1356: NOT
1357: PPUSH
1358: CALL 280 0 2
1362: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
1363: LD_ADDR_VAR 0 5
1367: PUSH
1368: LD_VAR 0 5
1372: PUSH
1373: LD_EXP 21
1377: ADD
1378: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
1379: LD_STRING CyrusInDelta
1381: PPUSH
1382: LD_INT 0
1384: PPUSH
1385: CALL_OW 30
1389: IFFALSE 1426
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1391: LD_ADDR_EXP 22
1395: PUSH
1396: LD_STRING Cyrus
1398: PPUSH
1399: LD_EXP 1
1403: NOT
1404: PPUSH
1405: CALL 280 0 2
1409: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
1410: LD_ADDR_VAR 0 5
1414: PUSH
1415: LD_VAR 0 5
1419: PUSH
1420: LD_EXP 22
1424: ADD
1425: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
1426: LD_ADDR_EXP 23
1430: PUSH
1431: LD_STRING othersDelta
1433: PPUSH
1434: CALL_OW 31
1438: ST_TO_ADDR
// if not others and debug then
1439: LD_EXP 23
1443: NOT
1444: PUSH
1445: LD_EXP 1
1449: AND
1450: IFFALSE 1515
// begin InitHc ;
1452: CALL_OW 19
// for i = 1 to 2 do
1456: LD_ADDR_VAR 0 2
1460: PUSH
1461: DOUBLE
1462: LD_INT 1
1464: DEC
1465: ST_TO_ADDR
1466: LD_INT 2
1468: PUSH
1469: FOR_TO
1470: IFFALSE 1513
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
1472: LD_INT 0
1474: PPUSH
1475: LD_VAR 0 2
1479: PUSH
1480: LD_INT 4
1482: MOD
1483: PUSH
1484: LD_INT 1
1486: PLUS
1487: PPUSH
1488: LD_INT 3
1490: PPUSH
1491: CALL_OW 380
// others := others ^ CreateHuman ;
1495: LD_ADDR_EXP 23
1499: PUSH
1500: LD_EXP 23
1504: PUSH
1505: CALL_OW 44
1509: ADD
1510: ST_TO_ADDR
// end ;
1511: GO 1469
1513: POP
1514: POP
// end ; if others then
1515: LD_EXP 23
1519: IFFALSE 1537
// tmp := tmp ^ others ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_EXP 23
1535: ADD
1536: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
1537: LD_ADDR_VAR 0 3
1541: PUSH
1542: LD_INT 28
1544: PUSH
1545: LD_INT 49
1547: PUSH
1548: EMPTY
1549: LIST
1550: LIST
1551: PUSH
1552: LD_INT 33
1554: PUSH
1555: LD_INT 54
1557: PUSH
1558: EMPTY
1559: LIST
1560: LIST
1561: PUSH
1562: LD_INT 38
1564: PUSH
1565: LD_INT 56
1567: PUSH
1568: EMPTY
1569: LIST
1570: LIST
1571: PUSH
1572: EMPTY
1573: LIST
1574: LIST
1575: LIST
1576: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1577: LD_ADDR_VAR 0 4
1581: PUSH
1582: LD_INT 1
1584: PPUSH
1585: LD_INT 1
1587: PPUSH
1588: LD_INT 2
1590: PPUSH
1591: LD_INT 2
1593: PPUSH
1594: LD_INT 1
1596: PPUSH
1597: LD_INT 12
1599: PPUSH
1600: LD_INT 80
1602: PPUSH
1603: CALL 337 0 7
1607: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1608: LD_VAR 0 4
1612: PPUSH
1613: LD_INT 1
1615: PPUSH
1616: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1620: LD_VAR 0 4
1624: PPUSH
1625: LD_VAR 0 3
1629: PUSH
1630: LD_INT 1
1632: ARRAY
1633: PUSH
1634: LD_INT 1
1636: ARRAY
1637: PPUSH
1638: LD_VAR 0 3
1642: PUSH
1643: LD_INT 1
1645: ARRAY
1646: PUSH
1647: LD_INT 2
1649: ARRAY
1650: PPUSH
1651: LD_INT 0
1653: PPUSH
1654: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1658: LD_VAR 0 4
1662: PPUSH
1663: LD_INT 1
1665: PPUSH
1666: LD_INT 100
1668: PPUSH
1669: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1673: LD_EXP 23
1677: PUSH
1678: LD_INT 1
1680: ARRAY
1681: PPUSH
1682: LD_VAR 0 4
1686: PPUSH
1687: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1691: LD_ADDR_VAR 0 4
1695: PUSH
1696: LD_INT 1
1698: PPUSH
1699: LD_INT 1
1701: PPUSH
1702: LD_INT 1
1704: PPUSH
1705: LD_INT 2
1707: PPUSH
1708: LD_INT 1
1710: PPUSH
1711: LD_INT 2
1713: PPUSH
1714: LD_INT 80
1716: PPUSH
1717: CALL 337 0 7
1721: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1722: LD_VAR 0 4
1726: PPUSH
1727: LD_INT 1
1729: PPUSH
1730: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1734: LD_VAR 0 4
1738: PPUSH
1739: LD_VAR 0 3
1743: PUSH
1744: LD_INT 2
1746: ARRAY
1747: PUSH
1748: LD_INT 1
1750: ARRAY
1751: PPUSH
1752: LD_VAR 0 3
1756: PUSH
1757: LD_INT 2
1759: ARRAY
1760: PUSH
1761: LD_INT 2
1763: ARRAY
1764: PPUSH
1765: LD_INT 0
1767: PPUSH
1768: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1772: LD_EXP 14
1776: PPUSH
1777: LD_VAR 0 4
1781: PPUSH
1782: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
1786: LD_ADDR_VAR 0 4
1790: PUSH
1791: LD_INT 1
1793: PPUSH
1794: LD_INT 1
1796: PPUSH
1797: LD_INT 1
1799: PPUSH
1800: LD_INT 2
1802: PPUSH
1803: LD_INT 1
1805: PPUSH
1806: LD_INT 3
1808: PPUSH
1809: LD_INT 80
1811: PPUSH
1812: CALL 337 0 7
1816: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1817: LD_VAR 0 4
1821: PPUSH
1822: LD_INT 1
1824: PPUSH
1825: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
1829: LD_VAR 0 4
1833: PPUSH
1834: LD_VAR 0 3
1838: PUSH
1839: LD_INT 3
1841: ARRAY
1842: PUSH
1843: LD_INT 1
1845: ARRAY
1846: PPUSH
1847: LD_VAR 0 3
1851: PUSH
1852: LD_INT 3
1854: ARRAY
1855: PUSH
1856: LD_INT 2
1858: ARRAY
1859: PPUSH
1860: LD_INT 0
1862: PPUSH
1863: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1867: LD_EXP 13
1871: PPUSH
1872: LD_VAR 0 4
1876: PPUSH
1877: CALL_OW 52
// if others > 1 then
1881: LD_EXP 23
1885: PUSH
1886: LD_INT 1
1888: GREATER
1889: IFFALSE 1933
// for i in tmp diff others [ 1 ] do
1891: LD_ADDR_VAR 0 2
1895: PUSH
1896: LD_VAR 0 5
1900: PUSH
1901: LD_EXP 23
1905: PUSH
1906: LD_INT 1
1908: ARRAY
1909: DIFF
1910: PUSH
1911: FOR_IN
1912: IFFALSE 1931
// PlaceUnitArea ( i , startArea , false ) ;
1914: LD_VAR 0 2
1918: PPUSH
1919: LD_INT 5
1921: PPUSH
1922: LD_INT 0
1924: PPUSH
1925: CALL_OW 49
1929: GO 1911
1931: POP
1932: POP
// end ; end_of_file
1933: LD_VAR 0 1
1937: RET
// export function Action ; begin
1938: LD_INT 0
1940: PPUSH
// InGameOn ;
1941: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
1945: LD_INT 28
1947: PPUSH
1948: LD_INT 51
1950: PPUSH
1951: CALL_OW 86
// Wait ( 3 ) ;
1955: LD_INT 3
1957: PPUSH
1958: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
1962: LD_EXP 13
1966: PPUSH
1967: LD_STRING D1d-JMM-1a
1969: PPUSH
1970: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
1974: LD_EXP 15
1978: PPUSH
1979: LD_STRING D1d-Har-1
1981: PPUSH
1982: CALL_OW 94
// InGameOff ;
1986: CALL_OW 9
// SaveForQuickRestart ;
1990: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
1994: LD_STRING M1
1996: PPUSH
1997: CALL_OW 337
// Wait ( 0 0$2 ) ;
2001: LD_INT 70
2003: PPUSH
2004: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
2008: LD_EXP 13
2012: PPUSH
2013: LD_STRING D2-JMM-1
2015: PPUSH
2016: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
2020: LD_EXP 14
2024: PPUSH
2025: LD_STRING D2-Glad-1
2027: PPUSH
2028: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2032: LD_EXP 13
2036: PPUSH
2037: LD_STRING D2-JMM-2
2039: PPUSH
2040: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
2044: LD_EXP 14
2048: PPUSH
2049: LD_STRING D2-Glad-2
2051: PPUSH
2052: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2056: LD_EXP 13
2060: PPUSH
2061: LD_STRING D2-JMM-3
2063: PPUSH
2064: CALL_OW 88
// SetWeather ( 2 , 100 , 150 ) ;
2068: LD_INT 2
2070: PPUSH
2071: LD_INT 100
2073: PPUSH
2074: LD_INT 150
2076: PPUSH
2077: CALL_OW 550
// Wait ( rand ( 4 4$00 , 5 5$00 ) ) ;
2081: LD_INT 8400
2083: PPUSH
2084: LD_INT 10500
2086: PPUSH
2087: CALL_OW 12
2091: PPUSH
2092: CALL_OW 67
// SetWeather ( 0 , 100 , 150 ) ;
2096: LD_INT 0
2098: PPUSH
2099: LD_INT 100
2101: PPUSH
2102: LD_INT 150
2104: PPUSH
2105: CALL_OW 550
// end ;
2109: LD_VAR 0 1
2113: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
2114: LD_INT 22
2116: PUSH
2117: LD_INT 1
2119: PUSH
2120: EMPTY
2121: LIST
2122: LIST
2123: PUSH
2124: LD_INT 3
2126: PUSH
2127: LD_INT 57
2129: PUSH
2130: EMPTY
2131: LIST
2132: PUSH
2133: EMPTY
2134: LIST
2135: LIST
2136: PUSH
2137: LD_INT 30
2139: PUSH
2140: LD_INT 0
2142: PUSH
2143: EMPTY
2144: LIST
2145: LIST
2146: PUSH
2147: EMPTY
2148: LIST
2149: LIST
2150: LIST
2151: PUSH
2152: EMPTY
2153: LIST
2154: PPUSH
2155: CALL_OW 69
2159: PUSH
2160: LD_EXP 2
2164: NOT
2165: AND
2166: IFFALSE 2179
2168: GO 2170
2170: DISABLE
// begin deltaBuilded := true ;
2171: LD_ADDR_EXP 2
2175: PUSH
2176: LD_INT 1
2178: ST_TO_ADDR
// end ;
2179: END
// every 0 0$01 trigger not Delta and deltaBuilded and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) do
2180: LD_EXP 4
2184: NOT
2185: PUSH
2186: LD_EXP 2
2190: AND
2191: PUSH
2192: LD_INT 22
2194: PUSH
2195: LD_INT 1
2197: PUSH
2198: EMPTY
2199: LIST
2200: LIST
2201: PUSH
2202: LD_INT 3
2204: PUSH
2205: LD_INT 57
2207: PUSH
2208: EMPTY
2209: LIST
2210: PUSH
2211: EMPTY
2212: LIST
2213: LIST
2214: PUSH
2215: LD_INT 30
2217: PUSH
2218: LD_INT 0
2220: PUSH
2221: EMPTY
2222: LIST
2223: LIST
2224: PUSH
2225: EMPTY
2226: LIST
2227: LIST
2228: LIST
2229: PUSH
2230: EMPTY
2231: LIST
2232: PPUSH
2233: CALL_OW 69
2237: AND
2238: IFFALSE 2311
2240: GO 2242
2242: DISABLE
// begin enable ;
2243: ENABLE
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
2244: LD_ADDR_EXP 4
2248: PUSH
2249: LD_INT 22
2251: PUSH
2252: LD_INT 1
2254: PUSH
2255: EMPTY
2256: LIST
2257: LIST
2258: PUSH
2259: LD_INT 3
2261: PUSH
2262: LD_INT 57
2264: PUSH
2265: EMPTY
2266: LIST
2267: PUSH
2268: EMPTY
2269: LIST
2270: LIST
2271: PUSH
2272: LD_INT 30
2274: PUSH
2275: LD_INT 0
2277: PUSH
2278: EMPTY
2279: LIST
2280: LIST
2281: PUSH
2282: EMPTY
2283: LIST
2284: LIST
2285: LIST
2286: PUSH
2287: EMPTY
2288: LIST
2289: PPUSH
2290: CALL_OW 69
2294: PUSH
2295: LD_INT 1
2297: ARRAY
2298: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
2299: LD_EXP 4
2303: PPUSH
2304: LD_STRING Delta
2306: PPUSH
2307: CALL_OW 500
// end ;
2311: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched do
2312: LD_INT 1
2314: PPUSH
2315: LD_INT 1
2317: PPUSH
2318: CALL_OW 321
2322: PUSH
2323: LD_INT 2
2325: EQUAL
2326: IFFALSE 2387
2328: GO 2330
2330: DISABLE
// begin DialogueOn ;
2331: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
2335: LD_EXP 14
2339: PPUSH
2340: LD_STRING D3-Glad-1
2342: PPUSH
2343: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2347: LD_EXP 13
2351: PPUSH
2352: LD_STRING D3-JMM-1
2354: PPUSH
2355: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
2359: LD_EXP 14
2363: PPUSH
2364: LD_STRING D3-Glad-2
2366: PPUSH
2367: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
2371: LD_EXP 13
2375: PPUSH
2376: LD_STRING D3-JMM-2
2378: PPUSH
2379: CALL_OW 88
// DialogueOff ;
2383: CALL_OW 7
// end ;
2387: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
2388: LD_INT 2
2390: PPUSH
2391: LD_INT 1
2393: PPUSH
2394: CALL_OW 321
2398: PUSH
2399: LD_INT 2
2401: EQUAL
2402: IFFALSE 2579
2404: GO 2406
2406: DISABLE
2407: LD_INT 0
2409: PPUSH
// begin DialogueOn ;
2410: CALL_OW 6
// if Frank then
2414: LD_EXP 20
2418: IFFALSE 2432
// Say ( Frank , D8a-Frank-1 ) ;
2420: LD_EXP 20
2424: PPUSH
2425: LD_STRING D8a-Frank-1
2427: PPUSH
2428: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
2432: LD_ADDR_VAR 0 1
2436: PUSH
2437: LD_EXP 23
2441: PPUSH
2442: LD_INT 26
2444: PUSH
2445: LD_INT 1
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: PPUSH
2452: CALL_OW 72
2456: PPUSH
2457: LD_STRING D8a-Sol1-1
2459: PPUSH
2460: CALL 425 0 2
2464: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2465: LD_EXP 16
2469: PUSH
2470: LD_EXP 16
2474: PPUSH
2475: CALL_OW 255
2479: PUSH
2480: LD_INT 1
2482: EQUAL
2483: AND
2484: IFFALSE 2498
// Say ( Denis , D8a-Den-1 ) ;
2486: LD_EXP 16
2490: PPUSH
2491: LD_STRING D8a-Den-1
2493: PPUSH
2494: CALL_OW 88
// if sol or Denis or Frank then
2498: LD_VAR 0 1
2502: PUSH
2503: LD_EXP 16
2507: OR
2508: PUSH
2509: LD_EXP 20
2513: OR
2514: IFFALSE 2575
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2516: LD_EXP 23
2520: PPUSH
2521: LD_INT 25
2523: PUSH
2524: LD_INT 4
2526: PUSH
2527: EMPTY
2528: LIST
2529: LIST
2530: PUSH
2531: LD_INT 26
2533: PUSH
2534: LD_INT 1
2536: PUSH
2537: EMPTY
2538: LIST
2539: LIST
2540: PUSH
2541: EMPTY
2542: LIST
2543: LIST
2544: PPUSH
2545: CALL_OW 72
2549: PUSH
2550: LD_VAR 0 1
2554: DIFF
2555: PPUSH
2556: LD_STRING D8a-Sci1-1
2558: PPUSH
2559: CALL 425 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2563: LD_EXP 13
2567: PPUSH
2568: LD_STRING D8a-JMM-1
2570: PPUSH
2571: CALL_OW 88
// end ; DialogueOff ;
2575: CALL_OW 7
// end ;
2579: PPOPN 1
2581: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2582: LD_INT 22
2584: PUSH
2585: LD_INT 1
2587: PUSH
2588: EMPTY
2589: LIST
2590: LIST
2591: PUSH
2592: LD_INT 25
2594: PUSH
2595: LD_INT 16
2597: PUSH
2598: EMPTY
2599: LIST
2600: LIST
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: PPUSH
2606: CALL_OW 69
2610: IFFALSE 2669
2612: GO 2614
2614: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2615: LD_STRING M1a
2617: PPUSH
2618: CALL_OW 337
// case Query ( Q2 ) of 1 :
2622: LD_STRING Q2
2624: PPUSH
2625: CALL_OW 97
2629: PUSH
2630: LD_INT 1
2632: DOUBLE
2633: EQUAL
2634: IFTRUE 2638
2636: GO 2649
2638: POP
// end_mission := true ; 2 :
2639: LD_ADDR_EXP 12
2643: PUSH
2644: LD_INT 1
2646: ST_TO_ADDR
2647: GO 2669
2649: LD_INT 2
2651: DOUBLE
2652: EQUAL
2653: IFTRUE 2657
2655: GO 2668
2657: POP
// end_the_mission_allowed := true ; end ;
2658: LD_ADDR_OWVAR 57
2662: PUSH
2663: LD_INT 1
2665: ST_TO_ADDR
2666: GO 2669
2668: POP
// end ;
2669: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) and Delta do
2670: LD_INT 22
2672: PUSH
2673: LD_INT 1
2675: PUSH
2676: EMPTY
2677: LIST
2678: LIST
2679: PUSH
2680: LD_INT 2
2682: PUSH
2683: LD_INT 30
2685: PUSH
2686: LD_INT 6
2688: PUSH
2689: EMPTY
2690: LIST
2691: LIST
2692: PUSH
2693: LD_INT 30
2695: PUSH
2696: LD_INT 7
2698: PUSH
2699: EMPTY
2700: LIST
2701: LIST
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: LIST
2707: PUSH
2708: EMPTY
2709: LIST
2710: LIST
2711: PPUSH
2712: CALL_OW 69
2716: PUSH
2717: LD_INT 22
2719: PUSH
2720: LD_INT 1
2722: PUSH
2723: EMPTY
2724: LIST
2725: LIST
2726: PUSH
2727: LD_INT 2
2729: PUSH
2730: LD_INT 30
2732: PUSH
2733: LD_INT 2
2735: PUSH
2736: EMPTY
2737: LIST
2738: LIST
2739: PUSH
2740: LD_INT 30
2742: PUSH
2743: LD_INT 3
2745: PUSH
2746: EMPTY
2747: LIST
2748: LIST
2749: PUSH
2750: EMPTY
2751: LIST
2752: LIST
2753: LIST
2754: PUSH
2755: EMPTY
2756: LIST
2757: LIST
2758: PPUSH
2759: CALL_OW 69
2763: AND
2764: PUSH
2765: LD_EXP 4
2769: AND
2770: IFFALSE 3197
2772: GO 2774
2774: DISABLE
// begin Wait ( rand ( 0 0$20 , 0 0$40 ) ) ;
2775: LD_INT 700
2777: PPUSH
2778: LD_INT 1400
2780: PPUSH
2781: CALL_OW 12
2785: PPUSH
2786: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
2790: LD_EXP 16
2794: PPUSH
2795: LD_INT 6
2797: PUSH
2798: LD_INT 9
2800: PUSH
2801: LD_INT 10
2803: PUSH
2804: EMPTY
2805: LIST
2806: LIST
2807: LIST
2808: PUSH
2809: LD_OWVAR 67
2813: ARRAY
2814: PPUSH
2815: LD_INT 0
2817: PPUSH
2818: CALL_OW 49
// ComHold ( Denis ) ;
2822: LD_EXP 16
2826: PPUSH
2827: CALL_OW 140
// InGameOn ;
2831: CALL_OW 8
// DialogueOn ;
2835: CALL_OW 6
// if Delta then
2839: LD_EXP 4
2843: IFFALSE 2856
// CenterNowOnUnits ( Delta ) else
2845: LD_EXP 4
2849: PPUSH
2850: CALL_OW 87
2854: GO 2865
// CenterNowOnUnits ( JMM ) ;
2856: LD_EXP 13
2860: PPUSH
2861: CALL_OW 87
// Say ( Denis , DD-Den-1 ) ;
2865: LD_EXP 16
2869: PPUSH
2870: LD_STRING DD-Den-1
2872: PPUSH
2873: CALL_OW 88
// Say ( JMM , DD-JMM-1 ) ;
2877: LD_EXP 13
2881: PPUSH
2882: LD_STRING DD-JMM-1
2884: PPUSH
2885: CALL_OW 88
// Say ( Denis , DD-Den-2 ) ;
2889: LD_EXP 16
2893: PPUSH
2894: LD_STRING DD-Den-2
2896: PPUSH
2897: CALL_OW 88
// Wait ( 3 ) ;
2901: LD_INT 3
2903: PPUSH
2904: CALL_OW 67
// DialogueOff ;
2908: CALL_OW 7
// InGameOff ;
2912: CALL_OW 9
// repeat wait ( 0 0$01 ) ;
2916: LD_INT 35
2918: PPUSH
2919: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
2923: LD_INT 1
2925: PPUSH
2926: LD_EXP 16
2930: PPUSH
2931: CALL_OW 292
2935: PUSH
2936: LD_EXP 16
2940: PPUSH
2941: CALL_OW 301
2945: OR
2946: IFFALSE 2916
// if IsDead ( Denis ) then
2948: LD_EXP 16
2952: PPUSH
2953: CALL_OW 301
2957: IFFALSE 2961
// exit ;
2959: GO 3197
// SetSide ( Denis , 1 ) ;
2961: LD_EXP 16
2965: PPUSH
2966: LD_INT 1
2968: PPUSH
2969: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
2973: LD_EXP 16
2977: PPUSH
2978: LD_STRING DD-Den-2a
2980: PPUSH
2981: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
2985: LD_INT 35
2987: PPUSH
2988: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
2992: LD_EXP 16
2996: PPUSH
2997: CALL_OW 310
3001: PPUSH
3002: CALL_OW 266
3006: PUSH
3007: LD_INT 6
3009: PUSH
3010: LD_INT 7
3012: PUSH
3013: LD_INT 8
3015: PUSH
3016: EMPTY
3017: LIST
3018: LIST
3019: LIST
3020: IN
3021: PUSH
3022: LD_EXP 16
3026: PPUSH
3027: CALL_OW 301
3031: OR
3032: IFFALSE 2985
// if IsDead ( Denis ) then
3034: LD_EXP 16
3038: PPUSH
3039: CALL_OW 301
3043: IFFALSE 3047
// exit ;
3045: GO 3197
// Say ( Denis , DD-Den-2b ) ;
3047: LD_EXP 16
3051: PPUSH
3052: LD_STRING DD-Den-2b
3054: PPUSH
3055: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
3059: LD_EXP 16
3063: PPUSH
3064: LD_INT 4
3066: PPUSH
3067: CALL_OW 123
// Wait ( 0 0$02 ) ;
3071: LD_INT 70
3073: PPUSH
3074: CALL_OW 67
// DialogueOn ;
3078: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
3082: LD_EXP 16
3086: PPUSH
3087: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3091: LD_EXP 13
3095: PPUSH
3096: LD_STRING D4-JMM-1
3098: PPUSH
3099: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
3103: LD_EXP 16
3107: PPUSH
3108: LD_STRING D4-Den-1
3110: PPUSH
3111: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
3115: LD_EXP 13
3119: PPUSH
3120: LD_STRING D4-JMM-2
3122: PPUSH
3123: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
3127: LD_EXP 16
3131: PPUSH
3132: LD_STRING D4-Den-2
3134: PPUSH
3135: CALL_OW 88
// DialogueOff ;
3139: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
3143: LD_STRING M2
3145: PPUSH
3146: CALL_OW 337
// radar_allowed := true ;
3150: LD_ADDR_EXP 5
3154: PUSH
3155: LD_INT 1
3157: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
3158: LD_INT 6
3160: PPUSH
3161: LD_INT 1
3163: PPUSH
3164: LD_INT 1
3166: PPUSH
3167: CALL_OW 322
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
3171: LD_INT 15
3173: PPUSH
3174: LD_INT 1
3176: PPUSH
3177: LD_INT 1
3179: PPUSH
3180: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
3184: LD_INT 20
3186: PPUSH
3187: LD_INT 1
3189: PPUSH
3190: LD_INT 1
3192: PPUSH
3193: CALL_OW 324
// end ;
3197: END
// every 0 0$1 trigger arab_spotted do var sol , sol2 ;
3198: LD_EXP 11
3202: IFFALSE 3825
3204: GO 3206
3206: DISABLE
3207: LD_INT 0
3209: PPUSH
3210: PPUSH
// begin sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D5-Sol1-1 ) ;
3211: LD_ADDR_VAR 0 1
3215: PUSH
3216: LD_EXP 23
3220: PPUSH
3221: LD_INT 26
3223: PUSH
3224: LD_INT 1
3226: PUSH
3227: EMPTY
3228: LIST
3229: LIST
3230: PPUSH
3231: CALL_OW 72
3235: PPUSH
3236: LD_STRING D5-Sol1-1
3238: PPUSH
3239: CALL 425 0 2
3243: ST_TO_ADDR
// if not sol then
3244: LD_VAR 0 1
3248: NOT
3249: IFFALSE 3253
// exit ;
3251: GO 3825
// repeat wait ( 0 0$01 ) ;
3253: LD_INT 35
3255: PPUSH
3256: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) = 0 ;
3260: LD_INT 22
3262: PUSH
3263: LD_INT 2
3265: PUSH
3266: EMPTY
3267: LIST
3268: LIST
3269: PUSH
3270: LD_INT 21
3272: PUSH
3273: LD_INT 2
3275: PUSH
3276: EMPTY
3277: LIST
3278: LIST
3279: PUSH
3280: EMPTY
3281: LIST
3282: LIST
3283: PPUSH
3284: CALL_OW 69
3288: PUSH
3289: LD_INT 0
3291: EQUAL
3292: IFFALSE 3253
// if IsOk ( sol ) then
3294: LD_VAR 0 1
3298: PPUSH
3299: CALL_OW 302
3303: IFFALSE 3323
// begin sol2 := others diff sol ;
3305: LD_ADDR_VAR 0 2
3309: PUSH
3310: LD_EXP 23
3314: PUSH
3315: LD_VAR 0 1
3319: DIFF
3320: ST_TO_ADDR
// end else
3321: GO 3325
// exit ;
3323: GO 3825
// if not Lisa and not sol2 then
3325: LD_EXP 19
3329: NOT
3330: PUSH
3331: LD_VAR 0 2
3335: NOT
3336: AND
3337: IFFALSE 3341
// exit ;
3339: GO 3825
// DialogueOn ;
3341: CALL_OW 6
// if Lisa then
3345: LD_EXP 19
3349: IFFALSE 3365
// Say ( Lisa , D5a-Lisa-1 ) else
3351: LD_EXP 19
3355: PPUSH
3356: LD_STRING D5a-Lisa-1
3358: PPUSH
3359: CALL_OW 88
3363: GO 3440
// if sol2 then
3365: LD_VAR 0 2
3369: IFFALSE 3440
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3371: LD_VAR 0 2
3375: PUSH
3376: LD_INT 1
3378: ARRAY
3379: PPUSH
3380: CALL_OW 258
3384: PUSH
3385: LD_INT 1
3387: DOUBLE
3388: EQUAL
3389: IFTRUE 3393
3391: GO 3412
3393: POP
// Say ( sol2 [ 1 ] , D5-Sol2-1 ) ; sex_female :
3394: LD_VAR 0 2
3398: PUSH
3399: LD_INT 1
3401: ARRAY
3402: PPUSH
3403: LD_STRING D5-Sol2-1
3405: PPUSH
3406: CALL_OW 88
3410: GO 3440
3412: LD_INT 2
3414: DOUBLE
3415: EQUAL
3416: IFTRUE 3420
3418: GO 3439
3420: POP
// Say ( sol2 [ 1 ] , D5-FSol2-1 ) ; end ;
3421: LD_VAR 0 2
3425: PUSH
3426: LD_INT 1
3428: ARRAY
3429: PPUSH
3430: LD_STRING D5-FSol2-1
3432: PPUSH
3433: CALL_OW 88
3437: GO 3440
3439: POP
// Say ( sol , D5-Sol1-2 ) ;
3440: LD_VAR 0 1
3444: PPUSH
3445: LD_STRING D5-Sol1-2
3447: PPUSH
3448: CALL_OW 88
// if Lisa then
3452: LD_EXP 19
3456: IFFALSE 3472
// Say ( Lisa , D5a-Lisa-2 ) else
3458: LD_EXP 19
3462: PPUSH
3463: LD_STRING D5a-Lisa-2
3465: PPUSH
3466: CALL_OW 88
3470: GO 3547
// if sol2 then
3472: LD_VAR 0 2
3476: IFFALSE 3547
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3478: LD_VAR 0 2
3482: PUSH
3483: LD_INT 1
3485: ARRAY
3486: PPUSH
3487: CALL_OW 258
3491: PUSH
3492: LD_INT 1
3494: DOUBLE
3495: EQUAL
3496: IFTRUE 3500
3498: GO 3519
3500: POP
// Say ( sol2 [ 1 ] , D5-Sol2-2 ) ; sex_female :
3501: LD_VAR 0 2
3505: PUSH
3506: LD_INT 1
3508: ARRAY
3509: PPUSH
3510: LD_STRING D5-Sol2-2
3512: PPUSH
3513: CALL_OW 88
3517: GO 3547
3519: LD_INT 2
3521: DOUBLE
3522: EQUAL
3523: IFTRUE 3527
3525: GO 3546
3527: POP
// Say ( sol2 [ 1 ] , D5-FSol2-2 ) ; end ;
3528: LD_VAR 0 2
3532: PUSH
3533: LD_INT 1
3535: ARRAY
3536: PPUSH
3537: LD_STRING D5-FSol2-2
3539: PPUSH
3540: CALL_OW 88
3544: GO 3547
3546: POP
// Say ( sol , D5a-Sol1-3 ) ;
3547: LD_VAR 0 1
3551: PPUSH
3552: LD_STRING D5a-Sol1-3
3554: PPUSH
3555: CALL_OW 88
// if Lisa then
3559: LD_EXP 19
3563: IFFALSE 3577
// Say ( Lisa , D5a-Lisa-3 ) ;
3565: LD_EXP 19
3569: PPUSH
3570: LD_STRING D5a-Lisa-3
3572: PPUSH
3573: CALL_OW 88
// if not sol2 then
3577: LD_VAR 0 2
3581: NOT
3582: IFFALSE 3590
// begin DialogueOff ;
3584: CALL_OW 7
// exit ;
3588: GO 3825
// end ; case GetSex ( sol2 [ 1 ] ) of sex_male :
3590: LD_VAR 0 2
3594: PUSH
3595: LD_INT 1
3597: ARRAY
3598: PPUSH
3599: CALL_OW 258
3603: PUSH
3604: LD_INT 1
3606: DOUBLE
3607: EQUAL
3608: IFTRUE 3612
3610: GO 3631
3612: POP
// Say ( sol2 [ 1 ] , D5-Sol2-3 ) ; sex_female :
3613: LD_VAR 0 2
3617: PUSH
3618: LD_INT 1
3620: ARRAY
3621: PPUSH
3622: LD_STRING D5-Sol2-3
3624: PPUSH
3625: CALL_OW 88
3629: GO 3659
3631: LD_INT 2
3633: DOUBLE
3634: EQUAL
3635: IFTRUE 3639
3637: GO 3658
3639: POP
// Say ( sol2 [ 1 ] , D5-FSol2-3 ) ; end ;
3640: LD_VAR 0 2
3644: PUSH
3645: LD_INT 1
3647: ARRAY
3648: PPUSH
3649: LD_STRING D5-FSol2-3
3651: PPUSH
3652: CALL_OW 88
3656: GO 3659
3658: POP
// Say ( sol , D5-Sol1-4 ) ;
3659: LD_VAR 0 1
3663: PPUSH
3664: LD_STRING D5-Sol1-4
3666: PPUSH
3667: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3671: LD_VAR 0 2
3675: PUSH
3676: LD_INT 1
3678: ARRAY
3679: PPUSH
3680: CALL_OW 258
3684: PUSH
3685: LD_INT 1
3687: DOUBLE
3688: EQUAL
3689: IFTRUE 3693
3691: GO 3712
3693: POP
// Say ( sol2 [ 1 ] , D5-Sol2-4 ) ; sex_female :
3694: LD_VAR 0 2
3698: PUSH
3699: LD_INT 1
3701: ARRAY
3702: PPUSH
3703: LD_STRING D5-Sol2-4
3705: PPUSH
3706: CALL_OW 88
3710: GO 3740
3712: LD_INT 2
3714: DOUBLE
3715: EQUAL
3716: IFTRUE 3720
3718: GO 3739
3720: POP
// Say ( sol2 [ 1 ] , D5-FSol2-4 ) ; end ;
3721: LD_VAR 0 2
3725: PUSH
3726: LD_INT 1
3728: ARRAY
3729: PPUSH
3730: LD_STRING D5-FSol2-4
3732: PPUSH
3733: CALL_OW 88
3737: GO 3740
3739: POP
// Say ( sol , D5-Sol1-5 ) ;
3740: LD_VAR 0 1
3744: PPUSH
3745: LD_STRING D5-Sol1-5
3747: PPUSH
3748: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3752: LD_VAR 0 2
3756: PUSH
3757: LD_INT 1
3759: ARRAY
3760: PPUSH
3761: CALL_OW 258
3765: PUSH
3766: LD_INT 1
3768: DOUBLE
3769: EQUAL
3770: IFTRUE 3774
3772: GO 3793
3774: POP
// Say ( sol2 [ 1 ] , D5-Sol2-5 ) ; sex_female :
3775: LD_VAR 0 2
3779: PUSH
3780: LD_INT 1
3782: ARRAY
3783: PPUSH
3784: LD_STRING D5-Sol2-5
3786: PPUSH
3787: CALL_OW 88
3791: GO 3821
3793: LD_INT 2
3795: DOUBLE
3796: EQUAL
3797: IFTRUE 3801
3799: GO 3820
3801: POP
// Say ( sol2 [ 1 ] , D5-FSol2-5 ) ; end ;
3802: LD_VAR 0 2
3806: PUSH
3807: LD_INT 1
3809: ARRAY
3810: PPUSH
3811: LD_STRING D5-FSol2-5
3813: PPUSH
3814: CALL_OW 88
3818: GO 3821
3820: POP
// DialogueOff ;
3821: CALL_OW 7
// end ;
3825: PPOPN 2
3827: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 5 do
3828: LD_INT 22
3830: PUSH
3831: LD_INT 1
3833: PUSH
3834: EMPTY
3835: LIST
3836: LIST
3837: PUSH
3838: LD_INT 25
3840: PUSH
3841: LD_INT 16
3843: PUSH
3844: EMPTY
3845: LIST
3846: LIST
3847: PUSH
3848: EMPTY
3849: LIST
3850: LIST
3851: PPUSH
3852: CALL_OW 69
3856: PUSH
3857: LD_INT 5
3859: GREATEREQUAL
3860: IFFALSE 3880
3862: GO 3864
3864: DISABLE
// begin ChangeMissionObjectives ( M1b ) ;
3865: LD_STRING M1b
3867: PPUSH
3868: CALL_OW 337
// apeman_army := true ;
3872: LD_ADDR_EXP 7
3876: PUSH
3877: LD_INT 1
3879: ST_TO_ADDR
// end ;
3880: END
// every 0 0$1 trigger GetTech ( tech_radar , 1 ) = state_researched do
3881: LD_INT 6
3883: PPUSH
3884: LD_INT 1
3886: PPUSH
3887: CALL_OW 321
3891: PUSH
3892: LD_INT 2
3894: EQUAL
3895: IFFALSE 3915
3897: GO 3899
3899: DISABLE
// begin ChangeMissionObjectives ( M2a ) ;
3900: LD_STRING M2a
3902: PPUSH
3903: CALL_OW 337
// radar_researched := true ;
3907: LD_ADDR_EXP 8
3911: PUSH
3912: LD_INT 1
3914: ST_TO_ADDR
// end ;
3915: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_weapon , us_radar ] , [ f_bweapon , us_radar ] ] ] ) do
3916: LD_INT 22
3918: PUSH
3919: LD_INT 1
3921: PUSH
3922: EMPTY
3923: LIST
3924: LIST
3925: PUSH
3926: LD_INT 2
3928: PUSH
3929: LD_INT 34
3931: PUSH
3932: LD_INT 11
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: PUSH
3939: LD_INT 35
3941: PUSH
3942: LD_INT 11
3944: PUSH
3945: EMPTY
3946: LIST
3947: LIST
3948: PUSH
3949: EMPTY
3950: LIST
3951: LIST
3952: LIST
3953: PUSH
3954: EMPTY
3955: LIST
3956: LIST
3957: PPUSH
3958: CALL_OW 69
3962: IFFALSE 3982
3964: GO 3966
3966: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
3967: LD_STRING M2b
3969: PPUSH
3970: CALL_OW 337
// radar_builded := true ;
3974: LD_ADDR_EXP 9
3978: PUSH
3979: LD_INT 1
3981: ST_TO_ADDR
// end ;
3982: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 and not first_apeman_tamed do
3983: LD_INT 22
3985: PUSH
3986: LD_INT 0
3988: PUSH
3989: EMPTY
3990: LIST
3991: LIST
3992: PUSH
3993: LD_INT 25
3995: PUSH
3996: LD_INT 12
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: PUSH
4003: EMPTY
4004: LIST
4005: LIST
4006: PPUSH
4007: CALL_OW 69
4011: PUSH
4012: LD_INT 0
4014: EQUAL
4015: PUSH
4016: LD_EXP 6
4020: NOT
4021: AND
4022: IFFALSE 4034
4024: GO 4026
4026: DISABLE
// YouLost ( Apeman ) ;
4027: LD_STRING Apeman
4029: PPUSH
4030: CALL_OW 104
4034: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 7 do var i , filter ;
4035: LD_INT 22
4037: PUSH
4038: LD_INT 1
4040: PUSH
4041: EMPTY
4042: LIST
4043: LIST
4044: PUSH
4045: LD_INT 25
4047: PUSH
4048: LD_INT 16
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: PUSH
4055: EMPTY
4056: LIST
4057: LIST
4058: PPUSH
4059: CALL_OW 69
4063: PUSH
4064: LD_INT 7
4066: GREATEREQUAL
4067: IFFALSE 4165
4069: GO 4071
4071: DISABLE
4072: LD_INT 0
4074: PPUSH
4075: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ^ JMM ;
4076: LD_ADDR_VAR 0 2
4080: PUSH
4081: LD_INT 22
4083: PUSH
4084: LD_INT 1
4086: PUSH
4087: EMPTY
4088: LIST
4089: LIST
4090: PUSH
4091: LD_INT 21
4093: PUSH
4094: LD_INT 1
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: PUSH
4101: LD_INT 25
4103: PUSH
4104: LD_INT 4
4106: PUSH
4107: EMPTY
4108: LIST
4109: LIST
4110: PUSH
4111: EMPTY
4112: LIST
4113: LIST
4114: LIST
4115: PPUSH
4116: CALL_OW 69
4120: PUSH
4121: LD_EXP 13
4125: ADD
4126: ST_TO_ADDR
// if filter then
4127: LD_VAR 0 2
4131: IFFALSE 4165
// for i in filter do
4133: LD_ADDR_VAR 0 1
4137: PUSH
4138: LD_VAR 0 2
4142: PUSH
4143: FOR_IN
4144: IFFALSE 4163
// AddExperience ( i , 4 , 12500 ) ;
4146: LD_VAR 0 1
4150: PPUSH
4151: LD_INT 4
4153: PPUSH
4154: LD_INT 12500
4156: PPUSH
4157: CALL_OW 492
4161: GO 4143
4163: POP
4164: POP
// end ;
4165: PPOPN 2
4167: END
// every 0 0$1 trigger end_mission do var i , tmp ;
4168: LD_EXP 12
4172: IFFALSE 5133
4174: GO 4176
4176: DISABLE
4177: LD_INT 0
4179: PPUSH
4180: PPUSH
// begin if FilterAllUnits ( [ f_side , 2 ] ) then
4181: LD_INT 22
4183: PUSH
4184: LD_INT 2
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: PPUSH
4191: CALL_OW 69
4195: IFFALSE 4233
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
4197: LD_ADDR_VAR 0 1
4201: PUSH
4202: LD_INT 22
4204: PUSH
4205: LD_INT 2
4207: PUSH
4208: EMPTY
4209: LIST
4210: LIST
4211: PPUSH
4212: CALL_OW 69
4216: PUSH
4217: FOR_IN
4218: IFFALSE 4231
// RemoveUnit ( i ) ;
4220: LD_VAR 0 1
4224: PPUSH
4225: CALL_OW 64
4229: GO 4217
4231: POP
4232: POP
// if apeman_army then
4233: LD_EXP 7
4237: IFFALSE 4251
// AddMedal ( Tame , 1 ) else
4239: LD_STRING Tame
4241: PPUSH
4242: LD_INT 1
4244: PPUSH
4245: CALL_OW 101
4249: GO 4262
// AddMedal ( Tame , - 1 ) ;
4251: LD_STRING Tame
4253: PPUSH
4254: LD_INT 1
4256: NEG
4257: PPUSH
4258: CALL_OW 101
// if radar_researched then
4262: LD_EXP 8
4266: IFFALSE 4290
// begin SaveVariable ( true , radarResInDelta ) ;
4268: LD_INT 1
4270: PPUSH
4271: LD_STRING radarResInDelta
4273: PPUSH
4274: CALL_OW 39
// AddMedal ( Radar , 1 ) ;
4278: LD_STRING Radar
4280: PPUSH
4281: LD_INT 1
4283: PPUSH
4284: CALL_OW 101
// end else
4288: GO 4320
// if radar_allowed then
4290: LD_EXP 5
4294: IFFALSE 4309
// AddMedal ( Radar , - 2 ) else
4296: LD_STRING Radar
4298: PPUSH
4299: LD_INT 2
4301: NEG
4302: PPUSH
4303: CALL_OW 101
4307: GO 4320
// AddMedal ( Radar , - 1 ) ;
4309: LD_STRING Radar
4311: PPUSH
4312: LD_INT 1
4314: NEG
4315: PPUSH
4316: CALL_OW 101
// if radar_builded then
4320: LD_EXP 9
4324: IFFALSE 4338
// AddMedal ( BuildRadar , 1 ) else
4326: LD_STRING BuildRadar
4328: PPUSH
4329: LD_INT 1
4331: PPUSH
4332: CALL_OW 101
4336: GO 4349
// AddMedal ( BuildRadar , - 1 ) ;
4338: LD_STRING BuildRadar
4340: PPUSH
4341: LD_INT 1
4343: NEG
4344: PPUSH
4345: CALL_OW 101
// GiveMedals ( MAIN ) ;
4349: LD_STRING MAIN
4351: PPUSH
4352: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
4356: LD_ADDR_VAR 0 2
4360: PUSH
4361: LD_INT 22
4363: PUSH
4364: LD_INT 1
4366: PUSH
4367: EMPTY
4368: LIST
4369: LIST
4370: PUSH
4371: LD_INT 21
4373: PUSH
4374: LD_INT 1
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: PUSH
4381: LD_INT 2
4383: PUSH
4384: LD_INT 25
4386: PUSH
4387: LD_INT 1
4389: PUSH
4390: EMPTY
4391: LIST
4392: LIST
4393: PUSH
4394: LD_INT 25
4396: PUSH
4397: LD_INT 2
4399: PUSH
4400: EMPTY
4401: LIST
4402: LIST
4403: PUSH
4404: LD_INT 25
4406: PUSH
4407: LD_INT 3
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: PUSH
4414: LD_INT 25
4416: PUSH
4417: LD_INT 4
4419: PUSH
4420: EMPTY
4421: LIST
4422: LIST
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: LIST
4428: LIST
4429: LIST
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: LIST
4435: PPUSH
4436: CALL_OW 69
4440: ST_TO_ADDR
// RewardPeople ( tmp ) ;
4441: LD_VAR 0 2
4445: PPUSH
4446: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
4450: LD_EXP 13
4454: PPUSH
4455: LD_STRING JMM
4457: PPUSH
4458: CALL_OW 38
// if IsOk ( Gladstone ) then
4462: LD_EXP 14
4466: PPUSH
4467: CALL_OW 302
4471: IFFALSE 4495
// begin SaveCharacters ( Gladstone , Gladstone ) ;
4473: LD_EXP 14
4477: PPUSH
4478: LD_STRING Gladstone
4480: PPUSH
4481: CALL_OW 38
// SaveVariable ( true , GladstoneInDelta ) ;
4485: LD_INT 1
4487: PPUSH
4488: LD_STRING GladstoneInDelta
4490: PPUSH
4491: CALL_OW 39
// end ; if IsOk ( Denis ) and GetSide ( Denis ) = 1 then
4495: LD_EXP 16
4499: PPUSH
4500: CALL_OW 302
4504: PUSH
4505: LD_EXP 16
4509: PPUSH
4510: CALL_OW 255
4514: PUSH
4515: LD_INT 1
4517: EQUAL
4518: AND
4519: IFFALSE 4543
// begin SaveCharacters ( Denis , Denis ) ;
4521: LD_EXP 16
4525: PPUSH
4526: LD_STRING Denis
4528: PPUSH
4529: CALL_OW 38
// SaveVariable ( true , DenisInDelta ) ;
4533: LD_INT 1
4535: PPUSH
4536: LD_STRING DenisInDelta
4538: PPUSH
4539: CALL_OW 39
// end ; if IsOk ( Lisa ) then
4543: LD_EXP 19
4547: PPUSH
4548: CALL_OW 302
4552: IFFALSE 4576
// begin SaveCharacters ( Lisa , Lisa ) ;
4554: LD_EXP 19
4558: PPUSH
4559: LD_STRING Lisa
4561: PPUSH
4562: CALL_OW 38
// SaveVariable ( true , LisaInDelta ) ;
4566: LD_INT 1
4568: PPUSH
4569: LD_STRING LisaInDelta
4571: PPUSH
4572: CALL_OW 39
// end ; if IsOk ( Frank ) then
4576: LD_EXP 20
4580: PPUSH
4581: CALL_OW 302
4585: IFFALSE 4609
// begin SaveCharacters ( Frank , Frank ) ;
4587: LD_EXP 20
4591: PPUSH
4592: LD_STRING Frank
4594: PPUSH
4595: CALL_OW 38
// SaveVariable ( true , FrankInDelta ) ;
4599: LD_INT 1
4601: PPUSH
4602: LD_STRING FrankInDelta
4604: PPUSH
4605: CALL_OW 39
// end ; if IsOk ( Bobby ) then
4609: LD_EXP 21
4613: PPUSH
4614: CALL_OW 302
4618: IFFALSE 4642
// begin SaveCharacters ( Bobby , Bobby ) ;
4620: LD_EXP 21
4624: PPUSH
4625: LD_STRING Bobby
4627: PPUSH
4628: CALL_OW 38
// SaveVariable ( true , BobbyInDelta ) ;
4632: LD_INT 1
4634: PPUSH
4635: LD_STRING BobbyInDelta
4637: PPUSH
4638: CALL_OW 39
// end ; if IsOk ( Cyrus ) then
4642: LD_EXP 22
4646: PPUSH
4647: CALL_OW 302
4651: IFFALSE 4675
// begin SaveCharacters ( Cyrus , Cyrus ) ;
4653: LD_EXP 22
4657: PPUSH
4658: LD_STRING Cyrus
4660: PPUSH
4661: CALL_OW 38
// SaveVariable ( true , CyrusInDelta ) ;
4665: LD_INT 1
4667: PPUSH
4668: LD_STRING CyrusInDelta
4670: PPUSH
4671: CALL_OW 39
// end ; if others then
4675: LD_EXP 23
4679: IFFALSE 4693
// SaveCharacters ( others , othersInDelta ) ;
4681: LD_EXP 23
4685: PPUSH
4686: LD_STRING othersInDelta
4688: PPUSH
4689: CALL_OW 38
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) then
4693: LD_INT 22
4695: PUSH
4696: LD_INT 1
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PUSH
4703: LD_INT 25
4705: PUSH
4706: LD_INT 16
4708: PUSH
4709: EMPTY
4710: LIST
4711: LIST
4712: PUSH
4713: EMPTY
4714: LIST
4715: LIST
4716: PPUSH
4717: CALL_OW 69
4721: IFFALSE 4759
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) , apeInDelta ) ;
4723: LD_INT 22
4725: PUSH
4726: LD_INT 1
4728: PUSH
4729: EMPTY
4730: LIST
4731: LIST
4732: PUSH
4733: LD_INT 25
4735: PUSH
4736: LD_INT 16
4738: PUSH
4739: EMPTY
4740: LIST
4741: LIST
4742: PUSH
4743: EMPTY
4744: LIST
4745: LIST
4746: PPUSH
4747: CALL_OW 69
4751: PPUSH
4752: LD_STRING apeInDelta
4754: PPUSH
4755: CALL_OW 38
// tmp := [ ] ;
4759: LD_ADDR_VAR 0 2
4763: PUSH
4764: EMPTY
4765: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) then
4766: LD_INT 22
4768: PUSH
4769: LD_INT 1
4771: PUSH
4772: EMPTY
4773: LIST
4774: LIST
4775: PUSH
4776: LD_INT 21
4778: PUSH
4779: LD_INT 2
4781: PUSH
4782: EMPTY
4783: LIST
4784: LIST
4785: PUSH
4786: EMPTY
4787: LIST
4788: LIST
4789: PPUSH
4790: CALL_OW 69
4794: IFFALSE 4905
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
4796: LD_ADDR_VAR 0 1
4800: PUSH
4801: LD_INT 22
4803: PUSH
4804: LD_INT 1
4806: PUSH
4807: EMPTY
4808: LIST
4809: LIST
4810: PUSH
4811: LD_INT 21
4813: PUSH
4814: LD_INT 2
4816: PUSH
4817: EMPTY
4818: LIST
4819: LIST
4820: PUSH
4821: EMPTY
4822: LIST
4823: LIST
4824: PPUSH
4825: CALL_OW 69
4829: PUSH
4830: FOR_IN
4831: IFFALSE 4903
// tmp := tmp ^ [ GetNation ( i ) , GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
4833: LD_ADDR_VAR 0 2
4837: PUSH
4838: LD_VAR 0 2
4842: PUSH
4843: LD_VAR 0 1
4847: PPUSH
4848: CALL_OW 248
4852: PUSH
4853: LD_VAR 0 1
4857: PPUSH
4858: CALL_OW 265
4862: PUSH
4863: LD_VAR 0 1
4867: PPUSH
4868: CALL_OW 262
4872: PUSH
4873: LD_VAR 0 1
4877: PPUSH
4878: CALL_OW 263
4882: PUSH
4883: LD_VAR 0 1
4887: PPUSH
4888: CALL_OW 264
4892: PUSH
4893: EMPTY
4894: LIST
4895: LIST
4896: LIST
4897: LIST
4898: LIST
4899: ADD
4900: ST_TO_ADDR
4901: GO 4830
4903: POP
4904: POP
// if tmp then
4905: LD_VAR 0 2
4909: IFFALSE 4923
// SaveVariable ( tmp , vehiclesInDelta ) ;
4911: LD_VAR 0 2
4915: PPUSH
4916: LD_STRING vehiclesInDelta
4918: PPUSH
4919: CALL_OW 39
// tmp := [ ] ;
4923: LD_ADDR_VAR 0 2
4927: PUSH
4928: EMPTY
4929: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
4930: LD_INT 22
4932: PUSH
4933: LD_INT 1
4935: PUSH
4936: EMPTY
4937: LIST
4938: LIST
4939: PUSH
4940: LD_INT 21
4942: PUSH
4943: LD_INT 3
4945: PUSH
4946: EMPTY
4947: LIST
4948: LIST
4949: PUSH
4950: EMPTY
4951: LIST
4952: LIST
4953: PPUSH
4954: CALL_OW 69
4958: IFFALSE 5111
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4960: LD_ADDR_VAR 0 1
4964: PUSH
4965: LD_INT 22
4967: PUSH
4968: LD_INT 1
4970: PUSH
4971: EMPTY
4972: LIST
4973: LIST
4974: PUSH
4975: LD_INT 21
4977: PUSH
4978: LD_INT 3
4980: PUSH
4981: EMPTY
4982: LIST
4983: LIST
4984: PUSH
4985: EMPTY
4986: LIST
4987: LIST
4988: PPUSH
4989: CALL_OW 69
4993: PUSH
4994: FOR_IN
4995: IFFALSE 5109
// tmp := tmp ^ [ [ GetBType ( i ) , GetBLevel ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
4997: LD_ADDR_VAR 0 2
5001: PUSH
5002: LD_VAR 0 2
5006: PUSH
5007: LD_VAR 0 1
5011: PPUSH
5012: CALL_OW 266
5016: PUSH
5017: LD_VAR 0 1
5021: PPUSH
5022: CALL_OW 267
5026: PUSH
5027: LD_VAR 0 1
5031: PPUSH
5032: CALL_OW 250
5036: PUSH
5037: LD_VAR 0 1
5041: PPUSH
5042: CALL_OW 251
5046: PUSH
5047: LD_VAR 0 1
5051: PPUSH
5052: CALL_OW 254
5056: PUSH
5057: LD_VAR 0 1
5061: PPUSH
5062: LD_INT 1
5064: PPUSH
5065: CALL_OW 268
5069: PUSH
5070: LD_VAR 0 1
5074: PPUSH
5075: LD_INT 2
5077: PPUSH
5078: CALL_OW 268
5082: PUSH
5083: LD_VAR 0 1
5087: PPUSH
5088: CALL_OW 269
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: LIST
5097: LIST
5098: LIST
5099: LIST
5100: LIST
5101: LIST
5102: PUSH
5103: EMPTY
5104: LIST
5105: ADD
5106: ST_TO_ADDR
5107: GO 4994
5109: POP
5110: POP
// if tmp then
5111: LD_VAR 0 2
5115: IFFALSE 5129
// SaveVariable ( tmp , buildingsInDelta ) ;
5117: LD_VAR 0 2
5121: PPUSH
5122: LD_STRING buildingsInDelta
5124: PPUSH
5125: CALL_OW 39
// YouWin ;
5129: CALL_OW 103
// end ; end_of_file
5133: PPOPN 2
5135: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un , tmp ; begin
5136: LD_INT 0
5138: PPUSH
5139: PPUSH
5140: PPUSH
5141: PPUSH
// InitHc ;
5142: CALL_OW 19
// InitUc ;
5146: CALL_OW 18
// uc_side := 2 ;
5150: LD_ADDR_OWVAR 20
5154: PUSH
5155: LD_INT 2
5157: ST_TO_ADDR
// uc_nation := 2 ;
5158: LD_ADDR_OWVAR 21
5162: PUSH
5163: LD_INT 2
5165: ST_TO_ADDR
// if not amount then
5166: LD_VAR 0 1
5170: NOT
5171: IFFALSE 5175
// exit ;
5173: GO 5298
// for i = 1 to amount do
5175: LD_ADDR_VAR 0 5
5179: PUSH
5180: DOUBLE
5181: LD_INT 1
5183: DEC
5184: ST_TO_ADDR
5185: LD_VAR 0 1
5189: PUSH
5190: FOR_TO
5191: IFFALSE 5286
// begin PrepareHuman ( false , 1 , skill ) ;
5193: LD_INT 0
5195: PPUSH
5196: LD_INT 1
5198: PPUSH
5199: LD_VAR 0 2
5203: PPUSH
5204: CALL_OW 380
// un := CreateHuman ;
5208: LD_ADDR_VAR 0 6
5212: PUSH
5213: CALL_OW 44
5217: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
5218: LD_ADDR_VAR 0 7
5222: PUSH
5223: LD_VAR 0 7
5227: PPUSH
5228: LD_INT 1
5230: PPUSH
5231: LD_VAR 0 6
5235: PPUSH
5236: CALL_OW 2
5240: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5241: LD_VAR 0 6
5245: PPUSH
5246: LD_VAR 0 3
5250: PPUSH
5251: LD_INT 0
5253: PPUSH
5254: CALL_OW 49
// if i mod 3 = 0 then
5258: LD_VAR 0 5
5262: PUSH
5263: LD_INT 3
5265: MOD
5266: PUSH
5267: LD_INT 0
5269: EQUAL
5270: IFFALSE 5284
// SetTag ( un , 11 ) ;
5272: LD_VAR 0 6
5276: PPUSH
5277: LD_INT 11
5279: PPUSH
5280: CALL_OW 109
// end ;
5284: GO 5190
5286: POP
5287: POP
// result := tmp ;
5288: LD_ADDR_VAR 0 4
5292: PUSH
5293: LD_VAR 0 7
5297: ST_TO_ADDR
// end ;
5298: LD_VAR 0 4
5302: RET
// export ar_forces , ap_killers ; every 0 0$1 trigger Delta do var i , timer , more_troops , skill , eng , un , veh , force ;
5303: LD_EXP 4
5307: IFFALSE 6224
5309: GO 5311
5311: DISABLE
5312: LD_INT 0
5314: PPUSH
5315: PPUSH
5316: PPUSH
5317: PPUSH
5318: PPUSH
5319: PPUSH
5320: PPUSH
5321: PPUSH
// begin more_troops := false ;
5322: LD_ADDR_VAR 0 3
5326: PUSH
5327: LD_INT 0
5329: ST_TO_ADDR
// skill := [ 3 , 4 , 5 ] [ Difficulty ] ;
5330: LD_ADDR_VAR 0 4
5334: PUSH
5335: LD_INT 3
5337: PUSH
5338: LD_INT 4
5340: PUSH
5341: LD_INT 5
5343: PUSH
5344: EMPTY
5345: LIST
5346: LIST
5347: LIST
5348: PUSH
5349: LD_OWVAR 67
5353: ARRAY
5354: ST_TO_ADDR
// timer := [ 5 5$00 , 4 4$00 , 3 3$00 ] [ Difficulty ] ;
5355: LD_ADDR_VAR 0 2
5359: PUSH
5360: LD_INT 10500
5362: PUSH
5363: LD_INT 8400
5365: PUSH
5366: LD_INT 6300
5368: PUSH
5369: EMPTY
5370: LIST
5371: LIST
5372: LIST
5373: PUSH
5374: LD_OWVAR 67
5378: ARRAY
5379: ST_TO_ADDR
// force := [ ] ;
5380: LD_ADDR_VAR 0 8
5384: PUSH
5385: EMPTY
5386: ST_TO_ADDR
// ar_forces := [ ] ;
5387: LD_ADDR_EXP 24
5391: PUSH
5392: EMPTY
5393: ST_TO_ADDR
// ap_killers := [ ] ;
5394: LD_ADDR_EXP 25
5398: PUSH
5399: EMPTY
5400: ST_TO_ADDR
// Wait ( timer ) ;
5401: LD_VAR 0 2
5405: PPUSH
5406: CALL_OW 67
// if Denis and GetSide ( Denis ) = 4 then
5410: LD_EXP 16
5414: PUSH
5415: LD_EXP 16
5419: PPUSH
5420: CALL_OW 255
5424: PUSH
5425: LD_INT 4
5427: EQUAL
5428: AND
5429: IFFALSE 5438
// Wait ( 0 0$45 ) ;
5431: LD_INT 1575
5433: PPUSH
5434: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) then
5438: LD_INT 22
5440: PUSH
5441: LD_INT 1
5443: PUSH
5444: EMPTY
5445: LIST
5446: LIST
5447: PUSH
5448: LD_INT 30
5450: PUSH
5451: LD_INT 4
5453: PUSH
5454: EMPTY
5455: LIST
5456: LIST
5457: PUSH
5458: EMPTY
5459: LIST
5460: LIST
5461: PPUSH
5462: CALL_OW 69
5466: IFFALSE 5483
// begin Wait ( 1 1$25 ) ;
5468: LD_INT 2975
5470: PPUSH
5471: CALL_OW 67
// more_troops := true ;
5475: LD_ADDR_VAR 0 3
5479: PUSH
5480: LD_INT 1
5482: ST_TO_ADDR
// end ; if more_troops then
5483: LD_VAR 0 3
5487: IFFALSE 5675
// begin force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , arArea2 ) ;
5489: LD_ADDR_VAR 0 8
5493: PUSH
5494: LD_INT 4
5496: PUSH
5497: LD_INT 5
5499: PUSH
5500: LD_INT 6
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: LIST
5507: PUSH
5508: LD_OWVAR 67
5512: ARRAY
5513: PPUSH
5514: LD_VAR 0 4
5518: PPUSH
5519: LD_INT 14
5521: PPUSH
5522: CALL 5136 0 3
5526: ST_TO_ADDR
// veh := PrepareTank ( 2 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ Difficulty ] , 90 ) ;
5527: LD_ADDR_VAR 0 7
5531: PUSH
5532: LD_INT 2
5534: PPUSH
5535: LD_INT 3
5537: PPUSH
5538: LD_INT 22
5540: PPUSH
5541: LD_INT 1
5543: PPUSH
5544: LD_INT 1
5546: PPUSH
5547: LD_INT 42
5549: PUSH
5550: LD_INT 42
5552: PUSH
5553: LD_INT 43
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: LIST
5560: PUSH
5561: LD_OWVAR 67
5565: ARRAY
5566: PPUSH
5567: LD_INT 90
5569: PPUSH
5570: CALL 337 0 7
5574: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5575: LD_VAR 0 7
5579: PPUSH
5580: LD_INT 4
5582: PPUSH
5583: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
5587: LD_VAR 0 7
5591: PPUSH
5592: LD_INT 13
5594: PPUSH
5595: LD_INT 0
5597: PPUSH
5598: CALL_OW 49
// uc_side := 2 ;
5602: LD_ADDR_OWVAR 20
5606: PUSH
5607: LD_INT 2
5609: ST_TO_ADDR
// uc_nation := 2 ;
5610: LD_ADDR_OWVAR 21
5614: PUSH
5615: LD_INT 2
5617: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5618: LD_INT 0
5620: PPUSH
5621: LD_INT 1
5623: PPUSH
5624: LD_VAR 0 4
5628: PPUSH
5629: CALL_OW 380
// un := CreateHuman ;
5633: LD_ADDR_VAR 0 6
5637: PUSH
5638: CALL_OW 44
5642: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
5643: LD_VAR 0 6
5647: PPUSH
5648: LD_VAR 0 7
5652: PPUSH
5653: CALL_OW 52
// force := force ^ un ;
5657: LD_ADDR_VAR 0 8
5661: PUSH
5662: LD_VAR 0 8
5666: PUSH
5667: LD_VAR 0 6
5671: ADD
5672: ST_TO_ADDR
// end else
5673: GO 5713
// begin force := PrepareArabianTroops ( [ 3 , 4 , 5 ] [ Difficulty ] , skill , arArea2 ) ;
5675: LD_ADDR_VAR 0 8
5679: PUSH
5680: LD_INT 3
5682: PUSH
5683: LD_INT 4
5685: PUSH
5686: LD_INT 5
5688: PUSH
5689: EMPTY
5690: LIST
5691: LIST
5692: LIST
5693: PUSH
5694: LD_OWVAR 67
5698: ARRAY
5699: PPUSH
5700: LD_VAR 0 4
5704: PPUSH
5705: LD_INT 14
5707: PPUSH
5708: CALL 5136 0 3
5712: ST_TO_ADDR
// end ; if force then
5713: LD_VAR 0 8
5717: IFFALSE 5729
// ar_forces := force ;
5719: LD_ADDR_EXP 24
5723: PUSH
5724: LD_VAR 0 8
5728: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5729: LD_INT 35
5731: PPUSH
5732: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
5736: LD_INT 22
5738: PUSH
5739: LD_INT 2
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: PPUSH
5746: CALL_OW 69
5750: PUSH
5751: LD_INT 0
5753: EQUAL
5754: IFFALSE 5729
// Wait ( timer ) ;
5756: LD_VAR 0 2
5760: PPUSH
5761: CALL_OW 67
// force := PrepareArabianTroops ( [ 5 , 6 , 6 ] [ Difficulty ] , skill , [ arArea1 , arArea2 ] [ rand ( 1 , 2 ) ] ) ;
5765: LD_ADDR_VAR 0 8
5769: PUSH
5770: LD_INT 5
5772: PUSH
5773: LD_INT 6
5775: PUSH
5776: LD_INT 6
5778: PUSH
5779: EMPTY
5780: LIST
5781: LIST
5782: LIST
5783: PUSH
5784: LD_OWVAR 67
5788: ARRAY
5789: PPUSH
5790: LD_VAR 0 4
5794: PPUSH
5795: LD_INT 13
5797: PUSH
5798: LD_INT 14
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: PUSH
5805: LD_INT 1
5807: PPUSH
5808: LD_INT 2
5810: PPUSH
5811: CALL_OW 12
5815: ARRAY
5816: PPUSH
5817: CALL 5136 0 3
5821: ST_TO_ADDR
// if Difficulty > 1 and Delta then
5822: LD_OWVAR 67
5826: PUSH
5827: LD_INT 1
5829: GREATER
5830: PUSH
5831: LD_EXP 4
5835: AND
5836: IFFALSE 6000
// begin veh := PrepareTank ( 2 , 2 , ar_light_trike , engine_solar , control_manual , 22 , 100 ) ;
5838: LD_ADDR_VAR 0 7
5842: PUSH
5843: LD_INT 2
5845: PPUSH
5846: LD_INT 2
5848: PPUSH
5849: LD_INT 12
5851: PPUSH
5852: LD_INT 2
5854: PPUSH
5855: LD_INT 1
5857: PPUSH
5858: LD_INT 22
5860: PPUSH
5861: LD_INT 100
5863: PPUSH
5864: CALL 337 0 7
5868: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5869: LD_VAR 0 7
5873: PPUSH
5874: LD_INT 4
5876: PPUSH
5877: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
5881: LD_VAR 0 7
5885: PPUSH
5886: LD_INT 13
5888: PPUSH
5889: LD_INT 0
5891: PPUSH
5892: CALL_OW 49
// uc_side := 2 ;
5896: LD_ADDR_OWVAR 20
5900: PUSH
5901: LD_INT 2
5903: ST_TO_ADDR
// uc_nation := 2 ;
5904: LD_ADDR_OWVAR 21
5908: PUSH
5909: LD_INT 2
5911: ST_TO_ADDR
// PrepareHuman ( false , 2 , skill ) ;
5912: LD_INT 0
5914: PPUSH
5915: LD_INT 2
5917: PPUSH
5918: LD_VAR 0 4
5922: PPUSH
5923: CALL_OW 380
// eng := CreateHuman ;
5927: LD_ADDR_VAR 0 5
5931: PUSH
5932: CALL_OW 44
5936: ST_TO_ADDR
// PlaceHumanInUnit ( eng , veh ) ;
5937: LD_VAR 0 5
5941: PPUSH
5942: LD_VAR 0 7
5946: PPUSH
5947: CALL_OW 52
// Wait ( 3 ) ;
5951: LD_INT 3
5953: PPUSH
5954: CALL_OW 67
// ComMoveUnit ( IsDrivenBy ( eng ) , Delta ) ;
5958: LD_VAR 0 5
5962: PPUSH
5963: CALL_OW 311
5967: PPUSH
5968: LD_EXP 4
5972: PPUSH
5973: CALL_OW 112
// AddComExitVehicle ( eng ) ;
5977: LD_VAR 0 5
5981: PPUSH
5982: CALL_OW 181
// AddComEnterUnit ( eng , Delta ) ;
5986: LD_VAR 0 5
5990: PPUSH
5991: LD_EXP 4
5995: PPUSH
5996: CALL_OW 180
// end ; if force then
6000: LD_VAR 0 8
6004: IFFALSE 6016
// ar_forces := force ;
6006: LD_ADDR_EXP 24
6010: PUSH
6011: LD_VAR 0 8
6015: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
6016: LD_INT 35
6018: PPUSH
6019: CALL_OW 67
// if eng then
6023: LD_VAR 0 5
6027: IFFALSE 6081
// if GetSide ( Delta ) = 2 and IsOk ( eng ) and not IsInUnit ( eng ) then
6029: LD_EXP 4
6033: PPUSH
6034: CALL_OW 255
6038: PUSH
6039: LD_INT 2
6041: EQUAL
6042: PUSH
6043: LD_VAR 0 5
6047: PPUSH
6048: CALL_OW 302
6052: AND
6053: PUSH
6054: LD_VAR 0 5
6058: PPUSH
6059: CALL_OW 310
6063: NOT
6064: AND
6065: IFFALSE 6081
// ComEnterUnit ( eng , Delta ) ;
6067: LD_VAR 0 5
6071: PPUSH
6072: LD_EXP 4
6076: PPUSH
6077: CALL_OW 120
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
6081: LD_INT 22
6083: PUSH
6084: LD_INT 2
6086: PUSH
6087: EMPTY
6088: LIST
6089: LIST
6090: PPUSH
6091: CALL_OW 69
6095: PUSH
6096: LD_INT 0
6098: EQUAL
6099: IFFALSE 6016
// ap_killers := PrepareArabianTroops ( [ 1 , 2 , 2 ] [ Difficulty ] , skill , arArea1 ) ;
6101: LD_ADDR_EXP 25
6105: PUSH
6106: LD_INT 1
6108: PUSH
6109: LD_INT 2
6111: PUSH
6112: LD_INT 2
6114: PUSH
6115: EMPTY
6116: LIST
6117: LIST
6118: LIST
6119: PUSH
6120: LD_OWVAR 67
6124: ARRAY
6125: PPUSH
6126: LD_VAR 0 4
6130: PPUSH
6131: LD_INT 13
6133: PPUSH
6134: CALL 5136 0 3
6138: ST_TO_ADDR
// Wait ( timer * 2 ) ;
6139: LD_VAR 0 2
6143: PUSH
6144: LD_INT 2
6146: MUL
6147: PPUSH
6148: CALL_OW 67
// ar_forces := PrepareArabianTroops ( [ 5 , 6 , 7 ] [ Difficulty ] , skill , arArea1 ) ^ PrepareArabianTroops ( [ 3 , 4 , 4 ] [ Difficulty ] , skill , arArea2 ) ;
6152: LD_ADDR_EXP 24
6156: PUSH
6157: LD_INT 5
6159: PUSH
6160: LD_INT 6
6162: PUSH
6163: LD_INT 7
6165: PUSH
6166: EMPTY
6167: LIST
6168: LIST
6169: LIST
6170: PUSH
6171: LD_OWVAR 67
6175: ARRAY
6176: PPUSH
6177: LD_VAR 0 4
6181: PPUSH
6182: LD_INT 13
6184: PPUSH
6185: CALL 5136 0 3
6189: PUSH
6190: LD_INT 3
6192: PUSH
6193: LD_INT 4
6195: PUSH
6196: LD_INT 4
6198: PUSH
6199: EMPTY
6200: LIST
6201: LIST
6202: LIST
6203: PUSH
6204: LD_OWVAR 67
6208: ARRAY
6209: PPUSH
6210: LD_VAR 0 4
6214: PPUSH
6215: LD_INT 14
6217: PPUSH
6218: CALL 5136 0 3
6222: ADD
6223: ST_TO_ADDR
// end ;
6224: PPOPN 8
6226: END
// every 0 0$03 trigger ar_forces do var i , target ;
6227: LD_EXP 24
6231: IFFALSE 6370
6233: GO 6235
6235: DISABLE
6236: LD_INT 0
6238: PPUSH
6239: PPUSH
// begin enable ;
6240: ENABLE
// if not ar_forces then
6241: LD_EXP 24
6245: NOT
6246: IFFALSE 6250
// exit ;
6248: GO 6370
// if Delta then
6250: LD_EXP 4
6254: IFFALSE 6268
// target := Delta else
6256: LD_ADDR_VAR 0 2
6260: PUSH
6261: LD_EXP 4
6265: ST_TO_ADDR
6266: GO 6278
// target := JMM ;
6268: LD_ADDR_VAR 0 2
6272: PUSH
6273: LD_EXP 13
6277: ST_TO_ADDR
// for i in ar_forces do
6278: LD_ADDR_VAR 0 1
6282: PUSH
6283: LD_EXP 24
6287: PUSH
6288: FOR_IN
6289: IFFALSE 6368
// begin if GetDistUnits ( i , target ) > 30 then
6291: LD_VAR 0 1
6295: PPUSH
6296: LD_VAR 0 2
6300: PPUSH
6301: CALL_OW 296
6305: PUSH
6306: LD_INT 30
6308: GREATER
6309: IFFALSE 6342
// ComAgressiveMove ( i , GetX ( target ) , GetY ( target ) ) else
6311: LD_VAR 0 1
6315: PPUSH
6316: LD_VAR 0 2
6320: PPUSH
6321: CALL_OW 250
6325: PPUSH
6326: LD_VAR 0 2
6330: PPUSH
6331: CALL_OW 251
6335: PPUSH
6336: CALL_OW 114
6340: GO 6366
// Attack ( i , FilterAllUnits ( [ f_enemy , 2 ] ) ) ;
6342: LD_VAR 0 1
6346: PPUSH
6347: LD_INT 81
6349: PUSH
6350: LD_INT 2
6352: PUSH
6353: EMPTY
6354: LIST
6355: LIST
6356: PPUSH
6357: CALL_OW 69
6361: PPUSH
6362: CALL 590 0 2
// end ;
6366: GO 6288
6368: POP
6369: POP
// end ;
6370: PPOPN 2
6372: END
// every 0 0$01 trigger ap_killers do var filter , i , target ;
6373: LD_EXP 25
6377: IFFALSE 6537
6379: GO 6381
6381: DISABLE
6382: LD_INT 0
6384: PPUSH
6385: PPUSH
6386: PPUSH
// begin enable ;
6387: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6388: LD_ADDR_VAR 0 1
6392: PUSH
6393: LD_INT 22
6395: PUSH
6396: LD_INT 0
6398: PUSH
6399: EMPTY
6400: LIST
6401: LIST
6402: PUSH
6403: LD_INT 25
6405: PUSH
6406: LD_INT 12
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: PUSH
6413: EMPTY
6414: LIST
6415: LIST
6416: PPUSH
6417: CALL_OW 69
6421: ST_TO_ADDR
// if not filter then
6422: LD_VAR 0 1
6426: NOT
6427: IFFALSE 6454
// begin ar_forces := ar_forces ^ ap_killers ;
6429: LD_ADDR_EXP 24
6433: PUSH
6434: LD_EXP 24
6438: PUSH
6439: LD_EXP 25
6443: ADD
6444: ST_TO_ADDR
// ap_killers := [ ] ;
6445: LD_ADDR_EXP 25
6449: PUSH
6450: EMPTY
6451: ST_TO_ADDR
// exit ;
6452: GO 6537
// end ; for i in ap_killers do
6454: LD_ADDR_VAR 0 2
6458: PUSH
6459: LD_EXP 25
6463: PUSH
6464: FOR_IN
6465: IFFALSE 6535
// begin if not IsOk ( i ) then
6467: LD_VAR 0 2
6471: PPUSH
6472: CALL_OW 302
6476: NOT
6477: IFFALSE 6481
// continue ;
6479: GO 6464
// if not HasTask ( i ) then
6481: LD_VAR 0 2
6485: PPUSH
6486: CALL_OW 314
6490: NOT
6491: IFFALSE 6513
// target := NearestUnitToUnit ( filter , i ) ;
6493: LD_ADDR_VAR 0 3
6497: PUSH
6498: LD_VAR 0 1
6502: PPUSH
6503: LD_VAR 0 2
6507: PPUSH
6508: CALL_OW 74
6512: ST_TO_ADDR
// if target then
6513: LD_VAR 0 3
6517: IFFALSE 6533
// ComAttackUnit ( i , target ) ;
6519: LD_VAR 0 2
6523: PPUSH
6524: LD_VAR 0 3
6528: PPUSH
6529: CALL_OW 115
// end ;
6533: GO 6464
6535: POP
6536: POP
// end ; end_of_file
6537: PPOPN 3
6539: END
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
6540: LD_EXP 4
6544: IFFALSE 6676
6546: GO 6548
6548: DISABLE
6549: LD_INT 0
6551: PPUSH
6552: PPUSH
6553: PPUSH
// begin counter := [ 700 , 600 , 500 ] [ Difficulty ] ;
6554: LD_ADDR_VAR 0 2
6558: PUSH
6559: LD_INT 700
6561: PUSH
6562: LD_INT 600
6564: PUSH
6565: LD_INT 500
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: PUSH
6573: LD_OWVAR 67
6577: ARRAY
6578: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
6579: LD_INT 1
6581: PPUSH
6582: LD_INT 3
6584: PPUSH
6585: CALL_OW 12
6589: PPUSH
6590: LD_INT 7
6592: PPUSH
6593: LD_INT 1
6595: PPUSH
6596: CALL_OW 55
// repeat wait ( rand ( 1 1$30 , 2 2$20 ) ) ;
6600: LD_INT 3150
6602: PPUSH
6603: LD_INT 4900
6605: PPUSH
6606: CALL_OW 12
6610: PPUSH
6611: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
6615: LD_ADDR_VAR 0 3
6619: PUSH
6620: LD_INT 1
6622: PPUSH
6623: LD_INT 5
6625: PPUSH
6626: CALL_OW 12
6630: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
6631: LD_VAR 0 3
6635: PPUSH
6636: LD_INT 7
6638: PPUSH
6639: LD_INT 1
6641: PPUSH
6642: CALL_OW 55
// counter := counter - cr * 10 ;
6646: LD_ADDR_VAR 0 2
6650: PUSH
6651: LD_VAR 0 2
6655: PUSH
6656: LD_VAR 0 3
6660: PUSH
6661: LD_INT 10
6663: MUL
6664: MINUS
6665: ST_TO_ADDR
// until counter <= 0 ;
6666: LD_VAR 0 2
6670: PUSH
6671: LD_INT 0
6673: LESSEQUAL
6674: IFFALSE 6600
// end ;
6676: PPOPN 3
6678: END
// every 0 0$03 trigger not Delta do var i ;
6679: LD_EXP 4
6683: NOT
6684: IFFALSE 6754
6686: GO 6688
6688: DISABLE
6689: LD_INT 0
6691: PPUSH
// begin for i = 1 to 4 - Difficulty do
6692: LD_ADDR_VAR 0 1
6696: PUSH
6697: DOUBLE
6698: LD_INT 1
6700: DEC
6701: ST_TO_ADDR
6702: LD_INT 4
6704: PUSH
6705: LD_OWVAR 67
6709: MINUS
6710: PUSH
6711: FOR_TO
6712: IFFALSE 6752
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
6714: LD_INT 2
6716: PPUSH
6717: LD_INT 5
6719: PPUSH
6720: CALL_OW 12
6724: PPUSH
6725: LD_INT 8
6727: PPUSH
6728: LD_INT 1
6730: PPUSH
6731: CALL_OW 55
// Wait ( rand ( 0 0$16 , 0 0$39 ) ) ;
6735: LD_INT 560
6737: PPUSH
6738: LD_INT 1365
6740: PPUSH
6741: CALL_OW 12
6745: PPUSH
6746: CALL_OW 67
// end ;
6750: GO 6711
6752: POP
6753: POP
// end ;
6754: PPOPN 1
6756: END
// every 2 2$00 do
6757: GO 6759
6759: DISABLE
// begin enable ;
6760: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
6761: LD_INT 1
6763: PPUSH
6764: LD_INT 3
6766: PPUSH
6767: CALL_OW 12
6771: PPUSH
6772: LD_INT 1
6774: PPUSH
6775: CALL_OW 57
// Wait ( rand ( 0 0$38 , 0 0$59 ) ) ;
6779: LD_INT 1330
6781: PPUSH
6782: LD_INT 2065
6784: PPUSH
6785: CALL_OW 12
6789: PPUSH
6790: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 4 ) , riverArea , true ) ;
6794: LD_INT 1
6796: PPUSH
6797: LD_INT 4
6799: PPUSH
6800: CALL_OW 12
6804: PPUSH
6805: LD_INT 15
6807: PPUSH
6808: LD_INT 1
6810: PPUSH
6811: CALL_OW 55
// end ; end_of_file
6815: END
// on UnitDestroyed ( un ) do begin if un = JMM then
6816: LD_VAR 0 1
6820: PUSH
6821: LD_EXP 13
6825: EQUAL
6826: IFFALSE 6835
// YouLost ( JMM ) ;
6828: LD_STRING JMM
6830: PPUSH
6831: CALL_OW 104
// if un = Delta then
6835: LD_VAR 0 1
6839: PUSH
6840: LD_EXP 4
6844: EQUAL
6845: IFFALSE 6855
// Delta := 0 ;
6847: LD_ADDR_EXP 4
6851: PUSH
6852: LD_INT 0
6854: ST_TO_ADDR
// if un in ar_forces then
6855: LD_VAR 0 1
6859: PUSH
6860: LD_EXP 24
6864: IN
6865: IFFALSE 6883
// ar_forces := ar_forces diff un ;
6867: LD_ADDR_EXP 24
6871: PUSH
6872: LD_EXP 24
6876: PUSH
6877: LD_VAR 0 1
6881: DIFF
6882: ST_TO_ADDR
// if un in ap_killers then
6883: LD_VAR 0 1
6887: PUSH
6888: LD_EXP 25
6892: IN
6893: IFFALSE 6911
// ap_killers := ap_killers diff un ;
6895: LD_ADDR_EXP 25
6899: PUSH
6900: LD_EXP 25
6904: PUSH
6905: LD_VAR 0 1
6909: DIFF
6910: ST_TO_ADDR
// end ;
6911: PPOPN 1
6913: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
6914: LD_VAR 0 1
6918: PUSH
6919: LD_INT 1
6921: EQUAL
6922: PUSH
6923: LD_VAR 0 2
6927: PUSH
6928: LD_INT 2
6930: EQUAL
6931: AND
6932: PUSH
6933: LD_EXP 11
6937: NOT
6938: AND
6939: IFFALSE 6949
// arab_spotted := true ;
6941: LD_ADDR_EXP 11
6945: PUSH
6946: LD_INT 1
6948: ST_TO_ADDR
6949: PPOPN 2
6951: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
6952: LD_ADDR_OWVAR 57
6956: PUSH
6957: LD_INT 0
6959: ST_TO_ADDR
// end_mission := true ;
6960: LD_ADDR_EXP 12
6964: PUSH
6965: LD_INT 1
6967: ST_TO_ADDR
// end ;
6968: PPOPN 1
6970: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
6971: LD_VAR 0 2
6975: PPUSH
6976: CALL_OW 255
6980: PUSH
6981: LD_INT 1
6983: EQUAL
6984: IFFALSE 7000
// apeman_counter := apeman_counter + 1 ;
6986: LD_ADDR_EXP 10
6990: PUSH
6991: LD_EXP 10
6995: PUSH
6996: LD_INT 1
6998: PLUS
6999: ST_TO_ADDR
// if not first_apeman_tamed then
7000: LD_EXP 6
7004: NOT
7005: IFFALSE 7205
// begin first_apeman_tamed := true ;
7007: LD_ADDR_EXP 6
7011: PUSH
7012: LD_INT 1
7014: ST_TO_ADDR
// if sci = Gladstone then
7015: LD_VAR 0 2
7019: PUSH
7020: LD_EXP 14
7024: EQUAL
7025: IFFALSE 7039
// Say ( Gladstone , D7b-Glad-1 ) ;
7027: LD_EXP 14
7031: PPUSH
7032: LD_STRING D7b-Glad-1
7034: PPUSH
7035: CALL_OW 88
// if sci = Denis then
7039: LD_VAR 0 2
7043: PUSH
7044: LD_EXP 16
7048: EQUAL
7049: IFFALSE 7063
// Say ( Denis , D7a-Den-1 ) ;
7051: LD_EXP 16
7055: PPUSH
7056: LD_STRING D7a-Den-1
7058: PPUSH
7059: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
7063: LD_VAR 0 2
7067: PUSH
7068: LD_EXP 13
7072: PUSH
7073: LD_EXP 14
7077: PUSH
7078: LD_EXP 16
7082: PUSH
7083: LD_EXP 19
7087: PUSH
7088: LD_EXP 20
7092: PUSH
7093: LD_EXP 21
7097: PUSH
7098: LD_EXP 22
7102: PUSH
7103: LD_EXP 18
7107: PUSH
7108: EMPTY
7109: LIST
7110: LIST
7111: LIST
7112: LIST
7113: LIST
7114: LIST
7115: LIST
7116: LIST
7117: IN
7118: NOT
7119: IFFALSE 7162
// begin if GetSex ( sci ) = sex_male then
7121: LD_VAR 0 2
7125: PPUSH
7126: CALL_OW 258
7130: PUSH
7131: LD_INT 1
7133: EQUAL
7134: IFFALSE 7150
// Say ( sci , D7c-Sci1-1 ) else
7136: LD_VAR 0 2
7140: PPUSH
7141: LD_STRING D7c-Sci1-1
7143: PPUSH
7144: CALL_OW 88
7148: GO 7162
// Say ( sci , D7c-FSci1-1 ) ;
7150: LD_VAR 0 2
7154: PPUSH
7155: LD_STRING D7c-FSci1-1
7157: PPUSH
7158: CALL_OW 88
// end ; if not sci = Gladstone then
7162: LD_VAR 0 2
7166: PUSH
7167: LD_EXP 14
7171: EQUAL
7172: NOT
7173: IFFALSE 7187
// Say ( Gladstone , D7c-Glad-1 ) ;
7175: LD_EXP 14
7179: PPUSH
7180: LD_STRING D7c-Glad-1
7182: PPUSH
7183: CALL_OW 88
// if Lisa then
7187: LD_EXP 19
7191: IFFALSE 7205
// Say ( Lisa , D8-Lisa-1 ) ;
7193: LD_EXP 19
7197: PPUSH
7198: LD_STRING D8-Lisa-1
7200: PPUSH
7201: CALL_OW 88
// end ; end ;
7205: PPOPN 2
7207: END
