// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 72 0 0
// InitRestrictions ;
  12: CALL 176 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 26
// DebugMode ;
  22: CALL 257 0 0
// SpawnApeman ( apemanStartArea , 2 ) ;
  26: LD_INT 12
  28: PPUSH
  29: LD_INT 2
  31: PPUSH
  32: CALL 505 0 2
// SpawnApeman ( apemanArea , [ 10 , 8 , 6 ] [ Difficulty ] ) ;
  36: LD_INT 11
  38: PPUSH
  39: LD_INT 10
  41: PUSH
  42: LD_INT 8
  44: PUSH
  45: LD_INT 6
  47: PUSH
  48: EMPTY
  49: LIST
  50: LIST
  51: LIST
  52: PUSH
  53: LD_OWVAR 67
  57: ARRAY
  58: PPUSH
  59: CALL 505 0 2
// PrepareAmericans ;
  63: CALL 1040 0 0
// Action ;
  67: CALL 1938 0 0
// end ;
  71: END
// export debug ; export deltaBuilded , denisArrives , Delta , radar_allowed , first_apeman_tamed , apeman_army , radar_researched , radar_builded ; export apeman_counter , arab_spotted , end_mission ; function Init ; begin
  72: LD_INT 0
  74: PPUSH
// debug := true ;
  75: LD_ADDR_EXP 1
  79: PUSH
  80: LD_INT 1
  82: ST_TO_ADDR
// deltaBuilded := false ;
  83: LD_ADDR_EXP 2
  87: PUSH
  88: LD_INT 0
  90: ST_TO_ADDR
// denisArrives := false ;
  91: LD_ADDR_EXP 3
  95: PUSH
  96: LD_INT 0
  98: ST_TO_ADDR
// radar_allowed := false ;
  99: LD_ADDR_EXP 5
 103: PUSH
 104: LD_INT 0
 106: ST_TO_ADDR
// first_apeman_tamed := false ;
 107: LD_ADDR_EXP 6
 111: PUSH
 112: LD_INT 0
 114: ST_TO_ADDR
// arab_spotted := false ;
 115: LD_ADDR_EXP 11
 119: PUSH
 120: LD_INT 0
 122: ST_TO_ADDR
// end_mission := false ;
 123: LD_ADDR_EXP 12
 127: PUSH
 128: LD_INT 0
 130: ST_TO_ADDR
// apeman_army := false ;
 131: LD_ADDR_EXP 7
 135: PUSH
 136: LD_INT 0
 138: ST_TO_ADDR
// radar_researched := false ;
 139: LD_ADDR_EXP 8
 143: PUSH
 144: LD_INT 0
 146: ST_TO_ADDR
// radar_builded := false ;
 147: LD_ADDR_EXP 9
 151: PUSH
 152: LD_INT 0
 154: ST_TO_ADDR
// apeman_counter := 0 ;
 155: LD_ADDR_EXP 10
 159: PUSH
 160: LD_INT 0
 162: ST_TO_ADDR
// Delta := 0 ;
 163: LD_ADDR_EXP 4
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// end ;
 171: LD_VAR 0 1
 175: RET
// function InitRestrictions ; begin
 176: LD_INT 0
 178: PPUSH
// SetRestrict ( b_lab_half , 1 , state_enabled ) ;
 179: LD_INT 7
 181: PPUSH
 182: LD_INT 1
 184: PPUSH
 185: LD_INT 1
 187: PPUSH
 188: CALL_OW 324
// SetRestrict ( b_lab_full , 1 , state_enabled ) ;
 192: LD_INT 8
 194: PPUSH
 195: LD_INT 1
 197: PPUSH
 198: LD_INT 1
 200: PPUSH
 201: CALL_OW 324
// SetRestrict ( b_lab_weapon , 1 , state_enabled ) ;
 205: LD_INT 10
 207: PPUSH
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 1
 213: PPUSH
 214: CALL_OW 324
// SetTech ( tech_gatling , 1 , LoadVariable ( GatlingInGamma , 1 ) ) ;
 218: LD_INT 69
 220: PPUSH
 221: LD_INT 1
 223: PPUSH
 224: LD_STRING GatlingInGamma
 226: PPUSH
 227: LD_INT 1
 229: PPUSH
 230: CALL_OW 30
 234: PPUSH
 235: CALL_OW 322
// SetTech ( tech_weap1 , 1 , state_enabled ) ;
 239: LD_INT 51
 241: PPUSH
 242: LD_INT 1
 244: PPUSH
 245: LD_INT 1
 247: PPUSH
 248: CALL_OW 322
// end ;
 252: LD_VAR 0 1
 256: RET
// function DebugMode ; begin
 257: LD_INT 0
 259: PPUSH
// FogOff ( 1 ) ;
 260: LD_INT 1
 262: PPUSH
 263: CALL_OW 344
// Difficulty := 2 ;
 267: LD_ADDR_OWVAR 67
 271: PUSH
 272: LD_INT 2
 274: ST_TO_ADDR
// end ; end_of_file
 275: LD_VAR 0 1
 279: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 280: LD_INT 0
 282: PPUSH
 283: PPUSH
// if exist_mode then
 284: LD_VAR 0 2
 288: IFFALSE 307
// unit := CreateCharacter ( ident ) else
 290: LD_ADDR_VAR 0 4
 294: PUSH
 295: LD_VAR 0 1
 299: PPUSH
 300: CALL_OW 34
 304: ST_TO_ADDR
 305: GO 322
// unit := NewCharacter ( ident ) ;
 307: LD_ADDR_VAR 0 4
 311: PUSH
 312: LD_VAR 0 1
 316: PPUSH
 317: CALL_OW 25
 321: ST_TO_ADDR
// result := unit ;
 322: LD_ADDR_VAR 0 3
 326: PUSH
 327: LD_VAR 0 4
 331: ST_TO_ADDR
// end ;
 332: LD_VAR 0 3
 336: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 337: LD_INT 0
 339: PPUSH
// uc_side := side ;
 340: LD_ADDR_OWVAR 20
 344: PUSH
 345: LD_VAR 0 1
 349: ST_TO_ADDR
// uc_nation := nation ;
 350: LD_ADDR_OWVAR 21
 354: PUSH
 355: LD_VAR 0 2
 359: ST_TO_ADDR
// vc_chassis := chassis ;
 360: LD_ADDR_OWVAR 37
 364: PUSH
 365: LD_VAR 0 3
 369: ST_TO_ADDR
// vc_engine := engine ;
 370: LD_ADDR_OWVAR 39
 374: PUSH
 375: LD_VAR 0 4
 379: ST_TO_ADDR
// vc_control := control ;
 380: LD_ADDR_OWVAR 38
 384: PUSH
 385: LD_VAR 0 5
 389: ST_TO_ADDR
// vc_weapon := weapon ;
 390: LD_ADDR_OWVAR 40
 394: PUSH
 395: LD_VAR 0 6
 399: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 400: LD_ADDR_OWVAR 41
 404: PUSH
 405: LD_VAR 0 7
 409: ST_TO_ADDR
// result := CreateVehicle ;
 410: LD_ADDR_VAR 0 8
 414: PUSH
 415: CALL_OW 45
 419: ST_TO_ADDR
// end ;
 420: LD_VAR 0 8
 424: RET
// export function SayX ( units , ident ) ; var i ; begin
 425: LD_INT 0
 427: PPUSH
 428: PPUSH
// result := false ;
 429: LD_ADDR_VAR 0 3
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// if not units then
 437: LD_VAR 0 1
 441: NOT
 442: IFFALSE 446
// exit ;
 444: GO 500
// for i in units do
 446: LD_ADDR_VAR 0 4
 450: PUSH
 451: LD_VAR 0 1
 455: PUSH
 456: FOR_IN
 457: IFFALSE 498
// if IsOk ( i ) then
 459: LD_VAR 0 4
 463: PPUSH
 464: CALL_OW 302
 468: IFFALSE 496
// begin Say ( i , ident ) ;
 470: LD_VAR 0 4
 474: PPUSH
 475: LD_VAR 0 2
 479: PPUSH
 480: CALL_OW 88
// result := i ;
 484: LD_ADDR_VAR 0 3
 488: PUSH
 489: LD_VAR 0 4
 493: ST_TO_ADDR
// break ;
 494: GO 498
// end ;
 496: GO 456
 498: POP
 499: POP
// end ;
 500: LD_VAR 0 3
 504: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 505: LD_INT 0
 507: PPUSH
 508: PPUSH
// InitUc ;
 509: CALL_OW 18
// InitHc ;
 513: CALL_OW 19
// uc_side := 0 ;
 517: LD_ADDR_OWVAR 20
 521: PUSH
 522: LD_INT 0
 524: ST_TO_ADDR
// uc_nation := 0 ;
 525: LD_ADDR_OWVAR 21
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// for i = 1 to amount do
 533: LD_ADDR_VAR 0 4
 537: PUSH
 538: DOUBLE
 539: LD_INT 1
 541: DEC
 542: ST_TO_ADDR
 543: LD_VAR 0 2
 547: PUSH
 548: FOR_TO
 549: IFFALSE 583
// begin PrepareHuman ( false , class_apeman , 1 ) ;
 551: LD_INT 0
 553: PPUSH
 554: LD_INT 12
 556: PPUSH
 557: LD_INT 1
 559: PPUSH
 560: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 564: CALL_OW 44
 568: PPUSH
 569: LD_VAR 0 1
 573: PPUSH
 574: LD_INT 0
 576: PPUSH
 577: CALL_OW 49
// end ;
 581: GO 548
 583: POP
 584: POP
// end ;
 585: LD_VAR 0 3
 589: RET
// export function Attack ( unit , enemy_list ) ; var target , targets_list ; begin
 590: LD_INT 0
 592: PPUSH
 593: PPUSH
 594: PPUSH
// if not unit then
 595: LD_VAR 0 1
 599: NOT
 600: IFFALSE 604
// exit ;
 602: GO 1035
// if IsInUnit ( unit ) then
 604: LD_VAR 0 1
 608: PPUSH
 609: CALL_OW 310
 613: IFFALSE 630
// unit := IsDrivenBy ( unit ) ;
 615: LD_ADDR_VAR 0 1
 619: PUSH
 620: LD_VAR 0 1
 624: PPUSH
 625: CALL_OW 311
 629: ST_TO_ADDR
// targets_list := [ ] ;
 630: LD_ADDR_VAR 0 5
 634: PUSH
 635: EMPTY
 636: ST_TO_ADDR
// target := UnitFilter ( enemy_list , [ [ f_lives , 250 ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
 637: LD_ADDR_VAR 0 4
 641: PUSH
 642: LD_VAR 0 2
 646: PPUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 250
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: PUSH
 657: LD_INT 3
 659: PUSH
 660: LD_INT 34
 662: PUSH
 663: LD_INT 12
 665: PUSH
 666: EMPTY
 667: LIST
 668: LIST
 669: PUSH
 670: EMPTY
 671: LIST
 672: LIST
 673: PUSH
 674: LD_INT 21
 676: PUSH
 677: LD_INT 2
 679: PUSH
 680: EMPTY
 681: LIST
 682: LIST
 683: PUSH
 684: LD_INT 58
 686: PUSH
 687: EMPTY
 688: LIST
 689: PUSH
 690: EMPTY
 691: LIST
 692: LIST
 693: LIST
 694: LIST
 695: PPUSH
 696: CALL_OW 72
 700: ST_TO_ADDR
// if GetDistUnits ( NearestUnitToUnit ( target , unit ) , unit ) < 11 and not IsInUnit ( unit ) then
 701: LD_VAR 0 4
 705: PPUSH
 706: LD_VAR 0 1
 710: PPUSH
 711: CALL_OW 74
 715: PPUSH
 716: LD_VAR 0 1
 720: PPUSH
 721: CALL_OW 296
 725: PUSH
 726: LD_INT 11
 728: LESS
 729: PUSH
 730: LD_VAR 0 1
 734: PPUSH
 735: CALL_OW 310
 739: NOT
 740: AND
 741: IFFALSE 769
// begin ComEnterUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
 743: LD_VAR 0 1
 747: PPUSH
 748: LD_VAR 0 4
 752: PPUSH
 753: LD_VAR 0 1
 757: PPUSH
 758: CALL_OW 74
 762: PPUSH
 763: CALL_OW 120
// exit ;
 767: GO 1035
// end ; targets_list := [ UnitFilter ( enemy_list , [ [ f_type , unit_human ] , [ f_not , [ f_inside ] ] ] ) , UnitFilter ( enemy_list , [ f_type , unit_vehicle ] ) , UnitFilter ( enemy_list , [ [ f_type , unit_building ] , [ f_not , [ f_empty ] ] ] ) , enemy_list ] ;
 769: LD_ADDR_VAR 0 5
 773: PUSH
 774: LD_VAR 0 2
 778: PPUSH
 779: LD_INT 21
 781: PUSH
 782: LD_INT 1
 784: PUSH
 785: EMPTY
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 3
 791: PUSH
 792: LD_INT 54
 794: PUSH
 795: EMPTY
 796: LIST
 797: PUSH
 798: EMPTY
 799: LIST
 800: LIST
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: PPUSH
 806: CALL_OW 72
 810: PUSH
 811: LD_VAR 0 2
 815: PPUSH
 816: LD_INT 21
 818: PUSH
 819: LD_INT 2
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: PPUSH
 826: CALL_OW 72
 830: PUSH
 831: LD_VAR 0 2
 835: PPUSH
 836: LD_INT 21
 838: PUSH
 839: LD_INT 3
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 58
 851: PUSH
 852: EMPTY
 853: LIST
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL_OW 72
 867: PUSH
 868: LD_VAR 0 2
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: ST_TO_ADDR
// for target in targets_list do
 879: LD_ADDR_VAR 0 4
 883: PUSH
 884: LD_VAR 0 5
 888: PUSH
 889: FOR_IN
 890: IFFALSE 1033
// begin if target then
 892: LD_VAR 0 4
 896: IFFALSE 1031
// if GetTag ( unit ) = 11 and ( GetType ( NearestUnitToUnit ( target , unit ) ) = unit_building or GetWeapon ( NearestUnitToUnit ( target , unit ) ) = us_cargo_bay ) then
 898: LD_VAR 0 1
 902: PPUSH
 903: CALL_OW 110
 907: PUSH
 908: LD_INT 11
 910: EQUAL
 911: PUSH
 912: LD_VAR 0 4
 916: PPUSH
 917: LD_VAR 0 1
 921: PPUSH
 922: CALL_OW 74
 926: PPUSH
 927: CALL_OW 247
 931: PUSH
 932: LD_INT 3
 934: EQUAL
 935: PUSH
 936: LD_VAR 0 4
 940: PPUSH
 941: LD_VAR 0 1
 945: PPUSH
 946: CALL_OW 74
 950: PPUSH
 951: CALL_OW 264
 955: PUSH
 956: LD_INT 12
 958: EQUAL
 959: OR
 960: AND
 961: IFFALSE 1007
// begin ComPlaceDelayedCharge ( unit , 0 , 0 , NearestUnitToUnit ( target , unit ) ) ;
 963: LD_VAR 0 1
 967: PPUSH
 968: LD_INT 0
 970: PPUSH
 971: LD_INT 0
 973: PPUSH
 974: LD_VAR 0 4
 978: PPUSH
 979: LD_VAR 0 1
 983: PPUSH
 984: CALL_OW 74
 988: PPUSH
 989: CALL_OW 132
// SetTag ( unit , 0 ) ;
 993: LD_VAR 0 1
 997: PPUSH
 998: LD_INT 0
1000: PPUSH
1001: CALL_OW 109
// end else
1005: GO 1031
// ComAttackUnit ( unit , NearestUnitToUnit ( target , unit ) ) ;
1007: LD_VAR 0 1
1011: PPUSH
1012: LD_VAR 0 4
1016: PPUSH
1017: LD_VAR 0 1
1021: PPUSH
1022: CALL_OW 74
1026: PPUSH
1027: CALL_OW 115
// end ;
1031: GO 889
1033: POP
1034: POP
// end ; end_of_file
1035: LD_VAR 0 3
1039: RET
// export JMM , Gladstone , Harrison , Denis , Brown , Donaldson , Lisa , Frank , Bobby , Cyrus ; export others ; export function PrepareAmericans ; var i , points , veh , tmp ; begin
1040: LD_INT 0
1042: PPUSH
1043: PPUSH
1044: PPUSH
1045: PPUSH
1046: PPUSH
// uc_nation := 1 ;
1047: LD_ADDR_OWVAR 21
1051: PUSH
1052: LD_INT 1
1054: ST_TO_ADDR
// uc_side := 4 ;
1055: LD_ADDR_OWVAR 20
1059: PUSH
1060: LD_INT 4
1062: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , false ) ;
1063: LD_ADDR_EXP 16
1067: PUSH
1068: LD_STRING Denis
1070: PPUSH
1071: LD_INT 0
1073: PPUSH
1074: CALL 280 0 2
1078: ST_TO_ADDR
// Harrison := PrepareUnit ( Harisson , false ) ;
1079: LD_ADDR_EXP 15
1083: PUSH
1084: LD_STRING Harisson
1086: PPUSH
1087: LD_INT 0
1089: PPUSH
1090: CALL 280 0 2
1094: ST_TO_ADDR
// uc_side := 1 ;
1095: LD_ADDR_OWVAR 20
1099: PUSH
1100: LD_INT 1
1102: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1103: LD_ADDR_EXP 13
1107: PUSH
1108: LD_STRING JMM
1110: PPUSH
1111: LD_EXP 1
1115: NOT
1116: PPUSH
1117: CALL 280 0 2
1121: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ) ;
1122: LD_ADDR_EXP 14
1126: PUSH
1127: LD_STRING Gladstone
1129: PPUSH
1130: LD_INT 0
1132: PPUSH
1133: CALL 280 0 2
1137: ST_TO_ADDR
// if LoadVariable ( BrownInDelta , debug ) then
1138: LD_STRING BrownInDelta
1140: PPUSH
1141: LD_EXP 1
1145: PPUSH
1146: CALL_OW 30
1150: IFFALSE 1187
// begin Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1152: LD_ADDR_EXP 17
1156: PUSH
1157: LD_STRING Brown
1159: PPUSH
1160: LD_EXP 1
1164: NOT
1165: PPUSH
1166: CALL 280 0 2
1170: ST_TO_ADDR
// tmp := tmp ^ Brown ;
1171: LD_ADDR_VAR 0 5
1175: PUSH
1176: LD_VAR 0 5
1180: PUSH
1181: LD_EXP 17
1185: ADD
1186: ST_TO_ADDR
// end ; if LoadVariable ( DonaldsonInDelta , 0 ) then
1187: LD_STRING DonaldsonInDelta
1189: PPUSH
1190: LD_INT 0
1192: PPUSH
1193: CALL_OW 30
1197: IFFALSE 1234
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1199: LD_ADDR_EXP 18
1203: PUSH
1204: LD_STRING Donaldson
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: CALL 280 0 2
1217: ST_TO_ADDR
// tmp := tmp ^ Donaldson ;
1218: LD_ADDR_VAR 0 5
1222: PUSH
1223: LD_VAR 0 5
1227: PUSH
1228: LD_EXP 18
1232: ADD
1233: ST_TO_ADDR
// end ; if LoadVariable ( LisaInDelta , debug ) then
1234: LD_STRING LisaInDelta
1236: PPUSH
1237: LD_EXP 1
1241: PPUSH
1242: CALL_OW 30
1246: IFFALSE 1283
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1248: LD_ADDR_EXP 19
1252: PUSH
1253: LD_STRING Lisa
1255: PPUSH
1256: LD_EXP 1
1260: NOT
1261: PPUSH
1262: CALL 280 0 2
1266: ST_TO_ADDR
// tmp := tmp ^ Lisa ;
1267: LD_ADDR_VAR 0 5
1271: PUSH
1272: LD_VAR 0 5
1276: PUSH
1277: LD_EXP 19
1281: ADD
1282: ST_TO_ADDR
// end ; if LoadVariable ( FrankInDelta , debug ) then
1283: LD_STRING FrankInDelta
1285: PPUSH
1286: LD_EXP 1
1290: PPUSH
1291: CALL_OW 30
1295: IFFALSE 1332
// begin Frank := PrepareUnit ( Frank , ( not debug ) ) ;
1297: LD_ADDR_EXP 20
1301: PUSH
1302: LD_STRING Frank
1304: PPUSH
1305: LD_EXP 1
1309: NOT
1310: PPUSH
1311: CALL 280 0 2
1315: ST_TO_ADDR
// tmp := tmp ^ Frank ;
1316: LD_ADDR_VAR 0 5
1320: PUSH
1321: LD_VAR 0 5
1325: PUSH
1326: LD_EXP 20
1330: ADD
1331: ST_TO_ADDR
// end ; if LoadVariable ( BobbyInDelta , 0 ) then
1332: LD_STRING BobbyInDelta
1334: PPUSH
1335: LD_INT 0
1337: PPUSH
1338: CALL_OW 30
1342: IFFALSE 1379
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1344: LD_ADDR_EXP 21
1348: PUSH
1349: LD_STRING Bobby
1351: PPUSH
1352: LD_EXP 1
1356: NOT
1357: PPUSH
1358: CALL 280 0 2
1362: ST_TO_ADDR
// tmp := tmp ^ Bobby ;
1363: LD_ADDR_VAR 0 5
1367: PUSH
1368: LD_VAR 0 5
1372: PUSH
1373: LD_EXP 21
1377: ADD
1378: ST_TO_ADDR
// end ; if LoadVariable ( CyrusInDelta , 0 ) then
1379: LD_STRING CyrusInDelta
1381: PPUSH
1382: LD_INT 0
1384: PPUSH
1385: CALL_OW 30
1389: IFFALSE 1426
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1391: LD_ADDR_EXP 22
1395: PUSH
1396: LD_STRING Cyrus
1398: PPUSH
1399: LD_EXP 1
1403: NOT
1404: PPUSH
1405: CALL 280 0 2
1409: ST_TO_ADDR
// tmp := tmp ^ Cyrus ;
1410: LD_ADDR_VAR 0 5
1414: PUSH
1415: LD_VAR 0 5
1419: PUSH
1420: LD_EXP 22
1424: ADD
1425: ST_TO_ADDR
// end ; others := CreateCharacterSet ( othersDelta ) ;
1426: LD_ADDR_EXP 23
1430: PUSH
1431: LD_STRING othersDelta
1433: PPUSH
1434: CALL_OW 31
1438: ST_TO_ADDR
// if not others and debug then
1439: LD_EXP 23
1443: NOT
1444: PUSH
1445: LD_EXP 1
1449: AND
1450: IFFALSE 1515
// begin InitHc ;
1452: CALL_OW 19
// for i = 1 to 2 do
1456: LD_ADDR_VAR 0 2
1460: PUSH
1461: DOUBLE
1462: LD_INT 1
1464: DEC
1465: ST_TO_ADDR
1466: LD_INT 2
1468: PUSH
1469: FOR_TO
1470: IFFALSE 1513
// begin PrepareHuman ( false , i mod 4 + 1 , 3 ) ;
1472: LD_INT 0
1474: PPUSH
1475: LD_VAR 0 2
1479: PUSH
1480: LD_INT 4
1482: MOD
1483: PUSH
1484: LD_INT 1
1486: PLUS
1487: PPUSH
1488: LD_INT 3
1490: PPUSH
1491: CALL_OW 380
// others := others ^ CreateHuman ;
1495: LD_ADDR_EXP 23
1499: PUSH
1500: LD_EXP 23
1504: PUSH
1505: CALL_OW 44
1509: ADD
1510: ST_TO_ADDR
// end ;
1511: GO 1469
1513: POP
1514: POP
// end ; if others then
1515: LD_EXP 23
1519: IFFALSE 1537
// tmp := tmp ^ others ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_EXP 23
1535: ADD
1536: ST_TO_ADDR
// points := [ [ 28 , 49 ] , [ 33 , 54 ] , [ 38 , 56 ] ] ;
1537: LD_ADDR_VAR 0 3
1541: PUSH
1542: LD_INT 28
1544: PUSH
1545: LD_INT 49
1547: PUSH
1548: EMPTY
1549: LIST
1550: LIST
1551: PUSH
1552: LD_INT 33
1554: PUSH
1555: LD_INT 54
1557: PUSH
1558: EMPTY
1559: LIST
1560: LIST
1561: PUSH
1562: LD_INT 38
1564: PUSH
1565: LD_INT 56
1567: PUSH
1568: EMPTY
1569: LIST
1570: LIST
1571: PUSH
1572: EMPTY
1573: LIST
1574: LIST
1575: LIST
1576: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_cargo_bay , 80 ) ;
1577: LD_ADDR_VAR 0 4
1581: PUSH
1582: LD_INT 1
1584: PPUSH
1585: LD_INT 1
1587: PPUSH
1588: LD_INT 2
1590: PPUSH
1591: LD_INT 2
1593: PPUSH
1594: LD_INT 1
1596: PPUSH
1597: LD_INT 12
1599: PPUSH
1600: LD_INT 80
1602: PPUSH
1603: CALL 337 0 7
1607: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1608: LD_VAR 0 4
1612: PPUSH
1613: LD_INT 1
1615: PPUSH
1616: CALL_OW 233
// PlaceUnitXY ( veh , points [ 1 ] [ 1 ] , points [ 1 ] [ 2 ] , false ) ;
1620: LD_VAR 0 4
1624: PPUSH
1625: LD_VAR 0 3
1629: PUSH
1630: LD_INT 1
1632: ARRAY
1633: PUSH
1634: LD_INT 1
1636: ARRAY
1637: PPUSH
1638: LD_VAR 0 3
1642: PUSH
1643: LD_INT 1
1645: ARRAY
1646: PUSH
1647: LD_INT 2
1649: ARRAY
1650: PPUSH
1651: LD_INT 0
1653: PPUSH
1654: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
1658: LD_VAR 0 4
1662: PPUSH
1663: LD_INT 1
1665: PPUSH
1666: LD_INT 100
1668: PPUSH
1669: CALL_OW 290
// PlaceHumanInUnit ( others [ 1 ] , veh ) ;
1673: LD_EXP 23
1677: PUSH
1678: LD_INT 1
1680: ARRAY
1681: PPUSH
1682: LD_VAR 0 4
1686: PPUSH
1687: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 80 ) ;
1691: LD_ADDR_VAR 0 4
1695: PUSH
1696: LD_INT 1
1698: PPUSH
1699: LD_INT 1
1701: PPUSH
1702: LD_INT 1
1704: PPUSH
1705: LD_INT 2
1707: PPUSH
1708: LD_INT 1
1710: PPUSH
1711: LD_INT 2
1713: PPUSH
1714: LD_INT 80
1716: PPUSH
1717: CALL 337 0 7
1721: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1722: LD_VAR 0 4
1726: PPUSH
1727: LD_INT 1
1729: PPUSH
1730: CALL_OW 233
// PlaceUnitXY ( veh , points [ 2 ] [ 1 ] , points [ 2 ] [ 2 ] , false ) ;
1734: LD_VAR 0 4
1738: PPUSH
1739: LD_VAR 0 3
1743: PUSH
1744: LD_INT 2
1746: ARRAY
1747: PUSH
1748: LD_INT 1
1750: ARRAY
1751: PPUSH
1752: LD_VAR 0 3
1756: PUSH
1757: LD_INT 2
1759: ARRAY
1760: PUSH
1761: LD_INT 2
1763: ARRAY
1764: PPUSH
1765: LD_INT 0
1767: PPUSH
1768: CALL_OW 48
// PlaceHumanInUnit ( Gladstone , veh ) ;
1772: LD_EXP 14
1776: PPUSH
1777: LD_VAR 0 4
1781: PPUSH
1782: CALL_OW 52
// veh := PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_light_gun , 80 ) ;
1786: LD_ADDR_VAR 0 4
1790: PUSH
1791: LD_INT 1
1793: PPUSH
1794: LD_INT 1
1796: PPUSH
1797: LD_INT 1
1799: PPUSH
1800: LD_INT 2
1802: PPUSH
1803: LD_INT 1
1805: PPUSH
1806: LD_INT 3
1808: PPUSH
1809: LD_INT 80
1811: PPUSH
1812: CALL 337 0 7
1816: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
1817: LD_VAR 0 4
1821: PPUSH
1822: LD_INT 1
1824: PPUSH
1825: CALL_OW 233
// PlaceUnitXY ( veh , points [ 3 ] [ 1 ] , points [ 3 ] [ 2 ] , false ) ;
1829: LD_VAR 0 4
1833: PPUSH
1834: LD_VAR 0 3
1838: PUSH
1839: LD_INT 3
1841: ARRAY
1842: PUSH
1843: LD_INT 1
1845: ARRAY
1846: PPUSH
1847: LD_VAR 0 3
1851: PUSH
1852: LD_INT 3
1854: ARRAY
1855: PUSH
1856: LD_INT 2
1858: ARRAY
1859: PPUSH
1860: LD_INT 0
1862: PPUSH
1863: CALL_OW 48
// PlaceHumanInUnit ( JMM , veh ) ;
1867: LD_EXP 13
1871: PPUSH
1872: LD_VAR 0 4
1876: PPUSH
1877: CALL_OW 52
// if others > 1 then
1881: LD_EXP 23
1885: PUSH
1886: LD_INT 1
1888: GREATER
1889: IFFALSE 1933
// for i in tmp diff others [ 1 ] do
1891: LD_ADDR_VAR 0 2
1895: PUSH
1896: LD_VAR 0 5
1900: PUSH
1901: LD_EXP 23
1905: PUSH
1906: LD_INT 1
1908: ARRAY
1909: DIFF
1910: PUSH
1911: FOR_IN
1912: IFFALSE 1931
// PlaceUnitArea ( i , startArea , false ) ;
1914: LD_VAR 0 2
1918: PPUSH
1919: LD_INT 5
1921: PPUSH
1922: LD_INT 0
1924: PPUSH
1925: CALL_OW 49
1929: GO 1911
1931: POP
1932: POP
// end ; end_of_file
1933: LD_VAR 0 1
1937: RET
// export function Action ; begin
1938: LD_INT 0
1940: PPUSH
// InGameOn ;
1941: CALL_OW 8
// CenterNowOnXY ( 28 , 51 ) ;
1945: LD_INT 28
1947: PPUSH
1948: LD_INT 51
1950: PPUSH
1951: CALL_OW 86
// Wait ( 3 ) ;
1955: LD_INT 3
1957: PPUSH
1958: CALL_OW 67
// Say ( JMM , D1d-JMM-1a ) ;
1962: LD_EXP 13
1966: PPUSH
1967: LD_STRING D1d-JMM-1a
1969: PPUSH
1970: CALL_OW 88
// SayRadio ( Harrison , D1d-Har-1 ) ;
1974: LD_EXP 15
1978: PPUSH
1979: LD_STRING D1d-Har-1
1981: PPUSH
1982: CALL_OW 94
// InGameOff ;
1986: CALL_OW 9
// SaveForQuickRestart ;
1990: CALL_OW 22
// ChangeMissionObjectives ( M1 ) ;
1994: LD_STRING M1
1996: PPUSH
1997: CALL_OW 337
// Wait ( 0 0$2 ) ;
2001: LD_INT 70
2003: PPUSH
2004: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
2008: LD_EXP 13
2012: PPUSH
2013: LD_STRING D2-JMM-1
2015: PPUSH
2016: CALL_OW 88
// Say ( Gladstone , D2-Glad-1 ) ;
2020: LD_EXP 14
2024: PPUSH
2025: LD_STRING D2-Glad-1
2027: PPUSH
2028: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
2032: LD_EXP 13
2036: PPUSH
2037: LD_STRING D2-JMM-2
2039: PPUSH
2040: CALL_OW 88
// Say ( Gladstone , D2-Glad-2 ) ;
2044: LD_EXP 14
2048: PPUSH
2049: LD_STRING D2-Glad-2
2051: PPUSH
2052: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
2056: LD_EXP 13
2060: PPUSH
2061: LD_STRING D2-JMM-3
2063: PPUSH
2064: CALL_OW 88
// SetWeather ( 2 , 100 , 150 ) ;
2068: LD_INT 2
2070: PPUSH
2071: LD_INT 100
2073: PPUSH
2074: LD_INT 150
2076: PPUSH
2077: CALL_OW 550
// Wait ( rand ( 4 4$00 , 5 5$00 ) ) ;
2081: LD_INT 8400
2083: PPUSH
2084: LD_INT 10500
2086: PPUSH
2087: CALL_OW 12
2091: PPUSH
2092: CALL_OW 67
// SetWeather ( 0 , 100 , 150 ) ;
2096: LD_INT 0
2098: PPUSH
2099: LD_INT 100
2101: PPUSH
2102: LD_INT 150
2104: PPUSH
2105: CALL_OW 550
// end ;
2109: LD_VAR 0 1
2113: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) and not deltaBuilded do
2114: LD_INT 22
2116: PUSH
2117: LD_INT 1
2119: PUSH
2120: EMPTY
2121: LIST
2122: LIST
2123: PUSH
2124: LD_INT 3
2126: PUSH
2127: LD_INT 57
2129: PUSH
2130: EMPTY
2131: LIST
2132: PUSH
2133: EMPTY
2134: LIST
2135: LIST
2136: PUSH
2137: LD_INT 30
2139: PUSH
2140: LD_INT 0
2142: PUSH
2143: EMPTY
2144: LIST
2145: LIST
2146: PUSH
2147: EMPTY
2148: LIST
2149: LIST
2150: LIST
2151: PUSH
2152: EMPTY
2153: LIST
2154: PPUSH
2155: CALL_OW 69
2159: PUSH
2160: LD_EXP 2
2164: NOT
2165: AND
2166: IFFALSE 2179
2168: GO 2170
2170: DISABLE
// begin deltaBuilded := true ;
2171: LD_ADDR_EXP 2
2175: PUSH
2176: LD_INT 1
2178: ST_TO_ADDR
// end ;
2179: END
// every 0 0$01 trigger not Delta and deltaBuilded and FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) do
2180: LD_EXP 4
2184: NOT
2185: PUSH
2186: LD_EXP 2
2190: AND
2191: PUSH
2192: LD_INT 22
2194: PUSH
2195: LD_INT 1
2197: PUSH
2198: EMPTY
2199: LIST
2200: LIST
2201: PUSH
2202: LD_INT 3
2204: PUSH
2205: LD_INT 57
2207: PUSH
2208: EMPTY
2209: LIST
2210: PUSH
2211: EMPTY
2212: LIST
2213: LIST
2214: PUSH
2215: LD_INT 30
2217: PUSH
2218: LD_INT 0
2220: PUSH
2221: EMPTY
2222: LIST
2223: LIST
2224: PUSH
2225: EMPTY
2226: LIST
2227: LIST
2228: LIST
2229: PUSH
2230: EMPTY
2231: LIST
2232: PPUSH
2233: CALL_OW 69
2237: AND
2238: IFFALSE 2311
2240: GO 2242
2242: DISABLE
// begin enable ;
2243: ENABLE
// Delta := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_depot ] ] ] ) [ 1 ] ;
2244: LD_ADDR_EXP 4
2248: PUSH
2249: LD_INT 22
2251: PUSH
2252: LD_INT 1
2254: PUSH
2255: EMPTY
2256: LIST
2257: LIST
2258: PUSH
2259: LD_INT 3
2261: PUSH
2262: LD_INT 57
2264: PUSH
2265: EMPTY
2266: LIST
2267: PUSH
2268: EMPTY
2269: LIST
2270: LIST
2271: PUSH
2272: LD_INT 30
2274: PUSH
2275: LD_INT 0
2277: PUSH
2278: EMPTY
2279: LIST
2280: LIST
2281: PUSH
2282: EMPTY
2283: LIST
2284: LIST
2285: LIST
2286: PUSH
2287: EMPTY
2288: LIST
2289: PPUSH
2290: CALL_OW 69
2294: PUSH
2295: LD_INT 1
2297: ARRAY
2298: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
2299: LD_EXP 4
2303: PPUSH
2304: LD_STRING Delta
2306: PPUSH
2307: CALL_OW 500
// end ;
2311: END
// every 0 0$2 trigger GetTech ( tech_ApeLang , 1 ) = state_researched do
2312: LD_INT 1
2314: PPUSH
2315: LD_INT 1
2317: PPUSH
2318: CALL_OW 321
2322: PUSH
2323: LD_INT 2
2325: EQUAL
2326: IFFALSE 2387
2328: GO 2330
2330: DISABLE
// begin DialogueOn ;
2331: CALL_OW 6
// Say ( Gladstone , D3-Glad-1 ) ;
2335: LD_EXP 14
2339: PPUSH
2340: LD_STRING D3-Glad-1
2342: PPUSH
2343: CALL_OW 88
// Say ( JMM , D3-JMM-1 ) ;
2347: LD_EXP 13
2351: PPUSH
2352: LD_STRING D3-JMM-1
2354: PPUSH
2355: CALL_OW 88
// Say ( Gladstone , D3-Glad-2 ) ;
2359: LD_EXP 14
2363: PPUSH
2364: LD_STRING D3-Glad-2
2366: PPUSH
2367: CALL_OW 88
// Say ( JMM , D3-JMM-2 ) ;
2371: LD_EXP 13
2375: PPUSH
2376: LD_STRING D3-JMM-2
2378: PPUSH
2379: CALL_OW 88
// DialogueOff ;
2383: CALL_OW 7
// end ;
2387: END
// every 0 0$1 trigger GetTech ( tech_ApePsych , 1 ) = state_researched do var sol ;
2388: LD_INT 2
2390: PPUSH
2391: LD_INT 1
2393: PPUSH
2394: CALL_OW 321
2398: PUSH
2399: LD_INT 2
2401: EQUAL
2402: IFFALSE 2579
2404: GO 2406
2406: DISABLE
2407: LD_INT 0
2409: PPUSH
// begin DialogueOn ;
2410: CALL_OW 6
// if Frank then
2414: LD_EXP 20
2418: IFFALSE 2432
// Say ( Frank , D8a-Frank-1 ) ;
2420: LD_EXP 20
2424: PPUSH
2425: LD_STRING D8a-Frank-1
2427: PPUSH
2428: CALL_OW 88
// sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D8a-Sol1-1 ) ;
2432: LD_ADDR_VAR 0 1
2436: PUSH
2437: LD_EXP 23
2441: PPUSH
2442: LD_INT 26
2444: PUSH
2445: LD_INT 1
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: PPUSH
2452: CALL_OW 72
2456: PPUSH
2457: LD_STRING D8a-Sol1-1
2459: PPUSH
2460: CALL 425 0 2
2464: ST_TO_ADDR
// if Denis and GetSide ( Denis ) = 1 then
2465: LD_EXP 16
2469: PUSH
2470: LD_EXP 16
2474: PPUSH
2475: CALL_OW 255
2479: PUSH
2480: LD_INT 1
2482: EQUAL
2483: AND
2484: IFFALSE 2498
// Say ( Denis , D8a-Den-1 ) ;
2486: LD_EXP 16
2490: PPUSH
2491: LD_STRING D8a-Den-1
2493: PPUSH
2494: CALL_OW 88
// if sol or Denis or Frank then
2498: LD_VAR 0 1
2502: PUSH
2503: LD_EXP 16
2507: OR
2508: PUSH
2509: LD_EXP 20
2513: OR
2514: IFFALSE 2575
// begin SayX ( UnitFilter ( others , [ [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff sol , D8a-Sci1-1 ) ;
2516: LD_EXP 23
2520: PPUSH
2521: LD_INT 25
2523: PUSH
2524: LD_INT 4
2526: PUSH
2527: EMPTY
2528: LIST
2529: LIST
2530: PUSH
2531: LD_INT 26
2533: PUSH
2534: LD_INT 1
2536: PUSH
2537: EMPTY
2538: LIST
2539: LIST
2540: PUSH
2541: EMPTY
2542: LIST
2543: LIST
2544: PPUSH
2545: CALL_OW 72
2549: PUSH
2550: LD_VAR 0 1
2554: DIFF
2555: PPUSH
2556: LD_STRING D8a-Sci1-1
2558: PPUSH
2559: CALL 425 0 2
// Say ( JMM , D8a-JMM-1 ) ;
2563: LD_EXP 13
2567: PPUSH
2568: LD_STRING D8a-JMM-1
2570: PPUSH
2571: CALL_OW 88
// end ; DialogueOff ;
2575: CALL_OW 7
// end ;
2579: PPOPN 1
2581: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) do
2582: LD_INT 22
2584: PUSH
2585: LD_INT 1
2587: PUSH
2588: EMPTY
2589: LIST
2590: LIST
2591: PUSH
2592: LD_INT 25
2594: PUSH
2595: LD_INT 16
2597: PUSH
2598: EMPTY
2599: LIST
2600: LIST
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: PPUSH
2606: CALL_OW 69
2610: IFFALSE 2669
2612: GO 2614
2614: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
2615: LD_STRING M1a
2617: PPUSH
2618: CALL_OW 337
// case Query ( Q2 ) of 1 :
2622: LD_STRING Q2
2624: PPUSH
2625: CALL_OW 97
2629: PUSH
2630: LD_INT 1
2632: DOUBLE
2633: EQUAL
2634: IFTRUE 2638
2636: GO 2649
2638: POP
// end_mission := true ; 2 :
2639: LD_ADDR_EXP 12
2643: PUSH
2644: LD_INT 1
2646: ST_TO_ADDR
2647: GO 2669
2649: LD_INT 2
2651: DOUBLE
2652: EQUAL
2653: IFTRUE 2657
2655: GO 2668
2657: POP
// end_the_mission_allowed := true ; end ;
2658: LD_ADDR_OWVAR 57
2662: PUSH
2663: LD_INT 1
2665: ST_TO_ADDR
2666: GO 2669
2668: POP
// end ;
2669: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) and Delta do
2670: LD_INT 22
2672: PUSH
2673: LD_INT 1
2675: PUSH
2676: EMPTY
2677: LIST
2678: LIST
2679: PUSH
2680: LD_INT 2
2682: PUSH
2683: LD_INT 30
2685: PUSH
2686: LD_INT 6
2688: PUSH
2689: EMPTY
2690: LIST
2691: LIST
2692: PUSH
2693: LD_INT 30
2695: PUSH
2696: LD_INT 7
2698: PUSH
2699: EMPTY
2700: LIST
2701: LIST
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: LIST
2707: PUSH
2708: EMPTY
2709: LIST
2710: LIST
2711: PPUSH
2712: CALL_OW 69
2716: PUSH
2717: LD_INT 22
2719: PUSH
2720: LD_INT 1
2722: PUSH
2723: EMPTY
2724: LIST
2725: LIST
2726: PUSH
2727: LD_INT 2
2729: PUSH
2730: LD_INT 30
2732: PUSH
2733: LD_INT 2
2735: PUSH
2736: EMPTY
2737: LIST
2738: LIST
2739: PUSH
2740: LD_INT 30
2742: PUSH
2743: LD_INT 3
2745: PUSH
2746: EMPTY
2747: LIST
2748: LIST
2749: PUSH
2750: EMPTY
2751: LIST
2752: LIST
2753: LIST
2754: PUSH
2755: EMPTY
2756: LIST
2757: LIST
2758: PPUSH
2759: CALL_OW 69
2763: AND
2764: PUSH
2765: LD_EXP 4
2769: AND
2770: IFFALSE 3180
2772: GO 2774
2774: DISABLE
// begin Wait ( rand ( 0 0$20 , 0 0$40 ) ) ;
2775: LD_INT 700
2777: PPUSH
2778: LD_INT 1400
2780: PPUSH
2781: CALL_OW 12
2785: PPUSH
2786: CALL_OW 67
// PlaceUnitArea ( Denis , [ denisArea1 , denisArea2 , denisArea3 ] [ Difficulty ] , false ) ;
2790: LD_EXP 16
2794: PPUSH
2795: LD_INT 6
2797: PUSH
2798: LD_INT 9
2800: PUSH
2801: LD_INT 10
2803: PUSH
2804: EMPTY
2805: LIST
2806: LIST
2807: LIST
2808: PUSH
2809: LD_OWVAR 67
2813: ARRAY
2814: PPUSH
2815: LD_INT 0
2817: PPUSH
2818: CALL_OW 49
// ComHold ( Denis ) ;
2822: LD_EXP 16
2826: PPUSH
2827: CALL_OW 140
// InGameOn ;
2831: CALL_OW 8
// DialogueOn ;
2835: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
2839: LD_EXP 13
2843: PPUSH
2844: CALL_OW 87
// Say ( Denis , DD-Den-1 ) ;
2848: LD_EXP 16
2852: PPUSH
2853: LD_STRING DD-Den-1
2855: PPUSH
2856: CALL_OW 88
// Say ( JMM , DD-JMM-1 ) ;
2860: LD_EXP 13
2864: PPUSH
2865: LD_STRING DD-JMM-1
2867: PPUSH
2868: CALL_OW 88
// Say ( Denis , DD-Den-2 ) ;
2872: LD_EXP 16
2876: PPUSH
2877: LD_STRING DD-Den-2
2879: PPUSH
2880: CALL_OW 88
// Wait ( 3 ) ;
2884: LD_INT 3
2886: PPUSH
2887: CALL_OW 67
// DialogueOff ;
2891: CALL_OW 7
// InGameOff ;
2895: CALL_OW 9
// repeat wait ( 0 0$01 ) ;
2899: LD_INT 35
2901: PPUSH
2902: CALL_OW 67
// until See ( 1 , Denis ) or IsDead ( Denis ) ;
2906: LD_INT 1
2908: PPUSH
2909: LD_EXP 16
2913: PPUSH
2914: CALL_OW 292
2918: PUSH
2919: LD_EXP 16
2923: PPUSH
2924: CALL_OW 301
2928: OR
2929: IFFALSE 2899
// if IsDead ( Denis ) then
2931: LD_EXP 16
2935: PPUSH
2936: CALL_OW 301
2940: IFFALSE 2944
// exit ;
2942: GO 3180
// SetSide ( Denis , 1 ) ;
2944: LD_EXP 16
2948: PPUSH
2949: LD_INT 1
2951: PPUSH
2952: CALL_OW 235
// Say ( Denis , DD-Den-2a ) ;
2956: LD_EXP 16
2960: PPUSH
2961: LD_STRING DD-Den-2a
2963: PPUSH
2964: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
2968: LD_INT 35
2970: PPUSH
2971: CALL_OW 67
// until GetBType ( IsInUnit ( Denis ) ) in [ b_lab , b_lab_half , b_lab_full ] or IsDead ( Denis ) ;
2975: LD_EXP 16
2979: PPUSH
2980: CALL_OW 310
2984: PPUSH
2985: CALL_OW 266
2989: PUSH
2990: LD_INT 6
2992: PUSH
2993: LD_INT 7
2995: PUSH
2996: LD_INT 8
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: LIST
3003: IN
3004: PUSH
3005: LD_EXP 16
3009: PPUSH
3010: CALL_OW 301
3014: OR
3015: IFFALSE 2968
// if IsDead ( Denis ) then
3017: LD_EXP 16
3021: PPUSH
3022: CALL_OW 301
3026: IFFALSE 3030
// exit ;
3028: GO 3180
// Say ( Denis , DD-Den-2b ) ;
3030: LD_EXP 16
3034: PPUSH
3035: LD_STRING DD-Den-2b
3037: PPUSH
3038: CALL_OW 88
// ComChangeProfession ( Denis , 4 ) ;
3042: LD_EXP 16
3046: PPUSH
3047: LD_INT 4
3049: PPUSH
3050: CALL_OW 123
// Wait ( 0 0$02 ) ;
3054: LD_INT 70
3056: PPUSH
3057: CALL_OW 67
// DialogueOn ;
3061: CALL_OW 6
// CenterNowOnUnits ( Denis ) ;
3065: LD_EXP 16
3069: PPUSH
3070: CALL_OW 87
// Say ( JMM , D4-JMM-1 ) ;
3074: LD_EXP 13
3078: PPUSH
3079: LD_STRING D4-JMM-1
3081: PPUSH
3082: CALL_OW 88
// Say ( Denis , D4-Den-1 ) ;
3086: LD_EXP 16
3090: PPUSH
3091: LD_STRING D4-Den-1
3093: PPUSH
3094: CALL_OW 88
// Say ( JMM , D4-JMM-2 ) ;
3098: LD_EXP 13
3102: PPUSH
3103: LD_STRING D4-JMM-2
3105: PPUSH
3106: CALL_OW 88
// Say ( Denis , D4-Den-2 ) ;
3110: LD_EXP 16
3114: PPUSH
3115: LD_STRING D4-Den-2
3117: PPUSH
3118: CALL_OW 88
// DialogueOff ;
3122: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
3126: LD_STRING M2
3128: PPUSH
3129: CALL_OW 337
// radar_allowed := true ;
3133: LD_ADDR_EXP 5
3137: PUSH
3138: LD_INT 1
3140: ST_TO_ADDR
// SetTech ( tech_radar , 1 , state_enabled ) ;
3141: LD_INT 6
3143: PPUSH
3144: LD_INT 1
3146: PPUSH
3147: LD_INT 1
3149: PPUSH
3150: CALL_OW 322
// SetRestrict ( b_lab_opto , 1 , state_enabled ) ;
3154: LD_INT 15
3156: PPUSH
3157: LD_INT 1
3159: PPUSH
3160: LD_INT 1
3162: PPUSH
3163: CALL_OW 324
// SetRestrict ( b_ext_radar , 1 , state_enabled ) ;
3167: LD_INT 20
3169: PPUSH
3170: LD_INT 1
3172: PPUSH
3173: LD_INT 1
3175: PPUSH
3176: CALL_OW 324
// end ;
3180: END
// every 0 0$1 trigger arab_spotted do var sol , sol2 ;
3181: LD_EXP 11
3185: IFFALSE 3808
3187: GO 3189
3189: DISABLE
3190: LD_INT 0
3192: PPUSH
3193: PPUSH
// begin sol := SayX ( UnitFilter ( others , [ f_sex , sex_male ] ) , D5-Sol1-1 ) ;
3194: LD_ADDR_VAR 0 1
3198: PUSH
3199: LD_EXP 23
3203: PPUSH
3204: LD_INT 26
3206: PUSH
3207: LD_INT 1
3209: PUSH
3210: EMPTY
3211: LIST
3212: LIST
3213: PPUSH
3214: CALL_OW 72
3218: PPUSH
3219: LD_STRING D5-Sol1-1
3221: PPUSH
3222: CALL 425 0 2
3226: ST_TO_ADDR
// if not sol then
3227: LD_VAR 0 1
3231: NOT
3232: IFFALSE 3236
// exit ;
3234: GO 3808
// repeat wait ( 0 0$01 ) ;
3236: LD_INT 35
3238: PPUSH
3239: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) = 0 ;
3243: LD_INT 22
3245: PUSH
3246: LD_INT 2
3248: PUSH
3249: EMPTY
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 21
3255: PUSH
3256: LD_INT 2
3258: PUSH
3259: EMPTY
3260: LIST
3261: LIST
3262: PUSH
3263: EMPTY
3264: LIST
3265: LIST
3266: PPUSH
3267: CALL_OW 69
3271: PUSH
3272: LD_INT 0
3274: EQUAL
3275: IFFALSE 3236
// if IsOk ( sol ) then
3277: LD_VAR 0 1
3281: PPUSH
3282: CALL_OW 302
3286: IFFALSE 3306
// begin sol2 := others diff sol ;
3288: LD_ADDR_VAR 0 2
3292: PUSH
3293: LD_EXP 23
3297: PUSH
3298: LD_VAR 0 1
3302: DIFF
3303: ST_TO_ADDR
// end else
3304: GO 3308
// exit ;
3306: GO 3808
// if not Lisa and not sol2 then
3308: LD_EXP 19
3312: NOT
3313: PUSH
3314: LD_VAR 0 2
3318: NOT
3319: AND
3320: IFFALSE 3324
// exit ;
3322: GO 3808
// DialogueOn ;
3324: CALL_OW 6
// if Lisa then
3328: LD_EXP 19
3332: IFFALSE 3348
// Say ( Lisa , D5a-Lisa-1 ) else
3334: LD_EXP 19
3338: PPUSH
3339: LD_STRING D5a-Lisa-1
3341: PPUSH
3342: CALL_OW 88
3346: GO 3423
// if sol2 then
3348: LD_VAR 0 2
3352: IFFALSE 3423
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3354: LD_VAR 0 2
3358: PUSH
3359: LD_INT 1
3361: ARRAY
3362: PPUSH
3363: CALL_OW 258
3367: PUSH
3368: LD_INT 1
3370: DOUBLE
3371: EQUAL
3372: IFTRUE 3376
3374: GO 3395
3376: POP
// Say ( sol2 [ 1 ] , D5-Sol2-1 ) ; sex_female :
3377: LD_VAR 0 2
3381: PUSH
3382: LD_INT 1
3384: ARRAY
3385: PPUSH
3386: LD_STRING D5-Sol2-1
3388: PPUSH
3389: CALL_OW 88
3393: GO 3423
3395: LD_INT 2
3397: DOUBLE
3398: EQUAL
3399: IFTRUE 3403
3401: GO 3422
3403: POP
// Say ( sol2 [ 1 ] , D5-FSol2-1 ) ; end ;
3404: LD_VAR 0 2
3408: PUSH
3409: LD_INT 1
3411: ARRAY
3412: PPUSH
3413: LD_STRING D5-FSol2-1
3415: PPUSH
3416: CALL_OW 88
3420: GO 3423
3422: POP
// Say ( sol , D5-Sol1-2 ) ;
3423: LD_VAR 0 1
3427: PPUSH
3428: LD_STRING D5-Sol1-2
3430: PPUSH
3431: CALL_OW 88
// if Lisa then
3435: LD_EXP 19
3439: IFFALSE 3455
// Say ( Lisa , D5a-Lisa-2 ) else
3441: LD_EXP 19
3445: PPUSH
3446: LD_STRING D5a-Lisa-2
3448: PPUSH
3449: CALL_OW 88
3453: GO 3530
// if sol2 then
3455: LD_VAR 0 2
3459: IFFALSE 3530
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3461: LD_VAR 0 2
3465: PUSH
3466: LD_INT 1
3468: ARRAY
3469: PPUSH
3470: CALL_OW 258
3474: PUSH
3475: LD_INT 1
3477: DOUBLE
3478: EQUAL
3479: IFTRUE 3483
3481: GO 3502
3483: POP
// Say ( sol2 [ 1 ] , D5-Sol2-2 ) ; sex_female :
3484: LD_VAR 0 2
3488: PUSH
3489: LD_INT 1
3491: ARRAY
3492: PPUSH
3493: LD_STRING D5-Sol2-2
3495: PPUSH
3496: CALL_OW 88
3500: GO 3530
3502: LD_INT 2
3504: DOUBLE
3505: EQUAL
3506: IFTRUE 3510
3508: GO 3529
3510: POP
// Say ( sol2 [ 1 ] , D5-FSol2-2 ) ; end ;
3511: LD_VAR 0 2
3515: PUSH
3516: LD_INT 1
3518: ARRAY
3519: PPUSH
3520: LD_STRING D5-FSol2-2
3522: PPUSH
3523: CALL_OW 88
3527: GO 3530
3529: POP
// Say ( sol , D5a-Sol1-3 ) ;
3530: LD_VAR 0 1
3534: PPUSH
3535: LD_STRING D5a-Sol1-3
3537: PPUSH
3538: CALL_OW 88
// if Lisa then
3542: LD_EXP 19
3546: IFFALSE 3560
// Say ( Lisa , D5a-Lisa-3 ) ;
3548: LD_EXP 19
3552: PPUSH
3553: LD_STRING D5a-Lisa-3
3555: PPUSH
3556: CALL_OW 88
// if not sol2 then
3560: LD_VAR 0 2
3564: NOT
3565: IFFALSE 3573
// begin DialogueOff ;
3567: CALL_OW 7
// exit ;
3571: GO 3808
// end ; case GetSex ( sol2 [ 1 ] ) of sex_male :
3573: LD_VAR 0 2
3577: PUSH
3578: LD_INT 1
3580: ARRAY
3581: PPUSH
3582: CALL_OW 258
3586: PUSH
3587: LD_INT 1
3589: DOUBLE
3590: EQUAL
3591: IFTRUE 3595
3593: GO 3614
3595: POP
// Say ( sol2 [ 1 ] , D5-Sol2-3 ) ; sex_female :
3596: LD_VAR 0 2
3600: PUSH
3601: LD_INT 1
3603: ARRAY
3604: PPUSH
3605: LD_STRING D5-Sol2-3
3607: PPUSH
3608: CALL_OW 88
3612: GO 3642
3614: LD_INT 2
3616: DOUBLE
3617: EQUAL
3618: IFTRUE 3622
3620: GO 3641
3622: POP
// Say ( sol2 [ 1 ] , D5-FSol2-3 ) ; end ;
3623: LD_VAR 0 2
3627: PUSH
3628: LD_INT 1
3630: ARRAY
3631: PPUSH
3632: LD_STRING D5-FSol2-3
3634: PPUSH
3635: CALL_OW 88
3639: GO 3642
3641: POP
// Say ( sol , D5-Sol1-4 ) ;
3642: LD_VAR 0 1
3646: PPUSH
3647: LD_STRING D5-Sol1-4
3649: PPUSH
3650: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3654: LD_VAR 0 2
3658: PUSH
3659: LD_INT 1
3661: ARRAY
3662: PPUSH
3663: CALL_OW 258
3667: PUSH
3668: LD_INT 1
3670: DOUBLE
3671: EQUAL
3672: IFTRUE 3676
3674: GO 3695
3676: POP
// Say ( sol2 [ 1 ] , D5-Sol2-4 ) ; sex_female :
3677: LD_VAR 0 2
3681: PUSH
3682: LD_INT 1
3684: ARRAY
3685: PPUSH
3686: LD_STRING D5-Sol2-4
3688: PPUSH
3689: CALL_OW 88
3693: GO 3723
3695: LD_INT 2
3697: DOUBLE
3698: EQUAL
3699: IFTRUE 3703
3701: GO 3722
3703: POP
// Say ( sol2 [ 1 ] , D5-FSol2-4 ) ; end ;
3704: LD_VAR 0 2
3708: PUSH
3709: LD_INT 1
3711: ARRAY
3712: PPUSH
3713: LD_STRING D5-FSol2-4
3715: PPUSH
3716: CALL_OW 88
3720: GO 3723
3722: POP
// Say ( sol , D5-Sol1-5 ) ;
3723: LD_VAR 0 1
3727: PPUSH
3728: LD_STRING D5-Sol1-5
3730: PPUSH
3731: CALL_OW 88
// case GetSex ( sol2 [ 1 ] ) of sex_male :
3735: LD_VAR 0 2
3739: PUSH
3740: LD_INT 1
3742: ARRAY
3743: PPUSH
3744: CALL_OW 258
3748: PUSH
3749: LD_INT 1
3751: DOUBLE
3752: EQUAL
3753: IFTRUE 3757
3755: GO 3776
3757: POP
// Say ( sol2 [ 1 ] , D5-Sol2-5 ) ; sex_female :
3758: LD_VAR 0 2
3762: PUSH
3763: LD_INT 1
3765: ARRAY
3766: PPUSH
3767: LD_STRING D5-Sol2-5
3769: PPUSH
3770: CALL_OW 88
3774: GO 3804
3776: LD_INT 2
3778: DOUBLE
3779: EQUAL
3780: IFTRUE 3784
3782: GO 3803
3784: POP
// Say ( sol2 [ 1 ] , D5-FSol2-5 ) ; end ;
3785: LD_VAR 0 2
3789: PUSH
3790: LD_INT 1
3792: ARRAY
3793: PPUSH
3794: LD_STRING D5-FSol2-5
3796: PPUSH
3797: CALL_OW 88
3801: GO 3804
3803: POP
// DialogueOff ;
3804: CALL_OW 7
// end ;
3808: PPOPN 2
3810: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 5 do
3811: LD_INT 22
3813: PUSH
3814: LD_INT 1
3816: PUSH
3817: EMPTY
3818: LIST
3819: LIST
3820: PUSH
3821: LD_INT 25
3823: PUSH
3824: LD_INT 16
3826: PUSH
3827: EMPTY
3828: LIST
3829: LIST
3830: PUSH
3831: EMPTY
3832: LIST
3833: LIST
3834: PPUSH
3835: CALL_OW 69
3839: PUSH
3840: LD_INT 5
3842: GREATEREQUAL
3843: IFFALSE 3863
3845: GO 3847
3847: DISABLE
// begin ChangeMissionObjectives ( M1b ) ;
3848: LD_STRING M1b
3850: PPUSH
3851: CALL_OW 337
// apeman_army := true ;
3855: LD_ADDR_EXP 7
3859: PUSH
3860: LD_INT 1
3862: ST_TO_ADDR
// end ;
3863: END
// every 0 0$1 trigger GetTech ( tech_radar , 1 ) = state_researched do
3864: LD_INT 6
3866: PPUSH
3867: LD_INT 1
3869: PPUSH
3870: CALL_OW 321
3874: PUSH
3875: LD_INT 2
3877: EQUAL
3878: IFFALSE 3898
3880: GO 3882
3882: DISABLE
// begin ChangeMissionObjectives ( M2a ) ;
3883: LD_STRING M2a
3885: PPUSH
3886: CALL_OW 337
// radar_researched := true ;
3890: LD_ADDR_EXP 8
3894: PUSH
3895: LD_INT 1
3897: ST_TO_ADDR
// end ;
3898: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_weapon , us_radar ] , [ f_bweapon , us_radar ] ] ] ) do
3899: LD_INT 22
3901: PUSH
3902: LD_INT 1
3904: PUSH
3905: EMPTY
3906: LIST
3907: LIST
3908: PUSH
3909: LD_INT 2
3911: PUSH
3912: LD_INT 34
3914: PUSH
3915: LD_INT 11
3917: PUSH
3918: EMPTY
3919: LIST
3920: LIST
3921: PUSH
3922: LD_INT 35
3924: PUSH
3925: LD_INT 11
3927: PUSH
3928: EMPTY
3929: LIST
3930: LIST
3931: PUSH
3932: EMPTY
3933: LIST
3934: LIST
3935: LIST
3936: PUSH
3937: EMPTY
3938: LIST
3939: LIST
3940: PPUSH
3941: CALL_OW 69
3945: IFFALSE 3965
3947: GO 3949
3949: DISABLE
// begin ChangeMissionObjectives ( M2b ) ;
3950: LD_STRING M2b
3952: PPUSH
3953: CALL_OW 337
// radar_builded := true ;
3957: LD_ADDR_EXP 9
3961: PUSH
3962: LD_INT 1
3964: ST_TO_ADDR
// end ;
3965: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) = 0 and not first_apeman_tamed do
3966: LD_INT 22
3968: PUSH
3969: LD_INT 0
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: PUSH
3976: LD_INT 25
3978: PUSH
3979: LD_INT 12
3981: PUSH
3982: EMPTY
3983: LIST
3984: LIST
3985: PUSH
3986: EMPTY
3987: LIST
3988: LIST
3989: PPUSH
3990: CALL_OW 69
3994: PUSH
3995: LD_INT 0
3997: EQUAL
3998: PUSH
3999: LD_EXP 6
4003: NOT
4004: AND
4005: IFFALSE 4017
4007: GO 4009
4009: DISABLE
// YouLost ( Apeman ) ;
4010: LD_STRING Apeman
4012: PPUSH
4013: CALL_OW 104
4017: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) >= 7 do var i , filter ;
4018: LD_INT 22
4020: PUSH
4021: LD_INT 1
4023: PUSH
4024: EMPTY
4025: LIST
4026: LIST
4027: PUSH
4028: LD_INT 25
4030: PUSH
4031: LD_INT 16
4033: PUSH
4034: EMPTY
4035: LIST
4036: LIST
4037: PUSH
4038: EMPTY
4039: LIST
4040: LIST
4041: PPUSH
4042: CALL_OW 69
4046: PUSH
4047: LD_INT 7
4049: GREATEREQUAL
4050: IFFALSE 4148
4052: GO 4054
4054: DISABLE
4055: LD_INT 0
4057: PPUSH
4058: PPUSH
// begin filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , 4 ] ] ) ^ JMM ;
4059: LD_ADDR_VAR 0 2
4063: PUSH
4064: LD_INT 22
4066: PUSH
4067: LD_INT 1
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: PUSH
4074: LD_INT 21
4076: PUSH
4077: LD_INT 1
4079: PUSH
4080: EMPTY
4081: LIST
4082: LIST
4083: PUSH
4084: LD_INT 25
4086: PUSH
4087: LD_INT 4
4089: PUSH
4090: EMPTY
4091: LIST
4092: LIST
4093: PUSH
4094: EMPTY
4095: LIST
4096: LIST
4097: LIST
4098: PPUSH
4099: CALL_OW 69
4103: PUSH
4104: LD_EXP 13
4108: ADD
4109: ST_TO_ADDR
// if filter then
4110: LD_VAR 0 2
4114: IFFALSE 4148
// for i in filter do
4116: LD_ADDR_VAR 0 1
4120: PUSH
4121: LD_VAR 0 2
4125: PUSH
4126: FOR_IN
4127: IFFALSE 4146
// AddExperience ( i , 4 , 12500 ) ;
4129: LD_VAR 0 1
4133: PPUSH
4134: LD_INT 4
4136: PPUSH
4137: LD_INT 12500
4139: PPUSH
4140: CALL_OW 492
4144: GO 4126
4146: POP
4147: POP
// end ;
4148: PPOPN 2
4150: END
// every 0 0$1 trigger end_mission do var i , tmp ;
4151: LD_EXP 12
4155: IFFALSE 5116
4157: GO 4159
4159: DISABLE
4160: LD_INT 0
4162: PPUSH
4163: PPUSH
// begin if FilterAllUnits ( [ f_side , 2 ] ) then
4164: LD_INT 22
4166: PUSH
4167: LD_INT 2
4169: PUSH
4170: EMPTY
4171: LIST
4172: LIST
4173: PPUSH
4174: CALL_OW 69
4178: IFFALSE 4216
// for i in FilterAllUnits ( [ f_side , 2 ] ) do
4180: LD_ADDR_VAR 0 1
4184: PUSH
4185: LD_INT 22
4187: PUSH
4188: LD_INT 2
4190: PUSH
4191: EMPTY
4192: LIST
4193: LIST
4194: PPUSH
4195: CALL_OW 69
4199: PUSH
4200: FOR_IN
4201: IFFALSE 4214
// RemoveUnit ( i ) ;
4203: LD_VAR 0 1
4207: PPUSH
4208: CALL_OW 64
4212: GO 4200
4214: POP
4215: POP
// if apeman_army then
4216: LD_EXP 7
4220: IFFALSE 4234
// AddMedal ( Tame , 1 ) else
4222: LD_STRING Tame
4224: PPUSH
4225: LD_INT 1
4227: PPUSH
4228: CALL_OW 101
4232: GO 4245
// AddMedal ( Tame , - 1 ) ;
4234: LD_STRING Tame
4236: PPUSH
4237: LD_INT 1
4239: NEG
4240: PPUSH
4241: CALL_OW 101
// if radar_researched then
4245: LD_EXP 8
4249: IFFALSE 4273
// begin SaveVariable ( true , radarResInDelta ) ;
4251: LD_INT 1
4253: PPUSH
4254: LD_STRING radarResInDelta
4256: PPUSH
4257: CALL_OW 39
// AddMedal ( Radar , 1 ) ;
4261: LD_STRING Radar
4263: PPUSH
4264: LD_INT 1
4266: PPUSH
4267: CALL_OW 101
// end else
4271: GO 4303
// if radar_allowed then
4273: LD_EXP 5
4277: IFFALSE 4292
// AddMedal ( Radar , - 2 ) else
4279: LD_STRING Radar
4281: PPUSH
4282: LD_INT 2
4284: NEG
4285: PPUSH
4286: CALL_OW 101
4290: GO 4303
// AddMedal ( Radar , - 1 ) ;
4292: LD_STRING Radar
4294: PPUSH
4295: LD_INT 1
4297: NEG
4298: PPUSH
4299: CALL_OW 101
// if radar_builded then
4303: LD_EXP 9
4307: IFFALSE 4321
// AddMedal ( BuildRadar , 1 ) else
4309: LD_STRING BuildRadar
4311: PPUSH
4312: LD_INT 1
4314: PPUSH
4315: CALL_OW 101
4319: GO 4332
// AddMedal ( BuildRadar , - 1 ) ;
4321: LD_STRING BuildRadar
4323: PPUSH
4324: LD_INT 1
4326: NEG
4327: PPUSH
4328: CALL_OW 101
// GiveMedals ( MAIN ) ;
4332: LD_STRING MAIN
4334: PPUSH
4335: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ;
4339: LD_ADDR_VAR 0 2
4343: PUSH
4344: LD_INT 22
4346: PUSH
4347: LD_INT 1
4349: PUSH
4350: EMPTY
4351: LIST
4352: LIST
4353: PUSH
4354: LD_INT 21
4356: PUSH
4357: LD_INT 1
4359: PUSH
4360: EMPTY
4361: LIST
4362: LIST
4363: PUSH
4364: LD_INT 2
4366: PUSH
4367: LD_INT 25
4369: PUSH
4370: LD_INT 1
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PUSH
4377: LD_INT 25
4379: PUSH
4380: LD_INT 2
4382: PUSH
4383: EMPTY
4384: LIST
4385: LIST
4386: PUSH
4387: LD_INT 25
4389: PUSH
4390: LD_INT 3
4392: PUSH
4393: EMPTY
4394: LIST
4395: LIST
4396: PUSH
4397: LD_INT 25
4399: PUSH
4400: LD_INT 4
4402: PUSH
4403: EMPTY
4404: LIST
4405: LIST
4406: PUSH
4407: EMPTY
4408: LIST
4409: LIST
4410: LIST
4411: LIST
4412: LIST
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: LIST
4418: PPUSH
4419: CALL_OW 69
4423: ST_TO_ADDR
// RewardPeople ( tmp ) ;
4424: LD_VAR 0 2
4428: PPUSH
4429: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
4433: LD_EXP 13
4437: PPUSH
4438: LD_STRING JMM
4440: PPUSH
4441: CALL_OW 38
// if IsOk ( Gladstone ) then
4445: LD_EXP 14
4449: PPUSH
4450: CALL_OW 302
4454: IFFALSE 4478
// begin SaveCharacters ( Gladstone , Gladstone ) ;
4456: LD_EXP 14
4460: PPUSH
4461: LD_STRING Gladstone
4463: PPUSH
4464: CALL_OW 38
// SaveVariable ( true , GladstoneInDelta ) ;
4468: LD_INT 1
4470: PPUSH
4471: LD_STRING GladstoneInDelta
4473: PPUSH
4474: CALL_OW 39
// end ; if IsOk ( Denis ) and GetSide ( Denis ) = 1 then
4478: LD_EXP 16
4482: PPUSH
4483: CALL_OW 302
4487: PUSH
4488: LD_EXP 16
4492: PPUSH
4493: CALL_OW 255
4497: PUSH
4498: LD_INT 1
4500: EQUAL
4501: AND
4502: IFFALSE 4526
// begin SaveCharacters ( Denis , Denis ) ;
4504: LD_EXP 16
4508: PPUSH
4509: LD_STRING Denis
4511: PPUSH
4512: CALL_OW 38
// SaveVariable ( true , DenisInDelta ) ;
4516: LD_INT 1
4518: PPUSH
4519: LD_STRING DenisInDelta
4521: PPUSH
4522: CALL_OW 39
// end ; if IsOk ( Lisa ) then
4526: LD_EXP 19
4530: PPUSH
4531: CALL_OW 302
4535: IFFALSE 4559
// begin SaveCharacters ( Lisa , Lisa ) ;
4537: LD_EXP 19
4541: PPUSH
4542: LD_STRING Lisa
4544: PPUSH
4545: CALL_OW 38
// SaveVariable ( true , LisaInDelta ) ;
4549: LD_INT 1
4551: PPUSH
4552: LD_STRING LisaInDelta
4554: PPUSH
4555: CALL_OW 39
// end ; if IsOk ( Frank ) then
4559: LD_EXP 20
4563: PPUSH
4564: CALL_OW 302
4568: IFFALSE 4592
// begin SaveCharacters ( Frank , Frank ) ;
4570: LD_EXP 20
4574: PPUSH
4575: LD_STRING Frank
4577: PPUSH
4578: CALL_OW 38
// SaveVariable ( true , FrankInDelta ) ;
4582: LD_INT 1
4584: PPUSH
4585: LD_STRING FrankInDelta
4587: PPUSH
4588: CALL_OW 39
// end ; if IsOk ( Bobby ) then
4592: LD_EXP 21
4596: PPUSH
4597: CALL_OW 302
4601: IFFALSE 4625
// begin SaveCharacters ( Bobby , Bobby ) ;
4603: LD_EXP 21
4607: PPUSH
4608: LD_STRING Bobby
4610: PPUSH
4611: CALL_OW 38
// SaveVariable ( true , BobbyInDelta ) ;
4615: LD_INT 1
4617: PPUSH
4618: LD_STRING BobbyInDelta
4620: PPUSH
4621: CALL_OW 39
// end ; if IsOk ( Cyrus ) then
4625: LD_EXP 22
4629: PPUSH
4630: CALL_OW 302
4634: IFFALSE 4658
// begin SaveCharacters ( Cyrus , Cyrus ) ;
4636: LD_EXP 22
4640: PPUSH
4641: LD_STRING Cyrus
4643: PPUSH
4644: CALL_OW 38
// SaveVariable ( true , CyrusInDelta ) ;
4648: LD_INT 1
4650: PPUSH
4651: LD_STRING CyrusInDelta
4653: PPUSH
4654: CALL_OW 39
// end ; if others then
4658: LD_EXP 23
4662: IFFALSE 4676
// SaveCharacters ( others , othersInDelta ) ;
4664: LD_EXP 23
4668: PPUSH
4669: LD_STRING othersInDelta
4671: PPUSH
4672: CALL_OW 38
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) then
4676: LD_INT 22
4678: PUSH
4679: LD_INT 1
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PUSH
4686: LD_INT 25
4688: PUSH
4689: LD_INT 16
4691: PUSH
4692: EMPTY
4693: LIST
4694: LIST
4695: PUSH
4696: EMPTY
4697: LIST
4698: LIST
4699: PPUSH
4700: CALL_OW 69
4704: IFFALSE 4742
// SaveCharacters ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , class_apeman_engineer ] ] ) , apeInDelta ) ;
4706: LD_INT 22
4708: PUSH
4709: LD_INT 1
4711: PUSH
4712: EMPTY
4713: LIST
4714: LIST
4715: PUSH
4716: LD_INT 25
4718: PUSH
4719: LD_INT 16
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PPUSH
4730: CALL_OW 69
4734: PPUSH
4735: LD_STRING apeInDelta
4737: PPUSH
4738: CALL_OW 38
// tmp := [ ] ;
4742: LD_ADDR_VAR 0 2
4746: PUSH
4747: EMPTY
4748: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) then
4749: LD_INT 22
4751: PUSH
4752: LD_INT 1
4754: PUSH
4755: EMPTY
4756: LIST
4757: LIST
4758: PUSH
4759: LD_INT 21
4761: PUSH
4762: LD_INT 2
4764: PUSH
4765: EMPTY
4766: LIST
4767: LIST
4768: PUSH
4769: EMPTY
4770: LIST
4771: LIST
4772: PPUSH
4773: CALL_OW 69
4777: IFFALSE 4888
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) do
4779: LD_ADDR_VAR 0 1
4783: PUSH
4784: LD_INT 22
4786: PUSH
4787: LD_INT 1
4789: PUSH
4790: EMPTY
4791: LIST
4792: LIST
4793: PUSH
4794: LD_INT 21
4796: PUSH
4797: LD_INT 2
4799: PUSH
4800: EMPTY
4801: LIST
4802: LIST
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PPUSH
4808: CALL_OW 69
4812: PUSH
4813: FOR_IN
4814: IFFALSE 4886
// tmp := tmp ^ [ GetNation ( i ) , GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
4816: LD_ADDR_VAR 0 2
4820: PUSH
4821: LD_VAR 0 2
4825: PUSH
4826: LD_VAR 0 1
4830: PPUSH
4831: CALL_OW 248
4835: PUSH
4836: LD_VAR 0 1
4840: PPUSH
4841: CALL_OW 265
4845: PUSH
4846: LD_VAR 0 1
4850: PPUSH
4851: CALL_OW 262
4855: PUSH
4856: LD_VAR 0 1
4860: PPUSH
4861: CALL_OW 263
4865: PUSH
4866: LD_VAR 0 1
4870: PPUSH
4871: CALL_OW 264
4875: PUSH
4876: EMPTY
4877: LIST
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: ADD
4883: ST_TO_ADDR
4884: GO 4813
4886: POP
4887: POP
// if tmp then
4888: LD_VAR 0 2
4892: IFFALSE 4906
// SaveVariable ( tmp , vehiclesInDelta ) ;
4894: LD_VAR 0 2
4898: PPUSH
4899: LD_STRING vehiclesInDelta
4901: PPUSH
4902: CALL_OW 39
// tmp := [ ] ;
4906: LD_ADDR_VAR 0 2
4910: PUSH
4911: EMPTY
4912: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) then
4913: LD_INT 22
4915: PUSH
4916: LD_INT 1
4918: PUSH
4919: EMPTY
4920: LIST
4921: LIST
4922: PUSH
4923: LD_INT 21
4925: PUSH
4926: LD_INT 3
4928: PUSH
4929: EMPTY
4930: LIST
4931: LIST
4932: PUSH
4933: EMPTY
4934: LIST
4935: LIST
4936: PPUSH
4937: CALL_OW 69
4941: IFFALSE 5094
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4943: LD_ADDR_VAR 0 1
4947: PUSH
4948: LD_INT 22
4950: PUSH
4951: LD_INT 1
4953: PUSH
4954: EMPTY
4955: LIST
4956: LIST
4957: PUSH
4958: LD_INT 21
4960: PUSH
4961: LD_INT 3
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: PUSH
4968: EMPTY
4969: LIST
4970: LIST
4971: PPUSH
4972: CALL_OW 69
4976: PUSH
4977: FOR_IN
4978: IFFALSE 5092
// tmp := tmp ^ [ [ GetBType ( i ) , GetBLevel ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
4980: LD_ADDR_VAR 0 2
4984: PUSH
4985: LD_VAR 0 2
4989: PUSH
4990: LD_VAR 0 1
4994: PPUSH
4995: CALL_OW 266
4999: PUSH
5000: LD_VAR 0 1
5004: PPUSH
5005: CALL_OW 267
5009: PUSH
5010: LD_VAR 0 1
5014: PPUSH
5015: CALL_OW 250
5019: PUSH
5020: LD_VAR 0 1
5024: PPUSH
5025: CALL_OW 251
5029: PUSH
5030: LD_VAR 0 1
5034: PPUSH
5035: CALL_OW 254
5039: PUSH
5040: LD_VAR 0 1
5044: PPUSH
5045: LD_INT 1
5047: PPUSH
5048: CALL_OW 268
5052: PUSH
5053: LD_VAR 0 1
5057: PPUSH
5058: LD_INT 2
5060: PPUSH
5061: CALL_OW 268
5065: PUSH
5066: LD_VAR 0 1
5070: PPUSH
5071: CALL_OW 269
5075: PUSH
5076: EMPTY
5077: LIST
5078: LIST
5079: LIST
5080: LIST
5081: LIST
5082: LIST
5083: LIST
5084: LIST
5085: PUSH
5086: EMPTY
5087: LIST
5088: ADD
5089: ST_TO_ADDR
5090: GO 4977
5092: POP
5093: POP
// if tmp then
5094: LD_VAR 0 2
5098: IFFALSE 5112
// SaveVariable ( tmp , buildingsInDelta ) ;
5100: LD_VAR 0 2
5104: PPUSH
5105: LD_STRING buildingsInDelta
5107: PPUSH
5108: CALL_OW 39
// YouWin ;
5112: CALL_OW 103
// end ; end_of_file
5116: PPOPN 2
5118: END
// export function PrepareArabianTroops ( amount , skill , area ) ; var i , un , tmp ; begin
5119: LD_INT 0
5121: PPUSH
5122: PPUSH
5123: PPUSH
5124: PPUSH
// InitHc ;
5125: CALL_OW 19
// InitUc ;
5129: CALL_OW 18
// uc_side := 2 ;
5133: LD_ADDR_OWVAR 20
5137: PUSH
5138: LD_INT 2
5140: ST_TO_ADDR
// uc_nation := 2 ;
5141: LD_ADDR_OWVAR 21
5145: PUSH
5146: LD_INT 2
5148: ST_TO_ADDR
// if not amount then
5149: LD_VAR 0 1
5153: NOT
5154: IFFALSE 5158
// exit ;
5156: GO 5281
// for i = 1 to amount do
5158: LD_ADDR_VAR 0 5
5162: PUSH
5163: DOUBLE
5164: LD_INT 1
5166: DEC
5167: ST_TO_ADDR
5168: LD_VAR 0 1
5172: PUSH
5173: FOR_TO
5174: IFFALSE 5269
// begin PrepareHuman ( false , 1 , skill ) ;
5176: LD_INT 0
5178: PPUSH
5179: LD_INT 1
5181: PPUSH
5182: LD_VAR 0 2
5186: PPUSH
5187: CALL_OW 380
// un := CreateHuman ;
5191: LD_ADDR_VAR 0 6
5195: PUSH
5196: CALL_OW 44
5200: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
5201: LD_ADDR_VAR 0 7
5205: PUSH
5206: LD_VAR 0 7
5210: PPUSH
5211: LD_INT 1
5213: PPUSH
5214: LD_VAR 0 6
5218: PPUSH
5219: CALL_OW 2
5223: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
5224: LD_VAR 0 6
5228: PPUSH
5229: LD_VAR 0 3
5233: PPUSH
5234: LD_INT 0
5236: PPUSH
5237: CALL_OW 49
// if i mod 3 = 0 then
5241: LD_VAR 0 5
5245: PUSH
5246: LD_INT 3
5248: MOD
5249: PUSH
5250: LD_INT 0
5252: EQUAL
5253: IFFALSE 5267
// SetTag ( un , 11 ) ;
5255: LD_VAR 0 6
5259: PPUSH
5260: LD_INT 11
5262: PPUSH
5263: CALL_OW 109
// end ;
5267: GO 5173
5269: POP
5270: POP
// result := tmp ;
5271: LD_ADDR_VAR 0 4
5275: PUSH
5276: LD_VAR 0 7
5280: ST_TO_ADDR
// end ;
5281: LD_VAR 0 4
5285: RET
// export ar_forces , ap_killers ; every 0 0$1 trigger Delta do var i , timer , more_troops , skill , eng , un , veh , force ;
5286: LD_EXP 4
5290: IFFALSE 6207
5292: GO 5294
5294: DISABLE
5295: LD_INT 0
5297: PPUSH
5298: PPUSH
5299: PPUSH
5300: PPUSH
5301: PPUSH
5302: PPUSH
5303: PPUSH
5304: PPUSH
// begin more_troops := false ;
5305: LD_ADDR_VAR 0 3
5309: PUSH
5310: LD_INT 0
5312: ST_TO_ADDR
// skill := [ 3 , 4 , 5 ] [ Difficulty ] ;
5313: LD_ADDR_VAR 0 4
5317: PUSH
5318: LD_INT 3
5320: PUSH
5321: LD_INT 4
5323: PUSH
5324: LD_INT 5
5326: PUSH
5327: EMPTY
5328: LIST
5329: LIST
5330: LIST
5331: PUSH
5332: LD_OWVAR 67
5336: ARRAY
5337: ST_TO_ADDR
// timer := [ 5 5$00 , 4 4$00 , 3 3$00 ] [ Difficulty ] ;
5338: LD_ADDR_VAR 0 2
5342: PUSH
5343: LD_INT 10500
5345: PUSH
5346: LD_INT 8400
5348: PUSH
5349: LD_INT 6300
5351: PUSH
5352: EMPTY
5353: LIST
5354: LIST
5355: LIST
5356: PUSH
5357: LD_OWVAR 67
5361: ARRAY
5362: ST_TO_ADDR
// force := [ ] ;
5363: LD_ADDR_VAR 0 8
5367: PUSH
5368: EMPTY
5369: ST_TO_ADDR
// ar_forces := [ ] ;
5370: LD_ADDR_EXP 24
5374: PUSH
5375: EMPTY
5376: ST_TO_ADDR
// ap_killers := [ ] ;
5377: LD_ADDR_EXP 25
5381: PUSH
5382: EMPTY
5383: ST_TO_ADDR
// Wait ( timer ) ;
5384: LD_VAR 0 2
5388: PPUSH
5389: CALL_OW 67
// if Denis and GetSide ( Denis ) = 4 then
5393: LD_EXP 16
5397: PUSH
5398: LD_EXP 16
5402: PPUSH
5403: CALL_OW 255
5407: PUSH
5408: LD_INT 4
5410: EQUAL
5411: AND
5412: IFFALSE 5421
// Wait ( 0 0$45 ) ;
5414: LD_INT 1575
5416: PPUSH
5417: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) then
5421: LD_INT 22
5423: PUSH
5424: LD_INT 1
5426: PUSH
5427: EMPTY
5428: LIST
5429: LIST
5430: PUSH
5431: LD_INT 30
5433: PUSH
5434: LD_INT 4
5436: PUSH
5437: EMPTY
5438: LIST
5439: LIST
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL_OW 69
5449: IFFALSE 5466
// begin Wait ( 1 1$25 ) ;
5451: LD_INT 2975
5453: PPUSH
5454: CALL_OW 67
// more_troops := true ;
5458: LD_ADDR_VAR 0 3
5462: PUSH
5463: LD_INT 1
5465: ST_TO_ADDR
// end ; if more_troops then
5466: LD_VAR 0 3
5470: IFFALSE 5658
// begin force := PrepareArabianTroops ( [ 4 , 5 , 6 ] [ Difficulty ] , skill , arArea2 ) ;
5472: LD_ADDR_VAR 0 8
5476: PUSH
5477: LD_INT 4
5479: PUSH
5480: LD_INT 5
5482: PUSH
5483: LD_INT 6
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: LIST
5490: PUSH
5491: LD_OWVAR 67
5495: ARRAY
5496: PPUSH
5497: LD_VAR 0 4
5501: PPUSH
5502: LD_INT 14
5504: PPUSH
5505: CALL 5119 0 3
5509: ST_TO_ADDR
// veh := PrepareTank ( 2 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_heavy_machine_gun , ru_gatling_gun ] [ Difficulty ] , 90 ) ;
5510: LD_ADDR_VAR 0 7
5514: PUSH
5515: LD_INT 2
5517: PPUSH
5518: LD_INT 3
5520: PPUSH
5521: LD_INT 22
5523: PPUSH
5524: LD_INT 1
5526: PPUSH
5527: LD_INT 1
5529: PPUSH
5530: LD_INT 42
5532: PUSH
5533: LD_INT 42
5535: PUSH
5536: LD_INT 43
5538: PUSH
5539: EMPTY
5540: LIST
5541: LIST
5542: LIST
5543: PUSH
5544: LD_OWVAR 67
5548: ARRAY
5549: PPUSH
5550: LD_INT 90
5552: PPUSH
5553: CALL 337 0 7
5557: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5558: LD_VAR 0 7
5562: PPUSH
5563: LD_INT 4
5565: PPUSH
5566: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
5570: LD_VAR 0 7
5574: PPUSH
5575: LD_INT 13
5577: PPUSH
5578: LD_INT 0
5580: PPUSH
5581: CALL_OW 49
// uc_side := 2 ;
5585: LD_ADDR_OWVAR 20
5589: PUSH
5590: LD_INT 2
5592: ST_TO_ADDR
// uc_nation := 2 ;
5593: LD_ADDR_OWVAR 21
5597: PUSH
5598: LD_INT 2
5600: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5601: LD_INT 0
5603: PPUSH
5604: LD_INT 1
5606: PPUSH
5607: LD_VAR 0 4
5611: PPUSH
5612: CALL_OW 380
// un := CreateHuman ;
5616: LD_ADDR_VAR 0 6
5620: PUSH
5621: CALL_OW 44
5625: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
5626: LD_VAR 0 6
5630: PPUSH
5631: LD_VAR 0 7
5635: PPUSH
5636: CALL_OW 52
// force := force ^ un ;
5640: LD_ADDR_VAR 0 8
5644: PUSH
5645: LD_VAR 0 8
5649: PUSH
5650: LD_VAR 0 6
5654: ADD
5655: ST_TO_ADDR
// end else
5656: GO 5696
// begin force := PrepareArabianTroops ( [ 3 , 4 , 5 ] [ Difficulty ] , skill , arArea2 ) ;
5658: LD_ADDR_VAR 0 8
5662: PUSH
5663: LD_INT 3
5665: PUSH
5666: LD_INT 4
5668: PUSH
5669: LD_INT 5
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: LIST
5676: PUSH
5677: LD_OWVAR 67
5681: ARRAY
5682: PPUSH
5683: LD_VAR 0 4
5687: PPUSH
5688: LD_INT 14
5690: PPUSH
5691: CALL 5119 0 3
5695: ST_TO_ADDR
// end ; if force then
5696: LD_VAR 0 8
5700: IFFALSE 5712
// ar_forces := force ;
5702: LD_ADDR_EXP 24
5706: PUSH
5707: LD_VAR 0 8
5711: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5712: LD_INT 35
5714: PPUSH
5715: CALL_OW 67
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
5719: LD_INT 22
5721: PUSH
5722: LD_INT 2
5724: PUSH
5725: EMPTY
5726: LIST
5727: LIST
5728: PPUSH
5729: CALL_OW 69
5733: PUSH
5734: LD_INT 0
5736: EQUAL
5737: IFFALSE 5712
// Wait ( timer ) ;
5739: LD_VAR 0 2
5743: PPUSH
5744: CALL_OW 67
// force := PrepareArabianTroops ( [ 5 , 6 , 6 ] [ Difficulty ] , skill , [ arArea1 , arArea2 ] [ rand ( 1 , 2 ) ] ) ;
5748: LD_ADDR_VAR 0 8
5752: PUSH
5753: LD_INT 5
5755: PUSH
5756: LD_INT 6
5758: PUSH
5759: LD_INT 6
5761: PUSH
5762: EMPTY
5763: LIST
5764: LIST
5765: LIST
5766: PUSH
5767: LD_OWVAR 67
5771: ARRAY
5772: PPUSH
5773: LD_VAR 0 4
5777: PPUSH
5778: LD_INT 13
5780: PUSH
5781: LD_INT 14
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: PUSH
5788: LD_INT 1
5790: PPUSH
5791: LD_INT 2
5793: PPUSH
5794: CALL_OW 12
5798: ARRAY
5799: PPUSH
5800: CALL 5119 0 3
5804: ST_TO_ADDR
// if Difficulty > 1 and Delta then
5805: LD_OWVAR 67
5809: PUSH
5810: LD_INT 1
5812: GREATER
5813: PUSH
5814: LD_EXP 4
5818: AND
5819: IFFALSE 5983
// begin veh := PrepareTank ( 2 , 2 , ar_light_trike , engine_solar , control_manual , 22 , 100 ) ;
5821: LD_ADDR_VAR 0 7
5825: PUSH
5826: LD_INT 2
5828: PPUSH
5829: LD_INT 2
5831: PPUSH
5832: LD_INT 12
5834: PPUSH
5835: LD_INT 2
5837: PPUSH
5838: LD_INT 1
5840: PPUSH
5841: LD_INT 22
5843: PPUSH
5844: LD_INT 100
5846: PPUSH
5847: CALL 337 0 7
5851: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5852: LD_VAR 0 7
5856: PPUSH
5857: LD_INT 4
5859: PPUSH
5860: CALL_OW 233
// PlaceUnitArea ( veh , arArea1 , false ) ;
5864: LD_VAR 0 7
5868: PPUSH
5869: LD_INT 13
5871: PPUSH
5872: LD_INT 0
5874: PPUSH
5875: CALL_OW 49
// uc_side := 2 ;
5879: LD_ADDR_OWVAR 20
5883: PUSH
5884: LD_INT 2
5886: ST_TO_ADDR
// uc_nation := 2 ;
5887: LD_ADDR_OWVAR 21
5891: PUSH
5892: LD_INT 2
5894: ST_TO_ADDR
// PrepareHuman ( false , 2 , skill ) ;
5895: LD_INT 0
5897: PPUSH
5898: LD_INT 2
5900: PPUSH
5901: LD_VAR 0 4
5905: PPUSH
5906: CALL_OW 380
// eng := CreateHuman ;
5910: LD_ADDR_VAR 0 5
5914: PUSH
5915: CALL_OW 44
5919: ST_TO_ADDR
// PlaceHumanInUnit ( eng , veh ) ;
5920: LD_VAR 0 5
5924: PPUSH
5925: LD_VAR 0 7
5929: PPUSH
5930: CALL_OW 52
// Wait ( 3 ) ;
5934: LD_INT 3
5936: PPUSH
5937: CALL_OW 67
// ComMoveUnit ( IsDrivenBy ( eng ) , Delta ) ;
5941: LD_VAR 0 5
5945: PPUSH
5946: CALL_OW 311
5950: PPUSH
5951: LD_EXP 4
5955: PPUSH
5956: CALL_OW 112
// AddComExitVehicle ( eng ) ;
5960: LD_VAR 0 5
5964: PPUSH
5965: CALL_OW 181
// AddComEnterUnit ( eng , Delta ) ;
5969: LD_VAR 0 5
5973: PPUSH
5974: LD_EXP 4
5978: PPUSH
5979: CALL_OW 180
// end ; if force then
5983: LD_VAR 0 8
5987: IFFALSE 5999
// ar_forces := force ;
5989: LD_ADDR_EXP 24
5993: PUSH
5994: LD_VAR 0 8
5998: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
5999: LD_INT 35
6001: PPUSH
6002: CALL_OW 67
// if eng then
6006: LD_VAR 0 5
6010: IFFALSE 6064
// if GetSide ( Delta ) = 2 and IsOk ( eng ) and not IsInUnit ( eng ) then
6012: LD_EXP 4
6016: PPUSH
6017: CALL_OW 255
6021: PUSH
6022: LD_INT 2
6024: EQUAL
6025: PUSH
6026: LD_VAR 0 5
6030: PPUSH
6031: CALL_OW 302
6035: AND
6036: PUSH
6037: LD_VAR 0 5
6041: PPUSH
6042: CALL_OW 310
6046: NOT
6047: AND
6048: IFFALSE 6064
// ComEnterUnit ( eng , Delta ) ;
6050: LD_VAR 0 5
6054: PPUSH
6055: LD_EXP 4
6059: PPUSH
6060: CALL_OW 120
// until FilterAllUnits ( [ f_side , 2 ] ) = 0 ;
6064: LD_INT 22
6066: PUSH
6067: LD_INT 2
6069: PUSH
6070: EMPTY
6071: LIST
6072: LIST
6073: PPUSH
6074: CALL_OW 69
6078: PUSH
6079: LD_INT 0
6081: EQUAL
6082: IFFALSE 5999
// ap_killers := PrepareArabianTroops ( [ 1 , 2 , 2 ] [ Difficulty ] , skill , arArea1 ) ;
6084: LD_ADDR_EXP 25
6088: PUSH
6089: LD_INT 1
6091: PUSH
6092: LD_INT 2
6094: PUSH
6095: LD_INT 2
6097: PUSH
6098: EMPTY
6099: LIST
6100: LIST
6101: LIST
6102: PUSH
6103: LD_OWVAR 67
6107: ARRAY
6108: PPUSH
6109: LD_VAR 0 4
6113: PPUSH
6114: LD_INT 13
6116: PPUSH
6117: CALL 5119 0 3
6121: ST_TO_ADDR
// Wait ( timer * 2 ) ;
6122: LD_VAR 0 2
6126: PUSH
6127: LD_INT 2
6129: MUL
6130: PPUSH
6131: CALL_OW 67
// ar_forces := PrepareArabianTroops ( [ 5 , 6 , 7 ] [ Difficulty ] , skill , arArea1 ) ^ PrepareArabianTroops ( [ 3 , 4 , 4 ] [ Difficulty ] , skill , arArea2 ) ;
6135: LD_ADDR_EXP 24
6139: PUSH
6140: LD_INT 5
6142: PUSH
6143: LD_INT 6
6145: PUSH
6146: LD_INT 7
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: LIST
6153: PUSH
6154: LD_OWVAR 67
6158: ARRAY
6159: PPUSH
6160: LD_VAR 0 4
6164: PPUSH
6165: LD_INT 13
6167: PPUSH
6168: CALL 5119 0 3
6172: PUSH
6173: LD_INT 3
6175: PUSH
6176: LD_INT 4
6178: PUSH
6179: LD_INT 4
6181: PUSH
6182: EMPTY
6183: LIST
6184: LIST
6185: LIST
6186: PUSH
6187: LD_OWVAR 67
6191: ARRAY
6192: PPUSH
6193: LD_VAR 0 4
6197: PPUSH
6198: LD_INT 14
6200: PPUSH
6201: CALL 5119 0 3
6205: ADD
6206: ST_TO_ADDR
// end ;
6207: PPOPN 8
6209: END
// every 0 0$03 trigger ar_forces do var i , target ;
6210: LD_EXP 24
6214: IFFALSE 6353
6216: GO 6218
6218: DISABLE
6219: LD_INT 0
6221: PPUSH
6222: PPUSH
// begin enable ;
6223: ENABLE
// if not ar_forces then
6224: LD_EXP 24
6228: NOT
6229: IFFALSE 6233
// exit ;
6231: GO 6353
// if Delta then
6233: LD_EXP 4
6237: IFFALSE 6251
// target := Delta else
6239: LD_ADDR_VAR 0 2
6243: PUSH
6244: LD_EXP 4
6248: ST_TO_ADDR
6249: GO 6261
// target := JMM ;
6251: LD_ADDR_VAR 0 2
6255: PUSH
6256: LD_EXP 13
6260: ST_TO_ADDR
// for i in ar_forces do
6261: LD_ADDR_VAR 0 1
6265: PUSH
6266: LD_EXP 24
6270: PUSH
6271: FOR_IN
6272: IFFALSE 6351
// begin if GetDistUnits ( i , target ) > 30 then
6274: LD_VAR 0 1
6278: PPUSH
6279: LD_VAR 0 2
6283: PPUSH
6284: CALL_OW 296
6288: PUSH
6289: LD_INT 30
6291: GREATER
6292: IFFALSE 6325
// ComAgressiveMove ( i , GetX ( target ) , GetY ( target ) ) else
6294: LD_VAR 0 1
6298: PPUSH
6299: LD_VAR 0 2
6303: PPUSH
6304: CALL_OW 250
6308: PPUSH
6309: LD_VAR 0 2
6313: PPUSH
6314: CALL_OW 251
6318: PPUSH
6319: CALL_OW 114
6323: GO 6349
// Attack ( i , FilterAllUnits ( [ f_enemy , 2 ] ) ) ;
6325: LD_VAR 0 1
6329: PPUSH
6330: LD_INT 81
6332: PUSH
6333: LD_INT 2
6335: PUSH
6336: EMPTY
6337: LIST
6338: LIST
6339: PPUSH
6340: CALL_OW 69
6344: PPUSH
6345: CALL 590 0 2
// end ;
6349: GO 6271
6351: POP
6352: POP
// end ;
6353: PPOPN 2
6355: END
// every 0 0$01 trigger ap_killers do var filter , i , target ;
6356: LD_EXP 25
6360: IFFALSE 6520
6362: GO 6364
6364: DISABLE
6365: LD_INT 0
6367: PPUSH
6368: PPUSH
6369: PPUSH
// begin enable ;
6370: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6371: LD_ADDR_VAR 0 1
6375: PUSH
6376: LD_INT 22
6378: PUSH
6379: LD_INT 0
6381: PUSH
6382: EMPTY
6383: LIST
6384: LIST
6385: PUSH
6386: LD_INT 25
6388: PUSH
6389: LD_INT 12
6391: PUSH
6392: EMPTY
6393: LIST
6394: LIST
6395: PUSH
6396: EMPTY
6397: LIST
6398: LIST
6399: PPUSH
6400: CALL_OW 69
6404: ST_TO_ADDR
// if not filter then
6405: LD_VAR 0 1
6409: NOT
6410: IFFALSE 6437
// begin ar_forces := ar_forces ^ ap_killers ;
6412: LD_ADDR_EXP 24
6416: PUSH
6417: LD_EXP 24
6421: PUSH
6422: LD_EXP 25
6426: ADD
6427: ST_TO_ADDR
// ap_killers := [ ] ;
6428: LD_ADDR_EXP 25
6432: PUSH
6433: EMPTY
6434: ST_TO_ADDR
// exit ;
6435: GO 6520
// end ; for i in ap_killers do
6437: LD_ADDR_VAR 0 2
6441: PUSH
6442: LD_EXP 25
6446: PUSH
6447: FOR_IN
6448: IFFALSE 6518
// begin if not IsOk ( i ) then
6450: LD_VAR 0 2
6454: PPUSH
6455: CALL_OW 302
6459: NOT
6460: IFFALSE 6464
// continue ;
6462: GO 6447
// if not HasTask ( i ) then
6464: LD_VAR 0 2
6468: PPUSH
6469: CALL_OW 314
6473: NOT
6474: IFFALSE 6496
// target := NearestUnitToUnit ( filter , i ) ;
6476: LD_ADDR_VAR 0 3
6480: PUSH
6481: LD_VAR 0 1
6485: PPUSH
6486: LD_VAR 0 2
6490: PPUSH
6491: CALL_OW 74
6495: ST_TO_ADDR
// if target then
6496: LD_VAR 0 3
6500: IFFALSE 6516
// ComAttackUnit ( i , target ) ;
6502: LD_VAR 0 2
6506: PPUSH
6507: LD_VAR 0 3
6511: PPUSH
6512: CALL_OW 115
// end ;
6516: GO 6447
6518: POP
6519: POP
// end ; end_of_file
6520: PPOPN 3
6522: END
// every 0 0$40 + 0 0$2 trigger Delta do var i , counter , cr ;
6523: LD_EXP 4
6527: IFFALSE 6659
6529: GO 6531
6531: DISABLE
6532: LD_INT 0
6534: PPUSH
6535: PPUSH
6536: PPUSH
// begin counter := [ 700 , 600 , 500 ] [ Difficulty ] ;
6537: LD_ADDR_VAR 0 2
6541: PUSH
6542: LD_INT 700
6544: PUSH
6545: LD_INT 600
6547: PUSH
6548: LD_INT 500
6550: PUSH
6551: EMPTY
6552: LIST
6553: LIST
6554: LIST
6555: PUSH
6556: LD_OWVAR 67
6560: ARRAY
6561: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 3 ) , cratesArea , true ) ;
6562: LD_INT 1
6564: PPUSH
6565: LD_INT 3
6567: PPUSH
6568: CALL_OW 12
6572: PPUSH
6573: LD_INT 7
6575: PPUSH
6576: LD_INT 1
6578: PPUSH
6579: CALL_OW 55
// repeat wait ( rand ( 1 1$30 , 2 2$20 ) ) ;
6583: LD_INT 3150
6585: PPUSH
6586: LD_INT 4900
6588: PPUSH
6589: CALL_OW 12
6593: PPUSH
6594: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
6598: LD_ADDR_VAR 0 3
6602: PUSH
6603: LD_INT 1
6605: PPUSH
6606: LD_INT 5
6608: PPUSH
6609: CALL_OW 12
6613: ST_TO_ADDR
// CreateCratesArea ( cr , cratesArea , true ) ;
6614: LD_VAR 0 3
6618: PPUSH
6619: LD_INT 7
6621: PPUSH
6622: LD_INT 1
6624: PPUSH
6625: CALL_OW 55
// counter := counter - cr * 10 ;
6629: LD_ADDR_VAR 0 2
6633: PUSH
6634: LD_VAR 0 2
6638: PUSH
6639: LD_VAR 0 3
6643: PUSH
6644: LD_INT 10
6646: MUL
6647: MINUS
6648: ST_TO_ADDR
// until counter <= 0 ;
6649: LD_VAR 0 2
6653: PUSH
6654: LD_INT 0
6656: LESSEQUAL
6657: IFFALSE 6583
// end ;
6659: PPOPN 3
6661: END
// every 0 0$03 trigger not Delta do var i ;
6662: LD_EXP 4
6666: NOT
6667: IFFALSE 6737
6669: GO 6671
6671: DISABLE
6672: LD_INT 0
6674: PPUSH
// begin for i = 1 to 4 - Difficulty do
6675: LD_ADDR_VAR 0 1
6679: PUSH
6680: DOUBLE
6681: LD_INT 1
6683: DEC
6684: ST_TO_ADDR
6685: LD_INT 4
6687: PUSH
6688: LD_OWVAR 67
6692: MINUS
6693: PUSH
6694: FOR_TO
6695: IFFALSE 6735
// begin CreateCratesArea ( rand ( 2 , 5 ) , deltaMainArea , true ) ;
6697: LD_INT 2
6699: PPUSH
6700: LD_INT 5
6702: PPUSH
6703: CALL_OW 12
6707: PPUSH
6708: LD_INT 8
6710: PPUSH
6711: LD_INT 1
6713: PPUSH
6714: CALL_OW 55
// Wait ( rand ( 0 0$16 , 0 0$39 ) ) ;
6718: LD_INT 560
6720: PPUSH
6721: LD_INT 1365
6723: PPUSH
6724: CALL_OW 12
6728: PPUSH
6729: CALL_OW 67
// end ;
6733: GO 6694
6735: POP
6736: POP
// end ;
6737: PPOPN 1
6739: END
// every 2 2$00 do
6740: GO 6742
6742: DISABLE
// begin enable ;
6743: ENABLE
// CreateCratesAnyWhere ( rand ( 1 , 3 ) , true ) ;
6744: LD_INT 1
6746: PPUSH
6747: LD_INT 3
6749: PPUSH
6750: CALL_OW 12
6754: PPUSH
6755: LD_INT 1
6757: PPUSH
6758: CALL_OW 57
// Wait ( rand ( 0 0$38 , 0 0$59 ) ) ;
6762: LD_INT 1330
6764: PPUSH
6765: LD_INT 2065
6767: PPUSH
6768: CALL_OW 12
6772: PPUSH
6773: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 4 ) , riverArea , true ) ;
6777: LD_INT 1
6779: PPUSH
6780: LD_INT 4
6782: PPUSH
6783: CALL_OW 12
6787: PPUSH
6788: LD_INT 15
6790: PPUSH
6791: LD_INT 1
6793: PPUSH
6794: CALL_OW 55
// end ; end_of_file
6798: END
// on UnitDestroyed ( un ) do begin if un = JMM then
6799: LD_VAR 0 1
6803: PUSH
6804: LD_EXP 13
6808: EQUAL
6809: IFFALSE 6818
// YouLost ( JMM ) ;
6811: LD_STRING JMM
6813: PPUSH
6814: CALL_OW 104
// if un = Delta then
6818: LD_VAR 0 1
6822: PUSH
6823: LD_EXP 4
6827: EQUAL
6828: IFFALSE 6838
// Delta := 0 ;
6830: LD_ADDR_EXP 4
6834: PUSH
6835: LD_INT 0
6837: ST_TO_ADDR
// if un in ar_forces then
6838: LD_VAR 0 1
6842: PUSH
6843: LD_EXP 24
6847: IN
6848: IFFALSE 6866
// ar_forces := ar_forces diff un ;
6850: LD_ADDR_EXP 24
6854: PUSH
6855: LD_EXP 24
6859: PUSH
6860: LD_VAR 0 1
6864: DIFF
6865: ST_TO_ADDR
// if un in ap_killers then
6866: LD_VAR 0 1
6870: PUSH
6871: LD_EXP 25
6875: IN
6876: IFFALSE 6894
// ap_killers := ap_killers diff un ;
6878: LD_ADDR_EXP 25
6882: PUSH
6883: LD_EXP 25
6887: PUSH
6888: LD_VAR 0 1
6892: DIFF
6893: ST_TO_ADDR
// end ;
6894: PPOPN 1
6896: END
// on Contact ( s1 , s2 ) do if s1 = 1 and s2 = 2 and not arab_spotted then
6897: LD_VAR 0 1
6901: PUSH
6902: LD_INT 1
6904: EQUAL
6905: PUSH
6906: LD_VAR 0 2
6910: PUSH
6911: LD_INT 2
6913: EQUAL
6914: AND
6915: PUSH
6916: LD_EXP 11
6920: NOT
6921: AND
6922: IFFALSE 6932
// arab_spotted := true ;
6924: LD_ADDR_EXP 11
6928: PUSH
6929: LD_INT 1
6931: ST_TO_ADDR
6932: PPOPN 2
6934: END
// on EndTheMissionRaised ( p ) do begin end_the_mission_allowed := false ;
6935: LD_ADDR_OWVAR 57
6939: PUSH
6940: LD_INT 0
6942: ST_TO_ADDR
// end_mission := true ;
6943: LD_ADDR_EXP 12
6947: PUSH
6948: LD_INT 1
6950: ST_TO_ADDR
// end ;
6951: PPOPN 1
6953: END
// on ApemanTamed ( apeman , sci ) do begin if GetSide ( sci ) = 1 then
6954: LD_VAR 0 2
6958: PPUSH
6959: CALL_OW 255
6963: PUSH
6964: LD_INT 1
6966: EQUAL
6967: IFFALSE 6983
// apeman_counter := apeman_counter + 1 ;
6969: LD_ADDR_EXP 10
6973: PUSH
6974: LD_EXP 10
6978: PUSH
6979: LD_INT 1
6981: PLUS
6982: ST_TO_ADDR
// if not first_apeman_tamed then
6983: LD_EXP 6
6987: NOT
6988: IFFALSE 7188
// begin first_apeman_tamed := true ;
6990: LD_ADDR_EXP 6
6994: PUSH
6995: LD_INT 1
6997: ST_TO_ADDR
// if sci = Gladstone then
6998: LD_VAR 0 2
7002: PUSH
7003: LD_EXP 14
7007: EQUAL
7008: IFFALSE 7022
// Say ( Gladstone , D7b-Glad-1 ) ;
7010: LD_EXP 14
7014: PPUSH
7015: LD_STRING D7b-Glad-1
7017: PPUSH
7018: CALL_OW 88
// if sci = Denis then
7022: LD_VAR 0 2
7026: PUSH
7027: LD_EXP 16
7031: EQUAL
7032: IFFALSE 7046
// Say ( Denis , D7a-Den-1 ) ;
7034: LD_EXP 16
7038: PPUSH
7039: LD_STRING D7a-Den-1
7041: PPUSH
7042: CALL_OW 88
// if not sci in [ JMM , Gladstone , Denis , Lisa , Frank , Bobby , Cyrus , Donaldson ] then
7046: LD_VAR 0 2
7050: PUSH
7051: LD_EXP 13
7055: PUSH
7056: LD_EXP 14
7060: PUSH
7061: LD_EXP 16
7065: PUSH
7066: LD_EXP 19
7070: PUSH
7071: LD_EXP 20
7075: PUSH
7076: LD_EXP 21
7080: PUSH
7081: LD_EXP 22
7085: PUSH
7086: LD_EXP 18
7090: PUSH
7091: EMPTY
7092: LIST
7093: LIST
7094: LIST
7095: LIST
7096: LIST
7097: LIST
7098: LIST
7099: LIST
7100: IN
7101: NOT
7102: IFFALSE 7145
// begin if GetSex ( sci ) = sex_male then
7104: LD_VAR 0 2
7108: PPUSH
7109: CALL_OW 258
7113: PUSH
7114: LD_INT 1
7116: EQUAL
7117: IFFALSE 7133
// Say ( sci , D7c-Sci1-1 ) else
7119: LD_VAR 0 2
7123: PPUSH
7124: LD_STRING D7c-Sci1-1
7126: PPUSH
7127: CALL_OW 88
7131: GO 7145
// Say ( sci , D7c-FSci1-1 ) ;
7133: LD_VAR 0 2
7137: PPUSH
7138: LD_STRING D7c-FSci1-1
7140: PPUSH
7141: CALL_OW 88
// end ; if not sci = Gladstone then
7145: LD_VAR 0 2
7149: PUSH
7150: LD_EXP 14
7154: EQUAL
7155: NOT
7156: IFFALSE 7170
// Say ( Gladstone , D7c-Glad-1 ) ;
7158: LD_EXP 14
7162: PPUSH
7163: LD_STRING D7c-Glad-1
7165: PPUSH
7166: CALL_OW 88
// if Lisa then
7170: LD_EXP 19
7174: IFFALSE 7188
// Say ( Lisa , D8-Lisa-1 ) ;
7176: LD_EXP 19
7180: PPUSH
7181: LD_STRING D8-Lisa-1
7183: PPUSH
7184: CALL_OW 88
// end ; end ;
7188: PPOPN 2
7190: END
