// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 363 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 451 0 0
// PrepareRussian ;
  22: CALL 2980 0 0
// PrepareAmerican ;
  26: CALL 1185 0 0
// PrepareCornell ;
  30: CALL 2209 0 0
// PrepareWesternBase ;
  34: CALL 2435 0 0
// Action ;
  38: CALL 5196 0 0
// end ;
  42: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , cornel_saved , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn , save_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  54: LD_ADDR_EXP 3
  58: PUSH
  59: LD_STRING 02_
  61: ST_TO_ADDR
// mission_prefix := 03_ ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_STRING 03_
  69: ST_TO_ADDR
// jmm_units := 0 ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// cornel_units := 0 ;
  78: LD_ADDR_EXP 6
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// bierezov_exist := false ;
  86: LD_ADDR_EXP 7
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// jmm_on_west := false ;
  94: LD_ADDR_EXP 5
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_active := false ;
 102: LD_ADDR_EXP 8
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_attack := false ;
 110: LD_ADDR_EXP 9
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// cornel_prepared := false ;
 118: LD_ADDR_EXP 11
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 126: LD_ADDR_EXP 10
 130: PUSH
 131: LD_INT 4200
 133: ST_TO_ADDR
// frank_can_return := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// solar_builded := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// frank_send_to_scout := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// jmm_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// bobby_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// cyrus_in_veh := false ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// lisa_in_veh := false ;
 182: LD_ADDR_EXP 18
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 190: LD_ADDR_EXP 28
 194: PUSH
 195: LD_INT 25200
 197: PUSH
 198: LD_INT 23100
 200: PUSH
 201: LD_INT 21000
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: PUSH
 209: LD_OWVAR 67
 213: ARRAY
 214: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 215: LD_ADDR_EXP 19
 219: PUSH
 220: LD_INT 600
 222: PUSH
 223: LD_INT 500
 225: PUSH
 226: LD_INT 400
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: PUSH
 234: LD_OWVAR 67
 238: ARRAY
 239: ST_TO_ADDR
// end_mission_allowed := false ;
 240: LD_ADDR_EXP 20
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// save_others := [ ] ;
 248: LD_ADDR_EXP 21
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// save_group := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// show_query := true ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// wait_for_them := false ;
 270: LD_ADDR_EXP 24
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// veh_on_meta := false ;
 278: LD_ADDR_EXP 27
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_spec_patrol := false ;
 286: LD_ADDR_EXP 29
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// prepare_siege := false ;
 294: LD_ADDR_EXP 30
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// send_attack_on_cornel := false ;
 302: LD_ADDR_EXP 31
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 310: LD_ADDR_EXP 25
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// game_end := false ;
 318: LD_ADDR_EXP 32
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// lose_counter := 0 ;
 326: LD_ADDR_EXP 33
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// powell_warn := 0 ;
 334: LD_ADDR_EXP 34
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// save_counter := 0 ;
 342: LD_ADDR_EXP 35
 346: PUSH
 347: LD_INT 0
 349: ST_TO_ADDR
// cornel_saved := false ;
 350: LD_ADDR_EXP 26
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// end ;
 358: LD_VAR 0 1
 362: RET
// function SetDiplomacy ; begin
 363: LD_INT 0
 365: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 366: LD_INT 1
 368: PPUSH
 369: LD_INT 4
 371: PPUSH
 372: LD_INT 1
 374: PPUSH
 375: LD_INT 1
 377: PPUSH
 378: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 382: LD_INT 1
 384: PPUSH
 385: LD_INT 8
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 398: LD_INT 3
 400: PPUSH
 401: LD_INT 6
 403: PPUSH
 404: LD_INT 1
 406: PPUSH
 407: LD_INT 1
 409: PPUSH
 410: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 414: LD_INT 4
 416: PPUSH
 417: LD_INT 6
 419: PPUSH
 420: LD_INT 0
 422: PPUSH
 423: LD_INT 1
 425: PPUSH
 426: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 430: LD_INT 3
 432: PPUSH
 433: LD_INT 8
 435: PPUSH
 436: LD_INT 0
 438: PPUSH
 439: LD_INT 1
 441: PPUSH
 442: CALL_OW 80
// end ;
 446: LD_VAR 0 1
 450: RET
// export function DebugMode ; var i ; begin
 451: LD_INT 0
 453: PPUSH
 454: PPUSH
// FogOff ( 1 ) ;
 455: LD_INT 1
 457: PPUSH
 458: CALL_OW 344
// debug_strings := [ ] ;
 462: LD_ADDR_OWVAR 48
 466: PUSH
 467: EMPTY
 468: ST_TO_ADDR
// end ; end_of_file
 469: LD_VAR 0 1
 473: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 474: LD_INT 0
 476: PPUSH
 477: PPUSH
// if exist_mode then
 478: LD_VAR 0 2
 482: IFFALSE 507
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 484: LD_ADDR_VAR 0 4
 488: PUSH
 489: LD_EXP 3
 493: PUSH
 494: LD_VAR 0 1
 498: STR
 499: PPUSH
 500: CALL_OW 34
 504: ST_TO_ADDR
 505: GO 522
// unit := NewCharacter ( ident ) ;
 507: LD_ADDR_VAR 0 4
 511: PUSH
 512: LD_VAR 0 1
 516: PPUSH
 517: CALL_OW 25
 521: ST_TO_ADDR
// result := unit ;
 522: LD_ADDR_VAR 0 3
 526: PUSH
 527: LD_VAR 0 4
 531: ST_TO_ADDR
// end ;
 532: LD_VAR 0 3
 536: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 537: LD_INT 0
 539: PPUSH
// uc_side := side ;
 540: LD_ADDR_OWVAR 20
 544: PUSH
 545: LD_VAR 0 1
 549: ST_TO_ADDR
// uc_nation := nation ;
 550: LD_ADDR_OWVAR 21
 554: PUSH
 555: LD_VAR 0 2
 559: ST_TO_ADDR
// vc_chassis := chassis ;
 560: LD_ADDR_OWVAR 37
 564: PUSH
 565: LD_VAR 0 3
 569: ST_TO_ADDR
// vc_engine := engine ;
 570: LD_ADDR_OWVAR 39
 574: PUSH
 575: LD_VAR 0 4
 579: ST_TO_ADDR
// vc_control := control ;
 580: LD_ADDR_OWVAR 38
 584: PUSH
 585: LD_VAR 0 5
 589: ST_TO_ADDR
// vc_weapon := weapon ;
 590: LD_ADDR_OWVAR 40
 594: PUSH
 595: LD_VAR 0 6
 599: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 600: LD_ADDR_OWVAR 41
 604: PUSH
 605: LD_VAR 0 7
 609: ST_TO_ADDR
// result := CreateVehicle ;
 610: LD_ADDR_VAR 0 8
 614: PUSH
 615: CALL_OW 45
 619: ST_TO_ADDR
// end ;
 620: LD_VAR 0 8
 624: RET
// export function SayX ( units , ident ) ; var i ; begin
 625: LD_INT 0
 627: PPUSH
 628: PPUSH
// result := false ;
 629: LD_ADDR_VAR 0 3
 633: PUSH
 634: LD_INT 0
 636: ST_TO_ADDR
// if not units then
 637: LD_VAR 0 1
 641: NOT
 642: IFFALSE 646
// exit ;
 644: GO 700
// for i in units do
 646: LD_ADDR_VAR 0 4
 650: PUSH
 651: LD_VAR 0 1
 655: PUSH
 656: FOR_IN
 657: IFFALSE 698
// if IsOk ( i ) then
 659: LD_VAR 0 4
 663: PPUSH
 664: CALL_OW 302
 668: IFFALSE 696
// begin Say ( i , ident ) ;
 670: LD_VAR 0 4
 674: PPUSH
 675: LD_VAR 0 2
 679: PPUSH
 680: CALL_OW 88
// result := i ;
 684: LD_ADDR_VAR 0 3
 688: PUSH
 689: LD_VAR 0 4
 693: ST_TO_ADDR
// break ;
 694: GO 698
// end ;
 696: GO 656
 698: POP
 699: POP
// end ;
 700: LD_VAR 0 3
 704: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 705: LD_INT 0
 707: PPUSH
 708: PPUSH
 709: PPUSH
 710: PPUSH
// for i = 1 to count do
 711: LD_ADDR_VAR 0 8
 715: PUSH
 716: DOUBLE
 717: LD_INT 1
 719: DEC
 720: ST_TO_ADDR
 721: LD_VAR 0 6
 725: PUSH
 726: FOR_TO
 727: IFFALSE 808
// begin uc_side = side ;
 729: LD_ADDR_OWVAR 20
 733: PUSH
 734: LD_VAR 0 1
 738: ST_TO_ADDR
// uc_nation = nation ;
 739: LD_ADDR_OWVAR 21
 743: PUSH
 744: LD_VAR 0 2
 748: ST_TO_ADDR
// hc_gallery =  ;
 749: LD_ADDR_OWVAR 33
 753: PUSH
 754: LD_STRING 
 756: ST_TO_ADDR
// hc_name =  ;
 757: LD_ADDR_OWVAR 26
 761: PUSH
 762: LD_STRING 
 764: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 765: LD_INT 0
 767: PPUSH
 768: LD_VAR 0 5
 772: PPUSH
 773: LD_VAR 0 4
 777: PPUSH
 778: CALL_OW 380
// un = CreateHuman ;
 782: LD_ADDR_VAR 0 10
 786: PUSH
 787: CALL_OW 44
 791: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 792: LD_VAR 0 10
 796: PPUSH
 797: LD_VAR 0 3
 801: PPUSH
 802: CALL_OW 52
// end ;
 806: GO 726
 808: POP
 809: POP
// end ;
 810: LD_VAR 0 7
 814: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// uc_side := GetSide ( b ) ;
 820: LD_ADDR_OWVAR 20
 824: PUSH
 825: LD_VAR 0 2
 829: PPUSH
 830: CALL_OW 255
 834: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_VAR 0 2
 844: PPUSH
 845: CALL_OW 248
 849: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 850: LD_INT 0
 852: PPUSH
 853: LD_INT 1
 855: PPUSH
 856: LD_VAR 0 1
 860: PPUSH
 861: CALL_OW 380
// un = CreateHuman ;
 865: LD_ADDR_VAR 0 4
 869: PUSH
 870: CALL_OW 44
 874: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 875: LD_ADDR_VAR 0 5
 879: PUSH
 880: LD_VAR 0 2
 884: PPUSH
 885: CALL_OW 254
 889: PUSH
 890: LD_INT 3
 892: MINUS
 893: ST_TO_ADDR
// if dir < 0 then
 894: LD_VAR 0 5
 898: PUSH
 899: LD_INT 0
 901: LESS
 902: IFFALSE 918
// dir := 6 + dir ;
 904: LD_ADDR_VAR 0 5
 908: PUSH
 909: LD_INT 6
 911: PUSH
 912: LD_VAR 0 5
 916: PLUS
 917: ST_TO_ADDR
// SetDir ( un , dir ) ;
 918: LD_VAR 0 4
 922: PPUSH
 923: LD_VAR 0 5
 927: PPUSH
 928: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 932: LD_VAR 0 4
 936: PPUSH
 937: LD_VAR 0 2
 941: PPUSH
 942: CALL_OW 52
// end ;
 946: LD_VAR 0 3
 950: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 951: LD_INT 0
 953: PPUSH
 954: PPUSH
 955: PPUSH
// result := false ;
 956: LD_ADDR_VAR 0 2
 960: PUSH
 961: LD_INT 0
 963: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 964: LD_ADDR_VAR 0 3
 968: PUSH
 969: LD_INT 22
 971: PUSH
 972: LD_INT 1
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 34
 981: PUSH
 982: LD_INT 2
 984: PUSH
 985: EMPTY
 986: LIST
 987: LIST
 988: PUSH
 989: EMPTY
 990: LIST
 991: LIST
 992: PPUSH
 993: CALL_OW 69
 997: ST_TO_ADDR
// for i in filter do
 998: LD_ADDR_VAR 0 4
1002: PUSH
1003: LD_VAR 0 3
1007: PUSH
1008: FOR_IN
1009: IFFALSE 1040
// if IsDrivenBy ( i ) = unit then
1011: LD_VAR 0 4
1015: PPUSH
1016: CALL_OW 311
1020: PUSH
1021: LD_VAR 0 1
1025: EQUAL
1026: IFFALSE 1038
// begin result := true ;
1028: LD_ADDR_VAR 0 2
1032: PUSH
1033: LD_INT 1
1035: ST_TO_ADDR
// break ;
1036: GO 1040
// end ;
1038: GO 1008
1040: POP
1041: POP
// end ;
1042: LD_VAR 0 2
1046: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1047: LD_INT 0
1049: PPUSH
1050: PPUSH
// result := false ;
1051: LD_ADDR_VAR 0 2
1055: PUSH
1056: LD_INT 0
1058: ST_TO_ADDR
// if not blist then
1059: LD_VAR 0 1
1063: NOT
1064: IFFALSE 1068
// exit ;
1066: GO 1112
// for i in blist do
1068: LD_ADDR_VAR 0 3
1072: PUSH
1073: LD_VAR 0 1
1077: PUSH
1078: FOR_IN
1079: IFFALSE 1110
// if UnitsInside ( i ) < 6 then
1081: LD_VAR 0 3
1085: PPUSH
1086: CALL_OW 313
1090: PUSH
1091: LD_INT 6
1093: LESS
1094: IFFALSE 1108
// begin result := i ;
1096: LD_ADDR_VAR 0 2
1100: PUSH
1101: LD_VAR 0 3
1105: ST_TO_ADDR
// break ;
1106: GO 1110
// end ;
1108: GO 1078
1110: POP
1111: POP
// end ;
1112: LD_VAR 0 2
1116: RET
// export function Count ( timer , mode ) ; begin
1117: LD_INT 0
1119: PPUSH
// if not timer then
1120: LD_VAR 0 1
1124: NOT
1125: IFFALSE 1129
// exit ;
1127: GO 1180
// if mode in [ asc , up , + ] then
1129: LD_VAR 0 2
1133: PUSH
1134: LD_STRING asc
1136: PUSH
1137: LD_STRING up
1139: PUSH
1140: LD_STRING +
1142: PUSH
1143: EMPTY
1144: LIST
1145: LIST
1146: LIST
1147: IN
1148: IFFALSE 1166
// result := timer + 0 0$01 else
1150: LD_ADDR_VAR 0 3
1154: PUSH
1155: LD_VAR 0 1
1159: PUSH
1160: LD_INT 35
1162: PLUS
1163: ST_TO_ADDR
1164: GO 1180
// result := timer - 0 0$01 ;
1166: LD_ADDR_VAR 0 3
1170: PUSH
1171: LD_VAR 0 1
1175: PUSH
1176: LD_INT 35
1178: MINUS
1179: ST_TO_ADDR
// end ; end_of_file
1180: LD_VAR 0 3
1184: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1185: LD_INT 0
1187: PPUSH
1188: PPUSH
1189: PPUSH
1190: PPUSH
1191: PPUSH
1192: PPUSH
1193: PPUSH
1194: PPUSH
// uc_side := 4 ;
1195: LD_ADDR_OWVAR 20
1199: PUSH
1200: LD_INT 4
1202: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1203: LD_ADDR_EXP 45
1207: PUSH
1208: LD_STRING Powell
1210: PPUSH
1211: LD_INT 0
1213: PPUSH
1214: CALL 474 0 2
1218: ST_TO_ADDR
// uc_side := 1 ;
1219: LD_ADDR_OWVAR 20
1223: PUSH
1224: LD_INT 1
1226: ST_TO_ADDR
// uc_nation := 1 ;
1227: LD_ADDR_OWVAR 21
1231: PUSH
1232: LD_INT 1
1234: ST_TO_ADDR
// if debug then
1235: LD_EXP 1
1239: IFFALSE 1369
// begin for i = 1 to 4 do
1241: LD_ADDR_VAR 0 2
1245: PUSH
1246: DOUBLE
1247: LD_INT 1
1249: DEC
1250: ST_TO_ADDR
1251: LD_INT 4
1253: PUSH
1254: FOR_TO
1255: IFFALSE 1306
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1257: LD_INT 0
1259: PPUSH
1260: LD_INT 1
1262: PPUSH
1263: LD_INT 2
1265: PPUSH
1266: CALL_OW 12
1270: PPUSH
1271: LD_INT 3
1273: PPUSH
1274: CALL_OW 380
// un := CreateHuman ;
1278: LD_ADDR_VAR 0 3
1282: PUSH
1283: CALL_OW 44
1287: ST_TO_ADDR
// others := others ^ un ;
1288: LD_ADDR_VAR 0 5
1292: PUSH
1293: LD_VAR 0 5
1297: PUSH
1298: LD_VAR 0 3
1302: ADD
1303: ST_TO_ADDR
// end ;
1304: GO 1254
1306: POP
1307: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1308: LD_ADDR_VAR 0 6
1312: PUSH
1313: LD_INT 21
1315: PUSH
1316: LD_INT 1
1318: PUSH
1319: LD_INT 1
1321: PUSH
1322: LD_INT 51
1324: PUSH
1325: LD_INT 90
1327: PUSH
1328: LD_INT 504
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: LIST
1335: LIST
1336: LIST
1337: LIST
1338: PUSH
1339: LD_INT 21
1341: PUSH
1342: LD_INT 1
1344: PUSH
1345: LD_INT 1
1347: PUSH
1348: LD_INT 51
1350: PUSH
1351: LD_INT 80
1353: PUSH
1354: LD_INT 750
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: LIST
1361: LIST
1362: LIST
1363: LIST
1364: PUSH
1365: EMPTY
1366: LIST
1367: LIST
1368: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1369: LD_ADDR_EXP 36
1373: PUSH
1374: LD_STRING JMM
1376: PPUSH
1377: LD_EXP 1
1381: NOT
1382: PPUSH
1383: CALL 474 0 2
1387: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1388: LD_ADDR_EXP 37
1392: PUSH
1393: LD_STRING Bobby
1395: PPUSH
1396: LD_EXP 1
1400: NOT
1401: PPUSH
1402: CALL 474 0 2
1406: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1407: LD_ADDR_EXP 38
1411: PUSH
1412: LD_STRING Cyrus
1414: PPUSH
1415: LD_EXP 1
1419: NOT
1420: PPUSH
1421: CALL 474 0 2
1425: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1426: LD_ADDR_EXP 39
1430: PUSH
1431: LD_STRING Lisa
1433: PPUSH
1434: LD_EXP 1
1438: NOT
1439: PPUSH
1440: CALL 474 0 2
1444: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1445: LD_ADDR_EXP 40
1449: PUSH
1450: LD_STRING Khatam
1452: PPUSH
1453: LD_EXP 1
1457: NOT
1458: PPUSH
1459: CALL 474 0 2
1463: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1464: LD_ADDR_EXP 41
1468: PUSH
1469: LD_STRING Brian
1471: PPUSH
1472: LD_EXP 1
1476: NOT
1477: PPUSH
1478: CALL 474 0 2
1482: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1483: LD_ADDR_EXP 42
1487: PUSH
1488: LD_STRING Jerry
1490: PPUSH
1491: LD_EXP 1
1495: NOT
1496: PPUSH
1497: CALL 474 0 2
1501: ST_TO_ADDR
// if Bobby then
1502: LD_EXP 37
1506: IFFALSE 1537
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1508: LD_ADDR_VAR 0 4
1512: PUSH
1513: LD_VAR 0 4
1517: PPUSH
1518: LD_VAR 0 4
1522: PUSH
1523: LD_INT 1
1525: PLUS
1526: PPUSH
1527: LD_EXP 37
1531: PPUSH
1532: CALL_OW 2
1536: ST_TO_ADDR
// if Cyrus then
1537: LD_EXP 38
1541: IFFALSE 1572
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1543: LD_ADDR_VAR 0 4
1547: PUSH
1548: LD_VAR 0 4
1552: PPUSH
1553: LD_VAR 0 4
1557: PUSH
1558: LD_INT 1
1560: PLUS
1561: PPUSH
1562: LD_EXP 38
1566: PPUSH
1567: CALL_OW 2
1571: ST_TO_ADDR
// if Lisa then
1572: LD_EXP 39
1576: IFFALSE 1607
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1578: LD_ADDR_VAR 0 4
1582: PUSH
1583: LD_VAR 0 4
1587: PPUSH
1588: LD_VAR 0 4
1592: PUSH
1593: LD_INT 1
1595: PLUS
1596: PPUSH
1597: LD_EXP 39
1601: PPUSH
1602: CALL_OW 2
1606: ST_TO_ADDR
// if Khatam then
1607: LD_EXP 40
1611: IFFALSE 1642
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1613: LD_ADDR_VAR 0 4
1617: PUSH
1618: LD_VAR 0 4
1622: PPUSH
1623: LD_VAR 0 4
1627: PUSH
1628: LD_INT 1
1630: PLUS
1631: PPUSH
1632: LD_EXP 40
1636: PPUSH
1637: CALL_OW 2
1641: ST_TO_ADDR
// if Brian then
1642: LD_EXP 41
1646: IFFALSE 1677
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1648: LD_ADDR_VAR 0 4
1652: PUSH
1653: LD_VAR 0 4
1657: PPUSH
1658: LD_VAR 0 4
1662: PUSH
1663: LD_INT 1
1665: PLUS
1666: PPUSH
1667: LD_EXP 41
1671: PPUSH
1672: CALL_OW 2
1676: ST_TO_ADDR
// if Jerry then
1677: LD_EXP 42
1681: IFFALSE 1712
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1683: LD_ADDR_VAR 0 4
1687: PUSH
1688: LD_VAR 0 4
1692: PPUSH
1693: LD_VAR 0 4
1697: PUSH
1698: LD_INT 1
1700: PLUS
1701: PPUSH
1702: LD_EXP 42
1706: PPUSH
1707: CALL_OW 2
1711: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1712: LD_STRING 02_other_survivors
1714: PPUSH
1715: CALL_OW 28
1719: IFFALSE 1734
// others := CreateCharacterSet ( 02_other_survivors ) ;
1721: LD_ADDR_VAR 0 5
1725: PUSH
1726: LD_STRING 02_other_survivors
1728: PPUSH
1729: CALL_OW 31
1733: ST_TO_ADDR
// if others then
1734: LD_VAR 0 5
1738: IFFALSE 1763
// begin tmp := tmp ^ others ;
1740: LD_ADDR_VAR 0 4
1744: PUSH
1745: LD_VAR 0 4
1749: PUSH
1750: LD_VAR 0 5
1754: ADD
1755: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1756: LD_STRING 02_other_survivors
1758: PPUSH
1759: CALL_OW 40
// end ; jmm_units := tmp ;
1763: LD_ADDR_EXP 4
1767: PUSH
1768: LD_VAR 0 4
1772: ST_TO_ADDR
// if not vehicles then
1773: LD_VAR 0 6
1777: NOT
1778: IFFALSE 1796
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1780: LD_ADDR_VAR 0 6
1784: PUSH
1785: LD_STRING 02_tanks_1
1787: PPUSH
1788: LD_INT 0
1790: PPUSH
1791: CALL_OW 30
1795: ST_TO_ADDR
// if vehicles then
1796: LD_VAR 0 6
1800: IFFALSE 1994
// begin got_mech := false ;
1802: LD_ADDR_VAR 0 7
1806: PUSH
1807: LD_INT 0
1809: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1810: LD_VAR 0 4
1814: PPUSH
1815: LD_INT 25
1817: PUSH
1818: LD_INT 3
1820: PUSH
1821: EMPTY
1822: LIST
1823: LIST
1824: PPUSH
1825: CALL_OW 72
1829: IFFALSE 1839
// got_mech := true ;
1831: LD_ADDR_VAR 0 7
1835: PUSH
1836: LD_INT 1
1838: ST_TO_ADDR
// for i = 1 to vehicles do
1839: LD_ADDR_VAR 0 2
1843: PUSH
1844: DOUBLE
1845: LD_INT 1
1847: DEC
1848: ST_TO_ADDR
1849: LD_VAR 0 6
1853: PUSH
1854: FOR_TO
1855: IFFALSE 1992
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1857: LD_ADDR_VAR 0 3
1861: PUSH
1862: LD_INT 1
1864: PPUSH
1865: LD_INT 3
1867: PPUSH
1868: LD_VAR 0 6
1872: PUSH
1873: LD_VAR 0 2
1877: ARRAY
1878: PUSH
1879: LD_INT 1
1881: ARRAY
1882: PPUSH
1883: LD_VAR 0 6
1887: PUSH
1888: LD_VAR 0 2
1892: ARRAY
1893: PUSH
1894: LD_INT 2
1896: ARRAY
1897: PPUSH
1898: LD_VAR 0 6
1902: PUSH
1903: LD_VAR 0 2
1907: ARRAY
1908: PUSH
1909: LD_INT 3
1911: ARRAY
1912: PPUSH
1913: LD_VAR 0 6
1917: PUSH
1918: LD_VAR 0 2
1922: ARRAY
1923: PUSH
1924: LD_INT 4
1926: ARRAY
1927: PPUSH
1928: LD_INT 40
1930: PPUSH
1931: CALL 537 0 7
1935: ST_TO_ADDR
// if not got_mech then
1936: LD_VAR 0 7
1940: NOT
1941: IFFALSE 1967
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1943: LD_VAR 0 3
1947: PPUSH
1948: LD_VAR 0 6
1952: PUSH
1953: LD_VAR 0 2
1957: ARRAY
1958: PUSH
1959: LD_INT 6
1961: ARRAY
1962: PPUSH
1963: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1967: LD_ADDR_VAR 0 4
1971: PUSH
1972: LD_VAR 0 4
1976: PPUSH
1977: LD_INT 1
1979: PPUSH
1980: LD_VAR 0 3
1984: PPUSH
1985: CALL_OW 2
1989: ST_TO_ADDR
// end ;
1990: GO 1854
1992: POP
1993: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1994: LD_EXP 36
1998: PPUSH
1999: LD_INT 194
2001: PPUSH
2002: LD_INT 119
2004: PPUSH
2005: LD_INT 0
2007: PPUSH
2008: CALL_OW 48
// if tmp then
2012: LD_VAR 0 4
2016: IFFALSE 2141
// begin for i in tmp do
2018: LD_ADDR_VAR 0 2
2022: PUSH
2023: LD_VAR 0 4
2027: PUSH
2028: FOR_IN
2029: IFFALSE 2139
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2031: LD_ADDR_VAR 0 8
2035: PUSH
2036: LD_INT 22
2038: PUSH
2039: LD_INT 1
2041: PUSH
2042: EMPTY
2043: LIST
2044: LIST
2045: PUSH
2046: LD_INT 21
2048: PUSH
2049: LD_INT 2
2051: PUSH
2052: EMPTY
2053: LIST
2054: LIST
2055: PUSH
2056: LD_INT 58
2058: PUSH
2059: EMPTY
2060: LIST
2061: PUSH
2062: EMPTY
2063: LIST
2064: LIST
2065: LIST
2066: PPUSH
2067: CALL_OW 69
2071: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2072: LD_VAR 0 2
2076: PPUSH
2077: CALL_OW 247
2081: PUSH
2082: LD_INT 1
2084: EQUAL
2085: PUSH
2086: LD_VAR 0 8
2090: AND
2091: IFFALSE 2113
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2093: LD_VAR 0 2
2097: PPUSH
2098: LD_VAR 0 8
2102: PUSH
2103: LD_INT 1
2105: ARRAY
2106: PPUSH
2107: CALL_OW 52
2111: GO 2128
// PlaceUnitArea ( i , startArea , false ) ;
2113: LD_VAR 0 2
2117: PPUSH
2118: LD_INT 1
2120: PPUSH
2121: LD_INT 0
2123: PPUSH
2124: CALL_OW 49
// ComHold ( i ) ;
2128: LD_VAR 0 2
2132: PPUSH
2133: CALL_OW 140
// end ;
2137: GO 2028
2139: POP
2140: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2141: LD_ADDR_EXP 7
2145: PUSH
2146: LD_STRING 02_mikhailStatus_1
2148: PPUSH
2149: LD_INT 0
2151: PPUSH
2152: CALL_OW 30
2156: ST_TO_ADDR
// if not bierezov_exist and not debug then
2157: LD_EXP 7
2161: NOT
2162: PUSH
2163: LD_EXP 1
2167: NOT
2168: AND
2169: IFFALSE 2173
// exit ;
2171: GO 2204
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2173: LD_ADDR_EXP 44
2177: PUSH
2178: LD_STRING Mikhail
2180: PPUSH
2181: LD_INT 0
2183: PPUSH
2184: CALL 474 0 2
2188: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2189: LD_EXP 44
2193: PPUSH
2194: LD_INT 1
2196: PPUSH
2197: LD_INT 0
2199: PPUSH
2200: CALL_OW 49
// end ;
2204: LD_VAR 0 1
2208: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2209: LD_INT 0
2211: PPUSH
2212: PPUSH
2213: PPUSH
2214: PPUSH
// uc_side := 4 ;
2215: LD_ADDR_OWVAR 20
2219: PUSH
2220: LD_INT 4
2222: ST_TO_ADDR
// uc_nation := 1 ;
2223: LD_ADDR_OWVAR 21
2227: PUSH
2228: LD_INT 1
2230: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2231: LD_ADDR_EXP 43
2235: PUSH
2236: LD_STRING Cornell
2238: PPUSH
2239: LD_INT 0
2241: PPUSH
2242: CALL 474 0 2
2246: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2247: LD_ADDR_EXP 6
2251: PUSH
2252: LD_INT 9
2254: PUSH
2255: LD_EXP 4
2259: MINUS
2260: ST_TO_ADDR
// tmp := [ ] ;
2261: LD_ADDR_VAR 0 2
2265: PUSH
2266: EMPTY
2267: ST_TO_ADDR
// if cornel_units < 4 then
2268: LD_EXP 6
2272: PUSH
2273: LD_INT 4
2275: LESS
2276: IFFALSE 2286
// cornel_units := 4 ;
2278: LD_ADDR_EXP 6
2282: PUSH
2283: LD_INT 4
2285: ST_TO_ADDR
// for i = 1 to cornel_units do
2286: LD_ADDR_VAR 0 4
2290: PUSH
2291: DOUBLE
2292: LD_INT 1
2294: DEC
2295: ST_TO_ADDR
2296: LD_EXP 6
2300: PUSH
2301: FOR_TO
2302: IFFALSE 2400
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2304: LD_INT 0
2306: PPUSH
2307: LD_INT 1
2309: PUSH
2310: LD_INT 1
2312: PUSH
2313: LD_INT 1
2315: PUSH
2316: LD_INT 2
2318: PUSH
2319: LD_INT 4
2321: PUSH
2322: EMPTY
2323: LIST
2324: LIST
2325: LIST
2326: LIST
2327: LIST
2328: PUSH
2329: LD_VAR 0 4
2333: PUSH
2334: LD_INT 5
2336: MOD
2337: PUSH
2338: LD_INT 1
2340: PLUS
2341: ARRAY
2342: PPUSH
2343: LD_INT 2
2345: PPUSH
2346: CALL_OW 380
// un := CreateHuman ;
2350: LD_ADDR_VAR 0 3
2354: PUSH
2355: CALL_OW 44
2359: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2360: LD_ADDR_VAR 0 2
2364: PUSH
2365: LD_VAR 0 2
2369: PPUSH
2370: LD_INT 1
2372: PPUSH
2373: LD_VAR 0 3
2377: PPUSH
2378: CALL_OW 2
2382: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2383: LD_VAR 0 3
2387: PPUSH
2388: LD_INT 2
2390: PPUSH
2391: LD_INT 0
2393: PPUSH
2394: CALL_OW 49
// end ;
2398: GO 2301
2400: POP
2401: POP
// cornel_units := tmp ;
2402: LD_ADDR_EXP 6
2406: PUSH
2407: LD_VAR 0 2
2411: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2412: LD_EXP 43
2416: PPUSH
2417: LD_INT 191
2419: PPUSH
2420: LD_INT 106
2422: PPUSH
2423: LD_INT 0
2425: PPUSH
2426: CALL_OW 48
// end ;
2430: LD_VAR 0 1
2434: RET
// export function PrepareWesternBase ; var i ; begin
2435: LD_INT 0
2437: PPUSH
2438: PPUSH
// uc_side := 8 ;
2439: LD_ADDR_OWVAR 20
2443: PUSH
2444: LD_INT 8
2446: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2447: LD_ADDR_EXP 46
2451: PUSH
2452: LD_STRING Lynch
2454: PPUSH
2455: LD_INT 0
2457: PPUSH
2458: CALL 474 0 2
2462: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2463: LD_ADDR_EXP 47
2467: PUSH
2468: LD_STRING Walker
2470: PPUSH
2471: LD_INT 0
2473: PPUSH
2474: CALL 474 0 2
2478: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2479: LD_ADDR_EXP 48
2483: PUSH
2484: LD_STRING Turner
2486: PPUSH
2487: LD_INT 0
2489: PPUSH
2490: CALL 474 0 2
2494: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2495: LD_ADDR_EXP 49
2499: PUSH
2500: LD_STRING Jillian
2502: PPUSH
2503: LD_INT 0
2505: PPUSH
2506: CALL 474 0 2
2510: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_EXP 46
2520: PUSH
2521: LD_EXP 47
2525: PUSH
2526: LD_EXP 48
2530: PUSH
2531: LD_EXP 49
2535: PUSH
2536: EMPTY
2537: LIST
2538: LIST
2539: LIST
2540: LIST
2541: PUSH
2542: FOR_IN
2543: IFFALSE 2571
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2545: LD_VAR 0 2
2549: PPUSH
2550: LD_INT 3
2552: PPUSH
2553: LD_INT 0
2555: PPUSH
2556: CALL_OW 49
// ComHold ( i ) ;
2560: LD_VAR 0 2
2564: PPUSH
2565: CALL_OW 140
// end ;
2569: GO 2542
2571: POP
2572: POP
// end ;
2573: LD_VAR 0 1
2577: RET
// export function SelectGroup ; var units , selected , i ; begin
2578: LD_INT 0
2580: PPUSH
2581: PPUSH
2582: PPUSH
2583: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2584: LD_ADDR_VAR 0 2
2588: PUSH
2589: LD_EXP 36
2593: PUSH
2594: LD_INT -3
2596: PUSH
2597: EMPTY
2598: LIST
2599: LIST
2600: PUSH
2601: LD_EXP 4
2605: ADD
2606: PUSH
2607: LD_INT -2
2609: PUSH
2610: LD_INT -4
2612: PUSH
2613: LD_EXP 43
2617: PUSH
2618: LD_EXP 44
2622: PUSH
2623: EMPTY
2624: LIST
2625: LIST
2626: LIST
2627: LIST
2628: ADD
2629: PUSH
2630: LD_INT -3
2632: PUSH
2633: EMPTY
2634: LIST
2635: ADD
2636: PUSH
2637: LD_EXP 6
2641: ADD
2642: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2643: LD_ADDR_VAR 0 3
2647: PUSH
2648: LD_EXP 36
2652: PUSH
2653: LD_STRING Select five characters to go with you
2655: PPUSH
2656: LD_INT 4
2658: PPUSH
2659: LD_INT 4
2661: PPUSH
2662: LD_VAR 0 2
2666: PPUSH
2667: EMPTY
2668: PPUSH
2669: CALL_OW 42
2673: ADD
2674: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2675: LD_ADDR_EXP 6
2679: PUSH
2680: LD_EXP 4
2684: PUSH
2685: LD_EXP 6
2689: UNION
2690: PUSH
2691: LD_VAR 0 3
2695: DIFF
2696: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2697: LD_ADDR_VAR 0 4
2701: PUSH
2702: LD_EXP 6
2706: PUSH
2707: LD_EXP 44
2711: ADD
2712: PUSH
2713: FOR_IN
2714: IFFALSE 2745
// if GetSide ( i ) = 1 then
2716: LD_VAR 0 4
2720: PPUSH
2721: CALL_OW 255
2725: PUSH
2726: LD_INT 1
2728: EQUAL
2729: IFFALSE 2743
// SetSide ( i , 4 ) ;
2731: LD_VAR 0 4
2735: PPUSH
2736: LD_INT 4
2738: PPUSH
2739: CALL_OW 235
2743: GO 2713
2745: POP
2746: POP
// for i in selected do
2747: LD_ADDR_VAR 0 4
2751: PUSH
2752: LD_VAR 0 3
2756: PUSH
2757: FOR_IN
2758: IFFALSE 2789
// if GetSide ( i ) = 4 then
2760: LD_VAR 0 4
2764: PPUSH
2765: CALL_OW 255
2769: PUSH
2770: LD_INT 4
2772: EQUAL
2773: IFFALSE 2787
// SetSide ( i , 1 ) ;
2775: LD_VAR 0 4
2779: PPUSH
2780: LD_INT 1
2782: PPUSH
2783: CALL_OW 235
2787: GO 2757
2789: POP
2790: POP
// jmm_units := jmm_units diff cornel_units ;
2791: LD_ADDR_EXP 4
2795: PUSH
2796: LD_EXP 4
2800: PUSH
2801: LD_EXP 6
2805: DIFF
2806: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2807: LD_EXP 37
2811: PPUSH
2812: CALL_OW 255
2816: PUSH
2817: LD_INT 4
2819: EQUAL
2820: IFFALSE 2835
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2822: LD_EXP 3
2826: PUSH
2827: LD_STRING Bobby
2829: STR
2830: PPUSH
2831: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2835: LD_EXP 38
2839: PPUSH
2840: CALL_OW 255
2844: PUSH
2845: LD_INT 4
2847: EQUAL
2848: IFFALSE 2863
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2850: LD_EXP 3
2854: PUSH
2855: LD_STRING Cyrus
2857: STR
2858: PPUSH
2859: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2863: LD_EXP 39
2867: PPUSH
2868: CALL_OW 255
2872: PUSH
2873: LD_INT 4
2875: EQUAL
2876: IFFALSE 2891
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2878: LD_EXP 3
2882: PUSH
2883: LD_STRING Lisa
2885: STR
2886: PPUSH
2887: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2891: LD_EXP 40
2895: PPUSH
2896: CALL_OW 255
2900: PUSH
2901: LD_INT 4
2903: EQUAL
2904: IFFALSE 2919
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
2906: LD_EXP 3
2910: PUSH
2911: LD_STRING Khatam
2913: STR
2914: PPUSH
2915: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2919: LD_EXP 41
2923: PPUSH
2924: CALL_OW 255
2928: PUSH
2929: LD_INT 4
2931: EQUAL
2932: IFFALSE 2947
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
2934: LD_EXP 3
2938: PUSH
2939: LD_STRING Brian
2941: STR
2942: PPUSH
2943: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2947: LD_EXP 42
2951: PPUSH
2952: CALL_OW 255
2956: PUSH
2957: LD_INT 4
2959: EQUAL
2960: IFFALSE 2975
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
2962: LD_EXP 3
2966: PUSH
2967: LD_STRING Jerry
2969: STR
2970: PPUSH
2971: CALL_OW 40
// end ; end_of_file
2975: LD_VAR 0 1
2979: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
2980: LD_INT 0
2982: PPUSH
2983: PPUSH
2984: PPUSH
2985: PPUSH
2986: PPUSH
2987: PPUSH
2988: PPUSH
2989: PPUSH
2990: PPUSH
2991: PPUSH
2992: PPUSH
2993: PPUSH
2994: PPUSH
// ru_alert := false ;
2995: LD_ADDR_EXP 59
2999: PUSH
3000: LD_INT 0
3002: ST_TO_ADDR
// ru_produce_list := [ ] ;
3003: LD_ADDR_EXP 56
3007: PUSH
3008: EMPTY
3009: ST_TO_ADDR
// if Difficulty > 1 then
3010: LD_OWVAR 67
3014: PUSH
3015: LD_INT 1
3017: GREATER
3018: IFFALSE 3106
// begin uc_side := 3 ;
3020: LD_ADDR_OWVAR 20
3024: PUSH
3025: LD_INT 3
3027: ST_TO_ADDR
// uc_nation := 3 ;
3028: LD_ADDR_OWVAR 21
3032: PUSH
3033: LD_INT 3
3035: ST_TO_ADDR
// bc_type := b_breastwork ;
3036: LD_ADDR_OWVAR 42
3040: PUSH
3041: LD_INT 31
3043: ST_TO_ADDR
// bc_level := Difficulty ;
3044: LD_ADDR_OWVAR 43
3048: PUSH
3049: LD_OWVAR 67
3053: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3054: LD_INT 22
3056: PPUSH
3057: LD_INT 14
3059: PPUSH
3060: LD_INT 0
3062: PPUSH
3063: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3067: LD_INT 48
3069: PPUSH
3070: LD_INT 46
3072: PPUSH
3073: LD_INT 0
3075: PPUSH
3076: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3080: LD_INT 86
3082: PPUSH
3083: LD_INT 65
3085: PPUSH
3086: LD_INT 5
3088: PPUSH
3089: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3093: LD_INT 165
3095: PPUSH
3096: LD_INT 73
3098: PPUSH
3099: LD_INT 5
3101: PPUSH
3102: CALL_OW 47
// end ; if Difficulty = 3 then
3106: LD_OWVAR 67
3110: PUSH
3111: LD_INT 3
3113: EQUAL
3114: IFFALSE 3129
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3116: LD_INT 51
3118: PPUSH
3119: LD_INT 3
3121: PPUSH
3122: LD_INT 2
3124: PPUSH
3125: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3129: LD_ADDR_VAR 0 7
3133: PUSH
3134: LD_INT 22
3136: PUSH
3137: LD_INT 3
3139: PUSH
3140: EMPTY
3141: LIST
3142: LIST
3143: PUSH
3144: LD_INT 2
3146: PUSH
3147: LD_INT 30
3149: PUSH
3150: LD_INT 31
3152: PUSH
3153: EMPTY
3154: LIST
3155: LIST
3156: PUSH
3157: LD_INT 30
3159: PUSH
3160: LD_INT 32
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: PUSH
3167: EMPTY
3168: LIST
3169: LIST
3170: LIST
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: PPUSH
3176: CALL_OW 69
3180: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3181: LD_ADDR_VAR 0 8
3185: PUSH
3186: LD_INT 22
3188: PUSH
3189: LD_INT 3
3191: PUSH
3192: EMPTY
3193: LIST
3194: LIST
3195: PUSH
3196: LD_INT 30
3198: PUSH
3199: LD_INT 4
3201: PUSH
3202: EMPTY
3203: LIST
3204: LIST
3205: PUSH
3206: EMPTY
3207: LIST
3208: LIST
3209: PPUSH
3210: CALL_OW 69
3214: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3215: LD_ADDR_VAR 0 10
3219: PUSH
3220: LD_INT 22
3222: PUSH
3223: LD_INT 3
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: PUSH
3230: LD_INT 30
3232: PUSH
3233: LD_INT 3
3235: PUSH
3236: EMPTY
3237: LIST
3238: LIST
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: PPUSH
3244: CALL_OW 69
3248: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3249: LD_ADDR_VAR 0 9
3253: PUSH
3254: LD_INT 22
3256: PUSH
3257: LD_INT 3
3259: PUSH
3260: EMPTY
3261: LIST
3262: LIST
3263: PUSH
3264: LD_INT 30
3266: PUSH
3267: LD_INT 6
3269: PUSH
3270: EMPTY
3271: LIST
3272: LIST
3273: PUSH
3274: EMPTY
3275: LIST
3276: LIST
3277: PPUSH
3278: CALL_OW 69
3282: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3283: LD_ADDR_VAR 0 2
3287: PUSH
3288: LD_INT 22
3290: PUSH
3291: LD_INT 3
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: PUSH
3298: LD_INT 30
3300: PUSH
3301: LD_INT 1
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: PUSH
3308: EMPTY
3309: LIST
3310: LIST
3311: PPUSH
3312: CALL_OW 69
3316: PUSH
3317: FOR_IN
3318: IFFALSE 3362
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3320: LD_VAR 0 2
3324: PPUSH
3325: CALL_OW 274
3329: PPUSH
3330: LD_INT 1
3332: PPUSH
3333: LD_INT 5000
3335: PPUSH
3336: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3340: LD_VAR 0 2
3344: PPUSH
3345: CALL_OW 274
3349: PPUSH
3350: LD_INT 2
3352: PPUSH
3353: LD_INT 3000
3355: PPUSH
3356: CALL_OW 277
// end ;
3360: GO 3317
3362: POP
3363: POP
// uc_side := 3 ;
3364: LD_ADDR_OWVAR 20
3368: PUSH
3369: LD_INT 3
3371: ST_TO_ADDR
// uc_nation := 3 ;
3372: LD_ADDR_OWVAR 21
3376: PUSH
3377: LD_INT 3
3379: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3380: LD_ADDR_VAR 0 11
3384: PUSH
3385: LD_INT 2
3387: PUSH
3388: LD_INT 3
3390: PUSH
3391: LD_INT 4
3393: PUSH
3394: EMPTY
3395: LIST
3396: LIST
3397: LIST
3398: PUSH
3399: LD_OWVAR 67
3403: ARRAY
3404: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3405: LD_ADDR_EXP 51
3409: PUSH
3410: LD_STRING Pokryshkin
3412: PPUSH
3413: LD_INT 0
3415: PPUSH
3416: CALL 474 0 2
3420: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3421: LD_EXP 51
3425: PPUSH
3426: LD_INT 63
3428: PPUSH
3429: LD_INT 21
3431: PPUSH
3432: LD_INT 0
3434: PPUSH
3435: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3439: LD_EXP 51
3443: PPUSH
3444: CALL_OW 140
// InitHc ;
3448: CALL_OW 19
// for i in fac do
3452: LD_ADDR_VAR 0 2
3456: PUSH
3457: LD_VAR 0 10
3461: PUSH
3462: FOR_IN
3463: IFFALSE 3516
// begin for j = 1 to 6 do
3465: LD_ADDR_VAR 0 3
3469: PUSH
3470: DOUBLE
3471: LD_INT 1
3473: DEC
3474: ST_TO_ADDR
3475: LD_INT 6
3477: PUSH
3478: FOR_TO
3479: IFFALSE 3512
// begin PrepareHuman ( false , 3 , skill ) ;
3481: LD_INT 0
3483: PPUSH
3484: LD_INT 3
3486: PPUSH
3487: LD_VAR 0 11
3491: PPUSH
3492: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3496: CALL_OW 44
3500: PPUSH
3501: LD_VAR 0 2
3505: PPUSH
3506: CALL_OW 52
// end ;
3510: GO 3478
3512: POP
3513: POP
// end ;
3514: GO 3462
3516: POP
3517: POP
// for i in lab do
3518: LD_ADDR_VAR 0 2
3522: PUSH
3523: LD_VAR 0 9
3527: PUSH
3528: FOR_IN
3529: IFFALSE 3562
// begin PrepareHuman ( false , 4 , skill ) ;
3531: LD_INT 0
3533: PPUSH
3534: LD_INT 4
3536: PPUSH
3537: LD_VAR 0 11
3541: PPUSH
3542: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3546: CALL_OW 44
3550: PPUSH
3551: LD_VAR 0 2
3555: PPUSH
3556: CALL_OW 52
// end ;
3560: GO 3528
3562: POP
3563: POP
// for i in tw do
3564: LD_ADDR_VAR 0 2
3568: PUSH
3569: LD_VAR 0 7
3573: PUSH
3574: FOR_IN
3575: IFFALSE 3624
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3577: LD_VAR 0 2
3581: PPUSH
3582: LD_INT 42
3584: PUSH
3585: LD_INT 43
3587: PUSH
3588: EMPTY
3589: LIST
3590: LIST
3591: PUSH
3592: LD_INT 1
3594: PPUSH
3595: LD_INT 2
3597: PPUSH
3598: CALL_OW 12
3602: ARRAY
3603: PPUSH
3604: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3608: LD_VAR 0 11
3612: PPUSH
3613: LD_VAR 0 2
3617: PPUSH
3618: CALL 815 0 2
// end ;
3622: GO 3574
3624: POP
3625: POP
// for i in bar do
3626: LD_ADDR_VAR 0 2
3630: PUSH
3631: LD_VAR 0 8
3635: PUSH
3636: FOR_IN
3637: IFFALSE 3670
// begin PrepareHuman ( false , 1 , skill ) ;
3639: LD_INT 0
3641: PPUSH
3642: LD_INT 1
3644: PPUSH
3645: LD_VAR 0 11
3649: PPUSH
3650: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3654: CALL_OW 44
3658: PPUSH
3659: LD_VAR 0 2
3663: PPUSH
3664: CALL_OW 52
// end ;
3668: GO 3636
3670: POP
3671: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3672: LD_ADDR_VAR 0 13
3676: PUSH
3677: LD_INT 100
3679: PUSH
3680: LD_INT 9
3682: PUSH
3683: EMPTY
3684: LIST
3685: LIST
3686: PUSH
3687: LD_INT 135
3689: PUSH
3690: LD_INT 60
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: PUSH
3697: LD_INT 41
3699: PUSH
3700: LD_INT 6
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: PUSH
3707: LD_INT 22
3709: PUSH
3710: LD_INT 9
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: PUSH
3717: LD_INT 84
3719: PUSH
3720: LD_INT 14
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: LIST
3731: LIST
3732: LIST
3733: ST_TO_ADDR
// vehicles := [ ] ;
3734: LD_ADDR_VAR 0 12
3738: PUSH
3739: EMPTY
3740: ST_TO_ADDR
// for i in spot_xy do
3741: LD_ADDR_VAR 0 2
3745: PUSH
3746: LD_VAR 0 13
3750: PUSH
3751: FOR_IN
3752: IFFALSE 3910
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3754: LD_ADDR_VAR 0 6
3758: PUSH
3759: LD_INT 3
3761: PPUSH
3762: LD_INT 3
3764: PPUSH
3765: LD_INT 22
3767: PPUSH
3768: LD_INT 1
3770: PPUSH
3771: LD_INT 1
3773: PPUSH
3774: LD_INT 42
3776: PUSH
3777: LD_INT 43
3779: PUSH
3780: LD_INT 44
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: LIST
3787: PUSH
3788: LD_INT 1
3790: PPUSH
3791: LD_INT 3
3793: PPUSH
3794: CALL_OW 12
3798: ARRAY
3799: PPUSH
3800: LD_INT 100
3802: PPUSH
3803: CALL 537 0 7
3807: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3808: LD_ADDR_VAR 0 12
3812: PUSH
3813: LD_VAR 0 12
3817: PPUSH
3818: LD_VAR 0 12
3822: PUSH
3823: LD_INT 1
3825: PLUS
3826: PPUSH
3827: LD_VAR 0 6
3831: PPUSH
3832: CALL_OW 2
3836: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3837: LD_VAR 0 6
3841: PPUSH
3842: LD_INT 3
3844: PPUSH
3845: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3849: LD_VAR 0 6
3853: PPUSH
3854: LD_VAR 0 2
3858: PUSH
3859: LD_INT 1
3861: ARRAY
3862: PPUSH
3863: LD_VAR 0 2
3867: PUSH
3868: LD_INT 2
3870: ARRAY
3871: PPUSH
3872: LD_INT 0
3874: PPUSH
3875: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3879: LD_INT 0
3881: PPUSH
3882: LD_INT 3
3884: PPUSH
3885: LD_VAR 0 11
3889: PPUSH
3890: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3894: CALL_OW 44
3898: PPUSH
3899: LD_VAR 0 6
3903: PPUSH
3904: CALL_OW 52
// end ;
3908: GO 3751
3910: POP
3911: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3912: LD_ADDR_VAR 0 2
3916: PUSH
3917: DOUBLE
3918: LD_INT 1
3920: DEC
3921: ST_TO_ADDR
3922: LD_INT 5
3924: PUSH
3925: LD_INT 7
3927: PUSH
3928: LD_INT 8
3930: PUSH
3931: EMPTY
3932: LIST
3933: LIST
3934: LIST
3935: PUSH
3936: LD_OWVAR 67
3940: ARRAY
3941: PUSH
3942: FOR_TO
3943: IFFALSE 4003
// begin PrepareHuman ( false , 1 , skill ) ;
3945: LD_INT 0
3947: PPUSH
3948: LD_INT 1
3950: PPUSH
3951: LD_VAR 0 11
3955: PPUSH
3956: CALL_OW 380
// un := CreateHuman ;
3960: LD_ADDR_VAR 0 5
3964: PUSH
3965: CALL_OW 44
3969: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3970: LD_VAR 0 5
3974: PPUSH
3975: LD_INT 11
3977: PPUSH
3978: LD_INT 0
3980: PPUSH
3981: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3985: LD_ADDR_EXP 54
3989: PUSH
3990: LD_EXP 54
3994: PUSH
3995: LD_VAR 0 5
3999: ADD
4000: ST_TO_ADDR
// end ;
4001: GO 3942
4003: POP
4004: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
4005: LD_ADDR_VAR 0 2
4009: PUSH
4010: DOUBLE
4011: LD_INT 1
4013: DEC
4014: ST_TO_ADDR
4015: LD_INT 2
4017: PUSH
4018: LD_INT 3
4020: PUSH
4021: LD_INT 4
4023: PUSH
4024: EMPTY
4025: LIST
4026: LIST
4027: LIST
4028: PUSH
4029: LD_OWVAR 67
4033: ARRAY
4034: PUSH
4035: FOR_TO
4036: IFFALSE 4096
// begin PrepareHuman ( false , 1 , skill ) ;
4038: LD_INT 0
4040: PPUSH
4041: LD_INT 1
4043: PPUSH
4044: LD_VAR 0 11
4048: PPUSH
4049: CALL_OW 380
// un := CreateHuman ;
4053: LD_ADDR_VAR 0 5
4057: PUSH
4058: CALL_OW 44
4062: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4063: LD_VAR 0 5
4067: PPUSH
4068: LD_INT 12
4070: PPUSH
4071: LD_INT 0
4073: PPUSH
4074: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4078: LD_ADDR_EXP 52
4082: PUSH
4083: LD_EXP 52
4087: PUSH
4088: LD_VAR 0 5
4092: ADD
4093: ST_TO_ADDR
// end ;
4094: GO 4035
4096: POP
4097: POP
// for i = 1 to 2 do
4098: LD_ADDR_VAR 0 2
4102: PUSH
4103: DOUBLE
4104: LD_INT 1
4106: DEC
4107: ST_TO_ADDR
4108: LD_INT 2
4110: PUSH
4111: FOR_TO
4112: IFFALSE 4178
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4114: LD_INT 1
4116: PPUSH
4117: LD_INT 1
4119: PPUSH
4120: LD_VAR 0 11
4124: PPUSH
4125: CALL_OW 380
// un := CreateHuman ;
4129: LD_ADDR_VAR 0 5
4133: PUSH
4134: CALL_OW 44
4138: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4139: LD_VAR 0 5
4143: PPUSH
4144: LD_INT 39
4146: PPUSH
4147: LD_INT 12
4149: PPUSH
4150: LD_INT 3
4152: PPUSH
4153: LD_INT 0
4155: PPUSH
4156: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4160: LD_ADDR_EXP 53
4164: PUSH
4165: LD_EXP 53
4169: PUSH
4170: LD_VAR 0 5
4174: ADD
4175: ST_TO_ADDR
// end ;
4176: GO 4111
4178: POP
4179: POP
// for i = 1 to 3 do
4180: LD_ADDR_VAR 0 2
4184: PUSH
4185: DOUBLE
4186: LD_INT 1
4188: DEC
4189: ST_TO_ADDR
4190: LD_INT 3
4192: PUSH
4193: FOR_TO
4194: IFFALSE 4260
// begin PrepareHuman ( false , 1 , skill ) ;
4196: LD_INT 0
4198: PPUSH
4199: LD_INT 1
4201: PPUSH
4202: LD_VAR 0 11
4206: PPUSH
4207: CALL_OW 380
// un := CreateHuman ;
4211: LD_ADDR_VAR 0 5
4215: PUSH
4216: CALL_OW 44
4220: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4221: LD_VAR 0 5
4225: PPUSH
4226: LD_INT 180
4228: PPUSH
4229: LD_INT 11
4231: PPUSH
4232: LD_INT 4
4234: PPUSH
4235: LD_INT 0
4237: PPUSH
4238: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4242: LD_ADDR_EXP 57
4246: PUSH
4247: LD_EXP 57
4251: PUSH
4252: LD_VAR 0 5
4256: ADD
4257: ST_TO_ADDR
// end ;
4258: GO 4193
4260: POP
4261: POP
// ru_vehicles := vehicles ;
4262: LD_ADDR_EXP 55
4266: PUSH
4267: LD_VAR 0 12
4271: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4272: LD_ADDR_EXP 58
4276: PUSH
4277: LD_INT 131
4279: PUSH
4280: LD_INT 121
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PUSH
4287: LD_INT 113
4289: PUSH
4290: LD_INT 90
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: PUSH
4297: LD_INT 93
4299: PUSH
4300: LD_INT 62
4302: PUSH
4303: EMPTY
4304: LIST
4305: LIST
4306: PUSH
4307: EMPTY
4308: LIST
4309: LIST
4310: LIST
4311: PUSH
4312: LD_INT 106
4314: PUSH
4315: LD_INT 54
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: PUSH
4322: LD_INT 120
4324: PUSH
4325: LD_INT 80
4327: PUSH
4328: EMPTY
4329: LIST
4330: LIST
4331: PUSH
4332: LD_INT 143
4334: PUSH
4335: LD_INT 120
4337: PUSH
4338: EMPTY
4339: LIST
4340: LIST
4341: PUSH
4342: EMPTY
4343: LIST
4344: LIST
4345: LIST
4346: PUSH
4347: LD_INT 154
4349: PUSH
4350: LD_INT 116
4352: PUSH
4353: EMPTY
4354: LIST
4355: LIST
4356: PUSH
4357: LD_INT 140
4359: PUSH
4360: LD_INT 93
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: PUSH
4367: LD_INT 130
4369: PUSH
4370: LD_INT 58
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: LIST
4381: PUSH
4382: LD_INT 105
4384: PUSH
4385: LD_INT 106
4387: PUSH
4388: EMPTY
4389: LIST
4390: LIST
4391: PUSH
4392: LD_INT 134
4394: PUSH
4395: LD_INT 98
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: LD_INT 159
4404: PUSH
4405: LD_INT 113
4407: PUSH
4408: EMPTY
4409: LIST
4410: LIST
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: LIST
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4423: LD_ADDR_VAR 0 2
4427: PUSH
4428: DOUBLE
4429: LD_INT 1
4431: DEC
4432: ST_TO_ADDR
4433: LD_OWVAR 67
4437: PUSH
4438: LD_INT 1
4440: MINUS
4441: PUSH
4442: FOR_TO
4443: IFFALSE 4476
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4445: LD_ADDR_EXP 56
4449: PUSH
4450: LD_EXP 56
4454: PUSH
4455: LD_INT 22
4457: PUSH
4458: LD_INT 1
4460: PUSH
4461: LD_INT 1
4463: PUSH
4464: LD_INT 43
4466: PUSH
4467: EMPTY
4468: LIST
4469: LIST
4470: LIST
4471: LIST
4472: ADD
4473: ST_TO_ADDR
4474: GO 4442
4476: POP
4477: POP
// end ;
4478: LD_VAR 0 1
4482: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4483: LD_INT 22
4485: PUSH
4486: LD_INT 3
4488: PUSH
4489: EMPTY
4490: LIST
4491: LIST
4492: PUSH
4493: LD_INT 21
4495: PUSH
4496: LD_INT 2
4498: PUSH
4499: EMPTY
4500: LIST
4501: LIST
4502: PUSH
4503: EMPTY
4504: LIST
4505: LIST
4506: PPUSH
4507: CALL_OW 69
4511: IFFALSE 4605
4513: GO 4515
4515: DISABLE
4516: LD_INT 0
4518: PPUSH
4519: PPUSH
// begin enable ;
4520: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4521: LD_ADDR_VAR 0 2
4525: PUSH
4526: LD_INT 22
4528: PUSH
4529: LD_INT 3
4531: PUSH
4532: EMPTY
4533: LIST
4534: LIST
4535: PUSH
4536: LD_INT 21
4538: PUSH
4539: LD_INT 2
4541: PUSH
4542: EMPTY
4543: LIST
4544: LIST
4545: PUSH
4546: EMPTY
4547: LIST
4548: LIST
4549: PPUSH
4550: CALL_OW 69
4554: ST_TO_ADDR
// if filter then
4555: LD_VAR 0 2
4559: IFFALSE 4605
// for i in filter do
4561: LD_ADDR_VAR 0 1
4565: PUSH
4566: LD_VAR 0 2
4570: PUSH
4571: FOR_IN
4572: IFFALSE 4603
// if GetFuel ( i ) < 20 then
4574: LD_VAR 0 1
4578: PPUSH
4579: CALL_OW 261
4583: PUSH
4584: LD_INT 20
4586: LESS
4587: IFFALSE 4601
// SetFuel ( i , 20 ) ;
4589: LD_VAR 0 1
4593: PPUSH
4594: LD_INT 20
4596: PPUSH
4597: CALL_OW 240
4601: GO 4571
4603: POP
4604: POP
// end ;
4605: PPOPN 2
4607: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4608: LD_EXP 56
4612: IFFALSE 4831
4614: GO 4616
4616: DISABLE
4617: LD_INT 0
4619: PPUSH
4620: PPUSH
4621: PPUSH
// begin enable ;
4622: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4623: LD_ADDR_VAR 0 2
4627: PUSH
4628: LD_INT 22
4630: PUSH
4631: LD_INT 3
4633: PUSH
4634: EMPTY
4635: LIST
4636: LIST
4637: PUSH
4638: LD_INT 30
4640: PUSH
4641: LD_INT 3
4643: PUSH
4644: EMPTY
4645: LIST
4646: LIST
4647: PUSH
4648: EMPTY
4649: LIST
4650: LIST
4651: PPUSH
4652: CALL_OW 69
4656: ST_TO_ADDR
// can_produce := [ ] ;
4657: LD_ADDR_VAR 0 3
4661: PUSH
4662: EMPTY
4663: ST_TO_ADDR
// if not fac then
4664: LD_VAR 0 2
4668: NOT
4669: IFFALSE 4674
// begin disable ;
4671: DISABLE
// exit ;
4672: GO 4831
// end ; for i in fac do
4674: LD_ADDR_VAR 0 1
4678: PUSH
4679: LD_VAR 0 2
4683: PUSH
4684: FOR_IN
4685: IFFALSE 4723
// if UnitsInside ( i ) then
4687: LD_VAR 0 1
4691: PPUSH
4692: CALL_OW 313
4696: IFFALSE 4721
// can_produce := Insert ( can_produce , 1 , i ) ;
4698: LD_ADDR_VAR 0 3
4702: PUSH
4703: LD_VAR 0 3
4707: PPUSH
4708: LD_INT 1
4710: PPUSH
4711: LD_VAR 0 1
4715: PPUSH
4716: CALL_OW 2
4720: ST_TO_ADDR
4721: GO 4684
4723: POP
4724: POP
// if not can_produce then
4725: LD_VAR 0 3
4729: NOT
4730: IFFALSE 4734
// exit ;
4732: GO 4831
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4734: LD_VAR 0 3
4738: PUSH
4739: LD_INT 1
4741: PPUSH
4742: LD_VAR 0 3
4746: PPUSH
4747: CALL_OW 12
4751: ARRAY
4752: PPUSH
4753: LD_EXP 56
4757: PUSH
4758: LD_INT 1
4760: ARRAY
4761: PPUSH
4762: LD_EXP 56
4766: PUSH
4767: LD_INT 2
4769: ARRAY
4770: PPUSH
4771: LD_EXP 56
4775: PUSH
4776: LD_INT 3
4778: ARRAY
4779: PPUSH
4780: LD_EXP 56
4784: PUSH
4785: LD_INT 4
4787: ARRAY
4788: PPUSH
4789: CALL_OW 125
// for i = 1 to 4 do
4793: LD_ADDR_VAR 0 1
4797: PUSH
4798: DOUBLE
4799: LD_INT 1
4801: DEC
4802: ST_TO_ADDR
4803: LD_INT 4
4805: PUSH
4806: FOR_TO
4807: IFFALSE 4829
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4809: LD_ADDR_EXP 56
4813: PUSH
4814: LD_EXP 56
4818: PPUSH
4819: LD_INT 1
4821: PPUSH
4822: CALL_OW 3
4826: ST_TO_ADDR
4827: GO 4806
4829: POP
4830: POP
// end ;
4831: PPOPN 3
4833: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4834: LD_INT 0
4836: PPUSH
4837: PPUSH
4838: PPUSH
// for i = 1 to 6 do
4839: LD_ADDR_VAR 0 2
4843: PUSH
4844: DOUBLE
4845: LD_INT 1
4847: DEC
4848: ST_TO_ADDR
4849: LD_INT 6
4851: PUSH
4852: FOR_TO
4853: IFFALSE 5002
// begin PrepareHuman ( false , 3 , 3 ) ;
4855: LD_INT 0
4857: PPUSH
4858: LD_INT 3
4860: PPUSH
4861: LD_INT 3
4863: PPUSH
4864: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4868: LD_ADDR_VAR 0 3
4872: PUSH
4873: LD_INT 3
4875: PPUSH
4876: LD_INT 3
4878: PPUSH
4879: LD_INT 22
4881: PPUSH
4882: LD_INT 1
4884: PPUSH
4885: LD_INT 1
4887: PPUSH
4888: LD_INT 43
4890: PUSH
4891: LD_INT 42
4893: PUSH
4894: EMPTY
4895: LIST
4896: LIST
4897: PUSH
4898: LD_INT 1
4900: PPUSH
4901: LD_INT 2
4903: PPUSH
4904: CALL_OW 12
4908: ARRAY
4909: PPUSH
4910: LD_INT 70
4912: PPUSH
4913: CALL 537 0 7
4917: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4918: LD_VAR 0 3
4922: PPUSH
4923: LD_INT 4
4925: PPUSH
4926: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4930: LD_VAR 0 3
4934: PPUSH
4935: LD_INT 229
4937: PPUSH
4938: LD_INT 44
4940: PPUSH
4941: LD_INT 0
4943: PPUSH
4944: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4948: CALL_OW 44
4952: PPUSH
4953: LD_VAR 0 3
4957: PPUSH
4958: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4962: LD_ADDR_EXP 55
4966: PUSH
4967: LD_EXP 55
4971: PUSH
4972: LD_VAR 0 3
4976: ADD
4977: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
4978: LD_VAR 0 3
4982: PPUSH
4983: LD_INT 191
4985: PPUSH
4986: LD_INT 32
4988: PPUSH
4989: CALL_OW 111
// Wait ( 0 0$02 ) ;
4993: LD_INT 70
4995: PPUSH
4996: CALL_OW 67
// end ;
5000: GO 4852
5002: POP
5003: POP
// end ;
5004: LD_VAR 0 1
5008: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
5009: LD_EXP 30
5013: PUSH
5014: LD_EXP 55
5018: AND
5019: IFFALSE 5193
5021: GO 5023
5023: DISABLE
5024: LD_INT 0
5026: PPUSH
5027: PPUSH
5028: PPUSH
// begin wait ( 0 0$50 ) ;
5029: LD_INT 1750
5031: PPUSH
5032: CALL_OW 67
// tmp := ru_vehicles ;
5036: LD_ADDR_VAR 0 3
5040: PUSH
5041: LD_EXP 55
5045: ST_TO_ADDR
// if not tmp then
5046: LD_VAR 0 3
5050: NOT
5051: IFFALSE 5055
// exit ;
5053: GO 5193
// repeat wait ( 0 0$1 ) ;
5055: LD_INT 35
5057: PPUSH
5058: CALL_OW 67
// for i in tmp do
5062: LD_ADDR_VAR 0 1
5066: PUSH
5067: LD_VAR 0 3
5071: PUSH
5072: FOR_IN
5073: IFFALSE 5184
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5075: LD_ADDR_VAR 0 2
5079: PUSH
5080: LD_INT 22
5082: PUSH
5083: LD_INT 1
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: PPUSH
5090: LD_VAR 0 1
5094: PPUSH
5095: CALL_OW 74
5099: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5100: LD_VAR 0 1
5104: PPUSH
5105: LD_VAR 0 2
5109: PPUSH
5110: CALL_OW 296
5114: PUSH
5115: LD_INT 10
5117: GREATER
5118: IFFALSE 5137
// ComAgressiveMove ( i , 69 , 101 ) else
5120: LD_VAR 0 1
5124: PPUSH
5125: LD_INT 69
5127: PPUSH
5128: LD_INT 101
5130: PPUSH
5131: CALL_OW 114
5135: GO 5151
// ComAttackUnit ( i , enemy ) ;
5137: LD_VAR 0 1
5141: PPUSH
5142: LD_VAR 0 2
5146: PPUSH
5147: CALL_OW 115
// if GetLives ( i ) < 250 then
5151: LD_VAR 0 1
5155: PPUSH
5156: CALL_OW 256
5160: PUSH
5161: LD_INT 250
5163: LESS
5164: IFFALSE 5182
// tmp := tmp diff i ;
5166: LD_ADDR_VAR 0 3
5170: PUSH
5171: LD_VAR 0 3
5175: PUSH
5176: LD_VAR 0 1
5180: DIFF
5181: ST_TO_ADDR
// end ;
5182: GO 5072
5184: POP
5185: POP
// until not tmp ;
5186: LD_VAR 0 3
5190: NOT
5191: IFFALSE 5055
// end ; end_of_file
5193: PPOPN 3
5195: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5196: LD_INT 0
5198: PPUSH
5199: PPUSH
5200: PPUSH
5201: PPUSH
5202: PPUSH
5203: PPUSH
5204: PPUSH
// InGameOn ;
5205: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5209: LD_EXP 36
5213: PPUSH
5214: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5218: LD_EXP 36
5222: PPUSH
5223: LD_EXP 43
5227: PPUSH
5228: CALL_OW 119
// if Bierezov then
5232: LD_EXP 44
5236: IFFALSE 5252
// ComTurnUnit ( Bierezov , Cornel ) ;
5238: LD_EXP 44
5242: PPUSH
5243: LD_EXP 43
5247: PPUSH
5248: CALL_OW 119
// for i in jmm_units do
5252: LD_ADDR_VAR 0 2
5256: PUSH
5257: LD_EXP 4
5261: PUSH
5262: FOR_IN
5263: IFFALSE 5281
// ComTurnUnit ( i , Cornel ) ;
5265: LD_VAR 0 2
5269: PPUSH
5270: LD_EXP 43
5274: PPUSH
5275: CALL_OW 119
5279: GO 5262
5281: POP
5282: POP
// units := cornel_units union Cornel ;
5283: LD_ADDR_VAR 0 3
5287: PUSH
5288: LD_EXP 6
5292: PUSH
5293: LD_EXP 43
5297: UNION
5298: ST_TO_ADDR
// repeat wait ( 1 ) ;
5299: LD_INT 1
5301: PPUSH
5302: CALL_OW 67
// for i in units do
5306: LD_ADDR_VAR 0 2
5310: PUSH
5311: LD_VAR 0 3
5315: PUSH
5316: FOR_IN
5317: IFFALSE 5350
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5319: LD_VAR 0 2
5323: PPUSH
5324: LD_EXP 36
5328: PPUSH
5329: CALL_OW 250
5333: PPUSH
5334: LD_EXP 36
5338: PPUSH
5339: CALL_OW 251
5343: PPUSH
5344: CALL_OW 111
5348: GO 5316
5350: POP
5351: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5352: LD_VAR 0 3
5356: PPUSH
5357: LD_INT 92
5359: PUSH
5360: LD_EXP 36
5364: PPUSH
5365: CALL_OW 250
5369: PUSH
5370: LD_EXP 36
5374: PPUSH
5375: CALL_OW 251
5379: PUSH
5380: LD_INT 10
5382: PUSH
5383: EMPTY
5384: LIST
5385: LIST
5386: LIST
5387: LIST
5388: PPUSH
5389: CALL_OW 72
5393: PUSH
5394: LD_VAR 0 3
5398: EQUAL
5399: IFFALSE 5299
// for i in units do
5401: LD_ADDR_VAR 0 2
5405: PUSH
5406: LD_VAR 0 3
5410: PUSH
5411: FOR_IN
5412: IFFALSE 5430
// ComTurnUnit ( i , JMM ) ;
5414: LD_VAR 0 2
5418: PPUSH
5419: LD_EXP 36
5423: PPUSH
5424: CALL_OW 119
5428: GO 5411
5430: POP
5431: POP
// ComTurnUnit ( Cornel , JMM ) ;
5432: LD_EXP 43
5436: PPUSH
5437: LD_EXP 36
5441: PPUSH
5442: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5446: LD_EXP 36
5450: PPUSH
5451: LD_STRING D1-JMM-1
5453: PPUSH
5454: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5458: LD_EXP 43
5462: PPUSH
5463: LD_STRING D1-Corn-1
5465: PPUSH
5466: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5470: LD_EXP 36
5474: PPUSH
5475: LD_EXP 43
5479: PPUSH
5480: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5484: LD_EXP 43
5488: PPUSH
5489: LD_EXP 36
5493: PPUSH
5494: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5498: LD_INT 35
5500: PPUSH
5501: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5505: LD_EXP 36
5509: PPUSH
5510: LD_EXP 43
5514: PPUSH
5515: CALL_OW 296
5519: PUSH
5520: LD_INT 6
5522: LESS
5523: IFFALSE 5498
// ChangeSideFog ( 4 , 1 ) ;
5525: LD_INT 4
5527: PPUSH
5528: LD_INT 1
5530: PPUSH
5531: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5535: LD_EXP 36
5539: PPUSH
5540: LD_EXP 43
5544: PPUSH
5545: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5549: LD_EXP 43
5553: PPUSH
5554: LD_EXP 36
5558: PPUSH
5559: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5563: LD_EXP 36
5567: PPUSH
5568: LD_STRING D1-JMM-2
5570: PPUSH
5571: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5575: LD_EXP 36
5579: PPUSH
5580: LD_STRING D1-JMM-2a
5582: PPUSH
5583: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5587: LD_EXP 43
5591: PPUSH
5592: LD_STRING D1-Corn-2
5594: PPUSH
5595: CALL_OW 88
// if bierezov_exist or debug then
5599: LD_EXP 7
5603: PUSH
5604: LD_EXP 1
5608: OR
5609: IFFALSE 5850
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5611: LD_EXP 43
5615: PPUSH
5616: LD_EXP 44
5620: PPUSH
5621: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5625: LD_INT 10
5627: PPUSH
5628: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5632: LD_EXP 43
5636: PPUSH
5637: LD_STRING D1a-Corn-1
5639: PPUSH
5640: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5644: LD_EXP 36
5648: PPUSH
5649: LD_EXP 44
5653: PPUSH
5654: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5658: LD_EXP 44
5662: PPUSH
5663: LD_EXP 36
5667: PPUSH
5668: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5672: LD_EXP 36
5676: PPUSH
5677: LD_STRING D1a-JMM-1
5679: PPUSH
5680: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5684: LD_EXP 36
5688: PPUSH
5689: LD_EXP 43
5693: PPUSH
5694: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5698: LD_EXP 43
5702: PPUSH
5703: LD_EXP 36
5707: PPUSH
5708: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5712: LD_EXP 43
5716: PPUSH
5717: LD_STRING D1a-Corn-2
5719: PPUSH
5720: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5724: LD_EXP 36
5728: PPUSH
5729: LD_STRING D1a-JMM-2
5731: PPUSH
5732: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5736: LD_EXP 43
5740: PPUSH
5741: LD_STRING D1a-Corn-3
5743: PPUSH
5744: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5748: LD_EXP 36
5752: PPUSH
5753: LD_STRING D1a-JMM-3
5755: PPUSH
5756: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5760: LD_EXP 43
5764: PPUSH
5765: LD_STRING D1a-Corn-4
5767: PPUSH
5768: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5772: LD_EXP 36
5776: PPUSH
5777: LD_STRING D1a-JMM-4
5779: PPUSH
5780: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5784: LD_EXP 43
5788: PPUSH
5789: LD_STRING D1a-Corn-5
5791: PPUSH
5792: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5796: LD_EXP 44
5800: PPUSH
5801: LD_EXP 43
5805: PPUSH
5806: CALL_OW 250
5810: PPUSH
5811: LD_EXP 43
5815: PPUSH
5816: CALL_OW 251
5820: PUSH
5821: LD_INT 2
5823: MINUS
5824: PPUSH
5825: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5829: LD_EXP 44
5833: PPUSH
5834: LD_EXP 43
5838: PPUSH
5839: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5843: LD_INT 10
5845: PPUSH
5846: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5850: LD_EXP 36
5854: PPUSH
5855: LD_STRING D1b-JMM-1
5857: PPUSH
5858: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5862: LD_EXP 43
5866: PPUSH
5867: LD_STRING D1b-Corn-1
5869: PPUSH
5870: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5874: LD_EXP 36
5878: PPUSH
5879: LD_STRING D1b-JMM-2
5881: PPUSH
5882: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5886: LD_EXP 43
5890: PPUSH
5891: LD_STRING D1b-Corn-2
5893: PPUSH
5894: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5898: LD_EXP 36
5902: PPUSH
5903: LD_STRING D1b-JMM-3
5905: PPUSH
5906: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5910: LD_INT 10
5912: PPUSH
5913: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5917: LD_EXP 45
5921: PPUSH
5922: LD_STRING D1b-Pow-3
5924: PPUSH
5925: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5929: LD_EXP 36
5933: PPUSH
5934: LD_STRING D1b-JMM-4
5936: PPUSH
5937: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5941: LD_EXP 43
5945: PPUSH
5946: LD_STRING D1b-Corn-4
5948: PPUSH
5949: CALL_OW 88
// if Khatam then
5953: LD_EXP 40
5957: IFFALSE 5973
// Say ( Khatam , D1b-Khat-4 ) else
5959: LD_EXP 40
5963: PPUSH
5964: LD_STRING D1b-Khat-4
5966: PPUSH
5967: CALL_OW 88
5971: GO 6009
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
5973: LD_EXP 6
5977: PPUSH
5978: LD_INT 26
5980: PUSH
5981: LD_INT 1
5983: PUSH
5984: EMPTY
5985: LIST
5986: LIST
5987: PPUSH
5988: CALL_OW 72
5992: PUSH
5993: LD_EXP 43
5997: PUSH
5998: EMPTY
5999: LIST
6000: DIFF
6001: PPUSH
6002: LD_STRING D1b-Sol1-4
6004: PPUSH
6005: CALL 625 0 2
// if Cyrus then
6009: LD_EXP 38
6013: IFFALSE 6027
// Say ( Cyrus , D1b-Cyrus-4 ) ;
6015: LD_EXP 38
6019: PPUSH
6020: LD_STRING D1b-Cyrus-4
6022: PPUSH
6023: CALL_OW 88
// if Lisa then
6027: LD_EXP 39
6031: IFFALSE 6089
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6033: LD_EXP 39
6037: PPUSH
6038: LD_STRING D1b-Lisa-4
6040: PPUSH
6041: CALL_OW 88
// if Cyrus then
6045: LD_EXP 38
6049: IFFALSE 6089
// begin if not IsInUnit ( Cyrus ) then
6051: LD_EXP 38
6055: PPUSH
6056: CALL_OW 310
6060: NOT
6061: IFFALSE 6077
// ComTurnUnit ( Cyrus , Lisa ) ;
6063: LD_EXP 38
6067: PPUSH
6068: LD_EXP 39
6072: PPUSH
6073: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6077: LD_EXP 38
6081: PPUSH
6082: LD_STRING D1b-Cyrus-5
6084: PPUSH
6085: CALL_OW 88
// end ; end ; SelectGroup ;
6089: CALL 2578 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6093: LD_EXP 36
6097: PPUSH
6098: LD_STRING D1d-JMM-1
6100: PPUSH
6101: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6105: LD_EXP 43
6109: PPUSH
6110: LD_STRING D1d-Corn-1
6112: PPUSH
6113: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6117: LD_ADDR_VAR 0 2
6121: PUSH
6122: LD_EXP 4
6126: PUSH
6127: LD_EXP 6
6131: ADD
6132: PUSH
6133: LD_EXP 36
6137: ADD
6138: PUSH
6139: FOR_IN
6140: IFFALSE 6153
// ComHold ( i ) ;
6142: LD_VAR 0 2
6146: PPUSH
6147: CALL_OW 140
6151: GO 6139
6153: POP
6154: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6155: LD_ADDR_VAR 0 4
6159: PUSH
6160: LD_INT 22
6162: PUSH
6163: LD_INT 1
6165: PUSH
6166: EMPTY
6167: LIST
6168: LIST
6169: PUSH
6170: LD_INT 21
6172: PUSH
6173: LD_INT 2
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: PUSH
6180: EMPTY
6181: LIST
6182: LIST
6183: PPUSH
6184: CALL_OW 69
6188: ST_TO_ADDR
// if vehicles then
6189: LD_VAR 0 4
6193: IFFALSE 6531
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6195: LD_EXP 6
6199: PPUSH
6200: LD_INT 55
6202: PUSH
6203: EMPTY
6204: LIST
6205: PPUSH
6206: CALL_OW 72
6210: IFFALSE 6249
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6212: LD_ADDR_VAR 0 2
6216: PUSH
6217: LD_EXP 6
6221: PPUSH
6222: LD_INT 55
6224: PUSH
6225: EMPTY
6226: LIST
6227: PPUSH
6228: CALL_OW 72
6232: PUSH
6233: FOR_IN
6234: IFFALSE 6247
// ComExitVehicle ( i ) ;
6236: LD_VAR 0 2
6240: PPUSH
6241: CALL_OW 121
6245: GO 6233
6247: POP
6248: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6249: LD_ADDR_VAR 0 5
6253: PUSH
6254: LD_VAR 0 4
6258: PPUSH
6259: LD_INT 34
6261: PUSH
6262: LD_INT 51
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: PPUSH
6269: CALL_OW 72
6273: ST_TO_ADDR
// if cargos then
6274: LD_VAR 0 5
6278: IFFALSE 6461
// begin vehicles := cargos ;
6280: LD_ADDR_VAR 0 4
6284: PUSH
6285: LD_VAR 0 5
6289: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6290: LD_ADDR_VAR 0 6
6294: PUSH
6295: LD_STRING 02_resources_4
6297: PPUSH
6298: LD_INT 0
6300: PPUSH
6301: CALL_OW 30
6305: ST_TO_ADDR
// if debug and not resources then
6306: LD_EXP 1
6310: PUSH
6311: LD_VAR 0 6
6315: NOT
6316: AND
6317: IFFALSE 6327
// resources := 160 ;
6319: LD_ADDR_VAR 0 6
6323: PUSH
6324: LD_INT 160
6326: ST_TO_ADDR
// if resources mod 10 then
6327: LD_VAR 0 6
6331: PUSH
6332: LD_INT 10
6334: MOD
6335: IFFALSE 6357
// resources := resources - resources mod 10 ;
6337: LD_ADDR_VAR 0 6
6341: PUSH
6342: LD_VAR 0 6
6346: PUSH
6347: LD_VAR 0 6
6351: PUSH
6352: LD_INT 10
6354: MOD
6355: MINUS
6356: ST_TO_ADDR
// if resources then
6357: LD_VAR 0 6
6361: IFFALSE 6461
// for i in cargos do
6363: LD_ADDR_VAR 0 2
6367: PUSH
6368: LD_VAR 0 5
6372: PUSH
6373: FOR_IN
6374: IFFALSE 6459
// begin if resources < 100 then
6376: LD_VAR 0 6
6380: PUSH
6381: LD_INT 100
6383: LESS
6384: IFFALSE 6406
// begin cargo := resources ;
6386: LD_ADDR_VAR 0 7
6390: PUSH
6391: LD_VAR 0 6
6395: ST_TO_ADDR
// resources := 0 ;
6396: LD_ADDR_VAR 0 6
6400: PUSH
6401: LD_INT 0
6403: ST_TO_ADDR
// end else
6404: GO 6428
// begin cargo := 100 ;
6406: LD_ADDR_VAR 0 7
6410: PUSH
6411: LD_INT 100
6413: ST_TO_ADDR
// resources := resources - 100 ;
6414: LD_ADDR_VAR 0 6
6418: PUSH
6419: LD_VAR 0 6
6423: PUSH
6424: LD_INT 100
6426: MINUS
6427: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6428: LD_VAR 0 2
6432: PPUSH
6433: LD_INT 1
6435: PPUSH
6436: LD_VAR 0 7
6440: PPUSH
6441: CALL_OW 290
// if resources = 0 then
6445: LD_VAR 0 6
6449: PUSH
6450: LD_INT 0
6452: EQUAL
6453: IFFALSE 6457
// break ;
6455: GO 6459
// end ;
6457: GO 6373
6459: POP
6460: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6461: LD_VAR 0 4
6465: PUSH
6466: LD_INT 1
6468: ARRAY
6469: PPUSH
6470: CALL_OW 311
6474: PPUSH
6475: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6479: LD_VAR 0 4
6483: PUSH
6484: LD_INT 1
6486: ARRAY
6487: PPUSH
6488: LD_INT 4
6490: PPUSH
6491: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6495: LD_EXP 43
6499: PPUSH
6500: LD_VAR 0 4
6504: PUSH
6505: LD_INT 1
6507: ARRAY
6508: PPUSH
6509: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6513: LD_INT 35
6515: PPUSH
6516: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6520: LD_EXP 43
6524: PPUSH
6525: CALL_OW 310
6529: IFFALSE 6513
// end ; InGameOff ;
6531: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6535: LD_STRING M1
6537: PPUSH
6538: CALL_OW 337
// SaveForQuickRestart ;
6542: CALL_OW 22
// cornel_active := true ;
6546: LD_ADDR_EXP 8
6550: PUSH
6551: LD_INT 1
6553: ST_TO_ADDR
// end ;
6554: LD_VAR 0 1
6558: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns , tmp ;
6559: LD_EXP 36
6563: PPUSH
6564: LD_EXP 46
6568: PPUSH
6569: CALL_OW 296
6573: PUSH
6574: LD_INT 10
6576: LESS
6577: IFFALSE 7934
6579: GO 6581
6581: DISABLE
6582: LD_INT 0
6584: PPUSH
6585: PPUSH
6586: PPUSH
6587: PPUSH
6588: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6589: LD_ADDR_VAR 0 2
6593: PUSH
6594: LD_INT 89
6596: PUSH
6597: LD_INT 34
6599: PUSH
6600: EMPTY
6601: LIST
6602: LIST
6603: PUSH
6604: LD_INT 138
6606: PUSH
6607: LD_INT 63
6609: PUSH
6610: EMPTY
6611: LIST
6612: LIST
6613: PUSH
6614: LD_INT 196
6616: PUSH
6617: LD_INT 84
6619: PUSH
6620: EMPTY
6621: LIST
6622: LIST
6623: PUSH
6624: LD_INT 135
6626: PUSH
6627: LD_INT 52
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: PUSH
6634: LD_INT 103
6636: PUSH
6637: LD_INT 39
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: PUSH
6644: LD_INT 58
6646: PUSH
6647: LD_INT 30
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 38
6656: PUSH
6657: LD_INT 51
6659: PUSH
6660: EMPTY
6661: LIST
6662: LIST
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: LIST
6668: LIST
6669: LIST
6670: LIST
6671: LIST
6672: ST_TO_ADDR
// InGameOn ;
6673: CALL_OW 8
// if jmm_units then
6677: LD_EXP 4
6681: IFFALSE 6757
// for i in jmm_units do
6683: LD_ADDR_VAR 0 1
6687: PUSH
6688: LD_EXP 4
6692: PUSH
6693: FOR_IN
6694: IFFALSE 6755
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6696: LD_VAR 0 1
6700: PPUSH
6701: LD_EXP 36
6705: PPUSH
6706: CALL_OW 296
6710: PUSH
6711: LD_INT 10
6713: LESS
6714: PUSH
6715: LD_VAR 0 1
6719: PPUSH
6720: CALL_OW 310
6724: NOT
6725: AND
6726: IFFALSE 6744
// ComTurnUnit ( i , JMM ) else
6728: LD_VAR 0 1
6732: PPUSH
6733: LD_EXP 36
6737: PPUSH
6738: CALL_OW 119
6742: GO 6753
// ComHold ( i ) ;
6744: LD_VAR 0 1
6748: PPUSH
6749: CALL_OW 140
// end ;
6753: GO 6693
6755: POP
6756: POP
// if IsInUnit ( JMM ) then
6757: LD_EXP 36
6761: PPUSH
6762: CALL_OW 310
6766: IFFALSE 6791
// begin ComExitVehicle ( JMM ) ;
6768: LD_EXP 36
6772: PPUSH
6773: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6777: LD_EXP 36
6781: PPUSH
6782: LD_EXP 46
6786: PPUSH
6787: CALL_OW 172
// end ; Wait ( 10 ) ;
6791: LD_INT 10
6793: PPUSH
6794: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6798: LD_EXP 36
6802: PPUSH
6803: LD_EXP 46
6807: PPUSH
6808: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6812: LD_INT 35
6814: PPUSH
6815: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6819: LD_EXP 36
6823: PPUSH
6824: LD_EXP 46
6828: PPUSH
6829: CALL_OW 296
6833: PUSH
6834: LD_INT 6
6836: LESS
6837: IFFALSE 6812
// ComTurnUnit ( JMM , Lynch ) ;
6839: LD_EXP 36
6843: PPUSH
6844: LD_EXP 46
6848: PPUSH
6849: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6853: LD_ADDR_VAR 0 1
6857: PUSH
6858: LD_EXP 46
6862: PUSH
6863: LD_EXP 47
6867: PUSH
6868: LD_EXP 48
6872: PUSH
6873: LD_EXP 49
6877: PUSH
6878: EMPTY
6879: LIST
6880: LIST
6881: LIST
6882: LIST
6883: PUSH
6884: FOR_IN
6885: IFFALSE 6903
// ComTurnUnit ( i , JMM ) ;
6887: LD_VAR 0 1
6891: PPUSH
6892: LD_EXP 36
6896: PPUSH
6897: CALL_OW 119
6901: GO 6884
6903: POP
6904: POP
// Wait ( 0 0$0.3 ) ;
6905: LD_INT 10
6907: PPUSH
6908: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6912: LD_EXP 36
6916: PPUSH
6917: LD_STRING D2-JMM-1
6919: PPUSH
6920: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6924: LD_EXP 46
6928: PPUSH
6929: LD_STRING D2-Sol1-1
6931: PPUSH
6932: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6936: LD_EXP 36
6940: PPUSH
6941: LD_STRING D2-JMM-2
6943: PPUSH
6944: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6948: LD_EXP 46
6952: PPUSH
6953: LD_STRING D2-Sol1-2
6955: PPUSH
6956: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6960: LD_EXP 36
6964: PPUSH
6965: LD_STRING D2-JMM-3
6967: PPUSH
6968: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
6972: LD_EXP 46
6976: PPUSH
6977: LD_STRING D2-Sol1-3
6979: PPUSH
6980: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6984: LD_ADDR_VAR 0 1
6988: PUSH
6989: LD_INT 22
6991: PUSH
6992: LD_INT 8
6994: PUSH
6995: EMPTY
6996: LIST
6997: LIST
6998: PPUSH
6999: CALL_OW 69
7003: PUSH
7004: FOR_IN
7005: IFFALSE 7021
// SetSide ( i , 1 ) ;
7007: LD_VAR 0 1
7011: PPUSH
7012: LD_INT 1
7014: PPUSH
7015: CALL_OW 235
7019: GO 7004
7021: POP
7022: POP
// Say ( JMM , D2-JMM-4 ) ;
7023: LD_EXP 36
7027: PPUSH
7028: LD_STRING D2-JMM-4
7030: PPUSH
7031: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7035: LD_INT 1
7037: PPUSH
7038: LD_INT 5
7040: PPUSH
7041: CALL_OW 332
// for i = 1 to points do
7045: LD_ADDR_VAR 0 1
7049: PUSH
7050: DOUBLE
7051: LD_INT 1
7053: DEC
7054: ST_TO_ADDR
7055: LD_VAR 0 2
7059: PUSH
7060: FOR_TO
7061: IFFALSE 7236
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7063: LD_VAR 0 2
7067: PUSH
7068: LD_VAR 0 1
7072: ARRAY
7073: PUSH
7074: LD_INT 1
7076: ARRAY
7077: PPUSH
7078: LD_VAR 0 2
7082: PUSH
7083: LD_VAR 0 1
7087: ARRAY
7088: PUSH
7089: LD_INT 2
7091: ARRAY
7092: PPUSH
7093: CALL_OW 84
// if i = 1 then
7097: LD_VAR 0 1
7101: PUSH
7102: LD_INT 1
7104: EQUAL
7105: IFFALSE 7119
// Say ( Lynch , D2-Sol1-4 ) ;
7107: LD_EXP 46
7111: PPUSH
7112: LD_STRING D2-Sol1-4
7114: PPUSH
7115: CALL_OW 88
// if i = 2 then
7119: LD_VAR 0 1
7123: PUSH
7124: LD_INT 2
7126: EQUAL
7127: IFFALSE 7141
// Say ( JMM , D2-JMM-5 ) ;
7129: LD_EXP 36
7133: PPUSH
7134: LD_STRING D2-JMM-5
7136: PPUSH
7137: CALL_OW 88
// if i = 4 then
7141: LD_VAR 0 1
7145: PUSH
7146: LD_INT 4
7148: EQUAL
7149: IFFALSE 7173
// begin RevealFogArea ( 1 , troopsArea ) ;
7151: LD_INT 1
7153: PPUSH
7154: LD_INT 6
7156: PPUSH
7157: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7161: LD_EXP 46
7165: PPUSH
7166: LD_STRING D2-Sol1-5
7168: PPUSH
7169: CALL_OW 88
// end ; if i = 5 then
7173: LD_VAR 0 1
7177: PUSH
7178: LD_INT 5
7180: EQUAL
7181: IFFALSE 7195
// Say ( JMM , D2-JMM-6 ) ;
7183: LD_EXP 36
7187: PPUSH
7188: LD_STRING D2-JMM-6
7190: PPUSH
7191: CALL_OW 88
// if i = 7 then
7195: LD_VAR 0 1
7199: PUSH
7200: LD_INT 7
7202: EQUAL
7203: IFFALSE 7227
// begin RevealFogArea ( 1 , forestArea ) ;
7205: LD_INT 1
7207: PPUSH
7208: LD_INT 7
7210: PPUSH
7211: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7215: LD_EXP 46
7219: PPUSH
7220: LD_STRING D2-Sol1-6
7222: PPUSH
7223: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7227: LD_INT 46
7229: PPUSH
7230: CALL_OW 67
// end ;
7234: GO 7060
7236: POP
7237: POP
// CenterNowOnUnits ( JMM ) ;
7238: LD_EXP 36
7242: PPUSH
7243: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7247: LD_EXP 36
7251: PPUSH
7252: LD_STRING D2-JMM-7
7254: PPUSH
7255: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7259: LD_EXP 46
7263: PPUSH
7264: LD_STRING D2-Sol1-7
7266: PPUSH
7267: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7271: LD_EXP 36
7275: PPUSH
7276: LD_STRING D2-JMM-8
7278: PPUSH
7279: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7283: LD_ADDR_VAR 0 4
7287: PUSH
7288: LD_INT 22
7290: PUSH
7291: LD_INT 1
7293: PUSH
7294: EMPTY
7295: LIST
7296: LIST
7297: PUSH
7298: LD_INT 30
7300: PUSH
7301: LD_INT 31
7303: PUSH
7304: EMPTY
7305: LIST
7306: LIST
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: PPUSH
7312: CALL_OW 69
7316: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7317: LD_EXP 46
7321: PPUSH
7322: LD_VAR 0 4
7326: PUSH
7327: LD_INT 1
7329: ARRAY
7330: PPUSH
7331: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7335: LD_INT 65
7337: PPUSH
7338: LD_INT 101
7340: PPUSH
7341: CALL_OW 428
7345: IFFALSE 7368
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7347: LD_INT 65
7349: PPUSH
7350: LD_INT 101
7352: PPUSH
7353: CALL_OW 428
7357: PPUSH
7358: LD_INT 75
7360: PPUSH
7361: LD_INT 100
7363: PPUSH
7364: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7368: LD_INT 66
7370: PPUSH
7371: LD_INT 103
7373: PPUSH
7374: CALL_OW 428
7378: IFFALSE 7401
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7380: LD_INT 66
7382: PPUSH
7383: LD_INT 103
7385: PPUSH
7386: CALL_OW 428
7390: PPUSH
7391: LD_INT 75
7393: PPUSH
7394: LD_INT 100
7396: PPUSH
7397: CALL_OW 111
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_dist , JMM , 7 ] ] ) ;
7401: LD_ADDR_VAR 0 5
7405: PUSH
7406: LD_INT 22
7408: PUSH
7409: LD_INT 1
7411: PUSH
7412: EMPTY
7413: LIST
7414: LIST
7415: PUSH
7416: LD_INT 21
7418: PUSH
7419: LD_INT 2
7421: PUSH
7422: EMPTY
7423: LIST
7424: LIST
7425: PUSH
7426: LD_INT 91
7428: PUSH
7429: LD_EXP 36
7433: PUSH
7434: LD_INT 7
7436: PUSH
7437: EMPTY
7438: LIST
7439: LIST
7440: LIST
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: PPUSH
7447: CALL_OW 69
7451: ST_TO_ADDR
// if tmp then
7452: LD_VAR 0 5
7456: IFFALSE 7473
// ComMoveXY ( tmp , 75 , 100 ) ;
7458: LD_VAR 0 5
7462: PPUSH
7463: LD_INT 75
7465: PPUSH
7466: LD_INT 100
7468: PPUSH
7469: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7473: LD_ADDR_VAR 0 3
7477: PUSH
7478: LD_EXP 4
7482: PPUSH
7483: LD_INT 25
7485: PUSH
7486: LD_INT 1
7488: PUSH
7489: EMPTY
7490: LIST
7491: LIST
7492: PPUSH
7493: CALL_OW 72
7497: PPUSH
7498: LD_EXP 36
7502: PPUSH
7503: CALL_OW 74
7507: ST_TO_ADDR
// if sol then
7508: LD_VAR 0 3
7512: IFFALSE 7552
// if GetDistUnits ( JMM , sol ) < 10 then
7514: LD_EXP 36
7518: PPUSH
7519: LD_VAR 0 3
7523: PPUSH
7524: CALL_OW 296
7528: PUSH
7529: LD_INT 10
7531: LESS
7532: IFFALSE 7552
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7534: LD_VAR 0 3
7538: PPUSH
7539: LD_VAR 0 4
7543: PUSH
7544: LD_INT 2
7546: ARRAY
7547: PPUSH
7548: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7552: LD_INT 10
7554: PPUSH
7555: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7559: LD_EXP 36
7563: PPUSH
7564: LD_INT 65
7566: PPUSH
7567: LD_INT 101
7569: PPUSH
7570: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7574: LD_EXP 36
7578: PPUSH
7579: LD_INT 63
7581: PPUSH
7582: LD_INT 100
7584: PPUSH
7585: CALL_OW 178
// tmp := 0 0$0 ;
7589: LD_ADDR_VAR 0 5
7593: PUSH
7594: LD_INT 0
7596: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7597: LD_INT 35
7599: PPUSH
7600: CALL_OW 67
// tmp := tmp + 0 0$1 ;
7604: LD_ADDR_VAR 0 5
7608: PUSH
7609: LD_VAR 0 5
7613: PUSH
7614: LD_INT 35
7616: PLUS
7617: ST_TO_ADDR
// until IsAt ( JMM , 65 , 101 ) or tmp > 0 0$5 ;
7618: LD_EXP 36
7622: PPUSH
7623: LD_INT 65
7625: PPUSH
7626: LD_INT 101
7628: PPUSH
7629: CALL_OW 307
7633: PUSH
7634: LD_VAR 0 5
7638: PUSH
7639: LD_INT 175
7641: GREATER
7642: OR
7643: IFFALSE 7597
// Say ( JMM , D2a-JMM-1 ) ;
7645: LD_EXP 36
7649: PPUSH
7650: LD_STRING D2a-JMM-1
7652: PPUSH
7653: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7657: LD_EXP 47
7661: PPUSH
7662: LD_INT 66
7664: PPUSH
7665: LD_INT 103
7667: PPUSH
7668: CALL_OW 111
// tmp := 0 0$0 ;
7672: LD_ADDR_VAR 0 5
7676: PUSH
7677: LD_INT 0
7679: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7680: LD_INT 35
7682: PPUSH
7683: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) or tmp > 0 0$5 ;
7687: LD_EXP 47
7691: PPUSH
7692: LD_INT 66
7694: PPUSH
7695: LD_INT 103
7697: PPUSH
7698: CALL_OW 307
7702: PUSH
7703: LD_VAR 0 5
7707: PUSH
7708: LD_INT 175
7710: GREATER
7711: OR
7712: IFFALSE 7680
// ComTurnUnit ( Walker , JMM ) ;
7714: LD_EXP 47
7718: PPUSH
7719: LD_EXP 36
7723: PPUSH
7724: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7728: LD_EXP 47
7732: PPUSH
7733: LD_STRING D2a-Sci1-1
7735: PPUSH
7736: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7740: LD_EXP 36
7744: PPUSH
7745: LD_EXP 47
7749: PPUSH
7750: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7754: LD_EXP 36
7758: PPUSH
7759: LD_STRING D2a-JMM-2
7761: PPUSH
7762: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7766: LD_EXP 47
7770: PPUSH
7771: LD_STRING D2a-Sci1-2
7773: PPUSH
7774: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7778: LD_EXP 36
7782: PPUSH
7783: LD_STRING D2a-JMM-3
7785: PPUSH
7786: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7790: LD_EXP 47
7794: PPUSH
7795: LD_STRING D2a-Sci1-3
7797: PPUSH
7798: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7802: LD_ADDR_EXP 4
7806: PUSH
7807: LD_EXP 4
7811: PUSH
7812: LD_EXP 46
7816: PUSH
7817: LD_EXP 47
7821: PUSH
7822: LD_EXP 48
7826: PUSH
7827: LD_EXP 49
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: LIST
7836: LIST
7837: ADD
7838: ST_TO_ADDR
// for i in jmm_units do
7839: LD_ADDR_VAR 0 1
7843: PUSH
7844: LD_EXP 4
7848: PUSH
7849: FOR_IN
7850: IFFALSE 7875
// if not IsInUnit ( i ) then
7852: LD_VAR 0 1
7856: PPUSH
7857: CALL_OW 310
7861: NOT
7862: IFFALSE 7873
// ComFree ( i ) ;
7864: LD_VAR 0 1
7868: PPUSH
7869: CALL_OW 139
7873: GO 7849
7875: POP
7876: POP
// InGameOff ;
7877: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
7881: LD_STRING MSolar1
7883: PPUSH
7884: CALL_OW 337
// jmm_on_west := true ;
7888: LD_ADDR_EXP 5
7892: PUSH
7893: LD_INT 1
7895: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7896: LD_INT 1050
7898: PPUSH
7899: CALL_OW 67
// frank_can_return := true ;
7903: LD_ADDR_EXP 12
7907: PUSH
7908: LD_INT 1
7910: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7911: LD_INT 6300
7913: PPUSH
7914: LD_INT 8400
7916: PPUSH
7917: CALL_OW 12
7921: PPUSH
7922: CALL_OW 67
// send_spec_patrol := true ;
7926: LD_ADDR_EXP 29
7930: PUSH
7931: LD_INT 1
7933: ST_TO_ADDR
// end ;
7934: PPOPN 5
7936: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7937: LD_INT 22
7939: PUSH
7940: LD_INT 1
7942: PUSH
7943: EMPTY
7944: LIST
7945: LIST
7946: PUSH
7947: LD_INT 34
7949: PUSH
7950: LD_INT 51
7952: PUSH
7953: EMPTY
7954: LIST
7955: LIST
7956: PUSH
7957: LD_INT 92
7959: PUSH
7960: LD_INT 63
7962: PUSH
7963: LD_INT 100
7965: PUSH
7966: LD_INT 5
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: LIST
7979: PUSH
7980: EMPTY
7981: LIST
7982: PPUSH
7983: CALL_OW 69
7987: PUSH
7988: LD_EXP 5
7992: NOT
7993: AND
7994: IFFALSE 8107
7996: GO 7998
7998: DISABLE
7999: LD_INT 0
8001: PPUSH
8002: PPUSH
// begin enable ;
8003: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
8004: LD_ADDR_VAR 0 2
8008: PUSH
8009: LD_INT 22
8011: PUSH
8012: LD_INT 1
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: PUSH
8019: LD_INT 34
8021: PUSH
8022: LD_INT 51
8024: PUSH
8025: EMPTY
8026: LIST
8027: LIST
8028: PUSH
8029: LD_INT 92
8031: PUSH
8032: LD_INT 63
8034: PUSH
8035: LD_INT 100
8037: PUSH
8038: LD_INT 5
8040: PUSH
8041: EMPTY
8042: LIST
8043: LIST
8044: LIST
8045: LIST
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: LIST
8051: PUSH
8052: EMPTY
8053: LIST
8054: PPUSH
8055: CALL_OW 69
8059: ST_TO_ADDR
// if not filter then
8060: LD_VAR 0 2
8064: NOT
8065: IFFALSE 8069
// exit ;
8067: GO 8107
// for i in filter do
8069: LD_ADDR_VAR 0 1
8073: PUSH
8074: LD_VAR 0 2
8078: PUSH
8079: FOR_IN
8080: IFFALSE 8105
// begin SetFuel ( i , 0 ) ;
8082: LD_VAR 0 1
8086: PPUSH
8087: LD_INT 0
8089: PPUSH
8090: CALL_OW 240
// ComStop ( i ) ;
8094: LD_VAR 0 1
8098: PPUSH
8099: CALL_OW 141
// end ;
8103: GO 8079
8105: POP
8106: POP
// end ;
8107: PPOPN 2
8109: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
8110: LD_EXP 29
8114: IFFALSE 9107
8116: GO 8118
8118: DISABLE
8119: LD_INT 0
8121: PPUSH
8122: PPUSH
8123: PPUSH
8124: PPUSH
8125: PPUSH
8126: PPUSH
8127: PPUSH
// begin if not ru_spec_patrol then
8128: LD_EXP 53
8132: NOT
8133: IFFALSE 8137
// exit ;
8135: GO 9107
// dead1 := false ;
8137: LD_ADDR_VAR 0 1
8141: PUSH
8142: LD_INT 0
8144: ST_TO_ADDR
// dead2 := false ;
8145: LD_ADDR_VAR 0 2
8149: PUSH
8150: LD_INT 0
8152: ST_TO_ADDR
// inarea1 := false ;
8153: LD_ADDR_VAR 0 3
8157: PUSH
8158: LD_INT 0
8160: ST_TO_ADDR
// inarea2 := false ;
8161: LD_ADDR_VAR 0 4
8165: PUSH
8166: LD_INT 0
8168: ST_TO_ADDR
// tmp := [ ] ;
8169: LD_ADDR_VAR 0 6
8173: PUSH
8174: EMPTY
8175: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8176: LD_EXP 53
8180: PPUSH
8181: LD_INT 75
8183: PPUSH
8184: LD_INT 101
8186: PPUSH
8187: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8191: LD_INT 35
8193: PPUSH
8194: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8198: LD_INT 1
8200: PPUSH
8201: LD_EXP 53
8205: PUSH
8206: LD_INT 1
8208: ARRAY
8209: PPUSH
8210: CALL_OW 292
8214: IFFALSE 8191
// ComStop ( ru_spec_patrol ) ;
8216: LD_EXP 53
8220: PPUSH
8221: CALL_OW 141
// Wait ( 0 0$02 ) ;
8225: LD_INT 70
8227: PPUSH
8228: CALL_OW 67
// DialogueOn ;
8232: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8236: LD_EXP 53
8240: PUSH
8241: LD_INT 1
8243: ARRAY
8244: PPUSH
8245: LD_STRING D8-Rus1-1
8247: PPUSH
8248: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8252: LD_EXP 36
8256: PPUSH
8257: LD_STRING D8-JMM-1
8259: PPUSH
8260: CALL_OW 88
// DialogueOff ;
8264: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8268: LD_EXP 53
8272: PPUSH
8273: LD_INT 13
8275: PPUSH
8276: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8280: LD_INT 35
8282: PPUSH
8283: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8287: LD_VAR 0 1
8291: NOT
8292: PUSH
8293: LD_EXP 53
8297: PUSH
8298: LD_INT 1
8300: ARRAY
8301: PPUSH
8302: CALL_OW 301
8306: AND
8307: IFFALSE 8317
// dead1 := true ;
8309: LD_ADDR_VAR 0 1
8313: PUSH
8314: LD_INT 1
8316: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8317: LD_VAR 0 2
8321: NOT
8322: PUSH
8323: LD_EXP 53
8327: PUSH
8328: LD_INT 2
8330: ARRAY
8331: PPUSH
8332: CALL_OW 301
8336: AND
8337: IFFALSE 8347
// dead2 := true ;
8339: LD_ADDR_VAR 0 2
8343: PUSH
8344: LD_INT 1
8346: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8347: LD_VAR 0 3
8351: NOT
8352: PUSH
8353: LD_EXP 53
8357: PUSH
8358: LD_INT 1
8360: ARRAY
8361: PPUSH
8362: LD_INT 14
8364: PPUSH
8365: CALL_OW 308
8369: AND
8370: IFFALSE 8380
// inarea1 := true ;
8372: LD_ADDR_VAR 0 3
8376: PUSH
8377: LD_INT 1
8379: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8380: LD_VAR 0 4
8384: NOT
8385: PUSH
8386: LD_EXP 53
8390: PUSH
8391: LD_INT 2
8393: ARRAY
8394: PPUSH
8395: LD_INT 14
8397: PPUSH
8398: CALL_OW 308
8402: AND
8403: IFFALSE 8413
// inarea2 := true ;
8405: LD_ADDR_VAR 0 4
8409: PUSH
8410: LD_INT 1
8412: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8413: LD_VAR 0 1
8417: PUSH
8418: LD_VAR 0 2
8422: AND
8423: PUSH
8424: LD_VAR 0 1
8428: PUSH
8429: LD_VAR 0 4
8433: AND
8434: OR
8435: PUSH
8436: LD_VAR 0 2
8440: PUSH
8441: LD_VAR 0 3
8445: AND
8446: OR
8447: PUSH
8448: LD_VAR 0 3
8452: PUSH
8453: LD_VAR 0 4
8457: AND
8458: OR
8459: IFFALSE 8280
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8461: LD_VAR 0 3
8465: PUSH
8466: LD_VAR 0 4
8470: AND
8471: PUSH
8472: LD_VAR 0 1
8476: PUSH
8477: LD_VAR 0 4
8481: AND
8482: OR
8483: PUSH
8484: LD_VAR 0 2
8488: PUSH
8489: LD_VAR 0 3
8493: AND
8494: OR
8495: IFFALSE 9087
// begin prepare_siege := true ;
8497: LD_ADDR_EXP 30
8501: PUSH
8502: LD_INT 1
8504: ST_TO_ADDR
// DialogueOn ;
8505: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8509: LD_VAR 0 3
8513: PUSH
8514: LD_VAR 0 4
8518: AND
8519: IFFALSE 8535
// Say ( JMM , D8b-JMM-1a ) else
8521: LD_EXP 36
8525: PPUSH
8526: LD_STRING D8b-JMM-1a
8528: PPUSH
8529: CALL_OW 88
8533: GO 8547
// Say ( JMM , D8b-JMM-1 ) ;
8535: LD_EXP 36
8539: PPUSH
8540: LD_STRING D8b-JMM-1
8542: PPUSH
8543: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8547: LD_EXP 4
8551: PPUSH
8552: LD_INT 26
8554: PUSH
8555: LD_INT 1
8557: PUSH
8558: EMPTY
8559: LIST
8560: LIST
8561: PPUSH
8562: CALL_OW 72
8566: PUSH
8567: LD_EXP 37
8571: PUSH
8572: LD_EXP 38
8576: PUSH
8577: LD_EXP 47
8581: PUSH
8582: LD_EXP 50
8586: PUSH
8587: EMPTY
8588: LIST
8589: LIST
8590: LIST
8591: LIST
8592: DIFF
8593: PPUSH
8594: LD_STRING D8b-Sol1-1
8596: PPUSH
8597: CALL 625 0 2
// if Cyrus and Cyrus in jmm_units then
8601: LD_EXP 38
8605: PUSH
8606: LD_EXP 38
8610: PUSH
8611: LD_EXP 4
8615: IN
8616: AND
8617: IFFALSE 8633
// Say ( Cyrus , D8b-Cyrus-1 ) else
8619: LD_EXP 38
8623: PPUSH
8624: LD_STRING D8b-Cyrus-1
8626: PPUSH
8627: CALL_OW 88
8631: GO 8645
// Say ( JMM , D8b-JMM-1a ) ;
8633: LD_EXP 36
8637: PPUSH
8638: LD_STRING D8b-JMM-1a
8640: PPUSH
8641: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8645: LD_EXP 39
8649: PUSH
8650: LD_EXP 39
8654: PUSH
8655: LD_EXP 4
8659: IN
8660: AND
8661: IFFALSE 8675
// Say ( Lisa , D8b-Lisa-2 ) ;
8663: LD_EXP 39
8667: PPUSH
8668: LD_STRING D8b-Lisa-2
8670: PPUSH
8671: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8675: LD_EXP 37
8679: PUSH
8680: LD_EXP 37
8684: PUSH
8685: LD_EXP 4
8689: IN
8690: AND
8691: IFFALSE 8707
// Say ( Bobby , D8b-Bobby-1 ) else
8693: LD_EXP 37
8697: PPUSH
8698: LD_STRING D8b-Bobby-1
8700: PPUSH
8701: CALL_OW 88
8705: GO 8767
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8707: LD_ADDR_VAR 0 5
8711: PUSH
8712: LD_EXP 4
8716: PPUSH
8717: LD_INT 26
8719: PUSH
8720: LD_INT 1
8722: PUSH
8723: EMPTY
8724: LIST
8725: LIST
8726: PPUSH
8727: CALL_OW 72
8731: PUSH
8732: LD_EXP 37
8736: PUSH
8737: LD_EXP 38
8741: PUSH
8742: LD_EXP 47
8746: PUSH
8747: LD_EXP 50
8751: PUSH
8752: EMPTY
8753: LIST
8754: LIST
8755: LIST
8756: LIST
8757: DIFF
8758: PPUSH
8759: LD_STRING D8b-Sol2-1
8761: PPUSH
8762: CALL 625 0 2
8766: ST_TO_ADDR
// DialogueOff ;
8767: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8771: LD_EXP 38
8775: PUSH
8776: LD_EXP 38
8780: PUSH
8781: LD_EXP 4
8785: IN
8786: AND
8787: IFFALSE 8812
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8789: LD_ADDR_VAR 0 6
8793: PUSH
8794: LD_VAR 0 6
8798: PPUSH
8799: LD_INT 1
8801: PPUSH
8802: LD_EXP 38
8806: PPUSH
8807: CALL_OW 2
8811: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8812: LD_EXP 37
8816: PUSH
8817: LD_EXP 37
8821: PUSH
8822: LD_EXP 4
8826: IN
8827: AND
8828: IFFALSE 8853
// tmp := Insert ( tmp , 1 , Bobby ) ;
8830: LD_ADDR_VAR 0 6
8834: PUSH
8835: LD_VAR 0 6
8839: PPUSH
8840: LD_INT 1
8842: PPUSH
8843: LD_EXP 37
8847: PPUSH
8848: CALL_OW 2
8852: ST_TO_ADDR
// if sol then
8853: LD_VAR 0 5
8857: IFFALSE 8882
// tmp := Insert ( tmp , 1 , sol ) ;
8859: LD_ADDR_VAR 0 6
8863: PUSH
8864: LD_VAR 0 6
8868: PPUSH
8869: LD_INT 1
8871: PPUSH
8872: LD_VAR 0 5
8876: PPUSH
8877: CALL_OW 2
8881: ST_TO_ADDR
// if tmp then
8882: LD_VAR 0 6
8886: IFFALSE 9046
// begin SetSide ( tmp , 8 ) ;
8888: LD_VAR 0 6
8892: PPUSH
8893: LD_INT 8
8895: PPUSH
8896: CALL_OW 235
// ComFree ( tmp ) ;
8900: LD_VAR 0 6
8904: PPUSH
8905: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8909: LD_VAR 0 6
8913: PPUSH
8914: LD_INT 15
8916: PPUSH
8917: CALL_OW 173
// AddComHold ( tmp ) ;
8921: LD_VAR 0 6
8925: PPUSH
8926: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8930: LD_INT 35
8932: PPUSH
8933: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
8937: LD_VAR 0 6
8941: PUSH
8942: LD_INT 1
8944: ARRAY
8945: PPUSH
8946: CALL_OW 314
8950: NOT
8951: IFFALSE 8965
// ComMoveToArea ( tmp , cyrusEscape ) ;
8953: LD_VAR 0 6
8957: PPUSH
8958: LD_INT 15
8960: PPUSH
8961: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8965: LD_VAR 0 6
8969: PUSH
8970: LD_INT 1
8972: ARRAY
8973: PPUSH
8974: LD_INT 15
8976: PPUSH
8977: CALL_OW 308
8981: IFFALSE 9036
// begin RemoveUnit ( tmp [ 1 ] ) ;
8983: LD_VAR 0 6
8987: PUSH
8988: LD_INT 1
8990: ARRAY
8991: PPUSH
8992: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
8996: LD_ADDR_EXP 4
9000: PUSH
9001: LD_EXP 4
9005: PUSH
9006: LD_VAR 0 6
9010: PUSH
9011: LD_INT 1
9013: ARRAY
9014: DIFF
9015: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
9016: LD_ADDR_VAR 0 6
9020: PUSH
9021: LD_VAR 0 6
9025: PUSH
9026: LD_VAR 0 6
9030: PUSH
9031: LD_INT 1
9033: ARRAY
9034: DIFF
9035: ST_TO_ADDR
// end ; until tmp = 0 ;
9036: LD_VAR 0 6
9040: PUSH
9041: LD_INT 0
9043: EQUAL
9044: IFFALSE 8930
// end ; Wait ( 0 0$30 ) ;
9046: LD_INT 1050
9048: PPUSH
9049: CALL_OW 67
// if ru_spec_patrol then
9053: LD_EXP 53
9057: IFFALSE 9085
// for i in ru_spec_patrol do
9059: LD_ADDR_VAR 0 7
9063: PUSH
9064: LD_EXP 53
9068: PUSH
9069: FOR_IN
9070: IFFALSE 9083
// RemoveUnit ( i ) ;
9072: LD_VAR 0 7
9076: PPUSH
9077: CALL_OW 64
9081: GO 9069
9083: POP
9084: POP
// end else
9085: GO 9107
// begin prepare_siege := false ;
9087: LD_ADDR_EXP 30
9091: PUSH
9092: LD_INT 0
9094: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
9095: LD_EXP 36
9099: PPUSH
9100: LD_STRING D8a-JMM-1
9102: PPUSH
9103: CALL_OW 88
// end ; end ;
9107: PPOPN 7
9109: END
// every 0 0$10 trigger frank_can_return do var i , p , points ;
9110: LD_EXP 12
9114: IFFALSE 10313
9116: GO 9118
9118: DISABLE
9119: LD_INT 0
9121: PPUSH
9122: PPUSH
9123: PPUSH
// begin uc_side := 8 ;
9124: LD_ADDR_OWVAR 20
9128: PUSH
9129: LD_INT 8
9131: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
9132: LD_ADDR_VAR 0 3
9136: PUSH
9137: LD_INT 59
9139: PUSH
9140: LD_INT 71
9142: PUSH
9143: EMPTY
9144: LIST
9145: LIST
9146: PUSH
9147: LD_INT 122
9149: PUSH
9150: LD_INT 117
9152: PUSH
9153: EMPTY
9154: LIST
9155: LIST
9156: PUSH
9157: EMPTY
9158: LIST
9159: LIST
9160: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9161: LD_ADDR_EXP 50
9165: PUSH
9166: LD_STRING Frank
9168: PPUSH
9169: LD_INT 0
9171: PPUSH
9172: CALL 474 0 2
9176: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9177: LD_ADDR_VAR 0 1
9181: PUSH
9182: LD_INT 1
9184: PPUSH
9185: LD_INT 2
9187: PPUSH
9188: CALL_OW 12
9192: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9193: LD_EXP 50
9197: PPUSH
9198: LD_VAR 0 3
9202: PUSH
9203: LD_VAR 0 1
9207: ARRAY
9208: PUSH
9209: LD_INT 1
9211: ARRAY
9212: PPUSH
9213: LD_VAR 0 3
9217: PUSH
9218: LD_VAR 0 1
9222: ARRAY
9223: PUSH
9224: LD_INT 2
9226: ARRAY
9227: PPUSH
9228: LD_INT 0
9230: PPUSH
9231: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9235: LD_EXP 50
9239: PPUSH
9240: LD_INT 1
9242: PPUSH
9243: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9247: LD_INT 35
9249: PPUSH
9250: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
9254: LD_EXP 50
9258: PPUSH
9259: LD_EXP 36
9263: PPUSH
9264: CALL_OW 296
9268: PUSH
9269: LD_INT 8
9271: LESS
9272: IFFALSE 9247
// InGameOn ;
9274: CALL_OW 8
// CenterOnUnits ( JMM ) ;
9278: LD_EXP 36
9282: PPUSH
9283: CALL_OW 85
// if IsInUnit ( JMM ) then
9287: LD_EXP 36
9291: PPUSH
9292: CALL_OW 310
9296: IFFALSE 9307
// ComFree ( JMM ) ;
9298: LD_EXP 36
9302: PPUSH
9303: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9307: LD_EXP 36
9311: PPUSH
9312: LD_EXP 50
9316: PPUSH
9317: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9321: LD_EXP 50
9325: PPUSH
9326: LD_EXP 36
9330: PPUSH
9331: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9335: LD_EXP 36
9339: PPUSH
9340: LD_STRING D6-JMM-1
9342: PPUSH
9343: CALL_OW 88
// p := 0 ;
9347: LD_ADDR_VAR 0 2
9351: PUSH
9352: LD_INT 0
9354: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9355: LD_INT 35
9357: PPUSH
9358: CALL_OW 67
// p := p + 1 ;
9362: LD_ADDR_VAR 0 2
9366: PUSH
9367: LD_VAR 0 2
9371: PUSH
9372: LD_INT 1
9374: PLUS
9375: ST_TO_ADDR
// until GetDistUnits ( JMM , Frank ) < 8 or p > 7 ;
9376: LD_EXP 36
9380: PPUSH
9381: LD_EXP 50
9385: PPUSH
9386: CALL_OW 296
9390: PUSH
9391: LD_INT 8
9393: LESS
9394: PUSH
9395: LD_VAR 0 2
9399: PUSH
9400: LD_INT 7
9402: GREATER
9403: OR
9404: IFFALSE 9355
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9406: LD_EXP 39
9410: PUSH
9411: LD_EXP 39
9415: PPUSH
9416: LD_EXP 50
9420: PPUSH
9421: CALL_OW 296
9425: PUSH
9426: LD_INT 20
9428: LESS
9429: AND
9430: IFFALSE 9455
// begin ComFree ( Lisa ) ;
9432: LD_EXP 39
9436: PPUSH
9437: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9441: LD_EXP 39
9445: PPUSH
9446: LD_EXP 50
9450: PPUSH
9451: CALL_OW 172
// end ; if Lynch then
9455: LD_EXP 46
9459: IFFALSE 9484
// begin ComFree ( Lynch ) ;
9461: LD_EXP 46
9465: PPUSH
9466: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9470: LD_EXP 46
9474: PPUSH
9475: LD_EXP 50
9479: PPUSH
9480: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9484: LD_EXP 36
9488: PPUSH
9489: LD_EXP 50
9493: PPUSH
9494: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9498: LD_EXP 50
9502: PPUSH
9503: LD_EXP 36
9507: PPUSH
9508: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9512: LD_EXP 50
9516: PPUSH
9517: LD_STRING D6-Frank-1
9519: PPUSH
9520: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9524: LD_INT 69
9526: PPUSH
9527: LD_INT 20
9529: PPUSH
9530: LD_INT 1
9532: PPUSH
9533: LD_INT 20
9535: NEG
9536: PPUSH
9537: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9541: LD_INT 69
9543: PPUSH
9544: LD_INT 20
9546: PPUSH
9547: LD_INT 1
9549: PPUSH
9550: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9554: LD_INT 190
9556: PPUSH
9557: LD_INT 31
9559: PPUSH
9560: LD_INT 1
9562: PPUSH
9563: LD_INT 20
9565: NEG
9566: PPUSH
9567: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9571: LD_INT 190
9573: PPUSH
9574: LD_INT 31
9576: PPUSH
9577: LD_INT 1
9579: PPUSH
9580: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9584: LD_INT 69
9586: PPUSH
9587: LD_INT 20
9589: PPUSH
9590: CALL_OW 84
// Wait ( 0 0$02 ) ;
9594: LD_INT 70
9596: PPUSH
9597: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9601: LD_EXP 36
9605: PPUSH
9606: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9610: LD_EXP 39
9614: PUSH
9615: LD_EXP 39
9619: PPUSH
9620: LD_EXP 50
9624: PPUSH
9625: CALL_OW 296
9629: PUSH
9630: LD_INT 20
9632: LESS
9633: AND
9634: PUSH
9635: LD_EXP 39
9639: PPUSH
9640: CALL_OW 302
9644: AND
9645: IFFALSE 9767
// begin ComFree ( Lisa ) ;
9647: LD_EXP 39
9651: PPUSH
9652: CALL_OW 139
// p := 0 ;
9656: LD_ADDR_VAR 0 2
9660: PUSH
9661: LD_INT 0
9663: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9664: LD_INT 35
9666: PPUSH
9667: CALL_OW 67
// p := p + 1 ;
9671: LD_ADDR_VAR 0 2
9675: PUSH
9676: LD_VAR 0 2
9680: PUSH
9681: LD_INT 1
9683: PLUS
9684: ST_TO_ADDR
// until GetDistUnits ( Lisa , Frank ) < 7 or p > 7 ;
9685: LD_EXP 39
9689: PPUSH
9690: LD_EXP 50
9694: PPUSH
9695: CALL_OW 296
9699: PUSH
9700: LD_INT 7
9702: LESS
9703: PUSH
9704: LD_VAR 0 2
9708: PUSH
9709: LD_INT 7
9711: GREATER
9712: OR
9713: IFFALSE 9664
// Say ( Lisa , D6-Lisa-1 ) ;
9715: LD_EXP 39
9719: PPUSH
9720: LD_STRING D6-Lisa-1
9722: PPUSH
9723: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9727: LD_EXP 39
9731: PPUSH
9732: LD_EXP 50
9736: PPUSH
9737: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9741: LD_EXP 50
9745: PPUSH
9746: LD_EXP 39
9750: PPUSH
9751: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9755: LD_EXP 50
9759: PPUSH
9760: LD_STRING D6-Frank-2
9762: PPUSH
9763: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9767: LD_EXP 46
9771: PUSH
9772: LD_EXP 46
9776: PPUSH
9777: LD_EXP 50
9781: PPUSH
9782: CALL_OW 296
9786: PUSH
9787: LD_INT 20
9789: LESS
9790: AND
9791: PUSH
9792: LD_EXP 46
9796: PPUSH
9797: CALL_OW 302
9801: AND
9802: IFFALSE 9983
// begin ComTurnUnit ( Lynch , JMM ) ;
9804: LD_EXP 46
9808: PPUSH
9809: LD_EXP 36
9813: PPUSH
9814: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9818: LD_EXP 50
9822: PPUSH
9823: LD_EXP 36
9827: PPUSH
9828: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9832: LD_EXP 46
9836: PPUSH
9837: LD_STRING D6-Sol1-2
9839: PPUSH
9840: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9844: LD_EXP 36
9848: PPUSH
9849: LD_STRING D6-JMM-2
9851: PPUSH
9852: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9856: LD_EXP 50
9860: PPUSH
9861: LD_STRING D6-Frank-3
9863: PPUSH
9864: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9868: LD_EXP 36
9872: PPUSH
9873: LD_STRING D6-JMM-3
9875: PPUSH
9876: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9880: LD_EXP 50
9884: PPUSH
9885: LD_STRING D6-Frank-4
9887: PPUSH
9888: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9892: LD_EXP 50
9896: PPUSH
9897: LD_STRING D6-Frank-4a
9899: PPUSH
9900: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9904: LD_EXP 36
9908: PPUSH
9909: LD_STRING D6-JMM-4
9911: PPUSH
9912: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9916: LD_EXP 50
9920: PPUSH
9921: LD_STRING D6-Frank-5
9923: PPUSH
9924: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9928: LD_EXP 39
9932: PUSH
9933: LD_EXP 39
9937: PPUSH
9938: CALL_OW 302
9942: AND
9943: IFFALSE 9957
// Say ( Lisa , D6-Lisa-5 ) ;
9945: LD_EXP 39
9949: PPUSH
9950: LD_STRING D6-Lisa-5
9952: PPUSH
9953: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9957: LD_EXP 50
9961: PPUSH
9962: LD_STRING D6-Frank-6
9964: PPUSH
9965: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9969: LD_EXP 36
9973: PPUSH
9974: LD_STRING D6-JMM-6
9976: PPUSH
9977: CALL_OW 88
// end else
9981: GO 10098
// begin ComTurnUnit ( Frank , JMM ) ;
9983: LD_EXP 50
9987: PPUSH
9988: LD_EXP 36
9992: PPUSH
9993: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
9997: LD_EXP 50
10001: PPUSH
10002: LD_STRING D6-Frank-4
10004: PPUSH
10005: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10009: LD_EXP 50
10013: PPUSH
10014: LD_STRING D6-Frank-4a
10016: PPUSH
10017: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10021: LD_EXP 36
10025: PPUSH
10026: LD_STRING D6-JMM-4
10028: PPUSH
10029: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10033: LD_EXP 50
10037: PPUSH
10038: LD_STRING D6-Frank-5
10040: PPUSH
10041: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10045: LD_EXP 39
10049: PUSH
10050: LD_EXP 39
10054: PPUSH
10055: CALL_OW 302
10059: AND
10060: IFFALSE 10074
// Say ( Lisa , D6-Lisa-5 ) ;
10062: LD_EXP 39
10066: PPUSH
10067: LD_STRING D6-Lisa-5
10069: PPUSH
10070: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10074: LD_EXP 50
10078: PPUSH
10079: LD_STRING D6-Frank-6
10081: PPUSH
10082: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10086: LD_EXP 36
10090: PPUSH
10091: LD_STRING D6-JMM-6
10093: PPUSH
10094: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
10098: LD_STRING Q1
10100: PPUSH
10101: CALL_OW 97
10105: PUSH
10106: LD_INT 1
10108: DOUBLE
10109: EQUAL
10110: IFTRUE 10114
10112: GO 10125
10114: POP
// frank_send_to_scout := true ; 2 :
10115: LD_ADDR_EXP 14
10119: PUSH
10120: LD_INT 1
10122: ST_TO_ADDR
10123: GO 10145
10125: LD_INT 2
10127: DOUBLE
10128: EQUAL
10129: IFTRUE 10133
10131: GO 10144
10133: POP
// frank_send_to_scout := false ; end ;
10134: LD_ADDR_EXP 14
10138: PUSH
10139: LD_INT 0
10141: ST_TO_ADDR
10142: GO 10145
10144: POP
// InGameOff ;
10145: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
10149: LD_EXP 36
10153: PUSH
10154: LD_EXP 39
10158: PUSH
10159: LD_EXP 46
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: LIST
10168: PPUSH
10169: CALL_OW 139
// if frank_send_to_scout then
10173: LD_EXP 14
10177: IFFALSE 10234
// begin ComMoveXY ( Frank , 130 , 123 ) ;
10179: LD_EXP 50
10183: PPUSH
10184: LD_INT 130
10186: PPUSH
10187: LD_INT 123
10189: PPUSH
10190: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
10194: LD_INT 35
10196: PPUSH
10197: CALL_OW 67
// until not See ( 1 , Frank ) ;
10201: LD_INT 1
10203: PPUSH
10204: LD_EXP 50
10208: PPUSH
10209: CALL_OW 292
10213: NOT
10214: IFFALSE 10194
// Wait ( 0 0$02 ) ;
10216: LD_INT 70
10218: PPUSH
10219: CALL_OW 67
// RemoveUnit ( Frank ) ;
10223: LD_EXP 50
10227: PPUSH
10228: CALL_OW 64
// end else
10232: GO 10246
// SetSide ( Frank , 1 ) ;
10234: LD_EXP 50
10238: PPUSH
10239: LD_INT 1
10241: PPUSH
10242: CALL_OW 235
// send_attack_on_cornel_base := true ;
10246: LD_ADDR_EXP 25
10250: PUSH
10251: LD_INT 1
10253: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10254: LD_INT 35
10256: PPUSH
10257: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10261: LD_ADDR_EXP 28
10265: PUSH
10266: LD_EXP 28
10270: PPUSH
10271: LD_STRING -
10273: PPUSH
10274: CALL 1117 0 2
10278: ST_TO_ADDR
// if debug then
10279: LD_EXP 1
10283: IFFALSE 10295
// debug_strings := time_to_prepare ;
10285: LD_ADDR_OWVAR 48
10289: PUSH
10290: LD_EXP 28
10294: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10295: LD_EXP 28
10299: PUSH
10300: LD_INT 0
10302: EQUAL
10303: IFFALSE 10254
// cornel_prepared := true ;
10305: LD_ADDR_EXP 11
10309: PUSH
10310: LD_INT 1
10312: ST_TO_ADDR
// end ;
10313: PPOPN 3
10315: END
// every 0 0$01 trigger cornel_prepared do
10316: LD_EXP 11
10320: IFFALSE 10577
10322: GO 10324
10324: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10325: LD_EXP 43
10329: PPUSH
10330: LD_STRING D3-Corn-1
10332: PPUSH
10333: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10337: LD_INT 35
10339: PPUSH
10340: CALL_OW 67
// until cornel_counter = 0 ;
10344: LD_EXP 10
10348: PUSH
10349: LD_INT 0
10351: EQUAL
10352: IFFALSE 10337
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10354: LD_EXP 43
10358: PPUSH
10359: LD_STRING D3a-Corn-1
10361: PPUSH
10362: CALL_OW 94
// if IsOk ( Cornel ) then
10366: LD_EXP 43
10370: PPUSH
10371: CALL_OW 302
10375: IFFALSE 10389
// Say ( JMM , D3a-JMM-1 ) ;
10377: LD_EXP 36
10381: PPUSH
10382: LD_STRING D3a-JMM-1
10384: PPUSH
10385: CALL_OW 88
// end_mission_allowed := true ;
10389: LD_ADDR_EXP 20
10393: PUSH
10394: LD_INT 1
10396: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10397: LD_STRING M2
10399: PPUSH
10400: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10404: LD_INT 9
10406: PPUSH
10407: LD_INT 1
10409: PPUSH
10410: CALL_OW 424
// Wait ( 0 0$05 ) ;
10414: LD_INT 175
10416: PPUSH
10417: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10421: LD_EXP 43
10425: PPUSH
10426: LD_STRING D3a-Corn-2
10428: PPUSH
10429: CALL_OW 94
// cornel_attack := true ;
10433: LD_ADDR_EXP 9
10437: PUSH
10438: LD_INT 1
10440: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10441: LD_INT 105
10443: PPUSH
10444: CALL_OW 67
// AddMoreTanks ( ) ;
10448: CALL 4834 0 0
// if frank_send_to_scout then
10452: LD_EXP 14
10456: IFFALSE 10577
// begin InitHc ;
10458: CALL_OW 19
// InitUc ;
10462: CALL_OW 18
// uc_side := 8 ;
10466: LD_ADDR_OWVAR 20
10470: PUSH
10471: LD_INT 8
10473: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10474: LD_ADDR_EXP 50
10478: PUSH
10479: LD_STRING Frank
10481: PPUSH
10482: LD_INT 0
10484: PPUSH
10485: CALL 474 0 2
10489: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10490: LD_EXP 50
10494: PPUSH
10495: LD_INT 6
10497: PPUSH
10498: LD_INT 9
10500: PPUSH
10501: LD_INT 0
10503: PPUSH
10504: CALL_OW 48
// ComCrawl ( Frank ) ;
10508: LD_EXP 50
10512: PPUSH
10513: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
10517: LD_INT 35
10519: PPUSH
10520: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
10524: LD_EXP 36
10528: PPUSH
10529: LD_EXP 50
10533: PPUSH
10534: CALL_OW 296
10538: PUSH
10539: LD_INT 9
10541: LESS
10542: IFFALSE 10517
// SetSide ( Frank , 1 ) ;
10544: LD_EXP 50
10548: PPUSH
10549: LD_INT 1
10551: PPUSH
10552: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10556: LD_EXP 50
10560: PPUSH
10561: LD_STRING D6a-Frank-1
10563: PPUSH
10564: CALL_OW 88
// ComWalk ( Frank ) ;
10568: LD_EXP 50
10572: PPUSH
10573: CALL_OW 138
// end ; end ;
10577: END
// every 0 0$01 trigger solar_builded do
10578: LD_EXP 13
10582: IFFALSE 10686
10584: GO 10586
10586: DISABLE
// begin Wait ( 0 0$02 ) ;
10587: LD_INT 70
10589: PPUSH
10590: CALL_OW 67
// DialogueOn ;
10594: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10598: LD_EXP 36
10602: PPUSH
10603: LD_STRING D2b-JMM-1
10605: PPUSH
10606: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10610: LD_EXP 47
10614: PUSH
10615: LD_EXP 47
10619: PPUSH
10620: CALL_OW 302
10624: AND
10625: IFFALSE 10675
// begin Say ( Walker , D2b-Sci1-1 ) ;
10627: LD_EXP 47
10631: PPUSH
10632: LD_STRING D2b-Sci1-1
10634: PPUSH
10635: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10639: LD_EXP 36
10643: PPUSH
10644: LD_STRING D2b-JMM-2
10646: PPUSH
10647: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10651: LD_EXP 47
10655: PPUSH
10656: LD_STRING D2b-Sci1-2
10658: PPUSH
10659: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10663: LD_EXP 36
10667: PPUSH
10668: LD_STRING D2b-JMM-3
10670: PPUSH
10671: CALL_OW 88
// end ; DialogueOff ;
10675: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10679: LD_STRING MOutSol
10681: PPUSH
10682: CALL_OW 337
// end ;
10686: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10687: LD_EXP 13
10691: PUSH
10692: LD_EXP 36
10696: PPUSH
10697: CALL_OW 302
10701: AND
10702: PUSH
10703: LD_EXP 36
10707: PPUSH
10708: CALL 951 0 1
10712: AND
10713: PUSH
10714: LD_EXP 15
10718: NOT
10719: AND
10720: IFFALSE 10791
10722: GO 10724
10724: DISABLE
10725: LD_INT 0
10727: PPUSH
// begin jmm_in_veh := true ;
10728: LD_ADDR_EXP 15
10732: PUSH
10733: LD_INT 1
10735: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10736: LD_ADDR_VAR 0 1
10740: PUSH
10741: LD_INT 0
10743: PPUSH
10744: LD_INT 1
10746: PPUSH
10747: CALL_OW 12
10751: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10752: LD_INT 70
10754: PPUSH
10755: CALL_OW 67
// if i then
10759: LD_VAR 0 1
10763: IFFALSE 10779
// Say ( JMM , D2c-JMM-1 ) else
10765: LD_EXP 36
10769: PPUSH
10770: LD_STRING D2c-JMM-1
10772: PPUSH
10773: CALL_OW 88
10777: GO 10791
// Say ( JMM , D2c-JMM-1a ) ;
10779: LD_EXP 36
10783: PPUSH
10784: LD_STRING D2c-JMM-1a
10786: PPUSH
10787: CALL_OW 88
// end ;
10791: PPOPN 1
10793: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10794: LD_EXP 13
10798: PUSH
10799: LD_EXP 37
10803: PPUSH
10804: CALL_OW 302
10808: AND
10809: PUSH
10810: LD_EXP 37
10814: PPUSH
10815: CALL 951 0 1
10819: AND
10820: PUSH
10821: LD_EXP 16
10825: NOT
10826: AND
10827: IFFALSE 10859
10829: GO 10831
10831: DISABLE
// begin bobby_in_veh := true ;
10832: LD_ADDR_EXP 16
10836: PUSH
10837: LD_INT 1
10839: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10840: LD_INT 70
10842: PPUSH
10843: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10847: LD_EXP 37
10851: PPUSH
10852: LD_STRING D2c-Bobby-1
10854: PPUSH
10855: CALL_OW 88
10859: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10860: LD_EXP 13
10864: PUSH
10865: LD_EXP 39
10869: PPUSH
10870: CALL_OW 302
10874: AND
10875: PUSH
10876: LD_EXP 39
10880: PPUSH
10881: CALL 951 0 1
10885: AND
10886: PUSH
10887: LD_EXP 18
10891: NOT
10892: AND
10893: IFFALSE 10925
10895: GO 10897
10897: DISABLE
// begin lisa_in_veh := true ;
10898: LD_ADDR_EXP 18
10902: PUSH
10903: LD_INT 1
10905: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10906: LD_INT 70
10908: PPUSH
10909: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10913: LD_EXP 39
10917: PPUSH
10918: LD_STRING D2c-Lisa-1
10920: PPUSH
10921: CALL_OW 88
10925: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
10926: LD_EXP 13
10930: PUSH
10931: LD_EXP 38
10935: PPUSH
10936: CALL_OW 302
10940: AND
10941: PUSH
10942: LD_EXP 38
10946: PPUSH
10947: CALL 951 0 1
10951: AND
10952: PUSH
10953: LD_EXP 17
10957: NOT
10958: AND
10959: IFFALSE 11030
10961: GO 10963
10963: DISABLE
10964: LD_INT 0
10966: PPUSH
// begin cyrus_in_veh := true ;
10967: LD_ADDR_EXP 17
10971: PUSH
10972: LD_INT 1
10974: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10975: LD_ADDR_VAR 0 1
10979: PUSH
10980: LD_INT 0
10982: PPUSH
10983: LD_INT 1
10985: PPUSH
10986: CALL_OW 12
10990: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10991: LD_INT 70
10993: PPUSH
10994: CALL_OW 67
// if i then
10998: LD_VAR 0 1
11002: IFFALSE 11018
// Say ( Cyrus , D2c-Cyrus-1 ) else
11004: LD_EXP 38
11008: PPUSH
11009: LD_STRING D2c-Cyrus-1
11011: PPUSH
11012: CALL_OW 88
11016: GO 11030
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11018: LD_EXP 38
11022: PPUSH
11023: LD_STRING D2c-Cyrus-1a
11025: PPUSH
11026: CALL_OW 88
// end ;
11030: PPOPN 1
11032: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
11033: LD_EXP 43
11037: PPUSH
11038: LD_INT 16
11040: PPUSH
11041: CALL_OW 308
11045: IFFALSE 11309
11047: GO 11049
11049: DISABLE
11050: LD_INT 0
11052: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
11053: LD_INT 3
11055: PPUSH
11056: LD_EXP 43
11060: PPUSH
11061: CALL_OW 471
// send_attack_on_cornel := true ;
11065: LD_ADDR_EXP 31
11069: PUSH
11070: LD_INT 1
11072: ST_TO_ADDR
// if ru_vehicles then
11073: LD_EXP 55
11077: IFFALSE 11111
// for i in ru_vehicles do
11079: LD_ADDR_VAR 0 1
11083: PUSH
11084: LD_EXP 55
11088: PUSH
11089: FOR_IN
11090: IFFALSE 11109
// ComAgressiveMove ( i , 215 , 69 ) ;
11092: LD_VAR 0 1
11096: PPUSH
11097: LD_INT 215
11099: PPUSH
11100: LD_INT 69
11102: PPUSH
11103: CALL_OW 114
11107: GO 11089
11109: POP
11110: POP
// if ru_patrol then
11111: LD_EXP 52
11115: IFFALSE 11149
// for i in ru_patrol do
11117: LD_ADDR_VAR 0 1
11121: PUSH
11122: LD_EXP 52
11126: PUSH
11127: FOR_IN
11128: IFFALSE 11147
// ComAgressiveMove ( i , 215 , 69 ) ;
11130: LD_VAR 0 1
11134: PPUSH
11135: LD_INT 215
11137: PPUSH
11138: LD_INT 69
11140: PPUSH
11141: CALL_OW 114
11145: GO 11127
11147: POP
11148: POP
// if frank_send_to_scout then
11149: LD_EXP 14
11153: IFFALSE 11167
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
11155: LD_EXP 50
11159: PPUSH
11160: LD_STRING D3b-Frank-1
11162: PPUSH
11163: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
11167: LD_INT 105
11169: PPUSH
11170: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
11174: LD_EXP 43
11178: PPUSH
11179: LD_STRING D4-Corn-1
11181: PPUSH
11182: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
11186: LD_INT 35
11188: PPUSH
11189: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 6 ;
11193: LD_INT 22
11195: PUSH
11196: LD_INT 4
11198: PUSH
11199: EMPTY
11200: LIST
11201: LIST
11202: PUSH
11203: LD_INT 21
11205: PUSH
11206: LD_INT 1
11208: PUSH
11209: EMPTY
11210: LIST
11211: LIST
11212: PUSH
11213: LD_INT 50
11215: PUSH
11216: EMPTY
11217: LIST
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: LIST
11223: PPUSH
11224: CALL_OW 69
11228: PUSH
11229: LD_INT 6
11231: LESS
11232: IFFALSE 11186
// SayRadio ( Cornel , D5-Corn-1 ) ;
11234: LD_EXP 43
11238: PPUSH
11239: LD_STRING D5-Corn-1
11241: PPUSH
11242: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11246: LD_EXP 43
11250: PPUSH
11251: LD_EXP 2
11255: PUSH
11256: LD_STRING Cornel
11258: STR
11259: PPUSH
11260: CALL_OW 38
// cornel_saved := true ;
11264: LD_ADDR_EXP 26
11268: PUSH
11269: LD_INT 1
11271: ST_TO_ADDR
// ChangeSideFog ( 4 , 8 ) ;
11272: LD_INT 4
11274: PPUSH
11275: LD_INT 8
11277: PPUSH
11278: CALL_OW 343
// Wait ( 0 0$01 ) ;
11282: LD_INT 35
11284: PPUSH
11285: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11289: LD_INT 3
11291: PPUSH
11292: LD_EXP 43
11296: PPUSH
11297: CALL_OW 472
// send_attack_on_cornel := false ;
11301: LD_ADDR_EXP 31
11305: PUSH
11306: LD_INT 0
11308: ST_TO_ADDR
// end ;
11309: PPOPN 1
11311: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11312: LD_INT 9
11314: PPUSH
11315: LD_INT 22
11317: PUSH
11318: LD_INT 1
11320: PUSH
11321: EMPTY
11322: LIST
11323: LIST
11324: PPUSH
11325: CALL_OW 70
11329: PUSH
11330: LD_EXP 32
11334: OR
11335: IFFALSE 11517
11337: GO 11339
11339: DISABLE
11340: LD_INT 0
11342: PPUSH
11343: PPUSH
// begin enable ;
11344: ENABLE
// if not jmm_on_west then
11345: LD_EXP 5
11349: NOT
11350: IFFALSE 11361
// begin YouLost ( 4 ) ;
11352: LD_STRING 4
11354: PPUSH
11355: CALL_OW 104
// exit ;
11359: GO 11517
// end ; if not game_end then
11361: LD_EXP 32
11365: NOT
11366: IFFALSE 11376
// game_end := true ;
11368: LD_ADDR_EXP 32
11372: PUSH
11373: LD_INT 1
11375: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11376: LD_ADDR_VAR 0 2
11380: PUSH
11381: LD_INT 9
11383: PPUSH
11384: LD_INT 22
11386: PUSH
11387: LD_INT 1
11389: PUSH
11390: EMPTY
11391: LIST
11392: LIST
11393: PPUSH
11394: CALL_OW 70
11398: ST_TO_ADDR
// if not filter then
11399: LD_VAR 0 2
11403: NOT
11404: IFFALSE 11408
// exit ;
11406: GO 11517
// for i in filter do
11408: LD_ADDR_VAR 0 1
11412: PUSH
11413: LD_VAR 0 2
11417: PUSH
11418: FOR_IN
11419: IFFALSE 11515
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
11421: LD_VAR 0 1
11425: PPUSH
11426: CALL_OW 302
11430: PUSH
11431: LD_VAR 0 1
11435: PPUSH
11436: CALL_OW 247
11440: PUSH
11441: LD_INT 2
11443: EQUAL
11444: AND
11445: IFFALSE 11478
// begin veh_on_meta := true ;
11447: LD_ADDR_EXP 27
11451: PUSH
11452: LD_INT 1
11454: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11455: LD_VAR 0 1
11459: PPUSH
11460: CALL_OW 311
11464: PPUSH
11465: CALL 11520 0 1
// RemoveUnit ( i ) ;
11469: LD_VAR 0 1
11473: PPUSH
11474: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11478: LD_VAR 0 1
11482: PPUSH
11483: CALL_OW 302
11487: PUSH
11488: LD_VAR 0 1
11492: PPUSH
11493: CALL_OW 247
11497: PUSH
11498: LD_INT 1
11500: EQUAL
11501: AND
11502: IFFALSE 11513
// Save ( i ) ;
11504: LD_VAR 0 1
11508: PPUSH
11509: CALL 11520 0 1
// end ;
11513: GO 11418
11515: POP
11516: POP
// end ;
11517: PPOPN 2
11519: END
// export function Save ( i ) ; begin
11520: LD_INT 0
11522: PPUSH
// save_counter := save_counter + 1 ;
11523: LD_ADDR_EXP 35
11527: PUSH
11528: LD_EXP 35
11532: PUSH
11533: LD_INT 1
11535: PLUS
11536: ST_TO_ADDR
// if i = JMM then
11537: LD_VAR 0 1
11541: PUSH
11542: LD_EXP 36
11546: EQUAL
11547: IFFALSE 11669
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11549: LD_EXP 23
11553: PUSH
11554: LD_INT 22
11556: PUSH
11557: LD_INT 1
11559: PUSH
11560: EMPTY
11561: LIST
11562: LIST
11563: PUSH
11564: LD_INT 21
11566: PUSH
11567: LD_INT 1
11569: PUSH
11570: EMPTY
11571: LIST
11572: LIST
11573: PUSH
11574: EMPTY
11575: LIST
11576: LIST
11577: PPUSH
11578: CALL_OW 69
11582: PUSH
11583: LD_INT 1
11585: GREATER
11586: AND
11587: IFFALSE 11644
// begin show_query := false ;
11589: LD_ADDR_EXP 23
11593: PUSH
11594: LD_INT 0
11596: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11597: LD_STRING Q2
11599: PPUSH
11600: CALL_OW 97
11604: PUSH
11605: LD_INT 1
11607: DOUBLE
11608: EQUAL
11609: IFTRUE 11613
11611: GO 11624
11613: POP
// wait_for_them := true ; 2 :
11614: LD_ADDR_EXP 24
11618: PUSH
11619: LD_INT 1
11621: ST_TO_ADDR
11622: GO 11644
11624: LD_INT 2
11626: DOUBLE
11627: EQUAL
11628: IFTRUE 11632
11630: GO 11643
11632: POP
// wait_for_them := false ; end ;
11633: LD_ADDR_EXP 24
11637: PUSH
11638: LD_INT 0
11640: ST_TO_ADDR
11641: GO 11644
11643: POP
// end ; save_group := save_group ^ JMM ;
11644: LD_ADDR_EXP 22
11648: PUSH
11649: LD_EXP 22
11653: PUSH
11654: LD_EXP 36
11658: ADD
11659: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11660: LD_EXP 36
11664: PPUSH
11665: CALL_OW 64
// end ; if i = Lisa then
11669: LD_VAR 0 1
11673: PUSH
11674: LD_EXP 39
11678: EQUAL
11679: IFFALSE 11706
// begin save_group := save_group ^ Lisa ;
11681: LD_ADDR_EXP 22
11685: PUSH
11686: LD_EXP 22
11690: PUSH
11691: LD_EXP 39
11695: ADD
11696: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11697: LD_EXP 39
11701: PPUSH
11702: CALL_OW 64
// end ; if i = Bobby then
11706: LD_VAR 0 1
11710: PUSH
11711: LD_EXP 37
11715: EQUAL
11716: IFFALSE 11743
// begin save_group := save_group ^ Bobby ;
11718: LD_ADDR_EXP 22
11722: PUSH
11723: LD_EXP 22
11727: PUSH
11728: LD_EXP 37
11732: ADD
11733: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11734: LD_EXP 37
11738: PPUSH
11739: CALL_OW 64
// end ; if i = Cyrus then
11743: LD_VAR 0 1
11747: PUSH
11748: LD_EXP 38
11752: EQUAL
11753: IFFALSE 11780
// begin save_group := save_group ^ Cyrus ;
11755: LD_ADDR_EXP 22
11759: PUSH
11760: LD_EXP 22
11764: PUSH
11765: LD_EXP 38
11769: ADD
11770: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11771: LD_EXP 38
11775: PPUSH
11776: CALL_OW 64
// end ; if i = Khatam then
11780: LD_VAR 0 1
11784: PUSH
11785: LD_EXP 40
11789: EQUAL
11790: IFFALSE 11817
// begin save_group := save_group ^ Khatam ;
11792: LD_ADDR_EXP 22
11796: PUSH
11797: LD_EXP 22
11801: PUSH
11802: LD_EXP 40
11806: ADD
11807: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11808: LD_EXP 40
11812: PPUSH
11813: CALL_OW 64
// end ; if i = Frank then
11817: LD_VAR 0 1
11821: PUSH
11822: LD_EXP 50
11826: EQUAL
11827: IFFALSE 11854
// begin save_group := save_group ^ Frank ;
11829: LD_ADDR_EXP 22
11833: PUSH
11834: LD_EXP 22
11838: PUSH
11839: LD_EXP 50
11843: ADD
11844: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11845: LD_EXP 50
11849: PPUSH
11850: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11854: LD_VAR 0 1
11858: PPUSH
11859: CALL_OW 302
11863: PUSH
11864: LD_VAR 0 1
11868: PPUSH
11869: CALL_OW 247
11873: PUSH
11874: LD_INT 1
11876: EQUAL
11877: AND
11878: PUSH
11879: LD_VAR 0 1
11883: PUSH
11884: LD_EXP 22
11888: IN
11889: NOT
11890: AND
11891: IFFALSE 11918
// begin save_others := save_others ^ i ;
11893: LD_ADDR_EXP 21
11897: PUSH
11898: LD_EXP 21
11902: PUSH
11903: LD_VAR 0 1
11907: ADD
11908: ST_TO_ADDR
// RemoveUnit ( i ) ;
11909: LD_VAR 0 1
11913: PPUSH
11914: CALL_OW 64
// end ; end ;
11918: LD_VAR 0 2
11922: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
11923: LD_EXP 23
11927: NOT
11928: PUSH
11929: LD_EXP 24
11933: NOT
11934: AND
11935: PUSH
11936: LD_INT 22
11938: PUSH
11939: LD_INT 1
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: PUSH
11946: LD_INT 21
11948: PUSH
11949: LD_INT 1
11951: PUSH
11952: EMPTY
11953: LIST
11954: LIST
11955: PUSH
11956: EMPTY
11957: LIST
11958: LIST
11959: PPUSH
11960: CALL_OW 69
11964: PUSH
11965: LD_INT 0
11967: EQUAL
11968: OR
11969: IFFALSE 11978
11971: GO 11973
11973: DISABLE
// EndMission ;
11974: CALL 11979 0 0
11978: END
// export function EndMission ; var i ; begin
11979: LD_INT 0
11981: PPUSH
11982: PPUSH
// Wait ( 0 0$02 ) ;
11983: LD_INT 70
11985: PPUSH
11986: CALL_OW 67
// if solar_builded then
11990: LD_EXP 13
11994: IFFALSE 12008
// AddMedal ( Solar1 , 1 ) else
11996: LD_STRING Solar1
11998: PPUSH
11999: LD_INT 1
12001: PPUSH
12002: CALL_OW 101
12006: GO 12019
// AddMedal ( Solar1 , - 1 ) ;
12008: LD_STRING Solar1
12010: PPUSH
12011: LD_INT 1
12013: NEG
12014: PPUSH
12015: CALL_OW 101
// if veh_on_meta then
12019: LD_EXP 27
12023: IFFALSE 12037
// AddMedal ( Solar2 , 1 ) else
12025: LD_STRING Solar2
12027: PPUSH
12028: LD_INT 1
12030: PPUSH
12031: CALL_OW 101
12035: GO 12067
// if solar_builded then
12037: LD_EXP 13
12041: IFFALSE 12056
// AddMedal ( Solar2 , - 1 ) else
12043: LD_STRING Solar2
12045: PPUSH
12046: LD_INT 1
12048: NEG
12049: PPUSH
12050: CALL_OW 101
12054: GO 12067
// AddMedal ( Solar2 , - 2 ) ;
12056: LD_STRING Solar2
12058: PPUSH
12059: LD_INT 2
12061: NEG
12062: PPUSH
12063: CALL_OW 101
// if lose_counter = 0 then
12067: LD_EXP 33
12071: PUSH
12072: LD_INT 0
12074: EQUAL
12075: IFFALSE 12089
// AddMedal ( No , 1 ) else
12077: LD_STRING No
12079: PPUSH
12080: LD_INT 1
12082: PPUSH
12083: CALL_OW 101
12087: GO 12133
// if lose_counter > 0 and lose_counter < 4 then
12089: LD_EXP 33
12093: PUSH
12094: LD_INT 0
12096: GREATER
12097: PUSH
12098: LD_EXP 33
12102: PUSH
12103: LD_INT 4
12105: LESS
12106: AND
12107: IFFALSE 12122
// AddMedal ( No , - 1 ) else
12109: LD_STRING No
12111: PPUSH
12112: LD_INT 1
12114: NEG
12115: PPUSH
12116: CALL_OW 101
12120: GO 12133
// AddMedal ( UpTo4 , - 1 ) ;
12122: LD_STRING UpTo4
12124: PPUSH
12125: LD_INT 1
12127: NEG
12128: PPUSH
12129: CALL_OW 101
// GiveMedals ( MAIN ) ;
12133: LD_STRING MAIN
12135: PPUSH
12136: CALL_OW 102
// if IsDead ( Pokryshkin ) then
12140: LD_EXP 51
12144: PPUSH
12145: CALL_OW 301
12149: IFFALSE 12189
// for i in save_group ^ save_others do
12151: LD_ADDR_VAR 0 2
12155: PUSH
12156: LD_EXP 22
12160: PUSH
12161: LD_EXP 21
12165: ADD
12166: PUSH
12167: FOR_IN
12168: IFFALSE 12187
// AddExperience ( i , skill_combat , 1500 ) ;
12170: LD_VAR 0 2
12174: PPUSH
12175: LD_INT 1
12177: PPUSH
12178: LD_INT 1500
12180: PPUSH
12181: CALL_OW 492
12185: GO 12167
12187: POP
12188: POP
// RewardPeople ( save_group ^ save_others ) ;
12189: LD_EXP 22
12193: PUSH
12194: LD_EXP 21
12198: ADD
12199: PPUSH
12200: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
12204: LD_EXP 36
12208: PPUSH
12209: LD_EXP 2
12213: PUSH
12214: LD_STRING JMM
12216: STR
12217: PPUSH
12218: CALL_OW 38
// if Bobby in save_group then
12222: LD_EXP 37
12226: PUSH
12227: LD_EXP 22
12231: IN
12232: IFFALSE 12252
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12234: LD_EXP 37
12238: PPUSH
12239: LD_EXP 2
12243: PUSH
12244: LD_STRING Bobby
12246: STR
12247: PPUSH
12248: CALL_OW 38
// if Cyrus in save_group then
12252: LD_EXP 38
12256: PUSH
12257: LD_EXP 22
12261: IN
12262: IFFALSE 12282
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12264: LD_EXP 38
12268: PPUSH
12269: LD_EXP 2
12273: PUSH
12274: LD_STRING Cyrus
12276: STR
12277: PPUSH
12278: CALL_OW 38
// if Lisa in save_group then
12282: LD_EXP 39
12286: PUSH
12287: LD_EXP 22
12291: IN
12292: IFFALSE 12312
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12294: LD_EXP 39
12298: PPUSH
12299: LD_EXP 2
12303: PUSH
12304: LD_STRING Lisa
12306: STR
12307: PPUSH
12308: CALL_OW 38
// if Frank in save_group then
12312: LD_EXP 50
12316: PUSH
12317: LD_EXP 22
12321: IN
12322: IFFALSE 12342
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12324: LD_EXP 50
12328: PPUSH
12329: LD_EXP 2
12333: PUSH
12334: LD_STRING Frank
12336: STR
12337: PPUSH
12338: CALL_OW 38
// if Khatam in save_group then
12342: LD_EXP 40
12346: PUSH
12347: LD_EXP 22
12351: IN
12352: IFFALSE 12372
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
12354: LD_EXP 40
12358: PPUSH
12359: LD_EXP 2
12363: PUSH
12364: LD_STRING Khatam
12366: STR
12367: PPUSH
12368: CALL_OW 38
// if save_others then
12372: LD_EXP 21
12376: IFFALSE 12390
// SaveCharacters ( save_others , 03_others ) ;
12378: LD_EXP 21
12382: PPUSH
12383: LD_STRING 03_others
12385: PPUSH
12386: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) and cornel_saved then
12390: LD_EXP 44
12394: PUSH
12395: LD_EXP 44
12399: PPUSH
12400: CALL_OW 302
12404: AND
12405: PUSH
12406: LD_EXP 26
12410: AND
12411: IFFALSE 12423
// begin ResetFog ;
12413: CALL_OW 335
// DisplayEndingScene ;
12417: CALL 12445 0 0
// end else
12421: GO 12436
// DeleteCharacters ( mission_prefix & Cornel ) ;
12423: LD_EXP 2
12427: PUSH
12428: LD_STRING Cornel
12430: STR
12431: PPUSH
12432: CALL_OW 40
// YouWin ;
12436: CALL_OW 103
// end ;
12440: LD_VAR 0 1
12444: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
12445: LD_INT 0
12447: PPUSH
12448: PPUSH
12449: PPUSH
12450: PPUSH
12451: PPUSH
12452: PPUSH
// InGameOn ;
12453: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12457: LD_INT 208
12459: PPUSH
12460: LD_INT 62
12462: PPUSH
12463: LD_INT 1
12465: PPUSH
12466: LD_INT 10
12468: NEG
12469: PPUSH
12470: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
12474: LD_INT 208
12476: PPUSH
12477: LD_INT 62
12479: PPUSH
12480: LD_INT 1
12482: PPUSH
12483: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
12487: LD_ADDR_VAR 0 3
12491: PUSH
12492: LD_INT 22
12494: PUSH
12495: LD_INT 3
12497: PUSH
12498: EMPTY
12499: LIST
12500: LIST
12501: PUSH
12502: LD_INT 2
12504: PUSH
12505: LD_INT 21
12507: PUSH
12508: LD_INT 2
12510: PUSH
12511: EMPTY
12512: LIST
12513: LIST
12514: PUSH
12515: LD_INT 21
12517: PUSH
12518: LD_INT 1
12520: PUSH
12521: EMPTY
12522: LIST
12523: LIST
12524: PUSH
12525: EMPTY
12526: LIST
12527: LIST
12528: LIST
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: PPUSH
12534: CALL_OW 69
12538: ST_TO_ADDR
// if filter then
12539: LD_VAR 0 3
12543: IFFALSE 12571
// for i in filter do
12545: LD_ADDR_VAR 0 2
12549: PUSH
12550: LD_VAR 0 3
12554: PUSH
12555: FOR_IN
12556: IFFALSE 12569
// RemoveUnit ( i ) ;
12558: LD_VAR 0 2
12562: PPUSH
12563: CALL_OW 64
12567: GO 12555
12569: POP
12570: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
12571: LD_ADDR_VAR 0 3
12575: PUSH
12576: LD_INT 22
12578: PUSH
12579: LD_INT 4
12581: PUSH
12582: EMPTY
12583: LIST
12584: LIST
12585: PUSH
12586: LD_INT 21
12588: PUSH
12589: LD_INT 1
12591: PUSH
12592: EMPTY
12593: LIST
12594: LIST
12595: PUSH
12596: EMPTY
12597: LIST
12598: LIST
12599: PPUSH
12600: CALL_OW 69
12604: ST_TO_ADDR
// if filter then
12605: LD_VAR 0 3
12609: IFFALSE 12640
// for i in filter do
12611: LD_ADDR_VAR 0 2
12615: PUSH
12616: LD_VAR 0 3
12620: PUSH
12621: FOR_IN
12622: IFFALSE 12638
// SetLives ( i , 0 ) ;
12624: LD_VAR 0 2
12628: PPUSH
12629: LD_INT 0
12631: PPUSH
12632: CALL_OW 234
12636: GO 12621
12638: POP
12639: POP
// uc_side := 4 ;
12640: LD_ADDR_OWVAR 20
12644: PUSH
12645: LD_INT 4
12647: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12648: LD_ADDR_VAR 0 4
12652: PUSH
12653: LD_STRING Cornell
12655: PPUSH
12656: LD_INT 0
12658: PPUSH
12659: CALL 474 0 2
12663: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12664: LD_VAR 0 4
12668: PPUSH
12669: LD_INT 208
12671: PPUSH
12672: LD_INT 62
12674: PPUSH
12675: LD_INT 0
12677: PPUSH
12678: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12682: LD_VAR 0 4
12686: PPUSH
12687: LD_INT 100
12689: PPUSH
12690: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12694: LD_INT 3
12696: PPUSH
12697: LD_VAR 0 4
12701: PPUSH
12702: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12706: LD_INT 4
12708: PPUSH
12709: LD_INT 3
12711: PPUSH
12712: LD_INT 1
12714: PPUSH
12715: LD_INT 1
12717: PPUSH
12718: CALL_OW 80
// uc_side := 3 ;
12722: LD_ADDR_OWVAR 20
12726: PUSH
12727: LD_INT 3
12729: ST_TO_ADDR
// uc_nation := 3 ;
12730: LD_ADDR_OWVAR 21
12734: PUSH
12735: LD_INT 3
12737: ST_TO_ADDR
// InitHc ;
12738: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12742: LD_ADDR_VAR 0 5
12746: PUSH
12747: LD_STRING Mikhail
12749: PPUSH
12750: LD_INT 0
12752: PPUSH
12753: CALL 474 0 2
12757: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12758: LD_INT 1
12760: PPUSH
12761: LD_INT 1
12763: PPUSH
12764: LD_INT 0
12766: PPUSH
12767: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12771: LD_ADDR_VAR 0 6
12775: PUSH
12776: LD_VAR 0 6
12780: PUSH
12781: CALL_OW 44
12785: ADD
12786: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12787: LD_ADDR_VAR 0 6
12791: PUSH
12792: LD_VAR 0 6
12796: PUSH
12797: CALL_OW 44
12801: ADD
12802: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12803: LD_INT 2
12805: PPUSH
12806: LD_INT 4
12808: PPUSH
12809: LD_INT 0
12811: PPUSH
12812: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12816: LD_ADDR_VAR 0 6
12820: PUSH
12821: LD_VAR 0 6
12825: PUSH
12826: CALL_OW 44
12830: ADD
12831: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12832: LD_VAR 0 5
12836: PPUSH
12837: LD_INT 17
12839: PPUSH
12840: LD_INT 0
12842: PPUSH
12843: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12847: LD_VAR 0 5
12851: PPUSH
12852: LD_INT 210
12854: PPUSH
12855: LD_INT 63
12857: PPUSH
12858: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12862: LD_VAR 0 5
12866: PPUSH
12867: LD_INT 208
12869: PPUSH
12870: LD_INT 62
12872: PPUSH
12873: CALL_OW 178
// for i in fake_russians do
12877: LD_ADDR_VAR 0 2
12881: PUSH
12882: LD_VAR 0 6
12886: PUSH
12887: FOR_IN
12888: IFFALSE 12966
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12890: LD_VAR 0 2
12894: PPUSH
12895: LD_INT 17
12897: PPUSH
12898: LD_INT 0
12900: PPUSH
12901: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
12905: LD_VAR 0 2
12909: PPUSH
12910: LD_INT 215
12912: PPUSH
12913: LD_INT 67
12915: PPUSH
12916: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
12920: LD_VAR 0 2
12924: PPUSH
12925: LD_INT 208
12927: PPUSH
12928: LD_INT 62
12930: PPUSH
12931: CALL_OW 178
// if GetClass ( i ) = 4 then
12935: LD_VAR 0 2
12939: PPUSH
12940: CALL_OW 257
12944: PUSH
12945: LD_INT 4
12947: EQUAL
12948: IFFALSE 12964
// ComHeal ( i , fake_cornel ) ;
12950: LD_VAR 0 2
12954: PPUSH
12955: LD_VAR 0 4
12959: PPUSH
12960: CALL_OW 128
// end ;
12964: GO 12887
12966: POP
12967: POP
// Wait ( 0 0$01 ) ;
12968: LD_INT 35
12970: PPUSH
12971: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
12975: LD_INT 208
12977: PPUSH
12978: LD_INT 62
12980: PPUSH
12981: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12985: LD_INT 208
12987: PPUSH
12988: LD_INT 62
12990: PPUSH
12991: LD_INT 1
12993: PPUSH
12994: LD_INT 10
12996: NEG
12997: PPUSH
12998: CALL_OW 330
// Wait ( 0 0$15 ) ;
13002: LD_INT 525
13004: PPUSH
13005: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
13009: LD_INT 208
13011: PPUSH
13012: LD_INT 62
13014: PPUSH
13015: LD_INT 1
13017: PPUSH
13018: CALL_OW 331
// ResetFog ;
13022: CALL_OW 335
// InGameOff ;
13026: CALL_OW 9
// end ;
13030: LD_VAR 0 1
13034: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
13035: LD_INT 10
13037: PPUSH
13038: LD_INT 22
13040: PUSH
13041: LD_INT 1
13043: PUSH
13044: EMPTY
13045: LIST
13046: LIST
13047: PPUSH
13048: CALL_OW 70
13052: PUSH
13053: LD_EXP 43
13057: PPUSH
13058: CALL_OW 302
13062: AND
13063: PUSH
13064: LD_INT 22
13066: PUSH
13067: LD_INT 1
13069: PUSH
13070: EMPTY
13071: LIST
13072: LIST
13073: PPUSH
13074: CALL_OW 69
13078: PPUSH
13079: LD_EXP 43
13083: PPUSH
13084: CALL_OW 74
13088: PPUSH
13089: LD_EXP 43
13093: PPUSH
13094: CALL_OW 296
13098: PUSH
13099: LD_INT 30
13101: LESS
13102: OR
13103: IFFALSE 13154
13105: GO 13107
13107: DISABLE
// begin enable ;
13108: ENABLE
// powell_warn := powell_warn + 1 ;
13109: LD_ADDR_EXP 34
13113: PUSH
13114: LD_EXP 34
13118: PUSH
13119: LD_INT 1
13121: PLUS
13122: ST_TO_ADDR
// if powell_warn = 3 then
13123: LD_EXP 34
13127: PUSH
13128: LD_INT 3
13130: EQUAL
13131: IFFALSE 13142
// begin YouLost ( 5 ) ;
13133: LD_STRING 5
13135: PPUSH
13136: CALL_OW 104
// exit ;
13140: GO 13154
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
13142: LD_EXP 45
13146: PPUSH
13147: LD_STRING DWarn-Pow-1
13149: PPUSH
13150: CALL_OW 94
// end ; end_of_file
13154: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
13155: LD_EXP 8
13159: IFFALSE 14484
13161: GO 13163
13163: DISABLE
13164: LD_INT 0
13166: PPUSH
13167: PPUSH
13168: PPUSH
13169: PPUSH
13170: PPUSH
13171: PPUSH
13172: PPUSH
13173: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
13174: LD_EXP 43
13178: PUSH
13179: LD_EXP 44
13183: ADD
13184: PUSH
13185: LD_EXP 6
13189: ADD
13190: PPUSH
13191: LD_INT 250
13193: PPUSH
13194: LD_INT 120
13196: PPUSH
13197: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff [ Bierezov ] ;
13201: LD_ADDR_VAR 0 2
13205: PUSH
13206: LD_EXP 6
13210: PPUSH
13211: LD_INT 25
13213: PUSH
13214: LD_INT 2
13216: PUSH
13217: EMPTY
13218: LIST
13219: LIST
13220: PPUSH
13221: CALL_OW 72
13225: PUSH
13226: LD_EXP 44
13230: PUSH
13231: EMPTY
13232: LIST
13233: DIFF
13234: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) diff has_eng ;
13235: LD_ADDR_VAR 0 3
13239: PUSH
13240: LD_EXP 6
13244: PPUSH
13245: LD_INT 21
13247: PUSH
13248: LD_INT 1
13250: PUSH
13251: EMPTY
13252: LIST
13253: LIST
13254: PPUSH
13255: CALL_OW 72
13259: PUSH
13260: LD_VAR 0 2
13264: DIFF
13265: ST_TO_ADDR
// if not has_eng then
13266: LD_VAR 0 2
13270: NOT
13271: IFFALSE 13354
// begin uc_side := 4 ;
13273: LD_ADDR_OWVAR 20
13277: PUSH
13278: LD_INT 4
13280: ST_TO_ADDR
// uc_nation := 1 ;
13281: LD_ADDR_OWVAR 21
13285: PUSH
13286: LD_INT 1
13288: ST_TO_ADDR
// bc_type := b_depot ;
13289: LD_ADDR_OWVAR 42
13293: PUSH
13294: LD_INT 0
13296: ST_TO_ADDR
// bc_level := 2 ;
13297: LD_ADDR_OWVAR 43
13301: PUSH
13302: LD_INT 2
13304: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13305: LD_ADDR_VAR 0 4
13309: PUSH
13310: LD_INT 264
13312: PPUSH
13313: LD_INT 120
13315: PPUSH
13316: LD_INT 4
13318: PPUSH
13319: CALL_OW 47
13323: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13324: LD_INT 264
13326: PPUSH
13327: LD_INT 120
13329: PPUSH
13330: LD_INT 4
13332: PPUSH
13333: LD_INT 10
13335: NEG
13336: PPUSH
13337: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13341: LD_INT 264
13343: PPUSH
13344: LD_INT 120
13346: PPUSH
13347: LD_INT 4
13349: PPUSH
13350: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13354: LD_INT 35
13356: PPUSH
13357: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
13361: LD_EXP 43
13365: PPUSH
13366: LD_INT 10
13368: PPUSH
13369: CALL_OW 308
13373: IFFALSE 13354
// if has_eng and not dep then
13375: LD_VAR 0 2
13379: PUSH
13380: LD_VAR 0 4
13384: NOT
13385: AND
13386: IFFALSE 13536
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
13388: LD_VAR 0 2
13392: PPUSH
13393: LD_INT 0
13395: PPUSH
13396: LD_INT 264
13398: PPUSH
13399: LD_INT 120
13401: PPUSH
13402: LD_INT 4
13404: PPUSH
13405: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
13409: LD_INT 35
13411: PPUSH
13412: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
13416: LD_INT 22
13418: PUSH
13419: LD_INT 4
13421: PUSH
13422: EMPTY
13423: LIST
13424: LIST
13425: PUSH
13426: LD_INT 30
13428: PUSH
13429: LD_INT 0
13431: PUSH
13432: EMPTY
13433: LIST
13434: LIST
13435: PUSH
13436: EMPTY
13437: LIST
13438: LIST
13439: PPUSH
13440: CALL_OW 69
13444: IFFALSE 13409
// ComMoveXY ( filter , 264 , 120 ) ;
13446: LD_VAR 0 3
13450: PPUSH
13451: LD_INT 264
13453: PPUSH
13454: LD_INT 120
13456: PPUSH
13457: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
13461: LD_INT 35
13463: PPUSH
13464: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
13468: LD_INT 22
13470: PUSH
13471: LD_INT 4
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: PUSH
13478: LD_INT 30
13480: PUSH
13481: LD_INT 0
13483: PUSH
13484: EMPTY
13485: LIST
13486: LIST
13487: PUSH
13488: LD_INT 3
13490: PUSH
13491: LD_INT 57
13493: PUSH
13494: EMPTY
13495: LIST
13496: PUSH
13497: EMPTY
13498: LIST
13499: LIST
13500: PUSH
13501: EMPTY
13502: LIST
13503: LIST
13504: LIST
13505: PPUSH
13506: CALL_OW 69
13510: IFFALSE 13461
// ComMoveXY ( filter , 247 , 113 ) ;
13512: LD_VAR 0 3
13516: PPUSH
13517: LD_INT 247
13519: PPUSH
13520: LD_INT 113
13522: PPUSH
13523: CALL_OW 111
// Wait ( 0 0$2 ) ;
13527: LD_INT 70
13529: PPUSH
13530: CALL_OW 67
// end else
13534: GO 13548
// begin SetSide ( dep , 4 ) ;
13536: LD_VAR 0 4
13540: PPUSH
13541: LD_INT 4
13543: PPUSH
13544: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
13548: LD_ADDR_VAR 0 4
13552: PUSH
13553: LD_INT 22
13555: PUSH
13556: LD_INT 4
13558: PUSH
13559: EMPTY
13560: LIST
13561: LIST
13562: PUSH
13563: LD_INT 30
13565: PUSH
13566: LD_INT 0
13568: PUSH
13569: EMPTY
13570: LIST
13571: LIST
13572: PUSH
13573: EMPTY
13574: LIST
13575: LIST
13576: PPUSH
13577: CALL_OW 69
13581: PUSH
13582: LD_INT 1
13584: ARRAY
13585: ST_TO_ADDR
// for i = 1 to 2 do
13586: LD_ADDR_VAR 0 1
13590: PUSH
13591: DOUBLE
13592: LD_INT 1
13594: DEC
13595: ST_TO_ADDR
13596: LD_INT 2
13598: PUSH
13599: FOR_TO
13600: IFFALSE 13695
// begin ComEnterUnit ( filter [ 1 ] , dep ) ;
13602: LD_VAR 0 3
13606: PUSH
13607: LD_INT 1
13609: ARRAY
13610: PPUSH
13611: LD_VAR 0 4
13615: PPUSH
13616: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 2 ) ;
13620: LD_VAR 0 3
13624: PUSH
13625: LD_INT 1
13627: ARRAY
13628: PPUSH
13629: LD_INT 2
13631: PPUSH
13632: CALL_OW 183
// AddComExitBuilding ( filter [ 1 ] ) ;
13636: LD_VAR 0 3
13640: PUSH
13641: LD_INT 1
13643: ARRAY
13644: PPUSH
13645: CALL_OW 182
// repeat wait ( 0 0$1 ) ;
13649: LD_INT 35
13651: PPUSH
13652: CALL_OW 67
// until GetClass ( filter [ 1 ] ) = 2 ;
13656: LD_VAR 0 3
13660: PUSH
13661: LD_INT 1
13663: ARRAY
13664: PPUSH
13665: CALL_OW 257
13669: PUSH
13670: LD_INT 2
13672: EQUAL
13673: IFFALSE 13649
// filter := Delete ( filter , 1 ) ;
13675: LD_ADDR_VAR 0 3
13679: PUSH
13680: LD_VAR 0 3
13684: PPUSH
13685: LD_INT 1
13687: PPUSH
13688: CALL_OW 3
13692: ST_TO_ADDR
// end ;
13693: GO 13599
13695: POP
13696: POP
// if IsInUnit ( Cornel ) then
13697: LD_EXP 43
13701: PPUSH
13702: CALL_OW 310
13706: IFFALSE 13789
// begin cargo := IsInUnit ( Cornel ) ;
13708: LD_ADDR_VAR 0 7
13712: PUSH
13713: LD_EXP 43
13717: PPUSH
13718: CALL_OW 310
13722: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13723: LD_VAR 0 7
13727: PPUSH
13728: LD_INT 1
13730: PPUSH
13731: CALL_OW 289
13735: IFFALSE 13751
// ComGive ( Cornel , dep ) ;
13737: LD_EXP 43
13741: PPUSH
13742: LD_VAR 0 4
13746: PPUSH
13747: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13751: LD_EXP 43
13755: PPUSH
13756: LD_INT 235
13758: PPUSH
13759: LD_INT 122
13761: PPUSH
13762: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13766: LD_EXP 43
13770: PPUSH
13771: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13775: LD_EXP 43
13779: PPUSH
13780: LD_VAR 0 4
13784: PPUSH
13785: CALL_OW 180
// end ; if Bierezov then
13789: LD_EXP 44
13793: IFFALSE 13809
// ComEnterUnit ( Bierezov , dep ) ;
13795: LD_EXP 44
13799: PPUSH
13800: LD_VAR 0 4
13804: PPUSH
13805: CALL_OW 120
// has_eng := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) diff [ Bierezov ] ;
13809: LD_ADDR_VAR 0 2
13813: PUSH
13814: LD_INT 22
13816: PUSH
13817: LD_INT 4
13819: PUSH
13820: EMPTY
13821: LIST
13822: LIST
13823: PUSH
13824: LD_INT 25
13826: PUSH
13827: LD_INT 2
13829: PUSH
13830: EMPTY
13831: LIST
13832: LIST
13833: PUSH
13834: EMPTY
13835: LIST
13836: LIST
13837: PPUSH
13838: CALL_OW 69
13842: PUSH
13843: LD_EXP 44
13847: PUSH
13848: EMPTY
13849: LIST
13850: DIFF
13851: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13852: LD_INT 35
13854: PPUSH
13855: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13859: LD_ADDR_VAR 0 6
13863: PUSH
13864: LD_INT 10
13866: PPUSH
13867: CALL_OW 435
13871: ST_TO_ADDR
// if crates then
13872: LD_VAR 0 6
13876: IFFALSE 13905
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
13878: LD_VAR 0 2
13882: PPUSH
13883: LD_VAR 0 6
13887: PUSH
13888: LD_INT 1
13890: ARRAY
13891: PPUSH
13892: LD_VAR 0 6
13896: PUSH
13897: LD_INT 2
13899: ARRAY
13900: PPUSH
13901: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
13905: LD_VAR 0 4
13909: PPUSH
13910: CALL_OW 274
13914: PPUSH
13915: LD_INT 1
13917: PPUSH
13918: CALL_OW 275
13922: PUSH
13923: LD_INT 40
13925: GREATEREQUAL
13926: IFFALSE 13852
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
13928: LD_ADDR_VAR 0 5
13932: PUSH
13933: LD_INT 4
13935: PUSH
13936: LD_INT 256
13938: PUSH
13939: LD_INT 111
13941: PUSH
13942: LD_INT 2
13944: PUSH
13945: EMPTY
13946: LIST
13947: LIST
13948: LIST
13949: LIST
13950: PUSH
13951: LD_INT 31
13953: PUSH
13954: LD_INT 243
13956: PUSH
13957: LD_INT 112
13959: PUSH
13960: LD_INT 2
13962: PUSH
13963: EMPTY
13964: LIST
13965: LIST
13966: LIST
13967: LIST
13968: PUSH
13969: EMPTY
13970: LIST
13971: LIST
13972: ST_TO_ADDR
// for i in blist do
13973: LD_ADDR_VAR 0 1
13977: PUSH
13978: LD_VAR 0 5
13982: PUSH
13983: FOR_IN
13984: IFFALSE 14033
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
13986: LD_VAR 0 2
13990: PPUSH
13991: LD_VAR 0 1
13995: PUSH
13996: LD_INT 1
13998: ARRAY
13999: PPUSH
14000: LD_VAR 0 1
14004: PUSH
14005: LD_INT 2
14007: ARRAY
14008: PPUSH
14009: LD_VAR 0 1
14013: PUSH
14014: LD_INT 3
14016: ARRAY
14017: PPUSH
14018: LD_VAR 0 1
14022: PUSH
14023: LD_INT 4
14025: ARRAY
14026: PPUSH
14027: CALL_OW 205
14031: GO 13983
14033: POP
14034: POP
// repeat wait ( 0 0$01 ) ;
14035: LD_INT 35
14037: PPUSH
14038: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
14042: LD_INT 22
14044: PUSH
14045: LD_INT 4
14047: PUSH
14048: EMPTY
14049: LIST
14050: LIST
14051: PUSH
14052: LD_INT 30
14054: PUSH
14055: LD_INT 4
14057: PUSH
14058: EMPTY
14059: LIST
14060: LIST
14061: PUSH
14062: LD_INT 3
14064: PUSH
14065: LD_INT 57
14067: PUSH
14068: EMPTY
14069: LIST
14070: PUSH
14071: EMPTY
14072: LIST
14073: LIST
14074: PUSH
14075: EMPTY
14076: LIST
14077: LIST
14078: LIST
14079: PPUSH
14080: CALL_OW 69
14084: IFFALSE 14035
// AddComEnterUnit ( filter , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14086: LD_VAR 0 3
14090: PPUSH
14091: LD_INT 22
14093: PUSH
14094: LD_INT 4
14096: PUSH
14097: EMPTY
14098: LIST
14099: LIST
14100: PUSH
14101: LD_INT 30
14103: PUSH
14104: LD_INT 4
14106: PUSH
14107: EMPTY
14108: LIST
14109: LIST
14110: PUSH
14111: EMPTY
14112: LIST
14113: LIST
14114: PPUSH
14115: CALL_OW 69
14119: PUSH
14120: LD_INT 1
14122: ARRAY
14123: PPUSH
14124: CALL_OW 180
// AddComChangeProfession ( filter , 1 ) ;
14128: LD_VAR 0 3
14132: PPUSH
14133: LD_INT 1
14135: PPUSH
14136: CALL_OW 183
// repeat wait ( 0 0$01 ) ;
14140: LD_INT 35
14142: PPUSH
14143: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
14147: LD_INT 22
14149: PUSH
14150: LD_INT 4
14152: PUSH
14153: EMPTY
14154: LIST
14155: LIST
14156: PUSH
14157: LD_INT 30
14159: PUSH
14160: LD_INT 31
14162: PUSH
14163: EMPTY
14164: LIST
14165: LIST
14166: PUSH
14167: LD_INT 3
14169: PUSH
14170: LD_INT 57
14172: PUSH
14173: EMPTY
14174: LIST
14175: PUSH
14176: EMPTY
14177: LIST
14178: LIST
14179: PUSH
14180: EMPTY
14181: LIST
14182: LIST
14183: LIST
14184: PPUSH
14185: CALL_OW 69
14189: IFFALSE 14140
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
14191: LD_ADDR_VAR 0 8
14195: PUSH
14196: LD_EXP 6
14200: PPUSH
14201: LD_INT 25
14203: PUSH
14204: LD_INT 1
14206: PUSH
14207: EMPTY
14208: LIST
14209: LIST
14210: PPUSH
14211: CALL_OW 72
14215: ST_TO_ADDR
// ComExitBuilding ( sol [ 1 ] ) ;
14216: LD_VAR 0 8
14220: PUSH
14221: LD_INT 1
14223: ARRAY
14224: PPUSH
14225: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
14229: LD_VAR 0 8
14233: PUSH
14234: LD_INT 1
14236: ARRAY
14237: PPUSH
14238: LD_INT 22
14240: PUSH
14241: LD_INT 4
14243: PUSH
14244: EMPTY
14245: LIST
14246: LIST
14247: PUSH
14248: LD_INT 30
14250: PUSH
14251: LD_INT 31
14253: PUSH
14254: EMPTY
14255: LIST
14256: LIST
14257: PUSH
14258: EMPTY
14259: LIST
14260: LIST
14261: PPUSH
14262: CALL_OW 69
14266: PUSH
14267: LD_INT 1
14269: ARRAY
14270: PPUSH
14271: CALL_OW 180
// ComEnterUnit ( has_eng , dep ) ;
14275: LD_VAR 0 2
14279: PPUSH
14280: LD_VAR 0 4
14284: PPUSH
14285: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
14289: LD_INT 35
14291: PPUSH
14292: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14296: LD_ADDR_VAR 0 3
14300: PUSH
14301: LD_INT 22
14303: PUSH
14304: LD_INT 4
14306: PUSH
14307: EMPTY
14308: LIST
14309: LIST
14310: PUSH
14311: LD_INT 21
14313: PUSH
14314: LD_INT 3
14316: PUSH
14317: EMPTY
14318: LIST
14319: LIST
14320: PUSH
14321: LD_INT 3
14323: PUSH
14324: LD_INT 24
14326: PUSH
14327: LD_INT 1000
14329: PUSH
14330: EMPTY
14331: LIST
14332: LIST
14333: PUSH
14334: EMPTY
14335: LIST
14336: LIST
14337: PUSH
14338: EMPTY
14339: LIST
14340: LIST
14341: LIST
14342: PPUSH
14343: CALL_OW 69
14347: ST_TO_ADDR
// if filter and has_eng then
14348: LD_VAR 0 3
14352: PUSH
14353: LD_VAR 0 2
14357: AND
14358: IFFALSE 14424
// begin for i in has_eng do
14360: LD_ADDR_VAR 0 1
14364: PUSH
14365: LD_VAR 0 2
14369: PUSH
14370: FOR_IN
14371: IFFALSE 14420
// begin if IsInUnit ( i ) then
14373: LD_VAR 0 1
14377: PPUSH
14378: CALL_OW 310
14382: IFFALSE 14393
// ComExitBuilding ( i ) ;
14384: LD_VAR 0 1
14388: PPUSH
14389: CALL_OW 122
// Wait ( 3 ) ;
14393: LD_INT 3
14395: PPUSH
14396: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
14400: LD_VAR 0 1
14404: PPUSH
14405: LD_VAR 0 3
14409: PUSH
14410: LD_INT 1
14412: ARRAY
14413: PPUSH
14414: CALL_OW 130
// end ;
14418: GO 14370
14420: POP
14421: POP
// end else
14422: GO 14478
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
14424: LD_VAR 0 2
14428: PUSH
14429: LD_VAR 0 2
14433: PPUSH
14434: LD_INT 56
14436: PUSH
14437: EMPTY
14438: LIST
14439: PPUSH
14440: CALL_OW 72
14444: AND
14445: IFFALSE 14478
// for i in has_eng do
14447: LD_ADDR_VAR 0 1
14451: PUSH
14452: LD_VAR 0 2
14456: PUSH
14457: FOR_IN
14458: IFFALSE 14476
// ComEnterUnit ( i , dep ) ;
14460: LD_VAR 0 1
14464: PPUSH
14465: LD_VAR 0 4
14469: PPUSH
14470: CALL_OW 120
14474: GO 14457
14476: POP
14477: POP
// until cornel_prepared ;
14478: LD_EXP 11
14482: IFFALSE 14289
// end ;
14484: PPOPN 8
14486: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
14487: LD_EXP 11
14491: IFFALSE 14840
14493: GO 14495
14495: DISABLE
14496: LD_INT 0
14498: PPUSH
14499: PPUSH
14500: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
14501: LD_ADDR_VAR 0 2
14505: PUSH
14506: LD_INT 22
14508: PUSH
14509: LD_INT 4
14511: PUSH
14512: EMPTY
14513: LIST
14514: LIST
14515: PUSH
14516: LD_INT 30
14518: PUSH
14519: LD_INT 4
14521: PUSH
14522: EMPTY
14523: LIST
14524: LIST
14525: PUSH
14526: EMPTY
14527: LIST
14528: LIST
14529: PPUSH
14530: CALL_OW 69
14534: PUSH
14535: LD_INT 1
14537: ARRAY
14538: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
14539: LD_EXP 6
14543: PPUSH
14544: CALL_OW 122
// Wait ( 0 0$03 ) ;
14548: LD_INT 105
14550: PPUSH
14551: CALL_OW 67
// for i in cornel_units do
14555: LD_ADDR_VAR 0 1
14559: PUSH
14560: LD_EXP 6
14564: PUSH
14565: FOR_IN
14566: IFFALSE 14642
// begin if GetClass ( i ) in [ 2 , 3 ] then
14568: LD_VAR 0 1
14572: PPUSH
14573: CALL_OW 257
14577: PUSH
14578: LD_INT 2
14580: PUSH
14581: LD_INT 3
14583: PUSH
14584: EMPTY
14585: LIST
14586: LIST
14587: IN
14588: IFFALSE 14625
// begin ComEnterUnit ( i , arm ) ;
14590: LD_VAR 0 1
14594: PPUSH
14595: LD_VAR 0 2
14599: PPUSH
14600: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
14604: LD_VAR 0 1
14608: PPUSH
14609: LD_INT 1
14611: PPUSH
14612: CALL_OW 183
// AddComExitBuilding ( i ) ;
14616: LD_VAR 0 1
14620: PPUSH
14621: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
14625: LD_VAR 0 1
14629: PPUSH
14630: LD_INT 257
14632: PPUSH
14633: LD_INT 121
14635: PPUSH
14636: CALL_OW 171
// end ;
14640: GO 14565
14642: POP
14643: POP
// Wait ( 1 1$00 ) ;
14644: LD_INT 2100
14646: PPUSH
14647: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
14651: LD_ADDR_VAR 0 3
14655: PUSH
14656: LD_EXP 43
14660: PUSH
14661: LD_EXP 44
14665: ADD
14666: PUSH
14667: LD_EXP 6
14671: ADD
14672: PUSH
14673: LD_EXP 6
14677: PPUSH
14678: LD_INT 21
14680: PUSH
14681: LD_INT 2
14683: PUSH
14684: EMPTY
14685: LIST
14686: LIST
14687: PPUSH
14688: CALL_OW 72
14692: DIFF
14693: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
14694: LD_VAR 0 3
14698: PPUSH
14699: LD_INT 248
14701: PPUSH
14702: LD_INT 85
14704: PPUSH
14705: CALL_OW 111
// AddComHold ( filter ) ;
14709: LD_VAR 0 3
14713: PPUSH
14714: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
14718: LD_INT 35
14720: PPUSH
14721: CALL_OW 67
// until cornel_attack ;
14725: LD_EXP 9
14729: IFFALSE 14718
// ComAgressiveMove ( filter , 209 , 63 ) ;
14731: LD_VAR 0 3
14735: PPUSH
14736: LD_INT 209
14738: PPUSH
14739: LD_INT 63
14741: PPUSH
14742: CALL_OW 114
// if Bierezov then
14746: LD_EXP 44
14750: IFFALSE 14840
// begin filter := filter diff Bierezov ;
14752: LD_ADDR_VAR 0 3
14756: PUSH
14757: LD_VAR 0 3
14761: PUSH
14762: LD_EXP 44
14766: DIFF
14767: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
14768: LD_EXP 44
14772: PPUSH
14773: LD_INT 6
14775: PPUSH
14776: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
14780: LD_EXP 44
14784: PPUSH
14785: LD_INT 235
14787: PPUSH
14788: LD_INT 60
14790: PPUSH
14791: CALL_OW 111
// AddComHold ( Bierezov ) ;
14795: LD_EXP 44
14799: PPUSH
14800: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
14804: LD_EXP 44
14808: PPUSH
14809: LD_INT 350
14811: PPUSH
14812: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
14816: LD_EXP 44
14820: PPUSH
14821: LD_INT 198
14823: PPUSH
14824: LD_INT 28
14826: PPUSH
14827: CALL_OW 171
// AddComHold ( Bierezov ) ;
14831: LD_EXP 44
14835: PPUSH
14836: CALL_OW 200
// end ; end ; end_of_file
14840: PPOPN 3
14842: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
14843: LD_EXP 52
14847: PUSH
14848: LD_EXP 30
14852: NOT
14853: AND
14854: PUSH
14855: LD_EXP 31
14859: NOT
14860: AND
14861: IFFALSE 15311
14863: GO 14865
14865: DISABLE
14866: LD_INT 0
14868: PPUSH
14869: PPUSH
14870: PPUSH
14871: PPUSH
// begin enable ;
14872: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14873: LD_ADDR_VAR 0 4
14877: PUSH
14878: LD_INT 81
14880: PUSH
14881: LD_INT 3
14883: PUSH
14884: EMPTY
14885: LIST
14886: LIST
14887: PPUSH
14888: CALL_OW 69
14892: ST_TO_ADDR
// for i = 1 to ru_patrol do
14893: LD_ADDR_VAR 0 2
14897: PUSH
14898: DOUBLE
14899: LD_INT 1
14901: DEC
14902: ST_TO_ADDR
14903: LD_EXP 52
14907: PUSH
14908: FOR_TO
14909: IFFALSE 15309
// begin un := ru_patrol [ i ] ;
14911: LD_ADDR_VAR 0 1
14915: PUSH
14916: LD_EXP 52
14920: PUSH
14921: LD_VAR 0 2
14925: ARRAY
14926: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14927: LD_VAR 0 1
14931: PPUSH
14932: LD_INT 13
14934: PPUSH
14935: CALL_OW 308
14939: IFFALSE 15044
// begin if not ru_alert then
14941: LD_EXP 59
14945: NOT
14946: IFFALSE 14956
// ru_alert := true ;
14948: LD_ADDR_EXP 59
14952: PUSH
14953: LD_INT 1
14955: ST_TO_ADDR
// if not See ( 1 , un ) then
14956: LD_INT 1
14958: PPUSH
14959: LD_VAR 0 1
14963: PPUSH
14964: CALL_OW 292
14968: NOT
14969: IFFALSE 14983
// SetLives ( un , 1000 ) ;
14971: LD_VAR 0 1
14975: PPUSH
14976: LD_INT 1000
14978: PPUSH
14979: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
14983: LD_ADDR_EXP 52
14987: PUSH
14988: LD_EXP 52
14992: PUSH
14993: LD_VAR 0 1
14997: DIFF
14998: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
14999: LD_VAR 0 1
15003: PPUSH
15004: LD_INT 22
15006: PUSH
15007: LD_INT 3
15009: PUSH
15010: EMPTY
15011: LIST
15012: LIST
15013: PUSH
15014: LD_INT 30
15016: PUSH
15017: LD_INT 4
15019: PUSH
15020: EMPTY
15021: LIST
15022: LIST
15023: PUSH
15024: EMPTY
15025: LIST
15026: LIST
15027: PPUSH
15028: CALL_OW 69
15032: PPUSH
15033: CALL 1047 0 1
15037: PPUSH
15038: CALL_OW 120
// continue ;
15042: GO 14908
// end ; if IsOk ( un ) and not HasTask ( un ) then
15044: LD_VAR 0 1
15048: PPUSH
15049: CALL_OW 302
15053: PUSH
15054: LD_VAR 0 1
15058: PPUSH
15059: CALL_OW 314
15063: NOT
15064: AND
15065: IFFALSE 15158
// begin for j = 1 to ru_firepoints_south [ i ] do
15067: LD_ADDR_VAR 0 3
15071: PUSH
15072: DOUBLE
15073: LD_INT 1
15075: DEC
15076: ST_TO_ADDR
15077: LD_EXP 58
15081: PUSH
15082: LD_VAR 0 2
15086: ARRAY
15087: PUSH
15088: FOR_TO
15089: IFFALSE 15156
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
15091: LD_VAR 0 1
15095: PPUSH
15096: LD_EXP 58
15100: PUSH
15101: LD_VAR 0 2
15105: ARRAY
15106: PUSH
15107: LD_VAR 0 3
15111: ARRAY
15112: PUSH
15113: LD_INT 1
15115: ARRAY
15116: PPUSH
15117: LD_EXP 58
15121: PUSH
15122: LD_VAR 0 2
15126: ARRAY
15127: PUSH
15128: LD_VAR 0 3
15132: ARRAY
15133: PUSH
15134: LD_INT 2
15136: ARRAY
15137: PPUSH
15138: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
15142: LD_VAR 0 1
15146: PPUSH
15147: LD_INT 70
15149: PPUSH
15150: CALL_OW 202
// end ;
15154: GO 15088
15156: POP
15157: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15158: LD_VAR 0 1
15162: PPUSH
15163: CALL_OW 256
15167: PUSH
15168: LD_INT 700
15170: LESS
15171: PUSH
15172: LD_VAR 0 1
15176: PPUSH
15177: LD_INT 13
15179: PPUSH
15180: CALL_OW 308
15184: NOT
15185: AND
15186: IFFALSE 15238
// begin ComMoveToArea ( un , retreatArea ) ;
15188: LD_VAR 0 1
15192: PPUSH
15193: LD_INT 13
15195: PPUSH
15196: CALL_OW 113
// if not ru_alert_xy then
15200: LD_EXP 60
15204: NOT
15205: IFFALSE 15236
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
15207: LD_ADDR_EXP 60
15211: PUSH
15212: LD_VAR 0 1
15216: PPUSH
15217: CALL_OW 250
15221: PUSH
15222: LD_VAR 0 1
15226: PPUSH
15227: CALL_OW 251
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: ST_TO_ADDR
// end else
15236: GO 15307
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15238: LD_VAR 0 1
15242: PPUSH
15243: LD_VAR 0 4
15247: PPUSH
15248: LD_VAR 0 1
15252: PPUSH
15253: CALL_OW 74
15257: PPUSH
15258: CALL_OW 296
15262: PUSH
15263: LD_INT 9
15265: LESS
15266: PUSH
15267: LD_VAR 0 1
15271: PPUSH
15272: CALL_OW 256
15276: PUSH
15277: LD_INT 500
15279: GREATER
15280: AND
15281: IFFALSE 15307
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15283: LD_VAR 0 1
15287: PPUSH
15288: LD_VAR 0 4
15292: PPUSH
15293: LD_VAR 0 1
15297: PPUSH
15298: CALL_OW 74
15302: PPUSH
15303: CALL_OW 115
// end ;
15307: GO 14908
15309: POP
15310: POP
// end ;
15311: PPOPN 4
15313: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
15314: LD_EXP 59
15318: PUSH
15319: LD_EXP 60
15323: AND
15324: PUSH
15325: LD_EXP 30
15329: NOT
15330: AND
15331: PUSH
15332: LD_EXP 31
15336: NOT
15337: AND
15338: IFFALSE 15548
15340: GO 15342
15342: DISABLE
15343: LD_INT 0
15345: PPUSH
15346: PPUSH
// begin enable ;
15347: ENABLE
// if not ru_vehicles then
15348: LD_EXP 55
15352: NOT
15353: IFFALSE 15357
// exit ;
15355: GO 15548
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15357: LD_ADDR_VAR 0 2
15361: PUSH
15362: LD_INT 81
15364: PUSH
15365: LD_INT 3
15367: PUSH
15368: EMPTY
15369: LIST
15370: LIST
15371: PPUSH
15372: CALL_OW 69
15376: ST_TO_ADDR
// if ru_vehicles then
15377: LD_EXP 55
15381: IFFALSE 15548
// begin for i in ru_vehicles do
15383: LD_ADDR_VAR 0 1
15387: PUSH
15388: LD_EXP 55
15392: PUSH
15393: FOR_IN
15394: IFFALSE 15546
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
15396: LD_VAR 0 1
15400: PPUSH
15401: CALL_OW 302
15405: PUSH
15406: LD_VAR 0 1
15410: PPUSH
15411: LD_VAR 0 2
15415: PPUSH
15416: LD_VAR 0 1
15420: PPUSH
15421: CALL_OW 74
15425: PPUSH
15426: CALL_OW 296
15430: PUSH
15431: LD_INT 9
15433: LESS
15434: AND
15435: IFFALSE 15461
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15437: LD_VAR 0 1
15441: PPUSH
15442: LD_VAR 0 2
15446: PPUSH
15447: LD_VAR 0 1
15451: PPUSH
15452: CALL_OW 74
15456: PPUSH
15457: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
15461: LD_VAR 0 1
15465: PPUSH
15466: CALL_OW 314
15470: NOT
15471: PUSH
15472: LD_VAR 0 1
15476: PPUSH
15477: CALL_OW 302
15481: AND
15482: PUSH
15483: LD_VAR 0 1
15487: PPUSH
15488: LD_EXP 60
15492: PUSH
15493: LD_INT 1
15495: ARRAY
15496: PPUSH
15497: LD_EXP 60
15501: PUSH
15502: LD_INT 2
15504: ARRAY
15505: PPUSH
15506: CALL_OW 297
15510: PUSH
15511: LD_INT 10
15513: GREATER
15514: AND
15515: IFFALSE 15544
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
15517: LD_VAR 0 1
15521: PPUSH
15522: LD_EXP 60
15526: PUSH
15527: LD_INT 1
15529: ARRAY
15530: PPUSH
15531: LD_EXP 60
15535: PUSH
15536: LD_INT 2
15538: ARRAY
15539: PPUSH
15540: CALL_OW 114
// end ;
15544: GO 15393
15546: POP
15547: POP
// end ; end ;
15548: PPOPN 2
15550: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
15551: LD_EXP 60
15555: PUSH
15556: LD_EXP 59
15560: AND
15561: PUSH
15562: LD_INT 3
15564: PPUSH
15565: CALL_OW 463
15569: NOT
15570: AND
15571: PUSH
15572: LD_EXP 30
15576: NOT
15577: AND
15578: PUSH
15579: LD_EXP 31
15583: NOT
15584: AND
15585: IFFALSE 15680
15587: GO 15589
15589: DISABLE
15590: LD_INT 0
15592: PPUSH
// begin enable ;
15593: ENABLE
// ru_alert_xy := false ;
15594: LD_ADDR_EXP 60
15598: PUSH
15599: LD_INT 0
15601: ST_TO_ADDR
// ru_alert := false ;
15602: LD_ADDR_EXP 59
15606: PUSH
15607: LD_INT 0
15609: ST_TO_ADDR
// if ru_vehicles then
15610: LD_EXP 55
15614: IFFALSE 15680
// for i in ru_vehicles do
15616: LD_ADDR_VAR 0 1
15620: PUSH
15621: LD_EXP 55
15625: PUSH
15626: FOR_IN
15627: IFFALSE 15678
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
15629: LD_VAR 0 1
15633: PPUSH
15634: CALL_OW 302
15638: PUSH
15639: LD_VAR 0 1
15643: PPUSH
15644: LD_INT 89
15646: PPUSH
15647: LD_INT 36
15649: PPUSH
15650: CALL_OW 297
15654: PUSH
15655: LD_INT 10
15657: GREATER
15658: AND
15659: IFFALSE 15676
// ComMoveXY ( i , 89 , 36 ) ;
15661: LD_VAR 0 1
15665: PPUSH
15666: LD_INT 89
15668: PPUSH
15669: LD_INT 36
15671: PPUSH
15672: CALL_OW 111
15676: GO 15626
15678: POP
15679: POP
// end ;
15680: PPOPN 1
15682: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
15683: LD_EXP 54
15687: PUSH
15688: LD_EXP 30
15692: NOT
15693: AND
15694: PUSH
15695: LD_EXP 31
15699: NOT
15700: AND
15701: IFFALSE 15985
15703: GO 15705
15705: DISABLE
15706: LD_INT 0
15708: PPUSH
15709: PPUSH
15710: PPUSH
// begin enable ;
15711: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15712: LD_ADDR_VAR 0 3
15716: PUSH
15717: LD_INT 81
15719: PUSH
15720: LD_INT 3
15722: PUSH
15723: EMPTY
15724: LIST
15725: LIST
15726: PPUSH
15727: CALL_OW 69
15731: ST_TO_ADDR
// for i = 1 to ru_forest do
15732: LD_ADDR_VAR 0 1
15736: PUSH
15737: DOUBLE
15738: LD_INT 1
15740: DEC
15741: ST_TO_ADDR
15742: LD_EXP 54
15746: PUSH
15747: FOR_TO
15748: IFFALSE 15983
// begin un := ru_forest [ i ] ;
15750: LD_ADDR_VAR 0 2
15754: PUSH
15755: LD_EXP 54
15759: PUSH
15760: LD_VAR 0 1
15764: ARRAY
15765: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15766: LD_VAR 0 2
15770: PPUSH
15771: LD_INT 13
15773: PPUSH
15774: CALL_OW 308
15778: IFFALSE 15868
// begin if not See ( 1 , un ) then
15780: LD_INT 1
15782: PPUSH
15783: LD_VAR 0 2
15787: PPUSH
15788: CALL_OW 292
15792: NOT
15793: IFFALSE 15807
// SetLives ( un , 1000 ) ;
15795: LD_VAR 0 2
15799: PPUSH
15800: LD_INT 1000
15802: PPUSH
15803: CALL_OW 234
// ru_forest := ru_forest diff un ;
15807: LD_ADDR_EXP 54
15811: PUSH
15812: LD_EXP 54
15816: PUSH
15817: LD_VAR 0 2
15821: DIFF
15822: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15823: LD_VAR 0 2
15827: PPUSH
15828: LD_INT 22
15830: PUSH
15831: LD_INT 3
15833: PUSH
15834: EMPTY
15835: LIST
15836: LIST
15837: PUSH
15838: LD_INT 30
15840: PUSH
15841: LD_INT 4
15843: PUSH
15844: EMPTY
15845: LIST
15846: LIST
15847: PUSH
15848: EMPTY
15849: LIST
15850: LIST
15851: PPUSH
15852: CALL_OW 69
15856: PPUSH
15857: CALL 1047 0 1
15861: PPUSH
15862: CALL_OW 120
// continue ;
15866: GO 15747
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15868: LD_VAR 0 2
15872: PPUSH
15873: CALL_OW 256
15877: PUSH
15878: LD_INT 700
15880: LESS
15881: PUSH
15882: LD_VAR 0 2
15886: PPUSH
15887: LD_INT 13
15889: PPUSH
15890: CALL_OW 308
15894: NOT
15895: AND
15896: IFFALSE 15912
// ComMoveToArea ( un , retreatArea ) else
15898: LD_VAR 0 2
15902: PPUSH
15903: LD_INT 13
15905: PPUSH
15906: CALL_OW 113
15910: GO 15981
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15912: LD_VAR 0 2
15916: PPUSH
15917: LD_VAR 0 3
15921: PPUSH
15922: LD_VAR 0 2
15926: PPUSH
15927: CALL_OW 74
15931: PPUSH
15932: CALL_OW 296
15936: PUSH
15937: LD_INT 9
15939: LESS
15940: PUSH
15941: LD_VAR 0 2
15945: PPUSH
15946: CALL_OW 256
15950: PUSH
15951: LD_INT 500
15953: GREATER
15954: AND
15955: IFFALSE 15981
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15957: LD_VAR 0 2
15961: PPUSH
15962: LD_VAR 0 3
15966: PPUSH
15967: LD_VAR 0 2
15971: PPUSH
15972: CALL_OW 74
15976: PPUSH
15977: CALL_OW 115
// end ;
15981: GO 15747
15983: POP
15984: POP
// end ;
15985: PPOPN 3
15987: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
15988: LD_EXP 31
15992: NOT
15993: IFFALSE 16114
15995: GO 15997
15997: DISABLE
15998: LD_INT 0
16000: PPUSH
16001: PPUSH
// begin enable ;
16002: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
16003: LD_ADDR_VAR 0 2
16007: PUSH
16008: LD_INT 22
16010: PUSH
16011: LD_INT 3
16013: PUSH
16014: EMPTY
16015: LIST
16016: LIST
16017: PUSH
16018: LD_INT 21
16020: PUSH
16021: LD_INT 3
16023: PUSH
16024: EMPTY
16025: LIST
16026: LIST
16027: PUSH
16028: EMPTY
16029: LIST
16030: LIST
16031: PPUSH
16032: CALL_OW 69
16036: ST_TO_ADDR
// if filter then
16037: LD_VAR 0 2
16041: IFFALSE 16114
// for i in filter do
16043: LD_ADDR_VAR 0 1
16047: PUSH
16048: LD_VAR 0 2
16052: PUSH
16053: FOR_IN
16054: IFFALSE 16112
// if GetLives ( i ) < 990 then
16056: LD_VAR 0 1
16060: PPUSH
16061: CALL_OW 256
16065: PUSH
16066: LD_INT 990
16068: LESS
16069: IFFALSE 16110
// begin ru_alert := true ;
16071: LD_ADDR_EXP 59
16075: PUSH
16076: LD_INT 1
16078: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
16079: LD_ADDR_EXP 60
16083: PUSH
16084: LD_VAR 0 1
16088: PPUSH
16089: CALL_OW 250
16093: PUSH
16094: LD_VAR 0 1
16098: PPUSH
16099: CALL_OW 251
16103: PUSH
16104: EMPTY
16105: LIST
16106: LIST
16107: ST_TO_ADDR
// break ;
16108: GO 16112
// end ;
16110: GO 16053
16112: POP
16113: POP
// end ;
16114: PPOPN 2
16116: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
16117: LD_EXP 30
16121: IFFALSE 16270
16123: GO 16125
16125: DISABLE
16126: LD_INT 0
16128: PPUSH
16129: PPUSH
16130: PPUSH
16131: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
16132: LD_ADDR_VAR 0 4
16136: PUSH
16137: LD_EXP 55
16141: PUSH
16142: LD_EXP 54
16146: ADD
16147: PUSH
16148: LD_EXP 52
16152: ADD
16153: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
16154: LD_ADDR_VAR 0 3
16158: PUSH
16159: LD_INT 3
16161: PPUSH
16162: LD_INT 81
16164: PUSH
16165: LD_INT 3
16167: PUSH
16168: EMPTY
16169: LIST
16170: LIST
16171: PPUSH
16172: CALL_OW 70
16176: ST_TO_ADDR
// if filter and enemy then
16177: LD_VAR 0 4
16181: PUSH
16182: LD_VAR 0 3
16186: AND
16187: IFFALSE 16270
// repeat wait ( 0 0$01 ) ;
16189: LD_INT 35
16191: PPUSH
16192: CALL_OW 67
// for i in filter do
16196: LD_ADDR_VAR 0 1
16200: PUSH
16201: LD_VAR 0 4
16205: PUSH
16206: FOR_IN
16207: IFFALSE 16235
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16209: LD_VAR 0 1
16213: PPUSH
16214: LD_VAR 0 3
16218: PPUSH
16219: LD_VAR 0 1
16223: PPUSH
16224: CALL_OW 74
16228: PPUSH
16229: CALL_OW 115
// end ;
16233: GO 16206
16235: POP
16236: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
16237: LD_INT 3
16239: PPUSH
16240: LD_INT 81
16242: PUSH
16243: LD_INT 3
16245: PUSH
16246: EMPTY
16247: LIST
16248: LIST
16249: PPUSH
16250: CALL_OW 70
16254: PUSH
16255: LD_INT 0
16257: EQUAL
16258: PUSH
16259: LD_VAR 0 4
16263: PUSH
16264: LD_INT 0
16266: EQUAL
16267: OR
16268: IFFALSE 16189
// end ;
16270: PPOPN 4
16272: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) do var i ;
16273: LD_EXP 25
16277: PUSH
16278: LD_INT 22
16280: PUSH
16281: LD_INT 4
16283: PUSH
16284: EMPTY
16285: LIST
16286: LIST
16287: PUSH
16288: LD_INT 30
16290: PUSH
16291: LD_INT 4
16293: PUSH
16294: EMPTY
16295: LIST
16296: LIST
16297: PUSH
16298: LD_INT 3
16300: PUSH
16301: LD_INT 57
16303: PUSH
16304: EMPTY
16305: LIST
16306: PUSH
16307: EMPTY
16308: LIST
16309: LIST
16310: PUSH
16311: EMPTY
16312: LIST
16313: LIST
16314: LIST
16315: PPUSH
16316: CALL_OW 69
16320: AND
16321: IFFALSE 16370
16323: GO 16325
16325: DISABLE
16326: LD_INT 0
16328: PPUSH
// begin if not ru_cornel_attack then
16329: LD_EXP 57
16333: NOT
16334: IFFALSE 16338
// exit ;
16336: GO 16370
// for i in ru_cornel_attack do
16338: LD_ADDR_VAR 0 1
16342: PUSH
16343: LD_EXP 57
16347: PUSH
16348: FOR_IN
16349: IFFALSE 16368
// ComAgressiveMove ( i , 258 , 119 ) ;
16351: LD_VAR 0 1
16355: PPUSH
16356: LD_INT 258
16358: PPUSH
16359: LD_INT 119
16361: PPUSH
16362: CALL_OW 114
16366: GO 16348
16368: POP
16369: POP
// end ; end_of_file
16370: PPOPN 1
16372: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
16373: LD_EXP 5
16377: PUSH
16378: LD_EXP 9
16382: NOT
16383: AND
16384: PUSH
16385: LD_EXP 19
16389: AND
16390: IFFALSE 16502
16392: GO 16394
16394: DISABLE
16395: LD_INT 0
16397: PPUSH
// begin enable ;
16398: ENABLE
// crates_counter := crates_counter - 50 ;
16399: LD_ADDR_EXP 19
16403: PUSH
16404: LD_EXP 19
16408: PUSH
16409: LD_INT 50
16411: MINUS
16412: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
16413: LD_INT 8
16415: PPUSH
16416: LD_INT 2
16418: PPUSH
16419: LD_INT 5
16421: PPUSH
16422: CALL_OW 12
16426: PPUSH
16427: LD_INT 1
16429: PPUSH
16430: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
16434: LD_INT 1785
16436: PPUSH
16437: LD_INT 2345
16439: PPUSH
16440: CALL_OW 12
16444: PPUSH
16445: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
16449: LD_ADDR_VAR 0 1
16453: PUSH
16454: LD_INT 1
16456: PPUSH
16457: LD_OWVAR 67
16461: PUSH
16462: LD_INT 2
16464: PLUS
16465: PPUSH
16466: CALL_OW 12
16470: ST_TO_ADDR
// if r < 3 then
16471: LD_VAR 0 1
16475: PUSH
16476: LD_INT 3
16478: LESS
16479: IFFALSE 16502
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
16481: LD_INT 4
16483: PPUSH
16484: LD_INT 1
16486: PPUSH
16487: LD_INT 5
16489: PPUSH
16490: CALL_OW 12
16494: PPUSH
16495: LD_INT 1
16497: PPUSH
16498: CALL_OW 55
// end ;
16502: PPOPN 1
16504: END
// every 0 0$01 trigger cornel_active do
16505: LD_EXP 8
16509: IFFALSE 16598
16511: GO 16513
16513: DISABLE
// begin Wait ( 0 0$03 ) ;
16514: LD_INT 105
16516: PPUSH
16517: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16521: LD_INT 2
16523: PPUSH
16524: LD_INT 5
16526: PPUSH
16527: CALL_OW 12
16531: PPUSH
16532: LD_INT 10
16534: PPUSH
16535: LD_INT 1
16537: PPUSH
16538: CALL_OW 55
// Wait ( 0 0$13 ) ;
16542: LD_INT 455
16544: PPUSH
16545: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16549: LD_INT 2
16551: PPUSH
16552: LD_INT 5
16554: PPUSH
16555: CALL_OW 12
16559: PPUSH
16560: LD_INT 10
16562: PPUSH
16563: LD_INT 1
16565: PPUSH
16566: CALL_OW 55
// Wait ( 0 0$16 ) ;
16570: LD_INT 560
16572: PPUSH
16573: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16577: LD_INT 2
16579: PPUSH
16580: LD_INT 5
16582: PPUSH
16583: CALL_OW 12
16587: PPUSH
16588: LD_INT 10
16590: PPUSH
16591: LD_INT 1
16593: PPUSH
16594: CALL_OW 55
// end ; end_of_file
16598: END
// every 0 0$01 trigger cornel_prepared do
16599: LD_EXP 11
16603: IFFALSE 16662
16605: GO 16607
16607: DISABLE
// begin enable ;
16608: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
16609: LD_ADDR_OWVAR 47
16613: PUSH
16614: LD_STRING #Am03-1
16616: PUSH
16617: LD_EXP 10
16621: PUSH
16622: EMPTY
16623: LIST
16624: LIST
16625: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
16626: LD_ADDR_EXP 10
16630: PUSH
16631: LD_EXP 10
16635: PPUSH
16636: LD_STRING -
16638: PPUSH
16639: CALL 1117 0 2
16643: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
16644: LD_EXP 10
16648: PUSH
16649: LD_INT 0
16651: EQUAL
16652: IFFALSE 16662
// begin Display_Strings := [ ] ;
16654: LD_ADDR_OWVAR 47
16658: PUSH
16659: EMPTY
16660: ST_TO_ADDR
// disable ;
16661: DISABLE
// end ; end ;
16662: END
// every 0 0$01 trigger debug and debug_strings do
16663: LD_EXP 1
16667: PUSH
16668: LD_OWVAR 48
16672: AND
16673: IFFALSE 16689
16675: GO 16677
16677: DISABLE
// begin enable ;
16678: ENABLE
// Display_Strings := debug_strings ;
16679: LD_ADDR_OWVAR 47
16683: PUSH
16684: LD_OWVAR 48
16688: ST_TO_ADDR
// end ; end_of_file
16689: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
16690: LD_VAR 0 1
16694: PPUSH
16695: CALL_OW 255
16699: PUSH
16700: LD_INT 1
16702: EQUAL
16703: PUSH
16704: LD_EXP 13
16708: NOT
16709: AND
16710: IFFALSE 16720
// solar_builded := true ;
16712: LD_ADDR_EXP 13
16716: PUSH
16717: LD_INT 1
16719: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
16720: LD_VAR 0 1
16724: PPUSH
16725: CALL_OW 255
16729: PUSH
16730: LD_INT 1
16732: EQUAL
16733: PUSH
16734: LD_EXP 28
16738: AND
16739: IFFALSE 16772
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
16741: LD_ADDR_EXP 28
16745: PUSH
16746: LD_EXP 28
16750: PUSH
16751: LD_INT 1750
16753: PUSH
16754: LD_INT 1400
16756: PUSH
16757: LD_INT 1225
16759: PUSH
16760: EMPTY
16761: LIST
16762: LIST
16763: LIST
16764: PUSH
16765: LD_OWVAR 67
16769: ARRAY
16770: PLUS
16771: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
16772: LD_VAR 0 1
16776: PPUSH
16777: CALL_OW 255
16781: PUSH
16782: LD_INT 3
16784: EQUAL
16785: IFFALSE 16803
// ru_vehicles := ru_vehicles ^ veh ;
16787: LD_ADDR_EXP 55
16791: PUSH
16792: LD_EXP 55
16796: PUSH
16797: LD_VAR 0 1
16801: ADD
16802: ST_TO_ADDR
// end ;
16803: PPOPN 2
16805: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
16806: LD_VAR 0 1
16810: PUSH
16811: LD_EXP 52
16815: IN
16816: IFFALSE 16834
// ru_patrol := ru_patrol diff un ;
16818: LD_ADDR_EXP 52
16822: PUSH
16823: LD_EXP 52
16827: PUSH
16828: LD_VAR 0 1
16832: DIFF
16833: ST_TO_ADDR
// if un in ru_forest then
16834: LD_VAR 0 1
16838: PUSH
16839: LD_EXP 54
16843: IN
16844: IFFALSE 16862
// ru_forest := ru_forest diff un ;
16846: LD_ADDR_EXP 54
16850: PUSH
16851: LD_EXP 54
16855: PUSH
16856: LD_VAR 0 1
16860: DIFF
16861: ST_TO_ADDR
// if un in ru_vehicles then
16862: LD_VAR 0 1
16866: PUSH
16867: LD_EXP 55
16871: IN
16872: IFFALSE 16947
// begin ru_vehicles := ru_vehicles diff un ;
16874: LD_ADDR_EXP 55
16878: PUSH
16879: LD_EXP 55
16883: PUSH
16884: LD_VAR 0 1
16888: DIFF
16889: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
16890: LD_ADDR_EXP 56
16894: PUSH
16895: LD_EXP 56
16899: PUSH
16900: LD_VAR 0 1
16904: PPUSH
16905: CALL_OW 265
16909: PUSH
16910: LD_VAR 0 1
16914: PPUSH
16915: CALL_OW 262
16919: PUSH
16920: LD_VAR 0 1
16924: PPUSH
16925: CALL_OW 263
16929: PUSH
16930: LD_VAR 0 1
16934: PPUSH
16935: CALL_OW 264
16939: PUSH
16940: EMPTY
16941: LIST
16942: LIST
16943: LIST
16944: LIST
16945: ADD
16946: ST_TO_ADDR
// end ; if un = JMM then
16947: LD_VAR 0 1
16951: PUSH
16952: LD_EXP 36
16956: EQUAL
16957: IFFALSE 16966
// YouLost ( 0 ) ;
16959: LD_STRING 0
16961: PPUSH
16962: CALL_OW 104
// if un = us_dep_west then
16966: LD_VAR 0 1
16970: PUSH
16971: LD_INT 1
16973: EQUAL
16974: IFFALSE 16983
// YouLost ( 2 ) ;
16976: LD_STRING 2
16978: PPUSH
16979: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
16983: LD_VAR 0 1
16987: PPUSH
16988: CALL_OW 255
16992: PUSH
16993: LD_INT 8
16995: EQUAL
16996: PUSH
16997: LD_EXP 5
17001: NOT
17002: AND
17003: IFFALSE 17012
// YouLost ( 4 ) ;
17005: LD_STRING 4
17007: PPUSH
17008: CALL_OW 104
// if un in jmm_units then
17012: LD_VAR 0 1
17016: PUSH
17017: LD_EXP 4
17021: IN
17022: IFFALSE 17038
// lose_counter := lose_counter + 1 ;
17024: LD_ADDR_EXP 33
17028: PUSH
17029: LD_EXP 33
17033: PUSH
17034: LD_INT 1
17036: PLUS
17037: ST_TO_ADDR
// end ;
17038: PPOPN 1
17040: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
17041: LD_INT 0
17043: PPUSH
17044: PPUSH
// begin if GetSide ( driver ) = 3 then
17045: LD_VAR 0 1
17049: PPUSH
17050: CALL_OW 255
17054: PUSH
17055: LD_INT 3
17057: EQUAL
17058: IFFALSE 17136
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
17060: LD_ADDR_VAR 0 6
17064: PUSH
17065: LD_INT 22
17067: PUSH
17068: LD_INT 3
17070: PUSH
17071: EMPTY
17072: LIST
17073: LIST
17074: PUSH
17075: LD_INT 30
17077: PUSH
17078: LD_INT 3
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: PPUSH
17089: CALL_OW 69
17093: PPUSH
17094: CALL 1047 0 1
17098: ST_TO_ADDR
// if place then
17099: LD_VAR 0 6
17103: IFFALSE 17121
// ComEnterUnit ( driver , place ) else
17105: LD_VAR 0 1
17109: PPUSH
17110: LD_VAR 0 6
17114: PPUSH
17115: CALL_OW 120
17119: GO 17136
// ComMoveXY ( driver , 70 , 22 ) ;
17121: LD_VAR 0 1
17125: PPUSH
17126: LD_INT 70
17128: PPUSH
17129: LD_INT 22
17131: PPUSH
17132: CALL_OW 111
// end ; end ;
17136: PPOPN 6
17138: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and ( s2 = 4 or ( s2 = 8 and not jmm_on_west ) ) then
17139: LD_VAR 0 1
17143: PUSH
17144: LD_INT 1
17146: EQUAL
17147: PUSH
17148: LD_VAR 0 2
17152: PUSH
17153: LD_INT 4
17155: EQUAL
17156: PUSH
17157: LD_VAR 0 2
17161: PUSH
17162: LD_INT 8
17164: EQUAL
17165: PUSH
17166: LD_EXP 5
17170: NOT
17171: AND
17172: OR
17173: AND
17174: IFFALSE 17183
// YouLost ( 5 ) ;
17176: LD_STRING 5
17178: PPUSH
17179: CALL_OW 104
// end ;
17183: PPOPN 2
17185: END
// every 0 0$01 trigger save_counter + ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
17186: LD_EXP 35
17190: PUSH
17191: LD_INT 22
17193: PUSH
17194: LD_INT 1
17196: PUSH
17197: EMPTY
17198: LIST
17199: LIST
17200: PUSH
17201: LD_INT 21
17203: PUSH
17204: LD_INT 1
17206: PUSH
17207: EMPTY
17208: LIST
17209: LIST
17210: PUSH
17211: EMPTY
17212: LIST
17213: LIST
17214: PPUSH
17215: CALL_OW 69
17219: PUSH
17220: LD_INT 22
17222: PUSH
17223: LD_INT 8
17225: PUSH
17226: EMPTY
17227: LIST
17228: LIST
17229: PUSH
17230: LD_INT 21
17232: PUSH
17233: LD_INT 1
17235: PUSH
17236: EMPTY
17237: LIST
17238: LIST
17239: PUSH
17240: EMPTY
17241: LIST
17242: LIST
17243: PPUSH
17244: CALL_OW 69
17248: ADD
17249: PLUS
17250: PUSH
17251: LD_INT 5
17253: LESS
17254: IFFALSE 17266
17256: GO 17258
17258: DISABLE
// YouLost ( 1 ) ;
17259: LD_STRING 1
17261: PPUSH
17262: CALL_OW 104
17266: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
17267: LD_INT 1
17269: PPUSH
17270: CALL_OW 255
17274: PUSH
17275: LD_INT 3
17277: EQUAL
17278: IFFALSE 17290
17280: GO 17282
17282: DISABLE
// YouLost ( 3 ) ;
17283: LD_STRING 3
17285: PPUSH
17286: CALL_OW 104
17290: END
