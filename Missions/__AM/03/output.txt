// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 39 0 0
// SetDiplomacy ;
   8: CALL 246 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 334 0 0
// PrepareRussian ;
  22: CALL 2653 0 0
// PrepareAmerican ;
  26: CALL 898 0 0
// PrepareCornell ;
  30: CALL 1934 0 0
// PrepareWesternBase ;
  34: CALL 2160 0 0
// end ;
  38: END
// export debug ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , veh_on_meta ; function Init ; begin
  39: LD_INT 0
  41: PPUSH
// debug := false ;
  42: LD_ADDR_EXP 1
  46: PUSH
  47: LD_INT 0
  49: ST_TO_ADDR
// jmm_units := 0 ;
  50: LD_ADDR_EXP 2
  54: PUSH
  55: LD_INT 0
  57: ST_TO_ADDR
// cornel_units := 0 ;
  58: LD_ADDR_EXP 4
  62: PUSH
  63: LD_INT 0
  65: ST_TO_ADDR
// bierezov_exist := false ;
  66: LD_ADDR_EXP 5
  70: PUSH
  71: LD_INT 0
  73: ST_TO_ADDR
// jmm_on_west := false ;
  74: LD_ADDR_EXP 3
  78: PUSH
  79: LD_INT 0
  81: ST_TO_ADDR
// cornel_active := false ;
  82: LD_ADDR_EXP 6
  86: PUSH
  87: LD_INT 0
  89: ST_TO_ADDR
// cornel_attack := false ;
  90: LD_ADDR_EXP 7
  94: PUSH
  95: LD_INT 0
  97: ST_TO_ADDR
// cornel_prepared := false ;
  98: LD_ADDR_EXP 9
 102: PUSH
 103: LD_INT 0
 105: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 106: LD_ADDR_EXP 8
 110: PUSH
 111: LD_INT 4200
 113: ST_TO_ADDR
// frank_can_return := false ;
 114: LD_ADDR_EXP 10
 118: PUSH
 119: LD_INT 0
 121: ST_TO_ADDR
// solar_builded := false ;
 122: LD_ADDR_EXP 11
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// frank_send_to_scout := false ;
 130: LD_ADDR_EXP 12
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// jmm_in_veh := false ;
 138: LD_ADDR_EXP 13
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// bobby_in_veh := false ;
 146: LD_ADDR_EXP 14
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// cyrus_in_veh := false ;
 154: LD_ADDR_EXP 15
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// lisa_in_veh := false ;
 162: LD_ADDR_EXP 16
 166: PUSH
 167: LD_INT 0
 169: ST_TO_ADDR
// crates_counter := [ 1200 , 1000 , 800 ] [ Difficulty ] ;
 170: LD_ADDR_EXP 17
 174: PUSH
 175: LD_INT 1200
 177: PUSH
 178: LD_INT 1000
 180: PUSH
 181: LD_INT 800
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: LIST
 188: PUSH
 189: LD_OWVAR 67
 193: ARRAY
 194: ST_TO_ADDR
// end_mission_allowed := false ;
 195: LD_ADDR_EXP 18
 199: PUSH
 200: LD_INT 0
 202: ST_TO_ADDR
// save_others := [ ] ;
 203: LD_ADDR_EXP 19
 207: PUSH
 208: EMPTY
 209: ST_TO_ADDR
// save_group := [ ] ;
 210: LD_ADDR_EXP 20
 214: PUSH
 215: EMPTY
 216: ST_TO_ADDR
// show_query := true ;
 217: LD_ADDR_EXP 21
 221: PUSH
 222: LD_INT 1
 224: ST_TO_ADDR
// wait_for_them := false ;
 225: LD_ADDR_EXP 22
 229: PUSH
 230: LD_INT 0
 232: ST_TO_ADDR
// veh_on_meta := false ;
 233: LD_ADDR_EXP 23
 237: PUSH
 238: LD_INT 0
 240: ST_TO_ADDR
// end ;
 241: LD_VAR 0 1
 245: RET
// function SetDiplomacy ; begin
 246: LD_INT 0
 248: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 249: LD_INT 1
 251: PPUSH
 252: LD_INT 4
 254: PPUSH
 255: LD_INT 1
 257: PPUSH
 258: LD_INT 1
 260: PPUSH
 261: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 265: LD_INT 1
 267: PPUSH
 268: LD_INT 8
 270: PPUSH
 271: LD_INT 1
 273: PPUSH
 274: LD_INT 1
 276: PPUSH
 277: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 281: LD_INT 3
 283: PPUSH
 284: LD_INT 6
 286: PPUSH
 287: LD_INT 1
 289: PPUSH
 290: LD_INT 1
 292: PPUSH
 293: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 297: LD_INT 4
 299: PPUSH
 300: LD_INT 6
 302: PPUSH
 303: LD_INT 0
 305: PPUSH
 306: LD_INT 1
 308: PPUSH
 309: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 313: LD_INT 3
 315: PPUSH
 316: LD_INT 8
 318: PPUSH
 319: LD_INT 0
 321: PPUSH
 322: LD_INT 1
 324: PPUSH
 325: CALL_OW 80
// end ;
 329: LD_VAR 0 1
 333: RET
// export function DebugMode ; begin
 334: LD_INT 0
 336: PPUSH
// FogOff ( 1 ) ;
 337: LD_INT 1
 339: PPUSH
 340: CALL_OW 344
// end ; end_of_file
 344: LD_VAR 0 1
 348: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 349: LD_INT 0
 351: PPUSH
 352: PPUSH
// if exist_mode then
 353: LD_VAR 0 2
 357: IFFALSE 376
// unit := CreateCharacter ( ident ) else
 359: LD_ADDR_VAR 0 4
 363: PUSH
 364: LD_VAR 0 1
 368: PPUSH
 369: CALL_OW 34
 373: ST_TO_ADDR
 374: GO 391
// unit := NewCharacter ( ident ) ;
 376: LD_ADDR_VAR 0 4
 380: PUSH
 381: LD_VAR 0 1
 385: PPUSH
 386: CALL_OW 25
 390: ST_TO_ADDR
// result := unit ;
 391: LD_ADDR_VAR 0 3
 395: PUSH
 396: LD_VAR 0 4
 400: ST_TO_ADDR
// end ;
 401: LD_VAR 0 3
 405: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 406: LD_INT 0
 408: PPUSH
// uc_side := side ;
 409: LD_ADDR_OWVAR 20
 413: PUSH
 414: LD_VAR 0 1
 418: ST_TO_ADDR
// uc_nation := nation ;
 419: LD_ADDR_OWVAR 21
 423: PUSH
 424: LD_VAR 0 2
 428: ST_TO_ADDR
// vc_chassis := chassis ;
 429: LD_ADDR_OWVAR 37
 433: PUSH
 434: LD_VAR 0 3
 438: ST_TO_ADDR
// vc_engine := engine ;
 439: LD_ADDR_OWVAR 39
 443: PUSH
 444: LD_VAR 0 4
 448: ST_TO_ADDR
// vc_control := control ;
 449: LD_ADDR_OWVAR 38
 453: PUSH
 454: LD_VAR 0 5
 458: ST_TO_ADDR
// vc_weapon := weapon ;
 459: LD_ADDR_OWVAR 40
 463: PUSH
 464: LD_VAR 0 6
 468: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 469: LD_ADDR_OWVAR 41
 473: PUSH
 474: LD_VAR 0 7
 478: ST_TO_ADDR
// result := CreateVehicle ;
 479: LD_ADDR_VAR 0 8
 483: PUSH
 484: CALL_OW 45
 488: ST_TO_ADDR
// end ;
 489: LD_VAR 0 8
 493: RET
// export function SayX ( units , ident ) ; var i ; begin
 494: LD_INT 0
 496: PPUSH
 497: PPUSH
// if not units then
 498: LD_VAR 0 1
 502: NOT
 503: IFFALSE 507
// exit ;
 505: GO 551
// for i in ident do
 507: LD_ADDR_VAR 0 4
 511: PUSH
 512: LD_VAR 0 2
 516: PUSH
 517: FOR_IN
 518: IFFALSE 549
// if IsOk ( i ) then
 520: LD_VAR 0 4
 524: PPUSH
 525: CALL_OW 302
 529: IFFALSE 547
// begin Say ( i , ident ) ;
 531: LD_VAR 0 4
 535: PPUSH
 536: LD_VAR 0 2
 540: PPUSH
 541: CALL_OW 88
// break ;
 545: GO 549
// end ;
 547: GO 517
 549: POP
 550: POP
// end ;
 551: LD_VAR 0 3
 555: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 556: LD_INT 0
 558: PPUSH
 559: PPUSH
 560: PPUSH
 561: PPUSH
// for i = 1 to count do
 562: LD_ADDR_VAR 0 8
 566: PUSH
 567: DOUBLE
 568: LD_INT 1
 570: DEC
 571: ST_TO_ADDR
 572: LD_VAR 0 6
 576: PUSH
 577: FOR_TO
 578: IFFALSE 659
// begin uc_side = side ;
 580: LD_ADDR_OWVAR 20
 584: PUSH
 585: LD_VAR 0 1
 589: ST_TO_ADDR
// uc_nation = nation ;
 590: LD_ADDR_OWVAR 21
 594: PUSH
 595: LD_VAR 0 2
 599: ST_TO_ADDR
// hc_gallery =  ;
 600: LD_ADDR_OWVAR 33
 604: PUSH
 605: LD_STRING 
 607: ST_TO_ADDR
// hc_name =  ;
 608: LD_ADDR_OWVAR 26
 612: PUSH
 613: LD_STRING 
 615: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 616: LD_INT 0
 618: PPUSH
 619: LD_VAR 0 5
 623: PPUSH
 624: LD_VAR 0 4
 628: PPUSH
 629: CALL_OW 380
// un = CreateHuman ;
 633: LD_ADDR_VAR 0 10
 637: PUSH
 638: CALL_OW 44
 642: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 643: LD_VAR 0 10
 647: PPUSH
 648: LD_VAR 0 3
 652: PPUSH
 653: CALL_OW 52
// end ;
 657: GO 577
 659: POP
 660: POP
// end ;
 661: LD_VAR 0 7
 665: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 666: LD_INT 0
 668: PPUSH
 669: PPUSH
 670: PPUSH
// uc_side := GetSide ( b ) ;
 671: LD_ADDR_OWVAR 20
 675: PUSH
 676: LD_VAR 0 2
 680: PPUSH
 681: CALL_OW 255
 685: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 686: LD_ADDR_OWVAR 21
 690: PUSH
 691: LD_VAR 0 2
 695: PPUSH
 696: CALL_OW 248
 700: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 701: LD_INT 0
 703: PPUSH
 704: LD_INT 1
 706: PPUSH
 707: LD_VAR 0 1
 711: PPUSH
 712: CALL_OW 380
// un = CreateHuman ;
 716: LD_ADDR_VAR 0 4
 720: PUSH
 721: CALL_OW 44
 725: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 726: LD_ADDR_VAR 0 5
 730: PUSH
 731: LD_VAR 0 2
 735: PPUSH
 736: CALL_OW 254
 740: PUSH
 741: LD_INT 3
 743: MINUS
 744: ST_TO_ADDR
// if dir < 0 then
 745: LD_VAR 0 5
 749: PUSH
 750: LD_INT 0
 752: LESS
 753: IFFALSE 769
// dir := 6 + dir ;
 755: LD_ADDR_VAR 0 5
 759: PUSH
 760: LD_INT 6
 762: PUSH
 763: LD_VAR 0 5
 767: PLUS
 768: ST_TO_ADDR
// SetDir ( un , dir ) ;
 769: LD_VAR 0 4
 773: PPUSH
 774: LD_VAR 0 5
 778: PPUSH
 779: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 783: LD_VAR 0 4
 787: PPUSH
 788: LD_VAR 0 2
 792: PPUSH
 793: CALL_OW 52
// end ;
 797: LD_VAR 0 3
 801: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 802: LD_INT 0
 804: PPUSH
 805: PPUSH
 806: PPUSH
// result := false ;
 807: LD_ADDR_VAR 0 2
 811: PUSH
 812: LD_INT 0
 814: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 815: LD_ADDR_VAR 0 3
 819: PUSH
 820: LD_INT 22
 822: PUSH
 823: LD_INT 1
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: PUSH
 830: LD_INT 34
 832: PUSH
 833: LD_INT 2
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: PPUSH
 844: CALL_OW 69
 848: ST_TO_ADDR
// for i in filter do
 849: LD_ADDR_VAR 0 4
 853: PUSH
 854: LD_VAR 0 3
 858: PUSH
 859: FOR_IN
 860: IFFALSE 891
// if IsDrivenBy ( i ) = unit then
 862: LD_VAR 0 4
 866: PPUSH
 867: CALL_OW 311
 871: PUSH
 872: LD_VAR 0 1
 876: EQUAL
 877: IFFALSE 889
// begin result := true ;
 879: LD_ADDR_VAR 0 2
 883: PUSH
 884: LD_INT 1
 886: ST_TO_ADDR
// break ;
 887: GO 891
// end ;
 889: GO 859
 891: POP
 892: POP
// end ; end_of_file
 893: LD_VAR 0 2
 897: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
 898: LD_INT 0
 900: PPUSH
 901: PPUSH
 902: PPUSH
 903: PPUSH
 904: PPUSH
 905: PPUSH
 906: PPUSH
 907: PPUSH
// uc_side := 4 ;
 908: LD_ADDR_OWVAR 20
 912: PUSH
 913: LD_INT 4
 915: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
 916: LD_ADDR_EXP 33
 920: PUSH
 921: LD_STRING Powell
 923: PPUSH
 924: LD_INT 0
 926: PPUSH
 927: CALL 349 0 2
 931: ST_TO_ADDR
// uc_side := 1 ;
 932: LD_ADDR_OWVAR 20
 936: PUSH
 937: LD_INT 1
 939: ST_TO_ADDR
// uc_nation := 1 ;
 940: LD_ADDR_OWVAR 21
 944: PUSH
 945: LD_INT 1
 947: ST_TO_ADDR
// if debug then
 948: LD_EXP 1
 952: IFFALSE 1082
// begin for i = 1 to 4 do
 954: LD_ADDR_VAR 0 2
 958: PUSH
 959: DOUBLE
 960: LD_INT 1
 962: DEC
 963: ST_TO_ADDR
 964: LD_INT 4
 966: PUSH
 967: FOR_TO
 968: IFFALSE 1019
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
 970: LD_INT 0
 972: PPUSH
 973: LD_INT 1
 975: PPUSH
 976: LD_INT 2
 978: PPUSH
 979: CALL_OW 12
 983: PPUSH
 984: LD_INT 3
 986: PPUSH
 987: CALL_OW 380
// un := CreateHuman ;
 991: LD_ADDR_VAR 0 3
 995: PUSH
 996: CALL_OW 44
1000: ST_TO_ADDR
// others := others ^ un ;
1001: LD_ADDR_VAR 0 5
1005: PUSH
1006: LD_VAR 0 5
1010: PUSH
1011: LD_VAR 0 3
1015: ADD
1016: ST_TO_ADDR
// end ;
1017: GO 967
1019: POP
1020: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1021: LD_ADDR_VAR 0 6
1025: PUSH
1026: LD_INT 21
1028: PUSH
1029: LD_INT 1
1031: PUSH
1032: LD_INT 1
1034: PUSH
1035: LD_INT 51
1037: PUSH
1038: LD_INT 90
1040: PUSH
1041: LD_INT 504
1043: PUSH
1044: EMPTY
1045: LIST
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: LIST
1051: PUSH
1052: LD_INT 21
1054: PUSH
1055: LD_INT 1
1057: PUSH
1058: LD_INT 1
1060: PUSH
1061: LD_INT 51
1063: PUSH
1064: LD_INT 80
1066: PUSH
1067: LD_INT 750
1069: PUSH
1070: EMPTY
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: LIST
1076: LIST
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1082: LD_ADDR_EXP 24
1086: PUSH
1087: LD_STRING JMM
1089: PPUSH
1090: LD_EXP 1
1094: NOT
1095: PPUSH
1096: CALL 349 0 2
1100: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1101: LD_ADDR_EXP 25
1105: PUSH
1106: LD_STRING Bobby
1108: PPUSH
1109: LD_EXP 1
1113: NOT
1114: PPUSH
1115: CALL 349 0 2
1119: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1120: LD_ADDR_EXP 26
1124: PUSH
1125: LD_STRING Cyrus
1127: PPUSH
1128: LD_EXP 1
1132: NOT
1133: PPUSH
1134: CALL 349 0 2
1138: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1139: LD_ADDR_EXP 27
1143: PUSH
1144: LD_STRING Lisa
1146: PPUSH
1147: LD_EXP 1
1151: NOT
1152: PPUSH
1153: CALL 349 0 2
1157: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1158: LD_ADDR_EXP 28
1162: PUSH
1163: LD_STRING Khatam
1165: PPUSH
1166: LD_EXP 1
1170: NOT
1171: PPUSH
1172: CALL 349 0 2
1176: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1177: LD_ADDR_EXP 29
1181: PUSH
1182: LD_STRING Brian
1184: PPUSH
1185: LD_EXP 1
1189: NOT
1190: PPUSH
1191: CALL 349 0 2
1195: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1196: LD_ADDR_EXP 30
1200: PUSH
1201: LD_STRING Jerry
1203: PPUSH
1204: LD_EXP 1
1208: NOT
1209: PPUSH
1210: CALL 349 0 2
1214: ST_TO_ADDR
// if Bobby then
1215: LD_EXP 25
1219: IFFALSE 1250
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1221: LD_ADDR_VAR 0 4
1225: PUSH
1226: LD_VAR 0 4
1230: PPUSH
1231: LD_VAR 0 4
1235: PUSH
1236: LD_INT 1
1238: PLUS
1239: PPUSH
1240: LD_EXP 25
1244: PPUSH
1245: CALL_OW 2
1249: ST_TO_ADDR
// if Cyrus then
1250: LD_EXP 26
1254: IFFALSE 1285
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1256: LD_ADDR_VAR 0 4
1260: PUSH
1261: LD_VAR 0 4
1265: PPUSH
1266: LD_VAR 0 4
1270: PUSH
1271: LD_INT 1
1273: PLUS
1274: PPUSH
1275: LD_EXP 26
1279: PPUSH
1280: CALL_OW 2
1284: ST_TO_ADDR
// if Lisa then
1285: LD_EXP 27
1289: IFFALSE 1320
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1291: LD_ADDR_VAR 0 4
1295: PUSH
1296: LD_VAR 0 4
1300: PPUSH
1301: LD_VAR 0 4
1305: PUSH
1306: LD_INT 1
1308: PLUS
1309: PPUSH
1310: LD_EXP 27
1314: PPUSH
1315: CALL_OW 2
1319: ST_TO_ADDR
// if Khatam then
1320: LD_EXP 28
1324: IFFALSE 1355
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1326: LD_ADDR_VAR 0 4
1330: PUSH
1331: LD_VAR 0 4
1335: PPUSH
1336: LD_VAR 0 4
1340: PUSH
1341: LD_INT 1
1343: PLUS
1344: PPUSH
1345: LD_EXP 28
1349: PPUSH
1350: CALL_OW 2
1354: ST_TO_ADDR
// if Brian then
1355: LD_EXP 29
1359: IFFALSE 1390
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1361: LD_ADDR_VAR 0 4
1365: PUSH
1366: LD_VAR 0 4
1370: PPUSH
1371: LD_VAR 0 4
1375: PUSH
1376: LD_INT 1
1378: PLUS
1379: PPUSH
1380: LD_EXP 29
1384: PPUSH
1385: CALL_OW 2
1389: ST_TO_ADDR
// if Jerry then
1390: LD_EXP 30
1394: IFFALSE 1425
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1396: LD_ADDR_VAR 0 4
1400: PUSH
1401: LD_VAR 0 4
1405: PPUSH
1406: LD_VAR 0 4
1410: PUSH
1411: LD_INT 1
1413: PLUS
1414: PPUSH
1415: LD_EXP 30
1419: PPUSH
1420: CALL_OW 2
1424: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1425: LD_STRING 02_other_survivors
1427: PPUSH
1428: CALL_OW 28
1432: IFFALSE 1447
// others := CreateCharacterSet ( 02_other_survivors ) ;
1434: LD_ADDR_VAR 0 5
1438: PUSH
1439: LD_STRING 02_other_survivors
1441: PPUSH
1442: CALL_OW 31
1446: ST_TO_ADDR
// if others then
1447: LD_VAR 0 5
1451: IFFALSE 1476
// begin tmp := tmp ^ others ;
1453: LD_ADDR_VAR 0 4
1457: PUSH
1458: LD_VAR 0 4
1462: PUSH
1463: LD_VAR 0 5
1467: ADD
1468: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1469: LD_STRING 02_other_survivors
1471: PPUSH
1472: CALL_OW 40
// end ; jmm_units := tmp ;
1476: LD_ADDR_EXP 2
1480: PUSH
1481: LD_VAR 0 4
1485: ST_TO_ADDR
// if not vehicles then
1486: LD_VAR 0 6
1490: NOT
1491: IFFALSE 1509
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1493: LD_ADDR_VAR 0 6
1497: PUSH
1498: LD_STRING 02_tanks_1
1500: PPUSH
1501: LD_INT 0
1503: PPUSH
1504: CALL_OW 30
1508: ST_TO_ADDR
// display_strings := vehicles ;
1509: LD_ADDR_OWVAR 47
1513: PUSH
1514: LD_VAR 0 6
1518: ST_TO_ADDR
// exit ;
1519: GO 1929
// if vehicles then
1521: LD_VAR 0 6
1525: IFFALSE 1719
// begin got_mech := false ;
1527: LD_ADDR_VAR 0 7
1531: PUSH
1532: LD_INT 0
1534: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1535: LD_VAR 0 4
1539: PPUSH
1540: LD_INT 25
1542: PUSH
1543: LD_INT 3
1545: PUSH
1546: EMPTY
1547: LIST
1548: LIST
1549: PPUSH
1550: CALL_OW 72
1554: IFFALSE 1564
// got_mech := true ;
1556: LD_ADDR_VAR 0 7
1560: PUSH
1561: LD_INT 1
1563: ST_TO_ADDR
// for i = 1 to vehicles do
1564: LD_ADDR_VAR 0 2
1568: PUSH
1569: DOUBLE
1570: LD_INT 1
1572: DEC
1573: ST_TO_ADDR
1574: LD_VAR 0 6
1578: PUSH
1579: FOR_TO
1580: IFFALSE 1717
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1582: LD_ADDR_VAR 0 3
1586: PUSH
1587: LD_INT 1
1589: PPUSH
1590: LD_INT 3
1592: PPUSH
1593: LD_VAR 0 6
1597: PUSH
1598: LD_VAR 0 2
1602: ARRAY
1603: PUSH
1604: LD_INT 1
1606: ARRAY
1607: PPUSH
1608: LD_VAR 0 6
1612: PUSH
1613: LD_VAR 0 2
1617: ARRAY
1618: PUSH
1619: LD_INT 2
1621: ARRAY
1622: PPUSH
1623: LD_VAR 0 6
1627: PUSH
1628: LD_VAR 0 2
1632: ARRAY
1633: PUSH
1634: LD_INT 3
1636: ARRAY
1637: PPUSH
1638: LD_VAR 0 6
1642: PUSH
1643: LD_VAR 0 2
1647: ARRAY
1648: PUSH
1649: LD_INT 4
1651: ARRAY
1652: PPUSH
1653: LD_INT 40
1655: PPUSH
1656: CALL 406 0 7
1660: ST_TO_ADDR
// if not got_mech then
1661: LD_VAR 0 7
1665: NOT
1666: IFFALSE 1692
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1668: LD_VAR 0 3
1672: PPUSH
1673: LD_VAR 0 6
1677: PUSH
1678: LD_VAR 0 2
1682: ARRAY
1683: PUSH
1684: LD_INT 6
1686: ARRAY
1687: PPUSH
1688: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1692: LD_ADDR_VAR 0 4
1696: PUSH
1697: LD_VAR 0 4
1701: PPUSH
1702: LD_INT 1
1704: PPUSH
1705: LD_VAR 0 3
1709: PPUSH
1710: CALL_OW 2
1714: ST_TO_ADDR
// end ;
1715: GO 1579
1717: POP
1718: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1719: LD_EXP 24
1723: PPUSH
1724: LD_INT 194
1726: PPUSH
1727: LD_INT 119
1729: PPUSH
1730: LD_INT 0
1732: PPUSH
1733: CALL_OW 48
// if tmp then
1737: LD_VAR 0 4
1741: IFFALSE 1866
// begin for i in tmp do
1743: LD_ADDR_VAR 0 2
1747: PUSH
1748: LD_VAR 0 4
1752: PUSH
1753: FOR_IN
1754: IFFALSE 1864
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1756: LD_ADDR_VAR 0 8
1760: PUSH
1761: LD_INT 22
1763: PUSH
1764: LD_INT 1
1766: PUSH
1767: EMPTY
1768: LIST
1769: LIST
1770: PUSH
1771: LD_INT 21
1773: PUSH
1774: LD_INT 2
1776: PUSH
1777: EMPTY
1778: LIST
1779: LIST
1780: PUSH
1781: LD_INT 58
1783: PUSH
1784: EMPTY
1785: LIST
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: LIST
1791: PPUSH
1792: CALL_OW 69
1796: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
1797: LD_VAR 0 2
1801: PPUSH
1802: CALL_OW 247
1806: PUSH
1807: LD_INT 1
1809: EQUAL
1810: PUSH
1811: LD_VAR 0 8
1815: AND
1816: IFFALSE 1838
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
1818: LD_VAR 0 2
1822: PPUSH
1823: LD_VAR 0 8
1827: PUSH
1828: LD_INT 1
1830: ARRAY
1831: PPUSH
1832: CALL_OW 52
1836: GO 1853
// PlaceUnitArea ( i , startArea , false ) ;
1838: LD_VAR 0 2
1842: PPUSH
1843: LD_INT 1
1845: PPUSH
1846: LD_INT 0
1848: PPUSH
1849: CALL_OW 49
// ComHold ( i ) ;
1853: LD_VAR 0 2
1857: PPUSH
1858: CALL_OW 140
// end ;
1862: GO 1753
1864: POP
1865: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
1866: LD_ADDR_EXP 5
1870: PUSH
1871: LD_STRING 02_mikhailStatus_1
1873: PPUSH
1874: LD_INT 0
1876: PPUSH
1877: CALL_OW 30
1881: ST_TO_ADDR
// if not bierezov_exist and not debug then
1882: LD_EXP 5
1886: NOT
1887: PUSH
1888: LD_EXP 1
1892: NOT
1893: AND
1894: IFFALSE 1898
// exit ;
1896: GO 1929
// Bierezov = PrepareUnit ( Mikhail , false ) ;
1898: LD_ADDR_EXP 32
1902: PUSH
1903: LD_STRING Mikhail
1905: PPUSH
1906: LD_INT 0
1908: PPUSH
1909: CALL 349 0 2
1913: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
1914: LD_EXP 32
1918: PPUSH
1919: LD_INT 1
1921: PPUSH
1922: LD_INT 0
1924: PPUSH
1925: CALL_OW 49
// end ;
1929: LD_VAR 0 1
1933: RET
// export function PrepareCornell ; var tmp , un , i ; begin
1934: LD_INT 0
1936: PPUSH
1937: PPUSH
1938: PPUSH
1939: PPUSH
// uc_side := 4 ;
1940: LD_ADDR_OWVAR 20
1944: PUSH
1945: LD_INT 4
1947: ST_TO_ADDR
// uc_nation := 1 ;
1948: LD_ADDR_OWVAR 21
1952: PUSH
1953: LD_INT 1
1955: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
1956: LD_ADDR_EXP 31
1960: PUSH
1961: LD_STRING Cornell
1963: PPUSH
1964: LD_INT 0
1966: PPUSH
1967: CALL 349 0 2
1971: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
1972: LD_ADDR_EXP 4
1976: PUSH
1977: LD_INT 8
1979: PUSH
1980: LD_EXP 2
1984: MINUS
1985: ST_TO_ADDR
// tmp := [ ] ;
1986: LD_ADDR_VAR 0 2
1990: PUSH
1991: EMPTY
1992: ST_TO_ADDR
// if cornel_units < 4 then
1993: LD_EXP 4
1997: PUSH
1998: LD_INT 4
2000: LESS
2001: IFFALSE 2011
// cornel_units := 4 ;
2003: LD_ADDR_EXP 4
2007: PUSH
2008: LD_INT 4
2010: ST_TO_ADDR
// for i = 1 to cornel_units do
2011: LD_ADDR_VAR 0 4
2015: PUSH
2016: DOUBLE
2017: LD_INT 1
2019: DEC
2020: ST_TO_ADDR
2021: LD_EXP 4
2025: PUSH
2026: FOR_TO
2027: IFFALSE 2125
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2029: LD_INT 0
2031: PPUSH
2032: LD_INT 1
2034: PUSH
2035: LD_INT 1
2037: PUSH
2038: LD_INT 1
2040: PUSH
2041: LD_INT 2
2043: PUSH
2044: LD_INT 4
2046: PUSH
2047: EMPTY
2048: LIST
2049: LIST
2050: LIST
2051: LIST
2052: LIST
2053: PUSH
2054: LD_VAR 0 4
2058: PUSH
2059: LD_INT 5
2061: MOD
2062: PUSH
2063: LD_INT 1
2065: PLUS
2066: ARRAY
2067: PPUSH
2068: LD_INT 2
2070: PPUSH
2071: CALL_OW 380
// un := CreateHuman ;
2075: LD_ADDR_VAR 0 3
2079: PUSH
2080: CALL_OW 44
2084: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2085: LD_ADDR_VAR 0 2
2089: PUSH
2090: LD_VAR 0 2
2094: PPUSH
2095: LD_INT 1
2097: PPUSH
2098: LD_VAR 0 3
2102: PPUSH
2103: CALL_OW 2
2107: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2108: LD_VAR 0 3
2112: PPUSH
2113: LD_INT 2
2115: PPUSH
2116: LD_INT 0
2118: PPUSH
2119: CALL_OW 49
// end ;
2123: GO 2026
2125: POP
2126: POP
// cornel_units := tmp ;
2127: LD_ADDR_EXP 4
2131: PUSH
2132: LD_VAR 0 2
2136: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2137: LD_EXP 31
2141: PPUSH
2142: LD_INT 191
2144: PPUSH
2145: LD_INT 106
2147: PPUSH
2148: LD_INT 0
2150: PPUSH
2151: CALL_OW 48
// end ;
2155: LD_VAR 0 1
2159: RET
// export function PrepareWesternBase ; var i ; begin
2160: LD_INT 0
2162: PPUSH
2163: PPUSH
// uc_side := 8 ;
2164: LD_ADDR_OWVAR 20
2168: PUSH
2169: LD_INT 8
2171: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2172: LD_ADDR_EXP 34
2176: PUSH
2177: LD_STRING Lynch
2179: PPUSH
2180: LD_INT 0
2182: PPUSH
2183: CALL 349 0 2
2187: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2188: LD_ADDR_EXP 35
2192: PUSH
2193: LD_STRING Walker
2195: PPUSH
2196: LD_INT 0
2198: PPUSH
2199: CALL 349 0 2
2203: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2204: LD_ADDR_EXP 36
2208: PUSH
2209: LD_STRING Turner
2211: PPUSH
2212: LD_INT 0
2214: PPUSH
2215: CALL 349 0 2
2219: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2220: LD_ADDR_EXP 37
2224: PUSH
2225: LD_STRING Jillian
2227: PPUSH
2228: LD_INT 0
2230: PPUSH
2231: CALL 349 0 2
2235: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2236: LD_ADDR_VAR 0 2
2240: PUSH
2241: LD_EXP 34
2245: PUSH
2246: LD_EXP 35
2250: PUSH
2251: LD_EXP 36
2255: PUSH
2256: LD_EXP 37
2260: PUSH
2261: EMPTY
2262: LIST
2263: LIST
2264: LIST
2265: LIST
2266: PUSH
2267: FOR_IN
2268: IFFALSE 2296
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2270: LD_VAR 0 2
2274: PPUSH
2275: LD_INT 3
2277: PPUSH
2278: LD_INT 0
2280: PPUSH
2281: CALL_OW 49
// ComHold ( i ) ;
2285: LD_VAR 0 2
2289: PPUSH
2290: CALL_OW 140
// end ;
2294: GO 2267
2296: POP
2297: POP
// end ;
2298: LD_VAR 0 1
2302: RET
// export function SelectGroup ; var units , selected , i ; begin
2303: LD_INT 0
2305: PPUSH
2306: PPUSH
2307: PPUSH
2308: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2309: LD_ADDR_VAR 0 2
2313: PUSH
2314: LD_EXP 24
2318: PUSH
2319: LD_INT -3
2321: PUSH
2322: EMPTY
2323: LIST
2324: LIST
2325: PUSH
2326: LD_EXP 2
2330: ADD
2331: PUSH
2332: LD_INT -2
2334: PUSH
2335: LD_INT -4
2337: PUSH
2338: LD_EXP 31
2342: PUSH
2343: LD_EXP 32
2347: PUSH
2348: EMPTY
2349: LIST
2350: LIST
2351: LIST
2352: LIST
2353: ADD
2354: PUSH
2355: LD_INT -3
2357: PUSH
2358: EMPTY
2359: LIST
2360: ADD
2361: PUSH
2362: LD_EXP 4
2366: ADD
2367: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2368: LD_ADDR_VAR 0 3
2372: PUSH
2373: LD_EXP 24
2377: PUSH
2378: LD_STRING Select five characters to go with you
2380: PPUSH
2381: LD_INT 4
2383: PPUSH
2384: LD_INT 4
2386: PPUSH
2387: LD_VAR 0 2
2391: PPUSH
2392: EMPTY
2393: PPUSH
2394: CALL_OW 42
2398: ADD
2399: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2400: LD_ADDR_EXP 4
2404: PUSH
2405: LD_EXP 2
2409: PUSH
2410: LD_EXP 4
2414: UNION
2415: PUSH
2416: LD_VAR 0 3
2420: DIFF
2421: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2422: LD_ADDR_VAR 0 4
2426: PUSH
2427: LD_EXP 4
2431: PUSH
2432: LD_EXP 32
2436: ADD
2437: PUSH
2438: FOR_IN
2439: IFFALSE 2470
// if GetSide ( i ) = 1 then
2441: LD_VAR 0 4
2445: PPUSH
2446: CALL_OW 255
2450: PUSH
2451: LD_INT 1
2453: EQUAL
2454: IFFALSE 2468
// SetSide ( i , 4 ) ;
2456: LD_VAR 0 4
2460: PPUSH
2461: LD_INT 4
2463: PPUSH
2464: CALL_OW 235
2468: GO 2438
2470: POP
2471: POP
// for i in selected do
2472: LD_ADDR_VAR 0 4
2476: PUSH
2477: LD_VAR 0 3
2481: PUSH
2482: FOR_IN
2483: IFFALSE 2514
// if GetSide ( i ) = 4 then
2485: LD_VAR 0 4
2489: PPUSH
2490: CALL_OW 255
2494: PUSH
2495: LD_INT 4
2497: EQUAL
2498: IFFALSE 2512
// SetSide ( i , 1 ) ;
2500: LD_VAR 0 4
2504: PPUSH
2505: LD_INT 1
2507: PPUSH
2508: CALL_OW 235
2512: GO 2482
2514: POP
2515: POP
// if GetSide ( Bobby ) = 4 then
2516: LD_EXP 25
2520: PPUSH
2521: CALL_OW 255
2525: PUSH
2526: LD_INT 4
2528: EQUAL
2529: IFFALSE 2538
// DeleteCharacters ( Bobby ) ;
2531: LD_STRING Bobby
2533: PPUSH
2534: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2538: LD_EXP 26
2542: PPUSH
2543: CALL_OW 255
2547: PUSH
2548: LD_INT 4
2550: EQUAL
2551: IFFALSE 2560
// DeleteCharacters ( Cyrus ) ;
2553: LD_STRING Cyrus
2555: PPUSH
2556: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2560: LD_EXP 27
2564: PPUSH
2565: CALL_OW 255
2569: PUSH
2570: LD_INT 4
2572: EQUAL
2573: IFFALSE 2582
// DeleteCharacters ( Lisa ) ;
2575: LD_STRING Lisa
2577: PPUSH
2578: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2582: LD_EXP 28
2586: PPUSH
2587: CALL_OW 255
2591: PUSH
2592: LD_INT 4
2594: EQUAL
2595: IFFALSE 2604
// DeleteCharacters ( Khatam ) ;
2597: LD_STRING Khatam
2599: PPUSH
2600: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2604: LD_EXP 29
2608: PPUSH
2609: CALL_OW 255
2613: PUSH
2614: LD_INT 4
2616: EQUAL
2617: IFFALSE 2626
// DeleteCharacters ( Brian ) ;
2619: LD_STRING Brian
2621: PPUSH
2622: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2626: LD_EXP 30
2630: PPUSH
2631: CALL_OW 255
2635: PUSH
2636: LD_INT 4
2638: EQUAL
2639: IFFALSE 2648
// DeleteCharacters ( Jerry ) ;
2641: LD_STRING Jerry
2643: PPUSH
2644: CALL_OW 40
// end ; end_of_file
2648: LD_VAR 0 1
2652: RET
// export Pokryshkin ; export ru_patrol , ru_forest ; export function PrepareRussian ; var i , b , un , veh , tw , bar , skill , vehicles , spot_xy ; begin
2653: LD_INT 0
2655: PPUSH
2656: PPUSH
2657: PPUSH
2658: PPUSH
2659: PPUSH
2660: PPUSH
2661: PPUSH
2662: PPUSH
2663: PPUSH
2664: PPUSH
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
2665: LD_ADDR_VAR 0 6
2669: PUSH
2670: LD_INT 22
2672: PUSH
2673: LD_INT 3
2675: PUSH
2676: EMPTY
2677: LIST
2678: LIST
2679: PUSH
2680: LD_INT 2
2682: PUSH
2683: LD_INT 30
2685: PUSH
2686: LD_INT 31
2688: PUSH
2689: EMPTY
2690: LIST
2691: LIST
2692: PUSH
2693: LD_INT 30
2695: PUSH
2696: LD_INT 32
2698: PUSH
2699: EMPTY
2700: LIST
2701: LIST
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: LIST
2707: PUSH
2708: EMPTY
2709: LIST
2710: LIST
2711: PPUSH
2712: CALL_OW 69
2716: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
2717: LD_ADDR_VAR 0 7
2721: PUSH
2722: LD_INT 22
2724: PUSH
2725: LD_INT 3
2727: PUSH
2728: EMPTY
2729: LIST
2730: LIST
2731: PUSH
2732: LD_INT 30
2734: PUSH
2735: LD_INT 4
2737: PUSH
2738: EMPTY
2739: LIST
2740: LIST
2741: PUSH
2742: EMPTY
2743: LIST
2744: LIST
2745: PPUSH
2746: CALL_OW 69
2750: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
2751: LD_ADDR_VAR 0 2
2755: PUSH
2756: LD_INT 22
2758: PUSH
2759: LD_INT 3
2761: PUSH
2762: EMPTY
2763: LIST
2764: LIST
2765: PUSH
2766: LD_INT 30
2768: PUSH
2769: LD_INT 1
2771: PUSH
2772: EMPTY
2773: LIST
2774: LIST
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PPUSH
2780: CALL_OW 69
2784: PUSH
2785: FOR_IN
2786: IFFALSE 2830
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
2788: LD_VAR 0 2
2792: PPUSH
2793: CALL_OW 274
2797: PPUSH
2798: LD_INT 1
2800: PPUSH
2801: LD_INT 1000
2803: PPUSH
2804: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 300 ) ;
2808: LD_VAR 0 2
2812: PPUSH
2813: CALL_OW 274
2817: PPUSH
2818: LD_INT 2
2820: PPUSH
2821: LD_INT 300
2823: PPUSH
2824: CALL_OW 277
// end ;
2828: GO 2785
2830: POP
2831: POP
// uc_side := 3 ;
2832: LD_ADDR_OWVAR 20
2836: PUSH
2837: LD_INT 3
2839: ST_TO_ADDR
// uc_nation := 3 ;
2840: LD_ADDR_OWVAR 21
2844: PUSH
2845: LD_INT 3
2847: ST_TO_ADDR
// skill := [ 2 , 2 , 3 ] [ Difficulty ] ;
2848: LD_ADDR_VAR 0 8
2852: PUSH
2853: LD_INT 2
2855: PUSH
2856: LD_INT 2
2858: PUSH
2859: LD_INT 3
2861: PUSH
2862: EMPTY
2863: LIST
2864: LIST
2865: LIST
2866: PUSH
2867: LD_OWVAR 67
2871: ARRAY
2872: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
2873: LD_ADDR_EXP 39
2877: PUSH
2878: LD_STRING Pokryshkin
2880: PPUSH
2881: LD_INT 0
2883: PPUSH
2884: CALL 349 0 2
2888: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
2889: LD_EXP 39
2893: PPUSH
2894: LD_INT 63
2896: PPUSH
2897: LD_INT 21
2899: PPUSH
2900: LD_INT 0
2902: PPUSH
2903: CALL_OW 48
// ComHold ( Pokryshkin ) ;
2907: LD_EXP 39
2911: PPUSH
2912: CALL_OW 140
// InitHc ;
2916: CALL_OW 19
// for i in tw do
2920: LD_ADDR_VAR 0 2
2924: PUSH
2925: LD_VAR 0 6
2929: PUSH
2930: FOR_IN
2931: IFFALSE 2980
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
2933: LD_VAR 0 2
2937: PPUSH
2938: LD_INT 42
2940: PUSH
2941: LD_INT 43
2943: PUSH
2944: EMPTY
2945: LIST
2946: LIST
2947: PUSH
2948: LD_INT 1
2950: PPUSH
2951: LD_INT 2
2953: PPUSH
2954: CALL_OW 12
2958: ARRAY
2959: PPUSH
2960: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
2964: LD_VAR 0 8
2968: PPUSH
2969: LD_VAR 0 2
2973: PPUSH
2974: CALL 666 0 2
// end ;
2978: GO 2930
2980: POP
2981: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
2982: LD_ADDR_VAR 0 10
2986: PUSH
2987: LD_INT 100
2989: PUSH
2990: LD_INT 9
2992: PUSH
2993: EMPTY
2994: LIST
2995: LIST
2996: PUSH
2997: LD_INT 135
2999: PUSH
3000: LD_INT 60
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: PUSH
3007: LD_INT 41
3009: PUSH
3010: LD_INT 6
3012: PUSH
3013: EMPTY
3014: LIST
3015: LIST
3016: PUSH
3017: LD_INT 22
3019: PUSH
3020: LD_INT 9
3022: PUSH
3023: EMPTY
3024: LIST
3025: LIST
3026: PUSH
3027: LD_INT 84
3029: PUSH
3030: LD_INT 14
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: PUSH
3037: EMPTY
3038: LIST
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: ST_TO_ADDR
// vehicles := [ ] ;
3044: LD_ADDR_VAR 0 9
3048: PUSH
3049: EMPTY
3050: ST_TO_ADDR
// for i in spot_xy do
3051: LD_ADDR_VAR 0 2
3055: PUSH
3056: LD_VAR 0 10
3060: PUSH
3061: FOR_IN
3062: IFFALSE 3216
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
3064: LD_ADDR_VAR 0 5
3068: PUSH
3069: LD_INT 3
3071: PPUSH
3072: LD_INT 3
3074: PPUSH
3075: LD_INT 22
3077: PPUSH
3078: LD_INT 1
3080: PPUSH
3081: LD_INT 1
3083: PPUSH
3084: LD_INT 42
3086: PUSH
3087: LD_INT 43
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: PUSH
3094: LD_INT 1
3096: PPUSH
3097: LD_INT 2
3099: PPUSH
3100: CALL_OW 12
3104: ARRAY
3105: PPUSH
3106: LD_INT 100
3108: PPUSH
3109: CALL 406 0 7
3113: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3114: LD_ADDR_VAR 0 9
3118: PUSH
3119: LD_VAR 0 9
3123: PPUSH
3124: LD_VAR 0 9
3128: PUSH
3129: LD_INT 1
3131: PLUS
3132: PPUSH
3133: LD_VAR 0 5
3137: PPUSH
3138: CALL_OW 2
3142: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3143: LD_VAR 0 5
3147: PPUSH
3148: LD_INT 3
3150: PPUSH
3151: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3155: LD_VAR 0 5
3159: PPUSH
3160: LD_VAR 0 2
3164: PUSH
3165: LD_INT 1
3167: ARRAY
3168: PPUSH
3169: LD_VAR 0 2
3173: PUSH
3174: LD_INT 2
3176: ARRAY
3177: PPUSH
3178: LD_INT 0
3180: PPUSH
3181: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3185: LD_INT 0
3187: PPUSH
3188: LD_INT 3
3190: PPUSH
3191: LD_VAR 0 8
3195: PPUSH
3196: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3200: CALL_OW 44
3204: PPUSH
3205: LD_VAR 0 5
3209: PPUSH
3210: CALL_OW 52
// end ;
3214: GO 3061
3216: POP
3217: POP
// for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
3218: LD_ADDR_VAR 0 2
3222: PUSH
3223: DOUBLE
3224: LD_INT 1
3226: DEC
3227: ST_TO_ADDR
3228: LD_INT 3
3230: PUSH
3231: LD_INT 4
3233: PUSH
3234: LD_INT 5
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PUSH
3242: LD_OWVAR 67
3246: ARRAY
3247: PUSH
3248: FOR_TO
3249: IFFALSE 3309
// begin PrepareHuman ( false , 1 , skill ) ;
3251: LD_INT 0
3253: PPUSH
3254: LD_INT 1
3256: PPUSH
3257: LD_VAR 0 8
3261: PPUSH
3262: CALL_OW 380
// un := CreateHuman ;
3266: LD_ADDR_VAR 0 4
3270: PUSH
3271: CALL_OW 44
3275: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3276: LD_VAR 0 4
3280: PPUSH
3281: LD_INT 11
3283: PPUSH
3284: LD_INT 0
3286: PPUSH
3287: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3291: LD_ADDR_EXP 41
3295: PUSH
3296: LD_EXP 41
3300: PUSH
3301: LD_VAR 0 4
3305: ADD
3306: ST_TO_ADDR
// end ;
3307: GO 3248
3309: POP
3310: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3311: LD_ADDR_VAR 0 2
3315: PUSH
3316: DOUBLE
3317: LD_INT 1
3319: DEC
3320: ST_TO_ADDR
3321: LD_INT 2
3323: PUSH
3324: LD_INT 3
3326: PUSH
3327: LD_INT 4
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: LIST
3334: PUSH
3335: LD_OWVAR 67
3339: ARRAY
3340: PUSH
3341: FOR_TO
3342: IFFALSE 3386
// begin PrepareHuman ( false , 1 , skill ) ;
3344: LD_INT 0
3346: PPUSH
3347: LD_INT 1
3349: PPUSH
3350: LD_VAR 0 8
3354: PPUSH
3355: CALL_OW 380
// un := CreateHuman ;
3359: LD_ADDR_VAR 0 4
3363: PUSH
3364: CALL_OW 44
3368: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
3369: LD_VAR 0 4
3373: PPUSH
3374: LD_INT 12
3376: PPUSH
3377: LD_INT 0
3379: PPUSH
3380: CALL_OW 49
// end ;
3384: GO 3341
3386: POP
3387: POP
// end ; end_of_file
3388: LD_VAR 0 1
3392: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
3393: LD_INT 0
3395: PPUSH
3396: PPUSH
3397: PPUSH
3398: PPUSH
3399: PPUSH
3400: PPUSH
3401: PPUSH
// InGameOn ;
3402: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
3406: LD_EXP 24
3410: PPUSH
3411: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
3415: LD_EXP 24
3419: PPUSH
3420: LD_EXP 31
3424: PPUSH
3425: CALL_OW 119
// if Bierezov then
3429: LD_EXP 32
3433: IFFALSE 3449
// ComTurnUnit ( Bierezov , Cornel ) ;
3435: LD_EXP 32
3439: PPUSH
3440: LD_EXP 31
3444: PPUSH
3445: CALL_OW 119
// for i in jmm_units do
3449: LD_ADDR_VAR 0 2
3453: PUSH
3454: LD_EXP 2
3458: PUSH
3459: FOR_IN
3460: IFFALSE 3478
// ComTurnUnit ( i , Cornel ) ;
3462: LD_VAR 0 2
3466: PPUSH
3467: LD_EXP 31
3471: PPUSH
3472: CALL_OW 119
3476: GO 3459
3478: POP
3479: POP
// units := cornel_units union Cornel ;
3480: LD_ADDR_VAR 0 3
3484: PUSH
3485: LD_EXP 4
3489: PUSH
3490: LD_EXP 31
3494: UNION
3495: ST_TO_ADDR
// repeat wait ( 1 ) ;
3496: LD_INT 1
3498: PPUSH
3499: CALL_OW 67
// for i in units do
3503: LD_ADDR_VAR 0 2
3507: PUSH
3508: LD_VAR 0 3
3512: PUSH
3513: FOR_IN
3514: IFFALSE 3547
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
3516: LD_VAR 0 2
3520: PPUSH
3521: LD_EXP 24
3525: PPUSH
3526: CALL_OW 250
3530: PPUSH
3531: LD_EXP 24
3535: PPUSH
3536: CALL_OW 251
3540: PPUSH
3541: CALL_OW 111
3545: GO 3513
3547: POP
3548: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
3549: LD_VAR 0 3
3553: PPUSH
3554: LD_INT 92
3556: PUSH
3557: LD_EXP 24
3561: PPUSH
3562: CALL_OW 250
3566: PUSH
3567: LD_EXP 24
3571: PPUSH
3572: CALL_OW 251
3576: PUSH
3577: LD_INT 10
3579: PUSH
3580: EMPTY
3581: LIST
3582: LIST
3583: LIST
3584: LIST
3585: PPUSH
3586: CALL_OW 72
3590: PUSH
3591: LD_VAR 0 3
3595: EQUAL
3596: IFFALSE 3496
// for i in units do
3598: LD_ADDR_VAR 0 2
3602: PUSH
3603: LD_VAR 0 3
3607: PUSH
3608: FOR_IN
3609: IFFALSE 3627
// ComTurnUnit ( i , JMM ) ;
3611: LD_VAR 0 2
3615: PPUSH
3616: LD_EXP 24
3620: PPUSH
3621: CALL_OW 119
3625: GO 3608
3627: POP
3628: POP
// ComTurnUnit ( Cornel , JMM ) ;
3629: LD_EXP 31
3633: PPUSH
3634: LD_EXP 24
3638: PPUSH
3639: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
3643: LD_EXP 24
3647: PPUSH
3648: LD_STRING D1-JMM-1
3650: PPUSH
3651: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
3655: LD_EXP 31
3659: PPUSH
3660: LD_STRING D1-Corn-1
3662: PPUSH
3663: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
3667: LD_EXP 24
3671: PPUSH
3672: LD_EXP 31
3676: PPUSH
3677: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
3681: LD_EXP 31
3685: PPUSH
3686: LD_EXP 24
3690: PPUSH
3691: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
3695: LD_INT 35
3697: PPUSH
3698: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
3702: LD_EXP 24
3706: PPUSH
3707: LD_EXP 31
3711: PPUSH
3712: CALL_OW 296
3716: PUSH
3717: LD_INT 6
3719: LESS
3720: IFFALSE 3695
// ChangeSideFog ( 4 , 1 ) ;
3722: LD_INT 4
3724: PPUSH
3725: LD_INT 1
3727: PPUSH
3728: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
3732: LD_EXP 24
3736: PPUSH
3737: LD_EXP 31
3741: PPUSH
3742: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
3746: LD_EXP 31
3750: PPUSH
3751: LD_EXP 24
3755: PPUSH
3756: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
3760: LD_EXP 24
3764: PPUSH
3765: LD_STRING D1-JMM-2
3767: PPUSH
3768: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
3772: LD_EXP 24
3776: PPUSH
3777: LD_STRING D1-JMM-2a
3779: PPUSH
3780: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
3784: LD_EXP 31
3788: PPUSH
3789: LD_STRING D1-Corn-2
3791: PPUSH
3792: CALL_OW 88
// if bierezov_exist or debug then
3796: LD_EXP 5
3800: PUSH
3801: LD_EXP 1
3805: OR
3806: IFFALSE 4047
// begin ComTurnUnit ( Cornel , Bierezov ) ;
3808: LD_EXP 31
3812: PPUSH
3813: LD_EXP 32
3817: PPUSH
3818: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
3822: LD_INT 10
3824: PPUSH
3825: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
3829: LD_EXP 31
3833: PPUSH
3834: LD_STRING D1a-Corn-1
3836: PPUSH
3837: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
3841: LD_EXP 24
3845: PPUSH
3846: LD_EXP 32
3850: PPUSH
3851: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
3855: LD_EXP 32
3859: PPUSH
3860: LD_EXP 24
3864: PPUSH
3865: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
3869: LD_EXP 24
3873: PPUSH
3874: LD_STRING D1a-JMM-1
3876: PPUSH
3877: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
3881: LD_EXP 24
3885: PPUSH
3886: LD_EXP 31
3890: PPUSH
3891: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
3895: LD_EXP 31
3899: PPUSH
3900: LD_EXP 24
3904: PPUSH
3905: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
3909: LD_EXP 31
3913: PPUSH
3914: LD_STRING D1a-Corn-2
3916: PPUSH
3917: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
3921: LD_EXP 24
3925: PPUSH
3926: LD_STRING D1a-JMM-2
3928: PPUSH
3929: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
3933: LD_EXP 31
3937: PPUSH
3938: LD_STRING D1a-Corn-3
3940: PPUSH
3941: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
3945: LD_EXP 24
3949: PPUSH
3950: LD_STRING D1a-JMM-3
3952: PPUSH
3953: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
3957: LD_EXP 31
3961: PPUSH
3962: LD_STRING D1a-Corn-4
3964: PPUSH
3965: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
3969: LD_EXP 24
3973: PPUSH
3974: LD_STRING D1a-JMM-4
3976: PPUSH
3977: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
3981: LD_EXP 31
3985: PPUSH
3986: LD_STRING D1a-Corn-5
3988: PPUSH
3989: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
3993: LD_EXP 32
3997: PPUSH
3998: LD_EXP 31
4002: PPUSH
4003: CALL_OW 250
4007: PPUSH
4008: LD_EXP 31
4012: PPUSH
4013: CALL_OW 251
4017: PUSH
4018: LD_INT 2
4020: MINUS
4021: PPUSH
4022: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
4026: LD_EXP 32
4030: PPUSH
4031: LD_EXP 31
4035: PPUSH
4036: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
4040: LD_INT 10
4042: PPUSH
4043: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
4047: LD_EXP 24
4051: PPUSH
4052: LD_STRING D1b-JMM-1
4054: PPUSH
4055: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
4059: LD_EXP 31
4063: PPUSH
4064: LD_STRING D1b-Corn-1
4066: PPUSH
4067: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
4071: LD_EXP 24
4075: PPUSH
4076: LD_STRING D1b-JMM-2
4078: PPUSH
4079: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
4083: LD_EXP 31
4087: PPUSH
4088: LD_STRING D1b-Corn-2
4090: PPUSH
4091: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
4095: LD_EXP 24
4099: PPUSH
4100: LD_STRING D1b-JMM-3
4102: PPUSH
4103: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
4107: LD_INT 10
4109: PPUSH
4110: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
4114: LD_EXP 33
4118: PPUSH
4119: LD_STRING D1b-Pow-3
4121: PPUSH
4122: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
4126: LD_EXP 24
4130: PPUSH
4131: LD_STRING D1b-JMM-4
4133: PPUSH
4134: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
4138: LD_EXP 31
4142: PPUSH
4143: LD_STRING D1b-Corn-4
4145: PPUSH
4146: CALL_OW 88
// if Khatam then
4150: LD_EXP 28
4154: IFFALSE 4170
// Say ( Khatam , D1b-Khat-4 ) else
4156: LD_EXP 28
4160: PPUSH
4161: LD_STRING D1b-Khat-4
4163: PPUSH
4164: CALL_OW 88
4168: GO 4206
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
4170: LD_EXP 4
4174: PPUSH
4175: LD_INT 26
4177: PUSH
4178: LD_INT 1
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: PPUSH
4185: CALL_OW 72
4189: PUSH
4190: LD_EXP 31
4194: PUSH
4195: EMPTY
4196: LIST
4197: DIFF
4198: PPUSH
4199: LD_STRING D1b-Sol1-4
4201: PPUSH
4202: CALL 494 0 2
// if Cyrus then
4206: LD_EXP 26
4210: IFFALSE 4224
// Say ( Cyrus , D1b-Cyrus-4 ) ;
4212: LD_EXP 26
4216: PPUSH
4217: LD_STRING D1b-Cyrus-4
4219: PPUSH
4220: CALL_OW 88
// if Lisa then
4224: LD_EXP 27
4228: IFFALSE 4286
// begin Say ( Lisa , D1b-Lisa-4 ) ;
4230: LD_EXP 27
4234: PPUSH
4235: LD_STRING D1b-Lisa-4
4237: PPUSH
4238: CALL_OW 88
// if Cyrus then
4242: LD_EXP 26
4246: IFFALSE 4286
// begin if not IsInUnit ( Cyrus ) then
4248: LD_EXP 26
4252: PPUSH
4253: CALL_OW 310
4257: NOT
4258: IFFALSE 4274
// ComTurnUnit ( Cyrus , Lisa ) ;
4260: LD_EXP 26
4264: PPUSH
4265: LD_EXP 27
4269: PPUSH
4270: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
4274: LD_EXP 26
4278: PPUSH
4279: LD_STRING D1b-Cyrus-5
4281: PPUSH
4282: CALL_OW 88
// end ; end ; SelectGroup ;
4286: CALL 2303 0 0
// Say ( JMM , D1d-JMM-1 ) ;
4290: LD_EXP 24
4294: PPUSH
4295: LD_STRING D1d-JMM-1
4297: PPUSH
4298: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
4302: LD_EXP 31
4306: PPUSH
4307: LD_STRING D1d-Corn-1
4309: PPUSH
4310: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
4314: LD_ADDR_VAR 0 2
4318: PUSH
4319: LD_EXP 2
4323: PUSH
4324: LD_EXP 4
4328: ADD
4329: PUSH
4330: LD_EXP 24
4334: ADD
4335: PUSH
4336: FOR_IN
4337: IFFALSE 4350
// ComHold ( i ) ;
4339: LD_VAR 0 2
4343: PPUSH
4344: CALL_OW 140
4348: GO 4336
4350: POP
4351: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
4352: LD_ADDR_VAR 0 4
4356: PUSH
4357: LD_INT 22
4359: PUSH
4360: LD_INT 1
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: PUSH
4367: LD_INT 21
4369: PUSH
4370: LD_INT 2
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: PPUSH
4381: CALL_OW 69
4385: ST_TO_ADDR
// if vehicles then
4386: LD_VAR 0 4
4390: IFFALSE 4728
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
4392: LD_EXP 4
4396: PPUSH
4397: LD_INT 55
4399: PUSH
4400: EMPTY
4401: LIST
4402: PPUSH
4403: CALL_OW 72
4407: IFFALSE 4446
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
4409: LD_ADDR_VAR 0 2
4413: PUSH
4414: LD_EXP 4
4418: PPUSH
4419: LD_INT 55
4421: PUSH
4422: EMPTY
4423: LIST
4424: PPUSH
4425: CALL_OW 72
4429: PUSH
4430: FOR_IN
4431: IFFALSE 4444
// ComExitVehicle ( i ) ;
4433: LD_VAR 0 2
4437: PPUSH
4438: CALL_OW 121
4442: GO 4430
4444: POP
4445: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
4446: LD_ADDR_VAR 0 5
4450: PUSH
4451: LD_VAR 0 4
4455: PPUSH
4456: LD_INT 34
4458: PUSH
4459: LD_INT 51
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PPUSH
4466: CALL_OW 72
4470: ST_TO_ADDR
// if cargos then
4471: LD_VAR 0 5
4475: IFFALSE 4658
// begin vehicles := cargos ;
4477: LD_ADDR_VAR 0 4
4481: PUSH
4482: LD_VAR 0 5
4486: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
4487: LD_ADDR_VAR 0 6
4491: PUSH
4492: LD_STRING 02_resources_4
4494: PPUSH
4495: LD_INT 0
4497: PPUSH
4498: CALL_OW 30
4502: ST_TO_ADDR
// if debug and not resources then
4503: LD_EXP 1
4507: PUSH
4508: LD_VAR 0 6
4512: NOT
4513: AND
4514: IFFALSE 4524
// resources := 160 ;
4516: LD_ADDR_VAR 0 6
4520: PUSH
4521: LD_INT 160
4523: ST_TO_ADDR
// if resources mod 10 then
4524: LD_VAR 0 6
4528: PUSH
4529: LD_INT 10
4531: MOD
4532: IFFALSE 4554
// resources := resources - resources mod 10 ;
4534: LD_ADDR_VAR 0 6
4538: PUSH
4539: LD_VAR 0 6
4543: PUSH
4544: LD_VAR 0 6
4548: PUSH
4549: LD_INT 10
4551: MOD
4552: MINUS
4553: ST_TO_ADDR
// if resources then
4554: LD_VAR 0 6
4558: IFFALSE 4658
// for i in cargos do
4560: LD_ADDR_VAR 0 2
4564: PUSH
4565: LD_VAR 0 5
4569: PUSH
4570: FOR_IN
4571: IFFALSE 4656
// begin if resources < 100 then
4573: LD_VAR 0 6
4577: PUSH
4578: LD_INT 100
4580: LESS
4581: IFFALSE 4603
// begin cargo := resources ;
4583: LD_ADDR_VAR 0 7
4587: PUSH
4588: LD_VAR 0 6
4592: ST_TO_ADDR
// resources := 0 ;
4593: LD_ADDR_VAR 0 6
4597: PUSH
4598: LD_INT 0
4600: ST_TO_ADDR
// end else
4601: GO 4625
// begin cargo := 100 ;
4603: LD_ADDR_VAR 0 7
4607: PUSH
4608: LD_INT 100
4610: ST_TO_ADDR
// resources := resources - 100 ;
4611: LD_ADDR_VAR 0 6
4615: PUSH
4616: LD_VAR 0 6
4620: PUSH
4621: LD_INT 100
4623: MINUS
4624: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
4625: LD_VAR 0 2
4629: PPUSH
4630: LD_INT 1
4632: PPUSH
4633: LD_VAR 0 7
4637: PPUSH
4638: CALL_OW 290
// if resources = 0 then
4642: LD_VAR 0 6
4646: PUSH
4647: LD_INT 0
4649: EQUAL
4650: IFFALSE 4654
// break ;
4652: GO 4656
// end ;
4654: GO 4570
4656: POP
4657: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
4658: LD_VAR 0 4
4662: PUSH
4663: LD_INT 1
4665: ARRAY
4666: PPUSH
4667: CALL_OW 311
4671: PPUSH
4672: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
4676: LD_VAR 0 4
4680: PUSH
4681: LD_INT 1
4683: ARRAY
4684: PPUSH
4685: LD_INT 4
4687: PPUSH
4688: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
4692: LD_EXP 31
4696: PPUSH
4697: LD_VAR 0 4
4701: PUSH
4702: LD_INT 1
4704: ARRAY
4705: PPUSH
4706: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
4710: LD_INT 35
4712: PPUSH
4713: CALL_OW 67
// until IsInUnit ( Cornel ) ;
4717: LD_EXP 31
4721: PPUSH
4722: CALL_OW 310
4726: IFFALSE 4710
// end ; InGameOff ;
4728: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
4732: LD_STRING M1
4734: PPUSH
4735: CALL_OW 337
// cornel_active := true ;
4739: LD_ADDR_EXP 6
4743: PUSH
4744: LD_INT 1
4746: ST_TO_ADDR
// end ;
4747: LD_VAR 0 1
4751: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
4752: LD_EXP 24
4756: PPUSH
4757: LD_EXP 34
4761: PPUSH
4762: CALL_OW 296
4766: PUSH
4767: LD_INT 10
4769: LESS
4770: IFFALSE 5862
4772: GO 4774
4774: DISABLE
4775: LD_INT 0
4777: PPUSH
4778: PPUSH
4779: PPUSH
4780: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
4781: LD_ADDR_VAR 0 2
4785: PUSH
4786: LD_INT 89
4788: PUSH
4789: LD_INT 34
4791: PUSH
4792: EMPTY
4793: LIST
4794: LIST
4795: PUSH
4796: LD_INT 138
4798: PUSH
4799: LD_INT 63
4801: PUSH
4802: EMPTY
4803: LIST
4804: LIST
4805: PUSH
4806: LD_INT 196
4808: PUSH
4809: LD_INT 84
4811: PUSH
4812: EMPTY
4813: LIST
4814: LIST
4815: PUSH
4816: LD_INT 135
4818: PUSH
4819: LD_INT 52
4821: PUSH
4822: EMPTY
4823: LIST
4824: LIST
4825: PUSH
4826: LD_INT 103
4828: PUSH
4829: LD_INT 39
4831: PUSH
4832: EMPTY
4833: LIST
4834: LIST
4835: PUSH
4836: LD_INT 58
4838: PUSH
4839: LD_INT 30
4841: PUSH
4842: EMPTY
4843: LIST
4844: LIST
4845: PUSH
4846: LD_INT 38
4848: PUSH
4849: LD_INT 51
4851: PUSH
4852: EMPTY
4853: LIST
4854: LIST
4855: PUSH
4856: EMPTY
4857: LIST
4858: LIST
4859: LIST
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: ST_TO_ADDR
// InGameOn ;
4865: CALL_OW 8
// if jmm_units then
4869: LD_EXP 2
4873: IFFALSE 4937
// for i in jmm_units do
4875: LD_ADDR_VAR 0 1
4879: PUSH
4880: LD_EXP 2
4884: PUSH
4885: FOR_IN
4886: IFFALSE 4935
// begin if GetDistUnits ( i , JMM ) < 10 then
4888: LD_VAR 0 1
4892: PPUSH
4893: LD_EXP 24
4897: PPUSH
4898: CALL_OW 296
4902: PUSH
4903: LD_INT 10
4905: LESS
4906: IFFALSE 4924
// ComTurnUnit ( i , JMM ) else
4908: LD_VAR 0 1
4912: PPUSH
4913: LD_EXP 24
4917: PPUSH
4918: CALL_OW 119
4922: GO 4933
// ComHold ( i ) ;
4924: LD_VAR 0 1
4928: PPUSH
4929: CALL_OW 140
// end ;
4933: GO 4885
4935: POP
4936: POP
// ComMoveUnit ( JMM , Lynch ) ;
4937: LD_EXP 24
4941: PPUSH
4942: LD_EXP 34
4946: PPUSH
4947: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
4951: LD_INT 35
4953: PPUSH
4954: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
4958: LD_EXP 24
4962: PPUSH
4963: LD_EXP 34
4967: PPUSH
4968: CALL_OW 296
4972: PUSH
4973: LD_INT 6
4975: LESS
4976: IFFALSE 4951
// ComTurnUnit ( JMM , Lynch ) ;
4978: LD_EXP 24
4982: PPUSH
4983: LD_EXP 34
4987: PPUSH
4988: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
4992: LD_ADDR_VAR 0 1
4996: PUSH
4997: LD_EXP 34
5001: PUSH
5002: LD_EXP 35
5006: PUSH
5007: LD_EXP 36
5011: PUSH
5012: LD_EXP 37
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: LIST
5021: LIST
5022: PUSH
5023: FOR_IN
5024: IFFALSE 5042
// ComTurnUnit ( i , JMM ) ;
5026: LD_VAR 0 1
5030: PPUSH
5031: LD_EXP 24
5035: PPUSH
5036: CALL_OW 119
5040: GO 5023
5042: POP
5043: POP
// Wait ( 0 0$0.3 ) ;
5044: LD_INT 10
5046: PPUSH
5047: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
5051: LD_EXP 24
5055: PPUSH
5056: LD_STRING D2-JMM-1
5058: PPUSH
5059: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
5063: LD_EXP 34
5067: PPUSH
5068: LD_STRING D2-Sol1-1
5070: PPUSH
5071: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
5075: LD_EXP 24
5079: PPUSH
5080: LD_STRING D2-JMM-2
5082: PPUSH
5083: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
5087: LD_EXP 34
5091: PPUSH
5092: LD_STRING D2-Sol1-2
5094: PPUSH
5095: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
5099: LD_EXP 24
5103: PPUSH
5104: LD_STRING D2-JMM-3
5106: PPUSH
5107: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
5111: LD_EXP 34
5115: PPUSH
5116: LD_STRING D2-Sol1-3
5118: PPUSH
5119: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
5123: LD_ADDR_VAR 0 1
5127: PUSH
5128: LD_INT 22
5130: PUSH
5131: LD_INT 8
5133: PUSH
5134: EMPTY
5135: LIST
5136: LIST
5137: PPUSH
5138: CALL_OW 69
5142: PUSH
5143: FOR_IN
5144: IFFALSE 5160
// SetSide ( i , 1 ) ;
5146: LD_VAR 0 1
5150: PPUSH
5151: LD_INT 1
5153: PPUSH
5154: CALL_OW 235
5158: GO 5143
5160: POP
5161: POP
// Say ( JMM , D2-JMM-4 ) ;
5162: LD_EXP 24
5166: PPUSH
5167: LD_STRING D2-JMM-4
5169: PPUSH
5170: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
5174: LD_INT 1
5176: PPUSH
5177: LD_INT 5
5179: PPUSH
5180: CALL_OW 332
// for i = 1 to points do
5184: LD_ADDR_VAR 0 1
5188: PUSH
5189: DOUBLE
5190: LD_INT 1
5192: DEC
5193: ST_TO_ADDR
5194: LD_VAR 0 2
5198: PUSH
5199: FOR_TO
5200: IFFALSE 5375
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
5202: LD_VAR 0 2
5206: PUSH
5207: LD_VAR 0 1
5211: ARRAY
5212: PUSH
5213: LD_INT 1
5215: ARRAY
5216: PPUSH
5217: LD_VAR 0 2
5221: PUSH
5222: LD_VAR 0 1
5226: ARRAY
5227: PUSH
5228: LD_INT 2
5230: ARRAY
5231: PPUSH
5232: CALL_OW 84
// if i = 1 then
5236: LD_VAR 0 1
5240: PUSH
5241: LD_INT 1
5243: EQUAL
5244: IFFALSE 5258
// Say ( Lynch , D2-Sol1-4 ) ;
5246: LD_EXP 34
5250: PPUSH
5251: LD_STRING D2-Sol1-4
5253: PPUSH
5254: CALL_OW 88
// if i = 2 then
5258: LD_VAR 0 1
5262: PUSH
5263: LD_INT 2
5265: EQUAL
5266: IFFALSE 5280
// Say ( JMM , D2-JMM-5 ) ;
5268: LD_EXP 24
5272: PPUSH
5273: LD_STRING D2-JMM-5
5275: PPUSH
5276: CALL_OW 88
// if i = 4 then
5280: LD_VAR 0 1
5284: PUSH
5285: LD_INT 4
5287: EQUAL
5288: IFFALSE 5312
// begin RevealFogArea ( 1 , troopsArea ) ;
5290: LD_INT 1
5292: PPUSH
5293: LD_INT 6
5295: PPUSH
5296: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
5300: LD_EXP 34
5304: PPUSH
5305: LD_STRING D2-Sol1-5
5307: PPUSH
5308: CALL_OW 88
// end ; if i = 5 then
5312: LD_VAR 0 1
5316: PUSH
5317: LD_INT 5
5319: EQUAL
5320: IFFALSE 5334
// Say ( JMM , D2-JMM-6 ) ;
5322: LD_EXP 24
5326: PPUSH
5327: LD_STRING D2-JMM-6
5329: PPUSH
5330: CALL_OW 88
// if i = 7 then
5334: LD_VAR 0 1
5338: PUSH
5339: LD_INT 7
5341: EQUAL
5342: IFFALSE 5366
// begin RevealFogArea ( 1 , forestArea ) ;
5344: LD_INT 1
5346: PPUSH
5347: LD_INT 7
5349: PPUSH
5350: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
5354: LD_EXP 34
5358: PPUSH
5359: LD_STRING D2-Sol1-6
5361: PPUSH
5362: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
5366: LD_INT 46
5368: PPUSH
5369: CALL_OW 67
// end ;
5373: GO 5199
5375: POP
5376: POP
// CenterNowOnUnits ( JMM ) ;
5377: LD_EXP 24
5381: PPUSH
5382: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
5386: LD_EXP 24
5390: PPUSH
5391: LD_STRING D2-JMM-7
5393: PPUSH
5394: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
5398: LD_EXP 34
5402: PPUSH
5403: LD_STRING D2-Sol1-7
5405: PPUSH
5406: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
5410: LD_EXP 24
5414: PPUSH
5415: LD_STRING D2-JMM-8
5417: PPUSH
5418: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
5422: LD_ADDR_VAR 0 4
5426: PUSH
5427: LD_INT 22
5429: PUSH
5430: LD_INT 1
5432: PUSH
5433: EMPTY
5434: LIST
5435: LIST
5436: PUSH
5437: LD_INT 30
5439: PUSH
5440: LD_INT 31
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: PUSH
5447: EMPTY
5448: LIST
5449: LIST
5450: PPUSH
5451: CALL_OW 69
5455: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
5456: LD_EXP 34
5460: PPUSH
5461: LD_VAR 0 4
5465: PUSH
5466: LD_INT 1
5468: ARRAY
5469: PPUSH
5470: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
5474: LD_ADDR_VAR 0 3
5478: PUSH
5479: LD_EXP 2
5483: PPUSH
5484: LD_INT 25
5486: PUSH
5487: LD_INT 1
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: PPUSH
5494: CALL_OW 72
5498: PPUSH
5499: LD_EXP 24
5503: PPUSH
5504: CALL_OW 74
5508: ST_TO_ADDR
// if sol then
5509: LD_VAR 0 3
5513: IFFALSE 5553
// if GetDistUnits ( JMM , sol ) < 10 then
5515: LD_EXP 24
5519: PPUSH
5520: LD_VAR 0 3
5524: PPUSH
5525: CALL_OW 296
5529: PUSH
5530: LD_INT 10
5532: LESS
5533: IFFALSE 5553
// ComEnterUnit ( sol , buns [ 2 ] ) ;
5535: LD_VAR 0 3
5539: PPUSH
5540: LD_VAR 0 4
5544: PUSH
5545: LD_INT 2
5547: ARRAY
5548: PPUSH
5549: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
5553: LD_INT 10
5555: PPUSH
5556: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
5560: LD_EXP 24
5564: PPUSH
5565: LD_INT 65
5567: PPUSH
5568: LD_INT 101
5570: PPUSH
5571: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
5575: LD_EXP 24
5579: PPUSH
5580: LD_INT 63
5582: PPUSH
5583: LD_INT 100
5585: PPUSH
5586: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
5590: LD_INT 35
5592: PPUSH
5593: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
5597: LD_EXP 24
5601: PPUSH
5602: LD_INT 65
5604: PPUSH
5605: LD_INT 101
5607: PPUSH
5608: CALL_OW 307
5612: IFFALSE 5590
// Say ( JMM , D2a-JMM-1 ) ;
5614: LD_EXP 24
5618: PPUSH
5619: LD_STRING D2a-JMM-1
5621: PPUSH
5622: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
5626: LD_EXP 35
5630: PPUSH
5631: LD_INT 66
5633: PPUSH
5634: LD_INT 103
5636: PPUSH
5637: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
5641: LD_INT 35
5643: PPUSH
5644: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
5648: LD_EXP 35
5652: PPUSH
5653: LD_INT 66
5655: PPUSH
5656: LD_INT 103
5658: PPUSH
5659: CALL_OW 307
5663: IFFALSE 5641
// ComTurnUnit ( Walker , JMM ) ;
5665: LD_EXP 35
5669: PPUSH
5670: LD_EXP 24
5674: PPUSH
5675: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
5679: LD_EXP 35
5683: PPUSH
5684: LD_STRING D2a-Sci1-1
5686: PPUSH
5687: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
5691: LD_EXP 24
5695: PPUSH
5696: LD_EXP 35
5700: PPUSH
5701: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
5705: LD_EXP 24
5709: PPUSH
5710: LD_STRING D2a-JMM-2
5712: PPUSH
5713: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
5717: LD_EXP 35
5721: PPUSH
5722: LD_STRING D2a-Sci1-2
5724: PPUSH
5725: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
5729: LD_EXP 24
5733: PPUSH
5734: LD_STRING D2a-JMM-3
5736: PPUSH
5737: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
5741: LD_EXP 35
5745: PPUSH
5746: LD_STRING D2a-Sci1-3
5748: PPUSH
5749: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
5753: LD_ADDR_EXP 2
5757: PUSH
5758: LD_EXP 2
5762: PUSH
5763: LD_EXP 34
5767: PUSH
5768: LD_EXP 35
5772: PUSH
5773: LD_EXP 36
5777: PUSH
5778: LD_EXP 37
5782: PUSH
5783: EMPTY
5784: LIST
5785: LIST
5786: LIST
5787: LIST
5788: ADD
5789: ST_TO_ADDR
// for i in jmm_units do
5790: LD_ADDR_VAR 0 1
5794: PUSH
5795: LD_EXP 2
5799: PUSH
5800: FOR_IN
5801: IFFALSE 5826
// if not IsInUnit ( i ) then
5803: LD_VAR 0 1
5807: PPUSH
5808: CALL_OW 310
5812: NOT
5813: IFFALSE 5824
// ComFree ( i ) ;
5815: LD_VAR 0 1
5819: PPUSH
5820: CALL_OW 139
5824: GO 5800
5826: POP
5827: POP
// InGameOff ;
5828: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
5832: LD_STRING MSolar1
5834: PPUSH
5835: CALL_OW 337
// jmm_on_west := true ;
5839: LD_ADDR_EXP 3
5843: PUSH
5844: LD_INT 1
5846: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
5847: LD_INT 1050
5849: PPUSH
5850: CALL_OW 67
// frank_can_return := true ;
5854: LD_ADDR_EXP 10
5858: PUSH
5859: LD_INT 1
5861: ST_TO_ADDR
// end ;
5862: PPOPN 4
5864: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
5865: LD_INT 22
5867: PUSH
5868: LD_INT 1
5870: PUSH
5871: EMPTY
5872: LIST
5873: LIST
5874: PUSH
5875: LD_INT 34
5877: PUSH
5878: LD_INT 51
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: PUSH
5885: LD_INT 92
5887: PUSH
5888: LD_INT 63
5890: PUSH
5891: LD_INT 100
5893: PUSH
5894: LD_INT 5
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: LIST
5907: PUSH
5908: EMPTY
5909: LIST
5910: PPUSH
5911: CALL_OW 69
5915: PUSH
5916: LD_EXP 3
5920: NOT
5921: AND
5922: IFFALSE 6035
5924: GO 5926
5926: DISABLE
5927: LD_INT 0
5929: PPUSH
5930: PPUSH
// begin enable ;
5931: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
5932: LD_ADDR_VAR 0 2
5936: PUSH
5937: LD_INT 22
5939: PUSH
5940: LD_INT 1
5942: PUSH
5943: EMPTY
5944: LIST
5945: LIST
5946: PUSH
5947: LD_INT 34
5949: PUSH
5950: LD_INT 51
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: PUSH
5957: LD_INT 92
5959: PUSH
5960: LD_INT 63
5962: PUSH
5963: LD_INT 100
5965: PUSH
5966: LD_INT 5
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: LIST
5973: LIST
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: LIST
5979: PUSH
5980: EMPTY
5981: LIST
5982: PPUSH
5983: CALL_OW 69
5987: ST_TO_ADDR
// if not filter then
5988: LD_VAR 0 2
5992: NOT
5993: IFFALSE 5997
// exit ;
5995: GO 6035
// for i in filter do
5997: LD_ADDR_VAR 0 1
6001: PUSH
6002: LD_VAR 0 2
6006: PUSH
6007: FOR_IN
6008: IFFALSE 6033
// begin SetFuel ( i , 0 ) ;
6010: LD_VAR 0 1
6014: PPUSH
6015: LD_INT 0
6017: PPUSH
6018: CALL_OW 240
// ComStop ( i ) ;
6022: LD_VAR 0 1
6026: PPUSH
6027: CALL_OW 141
// end ;
6031: GO 6007
6033: POP
6034: POP
// end ;
6035: PPOPN 2
6037: END
// every 0 0$10 trigger frank_can_return do var i , points ;
6038: LD_EXP 10
6042: IFFALSE 7037
6044: GO 6046
6046: DISABLE
6047: LD_INT 0
6049: PPUSH
6050: PPUSH
// begin uc_side := 8 ;
6051: LD_ADDR_OWVAR 20
6055: PUSH
6056: LD_INT 8
6058: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
6059: LD_ADDR_VAR 0 2
6063: PUSH
6064: LD_INT 59
6066: PUSH
6067: LD_INT 71
6069: PUSH
6070: EMPTY
6071: LIST
6072: LIST
6073: PUSH
6074: LD_INT 122
6076: PUSH
6077: LD_INT 117
6079: PUSH
6080: EMPTY
6081: LIST
6082: LIST
6083: PUSH
6084: EMPTY
6085: LIST
6086: LIST
6087: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
6088: LD_ADDR_EXP 38
6092: PUSH
6093: LD_STRING Frank
6095: PPUSH
6096: LD_INT 0
6098: PPUSH
6099: CALL 349 0 2
6103: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
6104: LD_ADDR_VAR 0 1
6108: PUSH
6109: LD_INT 1
6111: PPUSH
6112: LD_INT 2
6114: PPUSH
6115: CALL_OW 12
6119: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
6120: LD_EXP 38
6124: PPUSH
6125: LD_VAR 0 2
6129: PUSH
6130: LD_VAR 0 1
6134: ARRAY
6135: PUSH
6136: LD_INT 1
6138: ARRAY
6139: PPUSH
6140: LD_VAR 0 2
6144: PUSH
6145: LD_VAR 0 1
6149: ARRAY
6150: PUSH
6151: LD_INT 2
6153: ARRAY
6154: PPUSH
6155: LD_INT 0
6157: PPUSH
6158: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
6162: LD_EXP 38
6166: PPUSH
6167: LD_INT 1
6169: PPUSH
6170: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
6174: LD_INT 35
6176: PPUSH
6177: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
6181: LD_EXP 38
6185: PPUSH
6186: LD_EXP 24
6190: PPUSH
6191: CALL_OW 296
6195: PUSH
6196: LD_INT 8
6198: LESS
6199: IFFALSE 6174
// InGameOn ;
6201: CALL_OW 8
// if IsInUnit ( JMM ) then
6205: LD_EXP 24
6209: PPUSH
6210: CALL_OW 310
6214: IFFALSE 6225
// ComFree ( JMM ) ;
6216: LD_EXP 24
6220: PPUSH
6221: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
6225: LD_EXP 24
6229: PPUSH
6230: LD_EXP 38
6234: PPUSH
6235: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
6239: LD_EXP 38
6243: PPUSH
6244: LD_EXP 24
6248: PPUSH
6249: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
6253: LD_EXP 24
6257: PPUSH
6258: LD_STRING D6-JMM-1
6260: PPUSH
6261: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
6265: LD_INT 35
6267: PPUSH
6268: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
6272: LD_EXP 24
6276: PPUSH
6277: LD_EXP 38
6281: PPUSH
6282: CALL_OW 296
6286: PUSH
6287: LD_INT 8
6289: LESS
6290: IFFALSE 6265
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
6292: LD_EXP 27
6296: PUSH
6297: LD_EXP 27
6301: PPUSH
6302: LD_EXP 38
6306: PPUSH
6307: CALL_OW 296
6311: PUSH
6312: LD_INT 20
6314: LESS
6315: AND
6316: IFFALSE 6341
// begin ComFree ( Lisa ) ;
6318: LD_EXP 27
6322: PPUSH
6323: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
6327: LD_EXP 27
6331: PPUSH
6332: LD_EXP 38
6336: PPUSH
6337: CALL_OW 172
// end ; if Lynch then
6341: LD_EXP 34
6345: IFFALSE 6370
// begin ComFree ( Lynch ) ;
6347: LD_EXP 34
6351: PPUSH
6352: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
6356: LD_EXP 34
6360: PPUSH
6361: LD_EXP 38
6365: PPUSH
6366: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
6370: LD_EXP 24
6374: PPUSH
6375: LD_EXP 38
6379: PPUSH
6380: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
6384: LD_EXP 38
6388: PPUSH
6389: LD_EXP 24
6393: PPUSH
6394: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
6398: LD_EXP 38
6402: PPUSH
6403: LD_STRING D6-Frank-1
6405: PPUSH
6406: CALL_OW 88
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
6410: LD_EXP 27
6414: PUSH
6415: LD_EXP 27
6419: PPUSH
6420: LD_EXP 38
6424: PPUSH
6425: CALL_OW 296
6429: PUSH
6430: LD_INT 20
6432: LESS
6433: AND
6434: PUSH
6435: LD_EXP 27
6439: PPUSH
6440: CALL_OW 302
6444: AND
6445: IFFALSE 6526
// begin repeat wait ( 0 0$01 ) ;
6447: LD_INT 35
6449: PPUSH
6450: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
6454: LD_EXP 27
6458: PPUSH
6459: LD_EXP 38
6463: PPUSH
6464: CALL_OW 296
6468: PUSH
6469: LD_INT 7
6471: LESS
6472: IFFALSE 6447
// Say ( Lisa , D6-Lisa-1 ) ;
6474: LD_EXP 27
6478: PPUSH
6479: LD_STRING D6-Lisa-1
6481: PPUSH
6482: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
6486: LD_EXP 27
6490: PPUSH
6491: LD_EXP 38
6495: PPUSH
6496: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
6500: LD_EXP 38
6504: PPUSH
6505: LD_EXP 27
6509: PPUSH
6510: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
6514: LD_EXP 38
6518: PPUSH
6519: LD_STRING D6-Frank-2
6521: PPUSH
6522: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
6526: LD_EXP 34
6530: PUSH
6531: LD_EXP 34
6535: PPUSH
6536: LD_EXP 38
6540: PPUSH
6541: CALL_OW 296
6545: PUSH
6546: LD_INT 20
6548: LESS
6549: AND
6550: PUSH
6551: LD_EXP 34
6555: PPUSH
6556: CALL_OW 302
6560: AND
6561: IFFALSE 6742
// begin ComTurnUnit ( Lynch , JMM ) ;
6563: LD_EXP 34
6567: PPUSH
6568: LD_EXP 24
6572: PPUSH
6573: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
6577: LD_EXP 38
6581: PPUSH
6582: LD_EXP 24
6586: PPUSH
6587: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
6591: LD_EXP 34
6595: PPUSH
6596: LD_STRING D6-Sol1-2
6598: PPUSH
6599: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
6603: LD_EXP 24
6607: PPUSH
6608: LD_STRING D6-JMM-2
6610: PPUSH
6611: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
6615: LD_EXP 38
6619: PPUSH
6620: LD_STRING D6-Frank-3
6622: PPUSH
6623: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
6627: LD_EXP 24
6631: PPUSH
6632: LD_STRING D6-JMM-3
6634: PPUSH
6635: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
6639: LD_EXP 38
6643: PPUSH
6644: LD_STRING D6-Frank-4
6646: PPUSH
6647: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
6651: LD_EXP 38
6655: PPUSH
6656: LD_STRING D6-Frank-4a
6658: PPUSH
6659: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
6663: LD_EXP 24
6667: PPUSH
6668: LD_STRING D6-JMM-4
6670: PPUSH
6671: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
6675: LD_EXP 38
6679: PPUSH
6680: LD_STRING D6-Frank-5
6682: PPUSH
6683: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
6687: LD_EXP 27
6691: PUSH
6692: LD_EXP 27
6696: PPUSH
6697: CALL_OW 302
6701: AND
6702: IFFALSE 6716
// Say ( Lisa , D6-Lisa-5 ) ;
6704: LD_EXP 27
6708: PPUSH
6709: LD_STRING D6-Lisa-5
6711: PPUSH
6712: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
6716: LD_EXP 38
6720: PPUSH
6721: LD_STRING D6-Frank-6
6723: PPUSH
6724: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
6728: LD_EXP 24
6732: PPUSH
6733: LD_STRING D6-JMM-6
6735: PPUSH
6736: CALL_OW 88
// end else
6740: GO 6857
// begin ComTurnUnit ( Frank , JMM ) ;
6742: LD_EXP 38
6746: PPUSH
6747: LD_EXP 24
6751: PPUSH
6752: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
6756: LD_EXP 38
6760: PPUSH
6761: LD_STRING D6-Frank-4
6763: PPUSH
6764: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
6768: LD_EXP 38
6772: PPUSH
6773: LD_STRING D6-Frank-4a
6775: PPUSH
6776: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
6780: LD_EXP 24
6784: PPUSH
6785: LD_STRING D6-JMM-4
6787: PPUSH
6788: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
6792: LD_EXP 38
6796: PPUSH
6797: LD_STRING D6-Frank-5
6799: PPUSH
6800: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
6804: LD_EXP 27
6808: PUSH
6809: LD_EXP 27
6813: PPUSH
6814: CALL_OW 302
6818: AND
6819: IFFALSE 6833
// Say ( Lisa , D6-Lisa-5 ) ;
6821: LD_EXP 27
6825: PPUSH
6826: LD_STRING D6-Lisa-5
6828: PPUSH
6829: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
6833: LD_EXP 38
6837: PPUSH
6838: LD_STRING D6-Frank-6
6840: PPUSH
6841: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
6845: LD_EXP 24
6849: PPUSH
6850: LD_STRING D6-JMM-6
6852: PPUSH
6853: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
6857: LD_STRING Q1
6859: PPUSH
6860: CALL_OW 97
6864: PUSH
6865: LD_INT 1
6867: DOUBLE
6868: EQUAL
6869: IFTRUE 6873
6871: GO 6884
6873: POP
// frank_send_to_scout := true ; 2 :
6874: LD_ADDR_EXP 12
6878: PUSH
6879: LD_INT 1
6881: ST_TO_ADDR
6882: GO 6904
6884: LD_INT 2
6886: DOUBLE
6887: EQUAL
6888: IFTRUE 6892
6890: GO 6903
6892: POP
// frank_send_to_scout := false ; end ;
6893: LD_ADDR_EXP 12
6897: PUSH
6898: LD_INT 0
6900: ST_TO_ADDR
6901: GO 6904
6903: POP
// InGameOff ;
6904: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
6908: LD_EXP 24
6912: PUSH
6913: LD_EXP 27
6917: PUSH
6918: LD_EXP 34
6922: PUSH
6923: EMPTY
6924: LIST
6925: LIST
6926: LIST
6927: PPUSH
6928: CALL_OW 139
// if frank_send_to_scout then
6932: LD_EXP 12
6936: IFFALSE 6993
// begin ComMoveXY ( Frank , 130 , 123 ) ;
6938: LD_EXP 38
6942: PPUSH
6943: LD_INT 130
6945: PPUSH
6946: LD_INT 123
6948: PPUSH
6949: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
6953: LD_INT 35
6955: PPUSH
6956: CALL_OW 67
// until not See ( 1 , Frank ) ;
6960: LD_INT 1
6962: PPUSH
6963: LD_EXP 38
6967: PPUSH
6968: CALL_OW 292
6972: NOT
6973: IFFALSE 6953
// Wait ( 0 0$02 ) ;
6975: LD_INT 70
6977: PPUSH
6978: CALL_OW 67
// RemoveUnit ( Frank ) ;
6982: LD_EXP 38
6986: PPUSH
6987: CALL_OW 64
// end else
6991: GO 7005
// SetSide ( Frank , 1 ) ;
6993: LD_EXP 38
6997: PPUSH
6998: LD_INT 1
7000: PPUSH
7001: CALL_OW 235
// Wait ( [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ) ;
7005: LD_INT 25200
7007: PUSH
7008: LD_INT 23100
7010: PUSH
7011: LD_INT 21000
7013: PUSH
7014: EMPTY
7015: LIST
7016: LIST
7017: LIST
7018: PUSH
7019: LD_OWVAR 67
7023: ARRAY
7024: PPUSH
7025: CALL_OW 67
// cornel_prepared := true ;
7029: LD_ADDR_EXP 9
7033: PUSH
7034: LD_INT 1
7036: ST_TO_ADDR
// end ;
7037: PPOPN 2
7039: END
// every 0 0$01 trigger cornel_prepared do
7040: LD_EXP 9
7044: IFFALSE 7264
7046: GO 7048
7048: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
7049: LD_EXP 31
7053: PPUSH
7054: LD_STRING D3-Corn-1
7056: PPUSH
7057: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
7061: LD_INT 35
7063: PPUSH
7064: CALL_OW 67
// until cornel_counter = 0 ;
7068: LD_EXP 8
7072: PUSH
7073: LD_INT 0
7075: EQUAL
7076: IFFALSE 7061
// SayRadio ( Cornel , D3a-Corn-1 ) ;
7078: LD_EXP 31
7082: PPUSH
7083: LD_STRING D3a-Corn-1
7085: PPUSH
7086: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
7090: LD_EXP 24
7094: PPUSH
7095: LD_STRING D3a-JMM-1
7097: PPUSH
7098: CALL_OW 88
// end_mission_allowed := true ;
7102: LD_ADDR_EXP 18
7106: PUSH
7107: LD_INT 1
7109: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
7110: LD_STRING M2
7112: PPUSH
7113: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
7117: LD_INT 9
7119: PPUSH
7120: LD_INT 1
7122: PPUSH
7123: CALL_OW 424
// Wait ( 0 0$05 ) ;
7127: LD_INT 175
7129: PPUSH
7130: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
7134: LD_EXP 31
7138: PPUSH
7139: LD_STRING D3a-Corn-2
7141: PPUSH
7142: CALL_OW 94
// cornel_attack := true ;
7146: LD_ADDR_EXP 7
7150: PUSH
7151: LD_INT 1
7153: ST_TO_ADDR
// if frank_send_to_scout then
7154: LD_EXP 12
7158: IFFALSE 7264
// begin InitHc ;
7160: CALL_OW 19
// InitUc ;
7164: CALL_OW 18
// uc_side := 8 ;
7168: LD_ADDR_OWVAR 20
7172: PUSH
7173: LD_INT 8
7175: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
7176: LD_ADDR_EXP 38
7180: PUSH
7181: LD_STRING Frank
7183: PPUSH
7184: LD_INT 0
7186: PPUSH
7187: CALL 349 0 2
7191: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
7192: LD_EXP 38
7196: PPUSH
7197: LD_INT 6
7199: PPUSH
7200: LD_INT 9
7202: PPUSH
7203: LD_INT 0
7205: PPUSH
7206: CALL_OW 48
// ComCrawl ( Frank ) ;
7210: LD_EXP 38
7214: PPUSH
7215: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
7219: LD_INT 35
7221: PPUSH
7222: CALL_OW 67
// until See ( 1 , Frank ) ;
7226: LD_INT 1
7228: PPUSH
7229: LD_EXP 38
7233: PPUSH
7234: CALL_OW 292
7238: IFFALSE 7219
// SetSide ( Frank , 1 ) ;
7240: LD_EXP 38
7244: PPUSH
7245: LD_INT 1
7247: PPUSH
7248: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
7252: LD_EXP 38
7256: PPUSH
7257: LD_STRING D6a-Frank-1
7259: PPUSH
7260: CALL_OW 88
// end ; end ;
7264: END
// every 0 0$01 trigger solar_builded do
7265: LD_EXP 11
7269: IFFALSE 7373
7271: GO 7273
7273: DISABLE
// begin Wait ( 0 0$02 ) ;
7274: LD_INT 70
7276: PPUSH
7277: CALL_OW 67
// DialogueOn ;
7281: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
7285: LD_EXP 24
7289: PPUSH
7290: LD_STRING D2b-JMM-1
7292: PPUSH
7293: CALL_OW 88
// if Walker and IsOk ( Walker ) then
7297: LD_EXP 35
7301: PUSH
7302: LD_EXP 35
7306: PPUSH
7307: CALL_OW 302
7311: AND
7312: IFFALSE 7362
// begin Say ( Walker , D2b-Sci1-1 ) ;
7314: LD_EXP 35
7318: PPUSH
7319: LD_STRING D2b-Sci1-1
7321: PPUSH
7322: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
7326: LD_EXP 24
7330: PPUSH
7331: LD_STRING D2b-JMM-2
7333: PPUSH
7334: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
7338: LD_EXP 35
7342: PPUSH
7343: LD_STRING D2b-Sci1-2
7345: PPUSH
7346: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
7350: LD_EXP 24
7354: PPUSH
7355: LD_STRING D2b-JMM-3
7357: PPUSH
7358: CALL_OW 88
// end ; DialogueOff ;
7362: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
7366: LD_STRING MOutSol
7368: PPUSH
7369: CALL_OW 337
// end ;
7373: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
7374: LD_EXP 11
7378: PUSH
7379: LD_EXP 24
7383: PPUSH
7384: CALL_OW 302
7388: AND
7389: PUSH
7390: LD_EXP 24
7394: PPUSH
7395: CALL 802 0 1
7399: AND
7400: PUSH
7401: LD_EXP 13
7405: NOT
7406: AND
7407: IFFALSE 7478
7409: GO 7411
7411: DISABLE
7412: LD_INT 0
7414: PPUSH
// begin jmm_in_veh := true ;
7415: LD_ADDR_EXP 13
7419: PUSH
7420: LD_INT 1
7422: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
7423: LD_ADDR_VAR 0 1
7427: PUSH
7428: LD_INT 0
7430: PPUSH
7431: LD_INT 1
7433: PPUSH
7434: CALL_OW 12
7438: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
7439: LD_INT 70
7441: PPUSH
7442: CALL_OW 67
// if i then
7446: LD_VAR 0 1
7450: IFFALSE 7466
// Say ( JMM , D2c-JMM-1 ) else
7452: LD_EXP 24
7456: PPUSH
7457: LD_STRING D2c-JMM-1
7459: PPUSH
7460: CALL_OW 88
7464: GO 7478
// Say ( JMM , D2c-JMM-1a ) ;
7466: LD_EXP 24
7470: PPUSH
7471: LD_STRING D2c-JMM-1a
7473: PPUSH
7474: CALL_OW 88
// end ;
7478: PPOPN 1
7480: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
7481: LD_EXP 11
7485: PUSH
7486: LD_EXP 25
7490: PPUSH
7491: CALL_OW 302
7495: AND
7496: PUSH
7497: LD_EXP 25
7501: PPUSH
7502: CALL 802 0 1
7506: AND
7507: PUSH
7508: LD_EXP 14
7512: NOT
7513: AND
7514: IFFALSE 7546
7516: GO 7518
7518: DISABLE
// begin bobby_in_veh := true ;
7519: LD_ADDR_EXP 14
7523: PUSH
7524: LD_INT 1
7526: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
7527: LD_INT 70
7529: PPUSH
7530: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
7534: LD_EXP 25
7538: PPUSH
7539: LD_STRING D2c-Bobby-1
7541: PPUSH
7542: CALL_OW 88
7546: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
7547: LD_EXP 11
7551: PUSH
7552: LD_EXP 27
7556: PPUSH
7557: CALL_OW 302
7561: AND
7562: PUSH
7563: LD_EXP 27
7567: PPUSH
7568: CALL 802 0 1
7572: AND
7573: PUSH
7574: LD_EXP 16
7578: NOT
7579: AND
7580: IFFALSE 7612
7582: GO 7584
7584: DISABLE
// begin lisa_in_veh := true ;
7585: LD_ADDR_EXP 16
7589: PUSH
7590: LD_INT 1
7592: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
7593: LD_INT 70
7595: PPUSH
7596: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
7600: LD_EXP 27
7604: PPUSH
7605: LD_STRING D2c-Lisa-1
7607: PPUSH
7608: CALL_OW 88
7612: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
7613: LD_EXP 11
7617: PUSH
7618: LD_EXP 26
7622: PPUSH
7623: CALL_OW 302
7627: AND
7628: PUSH
7629: LD_EXP 26
7633: PPUSH
7634: CALL 802 0 1
7638: AND
7639: PUSH
7640: LD_EXP 15
7644: NOT
7645: AND
7646: IFFALSE 7717
7648: GO 7650
7650: DISABLE
7651: LD_INT 0
7653: PPUSH
// begin cyrus_in_veh := true ;
7654: LD_ADDR_EXP 15
7658: PUSH
7659: LD_INT 1
7661: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
7662: LD_ADDR_VAR 0 1
7666: PUSH
7667: LD_INT 0
7669: PPUSH
7670: LD_INT 1
7672: PPUSH
7673: CALL_OW 12
7677: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
7678: LD_INT 70
7680: PPUSH
7681: CALL_OW 67
// if i then
7685: LD_VAR 0 1
7689: IFFALSE 7705
// Say ( Cyrus , D2c-Cyrus-1 ) else
7691: LD_EXP 26
7695: PPUSH
7696: LD_STRING D2c-Cyrus-1
7698: PPUSH
7699: CALL_OW 88
7703: GO 7717
// Say ( Cyrus , D2c-Cyrus-1a ) ;
7705: LD_EXP 26
7709: PPUSH
7710: LD_STRING D2c-Cyrus-1a
7712: PPUSH
7713: CALL_OW 88
// end ;
7717: PPOPN 1
7719: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) do var i , filter ;
7720: LD_INT 9
7722: PPUSH
7723: LD_INT 22
7725: PUSH
7726: LD_INT 1
7728: PUSH
7729: EMPTY
7730: LIST
7731: LIST
7732: PPUSH
7733: CALL_OW 70
7737: IFFALSE 8529
7739: GO 7741
7741: DISABLE
7742: LD_INT 0
7744: PPUSH
7745: PPUSH
// begin enable ;
7746: ENABLE
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
7747: LD_ADDR_VAR 0 2
7751: PUSH
7752: LD_INT 9
7754: PPUSH
7755: LD_INT 22
7757: PUSH
7758: LD_INT 1
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: PPUSH
7765: CALL_OW 70
7769: ST_TO_ADDR
// if not filter then
7770: LD_VAR 0 2
7774: NOT
7775: IFFALSE 7779
// exit ;
7777: GO 8529
// for i in filter do
7779: LD_ADDR_VAR 0 1
7783: PUSH
7784: LD_VAR 0 2
7788: PUSH
7789: FOR_IN
7790: IFFALSE 8527
// begin if IsDrivenBy ( i ) and GetType ( i ) = unit_human then
7792: LD_VAR 0 1
7796: PPUSH
7797: CALL_OW 311
7801: PUSH
7802: LD_VAR 0 1
7806: PPUSH
7807: CALL_OW 247
7811: PUSH
7812: LD_INT 1
7814: EQUAL
7815: AND
7816: IFFALSE 7834
// begin ComExitVehicle ( i ) ;
7818: LD_VAR 0 1
7822: PPUSH
7823: CALL_OW 121
// Wait ( 3 ) ;
7827: LD_INT 3
7829: PPUSH
7830: CALL_OW 67
// end ; if i = JMM then
7834: LD_VAR 0 1
7838: PUSH
7839: LD_EXP 24
7843: EQUAL
7844: IFFALSE 8011
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
7846: LD_EXP 21
7850: PUSH
7851: LD_INT 22
7853: PUSH
7854: LD_INT 1
7856: PUSH
7857: EMPTY
7858: LIST
7859: LIST
7860: PUSH
7861: LD_INT 21
7863: PUSH
7864: LD_INT 1
7866: PUSH
7867: EMPTY
7868: LIST
7869: LIST
7870: PUSH
7871: EMPTY
7872: LIST
7873: LIST
7874: PPUSH
7875: CALL_OW 69
7879: PUSH
7880: LD_INT 1
7882: GREATER
7883: AND
7884: IFFALSE 7941
// begin show_query := false ;
7886: LD_ADDR_EXP 21
7890: PUSH
7891: LD_INT 0
7893: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
7894: LD_STRING Q2
7896: PPUSH
7897: CALL_OW 97
7901: PUSH
7902: LD_INT 1
7904: DOUBLE
7905: EQUAL
7906: IFTRUE 7910
7908: GO 7921
7910: POP
// wait_for_them := true ; 2 :
7911: LD_ADDR_EXP 22
7915: PUSH
7916: LD_INT 1
7918: ST_TO_ADDR
7919: GO 7941
7921: LD_INT 2
7923: DOUBLE
7924: EQUAL
7925: IFTRUE 7929
7927: GO 7940
7929: POP
// wait_for_them := false ; end ;
7930: LD_ADDR_EXP 22
7934: PUSH
7935: LD_INT 0
7937: ST_TO_ADDR
7938: GO 7941
7940: POP
// end ; if not wait_for_them or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 1 then
7941: LD_EXP 22
7945: NOT
7946: PUSH
7947: LD_INT 22
7949: PUSH
7950: LD_INT 1
7952: PUSH
7953: EMPTY
7954: LIST
7955: LIST
7956: PUSH
7957: LD_INT 21
7959: PUSH
7960: LD_INT 1
7962: PUSH
7963: EMPTY
7964: LIST
7965: LIST
7966: PUSH
7967: EMPTY
7968: LIST
7969: LIST
7970: PPUSH
7971: CALL_OW 69
7975: PUSH
7976: LD_INT 1
7978: EQUAL
7979: OR
7980: IFFALSE 8011
// begin save_group := save_group ^ JMM ;
7982: LD_ADDR_EXP 20
7986: PUSH
7987: LD_EXP 20
7991: PUSH
7992: LD_EXP 24
7996: ADD
7997: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
7998: LD_EXP 24
8002: PPUSH
8003: CALL_OW 64
// EndMission ;
8007: CALL 8532 0 0
// end ; end ; if i = Lisa then
8011: LD_VAR 0 1
8015: PUSH
8016: LD_EXP 27
8020: EQUAL
8021: IFFALSE 8048
// begin save_group := save_group ^ Lisa ;
8023: LD_ADDR_EXP 20
8027: PUSH
8028: LD_EXP 20
8032: PUSH
8033: LD_EXP 27
8037: ADD
8038: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
8039: LD_EXP 27
8043: PPUSH
8044: CALL_OW 64
// end ; if i = Bobby then
8048: LD_VAR 0 1
8052: PUSH
8053: LD_EXP 25
8057: EQUAL
8058: IFFALSE 8085
// begin save_group := save_group ^ Bobby ;
8060: LD_ADDR_EXP 20
8064: PUSH
8065: LD_EXP 20
8069: PUSH
8070: LD_EXP 25
8074: ADD
8075: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
8076: LD_EXP 25
8080: PPUSH
8081: CALL_OW 64
// end ; if i = Cyrus then
8085: LD_VAR 0 1
8089: PUSH
8090: LD_EXP 26
8094: EQUAL
8095: IFFALSE 8122
// begin save_group := save_group ^ Cyrus ;
8097: LD_ADDR_EXP 20
8101: PUSH
8102: LD_EXP 20
8106: PUSH
8107: LD_EXP 26
8111: ADD
8112: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
8113: LD_EXP 26
8117: PPUSH
8118: CALL_OW 64
// end ; if i = Khatam then
8122: LD_VAR 0 1
8126: PUSH
8127: LD_EXP 28
8131: EQUAL
8132: IFFALSE 8159
// begin save_group := save_group ^ Khatam ;
8134: LD_ADDR_EXP 20
8138: PUSH
8139: LD_EXP 20
8143: PUSH
8144: LD_EXP 28
8148: ADD
8149: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
8150: LD_EXP 28
8154: PPUSH
8155: CALL_OW 64
// end ; if i = Jerry then
8159: LD_VAR 0 1
8163: PUSH
8164: LD_EXP 30
8168: EQUAL
8169: IFFALSE 8196
// begin save_group := save_group ^ Jerry ;
8171: LD_ADDR_EXP 20
8175: PUSH
8176: LD_EXP 20
8180: PUSH
8181: LD_EXP 30
8185: ADD
8186: ST_TO_ADDR
// RemoveUnit ( Jerry ) ;
8187: LD_EXP 30
8191: PPUSH
8192: CALL_OW 64
// end ; if i = Brian then
8196: LD_VAR 0 1
8200: PUSH
8201: LD_EXP 29
8205: EQUAL
8206: IFFALSE 8233
// begin save_group := save_group ^ Brian ;
8208: LD_ADDR_EXP 20
8212: PUSH
8213: LD_EXP 20
8217: PUSH
8218: LD_EXP 29
8222: ADD
8223: ST_TO_ADDR
// RemoveUnit ( Brian ) ;
8224: LD_EXP 29
8228: PPUSH
8229: CALL_OW 64
// end ; if i = Lynch then
8233: LD_VAR 0 1
8237: PUSH
8238: LD_EXP 34
8242: EQUAL
8243: IFFALSE 8270
// begin save_group := save_group ^ Lynch ;
8245: LD_ADDR_EXP 20
8249: PUSH
8250: LD_EXP 20
8254: PUSH
8255: LD_EXP 34
8259: ADD
8260: ST_TO_ADDR
// RemoveUnit ( Lynch ) ;
8261: LD_EXP 34
8265: PPUSH
8266: CALL_OW 64
// end ; if i = Turner then
8270: LD_VAR 0 1
8274: PUSH
8275: LD_EXP 36
8279: EQUAL
8280: IFFALSE 8307
// begin save_group := save_group ^ Turner ;
8282: LD_ADDR_EXP 20
8286: PUSH
8287: LD_EXP 20
8291: PUSH
8292: LD_EXP 36
8296: ADD
8297: ST_TO_ADDR
// RemoveUnit ( Turner ) ;
8298: LD_EXP 36
8302: PPUSH
8303: CALL_OW 64
// end ; if i = Jillian then
8307: LD_VAR 0 1
8311: PUSH
8312: LD_EXP 37
8316: EQUAL
8317: IFFALSE 8344
// begin save_group := save_group ^ Jillian ;
8319: LD_ADDR_EXP 20
8323: PUSH
8324: LD_EXP 20
8328: PUSH
8329: LD_EXP 37
8333: ADD
8334: ST_TO_ADDR
// RemoveUnit ( Jillian ) ;
8335: LD_EXP 37
8339: PPUSH
8340: CALL_OW 64
// end ; if i = Walker then
8344: LD_VAR 0 1
8348: PUSH
8349: LD_EXP 35
8353: EQUAL
8354: IFFALSE 8381
// begin save_group := save_group ^ Walker ;
8356: LD_ADDR_EXP 20
8360: PUSH
8361: LD_EXP 20
8365: PUSH
8366: LD_EXP 35
8370: ADD
8371: ST_TO_ADDR
// RemoveUnit ( Walker ) ;
8372: LD_EXP 35
8376: PPUSH
8377: CALL_OW 64
// end ; if i = Frank then
8381: LD_VAR 0 1
8385: PUSH
8386: LD_EXP 38
8390: EQUAL
8391: IFFALSE 8418
// begin save_group := save_group ^ Frank ;
8393: LD_ADDR_EXP 20
8397: PUSH
8398: LD_EXP 20
8402: PUSH
8403: LD_EXP 38
8407: ADD
8408: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
8409: LD_EXP 38
8413: PPUSH
8414: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and not i in save_group then
8418: LD_VAR 0 1
8422: PPUSH
8423: CALL_OW 302
8427: PUSH
8428: LD_VAR 0 1
8432: PPUSH
8433: CALL_OW 247
8437: PUSH
8438: LD_INT 1
8440: EQUAL
8441: AND
8442: PUSH
8443: LD_VAR 0 1
8447: PUSH
8448: LD_EXP 20
8452: IN
8453: NOT
8454: AND
8455: IFFALSE 8482
// begin save_others := save_others ^ i ;
8457: LD_ADDR_EXP 19
8461: PUSH
8462: LD_EXP 19
8466: PUSH
8467: LD_VAR 0 1
8471: ADD
8472: ST_TO_ADDR
// RemoveUnit ( i ) ;
8473: LD_VAR 0 1
8477: PPUSH
8478: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_vehicle then
8482: LD_VAR 0 1
8486: PPUSH
8487: CALL_OW 302
8491: PUSH
8492: LD_VAR 0 1
8496: PPUSH
8497: CALL_OW 247
8501: PUSH
8502: LD_INT 2
8504: EQUAL
8505: AND
8506: IFFALSE 8525
// begin veh_on_meta := true ;
8508: LD_ADDR_EXP 23
8512: PUSH
8513: LD_INT 1
8515: ST_TO_ADDR
// RemoveUnit ( i ) ;
8516: LD_VAR 0 1
8520: PPUSH
8521: CALL_OW 64
// end ; end ;
8525: GO 7789
8527: POP
8528: POP
// end ;
8529: PPOPN 2
8531: END
// export function EndMission ; var counter ; begin
8532: LD_INT 0
8534: PPUSH
8535: PPUSH
// if solar_builded then
8536: LD_EXP 11
8540: IFFALSE 8554
// AddMedal ( Solar1 , 1 ) else
8542: LD_STRING Solar1
8544: PPUSH
8545: LD_INT 1
8547: PPUSH
8548: CALL_OW 101
8552: GO 8565
// AddMedal ( Solar1 , - 1 ) ;
8554: LD_STRING Solar1
8556: PPUSH
8557: LD_INT 1
8559: NEG
8560: PPUSH
8561: CALL_OW 101
// if veh_on_meta then
8565: LD_EXP 23
8569: IFFALSE 8583
// AddMedal ( Solar2 , 1 ) else
8571: LD_STRING Solar2
8573: PPUSH
8574: LD_INT 1
8576: PPUSH
8577: CALL_OW 101
8581: GO 8613
// if solar_builded then
8583: LD_EXP 11
8587: IFFALSE 8602
// AddMedal ( Solar2 , - 1 ) else
8589: LD_STRING Solar2
8591: PPUSH
8592: LD_INT 1
8594: NEG
8595: PPUSH
8596: CALL_OW 101
8600: GO 8613
// AddMedal ( Solar2 , - 2 ) ;
8602: LD_STRING Solar2
8604: PPUSH
8605: LD_INT 2
8607: NEG
8608: PPUSH
8609: CALL_OW 101
// counter := save_group ^ save_others ;
8613: LD_ADDR_VAR 0 2
8617: PUSH
8618: LD_EXP 20
8622: PUSH
8623: LD_EXP 19
8627: ADD
8628: ST_TO_ADDR
// if counter = 10 then
8629: LD_VAR 0 2
8633: PUSH
8634: LD_INT 10
8636: EQUAL
8637: IFFALSE 8651
// AddMedal ( No , 1 ) else
8639: LD_STRING No
8641: PPUSH
8642: LD_INT 1
8644: PPUSH
8645: CALL_OW 101
8649: GO 8695
// if counter < 10 and counter > 6 then
8651: LD_VAR 0 2
8655: PUSH
8656: LD_INT 10
8658: LESS
8659: PUSH
8660: LD_VAR 0 2
8664: PUSH
8665: LD_INT 6
8667: GREATER
8668: AND
8669: IFFALSE 8684
// AddMedal ( No , - 1 ) else
8671: LD_STRING No
8673: PPUSH
8674: LD_INT 1
8676: NEG
8677: PPUSH
8678: CALL_OW 101
8682: GO 8695
// AddMedal ( UpTo4 , - 1 ) ;
8684: LD_STRING UpTo4
8686: PPUSH
8687: LD_INT 1
8689: NEG
8690: PPUSH
8691: CALL_OW 101
// GiveMedals ( MAIN ) ;
8695: LD_STRING MAIN
8697: PPUSH
8698: CALL_OW 102
// RewardPeople ( save_group ^ save_others ) ;
8702: LD_EXP 20
8706: PUSH
8707: LD_EXP 19
8711: ADD
8712: PPUSH
8713: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
8717: LD_EXP 24
8721: PPUSH
8722: LD_STRING JMM
8724: PPUSH
8725: CALL_OW 38
// if Bobby in save_group then
8729: LD_EXP 25
8733: PUSH
8734: LD_EXP 20
8738: IN
8739: IFFALSE 8753
// SaveCharacters ( Bobby , Bobby ) ;
8741: LD_EXP 25
8745: PPUSH
8746: LD_STRING Bobby
8748: PPUSH
8749: CALL_OW 38
// if Cyrus in save_group then
8753: LD_EXP 26
8757: PUSH
8758: LD_EXP 20
8762: IN
8763: IFFALSE 8777
// SaveCharacters ( Cyrus , Cyrus ) ;
8765: LD_EXP 26
8769: PPUSH
8770: LD_STRING Cyrus
8772: PPUSH
8773: CALL_OW 38
// if Lisa in save_group then
8777: LD_EXP 27
8781: PUSH
8782: LD_EXP 20
8786: IN
8787: IFFALSE 8801
// SaveCharacters ( Lisa , Lisa ) ;
8789: LD_EXP 27
8793: PPUSH
8794: LD_STRING Lisa
8796: PPUSH
8797: CALL_OW 38
// if Frank in save_group then
8801: LD_EXP 38
8805: PUSH
8806: LD_EXP 20
8810: IN
8811: IFFALSE 8825
// SaveCharacters ( Frank , Frank ) ;
8813: LD_EXP 38
8817: PPUSH
8818: LD_STRING Frank
8820: PPUSH
8821: CALL_OW 38
// if Khatam in save_group then
8825: LD_EXP 28
8829: PUSH
8830: LD_EXP 20
8834: IN
8835: IFFALSE 8849
// SaveCharacters ( Khatam , Khatam ) ;
8837: LD_EXP 28
8841: PPUSH
8842: LD_STRING Khatam
8844: PPUSH
8845: CALL_OW 38
// if save_others then
8849: LD_EXP 19
8853: IFFALSE 8867
// SaveCharacters ( save_others , 03_others ) ;
8855: LD_EXP 19
8859: PPUSH
8860: LD_STRING 03_others
8862: PPUSH
8863: CALL_OW 38
// YouWin ;
8867: CALL_OW 103
// end ; end_of_file
8871: LD_VAR 0 1
8875: RET
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
8876: LD_EXP 6
8880: IFFALSE 9911
8882: GO 8884
8884: DISABLE
8885: LD_INT 0
8887: PPUSH
8888: PPUSH
8889: PPUSH
8890: PPUSH
8891: PPUSH
8892: PPUSH
8893: PPUSH
8894: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
8895: LD_EXP 31
8899: PUSH
8900: LD_EXP 32
8904: ADD
8905: PUSH
8906: LD_EXP 4
8910: ADD
8911: PPUSH
8912: LD_INT 250
8914: PPUSH
8915: LD_INT 120
8917: PPUSH
8918: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
8922: LD_ADDR_VAR 0 2
8926: PUSH
8927: LD_EXP 4
8931: PPUSH
8932: LD_INT 25
8934: PUSH
8935: LD_INT 2
8937: PUSH
8938: EMPTY
8939: LIST
8940: LIST
8941: PPUSH
8942: CALL_OW 72
8946: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
8947: LD_ADDR_VAR 0 3
8951: PUSH
8952: LD_EXP 4
8956: PPUSH
8957: LD_INT 21
8959: PUSH
8960: LD_INT 1
8962: PUSH
8963: EMPTY
8964: LIST
8965: LIST
8966: PPUSH
8967: CALL_OW 72
8971: ST_TO_ADDR
// if not has_eng then
8972: LD_VAR 0 2
8976: NOT
8977: IFFALSE 9060
// begin uc_side := 4 ;
8979: LD_ADDR_OWVAR 20
8983: PUSH
8984: LD_INT 4
8986: ST_TO_ADDR
// uc_nation := 1 ;
8987: LD_ADDR_OWVAR 21
8991: PUSH
8992: LD_INT 1
8994: ST_TO_ADDR
// bc_type := b_depot ;
8995: LD_ADDR_OWVAR 42
8999: PUSH
9000: LD_INT 0
9002: ST_TO_ADDR
// bc_level := 2 ;
9003: LD_ADDR_OWVAR 43
9007: PUSH
9008: LD_INT 2
9010: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
9011: LD_ADDR_VAR 0 4
9015: PUSH
9016: LD_INT 264
9018: PPUSH
9019: LD_INT 120
9021: PPUSH
9022: LD_INT 4
9024: PPUSH
9025: CALL_OW 47
9029: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
9030: LD_INT 264
9032: PPUSH
9033: LD_INT 120
9035: PPUSH
9036: LD_INT 4
9038: PPUSH
9039: LD_INT 10
9041: NEG
9042: PPUSH
9043: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
9047: LD_INT 264
9049: PPUSH
9050: LD_INT 120
9052: PPUSH
9053: LD_INT 4
9055: PPUSH
9056: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
9060: LD_INT 35
9062: PPUSH
9063: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
9067: LD_EXP 31
9071: PPUSH
9072: LD_INT 10
9074: PPUSH
9075: CALL_OW 308
9079: IFFALSE 9060
// if has_eng and not dep then
9081: LD_VAR 0 2
9085: PUSH
9086: LD_VAR 0 4
9090: NOT
9091: AND
9092: IFFALSE 9206
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
9094: LD_VAR 0 2
9098: PPUSH
9099: LD_INT 0
9101: PPUSH
9102: LD_INT 264
9104: PPUSH
9105: LD_INT 120
9107: PPUSH
9108: LD_INT 4
9110: PPUSH
9111: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
9115: LD_INT 35
9117: PPUSH
9118: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
9122: LD_INT 22
9124: PUSH
9125: LD_INT 4
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: PUSH
9132: LD_INT 30
9134: PUSH
9135: LD_INT 0
9137: PUSH
9138: EMPTY
9139: LIST
9140: LIST
9141: PUSH
9142: LD_INT 3
9144: PUSH
9145: LD_INT 57
9147: PUSH
9148: EMPTY
9149: LIST
9150: PUSH
9151: EMPTY
9152: LIST
9153: LIST
9154: PUSH
9155: EMPTY
9156: LIST
9157: LIST
9158: LIST
9159: PPUSH
9160: CALL_OW 69
9164: IFFALSE 9115
// dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
9166: LD_ADDR_VAR 0 4
9170: PUSH
9171: LD_INT 22
9173: PUSH
9174: LD_INT 4
9176: PUSH
9177: EMPTY
9178: LIST
9179: LIST
9180: PUSH
9181: LD_INT 30
9183: PUSH
9184: LD_INT 0
9186: PUSH
9187: EMPTY
9188: LIST
9189: LIST
9190: PUSH
9191: EMPTY
9192: LIST
9193: LIST
9194: PPUSH
9195: CALL_OW 69
9199: PUSH
9200: LD_INT 1
9202: ARRAY
9203: ST_TO_ADDR
// end else
9204: GO 9323
// begin SetSide ( dep , 4 ) ;
9206: LD_VAR 0 4
9210: PPUSH
9211: LD_INT 4
9213: PPUSH
9214: CALL_OW 235
// for i = 1 to 3 do
9218: LD_ADDR_VAR 0 1
9222: PUSH
9223: DOUBLE
9224: LD_INT 1
9226: DEC
9227: ST_TO_ADDR
9228: LD_INT 3
9230: PUSH
9231: FOR_TO
9232: IFFALSE 9289
// begin ComEnterUnit ( filter [ i ] , dep ) ;
9234: LD_VAR 0 3
9238: PUSH
9239: LD_VAR 0 1
9243: ARRAY
9244: PPUSH
9245: LD_VAR 0 4
9249: PPUSH
9250: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
9254: LD_VAR 0 3
9258: PUSH
9259: LD_VAR 0 1
9263: ARRAY
9264: PPUSH
9265: LD_INT 2
9267: PPUSH
9268: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
9272: LD_VAR 0 3
9276: PUSH
9277: LD_VAR 0 1
9281: ARRAY
9282: PPUSH
9283: CALL_OW 182
// end ;
9287: GO 9231
9289: POP
9290: POP
// repeat wait ( 0 0$01 ) ;
9291: LD_INT 35
9293: PPUSH
9294: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
9298: LD_VAR 0 3
9302: PPUSH
9303: LD_INT 25
9305: PUSH
9306: LD_INT 2
9308: PUSH
9309: EMPTY
9310: LIST
9311: LIST
9312: PPUSH
9313: CALL_OW 72
9317: PUSH
9318: LD_INT 3
9320: EQUAL
9321: IFFALSE 9291
// end ; ComEnterUnit ( Bierezov , dep ) ;
9323: LD_EXP 32
9327: PPUSH
9328: LD_VAR 0 4
9332: PPUSH
9333: CALL_OW 120
// if IsInUnit ( Cornel ) then
9337: LD_EXP 31
9341: PPUSH
9342: CALL_OW 310
9346: IFFALSE 9429
// begin cargo := IsInUnit ( Cornel ) ;
9348: LD_ADDR_VAR 0 7
9352: PUSH
9353: LD_EXP 31
9357: PPUSH
9358: CALL_OW 310
9362: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
9363: LD_VAR 0 7
9367: PPUSH
9368: LD_INT 1
9370: PPUSH
9371: CALL_OW 289
9375: IFFALSE 9391
// ComGive ( Cornel , dep ) ;
9377: LD_EXP 31
9381: PPUSH
9382: LD_VAR 0 4
9386: PPUSH
9387: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
9391: LD_EXP 31
9395: PPUSH
9396: LD_INT 235
9398: PPUSH
9399: LD_INT 122
9401: PPUSH
9402: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
9406: LD_EXP 31
9410: PPUSH
9411: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
9415: LD_EXP 31
9419: PPUSH
9420: LD_VAR 0 4
9424: PPUSH
9425: CALL_OW 180
// end ; has_eng := UnitFilter ( filter , [ f_class , 2 ] ) ;
9429: LD_ADDR_VAR 0 2
9433: PUSH
9434: LD_VAR 0 3
9438: PPUSH
9439: LD_INT 25
9441: PUSH
9442: LD_INT 2
9444: PUSH
9445: EMPTY
9446: LIST
9447: LIST
9448: PPUSH
9449: CALL_OW 72
9453: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9454: LD_INT 35
9456: PPUSH
9457: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
9461: LD_ADDR_VAR 0 6
9465: PUSH
9466: LD_INT 10
9468: PPUSH
9469: CALL_OW 435
9473: ST_TO_ADDR
// if crates then
9474: LD_VAR 0 6
9478: IFFALSE 9507
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
9480: LD_VAR 0 2
9484: PPUSH
9485: LD_VAR 0 6
9489: PUSH
9490: LD_INT 1
9492: ARRAY
9493: PPUSH
9494: LD_VAR 0 6
9498: PUSH
9499: LD_INT 2
9501: ARRAY
9502: PPUSH
9503: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
9507: LD_VAR 0 4
9511: PPUSH
9512: CALL_OW 274
9516: PPUSH
9517: LD_INT 1
9519: PPUSH
9520: CALL_OW 275
9524: PUSH
9525: LD_INT 40
9527: GREATEREQUAL
9528: IFFALSE 9454
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
9530: LD_ADDR_VAR 0 5
9534: PUSH
9535: LD_INT 4
9537: PUSH
9538: LD_INT 256
9540: PUSH
9541: LD_INT 111
9543: PUSH
9544: LD_INT 2
9546: PUSH
9547: EMPTY
9548: LIST
9549: LIST
9550: LIST
9551: LIST
9552: PUSH
9553: LD_INT 31
9555: PUSH
9556: LD_INT 243
9558: PUSH
9559: LD_INT 112
9561: PUSH
9562: LD_INT 2
9564: PUSH
9565: EMPTY
9566: LIST
9567: LIST
9568: LIST
9569: LIST
9570: PUSH
9571: EMPTY
9572: LIST
9573: LIST
9574: ST_TO_ADDR
// for i in blist do
9575: LD_ADDR_VAR 0 1
9579: PUSH
9580: LD_VAR 0 5
9584: PUSH
9585: FOR_IN
9586: IFFALSE 9635
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
9588: LD_VAR 0 2
9592: PPUSH
9593: LD_VAR 0 1
9597: PUSH
9598: LD_INT 1
9600: ARRAY
9601: PPUSH
9602: LD_VAR 0 1
9606: PUSH
9607: LD_INT 2
9609: ARRAY
9610: PPUSH
9611: LD_VAR 0 1
9615: PUSH
9616: LD_INT 3
9618: ARRAY
9619: PPUSH
9620: LD_VAR 0 1
9624: PUSH
9625: LD_INT 4
9627: ARRAY
9628: PPUSH
9629: CALL_OW 205
9633: GO 9585
9635: POP
9636: POP
// repeat wait ( 0 0$01 ) ;
9637: LD_INT 35
9639: PPUSH
9640: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
9644: LD_INT 22
9646: PUSH
9647: LD_INT 4
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: PUSH
9654: LD_INT 30
9656: PUSH
9657: LD_INT 4
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: PUSH
9664: LD_INT 3
9666: PUSH
9667: LD_INT 57
9669: PUSH
9670: EMPTY
9671: LIST
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: LIST
9681: PPUSH
9682: CALL_OW 69
9686: IFFALSE 9637
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
9688: LD_VAR 0 3
9692: PUSH
9693: LD_VAR 0 2
9697: DIFF
9698: PPUSH
9699: LD_INT 22
9701: PUSH
9702: LD_INT 4
9704: PUSH
9705: EMPTY
9706: LIST
9707: LIST
9708: PUSH
9709: LD_INT 30
9711: PUSH
9712: LD_INT 4
9714: PUSH
9715: EMPTY
9716: LIST
9717: LIST
9718: PUSH
9719: EMPTY
9720: LIST
9721: LIST
9722: PPUSH
9723: CALL_OW 69
9727: PUSH
9728: LD_INT 1
9730: ARRAY
9731: PPUSH
9732: CALL_OW 180
// repeat wait ( 0 0$01 ) ;
9736: LD_INT 35
9738: PPUSH
9739: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
9743: LD_INT 22
9745: PUSH
9746: LD_INT 4
9748: PUSH
9749: EMPTY
9750: LIST
9751: LIST
9752: PUSH
9753: LD_INT 30
9755: PUSH
9756: LD_INT 31
9758: PUSH
9759: EMPTY
9760: LIST
9761: LIST
9762: PUSH
9763: LD_INT 3
9765: PUSH
9766: LD_INT 57
9768: PUSH
9769: EMPTY
9770: LIST
9771: PUSH
9772: EMPTY
9773: LIST
9774: LIST
9775: PUSH
9776: EMPTY
9777: LIST
9778: LIST
9779: LIST
9780: PPUSH
9781: CALL_OW 69
9785: IFFALSE 9736
// sol := filter diff has_eng ;
9787: LD_ADDR_VAR 0 8
9791: PUSH
9792: LD_VAR 0 3
9796: PUSH
9797: LD_VAR 0 2
9801: DIFF
9802: ST_TO_ADDR
// if GetClass ( sol [ 1 ] ) > 1 then
9803: LD_VAR 0 8
9807: PUSH
9808: LD_INT 1
9810: ARRAY
9811: PPUSH
9812: CALL_OW 257
9816: PUSH
9817: LD_INT 1
9819: GREATER
9820: IFFALSE 9838
// SetClass ( sol [ 1 ] , 1 ) ;
9822: LD_VAR 0 8
9826: PUSH
9827: LD_INT 1
9829: ARRAY
9830: PPUSH
9831: LD_INT 1
9833: PPUSH
9834: CALL_OW 336
// ComExitBuilding ( sol [ 1 ] ) ;
9838: LD_VAR 0 8
9842: PUSH
9843: LD_INT 1
9845: ARRAY
9846: PPUSH
9847: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
9851: LD_VAR 0 8
9855: PUSH
9856: LD_INT 1
9858: ARRAY
9859: PPUSH
9860: LD_INT 22
9862: PUSH
9863: LD_INT 4
9865: PUSH
9866: EMPTY
9867: LIST
9868: LIST
9869: PUSH
9870: LD_INT 30
9872: PUSH
9873: LD_INT 31
9875: PUSH
9876: EMPTY
9877: LIST
9878: LIST
9879: PUSH
9880: EMPTY
9881: LIST
9882: LIST
9883: PPUSH
9884: CALL_OW 69
9888: PUSH
9889: LD_INT 1
9891: ARRAY
9892: PPUSH
9893: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
9897: LD_VAR 0 2
9901: PPUSH
9902: LD_VAR 0 4
9906: PPUSH
9907: CALL_OW 112
// end ;
9911: PPOPN 8
9913: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
9914: LD_EXP 9
9918: IFFALSE 10238
9920: GO 9922
9922: DISABLE
9923: LD_INT 0
9925: PPUSH
9926: PPUSH
9927: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
9928: LD_ADDR_VAR 0 2
9932: PUSH
9933: LD_INT 22
9935: PUSH
9936: LD_INT 4
9938: PUSH
9939: EMPTY
9940: LIST
9941: LIST
9942: PUSH
9943: LD_INT 30
9945: PUSH
9946: LD_INT 4
9948: PUSH
9949: EMPTY
9950: LIST
9951: LIST
9952: PUSH
9953: EMPTY
9954: LIST
9955: LIST
9956: PPUSH
9957: CALL_OW 69
9961: PUSH
9962: LD_INT 1
9964: ARRAY
9965: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
9966: LD_EXP 4
9970: PPUSH
9971: CALL_OW 122
// for i in cornel_units do
9975: LD_ADDR_VAR 0 1
9979: PUSH
9980: LD_EXP 4
9984: PUSH
9985: FOR_IN
9986: IFFALSE 10040
// if GetClass ( i ) = 2 then
9988: LD_VAR 0 1
9992: PPUSH
9993: CALL_OW 257
9997: PUSH
9998: LD_INT 2
10000: EQUAL
10001: IFFALSE 10038
// begin ComEnterUnit ( i , arm ) ;
10003: LD_VAR 0 1
10007: PPUSH
10008: LD_VAR 0 2
10012: PPUSH
10013: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
10017: LD_VAR 0 1
10021: PPUSH
10022: LD_INT 1
10024: PPUSH
10025: CALL_OW 183
// AddComExitBuilding ( i ) ;
10029: LD_VAR 0 1
10033: PPUSH
10034: CALL_OW 182
// end ;
10038: GO 9985
10040: POP
10041: POP
// Wait ( 1 1$00 ) ;
10042: LD_INT 2100
10044: PPUSH
10045: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
10049: LD_ADDR_VAR 0 3
10053: PUSH
10054: LD_EXP 31
10058: PUSH
10059: LD_EXP 32
10063: ADD
10064: PUSH
10065: LD_EXP 4
10069: ADD
10070: PUSH
10071: LD_EXP 4
10075: PPUSH
10076: LD_INT 21
10078: PUSH
10079: LD_INT 2
10081: PUSH
10082: EMPTY
10083: LIST
10084: LIST
10085: PPUSH
10086: CALL_OW 72
10090: DIFF
10091: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
10092: LD_VAR 0 3
10096: PPUSH
10097: LD_INT 248
10099: PPUSH
10100: LD_INT 85
10102: PPUSH
10103: CALL_OW 111
// AddComHold ( filter ) ;
10107: LD_VAR 0 3
10111: PPUSH
10112: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
10116: LD_INT 35
10118: PPUSH
10119: CALL_OW 67
// until cornel_attack ;
10123: LD_EXP 7
10127: IFFALSE 10116
// ComAgressiveMove ( filter , 209 , 63 ) ;
10129: LD_VAR 0 3
10133: PPUSH
10134: LD_INT 209
10136: PPUSH
10137: LD_INT 63
10139: PPUSH
10140: CALL_OW 114
// if Bierezov then
10144: LD_EXP 32
10148: IFFALSE 10238
// begin filter := filter diff Bierezov ;
10150: LD_ADDR_VAR 0 3
10154: PUSH
10155: LD_VAR 0 3
10159: PUSH
10160: LD_EXP 32
10164: DIFF
10165: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
10166: LD_EXP 32
10170: PPUSH
10171: LD_INT 6
10173: PPUSH
10174: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
10178: LD_EXP 32
10182: PPUSH
10183: LD_INT 235
10185: PPUSH
10186: LD_INT 60
10188: PPUSH
10189: CALL_OW 111
// AddComHold ( Bierezov ) ;
10193: LD_EXP 32
10197: PPUSH
10198: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
10202: LD_EXP 32
10206: PPUSH
10207: LD_INT 350
10209: PPUSH
10210: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
10214: LD_EXP 32
10218: PPUSH
10219: LD_INT 198
10221: PPUSH
10222: LD_INT 28
10224: PPUSH
10225: CALL_OW 171
// AddComHold ( Bierezov ) ;
10229: LD_EXP 32
10233: PPUSH
10234: CALL_OW 200
// end ; end ; end_of_file end_of_file
10238: PPOPN 3
10240: END
// every 0 0$50 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
10241: LD_EXP 3
10245: PUSH
10246: LD_EXP 7
10250: NOT
10251: AND
10252: PUSH
10253: LD_EXP 17
10257: AND
10258: IFFALSE 10370
10260: GO 10262
10262: DISABLE
10263: LD_INT 0
10265: PPUSH
// begin enable ;
10266: ENABLE
// crates_counter := crates_counter - 50 ;
10267: LD_ADDR_EXP 17
10271: PUSH
10272: LD_EXP 17
10276: PUSH
10277: LD_INT 50
10279: MINUS
10280: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
10281: LD_INT 8
10283: PPUSH
10284: LD_INT 2
10286: PPUSH
10287: LD_INT 5
10289: PPUSH
10290: CALL_OW 12
10294: PPUSH
10295: LD_INT 1
10297: PPUSH
10298: CALL_OW 55
// Wait ( Rand ( 0 0$11 , 0 0$37 ) ) ;
10302: LD_INT 385
10304: PPUSH
10305: LD_INT 1295
10307: PPUSH
10308: CALL_OW 12
10312: PPUSH
10313: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
10317: LD_ADDR_VAR 0 1
10321: PUSH
10322: LD_INT 1
10324: PPUSH
10325: LD_OWVAR 67
10329: PUSH
10330: LD_INT 2
10332: PLUS
10333: PPUSH
10334: CALL_OW 12
10338: ST_TO_ADDR
// if r < 3 then
10339: LD_VAR 0 1
10343: PUSH
10344: LD_INT 3
10346: LESS
10347: IFFALSE 10370
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
10349: LD_INT 4
10351: PPUSH
10352: LD_INT 1
10354: PPUSH
10355: LD_INT 5
10357: PPUSH
10358: CALL_OW 12
10362: PPUSH
10363: LD_INT 1
10365: PPUSH
10366: CALL_OW 55
// end ;
10370: PPOPN 1
10372: END
// every 0 0$01 trigger cornel_active do
10373: LD_EXP 6
10377: IFFALSE 10466
10379: GO 10381
10381: DISABLE
// begin Wait ( 0 0$03 ) ;
10382: LD_INT 105
10384: PPUSH
10385: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
10389: LD_INT 2
10391: PPUSH
10392: LD_INT 5
10394: PPUSH
10395: CALL_OW 12
10399: PPUSH
10400: LD_INT 10
10402: PPUSH
10403: LD_INT 1
10405: PPUSH
10406: CALL_OW 55
// Wait ( 0 0$13 ) ;
10410: LD_INT 455
10412: PPUSH
10413: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
10417: LD_INT 2
10419: PPUSH
10420: LD_INT 5
10422: PPUSH
10423: CALL_OW 12
10427: PPUSH
10428: LD_INT 10
10430: PPUSH
10431: LD_INT 1
10433: PPUSH
10434: CALL_OW 55
// Wait ( 0 0$16 ) ;
10438: LD_INT 560
10440: PPUSH
10441: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
10445: LD_INT 2
10447: PPUSH
10448: LD_INT 5
10450: PPUSH
10451: CALL_OW 12
10455: PPUSH
10456: LD_INT 10
10458: PPUSH
10459: LD_INT 1
10461: PPUSH
10462: CALL_OW 55
// end ; end_of_file
10466: END
// every 0 0$01 trigger cornel_prepared do
10467: LD_EXP 9
10471: IFFALSE 10526
10473: GO 10475
10475: DISABLE
// begin enable ;
10476: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
10477: LD_ADDR_OWVAR 47
10481: PUSH
10482: LD_STRING #Am03-1
10484: PUSH
10485: LD_EXP 8
10489: PUSH
10490: EMPTY
10491: LIST
10492: LIST
10493: ST_TO_ADDR
// cornel_counter := cornel_counter - 0 0$01 ;
10494: LD_ADDR_EXP 8
10498: PUSH
10499: LD_EXP 8
10503: PUSH
10504: LD_INT 35
10506: MINUS
10507: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
10508: LD_EXP 8
10512: PUSH
10513: LD_INT 0
10515: EQUAL
10516: IFFALSE 10526
// begin Display_Strings := [ ] ;
10518: LD_ADDR_OWVAR 47
10522: PUSH
10523: EMPTY
10524: ST_TO_ADDR
// disable ;
10525: DISABLE
// end ; end ; end_of_file
10526: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
10527: LD_VAR 0 1
10531: PPUSH
10532: CALL_OW 255
10536: PUSH
10537: LD_INT 1
10539: EQUAL
10540: PUSH
10541: LD_EXP 11
10545: NOT
10546: AND
10547: IFFALSE 10557
// solar_builded := true ;
10549: LD_ADDR_EXP 11
10553: PUSH
10554: LD_INT 1
10556: ST_TO_ADDR
// end ;
10557: PPOPN 2
10559: END
