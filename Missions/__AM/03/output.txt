// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 363 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 451 0 0
// PrepareRussian ;
  22: CALL 3008 0 0
// PrepareAmerican ;
  26: CALL 1213 0 0
// PrepareCornell ;
  30: CALL 2237 0 0
// PrepareWesternBase ;
  34: CALL 2463 0 0
// Action ;
  38: CALL 5224 0 0
// end ;
  42: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , cornel_saved , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn , save_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  54: LD_ADDR_EXP 3
  58: PUSH
  59: LD_STRING 02_
  61: ST_TO_ADDR
// mission_prefix := 03_ ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_STRING 03_
  69: ST_TO_ADDR
// jmm_units := 0 ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// cornel_units := 0 ;
  78: LD_ADDR_EXP 6
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// bierezov_exist := false ;
  86: LD_ADDR_EXP 7
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// jmm_on_west := false ;
  94: LD_ADDR_EXP 5
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_active := false ;
 102: LD_ADDR_EXP 8
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_attack := false ;
 110: LD_ADDR_EXP 9
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// cornel_prepared := false ;
 118: LD_ADDR_EXP 11
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 126: LD_ADDR_EXP 10
 130: PUSH
 131: LD_INT 4200
 133: ST_TO_ADDR
// frank_can_return := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// solar_builded := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// frank_send_to_scout := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// jmm_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// bobby_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// cyrus_in_veh := false ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// lisa_in_veh := false ;
 182: LD_ADDR_EXP 18
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 190: LD_ADDR_EXP 28
 194: PUSH
 195: LD_INT 25200
 197: PUSH
 198: LD_INT 23100
 200: PUSH
 201: LD_INT 21000
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: PUSH
 209: LD_OWVAR 67
 213: ARRAY
 214: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 215: LD_ADDR_EXP 19
 219: PUSH
 220: LD_INT 600
 222: PUSH
 223: LD_INT 500
 225: PUSH
 226: LD_INT 400
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: PUSH
 234: LD_OWVAR 67
 238: ARRAY
 239: ST_TO_ADDR
// end_mission_allowed := false ;
 240: LD_ADDR_EXP 20
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// save_others := [ ] ;
 248: LD_ADDR_EXP 21
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// save_group := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// show_query := true ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// wait_for_them := false ;
 270: LD_ADDR_EXP 24
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// veh_on_meta := false ;
 278: LD_ADDR_EXP 27
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_spec_patrol := false ;
 286: LD_ADDR_EXP 29
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// prepare_siege := false ;
 294: LD_ADDR_EXP 30
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// send_attack_on_cornel := false ;
 302: LD_ADDR_EXP 31
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 310: LD_ADDR_EXP 25
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// game_end := false ;
 318: LD_ADDR_EXP 32
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// lose_counter := 0 ;
 326: LD_ADDR_EXP 33
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// powell_warn := 0 ;
 334: LD_ADDR_EXP 34
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// save_counter := 0 ;
 342: LD_ADDR_EXP 35
 346: PUSH
 347: LD_INT 0
 349: ST_TO_ADDR
// cornel_saved := false ;
 350: LD_ADDR_EXP 26
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// end ;
 358: LD_VAR 0 1
 362: RET
// function SetDiplomacy ; begin
 363: LD_INT 0
 365: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 366: LD_INT 1
 368: PPUSH
 369: LD_INT 4
 371: PPUSH
 372: LD_INT 1
 374: PPUSH
 375: LD_INT 1
 377: PPUSH
 378: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 382: LD_INT 1
 384: PPUSH
 385: LD_INT 8
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 398: LD_INT 3
 400: PPUSH
 401: LD_INT 6
 403: PPUSH
 404: LD_INT 1
 406: PPUSH
 407: LD_INT 1
 409: PPUSH
 410: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 414: LD_INT 4
 416: PPUSH
 417: LD_INT 6
 419: PPUSH
 420: LD_INT 0
 422: PPUSH
 423: LD_INT 1
 425: PPUSH
 426: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 430: LD_INT 3
 432: PPUSH
 433: LD_INT 8
 435: PPUSH
 436: LD_INT 0
 438: PPUSH
 439: LD_INT 1
 441: PPUSH
 442: CALL_OW 80
// end ;
 446: LD_VAR 0 1
 450: RET
// export function DebugMode ; var i ; begin
 451: LD_INT 0
 453: PPUSH
 454: PPUSH
// FogOff ( 1 ) ;
 455: LD_INT 1
 457: PPUSH
 458: CALL_OW 344
// debug_strings := [ ] ;
 462: LD_ADDR_OWVAR 48
 466: PUSH
 467: EMPTY
 468: ST_TO_ADDR
// end ; end_of_file
 469: LD_VAR 0 1
 473: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 474: LD_INT 0
 476: PPUSH
 477: PPUSH
// if exist_mode then
 478: LD_VAR 0 2
 482: IFFALSE 507
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 484: LD_ADDR_VAR 0 4
 488: PUSH
 489: LD_EXP 3
 493: PUSH
 494: LD_VAR 0 1
 498: STR
 499: PPUSH
 500: CALL_OW 34
 504: ST_TO_ADDR
 505: GO 522
// unit := NewCharacter ( ident ) ;
 507: LD_ADDR_VAR 0 4
 511: PUSH
 512: LD_VAR 0 1
 516: PPUSH
 517: CALL_OW 25
 521: ST_TO_ADDR
// result := unit ;
 522: LD_ADDR_VAR 0 3
 526: PUSH
 527: LD_VAR 0 4
 531: ST_TO_ADDR
// end ;
 532: LD_VAR 0 3
 536: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 537: LD_INT 0
 539: PPUSH
// uc_side := side ;
 540: LD_ADDR_OWVAR 20
 544: PUSH
 545: LD_VAR 0 1
 549: ST_TO_ADDR
// uc_nation := nation ;
 550: LD_ADDR_OWVAR 21
 554: PUSH
 555: LD_VAR 0 2
 559: ST_TO_ADDR
// vc_chassis := chassis ;
 560: LD_ADDR_OWVAR 37
 564: PUSH
 565: LD_VAR 0 3
 569: ST_TO_ADDR
// vc_engine := engine ;
 570: LD_ADDR_OWVAR 39
 574: PUSH
 575: LD_VAR 0 4
 579: ST_TO_ADDR
// vc_control := control ;
 580: LD_ADDR_OWVAR 38
 584: PUSH
 585: LD_VAR 0 5
 589: ST_TO_ADDR
// vc_weapon := weapon ;
 590: LD_ADDR_OWVAR 40
 594: PUSH
 595: LD_VAR 0 6
 599: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 600: LD_ADDR_OWVAR 41
 604: PUSH
 605: LD_VAR 0 7
 609: ST_TO_ADDR
// result := CreateVehicle ;
 610: LD_ADDR_VAR 0 8
 614: PUSH
 615: CALL_OW 45
 619: ST_TO_ADDR
// end ;
 620: LD_VAR 0 8
 624: RET
// export function SayX ( units , ident ) ; var i ; begin
 625: LD_INT 0
 627: PPUSH
 628: PPUSH
// result := false ;
 629: LD_ADDR_VAR 0 3
 633: PUSH
 634: LD_INT 0
 636: ST_TO_ADDR
// if not units then
 637: LD_VAR 0 1
 641: NOT
 642: IFFALSE 646
// exit ;
 644: GO 700
// for i in units do
 646: LD_ADDR_VAR 0 4
 650: PUSH
 651: LD_VAR 0 1
 655: PUSH
 656: FOR_IN
 657: IFFALSE 698
// if IsOk ( i ) then
 659: LD_VAR 0 4
 663: PPUSH
 664: CALL_OW 302
 668: IFFALSE 696
// begin Say ( i , ident ) ;
 670: LD_VAR 0 4
 674: PPUSH
 675: LD_VAR 0 2
 679: PPUSH
 680: CALL_OW 88
// result := i ;
 684: LD_ADDR_VAR 0 3
 688: PUSH
 689: LD_VAR 0 4
 693: ST_TO_ADDR
// break ;
 694: GO 698
// end ;
 696: GO 656
 698: POP
 699: POP
// end ;
 700: LD_VAR 0 3
 704: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 705: LD_INT 0
 707: PPUSH
 708: PPUSH
 709: PPUSH
 710: PPUSH
// for i = 1 to count do
 711: LD_ADDR_VAR 0 8
 715: PUSH
 716: DOUBLE
 717: LD_INT 1
 719: DEC
 720: ST_TO_ADDR
 721: LD_VAR 0 6
 725: PUSH
 726: FOR_TO
 727: IFFALSE 808
// begin uc_side = side ;
 729: LD_ADDR_OWVAR 20
 733: PUSH
 734: LD_VAR 0 1
 738: ST_TO_ADDR
// uc_nation = nation ;
 739: LD_ADDR_OWVAR 21
 743: PUSH
 744: LD_VAR 0 2
 748: ST_TO_ADDR
// hc_gallery =  ;
 749: LD_ADDR_OWVAR 33
 753: PUSH
 754: LD_STRING 
 756: ST_TO_ADDR
// hc_name =  ;
 757: LD_ADDR_OWVAR 26
 761: PUSH
 762: LD_STRING 
 764: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 765: LD_INT 0
 767: PPUSH
 768: LD_VAR 0 5
 772: PPUSH
 773: LD_VAR 0 4
 777: PPUSH
 778: CALL_OW 380
// un = CreateHuman ;
 782: LD_ADDR_VAR 0 10
 786: PUSH
 787: CALL_OW 44
 791: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 792: LD_VAR 0 10
 796: PPUSH
 797: LD_VAR 0 3
 801: PPUSH
 802: CALL_OW 52
// end ;
 806: GO 726
 808: POP
 809: POP
// end ;
 810: LD_VAR 0 7
 814: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// uc_side := GetSide ( b ) ;
 820: LD_ADDR_OWVAR 20
 824: PUSH
 825: LD_VAR 0 2
 829: PPUSH
 830: CALL_OW 255
 834: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_VAR 0 2
 844: PPUSH
 845: CALL_OW 248
 849: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 850: LD_INT 0
 852: PPUSH
 853: LD_INT 1
 855: PPUSH
 856: LD_VAR 0 1
 860: PPUSH
 861: CALL_OW 380
// un = CreateHuman ;
 865: LD_ADDR_VAR 0 4
 869: PUSH
 870: CALL_OW 44
 874: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 875: LD_ADDR_VAR 0 5
 879: PUSH
 880: LD_VAR 0 2
 884: PPUSH
 885: CALL_OW 254
 889: PUSH
 890: LD_INT 3
 892: MINUS
 893: ST_TO_ADDR
// if dir < 0 then
 894: LD_VAR 0 5
 898: PUSH
 899: LD_INT 0
 901: LESS
 902: IFFALSE 918
// dir := 6 + dir ;
 904: LD_ADDR_VAR 0 5
 908: PUSH
 909: LD_INT 6
 911: PUSH
 912: LD_VAR 0 5
 916: PLUS
 917: ST_TO_ADDR
// SetDir ( un , dir ) ;
 918: LD_VAR 0 4
 922: PPUSH
 923: LD_VAR 0 5
 927: PPUSH
 928: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 932: LD_VAR 0 4
 936: PPUSH
 937: LD_VAR 0 2
 941: PPUSH
 942: CALL_OW 52
// end ;
 946: LD_VAR 0 3
 950: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 951: LD_INT 0
 953: PPUSH
 954: PPUSH
 955: PPUSH
// result := false ;
 956: LD_ADDR_VAR 0 2
 960: PUSH
 961: LD_INT 0
 963: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 964: LD_ADDR_VAR 0 3
 968: PUSH
 969: LD_INT 22
 971: PUSH
 972: LD_INT 1
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 34
 981: PUSH
 982: LD_INT 2
 984: PUSH
 985: EMPTY
 986: LIST
 987: LIST
 988: PUSH
 989: EMPTY
 990: LIST
 991: LIST
 992: PPUSH
 993: CALL_OW 69
 997: ST_TO_ADDR
// for i in filter do
 998: LD_ADDR_VAR 0 4
1002: PUSH
1003: LD_VAR 0 3
1007: PUSH
1008: FOR_IN
1009: IFFALSE 1040
// if IsDrivenBy ( i ) = unit then
1011: LD_VAR 0 4
1015: PPUSH
1016: CALL_OW 311
1020: PUSH
1021: LD_VAR 0 1
1025: EQUAL
1026: IFFALSE 1038
// begin result := true ;
1028: LD_ADDR_VAR 0 2
1032: PUSH
1033: LD_INT 1
1035: ST_TO_ADDR
// break ;
1036: GO 1040
// end ;
1038: GO 1008
1040: POP
1041: POP
// end ;
1042: LD_VAR 0 2
1046: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1047: LD_INT 0
1049: PPUSH
1050: PPUSH
// result := false ;
1051: LD_ADDR_VAR 0 2
1055: PUSH
1056: LD_INT 0
1058: ST_TO_ADDR
// if not blist then
1059: LD_VAR 0 1
1063: NOT
1064: IFFALSE 1068
// exit ;
1066: GO 1112
// for i in blist do
1068: LD_ADDR_VAR 0 3
1072: PUSH
1073: LD_VAR 0 1
1077: PUSH
1078: FOR_IN
1079: IFFALSE 1110
// if UnitsInside ( i ) < 6 then
1081: LD_VAR 0 3
1085: PPUSH
1086: CALL_OW 313
1090: PUSH
1091: LD_INT 6
1093: LESS
1094: IFFALSE 1108
// begin result := i ;
1096: LD_ADDR_VAR 0 2
1100: PUSH
1101: LD_VAR 0 3
1105: ST_TO_ADDR
// break ;
1106: GO 1110
// end ;
1108: GO 1078
1110: POP
1111: POP
// end ;
1112: LD_VAR 0 2
1116: RET
// export function Count ( timer , mode ) ; begin
1117: LD_INT 0
1119: PPUSH
// if not timer then
1120: LD_VAR 0 1
1124: NOT
1125: IFFALSE 1129
// exit ;
1127: GO 1180
// if mode in [ asc , up , + ] then
1129: LD_VAR 0 2
1133: PUSH
1134: LD_STRING asc
1136: PUSH
1137: LD_STRING up
1139: PUSH
1140: LD_STRING +
1142: PUSH
1143: EMPTY
1144: LIST
1145: LIST
1146: LIST
1147: IN
1148: IFFALSE 1166
// result := timer + 0 0$01 else
1150: LD_ADDR_VAR 0 3
1154: PUSH
1155: LD_VAR 0 1
1159: PUSH
1160: LD_INT 35
1162: PLUS
1163: ST_TO_ADDR
1164: GO 1180
// result := timer - 0 0$01 ;
1166: LD_ADDR_VAR 0 3
1170: PUSH
1171: LD_VAR 0 1
1175: PUSH
1176: LD_INT 35
1178: MINUS
1179: ST_TO_ADDR
// end ;
1180: LD_VAR 0 3
1184: RET
// export function Video ( mode ) ; begin
1185: LD_INT 0
1187: PPUSH
// ingame_video = mode ;
1188: LD_ADDR_OWVAR 52
1192: PUSH
1193: LD_VAR 0 1
1197: ST_TO_ADDR
// interface_hidden = mode ;
1198: LD_ADDR_OWVAR 54
1202: PUSH
1203: LD_VAR 0 1
1207: ST_TO_ADDR
// end ; end_of_file
1208: LD_VAR 0 2
1212: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1213: LD_INT 0
1215: PPUSH
1216: PPUSH
1217: PPUSH
1218: PPUSH
1219: PPUSH
1220: PPUSH
1221: PPUSH
1222: PPUSH
// uc_side := 4 ;
1223: LD_ADDR_OWVAR 20
1227: PUSH
1228: LD_INT 4
1230: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1231: LD_ADDR_EXP 45
1235: PUSH
1236: LD_STRING Powell
1238: PPUSH
1239: LD_INT 0
1241: PPUSH
1242: CALL 474 0 2
1246: ST_TO_ADDR
// uc_side := 1 ;
1247: LD_ADDR_OWVAR 20
1251: PUSH
1252: LD_INT 1
1254: ST_TO_ADDR
// uc_nation := 1 ;
1255: LD_ADDR_OWVAR 21
1259: PUSH
1260: LD_INT 1
1262: ST_TO_ADDR
// if debug then
1263: LD_EXP 1
1267: IFFALSE 1397
// begin for i = 1 to 4 do
1269: LD_ADDR_VAR 0 2
1273: PUSH
1274: DOUBLE
1275: LD_INT 1
1277: DEC
1278: ST_TO_ADDR
1279: LD_INT 4
1281: PUSH
1282: FOR_TO
1283: IFFALSE 1334
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1285: LD_INT 0
1287: PPUSH
1288: LD_INT 1
1290: PPUSH
1291: LD_INT 2
1293: PPUSH
1294: CALL_OW 12
1298: PPUSH
1299: LD_INT 3
1301: PPUSH
1302: CALL_OW 380
// un := CreateHuman ;
1306: LD_ADDR_VAR 0 3
1310: PUSH
1311: CALL_OW 44
1315: ST_TO_ADDR
// others := others ^ un ;
1316: LD_ADDR_VAR 0 5
1320: PUSH
1321: LD_VAR 0 5
1325: PUSH
1326: LD_VAR 0 3
1330: ADD
1331: ST_TO_ADDR
// end ;
1332: GO 1282
1334: POP
1335: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1336: LD_ADDR_VAR 0 6
1340: PUSH
1341: LD_INT 21
1343: PUSH
1344: LD_INT 1
1346: PUSH
1347: LD_INT 1
1349: PUSH
1350: LD_INT 51
1352: PUSH
1353: LD_INT 90
1355: PUSH
1356: LD_INT 504
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: LIST
1363: LIST
1364: LIST
1365: LIST
1366: PUSH
1367: LD_INT 21
1369: PUSH
1370: LD_INT 1
1372: PUSH
1373: LD_INT 1
1375: PUSH
1376: LD_INT 51
1378: PUSH
1379: LD_INT 80
1381: PUSH
1382: LD_INT 750
1384: PUSH
1385: EMPTY
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1397: LD_ADDR_EXP 36
1401: PUSH
1402: LD_STRING JMM
1404: PPUSH
1405: LD_EXP 1
1409: NOT
1410: PPUSH
1411: CALL 474 0 2
1415: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1416: LD_ADDR_EXP 37
1420: PUSH
1421: LD_STRING Bobby
1423: PPUSH
1424: LD_EXP 1
1428: NOT
1429: PPUSH
1430: CALL 474 0 2
1434: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1435: LD_ADDR_EXP 38
1439: PUSH
1440: LD_STRING Cyrus
1442: PPUSH
1443: LD_EXP 1
1447: NOT
1448: PPUSH
1449: CALL 474 0 2
1453: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1454: LD_ADDR_EXP 39
1458: PUSH
1459: LD_STRING Lisa
1461: PPUSH
1462: LD_EXP 1
1466: NOT
1467: PPUSH
1468: CALL 474 0 2
1472: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1473: LD_ADDR_EXP 40
1477: PUSH
1478: LD_STRING Khatam
1480: PPUSH
1481: LD_EXP 1
1485: NOT
1486: PPUSH
1487: CALL 474 0 2
1491: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1492: LD_ADDR_EXP 41
1496: PUSH
1497: LD_STRING Brian
1499: PPUSH
1500: LD_EXP 1
1504: NOT
1505: PPUSH
1506: CALL 474 0 2
1510: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1511: LD_ADDR_EXP 42
1515: PUSH
1516: LD_STRING Jerry
1518: PPUSH
1519: LD_EXP 1
1523: NOT
1524: PPUSH
1525: CALL 474 0 2
1529: ST_TO_ADDR
// if Bobby then
1530: LD_EXP 37
1534: IFFALSE 1565
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1536: LD_ADDR_VAR 0 4
1540: PUSH
1541: LD_VAR 0 4
1545: PPUSH
1546: LD_VAR 0 4
1550: PUSH
1551: LD_INT 1
1553: PLUS
1554: PPUSH
1555: LD_EXP 37
1559: PPUSH
1560: CALL_OW 2
1564: ST_TO_ADDR
// if Cyrus then
1565: LD_EXP 38
1569: IFFALSE 1600
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1571: LD_ADDR_VAR 0 4
1575: PUSH
1576: LD_VAR 0 4
1580: PPUSH
1581: LD_VAR 0 4
1585: PUSH
1586: LD_INT 1
1588: PLUS
1589: PPUSH
1590: LD_EXP 38
1594: PPUSH
1595: CALL_OW 2
1599: ST_TO_ADDR
// if Lisa then
1600: LD_EXP 39
1604: IFFALSE 1635
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1606: LD_ADDR_VAR 0 4
1610: PUSH
1611: LD_VAR 0 4
1615: PPUSH
1616: LD_VAR 0 4
1620: PUSH
1621: LD_INT 1
1623: PLUS
1624: PPUSH
1625: LD_EXP 39
1629: PPUSH
1630: CALL_OW 2
1634: ST_TO_ADDR
// if Khatam then
1635: LD_EXP 40
1639: IFFALSE 1670
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1641: LD_ADDR_VAR 0 4
1645: PUSH
1646: LD_VAR 0 4
1650: PPUSH
1651: LD_VAR 0 4
1655: PUSH
1656: LD_INT 1
1658: PLUS
1659: PPUSH
1660: LD_EXP 40
1664: PPUSH
1665: CALL_OW 2
1669: ST_TO_ADDR
// if Brian then
1670: LD_EXP 41
1674: IFFALSE 1705
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1676: LD_ADDR_VAR 0 4
1680: PUSH
1681: LD_VAR 0 4
1685: PPUSH
1686: LD_VAR 0 4
1690: PUSH
1691: LD_INT 1
1693: PLUS
1694: PPUSH
1695: LD_EXP 41
1699: PPUSH
1700: CALL_OW 2
1704: ST_TO_ADDR
// if Jerry then
1705: LD_EXP 42
1709: IFFALSE 1740
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1711: LD_ADDR_VAR 0 4
1715: PUSH
1716: LD_VAR 0 4
1720: PPUSH
1721: LD_VAR 0 4
1725: PUSH
1726: LD_INT 1
1728: PLUS
1729: PPUSH
1730: LD_EXP 42
1734: PPUSH
1735: CALL_OW 2
1739: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1740: LD_STRING 02_other_survivors
1742: PPUSH
1743: CALL_OW 28
1747: IFFALSE 1762
// others := CreateCharacterSet ( 02_other_survivors ) ;
1749: LD_ADDR_VAR 0 5
1753: PUSH
1754: LD_STRING 02_other_survivors
1756: PPUSH
1757: CALL_OW 31
1761: ST_TO_ADDR
// if others then
1762: LD_VAR 0 5
1766: IFFALSE 1791
// begin tmp := tmp ^ others ;
1768: LD_ADDR_VAR 0 4
1772: PUSH
1773: LD_VAR 0 4
1777: PUSH
1778: LD_VAR 0 5
1782: ADD
1783: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1784: LD_STRING 02_other_survivors
1786: PPUSH
1787: CALL_OW 40
// end ; jmm_units := tmp ;
1791: LD_ADDR_EXP 4
1795: PUSH
1796: LD_VAR 0 4
1800: ST_TO_ADDR
// if not vehicles then
1801: LD_VAR 0 6
1805: NOT
1806: IFFALSE 1824
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1808: LD_ADDR_VAR 0 6
1812: PUSH
1813: LD_STRING 02_tanks_1
1815: PPUSH
1816: LD_INT 0
1818: PPUSH
1819: CALL_OW 30
1823: ST_TO_ADDR
// if vehicles then
1824: LD_VAR 0 6
1828: IFFALSE 2022
// begin got_mech := false ;
1830: LD_ADDR_VAR 0 7
1834: PUSH
1835: LD_INT 0
1837: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1838: LD_VAR 0 4
1842: PPUSH
1843: LD_INT 25
1845: PUSH
1846: LD_INT 3
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: PPUSH
1853: CALL_OW 72
1857: IFFALSE 1867
// got_mech := true ;
1859: LD_ADDR_VAR 0 7
1863: PUSH
1864: LD_INT 1
1866: ST_TO_ADDR
// for i = 1 to vehicles do
1867: LD_ADDR_VAR 0 2
1871: PUSH
1872: DOUBLE
1873: LD_INT 1
1875: DEC
1876: ST_TO_ADDR
1877: LD_VAR 0 6
1881: PUSH
1882: FOR_TO
1883: IFFALSE 2020
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1885: LD_ADDR_VAR 0 3
1889: PUSH
1890: LD_INT 1
1892: PPUSH
1893: LD_INT 3
1895: PPUSH
1896: LD_VAR 0 6
1900: PUSH
1901: LD_VAR 0 2
1905: ARRAY
1906: PUSH
1907: LD_INT 1
1909: ARRAY
1910: PPUSH
1911: LD_VAR 0 6
1915: PUSH
1916: LD_VAR 0 2
1920: ARRAY
1921: PUSH
1922: LD_INT 2
1924: ARRAY
1925: PPUSH
1926: LD_VAR 0 6
1930: PUSH
1931: LD_VAR 0 2
1935: ARRAY
1936: PUSH
1937: LD_INT 3
1939: ARRAY
1940: PPUSH
1941: LD_VAR 0 6
1945: PUSH
1946: LD_VAR 0 2
1950: ARRAY
1951: PUSH
1952: LD_INT 4
1954: ARRAY
1955: PPUSH
1956: LD_INT 40
1958: PPUSH
1959: CALL 537 0 7
1963: ST_TO_ADDR
// if not got_mech then
1964: LD_VAR 0 7
1968: NOT
1969: IFFALSE 1995
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1971: LD_VAR 0 3
1975: PPUSH
1976: LD_VAR 0 6
1980: PUSH
1981: LD_VAR 0 2
1985: ARRAY
1986: PUSH
1987: LD_INT 6
1989: ARRAY
1990: PPUSH
1991: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1995: LD_ADDR_VAR 0 4
1999: PUSH
2000: LD_VAR 0 4
2004: PPUSH
2005: LD_INT 1
2007: PPUSH
2008: LD_VAR 0 3
2012: PPUSH
2013: CALL_OW 2
2017: ST_TO_ADDR
// end ;
2018: GO 1882
2020: POP
2021: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
2022: LD_EXP 36
2026: PPUSH
2027: LD_INT 194
2029: PPUSH
2030: LD_INT 119
2032: PPUSH
2033: LD_INT 0
2035: PPUSH
2036: CALL_OW 48
// if tmp then
2040: LD_VAR 0 4
2044: IFFALSE 2169
// begin for i in tmp do
2046: LD_ADDR_VAR 0 2
2050: PUSH
2051: LD_VAR 0 4
2055: PUSH
2056: FOR_IN
2057: IFFALSE 2167
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2059: LD_ADDR_VAR 0 8
2063: PUSH
2064: LD_INT 22
2066: PUSH
2067: LD_INT 1
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: PUSH
2074: LD_INT 21
2076: PUSH
2077: LD_INT 2
2079: PUSH
2080: EMPTY
2081: LIST
2082: LIST
2083: PUSH
2084: LD_INT 58
2086: PUSH
2087: EMPTY
2088: LIST
2089: PUSH
2090: EMPTY
2091: LIST
2092: LIST
2093: LIST
2094: PPUSH
2095: CALL_OW 69
2099: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2100: LD_VAR 0 2
2104: PPUSH
2105: CALL_OW 247
2109: PUSH
2110: LD_INT 1
2112: EQUAL
2113: PUSH
2114: LD_VAR 0 8
2118: AND
2119: IFFALSE 2141
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2121: LD_VAR 0 2
2125: PPUSH
2126: LD_VAR 0 8
2130: PUSH
2131: LD_INT 1
2133: ARRAY
2134: PPUSH
2135: CALL_OW 52
2139: GO 2156
// PlaceUnitArea ( i , startArea , false ) ;
2141: LD_VAR 0 2
2145: PPUSH
2146: LD_INT 1
2148: PPUSH
2149: LD_INT 0
2151: PPUSH
2152: CALL_OW 49
// ComHold ( i ) ;
2156: LD_VAR 0 2
2160: PPUSH
2161: CALL_OW 140
// end ;
2165: GO 2056
2167: POP
2168: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2169: LD_ADDR_EXP 7
2173: PUSH
2174: LD_STRING 02_mikhailStatus_1
2176: PPUSH
2177: LD_INT 0
2179: PPUSH
2180: CALL_OW 30
2184: ST_TO_ADDR
// if not bierezov_exist and not debug then
2185: LD_EXP 7
2189: NOT
2190: PUSH
2191: LD_EXP 1
2195: NOT
2196: AND
2197: IFFALSE 2201
// exit ;
2199: GO 2232
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2201: LD_ADDR_EXP 44
2205: PUSH
2206: LD_STRING Mikhail
2208: PPUSH
2209: LD_INT 0
2211: PPUSH
2212: CALL 474 0 2
2216: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2217: LD_EXP 44
2221: PPUSH
2222: LD_INT 1
2224: PPUSH
2225: LD_INT 0
2227: PPUSH
2228: CALL_OW 49
// end ;
2232: LD_VAR 0 1
2236: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2237: LD_INT 0
2239: PPUSH
2240: PPUSH
2241: PPUSH
2242: PPUSH
// uc_side := 4 ;
2243: LD_ADDR_OWVAR 20
2247: PUSH
2248: LD_INT 4
2250: ST_TO_ADDR
// uc_nation := 1 ;
2251: LD_ADDR_OWVAR 21
2255: PUSH
2256: LD_INT 1
2258: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2259: LD_ADDR_EXP 43
2263: PUSH
2264: LD_STRING Cornell
2266: PPUSH
2267: LD_INT 0
2269: PPUSH
2270: CALL 474 0 2
2274: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2275: LD_ADDR_EXP 6
2279: PUSH
2280: LD_INT 9
2282: PUSH
2283: LD_EXP 4
2287: MINUS
2288: ST_TO_ADDR
// tmp := [ ] ;
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: EMPTY
2295: ST_TO_ADDR
// if cornel_units < 4 then
2296: LD_EXP 6
2300: PUSH
2301: LD_INT 4
2303: LESS
2304: IFFALSE 2314
// cornel_units := 4 ;
2306: LD_ADDR_EXP 6
2310: PUSH
2311: LD_INT 4
2313: ST_TO_ADDR
// for i = 1 to cornel_units do
2314: LD_ADDR_VAR 0 4
2318: PUSH
2319: DOUBLE
2320: LD_INT 1
2322: DEC
2323: ST_TO_ADDR
2324: LD_EXP 6
2328: PUSH
2329: FOR_TO
2330: IFFALSE 2428
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2332: LD_INT 0
2334: PPUSH
2335: LD_INT 1
2337: PUSH
2338: LD_INT 1
2340: PUSH
2341: LD_INT 1
2343: PUSH
2344: LD_INT 2
2346: PUSH
2347: LD_INT 4
2349: PUSH
2350: EMPTY
2351: LIST
2352: LIST
2353: LIST
2354: LIST
2355: LIST
2356: PUSH
2357: LD_VAR 0 4
2361: PUSH
2362: LD_INT 5
2364: MOD
2365: PUSH
2366: LD_INT 1
2368: PLUS
2369: ARRAY
2370: PPUSH
2371: LD_INT 2
2373: PPUSH
2374: CALL_OW 380
// un := CreateHuman ;
2378: LD_ADDR_VAR 0 3
2382: PUSH
2383: CALL_OW 44
2387: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2388: LD_ADDR_VAR 0 2
2392: PUSH
2393: LD_VAR 0 2
2397: PPUSH
2398: LD_INT 1
2400: PPUSH
2401: LD_VAR 0 3
2405: PPUSH
2406: CALL_OW 2
2410: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2411: LD_VAR 0 3
2415: PPUSH
2416: LD_INT 2
2418: PPUSH
2419: LD_INT 0
2421: PPUSH
2422: CALL_OW 49
// end ;
2426: GO 2329
2428: POP
2429: POP
// cornel_units := tmp ;
2430: LD_ADDR_EXP 6
2434: PUSH
2435: LD_VAR 0 2
2439: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2440: LD_EXP 43
2444: PPUSH
2445: LD_INT 191
2447: PPUSH
2448: LD_INT 106
2450: PPUSH
2451: LD_INT 0
2453: PPUSH
2454: CALL_OW 48
// end ;
2458: LD_VAR 0 1
2462: RET
// export function PrepareWesternBase ; var i ; begin
2463: LD_INT 0
2465: PPUSH
2466: PPUSH
// uc_side := 8 ;
2467: LD_ADDR_OWVAR 20
2471: PUSH
2472: LD_INT 8
2474: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2475: LD_ADDR_EXP 46
2479: PUSH
2480: LD_STRING Lynch
2482: PPUSH
2483: LD_INT 0
2485: PPUSH
2486: CALL 474 0 2
2490: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2491: LD_ADDR_EXP 47
2495: PUSH
2496: LD_STRING Walker
2498: PPUSH
2499: LD_INT 0
2501: PPUSH
2502: CALL 474 0 2
2506: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2507: LD_ADDR_EXP 48
2511: PUSH
2512: LD_STRING Turner
2514: PPUSH
2515: LD_INT 0
2517: PPUSH
2518: CALL 474 0 2
2522: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2523: LD_ADDR_EXP 49
2527: PUSH
2528: LD_STRING Jillian
2530: PPUSH
2531: LD_INT 0
2533: PPUSH
2534: CALL 474 0 2
2538: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2539: LD_ADDR_VAR 0 2
2543: PUSH
2544: LD_EXP 46
2548: PUSH
2549: LD_EXP 47
2553: PUSH
2554: LD_EXP 48
2558: PUSH
2559: LD_EXP 49
2563: PUSH
2564: EMPTY
2565: LIST
2566: LIST
2567: LIST
2568: LIST
2569: PUSH
2570: FOR_IN
2571: IFFALSE 2599
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2573: LD_VAR 0 2
2577: PPUSH
2578: LD_INT 3
2580: PPUSH
2581: LD_INT 0
2583: PPUSH
2584: CALL_OW 49
// ComHold ( i ) ;
2588: LD_VAR 0 2
2592: PPUSH
2593: CALL_OW 140
// end ;
2597: GO 2570
2599: POP
2600: POP
// end ;
2601: LD_VAR 0 1
2605: RET
// export function SelectGroup ; var units , selected , i ; begin
2606: LD_INT 0
2608: PPUSH
2609: PPUSH
2610: PPUSH
2611: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2612: LD_ADDR_VAR 0 2
2616: PUSH
2617: LD_EXP 36
2621: PUSH
2622: LD_INT -3
2624: PUSH
2625: EMPTY
2626: LIST
2627: LIST
2628: PUSH
2629: LD_EXP 4
2633: ADD
2634: PUSH
2635: LD_INT -2
2637: PUSH
2638: LD_INT -4
2640: PUSH
2641: LD_EXP 43
2645: PUSH
2646: LD_EXP 44
2650: PUSH
2651: EMPTY
2652: LIST
2653: LIST
2654: LIST
2655: LIST
2656: ADD
2657: PUSH
2658: LD_INT -3
2660: PUSH
2661: EMPTY
2662: LIST
2663: ADD
2664: PUSH
2665: LD_EXP 6
2669: ADD
2670: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: LD_EXP 36
2680: PUSH
2681: LD_STRING Select five characters to go with you
2683: PPUSH
2684: LD_INT 4
2686: PPUSH
2687: LD_INT 4
2689: PPUSH
2690: LD_VAR 0 2
2694: PPUSH
2695: EMPTY
2696: PPUSH
2697: CALL_OW 42
2701: ADD
2702: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2703: LD_ADDR_EXP 6
2707: PUSH
2708: LD_EXP 4
2712: PUSH
2713: LD_EXP 6
2717: UNION
2718: PUSH
2719: LD_VAR 0 3
2723: DIFF
2724: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2725: LD_ADDR_VAR 0 4
2729: PUSH
2730: LD_EXP 6
2734: PUSH
2735: LD_EXP 44
2739: ADD
2740: PUSH
2741: FOR_IN
2742: IFFALSE 2773
// if GetSide ( i ) = 1 then
2744: LD_VAR 0 4
2748: PPUSH
2749: CALL_OW 255
2753: PUSH
2754: LD_INT 1
2756: EQUAL
2757: IFFALSE 2771
// SetSide ( i , 4 ) ;
2759: LD_VAR 0 4
2763: PPUSH
2764: LD_INT 4
2766: PPUSH
2767: CALL_OW 235
2771: GO 2741
2773: POP
2774: POP
// for i in selected do
2775: LD_ADDR_VAR 0 4
2779: PUSH
2780: LD_VAR 0 3
2784: PUSH
2785: FOR_IN
2786: IFFALSE 2817
// if GetSide ( i ) = 4 then
2788: LD_VAR 0 4
2792: PPUSH
2793: CALL_OW 255
2797: PUSH
2798: LD_INT 4
2800: EQUAL
2801: IFFALSE 2815
// SetSide ( i , 1 ) ;
2803: LD_VAR 0 4
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: CALL_OW 235
2815: GO 2785
2817: POP
2818: POP
// jmm_units := jmm_units diff cornel_units ;
2819: LD_ADDR_EXP 4
2823: PUSH
2824: LD_EXP 4
2828: PUSH
2829: LD_EXP 6
2833: DIFF
2834: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2835: LD_EXP 37
2839: PPUSH
2840: CALL_OW 255
2844: PUSH
2845: LD_INT 4
2847: EQUAL
2848: IFFALSE 2863
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2850: LD_EXP 3
2854: PUSH
2855: LD_STRING Bobby
2857: STR
2858: PPUSH
2859: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2863: LD_EXP 38
2867: PPUSH
2868: CALL_OW 255
2872: PUSH
2873: LD_INT 4
2875: EQUAL
2876: IFFALSE 2891
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2878: LD_EXP 3
2882: PUSH
2883: LD_STRING Cyrus
2885: STR
2886: PPUSH
2887: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2891: LD_EXP 39
2895: PPUSH
2896: CALL_OW 255
2900: PUSH
2901: LD_INT 4
2903: EQUAL
2904: IFFALSE 2919
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2906: LD_EXP 3
2910: PUSH
2911: LD_STRING Lisa
2913: STR
2914: PPUSH
2915: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2919: LD_EXP 40
2923: PPUSH
2924: CALL_OW 255
2928: PUSH
2929: LD_INT 4
2931: EQUAL
2932: IFFALSE 2947
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
2934: LD_EXP 3
2938: PUSH
2939: LD_STRING Khatam
2941: STR
2942: PPUSH
2943: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2947: LD_EXP 41
2951: PPUSH
2952: CALL_OW 255
2956: PUSH
2957: LD_INT 4
2959: EQUAL
2960: IFFALSE 2975
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
2962: LD_EXP 3
2966: PUSH
2967: LD_STRING Brian
2969: STR
2970: PPUSH
2971: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2975: LD_EXP 42
2979: PPUSH
2980: CALL_OW 255
2984: PUSH
2985: LD_INT 4
2987: EQUAL
2988: IFFALSE 3003
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
2990: LD_EXP 3
2994: PUSH
2995: LD_STRING Jerry
2997: STR
2998: PPUSH
2999: CALL_OW 40
// end ; end_of_file
3003: LD_VAR 0 1
3007: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
3008: LD_INT 0
3010: PPUSH
3011: PPUSH
3012: PPUSH
3013: PPUSH
3014: PPUSH
3015: PPUSH
3016: PPUSH
3017: PPUSH
3018: PPUSH
3019: PPUSH
3020: PPUSH
3021: PPUSH
3022: PPUSH
// ru_alert := false ;
3023: LD_ADDR_EXP 59
3027: PUSH
3028: LD_INT 0
3030: ST_TO_ADDR
// ru_produce_list := [ ] ;
3031: LD_ADDR_EXP 56
3035: PUSH
3036: EMPTY
3037: ST_TO_ADDR
// if Difficulty > 1 then
3038: LD_OWVAR 67
3042: PUSH
3043: LD_INT 1
3045: GREATER
3046: IFFALSE 3134
// begin uc_side := 3 ;
3048: LD_ADDR_OWVAR 20
3052: PUSH
3053: LD_INT 3
3055: ST_TO_ADDR
// uc_nation := 3 ;
3056: LD_ADDR_OWVAR 21
3060: PUSH
3061: LD_INT 3
3063: ST_TO_ADDR
// bc_type := b_breastwork ;
3064: LD_ADDR_OWVAR 42
3068: PUSH
3069: LD_INT 31
3071: ST_TO_ADDR
// bc_level := Difficulty ;
3072: LD_ADDR_OWVAR 43
3076: PUSH
3077: LD_OWVAR 67
3081: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3082: LD_INT 22
3084: PPUSH
3085: LD_INT 14
3087: PPUSH
3088: LD_INT 0
3090: PPUSH
3091: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3095: LD_INT 48
3097: PPUSH
3098: LD_INT 46
3100: PPUSH
3101: LD_INT 0
3103: PPUSH
3104: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3108: LD_INT 86
3110: PPUSH
3111: LD_INT 65
3113: PPUSH
3114: LD_INT 5
3116: PPUSH
3117: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3121: LD_INT 165
3123: PPUSH
3124: LD_INT 73
3126: PPUSH
3127: LD_INT 5
3129: PPUSH
3130: CALL_OW 47
// end ; if Difficulty = 3 then
3134: LD_OWVAR 67
3138: PUSH
3139: LD_INT 3
3141: EQUAL
3142: IFFALSE 3157
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3144: LD_INT 51
3146: PPUSH
3147: LD_INT 3
3149: PPUSH
3150: LD_INT 2
3152: PPUSH
3153: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3157: LD_ADDR_VAR 0 7
3161: PUSH
3162: LD_INT 22
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: EMPTY
3169: LIST
3170: LIST
3171: PUSH
3172: LD_INT 2
3174: PUSH
3175: LD_INT 30
3177: PUSH
3178: LD_INT 31
3180: PUSH
3181: EMPTY
3182: LIST
3183: LIST
3184: PUSH
3185: LD_INT 30
3187: PUSH
3188: LD_INT 32
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: LIST
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: PPUSH
3204: CALL_OW 69
3208: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3209: LD_ADDR_VAR 0 8
3213: PUSH
3214: LD_INT 22
3216: PUSH
3217: LD_INT 3
3219: PUSH
3220: EMPTY
3221: LIST
3222: LIST
3223: PUSH
3224: LD_INT 30
3226: PUSH
3227: LD_INT 4
3229: PUSH
3230: EMPTY
3231: LIST
3232: LIST
3233: PUSH
3234: EMPTY
3235: LIST
3236: LIST
3237: PPUSH
3238: CALL_OW 69
3242: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3243: LD_ADDR_VAR 0 10
3247: PUSH
3248: LD_INT 22
3250: PUSH
3251: LD_INT 3
3253: PUSH
3254: EMPTY
3255: LIST
3256: LIST
3257: PUSH
3258: LD_INT 30
3260: PUSH
3261: LD_INT 3
3263: PUSH
3264: EMPTY
3265: LIST
3266: LIST
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: PPUSH
3272: CALL_OW 69
3276: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3277: LD_ADDR_VAR 0 9
3281: PUSH
3282: LD_INT 22
3284: PUSH
3285: LD_INT 3
3287: PUSH
3288: EMPTY
3289: LIST
3290: LIST
3291: PUSH
3292: LD_INT 30
3294: PUSH
3295: LD_INT 6
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: PPUSH
3306: CALL_OW 69
3310: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3311: LD_ADDR_VAR 0 2
3315: PUSH
3316: LD_INT 22
3318: PUSH
3319: LD_INT 3
3321: PUSH
3322: EMPTY
3323: LIST
3324: LIST
3325: PUSH
3326: LD_INT 30
3328: PUSH
3329: LD_INT 1
3331: PUSH
3332: EMPTY
3333: LIST
3334: LIST
3335: PUSH
3336: EMPTY
3337: LIST
3338: LIST
3339: PPUSH
3340: CALL_OW 69
3344: PUSH
3345: FOR_IN
3346: IFFALSE 3390
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3348: LD_VAR 0 2
3352: PPUSH
3353: CALL_OW 274
3357: PPUSH
3358: LD_INT 1
3360: PPUSH
3361: LD_INT 5000
3363: PPUSH
3364: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3368: LD_VAR 0 2
3372: PPUSH
3373: CALL_OW 274
3377: PPUSH
3378: LD_INT 2
3380: PPUSH
3381: LD_INT 3000
3383: PPUSH
3384: CALL_OW 277
// end ;
3388: GO 3345
3390: POP
3391: POP
// uc_side := 3 ;
3392: LD_ADDR_OWVAR 20
3396: PUSH
3397: LD_INT 3
3399: ST_TO_ADDR
// uc_nation := 3 ;
3400: LD_ADDR_OWVAR 21
3404: PUSH
3405: LD_INT 3
3407: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3408: LD_ADDR_VAR 0 11
3412: PUSH
3413: LD_INT 2
3415: PUSH
3416: LD_INT 3
3418: PUSH
3419: LD_INT 4
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: LIST
3426: PUSH
3427: LD_OWVAR 67
3431: ARRAY
3432: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3433: LD_ADDR_EXP 51
3437: PUSH
3438: LD_STRING Pokryshkin
3440: PPUSH
3441: LD_INT 0
3443: PPUSH
3444: CALL 474 0 2
3448: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3449: LD_EXP 51
3453: PPUSH
3454: LD_INT 63
3456: PPUSH
3457: LD_INT 21
3459: PPUSH
3460: LD_INT 0
3462: PPUSH
3463: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3467: LD_EXP 51
3471: PPUSH
3472: CALL_OW 140
// InitHc ;
3476: CALL_OW 19
// for i in fac do
3480: LD_ADDR_VAR 0 2
3484: PUSH
3485: LD_VAR 0 10
3489: PUSH
3490: FOR_IN
3491: IFFALSE 3544
// begin for j = 1 to 6 do
3493: LD_ADDR_VAR 0 3
3497: PUSH
3498: DOUBLE
3499: LD_INT 1
3501: DEC
3502: ST_TO_ADDR
3503: LD_INT 6
3505: PUSH
3506: FOR_TO
3507: IFFALSE 3540
// begin PrepareHuman ( false , 3 , skill ) ;
3509: LD_INT 0
3511: PPUSH
3512: LD_INT 3
3514: PPUSH
3515: LD_VAR 0 11
3519: PPUSH
3520: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3524: CALL_OW 44
3528: PPUSH
3529: LD_VAR 0 2
3533: PPUSH
3534: CALL_OW 52
// end ;
3538: GO 3506
3540: POP
3541: POP
// end ;
3542: GO 3490
3544: POP
3545: POP
// for i in lab do
3546: LD_ADDR_VAR 0 2
3550: PUSH
3551: LD_VAR 0 9
3555: PUSH
3556: FOR_IN
3557: IFFALSE 3590
// begin PrepareHuman ( false , 4 , skill ) ;
3559: LD_INT 0
3561: PPUSH
3562: LD_INT 4
3564: PPUSH
3565: LD_VAR 0 11
3569: PPUSH
3570: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3574: CALL_OW 44
3578: PPUSH
3579: LD_VAR 0 2
3583: PPUSH
3584: CALL_OW 52
// end ;
3588: GO 3556
3590: POP
3591: POP
// for i in tw do
3592: LD_ADDR_VAR 0 2
3596: PUSH
3597: LD_VAR 0 7
3601: PUSH
3602: FOR_IN
3603: IFFALSE 3652
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3605: LD_VAR 0 2
3609: PPUSH
3610: LD_INT 42
3612: PUSH
3613: LD_INT 43
3615: PUSH
3616: EMPTY
3617: LIST
3618: LIST
3619: PUSH
3620: LD_INT 1
3622: PPUSH
3623: LD_INT 2
3625: PPUSH
3626: CALL_OW 12
3630: ARRAY
3631: PPUSH
3632: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3636: LD_VAR 0 11
3640: PPUSH
3641: LD_VAR 0 2
3645: PPUSH
3646: CALL 815 0 2
// end ;
3650: GO 3602
3652: POP
3653: POP
// for i in bar do
3654: LD_ADDR_VAR 0 2
3658: PUSH
3659: LD_VAR 0 8
3663: PUSH
3664: FOR_IN
3665: IFFALSE 3698
// begin PrepareHuman ( false , 1 , skill ) ;
3667: LD_INT 0
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: LD_VAR 0 11
3677: PPUSH
3678: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3682: CALL_OW 44
3686: PPUSH
3687: LD_VAR 0 2
3691: PPUSH
3692: CALL_OW 52
// end ;
3696: GO 3664
3698: POP
3699: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3700: LD_ADDR_VAR 0 13
3704: PUSH
3705: LD_INT 100
3707: PUSH
3708: LD_INT 9
3710: PUSH
3711: EMPTY
3712: LIST
3713: LIST
3714: PUSH
3715: LD_INT 135
3717: PUSH
3718: LD_INT 60
3720: PUSH
3721: EMPTY
3722: LIST
3723: LIST
3724: PUSH
3725: LD_INT 41
3727: PUSH
3728: LD_INT 6
3730: PUSH
3731: EMPTY
3732: LIST
3733: LIST
3734: PUSH
3735: LD_INT 22
3737: PUSH
3738: LD_INT 9
3740: PUSH
3741: EMPTY
3742: LIST
3743: LIST
3744: PUSH
3745: LD_INT 84
3747: PUSH
3748: LD_INT 14
3750: PUSH
3751: EMPTY
3752: LIST
3753: LIST
3754: PUSH
3755: EMPTY
3756: LIST
3757: LIST
3758: LIST
3759: LIST
3760: LIST
3761: ST_TO_ADDR
// vehicles := [ ] ;
3762: LD_ADDR_VAR 0 12
3766: PUSH
3767: EMPTY
3768: ST_TO_ADDR
// for i in spot_xy do
3769: LD_ADDR_VAR 0 2
3773: PUSH
3774: LD_VAR 0 13
3778: PUSH
3779: FOR_IN
3780: IFFALSE 3938
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3782: LD_ADDR_VAR 0 6
3786: PUSH
3787: LD_INT 3
3789: PPUSH
3790: LD_INT 3
3792: PPUSH
3793: LD_INT 22
3795: PPUSH
3796: LD_INT 1
3798: PPUSH
3799: LD_INT 1
3801: PPUSH
3802: LD_INT 42
3804: PUSH
3805: LD_INT 43
3807: PUSH
3808: LD_INT 44
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: LIST
3815: PUSH
3816: LD_INT 1
3818: PPUSH
3819: LD_INT 3
3821: PPUSH
3822: CALL_OW 12
3826: ARRAY
3827: PPUSH
3828: LD_INT 100
3830: PPUSH
3831: CALL 537 0 7
3835: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3836: LD_ADDR_VAR 0 12
3840: PUSH
3841: LD_VAR 0 12
3845: PPUSH
3846: LD_VAR 0 12
3850: PUSH
3851: LD_INT 1
3853: PLUS
3854: PPUSH
3855: LD_VAR 0 6
3859: PPUSH
3860: CALL_OW 2
3864: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3865: LD_VAR 0 6
3869: PPUSH
3870: LD_INT 3
3872: PPUSH
3873: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3877: LD_VAR 0 6
3881: PPUSH
3882: LD_VAR 0 2
3886: PUSH
3887: LD_INT 1
3889: ARRAY
3890: PPUSH
3891: LD_VAR 0 2
3895: PUSH
3896: LD_INT 2
3898: ARRAY
3899: PPUSH
3900: LD_INT 0
3902: PPUSH
3903: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3907: LD_INT 0
3909: PPUSH
3910: LD_INT 3
3912: PPUSH
3913: LD_VAR 0 11
3917: PPUSH
3918: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3922: CALL_OW 44
3926: PPUSH
3927: LD_VAR 0 6
3931: PPUSH
3932: CALL_OW 52
// end ;
3936: GO 3779
3938: POP
3939: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3940: LD_ADDR_VAR 0 2
3944: PUSH
3945: DOUBLE
3946: LD_INT 1
3948: DEC
3949: ST_TO_ADDR
3950: LD_INT 5
3952: PUSH
3953: LD_INT 7
3955: PUSH
3956: LD_INT 8
3958: PUSH
3959: EMPTY
3960: LIST
3961: LIST
3962: LIST
3963: PUSH
3964: LD_OWVAR 67
3968: ARRAY
3969: PUSH
3970: FOR_TO
3971: IFFALSE 4031
// begin PrepareHuman ( false , 1 , skill ) ;
3973: LD_INT 0
3975: PPUSH
3976: LD_INT 1
3978: PPUSH
3979: LD_VAR 0 11
3983: PPUSH
3984: CALL_OW 380
// un := CreateHuman ;
3988: LD_ADDR_VAR 0 5
3992: PUSH
3993: CALL_OW 44
3997: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3998: LD_VAR 0 5
4002: PPUSH
4003: LD_INT 11
4005: PPUSH
4006: LD_INT 0
4008: PPUSH
4009: CALL_OW 49
// ru_forest := ru_forest ^ un ;
4013: LD_ADDR_EXP 54
4017: PUSH
4018: LD_EXP 54
4022: PUSH
4023: LD_VAR 0 5
4027: ADD
4028: ST_TO_ADDR
// end ;
4029: GO 3970
4031: POP
4032: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
4033: LD_ADDR_VAR 0 2
4037: PUSH
4038: DOUBLE
4039: LD_INT 1
4041: DEC
4042: ST_TO_ADDR
4043: LD_INT 2
4045: PUSH
4046: LD_INT 3
4048: PUSH
4049: LD_INT 4
4051: PUSH
4052: EMPTY
4053: LIST
4054: LIST
4055: LIST
4056: PUSH
4057: LD_OWVAR 67
4061: ARRAY
4062: PUSH
4063: FOR_TO
4064: IFFALSE 4124
// begin PrepareHuman ( false , 1 , skill ) ;
4066: LD_INT 0
4068: PPUSH
4069: LD_INT 1
4071: PPUSH
4072: LD_VAR 0 11
4076: PPUSH
4077: CALL_OW 380
// un := CreateHuman ;
4081: LD_ADDR_VAR 0 5
4085: PUSH
4086: CALL_OW 44
4090: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4091: LD_VAR 0 5
4095: PPUSH
4096: LD_INT 12
4098: PPUSH
4099: LD_INT 0
4101: PPUSH
4102: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4106: LD_ADDR_EXP 52
4110: PUSH
4111: LD_EXP 52
4115: PUSH
4116: LD_VAR 0 5
4120: ADD
4121: ST_TO_ADDR
// end ;
4122: GO 4063
4124: POP
4125: POP
// for i = 1 to 2 do
4126: LD_ADDR_VAR 0 2
4130: PUSH
4131: DOUBLE
4132: LD_INT 1
4134: DEC
4135: ST_TO_ADDR
4136: LD_INT 2
4138: PUSH
4139: FOR_TO
4140: IFFALSE 4206
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4142: LD_INT 1
4144: PPUSH
4145: LD_INT 1
4147: PPUSH
4148: LD_VAR 0 11
4152: PPUSH
4153: CALL_OW 380
// un := CreateHuman ;
4157: LD_ADDR_VAR 0 5
4161: PUSH
4162: CALL_OW 44
4166: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4167: LD_VAR 0 5
4171: PPUSH
4172: LD_INT 39
4174: PPUSH
4175: LD_INT 12
4177: PPUSH
4178: LD_INT 3
4180: PPUSH
4181: LD_INT 0
4183: PPUSH
4184: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4188: LD_ADDR_EXP 53
4192: PUSH
4193: LD_EXP 53
4197: PUSH
4198: LD_VAR 0 5
4202: ADD
4203: ST_TO_ADDR
// end ;
4204: GO 4139
4206: POP
4207: POP
// for i = 1 to 3 do
4208: LD_ADDR_VAR 0 2
4212: PUSH
4213: DOUBLE
4214: LD_INT 1
4216: DEC
4217: ST_TO_ADDR
4218: LD_INT 3
4220: PUSH
4221: FOR_TO
4222: IFFALSE 4288
// begin PrepareHuman ( false , 1 , skill ) ;
4224: LD_INT 0
4226: PPUSH
4227: LD_INT 1
4229: PPUSH
4230: LD_VAR 0 11
4234: PPUSH
4235: CALL_OW 380
// un := CreateHuman ;
4239: LD_ADDR_VAR 0 5
4243: PUSH
4244: CALL_OW 44
4248: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4249: LD_VAR 0 5
4253: PPUSH
4254: LD_INT 180
4256: PPUSH
4257: LD_INT 11
4259: PPUSH
4260: LD_INT 4
4262: PPUSH
4263: LD_INT 0
4265: PPUSH
4266: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4270: LD_ADDR_EXP 57
4274: PUSH
4275: LD_EXP 57
4279: PUSH
4280: LD_VAR 0 5
4284: ADD
4285: ST_TO_ADDR
// end ;
4286: GO 4221
4288: POP
4289: POP
// ru_vehicles := vehicles ;
4290: LD_ADDR_EXP 55
4294: PUSH
4295: LD_VAR 0 12
4299: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4300: LD_ADDR_EXP 58
4304: PUSH
4305: LD_INT 131
4307: PUSH
4308: LD_INT 121
4310: PUSH
4311: EMPTY
4312: LIST
4313: LIST
4314: PUSH
4315: LD_INT 113
4317: PUSH
4318: LD_INT 90
4320: PUSH
4321: EMPTY
4322: LIST
4323: LIST
4324: PUSH
4325: LD_INT 93
4327: PUSH
4328: LD_INT 62
4330: PUSH
4331: EMPTY
4332: LIST
4333: LIST
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: LIST
4339: PUSH
4340: LD_INT 106
4342: PUSH
4343: LD_INT 54
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 120
4352: PUSH
4353: LD_INT 80
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: LD_INT 143
4362: PUSH
4363: LD_INT 120
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: LIST
4374: PUSH
4375: LD_INT 154
4377: PUSH
4378: LD_INT 116
4380: PUSH
4381: EMPTY
4382: LIST
4383: LIST
4384: PUSH
4385: LD_INT 140
4387: PUSH
4388: LD_INT 93
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 130
4397: PUSH
4398: LD_INT 58
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: LIST
4409: PUSH
4410: LD_INT 105
4412: PUSH
4413: LD_INT 106
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: LD_INT 134
4422: PUSH
4423: LD_INT 98
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 159
4432: PUSH
4433: LD_INT 113
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: LIST
4444: PUSH
4445: EMPTY
4446: LIST
4447: LIST
4448: LIST
4449: LIST
4450: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4451: LD_ADDR_VAR 0 2
4455: PUSH
4456: DOUBLE
4457: LD_INT 1
4459: DEC
4460: ST_TO_ADDR
4461: LD_OWVAR 67
4465: PUSH
4466: LD_INT 1
4468: MINUS
4469: PUSH
4470: FOR_TO
4471: IFFALSE 4504
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4473: LD_ADDR_EXP 56
4477: PUSH
4478: LD_EXP 56
4482: PUSH
4483: LD_INT 22
4485: PUSH
4486: LD_INT 1
4488: PUSH
4489: LD_INT 1
4491: PUSH
4492: LD_INT 43
4494: PUSH
4495: EMPTY
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: ADD
4501: ST_TO_ADDR
4502: GO 4470
4504: POP
4505: POP
// end ;
4506: LD_VAR 0 1
4510: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4511: LD_INT 22
4513: PUSH
4514: LD_INT 3
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: PUSH
4521: LD_INT 21
4523: PUSH
4524: LD_INT 2
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: PUSH
4531: EMPTY
4532: LIST
4533: LIST
4534: PPUSH
4535: CALL_OW 69
4539: IFFALSE 4633
4541: GO 4543
4543: DISABLE
4544: LD_INT 0
4546: PPUSH
4547: PPUSH
// begin enable ;
4548: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4549: LD_ADDR_VAR 0 2
4553: PUSH
4554: LD_INT 22
4556: PUSH
4557: LD_INT 3
4559: PUSH
4560: EMPTY
4561: LIST
4562: LIST
4563: PUSH
4564: LD_INT 21
4566: PUSH
4567: LD_INT 2
4569: PUSH
4570: EMPTY
4571: LIST
4572: LIST
4573: PUSH
4574: EMPTY
4575: LIST
4576: LIST
4577: PPUSH
4578: CALL_OW 69
4582: ST_TO_ADDR
// if filter then
4583: LD_VAR 0 2
4587: IFFALSE 4633
// for i in filter do
4589: LD_ADDR_VAR 0 1
4593: PUSH
4594: LD_VAR 0 2
4598: PUSH
4599: FOR_IN
4600: IFFALSE 4631
// if GetFuel ( i ) < 20 then
4602: LD_VAR 0 1
4606: PPUSH
4607: CALL_OW 261
4611: PUSH
4612: LD_INT 20
4614: LESS
4615: IFFALSE 4629
// SetFuel ( i , 20 ) ;
4617: LD_VAR 0 1
4621: PPUSH
4622: LD_INT 20
4624: PPUSH
4625: CALL_OW 240
4629: GO 4599
4631: POP
4632: POP
// end ;
4633: PPOPN 2
4635: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4636: LD_EXP 56
4640: IFFALSE 4859
4642: GO 4644
4644: DISABLE
4645: LD_INT 0
4647: PPUSH
4648: PPUSH
4649: PPUSH
// begin enable ;
4650: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4651: LD_ADDR_VAR 0 2
4655: PUSH
4656: LD_INT 22
4658: PUSH
4659: LD_INT 3
4661: PUSH
4662: EMPTY
4663: LIST
4664: LIST
4665: PUSH
4666: LD_INT 30
4668: PUSH
4669: LD_INT 3
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: PPUSH
4680: CALL_OW 69
4684: ST_TO_ADDR
// can_produce := [ ] ;
4685: LD_ADDR_VAR 0 3
4689: PUSH
4690: EMPTY
4691: ST_TO_ADDR
// if not fac then
4692: LD_VAR 0 2
4696: NOT
4697: IFFALSE 4702
// begin disable ;
4699: DISABLE
// exit ;
4700: GO 4859
// end ; for i in fac do
4702: LD_ADDR_VAR 0 1
4706: PUSH
4707: LD_VAR 0 2
4711: PUSH
4712: FOR_IN
4713: IFFALSE 4751
// if UnitsInside ( i ) then
4715: LD_VAR 0 1
4719: PPUSH
4720: CALL_OW 313
4724: IFFALSE 4749
// can_produce := Insert ( can_produce , 1 , i ) ;
4726: LD_ADDR_VAR 0 3
4730: PUSH
4731: LD_VAR 0 3
4735: PPUSH
4736: LD_INT 1
4738: PPUSH
4739: LD_VAR 0 1
4743: PPUSH
4744: CALL_OW 2
4748: ST_TO_ADDR
4749: GO 4712
4751: POP
4752: POP
// if not can_produce then
4753: LD_VAR 0 3
4757: NOT
4758: IFFALSE 4762
// exit ;
4760: GO 4859
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4762: LD_VAR 0 3
4766: PUSH
4767: LD_INT 1
4769: PPUSH
4770: LD_VAR 0 3
4774: PPUSH
4775: CALL_OW 12
4779: ARRAY
4780: PPUSH
4781: LD_EXP 56
4785: PUSH
4786: LD_INT 1
4788: ARRAY
4789: PPUSH
4790: LD_EXP 56
4794: PUSH
4795: LD_INT 2
4797: ARRAY
4798: PPUSH
4799: LD_EXP 56
4803: PUSH
4804: LD_INT 3
4806: ARRAY
4807: PPUSH
4808: LD_EXP 56
4812: PUSH
4813: LD_INT 4
4815: ARRAY
4816: PPUSH
4817: CALL_OW 125
// for i = 1 to 4 do
4821: LD_ADDR_VAR 0 1
4825: PUSH
4826: DOUBLE
4827: LD_INT 1
4829: DEC
4830: ST_TO_ADDR
4831: LD_INT 4
4833: PUSH
4834: FOR_TO
4835: IFFALSE 4857
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4837: LD_ADDR_EXP 56
4841: PUSH
4842: LD_EXP 56
4846: PPUSH
4847: LD_INT 1
4849: PPUSH
4850: CALL_OW 3
4854: ST_TO_ADDR
4855: GO 4834
4857: POP
4858: POP
// end ;
4859: PPOPN 3
4861: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4862: LD_INT 0
4864: PPUSH
4865: PPUSH
4866: PPUSH
// for i = 1 to 6 do
4867: LD_ADDR_VAR 0 2
4871: PUSH
4872: DOUBLE
4873: LD_INT 1
4875: DEC
4876: ST_TO_ADDR
4877: LD_INT 6
4879: PUSH
4880: FOR_TO
4881: IFFALSE 5030
// begin PrepareHuman ( false , 3 , 3 ) ;
4883: LD_INT 0
4885: PPUSH
4886: LD_INT 3
4888: PPUSH
4889: LD_INT 3
4891: PPUSH
4892: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4896: LD_ADDR_VAR 0 3
4900: PUSH
4901: LD_INT 3
4903: PPUSH
4904: LD_INT 3
4906: PPUSH
4907: LD_INT 22
4909: PPUSH
4910: LD_INT 1
4912: PPUSH
4913: LD_INT 1
4915: PPUSH
4916: LD_INT 43
4918: PUSH
4919: LD_INT 42
4921: PUSH
4922: EMPTY
4923: LIST
4924: LIST
4925: PUSH
4926: LD_INT 1
4928: PPUSH
4929: LD_INT 2
4931: PPUSH
4932: CALL_OW 12
4936: ARRAY
4937: PPUSH
4938: LD_INT 70
4940: PPUSH
4941: CALL 537 0 7
4945: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4946: LD_VAR 0 3
4950: PPUSH
4951: LD_INT 4
4953: PPUSH
4954: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4958: LD_VAR 0 3
4962: PPUSH
4963: LD_INT 229
4965: PPUSH
4966: LD_INT 44
4968: PPUSH
4969: LD_INT 0
4971: PPUSH
4972: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4976: CALL_OW 44
4980: PPUSH
4981: LD_VAR 0 3
4985: PPUSH
4986: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4990: LD_ADDR_EXP 55
4994: PUSH
4995: LD_EXP 55
4999: PUSH
5000: LD_VAR 0 3
5004: ADD
5005: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
5006: LD_VAR 0 3
5010: PPUSH
5011: LD_INT 191
5013: PPUSH
5014: LD_INT 32
5016: PPUSH
5017: CALL_OW 111
// Wait ( 0 0$02 ) ;
5021: LD_INT 70
5023: PPUSH
5024: CALL_OW 67
// end ;
5028: GO 4880
5030: POP
5031: POP
// end ;
5032: LD_VAR 0 1
5036: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
5037: LD_EXP 30
5041: PUSH
5042: LD_EXP 55
5046: AND
5047: IFFALSE 5221
5049: GO 5051
5051: DISABLE
5052: LD_INT 0
5054: PPUSH
5055: PPUSH
5056: PPUSH
// begin wait ( 0 0$50 ) ;
5057: LD_INT 1750
5059: PPUSH
5060: CALL_OW 67
// tmp := ru_vehicles ;
5064: LD_ADDR_VAR 0 3
5068: PUSH
5069: LD_EXP 55
5073: ST_TO_ADDR
// if not tmp then
5074: LD_VAR 0 3
5078: NOT
5079: IFFALSE 5083
// exit ;
5081: GO 5221
// repeat wait ( 0 0$1 ) ;
5083: LD_INT 35
5085: PPUSH
5086: CALL_OW 67
// for i in tmp do
5090: LD_ADDR_VAR 0 1
5094: PUSH
5095: LD_VAR 0 3
5099: PUSH
5100: FOR_IN
5101: IFFALSE 5212
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5103: LD_ADDR_VAR 0 2
5107: PUSH
5108: LD_INT 22
5110: PUSH
5111: LD_INT 1
5113: PUSH
5114: EMPTY
5115: LIST
5116: LIST
5117: PPUSH
5118: LD_VAR 0 1
5122: PPUSH
5123: CALL_OW 74
5127: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5128: LD_VAR 0 1
5132: PPUSH
5133: LD_VAR 0 2
5137: PPUSH
5138: CALL_OW 296
5142: PUSH
5143: LD_INT 10
5145: GREATER
5146: IFFALSE 5165
// ComAgressiveMove ( i , 69 , 101 ) else
5148: LD_VAR 0 1
5152: PPUSH
5153: LD_INT 69
5155: PPUSH
5156: LD_INT 101
5158: PPUSH
5159: CALL_OW 114
5163: GO 5179
// ComAttackUnit ( i , enemy ) ;
5165: LD_VAR 0 1
5169: PPUSH
5170: LD_VAR 0 2
5174: PPUSH
5175: CALL_OW 115
// if GetLives ( i ) < 250 then
5179: LD_VAR 0 1
5183: PPUSH
5184: CALL_OW 256
5188: PUSH
5189: LD_INT 250
5191: LESS
5192: IFFALSE 5210
// tmp := tmp diff i ;
5194: LD_ADDR_VAR 0 3
5198: PUSH
5199: LD_VAR 0 3
5203: PUSH
5204: LD_VAR 0 1
5208: DIFF
5209: ST_TO_ADDR
// end ;
5210: GO 5100
5212: POP
5213: POP
// until not tmp ;
5214: LD_VAR 0 3
5218: NOT
5219: IFFALSE 5083
// end ; end_of_file
5221: PPOPN 3
5223: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5224: LD_INT 0
5226: PPUSH
5227: PPUSH
5228: PPUSH
5229: PPUSH
5230: PPUSH
5231: PPUSH
5232: PPUSH
// InGameOn ;
5233: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5237: LD_EXP 36
5241: PPUSH
5242: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5246: LD_EXP 36
5250: PPUSH
5251: LD_EXP 43
5255: PPUSH
5256: CALL_OW 119
// if Bierezov then
5260: LD_EXP 44
5264: IFFALSE 5280
// ComTurnUnit ( Bierezov , Cornel ) ;
5266: LD_EXP 44
5270: PPUSH
5271: LD_EXP 43
5275: PPUSH
5276: CALL_OW 119
// for i in jmm_units do
5280: LD_ADDR_VAR 0 2
5284: PUSH
5285: LD_EXP 4
5289: PUSH
5290: FOR_IN
5291: IFFALSE 5309
// ComTurnUnit ( i , Cornel ) ;
5293: LD_VAR 0 2
5297: PPUSH
5298: LD_EXP 43
5302: PPUSH
5303: CALL_OW 119
5307: GO 5290
5309: POP
5310: POP
// units := cornel_units union Cornel ;
5311: LD_ADDR_VAR 0 3
5315: PUSH
5316: LD_EXP 6
5320: PUSH
5321: LD_EXP 43
5325: UNION
5326: ST_TO_ADDR
// repeat wait ( 1 ) ;
5327: LD_INT 1
5329: PPUSH
5330: CALL_OW 67
// for i in units do
5334: LD_ADDR_VAR 0 2
5338: PUSH
5339: LD_VAR 0 3
5343: PUSH
5344: FOR_IN
5345: IFFALSE 5378
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5347: LD_VAR 0 2
5351: PPUSH
5352: LD_EXP 36
5356: PPUSH
5357: CALL_OW 250
5361: PPUSH
5362: LD_EXP 36
5366: PPUSH
5367: CALL_OW 251
5371: PPUSH
5372: CALL_OW 111
5376: GO 5344
5378: POP
5379: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5380: LD_VAR 0 3
5384: PPUSH
5385: LD_INT 92
5387: PUSH
5388: LD_EXP 36
5392: PPUSH
5393: CALL_OW 250
5397: PUSH
5398: LD_EXP 36
5402: PPUSH
5403: CALL_OW 251
5407: PUSH
5408: LD_INT 10
5410: PUSH
5411: EMPTY
5412: LIST
5413: LIST
5414: LIST
5415: LIST
5416: PPUSH
5417: CALL_OW 72
5421: PUSH
5422: LD_VAR 0 3
5426: EQUAL
5427: IFFALSE 5327
// for i in units do
5429: LD_ADDR_VAR 0 2
5433: PUSH
5434: LD_VAR 0 3
5438: PUSH
5439: FOR_IN
5440: IFFALSE 5458
// ComTurnUnit ( i , JMM ) ;
5442: LD_VAR 0 2
5446: PPUSH
5447: LD_EXP 36
5451: PPUSH
5452: CALL_OW 119
5456: GO 5439
5458: POP
5459: POP
// ComTurnUnit ( Cornel , JMM ) ;
5460: LD_EXP 43
5464: PPUSH
5465: LD_EXP 36
5469: PPUSH
5470: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5474: LD_EXP 36
5478: PPUSH
5479: LD_STRING D1-JMM-1
5481: PPUSH
5482: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5486: LD_EXP 43
5490: PPUSH
5491: LD_STRING D1-Corn-1
5493: PPUSH
5494: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5498: LD_EXP 36
5502: PPUSH
5503: LD_EXP 43
5507: PPUSH
5508: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5512: LD_EXP 43
5516: PPUSH
5517: LD_EXP 36
5521: PPUSH
5522: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5526: LD_INT 35
5528: PPUSH
5529: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5533: LD_EXP 36
5537: PPUSH
5538: LD_EXP 43
5542: PPUSH
5543: CALL_OW 296
5547: PUSH
5548: LD_INT 6
5550: LESS
5551: IFFALSE 5526
// ChangeSideFog ( 4 , 1 ) ;
5553: LD_INT 4
5555: PPUSH
5556: LD_INT 1
5558: PPUSH
5559: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5563: LD_EXP 36
5567: PPUSH
5568: LD_EXP 43
5572: PPUSH
5573: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5577: LD_EXP 43
5581: PPUSH
5582: LD_EXP 36
5586: PPUSH
5587: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5591: LD_EXP 36
5595: PPUSH
5596: LD_STRING D1-JMM-2
5598: PPUSH
5599: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5603: LD_EXP 36
5607: PPUSH
5608: LD_STRING D1-JMM-2a
5610: PPUSH
5611: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5615: LD_EXP 43
5619: PPUSH
5620: LD_STRING D1-Corn-2
5622: PPUSH
5623: CALL_OW 88
// if bierezov_exist or debug then
5627: LD_EXP 7
5631: PUSH
5632: LD_EXP 1
5636: OR
5637: IFFALSE 5878
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5639: LD_EXP 43
5643: PPUSH
5644: LD_EXP 44
5648: PPUSH
5649: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5653: LD_INT 10
5655: PPUSH
5656: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5660: LD_EXP 43
5664: PPUSH
5665: LD_STRING D1a-Corn-1
5667: PPUSH
5668: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5672: LD_EXP 36
5676: PPUSH
5677: LD_EXP 44
5681: PPUSH
5682: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5686: LD_EXP 44
5690: PPUSH
5691: LD_EXP 36
5695: PPUSH
5696: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5700: LD_EXP 36
5704: PPUSH
5705: LD_STRING D1a-JMM-1
5707: PPUSH
5708: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5712: LD_EXP 36
5716: PPUSH
5717: LD_EXP 43
5721: PPUSH
5722: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5726: LD_EXP 43
5730: PPUSH
5731: LD_EXP 36
5735: PPUSH
5736: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5740: LD_EXP 43
5744: PPUSH
5745: LD_STRING D1a-Corn-2
5747: PPUSH
5748: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5752: LD_EXP 36
5756: PPUSH
5757: LD_STRING D1a-JMM-2
5759: PPUSH
5760: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5764: LD_EXP 43
5768: PPUSH
5769: LD_STRING D1a-Corn-3
5771: PPUSH
5772: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5776: LD_EXP 36
5780: PPUSH
5781: LD_STRING D1a-JMM-3
5783: PPUSH
5784: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5788: LD_EXP 43
5792: PPUSH
5793: LD_STRING D1a-Corn-4
5795: PPUSH
5796: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5800: LD_EXP 36
5804: PPUSH
5805: LD_STRING D1a-JMM-4
5807: PPUSH
5808: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5812: LD_EXP 43
5816: PPUSH
5817: LD_STRING D1a-Corn-5
5819: PPUSH
5820: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5824: LD_EXP 44
5828: PPUSH
5829: LD_EXP 43
5833: PPUSH
5834: CALL_OW 250
5838: PPUSH
5839: LD_EXP 43
5843: PPUSH
5844: CALL_OW 251
5848: PUSH
5849: LD_INT 2
5851: MINUS
5852: PPUSH
5853: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5857: LD_EXP 44
5861: PPUSH
5862: LD_EXP 43
5866: PPUSH
5867: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5871: LD_INT 10
5873: PPUSH
5874: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5878: LD_EXP 36
5882: PPUSH
5883: LD_STRING D1b-JMM-1
5885: PPUSH
5886: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5890: LD_EXP 43
5894: PPUSH
5895: LD_STRING D1b-Corn-1
5897: PPUSH
5898: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5902: LD_EXP 36
5906: PPUSH
5907: LD_STRING D1b-JMM-2
5909: PPUSH
5910: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5914: LD_EXP 43
5918: PPUSH
5919: LD_STRING D1b-Corn-2
5921: PPUSH
5922: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5926: LD_EXP 36
5930: PPUSH
5931: LD_STRING D1b-JMM-3
5933: PPUSH
5934: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5938: LD_INT 10
5940: PPUSH
5941: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5945: LD_EXP 45
5949: PPUSH
5950: LD_STRING D1b-Pow-3
5952: PPUSH
5953: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5957: LD_EXP 36
5961: PPUSH
5962: LD_STRING D1b-JMM-4
5964: PPUSH
5965: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5969: LD_EXP 43
5973: PPUSH
5974: LD_STRING D1b-Corn-4
5976: PPUSH
5977: CALL_OW 88
// if Khatam then
5981: LD_EXP 40
5985: IFFALSE 6001
// Say ( Khatam , D1b-Khat-4 ) else
5987: LD_EXP 40
5991: PPUSH
5992: LD_STRING D1b-Khat-4
5994: PPUSH
5995: CALL_OW 88
5999: GO 6037
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
6001: LD_EXP 6
6005: PPUSH
6006: LD_INT 26
6008: PUSH
6009: LD_INT 1
6011: PUSH
6012: EMPTY
6013: LIST
6014: LIST
6015: PPUSH
6016: CALL_OW 72
6020: PUSH
6021: LD_EXP 43
6025: PUSH
6026: EMPTY
6027: LIST
6028: DIFF
6029: PPUSH
6030: LD_STRING D1b-Sol1-4
6032: PPUSH
6033: CALL 625 0 2
// if Cyrus then
6037: LD_EXP 38
6041: IFFALSE 6055
// Say ( Cyrus , D1b-Cyrus-4 ) ;
6043: LD_EXP 38
6047: PPUSH
6048: LD_STRING D1b-Cyrus-4
6050: PPUSH
6051: CALL_OW 88
// if Lisa then
6055: LD_EXP 39
6059: IFFALSE 6117
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6061: LD_EXP 39
6065: PPUSH
6066: LD_STRING D1b-Lisa-4
6068: PPUSH
6069: CALL_OW 88
// if Cyrus then
6073: LD_EXP 38
6077: IFFALSE 6117
// begin if not IsInUnit ( Cyrus ) then
6079: LD_EXP 38
6083: PPUSH
6084: CALL_OW 310
6088: NOT
6089: IFFALSE 6105
// ComTurnUnit ( Cyrus , Lisa ) ;
6091: LD_EXP 38
6095: PPUSH
6096: LD_EXP 39
6100: PPUSH
6101: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6105: LD_EXP 38
6109: PPUSH
6110: LD_STRING D1b-Cyrus-5
6112: PPUSH
6113: CALL_OW 88
// end ; end ; SelectGroup ;
6117: CALL 2606 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6121: LD_EXP 36
6125: PPUSH
6126: LD_STRING D1d-JMM-1
6128: PPUSH
6129: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6133: LD_EXP 43
6137: PPUSH
6138: LD_STRING D1d-Corn-1
6140: PPUSH
6141: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6145: LD_ADDR_VAR 0 2
6149: PUSH
6150: LD_EXP 4
6154: PUSH
6155: LD_EXP 6
6159: ADD
6160: PUSH
6161: LD_EXP 36
6165: ADD
6166: PUSH
6167: FOR_IN
6168: IFFALSE 6181
// ComHold ( i ) ;
6170: LD_VAR 0 2
6174: PPUSH
6175: CALL_OW 140
6179: GO 6167
6181: POP
6182: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6183: LD_ADDR_VAR 0 4
6187: PUSH
6188: LD_INT 22
6190: PUSH
6191: LD_INT 1
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: PUSH
6198: LD_INT 21
6200: PUSH
6201: LD_INT 2
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: PUSH
6208: EMPTY
6209: LIST
6210: LIST
6211: PPUSH
6212: CALL_OW 69
6216: ST_TO_ADDR
// if vehicles then
6217: LD_VAR 0 4
6221: IFFALSE 6559
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6223: LD_EXP 6
6227: PPUSH
6228: LD_INT 55
6230: PUSH
6231: EMPTY
6232: LIST
6233: PPUSH
6234: CALL_OW 72
6238: IFFALSE 6277
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6240: LD_ADDR_VAR 0 2
6244: PUSH
6245: LD_EXP 6
6249: PPUSH
6250: LD_INT 55
6252: PUSH
6253: EMPTY
6254: LIST
6255: PPUSH
6256: CALL_OW 72
6260: PUSH
6261: FOR_IN
6262: IFFALSE 6275
// ComExitVehicle ( i ) ;
6264: LD_VAR 0 2
6268: PPUSH
6269: CALL_OW 121
6273: GO 6261
6275: POP
6276: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6277: LD_ADDR_VAR 0 5
6281: PUSH
6282: LD_VAR 0 4
6286: PPUSH
6287: LD_INT 34
6289: PUSH
6290: LD_INT 51
6292: PUSH
6293: EMPTY
6294: LIST
6295: LIST
6296: PPUSH
6297: CALL_OW 72
6301: ST_TO_ADDR
// if cargos then
6302: LD_VAR 0 5
6306: IFFALSE 6489
// begin vehicles := cargos ;
6308: LD_ADDR_VAR 0 4
6312: PUSH
6313: LD_VAR 0 5
6317: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6318: LD_ADDR_VAR 0 6
6322: PUSH
6323: LD_STRING 02_resources_4
6325: PPUSH
6326: LD_INT 0
6328: PPUSH
6329: CALL_OW 30
6333: ST_TO_ADDR
// if debug and not resources then
6334: LD_EXP 1
6338: PUSH
6339: LD_VAR 0 6
6343: NOT
6344: AND
6345: IFFALSE 6355
// resources := 160 ;
6347: LD_ADDR_VAR 0 6
6351: PUSH
6352: LD_INT 160
6354: ST_TO_ADDR
// if resources mod 10 then
6355: LD_VAR 0 6
6359: PUSH
6360: LD_INT 10
6362: MOD
6363: IFFALSE 6385
// resources := resources - resources mod 10 ;
6365: LD_ADDR_VAR 0 6
6369: PUSH
6370: LD_VAR 0 6
6374: PUSH
6375: LD_VAR 0 6
6379: PUSH
6380: LD_INT 10
6382: MOD
6383: MINUS
6384: ST_TO_ADDR
// if resources then
6385: LD_VAR 0 6
6389: IFFALSE 6489
// for i in cargos do
6391: LD_ADDR_VAR 0 2
6395: PUSH
6396: LD_VAR 0 5
6400: PUSH
6401: FOR_IN
6402: IFFALSE 6487
// begin if resources < 100 then
6404: LD_VAR 0 6
6408: PUSH
6409: LD_INT 100
6411: LESS
6412: IFFALSE 6434
// begin cargo := resources ;
6414: LD_ADDR_VAR 0 7
6418: PUSH
6419: LD_VAR 0 6
6423: ST_TO_ADDR
// resources := 0 ;
6424: LD_ADDR_VAR 0 6
6428: PUSH
6429: LD_INT 0
6431: ST_TO_ADDR
// end else
6432: GO 6456
// begin cargo := 100 ;
6434: LD_ADDR_VAR 0 7
6438: PUSH
6439: LD_INT 100
6441: ST_TO_ADDR
// resources := resources - 100 ;
6442: LD_ADDR_VAR 0 6
6446: PUSH
6447: LD_VAR 0 6
6451: PUSH
6452: LD_INT 100
6454: MINUS
6455: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6456: LD_VAR 0 2
6460: PPUSH
6461: LD_INT 1
6463: PPUSH
6464: LD_VAR 0 7
6468: PPUSH
6469: CALL_OW 290
// if resources = 0 then
6473: LD_VAR 0 6
6477: PUSH
6478: LD_INT 0
6480: EQUAL
6481: IFFALSE 6485
// break ;
6483: GO 6487
// end ;
6485: GO 6401
6487: POP
6488: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6489: LD_VAR 0 4
6493: PUSH
6494: LD_INT 1
6496: ARRAY
6497: PPUSH
6498: CALL_OW 311
6502: PPUSH
6503: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6507: LD_VAR 0 4
6511: PUSH
6512: LD_INT 1
6514: ARRAY
6515: PPUSH
6516: LD_INT 4
6518: PPUSH
6519: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6523: LD_EXP 43
6527: PPUSH
6528: LD_VAR 0 4
6532: PUSH
6533: LD_INT 1
6535: ARRAY
6536: PPUSH
6537: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6541: LD_INT 35
6543: PPUSH
6544: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6548: LD_EXP 43
6552: PPUSH
6553: CALL_OW 310
6557: IFFALSE 6541
// end ; InGameOff ;
6559: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6563: LD_STRING M1
6565: PPUSH
6566: CALL_OW 337
// SaveForQuickRestart ;
6570: CALL_OW 22
// cornel_active := true ;
6574: LD_ADDR_EXP 8
6578: PUSH
6579: LD_INT 1
6581: ST_TO_ADDR
// end ;
6582: LD_VAR 0 1
6586: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns , tmp ;
6587: LD_EXP 36
6591: PPUSH
6592: LD_EXP 46
6596: PPUSH
6597: CALL_OW 296
6601: PUSH
6602: LD_INT 10
6604: LESS
6605: IFFALSE 7988
6607: GO 6609
6609: DISABLE
6610: LD_INT 0
6612: PPUSH
6613: PPUSH
6614: PPUSH
6615: PPUSH
6616: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6617: LD_ADDR_VAR 0 2
6621: PUSH
6622: LD_INT 89
6624: PUSH
6625: LD_INT 34
6627: PUSH
6628: EMPTY
6629: LIST
6630: LIST
6631: PUSH
6632: LD_INT 138
6634: PUSH
6635: LD_INT 63
6637: PUSH
6638: EMPTY
6639: LIST
6640: LIST
6641: PUSH
6642: LD_INT 196
6644: PUSH
6645: LD_INT 84
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 135
6654: PUSH
6655: LD_INT 52
6657: PUSH
6658: EMPTY
6659: LIST
6660: LIST
6661: PUSH
6662: LD_INT 103
6664: PUSH
6665: LD_INT 39
6667: PUSH
6668: EMPTY
6669: LIST
6670: LIST
6671: PUSH
6672: LD_INT 58
6674: PUSH
6675: LD_INT 30
6677: PUSH
6678: EMPTY
6679: LIST
6680: LIST
6681: PUSH
6682: LD_INT 38
6684: PUSH
6685: LD_INT 51
6687: PUSH
6688: EMPTY
6689: LIST
6690: LIST
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: LIST
6698: LIST
6699: LIST
6700: ST_TO_ADDR
// Video ( true ) ;
6701: LD_INT 1
6703: PPUSH
6704: CALL 1185 0 1
// if jmm_units then
6708: LD_EXP 4
6712: IFFALSE 6788
// for i in jmm_units do
6714: LD_ADDR_VAR 0 1
6718: PUSH
6719: LD_EXP 4
6723: PUSH
6724: FOR_IN
6725: IFFALSE 6786
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6727: LD_VAR 0 1
6731: PPUSH
6732: LD_EXP 36
6736: PPUSH
6737: CALL_OW 296
6741: PUSH
6742: LD_INT 10
6744: LESS
6745: PUSH
6746: LD_VAR 0 1
6750: PPUSH
6751: CALL_OW 310
6755: NOT
6756: AND
6757: IFFALSE 6775
// ComTurnUnit ( i , JMM ) else
6759: LD_VAR 0 1
6763: PPUSH
6764: LD_EXP 36
6768: PPUSH
6769: CALL_OW 119
6773: GO 6784
// ComHold ( i ) ;
6775: LD_VAR 0 1
6779: PPUSH
6780: CALL_OW 140
// end ;
6784: GO 6724
6786: POP
6787: POP
// if IsInUnit ( JMM ) then
6788: LD_EXP 36
6792: PPUSH
6793: CALL_OW 310
6797: IFFALSE 6822
// begin ComExitVehicle ( JMM ) ;
6799: LD_EXP 36
6803: PPUSH
6804: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6808: LD_EXP 36
6812: PPUSH
6813: LD_EXP 46
6817: PPUSH
6818: CALL_OW 172
// end ; Wait ( 10 ) ;
6822: LD_INT 10
6824: PPUSH
6825: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6829: LD_EXP 36
6833: PPUSH
6834: LD_EXP 46
6838: PPUSH
6839: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6843: LD_INT 35
6845: PPUSH
6846: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6850: LD_EXP 36
6854: PPUSH
6855: LD_EXP 46
6859: PPUSH
6860: CALL_OW 296
6864: PUSH
6865: LD_INT 6
6867: LESS
6868: IFFALSE 6843
// ComTurnUnit ( JMM , Lynch ) ;
6870: LD_EXP 36
6874: PPUSH
6875: LD_EXP 46
6879: PPUSH
6880: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6884: LD_ADDR_VAR 0 1
6888: PUSH
6889: LD_EXP 46
6893: PUSH
6894: LD_EXP 47
6898: PUSH
6899: LD_EXP 48
6903: PUSH
6904: LD_EXP 49
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: LIST
6913: LIST
6914: PUSH
6915: FOR_IN
6916: IFFALSE 6934
// ComTurnUnit ( i , JMM ) ;
6918: LD_VAR 0 1
6922: PPUSH
6923: LD_EXP 36
6927: PPUSH
6928: CALL_OW 119
6932: GO 6915
6934: POP
6935: POP
// Wait ( 0 0$0.3 ) ;
6936: LD_INT 10
6938: PPUSH
6939: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6943: LD_EXP 36
6947: PPUSH
6948: LD_STRING D2-JMM-1
6950: PPUSH
6951: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6955: LD_EXP 46
6959: PPUSH
6960: LD_STRING D2-Sol1-1
6962: PPUSH
6963: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6967: LD_EXP 36
6971: PPUSH
6972: LD_STRING D2-JMM-2
6974: PPUSH
6975: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6979: LD_EXP 46
6983: PPUSH
6984: LD_STRING D2-Sol1-2
6986: PPUSH
6987: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6991: LD_EXP 36
6995: PPUSH
6996: LD_STRING D2-JMM-3
6998: PPUSH
6999: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
7003: LD_EXP 46
7007: PPUSH
7008: LD_STRING D2-Sol1-3
7010: PPUSH
7011: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7015: LD_ADDR_VAR 0 1
7019: PUSH
7020: LD_INT 22
7022: PUSH
7023: LD_INT 8
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: PPUSH
7030: CALL_OW 69
7034: PUSH
7035: FOR_IN
7036: IFFALSE 7052
// SetSide ( i , 1 ) ;
7038: LD_VAR 0 1
7042: PPUSH
7043: LD_INT 1
7045: PPUSH
7046: CALL_OW 235
7050: GO 7035
7052: POP
7053: POP
// Say ( JMM , D2-JMM-4 ) ;
7054: LD_EXP 36
7058: PPUSH
7059: LD_STRING D2-JMM-4
7061: PPUSH
7062: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7066: LD_INT 1
7068: PPUSH
7069: LD_INT 5
7071: PPUSH
7072: CALL_OW 332
// for i = 1 to points do
7076: LD_ADDR_VAR 0 1
7080: PUSH
7081: DOUBLE
7082: LD_INT 1
7084: DEC
7085: ST_TO_ADDR
7086: LD_VAR 0 2
7090: PUSH
7091: FOR_TO
7092: IFFALSE 7267
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7094: LD_VAR 0 2
7098: PUSH
7099: LD_VAR 0 1
7103: ARRAY
7104: PUSH
7105: LD_INT 1
7107: ARRAY
7108: PPUSH
7109: LD_VAR 0 2
7113: PUSH
7114: LD_VAR 0 1
7118: ARRAY
7119: PUSH
7120: LD_INT 2
7122: ARRAY
7123: PPUSH
7124: CALL_OW 84
// if i = 1 then
7128: LD_VAR 0 1
7132: PUSH
7133: LD_INT 1
7135: EQUAL
7136: IFFALSE 7150
// Say ( Lynch , D2-Sol1-4 ) ;
7138: LD_EXP 46
7142: PPUSH
7143: LD_STRING D2-Sol1-4
7145: PPUSH
7146: CALL_OW 88
// if i = 2 then
7150: LD_VAR 0 1
7154: PUSH
7155: LD_INT 2
7157: EQUAL
7158: IFFALSE 7172
// Say ( JMM , D2-JMM-5 ) ;
7160: LD_EXP 36
7164: PPUSH
7165: LD_STRING D2-JMM-5
7167: PPUSH
7168: CALL_OW 88
// if i = 4 then
7172: LD_VAR 0 1
7176: PUSH
7177: LD_INT 4
7179: EQUAL
7180: IFFALSE 7204
// begin RevealFogArea ( 1 , troopsArea ) ;
7182: LD_INT 1
7184: PPUSH
7185: LD_INT 6
7187: PPUSH
7188: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7192: LD_EXP 46
7196: PPUSH
7197: LD_STRING D2-Sol1-5
7199: PPUSH
7200: CALL_OW 88
// end ; if i = 5 then
7204: LD_VAR 0 1
7208: PUSH
7209: LD_INT 5
7211: EQUAL
7212: IFFALSE 7226
// Say ( JMM , D2-JMM-6 ) ;
7214: LD_EXP 36
7218: PPUSH
7219: LD_STRING D2-JMM-6
7221: PPUSH
7222: CALL_OW 88
// if i = 7 then
7226: LD_VAR 0 1
7230: PUSH
7231: LD_INT 7
7233: EQUAL
7234: IFFALSE 7258
// begin RevealFogArea ( 1 , forestArea ) ;
7236: LD_INT 1
7238: PPUSH
7239: LD_INT 7
7241: PPUSH
7242: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7246: LD_EXP 46
7250: PPUSH
7251: LD_STRING D2-Sol1-6
7253: PPUSH
7254: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7258: LD_INT 46
7260: PPUSH
7261: CALL_OW 67
// end ;
7265: GO 7091
7267: POP
7268: POP
// CenterNowOnUnits ( JMM ) ;
7269: LD_EXP 36
7273: PPUSH
7274: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7278: LD_EXP 36
7282: PPUSH
7283: LD_STRING D2-JMM-7
7285: PPUSH
7286: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7290: LD_EXP 46
7294: PPUSH
7295: LD_STRING D2-Sol1-7
7297: PPUSH
7298: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7302: LD_EXP 36
7306: PPUSH
7307: LD_STRING D2-JMM-8
7309: PPUSH
7310: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7314: LD_ADDR_VAR 0 4
7318: PUSH
7319: LD_INT 22
7321: PUSH
7322: LD_INT 1
7324: PUSH
7325: EMPTY
7326: LIST
7327: LIST
7328: PUSH
7329: LD_INT 30
7331: PUSH
7332: LD_INT 31
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: PUSH
7339: EMPTY
7340: LIST
7341: LIST
7342: PPUSH
7343: CALL_OW 69
7347: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7348: LD_EXP 46
7352: PPUSH
7353: LD_VAR 0 4
7357: PUSH
7358: LD_INT 1
7360: ARRAY
7361: PPUSH
7362: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7366: LD_INT 65
7368: PPUSH
7369: LD_INT 101
7371: PPUSH
7372: CALL_OW 428
7376: IFFALSE 7399
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7378: LD_INT 65
7380: PPUSH
7381: LD_INT 101
7383: PPUSH
7384: CALL_OW 428
7388: PPUSH
7389: LD_INT 75
7391: PPUSH
7392: LD_INT 100
7394: PPUSH
7395: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7399: LD_INT 66
7401: PPUSH
7402: LD_INT 103
7404: PPUSH
7405: CALL_OW 428
7409: IFFALSE 7432
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7411: LD_INT 66
7413: PPUSH
7414: LD_INT 103
7416: PPUSH
7417: CALL_OW 428
7421: PPUSH
7422: LD_INT 75
7424: PPUSH
7425: LD_INT 100
7427: PPUSH
7428: CALL_OW 111
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_dist , JMM , 7 ] ] ) ;
7432: LD_ADDR_VAR 0 5
7436: PUSH
7437: LD_INT 22
7439: PUSH
7440: LD_INT 1
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PUSH
7447: LD_INT 21
7449: PUSH
7450: LD_INT 2
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PUSH
7457: LD_INT 91
7459: PUSH
7460: LD_EXP 36
7464: PUSH
7465: LD_INT 7
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: PPUSH
7478: CALL_OW 69
7482: ST_TO_ADDR
// if tmp then
7483: LD_VAR 0 5
7487: IFFALSE 7504
// ComMoveXY ( tmp , 75 , 100 ) ;
7489: LD_VAR 0 5
7493: PPUSH
7494: LD_INT 75
7496: PPUSH
7497: LD_INT 100
7499: PPUSH
7500: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7504: LD_ADDR_VAR 0 3
7508: PUSH
7509: LD_EXP 4
7513: PPUSH
7514: LD_INT 25
7516: PUSH
7517: LD_INT 1
7519: PUSH
7520: EMPTY
7521: LIST
7522: LIST
7523: PPUSH
7524: CALL_OW 72
7528: PPUSH
7529: LD_EXP 36
7533: PPUSH
7534: CALL_OW 74
7538: ST_TO_ADDR
// if sol then
7539: LD_VAR 0 3
7543: IFFALSE 7603
// if GetDistUnits ( JMM , sol ) < 10 then
7545: LD_EXP 36
7549: PPUSH
7550: LD_VAR 0 3
7554: PPUSH
7555: CALL_OW 296
7559: PUSH
7560: LD_INT 10
7562: LESS
7563: IFFALSE 7603
// begin if IsInUnit ( sol ) then
7565: LD_VAR 0 3
7569: PPUSH
7570: CALL_OW 310
7574: IFFALSE 7585
// ComExitVehicle ( sol ) ;
7576: LD_VAR 0 3
7580: PPUSH
7581: CALL_OW 121
// AddComEnterUnit ( sol , buns [ 2 ] ) ;
7585: LD_VAR 0 3
7589: PPUSH
7590: LD_VAR 0 4
7594: PUSH
7595: LD_INT 2
7597: ARRAY
7598: PPUSH
7599: CALL_OW 180
// end ; Wait ( 0 0$0.3 ) ;
7603: LD_INT 10
7605: PPUSH
7606: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7610: LD_EXP 36
7614: PPUSH
7615: LD_INT 65
7617: PPUSH
7618: LD_INT 101
7620: PPUSH
7621: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7625: LD_EXP 36
7629: PPUSH
7630: LD_INT 63
7632: PPUSH
7633: LD_INT 100
7635: PPUSH
7636: CALL_OW 178
// tmp := 0 0$0 ;
7640: LD_ADDR_VAR 0 5
7644: PUSH
7645: LD_INT 0
7647: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7648: LD_INT 35
7650: PPUSH
7651: CALL_OW 67
// tmp := tmp + 0 0$1 ;
7655: LD_ADDR_VAR 0 5
7659: PUSH
7660: LD_VAR 0 5
7664: PUSH
7665: LD_INT 35
7667: PLUS
7668: ST_TO_ADDR
// until IsAt ( JMM , 65 , 101 ) or tmp > 0 0$5 ;
7669: LD_EXP 36
7673: PPUSH
7674: LD_INT 65
7676: PPUSH
7677: LD_INT 101
7679: PPUSH
7680: CALL_OW 307
7684: PUSH
7685: LD_VAR 0 5
7689: PUSH
7690: LD_INT 175
7692: GREATER
7693: OR
7694: IFFALSE 7648
// Say ( JMM , D2a-JMM-1 ) ;
7696: LD_EXP 36
7700: PPUSH
7701: LD_STRING D2a-JMM-1
7703: PPUSH
7704: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7708: LD_EXP 47
7712: PPUSH
7713: LD_INT 66
7715: PPUSH
7716: LD_INT 103
7718: PPUSH
7719: CALL_OW 111
// tmp := 0 0$0 ;
7723: LD_ADDR_VAR 0 5
7727: PUSH
7728: LD_INT 0
7730: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7731: LD_INT 35
7733: PPUSH
7734: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) or tmp > 0 0$5 ;
7738: LD_EXP 47
7742: PPUSH
7743: LD_INT 66
7745: PPUSH
7746: LD_INT 103
7748: PPUSH
7749: CALL_OW 307
7753: PUSH
7754: LD_VAR 0 5
7758: PUSH
7759: LD_INT 175
7761: GREATER
7762: OR
7763: IFFALSE 7731
// ComTurnUnit ( Walker , JMM ) ;
7765: LD_EXP 47
7769: PPUSH
7770: LD_EXP 36
7774: PPUSH
7775: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7779: LD_EXP 47
7783: PPUSH
7784: LD_STRING D2a-Sci1-1
7786: PPUSH
7787: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7791: LD_EXP 36
7795: PPUSH
7796: LD_EXP 47
7800: PPUSH
7801: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7805: LD_EXP 36
7809: PPUSH
7810: LD_STRING D2a-JMM-2
7812: PPUSH
7813: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7817: LD_EXP 47
7821: PPUSH
7822: LD_STRING D2a-Sci1-2
7824: PPUSH
7825: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7829: LD_EXP 36
7833: PPUSH
7834: LD_STRING D2a-JMM-3
7836: PPUSH
7837: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7841: LD_EXP 47
7845: PPUSH
7846: LD_STRING D2a-Sci1-3
7848: PPUSH
7849: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7853: LD_ADDR_EXP 4
7857: PUSH
7858: LD_EXP 4
7862: PUSH
7863: LD_EXP 46
7867: PUSH
7868: LD_EXP 47
7872: PUSH
7873: LD_EXP 48
7877: PUSH
7878: LD_EXP 49
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: LIST
7887: LIST
7888: ADD
7889: ST_TO_ADDR
// for i in jmm_units do
7890: LD_ADDR_VAR 0 1
7894: PUSH
7895: LD_EXP 4
7899: PUSH
7900: FOR_IN
7901: IFFALSE 7926
// if not IsInUnit ( i ) then
7903: LD_VAR 0 1
7907: PPUSH
7908: CALL_OW 310
7912: NOT
7913: IFFALSE 7924
// ComFree ( i ) ;
7915: LD_VAR 0 1
7919: PPUSH
7920: CALL_OW 139
7924: GO 7900
7926: POP
7927: POP
// Video ( false ) ;
7928: LD_INT 0
7930: PPUSH
7931: CALL 1185 0 1
// ChangeMissionObjectives ( MSolar1 ) ;
7935: LD_STRING MSolar1
7937: PPUSH
7938: CALL_OW 337
// jmm_on_west := true ;
7942: LD_ADDR_EXP 5
7946: PUSH
7947: LD_INT 1
7949: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7950: LD_INT 1050
7952: PPUSH
7953: CALL_OW 67
// frank_can_return := true ;
7957: LD_ADDR_EXP 12
7961: PUSH
7962: LD_INT 1
7964: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7965: LD_INT 6300
7967: PPUSH
7968: LD_INT 8400
7970: PPUSH
7971: CALL_OW 12
7975: PPUSH
7976: CALL_OW 67
// send_spec_patrol := true ;
7980: LD_ADDR_EXP 29
7984: PUSH
7985: LD_INT 1
7987: ST_TO_ADDR
// end ;
7988: PPOPN 5
7990: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7991: LD_INT 22
7993: PUSH
7994: LD_INT 1
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: PUSH
8001: LD_INT 34
8003: PUSH
8004: LD_INT 51
8006: PUSH
8007: EMPTY
8008: LIST
8009: LIST
8010: PUSH
8011: LD_INT 92
8013: PUSH
8014: LD_INT 63
8016: PUSH
8017: LD_INT 100
8019: PUSH
8020: LD_INT 5
8022: PUSH
8023: EMPTY
8024: LIST
8025: LIST
8026: LIST
8027: LIST
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: LIST
8033: PUSH
8034: EMPTY
8035: LIST
8036: PPUSH
8037: CALL_OW 69
8041: PUSH
8042: LD_EXP 5
8046: NOT
8047: AND
8048: IFFALSE 8161
8050: GO 8052
8052: DISABLE
8053: LD_INT 0
8055: PPUSH
8056: PPUSH
// begin enable ;
8057: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
8058: LD_ADDR_VAR 0 2
8062: PUSH
8063: LD_INT 22
8065: PUSH
8066: LD_INT 1
8068: PUSH
8069: EMPTY
8070: LIST
8071: LIST
8072: PUSH
8073: LD_INT 34
8075: PUSH
8076: LD_INT 51
8078: PUSH
8079: EMPTY
8080: LIST
8081: LIST
8082: PUSH
8083: LD_INT 92
8085: PUSH
8086: LD_INT 63
8088: PUSH
8089: LD_INT 100
8091: PUSH
8092: LD_INT 5
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: PUSH
8101: EMPTY
8102: LIST
8103: LIST
8104: LIST
8105: PUSH
8106: EMPTY
8107: LIST
8108: PPUSH
8109: CALL_OW 69
8113: ST_TO_ADDR
// if not filter then
8114: LD_VAR 0 2
8118: NOT
8119: IFFALSE 8123
// exit ;
8121: GO 8161
// for i in filter do
8123: LD_ADDR_VAR 0 1
8127: PUSH
8128: LD_VAR 0 2
8132: PUSH
8133: FOR_IN
8134: IFFALSE 8159
// begin SetFuel ( i , 0 ) ;
8136: LD_VAR 0 1
8140: PPUSH
8141: LD_INT 0
8143: PPUSH
8144: CALL_OW 240
// ComStop ( i ) ;
8148: LD_VAR 0 1
8152: PPUSH
8153: CALL_OW 141
// end ;
8157: GO 8133
8159: POP
8160: POP
// end ;
8161: PPOPN 2
8163: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
8164: LD_EXP 29
8168: IFFALSE 9161
8170: GO 8172
8172: DISABLE
8173: LD_INT 0
8175: PPUSH
8176: PPUSH
8177: PPUSH
8178: PPUSH
8179: PPUSH
8180: PPUSH
8181: PPUSH
// begin if not ru_spec_patrol then
8182: LD_EXP 53
8186: NOT
8187: IFFALSE 8191
// exit ;
8189: GO 9161
// dead1 := false ;
8191: LD_ADDR_VAR 0 1
8195: PUSH
8196: LD_INT 0
8198: ST_TO_ADDR
// dead2 := false ;
8199: LD_ADDR_VAR 0 2
8203: PUSH
8204: LD_INT 0
8206: ST_TO_ADDR
// inarea1 := false ;
8207: LD_ADDR_VAR 0 3
8211: PUSH
8212: LD_INT 0
8214: ST_TO_ADDR
// inarea2 := false ;
8215: LD_ADDR_VAR 0 4
8219: PUSH
8220: LD_INT 0
8222: ST_TO_ADDR
// tmp := [ ] ;
8223: LD_ADDR_VAR 0 6
8227: PUSH
8228: EMPTY
8229: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8230: LD_EXP 53
8234: PPUSH
8235: LD_INT 75
8237: PPUSH
8238: LD_INT 101
8240: PPUSH
8241: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8245: LD_INT 35
8247: PPUSH
8248: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8252: LD_INT 1
8254: PPUSH
8255: LD_EXP 53
8259: PUSH
8260: LD_INT 1
8262: ARRAY
8263: PPUSH
8264: CALL_OW 292
8268: IFFALSE 8245
// ComStop ( ru_spec_patrol ) ;
8270: LD_EXP 53
8274: PPUSH
8275: CALL_OW 141
// Wait ( 0 0$02 ) ;
8279: LD_INT 70
8281: PPUSH
8282: CALL_OW 67
// DialogueOn ;
8286: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8290: LD_EXP 53
8294: PUSH
8295: LD_INT 1
8297: ARRAY
8298: PPUSH
8299: LD_STRING D8-Rus1-1
8301: PPUSH
8302: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8306: LD_EXP 36
8310: PPUSH
8311: LD_STRING D8-JMM-1
8313: PPUSH
8314: CALL_OW 88
// DialogueOff ;
8318: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8322: LD_EXP 53
8326: PPUSH
8327: LD_INT 13
8329: PPUSH
8330: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8334: LD_INT 35
8336: PPUSH
8337: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8341: LD_VAR 0 1
8345: NOT
8346: PUSH
8347: LD_EXP 53
8351: PUSH
8352: LD_INT 1
8354: ARRAY
8355: PPUSH
8356: CALL_OW 301
8360: AND
8361: IFFALSE 8371
// dead1 := true ;
8363: LD_ADDR_VAR 0 1
8367: PUSH
8368: LD_INT 1
8370: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8371: LD_VAR 0 2
8375: NOT
8376: PUSH
8377: LD_EXP 53
8381: PUSH
8382: LD_INT 2
8384: ARRAY
8385: PPUSH
8386: CALL_OW 301
8390: AND
8391: IFFALSE 8401
// dead2 := true ;
8393: LD_ADDR_VAR 0 2
8397: PUSH
8398: LD_INT 1
8400: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8401: LD_VAR 0 3
8405: NOT
8406: PUSH
8407: LD_EXP 53
8411: PUSH
8412: LD_INT 1
8414: ARRAY
8415: PPUSH
8416: LD_INT 14
8418: PPUSH
8419: CALL_OW 308
8423: AND
8424: IFFALSE 8434
// inarea1 := true ;
8426: LD_ADDR_VAR 0 3
8430: PUSH
8431: LD_INT 1
8433: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8434: LD_VAR 0 4
8438: NOT
8439: PUSH
8440: LD_EXP 53
8444: PUSH
8445: LD_INT 2
8447: ARRAY
8448: PPUSH
8449: LD_INT 14
8451: PPUSH
8452: CALL_OW 308
8456: AND
8457: IFFALSE 8467
// inarea2 := true ;
8459: LD_ADDR_VAR 0 4
8463: PUSH
8464: LD_INT 1
8466: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8467: LD_VAR 0 1
8471: PUSH
8472: LD_VAR 0 2
8476: AND
8477: PUSH
8478: LD_VAR 0 1
8482: PUSH
8483: LD_VAR 0 4
8487: AND
8488: OR
8489: PUSH
8490: LD_VAR 0 2
8494: PUSH
8495: LD_VAR 0 3
8499: AND
8500: OR
8501: PUSH
8502: LD_VAR 0 3
8506: PUSH
8507: LD_VAR 0 4
8511: AND
8512: OR
8513: IFFALSE 8334
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8515: LD_VAR 0 3
8519: PUSH
8520: LD_VAR 0 4
8524: AND
8525: PUSH
8526: LD_VAR 0 1
8530: PUSH
8531: LD_VAR 0 4
8535: AND
8536: OR
8537: PUSH
8538: LD_VAR 0 2
8542: PUSH
8543: LD_VAR 0 3
8547: AND
8548: OR
8549: IFFALSE 9141
// begin prepare_siege := true ;
8551: LD_ADDR_EXP 30
8555: PUSH
8556: LD_INT 1
8558: ST_TO_ADDR
// DialogueOn ;
8559: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8563: LD_VAR 0 3
8567: PUSH
8568: LD_VAR 0 4
8572: AND
8573: IFFALSE 8589
// Say ( JMM , D8b-JMM-1a ) else
8575: LD_EXP 36
8579: PPUSH
8580: LD_STRING D8b-JMM-1a
8582: PPUSH
8583: CALL_OW 88
8587: GO 8601
// Say ( JMM , D8b-JMM-1 ) ;
8589: LD_EXP 36
8593: PPUSH
8594: LD_STRING D8b-JMM-1
8596: PPUSH
8597: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8601: LD_EXP 4
8605: PPUSH
8606: LD_INT 26
8608: PUSH
8609: LD_INT 1
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: PPUSH
8616: CALL_OW 72
8620: PUSH
8621: LD_EXP 37
8625: PUSH
8626: LD_EXP 38
8630: PUSH
8631: LD_EXP 47
8635: PUSH
8636: LD_EXP 50
8640: PUSH
8641: EMPTY
8642: LIST
8643: LIST
8644: LIST
8645: LIST
8646: DIFF
8647: PPUSH
8648: LD_STRING D8b-Sol1-1
8650: PPUSH
8651: CALL 625 0 2
// if Cyrus and Cyrus in jmm_units then
8655: LD_EXP 38
8659: PUSH
8660: LD_EXP 38
8664: PUSH
8665: LD_EXP 4
8669: IN
8670: AND
8671: IFFALSE 8687
// Say ( Cyrus , D8b-Cyrus-1 ) else
8673: LD_EXP 38
8677: PPUSH
8678: LD_STRING D8b-Cyrus-1
8680: PPUSH
8681: CALL_OW 88
8685: GO 8699
// Say ( JMM , D8b-JMM-1a ) ;
8687: LD_EXP 36
8691: PPUSH
8692: LD_STRING D8b-JMM-1a
8694: PPUSH
8695: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8699: LD_EXP 39
8703: PUSH
8704: LD_EXP 39
8708: PUSH
8709: LD_EXP 4
8713: IN
8714: AND
8715: IFFALSE 8729
// Say ( Lisa , D8b-Lisa-2 ) ;
8717: LD_EXP 39
8721: PPUSH
8722: LD_STRING D8b-Lisa-2
8724: PPUSH
8725: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8729: LD_EXP 37
8733: PUSH
8734: LD_EXP 37
8738: PUSH
8739: LD_EXP 4
8743: IN
8744: AND
8745: IFFALSE 8761
// Say ( Bobby , D8b-Bobby-1 ) else
8747: LD_EXP 37
8751: PPUSH
8752: LD_STRING D8b-Bobby-1
8754: PPUSH
8755: CALL_OW 88
8759: GO 8821
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8761: LD_ADDR_VAR 0 5
8765: PUSH
8766: LD_EXP 4
8770: PPUSH
8771: LD_INT 26
8773: PUSH
8774: LD_INT 1
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PPUSH
8781: CALL_OW 72
8785: PUSH
8786: LD_EXP 37
8790: PUSH
8791: LD_EXP 38
8795: PUSH
8796: LD_EXP 47
8800: PUSH
8801: LD_EXP 50
8805: PUSH
8806: EMPTY
8807: LIST
8808: LIST
8809: LIST
8810: LIST
8811: DIFF
8812: PPUSH
8813: LD_STRING D8b-Sol2-1
8815: PPUSH
8816: CALL 625 0 2
8820: ST_TO_ADDR
// DialogueOff ;
8821: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8825: LD_EXP 38
8829: PUSH
8830: LD_EXP 38
8834: PUSH
8835: LD_EXP 4
8839: IN
8840: AND
8841: IFFALSE 8866
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8843: LD_ADDR_VAR 0 6
8847: PUSH
8848: LD_VAR 0 6
8852: PPUSH
8853: LD_INT 1
8855: PPUSH
8856: LD_EXP 38
8860: PPUSH
8861: CALL_OW 2
8865: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8866: LD_EXP 37
8870: PUSH
8871: LD_EXP 37
8875: PUSH
8876: LD_EXP 4
8880: IN
8881: AND
8882: IFFALSE 8907
// tmp := Insert ( tmp , 1 , Bobby ) ;
8884: LD_ADDR_VAR 0 6
8888: PUSH
8889: LD_VAR 0 6
8893: PPUSH
8894: LD_INT 1
8896: PPUSH
8897: LD_EXP 37
8901: PPUSH
8902: CALL_OW 2
8906: ST_TO_ADDR
// if sol then
8907: LD_VAR 0 5
8911: IFFALSE 8936
// tmp := Insert ( tmp , 1 , sol ) ;
8913: LD_ADDR_VAR 0 6
8917: PUSH
8918: LD_VAR 0 6
8922: PPUSH
8923: LD_INT 1
8925: PPUSH
8926: LD_VAR 0 5
8930: PPUSH
8931: CALL_OW 2
8935: ST_TO_ADDR
// if tmp then
8936: LD_VAR 0 6
8940: IFFALSE 9100
// begin SetSide ( tmp , 8 ) ;
8942: LD_VAR 0 6
8946: PPUSH
8947: LD_INT 8
8949: PPUSH
8950: CALL_OW 235
// ComFree ( tmp ) ;
8954: LD_VAR 0 6
8958: PPUSH
8959: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8963: LD_VAR 0 6
8967: PPUSH
8968: LD_INT 15
8970: PPUSH
8971: CALL_OW 173
// AddComHold ( tmp ) ;
8975: LD_VAR 0 6
8979: PPUSH
8980: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8984: LD_INT 35
8986: PPUSH
8987: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
8991: LD_VAR 0 6
8995: PUSH
8996: LD_INT 1
8998: ARRAY
8999: PPUSH
9000: CALL_OW 314
9004: NOT
9005: IFFALSE 9019
// ComMoveToArea ( tmp , cyrusEscape ) ;
9007: LD_VAR 0 6
9011: PPUSH
9012: LD_INT 15
9014: PPUSH
9015: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
9019: LD_VAR 0 6
9023: PUSH
9024: LD_INT 1
9026: ARRAY
9027: PPUSH
9028: LD_INT 15
9030: PPUSH
9031: CALL_OW 308
9035: IFFALSE 9090
// begin RemoveUnit ( tmp [ 1 ] ) ;
9037: LD_VAR 0 6
9041: PUSH
9042: LD_INT 1
9044: ARRAY
9045: PPUSH
9046: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
9050: LD_ADDR_EXP 4
9054: PUSH
9055: LD_EXP 4
9059: PUSH
9060: LD_VAR 0 6
9064: PUSH
9065: LD_INT 1
9067: ARRAY
9068: DIFF
9069: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
9070: LD_ADDR_VAR 0 6
9074: PUSH
9075: LD_VAR 0 6
9079: PUSH
9080: LD_VAR 0 6
9084: PUSH
9085: LD_INT 1
9087: ARRAY
9088: DIFF
9089: ST_TO_ADDR
// end ; until tmp = 0 ;
9090: LD_VAR 0 6
9094: PUSH
9095: LD_INT 0
9097: EQUAL
9098: IFFALSE 8984
// end ; Wait ( 0 0$30 ) ;
9100: LD_INT 1050
9102: PPUSH
9103: CALL_OW 67
// if ru_spec_patrol then
9107: LD_EXP 53
9111: IFFALSE 9139
// for i in ru_spec_patrol do
9113: LD_ADDR_VAR 0 7
9117: PUSH
9118: LD_EXP 53
9122: PUSH
9123: FOR_IN
9124: IFFALSE 9137
// RemoveUnit ( i ) ;
9126: LD_VAR 0 7
9130: PPUSH
9131: CALL_OW 64
9135: GO 9123
9137: POP
9138: POP
// end else
9139: GO 9161
// begin prepare_siege := false ;
9141: LD_ADDR_EXP 30
9145: PUSH
9146: LD_INT 0
9148: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
9149: LD_EXP 36
9153: PPUSH
9154: LD_STRING D8a-JMM-1
9156: PPUSH
9157: CALL_OW 88
// end ; end ;
9161: PPOPN 7
9163: END
// every 0 0$10 trigger frank_can_return do var i , p , points ;
9164: LD_EXP 12
9168: IFFALSE 10385
9170: GO 9172
9172: DISABLE
9173: LD_INT 0
9175: PPUSH
9176: PPUSH
9177: PPUSH
// begin uc_side := 8 ;
9178: LD_ADDR_OWVAR 20
9182: PUSH
9183: LD_INT 8
9185: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
9186: LD_ADDR_VAR 0 3
9190: PUSH
9191: LD_INT 59
9193: PUSH
9194: LD_INT 71
9196: PUSH
9197: EMPTY
9198: LIST
9199: LIST
9200: PUSH
9201: LD_INT 122
9203: PUSH
9204: LD_INT 117
9206: PUSH
9207: EMPTY
9208: LIST
9209: LIST
9210: PUSH
9211: EMPTY
9212: LIST
9213: LIST
9214: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9215: LD_ADDR_EXP 50
9219: PUSH
9220: LD_STRING Frank
9222: PPUSH
9223: LD_INT 0
9225: PPUSH
9226: CALL 474 0 2
9230: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9231: LD_ADDR_VAR 0 1
9235: PUSH
9236: LD_INT 1
9238: PPUSH
9239: LD_INT 2
9241: PPUSH
9242: CALL_OW 12
9246: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9247: LD_EXP 50
9251: PPUSH
9252: LD_VAR 0 3
9256: PUSH
9257: LD_VAR 0 1
9261: ARRAY
9262: PUSH
9263: LD_INT 1
9265: ARRAY
9266: PPUSH
9267: LD_VAR 0 3
9271: PUSH
9272: LD_VAR 0 1
9276: ARRAY
9277: PUSH
9278: LD_INT 2
9280: ARRAY
9281: PPUSH
9282: LD_INT 0
9284: PPUSH
9285: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9289: LD_EXP 50
9293: PPUSH
9294: LD_INT 1
9296: PPUSH
9297: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9301: LD_INT 35
9303: PPUSH
9304: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 and GetLives ( Frank ) > 250 ;
9308: LD_EXP 50
9312: PPUSH
9313: LD_EXP 36
9317: PPUSH
9318: CALL_OW 296
9322: PUSH
9323: LD_INT 8
9325: LESS
9326: PUSH
9327: LD_EXP 50
9331: PPUSH
9332: CALL_OW 256
9336: PUSH
9337: LD_INT 250
9339: GREATER
9340: AND
9341: IFFALSE 9301
// Video ( true ) ;
9343: LD_INT 1
9345: PPUSH
9346: CALL 1185 0 1
// CenterOnUnits ( JMM ) ;
9350: LD_EXP 36
9354: PPUSH
9355: CALL_OW 85
// if IsInUnit ( JMM ) then
9359: LD_EXP 36
9363: PPUSH
9364: CALL_OW 310
9368: IFFALSE 9379
// ComFree ( JMM ) ;
9370: LD_EXP 36
9374: PPUSH
9375: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9379: LD_EXP 36
9383: PPUSH
9384: LD_EXP 50
9388: PPUSH
9389: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9393: LD_EXP 50
9397: PPUSH
9398: LD_EXP 36
9402: PPUSH
9403: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9407: LD_EXP 36
9411: PPUSH
9412: LD_STRING D6-JMM-1
9414: PPUSH
9415: CALL_OW 88
// p := 0 ;
9419: LD_ADDR_VAR 0 2
9423: PUSH
9424: LD_INT 0
9426: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9427: LD_INT 35
9429: PPUSH
9430: CALL_OW 67
// p := p + 1 ;
9434: LD_ADDR_VAR 0 2
9438: PUSH
9439: LD_VAR 0 2
9443: PUSH
9444: LD_INT 1
9446: PLUS
9447: ST_TO_ADDR
// until GetDistUnits ( JMM , Frank ) < 8 or p > 7 ;
9448: LD_EXP 36
9452: PPUSH
9453: LD_EXP 50
9457: PPUSH
9458: CALL_OW 296
9462: PUSH
9463: LD_INT 8
9465: LESS
9466: PUSH
9467: LD_VAR 0 2
9471: PUSH
9472: LD_INT 7
9474: GREATER
9475: OR
9476: IFFALSE 9427
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9478: LD_EXP 39
9482: PUSH
9483: LD_EXP 39
9487: PPUSH
9488: LD_EXP 50
9492: PPUSH
9493: CALL_OW 296
9497: PUSH
9498: LD_INT 20
9500: LESS
9501: AND
9502: IFFALSE 9527
// begin ComFree ( Lisa ) ;
9504: LD_EXP 39
9508: PPUSH
9509: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9513: LD_EXP 39
9517: PPUSH
9518: LD_EXP 50
9522: PPUSH
9523: CALL_OW 172
// end ; if Lynch then
9527: LD_EXP 46
9531: IFFALSE 9556
// begin ComFree ( Lynch ) ;
9533: LD_EXP 46
9537: PPUSH
9538: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9542: LD_EXP 46
9546: PPUSH
9547: LD_EXP 50
9551: PPUSH
9552: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9556: LD_EXP 36
9560: PPUSH
9561: LD_EXP 50
9565: PPUSH
9566: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9570: LD_EXP 50
9574: PPUSH
9575: LD_EXP 36
9579: PPUSH
9580: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9584: LD_EXP 50
9588: PPUSH
9589: LD_STRING D6-Frank-1
9591: PPUSH
9592: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9596: LD_INT 69
9598: PPUSH
9599: LD_INT 20
9601: PPUSH
9602: LD_INT 1
9604: PPUSH
9605: LD_INT 20
9607: NEG
9608: PPUSH
9609: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9613: LD_INT 69
9615: PPUSH
9616: LD_INT 20
9618: PPUSH
9619: LD_INT 1
9621: PPUSH
9622: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9626: LD_INT 190
9628: PPUSH
9629: LD_INT 31
9631: PPUSH
9632: LD_INT 1
9634: PPUSH
9635: LD_INT 20
9637: NEG
9638: PPUSH
9639: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9643: LD_INT 190
9645: PPUSH
9646: LD_INT 31
9648: PPUSH
9649: LD_INT 1
9651: PPUSH
9652: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9656: LD_INT 69
9658: PPUSH
9659: LD_INT 20
9661: PPUSH
9662: CALL_OW 84
// Wait ( 0 0$02 ) ;
9666: LD_INT 70
9668: PPUSH
9669: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9673: LD_EXP 36
9677: PPUSH
9678: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9682: LD_EXP 39
9686: PUSH
9687: LD_EXP 39
9691: PPUSH
9692: LD_EXP 50
9696: PPUSH
9697: CALL_OW 296
9701: PUSH
9702: LD_INT 20
9704: LESS
9705: AND
9706: PUSH
9707: LD_EXP 39
9711: PPUSH
9712: CALL_OW 302
9716: AND
9717: IFFALSE 9839
// begin ComFree ( Lisa ) ;
9719: LD_EXP 39
9723: PPUSH
9724: CALL_OW 139
// p := 0 ;
9728: LD_ADDR_VAR 0 2
9732: PUSH
9733: LD_INT 0
9735: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9736: LD_INT 35
9738: PPUSH
9739: CALL_OW 67
// p := p + 1 ;
9743: LD_ADDR_VAR 0 2
9747: PUSH
9748: LD_VAR 0 2
9752: PUSH
9753: LD_INT 1
9755: PLUS
9756: ST_TO_ADDR
// until GetDistUnits ( Lisa , Frank ) < 7 or p > 7 ;
9757: LD_EXP 39
9761: PPUSH
9762: LD_EXP 50
9766: PPUSH
9767: CALL_OW 296
9771: PUSH
9772: LD_INT 7
9774: LESS
9775: PUSH
9776: LD_VAR 0 2
9780: PUSH
9781: LD_INT 7
9783: GREATER
9784: OR
9785: IFFALSE 9736
// Say ( Lisa , D6-Lisa-1 ) ;
9787: LD_EXP 39
9791: PPUSH
9792: LD_STRING D6-Lisa-1
9794: PPUSH
9795: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9799: LD_EXP 39
9803: PPUSH
9804: LD_EXP 50
9808: PPUSH
9809: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9813: LD_EXP 50
9817: PPUSH
9818: LD_EXP 39
9822: PPUSH
9823: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9827: LD_EXP 50
9831: PPUSH
9832: LD_STRING D6-Frank-2
9834: PPUSH
9835: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9839: LD_EXP 46
9843: PUSH
9844: LD_EXP 46
9848: PPUSH
9849: LD_EXP 50
9853: PPUSH
9854: CALL_OW 296
9858: PUSH
9859: LD_INT 20
9861: LESS
9862: AND
9863: PUSH
9864: LD_EXP 46
9868: PPUSH
9869: CALL_OW 302
9873: AND
9874: IFFALSE 10055
// begin ComTurnUnit ( Lynch , JMM ) ;
9876: LD_EXP 46
9880: PPUSH
9881: LD_EXP 36
9885: PPUSH
9886: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9890: LD_EXP 50
9894: PPUSH
9895: LD_EXP 36
9899: PPUSH
9900: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9904: LD_EXP 46
9908: PPUSH
9909: LD_STRING D6-Sol1-2
9911: PPUSH
9912: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9916: LD_EXP 36
9920: PPUSH
9921: LD_STRING D6-JMM-2
9923: PPUSH
9924: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9928: LD_EXP 50
9932: PPUSH
9933: LD_STRING D6-Frank-3
9935: PPUSH
9936: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9940: LD_EXP 36
9944: PPUSH
9945: LD_STRING D6-JMM-3
9947: PPUSH
9948: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9952: LD_EXP 50
9956: PPUSH
9957: LD_STRING D6-Frank-4
9959: PPUSH
9960: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9964: LD_EXP 50
9968: PPUSH
9969: LD_STRING D6-Frank-4a
9971: PPUSH
9972: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9976: LD_EXP 36
9980: PPUSH
9981: LD_STRING D6-JMM-4
9983: PPUSH
9984: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9988: LD_EXP 50
9992: PPUSH
9993: LD_STRING D6-Frank-5
9995: PPUSH
9996: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10000: LD_EXP 39
10004: PUSH
10005: LD_EXP 39
10009: PPUSH
10010: CALL_OW 302
10014: AND
10015: IFFALSE 10029
// Say ( Lisa , D6-Lisa-5 ) ;
10017: LD_EXP 39
10021: PPUSH
10022: LD_STRING D6-Lisa-5
10024: PPUSH
10025: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10029: LD_EXP 50
10033: PPUSH
10034: LD_STRING D6-Frank-6
10036: PPUSH
10037: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10041: LD_EXP 36
10045: PPUSH
10046: LD_STRING D6-JMM-6
10048: PPUSH
10049: CALL_OW 88
// end else
10053: GO 10170
// begin ComTurnUnit ( Frank , JMM ) ;
10055: LD_EXP 50
10059: PPUSH
10060: LD_EXP 36
10064: PPUSH
10065: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
10069: LD_EXP 50
10073: PPUSH
10074: LD_STRING D6-Frank-4
10076: PPUSH
10077: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10081: LD_EXP 50
10085: PPUSH
10086: LD_STRING D6-Frank-4a
10088: PPUSH
10089: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10093: LD_EXP 36
10097: PPUSH
10098: LD_STRING D6-JMM-4
10100: PPUSH
10101: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10105: LD_EXP 50
10109: PPUSH
10110: LD_STRING D6-Frank-5
10112: PPUSH
10113: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10117: LD_EXP 39
10121: PUSH
10122: LD_EXP 39
10126: PPUSH
10127: CALL_OW 302
10131: AND
10132: IFFALSE 10146
// Say ( Lisa , D6-Lisa-5 ) ;
10134: LD_EXP 39
10138: PPUSH
10139: LD_STRING D6-Lisa-5
10141: PPUSH
10142: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10146: LD_EXP 50
10150: PPUSH
10151: LD_STRING D6-Frank-6
10153: PPUSH
10154: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10158: LD_EXP 36
10162: PPUSH
10163: LD_STRING D6-JMM-6
10165: PPUSH
10166: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
10170: LD_STRING Q1
10172: PPUSH
10173: CALL_OW 97
10177: PUSH
10178: LD_INT 1
10180: DOUBLE
10181: EQUAL
10182: IFTRUE 10186
10184: GO 10197
10186: POP
// frank_send_to_scout := true ; 2 :
10187: LD_ADDR_EXP 14
10191: PUSH
10192: LD_INT 1
10194: ST_TO_ADDR
10195: GO 10217
10197: LD_INT 2
10199: DOUBLE
10200: EQUAL
10201: IFTRUE 10205
10203: GO 10216
10205: POP
// frank_send_to_scout := false ; end ;
10206: LD_ADDR_EXP 14
10210: PUSH
10211: LD_INT 0
10213: ST_TO_ADDR
10214: GO 10217
10216: POP
// Video ( false ) ;
10217: LD_INT 0
10219: PPUSH
10220: CALL 1185 0 1
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
10224: LD_EXP 36
10228: PUSH
10229: LD_EXP 39
10233: PUSH
10234: LD_EXP 46
10238: PUSH
10239: EMPTY
10240: LIST
10241: LIST
10242: LIST
10243: PPUSH
10244: CALL_OW 139
// if frank_send_to_scout then
10248: LD_EXP 14
10252: IFFALSE 10306
// begin repeat ComMoveToArea ( Frank , cyrusEscape ) ;
10254: LD_EXP 50
10258: PPUSH
10259: LD_INT 15
10261: PPUSH
10262: CALL_OW 113
// wait ( 0 0$01 ) ;
10266: LD_INT 35
10268: PPUSH
10269: CALL_OW 67
// until not See ( 1 , Frank ) ;
10273: LD_INT 1
10275: PPUSH
10276: LD_EXP 50
10280: PPUSH
10281: CALL_OW 292
10285: NOT
10286: IFFALSE 10254
// wait ( 0 0$02 ) ;
10288: LD_INT 70
10290: PPUSH
10291: CALL_OW 67
// RemoveUnit ( Frank ) ;
10295: LD_EXP 50
10299: PPUSH
10300: CALL_OW 64
// end else
10304: GO 10318
// SetSide ( Frank , 1 ) ;
10306: LD_EXP 50
10310: PPUSH
10311: LD_INT 1
10313: PPUSH
10314: CALL_OW 235
// send_attack_on_cornel_base := true ;
10318: LD_ADDR_EXP 25
10322: PUSH
10323: LD_INT 1
10325: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10326: LD_INT 35
10328: PPUSH
10329: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10333: LD_ADDR_EXP 28
10337: PUSH
10338: LD_EXP 28
10342: PPUSH
10343: LD_STRING -
10345: PPUSH
10346: CALL 1117 0 2
10350: ST_TO_ADDR
// if debug then
10351: LD_EXP 1
10355: IFFALSE 10367
// debug_strings := time_to_prepare ;
10357: LD_ADDR_OWVAR 48
10361: PUSH
10362: LD_EXP 28
10366: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10367: LD_EXP 28
10371: PUSH
10372: LD_INT 0
10374: EQUAL
10375: IFFALSE 10326
// cornel_prepared := true ;
10377: LD_ADDR_EXP 11
10381: PUSH
10382: LD_INT 1
10384: ST_TO_ADDR
// end ;
10385: PPOPN 3
10387: END
// every 0 0$01 trigger cornel_prepared do
10388: LD_EXP 11
10392: IFFALSE 10656
10394: GO 10396
10396: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10397: LD_EXP 43
10401: PPUSH
10402: LD_STRING D3-Corn-1
10404: PPUSH
10405: CALL_OW 94
// ChangeMissionObjectives ( MOutWait ) ;
10409: LD_STRING MOutWait
10411: PPUSH
10412: CALL_OW 337
// repeat wait ( 0 0$01 ) ;
10416: LD_INT 35
10418: PPUSH
10419: CALL_OW 67
// until cornel_counter = 0 ;
10423: LD_EXP 10
10427: PUSH
10428: LD_INT 0
10430: EQUAL
10431: IFFALSE 10416
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10433: LD_EXP 43
10437: PPUSH
10438: LD_STRING D3a-Corn-1
10440: PPUSH
10441: CALL_OW 94
// if IsOk ( Cornel ) then
10445: LD_EXP 43
10449: PPUSH
10450: CALL_OW 302
10454: IFFALSE 10468
// Say ( JMM , D3a-JMM-1 ) ;
10456: LD_EXP 36
10460: PPUSH
10461: LD_STRING D3a-JMM-1
10463: PPUSH
10464: CALL_OW 88
// end_mission_allowed := true ;
10468: LD_ADDR_EXP 20
10472: PUSH
10473: LD_INT 1
10475: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10476: LD_STRING M2
10478: PPUSH
10479: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10483: LD_INT 9
10485: PPUSH
10486: LD_INT 1
10488: PPUSH
10489: CALL_OW 424
// Wait ( 0 0$05 ) ;
10493: LD_INT 175
10495: PPUSH
10496: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10500: LD_EXP 43
10504: PPUSH
10505: LD_STRING D3a-Corn-2
10507: PPUSH
10508: CALL_OW 94
// cornel_attack := true ;
10512: LD_ADDR_EXP 9
10516: PUSH
10517: LD_INT 1
10519: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10520: LD_INT 105
10522: PPUSH
10523: CALL_OW 67
// AddMoreTanks ( ) ;
10527: CALL 4862 0 0
// if frank_send_to_scout then
10531: LD_EXP 14
10535: IFFALSE 10656
// begin InitHc ;
10537: CALL_OW 19
// InitUc ;
10541: CALL_OW 18
// uc_side := 8 ;
10545: LD_ADDR_OWVAR 20
10549: PUSH
10550: LD_INT 8
10552: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10553: LD_ADDR_EXP 50
10557: PUSH
10558: LD_STRING Frank
10560: PPUSH
10561: LD_INT 0
10563: PPUSH
10564: CALL 474 0 2
10568: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10569: LD_EXP 50
10573: PPUSH
10574: LD_INT 6
10576: PPUSH
10577: LD_INT 9
10579: PPUSH
10580: LD_INT 0
10582: PPUSH
10583: CALL_OW 48
// ComCrawl ( Frank ) ;
10587: LD_EXP 50
10591: PPUSH
10592: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
10596: LD_INT 35
10598: PPUSH
10599: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
10603: LD_EXP 36
10607: PPUSH
10608: LD_EXP 50
10612: PPUSH
10613: CALL_OW 296
10617: PUSH
10618: LD_INT 9
10620: LESS
10621: IFFALSE 10596
// SetSide ( Frank , 1 ) ;
10623: LD_EXP 50
10627: PPUSH
10628: LD_INT 1
10630: PPUSH
10631: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10635: LD_EXP 50
10639: PPUSH
10640: LD_STRING D6a-Frank-1
10642: PPUSH
10643: CALL_OW 88
// ComWalk ( Frank ) ;
10647: LD_EXP 50
10651: PPUSH
10652: CALL_OW 138
// end ; end ;
10656: END
// every 0 0$01 trigger solar_builded do
10657: LD_EXP 13
10661: IFFALSE 10765
10663: GO 10665
10665: DISABLE
// begin Wait ( 0 0$02 ) ;
10666: LD_INT 70
10668: PPUSH
10669: CALL_OW 67
// DialogueOn ;
10673: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10677: LD_EXP 36
10681: PPUSH
10682: LD_STRING D2b-JMM-1
10684: PPUSH
10685: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10689: LD_EXP 47
10693: PUSH
10694: LD_EXP 47
10698: PPUSH
10699: CALL_OW 302
10703: AND
10704: IFFALSE 10754
// begin Say ( Walker , D2b-Sci1-1 ) ;
10706: LD_EXP 47
10710: PPUSH
10711: LD_STRING D2b-Sci1-1
10713: PPUSH
10714: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10718: LD_EXP 36
10722: PPUSH
10723: LD_STRING D2b-JMM-2
10725: PPUSH
10726: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10730: LD_EXP 47
10734: PPUSH
10735: LD_STRING D2b-Sci1-2
10737: PPUSH
10738: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10742: LD_EXP 36
10746: PPUSH
10747: LD_STRING D2b-JMM-3
10749: PPUSH
10750: CALL_OW 88
// end ; DialogueOff ;
10754: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10758: LD_STRING MOutSol
10760: PPUSH
10761: CALL_OW 337
// end ;
10765: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10766: LD_EXP 13
10770: PUSH
10771: LD_EXP 36
10775: PPUSH
10776: CALL_OW 302
10780: AND
10781: PUSH
10782: LD_EXP 36
10786: PPUSH
10787: CALL 951 0 1
10791: AND
10792: PUSH
10793: LD_EXP 15
10797: NOT
10798: AND
10799: IFFALSE 10870
10801: GO 10803
10803: DISABLE
10804: LD_INT 0
10806: PPUSH
// begin jmm_in_veh := true ;
10807: LD_ADDR_EXP 15
10811: PUSH
10812: LD_INT 1
10814: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10815: LD_ADDR_VAR 0 1
10819: PUSH
10820: LD_INT 0
10822: PPUSH
10823: LD_INT 1
10825: PPUSH
10826: CALL_OW 12
10830: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10831: LD_INT 70
10833: PPUSH
10834: CALL_OW 67
// if i then
10838: LD_VAR 0 1
10842: IFFALSE 10858
// Say ( JMM , D2c-JMM-1 ) else
10844: LD_EXP 36
10848: PPUSH
10849: LD_STRING D2c-JMM-1
10851: PPUSH
10852: CALL_OW 88
10856: GO 10870
// Say ( JMM , D2c-JMM-1a ) ;
10858: LD_EXP 36
10862: PPUSH
10863: LD_STRING D2c-JMM-1a
10865: PPUSH
10866: CALL_OW 88
// end ;
10870: PPOPN 1
10872: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10873: LD_EXP 13
10877: PUSH
10878: LD_EXP 37
10882: PPUSH
10883: CALL_OW 302
10887: AND
10888: PUSH
10889: LD_EXP 37
10893: PPUSH
10894: CALL 951 0 1
10898: AND
10899: PUSH
10900: LD_EXP 16
10904: NOT
10905: AND
10906: IFFALSE 10938
10908: GO 10910
10910: DISABLE
// begin bobby_in_veh := true ;
10911: LD_ADDR_EXP 16
10915: PUSH
10916: LD_INT 1
10918: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10919: LD_INT 70
10921: PPUSH
10922: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10926: LD_EXP 37
10930: PPUSH
10931: LD_STRING D2c-Bobby-1
10933: PPUSH
10934: CALL_OW 88
10938: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10939: LD_EXP 13
10943: PUSH
10944: LD_EXP 39
10948: PPUSH
10949: CALL_OW 302
10953: AND
10954: PUSH
10955: LD_EXP 39
10959: PPUSH
10960: CALL 951 0 1
10964: AND
10965: PUSH
10966: LD_EXP 18
10970: NOT
10971: AND
10972: IFFALSE 11004
10974: GO 10976
10976: DISABLE
// begin lisa_in_veh := true ;
10977: LD_ADDR_EXP 18
10981: PUSH
10982: LD_INT 1
10984: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10985: LD_INT 70
10987: PPUSH
10988: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10992: LD_EXP 39
10996: PPUSH
10997: LD_STRING D2c-Lisa-1
10999: PPUSH
11000: CALL_OW 88
11004: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
11005: LD_EXP 13
11009: PUSH
11010: LD_EXP 38
11014: PPUSH
11015: CALL_OW 302
11019: AND
11020: PUSH
11021: LD_EXP 38
11025: PPUSH
11026: CALL 951 0 1
11030: AND
11031: PUSH
11032: LD_EXP 17
11036: NOT
11037: AND
11038: IFFALSE 11109
11040: GO 11042
11042: DISABLE
11043: LD_INT 0
11045: PPUSH
// begin cyrus_in_veh := true ;
11046: LD_ADDR_EXP 17
11050: PUSH
11051: LD_INT 1
11053: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
11054: LD_ADDR_VAR 0 1
11058: PUSH
11059: LD_INT 0
11061: PPUSH
11062: LD_INT 1
11064: PPUSH
11065: CALL_OW 12
11069: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11070: LD_INT 70
11072: PPUSH
11073: CALL_OW 67
// if i then
11077: LD_VAR 0 1
11081: IFFALSE 11097
// Say ( Cyrus , D2c-Cyrus-1 ) else
11083: LD_EXP 38
11087: PPUSH
11088: LD_STRING D2c-Cyrus-1
11090: PPUSH
11091: CALL_OW 88
11095: GO 11109
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11097: LD_EXP 38
11101: PPUSH
11102: LD_STRING D2c-Cyrus-1a
11104: PPUSH
11105: CALL_OW 88
// end ;
11109: PPOPN 1
11111: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
11112: LD_EXP 43
11116: PPUSH
11117: LD_INT 16
11119: PPUSH
11120: CALL_OW 308
11124: IFFALSE 11405
11126: GO 11128
11128: DISABLE
11129: LD_INT 0
11131: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
11132: LD_INT 3
11134: PPUSH
11135: LD_EXP 43
11139: PPUSH
11140: CALL_OW 471
// send_attack_on_cornel := true ;
11144: LD_ADDR_EXP 31
11148: PUSH
11149: LD_INT 1
11151: ST_TO_ADDR
// if ru_vehicles then
11152: LD_EXP 55
11156: IFFALSE 11190
// for i in ru_vehicles do
11158: LD_ADDR_VAR 0 1
11162: PUSH
11163: LD_EXP 55
11167: PUSH
11168: FOR_IN
11169: IFFALSE 11188
// ComAgressiveMove ( i , 215 , 69 ) ;
11171: LD_VAR 0 1
11175: PPUSH
11176: LD_INT 215
11178: PPUSH
11179: LD_INT 69
11181: PPUSH
11182: CALL_OW 114
11186: GO 11168
11188: POP
11189: POP
// if ru_patrol then
11190: LD_EXP 52
11194: IFFALSE 11228
// for i in ru_patrol do
11196: LD_ADDR_VAR 0 1
11200: PUSH
11201: LD_EXP 52
11205: PUSH
11206: FOR_IN
11207: IFFALSE 11226
// ComAgressiveMove ( i , 215 , 69 ) ;
11209: LD_VAR 0 1
11213: PPUSH
11214: LD_INT 215
11216: PPUSH
11217: LD_INT 69
11219: PPUSH
11220: CALL_OW 114
11224: GO 11206
11226: POP
11227: POP
// if frank_send_to_scout then
11228: LD_EXP 14
11232: IFFALSE 11246
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
11234: LD_EXP 50
11238: PPUSH
11239: LD_STRING D3b-Frank-1
11241: PPUSH
11242: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
11246: LD_INT 105
11248: PPUSH
11249: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
11253: LD_EXP 43
11257: PPUSH
11258: LD_STRING D4-Corn-1
11260: PPUSH
11261: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
11265: LD_INT 35
11267: PPUSH
11268: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) < 6 ;
11272: LD_INT 22
11274: PUSH
11275: LD_INT 4
11277: PUSH
11278: EMPTY
11279: LIST
11280: LIST
11281: PUSH
11282: LD_INT 21
11284: PUSH
11285: LD_INT 1
11287: PUSH
11288: EMPTY
11289: LIST
11290: LIST
11291: PUSH
11292: LD_INT 3
11294: PUSH
11295: LD_INT 24
11297: PUSH
11298: LD_INT 1000
11300: PUSH
11301: EMPTY
11302: LIST
11303: LIST
11304: PUSH
11305: EMPTY
11306: LIST
11307: LIST
11308: PUSH
11309: EMPTY
11310: LIST
11311: LIST
11312: LIST
11313: PPUSH
11314: CALL_OW 69
11318: PUSH
11319: LD_INT 6
11321: LESS
11322: IFFALSE 11265
// if Cornel then
11324: LD_EXP 43
11328: IFFALSE 11368
// begin SayRadio ( Cornel , D5-Corn-1 ) ;
11330: LD_EXP 43
11334: PPUSH
11335: LD_STRING D5-Corn-1
11337: PPUSH
11338: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11342: LD_EXP 43
11346: PPUSH
11347: LD_EXP 2
11351: PUSH
11352: LD_STRING Cornel
11354: STR
11355: PPUSH
11356: CALL_OW 38
// cornel_saved := true ;
11360: LD_ADDR_EXP 26
11364: PUSH
11365: LD_INT 1
11367: ST_TO_ADDR
// end ; ChangeSideFog ( 4 , 8 ) ;
11368: LD_INT 4
11370: PPUSH
11371: LD_INT 8
11373: PPUSH
11374: CALL_OW 343
// Wait ( 0 0$01 ) ;
11378: LD_INT 35
11380: PPUSH
11381: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11385: LD_INT 3
11387: PPUSH
11388: LD_EXP 43
11392: PPUSH
11393: CALL_OW 472
// send_attack_on_cornel := false ;
11397: LD_ADDR_EXP 31
11401: PUSH
11402: LD_INT 0
11404: ST_TO_ADDR
// end ;
11405: PPOPN 1
11407: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11408: LD_INT 9
11410: PPUSH
11411: LD_INT 22
11413: PUSH
11414: LD_INT 1
11416: PUSH
11417: EMPTY
11418: LIST
11419: LIST
11420: PPUSH
11421: CALL_OW 70
11425: PUSH
11426: LD_EXP 32
11430: OR
11431: IFFALSE 11628
11433: GO 11435
11435: DISABLE
11436: LD_INT 0
11438: PPUSH
11439: PPUSH
// begin enable ;
11440: ENABLE
// if not jmm_on_west then
11441: LD_EXP 5
11445: NOT
11446: IFFALSE 11457
// begin YouLost ( 4 ) ;
11448: LD_STRING 4
11450: PPUSH
11451: CALL_OW 104
// exit ;
11455: GO 11628
// end ; if not game_end then
11457: LD_EXP 32
11461: NOT
11462: IFFALSE 11472
// game_end := true ;
11464: LD_ADDR_EXP 32
11468: PUSH
11469: LD_INT 1
11471: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11472: LD_ADDR_VAR 0 2
11476: PUSH
11477: LD_INT 9
11479: PPUSH
11480: LD_INT 22
11482: PUSH
11483: LD_INT 1
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: PPUSH
11490: CALL_OW 70
11494: ST_TO_ADDR
// if not filter then
11495: LD_VAR 0 2
11499: NOT
11500: IFFALSE 11504
// exit ;
11502: GO 11628
// for i in filter do
11504: LD_ADDR_VAR 0 1
11508: PUSH
11509: LD_VAR 0 2
11513: PUSH
11514: FOR_IN
11515: IFFALSE 11626
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle and GetNation ( i ) = nation_american then
11517: LD_VAR 0 1
11521: PPUSH
11522: CALL_OW 302
11526: PUSH
11527: LD_VAR 0 1
11531: PPUSH
11532: CALL_OW 247
11536: PUSH
11537: LD_INT 2
11539: EQUAL
11540: AND
11541: PUSH
11542: LD_VAR 0 1
11546: PPUSH
11547: CALL_OW 248
11551: PUSH
11552: LD_INT 1
11554: EQUAL
11555: AND
11556: IFFALSE 11589
// begin veh_on_meta := true ;
11558: LD_ADDR_EXP 27
11562: PUSH
11563: LD_INT 1
11565: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11566: LD_VAR 0 1
11570: PPUSH
11571: CALL_OW 311
11575: PPUSH
11576: CALL 11631 0 1
// RemoveUnit ( i ) ;
11580: LD_VAR 0 1
11584: PPUSH
11585: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11589: LD_VAR 0 1
11593: PPUSH
11594: CALL_OW 302
11598: PUSH
11599: LD_VAR 0 1
11603: PPUSH
11604: CALL_OW 247
11608: PUSH
11609: LD_INT 1
11611: EQUAL
11612: AND
11613: IFFALSE 11624
// Save ( i ) ;
11615: LD_VAR 0 1
11619: PPUSH
11620: CALL 11631 0 1
// end ;
11624: GO 11514
11626: POP
11627: POP
// end ;
11628: PPOPN 2
11630: END
// export function Save ( i ) ; begin
11631: LD_INT 0
11633: PPUSH
// save_counter := save_counter + 1 ;
11634: LD_ADDR_EXP 35
11638: PUSH
11639: LD_EXP 35
11643: PUSH
11644: LD_INT 1
11646: PLUS
11647: ST_TO_ADDR
// if i = JMM then
11648: LD_VAR 0 1
11652: PUSH
11653: LD_EXP 36
11657: EQUAL
11658: IFFALSE 11780
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11660: LD_EXP 23
11664: PUSH
11665: LD_INT 22
11667: PUSH
11668: LD_INT 1
11670: PUSH
11671: EMPTY
11672: LIST
11673: LIST
11674: PUSH
11675: LD_INT 21
11677: PUSH
11678: LD_INT 1
11680: PUSH
11681: EMPTY
11682: LIST
11683: LIST
11684: PUSH
11685: EMPTY
11686: LIST
11687: LIST
11688: PPUSH
11689: CALL_OW 69
11693: PUSH
11694: LD_INT 1
11696: GREATER
11697: AND
11698: IFFALSE 11755
// begin show_query := false ;
11700: LD_ADDR_EXP 23
11704: PUSH
11705: LD_INT 0
11707: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11708: LD_STRING Q2
11710: PPUSH
11711: CALL_OW 97
11715: PUSH
11716: LD_INT 1
11718: DOUBLE
11719: EQUAL
11720: IFTRUE 11724
11722: GO 11735
11724: POP
// wait_for_them := true ; 2 :
11725: LD_ADDR_EXP 24
11729: PUSH
11730: LD_INT 1
11732: ST_TO_ADDR
11733: GO 11755
11735: LD_INT 2
11737: DOUBLE
11738: EQUAL
11739: IFTRUE 11743
11741: GO 11754
11743: POP
// wait_for_them := false ; end ;
11744: LD_ADDR_EXP 24
11748: PUSH
11749: LD_INT 0
11751: ST_TO_ADDR
11752: GO 11755
11754: POP
// end ; save_group := save_group ^ JMM ;
11755: LD_ADDR_EXP 22
11759: PUSH
11760: LD_EXP 22
11764: PUSH
11765: LD_EXP 36
11769: ADD
11770: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11771: LD_EXP 36
11775: PPUSH
11776: CALL_OW 64
// end ; if i = Lisa then
11780: LD_VAR 0 1
11784: PUSH
11785: LD_EXP 39
11789: EQUAL
11790: IFFALSE 11817
// begin save_group := save_group ^ Lisa ;
11792: LD_ADDR_EXP 22
11796: PUSH
11797: LD_EXP 22
11801: PUSH
11802: LD_EXP 39
11806: ADD
11807: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11808: LD_EXP 39
11812: PPUSH
11813: CALL_OW 64
// end ; if i = Bobby then
11817: LD_VAR 0 1
11821: PUSH
11822: LD_EXP 37
11826: EQUAL
11827: IFFALSE 11854
// begin save_group := save_group ^ Bobby ;
11829: LD_ADDR_EXP 22
11833: PUSH
11834: LD_EXP 22
11838: PUSH
11839: LD_EXP 37
11843: ADD
11844: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11845: LD_EXP 37
11849: PPUSH
11850: CALL_OW 64
// end ; if i = Cyrus then
11854: LD_VAR 0 1
11858: PUSH
11859: LD_EXP 38
11863: EQUAL
11864: IFFALSE 11891
// begin save_group := save_group ^ Cyrus ;
11866: LD_ADDR_EXP 22
11870: PUSH
11871: LD_EXP 22
11875: PUSH
11876: LD_EXP 38
11880: ADD
11881: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11882: LD_EXP 38
11886: PPUSH
11887: CALL_OW 64
// end ; if i = Khatam then
11891: LD_VAR 0 1
11895: PUSH
11896: LD_EXP 40
11900: EQUAL
11901: IFFALSE 11928
// begin save_group := save_group ^ Khatam ;
11903: LD_ADDR_EXP 22
11907: PUSH
11908: LD_EXP 22
11912: PUSH
11913: LD_EXP 40
11917: ADD
11918: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11919: LD_EXP 40
11923: PPUSH
11924: CALL_OW 64
// end ; if i = Frank then
11928: LD_VAR 0 1
11932: PUSH
11933: LD_EXP 50
11937: EQUAL
11938: IFFALSE 11965
// begin save_group := save_group ^ Frank ;
11940: LD_ADDR_EXP 22
11944: PUSH
11945: LD_EXP 22
11949: PUSH
11950: LD_EXP 50
11954: ADD
11955: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11956: LD_EXP 50
11960: PPUSH
11961: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11965: LD_VAR 0 1
11969: PPUSH
11970: CALL_OW 302
11974: PUSH
11975: LD_VAR 0 1
11979: PPUSH
11980: CALL_OW 247
11984: PUSH
11985: LD_INT 1
11987: EQUAL
11988: AND
11989: PUSH
11990: LD_VAR 0 1
11994: PUSH
11995: LD_EXP 22
11999: IN
12000: NOT
12001: AND
12002: IFFALSE 12029
// begin save_others := save_others ^ i ;
12004: LD_ADDR_EXP 21
12008: PUSH
12009: LD_EXP 21
12013: PUSH
12014: LD_VAR 0 1
12018: ADD
12019: ST_TO_ADDR
// RemoveUnit ( i ) ;
12020: LD_VAR 0 1
12024: PPUSH
12025: CALL_OW 64
// end ; end ;
12029: LD_VAR 0 2
12033: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
12034: LD_EXP 23
12038: NOT
12039: PUSH
12040: LD_EXP 24
12044: NOT
12045: AND
12046: PUSH
12047: LD_INT 22
12049: PUSH
12050: LD_INT 1
12052: PUSH
12053: EMPTY
12054: LIST
12055: LIST
12056: PUSH
12057: LD_INT 21
12059: PUSH
12060: LD_INT 1
12062: PUSH
12063: EMPTY
12064: LIST
12065: LIST
12066: PUSH
12067: EMPTY
12068: LIST
12069: LIST
12070: PPUSH
12071: CALL_OW 69
12075: PUSH
12076: LD_INT 0
12078: EQUAL
12079: OR
12080: IFFALSE 12089
12082: GO 12084
12084: DISABLE
// EndMission ;
12085: CALL 12090 0 0
12089: END
// export function EndMission ; var i ; begin
12090: LD_INT 0
12092: PPUSH
12093: PPUSH
// Wait ( 0 0$02 ) ;
12094: LD_INT 70
12096: PPUSH
12097: CALL_OW 67
// if solar_builded then
12101: LD_EXP 13
12105: IFFALSE 12119
// AddMedal ( Solar1 , 1 ) else
12107: LD_STRING Solar1
12109: PPUSH
12110: LD_INT 1
12112: PPUSH
12113: CALL_OW 101
12117: GO 12130
// AddMedal ( Solar1 , - 1 ) ;
12119: LD_STRING Solar1
12121: PPUSH
12122: LD_INT 1
12124: NEG
12125: PPUSH
12126: CALL_OW 101
// if veh_on_meta then
12130: LD_EXP 27
12134: IFFALSE 12148
// AddMedal ( Solar2 , 1 ) else
12136: LD_STRING Solar2
12138: PPUSH
12139: LD_INT 1
12141: PPUSH
12142: CALL_OW 101
12146: GO 12178
// if solar_builded then
12148: LD_EXP 13
12152: IFFALSE 12167
// AddMedal ( Solar2 , - 1 ) else
12154: LD_STRING Solar2
12156: PPUSH
12157: LD_INT 1
12159: NEG
12160: PPUSH
12161: CALL_OW 101
12165: GO 12178
// AddMedal ( Solar2 , - 2 ) ;
12167: LD_STRING Solar2
12169: PPUSH
12170: LD_INT 2
12172: NEG
12173: PPUSH
12174: CALL_OW 101
// if lose_counter = 0 then
12178: LD_EXP 33
12182: PUSH
12183: LD_INT 0
12185: EQUAL
12186: IFFALSE 12200
// AddMedal ( No , 1 ) else
12188: LD_STRING No
12190: PPUSH
12191: LD_INT 1
12193: PPUSH
12194: CALL_OW 101
12198: GO 12244
// if lose_counter > 0 and lose_counter < 4 then
12200: LD_EXP 33
12204: PUSH
12205: LD_INT 0
12207: GREATER
12208: PUSH
12209: LD_EXP 33
12213: PUSH
12214: LD_INT 4
12216: LESS
12217: AND
12218: IFFALSE 12233
// AddMedal ( No , - 1 ) else
12220: LD_STRING No
12222: PPUSH
12223: LD_INT 1
12225: NEG
12226: PPUSH
12227: CALL_OW 101
12231: GO 12244
// AddMedal ( UpTo4 , - 1 ) ;
12233: LD_STRING UpTo4
12235: PPUSH
12236: LD_INT 1
12238: NEG
12239: PPUSH
12240: CALL_OW 101
// GiveMedals ( MAIN ) ;
12244: LD_STRING MAIN
12246: PPUSH
12247: CALL_OW 102
// if IsDead ( Pokryshkin ) then
12251: LD_EXP 51
12255: PPUSH
12256: CALL_OW 301
12260: IFFALSE 12300
// for i in save_group ^ save_others do
12262: LD_ADDR_VAR 0 2
12266: PUSH
12267: LD_EXP 22
12271: PUSH
12272: LD_EXP 21
12276: ADD
12277: PUSH
12278: FOR_IN
12279: IFFALSE 12298
// AddExperience ( i , skill_combat , 1500 ) ;
12281: LD_VAR 0 2
12285: PPUSH
12286: LD_INT 1
12288: PPUSH
12289: LD_INT 1500
12291: PPUSH
12292: CALL_OW 492
12296: GO 12278
12298: POP
12299: POP
// RewardPeople ( save_group ^ save_others ) ;
12300: LD_EXP 22
12304: PUSH
12305: LD_EXP 21
12309: ADD
12310: PPUSH
12311: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
12315: LD_EXP 36
12319: PPUSH
12320: LD_EXP 2
12324: PUSH
12325: LD_STRING JMM
12327: STR
12328: PPUSH
12329: CALL_OW 38
// if Bobby in save_group then
12333: LD_EXP 37
12337: PUSH
12338: LD_EXP 22
12342: IN
12343: IFFALSE 12363
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12345: LD_EXP 37
12349: PPUSH
12350: LD_EXP 2
12354: PUSH
12355: LD_STRING Bobby
12357: STR
12358: PPUSH
12359: CALL_OW 38
// if Cyrus in save_group then
12363: LD_EXP 38
12367: PUSH
12368: LD_EXP 22
12372: IN
12373: IFFALSE 12393
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12375: LD_EXP 38
12379: PPUSH
12380: LD_EXP 2
12384: PUSH
12385: LD_STRING Cyrus
12387: STR
12388: PPUSH
12389: CALL_OW 38
// if Lisa in save_group then
12393: LD_EXP 39
12397: PUSH
12398: LD_EXP 22
12402: IN
12403: IFFALSE 12423
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12405: LD_EXP 39
12409: PPUSH
12410: LD_EXP 2
12414: PUSH
12415: LD_STRING Lisa
12417: STR
12418: PPUSH
12419: CALL_OW 38
// if Frank in save_group then
12423: LD_EXP 50
12427: PUSH
12428: LD_EXP 22
12432: IN
12433: IFFALSE 12453
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12435: LD_EXP 50
12439: PPUSH
12440: LD_EXP 2
12444: PUSH
12445: LD_STRING Frank
12447: STR
12448: PPUSH
12449: CALL_OW 38
// if Khatam in save_group then
12453: LD_EXP 40
12457: PUSH
12458: LD_EXP 22
12462: IN
12463: IFFALSE 12483
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
12465: LD_EXP 40
12469: PPUSH
12470: LD_EXP 2
12474: PUSH
12475: LD_STRING Khatam
12477: STR
12478: PPUSH
12479: CALL_OW 38
// if save_others then
12483: LD_EXP 21
12487: IFFALSE 12501
// SaveCharacters ( save_others , 03_others ) ;
12489: LD_EXP 21
12493: PPUSH
12494: LD_STRING 03_others
12496: PPUSH
12497: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) and cornel_saved then
12501: LD_EXP 44
12505: PUSH
12506: LD_EXP 44
12510: PPUSH
12511: CALL_OW 302
12515: AND
12516: PUSH
12517: LD_EXP 26
12521: AND
12522: IFFALSE 12534
// begin ResetFog ;
12524: CALL_OW 335
// DisplayEndingScene ;
12528: CALL 12556 0 0
// end else
12532: GO 12547
// DeleteCharacters ( mission_prefix & Cornel ) ;
12534: LD_EXP 2
12538: PUSH
12539: LD_STRING Cornel
12541: STR
12542: PPUSH
12543: CALL_OW 40
// YouWin ;
12547: CALL_OW 103
// end ;
12551: LD_VAR 0 1
12555: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
12556: LD_INT 0
12558: PPUSH
12559: PPUSH
12560: PPUSH
12561: PPUSH
12562: PPUSH
12563: PPUSH
// InGameOn ;
12564: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12568: LD_INT 208
12570: PPUSH
12571: LD_INT 62
12573: PPUSH
12574: LD_INT 1
12576: PPUSH
12577: LD_INT 10
12579: NEG
12580: PPUSH
12581: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
12585: LD_INT 208
12587: PPUSH
12588: LD_INT 62
12590: PPUSH
12591: LD_INT 1
12593: PPUSH
12594: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
12598: LD_ADDR_VAR 0 3
12602: PUSH
12603: LD_INT 22
12605: PUSH
12606: LD_INT 3
12608: PUSH
12609: EMPTY
12610: LIST
12611: LIST
12612: PUSH
12613: LD_INT 2
12615: PUSH
12616: LD_INT 21
12618: PUSH
12619: LD_INT 2
12621: PUSH
12622: EMPTY
12623: LIST
12624: LIST
12625: PUSH
12626: LD_INT 21
12628: PUSH
12629: LD_INT 1
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: PUSH
12636: EMPTY
12637: LIST
12638: LIST
12639: LIST
12640: PUSH
12641: EMPTY
12642: LIST
12643: LIST
12644: PPUSH
12645: CALL_OW 69
12649: ST_TO_ADDR
// if filter then
12650: LD_VAR 0 3
12654: IFFALSE 12682
// for i in filter do
12656: LD_ADDR_VAR 0 2
12660: PUSH
12661: LD_VAR 0 3
12665: PUSH
12666: FOR_IN
12667: IFFALSE 12680
// RemoveUnit ( i ) ;
12669: LD_VAR 0 2
12673: PPUSH
12674: CALL_OW 64
12678: GO 12666
12680: POP
12681: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
12682: LD_ADDR_VAR 0 3
12686: PUSH
12687: LD_INT 22
12689: PUSH
12690: LD_INT 4
12692: PUSH
12693: EMPTY
12694: LIST
12695: LIST
12696: PUSH
12697: LD_INT 21
12699: PUSH
12700: LD_INT 1
12702: PUSH
12703: EMPTY
12704: LIST
12705: LIST
12706: PUSH
12707: EMPTY
12708: LIST
12709: LIST
12710: PPUSH
12711: CALL_OW 69
12715: ST_TO_ADDR
// if filter then
12716: LD_VAR 0 3
12720: IFFALSE 12751
// for i in filter do
12722: LD_ADDR_VAR 0 2
12726: PUSH
12727: LD_VAR 0 3
12731: PUSH
12732: FOR_IN
12733: IFFALSE 12749
// SetLives ( i , 0 ) ;
12735: LD_VAR 0 2
12739: PPUSH
12740: LD_INT 0
12742: PPUSH
12743: CALL_OW 234
12747: GO 12732
12749: POP
12750: POP
// uc_side := 4 ;
12751: LD_ADDR_OWVAR 20
12755: PUSH
12756: LD_INT 4
12758: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12759: LD_ADDR_VAR 0 4
12763: PUSH
12764: LD_STRING Cornell
12766: PPUSH
12767: LD_INT 0
12769: PPUSH
12770: CALL 474 0 2
12774: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12775: LD_VAR 0 4
12779: PPUSH
12780: LD_INT 208
12782: PPUSH
12783: LD_INT 62
12785: PPUSH
12786: LD_INT 0
12788: PPUSH
12789: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12793: LD_VAR 0 4
12797: PPUSH
12798: LD_INT 100
12800: PPUSH
12801: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12805: LD_INT 3
12807: PPUSH
12808: LD_VAR 0 4
12812: PPUSH
12813: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12817: LD_INT 4
12819: PPUSH
12820: LD_INT 3
12822: PPUSH
12823: LD_INT 1
12825: PPUSH
12826: LD_INT 1
12828: PPUSH
12829: CALL_OW 80
// uc_side := 3 ;
12833: LD_ADDR_OWVAR 20
12837: PUSH
12838: LD_INT 3
12840: ST_TO_ADDR
// uc_nation := 3 ;
12841: LD_ADDR_OWVAR 21
12845: PUSH
12846: LD_INT 3
12848: ST_TO_ADDR
// InitHc ;
12849: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12853: LD_ADDR_VAR 0 5
12857: PUSH
12858: LD_STRING Mikhail
12860: PPUSH
12861: LD_INT 0
12863: PPUSH
12864: CALL 474 0 2
12868: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12869: LD_INT 1
12871: PPUSH
12872: LD_INT 1
12874: PPUSH
12875: LD_INT 0
12877: PPUSH
12878: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12882: LD_ADDR_VAR 0 6
12886: PUSH
12887: LD_VAR 0 6
12891: PUSH
12892: CALL_OW 44
12896: ADD
12897: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12898: LD_ADDR_VAR 0 6
12902: PUSH
12903: LD_VAR 0 6
12907: PUSH
12908: CALL_OW 44
12912: ADD
12913: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12914: LD_INT 2
12916: PPUSH
12917: LD_INT 4
12919: PPUSH
12920: LD_INT 0
12922: PPUSH
12923: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12927: LD_ADDR_VAR 0 6
12931: PUSH
12932: LD_VAR 0 6
12936: PUSH
12937: CALL_OW 44
12941: ADD
12942: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12943: LD_VAR 0 5
12947: PPUSH
12948: LD_INT 17
12950: PPUSH
12951: LD_INT 0
12953: PPUSH
12954: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12958: LD_VAR 0 5
12962: PPUSH
12963: LD_INT 210
12965: PPUSH
12966: LD_INT 63
12968: PPUSH
12969: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12973: LD_VAR 0 5
12977: PPUSH
12978: LD_INT 208
12980: PPUSH
12981: LD_INT 62
12983: PPUSH
12984: CALL_OW 178
// for i in fake_russians do
12988: LD_ADDR_VAR 0 2
12992: PUSH
12993: LD_VAR 0 6
12997: PUSH
12998: FOR_IN
12999: IFFALSE 13077
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
13001: LD_VAR 0 2
13005: PPUSH
13006: LD_INT 17
13008: PPUSH
13009: LD_INT 0
13011: PPUSH
13012: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
13016: LD_VAR 0 2
13020: PPUSH
13021: LD_INT 215
13023: PPUSH
13024: LD_INT 67
13026: PPUSH
13027: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
13031: LD_VAR 0 2
13035: PPUSH
13036: LD_INT 208
13038: PPUSH
13039: LD_INT 62
13041: PPUSH
13042: CALL_OW 178
// if GetClass ( i ) = 4 then
13046: LD_VAR 0 2
13050: PPUSH
13051: CALL_OW 257
13055: PUSH
13056: LD_INT 4
13058: EQUAL
13059: IFFALSE 13075
// ComHeal ( i , fake_cornel ) ;
13061: LD_VAR 0 2
13065: PPUSH
13066: LD_VAR 0 4
13070: PPUSH
13071: CALL_OW 128
// end ;
13075: GO 12998
13077: POP
13078: POP
// Wait ( 0 0$01 ) ;
13079: LD_INT 35
13081: PPUSH
13082: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
13086: LD_INT 208
13088: PPUSH
13089: LD_INT 62
13091: PPUSH
13092: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
13096: LD_INT 208
13098: PPUSH
13099: LD_INT 62
13101: PPUSH
13102: LD_INT 1
13104: PPUSH
13105: LD_INT 10
13107: NEG
13108: PPUSH
13109: CALL_OW 330
// Wait ( 0 0$15 ) ;
13113: LD_INT 525
13115: PPUSH
13116: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
13120: LD_INT 208
13122: PPUSH
13123: LD_INT 62
13125: PPUSH
13126: LD_INT 1
13128: PPUSH
13129: CALL_OW 331
// ResetFog ;
13133: CALL_OW 335
// InGameOff ;
13137: CALL_OW 9
// end ;
13141: LD_VAR 0 1
13145: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
13146: LD_INT 10
13148: PPUSH
13149: LD_INT 22
13151: PUSH
13152: LD_INT 1
13154: PUSH
13155: EMPTY
13156: LIST
13157: LIST
13158: PPUSH
13159: CALL_OW 70
13163: PUSH
13164: LD_EXP 43
13168: PPUSH
13169: CALL_OW 302
13173: AND
13174: PUSH
13175: LD_INT 22
13177: PUSH
13178: LD_INT 1
13180: PUSH
13181: EMPTY
13182: LIST
13183: LIST
13184: PPUSH
13185: CALL_OW 69
13189: PPUSH
13190: LD_EXP 43
13194: PPUSH
13195: CALL_OW 74
13199: PPUSH
13200: LD_EXP 43
13204: PPUSH
13205: CALL_OW 296
13209: PUSH
13210: LD_INT 30
13212: LESS
13213: OR
13214: IFFALSE 13265
13216: GO 13218
13218: DISABLE
// begin enable ;
13219: ENABLE
// powell_warn := powell_warn + 1 ;
13220: LD_ADDR_EXP 34
13224: PUSH
13225: LD_EXP 34
13229: PUSH
13230: LD_INT 1
13232: PLUS
13233: ST_TO_ADDR
// if powell_warn = 3 then
13234: LD_EXP 34
13238: PUSH
13239: LD_INT 3
13241: EQUAL
13242: IFFALSE 13253
// begin YouLost ( 5 ) ;
13244: LD_STRING 5
13246: PPUSH
13247: CALL_OW 104
// exit ;
13251: GO 13265
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
13253: LD_EXP 45
13257: PPUSH
13258: LD_STRING DWarn-Pow-1
13260: PPUSH
13261: CALL_OW 94
// end ; end_of_file
13265: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
13266: LD_EXP 8
13270: IFFALSE 14864
13272: GO 13274
13274: DISABLE
13275: LD_INT 0
13277: PPUSH
13278: PPUSH
13279: PPUSH
13280: PPUSH
13281: PPUSH
13282: PPUSH
13283: PPUSH
13284: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
13285: LD_EXP 43
13289: PUSH
13290: LD_EXP 44
13294: ADD
13295: PUSH
13296: LD_EXP 6
13300: ADD
13301: PPUSH
13302: LD_INT 250
13304: PPUSH
13305: LD_INT 120
13307: PPUSH
13308: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff Bierezov ;
13312: LD_ADDR_VAR 0 2
13316: PUSH
13317: LD_EXP 6
13321: PPUSH
13322: LD_INT 25
13324: PUSH
13325: LD_INT 2
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: PPUSH
13332: CALL_OW 72
13336: PUSH
13337: LD_EXP 44
13341: DIFF
13342: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) diff has_eng ;
13343: LD_ADDR_VAR 0 3
13347: PUSH
13348: LD_EXP 6
13352: PPUSH
13353: LD_INT 21
13355: PUSH
13356: LD_INT 1
13358: PUSH
13359: EMPTY
13360: LIST
13361: LIST
13362: PPUSH
13363: CALL_OW 72
13367: PUSH
13368: LD_VAR 0 2
13372: DIFF
13373: ST_TO_ADDR
// if not has_eng then
13374: LD_VAR 0 2
13378: NOT
13379: IFFALSE 13462
// begin uc_side := 4 ;
13381: LD_ADDR_OWVAR 20
13385: PUSH
13386: LD_INT 4
13388: ST_TO_ADDR
// uc_nation := 1 ;
13389: LD_ADDR_OWVAR 21
13393: PUSH
13394: LD_INT 1
13396: ST_TO_ADDR
// bc_type := b_depot ;
13397: LD_ADDR_OWVAR 42
13401: PUSH
13402: LD_INT 0
13404: ST_TO_ADDR
// bc_level := 2 ;
13405: LD_ADDR_OWVAR 43
13409: PUSH
13410: LD_INT 2
13412: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13413: LD_ADDR_VAR 0 4
13417: PUSH
13418: LD_INT 264
13420: PPUSH
13421: LD_INT 120
13423: PPUSH
13424: LD_INT 4
13426: PPUSH
13427: CALL_OW 47
13431: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13432: LD_INT 264
13434: PPUSH
13435: LD_INT 120
13437: PPUSH
13438: LD_INT 4
13440: PPUSH
13441: LD_INT 10
13443: NEG
13444: PPUSH
13445: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13449: LD_INT 264
13451: PPUSH
13452: LD_INT 120
13454: PPUSH
13455: LD_INT 4
13457: PPUSH
13458: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13462: LD_INT 35
13464: PPUSH
13465: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) or IsInArea ( IsInUnit ( Cornel ) , cornelBaseArea ) ;
13469: LD_EXP 43
13473: PPUSH
13474: LD_INT 10
13476: PPUSH
13477: CALL_OW 308
13481: PUSH
13482: LD_EXP 43
13486: PPUSH
13487: CALL_OW 310
13491: PPUSH
13492: LD_INT 10
13494: PPUSH
13495: CALL_OW 308
13499: OR
13500: IFFALSE 13462
// if has_eng and not dep then
13502: LD_VAR 0 2
13506: PUSH
13507: LD_VAR 0 4
13511: NOT
13512: AND
13513: IFFALSE 13663
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
13515: LD_VAR 0 2
13519: PPUSH
13520: LD_INT 0
13522: PPUSH
13523: LD_INT 264
13525: PPUSH
13526: LD_INT 120
13528: PPUSH
13529: LD_INT 4
13531: PPUSH
13532: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
13536: LD_INT 35
13538: PPUSH
13539: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
13543: LD_INT 22
13545: PUSH
13546: LD_INT 4
13548: PUSH
13549: EMPTY
13550: LIST
13551: LIST
13552: PUSH
13553: LD_INT 30
13555: PUSH
13556: LD_INT 0
13558: PUSH
13559: EMPTY
13560: LIST
13561: LIST
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PPUSH
13567: CALL_OW 69
13571: IFFALSE 13536
// ComMoveXY ( filter , 264 , 120 ) ;
13573: LD_VAR 0 3
13577: PPUSH
13578: LD_INT 264
13580: PPUSH
13581: LD_INT 120
13583: PPUSH
13584: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
13588: LD_INT 35
13590: PPUSH
13591: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
13595: LD_INT 22
13597: PUSH
13598: LD_INT 4
13600: PUSH
13601: EMPTY
13602: LIST
13603: LIST
13604: PUSH
13605: LD_INT 30
13607: PUSH
13608: LD_INT 0
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: PUSH
13615: LD_INT 3
13617: PUSH
13618: LD_INT 57
13620: PUSH
13621: EMPTY
13622: LIST
13623: PUSH
13624: EMPTY
13625: LIST
13626: LIST
13627: PUSH
13628: EMPTY
13629: LIST
13630: LIST
13631: LIST
13632: PPUSH
13633: CALL_OW 69
13637: IFFALSE 13588
// ComMoveXY ( filter , 247 , 113 ) ;
13639: LD_VAR 0 3
13643: PPUSH
13644: LD_INT 247
13646: PPUSH
13647: LD_INT 113
13649: PPUSH
13650: CALL_OW 111
// Wait ( 0 0$2 ) ;
13654: LD_INT 70
13656: PPUSH
13657: CALL_OW 67
// end else
13661: GO 13675
// begin SetSide ( dep , 4 ) ;
13663: LD_VAR 0 4
13667: PPUSH
13668: LD_INT 4
13670: PPUSH
13671: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
13675: LD_ADDR_VAR 0 4
13679: PUSH
13680: LD_INT 22
13682: PUSH
13683: LD_INT 4
13685: PUSH
13686: EMPTY
13687: LIST
13688: LIST
13689: PUSH
13690: LD_INT 30
13692: PUSH
13693: LD_INT 0
13695: PUSH
13696: EMPTY
13697: LIST
13698: LIST
13699: PUSH
13700: EMPTY
13701: LIST
13702: LIST
13703: PPUSH
13704: CALL_OW 69
13708: PUSH
13709: LD_INT 1
13711: ARRAY
13712: ST_TO_ADDR
// for i = 1 to 2 do
13713: LD_ADDR_VAR 0 1
13717: PUSH
13718: DOUBLE
13719: LD_INT 1
13721: DEC
13722: ST_TO_ADDR
13723: LD_INT 2
13725: PUSH
13726: FOR_TO
13727: IFFALSE 13822
// begin ComEnterUnit ( filter [ 1 ] , dep ) ;
13729: LD_VAR 0 3
13733: PUSH
13734: LD_INT 1
13736: ARRAY
13737: PPUSH
13738: LD_VAR 0 4
13742: PPUSH
13743: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 2 ) ;
13747: LD_VAR 0 3
13751: PUSH
13752: LD_INT 1
13754: ARRAY
13755: PPUSH
13756: LD_INT 2
13758: PPUSH
13759: CALL_OW 183
// AddComExitBuilding ( filter [ 1 ] ) ;
13763: LD_VAR 0 3
13767: PUSH
13768: LD_INT 1
13770: ARRAY
13771: PPUSH
13772: CALL_OW 182
// repeat wait ( 0 0$1 ) ;
13776: LD_INT 35
13778: PPUSH
13779: CALL_OW 67
// until GetClass ( filter [ 1 ] ) = 2 ;
13783: LD_VAR 0 3
13787: PUSH
13788: LD_INT 1
13790: ARRAY
13791: PPUSH
13792: CALL_OW 257
13796: PUSH
13797: LD_INT 2
13799: EQUAL
13800: IFFALSE 13776
// filter := Delete ( filter , 1 ) ;
13802: LD_ADDR_VAR 0 3
13806: PUSH
13807: LD_VAR 0 3
13811: PPUSH
13812: LD_INT 1
13814: PPUSH
13815: CALL_OW 3
13819: ST_TO_ADDR
// end ;
13820: GO 13726
13822: POP
13823: POP
// if IsInUnit ( Cornel ) then
13824: LD_EXP 43
13828: PPUSH
13829: CALL_OW 310
13833: IFFALSE 13911
// begin cargo := IsInUnit ( Cornel ) ;
13835: LD_ADDR_VAR 0 7
13839: PUSH
13840: LD_EXP 43
13844: PPUSH
13845: CALL_OW 310
13849: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13850: LD_VAR 0 7
13854: PPUSH
13855: LD_INT 1
13857: PPUSH
13858: CALL_OW 289
13862: IFFALSE 13873
// ComUnload ( cargo ) ;
13864: LD_VAR 0 7
13868: PPUSH
13869: CALL_OW 159
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13873: LD_EXP 43
13877: PPUSH
13878: LD_INT 235
13880: PPUSH
13881: LD_INT 122
13883: PPUSH
13884: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13888: LD_EXP 43
13892: PPUSH
13893: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13897: LD_EXP 43
13901: PPUSH
13902: LD_VAR 0 4
13906: PPUSH
13907: CALL_OW 180
// end ; if Bierezov then
13911: LD_EXP 44
13915: IFFALSE 13963
// begin ComMoveXY ( Bierezov , 260 , 120 ) ;
13917: LD_EXP 44
13921: PPUSH
13922: LD_INT 260
13924: PPUSH
13925: LD_INT 120
13927: PPUSH
13928: CALL_OW 111
// if dep then
13932: LD_VAR 0 4
13936: IFFALSE 13954
// AddComEnterUnit ( Bierezov , dep ) else
13938: LD_EXP 44
13942: PPUSH
13943: LD_VAR 0 4
13947: PPUSH
13948: CALL_OW 180
13952: GO 13963
// AddComHold ( Bierezov ) ;
13954: LD_EXP 44
13958: PPUSH
13959: CALL_OW 200
// end ; has_eng := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) diff Bierezov ;
13963: LD_ADDR_VAR 0 2
13967: PUSH
13968: LD_INT 22
13970: PUSH
13971: LD_INT 4
13973: PUSH
13974: EMPTY
13975: LIST
13976: LIST
13977: PUSH
13978: LD_INT 25
13980: PUSH
13981: LD_INT 2
13983: PUSH
13984: EMPTY
13985: LIST
13986: LIST
13987: PUSH
13988: EMPTY
13989: LIST
13990: LIST
13991: PPUSH
13992: CALL_OW 69
13996: PUSH
13997: LD_EXP 44
14001: DIFF
14002: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
14003: LD_INT 35
14005: PPUSH
14006: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
14010: LD_ADDR_VAR 0 6
14014: PUSH
14015: LD_INT 10
14017: PPUSH
14018: CALL_OW 435
14022: ST_TO_ADDR
// if crates then
14023: LD_VAR 0 6
14027: IFFALSE 14056
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
14029: LD_VAR 0 2
14033: PPUSH
14034: LD_VAR 0 6
14038: PUSH
14039: LD_INT 1
14041: ARRAY
14042: PPUSH
14043: LD_VAR 0 6
14047: PUSH
14048: LD_INT 2
14050: ARRAY
14051: PPUSH
14052: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
14056: LD_VAR 0 4
14060: PPUSH
14061: CALL_OW 274
14065: PPUSH
14066: LD_INT 1
14068: PPUSH
14069: CALL_OW 275
14073: PUSH
14074: LD_INT 40
14076: GREATEREQUAL
14077: IFFALSE 14003
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] , [ b_breastwork , 254 , 114 , 2 ] ] ;
14079: LD_ADDR_VAR 0 5
14083: PUSH
14084: LD_INT 4
14086: PUSH
14087: LD_INT 256
14089: PUSH
14090: LD_INT 111
14092: PUSH
14093: LD_INT 2
14095: PUSH
14096: EMPTY
14097: LIST
14098: LIST
14099: LIST
14100: LIST
14101: PUSH
14102: LD_INT 31
14104: PUSH
14105: LD_INT 243
14107: PUSH
14108: LD_INT 112
14110: PUSH
14111: LD_INT 2
14113: PUSH
14114: EMPTY
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: PUSH
14120: LD_INT 31
14122: PUSH
14123: LD_INT 254
14125: PUSH
14126: LD_INT 114
14128: PUSH
14129: LD_INT 2
14131: PUSH
14132: EMPTY
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: PUSH
14138: EMPTY
14139: LIST
14140: LIST
14141: LIST
14142: ST_TO_ADDR
// for i in blist do
14143: LD_ADDR_VAR 0 1
14147: PUSH
14148: LD_VAR 0 5
14152: PUSH
14153: FOR_IN
14154: IFFALSE 14203
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
14156: LD_VAR 0 2
14160: PPUSH
14161: LD_VAR 0 1
14165: PUSH
14166: LD_INT 1
14168: ARRAY
14169: PPUSH
14170: LD_VAR 0 1
14174: PUSH
14175: LD_INT 2
14177: ARRAY
14178: PPUSH
14179: LD_VAR 0 1
14183: PUSH
14184: LD_INT 3
14186: ARRAY
14187: PPUSH
14188: LD_VAR 0 1
14192: PUSH
14193: LD_INT 4
14195: ARRAY
14196: PPUSH
14197: CALL_OW 205
14201: GO 14153
14203: POP
14204: POP
// repeat wait ( 0 0$01 ) ;
14205: LD_INT 35
14207: PPUSH
14208: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
14212: LD_INT 22
14214: PUSH
14215: LD_INT 4
14217: PUSH
14218: EMPTY
14219: LIST
14220: LIST
14221: PUSH
14222: LD_INT 30
14224: PUSH
14225: LD_INT 4
14227: PUSH
14228: EMPTY
14229: LIST
14230: LIST
14231: PUSH
14232: LD_INT 3
14234: PUSH
14235: LD_INT 57
14237: PUSH
14238: EMPTY
14239: LIST
14240: PUSH
14241: EMPTY
14242: LIST
14243: LIST
14244: PUSH
14245: EMPTY
14246: LIST
14247: LIST
14248: LIST
14249: PPUSH
14250: CALL_OW 69
14254: IFFALSE 14205
// AddComEnterUnit ( filter , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14256: LD_VAR 0 3
14260: PPUSH
14261: LD_INT 22
14263: PUSH
14264: LD_INT 4
14266: PUSH
14267: EMPTY
14268: LIST
14269: LIST
14270: PUSH
14271: LD_INT 30
14273: PUSH
14274: LD_INT 4
14276: PUSH
14277: EMPTY
14278: LIST
14279: LIST
14280: PUSH
14281: EMPTY
14282: LIST
14283: LIST
14284: PPUSH
14285: CALL_OW 69
14289: PUSH
14290: LD_INT 1
14292: ARRAY
14293: PPUSH
14294: CALL_OW 180
// AddComChangeProfession ( filter , 1 ) ;
14298: LD_VAR 0 3
14302: PPUSH
14303: LD_INT 1
14305: PPUSH
14306: CALL_OW 183
// repeat wait ( 0 0$01 ) ;
14310: LD_INT 35
14312: PPUSH
14313: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) > 1 ;
14317: LD_INT 22
14319: PUSH
14320: LD_INT 4
14322: PUSH
14323: EMPTY
14324: LIST
14325: LIST
14326: PUSH
14327: LD_INT 30
14329: PUSH
14330: LD_INT 31
14332: PUSH
14333: EMPTY
14334: LIST
14335: LIST
14336: PUSH
14337: LD_INT 3
14339: PUSH
14340: LD_INT 57
14342: PUSH
14343: EMPTY
14344: LIST
14345: PUSH
14346: EMPTY
14347: LIST
14348: LIST
14349: PUSH
14350: EMPTY
14351: LIST
14352: LIST
14353: LIST
14354: PPUSH
14355: CALL_OW 69
14359: PUSH
14360: LD_INT 1
14362: GREATER
14363: IFFALSE 14310
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
14365: LD_ADDR_VAR 0 8
14369: PUSH
14370: LD_EXP 6
14374: PPUSH
14375: LD_INT 25
14377: PUSH
14378: LD_INT 1
14380: PUSH
14381: EMPTY
14382: LIST
14383: LIST
14384: PPUSH
14385: CALL_OW 72
14389: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) do
14390: LD_ADDR_VAR 0 1
14394: PUSH
14395: DOUBLE
14396: LD_INT 1
14398: DEC
14399: ST_TO_ADDR
14400: LD_INT 22
14402: PUSH
14403: LD_INT 4
14405: PUSH
14406: EMPTY
14407: LIST
14408: LIST
14409: PUSH
14410: LD_INT 30
14412: PUSH
14413: LD_INT 31
14415: PUSH
14416: EMPTY
14417: LIST
14418: LIST
14419: PUSH
14420: LD_INT 3
14422: PUSH
14423: LD_INT 57
14425: PUSH
14426: EMPTY
14427: LIST
14428: PUSH
14429: EMPTY
14430: LIST
14431: LIST
14432: PUSH
14433: EMPTY
14434: LIST
14435: LIST
14436: LIST
14437: PPUSH
14438: CALL_OW 69
14442: PUSH
14443: FOR_TO
14444: IFFALSE 14528
// begin if not sol [ i ] then
14446: LD_VAR 0 8
14450: PUSH
14451: LD_VAR 0 1
14455: ARRAY
14456: NOT
14457: IFFALSE 14461
// break ;
14459: GO 14528
// ComExitBuilding ( sol [ i ] ) ;
14461: LD_VAR 0 8
14465: PUSH
14466: LD_VAR 0 1
14470: ARRAY
14471: PPUSH
14472: CALL_OW 122
// AddComEnterUnit ( sol [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
14476: LD_VAR 0 8
14480: PUSH
14481: LD_VAR 0 1
14485: ARRAY
14486: PPUSH
14487: LD_INT 22
14489: PUSH
14490: LD_INT 4
14492: PUSH
14493: EMPTY
14494: LIST
14495: LIST
14496: PUSH
14497: LD_INT 30
14499: PUSH
14500: LD_INT 31
14502: PUSH
14503: EMPTY
14504: LIST
14505: LIST
14506: PUSH
14507: EMPTY
14508: LIST
14509: LIST
14510: PPUSH
14511: CALL_OW 69
14515: PUSH
14516: LD_VAR 0 1
14520: ARRAY
14521: PPUSH
14522: CALL_OW 180
// end ;
14526: GO 14443
14528: POP
14529: POP
// if sol > 2 then
14530: LD_VAR 0 8
14534: PUSH
14535: LD_INT 2
14537: GREATER
14538: IFFALSE 14655
// begin ComExitBuilding ( sol [ 3 ] ) ;
14540: LD_VAR 0 8
14544: PUSH
14545: LD_INT 3
14547: ARRAY
14548: PPUSH
14549: CALL_OW 122
// AddComMoveXY ( sol [ 3 ] , 246 , 94 ) ;
14553: LD_VAR 0 8
14557: PUSH
14558: LD_INT 3
14560: ARRAY
14561: PPUSH
14562: LD_INT 246
14564: PPUSH
14565: LD_INT 94
14567: PPUSH
14568: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$5 ) ;
14572: LD_VAR 0 8
14576: PUSH
14577: LD_INT 3
14579: ARRAY
14580: PPUSH
14581: LD_INT 175
14583: PPUSH
14584: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 224 , 90 ) ;
14588: LD_VAR 0 8
14592: PUSH
14593: LD_INT 3
14595: ARRAY
14596: PPUSH
14597: LD_INT 224
14599: PPUSH
14600: LD_INT 90
14602: PPUSH
14603: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$7 ) ;
14607: LD_VAR 0 8
14611: PUSH
14612: LD_INT 3
14614: ARRAY
14615: PPUSH
14616: LD_INT 245
14618: PPUSH
14619: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 223 , 110 ) ;
14623: LD_VAR 0 8
14627: PUSH
14628: LD_INT 3
14630: ARRAY
14631: PPUSH
14632: LD_INT 223
14634: PPUSH
14635: LD_INT 110
14637: PPUSH
14638: CALL_OW 171
// AddComHold ( sol [ 3 ] ) ;
14642: LD_VAR 0 8
14646: PUSH
14647: LD_INT 3
14649: ARRAY
14650: PPUSH
14651: CALL_OW 200
// end ; ComEnterUnit ( has_eng , dep ) ;
14655: LD_VAR 0 2
14659: PPUSH
14660: LD_VAR 0 4
14664: PPUSH
14665: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
14669: LD_INT 35
14671: PPUSH
14672: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14676: LD_ADDR_VAR 0 3
14680: PUSH
14681: LD_INT 22
14683: PUSH
14684: LD_INT 4
14686: PUSH
14687: EMPTY
14688: LIST
14689: LIST
14690: PUSH
14691: LD_INT 21
14693: PUSH
14694: LD_INT 3
14696: PUSH
14697: EMPTY
14698: LIST
14699: LIST
14700: PUSH
14701: LD_INT 3
14703: PUSH
14704: LD_INT 24
14706: PUSH
14707: LD_INT 1000
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: PUSH
14714: EMPTY
14715: LIST
14716: LIST
14717: PUSH
14718: EMPTY
14719: LIST
14720: LIST
14721: LIST
14722: PPUSH
14723: CALL_OW 69
14727: ST_TO_ADDR
// if filter and has_eng then
14728: LD_VAR 0 3
14732: PUSH
14733: LD_VAR 0 2
14737: AND
14738: IFFALSE 14804
// begin for i in has_eng do
14740: LD_ADDR_VAR 0 1
14744: PUSH
14745: LD_VAR 0 2
14749: PUSH
14750: FOR_IN
14751: IFFALSE 14800
// begin if IsInUnit ( i ) then
14753: LD_VAR 0 1
14757: PPUSH
14758: CALL_OW 310
14762: IFFALSE 14773
// ComExitBuilding ( i ) ;
14764: LD_VAR 0 1
14768: PPUSH
14769: CALL_OW 122
// Wait ( 3 ) ;
14773: LD_INT 3
14775: PPUSH
14776: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
14780: LD_VAR 0 1
14784: PPUSH
14785: LD_VAR 0 3
14789: PUSH
14790: LD_INT 1
14792: ARRAY
14793: PPUSH
14794: CALL_OW 130
// end ;
14798: GO 14750
14800: POP
14801: POP
// end else
14802: GO 14858
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
14804: LD_VAR 0 2
14808: PUSH
14809: LD_VAR 0 2
14813: PPUSH
14814: LD_INT 56
14816: PUSH
14817: EMPTY
14818: LIST
14819: PPUSH
14820: CALL_OW 72
14824: AND
14825: IFFALSE 14858
// for i in has_eng do
14827: LD_ADDR_VAR 0 1
14831: PUSH
14832: LD_VAR 0 2
14836: PUSH
14837: FOR_IN
14838: IFFALSE 14856
// ComEnterUnit ( i , dep ) ;
14840: LD_VAR 0 1
14844: PPUSH
14845: LD_VAR 0 4
14849: PPUSH
14850: CALL_OW 120
14854: GO 14837
14856: POP
14857: POP
// until cornel_prepared ;
14858: LD_EXP 11
14862: IFFALSE 14669
// end ;
14864: PPOPN 8
14866: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
14867: LD_EXP 11
14871: IFFALSE 15270
14873: GO 14875
14875: DISABLE
14876: LD_INT 0
14878: PPUSH
14879: PPUSH
14880: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
14881: LD_ADDR_VAR 0 2
14885: PUSH
14886: LD_INT 22
14888: PUSH
14889: LD_INT 4
14891: PUSH
14892: EMPTY
14893: LIST
14894: LIST
14895: PUSH
14896: LD_INT 30
14898: PUSH
14899: LD_INT 4
14901: PUSH
14902: EMPTY
14903: LIST
14904: LIST
14905: PUSH
14906: EMPTY
14907: LIST
14908: LIST
14909: PPUSH
14910: CALL_OW 69
14914: PUSH
14915: LD_INT 1
14917: ARRAY
14918: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
14919: LD_EXP 6
14923: PPUSH
14924: CALL_OW 122
// if Bierezov and IsInUnit ( Bierezov ) then
14928: LD_EXP 44
14932: PUSH
14933: LD_EXP 44
14937: PPUSH
14938: CALL_OW 310
14942: AND
14943: IFFALSE 14954
// ComExitBuilding ( Bierezov ) ;
14945: LD_EXP 44
14949: PPUSH
14950: CALL_OW 122
// Wait ( 0 0$03 ) ;
14954: LD_INT 105
14956: PPUSH
14957: CALL_OW 67
// for i in cornel_units do
14961: LD_ADDR_VAR 0 1
14965: PUSH
14966: LD_EXP 6
14970: PUSH
14971: FOR_IN
14972: IFFALSE 15048
// begin if GetClass ( i ) in [ 2 , 3 ] then
14974: LD_VAR 0 1
14978: PPUSH
14979: CALL_OW 257
14983: PUSH
14984: LD_INT 2
14986: PUSH
14987: LD_INT 3
14989: PUSH
14990: EMPTY
14991: LIST
14992: LIST
14993: IN
14994: IFFALSE 15031
// begin ComEnterUnit ( i , arm ) ;
14996: LD_VAR 0 1
15000: PPUSH
15001: LD_VAR 0 2
15005: PPUSH
15006: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
15010: LD_VAR 0 1
15014: PPUSH
15015: LD_INT 1
15017: PPUSH
15018: CALL_OW 183
// AddComExitBuilding ( i ) ;
15022: LD_VAR 0 1
15026: PPUSH
15027: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
15031: LD_VAR 0 1
15035: PPUSH
15036: LD_INT 257
15038: PPUSH
15039: LD_INT 121
15041: PPUSH
15042: CALL_OW 171
// end ;
15046: GO 14971
15048: POP
15049: POP
// Wait ( 1 1$00 ) ;
15050: LD_INT 2100
15052: PPUSH
15053: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
15057: LD_ADDR_VAR 0 3
15061: PUSH
15062: LD_EXP 43
15066: PUSH
15067: LD_EXP 44
15071: ADD
15072: PUSH
15073: LD_EXP 6
15077: ADD
15078: PUSH
15079: LD_EXP 6
15083: PPUSH
15084: LD_INT 21
15086: PUSH
15087: LD_INT 2
15089: PUSH
15090: EMPTY
15091: LIST
15092: LIST
15093: PPUSH
15094: CALL_OW 72
15098: DIFF
15099: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
15100: LD_VAR 0 3
15104: PPUSH
15105: LD_INT 248
15107: PPUSH
15108: LD_INT 85
15110: PPUSH
15111: CALL_OW 111
// AddComHold ( filter ) ;
15115: LD_VAR 0 3
15119: PPUSH
15120: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
15124: LD_INT 35
15126: PPUSH
15127: CALL_OW 67
// until cornel_attack ;
15131: LD_EXP 9
15135: IFFALSE 15124
// ComAgressiveMove ( filter , 209 , 63 ) ;
15137: LD_VAR 0 3
15141: PPUSH
15142: LD_INT 209
15144: PPUSH
15145: LD_INT 63
15147: PPUSH
15148: CALL_OW 114
// ComAgressiveMove ( Cornel , 208 , 62 ) ;
15152: LD_EXP 43
15156: PPUSH
15157: LD_INT 208
15159: PPUSH
15160: LD_INT 62
15162: PPUSH
15163: CALL_OW 114
// AddComHold ( Cornel ) ;
15167: LD_EXP 43
15171: PPUSH
15172: CALL_OW 200
// if Bierezov then
15176: LD_EXP 44
15180: IFFALSE 15270
// begin filter := filter diff Bierezov ;
15182: LD_ADDR_VAR 0 3
15186: PUSH
15187: LD_VAR 0 3
15191: PUSH
15192: LD_EXP 44
15196: DIFF
15197: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
15198: LD_EXP 44
15202: PPUSH
15203: LD_INT 6
15205: PPUSH
15206: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
15210: LD_EXP 44
15214: PPUSH
15215: LD_INT 235
15217: PPUSH
15218: LD_INT 60
15220: PPUSH
15221: CALL_OW 111
// AddComHold ( Bierezov ) ;
15225: LD_EXP 44
15229: PPUSH
15230: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
15234: LD_EXP 44
15238: PPUSH
15239: LD_INT 350
15241: PPUSH
15242: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
15246: LD_EXP 44
15250: PPUSH
15251: LD_INT 198
15253: PPUSH
15254: LD_INT 28
15256: PPUSH
15257: CALL_OW 171
// AddComHold ( Bierezov ) ;
15261: LD_EXP 44
15265: PPUSH
15266: CALL_OW 200
// end ; end ; end_of_file
15270: PPOPN 3
15272: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
15273: LD_EXP 52
15277: PUSH
15278: LD_EXP 30
15282: NOT
15283: AND
15284: PUSH
15285: LD_EXP 31
15289: NOT
15290: AND
15291: IFFALSE 15741
15293: GO 15295
15295: DISABLE
15296: LD_INT 0
15298: PPUSH
15299: PPUSH
15300: PPUSH
15301: PPUSH
// begin enable ;
15302: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15303: LD_ADDR_VAR 0 4
15307: PUSH
15308: LD_INT 81
15310: PUSH
15311: LD_INT 3
15313: PUSH
15314: EMPTY
15315: LIST
15316: LIST
15317: PPUSH
15318: CALL_OW 69
15322: ST_TO_ADDR
// for i = 1 to ru_patrol do
15323: LD_ADDR_VAR 0 2
15327: PUSH
15328: DOUBLE
15329: LD_INT 1
15331: DEC
15332: ST_TO_ADDR
15333: LD_EXP 52
15337: PUSH
15338: FOR_TO
15339: IFFALSE 15739
// begin un := ru_patrol [ i ] ;
15341: LD_ADDR_VAR 0 1
15345: PUSH
15346: LD_EXP 52
15350: PUSH
15351: LD_VAR 0 2
15355: ARRAY
15356: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15357: LD_VAR 0 1
15361: PPUSH
15362: LD_INT 13
15364: PPUSH
15365: CALL_OW 308
15369: IFFALSE 15474
// begin if not ru_alert then
15371: LD_EXP 59
15375: NOT
15376: IFFALSE 15386
// ru_alert := true ;
15378: LD_ADDR_EXP 59
15382: PUSH
15383: LD_INT 1
15385: ST_TO_ADDR
// if not See ( 1 , un ) then
15386: LD_INT 1
15388: PPUSH
15389: LD_VAR 0 1
15393: PPUSH
15394: CALL_OW 292
15398: NOT
15399: IFFALSE 15413
// SetLives ( un , 1000 ) ;
15401: LD_VAR 0 1
15405: PPUSH
15406: LD_INT 1000
15408: PPUSH
15409: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
15413: LD_ADDR_EXP 52
15417: PUSH
15418: LD_EXP 52
15422: PUSH
15423: LD_VAR 0 1
15427: DIFF
15428: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15429: LD_VAR 0 1
15433: PPUSH
15434: LD_INT 22
15436: PUSH
15437: LD_INT 3
15439: PUSH
15440: EMPTY
15441: LIST
15442: LIST
15443: PUSH
15444: LD_INT 30
15446: PUSH
15447: LD_INT 4
15449: PUSH
15450: EMPTY
15451: LIST
15452: LIST
15453: PUSH
15454: EMPTY
15455: LIST
15456: LIST
15457: PPUSH
15458: CALL_OW 69
15462: PPUSH
15463: CALL 1047 0 1
15467: PPUSH
15468: CALL_OW 120
// continue ;
15472: GO 15338
// end ; if IsOk ( un ) and not HasTask ( un ) then
15474: LD_VAR 0 1
15478: PPUSH
15479: CALL_OW 302
15483: PUSH
15484: LD_VAR 0 1
15488: PPUSH
15489: CALL_OW 314
15493: NOT
15494: AND
15495: IFFALSE 15588
// begin for j = 1 to ru_firepoints_south [ i ] do
15497: LD_ADDR_VAR 0 3
15501: PUSH
15502: DOUBLE
15503: LD_INT 1
15505: DEC
15506: ST_TO_ADDR
15507: LD_EXP 58
15511: PUSH
15512: LD_VAR 0 2
15516: ARRAY
15517: PUSH
15518: FOR_TO
15519: IFFALSE 15586
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
15521: LD_VAR 0 1
15525: PPUSH
15526: LD_EXP 58
15530: PUSH
15531: LD_VAR 0 2
15535: ARRAY
15536: PUSH
15537: LD_VAR 0 3
15541: ARRAY
15542: PUSH
15543: LD_INT 1
15545: ARRAY
15546: PPUSH
15547: LD_EXP 58
15551: PUSH
15552: LD_VAR 0 2
15556: ARRAY
15557: PUSH
15558: LD_VAR 0 3
15562: ARRAY
15563: PUSH
15564: LD_INT 2
15566: ARRAY
15567: PPUSH
15568: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
15572: LD_VAR 0 1
15576: PPUSH
15577: LD_INT 70
15579: PPUSH
15580: CALL_OW 202
// end ;
15584: GO 15518
15586: POP
15587: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15588: LD_VAR 0 1
15592: PPUSH
15593: CALL_OW 256
15597: PUSH
15598: LD_INT 700
15600: LESS
15601: PUSH
15602: LD_VAR 0 1
15606: PPUSH
15607: LD_INT 13
15609: PPUSH
15610: CALL_OW 308
15614: NOT
15615: AND
15616: IFFALSE 15668
// begin ComMoveToArea ( un , retreatArea ) ;
15618: LD_VAR 0 1
15622: PPUSH
15623: LD_INT 13
15625: PPUSH
15626: CALL_OW 113
// if not ru_alert_xy then
15630: LD_EXP 60
15634: NOT
15635: IFFALSE 15666
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
15637: LD_ADDR_EXP 60
15641: PUSH
15642: LD_VAR 0 1
15646: PPUSH
15647: CALL_OW 250
15651: PUSH
15652: LD_VAR 0 1
15656: PPUSH
15657: CALL_OW 251
15661: PUSH
15662: EMPTY
15663: LIST
15664: LIST
15665: ST_TO_ADDR
// end else
15666: GO 15737
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15668: LD_VAR 0 1
15672: PPUSH
15673: LD_VAR 0 4
15677: PPUSH
15678: LD_VAR 0 1
15682: PPUSH
15683: CALL_OW 74
15687: PPUSH
15688: CALL_OW 296
15692: PUSH
15693: LD_INT 9
15695: LESS
15696: PUSH
15697: LD_VAR 0 1
15701: PPUSH
15702: CALL_OW 256
15706: PUSH
15707: LD_INT 500
15709: GREATER
15710: AND
15711: IFFALSE 15737
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15713: LD_VAR 0 1
15717: PPUSH
15718: LD_VAR 0 4
15722: PPUSH
15723: LD_VAR 0 1
15727: PPUSH
15728: CALL_OW 74
15732: PPUSH
15733: CALL_OW 115
// end ;
15737: GO 15338
15739: POP
15740: POP
// end ;
15741: PPOPN 4
15743: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
15744: LD_EXP 59
15748: PUSH
15749: LD_EXP 60
15753: AND
15754: PUSH
15755: LD_EXP 30
15759: NOT
15760: AND
15761: PUSH
15762: LD_EXP 31
15766: NOT
15767: AND
15768: IFFALSE 15978
15770: GO 15772
15772: DISABLE
15773: LD_INT 0
15775: PPUSH
15776: PPUSH
// begin enable ;
15777: ENABLE
// if not ru_vehicles then
15778: LD_EXP 55
15782: NOT
15783: IFFALSE 15787
// exit ;
15785: GO 15978
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15787: LD_ADDR_VAR 0 2
15791: PUSH
15792: LD_INT 81
15794: PUSH
15795: LD_INT 3
15797: PUSH
15798: EMPTY
15799: LIST
15800: LIST
15801: PPUSH
15802: CALL_OW 69
15806: ST_TO_ADDR
// if ru_vehicles then
15807: LD_EXP 55
15811: IFFALSE 15978
// begin for i in ru_vehicles do
15813: LD_ADDR_VAR 0 1
15817: PUSH
15818: LD_EXP 55
15822: PUSH
15823: FOR_IN
15824: IFFALSE 15976
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
15826: LD_VAR 0 1
15830: PPUSH
15831: CALL_OW 302
15835: PUSH
15836: LD_VAR 0 1
15840: PPUSH
15841: LD_VAR 0 2
15845: PPUSH
15846: LD_VAR 0 1
15850: PPUSH
15851: CALL_OW 74
15855: PPUSH
15856: CALL_OW 296
15860: PUSH
15861: LD_INT 9
15863: LESS
15864: AND
15865: IFFALSE 15891
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15867: LD_VAR 0 1
15871: PPUSH
15872: LD_VAR 0 2
15876: PPUSH
15877: LD_VAR 0 1
15881: PPUSH
15882: CALL_OW 74
15886: PPUSH
15887: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
15891: LD_VAR 0 1
15895: PPUSH
15896: CALL_OW 314
15900: NOT
15901: PUSH
15902: LD_VAR 0 1
15906: PPUSH
15907: CALL_OW 302
15911: AND
15912: PUSH
15913: LD_VAR 0 1
15917: PPUSH
15918: LD_EXP 60
15922: PUSH
15923: LD_INT 1
15925: ARRAY
15926: PPUSH
15927: LD_EXP 60
15931: PUSH
15932: LD_INT 2
15934: ARRAY
15935: PPUSH
15936: CALL_OW 297
15940: PUSH
15941: LD_INT 10
15943: GREATER
15944: AND
15945: IFFALSE 15974
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
15947: LD_VAR 0 1
15951: PPUSH
15952: LD_EXP 60
15956: PUSH
15957: LD_INT 1
15959: ARRAY
15960: PPUSH
15961: LD_EXP 60
15965: PUSH
15966: LD_INT 2
15968: ARRAY
15969: PPUSH
15970: CALL_OW 114
// end ;
15974: GO 15823
15976: POP
15977: POP
// end ; end ;
15978: PPOPN 2
15980: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
15981: LD_EXP 60
15985: PUSH
15986: LD_EXP 59
15990: AND
15991: PUSH
15992: LD_INT 3
15994: PPUSH
15995: CALL_OW 463
15999: NOT
16000: AND
16001: PUSH
16002: LD_EXP 30
16006: NOT
16007: AND
16008: PUSH
16009: LD_EXP 31
16013: NOT
16014: AND
16015: IFFALSE 16110
16017: GO 16019
16019: DISABLE
16020: LD_INT 0
16022: PPUSH
// begin enable ;
16023: ENABLE
// ru_alert_xy := false ;
16024: LD_ADDR_EXP 60
16028: PUSH
16029: LD_INT 0
16031: ST_TO_ADDR
// ru_alert := false ;
16032: LD_ADDR_EXP 59
16036: PUSH
16037: LD_INT 0
16039: ST_TO_ADDR
// if ru_vehicles then
16040: LD_EXP 55
16044: IFFALSE 16110
// for i in ru_vehicles do
16046: LD_ADDR_VAR 0 1
16050: PUSH
16051: LD_EXP 55
16055: PUSH
16056: FOR_IN
16057: IFFALSE 16108
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
16059: LD_VAR 0 1
16063: PPUSH
16064: CALL_OW 302
16068: PUSH
16069: LD_VAR 0 1
16073: PPUSH
16074: LD_INT 89
16076: PPUSH
16077: LD_INT 36
16079: PPUSH
16080: CALL_OW 297
16084: PUSH
16085: LD_INT 10
16087: GREATER
16088: AND
16089: IFFALSE 16106
// ComMoveXY ( i , 89 , 36 ) ;
16091: LD_VAR 0 1
16095: PPUSH
16096: LD_INT 89
16098: PPUSH
16099: LD_INT 36
16101: PPUSH
16102: CALL_OW 111
16106: GO 16056
16108: POP
16109: POP
// end ;
16110: PPOPN 1
16112: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
16113: LD_EXP 54
16117: PUSH
16118: LD_EXP 30
16122: NOT
16123: AND
16124: PUSH
16125: LD_EXP 31
16129: NOT
16130: AND
16131: IFFALSE 16415
16133: GO 16135
16135: DISABLE
16136: LD_INT 0
16138: PPUSH
16139: PPUSH
16140: PPUSH
// begin enable ;
16141: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16142: LD_ADDR_VAR 0 3
16146: PUSH
16147: LD_INT 81
16149: PUSH
16150: LD_INT 3
16152: PUSH
16153: EMPTY
16154: LIST
16155: LIST
16156: PPUSH
16157: CALL_OW 69
16161: ST_TO_ADDR
// for i = 1 to ru_forest do
16162: LD_ADDR_VAR 0 1
16166: PUSH
16167: DOUBLE
16168: LD_INT 1
16170: DEC
16171: ST_TO_ADDR
16172: LD_EXP 54
16176: PUSH
16177: FOR_TO
16178: IFFALSE 16413
// begin un := ru_forest [ i ] ;
16180: LD_ADDR_VAR 0 2
16184: PUSH
16185: LD_EXP 54
16189: PUSH
16190: LD_VAR 0 1
16194: ARRAY
16195: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
16196: LD_VAR 0 2
16200: PPUSH
16201: LD_INT 13
16203: PPUSH
16204: CALL_OW 308
16208: IFFALSE 16298
// begin if not See ( 1 , un ) then
16210: LD_INT 1
16212: PPUSH
16213: LD_VAR 0 2
16217: PPUSH
16218: CALL_OW 292
16222: NOT
16223: IFFALSE 16237
// SetLives ( un , 1000 ) ;
16225: LD_VAR 0 2
16229: PPUSH
16230: LD_INT 1000
16232: PPUSH
16233: CALL_OW 234
// ru_forest := ru_forest diff un ;
16237: LD_ADDR_EXP 54
16241: PUSH
16242: LD_EXP 54
16246: PUSH
16247: LD_VAR 0 2
16251: DIFF
16252: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
16253: LD_VAR 0 2
16257: PPUSH
16258: LD_INT 22
16260: PUSH
16261: LD_INT 3
16263: PUSH
16264: EMPTY
16265: LIST
16266: LIST
16267: PUSH
16268: LD_INT 30
16270: PUSH
16271: LD_INT 4
16273: PUSH
16274: EMPTY
16275: LIST
16276: LIST
16277: PUSH
16278: EMPTY
16279: LIST
16280: LIST
16281: PPUSH
16282: CALL_OW 69
16286: PPUSH
16287: CALL 1047 0 1
16291: PPUSH
16292: CALL_OW 120
// continue ;
16296: GO 16177
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
16298: LD_VAR 0 2
16302: PPUSH
16303: CALL_OW 256
16307: PUSH
16308: LD_INT 700
16310: LESS
16311: PUSH
16312: LD_VAR 0 2
16316: PPUSH
16317: LD_INT 13
16319: PPUSH
16320: CALL_OW 308
16324: NOT
16325: AND
16326: IFFALSE 16342
// ComMoveToArea ( un , retreatArea ) else
16328: LD_VAR 0 2
16332: PPUSH
16333: LD_INT 13
16335: PPUSH
16336: CALL_OW 113
16340: GO 16411
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
16342: LD_VAR 0 2
16346: PPUSH
16347: LD_VAR 0 3
16351: PPUSH
16352: LD_VAR 0 2
16356: PPUSH
16357: CALL_OW 74
16361: PPUSH
16362: CALL_OW 296
16366: PUSH
16367: LD_INT 9
16369: LESS
16370: PUSH
16371: LD_VAR 0 2
16375: PPUSH
16376: CALL_OW 256
16380: PUSH
16381: LD_INT 500
16383: GREATER
16384: AND
16385: IFFALSE 16411
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
16387: LD_VAR 0 2
16391: PPUSH
16392: LD_VAR 0 3
16396: PPUSH
16397: LD_VAR 0 2
16401: PPUSH
16402: CALL_OW 74
16406: PPUSH
16407: CALL_OW 115
// end ;
16411: GO 16177
16413: POP
16414: POP
// end ;
16415: PPOPN 3
16417: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
16418: LD_EXP 31
16422: NOT
16423: IFFALSE 16544
16425: GO 16427
16427: DISABLE
16428: LD_INT 0
16430: PPUSH
16431: PPUSH
// begin enable ;
16432: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
16433: LD_ADDR_VAR 0 2
16437: PUSH
16438: LD_INT 22
16440: PUSH
16441: LD_INT 3
16443: PUSH
16444: EMPTY
16445: LIST
16446: LIST
16447: PUSH
16448: LD_INT 21
16450: PUSH
16451: LD_INT 3
16453: PUSH
16454: EMPTY
16455: LIST
16456: LIST
16457: PUSH
16458: EMPTY
16459: LIST
16460: LIST
16461: PPUSH
16462: CALL_OW 69
16466: ST_TO_ADDR
// if filter then
16467: LD_VAR 0 2
16471: IFFALSE 16544
// for i in filter do
16473: LD_ADDR_VAR 0 1
16477: PUSH
16478: LD_VAR 0 2
16482: PUSH
16483: FOR_IN
16484: IFFALSE 16542
// if GetLives ( i ) < 990 then
16486: LD_VAR 0 1
16490: PPUSH
16491: CALL_OW 256
16495: PUSH
16496: LD_INT 990
16498: LESS
16499: IFFALSE 16540
// begin ru_alert := true ;
16501: LD_ADDR_EXP 59
16505: PUSH
16506: LD_INT 1
16508: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
16509: LD_ADDR_EXP 60
16513: PUSH
16514: LD_VAR 0 1
16518: PPUSH
16519: CALL_OW 250
16523: PUSH
16524: LD_VAR 0 1
16528: PPUSH
16529: CALL_OW 251
16533: PUSH
16534: EMPTY
16535: LIST
16536: LIST
16537: ST_TO_ADDR
// break ;
16538: GO 16542
// end ;
16540: GO 16483
16542: POP
16543: POP
// end ;
16544: PPOPN 2
16546: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
16547: LD_EXP 30
16551: IFFALSE 16700
16553: GO 16555
16555: DISABLE
16556: LD_INT 0
16558: PPUSH
16559: PPUSH
16560: PPUSH
16561: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
16562: LD_ADDR_VAR 0 4
16566: PUSH
16567: LD_EXP 55
16571: PUSH
16572: LD_EXP 54
16576: ADD
16577: PUSH
16578: LD_EXP 52
16582: ADD
16583: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
16584: LD_ADDR_VAR 0 3
16588: PUSH
16589: LD_INT 3
16591: PPUSH
16592: LD_INT 81
16594: PUSH
16595: LD_INT 3
16597: PUSH
16598: EMPTY
16599: LIST
16600: LIST
16601: PPUSH
16602: CALL_OW 70
16606: ST_TO_ADDR
// if filter and enemy then
16607: LD_VAR 0 4
16611: PUSH
16612: LD_VAR 0 3
16616: AND
16617: IFFALSE 16700
// repeat wait ( 0 0$01 ) ;
16619: LD_INT 35
16621: PPUSH
16622: CALL_OW 67
// for i in filter do
16626: LD_ADDR_VAR 0 1
16630: PUSH
16631: LD_VAR 0 4
16635: PUSH
16636: FOR_IN
16637: IFFALSE 16665
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16639: LD_VAR 0 1
16643: PPUSH
16644: LD_VAR 0 3
16648: PPUSH
16649: LD_VAR 0 1
16653: PPUSH
16654: CALL_OW 74
16658: PPUSH
16659: CALL_OW 115
// end ;
16663: GO 16636
16665: POP
16666: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
16667: LD_INT 3
16669: PPUSH
16670: LD_INT 81
16672: PUSH
16673: LD_INT 3
16675: PUSH
16676: EMPTY
16677: LIST
16678: LIST
16679: PPUSH
16680: CALL_OW 70
16684: PUSH
16685: LD_INT 0
16687: EQUAL
16688: PUSH
16689: LD_VAR 0 4
16693: PUSH
16694: LD_INT 0
16696: EQUAL
16697: OR
16698: IFFALSE 16619
// end ;
16700: PPOPN 4
16702: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) do var i ;
16703: LD_EXP 25
16707: PUSH
16708: LD_INT 22
16710: PUSH
16711: LD_INT 4
16713: PUSH
16714: EMPTY
16715: LIST
16716: LIST
16717: PUSH
16718: LD_INT 30
16720: PUSH
16721: LD_INT 4
16723: PUSH
16724: EMPTY
16725: LIST
16726: LIST
16727: PUSH
16728: LD_INT 3
16730: PUSH
16731: LD_INT 57
16733: PUSH
16734: EMPTY
16735: LIST
16736: PUSH
16737: EMPTY
16738: LIST
16739: LIST
16740: PUSH
16741: EMPTY
16742: LIST
16743: LIST
16744: LIST
16745: PPUSH
16746: CALL_OW 69
16750: AND
16751: IFFALSE 16800
16753: GO 16755
16755: DISABLE
16756: LD_INT 0
16758: PPUSH
// begin if not ru_cornel_attack then
16759: LD_EXP 57
16763: NOT
16764: IFFALSE 16768
// exit ;
16766: GO 16800
// for i in ru_cornel_attack do
16768: LD_ADDR_VAR 0 1
16772: PUSH
16773: LD_EXP 57
16777: PUSH
16778: FOR_IN
16779: IFFALSE 16798
// ComAgressiveMove ( i , 258 , 119 ) ;
16781: LD_VAR 0 1
16785: PPUSH
16786: LD_INT 258
16788: PPUSH
16789: LD_INT 119
16791: PPUSH
16792: CALL_OW 114
16796: GO 16778
16798: POP
16799: POP
// end ; end_of_file
16800: PPOPN 1
16802: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
16803: LD_EXP 5
16807: PUSH
16808: LD_EXP 9
16812: NOT
16813: AND
16814: PUSH
16815: LD_EXP 19
16819: AND
16820: IFFALSE 16932
16822: GO 16824
16824: DISABLE
16825: LD_INT 0
16827: PPUSH
// begin enable ;
16828: ENABLE
// crates_counter := crates_counter - 50 ;
16829: LD_ADDR_EXP 19
16833: PUSH
16834: LD_EXP 19
16838: PUSH
16839: LD_INT 50
16841: MINUS
16842: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
16843: LD_INT 8
16845: PPUSH
16846: LD_INT 2
16848: PPUSH
16849: LD_INT 5
16851: PPUSH
16852: CALL_OW 12
16856: PPUSH
16857: LD_INT 1
16859: PPUSH
16860: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
16864: LD_INT 1785
16866: PPUSH
16867: LD_INT 2345
16869: PPUSH
16870: CALL_OW 12
16874: PPUSH
16875: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
16879: LD_ADDR_VAR 0 1
16883: PUSH
16884: LD_INT 1
16886: PPUSH
16887: LD_OWVAR 67
16891: PUSH
16892: LD_INT 2
16894: PLUS
16895: PPUSH
16896: CALL_OW 12
16900: ST_TO_ADDR
// if r < 3 then
16901: LD_VAR 0 1
16905: PUSH
16906: LD_INT 3
16908: LESS
16909: IFFALSE 16932
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
16911: LD_INT 4
16913: PPUSH
16914: LD_INT 1
16916: PPUSH
16917: LD_INT 5
16919: PPUSH
16920: CALL_OW 12
16924: PPUSH
16925: LD_INT 1
16927: PPUSH
16928: CALL_OW 55
// end ;
16932: PPOPN 1
16934: END
// every 0 0$01 trigger cornel_active do
16935: LD_EXP 8
16939: IFFALSE 17028
16941: GO 16943
16943: DISABLE
// begin Wait ( 0 0$03 ) ;
16944: LD_INT 105
16946: PPUSH
16947: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16951: LD_INT 2
16953: PPUSH
16954: LD_INT 5
16956: PPUSH
16957: CALL_OW 12
16961: PPUSH
16962: LD_INT 10
16964: PPUSH
16965: LD_INT 1
16967: PPUSH
16968: CALL_OW 55
// Wait ( 0 0$13 ) ;
16972: LD_INT 455
16974: PPUSH
16975: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16979: LD_INT 2
16981: PPUSH
16982: LD_INT 5
16984: PPUSH
16985: CALL_OW 12
16989: PPUSH
16990: LD_INT 10
16992: PPUSH
16993: LD_INT 1
16995: PPUSH
16996: CALL_OW 55
// Wait ( 0 0$16 ) ;
17000: LD_INT 560
17002: PPUSH
17003: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17007: LD_INT 2
17009: PPUSH
17010: LD_INT 5
17012: PPUSH
17013: CALL_OW 12
17017: PPUSH
17018: LD_INT 10
17020: PPUSH
17021: LD_INT 1
17023: PPUSH
17024: CALL_OW 55
// end ; end_of_file
17028: END
// every 0 0$01 trigger cornel_prepared do
17029: LD_EXP 11
17033: IFFALSE 17092
17035: GO 17037
17037: DISABLE
// begin enable ;
17038: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
17039: LD_ADDR_OWVAR 47
17043: PUSH
17044: LD_STRING #Am03-1
17046: PUSH
17047: LD_EXP 10
17051: PUSH
17052: EMPTY
17053: LIST
17054: LIST
17055: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
17056: LD_ADDR_EXP 10
17060: PUSH
17061: LD_EXP 10
17065: PPUSH
17066: LD_STRING -
17068: PPUSH
17069: CALL 1117 0 2
17073: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
17074: LD_EXP 10
17078: PUSH
17079: LD_INT 0
17081: EQUAL
17082: IFFALSE 17092
// begin Display_Strings := [ ] ;
17084: LD_ADDR_OWVAR 47
17088: PUSH
17089: EMPTY
17090: ST_TO_ADDR
// disable ;
17091: DISABLE
// end ; end ;
17092: END
// every 0 0$01 trigger debug and debug_strings do
17093: LD_EXP 1
17097: PUSH
17098: LD_OWVAR 48
17102: AND
17103: IFFALSE 17119
17105: GO 17107
17107: DISABLE
// begin enable ;
17108: ENABLE
// Display_Strings := debug_strings ;
17109: LD_ADDR_OWVAR 47
17113: PUSH
17114: LD_OWVAR 48
17118: ST_TO_ADDR
// end ; end_of_file
17119: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
17120: LD_VAR 0 1
17124: PPUSH
17125: CALL_OW 255
17129: PUSH
17130: LD_INT 1
17132: EQUAL
17133: PUSH
17134: LD_EXP 13
17138: NOT
17139: AND
17140: IFFALSE 17150
// solar_builded := true ;
17142: LD_ADDR_EXP 13
17146: PUSH
17147: LD_INT 1
17149: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
17150: LD_VAR 0 1
17154: PPUSH
17155: CALL_OW 255
17159: PUSH
17160: LD_INT 1
17162: EQUAL
17163: PUSH
17164: LD_EXP 28
17168: AND
17169: IFFALSE 17202
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
17171: LD_ADDR_EXP 28
17175: PUSH
17176: LD_EXP 28
17180: PUSH
17181: LD_INT 1750
17183: PUSH
17184: LD_INT 1400
17186: PUSH
17187: LD_INT 1225
17189: PUSH
17190: EMPTY
17191: LIST
17192: LIST
17193: LIST
17194: PUSH
17195: LD_OWVAR 67
17199: ARRAY
17200: PLUS
17201: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
17202: LD_VAR 0 1
17206: PPUSH
17207: CALL_OW 255
17211: PUSH
17212: LD_INT 3
17214: EQUAL
17215: IFFALSE 17233
// ru_vehicles := ru_vehicles ^ veh ;
17217: LD_ADDR_EXP 55
17221: PUSH
17222: LD_EXP 55
17226: PUSH
17227: LD_VAR 0 1
17231: ADD
17232: ST_TO_ADDR
// end ;
17233: PPOPN 2
17235: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
17236: LD_VAR 0 1
17240: PUSH
17241: LD_EXP 52
17245: IN
17246: IFFALSE 17264
// ru_patrol := ru_patrol diff un ;
17248: LD_ADDR_EXP 52
17252: PUSH
17253: LD_EXP 52
17257: PUSH
17258: LD_VAR 0 1
17262: DIFF
17263: ST_TO_ADDR
// if un in ru_forest then
17264: LD_VAR 0 1
17268: PUSH
17269: LD_EXP 54
17273: IN
17274: IFFALSE 17292
// ru_forest := ru_forest diff un ;
17276: LD_ADDR_EXP 54
17280: PUSH
17281: LD_EXP 54
17285: PUSH
17286: LD_VAR 0 1
17290: DIFF
17291: ST_TO_ADDR
// if un in ru_vehicles then
17292: LD_VAR 0 1
17296: PUSH
17297: LD_EXP 55
17301: IN
17302: IFFALSE 17377
// begin ru_vehicles := ru_vehicles diff un ;
17304: LD_ADDR_EXP 55
17308: PUSH
17309: LD_EXP 55
17313: PUSH
17314: LD_VAR 0 1
17318: DIFF
17319: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
17320: LD_ADDR_EXP 56
17324: PUSH
17325: LD_EXP 56
17329: PUSH
17330: LD_VAR 0 1
17334: PPUSH
17335: CALL_OW 265
17339: PUSH
17340: LD_VAR 0 1
17344: PPUSH
17345: CALL_OW 262
17349: PUSH
17350: LD_VAR 0 1
17354: PPUSH
17355: CALL_OW 263
17359: PUSH
17360: LD_VAR 0 1
17364: PPUSH
17365: CALL_OW 264
17369: PUSH
17370: EMPTY
17371: LIST
17372: LIST
17373: LIST
17374: LIST
17375: ADD
17376: ST_TO_ADDR
// end ; if un = JMM then
17377: LD_VAR 0 1
17381: PUSH
17382: LD_EXP 36
17386: EQUAL
17387: IFFALSE 17396
// YouLost ( 0 ) ;
17389: LD_STRING 0
17391: PPUSH
17392: CALL_OW 104
// if un = us_dep_west then
17396: LD_VAR 0 1
17400: PUSH
17401: LD_INT 1
17403: EQUAL
17404: IFFALSE 17413
// YouLost ( 2 ) ;
17406: LD_STRING 2
17408: PPUSH
17409: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
17413: LD_VAR 0 1
17417: PPUSH
17418: CALL_OW 255
17422: PUSH
17423: LD_INT 8
17425: EQUAL
17426: PUSH
17427: LD_EXP 5
17431: NOT
17432: AND
17433: IFFALSE 17442
// YouLost ( 4 ) ;
17435: LD_STRING 4
17437: PPUSH
17438: CALL_OW 104
// if un in jmm_units then
17442: LD_VAR 0 1
17446: PUSH
17447: LD_EXP 4
17451: IN
17452: IFFALSE 17468
// lose_counter := lose_counter + 1 ;
17454: LD_ADDR_EXP 33
17458: PUSH
17459: LD_EXP 33
17463: PUSH
17464: LD_INT 1
17466: PLUS
17467: ST_TO_ADDR
// end ;
17468: PPOPN 1
17470: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
17471: LD_INT 0
17473: PPUSH
17474: PPUSH
// begin if GetSide ( driver ) = 3 then
17475: LD_VAR 0 1
17479: PPUSH
17480: CALL_OW 255
17484: PUSH
17485: LD_INT 3
17487: EQUAL
17488: IFFALSE 17566
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
17490: LD_ADDR_VAR 0 6
17494: PUSH
17495: LD_INT 22
17497: PUSH
17498: LD_INT 3
17500: PUSH
17501: EMPTY
17502: LIST
17503: LIST
17504: PUSH
17505: LD_INT 30
17507: PUSH
17508: LD_INT 3
17510: PUSH
17511: EMPTY
17512: LIST
17513: LIST
17514: PUSH
17515: EMPTY
17516: LIST
17517: LIST
17518: PPUSH
17519: CALL_OW 69
17523: PPUSH
17524: CALL 1047 0 1
17528: ST_TO_ADDR
// if place then
17529: LD_VAR 0 6
17533: IFFALSE 17551
// ComEnterUnit ( driver , place ) else
17535: LD_VAR 0 1
17539: PPUSH
17540: LD_VAR 0 6
17544: PPUSH
17545: CALL_OW 120
17549: GO 17566
// ComMoveXY ( driver , 70 , 22 ) ;
17551: LD_VAR 0 1
17555: PPUSH
17556: LD_INT 70
17558: PPUSH
17559: LD_INT 22
17561: PPUSH
17562: CALL_OW 111
// end ; end ;
17566: PPOPN 6
17568: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and ( s2 = 4 or ( s2 = 8 and not jmm_on_west ) ) then
17569: LD_VAR 0 1
17573: PUSH
17574: LD_INT 1
17576: EQUAL
17577: PUSH
17578: LD_VAR 0 2
17582: PUSH
17583: LD_INT 4
17585: EQUAL
17586: PUSH
17587: LD_VAR 0 2
17591: PUSH
17592: LD_INT 8
17594: EQUAL
17595: PUSH
17596: LD_EXP 5
17600: NOT
17601: AND
17602: OR
17603: AND
17604: IFFALSE 17613
// YouLost ( 5 ) ;
17606: LD_STRING 5
17608: PPUSH
17609: CALL_OW 104
// end ;
17613: PPOPN 2
17615: END
// every 0 0$01 trigger save_counter + ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
17616: LD_EXP 35
17620: PUSH
17621: LD_INT 22
17623: PUSH
17624: LD_INT 1
17626: PUSH
17627: EMPTY
17628: LIST
17629: LIST
17630: PUSH
17631: LD_INT 21
17633: PUSH
17634: LD_INT 1
17636: PUSH
17637: EMPTY
17638: LIST
17639: LIST
17640: PUSH
17641: EMPTY
17642: LIST
17643: LIST
17644: PPUSH
17645: CALL_OW 69
17649: PUSH
17650: LD_INT 22
17652: PUSH
17653: LD_INT 8
17655: PUSH
17656: EMPTY
17657: LIST
17658: LIST
17659: PUSH
17660: LD_INT 21
17662: PUSH
17663: LD_INT 1
17665: PUSH
17666: EMPTY
17667: LIST
17668: LIST
17669: PUSH
17670: EMPTY
17671: LIST
17672: LIST
17673: PPUSH
17674: CALL_OW 69
17678: ADD
17679: PLUS
17680: PUSH
17681: LD_INT 5
17683: LESS
17684: IFFALSE 17696
17686: GO 17688
17688: DISABLE
// YouLost ( 1 ) ;
17689: LD_STRING 1
17691: PPUSH
17692: CALL_OW 104
17696: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
17697: LD_INT 1
17699: PPUSH
17700: CALL_OW 255
17704: PUSH
17705: LD_INT 3
17707: EQUAL
17708: IFFALSE 17720
17710: GO 17712
17712: DISABLE
// YouLost ( 3 ) ;
17713: LD_STRING 3
17715: PPUSH
17716: CALL_OW 104
17720: END
