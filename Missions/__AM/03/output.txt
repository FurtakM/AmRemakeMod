// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 363 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 451 0 0
// PrepareRussian ;
  22: CALL 2980 0 0
// PrepareAmerican ;
  26: CALL 1185 0 0
// PrepareCornell ;
  30: CALL 2209 0 0
// PrepareWesternBase ;
  34: CALL 2435 0 0
// Action ;
  38: CALL 5196 0 0
// end ;
  42: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , cornel_saved , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn , save_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  54: LD_ADDR_EXP 3
  58: PUSH
  59: LD_STRING 02_
  61: ST_TO_ADDR
// mission_prefix := 03_ ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_STRING 03_
  69: ST_TO_ADDR
// jmm_units := 0 ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// cornel_units := 0 ;
  78: LD_ADDR_EXP 6
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// bierezov_exist := false ;
  86: LD_ADDR_EXP 7
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// jmm_on_west := false ;
  94: LD_ADDR_EXP 5
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_active := false ;
 102: LD_ADDR_EXP 8
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_attack := false ;
 110: LD_ADDR_EXP 9
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// cornel_prepared := false ;
 118: LD_ADDR_EXP 11
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 126: LD_ADDR_EXP 10
 130: PUSH
 131: LD_INT 4200
 133: ST_TO_ADDR
// frank_can_return := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// solar_builded := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// frank_send_to_scout := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// jmm_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// bobby_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// cyrus_in_veh := false ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// lisa_in_veh := false ;
 182: LD_ADDR_EXP 18
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 190: LD_ADDR_EXP 28
 194: PUSH
 195: LD_INT 25200
 197: PUSH
 198: LD_INT 23100
 200: PUSH
 201: LD_INT 21000
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: PUSH
 209: LD_OWVAR 67
 213: ARRAY
 214: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 215: LD_ADDR_EXP 19
 219: PUSH
 220: LD_INT 600
 222: PUSH
 223: LD_INT 500
 225: PUSH
 226: LD_INT 400
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: PUSH
 234: LD_OWVAR 67
 238: ARRAY
 239: ST_TO_ADDR
// end_mission_allowed := false ;
 240: LD_ADDR_EXP 20
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// save_others := [ ] ;
 248: LD_ADDR_EXP 21
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// save_group := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// show_query := true ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// wait_for_them := false ;
 270: LD_ADDR_EXP 24
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// veh_on_meta := false ;
 278: LD_ADDR_EXP 27
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_spec_patrol := false ;
 286: LD_ADDR_EXP 29
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// prepare_siege := false ;
 294: LD_ADDR_EXP 30
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// send_attack_on_cornel := false ;
 302: LD_ADDR_EXP 31
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 310: LD_ADDR_EXP 25
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// game_end := false ;
 318: LD_ADDR_EXP 32
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// lose_counter := 0 ;
 326: LD_ADDR_EXP 33
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// powell_warn := 0 ;
 334: LD_ADDR_EXP 34
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// save_counter := 0 ;
 342: LD_ADDR_EXP 35
 346: PUSH
 347: LD_INT 0
 349: ST_TO_ADDR
// cornel_saved := false ;
 350: LD_ADDR_EXP 26
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// end ;
 358: LD_VAR 0 1
 362: RET
// function SetDiplomacy ; begin
 363: LD_INT 0
 365: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 366: LD_INT 1
 368: PPUSH
 369: LD_INT 4
 371: PPUSH
 372: LD_INT 1
 374: PPUSH
 375: LD_INT 1
 377: PPUSH
 378: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 382: LD_INT 1
 384: PPUSH
 385: LD_INT 8
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 398: LD_INT 3
 400: PPUSH
 401: LD_INT 6
 403: PPUSH
 404: LD_INT 1
 406: PPUSH
 407: LD_INT 1
 409: PPUSH
 410: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 414: LD_INT 4
 416: PPUSH
 417: LD_INT 6
 419: PPUSH
 420: LD_INT 0
 422: PPUSH
 423: LD_INT 1
 425: PPUSH
 426: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 430: LD_INT 3
 432: PPUSH
 433: LD_INT 8
 435: PPUSH
 436: LD_INT 0
 438: PPUSH
 439: LD_INT 1
 441: PPUSH
 442: CALL_OW 80
// end ;
 446: LD_VAR 0 1
 450: RET
// export function DebugMode ; var i ; begin
 451: LD_INT 0
 453: PPUSH
 454: PPUSH
// FogOff ( 1 ) ;
 455: LD_INT 1
 457: PPUSH
 458: CALL_OW 344
// debug_strings := [ ] ;
 462: LD_ADDR_OWVAR 48
 466: PUSH
 467: EMPTY
 468: ST_TO_ADDR
// end ; end_of_file
 469: LD_VAR 0 1
 473: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 474: LD_INT 0
 476: PPUSH
 477: PPUSH
// if exist_mode then
 478: LD_VAR 0 2
 482: IFFALSE 507
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 484: LD_ADDR_VAR 0 4
 488: PUSH
 489: LD_EXP 3
 493: PUSH
 494: LD_VAR 0 1
 498: STR
 499: PPUSH
 500: CALL_OW 34
 504: ST_TO_ADDR
 505: GO 522
// unit := NewCharacter ( ident ) ;
 507: LD_ADDR_VAR 0 4
 511: PUSH
 512: LD_VAR 0 1
 516: PPUSH
 517: CALL_OW 25
 521: ST_TO_ADDR
// result := unit ;
 522: LD_ADDR_VAR 0 3
 526: PUSH
 527: LD_VAR 0 4
 531: ST_TO_ADDR
// end ;
 532: LD_VAR 0 3
 536: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 537: LD_INT 0
 539: PPUSH
// uc_side := side ;
 540: LD_ADDR_OWVAR 20
 544: PUSH
 545: LD_VAR 0 1
 549: ST_TO_ADDR
// uc_nation := nation ;
 550: LD_ADDR_OWVAR 21
 554: PUSH
 555: LD_VAR 0 2
 559: ST_TO_ADDR
// vc_chassis := chassis ;
 560: LD_ADDR_OWVAR 37
 564: PUSH
 565: LD_VAR 0 3
 569: ST_TO_ADDR
// vc_engine := engine ;
 570: LD_ADDR_OWVAR 39
 574: PUSH
 575: LD_VAR 0 4
 579: ST_TO_ADDR
// vc_control := control ;
 580: LD_ADDR_OWVAR 38
 584: PUSH
 585: LD_VAR 0 5
 589: ST_TO_ADDR
// vc_weapon := weapon ;
 590: LD_ADDR_OWVAR 40
 594: PUSH
 595: LD_VAR 0 6
 599: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 600: LD_ADDR_OWVAR 41
 604: PUSH
 605: LD_VAR 0 7
 609: ST_TO_ADDR
// result := CreateVehicle ;
 610: LD_ADDR_VAR 0 8
 614: PUSH
 615: CALL_OW 45
 619: ST_TO_ADDR
// end ;
 620: LD_VAR 0 8
 624: RET
// export function SayX ( units , ident ) ; var i ; begin
 625: LD_INT 0
 627: PPUSH
 628: PPUSH
// result := false ;
 629: LD_ADDR_VAR 0 3
 633: PUSH
 634: LD_INT 0
 636: ST_TO_ADDR
// if not units then
 637: LD_VAR 0 1
 641: NOT
 642: IFFALSE 646
// exit ;
 644: GO 700
// for i in units do
 646: LD_ADDR_VAR 0 4
 650: PUSH
 651: LD_VAR 0 1
 655: PUSH
 656: FOR_IN
 657: IFFALSE 698
// if IsOk ( i ) then
 659: LD_VAR 0 4
 663: PPUSH
 664: CALL_OW 302
 668: IFFALSE 696
// begin Say ( i , ident ) ;
 670: LD_VAR 0 4
 674: PPUSH
 675: LD_VAR 0 2
 679: PPUSH
 680: CALL_OW 88
// result := i ;
 684: LD_ADDR_VAR 0 3
 688: PUSH
 689: LD_VAR 0 4
 693: ST_TO_ADDR
// break ;
 694: GO 698
// end ;
 696: GO 656
 698: POP
 699: POP
// end ;
 700: LD_VAR 0 3
 704: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 705: LD_INT 0
 707: PPUSH
 708: PPUSH
 709: PPUSH
 710: PPUSH
// for i = 1 to count do
 711: LD_ADDR_VAR 0 8
 715: PUSH
 716: DOUBLE
 717: LD_INT 1
 719: DEC
 720: ST_TO_ADDR
 721: LD_VAR 0 6
 725: PUSH
 726: FOR_TO
 727: IFFALSE 808
// begin uc_side = side ;
 729: LD_ADDR_OWVAR 20
 733: PUSH
 734: LD_VAR 0 1
 738: ST_TO_ADDR
// uc_nation = nation ;
 739: LD_ADDR_OWVAR 21
 743: PUSH
 744: LD_VAR 0 2
 748: ST_TO_ADDR
// hc_gallery =  ;
 749: LD_ADDR_OWVAR 33
 753: PUSH
 754: LD_STRING 
 756: ST_TO_ADDR
// hc_name =  ;
 757: LD_ADDR_OWVAR 26
 761: PUSH
 762: LD_STRING 
 764: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 765: LD_INT 0
 767: PPUSH
 768: LD_VAR 0 5
 772: PPUSH
 773: LD_VAR 0 4
 777: PPUSH
 778: CALL_OW 380
// un = CreateHuman ;
 782: LD_ADDR_VAR 0 10
 786: PUSH
 787: CALL_OW 44
 791: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 792: LD_VAR 0 10
 796: PPUSH
 797: LD_VAR 0 3
 801: PPUSH
 802: CALL_OW 52
// end ;
 806: GO 726
 808: POP
 809: POP
// end ;
 810: LD_VAR 0 7
 814: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// uc_side := GetSide ( b ) ;
 820: LD_ADDR_OWVAR 20
 824: PUSH
 825: LD_VAR 0 2
 829: PPUSH
 830: CALL_OW 255
 834: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_VAR 0 2
 844: PPUSH
 845: CALL_OW 248
 849: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 850: LD_INT 0
 852: PPUSH
 853: LD_INT 1
 855: PPUSH
 856: LD_VAR 0 1
 860: PPUSH
 861: CALL_OW 380
// un = CreateHuman ;
 865: LD_ADDR_VAR 0 4
 869: PUSH
 870: CALL_OW 44
 874: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 875: LD_ADDR_VAR 0 5
 879: PUSH
 880: LD_VAR 0 2
 884: PPUSH
 885: CALL_OW 254
 889: PUSH
 890: LD_INT 3
 892: MINUS
 893: ST_TO_ADDR
// if dir < 0 then
 894: LD_VAR 0 5
 898: PUSH
 899: LD_INT 0
 901: LESS
 902: IFFALSE 918
// dir := 6 + dir ;
 904: LD_ADDR_VAR 0 5
 908: PUSH
 909: LD_INT 6
 911: PUSH
 912: LD_VAR 0 5
 916: PLUS
 917: ST_TO_ADDR
// SetDir ( un , dir ) ;
 918: LD_VAR 0 4
 922: PPUSH
 923: LD_VAR 0 5
 927: PPUSH
 928: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 932: LD_VAR 0 4
 936: PPUSH
 937: LD_VAR 0 2
 941: PPUSH
 942: CALL_OW 52
// end ;
 946: LD_VAR 0 3
 950: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 951: LD_INT 0
 953: PPUSH
 954: PPUSH
 955: PPUSH
// result := false ;
 956: LD_ADDR_VAR 0 2
 960: PUSH
 961: LD_INT 0
 963: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 964: LD_ADDR_VAR 0 3
 968: PUSH
 969: LD_INT 22
 971: PUSH
 972: LD_INT 1
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 34
 981: PUSH
 982: LD_INT 2
 984: PUSH
 985: EMPTY
 986: LIST
 987: LIST
 988: PUSH
 989: EMPTY
 990: LIST
 991: LIST
 992: PPUSH
 993: CALL_OW 69
 997: ST_TO_ADDR
// for i in filter do
 998: LD_ADDR_VAR 0 4
1002: PUSH
1003: LD_VAR 0 3
1007: PUSH
1008: FOR_IN
1009: IFFALSE 1040
// if IsDrivenBy ( i ) = unit then
1011: LD_VAR 0 4
1015: PPUSH
1016: CALL_OW 311
1020: PUSH
1021: LD_VAR 0 1
1025: EQUAL
1026: IFFALSE 1038
// begin result := true ;
1028: LD_ADDR_VAR 0 2
1032: PUSH
1033: LD_INT 1
1035: ST_TO_ADDR
// break ;
1036: GO 1040
// end ;
1038: GO 1008
1040: POP
1041: POP
// end ;
1042: LD_VAR 0 2
1046: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1047: LD_INT 0
1049: PPUSH
1050: PPUSH
// result := false ;
1051: LD_ADDR_VAR 0 2
1055: PUSH
1056: LD_INT 0
1058: ST_TO_ADDR
// if not blist then
1059: LD_VAR 0 1
1063: NOT
1064: IFFALSE 1068
// exit ;
1066: GO 1112
// for i in blist do
1068: LD_ADDR_VAR 0 3
1072: PUSH
1073: LD_VAR 0 1
1077: PUSH
1078: FOR_IN
1079: IFFALSE 1110
// if UnitsInside ( i ) < 6 then
1081: LD_VAR 0 3
1085: PPUSH
1086: CALL_OW 313
1090: PUSH
1091: LD_INT 6
1093: LESS
1094: IFFALSE 1108
// begin result := i ;
1096: LD_ADDR_VAR 0 2
1100: PUSH
1101: LD_VAR 0 3
1105: ST_TO_ADDR
// break ;
1106: GO 1110
// end ;
1108: GO 1078
1110: POP
1111: POP
// end ;
1112: LD_VAR 0 2
1116: RET
// export function Count ( timer , mode ) ; begin
1117: LD_INT 0
1119: PPUSH
// if not timer then
1120: LD_VAR 0 1
1124: NOT
1125: IFFALSE 1129
// exit ;
1127: GO 1180
// if mode in [ asc , up , + ] then
1129: LD_VAR 0 2
1133: PUSH
1134: LD_STRING asc
1136: PUSH
1137: LD_STRING up
1139: PUSH
1140: LD_STRING +
1142: PUSH
1143: EMPTY
1144: LIST
1145: LIST
1146: LIST
1147: IN
1148: IFFALSE 1166
// result := timer + 0 0$01 else
1150: LD_ADDR_VAR 0 3
1154: PUSH
1155: LD_VAR 0 1
1159: PUSH
1160: LD_INT 35
1162: PLUS
1163: ST_TO_ADDR
1164: GO 1180
// result := timer - 0 0$01 ;
1166: LD_ADDR_VAR 0 3
1170: PUSH
1171: LD_VAR 0 1
1175: PUSH
1176: LD_INT 35
1178: MINUS
1179: ST_TO_ADDR
// end ; end_of_file
1180: LD_VAR 0 3
1184: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1185: LD_INT 0
1187: PPUSH
1188: PPUSH
1189: PPUSH
1190: PPUSH
1191: PPUSH
1192: PPUSH
1193: PPUSH
1194: PPUSH
// uc_side := 4 ;
1195: LD_ADDR_OWVAR 20
1199: PUSH
1200: LD_INT 4
1202: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1203: LD_ADDR_EXP 45
1207: PUSH
1208: LD_STRING Powell
1210: PPUSH
1211: LD_INT 0
1213: PPUSH
1214: CALL 474 0 2
1218: ST_TO_ADDR
// uc_side := 1 ;
1219: LD_ADDR_OWVAR 20
1223: PUSH
1224: LD_INT 1
1226: ST_TO_ADDR
// uc_nation := 1 ;
1227: LD_ADDR_OWVAR 21
1231: PUSH
1232: LD_INT 1
1234: ST_TO_ADDR
// if debug then
1235: LD_EXP 1
1239: IFFALSE 1369
// begin for i = 1 to 4 do
1241: LD_ADDR_VAR 0 2
1245: PUSH
1246: DOUBLE
1247: LD_INT 1
1249: DEC
1250: ST_TO_ADDR
1251: LD_INT 4
1253: PUSH
1254: FOR_TO
1255: IFFALSE 1306
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1257: LD_INT 0
1259: PPUSH
1260: LD_INT 1
1262: PPUSH
1263: LD_INT 2
1265: PPUSH
1266: CALL_OW 12
1270: PPUSH
1271: LD_INT 3
1273: PPUSH
1274: CALL_OW 380
// un := CreateHuman ;
1278: LD_ADDR_VAR 0 3
1282: PUSH
1283: CALL_OW 44
1287: ST_TO_ADDR
// others := others ^ un ;
1288: LD_ADDR_VAR 0 5
1292: PUSH
1293: LD_VAR 0 5
1297: PUSH
1298: LD_VAR 0 3
1302: ADD
1303: ST_TO_ADDR
// end ;
1304: GO 1254
1306: POP
1307: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1308: LD_ADDR_VAR 0 6
1312: PUSH
1313: LD_INT 21
1315: PUSH
1316: LD_INT 1
1318: PUSH
1319: LD_INT 1
1321: PUSH
1322: LD_INT 51
1324: PUSH
1325: LD_INT 90
1327: PUSH
1328: LD_INT 504
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: LIST
1335: LIST
1336: LIST
1337: LIST
1338: PUSH
1339: LD_INT 21
1341: PUSH
1342: LD_INT 1
1344: PUSH
1345: LD_INT 1
1347: PUSH
1348: LD_INT 51
1350: PUSH
1351: LD_INT 80
1353: PUSH
1354: LD_INT 750
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: LIST
1361: LIST
1362: LIST
1363: LIST
1364: PUSH
1365: EMPTY
1366: LIST
1367: LIST
1368: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1369: LD_ADDR_EXP 36
1373: PUSH
1374: LD_STRING JMM
1376: PPUSH
1377: LD_EXP 1
1381: NOT
1382: PPUSH
1383: CALL 474 0 2
1387: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1388: LD_ADDR_EXP 37
1392: PUSH
1393: LD_STRING Bobby
1395: PPUSH
1396: LD_EXP 1
1400: NOT
1401: PPUSH
1402: CALL 474 0 2
1406: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1407: LD_ADDR_EXP 38
1411: PUSH
1412: LD_STRING Cyrus
1414: PPUSH
1415: LD_EXP 1
1419: NOT
1420: PPUSH
1421: CALL 474 0 2
1425: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1426: LD_ADDR_EXP 39
1430: PUSH
1431: LD_STRING Lisa
1433: PPUSH
1434: LD_EXP 1
1438: NOT
1439: PPUSH
1440: CALL 474 0 2
1444: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1445: LD_ADDR_EXP 40
1449: PUSH
1450: LD_STRING Khatam
1452: PPUSH
1453: LD_EXP 1
1457: NOT
1458: PPUSH
1459: CALL 474 0 2
1463: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1464: LD_ADDR_EXP 41
1468: PUSH
1469: LD_STRING Brian
1471: PPUSH
1472: LD_EXP 1
1476: NOT
1477: PPUSH
1478: CALL 474 0 2
1482: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1483: LD_ADDR_EXP 42
1487: PUSH
1488: LD_STRING Jerry
1490: PPUSH
1491: LD_EXP 1
1495: NOT
1496: PPUSH
1497: CALL 474 0 2
1501: ST_TO_ADDR
// if Bobby then
1502: LD_EXP 37
1506: IFFALSE 1537
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1508: LD_ADDR_VAR 0 4
1512: PUSH
1513: LD_VAR 0 4
1517: PPUSH
1518: LD_VAR 0 4
1522: PUSH
1523: LD_INT 1
1525: PLUS
1526: PPUSH
1527: LD_EXP 37
1531: PPUSH
1532: CALL_OW 2
1536: ST_TO_ADDR
// if Cyrus then
1537: LD_EXP 38
1541: IFFALSE 1572
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1543: LD_ADDR_VAR 0 4
1547: PUSH
1548: LD_VAR 0 4
1552: PPUSH
1553: LD_VAR 0 4
1557: PUSH
1558: LD_INT 1
1560: PLUS
1561: PPUSH
1562: LD_EXP 38
1566: PPUSH
1567: CALL_OW 2
1571: ST_TO_ADDR
// if Lisa then
1572: LD_EXP 39
1576: IFFALSE 1607
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1578: LD_ADDR_VAR 0 4
1582: PUSH
1583: LD_VAR 0 4
1587: PPUSH
1588: LD_VAR 0 4
1592: PUSH
1593: LD_INT 1
1595: PLUS
1596: PPUSH
1597: LD_EXP 39
1601: PPUSH
1602: CALL_OW 2
1606: ST_TO_ADDR
// if Khatam then
1607: LD_EXP 40
1611: IFFALSE 1642
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1613: LD_ADDR_VAR 0 4
1617: PUSH
1618: LD_VAR 0 4
1622: PPUSH
1623: LD_VAR 0 4
1627: PUSH
1628: LD_INT 1
1630: PLUS
1631: PPUSH
1632: LD_EXP 40
1636: PPUSH
1637: CALL_OW 2
1641: ST_TO_ADDR
// if Brian then
1642: LD_EXP 41
1646: IFFALSE 1677
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1648: LD_ADDR_VAR 0 4
1652: PUSH
1653: LD_VAR 0 4
1657: PPUSH
1658: LD_VAR 0 4
1662: PUSH
1663: LD_INT 1
1665: PLUS
1666: PPUSH
1667: LD_EXP 41
1671: PPUSH
1672: CALL_OW 2
1676: ST_TO_ADDR
// if Jerry then
1677: LD_EXP 42
1681: IFFALSE 1712
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1683: LD_ADDR_VAR 0 4
1687: PUSH
1688: LD_VAR 0 4
1692: PPUSH
1693: LD_VAR 0 4
1697: PUSH
1698: LD_INT 1
1700: PLUS
1701: PPUSH
1702: LD_EXP 42
1706: PPUSH
1707: CALL_OW 2
1711: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1712: LD_STRING 02_other_survivors
1714: PPUSH
1715: CALL_OW 28
1719: IFFALSE 1734
// others := CreateCharacterSet ( 02_other_survivors ) ;
1721: LD_ADDR_VAR 0 5
1725: PUSH
1726: LD_STRING 02_other_survivors
1728: PPUSH
1729: CALL_OW 31
1733: ST_TO_ADDR
// if others then
1734: LD_VAR 0 5
1738: IFFALSE 1763
// begin tmp := tmp ^ others ;
1740: LD_ADDR_VAR 0 4
1744: PUSH
1745: LD_VAR 0 4
1749: PUSH
1750: LD_VAR 0 5
1754: ADD
1755: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1756: LD_STRING 02_other_survivors
1758: PPUSH
1759: CALL_OW 40
// end ; jmm_units := tmp ;
1763: LD_ADDR_EXP 4
1767: PUSH
1768: LD_VAR 0 4
1772: ST_TO_ADDR
// if not vehicles then
1773: LD_VAR 0 6
1777: NOT
1778: IFFALSE 1796
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1780: LD_ADDR_VAR 0 6
1784: PUSH
1785: LD_STRING 02_tanks_1
1787: PPUSH
1788: LD_INT 0
1790: PPUSH
1791: CALL_OW 30
1795: ST_TO_ADDR
// if vehicles then
1796: LD_VAR 0 6
1800: IFFALSE 1994
// begin got_mech := false ;
1802: LD_ADDR_VAR 0 7
1806: PUSH
1807: LD_INT 0
1809: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1810: LD_VAR 0 4
1814: PPUSH
1815: LD_INT 25
1817: PUSH
1818: LD_INT 3
1820: PUSH
1821: EMPTY
1822: LIST
1823: LIST
1824: PPUSH
1825: CALL_OW 72
1829: IFFALSE 1839
// got_mech := true ;
1831: LD_ADDR_VAR 0 7
1835: PUSH
1836: LD_INT 1
1838: ST_TO_ADDR
// for i = 1 to vehicles do
1839: LD_ADDR_VAR 0 2
1843: PUSH
1844: DOUBLE
1845: LD_INT 1
1847: DEC
1848: ST_TO_ADDR
1849: LD_VAR 0 6
1853: PUSH
1854: FOR_TO
1855: IFFALSE 1992
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1857: LD_ADDR_VAR 0 3
1861: PUSH
1862: LD_INT 1
1864: PPUSH
1865: LD_INT 3
1867: PPUSH
1868: LD_VAR 0 6
1872: PUSH
1873: LD_VAR 0 2
1877: ARRAY
1878: PUSH
1879: LD_INT 1
1881: ARRAY
1882: PPUSH
1883: LD_VAR 0 6
1887: PUSH
1888: LD_VAR 0 2
1892: ARRAY
1893: PUSH
1894: LD_INT 2
1896: ARRAY
1897: PPUSH
1898: LD_VAR 0 6
1902: PUSH
1903: LD_VAR 0 2
1907: ARRAY
1908: PUSH
1909: LD_INT 3
1911: ARRAY
1912: PPUSH
1913: LD_VAR 0 6
1917: PUSH
1918: LD_VAR 0 2
1922: ARRAY
1923: PUSH
1924: LD_INT 4
1926: ARRAY
1927: PPUSH
1928: LD_INT 40
1930: PPUSH
1931: CALL 537 0 7
1935: ST_TO_ADDR
// if not got_mech then
1936: LD_VAR 0 7
1940: NOT
1941: IFFALSE 1967
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1943: LD_VAR 0 3
1947: PPUSH
1948: LD_VAR 0 6
1952: PUSH
1953: LD_VAR 0 2
1957: ARRAY
1958: PUSH
1959: LD_INT 6
1961: ARRAY
1962: PPUSH
1963: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1967: LD_ADDR_VAR 0 4
1971: PUSH
1972: LD_VAR 0 4
1976: PPUSH
1977: LD_INT 1
1979: PPUSH
1980: LD_VAR 0 3
1984: PPUSH
1985: CALL_OW 2
1989: ST_TO_ADDR
// end ;
1990: GO 1854
1992: POP
1993: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1994: LD_EXP 36
1998: PPUSH
1999: LD_INT 194
2001: PPUSH
2002: LD_INT 119
2004: PPUSH
2005: LD_INT 0
2007: PPUSH
2008: CALL_OW 48
// if tmp then
2012: LD_VAR 0 4
2016: IFFALSE 2141
// begin for i in tmp do
2018: LD_ADDR_VAR 0 2
2022: PUSH
2023: LD_VAR 0 4
2027: PUSH
2028: FOR_IN
2029: IFFALSE 2139
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2031: LD_ADDR_VAR 0 8
2035: PUSH
2036: LD_INT 22
2038: PUSH
2039: LD_INT 1
2041: PUSH
2042: EMPTY
2043: LIST
2044: LIST
2045: PUSH
2046: LD_INT 21
2048: PUSH
2049: LD_INT 2
2051: PUSH
2052: EMPTY
2053: LIST
2054: LIST
2055: PUSH
2056: LD_INT 58
2058: PUSH
2059: EMPTY
2060: LIST
2061: PUSH
2062: EMPTY
2063: LIST
2064: LIST
2065: LIST
2066: PPUSH
2067: CALL_OW 69
2071: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2072: LD_VAR 0 2
2076: PPUSH
2077: CALL_OW 247
2081: PUSH
2082: LD_INT 1
2084: EQUAL
2085: PUSH
2086: LD_VAR 0 8
2090: AND
2091: IFFALSE 2113
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2093: LD_VAR 0 2
2097: PPUSH
2098: LD_VAR 0 8
2102: PUSH
2103: LD_INT 1
2105: ARRAY
2106: PPUSH
2107: CALL_OW 52
2111: GO 2128
// PlaceUnitArea ( i , startArea , false ) ;
2113: LD_VAR 0 2
2117: PPUSH
2118: LD_INT 1
2120: PPUSH
2121: LD_INT 0
2123: PPUSH
2124: CALL_OW 49
// ComHold ( i ) ;
2128: LD_VAR 0 2
2132: PPUSH
2133: CALL_OW 140
// end ;
2137: GO 2028
2139: POP
2140: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2141: LD_ADDR_EXP 7
2145: PUSH
2146: LD_STRING 02_mikhailStatus_1
2148: PPUSH
2149: LD_INT 0
2151: PPUSH
2152: CALL_OW 30
2156: ST_TO_ADDR
// if not bierezov_exist and not debug then
2157: LD_EXP 7
2161: NOT
2162: PUSH
2163: LD_EXP 1
2167: NOT
2168: AND
2169: IFFALSE 2173
// exit ;
2171: GO 2204
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2173: LD_ADDR_EXP 44
2177: PUSH
2178: LD_STRING Mikhail
2180: PPUSH
2181: LD_INT 0
2183: PPUSH
2184: CALL 474 0 2
2188: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2189: LD_EXP 44
2193: PPUSH
2194: LD_INT 1
2196: PPUSH
2197: LD_INT 0
2199: PPUSH
2200: CALL_OW 49
// end ;
2204: LD_VAR 0 1
2208: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2209: LD_INT 0
2211: PPUSH
2212: PPUSH
2213: PPUSH
2214: PPUSH
// uc_side := 4 ;
2215: LD_ADDR_OWVAR 20
2219: PUSH
2220: LD_INT 4
2222: ST_TO_ADDR
// uc_nation := 1 ;
2223: LD_ADDR_OWVAR 21
2227: PUSH
2228: LD_INT 1
2230: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2231: LD_ADDR_EXP 43
2235: PUSH
2236: LD_STRING Cornell
2238: PPUSH
2239: LD_INT 0
2241: PPUSH
2242: CALL 474 0 2
2246: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2247: LD_ADDR_EXP 6
2251: PUSH
2252: LD_INT 9
2254: PUSH
2255: LD_EXP 4
2259: MINUS
2260: ST_TO_ADDR
// tmp := [ ] ;
2261: LD_ADDR_VAR 0 2
2265: PUSH
2266: EMPTY
2267: ST_TO_ADDR
// if cornel_units < 4 then
2268: LD_EXP 6
2272: PUSH
2273: LD_INT 4
2275: LESS
2276: IFFALSE 2286
// cornel_units := 4 ;
2278: LD_ADDR_EXP 6
2282: PUSH
2283: LD_INT 4
2285: ST_TO_ADDR
// for i = 1 to cornel_units do
2286: LD_ADDR_VAR 0 4
2290: PUSH
2291: DOUBLE
2292: LD_INT 1
2294: DEC
2295: ST_TO_ADDR
2296: LD_EXP 6
2300: PUSH
2301: FOR_TO
2302: IFFALSE 2400
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2304: LD_INT 0
2306: PPUSH
2307: LD_INT 1
2309: PUSH
2310: LD_INT 1
2312: PUSH
2313: LD_INT 1
2315: PUSH
2316: LD_INT 2
2318: PUSH
2319: LD_INT 4
2321: PUSH
2322: EMPTY
2323: LIST
2324: LIST
2325: LIST
2326: LIST
2327: LIST
2328: PUSH
2329: LD_VAR 0 4
2333: PUSH
2334: LD_INT 5
2336: MOD
2337: PUSH
2338: LD_INT 1
2340: PLUS
2341: ARRAY
2342: PPUSH
2343: LD_INT 2
2345: PPUSH
2346: CALL_OW 380
// un := CreateHuman ;
2350: LD_ADDR_VAR 0 3
2354: PUSH
2355: CALL_OW 44
2359: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2360: LD_ADDR_VAR 0 2
2364: PUSH
2365: LD_VAR 0 2
2369: PPUSH
2370: LD_INT 1
2372: PPUSH
2373: LD_VAR 0 3
2377: PPUSH
2378: CALL_OW 2
2382: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2383: LD_VAR 0 3
2387: PPUSH
2388: LD_INT 2
2390: PPUSH
2391: LD_INT 0
2393: PPUSH
2394: CALL_OW 49
// end ;
2398: GO 2301
2400: POP
2401: POP
// cornel_units := tmp ;
2402: LD_ADDR_EXP 6
2406: PUSH
2407: LD_VAR 0 2
2411: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2412: LD_EXP 43
2416: PPUSH
2417: LD_INT 191
2419: PPUSH
2420: LD_INT 106
2422: PPUSH
2423: LD_INT 0
2425: PPUSH
2426: CALL_OW 48
// end ;
2430: LD_VAR 0 1
2434: RET
// export function PrepareWesternBase ; var i ; begin
2435: LD_INT 0
2437: PPUSH
2438: PPUSH
// uc_side := 8 ;
2439: LD_ADDR_OWVAR 20
2443: PUSH
2444: LD_INT 8
2446: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2447: LD_ADDR_EXP 46
2451: PUSH
2452: LD_STRING Lynch
2454: PPUSH
2455: LD_INT 0
2457: PPUSH
2458: CALL 474 0 2
2462: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2463: LD_ADDR_EXP 47
2467: PUSH
2468: LD_STRING Walker
2470: PPUSH
2471: LD_INT 0
2473: PPUSH
2474: CALL 474 0 2
2478: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2479: LD_ADDR_EXP 48
2483: PUSH
2484: LD_STRING Turner
2486: PPUSH
2487: LD_INT 0
2489: PPUSH
2490: CALL 474 0 2
2494: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2495: LD_ADDR_EXP 49
2499: PUSH
2500: LD_STRING Jillian
2502: PPUSH
2503: LD_INT 0
2505: PPUSH
2506: CALL 474 0 2
2510: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_EXP 46
2520: PUSH
2521: LD_EXP 47
2525: PUSH
2526: LD_EXP 48
2530: PUSH
2531: LD_EXP 49
2535: PUSH
2536: EMPTY
2537: LIST
2538: LIST
2539: LIST
2540: LIST
2541: PUSH
2542: FOR_IN
2543: IFFALSE 2571
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2545: LD_VAR 0 2
2549: PPUSH
2550: LD_INT 3
2552: PPUSH
2553: LD_INT 0
2555: PPUSH
2556: CALL_OW 49
// ComHold ( i ) ;
2560: LD_VAR 0 2
2564: PPUSH
2565: CALL_OW 140
// end ;
2569: GO 2542
2571: POP
2572: POP
// end ;
2573: LD_VAR 0 1
2577: RET
// export function SelectGroup ; var units , selected , i ; begin
2578: LD_INT 0
2580: PPUSH
2581: PPUSH
2582: PPUSH
2583: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2584: LD_ADDR_VAR 0 2
2588: PUSH
2589: LD_EXP 36
2593: PUSH
2594: LD_INT -3
2596: PUSH
2597: EMPTY
2598: LIST
2599: LIST
2600: PUSH
2601: LD_EXP 4
2605: ADD
2606: PUSH
2607: LD_INT -2
2609: PUSH
2610: LD_INT -4
2612: PUSH
2613: LD_EXP 43
2617: PUSH
2618: LD_EXP 44
2622: PUSH
2623: EMPTY
2624: LIST
2625: LIST
2626: LIST
2627: LIST
2628: ADD
2629: PUSH
2630: LD_INT -3
2632: PUSH
2633: EMPTY
2634: LIST
2635: ADD
2636: PUSH
2637: LD_EXP 6
2641: ADD
2642: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2643: LD_ADDR_VAR 0 3
2647: PUSH
2648: LD_EXP 36
2652: PUSH
2653: LD_STRING Select five characters to go with you
2655: PPUSH
2656: LD_INT 4
2658: PPUSH
2659: LD_INT 4
2661: PPUSH
2662: LD_VAR 0 2
2666: PPUSH
2667: EMPTY
2668: PPUSH
2669: CALL_OW 42
2673: ADD
2674: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2675: LD_ADDR_EXP 6
2679: PUSH
2680: LD_EXP 4
2684: PUSH
2685: LD_EXP 6
2689: UNION
2690: PUSH
2691: LD_VAR 0 3
2695: DIFF
2696: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2697: LD_ADDR_VAR 0 4
2701: PUSH
2702: LD_EXP 6
2706: PUSH
2707: LD_EXP 44
2711: ADD
2712: PUSH
2713: FOR_IN
2714: IFFALSE 2745
// if GetSide ( i ) = 1 then
2716: LD_VAR 0 4
2720: PPUSH
2721: CALL_OW 255
2725: PUSH
2726: LD_INT 1
2728: EQUAL
2729: IFFALSE 2743
// SetSide ( i , 4 ) ;
2731: LD_VAR 0 4
2735: PPUSH
2736: LD_INT 4
2738: PPUSH
2739: CALL_OW 235
2743: GO 2713
2745: POP
2746: POP
// for i in selected do
2747: LD_ADDR_VAR 0 4
2751: PUSH
2752: LD_VAR 0 3
2756: PUSH
2757: FOR_IN
2758: IFFALSE 2789
// if GetSide ( i ) = 4 then
2760: LD_VAR 0 4
2764: PPUSH
2765: CALL_OW 255
2769: PUSH
2770: LD_INT 4
2772: EQUAL
2773: IFFALSE 2787
// SetSide ( i , 1 ) ;
2775: LD_VAR 0 4
2779: PPUSH
2780: LD_INT 1
2782: PPUSH
2783: CALL_OW 235
2787: GO 2757
2789: POP
2790: POP
// jmm_units := jmm_units diff cornel_units ;
2791: LD_ADDR_EXP 4
2795: PUSH
2796: LD_EXP 4
2800: PUSH
2801: LD_EXP 6
2805: DIFF
2806: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2807: LD_EXP 37
2811: PPUSH
2812: CALL_OW 255
2816: PUSH
2817: LD_INT 4
2819: EQUAL
2820: IFFALSE 2835
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2822: LD_EXP 3
2826: PUSH
2827: LD_STRING Bobby
2829: STR
2830: PPUSH
2831: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2835: LD_EXP 38
2839: PPUSH
2840: CALL_OW 255
2844: PUSH
2845: LD_INT 4
2847: EQUAL
2848: IFFALSE 2863
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2850: LD_EXP 3
2854: PUSH
2855: LD_STRING Cyrus
2857: STR
2858: PPUSH
2859: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2863: LD_EXP 39
2867: PPUSH
2868: CALL_OW 255
2872: PUSH
2873: LD_INT 4
2875: EQUAL
2876: IFFALSE 2891
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2878: LD_EXP 3
2882: PUSH
2883: LD_STRING Lisa
2885: STR
2886: PPUSH
2887: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2891: LD_EXP 40
2895: PPUSH
2896: CALL_OW 255
2900: PUSH
2901: LD_INT 4
2903: EQUAL
2904: IFFALSE 2919
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
2906: LD_EXP 3
2910: PUSH
2911: LD_STRING Khatam
2913: STR
2914: PPUSH
2915: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2919: LD_EXP 41
2923: PPUSH
2924: CALL_OW 255
2928: PUSH
2929: LD_INT 4
2931: EQUAL
2932: IFFALSE 2947
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
2934: LD_EXP 3
2938: PUSH
2939: LD_STRING Brian
2941: STR
2942: PPUSH
2943: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2947: LD_EXP 42
2951: PPUSH
2952: CALL_OW 255
2956: PUSH
2957: LD_INT 4
2959: EQUAL
2960: IFFALSE 2975
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
2962: LD_EXP 3
2966: PUSH
2967: LD_STRING Jerry
2969: STR
2970: PPUSH
2971: CALL_OW 40
// end ; end_of_file
2975: LD_VAR 0 1
2979: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
2980: LD_INT 0
2982: PPUSH
2983: PPUSH
2984: PPUSH
2985: PPUSH
2986: PPUSH
2987: PPUSH
2988: PPUSH
2989: PPUSH
2990: PPUSH
2991: PPUSH
2992: PPUSH
2993: PPUSH
2994: PPUSH
// ru_alert := false ;
2995: LD_ADDR_EXP 59
2999: PUSH
3000: LD_INT 0
3002: ST_TO_ADDR
// ru_produce_list := [ ] ;
3003: LD_ADDR_EXP 56
3007: PUSH
3008: EMPTY
3009: ST_TO_ADDR
// if Difficulty > 1 then
3010: LD_OWVAR 67
3014: PUSH
3015: LD_INT 1
3017: GREATER
3018: IFFALSE 3106
// begin uc_side := 3 ;
3020: LD_ADDR_OWVAR 20
3024: PUSH
3025: LD_INT 3
3027: ST_TO_ADDR
// uc_nation := 3 ;
3028: LD_ADDR_OWVAR 21
3032: PUSH
3033: LD_INT 3
3035: ST_TO_ADDR
// bc_type := b_breastwork ;
3036: LD_ADDR_OWVAR 42
3040: PUSH
3041: LD_INT 31
3043: ST_TO_ADDR
// bc_level := Difficulty ;
3044: LD_ADDR_OWVAR 43
3048: PUSH
3049: LD_OWVAR 67
3053: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3054: LD_INT 22
3056: PPUSH
3057: LD_INT 14
3059: PPUSH
3060: LD_INT 0
3062: PPUSH
3063: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3067: LD_INT 48
3069: PPUSH
3070: LD_INT 46
3072: PPUSH
3073: LD_INT 0
3075: PPUSH
3076: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3080: LD_INT 86
3082: PPUSH
3083: LD_INT 65
3085: PPUSH
3086: LD_INT 5
3088: PPUSH
3089: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3093: LD_INT 165
3095: PPUSH
3096: LD_INT 73
3098: PPUSH
3099: LD_INT 5
3101: PPUSH
3102: CALL_OW 47
// end ; if Difficulty = 3 then
3106: LD_OWVAR 67
3110: PUSH
3111: LD_INT 3
3113: EQUAL
3114: IFFALSE 3129
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3116: LD_INT 51
3118: PPUSH
3119: LD_INT 3
3121: PPUSH
3122: LD_INT 2
3124: PPUSH
3125: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3129: LD_ADDR_VAR 0 7
3133: PUSH
3134: LD_INT 22
3136: PUSH
3137: LD_INT 3
3139: PUSH
3140: EMPTY
3141: LIST
3142: LIST
3143: PUSH
3144: LD_INT 2
3146: PUSH
3147: LD_INT 30
3149: PUSH
3150: LD_INT 31
3152: PUSH
3153: EMPTY
3154: LIST
3155: LIST
3156: PUSH
3157: LD_INT 30
3159: PUSH
3160: LD_INT 32
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: PUSH
3167: EMPTY
3168: LIST
3169: LIST
3170: LIST
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: PPUSH
3176: CALL_OW 69
3180: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3181: LD_ADDR_VAR 0 8
3185: PUSH
3186: LD_INT 22
3188: PUSH
3189: LD_INT 3
3191: PUSH
3192: EMPTY
3193: LIST
3194: LIST
3195: PUSH
3196: LD_INT 30
3198: PUSH
3199: LD_INT 4
3201: PUSH
3202: EMPTY
3203: LIST
3204: LIST
3205: PUSH
3206: EMPTY
3207: LIST
3208: LIST
3209: PPUSH
3210: CALL_OW 69
3214: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3215: LD_ADDR_VAR 0 10
3219: PUSH
3220: LD_INT 22
3222: PUSH
3223: LD_INT 3
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: PUSH
3230: LD_INT 30
3232: PUSH
3233: LD_INT 3
3235: PUSH
3236: EMPTY
3237: LIST
3238: LIST
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: PPUSH
3244: CALL_OW 69
3248: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3249: LD_ADDR_VAR 0 9
3253: PUSH
3254: LD_INT 22
3256: PUSH
3257: LD_INT 3
3259: PUSH
3260: EMPTY
3261: LIST
3262: LIST
3263: PUSH
3264: LD_INT 30
3266: PUSH
3267: LD_INT 6
3269: PUSH
3270: EMPTY
3271: LIST
3272: LIST
3273: PUSH
3274: EMPTY
3275: LIST
3276: LIST
3277: PPUSH
3278: CALL_OW 69
3282: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3283: LD_ADDR_VAR 0 2
3287: PUSH
3288: LD_INT 22
3290: PUSH
3291: LD_INT 3
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: PUSH
3298: LD_INT 30
3300: PUSH
3301: LD_INT 1
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: PUSH
3308: EMPTY
3309: LIST
3310: LIST
3311: PPUSH
3312: CALL_OW 69
3316: PUSH
3317: FOR_IN
3318: IFFALSE 3362
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3320: LD_VAR 0 2
3324: PPUSH
3325: CALL_OW 274
3329: PPUSH
3330: LD_INT 1
3332: PPUSH
3333: LD_INT 5000
3335: PPUSH
3336: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3340: LD_VAR 0 2
3344: PPUSH
3345: CALL_OW 274
3349: PPUSH
3350: LD_INT 2
3352: PPUSH
3353: LD_INT 3000
3355: PPUSH
3356: CALL_OW 277
// end ;
3360: GO 3317
3362: POP
3363: POP
// uc_side := 3 ;
3364: LD_ADDR_OWVAR 20
3368: PUSH
3369: LD_INT 3
3371: ST_TO_ADDR
// uc_nation := 3 ;
3372: LD_ADDR_OWVAR 21
3376: PUSH
3377: LD_INT 3
3379: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3380: LD_ADDR_VAR 0 11
3384: PUSH
3385: LD_INT 2
3387: PUSH
3388: LD_INT 3
3390: PUSH
3391: LD_INT 4
3393: PUSH
3394: EMPTY
3395: LIST
3396: LIST
3397: LIST
3398: PUSH
3399: LD_OWVAR 67
3403: ARRAY
3404: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3405: LD_ADDR_EXP 51
3409: PUSH
3410: LD_STRING Pokryshkin
3412: PPUSH
3413: LD_INT 0
3415: PPUSH
3416: CALL 474 0 2
3420: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3421: LD_EXP 51
3425: PPUSH
3426: LD_INT 63
3428: PPUSH
3429: LD_INT 21
3431: PPUSH
3432: LD_INT 0
3434: PPUSH
3435: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3439: LD_EXP 51
3443: PPUSH
3444: CALL_OW 140
// InitHc ;
3448: CALL_OW 19
// for i in fac do
3452: LD_ADDR_VAR 0 2
3456: PUSH
3457: LD_VAR 0 10
3461: PUSH
3462: FOR_IN
3463: IFFALSE 3516
// begin for j = 1 to 6 do
3465: LD_ADDR_VAR 0 3
3469: PUSH
3470: DOUBLE
3471: LD_INT 1
3473: DEC
3474: ST_TO_ADDR
3475: LD_INT 6
3477: PUSH
3478: FOR_TO
3479: IFFALSE 3512
// begin PrepareHuman ( false , 3 , skill ) ;
3481: LD_INT 0
3483: PPUSH
3484: LD_INT 3
3486: PPUSH
3487: LD_VAR 0 11
3491: PPUSH
3492: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3496: CALL_OW 44
3500: PPUSH
3501: LD_VAR 0 2
3505: PPUSH
3506: CALL_OW 52
// end ;
3510: GO 3478
3512: POP
3513: POP
// end ;
3514: GO 3462
3516: POP
3517: POP
// for i in lab do
3518: LD_ADDR_VAR 0 2
3522: PUSH
3523: LD_VAR 0 9
3527: PUSH
3528: FOR_IN
3529: IFFALSE 3562
// begin PrepareHuman ( false , 4 , skill ) ;
3531: LD_INT 0
3533: PPUSH
3534: LD_INT 4
3536: PPUSH
3537: LD_VAR 0 11
3541: PPUSH
3542: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3546: CALL_OW 44
3550: PPUSH
3551: LD_VAR 0 2
3555: PPUSH
3556: CALL_OW 52
// end ;
3560: GO 3528
3562: POP
3563: POP
// for i in tw do
3564: LD_ADDR_VAR 0 2
3568: PUSH
3569: LD_VAR 0 7
3573: PUSH
3574: FOR_IN
3575: IFFALSE 3624
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3577: LD_VAR 0 2
3581: PPUSH
3582: LD_INT 42
3584: PUSH
3585: LD_INT 43
3587: PUSH
3588: EMPTY
3589: LIST
3590: LIST
3591: PUSH
3592: LD_INT 1
3594: PPUSH
3595: LD_INT 2
3597: PPUSH
3598: CALL_OW 12
3602: ARRAY
3603: PPUSH
3604: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3608: LD_VAR 0 11
3612: PPUSH
3613: LD_VAR 0 2
3617: PPUSH
3618: CALL 815 0 2
// end ;
3622: GO 3574
3624: POP
3625: POP
// for i in bar do
3626: LD_ADDR_VAR 0 2
3630: PUSH
3631: LD_VAR 0 8
3635: PUSH
3636: FOR_IN
3637: IFFALSE 3670
// begin PrepareHuman ( false , 1 , skill ) ;
3639: LD_INT 0
3641: PPUSH
3642: LD_INT 1
3644: PPUSH
3645: LD_VAR 0 11
3649: PPUSH
3650: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3654: CALL_OW 44
3658: PPUSH
3659: LD_VAR 0 2
3663: PPUSH
3664: CALL_OW 52
// end ;
3668: GO 3636
3670: POP
3671: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3672: LD_ADDR_VAR 0 13
3676: PUSH
3677: LD_INT 100
3679: PUSH
3680: LD_INT 9
3682: PUSH
3683: EMPTY
3684: LIST
3685: LIST
3686: PUSH
3687: LD_INT 135
3689: PUSH
3690: LD_INT 60
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: PUSH
3697: LD_INT 41
3699: PUSH
3700: LD_INT 6
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: PUSH
3707: LD_INT 22
3709: PUSH
3710: LD_INT 9
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: PUSH
3717: LD_INT 84
3719: PUSH
3720: LD_INT 14
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: LIST
3731: LIST
3732: LIST
3733: ST_TO_ADDR
// vehicles := [ ] ;
3734: LD_ADDR_VAR 0 12
3738: PUSH
3739: EMPTY
3740: ST_TO_ADDR
// for i in spot_xy do
3741: LD_ADDR_VAR 0 2
3745: PUSH
3746: LD_VAR 0 13
3750: PUSH
3751: FOR_IN
3752: IFFALSE 3910
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3754: LD_ADDR_VAR 0 6
3758: PUSH
3759: LD_INT 3
3761: PPUSH
3762: LD_INT 3
3764: PPUSH
3765: LD_INT 22
3767: PPUSH
3768: LD_INT 1
3770: PPUSH
3771: LD_INT 1
3773: PPUSH
3774: LD_INT 42
3776: PUSH
3777: LD_INT 43
3779: PUSH
3780: LD_INT 44
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: LIST
3787: PUSH
3788: LD_INT 1
3790: PPUSH
3791: LD_INT 3
3793: PPUSH
3794: CALL_OW 12
3798: ARRAY
3799: PPUSH
3800: LD_INT 100
3802: PPUSH
3803: CALL 537 0 7
3807: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3808: LD_ADDR_VAR 0 12
3812: PUSH
3813: LD_VAR 0 12
3817: PPUSH
3818: LD_VAR 0 12
3822: PUSH
3823: LD_INT 1
3825: PLUS
3826: PPUSH
3827: LD_VAR 0 6
3831: PPUSH
3832: CALL_OW 2
3836: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3837: LD_VAR 0 6
3841: PPUSH
3842: LD_INT 3
3844: PPUSH
3845: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3849: LD_VAR 0 6
3853: PPUSH
3854: LD_VAR 0 2
3858: PUSH
3859: LD_INT 1
3861: ARRAY
3862: PPUSH
3863: LD_VAR 0 2
3867: PUSH
3868: LD_INT 2
3870: ARRAY
3871: PPUSH
3872: LD_INT 0
3874: PPUSH
3875: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3879: LD_INT 0
3881: PPUSH
3882: LD_INT 3
3884: PPUSH
3885: LD_VAR 0 11
3889: PPUSH
3890: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3894: CALL_OW 44
3898: PPUSH
3899: LD_VAR 0 6
3903: PPUSH
3904: CALL_OW 52
// end ;
3908: GO 3751
3910: POP
3911: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3912: LD_ADDR_VAR 0 2
3916: PUSH
3917: DOUBLE
3918: LD_INT 1
3920: DEC
3921: ST_TO_ADDR
3922: LD_INT 5
3924: PUSH
3925: LD_INT 7
3927: PUSH
3928: LD_INT 8
3930: PUSH
3931: EMPTY
3932: LIST
3933: LIST
3934: LIST
3935: PUSH
3936: LD_OWVAR 67
3940: ARRAY
3941: PUSH
3942: FOR_TO
3943: IFFALSE 4003
// begin PrepareHuman ( false , 1 , skill ) ;
3945: LD_INT 0
3947: PPUSH
3948: LD_INT 1
3950: PPUSH
3951: LD_VAR 0 11
3955: PPUSH
3956: CALL_OW 380
// un := CreateHuman ;
3960: LD_ADDR_VAR 0 5
3964: PUSH
3965: CALL_OW 44
3969: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3970: LD_VAR 0 5
3974: PPUSH
3975: LD_INT 11
3977: PPUSH
3978: LD_INT 0
3980: PPUSH
3981: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3985: LD_ADDR_EXP 54
3989: PUSH
3990: LD_EXP 54
3994: PUSH
3995: LD_VAR 0 5
3999: ADD
4000: ST_TO_ADDR
// end ;
4001: GO 3942
4003: POP
4004: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
4005: LD_ADDR_VAR 0 2
4009: PUSH
4010: DOUBLE
4011: LD_INT 1
4013: DEC
4014: ST_TO_ADDR
4015: LD_INT 2
4017: PUSH
4018: LD_INT 3
4020: PUSH
4021: LD_INT 4
4023: PUSH
4024: EMPTY
4025: LIST
4026: LIST
4027: LIST
4028: PUSH
4029: LD_OWVAR 67
4033: ARRAY
4034: PUSH
4035: FOR_TO
4036: IFFALSE 4096
// begin PrepareHuman ( false , 1 , skill ) ;
4038: LD_INT 0
4040: PPUSH
4041: LD_INT 1
4043: PPUSH
4044: LD_VAR 0 11
4048: PPUSH
4049: CALL_OW 380
// un := CreateHuman ;
4053: LD_ADDR_VAR 0 5
4057: PUSH
4058: CALL_OW 44
4062: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4063: LD_VAR 0 5
4067: PPUSH
4068: LD_INT 12
4070: PPUSH
4071: LD_INT 0
4073: PPUSH
4074: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4078: LD_ADDR_EXP 52
4082: PUSH
4083: LD_EXP 52
4087: PUSH
4088: LD_VAR 0 5
4092: ADD
4093: ST_TO_ADDR
// end ;
4094: GO 4035
4096: POP
4097: POP
// for i = 1 to 2 do
4098: LD_ADDR_VAR 0 2
4102: PUSH
4103: DOUBLE
4104: LD_INT 1
4106: DEC
4107: ST_TO_ADDR
4108: LD_INT 2
4110: PUSH
4111: FOR_TO
4112: IFFALSE 4178
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4114: LD_INT 1
4116: PPUSH
4117: LD_INT 1
4119: PPUSH
4120: LD_VAR 0 11
4124: PPUSH
4125: CALL_OW 380
// un := CreateHuman ;
4129: LD_ADDR_VAR 0 5
4133: PUSH
4134: CALL_OW 44
4138: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4139: LD_VAR 0 5
4143: PPUSH
4144: LD_INT 39
4146: PPUSH
4147: LD_INT 12
4149: PPUSH
4150: LD_INT 3
4152: PPUSH
4153: LD_INT 0
4155: PPUSH
4156: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4160: LD_ADDR_EXP 53
4164: PUSH
4165: LD_EXP 53
4169: PUSH
4170: LD_VAR 0 5
4174: ADD
4175: ST_TO_ADDR
// end ;
4176: GO 4111
4178: POP
4179: POP
// for i = 1 to 3 do
4180: LD_ADDR_VAR 0 2
4184: PUSH
4185: DOUBLE
4186: LD_INT 1
4188: DEC
4189: ST_TO_ADDR
4190: LD_INT 3
4192: PUSH
4193: FOR_TO
4194: IFFALSE 4260
// begin PrepareHuman ( false , 1 , skill ) ;
4196: LD_INT 0
4198: PPUSH
4199: LD_INT 1
4201: PPUSH
4202: LD_VAR 0 11
4206: PPUSH
4207: CALL_OW 380
// un := CreateHuman ;
4211: LD_ADDR_VAR 0 5
4215: PUSH
4216: CALL_OW 44
4220: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4221: LD_VAR 0 5
4225: PPUSH
4226: LD_INT 180
4228: PPUSH
4229: LD_INT 11
4231: PPUSH
4232: LD_INT 4
4234: PPUSH
4235: LD_INT 0
4237: PPUSH
4238: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4242: LD_ADDR_EXP 57
4246: PUSH
4247: LD_EXP 57
4251: PUSH
4252: LD_VAR 0 5
4256: ADD
4257: ST_TO_ADDR
// end ;
4258: GO 4193
4260: POP
4261: POP
// ru_vehicles := vehicles ;
4262: LD_ADDR_EXP 55
4266: PUSH
4267: LD_VAR 0 12
4271: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4272: LD_ADDR_EXP 58
4276: PUSH
4277: LD_INT 131
4279: PUSH
4280: LD_INT 121
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PUSH
4287: LD_INT 113
4289: PUSH
4290: LD_INT 90
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: PUSH
4297: LD_INT 93
4299: PUSH
4300: LD_INT 62
4302: PUSH
4303: EMPTY
4304: LIST
4305: LIST
4306: PUSH
4307: EMPTY
4308: LIST
4309: LIST
4310: LIST
4311: PUSH
4312: LD_INT 106
4314: PUSH
4315: LD_INT 54
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: PUSH
4322: LD_INT 120
4324: PUSH
4325: LD_INT 80
4327: PUSH
4328: EMPTY
4329: LIST
4330: LIST
4331: PUSH
4332: LD_INT 143
4334: PUSH
4335: LD_INT 120
4337: PUSH
4338: EMPTY
4339: LIST
4340: LIST
4341: PUSH
4342: EMPTY
4343: LIST
4344: LIST
4345: LIST
4346: PUSH
4347: LD_INT 154
4349: PUSH
4350: LD_INT 116
4352: PUSH
4353: EMPTY
4354: LIST
4355: LIST
4356: PUSH
4357: LD_INT 140
4359: PUSH
4360: LD_INT 93
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: PUSH
4367: LD_INT 130
4369: PUSH
4370: LD_INT 58
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: LIST
4381: PUSH
4382: LD_INT 105
4384: PUSH
4385: LD_INT 106
4387: PUSH
4388: EMPTY
4389: LIST
4390: LIST
4391: PUSH
4392: LD_INT 134
4394: PUSH
4395: LD_INT 98
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: LD_INT 159
4404: PUSH
4405: LD_INT 113
4407: PUSH
4408: EMPTY
4409: LIST
4410: LIST
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: LIST
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4423: LD_ADDR_VAR 0 2
4427: PUSH
4428: DOUBLE
4429: LD_INT 1
4431: DEC
4432: ST_TO_ADDR
4433: LD_OWVAR 67
4437: PUSH
4438: LD_INT 1
4440: MINUS
4441: PUSH
4442: FOR_TO
4443: IFFALSE 4476
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4445: LD_ADDR_EXP 56
4449: PUSH
4450: LD_EXP 56
4454: PUSH
4455: LD_INT 22
4457: PUSH
4458: LD_INT 1
4460: PUSH
4461: LD_INT 1
4463: PUSH
4464: LD_INT 43
4466: PUSH
4467: EMPTY
4468: LIST
4469: LIST
4470: LIST
4471: LIST
4472: ADD
4473: ST_TO_ADDR
4474: GO 4442
4476: POP
4477: POP
// end ;
4478: LD_VAR 0 1
4482: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4483: LD_INT 22
4485: PUSH
4486: LD_INT 3
4488: PUSH
4489: EMPTY
4490: LIST
4491: LIST
4492: PUSH
4493: LD_INT 21
4495: PUSH
4496: LD_INT 2
4498: PUSH
4499: EMPTY
4500: LIST
4501: LIST
4502: PUSH
4503: EMPTY
4504: LIST
4505: LIST
4506: PPUSH
4507: CALL_OW 69
4511: IFFALSE 4605
4513: GO 4515
4515: DISABLE
4516: LD_INT 0
4518: PPUSH
4519: PPUSH
// begin enable ;
4520: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4521: LD_ADDR_VAR 0 2
4525: PUSH
4526: LD_INT 22
4528: PUSH
4529: LD_INT 3
4531: PUSH
4532: EMPTY
4533: LIST
4534: LIST
4535: PUSH
4536: LD_INT 21
4538: PUSH
4539: LD_INT 2
4541: PUSH
4542: EMPTY
4543: LIST
4544: LIST
4545: PUSH
4546: EMPTY
4547: LIST
4548: LIST
4549: PPUSH
4550: CALL_OW 69
4554: ST_TO_ADDR
// if filter then
4555: LD_VAR 0 2
4559: IFFALSE 4605
// for i in filter do
4561: LD_ADDR_VAR 0 1
4565: PUSH
4566: LD_VAR 0 2
4570: PUSH
4571: FOR_IN
4572: IFFALSE 4603
// if GetFuel ( i ) < 20 then
4574: LD_VAR 0 1
4578: PPUSH
4579: CALL_OW 261
4583: PUSH
4584: LD_INT 20
4586: LESS
4587: IFFALSE 4601
// SetFuel ( i , 20 ) ;
4589: LD_VAR 0 1
4593: PPUSH
4594: LD_INT 20
4596: PPUSH
4597: CALL_OW 240
4601: GO 4571
4603: POP
4604: POP
// end ;
4605: PPOPN 2
4607: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4608: LD_EXP 56
4612: IFFALSE 4831
4614: GO 4616
4616: DISABLE
4617: LD_INT 0
4619: PPUSH
4620: PPUSH
4621: PPUSH
// begin enable ;
4622: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4623: LD_ADDR_VAR 0 2
4627: PUSH
4628: LD_INT 22
4630: PUSH
4631: LD_INT 3
4633: PUSH
4634: EMPTY
4635: LIST
4636: LIST
4637: PUSH
4638: LD_INT 30
4640: PUSH
4641: LD_INT 3
4643: PUSH
4644: EMPTY
4645: LIST
4646: LIST
4647: PUSH
4648: EMPTY
4649: LIST
4650: LIST
4651: PPUSH
4652: CALL_OW 69
4656: ST_TO_ADDR
// can_produce := [ ] ;
4657: LD_ADDR_VAR 0 3
4661: PUSH
4662: EMPTY
4663: ST_TO_ADDR
// if not fac then
4664: LD_VAR 0 2
4668: NOT
4669: IFFALSE 4674
// begin disable ;
4671: DISABLE
// exit ;
4672: GO 4831
// end ; for i in fac do
4674: LD_ADDR_VAR 0 1
4678: PUSH
4679: LD_VAR 0 2
4683: PUSH
4684: FOR_IN
4685: IFFALSE 4723
// if UnitsInside ( i ) then
4687: LD_VAR 0 1
4691: PPUSH
4692: CALL_OW 313
4696: IFFALSE 4721
// can_produce := Insert ( can_produce , 1 , i ) ;
4698: LD_ADDR_VAR 0 3
4702: PUSH
4703: LD_VAR 0 3
4707: PPUSH
4708: LD_INT 1
4710: PPUSH
4711: LD_VAR 0 1
4715: PPUSH
4716: CALL_OW 2
4720: ST_TO_ADDR
4721: GO 4684
4723: POP
4724: POP
// if not can_produce then
4725: LD_VAR 0 3
4729: NOT
4730: IFFALSE 4734
// exit ;
4732: GO 4831
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4734: LD_VAR 0 3
4738: PUSH
4739: LD_INT 1
4741: PPUSH
4742: LD_VAR 0 3
4746: PPUSH
4747: CALL_OW 12
4751: ARRAY
4752: PPUSH
4753: LD_EXP 56
4757: PUSH
4758: LD_INT 1
4760: ARRAY
4761: PPUSH
4762: LD_EXP 56
4766: PUSH
4767: LD_INT 2
4769: ARRAY
4770: PPUSH
4771: LD_EXP 56
4775: PUSH
4776: LD_INT 3
4778: ARRAY
4779: PPUSH
4780: LD_EXP 56
4784: PUSH
4785: LD_INT 4
4787: ARRAY
4788: PPUSH
4789: CALL_OW 125
// for i = 1 to 4 do
4793: LD_ADDR_VAR 0 1
4797: PUSH
4798: DOUBLE
4799: LD_INT 1
4801: DEC
4802: ST_TO_ADDR
4803: LD_INT 4
4805: PUSH
4806: FOR_TO
4807: IFFALSE 4829
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4809: LD_ADDR_EXP 56
4813: PUSH
4814: LD_EXP 56
4818: PPUSH
4819: LD_INT 1
4821: PPUSH
4822: CALL_OW 3
4826: ST_TO_ADDR
4827: GO 4806
4829: POP
4830: POP
// end ;
4831: PPOPN 3
4833: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4834: LD_INT 0
4836: PPUSH
4837: PPUSH
4838: PPUSH
// for i = 1 to 6 do
4839: LD_ADDR_VAR 0 2
4843: PUSH
4844: DOUBLE
4845: LD_INT 1
4847: DEC
4848: ST_TO_ADDR
4849: LD_INT 6
4851: PUSH
4852: FOR_TO
4853: IFFALSE 5002
// begin PrepareHuman ( false , 3 , 3 ) ;
4855: LD_INT 0
4857: PPUSH
4858: LD_INT 3
4860: PPUSH
4861: LD_INT 3
4863: PPUSH
4864: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4868: LD_ADDR_VAR 0 3
4872: PUSH
4873: LD_INT 3
4875: PPUSH
4876: LD_INT 3
4878: PPUSH
4879: LD_INT 22
4881: PPUSH
4882: LD_INT 1
4884: PPUSH
4885: LD_INT 1
4887: PPUSH
4888: LD_INT 43
4890: PUSH
4891: LD_INT 42
4893: PUSH
4894: EMPTY
4895: LIST
4896: LIST
4897: PUSH
4898: LD_INT 1
4900: PPUSH
4901: LD_INT 2
4903: PPUSH
4904: CALL_OW 12
4908: ARRAY
4909: PPUSH
4910: LD_INT 70
4912: PPUSH
4913: CALL 537 0 7
4917: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4918: LD_VAR 0 3
4922: PPUSH
4923: LD_INT 4
4925: PPUSH
4926: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4930: LD_VAR 0 3
4934: PPUSH
4935: LD_INT 229
4937: PPUSH
4938: LD_INT 44
4940: PPUSH
4941: LD_INT 0
4943: PPUSH
4944: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4948: CALL_OW 44
4952: PPUSH
4953: LD_VAR 0 3
4957: PPUSH
4958: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4962: LD_ADDR_EXP 55
4966: PUSH
4967: LD_EXP 55
4971: PUSH
4972: LD_VAR 0 3
4976: ADD
4977: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
4978: LD_VAR 0 3
4982: PPUSH
4983: LD_INT 191
4985: PPUSH
4986: LD_INT 32
4988: PPUSH
4989: CALL_OW 111
// Wait ( 0 0$02 ) ;
4993: LD_INT 70
4995: PPUSH
4996: CALL_OW 67
// end ;
5000: GO 4852
5002: POP
5003: POP
// end ;
5004: LD_VAR 0 1
5008: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
5009: LD_EXP 30
5013: PUSH
5014: LD_EXP 55
5018: AND
5019: IFFALSE 5193
5021: GO 5023
5023: DISABLE
5024: LD_INT 0
5026: PPUSH
5027: PPUSH
5028: PPUSH
// begin wait ( 0 0$50 ) ;
5029: LD_INT 1750
5031: PPUSH
5032: CALL_OW 67
// tmp := ru_vehicles ;
5036: LD_ADDR_VAR 0 3
5040: PUSH
5041: LD_EXP 55
5045: ST_TO_ADDR
// if not tmp then
5046: LD_VAR 0 3
5050: NOT
5051: IFFALSE 5055
// exit ;
5053: GO 5193
// repeat wait ( 0 0$1 ) ;
5055: LD_INT 35
5057: PPUSH
5058: CALL_OW 67
// for i in tmp do
5062: LD_ADDR_VAR 0 1
5066: PUSH
5067: LD_VAR 0 3
5071: PUSH
5072: FOR_IN
5073: IFFALSE 5184
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5075: LD_ADDR_VAR 0 2
5079: PUSH
5080: LD_INT 22
5082: PUSH
5083: LD_INT 1
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: PPUSH
5090: LD_VAR 0 1
5094: PPUSH
5095: CALL_OW 74
5099: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5100: LD_VAR 0 1
5104: PPUSH
5105: LD_VAR 0 2
5109: PPUSH
5110: CALL_OW 296
5114: PUSH
5115: LD_INT 10
5117: GREATER
5118: IFFALSE 5137
// ComAgressiveMove ( i , 69 , 101 ) else
5120: LD_VAR 0 1
5124: PPUSH
5125: LD_INT 69
5127: PPUSH
5128: LD_INT 101
5130: PPUSH
5131: CALL_OW 114
5135: GO 5151
// ComAttackUnit ( i , enemy ) ;
5137: LD_VAR 0 1
5141: PPUSH
5142: LD_VAR 0 2
5146: PPUSH
5147: CALL_OW 115
// if GetLives ( i ) < 250 then
5151: LD_VAR 0 1
5155: PPUSH
5156: CALL_OW 256
5160: PUSH
5161: LD_INT 250
5163: LESS
5164: IFFALSE 5182
// tmp := tmp diff i ;
5166: LD_ADDR_VAR 0 3
5170: PUSH
5171: LD_VAR 0 3
5175: PUSH
5176: LD_VAR 0 1
5180: DIFF
5181: ST_TO_ADDR
// end ;
5182: GO 5072
5184: POP
5185: POP
// until not tmp ;
5186: LD_VAR 0 3
5190: NOT
5191: IFFALSE 5055
// end ; end_of_file
5193: PPOPN 3
5195: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5196: LD_INT 0
5198: PPUSH
5199: PPUSH
5200: PPUSH
5201: PPUSH
5202: PPUSH
5203: PPUSH
5204: PPUSH
// InGameOn ;
5205: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5209: LD_EXP 36
5213: PPUSH
5214: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5218: LD_EXP 36
5222: PPUSH
5223: LD_EXP 43
5227: PPUSH
5228: CALL_OW 119
// if Bierezov then
5232: LD_EXP 44
5236: IFFALSE 5252
// ComTurnUnit ( Bierezov , Cornel ) ;
5238: LD_EXP 44
5242: PPUSH
5243: LD_EXP 43
5247: PPUSH
5248: CALL_OW 119
// for i in jmm_units do
5252: LD_ADDR_VAR 0 2
5256: PUSH
5257: LD_EXP 4
5261: PUSH
5262: FOR_IN
5263: IFFALSE 5281
// ComTurnUnit ( i , Cornel ) ;
5265: LD_VAR 0 2
5269: PPUSH
5270: LD_EXP 43
5274: PPUSH
5275: CALL_OW 119
5279: GO 5262
5281: POP
5282: POP
// units := cornel_units union Cornel ;
5283: LD_ADDR_VAR 0 3
5287: PUSH
5288: LD_EXP 6
5292: PUSH
5293: LD_EXP 43
5297: UNION
5298: ST_TO_ADDR
// repeat wait ( 1 ) ;
5299: LD_INT 1
5301: PPUSH
5302: CALL_OW 67
// for i in units do
5306: LD_ADDR_VAR 0 2
5310: PUSH
5311: LD_VAR 0 3
5315: PUSH
5316: FOR_IN
5317: IFFALSE 5350
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5319: LD_VAR 0 2
5323: PPUSH
5324: LD_EXP 36
5328: PPUSH
5329: CALL_OW 250
5333: PPUSH
5334: LD_EXP 36
5338: PPUSH
5339: CALL_OW 251
5343: PPUSH
5344: CALL_OW 111
5348: GO 5316
5350: POP
5351: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5352: LD_VAR 0 3
5356: PPUSH
5357: LD_INT 92
5359: PUSH
5360: LD_EXP 36
5364: PPUSH
5365: CALL_OW 250
5369: PUSH
5370: LD_EXP 36
5374: PPUSH
5375: CALL_OW 251
5379: PUSH
5380: LD_INT 10
5382: PUSH
5383: EMPTY
5384: LIST
5385: LIST
5386: LIST
5387: LIST
5388: PPUSH
5389: CALL_OW 72
5393: PUSH
5394: LD_VAR 0 3
5398: EQUAL
5399: IFFALSE 5299
// for i in units do
5401: LD_ADDR_VAR 0 2
5405: PUSH
5406: LD_VAR 0 3
5410: PUSH
5411: FOR_IN
5412: IFFALSE 5430
// ComTurnUnit ( i , JMM ) ;
5414: LD_VAR 0 2
5418: PPUSH
5419: LD_EXP 36
5423: PPUSH
5424: CALL_OW 119
5428: GO 5411
5430: POP
5431: POP
// ComTurnUnit ( Cornel , JMM ) ;
5432: LD_EXP 43
5436: PPUSH
5437: LD_EXP 36
5441: PPUSH
5442: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5446: LD_EXP 36
5450: PPUSH
5451: LD_STRING D1-JMM-1
5453: PPUSH
5454: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5458: LD_EXP 43
5462: PPUSH
5463: LD_STRING D1-Corn-1
5465: PPUSH
5466: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5470: LD_EXP 36
5474: PPUSH
5475: LD_EXP 43
5479: PPUSH
5480: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5484: LD_EXP 43
5488: PPUSH
5489: LD_EXP 36
5493: PPUSH
5494: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5498: LD_INT 35
5500: PPUSH
5501: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5505: LD_EXP 36
5509: PPUSH
5510: LD_EXP 43
5514: PPUSH
5515: CALL_OW 296
5519: PUSH
5520: LD_INT 6
5522: LESS
5523: IFFALSE 5498
// ChangeSideFog ( 4 , 1 ) ;
5525: LD_INT 4
5527: PPUSH
5528: LD_INT 1
5530: PPUSH
5531: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5535: LD_EXP 36
5539: PPUSH
5540: LD_EXP 43
5544: PPUSH
5545: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5549: LD_EXP 43
5553: PPUSH
5554: LD_EXP 36
5558: PPUSH
5559: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5563: LD_EXP 36
5567: PPUSH
5568: LD_STRING D1-JMM-2
5570: PPUSH
5571: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5575: LD_EXP 36
5579: PPUSH
5580: LD_STRING D1-JMM-2a
5582: PPUSH
5583: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5587: LD_EXP 43
5591: PPUSH
5592: LD_STRING D1-Corn-2
5594: PPUSH
5595: CALL_OW 88
// if bierezov_exist or debug then
5599: LD_EXP 7
5603: PUSH
5604: LD_EXP 1
5608: OR
5609: IFFALSE 5850
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5611: LD_EXP 43
5615: PPUSH
5616: LD_EXP 44
5620: PPUSH
5621: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5625: LD_INT 10
5627: PPUSH
5628: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5632: LD_EXP 43
5636: PPUSH
5637: LD_STRING D1a-Corn-1
5639: PPUSH
5640: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5644: LD_EXP 36
5648: PPUSH
5649: LD_EXP 44
5653: PPUSH
5654: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5658: LD_EXP 44
5662: PPUSH
5663: LD_EXP 36
5667: PPUSH
5668: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5672: LD_EXP 36
5676: PPUSH
5677: LD_STRING D1a-JMM-1
5679: PPUSH
5680: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5684: LD_EXP 36
5688: PPUSH
5689: LD_EXP 43
5693: PPUSH
5694: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5698: LD_EXP 43
5702: PPUSH
5703: LD_EXP 36
5707: PPUSH
5708: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5712: LD_EXP 43
5716: PPUSH
5717: LD_STRING D1a-Corn-2
5719: PPUSH
5720: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5724: LD_EXP 36
5728: PPUSH
5729: LD_STRING D1a-JMM-2
5731: PPUSH
5732: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5736: LD_EXP 43
5740: PPUSH
5741: LD_STRING D1a-Corn-3
5743: PPUSH
5744: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5748: LD_EXP 36
5752: PPUSH
5753: LD_STRING D1a-JMM-3
5755: PPUSH
5756: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5760: LD_EXP 43
5764: PPUSH
5765: LD_STRING D1a-Corn-4
5767: PPUSH
5768: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5772: LD_EXP 36
5776: PPUSH
5777: LD_STRING D1a-JMM-4
5779: PPUSH
5780: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5784: LD_EXP 43
5788: PPUSH
5789: LD_STRING D1a-Corn-5
5791: PPUSH
5792: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5796: LD_EXP 44
5800: PPUSH
5801: LD_EXP 43
5805: PPUSH
5806: CALL_OW 250
5810: PPUSH
5811: LD_EXP 43
5815: PPUSH
5816: CALL_OW 251
5820: PUSH
5821: LD_INT 2
5823: MINUS
5824: PPUSH
5825: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5829: LD_EXP 44
5833: PPUSH
5834: LD_EXP 43
5838: PPUSH
5839: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5843: LD_INT 10
5845: PPUSH
5846: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5850: LD_EXP 36
5854: PPUSH
5855: LD_STRING D1b-JMM-1
5857: PPUSH
5858: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5862: LD_EXP 43
5866: PPUSH
5867: LD_STRING D1b-Corn-1
5869: PPUSH
5870: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5874: LD_EXP 36
5878: PPUSH
5879: LD_STRING D1b-JMM-2
5881: PPUSH
5882: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5886: LD_EXP 43
5890: PPUSH
5891: LD_STRING D1b-Corn-2
5893: PPUSH
5894: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5898: LD_EXP 36
5902: PPUSH
5903: LD_STRING D1b-JMM-3
5905: PPUSH
5906: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5910: LD_INT 10
5912: PPUSH
5913: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5917: LD_EXP 45
5921: PPUSH
5922: LD_STRING D1b-Pow-3
5924: PPUSH
5925: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5929: LD_EXP 36
5933: PPUSH
5934: LD_STRING D1b-JMM-4
5936: PPUSH
5937: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5941: LD_EXP 43
5945: PPUSH
5946: LD_STRING D1b-Corn-4
5948: PPUSH
5949: CALL_OW 88
// if Khatam then
5953: LD_EXP 40
5957: IFFALSE 5973
// Say ( Khatam , D1b-Khat-4 ) else
5959: LD_EXP 40
5963: PPUSH
5964: LD_STRING D1b-Khat-4
5966: PPUSH
5967: CALL_OW 88
5971: GO 6009
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
5973: LD_EXP 6
5977: PPUSH
5978: LD_INT 26
5980: PUSH
5981: LD_INT 1
5983: PUSH
5984: EMPTY
5985: LIST
5986: LIST
5987: PPUSH
5988: CALL_OW 72
5992: PUSH
5993: LD_EXP 43
5997: PUSH
5998: EMPTY
5999: LIST
6000: DIFF
6001: PPUSH
6002: LD_STRING D1b-Sol1-4
6004: PPUSH
6005: CALL 625 0 2
// if Cyrus then
6009: LD_EXP 38
6013: IFFALSE 6027
// Say ( Cyrus , D1b-Cyrus-4 ) ;
6015: LD_EXP 38
6019: PPUSH
6020: LD_STRING D1b-Cyrus-4
6022: PPUSH
6023: CALL_OW 88
// if Lisa then
6027: LD_EXP 39
6031: IFFALSE 6089
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6033: LD_EXP 39
6037: PPUSH
6038: LD_STRING D1b-Lisa-4
6040: PPUSH
6041: CALL_OW 88
// if Cyrus then
6045: LD_EXP 38
6049: IFFALSE 6089
// begin if not IsInUnit ( Cyrus ) then
6051: LD_EXP 38
6055: PPUSH
6056: CALL_OW 310
6060: NOT
6061: IFFALSE 6077
// ComTurnUnit ( Cyrus , Lisa ) ;
6063: LD_EXP 38
6067: PPUSH
6068: LD_EXP 39
6072: PPUSH
6073: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6077: LD_EXP 38
6081: PPUSH
6082: LD_STRING D1b-Cyrus-5
6084: PPUSH
6085: CALL_OW 88
// end ; end ; SelectGroup ;
6089: CALL 2578 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6093: LD_EXP 36
6097: PPUSH
6098: LD_STRING D1d-JMM-1
6100: PPUSH
6101: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6105: LD_EXP 43
6109: PPUSH
6110: LD_STRING D1d-Corn-1
6112: PPUSH
6113: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6117: LD_ADDR_VAR 0 2
6121: PUSH
6122: LD_EXP 4
6126: PUSH
6127: LD_EXP 6
6131: ADD
6132: PUSH
6133: LD_EXP 36
6137: ADD
6138: PUSH
6139: FOR_IN
6140: IFFALSE 6153
// ComHold ( i ) ;
6142: LD_VAR 0 2
6146: PPUSH
6147: CALL_OW 140
6151: GO 6139
6153: POP
6154: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6155: LD_ADDR_VAR 0 4
6159: PUSH
6160: LD_INT 22
6162: PUSH
6163: LD_INT 1
6165: PUSH
6166: EMPTY
6167: LIST
6168: LIST
6169: PUSH
6170: LD_INT 21
6172: PUSH
6173: LD_INT 2
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: PUSH
6180: EMPTY
6181: LIST
6182: LIST
6183: PPUSH
6184: CALL_OW 69
6188: ST_TO_ADDR
// if vehicles then
6189: LD_VAR 0 4
6193: IFFALSE 6531
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6195: LD_EXP 6
6199: PPUSH
6200: LD_INT 55
6202: PUSH
6203: EMPTY
6204: LIST
6205: PPUSH
6206: CALL_OW 72
6210: IFFALSE 6249
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6212: LD_ADDR_VAR 0 2
6216: PUSH
6217: LD_EXP 6
6221: PPUSH
6222: LD_INT 55
6224: PUSH
6225: EMPTY
6226: LIST
6227: PPUSH
6228: CALL_OW 72
6232: PUSH
6233: FOR_IN
6234: IFFALSE 6247
// ComExitVehicle ( i ) ;
6236: LD_VAR 0 2
6240: PPUSH
6241: CALL_OW 121
6245: GO 6233
6247: POP
6248: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6249: LD_ADDR_VAR 0 5
6253: PUSH
6254: LD_VAR 0 4
6258: PPUSH
6259: LD_INT 34
6261: PUSH
6262: LD_INT 51
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: PPUSH
6269: CALL_OW 72
6273: ST_TO_ADDR
// if cargos then
6274: LD_VAR 0 5
6278: IFFALSE 6461
// begin vehicles := cargos ;
6280: LD_ADDR_VAR 0 4
6284: PUSH
6285: LD_VAR 0 5
6289: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6290: LD_ADDR_VAR 0 6
6294: PUSH
6295: LD_STRING 02_resources_4
6297: PPUSH
6298: LD_INT 0
6300: PPUSH
6301: CALL_OW 30
6305: ST_TO_ADDR
// if debug and not resources then
6306: LD_EXP 1
6310: PUSH
6311: LD_VAR 0 6
6315: NOT
6316: AND
6317: IFFALSE 6327
// resources := 160 ;
6319: LD_ADDR_VAR 0 6
6323: PUSH
6324: LD_INT 160
6326: ST_TO_ADDR
// if resources mod 10 then
6327: LD_VAR 0 6
6331: PUSH
6332: LD_INT 10
6334: MOD
6335: IFFALSE 6357
// resources := resources - resources mod 10 ;
6337: LD_ADDR_VAR 0 6
6341: PUSH
6342: LD_VAR 0 6
6346: PUSH
6347: LD_VAR 0 6
6351: PUSH
6352: LD_INT 10
6354: MOD
6355: MINUS
6356: ST_TO_ADDR
// if resources then
6357: LD_VAR 0 6
6361: IFFALSE 6461
// for i in cargos do
6363: LD_ADDR_VAR 0 2
6367: PUSH
6368: LD_VAR 0 5
6372: PUSH
6373: FOR_IN
6374: IFFALSE 6459
// begin if resources < 100 then
6376: LD_VAR 0 6
6380: PUSH
6381: LD_INT 100
6383: LESS
6384: IFFALSE 6406
// begin cargo := resources ;
6386: LD_ADDR_VAR 0 7
6390: PUSH
6391: LD_VAR 0 6
6395: ST_TO_ADDR
// resources := 0 ;
6396: LD_ADDR_VAR 0 6
6400: PUSH
6401: LD_INT 0
6403: ST_TO_ADDR
// end else
6404: GO 6428
// begin cargo := 100 ;
6406: LD_ADDR_VAR 0 7
6410: PUSH
6411: LD_INT 100
6413: ST_TO_ADDR
// resources := resources - 100 ;
6414: LD_ADDR_VAR 0 6
6418: PUSH
6419: LD_VAR 0 6
6423: PUSH
6424: LD_INT 100
6426: MINUS
6427: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6428: LD_VAR 0 2
6432: PPUSH
6433: LD_INT 1
6435: PPUSH
6436: LD_VAR 0 7
6440: PPUSH
6441: CALL_OW 290
// if resources = 0 then
6445: LD_VAR 0 6
6449: PUSH
6450: LD_INT 0
6452: EQUAL
6453: IFFALSE 6457
// break ;
6455: GO 6459
// end ;
6457: GO 6373
6459: POP
6460: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6461: LD_VAR 0 4
6465: PUSH
6466: LD_INT 1
6468: ARRAY
6469: PPUSH
6470: CALL_OW 311
6474: PPUSH
6475: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6479: LD_VAR 0 4
6483: PUSH
6484: LD_INT 1
6486: ARRAY
6487: PPUSH
6488: LD_INT 4
6490: PPUSH
6491: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6495: LD_EXP 43
6499: PPUSH
6500: LD_VAR 0 4
6504: PUSH
6505: LD_INT 1
6507: ARRAY
6508: PPUSH
6509: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6513: LD_INT 35
6515: PPUSH
6516: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6520: LD_EXP 43
6524: PPUSH
6525: CALL_OW 310
6529: IFFALSE 6513
// end ; InGameOff ;
6531: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6535: LD_STRING M1
6537: PPUSH
6538: CALL_OW 337
// SaveForQuickRestart ;
6542: CALL_OW 22
// cornel_active := true ;
6546: LD_ADDR_EXP 8
6550: PUSH
6551: LD_INT 1
6553: ST_TO_ADDR
// end ;
6554: LD_VAR 0 1
6558: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns , tmp ;
6559: LD_EXP 36
6563: PPUSH
6564: LD_EXP 46
6568: PPUSH
6569: CALL_OW 296
6573: PUSH
6574: LD_INT 10
6576: LESS
6577: IFFALSE 7934
6579: GO 6581
6581: DISABLE
6582: LD_INT 0
6584: PPUSH
6585: PPUSH
6586: PPUSH
6587: PPUSH
6588: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6589: LD_ADDR_VAR 0 2
6593: PUSH
6594: LD_INT 89
6596: PUSH
6597: LD_INT 34
6599: PUSH
6600: EMPTY
6601: LIST
6602: LIST
6603: PUSH
6604: LD_INT 138
6606: PUSH
6607: LD_INT 63
6609: PUSH
6610: EMPTY
6611: LIST
6612: LIST
6613: PUSH
6614: LD_INT 196
6616: PUSH
6617: LD_INT 84
6619: PUSH
6620: EMPTY
6621: LIST
6622: LIST
6623: PUSH
6624: LD_INT 135
6626: PUSH
6627: LD_INT 52
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: PUSH
6634: LD_INT 103
6636: PUSH
6637: LD_INT 39
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: PUSH
6644: LD_INT 58
6646: PUSH
6647: LD_INT 30
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 38
6656: PUSH
6657: LD_INT 51
6659: PUSH
6660: EMPTY
6661: LIST
6662: LIST
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: LIST
6668: LIST
6669: LIST
6670: LIST
6671: LIST
6672: ST_TO_ADDR
// InGameOn ;
6673: CALL_OW 8
// if jmm_units then
6677: LD_EXP 4
6681: IFFALSE 6757
// for i in jmm_units do
6683: LD_ADDR_VAR 0 1
6687: PUSH
6688: LD_EXP 4
6692: PUSH
6693: FOR_IN
6694: IFFALSE 6755
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6696: LD_VAR 0 1
6700: PPUSH
6701: LD_EXP 36
6705: PPUSH
6706: CALL_OW 296
6710: PUSH
6711: LD_INT 10
6713: LESS
6714: PUSH
6715: LD_VAR 0 1
6719: PPUSH
6720: CALL_OW 310
6724: NOT
6725: AND
6726: IFFALSE 6744
// ComTurnUnit ( i , JMM ) else
6728: LD_VAR 0 1
6732: PPUSH
6733: LD_EXP 36
6737: PPUSH
6738: CALL_OW 119
6742: GO 6753
// ComHold ( i ) ;
6744: LD_VAR 0 1
6748: PPUSH
6749: CALL_OW 140
// end ;
6753: GO 6693
6755: POP
6756: POP
// if IsInUnit ( JMM ) then
6757: LD_EXP 36
6761: PPUSH
6762: CALL_OW 310
6766: IFFALSE 6791
// begin ComExitVehicle ( JMM ) ;
6768: LD_EXP 36
6772: PPUSH
6773: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6777: LD_EXP 36
6781: PPUSH
6782: LD_EXP 46
6786: PPUSH
6787: CALL_OW 172
// end ; Wait ( 10 ) ;
6791: LD_INT 10
6793: PPUSH
6794: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6798: LD_EXP 36
6802: PPUSH
6803: LD_EXP 46
6807: PPUSH
6808: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6812: LD_INT 35
6814: PPUSH
6815: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6819: LD_EXP 36
6823: PPUSH
6824: LD_EXP 46
6828: PPUSH
6829: CALL_OW 296
6833: PUSH
6834: LD_INT 6
6836: LESS
6837: IFFALSE 6812
// ComTurnUnit ( JMM , Lynch ) ;
6839: LD_EXP 36
6843: PPUSH
6844: LD_EXP 46
6848: PPUSH
6849: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6853: LD_ADDR_VAR 0 1
6857: PUSH
6858: LD_EXP 46
6862: PUSH
6863: LD_EXP 47
6867: PUSH
6868: LD_EXP 48
6872: PUSH
6873: LD_EXP 49
6877: PUSH
6878: EMPTY
6879: LIST
6880: LIST
6881: LIST
6882: LIST
6883: PUSH
6884: FOR_IN
6885: IFFALSE 6903
// ComTurnUnit ( i , JMM ) ;
6887: LD_VAR 0 1
6891: PPUSH
6892: LD_EXP 36
6896: PPUSH
6897: CALL_OW 119
6901: GO 6884
6903: POP
6904: POP
// Wait ( 0 0$0.3 ) ;
6905: LD_INT 10
6907: PPUSH
6908: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6912: LD_EXP 36
6916: PPUSH
6917: LD_STRING D2-JMM-1
6919: PPUSH
6920: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6924: LD_EXP 46
6928: PPUSH
6929: LD_STRING D2-Sol1-1
6931: PPUSH
6932: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6936: LD_EXP 36
6940: PPUSH
6941: LD_STRING D2-JMM-2
6943: PPUSH
6944: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6948: LD_EXP 46
6952: PPUSH
6953: LD_STRING D2-Sol1-2
6955: PPUSH
6956: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6960: LD_EXP 36
6964: PPUSH
6965: LD_STRING D2-JMM-3
6967: PPUSH
6968: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
6972: LD_EXP 46
6976: PPUSH
6977: LD_STRING D2-Sol1-3
6979: PPUSH
6980: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6984: LD_ADDR_VAR 0 1
6988: PUSH
6989: LD_INT 22
6991: PUSH
6992: LD_INT 8
6994: PUSH
6995: EMPTY
6996: LIST
6997: LIST
6998: PPUSH
6999: CALL_OW 69
7003: PUSH
7004: FOR_IN
7005: IFFALSE 7021
// SetSide ( i , 1 ) ;
7007: LD_VAR 0 1
7011: PPUSH
7012: LD_INT 1
7014: PPUSH
7015: CALL_OW 235
7019: GO 7004
7021: POP
7022: POP
// Say ( JMM , D2-JMM-4 ) ;
7023: LD_EXP 36
7027: PPUSH
7028: LD_STRING D2-JMM-4
7030: PPUSH
7031: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7035: LD_INT 1
7037: PPUSH
7038: LD_INT 5
7040: PPUSH
7041: CALL_OW 332
// for i = 1 to points do
7045: LD_ADDR_VAR 0 1
7049: PUSH
7050: DOUBLE
7051: LD_INT 1
7053: DEC
7054: ST_TO_ADDR
7055: LD_VAR 0 2
7059: PUSH
7060: FOR_TO
7061: IFFALSE 7236
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7063: LD_VAR 0 2
7067: PUSH
7068: LD_VAR 0 1
7072: ARRAY
7073: PUSH
7074: LD_INT 1
7076: ARRAY
7077: PPUSH
7078: LD_VAR 0 2
7082: PUSH
7083: LD_VAR 0 1
7087: ARRAY
7088: PUSH
7089: LD_INT 2
7091: ARRAY
7092: PPUSH
7093: CALL_OW 84
// if i = 1 then
7097: LD_VAR 0 1
7101: PUSH
7102: LD_INT 1
7104: EQUAL
7105: IFFALSE 7119
// Say ( Lynch , D2-Sol1-4 ) ;
7107: LD_EXP 46
7111: PPUSH
7112: LD_STRING D2-Sol1-4
7114: PPUSH
7115: CALL_OW 88
// if i = 2 then
7119: LD_VAR 0 1
7123: PUSH
7124: LD_INT 2
7126: EQUAL
7127: IFFALSE 7141
// Say ( JMM , D2-JMM-5 ) ;
7129: LD_EXP 36
7133: PPUSH
7134: LD_STRING D2-JMM-5
7136: PPUSH
7137: CALL_OW 88
// if i = 4 then
7141: LD_VAR 0 1
7145: PUSH
7146: LD_INT 4
7148: EQUAL
7149: IFFALSE 7173
// begin RevealFogArea ( 1 , troopsArea ) ;
7151: LD_INT 1
7153: PPUSH
7154: LD_INT 6
7156: PPUSH
7157: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7161: LD_EXP 46
7165: PPUSH
7166: LD_STRING D2-Sol1-5
7168: PPUSH
7169: CALL_OW 88
// end ; if i = 5 then
7173: LD_VAR 0 1
7177: PUSH
7178: LD_INT 5
7180: EQUAL
7181: IFFALSE 7195
// Say ( JMM , D2-JMM-6 ) ;
7183: LD_EXP 36
7187: PPUSH
7188: LD_STRING D2-JMM-6
7190: PPUSH
7191: CALL_OW 88
// if i = 7 then
7195: LD_VAR 0 1
7199: PUSH
7200: LD_INT 7
7202: EQUAL
7203: IFFALSE 7227
// begin RevealFogArea ( 1 , forestArea ) ;
7205: LD_INT 1
7207: PPUSH
7208: LD_INT 7
7210: PPUSH
7211: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7215: LD_EXP 46
7219: PPUSH
7220: LD_STRING D2-Sol1-6
7222: PPUSH
7223: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7227: LD_INT 46
7229: PPUSH
7230: CALL_OW 67
// end ;
7234: GO 7060
7236: POP
7237: POP
// CenterNowOnUnits ( JMM ) ;
7238: LD_EXP 36
7242: PPUSH
7243: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7247: LD_EXP 36
7251: PPUSH
7252: LD_STRING D2-JMM-7
7254: PPUSH
7255: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7259: LD_EXP 46
7263: PPUSH
7264: LD_STRING D2-Sol1-7
7266: PPUSH
7267: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7271: LD_EXP 36
7275: PPUSH
7276: LD_STRING D2-JMM-8
7278: PPUSH
7279: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7283: LD_ADDR_VAR 0 4
7287: PUSH
7288: LD_INT 22
7290: PUSH
7291: LD_INT 1
7293: PUSH
7294: EMPTY
7295: LIST
7296: LIST
7297: PUSH
7298: LD_INT 30
7300: PUSH
7301: LD_INT 31
7303: PUSH
7304: EMPTY
7305: LIST
7306: LIST
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: PPUSH
7312: CALL_OW 69
7316: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7317: LD_EXP 46
7321: PPUSH
7322: LD_VAR 0 4
7326: PUSH
7327: LD_INT 1
7329: ARRAY
7330: PPUSH
7331: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7335: LD_INT 65
7337: PPUSH
7338: LD_INT 101
7340: PPUSH
7341: CALL_OW 428
7345: IFFALSE 7368
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7347: LD_INT 65
7349: PPUSH
7350: LD_INT 101
7352: PPUSH
7353: CALL_OW 428
7357: PPUSH
7358: LD_INT 75
7360: PPUSH
7361: LD_INT 100
7363: PPUSH
7364: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7368: LD_INT 66
7370: PPUSH
7371: LD_INT 103
7373: PPUSH
7374: CALL_OW 428
7378: IFFALSE 7401
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7380: LD_INT 66
7382: PPUSH
7383: LD_INT 103
7385: PPUSH
7386: CALL_OW 428
7390: PPUSH
7391: LD_INT 75
7393: PPUSH
7394: LD_INT 100
7396: PPUSH
7397: CALL_OW 111
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_dist , JMM , 7 ] ] ) ;
7401: LD_ADDR_VAR 0 5
7405: PUSH
7406: LD_INT 22
7408: PUSH
7409: LD_INT 1
7411: PUSH
7412: EMPTY
7413: LIST
7414: LIST
7415: PUSH
7416: LD_INT 21
7418: PUSH
7419: LD_INT 2
7421: PUSH
7422: EMPTY
7423: LIST
7424: LIST
7425: PUSH
7426: LD_INT 91
7428: PUSH
7429: LD_EXP 36
7433: PUSH
7434: LD_INT 7
7436: PUSH
7437: EMPTY
7438: LIST
7439: LIST
7440: LIST
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: PPUSH
7447: CALL_OW 69
7451: ST_TO_ADDR
// if tmp then
7452: LD_VAR 0 5
7456: IFFALSE 7473
// ComMoveXY ( tmp , 75 , 100 ) ;
7458: LD_VAR 0 5
7462: PPUSH
7463: LD_INT 75
7465: PPUSH
7466: LD_INT 100
7468: PPUSH
7469: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7473: LD_ADDR_VAR 0 3
7477: PUSH
7478: LD_EXP 4
7482: PPUSH
7483: LD_INT 25
7485: PUSH
7486: LD_INT 1
7488: PUSH
7489: EMPTY
7490: LIST
7491: LIST
7492: PPUSH
7493: CALL_OW 72
7497: PPUSH
7498: LD_EXP 36
7502: PPUSH
7503: CALL_OW 74
7507: ST_TO_ADDR
// if sol then
7508: LD_VAR 0 3
7512: IFFALSE 7552
// if GetDistUnits ( JMM , sol ) < 10 then
7514: LD_EXP 36
7518: PPUSH
7519: LD_VAR 0 3
7523: PPUSH
7524: CALL_OW 296
7528: PUSH
7529: LD_INT 10
7531: LESS
7532: IFFALSE 7552
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7534: LD_VAR 0 3
7538: PPUSH
7539: LD_VAR 0 4
7543: PUSH
7544: LD_INT 2
7546: ARRAY
7547: PPUSH
7548: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7552: LD_INT 10
7554: PPUSH
7555: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7559: LD_EXP 36
7563: PPUSH
7564: LD_INT 65
7566: PPUSH
7567: LD_INT 101
7569: PPUSH
7570: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7574: LD_EXP 36
7578: PPUSH
7579: LD_INT 63
7581: PPUSH
7582: LD_INT 100
7584: PPUSH
7585: CALL_OW 178
// tmp := 0 0$0 ;
7589: LD_ADDR_VAR 0 5
7593: PUSH
7594: LD_INT 0
7596: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7597: LD_INT 35
7599: PPUSH
7600: CALL_OW 67
// tmp := tmp + 0 0$1 ;
7604: LD_ADDR_VAR 0 5
7608: PUSH
7609: LD_VAR 0 5
7613: PUSH
7614: LD_INT 35
7616: PLUS
7617: ST_TO_ADDR
// until IsAt ( JMM , 65 , 101 ) or tmp > 0 0$5 ;
7618: LD_EXP 36
7622: PPUSH
7623: LD_INT 65
7625: PPUSH
7626: LD_INT 101
7628: PPUSH
7629: CALL_OW 307
7633: PUSH
7634: LD_VAR 0 5
7638: PUSH
7639: LD_INT 175
7641: GREATER
7642: OR
7643: IFFALSE 7597
// Say ( JMM , D2a-JMM-1 ) ;
7645: LD_EXP 36
7649: PPUSH
7650: LD_STRING D2a-JMM-1
7652: PPUSH
7653: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7657: LD_EXP 47
7661: PPUSH
7662: LD_INT 66
7664: PPUSH
7665: LD_INT 103
7667: PPUSH
7668: CALL_OW 111
// tmp := 0 0$0 ;
7672: LD_ADDR_VAR 0 5
7676: PUSH
7677: LD_INT 0
7679: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7680: LD_INT 35
7682: PPUSH
7683: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) or tmp > 0 0$5 ;
7687: LD_EXP 47
7691: PPUSH
7692: LD_INT 66
7694: PPUSH
7695: LD_INT 103
7697: PPUSH
7698: CALL_OW 307
7702: PUSH
7703: LD_VAR 0 5
7707: PUSH
7708: LD_INT 175
7710: GREATER
7711: OR
7712: IFFALSE 7680
// ComTurnUnit ( Walker , JMM ) ;
7714: LD_EXP 47
7718: PPUSH
7719: LD_EXP 36
7723: PPUSH
7724: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7728: LD_EXP 47
7732: PPUSH
7733: LD_STRING D2a-Sci1-1
7735: PPUSH
7736: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7740: LD_EXP 36
7744: PPUSH
7745: LD_EXP 47
7749: PPUSH
7750: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7754: LD_EXP 36
7758: PPUSH
7759: LD_STRING D2a-JMM-2
7761: PPUSH
7762: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7766: LD_EXP 47
7770: PPUSH
7771: LD_STRING D2a-Sci1-2
7773: PPUSH
7774: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7778: LD_EXP 36
7782: PPUSH
7783: LD_STRING D2a-JMM-3
7785: PPUSH
7786: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7790: LD_EXP 47
7794: PPUSH
7795: LD_STRING D2a-Sci1-3
7797: PPUSH
7798: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7802: LD_ADDR_EXP 4
7806: PUSH
7807: LD_EXP 4
7811: PUSH
7812: LD_EXP 46
7816: PUSH
7817: LD_EXP 47
7821: PUSH
7822: LD_EXP 48
7826: PUSH
7827: LD_EXP 49
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: LIST
7836: LIST
7837: ADD
7838: ST_TO_ADDR
// for i in jmm_units do
7839: LD_ADDR_VAR 0 1
7843: PUSH
7844: LD_EXP 4
7848: PUSH
7849: FOR_IN
7850: IFFALSE 7875
// if not IsInUnit ( i ) then
7852: LD_VAR 0 1
7856: PPUSH
7857: CALL_OW 310
7861: NOT
7862: IFFALSE 7873
// ComFree ( i ) ;
7864: LD_VAR 0 1
7868: PPUSH
7869: CALL_OW 139
7873: GO 7849
7875: POP
7876: POP
// InGameOff ;
7877: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
7881: LD_STRING MSolar1
7883: PPUSH
7884: CALL_OW 337
// jmm_on_west := true ;
7888: LD_ADDR_EXP 5
7892: PUSH
7893: LD_INT 1
7895: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7896: LD_INT 1050
7898: PPUSH
7899: CALL_OW 67
// frank_can_return := true ;
7903: LD_ADDR_EXP 12
7907: PUSH
7908: LD_INT 1
7910: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7911: LD_INT 6300
7913: PPUSH
7914: LD_INT 8400
7916: PPUSH
7917: CALL_OW 12
7921: PPUSH
7922: CALL_OW 67
// send_spec_patrol := true ;
7926: LD_ADDR_EXP 29
7930: PUSH
7931: LD_INT 1
7933: ST_TO_ADDR
// end ;
7934: PPOPN 5
7936: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7937: LD_INT 22
7939: PUSH
7940: LD_INT 1
7942: PUSH
7943: EMPTY
7944: LIST
7945: LIST
7946: PUSH
7947: LD_INT 34
7949: PUSH
7950: LD_INT 51
7952: PUSH
7953: EMPTY
7954: LIST
7955: LIST
7956: PUSH
7957: LD_INT 92
7959: PUSH
7960: LD_INT 63
7962: PUSH
7963: LD_INT 100
7965: PUSH
7966: LD_INT 5
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: LIST
7979: PUSH
7980: EMPTY
7981: LIST
7982: PPUSH
7983: CALL_OW 69
7987: PUSH
7988: LD_EXP 5
7992: NOT
7993: AND
7994: IFFALSE 8107
7996: GO 7998
7998: DISABLE
7999: LD_INT 0
8001: PPUSH
8002: PPUSH
// begin enable ;
8003: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
8004: LD_ADDR_VAR 0 2
8008: PUSH
8009: LD_INT 22
8011: PUSH
8012: LD_INT 1
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: PUSH
8019: LD_INT 34
8021: PUSH
8022: LD_INT 51
8024: PUSH
8025: EMPTY
8026: LIST
8027: LIST
8028: PUSH
8029: LD_INT 92
8031: PUSH
8032: LD_INT 63
8034: PUSH
8035: LD_INT 100
8037: PUSH
8038: LD_INT 5
8040: PUSH
8041: EMPTY
8042: LIST
8043: LIST
8044: LIST
8045: LIST
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: LIST
8051: PUSH
8052: EMPTY
8053: LIST
8054: PPUSH
8055: CALL_OW 69
8059: ST_TO_ADDR
// if not filter then
8060: LD_VAR 0 2
8064: NOT
8065: IFFALSE 8069
// exit ;
8067: GO 8107
// for i in filter do
8069: LD_ADDR_VAR 0 1
8073: PUSH
8074: LD_VAR 0 2
8078: PUSH
8079: FOR_IN
8080: IFFALSE 8105
// begin SetFuel ( i , 0 ) ;
8082: LD_VAR 0 1
8086: PPUSH
8087: LD_INT 0
8089: PPUSH
8090: CALL_OW 240
// ComStop ( i ) ;
8094: LD_VAR 0 1
8098: PPUSH
8099: CALL_OW 141
// end ;
8103: GO 8079
8105: POP
8106: POP
// end ;
8107: PPOPN 2
8109: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
8110: LD_EXP 29
8114: IFFALSE 9107
8116: GO 8118
8118: DISABLE
8119: LD_INT 0
8121: PPUSH
8122: PPUSH
8123: PPUSH
8124: PPUSH
8125: PPUSH
8126: PPUSH
8127: PPUSH
// begin if not ru_spec_patrol then
8128: LD_EXP 53
8132: NOT
8133: IFFALSE 8137
// exit ;
8135: GO 9107
// dead1 := false ;
8137: LD_ADDR_VAR 0 1
8141: PUSH
8142: LD_INT 0
8144: ST_TO_ADDR
// dead2 := false ;
8145: LD_ADDR_VAR 0 2
8149: PUSH
8150: LD_INT 0
8152: ST_TO_ADDR
// inarea1 := false ;
8153: LD_ADDR_VAR 0 3
8157: PUSH
8158: LD_INT 0
8160: ST_TO_ADDR
// inarea2 := false ;
8161: LD_ADDR_VAR 0 4
8165: PUSH
8166: LD_INT 0
8168: ST_TO_ADDR
// tmp := [ ] ;
8169: LD_ADDR_VAR 0 6
8173: PUSH
8174: EMPTY
8175: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8176: LD_EXP 53
8180: PPUSH
8181: LD_INT 75
8183: PPUSH
8184: LD_INT 101
8186: PPUSH
8187: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8191: LD_INT 35
8193: PPUSH
8194: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8198: LD_INT 1
8200: PPUSH
8201: LD_EXP 53
8205: PUSH
8206: LD_INT 1
8208: ARRAY
8209: PPUSH
8210: CALL_OW 292
8214: IFFALSE 8191
// ComStop ( ru_spec_patrol ) ;
8216: LD_EXP 53
8220: PPUSH
8221: CALL_OW 141
// Wait ( 0 0$02 ) ;
8225: LD_INT 70
8227: PPUSH
8228: CALL_OW 67
// DialogueOn ;
8232: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8236: LD_EXP 53
8240: PUSH
8241: LD_INT 1
8243: ARRAY
8244: PPUSH
8245: LD_STRING D8-Rus1-1
8247: PPUSH
8248: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8252: LD_EXP 36
8256: PPUSH
8257: LD_STRING D8-JMM-1
8259: PPUSH
8260: CALL_OW 88
// DialogueOff ;
8264: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8268: LD_EXP 53
8272: PPUSH
8273: LD_INT 13
8275: PPUSH
8276: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8280: LD_INT 35
8282: PPUSH
8283: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8287: LD_VAR 0 1
8291: NOT
8292: PUSH
8293: LD_EXP 53
8297: PUSH
8298: LD_INT 1
8300: ARRAY
8301: PPUSH
8302: CALL_OW 301
8306: AND
8307: IFFALSE 8317
// dead1 := true ;
8309: LD_ADDR_VAR 0 1
8313: PUSH
8314: LD_INT 1
8316: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8317: LD_VAR 0 2
8321: NOT
8322: PUSH
8323: LD_EXP 53
8327: PUSH
8328: LD_INT 2
8330: ARRAY
8331: PPUSH
8332: CALL_OW 301
8336: AND
8337: IFFALSE 8347
// dead2 := true ;
8339: LD_ADDR_VAR 0 2
8343: PUSH
8344: LD_INT 1
8346: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8347: LD_VAR 0 3
8351: NOT
8352: PUSH
8353: LD_EXP 53
8357: PUSH
8358: LD_INT 1
8360: ARRAY
8361: PPUSH
8362: LD_INT 14
8364: PPUSH
8365: CALL_OW 308
8369: AND
8370: IFFALSE 8380
// inarea1 := true ;
8372: LD_ADDR_VAR 0 3
8376: PUSH
8377: LD_INT 1
8379: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8380: LD_VAR 0 4
8384: NOT
8385: PUSH
8386: LD_EXP 53
8390: PUSH
8391: LD_INT 2
8393: ARRAY
8394: PPUSH
8395: LD_INT 14
8397: PPUSH
8398: CALL_OW 308
8402: AND
8403: IFFALSE 8413
// inarea2 := true ;
8405: LD_ADDR_VAR 0 4
8409: PUSH
8410: LD_INT 1
8412: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8413: LD_VAR 0 1
8417: PUSH
8418: LD_VAR 0 2
8422: AND
8423: PUSH
8424: LD_VAR 0 1
8428: PUSH
8429: LD_VAR 0 4
8433: AND
8434: OR
8435: PUSH
8436: LD_VAR 0 2
8440: PUSH
8441: LD_VAR 0 3
8445: AND
8446: OR
8447: PUSH
8448: LD_VAR 0 3
8452: PUSH
8453: LD_VAR 0 4
8457: AND
8458: OR
8459: IFFALSE 8280
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8461: LD_VAR 0 3
8465: PUSH
8466: LD_VAR 0 4
8470: AND
8471: PUSH
8472: LD_VAR 0 1
8476: PUSH
8477: LD_VAR 0 4
8481: AND
8482: OR
8483: PUSH
8484: LD_VAR 0 2
8488: PUSH
8489: LD_VAR 0 3
8493: AND
8494: OR
8495: IFFALSE 9087
// begin prepare_siege := true ;
8497: LD_ADDR_EXP 30
8501: PUSH
8502: LD_INT 1
8504: ST_TO_ADDR
// DialogueOn ;
8505: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8509: LD_VAR 0 3
8513: PUSH
8514: LD_VAR 0 4
8518: AND
8519: IFFALSE 8535
// Say ( JMM , D8b-JMM-1a ) else
8521: LD_EXP 36
8525: PPUSH
8526: LD_STRING D8b-JMM-1a
8528: PPUSH
8529: CALL_OW 88
8533: GO 8547
// Say ( JMM , D8b-JMM-1 ) ;
8535: LD_EXP 36
8539: PPUSH
8540: LD_STRING D8b-JMM-1
8542: PPUSH
8543: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8547: LD_EXP 4
8551: PPUSH
8552: LD_INT 26
8554: PUSH
8555: LD_INT 1
8557: PUSH
8558: EMPTY
8559: LIST
8560: LIST
8561: PPUSH
8562: CALL_OW 72
8566: PUSH
8567: LD_EXP 37
8571: PUSH
8572: LD_EXP 38
8576: PUSH
8577: LD_EXP 47
8581: PUSH
8582: LD_EXP 50
8586: PUSH
8587: EMPTY
8588: LIST
8589: LIST
8590: LIST
8591: LIST
8592: DIFF
8593: PPUSH
8594: LD_STRING D8b-Sol1-1
8596: PPUSH
8597: CALL 625 0 2
// if Cyrus and Cyrus in jmm_units then
8601: LD_EXP 38
8605: PUSH
8606: LD_EXP 38
8610: PUSH
8611: LD_EXP 4
8615: IN
8616: AND
8617: IFFALSE 8633
// Say ( Cyrus , D8b-Cyrus-1 ) else
8619: LD_EXP 38
8623: PPUSH
8624: LD_STRING D8b-Cyrus-1
8626: PPUSH
8627: CALL_OW 88
8631: GO 8645
// Say ( JMM , D8b-JMM-1a ) ;
8633: LD_EXP 36
8637: PPUSH
8638: LD_STRING D8b-JMM-1a
8640: PPUSH
8641: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8645: LD_EXP 39
8649: PUSH
8650: LD_EXP 39
8654: PUSH
8655: LD_EXP 4
8659: IN
8660: AND
8661: IFFALSE 8675
// Say ( Lisa , D8b-Lisa-2 ) ;
8663: LD_EXP 39
8667: PPUSH
8668: LD_STRING D8b-Lisa-2
8670: PPUSH
8671: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8675: LD_EXP 37
8679: PUSH
8680: LD_EXP 37
8684: PUSH
8685: LD_EXP 4
8689: IN
8690: AND
8691: IFFALSE 8707
// Say ( Bobby , D8b-Bobby-1 ) else
8693: LD_EXP 37
8697: PPUSH
8698: LD_STRING D8b-Bobby-1
8700: PPUSH
8701: CALL_OW 88
8705: GO 8767
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8707: LD_ADDR_VAR 0 5
8711: PUSH
8712: LD_EXP 4
8716: PPUSH
8717: LD_INT 26
8719: PUSH
8720: LD_INT 1
8722: PUSH
8723: EMPTY
8724: LIST
8725: LIST
8726: PPUSH
8727: CALL_OW 72
8731: PUSH
8732: LD_EXP 37
8736: PUSH
8737: LD_EXP 38
8741: PUSH
8742: LD_EXP 47
8746: PUSH
8747: LD_EXP 50
8751: PUSH
8752: EMPTY
8753: LIST
8754: LIST
8755: LIST
8756: LIST
8757: DIFF
8758: PPUSH
8759: LD_STRING D8b-Sol2-1
8761: PPUSH
8762: CALL 625 0 2
8766: ST_TO_ADDR
// DialogueOff ;
8767: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8771: LD_EXP 38
8775: PUSH
8776: LD_EXP 38
8780: PUSH
8781: LD_EXP 4
8785: IN
8786: AND
8787: IFFALSE 8812
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8789: LD_ADDR_VAR 0 6
8793: PUSH
8794: LD_VAR 0 6
8798: PPUSH
8799: LD_INT 1
8801: PPUSH
8802: LD_EXP 38
8806: PPUSH
8807: CALL_OW 2
8811: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8812: LD_EXP 37
8816: PUSH
8817: LD_EXP 37
8821: PUSH
8822: LD_EXP 4
8826: IN
8827: AND
8828: IFFALSE 8853
// tmp := Insert ( tmp , 1 , Bobby ) ;
8830: LD_ADDR_VAR 0 6
8834: PUSH
8835: LD_VAR 0 6
8839: PPUSH
8840: LD_INT 1
8842: PPUSH
8843: LD_EXP 37
8847: PPUSH
8848: CALL_OW 2
8852: ST_TO_ADDR
// if sol then
8853: LD_VAR 0 5
8857: IFFALSE 8882
// tmp := Insert ( tmp , 1 , sol ) ;
8859: LD_ADDR_VAR 0 6
8863: PUSH
8864: LD_VAR 0 6
8868: PPUSH
8869: LD_INT 1
8871: PPUSH
8872: LD_VAR 0 5
8876: PPUSH
8877: CALL_OW 2
8881: ST_TO_ADDR
// if tmp then
8882: LD_VAR 0 6
8886: IFFALSE 9046
// begin SetSide ( tmp , 8 ) ;
8888: LD_VAR 0 6
8892: PPUSH
8893: LD_INT 8
8895: PPUSH
8896: CALL_OW 235
// ComFree ( tmp ) ;
8900: LD_VAR 0 6
8904: PPUSH
8905: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8909: LD_VAR 0 6
8913: PPUSH
8914: LD_INT 15
8916: PPUSH
8917: CALL_OW 173
// AddComHold ( tmp ) ;
8921: LD_VAR 0 6
8925: PPUSH
8926: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8930: LD_INT 35
8932: PPUSH
8933: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
8937: LD_VAR 0 6
8941: PUSH
8942: LD_INT 1
8944: ARRAY
8945: PPUSH
8946: CALL_OW 314
8950: NOT
8951: IFFALSE 8965
// ComMoveToArea ( tmp , cyrusEscape ) ;
8953: LD_VAR 0 6
8957: PPUSH
8958: LD_INT 15
8960: PPUSH
8961: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8965: LD_VAR 0 6
8969: PUSH
8970: LD_INT 1
8972: ARRAY
8973: PPUSH
8974: LD_INT 15
8976: PPUSH
8977: CALL_OW 308
8981: IFFALSE 9036
// begin RemoveUnit ( tmp [ 1 ] ) ;
8983: LD_VAR 0 6
8987: PUSH
8988: LD_INT 1
8990: ARRAY
8991: PPUSH
8992: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
8996: LD_ADDR_EXP 4
9000: PUSH
9001: LD_EXP 4
9005: PUSH
9006: LD_VAR 0 6
9010: PUSH
9011: LD_INT 1
9013: ARRAY
9014: DIFF
9015: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
9016: LD_ADDR_VAR 0 6
9020: PUSH
9021: LD_VAR 0 6
9025: PUSH
9026: LD_VAR 0 6
9030: PUSH
9031: LD_INT 1
9033: ARRAY
9034: DIFF
9035: ST_TO_ADDR
// end ; until tmp = 0 ;
9036: LD_VAR 0 6
9040: PUSH
9041: LD_INT 0
9043: EQUAL
9044: IFFALSE 8930
// end ; Wait ( 0 0$30 ) ;
9046: LD_INT 1050
9048: PPUSH
9049: CALL_OW 67
// if ru_spec_patrol then
9053: LD_EXP 53
9057: IFFALSE 9085
// for i in ru_spec_patrol do
9059: LD_ADDR_VAR 0 7
9063: PUSH
9064: LD_EXP 53
9068: PUSH
9069: FOR_IN
9070: IFFALSE 9083
// RemoveUnit ( i ) ;
9072: LD_VAR 0 7
9076: PPUSH
9077: CALL_OW 64
9081: GO 9069
9083: POP
9084: POP
// end else
9085: GO 9107
// begin prepare_siege := false ;
9087: LD_ADDR_EXP 30
9091: PUSH
9092: LD_INT 0
9094: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
9095: LD_EXP 36
9099: PPUSH
9100: LD_STRING D8a-JMM-1
9102: PPUSH
9103: CALL_OW 88
// end ; end ;
9107: PPOPN 7
9109: END
// every 0 0$10 trigger frank_can_return do var i , p , points ;
9110: LD_EXP 12
9114: IFFALSE 10313
9116: GO 9118
9118: DISABLE
9119: LD_INT 0
9121: PPUSH
9122: PPUSH
9123: PPUSH
// begin uc_side := 8 ;
9124: LD_ADDR_OWVAR 20
9128: PUSH
9129: LD_INT 8
9131: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
9132: LD_ADDR_VAR 0 3
9136: PUSH
9137: LD_INT 59
9139: PUSH
9140: LD_INT 71
9142: PUSH
9143: EMPTY
9144: LIST
9145: LIST
9146: PUSH
9147: LD_INT 122
9149: PUSH
9150: LD_INT 117
9152: PUSH
9153: EMPTY
9154: LIST
9155: LIST
9156: PUSH
9157: EMPTY
9158: LIST
9159: LIST
9160: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9161: LD_ADDR_EXP 50
9165: PUSH
9166: LD_STRING Frank
9168: PPUSH
9169: LD_INT 0
9171: PPUSH
9172: CALL 474 0 2
9176: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9177: LD_ADDR_VAR 0 1
9181: PUSH
9182: LD_INT 1
9184: PPUSH
9185: LD_INT 2
9187: PPUSH
9188: CALL_OW 12
9192: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9193: LD_EXP 50
9197: PPUSH
9198: LD_VAR 0 3
9202: PUSH
9203: LD_VAR 0 1
9207: ARRAY
9208: PUSH
9209: LD_INT 1
9211: ARRAY
9212: PPUSH
9213: LD_VAR 0 3
9217: PUSH
9218: LD_VAR 0 1
9222: ARRAY
9223: PUSH
9224: LD_INT 2
9226: ARRAY
9227: PPUSH
9228: LD_INT 0
9230: PPUSH
9231: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9235: LD_EXP 50
9239: PPUSH
9240: LD_INT 1
9242: PPUSH
9243: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9247: LD_INT 35
9249: PPUSH
9250: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
9254: LD_EXP 50
9258: PPUSH
9259: LD_EXP 36
9263: PPUSH
9264: CALL_OW 296
9268: PUSH
9269: LD_INT 8
9271: LESS
9272: IFFALSE 9247
// InGameOn ;
9274: CALL_OW 8
// CenterOnUnits ( JMM ) ;
9278: LD_EXP 36
9282: PPUSH
9283: CALL_OW 85
// if IsInUnit ( JMM ) then
9287: LD_EXP 36
9291: PPUSH
9292: CALL_OW 310
9296: IFFALSE 9307
// ComFree ( JMM ) ;
9298: LD_EXP 36
9302: PPUSH
9303: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9307: LD_EXP 36
9311: PPUSH
9312: LD_EXP 50
9316: PPUSH
9317: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9321: LD_EXP 50
9325: PPUSH
9326: LD_EXP 36
9330: PPUSH
9331: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9335: LD_EXP 36
9339: PPUSH
9340: LD_STRING D6-JMM-1
9342: PPUSH
9343: CALL_OW 88
// p := 0 ;
9347: LD_ADDR_VAR 0 2
9351: PUSH
9352: LD_INT 0
9354: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9355: LD_INT 35
9357: PPUSH
9358: CALL_OW 67
// p := p + 1 ;
9362: LD_ADDR_VAR 0 2
9366: PUSH
9367: LD_VAR 0 2
9371: PUSH
9372: LD_INT 1
9374: PLUS
9375: ST_TO_ADDR
// until GetDistUnits ( JMM , Frank ) < 8 or p > 7 ;
9376: LD_EXP 36
9380: PPUSH
9381: LD_EXP 50
9385: PPUSH
9386: CALL_OW 296
9390: PUSH
9391: LD_INT 8
9393: LESS
9394: PUSH
9395: LD_VAR 0 2
9399: PUSH
9400: LD_INT 7
9402: GREATER
9403: OR
9404: IFFALSE 9355
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9406: LD_EXP 39
9410: PUSH
9411: LD_EXP 39
9415: PPUSH
9416: LD_EXP 50
9420: PPUSH
9421: CALL_OW 296
9425: PUSH
9426: LD_INT 20
9428: LESS
9429: AND
9430: IFFALSE 9455
// begin ComFree ( Lisa ) ;
9432: LD_EXP 39
9436: PPUSH
9437: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9441: LD_EXP 39
9445: PPUSH
9446: LD_EXP 50
9450: PPUSH
9451: CALL_OW 172
// end ; if Lynch then
9455: LD_EXP 46
9459: IFFALSE 9484
// begin ComFree ( Lynch ) ;
9461: LD_EXP 46
9465: PPUSH
9466: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9470: LD_EXP 46
9474: PPUSH
9475: LD_EXP 50
9479: PPUSH
9480: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9484: LD_EXP 36
9488: PPUSH
9489: LD_EXP 50
9493: PPUSH
9494: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9498: LD_EXP 50
9502: PPUSH
9503: LD_EXP 36
9507: PPUSH
9508: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9512: LD_EXP 50
9516: PPUSH
9517: LD_STRING D6-Frank-1
9519: PPUSH
9520: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9524: LD_INT 69
9526: PPUSH
9527: LD_INT 20
9529: PPUSH
9530: LD_INT 1
9532: PPUSH
9533: LD_INT 20
9535: NEG
9536: PPUSH
9537: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9541: LD_INT 69
9543: PPUSH
9544: LD_INT 20
9546: PPUSH
9547: LD_INT 1
9549: PPUSH
9550: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9554: LD_INT 190
9556: PPUSH
9557: LD_INT 31
9559: PPUSH
9560: LD_INT 1
9562: PPUSH
9563: LD_INT 20
9565: NEG
9566: PPUSH
9567: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9571: LD_INT 190
9573: PPUSH
9574: LD_INT 31
9576: PPUSH
9577: LD_INT 1
9579: PPUSH
9580: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9584: LD_INT 69
9586: PPUSH
9587: LD_INT 20
9589: PPUSH
9590: CALL_OW 84
// Wait ( 0 0$02 ) ;
9594: LD_INT 70
9596: PPUSH
9597: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9601: LD_EXP 36
9605: PPUSH
9606: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9610: LD_EXP 39
9614: PUSH
9615: LD_EXP 39
9619: PPUSH
9620: LD_EXP 50
9624: PPUSH
9625: CALL_OW 296
9629: PUSH
9630: LD_INT 20
9632: LESS
9633: AND
9634: PUSH
9635: LD_EXP 39
9639: PPUSH
9640: CALL_OW 302
9644: AND
9645: IFFALSE 9767
// begin ComFree ( Lisa ) ;
9647: LD_EXP 39
9651: PPUSH
9652: CALL_OW 139
// p := 0 ;
9656: LD_ADDR_VAR 0 2
9660: PUSH
9661: LD_INT 0
9663: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9664: LD_INT 35
9666: PPUSH
9667: CALL_OW 67
// p := p + 1 ;
9671: LD_ADDR_VAR 0 2
9675: PUSH
9676: LD_VAR 0 2
9680: PUSH
9681: LD_INT 1
9683: PLUS
9684: ST_TO_ADDR
// until GetDistUnits ( Lisa , Frank ) < 7 or p > 7 ;
9685: LD_EXP 39
9689: PPUSH
9690: LD_EXP 50
9694: PPUSH
9695: CALL_OW 296
9699: PUSH
9700: LD_INT 7
9702: LESS
9703: PUSH
9704: LD_VAR 0 2
9708: PUSH
9709: LD_INT 7
9711: GREATER
9712: OR
9713: IFFALSE 9664
// Say ( Lisa , D6-Lisa-1 ) ;
9715: LD_EXP 39
9719: PPUSH
9720: LD_STRING D6-Lisa-1
9722: PPUSH
9723: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9727: LD_EXP 39
9731: PPUSH
9732: LD_EXP 50
9736: PPUSH
9737: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9741: LD_EXP 50
9745: PPUSH
9746: LD_EXP 39
9750: PPUSH
9751: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9755: LD_EXP 50
9759: PPUSH
9760: LD_STRING D6-Frank-2
9762: PPUSH
9763: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9767: LD_EXP 46
9771: PUSH
9772: LD_EXP 46
9776: PPUSH
9777: LD_EXP 50
9781: PPUSH
9782: CALL_OW 296
9786: PUSH
9787: LD_INT 20
9789: LESS
9790: AND
9791: PUSH
9792: LD_EXP 46
9796: PPUSH
9797: CALL_OW 302
9801: AND
9802: IFFALSE 9983
// begin ComTurnUnit ( Lynch , JMM ) ;
9804: LD_EXP 46
9808: PPUSH
9809: LD_EXP 36
9813: PPUSH
9814: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9818: LD_EXP 50
9822: PPUSH
9823: LD_EXP 36
9827: PPUSH
9828: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9832: LD_EXP 46
9836: PPUSH
9837: LD_STRING D6-Sol1-2
9839: PPUSH
9840: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9844: LD_EXP 36
9848: PPUSH
9849: LD_STRING D6-JMM-2
9851: PPUSH
9852: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9856: LD_EXP 50
9860: PPUSH
9861: LD_STRING D6-Frank-3
9863: PPUSH
9864: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9868: LD_EXP 36
9872: PPUSH
9873: LD_STRING D6-JMM-3
9875: PPUSH
9876: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9880: LD_EXP 50
9884: PPUSH
9885: LD_STRING D6-Frank-4
9887: PPUSH
9888: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9892: LD_EXP 50
9896: PPUSH
9897: LD_STRING D6-Frank-4a
9899: PPUSH
9900: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9904: LD_EXP 36
9908: PPUSH
9909: LD_STRING D6-JMM-4
9911: PPUSH
9912: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9916: LD_EXP 50
9920: PPUSH
9921: LD_STRING D6-Frank-5
9923: PPUSH
9924: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9928: LD_EXP 39
9932: PUSH
9933: LD_EXP 39
9937: PPUSH
9938: CALL_OW 302
9942: AND
9943: IFFALSE 9957
// Say ( Lisa , D6-Lisa-5 ) ;
9945: LD_EXP 39
9949: PPUSH
9950: LD_STRING D6-Lisa-5
9952: PPUSH
9953: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9957: LD_EXP 50
9961: PPUSH
9962: LD_STRING D6-Frank-6
9964: PPUSH
9965: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9969: LD_EXP 36
9973: PPUSH
9974: LD_STRING D6-JMM-6
9976: PPUSH
9977: CALL_OW 88
// end else
9981: GO 10098
// begin ComTurnUnit ( Frank , JMM ) ;
9983: LD_EXP 50
9987: PPUSH
9988: LD_EXP 36
9992: PPUSH
9993: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
9997: LD_EXP 50
10001: PPUSH
10002: LD_STRING D6-Frank-4
10004: PPUSH
10005: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10009: LD_EXP 50
10013: PPUSH
10014: LD_STRING D6-Frank-4a
10016: PPUSH
10017: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10021: LD_EXP 36
10025: PPUSH
10026: LD_STRING D6-JMM-4
10028: PPUSH
10029: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10033: LD_EXP 50
10037: PPUSH
10038: LD_STRING D6-Frank-5
10040: PPUSH
10041: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10045: LD_EXP 39
10049: PUSH
10050: LD_EXP 39
10054: PPUSH
10055: CALL_OW 302
10059: AND
10060: IFFALSE 10074
// Say ( Lisa , D6-Lisa-5 ) ;
10062: LD_EXP 39
10066: PPUSH
10067: LD_STRING D6-Lisa-5
10069: PPUSH
10070: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10074: LD_EXP 50
10078: PPUSH
10079: LD_STRING D6-Frank-6
10081: PPUSH
10082: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10086: LD_EXP 36
10090: PPUSH
10091: LD_STRING D6-JMM-6
10093: PPUSH
10094: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
10098: LD_STRING Q1
10100: PPUSH
10101: CALL_OW 97
10105: PUSH
10106: LD_INT 1
10108: DOUBLE
10109: EQUAL
10110: IFTRUE 10114
10112: GO 10125
10114: POP
// frank_send_to_scout := true ; 2 :
10115: LD_ADDR_EXP 14
10119: PUSH
10120: LD_INT 1
10122: ST_TO_ADDR
10123: GO 10145
10125: LD_INT 2
10127: DOUBLE
10128: EQUAL
10129: IFTRUE 10133
10131: GO 10144
10133: POP
// frank_send_to_scout := false ; end ;
10134: LD_ADDR_EXP 14
10138: PUSH
10139: LD_INT 0
10141: ST_TO_ADDR
10142: GO 10145
10144: POP
// InGameOff ;
10145: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
10149: LD_EXP 36
10153: PUSH
10154: LD_EXP 39
10158: PUSH
10159: LD_EXP 46
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: LIST
10168: PPUSH
10169: CALL_OW 139
// if frank_send_to_scout then
10173: LD_EXP 14
10177: IFFALSE 10234
// begin ComMoveXY ( Frank , 130 , 123 ) ;
10179: LD_EXP 50
10183: PPUSH
10184: LD_INT 130
10186: PPUSH
10187: LD_INT 123
10189: PPUSH
10190: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
10194: LD_INT 35
10196: PPUSH
10197: CALL_OW 67
// until not See ( 1 , Frank ) ;
10201: LD_INT 1
10203: PPUSH
10204: LD_EXP 50
10208: PPUSH
10209: CALL_OW 292
10213: NOT
10214: IFFALSE 10194
// Wait ( 0 0$02 ) ;
10216: LD_INT 70
10218: PPUSH
10219: CALL_OW 67
// RemoveUnit ( Frank ) ;
10223: LD_EXP 50
10227: PPUSH
10228: CALL_OW 64
// end else
10232: GO 10246
// SetSide ( Frank , 1 ) ;
10234: LD_EXP 50
10238: PPUSH
10239: LD_INT 1
10241: PPUSH
10242: CALL_OW 235
// send_attack_on_cornel_base := true ;
10246: LD_ADDR_EXP 25
10250: PUSH
10251: LD_INT 1
10253: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10254: LD_INT 35
10256: PPUSH
10257: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10261: LD_ADDR_EXP 28
10265: PUSH
10266: LD_EXP 28
10270: PPUSH
10271: LD_STRING -
10273: PPUSH
10274: CALL 1117 0 2
10278: ST_TO_ADDR
// if debug then
10279: LD_EXP 1
10283: IFFALSE 10295
// debug_strings := time_to_prepare ;
10285: LD_ADDR_OWVAR 48
10289: PUSH
10290: LD_EXP 28
10294: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10295: LD_EXP 28
10299: PUSH
10300: LD_INT 0
10302: EQUAL
10303: IFFALSE 10254
// cornel_prepared := true ;
10305: LD_ADDR_EXP 11
10309: PUSH
10310: LD_INT 1
10312: ST_TO_ADDR
// end ;
10313: PPOPN 3
10315: END
// every 0 0$01 trigger cornel_prepared do
10316: LD_EXP 11
10320: IFFALSE 10584
10322: GO 10324
10324: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10325: LD_EXP 43
10329: PPUSH
10330: LD_STRING D3-Corn-1
10332: PPUSH
10333: CALL_OW 94
// ChangeMissionObjectives ( MOutWait ) ;
10337: LD_STRING MOutWait
10339: PPUSH
10340: CALL_OW 337
// repeat wait ( 0 0$01 ) ;
10344: LD_INT 35
10346: PPUSH
10347: CALL_OW 67
// until cornel_counter = 0 ;
10351: LD_EXP 10
10355: PUSH
10356: LD_INT 0
10358: EQUAL
10359: IFFALSE 10344
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10361: LD_EXP 43
10365: PPUSH
10366: LD_STRING D3a-Corn-1
10368: PPUSH
10369: CALL_OW 94
// if IsOk ( Cornel ) then
10373: LD_EXP 43
10377: PPUSH
10378: CALL_OW 302
10382: IFFALSE 10396
// Say ( JMM , D3a-JMM-1 ) ;
10384: LD_EXP 36
10388: PPUSH
10389: LD_STRING D3a-JMM-1
10391: PPUSH
10392: CALL_OW 88
// end_mission_allowed := true ;
10396: LD_ADDR_EXP 20
10400: PUSH
10401: LD_INT 1
10403: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10404: LD_STRING M2
10406: PPUSH
10407: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10411: LD_INT 9
10413: PPUSH
10414: LD_INT 1
10416: PPUSH
10417: CALL_OW 424
// Wait ( 0 0$05 ) ;
10421: LD_INT 175
10423: PPUSH
10424: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10428: LD_EXP 43
10432: PPUSH
10433: LD_STRING D3a-Corn-2
10435: PPUSH
10436: CALL_OW 94
// cornel_attack := true ;
10440: LD_ADDR_EXP 9
10444: PUSH
10445: LD_INT 1
10447: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10448: LD_INT 105
10450: PPUSH
10451: CALL_OW 67
// AddMoreTanks ( ) ;
10455: CALL 4834 0 0
// if frank_send_to_scout then
10459: LD_EXP 14
10463: IFFALSE 10584
// begin InitHc ;
10465: CALL_OW 19
// InitUc ;
10469: CALL_OW 18
// uc_side := 8 ;
10473: LD_ADDR_OWVAR 20
10477: PUSH
10478: LD_INT 8
10480: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10481: LD_ADDR_EXP 50
10485: PUSH
10486: LD_STRING Frank
10488: PPUSH
10489: LD_INT 0
10491: PPUSH
10492: CALL 474 0 2
10496: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10497: LD_EXP 50
10501: PPUSH
10502: LD_INT 6
10504: PPUSH
10505: LD_INT 9
10507: PPUSH
10508: LD_INT 0
10510: PPUSH
10511: CALL_OW 48
// ComCrawl ( Frank ) ;
10515: LD_EXP 50
10519: PPUSH
10520: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
10524: LD_INT 35
10526: PPUSH
10527: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
10531: LD_EXP 36
10535: PPUSH
10536: LD_EXP 50
10540: PPUSH
10541: CALL_OW 296
10545: PUSH
10546: LD_INT 9
10548: LESS
10549: IFFALSE 10524
// SetSide ( Frank , 1 ) ;
10551: LD_EXP 50
10555: PPUSH
10556: LD_INT 1
10558: PPUSH
10559: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10563: LD_EXP 50
10567: PPUSH
10568: LD_STRING D6a-Frank-1
10570: PPUSH
10571: CALL_OW 88
// ComWalk ( Frank ) ;
10575: LD_EXP 50
10579: PPUSH
10580: CALL_OW 138
// end ; end ;
10584: END
// every 0 0$01 trigger solar_builded do
10585: LD_EXP 13
10589: IFFALSE 10693
10591: GO 10593
10593: DISABLE
// begin Wait ( 0 0$02 ) ;
10594: LD_INT 70
10596: PPUSH
10597: CALL_OW 67
// DialogueOn ;
10601: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10605: LD_EXP 36
10609: PPUSH
10610: LD_STRING D2b-JMM-1
10612: PPUSH
10613: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10617: LD_EXP 47
10621: PUSH
10622: LD_EXP 47
10626: PPUSH
10627: CALL_OW 302
10631: AND
10632: IFFALSE 10682
// begin Say ( Walker , D2b-Sci1-1 ) ;
10634: LD_EXP 47
10638: PPUSH
10639: LD_STRING D2b-Sci1-1
10641: PPUSH
10642: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10646: LD_EXP 36
10650: PPUSH
10651: LD_STRING D2b-JMM-2
10653: PPUSH
10654: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10658: LD_EXP 47
10662: PPUSH
10663: LD_STRING D2b-Sci1-2
10665: PPUSH
10666: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10670: LD_EXP 36
10674: PPUSH
10675: LD_STRING D2b-JMM-3
10677: PPUSH
10678: CALL_OW 88
// end ; DialogueOff ;
10682: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10686: LD_STRING MOutSol
10688: PPUSH
10689: CALL_OW 337
// end ;
10693: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10694: LD_EXP 13
10698: PUSH
10699: LD_EXP 36
10703: PPUSH
10704: CALL_OW 302
10708: AND
10709: PUSH
10710: LD_EXP 36
10714: PPUSH
10715: CALL 951 0 1
10719: AND
10720: PUSH
10721: LD_EXP 15
10725: NOT
10726: AND
10727: IFFALSE 10798
10729: GO 10731
10731: DISABLE
10732: LD_INT 0
10734: PPUSH
// begin jmm_in_veh := true ;
10735: LD_ADDR_EXP 15
10739: PUSH
10740: LD_INT 1
10742: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10743: LD_ADDR_VAR 0 1
10747: PUSH
10748: LD_INT 0
10750: PPUSH
10751: LD_INT 1
10753: PPUSH
10754: CALL_OW 12
10758: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10759: LD_INT 70
10761: PPUSH
10762: CALL_OW 67
// if i then
10766: LD_VAR 0 1
10770: IFFALSE 10786
// Say ( JMM , D2c-JMM-1 ) else
10772: LD_EXP 36
10776: PPUSH
10777: LD_STRING D2c-JMM-1
10779: PPUSH
10780: CALL_OW 88
10784: GO 10798
// Say ( JMM , D2c-JMM-1a ) ;
10786: LD_EXP 36
10790: PPUSH
10791: LD_STRING D2c-JMM-1a
10793: PPUSH
10794: CALL_OW 88
// end ;
10798: PPOPN 1
10800: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10801: LD_EXP 13
10805: PUSH
10806: LD_EXP 37
10810: PPUSH
10811: CALL_OW 302
10815: AND
10816: PUSH
10817: LD_EXP 37
10821: PPUSH
10822: CALL 951 0 1
10826: AND
10827: PUSH
10828: LD_EXP 16
10832: NOT
10833: AND
10834: IFFALSE 10866
10836: GO 10838
10838: DISABLE
// begin bobby_in_veh := true ;
10839: LD_ADDR_EXP 16
10843: PUSH
10844: LD_INT 1
10846: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10847: LD_INT 70
10849: PPUSH
10850: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10854: LD_EXP 37
10858: PPUSH
10859: LD_STRING D2c-Bobby-1
10861: PPUSH
10862: CALL_OW 88
10866: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10867: LD_EXP 13
10871: PUSH
10872: LD_EXP 39
10876: PPUSH
10877: CALL_OW 302
10881: AND
10882: PUSH
10883: LD_EXP 39
10887: PPUSH
10888: CALL 951 0 1
10892: AND
10893: PUSH
10894: LD_EXP 18
10898: NOT
10899: AND
10900: IFFALSE 10932
10902: GO 10904
10904: DISABLE
// begin lisa_in_veh := true ;
10905: LD_ADDR_EXP 18
10909: PUSH
10910: LD_INT 1
10912: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10913: LD_INT 70
10915: PPUSH
10916: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10920: LD_EXP 39
10924: PPUSH
10925: LD_STRING D2c-Lisa-1
10927: PPUSH
10928: CALL_OW 88
10932: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
10933: LD_EXP 13
10937: PUSH
10938: LD_EXP 38
10942: PPUSH
10943: CALL_OW 302
10947: AND
10948: PUSH
10949: LD_EXP 38
10953: PPUSH
10954: CALL 951 0 1
10958: AND
10959: PUSH
10960: LD_EXP 17
10964: NOT
10965: AND
10966: IFFALSE 11037
10968: GO 10970
10970: DISABLE
10971: LD_INT 0
10973: PPUSH
// begin cyrus_in_veh := true ;
10974: LD_ADDR_EXP 17
10978: PUSH
10979: LD_INT 1
10981: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10982: LD_ADDR_VAR 0 1
10986: PUSH
10987: LD_INT 0
10989: PPUSH
10990: LD_INT 1
10992: PPUSH
10993: CALL_OW 12
10997: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10998: LD_INT 70
11000: PPUSH
11001: CALL_OW 67
// if i then
11005: LD_VAR 0 1
11009: IFFALSE 11025
// Say ( Cyrus , D2c-Cyrus-1 ) else
11011: LD_EXP 38
11015: PPUSH
11016: LD_STRING D2c-Cyrus-1
11018: PPUSH
11019: CALL_OW 88
11023: GO 11037
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11025: LD_EXP 38
11029: PPUSH
11030: LD_STRING D2c-Cyrus-1a
11032: PPUSH
11033: CALL_OW 88
// end ;
11037: PPOPN 1
11039: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
11040: LD_EXP 43
11044: PPUSH
11045: LD_INT 16
11047: PPUSH
11048: CALL_OW 308
11052: IFFALSE 11333
11054: GO 11056
11056: DISABLE
11057: LD_INT 0
11059: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
11060: LD_INT 3
11062: PPUSH
11063: LD_EXP 43
11067: PPUSH
11068: CALL_OW 471
// send_attack_on_cornel := true ;
11072: LD_ADDR_EXP 31
11076: PUSH
11077: LD_INT 1
11079: ST_TO_ADDR
// if ru_vehicles then
11080: LD_EXP 55
11084: IFFALSE 11118
// for i in ru_vehicles do
11086: LD_ADDR_VAR 0 1
11090: PUSH
11091: LD_EXP 55
11095: PUSH
11096: FOR_IN
11097: IFFALSE 11116
// ComAgressiveMove ( i , 215 , 69 ) ;
11099: LD_VAR 0 1
11103: PPUSH
11104: LD_INT 215
11106: PPUSH
11107: LD_INT 69
11109: PPUSH
11110: CALL_OW 114
11114: GO 11096
11116: POP
11117: POP
// if ru_patrol then
11118: LD_EXP 52
11122: IFFALSE 11156
// for i in ru_patrol do
11124: LD_ADDR_VAR 0 1
11128: PUSH
11129: LD_EXP 52
11133: PUSH
11134: FOR_IN
11135: IFFALSE 11154
// ComAgressiveMove ( i , 215 , 69 ) ;
11137: LD_VAR 0 1
11141: PPUSH
11142: LD_INT 215
11144: PPUSH
11145: LD_INT 69
11147: PPUSH
11148: CALL_OW 114
11152: GO 11134
11154: POP
11155: POP
// if frank_send_to_scout then
11156: LD_EXP 14
11160: IFFALSE 11174
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
11162: LD_EXP 50
11166: PPUSH
11167: LD_STRING D3b-Frank-1
11169: PPUSH
11170: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
11174: LD_INT 105
11176: PPUSH
11177: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
11181: LD_EXP 43
11185: PPUSH
11186: LD_STRING D4-Corn-1
11188: PPUSH
11189: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
11193: LD_INT 35
11195: PPUSH
11196: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) < 6 ;
11200: LD_INT 22
11202: PUSH
11203: LD_INT 4
11205: PUSH
11206: EMPTY
11207: LIST
11208: LIST
11209: PUSH
11210: LD_INT 21
11212: PUSH
11213: LD_INT 1
11215: PUSH
11216: EMPTY
11217: LIST
11218: LIST
11219: PUSH
11220: LD_INT 3
11222: PUSH
11223: LD_INT 24
11225: PUSH
11226: LD_INT 1000
11228: PUSH
11229: EMPTY
11230: LIST
11231: LIST
11232: PUSH
11233: EMPTY
11234: LIST
11235: LIST
11236: PUSH
11237: EMPTY
11238: LIST
11239: LIST
11240: LIST
11241: PPUSH
11242: CALL_OW 69
11246: PUSH
11247: LD_INT 6
11249: LESS
11250: IFFALSE 11193
// if Cornel then
11252: LD_EXP 43
11256: IFFALSE 11296
// begin SayRadio ( Cornel , D5-Corn-1 ) ;
11258: LD_EXP 43
11262: PPUSH
11263: LD_STRING D5-Corn-1
11265: PPUSH
11266: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11270: LD_EXP 43
11274: PPUSH
11275: LD_EXP 2
11279: PUSH
11280: LD_STRING Cornel
11282: STR
11283: PPUSH
11284: CALL_OW 38
// cornel_saved := true ;
11288: LD_ADDR_EXP 26
11292: PUSH
11293: LD_INT 1
11295: ST_TO_ADDR
// end ; ChangeSideFog ( 4 , 8 ) ;
11296: LD_INT 4
11298: PPUSH
11299: LD_INT 8
11301: PPUSH
11302: CALL_OW 343
// Wait ( 0 0$01 ) ;
11306: LD_INT 35
11308: PPUSH
11309: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11313: LD_INT 3
11315: PPUSH
11316: LD_EXP 43
11320: PPUSH
11321: CALL_OW 472
// send_attack_on_cornel := false ;
11325: LD_ADDR_EXP 31
11329: PUSH
11330: LD_INT 0
11332: ST_TO_ADDR
// end ;
11333: PPOPN 1
11335: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11336: LD_INT 9
11338: PPUSH
11339: LD_INT 22
11341: PUSH
11342: LD_INT 1
11344: PUSH
11345: EMPTY
11346: LIST
11347: LIST
11348: PPUSH
11349: CALL_OW 70
11353: PUSH
11354: LD_EXP 32
11358: OR
11359: IFFALSE 11541
11361: GO 11363
11363: DISABLE
11364: LD_INT 0
11366: PPUSH
11367: PPUSH
// begin enable ;
11368: ENABLE
// if not jmm_on_west then
11369: LD_EXP 5
11373: NOT
11374: IFFALSE 11385
// begin YouLost ( 4 ) ;
11376: LD_STRING 4
11378: PPUSH
11379: CALL_OW 104
// exit ;
11383: GO 11541
// end ; if not game_end then
11385: LD_EXP 32
11389: NOT
11390: IFFALSE 11400
// game_end := true ;
11392: LD_ADDR_EXP 32
11396: PUSH
11397: LD_INT 1
11399: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11400: LD_ADDR_VAR 0 2
11404: PUSH
11405: LD_INT 9
11407: PPUSH
11408: LD_INT 22
11410: PUSH
11411: LD_INT 1
11413: PUSH
11414: EMPTY
11415: LIST
11416: LIST
11417: PPUSH
11418: CALL_OW 70
11422: ST_TO_ADDR
// if not filter then
11423: LD_VAR 0 2
11427: NOT
11428: IFFALSE 11432
// exit ;
11430: GO 11541
// for i in filter do
11432: LD_ADDR_VAR 0 1
11436: PUSH
11437: LD_VAR 0 2
11441: PUSH
11442: FOR_IN
11443: IFFALSE 11539
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
11445: LD_VAR 0 1
11449: PPUSH
11450: CALL_OW 302
11454: PUSH
11455: LD_VAR 0 1
11459: PPUSH
11460: CALL_OW 247
11464: PUSH
11465: LD_INT 2
11467: EQUAL
11468: AND
11469: IFFALSE 11502
// begin veh_on_meta := true ;
11471: LD_ADDR_EXP 27
11475: PUSH
11476: LD_INT 1
11478: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11479: LD_VAR 0 1
11483: PPUSH
11484: CALL_OW 311
11488: PPUSH
11489: CALL 11544 0 1
// RemoveUnit ( i ) ;
11493: LD_VAR 0 1
11497: PPUSH
11498: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11502: LD_VAR 0 1
11506: PPUSH
11507: CALL_OW 302
11511: PUSH
11512: LD_VAR 0 1
11516: PPUSH
11517: CALL_OW 247
11521: PUSH
11522: LD_INT 1
11524: EQUAL
11525: AND
11526: IFFALSE 11537
// Save ( i ) ;
11528: LD_VAR 0 1
11532: PPUSH
11533: CALL 11544 0 1
// end ;
11537: GO 11442
11539: POP
11540: POP
// end ;
11541: PPOPN 2
11543: END
// export function Save ( i ) ; begin
11544: LD_INT 0
11546: PPUSH
// save_counter := save_counter + 1 ;
11547: LD_ADDR_EXP 35
11551: PUSH
11552: LD_EXP 35
11556: PUSH
11557: LD_INT 1
11559: PLUS
11560: ST_TO_ADDR
// if i = JMM then
11561: LD_VAR 0 1
11565: PUSH
11566: LD_EXP 36
11570: EQUAL
11571: IFFALSE 11693
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11573: LD_EXP 23
11577: PUSH
11578: LD_INT 22
11580: PUSH
11581: LD_INT 1
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: PUSH
11588: LD_INT 21
11590: PUSH
11591: LD_INT 1
11593: PUSH
11594: EMPTY
11595: LIST
11596: LIST
11597: PUSH
11598: EMPTY
11599: LIST
11600: LIST
11601: PPUSH
11602: CALL_OW 69
11606: PUSH
11607: LD_INT 1
11609: GREATER
11610: AND
11611: IFFALSE 11668
// begin show_query := false ;
11613: LD_ADDR_EXP 23
11617: PUSH
11618: LD_INT 0
11620: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11621: LD_STRING Q2
11623: PPUSH
11624: CALL_OW 97
11628: PUSH
11629: LD_INT 1
11631: DOUBLE
11632: EQUAL
11633: IFTRUE 11637
11635: GO 11648
11637: POP
// wait_for_them := true ; 2 :
11638: LD_ADDR_EXP 24
11642: PUSH
11643: LD_INT 1
11645: ST_TO_ADDR
11646: GO 11668
11648: LD_INT 2
11650: DOUBLE
11651: EQUAL
11652: IFTRUE 11656
11654: GO 11667
11656: POP
// wait_for_them := false ; end ;
11657: LD_ADDR_EXP 24
11661: PUSH
11662: LD_INT 0
11664: ST_TO_ADDR
11665: GO 11668
11667: POP
// end ; save_group := save_group ^ JMM ;
11668: LD_ADDR_EXP 22
11672: PUSH
11673: LD_EXP 22
11677: PUSH
11678: LD_EXP 36
11682: ADD
11683: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11684: LD_EXP 36
11688: PPUSH
11689: CALL_OW 64
// end ; if i = Lisa then
11693: LD_VAR 0 1
11697: PUSH
11698: LD_EXP 39
11702: EQUAL
11703: IFFALSE 11730
// begin save_group := save_group ^ Lisa ;
11705: LD_ADDR_EXP 22
11709: PUSH
11710: LD_EXP 22
11714: PUSH
11715: LD_EXP 39
11719: ADD
11720: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11721: LD_EXP 39
11725: PPUSH
11726: CALL_OW 64
// end ; if i = Bobby then
11730: LD_VAR 0 1
11734: PUSH
11735: LD_EXP 37
11739: EQUAL
11740: IFFALSE 11767
// begin save_group := save_group ^ Bobby ;
11742: LD_ADDR_EXP 22
11746: PUSH
11747: LD_EXP 22
11751: PUSH
11752: LD_EXP 37
11756: ADD
11757: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11758: LD_EXP 37
11762: PPUSH
11763: CALL_OW 64
// end ; if i = Cyrus then
11767: LD_VAR 0 1
11771: PUSH
11772: LD_EXP 38
11776: EQUAL
11777: IFFALSE 11804
// begin save_group := save_group ^ Cyrus ;
11779: LD_ADDR_EXP 22
11783: PUSH
11784: LD_EXP 22
11788: PUSH
11789: LD_EXP 38
11793: ADD
11794: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11795: LD_EXP 38
11799: PPUSH
11800: CALL_OW 64
// end ; if i = Khatam then
11804: LD_VAR 0 1
11808: PUSH
11809: LD_EXP 40
11813: EQUAL
11814: IFFALSE 11841
// begin save_group := save_group ^ Khatam ;
11816: LD_ADDR_EXP 22
11820: PUSH
11821: LD_EXP 22
11825: PUSH
11826: LD_EXP 40
11830: ADD
11831: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11832: LD_EXP 40
11836: PPUSH
11837: CALL_OW 64
// end ; if i = Frank then
11841: LD_VAR 0 1
11845: PUSH
11846: LD_EXP 50
11850: EQUAL
11851: IFFALSE 11878
// begin save_group := save_group ^ Frank ;
11853: LD_ADDR_EXP 22
11857: PUSH
11858: LD_EXP 22
11862: PUSH
11863: LD_EXP 50
11867: ADD
11868: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11869: LD_EXP 50
11873: PPUSH
11874: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11878: LD_VAR 0 1
11882: PPUSH
11883: CALL_OW 302
11887: PUSH
11888: LD_VAR 0 1
11892: PPUSH
11893: CALL_OW 247
11897: PUSH
11898: LD_INT 1
11900: EQUAL
11901: AND
11902: PUSH
11903: LD_VAR 0 1
11907: PUSH
11908: LD_EXP 22
11912: IN
11913: NOT
11914: AND
11915: IFFALSE 11942
// begin save_others := save_others ^ i ;
11917: LD_ADDR_EXP 21
11921: PUSH
11922: LD_EXP 21
11926: PUSH
11927: LD_VAR 0 1
11931: ADD
11932: ST_TO_ADDR
// RemoveUnit ( i ) ;
11933: LD_VAR 0 1
11937: PPUSH
11938: CALL_OW 64
// end ; end ;
11942: LD_VAR 0 2
11946: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
11947: LD_EXP 23
11951: NOT
11952: PUSH
11953: LD_EXP 24
11957: NOT
11958: AND
11959: PUSH
11960: LD_INT 22
11962: PUSH
11963: LD_INT 1
11965: PUSH
11966: EMPTY
11967: LIST
11968: LIST
11969: PUSH
11970: LD_INT 21
11972: PUSH
11973: LD_INT 1
11975: PUSH
11976: EMPTY
11977: LIST
11978: LIST
11979: PUSH
11980: EMPTY
11981: LIST
11982: LIST
11983: PPUSH
11984: CALL_OW 69
11988: PUSH
11989: LD_INT 0
11991: EQUAL
11992: OR
11993: IFFALSE 12002
11995: GO 11997
11997: DISABLE
// EndMission ;
11998: CALL 12003 0 0
12002: END
// export function EndMission ; var i ; begin
12003: LD_INT 0
12005: PPUSH
12006: PPUSH
// Wait ( 0 0$02 ) ;
12007: LD_INT 70
12009: PPUSH
12010: CALL_OW 67
// if solar_builded then
12014: LD_EXP 13
12018: IFFALSE 12032
// AddMedal ( Solar1 , 1 ) else
12020: LD_STRING Solar1
12022: PPUSH
12023: LD_INT 1
12025: PPUSH
12026: CALL_OW 101
12030: GO 12043
// AddMedal ( Solar1 , - 1 ) ;
12032: LD_STRING Solar1
12034: PPUSH
12035: LD_INT 1
12037: NEG
12038: PPUSH
12039: CALL_OW 101
// if veh_on_meta then
12043: LD_EXP 27
12047: IFFALSE 12061
// AddMedal ( Solar2 , 1 ) else
12049: LD_STRING Solar2
12051: PPUSH
12052: LD_INT 1
12054: PPUSH
12055: CALL_OW 101
12059: GO 12091
// if solar_builded then
12061: LD_EXP 13
12065: IFFALSE 12080
// AddMedal ( Solar2 , - 1 ) else
12067: LD_STRING Solar2
12069: PPUSH
12070: LD_INT 1
12072: NEG
12073: PPUSH
12074: CALL_OW 101
12078: GO 12091
// AddMedal ( Solar2 , - 2 ) ;
12080: LD_STRING Solar2
12082: PPUSH
12083: LD_INT 2
12085: NEG
12086: PPUSH
12087: CALL_OW 101
// if lose_counter = 0 then
12091: LD_EXP 33
12095: PUSH
12096: LD_INT 0
12098: EQUAL
12099: IFFALSE 12113
// AddMedal ( No , 1 ) else
12101: LD_STRING No
12103: PPUSH
12104: LD_INT 1
12106: PPUSH
12107: CALL_OW 101
12111: GO 12157
// if lose_counter > 0 and lose_counter < 4 then
12113: LD_EXP 33
12117: PUSH
12118: LD_INT 0
12120: GREATER
12121: PUSH
12122: LD_EXP 33
12126: PUSH
12127: LD_INT 4
12129: LESS
12130: AND
12131: IFFALSE 12146
// AddMedal ( No , - 1 ) else
12133: LD_STRING No
12135: PPUSH
12136: LD_INT 1
12138: NEG
12139: PPUSH
12140: CALL_OW 101
12144: GO 12157
// AddMedal ( UpTo4 , - 1 ) ;
12146: LD_STRING UpTo4
12148: PPUSH
12149: LD_INT 1
12151: NEG
12152: PPUSH
12153: CALL_OW 101
// GiveMedals ( MAIN ) ;
12157: LD_STRING MAIN
12159: PPUSH
12160: CALL_OW 102
// if IsDead ( Pokryshkin ) then
12164: LD_EXP 51
12168: PPUSH
12169: CALL_OW 301
12173: IFFALSE 12213
// for i in save_group ^ save_others do
12175: LD_ADDR_VAR 0 2
12179: PUSH
12180: LD_EXP 22
12184: PUSH
12185: LD_EXP 21
12189: ADD
12190: PUSH
12191: FOR_IN
12192: IFFALSE 12211
// AddExperience ( i , skill_combat , 1500 ) ;
12194: LD_VAR 0 2
12198: PPUSH
12199: LD_INT 1
12201: PPUSH
12202: LD_INT 1500
12204: PPUSH
12205: CALL_OW 492
12209: GO 12191
12211: POP
12212: POP
// RewardPeople ( save_group ^ save_others ) ;
12213: LD_EXP 22
12217: PUSH
12218: LD_EXP 21
12222: ADD
12223: PPUSH
12224: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
12228: LD_EXP 36
12232: PPUSH
12233: LD_EXP 2
12237: PUSH
12238: LD_STRING JMM
12240: STR
12241: PPUSH
12242: CALL_OW 38
// if Bobby in save_group then
12246: LD_EXP 37
12250: PUSH
12251: LD_EXP 22
12255: IN
12256: IFFALSE 12276
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12258: LD_EXP 37
12262: PPUSH
12263: LD_EXP 2
12267: PUSH
12268: LD_STRING Bobby
12270: STR
12271: PPUSH
12272: CALL_OW 38
// if Cyrus in save_group then
12276: LD_EXP 38
12280: PUSH
12281: LD_EXP 22
12285: IN
12286: IFFALSE 12306
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12288: LD_EXP 38
12292: PPUSH
12293: LD_EXP 2
12297: PUSH
12298: LD_STRING Cyrus
12300: STR
12301: PPUSH
12302: CALL_OW 38
// if Lisa in save_group then
12306: LD_EXP 39
12310: PUSH
12311: LD_EXP 22
12315: IN
12316: IFFALSE 12336
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12318: LD_EXP 39
12322: PPUSH
12323: LD_EXP 2
12327: PUSH
12328: LD_STRING Lisa
12330: STR
12331: PPUSH
12332: CALL_OW 38
// if Frank in save_group then
12336: LD_EXP 50
12340: PUSH
12341: LD_EXP 22
12345: IN
12346: IFFALSE 12366
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12348: LD_EXP 50
12352: PPUSH
12353: LD_EXP 2
12357: PUSH
12358: LD_STRING Frank
12360: STR
12361: PPUSH
12362: CALL_OW 38
// if Khatam in save_group then
12366: LD_EXP 40
12370: PUSH
12371: LD_EXP 22
12375: IN
12376: IFFALSE 12396
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
12378: LD_EXP 40
12382: PPUSH
12383: LD_EXP 2
12387: PUSH
12388: LD_STRING Khatam
12390: STR
12391: PPUSH
12392: CALL_OW 38
// if save_others then
12396: LD_EXP 21
12400: IFFALSE 12414
// SaveCharacters ( save_others , 03_others ) ;
12402: LD_EXP 21
12406: PPUSH
12407: LD_STRING 03_others
12409: PPUSH
12410: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) and cornel_saved then
12414: LD_EXP 44
12418: PUSH
12419: LD_EXP 44
12423: PPUSH
12424: CALL_OW 302
12428: AND
12429: PUSH
12430: LD_EXP 26
12434: AND
12435: IFFALSE 12447
// begin ResetFog ;
12437: CALL_OW 335
// DisplayEndingScene ;
12441: CALL 12469 0 0
// end else
12445: GO 12460
// DeleteCharacters ( mission_prefix & Cornel ) ;
12447: LD_EXP 2
12451: PUSH
12452: LD_STRING Cornel
12454: STR
12455: PPUSH
12456: CALL_OW 40
// YouWin ;
12460: CALL_OW 103
// end ;
12464: LD_VAR 0 1
12468: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
12469: LD_INT 0
12471: PPUSH
12472: PPUSH
12473: PPUSH
12474: PPUSH
12475: PPUSH
12476: PPUSH
// InGameOn ;
12477: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12481: LD_INT 208
12483: PPUSH
12484: LD_INT 62
12486: PPUSH
12487: LD_INT 1
12489: PPUSH
12490: LD_INT 10
12492: NEG
12493: PPUSH
12494: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
12498: LD_INT 208
12500: PPUSH
12501: LD_INT 62
12503: PPUSH
12504: LD_INT 1
12506: PPUSH
12507: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
12511: LD_ADDR_VAR 0 3
12515: PUSH
12516: LD_INT 22
12518: PUSH
12519: LD_INT 3
12521: PUSH
12522: EMPTY
12523: LIST
12524: LIST
12525: PUSH
12526: LD_INT 2
12528: PUSH
12529: LD_INT 21
12531: PUSH
12532: LD_INT 2
12534: PUSH
12535: EMPTY
12536: LIST
12537: LIST
12538: PUSH
12539: LD_INT 21
12541: PUSH
12542: LD_INT 1
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PUSH
12549: EMPTY
12550: LIST
12551: LIST
12552: LIST
12553: PUSH
12554: EMPTY
12555: LIST
12556: LIST
12557: PPUSH
12558: CALL_OW 69
12562: ST_TO_ADDR
// if filter then
12563: LD_VAR 0 3
12567: IFFALSE 12595
// for i in filter do
12569: LD_ADDR_VAR 0 2
12573: PUSH
12574: LD_VAR 0 3
12578: PUSH
12579: FOR_IN
12580: IFFALSE 12593
// RemoveUnit ( i ) ;
12582: LD_VAR 0 2
12586: PPUSH
12587: CALL_OW 64
12591: GO 12579
12593: POP
12594: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
12595: LD_ADDR_VAR 0 3
12599: PUSH
12600: LD_INT 22
12602: PUSH
12603: LD_INT 4
12605: PUSH
12606: EMPTY
12607: LIST
12608: LIST
12609: PUSH
12610: LD_INT 21
12612: PUSH
12613: LD_INT 1
12615: PUSH
12616: EMPTY
12617: LIST
12618: LIST
12619: PUSH
12620: EMPTY
12621: LIST
12622: LIST
12623: PPUSH
12624: CALL_OW 69
12628: ST_TO_ADDR
// if filter then
12629: LD_VAR 0 3
12633: IFFALSE 12664
// for i in filter do
12635: LD_ADDR_VAR 0 2
12639: PUSH
12640: LD_VAR 0 3
12644: PUSH
12645: FOR_IN
12646: IFFALSE 12662
// SetLives ( i , 0 ) ;
12648: LD_VAR 0 2
12652: PPUSH
12653: LD_INT 0
12655: PPUSH
12656: CALL_OW 234
12660: GO 12645
12662: POP
12663: POP
// uc_side := 4 ;
12664: LD_ADDR_OWVAR 20
12668: PUSH
12669: LD_INT 4
12671: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12672: LD_ADDR_VAR 0 4
12676: PUSH
12677: LD_STRING Cornell
12679: PPUSH
12680: LD_INT 0
12682: PPUSH
12683: CALL 474 0 2
12687: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12688: LD_VAR 0 4
12692: PPUSH
12693: LD_INT 208
12695: PPUSH
12696: LD_INT 62
12698: PPUSH
12699: LD_INT 0
12701: PPUSH
12702: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12706: LD_VAR 0 4
12710: PPUSH
12711: LD_INT 100
12713: PPUSH
12714: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12718: LD_INT 3
12720: PPUSH
12721: LD_VAR 0 4
12725: PPUSH
12726: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12730: LD_INT 4
12732: PPUSH
12733: LD_INT 3
12735: PPUSH
12736: LD_INT 1
12738: PPUSH
12739: LD_INT 1
12741: PPUSH
12742: CALL_OW 80
// uc_side := 3 ;
12746: LD_ADDR_OWVAR 20
12750: PUSH
12751: LD_INT 3
12753: ST_TO_ADDR
// uc_nation := 3 ;
12754: LD_ADDR_OWVAR 21
12758: PUSH
12759: LD_INT 3
12761: ST_TO_ADDR
// InitHc ;
12762: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12766: LD_ADDR_VAR 0 5
12770: PUSH
12771: LD_STRING Mikhail
12773: PPUSH
12774: LD_INT 0
12776: PPUSH
12777: CALL 474 0 2
12781: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12782: LD_INT 1
12784: PPUSH
12785: LD_INT 1
12787: PPUSH
12788: LD_INT 0
12790: PPUSH
12791: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12795: LD_ADDR_VAR 0 6
12799: PUSH
12800: LD_VAR 0 6
12804: PUSH
12805: CALL_OW 44
12809: ADD
12810: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12811: LD_ADDR_VAR 0 6
12815: PUSH
12816: LD_VAR 0 6
12820: PUSH
12821: CALL_OW 44
12825: ADD
12826: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12827: LD_INT 2
12829: PPUSH
12830: LD_INT 4
12832: PPUSH
12833: LD_INT 0
12835: PPUSH
12836: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12840: LD_ADDR_VAR 0 6
12844: PUSH
12845: LD_VAR 0 6
12849: PUSH
12850: CALL_OW 44
12854: ADD
12855: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12856: LD_VAR 0 5
12860: PPUSH
12861: LD_INT 17
12863: PPUSH
12864: LD_INT 0
12866: PPUSH
12867: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12871: LD_VAR 0 5
12875: PPUSH
12876: LD_INT 210
12878: PPUSH
12879: LD_INT 63
12881: PPUSH
12882: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12886: LD_VAR 0 5
12890: PPUSH
12891: LD_INT 208
12893: PPUSH
12894: LD_INT 62
12896: PPUSH
12897: CALL_OW 178
// for i in fake_russians do
12901: LD_ADDR_VAR 0 2
12905: PUSH
12906: LD_VAR 0 6
12910: PUSH
12911: FOR_IN
12912: IFFALSE 12990
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12914: LD_VAR 0 2
12918: PPUSH
12919: LD_INT 17
12921: PPUSH
12922: LD_INT 0
12924: PPUSH
12925: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
12929: LD_VAR 0 2
12933: PPUSH
12934: LD_INT 215
12936: PPUSH
12937: LD_INT 67
12939: PPUSH
12940: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
12944: LD_VAR 0 2
12948: PPUSH
12949: LD_INT 208
12951: PPUSH
12952: LD_INT 62
12954: PPUSH
12955: CALL_OW 178
// if GetClass ( i ) = 4 then
12959: LD_VAR 0 2
12963: PPUSH
12964: CALL_OW 257
12968: PUSH
12969: LD_INT 4
12971: EQUAL
12972: IFFALSE 12988
// ComHeal ( i , fake_cornel ) ;
12974: LD_VAR 0 2
12978: PPUSH
12979: LD_VAR 0 4
12983: PPUSH
12984: CALL_OW 128
// end ;
12988: GO 12911
12990: POP
12991: POP
// Wait ( 0 0$01 ) ;
12992: LD_INT 35
12994: PPUSH
12995: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
12999: LD_INT 208
13001: PPUSH
13002: LD_INT 62
13004: PPUSH
13005: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
13009: LD_INT 208
13011: PPUSH
13012: LD_INT 62
13014: PPUSH
13015: LD_INT 1
13017: PPUSH
13018: LD_INT 10
13020: NEG
13021: PPUSH
13022: CALL_OW 330
// Wait ( 0 0$15 ) ;
13026: LD_INT 525
13028: PPUSH
13029: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
13033: LD_INT 208
13035: PPUSH
13036: LD_INT 62
13038: PPUSH
13039: LD_INT 1
13041: PPUSH
13042: CALL_OW 331
// ResetFog ;
13046: CALL_OW 335
// InGameOff ;
13050: CALL_OW 9
// end ;
13054: LD_VAR 0 1
13058: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
13059: LD_INT 10
13061: PPUSH
13062: LD_INT 22
13064: PUSH
13065: LD_INT 1
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: PPUSH
13072: CALL_OW 70
13076: PUSH
13077: LD_EXP 43
13081: PPUSH
13082: CALL_OW 302
13086: AND
13087: PUSH
13088: LD_INT 22
13090: PUSH
13091: LD_INT 1
13093: PUSH
13094: EMPTY
13095: LIST
13096: LIST
13097: PPUSH
13098: CALL_OW 69
13102: PPUSH
13103: LD_EXP 43
13107: PPUSH
13108: CALL_OW 74
13112: PPUSH
13113: LD_EXP 43
13117: PPUSH
13118: CALL_OW 296
13122: PUSH
13123: LD_INT 30
13125: LESS
13126: OR
13127: IFFALSE 13178
13129: GO 13131
13131: DISABLE
// begin enable ;
13132: ENABLE
// powell_warn := powell_warn + 1 ;
13133: LD_ADDR_EXP 34
13137: PUSH
13138: LD_EXP 34
13142: PUSH
13143: LD_INT 1
13145: PLUS
13146: ST_TO_ADDR
// if powell_warn = 3 then
13147: LD_EXP 34
13151: PUSH
13152: LD_INT 3
13154: EQUAL
13155: IFFALSE 13166
// begin YouLost ( 5 ) ;
13157: LD_STRING 5
13159: PPUSH
13160: CALL_OW 104
// exit ;
13164: GO 13178
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
13166: LD_EXP 45
13170: PPUSH
13171: LD_STRING DWarn-Pow-1
13173: PPUSH
13174: CALL_OW 94
// end ; end_of_file
13178: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
13179: LD_EXP 8
13183: IFFALSE 14539
13185: GO 13187
13187: DISABLE
13188: LD_INT 0
13190: PPUSH
13191: PPUSH
13192: PPUSH
13193: PPUSH
13194: PPUSH
13195: PPUSH
13196: PPUSH
13197: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
13198: LD_EXP 43
13202: PUSH
13203: LD_EXP 44
13207: ADD
13208: PUSH
13209: LD_EXP 6
13213: ADD
13214: PPUSH
13215: LD_INT 250
13217: PPUSH
13218: LD_INT 120
13220: PPUSH
13221: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff Bierezov ;
13225: LD_ADDR_VAR 0 2
13229: PUSH
13230: LD_EXP 6
13234: PPUSH
13235: LD_INT 25
13237: PUSH
13238: LD_INT 2
13240: PUSH
13241: EMPTY
13242: LIST
13243: LIST
13244: PPUSH
13245: CALL_OW 72
13249: PUSH
13250: LD_EXP 44
13254: DIFF
13255: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) diff has_eng ;
13256: LD_ADDR_VAR 0 3
13260: PUSH
13261: LD_EXP 6
13265: PPUSH
13266: LD_INT 21
13268: PUSH
13269: LD_INT 1
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: PPUSH
13276: CALL_OW 72
13280: PUSH
13281: LD_VAR 0 2
13285: DIFF
13286: ST_TO_ADDR
// if not has_eng then
13287: LD_VAR 0 2
13291: NOT
13292: IFFALSE 13375
// begin uc_side := 4 ;
13294: LD_ADDR_OWVAR 20
13298: PUSH
13299: LD_INT 4
13301: ST_TO_ADDR
// uc_nation := 1 ;
13302: LD_ADDR_OWVAR 21
13306: PUSH
13307: LD_INT 1
13309: ST_TO_ADDR
// bc_type := b_depot ;
13310: LD_ADDR_OWVAR 42
13314: PUSH
13315: LD_INT 0
13317: ST_TO_ADDR
// bc_level := 2 ;
13318: LD_ADDR_OWVAR 43
13322: PUSH
13323: LD_INT 2
13325: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13326: LD_ADDR_VAR 0 4
13330: PUSH
13331: LD_INT 264
13333: PPUSH
13334: LD_INT 120
13336: PPUSH
13337: LD_INT 4
13339: PPUSH
13340: CALL_OW 47
13344: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13345: LD_INT 264
13347: PPUSH
13348: LD_INT 120
13350: PPUSH
13351: LD_INT 4
13353: PPUSH
13354: LD_INT 10
13356: NEG
13357: PPUSH
13358: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13362: LD_INT 264
13364: PPUSH
13365: LD_INT 120
13367: PPUSH
13368: LD_INT 4
13370: PPUSH
13371: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13375: LD_INT 35
13377: PPUSH
13378: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
13382: LD_EXP 43
13386: PPUSH
13387: LD_INT 10
13389: PPUSH
13390: CALL_OW 308
13394: IFFALSE 13375
// if has_eng and not dep then
13396: LD_VAR 0 2
13400: PUSH
13401: LD_VAR 0 4
13405: NOT
13406: AND
13407: IFFALSE 13557
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
13409: LD_VAR 0 2
13413: PPUSH
13414: LD_INT 0
13416: PPUSH
13417: LD_INT 264
13419: PPUSH
13420: LD_INT 120
13422: PPUSH
13423: LD_INT 4
13425: PPUSH
13426: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
13430: LD_INT 35
13432: PPUSH
13433: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
13437: LD_INT 22
13439: PUSH
13440: LD_INT 4
13442: PUSH
13443: EMPTY
13444: LIST
13445: LIST
13446: PUSH
13447: LD_INT 30
13449: PUSH
13450: LD_INT 0
13452: PUSH
13453: EMPTY
13454: LIST
13455: LIST
13456: PUSH
13457: EMPTY
13458: LIST
13459: LIST
13460: PPUSH
13461: CALL_OW 69
13465: IFFALSE 13430
// ComMoveXY ( filter , 264 , 120 ) ;
13467: LD_VAR 0 3
13471: PPUSH
13472: LD_INT 264
13474: PPUSH
13475: LD_INT 120
13477: PPUSH
13478: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
13482: LD_INT 35
13484: PPUSH
13485: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
13489: LD_INT 22
13491: PUSH
13492: LD_INT 4
13494: PUSH
13495: EMPTY
13496: LIST
13497: LIST
13498: PUSH
13499: LD_INT 30
13501: PUSH
13502: LD_INT 0
13504: PUSH
13505: EMPTY
13506: LIST
13507: LIST
13508: PUSH
13509: LD_INT 3
13511: PUSH
13512: LD_INT 57
13514: PUSH
13515: EMPTY
13516: LIST
13517: PUSH
13518: EMPTY
13519: LIST
13520: LIST
13521: PUSH
13522: EMPTY
13523: LIST
13524: LIST
13525: LIST
13526: PPUSH
13527: CALL_OW 69
13531: IFFALSE 13482
// ComMoveXY ( filter , 247 , 113 ) ;
13533: LD_VAR 0 3
13537: PPUSH
13538: LD_INT 247
13540: PPUSH
13541: LD_INT 113
13543: PPUSH
13544: CALL_OW 111
// Wait ( 0 0$2 ) ;
13548: LD_INT 70
13550: PPUSH
13551: CALL_OW 67
// end else
13555: GO 13569
// begin SetSide ( dep , 4 ) ;
13557: LD_VAR 0 4
13561: PPUSH
13562: LD_INT 4
13564: PPUSH
13565: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
13569: LD_ADDR_VAR 0 4
13573: PUSH
13574: LD_INT 22
13576: PUSH
13577: LD_INT 4
13579: PUSH
13580: EMPTY
13581: LIST
13582: LIST
13583: PUSH
13584: LD_INT 30
13586: PUSH
13587: LD_INT 0
13589: PUSH
13590: EMPTY
13591: LIST
13592: LIST
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: PPUSH
13598: CALL_OW 69
13602: PUSH
13603: LD_INT 1
13605: ARRAY
13606: ST_TO_ADDR
// for i = 1 to 2 do
13607: LD_ADDR_VAR 0 1
13611: PUSH
13612: DOUBLE
13613: LD_INT 1
13615: DEC
13616: ST_TO_ADDR
13617: LD_INT 2
13619: PUSH
13620: FOR_TO
13621: IFFALSE 13716
// begin ComEnterUnit ( filter [ 1 ] , dep ) ;
13623: LD_VAR 0 3
13627: PUSH
13628: LD_INT 1
13630: ARRAY
13631: PPUSH
13632: LD_VAR 0 4
13636: PPUSH
13637: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 2 ) ;
13641: LD_VAR 0 3
13645: PUSH
13646: LD_INT 1
13648: ARRAY
13649: PPUSH
13650: LD_INT 2
13652: PPUSH
13653: CALL_OW 183
// AddComExitBuilding ( filter [ 1 ] ) ;
13657: LD_VAR 0 3
13661: PUSH
13662: LD_INT 1
13664: ARRAY
13665: PPUSH
13666: CALL_OW 182
// repeat wait ( 0 0$1 ) ;
13670: LD_INT 35
13672: PPUSH
13673: CALL_OW 67
// until GetClass ( filter [ 1 ] ) = 2 ;
13677: LD_VAR 0 3
13681: PUSH
13682: LD_INT 1
13684: ARRAY
13685: PPUSH
13686: CALL_OW 257
13690: PUSH
13691: LD_INT 2
13693: EQUAL
13694: IFFALSE 13670
// filter := Delete ( filter , 1 ) ;
13696: LD_ADDR_VAR 0 3
13700: PUSH
13701: LD_VAR 0 3
13705: PPUSH
13706: LD_INT 1
13708: PPUSH
13709: CALL_OW 3
13713: ST_TO_ADDR
// end ;
13714: GO 13620
13716: POP
13717: POP
// if IsInUnit ( Cornel ) then
13718: LD_EXP 43
13722: PPUSH
13723: CALL_OW 310
13727: IFFALSE 13805
// begin cargo := IsInUnit ( Cornel ) ;
13729: LD_ADDR_VAR 0 7
13733: PUSH
13734: LD_EXP 43
13738: PPUSH
13739: CALL_OW 310
13743: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13744: LD_VAR 0 7
13748: PPUSH
13749: LD_INT 1
13751: PPUSH
13752: CALL_OW 289
13756: IFFALSE 13767
// ComUnload ( cargo ) ;
13758: LD_VAR 0 7
13762: PPUSH
13763: CALL_OW 159
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13767: LD_EXP 43
13771: PPUSH
13772: LD_INT 235
13774: PPUSH
13775: LD_INT 122
13777: PPUSH
13778: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13782: LD_EXP 43
13786: PPUSH
13787: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13791: LD_EXP 43
13795: PPUSH
13796: LD_VAR 0 4
13800: PPUSH
13801: CALL_OW 180
// end ; ComMoveXY ( Bierezov , 260 , 120 ) ;
13805: LD_EXP 44
13809: PPUSH
13810: LD_INT 260
13812: PPUSH
13813: LD_INT 120
13815: PPUSH
13816: CALL_OW 111
// AddComHold ( Bierezov ) ;
13820: LD_EXP 44
13824: PPUSH
13825: CALL_OW 200
// if Bierezov and dep and not IsInUnit ( Bierezov ) then
13829: LD_EXP 44
13833: PUSH
13834: LD_VAR 0 4
13838: AND
13839: PUSH
13840: LD_EXP 44
13844: PPUSH
13845: CALL_OW 310
13849: NOT
13850: AND
13851: IFFALSE 13867
// AddComEnterUnit ( Bierezov , dep ) ;
13853: LD_EXP 44
13857: PPUSH
13858: LD_VAR 0 4
13862: PPUSH
13863: CALL_OW 180
// has_eng := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) diff Bierezov ;
13867: LD_ADDR_VAR 0 2
13871: PUSH
13872: LD_INT 22
13874: PUSH
13875: LD_INT 4
13877: PUSH
13878: EMPTY
13879: LIST
13880: LIST
13881: PUSH
13882: LD_INT 25
13884: PUSH
13885: LD_INT 2
13887: PUSH
13888: EMPTY
13889: LIST
13890: LIST
13891: PUSH
13892: EMPTY
13893: LIST
13894: LIST
13895: PPUSH
13896: CALL_OW 69
13900: PUSH
13901: LD_EXP 44
13905: DIFF
13906: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13907: LD_INT 35
13909: PPUSH
13910: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13914: LD_ADDR_VAR 0 6
13918: PUSH
13919: LD_INT 10
13921: PPUSH
13922: CALL_OW 435
13926: ST_TO_ADDR
// if crates then
13927: LD_VAR 0 6
13931: IFFALSE 13960
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
13933: LD_VAR 0 2
13937: PPUSH
13938: LD_VAR 0 6
13942: PUSH
13943: LD_INT 1
13945: ARRAY
13946: PPUSH
13947: LD_VAR 0 6
13951: PUSH
13952: LD_INT 2
13954: ARRAY
13955: PPUSH
13956: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
13960: LD_VAR 0 4
13964: PPUSH
13965: CALL_OW 274
13969: PPUSH
13970: LD_INT 1
13972: PPUSH
13973: CALL_OW 275
13977: PUSH
13978: LD_INT 40
13980: GREATEREQUAL
13981: IFFALSE 13907
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
13983: LD_ADDR_VAR 0 5
13987: PUSH
13988: LD_INT 4
13990: PUSH
13991: LD_INT 256
13993: PUSH
13994: LD_INT 111
13996: PUSH
13997: LD_INT 2
13999: PUSH
14000: EMPTY
14001: LIST
14002: LIST
14003: LIST
14004: LIST
14005: PUSH
14006: LD_INT 31
14008: PUSH
14009: LD_INT 243
14011: PUSH
14012: LD_INT 112
14014: PUSH
14015: LD_INT 2
14017: PUSH
14018: EMPTY
14019: LIST
14020: LIST
14021: LIST
14022: LIST
14023: PUSH
14024: EMPTY
14025: LIST
14026: LIST
14027: ST_TO_ADDR
// for i in blist do
14028: LD_ADDR_VAR 0 1
14032: PUSH
14033: LD_VAR 0 5
14037: PUSH
14038: FOR_IN
14039: IFFALSE 14088
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
14041: LD_VAR 0 2
14045: PPUSH
14046: LD_VAR 0 1
14050: PUSH
14051: LD_INT 1
14053: ARRAY
14054: PPUSH
14055: LD_VAR 0 1
14059: PUSH
14060: LD_INT 2
14062: ARRAY
14063: PPUSH
14064: LD_VAR 0 1
14068: PUSH
14069: LD_INT 3
14071: ARRAY
14072: PPUSH
14073: LD_VAR 0 1
14077: PUSH
14078: LD_INT 4
14080: ARRAY
14081: PPUSH
14082: CALL_OW 205
14086: GO 14038
14088: POP
14089: POP
// repeat wait ( 0 0$01 ) ;
14090: LD_INT 35
14092: PPUSH
14093: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
14097: LD_INT 22
14099: PUSH
14100: LD_INT 4
14102: PUSH
14103: EMPTY
14104: LIST
14105: LIST
14106: PUSH
14107: LD_INT 30
14109: PUSH
14110: LD_INT 4
14112: PUSH
14113: EMPTY
14114: LIST
14115: LIST
14116: PUSH
14117: LD_INT 3
14119: PUSH
14120: LD_INT 57
14122: PUSH
14123: EMPTY
14124: LIST
14125: PUSH
14126: EMPTY
14127: LIST
14128: LIST
14129: PUSH
14130: EMPTY
14131: LIST
14132: LIST
14133: LIST
14134: PPUSH
14135: CALL_OW 69
14139: IFFALSE 14090
// AddComEnterUnit ( filter , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14141: LD_VAR 0 3
14145: PPUSH
14146: LD_INT 22
14148: PUSH
14149: LD_INT 4
14151: PUSH
14152: EMPTY
14153: LIST
14154: LIST
14155: PUSH
14156: LD_INT 30
14158: PUSH
14159: LD_INT 4
14161: PUSH
14162: EMPTY
14163: LIST
14164: LIST
14165: PUSH
14166: EMPTY
14167: LIST
14168: LIST
14169: PPUSH
14170: CALL_OW 69
14174: PUSH
14175: LD_INT 1
14177: ARRAY
14178: PPUSH
14179: CALL_OW 180
// AddComChangeProfession ( filter , 1 ) ;
14183: LD_VAR 0 3
14187: PPUSH
14188: LD_INT 1
14190: PPUSH
14191: CALL_OW 183
// repeat wait ( 0 0$01 ) ;
14195: LD_INT 35
14197: PPUSH
14198: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
14202: LD_INT 22
14204: PUSH
14205: LD_INT 4
14207: PUSH
14208: EMPTY
14209: LIST
14210: LIST
14211: PUSH
14212: LD_INT 30
14214: PUSH
14215: LD_INT 31
14217: PUSH
14218: EMPTY
14219: LIST
14220: LIST
14221: PUSH
14222: LD_INT 3
14224: PUSH
14225: LD_INT 57
14227: PUSH
14228: EMPTY
14229: LIST
14230: PUSH
14231: EMPTY
14232: LIST
14233: LIST
14234: PUSH
14235: EMPTY
14236: LIST
14237: LIST
14238: LIST
14239: PPUSH
14240: CALL_OW 69
14244: IFFALSE 14195
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
14246: LD_ADDR_VAR 0 8
14250: PUSH
14251: LD_EXP 6
14255: PPUSH
14256: LD_INT 25
14258: PUSH
14259: LD_INT 1
14261: PUSH
14262: EMPTY
14263: LIST
14264: LIST
14265: PPUSH
14266: CALL_OW 72
14270: ST_TO_ADDR
// ComExitBuilding ( sol [ 1 ] ) ;
14271: LD_VAR 0 8
14275: PUSH
14276: LD_INT 1
14278: ARRAY
14279: PPUSH
14280: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
14284: LD_VAR 0 8
14288: PUSH
14289: LD_INT 1
14291: ARRAY
14292: PPUSH
14293: LD_INT 22
14295: PUSH
14296: LD_INT 4
14298: PUSH
14299: EMPTY
14300: LIST
14301: LIST
14302: PUSH
14303: LD_INT 30
14305: PUSH
14306: LD_INT 31
14308: PUSH
14309: EMPTY
14310: LIST
14311: LIST
14312: PUSH
14313: EMPTY
14314: LIST
14315: LIST
14316: PPUSH
14317: CALL_OW 69
14321: PUSH
14322: LD_INT 1
14324: ARRAY
14325: PPUSH
14326: CALL_OW 180
// ComEnterUnit ( has_eng , dep ) ;
14330: LD_VAR 0 2
14334: PPUSH
14335: LD_VAR 0 4
14339: PPUSH
14340: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
14344: LD_INT 35
14346: PPUSH
14347: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14351: LD_ADDR_VAR 0 3
14355: PUSH
14356: LD_INT 22
14358: PUSH
14359: LD_INT 4
14361: PUSH
14362: EMPTY
14363: LIST
14364: LIST
14365: PUSH
14366: LD_INT 21
14368: PUSH
14369: LD_INT 3
14371: PUSH
14372: EMPTY
14373: LIST
14374: LIST
14375: PUSH
14376: LD_INT 3
14378: PUSH
14379: LD_INT 24
14381: PUSH
14382: LD_INT 1000
14384: PUSH
14385: EMPTY
14386: LIST
14387: LIST
14388: PUSH
14389: EMPTY
14390: LIST
14391: LIST
14392: PUSH
14393: EMPTY
14394: LIST
14395: LIST
14396: LIST
14397: PPUSH
14398: CALL_OW 69
14402: ST_TO_ADDR
// if filter and has_eng then
14403: LD_VAR 0 3
14407: PUSH
14408: LD_VAR 0 2
14412: AND
14413: IFFALSE 14479
// begin for i in has_eng do
14415: LD_ADDR_VAR 0 1
14419: PUSH
14420: LD_VAR 0 2
14424: PUSH
14425: FOR_IN
14426: IFFALSE 14475
// begin if IsInUnit ( i ) then
14428: LD_VAR 0 1
14432: PPUSH
14433: CALL_OW 310
14437: IFFALSE 14448
// ComExitBuilding ( i ) ;
14439: LD_VAR 0 1
14443: PPUSH
14444: CALL_OW 122
// Wait ( 3 ) ;
14448: LD_INT 3
14450: PPUSH
14451: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
14455: LD_VAR 0 1
14459: PPUSH
14460: LD_VAR 0 3
14464: PUSH
14465: LD_INT 1
14467: ARRAY
14468: PPUSH
14469: CALL_OW 130
// end ;
14473: GO 14425
14475: POP
14476: POP
// end else
14477: GO 14533
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
14479: LD_VAR 0 2
14483: PUSH
14484: LD_VAR 0 2
14488: PPUSH
14489: LD_INT 56
14491: PUSH
14492: EMPTY
14493: LIST
14494: PPUSH
14495: CALL_OW 72
14499: AND
14500: IFFALSE 14533
// for i in has_eng do
14502: LD_ADDR_VAR 0 1
14506: PUSH
14507: LD_VAR 0 2
14511: PUSH
14512: FOR_IN
14513: IFFALSE 14531
// ComEnterUnit ( i , dep ) ;
14515: LD_VAR 0 1
14519: PPUSH
14520: LD_VAR 0 4
14524: PPUSH
14525: CALL_OW 120
14529: GO 14512
14531: POP
14532: POP
// until cornel_prepared ;
14533: LD_EXP 11
14537: IFFALSE 14344
// end ;
14539: PPOPN 8
14541: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
14542: LD_EXP 11
14546: IFFALSE 14919
14548: GO 14550
14550: DISABLE
14551: LD_INT 0
14553: PPUSH
14554: PPUSH
14555: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
14556: LD_ADDR_VAR 0 2
14560: PUSH
14561: LD_INT 22
14563: PUSH
14564: LD_INT 4
14566: PUSH
14567: EMPTY
14568: LIST
14569: LIST
14570: PUSH
14571: LD_INT 30
14573: PUSH
14574: LD_INT 4
14576: PUSH
14577: EMPTY
14578: LIST
14579: LIST
14580: PUSH
14581: EMPTY
14582: LIST
14583: LIST
14584: PPUSH
14585: CALL_OW 69
14589: PUSH
14590: LD_INT 1
14592: ARRAY
14593: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
14594: LD_EXP 6
14598: PPUSH
14599: CALL_OW 122
// Wait ( 0 0$03 ) ;
14603: LD_INT 105
14605: PPUSH
14606: CALL_OW 67
// for i in cornel_units do
14610: LD_ADDR_VAR 0 1
14614: PUSH
14615: LD_EXP 6
14619: PUSH
14620: FOR_IN
14621: IFFALSE 14697
// begin if GetClass ( i ) in [ 2 , 3 ] then
14623: LD_VAR 0 1
14627: PPUSH
14628: CALL_OW 257
14632: PUSH
14633: LD_INT 2
14635: PUSH
14636: LD_INT 3
14638: PUSH
14639: EMPTY
14640: LIST
14641: LIST
14642: IN
14643: IFFALSE 14680
// begin ComEnterUnit ( i , arm ) ;
14645: LD_VAR 0 1
14649: PPUSH
14650: LD_VAR 0 2
14654: PPUSH
14655: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
14659: LD_VAR 0 1
14663: PPUSH
14664: LD_INT 1
14666: PPUSH
14667: CALL_OW 183
// AddComExitBuilding ( i ) ;
14671: LD_VAR 0 1
14675: PPUSH
14676: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
14680: LD_VAR 0 1
14684: PPUSH
14685: LD_INT 257
14687: PPUSH
14688: LD_INT 121
14690: PPUSH
14691: CALL_OW 171
// end ;
14695: GO 14620
14697: POP
14698: POP
// Wait ( 1 1$00 ) ;
14699: LD_INT 2100
14701: PPUSH
14702: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
14706: LD_ADDR_VAR 0 3
14710: PUSH
14711: LD_EXP 43
14715: PUSH
14716: LD_EXP 44
14720: ADD
14721: PUSH
14722: LD_EXP 6
14726: ADD
14727: PUSH
14728: LD_EXP 6
14732: PPUSH
14733: LD_INT 21
14735: PUSH
14736: LD_INT 2
14738: PUSH
14739: EMPTY
14740: LIST
14741: LIST
14742: PPUSH
14743: CALL_OW 72
14747: DIFF
14748: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
14749: LD_VAR 0 3
14753: PPUSH
14754: LD_INT 248
14756: PPUSH
14757: LD_INT 85
14759: PPUSH
14760: CALL_OW 111
// AddComHold ( filter ) ;
14764: LD_VAR 0 3
14768: PPUSH
14769: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
14773: LD_INT 35
14775: PPUSH
14776: CALL_OW 67
// until cornel_attack ;
14780: LD_EXP 9
14784: IFFALSE 14773
// ComAgressiveMove ( filter , 209 , 63 ) ;
14786: LD_VAR 0 3
14790: PPUSH
14791: LD_INT 209
14793: PPUSH
14794: LD_INT 63
14796: PPUSH
14797: CALL_OW 114
// ComAgressiveMove ( Cornel , 208 , 62 ) ;
14801: LD_EXP 43
14805: PPUSH
14806: LD_INT 208
14808: PPUSH
14809: LD_INT 62
14811: PPUSH
14812: CALL_OW 114
// AddComHold ( Cornel ) ;
14816: LD_EXP 43
14820: PPUSH
14821: CALL_OW 200
// if Bierezov then
14825: LD_EXP 44
14829: IFFALSE 14919
// begin filter := filter diff Bierezov ;
14831: LD_ADDR_VAR 0 3
14835: PUSH
14836: LD_VAR 0 3
14840: PUSH
14841: LD_EXP 44
14845: DIFF
14846: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
14847: LD_EXP 44
14851: PPUSH
14852: LD_INT 6
14854: PPUSH
14855: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
14859: LD_EXP 44
14863: PPUSH
14864: LD_INT 235
14866: PPUSH
14867: LD_INT 60
14869: PPUSH
14870: CALL_OW 111
// AddComHold ( Bierezov ) ;
14874: LD_EXP 44
14878: PPUSH
14879: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
14883: LD_EXP 44
14887: PPUSH
14888: LD_INT 350
14890: PPUSH
14891: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
14895: LD_EXP 44
14899: PPUSH
14900: LD_INT 198
14902: PPUSH
14903: LD_INT 28
14905: PPUSH
14906: CALL_OW 171
// AddComHold ( Bierezov ) ;
14910: LD_EXP 44
14914: PPUSH
14915: CALL_OW 200
// end ; end ; end_of_file
14919: PPOPN 3
14921: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
14922: LD_EXP 52
14926: PUSH
14927: LD_EXP 30
14931: NOT
14932: AND
14933: PUSH
14934: LD_EXP 31
14938: NOT
14939: AND
14940: IFFALSE 15390
14942: GO 14944
14944: DISABLE
14945: LD_INT 0
14947: PPUSH
14948: PPUSH
14949: PPUSH
14950: PPUSH
// begin enable ;
14951: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14952: LD_ADDR_VAR 0 4
14956: PUSH
14957: LD_INT 81
14959: PUSH
14960: LD_INT 3
14962: PUSH
14963: EMPTY
14964: LIST
14965: LIST
14966: PPUSH
14967: CALL_OW 69
14971: ST_TO_ADDR
// for i = 1 to ru_patrol do
14972: LD_ADDR_VAR 0 2
14976: PUSH
14977: DOUBLE
14978: LD_INT 1
14980: DEC
14981: ST_TO_ADDR
14982: LD_EXP 52
14986: PUSH
14987: FOR_TO
14988: IFFALSE 15388
// begin un := ru_patrol [ i ] ;
14990: LD_ADDR_VAR 0 1
14994: PUSH
14995: LD_EXP 52
14999: PUSH
15000: LD_VAR 0 2
15004: ARRAY
15005: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15006: LD_VAR 0 1
15010: PPUSH
15011: LD_INT 13
15013: PPUSH
15014: CALL_OW 308
15018: IFFALSE 15123
// begin if not ru_alert then
15020: LD_EXP 59
15024: NOT
15025: IFFALSE 15035
// ru_alert := true ;
15027: LD_ADDR_EXP 59
15031: PUSH
15032: LD_INT 1
15034: ST_TO_ADDR
// if not See ( 1 , un ) then
15035: LD_INT 1
15037: PPUSH
15038: LD_VAR 0 1
15042: PPUSH
15043: CALL_OW 292
15047: NOT
15048: IFFALSE 15062
// SetLives ( un , 1000 ) ;
15050: LD_VAR 0 1
15054: PPUSH
15055: LD_INT 1000
15057: PPUSH
15058: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
15062: LD_ADDR_EXP 52
15066: PUSH
15067: LD_EXP 52
15071: PUSH
15072: LD_VAR 0 1
15076: DIFF
15077: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15078: LD_VAR 0 1
15082: PPUSH
15083: LD_INT 22
15085: PUSH
15086: LD_INT 3
15088: PUSH
15089: EMPTY
15090: LIST
15091: LIST
15092: PUSH
15093: LD_INT 30
15095: PUSH
15096: LD_INT 4
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: PUSH
15103: EMPTY
15104: LIST
15105: LIST
15106: PPUSH
15107: CALL_OW 69
15111: PPUSH
15112: CALL 1047 0 1
15116: PPUSH
15117: CALL_OW 120
// continue ;
15121: GO 14987
// end ; if IsOk ( un ) and not HasTask ( un ) then
15123: LD_VAR 0 1
15127: PPUSH
15128: CALL_OW 302
15132: PUSH
15133: LD_VAR 0 1
15137: PPUSH
15138: CALL_OW 314
15142: NOT
15143: AND
15144: IFFALSE 15237
// begin for j = 1 to ru_firepoints_south [ i ] do
15146: LD_ADDR_VAR 0 3
15150: PUSH
15151: DOUBLE
15152: LD_INT 1
15154: DEC
15155: ST_TO_ADDR
15156: LD_EXP 58
15160: PUSH
15161: LD_VAR 0 2
15165: ARRAY
15166: PUSH
15167: FOR_TO
15168: IFFALSE 15235
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
15170: LD_VAR 0 1
15174: PPUSH
15175: LD_EXP 58
15179: PUSH
15180: LD_VAR 0 2
15184: ARRAY
15185: PUSH
15186: LD_VAR 0 3
15190: ARRAY
15191: PUSH
15192: LD_INT 1
15194: ARRAY
15195: PPUSH
15196: LD_EXP 58
15200: PUSH
15201: LD_VAR 0 2
15205: ARRAY
15206: PUSH
15207: LD_VAR 0 3
15211: ARRAY
15212: PUSH
15213: LD_INT 2
15215: ARRAY
15216: PPUSH
15217: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
15221: LD_VAR 0 1
15225: PPUSH
15226: LD_INT 70
15228: PPUSH
15229: CALL_OW 202
// end ;
15233: GO 15167
15235: POP
15236: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15237: LD_VAR 0 1
15241: PPUSH
15242: CALL_OW 256
15246: PUSH
15247: LD_INT 700
15249: LESS
15250: PUSH
15251: LD_VAR 0 1
15255: PPUSH
15256: LD_INT 13
15258: PPUSH
15259: CALL_OW 308
15263: NOT
15264: AND
15265: IFFALSE 15317
// begin ComMoveToArea ( un , retreatArea ) ;
15267: LD_VAR 0 1
15271: PPUSH
15272: LD_INT 13
15274: PPUSH
15275: CALL_OW 113
// if not ru_alert_xy then
15279: LD_EXP 60
15283: NOT
15284: IFFALSE 15315
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
15286: LD_ADDR_EXP 60
15290: PUSH
15291: LD_VAR 0 1
15295: PPUSH
15296: CALL_OW 250
15300: PUSH
15301: LD_VAR 0 1
15305: PPUSH
15306: CALL_OW 251
15310: PUSH
15311: EMPTY
15312: LIST
15313: LIST
15314: ST_TO_ADDR
// end else
15315: GO 15386
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15317: LD_VAR 0 1
15321: PPUSH
15322: LD_VAR 0 4
15326: PPUSH
15327: LD_VAR 0 1
15331: PPUSH
15332: CALL_OW 74
15336: PPUSH
15337: CALL_OW 296
15341: PUSH
15342: LD_INT 9
15344: LESS
15345: PUSH
15346: LD_VAR 0 1
15350: PPUSH
15351: CALL_OW 256
15355: PUSH
15356: LD_INT 500
15358: GREATER
15359: AND
15360: IFFALSE 15386
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15362: LD_VAR 0 1
15366: PPUSH
15367: LD_VAR 0 4
15371: PPUSH
15372: LD_VAR 0 1
15376: PPUSH
15377: CALL_OW 74
15381: PPUSH
15382: CALL_OW 115
// end ;
15386: GO 14987
15388: POP
15389: POP
// end ;
15390: PPOPN 4
15392: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
15393: LD_EXP 59
15397: PUSH
15398: LD_EXP 60
15402: AND
15403: PUSH
15404: LD_EXP 30
15408: NOT
15409: AND
15410: PUSH
15411: LD_EXP 31
15415: NOT
15416: AND
15417: IFFALSE 15627
15419: GO 15421
15421: DISABLE
15422: LD_INT 0
15424: PPUSH
15425: PPUSH
// begin enable ;
15426: ENABLE
// if not ru_vehicles then
15427: LD_EXP 55
15431: NOT
15432: IFFALSE 15436
// exit ;
15434: GO 15627
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15436: LD_ADDR_VAR 0 2
15440: PUSH
15441: LD_INT 81
15443: PUSH
15444: LD_INT 3
15446: PUSH
15447: EMPTY
15448: LIST
15449: LIST
15450: PPUSH
15451: CALL_OW 69
15455: ST_TO_ADDR
// if ru_vehicles then
15456: LD_EXP 55
15460: IFFALSE 15627
// begin for i in ru_vehicles do
15462: LD_ADDR_VAR 0 1
15466: PUSH
15467: LD_EXP 55
15471: PUSH
15472: FOR_IN
15473: IFFALSE 15625
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
15475: LD_VAR 0 1
15479: PPUSH
15480: CALL_OW 302
15484: PUSH
15485: LD_VAR 0 1
15489: PPUSH
15490: LD_VAR 0 2
15494: PPUSH
15495: LD_VAR 0 1
15499: PPUSH
15500: CALL_OW 74
15504: PPUSH
15505: CALL_OW 296
15509: PUSH
15510: LD_INT 9
15512: LESS
15513: AND
15514: IFFALSE 15540
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15516: LD_VAR 0 1
15520: PPUSH
15521: LD_VAR 0 2
15525: PPUSH
15526: LD_VAR 0 1
15530: PPUSH
15531: CALL_OW 74
15535: PPUSH
15536: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
15540: LD_VAR 0 1
15544: PPUSH
15545: CALL_OW 314
15549: NOT
15550: PUSH
15551: LD_VAR 0 1
15555: PPUSH
15556: CALL_OW 302
15560: AND
15561: PUSH
15562: LD_VAR 0 1
15566: PPUSH
15567: LD_EXP 60
15571: PUSH
15572: LD_INT 1
15574: ARRAY
15575: PPUSH
15576: LD_EXP 60
15580: PUSH
15581: LD_INT 2
15583: ARRAY
15584: PPUSH
15585: CALL_OW 297
15589: PUSH
15590: LD_INT 10
15592: GREATER
15593: AND
15594: IFFALSE 15623
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
15596: LD_VAR 0 1
15600: PPUSH
15601: LD_EXP 60
15605: PUSH
15606: LD_INT 1
15608: ARRAY
15609: PPUSH
15610: LD_EXP 60
15614: PUSH
15615: LD_INT 2
15617: ARRAY
15618: PPUSH
15619: CALL_OW 114
// end ;
15623: GO 15472
15625: POP
15626: POP
// end ; end ;
15627: PPOPN 2
15629: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
15630: LD_EXP 60
15634: PUSH
15635: LD_EXP 59
15639: AND
15640: PUSH
15641: LD_INT 3
15643: PPUSH
15644: CALL_OW 463
15648: NOT
15649: AND
15650: PUSH
15651: LD_EXP 30
15655: NOT
15656: AND
15657: PUSH
15658: LD_EXP 31
15662: NOT
15663: AND
15664: IFFALSE 15759
15666: GO 15668
15668: DISABLE
15669: LD_INT 0
15671: PPUSH
// begin enable ;
15672: ENABLE
// ru_alert_xy := false ;
15673: LD_ADDR_EXP 60
15677: PUSH
15678: LD_INT 0
15680: ST_TO_ADDR
// ru_alert := false ;
15681: LD_ADDR_EXP 59
15685: PUSH
15686: LD_INT 0
15688: ST_TO_ADDR
// if ru_vehicles then
15689: LD_EXP 55
15693: IFFALSE 15759
// for i in ru_vehicles do
15695: LD_ADDR_VAR 0 1
15699: PUSH
15700: LD_EXP 55
15704: PUSH
15705: FOR_IN
15706: IFFALSE 15757
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
15708: LD_VAR 0 1
15712: PPUSH
15713: CALL_OW 302
15717: PUSH
15718: LD_VAR 0 1
15722: PPUSH
15723: LD_INT 89
15725: PPUSH
15726: LD_INT 36
15728: PPUSH
15729: CALL_OW 297
15733: PUSH
15734: LD_INT 10
15736: GREATER
15737: AND
15738: IFFALSE 15755
// ComMoveXY ( i , 89 , 36 ) ;
15740: LD_VAR 0 1
15744: PPUSH
15745: LD_INT 89
15747: PPUSH
15748: LD_INT 36
15750: PPUSH
15751: CALL_OW 111
15755: GO 15705
15757: POP
15758: POP
// end ;
15759: PPOPN 1
15761: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
15762: LD_EXP 54
15766: PUSH
15767: LD_EXP 30
15771: NOT
15772: AND
15773: PUSH
15774: LD_EXP 31
15778: NOT
15779: AND
15780: IFFALSE 16064
15782: GO 15784
15784: DISABLE
15785: LD_INT 0
15787: PPUSH
15788: PPUSH
15789: PPUSH
// begin enable ;
15790: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15791: LD_ADDR_VAR 0 3
15795: PUSH
15796: LD_INT 81
15798: PUSH
15799: LD_INT 3
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: PPUSH
15806: CALL_OW 69
15810: ST_TO_ADDR
// for i = 1 to ru_forest do
15811: LD_ADDR_VAR 0 1
15815: PUSH
15816: DOUBLE
15817: LD_INT 1
15819: DEC
15820: ST_TO_ADDR
15821: LD_EXP 54
15825: PUSH
15826: FOR_TO
15827: IFFALSE 16062
// begin un := ru_forest [ i ] ;
15829: LD_ADDR_VAR 0 2
15833: PUSH
15834: LD_EXP 54
15838: PUSH
15839: LD_VAR 0 1
15843: ARRAY
15844: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15845: LD_VAR 0 2
15849: PPUSH
15850: LD_INT 13
15852: PPUSH
15853: CALL_OW 308
15857: IFFALSE 15947
// begin if not See ( 1 , un ) then
15859: LD_INT 1
15861: PPUSH
15862: LD_VAR 0 2
15866: PPUSH
15867: CALL_OW 292
15871: NOT
15872: IFFALSE 15886
// SetLives ( un , 1000 ) ;
15874: LD_VAR 0 2
15878: PPUSH
15879: LD_INT 1000
15881: PPUSH
15882: CALL_OW 234
// ru_forest := ru_forest diff un ;
15886: LD_ADDR_EXP 54
15890: PUSH
15891: LD_EXP 54
15895: PUSH
15896: LD_VAR 0 2
15900: DIFF
15901: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15902: LD_VAR 0 2
15906: PPUSH
15907: LD_INT 22
15909: PUSH
15910: LD_INT 3
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: PUSH
15917: LD_INT 30
15919: PUSH
15920: LD_INT 4
15922: PUSH
15923: EMPTY
15924: LIST
15925: LIST
15926: PUSH
15927: EMPTY
15928: LIST
15929: LIST
15930: PPUSH
15931: CALL_OW 69
15935: PPUSH
15936: CALL 1047 0 1
15940: PPUSH
15941: CALL_OW 120
// continue ;
15945: GO 15826
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15947: LD_VAR 0 2
15951: PPUSH
15952: CALL_OW 256
15956: PUSH
15957: LD_INT 700
15959: LESS
15960: PUSH
15961: LD_VAR 0 2
15965: PPUSH
15966: LD_INT 13
15968: PPUSH
15969: CALL_OW 308
15973: NOT
15974: AND
15975: IFFALSE 15991
// ComMoveToArea ( un , retreatArea ) else
15977: LD_VAR 0 2
15981: PPUSH
15982: LD_INT 13
15984: PPUSH
15985: CALL_OW 113
15989: GO 16060
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15991: LD_VAR 0 2
15995: PPUSH
15996: LD_VAR 0 3
16000: PPUSH
16001: LD_VAR 0 2
16005: PPUSH
16006: CALL_OW 74
16010: PPUSH
16011: CALL_OW 296
16015: PUSH
16016: LD_INT 9
16018: LESS
16019: PUSH
16020: LD_VAR 0 2
16024: PPUSH
16025: CALL_OW 256
16029: PUSH
16030: LD_INT 500
16032: GREATER
16033: AND
16034: IFFALSE 16060
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
16036: LD_VAR 0 2
16040: PPUSH
16041: LD_VAR 0 3
16045: PPUSH
16046: LD_VAR 0 2
16050: PPUSH
16051: CALL_OW 74
16055: PPUSH
16056: CALL_OW 115
// end ;
16060: GO 15826
16062: POP
16063: POP
// end ;
16064: PPOPN 3
16066: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
16067: LD_EXP 31
16071: NOT
16072: IFFALSE 16193
16074: GO 16076
16076: DISABLE
16077: LD_INT 0
16079: PPUSH
16080: PPUSH
// begin enable ;
16081: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
16082: LD_ADDR_VAR 0 2
16086: PUSH
16087: LD_INT 22
16089: PUSH
16090: LD_INT 3
16092: PUSH
16093: EMPTY
16094: LIST
16095: LIST
16096: PUSH
16097: LD_INT 21
16099: PUSH
16100: LD_INT 3
16102: PUSH
16103: EMPTY
16104: LIST
16105: LIST
16106: PUSH
16107: EMPTY
16108: LIST
16109: LIST
16110: PPUSH
16111: CALL_OW 69
16115: ST_TO_ADDR
// if filter then
16116: LD_VAR 0 2
16120: IFFALSE 16193
// for i in filter do
16122: LD_ADDR_VAR 0 1
16126: PUSH
16127: LD_VAR 0 2
16131: PUSH
16132: FOR_IN
16133: IFFALSE 16191
// if GetLives ( i ) < 990 then
16135: LD_VAR 0 1
16139: PPUSH
16140: CALL_OW 256
16144: PUSH
16145: LD_INT 990
16147: LESS
16148: IFFALSE 16189
// begin ru_alert := true ;
16150: LD_ADDR_EXP 59
16154: PUSH
16155: LD_INT 1
16157: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
16158: LD_ADDR_EXP 60
16162: PUSH
16163: LD_VAR 0 1
16167: PPUSH
16168: CALL_OW 250
16172: PUSH
16173: LD_VAR 0 1
16177: PPUSH
16178: CALL_OW 251
16182: PUSH
16183: EMPTY
16184: LIST
16185: LIST
16186: ST_TO_ADDR
// break ;
16187: GO 16191
// end ;
16189: GO 16132
16191: POP
16192: POP
// end ;
16193: PPOPN 2
16195: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
16196: LD_EXP 30
16200: IFFALSE 16349
16202: GO 16204
16204: DISABLE
16205: LD_INT 0
16207: PPUSH
16208: PPUSH
16209: PPUSH
16210: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
16211: LD_ADDR_VAR 0 4
16215: PUSH
16216: LD_EXP 55
16220: PUSH
16221: LD_EXP 54
16225: ADD
16226: PUSH
16227: LD_EXP 52
16231: ADD
16232: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
16233: LD_ADDR_VAR 0 3
16237: PUSH
16238: LD_INT 3
16240: PPUSH
16241: LD_INT 81
16243: PUSH
16244: LD_INT 3
16246: PUSH
16247: EMPTY
16248: LIST
16249: LIST
16250: PPUSH
16251: CALL_OW 70
16255: ST_TO_ADDR
// if filter and enemy then
16256: LD_VAR 0 4
16260: PUSH
16261: LD_VAR 0 3
16265: AND
16266: IFFALSE 16349
// repeat wait ( 0 0$01 ) ;
16268: LD_INT 35
16270: PPUSH
16271: CALL_OW 67
// for i in filter do
16275: LD_ADDR_VAR 0 1
16279: PUSH
16280: LD_VAR 0 4
16284: PUSH
16285: FOR_IN
16286: IFFALSE 16314
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16288: LD_VAR 0 1
16292: PPUSH
16293: LD_VAR 0 3
16297: PPUSH
16298: LD_VAR 0 1
16302: PPUSH
16303: CALL_OW 74
16307: PPUSH
16308: CALL_OW 115
// end ;
16312: GO 16285
16314: POP
16315: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
16316: LD_INT 3
16318: PPUSH
16319: LD_INT 81
16321: PUSH
16322: LD_INT 3
16324: PUSH
16325: EMPTY
16326: LIST
16327: LIST
16328: PPUSH
16329: CALL_OW 70
16333: PUSH
16334: LD_INT 0
16336: EQUAL
16337: PUSH
16338: LD_VAR 0 4
16342: PUSH
16343: LD_INT 0
16345: EQUAL
16346: OR
16347: IFFALSE 16268
// end ;
16349: PPOPN 4
16351: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) do var i ;
16352: LD_EXP 25
16356: PUSH
16357: LD_INT 22
16359: PUSH
16360: LD_INT 4
16362: PUSH
16363: EMPTY
16364: LIST
16365: LIST
16366: PUSH
16367: LD_INT 30
16369: PUSH
16370: LD_INT 4
16372: PUSH
16373: EMPTY
16374: LIST
16375: LIST
16376: PUSH
16377: LD_INT 3
16379: PUSH
16380: LD_INT 57
16382: PUSH
16383: EMPTY
16384: LIST
16385: PUSH
16386: EMPTY
16387: LIST
16388: LIST
16389: PUSH
16390: EMPTY
16391: LIST
16392: LIST
16393: LIST
16394: PPUSH
16395: CALL_OW 69
16399: AND
16400: IFFALSE 16449
16402: GO 16404
16404: DISABLE
16405: LD_INT 0
16407: PPUSH
// begin if not ru_cornel_attack then
16408: LD_EXP 57
16412: NOT
16413: IFFALSE 16417
// exit ;
16415: GO 16449
// for i in ru_cornel_attack do
16417: LD_ADDR_VAR 0 1
16421: PUSH
16422: LD_EXP 57
16426: PUSH
16427: FOR_IN
16428: IFFALSE 16447
// ComAgressiveMove ( i , 258 , 119 ) ;
16430: LD_VAR 0 1
16434: PPUSH
16435: LD_INT 258
16437: PPUSH
16438: LD_INT 119
16440: PPUSH
16441: CALL_OW 114
16445: GO 16427
16447: POP
16448: POP
// end ; end_of_file
16449: PPOPN 1
16451: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
16452: LD_EXP 5
16456: PUSH
16457: LD_EXP 9
16461: NOT
16462: AND
16463: PUSH
16464: LD_EXP 19
16468: AND
16469: IFFALSE 16581
16471: GO 16473
16473: DISABLE
16474: LD_INT 0
16476: PPUSH
// begin enable ;
16477: ENABLE
// crates_counter := crates_counter - 50 ;
16478: LD_ADDR_EXP 19
16482: PUSH
16483: LD_EXP 19
16487: PUSH
16488: LD_INT 50
16490: MINUS
16491: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
16492: LD_INT 8
16494: PPUSH
16495: LD_INT 2
16497: PPUSH
16498: LD_INT 5
16500: PPUSH
16501: CALL_OW 12
16505: PPUSH
16506: LD_INT 1
16508: PPUSH
16509: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
16513: LD_INT 1785
16515: PPUSH
16516: LD_INT 2345
16518: PPUSH
16519: CALL_OW 12
16523: PPUSH
16524: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
16528: LD_ADDR_VAR 0 1
16532: PUSH
16533: LD_INT 1
16535: PPUSH
16536: LD_OWVAR 67
16540: PUSH
16541: LD_INT 2
16543: PLUS
16544: PPUSH
16545: CALL_OW 12
16549: ST_TO_ADDR
// if r < 3 then
16550: LD_VAR 0 1
16554: PUSH
16555: LD_INT 3
16557: LESS
16558: IFFALSE 16581
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
16560: LD_INT 4
16562: PPUSH
16563: LD_INT 1
16565: PPUSH
16566: LD_INT 5
16568: PPUSH
16569: CALL_OW 12
16573: PPUSH
16574: LD_INT 1
16576: PPUSH
16577: CALL_OW 55
// end ;
16581: PPOPN 1
16583: END
// every 0 0$01 trigger cornel_active do
16584: LD_EXP 8
16588: IFFALSE 16677
16590: GO 16592
16592: DISABLE
// begin Wait ( 0 0$03 ) ;
16593: LD_INT 105
16595: PPUSH
16596: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16600: LD_INT 2
16602: PPUSH
16603: LD_INT 5
16605: PPUSH
16606: CALL_OW 12
16610: PPUSH
16611: LD_INT 10
16613: PPUSH
16614: LD_INT 1
16616: PPUSH
16617: CALL_OW 55
// Wait ( 0 0$13 ) ;
16621: LD_INT 455
16623: PPUSH
16624: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16628: LD_INT 2
16630: PPUSH
16631: LD_INT 5
16633: PPUSH
16634: CALL_OW 12
16638: PPUSH
16639: LD_INT 10
16641: PPUSH
16642: LD_INT 1
16644: PPUSH
16645: CALL_OW 55
// Wait ( 0 0$16 ) ;
16649: LD_INT 560
16651: PPUSH
16652: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16656: LD_INT 2
16658: PPUSH
16659: LD_INT 5
16661: PPUSH
16662: CALL_OW 12
16666: PPUSH
16667: LD_INT 10
16669: PPUSH
16670: LD_INT 1
16672: PPUSH
16673: CALL_OW 55
// end ; end_of_file
16677: END
// every 0 0$01 trigger cornel_prepared do
16678: LD_EXP 11
16682: IFFALSE 16741
16684: GO 16686
16686: DISABLE
// begin enable ;
16687: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
16688: LD_ADDR_OWVAR 47
16692: PUSH
16693: LD_STRING #Am03-1
16695: PUSH
16696: LD_EXP 10
16700: PUSH
16701: EMPTY
16702: LIST
16703: LIST
16704: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
16705: LD_ADDR_EXP 10
16709: PUSH
16710: LD_EXP 10
16714: PPUSH
16715: LD_STRING -
16717: PPUSH
16718: CALL 1117 0 2
16722: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
16723: LD_EXP 10
16727: PUSH
16728: LD_INT 0
16730: EQUAL
16731: IFFALSE 16741
// begin Display_Strings := [ ] ;
16733: LD_ADDR_OWVAR 47
16737: PUSH
16738: EMPTY
16739: ST_TO_ADDR
// disable ;
16740: DISABLE
// end ; end ;
16741: END
// every 0 0$01 trigger debug and debug_strings do
16742: LD_EXP 1
16746: PUSH
16747: LD_OWVAR 48
16751: AND
16752: IFFALSE 16768
16754: GO 16756
16756: DISABLE
// begin enable ;
16757: ENABLE
// Display_Strings := debug_strings ;
16758: LD_ADDR_OWVAR 47
16762: PUSH
16763: LD_OWVAR 48
16767: ST_TO_ADDR
// end ; end_of_file
16768: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
16769: LD_VAR 0 1
16773: PPUSH
16774: CALL_OW 255
16778: PUSH
16779: LD_INT 1
16781: EQUAL
16782: PUSH
16783: LD_EXP 13
16787: NOT
16788: AND
16789: IFFALSE 16799
// solar_builded := true ;
16791: LD_ADDR_EXP 13
16795: PUSH
16796: LD_INT 1
16798: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
16799: LD_VAR 0 1
16803: PPUSH
16804: CALL_OW 255
16808: PUSH
16809: LD_INT 1
16811: EQUAL
16812: PUSH
16813: LD_EXP 28
16817: AND
16818: IFFALSE 16851
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
16820: LD_ADDR_EXP 28
16824: PUSH
16825: LD_EXP 28
16829: PUSH
16830: LD_INT 1750
16832: PUSH
16833: LD_INT 1400
16835: PUSH
16836: LD_INT 1225
16838: PUSH
16839: EMPTY
16840: LIST
16841: LIST
16842: LIST
16843: PUSH
16844: LD_OWVAR 67
16848: ARRAY
16849: PLUS
16850: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
16851: LD_VAR 0 1
16855: PPUSH
16856: CALL_OW 255
16860: PUSH
16861: LD_INT 3
16863: EQUAL
16864: IFFALSE 16882
// ru_vehicles := ru_vehicles ^ veh ;
16866: LD_ADDR_EXP 55
16870: PUSH
16871: LD_EXP 55
16875: PUSH
16876: LD_VAR 0 1
16880: ADD
16881: ST_TO_ADDR
// end ;
16882: PPOPN 2
16884: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
16885: LD_VAR 0 1
16889: PUSH
16890: LD_EXP 52
16894: IN
16895: IFFALSE 16913
// ru_patrol := ru_patrol diff un ;
16897: LD_ADDR_EXP 52
16901: PUSH
16902: LD_EXP 52
16906: PUSH
16907: LD_VAR 0 1
16911: DIFF
16912: ST_TO_ADDR
// if un in ru_forest then
16913: LD_VAR 0 1
16917: PUSH
16918: LD_EXP 54
16922: IN
16923: IFFALSE 16941
// ru_forest := ru_forest diff un ;
16925: LD_ADDR_EXP 54
16929: PUSH
16930: LD_EXP 54
16934: PUSH
16935: LD_VAR 0 1
16939: DIFF
16940: ST_TO_ADDR
// if un in ru_vehicles then
16941: LD_VAR 0 1
16945: PUSH
16946: LD_EXP 55
16950: IN
16951: IFFALSE 17026
// begin ru_vehicles := ru_vehicles diff un ;
16953: LD_ADDR_EXP 55
16957: PUSH
16958: LD_EXP 55
16962: PUSH
16963: LD_VAR 0 1
16967: DIFF
16968: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
16969: LD_ADDR_EXP 56
16973: PUSH
16974: LD_EXP 56
16978: PUSH
16979: LD_VAR 0 1
16983: PPUSH
16984: CALL_OW 265
16988: PUSH
16989: LD_VAR 0 1
16993: PPUSH
16994: CALL_OW 262
16998: PUSH
16999: LD_VAR 0 1
17003: PPUSH
17004: CALL_OW 263
17008: PUSH
17009: LD_VAR 0 1
17013: PPUSH
17014: CALL_OW 264
17018: PUSH
17019: EMPTY
17020: LIST
17021: LIST
17022: LIST
17023: LIST
17024: ADD
17025: ST_TO_ADDR
// end ; if un = JMM then
17026: LD_VAR 0 1
17030: PUSH
17031: LD_EXP 36
17035: EQUAL
17036: IFFALSE 17045
// YouLost ( 0 ) ;
17038: LD_STRING 0
17040: PPUSH
17041: CALL_OW 104
// if un = us_dep_west then
17045: LD_VAR 0 1
17049: PUSH
17050: LD_INT 1
17052: EQUAL
17053: IFFALSE 17062
// YouLost ( 2 ) ;
17055: LD_STRING 2
17057: PPUSH
17058: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
17062: LD_VAR 0 1
17066: PPUSH
17067: CALL_OW 255
17071: PUSH
17072: LD_INT 8
17074: EQUAL
17075: PUSH
17076: LD_EXP 5
17080: NOT
17081: AND
17082: IFFALSE 17091
// YouLost ( 4 ) ;
17084: LD_STRING 4
17086: PPUSH
17087: CALL_OW 104
// if un in jmm_units then
17091: LD_VAR 0 1
17095: PUSH
17096: LD_EXP 4
17100: IN
17101: IFFALSE 17117
// lose_counter := lose_counter + 1 ;
17103: LD_ADDR_EXP 33
17107: PUSH
17108: LD_EXP 33
17112: PUSH
17113: LD_INT 1
17115: PLUS
17116: ST_TO_ADDR
// end ;
17117: PPOPN 1
17119: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
17120: LD_INT 0
17122: PPUSH
17123: PPUSH
// begin if GetSide ( driver ) = 3 then
17124: LD_VAR 0 1
17128: PPUSH
17129: CALL_OW 255
17133: PUSH
17134: LD_INT 3
17136: EQUAL
17137: IFFALSE 17215
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
17139: LD_ADDR_VAR 0 6
17143: PUSH
17144: LD_INT 22
17146: PUSH
17147: LD_INT 3
17149: PUSH
17150: EMPTY
17151: LIST
17152: LIST
17153: PUSH
17154: LD_INT 30
17156: PUSH
17157: LD_INT 3
17159: PUSH
17160: EMPTY
17161: LIST
17162: LIST
17163: PUSH
17164: EMPTY
17165: LIST
17166: LIST
17167: PPUSH
17168: CALL_OW 69
17172: PPUSH
17173: CALL 1047 0 1
17177: ST_TO_ADDR
// if place then
17178: LD_VAR 0 6
17182: IFFALSE 17200
// ComEnterUnit ( driver , place ) else
17184: LD_VAR 0 1
17188: PPUSH
17189: LD_VAR 0 6
17193: PPUSH
17194: CALL_OW 120
17198: GO 17215
// ComMoveXY ( driver , 70 , 22 ) ;
17200: LD_VAR 0 1
17204: PPUSH
17205: LD_INT 70
17207: PPUSH
17208: LD_INT 22
17210: PPUSH
17211: CALL_OW 111
// end ; end ;
17215: PPOPN 6
17217: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and ( s2 = 4 or ( s2 = 8 and not jmm_on_west ) ) then
17218: LD_VAR 0 1
17222: PUSH
17223: LD_INT 1
17225: EQUAL
17226: PUSH
17227: LD_VAR 0 2
17231: PUSH
17232: LD_INT 4
17234: EQUAL
17235: PUSH
17236: LD_VAR 0 2
17240: PUSH
17241: LD_INT 8
17243: EQUAL
17244: PUSH
17245: LD_EXP 5
17249: NOT
17250: AND
17251: OR
17252: AND
17253: IFFALSE 17262
// YouLost ( 5 ) ;
17255: LD_STRING 5
17257: PPUSH
17258: CALL_OW 104
// end ;
17262: PPOPN 2
17264: END
// every 0 0$01 trigger save_counter + ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
17265: LD_EXP 35
17269: PUSH
17270: LD_INT 22
17272: PUSH
17273: LD_INT 1
17275: PUSH
17276: EMPTY
17277: LIST
17278: LIST
17279: PUSH
17280: LD_INT 21
17282: PUSH
17283: LD_INT 1
17285: PUSH
17286: EMPTY
17287: LIST
17288: LIST
17289: PUSH
17290: EMPTY
17291: LIST
17292: LIST
17293: PPUSH
17294: CALL_OW 69
17298: PUSH
17299: LD_INT 22
17301: PUSH
17302: LD_INT 8
17304: PUSH
17305: EMPTY
17306: LIST
17307: LIST
17308: PUSH
17309: LD_INT 21
17311: PUSH
17312: LD_INT 1
17314: PUSH
17315: EMPTY
17316: LIST
17317: LIST
17318: PUSH
17319: EMPTY
17320: LIST
17321: LIST
17322: PPUSH
17323: CALL_OW 69
17327: ADD
17328: PLUS
17329: PUSH
17330: LD_INT 5
17332: LESS
17333: IFFALSE 17345
17335: GO 17337
17337: DISABLE
// YouLost ( 1 ) ;
17338: LD_STRING 1
17340: PPUSH
17341: CALL_OW 104
17345: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
17346: LD_INT 1
17348: PPUSH
17349: CALL_OW 255
17353: PUSH
17354: LD_INT 3
17356: EQUAL
17357: IFFALSE 17369
17359: GO 17361
17361: DISABLE
// YouLost ( 3 ) ;
17362: LD_STRING 3
17364: PPUSH
17365: CALL_OW 104
17369: END
