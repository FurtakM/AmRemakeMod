// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 363 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 451 0 0
// PrepareRussian ;
  22: CALL 3008 0 0
// PrepareAmerican ;
  26: CALL 1213 0 0
// PrepareCornell ;
  30: CALL 2237 0 0
// PrepareWesternBase ;
  34: CALL 2463 0 0
// Action ;
  38: CALL 5224 0 0
// end ;
  42: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , cornel_saved , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn , save_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  54: LD_ADDR_EXP 3
  58: PUSH
  59: LD_STRING 02_
  61: ST_TO_ADDR
// mission_prefix := 03_ ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_STRING 03_
  69: ST_TO_ADDR
// jmm_units := 0 ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// cornel_units := 0 ;
  78: LD_ADDR_EXP 6
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// bierezov_exist := false ;
  86: LD_ADDR_EXP 7
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// jmm_on_west := false ;
  94: LD_ADDR_EXP 5
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_active := false ;
 102: LD_ADDR_EXP 8
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_attack := false ;
 110: LD_ADDR_EXP 9
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// cornel_prepared := false ;
 118: LD_ADDR_EXP 11
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 126: LD_ADDR_EXP 10
 130: PUSH
 131: LD_INT 4200
 133: ST_TO_ADDR
// frank_can_return := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// solar_builded := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// frank_send_to_scout := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// jmm_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// bobby_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// cyrus_in_veh := false ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// lisa_in_veh := false ;
 182: LD_ADDR_EXP 18
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 190: LD_ADDR_EXP 28
 194: PUSH
 195: LD_INT 25200
 197: PUSH
 198: LD_INT 23100
 200: PUSH
 201: LD_INT 21000
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: PUSH
 209: LD_OWVAR 67
 213: ARRAY
 214: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 215: LD_ADDR_EXP 19
 219: PUSH
 220: LD_INT 600
 222: PUSH
 223: LD_INT 500
 225: PUSH
 226: LD_INT 400
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: PUSH
 234: LD_OWVAR 67
 238: ARRAY
 239: ST_TO_ADDR
// end_mission_allowed := false ;
 240: LD_ADDR_EXP 20
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// save_others := [ ] ;
 248: LD_ADDR_EXP 21
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// save_group := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// show_query := true ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// wait_for_them := false ;
 270: LD_ADDR_EXP 24
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// veh_on_meta := false ;
 278: LD_ADDR_EXP 27
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_spec_patrol := false ;
 286: LD_ADDR_EXP 29
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// prepare_siege := false ;
 294: LD_ADDR_EXP 30
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// send_attack_on_cornel := false ;
 302: LD_ADDR_EXP 31
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 310: LD_ADDR_EXP 25
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// game_end := false ;
 318: LD_ADDR_EXP 32
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// lose_counter := 0 ;
 326: LD_ADDR_EXP 33
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// powell_warn := 0 ;
 334: LD_ADDR_EXP 34
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// save_counter := 0 ;
 342: LD_ADDR_EXP 35
 346: PUSH
 347: LD_INT 0
 349: ST_TO_ADDR
// cornel_saved := false ;
 350: LD_ADDR_EXP 26
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// end ;
 358: LD_VAR 0 1
 362: RET
// function SetDiplomacy ; begin
 363: LD_INT 0
 365: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 366: LD_INT 1
 368: PPUSH
 369: LD_INT 4
 371: PPUSH
 372: LD_INT 1
 374: PPUSH
 375: LD_INT 1
 377: PPUSH
 378: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 382: LD_INT 1
 384: PPUSH
 385: LD_INT 8
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 398: LD_INT 3
 400: PPUSH
 401: LD_INT 6
 403: PPUSH
 404: LD_INT 1
 406: PPUSH
 407: LD_INT 1
 409: PPUSH
 410: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 414: LD_INT 4
 416: PPUSH
 417: LD_INT 6
 419: PPUSH
 420: LD_INT 0
 422: PPUSH
 423: LD_INT 1
 425: PPUSH
 426: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 430: LD_INT 3
 432: PPUSH
 433: LD_INT 8
 435: PPUSH
 436: LD_INT 0
 438: PPUSH
 439: LD_INT 1
 441: PPUSH
 442: CALL_OW 80
// end ;
 446: LD_VAR 0 1
 450: RET
// export function DebugMode ; var i ; begin
 451: LD_INT 0
 453: PPUSH
 454: PPUSH
// FogOff ( 1 ) ;
 455: LD_INT 1
 457: PPUSH
 458: CALL_OW 344
// debug_strings := [ ] ;
 462: LD_ADDR_OWVAR 48
 466: PUSH
 467: EMPTY
 468: ST_TO_ADDR
// end ; end_of_file
 469: LD_VAR 0 1
 473: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 474: LD_INT 0
 476: PPUSH
 477: PPUSH
// if exist_mode then
 478: LD_VAR 0 2
 482: IFFALSE 507
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 484: LD_ADDR_VAR 0 4
 488: PUSH
 489: LD_EXP 3
 493: PUSH
 494: LD_VAR 0 1
 498: STR
 499: PPUSH
 500: CALL_OW 34
 504: ST_TO_ADDR
 505: GO 522
// unit := NewCharacter ( ident ) ;
 507: LD_ADDR_VAR 0 4
 511: PUSH
 512: LD_VAR 0 1
 516: PPUSH
 517: CALL_OW 25
 521: ST_TO_ADDR
// result := unit ;
 522: LD_ADDR_VAR 0 3
 526: PUSH
 527: LD_VAR 0 4
 531: ST_TO_ADDR
// end ;
 532: LD_VAR 0 3
 536: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 537: LD_INT 0
 539: PPUSH
// uc_side := side ;
 540: LD_ADDR_OWVAR 20
 544: PUSH
 545: LD_VAR 0 1
 549: ST_TO_ADDR
// uc_nation := nation ;
 550: LD_ADDR_OWVAR 21
 554: PUSH
 555: LD_VAR 0 2
 559: ST_TO_ADDR
// vc_chassis := chassis ;
 560: LD_ADDR_OWVAR 37
 564: PUSH
 565: LD_VAR 0 3
 569: ST_TO_ADDR
// vc_engine := engine ;
 570: LD_ADDR_OWVAR 39
 574: PUSH
 575: LD_VAR 0 4
 579: ST_TO_ADDR
// vc_control := control ;
 580: LD_ADDR_OWVAR 38
 584: PUSH
 585: LD_VAR 0 5
 589: ST_TO_ADDR
// vc_weapon := weapon ;
 590: LD_ADDR_OWVAR 40
 594: PUSH
 595: LD_VAR 0 6
 599: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 600: LD_ADDR_OWVAR 41
 604: PUSH
 605: LD_VAR 0 7
 609: ST_TO_ADDR
// result := CreateVehicle ;
 610: LD_ADDR_VAR 0 8
 614: PUSH
 615: CALL_OW 45
 619: ST_TO_ADDR
// end ;
 620: LD_VAR 0 8
 624: RET
// export function SayX ( units , ident ) ; var i ; begin
 625: LD_INT 0
 627: PPUSH
 628: PPUSH
// result := false ;
 629: LD_ADDR_VAR 0 3
 633: PUSH
 634: LD_INT 0
 636: ST_TO_ADDR
// if not units then
 637: LD_VAR 0 1
 641: NOT
 642: IFFALSE 646
// exit ;
 644: GO 700
// for i in units do
 646: LD_ADDR_VAR 0 4
 650: PUSH
 651: LD_VAR 0 1
 655: PUSH
 656: FOR_IN
 657: IFFALSE 698
// if IsOk ( i ) then
 659: LD_VAR 0 4
 663: PPUSH
 664: CALL_OW 302
 668: IFFALSE 696
// begin Say ( i , ident ) ;
 670: LD_VAR 0 4
 674: PPUSH
 675: LD_VAR 0 2
 679: PPUSH
 680: CALL_OW 88
// result := i ;
 684: LD_ADDR_VAR 0 3
 688: PUSH
 689: LD_VAR 0 4
 693: ST_TO_ADDR
// break ;
 694: GO 698
// end ;
 696: GO 656
 698: POP
 699: POP
// end ;
 700: LD_VAR 0 3
 704: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 705: LD_INT 0
 707: PPUSH
 708: PPUSH
 709: PPUSH
 710: PPUSH
// for i = 1 to count do
 711: LD_ADDR_VAR 0 8
 715: PUSH
 716: DOUBLE
 717: LD_INT 1
 719: DEC
 720: ST_TO_ADDR
 721: LD_VAR 0 6
 725: PUSH
 726: FOR_TO
 727: IFFALSE 808
// begin uc_side = side ;
 729: LD_ADDR_OWVAR 20
 733: PUSH
 734: LD_VAR 0 1
 738: ST_TO_ADDR
// uc_nation = nation ;
 739: LD_ADDR_OWVAR 21
 743: PUSH
 744: LD_VAR 0 2
 748: ST_TO_ADDR
// hc_gallery =  ;
 749: LD_ADDR_OWVAR 33
 753: PUSH
 754: LD_STRING 
 756: ST_TO_ADDR
// hc_name =  ;
 757: LD_ADDR_OWVAR 26
 761: PUSH
 762: LD_STRING 
 764: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 765: LD_INT 0
 767: PPUSH
 768: LD_VAR 0 5
 772: PPUSH
 773: LD_VAR 0 4
 777: PPUSH
 778: CALL_OW 380
// un = CreateHuman ;
 782: LD_ADDR_VAR 0 10
 786: PUSH
 787: CALL_OW 44
 791: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 792: LD_VAR 0 10
 796: PPUSH
 797: LD_VAR 0 3
 801: PPUSH
 802: CALL_OW 52
// end ;
 806: GO 726
 808: POP
 809: POP
// end ;
 810: LD_VAR 0 7
 814: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// uc_side := GetSide ( b ) ;
 820: LD_ADDR_OWVAR 20
 824: PUSH
 825: LD_VAR 0 2
 829: PPUSH
 830: CALL_OW 255
 834: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_VAR 0 2
 844: PPUSH
 845: CALL_OW 248
 849: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 850: LD_INT 0
 852: PPUSH
 853: LD_INT 1
 855: PPUSH
 856: LD_VAR 0 1
 860: PPUSH
 861: CALL_OW 380
// un = CreateHuman ;
 865: LD_ADDR_VAR 0 4
 869: PUSH
 870: CALL_OW 44
 874: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 875: LD_ADDR_VAR 0 5
 879: PUSH
 880: LD_VAR 0 2
 884: PPUSH
 885: CALL_OW 254
 889: PUSH
 890: LD_INT 3
 892: MINUS
 893: ST_TO_ADDR
// if dir < 0 then
 894: LD_VAR 0 5
 898: PUSH
 899: LD_INT 0
 901: LESS
 902: IFFALSE 918
// dir := 6 + dir ;
 904: LD_ADDR_VAR 0 5
 908: PUSH
 909: LD_INT 6
 911: PUSH
 912: LD_VAR 0 5
 916: PLUS
 917: ST_TO_ADDR
// SetDir ( un , dir ) ;
 918: LD_VAR 0 4
 922: PPUSH
 923: LD_VAR 0 5
 927: PPUSH
 928: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 932: LD_VAR 0 4
 936: PPUSH
 937: LD_VAR 0 2
 941: PPUSH
 942: CALL_OW 52
// end ;
 946: LD_VAR 0 3
 950: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 951: LD_INT 0
 953: PPUSH
 954: PPUSH
 955: PPUSH
// result := false ;
 956: LD_ADDR_VAR 0 2
 960: PUSH
 961: LD_INT 0
 963: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 964: LD_ADDR_VAR 0 3
 968: PUSH
 969: LD_INT 22
 971: PUSH
 972: LD_INT 1
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 34
 981: PUSH
 982: LD_INT 2
 984: PUSH
 985: EMPTY
 986: LIST
 987: LIST
 988: PUSH
 989: EMPTY
 990: LIST
 991: LIST
 992: PPUSH
 993: CALL_OW 69
 997: ST_TO_ADDR
// for i in filter do
 998: LD_ADDR_VAR 0 4
1002: PUSH
1003: LD_VAR 0 3
1007: PUSH
1008: FOR_IN
1009: IFFALSE 1040
// if IsDrivenBy ( i ) = unit then
1011: LD_VAR 0 4
1015: PPUSH
1016: CALL_OW 311
1020: PUSH
1021: LD_VAR 0 1
1025: EQUAL
1026: IFFALSE 1038
// begin result := true ;
1028: LD_ADDR_VAR 0 2
1032: PUSH
1033: LD_INT 1
1035: ST_TO_ADDR
// break ;
1036: GO 1040
// end ;
1038: GO 1008
1040: POP
1041: POP
// end ;
1042: LD_VAR 0 2
1046: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1047: LD_INT 0
1049: PPUSH
1050: PPUSH
// result := false ;
1051: LD_ADDR_VAR 0 2
1055: PUSH
1056: LD_INT 0
1058: ST_TO_ADDR
// if not blist then
1059: LD_VAR 0 1
1063: NOT
1064: IFFALSE 1068
// exit ;
1066: GO 1112
// for i in blist do
1068: LD_ADDR_VAR 0 3
1072: PUSH
1073: LD_VAR 0 1
1077: PUSH
1078: FOR_IN
1079: IFFALSE 1110
// if UnitsInside ( i ) < 6 then
1081: LD_VAR 0 3
1085: PPUSH
1086: CALL_OW 313
1090: PUSH
1091: LD_INT 6
1093: LESS
1094: IFFALSE 1108
// begin result := i ;
1096: LD_ADDR_VAR 0 2
1100: PUSH
1101: LD_VAR 0 3
1105: ST_TO_ADDR
// break ;
1106: GO 1110
// end ;
1108: GO 1078
1110: POP
1111: POP
// end ;
1112: LD_VAR 0 2
1116: RET
// export function Count ( timer , mode ) ; begin
1117: LD_INT 0
1119: PPUSH
// if not timer then
1120: LD_VAR 0 1
1124: NOT
1125: IFFALSE 1129
// exit ;
1127: GO 1180
// if mode in [ asc , up , + ] then
1129: LD_VAR 0 2
1133: PUSH
1134: LD_STRING asc
1136: PUSH
1137: LD_STRING up
1139: PUSH
1140: LD_STRING +
1142: PUSH
1143: EMPTY
1144: LIST
1145: LIST
1146: LIST
1147: IN
1148: IFFALSE 1166
// result := timer + 0 0$01 else
1150: LD_ADDR_VAR 0 3
1154: PUSH
1155: LD_VAR 0 1
1159: PUSH
1160: LD_INT 35
1162: PLUS
1163: ST_TO_ADDR
1164: GO 1180
// result := timer - 0 0$01 ;
1166: LD_ADDR_VAR 0 3
1170: PUSH
1171: LD_VAR 0 1
1175: PUSH
1176: LD_INT 35
1178: MINUS
1179: ST_TO_ADDR
// end ;
1180: LD_VAR 0 3
1184: RET
// export function Video ( mode ) ; begin
1185: LD_INT 0
1187: PPUSH
// ingame_video = mode ;
1188: LD_ADDR_OWVAR 52
1192: PUSH
1193: LD_VAR 0 1
1197: ST_TO_ADDR
// interface_hidden = mode ;
1198: LD_ADDR_OWVAR 54
1202: PUSH
1203: LD_VAR 0 1
1207: ST_TO_ADDR
// end ; end_of_file
1208: LD_VAR 0 2
1212: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1213: LD_INT 0
1215: PPUSH
1216: PPUSH
1217: PPUSH
1218: PPUSH
1219: PPUSH
1220: PPUSH
1221: PPUSH
1222: PPUSH
// uc_side := 4 ;
1223: LD_ADDR_OWVAR 20
1227: PUSH
1228: LD_INT 4
1230: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1231: LD_ADDR_EXP 45
1235: PUSH
1236: LD_STRING Powell
1238: PPUSH
1239: LD_INT 0
1241: PPUSH
1242: CALL 474 0 2
1246: ST_TO_ADDR
// uc_side := 1 ;
1247: LD_ADDR_OWVAR 20
1251: PUSH
1252: LD_INT 1
1254: ST_TO_ADDR
// uc_nation := 1 ;
1255: LD_ADDR_OWVAR 21
1259: PUSH
1260: LD_INT 1
1262: ST_TO_ADDR
// if debug then
1263: LD_EXP 1
1267: IFFALSE 1397
// begin for i = 1 to 4 do
1269: LD_ADDR_VAR 0 2
1273: PUSH
1274: DOUBLE
1275: LD_INT 1
1277: DEC
1278: ST_TO_ADDR
1279: LD_INT 4
1281: PUSH
1282: FOR_TO
1283: IFFALSE 1334
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1285: LD_INT 0
1287: PPUSH
1288: LD_INT 1
1290: PPUSH
1291: LD_INT 2
1293: PPUSH
1294: CALL_OW 12
1298: PPUSH
1299: LD_INT 3
1301: PPUSH
1302: CALL_OW 380
// un := CreateHuman ;
1306: LD_ADDR_VAR 0 3
1310: PUSH
1311: CALL_OW 44
1315: ST_TO_ADDR
// others := others ^ un ;
1316: LD_ADDR_VAR 0 5
1320: PUSH
1321: LD_VAR 0 5
1325: PUSH
1326: LD_VAR 0 3
1330: ADD
1331: ST_TO_ADDR
// end ;
1332: GO 1282
1334: POP
1335: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1336: LD_ADDR_VAR 0 6
1340: PUSH
1341: LD_INT 21
1343: PUSH
1344: LD_INT 1
1346: PUSH
1347: LD_INT 1
1349: PUSH
1350: LD_INT 51
1352: PUSH
1353: LD_INT 90
1355: PUSH
1356: LD_INT 504
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: LIST
1363: LIST
1364: LIST
1365: LIST
1366: PUSH
1367: LD_INT 21
1369: PUSH
1370: LD_INT 1
1372: PUSH
1373: LD_INT 1
1375: PUSH
1376: LD_INT 51
1378: PUSH
1379: LD_INT 80
1381: PUSH
1382: LD_INT 750
1384: PUSH
1385: EMPTY
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1397: LD_ADDR_EXP 36
1401: PUSH
1402: LD_STRING JMM
1404: PPUSH
1405: LD_EXP 1
1409: NOT
1410: PPUSH
1411: CALL 474 0 2
1415: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1416: LD_ADDR_EXP 37
1420: PUSH
1421: LD_STRING Bobby
1423: PPUSH
1424: LD_EXP 1
1428: NOT
1429: PPUSH
1430: CALL 474 0 2
1434: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1435: LD_ADDR_EXP 38
1439: PUSH
1440: LD_STRING Cyrus
1442: PPUSH
1443: LD_EXP 1
1447: NOT
1448: PPUSH
1449: CALL 474 0 2
1453: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1454: LD_ADDR_EXP 39
1458: PUSH
1459: LD_STRING Lisa
1461: PPUSH
1462: LD_EXP 1
1466: NOT
1467: PPUSH
1468: CALL 474 0 2
1472: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1473: LD_ADDR_EXP 40
1477: PUSH
1478: LD_STRING Khatam
1480: PPUSH
1481: LD_EXP 1
1485: NOT
1486: PPUSH
1487: CALL 474 0 2
1491: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1492: LD_ADDR_EXP 41
1496: PUSH
1497: LD_STRING Brian
1499: PPUSH
1500: LD_EXP 1
1504: NOT
1505: PPUSH
1506: CALL 474 0 2
1510: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1511: LD_ADDR_EXP 42
1515: PUSH
1516: LD_STRING Jerry
1518: PPUSH
1519: LD_EXP 1
1523: NOT
1524: PPUSH
1525: CALL 474 0 2
1529: ST_TO_ADDR
// if Bobby then
1530: LD_EXP 37
1534: IFFALSE 1565
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1536: LD_ADDR_VAR 0 4
1540: PUSH
1541: LD_VAR 0 4
1545: PPUSH
1546: LD_VAR 0 4
1550: PUSH
1551: LD_INT 1
1553: PLUS
1554: PPUSH
1555: LD_EXP 37
1559: PPUSH
1560: CALL_OW 2
1564: ST_TO_ADDR
// if Cyrus then
1565: LD_EXP 38
1569: IFFALSE 1600
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1571: LD_ADDR_VAR 0 4
1575: PUSH
1576: LD_VAR 0 4
1580: PPUSH
1581: LD_VAR 0 4
1585: PUSH
1586: LD_INT 1
1588: PLUS
1589: PPUSH
1590: LD_EXP 38
1594: PPUSH
1595: CALL_OW 2
1599: ST_TO_ADDR
// if Lisa then
1600: LD_EXP 39
1604: IFFALSE 1635
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1606: LD_ADDR_VAR 0 4
1610: PUSH
1611: LD_VAR 0 4
1615: PPUSH
1616: LD_VAR 0 4
1620: PUSH
1621: LD_INT 1
1623: PLUS
1624: PPUSH
1625: LD_EXP 39
1629: PPUSH
1630: CALL_OW 2
1634: ST_TO_ADDR
// if Khatam then
1635: LD_EXP 40
1639: IFFALSE 1670
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1641: LD_ADDR_VAR 0 4
1645: PUSH
1646: LD_VAR 0 4
1650: PPUSH
1651: LD_VAR 0 4
1655: PUSH
1656: LD_INT 1
1658: PLUS
1659: PPUSH
1660: LD_EXP 40
1664: PPUSH
1665: CALL_OW 2
1669: ST_TO_ADDR
// if Brian then
1670: LD_EXP 41
1674: IFFALSE 1705
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1676: LD_ADDR_VAR 0 4
1680: PUSH
1681: LD_VAR 0 4
1685: PPUSH
1686: LD_VAR 0 4
1690: PUSH
1691: LD_INT 1
1693: PLUS
1694: PPUSH
1695: LD_EXP 41
1699: PPUSH
1700: CALL_OW 2
1704: ST_TO_ADDR
// if Jerry then
1705: LD_EXP 42
1709: IFFALSE 1740
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1711: LD_ADDR_VAR 0 4
1715: PUSH
1716: LD_VAR 0 4
1720: PPUSH
1721: LD_VAR 0 4
1725: PUSH
1726: LD_INT 1
1728: PLUS
1729: PPUSH
1730: LD_EXP 42
1734: PPUSH
1735: CALL_OW 2
1739: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1740: LD_STRING 02_other_survivors
1742: PPUSH
1743: CALL_OW 28
1747: IFFALSE 1762
// others := CreateCharacterSet ( 02_other_survivors ) ;
1749: LD_ADDR_VAR 0 5
1753: PUSH
1754: LD_STRING 02_other_survivors
1756: PPUSH
1757: CALL_OW 31
1761: ST_TO_ADDR
// if others then
1762: LD_VAR 0 5
1766: IFFALSE 1791
// begin tmp := tmp ^ others ;
1768: LD_ADDR_VAR 0 4
1772: PUSH
1773: LD_VAR 0 4
1777: PUSH
1778: LD_VAR 0 5
1782: ADD
1783: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1784: LD_STRING 02_other_survivors
1786: PPUSH
1787: CALL_OW 40
// end ; jmm_units := tmp ;
1791: LD_ADDR_EXP 4
1795: PUSH
1796: LD_VAR 0 4
1800: ST_TO_ADDR
// if not vehicles then
1801: LD_VAR 0 6
1805: NOT
1806: IFFALSE 1824
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1808: LD_ADDR_VAR 0 6
1812: PUSH
1813: LD_STRING 02_tanks_1
1815: PPUSH
1816: LD_INT 0
1818: PPUSH
1819: CALL_OW 30
1823: ST_TO_ADDR
// if vehicles then
1824: LD_VAR 0 6
1828: IFFALSE 2022
// begin got_mech := false ;
1830: LD_ADDR_VAR 0 7
1834: PUSH
1835: LD_INT 0
1837: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1838: LD_VAR 0 4
1842: PPUSH
1843: LD_INT 25
1845: PUSH
1846: LD_INT 3
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: PPUSH
1853: CALL_OW 72
1857: IFFALSE 1867
// got_mech := true ;
1859: LD_ADDR_VAR 0 7
1863: PUSH
1864: LD_INT 1
1866: ST_TO_ADDR
// for i = 1 to vehicles do
1867: LD_ADDR_VAR 0 2
1871: PUSH
1872: DOUBLE
1873: LD_INT 1
1875: DEC
1876: ST_TO_ADDR
1877: LD_VAR 0 6
1881: PUSH
1882: FOR_TO
1883: IFFALSE 2020
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1885: LD_ADDR_VAR 0 3
1889: PUSH
1890: LD_INT 1
1892: PPUSH
1893: LD_INT 3
1895: PPUSH
1896: LD_VAR 0 6
1900: PUSH
1901: LD_VAR 0 2
1905: ARRAY
1906: PUSH
1907: LD_INT 1
1909: ARRAY
1910: PPUSH
1911: LD_VAR 0 6
1915: PUSH
1916: LD_VAR 0 2
1920: ARRAY
1921: PUSH
1922: LD_INT 2
1924: ARRAY
1925: PPUSH
1926: LD_VAR 0 6
1930: PUSH
1931: LD_VAR 0 2
1935: ARRAY
1936: PUSH
1937: LD_INT 3
1939: ARRAY
1940: PPUSH
1941: LD_VAR 0 6
1945: PUSH
1946: LD_VAR 0 2
1950: ARRAY
1951: PUSH
1952: LD_INT 4
1954: ARRAY
1955: PPUSH
1956: LD_INT 40
1958: PPUSH
1959: CALL 537 0 7
1963: ST_TO_ADDR
// if not got_mech then
1964: LD_VAR 0 7
1968: NOT
1969: IFFALSE 1995
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1971: LD_VAR 0 3
1975: PPUSH
1976: LD_VAR 0 6
1980: PUSH
1981: LD_VAR 0 2
1985: ARRAY
1986: PUSH
1987: LD_INT 6
1989: ARRAY
1990: PPUSH
1991: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1995: LD_ADDR_VAR 0 4
1999: PUSH
2000: LD_VAR 0 4
2004: PPUSH
2005: LD_INT 1
2007: PPUSH
2008: LD_VAR 0 3
2012: PPUSH
2013: CALL_OW 2
2017: ST_TO_ADDR
// end ;
2018: GO 1882
2020: POP
2021: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
2022: LD_EXP 36
2026: PPUSH
2027: LD_INT 194
2029: PPUSH
2030: LD_INT 119
2032: PPUSH
2033: LD_INT 0
2035: PPUSH
2036: CALL_OW 48
// if tmp then
2040: LD_VAR 0 4
2044: IFFALSE 2169
// begin for i in tmp do
2046: LD_ADDR_VAR 0 2
2050: PUSH
2051: LD_VAR 0 4
2055: PUSH
2056: FOR_IN
2057: IFFALSE 2167
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2059: LD_ADDR_VAR 0 8
2063: PUSH
2064: LD_INT 22
2066: PUSH
2067: LD_INT 1
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: PUSH
2074: LD_INT 21
2076: PUSH
2077: LD_INT 2
2079: PUSH
2080: EMPTY
2081: LIST
2082: LIST
2083: PUSH
2084: LD_INT 58
2086: PUSH
2087: EMPTY
2088: LIST
2089: PUSH
2090: EMPTY
2091: LIST
2092: LIST
2093: LIST
2094: PPUSH
2095: CALL_OW 69
2099: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2100: LD_VAR 0 2
2104: PPUSH
2105: CALL_OW 247
2109: PUSH
2110: LD_INT 1
2112: EQUAL
2113: PUSH
2114: LD_VAR 0 8
2118: AND
2119: IFFALSE 2141
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2121: LD_VAR 0 2
2125: PPUSH
2126: LD_VAR 0 8
2130: PUSH
2131: LD_INT 1
2133: ARRAY
2134: PPUSH
2135: CALL_OW 52
2139: GO 2156
// PlaceUnitArea ( i , startArea , false ) ;
2141: LD_VAR 0 2
2145: PPUSH
2146: LD_INT 1
2148: PPUSH
2149: LD_INT 0
2151: PPUSH
2152: CALL_OW 49
// ComHold ( i ) ;
2156: LD_VAR 0 2
2160: PPUSH
2161: CALL_OW 140
// end ;
2165: GO 2056
2167: POP
2168: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2169: LD_ADDR_EXP 7
2173: PUSH
2174: LD_STRING 02_mikhailStatus_1
2176: PPUSH
2177: LD_INT 0
2179: PPUSH
2180: CALL_OW 30
2184: ST_TO_ADDR
// if not bierezov_exist and not debug then
2185: LD_EXP 7
2189: NOT
2190: PUSH
2191: LD_EXP 1
2195: NOT
2196: AND
2197: IFFALSE 2201
// exit ;
2199: GO 2232
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2201: LD_ADDR_EXP 44
2205: PUSH
2206: LD_STRING Mikhail
2208: PPUSH
2209: LD_INT 0
2211: PPUSH
2212: CALL 474 0 2
2216: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2217: LD_EXP 44
2221: PPUSH
2222: LD_INT 1
2224: PPUSH
2225: LD_INT 0
2227: PPUSH
2228: CALL_OW 49
// end ;
2232: LD_VAR 0 1
2236: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2237: LD_INT 0
2239: PPUSH
2240: PPUSH
2241: PPUSH
2242: PPUSH
// uc_side := 4 ;
2243: LD_ADDR_OWVAR 20
2247: PUSH
2248: LD_INT 4
2250: ST_TO_ADDR
// uc_nation := 1 ;
2251: LD_ADDR_OWVAR 21
2255: PUSH
2256: LD_INT 1
2258: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2259: LD_ADDR_EXP 43
2263: PUSH
2264: LD_STRING Cornell
2266: PPUSH
2267: LD_INT 0
2269: PPUSH
2270: CALL 474 0 2
2274: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2275: LD_ADDR_EXP 6
2279: PUSH
2280: LD_INT 9
2282: PUSH
2283: LD_EXP 4
2287: MINUS
2288: ST_TO_ADDR
// tmp := [ ] ;
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: EMPTY
2295: ST_TO_ADDR
// if cornel_units < 4 then
2296: LD_EXP 6
2300: PUSH
2301: LD_INT 4
2303: LESS
2304: IFFALSE 2314
// cornel_units := 4 ;
2306: LD_ADDR_EXP 6
2310: PUSH
2311: LD_INT 4
2313: ST_TO_ADDR
// for i = 1 to cornel_units do
2314: LD_ADDR_VAR 0 4
2318: PUSH
2319: DOUBLE
2320: LD_INT 1
2322: DEC
2323: ST_TO_ADDR
2324: LD_EXP 6
2328: PUSH
2329: FOR_TO
2330: IFFALSE 2428
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2332: LD_INT 0
2334: PPUSH
2335: LD_INT 1
2337: PUSH
2338: LD_INT 1
2340: PUSH
2341: LD_INT 1
2343: PUSH
2344: LD_INT 2
2346: PUSH
2347: LD_INT 4
2349: PUSH
2350: EMPTY
2351: LIST
2352: LIST
2353: LIST
2354: LIST
2355: LIST
2356: PUSH
2357: LD_VAR 0 4
2361: PUSH
2362: LD_INT 5
2364: MOD
2365: PUSH
2366: LD_INT 1
2368: PLUS
2369: ARRAY
2370: PPUSH
2371: LD_INT 2
2373: PPUSH
2374: CALL_OW 380
// un := CreateHuman ;
2378: LD_ADDR_VAR 0 3
2382: PUSH
2383: CALL_OW 44
2387: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2388: LD_ADDR_VAR 0 2
2392: PUSH
2393: LD_VAR 0 2
2397: PPUSH
2398: LD_INT 1
2400: PPUSH
2401: LD_VAR 0 3
2405: PPUSH
2406: CALL_OW 2
2410: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2411: LD_VAR 0 3
2415: PPUSH
2416: LD_INT 2
2418: PPUSH
2419: LD_INT 0
2421: PPUSH
2422: CALL_OW 49
// end ;
2426: GO 2329
2428: POP
2429: POP
// cornel_units := tmp ;
2430: LD_ADDR_EXP 6
2434: PUSH
2435: LD_VAR 0 2
2439: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2440: LD_EXP 43
2444: PPUSH
2445: LD_INT 191
2447: PPUSH
2448: LD_INT 106
2450: PPUSH
2451: LD_INT 0
2453: PPUSH
2454: CALL_OW 48
// end ;
2458: LD_VAR 0 1
2462: RET
// export function PrepareWesternBase ; var i ; begin
2463: LD_INT 0
2465: PPUSH
2466: PPUSH
// uc_side := 8 ;
2467: LD_ADDR_OWVAR 20
2471: PUSH
2472: LD_INT 8
2474: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2475: LD_ADDR_EXP 46
2479: PUSH
2480: LD_STRING Lynch
2482: PPUSH
2483: LD_INT 0
2485: PPUSH
2486: CALL 474 0 2
2490: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2491: LD_ADDR_EXP 47
2495: PUSH
2496: LD_STRING Walker
2498: PPUSH
2499: LD_INT 0
2501: PPUSH
2502: CALL 474 0 2
2506: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2507: LD_ADDR_EXP 48
2511: PUSH
2512: LD_STRING Turner
2514: PPUSH
2515: LD_INT 0
2517: PPUSH
2518: CALL 474 0 2
2522: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2523: LD_ADDR_EXP 49
2527: PUSH
2528: LD_STRING Jillian
2530: PPUSH
2531: LD_INT 0
2533: PPUSH
2534: CALL 474 0 2
2538: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2539: LD_ADDR_VAR 0 2
2543: PUSH
2544: LD_EXP 46
2548: PUSH
2549: LD_EXP 47
2553: PUSH
2554: LD_EXP 48
2558: PUSH
2559: LD_EXP 49
2563: PUSH
2564: EMPTY
2565: LIST
2566: LIST
2567: LIST
2568: LIST
2569: PUSH
2570: FOR_IN
2571: IFFALSE 2599
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2573: LD_VAR 0 2
2577: PPUSH
2578: LD_INT 3
2580: PPUSH
2581: LD_INT 0
2583: PPUSH
2584: CALL_OW 49
// ComHold ( i ) ;
2588: LD_VAR 0 2
2592: PPUSH
2593: CALL_OW 140
// end ;
2597: GO 2570
2599: POP
2600: POP
// end ;
2601: LD_VAR 0 1
2605: RET
// export function SelectGroup ; var units , selected , i ; begin
2606: LD_INT 0
2608: PPUSH
2609: PPUSH
2610: PPUSH
2611: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2612: LD_ADDR_VAR 0 2
2616: PUSH
2617: LD_EXP 36
2621: PUSH
2622: LD_INT -3
2624: PUSH
2625: EMPTY
2626: LIST
2627: LIST
2628: PUSH
2629: LD_EXP 4
2633: ADD
2634: PUSH
2635: LD_INT -2
2637: PUSH
2638: LD_INT -4
2640: PUSH
2641: LD_EXP 43
2645: PUSH
2646: LD_EXP 44
2650: PUSH
2651: EMPTY
2652: LIST
2653: LIST
2654: LIST
2655: LIST
2656: ADD
2657: PUSH
2658: LD_INT -3
2660: PUSH
2661: EMPTY
2662: LIST
2663: ADD
2664: PUSH
2665: LD_EXP 6
2669: ADD
2670: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: LD_EXP 36
2680: PUSH
2681: LD_STRING Select five characters to go with you
2683: PPUSH
2684: LD_INT 4
2686: PPUSH
2687: LD_INT 4
2689: PPUSH
2690: LD_VAR 0 2
2694: PPUSH
2695: EMPTY
2696: PPUSH
2697: CALL_OW 42
2701: ADD
2702: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2703: LD_ADDR_EXP 6
2707: PUSH
2708: LD_EXP 4
2712: PUSH
2713: LD_EXP 6
2717: UNION
2718: PUSH
2719: LD_VAR 0 3
2723: DIFF
2724: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2725: LD_ADDR_VAR 0 4
2729: PUSH
2730: LD_EXP 6
2734: PUSH
2735: LD_EXP 44
2739: ADD
2740: PUSH
2741: FOR_IN
2742: IFFALSE 2773
// if GetSide ( i ) = 1 then
2744: LD_VAR 0 4
2748: PPUSH
2749: CALL_OW 255
2753: PUSH
2754: LD_INT 1
2756: EQUAL
2757: IFFALSE 2771
// SetSide ( i , 4 ) ;
2759: LD_VAR 0 4
2763: PPUSH
2764: LD_INT 4
2766: PPUSH
2767: CALL_OW 235
2771: GO 2741
2773: POP
2774: POP
// for i in selected do
2775: LD_ADDR_VAR 0 4
2779: PUSH
2780: LD_VAR 0 3
2784: PUSH
2785: FOR_IN
2786: IFFALSE 2817
// if GetSide ( i ) = 4 then
2788: LD_VAR 0 4
2792: PPUSH
2793: CALL_OW 255
2797: PUSH
2798: LD_INT 4
2800: EQUAL
2801: IFFALSE 2815
// SetSide ( i , 1 ) ;
2803: LD_VAR 0 4
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: CALL_OW 235
2815: GO 2785
2817: POP
2818: POP
// jmm_units := jmm_units diff cornel_units ;
2819: LD_ADDR_EXP 4
2823: PUSH
2824: LD_EXP 4
2828: PUSH
2829: LD_EXP 6
2833: DIFF
2834: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2835: LD_EXP 37
2839: PPUSH
2840: CALL_OW 255
2844: PUSH
2845: LD_INT 4
2847: EQUAL
2848: IFFALSE 2863
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2850: LD_EXP 3
2854: PUSH
2855: LD_STRING Bobby
2857: STR
2858: PPUSH
2859: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2863: LD_EXP 38
2867: PPUSH
2868: CALL_OW 255
2872: PUSH
2873: LD_INT 4
2875: EQUAL
2876: IFFALSE 2891
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2878: LD_EXP 3
2882: PUSH
2883: LD_STRING Cyrus
2885: STR
2886: PPUSH
2887: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2891: LD_EXP 39
2895: PPUSH
2896: CALL_OW 255
2900: PUSH
2901: LD_INT 4
2903: EQUAL
2904: IFFALSE 2919
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2906: LD_EXP 3
2910: PUSH
2911: LD_STRING Lisa
2913: STR
2914: PPUSH
2915: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2919: LD_EXP 40
2923: PPUSH
2924: CALL_OW 255
2928: PUSH
2929: LD_INT 4
2931: EQUAL
2932: IFFALSE 2947
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
2934: LD_EXP 3
2938: PUSH
2939: LD_STRING Khatam
2941: STR
2942: PPUSH
2943: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2947: LD_EXP 41
2951: PPUSH
2952: CALL_OW 255
2956: PUSH
2957: LD_INT 4
2959: EQUAL
2960: IFFALSE 2975
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
2962: LD_EXP 3
2966: PUSH
2967: LD_STRING Brian
2969: STR
2970: PPUSH
2971: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2975: LD_EXP 42
2979: PPUSH
2980: CALL_OW 255
2984: PUSH
2985: LD_INT 4
2987: EQUAL
2988: IFFALSE 3003
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
2990: LD_EXP 3
2994: PUSH
2995: LD_STRING Jerry
2997: STR
2998: PPUSH
2999: CALL_OW 40
// end ; end_of_file
3003: LD_VAR 0 1
3007: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
3008: LD_INT 0
3010: PPUSH
3011: PPUSH
3012: PPUSH
3013: PPUSH
3014: PPUSH
3015: PPUSH
3016: PPUSH
3017: PPUSH
3018: PPUSH
3019: PPUSH
3020: PPUSH
3021: PPUSH
3022: PPUSH
// ru_alert := false ;
3023: LD_ADDR_EXP 59
3027: PUSH
3028: LD_INT 0
3030: ST_TO_ADDR
// ru_produce_list := [ ] ;
3031: LD_ADDR_EXP 56
3035: PUSH
3036: EMPTY
3037: ST_TO_ADDR
// if Difficulty > 1 then
3038: LD_OWVAR 67
3042: PUSH
3043: LD_INT 1
3045: GREATER
3046: IFFALSE 3134
// begin uc_side := 3 ;
3048: LD_ADDR_OWVAR 20
3052: PUSH
3053: LD_INT 3
3055: ST_TO_ADDR
// uc_nation := 3 ;
3056: LD_ADDR_OWVAR 21
3060: PUSH
3061: LD_INT 3
3063: ST_TO_ADDR
// bc_type := b_breastwork ;
3064: LD_ADDR_OWVAR 42
3068: PUSH
3069: LD_INT 31
3071: ST_TO_ADDR
// bc_level := Difficulty ;
3072: LD_ADDR_OWVAR 43
3076: PUSH
3077: LD_OWVAR 67
3081: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3082: LD_INT 22
3084: PPUSH
3085: LD_INT 14
3087: PPUSH
3088: LD_INT 0
3090: PPUSH
3091: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3095: LD_INT 48
3097: PPUSH
3098: LD_INT 46
3100: PPUSH
3101: LD_INT 0
3103: PPUSH
3104: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3108: LD_INT 86
3110: PPUSH
3111: LD_INT 65
3113: PPUSH
3114: LD_INT 5
3116: PPUSH
3117: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3121: LD_INT 165
3123: PPUSH
3124: LD_INT 73
3126: PPUSH
3127: LD_INT 5
3129: PPUSH
3130: CALL_OW 47
// end ; if Difficulty = 3 then
3134: LD_OWVAR 67
3138: PUSH
3139: LD_INT 3
3141: EQUAL
3142: IFFALSE 3157
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3144: LD_INT 51
3146: PPUSH
3147: LD_INT 3
3149: PPUSH
3150: LD_INT 2
3152: PPUSH
3153: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3157: LD_ADDR_VAR 0 7
3161: PUSH
3162: LD_INT 22
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: EMPTY
3169: LIST
3170: LIST
3171: PUSH
3172: LD_INT 2
3174: PUSH
3175: LD_INT 30
3177: PUSH
3178: LD_INT 31
3180: PUSH
3181: EMPTY
3182: LIST
3183: LIST
3184: PUSH
3185: LD_INT 30
3187: PUSH
3188: LD_INT 32
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: LIST
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: PPUSH
3204: CALL_OW 69
3208: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3209: LD_ADDR_VAR 0 8
3213: PUSH
3214: LD_INT 22
3216: PUSH
3217: LD_INT 3
3219: PUSH
3220: EMPTY
3221: LIST
3222: LIST
3223: PUSH
3224: LD_INT 30
3226: PUSH
3227: LD_INT 4
3229: PUSH
3230: EMPTY
3231: LIST
3232: LIST
3233: PUSH
3234: EMPTY
3235: LIST
3236: LIST
3237: PPUSH
3238: CALL_OW 69
3242: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3243: LD_ADDR_VAR 0 10
3247: PUSH
3248: LD_INT 22
3250: PUSH
3251: LD_INT 3
3253: PUSH
3254: EMPTY
3255: LIST
3256: LIST
3257: PUSH
3258: LD_INT 30
3260: PUSH
3261: LD_INT 3
3263: PUSH
3264: EMPTY
3265: LIST
3266: LIST
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: PPUSH
3272: CALL_OW 69
3276: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3277: LD_ADDR_VAR 0 9
3281: PUSH
3282: LD_INT 22
3284: PUSH
3285: LD_INT 3
3287: PUSH
3288: EMPTY
3289: LIST
3290: LIST
3291: PUSH
3292: LD_INT 30
3294: PUSH
3295: LD_INT 6
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: PPUSH
3306: CALL_OW 69
3310: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3311: LD_ADDR_VAR 0 2
3315: PUSH
3316: LD_INT 22
3318: PUSH
3319: LD_INT 3
3321: PUSH
3322: EMPTY
3323: LIST
3324: LIST
3325: PUSH
3326: LD_INT 30
3328: PUSH
3329: LD_INT 1
3331: PUSH
3332: EMPTY
3333: LIST
3334: LIST
3335: PUSH
3336: EMPTY
3337: LIST
3338: LIST
3339: PPUSH
3340: CALL_OW 69
3344: PUSH
3345: FOR_IN
3346: IFFALSE 3390
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3348: LD_VAR 0 2
3352: PPUSH
3353: CALL_OW 274
3357: PPUSH
3358: LD_INT 1
3360: PPUSH
3361: LD_INT 5000
3363: PPUSH
3364: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3368: LD_VAR 0 2
3372: PPUSH
3373: CALL_OW 274
3377: PPUSH
3378: LD_INT 2
3380: PPUSH
3381: LD_INT 3000
3383: PPUSH
3384: CALL_OW 277
// end ;
3388: GO 3345
3390: POP
3391: POP
// uc_side := 3 ;
3392: LD_ADDR_OWVAR 20
3396: PUSH
3397: LD_INT 3
3399: ST_TO_ADDR
// uc_nation := 3 ;
3400: LD_ADDR_OWVAR 21
3404: PUSH
3405: LD_INT 3
3407: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3408: LD_ADDR_VAR 0 11
3412: PUSH
3413: LD_INT 2
3415: PUSH
3416: LD_INT 3
3418: PUSH
3419: LD_INT 4
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: LIST
3426: PUSH
3427: LD_OWVAR 67
3431: ARRAY
3432: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3433: LD_ADDR_EXP 51
3437: PUSH
3438: LD_STRING Pokryshkin
3440: PPUSH
3441: LD_INT 0
3443: PPUSH
3444: CALL 474 0 2
3448: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3449: LD_EXP 51
3453: PPUSH
3454: LD_INT 63
3456: PPUSH
3457: LD_INT 21
3459: PPUSH
3460: LD_INT 0
3462: PPUSH
3463: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3467: LD_EXP 51
3471: PPUSH
3472: CALL_OW 140
// InitHc ;
3476: CALL_OW 19
// for i in fac do
3480: LD_ADDR_VAR 0 2
3484: PUSH
3485: LD_VAR 0 10
3489: PUSH
3490: FOR_IN
3491: IFFALSE 3544
// begin for j = 1 to 6 do
3493: LD_ADDR_VAR 0 3
3497: PUSH
3498: DOUBLE
3499: LD_INT 1
3501: DEC
3502: ST_TO_ADDR
3503: LD_INT 6
3505: PUSH
3506: FOR_TO
3507: IFFALSE 3540
// begin PrepareHuman ( false , 3 , skill ) ;
3509: LD_INT 0
3511: PPUSH
3512: LD_INT 3
3514: PPUSH
3515: LD_VAR 0 11
3519: PPUSH
3520: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3524: CALL_OW 44
3528: PPUSH
3529: LD_VAR 0 2
3533: PPUSH
3534: CALL_OW 52
// end ;
3538: GO 3506
3540: POP
3541: POP
// end ;
3542: GO 3490
3544: POP
3545: POP
// for i in lab do
3546: LD_ADDR_VAR 0 2
3550: PUSH
3551: LD_VAR 0 9
3555: PUSH
3556: FOR_IN
3557: IFFALSE 3590
// begin PrepareHuman ( false , 4 , skill ) ;
3559: LD_INT 0
3561: PPUSH
3562: LD_INT 4
3564: PPUSH
3565: LD_VAR 0 11
3569: PPUSH
3570: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3574: CALL_OW 44
3578: PPUSH
3579: LD_VAR 0 2
3583: PPUSH
3584: CALL_OW 52
// end ;
3588: GO 3556
3590: POP
3591: POP
// for i in tw do
3592: LD_ADDR_VAR 0 2
3596: PUSH
3597: LD_VAR 0 7
3601: PUSH
3602: FOR_IN
3603: IFFALSE 3652
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3605: LD_VAR 0 2
3609: PPUSH
3610: LD_INT 42
3612: PUSH
3613: LD_INT 43
3615: PUSH
3616: EMPTY
3617: LIST
3618: LIST
3619: PUSH
3620: LD_INT 1
3622: PPUSH
3623: LD_INT 2
3625: PPUSH
3626: CALL_OW 12
3630: ARRAY
3631: PPUSH
3632: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3636: LD_VAR 0 11
3640: PPUSH
3641: LD_VAR 0 2
3645: PPUSH
3646: CALL 815 0 2
// end ;
3650: GO 3602
3652: POP
3653: POP
// for i in bar do
3654: LD_ADDR_VAR 0 2
3658: PUSH
3659: LD_VAR 0 8
3663: PUSH
3664: FOR_IN
3665: IFFALSE 3698
// begin PrepareHuman ( false , 1 , skill ) ;
3667: LD_INT 0
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: LD_VAR 0 11
3677: PPUSH
3678: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3682: CALL_OW 44
3686: PPUSH
3687: LD_VAR 0 2
3691: PPUSH
3692: CALL_OW 52
// end ;
3696: GO 3664
3698: POP
3699: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3700: LD_ADDR_VAR 0 13
3704: PUSH
3705: LD_INT 100
3707: PUSH
3708: LD_INT 9
3710: PUSH
3711: EMPTY
3712: LIST
3713: LIST
3714: PUSH
3715: LD_INT 135
3717: PUSH
3718: LD_INT 60
3720: PUSH
3721: EMPTY
3722: LIST
3723: LIST
3724: PUSH
3725: LD_INT 41
3727: PUSH
3728: LD_INT 6
3730: PUSH
3731: EMPTY
3732: LIST
3733: LIST
3734: PUSH
3735: LD_INT 22
3737: PUSH
3738: LD_INT 9
3740: PUSH
3741: EMPTY
3742: LIST
3743: LIST
3744: PUSH
3745: LD_INT 84
3747: PUSH
3748: LD_INT 14
3750: PUSH
3751: EMPTY
3752: LIST
3753: LIST
3754: PUSH
3755: EMPTY
3756: LIST
3757: LIST
3758: LIST
3759: LIST
3760: LIST
3761: ST_TO_ADDR
// vehicles := [ ] ;
3762: LD_ADDR_VAR 0 12
3766: PUSH
3767: EMPTY
3768: ST_TO_ADDR
// for i in spot_xy do
3769: LD_ADDR_VAR 0 2
3773: PUSH
3774: LD_VAR 0 13
3778: PUSH
3779: FOR_IN
3780: IFFALSE 3938
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3782: LD_ADDR_VAR 0 6
3786: PUSH
3787: LD_INT 3
3789: PPUSH
3790: LD_INT 3
3792: PPUSH
3793: LD_INT 22
3795: PPUSH
3796: LD_INT 1
3798: PPUSH
3799: LD_INT 1
3801: PPUSH
3802: LD_INT 42
3804: PUSH
3805: LD_INT 43
3807: PUSH
3808: LD_INT 44
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: LIST
3815: PUSH
3816: LD_INT 1
3818: PPUSH
3819: LD_INT 3
3821: PPUSH
3822: CALL_OW 12
3826: ARRAY
3827: PPUSH
3828: LD_INT 100
3830: PPUSH
3831: CALL 537 0 7
3835: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3836: LD_ADDR_VAR 0 12
3840: PUSH
3841: LD_VAR 0 12
3845: PPUSH
3846: LD_VAR 0 12
3850: PUSH
3851: LD_INT 1
3853: PLUS
3854: PPUSH
3855: LD_VAR 0 6
3859: PPUSH
3860: CALL_OW 2
3864: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3865: LD_VAR 0 6
3869: PPUSH
3870: LD_INT 3
3872: PPUSH
3873: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3877: LD_VAR 0 6
3881: PPUSH
3882: LD_VAR 0 2
3886: PUSH
3887: LD_INT 1
3889: ARRAY
3890: PPUSH
3891: LD_VAR 0 2
3895: PUSH
3896: LD_INT 2
3898: ARRAY
3899: PPUSH
3900: LD_INT 0
3902: PPUSH
3903: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3907: LD_INT 0
3909: PPUSH
3910: LD_INT 3
3912: PPUSH
3913: LD_VAR 0 11
3917: PPUSH
3918: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3922: CALL_OW 44
3926: PPUSH
3927: LD_VAR 0 6
3931: PPUSH
3932: CALL_OW 52
// end ;
3936: GO 3779
3938: POP
3939: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3940: LD_ADDR_VAR 0 2
3944: PUSH
3945: DOUBLE
3946: LD_INT 1
3948: DEC
3949: ST_TO_ADDR
3950: LD_INT 5
3952: PUSH
3953: LD_INT 7
3955: PUSH
3956: LD_INT 8
3958: PUSH
3959: EMPTY
3960: LIST
3961: LIST
3962: LIST
3963: PUSH
3964: LD_OWVAR 67
3968: ARRAY
3969: PUSH
3970: FOR_TO
3971: IFFALSE 4031
// begin PrepareHuman ( false , 1 , skill ) ;
3973: LD_INT 0
3975: PPUSH
3976: LD_INT 1
3978: PPUSH
3979: LD_VAR 0 11
3983: PPUSH
3984: CALL_OW 380
// un := CreateHuman ;
3988: LD_ADDR_VAR 0 5
3992: PUSH
3993: CALL_OW 44
3997: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3998: LD_VAR 0 5
4002: PPUSH
4003: LD_INT 11
4005: PPUSH
4006: LD_INT 0
4008: PPUSH
4009: CALL_OW 49
// ru_forest := ru_forest ^ un ;
4013: LD_ADDR_EXP 54
4017: PUSH
4018: LD_EXP 54
4022: PUSH
4023: LD_VAR 0 5
4027: ADD
4028: ST_TO_ADDR
// end ;
4029: GO 3970
4031: POP
4032: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
4033: LD_ADDR_VAR 0 2
4037: PUSH
4038: DOUBLE
4039: LD_INT 1
4041: DEC
4042: ST_TO_ADDR
4043: LD_INT 2
4045: PUSH
4046: LD_INT 3
4048: PUSH
4049: LD_INT 4
4051: PUSH
4052: EMPTY
4053: LIST
4054: LIST
4055: LIST
4056: PUSH
4057: LD_OWVAR 67
4061: ARRAY
4062: PUSH
4063: FOR_TO
4064: IFFALSE 4124
// begin PrepareHuman ( false , 1 , skill ) ;
4066: LD_INT 0
4068: PPUSH
4069: LD_INT 1
4071: PPUSH
4072: LD_VAR 0 11
4076: PPUSH
4077: CALL_OW 380
// un := CreateHuman ;
4081: LD_ADDR_VAR 0 5
4085: PUSH
4086: CALL_OW 44
4090: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4091: LD_VAR 0 5
4095: PPUSH
4096: LD_INT 12
4098: PPUSH
4099: LD_INT 0
4101: PPUSH
4102: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4106: LD_ADDR_EXP 52
4110: PUSH
4111: LD_EXP 52
4115: PUSH
4116: LD_VAR 0 5
4120: ADD
4121: ST_TO_ADDR
// end ;
4122: GO 4063
4124: POP
4125: POP
// for i = 1 to 2 do
4126: LD_ADDR_VAR 0 2
4130: PUSH
4131: DOUBLE
4132: LD_INT 1
4134: DEC
4135: ST_TO_ADDR
4136: LD_INT 2
4138: PUSH
4139: FOR_TO
4140: IFFALSE 4206
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4142: LD_INT 1
4144: PPUSH
4145: LD_INT 1
4147: PPUSH
4148: LD_VAR 0 11
4152: PPUSH
4153: CALL_OW 380
// un := CreateHuman ;
4157: LD_ADDR_VAR 0 5
4161: PUSH
4162: CALL_OW 44
4166: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4167: LD_VAR 0 5
4171: PPUSH
4172: LD_INT 39
4174: PPUSH
4175: LD_INT 12
4177: PPUSH
4178: LD_INT 3
4180: PPUSH
4181: LD_INT 0
4183: PPUSH
4184: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4188: LD_ADDR_EXP 53
4192: PUSH
4193: LD_EXP 53
4197: PUSH
4198: LD_VAR 0 5
4202: ADD
4203: ST_TO_ADDR
// end ;
4204: GO 4139
4206: POP
4207: POP
// for i = 1 to 3 do
4208: LD_ADDR_VAR 0 2
4212: PUSH
4213: DOUBLE
4214: LD_INT 1
4216: DEC
4217: ST_TO_ADDR
4218: LD_INT 3
4220: PUSH
4221: FOR_TO
4222: IFFALSE 4288
// begin PrepareHuman ( false , 1 , skill ) ;
4224: LD_INT 0
4226: PPUSH
4227: LD_INT 1
4229: PPUSH
4230: LD_VAR 0 11
4234: PPUSH
4235: CALL_OW 380
// un := CreateHuman ;
4239: LD_ADDR_VAR 0 5
4243: PUSH
4244: CALL_OW 44
4248: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4249: LD_VAR 0 5
4253: PPUSH
4254: LD_INT 180
4256: PPUSH
4257: LD_INT 11
4259: PPUSH
4260: LD_INT 4
4262: PPUSH
4263: LD_INT 0
4265: PPUSH
4266: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4270: LD_ADDR_EXP 57
4274: PUSH
4275: LD_EXP 57
4279: PUSH
4280: LD_VAR 0 5
4284: ADD
4285: ST_TO_ADDR
// end ;
4286: GO 4221
4288: POP
4289: POP
// ru_vehicles := vehicles ;
4290: LD_ADDR_EXP 55
4294: PUSH
4295: LD_VAR 0 12
4299: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4300: LD_ADDR_EXP 58
4304: PUSH
4305: LD_INT 131
4307: PUSH
4308: LD_INT 121
4310: PUSH
4311: EMPTY
4312: LIST
4313: LIST
4314: PUSH
4315: LD_INT 113
4317: PUSH
4318: LD_INT 90
4320: PUSH
4321: EMPTY
4322: LIST
4323: LIST
4324: PUSH
4325: LD_INT 93
4327: PUSH
4328: LD_INT 62
4330: PUSH
4331: EMPTY
4332: LIST
4333: LIST
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: LIST
4339: PUSH
4340: LD_INT 106
4342: PUSH
4343: LD_INT 54
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 120
4352: PUSH
4353: LD_INT 80
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: LD_INT 143
4362: PUSH
4363: LD_INT 120
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: LIST
4374: PUSH
4375: LD_INT 154
4377: PUSH
4378: LD_INT 116
4380: PUSH
4381: EMPTY
4382: LIST
4383: LIST
4384: PUSH
4385: LD_INT 140
4387: PUSH
4388: LD_INT 93
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 130
4397: PUSH
4398: LD_INT 58
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: LIST
4409: PUSH
4410: LD_INT 105
4412: PUSH
4413: LD_INT 106
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: LD_INT 134
4422: PUSH
4423: LD_INT 98
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 159
4432: PUSH
4433: LD_INT 113
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: LIST
4444: PUSH
4445: EMPTY
4446: LIST
4447: LIST
4448: LIST
4449: LIST
4450: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4451: LD_ADDR_VAR 0 2
4455: PUSH
4456: DOUBLE
4457: LD_INT 1
4459: DEC
4460: ST_TO_ADDR
4461: LD_OWVAR 67
4465: PUSH
4466: LD_INT 1
4468: MINUS
4469: PUSH
4470: FOR_TO
4471: IFFALSE 4504
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4473: LD_ADDR_EXP 56
4477: PUSH
4478: LD_EXP 56
4482: PUSH
4483: LD_INT 22
4485: PUSH
4486: LD_INT 1
4488: PUSH
4489: LD_INT 1
4491: PUSH
4492: LD_INT 43
4494: PUSH
4495: EMPTY
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: ADD
4501: ST_TO_ADDR
4502: GO 4470
4504: POP
4505: POP
// end ;
4506: LD_VAR 0 1
4510: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4511: LD_INT 22
4513: PUSH
4514: LD_INT 3
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: PUSH
4521: LD_INT 21
4523: PUSH
4524: LD_INT 2
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: PUSH
4531: EMPTY
4532: LIST
4533: LIST
4534: PPUSH
4535: CALL_OW 69
4539: IFFALSE 4633
4541: GO 4543
4543: DISABLE
4544: LD_INT 0
4546: PPUSH
4547: PPUSH
// begin enable ;
4548: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4549: LD_ADDR_VAR 0 2
4553: PUSH
4554: LD_INT 22
4556: PUSH
4557: LD_INT 3
4559: PUSH
4560: EMPTY
4561: LIST
4562: LIST
4563: PUSH
4564: LD_INT 21
4566: PUSH
4567: LD_INT 2
4569: PUSH
4570: EMPTY
4571: LIST
4572: LIST
4573: PUSH
4574: EMPTY
4575: LIST
4576: LIST
4577: PPUSH
4578: CALL_OW 69
4582: ST_TO_ADDR
// if filter then
4583: LD_VAR 0 2
4587: IFFALSE 4633
// for i in filter do
4589: LD_ADDR_VAR 0 1
4593: PUSH
4594: LD_VAR 0 2
4598: PUSH
4599: FOR_IN
4600: IFFALSE 4631
// if GetFuel ( i ) < 20 then
4602: LD_VAR 0 1
4606: PPUSH
4607: CALL_OW 261
4611: PUSH
4612: LD_INT 20
4614: LESS
4615: IFFALSE 4629
// SetFuel ( i , 20 ) ;
4617: LD_VAR 0 1
4621: PPUSH
4622: LD_INT 20
4624: PPUSH
4625: CALL_OW 240
4629: GO 4599
4631: POP
4632: POP
// end ;
4633: PPOPN 2
4635: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4636: LD_EXP 56
4640: IFFALSE 4859
4642: GO 4644
4644: DISABLE
4645: LD_INT 0
4647: PPUSH
4648: PPUSH
4649: PPUSH
// begin enable ;
4650: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4651: LD_ADDR_VAR 0 2
4655: PUSH
4656: LD_INT 22
4658: PUSH
4659: LD_INT 3
4661: PUSH
4662: EMPTY
4663: LIST
4664: LIST
4665: PUSH
4666: LD_INT 30
4668: PUSH
4669: LD_INT 3
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: PPUSH
4680: CALL_OW 69
4684: ST_TO_ADDR
// can_produce := [ ] ;
4685: LD_ADDR_VAR 0 3
4689: PUSH
4690: EMPTY
4691: ST_TO_ADDR
// if not fac then
4692: LD_VAR 0 2
4696: NOT
4697: IFFALSE 4702
// begin disable ;
4699: DISABLE
// exit ;
4700: GO 4859
// end ; for i in fac do
4702: LD_ADDR_VAR 0 1
4706: PUSH
4707: LD_VAR 0 2
4711: PUSH
4712: FOR_IN
4713: IFFALSE 4751
// if UnitsInside ( i ) then
4715: LD_VAR 0 1
4719: PPUSH
4720: CALL_OW 313
4724: IFFALSE 4749
// can_produce := Insert ( can_produce , 1 , i ) ;
4726: LD_ADDR_VAR 0 3
4730: PUSH
4731: LD_VAR 0 3
4735: PPUSH
4736: LD_INT 1
4738: PPUSH
4739: LD_VAR 0 1
4743: PPUSH
4744: CALL_OW 2
4748: ST_TO_ADDR
4749: GO 4712
4751: POP
4752: POP
// if not can_produce then
4753: LD_VAR 0 3
4757: NOT
4758: IFFALSE 4762
// exit ;
4760: GO 4859
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4762: LD_VAR 0 3
4766: PUSH
4767: LD_INT 1
4769: PPUSH
4770: LD_VAR 0 3
4774: PPUSH
4775: CALL_OW 12
4779: ARRAY
4780: PPUSH
4781: LD_EXP 56
4785: PUSH
4786: LD_INT 1
4788: ARRAY
4789: PPUSH
4790: LD_EXP 56
4794: PUSH
4795: LD_INT 2
4797: ARRAY
4798: PPUSH
4799: LD_EXP 56
4803: PUSH
4804: LD_INT 3
4806: ARRAY
4807: PPUSH
4808: LD_EXP 56
4812: PUSH
4813: LD_INT 4
4815: ARRAY
4816: PPUSH
4817: CALL_OW 125
// for i = 1 to 4 do
4821: LD_ADDR_VAR 0 1
4825: PUSH
4826: DOUBLE
4827: LD_INT 1
4829: DEC
4830: ST_TO_ADDR
4831: LD_INT 4
4833: PUSH
4834: FOR_TO
4835: IFFALSE 4857
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4837: LD_ADDR_EXP 56
4841: PUSH
4842: LD_EXP 56
4846: PPUSH
4847: LD_INT 1
4849: PPUSH
4850: CALL_OW 3
4854: ST_TO_ADDR
4855: GO 4834
4857: POP
4858: POP
// end ;
4859: PPOPN 3
4861: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4862: LD_INT 0
4864: PPUSH
4865: PPUSH
4866: PPUSH
// for i = 1 to 6 do
4867: LD_ADDR_VAR 0 2
4871: PUSH
4872: DOUBLE
4873: LD_INT 1
4875: DEC
4876: ST_TO_ADDR
4877: LD_INT 6
4879: PUSH
4880: FOR_TO
4881: IFFALSE 5030
// begin PrepareHuman ( false , 3 , 3 ) ;
4883: LD_INT 0
4885: PPUSH
4886: LD_INT 3
4888: PPUSH
4889: LD_INT 3
4891: PPUSH
4892: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4896: LD_ADDR_VAR 0 3
4900: PUSH
4901: LD_INT 3
4903: PPUSH
4904: LD_INT 3
4906: PPUSH
4907: LD_INT 22
4909: PPUSH
4910: LD_INT 1
4912: PPUSH
4913: LD_INT 1
4915: PPUSH
4916: LD_INT 43
4918: PUSH
4919: LD_INT 42
4921: PUSH
4922: EMPTY
4923: LIST
4924: LIST
4925: PUSH
4926: LD_INT 1
4928: PPUSH
4929: LD_INT 2
4931: PPUSH
4932: CALL_OW 12
4936: ARRAY
4937: PPUSH
4938: LD_INT 70
4940: PPUSH
4941: CALL 537 0 7
4945: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4946: LD_VAR 0 3
4950: PPUSH
4951: LD_INT 4
4953: PPUSH
4954: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4958: LD_VAR 0 3
4962: PPUSH
4963: LD_INT 229
4965: PPUSH
4966: LD_INT 44
4968: PPUSH
4969: LD_INT 0
4971: PPUSH
4972: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4976: CALL_OW 44
4980: PPUSH
4981: LD_VAR 0 3
4985: PPUSH
4986: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4990: LD_ADDR_EXP 55
4994: PUSH
4995: LD_EXP 55
4999: PUSH
5000: LD_VAR 0 3
5004: ADD
5005: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
5006: LD_VAR 0 3
5010: PPUSH
5011: LD_INT 191
5013: PPUSH
5014: LD_INT 32
5016: PPUSH
5017: CALL_OW 111
// Wait ( 0 0$02 ) ;
5021: LD_INT 70
5023: PPUSH
5024: CALL_OW 67
// end ;
5028: GO 4880
5030: POP
5031: POP
// end ;
5032: LD_VAR 0 1
5036: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
5037: LD_EXP 30
5041: PUSH
5042: LD_EXP 55
5046: AND
5047: IFFALSE 5221
5049: GO 5051
5051: DISABLE
5052: LD_INT 0
5054: PPUSH
5055: PPUSH
5056: PPUSH
// begin wait ( 0 0$50 ) ;
5057: LD_INT 1750
5059: PPUSH
5060: CALL_OW 67
// tmp := ru_vehicles ;
5064: LD_ADDR_VAR 0 3
5068: PUSH
5069: LD_EXP 55
5073: ST_TO_ADDR
// if not tmp then
5074: LD_VAR 0 3
5078: NOT
5079: IFFALSE 5083
// exit ;
5081: GO 5221
// repeat wait ( 0 0$1 ) ;
5083: LD_INT 35
5085: PPUSH
5086: CALL_OW 67
// for i in tmp do
5090: LD_ADDR_VAR 0 1
5094: PUSH
5095: LD_VAR 0 3
5099: PUSH
5100: FOR_IN
5101: IFFALSE 5212
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5103: LD_ADDR_VAR 0 2
5107: PUSH
5108: LD_INT 22
5110: PUSH
5111: LD_INT 1
5113: PUSH
5114: EMPTY
5115: LIST
5116: LIST
5117: PPUSH
5118: LD_VAR 0 1
5122: PPUSH
5123: CALL_OW 74
5127: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5128: LD_VAR 0 1
5132: PPUSH
5133: LD_VAR 0 2
5137: PPUSH
5138: CALL_OW 296
5142: PUSH
5143: LD_INT 10
5145: GREATER
5146: IFFALSE 5165
// ComAgressiveMove ( i , 69 , 101 ) else
5148: LD_VAR 0 1
5152: PPUSH
5153: LD_INT 69
5155: PPUSH
5156: LD_INT 101
5158: PPUSH
5159: CALL_OW 114
5163: GO 5179
// ComAttackUnit ( i , enemy ) ;
5165: LD_VAR 0 1
5169: PPUSH
5170: LD_VAR 0 2
5174: PPUSH
5175: CALL_OW 115
// if GetLives ( i ) < 250 then
5179: LD_VAR 0 1
5183: PPUSH
5184: CALL_OW 256
5188: PUSH
5189: LD_INT 250
5191: LESS
5192: IFFALSE 5210
// tmp := tmp diff i ;
5194: LD_ADDR_VAR 0 3
5198: PUSH
5199: LD_VAR 0 3
5203: PUSH
5204: LD_VAR 0 1
5208: DIFF
5209: ST_TO_ADDR
// end ;
5210: GO 5100
5212: POP
5213: POP
// until not tmp ;
5214: LD_VAR 0 3
5218: NOT
5219: IFFALSE 5083
// end ; end_of_file
5221: PPOPN 3
5223: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5224: LD_INT 0
5226: PPUSH
5227: PPUSH
5228: PPUSH
5229: PPUSH
5230: PPUSH
5231: PPUSH
5232: PPUSH
// InGameOn ;
5233: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5237: LD_EXP 36
5241: PPUSH
5242: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5246: LD_EXP 36
5250: PPUSH
5251: LD_EXP 43
5255: PPUSH
5256: CALL_OW 119
// if Bierezov then
5260: LD_EXP 44
5264: IFFALSE 5280
// ComTurnUnit ( Bierezov , Cornel ) ;
5266: LD_EXP 44
5270: PPUSH
5271: LD_EXP 43
5275: PPUSH
5276: CALL_OW 119
// for i in jmm_units do
5280: LD_ADDR_VAR 0 2
5284: PUSH
5285: LD_EXP 4
5289: PUSH
5290: FOR_IN
5291: IFFALSE 5309
// ComTurnUnit ( i , Cornel ) ;
5293: LD_VAR 0 2
5297: PPUSH
5298: LD_EXP 43
5302: PPUSH
5303: CALL_OW 119
5307: GO 5290
5309: POP
5310: POP
// units := cornel_units union Cornel ;
5311: LD_ADDR_VAR 0 3
5315: PUSH
5316: LD_EXP 6
5320: PUSH
5321: LD_EXP 43
5325: UNION
5326: ST_TO_ADDR
// repeat wait ( 1 ) ;
5327: LD_INT 1
5329: PPUSH
5330: CALL_OW 67
// for i in units do
5334: LD_ADDR_VAR 0 2
5338: PUSH
5339: LD_VAR 0 3
5343: PUSH
5344: FOR_IN
5345: IFFALSE 5378
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5347: LD_VAR 0 2
5351: PPUSH
5352: LD_EXP 36
5356: PPUSH
5357: CALL_OW 250
5361: PPUSH
5362: LD_EXP 36
5366: PPUSH
5367: CALL_OW 251
5371: PPUSH
5372: CALL_OW 111
5376: GO 5344
5378: POP
5379: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5380: LD_VAR 0 3
5384: PPUSH
5385: LD_INT 92
5387: PUSH
5388: LD_EXP 36
5392: PPUSH
5393: CALL_OW 250
5397: PUSH
5398: LD_EXP 36
5402: PPUSH
5403: CALL_OW 251
5407: PUSH
5408: LD_INT 10
5410: PUSH
5411: EMPTY
5412: LIST
5413: LIST
5414: LIST
5415: LIST
5416: PPUSH
5417: CALL_OW 72
5421: PUSH
5422: LD_VAR 0 3
5426: EQUAL
5427: IFFALSE 5327
// for i in units do
5429: LD_ADDR_VAR 0 2
5433: PUSH
5434: LD_VAR 0 3
5438: PUSH
5439: FOR_IN
5440: IFFALSE 5458
// ComTurnUnit ( i , JMM ) ;
5442: LD_VAR 0 2
5446: PPUSH
5447: LD_EXP 36
5451: PPUSH
5452: CALL_OW 119
5456: GO 5439
5458: POP
5459: POP
// ComTurnUnit ( Cornel , JMM ) ;
5460: LD_EXP 43
5464: PPUSH
5465: LD_EXP 36
5469: PPUSH
5470: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5474: LD_EXP 36
5478: PPUSH
5479: LD_STRING D1-JMM-1
5481: PPUSH
5482: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5486: LD_EXP 43
5490: PPUSH
5491: LD_STRING D1-Corn-1
5493: PPUSH
5494: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5498: LD_EXP 36
5502: PPUSH
5503: LD_EXP 43
5507: PPUSH
5508: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5512: LD_EXP 43
5516: PPUSH
5517: LD_EXP 36
5521: PPUSH
5522: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5526: LD_INT 35
5528: PPUSH
5529: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5533: LD_EXP 36
5537: PPUSH
5538: LD_EXP 43
5542: PPUSH
5543: CALL_OW 296
5547: PUSH
5548: LD_INT 6
5550: LESS
5551: IFFALSE 5526
// ChangeSideFog ( 4 , 1 ) ;
5553: LD_INT 4
5555: PPUSH
5556: LD_INT 1
5558: PPUSH
5559: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5563: LD_EXP 36
5567: PPUSH
5568: LD_EXP 43
5572: PPUSH
5573: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5577: LD_EXP 43
5581: PPUSH
5582: LD_EXP 36
5586: PPUSH
5587: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5591: LD_EXP 36
5595: PPUSH
5596: LD_STRING D1-JMM-2
5598: PPUSH
5599: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5603: LD_EXP 36
5607: PPUSH
5608: LD_STRING D1-JMM-2a
5610: PPUSH
5611: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5615: LD_EXP 43
5619: PPUSH
5620: LD_STRING D1-Corn-2
5622: PPUSH
5623: CALL_OW 88
// if bierezov_exist or debug then
5627: LD_EXP 7
5631: PUSH
5632: LD_EXP 1
5636: OR
5637: IFFALSE 5878
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5639: LD_EXP 43
5643: PPUSH
5644: LD_EXP 44
5648: PPUSH
5649: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5653: LD_INT 10
5655: PPUSH
5656: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5660: LD_EXP 43
5664: PPUSH
5665: LD_STRING D1a-Corn-1
5667: PPUSH
5668: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5672: LD_EXP 36
5676: PPUSH
5677: LD_EXP 44
5681: PPUSH
5682: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5686: LD_EXP 44
5690: PPUSH
5691: LD_EXP 36
5695: PPUSH
5696: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5700: LD_EXP 36
5704: PPUSH
5705: LD_STRING D1a-JMM-1
5707: PPUSH
5708: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5712: LD_EXP 36
5716: PPUSH
5717: LD_EXP 43
5721: PPUSH
5722: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5726: LD_EXP 43
5730: PPUSH
5731: LD_EXP 36
5735: PPUSH
5736: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5740: LD_EXP 43
5744: PPUSH
5745: LD_STRING D1a-Corn-2
5747: PPUSH
5748: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5752: LD_EXP 36
5756: PPUSH
5757: LD_STRING D1a-JMM-2
5759: PPUSH
5760: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5764: LD_EXP 43
5768: PPUSH
5769: LD_STRING D1a-Corn-3
5771: PPUSH
5772: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5776: LD_EXP 36
5780: PPUSH
5781: LD_STRING D1a-JMM-3
5783: PPUSH
5784: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5788: LD_EXP 43
5792: PPUSH
5793: LD_STRING D1a-Corn-4
5795: PPUSH
5796: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5800: LD_EXP 36
5804: PPUSH
5805: LD_STRING D1a-JMM-4
5807: PPUSH
5808: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5812: LD_EXP 43
5816: PPUSH
5817: LD_STRING D1a-Corn-5
5819: PPUSH
5820: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5824: LD_EXP 44
5828: PPUSH
5829: LD_EXP 43
5833: PPUSH
5834: CALL_OW 250
5838: PPUSH
5839: LD_EXP 43
5843: PPUSH
5844: CALL_OW 251
5848: PUSH
5849: LD_INT 2
5851: MINUS
5852: PPUSH
5853: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5857: LD_EXP 44
5861: PPUSH
5862: LD_EXP 43
5866: PPUSH
5867: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5871: LD_INT 10
5873: PPUSH
5874: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5878: LD_EXP 36
5882: PPUSH
5883: LD_STRING D1b-JMM-1
5885: PPUSH
5886: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5890: LD_EXP 43
5894: PPUSH
5895: LD_STRING D1b-Corn-1
5897: PPUSH
5898: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5902: LD_EXP 36
5906: PPUSH
5907: LD_STRING D1b-JMM-2
5909: PPUSH
5910: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5914: LD_EXP 43
5918: PPUSH
5919: LD_STRING D1b-Corn-2
5921: PPUSH
5922: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5926: LD_EXP 36
5930: PPUSH
5931: LD_STRING D1b-JMM-3
5933: PPUSH
5934: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5938: LD_INT 10
5940: PPUSH
5941: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5945: LD_EXP 45
5949: PPUSH
5950: LD_STRING D1b-Pow-3
5952: PPUSH
5953: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5957: LD_EXP 36
5961: PPUSH
5962: LD_STRING D1b-JMM-4
5964: PPUSH
5965: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5969: LD_EXP 43
5973: PPUSH
5974: LD_STRING D1b-Corn-4
5976: PPUSH
5977: CALL_OW 88
// if Khatam then
5981: LD_EXP 40
5985: IFFALSE 6001
// Say ( Khatam , D1b-Khat-4 ) else
5987: LD_EXP 40
5991: PPUSH
5992: LD_STRING D1b-Khat-4
5994: PPUSH
5995: CALL_OW 88
5999: GO 6037
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
6001: LD_EXP 6
6005: PPUSH
6006: LD_INT 26
6008: PUSH
6009: LD_INT 1
6011: PUSH
6012: EMPTY
6013: LIST
6014: LIST
6015: PPUSH
6016: CALL_OW 72
6020: PUSH
6021: LD_EXP 43
6025: PUSH
6026: EMPTY
6027: LIST
6028: DIFF
6029: PPUSH
6030: LD_STRING D1b-Sol1-4
6032: PPUSH
6033: CALL 625 0 2
// if Cyrus then
6037: LD_EXP 38
6041: IFFALSE 6055
// Say ( Cyrus , D1b-Cyrus-4 ) ;
6043: LD_EXP 38
6047: PPUSH
6048: LD_STRING D1b-Cyrus-4
6050: PPUSH
6051: CALL_OW 88
// if Lisa then
6055: LD_EXP 39
6059: IFFALSE 6117
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6061: LD_EXP 39
6065: PPUSH
6066: LD_STRING D1b-Lisa-4
6068: PPUSH
6069: CALL_OW 88
// if Cyrus then
6073: LD_EXP 38
6077: IFFALSE 6117
// begin if not IsInUnit ( Cyrus ) then
6079: LD_EXP 38
6083: PPUSH
6084: CALL_OW 310
6088: NOT
6089: IFFALSE 6105
// ComTurnUnit ( Cyrus , Lisa ) ;
6091: LD_EXP 38
6095: PPUSH
6096: LD_EXP 39
6100: PPUSH
6101: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6105: LD_EXP 38
6109: PPUSH
6110: LD_STRING D1b-Cyrus-5
6112: PPUSH
6113: CALL_OW 88
// end ; end ; SelectGroup ;
6117: CALL 2606 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6121: LD_EXP 36
6125: PPUSH
6126: LD_STRING D1d-JMM-1
6128: PPUSH
6129: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6133: LD_EXP 43
6137: PPUSH
6138: LD_STRING D1d-Corn-1
6140: PPUSH
6141: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6145: LD_ADDR_VAR 0 2
6149: PUSH
6150: LD_EXP 4
6154: PUSH
6155: LD_EXP 6
6159: ADD
6160: PUSH
6161: LD_EXP 36
6165: ADD
6166: PUSH
6167: FOR_IN
6168: IFFALSE 6181
// ComHold ( i ) ;
6170: LD_VAR 0 2
6174: PPUSH
6175: CALL_OW 140
6179: GO 6167
6181: POP
6182: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6183: LD_ADDR_VAR 0 4
6187: PUSH
6188: LD_INT 22
6190: PUSH
6191: LD_INT 1
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: PUSH
6198: LD_INT 21
6200: PUSH
6201: LD_INT 2
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: PUSH
6208: EMPTY
6209: LIST
6210: LIST
6211: PPUSH
6212: CALL_OW 69
6216: ST_TO_ADDR
// if vehicles then
6217: LD_VAR 0 4
6221: IFFALSE 6559
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6223: LD_EXP 6
6227: PPUSH
6228: LD_INT 55
6230: PUSH
6231: EMPTY
6232: LIST
6233: PPUSH
6234: CALL_OW 72
6238: IFFALSE 6277
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6240: LD_ADDR_VAR 0 2
6244: PUSH
6245: LD_EXP 6
6249: PPUSH
6250: LD_INT 55
6252: PUSH
6253: EMPTY
6254: LIST
6255: PPUSH
6256: CALL_OW 72
6260: PUSH
6261: FOR_IN
6262: IFFALSE 6275
// ComExitVehicle ( i ) ;
6264: LD_VAR 0 2
6268: PPUSH
6269: CALL_OW 121
6273: GO 6261
6275: POP
6276: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6277: LD_ADDR_VAR 0 5
6281: PUSH
6282: LD_VAR 0 4
6286: PPUSH
6287: LD_INT 34
6289: PUSH
6290: LD_INT 51
6292: PUSH
6293: EMPTY
6294: LIST
6295: LIST
6296: PPUSH
6297: CALL_OW 72
6301: ST_TO_ADDR
// if cargos then
6302: LD_VAR 0 5
6306: IFFALSE 6489
// begin vehicles := cargos ;
6308: LD_ADDR_VAR 0 4
6312: PUSH
6313: LD_VAR 0 5
6317: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6318: LD_ADDR_VAR 0 6
6322: PUSH
6323: LD_STRING 02_resources_4
6325: PPUSH
6326: LD_INT 0
6328: PPUSH
6329: CALL_OW 30
6333: ST_TO_ADDR
// if debug and not resources then
6334: LD_EXP 1
6338: PUSH
6339: LD_VAR 0 6
6343: NOT
6344: AND
6345: IFFALSE 6355
// resources := 160 ;
6347: LD_ADDR_VAR 0 6
6351: PUSH
6352: LD_INT 160
6354: ST_TO_ADDR
// if resources mod 10 then
6355: LD_VAR 0 6
6359: PUSH
6360: LD_INT 10
6362: MOD
6363: IFFALSE 6385
// resources := resources - resources mod 10 ;
6365: LD_ADDR_VAR 0 6
6369: PUSH
6370: LD_VAR 0 6
6374: PUSH
6375: LD_VAR 0 6
6379: PUSH
6380: LD_INT 10
6382: MOD
6383: MINUS
6384: ST_TO_ADDR
// if resources then
6385: LD_VAR 0 6
6389: IFFALSE 6489
// for i in cargos do
6391: LD_ADDR_VAR 0 2
6395: PUSH
6396: LD_VAR 0 5
6400: PUSH
6401: FOR_IN
6402: IFFALSE 6487
// begin if resources < 100 then
6404: LD_VAR 0 6
6408: PUSH
6409: LD_INT 100
6411: LESS
6412: IFFALSE 6434
// begin cargo := resources ;
6414: LD_ADDR_VAR 0 7
6418: PUSH
6419: LD_VAR 0 6
6423: ST_TO_ADDR
// resources := 0 ;
6424: LD_ADDR_VAR 0 6
6428: PUSH
6429: LD_INT 0
6431: ST_TO_ADDR
// end else
6432: GO 6456
// begin cargo := 100 ;
6434: LD_ADDR_VAR 0 7
6438: PUSH
6439: LD_INT 100
6441: ST_TO_ADDR
// resources := resources - 100 ;
6442: LD_ADDR_VAR 0 6
6446: PUSH
6447: LD_VAR 0 6
6451: PUSH
6452: LD_INT 100
6454: MINUS
6455: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6456: LD_VAR 0 2
6460: PPUSH
6461: LD_INT 1
6463: PPUSH
6464: LD_VAR 0 7
6468: PPUSH
6469: CALL_OW 290
// if resources = 0 then
6473: LD_VAR 0 6
6477: PUSH
6478: LD_INT 0
6480: EQUAL
6481: IFFALSE 6485
// break ;
6483: GO 6487
// end ;
6485: GO 6401
6487: POP
6488: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6489: LD_VAR 0 4
6493: PUSH
6494: LD_INT 1
6496: ARRAY
6497: PPUSH
6498: CALL_OW 311
6502: PPUSH
6503: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6507: LD_VAR 0 4
6511: PUSH
6512: LD_INT 1
6514: ARRAY
6515: PPUSH
6516: LD_INT 4
6518: PPUSH
6519: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6523: LD_EXP 43
6527: PPUSH
6528: LD_VAR 0 4
6532: PUSH
6533: LD_INT 1
6535: ARRAY
6536: PPUSH
6537: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6541: LD_INT 35
6543: PPUSH
6544: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6548: LD_EXP 43
6552: PPUSH
6553: CALL_OW 310
6557: IFFALSE 6541
// end ; InGameOff ;
6559: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6563: LD_STRING M1
6565: PPUSH
6566: CALL_OW 337
// SaveForQuickRestart ;
6570: CALL_OW 22
// cornel_active := true ;
6574: LD_ADDR_EXP 8
6578: PUSH
6579: LD_INT 1
6581: ST_TO_ADDR
// end ;
6582: LD_VAR 0 1
6586: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns , tmp ;
6587: LD_EXP 36
6591: PPUSH
6592: LD_EXP 46
6596: PPUSH
6597: CALL_OW 296
6601: PUSH
6602: LD_INT 10
6604: LESS
6605: IFFALSE 7968
6607: GO 6609
6609: DISABLE
6610: LD_INT 0
6612: PPUSH
6613: PPUSH
6614: PPUSH
6615: PPUSH
6616: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6617: LD_ADDR_VAR 0 2
6621: PUSH
6622: LD_INT 89
6624: PUSH
6625: LD_INT 34
6627: PUSH
6628: EMPTY
6629: LIST
6630: LIST
6631: PUSH
6632: LD_INT 138
6634: PUSH
6635: LD_INT 63
6637: PUSH
6638: EMPTY
6639: LIST
6640: LIST
6641: PUSH
6642: LD_INT 196
6644: PUSH
6645: LD_INT 84
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 135
6654: PUSH
6655: LD_INT 52
6657: PUSH
6658: EMPTY
6659: LIST
6660: LIST
6661: PUSH
6662: LD_INT 103
6664: PUSH
6665: LD_INT 39
6667: PUSH
6668: EMPTY
6669: LIST
6670: LIST
6671: PUSH
6672: LD_INT 58
6674: PUSH
6675: LD_INT 30
6677: PUSH
6678: EMPTY
6679: LIST
6680: LIST
6681: PUSH
6682: LD_INT 38
6684: PUSH
6685: LD_INT 51
6687: PUSH
6688: EMPTY
6689: LIST
6690: LIST
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: LIST
6698: LIST
6699: LIST
6700: ST_TO_ADDR
// Video ( true ) ;
6701: LD_INT 1
6703: PPUSH
6704: CALL 1185 0 1
// if jmm_units then
6708: LD_EXP 4
6712: IFFALSE 6788
// for i in jmm_units do
6714: LD_ADDR_VAR 0 1
6718: PUSH
6719: LD_EXP 4
6723: PUSH
6724: FOR_IN
6725: IFFALSE 6786
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6727: LD_VAR 0 1
6731: PPUSH
6732: LD_EXP 36
6736: PPUSH
6737: CALL_OW 296
6741: PUSH
6742: LD_INT 10
6744: LESS
6745: PUSH
6746: LD_VAR 0 1
6750: PPUSH
6751: CALL_OW 310
6755: NOT
6756: AND
6757: IFFALSE 6775
// ComTurnUnit ( i , JMM ) else
6759: LD_VAR 0 1
6763: PPUSH
6764: LD_EXP 36
6768: PPUSH
6769: CALL_OW 119
6773: GO 6784
// ComHold ( i ) ;
6775: LD_VAR 0 1
6779: PPUSH
6780: CALL_OW 140
// end ;
6784: GO 6724
6786: POP
6787: POP
// if IsInUnit ( JMM ) then
6788: LD_EXP 36
6792: PPUSH
6793: CALL_OW 310
6797: IFFALSE 6822
// begin ComExitVehicle ( JMM ) ;
6799: LD_EXP 36
6803: PPUSH
6804: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6808: LD_EXP 36
6812: PPUSH
6813: LD_EXP 46
6817: PPUSH
6818: CALL_OW 172
// end ; Wait ( 10 ) ;
6822: LD_INT 10
6824: PPUSH
6825: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6829: LD_EXP 36
6833: PPUSH
6834: LD_EXP 46
6838: PPUSH
6839: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6843: LD_INT 35
6845: PPUSH
6846: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6850: LD_EXP 36
6854: PPUSH
6855: LD_EXP 46
6859: PPUSH
6860: CALL_OW 296
6864: PUSH
6865: LD_INT 6
6867: LESS
6868: IFFALSE 6843
// ComTurnUnit ( JMM , Lynch ) ;
6870: LD_EXP 36
6874: PPUSH
6875: LD_EXP 46
6879: PPUSH
6880: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6884: LD_ADDR_VAR 0 1
6888: PUSH
6889: LD_EXP 46
6893: PUSH
6894: LD_EXP 47
6898: PUSH
6899: LD_EXP 48
6903: PUSH
6904: LD_EXP 49
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: LIST
6913: LIST
6914: PUSH
6915: FOR_IN
6916: IFFALSE 6934
// ComTurnUnit ( i , JMM ) ;
6918: LD_VAR 0 1
6922: PPUSH
6923: LD_EXP 36
6927: PPUSH
6928: CALL_OW 119
6932: GO 6915
6934: POP
6935: POP
// Wait ( 0 0$0.3 ) ;
6936: LD_INT 10
6938: PPUSH
6939: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6943: LD_EXP 36
6947: PPUSH
6948: LD_STRING D2-JMM-1
6950: PPUSH
6951: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6955: LD_EXP 46
6959: PPUSH
6960: LD_STRING D2-Sol1-1
6962: PPUSH
6963: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6967: LD_EXP 36
6971: PPUSH
6972: LD_STRING D2-JMM-2
6974: PPUSH
6975: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6979: LD_EXP 46
6983: PPUSH
6984: LD_STRING D2-Sol1-2
6986: PPUSH
6987: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6991: LD_EXP 36
6995: PPUSH
6996: LD_STRING D2-JMM-3
6998: PPUSH
6999: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
7003: LD_EXP 46
7007: PPUSH
7008: LD_STRING D2-Sol1-3
7010: PPUSH
7011: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7015: LD_ADDR_VAR 0 1
7019: PUSH
7020: LD_INT 22
7022: PUSH
7023: LD_INT 8
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: PPUSH
7030: CALL_OW 69
7034: PUSH
7035: FOR_IN
7036: IFFALSE 7052
// SetSide ( i , 1 ) ;
7038: LD_VAR 0 1
7042: PPUSH
7043: LD_INT 1
7045: PPUSH
7046: CALL_OW 235
7050: GO 7035
7052: POP
7053: POP
// Say ( JMM , D2-JMM-4 ) ;
7054: LD_EXP 36
7058: PPUSH
7059: LD_STRING D2-JMM-4
7061: PPUSH
7062: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7066: LD_INT 1
7068: PPUSH
7069: LD_INT 5
7071: PPUSH
7072: CALL_OW 332
// for i = 1 to points do
7076: LD_ADDR_VAR 0 1
7080: PUSH
7081: DOUBLE
7082: LD_INT 1
7084: DEC
7085: ST_TO_ADDR
7086: LD_VAR 0 2
7090: PUSH
7091: FOR_TO
7092: IFFALSE 7267
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7094: LD_VAR 0 2
7098: PUSH
7099: LD_VAR 0 1
7103: ARRAY
7104: PUSH
7105: LD_INT 1
7107: ARRAY
7108: PPUSH
7109: LD_VAR 0 2
7113: PUSH
7114: LD_VAR 0 1
7118: ARRAY
7119: PUSH
7120: LD_INT 2
7122: ARRAY
7123: PPUSH
7124: CALL_OW 84
// if i = 1 then
7128: LD_VAR 0 1
7132: PUSH
7133: LD_INT 1
7135: EQUAL
7136: IFFALSE 7150
// Say ( Lynch , D2-Sol1-4 ) ;
7138: LD_EXP 46
7142: PPUSH
7143: LD_STRING D2-Sol1-4
7145: PPUSH
7146: CALL_OW 88
// if i = 2 then
7150: LD_VAR 0 1
7154: PUSH
7155: LD_INT 2
7157: EQUAL
7158: IFFALSE 7172
// Say ( JMM , D2-JMM-5 ) ;
7160: LD_EXP 36
7164: PPUSH
7165: LD_STRING D2-JMM-5
7167: PPUSH
7168: CALL_OW 88
// if i = 4 then
7172: LD_VAR 0 1
7176: PUSH
7177: LD_INT 4
7179: EQUAL
7180: IFFALSE 7204
// begin RevealFogArea ( 1 , troopsArea ) ;
7182: LD_INT 1
7184: PPUSH
7185: LD_INT 6
7187: PPUSH
7188: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7192: LD_EXP 46
7196: PPUSH
7197: LD_STRING D2-Sol1-5
7199: PPUSH
7200: CALL_OW 88
// end ; if i = 5 then
7204: LD_VAR 0 1
7208: PUSH
7209: LD_INT 5
7211: EQUAL
7212: IFFALSE 7226
// Say ( JMM , D2-JMM-6 ) ;
7214: LD_EXP 36
7218: PPUSH
7219: LD_STRING D2-JMM-6
7221: PPUSH
7222: CALL_OW 88
// if i = 7 then
7226: LD_VAR 0 1
7230: PUSH
7231: LD_INT 7
7233: EQUAL
7234: IFFALSE 7258
// begin RevealFogArea ( 1 , forestArea ) ;
7236: LD_INT 1
7238: PPUSH
7239: LD_INT 7
7241: PPUSH
7242: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7246: LD_EXP 46
7250: PPUSH
7251: LD_STRING D2-Sol1-6
7253: PPUSH
7254: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7258: LD_INT 46
7260: PPUSH
7261: CALL_OW 67
// end ;
7265: GO 7091
7267: POP
7268: POP
// CenterNowOnUnits ( JMM ) ;
7269: LD_EXP 36
7273: PPUSH
7274: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7278: LD_EXP 36
7282: PPUSH
7283: LD_STRING D2-JMM-7
7285: PPUSH
7286: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7290: LD_EXP 46
7294: PPUSH
7295: LD_STRING D2-Sol1-7
7297: PPUSH
7298: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7302: LD_EXP 36
7306: PPUSH
7307: LD_STRING D2-JMM-8
7309: PPUSH
7310: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7314: LD_ADDR_VAR 0 4
7318: PUSH
7319: LD_INT 22
7321: PUSH
7322: LD_INT 1
7324: PUSH
7325: EMPTY
7326: LIST
7327: LIST
7328: PUSH
7329: LD_INT 30
7331: PUSH
7332: LD_INT 31
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: PUSH
7339: EMPTY
7340: LIST
7341: LIST
7342: PPUSH
7343: CALL_OW 69
7347: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7348: LD_EXP 46
7352: PPUSH
7353: LD_VAR 0 4
7357: PUSH
7358: LD_INT 1
7360: ARRAY
7361: PPUSH
7362: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7366: LD_INT 65
7368: PPUSH
7369: LD_INT 101
7371: PPUSH
7372: CALL_OW 428
7376: IFFALSE 7399
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7378: LD_INT 65
7380: PPUSH
7381: LD_INT 101
7383: PPUSH
7384: CALL_OW 428
7388: PPUSH
7389: LD_INT 75
7391: PPUSH
7392: LD_INT 100
7394: PPUSH
7395: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7399: LD_INT 66
7401: PPUSH
7402: LD_INT 103
7404: PPUSH
7405: CALL_OW 428
7409: IFFALSE 7432
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7411: LD_INT 66
7413: PPUSH
7414: LD_INT 103
7416: PPUSH
7417: CALL_OW 428
7421: PPUSH
7422: LD_INT 75
7424: PPUSH
7425: LD_INT 100
7427: PPUSH
7428: CALL_OW 111
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_dist , JMM , 7 ] ] ) ;
7432: LD_ADDR_VAR 0 5
7436: PUSH
7437: LD_INT 22
7439: PUSH
7440: LD_INT 1
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PUSH
7447: LD_INT 21
7449: PUSH
7450: LD_INT 2
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PUSH
7457: LD_INT 91
7459: PUSH
7460: LD_EXP 36
7464: PUSH
7465: LD_INT 7
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: PPUSH
7478: CALL_OW 69
7482: ST_TO_ADDR
// if tmp then
7483: LD_VAR 0 5
7487: IFFALSE 7504
// ComMoveXY ( tmp , 75 , 100 ) ;
7489: LD_VAR 0 5
7493: PPUSH
7494: LD_INT 75
7496: PPUSH
7497: LD_INT 100
7499: PPUSH
7500: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7504: LD_ADDR_VAR 0 3
7508: PUSH
7509: LD_EXP 4
7513: PPUSH
7514: LD_INT 25
7516: PUSH
7517: LD_INT 1
7519: PUSH
7520: EMPTY
7521: LIST
7522: LIST
7523: PPUSH
7524: CALL_OW 72
7528: PPUSH
7529: LD_EXP 36
7533: PPUSH
7534: CALL_OW 74
7538: ST_TO_ADDR
// if sol then
7539: LD_VAR 0 3
7543: IFFALSE 7583
// if GetDistUnits ( JMM , sol ) < 10 then
7545: LD_EXP 36
7549: PPUSH
7550: LD_VAR 0 3
7554: PPUSH
7555: CALL_OW 296
7559: PUSH
7560: LD_INT 10
7562: LESS
7563: IFFALSE 7583
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7565: LD_VAR 0 3
7569: PPUSH
7570: LD_VAR 0 4
7574: PUSH
7575: LD_INT 2
7577: ARRAY
7578: PPUSH
7579: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7583: LD_INT 10
7585: PPUSH
7586: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7590: LD_EXP 36
7594: PPUSH
7595: LD_INT 65
7597: PPUSH
7598: LD_INT 101
7600: PPUSH
7601: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7605: LD_EXP 36
7609: PPUSH
7610: LD_INT 63
7612: PPUSH
7613: LD_INT 100
7615: PPUSH
7616: CALL_OW 178
// tmp := 0 0$0 ;
7620: LD_ADDR_VAR 0 5
7624: PUSH
7625: LD_INT 0
7627: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7628: LD_INT 35
7630: PPUSH
7631: CALL_OW 67
// tmp := tmp + 0 0$1 ;
7635: LD_ADDR_VAR 0 5
7639: PUSH
7640: LD_VAR 0 5
7644: PUSH
7645: LD_INT 35
7647: PLUS
7648: ST_TO_ADDR
// until IsAt ( JMM , 65 , 101 ) or tmp > 0 0$5 ;
7649: LD_EXP 36
7653: PPUSH
7654: LD_INT 65
7656: PPUSH
7657: LD_INT 101
7659: PPUSH
7660: CALL_OW 307
7664: PUSH
7665: LD_VAR 0 5
7669: PUSH
7670: LD_INT 175
7672: GREATER
7673: OR
7674: IFFALSE 7628
// Say ( JMM , D2a-JMM-1 ) ;
7676: LD_EXP 36
7680: PPUSH
7681: LD_STRING D2a-JMM-1
7683: PPUSH
7684: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7688: LD_EXP 47
7692: PPUSH
7693: LD_INT 66
7695: PPUSH
7696: LD_INT 103
7698: PPUSH
7699: CALL_OW 111
// tmp := 0 0$0 ;
7703: LD_ADDR_VAR 0 5
7707: PUSH
7708: LD_INT 0
7710: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7711: LD_INT 35
7713: PPUSH
7714: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) or tmp > 0 0$5 ;
7718: LD_EXP 47
7722: PPUSH
7723: LD_INT 66
7725: PPUSH
7726: LD_INT 103
7728: PPUSH
7729: CALL_OW 307
7733: PUSH
7734: LD_VAR 0 5
7738: PUSH
7739: LD_INT 175
7741: GREATER
7742: OR
7743: IFFALSE 7711
// ComTurnUnit ( Walker , JMM ) ;
7745: LD_EXP 47
7749: PPUSH
7750: LD_EXP 36
7754: PPUSH
7755: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7759: LD_EXP 47
7763: PPUSH
7764: LD_STRING D2a-Sci1-1
7766: PPUSH
7767: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7771: LD_EXP 36
7775: PPUSH
7776: LD_EXP 47
7780: PPUSH
7781: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7785: LD_EXP 36
7789: PPUSH
7790: LD_STRING D2a-JMM-2
7792: PPUSH
7793: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7797: LD_EXP 47
7801: PPUSH
7802: LD_STRING D2a-Sci1-2
7804: PPUSH
7805: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7809: LD_EXP 36
7813: PPUSH
7814: LD_STRING D2a-JMM-3
7816: PPUSH
7817: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7821: LD_EXP 47
7825: PPUSH
7826: LD_STRING D2a-Sci1-3
7828: PPUSH
7829: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7833: LD_ADDR_EXP 4
7837: PUSH
7838: LD_EXP 4
7842: PUSH
7843: LD_EXP 46
7847: PUSH
7848: LD_EXP 47
7852: PUSH
7853: LD_EXP 48
7857: PUSH
7858: LD_EXP 49
7862: PUSH
7863: EMPTY
7864: LIST
7865: LIST
7866: LIST
7867: LIST
7868: ADD
7869: ST_TO_ADDR
// for i in jmm_units do
7870: LD_ADDR_VAR 0 1
7874: PUSH
7875: LD_EXP 4
7879: PUSH
7880: FOR_IN
7881: IFFALSE 7906
// if not IsInUnit ( i ) then
7883: LD_VAR 0 1
7887: PPUSH
7888: CALL_OW 310
7892: NOT
7893: IFFALSE 7904
// ComFree ( i ) ;
7895: LD_VAR 0 1
7899: PPUSH
7900: CALL_OW 139
7904: GO 7880
7906: POP
7907: POP
// Video ( false ) ;
7908: LD_INT 0
7910: PPUSH
7911: CALL 1185 0 1
// ChangeMissionObjectives ( MSolar1 ) ;
7915: LD_STRING MSolar1
7917: PPUSH
7918: CALL_OW 337
// jmm_on_west := true ;
7922: LD_ADDR_EXP 5
7926: PUSH
7927: LD_INT 1
7929: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7930: LD_INT 1050
7932: PPUSH
7933: CALL_OW 67
// frank_can_return := true ;
7937: LD_ADDR_EXP 12
7941: PUSH
7942: LD_INT 1
7944: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7945: LD_INT 6300
7947: PPUSH
7948: LD_INT 8400
7950: PPUSH
7951: CALL_OW 12
7955: PPUSH
7956: CALL_OW 67
// send_spec_patrol := true ;
7960: LD_ADDR_EXP 29
7964: PUSH
7965: LD_INT 1
7967: ST_TO_ADDR
// end ;
7968: PPOPN 5
7970: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7971: LD_INT 22
7973: PUSH
7974: LD_INT 1
7976: PUSH
7977: EMPTY
7978: LIST
7979: LIST
7980: PUSH
7981: LD_INT 34
7983: PUSH
7984: LD_INT 51
7986: PUSH
7987: EMPTY
7988: LIST
7989: LIST
7990: PUSH
7991: LD_INT 92
7993: PUSH
7994: LD_INT 63
7996: PUSH
7997: LD_INT 100
7999: PUSH
8000: LD_INT 5
8002: PUSH
8003: EMPTY
8004: LIST
8005: LIST
8006: LIST
8007: LIST
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: LIST
8013: PUSH
8014: EMPTY
8015: LIST
8016: PPUSH
8017: CALL_OW 69
8021: PUSH
8022: LD_EXP 5
8026: NOT
8027: AND
8028: IFFALSE 8141
8030: GO 8032
8032: DISABLE
8033: LD_INT 0
8035: PPUSH
8036: PPUSH
// begin enable ;
8037: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
8038: LD_ADDR_VAR 0 2
8042: PUSH
8043: LD_INT 22
8045: PUSH
8046: LD_INT 1
8048: PUSH
8049: EMPTY
8050: LIST
8051: LIST
8052: PUSH
8053: LD_INT 34
8055: PUSH
8056: LD_INT 51
8058: PUSH
8059: EMPTY
8060: LIST
8061: LIST
8062: PUSH
8063: LD_INT 92
8065: PUSH
8066: LD_INT 63
8068: PUSH
8069: LD_INT 100
8071: PUSH
8072: LD_INT 5
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: LIST
8079: LIST
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: LIST
8085: PUSH
8086: EMPTY
8087: LIST
8088: PPUSH
8089: CALL_OW 69
8093: ST_TO_ADDR
// if not filter then
8094: LD_VAR 0 2
8098: NOT
8099: IFFALSE 8103
// exit ;
8101: GO 8141
// for i in filter do
8103: LD_ADDR_VAR 0 1
8107: PUSH
8108: LD_VAR 0 2
8112: PUSH
8113: FOR_IN
8114: IFFALSE 8139
// begin SetFuel ( i , 0 ) ;
8116: LD_VAR 0 1
8120: PPUSH
8121: LD_INT 0
8123: PPUSH
8124: CALL_OW 240
// ComStop ( i ) ;
8128: LD_VAR 0 1
8132: PPUSH
8133: CALL_OW 141
// end ;
8137: GO 8113
8139: POP
8140: POP
// end ;
8141: PPOPN 2
8143: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
8144: LD_EXP 29
8148: IFFALSE 9141
8150: GO 8152
8152: DISABLE
8153: LD_INT 0
8155: PPUSH
8156: PPUSH
8157: PPUSH
8158: PPUSH
8159: PPUSH
8160: PPUSH
8161: PPUSH
// begin if not ru_spec_patrol then
8162: LD_EXP 53
8166: NOT
8167: IFFALSE 8171
// exit ;
8169: GO 9141
// dead1 := false ;
8171: LD_ADDR_VAR 0 1
8175: PUSH
8176: LD_INT 0
8178: ST_TO_ADDR
// dead2 := false ;
8179: LD_ADDR_VAR 0 2
8183: PUSH
8184: LD_INT 0
8186: ST_TO_ADDR
// inarea1 := false ;
8187: LD_ADDR_VAR 0 3
8191: PUSH
8192: LD_INT 0
8194: ST_TO_ADDR
// inarea2 := false ;
8195: LD_ADDR_VAR 0 4
8199: PUSH
8200: LD_INT 0
8202: ST_TO_ADDR
// tmp := [ ] ;
8203: LD_ADDR_VAR 0 6
8207: PUSH
8208: EMPTY
8209: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8210: LD_EXP 53
8214: PPUSH
8215: LD_INT 75
8217: PPUSH
8218: LD_INT 101
8220: PPUSH
8221: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8225: LD_INT 35
8227: PPUSH
8228: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8232: LD_INT 1
8234: PPUSH
8235: LD_EXP 53
8239: PUSH
8240: LD_INT 1
8242: ARRAY
8243: PPUSH
8244: CALL_OW 292
8248: IFFALSE 8225
// ComStop ( ru_spec_patrol ) ;
8250: LD_EXP 53
8254: PPUSH
8255: CALL_OW 141
// Wait ( 0 0$02 ) ;
8259: LD_INT 70
8261: PPUSH
8262: CALL_OW 67
// DialogueOn ;
8266: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8270: LD_EXP 53
8274: PUSH
8275: LD_INT 1
8277: ARRAY
8278: PPUSH
8279: LD_STRING D8-Rus1-1
8281: PPUSH
8282: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8286: LD_EXP 36
8290: PPUSH
8291: LD_STRING D8-JMM-1
8293: PPUSH
8294: CALL_OW 88
// DialogueOff ;
8298: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8302: LD_EXP 53
8306: PPUSH
8307: LD_INT 13
8309: PPUSH
8310: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8314: LD_INT 35
8316: PPUSH
8317: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8321: LD_VAR 0 1
8325: NOT
8326: PUSH
8327: LD_EXP 53
8331: PUSH
8332: LD_INT 1
8334: ARRAY
8335: PPUSH
8336: CALL_OW 301
8340: AND
8341: IFFALSE 8351
// dead1 := true ;
8343: LD_ADDR_VAR 0 1
8347: PUSH
8348: LD_INT 1
8350: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8351: LD_VAR 0 2
8355: NOT
8356: PUSH
8357: LD_EXP 53
8361: PUSH
8362: LD_INT 2
8364: ARRAY
8365: PPUSH
8366: CALL_OW 301
8370: AND
8371: IFFALSE 8381
// dead2 := true ;
8373: LD_ADDR_VAR 0 2
8377: PUSH
8378: LD_INT 1
8380: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8381: LD_VAR 0 3
8385: NOT
8386: PUSH
8387: LD_EXP 53
8391: PUSH
8392: LD_INT 1
8394: ARRAY
8395: PPUSH
8396: LD_INT 14
8398: PPUSH
8399: CALL_OW 308
8403: AND
8404: IFFALSE 8414
// inarea1 := true ;
8406: LD_ADDR_VAR 0 3
8410: PUSH
8411: LD_INT 1
8413: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8414: LD_VAR 0 4
8418: NOT
8419: PUSH
8420: LD_EXP 53
8424: PUSH
8425: LD_INT 2
8427: ARRAY
8428: PPUSH
8429: LD_INT 14
8431: PPUSH
8432: CALL_OW 308
8436: AND
8437: IFFALSE 8447
// inarea2 := true ;
8439: LD_ADDR_VAR 0 4
8443: PUSH
8444: LD_INT 1
8446: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8447: LD_VAR 0 1
8451: PUSH
8452: LD_VAR 0 2
8456: AND
8457: PUSH
8458: LD_VAR 0 1
8462: PUSH
8463: LD_VAR 0 4
8467: AND
8468: OR
8469: PUSH
8470: LD_VAR 0 2
8474: PUSH
8475: LD_VAR 0 3
8479: AND
8480: OR
8481: PUSH
8482: LD_VAR 0 3
8486: PUSH
8487: LD_VAR 0 4
8491: AND
8492: OR
8493: IFFALSE 8314
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8495: LD_VAR 0 3
8499: PUSH
8500: LD_VAR 0 4
8504: AND
8505: PUSH
8506: LD_VAR 0 1
8510: PUSH
8511: LD_VAR 0 4
8515: AND
8516: OR
8517: PUSH
8518: LD_VAR 0 2
8522: PUSH
8523: LD_VAR 0 3
8527: AND
8528: OR
8529: IFFALSE 9121
// begin prepare_siege := true ;
8531: LD_ADDR_EXP 30
8535: PUSH
8536: LD_INT 1
8538: ST_TO_ADDR
// DialogueOn ;
8539: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8543: LD_VAR 0 3
8547: PUSH
8548: LD_VAR 0 4
8552: AND
8553: IFFALSE 8569
// Say ( JMM , D8b-JMM-1a ) else
8555: LD_EXP 36
8559: PPUSH
8560: LD_STRING D8b-JMM-1a
8562: PPUSH
8563: CALL_OW 88
8567: GO 8581
// Say ( JMM , D8b-JMM-1 ) ;
8569: LD_EXP 36
8573: PPUSH
8574: LD_STRING D8b-JMM-1
8576: PPUSH
8577: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8581: LD_EXP 4
8585: PPUSH
8586: LD_INT 26
8588: PUSH
8589: LD_INT 1
8591: PUSH
8592: EMPTY
8593: LIST
8594: LIST
8595: PPUSH
8596: CALL_OW 72
8600: PUSH
8601: LD_EXP 37
8605: PUSH
8606: LD_EXP 38
8610: PUSH
8611: LD_EXP 47
8615: PUSH
8616: LD_EXP 50
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: LIST
8625: LIST
8626: DIFF
8627: PPUSH
8628: LD_STRING D8b-Sol1-1
8630: PPUSH
8631: CALL 625 0 2
// if Cyrus and Cyrus in jmm_units then
8635: LD_EXP 38
8639: PUSH
8640: LD_EXP 38
8644: PUSH
8645: LD_EXP 4
8649: IN
8650: AND
8651: IFFALSE 8667
// Say ( Cyrus , D8b-Cyrus-1 ) else
8653: LD_EXP 38
8657: PPUSH
8658: LD_STRING D8b-Cyrus-1
8660: PPUSH
8661: CALL_OW 88
8665: GO 8679
// Say ( JMM , D8b-JMM-1a ) ;
8667: LD_EXP 36
8671: PPUSH
8672: LD_STRING D8b-JMM-1a
8674: PPUSH
8675: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8679: LD_EXP 39
8683: PUSH
8684: LD_EXP 39
8688: PUSH
8689: LD_EXP 4
8693: IN
8694: AND
8695: IFFALSE 8709
// Say ( Lisa , D8b-Lisa-2 ) ;
8697: LD_EXP 39
8701: PPUSH
8702: LD_STRING D8b-Lisa-2
8704: PPUSH
8705: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8709: LD_EXP 37
8713: PUSH
8714: LD_EXP 37
8718: PUSH
8719: LD_EXP 4
8723: IN
8724: AND
8725: IFFALSE 8741
// Say ( Bobby , D8b-Bobby-1 ) else
8727: LD_EXP 37
8731: PPUSH
8732: LD_STRING D8b-Bobby-1
8734: PPUSH
8735: CALL_OW 88
8739: GO 8801
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8741: LD_ADDR_VAR 0 5
8745: PUSH
8746: LD_EXP 4
8750: PPUSH
8751: LD_INT 26
8753: PUSH
8754: LD_INT 1
8756: PUSH
8757: EMPTY
8758: LIST
8759: LIST
8760: PPUSH
8761: CALL_OW 72
8765: PUSH
8766: LD_EXP 37
8770: PUSH
8771: LD_EXP 38
8775: PUSH
8776: LD_EXP 47
8780: PUSH
8781: LD_EXP 50
8785: PUSH
8786: EMPTY
8787: LIST
8788: LIST
8789: LIST
8790: LIST
8791: DIFF
8792: PPUSH
8793: LD_STRING D8b-Sol2-1
8795: PPUSH
8796: CALL 625 0 2
8800: ST_TO_ADDR
// DialogueOff ;
8801: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8805: LD_EXP 38
8809: PUSH
8810: LD_EXP 38
8814: PUSH
8815: LD_EXP 4
8819: IN
8820: AND
8821: IFFALSE 8846
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8823: LD_ADDR_VAR 0 6
8827: PUSH
8828: LD_VAR 0 6
8832: PPUSH
8833: LD_INT 1
8835: PPUSH
8836: LD_EXP 38
8840: PPUSH
8841: CALL_OW 2
8845: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8846: LD_EXP 37
8850: PUSH
8851: LD_EXP 37
8855: PUSH
8856: LD_EXP 4
8860: IN
8861: AND
8862: IFFALSE 8887
// tmp := Insert ( tmp , 1 , Bobby ) ;
8864: LD_ADDR_VAR 0 6
8868: PUSH
8869: LD_VAR 0 6
8873: PPUSH
8874: LD_INT 1
8876: PPUSH
8877: LD_EXP 37
8881: PPUSH
8882: CALL_OW 2
8886: ST_TO_ADDR
// if sol then
8887: LD_VAR 0 5
8891: IFFALSE 8916
// tmp := Insert ( tmp , 1 , sol ) ;
8893: LD_ADDR_VAR 0 6
8897: PUSH
8898: LD_VAR 0 6
8902: PPUSH
8903: LD_INT 1
8905: PPUSH
8906: LD_VAR 0 5
8910: PPUSH
8911: CALL_OW 2
8915: ST_TO_ADDR
// if tmp then
8916: LD_VAR 0 6
8920: IFFALSE 9080
// begin SetSide ( tmp , 8 ) ;
8922: LD_VAR 0 6
8926: PPUSH
8927: LD_INT 8
8929: PPUSH
8930: CALL_OW 235
// ComFree ( tmp ) ;
8934: LD_VAR 0 6
8938: PPUSH
8939: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8943: LD_VAR 0 6
8947: PPUSH
8948: LD_INT 15
8950: PPUSH
8951: CALL_OW 173
// AddComHold ( tmp ) ;
8955: LD_VAR 0 6
8959: PPUSH
8960: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8964: LD_INT 35
8966: PPUSH
8967: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
8971: LD_VAR 0 6
8975: PUSH
8976: LD_INT 1
8978: ARRAY
8979: PPUSH
8980: CALL_OW 314
8984: NOT
8985: IFFALSE 8999
// ComMoveToArea ( tmp , cyrusEscape ) ;
8987: LD_VAR 0 6
8991: PPUSH
8992: LD_INT 15
8994: PPUSH
8995: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8999: LD_VAR 0 6
9003: PUSH
9004: LD_INT 1
9006: ARRAY
9007: PPUSH
9008: LD_INT 15
9010: PPUSH
9011: CALL_OW 308
9015: IFFALSE 9070
// begin RemoveUnit ( tmp [ 1 ] ) ;
9017: LD_VAR 0 6
9021: PUSH
9022: LD_INT 1
9024: ARRAY
9025: PPUSH
9026: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
9030: LD_ADDR_EXP 4
9034: PUSH
9035: LD_EXP 4
9039: PUSH
9040: LD_VAR 0 6
9044: PUSH
9045: LD_INT 1
9047: ARRAY
9048: DIFF
9049: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
9050: LD_ADDR_VAR 0 6
9054: PUSH
9055: LD_VAR 0 6
9059: PUSH
9060: LD_VAR 0 6
9064: PUSH
9065: LD_INT 1
9067: ARRAY
9068: DIFF
9069: ST_TO_ADDR
// end ; until tmp = 0 ;
9070: LD_VAR 0 6
9074: PUSH
9075: LD_INT 0
9077: EQUAL
9078: IFFALSE 8964
// end ; Wait ( 0 0$30 ) ;
9080: LD_INT 1050
9082: PPUSH
9083: CALL_OW 67
// if ru_spec_patrol then
9087: LD_EXP 53
9091: IFFALSE 9119
// for i in ru_spec_patrol do
9093: LD_ADDR_VAR 0 7
9097: PUSH
9098: LD_EXP 53
9102: PUSH
9103: FOR_IN
9104: IFFALSE 9117
// RemoveUnit ( i ) ;
9106: LD_VAR 0 7
9110: PPUSH
9111: CALL_OW 64
9115: GO 9103
9117: POP
9118: POP
// end else
9119: GO 9141
// begin prepare_siege := false ;
9121: LD_ADDR_EXP 30
9125: PUSH
9126: LD_INT 0
9128: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
9129: LD_EXP 36
9133: PPUSH
9134: LD_STRING D8a-JMM-1
9136: PPUSH
9137: CALL_OW 88
// end ; end ;
9141: PPOPN 7
9143: END
// every 0 0$10 trigger frank_can_return do var i , p , points ;
9144: LD_EXP 12
9148: IFFALSE 10380
9150: GO 9152
9152: DISABLE
9153: LD_INT 0
9155: PPUSH
9156: PPUSH
9157: PPUSH
// begin uc_side := 8 ;
9158: LD_ADDR_OWVAR 20
9162: PUSH
9163: LD_INT 8
9165: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
9166: LD_ADDR_VAR 0 3
9170: PUSH
9171: LD_INT 59
9173: PUSH
9174: LD_INT 71
9176: PUSH
9177: EMPTY
9178: LIST
9179: LIST
9180: PUSH
9181: LD_INT 122
9183: PUSH
9184: LD_INT 117
9186: PUSH
9187: EMPTY
9188: LIST
9189: LIST
9190: PUSH
9191: EMPTY
9192: LIST
9193: LIST
9194: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9195: LD_ADDR_EXP 50
9199: PUSH
9200: LD_STRING Frank
9202: PPUSH
9203: LD_INT 0
9205: PPUSH
9206: CALL 474 0 2
9210: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9211: LD_ADDR_VAR 0 1
9215: PUSH
9216: LD_INT 1
9218: PPUSH
9219: LD_INT 2
9221: PPUSH
9222: CALL_OW 12
9226: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9227: LD_EXP 50
9231: PPUSH
9232: LD_VAR 0 3
9236: PUSH
9237: LD_VAR 0 1
9241: ARRAY
9242: PUSH
9243: LD_INT 1
9245: ARRAY
9246: PPUSH
9247: LD_VAR 0 3
9251: PUSH
9252: LD_VAR 0 1
9256: ARRAY
9257: PUSH
9258: LD_INT 2
9260: ARRAY
9261: PPUSH
9262: LD_INT 0
9264: PPUSH
9265: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9269: LD_EXP 50
9273: PPUSH
9274: LD_INT 1
9276: PPUSH
9277: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9281: LD_INT 35
9283: PPUSH
9284: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 and GetLives ( Frank ) > 250 ;
9288: LD_EXP 50
9292: PPUSH
9293: LD_EXP 36
9297: PPUSH
9298: CALL_OW 296
9302: PUSH
9303: LD_INT 8
9305: LESS
9306: PUSH
9307: LD_EXP 50
9311: PPUSH
9312: CALL_OW 256
9316: PUSH
9317: LD_INT 250
9319: GREATER
9320: AND
9321: IFFALSE 9281
// Video ( true ) ;
9323: LD_INT 1
9325: PPUSH
9326: CALL 1185 0 1
// CenterOnUnits ( JMM ) ;
9330: LD_EXP 36
9334: PPUSH
9335: CALL_OW 85
// if IsInUnit ( JMM ) then
9339: LD_EXP 36
9343: PPUSH
9344: CALL_OW 310
9348: IFFALSE 9359
// ComFree ( JMM ) ;
9350: LD_EXP 36
9354: PPUSH
9355: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9359: LD_EXP 36
9363: PPUSH
9364: LD_EXP 50
9368: PPUSH
9369: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9373: LD_EXP 50
9377: PPUSH
9378: LD_EXP 36
9382: PPUSH
9383: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9387: LD_EXP 36
9391: PPUSH
9392: LD_STRING D6-JMM-1
9394: PPUSH
9395: CALL_OW 88
// p := 0 ;
9399: LD_ADDR_VAR 0 2
9403: PUSH
9404: LD_INT 0
9406: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9407: LD_INT 35
9409: PPUSH
9410: CALL_OW 67
// p := p + 1 ;
9414: LD_ADDR_VAR 0 2
9418: PUSH
9419: LD_VAR 0 2
9423: PUSH
9424: LD_INT 1
9426: PLUS
9427: ST_TO_ADDR
// until GetDistUnits ( JMM , Frank ) < 8 or p > 7 ;
9428: LD_EXP 36
9432: PPUSH
9433: LD_EXP 50
9437: PPUSH
9438: CALL_OW 296
9442: PUSH
9443: LD_INT 8
9445: LESS
9446: PUSH
9447: LD_VAR 0 2
9451: PUSH
9452: LD_INT 7
9454: GREATER
9455: OR
9456: IFFALSE 9407
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9458: LD_EXP 39
9462: PUSH
9463: LD_EXP 39
9467: PPUSH
9468: LD_EXP 50
9472: PPUSH
9473: CALL_OW 296
9477: PUSH
9478: LD_INT 20
9480: LESS
9481: AND
9482: IFFALSE 9507
// begin ComFree ( Lisa ) ;
9484: LD_EXP 39
9488: PPUSH
9489: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9493: LD_EXP 39
9497: PPUSH
9498: LD_EXP 50
9502: PPUSH
9503: CALL_OW 172
// end ; if Lynch then
9507: LD_EXP 46
9511: IFFALSE 9536
// begin ComFree ( Lynch ) ;
9513: LD_EXP 46
9517: PPUSH
9518: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9522: LD_EXP 46
9526: PPUSH
9527: LD_EXP 50
9531: PPUSH
9532: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9536: LD_EXP 36
9540: PPUSH
9541: LD_EXP 50
9545: PPUSH
9546: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9550: LD_EXP 50
9554: PPUSH
9555: LD_EXP 36
9559: PPUSH
9560: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9564: LD_EXP 50
9568: PPUSH
9569: LD_STRING D6-Frank-1
9571: PPUSH
9572: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9576: LD_INT 69
9578: PPUSH
9579: LD_INT 20
9581: PPUSH
9582: LD_INT 1
9584: PPUSH
9585: LD_INT 20
9587: NEG
9588: PPUSH
9589: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9593: LD_INT 69
9595: PPUSH
9596: LD_INT 20
9598: PPUSH
9599: LD_INT 1
9601: PPUSH
9602: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9606: LD_INT 190
9608: PPUSH
9609: LD_INT 31
9611: PPUSH
9612: LD_INT 1
9614: PPUSH
9615: LD_INT 20
9617: NEG
9618: PPUSH
9619: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9623: LD_INT 190
9625: PPUSH
9626: LD_INT 31
9628: PPUSH
9629: LD_INT 1
9631: PPUSH
9632: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9636: LD_INT 69
9638: PPUSH
9639: LD_INT 20
9641: PPUSH
9642: CALL_OW 84
// Wait ( 0 0$02 ) ;
9646: LD_INT 70
9648: PPUSH
9649: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9653: LD_EXP 36
9657: PPUSH
9658: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9662: LD_EXP 39
9666: PUSH
9667: LD_EXP 39
9671: PPUSH
9672: LD_EXP 50
9676: PPUSH
9677: CALL_OW 296
9681: PUSH
9682: LD_INT 20
9684: LESS
9685: AND
9686: PUSH
9687: LD_EXP 39
9691: PPUSH
9692: CALL_OW 302
9696: AND
9697: IFFALSE 9819
// begin ComFree ( Lisa ) ;
9699: LD_EXP 39
9703: PPUSH
9704: CALL_OW 139
// p := 0 ;
9708: LD_ADDR_VAR 0 2
9712: PUSH
9713: LD_INT 0
9715: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9716: LD_INT 35
9718: PPUSH
9719: CALL_OW 67
// p := p + 1 ;
9723: LD_ADDR_VAR 0 2
9727: PUSH
9728: LD_VAR 0 2
9732: PUSH
9733: LD_INT 1
9735: PLUS
9736: ST_TO_ADDR
// until GetDistUnits ( Lisa , Frank ) < 7 or p > 7 ;
9737: LD_EXP 39
9741: PPUSH
9742: LD_EXP 50
9746: PPUSH
9747: CALL_OW 296
9751: PUSH
9752: LD_INT 7
9754: LESS
9755: PUSH
9756: LD_VAR 0 2
9760: PUSH
9761: LD_INT 7
9763: GREATER
9764: OR
9765: IFFALSE 9716
// Say ( Lisa , D6-Lisa-1 ) ;
9767: LD_EXP 39
9771: PPUSH
9772: LD_STRING D6-Lisa-1
9774: PPUSH
9775: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9779: LD_EXP 39
9783: PPUSH
9784: LD_EXP 50
9788: PPUSH
9789: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9793: LD_EXP 50
9797: PPUSH
9798: LD_EXP 39
9802: PPUSH
9803: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9807: LD_EXP 50
9811: PPUSH
9812: LD_STRING D6-Frank-2
9814: PPUSH
9815: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9819: LD_EXP 46
9823: PUSH
9824: LD_EXP 46
9828: PPUSH
9829: LD_EXP 50
9833: PPUSH
9834: CALL_OW 296
9838: PUSH
9839: LD_INT 20
9841: LESS
9842: AND
9843: PUSH
9844: LD_EXP 46
9848: PPUSH
9849: CALL_OW 302
9853: AND
9854: IFFALSE 10035
// begin ComTurnUnit ( Lynch , JMM ) ;
9856: LD_EXP 46
9860: PPUSH
9861: LD_EXP 36
9865: PPUSH
9866: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9870: LD_EXP 50
9874: PPUSH
9875: LD_EXP 36
9879: PPUSH
9880: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9884: LD_EXP 46
9888: PPUSH
9889: LD_STRING D6-Sol1-2
9891: PPUSH
9892: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9896: LD_EXP 36
9900: PPUSH
9901: LD_STRING D6-JMM-2
9903: PPUSH
9904: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9908: LD_EXP 50
9912: PPUSH
9913: LD_STRING D6-Frank-3
9915: PPUSH
9916: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9920: LD_EXP 36
9924: PPUSH
9925: LD_STRING D6-JMM-3
9927: PPUSH
9928: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9932: LD_EXP 50
9936: PPUSH
9937: LD_STRING D6-Frank-4
9939: PPUSH
9940: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9944: LD_EXP 50
9948: PPUSH
9949: LD_STRING D6-Frank-4a
9951: PPUSH
9952: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9956: LD_EXP 36
9960: PPUSH
9961: LD_STRING D6-JMM-4
9963: PPUSH
9964: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9968: LD_EXP 50
9972: PPUSH
9973: LD_STRING D6-Frank-5
9975: PPUSH
9976: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9980: LD_EXP 39
9984: PUSH
9985: LD_EXP 39
9989: PPUSH
9990: CALL_OW 302
9994: AND
9995: IFFALSE 10009
// Say ( Lisa , D6-Lisa-5 ) ;
9997: LD_EXP 39
10001: PPUSH
10002: LD_STRING D6-Lisa-5
10004: PPUSH
10005: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10009: LD_EXP 50
10013: PPUSH
10014: LD_STRING D6-Frank-6
10016: PPUSH
10017: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10021: LD_EXP 36
10025: PPUSH
10026: LD_STRING D6-JMM-6
10028: PPUSH
10029: CALL_OW 88
// end else
10033: GO 10150
// begin ComTurnUnit ( Frank , JMM ) ;
10035: LD_EXP 50
10039: PPUSH
10040: LD_EXP 36
10044: PPUSH
10045: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
10049: LD_EXP 50
10053: PPUSH
10054: LD_STRING D6-Frank-4
10056: PPUSH
10057: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10061: LD_EXP 50
10065: PPUSH
10066: LD_STRING D6-Frank-4a
10068: PPUSH
10069: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10073: LD_EXP 36
10077: PPUSH
10078: LD_STRING D6-JMM-4
10080: PPUSH
10081: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10085: LD_EXP 50
10089: PPUSH
10090: LD_STRING D6-Frank-5
10092: PPUSH
10093: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10097: LD_EXP 39
10101: PUSH
10102: LD_EXP 39
10106: PPUSH
10107: CALL_OW 302
10111: AND
10112: IFFALSE 10126
// Say ( Lisa , D6-Lisa-5 ) ;
10114: LD_EXP 39
10118: PPUSH
10119: LD_STRING D6-Lisa-5
10121: PPUSH
10122: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10126: LD_EXP 50
10130: PPUSH
10131: LD_STRING D6-Frank-6
10133: PPUSH
10134: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10138: LD_EXP 36
10142: PPUSH
10143: LD_STRING D6-JMM-6
10145: PPUSH
10146: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
10150: LD_STRING Q1
10152: PPUSH
10153: CALL_OW 97
10157: PUSH
10158: LD_INT 1
10160: DOUBLE
10161: EQUAL
10162: IFTRUE 10166
10164: GO 10177
10166: POP
// frank_send_to_scout := true ; 2 :
10167: LD_ADDR_EXP 14
10171: PUSH
10172: LD_INT 1
10174: ST_TO_ADDR
10175: GO 10197
10177: LD_INT 2
10179: DOUBLE
10180: EQUAL
10181: IFTRUE 10185
10183: GO 10196
10185: POP
// frank_send_to_scout := false ; end ;
10186: LD_ADDR_EXP 14
10190: PUSH
10191: LD_INT 0
10193: ST_TO_ADDR
10194: GO 10197
10196: POP
// Video ( false ) ;
10197: LD_INT 0
10199: PPUSH
10200: CALL 1185 0 1
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
10204: LD_EXP 36
10208: PUSH
10209: LD_EXP 39
10213: PUSH
10214: LD_EXP 46
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: LIST
10223: PPUSH
10224: CALL_OW 139
// if frank_send_to_scout then
10228: LD_EXP 14
10232: IFFALSE 10301
// begin repeat if not HasTask ( Frank ) then
10234: LD_EXP 50
10238: PPUSH
10239: CALL_OW 314
10243: NOT
10244: IFFALSE 10261
// ComMoveXY ( Frank , 130 , 123 ) ;
10246: LD_EXP 50
10250: PPUSH
10251: LD_INT 130
10253: PPUSH
10254: LD_INT 123
10256: PPUSH
10257: CALL_OW 111
// wait ( 0 0$01 ) ;
10261: LD_INT 35
10263: PPUSH
10264: CALL_OW 67
// until not See ( 1 , Frank ) ;
10268: LD_INT 1
10270: PPUSH
10271: LD_EXP 50
10275: PPUSH
10276: CALL_OW 292
10280: NOT
10281: IFFALSE 10234
// Wait ( 0 0$02 ) ;
10283: LD_INT 70
10285: PPUSH
10286: CALL_OW 67
// RemoveUnit ( Frank ) ;
10290: LD_EXP 50
10294: PPUSH
10295: CALL_OW 64
// end else
10299: GO 10313
// SetSide ( Frank , 1 ) ;
10301: LD_EXP 50
10305: PPUSH
10306: LD_INT 1
10308: PPUSH
10309: CALL_OW 235
// send_attack_on_cornel_base := true ;
10313: LD_ADDR_EXP 25
10317: PUSH
10318: LD_INT 1
10320: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10321: LD_INT 35
10323: PPUSH
10324: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10328: LD_ADDR_EXP 28
10332: PUSH
10333: LD_EXP 28
10337: PPUSH
10338: LD_STRING -
10340: PPUSH
10341: CALL 1117 0 2
10345: ST_TO_ADDR
// if debug then
10346: LD_EXP 1
10350: IFFALSE 10362
// debug_strings := time_to_prepare ;
10352: LD_ADDR_OWVAR 48
10356: PUSH
10357: LD_EXP 28
10361: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10362: LD_EXP 28
10366: PUSH
10367: LD_INT 0
10369: EQUAL
10370: IFFALSE 10321
// cornel_prepared := true ;
10372: LD_ADDR_EXP 11
10376: PUSH
10377: LD_INT 1
10379: ST_TO_ADDR
// end ;
10380: PPOPN 3
10382: END
// every 0 0$01 trigger cornel_prepared do
10383: LD_EXP 11
10387: IFFALSE 10651
10389: GO 10391
10391: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10392: LD_EXP 43
10396: PPUSH
10397: LD_STRING D3-Corn-1
10399: PPUSH
10400: CALL_OW 94
// ChangeMissionObjectives ( MOutWait ) ;
10404: LD_STRING MOutWait
10406: PPUSH
10407: CALL_OW 337
// repeat wait ( 0 0$01 ) ;
10411: LD_INT 35
10413: PPUSH
10414: CALL_OW 67
// until cornel_counter = 0 ;
10418: LD_EXP 10
10422: PUSH
10423: LD_INT 0
10425: EQUAL
10426: IFFALSE 10411
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10428: LD_EXP 43
10432: PPUSH
10433: LD_STRING D3a-Corn-1
10435: PPUSH
10436: CALL_OW 94
// if IsOk ( Cornel ) then
10440: LD_EXP 43
10444: PPUSH
10445: CALL_OW 302
10449: IFFALSE 10463
// Say ( JMM , D3a-JMM-1 ) ;
10451: LD_EXP 36
10455: PPUSH
10456: LD_STRING D3a-JMM-1
10458: PPUSH
10459: CALL_OW 88
// end_mission_allowed := true ;
10463: LD_ADDR_EXP 20
10467: PUSH
10468: LD_INT 1
10470: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10471: LD_STRING M2
10473: PPUSH
10474: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10478: LD_INT 9
10480: PPUSH
10481: LD_INT 1
10483: PPUSH
10484: CALL_OW 424
// Wait ( 0 0$05 ) ;
10488: LD_INT 175
10490: PPUSH
10491: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10495: LD_EXP 43
10499: PPUSH
10500: LD_STRING D3a-Corn-2
10502: PPUSH
10503: CALL_OW 94
// cornel_attack := true ;
10507: LD_ADDR_EXP 9
10511: PUSH
10512: LD_INT 1
10514: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10515: LD_INT 105
10517: PPUSH
10518: CALL_OW 67
// AddMoreTanks ( ) ;
10522: CALL 4862 0 0
// if frank_send_to_scout then
10526: LD_EXP 14
10530: IFFALSE 10651
// begin InitHc ;
10532: CALL_OW 19
// InitUc ;
10536: CALL_OW 18
// uc_side := 8 ;
10540: LD_ADDR_OWVAR 20
10544: PUSH
10545: LD_INT 8
10547: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10548: LD_ADDR_EXP 50
10552: PUSH
10553: LD_STRING Frank
10555: PPUSH
10556: LD_INT 0
10558: PPUSH
10559: CALL 474 0 2
10563: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10564: LD_EXP 50
10568: PPUSH
10569: LD_INT 6
10571: PPUSH
10572: LD_INT 9
10574: PPUSH
10575: LD_INT 0
10577: PPUSH
10578: CALL_OW 48
// ComCrawl ( Frank ) ;
10582: LD_EXP 50
10586: PPUSH
10587: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
10591: LD_INT 35
10593: PPUSH
10594: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
10598: LD_EXP 36
10602: PPUSH
10603: LD_EXP 50
10607: PPUSH
10608: CALL_OW 296
10612: PUSH
10613: LD_INT 9
10615: LESS
10616: IFFALSE 10591
// SetSide ( Frank , 1 ) ;
10618: LD_EXP 50
10622: PPUSH
10623: LD_INT 1
10625: PPUSH
10626: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10630: LD_EXP 50
10634: PPUSH
10635: LD_STRING D6a-Frank-1
10637: PPUSH
10638: CALL_OW 88
// ComWalk ( Frank ) ;
10642: LD_EXP 50
10646: PPUSH
10647: CALL_OW 138
// end ; end ;
10651: END
// every 0 0$01 trigger solar_builded do
10652: LD_EXP 13
10656: IFFALSE 10760
10658: GO 10660
10660: DISABLE
// begin Wait ( 0 0$02 ) ;
10661: LD_INT 70
10663: PPUSH
10664: CALL_OW 67
// DialogueOn ;
10668: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10672: LD_EXP 36
10676: PPUSH
10677: LD_STRING D2b-JMM-1
10679: PPUSH
10680: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10684: LD_EXP 47
10688: PUSH
10689: LD_EXP 47
10693: PPUSH
10694: CALL_OW 302
10698: AND
10699: IFFALSE 10749
// begin Say ( Walker , D2b-Sci1-1 ) ;
10701: LD_EXP 47
10705: PPUSH
10706: LD_STRING D2b-Sci1-1
10708: PPUSH
10709: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10713: LD_EXP 36
10717: PPUSH
10718: LD_STRING D2b-JMM-2
10720: PPUSH
10721: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10725: LD_EXP 47
10729: PPUSH
10730: LD_STRING D2b-Sci1-2
10732: PPUSH
10733: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10737: LD_EXP 36
10741: PPUSH
10742: LD_STRING D2b-JMM-3
10744: PPUSH
10745: CALL_OW 88
// end ; DialogueOff ;
10749: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10753: LD_STRING MOutSol
10755: PPUSH
10756: CALL_OW 337
// end ;
10760: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10761: LD_EXP 13
10765: PUSH
10766: LD_EXP 36
10770: PPUSH
10771: CALL_OW 302
10775: AND
10776: PUSH
10777: LD_EXP 36
10781: PPUSH
10782: CALL 951 0 1
10786: AND
10787: PUSH
10788: LD_EXP 15
10792: NOT
10793: AND
10794: IFFALSE 10865
10796: GO 10798
10798: DISABLE
10799: LD_INT 0
10801: PPUSH
// begin jmm_in_veh := true ;
10802: LD_ADDR_EXP 15
10806: PUSH
10807: LD_INT 1
10809: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10810: LD_ADDR_VAR 0 1
10814: PUSH
10815: LD_INT 0
10817: PPUSH
10818: LD_INT 1
10820: PPUSH
10821: CALL_OW 12
10825: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10826: LD_INT 70
10828: PPUSH
10829: CALL_OW 67
// if i then
10833: LD_VAR 0 1
10837: IFFALSE 10853
// Say ( JMM , D2c-JMM-1 ) else
10839: LD_EXP 36
10843: PPUSH
10844: LD_STRING D2c-JMM-1
10846: PPUSH
10847: CALL_OW 88
10851: GO 10865
// Say ( JMM , D2c-JMM-1a ) ;
10853: LD_EXP 36
10857: PPUSH
10858: LD_STRING D2c-JMM-1a
10860: PPUSH
10861: CALL_OW 88
// end ;
10865: PPOPN 1
10867: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10868: LD_EXP 13
10872: PUSH
10873: LD_EXP 37
10877: PPUSH
10878: CALL_OW 302
10882: AND
10883: PUSH
10884: LD_EXP 37
10888: PPUSH
10889: CALL 951 0 1
10893: AND
10894: PUSH
10895: LD_EXP 16
10899: NOT
10900: AND
10901: IFFALSE 10933
10903: GO 10905
10905: DISABLE
// begin bobby_in_veh := true ;
10906: LD_ADDR_EXP 16
10910: PUSH
10911: LD_INT 1
10913: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10914: LD_INT 70
10916: PPUSH
10917: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10921: LD_EXP 37
10925: PPUSH
10926: LD_STRING D2c-Bobby-1
10928: PPUSH
10929: CALL_OW 88
10933: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10934: LD_EXP 13
10938: PUSH
10939: LD_EXP 39
10943: PPUSH
10944: CALL_OW 302
10948: AND
10949: PUSH
10950: LD_EXP 39
10954: PPUSH
10955: CALL 951 0 1
10959: AND
10960: PUSH
10961: LD_EXP 18
10965: NOT
10966: AND
10967: IFFALSE 10999
10969: GO 10971
10971: DISABLE
// begin lisa_in_veh := true ;
10972: LD_ADDR_EXP 18
10976: PUSH
10977: LD_INT 1
10979: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10980: LD_INT 70
10982: PPUSH
10983: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10987: LD_EXP 39
10991: PPUSH
10992: LD_STRING D2c-Lisa-1
10994: PPUSH
10995: CALL_OW 88
10999: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
11000: LD_EXP 13
11004: PUSH
11005: LD_EXP 38
11009: PPUSH
11010: CALL_OW 302
11014: AND
11015: PUSH
11016: LD_EXP 38
11020: PPUSH
11021: CALL 951 0 1
11025: AND
11026: PUSH
11027: LD_EXP 17
11031: NOT
11032: AND
11033: IFFALSE 11104
11035: GO 11037
11037: DISABLE
11038: LD_INT 0
11040: PPUSH
// begin cyrus_in_veh := true ;
11041: LD_ADDR_EXP 17
11045: PUSH
11046: LD_INT 1
11048: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
11049: LD_ADDR_VAR 0 1
11053: PUSH
11054: LD_INT 0
11056: PPUSH
11057: LD_INT 1
11059: PPUSH
11060: CALL_OW 12
11064: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11065: LD_INT 70
11067: PPUSH
11068: CALL_OW 67
// if i then
11072: LD_VAR 0 1
11076: IFFALSE 11092
// Say ( Cyrus , D2c-Cyrus-1 ) else
11078: LD_EXP 38
11082: PPUSH
11083: LD_STRING D2c-Cyrus-1
11085: PPUSH
11086: CALL_OW 88
11090: GO 11104
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11092: LD_EXP 38
11096: PPUSH
11097: LD_STRING D2c-Cyrus-1a
11099: PPUSH
11100: CALL_OW 88
// end ;
11104: PPOPN 1
11106: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
11107: LD_EXP 43
11111: PPUSH
11112: LD_INT 16
11114: PPUSH
11115: CALL_OW 308
11119: IFFALSE 11400
11121: GO 11123
11123: DISABLE
11124: LD_INT 0
11126: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
11127: LD_INT 3
11129: PPUSH
11130: LD_EXP 43
11134: PPUSH
11135: CALL_OW 471
// send_attack_on_cornel := true ;
11139: LD_ADDR_EXP 31
11143: PUSH
11144: LD_INT 1
11146: ST_TO_ADDR
// if ru_vehicles then
11147: LD_EXP 55
11151: IFFALSE 11185
// for i in ru_vehicles do
11153: LD_ADDR_VAR 0 1
11157: PUSH
11158: LD_EXP 55
11162: PUSH
11163: FOR_IN
11164: IFFALSE 11183
// ComAgressiveMove ( i , 215 , 69 ) ;
11166: LD_VAR 0 1
11170: PPUSH
11171: LD_INT 215
11173: PPUSH
11174: LD_INT 69
11176: PPUSH
11177: CALL_OW 114
11181: GO 11163
11183: POP
11184: POP
// if ru_patrol then
11185: LD_EXP 52
11189: IFFALSE 11223
// for i in ru_patrol do
11191: LD_ADDR_VAR 0 1
11195: PUSH
11196: LD_EXP 52
11200: PUSH
11201: FOR_IN
11202: IFFALSE 11221
// ComAgressiveMove ( i , 215 , 69 ) ;
11204: LD_VAR 0 1
11208: PPUSH
11209: LD_INT 215
11211: PPUSH
11212: LD_INT 69
11214: PPUSH
11215: CALL_OW 114
11219: GO 11201
11221: POP
11222: POP
// if frank_send_to_scout then
11223: LD_EXP 14
11227: IFFALSE 11241
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
11229: LD_EXP 50
11233: PPUSH
11234: LD_STRING D3b-Frank-1
11236: PPUSH
11237: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
11241: LD_INT 105
11243: PPUSH
11244: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
11248: LD_EXP 43
11252: PPUSH
11253: LD_STRING D4-Corn-1
11255: PPUSH
11256: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
11260: LD_INT 35
11262: PPUSH
11263: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) < 6 ;
11267: LD_INT 22
11269: PUSH
11270: LD_INT 4
11272: PUSH
11273: EMPTY
11274: LIST
11275: LIST
11276: PUSH
11277: LD_INT 21
11279: PUSH
11280: LD_INT 1
11282: PUSH
11283: EMPTY
11284: LIST
11285: LIST
11286: PUSH
11287: LD_INT 3
11289: PUSH
11290: LD_INT 24
11292: PUSH
11293: LD_INT 1000
11295: PUSH
11296: EMPTY
11297: LIST
11298: LIST
11299: PUSH
11300: EMPTY
11301: LIST
11302: LIST
11303: PUSH
11304: EMPTY
11305: LIST
11306: LIST
11307: LIST
11308: PPUSH
11309: CALL_OW 69
11313: PUSH
11314: LD_INT 6
11316: LESS
11317: IFFALSE 11260
// if Cornel then
11319: LD_EXP 43
11323: IFFALSE 11363
// begin SayRadio ( Cornel , D5-Corn-1 ) ;
11325: LD_EXP 43
11329: PPUSH
11330: LD_STRING D5-Corn-1
11332: PPUSH
11333: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11337: LD_EXP 43
11341: PPUSH
11342: LD_EXP 2
11346: PUSH
11347: LD_STRING Cornel
11349: STR
11350: PPUSH
11351: CALL_OW 38
// cornel_saved := true ;
11355: LD_ADDR_EXP 26
11359: PUSH
11360: LD_INT 1
11362: ST_TO_ADDR
// end ; ChangeSideFog ( 4 , 8 ) ;
11363: LD_INT 4
11365: PPUSH
11366: LD_INT 8
11368: PPUSH
11369: CALL_OW 343
// Wait ( 0 0$01 ) ;
11373: LD_INT 35
11375: PPUSH
11376: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11380: LD_INT 3
11382: PPUSH
11383: LD_EXP 43
11387: PPUSH
11388: CALL_OW 472
// send_attack_on_cornel := false ;
11392: LD_ADDR_EXP 31
11396: PUSH
11397: LD_INT 0
11399: ST_TO_ADDR
// end ;
11400: PPOPN 1
11402: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11403: LD_INT 9
11405: PPUSH
11406: LD_INT 22
11408: PUSH
11409: LD_INT 1
11411: PUSH
11412: EMPTY
11413: LIST
11414: LIST
11415: PPUSH
11416: CALL_OW 70
11420: PUSH
11421: LD_EXP 32
11425: OR
11426: IFFALSE 11623
11428: GO 11430
11430: DISABLE
11431: LD_INT 0
11433: PPUSH
11434: PPUSH
// begin enable ;
11435: ENABLE
// if not jmm_on_west then
11436: LD_EXP 5
11440: NOT
11441: IFFALSE 11452
// begin YouLost ( 4 ) ;
11443: LD_STRING 4
11445: PPUSH
11446: CALL_OW 104
// exit ;
11450: GO 11623
// end ; if not game_end then
11452: LD_EXP 32
11456: NOT
11457: IFFALSE 11467
// game_end := true ;
11459: LD_ADDR_EXP 32
11463: PUSH
11464: LD_INT 1
11466: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11467: LD_ADDR_VAR 0 2
11471: PUSH
11472: LD_INT 9
11474: PPUSH
11475: LD_INT 22
11477: PUSH
11478: LD_INT 1
11480: PUSH
11481: EMPTY
11482: LIST
11483: LIST
11484: PPUSH
11485: CALL_OW 70
11489: ST_TO_ADDR
// if not filter then
11490: LD_VAR 0 2
11494: NOT
11495: IFFALSE 11499
// exit ;
11497: GO 11623
// for i in filter do
11499: LD_ADDR_VAR 0 1
11503: PUSH
11504: LD_VAR 0 2
11508: PUSH
11509: FOR_IN
11510: IFFALSE 11621
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle and GetNation ( i ) = nation_american then
11512: LD_VAR 0 1
11516: PPUSH
11517: CALL_OW 302
11521: PUSH
11522: LD_VAR 0 1
11526: PPUSH
11527: CALL_OW 247
11531: PUSH
11532: LD_INT 2
11534: EQUAL
11535: AND
11536: PUSH
11537: LD_VAR 0 1
11541: PPUSH
11542: CALL_OW 248
11546: PUSH
11547: LD_INT 1
11549: EQUAL
11550: AND
11551: IFFALSE 11584
// begin veh_on_meta := true ;
11553: LD_ADDR_EXP 27
11557: PUSH
11558: LD_INT 1
11560: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11561: LD_VAR 0 1
11565: PPUSH
11566: CALL_OW 311
11570: PPUSH
11571: CALL 11626 0 1
// RemoveUnit ( i ) ;
11575: LD_VAR 0 1
11579: PPUSH
11580: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11584: LD_VAR 0 1
11588: PPUSH
11589: CALL_OW 302
11593: PUSH
11594: LD_VAR 0 1
11598: PPUSH
11599: CALL_OW 247
11603: PUSH
11604: LD_INT 1
11606: EQUAL
11607: AND
11608: IFFALSE 11619
// Save ( i ) ;
11610: LD_VAR 0 1
11614: PPUSH
11615: CALL 11626 0 1
// end ;
11619: GO 11509
11621: POP
11622: POP
// end ;
11623: PPOPN 2
11625: END
// export function Save ( i ) ; begin
11626: LD_INT 0
11628: PPUSH
// save_counter := save_counter + 1 ;
11629: LD_ADDR_EXP 35
11633: PUSH
11634: LD_EXP 35
11638: PUSH
11639: LD_INT 1
11641: PLUS
11642: ST_TO_ADDR
// if i = JMM then
11643: LD_VAR 0 1
11647: PUSH
11648: LD_EXP 36
11652: EQUAL
11653: IFFALSE 11775
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11655: LD_EXP 23
11659: PUSH
11660: LD_INT 22
11662: PUSH
11663: LD_INT 1
11665: PUSH
11666: EMPTY
11667: LIST
11668: LIST
11669: PUSH
11670: LD_INT 21
11672: PUSH
11673: LD_INT 1
11675: PUSH
11676: EMPTY
11677: LIST
11678: LIST
11679: PUSH
11680: EMPTY
11681: LIST
11682: LIST
11683: PPUSH
11684: CALL_OW 69
11688: PUSH
11689: LD_INT 1
11691: GREATER
11692: AND
11693: IFFALSE 11750
// begin show_query := false ;
11695: LD_ADDR_EXP 23
11699: PUSH
11700: LD_INT 0
11702: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11703: LD_STRING Q2
11705: PPUSH
11706: CALL_OW 97
11710: PUSH
11711: LD_INT 1
11713: DOUBLE
11714: EQUAL
11715: IFTRUE 11719
11717: GO 11730
11719: POP
// wait_for_them := true ; 2 :
11720: LD_ADDR_EXP 24
11724: PUSH
11725: LD_INT 1
11727: ST_TO_ADDR
11728: GO 11750
11730: LD_INT 2
11732: DOUBLE
11733: EQUAL
11734: IFTRUE 11738
11736: GO 11749
11738: POP
// wait_for_them := false ; end ;
11739: LD_ADDR_EXP 24
11743: PUSH
11744: LD_INT 0
11746: ST_TO_ADDR
11747: GO 11750
11749: POP
// end ; save_group := save_group ^ JMM ;
11750: LD_ADDR_EXP 22
11754: PUSH
11755: LD_EXP 22
11759: PUSH
11760: LD_EXP 36
11764: ADD
11765: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11766: LD_EXP 36
11770: PPUSH
11771: CALL_OW 64
// end ; if i = Lisa then
11775: LD_VAR 0 1
11779: PUSH
11780: LD_EXP 39
11784: EQUAL
11785: IFFALSE 11812
// begin save_group := save_group ^ Lisa ;
11787: LD_ADDR_EXP 22
11791: PUSH
11792: LD_EXP 22
11796: PUSH
11797: LD_EXP 39
11801: ADD
11802: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11803: LD_EXP 39
11807: PPUSH
11808: CALL_OW 64
// end ; if i = Bobby then
11812: LD_VAR 0 1
11816: PUSH
11817: LD_EXP 37
11821: EQUAL
11822: IFFALSE 11849
// begin save_group := save_group ^ Bobby ;
11824: LD_ADDR_EXP 22
11828: PUSH
11829: LD_EXP 22
11833: PUSH
11834: LD_EXP 37
11838: ADD
11839: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11840: LD_EXP 37
11844: PPUSH
11845: CALL_OW 64
// end ; if i = Cyrus then
11849: LD_VAR 0 1
11853: PUSH
11854: LD_EXP 38
11858: EQUAL
11859: IFFALSE 11886
// begin save_group := save_group ^ Cyrus ;
11861: LD_ADDR_EXP 22
11865: PUSH
11866: LD_EXP 22
11870: PUSH
11871: LD_EXP 38
11875: ADD
11876: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11877: LD_EXP 38
11881: PPUSH
11882: CALL_OW 64
// end ; if i = Khatam then
11886: LD_VAR 0 1
11890: PUSH
11891: LD_EXP 40
11895: EQUAL
11896: IFFALSE 11923
// begin save_group := save_group ^ Khatam ;
11898: LD_ADDR_EXP 22
11902: PUSH
11903: LD_EXP 22
11907: PUSH
11908: LD_EXP 40
11912: ADD
11913: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11914: LD_EXP 40
11918: PPUSH
11919: CALL_OW 64
// end ; if i = Frank then
11923: LD_VAR 0 1
11927: PUSH
11928: LD_EXP 50
11932: EQUAL
11933: IFFALSE 11960
// begin save_group := save_group ^ Frank ;
11935: LD_ADDR_EXP 22
11939: PUSH
11940: LD_EXP 22
11944: PUSH
11945: LD_EXP 50
11949: ADD
11950: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11951: LD_EXP 50
11955: PPUSH
11956: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11960: LD_VAR 0 1
11964: PPUSH
11965: CALL_OW 302
11969: PUSH
11970: LD_VAR 0 1
11974: PPUSH
11975: CALL_OW 247
11979: PUSH
11980: LD_INT 1
11982: EQUAL
11983: AND
11984: PUSH
11985: LD_VAR 0 1
11989: PUSH
11990: LD_EXP 22
11994: IN
11995: NOT
11996: AND
11997: IFFALSE 12024
// begin save_others := save_others ^ i ;
11999: LD_ADDR_EXP 21
12003: PUSH
12004: LD_EXP 21
12008: PUSH
12009: LD_VAR 0 1
12013: ADD
12014: ST_TO_ADDR
// RemoveUnit ( i ) ;
12015: LD_VAR 0 1
12019: PPUSH
12020: CALL_OW 64
// end ; end ;
12024: LD_VAR 0 2
12028: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
12029: LD_EXP 23
12033: NOT
12034: PUSH
12035: LD_EXP 24
12039: NOT
12040: AND
12041: PUSH
12042: LD_INT 22
12044: PUSH
12045: LD_INT 1
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: PUSH
12052: LD_INT 21
12054: PUSH
12055: LD_INT 1
12057: PUSH
12058: EMPTY
12059: LIST
12060: LIST
12061: PUSH
12062: EMPTY
12063: LIST
12064: LIST
12065: PPUSH
12066: CALL_OW 69
12070: PUSH
12071: LD_INT 0
12073: EQUAL
12074: OR
12075: IFFALSE 12084
12077: GO 12079
12079: DISABLE
// EndMission ;
12080: CALL 12085 0 0
12084: END
// export function EndMission ; var i ; begin
12085: LD_INT 0
12087: PPUSH
12088: PPUSH
// Wait ( 0 0$02 ) ;
12089: LD_INT 70
12091: PPUSH
12092: CALL_OW 67
// if solar_builded then
12096: LD_EXP 13
12100: IFFALSE 12114
// AddMedal ( Solar1 , 1 ) else
12102: LD_STRING Solar1
12104: PPUSH
12105: LD_INT 1
12107: PPUSH
12108: CALL_OW 101
12112: GO 12125
// AddMedal ( Solar1 , - 1 ) ;
12114: LD_STRING Solar1
12116: PPUSH
12117: LD_INT 1
12119: NEG
12120: PPUSH
12121: CALL_OW 101
// if veh_on_meta then
12125: LD_EXP 27
12129: IFFALSE 12143
// AddMedal ( Solar2 , 1 ) else
12131: LD_STRING Solar2
12133: PPUSH
12134: LD_INT 1
12136: PPUSH
12137: CALL_OW 101
12141: GO 12173
// if solar_builded then
12143: LD_EXP 13
12147: IFFALSE 12162
// AddMedal ( Solar2 , - 1 ) else
12149: LD_STRING Solar2
12151: PPUSH
12152: LD_INT 1
12154: NEG
12155: PPUSH
12156: CALL_OW 101
12160: GO 12173
// AddMedal ( Solar2 , - 2 ) ;
12162: LD_STRING Solar2
12164: PPUSH
12165: LD_INT 2
12167: NEG
12168: PPUSH
12169: CALL_OW 101
// if lose_counter = 0 then
12173: LD_EXP 33
12177: PUSH
12178: LD_INT 0
12180: EQUAL
12181: IFFALSE 12195
// AddMedal ( No , 1 ) else
12183: LD_STRING No
12185: PPUSH
12186: LD_INT 1
12188: PPUSH
12189: CALL_OW 101
12193: GO 12239
// if lose_counter > 0 and lose_counter < 4 then
12195: LD_EXP 33
12199: PUSH
12200: LD_INT 0
12202: GREATER
12203: PUSH
12204: LD_EXP 33
12208: PUSH
12209: LD_INT 4
12211: LESS
12212: AND
12213: IFFALSE 12228
// AddMedal ( No , - 1 ) else
12215: LD_STRING No
12217: PPUSH
12218: LD_INT 1
12220: NEG
12221: PPUSH
12222: CALL_OW 101
12226: GO 12239
// AddMedal ( UpTo4 , - 1 ) ;
12228: LD_STRING UpTo4
12230: PPUSH
12231: LD_INT 1
12233: NEG
12234: PPUSH
12235: CALL_OW 101
// GiveMedals ( MAIN ) ;
12239: LD_STRING MAIN
12241: PPUSH
12242: CALL_OW 102
// if IsDead ( Pokryshkin ) then
12246: LD_EXP 51
12250: PPUSH
12251: CALL_OW 301
12255: IFFALSE 12295
// for i in save_group ^ save_others do
12257: LD_ADDR_VAR 0 2
12261: PUSH
12262: LD_EXP 22
12266: PUSH
12267: LD_EXP 21
12271: ADD
12272: PUSH
12273: FOR_IN
12274: IFFALSE 12293
// AddExperience ( i , skill_combat , 1500 ) ;
12276: LD_VAR 0 2
12280: PPUSH
12281: LD_INT 1
12283: PPUSH
12284: LD_INT 1500
12286: PPUSH
12287: CALL_OW 492
12291: GO 12273
12293: POP
12294: POP
// RewardPeople ( save_group ^ save_others ) ;
12295: LD_EXP 22
12299: PUSH
12300: LD_EXP 21
12304: ADD
12305: PPUSH
12306: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
12310: LD_EXP 36
12314: PPUSH
12315: LD_EXP 2
12319: PUSH
12320: LD_STRING JMM
12322: STR
12323: PPUSH
12324: CALL_OW 38
// if Bobby in save_group then
12328: LD_EXP 37
12332: PUSH
12333: LD_EXP 22
12337: IN
12338: IFFALSE 12358
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12340: LD_EXP 37
12344: PPUSH
12345: LD_EXP 2
12349: PUSH
12350: LD_STRING Bobby
12352: STR
12353: PPUSH
12354: CALL_OW 38
// if Cyrus in save_group then
12358: LD_EXP 38
12362: PUSH
12363: LD_EXP 22
12367: IN
12368: IFFALSE 12388
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12370: LD_EXP 38
12374: PPUSH
12375: LD_EXP 2
12379: PUSH
12380: LD_STRING Cyrus
12382: STR
12383: PPUSH
12384: CALL_OW 38
// if Lisa in save_group then
12388: LD_EXP 39
12392: PUSH
12393: LD_EXP 22
12397: IN
12398: IFFALSE 12418
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12400: LD_EXP 39
12404: PPUSH
12405: LD_EXP 2
12409: PUSH
12410: LD_STRING Lisa
12412: STR
12413: PPUSH
12414: CALL_OW 38
// if Frank in save_group then
12418: LD_EXP 50
12422: PUSH
12423: LD_EXP 22
12427: IN
12428: IFFALSE 12448
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12430: LD_EXP 50
12434: PPUSH
12435: LD_EXP 2
12439: PUSH
12440: LD_STRING Frank
12442: STR
12443: PPUSH
12444: CALL_OW 38
// if Khatam in save_group then
12448: LD_EXP 40
12452: PUSH
12453: LD_EXP 22
12457: IN
12458: IFFALSE 12478
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
12460: LD_EXP 40
12464: PPUSH
12465: LD_EXP 2
12469: PUSH
12470: LD_STRING Khatam
12472: STR
12473: PPUSH
12474: CALL_OW 38
// if save_others then
12478: LD_EXP 21
12482: IFFALSE 12496
// SaveCharacters ( save_others , 03_others ) ;
12484: LD_EXP 21
12488: PPUSH
12489: LD_STRING 03_others
12491: PPUSH
12492: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) and cornel_saved then
12496: LD_EXP 44
12500: PUSH
12501: LD_EXP 44
12505: PPUSH
12506: CALL_OW 302
12510: AND
12511: PUSH
12512: LD_EXP 26
12516: AND
12517: IFFALSE 12529
// begin ResetFog ;
12519: CALL_OW 335
// DisplayEndingScene ;
12523: CALL 12551 0 0
// end else
12527: GO 12542
// DeleteCharacters ( mission_prefix & Cornel ) ;
12529: LD_EXP 2
12533: PUSH
12534: LD_STRING Cornel
12536: STR
12537: PPUSH
12538: CALL_OW 40
// YouWin ;
12542: CALL_OW 103
// end ;
12546: LD_VAR 0 1
12550: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
12551: LD_INT 0
12553: PPUSH
12554: PPUSH
12555: PPUSH
12556: PPUSH
12557: PPUSH
12558: PPUSH
// InGameOn ;
12559: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12563: LD_INT 208
12565: PPUSH
12566: LD_INT 62
12568: PPUSH
12569: LD_INT 1
12571: PPUSH
12572: LD_INT 10
12574: NEG
12575: PPUSH
12576: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
12580: LD_INT 208
12582: PPUSH
12583: LD_INT 62
12585: PPUSH
12586: LD_INT 1
12588: PPUSH
12589: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
12593: LD_ADDR_VAR 0 3
12597: PUSH
12598: LD_INT 22
12600: PUSH
12601: LD_INT 3
12603: PUSH
12604: EMPTY
12605: LIST
12606: LIST
12607: PUSH
12608: LD_INT 2
12610: PUSH
12611: LD_INT 21
12613: PUSH
12614: LD_INT 2
12616: PUSH
12617: EMPTY
12618: LIST
12619: LIST
12620: PUSH
12621: LD_INT 21
12623: PUSH
12624: LD_INT 1
12626: PUSH
12627: EMPTY
12628: LIST
12629: LIST
12630: PUSH
12631: EMPTY
12632: LIST
12633: LIST
12634: LIST
12635: PUSH
12636: EMPTY
12637: LIST
12638: LIST
12639: PPUSH
12640: CALL_OW 69
12644: ST_TO_ADDR
// if filter then
12645: LD_VAR 0 3
12649: IFFALSE 12677
// for i in filter do
12651: LD_ADDR_VAR 0 2
12655: PUSH
12656: LD_VAR 0 3
12660: PUSH
12661: FOR_IN
12662: IFFALSE 12675
// RemoveUnit ( i ) ;
12664: LD_VAR 0 2
12668: PPUSH
12669: CALL_OW 64
12673: GO 12661
12675: POP
12676: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
12677: LD_ADDR_VAR 0 3
12681: PUSH
12682: LD_INT 22
12684: PUSH
12685: LD_INT 4
12687: PUSH
12688: EMPTY
12689: LIST
12690: LIST
12691: PUSH
12692: LD_INT 21
12694: PUSH
12695: LD_INT 1
12697: PUSH
12698: EMPTY
12699: LIST
12700: LIST
12701: PUSH
12702: EMPTY
12703: LIST
12704: LIST
12705: PPUSH
12706: CALL_OW 69
12710: ST_TO_ADDR
// if filter then
12711: LD_VAR 0 3
12715: IFFALSE 12746
// for i in filter do
12717: LD_ADDR_VAR 0 2
12721: PUSH
12722: LD_VAR 0 3
12726: PUSH
12727: FOR_IN
12728: IFFALSE 12744
// SetLives ( i , 0 ) ;
12730: LD_VAR 0 2
12734: PPUSH
12735: LD_INT 0
12737: PPUSH
12738: CALL_OW 234
12742: GO 12727
12744: POP
12745: POP
// uc_side := 4 ;
12746: LD_ADDR_OWVAR 20
12750: PUSH
12751: LD_INT 4
12753: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12754: LD_ADDR_VAR 0 4
12758: PUSH
12759: LD_STRING Cornell
12761: PPUSH
12762: LD_INT 0
12764: PPUSH
12765: CALL 474 0 2
12769: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12770: LD_VAR 0 4
12774: PPUSH
12775: LD_INT 208
12777: PPUSH
12778: LD_INT 62
12780: PPUSH
12781: LD_INT 0
12783: PPUSH
12784: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12788: LD_VAR 0 4
12792: PPUSH
12793: LD_INT 100
12795: PPUSH
12796: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12800: LD_INT 3
12802: PPUSH
12803: LD_VAR 0 4
12807: PPUSH
12808: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12812: LD_INT 4
12814: PPUSH
12815: LD_INT 3
12817: PPUSH
12818: LD_INT 1
12820: PPUSH
12821: LD_INT 1
12823: PPUSH
12824: CALL_OW 80
// uc_side := 3 ;
12828: LD_ADDR_OWVAR 20
12832: PUSH
12833: LD_INT 3
12835: ST_TO_ADDR
// uc_nation := 3 ;
12836: LD_ADDR_OWVAR 21
12840: PUSH
12841: LD_INT 3
12843: ST_TO_ADDR
// InitHc ;
12844: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12848: LD_ADDR_VAR 0 5
12852: PUSH
12853: LD_STRING Mikhail
12855: PPUSH
12856: LD_INT 0
12858: PPUSH
12859: CALL 474 0 2
12863: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12864: LD_INT 1
12866: PPUSH
12867: LD_INT 1
12869: PPUSH
12870: LD_INT 0
12872: PPUSH
12873: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12877: LD_ADDR_VAR 0 6
12881: PUSH
12882: LD_VAR 0 6
12886: PUSH
12887: CALL_OW 44
12891: ADD
12892: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12893: LD_ADDR_VAR 0 6
12897: PUSH
12898: LD_VAR 0 6
12902: PUSH
12903: CALL_OW 44
12907: ADD
12908: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12909: LD_INT 2
12911: PPUSH
12912: LD_INT 4
12914: PPUSH
12915: LD_INT 0
12917: PPUSH
12918: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12922: LD_ADDR_VAR 0 6
12926: PUSH
12927: LD_VAR 0 6
12931: PUSH
12932: CALL_OW 44
12936: ADD
12937: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12938: LD_VAR 0 5
12942: PPUSH
12943: LD_INT 17
12945: PPUSH
12946: LD_INT 0
12948: PPUSH
12949: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12953: LD_VAR 0 5
12957: PPUSH
12958: LD_INT 210
12960: PPUSH
12961: LD_INT 63
12963: PPUSH
12964: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12968: LD_VAR 0 5
12972: PPUSH
12973: LD_INT 208
12975: PPUSH
12976: LD_INT 62
12978: PPUSH
12979: CALL_OW 178
// for i in fake_russians do
12983: LD_ADDR_VAR 0 2
12987: PUSH
12988: LD_VAR 0 6
12992: PUSH
12993: FOR_IN
12994: IFFALSE 13072
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12996: LD_VAR 0 2
13000: PPUSH
13001: LD_INT 17
13003: PPUSH
13004: LD_INT 0
13006: PPUSH
13007: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
13011: LD_VAR 0 2
13015: PPUSH
13016: LD_INT 215
13018: PPUSH
13019: LD_INT 67
13021: PPUSH
13022: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
13026: LD_VAR 0 2
13030: PPUSH
13031: LD_INT 208
13033: PPUSH
13034: LD_INT 62
13036: PPUSH
13037: CALL_OW 178
// if GetClass ( i ) = 4 then
13041: LD_VAR 0 2
13045: PPUSH
13046: CALL_OW 257
13050: PUSH
13051: LD_INT 4
13053: EQUAL
13054: IFFALSE 13070
// ComHeal ( i , fake_cornel ) ;
13056: LD_VAR 0 2
13060: PPUSH
13061: LD_VAR 0 4
13065: PPUSH
13066: CALL_OW 128
// end ;
13070: GO 12993
13072: POP
13073: POP
// Wait ( 0 0$01 ) ;
13074: LD_INT 35
13076: PPUSH
13077: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
13081: LD_INT 208
13083: PPUSH
13084: LD_INT 62
13086: PPUSH
13087: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
13091: LD_INT 208
13093: PPUSH
13094: LD_INT 62
13096: PPUSH
13097: LD_INT 1
13099: PPUSH
13100: LD_INT 10
13102: NEG
13103: PPUSH
13104: CALL_OW 330
// Wait ( 0 0$15 ) ;
13108: LD_INT 525
13110: PPUSH
13111: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
13115: LD_INT 208
13117: PPUSH
13118: LD_INT 62
13120: PPUSH
13121: LD_INT 1
13123: PPUSH
13124: CALL_OW 331
// ResetFog ;
13128: CALL_OW 335
// InGameOff ;
13132: CALL_OW 9
// end ;
13136: LD_VAR 0 1
13140: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
13141: LD_INT 10
13143: PPUSH
13144: LD_INT 22
13146: PUSH
13147: LD_INT 1
13149: PUSH
13150: EMPTY
13151: LIST
13152: LIST
13153: PPUSH
13154: CALL_OW 70
13158: PUSH
13159: LD_EXP 43
13163: PPUSH
13164: CALL_OW 302
13168: AND
13169: PUSH
13170: LD_INT 22
13172: PUSH
13173: LD_INT 1
13175: PUSH
13176: EMPTY
13177: LIST
13178: LIST
13179: PPUSH
13180: CALL_OW 69
13184: PPUSH
13185: LD_EXP 43
13189: PPUSH
13190: CALL_OW 74
13194: PPUSH
13195: LD_EXP 43
13199: PPUSH
13200: CALL_OW 296
13204: PUSH
13205: LD_INT 30
13207: LESS
13208: OR
13209: IFFALSE 13260
13211: GO 13213
13213: DISABLE
// begin enable ;
13214: ENABLE
// powell_warn := powell_warn + 1 ;
13215: LD_ADDR_EXP 34
13219: PUSH
13220: LD_EXP 34
13224: PUSH
13225: LD_INT 1
13227: PLUS
13228: ST_TO_ADDR
// if powell_warn = 3 then
13229: LD_EXP 34
13233: PUSH
13234: LD_INT 3
13236: EQUAL
13237: IFFALSE 13248
// begin YouLost ( 5 ) ;
13239: LD_STRING 5
13241: PPUSH
13242: CALL_OW 104
// exit ;
13246: GO 13260
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
13248: LD_EXP 45
13252: PPUSH
13253: LD_STRING DWarn-Pow-1
13255: PPUSH
13256: CALL_OW 94
// end ; end_of_file
13260: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
13261: LD_EXP 8
13265: IFFALSE 14859
13267: GO 13269
13269: DISABLE
13270: LD_INT 0
13272: PPUSH
13273: PPUSH
13274: PPUSH
13275: PPUSH
13276: PPUSH
13277: PPUSH
13278: PPUSH
13279: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
13280: LD_EXP 43
13284: PUSH
13285: LD_EXP 44
13289: ADD
13290: PUSH
13291: LD_EXP 6
13295: ADD
13296: PPUSH
13297: LD_INT 250
13299: PPUSH
13300: LD_INT 120
13302: PPUSH
13303: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff Bierezov ;
13307: LD_ADDR_VAR 0 2
13311: PUSH
13312: LD_EXP 6
13316: PPUSH
13317: LD_INT 25
13319: PUSH
13320: LD_INT 2
13322: PUSH
13323: EMPTY
13324: LIST
13325: LIST
13326: PPUSH
13327: CALL_OW 72
13331: PUSH
13332: LD_EXP 44
13336: DIFF
13337: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) diff has_eng ;
13338: LD_ADDR_VAR 0 3
13342: PUSH
13343: LD_EXP 6
13347: PPUSH
13348: LD_INT 21
13350: PUSH
13351: LD_INT 1
13353: PUSH
13354: EMPTY
13355: LIST
13356: LIST
13357: PPUSH
13358: CALL_OW 72
13362: PUSH
13363: LD_VAR 0 2
13367: DIFF
13368: ST_TO_ADDR
// if not has_eng then
13369: LD_VAR 0 2
13373: NOT
13374: IFFALSE 13457
// begin uc_side := 4 ;
13376: LD_ADDR_OWVAR 20
13380: PUSH
13381: LD_INT 4
13383: ST_TO_ADDR
// uc_nation := 1 ;
13384: LD_ADDR_OWVAR 21
13388: PUSH
13389: LD_INT 1
13391: ST_TO_ADDR
// bc_type := b_depot ;
13392: LD_ADDR_OWVAR 42
13396: PUSH
13397: LD_INT 0
13399: ST_TO_ADDR
// bc_level := 2 ;
13400: LD_ADDR_OWVAR 43
13404: PUSH
13405: LD_INT 2
13407: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13408: LD_ADDR_VAR 0 4
13412: PUSH
13413: LD_INT 264
13415: PPUSH
13416: LD_INT 120
13418: PPUSH
13419: LD_INT 4
13421: PPUSH
13422: CALL_OW 47
13426: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13427: LD_INT 264
13429: PPUSH
13430: LD_INT 120
13432: PPUSH
13433: LD_INT 4
13435: PPUSH
13436: LD_INT 10
13438: NEG
13439: PPUSH
13440: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13444: LD_INT 264
13446: PPUSH
13447: LD_INT 120
13449: PPUSH
13450: LD_INT 4
13452: PPUSH
13453: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13457: LD_INT 35
13459: PPUSH
13460: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) or IsInArea ( IsInUnit ( Cornel ) , cornelBaseArea ) ;
13464: LD_EXP 43
13468: PPUSH
13469: LD_INT 10
13471: PPUSH
13472: CALL_OW 308
13476: PUSH
13477: LD_EXP 43
13481: PPUSH
13482: CALL_OW 310
13486: PPUSH
13487: LD_INT 10
13489: PPUSH
13490: CALL_OW 308
13494: OR
13495: IFFALSE 13457
// if has_eng and not dep then
13497: LD_VAR 0 2
13501: PUSH
13502: LD_VAR 0 4
13506: NOT
13507: AND
13508: IFFALSE 13658
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
13510: LD_VAR 0 2
13514: PPUSH
13515: LD_INT 0
13517: PPUSH
13518: LD_INT 264
13520: PPUSH
13521: LD_INT 120
13523: PPUSH
13524: LD_INT 4
13526: PPUSH
13527: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
13531: LD_INT 35
13533: PPUSH
13534: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
13538: LD_INT 22
13540: PUSH
13541: LD_INT 4
13543: PUSH
13544: EMPTY
13545: LIST
13546: LIST
13547: PUSH
13548: LD_INT 30
13550: PUSH
13551: LD_INT 0
13553: PUSH
13554: EMPTY
13555: LIST
13556: LIST
13557: PUSH
13558: EMPTY
13559: LIST
13560: LIST
13561: PPUSH
13562: CALL_OW 69
13566: IFFALSE 13531
// ComMoveXY ( filter , 264 , 120 ) ;
13568: LD_VAR 0 3
13572: PPUSH
13573: LD_INT 264
13575: PPUSH
13576: LD_INT 120
13578: PPUSH
13579: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
13583: LD_INT 35
13585: PPUSH
13586: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
13590: LD_INT 22
13592: PUSH
13593: LD_INT 4
13595: PUSH
13596: EMPTY
13597: LIST
13598: LIST
13599: PUSH
13600: LD_INT 30
13602: PUSH
13603: LD_INT 0
13605: PUSH
13606: EMPTY
13607: LIST
13608: LIST
13609: PUSH
13610: LD_INT 3
13612: PUSH
13613: LD_INT 57
13615: PUSH
13616: EMPTY
13617: LIST
13618: PUSH
13619: EMPTY
13620: LIST
13621: LIST
13622: PUSH
13623: EMPTY
13624: LIST
13625: LIST
13626: LIST
13627: PPUSH
13628: CALL_OW 69
13632: IFFALSE 13583
// ComMoveXY ( filter , 247 , 113 ) ;
13634: LD_VAR 0 3
13638: PPUSH
13639: LD_INT 247
13641: PPUSH
13642: LD_INT 113
13644: PPUSH
13645: CALL_OW 111
// Wait ( 0 0$2 ) ;
13649: LD_INT 70
13651: PPUSH
13652: CALL_OW 67
// end else
13656: GO 13670
// begin SetSide ( dep , 4 ) ;
13658: LD_VAR 0 4
13662: PPUSH
13663: LD_INT 4
13665: PPUSH
13666: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
13670: LD_ADDR_VAR 0 4
13674: PUSH
13675: LD_INT 22
13677: PUSH
13678: LD_INT 4
13680: PUSH
13681: EMPTY
13682: LIST
13683: LIST
13684: PUSH
13685: LD_INT 30
13687: PUSH
13688: LD_INT 0
13690: PUSH
13691: EMPTY
13692: LIST
13693: LIST
13694: PUSH
13695: EMPTY
13696: LIST
13697: LIST
13698: PPUSH
13699: CALL_OW 69
13703: PUSH
13704: LD_INT 1
13706: ARRAY
13707: ST_TO_ADDR
// for i = 1 to 2 do
13708: LD_ADDR_VAR 0 1
13712: PUSH
13713: DOUBLE
13714: LD_INT 1
13716: DEC
13717: ST_TO_ADDR
13718: LD_INT 2
13720: PUSH
13721: FOR_TO
13722: IFFALSE 13817
// begin ComEnterUnit ( filter [ 1 ] , dep ) ;
13724: LD_VAR 0 3
13728: PUSH
13729: LD_INT 1
13731: ARRAY
13732: PPUSH
13733: LD_VAR 0 4
13737: PPUSH
13738: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 2 ) ;
13742: LD_VAR 0 3
13746: PUSH
13747: LD_INT 1
13749: ARRAY
13750: PPUSH
13751: LD_INT 2
13753: PPUSH
13754: CALL_OW 183
// AddComExitBuilding ( filter [ 1 ] ) ;
13758: LD_VAR 0 3
13762: PUSH
13763: LD_INT 1
13765: ARRAY
13766: PPUSH
13767: CALL_OW 182
// repeat wait ( 0 0$1 ) ;
13771: LD_INT 35
13773: PPUSH
13774: CALL_OW 67
// until GetClass ( filter [ 1 ] ) = 2 ;
13778: LD_VAR 0 3
13782: PUSH
13783: LD_INT 1
13785: ARRAY
13786: PPUSH
13787: CALL_OW 257
13791: PUSH
13792: LD_INT 2
13794: EQUAL
13795: IFFALSE 13771
// filter := Delete ( filter , 1 ) ;
13797: LD_ADDR_VAR 0 3
13801: PUSH
13802: LD_VAR 0 3
13806: PPUSH
13807: LD_INT 1
13809: PPUSH
13810: CALL_OW 3
13814: ST_TO_ADDR
// end ;
13815: GO 13721
13817: POP
13818: POP
// if IsInUnit ( Cornel ) then
13819: LD_EXP 43
13823: PPUSH
13824: CALL_OW 310
13828: IFFALSE 13906
// begin cargo := IsInUnit ( Cornel ) ;
13830: LD_ADDR_VAR 0 7
13834: PUSH
13835: LD_EXP 43
13839: PPUSH
13840: CALL_OW 310
13844: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13845: LD_VAR 0 7
13849: PPUSH
13850: LD_INT 1
13852: PPUSH
13853: CALL_OW 289
13857: IFFALSE 13868
// ComUnload ( cargo ) ;
13859: LD_VAR 0 7
13863: PPUSH
13864: CALL_OW 159
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13868: LD_EXP 43
13872: PPUSH
13873: LD_INT 235
13875: PPUSH
13876: LD_INT 122
13878: PPUSH
13879: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13883: LD_EXP 43
13887: PPUSH
13888: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13892: LD_EXP 43
13896: PPUSH
13897: LD_VAR 0 4
13901: PPUSH
13902: CALL_OW 180
// end ; if Bierezov then
13906: LD_EXP 44
13910: IFFALSE 13958
// begin ComMoveXY ( Bierezov , 260 , 120 ) ;
13912: LD_EXP 44
13916: PPUSH
13917: LD_INT 260
13919: PPUSH
13920: LD_INT 120
13922: PPUSH
13923: CALL_OW 111
// if dep then
13927: LD_VAR 0 4
13931: IFFALSE 13949
// AddComEnterUnit ( Bierezov , dep ) else
13933: LD_EXP 44
13937: PPUSH
13938: LD_VAR 0 4
13942: PPUSH
13943: CALL_OW 180
13947: GO 13958
// AddComHold ( Bierezov ) ;
13949: LD_EXP 44
13953: PPUSH
13954: CALL_OW 200
// end ; has_eng := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) diff Bierezov ;
13958: LD_ADDR_VAR 0 2
13962: PUSH
13963: LD_INT 22
13965: PUSH
13966: LD_INT 4
13968: PUSH
13969: EMPTY
13970: LIST
13971: LIST
13972: PUSH
13973: LD_INT 25
13975: PUSH
13976: LD_INT 2
13978: PUSH
13979: EMPTY
13980: LIST
13981: LIST
13982: PUSH
13983: EMPTY
13984: LIST
13985: LIST
13986: PPUSH
13987: CALL_OW 69
13991: PUSH
13992: LD_EXP 44
13996: DIFF
13997: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13998: LD_INT 35
14000: PPUSH
14001: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
14005: LD_ADDR_VAR 0 6
14009: PUSH
14010: LD_INT 10
14012: PPUSH
14013: CALL_OW 435
14017: ST_TO_ADDR
// if crates then
14018: LD_VAR 0 6
14022: IFFALSE 14051
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
14024: LD_VAR 0 2
14028: PPUSH
14029: LD_VAR 0 6
14033: PUSH
14034: LD_INT 1
14036: ARRAY
14037: PPUSH
14038: LD_VAR 0 6
14042: PUSH
14043: LD_INT 2
14045: ARRAY
14046: PPUSH
14047: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
14051: LD_VAR 0 4
14055: PPUSH
14056: CALL_OW 274
14060: PPUSH
14061: LD_INT 1
14063: PPUSH
14064: CALL_OW 275
14068: PUSH
14069: LD_INT 40
14071: GREATEREQUAL
14072: IFFALSE 13998
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] , [ b_breastwork , 254 , 114 , 2 ] ] ;
14074: LD_ADDR_VAR 0 5
14078: PUSH
14079: LD_INT 4
14081: PUSH
14082: LD_INT 256
14084: PUSH
14085: LD_INT 111
14087: PUSH
14088: LD_INT 2
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: LIST
14095: LIST
14096: PUSH
14097: LD_INT 31
14099: PUSH
14100: LD_INT 243
14102: PUSH
14103: LD_INT 112
14105: PUSH
14106: LD_INT 2
14108: PUSH
14109: EMPTY
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: PUSH
14115: LD_INT 31
14117: PUSH
14118: LD_INT 254
14120: PUSH
14121: LD_INT 114
14123: PUSH
14124: LD_INT 2
14126: PUSH
14127: EMPTY
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: PUSH
14133: EMPTY
14134: LIST
14135: LIST
14136: LIST
14137: ST_TO_ADDR
// for i in blist do
14138: LD_ADDR_VAR 0 1
14142: PUSH
14143: LD_VAR 0 5
14147: PUSH
14148: FOR_IN
14149: IFFALSE 14198
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
14151: LD_VAR 0 2
14155: PPUSH
14156: LD_VAR 0 1
14160: PUSH
14161: LD_INT 1
14163: ARRAY
14164: PPUSH
14165: LD_VAR 0 1
14169: PUSH
14170: LD_INT 2
14172: ARRAY
14173: PPUSH
14174: LD_VAR 0 1
14178: PUSH
14179: LD_INT 3
14181: ARRAY
14182: PPUSH
14183: LD_VAR 0 1
14187: PUSH
14188: LD_INT 4
14190: ARRAY
14191: PPUSH
14192: CALL_OW 205
14196: GO 14148
14198: POP
14199: POP
// repeat wait ( 0 0$01 ) ;
14200: LD_INT 35
14202: PPUSH
14203: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
14207: LD_INT 22
14209: PUSH
14210: LD_INT 4
14212: PUSH
14213: EMPTY
14214: LIST
14215: LIST
14216: PUSH
14217: LD_INT 30
14219: PUSH
14220: LD_INT 4
14222: PUSH
14223: EMPTY
14224: LIST
14225: LIST
14226: PUSH
14227: LD_INT 3
14229: PUSH
14230: LD_INT 57
14232: PUSH
14233: EMPTY
14234: LIST
14235: PUSH
14236: EMPTY
14237: LIST
14238: LIST
14239: PUSH
14240: EMPTY
14241: LIST
14242: LIST
14243: LIST
14244: PPUSH
14245: CALL_OW 69
14249: IFFALSE 14200
// AddComEnterUnit ( filter , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14251: LD_VAR 0 3
14255: PPUSH
14256: LD_INT 22
14258: PUSH
14259: LD_INT 4
14261: PUSH
14262: EMPTY
14263: LIST
14264: LIST
14265: PUSH
14266: LD_INT 30
14268: PUSH
14269: LD_INT 4
14271: PUSH
14272: EMPTY
14273: LIST
14274: LIST
14275: PUSH
14276: EMPTY
14277: LIST
14278: LIST
14279: PPUSH
14280: CALL_OW 69
14284: PUSH
14285: LD_INT 1
14287: ARRAY
14288: PPUSH
14289: CALL_OW 180
// AddComChangeProfession ( filter , 1 ) ;
14293: LD_VAR 0 3
14297: PPUSH
14298: LD_INT 1
14300: PPUSH
14301: CALL_OW 183
// repeat wait ( 0 0$01 ) ;
14305: LD_INT 35
14307: PPUSH
14308: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) > 1 ;
14312: LD_INT 22
14314: PUSH
14315: LD_INT 4
14317: PUSH
14318: EMPTY
14319: LIST
14320: LIST
14321: PUSH
14322: LD_INT 30
14324: PUSH
14325: LD_INT 31
14327: PUSH
14328: EMPTY
14329: LIST
14330: LIST
14331: PUSH
14332: LD_INT 3
14334: PUSH
14335: LD_INT 57
14337: PUSH
14338: EMPTY
14339: LIST
14340: PUSH
14341: EMPTY
14342: LIST
14343: LIST
14344: PUSH
14345: EMPTY
14346: LIST
14347: LIST
14348: LIST
14349: PPUSH
14350: CALL_OW 69
14354: PUSH
14355: LD_INT 1
14357: GREATER
14358: IFFALSE 14305
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
14360: LD_ADDR_VAR 0 8
14364: PUSH
14365: LD_EXP 6
14369: PPUSH
14370: LD_INT 25
14372: PUSH
14373: LD_INT 1
14375: PUSH
14376: EMPTY
14377: LIST
14378: LIST
14379: PPUSH
14380: CALL_OW 72
14384: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) do
14385: LD_ADDR_VAR 0 1
14389: PUSH
14390: DOUBLE
14391: LD_INT 1
14393: DEC
14394: ST_TO_ADDR
14395: LD_INT 22
14397: PUSH
14398: LD_INT 4
14400: PUSH
14401: EMPTY
14402: LIST
14403: LIST
14404: PUSH
14405: LD_INT 30
14407: PUSH
14408: LD_INT 31
14410: PUSH
14411: EMPTY
14412: LIST
14413: LIST
14414: PUSH
14415: LD_INT 3
14417: PUSH
14418: LD_INT 57
14420: PUSH
14421: EMPTY
14422: LIST
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: PUSH
14428: EMPTY
14429: LIST
14430: LIST
14431: LIST
14432: PPUSH
14433: CALL_OW 69
14437: PUSH
14438: FOR_TO
14439: IFFALSE 14523
// begin if not sol [ i ] then
14441: LD_VAR 0 8
14445: PUSH
14446: LD_VAR 0 1
14450: ARRAY
14451: NOT
14452: IFFALSE 14456
// break ;
14454: GO 14523
// ComExitBuilding ( sol [ i ] ) ;
14456: LD_VAR 0 8
14460: PUSH
14461: LD_VAR 0 1
14465: ARRAY
14466: PPUSH
14467: CALL_OW 122
// AddComEnterUnit ( sol [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
14471: LD_VAR 0 8
14475: PUSH
14476: LD_VAR 0 1
14480: ARRAY
14481: PPUSH
14482: LD_INT 22
14484: PUSH
14485: LD_INT 4
14487: PUSH
14488: EMPTY
14489: LIST
14490: LIST
14491: PUSH
14492: LD_INT 30
14494: PUSH
14495: LD_INT 31
14497: PUSH
14498: EMPTY
14499: LIST
14500: LIST
14501: PUSH
14502: EMPTY
14503: LIST
14504: LIST
14505: PPUSH
14506: CALL_OW 69
14510: PUSH
14511: LD_VAR 0 1
14515: ARRAY
14516: PPUSH
14517: CALL_OW 180
// end ;
14521: GO 14438
14523: POP
14524: POP
// if sol > 2 then
14525: LD_VAR 0 8
14529: PUSH
14530: LD_INT 2
14532: GREATER
14533: IFFALSE 14650
// begin ComExitBuilding ( sol [ 3 ] ) ;
14535: LD_VAR 0 8
14539: PUSH
14540: LD_INT 3
14542: ARRAY
14543: PPUSH
14544: CALL_OW 122
// AddComMoveXY ( sol [ 3 ] , 246 , 94 ) ;
14548: LD_VAR 0 8
14552: PUSH
14553: LD_INT 3
14555: ARRAY
14556: PPUSH
14557: LD_INT 246
14559: PPUSH
14560: LD_INT 94
14562: PPUSH
14563: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$5 ) ;
14567: LD_VAR 0 8
14571: PUSH
14572: LD_INT 3
14574: ARRAY
14575: PPUSH
14576: LD_INT 175
14578: PPUSH
14579: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 224 , 90 ) ;
14583: LD_VAR 0 8
14587: PUSH
14588: LD_INT 3
14590: ARRAY
14591: PPUSH
14592: LD_INT 224
14594: PPUSH
14595: LD_INT 90
14597: PPUSH
14598: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$7 ) ;
14602: LD_VAR 0 8
14606: PUSH
14607: LD_INT 3
14609: ARRAY
14610: PPUSH
14611: LD_INT 245
14613: PPUSH
14614: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 223 , 110 ) ;
14618: LD_VAR 0 8
14622: PUSH
14623: LD_INT 3
14625: ARRAY
14626: PPUSH
14627: LD_INT 223
14629: PPUSH
14630: LD_INT 110
14632: PPUSH
14633: CALL_OW 171
// AddComHold ( sol [ 3 ] ) ;
14637: LD_VAR 0 8
14641: PUSH
14642: LD_INT 3
14644: ARRAY
14645: PPUSH
14646: CALL_OW 200
// end ; ComEnterUnit ( has_eng , dep ) ;
14650: LD_VAR 0 2
14654: PPUSH
14655: LD_VAR 0 4
14659: PPUSH
14660: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
14664: LD_INT 35
14666: PPUSH
14667: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14671: LD_ADDR_VAR 0 3
14675: PUSH
14676: LD_INT 22
14678: PUSH
14679: LD_INT 4
14681: PUSH
14682: EMPTY
14683: LIST
14684: LIST
14685: PUSH
14686: LD_INT 21
14688: PUSH
14689: LD_INT 3
14691: PUSH
14692: EMPTY
14693: LIST
14694: LIST
14695: PUSH
14696: LD_INT 3
14698: PUSH
14699: LD_INT 24
14701: PUSH
14702: LD_INT 1000
14704: PUSH
14705: EMPTY
14706: LIST
14707: LIST
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PUSH
14713: EMPTY
14714: LIST
14715: LIST
14716: LIST
14717: PPUSH
14718: CALL_OW 69
14722: ST_TO_ADDR
// if filter and has_eng then
14723: LD_VAR 0 3
14727: PUSH
14728: LD_VAR 0 2
14732: AND
14733: IFFALSE 14799
// begin for i in has_eng do
14735: LD_ADDR_VAR 0 1
14739: PUSH
14740: LD_VAR 0 2
14744: PUSH
14745: FOR_IN
14746: IFFALSE 14795
// begin if IsInUnit ( i ) then
14748: LD_VAR 0 1
14752: PPUSH
14753: CALL_OW 310
14757: IFFALSE 14768
// ComExitBuilding ( i ) ;
14759: LD_VAR 0 1
14763: PPUSH
14764: CALL_OW 122
// Wait ( 3 ) ;
14768: LD_INT 3
14770: PPUSH
14771: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
14775: LD_VAR 0 1
14779: PPUSH
14780: LD_VAR 0 3
14784: PUSH
14785: LD_INT 1
14787: ARRAY
14788: PPUSH
14789: CALL_OW 130
// end ;
14793: GO 14745
14795: POP
14796: POP
// end else
14797: GO 14853
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
14799: LD_VAR 0 2
14803: PUSH
14804: LD_VAR 0 2
14808: PPUSH
14809: LD_INT 56
14811: PUSH
14812: EMPTY
14813: LIST
14814: PPUSH
14815: CALL_OW 72
14819: AND
14820: IFFALSE 14853
// for i in has_eng do
14822: LD_ADDR_VAR 0 1
14826: PUSH
14827: LD_VAR 0 2
14831: PUSH
14832: FOR_IN
14833: IFFALSE 14851
// ComEnterUnit ( i , dep ) ;
14835: LD_VAR 0 1
14839: PPUSH
14840: LD_VAR 0 4
14844: PPUSH
14845: CALL_OW 120
14849: GO 14832
14851: POP
14852: POP
// until cornel_prepared ;
14853: LD_EXP 11
14857: IFFALSE 14664
// end ;
14859: PPOPN 8
14861: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
14862: LD_EXP 11
14866: IFFALSE 15265
14868: GO 14870
14870: DISABLE
14871: LD_INT 0
14873: PPUSH
14874: PPUSH
14875: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
14876: LD_ADDR_VAR 0 2
14880: PUSH
14881: LD_INT 22
14883: PUSH
14884: LD_INT 4
14886: PUSH
14887: EMPTY
14888: LIST
14889: LIST
14890: PUSH
14891: LD_INT 30
14893: PUSH
14894: LD_INT 4
14896: PUSH
14897: EMPTY
14898: LIST
14899: LIST
14900: PUSH
14901: EMPTY
14902: LIST
14903: LIST
14904: PPUSH
14905: CALL_OW 69
14909: PUSH
14910: LD_INT 1
14912: ARRAY
14913: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
14914: LD_EXP 6
14918: PPUSH
14919: CALL_OW 122
// if Bierezov and IsInUnit ( Bierezov ) then
14923: LD_EXP 44
14927: PUSH
14928: LD_EXP 44
14932: PPUSH
14933: CALL_OW 310
14937: AND
14938: IFFALSE 14949
// ComExitBuilding ( Bierezov ) ;
14940: LD_EXP 44
14944: PPUSH
14945: CALL_OW 122
// Wait ( 0 0$03 ) ;
14949: LD_INT 105
14951: PPUSH
14952: CALL_OW 67
// for i in cornel_units do
14956: LD_ADDR_VAR 0 1
14960: PUSH
14961: LD_EXP 6
14965: PUSH
14966: FOR_IN
14967: IFFALSE 15043
// begin if GetClass ( i ) in [ 2 , 3 ] then
14969: LD_VAR 0 1
14973: PPUSH
14974: CALL_OW 257
14978: PUSH
14979: LD_INT 2
14981: PUSH
14982: LD_INT 3
14984: PUSH
14985: EMPTY
14986: LIST
14987: LIST
14988: IN
14989: IFFALSE 15026
// begin ComEnterUnit ( i , arm ) ;
14991: LD_VAR 0 1
14995: PPUSH
14996: LD_VAR 0 2
15000: PPUSH
15001: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
15005: LD_VAR 0 1
15009: PPUSH
15010: LD_INT 1
15012: PPUSH
15013: CALL_OW 183
// AddComExitBuilding ( i ) ;
15017: LD_VAR 0 1
15021: PPUSH
15022: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
15026: LD_VAR 0 1
15030: PPUSH
15031: LD_INT 257
15033: PPUSH
15034: LD_INT 121
15036: PPUSH
15037: CALL_OW 171
// end ;
15041: GO 14966
15043: POP
15044: POP
// Wait ( 1 1$00 ) ;
15045: LD_INT 2100
15047: PPUSH
15048: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
15052: LD_ADDR_VAR 0 3
15056: PUSH
15057: LD_EXP 43
15061: PUSH
15062: LD_EXP 44
15066: ADD
15067: PUSH
15068: LD_EXP 6
15072: ADD
15073: PUSH
15074: LD_EXP 6
15078: PPUSH
15079: LD_INT 21
15081: PUSH
15082: LD_INT 2
15084: PUSH
15085: EMPTY
15086: LIST
15087: LIST
15088: PPUSH
15089: CALL_OW 72
15093: DIFF
15094: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
15095: LD_VAR 0 3
15099: PPUSH
15100: LD_INT 248
15102: PPUSH
15103: LD_INT 85
15105: PPUSH
15106: CALL_OW 111
// AddComHold ( filter ) ;
15110: LD_VAR 0 3
15114: PPUSH
15115: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
15119: LD_INT 35
15121: PPUSH
15122: CALL_OW 67
// until cornel_attack ;
15126: LD_EXP 9
15130: IFFALSE 15119
// ComAgressiveMove ( filter , 209 , 63 ) ;
15132: LD_VAR 0 3
15136: PPUSH
15137: LD_INT 209
15139: PPUSH
15140: LD_INT 63
15142: PPUSH
15143: CALL_OW 114
// ComAgressiveMove ( Cornel , 208 , 62 ) ;
15147: LD_EXP 43
15151: PPUSH
15152: LD_INT 208
15154: PPUSH
15155: LD_INT 62
15157: PPUSH
15158: CALL_OW 114
// AddComHold ( Cornel ) ;
15162: LD_EXP 43
15166: PPUSH
15167: CALL_OW 200
// if Bierezov then
15171: LD_EXP 44
15175: IFFALSE 15265
// begin filter := filter diff Bierezov ;
15177: LD_ADDR_VAR 0 3
15181: PUSH
15182: LD_VAR 0 3
15186: PUSH
15187: LD_EXP 44
15191: DIFF
15192: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
15193: LD_EXP 44
15197: PPUSH
15198: LD_INT 6
15200: PPUSH
15201: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
15205: LD_EXP 44
15209: PPUSH
15210: LD_INT 235
15212: PPUSH
15213: LD_INT 60
15215: PPUSH
15216: CALL_OW 111
// AddComHold ( Bierezov ) ;
15220: LD_EXP 44
15224: PPUSH
15225: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
15229: LD_EXP 44
15233: PPUSH
15234: LD_INT 350
15236: PPUSH
15237: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
15241: LD_EXP 44
15245: PPUSH
15246: LD_INT 198
15248: PPUSH
15249: LD_INT 28
15251: PPUSH
15252: CALL_OW 171
// AddComHold ( Bierezov ) ;
15256: LD_EXP 44
15260: PPUSH
15261: CALL_OW 200
// end ; end ; end_of_file
15265: PPOPN 3
15267: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
15268: LD_EXP 52
15272: PUSH
15273: LD_EXP 30
15277: NOT
15278: AND
15279: PUSH
15280: LD_EXP 31
15284: NOT
15285: AND
15286: IFFALSE 15736
15288: GO 15290
15290: DISABLE
15291: LD_INT 0
15293: PPUSH
15294: PPUSH
15295: PPUSH
15296: PPUSH
// begin enable ;
15297: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15298: LD_ADDR_VAR 0 4
15302: PUSH
15303: LD_INT 81
15305: PUSH
15306: LD_INT 3
15308: PUSH
15309: EMPTY
15310: LIST
15311: LIST
15312: PPUSH
15313: CALL_OW 69
15317: ST_TO_ADDR
// for i = 1 to ru_patrol do
15318: LD_ADDR_VAR 0 2
15322: PUSH
15323: DOUBLE
15324: LD_INT 1
15326: DEC
15327: ST_TO_ADDR
15328: LD_EXP 52
15332: PUSH
15333: FOR_TO
15334: IFFALSE 15734
// begin un := ru_patrol [ i ] ;
15336: LD_ADDR_VAR 0 1
15340: PUSH
15341: LD_EXP 52
15345: PUSH
15346: LD_VAR 0 2
15350: ARRAY
15351: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15352: LD_VAR 0 1
15356: PPUSH
15357: LD_INT 13
15359: PPUSH
15360: CALL_OW 308
15364: IFFALSE 15469
// begin if not ru_alert then
15366: LD_EXP 59
15370: NOT
15371: IFFALSE 15381
// ru_alert := true ;
15373: LD_ADDR_EXP 59
15377: PUSH
15378: LD_INT 1
15380: ST_TO_ADDR
// if not See ( 1 , un ) then
15381: LD_INT 1
15383: PPUSH
15384: LD_VAR 0 1
15388: PPUSH
15389: CALL_OW 292
15393: NOT
15394: IFFALSE 15408
// SetLives ( un , 1000 ) ;
15396: LD_VAR 0 1
15400: PPUSH
15401: LD_INT 1000
15403: PPUSH
15404: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
15408: LD_ADDR_EXP 52
15412: PUSH
15413: LD_EXP 52
15417: PUSH
15418: LD_VAR 0 1
15422: DIFF
15423: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15424: LD_VAR 0 1
15428: PPUSH
15429: LD_INT 22
15431: PUSH
15432: LD_INT 3
15434: PUSH
15435: EMPTY
15436: LIST
15437: LIST
15438: PUSH
15439: LD_INT 30
15441: PUSH
15442: LD_INT 4
15444: PUSH
15445: EMPTY
15446: LIST
15447: LIST
15448: PUSH
15449: EMPTY
15450: LIST
15451: LIST
15452: PPUSH
15453: CALL_OW 69
15457: PPUSH
15458: CALL 1047 0 1
15462: PPUSH
15463: CALL_OW 120
// continue ;
15467: GO 15333
// end ; if IsOk ( un ) and not HasTask ( un ) then
15469: LD_VAR 0 1
15473: PPUSH
15474: CALL_OW 302
15478: PUSH
15479: LD_VAR 0 1
15483: PPUSH
15484: CALL_OW 314
15488: NOT
15489: AND
15490: IFFALSE 15583
// begin for j = 1 to ru_firepoints_south [ i ] do
15492: LD_ADDR_VAR 0 3
15496: PUSH
15497: DOUBLE
15498: LD_INT 1
15500: DEC
15501: ST_TO_ADDR
15502: LD_EXP 58
15506: PUSH
15507: LD_VAR 0 2
15511: ARRAY
15512: PUSH
15513: FOR_TO
15514: IFFALSE 15581
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
15516: LD_VAR 0 1
15520: PPUSH
15521: LD_EXP 58
15525: PUSH
15526: LD_VAR 0 2
15530: ARRAY
15531: PUSH
15532: LD_VAR 0 3
15536: ARRAY
15537: PUSH
15538: LD_INT 1
15540: ARRAY
15541: PPUSH
15542: LD_EXP 58
15546: PUSH
15547: LD_VAR 0 2
15551: ARRAY
15552: PUSH
15553: LD_VAR 0 3
15557: ARRAY
15558: PUSH
15559: LD_INT 2
15561: ARRAY
15562: PPUSH
15563: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
15567: LD_VAR 0 1
15571: PPUSH
15572: LD_INT 70
15574: PPUSH
15575: CALL_OW 202
// end ;
15579: GO 15513
15581: POP
15582: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15583: LD_VAR 0 1
15587: PPUSH
15588: CALL_OW 256
15592: PUSH
15593: LD_INT 700
15595: LESS
15596: PUSH
15597: LD_VAR 0 1
15601: PPUSH
15602: LD_INT 13
15604: PPUSH
15605: CALL_OW 308
15609: NOT
15610: AND
15611: IFFALSE 15663
// begin ComMoveToArea ( un , retreatArea ) ;
15613: LD_VAR 0 1
15617: PPUSH
15618: LD_INT 13
15620: PPUSH
15621: CALL_OW 113
// if not ru_alert_xy then
15625: LD_EXP 60
15629: NOT
15630: IFFALSE 15661
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
15632: LD_ADDR_EXP 60
15636: PUSH
15637: LD_VAR 0 1
15641: PPUSH
15642: CALL_OW 250
15646: PUSH
15647: LD_VAR 0 1
15651: PPUSH
15652: CALL_OW 251
15656: PUSH
15657: EMPTY
15658: LIST
15659: LIST
15660: ST_TO_ADDR
// end else
15661: GO 15732
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15663: LD_VAR 0 1
15667: PPUSH
15668: LD_VAR 0 4
15672: PPUSH
15673: LD_VAR 0 1
15677: PPUSH
15678: CALL_OW 74
15682: PPUSH
15683: CALL_OW 296
15687: PUSH
15688: LD_INT 9
15690: LESS
15691: PUSH
15692: LD_VAR 0 1
15696: PPUSH
15697: CALL_OW 256
15701: PUSH
15702: LD_INT 500
15704: GREATER
15705: AND
15706: IFFALSE 15732
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15708: LD_VAR 0 1
15712: PPUSH
15713: LD_VAR 0 4
15717: PPUSH
15718: LD_VAR 0 1
15722: PPUSH
15723: CALL_OW 74
15727: PPUSH
15728: CALL_OW 115
// end ;
15732: GO 15333
15734: POP
15735: POP
// end ;
15736: PPOPN 4
15738: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
15739: LD_EXP 59
15743: PUSH
15744: LD_EXP 60
15748: AND
15749: PUSH
15750: LD_EXP 30
15754: NOT
15755: AND
15756: PUSH
15757: LD_EXP 31
15761: NOT
15762: AND
15763: IFFALSE 15973
15765: GO 15767
15767: DISABLE
15768: LD_INT 0
15770: PPUSH
15771: PPUSH
// begin enable ;
15772: ENABLE
// if not ru_vehicles then
15773: LD_EXP 55
15777: NOT
15778: IFFALSE 15782
// exit ;
15780: GO 15973
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15782: LD_ADDR_VAR 0 2
15786: PUSH
15787: LD_INT 81
15789: PUSH
15790: LD_INT 3
15792: PUSH
15793: EMPTY
15794: LIST
15795: LIST
15796: PPUSH
15797: CALL_OW 69
15801: ST_TO_ADDR
// if ru_vehicles then
15802: LD_EXP 55
15806: IFFALSE 15973
// begin for i in ru_vehicles do
15808: LD_ADDR_VAR 0 1
15812: PUSH
15813: LD_EXP 55
15817: PUSH
15818: FOR_IN
15819: IFFALSE 15971
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
15821: LD_VAR 0 1
15825: PPUSH
15826: CALL_OW 302
15830: PUSH
15831: LD_VAR 0 1
15835: PPUSH
15836: LD_VAR 0 2
15840: PPUSH
15841: LD_VAR 0 1
15845: PPUSH
15846: CALL_OW 74
15850: PPUSH
15851: CALL_OW 296
15855: PUSH
15856: LD_INT 9
15858: LESS
15859: AND
15860: IFFALSE 15886
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15862: LD_VAR 0 1
15866: PPUSH
15867: LD_VAR 0 2
15871: PPUSH
15872: LD_VAR 0 1
15876: PPUSH
15877: CALL_OW 74
15881: PPUSH
15882: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
15886: LD_VAR 0 1
15890: PPUSH
15891: CALL_OW 314
15895: NOT
15896: PUSH
15897: LD_VAR 0 1
15901: PPUSH
15902: CALL_OW 302
15906: AND
15907: PUSH
15908: LD_VAR 0 1
15912: PPUSH
15913: LD_EXP 60
15917: PUSH
15918: LD_INT 1
15920: ARRAY
15921: PPUSH
15922: LD_EXP 60
15926: PUSH
15927: LD_INT 2
15929: ARRAY
15930: PPUSH
15931: CALL_OW 297
15935: PUSH
15936: LD_INT 10
15938: GREATER
15939: AND
15940: IFFALSE 15969
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
15942: LD_VAR 0 1
15946: PPUSH
15947: LD_EXP 60
15951: PUSH
15952: LD_INT 1
15954: ARRAY
15955: PPUSH
15956: LD_EXP 60
15960: PUSH
15961: LD_INT 2
15963: ARRAY
15964: PPUSH
15965: CALL_OW 114
// end ;
15969: GO 15818
15971: POP
15972: POP
// end ; end ;
15973: PPOPN 2
15975: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
15976: LD_EXP 60
15980: PUSH
15981: LD_EXP 59
15985: AND
15986: PUSH
15987: LD_INT 3
15989: PPUSH
15990: CALL_OW 463
15994: NOT
15995: AND
15996: PUSH
15997: LD_EXP 30
16001: NOT
16002: AND
16003: PUSH
16004: LD_EXP 31
16008: NOT
16009: AND
16010: IFFALSE 16105
16012: GO 16014
16014: DISABLE
16015: LD_INT 0
16017: PPUSH
// begin enable ;
16018: ENABLE
// ru_alert_xy := false ;
16019: LD_ADDR_EXP 60
16023: PUSH
16024: LD_INT 0
16026: ST_TO_ADDR
// ru_alert := false ;
16027: LD_ADDR_EXP 59
16031: PUSH
16032: LD_INT 0
16034: ST_TO_ADDR
// if ru_vehicles then
16035: LD_EXP 55
16039: IFFALSE 16105
// for i in ru_vehicles do
16041: LD_ADDR_VAR 0 1
16045: PUSH
16046: LD_EXP 55
16050: PUSH
16051: FOR_IN
16052: IFFALSE 16103
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
16054: LD_VAR 0 1
16058: PPUSH
16059: CALL_OW 302
16063: PUSH
16064: LD_VAR 0 1
16068: PPUSH
16069: LD_INT 89
16071: PPUSH
16072: LD_INT 36
16074: PPUSH
16075: CALL_OW 297
16079: PUSH
16080: LD_INT 10
16082: GREATER
16083: AND
16084: IFFALSE 16101
// ComMoveXY ( i , 89 , 36 ) ;
16086: LD_VAR 0 1
16090: PPUSH
16091: LD_INT 89
16093: PPUSH
16094: LD_INT 36
16096: PPUSH
16097: CALL_OW 111
16101: GO 16051
16103: POP
16104: POP
// end ;
16105: PPOPN 1
16107: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
16108: LD_EXP 54
16112: PUSH
16113: LD_EXP 30
16117: NOT
16118: AND
16119: PUSH
16120: LD_EXP 31
16124: NOT
16125: AND
16126: IFFALSE 16410
16128: GO 16130
16130: DISABLE
16131: LD_INT 0
16133: PPUSH
16134: PPUSH
16135: PPUSH
// begin enable ;
16136: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16137: LD_ADDR_VAR 0 3
16141: PUSH
16142: LD_INT 81
16144: PUSH
16145: LD_INT 3
16147: PUSH
16148: EMPTY
16149: LIST
16150: LIST
16151: PPUSH
16152: CALL_OW 69
16156: ST_TO_ADDR
// for i = 1 to ru_forest do
16157: LD_ADDR_VAR 0 1
16161: PUSH
16162: DOUBLE
16163: LD_INT 1
16165: DEC
16166: ST_TO_ADDR
16167: LD_EXP 54
16171: PUSH
16172: FOR_TO
16173: IFFALSE 16408
// begin un := ru_forest [ i ] ;
16175: LD_ADDR_VAR 0 2
16179: PUSH
16180: LD_EXP 54
16184: PUSH
16185: LD_VAR 0 1
16189: ARRAY
16190: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
16191: LD_VAR 0 2
16195: PPUSH
16196: LD_INT 13
16198: PPUSH
16199: CALL_OW 308
16203: IFFALSE 16293
// begin if not See ( 1 , un ) then
16205: LD_INT 1
16207: PPUSH
16208: LD_VAR 0 2
16212: PPUSH
16213: CALL_OW 292
16217: NOT
16218: IFFALSE 16232
// SetLives ( un , 1000 ) ;
16220: LD_VAR 0 2
16224: PPUSH
16225: LD_INT 1000
16227: PPUSH
16228: CALL_OW 234
// ru_forest := ru_forest diff un ;
16232: LD_ADDR_EXP 54
16236: PUSH
16237: LD_EXP 54
16241: PUSH
16242: LD_VAR 0 2
16246: DIFF
16247: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
16248: LD_VAR 0 2
16252: PPUSH
16253: LD_INT 22
16255: PUSH
16256: LD_INT 3
16258: PUSH
16259: EMPTY
16260: LIST
16261: LIST
16262: PUSH
16263: LD_INT 30
16265: PUSH
16266: LD_INT 4
16268: PUSH
16269: EMPTY
16270: LIST
16271: LIST
16272: PUSH
16273: EMPTY
16274: LIST
16275: LIST
16276: PPUSH
16277: CALL_OW 69
16281: PPUSH
16282: CALL 1047 0 1
16286: PPUSH
16287: CALL_OW 120
// continue ;
16291: GO 16172
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
16293: LD_VAR 0 2
16297: PPUSH
16298: CALL_OW 256
16302: PUSH
16303: LD_INT 700
16305: LESS
16306: PUSH
16307: LD_VAR 0 2
16311: PPUSH
16312: LD_INT 13
16314: PPUSH
16315: CALL_OW 308
16319: NOT
16320: AND
16321: IFFALSE 16337
// ComMoveToArea ( un , retreatArea ) else
16323: LD_VAR 0 2
16327: PPUSH
16328: LD_INT 13
16330: PPUSH
16331: CALL_OW 113
16335: GO 16406
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
16337: LD_VAR 0 2
16341: PPUSH
16342: LD_VAR 0 3
16346: PPUSH
16347: LD_VAR 0 2
16351: PPUSH
16352: CALL_OW 74
16356: PPUSH
16357: CALL_OW 296
16361: PUSH
16362: LD_INT 9
16364: LESS
16365: PUSH
16366: LD_VAR 0 2
16370: PPUSH
16371: CALL_OW 256
16375: PUSH
16376: LD_INT 500
16378: GREATER
16379: AND
16380: IFFALSE 16406
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
16382: LD_VAR 0 2
16386: PPUSH
16387: LD_VAR 0 3
16391: PPUSH
16392: LD_VAR 0 2
16396: PPUSH
16397: CALL_OW 74
16401: PPUSH
16402: CALL_OW 115
// end ;
16406: GO 16172
16408: POP
16409: POP
// end ;
16410: PPOPN 3
16412: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
16413: LD_EXP 31
16417: NOT
16418: IFFALSE 16539
16420: GO 16422
16422: DISABLE
16423: LD_INT 0
16425: PPUSH
16426: PPUSH
// begin enable ;
16427: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
16428: LD_ADDR_VAR 0 2
16432: PUSH
16433: LD_INT 22
16435: PUSH
16436: LD_INT 3
16438: PUSH
16439: EMPTY
16440: LIST
16441: LIST
16442: PUSH
16443: LD_INT 21
16445: PUSH
16446: LD_INT 3
16448: PUSH
16449: EMPTY
16450: LIST
16451: LIST
16452: PUSH
16453: EMPTY
16454: LIST
16455: LIST
16456: PPUSH
16457: CALL_OW 69
16461: ST_TO_ADDR
// if filter then
16462: LD_VAR 0 2
16466: IFFALSE 16539
// for i in filter do
16468: LD_ADDR_VAR 0 1
16472: PUSH
16473: LD_VAR 0 2
16477: PUSH
16478: FOR_IN
16479: IFFALSE 16537
// if GetLives ( i ) < 990 then
16481: LD_VAR 0 1
16485: PPUSH
16486: CALL_OW 256
16490: PUSH
16491: LD_INT 990
16493: LESS
16494: IFFALSE 16535
// begin ru_alert := true ;
16496: LD_ADDR_EXP 59
16500: PUSH
16501: LD_INT 1
16503: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
16504: LD_ADDR_EXP 60
16508: PUSH
16509: LD_VAR 0 1
16513: PPUSH
16514: CALL_OW 250
16518: PUSH
16519: LD_VAR 0 1
16523: PPUSH
16524: CALL_OW 251
16528: PUSH
16529: EMPTY
16530: LIST
16531: LIST
16532: ST_TO_ADDR
// break ;
16533: GO 16537
// end ;
16535: GO 16478
16537: POP
16538: POP
// end ;
16539: PPOPN 2
16541: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
16542: LD_EXP 30
16546: IFFALSE 16695
16548: GO 16550
16550: DISABLE
16551: LD_INT 0
16553: PPUSH
16554: PPUSH
16555: PPUSH
16556: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
16557: LD_ADDR_VAR 0 4
16561: PUSH
16562: LD_EXP 55
16566: PUSH
16567: LD_EXP 54
16571: ADD
16572: PUSH
16573: LD_EXP 52
16577: ADD
16578: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
16579: LD_ADDR_VAR 0 3
16583: PUSH
16584: LD_INT 3
16586: PPUSH
16587: LD_INT 81
16589: PUSH
16590: LD_INT 3
16592: PUSH
16593: EMPTY
16594: LIST
16595: LIST
16596: PPUSH
16597: CALL_OW 70
16601: ST_TO_ADDR
// if filter and enemy then
16602: LD_VAR 0 4
16606: PUSH
16607: LD_VAR 0 3
16611: AND
16612: IFFALSE 16695
// repeat wait ( 0 0$01 ) ;
16614: LD_INT 35
16616: PPUSH
16617: CALL_OW 67
// for i in filter do
16621: LD_ADDR_VAR 0 1
16625: PUSH
16626: LD_VAR 0 4
16630: PUSH
16631: FOR_IN
16632: IFFALSE 16660
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16634: LD_VAR 0 1
16638: PPUSH
16639: LD_VAR 0 3
16643: PPUSH
16644: LD_VAR 0 1
16648: PPUSH
16649: CALL_OW 74
16653: PPUSH
16654: CALL_OW 115
// end ;
16658: GO 16631
16660: POP
16661: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
16662: LD_INT 3
16664: PPUSH
16665: LD_INT 81
16667: PUSH
16668: LD_INT 3
16670: PUSH
16671: EMPTY
16672: LIST
16673: LIST
16674: PPUSH
16675: CALL_OW 70
16679: PUSH
16680: LD_INT 0
16682: EQUAL
16683: PUSH
16684: LD_VAR 0 4
16688: PUSH
16689: LD_INT 0
16691: EQUAL
16692: OR
16693: IFFALSE 16614
// end ;
16695: PPOPN 4
16697: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) do var i ;
16698: LD_EXP 25
16702: PUSH
16703: LD_INT 22
16705: PUSH
16706: LD_INT 4
16708: PUSH
16709: EMPTY
16710: LIST
16711: LIST
16712: PUSH
16713: LD_INT 30
16715: PUSH
16716: LD_INT 4
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: PUSH
16723: LD_INT 3
16725: PUSH
16726: LD_INT 57
16728: PUSH
16729: EMPTY
16730: LIST
16731: PUSH
16732: EMPTY
16733: LIST
16734: LIST
16735: PUSH
16736: EMPTY
16737: LIST
16738: LIST
16739: LIST
16740: PPUSH
16741: CALL_OW 69
16745: AND
16746: IFFALSE 16795
16748: GO 16750
16750: DISABLE
16751: LD_INT 0
16753: PPUSH
// begin if not ru_cornel_attack then
16754: LD_EXP 57
16758: NOT
16759: IFFALSE 16763
// exit ;
16761: GO 16795
// for i in ru_cornel_attack do
16763: LD_ADDR_VAR 0 1
16767: PUSH
16768: LD_EXP 57
16772: PUSH
16773: FOR_IN
16774: IFFALSE 16793
// ComAgressiveMove ( i , 258 , 119 ) ;
16776: LD_VAR 0 1
16780: PPUSH
16781: LD_INT 258
16783: PPUSH
16784: LD_INT 119
16786: PPUSH
16787: CALL_OW 114
16791: GO 16773
16793: POP
16794: POP
// end ; end_of_file
16795: PPOPN 1
16797: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
16798: LD_EXP 5
16802: PUSH
16803: LD_EXP 9
16807: NOT
16808: AND
16809: PUSH
16810: LD_EXP 19
16814: AND
16815: IFFALSE 16927
16817: GO 16819
16819: DISABLE
16820: LD_INT 0
16822: PPUSH
// begin enable ;
16823: ENABLE
// crates_counter := crates_counter - 50 ;
16824: LD_ADDR_EXP 19
16828: PUSH
16829: LD_EXP 19
16833: PUSH
16834: LD_INT 50
16836: MINUS
16837: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
16838: LD_INT 8
16840: PPUSH
16841: LD_INT 2
16843: PPUSH
16844: LD_INT 5
16846: PPUSH
16847: CALL_OW 12
16851: PPUSH
16852: LD_INT 1
16854: PPUSH
16855: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
16859: LD_INT 1785
16861: PPUSH
16862: LD_INT 2345
16864: PPUSH
16865: CALL_OW 12
16869: PPUSH
16870: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
16874: LD_ADDR_VAR 0 1
16878: PUSH
16879: LD_INT 1
16881: PPUSH
16882: LD_OWVAR 67
16886: PUSH
16887: LD_INT 2
16889: PLUS
16890: PPUSH
16891: CALL_OW 12
16895: ST_TO_ADDR
// if r < 3 then
16896: LD_VAR 0 1
16900: PUSH
16901: LD_INT 3
16903: LESS
16904: IFFALSE 16927
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
16906: LD_INT 4
16908: PPUSH
16909: LD_INT 1
16911: PPUSH
16912: LD_INT 5
16914: PPUSH
16915: CALL_OW 12
16919: PPUSH
16920: LD_INT 1
16922: PPUSH
16923: CALL_OW 55
// end ;
16927: PPOPN 1
16929: END
// every 0 0$01 trigger cornel_active do
16930: LD_EXP 8
16934: IFFALSE 17023
16936: GO 16938
16938: DISABLE
// begin Wait ( 0 0$03 ) ;
16939: LD_INT 105
16941: PPUSH
16942: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16946: LD_INT 2
16948: PPUSH
16949: LD_INT 5
16951: PPUSH
16952: CALL_OW 12
16956: PPUSH
16957: LD_INT 10
16959: PPUSH
16960: LD_INT 1
16962: PPUSH
16963: CALL_OW 55
// Wait ( 0 0$13 ) ;
16967: LD_INT 455
16969: PPUSH
16970: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16974: LD_INT 2
16976: PPUSH
16977: LD_INT 5
16979: PPUSH
16980: CALL_OW 12
16984: PPUSH
16985: LD_INT 10
16987: PPUSH
16988: LD_INT 1
16990: PPUSH
16991: CALL_OW 55
// Wait ( 0 0$16 ) ;
16995: LD_INT 560
16997: PPUSH
16998: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17002: LD_INT 2
17004: PPUSH
17005: LD_INT 5
17007: PPUSH
17008: CALL_OW 12
17012: PPUSH
17013: LD_INT 10
17015: PPUSH
17016: LD_INT 1
17018: PPUSH
17019: CALL_OW 55
// end ; end_of_file
17023: END
// every 0 0$01 trigger cornel_prepared do
17024: LD_EXP 11
17028: IFFALSE 17087
17030: GO 17032
17032: DISABLE
// begin enable ;
17033: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
17034: LD_ADDR_OWVAR 47
17038: PUSH
17039: LD_STRING #Am03-1
17041: PUSH
17042: LD_EXP 10
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
17051: LD_ADDR_EXP 10
17055: PUSH
17056: LD_EXP 10
17060: PPUSH
17061: LD_STRING -
17063: PPUSH
17064: CALL 1117 0 2
17068: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
17069: LD_EXP 10
17073: PUSH
17074: LD_INT 0
17076: EQUAL
17077: IFFALSE 17087
// begin Display_Strings := [ ] ;
17079: LD_ADDR_OWVAR 47
17083: PUSH
17084: EMPTY
17085: ST_TO_ADDR
// disable ;
17086: DISABLE
// end ; end ;
17087: END
// every 0 0$01 trigger debug and debug_strings do
17088: LD_EXP 1
17092: PUSH
17093: LD_OWVAR 48
17097: AND
17098: IFFALSE 17114
17100: GO 17102
17102: DISABLE
// begin enable ;
17103: ENABLE
// Display_Strings := debug_strings ;
17104: LD_ADDR_OWVAR 47
17108: PUSH
17109: LD_OWVAR 48
17113: ST_TO_ADDR
// end ; end_of_file
17114: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
17115: LD_VAR 0 1
17119: PPUSH
17120: CALL_OW 255
17124: PUSH
17125: LD_INT 1
17127: EQUAL
17128: PUSH
17129: LD_EXP 13
17133: NOT
17134: AND
17135: IFFALSE 17145
// solar_builded := true ;
17137: LD_ADDR_EXP 13
17141: PUSH
17142: LD_INT 1
17144: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
17145: LD_VAR 0 1
17149: PPUSH
17150: CALL_OW 255
17154: PUSH
17155: LD_INT 1
17157: EQUAL
17158: PUSH
17159: LD_EXP 28
17163: AND
17164: IFFALSE 17197
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
17166: LD_ADDR_EXP 28
17170: PUSH
17171: LD_EXP 28
17175: PUSH
17176: LD_INT 1750
17178: PUSH
17179: LD_INT 1400
17181: PUSH
17182: LD_INT 1225
17184: PUSH
17185: EMPTY
17186: LIST
17187: LIST
17188: LIST
17189: PUSH
17190: LD_OWVAR 67
17194: ARRAY
17195: PLUS
17196: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
17197: LD_VAR 0 1
17201: PPUSH
17202: CALL_OW 255
17206: PUSH
17207: LD_INT 3
17209: EQUAL
17210: IFFALSE 17228
// ru_vehicles := ru_vehicles ^ veh ;
17212: LD_ADDR_EXP 55
17216: PUSH
17217: LD_EXP 55
17221: PUSH
17222: LD_VAR 0 1
17226: ADD
17227: ST_TO_ADDR
// end ;
17228: PPOPN 2
17230: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
17231: LD_VAR 0 1
17235: PUSH
17236: LD_EXP 52
17240: IN
17241: IFFALSE 17259
// ru_patrol := ru_patrol diff un ;
17243: LD_ADDR_EXP 52
17247: PUSH
17248: LD_EXP 52
17252: PUSH
17253: LD_VAR 0 1
17257: DIFF
17258: ST_TO_ADDR
// if un in ru_forest then
17259: LD_VAR 0 1
17263: PUSH
17264: LD_EXP 54
17268: IN
17269: IFFALSE 17287
// ru_forest := ru_forest diff un ;
17271: LD_ADDR_EXP 54
17275: PUSH
17276: LD_EXP 54
17280: PUSH
17281: LD_VAR 0 1
17285: DIFF
17286: ST_TO_ADDR
// if un in ru_vehicles then
17287: LD_VAR 0 1
17291: PUSH
17292: LD_EXP 55
17296: IN
17297: IFFALSE 17372
// begin ru_vehicles := ru_vehicles diff un ;
17299: LD_ADDR_EXP 55
17303: PUSH
17304: LD_EXP 55
17308: PUSH
17309: LD_VAR 0 1
17313: DIFF
17314: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
17315: LD_ADDR_EXP 56
17319: PUSH
17320: LD_EXP 56
17324: PUSH
17325: LD_VAR 0 1
17329: PPUSH
17330: CALL_OW 265
17334: PUSH
17335: LD_VAR 0 1
17339: PPUSH
17340: CALL_OW 262
17344: PUSH
17345: LD_VAR 0 1
17349: PPUSH
17350: CALL_OW 263
17354: PUSH
17355: LD_VAR 0 1
17359: PPUSH
17360: CALL_OW 264
17364: PUSH
17365: EMPTY
17366: LIST
17367: LIST
17368: LIST
17369: LIST
17370: ADD
17371: ST_TO_ADDR
// end ; if un = JMM then
17372: LD_VAR 0 1
17376: PUSH
17377: LD_EXP 36
17381: EQUAL
17382: IFFALSE 17391
// YouLost ( 0 ) ;
17384: LD_STRING 0
17386: PPUSH
17387: CALL_OW 104
// if un = us_dep_west then
17391: LD_VAR 0 1
17395: PUSH
17396: LD_INT 1
17398: EQUAL
17399: IFFALSE 17408
// YouLost ( 2 ) ;
17401: LD_STRING 2
17403: PPUSH
17404: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
17408: LD_VAR 0 1
17412: PPUSH
17413: CALL_OW 255
17417: PUSH
17418: LD_INT 8
17420: EQUAL
17421: PUSH
17422: LD_EXP 5
17426: NOT
17427: AND
17428: IFFALSE 17437
// YouLost ( 4 ) ;
17430: LD_STRING 4
17432: PPUSH
17433: CALL_OW 104
// if un in jmm_units then
17437: LD_VAR 0 1
17441: PUSH
17442: LD_EXP 4
17446: IN
17447: IFFALSE 17463
// lose_counter := lose_counter + 1 ;
17449: LD_ADDR_EXP 33
17453: PUSH
17454: LD_EXP 33
17458: PUSH
17459: LD_INT 1
17461: PLUS
17462: ST_TO_ADDR
// end ;
17463: PPOPN 1
17465: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
17466: LD_INT 0
17468: PPUSH
17469: PPUSH
// begin if GetSide ( driver ) = 3 then
17470: LD_VAR 0 1
17474: PPUSH
17475: CALL_OW 255
17479: PUSH
17480: LD_INT 3
17482: EQUAL
17483: IFFALSE 17561
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
17485: LD_ADDR_VAR 0 6
17489: PUSH
17490: LD_INT 22
17492: PUSH
17493: LD_INT 3
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: PUSH
17500: LD_INT 30
17502: PUSH
17503: LD_INT 3
17505: PUSH
17506: EMPTY
17507: LIST
17508: LIST
17509: PUSH
17510: EMPTY
17511: LIST
17512: LIST
17513: PPUSH
17514: CALL_OW 69
17518: PPUSH
17519: CALL 1047 0 1
17523: ST_TO_ADDR
// if place then
17524: LD_VAR 0 6
17528: IFFALSE 17546
// ComEnterUnit ( driver , place ) else
17530: LD_VAR 0 1
17534: PPUSH
17535: LD_VAR 0 6
17539: PPUSH
17540: CALL_OW 120
17544: GO 17561
// ComMoveXY ( driver , 70 , 22 ) ;
17546: LD_VAR 0 1
17550: PPUSH
17551: LD_INT 70
17553: PPUSH
17554: LD_INT 22
17556: PPUSH
17557: CALL_OW 111
// end ; end ;
17561: PPOPN 6
17563: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and ( s2 = 4 or ( s2 = 8 and not jmm_on_west ) ) then
17564: LD_VAR 0 1
17568: PUSH
17569: LD_INT 1
17571: EQUAL
17572: PUSH
17573: LD_VAR 0 2
17577: PUSH
17578: LD_INT 4
17580: EQUAL
17581: PUSH
17582: LD_VAR 0 2
17586: PUSH
17587: LD_INT 8
17589: EQUAL
17590: PUSH
17591: LD_EXP 5
17595: NOT
17596: AND
17597: OR
17598: AND
17599: IFFALSE 17608
// YouLost ( 5 ) ;
17601: LD_STRING 5
17603: PPUSH
17604: CALL_OW 104
// end ;
17608: PPOPN 2
17610: END
// every 0 0$01 trigger save_counter + ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
17611: LD_EXP 35
17615: PUSH
17616: LD_INT 22
17618: PUSH
17619: LD_INT 1
17621: PUSH
17622: EMPTY
17623: LIST
17624: LIST
17625: PUSH
17626: LD_INT 21
17628: PUSH
17629: LD_INT 1
17631: PUSH
17632: EMPTY
17633: LIST
17634: LIST
17635: PUSH
17636: EMPTY
17637: LIST
17638: LIST
17639: PPUSH
17640: CALL_OW 69
17644: PUSH
17645: LD_INT 22
17647: PUSH
17648: LD_INT 8
17650: PUSH
17651: EMPTY
17652: LIST
17653: LIST
17654: PUSH
17655: LD_INT 21
17657: PUSH
17658: LD_INT 1
17660: PUSH
17661: EMPTY
17662: LIST
17663: LIST
17664: PUSH
17665: EMPTY
17666: LIST
17667: LIST
17668: PPUSH
17669: CALL_OW 69
17673: ADD
17674: PLUS
17675: PUSH
17676: LD_INT 5
17678: LESS
17679: IFFALSE 17691
17681: GO 17683
17683: DISABLE
// YouLost ( 1 ) ;
17684: LD_STRING 1
17686: PPUSH
17687: CALL_OW 104
17691: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
17692: LD_INT 1
17694: PPUSH
17695: CALL_OW 255
17699: PUSH
17700: LD_INT 3
17702: EQUAL
17703: IFFALSE 17715
17705: GO 17707
17707: DISABLE
// YouLost ( 3 ) ;
17708: LD_STRING 3
17710: PPUSH
17711: CALL_OW 104
17715: END
