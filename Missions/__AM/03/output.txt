// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 363 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 451 0 0
// PrepareRussian ;
  22: CALL 2980 0 0
// PrepareAmerican ;
  26: CALL 1185 0 0
// PrepareCornell ;
  30: CALL 2209 0 0
// PrepareWesternBase ;
  34: CALL 2435 0 0
// Action ;
  38: CALL 5196 0 0
// end ;
  42: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , cornel_saved , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn , save_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  54: LD_ADDR_EXP 3
  58: PUSH
  59: LD_STRING 02_
  61: ST_TO_ADDR
// mission_prefix := 03_ ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_STRING 03_
  69: ST_TO_ADDR
// jmm_units := 0 ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// cornel_units := 0 ;
  78: LD_ADDR_EXP 6
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// bierezov_exist := false ;
  86: LD_ADDR_EXP 7
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// jmm_on_west := false ;
  94: LD_ADDR_EXP 5
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_active := false ;
 102: LD_ADDR_EXP 8
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_attack := false ;
 110: LD_ADDR_EXP 9
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// cornel_prepared := false ;
 118: LD_ADDR_EXP 11
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 126: LD_ADDR_EXP 10
 130: PUSH
 131: LD_INT 4200
 133: ST_TO_ADDR
// frank_can_return := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// solar_builded := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// frank_send_to_scout := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// jmm_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// bobby_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// cyrus_in_veh := false ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// lisa_in_veh := false ;
 182: LD_ADDR_EXP 18
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 190: LD_ADDR_EXP 28
 194: PUSH
 195: LD_INT 25200
 197: PUSH
 198: LD_INT 23100
 200: PUSH
 201: LD_INT 21000
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: PUSH
 209: LD_OWVAR 67
 213: ARRAY
 214: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 215: LD_ADDR_EXP 19
 219: PUSH
 220: LD_INT 600
 222: PUSH
 223: LD_INT 500
 225: PUSH
 226: LD_INT 400
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: PUSH
 234: LD_OWVAR 67
 238: ARRAY
 239: ST_TO_ADDR
// end_mission_allowed := false ;
 240: LD_ADDR_EXP 20
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// save_others := [ ] ;
 248: LD_ADDR_EXP 21
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// save_group := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// show_query := true ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// wait_for_them := false ;
 270: LD_ADDR_EXP 24
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// veh_on_meta := false ;
 278: LD_ADDR_EXP 27
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_spec_patrol := false ;
 286: LD_ADDR_EXP 29
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// prepare_siege := false ;
 294: LD_ADDR_EXP 30
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// send_attack_on_cornel := false ;
 302: LD_ADDR_EXP 31
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 310: LD_ADDR_EXP 25
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// game_end := false ;
 318: LD_ADDR_EXP 32
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// lose_counter := 0 ;
 326: LD_ADDR_EXP 33
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// powell_warn := 0 ;
 334: LD_ADDR_EXP 34
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// save_counter := 0 ;
 342: LD_ADDR_EXP 35
 346: PUSH
 347: LD_INT 0
 349: ST_TO_ADDR
// cornel_saved := false ;
 350: LD_ADDR_EXP 26
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// end ;
 358: LD_VAR 0 1
 362: RET
// function SetDiplomacy ; begin
 363: LD_INT 0
 365: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 366: LD_INT 1
 368: PPUSH
 369: LD_INT 4
 371: PPUSH
 372: LD_INT 1
 374: PPUSH
 375: LD_INT 1
 377: PPUSH
 378: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 382: LD_INT 1
 384: PPUSH
 385: LD_INT 8
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 398: LD_INT 3
 400: PPUSH
 401: LD_INT 6
 403: PPUSH
 404: LD_INT 1
 406: PPUSH
 407: LD_INT 1
 409: PPUSH
 410: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 414: LD_INT 4
 416: PPUSH
 417: LD_INT 6
 419: PPUSH
 420: LD_INT 0
 422: PPUSH
 423: LD_INT 1
 425: PPUSH
 426: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 430: LD_INT 3
 432: PPUSH
 433: LD_INT 8
 435: PPUSH
 436: LD_INT 0
 438: PPUSH
 439: LD_INT 1
 441: PPUSH
 442: CALL_OW 80
// end ;
 446: LD_VAR 0 1
 450: RET
// export function DebugMode ; var i ; begin
 451: LD_INT 0
 453: PPUSH
 454: PPUSH
// FogOff ( 1 ) ;
 455: LD_INT 1
 457: PPUSH
 458: CALL_OW 344
// debug_strings := [ ] ;
 462: LD_ADDR_OWVAR 48
 466: PUSH
 467: EMPTY
 468: ST_TO_ADDR
// end ; end_of_file
 469: LD_VAR 0 1
 473: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 474: LD_INT 0
 476: PPUSH
 477: PPUSH
// if exist_mode then
 478: LD_VAR 0 2
 482: IFFALSE 507
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 484: LD_ADDR_VAR 0 4
 488: PUSH
 489: LD_EXP 3
 493: PUSH
 494: LD_VAR 0 1
 498: STR
 499: PPUSH
 500: CALL_OW 34
 504: ST_TO_ADDR
 505: GO 522
// unit := NewCharacter ( ident ) ;
 507: LD_ADDR_VAR 0 4
 511: PUSH
 512: LD_VAR 0 1
 516: PPUSH
 517: CALL_OW 25
 521: ST_TO_ADDR
// result := unit ;
 522: LD_ADDR_VAR 0 3
 526: PUSH
 527: LD_VAR 0 4
 531: ST_TO_ADDR
// end ;
 532: LD_VAR 0 3
 536: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 537: LD_INT 0
 539: PPUSH
// uc_side := side ;
 540: LD_ADDR_OWVAR 20
 544: PUSH
 545: LD_VAR 0 1
 549: ST_TO_ADDR
// uc_nation := nation ;
 550: LD_ADDR_OWVAR 21
 554: PUSH
 555: LD_VAR 0 2
 559: ST_TO_ADDR
// vc_chassis := chassis ;
 560: LD_ADDR_OWVAR 37
 564: PUSH
 565: LD_VAR 0 3
 569: ST_TO_ADDR
// vc_engine := engine ;
 570: LD_ADDR_OWVAR 39
 574: PUSH
 575: LD_VAR 0 4
 579: ST_TO_ADDR
// vc_control := control ;
 580: LD_ADDR_OWVAR 38
 584: PUSH
 585: LD_VAR 0 5
 589: ST_TO_ADDR
// vc_weapon := weapon ;
 590: LD_ADDR_OWVAR 40
 594: PUSH
 595: LD_VAR 0 6
 599: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 600: LD_ADDR_OWVAR 41
 604: PUSH
 605: LD_VAR 0 7
 609: ST_TO_ADDR
// result := CreateVehicle ;
 610: LD_ADDR_VAR 0 8
 614: PUSH
 615: CALL_OW 45
 619: ST_TO_ADDR
// end ;
 620: LD_VAR 0 8
 624: RET
// export function SayX ( units , ident ) ; var i ; begin
 625: LD_INT 0
 627: PPUSH
 628: PPUSH
// result := false ;
 629: LD_ADDR_VAR 0 3
 633: PUSH
 634: LD_INT 0
 636: ST_TO_ADDR
// if not units then
 637: LD_VAR 0 1
 641: NOT
 642: IFFALSE 646
// exit ;
 644: GO 700
// for i in units do
 646: LD_ADDR_VAR 0 4
 650: PUSH
 651: LD_VAR 0 1
 655: PUSH
 656: FOR_IN
 657: IFFALSE 698
// if IsOk ( i ) then
 659: LD_VAR 0 4
 663: PPUSH
 664: CALL_OW 302
 668: IFFALSE 696
// begin Say ( i , ident ) ;
 670: LD_VAR 0 4
 674: PPUSH
 675: LD_VAR 0 2
 679: PPUSH
 680: CALL_OW 88
// result := i ;
 684: LD_ADDR_VAR 0 3
 688: PUSH
 689: LD_VAR 0 4
 693: ST_TO_ADDR
// break ;
 694: GO 698
// end ;
 696: GO 656
 698: POP
 699: POP
// end ;
 700: LD_VAR 0 3
 704: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 705: LD_INT 0
 707: PPUSH
 708: PPUSH
 709: PPUSH
 710: PPUSH
// for i = 1 to count do
 711: LD_ADDR_VAR 0 8
 715: PUSH
 716: DOUBLE
 717: LD_INT 1
 719: DEC
 720: ST_TO_ADDR
 721: LD_VAR 0 6
 725: PUSH
 726: FOR_TO
 727: IFFALSE 808
// begin uc_side = side ;
 729: LD_ADDR_OWVAR 20
 733: PUSH
 734: LD_VAR 0 1
 738: ST_TO_ADDR
// uc_nation = nation ;
 739: LD_ADDR_OWVAR 21
 743: PUSH
 744: LD_VAR 0 2
 748: ST_TO_ADDR
// hc_gallery =  ;
 749: LD_ADDR_OWVAR 33
 753: PUSH
 754: LD_STRING 
 756: ST_TO_ADDR
// hc_name =  ;
 757: LD_ADDR_OWVAR 26
 761: PUSH
 762: LD_STRING 
 764: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 765: LD_INT 0
 767: PPUSH
 768: LD_VAR 0 5
 772: PPUSH
 773: LD_VAR 0 4
 777: PPUSH
 778: CALL_OW 380
// un = CreateHuman ;
 782: LD_ADDR_VAR 0 10
 786: PUSH
 787: CALL_OW 44
 791: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 792: LD_VAR 0 10
 796: PPUSH
 797: LD_VAR 0 3
 801: PPUSH
 802: CALL_OW 52
// end ;
 806: GO 726
 808: POP
 809: POP
// end ;
 810: LD_VAR 0 7
 814: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// uc_side := GetSide ( b ) ;
 820: LD_ADDR_OWVAR 20
 824: PUSH
 825: LD_VAR 0 2
 829: PPUSH
 830: CALL_OW 255
 834: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_VAR 0 2
 844: PPUSH
 845: CALL_OW 248
 849: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 850: LD_INT 0
 852: PPUSH
 853: LD_INT 1
 855: PPUSH
 856: LD_VAR 0 1
 860: PPUSH
 861: CALL_OW 380
// un = CreateHuman ;
 865: LD_ADDR_VAR 0 4
 869: PUSH
 870: CALL_OW 44
 874: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 875: LD_ADDR_VAR 0 5
 879: PUSH
 880: LD_VAR 0 2
 884: PPUSH
 885: CALL_OW 254
 889: PUSH
 890: LD_INT 3
 892: MINUS
 893: ST_TO_ADDR
// if dir < 0 then
 894: LD_VAR 0 5
 898: PUSH
 899: LD_INT 0
 901: LESS
 902: IFFALSE 918
// dir := 6 + dir ;
 904: LD_ADDR_VAR 0 5
 908: PUSH
 909: LD_INT 6
 911: PUSH
 912: LD_VAR 0 5
 916: PLUS
 917: ST_TO_ADDR
// SetDir ( un , dir ) ;
 918: LD_VAR 0 4
 922: PPUSH
 923: LD_VAR 0 5
 927: PPUSH
 928: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 932: LD_VAR 0 4
 936: PPUSH
 937: LD_VAR 0 2
 941: PPUSH
 942: CALL_OW 52
// end ;
 946: LD_VAR 0 3
 950: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 951: LD_INT 0
 953: PPUSH
 954: PPUSH
 955: PPUSH
// result := false ;
 956: LD_ADDR_VAR 0 2
 960: PUSH
 961: LD_INT 0
 963: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 964: LD_ADDR_VAR 0 3
 968: PUSH
 969: LD_INT 22
 971: PUSH
 972: LD_INT 1
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 34
 981: PUSH
 982: LD_INT 2
 984: PUSH
 985: EMPTY
 986: LIST
 987: LIST
 988: PUSH
 989: EMPTY
 990: LIST
 991: LIST
 992: PPUSH
 993: CALL_OW 69
 997: ST_TO_ADDR
// for i in filter do
 998: LD_ADDR_VAR 0 4
1002: PUSH
1003: LD_VAR 0 3
1007: PUSH
1008: FOR_IN
1009: IFFALSE 1040
// if IsDrivenBy ( i ) = unit then
1011: LD_VAR 0 4
1015: PPUSH
1016: CALL_OW 311
1020: PUSH
1021: LD_VAR 0 1
1025: EQUAL
1026: IFFALSE 1038
// begin result := true ;
1028: LD_ADDR_VAR 0 2
1032: PUSH
1033: LD_INT 1
1035: ST_TO_ADDR
// break ;
1036: GO 1040
// end ;
1038: GO 1008
1040: POP
1041: POP
// end ;
1042: LD_VAR 0 2
1046: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1047: LD_INT 0
1049: PPUSH
1050: PPUSH
// result := false ;
1051: LD_ADDR_VAR 0 2
1055: PUSH
1056: LD_INT 0
1058: ST_TO_ADDR
// if not blist then
1059: LD_VAR 0 1
1063: NOT
1064: IFFALSE 1068
// exit ;
1066: GO 1112
// for i in blist do
1068: LD_ADDR_VAR 0 3
1072: PUSH
1073: LD_VAR 0 1
1077: PUSH
1078: FOR_IN
1079: IFFALSE 1110
// if UnitsInside ( i ) < 6 then
1081: LD_VAR 0 3
1085: PPUSH
1086: CALL_OW 313
1090: PUSH
1091: LD_INT 6
1093: LESS
1094: IFFALSE 1108
// begin result := i ;
1096: LD_ADDR_VAR 0 2
1100: PUSH
1101: LD_VAR 0 3
1105: ST_TO_ADDR
// break ;
1106: GO 1110
// end ;
1108: GO 1078
1110: POP
1111: POP
// end ;
1112: LD_VAR 0 2
1116: RET
// export function Count ( timer , mode ) ; begin
1117: LD_INT 0
1119: PPUSH
// if not timer then
1120: LD_VAR 0 1
1124: NOT
1125: IFFALSE 1129
// exit ;
1127: GO 1180
// if mode in [ asc , up , + ] then
1129: LD_VAR 0 2
1133: PUSH
1134: LD_STRING asc
1136: PUSH
1137: LD_STRING up
1139: PUSH
1140: LD_STRING +
1142: PUSH
1143: EMPTY
1144: LIST
1145: LIST
1146: LIST
1147: IN
1148: IFFALSE 1166
// result := timer + 0 0$01 else
1150: LD_ADDR_VAR 0 3
1154: PUSH
1155: LD_VAR 0 1
1159: PUSH
1160: LD_INT 35
1162: PLUS
1163: ST_TO_ADDR
1164: GO 1180
// result := timer - 0 0$01 ;
1166: LD_ADDR_VAR 0 3
1170: PUSH
1171: LD_VAR 0 1
1175: PUSH
1176: LD_INT 35
1178: MINUS
1179: ST_TO_ADDR
// end ; end_of_file
1180: LD_VAR 0 3
1184: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1185: LD_INT 0
1187: PPUSH
1188: PPUSH
1189: PPUSH
1190: PPUSH
1191: PPUSH
1192: PPUSH
1193: PPUSH
1194: PPUSH
// uc_side := 4 ;
1195: LD_ADDR_OWVAR 20
1199: PUSH
1200: LD_INT 4
1202: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1203: LD_ADDR_EXP 45
1207: PUSH
1208: LD_STRING Powell
1210: PPUSH
1211: LD_INT 0
1213: PPUSH
1214: CALL 474 0 2
1218: ST_TO_ADDR
// uc_side := 1 ;
1219: LD_ADDR_OWVAR 20
1223: PUSH
1224: LD_INT 1
1226: ST_TO_ADDR
// uc_nation := 1 ;
1227: LD_ADDR_OWVAR 21
1231: PUSH
1232: LD_INT 1
1234: ST_TO_ADDR
// if debug then
1235: LD_EXP 1
1239: IFFALSE 1369
// begin for i = 1 to 4 do
1241: LD_ADDR_VAR 0 2
1245: PUSH
1246: DOUBLE
1247: LD_INT 1
1249: DEC
1250: ST_TO_ADDR
1251: LD_INT 4
1253: PUSH
1254: FOR_TO
1255: IFFALSE 1306
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1257: LD_INT 0
1259: PPUSH
1260: LD_INT 1
1262: PPUSH
1263: LD_INT 2
1265: PPUSH
1266: CALL_OW 12
1270: PPUSH
1271: LD_INT 3
1273: PPUSH
1274: CALL_OW 380
// un := CreateHuman ;
1278: LD_ADDR_VAR 0 3
1282: PUSH
1283: CALL_OW 44
1287: ST_TO_ADDR
// others := others ^ un ;
1288: LD_ADDR_VAR 0 5
1292: PUSH
1293: LD_VAR 0 5
1297: PUSH
1298: LD_VAR 0 3
1302: ADD
1303: ST_TO_ADDR
// end ;
1304: GO 1254
1306: POP
1307: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1308: LD_ADDR_VAR 0 6
1312: PUSH
1313: LD_INT 21
1315: PUSH
1316: LD_INT 1
1318: PUSH
1319: LD_INT 1
1321: PUSH
1322: LD_INT 51
1324: PUSH
1325: LD_INT 90
1327: PUSH
1328: LD_INT 504
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: LIST
1335: LIST
1336: LIST
1337: LIST
1338: PUSH
1339: LD_INT 21
1341: PUSH
1342: LD_INT 1
1344: PUSH
1345: LD_INT 1
1347: PUSH
1348: LD_INT 51
1350: PUSH
1351: LD_INT 80
1353: PUSH
1354: LD_INT 750
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: LIST
1361: LIST
1362: LIST
1363: LIST
1364: PUSH
1365: EMPTY
1366: LIST
1367: LIST
1368: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1369: LD_ADDR_EXP 36
1373: PUSH
1374: LD_STRING JMM
1376: PPUSH
1377: LD_EXP 1
1381: NOT
1382: PPUSH
1383: CALL 474 0 2
1387: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1388: LD_ADDR_EXP 37
1392: PUSH
1393: LD_STRING Bobby
1395: PPUSH
1396: LD_EXP 1
1400: NOT
1401: PPUSH
1402: CALL 474 0 2
1406: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1407: LD_ADDR_EXP 38
1411: PUSH
1412: LD_STRING Cyrus
1414: PPUSH
1415: LD_EXP 1
1419: NOT
1420: PPUSH
1421: CALL 474 0 2
1425: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1426: LD_ADDR_EXP 39
1430: PUSH
1431: LD_STRING Lisa
1433: PPUSH
1434: LD_EXP 1
1438: NOT
1439: PPUSH
1440: CALL 474 0 2
1444: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1445: LD_ADDR_EXP 40
1449: PUSH
1450: LD_STRING Khatam
1452: PPUSH
1453: LD_EXP 1
1457: NOT
1458: PPUSH
1459: CALL 474 0 2
1463: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1464: LD_ADDR_EXP 41
1468: PUSH
1469: LD_STRING Brian
1471: PPUSH
1472: LD_EXP 1
1476: NOT
1477: PPUSH
1478: CALL 474 0 2
1482: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1483: LD_ADDR_EXP 42
1487: PUSH
1488: LD_STRING Jerry
1490: PPUSH
1491: LD_EXP 1
1495: NOT
1496: PPUSH
1497: CALL 474 0 2
1501: ST_TO_ADDR
// if Bobby then
1502: LD_EXP 37
1506: IFFALSE 1537
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1508: LD_ADDR_VAR 0 4
1512: PUSH
1513: LD_VAR 0 4
1517: PPUSH
1518: LD_VAR 0 4
1522: PUSH
1523: LD_INT 1
1525: PLUS
1526: PPUSH
1527: LD_EXP 37
1531: PPUSH
1532: CALL_OW 2
1536: ST_TO_ADDR
// if Cyrus then
1537: LD_EXP 38
1541: IFFALSE 1572
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1543: LD_ADDR_VAR 0 4
1547: PUSH
1548: LD_VAR 0 4
1552: PPUSH
1553: LD_VAR 0 4
1557: PUSH
1558: LD_INT 1
1560: PLUS
1561: PPUSH
1562: LD_EXP 38
1566: PPUSH
1567: CALL_OW 2
1571: ST_TO_ADDR
// if Lisa then
1572: LD_EXP 39
1576: IFFALSE 1607
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1578: LD_ADDR_VAR 0 4
1582: PUSH
1583: LD_VAR 0 4
1587: PPUSH
1588: LD_VAR 0 4
1592: PUSH
1593: LD_INT 1
1595: PLUS
1596: PPUSH
1597: LD_EXP 39
1601: PPUSH
1602: CALL_OW 2
1606: ST_TO_ADDR
// if Khatam then
1607: LD_EXP 40
1611: IFFALSE 1642
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1613: LD_ADDR_VAR 0 4
1617: PUSH
1618: LD_VAR 0 4
1622: PPUSH
1623: LD_VAR 0 4
1627: PUSH
1628: LD_INT 1
1630: PLUS
1631: PPUSH
1632: LD_EXP 40
1636: PPUSH
1637: CALL_OW 2
1641: ST_TO_ADDR
// if Brian then
1642: LD_EXP 41
1646: IFFALSE 1677
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1648: LD_ADDR_VAR 0 4
1652: PUSH
1653: LD_VAR 0 4
1657: PPUSH
1658: LD_VAR 0 4
1662: PUSH
1663: LD_INT 1
1665: PLUS
1666: PPUSH
1667: LD_EXP 41
1671: PPUSH
1672: CALL_OW 2
1676: ST_TO_ADDR
// if Jerry then
1677: LD_EXP 42
1681: IFFALSE 1712
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1683: LD_ADDR_VAR 0 4
1687: PUSH
1688: LD_VAR 0 4
1692: PPUSH
1693: LD_VAR 0 4
1697: PUSH
1698: LD_INT 1
1700: PLUS
1701: PPUSH
1702: LD_EXP 42
1706: PPUSH
1707: CALL_OW 2
1711: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1712: LD_STRING 02_other_survivors
1714: PPUSH
1715: CALL_OW 28
1719: IFFALSE 1734
// others := CreateCharacterSet ( 02_other_survivors ) ;
1721: LD_ADDR_VAR 0 5
1725: PUSH
1726: LD_STRING 02_other_survivors
1728: PPUSH
1729: CALL_OW 31
1733: ST_TO_ADDR
// if others then
1734: LD_VAR 0 5
1738: IFFALSE 1763
// begin tmp := tmp ^ others ;
1740: LD_ADDR_VAR 0 4
1744: PUSH
1745: LD_VAR 0 4
1749: PUSH
1750: LD_VAR 0 5
1754: ADD
1755: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1756: LD_STRING 02_other_survivors
1758: PPUSH
1759: CALL_OW 40
// end ; jmm_units := tmp ;
1763: LD_ADDR_EXP 4
1767: PUSH
1768: LD_VAR 0 4
1772: ST_TO_ADDR
// if not vehicles then
1773: LD_VAR 0 6
1777: NOT
1778: IFFALSE 1796
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1780: LD_ADDR_VAR 0 6
1784: PUSH
1785: LD_STRING 02_tanks_1
1787: PPUSH
1788: LD_INT 0
1790: PPUSH
1791: CALL_OW 30
1795: ST_TO_ADDR
// if vehicles then
1796: LD_VAR 0 6
1800: IFFALSE 1994
// begin got_mech := false ;
1802: LD_ADDR_VAR 0 7
1806: PUSH
1807: LD_INT 0
1809: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1810: LD_VAR 0 4
1814: PPUSH
1815: LD_INT 25
1817: PUSH
1818: LD_INT 3
1820: PUSH
1821: EMPTY
1822: LIST
1823: LIST
1824: PPUSH
1825: CALL_OW 72
1829: IFFALSE 1839
// got_mech := true ;
1831: LD_ADDR_VAR 0 7
1835: PUSH
1836: LD_INT 1
1838: ST_TO_ADDR
// for i = 1 to vehicles do
1839: LD_ADDR_VAR 0 2
1843: PUSH
1844: DOUBLE
1845: LD_INT 1
1847: DEC
1848: ST_TO_ADDR
1849: LD_VAR 0 6
1853: PUSH
1854: FOR_TO
1855: IFFALSE 1992
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1857: LD_ADDR_VAR 0 3
1861: PUSH
1862: LD_INT 1
1864: PPUSH
1865: LD_INT 3
1867: PPUSH
1868: LD_VAR 0 6
1872: PUSH
1873: LD_VAR 0 2
1877: ARRAY
1878: PUSH
1879: LD_INT 1
1881: ARRAY
1882: PPUSH
1883: LD_VAR 0 6
1887: PUSH
1888: LD_VAR 0 2
1892: ARRAY
1893: PUSH
1894: LD_INT 2
1896: ARRAY
1897: PPUSH
1898: LD_VAR 0 6
1902: PUSH
1903: LD_VAR 0 2
1907: ARRAY
1908: PUSH
1909: LD_INT 3
1911: ARRAY
1912: PPUSH
1913: LD_VAR 0 6
1917: PUSH
1918: LD_VAR 0 2
1922: ARRAY
1923: PUSH
1924: LD_INT 4
1926: ARRAY
1927: PPUSH
1928: LD_INT 40
1930: PPUSH
1931: CALL 537 0 7
1935: ST_TO_ADDR
// if not got_mech then
1936: LD_VAR 0 7
1940: NOT
1941: IFFALSE 1967
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1943: LD_VAR 0 3
1947: PPUSH
1948: LD_VAR 0 6
1952: PUSH
1953: LD_VAR 0 2
1957: ARRAY
1958: PUSH
1959: LD_INT 6
1961: ARRAY
1962: PPUSH
1963: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1967: LD_ADDR_VAR 0 4
1971: PUSH
1972: LD_VAR 0 4
1976: PPUSH
1977: LD_INT 1
1979: PPUSH
1980: LD_VAR 0 3
1984: PPUSH
1985: CALL_OW 2
1989: ST_TO_ADDR
// end ;
1990: GO 1854
1992: POP
1993: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1994: LD_EXP 36
1998: PPUSH
1999: LD_INT 194
2001: PPUSH
2002: LD_INT 119
2004: PPUSH
2005: LD_INT 0
2007: PPUSH
2008: CALL_OW 48
// if tmp then
2012: LD_VAR 0 4
2016: IFFALSE 2141
// begin for i in tmp do
2018: LD_ADDR_VAR 0 2
2022: PUSH
2023: LD_VAR 0 4
2027: PUSH
2028: FOR_IN
2029: IFFALSE 2139
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2031: LD_ADDR_VAR 0 8
2035: PUSH
2036: LD_INT 22
2038: PUSH
2039: LD_INT 1
2041: PUSH
2042: EMPTY
2043: LIST
2044: LIST
2045: PUSH
2046: LD_INT 21
2048: PUSH
2049: LD_INT 2
2051: PUSH
2052: EMPTY
2053: LIST
2054: LIST
2055: PUSH
2056: LD_INT 58
2058: PUSH
2059: EMPTY
2060: LIST
2061: PUSH
2062: EMPTY
2063: LIST
2064: LIST
2065: LIST
2066: PPUSH
2067: CALL_OW 69
2071: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2072: LD_VAR 0 2
2076: PPUSH
2077: CALL_OW 247
2081: PUSH
2082: LD_INT 1
2084: EQUAL
2085: PUSH
2086: LD_VAR 0 8
2090: AND
2091: IFFALSE 2113
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2093: LD_VAR 0 2
2097: PPUSH
2098: LD_VAR 0 8
2102: PUSH
2103: LD_INT 1
2105: ARRAY
2106: PPUSH
2107: CALL_OW 52
2111: GO 2128
// PlaceUnitArea ( i , startArea , false ) ;
2113: LD_VAR 0 2
2117: PPUSH
2118: LD_INT 1
2120: PPUSH
2121: LD_INT 0
2123: PPUSH
2124: CALL_OW 49
// ComHold ( i ) ;
2128: LD_VAR 0 2
2132: PPUSH
2133: CALL_OW 140
// end ;
2137: GO 2028
2139: POP
2140: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2141: LD_ADDR_EXP 7
2145: PUSH
2146: LD_STRING 02_mikhailStatus_1
2148: PPUSH
2149: LD_INT 0
2151: PPUSH
2152: CALL_OW 30
2156: ST_TO_ADDR
// if not bierezov_exist and not debug then
2157: LD_EXP 7
2161: NOT
2162: PUSH
2163: LD_EXP 1
2167: NOT
2168: AND
2169: IFFALSE 2173
// exit ;
2171: GO 2204
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2173: LD_ADDR_EXP 44
2177: PUSH
2178: LD_STRING Mikhail
2180: PPUSH
2181: LD_INT 0
2183: PPUSH
2184: CALL 474 0 2
2188: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2189: LD_EXP 44
2193: PPUSH
2194: LD_INT 1
2196: PPUSH
2197: LD_INT 0
2199: PPUSH
2200: CALL_OW 49
// end ;
2204: LD_VAR 0 1
2208: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2209: LD_INT 0
2211: PPUSH
2212: PPUSH
2213: PPUSH
2214: PPUSH
// uc_side := 4 ;
2215: LD_ADDR_OWVAR 20
2219: PUSH
2220: LD_INT 4
2222: ST_TO_ADDR
// uc_nation := 1 ;
2223: LD_ADDR_OWVAR 21
2227: PUSH
2228: LD_INT 1
2230: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2231: LD_ADDR_EXP 43
2235: PUSH
2236: LD_STRING Cornell
2238: PPUSH
2239: LD_INT 0
2241: PPUSH
2242: CALL 474 0 2
2246: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2247: LD_ADDR_EXP 6
2251: PUSH
2252: LD_INT 9
2254: PUSH
2255: LD_EXP 4
2259: MINUS
2260: ST_TO_ADDR
// tmp := [ ] ;
2261: LD_ADDR_VAR 0 2
2265: PUSH
2266: EMPTY
2267: ST_TO_ADDR
// if cornel_units < 4 then
2268: LD_EXP 6
2272: PUSH
2273: LD_INT 4
2275: LESS
2276: IFFALSE 2286
// cornel_units := 4 ;
2278: LD_ADDR_EXP 6
2282: PUSH
2283: LD_INT 4
2285: ST_TO_ADDR
// for i = 1 to cornel_units do
2286: LD_ADDR_VAR 0 4
2290: PUSH
2291: DOUBLE
2292: LD_INT 1
2294: DEC
2295: ST_TO_ADDR
2296: LD_EXP 6
2300: PUSH
2301: FOR_TO
2302: IFFALSE 2400
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2304: LD_INT 0
2306: PPUSH
2307: LD_INT 1
2309: PUSH
2310: LD_INT 1
2312: PUSH
2313: LD_INT 1
2315: PUSH
2316: LD_INT 2
2318: PUSH
2319: LD_INT 4
2321: PUSH
2322: EMPTY
2323: LIST
2324: LIST
2325: LIST
2326: LIST
2327: LIST
2328: PUSH
2329: LD_VAR 0 4
2333: PUSH
2334: LD_INT 5
2336: MOD
2337: PUSH
2338: LD_INT 1
2340: PLUS
2341: ARRAY
2342: PPUSH
2343: LD_INT 2
2345: PPUSH
2346: CALL_OW 380
// un := CreateHuman ;
2350: LD_ADDR_VAR 0 3
2354: PUSH
2355: CALL_OW 44
2359: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2360: LD_ADDR_VAR 0 2
2364: PUSH
2365: LD_VAR 0 2
2369: PPUSH
2370: LD_INT 1
2372: PPUSH
2373: LD_VAR 0 3
2377: PPUSH
2378: CALL_OW 2
2382: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2383: LD_VAR 0 3
2387: PPUSH
2388: LD_INT 2
2390: PPUSH
2391: LD_INT 0
2393: PPUSH
2394: CALL_OW 49
// end ;
2398: GO 2301
2400: POP
2401: POP
// cornel_units := tmp ;
2402: LD_ADDR_EXP 6
2406: PUSH
2407: LD_VAR 0 2
2411: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2412: LD_EXP 43
2416: PPUSH
2417: LD_INT 191
2419: PPUSH
2420: LD_INT 106
2422: PPUSH
2423: LD_INT 0
2425: PPUSH
2426: CALL_OW 48
// end ;
2430: LD_VAR 0 1
2434: RET
// export function PrepareWesternBase ; var i ; begin
2435: LD_INT 0
2437: PPUSH
2438: PPUSH
// uc_side := 8 ;
2439: LD_ADDR_OWVAR 20
2443: PUSH
2444: LD_INT 8
2446: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2447: LD_ADDR_EXP 46
2451: PUSH
2452: LD_STRING Lynch
2454: PPUSH
2455: LD_INT 0
2457: PPUSH
2458: CALL 474 0 2
2462: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2463: LD_ADDR_EXP 47
2467: PUSH
2468: LD_STRING Walker
2470: PPUSH
2471: LD_INT 0
2473: PPUSH
2474: CALL 474 0 2
2478: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2479: LD_ADDR_EXP 48
2483: PUSH
2484: LD_STRING Turner
2486: PPUSH
2487: LD_INT 0
2489: PPUSH
2490: CALL 474 0 2
2494: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2495: LD_ADDR_EXP 49
2499: PUSH
2500: LD_STRING Jillian
2502: PPUSH
2503: LD_INT 0
2505: PPUSH
2506: CALL 474 0 2
2510: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_EXP 46
2520: PUSH
2521: LD_EXP 47
2525: PUSH
2526: LD_EXP 48
2530: PUSH
2531: LD_EXP 49
2535: PUSH
2536: EMPTY
2537: LIST
2538: LIST
2539: LIST
2540: LIST
2541: PUSH
2542: FOR_IN
2543: IFFALSE 2571
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2545: LD_VAR 0 2
2549: PPUSH
2550: LD_INT 3
2552: PPUSH
2553: LD_INT 0
2555: PPUSH
2556: CALL_OW 49
// ComHold ( i ) ;
2560: LD_VAR 0 2
2564: PPUSH
2565: CALL_OW 140
// end ;
2569: GO 2542
2571: POP
2572: POP
// end ;
2573: LD_VAR 0 1
2577: RET
// export function SelectGroup ; var units , selected , i ; begin
2578: LD_INT 0
2580: PPUSH
2581: PPUSH
2582: PPUSH
2583: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2584: LD_ADDR_VAR 0 2
2588: PUSH
2589: LD_EXP 36
2593: PUSH
2594: LD_INT -3
2596: PUSH
2597: EMPTY
2598: LIST
2599: LIST
2600: PUSH
2601: LD_EXP 4
2605: ADD
2606: PUSH
2607: LD_INT -2
2609: PUSH
2610: LD_INT -4
2612: PUSH
2613: LD_EXP 43
2617: PUSH
2618: LD_EXP 44
2622: PUSH
2623: EMPTY
2624: LIST
2625: LIST
2626: LIST
2627: LIST
2628: ADD
2629: PUSH
2630: LD_INT -3
2632: PUSH
2633: EMPTY
2634: LIST
2635: ADD
2636: PUSH
2637: LD_EXP 6
2641: ADD
2642: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2643: LD_ADDR_VAR 0 3
2647: PUSH
2648: LD_EXP 36
2652: PUSH
2653: LD_STRING Select five characters to go with you
2655: PPUSH
2656: LD_INT 4
2658: PPUSH
2659: LD_INT 4
2661: PPUSH
2662: LD_VAR 0 2
2666: PPUSH
2667: EMPTY
2668: PPUSH
2669: CALL_OW 42
2673: ADD
2674: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2675: LD_ADDR_EXP 6
2679: PUSH
2680: LD_EXP 4
2684: PUSH
2685: LD_EXP 6
2689: UNION
2690: PUSH
2691: LD_VAR 0 3
2695: DIFF
2696: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2697: LD_ADDR_VAR 0 4
2701: PUSH
2702: LD_EXP 6
2706: PUSH
2707: LD_EXP 44
2711: ADD
2712: PUSH
2713: FOR_IN
2714: IFFALSE 2745
// if GetSide ( i ) = 1 then
2716: LD_VAR 0 4
2720: PPUSH
2721: CALL_OW 255
2725: PUSH
2726: LD_INT 1
2728: EQUAL
2729: IFFALSE 2743
// SetSide ( i , 4 ) ;
2731: LD_VAR 0 4
2735: PPUSH
2736: LD_INT 4
2738: PPUSH
2739: CALL_OW 235
2743: GO 2713
2745: POP
2746: POP
// for i in selected do
2747: LD_ADDR_VAR 0 4
2751: PUSH
2752: LD_VAR 0 3
2756: PUSH
2757: FOR_IN
2758: IFFALSE 2789
// if GetSide ( i ) = 4 then
2760: LD_VAR 0 4
2764: PPUSH
2765: CALL_OW 255
2769: PUSH
2770: LD_INT 4
2772: EQUAL
2773: IFFALSE 2787
// SetSide ( i , 1 ) ;
2775: LD_VAR 0 4
2779: PPUSH
2780: LD_INT 1
2782: PPUSH
2783: CALL_OW 235
2787: GO 2757
2789: POP
2790: POP
// jmm_units := jmm_units diff cornel_units ;
2791: LD_ADDR_EXP 4
2795: PUSH
2796: LD_EXP 4
2800: PUSH
2801: LD_EXP 6
2805: DIFF
2806: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2807: LD_EXP 37
2811: PPUSH
2812: CALL_OW 255
2816: PUSH
2817: LD_INT 4
2819: EQUAL
2820: IFFALSE 2835
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2822: LD_EXP 3
2826: PUSH
2827: LD_STRING Bobby
2829: STR
2830: PPUSH
2831: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2835: LD_EXP 38
2839: PPUSH
2840: CALL_OW 255
2844: PUSH
2845: LD_INT 4
2847: EQUAL
2848: IFFALSE 2863
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2850: LD_EXP 3
2854: PUSH
2855: LD_STRING Cyrus
2857: STR
2858: PPUSH
2859: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2863: LD_EXP 39
2867: PPUSH
2868: CALL_OW 255
2872: PUSH
2873: LD_INT 4
2875: EQUAL
2876: IFFALSE 2891
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2878: LD_EXP 3
2882: PUSH
2883: LD_STRING Lisa
2885: STR
2886: PPUSH
2887: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2891: LD_EXP 40
2895: PPUSH
2896: CALL_OW 255
2900: PUSH
2901: LD_INT 4
2903: EQUAL
2904: IFFALSE 2919
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
2906: LD_EXP 3
2910: PUSH
2911: LD_STRING Khatam
2913: STR
2914: PPUSH
2915: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2919: LD_EXP 41
2923: PPUSH
2924: CALL_OW 255
2928: PUSH
2929: LD_INT 4
2931: EQUAL
2932: IFFALSE 2947
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
2934: LD_EXP 3
2938: PUSH
2939: LD_STRING Brian
2941: STR
2942: PPUSH
2943: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2947: LD_EXP 42
2951: PPUSH
2952: CALL_OW 255
2956: PUSH
2957: LD_INT 4
2959: EQUAL
2960: IFFALSE 2975
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
2962: LD_EXP 3
2966: PUSH
2967: LD_STRING Jerry
2969: STR
2970: PPUSH
2971: CALL_OW 40
// end ; end_of_file
2975: LD_VAR 0 1
2979: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
2980: LD_INT 0
2982: PPUSH
2983: PPUSH
2984: PPUSH
2985: PPUSH
2986: PPUSH
2987: PPUSH
2988: PPUSH
2989: PPUSH
2990: PPUSH
2991: PPUSH
2992: PPUSH
2993: PPUSH
2994: PPUSH
// ru_alert := false ;
2995: LD_ADDR_EXP 59
2999: PUSH
3000: LD_INT 0
3002: ST_TO_ADDR
// ru_produce_list := [ ] ;
3003: LD_ADDR_EXP 56
3007: PUSH
3008: EMPTY
3009: ST_TO_ADDR
// if Difficulty > 1 then
3010: LD_OWVAR 67
3014: PUSH
3015: LD_INT 1
3017: GREATER
3018: IFFALSE 3106
// begin uc_side := 3 ;
3020: LD_ADDR_OWVAR 20
3024: PUSH
3025: LD_INT 3
3027: ST_TO_ADDR
// uc_nation := 3 ;
3028: LD_ADDR_OWVAR 21
3032: PUSH
3033: LD_INT 3
3035: ST_TO_ADDR
// bc_type := b_breastwork ;
3036: LD_ADDR_OWVAR 42
3040: PUSH
3041: LD_INT 31
3043: ST_TO_ADDR
// bc_level := Difficulty ;
3044: LD_ADDR_OWVAR 43
3048: PUSH
3049: LD_OWVAR 67
3053: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3054: LD_INT 22
3056: PPUSH
3057: LD_INT 14
3059: PPUSH
3060: LD_INT 0
3062: PPUSH
3063: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3067: LD_INT 48
3069: PPUSH
3070: LD_INT 46
3072: PPUSH
3073: LD_INT 0
3075: PPUSH
3076: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3080: LD_INT 86
3082: PPUSH
3083: LD_INT 65
3085: PPUSH
3086: LD_INT 5
3088: PPUSH
3089: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3093: LD_INT 165
3095: PPUSH
3096: LD_INT 73
3098: PPUSH
3099: LD_INT 5
3101: PPUSH
3102: CALL_OW 47
// end ; if Difficulty = 3 then
3106: LD_OWVAR 67
3110: PUSH
3111: LD_INT 3
3113: EQUAL
3114: IFFALSE 3129
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3116: LD_INT 51
3118: PPUSH
3119: LD_INT 3
3121: PPUSH
3122: LD_INT 2
3124: PPUSH
3125: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3129: LD_ADDR_VAR 0 7
3133: PUSH
3134: LD_INT 22
3136: PUSH
3137: LD_INT 3
3139: PUSH
3140: EMPTY
3141: LIST
3142: LIST
3143: PUSH
3144: LD_INT 2
3146: PUSH
3147: LD_INT 30
3149: PUSH
3150: LD_INT 31
3152: PUSH
3153: EMPTY
3154: LIST
3155: LIST
3156: PUSH
3157: LD_INT 30
3159: PUSH
3160: LD_INT 32
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: PUSH
3167: EMPTY
3168: LIST
3169: LIST
3170: LIST
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: PPUSH
3176: CALL_OW 69
3180: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3181: LD_ADDR_VAR 0 8
3185: PUSH
3186: LD_INT 22
3188: PUSH
3189: LD_INT 3
3191: PUSH
3192: EMPTY
3193: LIST
3194: LIST
3195: PUSH
3196: LD_INT 30
3198: PUSH
3199: LD_INT 4
3201: PUSH
3202: EMPTY
3203: LIST
3204: LIST
3205: PUSH
3206: EMPTY
3207: LIST
3208: LIST
3209: PPUSH
3210: CALL_OW 69
3214: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3215: LD_ADDR_VAR 0 10
3219: PUSH
3220: LD_INT 22
3222: PUSH
3223: LD_INT 3
3225: PUSH
3226: EMPTY
3227: LIST
3228: LIST
3229: PUSH
3230: LD_INT 30
3232: PUSH
3233: LD_INT 3
3235: PUSH
3236: EMPTY
3237: LIST
3238: LIST
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: PPUSH
3244: CALL_OW 69
3248: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3249: LD_ADDR_VAR 0 9
3253: PUSH
3254: LD_INT 22
3256: PUSH
3257: LD_INT 3
3259: PUSH
3260: EMPTY
3261: LIST
3262: LIST
3263: PUSH
3264: LD_INT 30
3266: PUSH
3267: LD_INT 6
3269: PUSH
3270: EMPTY
3271: LIST
3272: LIST
3273: PUSH
3274: EMPTY
3275: LIST
3276: LIST
3277: PPUSH
3278: CALL_OW 69
3282: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3283: LD_ADDR_VAR 0 2
3287: PUSH
3288: LD_INT 22
3290: PUSH
3291: LD_INT 3
3293: PUSH
3294: EMPTY
3295: LIST
3296: LIST
3297: PUSH
3298: LD_INT 30
3300: PUSH
3301: LD_INT 1
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: PUSH
3308: EMPTY
3309: LIST
3310: LIST
3311: PPUSH
3312: CALL_OW 69
3316: PUSH
3317: FOR_IN
3318: IFFALSE 3362
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3320: LD_VAR 0 2
3324: PPUSH
3325: CALL_OW 274
3329: PPUSH
3330: LD_INT 1
3332: PPUSH
3333: LD_INT 5000
3335: PPUSH
3336: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3340: LD_VAR 0 2
3344: PPUSH
3345: CALL_OW 274
3349: PPUSH
3350: LD_INT 2
3352: PPUSH
3353: LD_INT 3000
3355: PPUSH
3356: CALL_OW 277
// end ;
3360: GO 3317
3362: POP
3363: POP
// uc_side := 3 ;
3364: LD_ADDR_OWVAR 20
3368: PUSH
3369: LD_INT 3
3371: ST_TO_ADDR
// uc_nation := 3 ;
3372: LD_ADDR_OWVAR 21
3376: PUSH
3377: LD_INT 3
3379: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3380: LD_ADDR_VAR 0 11
3384: PUSH
3385: LD_INT 2
3387: PUSH
3388: LD_INT 3
3390: PUSH
3391: LD_INT 4
3393: PUSH
3394: EMPTY
3395: LIST
3396: LIST
3397: LIST
3398: PUSH
3399: LD_OWVAR 67
3403: ARRAY
3404: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3405: LD_ADDR_EXP 51
3409: PUSH
3410: LD_STRING Pokryshkin
3412: PPUSH
3413: LD_INT 0
3415: PPUSH
3416: CALL 474 0 2
3420: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3421: LD_EXP 51
3425: PPUSH
3426: LD_INT 63
3428: PPUSH
3429: LD_INT 21
3431: PPUSH
3432: LD_INT 0
3434: PPUSH
3435: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3439: LD_EXP 51
3443: PPUSH
3444: CALL_OW 140
// InitHc ;
3448: CALL_OW 19
// for i in fac do
3452: LD_ADDR_VAR 0 2
3456: PUSH
3457: LD_VAR 0 10
3461: PUSH
3462: FOR_IN
3463: IFFALSE 3516
// begin for j = 1 to 6 do
3465: LD_ADDR_VAR 0 3
3469: PUSH
3470: DOUBLE
3471: LD_INT 1
3473: DEC
3474: ST_TO_ADDR
3475: LD_INT 6
3477: PUSH
3478: FOR_TO
3479: IFFALSE 3512
// begin PrepareHuman ( false , 3 , skill ) ;
3481: LD_INT 0
3483: PPUSH
3484: LD_INT 3
3486: PPUSH
3487: LD_VAR 0 11
3491: PPUSH
3492: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3496: CALL_OW 44
3500: PPUSH
3501: LD_VAR 0 2
3505: PPUSH
3506: CALL_OW 52
// end ;
3510: GO 3478
3512: POP
3513: POP
// end ;
3514: GO 3462
3516: POP
3517: POP
// for i in lab do
3518: LD_ADDR_VAR 0 2
3522: PUSH
3523: LD_VAR 0 9
3527: PUSH
3528: FOR_IN
3529: IFFALSE 3562
// begin PrepareHuman ( false , 4 , skill ) ;
3531: LD_INT 0
3533: PPUSH
3534: LD_INT 4
3536: PPUSH
3537: LD_VAR 0 11
3541: PPUSH
3542: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3546: CALL_OW 44
3550: PPUSH
3551: LD_VAR 0 2
3555: PPUSH
3556: CALL_OW 52
// end ;
3560: GO 3528
3562: POP
3563: POP
// for i in tw do
3564: LD_ADDR_VAR 0 2
3568: PUSH
3569: LD_VAR 0 7
3573: PUSH
3574: FOR_IN
3575: IFFALSE 3624
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3577: LD_VAR 0 2
3581: PPUSH
3582: LD_INT 42
3584: PUSH
3585: LD_INT 43
3587: PUSH
3588: EMPTY
3589: LIST
3590: LIST
3591: PUSH
3592: LD_INT 1
3594: PPUSH
3595: LD_INT 2
3597: PPUSH
3598: CALL_OW 12
3602: ARRAY
3603: PPUSH
3604: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3608: LD_VAR 0 11
3612: PPUSH
3613: LD_VAR 0 2
3617: PPUSH
3618: CALL 815 0 2
// end ;
3622: GO 3574
3624: POP
3625: POP
// for i in bar do
3626: LD_ADDR_VAR 0 2
3630: PUSH
3631: LD_VAR 0 8
3635: PUSH
3636: FOR_IN
3637: IFFALSE 3670
// begin PrepareHuman ( false , 1 , skill ) ;
3639: LD_INT 0
3641: PPUSH
3642: LD_INT 1
3644: PPUSH
3645: LD_VAR 0 11
3649: PPUSH
3650: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3654: CALL_OW 44
3658: PPUSH
3659: LD_VAR 0 2
3663: PPUSH
3664: CALL_OW 52
// end ;
3668: GO 3636
3670: POP
3671: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3672: LD_ADDR_VAR 0 13
3676: PUSH
3677: LD_INT 100
3679: PUSH
3680: LD_INT 9
3682: PUSH
3683: EMPTY
3684: LIST
3685: LIST
3686: PUSH
3687: LD_INT 135
3689: PUSH
3690: LD_INT 60
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: PUSH
3697: LD_INT 41
3699: PUSH
3700: LD_INT 6
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: PUSH
3707: LD_INT 22
3709: PUSH
3710: LD_INT 9
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: PUSH
3717: LD_INT 84
3719: PUSH
3720: LD_INT 14
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: LIST
3731: LIST
3732: LIST
3733: ST_TO_ADDR
// vehicles := [ ] ;
3734: LD_ADDR_VAR 0 12
3738: PUSH
3739: EMPTY
3740: ST_TO_ADDR
// for i in spot_xy do
3741: LD_ADDR_VAR 0 2
3745: PUSH
3746: LD_VAR 0 13
3750: PUSH
3751: FOR_IN
3752: IFFALSE 3910
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3754: LD_ADDR_VAR 0 6
3758: PUSH
3759: LD_INT 3
3761: PPUSH
3762: LD_INT 3
3764: PPUSH
3765: LD_INT 22
3767: PPUSH
3768: LD_INT 1
3770: PPUSH
3771: LD_INT 1
3773: PPUSH
3774: LD_INT 42
3776: PUSH
3777: LD_INT 43
3779: PUSH
3780: LD_INT 44
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: LIST
3787: PUSH
3788: LD_INT 1
3790: PPUSH
3791: LD_INT 3
3793: PPUSH
3794: CALL_OW 12
3798: ARRAY
3799: PPUSH
3800: LD_INT 100
3802: PPUSH
3803: CALL 537 0 7
3807: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3808: LD_ADDR_VAR 0 12
3812: PUSH
3813: LD_VAR 0 12
3817: PPUSH
3818: LD_VAR 0 12
3822: PUSH
3823: LD_INT 1
3825: PLUS
3826: PPUSH
3827: LD_VAR 0 6
3831: PPUSH
3832: CALL_OW 2
3836: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3837: LD_VAR 0 6
3841: PPUSH
3842: LD_INT 3
3844: PPUSH
3845: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3849: LD_VAR 0 6
3853: PPUSH
3854: LD_VAR 0 2
3858: PUSH
3859: LD_INT 1
3861: ARRAY
3862: PPUSH
3863: LD_VAR 0 2
3867: PUSH
3868: LD_INT 2
3870: ARRAY
3871: PPUSH
3872: LD_INT 0
3874: PPUSH
3875: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3879: LD_INT 0
3881: PPUSH
3882: LD_INT 3
3884: PPUSH
3885: LD_VAR 0 11
3889: PPUSH
3890: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3894: CALL_OW 44
3898: PPUSH
3899: LD_VAR 0 6
3903: PPUSH
3904: CALL_OW 52
// end ;
3908: GO 3751
3910: POP
3911: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3912: LD_ADDR_VAR 0 2
3916: PUSH
3917: DOUBLE
3918: LD_INT 1
3920: DEC
3921: ST_TO_ADDR
3922: LD_INT 5
3924: PUSH
3925: LD_INT 7
3927: PUSH
3928: LD_INT 8
3930: PUSH
3931: EMPTY
3932: LIST
3933: LIST
3934: LIST
3935: PUSH
3936: LD_OWVAR 67
3940: ARRAY
3941: PUSH
3942: FOR_TO
3943: IFFALSE 4003
// begin PrepareHuman ( false , 1 , skill ) ;
3945: LD_INT 0
3947: PPUSH
3948: LD_INT 1
3950: PPUSH
3951: LD_VAR 0 11
3955: PPUSH
3956: CALL_OW 380
// un := CreateHuman ;
3960: LD_ADDR_VAR 0 5
3964: PUSH
3965: CALL_OW 44
3969: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3970: LD_VAR 0 5
3974: PPUSH
3975: LD_INT 11
3977: PPUSH
3978: LD_INT 0
3980: PPUSH
3981: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3985: LD_ADDR_EXP 54
3989: PUSH
3990: LD_EXP 54
3994: PUSH
3995: LD_VAR 0 5
3999: ADD
4000: ST_TO_ADDR
// end ;
4001: GO 3942
4003: POP
4004: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
4005: LD_ADDR_VAR 0 2
4009: PUSH
4010: DOUBLE
4011: LD_INT 1
4013: DEC
4014: ST_TO_ADDR
4015: LD_INT 2
4017: PUSH
4018: LD_INT 3
4020: PUSH
4021: LD_INT 4
4023: PUSH
4024: EMPTY
4025: LIST
4026: LIST
4027: LIST
4028: PUSH
4029: LD_OWVAR 67
4033: ARRAY
4034: PUSH
4035: FOR_TO
4036: IFFALSE 4096
// begin PrepareHuman ( false , 1 , skill ) ;
4038: LD_INT 0
4040: PPUSH
4041: LD_INT 1
4043: PPUSH
4044: LD_VAR 0 11
4048: PPUSH
4049: CALL_OW 380
// un := CreateHuman ;
4053: LD_ADDR_VAR 0 5
4057: PUSH
4058: CALL_OW 44
4062: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4063: LD_VAR 0 5
4067: PPUSH
4068: LD_INT 12
4070: PPUSH
4071: LD_INT 0
4073: PPUSH
4074: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4078: LD_ADDR_EXP 52
4082: PUSH
4083: LD_EXP 52
4087: PUSH
4088: LD_VAR 0 5
4092: ADD
4093: ST_TO_ADDR
// end ;
4094: GO 4035
4096: POP
4097: POP
// for i = 1 to 2 do
4098: LD_ADDR_VAR 0 2
4102: PUSH
4103: DOUBLE
4104: LD_INT 1
4106: DEC
4107: ST_TO_ADDR
4108: LD_INT 2
4110: PUSH
4111: FOR_TO
4112: IFFALSE 4178
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4114: LD_INT 1
4116: PPUSH
4117: LD_INT 1
4119: PPUSH
4120: LD_VAR 0 11
4124: PPUSH
4125: CALL_OW 380
// un := CreateHuman ;
4129: LD_ADDR_VAR 0 5
4133: PUSH
4134: CALL_OW 44
4138: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4139: LD_VAR 0 5
4143: PPUSH
4144: LD_INT 39
4146: PPUSH
4147: LD_INT 12
4149: PPUSH
4150: LD_INT 3
4152: PPUSH
4153: LD_INT 0
4155: PPUSH
4156: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4160: LD_ADDR_EXP 53
4164: PUSH
4165: LD_EXP 53
4169: PUSH
4170: LD_VAR 0 5
4174: ADD
4175: ST_TO_ADDR
// end ;
4176: GO 4111
4178: POP
4179: POP
// for i = 1 to 3 do
4180: LD_ADDR_VAR 0 2
4184: PUSH
4185: DOUBLE
4186: LD_INT 1
4188: DEC
4189: ST_TO_ADDR
4190: LD_INT 3
4192: PUSH
4193: FOR_TO
4194: IFFALSE 4260
// begin PrepareHuman ( false , 1 , skill ) ;
4196: LD_INT 0
4198: PPUSH
4199: LD_INT 1
4201: PPUSH
4202: LD_VAR 0 11
4206: PPUSH
4207: CALL_OW 380
// un := CreateHuman ;
4211: LD_ADDR_VAR 0 5
4215: PUSH
4216: CALL_OW 44
4220: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4221: LD_VAR 0 5
4225: PPUSH
4226: LD_INT 180
4228: PPUSH
4229: LD_INT 11
4231: PPUSH
4232: LD_INT 4
4234: PPUSH
4235: LD_INT 0
4237: PPUSH
4238: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4242: LD_ADDR_EXP 57
4246: PUSH
4247: LD_EXP 57
4251: PUSH
4252: LD_VAR 0 5
4256: ADD
4257: ST_TO_ADDR
// end ;
4258: GO 4193
4260: POP
4261: POP
// ru_vehicles := vehicles ;
4262: LD_ADDR_EXP 55
4266: PUSH
4267: LD_VAR 0 12
4271: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4272: LD_ADDR_EXP 58
4276: PUSH
4277: LD_INT 131
4279: PUSH
4280: LD_INT 121
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PUSH
4287: LD_INT 113
4289: PUSH
4290: LD_INT 90
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: PUSH
4297: LD_INT 93
4299: PUSH
4300: LD_INT 62
4302: PUSH
4303: EMPTY
4304: LIST
4305: LIST
4306: PUSH
4307: EMPTY
4308: LIST
4309: LIST
4310: LIST
4311: PUSH
4312: LD_INT 106
4314: PUSH
4315: LD_INT 54
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: PUSH
4322: LD_INT 120
4324: PUSH
4325: LD_INT 80
4327: PUSH
4328: EMPTY
4329: LIST
4330: LIST
4331: PUSH
4332: LD_INT 143
4334: PUSH
4335: LD_INT 120
4337: PUSH
4338: EMPTY
4339: LIST
4340: LIST
4341: PUSH
4342: EMPTY
4343: LIST
4344: LIST
4345: LIST
4346: PUSH
4347: LD_INT 154
4349: PUSH
4350: LD_INT 116
4352: PUSH
4353: EMPTY
4354: LIST
4355: LIST
4356: PUSH
4357: LD_INT 140
4359: PUSH
4360: LD_INT 93
4362: PUSH
4363: EMPTY
4364: LIST
4365: LIST
4366: PUSH
4367: LD_INT 130
4369: PUSH
4370: LD_INT 58
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: LIST
4381: PUSH
4382: LD_INT 105
4384: PUSH
4385: LD_INT 106
4387: PUSH
4388: EMPTY
4389: LIST
4390: LIST
4391: PUSH
4392: LD_INT 134
4394: PUSH
4395: LD_INT 98
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: LD_INT 159
4404: PUSH
4405: LD_INT 113
4407: PUSH
4408: EMPTY
4409: LIST
4410: LIST
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: LIST
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4423: LD_ADDR_VAR 0 2
4427: PUSH
4428: DOUBLE
4429: LD_INT 1
4431: DEC
4432: ST_TO_ADDR
4433: LD_OWVAR 67
4437: PUSH
4438: LD_INT 1
4440: MINUS
4441: PUSH
4442: FOR_TO
4443: IFFALSE 4476
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4445: LD_ADDR_EXP 56
4449: PUSH
4450: LD_EXP 56
4454: PUSH
4455: LD_INT 22
4457: PUSH
4458: LD_INT 1
4460: PUSH
4461: LD_INT 1
4463: PUSH
4464: LD_INT 43
4466: PUSH
4467: EMPTY
4468: LIST
4469: LIST
4470: LIST
4471: LIST
4472: ADD
4473: ST_TO_ADDR
4474: GO 4442
4476: POP
4477: POP
// end ;
4478: LD_VAR 0 1
4482: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4483: LD_INT 22
4485: PUSH
4486: LD_INT 3
4488: PUSH
4489: EMPTY
4490: LIST
4491: LIST
4492: PUSH
4493: LD_INT 21
4495: PUSH
4496: LD_INT 2
4498: PUSH
4499: EMPTY
4500: LIST
4501: LIST
4502: PUSH
4503: EMPTY
4504: LIST
4505: LIST
4506: PPUSH
4507: CALL_OW 69
4511: IFFALSE 4605
4513: GO 4515
4515: DISABLE
4516: LD_INT 0
4518: PPUSH
4519: PPUSH
// begin enable ;
4520: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4521: LD_ADDR_VAR 0 2
4525: PUSH
4526: LD_INT 22
4528: PUSH
4529: LD_INT 3
4531: PUSH
4532: EMPTY
4533: LIST
4534: LIST
4535: PUSH
4536: LD_INT 21
4538: PUSH
4539: LD_INT 2
4541: PUSH
4542: EMPTY
4543: LIST
4544: LIST
4545: PUSH
4546: EMPTY
4547: LIST
4548: LIST
4549: PPUSH
4550: CALL_OW 69
4554: ST_TO_ADDR
// if filter then
4555: LD_VAR 0 2
4559: IFFALSE 4605
// for i in filter do
4561: LD_ADDR_VAR 0 1
4565: PUSH
4566: LD_VAR 0 2
4570: PUSH
4571: FOR_IN
4572: IFFALSE 4603
// if GetFuel ( i ) < 20 then
4574: LD_VAR 0 1
4578: PPUSH
4579: CALL_OW 261
4583: PUSH
4584: LD_INT 20
4586: LESS
4587: IFFALSE 4601
// SetFuel ( i , 20 ) ;
4589: LD_VAR 0 1
4593: PPUSH
4594: LD_INT 20
4596: PPUSH
4597: CALL_OW 240
4601: GO 4571
4603: POP
4604: POP
// end ;
4605: PPOPN 2
4607: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4608: LD_EXP 56
4612: IFFALSE 4831
4614: GO 4616
4616: DISABLE
4617: LD_INT 0
4619: PPUSH
4620: PPUSH
4621: PPUSH
// begin enable ;
4622: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4623: LD_ADDR_VAR 0 2
4627: PUSH
4628: LD_INT 22
4630: PUSH
4631: LD_INT 3
4633: PUSH
4634: EMPTY
4635: LIST
4636: LIST
4637: PUSH
4638: LD_INT 30
4640: PUSH
4641: LD_INT 3
4643: PUSH
4644: EMPTY
4645: LIST
4646: LIST
4647: PUSH
4648: EMPTY
4649: LIST
4650: LIST
4651: PPUSH
4652: CALL_OW 69
4656: ST_TO_ADDR
// can_produce := [ ] ;
4657: LD_ADDR_VAR 0 3
4661: PUSH
4662: EMPTY
4663: ST_TO_ADDR
// if not fac then
4664: LD_VAR 0 2
4668: NOT
4669: IFFALSE 4674
// begin disable ;
4671: DISABLE
// exit ;
4672: GO 4831
// end ; for i in fac do
4674: LD_ADDR_VAR 0 1
4678: PUSH
4679: LD_VAR 0 2
4683: PUSH
4684: FOR_IN
4685: IFFALSE 4723
// if UnitsInside ( i ) then
4687: LD_VAR 0 1
4691: PPUSH
4692: CALL_OW 313
4696: IFFALSE 4721
// can_produce := Insert ( can_produce , 1 , i ) ;
4698: LD_ADDR_VAR 0 3
4702: PUSH
4703: LD_VAR 0 3
4707: PPUSH
4708: LD_INT 1
4710: PPUSH
4711: LD_VAR 0 1
4715: PPUSH
4716: CALL_OW 2
4720: ST_TO_ADDR
4721: GO 4684
4723: POP
4724: POP
// if not can_produce then
4725: LD_VAR 0 3
4729: NOT
4730: IFFALSE 4734
// exit ;
4732: GO 4831
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4734: LD_VAR 0 3
4738: PUSH
4739: LD_INT 1
4741: PPUSH
4742: LD_VAR 0 3
4746: PPUSH
4747: CALL_OW 12
4751: ARRAY
4752: PPUSH
4753: LD_EXP 56
4757: PUSH
4758: LD_INT 1
4760: ARRAY
4761: PPUSH
4762: LD_EXP 56
4766: PUSH
4767: LD_INT 2
4769: ARRAY
4770: PPUSH
4771: LD_EXP 56
4775: PUSH
4776: LD_INT 3
4778: ARRAY
4779: PPUSH
4780: LD_EXP 56
4784: PUSH
4785: LD_INT 4
4787: ARRAY
4788: PPUSH
4789: CALL_OW 125
// for i = 1 to 4 do
4793: LD_ADDR_VAR 0 1
4797: PUSH
4798: DOUBLE
4799: LD_INT 1
4801: DEC
4802: ST_TO_ADDR
4803: LD_INT 4
4805: PUSH
4806: FOR_TO
4807: IFFALSE 4829
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4809: LD_ADDR_EXP 56
4813: PUSH
4814: LD_EXP 56
4818: PPUSH
4819: LD_INT 1
4821: PPUSH
4822: CALL_OW 3
4826: ST_TO_ADDR
4827: GO 4806
4829: POP
4830: POP
// end ;
4831: PPOPN 3
4833: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4834: LD_INT 0
4836: PPUSH
4837: PPUSH
4838: PPUSH
// for i = 1 to 6 do
4839: LD_ADDR_VAR 0 2
4843: PUSH
4844: DOUBLE
4845: LD_INT 1
4847: DEC
4848: ST_TO_ADDR
4849: LD_INT 6
4851: PUSH
4852: FOR_TO
4853: IFFALSE 5002
// begin PrepareHuman ( false , 3 , 3 ) ;
4855: LD_INT 0
4857: PPUSH
4858: LD_INT 3
4860: PPUSH
4861: LD_INT 3
4863: PPUSH
4864: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4868: LD_ADDR_VAR 0 3
4872: PUSH
4873: LD_INT 3
4875: PPUSH
4876: LD_INT 3
4878: PPUSH
4879: LD_INT 22
4881: PPUSH
4882: LD_INT 1
4884: PPUSH
4885: LD_INT 1
4887: PPUSH
4888: LD_INT 43
4890: PUSH
4891: LD_INT 42
4893: PUSH
4894: EMPTY
4895: LIST
4896: LIST
4897: PUSH
4898: LD_INT 1
4900: PPUSH
4901: LD_INT 2
4903: PPUSH
4904: CALL_OW 12
4908: ARRAY
4909: PPUSH
4910: LD_INT 70
4912: PPUSH
4913: CALL 537 0 7
4917: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4918: LD_VAR 0 3
4922: PPUSH
4923: LD_INT 4
4925: PPUSH
4926: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4930: LD_VAR 0 3
4934: PPUSH
4935: LD_INT 229
4937: PPUSH
4938: LD_INT 44
4940: PPUSH
4941: LD_INT 0
4943: PPUSH
4944: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4948: CALL_OW 44
4952: PPUSH
4953: LD_VAR 0 3
4957: PPUSH
4958: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4962: LD_ADDR_EXP 55
4966: PUSH
4967: LD_EXP 55
4971: PUSH
4972: LD_VAR 0 3
4976: ADD
4977: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
4978: LD_VAR 0 3
4982: PPUSH
4983: LD_INT 191
4985: PPUSH
4986: LD_INT 32
4988: PPUSH
4989: CALL_OW 111
// Wait ( 0 0$02 ) ;
4993: LD_INT 70
4995: PPUSH
4996: CALL_OW 67
// end ;
5000: GO 4852
5002: POP
5003: POP
// end ;
5004: LD_VAR 0 1
5008: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
5009: LD_EXP 30
5013: PUSH
5014: LD_EXP 55
5018: AND
5019: IFFALSE 5193
5021: GO 5023
5023: DISABLE
5024: LD_INT 0
5026: PPUSH
5027: PPUSH
5028: PPUSH
// begin wait ( 0 0$50 ) ;
5029: LD_INT 1750
5031: PPUSH
5032: CALL_OW 67
// tmp := ru_vehicles ;
5036: LD_ADDR_VAR 0 3
5040: PUSH
5041: LD_EXP 55
5045: ST_TO_ADDR
// if not tmp then
5046: LD_VAR 0 3
5050: NOT
5051: IFFALSE 5055
// exit ;
5053: GO 5193
// repeat wait ( 0 0$1 ) ;
5055: LD_INT 35
5057: PPUSH
5058: CALL_OW 67
// for i in tmp do
5062: LD_ADDR_VAR 0 1
5066: PUSH
5067: LD_VAR 0 3
5071: PUSH
5072: FOR_IN
5073: IFFALSE 5184
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5075: LD_ADDR_VAR 0 2
5079: PUSH
5080: LD_INT 22
5082: PUSH
5083: LD_INT 1
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: PPUSH
5090: LD_VAR 0 1
5094: PPUSH
5095: CALL_OW 74
5099: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5100: LD_VAR 0 1
5104: PPUSH
5105: LD_VAR 0 2
5109: PPUSH
5110: CALL_OW 296
5114: PUSH
5115: LD_INT 10
5117: GREATER
5118: IFFALSE 5137
// ComAgressiveMove ( i , 69 , 101 ) else
5120: LD_VAR 0 1
5124: PPUSH
5125: LD_INT 69
5127: PPUSH
5128: LD_INT 101
5130: PPUSH
5131: CALL_OW 114
5135: GO 5151
// ComAttackUnit ( i , enemy ) ;
5137: LD_VAR 0 1
5141: PPUSH
5142: LD_VAR 0 2
5146: PPUSH
5147: CALL_OW 115
// if GetLives ( i ) < 250 then
5151: LD_VAR 0 1
5155: PPUSH
5156: CALL_OW 256
5160: PUSH
5161: LD_INT 250
5163: LESS
5164: IFFALSE 5182
// tmp := tmp diff i ;
5166: LD_ADDR_VAR 0 3
5170: PUSH
5171: LD_VAR 0 3
5175: PUSH
5176: LD_VAR 0 1
5180: DIFF
5181: ST_TO_ADDR
// end ;
5182: GO 5072
5184: POP
5185: POP
// until not tmp ;
5186: LD_VAR 0 3
5190: NOT
5191: IFFALSE 5055
// end ; end_of_file
5193: PPOPN 3
5195: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5196: LD_INT 0
5198: PPUSH
5199: PPUSH
5200: PPUSH
5201: PPUSH
5202: PPUSH
5203: PPUSH
5204: PPUSH
// InGameOn ;
5205: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5209: LD_EXP 36
5213: PPUSH
5214: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5218: LD_EXP 36
5222: PPUSH
5223: LD_EXP 43
5227: PPUSH
5228: CALL_OW 119
// if Bierezov then
5232: LD_EXP 44
5236: IFFALSE 5252
// ComTurnUnit ( Bierezov , Cornel ) ;
5238: LD_EXP 44
5242: PPUSH
5243: LD_EXP 43
5247: PPUSH
5248: CALL_OW 119
// for i in jmm_units do
5252: LD_ADDR_VAR 0 2
5256: PUSH
5257: LD_EXP 4
5261: PUSH
5262: FOR_IN
5263: IFFALSE 5281
// ComTurnUnit ( i , Cornel ) ;
5265: LD_VAR 0 2
5269: PPUSH
5270: LD_EXP 43
5274: PPUSH
5275: CALL_OW 119
5279: GO 5262
5281: POP
5282: POP
// units := cornel_units union Cornel ;
5283: LD_ADDR_VAR 0 3
5287: PUSH
5288: LD_EXP 6
5292: PUSH
5293: LD_EXP 43
5297: UNION
5298: ST_TO_ADDR
// repeat wait ( 1 ) ;
5299: LD_INT 1
5301: PPUSH
5302: CALL_OW 67
// for i in units do
5306: LD_ADDR_VAR 0 2
5310: PUSH
5311: LD_VAR 0 3
5315: PUSH
5316: FOR_IN
5317: IFFALSE 5350
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5319: LD_VAR 0 2
5323: PPUSH
5324: LD_EXP 36
5328: PPUSH
5329: CALL_OW 250
5333: PPUSH
5334: LD_EXP 36
5338: PPUSH
5339: CALL_OW 251
5343: PPUSH
5344: CALL_OW 111
5348: GO 5316
5350: POP
5351: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5352: LD_VAR 0 3
5356: PPUSH
5357: LD_INT 92
5359: PUSH
5360: LD_EXP 36
5364: PPUSH
5365: CALL_OW 250
5369: PUSH
5370: LD_EXP 36
5374: PPUSH
5375: CALL_OW 251
5379: PUSH
5380: LD_INT 10
5382: PUSH
5383: EMPTY
5384: LIST
5385: LIST
5386: LIST
5387: LIST
5388: PPUSH
5389: CALL_OW 72
5393: PUSH
5394: LD_VAR 0 3
5398: EQUAL
5399: IFFALSE 5299
// for i in units do
5401: LD_ADDR_VAR 0 2
5405: PUSH
5406: LD_VAR 0 3
5410: PUSH
5411: FOR_IN
5412: IFFALSE 5430
// ComTurnUnit ( i , JMM ) ;
5414: LD_VAR 0 2
5418: PPUSH
5419: LD_EXP 36
5423: PPUSH
5424: CALL_OW 119
5428: GO 5411
5430: POP
5431: POP
// ComTurnUnit ( Cornel , JMM ) ;
5432: LD_EXP 43
5436: PPUSH
5437: LD_EXP 36
5441: PPUSH
5442: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5446: LD_EXP 36
5450: PPUSH
5451: LD_STRING D1-JMM-1
5453: PPUSH
5454: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5458: LD_EXP 43
5462: PPUSH
5463: LD_STRING D1-Corn-1
5465: PPUSH
5466: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5470: LD_EXP 36
5474: PPUSH
5475: LD_EXP 43
5479: PPUSH
5480: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5484: LD_EXP 43
5488: PPUSH
5489: LD_EXP 36
5493: PPUSH
5494: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5498: LD_INT 35
5500: PPUSH
5501: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5505: LD_EXP 36
5509: PPUSH
5510: LD_EXP 43
5514: PPUSH
5515: CALL_OW 296
5519: PUSH
5520: LD_INT 6
5522: LESS
5523: IFFALSE 5498
// ChangeSideFog ( 4 , 1 ) ;
5525: LD_INT 4
5527: PPUSH
5528: LD_INT 1
5530: PPUSH
5531: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5535: LD_EXP 36
5539: PPUSH
5540: LD_EXP 43
5544: PPUSH
5545: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5549: LD_EXP 43
5553: PPUSH
5554: LD_EXP 36
5558: PPUSH
5559: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5563: LD_EXP 36
5567: PPUSH
5568: LD_STRING D1-JMM-2
5570: PPUSH
5571: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5575: LD_EXP 36
5579: PPUSH
5580: LD_STRING D1-JMM-2a
5582: PPUSH
5583: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5587: LD_EXP 43
5591: PPUSH
5592: LD_STRING D1-Corn-2
5594: PPUSH
5595: CALL_OW 88
// if bierezov_exist or debug then
5599: LD_EXP 7
5603: PUSH
5604: LD_EXP 1
5608: OR
5609: IFFALSE 5850
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5611: LD_EXP 43
5615: PPUSH
5616: LD_EXP 44
5620: PPUSH
5621: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5625: LD_INT 10
5627: PPUSH
5628: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5632: LD_EXP 43
5636: PPUSH
5637: LD_STRING D1a-Corn-1
5639: PPUSH
5640: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5644: LD_EXP 36
5648: PPUSH
5649: LD_EXP 44
5653: PPUSH
5654: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5658: LD_EXP 44
5662: PPUSH
5663: LD_EXP 36
5667: PPUSH
5668: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5672: LD_EXP 36
5676: PPUSH
5677: LD_STRING D1a-JMM-1
5679: PPUSH
5680: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5684: LD_EXP 36
5688: PPUSH
5689: LD_EXP 43
5693: PPUSH
5694: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5698: LD_EXP 43
5702: PPUSH
5703: LD_EXP 36
5707: PPUSH
5708: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5712: LD_EXP 43
5716: PPUSH
5717: LD_STRING D1a-Corn-2
5719: PPUSH
5720: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5724: LD_EXP 36
5728: PPUSH
5729: LD_STRING D1a-JMM-2
5731: PPUSH
5732: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5736: LD_EXP 43
5740: PPUSH
5741: LD_STRING D1a-Corn-3
5743: PPUSH
5744: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5748: LD_EXP 36
5752: PPUSH
5753: LD_STRING D1a-JMM-3
5755: PPUSH
5756: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5760: LD_EXP 43
5764: PPUSH
5765: LD_STRING D1a-Corn-4
5767: PPUSH
5768: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5772: LD_EXP 36
5776: PPUSH
5777: LD_STRING D1a-JMM-4
5779: PPUSH
5780: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5784: LD_EXP 43
5788: PPUSH
5789: LD_STRING D1a-Corn-5
5791: PPUSH
5792: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5796: LD_EXP 44
5800: PPUSH
5801: LD_EXP 43
5805: PPUSH
5806: CALL_OW 250
5810: PPUSH
5811: LD_EXP 43
5815: PPUSH
5816: CALL_OW 251
5820: PUSH
5821: LD_INT 2
5823: MINUS
5824: PPUSH
5825: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5829: LD_EXP 44
5833: PPUSH
5834: LD_EXP 43
5838: PPUSH
5839: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5843: LD_INT 10
5845: PPUSH
5846: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5850: LD_EXP 36
5854: PPUSH
5855: LD_STRING D1b-JMM-1
5857: PPUSH
5858: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5862: LD_EXP 43
5866: PPUSH
5867: LD_STRING D1b-Corn-1
5869: PPUSH
5870: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5874: LD_EXP 36
5878: PPUSH
5879: LD_STRING D1b-JMM-2
5881: PPUSH
5882: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5886: LD_EXP 43
5890: PPUSH
5891: LD_STRING D1b-Corn-2
5893: PPUSH
5894: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5898: LD_EXP 36
5902: PPUSH
5903: LD_STRING D1b-JMM-3
5905: PPUSH
5906: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5910: LD_INT 10
5912: PPUSH
5913: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5917: LD_EXP 45
5921: PPUSH
5922: LD_STRING D1b-Pow-3
5924: PPUSH
5925: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5929: LD_EXP 36
5933: PPUSH
5934: LD_STRING D1b-JMM-4
5936: PPUSH
5937: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5941: LD_EXP 43
5945: PPUSH
5946: LD_STRING D1b-Corn-4
5948: PPUSH
5949: CALL_OW 88
// if Khatam then
5953: LD_EXP 40
5957: IFFALSE 5973
// Say ( Khatam , D1b-Khat-4 ) else
5959: LD_EXP 40
5963: PPUSH
5964: LD_STRING D1b-Khat-4
5966: PPUSH
5967: CALL_OW 88
5971: GO 6009
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
5973: LD_EXP 6
5977: PPUSH
5978: LD_INT 26
5980: PUSH
5981: LD_INT 1
5983: PUSH
5984: EMPTY
5985: LIST
5986: LIST
5987: PPUSH
5988: CALL_OW 72
5992: PUSH
5993: LD_EXP 43
5997: PUSH
5998: EMPTY
5999: LIST
6000: DIFF
6001: PPUSH
6002: LD_STRING D1b-Sol1-4
6004: PPUSH
6005: CALL 625 0 2
// if Cyrus then
6009: LD_EXP 38
6013: IFFALSE 6027
// Say ( Cyrus , D1b-Cyrus-4 ) ;
6015: LD_EXP 38
6019: PPUSH
6020: LD_STRING D1b-Cyrus-4
6022: PPUSH
6023: CALL_OW 88
// if Lisa then
6027: LD_EXP 39
6031: IFFALSE 6089
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6033: LD_EXP 39
6037: PPUSH
6038: LD_STRING D1b-Lisa-4
6040: PPUSH
6041: CALL_OW 88
// if Cyrus then
6045: LD_EXP 38
6049: IFFALSE 6089
// begin if not IsInUnit ( Cyrus ) then
6051: LD_EXP 38
6055: PPUSH
6056: CALL_OW 310
6060: NOT
6061: IFFALSE 6077
// ComTurnUnit ( Cyrus , Lisa ) ;
6063: LD_EXP 38
6067: PPUSH
6068: LD_EXP 39
6072: PPUSH
6073: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6077: LD_EXP 38
6081: PPUSH
6082: LD_STRING D1b-Cyrus-5
6084: PPUSH
6085: CALL_OW 88
// end ; end ; SelectGroup ;
6089: CALL 2578 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6093: LD_EXP 36
6097: PPUSH
6098: LD_STRING D1d-JMM-1
6100: PPUSH
6101: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6105: LD_EXP 43
6109: PPUSH
6110: LD_STRING D1d-Corn-1
6112: PPUSH
6113: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6117: LD_ADDR_VAR 0 2
6121: PUSH
6122: LD_EXP 4
6126: PUSH
6127: LD_EXP 6
6131: ADD
6132: PUSH
6133: LD_EXP 36
6137: ADD
6138: PUSH
6139: FOR_IN
6140: IFFALSE 6153
// ComHold ( i ) ;
6142: LD_VAR 0 2
6146: PPUSH
6147: CALL_OW 140
6151: GO 6139
6153: POP
6154: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6155: LD_ADDR_VAR 0 4
6159: PUSH
6160: LD_INT 22
6162: PUSH
6163: LD_INT 1
6165: PUSH
6166: EMPTY
6167: LIST
6168: LIST
6169: PUSH
6170: LD_INT 21
6172: PUSH
6173: LD_INT 2
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: PUSH
6180: EMPTY
6181: LIST
6182: LIST
6183: PPUSH
6184: CALL_OW 69
6188: ST_TO_ADDR
// if vehicles then
6189: LD_VAR 0 4
6193: IFFALSE 6531
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6195: LD_EXP 6
6199: PPUSH
6200: LD_INT 55
6202: PUSH
6203: EMPTY
6204: LIST
6205: PPUSH
6206: CALL_OW 72
6210: IFFALSE 6249
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6212: LD_ADDR_VAR 0 2
6216: PUSH
6217: LD_EXP 6
6221: PPUSH
6222: LD_INT 55
6224: PUSH
6225: EMPTY
6226: LIST
6227: PPUSH
6228: CALL_OW 72
6232: PUSH
6233: FOR_IN
6234: IFFALSE 6247
// ComExitVehicle ( i ) ;
6236: LD_VAR 0 2
6240: PPUSH
6241: CALL_OW 121
6245: GO 6233
6247: POP
6248: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6249: LD_ADDR_VAR 0 5
6253: PUSH
6254: LD_VAR 0 4
6258: PPUSH
6259: LD_INT 34
6261: PUSH
6262: LD_INT 51
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: PPUSH
6269: CALL_OW 72
6273: ST_TO_ADDR
// if cargos then
6274: LD_VAR 0 5
6278: IFFALSE 6461
// begin vehicles := cargos ;
6280: LD_ADDR_VAR 0 4
6284: PUSH
6285: LD_VAR 0 5
6289: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6290: LD_ADDR_VAR 0 6
6294: PUSH
6295: LD_STRING 02_resources_4
6297: PPUSH
6298: LD_INT 0
6300: PPUSH
6301: CALL_OW 30
6305: ST_TO_ADDR
// if debug and not resources then
6306: LD_EXP 1
6310: PUSH
6311: LD_VAR 0 6
6315: NOT
6316: AND
6317: IFFALSE 6327
// resources := 160 ;
6319: LD_ADDR_VAR 0 6
6323: PUSH
6324: LD_INT 160
6326: ST_TO_ADDR
// if resources mod 10 then
6327: LD_VAR 0 6
6331: PUSH
6332: LD_INT 10
6334: MOD
6335: IFFALSE 6357
// resources := resources - resources mod 10 ;
6337: LD_ADDR_VAR 0 6
6341: PUSH
6342: LD_VAR 0 6
6346: PUSH
6347: LD_VAR 0 6
6351: PUSH
6352: LD_INT 10
6354: MOD
6355: MINUS
6356: ST_TO_ADDR
// if resources then
6357: LD_VAR 0 6
6361: IFFALSE 6461
// for i in cargos do
6363: LD_ADDR_VAR 0 2
6367: PUSH
6368: LD_VAR 0 5
6372: PUSH
6373: FOR_IN
6374: IFFALSE 6459
// begin if resources < 100 then
6376: LD_VAR 0 6
6380: PUSH
6381: LD_INT 100
6383: LESS
6384: IFFALSE 6406
// begin cargo := resources ;
6386: LD_ADDR_VAR 0 7
6390: PUSH
6391: LD_VAR 0 6
6395: ST_TO_ADDR
// resources := 0 ;
6396: LD_ADDR_VAR 0 6
6400: PUSH
6401: LD_INT 0
6403: ST_TO_ADDR
// end else
6404: GO 6428
// begin cargo := 100 ;
6406: LD_ADDR_VAR 0 7
6410: PUSH
6411: LD_INT 100
6413: ST_TO_ADDR
// resources := resources - 100 ;
6414: LD_ADDR_VAR 0 6
6418: PUSH
6419: LD_VAR 0 6
6423: PUSH
6424: LD_INT 100
6426: MINUS
6427: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6428: LD_VAR 0 2
6432: PPUSH
6433: LD_INT 1
6435: PPUSH
6436: LD_VAR 0 7
6440: PPUSH
6441: CALL_OW 290
// if resources = 0 then
6445: LD_VAR 0 6
6449: PUSH
6450: LD_INT 0
6452: EQUAL
6453: IFFALSE 6457
// break ;
6455: GO 6459
// end ;
6457: GO 6373
6459: POP
6460: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6461: LD_VAR 0 4
6465: PUSH
6466: LD_INT 1
6468: ARRAY
6469: PPUSH
6470: CALL_OW 311
6474: PPUSH
6475: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6479: LD_VAR 0 4
6483: PUSH
6484: LD_INT 1
6486: ARRAY
6487: PPUSH
6488: LD_INT 4
6490: PPUSH
6491: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6495: LD_EXP 43
6499: PPUSH
6500: LD_VAR 0 4
6504: PUSH
6505: LD_INT 1
6507: ARRAY
6508: PPUSH
6509: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6513: LD_INT 35
6515: PPUSH
6516: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6520: LD_EXP 43
6524: PPUSH
6525: CALL_OW 310
6529: IFFALSE 6513
// end ; InGameOff ;
6531: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6535: LD_STRING M1
6537: PPUSH
6538: CALL_OW 337
// SaveForQuickRestart ;
6542: CALL_OW 22
// cornel_active := true ;
6546: LD_ADDR_EXP 8
6550: PUSH
6551: LD_INT 1
6553: ST_TO_ADDR
// end ;
6554: LD_VAR 0 1
6558: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns , tmp ;
6559: LD_EXP 36
6563: PPUSH
6564: LD_EXP 46
6568: PPUSH
6569: CALL_OW 296
6573: PUSH
6574: LD_INT 10
6576: LESS
6577: IFFALSE 7934
6579: GO 6581
6581: DISABLE
6582: LD_INT 0
6584: PPUSH
6585: PPUSH
6586: PPUSH
6587: PPUSH
6588: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6589: LD_ADDR_VAR 0 2
6593: PUSH
6594: LD_INT 89
6596: PUSH
6597: LD_INT 34
6599: PUSH
6600: EMPTY
6601: LIST
6602: LIST
6603: PUSH
6604: LD_INT 138
6606: PUSH
6607: LD_INT 63
6609: PUSH
6610: EMPTY
6611: LIST
6612: LIST
6613: PUSH
6614: LD_INT 196
6616: PUSH
6617: LD_INT 84
6619: PUSH
6620: EMPTY
6621: LIST
6622: LIST
6623: PUSH
6624: LD_INT 135
6626: PUSH
6627: LD_INT 52
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: PUSH
6634: LD_INT 103
6636: PUSH
6637: LD_INT 39
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: PUSH
6644: LD_INT 58
6646: PUSH
6647: LD_INT 30
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 38
6656: PUSH
6657: LD_INT 51
6659: PUSH
6660: EMPTY
6661: LIST
6662: LIST
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: LIST
6668: LIST
6669: LIST
6670: LIST
6671: LIST
6672: ST_TO_ADDR
// InGameOn ;
6673: CALL_OW 8
// if jmm_units then
6677: LD_EXP 4
6681: IFFALSE 6757
// for i in jmm_units do
6683: LD_ADDR_VAR 0 1
6687: PUSH
6688: LD_EXP 4
6692: PUSH
6693: FOR_IN
6694: IFFALSE 6755
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6696: LD_VAR 0 1
6700: PPUSH
6701: LD_EXP 36
6705: PPUSH
6706: CALL_OW 296
6710: PUSH
6711: LD_INT 10
6713: LESS
6714: PUSH
6715: LD_VAR 0 1
6719: PPUSH
6720: CALL_OW 310
6724: NOT
6725: AND
6726: IFFALSE 6744
// ComTurnUnit ( i , JMM ) else
6728: LD_VAR 0 1
6732: PPUSH
6733: LD_EXP 36
6737: PPUSH
6738: CALL_OW 119
6742: GO 6753
// ComHold ( i ) ;
6744: LD_VAR 0 1
6748: PPUSH
6749: CALL_OW 140
// end ;
6753: GO 6693
6755: POP
6756: POP
// if IsInUnit ( JMM ) then
6757: LD_EXP 36
6761: PPUSH
6762: CALL_OW 310
6766: IFFALSE 6791
// begin ComExitVehicle ( JMM ) ;
6768: LD_EXP 36
6772: PPUSH
6773: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6777: LD_EXP 36
6781: PPUSH
6782: LD_EXP 46
6786: PPUSH
6787: CALL_OW 172
// end ; Wait ( 10 ) ;
6791: LD_INT 10
6793: PPUSH
6794: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6798: LD_EXP 36
6802: PPUSH
6803: LD_EXP 46
6807: PPUSH
6808: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6812: LD_INT 35
6814: PPUSH
6815: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6819: LD_EXP 36
6823: PPUSH
6824: LD_EXP 46
6828: PPUSH
6829: CALL_OW 296
6833: PUSH
6834: LD_INT 6
6836: LESS
6837: IFFALSE 6812
// ComTurnUnit ( JMM , Lynch ) ;
6839: LD_EXP 36
6843: PPUSH
6844: LD_EXP 46
6848: PPUSH
6849: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6853: LD_ADDR_VAR 0 1
6857: PUSH
6858: LD_EXP 46
6862: PUSH
6863: LD_EXP 47
6867: PUSH
6868: LD_EXP 48
6872: PUSH
6873: LD_EXP 49
6877: PUSH
6878: EMPTY
6879: LIST
6880: LIST
6881: LIST
6882: LIST
6883: PUSH
6884: FOR_IN
6885: IFFALSE 6903
// ComTurnUnit ( i , JMM ) ;
6887: LD_VAR 0 1
6891: PPUSH
6892: LD_EXP 36
6896: PPUSH
6897: CALL_OW 119
6901: GO 6884
6903: POP
6904: POP
// Wait ( 0 0$0.3 ) ;
6905: LD_INT 10
6907: PPUSH
6908: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6912: LD_EXP 36
6916: PPUSH
6917: LD_STRING D2-JMM-1
6919: PPUSH
6920: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6924: LD_EXP 46
6928: PPUSH
6929: LD_STRING D2-Sol1-1
6931: PPUSH
6932: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6936: LD_EXP 36
6940: PPUSH
6941: LD_STRING D2-JMM-2
6943: PPUSH
6944: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6948: LD_EXP 46
6952: PPUSH
6953: LD_STRING D2-Sol1-2
6955: PPUSH
6956: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6960: LD_EXP 36
6964: PPUSH
6965: LD_STRING D2-JMM-3
6967: PPUSH
6968: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
6972: LD_EXP 46
6976: PPUSH
6977: LD_STRING D2-Sol1-3
6979: PPUSH
6980: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6984: LD_ADDR_VAR 0 1
6988: PUSH
6989: LD_INT 22
6991: PUSH
6992: LD_INT 8
6994: PUSH
6995: EMPTY
6996: LIST
6997: LIST
6998: PPUSH
6999: CALL_OW 69
7003: PUSH
7004: FOR_IN
7005: IFFALSE 7021
// SetSide ( i , 1 ) ;
7007: LD_VAR 0 1
7011: PPUSH
7012: LD_INT 1
7014: PPUSH
7015: CALL_OW 235
7019: GO 7004
7021: POP
7022: POP
// Say ( JMM , D2-JMM-4 ) ;
7023: LD_EXP 36
7027: PPUSH
7028: LD_STRING D2-JMM-4
7030: PPUSH
7031: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7035: LD_INT 1
7037: PPUSH
7038: LD_INT 5
7040: PPUSH
7041: CALL_OW 332
// for i = 1 to points do
7045: LD_ADDR_VAR 0 1
7049: PUSH
7050: DOUBLE
7051: LD_INT 1
7053: DEC
7054: ST_TO_ADDR
7055: LD_VAR 0 2
7059: PUSH
7060: FOR_TO
7061: IFFALSE 7236
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7063: LD_VAR 0 2
7067: PUSH
7068: LD_VAR 0 1
7072: ARRAY
7073: PUSH
7074: LD_INT 1
7076: ARRAY
7077: PPUSH
7078: LD_VAR 0 2
7082: PUSH
7083: LD_VAR 0 1
7087: ARRAY
7088: PUSH
7089: LD_INT 2
7091: ARRAY
7092: PPUSH
7093: CALL_OW 84
// if i = 1 then
7097: LD_VAR 0 1
7101: PUSH
7102: LD_INT 1
7104: EQUAL
7105: IFFALSE 7119
// Say ( Lynch , D2-Sol1-4 ) ;
7107: LD_EXP 46
7111: PPUSH
7112: LD_STRING D2-Sol1-4
7114: PPUSH
7115: CALL_OW 88
// if i = 2 then
7119: LD_VAR 0 1
7123: PUSH
7124: LD_INT 2
7126: EQUAL
7127: IFFALSE 7141
// Say ( JMM , D2-JMM-5 ) ;
7129: LD_EXP 36
7133: PPUSH
7134: LD_STRING D2-JMM-5
7136: PPUSH
7137: CALL_OW 88
// if i = 4 then
7141: LD_VAR 0 1
7145: PUSH
7146: LD_INT 4
7148: EQUAL
7149: IFFALSE 7173
// begin RevealFogArea ( 1 , troopsArea ) ;
7151: LD_INT 1
7153: PPUSH
7154: LD_INT 6
7156: PPUSH
7157: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7161: LD_EXP 46
7165: PPUSH
7166: LD_STRING D2-Sol1-5
7168: PPUSH
7169: CALL_OW 88
// end ; if i = 5 then
7173: LD_VAR 0 1
7177: PUSH
7178: LD_INT 5
7180: EQUAL
7181: IFFALSE 7195
// Say ( JMM , D2-JMM-6 ) ;
7183: LD_EXP 36
7187: PPUSH
7188: LD_STRING D2-JMM-6
7190: PPUSH
7191: CALL_OW 88
// if i = 7 then
7195: LD_VAR 0 1
7199: PUSH
7200: LD_INT 7
7202: EQUAL
7203: IFFALSE 7227
// begin RevealFogArea ( 1 , forestArea ) ;
7205: LD_INT 1
7207: PPUSH
7208: LD_INT 7
7210: PPUSH
7211: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7215: LD_EXP 46
7219: PPUSH
7220: LD_STRING D2-Sol1-6
7222: PPUSH
7223: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7227: LD_INT 46
7229: PPUSH
7230: CALL_OW 67
// end ;
7234: GO 7060
7236: POP
7237: POP
// CenterNowOnUnits ( JMM ) ;
7238: LD_EXP 36
7242: PPUSH
7243: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7247: LD_EXP 36
7251: PPUSH
7252: LD_STRING D2-JMM-7
7254: PPUSH
7255: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7259: LD_EXP 46
7263: PPUSH
7264: LD_STRING D2-Sol1-7
7266: PPUSH
7267: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7271: LD_EXP 36
7275: PPUSH
7276: LD_STRING D2-JMM-8
7278: PPUSH
7279: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7283: LD_ADDR_VAR 0 4
7287: PUSH
7288: LD_INT 22
7290: PUSH
7291: LD_INT 1
7293: PUSH
7294: EMPTY
7295: LIST
7296: LIST
7297: PUSH
7298: LD_INT 30
7300: PUSH
7301: LD_INT 31
7303: PUSH
7304: EMPTY
7305: LIST
7306: LIST
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: PPUSH
7312: CALL_OW 69
7316: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7317: LD_EXP 46
7321: PPUSH
7322: LD_VAR 0 4
7326: PUSH
7327: LD_INT 1
7329: ARRAY
7330: PPUSH
7331: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7335: LD_INT 65
7337: PPUSH
7338: LD_INT 101
7340: PPUSH
7341: CALL_OW 428
7345: IFFALSE 7368
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7347: LD_INT 65
7349: PPUSH
7350: LD_INT 101
7352: PPUSH
7353: CALL_OW 428
7357: PPUSH
7358: LD_INT 75
7360: PPUSH
7361: LD_INT 100
7363: PPUSH
7364: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7368: LD_INT 66
7370: PPUSH
7371: LD_INT 103
7373: PPUSH
7374: CALL_OW 428
7378: IFFALSE 7401
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7380: LD_INT 66
7382: PPUSH
7383: LD_INT 103
7385: PPUSH
7386: CALL_OW 428
7390: PPUSH
7391: LD_INT 75
7393: PPUSH
7394: LD_INT 100
7396: PPUSH
7397: CALL_OW 111
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_dist , JMM , 7 ] ] ) ;
7401: LD_ADDR_VAR 0 5
7405: PUSH
7406: LD_INT 22
7408: PUSH
7409: LD_INT 1
7411: PUSH
7412: EMPTY
7413: LIST
7414: LIST
7415: PUSH
7416: LD_INT 21
7418: PUSH
7419: LD_INT 2
7421: PUSH
7422: EMPTY
7423: LIST
7424: LIST
7425: PUSH
7426: LD_INT 91
7428: PUSH
7429: LD_EXP 36
7433: PUSH
7434: LD_INT 7
7436: PUSH
7437: EMPTY
7438: LIST
7439: LIST
7440: LIST
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: PPUSH
7447: CALL_OW 69
7451: ST_TO_ADDR
// if tmp then
7452: LD_VAR 0 5
7456: IFFALSE 7473
// ComMoveXY ( tmp , 75 , 100 ) ;
7458: LD_VAR 0 5
7462: PPUSH
7463: LD_INT 75
7465: PPUSH
7466: LD_INT 100
7468: PPUSH
7469: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7473: LD_ADDR_VAR 0 3
7477: PUSH
7478: LD_EXP 4
7482: PPUSH
7483: LD_INT 25
7485: PUSH
7486: LD_INT 1
7488: PUSH
7489: EMPTY
7490: LIST
7491: LIST
7492: PPUSH
7493: CALL_OW 72
7497: PPUSH
7498: LD_EXP 36
7502: PPUSH
7503: CALL_OW 74
7507: ST_TO_ADDR
// if sol then
7508: LD_VAR 0 3
7512: IFFALSE 7552
// if GetDistUnits ( JMM , sol ) < 10 then
7514: LD_EXP 36
7518: PPUSH
7519: LD_VAR 0 3
7523: PPUSH
7524: CALL_OW 296
7528: PUSH
7529: LD_INT 10
7531: LESS
7532: IFFALSE 7552
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7534: LD_VAR 0 3
7538: PPUSH
7539: LD_VAR 0 4
7543: PUSH
7544: LD_INT 2
7546: ARRAY
7547: PPUSH
7548: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7552: LD_INT 10
7554: PPUSH
7555: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7559: LD_EXP 36
7563: PPUSH
7564: LD_INT 65
7566: PPUSH
7567: LD_INT 101
7569: PPUSH
7570: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7574: LD_EXP 36
7578: PPUSH
7579: LD_INT 63
7581: PPUSH
7582: LD_INT 100
7584: PPUSH
7585: CALL_OW 178
// tmp := 0 0$0 ;
7589: LD_ADDR_VAR 0 5
7593: PUSH
7594: LD_INT 0
7596: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7597: LD_INT 35
7599: PPUSH
7600: CALL_OW 67
// tmp := tmp + 0 0$1 ;
7604: LD_ADDR_VAR 0 5
7608: PUSH
7609: LD_VAR 0 5
7613: PUSH
7614: LD_INT 35
7616: PLUS
7617: ST_TO_ADDR
// until IsAt ( JMM , 65 , 101 ) or tmp > 0 0$5 ;
7618: LD_EXP 36
7622: PPUSH
7623: LD_INT 65
7625: PPUSH
7626: LD_INT 101
7628: PPUSH
7629: CALL_OW 307
7633: PUSH
7634: LD_VAR 0 5
7638: PUSH
7639: LD_INT 175
7641: GREATER
7642: OR
7643: IFFALSE 7597
// Say ( JMM , D2a-JMM-1 ) ;
7645: LD_EXP 36
7649: PPUSH
7650: LD_STRING D2a-JMM-1
7652: PPUSH
7653: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7657: LD_EXP 47
7661: PPUSH
7662: LD_INT 66
7664: PPUSH
7665: LD_INT 103
7667: PPUSH
7668: CALL_OW 111
// tmp := 0 0$0 ;
7672: LD_ADDR_VAR 0 5
7676: PUSH
7677: LD_INT 0
7679: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7680: LD_INT 35
7682: PPUSH
7683: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) or tmp > 0 0$5 ;
7687: LD_EXP 47
7691: PPUSH
7692: LD_INT 66
7694: PPUSH
7695: LD_INT 103
7697: PPUSH
7698: CALL_OW 307
7702: PUSH
7703: LD_VAR 0 5
7707: PUSH
7708: LD_INT 175
7710: GREATER
7711: OR
7712: IFFALSE 7680
// ComTurnUnit ( Walker , JMM ) ;
7714: LD_EXP 47
7718: PPUSH
7719: LD_EXP 36
7723: PPUSH
7724: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7728: LD_EXP 47
7732: PPUSH
7733: LD_STRING D2a-Sci1-1
7735: PPUSH
7736: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7740: LD_EXP 36
7744: PPUSH
7745: LD_EXP 47
7749: PPUSH
7750: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7754: LD_EXP 36
7758: PPUSH
7759: LD_STRING D2a-JMM-2
7761: PPUSH
7762: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7766: LD_EXP 47
7770: PPUSH
7771: LD_STRING D2a-Sci1-2
7773: PPUSH
7774: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7778: LD_EXP 36
7782: PPUSH
7783: LD_STRING D2a-JMM-3
7785: PPUSH
7786: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7790: LD_EXP 47
7794: PPUSH
7795: LD_STRING D2a-Sci1-3
7797: PPUSH
7798: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7802: LD_ADDR_EXP 4
7806: PUSH
7807: LD_EXP 4
7811: PUSH
7812: LD_EXP 46
7816: PUSH
7817: LD_EXP 47
7821: PUSH
7822: LD_EXP 48
7826: PUSH
7827: LD_EXP 49
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: LIST
7836: LIST
7837: ADD
7838: ST_TO_ADDR
// for i in jmm_units do
7839: LD_ADDR_VAR 0 1
7843: PUSH
7844: LD_EXP 4
7848: PUSH
7849: FOR_IN
7850: IFFALSE 7875
// if not IsInUnit ( i ) then
7852: LD_VAR 0 1
7856: PPUSH
7857: CALL_OW 310
7861: NOT
7862: IFFALSE 7873
// ComFree ( i ) ;
7864: LD_VAR 0 1
7868: PPUSH
7869: CALL_OW 139
7873: GO 7849
7875: POP
7876: POP
// InGameOff ;
7877: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
7881: LD_STRING MSolar1
7883: PPUSH
7884: CALL_OW 337
// jmm_on_west := true ;
7888: LD_ADDR_EXP 5
7892: PUSH
7893: LD_INT 1
7895: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7896: LD_INT 1050
7898: PPUSH
7899: CALL_OW 67
// frank_can_return := true ;
7903: LD_ADDR_EXP 12
7907: PUSH
7908: LD_INT 1
7910: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7911: LD_INT 6300
7913: PPUSH
7914: LD_INT 8400
7916: PPUSH
7917: CALL_OW 12
7921: PPUSH
7922: CALL_OW 67
// send_spec_patrol := true ;
7926: LD_ADDR_EXP 29
7930: PUSH
7931: LD_INT 1
7933: ST_TO_ADDR
// end ;
7934: PPOPN 5
7936: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7937: LD_INT 22
7939: PUSH
7940: LD_INT 1
7942: PUSH
7943: EMPTY
7944: LIST
7945: LIST
7946: PUSH
7947: LD_INT 34
7949: PUSH
7950: LD_INT 51
7952: PUSH
7953: EMPTY
7954: LIST
7955: LIST
7956: PUSH
7957: LD_INT 92
7959: PUSH
7960: LD_INT 63
7962: PUSH
7963: LD_INT 100
7965: PUSH
7966: LD_INT 5
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: LIST
7979: PUSH
7980: EMPTY
7981: LIST
7982: PPUSH
7983: CALL_OW 69
7987: PUSH
7988: LD_EXP 5
7992: NOT
7993: AND
7994: IFFALSE 8107
7996: GO 7998
7998: DISABLE
7999: LD_INT 0
8001: PPUSH
8002: PPUSH
// begin enable ;
8003: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
8004: LD_ADDR_VAR 0 2
8008: PUSH
8009: LD_INT 22
8011: PUSH
8012: LD_INT 1
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: PUSH
8019: LD_INT 34
8021: PUSH
8022: LD_INT 51
8024: PUSH
8025: EMPTY
8026: LIST
8027: LIST
8028: PUSH
8029: LD_INT 92
8031: PUSH
8032: LD_INT 63
8034: PUSH
8035: LD_INT 100
8037: PUSH
8038: LD_INT 5
8040: PUSH
8041: EMPTY
8042: LIST
8043: LIST
8044: LIST
8045: LIST
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: LIST
8051: PUSH
8052: EMPTY
8053: LIST
8054: PPUSH
8055: CALL_OW 69
8059: ST_TO_ADDR
// if not filter then
8060: LD_VAR 0 2
8064: NOT
8065: IFFALSE 8069
// exit ;
8067: GO 8107
// for i in filter do
8069: LD_ADDR_VAR 0 1
8073: PUSH
8074: LD_VAR 0 2
8078: PUSH
8079: FOR_IN
8080: IFFALSE 8105
// begin SetFuel ( i , 0 ) ;
8082: LD_VAR 0 1
8086: PPUSH
8087: LD_INT 0
8089: PPUSH
8090: CALL_OW 240
// ComStop ( i ) ;
8094: LD_VAR 0 1
8098: PPUSH
8099: CALL_OW 141
// end ;
8103: GO 8079
8105: POP
8106: POP
// end ;
8107: PPOPN 2
8109: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
8110: LD_EXP 29
8114: IFFALSE 9107
8116: GO 8118
8118: DISABLE
8119: LD_INT 0
8121: PPUSH
8122: PPUSH
8123: PPUSH
8124: PPUSH
8125: PPUSH
8126: PPUSH
8127: PPUSH
// begin if not ru_spec_patrol then
8128: LD_EXP 53
8132: NOT
8133: IFFALSE 8137
// exit ;
8135: GO 9107
// dead1 := false ;
8137: LD_ADDR_VAR 0 1
8141: PUSH
8142: LD_INT 0
8144: ST_TO_ADDR
// dead2 := false ;
8145: LD_ADDR_VAR 0 2
8149: PUSH
8150: LD_INT 0
8152: ST_TO_ADDR
// inarea1 := false ;
8153: LD_ADDR_VAR 0 3
8157: PUSH
8158: LD_INT 0
8160: ST_TO_ADDR
// inarea2 := false ;
8161: LD_ADDR_VAR 0 4
8165: PUSH
8166: LD_INT 0
8168: ST_TO_ADDR
// tmp := [ ] ;
8169: LD_ADDR_VAR 0 6
8173: PUSH
8174: EMPTY
8175: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8176: LD_EXP 53
8180: PPUSH
8181: LD_INT 75
8183: PPUSH
8184: LD_INT 101
8186: PPUSH
8187: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8191: LD_INT 35
8193: PPUSH
8194: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8198: LD_INT 1
8200: PPUSH
8201: LD_EXP 53
8205: PUSH
8206: LD_INT 1
8208: ARRAY
8209: PPUSH
8210: CALL_OW 292
8214: IFFALSE 8191
// ComStop ( ru_spec_patrol ) ;
8216: LD_EXP 53
8220: PPUSH
8221: CALL_OW 141
// Wait ( 0 0$02 ) ;
8225: LD_INT 70
8227: PPUSH
8228: CALL_OW 67
// DialogueOn ;
8232: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8236: LD_EXP 53
8240: PUSH
8241: LD_INT 1
8243: ARRAY
8244: PPUSH
8245: LD_STRING D8-Rus1-1
8247: PPUSH
8248: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8252: LD_EXP 36
8256: PPUSH
8257: LD_STRING D8-JMM-1
8259: PPUSH
8260: CALL_OW 88
// DialogueOff ;
8264: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8268: LD_EXP 53
8272: PPUSH
8273: LD_INT 13
8275: PPUSH
8276: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8280: LD_INT 35
8282: PPUSH
8283: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8287: LD_VAR 0 1
8291: NOT
8292: PUSH
8293: LD_EXP 53
8297: PUSH
8298: LD_INT 1
8300: ARRAY
8301: PPUSH
8302: CALL_OW 301
8306: AND
8307: IFFALSE 8317
// dead1 := true ;
8309: LD_ADDR_VAR 0 1
8313: PUSH
8314: LD_INT 1
8316: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8317: LD_VAR 0 2
8321: NOT
8322: PUSH
8323: LD_EXP 53
8327: PUSH
8328: LD_INT 2
8330: ARRAY
8331: PPUSH
8332: CALL_OW 301
8336: AND
8337: IFFALSE 8347
// dead2 := true ;
8339: LD_ADDR_VAR 0 2
8343: PUSH
8344: LD_INT 1
8346: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8347: LD_VAR 0 3
8351: NOT
8352: PUSH
8353: LD_EXP 53
8357: PUSH
8358: LD_INT 1
8360: ARRAY
8361: PPUSH
8362: LD_INT 14
8364: PPUSH
8365: CALL_OW 308
8369: AND
8370: IFFALSE 8380
// inarea1 := true ;
8372: LD_ADDR_VAR 0 3
8376: PUSH
8377: LD_INT 1
8379: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8380: LD_VAR 0 4
8384: NOT
8385: PUSH
8386: LD_EXP 53
8390: PUSH
8391: LD_INT 2
8393: ARRAY
8394: PPUSH
8395: LD_INT 14
8397: PPUSH
8398: CALL_OW 308
8402: AND
8403: IFFALSE 8413
// inarea2 := true ;
8405: LD_ADDR_VAR 0 4
8409: PUSH
8410: LD_INT 1
8412: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8413: LD_VAR 0 1
8417: PUSH
8418: LD_VAR 0 2
8422: AND
8423: PUSH
8424: LD_VAR 0 1
8428: PUSH
8429: LD_VAR 0 4
8433: AND
8434: OR
8435: PUSH
8436: LD_VAR 0 2
8440: PUSH
8441: LD_VAR 0 3
8445: AND
8446: OR
8447: PUSH
8448: LD_VAR 0 3
8452: PUSH
8453: LD_VAR 0 4
8457: AND
8458: OR
8459: IFFALSE 8280
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8461: LD_VAR 0 3
8465: PUSH
8466: LD_VAR 0 4
8470: AND
8471: PUSH
8472: LD_VAR 0 1
8476: PUSH
8477: LD_VAR 0 4
8481: AND
8482: OR
8483: PUSH
8484: LD_VAR 0 2
8488: PUSH
8489: LD_VAR 0 3
8493: AND
8494: OR
8495: IFFALSE 9087
// begin prepare_siege := true ;
8497: LD_ADDR_EXP 30
8501: PUSH
8502: LD_INT 1
8504: ST_TO_ADDR
// DialogueOn ;
8505: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8509: LD_VAR 0 3
8513: PUSH
8514: LD_VAR 0 4
8518: AND
8519: IFFALSE 8535
// Say ( JMM , D8b-JMM-1a ) else
8521: LD_EXP 36
8525: PPUSH
8526: LD_STRING D8b-JMM-1a
8528: PPUSH
8529: CALL_OW 88
8533: GO 8547
// Say ( JMM , D8b-JMM-1 ) ;
8535: LD_EXP 36
8539: PPUSH
8540: LD_STRING D8b-JMM-1
8542: PPUSH
8543: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8547: LD_EXP 4
8551: PPUSH
8552: LD_INT 26
8554: PUSH
8555: LD_INT 1
8557: PUSH
8558: EMPTY
8559: LIST
8560: LIST
8561: PPUSH
8562: CALL_OW 72
8566: PUSH
8567: LD_EXP 37
8571: PUSH
8572: LD_EXP 38
8576: PUSH
8577: LD_EXP 47
8581: PUSH
8582: LD_EXP 50
8586: PUSH
8587: EMPTY
8588: LIST
8589: LIST
8590: LIST
8591: LIST
8592: DIFF
8593: PPUSH
8594: LD_STRING D8b-Sol1-1
8596: PPUSH
8597: CALL 625 0 2
// if Cyrus and Cyrus in jmm_units then
8601: LD_EXP 38
8605: PUSH
8606: LD_EXP 38
8610: PUSH
8611: LD_EXP 4
8615: IN
8616: AND
8617: IFFALSE 8633
// Say ( Cyrus , D8b-Cyrus-1 ) else
8619: LD_EXP 38
8623: PPUSH
8624: LD_STRING D8b-Cyrus-1
8626: PPUSH
8627: CALL_OW 88
8631: GO 8645
// Say ( JMM , D8b-JMM-1a ) ;
8633: LD_EXP 36
8637: PPUSH
8638: LD_STRING D8b-JMM-1a
8640: PPUSH
8641: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8645: LD_EXP 39
8649: PUSH
8650: LD_EXP 39
8654: PUSH
8655: LD_EXP 4
8659: IN
8660: AND
8661: IFFALSE 8675
// Say ( Lisa , D8b-Lisa-2 ) ;
8663: LD_EXP 39
8667: PPUSH
8668: LD_STRING D8b-Lisa-2
8670: PPUSH
8671: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8675: LD_EXP 37
8679: PUSH
8680: LD_EXP 37
8684: PUSH
8685: LD_EXP 4
8689: IN
8690: AND
8691: IFFALSE 8707
// Say ( Bobby , D8b-Bobby-1 ) else
8693: LD_EXP 37
8697: PPUSH
8698: LD_STRING D8b-Bobby-1
8700: PPUSH
8701: CALL_OW 88
8705: GO 8767
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8707: LD_ADDR_VAR 0 5
8711: PUSH
8712: LD_EXP 4
8716: PPUSH
8717: LD_INT 26
8719: PUSH
8720: LD_INT 1
8722: PUSH
8723: EMPTY
8724: LIST
8725: LIST
8726: PPUSH
8727: CALL_OW 72
8731: PUSH
8732: LD_EXP 37
8736: PUSH
8737: LD_EXP 38
8741: PUSH
8742: LD_EXP 47
8746: PUSH
8747: LD_EXP 50
8751: PUSH
8752: EMPTY
8753: LIST
8754: LIST
8755: LIST
8756: LIST
8757: DIFF
8758: PPUSH
8759: LD_STRING D8b-Sol2-1
8761: PPUSH
8762: CALL 625 0 2
8766: ST_TO_ADDR
// DialogueOff ;
8767: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8771: LD_EXP 38
8775: PUSH
8776: LD_EXP 38
8780: PUSH
8781: LD_EXP 4
8785: IN
8786: AND
8787: IFFALSE 8812
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8789: LD_ADDR_VAR 0 6
8793: PUSH
8794: LD_VAR 0 6
8798: PPUSH
8799: LD_INT 1
8801: PPUSH
8802: LD_EXP 38
8806: PPUSH
8807: CALL_OW 2
8811: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8812: LD_EXP 37
8816: PUSH
8817: LD_EXP 37
8821: PUSH
8822: LD_EXP 4
8826: IN
8827: AND
8828: IFFALSE 8853
// tmp := Insert ( tmp , 1 , Bobby ) ;
8830: LD_ADDR_VAR 0 6
8834: PUSH
8835: LD_VAR 0 6
8839: PPUSH
8840: LD_INT 1
8842: PPUSH
8843: LD_EXP 37
8847: PPUSH
8848: CALL_OW 2
8852: ST_TO_ADDR
// if sol then
8853: LD_VAR 0 5
8857: IFFALSE 8882
// tmp := Insert ( tmp , 1 , sol ) ;
8859: LD_ADDR_VAR 0 6
8863: PUSH
8864: LD_VAR 0 6
8868: PPUSH
8869: LD_INT 1
8871: PPUSH
8872: LD_VAR 0 5
8876: PPUSH
8877: CALL_OW 2
8881: ST_TO_ADDR
// if tmp then
8882: LD_VAR 0 6
8886: IFFALSE 9046
// begin SetSide ( tmp , 8 ) ;
8888: LD_VAR 0 6
8892: PPUSH
8893: LD_INT 8
8895: PPUSH
8896: CALL_OW 235
// ComFree ( tmp ) ;
8900: LD_VAR 0 6
8904: PPUSH
8905: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8909: LD_VAR 0 6
8913: PPUSH
8914: LD_INT 15
8916: PPUSH
8917: CALL_OW 173
// AddComHold ( tmp ) ;
8921: LD_VAR 0 6
8925: PPUSH
8926: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8930: LD_INT 35
8932: PPUSH
8933: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
8937: LD_VAR 0 6
8941: PUSH
8942: LD_INT 1
8944: ARRAY
8945: PPUSH
8946: CALL_OW 314
8950: NOT
8951: IFFALSE 8965
// ComMoveToArea ( tmp , cyrusEscape ) ;
8953: LD_VAR 0 6
8957: PPUSH
8958: LD_INT 15
8960: PPUSH
8961: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8965: LD_VAR 0 6
8969: PUSH
8970: LD_INT 1
8972: ARRAY
8973: PPUSH
8974: LD_INT 15
8976: PPUSH
8977: CALL_OW 308
8981: IFFALSE 9036
// begin RemoveUnit ( tmp [ 1 ] ) ;
8983: LD_VAR 0 6
8987: PUSH
8988: LD_INT 1
8990: ARRAY
8991: PPUSH
8992: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
8996: LD_ADDR_EXP 4
9000: PUSH
9001: LD_EXP 4
9005: PUSH
9006: LD_VAR 0 6
9010: PUSH
9011: LD_INT 1
9013: ARRAY
9014: DIFF
9015: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
9016: LD_ADDR_VAR 0 6
9020: PUSH
9021: LD_VAR 0 6
9025: PUSH
9026: LD_VAR 0 6
9030: PUSH
9031: LD_INT 1
9033: ARRAY
9034: DIFF
9035: ST_TO_ADDR
// end ; until tmp = 0 ;
9036: LD_VAR 0 6
9040: PUSH
9041: LD_INT 0
9043: EQUAL
9044: IFFALSE 8930
// end ; Wait ( 0 0$30 ) ;
9046: LD_INT 1050
9048: PPUSH
9049: CALL_OW 67
// if ru_spec_patrol then
9053: LD_EXP 53
9057: IFFALSE 9085
// for i in ru_spec_patrol do
9059: LD_ADDR_VAR 0 7
9063: PUSH
9064: LD_EXP 53
9068: PUSH
9069: FOR_IN
9070: IFFALSE 9083
// RemoveUnit ( i ) ;
9072: LD_VAR 0 7
9076: PPUSH
9077: CALL_OW 64
9081: GO 9069
9083: POP
9084: POP
// end else
9085: GO 9107
// begin prepare_siege := false ;
9087: LD_ADDR_EXP 30
9091: PUSH
9092: LD_INT 0
9094: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
9095: LD_EXP 36
9099: PPUSH
9100: LD_STRING D8a-JMM-1
9102: PPUSH
9103: CALL_OW 88
// end ; end ;
9107: PPOPN 7
9109: END
// every 0 0$10 trigger frank_can_return do var i , p , points ;
9110: LD_EXP 12
9114: IFFALSE 10313
9116: GO 9118
9118: DISABLE
9119: LD_INT 0
9121: PPUSH
9122: PPUSH
9123: PPUSH
// begin uc_side := 8 ;
9124: LD_ADDR_OWVAR 20
9128: PUSH
9129: LD_INT 8
9131: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
9132: LD_ADDR_VAR 0 3
9136: PUSH
9137: LD_INT 59
9139: PUSH
9140: LD_INT 71
9142: PUSH
9143: EMPTY
9144: LIST
9145: LIST
9146: PUSH
9147: LD_INT 122
9149: PUSH
9150: LD_INT 117
9152: PUSH
9153: EMPTY
9154: LIST
9155: LIST
9156: PUSH
9157: EMPTY
9158: LIST
9159: LIST
9160: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9161: LD_ADDR_EXP 50
9165: PUSH
9166: LD_STRING Frank
9168: PPUSH
9169: LD_INT 0
9171: PPUSH
9172: CALL 474 0 2
9176: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9177: LD_ADDR_VAR 0 1
9181: PUSH
9182: LD_INT 1
9184: PPUSH
9185: LD_INT 2
9187: PPUSH
9188: CALL_OW 12
9192: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9193: LD_EXP 50
9197: PPUSH
9198: LD_VAR 0 3
9202: PUSH
9203: LD_VAR 0 1
9207: ARRAY
9208: PUSH
9209: LD_INT 1
9211: ARRAY
9212: PPUSH
9213: LD_VAR 0 3
9217: PUSH
9218: LD_VAR 0 1
9222: ARRAY
9223: PUSH
9224: LD_INT 2
9226: ARRAY
9227: PPUSH
9228: LD_INT 0
9230: PPUSH
9231: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9235: LD_EXP 50
9239: PPUSH
9240: LD_INT 1
9242: PPUSH
9243: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9247: LD_INT 35
9249: PPUSH
9250: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
9254: LD_EXP 50
9258: PPUSH
9259: LD_EXP 36
9263: PPUSH
9264: CALL_OW 296
9268: PUSH
9269: LD_INT 8
9271: LESS
9272: IFFALSE 9247
// InGameOn ;
9274: CALL_OW 8
// CenterOnUnits ( JMM ) ;
9278: LD_EXP 36
9282: PPUSH
9283: CALL_OW 85
// if IsInUnit ( JMM ) then
9287: LD_EXP 36
9291: PPUSH
9292: CALL_OW 310
9296: IFFALSE 9307
// ComFree ( JMM ) ;
9298: LD_EXP 36
9302: PPUSH
9303: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9307: LD_EXP 36
9311: PPUSH
9312: LD_EXP 50
9316: PPUSH
9317: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9321: LD_EXP 50
9325: PPUSH
9326: LD_EXP 36
9330: PPUSH
9331: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9335: LD_EXP 36
9339: PPUSH
9340: LD_STRING D6-JMM-1
9342: PPUSH
9343: CALL_OW 88
// p := 0 ;
9347: LD_ADDR_VAR 0 2
9351: PUSH
9352: LD_INT 0
9354: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9355: LD_INT 35
9357: PPUSH
9358: CALL_OW 67
// p := p + 1 ;
9362: LD_ADDR_VAR 0 2
9366: PUSH
9367: LD_VAR 0 2
9371: PUSH
9372: LD_INT 1
9374: PLUS
9375: ST_TO_ADDR
// until GetDistUnits ( JMM , Frank ) < 8 or p > 7 ;
9376: LD_EXP 36
9380: PPUSH
9381: LD_EXP 50
9385: PPUSH
9386: CALL_OW 296
9390: PUSH
9391: LD_INT 8
9393: LESS
9394: PUSH
9395: LD_VAR 0 2
9399: PUSH
9400: LD_INT 7
9402: GREATER
9403: OR
9404: IFFALSE 9355
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9406: LD_EXP 39
9410: PUSH
9411: LD_EXP 39
9415: PPUSH
9416: LD_EXP 50
9420: PPUSH
9421: CALL_OW 296
9425: PUSH
9426: LD_INT 20
9428: LESS
9429: AND
9430: IFFALSE 9455
// begin ComFree ( Lisa ) ;
9432: LD_EXP 39
9436: PPUSH
9437: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9441: LD_EXP 39
9445: PPUSH
9446: LD_EXP 50
9450: PPUSH
9451: CALL_OW 172
// end ; if Lynch then
9455: LD_EXP 46
9459: IFFALSE 9484
// begin ComFree ( Lynch ) ;
9461: LD_EXP 46
9465: PPUSH
9466: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9470: LD_EXP 46
9474: PPUSH
9475: LD_EXP 50
9479: PPUSH
9480: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9484: LD_EXP 36
9488: PPUSH
9489: LD_EXP 50
9493: PPUSH
9494: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9498: LD_EXP 50
9502: PPUSH
9503: LD_EXP 36
9507: PPUSH
9508: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9512: LD_EXP 50
9516: PPUSH
9517: LD_STRING D6-Frank-1
9519: PPUSH
9520: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9524: LD_INT 69
9526: PPUSH
9527: LD_INT 20
9529: PPUSH
9530: LD_INT 1
9532: PPUSH
9533: LD_INT 20
9535: NEG
9536: PPUSH
9537: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9541: LD_INT 69
9543: PPUSH
9544: LD_INT 20
9546: PPUSH
9547: LD_INT 1
9549: PPUSH
9550: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9554: LD_INT 190
9556: PPUSH
9557: LD_INT 31
9559: PPUSH
9560: LD_INT 1
9562: PPUSH
9563: LD_INT 20
9565: NEG
9566: PPUSH
9567: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9571: LD_INT 190
9573: PPUSH
9574: LD_INT 31
9576: PPUSH
9577: LD_INT 1
9579: PPUSH
9580: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9584: LD_INT 69
9586: PPUSH
9587: LD_INT 20
9589: PPUSH
9590: CALL_OW 84
// Wait ( 0 0$02 ) ;
9594: LD_INT 70
9596: PPUSH
9597: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9601: LD_EXP 36
9605: PPUSH
9606: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9610: LD_EXP 39
9614: PUSH
9615: LD_EXP 39
9619: PPUSH
9620: LD_EXP 50
9624: PPUSH
9625: CALL_OW 296
9629: PUSH
9630: LD_INT 20
9632: LESS
9633: AND
9634: PUSH
9635: LD_EXP 39
9639: PPUSH
9640: CALL_OW 302
9644: AND
9645: IFFALSE 9767
// begin ComFree ( Lisa ) ;
9647: LD_EXP 39
9651: PPUSH
9652: CALL_OW 139
// p := 0 ;
9656: LD_ADDR_VAR 0 2
9660: PUSH
9661: LD_INT 0
9663: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9664: LD_INT 35
9666: PPUSH
9667: CALL_OW 67
// p := p + 1 ;
9671: LD_ADDR_VAR 0 2
9675: PUSH
9676: LD_VAR 0 2
9680: PUSH
9681: LD_INT 1
9683: PLUS
9684: ST_TO_ADDR
// until GetDistUnits ( Lisa , Frank ) < 7 or p > 7 ;
9685: LD_EXP 39
9689: PPUSH
9690: LD_EXP 50
9694: PPUSH
9695: CALL_OW 296
9699: PUSH
9700: LD_INT 7
9702: LESS
9703: PUSH
9704: LD_VAR 0 2
9708: PUSH
9709: LD_INT 7
9711: GREATER
9712: OR
9713: IFFALSE 9664
// Say ( Lisa , D6-Lisa-1 ) ;
9715: LD_EXP 39
9719: PPUSH
9720: LD_STRING D6-Lisa-1
9722: PPUSH
9723: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9727: LD_EXP 39
9731: PPUSH
9732: LD_EXP 50
9736: PPUSH
9737: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9741: LD_EXP 50
9745: PPUSH
9746: LD_EXP 39
9750: PPUSH
9751: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9755: LD_EXP 50
9759: PPUSH
9760: LD_STRING D6-Frank-2
9762: PPUSH
9763: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9767: LD_EXP 46
9771: PUSH
9772: LD_EXP 46
9776: PPUSH
9777: LD_EXP 50
9781: PPUSH
9782: CALL_OW 296
9786: PUSH
9787: LD_INT 20
9789: LESS
9790: AND
9791: PUSH
9792: LD_EXP 46
9796: PPUSH
9797: CALL_OW 302
9801: AND
9802: IFFALSE 9983
// begin ComTurnUnit ( Lynch , JMM ) ;
9804: LD_EXP 46
9808: PPUSH
9809: LD_EXP 36
9813: PPUSH
9814: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9818: LD_EXP 50
9822: PPUSH
9823: LD_EXP 36
9827: PPUSH
9828: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9832: LD_EXP 46
9836: PPUSH
9837: LD_STRING D6-Sol1-2
9839: PPUSH
9840: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9844: LD_EXP 36
9848: PPUSH
9849: LD_STRING D6-JMM-2
9851: PPUSH
9852: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9856: LD_EXP 50
9860: PPUSH
9861: LD_STRING D6-Frank-3
9863: PPUSH
9864: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9868: LD_EXP 36
9872: PPUSH
9873: LD_STRING D6-JMM-3
9875: PPUSH
9876: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9880: LD_EXP 50
9884: PPUSH
9885: LD_STRING D6-Frank-4
9887: PPUSH
9888: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9892: LD_EXP 50
9896: PPUSH
9897: LD_STRING D6-Frank-4a
9899: PPUSH
9900: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9904: LD_EXP 36
9908: PPUSH
9909: LD_STRING D6-JMM-4
9911: PPUSH
9912: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9916: LD_EXP 50
9920: PPUSH
9921: LD_STRING D6-Frank-5
9923: PPUSH
9924: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9928: LD_EXP 39
9932: PUSH
9933: LD_EXP 39
9937: PPUSH
9938: CALL_OW 302
9942: AND
9943: IFFALSE 9957
// Say ( Lisa , D6-Lisa-5 ) ;
9945: LD_EXP 39
9949: PPUSH
9950: LD_STRING D6-Lisa-5
9952: PPUSH
9953: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9957: LD_EXP 50
9961: PPUSH
9962: LD_STRING D6-Frank-6
9964: PPUSH
9965: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9969: LD_EXP 36
9973: PPUSH
9974: LD_STRING D6-JMM-6
9976: PPUSH
9977: CALL_OW 88
// end else
9981: GO 10098
// begin ComTurnUnit ( Frank , JMM ) ;
9983: LD_EXP 50
9987: PPUSH
9988: LD_EXP 36
9992: PPUSH
9993: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
9997: LD_EXP 50
10001: PPUSH
10002: LD_STRING D6-Frank-4
10004: PPUSH
10005: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10009: LD_EXP 50
10013: PPUSH
10014: LD_STRING D6-Frank-4a
10016: PPUSH
10017: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10021: LD_EXP 36
10025: PPUSH
10026: LD_STRING D6-JMM-4
10028: PPUSH
10029: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10033: LD_EXP 50
10037: PPUSH
10038: LD_STRING D6-Frank-5
10040: PPUSH
10041: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10045: LD_EXP 39
10049: PUSH
10050: LD_EXP 39
10054: PPUSH
10055: CALL_OW 302
10059: AND
10060: IFFALSE 10074
// Say ( Lisa , D6-Lisa-5 ) ;
10062: LD_EXP 39
10066: PPUSH
10067: LD_STRING D6-Lisa-5
10069: PPUSH
10070: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10074: LD_EXP 50
10078: PPUSH
10079: LD_STRING D6-Frank-6
10081: PPUSH
10082: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10086: LD_EXP 36
10090: PPUSH
10091: LD_STRING D6-JMM-6
10093: PPUSH
10094: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
10098: LD_STRING Q1
10100: PPUSH
10101: CALL_OW 97
10105: PUSH
10106: LD_INT 1
10108: DOUBLE
10109: EQUAL
10110: IFTRUE 10114
10112: GO 10125
10114: POP
// frank_send_to_scout := true ; 2 :
10115: LD_ADDR_EXP 14
10119: PUSH
10120: LD_INT 1
10122: ST_TO_ADDR
10123: GO 10145
10125: LD_INT 2
10127: DOUBLE
10128: EQUAL
10129: IFTRUE 10133
10131: GO 10144
10133: POP
// frank_send_to_scout := false ; end ;
10134: LD_ADDR_EXP 14
10138: PUSH
10139: LD_INT 0
10141: ST_TO_ADDR
10142: GO 10145
10144: POP
// InGameOff ;
10145: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
10149: LD_EXP 36
10153: PUSH
10154: LD_EXP 39
10158: PUSH
10159: LD_EXP 46
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: LIST
10168: PPUSH
10169: CALL_OW 139
// if frank_send_to_scout then
10173: LD_EXP 14
10177: IFFALSE 10234
// begin ComMoveXY ( Frank , 130 , 123 ) ;
10179: LD_EXP 50
10183: PPUSH
10184: LD_INT 130
10186: PPUSH
10187: LD_INT 123
10189: PPUSH
10190: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
10194: LD_INT 35
10196: PPUSH
10197: CALL_OW 67
// until not See ( 1 , Frank ) ;
10201: LD_INT 1
10203: PPUSH
10204: LD_EXP 50
10208: PPUSH
10209: CALL_OW 292
10213: NOT
10214: IFFALSE 10194
// Wait ( 0 0$02 ) ;
10216: LD_INT 70
10218: PPUSH
10219: CALL_OW 67
// RemoveUnit ( Frank ) ;
10223: LD_EXP 50
10227: PPUSH
10228: CALL_OW 64
// end else
10232: GO 10246
// SetSide ( Frank , 1 ) ;
10234: LD_EXP 50
10238: PPUSH
10239: LD_INT 1
10241: PPUSH
10242: CALL_OW 235
// send_attack_on_cornel_base := true ;
10246: LD_ADDR_EXP 25
10250: PUSH
10251: LD_INT 1
10253: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10254: LD_INT 35
10256: PPUSH
10257: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10261: LD_ADDR_EXP 28
10265: PUSH
10266: LD_EXP 28
10270: PPUSH
10271: LD_STRING -
10273: PPUSH
10274: CALL 1117 0 2
10278: ST_TO_ADDR
// if debug then
10279: LD_EXP 1
10283: IFFALSE 10295
// debug_strings := time_to_prepare ;
10285: LD_ADDR_OWVAR 48
10289: PUSH
10290: LD_EXP 28
10294: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10295: LD_EXP 28
10299: PUSH
10300: LD_INT 0
10302: EQUAL
10303: IFFALSE 10254
// cornel_prepared := true ;
10305: LD_ADDR_EXP 11
10309: PUSH
10310: LD_INT 1
10312: ST_TO_ADDR
// end ;
10313: PPOPN 3
10315: END
// every 0 0$01 trigger cornel_prepared do
10316: LD_EXP 11
10320: IFFALSE 10577
10322: GO 10324
10324: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10325: LD_EXP 43
10329: PPUSH
10330: LD_STRING D3-Corn-1
10332: PPUSH
10333: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10337: LD_INT 35
10339: PPUSH
10340: CALL_OW 67
// until cornel_counter = 0 ;
10344: LD_EXP 10
10348: PUSH
10349: LD_INT 0
10351: EQUAL
10352: IFFALSE 10337
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10354: LD_EXP 43
10358: PPUSH
10359: LD_STRING D3a-Corn-1
10361: PPUSH
10362: CALL_OW 94
// if IsOk ( Cornel ) then
10366: LD_EXP 43
10370: PPUSH
10371: CALL_OW 302
10375: IFFALSE 10389
// Say ( JMM , D3a-JMM-1 ) ;
10377: LD_EXP 36
10381: PPUSH
10382: LD_STRING D3a-JMM-1
10384: PPUSH
10385: CALL_OW 88
// end_mission_allowed := true ;
10389: LD_ADDR_EXP 20
10393: PUSH
10394: LD_INT 1
10396: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10397: LD_STRING M2
10399: PPUSH
10400: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10404: LD_INT 9
10406: PPUSH
10407: LD_INT 1
10409: PPUSH
10410: CALL_OW 424
// Wait ( 0 0$05 ) ;
10414: LD_INT 175
10416: PPUSH
10417: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10421: LD_EXP 43
10425: PPUSH
10426: LD_STRING D3a-Corn-2
10428: PPUSH
10429: CALL_OW 94
// cornel_attack := true ;
10433: LD_ADDR_EXP 9
10437: PUSH
10438: LD_INT 1
10440: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10441: LD_INT 105
10443: PPUSH
10444: CALL_OW 67
// AddMoreTanks ( ) ;
10448: CALL 4834 0 0
// if frank_send_to_scout then
10452: LD_EXP 14
10456: IFFALSE 10577
// begin InitHc ;
10458: CALL_OW 19
// InitUc ;
10462: CALL_OW 18
// uc_side := 8 ;
10466: LD_ADDR_OWVAR 20
10470: PUSH
10471: LD_INT 8
10473: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10474: LD_ADDR_EXP 50
10478: PUSH
10479: LD_STRING Frank
10481: PPUSH
10482: LD_INT 0
10484: PPUSH
10485: CALL 474 0 2
10489: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10490: LD_EXP 50
10494: PPUSH
10495: LD_INT 6
10497: PPUSH
10498: LD_INT 9
10500: PPUSH
10501: LD_INT 0
10503: PPUSH
10504: CALL_OW 48
// ComCrawl ( Frank ) ;
10508: LD_EXP 50
10512: PPUSH
10513: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
10517: LD_INT 35
10519: PPUSH
10520: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
10524: LD_EXP 36
10528: PPUSH
10529: LD_EXP 50
10533: PPUSH
10534: CALL_OW 296
10538: PUSH
10539: LD_INT 9
10541: LESS
10542: IFFALSE 10517
// SetSide ( Frank , 1 ) ;
10544: LD_EXP 50
10548: PPUSH
10549: LD_INT 1
10551: PPUSH
10552: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10556: LD_EXP 50
10560: PPUSH
10561: LD_STRING D6a-Frank-1
10563: PPUSH
10564: CALL_OW 88
// ComWalk ( Frank ) ;
10568: LD_EXP 50
10572: PPUSH
10573: CALL_OW 138
// end ; end ;
10577: END
// every 0 0$01 trigger solar_builded do
10578: LD_EXP 13
10582: IFFALSE 10686
10584: GO 10586
10586: DISABLE
// begin Wait ( 0 0$02 ) ;
10587: LD_INT 70
10589: PPUSH
10590: CALL_OW 67
// DialogueOn ;
10594: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10598: LD_EXP 36
10602: PPUSH
10603: LD_STRING D2b-JMM-1
10605: PPUSH
10606: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10610: LD_EXP 47
10614: PUSH
10615: LD_EXP 47
10619: PPUSH
10620: CALL_OW 302
10624: AND
10625: IFFALSE 10675
// begin Say ( Walker , D2b-Sci1-1 ) ;
10627: LD_EXP 47
10631: PPUSH
10632: LD_STRING D2b-Sci1-1
10634: PPUSH
10635: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10639: LD_EXP 36
10643: PPUSH
10644: LD_STRING D2b-JMM-2
10646: PPUSH
10647: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10651: LD_EXP 47
10655: PPUSH
10656: LD_STRING D2b-Sci1-2
10658: PPUSH
10659: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10663: LD_EXP 36
10667: PPUSH
10668: LD_STRING D2b-JMM-3
10670: PPUSH
10671: CALL_OW 88
// end ; DialogueOff ;
10675: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10679: LD_STRING MOutSol
10681: PPUSH
10682: CALL_OW 337
// end ;
10686: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10687: LD_EXP 13
10691: PUSH
10692: LD_EXP 36
10696: PPUSH
10697: CALL_OW 302
10701: AND
10702: PUSH
10703: LD_EXP 36
10707: PPUSH
10708: CALL 951 0 1
10712: AND
10713: PUSH
10714: LD_EXP 15
10718: NOT
10719: AND
10720: IFFALSE 10791
10722: GO 10724
10724: DISABLE
10725: LD_INT 0
10727: PPUSH
// begin jmm_in_veh := true ;
10728: LD_ADDR_EXP 15
10732: PUSH
10733: LD_INT 1
10735: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10736: LD_ADDR_VAR 0 1
10740: PUSH
10741: LD_INT 0
10743: PPUSH
10744: LD_INT 1
10746: PPUSH
10747: CALL_OW 12
10751: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10752: LD_INT 70
10754: PPUSH
10755: CALL_OW 67
// if i then
10759: LD_VAR 0 1
10763: IFFALSE 10779
// Say ( JMM , D2c-JMM-1 ) else
10765: LD_EXP 36
10769: PPUSH
10770: LD_STRING D2c-JMM-1
10772: PPUSH
10773: CALL_OW 88
10777: GO 10791
// Say ( JMM , D2c-JMM-1a ) ;
10779: LD_EXP 36
10783: PPUSH
10784: LD_STRING D2c-JMM-1a
10786: PPUSH
10787: CALL_OW 88
// end ;
10791: PPOPN 1
10793: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10794: LD_EXP 13
10798: PUSH
10799: LD_EXP 37
10803: PPUSH
10804: CALL_OW 302
10808: AND
10809: PUSH
10810: LD_EXP 37
10814: PPUSH
10815: CALL 951 0 1
10819: AND
10820: PUSH
10821: LD_EXP 16
10825: NOT
10826: AND
10827: IFFALSE 10859
10829: GO 10831
10831: DISABLE
// begin bobby_in_veh := true ;
10832: LD_ADDR_EXP 16
10836: PUSH
10837: LD_INT 1
10839: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10840: LD_INT 70
10842: PPUSH
10843: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10847: LD_EXP 37
10851: PPUSH
10852: LD_STRING D2c-Bobby-1
10854: PPUSH
10855: CALL_OW 88
10859: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10860: LD_EXP 13
10864: PUSH
10865: LD_EXP 39
10869: PPUSH
10870: CALL_OW 302
10874: AND
10875: PUSH
10876: LD_EXP 39
10880: PPUSH
10881: CALL 951 0 1
10885: AND
10886: PUSH
10887: LD_EXP 18
10891: NOT
10892: AND
10893: IFFALSE 10925
10895: GO 10897
10897: DISABLE
// begin lisa_in_veh := true ;
10898: LD_ADDR_EXP 18
10902: PUSH
10903: LD_INT 1
10905: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10906: LD_INT 70
10908: PPUSH
10909: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10913: LD_EXP 39
10917: PPUSH
10918: LD_STRING D2c-Lisa-1
10920: PPUSH
10921: CALL_OW 88
10925: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
10926: LD_EXP 13
10930: PUSH
10931: LD_EXP 38
10935: PPUSH
10936: CALL_OW 302
10940: AND
10941: PUSH
10942: LD_EXP 38
10946: PPUSH
10947: CALL 951 0 1
10951: AND
10952: PUSH
10953: LD_EXP 17
10957: NOT
10958: AND
10959: IFFALSE 11030
10961: GO 10963
10963: DISABLE
10964: LD_INT 0
10966: PPUSH
// begin cyrus_in_veh := true ;
10967: LD_ADDR_EXP 17
10971: PUSH
10972: LD_INT 1
10974: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10975: LD_ADDR_VAR 0 1
10979: PUSH
10980: LD_INT 0
10982: PPUSH
10983: LD_INT 1
10985: PPUSH
10986: CALL_OW 12
10990: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10991: LD_INT 70
10993: PPUSH
10994: CALL_OW 67
// if i then
10998: LD_VAR 0 1
11002: IFFALSE 11018
// Say ( Cyrus , D2c-Cyrus-1 ) else
11004: LD_EXP 38
11008: PPUSH
11009: LD_STRING D2c-Cyrus-1
11011: PPUSH
11012: CALL_OW 88
11016: GO 11030
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11018: LD_EXP 38
11022: PPUSH
11023: LD_STRING D2c-Cyrus-1a
11025: PPUSH
11026: CALL_OW 88
// end ;
11030: PPOPN 1
11032: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
11033: LD_EXP 43
11037: PPUSH
11038: LD_INT 16
11040: PPUSH
11041: CALL_OW 308
11045: IFFALSE 11315
11047: GO 11049
11049: DISABLE
11050: LD_INT 0
11052: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
11053: LD_INT 3
11055: PPUSH
11056: LD_EXP 43
11060: PPUSH
11061: CALL_OW 471
// send_attack_on_cornel := true ;
11065: LD_ADDR_EXP 31
11069: PUSH
11070: LD_INT 1
11072: ST_TO_ADDR
// if ru_vehicles then
11073: LD_EXP 55
11077: IFFALSE 11111
// for i in ru_vehicles do
11079: LD_ADDR_VAR 0 1
11083: PUSH
11084: LD_EXP 55
11088: PUSH
11089: FOR_IN
11090: IFFALSE 11109
// ComAgressiveMove ( i , 215 , 69 ) ;
11092: LD_VAR 0 1
11096: PPUSH
11097: LD_INT 215
11099: PPUSH
11100: LD_INT 69
11102: PPUSH
11103: CALL_OW 114
11107: GO 11089
11109: POP
11110: POP
// if ru_patrol then
11111: LD_EXP 52
11115: IFFALSE 11149
// for i in ru_patrol do
11117: LD_ADDR_VAR 0 1
11121: PUSH
11122: LD_EXP 52
11126: PUSH
11127: FOR_IN
11128: IFFALSE 11147
// ComAgressiveMove ( i , 215 , 69 ) ;
11130: LD_VAR 0 1
11134: PPUSH
11135: LD_INT 215
11137: PPUSH
11138: LD_INT 69
11140: PPUSH
11141: CALL_OW 114
11145: GO 11127
11147: POP
11148: POP
// if frank_send_to_scout then
11149: LD_EXP 14
11153: IFFALSE 11167
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
11155: LD_EXP 50
11159: PPUSH
11160: LD_STRING D3b-Frank-1
11162: PPUSH
11163: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
11167: LD_INT 105
11169: PPUSH
11170: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
11174: LD_EXP 43
11178: PPUSH
11179: LD_STRING D4-Corn-1
11181: PPUSH
11182: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
11186: LD_INT 35
11188: PPUSH
11189: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 6 ;
11193: LD_INT 22
11195: PUSH
11196: LD_INT 4
11198: PUSH
11199: EMPTY
11200: LIST
11201: LIST
11202: PUSH
11203: LD_INT 21
11205: PUSH
11206: LD_INT 1
11208: PUSH
11209: EMPTY
11210: LIST
11211: LIST
11212: PUSH
11213: LD_INT 50
11215: PUSH
11216: EMPTY
11217: LIST
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: LIST
11223: PPUSH
11224: CALL_OW 69
11228: PUSH
11229: LD_INT 6
11231: LESS
11232: IFFALSE 11186
// if Cornel then
11234: LD_EXP 43
11238: IFFALSE 11278
// begin SayRadio ( Cornel , D5-Corn-1 ) ;
11240: LD_EXP 43
11244: PPUSH
11245: LD_STRING D5-Corn-1
11247: PPUSH
11248: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11252: LD_EXP 43
11256: PPUSH
11257: LD_EXP 2
11261: PUSH
11262: LD_STRING Cornel
11264: STR
11265: PPUSH
11266: CALL_OW 38
// cornel_saved := true ;
11270: LD_ADDR_EXP 26
11274: PUSH
11275: LD_INT 1
11277: ST_TO_ADDR
// end ; ChangeSideFog ( 4 , 8 ) ;
11278: LD_INT 4
11280: PPUSH
11281: LD_INT 8
11283: PPUSH
11284: CALL_OW 343
// Wait ( 0 0$01 ) ;
11288: LD_INT 35
11290: PPUSH
11291: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11295: LD_INT 3
11297: PPUSH
11298: LD_EXP 43
11302: PPUSH
11303: CALL_OW 472
// send_attack_on_cornel := false ;
11307: LD_ADDR_EXP 31
11311: PUSH
11312: LD_INT 0
11314: ST_TO_ADDR
// end ;
11315: PPOPN 1
11317: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11318: LD_INT 9
11320: PPUSH
11321: LD_INT 22
11323: PUSH
11324: LD_INT 1
11326: PUSH
11327: EMPTY
11328: LIST
11329: LIST
11330: PPUSH
11331: CALL_OW 70
11335: PUSH
11336: LD_EXP 32
11340: OR
11341: IFFALSE 11523
11343: GO 11345
11345: DISABLE
11346: LD_INT 0
11348: PPUSH
11349: PPUSH
// begin enable ;
11350: ENABLE
// if not jmm_on_west then
11351: LD_EXP 5
11355: NOT
11356: IFFALSE 11367
// begin YouLost ( 4 ) ;
11358: LD_STRING 4
11360: PPUSH
11361: CALL_OW 104
// exit ;
11365: GO 11523
// end ; if not game_end then
11367: LD_EXP 32
11371: NOT
11372: IFFALSE 11382
// game_end := true ;
11374: LD_ADDR_EXP 32
11378: PUSH
11379: LD_INT 1
11381: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11382: LD_ADDR_VAR 0 2
11386: PUSH
11387: LD_INT 9
11389: PPUSH
11390: LD_INT 22
11392: PUSH
11393: LD_INT 1
11395: PUSH
11396: EMPTY
11397: LIST
11398: LIST
11399: PPUSH
11400: CALL_OW 70
11404: ST_TO_ADDR
// if not filter then
11405: LD_VAR 0 2
11409: NOT
11410: IFFALSE 11414
// exit ;
11412: GO 11523
// for i in filter do
11414: LD_ADDR_VAR 0 1
11418: PUSH
11419: LD_VAR 0 2
11423: PUSH
11424: FOR_IN
11425: IFFALSE 11521
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
11427: LD_VAR 0 1
11431: PPUSH
11432: CALL_OW 302
11436: PUSH
11437: LD_VAR 0 1
11441: PPUSH
11442: CALL_OW 247
11446: PUSH
11447: LD_INT 2
11449: EQUAL
11450: AND
11451: IFFALSE 11484
// begin veh_on_meta := true ;
11453: LD_ADDR_EXP 27
11457: PUSH
11458: LD_INT 1
11460: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11461: LD_VAR 0 1
11465: PPUSH
11466: CALL_OW 311
11470: PPUSH
11471: CALL 11526 0 1
// RemoveUnit ( i ) ;
11475: LD_VAR 0 1
11479: PPUSH
11480: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11484: LD_VAR 0 1
11488: PPUSH
11489: CALL_OW 302
11493: PUSH
11494: LD_VAR 0 1
11498: PPUSH
11499: CALL_OW 247
11503: PUSH
11504: LD_INT 1
11506: EQUAL
11507: AND
11508: IFFALSE 11519
// Save ( i ) ;
11510: LD_VAR 0 1
11514: PPUSH
11515: CALL 11526 0 1
// end ;
11519: GO 11424
11521: POP
11522: POP
// end ;
11523: PPOPN 2
11525: END
// export function Save ( i ) ; begin
11526: LD_INT 0
11528: PPUSH
// save_counter := save_counter + 1 ;
11529: LD_ADDR_EXP 35
11533: PUSH
11534: LD_EXP 35
11538: PUSH
11539: LD_INT 1
11541: PLUS
11542: ST_TO_ADDR
// if i = JMM then
11543: LD_VAR 0 1
11547: PUSH
11548: LD_EXP 36
11552: EQUAL
11553: IFFALSE 11675
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11555: LD_EXP 23
11559: PUSH
11560: LD_INT 22
11562: PUSH
11563: LD_INT 1
11565: PUSH
11566: EMPTY
11567: LIST
11568: LIST
11569: PUSH
11570: LD_INT 21
11572: PUSH
11573: LD_INT 1
11575: PUSH
11576: EMPTY
11577: LIST
11578: LIST
11579: PUSH
11580: EMPTY
11581: LIST
11582: LIST
11583: PPUSH
11584: CALL_OW 69
11588: PUSH
11589: LD_INT 1
11591: GREATER
11592: AND
11593: IFFALSE 11650
// begin show_query := false ;
11595: LD_ADDR_EXP 23
11599: PUSH
11600: LD_INT 0
11602: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11603: LD_STRING Q2
11605: PPUSH
11606: CALL_OW 97
11610: PUSH
11611: LD_INT 1
11613: DOUBLE
11614: EQUAL
11615: IFTRUE 11619
11617: GO 11630
11619: POP
// wait_for_them := true ; 2 :
11620: LD_ADDR_EXP 24
11624: PUSH
11625: LD_INT 1
11627: ST_TO_ADDR
11628: GO 11650
11630: LD_INT 2
11632: DOUBLE
11633: EQUAL
11634: IFTRUE 11638
11636: GO 11649
11638: POP
// wait_for_them := false ; end ;
11639: LD_ADDR_EXP 24
11643: PUSH
11644: LD_INT 0
11646: ST_TO_ADDR
11647: GO 11650
11649: POP
// end ; save_group := save_group ^ JMM ;
11650: LD_ADDR_EXP 22
11654: PUSH
11655: LD_EXP 22
11659: PUSH
11660: LD_EXP 36
11664: ADD
11665: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11666: LD_EXP 36
11670: PPUSH
11671: CALL_OW 64
// end ; if i = Lisa then
11675: LD_VAR 0 1
11679: PUSH
11680: LD_EXP 39
11684: EQUAL
11685: IFFALSE 11712
// begin save_group := save_group ^ Lisa ;
11687: LD_ADDR_EXP 22
11691: PUSH
11692: LD_EXP 22
11696: PUSH
11697: LD_EXP 39
11701: ADD
11702: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11703: LD_EXP 39
11707: PPUSH
11708: CALL_OW 64
// end ; if i = Bobby then
11712: LD_VAR 0 1
11716: PUSH
11717: LD_EXP 37
11721: EQUAL
11722: IFFALSE 11749
// begin save_group := save_group ^ Bobby ;
11724: LD_ADDR_EXP 22
11728: PUSH
11729: LD_EXP 22
11733: PUSH
11734: LD_EXP 37
11738: ADD
11739: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11740: LD_EXP 37
11744: PPUSH
11745: CALL_OW 64
// end ; if i = Cyrus then
11749: LD_VAR 0 1
11753: PUSH
11754: LD_EXP 38
11758: EQUAL
11759: IFFALSE 11786
// begin save_group := save_group ^ Cyrus ;
11761: LD_ADDR_EXP 22
11765: PUSH
11766: LD_EXP 22
11770: PUSH
11771: LD_EXP 38
11775: ADD
11776: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11777: LD_EXP 38
11781: PPUSH
11782: CALL_OW 64
// end ; if i = Khatam then
11786: LD_VAR 0 1
11790: PUSH
11791: LD_EXP 40
11795: EQUAL
11796: IFFALSE 11823
// begin save_group := save_group ^ Khatam ;
11798: LD_ADDR_EXP 22
11802: PUSH
11803: LD_EXP 22
11807: PUSH
11808: LD_EXP 40
11812: ADD
11813: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11814: LD_EXP 40
11818: PPUSH
11819: CALL_OW 64
// end ; if i = Frank then
11823: LD_VAR 0 1
11827: PUSH
11828: LD_EXP 50
11832: EQUAL
11833: IFFALSE 11860
// begin save_group := save_group ^ Frank ;
11835: LD_ADDR_EXP 22
11839: PUSH
11840: LD_EXP 22
11844: PUSH
11845: LD_EXP 50
11849: ADD
11850: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11851: LD_EXP 50
11855: PPUSH
11856: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11860: LD_VAR 0 1
11864: PPUSH
11865: CALL_OW 302
11869: PUSH
11870: LD_VAR 0 1
11874: PPUSH
11875: CALL_OW 247
11879: PUSH
11880: LD_INT 1
11882: EQUAL
11883: AND
11884: PUSH
11885: LD_VAR 0 1
11889: PUSH
11890: LD_EXP 22
11894: IN
11895: NOT
11896: AND
11897: IFFALSE 11924
// begin save_others := save_others ^ i ;
11899: LD_ADDR_EXP 21
11903: PUSH
11904: LD_EXP 21
11908: PUSH
11909: LD_VAR 0 1
11913: ADD
11914: ST_TO_ADDR
// RemoveUnit ( i ) ;
11915: LD_VAR 0 1
11919: PPUSH
11920: CALL_OW 64
// end ; end ;
11924: LD_VAR 0 2
11928: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
11929: LD_EXP 23
11933: NOT
11934: PUSH
11935: LD_EXP 24
11939: NOT
11940: AND
11941: PUSH
11942: LD_INT 22
11944: PUSH
11945: LD_INT 1
11947: PUSH
11948: EMPTY
11949: LIST
11950: LIST
11951: PUSH
11952: LD_INT 21
11954: PUSH
11955: LD_INT 1
11957: PUSH
11958: EMPTY
11959: LIST
11960: LIST
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: PPUSH
11966: CALL_OW 69
11970: PUSH
11971: LD_INT 0
11973: EQUAL
11974: OR
11975: IFFALSE 11984
11977: GO 11979
11979: DISABLE
// EndMission ;
11980: CALL 11985 0 0
11984: END
// export function EndMission ; var i ; begin
11985: LD_INT 0
11987: PPUSH
11988: PPUSH
// Wait ( 0 0$02 ) ;
11989: LD_INT 70
11991: PPUSH
11992: CALL_OW 67
// if solar_builded then
11996: LD_EXP 13
12000: IFFALSE 12014
// AddMedal ( Solar1 , 1 ) else
12002: LD_STRING Solar1
12004: PPUSH
12005: LD_INT 1
12007: PPUSH
12008: CALL_OW 101
12012: GO 12025
// AddMedal ( Solar1 , - 1 ) ;
12014: LD_STRING Solar1
12016: PPUSH
12017: LD_INT 1
12019: NEG
12020: PPUSH
12021: CALL_OW 101
// if veh_on_meta then
12025: LD_EXP 27
12029: IFFALSE 12043
// AddMedal ( Solar2 , 1 ) else
12031: LD_STRING Solar2
12033: PPUSH
12034: LD_INT 1
12036: PPUSH
12037: CALL_OW 101
12041: GO 12073
// if solar_builded then
12043: LD_EXP 13
12047: IFFALSE 12062
// AddMedal ( Solar2 , - 1 ) else
12049: LD_STRING Solar2
12051: PPUSH
12052: LD_INT 1
12054: NEG
12055: PPUSH
12056: CALL_OW 101
12060: GO 12073
// AddMedal ( Solar2 , - 2 ) ;
12062: LD_STRING Solar2
12064: PPUSH
12065: LD_INT 2
12067: NEG
12068: PPUSH
12069: CALL_OW 101
// if lose_counter = 0 then
12073: LD_EXP 33
12077: PUSH
12078: LD_INT 0
12080: EQUAL
12081: IFFALSE 12095
// AddMedal ( No , 1 ) else
12083: LD_STRING No
12085: PPUSH
12086: LD_INT 1
12088: PPUSH
12089: CALL_OW 101
12093: GO 12139
// if lose_counter > 0 and lose_counter < 4 then
12095: LD_EXP 33
12099: PUSH
12100: LD_INT 0
12102: GREATER
12103: PUSH
12104: LD_EXP 33
12108: PUSH
12109: LD_INT 4
12111: LESS
12112: AND
12113: IFFALSE 12128
// AddMedal ( No , - 1 ) else
12115: LD_STRING No
12117: PPUSH
12118: LD_INT 1
12120: NEG
12121: PPUSH
12122: CALL_OW 101
12126: GO 12139
// AddMedal ( UpTo4 , - 1 ) ;
12128: LD_STRING UpTo4
12130: PPUSH
12131: LD_INT 1
12133: NEG
12134: PPUSH
12135: CALL_OW 101
// GiveMedals ( MAIN ) ;
12139: LD_STRING MAIN
12141: PPUSH
12142: CALL_OW 102
// if IsDead ( Pokryshkin ) then
12146: LD_EXP 51
12150: PPUSH
12151: CALL_OW 301
12155: IFFALSE 12195
// for i in save_group ^ save_others do
12157: LD_ADDR_VAR 0 2
12161: PUSH
12162: LD_EXP 22
12166: PUSH
12167: LD_EXP 21
12171: ADD
12172: PUSH
12173: FOR_IN
12174: IFFALSE 12193
// AddExperience ( i , skill_combat , 1500 ) ;
12176: LD_VAR 0 2
12180: PPUSH
12181: LD_INT 1
12183: PPUSH
12184: LD_INT 1500
12186: PPUSH
12187: CALL_OW 492
12191: GO 12173
12193: POP
12194: POP
// RewardPeople ( save_group ^ save_others ) ;
12195: LD_EXP 22
12199: PUSH
12200: LD_EXP 21
12204: ADD
12205: PPUSH
12206: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
12210: LD_EXP 36
12214: PPUSH
12215: LD_EXP 2
12219: PUSH
12220: LD_STRING JMM
12222: STR
12223: PPUSH
12224: CALL_OW 38
// if Bobby in save_group then
12228: LD_EXP 37
12232: PUSH
12233: LD_EXP 22
12237: IN
12238: IFFALSE 12258
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12240: LD_EXP 37
12244: PPUSH
12245: LD_EXP 2
12249: PUSH
12250: LD_STRING Bobby
12252: STR
12253: PPUSH
12254: CALL_OW 38
// if Cyrus in save_group then
12258: LD_EXP 38
12262: PUSH
12263: LD_EXP 22
12267: IN
12268: IFFALSE 12288
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12270: LD_EXP 38
12274: PPUSH
12275: LD_EXP 2
12279: PUSH
12280: LD_STRING Cyrus
12282: STR
12283: PPUSH
12284: CALL_OW 38
// if Lisa in save_group then
12288: LD_EXP 39
12292: PUSH
12293: LD_EXP 22
12297: IN
12298: IFFALSE 12318
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12300: LD_EXP 39
12304: PPUSH
12305: LD_EXP 2
12309: PUSH
12310: LD_STRING Lisa
12312: STR
12313: PPUSH
12314: CALL_OW 38
// if Frank in save_group then
12318: LD_EXP 50
12322: PUSH
12323: LD_EXP 22
12327: IN
12328: IFFALSE 12348
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12330: LD_EXP 50
12334: PPUSH
12335: LD_EXP 2
12339: PUSH
12340: LD_STRING Frank
12342: STR
12343: PPUSH
12344: CALL_OW 38
// if Khatam in save_group then
12348: LD_EXP 40
12352: PUSH
12353: LD_EXP 22
12357: IN
12358: IFFALSE 12378
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
12360: LD_EXP 40
12364: PPUSH
12365: LD_EXP 2
12369: PUSH
12370: LD_STRING Khatam
12372: STR
12373: PPUSH
12374: CALL_OW 38
// if save_others then
12378: LD_EXP 21
12382: IFFALSE 12396
// SaveCharacters ( save_others , 03_others ) ;
12384: LD_EXP 21
12388: PPUSH
12389: LD_STRING 03_others
12391: PPUSH
12392: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) and cornel_saved then
12396: LD_EXP 44
12400: PUSH
12401: LD_EXP 44
12405: PPUSH
12406: CALL_OW 302
12410: AND
12411: PUSH
12412: LD_EXP 26
12416: AND
12417: IFFALSE 12429
// begin ResetFog ;
12419: CALL_OW 335
// DisplayEndingScene ;
12423: CALL 12451 0 0
// end else
12427: GO 12442
// DeleteCharacters ( mission_prefix & Cornel ) ;
12429: LD_EXP 2
12433: PUSH
12434: LD_STRING Cornel
12436: STR
12437: PPUSH
12438: CALL_OW 40
// YouWin ;
12442: CALL_OW 103
// end ;
12446: LD_VAR 0 1
12450: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
12451: LD_INT 0
12453: PPUSH
12454: PPUSH
12455: PPUSH
12456: PPUSH
12457: PPUSH
12458: PPUSH
// InGameOn ;
12459: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12463: LD_INT 208
12465: PPUSH
12466: LD_INT 62
12468: PPUSH
12469: LD_INT 1
12471: PPUSH
12472: LD_INT 10
12474: NEG
12475: PPUSH
12476: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
12480: LD_INT 208
12482: PPUSH
12483: LD_INT 62
12485: PPUSH
12486: LD_INT 1
12488: PPUSH
12489: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
12493: LD_ADDR_VAR 0 3
12497: PUSH
12498: LD_INT 22
12500: PUSH
12501: LD_INT 3
12503: PUSH
12504: EMPTY
12505: LIST
12506: LIST
12507: PUSH
12508: LD_INT 2
12510: PUSH
12511: LD_INT 21
12513: PUSH
12514: LD_INT 2
12516: PUSH
12517: EMPTY
12518: LIST
12519: LIST
12520: PUSH
12521: LD_INT 21
12523: PUSH
12524: LD_INT 1
12526: PUSH
12527: EMPTY
12528: LIST
12529: LIST
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: LIST
12535: PUSH
12536: EMPTY
12537: LIST
12538: LIST
12539: PPUSH
12540: CALL_OW 69
12544: ST_TO_ADDR
// if filter then
12545: LD_VAR 0 3
12549: IFFALSE 12577
// for i in filter do
12551: LD_ADDR_VAR 0 2
12555: PUSH
12556: LD_VAR 0 3
12560: PUSH
12561: FOR_IN
12562: IFFALSE 12575
// RemoveUnit ( i ) ;
12564: LD_VAR 0 2
12568: PPUSH
12569: CALL_OW 64
12573: GO 12561
12575: POP
12576: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
12577: LD_ADDR_VAR 0 3
12581: PUSH
12582: LD_INT 22
12584: PUSH
12585: LD_INT 4
12587: PUSH
12588: EMPTY
12589: LIST
12590: LIST
12591: PUSH
12592: LD_INT 21
12594: PUSH
12595: LD_INT 1
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: PUSH
12602: EMPTY
12603: LIST
12604: LIST
12605: PPUSH
12606: CALL_OW 69
12610: ST_TO_ADDR
// if filter then
12611: LD_VAR 0 3
12615: IFFALSE 12646
// for i in filter do
12617: LD_ADDR_VAR 0 2
12621: PUSH
12622: LD_VAR 0 3
12626: PUSH
12627: FOR_IN
12628: IFFALSE 12644
// SetLives ( i , 0 ) ;
12630: LD_VAR 0 2
12634: PPUSH
12635: LD_INT 0
12637: PPUSH
12638: CALL_OW 234
12642: GO 12627
12644: POP
12645: POP
// uc_side := 4 ;
12646: LD_ADDR_OWVAR 20
12650: PUSH
12651: LD_INT 4
12653: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12654: LD_ADDR_VAR 0 4
12658: PUSH
12659: LD_STRING Cornell
12661: PPUSH
12662: LD_INT 0
12664: PPUSH
12665: CALL 474 0 2
12669: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12670: LD_VAR 0 4
12674: PPUSH
12675: LD_INT 208
12677: PPUSH
12678: LD_INT 62
12680: PPUSH
12681: LD_INT 0
12683: PPUSH
12684: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12688: LD_VAR 0 4
12692: PPUSH
12693: LD_INT 100
12695: PPUSH
12696: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12700: LD_INT 3
12702: PPUSH
12703: LD_VAR 0 4
12707: PPUSH
12708: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12712: LD_INT 4
12714: PPUSH
12715: LD_INT 3
12717: PPUSH
12718: LD_INT 1
12720: PPUSH
12721: LD_INT 1
12723: PPUSH
12724: CALL_OW 80
// uc_side := 3 ;
12728: LD_ADDR_OWVAR 20
12732: PUSH
12733: LD_INT 3
12735: ST_TO_ADDR
// uc_nation := 3 ;
12736: LD_ADDR_OWVAR 21
12740: PUSH
12741: LD_INT 3
12743: ST_TO_ADDR
// InitHc ;
12744: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12748: LD_ADDR_VAR 0 5
12752: PUSH
12753: LD_STRING Mikhail
12755: PPUSH
12756: LD_INT 0
12758: PPUSH
12759: CALL 474 0 2
12763: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12764: LD_INT 1
12766: PPUSH
12767: LD_INT 1
12769: PPUSH
12770: LD_INT 0
12772: PPUSH
12773: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12777: LD_ADDR_VAR 0 6
12781: PUSH
12782: LD_VAR 0 6
12786: PUSH
12787: CALL_OW 44
12791: ADD
12792: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12793: LD_ADDR_VAR 0 6
12797: PUSH
12798: LD_VAR 0 6
12802: PUSH
12803: CALL_OW 44
12807: ADD
12808: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12809: LD_INT 2
12811: PPUSH
12812: LD_INT 4
12814: PPUSH
12815: LD_INT 0
12817: PPUSH
12818: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12822: LD_ADDR_VAR 0 6
12826: PUSH
12827: LD_VAR 0 6
12831: PUSH
12832: CALL_OW 44
12836: ADD
12837: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12838: LD_VAR 0 5
12842: PPUSH
12843: LD_INT 17
12845: PPUSH
12846: LD_INT 0
12848: PPUSH
12849: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12853: LD_VAR 0 5
12857: PPUSH
12858: LD_INT 210
12860: PPUSH
12861: LD_INT 63
12863: PPUSH
12864: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12868: LD_VAR 0 5
12872: PPUSH
12873: LD_INT 208
12875: PPUSH
12876: LD_INT 62
12878: PPUSH
12879: CALL_OW 178
// for i in fake_russians do
12883: LD_ADDR_VAR 0 2
12887: PUSH
12888: LD_VAR 0 6
12892: PUSH
12893: FOR_IN
12894: IFFALSE 12972
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12896: LD_VAR 0 2
12900: PPUSH
12901: LD_INT 17
12903: PPUSH
12904: LD_INT 0
12906: PPUSH
12907: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
12911: LD_VAR 0 2
12915: PPUSH
12916: LD_INT 215
12918: PPUSH
12919: LD_INT 67
12921: PPUSH
12922: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
12926: LD_VAR 0 2
12930: PPUSH
12931: LD_INT 208
12933: PPUSH
12934: LD_INT 62
12936: PPUSH
12937: CALL_OW 178
// if GetClass ( i ) = 4 then
12941: LD_VAR 0 2
12945: PPUSH
12946: CALL_OW 257
12950: PUSH
12951: LD_INT 4
12953: EQUAL
12954: IFFALSE 12970
// ComHeal ( i , fake_cornel ) ;
12956: LD_VAR 0 2
12960: PPUSH
12961: LD_VAR 0 4
12965: PPUSH
12966: CALL_OW 128
// end ;
12970: GO 12893
12972: POP
12973: POP
// Wait ( 0 0$01 ) ;
12974: LD_INT 35
12976: PPUSH
12977: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
12981: LD_INT 208
12983: PPUSH
12984: LD_INT 62
12986: PPUSH
12987: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12991: LD_INT 208
12993: PPUSH
12994: LD_INT 62
12996: PPUSH
12997: LD_INT 1
12999: PPUSH
13000: LD_INT 10
13002: NEG
13003: PPUSH
13004: CALL_OW 330
// Wait ( 0 0$15 ) ;
13008: LD_INT 525
13010: PPUSH
13011: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
13015: LD_INT 208
13017: PPUSH
13018: LD_INT 62
13020: PPUSH
13021: LD_INT 1
13023: PPUSH
13024: CALL_OW 331
// ResetFog ;
13028: CALL_OW 335
// InGameOff ;
13032: CALL_OW 9
// end ;
13036: LD_VAR 0 1
13040: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
13041: LD_INT 10
13043: PPUSH
13044: LD_INT 22
13046: PUSH
13047: LD_INT 1
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: PPUSH
13054: CALL_OW 70
13058: PUSH
13059: LD_EXP 43
13063: PPUSH
13064: CALL_OW 302
13068: AND
13069: PUSH
13070: LD_INT 22
13072: PUSH
13073: LD_INT 1
13075: PUSH
13076: EMPTY
13077: LIST
13078: LIST
13079: PPUSH
13080: CALL_OW 69
13084: PPUSH
13085: LD_EXP 43
13089: PPUSH
13090: CALL_OW 74
13094: PPUSH
13095: LD_EXP 43
13099: PPUSH
13100: CALL_OW 296
13104: PUSH
13105: LD_INT 30
13107: LESS
13108: OR
13109: IFFALSE 13160
13111: GO 13113
13113: DISABLE
// begin enable ;
13114: ENABLE
// powell_warn := powell_warn + 1 ;
13115: LD_ADDR_EXP 34
13119: PUSH
13120: LD_EXP 34
13124: PUSH
13125: LD_INT 1
13127: PLUS
13128: ST_TO_ADDR
// if powell_warn = 3 then
13129: LD_EXP 34
13133: PUSH
13134: LD_INT 3
13136: EQUAL
13137: IFFALSE 13148
// begin YouLost ( 5 ) ;
13139: LD_STRING 5
13141: PPUSH
13142: CALL_OW 104
// exit ;
13146: GO 13160
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
13148: LD_EXP 45
13152: PPUSH
13153: LD_STRING DWarn-Pow-1
13155: PPUSH
13156: CALL_OW 94
// end ; end_of_file
13160: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
13161: LD_EXP 8
13165: IFFALSE 14521
13167: GO 13169
13169: DISABLE
13170: LD_INT 0
13172: PPUSH
13173: PPUSH
13174: PPUSH
13175: PPUSH
13176: PPUSH
13177: PPUSH
13178: PPUSH
13179: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
13180: LD_EXP 43
13184: PUSH
13185: LD_EXP 44
13189: ADD
13190: PUSH
13191: LD_EXP 6
13195: ADD
13196: PPUSH
13197: LD_INT 250
13199: PPUSH
13200: LD_INT 120
13202: PPUSH
13203: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff Bierezov ;
13207: LD_ADDR_VAR 0 2
13211: PUSH
13212: LD_EXP 6
13216: PPUSH
13217: LD_INT 25
13219: PUSH
13220: LD_INT 2
13222: PUSH
13223: EMPTY
13224: LIST
13225: LIST
13226: PPUSH
13227: CALL_OW 72
13231: PUSH
13232: LD_EXP 44
13236: DIFF
13237: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) diff has_eng ;
13238: LD_ADDR_VAR 0 3
13242: PUSH
13243: LD_EXP 6
13247: PPUSH
13248: LD_INT 21
13250: PUSH
13251: LD_INT 1
13253: PUSH
13254: EMPTY
13255: LIST
13256: LIST
13257: PPUSH
13258: CALL_OW 72
13262: PUSH
13263: LD_VAR 0 2
13267: DIFF
13268: ST_TO_ADDR
// if not has_eng then
13269: LD_VAR 0 2
13273: NOT
13274: IFFALSE 13357
// begin uc_side := 4 ;
13276: LD_ADDR_OWVAR 20
13280: PUSH
13281: LD_INT 4
13283: ST_TO_ADDR
// uc_nation := 1 ;
13284: LD_ADDR_OWVAR 21
13288: PUSH
13289: LD_INT 1
13291: ST_TO_ADDR
// bc_type := b_depot ;
13292: LD_ADDR_OWVAR 42
13296: PUSH
13297: LD_INT 0
13299: ST_TO_ADDR
// bc_level := 2 ;
13300: LD_ADDR_OWVAR 43
13304: PUSH
13305: LD_INT 2
13307: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13308: LD_ADDR_VAR 0 4
13312: PUSH
13313: LD_INT 264
13315: PPUSH
13316: LD_INT 120
13318: PPUSH
13319: LD_INT 4
13321: PPUSH
13322: CALL_OW 47
13326: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13327: LD_INT 264
13329: PPUSH
13330: LD_INT 120
13332: PPUSH
13333: LD_INT 4
13335: PPUSH
13336: LD_INT 10
13338: NEG
13339: PPUSH
13340: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13344: LD_INT 264
13346: PPUSH
13347: LD_INT 120
13349: PPUSH
13350: LD_INT 4
13352: PPUSH
13353: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13357: LD_INT 35
13359: PPUSH
13360: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
13364: LD_EXP 43
13368: PPUSH
13369: LD_INT 10
13371: PPUSH
13372: CALL_OW 308
13376: IFFALSE 13357
// if has_eng and not dep then
13378: LD_VAR 0 2
13382: PUSH
13383: LD_VAR 0 4
13387: NOT
13388: AND
13389: IFFALSE 13539
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
13391: LD_VAR 0 2
13395: PPUSH
13396: LD_INT 0
13398: PPUSH
13399: LD_INT 264
13401: PPUSH
13402: LD_INT 120
13404: PPUSH
13405: LD_INT 4
13407: PPUSH
13408: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
13412: LD_INT 35
13414: PPUSH
13415: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
13419: LD_INT 22
13421: PUSH
13422: LD_INT 4
13424: PUSH
13425: EMPTY
13426: LIST
13427: LIST
13428: PUSH
13429: LD_INT 30
13431: PUSH
13432: LD_INT 0
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: PUSH
13439: EMPTY
13440: LIST
13441: LIST
13442: PPUSH
13443: CALL_OW 69
13447: IFFALSE 13412
// ComMoveXY ( filter , 264 , 120 ) ;
13449: LD_VAR 0 3
13453: PPUSH
13454: LD_INT 264
13456: PPUSH
13457: LD_INT 120
13459: PPUSH
13460: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
13464: LD_INT 35
13466: PPUSH
13467: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
13471: LD_INT 22
13473: PUSH
13474: LD_INT 4
13476: PUSH
13477: EMPTY
13478: LIST
13479: LIST
13480: PUSH
13481: LD_INT 30
13483: PUSH
13484: LD_INT 0
13486: PUSH
13487: EMPTY
13488: LIST
13489: LIST
13490: PUSH
13491: LD_INT 3
13493: PUSH
13494: LD_INT 57
13496: PUSH
13497: EMPTY
13498: LIST
13499: PUSH
13500: EMPTY
13501: LIST
13502: LIST
13503: PUSH
13504: EMPTY
13505: LIST
13506: LIST
13507: LIST
13508: PPUSH
13509: CALL_OW 69
13513: IFFALSE 13464
// ComMoveXY ( filter , 247 , 113 ) ;
13515: LD_VAR 0 3
13519: PPUSH
13520: LD_INT 247
13522: PPUSH
13523: LD_INT 113
13525: PPUSH
13526: CALL_OW 111
// Wait ( 0 0$2 ) ;
13530: LD_INT 70
13532: PPUSH
13533: CALL_OW 67
// end else
13537: GO 13551
// begin SetSide ( dep , 4 ) ;
13539: LD_VAR 0 4
13543: PPUSH
13544: LD_INT 4
13546: PPUSH
13547: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
13551: LD_ADDR_VAR 0 4
13555: PUSH
13556: LD_INT 22
13558: PUSH
13559: LD_INT 4
13561: PUSH
13562: EMPTY
13563: LIST
13564: LIST
13565: PUSH
13566: LD_INT 30
13568: PUSH
13569: LD_INT 0
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: PUSH
13576: EMPTY
13577: LIST
13578: LIST
13579: PPUSH
13580: CALL_OW 69
13584: PUSH
13585: LD_INT 1
13587: ARRAY
13588: ST_TO_ADDR
// for i = 1 to 2 do
13589: LD_ADDR_VAR 0 1
13593: PUSH
13594: DOUBLE
13595: LD_INT 1
13597: DEC
13598: ST_TO_ADDR
13599: LD_INT 2
13601: PUSH
13602: FOR_TO
13603: IFFALSE 13698
// begin ComEnterUnit ( filter [ 1 ] , dep ) ;
13605: LD_VAR 0 3
13609: PUSH
13610: LD_INT 1
13612: ARRAY
13613: PPUSH
13614: LD_VAR 0 4
13618: PPUSH
13619: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 2 ) ;
13623: LD_VAR 0 3
13627: PUSH
13628: LD_INT 1
13630: ARRAY
13631: PPUSH
13632: LD_INT 2
13634: PPUSH
13635: CALL_OW 183
// AddComExitBuilding ( filter [ 1 ] ) ;
13639: LD_VAR 0 3
13643: PUSH
13644: LD_INT 1
13646: ARRAY
13647: PPUSH
13648: CALL_OW 182
// repeat wait ( 0 0$1 ) ;
13652: LD_INT 35
13654: PPUSH
13655: CALL_OW 67
// until GetClass ( filter [ 1 ] ) = 2 ;
13659: LD_VAR 0 3
13663: PUSH
13664: LD_INT 1
13666: ARRAY
13667: PPUSH
13668: CALL_OW 257
13672: PUSH
13673: LD_INT 2
13675: EQUAL
13676: IFFALSE 13652
// filter := Delete ( filter , 1 ) ;
13678: LD_ADDR_VAR 0 3
13682: PUSH
13683: LD_VAR 0 3
13687: PPUSH
13688: LD_INT 1
13690: PPUSH
13691: CALL_OW 3
13695: ST_TO_ADDR
// end ;
13696: GO 13602
13698: POP
13699: POP
// if IsInUnit ( Cornel ) then
13700: LD_EXP 43
13704: PPUSH
13705: CALL_OW 310
13709: IFFALSE 13787
// begin cargo := IsInUnit ( Cornel ) ;
13711: LD_ADDR_VAR 0 7
13715: PUSH
13716: LD_EXP 43
13720: PPUSH
13721: CALL_OW 310
13725: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13726: LD_VAR 0 7
13730: PPUSH
13731: LD_INT 1
13733: PPUSH
13734: CALL_OW 289
13738: IFFALSE 13749
// ComUnload ( cargo ) ;
13740: LD_VAR 0 7
13744: PPUSH
13745: CALL_OW 159
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13749: LD_EXP 43
13753: PPUSH
13754: LD_INT 235
13756: PPUSH
13757: LD_INT 122
13759: PPUSH
13760: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13764: LD_EXP 43
13768: PPUSH
13769: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13773: LD_EXP 43
13777: PPUSH
13778: LD_VAR 0 4
13782: PPUSH
13783: CALL_OW 180
// end ; ComMoveXY ( Bierezov , 260 , 120 ) ;
13787: LD_EXP 44
13791: PPUSH
13792: LD_INT 260
13794: PPUSH
13795: LD_INT 120
13797: PPUSH
13798: CALL_OW 111
// AddComHold ( Bierezov ) ;
13802: LD_EXP 44
13806: PPUSH
13807: CALL_OW 200
// if Bierezov and dep and not IsInUnit ( Bierezov ) then
13811: LD_EXP 44
13815: PUSH
13816: LD_VAR 0 4
13820: AND
13821: PUSH
13822: LD_EXP 44
13826: PPUSH
13827: CALL_OW 310
13831: NOT
13832: AND
13833: IFFALSE 13849
// AddComEnterUnit ( Bierezov , dep ) ;
13835: LD_EXP 44
13839: PPUSH
13840: LD_VAR 0 4
13844: PPUSH
13845: CALL_OW 180
// has_eng := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) diff Bierezov ;
13849: LD_ADDR_VAR 0 2
13853: PUSH
13854: LD_INT 22
13856: PUSH
13857: LD_INT 4
13859: PUSH
13860: EMPTY
13861: LIST
13862: LIST
13863: PUSH
13864: LD_INT 25
13866: PUSH
13867: LD_INT 2
13869: PUSH
13870: EMPTY
13871: LIST
13872: LIST
13873: PUSH
13874: EMPTY
13875: LIST
13876: LIST
13877: PPUSH
13878: CALL_OW 69
13882: PUSH
13883: LD_EXP 44
13887: DIFF
13888: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13889: LD_INT 35
13891: PPUSH
13892: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13896: LD_ADDR_VAR 0 6
13900: PUSH
13901: LD_INT 10
13903: PPUSH
13904: CALL_OW 435
13908: ST_TO_ADDR
// if crates then
13909: LD_VAR 0 6
13913: IFFALSE 13942
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
13915: LD_VAR 0 2
13919: PPUSH
13920: LD_VAR 0 6
13924: PUSH
13925: LD_INT 1
13927: ARRAY
13928: PPUSH
13929: LD_VAR 0 6
13933: PUSH
13934: LD_INT 2
13936: ARRAY
13937: PPUSH
13938: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
13942: LD_VAR 0 4
13946: PPUSH
13947: CALL_OW 274
13951: PPUSH
13952: LD_INT 1
13954: PPUSH
13955: CALL_OW 275
13959: PUSH
13960: LD_INT 40
13962: GREATEREQUAL
13963: IFFALSE 13889
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
13965: LD_ADDR_VAR 0 5
13969: PUSH
13970: LD_INT 4
13972: PUSH
13973: LD_INT 256
13975: PUSH
13976: LD_INT 111
13978: PUSH
13979: LD_INT 2
13981: PUSH
13982: EMPTY
13983: LIST
13984: LIST
13985: LIST
13986: LIST
13987: PUSH
13988: LD_INT 31
13990: PUSH
13991: LD_INT 243
13993: PUSH
13994: LD_INT 112
13996: PUSH
13997: LD_INT 2
13999: PUSH
14000: EMPTY
14001: LIST
14002: LIST
14003: LIST
14004: LIST
14005: PUSH
14006: EMPTY
14007: LIST
14008: LIST
14009: ST_TO_ADDR
// for i in blist do
14010: LD_ADDR_VAR 0 1
14014: PUSH
14015: LD_VAR 0 5
14019: PUSH
14020: FOR_IN
14021: IFFALSE 14070
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
14023: LD_VAR 0 2
14027: PPUSH
14028: LD_VAR 0 1
14032: PUSH
14033: LD_INT 1
14035: ARRAY
14036: PPUSH
14037: LD_VAR 0 1
14041: PUSH
14042: LD_INT 2
14044: ARRAY
14045: PPUSH
14046: LD_VAR 0 1
14050: PUSH
14051: LD_INT 3
14053: ARRAY
14054: PPUSH
14055: LD_VAR 0 1
14059: PUSH
14060: LD_INT 4
14062: ARRAY
14063: PPUSH
14064: CALL_OW 205
14068: GO 14020
14070: POP
14071: POP
// repeat wait ( 0 0$01 ) ;
14072: LD_INT 35
14074: PPUSH
14075: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
14079: LD_INT 22
14081: PUSH
14082: LD_INT 4
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: PUSH
14089: LD_INT 30
14091: PUSH
14092: LD_INT 4
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PUSH
14099: LD_INT 3
14101: PUSH
14102: LD_INT 57
14104: PUSH
14105: EMPTY
14106: LIST
14107: PUSH
14108: EMPTY
14109: LIST
14110: LIST
14111: PUSH
14112: EMPTY
14113: LIST
14114: LIST
14115: LIST
14116: PPUSH
14117: CALL_OW 69
14121: IFFALSE 14072
// AddComEnterUnit ( filter , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14123: LD_VAR 0 3
14127: PPUSH
14128: LD_INT 22
14130: PUSH
14131: LD_INT 4
14133: PUSH
14134: EMPTY
14135: LIST
14136: LIST
14137: PUSH
14138: LD_INT 30
14140: PUSH
14141: LD_INT 4
14143: PUSH
14144: EMPTY
14145: LIST
14146: LIST
14147: PUSH
14148: EMPTY
14149: LIST
14150: LIST
14151: PPUSH
14152: CALL_OW 69
14156: PUSH
14157: LD_INT 1
14159: ARRAY
14160: PPUSH
14161: CALL_OW 180
// AddComChangeProfession ( filter , 1 ) ;
14165: LD_VAR 0 3
14169: PPUSH
14170: LD_INT 1
14172: PPUSH
14173: CALL_OW 183
// repeat wait ( 0 0$01 ) ;
14177: LD_INT 35
14179: PPUSH
14180: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
14184: LD_INT 22
14186: PUSH
14187: LD_INT 4
14189: PUSH
14190: EMPTY
14191: LIST
14192: LIST
14193: PUSH
14194: LD_INT 30
14196: PUSH
14197: LD_INT 31
14199: PUSH
14200: EMPTY
14201: LIST
14202: LIST
14203: PUSH
14204: LD_INT 3
14206: PUSH
14207: LD_INT 57
14209: PUSH
14210: EMPTY
14211: LIST
14212: PUSH
14213: EMPTY
14214: LIST
14215: LIST
14216: PUSH
14217: EMPTY
14218: LIST
14219: LIST
14220: LIST
14221: PPUSH
14222: CALL_OW 69
14226: IFFALSE 14177
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
14228: LD_ADDR_VAR 0 8
14232: PUSH
14233: LD_EXP 6
14237: PPUSH
14238: LD_INT 25
14240: PUSH
14241: LD_INT 1
14243: PUSH
14244: EMPTY
14245: LIST
14246: LIST
14247: PPUSH
14248: CALL_OW 72
14252: ST_TO_ADDR
// ComExitBuilding ( sol [ 1 ] ) ;
14253: LD_VAR 0 8
14257: PUSH
14258: LD_INT 1
14260: ARRAY
14261: PPUSH
14262: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
14266: LD_VAR 0 8
14270: PUSH
14271: LD_INT 1
14273: ARRAY
14274: PPUSH
14275: LD_INT 22
14277: PUSH
14278: LD_INT 4
14280: PUSH
14281: EMPTY
14282: LIST
14283: LIST
14284: PUSH
14285: LD_INT 30
14287: PUSH
14288: LD_INT 31
14290: PUSH
14291: EMPTY
14292: LIST
14293: LIST
14294: PUSH
14295: EMPTY
14296: LIST
14297: LIST
14298: PPUSH
14299: CALL_OW 69
14303: PUSH
14304: LD_INT 1
14306: ARRAY
14307: PPUSH
14308: CALL_OW 180
// ComEnterUnit ( has_eng , dep ) ;
14312: LD_VAR 0 2
14316: PPUSH
14317: LD_VAR 0 4
14321: PPUSH
14322: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
14326: LD_INT 35
14328: PPUSH
14329: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14333: LD_ADDR_VAR 0 3
14337: PUSH
14338: LD_INT 22
14340: PUSH
14341: LD_INT 4
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: PUSH
14348: LD_INT 21
14350: PUSH
14351: LD_INT 3
14353: PUSH
14354: EMPTY
14355: LIST
14356: LIST
14357: PUSH
14358: LD_INT 3
14360: PUSH
14361: LD_INT 24
14363: PUSH
14364: LD_INT 1000
14366: PUSH
14367: EMPTY
14368: LIST
14369: LIST
14370: PUSH
14371: EMPTY
14372: LIST
14373: LIST
14374: PUSH
14375: EMPTY
14376: LIST
14377: LIST
14378: LIST
14379: PPUSH
14380: CALL_OW 69
14384: ST_TO_ADDR
// if filter and has_eng then
14385: LD_VAR 0 3
14389: PUSH
14390: LD_VAR 0 2
14394: AND
14395: IFFALSE 14461
// begin for i in has_eng do
14397: LD_ADDR_VAR 0 1
14401: PUSH
14402: LD_VAR 0 2
14406: PUSH
14407: FOR_IN
14408: IFFALSE 14457
// begin if IsInUnit ( i ) then
14410: LD_VAR 0 1
14414: PPUSH
14415: CALL_OW 310
14419: IFFALSE 14430
// ComExitBuilding ( i ) ;
14421: LD_VAR 0 1
14425: PPUSH
14426: CALL_OW 122
// Wait ( 3 ) ;
14430: LD_INT 3
14432: PPUSH
14433: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
14437: LD_VAR 0 1
14441: PPUSH
14442: LD_VAR 0 3
14446: PUSH
14447: LD_INT 1
14449: ARRAY
14450: PPUSH
14451: CALL_OW 130
// end ;
14455: GO 14407
14457: POP
14458: POP
// end else
14459: GO 14515
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
14461: LD_VAR 0 2
14465: PUSH
14466: LD_VAR 0 2
14470: PPUSH
14471: LD_INT 56
14473: PUSH
14474: EMPTY
14475: LIST
14476: PPUSH
14477: CALL_OW 72
14481: AND
14482: IFFALSE 14515
// for i in has_eng do
14484: LD_ADDR_VAR 0 1
14488: PUSH
14489: LD_VAR 0 2
14493: PUSH
14494: FOR_IN
14495: IFFALSE 14513
// ComEnterUnit ( i , dep ) ;
14497: LD_VAR 0 1
14501: PPUSH
14502: LD_VAR 0 4
14506: PPUSH
14507: CALL_OW 120
14511: GO 14494
14513: POP
14514: POP
// until cornel_prepared ;
14515: LD_EXP 11
14519: IFFALSE 14326
// end ;
14521: PPOPN 8
14523: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
14524: LD_EXP 11
14528: IFFALSE 14901
14530: GO 14532
14532: DISABLE
14533: LD_INT 0
14535: PPUSH
14536: PPUSH
14537: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
14538: LD_ADDR_VAR 0 2
14542: PUSH
14543: LD_INT 22
14545: PUSH
14546: LD_INT 4
14548: PUSH
14549: EMPTY
14550: LIST
14551: LIST
14552: PUSH
14553: LD_INT 30
14555: PUSH
14556: LD_INT 4
14558: PUSH
14559: EMPTY
14560: LIST
14561: LIST
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: PPUSH
14567: CALL_OW 69
14571: PUSH
14572: LD_INT 1
14574: ARRAY
14575: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
14576: LD_EXP 6
14580: PPUSH
14581: CALL_OW 122
// Wait ( 0 0$03 ) ;
14585: LD_INT 105
14587: PPUSH
14588: CALL_OW 67
// for i in cornel_units do
14592: LD_ADDR_VAR 0 1
14596: PUSH
14597: LD_EXP 6
14601: PUSH
14602: FOR_IN
14603: IFFALSE 14679
// begin if GetClass ( i ) in [ 2 , 3 ] then
14605: LD_VAR 0 1
14609: PPUSH
14610: CALL_OW 257
14614: PUSH
14615: LD_INT 2
14617: PUSH
14618: LD_INT 3
14620: PUSH
14621: EMPTY
14622: LIST
14623: LIST
14624: IN
14625: IFFALSE 14662
// begin ComEnterUnit ( i , arm ) ;
14627: LD_VAR 0 1
14631: PPUSH
14632: LD_VAR 0 2
14636: PPUSH
14637: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
14641: LD_VAR 0 1
14645: PPUSH
14646: LD_INT 1
14648: PPUSH
14649: CALL_OW 183
// AddComExitBuilding ( i ) ;
14653: LD_VAR 0 1
14657: PPUSH
14658: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
14662: LD_VAR 0 1
14666: PPUSH
14667: LD_INT 257
14669: PPUSH
14670: LD_INT 121
14672: PPUSH
14673: CALL_OW 171
// end ;
14677: GO 14602
14679: POP
14680: POP
// Wait ( 1 1$00 ) ;
14681: LD_INT 2100
14683: PPUSH
14684: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
14688: LD_ADDR_VAR 0 3
14692: PUSH
14693: LD_EXP 43
14697: PUSH
14698: LD_EXP 44
14702: ADD
14703: PUSH
14704: LD_EXP 6
14708: ADD
14709: PUSH
14710: LD_EXP 6
14714: PPUSH
14715: LD_INT 21
14717: PUSH
14718: LD_INT 2
14720: PUSH
14721: EMPTY
14722: LIST
14723: LIST
14724: PPUSH
14725: CALL_OW 72
14729: DIFF
14730: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
14731: LD_VAR 0 3
14735: PPUSH
14736: LD_INT 248
14738: PPUSH
14739: LD_INT 85
14741: PPUSH
14742: CALL_OW 111
// AddComHold ( filter ) ;
14746: LD_VAR 0 3
14750: PPUSH
14751: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
14755: LD_INT 35
14757: PPUSH
14758: CALL_OW 67
// until cornel_attack ;
14762: LD_EXP 9
14766: IFFALSE 14755
// ComAgressiveMove ( filter , 209 , 63 ) ;
14768: LD_VAR 0 3
14772: PPUSH
14773: LD_INT 209
14775: PPUSH
14776: LD_INT 63
14778: PPUSH
14779: CALL_OW 114
// ComAgressiveMove ( Cornel , 208 , 62 ) ;
14783: LD_EXP 43
14787: PPUSH
14788: LD_INT 208
14790: PPUSH
14791: LD_INT 62
14793: PPUSH
14794: CALL_OW 114
// AddComHold ( Cornel ) ;
14798: LD_EXP 43
14802: PPUSH
14803: CALL_OW 200
// if Bierezov then
14807: LD_EXP 44
14811: IFFALSE 14901
// begin filter := filter diff Bierezov ;
14813: LD_ADDR_VAR 0 3
14817: PUSH
14818: LD_VAR 0 3
14822: PUSH
14823: LD_EXP 44
14827: DIFF
14828: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
14829: LD_EXP 44
14833: PPUSH
14834: LD_INT 6
14836: PPUSH
14837: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
14841: LD_EXP 44
14845: PPUSH
14846: LD_INT 235
14848: PPUSH
14849: LD_INT 60
14851: PPUSH
14852: CALL_OW 111
// AddComHold ( Bierezov ) ;
14856: LD_EXP 44
14860: PPUSH
14861: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
14865: LD_EXP 44
14869: PPUSH
14870: LD_INT 350
14872: PPUSH
14873: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
14877: LD_EXP 44
14881: PPUSH
14882: LD_INT 198
14884: PPUSH
14885: LD_INT 28
14887: PPUSH
14888: CALL_OW 171
// AddComHold ( Bierezov ) ;
14892: LD_EXP 44
14896: PPUSH
14897: CALL_OW 200
// end ; end ; end_of_file
14901: PPOPN 3
14903: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
14904: LD_EXP 52
14908: PUSH
14909: LD_EXP 30
14913: NOT
14914: AND
14915: PUSH
14916: LD_EXP 31
14920: NOT
14921: AND
14922: IFFALSE 15372
14924: GO 14926
14926: DISABLE
14927: LD_INT 0
14929: PPUSH
14930: PPUSH
14931: PPUSH
14932: PPUSH
// begin enable ;
14933: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14934: LD_ADDR_VAR 0 4
14938: PUSH
14939: LD_INT 81
14941: PUSH
14942: LD_INT 3
14944: PUSH
14945: EMPTY
14946: LIST
14947: LIST
14948: PPUSH
14949: CALL_OW 69
14953: ST_TO_ADDR
// for i = 1 to ru_patrol do
14954: LD_ADDR_VAR 0 2
14958: PUSH
14959: DOUBLE
14960: LD_INT 1
14962: DEC
14963: ST_TO_ADDR
14964: LD_EXP 52
14968: PUSH
14969: FOR_TO
14970: IFFALSE 15370
// begin un := ru_patrol [ i ] ;
14972: LD_ADDR_VAR 0 1
14976: PUSH
14977: LD_EXP 52
14981: PUSH
14982: LD_VAR 0 2
14986: ARRAY
14987: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14988: LD_VAR 0 1
14992: PPUSH
14993: LD_INT 13
14995: PPUSH
14996: CALL_OW 308
15000: IFFALSE 15105
// begin if not ru_alert then
15002: LD_EXP 59
15006: NOT
15007: IFFALSE 15017
// ru_alert := true ;
15009: LD_ADDR_EXP 59
15013: PUSH
15014: LD_INT 1
15016: ST_TO_ADDR
// if not See ( 1 , un ) then
15017: LD_INT 1
15019: PPUSH
15020: LD_VAR 0 1
15024: PPUSH
15025: CALL_OW 292
15029: NOT
15030: IFFALSE 15044
// SetLives ( un , 1000 ) ;
15032: LD_VAR 0 1
15036: PPUSH
15037: LD_INT 1000
15039: PPUSH
15040: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
15044: LD_ADDR_EXP 52
15048: PUSH
15049: LD_EXP 52
15053: PUSH
15054: LD_VAR 0 1
15058: DIFF
15059: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15060: LD_VAR 0 1
15064: PPUSH
15065: LD_INT 22
15067: PUSH
15068: LD_INT 3
15070: PUSH
15071: EMPTY
15072: LIST
15073: LIST
15074: PUSH
15075: LD_INT 30
15077: PUSH
15078: LD_INT 4
15080: PUSH
15081: EMPTY
15082: LIST
15083: LIST
15084: PUSH
15085: EMPTY
15086: LIST
15087: LIST
15088: PPUSH
15089: CALL_OW 69
15093: PPUSH
15094: CALL 1047 0 1
15098: PPUSH
15099: CALL_OW 120
// continue ;
15103: GO 14969
// end ; if IsOk ( un ) and not HasTask ( un ) then
15105: LD_VAR 0 1
15109: PPUSH
15110: CALL_OW 302
15114: PUSH
15115: LD_VAR 0 1
15119: PPUSH
15120: CALL_OW 314
15124: NOT
15125: AND
15126: IFFALSE 15219
// begin for j = 1 to ru_firepoints_south [ i ] do
15128: LD_ADDR_VAR 0 3
15132: PUSH
15133: DOUBLE
15134: LD_INT 1
15136: DEC
15137: ST_TO_ADDR
15138: LD_EXP 58
15142: PUSH
15143: LD_VAR 0 2
15147: ARRAY
15148: PUSH
15149: FOR_TO
15150: IFFALSE 15217
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
15152: LD_VAR 0 1
15156: PPUSH
15157: LD_EXP 58
15161: PUSH
15162: LD_VAR 0 2
15166: ARRAY
15167: PUSH
15168: LD_VAR 0 3
15172: ARRAY
15173: PUSH
15174: LD_INT 1
15176: ARRAY
15177: PPUSH
15178: LD_EXP 58
15182: PUSH
15183: LD_VAR 0 2
15187: ARRAY
15188: PUSH
15189: LD_VAR 0 3
15193: ARRAY
15194: PUSH
15195: LD_INT 2
15197: ARRAY
15198: PPUSH
15199: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
15203: LD_VAR 0 1
15207: PPUSH
15208: LD_INT 70
15210: PPUSH
15211: CALL_OW 202
// end ;
15215: GO 15149
15217: POP
15218: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15219: LD_VAR 0 1
15223: PPUSH
15224: CALL_OW 256
15228: PUSH
15229: LD_INT 700
15231: LESS
15232: PUSH
15233: LD_VAR 0 1
15237: PPUSH
15238: LD_INT 13
15240: PPUSH
15241: CALL_OW 308
15245: NOT
15246: AND
15247: IFFALSE 15299
// begin ComMoveToArea ( un , retreatArea ) ;
15249: LD_VAR 0 1
15253: PPUSH
15254: LD_INT 13
15256: PPUSH
15257: CALL_OW 113
// if not ru_alert_xy then
15261: LD_EXP 60
15265: NOT
15266: IFFALSE 15297
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
15268: LD_ADDR_EXP 60
15272: PUSH
15273: LD_VAR 0 1
15277: PPUSH
15278: CALL_OW 250
15282: PUSH
15283: LD_VAR 0 1
15287: PPUSH
15288: CALL_OW 251
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: ST_TO_ADDR
// end else
15297: GO 15368
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15299: LD_VAR 0 1
15303: PPUSH
15304: LD_VAR 0 4
15308: PPUSH
15309: LD_VAR 0 1
15313: PPUSH
15314: CALL_OW 74
15318: PPUSH
15319: CALL_OW 296
15323: PUSH
15324: LD_INT 9
15326: LESS
15327: PUSH
15328: LD_VAR 0 1
15332: PPUSH
15333: CALL_OW 256
15337: PUSH
15338: LD_INT 500
15340: GREATER
15341: AND
15342: IFFALSE 15368
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15344: LD_VAR 0 1
15348: PPUSH
15349: LD_VAR 0 4
15353: PPUSH
15354: LD_VAR 0 1
15358: PPUSH
15359: CALL_OW 74
15363: PPUSH
15364: CALL_OW 115
// end ;
15368: GO 14969
15370: POP
15371: POP
// end ;
15372: PPOPN 4
15374: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
15375: LD_EXP 59
15379: PUSH
15380: LD_EXP 60
15384: AND
15385: PUSH
15386: LD_EXP 30
15390: NOT
15391: AND
15392: PUSH
15393: LD_EXP 31
15397: NOT
15398: AND
15399: IFFALSE 15609
15401: GO 15403
15403: DISABLE
15404: LD_INT 0
15406: PPUSH
15407: PPUSH
// begin enable ;
15408: ENABLE
// if not ru_vehicles then
15409: LD_EXP 55
15413: NOT
15414: IFFALSE 15418
// exit ;
15416: GO 15609
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15418: LD_ADDR_VAR 0 2
15422: PUSH
15423: LD_INT 81
15425: PUSH
15426: LD_INT 3
15428: PUSH
15429: EMPTY
15430: LIST
15431: LIST
15432: PPUSH
15433: CALL_OW 69
15437: ST_TO_ADDR
// if ru_vehicles then
15438: LD_EXP 55
15442: IFFALSE 15609
// begin for i in ru_vehicles do
15444: LD_ADDR_VAR 0 1
15448: PUSH
15449: LD_EXP 55
15453: PUSH
15454: FOR_IN
15455: IFFALSE 15607
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
15457: LD_VAR 0 1
15461: PPUSH
15462: CALL_OW 302
15466: PUSH
15467: LD_VAR 0 1
15471: PPUSH
15472: LD_VAR 0 2
15476: PPUSH
15477: LD_VAR 0 1
15481: PPUSH
15482: CALL_OW 74
15486: PPUSH
15487: CALL_OW 296
15491: PUSH
15492: LD_INT 9
15494: LESS
15495: AND
15496: IFFALSE 15522
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15498: LD_VAR 0 1
15502: PPUSH
15503: LD_VAR 0 2
15507: PPUSH
15508: LD_VAR 0 1
15512: PPUSH
15513: CALL_OW 74
15517: PPUSH
15518: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
15522: LD_VAR 0 1
15526: PPUSH
15527: CALL_OW 314
15531: NOT
15532: PUSH
15533: LD_VAR 0 1
15537: PPUSH
15538: CALL_OW 302
15542: AND
15543: PUSH
15544: LD_VAR 0 1
15548: PPUSH
15549: LD_EXP 60
15553: PUSH
15554: LD_INT 1
15556: ARRAY
15557: PPUSH
15558: LD_EXP 60
15562: PUSH
15563: LD_INT 2
15565: ARRAY
15566: PPUSH
15567: CALL_OW 297
15571: PUSH
15572: LD_INT 10
15574: GREATER
15575: AND
15576: IFFALSE 15605
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
15578: LD_VAR 0 1
15582: PPUSH
15583: LD_EXP 60
15587: PUSH
15588: LD_INT 1
15590: ARRAY
15591: PPUSH
15592: LD_EXP 60
15596: PUSH
15597: LD_INT 2
15599: ARRAY
15600: PPUSH
15601: CALL_OW 114
// end ;
15605: GO 15454
15607: POP
15608: POP
// end ; end ;
15609: PPOPN 2
15611: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
15612: LD_EXP 60
15616: PUSH
15617: LD_EXP 59
15621: AND
15622: PUSH
15623: LD_INT 3
15625: PPUSH
15626: CALL_OW 463
15630: NOT
15631: AND
15632: PUSH
15633: LD_EXP 30
15637: NOT
15638: AND
15639: PUSH
15640: LD_EXP 31
15644: NOT
15645: AND
15646: IFFALSE 15741
15648: GO 15650
15650: DISABLE
15651: LD_INT 0
15653: PPUSH
// begin enable ;
15654: ENABLE
// ru_alert_xy := false ;
15655: LD_ADDR_EXP 60
15659: PUSH
15660: LD_INT 0
15662: ST_TO_ADDR
// ru_alert := false ;
15663: LD_ADDR_EXP 59
15667: PUSH
15668: LD_INT 0
15670: ST_TO_ADDR
// if ru_vehicles then
15671: LD_EXP 55
15675: IFFALSE 15741
// for i in ru_vehicles do
15677: LD_ADDR_VAR 0 1
15681: PUSH
15682: LD_EXP 55
15686: PUSH
15687: FOR_IN
15688: IFFALSE 15739
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
15690: LD_VAR 0 1
15694: PPUSH
15695: CALL_OW 302
15699: PUSH
15700: LD_VAR 0 1
15704: PPUSH
15705: LD_INT 89
15707: PPUSH
15708: LD_INT 36
15710: PPUSH
15711: CALL_OW 297
15715: PUSH
15716: LD_INT 10
15718: GREATER
15719: AND
15720: IFFALSE 15737
// ComMoveXY ( i , 89 , 36 ) ;
15722: LD_VAR 0 1
15726: PPUSH
15727: LD_INT 89
15729: PPUSH
15730: LD_INT 36
15732: PPUSH
15733: CALL_OW 111
15737: GO 15687
15739: POP
15740: POP
// end ;
15741: PPOPN 1
15743: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
15744: LD_EXP 54
15748: PUSH
15749: LD_EXP 30
15753: NOT
15754: AND
15755: PUSH
15756: LD_EXP 31
15760: NOT
15761: AND
15762: IFFALSE 16046
15764: GO 15766
15766: DISABLE
15767: LD_INT 0
15769: PPUSH
15770: PPUSH
15771: PPUSH
// begin enable ;
15772: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15773: LD_ADDR_VAR 0 3
15777: PUSH
15778: LD_INT 81
15780: PUSH
15781: LD_INT 3
15783: PUSH
15784: EMPTY
15785: LIST
15786: LIST
15787: PPUSH
15788: CALL_OW 69
15792: ST_TO_ADDR
// for i = 1 to ru_forest do
15793: LD_ADDR_VAR 0 1
15797: PUSH
15798: DOUBLE
15799: LD_INT 1
15801: DEC
15802: ST_TO_ADDR
15803: LD_EXP 54
15807: PUSH
15808: FOR_TO
15809: IFFALSE 16044
// begin un := ru_forest [ i ] ;
15811: LD_ADDR_VAR 0 2
15815: PUSH
15816: LD_EXP 54
15820: PUSH
15821: LD_VAR 0 1
15825: ARRAY
15826: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15827: LD_VAR 0 2
15831: PPUSH
15832: LD_INT 13
15834: PPUSH
15835: CALL_OW 308
15839: IFFALSE 15929
// begin if not See ( 1 , un ) then
15841: LD_INT 1
15843: PPUSH
15844: LD_VAR 0 2
15848: PPUSH
15849: CALL_OW 292
15853: NOT
15854: IFFALSE 15868
// SetLives ( un , 1000 ) ;
15856: LD_VAR 0 2
15860: PPUSH
15861: LD_INT 1000
15863: PPUSH
15864: CALL_OW 234
// ru_forest := ru_forest diff un ;
15868: LD_ADDR_EXP 54
15872: PUSH
15873: LD_EXP 54
15877: PUSH
15878: LD_VAR 0 2
15882: DIFF
15883: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15884: LD_VAR 0 2
15888: PPUSH
15889: LD_INT 22
15891: PUSH
15892: LD_INT 3
15894: PUSH
15895: EMPTY
15896: LIST
15897: LIST
15898: PUSH
15899: LD_INT 30
15901: PUSH
15902: LD_INT 4
15904: PUSH
15905: EMPTY
15906: LIST
15907: LIST
15908: PUSH
15909: EMPTY
15910: LIST
15911: LIST
15912: PPUSH
15913: CALL_OW 69
15917: PPUSH
15918: CALL 1047 0 1
15922: PPUSH
15923: CALL_OW 120
// continue ;
15927: GO 15808
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15929: LD_VAR 0 2
15933: PPUSH
15934: CALL_OW 256
15938: PUSH
15939: LD_INT 700
15941: LESS
15942: PUSH
15943: LD_VAR 0 2
15947: PPUSH
15948: LD_INT 13
15950: PPUSH
15951: CALL_OW 308
15955: NOT
15956: AND
15957: IFFALSE 15973
// ComMoveToArea ( un , retreatArea ) else
15959: LD_VAR 0 2
15963: PPUSH
15964: LD_INT 13
15966: PPUSH
15967: CALL_OW 113
15971: GO 16042
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15973: LD_VAR 0 2
15977: PPUSH
15978: LD_VAR 0 3
15982: PPUSH
15983: LD_VAR 0 2
15987: PPUSH
15988: CALL_OW 74
15992: PPUSH
15993: CALL_OW 296
15997: PUSH
15998: LD_INT 9
16000: LESS
16001: PUSH
16002: LD_VAR 0 2
16006: PPUSH
16007: CALL_OW 256
16011: PUSH
16012: LD_INT 500
16014: GREATER
16015: AND
16016: IFFALSE 16042
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
16018: LD_VAR 0 2
16022: PPUSH
16023: LD_VAR 0 3
16027: PPUSH
16028: LD_VAR 0 2
16032: PPUSH
16033: CALL_OW 74
16037: PPUSH
16038: CALL_OW 115
// end ;
16042: GO 15808
16044: POP
16045: POP
// end ;
16046: PPOPN 3
16048: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
16049: LD_EXP 31
16053: NOT
16054: IFFALSE 16175
16056: GO 16058
16058: DISABLE
16059: LD_INT 0
16061: PPUSH
16062: PPUSH
// begin enable ;
16063: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
16064: LD_ADDR_VAR 0 2
16068: PUSH
16069: LD_INT 22
16071: PUSH
16072: LD_INT 3
16074: PUSH
16075: EMPTY
16076: LIST
16077: LIST
16078: PUSH
16079: LD_INT 21
16081: PUSH
16082: LD_INT 3
16084: PUSH
16085: EMPTY
16086: LIST
16087: LIST
16088: PUSH
16089: EMPTY
16090: LIST
16091: LIST
16092: PPUSH
16093: CALL_OW 69
16097: ST_TO_ADDR
// if filter then
16098: LD_VAR 0 2
16102: IFFALSE 16175
// for i in filter do
16104: LD_ADDR_VAR 0 1
16108: PUSH
16109: LD_VAR 0 2
16113: PUSH
16114: FOR_IN
16115: IFFALSE 16173
// if GetLives ( i ) < 990 then
16117: LD_VAR 0 1
16121: PPUSH
16122: CALL_OW 256
16126: PUSH
16127: LD_INT 990
16129: LESS
16130: IFFALSE 16171
// begin ru_alert := true ;
16132: LD_ADDR_EXP 59
16136: PUSH
16137: LD_INT 1
16139: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
16140: LD_ADDR_EXP 60
16144: PUSH
16145: LD_VAR 0 1
16149: PPUSH
16150: CALL_OW 250
16154: PUSH
16155: LD_VAR 0 1
16159: PPUSH
16160: CALL_OW 251
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: ST_TO_ADDR
// break ;
16169: GO 16173
// end ;
16171: GO 16114
16173: POP
16174: POP
// end ;
16175: PPOPN 2
16177: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
16178: LD_EXP 30
16182: IFFALSE 16331
16184: GO 16186
16186: DISABLE
16187: LD_INT 0
16189: PPUSH
16190: PPUSH
16191: PPUSH
16192: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
16193: LD_ADDR_VAR 0 4
16197: PUSH
16198: LD_EXP 55
16202: PUSH
16203: LD_EXP 54
16207: ADD
16208: PUSH
16209: LD_EXP 52
16213: ADD
16214: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
16215: LD_ADDR_VAR 0 3
16219: PUSH
16220: LD_INT 3
16222: PPUSH
16223: LD_INT 81
16225: PUSH
16226: LD_INT 3
16228: PUSH
16229: EMPTY
16230: LIST
16231: LIST
16232: PPUSH
16233: CALL_OW 70
16237: ST_TO_ADDR
// if filter and enemy then
16238: LD_VAR 0 4
16242: PUSH
16243: LD_VAR 0 3
16247: AND
16248: IFFALSE 16331
// repeat wait ( 0 0$01 ) ;
16250: LD_INT 35
16252: PPUSH
16253: CALL_OW 67
// for i in filter do
16257: LD_ADDR_VAR 0 1
16261: PUSH
16262: LD_VAR 0 4
16266: PUSH
16267: FOR_IN
16268: IFFALSE 16296
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16270: LD_VAR 0 1
16274: PPUSH
16275: LD_VAR 0 3
16279: PPUSH
16280: LD_VAR 0 1
16284: PPUSH
16285: CALL_OW 74
16289: PPUSH
16290: CALL_OW 115
// end ;
16294: GO 16267
16296: POP
16297: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
16298: LD_INT 3
16300: PPUSH
16301: LD_INT 81
16303: PUSH
16304: LD_INT 3
16306: PUSH
16307: EMPTY
16308: LIST
16309: LIST
16310: PPUSH
16311: CALL_OW 70
16315: PUSH
16316: LD_INT 0
16318: EQUAL
16319: PUSH
16320: LD_VAR 0 4
16324: PUSH
16325: LD_INT 0
16327: EQUAL
16328: OR
16329: IFFALSE 16250
// end ;
16331: PPOPN 4
16333: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) do var i ;
16334: LD_EXP 25
16338: PUSH
16339: LD_INT 22
16341: PUSH
16342: LD_INT 4
16344: PUSH
16345: EMPTY
16346: LIST
16347: LIST
16348: PUSH
16349: LD_INT 30
16351: PUSH
16352: LD_INT 4
16354: PUSH
16355: EMPTY
16356: LIST
16357: LIST
16358: PUSH
16359: LD_INT 3
16361: PUSH
16362: LD_INT 57
16364: PUSH
16365: EMPTY
16366: LIST
16367: PUSH
16368: EMPTY
16369: LIST
16370: LIST
16371: PUSH
16372: EMPTY
16373: LIST
16374: LIST
16375: LIST
16376: PPUSH
16377: CALL_OW 69
16381: AND
16382: IFFALSE 16431
16384: GO 16386
16386: DISABLE
16387: LD_INT 0
16389: PPUSH
// begin if not ru_cornel_attack then
16390: LD_EXP 57
16394: NOT
16395: IFFALSE 16399
// exit ;
16397: GO 16431
// for i in ru_cornel_attack do
16399: LD_ADDR_VAR 0 1
16403: PUSH
16404: LD_EXP 57
16408: PUSH
16409: FOR_IN
16410: IFFALSE 16429
// ComAgressiveMove ( i , 258 , 119 ) ;
16412: LD_VAR 0 1
16416: PPUSH
16417: LD_INT 258
16419: PPUSH
16420: LD_INT 119
16422: PPUSH
16423: CALL_OW 114
16427: GO 16409
16429: POP
16430: POP
// end ; end_of_file
16431: PPOPN 1
16433: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
16434: LD_EXP 5
16438: PUSH
16439: LD_EXP 9
16443: NOT
16444: AND
16445: PUSH
16446: LD_EXP 19
16450: AND
16451: IFFALSE 16563
16453: GO 16455
16455: DISABLE
16456: LD_INT 0
16458: PPUSH
// begin enable ;
16459: ENABLE
// crates_counter := crates_counter - 50 ;
16460: LD_ADDR_EXP 19
16464: PUSH
16465: LD_EXP 19
16469: PUSH
16470: LD_INT 50
16472: MINUS
16473: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
16474: LD_INT 8
16476: PPUSH
16477: LD_INT 2
16479: PPUSH
16480: LD_INT 5
16482: PPUSH
16483: CALL_OW 12
16487: PPUSH
16488: LD_INT 1
16490: PPUSH
16491: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
16495: LD_INT 1785
16497: PPUSH
16498: LD_INT 2345
16500: PPUSH
16501: CALL_OW 12
16505: PPUSH
16506: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
16510: LD_ADDR_VAR 0 1
16514: PUSH
16515: LD_INT 1
16517: PPUSH
16518: LD_OWVAR 67
16522: PUSH
16523: LD_INT 2
16525: PLUS
16526: PPUSH
16527: CALL_OW 12
16531: ST_TO_ADDR
// if r < 3 then
16532: LD_VAR 0 1
16536: PUSH
16537: LD_INT 3
16539: LESS
16540: IFFALSE 16563
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
16542: LD_INT 4
16544: PPUSH
16545: LD_INT 1
16547: PPUSH
16548: LD_INT 5
16550: PPUSH
16551: CALL_OW 12
16555: PPUSH
16556: LD_INT 1
16558: PPUSH
16559: CALL_OW 55
// end ;
16563: PPOPN 1
16565: END
// every 0 0$01 trigger cornel_active do
16566: LD_EXP 8
16570: IFFALSE 16659
16572: GO 16574
16574: DISABLE
// begin Wait ( 0 0$03 ) ;
16575: LD_INT 105
16577: PPUSH
16578: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16582: LD_INT 2
16584: PPUSH
16585: LD_INT 5
16587: PPUSH
16588: CALL_OW 12
16592: PPUSH
16593: LD_INT 10
16595: PPUSH
16596: LD_INT 1
16598: PPUSH
16599: CALL_OW 55
// Wait ( 0 0$13 ) ;
16603: LD_INT 455
16605: PPUSH
16606: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16610: LD_INT 2
16612: PPUSH
16613: LD_INT 5
16615: PPUSH
16616: CALL_OW 12
16620: PPUSH
16621: LD_INT 10
16623: PPUSH
16624: LD_INT 1
16626: PPUSH
16627: CALL_OW 55
// Wait ( 0 0$16 ) ;
16631: LD_INT 560
16633: PPUSH
16634: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16638: LD_INT 2
16640: PPUSH
16641: LD_INT 5
16643: PPUSH
16644: CALL_OW 12
16648: PPUSH
16649: LD_INT 10
16651: PPUSH
16652: LD_INT 1
16654: PPUSH
16655: CALL_OW 55
// end ; end_of_file
16659: END
// every 0 0$01 trigger cornel_prepared do
16660: LD_EXP 11
16664: IFFALSE 16723
16666: GO 16668
16668: DISABLE
// begin enable ;
16669: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
16670: LD_ADDR_OWVAR 47
16674: PUSH
16675: LD_STRING #Am03-1
16677: PUSH
16678: LD_EXP 10
16682: PUSH
16683: EMPTY
16684: LIST
16685: LIST
16686: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
16687: LD_ADDR_EXP 10
16691: PUSH
16692: LD_EXP 10
16696: PPUSH
16697: LD_STRING -
16699: PPUSH
16700: CALL 1117 0 2
16704: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
16705: LD_EXP 10
16709: PUSH
16710: LD_INT 0
16712: EQUAL
16713: IFFALSE 16723
// begin Display_Strings := [ ] ;
16715: LD_ADDR_OWVAR 47
16719: PUSH
16720: EMPTY
16721: ST_TO_ADDR
// disable ;
16722: DISABLE
// end ; end ;
16723: END
// every 0 0$01 trigger debug and debug_strings do
16724: LD_EXP 1
16728: PUSH
16729: LD_OWVAR 48
16733: AND
16734: IFFALSE 16750
16736: GO 16738
16738: DISABLE
// begin enable ;
16739: ENABLE
// Display_Strings := debug_strings ;
16740: LD_ADDR_OWVAR 47
16744: PUSH
16745: LD_OWVAR 48
16749: ST_TO_ADDR
// end ; end_of_file
16750: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
16751: LD_VAR 0 1
16755: PPUSH
16756: CALL_OW 255
16760: PUSH
16761: LD_INT 1
16763: EQUAL
16764: PUSH
16765: LD_EXP 13
16769: NOT
16770: AND
16771: IFFALSE 16781
// solar_builded := true ;
16773: LD_ADDR_EXP 13
16777: PUSH
16778: LD_INT 1
16780: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
16781: LD_VAR 0 1
16785: PPUSH
16786: CALL_OW 255
16790: PUSH
16791: LD_INT 1
16793: EQUAL
16794: PUSH
16795: LD_EXP 28
16799: AND
16800: IFFALSE 16833
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
16802: LD_ADDR_EXP 28
16806: PUSH
16807: LD_EXP 28
16811: PUSH
16812: LD_INT 1750
16814: PUSH
16815: LD_INT 1400
16817: PUSH
16818: LD_INT 1225
16820: PUSH
16821: EMPTY
16822: LIST
16823: LIST
16824: LIST
16825: PUSH
16826: LD_OWVAR 67
16830: ARRAY
16831: PLUS
16832: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
16833: LD_VAR 0 1
16837: PPUSH
16838: CALL_OW 255
16842: PUSH
16843: LD_INT 3
16845: EQUAL
16846: IFFALSE 16864
// ru_vehicles := ru_vehicles ^ veh ;
16848: LD_ADDR_EXP 55
16852: PUSH
16853: LD_EXP 55
16857: PUSH
16858: LD_VAR 0 1
16862: ADD
16863: ST_TO_ADDR
// end ;
16864: PPOPN 2
16866: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
16867: LD_VAR 0 1
16871: PUSH
16872: LD_EXP 52
16876: IN
16877: IFFALSE 16895
// ru_patrol := ru_patrol diff un ;
16879: LD_ADDR_EXP 52
16883: PUSH
16884: LD_EXP 52
16888: PUSH
16889: LD_VAR 0 1
16893: DIFF
16894: ST_TO_ADDR
// if un in ru_forest then
16895: LD_VAR 0 1
16899: PUSH
16900: LD_EXP 54
16904: IN
16905: IFFALSE 16923
// ru_forest := ru_forest diff un ;
16907: LD_ADDR_EXP 54
16911: PUSH
16912: LD_EXP 54
16916: PUSH
16917: LD_VAR 0 1
16921: DIFF
16922: ST_TO_ADDR
// if un in ru_vehicles then
16923: LD_VAR 0 1
16927: PUSH
16928: LD_EXP 55
16932: IN
16933: IFFALSE 17008
// begin ru_vehicles := ru_vehicles diff un ;
16935: LD_ADDR_EXP 55
16939: PUSH
16940: LD_EXP 55
16944: PUSH
16945: LD_VAR 0 1
16949: DIFF
16950: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
16951: LD_ADDR_EXP 56
16955: PUSH
16956: LD_EXP 56
16960: PUSH
16961: LD_VAR 0 1
16965: PPUSH
16966: CALL_OW 265
16970: PUSH
16971: LD_VAR 0 1
16975: PPUSH
16976: CALL_OW 262
16980: PUSH
16981: LD_VAR 0 1
16985: PPUSH
16986: CALL_OW 263
16990: PUSH
16991: LD_VAR 0 1
16995: PPUSH
16996: CALL_OW 264
17000: PUSH
17001: EMPTY
17002: LIST
17003: LIST
17004: LIST
17005: LIST
17006: ADD
17007: ST_TO_ADDR
// end ; if un = JMM then
17008: LD_VAR 0 1
17012: PUSH
17013: LD_EXP 36
17017: EQUAL
17018: IFFALSE 17027
// YouLost ( 0 ) ;
17020: LD_STRING 0
17022: PPUSH
17023: CALL_OW 104
// if un = us_dep_west then
17027: LD_VAR 0 1
17031: PUSH
17032: LD_INT 1
17034: EQUAL
17035: IFFALSE 17044
// YouLost ( 2 ) ;
17037: LD_STRING 2
17039: PPUSH
17040: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
17044: LD_VAR 0 1
17048: PPUSH
17049: CALL_OW 255
17053: PUSH
17054: LD_INT 8
17056: EQUAL
17057: PUSH
17058: LD_EXP 5
17062: NOT
17063: AND
17064: IFFALSE 17073
// YouLost ( 4 ) ;
17066: LD_STRING 4
17068: PPUSH
17069: CALL_OW 104
// if un in jmm_units then
17073: LD_VAR 0 1
17077: PUSH
17078: LD_EXP 4
17082: IN
17083: IFFALSE 17099
// lose_counter := lose_counter + 1 ;
17085: LD_ADDR_EXP 33
17089: PUSH
17090: LD_EXP 33
17094: PUSH
17095: LD_INT 1
17097: PLUS
17098: ST_TO_ADDR
// end ;
17099: PPOPN 1
17101: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
17102: LD_INT 0
17104: PPUSH
17105: PPUSH
// begin if GetSide ( driver ) = 3 then
17106: LD_VAR 0 1
17110: PPUSH
17111: CALL_OW 255
17115: PUSH
17116: LD_INT 3
17118: EQUAL
17119: IFFALSE 17197
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
17121: LD_ADDR_VAR 0 6
17125: PUSH
17126: LD_INT 22
17128: PUSH
17129: LD_INT 3
17131: PUSH
17132: EMPTY
17133: LIST
17134: LIST
17135: PUSH
17136: LD_INT 30
17138: PUSH
17139: LD_INT 3
17141: PUSH
17142: EMPTY
17143: LIST
17144: LIST
17145: PUSH
17146: EMPTY
17147: LIST
17148: LIST
17149: PPUSH
17150: CALL_OW 69
17154: PPUSH
17155: CALL 1047 0 1
17159: ST_TO_ADDR
// if place then
17160: LD_VAR 0 6
17164: IFFALSE 17182
// ComEnterUnit ( driver , place ) else
17166: LD_VAR 0 1
17170: PPUSH
17171: LD_VAR 0 6
17175: PPUSH
17176: CALL_OW 120
17180: GO 17197
// ComMoveXY ( driver , 70 , 22 ) ;
17182: LD_VAR 0 1
17186: PPUSH
17187: LD_INT 70
17189: PPUSH
17190: LD_INT 22
17192: PPUSH
17193: CALL_OW 111
// end ; end ;
17197: PPOPN 6
17199: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and ( s2 = 4 or ( s2 = 8 and not jmm_on_west ) ) then
17200: LD_VAR 0 1
17204: PUSH
17205: LD_INT 1
17207: EQUAL
17208: PUSH
17209: LD_VAR 0 2
17213: PUSH
17214: LD_INT 4
17216: EQUAL
17217: PUSH
17218: LD_VAR 0 2
17222: PUSH
17223: LD_INT 8
17225: EQUAL
17226: PUSH
17227: LD_EXP 5
17231: NOT
17232: AND
17233: OR
17234: AND
17235: IFFALSE 17244
// YouLost ( 5 ) ;
17237: LD_STRING 5
17239: PPUSH
17240: CALL_OW 104
// end ;
17244: PPOPN 2
17246: END
// every 0 0$01 trigger save_counter + ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
17247: LD_EXP 35
17251: PUSH
17252: LD_INT 22
17254: PUSH
17255: LD_INT 1
17257: PUSH
17258: EMPTY
17259: LIST
17260: LIST
17261: PUSH
17262: LD_INT 21
17264: PUSH
17265: LD_INT 1
17267: PUSH
17268: EMPTY
17269: LIST
17270: LIST
17271: PUSH
17272: EMPTY
17273: LIST
17274: LIST
17275: PPUSH
17276: CALL_OW 69
17280: PUSH
17281: LD_INT 22
17283: PUSH
17284: LD_INT 8
17286: PUSH
17287: EMPTY
17288: LIST
17289: LIST
17290: PUSH
17291: LD_INT 21
17293: PUSH
17294: LD_INT 1
17296: PUSH
17297: EMPTY
17298: LIST
17299: LIST
17300: PUSH
17301: EMPTY
17302: LIST
17303: LIST
17304: PPUSH
17305: CALL_OW 69
17309: ADD
17310: PLUS
17311: PUSH
17312: LD_INT 5
17314: LESS
17315: IFFALSE 17327
17317: GO 17319
17319: DISABLE
// YouLost ( 1 ) ;
17320: LD_STRING 1
17322: PPUSH
17323: CALL_OW 104
17327: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
17328: LD_INT 1
17330: PPUSH
17331: CALL_OW 255
17335: PUSH
17336: LD_INT 3
17338: EQUAL
17339: IFFALSE 17351
17341: GO 17343
17343: DISABLE
// YouLost ( 3 ) ;
17344: LD_STRING 3
17346: PPUSH
17347: CALL_OW 104
17351: END
