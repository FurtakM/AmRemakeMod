// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 33 0 0
// SetDiplomacy ;
   8: CALL 297 0 0
// PrepareRussian ;
  12: CALL 2864 0 0
// PrepareAmerican ;
  16: CALL 1121 0 0
// PrepareCornell ;
  20: CALL 2145 0 0
// PrepareWesternBase ;
  24: CALL 2371 0 0
// Action ;
  28: CALL 3921 0 0
// end ;
  32: END
// export debug ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end ; function Init ; begin
  33: LD_INT 0
  35: PPUSH
// debug := true ;
  36: LD_ADDR_EXP 1
  40: PUSH
  41: LD_INT 1
  43: ST_TO_ADDR
// jmm_units := 0 ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// cornel_units := 0 ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// bierezov_exist := false ;
  60: LD_ADDR_EXP 5
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// jmm_on_west := false ;
  68: LD_ADDR_EXP 3
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// cornel_active := false ;
  76: LD_ADDR_EXP 6
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// cornel_attack := false ;
  84: LD_ADDR_EXP 7
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// cornel_prepared := false ;
  92: LD_ADDR_EXP 9
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 100: LD_ADDR_EXP 8
 104: PUSH
 105: LD_INT 4200
 107: ST_TO_ADDR
// frank_can_return := false ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// solar_builded := false ;
 116: LD_ADDR_EXP 11
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// frank_send_to_scout := false ;
 124: LD_ADDR_EXP 12
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// jmm_in_veh := false ;
 132: LD_ADDR_EXP 13
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// bobby_in_veh := false ;
 140: LD_ADDR_EXP 14
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// cyrus_in_veh := false ;
 148: LD_ADDR_EXP 15
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// lisa_in_veh := false ;
 156: LD_ADDR_EXP 16
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 164: LD_ADDR_EXP 24
 168: PUSH
 169: LD_INT 25200
 171: PUSH
 172: LD_INT 23100
 174: PUSH
 175: LD_INT 21000
 177: PUSH
 178: EMPTY
 179: LIST
 180: LIST
 181: LIST
 182: PUSH
 183: LD_OWVAR 67
 187: ARRAY
 188: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 189: LD_ADDR_EXP 17
 193: PUSH
 194: LD_INT 600
 196: PUSH
 197: LD_INT 500
 199: PUSH
 200: LD_INT 400
 202: PUSH
 203: EMPTY
 204: LIST
 205: LIST
 206: LIST
 207: PUSH
 208: LD_OWVAR 67
 212: ARRAY
 213: ST_TO_ADDR
// end_mission_allowed := false ;
 214: LD_ADDR_EXP 18
 218: PUSH
 219: LD_INT 0
 221: ST_TO_ADDR
// save_others := [ ] ;
 222: LD_ADDR_EXP 19
 226: PUSH
 227: EMPTY
 228: ST_TO_ADDR
// save_group := [ ] ;
 229: LD_ADDR_EXP 20
 233: PUSH
 234: EMPTY
 235: ST_TO_ADDR
// show_query := true ;
 236: LD_ADDR_EXP 21
 240: PUSH
 241: LD_INT 1
 243: ST_TO_ADDR
// wait_for_them := false ;
 244: LD_ADDR_EXP 22
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// veh_on_meta := false ;
 252: LD_ADDR_EXP 23
 256: PUSH
 257: LD_INT 0
 259: ST_TO_ADDR
// send_spec_patrol := false ;
 260: LD_ADDR_EXP 25
 264: PUSH
 265: LD_INT 0
 267: ST_TO_ADDR
// prepare_siege := false ;
 268: LD_ADDR_EXP 26
 272: PUSH
 273: LD_INT 0
 275: ST_TO_ADDR
// send_attack_on_cornel := false ;
 276: LD_ADDR_EXP 27
 280: PUSH
 281: LD_INT 0
 283: ST_TO_ADDR
// game_end := false ;
 284: LD_ADDR_EXP 28
 288: PUSH
 289: LD_INT 0
 291: ST_TO_ADDR
// end ;
 292: LD_VAR 0 1
 296: RET
// function SetDiplomacy ; begin
 297: LD_INT 0
 299: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 300: LD_INT 1
 302: PPUSH
 303: LD_INT 4
 305: PPUSH
 306: LD_INT 1
 308: PPUSH
 309: LD_INT 1
 311: PPUSH
 312: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 316: LD_INT 1
 318: PPUSH
 319: LD_INT 8
 321: PPUSH
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 1
 327: PPUSH
 328: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 332: LD_INT 3
 334: PPUSH
 335: LD_INT 6
 337: PPUSH
 338: LD_INT 1
 340: PPUSH
 341: LD_INT 1
 343: PPUSH
 344: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 348: LD_INT 4
 350: PPUSH
 351: LD_INT 6
 353: PPUSH
 354: LD_INT 0
 356: PPUSH
 357: LD_INT 1
 359: PPUSH
 360: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 364: LD_INT 3
 366: PPUSH
 367: LD_INT 8
 369: PPUSH
 370: LD_INT 0
 372: PPUSH
 373: LD_INT 1
 375: PPUSH
 376: CALL_OW 80
// end ;
 380: LD_VAR 0 1
 384: RET
// export function DebugMode ; begin
 385: LD_INT 0
 387: PPUSH
// FogOff ( 1 ) ;
 388: LD_INT 1
 390: PPUSH
 391: CALL_OW 344
// debug_strings := [ ] ;
 395: LD_ADDR_OWVAR 48
 399: PUSH
 400: EMPTY
 401: ST_TO_ADDR
// end ; end_of_file
 402: LD_VAR 0 1
 406: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 407: LD_INT 0
 409: PPUSH
 410: PPUSH
// if exist_mode then
 411: LD_VAR 0 2
 415: IFFALSE 443
// begin unit := CreateCharacter ( ident ) ;
 417: LD_ADDR_VAR 0 4
 421: PUSH
 422: LD_VAR 0 1
 426: PPUSH
 427: CALL_OW 34
 431: ST_TO_ADDR
// DeleteCharacters ( ident ) ;
 432: LD_VAR 0 1
 436: PPUSH
 437: CALL_OW 40
// end else
 441: GO 458
// unit := NewCharacter ( ident ) ;
 443: LD_ADDR_VAR 0 4
 447: PUSH
 448: LD_VAR 0 1
 452: PPUSH
 453: CALL_OW 25
 457: ST_TO_ADDR
// result := unit ;
 458: LD_ADDR_VAR 0 3
 462: PUSH
 463: LD_VAR 0 4
 467: ST_TO_ADDR
// end ;
 468: LD_VAR 0 3
 472: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 473: LD_INT 0
 475: PPUSH
// uc_side := side ;
 476: LD_ADDR_OWVAR 20
 480: PUSH
 481: LD_VAR 0 1
 485: ST_TO_ADDR
// uc_nation := nation ;
 486: LD_ADDR_OWVAR 21
 490: PUSH
 491: LD_VAR 0 2
 495: ST_TO_ADDR
// vc_chassis := chassis ;
 496: LD_ADDR_OWVAR 37
 500: PUSH
 501: LD_VAR 0 3
 505: ST_TO_ADDR
// vc_engine := engine ;
 506: LD_ADDR_OWVAR 39
 510: PUSH
 511: LD_VAR 0 4
 515: ST_TO_ADDR
// vc_control := control ;
 516: LD_ADDR_OWVAR 38
 520: PUSH
 521: LD_VAR 0 5
 525: ST_TO_ADDR
// vc_weapon := weapon ;
 526: LD_ADDR_OWVAR 40
 530: PUSH
 531: LD_VAR 0 6
 535: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 536: LD_ADDR_OWVAR 41
 540: PUSH
 541: LD_VAR 0 7
 545: ST_TO_ADDR
// result := CreateVehicle ;
 546: LD_ADDR_VAR 0 8
 550: PUSH
 551: CALL_OW 45
 555: ST_TO_ADDR
// end ;
 556: LD_VAR 0 8
 560: RET
// export function SayX ( units , ident ) ; var i ; begin
 561: LD_INT 0
 563: PPUSH
 564: PPUSH
// result := false ;
 565: LD_ADDR_VAR 0 3
 569: PUSH
 570: LD_INT 0
 572: ST_TO_ADDR
// if not units then
 573: LD_VAR 0 1
 577: NOT
 578: IFFALSE 582
// exit ;
 580: GO 636
// for i in units do
 582: LD_ADDR_VAR 0 4
 586: PUSH
 587: LD_VAR 0 1
 591: PUSH
 592: FOR_IN
 593: IFFALSE 634
// if IsOk ( i ) then
 595: LD_VAR 0 4
 599: PPUSH
 600: CALL_OW 302
 604: IFFALSE 632
// begin Say ( i , ident ) ;
 606: LD_VAR 0 4
 610: PPUSH
 611: LD_VAR 0 2
 615: PPUSH
 616: CALL_OW 88
// result := i ;
 620: LD_ADDR_VAR 0 3
 624: PUSH
 625: LD_VAR 0 4
 629: ST_TO_ADDR
// break ;
 630: GO 634
// end ;
 632: GO 592
 634: POP
 635: POP
// end ;
 636: LD_VAR 0 3
 640: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 641: LD_INT 0
 643: PPUSH
 644: PPUSH
 645: PPUSH
 646: PPUSH
// for i = 1 to count do
 647: LD_ADDR_VAR 0 8
 651: PUSH
 652: DOUBLE
 653: LD_INT 1
 655: DEC
 656: ST_TO_ADDR
 657: LD_VAR 0 6
 661: PUSH
 662: FOR_TO
 663: IFFALSE 744
// begin uc_side = side ;
 665: LD_ADDR_OWVAR 20
 669: PUSH
 670: LD_VAR 0 1
 674: ST_TO_ADDR
// uc_nation = nation ;
 675: LD_ADDR_OWVAR 21
 679: PUSH
 680: LD_VAR 0 2
 684: ST_TO_ADDR
// hc_gallery =  ;
 685: LD_ADDR_OWVAR 33
 689: PUSH
 690: LD_STRING 
 692: ST_TO_ADDR
// hc_name =  ;
 693: LD_ADDR_OWVAR 26
 697: PUSH
 698: LD_STRING 
 700: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 701: LD_INT 0
 703: PPUSH
 704: LD_VAR 0 5
 708: PPUSH
 709: LD_VAR 0 4
 713: PPUSH
 714: CALL_OW 380
// un = CreateHuman ;
 718: LD_ADDR_VAR 0 10
 722: PUSH
 723: CALL_OW 44
 727: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 728: LD_VAR 0 10
 732: PPUSH
 733: LD_VAR 0 3
 737: PPUSH
 738: CALL_OW 52
// end ;
 742: GO 662
 744: POP
 745: POP
// end ;
 746: LD_VAR 0 7
 750: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 751: LD_INT 0
 753: PPUSH
 754: PPUSH
 755: PPUSH
// uc_side := GetSide ( b ) ;
 756: LD_ADDR_OWVAR 20
 760: PUSH
 761: LD_VAR 0 2
 765: PPUSH
 766: CALL_OW 255
 770: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 771: LD_ADDR_OWVAR 21
 775: PUSH
 776: LD_VAR 0 2
 780: PPUSH
 781: CALL_OW 248
 785: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 786: LD_INT 0
 788: PPUSH
 789: LD_INT 1
 791: PPUSH
 792: LD_VAR 0 1
 796: PPUSH
 797: CALL_OW 380
// un = CreateHuman ;
 801: LD_ADDR_VAR 0 4
 805: PUSH
 806: CALL_OW 44
 810: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 811: LD_ADDR_VAR 0 5
 815: PUSH
 816: LD_VAR 0 2
 820: PPUSH
 821: CALL_OW 254
 825: PUSH
 826: LD_INT 3
 828: MINUS
 829: ST_TO_ADDR
// if dir < 0 then
 830: LD_VAR 0 5
 834: PUSH
 835: LD_INT 0
 837: LESS
 838: IFFALSE 854
// dir := 6 + dir ;
 840: LD_ADDR_VAR 0 5
 844: PUSH
 845: LD_INT 6
 847: PUSH
 848: LD_VAR 0 5
 852: PLUS
 853: ST_TO_ADDR
// SetDir ( un , dir ) ;
 854: LD_VAR 0 4
 858: PPUSH
 859: LD_VAR 0 5
 863: PPUSH
 864: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 868: LD_VAR 0 4
 872: PPUSH
 873: LD_VAR 0 2
 877: PPUSH
 878: CALL_OW 52
// end ;
 882: LD_VAR 0 3
 886: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 887: LD_INT 0
 889: PPUSH
 890: PPUSH
 891: PPUSH
// result := false ;
 892: LD_ADDR_VAR 0 2
 896: PUSH
 897: LD_INT 0
 899: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 900: LD_ADDR_VAR 0 3
 904: PUSH
 905: LD_INT 22
 907: PUSH
 908: LD_INT 1
 910: PUSH
 911: EMPTY
 912: LIST
 913: LIST
 914: PUSH
 915: LD_INT 34
 917: PUSH
 918: LD_INT 2
 920: PUSH
 921: EMPTY
 922: LIST
 923: LIST
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: PPUSH
 929: CALL_OW 69
 933: ST_TO_ADDR
// for i in filter do
 934: LD_ADDR_VAR 0 4
 938: PUSH
 939: LD_VAR 0 3
 943: PUSH
 944: FOR_IN
 945: IFFALSE 976
// if IsDrivenBy ( i ) = unit then
 947: LD_VAR 0 4
 951: PPUSH
 952: CALL_OW 311
 956: PUSH
 957: LD_VAR 0 1
 961: EQUAL
 962: IFFALSE 974
// begin result := true ;
 964: LD_ADDR_VAR 0 2
 968: PUSH
 969: LD_INT 1
 971: ST_TO_ADDR
// break ;
 972: GO 976
// end ;
 974: GO 944
 976: POP
 977: POP
// end ;
 978: LD_VAR 0 2
 982: RET
// export function FindFreePlace ( blist ) ; var i ; begin
 983: LD_INT 0
 985: PPUSH
 986: PPUSH
// result := false ;
 987: LD_ADDR_VAR 0 2
 991: PUSH
 992: LD_INT 0
 994: ST_TO_ADDR
// if not blist then
 995: LD_VAR 0 1
 999: NOT
1000: IFFALSE 1004
// exit ;
1002: GO 1048
// for i in blist do
1004: LD_ADDR_VAR 0 3
1008: PUSH
1009: LD_VAR 0 1
1013: PUSH
1014: FOR_IN
1015: IFFALSE 1046
// if UnitsInside ( i ) < 6 then
1017: LD_VAR 0 3
1021: PPUSH
1022: CALL_OW 313
1026: PUSH
1027: LD_INT 6
1029: LESS
1030: IFFALSE 1044
// begin result := i ;
1032: LD_ADDR_VAR 0 2
1036: PUSH
1037: LD_VAR 0 3
1041: ST_TO_ADDR
// break ;
1042: GO 1046
// end ;
1044: GO 1014
1046: POP
1047: POP
// end ;
1048: LD_VAR 0 2
1052: RET
// export function Count ( timer , mode ) ; begin
1053: LD_INT 0
1055: PPUSH
// if not timer then
1056: LD_VAR 0 1
1060: NOT
1061: IFFALSE 1065
// exit ;
1063: GO 1116
// if mode in [ asc , up , + ] then
1065: LD_VAR 0 2
1069: PUSH
1070: LD_STRING asc
1072: PUSH
1073: LD_STRING up
1075: PUSH
1076: LD_STRING +
1078: PUSH
1079: EMPTY
1080: LIST
1081: LIST
1082: LIST
1083: IN
1084: IFFALSE 1102
// result := timer + 0 0$01 else
1086: LD_ADDR_VAR 0 3
1090: PUSH
1091: LD_VAR 0 1
1095: PUSH
1096: LD_INT 35
1098: PLUS
1099: ST_TO_ADDR
1100: GO 1116
// result := timer - 0 0$01 ;
1102: LD_ADDR_VAR 0 3
1106: PUSH
1107: LD_VAR 0 1
1111: PUSH
1112: LD_INT 35
1114: MINUS
1115: ST_TO_ADDR
// end ; end_of_file
1116: LD_VAR 0 3
1120: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1121: LD_INT 0
1123: PPUSH
1124: PPUSH
1125: PPUSH
1126: PPUSH
1127: PPUSH
1128: PPUSH
1129: PPUSH
1130: PPUSH
// uc_side := 4 ;
1131: LD_ADDR_OWVAR 20
1135: PUSH
1136: LD_INT 4
1138: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1139: LD_ADDR_EXP 38
1143: PUSH
1144: LD_STRING Powell
1146: PPUSH
1147: LD_INT 0
1149: PPUSH
1150: CALL 407 0 2
1154: ST_TO_ADDR
// uc_side := 1 ;
1155: LD_ADDR_OWVAR 20
1159: PUSH
1160: LD_INT 1
1162: ST_TO_ADDR
// uc_nation := 1 ;
1163: LD_ADDR_OWVAR 21
1167: PUSH
1168: LD_INT 1
1170: ST_TO_ADDR
// if debug then
1171: LD_EXP 1
1175: IFFALSE 1305
// begin for i = 1 to 4 do
1177: LD_ADDR_VAR 0 2
1181: PUSH
1182: DOUBLE
1183: LD_INT 1
1185: DEC
1186: ST_TO_ADDR
1187: LD_INT 4
1189: PUSH
1190: FOR_TO
1191: IFFALSE 1242
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1193: LD_INT 0
1195: PPUSH
1196: LD_INT 1
1198: PPUSH
1199: LD_INT 2
1201: PPUSH
1202: CALL_OW 12
1206: PPUSH
1207: LD_INT 3
1209: PPUSH
1210: CALL_OW 380
// un := CreateHuman ;
1214: LD_ADDR_VAR 0 3
1218: PUSH
1219: CALL_OW 44
1223: ST_TO_ADDR
// others := others ^ un ;
1224: LD_ADDR_VAR 0 5
1228: PUSH
1229: LD_VAR 0 5
1233: PUSH
1234: LD_VAR 0 3
1238: ADD
1239: ST_TO_ADDR
// end ;
1240: GO 1190
1242: POP
1243: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1244: LD_ADDR_VAR 0 6
1248: PUSH
1249: LD_INT 21
1251: PUSH
1252: LD_INT 1
1254: PUSH
1255: LD_INT 1
1257: PUSH
1258: LD_INT 51
1260: PUSH
1261: LD_INT 90
1263: PUSH
1264: LD_INT 504
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: LIST
1273: LIST
1274: PUSH
1275: LD_INT 21
1277: PUSH
1278: LD_INT 1
1280: PUSH
1281: LD_INT 1
1283: PUSH
1284: LD_INT 51
1286: PUSH
1287: LD_INT 80
1289: PUSH
1290: LD_INT 750
1292: PUSH
1293: EMPTY
1294: LIST
1295: LIST
1296: LIST
1297: LIST
1298: LIST
1299: LIST
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1305: LD_ADDR_EXP 29
1309: PUSH
1310: LD_STRING JMM
1312: PPUSH
1313: LD_EXP 1
1317: NOT
1318: PPUSH
1319: CALL 407 0 2
1323: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1324: LD_ADDR_EXP 30
1328: PUSH
1329: LD_STRING Bobby
1331: PPUSH
1332: LD_EXP 1
1336: NOT
1337: PPUSH
1338: CALL 407 0 2
1342: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1343: LD_ADDR_EXP 31
1347: PUSH
1348: LD_STRING Cyrus
1350: PPUSH
1351: LD_EXP 1
1355: NOT
1356: PPUSH
1357: CALL 407 0 2
1361: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1362: LD_ADDR_EXP 32
1366: PUSH
1367: LD_STRING Lisa
1369: PPUSH
1370: LD_EXP 1
1374: NOT
1375: PPUSH
1376: CALL 407 0 2
1380: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1381: LD_ADDR_EXP 33
1385: PUSH
1386: LD_STRING Khatam
1388: PPUSH
1389: LD_EXP 1
1393: NOT
1394: PPUSH
1395: CALL 407 0 2
1399: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1400: LD_ADDR_EXP 34
1404: PUSH
1405: LD_STRING Brian
1407: PPUSH
1408: LD_EXP 1
1412: NOT
1413: PPUSH
1414: CALL 407 0 2
1418: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1419: LD_ADDR_EXP 35
1423: PUSH
1424: LD_STRING Jerry
1426: PPUSH
1427: LD_EXP 1
1431: NOT
1432: PPUSH
1433: CALL 407 0 2
1437: ST_TO_ADDR
// if Bobby then
1438: LD_EXP 30
1442: IFFALSE 1473
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1444: LD_ADDR_VAR 0 4
1448: PUSH
1449: LD_VAR 0 4
1453: PPUSH
1454: LD_VAR 0 4
1458: PUSH
1459: LD_INT 1
1461: PLUS
1462: PPUSH
1463: LD_EXP 30
1467: PPUSH
1468: CALL_OW 2
1472: ST_TO_ADDR
// if Cyrus then
1473: LD_EXP 31
1477: IFFALSE 1508
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1479: LD_ADDR_VAR 0 4
1483: PUSH
1484: LD_VAR 0 4
1488: PPUSH
1489: LD_VAR 0 4
1493: PUSH
1494: LD_INT 1
1496: PLUS
1497: PPUSH
1498: LD_EXP 31
1502: PPUSH
1503: CALL_OW 2
1507: ST_TO_ADDR
// if Lisa then
1508: LD_EXP 32
1512: IFFALSE 1543
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1514: LD_ADDR_VAR 0 4
1518: PUSH
1519: LD_VAR 0 4
1523: PPUSH
1524: LD_VAR 0 4
1528: PUSH
1529: LD_INT 1
1531: PLUS
1532: PPUSH
1533: LD_EXP 32
1537: PPUSH
1538: CALL_OW 2
1542: ST_TO_ADDR
// if Khatam then
1543: LD_EXP 33
1547: IFFALSE 1578
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1549: LD_ADDR_VAR 0 4
1553: PUSH
1554: LD_VAR 0 4
1558: PPUSH
1559: LD_VAR 0 4
1563: PUSH
1564: LD_INT 1
1566: PLUS
1567: PPUSH
1568: LD_EXP 33
1572: PPUSH
1573: CALL_OW 2
1577: ST_TO_ADDR
// if Brian then
1578: LD_EXP 34
1582: IFFALSE 1613
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1584: LD_ADDR_VAR 0 4
1588: PUSH
1589: LD_VAR 0 4
1593: PPUSH
1594: LD_VAR 0 4
1598: PUSH
1599: LD_INT 1
1601: PLUS
1602: PPUSH
1603: LD_EXP 34
1607: PPUSH
1608: CALL_OW 2
1612: ST_TO_ADDR
// if Jerry then
1613: LD_EXP 35
1617: IFFALSE 1648
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1619: LD_ADDR_VAR 0 4
1623: PUSH
1624: LD_VAR 0 4
1628: PPUSH
1629: LD_VAR 0 4
1633: PUSH
1634: LD_INT 1
1636: PLUS
1637: PPUSH
1638: LD_EXP 35
1642: PPUSH
1643: CALL_OW 2
1647: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1648: LD_STRING 02_other_survivors
1650: PPUSH
1651: CALL_OW 28
1655: IFFALSE 1670
// others := CreateCharacterSet ( 02_other_survivors ) ;
1657: LD_ADDR_VAR 0 5
1661: PUSH
1662: LD_STRING 02_other_survivors
1664: PPUSH
1665: CALL_OW 31
1669: ST_TO_ADDR
// if others then
1670: LD_VAR 0 5
1674: IFFALSE 1699
// begin tmp := tmp ^ others ;
1676: LD_ADDR_VAR 0 4
1680: PUSH
1681: LD_VAR 0 4
1685: PUSH
1686: LD_VAR 0 5
1690: ADD
1691: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1692: LD_STRING 02_other_survivors
1694: PPUSH
1695: CALL_OW 40
// end ; jmm_units := tmp ;
1699: LD_ADDR_EXP 2
1703: PUSH
1704: LD_VAR 0 4
1708: ST_TO_ADDR
// if not vehicles then
1709: LD_VAR 0 6
1713: NOT
1714: IFFALSE 1732
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1716: LD_ADDR_VAR 0 6
1720: PUSH
1721: LD_STRING 02_tanks_1
1723: PPUSH
1724: LD_INT 0
1726: PPUSH
1727: CALL_OW 30
1731: ST_TO_ADDR
// if vehicles then
1732: LD_VAR 0 6
1736: IFFALSE 1930
// begin got_mech := false ;
1738: LD_ADDR_VAR 0 7
1742: PUSH
1743: LD_INT 0
1745: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1746: LD_VAR 0 4
1750: PPUSH
1751: LD_INT 25
1753: PUSH
1754: LD_INT 3
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PPUSH
1761: CALL_OW 72
1765: IFFALSE 1775
// got_mech := true ;
1767: LD_ADDR_VAR 0 7
1771: PUSH
1772: LD_INT 1
1774: ST_TO_ADDR
// for i = 1 to vehicles do
1775: LD_ADDR_VAR 0 2
1779: PUSH
1780: DOUBLE
1781: LD_INT 1
1783: DEC
1784: ST_TO_ADDR
1785: LD_VAR 0 6
1789: PUSH
1790: FOR_TO
1791: IFFALSE 1928
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1793: LD_ADDR_VAR 0 3
1797: PUSH
1798: LD_INT 1
1800: PPUSH
1801: LD_INT 3
1803: PPUSH
1804: LD_VAR 0 6
1808: PUSH
1809: LD_VAR 0 2
1813: ARRAY
1814: PUSH
1815: LD_INT 1
1817: ARRAY
1818: PPUSH
1819: LD_VAR 0 6
1823: PUSH
1824: LD_VAR 0 2
1828: ARRAY
1829: PUSH
1830: LD_INT 2
1832: ARRAY
1833: PPUSH
1834: LD_VAR 0 6
1838: PUSH
1839: LD_VAR 0 2
1843: ARRAY
1844: PUSH
1845: LD_INT 3
1847: ARRAY
1848: PPUSH
1849: LD_VAR 0 6
1853: PUSH
1854: LD_VAR 0 2
1858: ARRAY
1859: PUSH
1860: LD_INT 4
1862: ARRAY
1863: PPUSH
1864: LD_INT 40
1866: PPUSH
1867: CALL 473 0 7
1871: ST_TO_ADDR
// if not got_mech then
1872: LD_VAR 0 7
1876: NOT
1877: IFFALSE 1903
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1879: LD_VAR 0 3
1883: PPUSH
1884: LD_VAR 0 6
1888: PUSH
1889: LD_VAR 0 2
1893: ARRAY
1894: PUSH
1895: LD_INT 6
1897: ARRAY
1898: PPUSH
1899: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1903: LD_ADDR_VAR 0 4
1907: PUSH
1908: LD_VAR 0 4
1912: PPUSH
1913: LD_INT 1
1915: PPUSH
1916: LD_VAR 0 3
1920: PPUSH
1921: CALL_OW 2
1925: ST_TO_ADDR
// end ;
1926: GO 1790
1928: POP
1929: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1930: LD_EXP 29
1934: PPUSH
1935: LD_INT 194
1937: PPUSH
1938: LD_INT 119
1940: PPUSH
1941: LD_INT 0
1943: PPUSH
1944: CALL_OW 48
// if tmp then
1948: LD_VAR 0 4
1952: IFFALSE 2077
// begin for i in tmp do
1954: LD_ADDR_VAR 0 2
1958: PUSH
1959: LD_VAR 0 4
1963: PUSH
1964: FOR_IN
1965: IFFALSE 2075
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1967: LD_ADDR_VAR 0 8
1971: PUSH
1972: LD_INT 22
1974: PUSH
1975: LD_INT 1
1977: PUSH
1978: EMPTY
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 21
1984: PUSH
1985: LD_INT 2
1987: PUSH
1988: EMPTY
1989: LIST
1990: LIST
1991: PUSH
1992: LD_INT 58
1994: PUSH
1995: EMPTY
1996: LIST
1997: PUSH
1998: EMPTY
1999: LIST
2000: LIST
2001: LIST
2002: PPUSH
2003: CALL_OW 69
2007: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2008: LD_VAR 0 2
2012: PPUSH
2013: CALL_OW 247
2017: PUSH
2018: LD_INT 1
2020: EQUAL
2021: PUSH
2022: LD_VAR 0 8
2026: AND
2027: IFFALSE 2049
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2029: LD_VAR 0 2
2033: PPUSH
2034: LD_VAR 0 8
2038: PUSH
2039: LD_INT 1
2041: ARRAY
2042: PPUSH
2043: CALL_OW 52
2047: GO 2064
// PlaceUnitArea ( i , startArea , false ) ;
2049: LD_VAR 0 2
2053: PPUSH
2054: LD_INT 1
2056: PPUSH
2057: LD_INT 0
2059: PPUSH
2060: CALL_OW 49
// ComHold ( i ) ;
2064: LD_VAR 0 2
2068: PPUSH
2069: CALL_OW 140
// end ;
2073: GO 1964
2075: POP
2076: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2077: LD_ADDR_EXP 5
2081: PUSH
2082: LD_STRING 02_mikhailStatus_1
2084: PPUSH
2085: LD_INT 0
2087: PPUSH
2088: CALL_OW 30
2092: ST_TO_ADDR
// if not bierezov_exist and not debug then
2093: LD_EXP 5
2097: NOT
2098: PUSH
2099: LD_EXP 1
2103: NOT
2104: AND
2105: IFFALSE 2109
// exit ;
2107: GO 2140
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2109: LD_ADDR_EXP 37
2113: PUSH
2114: LD_STRING Mikhail
2116: PPUSH
2117: LD_INT 0
2119: PPUSH
2120: CALL 407 0 2
2124: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2125: LD_EXP 37
2129: PPUSH
2130: LD_INT 1
2132: PPUSH
2133: LD_INT 0
2135: PPUSH
2136: CALL_OW 49
// end ;
2140: LD_VAR 0 1
2144: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2145: LD_INT 0
2147: PPUSH
2148: PPUSH
2149: PPUSH
2150: PPUSH
// uc_side := 4 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 4
2158: ST_TO_ADDR
// uc_nation := 1 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 1
2166: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2167: LD_ADDR_EXP 36
2171: PUSH
2172: LD_STRING Cornell
2174: PPUSH
2175: LD_INT 0
2177: PPUSH
2178: CALL 407 0 2
2182: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
2183: LD_ADDR_EXP 4
2187: PUSH
2188: LD_INT 8
2190: PUSH
2191: LD_EXP 2
2195: MINUS
2196: ST_TO_ADDR
// tmp := [ ] ;
2197: LD_ADDR_VAR 0 2
2201: PUSH
2202: EMPTY
2203: ST_TO_ADDR
// if cornel_units < 3 then
2204: LD_EXP 4
2208: PUSH
2209: LD_INT 3
2211: LESS
2212: IFFALSE 2222
// cornel_units := 3 ;
2214: LD_ADDR_EXP 4
2218: PUSH
2219: LD_INT 3
2221: ST_TO_ADDR
// for i = 1 to cornel_units do
2222: LD_ADDR_VAR 0 4
2226: PUSH
2227: DOUBLE
2228: LD_INT 1
2230: DEC
2231: ST_TO_ADDR
2232: LD_EXP 4
2236: PUSH
2237: FOR_TO
2238: IFFALSE 2336
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2240: LD_INT 0
2242: PPUSH
2243: LD_INT 1
2245: PUSH
2246: LD_INT 1
2248: PUSH
2249: LD_INT 1
2251: PUSH
2252: LD_INT 2
2254: PUSH
2255: LD_INT 4
2257: PUSH
2258: EMPTY
2259: LIST
2260: LIST
2261: LIST
2262: LIST
2263: LIST
2264: PUSH
2265: LD_VAR 0 4
2269: PUSH
2270: LD_INT 5
2272: MOD
2273: PUSH
2274: LD_INT 1
2276: PLUS
2277: ARRAY
2278: PPUSH
2279: LD_INT 2
2281: PPUSH
2282: CALL_OW 380
// un := CreateHuman ;
2286: LD_ADDR_VAR 0 3
2290: PUSH
2291: CALL_OW 44
2295: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2296: LD_ADDR_VAR 0 2
2300: PUSH
2301: LD_VAR 0 2
2305: PPUSH
2306: LD_INT 1
2308: PPUSH
2309: LD_VAR 0 3
2313: PPUSH
2314: CALL_OW 2
2318: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2319: LD_VAR 0 3
2323: PPUSH
2324: LD_INT 2
2326: PPUSH
2327: LD_INT 0
2329: PPUSH
2330: CALL_OW 49
// end ;
2334: GO 2237
2336: POP
2337: POP
// cornel_units := tmp ;
2338: LD_ADDR_EXP 4
2342: PUSH
2343: LD_VAR 0 2
2347: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2348: LD_EXP 36
2352: PPUSH
2353: LD_INT 191
2355: PPUSH
2356: LD_INT 106
2358: PPUSH
2359: LD_INT 0
2361: PPUSH
2362: CALL_OW 48
// end ;
2366: LD_VAR 0 1
2370: RET
// export function PrepareWesternBase ; var i ; begin
2371: LD_INT 0
2373: PPUSH
2374: PPUSH
// uc_side := 8 ;
2375: LD_ADDR_OWVAR 20
2379: PUSH
2380: LD_INT 8
2382: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2383: LD_ADDR_EXP 39
2387: PUSH
2388: LD_STRING Lynch
2390: PPUSH
2391: LD_INT 0
2393: PPUSH
2394: CALL 407 0 2
2398: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2399: LD_ADDR_EXP 40
2403: PUSH
2404: LD_STRING Walker
2406: PPUSH
2407: LD_INT 0
2409: PPUSH
2410: CALL 407 0 2
2414: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2415: LD_ADDR_EXP 41
2419: PUSH
2420: LD_STRING Turner
2422: PPUSH
2423: LD_INT 0
2425: PPUSH
2426: CALL 407 0 2
2430: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2431: LD_ADDR_EXP 42
2435: PUSH
2436: LD_STRING Jillian
2438: PPUSH
2439: LD_INT 0
2441: PPUSH
2442: CALL 407 0 2
2446: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2447: LD_ADDR_VAR 0 2
2451: PUSH
2452: LD_EXP 39
2456: PUSH
2457: LD_EXP 40
2461: PUSH
2462: LD_EXP 41
2466: PUSH
2467: LD_EXP 42
2471: PUSH
2472: EMPTY
2473: LIST
2474: LIST
2475: LIST
2476: LIST
2477: PUSH
2478: FOR_IN
2479: IFFALSE 2507
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2481: LD_VAR 0 2
2485: PPUSH
2486: LD_INT 3
2488: PPUSH
2489: LD_INT 0
2491: PPUSH
2492: CALL_OW 49
// ComHold ( i ) ;
2496: LD_VAR 0 2
2500: PPUSH
2501: CALL_OW 140
// end ;
2505: GO 2478
2507: POP
2508: POP
// end ;
2509: LD_VAR 0 1
2513: RET
// export function SelectGroup ; var units , selected , i ; begin
2514: LD_INT 0
2516: PPUSH
2517: PPUSH
2518: PPUSH
2519: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2520: LD_ADDR_VAR 0 2
2524: PUSH
2525: LD_EXP 29
2529: PUSH
2530: LD_INT -3
2532: PUSH
2533: EMPTY
2534: LIST
2535: LIST
2536: PUSH
2537: LD_EXP 2
2541: ADD
2542: PUSH
2543: LD_INT -2
2545: PUSH
2546: LD_INT -4
2548: PUSH
2549: LD_EXP 36
2553: PUSH
2554: LD_EXP 37
2558: PUSH
2559: EMPTY
2560: LIST
2561: LIST
2562: LIST
2563: LIST
2564: ADD
2565: PUSH
2566: LD_INT -3
2568: PUSH
2569: EMPTY
2570: LIST
2571: ADD
2572: PUSH
2573: LD_EXP 4
2577: ADD
2578: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2579: LD_ADDR_VAR 0 3
2583: PUSH
2584: LD_EXP 29
2588: PUSH
2589: LD_STRING Select five characters to go with you
2591: PPUSH
2592: LD_INT 4
2594: PPUSH
2595: LD_INT 4
2597: PPUSH
2598: LD_VAR 0 2
2602: PPUSH
2603: EMPTY
2604: PPUSH
2605: CALL_OW 42
2609: ADD
2610: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2611: LD_ADDR_EXP 4
2615: PUSH
2616: LD_EXP 2
2620: PUSH
2621: LD_EXP 4
2625: UNION
2626: PUSH
2627: LD_VAR 0 3
2631: DIFF
2632: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2633: LD_ADDR_VAR 0 4
2637: PUSH
2638: LD_EXP 4
2642: PUSH
2643: LD_EXP 37
2647: ADD
2648: PUSH
2649: FOR_IN
2650: IFFALSE 2681
// if GetSide ( i ) = 1 then
2652: LD_VAR 0 4
2656: PPUSH
2657: CALL_OW 255
2661: PUSH
2662: LD_INT 1
2664: EQUAL
2665: IFFALSE 2679
// SetSide ( i , 4 ) ;
2667: LD_VAR 0 4
2671: PPUSH
2672: LD_INT 4
2674: PPUSH
2675: CALL_OW 235
2679: GO 2649
2681: POP
2682: POP
// for i in selected do
2683: LD_ADDR_VAR 0 4
2687: PUSH
2688: LD_VAR 0 3
2692: PUSH
2693: FOR_IN
2694: IFFALSE 2725
// if GetSide ( i ) = 4 then
2696: LD_VAR 0 4
2700: PPUSH
2701: CALL_OW 255
2705: PUSH
2706: LD_INT 4
2708: EQUAL
2709: IFFALSE 2723
// SetSide ( i , 1 ) ;
2711: LD_VAR 0 4
2715: PPUSH
2716: LD_INT 1
2718: PPUSH
2719: CALL_OW 235
2723: GO 2693
2725: POP
2726: POP
// if GetSide ( Bobby ) = 4 then
2727: LD_EXP 30
2731: PPUSH
2732: CALL_OW 255
2736: PUSH
2737: LD_INT 4
2739: EQUAL
2740: IFFALSE 2749
// DeleteCharacters ( Bobby ) ;
2742: LD_STRING Bobby
2744: PPUSH
2745: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2749: LD_EXP 31
2753: PPUSH
2754: CALL_OW 255
2758: PUSH
2759: LD_INT 4
2761: EQUAL
2762: IFFALSE 2771
// DeleteCharacters ( Cyrus ) ;
2764: LD_STRING Cyrus
2766: PPUSH
2767: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2771: LD_EXP 32
2775: PPUSH
2776: CALL_OW 255
2780: PUSH
2781: LD_INT 4
2783: EQUAL
2784: IFFALSE 2793
// DeleteCharacters ( Lisa ) ;
2786: LD_STRING Lisa
2788: PPUSH
2789: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2793: LD_EXP 33
2797: PPUSH
2798: CALL_OW 255
2802: PUSH
2803: LD_INT 4
2805: EQUAL
2806: IFFALSE 2815
// DeleteCharacters ( Khatam ) ;
2808: LD_STRING Khatam
2810: PPUSH
2811: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2815: LD_EXP 34
2819: PPUSH
2820: CALL_OW 255
2824: PUSH
2825: LD_INT 4
2827: EQUAL
2828: IFFALSE 2837
// DeleteCharacters ( Brian ) ;
2830: LD_STRING Brian
2832: PPUSH
2833: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2837: LD_EXP 35
2841: PPUSH
2842: CALL_OW 255
2846: PUSH
2847: LD_INT 4
2849: EQUAL
2850: IFFALSE 2859
// DeleteCharacters ( Jerry ) ;
2852: LD_STRING Jerry
2854: PPUSH
2855: CALL_OW 40
// end ; end_of_file
2859: LD_VAR 0 1
2863: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , b , un , veh , tw , bar , skill , vehicles , spot_xy ; begin
2864: LD_INT 0
2866: PPUSH
2867: PPUSH
2868: PPUSH
2869: PPUSH
2870: PPUSH
2871: PPUSH
2872: PPUSH
2873: PPUSH
2874: PPUSH
2875: PPUSH
// ru_alert := false ;
2876: LD_ADDR_EXP 50
2880: PUSH
2881: LD_INT 0
2883: ST_TO_ADDR
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
2884: LD_ADDR_VAR 0 6
2888: PUSH
2889: LD_INT 22
2891: PUSH
2892: LD_INT 3
2894: PUSH
2895: EMPTY
2896: LIST
2897: LIST
2898: PUSH
2899: LD_INT 2
2901: PUSH
2902: LD_INT 30
2904: PUSH
2905: LD_INT 31
2907: PUSH
2908: EMPTY
2909: LIST
2910: LIST
2911: PUSH
2912: LD_INT 30
2914: PUSH
2915: LD_INT 32
2917: PUSH
2918: EMPTY
2919: LIST
2920: LIST
2921: PUSH
2922: EMPTY
2923: LIST
2924: LIST
2925: LIST
2926: PUSH
2927: EMPTY
2928: LIST
2929: LIST
2930: PPUSH
2931: CALL_OW 69
2935: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
2936: LD_ADDR_VAR 0 7
2940: PUSH
2941: LD_INT 22
2943: PUSH
2944: LD_INT 3
2946: PUSH
2947: EMPTY
2948: LIST
2949: LIST
2950: PUSH
2951: LD_INT 30
2953: PUSH
2954: LD_INT 4
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: PUSH
2961: EMPTY
2962: LIST
2963: LIST
2964: PPUSH
2965: CALL_OW 69
2969: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
2970: LD_ADDR_VAR 0 2
2974: PUSH
2975: LD_INT 22
2977: PUSH
2978: LD_INT 3
2980: PUSH
2981: EMPTY
2982: LIST
2983: LIST
2984: PUSH
2985: LD_INT 30
2987: PUSH
2988: LD_INT 1
2990: PUSH
2991: EMPTY
2992: LIST
2993: LIST
2994: PUSH
2995: EMPTY
2996: LIST
2997: LIST
2998: PPUSH
2999: CALL_OW 69
3003: PUSH
3004: FOR_IN
3005: IFFALSE 3049
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
3007: LD_VAR 0 2
3011: PPUSH
3012: CALL_OW 274
3016: PPUSH
3017: LD_INT 1
3019: PPUSH
3020: LD_INT 1000
3022: PPUSH
3023: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 300 ) ;
3027: LD_VAR 0 2
3031: PPUSH
3032: CALL_OW 274
3036: PPUSH
3037: LD_INT 2
3039: PPUSH
3040: LD_INT 300
3042: PPUSH
3043: CALL_OW 277
// end ;
3047: GO 3004
3049: POP
3050: POP
// uc_side := 3 ;
3051: LD_ADDR_OWVAR 20
3055: PUSH
3056: LD_INT 3
3058: ST_TO_ADDR
// uc_nation := 3 ;
3059: LD_ADDR_OWVAR 21
3063: PUSH
3064: LD_INT 3
3066: ST_TO_ADDR
// skill := [ 2 , 2 , 3 ] [ Difficulty ] ;
3067: LD_ADDR_VAR 0 8
3071: PUSH
3072: LD_INT 2
3074: PUSH
3075: LD_INT 2
3077: PUSH
3078: LD_INT 3
3080: PUSH
3081: EMPTY
3082: LIST
3083: LIST
3084: LIST
3085: PUSH
3086: LD_OWVAR 67
3090: ARRAY
3091: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3092: LD_ADDR_EXP 44
3096: PUSH
3097: LD_STRING Pokryshkin
3099: PPUSH
3100: LD_INT 0
3102: PPUSH
3103: CALL 407 0 2
3107: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3108: LD_EXP 44
3112: PPUSH
3113: LD_INT 63
3115: PPUSH
3116: LD_INT 21
3118: PPUSH
3119: LD_INT 0
3121: PPUSH
3122: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3126: LD_EXP 44
3130: PPUSH
3131: CALL_OW 140
// InitHc ;
3135: CALL_OW 19
// for i in tw do
3139: LD_ADDR_VAR 0 2
3143: PUSH
3144: LD_VAR 0 6
3148: PUSH
3149: FOR_IN
3150: IFFALSE 3199
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3152: LD_VAR 0 2
3156: PPUSH
3157: LD_INT 42
3159: PUSH
3160: LD_INT 43
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: PUSH
3167: LD_INT 1
3169: PPUSH
3170: LD_INT 2
3172: PPUSH
3173: CALL_OW 12
3177: ARRAY
3178: PPUSH
3179: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3183: LD_VAR 0 8
3187: PPUSH
3188: LD_VAR 0 2
3192: PPUSH
3193: CALL 751 0 2
// end ;
3197: GO 3149
3199: POP
3200: POP
// for i in bar do
3201: LD_ADDR_VAR 0 2
3205: PUSH
3206: LD_VAR 0 7
3210: PUSH
3211: FOR_IN
3212: IFFALSE 3245
// begin PrepareHuman ( false , 1 , skill ) ;
3214: LD_INT 0
3216: PPUSH
3217: LD_INT 1
3219: PPUSH
3220: LD_VAR 0 8
3224: PPUSH
3225: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3229: CALL_OW 44
3233: PPUSH
3234: LD_VAR 0 2
3238: PPUSH
3239: CALL_OW 52
// end ;
3243: GO 3211
3245: POP
3246: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3247: LD_ADDR_VAR 0 10
3251: PUSH
3252: LD_INT 100
3254: PUSH
3255: LD_INT 9
3257: PUSH
3258: EMPTY
3259: LIST
3260: LIST
3261: PUSH
3262: LD_INT 135
3264: PUSH
3265: LD_INT 60
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: PUSH
3272: LD_INT 41
3274: PUSH
3275: LD_INT 6
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: PUSH
3282: LD_INT 22
3284: PUSH
3285: LD_INT 9
3287: PUSH
3288: EMPTY
3289: LIST
3290: LIST
3291: PUSH
3292: LD_INT 84
3294: PUSH
3295: LD_INT 14
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: LIST
3306: LIST
3307: LIST
3308: ST_TO_ADDR
// vehicles := [ ] ;
3309: LD_ADDR_VAR 0 9
3313: PUSH
3314: EMPTY
3315: ST_TO_ADDR
// for i in spot_xy do
3316: LD_ADDR_VAR 0 2
3320: PUSH
3321: LD_VAR 0 10
3325: PUSH
3326: FOR_IN
3327: IFFALSE 3485
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3329: LD_ADDR_VAR 0 5
3333: PUSH
3334: LD_INT 3
3336: PPUSH
3337: LD_INT 3
3339: PPUSH
3340: LD_INT 22
3342: PPUSH
3343: LD_INT 1
3345: PPUSH
3346: LD_INT 1
3348: PPUSH
3349: LD_INT 42
3351: PUSH
3352: LD_INT 43
3354: PUSH
3355: LD_INT 44
3357: PUSH
3358: EMPTY
3359: LIST
3360: LIST
3361: LIST
3362: PUSH
3363: LD_INT 1
3365: PPUSH
3366: LD_INT 3
3368: PPUSH
3369: CALL_OW 12
3373: ARRAY
3374: PPUSH
3375: LD_INT 100
3377: PPUSH
3378: CALL 473 0 7
3382: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3383: LD_ADDR_VAR 0 9
3387: PUSH
3388: LD_VAR 0 9
3392: PPUSH
3393: LD_VAR 0 9
3397: PUSH
3398: LD_INT 1
3400: PLUS
3401: PPUSH
3402: LD_VAR 0 5
3406: PPUSH
3407: CALL_OW 2
3411: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3412: LD_VAR 0 5
3416: PPUSH
3417: LD_INT 3
3419: PPUSH
3420: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3424: LD_VAR 0 5
3428: PPUSH
3429: LD_VAR 0 2
3433: PUSH
3434: LD_INT 1
3436: ARRAY
3437: PPUSH
3438: LD_VAR 0 2
3442: PUSH
3443: LD_INT 2
3445: ARRAY
3446: PPUSH
3447: LD_INT 0
3449: PPUSH
3450: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3454: LD_INT 0
3456: PPUSH
3457: LD_INT 3
3459: PPUSH
3460: LD_VAR 0 8
3464: PPUSH
3465: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3469: CALL_OW 44
3473: PPUSH
3474: LD_VAR 0 5
3478: PPUSH
3479: CALL_OW 52
// end ;
3483: GO 3326
3485: POP
3486: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3487: LD_ADDR_VAR 0 2
3491: PUSH
3492: DOUBLE
3493: LD_INT 1
3495: DEC
3496: ST_TO_ADDR
3497: LD_INT 5
3499: PUSH
3500: LD_INT 7
3502: PUSH
3503: LD_INT 8
3505: PUSH
3506: EMPTY
3507: LIST
3508: LIST
3509: LIST
3510: PUSH
3511: LD_OWVAR 67
3515: ARRAY
3516: PUSH
3517: FOR_TO
3518: IFFALSE 3578
// begin PrepareHuman ( false , 1 , skill ) ;
3520: LD_INT 0
3522: PPUSH
3523: LD_INT 1
3525: PPUSH
3526: LD_VAR 0 8
3530: PPUSH
3531: CALL_OW 380
// un := CreateHuman ;
3535: LD_ADDR_VAR 0 4
3539: PUSH
3540: CALL_OW 44
3544: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3545: LD_VAR 0 4
3549: PPUSH
3550: LD_INT 11
3552: PPUSH
3553: LD_INT 0
3555: PPUSH
3556: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3560: LD_ADDR_EXP 47
3564: PUSH
3565: LD_EXP 47
3569: PUSH
3570: LD_VAR 0 4
3574: ADD
3575: ST_TO_ADDR
// end ;
3576: GO 3517
3578: POP
3579: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3580: LD_ADDR_VAR 0 2
3584: PUSH
3585: DOUBLE
3586: LD_INT 1
3588: DEC
3589: ST_TO_ADDR
3590: LD_INT 2
3592: PUSH
3593: LD_INT 3
3595: PUSH
3596: LD_INT 4
3598: PUSH
3599: EMPTY
3600: LIST
3601: LIST
3602: LIST
3603: PUSH
3604: LD_OWVAR 67
3608: ARRAY
3609: PUSH
3610: FOR_TO
3611: IFFALSE 3671
// begin PrepareHuman ( false , 1 , skill ) ;
3613: LD_INT 0
3615: PPUSH
3616: LD_INT 1
3618: PPUSH
3619: LD_VAR 0 8
3623: PPUSH
3624: CALL_OW 380
// un := CreateHuman ;
3628: LD_ADDR_VAR 0 4
3632: PUSH
3633: CALL_OW 44
3637: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
3638: LD_VAR 0 4
3642: PPUSH
3643: LD_INT 12
3645: PPUSH
3646: LD_INT 0
3648: PPUSH
3649: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
3653: LD_ADDR_EXP 45
3657: PUSH
3658: LD_EXP 45
3662: PUSH
3663: LD_VAR 0 4
3667: ADD
3668: ST_TO_ADDR
// end ;
3669: GO 3610
3671: POP
3672: POP
// for i = 1 to 2 do
3673: LD_ADDR_VAR 0 2
3677: PUSH
3678: DOUBLE
3679: LD_INT 1
3681: DEC
3682: ST_TO_ADDR
3683: LD_INT 2
3685: PUSH
3686: FOR_TO
3687: IFFALSE 3753
// begin PrepareHuman ( false , 1 , skill ) ;
3689: LD_INT 0
3691: PPUSH
3692: LD_INT 1
3694: PPUSH
3695: LD_VAR 0 8
3699: PPUSH
3700: CALL_OW 380
// un := CreateHuman ;
3704: LD_ADDR_VAR 0 4
3708: PUSH
3709: CALL_OW 44
3713: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
3714: LD_VAR 0 4
3718: PPUSH
3719: LD_INT 39
3721: PPUSH
3722: LD_INT 12
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 0
3730: PPUSH
3731: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
3735: LD_ADDR_EXP 46
3739: PUSH
3740: LD_EXP 46
3744: PUSH
3745: LD_VAR 0 4
3749: ADD
3750: ST_TO_ADDR
// end ;
3751: GO 3686
3753: POP
3754: POP
// ru_vehicles := vehicles ;
3755: LD_ADDR_EXP 48
3759: PUSH
3760: LD_VAR 0 9
3764: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
3765: LD_ADDR_EXP 49
3769: PUSH
3770: LD_INT 131
3772: PUSH
3773: LD_INT 121
3775: PUSH
3776: EMPTY
3777: LIST
3778: LIST
3779: PUSH
3780: LD_INT 113
3782: PUSH
3783: LD_INT 90
3785: PUSH
3786: EMPTY
3787: LIST
3788: LIST
3789: PUSH
3790: LD_INT 93
3792: PUSH
3793: LD_INT 62
3795: PUSH
3796: EMPTY
3797: LIST
3798: LIST
3799: PUSH
3800: EMPTY
3801: LIST
3802: LIST
3803: LIST
3804: PUSH
3805: LD_INT 106
3807: PUSH
3808: LD_INT 54
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PUSH
3815: LD_INT 120
3817: PUSH
3818: LD_INT 80
3820: PUSH
3821: EMPTY
3822: LIST
3823: LIST
3824: PUSH
3825: LD_INT 143
3827: PUSH
3828: LD_INT 120
3830: PUSH
3831: EMPTY
3832: LIST
3833: LIST
3834: PUSH
3835: EMPTY
3836: LIST
3837: LIST
3838: LIST
3839: PUSH
3840: LD_INT 154
3842: PUSH
3843: LD_INT 116
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: PUSH
3850: LD_INT 140
3852: PUSH
3853: LD_INT 93
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PUSH
3860: LD_INT 130
3862: PUSH
3863: LD_INT 58
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: LIST
3874: PUSH
3875: LD_INT 105
3877: PUSH
3878: LD_INT 106
3880: PUSH
3881: EMPTY
3882: LIST
3883: LIST
3884: PUSH
3885: LD_INT 134
3887: PUSH
3888: LD_INT 98
3890: PUSH
3891: EMPTY
3892: LIST
3893: LIST
3894: PUSH
3895: LD_INT 159
3897: PUSH
3898: LD_INT 113
3900: PUSH
3901: EMPTY
3902: LIST
3903: LIST
3904: PUSH
3905: EMPTY
3906: LIST
3907: LIST
3908: LIST
3909: PUSH
3910: EMPTY
3911: LIST
3912: LIST
3913: LIST
3914: LIST
3915: ST_TO_ADDR
// end ; end_of_file
3916: LD_VAR 0 1
3920: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
3921: LD_INT 0
3923: PPUSH
3924: PPUSH
3925: PPUSH
3926: PPUSH
3927: PPUSH
3928: PPUSH
3929: PPUSH
// InGameOn ;
3930: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
3934: LD_EXP 29
3938: PPUSH
3939: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
3943: LD_EXP 29
3947: PPUSH
3948: LD_EXP 36
3952: PPUSH
3953: CALL_OW 119
// if Bierezov then
3957: LD_EXP 37
3961: IFFALSE 3977
// ComTurnUnit ( Bierezov , Cornel ) ;
3963: LD_EXP 37
3967: PPUSH
3968: LD_EXP 36
3972: PPUSH
3973: CALL_OW 119
// for i in jmm_units do
3977: LD_ADDR_VAR 0 2
3981: PUSH
3982: LD_EXP 2
3986: PUSH
3987: FOR_IN
3988: IFFALSE 4006
// ComTurnUnit ( i , Cornel ) ;
3990: LD_VAR 0 2
3994: PPUSH
3995: LD_EXP 36
3999: PPUSH
4000: CALL_OW 119
4004: GO 3987
4006: POP
4007: POP
// units := cornel_units union Cornel ;
4008: LD_ADDR_VAR 0 3
4012: PUSH
4013: LD_EXP 4
4017: PUSH
4018: LD_EXP 36
4022: UNION
4023: ST_TO_ADDR
// repeat wait ( 1 ) ;
4024: LD_INT 1
4026: PPUSH
4027: CALL_OW 67
// for i in units do
4031: LD_ADDR_VAR 0 2
4035: PUSH
4036: LD_VAR 0 3
4040: PUSH
4041: FOR_IN
4042: IFFALSE 4075
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
4044: LD_VAR 0 2
4048: PPUSH
4049: LD_EXP 29
4053: PPUSH
4054: CALL_OW 250
4058: PPUSH
4059: LD_EXP 29
4063: PPUSH
4064: CALL_OW 251
4068: PPUSH
4069: CALL_OW 111
4073: GO 4041
4075: POP
4076: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
4077: LD_VAR 0 3
4081: PPUSH
4082: LD_INT 92
4084: PUSH
4085: LD_EXP 29
4089: PPUSH
4090: CALL_OW 250
4094: PUSH
4095: LD_EXP 29
4099: PPUSH
4100: CALL_OW 251
4104: PUSH
4105: LD_INT 10
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: LIST
4112: LIST
4113: PPUSH
4114: CALL_OW 72
4118: PUSH
4119: LD_VAR 0 3
4123: EQUAL
4124: IFFALSE 4024
// for i in units do
4126: LD_ADDR_VAR 0 2
4130: PUSH
4131: LD_VAR 0 3
4135: PUSH
4136: FOR_IN
4137: IFFALSE 4155
// ComTurnUnit ( i , JMM ) ;
4139: LD_VAR 0 2
4143: PPUSH
4144: LD_EXP 29
4148: PPUSH
4149: CALL_OW 119
4153: GO 4136
4155: POP
4156: POP
// ComTurnUnit ( Cornel , JMM ) ;
4157: LD_EXP 36
4161: PPUSH
4162: LD_EXP 29
4166: PPUSH
4167: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
4171: LD_EXP 29
4175: PPUSH
4176: LD_STRING D1-JMM-1
4178: PPUSH
4179: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
4183: LD_EXP 36
4187: PPUSH
4188: LD_STRING D1-Corn-1
4190: PPUSH
4191: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
4195: LD_EXP 29
4199: PPUSH
4200: LD_EXP 36
4204: PPUSH
4205: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
4209: LD_EXP 36
4213: PPUSH
4214: LD_EXP 29
4218: PPUSH
4219: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
4223: LD_INT 35
4225: PPUSH
4226: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
4230: LD_EXP 29
4234: PPUSH
4235: LD_EXP 36
4239: PPUSH
4240: CALL_OW 296
4244: PUSH
4245: LD_INT 6
4247: LESS
4248: IFFALSE 4223
// ChangeSideFog ( 4 , 1 ) ;
4250: LD_INT 4
4252: PPUSH
4253: LD_INT 1
4255: PPUSH
4256: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
4260: LD_EXP 29
4264: PPUSH
4265: LD_EXP 36
4269: PPUSH
4270: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
4274: LD_EXP 36
4278: PPUSH
4279: LD_EXP 29
4283: PPUSH
4284: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
4288: LD_EXP 29
4292: PPUSH
4293: LD_STRING D1-JMM-2
4295: PPUSH
4296: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
4300: LD_EXP 29
4304: PPUSH
4305: LD_STRING D1-JMM-2a
4307: PPUSH
4308: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
4312: LD_EXP 36
4316: PPUSH
4317: LD_STRING D1-Corn-2
4319: PPUSH
4320: CALL_OW 88
// if bierezov_exist or debug then
4324: LD_EXP 5
4328: PUSH
4329: LD_EXP 1
4333: OR
4334: IFFALSE 4575
// begin ComTurnUnit ( Cornel , Bierezov ) ;
4336: LD_EXP 36
4340: PPUSH
4341: LD_EXP 37
4345: PPUSH
4346: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
4350: LD_INT 10
4352: PPUSH
4353: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
4357: LD_EXP 36
4361: PPUSH
4362: LD_STRING D1a-Corn-1
4364: PPUSH
4365: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
4369: LD_EXP 29
4373: PPUSH
4374: LD_EXP 37
4378: PPUSH
4379: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
4383: LD_EXP 37
4387: PPUSH
4388: LD_EXP 29
4392: PPUSH
4393: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
4397: LD_EXP 29
4401: PPUSH
4402: LD_STRING D1a-JMM-1
4404: PPUSH
4405: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
4409: LD_EXP 29
4413: PPUSH
4414: LD_EXP 36
4418: PPUSH
4419: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
4423: LD_EXP 36
4427: PPUSH
4428: LD_EXP 29
4432: PPUSH
4433: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
4437: LD_EXP 36
4441: PPUSH
4442: LD_STRING D1a-Corn-2
4444: PPUSH
4445: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
4449: LD_EXP 29
4453: PPUSH
4454: LD_STRING D1a-JMM-2
4456: PPUSH
4457: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
4461: LD_EXP 36
4465: PPUSH
4466: LD_STRING D1a-Corn-3
4468: PPUSH
4469: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
4473: LD_EXP 29
4477: PPUSH
4478: LD_STRING D1a-JMM-3
4480: PPUSH
4481: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
4485: LD_EXP 36
4489: PPUSH
4490: LD_STRING D1a-Corn-4
4492: PPUSH
4493: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
4497: LD_EXP 29
4501: PPUSH
4502: LD_STRING D1a-JMM-4
4504: PPUSH
4505: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
4509: LD_EXP 36
4513: PPUSH
4514: LD_STRING D1a-Corn-5
4516: PPUSH
4517: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
4521: LD_EXP 37
4525: PPUSH
4526: LD_EXP 36
4530: PPUSH
4531: CALL_OW 250
4535: PPUSH
4536: LD_EXP 36
4540: PPUSH
4541: CALL_OW 251
4545: PUSH
4546: LD_INT 2
4548: MINUS
4549: PPUSH
4550: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
4554: LD_EXP 37
4558: PPUSH
4559: LD_EXP 36
4563: PPUSH
4564: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
4568: LD_INT 10
4570: PPUSH
4571: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
4575: LD_EXP 29
4579: PPUSH
4580: LD_STRING D1b-JMM-1
4582: PPUSH
4583: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
4587: LD_EXP 36
4591: PPUSH
4592: LD_STRING D1b-Corn-1
4594: PPUSH
4595: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
4599: LD_EXP 29
4603: PPUSH
4604: LD_STRING D1b-JMM-2
4606: PPUSH
4607: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
4611: LD_EXP 36
4615: PPUSH
4616: LD_STRING D1b-Corn-2
4618: PPUSH
4619: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
4623: LD_EXP 29
4627: PPUSH
4628: LD_STRING D1b-JMM-3
4630: PPUSH
4631: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
4635: LD_INT 10
4637: PPUSH
4638: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
4642: LD_EXP 38
4646: PPUSH
4647: LD_STRING D1b-Pow-3
4649: PPUSH
4650: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
4654: LD_EXP 29
4658: PPUSH
4659: LD_STRING D1b-JMM-4
4661: PPUSH
4662: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
4666: LD_EXP 36
4670: PPUSH
4671: LD_STRING D1b-Corn-4
4673: PPUSH
4674: CALL_OW 88
// if Khatam then
4678: LD_EXP 33
4682: IFFALSE 4698
// Say ( Khatam , D1b-Khat-4 ) else
4684: LD_EXP 33
4688: PPUSH
4689: LD_STRING D1b-Khat-4
4691: PPUSH
4692: CALL_OW 88
4696: GO 4734
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
4698: LD_EXP 4
4702: PPUSH
4703: LD_INT 26
4705: PUSH
4706: LD_INT 1
4708: PUSH
4709: EMPTY
4710: LIST
4711: LIST
4712: PPUSH
4713: CALL_OW 72
4717: PUSH
4718: LD_EXP 36
4722: PUSH
4723: EMPTY
4724: LIST
4725: DIFF
4726: PPUSH
4727: LD_STRING D1b-Sol1-4
4729: PPUSH
4730: CALL 561 0 2
// if Cyrus then
4734: LD_EXP 31
4738: IFFALSE 4752
// Say ( Cyrus , D1b-Cyrus-4 ) ;
4740: LD_EXP 31
4744: PPUSH
4745: LD_STRING D1b-Cyrus-4
4747: PPUSH
4748: CALL_OW 88
// if Lisa then
4752: LD_EXP 32
4756: IFFALSE 4814
// begin Say ( Lisa , D1b-Lisa-4 ) ;
4758: LD_EXP 32
4762: PPUSH
4763: LD_STRING D1b-Lisa-4
4765: PPUSH
4766: CALL_OW 88
// if Cyrus then
4770: LD_EXP 31
4774: IFFALSE 4814
// begin if not IsInUnit ( Cyrus ) then
4776: LD_EXP 31
4780: PPUSH
4781: CALL_OW 310
4785: NOT
4786: IFFALSE 4802
// ComTurnUnit ( Cyrus , Lisa ) ;
4788: LD_EXP 31
4792: PPUSH
4793: LD_EXP 32
4797: PPUSH
4798: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
4802: LD_EXP 31
4806: PPUSH
4807: LD_STRING D1b-Cyrus-5
4809: PPUSH
4810: CALL_OW 88
// end ; end ; SelectGroup ;
4814: CALL 2514 0 0
// Say ( JMM , D1d-JMM-1 ) ;
4818: LD_EXP 29
4822: PPUSH
4823: LD_STRING D1d-JMM-1
4825: PPUSH
4826: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
4830: LD_EXP 36
4834: PPUSH
4835: LD_STRING D1d-Corn-1
4837: PPUSH
4838: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
4842: LD_ADDR_VAR 0 2
4846: PUSH
4847: LD_EXP 2
4851: PUSH
4852: LD_EXP 4
4856: ADD
4857: PUSH
4858: LD_EXP 29
4862: ADD
4863: PUSH
4864: FOR_IN
4865: IFFALSE 4878
// ComHold ( i ) ;
4867: LD_VAR 0 2
4871: PPUSH
4872: CALL_OW 140
4876: GO 4864
4878: POP
4879: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
4880: LD_ADDR_VAR 0 4
4884: PUSH
4885: LD_INT 22
4887: PUSH
4888: LD_INT 1
4890: PUSH
4891: EMPTY
4892: LIST
4893: LIST
4894: PUSH
4895: LD_INT 21
4897: PUSH
4898: LD_INT 2
4900: PUSH
4901: EMPTY
4902: LIST
4903: LIST
4904: PUSH
4905: EMPTY
4906: LIST
4907: LIST
4908: PPUSH
4909: CALL_OW 69
4913: ST_TO_ADDR
// if vehicles then
4914: LD_VAR 0 4
4918: IFFALSE 5256
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
4920: LD_EXP 4
4924: PPUSH
4925: LD_INT 55
4927: PUSH
4928: EMPTY
4929: LIST
4930: PPUSH
4931: CALL_OW 72
4935: IFFALSE 4974
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
4937: LD_ADDR_VAR 0 2
4941: PUSH
4942: LD_EXP 4
4946: PPUSH
4947: LD_INT 55
4949: PUSH
4950: EMPTY
4951: LIST
4952: PPUSH
4953: CALL_OW 72
4957: PUSH
4958: FOR_IN
4959: IFFALSE 4972
// ComExitVehicle ( i ) ;
4961: LD_VAR 0 2
4965: PPUSH
4966: CALL_OW 121
4970: GO 4958
4972: POP
4973: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
4974: LD_ADDR_VAR 0 5
4978: PUSH
4979: LD_VAR 0 4
4983: PPUSH
4984: LD_INT 34
4986: PUSH
4987: LD_INT 51
4989: PUSH
4990: EMPTY
4991: LIST
4992: LIST
4993: PPUSH
4994: CALL_OW 72
4998: ST_TO_ADDR
// if cargos then
4999: LD_VAR 0 5
5003: IFFALSE 5186
// begin vehicles := cargos ;
5005: LD_ADDR_VAR 0 4
5009: PUSH
5010: LD_VAR 0 5
5014: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
5015: LD_ADDR_VAR 0 6
5019: PUSH
5020: LD_STRING 02_resources_4
5022: PPUSH
5023: LD_INT 0
5025: PPUSH
5026: CALL_OW 30
5030: ST_TO_ADDR
// if debug and not resources then
5031: LD_EXP 1
5035: PUSH
5036: LD_VAR 0 6
5040: NOT
5041: AND
5042: IFFALSE 5052
// resources := 160 ;
5044: LD_ADDR_VAR 0 6
5048: PUSH
5049: LD_INT 160
5051: ST_TO_ADDR
// if resources mod 10 then
5052: LD_VAR 0 6
5056: PUSH
5057: LD_INT 10
5059: MOD
5060: IFFALSE 5082
// resources := resources - resources mod 10 ;
5062: LD_ADDR_VAR 0 6
5066: PUSH
5067: LD_VAR 0 6
5071: PUSH
5072: LD_VAR 0 6
5076: PUSH
5077: LD_INT 10
5079: MOD
5080: MINUS
5081: ST_TO_ADDR
// if resources then
5082: LD_VAR 0 6
5086: IFFALSE 5186
// for i in cargos do
5088: LD_ADDR_VAR 0 2
5092: PUSH
5093: LD_VAR 0 5
5097: PUSH
5098: FOR_IN
5099: IFFALSE 5184
// begin if resources < 100 then
5101: LD_VAR 0 6
5105: PUSH
5106: LD_INT 100
5108: LESS
5109: IFFALSE 5131
// begin cargo := resources ;
5111: LD_ADDR_VAR 0 7
5115: PUSH
5116: LD_VAR 0 6
5120: ST_TO_ADDR
// resources := 0 ;
5121: LD_ADDR_VAR 0 6
5125: PUSH
5126: LD_INT 0
5128: ST_TO_ADDR
// end else
5129: GO 5153
// begin cargo := 100 ;
5131: LD_ADDR_VAR 0 7
5135: PUSH
5136: LD_INT 100
5138: ST_TO_ADDR
// resources := resources - 100 ;
5139: LD_ADDR_VAR 0 6
5143: PUSH
5144: LD_VAR 0 6
5148: PUSH
5149: LD_INT 100
5151: MINUS
5152: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
5153: LD_VAR 0 2
5157: PPUSH
5158: LD_INT 1
5160: PPUSH
5161: LD_VAR 0 7
5165: PPUSH
5166: CALL_OW 290
// if resources = 0 then
5170: LD_VAR 0 6
5174: PUSH
5175: LD_INT 0
5177: EQUAL
5178: IFFALSE 5182
// break ;
5180: GO 5184
// end ;
5182: GO 5098
5184: POP
5185: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
5186: LD_VAR 0 4
5190: PUSH
5191: LD_INT 1
5193: ARRAY
5194: PPUSH
5195: CALL_OW 311
5199: PPUSH
5200: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
5204: LD_VAR 0 4
5208: PUSH
5209: LD_INT 1
5211: ARRAY
5212: PPUSH
5213: LD_INT 4
5215: PPUSH
5216: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
5220: LD_EXP 36
5224: PPUSH
5225: LD_VAR 0 4
5229: PUSH
5230: LD_INT 1
5232: ARRAY
5233: PPUSH
5234: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
5238: LD_INT 35
5240: PPUSH
5241: CALL_OW 67
// until IsInUnit ( Cornel ) ;
5245: LD_EXP 36
5249: PPUSH
5250: CALL_OW 310
5254: IFFALSE 5238
// end ; InGameOff ;
5256: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
5260: LD_STRING M1
5262: PPUSH
5263: CALL_OW 337
// SaveForQuickRestart ;
5267: CALL_OW 22
// cornel_active := true ;
5271: LD_ADDR_EXP 6
5275: PUSH
5276: LD_INT 1
5278: ST_TO_ADDR
// end ;
5279: LD_VAR 0 1
5283: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
5284: LD_EXP 29
5288: PPUSH
5289: LD_EXP 39
5293: PPUSH
5294: CALL_OW 296
5298: PUSH
5299: LD_INT 10
5301: LESS
5302: IFFALSE 6417
5304: GO 5306
5306: DISABLE
5307: LD_INT 0
5309: PPUSH
5310: PPUSH
5311: PPUSH
5312: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
5313: LD_ADDR_VAR 0 2
5317: PUSH
5318: LD_INT 89
5320: PUSH
5321: LD_INT 34
5323: PUSH
5324: EMPTY
5325: LIST
5326: LIST
5327: PUSH
5328: LD_INT 138
5330: PUSH
5331: LD_INT 63
5333: PUSH
5334: EMPTY
5335: LIST
5336: LIST
5337: PUSH
5338: LD_INT 196
5340: PUSH
5341: LD_INT 84
5343: PUSH
5344: EMPTY
5345: LIST
5346: LIST
5347: PUSH
5348: LD_INT 135
5350: PUSH
5351: LD_INT 52
5353: PUSH
5354: EMPTY
5355: LIST
5356: LIST
5357: PUSH
5358: LD_INT 103
5360: PUSH
5361: LD_INT 39
5363: PUSH
5364: EMPTY
5365: LIST
5366: LIST
5367: PUSH
5368: LD_INT 58
5370: PUSH
5371: LD_INT 30
5373: PUSH
5374: EMPTY
5375: LIST
5376: LIST
5377: PUSH
5378: LD_INT 38
5380: PUSH
5381: LD_INT 51
5383: PUSH
5384: EMPTY
5385: LIST
5386: LIST
5387: PUSH
5388: EMPTY
5389: LIST
5390: LIST
5391: LIST
5392: LIST
5393: LIST
5394: LIST
5395: LIST
5396: ST_TO_ADDR
// InGameOn ;
5397: CALL_OW 8
// if jmm_units then
5401: LD_EXP 2
5405: IFFALSE 5469
// for i in jmm_units do
5407: LD_ADDR_VAR 0 1
5411: PUSH
5412: LD_EXP 2
5416: PUSH
5417: FOR_IN
5418: IFFALSE 5467
// begin if GetDistUnits ( i , JMM ) < 10 then
5420: LD_VAR 0 1
5424: PPUSH
5425: LD_EXP 29
5429: PPUSH
5430: CALL_OW 296
5434: PUSH
5435: LD_INT 10
5437: LESS
5438: IFFALSE 5456
// ComTurnUnit ( i , JMM ) else
5440: LD_VAR 0 1
5444: PPUSH
5445: LD_EXP 29
5449: PPUSH
5450: CALL_OW 119
5454: GO 5465
// ComHold ( i ) ;
5456: LD_VAR 0 1
5460: PPUSH
5461: CALL_OW 140
// end ;
5465: GO 5417
5467: POP
5468: POP
// ComMoveUnit ( JMM , Lynch ) ;
5469: LD_EXP 29
5473: PPUSH
5474: LD_EXP 39
5478: PPUSH
5479: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5483: LD_INT 35
5485: PPUSH
5486: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
5490: LD_EXP 29
5494: PPUSH
5495: LD_EXP 39
5499: PPUSH
5500: CALL_OW 296
5504: PUSH
5505: LD_INT 6
5507: LESS
5508: IFFALSE 5483
// ComTurnUnit ( JMM , Lynch ) ;
5510: LD_EXP 29
5514: PPUSH
5515: LD_EXP 39
5519: PPUSH
5520: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
5524: LD_ADDR_VAR 0 1
5528: PUSH
5529: LD_EXP 39
5533: PUSH
5534: LD_EXP 40
5538: PUSH
5539: LD_EXP 41
5543: PUSH
5544: LD_EXP 42
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: PUSH
5555: FOR_IN
5556: IFFALSE 5574
// ComTurnUnit ( i , JMM ) ;
5558: LD_VAR 0 1
5562: PPUSH
5563: LD_EXP 29
5567: PPUSH
5568: CALL_OW 119
5572: GO 5555
5574: POP
5575: POP
// Wait ( 0 0$0.3 ) ;
5576: LD_INT 10
5578: PPUSH
5579: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
5583: LD_EXP 29
5587: PPUSH
5588: LD_STRING D2-JMM-1
5590: PPUSH
5591: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
5595: LD_EXP 39
5599: PPUSH
5600: LD_STRING D2-Sol1-1
5602: PPUSH
5603: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
5607: LD_EXP 29
5611: PPUSH
5612: LD_STRING D2-JMM-2
5614: PPUSH
5615: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
5619: LD_EXP 39
5623: PPUSH
5624: LD_STRING D2-Sol1-2
5626: PPUSH
5627: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
5631: LD_EXP 29
5635: PPUSH
5636: LD_STRING D2-JMM-3
5638: PPUSH
5639: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
5643: LD_EXP 39
5647: PPUSH
5648: LD_STRING D2-Sol1-3
5650: PPUSH
5651: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
5655: LD_ADDR_VAR 0 1
5659: PUSH
5660: LD_INT 22
5662: PUSH
5663: LD_INT 8
5665: PUSH
5666: EMPTY
5667: LIST
5668: LIST
5669: PPUSH
5670: CALL_OW 69
5674: PUSH
5675: FOR_IN
5676: IFFALSE 5692
// SetSide ( i , 1 ) ;
5678: LD_VAR 0 1
5682: PPUSH
5683: LD_INT 1
5685: PPUSH
5686: CALL_OW 235
5690: GO 5675
5692: POP
5693: POP
// Say ( JMM , D2-JMM-4 ) ;
5694: LD_EXP 29
5698: PPUSH
5699: LD_STRING D2-JMM-4
5701: PPUSH
5702: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
5706: LD_INT 1
5708: PPUSH
5709: LD_INT 5
5711: PPUSH
5712: CALL_OW 332
// for i = 1 to points do
5716: LD_ADDR_VAR 0 1
5720: PUSH
5721: DOUBLE
5722: LD_INT 1
5724: DEC
5725: ST_TO_ADDR
5726: LD_VAR 0 2
5730: PUSH
5731: FOR_TO
5732: IFFALSE 5907
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
5734: LD_VAR 0 2
5738: PUSH
5739: LD_VAR 0 1
5743: ARRAY
5744: PUSH
5745: LD_INT 1
5747: ARRAY
5748: PPUSH
5749: LD_VAR 0 2
5753: PUSH
5754: LD_VAR 0 1
5758: ARRAY
5759: PUSH
5760: LD_INT 2
5762: ARRAY
5763: PPUSH
5764: CALL_OW 84
// if i = 1 then
5768: LD_VAR 0 1
5772: PUSH
5773: LD_INT 1
5775: EQUAL
5776: IFFALSE 5790
// Say ( Lynch , D2-Sol1-4 ) ;
5778: LD_EXP 39
5782: PPUSH
5783: LD_STRING D2-Sol1-4
5785: PPUSH
5786: CALL_OW 88
// if i = 2 then
5790: LD_VAR 0 1
5794: PUSH
5795: LD_INT 2
5797: EQUAL
5798: IFFALSE 5812
// Say ( JMM , D2-JMM-5 ) ;
5800: LD_EXP 29
5804: PPUSH
5805: LD_STRING D2-JMM-5
5807: PPUSH
5808: CALL_OW 88
// if i = 4 then
5812: LD_VAR 0 1
5816: PUSH
5817: LD_INT 4
5819: EQUAL
5820: IFFALSE 5844
// begin RevealFogArea ( 1 , troopsArea ) ;
5822: LD_INT 1
5824: PPUSH
5825: LD_INT 6
5827: PPUSH
5828: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
5832: LD_EXP 39
5836: PPUSH
5837: LD_STRING D2-Sol1-5
5839: PPUSH
5840: CALL_OW 88
// end ; if i = 5 then
5844: LD_VAR 0 1
5848: PUSH
5849: LD_INT 5
5851: EQUAL
5852: IFFALSE 5866
// Say ( JMM , D2-JMM-6 ) ;
5854: LD_EXP 29
5858: PPUSH
5859: LD_STRING D2-JMM-6
5861: PPUSH
5862: CALL_OW 88
// if i = 7 then
5866: LD_VAR 0 1
5870: PUSH
5871: LD_INT 7
5873: EQUAL
5874: IFFALSE 5898
// begin RevealFogArea ( 1 , forestArea ) ;
5876: LD_INT 1
5878: PPUSH
5879: LD_INT 7
5881: PPUSH
5882: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
5886: LD_EXP 39
5890: PPUSH
5891: LD_STRING D2-Sol1-6
5893: PPUSH
5894: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
5898: LD_INT 46
5900: PPUSH
5901: CALL_OW 67
// end ;
5905: GO 5731
5907: POP
5908: POP
// CenterNowOnUnits ( JMM ) ;
5909: LD_EXP 29
5913: PPUSH
5914: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
5918: LD_EXP 29
5922: PPUSH
5923: LD_STRING D2-JMM-7
5925: PPUSH
5926: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
5930: LD_EXP 39
5934: PPUSH
5935: LD_STRING D2-Sol1-7
5937: PPUSH
5938: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
5942: LD_EXP 29
5946: PPUSH
5947: LD_STRING D2-JMM-8
5949: PPUSH
5950: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
5954: LD_ADDR_VAR 0 4
5958: PUSH
5959: LD_INT 22
5961: PUSH
5962: LD_INT 1
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: PUSH
5969: LD_INT 30
5971: PUSH
5972: LD_INT 31
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: PUSH
5979: EMPTY
5980: LIST
5981: LIST
5982: PPUSH
5983: CALL_OW 69
5987: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
5988: LD_EXP 39
5992: PPUSH
5993: LD_VAR 0 4
5997: PUSH
5998: LD_INT 1
6000: ARRAY
6001: PPUSH
6002: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
6006: LD_ADDR_VAR 0 3
6010: PUSH
6011: LD_EXP 2
6015: PPUSH
6016: LD_INT 25
6018: PUSH
6019: LD_INT 1
6021: PUSH
6022: EMPTY
6023: LIST
6024: LIST
6025: PPUSH
6026: CALL_OW 72
6030: PPUSH
6031: LD_EXP 29
6035: PPUSH
6036: CALL_OW 74
6040: ST_TO_ADDR
// if sol then
6041: LD_VAR 0 3
6045: IFFALSE 6085
// if GetDistUnits ( JMM , sol ) < 10 then
6047: LD_EXP 29
6051: PPUSH
6052: LD_VAR 0 3
6056: PPUSH
6057: CALL_OW 296
6061: PUSH
6062: LD_INT 10
6064: LESS
6065: IFFALSE 6085
// ComEnterUnit ( sol , buns [ 2 ] ) ;
6067: LD_VAR 0 3
6071: PPUSH
6072: LD_VAR 0 4
6076: PUSH
6077: LD_INT 2
6079: ARRAY
6080: PPUSH
6081: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
6085: LD_INT 10
6087: PPUSH
6088: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
6092: LD_EXP 29
6096: PPUSH
6097: LD_INT 65
6099: PPUSH
6100: LD_INT 101
6102: PPUSH
6103: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
6107: LD_EXP 29
6111: PPUSH
6112: LD_INT 63
6114: PPUSH
6115: LD_INT 100
6117: PPUSH
6118: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
6122: LD_INT 35
6124: PPUSH
6125: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
6129: LD_EXP 29
6133: PPUSH
6134: LD_INT 65
6136: PPUSH
6137: LD_INT 101
6139: PPUSH
6140: CALL_OW 307
6144: IFFALSE 6122
// Say ( JMM , D2a-JMM-1 ) ;
6146: LD_EXP 29
6150: PPUSH
6151: LD_STRING D2a-JMM-1
6153: PPUSH
6154: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
6158: LD_EXP 40
6162: PPUSH
6163: LD_INT 66
6165: PPUSH
6166: LD_INT 103
6168: PPUSH
6169: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
6173: LD_INT 35
6175: PPUSH
6176: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
6180: LD_EXP 40
6184: PPUSH
6185: LD_INT 66
6187: PPUSH
6188: LD_INT 103
6190: PPUSH
6191: CALL_OW 307
6195: IFFALSE 6173
// ComTurnUnit ( Walker , JMM ) ;
6197: LD_EXP 40
6201: PPUSH
6202: LD_EXP 29
6206: PPUSH
6207: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
6211: LD_EXP 40
6215: PPUSH
6216: LD_STRING D2a-Sci1-1
6218: PPUSH
6219: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
6223: LD_EXP 29
6227: PPUSH
6228: LD_EXP 40
6232: PPUSH
6233: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
6237: LD_EXP 29
6241: PPUSH
6242: LD_STRING D2a-JMM-2
6244: PPUSH
6245: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
6249: LD_EXP 40
6253: PPUSH
6254: LD_STRING D2a-Sci1-2
6256: PPUSH
6257: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
6261: LD_EXP 29
6265: PPUSH
6266: LD_STRING D2a-JMM-3
6268: PPUSH
6269: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
6273: LD_EXP 40
6277: PPUSH
6278: LD_STRING D2a-Sci1-3
6280: PPUSH
6281: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
6285: LD_ADDR_EXP 2
6289: PUSH
6290: LD_EXP 2
6294: PUSH
6295: LD_EXP 39
6299: PUSH
6300: LD_EXP 40
6304: PUSH
6305: LD_EXP 41
6309: PUSH
6310: LD_EXP 42
6314: PUSH
6315: EMPTY
6316: LIST
6317: LIST
6318: LIST
6319: LIST
6320: ADD
6321: ST_TO_ADDR
// for i in jmm_units do
6322: LD_ADDR_VAR 0 1
6326: PUSH
6327: LD_EXP 2
6331: PUSH
6332: FOR_IN
6333: IFFALSE 6358
// if not IsInUnit ( i ) then
6335: LD_VAR 0 1
6339: PPUSH
6340: CALL_OW 310
6344: NOT
6345: IFFALSE 6356
// ComFree ( i ) ;
6347: LD_VAR 0 1
6351: PPUSH
6352: CALL_OW 139
6356: GO 6332
6358: POP
6359: POP
// InGameOff ;
6360: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
6364: LD_STRING MSolar1
6366: PPUSH
6367: CALL_OW 337
// jmm_on_west := true ;
6371: LD_ADDR_EXP 3
6375: PUSH
6376: LD_INT 1
6378: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
6379: LD_INT 1050
6381: PPUSH
6382: CALL_OW 67
// frank_can_return := true ;
6386: LD_ADDR_EXP 10
6390: PUSH
6391: LD_INT 1
6393: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
6394: LD_INT 6300
6396: PPUSH
6397: LD_INT 8400
6399: PPUSH
6400: CALL_OW 12
6404: PPUSH
6405: CALL_OW 67
// send_spec_patrol := true ;
6409: LD_ADDR_EXP 25
6413: PUSH
6414: LD_INT 1
6416: ST_TO_ADDR
// end ;
6417: PPOPN 4
6419: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
6420: LD_INT 22
6422: PUSH
6423: LD_INT 1
6425: PUSH
6426: EMPTY
6427: LIST
6428: LIST
6429: PUSH
6430: LD_INT 34
6432: PUSH
6433: LD_INT 51
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: PUSH
6440: LD_INT 92
6442: PUSH
6443: LD_INT 63
6445: PUSH
6446: LD_INT 100
6448: PUSH
6449: LD_INT 5
6451: PUSH
6452: EMPTY
6453: LIST
6454: LIST
6455: LIST
6456: LIST
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: LIST
6462: PUSH
6463: EMPTY
6464: LIST
6465: PPUSH
6466: CALL_OW 69
6470: PUSH
6471: LD_EXP 3
6475: NOT
6476: AND
6477: IFFALSE 6590
6479: GO 6481
6481: DISABLE
6482: LD_INT 0
6484: PPUSH
6485: PPUSH
// begin enable ;
6486: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
6487: LD_ADDR_VAR 0 2
6491: PUSH
6492: LD_INT 22
6494: PUSH
6495: LD_INT 1
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: PUSH
6502: LD_INT 34
6504: PUSH
6505: LD_INT 51
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: PUSH
6512: LD_INT 92
6514: PUSH
6515: LD_INT 63
6517: PUSH
6518: LD_INT 100
6520: PUSH
6521: LD_INT 5
6523: PUSH
6524: EMPTY
6525: LIST
6526: LIST
6527: LIST
6528: LIST
6529: PUSH
6530: EMPTY
6531: LIST
6532: LIST
6533: LIST
6534: PUSH
6535: EMPTY
6536: LIST
6537: PPUSH
6538: CALL_OW 69
6542: ST_TO_ADDR
// if not filter then
6543: LD_VAR 0 2
6547: NOT
6548: IFFALSE 6552
// exit ;
6550: GO 6590
// for i in filter do
6552: LD_ADDR_VAR 0 1
6556: PUSH
6557: LD_VAR 0 2
6561: PUSH
6562: FOR_IN
6563: IFFALSE 6588
// begin SetFuel ( i , 0 ) ;
6565: LD_VAR 0 1
6569: PPUSH
6570: LD_INT 0
6572: PPUSH
6573: CALL_OW 240
// ComStop ( i ) ;
6577: LD_VAR 0 1
6581: PPUSH
6582: CALL_OW 141
// end ;
6586: GO 6562
6588: POP
6589: POP
// end ;
6590: PPOPN 2
6592: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
6593: LD_EXP 25
6597: IFFALSE 7542
6599: GO 6601
6601: DISABLE
6602: LD_INT 0
6604: PPUSH
6605: PPUSH
6606: PPUSH
6607: PPUSH
6608: PPUSH
6609: PPUSH
6610: PPUSH
// begin if not ru_spec_patrol then
6611: LD_EXP 46
6615: NOT
6616: IFFALSE 6620
// exit ;
6618: GO 7542
// dead1 := false ;
6620: LD_ADDR_VAR 0 1
6624: PUSH
6625: LD_INT 0
6627: ST_TO_ADDR
// dead2 := false ;
6628: LD_ADDR_VAR 0 2
6632: PUSH
6633: LD_INT 0
6635: ST_TO_ADDR
// inarea1 := false ;
6636: LD_ADDR_VAR 0 3
6640: PUSH
6641: LD_INT 0
6643: ST_TO_ADDR
// inarea2 := false ;
6644: LD_ADDR_VAR 0 4
6648: PUSH
6649: LD_INT 0
6651: ST_TO_ADDR
// tmp := [ ] ;
6652: LD_ADDR_VAR 0 6
6656: PUSH
6657: EMPTY
6658: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
6659: LD_EXP 46
6663: PPUSH
6664: LD_INT 75
6666: PPUSH
6667: LD_INT 101
6669: PPUSH
6670: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
6674: LD_INT 35
6676: PPUSH
6677: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
6681: LD_INT 1
6683: PPUSH
6684: LD_EXP 46
6688: PUSH
6689: LD_INT 1
6691: ARRAY
6692: PPUSH
6693: CALL_OW 292
6697: IFFALSE 6674
// ComStop ( ru_spec_patrol ) ;
6699: LD_EXP 46
6703: PPUSH
6704: CALL_OW 141
// Wait ( 0 0$02 ) ;
6708: LD_INT 70
6710: PPUSH
6711: CALL_OW 67
// DialogueOn ;
6715: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
6719: LD_EXP 46
6723: PUSH
6724: LD_INT 1
6726: ARRAY
6727: PPUSH
6728: LD_STRING D8-Rus1-1
6730: PPUSH
6731: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
6735: LD_EXP 29
6739: PPUSH
6740: LD_STRING D8-JMM-1
6742: PPUSH
6743: CALL_OW 88
// DialogueOff ;
6747: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
6751: LD_EXP 46
6755: PPUSH
6756: LD_INT 13
6758: PPUSH
6759: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
6763: LD_INT 35
6765: PPUSH
6766: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
6770: LD_VAR 0 1
6774: NOT
6775: PUSH
6776: LD_EXP 46
6780: PUSH
6781: LD_INT 1
6783: ARRAY
6784: PPUSH
6785: CALL_OW 301
6789: AND
6790: IFFALSE 6800
// dead1 := true ;
6792: LD_ADDR_VAR 0 1
6796: PUSH
6797: LD_INT 1
6799: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
6800: LD_VAR 0 2
6804: NOT
6805: PUSH
6806: LD_EXP 46
6810: PUSH
6811: LD_INT 2
6813: ARRAY
6814: PPUSH
6815: CALL_OW 301
6819: AND
6820: IFFALSE 6830
// dead2 := true ;
6822: LD_ADDR_VAR 0 2
6826: PUSH
6827: LD_INT 1
6829: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
6830: LD_VAR 0 3
6834: NOT
6835: PUSH
6836: LD_EXP 46
6840: PUSH
6841: LD_INT 1
6843: ARRAY
6844: PPUSH
6845: LD_INT 14
6847: PPUSH
6848: CALL_OW 308
6852: AND
6853: IFFALSE 6863
// inarea1 := true ;
6855: LD_ADDR_VAR 0 3
6859: PUSH
6860: LD_INT 1
6862: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
6863: LD_VAR 0 4
6867: NOT
6868: PUSH
6869: LD_EXP 46
6873: PUSH
6874: LD_INT 2
6876: ARRAY
6877: PPUSH
6878: LD_INT 14
6880: PPUSH
6881: CALL_OW 308
6885: AND
6886: IFFALSE 6896
// inarea2 := true ;
6888: LD_ADDR_VAR 0 4
6892: PUSH
6893: LD_INT 1
6895: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
6896: LD_VAR 0 1
6900: PUSH
6901: LD_VAR 0 2
6905: AND
6906: PUSH
6907: LD_VAR 0 1
6911: PUSH
6912: LD_VAR 0 4
6916: AND
6917: OR
6918: PUSH
6919: LD_VAR 0 2
6923: PUSH
6924: LD_VAR 0 3
6928: AND
6929: OR
6930: PUSH
6931: LD_VAR 0 3
6935: PUSH
6936: LD_VAR 0 4
6940: AND
6941: OR
6942: IFFALSE 6763
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
6944: LD_VAR 0 3
6948: PUSH
6949: LD_VAR 0 4
6953: AND
6954: PUSH
6955: LD_VAR 0 1
6959: PUSH
6960: LD_VAR 0 4
6964: AND
6965: OR
6966: PUSH
6967: LD_VAR 0 2
6971: PUSH
6972: LD_VAR 0 3
6976: AND
6977: OR
6978: IFFALSE 7522
// begin prepare_siege := true ;
6980: LD_ADDR_EXP 26
6984: PUSH
6985: LD_INT 1
6987: ST_TO_ADDR
// DialogueOn ;
6988: CALL_OW 6
// if ( inarea1 and inarea2 ) then
6992: LD_VAR 0 3
6996: PUSH
6997: LD_VAR 0 4
7001: AND
7002: IFFALSE 7018
// Say ( JMM , D8b-JMM-1a ) else
7004: LD_EXP 29
7008: PPUSH
7009: LD_STRING D8b-JMM-1a
7011: PPUSH
7012: CALL_OW 88
7016: GO 7030
// Say ( JMM , D8b-JMM-1 ) ;
7018: LD_EXP 29
7022: PPUSH
7023: LD_STRING D8b-JMM-1
7025: PPUSH
7026: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
7030: LD_EXP 2
7034: PPUSH
7035: LD_INT 26
7037: PUSH
7038: LD_INT 1
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PPUSH
7045: CALL_OW 72
7049: PUSH
7050: LD_EXP 30
7054: PUSH
7055: LD_EXP 31
7059: PUSH
7060: LD_EXP 40
7064: PUSH
7065: LD_EXP 43
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: LIST
7074: LIST
7075: DIFF
7076: PPUSH
7077: LD_STRING D8b-Sol1-1
7079: PPUSH
7080: CALL 561 0 2
// if Cyrus and Cyrus in jmm_units then
7084: LD_EXP 31
7088: PUSH
7089: LD_EXP 31
7093: PUSH
7094: LD_EXP 2
7098: IN
7099: AND
7100: IFFALSE 7116
// Say ( Cyrus , D8b-Cyrus-1 ) else
7102: LD_EXP 31
7106: PPUSH
7107: LD_STRING D8b-Cyrus-1
7109: PPUSH
7110: CALL_OW 88
7114: GO 7128
// Say ( JMM , D8b-JMM-1a ) ;
7116: LD_EXP 29
7120: PPUSH
7121: LD_STRING D8b-JMM-1a
7123: PPUSH
7124: CALL_OW 88
// if Lisa and Lisa in jmm_units then
7128: LD_EXP 32
7132: PUSH
7133: LD_EXP 32
7137: PUSH
7138: LD_EXP 2
7142: IN
7143: AND
7144: IFFALSE 7158
// Say ( Lisa , D8b-Lisa-2 ) ;
7146: LD_EXP 32
7150: PPUSH
7151: LD_STRING D8b-Lisa-2
7153: PPUSH
7154: CALL_OW 88
// if Bobby and Bobby in jmm_units then
7158: LD_EXP 30
7162: PUSH
7163: LD_EXP 30
7167: PUSH
7168: LD_EXP 2
7172: IN
7173: AND
7174: IFFALSE 7190
// Say ( Bobby , D8b-Bobby-1 ) else
7176: LD_EXP 30
7180: PPUSH
7181: LD_STRING D8b-Bobby-1
7183: PPUSH
7184: CALL_OW 88
7188: GO 7250
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
7190: LD_ADDR_VAR 0 5
7194: PUSH
7195: LD_EXP 2
7199: PPUSH
7200: LD_INT 26
7202: PUSH
7203: LD_INT 1
7205: PUSH
7206: EMPTY
7207: LIST
7208: LIST
7209: PPUSH
7210: CALL_OW 72
7214: PUSH
7215: LD_EXP 30
7219: PUSH
7220: LD_EXP 31
7224: PUSH
7225: LD_EXP 40
7229: PUSH
7230: LD_EXP 43
7234: PUSH
7235: EMPTY
7236: LIST
7237: LIST
7238: LIST
7239: LIST
7240: DIFF
7241: PPUSH
7242: LD_STRING D8b-Sol2-1
7244: PPUSH
7245: CALL 561 0 2
7249: ST_TO_ADDR
// DialogueOff ;
7250: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
7254: LD_EXP 31
7258: PUSH
7259: LD_EXP 31
7263: PUSH
7264: LD_EXP 2
7268: IN
7269: AND
7270: IFFALSE 7295
// tmp := Insert ( tmp , 1 , Cyrus ) ;
7272: LD_ADDR_VAR 0 6
7276: PUSH
7277: LD_VAR 0 6
7281: PPUSH
7282: LD_INT 1
7284: PPUSH
7285: LD_EXP 31
7289: PPUSH
7290: CALL_OW 2
7294: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
7295: LD_EXP 30
7299: PUSH
7300: LD_EXP 30
7304: PUSH
7305: LD_EXP 2
7309: IN
7310: AND
7311: IFFALSE 7336
// tmp := Insert ( tmp , 1 , Bobby ) ;
7313: LD_ADDR_VAR 0 6
7317: PUSH
7318: LD_VAR 0 6
7322: PPUSH
7323: LD_INT 1
7325: PPUSH
7326: LD_EXP 30
7330: PPUSH
7331: CALL_OW 2
7335: ST_TO_ADDR
// if sol then
7336: LD_VAR 0 5
7340: IFFALSE 7365
// tmp := Insert ( tmp , 1 , sol ) ;
7342: LD_ADDR_VAR 0 6
7346: PUSH
7347: LD_VAR 0 6
7351: PPUSH
7352: LD_INT 1
7354: PPUSH
7355: LD_VAR 0 5
7359: PPUSH
7360: CALL_OW 2
7364: ST_TO_ADDR
// if tmp then
7365: LD_VAR 0 6
7369: IFFALSE 7481
// begin SetSide ( tmp , 8 ) ;
7371: LD_VAR 0 6
7375: PPUSH
7376: LD_INT 8
7378: PPUSH
7379: CALL_OW 235
// ComFree ( tmp ) ;
7383: LD_VAR 0 6
7387: PPUSH
7388: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
7392: LD_VAR 0 6
7396: PPUSH
7397: LD_INT 15
7399: PPUSH
7400: CALL_OW 173
// AddComHold ( tmp ) ;
7404: LD_VAR 0 6
7408: PPUSH
7409: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7413: LD_INT 35
7415: PPUSH
7416: CALL_OW 67
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
7420: LD_VAR 0 6
7424: PUSH
7425: LD_INT 1
7427: ARRAY
7428: PPUSH
7429: LD_INT 15
7431: PPUSH
7432: CALL_OW 308
7436: IFFALSE 7471
// begin RemoveUnit ( tmp [ 1 ] ) ;
7438: LD_VAR 0 6
7442: PUSH
7443: LD_INT 1
7445: ARRAY
7446: PPUSH
7447: CALL_OW 64
// tmp := tmp diff tmp [ 1 ] ;
7451: LD_ADDR_VAR 0 6
7455: PUSH
7456: LD_VAR 0 6
7460: PUSH
7461: LD_VAR 0 6
7465: PUSH
7466: LD_INT 1
7468: ARRAY
7469: DIFF
7470: ST_TO_ADDR
// end ; until tmp = 0 ;
7471: LD_VAR 0 6
7475: PUSH
7476: LD_INT 0
7478: EQUAL
7479: IFFALSE 7413
// end ; Wait ( 0 0$30 ) ;
7481: LD_INT 1050
7483: PPUSH
7484: CALL_OW 67
// if ru_spec_patrol then
7488: LD_EXP 46
7492: IFFALSE 7520
// for i in ru_spec_patrol do
7494: LD_ADDR_VAR 0 7
7498: PUSH
7499: LD_EXP 46
7503: PUSH
7504: FOR_IN
7505: IFFALSE 7518
// RemoveUnit ( i ) ;
7507: LD_VAR 0 7
7511: PPUSH
7512: CALL_OW 64
7516: GO 7504
7518: POP
7519: POP
// end else
7520: GO 7542
// begin prepare_siege := false ;
7522: LD_ADDR_EXP 26
7526: PUSH
7527: LD_INT 0
7529: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
7530: LD_EXP 29
7534: PPUSH
7535: LD_STRING D8a-JMM-1
7537: PPUSH
7538: CALL_OW 88
// end ; end ;
7542: PPOPN 7
7544: END
// every 0 0$10 trigger frank_can_return do var i , points ;
7545: LD_EXP 10
7549: IFFALSE 8649
7551: GO 7553
7553: DISABLE
7554: LD_INT 0
7556: PPUSH
7557: PPUSH
// begin uc_side := 8 ;
7558: LD_ADDR_OWVAR 20
7562: PUSH
7563: LD_INT 8
7565: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
7566: LD_ADDR_VAR 0 2
7570: PUSH
7571: LD_INT 59
7573: PUSH
7574: LD_INT 71
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: PUSH
7581: LD_INT 122
7583: PUSH
7584: LD_INT 117
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
7595: LD_ADDR_EXP 43
7599: PUSH
7600: LD_STRING Frank
7602: PPUSH
7603: LD_INT 0
7605: PPUSH
7606: CALL 407 0 2
7610: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
7611: LD_ADDR_VAR 0 1
7615: PUSH
7616: LD_INT 1
7618: PPUSH
7619: LD_INT 2
7621: PPUSH
7622: CALL_OW 12
7626: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
7627: LD_EXP 43
7631: PPUSH
7632: LD_VAR 0 2
7636: PUSH
7637: LD_VAR 0 1
7641: ARRAY
7642: PUSH
7643: LD_INT 1
7645: ARRAY
7646: PPUSH
7647: LD_VAR 0 2
7651: PUSH
7652: LD_VAR 0 1
7656: ARRAY
7657: PUSH
7658: LD_INT 2
7660: ARRAY
7661: PPUSH
7662: LD_INT 0
7664: PPUSH
7665: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
7669: LD_EXP 43
7673: PPUSH
7674: LD_INT 1
7676: PPUSH
7677: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
7681: LD_INT 35
7683: PPUSH
7684: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
7688: LD_EXP 43
7692: PPUSH
7693: LD_EXP 29
7697: PPUSH
7698: CALL_OW 296
7702: PUSH
7703: LD_INT 8
7705: LESS
7706: IFFALSE 7681
// InGameOn ;
7708: CALL_OW 8
// CenterOnUnits ( JMM ) ;
7712: LD_EXP 29
7716: PPUSH
7717: CALL_OW 85
// if IsInUnit ( JMM ) then
7721: LD_EXP 29
7725: PPUSH
7726: CALL_OW 310
7730: IFFALSE 7741
// ComFree ( JMM ) ;
7732: LD_EXP 29
7736: PPUSH
7737: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
7741: LD_EXP 29
7745: PPUSH
7746: LD_EXP 43
7750: PPUSH
7751: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
7755: LD_EXP 43
7759: PPUSH
7760: LD_EXP 29
7764: PPUSH
7765: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
7769: LD_EXP 29
7773: PPUSH
7774: LD_STRING D6-JMM-1
7776: PPUSH
7777: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
7781: LD_INT 35
7783: PPUSH
7784: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
7788: LD_EXP 29
7792: PPUSH
7793: LD_EXP 43
7797: PPUSH
7798: CALL_OW 296
7802: PUSH
7803: LD_INT 8
7805: LESS
7806: IFFALSE 7781
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
7808: LD_EXP 32
7812: PUSH
7813: LD_EXP 32
7817: PPUSH
7818: LD_EXP 43
7822: PPUSH
7823: CALL_OW 296
7827: PUSH
7828: LD_INT 20
7830: LESS
7831: AND
7832: IFFALSE 7857
// begin ComFree ( Lisa ) ;
7834: LD_EXP 32
7838: PPUSH
7839: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
7843: LD_EXP 32
7847: PPUSH
7848: LD_EXP 43
7852: PPUSH
7853: CALL_OW 172
// end ; if Lynch then
7857: LD_EXP 39
7861: IFFALSE 7886
// begin ComFree ( Lynch ) ;
7863: LD_EXP 39
7867: PPUSH
7868: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
7872: LD_EXP 39
7876: PPUSH
7877: LD_EXP 43
7881: PPUSH
7882: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
7886: LD_EXP 29
7890: PPUSH
7891: LD_EXP 43
7895: PPUSH
7896: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
7900: LD_EXP 43
7904: PPUSH
7905: LD_EXP 29
7909: PPUSH
7910: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
7914: LD_EXP 43
7918: PPUSH
7919: LD_STRING D6-Frank-1
7921: PPUSH
7922: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
7926: LD_INT 69
7928: PPUSH
7929: LD_INT 20
7931: PPUSH
7932: LD_INT 1
7934: PPUSH
7935: LD_INT 20
7937: NEG
7938: PPUSH
7939: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
7943: LD_INT 69
7945: PPUSH
7946: LD_INT 20
7948: PPUSH
7949: LD_INT 1
7951: PPUSH
7952: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
7956: LD_INT 190
7958: PPUSH
7959: LD_INT 31
7961: PPUSH
7962: LD_INT 1
7964: PPUSH
7965: LD_INT 20
7967: NEG
7968: PPUSH
7969: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
7973: LD_INT 190
7975: PPUSH
7976: LD_INT 31
7978: PPUSH
7979: LD_INT 1
7981: PPUSH
7982: CALL_OW 331
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
7986: LD_EXP 32
7990: PUSH
7991: LD_EXP 32
7995: PPUSH
7996: LD_EXP 43
8000: PPUSH
8001: CALL_OW 296
8005: PUSH
8006: LD_INT 20
8008: LESS
8009: AND
8010: PUSH
8011: LD_EXP 32
8015: PPUSH
8016: CALL_OW 302
8020: AND
8021: IFFALSE 8111
// begin ComFree ( Lisa ) ;
8023: LD_EXP 32
8027: PPUSH
8028: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
8032: LD_INT 35
8034: PPUSH
8035: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
8039: LD_EXP 32
8043: PPUSH
8044: LD_EXP 43
8048: PPUSH
8049: CALL_OW 296
8053: PUSH
8054: LD_INT 7
8056: LESS
8057: IFFALSE 8032
// Say ( Lisa , D6-Lisa-1 ) ;
8059: LD_EXP 32
8063: PPUSH
8064: LD_STRING D6-Lisa-1
8066: PPUSH
8067: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
8071: LD_EXP 32
8075: PPUSH
8076: LD_EXP 43
8080: PPUSH
8081: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
8085: LD_EXP 43
8089: PPUSH
8090: LD_EXP 32
8094: PPUSH
8095: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
8099: LD_EXP 43
8103: PPUSH
8104: LD_STRING D6-Frank-2
8106: PPUSH
8107: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
8111: LD_EXP 39
8115: PUSH
8116: LD_EXP 39
8120: PPUSH
8121: LD_EXP 43
8125: PPUSH
8126: CALL_OW 296
8130: PUSH
8131: LD_INT 20
8133: LESS
8134: AND
8135: PUSH
8136: LD_EXP 39
8140: PPUSH
8141: CALL_OW 302
8145: AND
8146: IFFALSE 8327
// begin ComTurnUnit ( Lynch , JMM ) ;
8148: LD_EXP 39
8152: PPUSH
8153: LD_EXP 29
8157: PPUSH
8158: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
8162: LD_EXP 43
8166: PPUSH
8167: LD_EXP 29
8171: PPUSH
8172: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
8176: LD_EXP 39
8180: PPUSH
8181: LD_STRING D6-Sol1-2
8183: PPUSH
8184: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
8188: LD_EXP 29
8192: PPUSH
8193: LD_STRING D6-JMM-2
8195: PPUSH
8196: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
8200: LD_EXP 43
8204: PPUSH
8205: LD_STRING D6-Frank-3
8207: PPUSH
8208: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
8212: LD_EXP 29
8216: PPUSH
8217: LD_STRING D6-JMM-3
8219: PPUSH
8220: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
8224: LD_EXP 43
8228: PPUSH
8229: LD_STRING D6-Frank-4
8231: PPUSH
8232: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
8236: LD_EXP 43
8240: PPUSH
8241: LD_STRING D6-Frank-4a
8243: PPUSH
8244: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
8248: LD_EXP 29
8252: PPUSH
8253: LD_STRING D6-JMM-4
8255: PPUSH
8256: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
8260: LD_EXP 43
8264: PPUSH
8265: LD_STRING D6-Frank-5
8267: PPUSH
8268: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
8272: LD_EXP 32
8276: PUSH
8277: LD_EXP 32
8281: PPUSH
8282: CALL_OW 302
8286: AND
8287: IFFALSE 8301
// Say ( Lisa , D6-Lisa-5 ) ;
8289: LD_EXP 32
8293: PPUSH
8294: LD_STRING D6-Lisa-5
8296: PPUSH
8297: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
8301: LD_EXP 43
8305: PPUSH
8306: LD_STRING D6-Frank-6
8308: PPUSH
8309: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
8313: LD_EXP 29
8317: PPUSH
8318: LD_STRING D6-JMM-6
8320: PPUSH
8321: CALL_OW 88
// end else
8325: GO 8442
// begin ComTurnUnit ( Frank , JMM ) ;
8327: LD_EXP 43
8331: PPUSH
8332: LD_EXP 29
8336: PPUSH
8337: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
8341: LD_EXP 43
8345: PPUSH
8346: LD_STRING D6-Frank-4
8348: PPUSH
8349: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
8353: LD_EXP 43
8357: PPUSH
8358: LD_STRING D6-Frank-4a
8360: PPUSH
8361: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
8365: LD_EXP 29
8369: PPUSH
8370: LD_STRING D6-JMM-4
8372: PPUSH
8373: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
8377: LD_EXP 43
8381: PPUSH
8382: LD_STRING D6-Frank-5
8384: PPUSH
8385: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
8389: LD_EXP 32
8393: PUSH
8394: LD_EXP 32
8398: PPUSH
8399: CALL_OW 302
8403: AND
8404: IFFALSE 8418
// Say ( Lisa , D6-Lisa-5 ) ;
8406: LD_EXP 32
8410: PPUSH
8411: LD_STRING D6-Lisa-5
8413: PPUSH
8414: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
8418: LD_EXP 43
8422: PPUSH
8423: LD_STRING D6-Frank-6
8425: PPUSH
8426: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
8430: LD_EXP 29
8434: PPUSH
8435: LD_STRING D6-JMM-6
8437: PPUSH
8438: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
8442: LD_STRING Q1
8444: PPUSH
8445: CALL_OW 97
8449: PUSH
8450: LD_INT 1
8452: DOUBLE
8453: EQUAL
8454: IFTRUE 8458
8456: GO 8469
8458: POP
// frank_send_to_scout := true ; 2 :
8459: LD_ADDR_EXP 12
8463: PUSH
8464: LD_INT 1
8466: ST_TO_ADDR
8467: GO 8489
8469: LD_INT 2
8471: DOUBLE
8472: EQUAL
8473: IFTRUE 8477
8475: GO 8488
8477: POP
// frank_send_to_scout := false ; end ;
8478: LD_ADDR_EXP 12
8482: PUSH
8483: LD_INT 0
8485: ST_TO_ADDR
8486: GO 8489
8488: POP
// InGameOff ;
8489: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
8493: LD_EXP 29
8497: PUSH
8498: LD_EXP 32
8502: PUSH
8503: LD_EXP 39
8507: PUSH
8508: EMPTY
8509: LIST
8510: LIST
8511: LIST
8512: PPUSH
8513: CALL_OW 139
// if frank_send_to_scout then
8517: LD_EXP 12
8521: IFFALSE 8578
// begin ComMoveXY ( Frank , 130 , 123 ) ;
8523: LD_EXP 43
8527: PPUSH
8528: LD_INT 130
8530: PPUSH
8531: LD_INT 123
8533: PPUSH
8534: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
8538: LD_INT 35
8540: PPUSH
8541: CALL_OW 67
// until not See ( 1 , Frank ) ;
8545: LD_INT 1
8547: PPUSH
8548: LD_EXP 43
8552: PPUSH
8553: CALL_OW 292
8557: NOT
8558: IFFALSE 8538
// Wait ( 0 0$02 ) ;
8560: LD_INT 70
8562: PPUSH
8563: CALL_OW 67
// RemoveUnit ( Frank ) ;
8567: LD_EXP 43
8571: PPUSH
8572: CALL_OW 64
// end else
8576: GO 8590
// SetSide ( Frank , 1 ) ;
8578: LD_EXP 43
8582: PPUSH
8583: LD_INT 1
8585: PPUSH
8586: CALL_OW 235
// repeat wait ( 0 0$01 ) ;
8590: LD_INT 35
8592: PPUSH
8593: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
8597: LD_ADDR_EXP 24
8601: PUSH
8602: LD_EXP 24
8606: PPUSH
8607: LD_STRING -
8609: PPUSH
8610: CALL 1053 0 2
8614: ST_TO_ADDR
// if debug then
8615: LD_EXP 1
8619: IFFALSE 8631
// debug_strings := time_to_prepare ;
8621: LD_ADDR_OWVAR 48
8625: PUSH
8626: LD_EXP 24
8630: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
8631: LD_EXP 24
8635: PUSH
8636: LD_INT 0
8638: EQUAL
8639: IFFALSE 8590
// cornel_prepared := true ;
8641: LD_ADDR_EXP 9
8645: PUSH
8646: LD_INT 1
8648: ST_TO_ADDR
// end ;
8649: PPOPN 2
8651: END
// every 0 0$01 trigger cornel_prepared do
8652: LD_EXP 9
8656: IFFALSE 8876
8658: GO 8660
8660: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
8661: LD_EXP 36
8665: PPUSH
8666: LD_STRING D3-Corn-1
8668: PPUSH
8669: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
8673: LD_INT 35
8675: PPUSH
8676: CALL_OW 67
// until cornel_counter = 0 ;
8680: LD_EXP 8
8684: PUSH
8685: LD_INT 0
8687: EQUAL
8688: IFFALSE 8673
// SayRadio ( Cornel , D3a-Corn-1 ) ;
8690: LD_EXP 36
8694: PPUSH
8695: LD_STRING D3a-Corn-1
8697: PPUSH
8698: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
8702: LD_EXP 29
8706: PPUSH
8707: LD_STRING D3a-JMM-1
8709: PPUSH
8710: CALL_OW 88
// end_mission_allowed := true ;
8714: LD_ADDR_EXP 18
8718: PUSH
8719: LD_INT 1
8721: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
8722: LD_STRING M2
8724: PPUSH
8725: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
8729: LD_INT 9
8731: PPUSH
8732: LD_INT 1
8734: PPUSH
8735: CALL_OW 424
// Wait ( 0 0$05 ) ;
8739: LD_INT 175
8741: PPUSH
8742: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
8746: LD_EXP 36
8750: PPUSH
8751: LD_STRING D3a-Corn-2
8753: PPUSH
8754: CALL_OW 94
// cornel_attack := true ;
8758: LD_ADDR_EXP 7
8762: PUSH
8763: LD_INT 1
8765: ST_TO_ADDR
// if frank_send_to_scout then
8766: LD_EXP 12
8770: IFFALSE 8876
// begin InitHc ;
8772: CALL_OW 19
// InitUc ;
8776: CALL_OW 18
// uc_side := 8 ;
8780: LD_ADDR_OWVAR 20
8784: PUSH
8785: LD_INT 8
8787: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
8788: LD_ADDR_EXP 43
8792: PUSH
8793: LD_STRING Frank
8795: PPUSH
8796: LD_INT 0
8798: PPUSH
8799: CALL 407 0 2
8803: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
8804: LD_EXP 43
8808: PPUSH
8809: LD_INT 6
8811: PPUSH
8812: LD_INT 9
8814: PPUSH
8815: LD_INT 0
8817: PPUSH
8818: CALL_OW 48
// ComCrawl ( Frank ) ;
8822: LD_EXP 43
8826: PPUSH
8827: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
8831: LD_INT 35
8833: PPUSH
8834: CALL_OW 67
// until See ( 1 , Frank ) ;
8838: LD_INT 1
8840: PPUSH
8841: LD_EXP 43
8845: PPUSH
8846: CALL_OW 292
8850: IFFALSE 8831
// SetSide ( Frank , 1 ) ;
8852: LD_EXP 43
8856: PPUSH
8857: LD_INT 1
8859: PPUSH
8860: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
8864: LD_EXP 43
8868: PPUSH
8869: LD_STRING D6a-Frank-1
8871: PPUSH
8872: CALL_OW 88
// end ; end ;
8876: END
// every 0 0$01 trigger solar_builded do
8877: LD_EXP 11
8881: IFFALSE 8985
8883: GO 8885
8885: DISABLE
// begin Wait ( 0 0$02 ) ;
8886: LD_INT 70
8888: PPUSH
8889: CALL_OW 67
// DialogueOn ;
8893: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
8897: LD_EXP 29
8901: PPUSH
8902: LD_STRING D2b-JMM-1
8904: PPUSH
8905: CALL_OW 88
// if Walker and IsOk ( Walker ) then
8909: LD_EXP 40
8913: PUSH
8914: LD_EXP 40
8918: PPUSH
8919: CALL_OW 302
8923: AND
8924: IFFALSE 8974
// begin Say ( Walker , D2b-Sci1-1 ) ;
8926: LD_EXP 40
8930: PPUSH
8931: LD_STRING D2b-Sci1-1
8933: PPUSH
8934: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
8938: LD_EXP 29
8942: PPUSH
8943: LD_STRING D2b-JMM-2
8945: PPUSH
8946: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
8950: LD_EXP 40
8954: PPUSH
8955: LD_STRING D2b-Sci1-2
8957: PPUSH
8958: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
8962: LD_EXP 29
8966: PPUSH
8967: LD_STRING D2b-JMM-3
8969: PPUSH
8970: CALL_OW 88
// end ; DialogueOff ;
8974: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
8978: LD_STRING MOutSol
8980: PPUSH
8981: CALL_OW 337
// end ;
8985: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
8986: LD_EXP 11
8990: PUSH
8991: LD_EXP 29
8995: PPUSH
8996: CALL_OW 302
9000: AND
9001: PUSH
9002: LD_EXP 29
9006: PPUSH
9007: CALL 887 0 1
9011: AND
9012: PUSH
9013: LD_EXP 13
9017: NOT
9018: AND
9019: IFFALSE 9090
9021: GO 9023
9023: DISABLE
9024: LD_INT 0
9026: PPUSH
// begin jmm_in_veh := true ;
9027: LD_ADDR_EXP 13
9031: PUSH
9032: LD_INT 1
9034: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
9035: LD_ADDR_VAR 0 1
9039: PUSH
9040: LD_INT 0
9042: PPUSH
9043: LD_INT 1
9045: PPUSH
9046: CALL_OW 12
9050: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
9051: LD_INT 70
9053: PPUSH
9054: CALL_OW 67
// if i then
9058: LD_VAR 0 1
9062: IFFALSE 9078
// Say ( JMM , D2c-JMM-1 ) else
9064: LD_EXP 29
9068: PPUSH
9069: LD_STRING D2c-JMM-1
9071: PPUSH
9072: CALL_OW 88
9076: GO 9090
// Say ( JMM , D2c-JMM-1a ) ;
9078: LD_EXP 29
9082: PPUSH
9083: LD_STRING D2c-JMM-1a
9085: PPUSH
9086: CALL_OW 88
// end ;
9090: PPOPN 1
9092: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
9093: LD_EXP 11
9097: PUSH
9098: LD_EXP 30
9102: PPUSH
9103: CALL_OW 302
9107: AND
9108: PUSH
9109: LD_EXP 30
9113: PPUSH
9114: CALL 887 0 1
9118: AND
9119: PUSH
9120: LD_EXP 14
9124: NOT
9125: AND
9126: IFFALSE 9158
9128: GO 9130
9130: DISABLE
// begin bobby_in_veh := true ;
9131: LD_ADDR_EXP 14
9135: PUSH
9136: LD_INT 1
9138: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
9139: LD_INT 70
9141: PPUSH
9142: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
9146: LD_EXP 30
9150: PPUSH
9151: LD_STRING D2c-Bobby-1
9153: PPUSH
9154: CALL_OW 88
9158: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
9159: LD_EXP 11
9163: PUSH
9164: LD_EXP 32
9168: PPUSH
9169: CALL_OW 302
9173: AND
9174: PUSH
9175: LD_EXP 32
9179: PPUSH
9180: CALL 887 0 1
9184: AND
9185: PUSH
9186: LD_EXP 16
9190: NOT
9191: AND
9192: IFFALSE 9224
9194: GO 9196
9196: DISABLE
// begin lisa_in_veh := true ;
9197: LD_ADDR_EXP 16
9201: PUSH
9202: LD_INT 1
9204: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
9205: LD_INT 70
9207: PPUSH
9208: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
9212: LD_EXP 32
9216: PPUSH
9217: LD_STRING D2c-Lisa-1
9219: PPUSH
9220: CALL_OW 88
9224: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
9225: LD_EXP 11
9229: PUSH
9230: LD_EXP 31
9234: PPUSH
9235: CALL_OW 302
9239: AND
9240: PUSH
9241: LD_EXP 31
9245: PPUSH
9246: CALL 887 0 1
9250: AND
9251: PUSH
9252: LD_EXP 15
9256: NOT
9257: AND
9258: IFFALSE 9329
9260: GO 9262
9262: DISABLE
9263: LD_INT 0
9265: PPUSH
// begin cyrus_in_veh := true ;
9266: LD_ADDR_EXP 15
9270: PUSH
9271: LD_INT 1
9273: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
9274: LD_ADDR_VAR 0 1
9278: PUSH
9279: LD_INT 0
9281: PPUSH
9282: LD_INT 1
9284: PPUSH
9285: CALL_OW 12
9289: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
9290: LD_INT 70
9292: PPUSH
9293: CALL_OW 67
// if i then
9297: LD_VAR 0 1
9301: IFFALSE 9317
// Say ( Cyrus , D2c-Cyrus-1 ) else
9303: LD_EXP 31
9307: PPUSH
9308: LD_STRING D2c-Cyrus-1
9310: PPUSH
9311: CALL_OW 88
9315: GO 9329
// Say ( Cyrus , D2c-Cyrus-1a ) ;
9317: LD_EXP 31
9321: PPUSH
9322: LD_STRING D2c-Cyrus-1a
9324: PPUSH
9325: CALL_OW 88
// end ;
9329: PPOPN 1
9331: END
// every 0 0$04 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
9332: LD_EXP 36
9336: PPUSH
9337: LD_INT 16
9339: PPUSH
9340: CALL_OW 308
9344: IFFALSE 9586
9346: GO 9348
9348: DISABLE
9349: LD_INT 0
9351: PPUSH
// begin if frank_send_to_scout then
9352: LD_EXP 12
9356: IFFALSE 9370
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
9358: LD_EXP 43
9362: PPUSH
9363: LD_STRING D3b-Frank-1
9365: PPUSH
9366: CALL_OW 94
// end ; DoNotAttack ( 3 , Cornel ) ;
9370: LD_INT 3
9372: PPUSH
9373: LD_EXP 36
9377: PPUSH
9378: CALL_OW 471
// Wait ( 0 0$10 ) ;
9382: LD_INT 350
9384: PPUSH
9385: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
9389: LD_EXP 36
9393: PPUSH
9394: LD_STRING D4-Corn-1
9396: PPUSH
9397: CALL_OW 94
// send_attack_on_cornel := true ;
9401: LD_ADDR_EXP 27
9405: PUSH
9406: LD_INT 1
9408: ST_TO_ADDR
// if ru_vehicles then
9409: LD_EXP 48
9413: IFFALSE 9447
// for i in ru_vehicles do
9415: LD_ADDR_VAR 0 1
9419: PUSH
9420: LD_EXP 48
9424: PUSH
9425: FOR_IN
9426: IFFALSE 9445
// ComAgressiveMove ( i , 215 , 69 ) ;
9428: LD_VAR 0 1
9432: PPUSH
9433: LD_INT 215
9435: PPUSH
9436: LD_INT 69
9438: PPUSH
9439: CALL_OW 114
9443: GO 9425
9445: POP
9446: POP
// if ru_patrol then
9447: LD_EXP 45
9451: IFFALSE 9485
// for i in ru_patrol do
9453: LD_ADDR_VAR 0 1
9457: PUSH
9458: LD_EXP 45
9462: PUSH
9463: FOR_IN
9464: IFFALSE 9483
// ComAgressiveMove ( i , 215 , 69 ) ;
9466: LD_VAR 0 1
9470: PPUSH
9471: LD_INT 215
9473: PPUSH
9474: LD_INT 69
9476: PPUSH
9477: CALL_OW 114
9481: GO 9463
9483: POP
9484: POP
// repeat wait ( 0 0$01 ) ;
9485: LD_INT 35
9487: PPUSH
9488: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 5 ;
9492: LD_INT 22
9494: PUSH
9495: LD_INT 4
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: PUSH
9502: LD_INT 21
9504: PUSH
9505: LD_INT 1
9507: PUSH
9508: EMPTY
9509: LIST
9510: LIST
9511: PUSH
9512: LD_INT 50
9514: PUSH
9515: EMPTY
9516: LIST
9517: PUSH
9518: EMPTY
9519: LIST
9520: LIST
9521: LIST
9522: PPUSH
9523: CALL_OW 69
9527: PUSH
9528: LD_INT 5
9530: LESS
9531: IFFALSE 9485
// SayRadio ( Cornel , D5-Corn-1 ) ;
9533: LD_EXP 36
9537: PPUSH
9538: LD_STRING D5-Corn-1
9540: PPUSH
9541: CALL_OW 94
// SaveCharacters ( Cornel , Cornel ) ;
9545: LD_EXP 36
9549: PPUSH
9550: LD_STRING Cornel
9552: PPUSH
9553: CALL_OW 38
// ChangeSideFog ( 4 , 8 ) ;
9557: LD_INT 4
9559: PPUSH
9560: LD_INT 8
9562: PPUSH
9563: CALL_OW 343
// Wait ( 0 0$01 ) ;
9567: LD_INT 35
9569: PPUSH
9570: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
9574: LD_INT 3
9576: PPUSH
9577: LD_EXP 36
9581: PPUSH
9582: CALL_OW 472
// end ;
9586: PPOPN 1
9588: END
// every 0 0$02 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
9589: LD_INT 9
9591: PPUSH
9592: LD_INT 22
9594: PUSH
9595: LD_INT 1
9597: PUSH
9598: EMPTY
9599: LIST
9600: LIST
9601: PPUSH
9602: CALL_OW 70
9606: PUSH
9607: LD_EXP 28
9611: OR
9612: IFFALSE 10353
9614: GO 9616
9616: DISABLE
9617: LD_INT 0
9619: PPUSH
9620: PPUSH
// begin enable ;
9621: ENABLE
// if not game_end then
9622: LD_EXP 28
9626: NOT
9627: IFFALSE 9637
// game_end := true ;
9629: LD_ADDR_EXP 28
9633: PUSH
9634: LD_INT 1
9636: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
9637: LD_ADDR_VAR 0 2
9641: PUSH
9642: LD_INT 9
9644: PPUSH
9645: LD_INT 22
9647: PUSH
9648: LD_INT 1
9650: PUSH
9651: EMPTY
9652: LIST
9653: LIST
9654: PPUSH
9655: CALL_OW 70
9659: ST_TO_ADDR
// if not filter then
9660: LD_VAR 0 2
9664: NOT
9665: IFFALSE 9669
// exit ;
9667: GO 10353
// for i in filter do
9669: LD_ADDR_VAR 0 1
9673: PUSH
9674: LD_VAR 0 2
9678: PUSH
9679: FOR_IN
9680: IFFALSE 10351
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
9682: LD_VAR 0 1
9686: PPUSH
9687: CALL_OW 302
9691: PUSH
9692: LD_VAR 0 1
9696: PPUSH
9697: CALL_OW 247
9701: PUSH
9702: LD_INT 2
9704: EQUAL
9705: AND
9706: IFFALSE 9746
// begin veh_on_meta := true ;
9708: LD_ADDR_EXP 23
9712: PUSH
9713: LD_INT 1
9715: ST_TO_ADDR
// ComExitVehicle ( IsInUnit ( i ) ) ;
9716: LD_VAR 0 1
9720: PPUSH
9721: CALL_OW 310
9725: PPUSH
9726: CALL_OW 121
// RemoveUnit ( i ) ;
9730: LD_VAR 0 1
9734: PPUSH
9735: CALL_OW 64
// Wait ( 10 ) ;
9739: LD_INT 10
9741: PPUSH
9742: CALL_OW 67
// end ; if i = JMM then
9746: LD_VAR 0 1
9750: PUSH
9751: LD_EXP 29
9755: EQUAL
9756: IFFALSE 9878
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
9758: LD_EXP 21
9762: PUSH
9763: LD_INT 22
9765: PUSH
9766: LD_INT 1
9768: PUSH
9769: EMPTY
9770: LIST
9771: LIST
9772: PUSH
9773: LD_INT 21
9775: PUSH
9776: LD_INT 1
9778: PUSH
9779: EMPTY
9780: LIST
9781: LIST
9782: PUSH
9783: EMPTY
9784: LIST
9785: LIST
9786: PPUSH
9787: CALL_OW 69
9791: PUSH
9792: LD_INT 1
9794: GREATER
9795: AND
9796: IFFALSE 9853
// begin show_query := false ;
9798: LD_ADDR_EXP 21
9802: PUSH
9803: LD_INT 0
9805: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
9806: LD_STRING Q2
9808: PPUSH
9809: CALL_OW 97
9813: PUSH
9814: LD_INT 1
9816: DOUBLE
9817: EQUAL
9818: IFTRUE 9822
9820: GO 9833
9822: POP
// wait_for_them := true ; 2 :
9823: LD_ADDR_EXP 22
9827: PUSH
9828: LD_INT 1
9830: ST_TO_ADDR
9831: GO 9853
9833: LD_INT 2
9835: DOUBLE
9836: EQUAL
9837: IFTRUE 9841
9839: GO 9852
9841: POP
// wait_for_them := false ; end ;
9842: LD_ADDR_EXP 22
9846: PUSH
9847: LD_INT 0
9849: ST_TO_ADDR
9850: GO 9853
9852: POP
// end ; save_group := save_group ^ JMM ;
9853: LD_ADDR_EXP 20
9857: PUSH
9858: LD_EXP 20
9862: PUSH
9863: LD_EXP 29
9867: ADD
9868: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
9869: LD_EXP 29
9873: PPUSH
9874: CALL_OW 64
// end ; if i = Lisa then
9878: LD_VAR 0 1
9882: PUSH
9883: LD_EXP 32
9887: EQUAL
9888: IFFALSE 9915
// begin save_group := save_group ^ Lisa ;
9890: LD_ADDR_EXP 20
9894: PUSH
9895: LD_EXP 20
9899: PUSH
9900: LD_EXP 32
9904: ADD
9905: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
9906: LD_EXP 32
9910: PPUSH
9911: CALL_OW 64
// end ; if i = Bobby then
9915: LD_VAR 0 1
9919: PUSH
9920: LD_EXP 30
9924: EQUAL
9925: IFFALSE 9952
// begin save_group := save_group ^ Bobby ;
9927: LD_ADDR_EXP 20
9931: PUSH
9932: LD_EXP 20
9936: PUSH
9937: LD_EXP 30
9941: ADD
9942: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
9943: LD_EXP 30
9947: PPUSH
9948: CALL_OW 64
// end ; if i = Cyrus then
9952: LD_VAR 0 1
9956: PUSH
9957: LD_EXP 31
9961: EQUAL
9962: IFFALSE 9989
// begin save_group := save_group ^ Cyrus ;
9964: LD_ADDR_EXP 20
9968: PUSH
9969: LD_EXP 20
9973: PUSH
9974: LD_EXP 31
9978: ADD
9979: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
9980: LD_EXP 31
9984: PPUSH
9985: CALL_OW 64
// end ; if i = Khatam then
9989: LD_VAR 0 1
9993: PUSH
9994: LD_EXP 33
9998: EQUAL
9999: IFFALSE 10026
// begin save_group := save_group ^ Khatam ;
10001: LD_ADDR_EXP 20
10005: PUSH
10006: LD_EXP 20
10010: PUSH
10011: LD_EXP 33
10015: ADD
10016: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
10017: LD_EXP 33
10021: PPUSH
10022: CALL_OW 64
// end ; if i = Jerry then
10026: LD_VAR 0 1
10030: PUSH
10031: LD_EXP 35
10035: EQUAL
10036: IFFALSE 10063
// begin save_group := save_group ^ Jerry ;
10038: LD_ADDR_EXP 20
10042: PUSH
10043: LD_EXP 20
10047: PUSH
10048: LD_EXP 35
10052: ADD
10053: ST_TO_ADDR
// RemoveUnit ( Jerry ) ;
10054: LD_EXP 35
10058: PPUSH
10059: CALL_OW 64
// end ; if i = Brian then
10063: LD_VAR 0 1
10067: PUSH
10068: LD_EXP 34
10072: EQUAL
10073: IFFALSE 10100
// begin save_group := save_group ^ Brian ;
10075: LD_ADDR_EXP 20
10079: PUSH
10080: LD_EXP 20
10084: PUSH
10085: LD_EXP 34
10089: ADD
10090: ST_TO_ADDR
// RemoveUnit ( Brian ) ;
10091: LD_EXP 34
10095: PPUSH
10096: CALL_OW 64
// end ; if i = Lynch then
10100: LD_VAR 0 1
10104: PUSH
10105: LD_EXP 39
10109: EQUAL
10110: IFFALSE 10137
// begin save_group := save_group ^ Lynch ;
10112: LD_ADDR_EXP 20
10116: PUSH
10117: LD_EXP 20
10121: PUSH
10122: LD_EXP 39
10126: ADD
10127: ST_TO_ADDR
// RemoveUnit ( Lynch ) ;
10128: LD_EXP 39
10132: PPUSH
10133: CALL_OW 64
// end ; if i = Turner then
10137: LD_VAR 0 1
10141: PUSH
10142: LD_EXP 41
10146: EQUAL
10147: IFFALSE 10174
// begin save_group := save_group ^ Turner ;
10149: LD_ADDR_EXP 20
10153: PUSH
10154: LD_EXP 20
10158: PUSH
10159: LD_EXP 41
10163: ADD
10164: ST_TO_ADDR
// RemoveUnit ( Turner ) ;
10165: LD_EXP 41
10169: PPUSH
10170: CALL_OW 64
// end ; if i = Jillian then
10174: LD_VAR 0 1
10178: PUSH
10179: LD_EXP 42
10183: EQUAL
10184: IFFALSE 10211
// begin save_group := save_group ^ Jillian ;
10186: LD_ADDR_EXP 20
10190: PUSH
10191: LD_EXP 20
10195: PUSH
10196: LD_EXP 42
10200: ADD
10201: ST_TO_ADDR
// RemoveUnit ( Jillian ) ;
10202: LD_EXP 42
10206: PPUSH
10207: CALL_OW 64
// end ; if i = Walker then
10211: LD_VAR 0 1
10215: PUSH
10216: LD_EXP 40
10220: EQUAL
10221: IFFALSE 10248
// begin save_group := save_group ^ Walker ;
10223: LD_ADDR_EXP 20
10227: PUSH
10228: LD_EXP 20
10232: PUSH
10233: LD_EXP 40
10237: ADD
10238: ST_TO_ADDR
// RemoveUnit ( Walker ) ;
10239: LD_EXP 40
10243: PPUSH
10244: CALL_OW 64
// end ; if i = Frank then
10248: LD_VAR 0 1
10252: PUSH
10253: LD_EXP 43
10257: EQUAL
10258: IFFALSE 10285
// begin save_group := save_group ^ Frank ;
10260: LD_ADDR_EXP 20
10264: PUSH
10265: LD_EXP 20
10269: PUSH
10270: LD_EXP 43
10274: ADD
10275: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
10276: LD_EXP 43
10280: PPUSH
10281: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and not i in save_group then
10285: LD_VAR 0 1
10289: PPUSH
10290: CALL_OW 302
10294: PUSH
10295: LD_VAR 0 1
10299: PPUSH
10300: CALL_OW 247
10304: PUSH
10305: LD_INT 1
10307: EQUAL
10308: AND
10309: PUSH
10310: LD_VAR 0 1
10314: PUSH
10315: LD_EXP 20
10319: IN
10320: NOT
10321: AND
10322: IFFALSE 10349
// begin save_others := save_others ^ i ;
10324: LD_ADDR_EXP 19
10328: PUSH
10329: LD_EXP 19
10333: PUSH
10334: LD_VAR 0 1
10338: ADD
10339: ST_TO_ADDR
// RemoveUnit ( i ) ;
10340: LD_VAR 0 1
10344: PPUSH
10345: CALL_OW 64
// end ; end ;
10349: GO 9679
10351: POP
10352: POP
// end ;
10353: PPOPN 2
10355: END
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or ( wait_for_them and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 ) do
10356: LD_EXP 21
10360: NOT
10361: PUSH
10362: LD_EXP 22
10366: NOT
10367: AND
10368: PUSH
10369: LD_EXP 22
10373: PUSH
10374: LD_INT 22
10376: PUSH
10377: LD_INT 1
10379: PUSH
10380: EMPTY
10381: LIST
10382: LIST
10383: PUSH
10384: LD_INT 21
10386: PUSH
10387: LD_INT 1
10389: PUSH
10390: EMPTY
10391: LIST
10392: LIST
10393: PUSH
10394: EMPTY
10395: LIST
10396: LIST
10397: PPUSH
10398: CALL_OW 69
10402: PUSH
10403: LD_INT 0
10405: EQUAL
10406: AND
10407: OR
10408: IFFALSE 10417
10410: GO 10412
10412: DISABLE
// EndMission ;
10413: CALL 10418 0 0
10417: END
// export function EndMission ; var counter , i ; begin
10418: LD_INT 0
10420: PPUSH
10421: PPUSH
10422: PPUSH
// if solar_builded then
10423: LD_EXP 11
10427: IFFALSE 10441
// AddMedal ( Solar1 , 1 ) else
10429: LD_STRING Solar1
10431: PPUSH
10432: LD_INT 1
10434: PPUSH
10435: CALL_OW 101
10439: GO 10452
// AddMedal ( Solar1 , - 1 ) ;
10441: LD_STRING Solar1
10443: PPUSH
10444: LD_INT 1
10446: NEG
10447: PPUSH
10448: CALL_OW 101
// if veh_on_meta then
10452: LD_EXP 23
10456: IFFALSE 10470
// AddMedal ( Solar2 , 1 ) else
10458: LD_STRING Solar2
10460: PPUSH
10461: LD_INT 1
10463: PPUSH
10464: CALL_OW 101
10468: GO 10500
// if solar_builded then
10470: LD_EXP 11
10474: IFFALSE 10489
// AddMedal ( Solar2 , - 1 ) else
10476: LD_STRING Solar2
10478: PPUSH
10479: LD_INT 1
10481: NEG
10482: PPUSH
10483: CALL_OW 101
10487: GO 10500
// AddMedal ( Solar2 , - 2 ) ;
10489: LD_STRING Solar2
10491: PPUSH
10492: LD_INT 2
10494: NEG
10495: PPUSH
10496: CALL_OW 101
// counter := save_group + save_others ;
10500: LD_ADDR_VAR 0 2
10504: PUSH
10505: LD_EXP 20
10509: PUSH
10510: LD_EXP 19
10514: PLUS
10515: ST_TO_ADDR
// if counter = 10 then
10516: LD_VAR 0 2
10520: PUSH
10521: LD_INT 10
10523: EQUAL
10524: IFFALSE 10538
// AddMedal ( No , 1 ) else
10526: LD_STRING No
10528: PPUSH
10529: LD_INT 1
10531: PPUSH
10532: CALL_OW 101
10536: GO 10582
// if counter < 10 and counter > 6 then
10538: LD_VAR 0 2
10542: PUSH
10543: LD_INT 10
10545: LESS
10546: PUSH
10547: LD_VAR 0 2
10551: PUSH
10552: LD_INT 6
10554: GREATER
10555: AND
10556: IFFALSE 10571
// AddMedal ( No , - 1 ) else
10558: LD_STRING No
10560: PPUSH
10561: LD_INT 1
10563: NEG
10564: PPUSH
10565: CALL_OW 101
10569: GO 10582
// AddMedal ( UpTo4 , - 1 ) ;
10571: LD_STRING UpTo4
10573: PPUSH
10574: LD_INT 1
10576: NEG
10577: PPUSH
10578: CALL_OW 101
// GiveMedals ( MAIN ) ;
10582: LD_STRING MAIN
10584: PPUSH
10585: CALL_OW 102
// if IsDead ( Pokryshkin ) then
10589: LD_EXP 44
10593: PPUSH
10594: CALL_OW 301
10598: IFFALSE 10638
// for i in save_group ^ save_others do
10600: LD_ADDR_VAR 0 3
10604: PUSH
10605: LD_EXP 20
10609: PUSH
10610: LD_EXP 19
10614: ADD
10615: PUSH
10616: FOR_IN
10617: IFFALSE 10636
// AddExperience ( i , skill_combat , 1500 ) ;
10619: LD_VAR 0 3
10623: PPUSH
10624: LD_INT 1
10626: PPUSH
10627: LD_INT 1500
10629: PPUSH
10630: CALL_OW 492
10634: GO 10616
10636: POP
10637: POP
// RewardPeople ( save_group ^ save_others ) ;
10638: LD_EXP 20
10642: PUSH
10643: LD_EXP 19
10647: ADD
10648: PPUSH
10649: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
10653: LD_EXP 29
10657: PPUSH
10658: LD_STRING JMM
10660: PPUSH
10661: CALL_OW 38
// if Bobby in save_group then
10665: LD_EXP 30
10669: PUSH
10670: LD_EXP 20
10674: IN
10675: IFFALSE 10689
// SaveCharacters ( Bobby , Bobby ) ;
10677: LD_EXP 30
10681: PPUSH
10682: LD_STRING Bobby
10684: PPUSH
10685: CALL_OW 38
// if Cyrus in save_group then
10689: LD_EXP 31
10693: PUSH
10694: LD_EXP 20
10698: IN
10699: IFFALSE 10713
// SaveCharacters ( Cyrus , Cyrus ) ;
10701: LD_EXP 31
10705: PPUSH
10706: LD_STRING Cyrus
10708: PPUSH
10709: CALL_OW 38
// if Lisa in save_group then
10713: LD_EXP 32
10717: PUSH
10718: LD_EXP 20
10722: IN
10723: IFFALSE 10737
// SaveCharacters ( Lisa , Lisa ) ;
10725: LD_EXP 32
10729: PPUSH
10730: LD_STRING Lisa
10732: PPUSH
10733: CALL_OW 38
// if Frank in save_group then
10737: LD_EXP 43
10741: PUSH
10742: LD_EXP 20
10746: IN
10747: IFFALSE 10761
// SaveCharacters ( Frank , Frank ) ;
10749: LD_EXP 43
10753: PPUSH
10754: LD_STRING Frank
10756: PPUSH
10757: CALL_OW 38
// if Khatam in save_group then
10761: LD_EXP 33
10765: PUSH
10766: LD_EXP 20
10770: IN
10771: IFFALSE 10785
// SaveCharacters ( Khatam , Khatam ) ;
10773: LD_EXP 33
10777: PPUSH
10778: LD_STRING Khatam
10780: PPUSH
10781: CALL_OW 38
// if Lynch in save_group then
10785: LD_EXP 39
10789: PUSH
10790: LD_EXP 20
10794: IN
10795: IFFALSE 10809
// SaveCharacters ( Lynch , Lynch ) ;
10797: LD_EXP 39
10801: PPUSH
10802: LD_STRING Lynch
10804: PPUSH
10805: CALL_OW 38
// if Walker in save_group then
10809: LD_EXP 40
10813: PUSH
10814: LD_EXP 20
10818: IN
10819: IFFALSE 10833
// SaveCharacters ( Walker , Walker ) ;
10821: LD_EXP 40
10825: PPUSH
10826: LD_STRING Walker
10828: PPUSH
10829: CALL_OW 38
// if Turner in save_group then
10833: LD_EXP 41
10837: PUSH
10838: LD_EXP 20
10842: IN
10843: IFFALSE 10857
// SaveCharacters ( Turner , Turner ) ;
10845: LD_EXP 41
10849: PPUSH
10850: LD_STRING Turner
10852: PPUSH
10853: CALL_OW 38
// if Jillian in save_group then
10857: LD_EXP 42
10861: PUSH
10862: LD_EXP 20
10866: IN
10867: IFFALSE 10881
// SaveCharacters ( Jillian , Jillian ) ;
10869: LD_EXP 42
10873: PPUSH
10874: LD_STRING Jillian
10876: PPUSH
10877: CALL_OW 38
// if save_others then
10881: LD_EXP 19
10885: IFFALSE 10899
// SaveCharacters ( save_others , 03_others ) ;
10887: LD_EXP 19
10891: PPUSH
10892: LD_STRING 03_others
10894: PPUSH
10895: CALL_OW 38
// if Bierezov then
10899: LD_EXP 37
10903: IFFALSE 10913
// begin ResetFog ;
10905: CALL_OW 335
// DisplayEndingScene ;
10909: CALL 10922 0 0
// end ; YouWin ;
10913: CALL_OW 103
// end ;
10917: LD_VAR 0 1
10921: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
10922: LD_INT 0
10924: PPUSH
10925: PPUSH
10926: PPUSH
10927: PPUSH
10928: PPUSH
10929: PPUSH
// InGameOn ;
10930: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
10934: LD_INT 208
10936: PPUSH
10937: LD_INT 62
10939: PPUSH
10940: LD_INT 1
10942: PPUSH
10943: LD_INT 10
10945: NEG
10946: PPUSH
10947: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
10951: LD_INT 208
10953: PPUSH
10954: LD_INT 62
10956: PPUSH
10957: LD_INT 1
10959: PPUSH
10960: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
10964: LD_ADDR_VAR 0 3
10968: PUSH
10969: LD_INT 22
10971: PUSH
10972: LD_INT 3
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: PUSH
10979: LD_INT 2
10981: PUSH
10982: LD_INT 21
10984: PUSH
10985: LD_INT 2
10987: PUSH
10988: EMPTY
10989: LIST
10990: LIST
10991: PUSH
10992: LD_INT 21
10994: PUSH
10995: LD_INT 1
10997: PUSH
10998: EMPTY
10999: LIST
11000: LIST
11001: PUSH
11002: EMPTY
11003: LIST
11004: LIST
11005: LIST
11006: PUSH
11007: EMPTY
11008: LIST
11009: LIST
11010: PPUSH
11011: CALL_OW 69
11015: ST_TO_ADDR
// if filter then
11016: LD_VAR 0 3
11020: IFFALSE 11048
// for i in filter do
11022: LD_ADDR_VAR 0 2
11026: PUSH
11027: LD_VAR 0 3
11031: PUSH
11032: FOR_IN
11033: IFFALSE 11046
// RemoveUnit ( i ) ;
11035: LD_VAR 0 2
11039: PPUSH
11040: CALL_OW 64
11044: GO 11032
11046: POP
11047: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
11048: LD_ADDR_VAR 0 3
11052: PUSH
11053: LD_INT 22
11055: PUSH
11056: LD_INT 4
11058: PUSH
11059: EMPTY
11060: LIST
11061: LIST
11062: PUSH
11063: LD_INT 21
11065: PUSH
11066: LD_INT 1
11068: PUSH
11069: EMPTY
11070: LIST
11071: LIST
11072: PUSH
11073: EMPTY
11074: LIST
11075: LIST
11076: PPUSH
11077: CALL_OW 69
11081: ST_TO_ADDR
// if filter then
11082: LD_VAR 0 3
11086: IFFALSE 11117
// for i in filter do
11088: LD_ADDR_VAR 0 2
11092: PUSH
11093: LD_VAR 0 3
11097: PUSH
11098: FOR_IN
11099: IFFALSE 11115
// SetLives ( i , 0 ) ;
11101: LD_VAR 0 2
11105: PPUSH
11106: LD_INT 0
11108: PPUSH
11109: CALL_OW 234
11113: GO 11098
11115: POP
11116: POP
// uc_side := 4 ;
11117: LD_ADDR_OWVAR 20
11121: PUSH
11122: LD_INT 4
11124: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
11125: LD_ADDR_VAR 0 4
11129: PUSH
11130: LD_STRING Cornell
11132: PPUSH
11133: LD_INT 0
11135: PPUSH
11136: CALL 407 0 2
11140: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
11141: LD_VAR 0 4
11145: PPUSH
11146: LD_INT 208
11148: PPUSH
11149: LD_INT 62
11151: PPUSH
11152: LD_INT 0
11154: PPUSH
11155: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
11159: LD_VAR 0 4
11163: PPUSH
11164: LD_INT 100
11166: PPUSH
11167: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
11171: LD_INT 3
11173: PPUSH
11174: LD_VAR 0 4
11178: PPUSH
11179: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
11183: LD_INT 4
11185: PPUSH
11186: LD_INT 3
11188: PPUSH
11189: LD_INT 1
11191: PPUSH
11192: LD_INT 1
11194: PPUSH
11195: CALL_OW 80
// uc_side := 3 ;
11199: LD_ADDR_OWVAR 20
11203: PUSH
11204: LD_INT 3
11206: ST_TO_ADDR
// uc_nation := 3 ;
11207: LD_ADDR_OWVAR 21
11211: PUSH
11212: LD_INT 3
11214: ST_TO_ADDR
// InitHc ;
11215: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
11219: LD_ADDR_VAR 0 5
11223: PUSH
11224: LD_STRING Mikhail
11226: PPUSH
11227: LD_INT 0
11229: PPUSH
11230: CALL 407 0 2
11234: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
11235: LD_INT 1
11237: PPUSH
11238: LD_INT 1
11240: PPUSH
11241: LD_INT 0
11243: PPUSH
11244: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
11248: LD_ADDR_VAR 0 6
11252: PUSH
11253: LD_VAR 0 6
11257: PUSH
11258: CALL_OW 44
11262: ADD
11263: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
11264: LD_ADDR_VAR 0 6
11268: PUSH
11269: LD_VAR 0 6
11273: PUSH
11274: CALL_OW 44
11278: ADD
11279: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
11280: LD_INT 2
11282: PPUSH
11283: LD_INT 4
11285: PPUSH
11286: LD_INT 0
11288: PPUSH
11289: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
11293: LD_ADDR_VAR 0 6
11297: PUSH
11298: LD_VAR 0 6
11302: PUSH
11303: CALL_OW 44
11307: ADD
11308: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
11309: LD_VAR 0 5
11313: PPUSH
11314: LD_INT 17
11316: PPUSH
11317: LD_INT 0
11319: PPUSH
11320: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
11324: LD_VAR 0 5
11328: PPUSH
11329: LD_INT 210
11331: PPUSH
11332: LD_INT 63
11334: PPUSH
11335: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
11339: LD_VAR 0 5
11343: PPUSH
11344: LD_INT 208
11346: PPUSH
11347: LD_INT 62
11349: PPUSH
11350: CALL_OW 178
// for i in fake_russians do
11354: LD_ADDR_VAR 0 2
11358: PUSH
11359: LD_VAR 0 6
11363: PUSH
11364: FOR_IN
11365: IFFALSE 11443
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
11367: LD_VAR 0 2
11371: PPUSH
11372: LD_INT 17
11374: PPUSH
11375: LD_INT 0
11377: PPUSH
11378: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
11382: LD_VAR 0 2
11386: PPUSH
11387: LD_INT 215
11389: PPUSH
11390: LD_INT 67
11392: PPUSH
11393: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
11397: LD_VAR 0 2
11401: PPUSH
11402: LD_INT 208
11404: PPUSH
11405: LD_INT 62
11407: PPUSH
11408: CALL_OW 178
// if GetClass ( i ) = 4 then
11412: LD_VAR 0 2
11416: PPUSH
11417: CALL_OW 257
11421: PUSH
11422: LD_INT 4
11424: EQUAL
11425: IFFALSE 11441
// ComHeal ( i , fake_cornel ) ;
11427: LD_VAR 0 2
11431: PPUSH
11432: LD_VAR 0 4
11436: PPUSH
11437: CALL_OW 128
// end ;
11441: GO 11364
11443: POP
11444: POP
// Wait ( 0 0$01 ) ;
11445: LD_INT 35
11447: PPUSH
11448: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
11452: LD_INT 208
11454: PPUSH
11455: LD_INT 62
11457: PPUSH
11458: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
11462: LD_INT 208
11464: PPUSH
11465: LD_INT 62
11467: PPUSH
11468: LD_INT 1
11470: PPUSH
11471: LD_INT 10
11473: NEG
11474: PPUSH
11475: CALL_OW 330
// Wait ( 0 0$15 ) ;
11479: LD_INT 525
11481: PPUSH
11482: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
11486: LD_INT 208
11488: PPUSH
11489: LD_INT 62
11491: PPUSH
11492: LD_INT 1
11494: PPUSH
11495: CALL_OW 331
// ResetFog ;
11499: CALL_OW 335
// InGameOff ;
11503: CALL_OW 9
// end ; end_of_file
11507: LD_VAR 0 1
11511: RET
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
11512: LD_EXP 6
11516: IFFALSE 12547
11518: GO 11520
11520: DISABLE
11521: LD_INT 0
11523: PPUSH
11524: PPUSH
11525: PPUSH
11526: PPUSH
11527: PPUSH
11528: PPUSH
11529: PPUSH
11530: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
11531: LD_EXP 36
11535: PUSH
11536: LD_EXP 37
11540: ADD
11541: PUSH
11542: LD_EXP 4
11546: ADD
11547: PPUSH
11548: LD_INT 250
11550: PPUSH
11551: LD_INT 120
11553: PPUSH
11554: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
11558: LD_ADDR_VAR 0 2
11562: PUSH
11563: LD_EXP 4
11567: PPUSH
11568: LD_INT 25
11570: PUSH
11571: LD_INT 2
11573: PUSH
11574: EMPTY
11575: LIST
11576: LIST
11577: PPUSH
11578: CALL_OW 72
11582: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
11583: LD_ADDR_VAR 0 3
11587: PUSH
11588: LD_EXP 4
11592: PPUSH
11593: LD_INT 21
11595: PUSH
11596: LD_INT 1
11598: PUSH
11599: EMPTY
11600: LIST
11601: LIST
11602: PPUSH
11603: CALL_OW 72
11607: ST_TO_ADDR
// if not has_eng then
11608: LD_VAR 0 2
11612: NOT
11613: IFFALSE 11696
// begin uc_side := 4 ;
11615: LD_ADDR_OWVAR 20
11619: PUSH
11620: LD_INT 4
11622: ST_TO_ADDR
// uc_nation := 1 ;
11623: LD_ADDR_OWVAR 21
11627: PUSH
11628: LD_INT 1
11630: ST_TO_ADDR
// bc_type := b_depot ;
11631: LD_ADDR_OWVAR 42
11635: PUSH
11636: LD_INT 0
11638: ST_TO_ADDR
// bc_level := 2 ;
11639: LD_ADDR_OWVAR 43
11643: PUSH
11644: LD_INT 2
11646: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
11647: LD_ADDR_VAR 0 4
11651: PUSH
11652: LD_INT 264
11654: PPUSH
11655: LD_INT 120
11657: PPUSH
11658: LD_INT 4
11660: PPUSH
11661: CALL_OW 47
11665: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
11666: LD_INT 264
11668: PPUSH
11669: LD_INT 120
11671: PPUSH
11672: LD_INT 4
11674: PPUSH
11675: LD_INT 10
11677: NEG
11678: PPUSH
11679: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
11683: LD_INT 264
11685: PPUSH
11686: LD_INT 120
11688: PPUSH
11689: LD_INT 4
11691: PPUSH
11692: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
11696: LD_INT 35
11698: PPUSH
11699: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
11703: LD_EXP 36
11707: PPUSH
11708: LD_INT 10
11710: PPUSH
11711: CALL_OW 308
11715: IFFALSE 11696
// if has_eng and not dep then
11717: LD_VAR 0 2
11721: PUSH
11722: LD_VAR 0 4
11726: NOT
11727: AND
11728: IFFALSE 11842
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
11730: LD_VAR 0 2
11734: PPUSH
11735: LD_INT 0
11737: PPUSH
11738: LD_INT 264
11740: PPUSH
11741: LD_INT 120
11743: PPUSH
11744: LD_INT 4
11746: PPUSH
11747: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
11751: LD_INT 35
11753: PPUSH
11754: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
11758: LD_INT 22
11760: PUSH
11761: LD_INT 4
11763: PUSH
11764: EMPTY
11765: LIST
11766: LIST
11767: PUSH
11768: LD_INT 30
11770: PUSH
11771: LD_INT 0
11773: PUSH
11774: EMPTY
11775: LIST
11776: LIST
11777: PUSH
11778: LD_INT 3
11780: PUSH
11781: LD_INT 57
11783: PUSH
11784: EMPTY
11785: LIST
11786: PUSH
11787: EMPTY
11788: LIST
11789: LIST
11790: PUSH
11791: EMPTY
11792: LIST
11793: LIST
11794: LIST
11795: PPUSH
11796: CALL_OW 69
11800: IFFALSE 11751
// dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
11802: LD_ADDR_VAR 0 4
11806: PUSH
11807: LD_INT 22
11809: PUSH
11810: LD_INT 4
11812: PUSH
11813: EMPTY
11814: LIST
11815: LIST
11816: PUSH
11817: LD_INT 30
11819: PUSH
11820: LD_INT 0
11822: PUSH
11823: EMPTY
11824: LIST
11825: LIST
11826: PUSH
11827: EMPTY
11828: LIST
11829: LIST
11830: PPUSH
11831: CALL_OW 69
11835: PUSH
11836: LD_INT 1
11838: ARRAY
11839: ST_TO_ADDR
// end else
11840: GO 11959
// begin SetSide ( dep , 4 ) ;
11842: LD_VAR 0 4
11846: PPUSH
11847: LD_INT 4
11849: PPUSH
11850: CALL_OW 235
// for i = 1 to 3 do
11854: LD_ADDR_VAR 0 1
11858: PUSH
11859: DOUBLE
11860: LD_INT 1
11862: DEC
11863: ST_TO_ADDR
11864: LD_INT 3
11866: PUSH
11867: FOR_TO
11868: IFFALSE 11925
// begin ComEnterUnit ( filter [ i ] , dep ) ;
11870: LD_VAR 0 3
11874: PUSH
11875: LD_VAR 0 1
11879: ARRAY
11880: PPUSH
11881: LD_VAR 0 4
11885: PPUSH
11886: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
11890: LD_VAR 0 3
11894: PUSH
11895: LD_VAR 0 1
11899: ARRAY
11900: PPUSH
11901: LD_INT 2
11903: PPUSH
11904: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
11908: LD_VAR 0 3
11912: PUSH
11913: LD_VAR 0 1
11917: ARRAY
11918: PPUSH
11919: CALL_OW 182
// end ;
11923: GO 11867
11925: POP
11926: POP
// repeat wait ( 0 0$01 ) ;
11927: LD_INT 35
11929: PPUSH
11930: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
11934: LD_VAR 0 3
11938: PPUSH
11939: LD_INT 25
11941: PUSH
11942: LD_INT 2
11944: PUSH
11945: EMPTY
11946: LIST
11947: LIST
11948: PPUSH
11949: CALL_OW 72
11953: PUSH
11954: LD_INT 3
11956: EQUAL
11957: IFFALSE 11927
// end ; ComEnterUnit ( Bierezov , dep ) ;
11959: LD_EXP 37
11963: PPUSH
11964: LD_VAR 0 4
11968: PPUSH
11969: CALL_OW 120
// if IsInUnit ( Cornel ) then
11973: LD_EXP 36
11977: PPUSH
11978: CALL_OW 310
11982: IFFALSE 12065
// begin cargo := IsInUnit ( Cornel ) ;
11984: LD_ADDR_VAR 0 7
11988: PUSH
11989: LD_EXP 36
11993: PPUSH
11994: CALL_OW 310
11998: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
11999: LD_VAR 0 7
12003: PPUSH
12004: LD_INT 1
12006: PPUSH
12007: CALL_OW 289
12011: IFFALSE 12027
// ComGive ( Cornel , dep ) ;
12013: LD_EXP 36
12017: PPUSH
12018: LD_VAR 0 4
12022: PPUSH
12023: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
12027: LD_EXP 36
12031: PPUSH
12032: LD_INT 235
12034: PPUSH
12035: LD_INT 122
12037: PPUSH
12038: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
12042: LD_EXP 36
12046: PPUSH
12047: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
12051: LD_EXP 36
12055: PPUSH
12056: LD_VAR 0 4
12060: PPUSH
12061: CALL_OW 180
// end ; has_eng := UnitFilter ( filter , [ f_class , 2 ] ) ;
12065: LD_ADDR_VAR 0 2
12069: PUSH
12070: LD_VAR 0 3
12074: PPUSH
12075: LD_INT 25
12077: PUSH
12078: LD_INT 2
12080: PUSH
12081: EMPTY
12082: LIST
12083: LIST
12084: PPUSH
12085: CALL_OW 72
12089: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
12090: LD_INT 35
12092: PPUSH
12093: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
12097: LD_ADDR_VAR 0 6
12101: PUSH
12102: LD_INT 10
12104: PPUSH
12105: CALL_OW 435
12109: ST_TO_ADDR
// if crates then
12110: LD_VAR 0 6
12114: IFFALSE 12143
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
12116: LD_VAR 0 2
12120: PPUSH
12121: LD_VAR 0 6
12125: PUSH
12126: LD_INT 1
12128: ARRAY
12129: PPUSH
12130: LD_VAR 0 6
12134: PUSH
12135: LD_INT 2
12137: ARRAY
12138: PPUSH
12139: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
12143: LD_VAR 0 4
12147: PPUSH
12148: CALL_OW 274
12152: PPUSH
12153: LD_INT 1
12155: PPUSH
12156: CALL_OW 275
12160: PUSH
12161: LD_INT 40
12163: GREATEREQUAL
12164: IFFALSE 12090
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
12166: LD_ADDR_VAR 0 5
12170: PUSH
12171: LD_INT 4
12173: PUSH
12174: LD_INT 256
12176: PUSH
12177: LD_INT 111
12179: PUSH
12180: LD_INT 2
12182: PUSH
12183: EMPTY
12184: LIST
12185: LIST
12186: LIST
12187: LIST
12188: PUSH
12189: LD_INT 31
12191: PUSH
12192: LD_INT 243
12194: PUSH
12195: LD_INT 112
12197: PUSH
12198: LD_INT 2
12200: PUSH
12201: EMPTY
12202: LIST
12203: LIST
12204: LIST
12205: LIST
12206: PUSH
12207: EMPTY
12208: LIST
12209: LIST
12210: ST_TO_ADDR
// for i in blist do
12211: LD_ADDR_VAR 0 1
12215: PUSH
12216: LD_VAR 0 5
12220: PUSH
12221: FOR_IN
12222: IFFALSE 12271
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
12224: LD_VAR 0 2
12228: PPUSH
12229: LD_VAR 0 1
12233: PUSH
12234: LD_INT 1
12236: ARRAY
12237: PPUSH
12238: LD_VAR 0 1
12242: PUSH
12243: LD_INT 2
12245: ARRAY
12246: PPUSH
12247: LD_VAR 0 1
12251: PUSH
12252: LD_INT 3
12254: ARRAY
12255: PPUSH
12256: LD_VAR 0 1
12260: PUSH
12261: LD_INT 4
12263: ARRAY
12264: PPUSH
12265: CALL_OW 205
12269: GO 12221
12271: POP
12272: POP
// repeat wait ( 0 0$01 ) ;
12273: LD_INT 35
12275: PPUSH
12276: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
12280: LD_INT 22
12282: PUSH
12283: LD_INT 4
12285: PUSH
12286: EMPTY
12287: LIST
12288: LIST
12289: PUSH
12290: LD_INT 30
12292: PUSH
12293: LD_INT 4
12295: PUSH
12296: EMPTY
12297: LIST
12298: LIST
12299: PUSH
12300: LD_INT 3
12302: PUSH
12303: LD_INT 57
12305: PUSH
12306: EMPTY
12307: LIST
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: PUSH
12313: EMPTY
12314: LIST
12315: LIST
12316: LIST
12317: PPUSH
12318: CALL_OW 69
12322: IFFALSE 12273
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
12324: LD_VAR 0 3
12328: PUSH
12329: LD_VAR 0 2
12333: DIFF
12334: PPUSH
12335: LD_INT 22
12337: PUSH
12338: LD_INT 4
12340: PUSH
12341: EMPTY
12342: LIST
12343: LIST
12344: PUSH
12345: LD_INT 30
12347: PUSH
12348: LD_INT 4
12350: PUSH
12351: EMPTY
12352: LIST
12353: LIST
12354: PUSH
12355: EMPTY
12356: LIST
12357: LIST
12358: PPUSH
12359: CALL_OW 69
12363: PUSH
12364: LD_INT 1
12366: ARRAY
12367: PPUSH
12368: CALL_OW 180
// repeat wait ( 0 0$01 ) ;
12372: LD_INT 35
12374: PPUSH
12375: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
12379: LD_INT 22
12381: PUSH
12382: LD_INT 4
12384: PUSH
12385: EMPTY
12386: LIST
12387: LIST
12388: PUSH
12389: LD_INT 30
12391: PUSH
12392: LD_INT 31
12394: PUSH
12395: EMPTY
12396: LIST
12397: LIST
12398: PUSH
12399: LD_INT 3
12401: PUSH
12402: LD_INT 57
12404: PUSH
12405: EMPTY
12406: LIST
12407: PUSH
12408: EMPTY
12409: LIST
12410: LIST
12411: PUSH
12412: EMPTY
12413: LIST
12414: LIST
12415: LIST
12416: PPUSH
12417: CALL_OW 69
12421: IFFALSE 12372
// sol := filter diff has_eng ;
12423: LD_ADDR_VAR 0 8
12427: PUSH
12428: LD_VAR 0 3
12432: PUSH
12433: LD_VAR 0 2
12437: DIFF
12438: ST_TO_ADDR
// if GetClass ( sol [ 1 ] ) > 1 then
12439: LD_VAR 0 8
12443: PUSH
12444: LD_INT 1
12446: ARRAY
12447: PPUSH
12448: CALL_OW 257
12452: PUSH
12453: LD_INT 1
12455: GREATER
12456: IFFALSE 12474
// SetClass ( sol [ 1 ] , 1 ) ;
12458: LD_VAR 0 8
12462: PUSH
12463: LD_INT 1
12465: ARRAY
12466: PPUSH
12467: LD_INT 1
12469: PPUSH
12470: CALL_OW 336
// ComExitBuilding ( sol [ 1 ] ) ;
12474: LD_VAR 0 8
12478: PUSH
12479: LD_INT 1
12481: ARRAY
12482: PPUSH
12483: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
12487: LD_VAR 0 8
12491: PUSH
12492: LD_INT 1
12494: ARRAY
12495: PPUSH
12496: LD_INT 22
12498: PUSH
12499: LD_INT 4
12501: PUSH
12502: EMPTY
12503: LIST
12504: LIST
12505: PUSH
12506: LD_INT 30
12508: PUSH
12509: LD_INT 31
12511: PUSH
12512: EMPTY
12513: LIST
12514: LIST
12515: PUSH
12516: EMPTY
12517: LIST
12518: LIST
12519: PPUSH
12520: CALL_OW 69
12524: PUSH
12525: LD_INT 1
12527: ARRAY
12528: PPUSH
12529: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
12533: LD_VAR 0 2
12537: PPUSH
12538: LD_VAR 0 4
12542: PPUSH
12543: CALL_OW 112
// end ;
12547: PPOPN 8
12549: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
12550: LD_EXP 9
12554: IFFALSE 12874
12556: GO 12558
12558: DISABLE
12559: LD_INT 0
12561: PPUSH
12562: PPUSH
12563: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
12564: LD_ADDR_VAR 0 2
12568: PUSH
12569: LD_INT 22
12571: PUSH
12572: LD_INT 4
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: PUSH
12579: LD_INT 30
12581: PUSH
12582: LD_INT 4
12584: PUSH
12585: EMPTY
12586: LIST
12587: LIST
12588: PUSH
12589: EMPTY
12590: LIST
12591: LIST
12592: PPUSH
12593: CALL_OW 69
12597: PUSH
12598: LD_INT 1
12600: ARRAY
12601: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
12602: LD_EXP 4
12606: PPUSH
12607: CALL_OW 122
// for i in cornel_units do
12611: LD_ADDR_VAR 0 1
12615: PUSH
12616: LD_EXP 4
12620: PUSH
12621: FOR_IN
12622: IFFALSE 12676
// if GetClass ( i ) = 2 then
12624: LD_VAR 0 1
12628: PPUSH
12629: CALL_OW 257
12633: PUSH
12634: LD_INT 2
12636: EQUAL
12637: IFFALSE 12674
// begin ComEnterUnit ( i , arm ) ;
12639: LD_VAR 0 1
12643: PPUSH
12644: LD_VAR 0 2
12648: PPUSH
12649: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
12653: LD_VAR 0 1
12657: PPUSH
12658: LD_INT 1
12660: PPUSH
12661: CALL_OW 183
// AddComExitBuilding ( i ) ;
12665: LD_VAR 0 1
12669: PPUSH
12670: CALL_OW 182
// end ;
12674: GO 12621
12676: POP
12677: POP
// Wait ( 1 1$00 ) ;
12678: LD_INT 2100
12680: PPUSH
12681: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
12685: LD_ADDR_VAR 0 3
12689: PUSH
12690: LD_EXP 36
12694: PUSH
12695: LD_EXP 37
12699: ADD
12700: PUSH
12701: LD_EXP 4
12705: ADD
12706: PUSH
12707: LD_EXP 4
12711: PPUSH
12712: LD_INT 21
12714: PUSH
12715: LD_INT 2
12717: PUSH
12718: EMPTY
12719: LIST
12720: LIST
12721: PPUSH
12722: CALL_OW 72
12726: DIFF
12727: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
12728: LD_VAR 0 3
12732: PPUSH
12733: LD_INT 248
12735: PPUSH
12736: LD_INT 85
12738: PPUSH
12739: CALL_OW 111
// AddComHold ( filter ) ;
12743: LD_VAR 0 3
12747: PPUSH
12748: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
12752: LD_INT 35
12754: PPUSH
12755: CALL_OW 67
// until cornel_attack ;
12759: LD_EXP 7
12763: IFFALSE 12752
// ComAgressiveMove ( filter , 209 , 63 ) ;
12765: LD_VAR 0 3
12769: PPUSH
12770: LD_INT 209
12772: PPUSH
12773: LD_INT 63
12775: PPUSH
12776: CALL_OW 114
// if Bierezov then
12780: LD_EXP 37
12784: IFFALSE 12874
// begin filter := filter diff Bierezov ;
12786: LD_ADDR_VAR 0 3
12790: PUSH
12791: LD_VAR 0 3
12795: PUSH
12796: LD_EXP 37
12800: DIFF
12801: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
12802: LD_EXP 37
12806: PPUSH
12807: LD_INT 6
12809: PPUSH
12810: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
12814: LD_EXP 37
12818: PPUSH
12819: LD_INT 235
12821: PPUSH
12822: LD_INT 60
12824: PPUSH
12825: CALL_OW 111
// AddComHold ( Bierezov ) ;
12829: LD_EXP 37
12833: PPUSH
12834: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
12838: LD_EXP 37
12842: PPUSH
12843: LD_INT 350
12845: PPUSH
12846: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
12850: LD_EXP 37
12854: PPUSH
12855: LD_INT 198
12857: PPUSH
12858: LD_INT 28
12860: PPUSH
12861: CALL_OW 171
// AddComHold ( Bierezov ) ;
12865: LD_EXP 37
12869: PPUSH
12870: CALL_OW 200
// end ; end ; end_of_file
12874: PPOPN 3
12876: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
12877: LD_EXP 45
12881: PUSH
12882: LD_EXP 26
12886: NOT
12887: AND
12888: PUSH
12889: LD_EXP 27
12893: NOT
12894: AND
12895: IFFALSE 13345
12897: GO 12899
12899: DISABLE
12900: LD_INT 0
12902: PPUSH
12903: PPUSH
12904: PPUSH
12905: PPUSH
// begin enable ;
12906: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
12907: LD_ADDR_VAR 0 4
12911: PUSH
12912: LD_INT 81
12914: PUSH
12915: LD_INT 3
12917: PUSH
12918: EMPTY
12919: LIST
12920: LIST
12921: PPUSH
12922: CALL_OW 69
12926: ST_TO_ADDR
// for i = 1 to ru_patrol do
12927: LD_ADDR_VAR 0 2
12931: PUSH
12932: DOUBLE
12933: LD_INT 1
12935: DEC
12936: ST_TO_ADDR
12937: LD_EXP 45
12941: PUSH
12942: FOR_TO
12943: IFFALSE 13343
// begin un := ru_patrol [ i ] ;
12945: LD_ADDR_VAR 0 1
12949: PUSH
12950: LD_EXP 45
12954: PUSH
12955: LD_VAR 0 2
12959: ARRAY
12960: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
12961: LD_VAR 0 1
12965: PPUSH
12966: LD_INT 13
12968: PPUSH
12969: CALL_OW 308
12973: IFFALSE 13078
// begin if not ru_alert then
12975: LD_EXP 50
12979: NOT
12980: IFFALSE 12990
// ru_alert := true ;
12982: LD_ADDR_EXP 50
12986: PUSH
12987: LD_INT 1
12989: ST_TO_ADDR
// if not See ( 1 , un ) then
12990: LD_INT 1
12992: PPUSH
12993: LD_VAR 0 1
12997: PPUSH
12998: CALL_OW 292
13002: NOT
13003: IFFALSE 13017
// SetLives ( un , 1000 ) ;
13005: LD_VAR 0 1
13009: PPUSH
13010: LD_INT 1000
13012: PPUSH
13013: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
13017: LD_ADDR_EXP 45
13021: PUSH
13022: LD_EXP 45
13026: PUSH
13027: LD_VAR 0 1
13031: DIFF
13032: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
13033: LD_VAR 0 1
13037: PPUSH
13038: LD_INT 22
13040: PUSH
13041: LD_INT 3
13043: PUSH
13044: EMPTY
13045: LIST
13046: LIST
13047: PUSH
13048: LD_INT 30
13050: PUSH
13051: LD_INT 4
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: PUSH
13058: EMPTY
13059: LIST
13060: LIST
13061: PPUSH
13062: CALL_OW 69
13066: PPUSH
13067: CALL 983 0 1
13071: PPUSH
13072: CALL_OW 120
// continue ;
13076: GO 12942
// end ; if IsOk ( un ) and not HasTask ( un ) then
13078: LD_VAR 0 1
13082: PPUSH
13083: CALL_OW 302
13087: PUSH
13088: LD_VAR 0 1
13092: PPUSH
13093: CALL_OW 314
13097: NOT
13098: AND
13099: IFFALSE 13192
// begin for j = 1 to ru_firepoints_south [ i ] do
13101: LD_ADDR_VAR 0 3
13105: PUSH
13106: DOUBLE
13107: LD_INT 1
13109: DEC
13110: ST_TO_ADDR
13111: LD_EXP 49
13115: PUSH
13116: LD_VAR 0 2
13120: ARRAY
13121: PUSH
13122: FOR_TO
13123: IFFALSE 13190
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
13125: LD_VAR 0 1
13129: PPUSH
13130: LD_EXP 49
13134: PUSH
13135: LD_VAR 0 2
13139: ARRAY
13140: PUSH
13141: LD_VAR 0 3
13145: ARRAY
13146: PUSH
13147: LD_INT 1
13149: ARRAY
13150: PPUSH
13151: LD_EXP 49
13155: PUSH
13156: LD_VAR 0 2
13160: ARRAY
13161: PUSH
13162: LD_VAR 0 3
13166: ARRAY
13167: PUSH
13168: LD_INT 2
13170: ARRAY
13171: PPUSH
13172: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
13176: LD_VAR 0 1
13180: PPUSH
13181: LD_INT 70
13183: PPUSH
13184: CALL_OW 202
// end ;
13188: GO 13122
13190: POP
13191: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
13192: LD_VAR 0 1
13196: PPUSH
13197: CALL_OW 256
13201: PUSH
13202: LD_INT 700
13204: LESS
13205: PUSH
13206: LD_VAR 0 1
13210: PPUSH
13211: LD_INT 13
13213: PPUSH
13214: CALL_OW 308
13218: NOT
13219: AND
13220: IFFALSE 13272
// begin ComMoveToArea ( un , retreatArea ) ;
13222: LD_VAR 0 1
13226: PPUSH
13227: LD_INT 13
13229: PPUSH
13230: CALL_OW 113
// if not ru_alert_xy then
13234: LD_EXP 51
13238: NOT
13239: IFFALSE 13270
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
13241: LD_ADDR_EXP 51
13245: PUSH
13246: LD_VAR 0 1
13250: PPUSH
13251: CALL_OW 250
13255: PUSH
13256: LD_VAR 0 1
13260: PPUSH
13261: CALL_OW 251
13265: PUSH
13266: EMPTY
13267: LIST
13268: LIST
13269: ST_TO_ADDR
// end else
13270: GO 13341
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
13272: LD_VAR 0 1
13276: PPUSH
13277: LD_VAR 0 4
13281: PPUSH
13282: LD_VAR 0 1
13286: PPUSH
13287: CALL_OW 74
13291: PPUSH
13292: CALL_OW 296
13296: PUSH
13297: LD_INT 9
13299: LESS
13300: PUSH
13301: LD_VAR 0 1
13305: PPUSH
13306: CALL_OW 256
13310: PUSH
13311: LD_INT 500
13313: GREATER
13314: AND
13315: IFFALSE 13341
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
13317: LD_VAR 0 1
13321: PPUSH
13322: LD_VAR 0 4
13326: PPUSH
13327: LD_VAR 0 1
13331: PPUSH
13332: CALL_OW 74
13336: PPUSH
13337: CALL_OW 115
// end ;
13341: GO 12942
13343: POP
13344: POP
// end ;
13345: PPOPN 4
13347: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
13348: LD_EXP 50
13352: PUSH
13353: LD_EXP 51
13357: AND
13358: PUSH
13359: LD_EXP 26
13363: NOT
13364: AND
13365: PUSH
13366: LD_EXP 27
13370: NOT
13371: AND
13372: IFFALSE 13582
13374: GO 13376
13376: DISABLE
13377: LD_INT 0
13379: PPUSH
13380: PPUSH
// begin enable ;
13381: ENABLE
// if not ru_vehicles then
13382: LD_EXP 48
13386: NOT
13387: IFFALSE 13391
// exit ;
13389: GO 13582
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
13391: LD_ADDR_VAR 0 2
13395: PUSH
13396: LD_INT 81
13398: PUSH
13399: LD_INT 3
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: PPUSH
13406: CALL_OW 69
13410: ST_TO_ADDR
// if ru_vehicles then
13411: LD_EXP 48
13415: IFFALSE 13582
// begin for i in ru_vehicles do
13417: LD_ADDR_VAR 0 1
13421: PUSH
13422: LD_EXP 48
13426: PUSH
13427: FOR_IN
13428: IFFALSE 13580
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
13430: LD_VAR 0 1
13434: PPUSH
13435: CALL_OW 302
13439: PUSH
13440: LD_VAR 0 1
13444: PPUSH
13445: LD_VAR 0 2
13449: PPUSH
13450: LD_VAR 0 1
13454: PPUSH
13455: CALL_OW 74
13459: PPUSH
13460: CALL_OW 296
13464: PUSH
13465: LD_INT 9
13467: LESS
13468: AND
13469: IFFALSE 13495
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
13471: LD_VAR 0 1
13475: PPUSH
13476: LD_VAR 0 2
13480: PPUSH
13481: LD_VAR 0 1
13485: PPUSH
13486: CALL_OW 74
13490: PPUSH
13491: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
13495: LD_VAR 0 1
13499: PPUSH
13500: CALL_OW 314
13504: NOT
13505: PUSH
13506: LD_VAR 0 1
13510: PPUSH
13511: CALL_OW 302
13515: AND
13516: PUSH
13517: LD_VAR 0 1
13521: PPUSH
13522: LD_EXP 51
13526: PUSH
13527: LD_INT 1
13529: ARRAY
13530: PPUSH
13531: LD_EXP 51
13535: PUSH
13536: LD_INT 2
13538: ARRAY
13539: PPUSH
13540: CALL_OW 297
13544: PUSH
13545: LD_INT 10
13547: GREATER
13548: AND
13549: IFFALSE 13578
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
13551: LD_VAR 0 1
13555: PPUSH
13556: LD_EXP 51
13560: PUSH
13561: LD_INT 1
13563: ARRAY
13564: PPUSH
13565: LD_EXP 51
13569: PUSH
13570: LD_INT 2
13572: ARRAY
13573: PPUSH
13574: CALL_OW 114
// end ;
13578: GO 13427
13580: POP
13581: POP
// end ; end ;
13582: PPOPN 2
13584: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
13585: LD_EXP 51
13589: PUSH
13590: LD_EXP 50
13594: AND
13595: PUSH
13596: LD_INT 3
13598: PPUSH
13599: CALL_OW 463
13603: NOT
13604: AND
13605: PUSH
13606: LD_EXP 26
13610: NOT
13611: AND
13612: PUSH
13613: LD_EXP 27
13617: NOT
13618: AND
13619: IFFALSE 13714
13621: GO 13623
13623: DISABLE
13624: LD_INT 0
13626: PPUSH
// begin enable ;
13627: ENABLE
// ru_alert_xy := false ;
13628: LD_ADDR_EXP 51
13632: PUSH
13633: LD_INT 0
13635: ST_TO_ADDR
// ru_alert := false ;
13636: LD_ADDR_EXP 50
13640: PUSH
13641: LD_INT 0
13643: ST_TO_ADDR
// if ru_vehicles then
13644: LD_EXP 48
13648: IFFALSE 13714
// for i in ru_vehicles do
13650: LD_ADDR_VAR 0 1
13654: PUSH
13655: LD_EXP 48
13659: PUSH
13660: FOR_IN
13661: IFFALSE 13712
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
13663: LD_VAR 0 1
13667: PPUSH
13668: CALL_OW 302
13672: PUSH
13673: LD_VAR 0 1
13677: PPUSH
13678: LD_INT 89
13680: PPUSH
13681: LD_INT 36
13683: PPUSH
13684: CALL_OW 297
13688: PUSH
13689: LD_INT 10
13691: GREATER
13692: AND
13693: IFFALSE 13710
// ComMoveXY ( i , 89 , 36 ) ;
13695: LD_VAR 0 1
13699: PPUSH
13700: LD_INT 89
13702: PPUSH
13703: LD_INT 36
13705: PPUSH
13706: CALL_OW 111
13710: GO 13660
13712: POP
13713: POP
// end ;
13714: PPOPN 1
13716: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
13717: LD_EXP 47
13721: PUSH
13722: LD_EXP 26
13726: NOT
13727: AND
13728: PUSH
13729: LD_EXP 27
13733: NOT
13734: AND
13735: IFFALSE 14019
13737: GO 13739
13739: DISABLE
13740: LD_INT 0
13742: PPUSH
13743: PPUSH
13744: PPUSH
// begin enable ;
13745: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
13746: LD_ADDR_VAR 0 3
13750: PUSH
13751: LD_INT 81
13753: PUSH
13754: LD_INT 3
13756: PUSH
13757: EMPTY
13758: LIST
13759: LIST
13760: PPUSH
13761: CALL_OW 69
13765: ST_TO_ADDR
// for i = 1 to ru_forest do
13766: LD_ADDR_VAR 0 1
13770: PUSH
13771: DOUBLE
13772: LD_INT 1
13774: DEC
13775: ST_TO_ADDR
13776: LD_EXP 47
13780: PUSH
13781: FOR_TO
13782: IFFALSE 14017
// begin un := ru_forest [ i ] ;
13784: LD_ADDR_VAR 0 2
13788: PUSH
13789: LD_EXP 47
13793: PUSH
13794: LD_VAR 0 1
13798: ARRAY
13799: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
13800: LD_VAR 0 2
13804: PPUSH
13805: LD_INT 13
13807: PPUSH
13808: CALL_OW 308
13812: IFFALSE 13902
// begin if not See ( 1 , un ) then
13814: LD_INT 1
13816: PPUSH
13817: LD_VAR 0 2
13821: PPUSH
13822: CALL_OW 292
13826: NOT
13827: IFFALSE 13841
// SetLives ( un , 1000 ) ;
13829: LD_VAR 0 2
13833: PPUSH
13834: LD_INT 1000
13836: PPUSH
13837: CALL_OW 234
// ru_forest := ru_forest diff un ;
13841: LD_ADDR_EXP 47
13845: PUSH
13846: LD_EXP 47
13850: PUSH
13851: LD_VAR 0 2
13855: DIFF
13856: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
13857: LD_VAR 0 2
13861: PPUSH
13862: LD_INT 22
13864: PUSH
13865: LD_INT 3
13867: PUSH
13868: EMPTY
13869: LIST
13870: LIST
13871: PUSH
13872: LD_INT 30
13874: PUSH
13875: LD_INT 4
13877: PUSH
13878: EMPTY
13879: LIST
13880: LIST
13881: PUSH
13882: EMPTY
13883: LIST
13884: LIST
13885: PPUSH
13886: CALL_OW 69
13890: PPUSH
13891: CALL 983 0 1
13895: PPUSH
13896: CALL_OW 120
// continue ;
13900: GO 13781
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
13902: LD_VAR 0 2
13906: PPUSH
13907: CALL_OW 256
13911: PUSH
13912: LD_INT 700
13914: LESS
13915: PUSH
13916: LD_VAR 0 2
13920: PPUSH
13921: LD_INT 13
13923: PPUSH
13924: CALL_OW 308
13928: NOT
13929: AND
13930: IFFALSE 13946
// ComMoveToArea ( un , retreatArea ) else
13932: LD_VAR 0 2
13936: PPUSH
13937: LD_INT 13
13939: PPUSH
13940: CALL_OW 113
13944: GO 14015
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
13946: LD_VAR 0 2
13950: PPUSH
13951: LD_VAR 0 3
13955: PPUSH
13956: LD_VAR 0 2
13960: PPUSH
13961: CALL_OW 74
13965: PPUSH
13966: CALL_OW 296
13970: PUSH
13971: LD_INT 9
13973: LESS
13974: PUSH
13975: LD_VAR 0 2
13979: PPUSH
13980: CALL_OW 256
13984: PUSH
13985: LD_INT 500
13987: GREATER
13988: AND
13989: IFFALSE 14015
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
13991: LD_VAR 0 2
13995: PPUSH
13996: LD_VAR 0 3
14000: PPUSH
14001: LD_VAR 0 2
14005: PPUSH
14006: CALL_OW 74
14010: PPUSH
14011: CALL_OW 115
// end ;
14015: GO 13781
14017: POP
14018: POP
// end ;
14019: PPOPN 3
14021: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
14022: LD_EXP 27
14026: NOT
14027: IFFALSE 14148
14029: GO 14031
14031: DISABLE
14032: LD_INT 0
14034: PPUSH
14035: PPUSH
// begin enable ;
14036: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
14037: LD_ADDR_VAR 0 2
14041: PUSH
14042: LD_INT 22
14044: PUSH
14045: LD_INT 3
14047: PUSH
14048: EMPTY
14049: LIST
14050: LIST
14051: PUSH
14052: LD_INT 21
14054: PUSH
14055: LD_INT 3
14057: PUSH
14058: EMPTY
14059: LIST
14060: LIST
14061: PUSH
14062: EMPTY
14063: LIST
14064: LIST
14065: PPUSH
14066: CALL_OW 69
14070: ST_TO_ADDR
// if filter then
14071: LD_VAR 0 2
14075: IFFALSE 14148
// for i in filter do
14077: LD_ADDR_VAR 0 1
14081: PUSH
14082: LD_VAR 0 2
14086: PUSH
14087: FOR_IN
14088: IFFALSE 14146
// if GetLives ( i ) < 990 then
14090: LD_VAR 0 1
14094: PPUSH
14095: CALL_OW 256
14099: PUSH
14100: LD_INT 990
14102: LESS
14103: IFFALSE 14144
// begin ru_alert := true ;
14105: LD_ADDR_EXP 50
14109: PUSH
14110: LD_INT 1
14112: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
14113: LD_ADDR_EXP 51
14117: PUSH
14118: LD_VAR 0 1
14122: PPUSH
14123: CALL_OW 250
14127: PUSH
14128: LD_VAR 0 1
14132: PPUSH
14133: CALL_OW 251
14137: PUSH
14138: EMPTY
14139: LIST
14140: LIST
14141: ST_TO_ADDR
// break ;
14142: GO 14146
// end ;
14144: GO 14087
14146: POP
14147: POP
// end ;
14148: PPOPN 2
14150: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
14151: LD_EXP 26
14155: IFFALSE 14294
14157: GO 14159
14159: DISABLE
14160: LD_INT 0
14162: PPUSH
14163: PPUSH
14164: PPUSH
14165: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
14166: LD_ADDR_VAR 0 4
14170: PUSH
14171: LD_EXP 48
14175: PUSH
14176: LD_EXP 47
14180: ADD
14181: PUSH
14182: LD_EXP 45
14186: ADD
14187: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
14188: LD_ADDR_VAR 0 3
14192: PUSH
14193: LD_INT 3
14195: PPUSH
14196: LD_INT 81
14198: PUSH
14199: LD_INT 3
14201: PUSH
14202: EMPTY
14203: LIST
14204: LIST
14205: PPUSH
14206: CALL_OW 70
14210: ST_TO_ADDR
// if filter and enemy then
14211: LD_VAR 0 4
14215: PUSH
14216: LD_VAR 0 3
14220: AND
14221: IFFALSE 14294
// repeat wait ( 0 0$01 ) ;
14223: LD_INT 35
14225: PPUSH
14226: CALL_OW 67
// for i in filter do
14230: LD_ADDR_VAR 0 1
14234: PUSH
14235: LD_VAR 0 4
14239: PUSH
14240: FOR_IN
14241: IFFALSE 14269
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
14243: LD_VAR 0 1
14247: PPUSH
14248: LD_VAR 0 3
14252: PPUSH
14253: LD_VAR 0 1
14257: PPUSH
14258: CALL_OW 74
14262: PPUSH
14263: CALL_OW 115
// end ;
14267: GO 14240
14269: POP
14270: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 ;
14271: LD_INT 3
14273: PPUSH
14274: LD_INT 81
14276: PUSH
14277: LD_INT 3
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: PPUSH
14284: CALL_OW 70
14288: PUSH
14289: LD_INT 0
14291: EQUAL
14292: IFFALSE 14223
// end ; end_of_file
14294: PPOPN 4
14296: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
14297: LD_EXP 3
14301: PUSH
14302: LD_EXP 7
14306: NOT
14307: AND
14308: PUSH
14309: LD_EXP 17
14313: AND
14314: IFFALSE 14426
14316: GO 14318
14318: DISABLE
14319: LD_INT 0
14321: PPUSH
// begin enable ;
14322: ENABLE
// crates_counter := crates_counter - 50 ;
14323: LD_ADDR_EXP 17
14327: PUSH
14328: LD_EXP 17
14332: PUSH
14333: LD_INT 50
14335: MINUS
14336: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
14337: LD_INT 8
14339: PPUSH
14340: LD_INT 2
14342: PPUSH
14343: LD_INT 5
14345: PPUSH
14346: CALL_OW 12
14350: PPUSH
14351: LD_INT 1
14353: PPUSH
14354: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
14358: LD_INT 1785
14360: PPUSH
14361: LD_INT 2345
14363: PPUSH
14364: CALL_OW 12
14368: PPUSH
14369: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
14373: LD_ADDR_VAR 0 1
14377: PUSH
14378: LD_INT 1
14380: PPUSH
14381: LD_OWVAR 67
14385: PUSH
14386: LD_INT 2
14388: PLUS
14389: PPUSH
14390: CALL_OW 12
14394: ST_TO_ADDR
// if r < 3 then
14395: LD_VAR 0 1
14399: PUSH
14400: LD_INT 3
14402: LESS
14403: IFFALSE 14426
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
14405: LD_INT 4
14407: PPUSH
14408: LD_INT 1
14410: PPUSH
14411: LD_INT 5
14413: PPUSH
14414: CALL_OW 12
14418: PPUSH
14419: LD_INT 1
14421: PPUSH
14422: CALL_OW 55
// end ;
14426: PPOPN 1
14428: END
// every 0 0$01 trigger cornel_active do
14429: LD_EXP 6
14433: IFFALSE 14522
14435: GO 14437
14437: DISABLE
// begin Wait ( 0 0$03 ) ;
14438: LD_INT 105
14440: PPUSH
14441: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
14445: LD_INT 2
14447: PPUSH
14448: LD_INT 5
14450: PPUSH
14451: CALL_OW 12
14455: PPUSH
14456: LD_INT 10
14458: PPUSH
14459: LD_INT 1
14461: PPUSH
14462: CALL_OW 55
// Wait ( 0 0$13 ) ;
14466: LD_INT 455
14468: PPUSH
14469: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
14473: LD_INT 2
14475: PPUSH
14476: LD_INT 5
14478: PPUSH
14479: CALL_OW 12
14483: PPUSH
14484: LD_INT 10
14486: PPUSH
14487: LD_INT 1
14489: PPUSH
14490: CALL_OW 55
// Wait ( 0 0$16 ) ;
14494: LD_INT 560
14496: PPUSH
14497: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
14501: LD_INT 2
14503: PPUSH
14504: LD_INT 5
14506: PPUSH
14507: CALL_OW 12
14511: PPUSH
14512: LD_INT 10
14514: PPUSH
14515: LD_INT 1
14517: PPUSH
14518: CALL_OW 55
// end ; end_of_file
14522: END
// every 0 0$01 trigger cornel_prepared do
14523: LD_EXP 9
14527: IFFALSE 14586
14529: GO 14531
14531: DISABLE
// begin enable ;
14532: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
14533: LD_ADDR_OWVAR 47
14537: PUSH
14538: LD_STRING #Am03-1
14540: PUSH
14541: LD_EXP 8
14545: PUSH
14546: EMPTY
14547: LIST
14548: LIST
14549: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
14550: LD_ADDR_EXP 8
14554: PUSH
14555: LD_EXP 8
14559: PPUSH
14560: LD_STRING -
14562: PPUSH
14563: CALL 1053 0 2
14567: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
14568: LD_EXP 8
14572: PUSH
14573: LD_INT 0
14575: EQUAL
14576: IFFALSE 14586
// begin Display_Strings := [ ] ;
14578: LD_ADDR_OWVAR 47
14582: PUSH
14583: EMPTY
14584: ST_TO_ADDR
// disable ;
14585: DISABLE
// end ; end ;
14586: END
// every 0 0$01 trigger debug and debug_strings do
14587: LD_EXP 1
14591: PUSH
14592: LD_OWVAR 48
14596: AND
14597: IFFALSE 14613
14599: GO 14601
14601: DISABLE
// begin enable ;
14602: ENABLE
// Display_Strings := debug_strings ;
14603: LD_ADDR_OWVAR 47
14607: PUSH
14608: LD_OWVAR 48
14612: ST_TO_ADDR
// end ; end_of_file
14613: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
14614: LD_VAR 0 1
14618: PPUSH
14619: CALL_OW 255
14623: PUSH
14624: LD_INT 1
14626: EQUAL
14627: PUSH
14628: LD_EXP 11
14632: NOT
14633: AND
14634: IFFALSE 14644
// solar_builded := true ;
14636: LD_ADDR_EXP 11
14640: PUSH
14641: LD_INT 1
14643: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
14644: LD_VAR 0 1
14648: PPUSH
14649: CALL_OW 255
14653: PUSH
14654: LD_INT 1
14656: EQUAL
14657: PUSH
14658: LD_EXP 24
14662: AND
14663: IFFALSE 14696
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
14665: LD_ADDR_EXP 24
14669: PUSH
14670: LD_EXP 24
14674: PUSH
14675: LD_INT 1750
14677: PUSH
14678: LD_INT 1400
14680: PUSH
14681: LD_INT 1225
14683: PUSH
14684: EMPTY
14685: LIST
14686: LIST
14687: LIST
14688: PUSH
14689: LD_OWVAR 67
14693: ARRAY
14694: PLUS
14695: ST_TO_ADDR
// end ;
14696: PPOPN 2
14698: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
14699: LD_VAR 0 1
14703: PUSH
14704: LD_EXP 45
14708: IN
14709: IFFALSE 14727
// ru_patrol := ru_patrol diff un ;
14711: LD_ADDR_EXP 45
14715: PUSH
14716: LD_EXP 45
14720: PUSH
14721: LD_VAR 0 1
14725: DIFF
14726: ST_TO_ADDR
// if un in ru_forest then
14727: LD_VAR 0 1
14731: PUSH
14732: LD_EXP 47
14736: IN
14737: IFFALSE 14755
// ru_forest := ru_forest diff un ;
14739: LD_ADDR_EXP 47
14743: PUSH
14744: LD_EXP 47
14748: PUSH
14749: LD_VAR 0 1
14753: DIFF
14754: ST_TO_ADDR
// if un in ru_vehicles then
14755: LD_VAR 0 1
14759: PUSH
14760: LD_EXP 48
14764: IN
14765: IFFALSE 14783
// ru_vehicles := ru_vehicles diff un ;
14767: LD_ADDR_EXP 48
14771: PUSH
14772: LD_EXP 48
14776: PUSH
14777: LD_VAR 0 1
14781: DIFF
14782: ST_TO_ADDR
// if un = JMM then
14783: LD_VAR 0 1
14787: PUSH
14788: LD_EXP 29
14792: EQUAL
14793: IFFALSE 14802
// YouLost ( 0 ) ;
14795: LD_STRING 0
14797: PPUSH
14798: CALL_OW 104
// if un = us_dep_west then
14802: LD_VAR 0 1
14806: PUSH
14807: LD_INT 1
14809: EQUAL
14810: IFFALSE 14819
// YouLost ( 2 ) ;
14812: LD_STRING 2
14814: PPUSH
14815: CALL_OW 104
// if un = Lynch and GetSide ( Lynch ) = 8 then
14819: LD_VAR 0 1
14823: PUSH
14824: LD_EXP 39
14828: EQUAL
14829: PUSH
14830: LD_EXP 39
14834: PPUSH
14835: CALL_OW 255
14839: PUSH
14840: LD_INT 8
14842: EQUAL
14843: AND
14844: IFFALSE 14853
// YouLost ( 4 ) ;
14846: LD_STRING 4
14848: PPUSH
14849: CALL_OW 104
// end ;
14853: PPOPN 1
14855: END
// every 0 0$01 trigger not game_end and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) < 4 do
14856: LD_EXP 28
14860: NOT
14861: PUSH
14862: LD_INT 22
14864: PUSH
14865: LD_INT 1
14867: PUSH
14868: EMPTY
14869: LIST
14870: LIST
14871: PUSH
14872: LD_INT 21
14874: PUSH
14875: LD_INT 1
14877: PUSH
14878: EMPTY
14879: LIST
14880: LIST
14881: PUSH
14882: EMPTY
14883: LIST
14884: LIST
14885: PPUSH
14886: CALL_OW 69
14890: PUSH
14891: LD_INT 22
14893: PUSH
14894: LD_INT 8
14896: PUSH
14897: EMPTY
14898: LIST
14899: LIST
14900: PUSH
14901: LD_INT 21
14903: PUSH
14904: LD_INT 1
14906: PUSH
14907: EMPTY
14908: LIST
14909: LIST
14910: PUSH
14911: EMPTY
14912: LIST
14913: LIST
14914: PPUSH
14915: CALL_OW 69
14919: PLUS
14920: PUSH
14921: LD_INT 4
14923: LESS
14924: AND
14925: IFFALSE 14937
14927: GO 14929
14929: DISABLE
// YouLost ( 1 ) ;
14930: LD_STRING 1
14932: PPUSH
14933: CALL_OW 104
14937: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
14938: LD_INT 1
14940: PPUSH
14941: CALL_OW 255
14945: PUSH
14946: LD_INT 3
14948: EQUAL
14949: IFFALSE 14961
14951: GO 14953
14953: DISABLE
// YouLost ( 3 ) ;
14954: LD_STRING 3
14956: PPUSH
14957: CALL_OW 104
14961: END
