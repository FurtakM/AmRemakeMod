// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 347 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 435 0 0
// PrepareRussian ;
  22: CALL 2928 0 0
// PrepareAmerican ;
  26: CALL 1169 0 0
// PrepareCornell ;
  30: CALL 2193 0 0
// PrepareWesternBase ;
  34: CALL 2419 0 0
// Action ;
  38: CALL 4934 0 0
// end ;
  42: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := 1 ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 1
  53: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  54: LD_ADDR_EXP 3
  58: PUSH
  59: LD_STRING 02_
  61: ST_TO_ADDR
// mission_prefix := 03_ ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_STRING 03_
  69: ST_TO_ADDR
// jmm_units := 0 ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// cornel_units := 0 ;
  78: LD_ADDR_EXP 6
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// bierezov_exist := false ;
  86: LD_ADDR_EXP 7
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// jmm_on_west := false ;
  94: LD_ADDR_EXP 5
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_active := false ;
 102: LD_ADDR_EXP 8
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_attack := false ;
 110: LD_ADDR_EXP 9
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// cornel_prepared := false ;
 118: LD_ADDR_EXP 11
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 126: LD_ADDR_EXP 10
 130: PUSH
 131: LD_INT 4200
 133: ST_TO_ADDR
// frank_can_return := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// solar_builded := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// frank_send_to_scout := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// jmm_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// bobby_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// cyrus_in_veh := false ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// lisa_in_veh := false ;
 182: LD_ADDR_EXP 18
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 190: LD_ADDR_EXP 27
 194: PUSH
 195: LD_INT 25200
 197: PUSH
 198: LD_INT 23100
 200: PUSH
 201: LD_INT 21000
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: PUSH
 209: LD_OWVAR 67
 213: ARRAY
 214: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 215: LD_ADDR_EXP 19
 219: PUSH
 220: LD_INT 600
 222: PUSH
 223: LD_INT 500
 225: PUSH
 226: LD_INT 400
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: PUSH
 234: LD_OWVAR 67
 238: ARRAY
 239: ST_TO_ADDR
// end_mission_allowed := false ;
 240: LD_ADDR_EXP 20
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// save_others := [ ] ;
 248: LD_ADDR_EXP 21
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// save_group := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// show_query := true ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// wait_for_them := false ;
 270: LD_ADDR_EXP 24
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// veh_on_meta := false ;
 278: LD_ADDR_EXP 26
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_spec_patrol := false ;
 286: LD_ADDR_EXP 28
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// prepare_siege := false ;
 294: LD_ADDR_EXP 29
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// send_attack_on_cornel := false ;
 302: LD_ADDR_EXP 30
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 310: LD_ADDR_EXP 25
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// game_end := false ;
 318: LD_ADDR_EXP 31
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// lose_counter := 0 ;
 326: LD_ADDR_EXP 32
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// powell_warn := 0 ;
 334: LD_ADDR_EXP 33
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// end ;
 342: LD_VAR 0 1
 346: RET
// function SetDiplomacy ; begin
 347: LD_INT 0
 349: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 4
 355: PPUSH
 356: LD_INT 1
 358: PPUSH
 359: LD_INT 1
 361: PPUSH
 362: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 366: LD_INT 1
 368: PPUSH
 369: LD_INT 8
 371: PPUSH
 372: LD_INT 1
 374: PPUSH
 375: LD_INT 1
 377: PPUSH
 378: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 382: LD_INT 3
 384: PPUSH
 385: LD_INT 6
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 398: LD_INT 4
 400: PPUSH
 401: LD_INT 6
 403: PPUSH
 404: LD_INT 0
 406: PPUSH
 407: LD_INT 1
 409: PPUSH
 410: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 8
 419: PPUSH
 420: LD_INT 0
 422: PPUSH
 423: LD_INT 1
 425: PPUSH
 426: CALL_OW 80
// end ;
 430: LD_VAR 0 1
 434: RET
// export function DebugMode ; var i ; begin
 435: LD_INT 0
 437: PPUSH
 438: PPUSH
// FogOff ( 1 ) ;
 439: LD_INT 1
 441: PPUSH
 442: CALL_OW 344
// debug_strings := [ ] ;
 446: LD_ADDR_OWVAR 48
 450: PUSH
 451: EMPTY
 452: ST_TO_ADDR
// end ; end_of_file
 453: LD_VAR 0 1
 457: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 458: LD_INT 0
 460: PPUSH
 461: PPUSH
// if exist_mode then
 462: LD_VAR 0 2
 466: IFFALSE 491
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 468: LD_ADDR_VAR 0 4
 472: PUSH
 473: LD_EXP 3
 477: PUSH
 478: LD_VAR 0 1
 482: STR
 483: PPUSH
 484: CALL_OW 34
 488: ST_TO_ADDR
 489: GO 506
// unit := NewCharacter ( ident ) ;
 491: LD_ADDR_VAR 0 4
 495: PUSH
 496: LD_VAR 0 1
 500: PPUSH
 501: CALL_OW 25
 505: ST_TO_ADDR
// result := unit ;
 506: LD_ADDR_VAR 0 3
 510: PUSH
 511: LD_VAR 0 4
 515: ST_TO_ADDR
// end ;
 516: LD_VAR 0 3
 520: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 521: LD_INT 0
 523: PPUSH
// uc_side := side ;
 524: LD_ADDR_OWVAR 20
 528: PUSH
 529: LD_VAR 0 1
 533: ST_TO_ADDR
// uc_nation := nation ;
 534: LD_ADDR_OWVAR 21
 538: PUSH
 539: LD_VAR 0 2
 543: ST_TO_ADDR
// vc_chassis := chassis ;
 544: LD_ADDR_OWVAR 37
 548: PUSH
 549: LD_VAR 0 3
 553: ST_TO_ADDR
// vc_engine := engine ;
 554: LD_ADDR_OWVAR 39
 558: PUSH
 559: LD_VAR 0 4
 563: ST_TO_ADDR
// vc_control := control ;
 564: LD_ADDR_OWVAR 38
 568: PUSH
 569: LD_VAR 0 5
 573: ST_TO_ADDR
// vc_weapon := weapon ;
 574: LD_ADDR_OWVAR 40
 578: PUSH
 579: LD_VAR 0 6
 583: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 584: LD_ADDR_OWVAR 41
 588: PUSH
 589: LD_VAR 0 7
 593: ST_TO_ADDR
// result := CreateVehicle ;
 594: LD_ADDR_VAR 0 8
 598: PUSH
 599: CALL_OW 45
 603: ST_TO_ADDR
// end ;
 604: LD_VAR 0 8
 608: RET
// export function SayX ( units , ident ) ; var i ; begin
 609: LD_INT 0
 611: PPUSH
 612: PPUSH
// result := false ;
 613: LD_ADDR_VAR 0 3
 617: PUSH
 618: LD_INT 0
 620: ST_TO_ADDR
// if not units then
 621: LD_VAR 0 1
 625: NOT
 626: IFFALSE 630
// exit ;
 628: GO 684
// for i in units do
 630: LD_ADDR_VAR 0 4
 634: PUSH
 635: LD_VAR 0 1
 639: PUSH
 640: FOR_IN
 641: IFFALSE 682
// if IsOk ( i ) then
 643: LD_VAR 0 4
 647: PPUSH
 648: CALL_OW 302
 652: IFFALSE 680
// begin Say ( i , ident ) ;
 654: LD_VAR 0 4
 658: PPUSH
 659: LD_VAR 0 2
 663: PPUSH
 664: CALL_OW 88
// result := i ;
 668: LD_ADDR_VAR 0 3
 672: PUSH
 673: LD_VAR 0 4
 677: ST_TO_ADDR
// break ;
 678: GO 682
// end ;
 680: GO 640
 682: POP
 683: POP
// end ;
 684: LD_VAR 0 3
 688: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 689: LD_INT 0
 691: PPUSH
 692: PPUSH
 693: PPUSH
 694: PPUSH
// for i = 1 to count do
 695: LD_ADDR_VAR 0 8
 699: PUSH
 700: DOUBLE
 701: LD_INT 1
 703: DEC
 704: ST_TO_ADDR
 705: LD_VAR 0 6
 709: PUSH
 710: FOR_TO
 711: IFFALSE 792
// begin uc_side = side ;
 713: LD_ADDR_OWVAR 20
 717: PUSH
 718: LD_VAR 0 1
 722: ST_TO_ADDR
// uc_nation = nation ;
 723: LD_ADDR_OWVAR 21
 727: PUSH
 728: LD_VAR 0 2
 732: ST_TO_ADDR
// hc_gallery =  ;
 733: LD_ADDR_OWVAR 33
 737: PUSH
 738: LD_STRING 
 740: ST_TO_ADDR
// hc_name =  ;
 741: LD_ADDR_OWVAR 26
 745: PUSH
 746: LD_STRING 
 748: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 749: LD_INT 0
 751: PPUSH
 752: LD_VAR 0 5
 756: PPUSH
 757: LD_VAR 0 4
 761: PPUSH
 762: CALL_OW 380
// un = CreateHuman ;
 766: LD_ADDR_VAR 0 10
 770: PUSH
 771: CALL_OW 44
 775: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 776: LD_VAR 0 10
 780: PPUSH
 781: LD_VAR 0 3
 785: PPUSH
 786: CALL_OW 52
// end ;
 790: GO 710
 792: POP
 793: POP
// end ;
 794: LD_VAR 0 7
 798: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 799: LD_INT 0
 801: PPUSH
 802: PPUSH
 803: PPUSH
// uc_side := GetSide ( b ) ;
 804: LD_ADDR_OWVAR 20
 808: PUSH
 809: LD_VAR 0 2
 813: PPUSH
 814: CALL_OW 255
 818: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 819: LD_ADDR_OWVAR 21
 823: PUSH
 824: LD_VAR 0 2
 828: PPUSH
 829: CALL_OW 248
 833: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 834: LD_INT 0
 836: PPUSH
 837: LD_INT 1
 839: PPUSH
 840: LD_VAR 0 1
 844: PPUSH
 845: CALL_OW 380
// un = CreateHuman ;
 849: LD_ADDR_VAR 0 4
 853: PUSH
 854: CALL_OW 44
 858: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 859: LD_ADDR_VAR 0 5
 863: PUSH
 864: LD_VAR 0 2
 868: PPUSH
 869: CALL_OW 254
 873: PUSH
 874: LD_INT 3
 876: MINUS
 877: ST_TO_ADDR
// if dir < 0 then
 878: LD_VAR 0 5
 882: PUSH
 883: LD_INT 0
 885: LESS
 886: IFFALSE 902
// dir := 6 + dir ;
 888: LD_ADDR_VAR 0 5
 892: PUSH
 893: LD_INT 6
 895: PUSH
 896: LD_VAR 0 5
 900: PLUS
 901: ST_TO_ADDR
// SetDir ( un , dir ) ;
 902: LD_VAR 0 4
 906: PPUSH
 907: LD_VAR 0 5
 911: PPUSH
 912: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 916: LD_VAR 0 4
 920: PPUSH
 921: LD_VAR 0 2
 925: PPUSH
 926: CALL_OW 52
// end ;
 930: LD_VAR 0 3
 934: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 935: LD_INT 0
 937: PPUSH
 938: PPUSH
 939: PPUSH
// result := false ;
 940: LD_ADDR_VAR 0 2
 944: PUSH
 945: LD_INT 0
 947: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 948: LD_ADDR_VAR 0 3
 952: PUSH
 953: LD_INT 22
 955: PUSH
 956: LD_INT 1
 958: PUSH
 959: EMPTY
 960: LIST
 961: LIST
 962: PUSH
 963: LD_INT 34
 965: PUSH
 966: LD_INT 2
 968: PUSH
 969: EMPTY
 970: LIST
 971: LIST
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: PPUSH
 977: CALL_OW 69
 981: ST_TO_ADDR
// for i in filter do
 982: LD_ADDR_VAR 0 4
 986: PUSH
 987: LD_VAR 0 3
 991: PUSH
 992: FOR_IN
 993: IFFALSE 1024
// if IsDrivenBy ( i ) = unit then
 995: LD_VAR 0 4
 999: PPUSH
1000: CALL_OW 311
1004: PUSH
1005: LD_VAR 0 1
1009: EQUAL
1010: IFFALSE 1022
// begin result := true ;
1012: LD_ADDR_VAR 0 2
1016: PUSH
1017: LD_INT 1
1019: ST_TO_ADDR
// break ;
1020: GO 1024
// end ;
1022: GO 992
1024: POP
1025: POP
// end ;
1026: LD_VAR 0 2
1030: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1031: LD_INT 0
1033: PPUSH
1034: PPUSH
// result := false ;
1035: LD_ADDR_VAR 0 2
1039: PUSH
1040: LD_INT 0
1042: ST_TO_ADDR
// if not blist then
1043: LD_VAR 0 1
1047: NOT
1048: IFFALSE 1052
// exit ;
1050: GO 1096
// for i in blist do
1052: LD_ADDR_VAR 0 3
1056: PUSH
1057: LD_VAR 0 1
1061: PUSH
1062: FOR_IN
1063: IFFALSE 1094
// if UnitsInside ( i ) < 6 then
1065: LD_VAR 0 3
1069: PPUSH
1070: CALL_OW 313
1074: PUSH
1075: LD_INT 6
1077: LESS
1078: IFFALSE 1092
// begin result := i ;
1080: LD_ADDR_VAR 0 2
1084: PUSH
1085: LD_VAR 0 3
1089: ST_TO_ADDR
// break ;
1090: GO 1094
// end ;
1092: GO 1062
1094: POP
1095: POP
// end ;
1096: LD_VAR 0 2
1100: RET
// export function Count ( timer , mode ) ; begin
1101: LD_INT 0
1103: PPUSH
// if not timer then
1104: LD_VAR 0 1
1108: NOT
1109: IFFALSE 1113
// exit ;
1111: GO 1164
// if mode in [ asc , up , + ] then
1113: LD_VAR 0 2
1117: PUSH
1118: LD_STRING asc
1120: PUSH
1121: LD_STRING up
1123: PUSH
1124: LD_STRING +
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: LIST
1131: IN
1132: IFFALSE 1150
// result := timer + 0 0$01 else
1134: LD_ADDR_VAR 0 3
1138: PUSH
1139: LD_VAR 0 1
1143: PUSH
1144: LD_INT 35
1146: PLUS
1147: ST_TO_ADDR
1148: GO 1164
// result := timer - 0 0$01 ;
1150: LD_ADDR_VAR 0 3
1154: PUSH
1155: LD_VAR 0 1
1159: PUSH
1160: LD_INT 35
1162: MINUS
1163: ST_TO_ADDR
// end ; end_of_file
1164: LD_VAR 0 3
1168: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1169: LD_INT 0
1171: PPUSH
1172: PPUSH
1173: PPUSH
1174: PPUSH
1175: PPUSH
1176: PPUSH
1177: PPUSH
1178: PPUSH
// uc_side := 4 ;
1179: LD_ADDR_OWVAR 20
1183: PUSH
1184: LD_INT 4
1186: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1187: LD_ADDR_EXP 43
1191: PUSH
1192: LD_STRING Powell
1194: PPUSH
1195: LD_INT 0
1197: PPUSH
1198: CALL 458 0 2
1202: ST_TO_ADDR
// uc_side := 1 ;
1203: LD_ADDR_OWVAR 20
1207: PUSH
1208: LD_INT 1
1210: ST_TO_ADDR
// uc_nation := 1 ;
1211: LD_ADDR_OWVAR 21
1215: PUSH
1216: LD_INT 1
1218: ST_TO_ADDR
// if debug then
1219: LD_EXP 1
1223: IFFALSE 1353
// begin for i = 1 to 4 do
1225: LD_ADDR_VAR 0 2
1229: PUSH
1230: DOUBLE
1231: LD_INT 1
1233: DEC
1234: ST_TO_ADDR
1235: LD_INT 4
1237: PUSH
1238: FOR_TO
1239: IFFALSE 1290
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1241: LD_INT 0
1243: PPUSH
1244: LD_INT 1
1246: PPUSH
1247: LD_INT 2
1249: PPUSH
1250: CALL_OW 12
1254: PPUSH
1255: LD_INT 3
1257: PPUSH
1258: CALL_OW 380
// un := CreateHuman ;
1262: LD_ADDR_VAR 0 3
1266: PUSH
1267: CALL_OW 44
1271: ST_TO_ADDR
// others := others ^ un ;
1272: LD_ADDR_VAR 0 5
1276: PUSH
1277: LD_VAR 0 5
1281: PUSH
1282: LD_VAR 0 3
1286: ADD
1287: ST_TO_ADDR
// end ;
1288: GO 1238
1290: POP
1291: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1292: LD_ADDR_VAR 0 6
1296: PUSH
1297: LD_INT 21
1299: PUSH
1300: LD_INT 1
1302: PUSH
1303: LD_INT 1
1305: PUSH
1306: LD_INT 51
1308: PUSH
1309: LD_INT 90
1311: PUSH
1312: LD_INT 504
1314: PUSH
1315: EMPTY
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: PUSH
1323: LD_INT 21
1325: PUSH
1326: LD_INT 1
1328: PUSH
1329: LD_INT 1
1331: PUSH
1332: LD_INT 51
1334: PUSH
1335: LD_INT 80
1337: PUSH
1338: LD_INT 750
1340: PUSH
1341: EMPTY
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: PUSH
1349: EMPTY
1350: LIST
1351: LIST
1352: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1353: LD_ADDR_EXP 34
1357: PUSH
1358: LD_STRING JMM
1360: PPUSH
1361: LD_EXP 1
1365: NOT
1366: PPUSH
1367: CALL 458 0 2
1371: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1372: LD_ADDR_EXP 35
1376: PUSH
1377: LD_STRING Bobby
1379: PPUSH
1380: LD_EXP 1
1384: NOT
1385: PPUSH
1386: CALL 458 0 2
1390: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1391: LD_ADDR_EXP 36
1395: PUSH
1396: LD_STRING Cyrus
1398: PPUSH
1399: LD_EXP 1
1403: NOT
1404: PPUSH
1405: CALL 458 0 2
1409: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1410: LD_ADDR_EXP 37
1414: PUSH
1415: LD_STRING Lisa
1417: PPUSH
1418: LD_EXP 1
1422: NOT
1423: PPUSH
1424: CALL 458 0 2
1428: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1429: LD_ADDR_EXP 38
1433: PUSH
1434: LD_STRING Khatam
1436: PPUSH
1437: LD_EXP 1
1441: NOT
1442: PPUSH
1443: CALL 458 0 2
1447: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1448: LD_ADDR_EXP 39
1452: PUSH
1453: LD_STRING Brian
1455: PPUSH
1456: LD_EXP 1
1460: NOT
1461: PPUSH
1462: CALL 458 0 2
1466: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1467: LD_ADDR_EXP 40
1471: PUSH
1472: LD_STRING Jerry
1474: PPUSH
1475: LD_EXP 1
1479: NOT
1480: PPUSH
1481: CALL 458 0 2
1485: ST_TO_ADDR
// if Bobby then
1486: LD_EXP 35
1490: IFFALSE 1521
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1492: LD_ADDR_VAR 0 4
1496: PUSH
1497: LD_VAR 0 4
1501: PPUSH
1502: LD_VAR 0 4
1506: PUSH
1507: LD_INT 1
1509: PLUS
1510: PPUSH
1511: LD_EXP 35
1515: PPUSH
1516: CALL_OW 2
1520: ST_TO_ADDR
// if Cyrus then
1521: LD_EXP 36
1525: IFFALSE 1556
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1527: LD_ADDR_VAR 0 4
1531: PUSH
1532: LD_VAR 0 4
1536: PPUSH
1537: LD_VAR 0 4
1541: PUSH
1542: LD_INT 1
1544: PLUS
1545: PPUSH
1546: LD_EXP 36
1550: PPUSH
1551: CALL_OW 2
1555: ST_TO_ADDR
// if Lisa then
1556: LD_EXP 37
1560: IFFALSE 1591
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1562: LD_ADDR_VAR 0 4
1566: PUSH
1567: LD_VAR 0 4
1571: PPUSH
1572: LD_VAR 0 4
1576: PUSH
1577: LD_INT 1
1579: PLUS
1580: PPUSH
1581: LD_EXP 37
1585: PPUSH
1586: CALL_OW 2
1590: ST_TO_ADDR
// if Khatam then
1591: LD_EXP 38
1595: IFFALSE 1626
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1597: LD_ADDR_VAR 0 4
1601: PUSH
1602: LD_VAR 0 4
1606: PPUSH
1607: LD_VAR 0 4
1611: PUSH
1612: LD_INT 1
1614: PLUS
1615: PPUSH
1616: LD_EXP 38
1620: PPUSH
1621: CALL_OW 2
1625: ST_TO_ADDR
// if Brian then
1626: LD_EXP 39
1630: IFFALSE 1661
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1632: LD_ADDR_VAR 0 4
1636: PUSH
1637: LD_VAR 0 4
1641: PPUSH
1642: LD_VAR 0 4
1646: PUSH
1647: LD_INT 1
1649: PLUS
1650: PPUSH
1651: LD_EXP 39
1655: PPUSH
1656: CALL_OW 2
1660: ST_TO_ADDR
// if Jerry then
1661: LD_EXP 40
1665: IFFALSE 1696
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1667: LD_ADDR_VAR 0 4
1671: PUSH
1672: LD_VAR 0 4
1676: PPUSH
1677: LD_VAR 0 4
1681: PUSH
1682: LD_INT 1
1684: PLUS
1685: PPUSH
1686: LD_EXP 40
1690: PPUSH
1691: CALL_OW 2
1695: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1696: LD_STRING 02_other_survivors
1698: PPUSH
1699: CALL_OW 28
1703: IFFALSE 1718
// others := CreateCharacterSet ( 02_other_survivors ) ;
1705: LD_ADDR_VAR 0 5
1709: PUSH
1710: LD_STRING 02_other_survivors
1712: PPUSH
1713: CALL_OW 31
1717: ST_TO_ADDR
// if others then
1718: LD_VAR 0 5
1722: IFFALSE 1747
// begin tmp := tmp ^ others ;
1724: LD_ADDR_VAR 0 4
1728: PUSH
1729: LD_VAR 0 4
1733: PUSH
1734: LD_VAR 0 5
1738: ADD
1739: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1740: LD_STRING 02_other_survivors
1742: PPUSH
1743: CALL_OW 40
// end ; jmm_units := tmp ;
1747: LD_ADDR_EXP 4
1751: PUSH
1752: LD_VAR 0 4
1756: ST_TO_ADDR
// if not vehicles then
1757: LD_VAR 0 6
1761: NOT
1762: IFFALSE 1780
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1764: LD_ADDR_VAR 0 6
1768: PUSH
1769: LD_STRING 02_tanks_1
1771: PPUSH
1772: LD_INT 0
1774: PPUSH
1775: CALL_OW 30
1779: ST_TO_ADDR
// if vehicles then
1780: LD_VAR 0 6
1784: IFFALSE 1978
// begin got_mech := false ;
1786: LD_ADDR_VAR 0 7
1790: PUSH
1791: LD_INT 0
1793: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1794: LD_VAR 0 4
1798: PPUSH
1799: LD_INT 25
1801: PUSH
1802: LD_INT 3
1804: PUSH
1805: EMPTY
1806: LIST
1807: LIST
1808: PPUSH
1809: CALL_OW 72
1813: IFFALSE 1823
// got_mech := true ;
1815: LD_ADDR_VAR 0 7
1819: PUSH
1820: LD_INT 1
1822: ST_TO_ADDR
// for i = 1 to vehicles do
1823: LD_ADDR_VAR 0 2
1827: PUSH
1828: DOUBLE
1829: LD_INT 1
1831: DEC
1832: ST_TO_ADDR
1833: LD_VAR 0 6
1837: PUSH
1838: FOR_TO
1839: IFFALSE 1976
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1841: LD_ADDR_VAR 0 3
1845: PUSH
1846: LD_INT 1
1848: PPUSH
1849: LD_INT 3
1851: PPUSH
1852: LD_VAR 0 6
1856: PUSH
1857: LD_VAR 0 2
1861: ARRAY
1862: PUSH
1863: LD_INT 1
1865: ARRAY
1866: PPUSH
1867: LD_VAR 0 6
1871: PUSH
1872: LD_VAR 0 2
1876: ARRAY
1877: PUSH
1878: LD_INT 2
1880: ARRAY
1881: PPUSH
1882: LD_VAR 0 6
1886: PUSH
1887: LD_VAR 0 2
1891: ARRAY
1892: PUSH
1893: LD_INT 3
1895: ARRAY
1896: PPUSH
1897: LD_VAR 0 6
1901: PUSH
1902: LD_VAR 0 2
1906: ARRAY
1907: PUSH
1908: LD_INT 4
1910: ARRAY
1911: PPUSH
1912: LD_INT 40
1914: PPUSH
1915: CALL 521 0 7
1919: ST_TO_ADDR
// if not got_mech then
1920: LD_VAR 0 7
1924: NOT
1925: IFFALSE 1951
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1927: LD_VAR 0 3
1931: PPUSH
1932: LD_VAR 0 6
1936: PUSH
1937: LD_VAR 0 2
1941: ARRAY
1942: PUSH
1943: LD_INT 6
1945: ARRAY
1946: PPUSH
1947: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1951: LD_ADDR_VAR 0 4
1955: PUSH
1956: LD_VAR 0 4
1960: PPUSH
1961: LD_INT 1
1963: PPUSH
1964: LD_VAR 0 3
1968: PPUSH
1969: CALL_OW 2
1973: ST_TO_ADDR
// end ;
1974: GO 1838
1976: POP
1977: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1978: LD_EXP 34
1982: PPUSH
1983: LD_INT 194
1985: PPUSH
1986: LD_INT 119
1988: PPUSH
1989: LD_INT 0
1991: PPUSH
1992: CALL_OW 48
// if tmp then
1996: LD_VAR 0 4
2000: IFFALSE 2125
// begin for i in tmp do
2002: LD_ADDR_VAR 0 2
2006: PUSH
2007: LD_VAR 0 4
2011: PUSH
2012: FOR_IN
2013: IFFALSE 2123
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2015: LD_ADDR_VAR 0 8
2019: PUSH
2020: LD_INT 22
2022: PUSH
2023: LD_INT 1
2025: PUSH
2026: EMPTY
2027: LIST
2028: LIST
2029: PUSH
2030: LD_INT 21
2032: PUSH
2033: LD_INT 2
2035: PUSH
2036: EMPTY
2037: LIST
2038: LIST
2039: PUSH
2040: LD_INT 58
2042: PUSH
2043: EMPTY
2044: LIST
2045: PUSH
2046: EMPTY
2047: LIST
2048: LIST
2049: LIST
2050: PPUSH
2051: CALL_OW 69
2055: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2056: LD_VAR 0 2
2060: PPUSH
2061: CALL_OW 247
2065: PUSH
2066: LD_INT 1
2068: EQUAL
2069: PUSH
2070: LD_VAR 0 8
2074: AND
2075: IFFALSE 2097
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2077: LD_VAR 0 2
2081: PPUSH
2082: LD_VAR 0 8
2086: PUSH
2087: LD_INT 1
2089: ARRAY
2090: PPUSH
2091: CALL_OW 52
2095: GO 2112
// PlaceUnitArea ( i , startArea , false ) ;
2097: LD_VAR 0 2
2101: PPUSH
2102: LD_INT 1
2104: PPUSH
2105: LD_INT 0
2107: PPUSH
2108: CALL_OW 49
// ComHold ( i ) ;
2112: LD_VAR 0 2
2116: PPUSH
2117: CALL_OW 140
// end ;
2121: GO 2012
2123: POP
2124: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2125: LD_ADDR_EXP 7
2129: PUSH
2130: LD_STRING 02_mikhailStatus_1
2132: PPUSH
2133: LD_INT 0
2135: PPUSH
2136: CALL_OW 30
2140: ST_TO_ADDR
// if not bierezov_exist and not debug then
2141: LD_EXP 7
2145: NOT
2146: PUSH
2147: LD_EXP 1
2151: NOT
2152: AND
2153: IFFALSE 2157
// exit ;
2155: GO 2188
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2157: LD_ADDR_EXP 42
2161: PUSH
2162: LD_STRING Mikhail
2164: PPUSH
2165: LD_INT 0
2167: PPUSH
2168: CALL 458 0 2
2172: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2173: LD_EXP 42
2177: PPUSH
2178: LD_INT 1
2180: PPUSH
2181: LD_INT 0
2183: PPUSH
2184: CALL_OW 49
// end ;
2188: LD_VAR 0 1
2192: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2193: LD_INT 0
2195: PPUSH
2196: PPUSH
2197: PPUSH
2198: PPUSH
// uc_side := 4 ;
2199: LD_ADDR_OWVAR 20
2203: PUSH
2204: LD_INT 4
2206: ST_TO_ADDR
// uc_nation := 1 ;
2207: LD_ADDR_OWVAR 21
2211: PUSH
2212: LD_INT 1
2214: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2215: LD_ADDR_EXP 41
2219: PUSH
2220: LD_STRING Cornell
2222: PPUSH
2223: LD_INT 0
2225: PPUSH
2226: CALL 458 0 2
2230: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
2231: LD_ADDR_EXP 6
2235: PUSH
2236: LD_INT 8
2238: PUSH
2239: LD_EXP 4
2243: MINUS
2244: ST_TO_ADDR
// tmp := [ ] ;
2245: LD_ADDR_VAR 0 2
2249: PUSH
2250: EMPTY
2251: ST_TO_ADDR
// if cornel_units < 3 then
2252: LD_EXP 6
2256: PUSH
2257: LD_INT 3
2259: LESS
2260: IFFALSE 2270
// cornel_units := 3 ;
2262: LD_ADDR_EXP 6
2266: PUSH
2267: LD_INT 3
2269: ST_TO_ADDR
// for i = 1 to cornel_units do
2270: LD_ADDR_VAR 0 4
2274: PUSH
2275: DOUBLE
2276: LD_INT 1
2278: DEC
2279: ST_TO_ADDR
2280: LD_EXP 6
2284: PUSH
2285: FOR_TO
2286: IFFALSE 2384
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2288: LD_INT 0
2290: PPUSH
2291: LD_INT 1
2293: PUSH
2294: LD_INT 1
2296: PUSH
2297: LD_INT 1
2299: PUSH
2300: LD_INT 2
2302: PUSH
2303: LD_INT 4
2305: PUSH
2306: EMPTY
2307: LIST
2308: LIST
2309: LIST
2310: LIST
2311: LIST
2312: PUSH
2313: LD_VAR 0 4
2317: PUSH
2318: LD_INT 5
2320: MOD
2321: PUSH
2322: LD_INT 1
2324: PLUS
2325: ARRAY
2326: PPUSH
2327: LD_INT 2
2329: PPUSH
2330: CALL_OW 380
// un := CreateHuman ;
2334: LD_ADDR_VAR 0 3
2338: PUSH
2339: CALL_OW 44
2343: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2344: LD_ADDR_VAR 0 2
2348: PUSH
2349: LD_VAR 0 2
2353: PPUSH
2354: LD_INT 1
2356: PPUSH
2357: LD_VAR 0 3
2361: PPUSH
2362: CALL_OW 2
2366: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2367: LD_VAR 0 3
2371: PPUSH
2372: LD_INT 2
2374: PPUSH
2375: LD_INT 0
2377: PPUSH
2378: CALL_OW 49
// end ;
2382: GO 2285
2384: POP
2385: POP
// cornel_units := tmp ;
2386: LD_ADDR_EXP 6
2390: PUSH
2391: LD_VAR 0 2
2395: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2396: LD_EXP 41
2400: PPUSH
2401: LD_INT 191
2403: PPUSH
2404: LD_INT 106
2406: PPUSH
2407: LD_INT 0
2409: PPUSH
2410: CALL_OW 48
// end ;
2414: LD_VAR 0 1
2418: RET
// export function PrepareWesternBase ; var i ; begin
2419: LD_INT 0
2421: PPUSH
2422: PPUSH
// uc_side := 8 ;
2423: LD_ADDR_OWVAR 20
2427: PUSH
2428: LD_INT 8
2430: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2431: LD_ADDR_EXP 44
2435: PUSH
2436: LD_STRING Lynch
2438: PPUSH
2439: LD_INT 0
2441: PPUSH
2442: CALL 458 0 2
2446: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2447: LD_ADDR_EXP 45
2451: PUSH
2452: LD_STRING Walker
2454: PPUSH
2455: LD_INT 0
2457: PPUSH
2458: CALL 458 0 2
2462: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2463: LD_ADDR_EXP 46
2467: PUSH
2468: LD_STRING Turner
2470: PPUSH
2471: LD_INT 0
2473: PPUSH
2474: CALL 458 0 2
2478: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2479: LD_ADDR_EXP 47
2483: PUSH
2484: LD_STRING Jillian
2486: PPUSH
2487: LD_INT 0
2489: PPUSH
2490: CALL 458 0 2
2494: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2495: LD_ADDR_VAR 0 2
2499: PUSH
2500: LD_EXP 44
2504: PUSH
2505: LD_EXP 45
2509: PUSH
2510: LD_EXP 46
2514: PUSH
2515: LD_EXP 47
2519: PUSH
2520: EMPTY
2521: LIST
2522: LIST
2523: LIST
2524: LIST
2525: PUSH
2526: FOR_IN
2527: IFFALSE 2555
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2529: LD_VAR 0 2
2533: PPUSH
2534: LD_INT 3
2536: PPUSH
2537: LD_INT 0
2539: PPUSH
2540: CALL_OW 49
// ComHold ( i ) ;
2544: LD_VAR 0 2
2548: PPUSH
2549: CALL_OW 140
// end ;
2553: GO 2526
2555: POP
2556: POP
// end ;
2557: LD_VAR 0 1
2561: RET
// export function SelectGroup ; var units , selected , i ; begin
2562: LD_INT 0
2564: PPUSH
2565: PPUSH
2566: PPUSH
2567: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2568: LD_ADDR_VAR 0 2
2572: PUSH
2573: LD_EXP 34
2577: PUSH
2578: LD_INT -3
2580: PUSH
2581: EMPTY
2582: LIST
2583: LIST
2584: PUSH
2585: LD_EXP 4
2589: ADD
2590: PUSH
2591: LD_INT -2
2593: PUSH
2594: LD_INT -4
2596: PUSH
2597: LD_EXP 41
2601: PUSH
2602: LD_EXP 42
2606: PUSH
2607: EMPTY
2608: LIST
2609: LIST
2610: LIST
2611: LIST
2612: ADD
2613: PUSH
2614: LD_INT -3
2616: PUSH
2617: EMPTY
2618: LIST
2619: ADD
2620: PUSH
2621: LD_EXP 6
2625: ADD
2626: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2627: LD_ADDR_VAR 0 3
2631: PUSH
2632: LD_EXP 34
2636: PUSH
2637: LD_STRING Select five characters to go with you
2639: PPUSH
2640: LD_INT 4
2642: PPUSH
2643: LD_INT 4
2645: PPUSH
2646: LD_VAR 0 2
2650: PPUSH
2651: EMPTY
2652: PPUSH
2653: CALL_OW 42
2657: ADD
2658: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2659: LD_ADDR_EXP 6
2663: PUSH
2664: LD_EXP 4
2668: PUSH
2669: LD_EXP 6
2673: UNION
2674: PUSH
2675: LD_VAR 0 3
2679: DIFF
2680: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2681: LD_ADDR_VAR 0 4
2685: PUSH
2686: LD_EXP 6
2690: PUSH
2691: LD_EXP 42
2695: ADD
2696: PUSH
2697: FOR_IN
2698: IFFALSE 2729
// if GetSide ( i ) = 1 then
2700: LD_VAR 0 4
2704: PPUSH
2705: CALL_OW 255
2709: PUSH
2710: LD_INT 1
2712: EQUAL
2713: IFFALSE 2727
// SetSide ( i , 4 ) ;
2715: LD_VAR 0 4
2719: PPUSH
2720: LD_INT 4
2722: PPUSH
2723: CALL_OW 235
2727: GO 2697
2729: POP
2730: POP
// for i in selected do
2731: LD_ADDR_VAR 0 4
2735: PUSH
2736: LD_VAR 0 3
2740: PUSH
2741: FOR_IN
2742: IFFALSE 2773
// if GetSide ( i ) = 4 then
2744: LD_VAR 0 4
2748: PPUSH
2749: CALL_OW 255
2753: PUSH
2754: LD_INT 4
2756: EQUAL
2757: IFFALSE 2771
// SetSide ( i , 1 ) ;
2759: LD_VAR 0 4
2763: PPUSH
2764: LD_INT 1
2766: PPUSH
2767: CALL_OW 235
2771: GO 2741
2773: POP
2774: POP
// jmm_units := jmm_units diff cornel_units ;
2775: LD_ADDR_EXP 4
2779: PUSH
2780: LD_EXP 4
2784: PUSH
2785: LD_EXP 6
2789: DIFF
2790: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2791: LD_EXP 35
2795: PPUSH
2796: CALL_OW 255
2800: PUSH
2801: LD_INT 4
2803: EQUAL
2804: IFFALSE 2813
// DeleteCharacters ( Bobby ) ;
2806: LD_STRING Bobby
2808: PPUSH
2809: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2813: LD_EXP 36
2817: PPUSH
2818: CALL_OW 255
2822: PUSH
2823: LD_INT 4
2825: EQUAL
2826: IFFALSE 2835
// DeleteCharacters ( Cyrus ) ;
2828: LD_STRING Cyrus
2830: PPUSH
2831: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2835: LD_EXP 37
2839: PPUSH
2840: CALL_OW 255
2844: PUSH
2845: LD_INT 4
2847: EQUAL
2848: IFFALSE 2857
// DeleteCharacters ( Lisa ) ;
2850: LD_STRING Lisa
2852: PPUSH
2853: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2857: LD_EXP 38
2861: PPUSH
2862: CALL_OW 255
2866: PUSH
2867: LD_INT 4
2869: EQUAL
2870: IFFALSE 2879
// DeleteCharacters ( Khatam ) ;
2872: LD_STRING Khatam
2874: PPUSH
2875: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2879: LD_EXP 39
2883: PPUSH
2884: CALL_OW 255
2888: PUSH
2889: LD_INT 4
2891: EQUAL
2892: IFFALSE 2901
// DeleteCharacters ( Brian ) ;
2894: LD_STRING Brian
2896: PPUSH
2897: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2901: LD_EXP 40
2905: PPUSH
2906: CALL_OW 255
2910: PUSH
2911: LD_INT 4
2913: EQUAL
2914: IFFALSE 2923
// DeleteCharacters ( Jerry ) ;
2916: LD_STRING Jerry
2918: PPUSH
2919: CALL_OW 40
// end ; end_of_file
2923: LD_VAR 0 1
2927: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
2928: LD_INT 0
2930: PPUSH
2931: PPUSH
2932: PPUSH
2933: PPUSH
2934: PPUSH
2935: PPUSH
2936: PPUSH
2937: PPUSH
2938: PPUSH
2939: PPUSH
2940: PPUSH
2941: PPUSH
2942: PPUSH
// ru_alert := false ;
2943: LD_ADDR_EXP 57
2947: PUSH
2948: LD_INT 0
2950: ST_TO_ADDR
// ru_produce_list := [ ] ;
2951: LD_ADDR_EXP 54
2955: PUSH
2956: EMPTY
2957: ST_TO_ADDR
// if Difficulty > 1 then
2958: LD_OWVAR 67
2962: PUSH
2963: LD_INT 1
2965: GREATER
2966: IFFALSE 3054
// begin uc_side := 3 ;
2968: LD_ADDR_OWVAR 20
2972: PUSH
2973: LD_INT 3
2975: ST_TO_ADDR
// uc_nation := 3 ;
2976: LD_ADDR_OWVAR 21
2980: PUSH
2981: LD_INT 3
2983: ST_TO_ADDR
// bc_type := b_breastwork ;
2984: LD_ADDR_OWVAR 42
2988: PUSH
2989: LD_INT 31
2991: ST_TO_ADDR
// bc_level := Difficulty ;
2992: LD_ADDR_OWVAR 43
2996: PUSH
2997: LD_OWVAR 67
3001: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3002: LD_INT 22
3004: PPUSH
3005: LD_INT 14
3007: PPUSH
3008: LD_INT 0
3010: PPUSH
3011: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3015: LD_INT 48
3017: PPUSH
3018: LD_INT 46
3020: PPUSH
3021: LD_INT 0
3023: PPUSH
3024: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3028: LD_INT 86
3030: PPUSH
3031: LD_INT 65
3033: PPUSH
3034: LD_INT 5
3036: PPUSH
3037: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3041: LD_INT 165
3043: PPUSH
3044: LD_INT 73
3046: PPUSH
3047: LD_INT 5
3049: PPUSH
3050: CALL_OW 47
// end ; tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3054: LD_ADDR_VAR 0 7
3058: PUSH
3059: LD_INT 22
3061: PUSH
3062: LD_INT 3
3064: PUSH
3065: EMPTY
3066: LIST
3067: LIST
3068: PUSH
3069: LD_INT 2
3071: PUSH
3072: LD_INT 30
3074: PUSH
3075: LD_INT 31
3077: PUSH
3078: EMPTY
3079: LIST
3080: LIST
3081: PUSH
3082: LD_INT 30
3084: PUSH
3085: LD_INT 32
3087: PUSH
3088: EMPTY
3089: LIST
3090: LIST
3091: PUSH
3092: EMPTY
3093: LIST
3094: LIST
3095: LIST
3096: PUSH
3097: EMPTY
3098: LIST
3099: LIST
3100: PPUSH
3101: CALL_OW 69
3105: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3106: LD_ADDR_VAR 0 8
3110: PUSH
3111: LD_INT 22
3113: PUSH
3114: LD_INT 3
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: PUSH
3121: LD_INT 30
3123: PUSH
3124: LD_INT 4
3126: PUSH
3127: EMPTY
3128: LIST
3129: LIST
3130: PUSH
3131: EMPTY
3132: LIST
3133: LIST
3134: PPUSH
3135: CALL_OW 69
3139: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3140: LD_ADDR_VAR 0 10
3144: PUSH
3145: LD_INT 22
3147: PUSH
3148: LD_INT 3
3150: PUSH
3151: EMPTY
3152: LIST
3153: LIST
3154: PUSH
3155: LD_INT 30
3157: PUSH
3158: LD_INT 3
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: PUSH
3165: EMPTY
3166: LIST
3167: LIST
3168: PPUSH
3169: CALL_OW 69
3173: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3174: LD_ADDR_VAR 0 9
3178: PUSH
3179: LD_INT 22
3181: PUSH
3182: LD_INT 3
3184: PUSH
3185: EMPTY
3186: LIST
3187: LIST
3188: PUSH
3189: LD_INT 30
3191: PUSH
3192: LD_INT 6
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: PUSH
3199: EMPTY
3200: LIST
3201: LIST
3202: PPUSH
3203: CALL_OW 69
3207: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3208: LD_ADDR_VAR 0 2
3212: PUSH
3213: LD_INT 22
3215: PUSH
3216: LD_INT 3
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: PUSH
3223: LD_INT 30
3225: PUSH
3226: LD_INT 1
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: PPUSH
3237: CALL_OW 69
3241: PUSH
3242: FOR_IN
3243: IFFALSE 3287
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3245: LD_VAR 0 2
3249: PPUSH
3250: CALL_OW 274
3254: PPUSH
3255: LD_INT 1
3257: PPUSH
3258: LD_INT 5000
3260: PPUSH
3261: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3265: LD_VAR 0 2
3269: PPUSH
3270: CALL_OW 274
3274: PPUSH
3275: LD_INT 2
3277: PPUSH
3278: LD_INT 3000
3280: PPUSH
3281: CALL_OW 277
// end ;
3285: GO 3242
3287: POP
3288: POP
// uc_side := 3 ;
3289: LD_ADDR_OWVAR 20
3293: PUSH
3294: LD_INT 3
3296: ST_TO_ADDR
// uc_nation := 3 ;
3297: LD_ADDR_OWVAR 21
3301: PUSH
3302: LD_INT 3
3304: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3305: LD_ADDR_VAR 0 11
3309: PUSH
3310: LD_INT 2
3312: PUSH
3313: LD_INT 3
3315: PUSH
3316: LD_INT 4
3318: PUSH
3319: EMPTY
3320: LIST
3321: LIST
3322: LIST
3323: PUSH
3324: LD_OWVAR 67
3328: ARRAY
3329: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3330: LD_ADDR_EXP 49
3334: PUSH
3335: LD_STRING Pokryshkin
3337: PPUSH
3338: LD_INT 0
3340: PPUSH
3341: CALL 458 0 2
3345: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3346: LD_EXP 49
3350: PPUSH
3351: LD_INT 63
3353: PPUSH
3354: LD_INT 21
3356: PPUSH
3357: LD_INT 0
3359: PPUSH
3360: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3364: LD_EXP 49
3368: PPUSH
3369: CALL_OW 140
// InitHc ;
3373: CALL_OW 19
// for i in fac do
3377: LD_ADDR_VAR 0 2
3381: PUSH
3382: LD_VAR 0 10
3386: PUSH
3387: FOR_IN
3388: IFFALSE 3441
// begin for j = 1 to 6 do
3390: LD_ADDR_VAR 0 3
3394: PUSH
3395: DOUBLE
3396: LD_INT 1
3398: DEC
3399: ST_TO_ADDR
3400: LD_INT 6
3402: PUSH
3403: FOR_TO
3404: IFFALSE 3437
// begin PrepareHuman ( false , 3 , skill ) ;
3406: LD_INT 0
3408: PPUSH
3409: LD_INT 3
3411: PPUSH
3412: LD_VAR 0 11
3416: PPUSH
3417: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3421: CALL_OW 44
3425: PPUSH
3426: LD_VAR 0 2
3430: PPUSH
3431: CALL_OW 52
// end ;
3435: GO 3403
3437: POP
3438: POP
// end ;
3439: GO 3387
3441: POP
3442: POP
// for i in lab do
3443: LD_ADDR_VAR 0 2
3447: PUSH
3448: LD_VAR 0 9
3452: PUSH
3453: FOR_IN
3454: IFFALSE 3487
// begin PrepareHuman ( false , 4 , skill ) ;
3456: LD_INT 0
3458: PPUSH
3459: LD_INT 4
3461: PPUSH
3462: LD_VAR 0 11
3466: PPUSH
3467: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3471: CALL_OW 44
3475: PPUSH
3476: LD_VAR 0 2
3480: PPUSH
3481: CALL_OW 52
// end ;
3485: GO 3453
3487: POP
3488: POP
// for i in tw do
3489: LD_ADDR_VAR 0 2
3493: PUSH
3494: LD_VAR 0 7
3498: PUSH
3499: FOR_IN
3500: IFFALSE 3549
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3502: LD_VAR 0 2
3506: PPUSH
3507: LD_INT 42
3509: PUSH
3510: LD_INT 43
3512: PUSH
3513: EMPTY
3514: LIST
3515: LIST
3516: PUSH
3517: LD_INT 1
3519: PPUSH
3520: LD_INT 2
3522: PPUSH
3523: CALL_OW 12
3527: ARRAY
3528: PPUSH
3529: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3533: LD_VAR 0 11
3537: PPUSH
3538: LD_VAR 0 2
3542: PPUSH
3543: CALL 799 0 2
// end ;
3547: GO 3499
3549: POP
3550: POP
// for i in bar do
3551: LD_ADDR_VAR 0 2
3555: PUSH
3556: LD_VAR 0 8
3560: PUSH
3561: FOR_IN
3562: IFFALSE 3595
// begin PrepareHuman ( false , 1 , skill ) ;
3564: LD_INT 0
3566: PPUSH
3567: LD_INT 1
3569: PPUSH
3570: LD_VAR 0 11
3574: PPUSH
3575: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3579: CALL_OW 44
3583: PPUSH
3584: LD_VAR 0 2
3588: PPUSH
3589: CALL_OW 52
// end ;
3593: GO 3561
3595: POP
3596: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3597: LD_ADDR_VAR 0 13
3601: PUSH
3602: LD_INT 100
3604: PUSH
3605: LD_INT 9
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: PUSH
3612: LD_INT 135
3614: PUSH
3615: LD_INT 60
3617: PUSH
3618: EMPTY
3619: LIST
3620: LIST
3621: PUSH
3622: LD_INT 41
3624: PUSH
3625: LD_INT 6
3627: PUSH
3628: EMPTY
3629: LIST
3630: LIST
3631: PUSH
3632: LD_INT 22
3634: PUSH
3635: LD_INT 9
3637: PUSH
3638: EMPTY
3639: LIST
3640: LIST
3641: PUSH
3642: LD_INT 84
3644: PUSH
3645: LD_INT 14
3647: PUSH
3648: EMPTY
3649: LIST
3650: LIST
3651: PUSH
3652: EMPTY
3653: LIST
3654: LIST
3655: LIST
3656: LIST
3657: LIST
3658: ST_TO_ADDR
// vehicles := [ ] ;
3659: LD_ADDR_VAR 0 12
3663: PUSH
3664: EMPTY
3665: ST_TO_ADDR
// for i in spot_xy do
3666: LD_ADDR_VAR 0 2
3670: PUSH
3671: LD_VAR 0 13
3675: PUSH
3676: FOR_IN
3677: IFFALSE 3835
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3679: LD_ADDR_VAR 0 6
3683: PUSH
3684: LD_INT 3
3686: PPUSH
3687: LD_INT 3
3689: PPUSH
3690: LD_INT 22
3692: PPUSH
3693: LD_INT 1
3695: PPUSH
3696: LD_INT 1
3698: PPUSH
3699: LD_INT 42
3701: PUSH
3702: LD_INT 43
3704: PUSH
3705: LD_INT 44
3707: PUSH
3708: EMPTY
3709: LIST
3710: LIST
3711: LIST
3712: PUSH
3713: LD_INT 1
3715: PPUSH
3716: LD_INT 3
3718: PPUSH
3719: CALL_OW 12
3723: ARRAY
3724: PPUSH
3725: LD_INT 100
3727: PPUSH
3728: CALL 521 0 7
3732: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3733: LD_ADDR_VAR 0 12
3737: PUSH
3738: LD_VAR 0 12
3742: PPUSH
3743: LD_VAR 0 12
3747: PUSH
3748: LD_INT 1
3750: PLUS
3751: PPUSH
3752: LD_VAR 0 6
3756: PPUSH
3757: CALL_OW 2
3761: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3762: LD_VAR 0 6
3766: PPUSH
3767: LD_INT 3
3769: PPUSH
3770: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3774: LD_VAR 0 6
3778: PPUSH
3779: LD_VAR 0 2
3783: PUSH
3784: LD_INT 1
3786: ARRAY
3787: PPUSH
3788: LD_VAR 0 2
3792: PUSH
3793: LD_INT 2
3795: ARRAY
3796: PPUSH
3797: LD_INT 0
3799: PPUSH
3800: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3804: LD_INT 0
3806: PPUSH
3807: LD_INT 3
3809: PPUSH
3810: LD_VAR 0 11
3814: PPUSH
3815: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3819: CALL_OW 44
3823: PPUSH
3824: LD_VAR 0 6
3828: PPUSH
3829: CALL_OW 52
// end ;
3833: GO 3676
3835: POP
3836: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3837: LD_ADDR_VAR 0 2
3841: PUSH
3842: DOUBLE
3843: LD_INT 1
3845: DEC
3846: ST_TO_ADDR
3847: LD_INT 5
3849: PUSH
3850: LD_INT 7
3852: PUSH
3853: LD_INT 8
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: LIST
3860: PUSH
3861: LD_OWVAR 67
3865: ARRAY
3866: PUSH
3867: FOR_TO
3868: IFFALSE 3928
// begin PrepareHuman ( false , 1 , skill ) ;
3870: LD_INT 0
3872: PPUSH
3873: LD_INT 1
3875: PPUSH
3876: LD_VAR 0 11
3880: PPUSH
3881: CALL_OW 380
// un := CreateHuman ;
3885: LD_ADDR_VAR 0 5
3889: PUSH
3890: CALL_OW 44
3894: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3895: LD_VAR 0 5
3899: PPUSH
3900: LD_INT 11
3902: PPUSH
3903: LD_INT 0
3905: PPUSH
3906: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3910: LD_ADDR_EXP 52
3914: PUSH
3915: LD_EXP 52
3919: PUSH
3920: LD_VAR 0 5
3924: ADD
3925: ST_TO_ADDR
// end ;
3926: GO 3867
3928: POP
3929: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3930: LD_ADDR_VAR 0 2
3934: PUSH
3935: DOUBLE
3936: LD_INT 1
3938: DEC
3939: ST_TO_ADDR
3940: LD_INT 2
3942: PUSH
3943: LD_INT 3
3945: PUSH
3946: LD_INT 4
3948: PUSH
3949: EMPTY
3950: LIST
3951: LIST
3952: LIST
3953: PUSH
3954: LD_OWVAR 67
3958: ARRAY
3959: PUSH
3960: FOR_TO
3961: IFFALSE 4021
// begin PrepareHuman ( false , 1 , skill ) ;
3963: LD_INT 0
3965: PPUSH
3966: LD_INT 1
3968: PPUSH
3969: LD_VAR 0 11
3973: PPUSH
3974: CALL_OW 380
// un := CreateHuman ;
3978: LD_ADDR_VAR 0 5
3982: PUSH
3983: CALL_OW 44
3987: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
3988: LD_VAR 0 5
3992: PPUSH
3993: LD_INT 12
3995: PPUSH
3996: LD_INT 0
3998: PPUSH
3999: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4003: LD_ADDR_EXP 50
4007: PUSH
4008: LD_EXP 50
4012: PUSH
4013: LD_VAR 0 5
4017: ADD
4018: ST_TO_ADDR
// end ;
4019: GO 3960
4021: POP
4022: POP
// for i = 1 to 2 do
4023: LD_ADDR_VAR 0 2
4027: PUSH
4028: DOUBLE
4029: LD_INT 1
4031: DEC
4032: ST_TO_ADDR
4033: LD_INT 2
4035: PUSH
4036: FOR_TO
4037: IFFALSE 4103
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4039: LD_INT 1
4041: PPUSH
4042: LD_INT 1
4044: PPUSH
4045: LD_VAR 0 11
4049: PPUSH
4050: CALL_OW 380
// un := CreateHuman ;
4054: LD_ADDR_VAR 0 5
4058: PUSH
4059: CALL_OW 44
4063: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4064: LD_VAR 0 5
4068: PPUSH
4069: LD_INT 39
4071: PPUSH
4072: LD_INT 12
4074: PPUSH
4075: LD_INT 3
4077: PPUSH
4078: LD_INT 0
4080: PPUSH
4081: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4085: LD_ADDR_EXP 51
4089: PUSH
4090: LD_EXP 51
4094: PUSH
4095: LD_VAR 0 5
4099: ADD
4100: ST_TO_ADDR
// end ;
4101: GO 4036
4103: POP
4104: POP
// for i = 1 to 3 do
4105: LD_ADDR_VAR 0 2
4109: PUSH
4110: DOUBLE
4111: LD_INT 1
4113: DEC
4114: ST_TO_ADDR
4115: LD_INT 3
4117: PUSH
4118: FOR_TO
4119: IFFALSE 4185
// begin PrepareHuman ( false , 1 , skill ) ;
4121: LD_INT 0
4123: PPUSH
4124: LD_INT 1
4126: PPUSH
4127: LD_VAR 0 11
4131: PPUSH
4132: CALL_OW 380
// un := CreateHuman ;
4136: LD_ADDR_VAR 0 5
4140: PUSH
4141: CALL_OW 44
4145: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4146: LD_VAR 0 5
4150: PPUSH
4151: LD_INT 180
4153: PPUSH
4154: LD_INT 11
4156: PPUSH
4157: LD_INT 4
4159: PPUSH
4160: LD_INT 0
4162: PPUSH
4163: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4167: LD_ADDR_EXP 55
4171: PUSH
4172: LD_EXP 55
4176: PUSH
4177: LD_VAR 0 5
4181: ADD
4182: ST_TO_ADDR
// end ;
4183: GO 4118
4185: POP
4186: POP
// ru_vehicles := vehicles ;
4187: LD_ADDR_EXP 53
4191: PUSH
4192: LD_VAR 0 12
4196: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4197: LD_ADDR_EXP 56
4201: PUSH
4202: LD_INT 131
4204: PUSH
4205: LD_INT 121
4207: PUSH
4208: EMPTY
4209: LIST
4210: LIST
4211: PUSH
4212: LD_INT 113
4214: PUSH
4215: LD_INT 90
4217: PUSH
4218: EMPTY
4219: LIST
4220: LIST
4221: PUSH
4222: LD_INT 93
4224: PUSH
4225: LD_INT 62
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PUSH
4232: EMPTY
4233: LIST
4234: LIST
4235: LIST
4236: PUSH
4237: LD_INT 106
4239: PUSH
4240: LD_INT 54
4242: PUSH
4243: EMPTY
4244: LIST
4245: LIST
4246: PUSH
4247: LD_INT 120
4249: PUSH
4250: LD_INT 80
4252: PUSH
4253: EMPTY
4254: LIST
4255: LIST
4256: PUSH
4257: LD_INT 143
4259: PUSH
4260: LD_INT 120
4262: PUSH
4263: EMPTY
4264: LIST
4265: LIST
4266: PUSH
4267: EMPTY
4268: LIST
4269: LIST
4270: LIST
4271: PUSH
4272: LD_INT 154
4274: PUSH
4275: LD_INT 116
4277: PUSH
4278: EMPTY
4279: LIST
4280: LIST
4281: PUSH
4282: LD_INT 140
4284: PUSH
4285: LD_INT 93
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: PUSH
4292: LD_INT 130
4294: PUSH
4295: LD_INT 58
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: PUSH
4302: EMPTY
4303: LIST
4304: LIST
4305: LIST
4306: PUSH
4307: LD_INT 105
4309: PUSH
4310: LD_INT 106
4312: PUSH
4313: EMPTY
4314: LIST
4315: LIST
4316: PUSH
4317: LD_INT 134
4319: PUSH
4320: LD_INT 98
4322: PUSH
4323: EMPTY
4324: LIST
4325: LIST
4326: PUSH
4327: LD_INT 159
4329: PUSH
4330: LD_INT 113
4332: PUSH
4333: EMPTY
4334: LIST
4335: LIST
4336: PUSH
4337: EMPTY
4338: LIST
4339: LIST
4340: LIST
4341: PUSH
4342: EMPTY
4343: LIST
4344: LIST
4345: LIST
4346: LIST
4347: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4348: LD_ADDR_VAR 0 2
4352: PUSH
4353: DOUBLE
4354: LD_INT 1
4356: DEC
4357: ST_TO_ADDR
4358: LD_OWVAR 67
4362: PUSH
4363: LD_INT 1
4365: MINUS
4366: PUSH
4367: FOR_TO
4368: IFFALSE 4401
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4370: LD_ADDR_EXP 54
4374: PUSH
4375: LD_EXP 54
4379: PUSH
4380: LD_INT 22
4382: PUSH
4383: LD_INT 1
4385: PUSH
4386: LD_INT 1
4388: PUSH
4389: LD_INT 43
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: LIST
4396: LIST
4397: ADD
4398: ST_TO_ADDR
4399: GO 4367
4401: POP
4402: POP
// end ;
4403: LD_VAR 0 1
4407: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4408: LD_INT 22
4410: PUSH
4411: LD_INT 3
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: PUSH
4418: LD_INT 21
4420: PUSH
4421: LD_INT 2
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: PPUSH
4432: CALL_OW 69
4436: IFFALSE 4530
4438: GO 4440
4440: DISABLE
4441: LD_INT 0
4443: PPUSH
4444: PPUSH
// begin enable ;
4445: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4446: LD_ADDR_VAR 0 2
4450: PUSH
4451: LD_INT 22
4453: PUSH
4454: LD_INT 3
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: PUSH
4461: LD_INT 21
4463: PUSH
4464: LD_INT 2
4466: PUSH
4467: EMPTY
4468: LIST
4469: LIST
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: PPUSH
4475: CALL_OW 69
4479: ST_TO_ADDR
// if filter then
4480: LD_VAR 0 2
4484: IFFALSE 4530
// for i in filter do
4486: LD_ADDR_VAR 0 1
4490: PUSH
4491: LD_VAR 0 2
4495: PUSH
4496: FOR_IN
4497: IFFALSE 4528
// if GetFuel ( i ) < 20 then
4499: LD_VAR 0 1
4503: PPUSH
4504: CALL_OW 261
4508: PUSH
4509: LD_INT 20
4511: LESS
4512: IFFALSE 4526
// SetFuel ( i , 20 ) ;
4514: LD_VAR 0 1
4518: PPUSH
4519: LD_INT 20
4521: PPUSH
4522: CALL_OW 240
4526: GO 4496
4528: POP
4529: POP
// end ;
4530: PPOPN 2
4532: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4533: LD_EXP 54
4537: IFFALSE 4756
4539: GO 4541
4541: DISABLE
4542: LD_INT 0
4544: PPUSH
4545: PPUSH
4546: PPUSH
// begin enable ;
4547: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4548: LD_ADDR_VAR 0 2
4552: PUSH
4553: LD_INT 22
4555: PUSH
4556: LD_INT 3
4558: PUSH
4559: EMPTY
4560: LIST
4561: LIST
4562: PUSH
4563: LD_INT 30
4565: PUSH
4566: LD_INT 3
4568: PUSH
4569: EMPTY
4570: LIST
4571: LIST
4572: PUSH
4573: EMPTY
4574: LIST
4575: LIST
4576: PPUSH
4577: CALL_OW 69
4581: ST_TO_ADDR
// can_produce := [ ] ;
4582: LD_ADDR_VAR 0 3
4586: PUSH
4587: EMPTY
4588: ST_TO_ADDR
// if not fac then
4589: LD_VAR 0 2
4593: NOT
4594: IFFALSE 4599
// begin disable ;
4596: DISABLE
// exit ;
4597: GO 4756
// end ; for i in fac do
4599: LD_ADDR_VAR 0 1
4603: PUSH
4604: LD_VAR 0 2
4608: PUSH
4609: FOR_IN
4610: IFFALSE 4648
// if UnitsInside ( i ) then
4612: LD_VAR 0 1
4616: PPUSH
4617: CALL_OW 313
4621: IFFALSE 4646
// can_produce := Insert ( can_produce , 1 , i ) ;
4623: LD_ADDR_VAR 0 3
4627: PUSH
4628: LD_VAR 0 3
4632: PPUSH
4633: LD_INT 1
4635: PPUSH
4636: LD_VAR 0 1
4640: PPUSH
4641: CALL_OW 2
4645: ST_TO_ADDR
4646: GO 4609
4648: POP
4649: POP
// if not can_produce then
4650: LD_VAR 0 3
4654: NOT
4655: IFFALSE 4659
// exit ;
4657: GO 4756
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4659: LD_VAR 0 3
4663: PUSH
4664: LD_INT 1
4666: PPUSH
4667: LD_VAR 0 3
4671: PPUSH
4672: CALL_OW 12
4676: ARRAY
4677: PPUSH
4678: LD_EXP 54
4682: PUSH
4683: LD_INT 1
4685: ARRAY
4686: PPUSH
4687: LD_EXP 54
4691: PUSH
4692: LD_INT 2
4694: ARRAY
4695: PPUSH
4696: LD_EXP 54
4700: PUSH
4701: LD_INT 3
4703: ARRAY
4704: PPUSH
4705: LD_EXP 54
4709: PUSH
4710: LD_INT 4
4712: ARRAY
4713: PPUSH
4714: CALL_OW 125
// for i = 1 to 4 do
4718: LD_ADDR_VAR 0 1
4722: PUSH
4723: DOUBLE
4724: LD_INT 1
4726: DEC
4727: ST_TO_ADDR
4728: LD_INT 4
4730: PUSH
4731: FOR_TO
4732: IFFALSE 4754
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4734: LD_ADDR_EXP 54
4738: PUSH
4739: LD_EXP 54
4743: PPUSH
4744: LD_INT 1
4746: PPUSH
4747: CALL_OW 3
4751: ST_TO_ADDR
4752: GO 4731
4754: POP
4755: POP
// end ;
4756: PPOPN 3
4758: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4759: LD_INT 0
4761: PPUSH
4762: PPUSH
4763: PPUSH
// for i = 1 to 6 do
4764: LD_ADDR_VAR 0 2
4768: PUSH
4769: DOUBLE
4770: LD_INT 1
4772: DEC
4773: ST_TO_ADDR
4774: LD_INT 6
4776: PUSH
4777: FOR_TO
4778: IFFALSE 4927
// begin PrepareHuman ( false , 3 , 3 ) ;
4780: LD_INT 0
4782: PPUSH
4783: LD_INT 3
4785: PPUSH
4786: LD_INT 3
4788: PPUSH
4789: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4793: LD_ADDR_VAR 0 3
4797: PUSH
4798: LD_INT 3
4800: PPUSH
4801: LD_INT 3
4803: PPUSH
4804: LD_INT 22
4806: PPUSH
4807: LD_INT 1
4809: PPUSH
4810: LD_INT 1
4812: PPUSH
4813: LD_INT 43
4815: PUSH
4816: LD_INT 42
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: LD_INT 1
4825: PPUSH
4826: LD_INT 2
4828: PPUSH
4829: CALL_OW 12
4833: ARRAY
4834: PPUSH
4835: LD_INT 70
4837: PPUSH
4838: CALL 521 0 7
4842: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4843: LD_VAR 0 3
4847: PPUSH
4848: LD_INT 4
4850: PPUSH
4851: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4855: LD_VAR 0 3
4859: PPUSH
4860: LD_INT 229
4862: PPUSH
4863: LD_INT 44
4865: PPUSH
4866: LD_INT 0
4868: PPUSH
4869: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4873: CALL_OW 44
4877: PPUSH
4878: LD_VAR 0 3
4882: PPUSH
4883: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4887: LD_ADDR_EXP 53
4891: PUSH
4892: LD_EXP 53
4896: PUSH
4897: LD_VAR 0 3
4901: ADD
4902: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
4903: LD_VAR 0 3
4907: PPUSH
4908: LD_INT 191
4910: PPUSH
4911: LD_INT 32
4913: PPUSH
4914: CALL_OW 111
// Wait ( 0 0$02 ) ;
4918: LD_INT 70
4920: PPUSH
4921: CALL_OW 67
// end ;
4925: GO 4777
4927: POP
4928: POP
// end ; end_of_file
4929: LD_VAR 0 1
4933: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
4934: LD_INT 0
4936: PPUSH
4937: PPUSH
4938: PPUSH
4939: PPUSH
4940: PPUSH
4941: PPUSH
4942: PPUSH
// InGameOn ;
4943: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
4947: LD_EXP 34
4951: PPUSH
4952: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
4956: LD_EXP 34
4960: PPUSH
4961: LD_EXP 41
4965: PPUSH
4966: CALL_OW 119
// if Bierezov then
4970: LD_EXP 42
4974: IFFALSE 4990
// ComTurnUnit ( Bierezov , Cornel ) ;
4976: LD_EXP 42
4980: PPUSH
4981: LD_EXP 41
4985: PPUSH
4986: CALL_OW 119
// for i in jmm_units do
4990: LD_ADDR_VAR 0 2
4994: PUSH
4995: LD_EXP 4
4999: PUSH
5000: FOR_IN
5001: IFFALSE 5019
// ComTurnUnit ( i , Cornel ) ;
5003: LD_VAR 0 2
5007: PPUSH
5008: LD_EXP 41
5012: PPUSH
5013: CALL_OW 119
5017: GO 5000
5019: POP
5020: POP
// units := cornel_units union Cornel ;
5021: LD_ADDR_VAR 0 3
5025: PUSH
5026: LD_EXP 6
5030: PUSH
5031: LD_EXP 41
5035: UNION
5036: ST_TO_ADDR
// repeat wait ( 1 ) ;
5037: LD_INT 1
5039: PPUSH
5040: CALL_OW 67
// for i in units do
5044: LD_ADDR_VAR 0 2
5048: PUSH
5049: LD_VAR 0 3
5053: PUSH
5054: FOR_IN
5055: IFFALSE 5088
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5057: LD_VAR 0 2
5061: PPUSH
5062: LD_EXP 34
5066: PPUSH
5067: CALL_OW 250
5071: PPUSH
5072: LD_EXP 34
5076: PPUSH
5077: CALL_OW 251
5081: PPUSH
5082: CALL_OW 111
5086: GO 5054
5088: POP
5089: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5090: LD_VAR 0 3
5094: PPUSH
5095: LD_INT 92
5097: PUSH
5098: LD_EXP 34
5102: PPUSH
5103: CALL_OW 250
5107: PUSH
5108: LD_EXP 34
5112: PPUSH
5113: CALL_OW 251
5117: PUSH
5118: LD_INT 10
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: LIST
5125: LIST
5126: PPUSH
5127: CALL_OW 72
5131: PUSH
5132: LD_VAR 0 3
5136: EQUAL
5137: IFFALSE 5037
// for i in units do
5139: LD_ADDR_VAR 0 2
5143: PUSH
5144: LD_VAR 0 3
5148: PUSH
5149: FOR_IN
5150: IFFALSE 5168
// ComTurnUnit ( i , JMM ) ;
5152: LD_VAR 0 2
5156: PPUSH
5157: LD_EXP 34
5161: PPUSH
5162: CALL_OW 119
5166: GO 5149
5168: POP
5169: POP
// ComTurnUnit ( Cornel , JMM ) ;
5170: LD_EXP 41
5174: PPUSH
5175: LD_EXP 34
5179: PPUSH
5180: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5184: LD_EXP 34
5188: PPUSH
5189: LD_STRING D1-JMM-1
5191: PPUSH
5192: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5196: LD_EXP 41
5200: PPUSH
5201: LD_STRING D1-Corn-1
5203: PPUSH
5204: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5208: LD_EXP 34
5212: PPUSH
5213: LD_EXP 41
5217: PPUSH
5218: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5222: LD_EXP 41
5226: PPUSH
5227: LD_EXP 34
5231: PPUSH
5232: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5236: LD_INT 35
5238: PPUSH
5239: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5243: LD_EXP 34
5247: PPUSH
5248: LD_EXP 41
5252: PPUSH
5253: CALL_OW 296
5257: PUSH
5258: LD_INT 6
5260: LESS
5261: IFFALSE 5236
// ChangeSideFog ( 4 , 1 ) ;
5263: LD_INT 4
5265: PPUSH
5266: LD_INT 1
5268: PPUSH
5269: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5273: LD_EXP 34
5277: PPUSH
5278: LD_EXP 41
5282: PPUSH
5283: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5287: LD_EXP 41
5291: PPUSH
5292: LD_EXP 34
5296: PPUSH
5297: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5301: LD_EXP 34
5305: PPUSH
5306: LD_STRING D1-JMM-2
5308: PPUSH
5309: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5313: LD_EXP 34
5317: PPUSH
5318: LD_STRING D1-JMM-2a
5320: PPUSH
5321: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5325: LD_EXP 41
5329: PPUSH
5330: LD_STRING D1-Corn-2
5332: PPUSH
5333: CALL_OW 88
// if bierezov_exist or debug then
5337: LD_EXP 7
5341: PUSH
5342: LD_EXP 1
5346: OR
5347: IFFALSE 5588
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5349: LD_EXP 41
5353: PPUSH
5354: LD_EXP 42
5358: PPUSH
5359: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5363: LD_INT 10
5365: PPUSH
5366: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5370: LD_EXP 41
5374: PPUSH
5375: LD_STRING D1a-Corn-1
5377: PPUSH
5378: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5382: LD_EXP 34
5386: PPUSH
5387: LD_EXP 42
5391: PPUSH
5392: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5396: LD_EXP 42
5400: PPUSH
5401: LD_EXP 34
5405: PPUSH
5406: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5410: LD_EXP 34
5414: PPUSH
5415: LD_STRING D1a-JMM-1
5417: PPUSH
5418: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5422: LD_EXP 34
5426: PPUSH
5427: LD_EXP 41
5431: PPUSH
5432: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5436: LD_EXP 41
5440: PPUSH
5441: LD_EXP 34
5445: PPUSH
5446: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5450: LD_EXP 41
5454: PPUSH
5455: LD_STRING D1a-Corn-2
5457: PPUSH
5458: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5462: LD_EXP 34
5466: PPUSH
5467: LD_STRING D1a-JMM-2
5469: PPUSH
5470: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5474: LD_EXP 41
5478: PPUSH
5479: LD_STRING D1a-Corn-3
5481: PPUSH
5482: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5486: LD_EXP 34
5490: PPUSH
5491: LD_STRING D1a-JMM-3
5493: PPUSH
5494: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5498: LD_EXP 41
5502: PPUSH
5503: LD_STRING D1a-Corn-4
5505: PPUSH
5506: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5510: LD_EXP 34
5514: PPUSH
5515: LD_STRING D1a-JMM-4
5517: PPUSH
5518: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5522: LD_EXP 41
5526: PPUSH
5527: LD_STRING D1a-Corn-5
5529: PPUSH
5530: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5534: LD_EXP 42
5538: PPUSH
5539: LD_EXP 41
5543: PPUSH
5544: CALL_OW 250
5548: PPUSH
5549: LD_EXP 41
5553: PPUSH
5554: CALL_OW 251
5558: PUSH
5559: LD_INT 2
5561: MINUS
5562: PPUSH
5563: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5567: LD_EXP 42
5571: PPUSH
5572: LD_EXP 41
5576: PPUSH
5577: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5581: LD_INT 10
5583: PPUSH
5584: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5588: LD_EXP 34
5592: PPUSH
5593: LD_STRING D1b-JMM-1
5595: PPUSH
5596: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5600: LD_EXP 41
5604: PPUSH
5605: LD_STRING D1b-Corn-1
5607: PPUSH
5608: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5612: LD_EXP 34
5616: PPUSH
5617: LD_STRING D1b-JMM-2
5619: PPUSH
5620: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5624: LD_EXP 41
5628: PPUSH
5629: LD_STRING D1b-Corn-2
5631: PPUSH
5632: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5636: LD_EXP 34
5640: PPUSH
5641: LD_STRING D1b-JMM-3
5643: PPUSH
5644: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5648: LD_INT 10
5650: PPUSH
5651: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5655: LD_EXP 43
5659: PPUSH
5660: LD_STRING D1b-Pow-3
5662: PPUSH
5663: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5667: LD_EXP 34
5671: PPUSH
5672: LD_STRING D1b-JMM-4
5674: PPUSH
5675: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5679: LD_EXP 41
5683: PPUSH
5684: LD_STRING D1b-Corn-4
5686: PPUSH
5687: CALL_OW 88
// if Khatam then
5691: LD_EXP 38
5695: IFFALSE 5711
// Say ( Khatam , D1b-Khat-4 ) else
5697: LD_EXP 38
5701: PPUSH
5702: LD_STRING D1b-Khat-4
5704: PPUSH
5705: CALL_OW 88
5709: GO 5747
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
5711: LD_EXP 6
5715: PPUSH
5716: LD_INT 26
5718: PUSH
5719: LD_INT 1
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: PPUSH
5726: CALL_OW 72
5730: PUSH
5731: LD_EXP 41
5735: PUSH
5736: EMPTY
5737: LIST
5738: DIFF
5739: PPUSH
5740: LD_STRING D1b-Sol1-4
5742: PPUSH
5743: CALL 609 0 2
// if Cyrus then
5747: LD_EXP 36
5751: IFFALSE 5765
// Say ( Cyrus , D1b-Cyrus-4 ) ;
5753: LD_EXP 36
5757: PPUSH
5758: LD_STRING D1b-Cyrus-4
5760: PPUSH
5761: CALL_OW 88
// if Lisa then
5765: LD_EXP 37
5769: IFFALSE 5827
// begin Say ( Lisa , D1b-Lisa-4 ) ;
5771: LD_EXP 37
5775: PPUSH
5776: LD_STRING D1b-Lisa-4
5778: PPUSH
5779: CALL_OW 88
// if Cyrus then
5783: LD_EXP 36
5787: IFFALSE 5827
// begin if not IsInUnit ( Cyrus ) then
5789: LD_EXP 36
5793: PPUSH
5794: CALL_OW 310
5798: NOT
5799: IFFALSE 5815
// ComTurnUnit ( Cyrus , Lisa ) ;
5801: LD_EXP 36
5805: PPUSH
5806: LD_EXP 37
5810: PPUSH
5811: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
5815: LD_EXP 36
5819: PPUSH
5820: LD_STRING D1b-Cyrus-5
5822: PPUSH
5823: CALL_OW 88
// end ; end ; SelectGroup ;
5827: CALL 2562 0 0
// Say ( JMM , D1d-JMM-1 ) ;
5831: LD_EXP 34
5835: PPUSH
5836: LD_STRING D1d-JMM-1
5838: PPUSH
5839: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
5843: LD_EXP 41
5847: PPUSH
5848: LD_STRING D1d-Corn-1
5850: PPUSH
5851: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
5855: LD_ADDR_VAR 0 2
5859: PUSH
5860: LD_EXP 4
5864: PUSH
5865: LD_EXP 6
5869: ADD
5870: PUSH
5871: LD_EXP 34
5875: ADD
5876: PUSH
5877: FOR_IN
5878: IFFALSE 5891
// ComHold ( i ) ;
5880: LD_VAR 0 2
5884: PPUSH
5885: CALL_OW 140
5889: GO 5877
5891: POP
5892: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
5893: LD_ADDR_VAR 0 4
5897: PUSH
5898: LD_INT 22
5900: PUSH
5901: LD_INT 1
5903: PUSH
5904: EMPTY
5905: LIST
5906: LIST
5907: PUSH
5908: LD_INT 21
5910: PUSH
5911: LD_INT 2
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: PUSH
5918: EMPTY
5919: LIST
5920: LIST
5921: PPUSH
5922: CALL_OW 69
5926: ST_TO_ADDR
// if vehicles then
5927: LD_VAR 0 4
5931: IFFALSE 6269
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
5933: LD_EXP 6
5937: PPUSH
5938: LD_INT 55
5940: PUSH
5941: EMPTY
5942: LIST
5943: PPUSH
5944: CALL_OW 72
5948: IFFALSE 5987
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
5950: LD_ADDR_VAR 0 2
5954: PUSH
5955: LD_EXP 6
5959: PPUSH
5960: LD_INT 55
5962: PUSH
5963: EMPTY
5964: LIST
5965: PPUSH
5966: CALL_OW 72
5970: PUSH
5971: FOR_IN
5972: IFFALSE 5985
// ComExitVehicle ( i ) ;
5974: LD_VAR 0 2
5978: PPUSH
5979: CALL_OW 121
5983: GO 5971
5985: POP
5986: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
5987: LD_ADDR_VAR 0 5
5991: PUSH
5992: LD_VAR 0 4
5996: PPUSH
5997: LD_INT 34
5999: PUSH
6000: LD_INT 51
6002: PUSH
6003: EMPTY
6004: LIST
6005: LIST
6006: PPUSH
6007: CALL_OW 72
6011: ST_TO_ADDR
// if cargos then
6012: LD_VAR 0 5
6016: IFFALSE 6199
// begin vehicles := cargos ;
6018: LD_ADDR_VAR 0 4
6022: PUSH
6023: LD_VAR 0 5
6027: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6028: LD_ADDR_VAR 0 6
6032: PUSH
6033: LD_STRING 02_resources_4
6035: PPUSH
6036: LD_INT 0
6038: PPUSH
6039: CALL_OW 30
6043: ST_TO_ADDR
// if debug and not resources then
6044: LD_EXP 1
6048: PUSH
6049: LD_VAR 0 6
6053: NOT
6054: AND
6055: IFFALSE 6065
// resources := 160 ;
6057: LD_ADDR_VAR 0 6
6061: PUSH
6062: LD_INT 160
6064: ST_TO_ADDR
// if resources mod 10 then
6065: LD_VAR 0 6
6069: PUSH
6070: LD_INT 10
6072: MOD
6073: IFFALSE 6095
// resources := resources - resources mod 10 ;
6075: LD_ADDR_VAR 0 6
6079: PUSH
6080: LD_VAR 0 6
6084: PUSH
6085: LD_VAR 0 6
6089: PUSH
6090: LD_INT 10
6092: MOD
6093: MINUS
6094: ST_TO_ADDR
// if resources then
6095: LD_VAR 0 6
6099: IFFALSE 6199
// for i in cargos do
6101: LD_ADDR_VAR 0 2
6105: PUSH
6106: LD_VAR 0 5
6110: PUSH
6111: FOR_IN
6112: IFFALSE 6197
// begin if resources < 100 then
6114: LD_VAR 0 6
6118: PUSH
6119: LD_INT 100
6121: LESS
6122: IFFALSE 6144
// begin cargo := resources ;
6124: LD_ADDR_VAR 0 7
6128: PUSH
6129: LD_VAR 0 6
6133: ST_TO_ADDR
// resources := 0 ;
6134: LD_ADDR_VAR 0 6
6138: PUSH
6139: LD_INT 0
6141: ST_TO_ADDR
// end else
6142: GO 6166
// begin cargo := 100 ;
6144: LD_ADDR_VAR 0 7
6148: PUSH
6149: LD_INT 100
6151: ST_TO_ADDR
// resources := resources - 100 ;
6152: LD_ADDR_VAR 0 6
6156: PUSH
6157: LD_VAR 0 6
6161: PUSH
6162: LD_INT 100
6164: MINUS
6165: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6166: LD_VAR 0 2
6170: PPUSH
6171: LD_INT 1
6173: PPUSH
6174: LD_VAR 0 7
6178: PPUSH
6179: CALL_OW 290
// if resources = 0 then
6183: LD_VAR 0 6
6187: PUSH
6188: LD_INT 0
6190: EQUAL
6191: IFFALSE 6195
// break ;
6193: GO 6197
// end ;
6195: GO 6111
6197: POP
6198: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6199: LD_VAR 0 4
6203: PUSH
6204: LD_INT 1
6206: ARRAY
6207: PPUSH
6208: CALL_OW 311
6212: PPUSH
6213: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6217: LD_VAR 0 4
6221: PUSH
6222: LD_INT 1
6224: ARRAY
6225: PPUSH
6226: LD_INT 4
6228: PPUSH
6229: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6233: LD_EXP 41
6237: PPUSH
6238: LD_VAR 0 4
6242: PUSH
6243: LD_INT 1
6245: ARRAY
6246: PPUSH
6247: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6251: LD_INT 35
6253: PPUSH
6254: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6258: LD_EXP 41
6262: PPUSH
6263: CALL_OW 310
6267: IFFALSE 6251
// end ; InGameOff ;
6269: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6273: LD_STRING M1
6275: PPUSH
6276: CALL_OW 337
// SaveForQuickRestart ;
6280: CALL_OW 22
// cornel_active := true ;
6284: LD_ADDR_EXP 8
6288: PUSH
6289: LD_INT 1
6291: ST_TO_ADDR
// end ;
6292: LD_VAR 0 1
6296: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
6297: LD_EXP 34
6301: PPUSH
6302: LD_EXP 44
6306: PPUSH
6307: CALL_OW 296
6311: PUSH
6312: LD_INT 10
6314: LESS
6315: IFFALSE 7471
6317: GO 6319
6319: DISABLE
6320: LD_INT 0
6322: PPUSH
6323: PPUSH
6324: PPUSH
6325: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6326: LD_ADDR_VAR 0 2
6330: PUSH
6331: LD_INT 89
6333: PUSH
6334: LD_INT 34
6336: PUSH
6337: EMPTY
6338: LIST
6339: LIST
6340: PUSH
6341: LD_INT 138
6343: PUSH
6344: LD_INT 63
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: PUSH
6351: LD_INT 196
6353: PUSH
6354: LD_INT 84
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: PUSH
6361: LD_INT 135
6363: PUSH
6364: LD_INT 52
6366: PUSH
6367: EMPTY
6368: LIST
6369: LIST
6370: PUSH
6371: LD_INT 103
6373: PUSH
6374: LD_INT 39
6376: PUSH
6377: EMPTY
6378: LIST
6379: LIST
6380: PUSH
6381: LD_INT 58
6383: PUSH
6384: LD_INT 30
6386: PUSH
6387: EMPTY
6388: LIST
6389: LIST
6390: PUSH
6391: LD_INT 38
6393: PUSH
6394: LD_INT 51
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: ST_TO_ADDR
// InGameOn ;
6410: CALL_OW 8
// if jmm_units then
6414: LD_EXP 4
6418: IFFALSE 6482
// for i in jmm_units do
6420: LD_ADDR_VAR 0 1
6424: PUSH
6425: LD_EXP 4
6429: PUSH
6430: FOR_IN
6431: IFFALSE 6480
// begin if GetDistUnits ( i , JMM ) < 10 then
6433: LD_VAR 0 1
6437: PPUSH
6438: LD_EXP 34
6442: PPUSH
6443: CALL_OW 296
6447: PUSH
6448: LD_INT 10
6450: LESS
6451: IFFALSE 6469
// ComTurnUnit ( i , JMM ) else
6453: LD_VAR 0 1
6457: PPUSH
6458: LD_EXP 34
6462: PPUSH
6463: CALL_OW 119
6467: GO 6478
// ComHold ( i ) ;
6469: LD_VAR 0 1
6473: PPUSH
6474: CALL_OW 140
// end ;
6478: GO 6430
6480: POP
6481: POP
// if IsInUnit ( JMM ) then
6482: LD_EXP 34
6486: PPUSH
6487: CALL_OW 310
6491: IFFALSE 6516
// begin ComExitVehicle ( JMM ) ;
6493: LD_EXP 34
6497: PPUSH
6498: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6502: LD_EXP 34
6506: PPUSH
6507: LD_EXP 44
6511: PPUSH
6512: CALL_OW 172
// end ; Wait ( 10 ) ;
6516: LD_INT 10
6518: PPUSH
6519: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6523: LD_EXP 34
6527: PPUSH
6528: LD_EXP 44
6532: PPUSH
6533: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6537: LD_INT 35
6539: PPUSH
6540: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6544: LD_EXP 34
6548: PPUSH
6549: LD_EXP 44
6553: PPUSH
6554: CALL_OW 296
6558: PUSH
6559: LD_INT 6
6561: LESS
6562: IFFALSE 6537
// ComTurnUnit ( JMM , Lynch ) ;
6564: LD_EXP 34
6568: PPUSH
6569: LD_EXP 44
6573: PPUSH
6574: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6578: LD_ADDR_VAR 0 1
6582: PUSH
6583: LD_EXP 44
6587: PUSH
6588: LD_EXP 45
6592: PUSH
6593: LD_EXP 46
6597: PUSH
6598: LD_EXP 47
6602: PUSH
6603: EMPTY
6604: LIST
6605: LIST
6606: LIST
6607: LIST
6608: PUSH
6609: FOR_IN
6610: IFFALSE 6628
// ComTurnUnit ( i , JMM ) ;
6612: LD_VAR 0 1
6616: PPUSH
6617: LD_EXP 34
6621: PPUSH
6622: CALL_OW 119
6626: GO 6609
6628: POP
6629: POP
// Wait ( 0 0$0.3 ) ;
6630: LD_INT 10
6632: PPUSH
6633: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6637: LD_EXP 34
6641: PPUSH
6642: LD_STRING D2-JMM-1
6644: PPUSH
6645: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6649: LD_EXP 44
6653: PPUSH
6654: LD_STRING D2-Sol1-1
6656: PPUSH
6657: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6661: LD_EXP 34
6665: PPUSH
6666: LD_STRING D2-JMM-2
6668: PPUSH
6669: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6673: LD_EXP 44
6677: PPUSH
6678: LD_STRING D2-Sol1-2
6680: PPUSH
6681: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6685: LD_EXP 34
6689: PPUSH
6690: LD_STRING D2-JMM-3
6692: PPUSH
6693: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
6697: LD_EXP 44
6701: PPUSH
6702: LD_STRING D2-Sol1-3
6704: PPUSH
6705: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6709: LD_ADDR_VAR 0 1
6713: PUSH
6714: LD_INT 22
6716: PUSH
6717: LD_INT 8
6719: PUSH
6720: EMPTY
6721: LIST
6722: LIST
6723: PPUSH
6724: CALL_OW 69
6728: PUSH
6729: FOR_IN
6730: IFFALSE 6746
// SetSide ( i , 1 ) ;
6732: LD_VAR 0 1
6736: PPUSH
6737: LD_INT 1
6739: PPUSH
6740: CALL_OW 235
6744: GO 6729
6746: POP
6747: POP
// Say ( JMM , D2-JMM-4 ) ;
6748: LD_EXP 34
6752: PPUSH
6753: LD_STRING D2-JMM-4
6755: PPUSH
6756: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
6760: LD_INT 1
6762: PPUSH
6763: LD_INT 5
6765: PPUSH
6766: CALL_OW 332
// for i = 1 to points do
6770: LD_ADDR_VAR 0 1
6774: PUSH
6775: DOUBLE
6776: LD_INT 1
6778: DEC
6779: ST_TO_ADDR
6780: LD_VAR 0 2
6784: PUSH
6785: FOR_TO
6786: IFFALSE 6961
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6788: LD_VAR 0 2
6792: PUSH
6793: LD_VAR 0 1
6797: ARRAY
6798: PUSH
6799: LD_INT 1
6801: ARRAY
6802: PPUSH
6803: LD_VAR 0 2
6807: PUSH
6808: LD_VAR 0 1
6812: ARRAY
6813: PUSH
6814: LD_INT 2
6816: ARRAY
6817: PPUSH
6818: CALL_OW 84
// if i = 1 then
6822: LD_VAR 0 1
6826: PUSH
6827: LD_INT 1
6829: EQUAL
6830: IFFALSE 6844
// Say ( Lynch , D2-Sol1-4 ) ;
6832: LD_EXP 44
6836: PPUSH
6837: LD_STRING D2-Sol1-4
6839: PPUSH
6840: CALL_OW 88
// if i = 2 then
6844: LD_VAR 0 1
6848: PUSH
6849: LD_INT 2
6851: EQUAL
6852: IFFALSE 6866
// Say ( JMM , D2-JMM-5 ) ;
6854: LD_EXP 34
6858: PPUSH
6859: LD_STRING D2-JMM-5
6861: PPUSH
6862: CALL_OW 88
// if i = 4 then
6866: LD_VAR 0 1
6870: PUSH
6871: LD_INT 4
6873: EQUAL
6874: IFFALSE 6898
// begin RevealFogArea ( 1 , troopsArea ) ;
6876: LD_INT 1
6878: PPUSH
6879: LD_INT 6
6881: PPUSH
6882: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
6886: LD_EXP 44
6890: PPUSH
6891: LD_STRING D2-Sol1-5
6893: PPUSH
6894: CALL_OW 88
// end ; if i = 5 then
6898: LD_VAR 0 1
6902: PUSH
6903: LD_INT 5
6905: EQUAL
6906: IFFALSE 6920
// Say ( JMM , D2-JMM-6 ) ;
6908: LD_EXP 34
6912: PPUSH
6913: LD_STRING D2-JMM-6
6915: PPUSH
6916: CALL_OW 88
// if i = 7 then
6920: LD_VAR 0 1
6924: PUSH
6925: LD_INT 7
6927: EQUAL
6928: IFFALSE 6952
// begin RevealFogArea ( 1 , forestArea ) ;
6930: LD_INT 1
6932: PPUSH
6933: LD_INT 7
6935: PPUSH
6936: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
6940: LD_EXP 44
6944: PPUSH
6945: LD_STRING D2-Sol1-6
6947: PPUSH
6948: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
6952: LD_INT 46
6954: PPUSH
6955: CALL_OW 67
// end ;
6959: GO 6785
6961: POP
6962: POP
// CenterNowOnUnits ( JMM ) ;
6963: LD_EXP 34
6967: PPUSH
6968: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
6972: LD_EXP 34
6976: PPUSH
6977: LD_STRING D2-JMM-7
6979: PPUSH
6980: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
6984: LD_EXP 44
6988: PPUSH
6989: LD_STRING D2-Sol1-7
6991: PPUSH
6992: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
6996: LD_EXP 34
7000: PPUSH
7001: LD_STRING D2-JMM-8
7003: PPUSH
7004: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7008: LD_ADDR_VAR 0 4
7012: PUSH
7013: LD_INT 22
7015: PUSH
7016: LD_INT 1
7018: PUSH
7019: EMPTY
7020: LIST
7021: LIST
7022: PUSH
7023: LD_INT 30
7025: PUSH
7026: LD_INT 31
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: PPUSH
7037: CALL_OW 69
7041: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7042: LD_EXP 44
7046: PPUSH
7047: LD_VAR 0 4
7051: PUSH
7052: LD_INT 1
7054: ARRAY
7055: PPUSH
7056: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7060: LD_ADDR_VAR 0 3
7064: PUSH
7065: LD_EXP 4
7069: PPUSH
7070: LD_INT 25
7072: PUSH
7073: LD_INT 1
7075: PUSH
7076: EMPTY
7077: LIST
7078: LIST
7079: PPUSH
7080: CALL_OW 72
7084: PPUSH
7085: LD_EXP 34
7089: PPUSH
7090: CALL_OW 74
7094: ST_TO_ADDR
// if sol then
7095: LD_VAR 0 3
7099: IFFALSE 7139
// if GetDistUnits ( JMM , sol ) < 10 then
7101: LD_EXP 34
7105: PPUSH
7106: LD_VAR 0 3
7110: PPUSH
7111: CALL_OW 296
7115: PUSH
7116: LD_INT 10
7118: LESS
7119: IFFALSE 7139
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7121: LD_VAR 0 3
7125: PPUSH
7126: LD_VAR 0 4
7130: PUSH
7131: LD_INT 2
7133: ARRAY
7134: PPUSH
7135: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7139: LD_INT 10
7141: PPUSH
7142: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7146: LD_EXP 34
7150: PPUSH
7151: LD_INT 65
7153: PPUSH
7154: LD_INT 101
7156: PPUSH
7157: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7161: LD_EXP 34
7165: PPUSH
7166: LD_INT 63
7168: PPUSH
7169: LD_INT 100
7171: PPUSH
7172: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
7176: LD_INT 35
7178: PPUSH
7179: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
7183: LD_EXP 34
7187: PPUSH
7188: LD_INT 65
7190: PPUSH
7191: LD_INT 101
7193: PPUSH
7194: CALL_OW 307
7198: IFFALSE 7176
// Say ( JMM , D2a-JMM-1 ) ;
7200: LD_EXP 34
7204: PPUSH
7205: LD_STRING D2a-JMM-1
7207: PPUSH
7208: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7212: LD_EXP 45
7216: PPUSH
7217: LD_INT 66
7219: PPUSH
7220: LD_INT 103
7222: PPUSH
7223: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
7227: LD_INT 35
7229: PPUSH
7230: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
7234: LD_EXP 45
7238: PPUSH
7239: LD_INT 66
7241: PPUSH
7242: LD_INT 103
7244: PPUSH
7245: CALL_OW 307
7249: IFFALSE 7227
// ComTurnUnit ( Walker , JMM ) ;
7251: LD_EXP 45
7255: PPUSH
7256: LD_EXP 34
7260: PPUSH
7261: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7265: LD_EXP 45
7269: PPUSH
7270: LD_STRING D2a-Sci1-1
7272: PPUSH
7273: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7277: LD_EXP 34
7281: PPUSH
7282: LD_EXP 45
7286: PPUSH
7287: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7291: LD_EXP 34
7295: PPUSH
7296: LD_STRING D2a-JMM-2
7298: PPUSH
7299: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7303: LD_EXP 45
7307: PPUSH
7308: LD_STRING D2a-Sci1-2
7310: PPUSH
7311: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7315: LD_EXP 34
7319: PPUSH
7320: LD_STRING D2a-JMM-3
7322: PPUSH
7323: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7327: LD_EXP 45
7331: PPUSH
7332: LD_STRING D2a-Sci1-3
7334: PPUSH
7335: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7339: LD_ADDR_EXP 4
7343: PUSH
7344: LD_EXP 4
7348: PUSH
7349: LD_EXP 44
7353: PUSH
7354: LD_EXP 45
7358: PUSH
7359: LD_EXP 46
7363: PUSH
7364: LD_EXP 47
7368: PUSH
7369: EMPTY
7370: LIST
7371: LIST
7372: LIST
7373: LIST
7374: ADD
7375: ST_TO_ADDR
// for i in jmm_units do
7376: LD_ADDR_VAR 0 1
7380: PUSH
7381: LD_EXP 4
7385: PUSH
7386: FOR_IN
7387: IFFALSE 7412
// if not IsInUnit ( i ) then
7389: LD_VAR 0 1
7393: PPUSH
7394: CALL_OW 310
7398: NOT
7399: IFFALSE 7410
// ComFree ( i ) ;
7401: LD_VAR 0 1
7405: PPUSH
7406: CALL_OW 139
7410: GO 7386
7412: POP
7413: POP
// InGameOff ;
7414: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
7418: LD_STRING MSolar1
7420: PPUSH
7421: CALL_OW 337
// jmm_on_west := true ;
7425: LD_ADDR_EXP 5
7429: PUSH
7430: LD_INT 1
7432: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7433: LD_INT 1050
7435: PPUSH
7436: CALL_OW 67
// frank_can_return := true ;
7440: LD_ADDR_EXP 12
7444: PUSH
7445: LD_INT 1
7447: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7448: LD_INT 6300
7450: PPUSH
7451: LD_INT 8400
7453: PPUSH
7454: CALL_OW 12
7458: PPUSH
7459: CALL_OW 67
// send_spec_patrol := true ;
7463: LD_ADDR_EXP 28
7467: PUSH
7468: LD_INT 1
7470: ST_TO_ADDR
// end ;
7471: PPOPN 4
7473: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7474: LD_INT 22
7476: PUSH
7477: LD_INT 1
7479: PUSH
7480: EMPTY
7481: LIST
7482: LIST
7483: PUSH
7484: LD_INT 34
7486: PUSH
7487: LD_INT 51
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 92
7496: PUSH
7497: LD_INT 63
7499: PUSH
7500: LD_INT 100
7502: PUSH
7503: LD_INT 5
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: LIST
7510: LIST
7511: PUSH
7512: EMPTY
7513: LIST
7514: LIST
7515: LIST
7516: PUSH
7517: EMPTY
7518: LIST
7519: PPUSH
7520: CALL_OW 69
7524: PUSH
7525: LD_EXP 5
7529: NOT
7530: AND
7531: IFFALSE 7644
7533: GO 7535
7535: DISABLE
7536: LD_INT 0
7538: PPUSH
7539: PPUSH
// begin enable ;
7540: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
7541: LD_ADDR_VAR 0 2
7545: PUSH
7546: LD_INT 22
7548: PUSH
7549: LD_INT 1
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: PUSH
7556: LD_INT 34
7558: PUSH
7559: LD_INT 51
7561: PUSH
7562: EMPTY
7563: LIST
7564: LIST
7565: PUSH
7566: LD_INT 92
7568: PUSH
7569: LD_INT 63
7571: PUSH
7572: LD_INT 100
7574: PUSH
7575: LD_INT 5
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: LIST
7582: LIST
7583: PUSH
7584: EMPTY
7585: LIST
7586: LIST
7587: LIST
7588: PUSH
7589: EMPTY
7590: LIST
7591: PPUSH
7592: CALL_OW 69
7596: ST_TO_ADDR
// if not filter then
7597: LD_VAR 0 2
7601: NOT
7602: IFFALSE 7606
// exit ;
7604: GO 7644
// for i in filter do
7606: LD_ADDR_VAR 0 1
7610: PUSH
7611: LD_VAR 0 2
7615: PUSH
7616: FOR_IN
7617: IFFALSE 7642
// begin SetFuel ( i , 0 ) ;
7619: LD_VAR 0 1
7623: PPUSH
7624: LD_INT 0
7626: PPUSH
7627: CALL_OW 240
// ComStop ( i ) ;
7631: LD_VAR 0 1
7635: PPUSH
7636: CALL_OW 141
// end ;
7640: GO 7616
7642: POP
7643: POP
// end ;
7644: PPOPN 2
7646: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
7647: LD_EXP 28
7651: IFFALSE 8616
7653: GO 7655
7655: DISABLE
7656: LD_INT 0
7658: PPUSH
7659: PPUSH
7660: PPUSH
7661: PPUSH
7662: PPUSH
7663: PPUSH
7664: PPUSH
// begin if not ru_spec_patrol then
7665: LD_EXP 51
7669: NOT
7670: IFFALSE 7674
// exit ;
7672: GO 8616
// dead1 := false ;
7674: LD_ADDR_VAR 0 1
7678: PUSH
7679: LD_INT 0
7681: ST_TO_ADDR
// dead2 := false ;
7682: LD_ADDR_VAR 0 2
7686: PUSH
7687: LD_INT 0
7689: ST_TO_ADDR
// inarea1 := false ;
7690: LD_ADDR_VAR 0 3
7694: PUSH
7695: LD_INT 0
7697: ST_TO_ADDR
// inarea2 := false ;
7698: LD_ADDR_VAR 0 4
7702: PUSH
7703: LD_INT 0
7705: ST_TO_ADDR
// tmp := [ ] ;
7706: LD_ADDR_VAR 0 6
7710: PUSH
7711: EMPTY
7712: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
7713: LD_EXP 51
7717: PPUSH
7718: LD_INT 75
7720: PPUSH
7721: LD_INT 101
7723: PPUSH
7724: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
7728: LD_INT 35
7730: PPUSH
7731: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
7735: LD_INT 1
7737: PPUSH
7738: LD_EXP 51
7742: PUSH
7743: LD_INT 1
7745: ARRAY
7746: PPUSH
7747: CALL_OW 292
7751: IFFALSE 7728
// ComStop ( ru_spec_patrol ) ;
7753: LD_EXP 51
7757: PPUSH
7758: CALL_OW 141
// Wait ( 0 0$02 ) ;
7762: LD_INT 70
7764: PPUSH
7765: CALL_OW 67
// DialogueOn ;
7769: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
7773: LD_EXP 51
7777: PUSH
7778: LD_INT 1
7780: ARRAY
7781: PPUSH
7782: LD_STRING D8-Rus1-1
7784: PPUSH
7785: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
7789: LD_EXP 34
7793: PPUSH
7794: LD_STRING D8-JMM-1
7796: PPUSH
7797: CALL_OW 88
// DialogueOff ;
7801: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
7805: LD_EXP 51
7809: PPUSH
7810: LD_INT 13
7812: PPUSH
7813: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
7817: LD_INT 35
7819: PPUSH
7820: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
7824: LD_VAR 0 1
7828: NOT
7829: PUSH
7830: LD_EXP 51
7834: PUSH
7835: LD_INT 1
7837: ARRAY
7838: PPUSH
7839: CALL_OW 301
7843: AND
7844: IFFALSE 7854
// dead1 := true ;
7846: LD_ADDR_VAR 0 1
7850: PUSH
7851: LD_INT 1
7853: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
7854: LD_VAR 0 2
7858: NOT
7859: PUSH
7860: LD_EXP 51
7864: PUSH
7865: LD_INT 2
7867: ARRAY
7868: PPUSH
7869: CALL_OW 301
7873: AND
7874: IFFALSE 7884
// dead2 := true ;
7876: LD_ADDR_VAR 0 2
7880: PUSH
7881: LD_INT 1
7883: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
7884: LD_VAR 0 3
7888: NOT
7889: PUSH
7890: LD_EXP 51
7894: PUSH
7895: LD_INT 1
7897: ARRAY
7898: PPUSH
7899: LD_INT 14
7901: PPUSH
7902: CALL_OW 308
7906: AND
7907: IFFALSE 7917
// inarea1 := true ;
7909: LD_ADDR_VAR 0 3
7913: PUSH
7914: LD_INT 1
7916: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
7917: LD_VAR 0 4
7921: NOT
7922: PUSH
7923: LD_EXP 51
7927: PUSH
7928: LD_INT 2
7930: ARRAY
7931: PPUSH
7932: LD_INT 14
7934: PPUSH
7935: CALL_OW 308
7939: AND
7940: IFFALSE 7950
// inarea2 := true ;
7942: LD_ADDR_VAR 0 4
7946: PUSH
7947: LD_INT 1
7949: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
7950: LD_VAR 0 1
7954: PUSH
7955: LD_VAR 0 2
7959: AND
7960: PUSH
7961: LD_VAR 0 1
7965: PUSH
7966: LD_VAR 0 4
7970: AND
7971: OR
7972: PUSH
7973: LD_VAR 0 2
7977: PUSH
7978: LD_VAR 0 3
7982: AND
7983: OR
7984: PUSH
7985: LD_VAR 0 3
7989: PUSH
7990: LD_VAR 0 4
7994: AND
7995: OR
7996: IFFALSE 7817
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
7998: LD_VAR 0 3
8002: PUSH
8003: LD_VAR 0 4
8007: AND
8008: PUSH
8009: LD_VAR 0 1
8013: PUSH
8014: LD_VAR 0 4
8018: AND
8019: OR
8020: PUSH
8021: LD_VAR 0 2
8025: PUSH
8026: LD_VAR 0 3
8030: AND
8031: OR
8032: IFFALSE 8596
// begin prepare_siege := true ;
8034: LD_ADDR_EXP 29
8038: PUSH
8039: LD_INT 1
8041: ST_TO_ADDR
// DialogueOn ;
8042: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8046: LD_VAR 0 3
8050: PUSH
8051: LD_VAR 0 4
8055: AND
8056: IFFALSE 8072
// Say ( JMM , D8b-JMM-1a ) else
8058: LD_EXP 34
8062: PPUSH
8063: LD_STRING D8b-JMM-1a
8065: PPUSH
8066: CALL_OW 88
8070: GO 8084
// Say ( JMM , D8b-JMM-1 ) ;
8072: LD_EXP 34
8076: PPUSH
8077: LD_STRING D8b-JMM-1
8079: PPUSH
8080: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8084: LD_EXP 4
8088: PPUSH
8089: LD_INT 26
8091: PUSH
8092: LD_INT 1
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: PPUSH
8099: CALL_OW 72
8103: PUSH
8104: LD_EXP 35
8108: PUSH
8109: LD_EXP 36
8113: PUSH
8114: LD_EXP 45
8118: PUSH
8119: LD_EXP 48
8123: PUSH
8124: EMPTY
8125: LIST
8126: LIST
8127: LIST
8128: LIST
8129: DIFF
8130: PPUSH
8131: LD_STRING D8b-Sol1-1
8133: PPUSH
8134: CALL 609 0 2
// if Cyrus and Cyrus in jmm_units then
8138: LD_EXP 36
8142: PUSH
8143: LD_EXP 36
8147: PUSH
8148: LD_EXP 4
8152: IN
8153: AND
8154: IFFALSE 8170
// Say ( Cyrus , D8b-Cyrus-1 ) else
8156: LD_EXP 36
8160: PPUSH
8161: LD_STRING D8b-Cyrus-1
8163: PPUSH
8164: CALL_OW 88
8168: GO 8182
// Say ( JMM , D8b-JMM-1a ) ;
8170: LD_EXP 34
8174: PPUSH
8175: LD_STRING D8b-JMM-1a
8177: PPUSH
8178: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8182: LD_EXP 37
8186: PUSH
8187: LD_EXP 37
8191: PUSH
8192: LD_EXP 4
8196: IN
8197: AND
8198: IFFALSE 8212
// Say ( Lisa , D8b-Lisa-2 ) ;
8200: LD_EXP 37
8204: PPUSH
8205: LD_STRING D8b-Lisa-2
8207: PPUSH
8208: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8212: LD_EXP 35
8216: PUSH
8217: LD_EXP 35
8221: PUSH
8222: LD_EXP 4
8226: IN
8227: AND
8228: IFFALSE 8244
// Say ( Bobby , D8b-Bobby-1 ) else
8230: LD_EXP 35
8234: PPUSH
8235: LD_STRING D8b-Bobby-1
8237: PPUSH
8238: CALL_OW 88
8242: GO 8304
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8244: LD_ADDR_VAR 0 5
8248: PUSH
8249: LD_EXP 4
8253: PPUSH
8254: LD_INT 26
8256: PUSH
8257: LD_INT 1
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: PPUSH
8264: CALL_OW 72
8268: PUSH
8269: LD_EXP 35
8273: PUSH
8274: LD_EXP 36
8278: PUSH
8279: LD_EXP 45
8283: PUSH
8284: LD_EXP 48
8288: PUSH
8289: EMPTY
8290: LIST
8291: LIST
8292: LIST
8293: LIST
8294: DIFF
8295: PPUSH
8296: LD_STRING D8b-Sol2-1
8298: PPUSH
8299: CALL 609 0 2
8303: ST_TO_ADDR
// DialogueOff ;
8304: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8308: LD_EXP 36
8312: PUSH
8313: LD_EXP 36
8317: PUSH
8318: LD_EXP 4
8322: IN
8323: AND
8324: IFFALSE 8349
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8326: LD_ADDR_VAR 0 6
8330: PUSH
8331: LD_VAR 0 6
8335: PPUSH
8336: LD_INT 1
8338: PPUSH
8339: LD_EXP 36
8343: PPUSH
8344: CALL_OW 2
8348: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8349: LD_EXP 35
8353: PUSH
8354: LD_EXP 35
8358: PUSH
8359: LD_EXP 4
8363: IN
8364: AND
8365: IFFALSE 8390
// tmp := Insert ( tmp , 1 , Bobby ) ;
8367: LD_ADDR_VAR 0 6
8371: PUSH
8372: LD_VAR 0 6
8376: PPUSH
8377: LD_INT 1
8379: PPUSH
8380: LD_EXP 35
8384: PPUSH
8385: CALL_OW 2
8389: ST_TO_ADDR
// if sol then
8390: LD_VAR 0 5
8394: IFFALSE 8419
// tmp := Insert ( tmp , 1 , sol ) ;
8396: LD_ADDR_VAR 0 6
8400: PUSH
8401: LD_VAR 0 6
8405: PPUSH
8406: LD_INT 1
8408: PPUSH
8409: LD_VAR 0 5
8413: PPUSH
8414: CALL_OW 2
8418: ST_TO_ADDR
// if tmp then
8419: LD_VAR 0 6
8423: IFFALSE 8555
// begin SetSide ( tmp , 8 ) ;
8425: LD_VAR 0 6
8429: PPUSH
8430: LD_INT 8
8432: PPUSH
8433: CALL_OW 235
// ComFree ( tmp ) ;
8437: LD_VAR 0 6
8441: PPUSH
8442: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8446: LD_VAR 0 6
8450: PPUSH
8451: LD_INT 15
8453: PPUSH
8454: CALL_OW 173
// AddComHold ( tmp ) ;
8458: LD_VAR 0 6
8462: PPUSH
8463: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8467: LD_INT 35
8469: PPUSH
8470: CALL_OW 67
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8474: LD_VAR 0 6
8478: PUSH
8479: LD_INT 1
8481: ARRAY
8482: PPUSH
8483: LD_INT 15
8485: PPUSH
8486: CALL_OW 308
8490: IFFALSE 8545
// begin RemoveUnit ( tmp [ 1 ] ) ;
8492: LD_VAR 0 6
8496: PUSH
8497: LD_INT 1
8499: ARRAY
8500: PPUSH
8501: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
8505: LD_ADDR_EXP 4
8509: PUSH
8510: LD_EXP 4
8514: PUSH
8515: LD_VAR 0 6
8519: PUSH
8520: LD_INT 1
8522: ARRAY
8523: DIFF
8524: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
8525: LD_ADDR_VAR 0 6
8529: PUSH
8530: LD_VAR 0 6
8534: PUSH
8535: LD_VAR 0 6
8539: PUSH
8540: LD_INT 1
8542: ARRAY
8543: DIFF
8544: ST_TO_ADDR
// end ; until tmp = 0 ;
8545: LD_VAR 0 6
8549: PUSH
8550: LD_INT 0
8552: EQUAL
8553: IFFALSE 8467
// end ; Wait ( 0 0$30 ) ;
8555: LD_INT 1050
8557: PPUSH
8558: CALL_OW 67
// if ru_spec_patrol then
8562: LD_EXP 51
8566: IFFALSE 8594
// for i in ru_spec_patrol do
8568: LD_ADDR_VAR 0 7
8572: PUSH
8573: LD_EXP 51
8577: PUSH
8578: FOR_IN
8579: IFFALSE 8592
// RemoveUnit ( i ) ;
8581: LD_VAR 0 7
8585: PPUSH
8586: CALL_OW 64
8590: GO 8578
8592: POP
8593: POP
// end else
8594: GO 8616
// begin prepare_siege := false ;
8596: LD_ADDR_EXP 29
8600: PUSH
8601: LD_INT 0
8603: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
8604: LD_EXP 34
8608: PPUSH
8609: LD_STRING D8a-JMM-1
8611: PPUSH
8612: CALL_OW 88
// end ; end ;
8616: PPOPN 7
8618: END
// every 0 0$10 trigger frank_can_return do var i , points ;
8619: LD_EXP 12
8623: IFFALSE 9757
8625: GO 8627
8627: DISABLE
8628: LD_INT 0
8630: PPUSH
8631: PPUSH
// begin uc_side := 8 ;
8632: LD_ADDR_OWVAR 20
8636: PUSH
8637: LD_INT 8
8639: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
8640: LD_ADDR_VAR 0 2
8644: PUSH
8645: LD_INT 59
8647: PUSH
8648: LD_INT 71
8650: PUSH
8651: EMPTY
8652: LIST
8653: LIST
8654: PUSH
8655: LD_INT 122
8657: PUSH
8658: LD_INT 117
8660: PUSH
8661: EMPTY
8662: LIST
8663: LIST
8664: PUSH
8665: EMPTY
8666: LIST
8667: LIST
8668: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
8669: LD_ADDR_EXP 48
8673: PUSH
8674: LD_STRING Frank
8676: PPUSH
8677: LD_INT 0
8679: PPUSH
8680: CALL 458 0 2
8684: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
8685: LD_ADDR_VAR 0 1
8689: PUSH
8690: LD_INT 1
8692: PPUSH
8693: LD_INT 2
8695: PPUSH
8696: CALL_OW 12
8700: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
8701: LD_EXP 48
8705: PPUSH
8706: LD_VAR 0 2
8710: PUSH
8711: LD_VAR 0 1
8715: ARRAY
8716: PUSH
8717: LD_INT 1
8719: ARRAY
8720: PPUSH
8721: LD_VAR 0 2
8725: PUSH
8726: LD_VAR 0 1
8730: ARRAY
8731: PUSH
8732: LD_INT 2
8734: ARRAY
8735: PPUSH
8736: LD_INT 0
8738: PPUSH
8739: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
8743: LD_EXP 48
8747: PPUSH
8748: LD_INT 1
8750: PPUSH
8751: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
8755: LD_INT 35
8757: PPUSH
8758: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
8762: LD_EXP 48
8766: PPUSH
8767: LD_EXP 34
8771: PPUSH
8772: CALL_OW 296
8776: PUSH
8777: LD_INT 8
8779: LESS
8780: IFFALSE 8755
// InGameOn ;
8782: CALL_OW 8
// CenterOnUnits ( JMM ) ;
8786: LD_EXP 34
8790: PPUSH
8791: CALL_OW 85
// if IsInUnit ( JMM ) then
8795: LD_EXP 34
8799: PPUSH
8800: CALL_OW 310
8804: IFFALSE 8815
// ComFree ( JMM ) ;
8806: LD_EXP 34
8810: PPUSH
8811: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
8815: LD_EXP 34
8819: PPUSH
8820: LD_EXP 48
8824: PPUSH
8825: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
8829: LD_EXP 48
8833: PPUSH
8834: LD_EXP 34
8838: PPUSH
8839: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
8843: LD_EXP 34
8847: PPUSH
8848: LD_STRING D6-JMM-1
8850: PPUSH
8851: CALL_OW 88
// repeat wait ( 3 ) ;
8855: LD_INT 3
8857: PPUSH
8858: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
8862: LD_EXP 34
8866: PPUSH
8867: LD_EXP 48
8871: PPUSH
8872: CALL_OW 296
8876: PUSH
8877: LD_INT 8
8879: LESS
8880: IFFALSE 8855
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
8882: LD_EXP 37
8886: PUSH
8887: LD_EXP 37
8891: PPUSH
8892: LD_EXP 48
8896: PPUSH
8897: CALL_OW 296
8901: PUSH
8902: LD_INT 20
8904: LESS
8905: AND
8906: IFFALSE 8931
// begin ComFree ( Lisa ) ;
8908: LD_EXP 37
8912: PPUSH
8913: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
8917: LD_EXP 37
8921: PPUSH
8922: LD_EXP 48
8926: PPUSH
8927: CALL_OW 172
// end ; if Lynch then
8931: LD_EXP 44
8935: IFFALSE 8960
// begin ComFree ( Lynch ) ;
8937: LD_EXP 44
8941: PPUSH
8942: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
8946: LD_EXP 44
8950: PPUSH
8951: LD_EXP 48
8955: PPUSH
8956: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
8960: LD_EXP 34
8964: PPUSH
8965: LD_EXP 48
8969: PPUSH
8970: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
8974: LD_EXP 48
8978: PPUSH
8979: LD_EXP 34
8983: PPUSH
8984: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
8988: LD_EXP 48
8992: PPUSH
8993: LD_STRING D6-Frank-1
8995: PPUSH
8996: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9000: LD_INT 69
9002: PPUSH
9003: LD_INT 20
9005: PPUSH
9006: LD_INT 1
9008: PPUSH
9009: LD_INT 20
9011: NEG
9012: PPUSH
9013: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9017: LD_INT 69
9019: PPUSH
9020: LD_INT 20
9022: PPUSH
9023: LD_INT 1
9025: PPUSH
9026: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9030: LD_INT 190
9032: PPUSH
9033: LD_INT 31
9035: PPUSH
9036: LD_INT 1
9038: PPUSH
9039: LD_INT 20
9041: NEG
9042: PPUSH
9043: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9047: LD_INT 190
9049: PPUSH
9050: LD_INT 31
9052: PPUSH
9053: LD_INT 1
9055: PPUSH
9056: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9060: LD_INT 69
9062: PPUSH
9063: LD_INT 20
9065: PPUSH
9066: CALL_OW 84
// Wait ( 0 0$02 ) ;
9070: LD_INT 70
9072: PPUSH
9073: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9077: LD_EXP 34
9081: PPUSH
9082: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9086: LD_EXP 37
9090: PUSH
9091: LD_EXP 37
9095: PPUSH
9096: LD_EXP 48
9100: PPUSH
9101: CALL_OW 296
9105: PUSH
9106: LD_INT 20
9108: LESS
9109: AND
9110: PUSH
9111: LD_EXP 37
9115: PPUSH
9116: CALL_OW 302
9120: AND
9121: IFFALSE 9211
// begin ComFree ( Lisa ) ;
9123: LD_EXP 37
9127: PPUSH
9128: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
9132: LD_INT 35
9134: PPUSH
9135: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
9139: LD_EXP 37
9143: PPUSH
9144: LD_EXP 48
9148: PPUSH
9149: CALL_OW 296
9153: PUSH
9154: LD_INT 7
9156: LESS
9157: IFFALSE 9132
// Say ( Lisa , D6-Lisa-1 ) ;
9159: LD_EXP 37
9163: PPUSH
9164: LD_STRING D6-Lisa-1
9166: PPUSH
9167: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9171: LD_EXP 37
9175: PPUSH
9176: LD_EXP 48
9180: PPUSH
9181: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9185: LD_EXP 48
9189: PPUSH
9190: LD_EXP 37
9194: PPUSH
9195: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9199: LD_EXP 48
9203: PPUSH
9204: LD_STRING D6-Frank-2
9206: PPUSH
9207: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9211: LD_EXP 44
9215: PUSH
9216: LD_EXP 44
9220: PPUSH
9221: LD_EXP 48
9225: PPUSH
9226: CALL_OW 296
9230: PUSH
9231: LD_INT 20
9233: LESS
9234: AND
9235: PUSH
9236: LD_EXP 44
9240: PPUSH
9241: CALL_OW 302
9245: AND
9246: IFFALSE 9427
// begin ComTurnUnit ( Lynch , JMM ) ;
9248: LD_EXP 44
9252: PPUSH
9253: LD_EXP 34
9257: PPUSH
9258: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9262: LD_EXP 48
9266: PPUSH
9267: LD_EXP 34
9271: PPUSH
9272: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9276: LD_EXP 44
9280: PPUSH
9281: LD_STRING D6-Sol1-2
9283: PPUSH
9284: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9288: LD_EXP 34
9292: PPUSH
9293: LD_STRING D6-JMM-2
9295: PPUSH
9296: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9300: LD_EXP 48
9304: PPUSH
9305: LD_STRING D6-Frank-3
9307: PPUSH
9308: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9312: LD_EXP 34
9316: PPUSH
9317: LD_STRING D6-JMM-3
9319: PPUSH
9320: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9324: LD_EXP 48
9328: PPUSH
9329: LD_STRING D6-Frank-4
9331: PPUSH
9332: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9336: LD_EXP 48
9340: PPUSH
9341: LD_STRING D6-Frank-4a
9343: PPUSH
9344: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9348: LD_EXP 34
9352: PPUSH
9353: LD_STRING D6-JMM-4
9355: PPUSH
9356: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9360: LD_EXP 48
9364: PPUSH
9365: LD_STRING D6-Frank-5
9367: PPUSH
9368: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9372: LD_EXP 37
9376: PUSH
9377: LD_EXP 37
9381: PPUSH
9382: CALL_OW 302
9386: AND
9387: IFFALSE 9401
// Say ( Lisa , D6-Lisa-5 ) ;
9389: LD_EXP 37
9393: PPUSH
9394: LD_STRING D6-Lisa-5
9396: PPUSH
9397: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9401: LD_EXP 48
9405: PPUSH
9406: LD_STRING D6-Frank-6
9408: PPUSH
9409: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9413: LD_EXP 34
9417: PPUSH
9418: LD_STRING D6-JMM-6
9420: PPUSH
9421: CALL_OW 88
// end else
9425: GO 9542
// begin ComTurnUnit ( Frank , JMM ) ;
9427: LD_EXP 48
9431: PPUSH
9432: LD_EXP 34
9436: PPUSH
9437: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
9441: LD_EXP 48
9445: PPUSH
9446: LD_STRING D6-Frank-4
9448: PPUSH
9449: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9453: LD_EXP 48
9457: PPUSH
9458: LD_STRING D6-Frank-4a
9460: PPUSH
9461: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9465: LD_EXP 34
9469: PPUSH
9470: LD_STRING D6-JMM-4
9472: PPUSH
9473: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9477: LD_EXP 48
9481: PPUSH
9482: LD_STRING D6-Frank-5
9484: PPUSH
9485: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9489: LD_EXP 37
9493: PUSH
9494: LD_EXP 37
9498: PPUSH
9499: CALL_OW 302
9503: AND
9504: IFFALSE 9518
// Say ( Lisa , D6-Lisa-5 ) ;
9506: LD_EXP 37
9510: PPUSH
9511: LD_STRING D6-Lisa-5
9513: PPUSH
9514: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9518: LD_EXP 48
9522: PPUSH
9523: LD_STRING D6-Frank-6
9525: PPUSH
9526: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9530: LD_EXP 34
9534: PPUSH
9535: LD_STRING D6-JMM-6
9537: PPUSH
9538: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
9542: LD_STRING Q1
9544: PPUSH
9545: CALL_OW 97
9549: PUSH
9550: LD_INT 1
9552: DOUBLE
9553: EQUAL
9554: IFTRUE 9558
9556: GO 9569
9558: POP
// frank_send_to_scout := true ; 2 :
9559: LD_ADDR_EXP 14
9563: PUSH
9564: LD_INT 1
9566: ST_TO_ADDR
9567: GO 9589
9569: LD_INT 2
9571: DOUBLE
9572: EQUAL
9573: IFTRUE 9577
9575: GO 9588
9577: POP
// frank_send_to_scout := false ; end ;
9578: LD_ADDR_EXP 14
9582: PUSH
9583: LD_INT 0
9585: ST_TO_ADDR
9586: GO 9589
9588: POP
// InGameOff ;
9589: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
9593: LD_EXP 34
9597: PUSH
9598: LD_EXP 37
9602: PUSH
9603: LD_EXP 44
9607: PUSH
9608: EMPTY
9609: LIST
9610: LIST
9611: LIST
9612: PPUSH
9613: CALL_OW 139
// if frank_send_to_scout then
9617: LD_EXP 14
9621: IFFALSE 9678
// begin ComMoveXY ( Frank , 130 , 123 ) ;
9623: LD_EXP 48
9627: PPUSH
9628: LD_INT 130
9630: PPUSH
9631: LD_INT 123
9633: PPUSH
9634: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
9638: LD_INT 35
9640: PPUSH
9641: CALL_OW 67
// until not See ( 1 , Frank ) ;
9645: LD_INT 1
9647: PPUSH
9648: LD_EXP 48
9652: PPUSH
9653: CALL_OW 292
9657: NOT
9658: IFFALSE 9638
// Wait ( 0 0$02 ) ;
9660: LD_INT 70
9662: PPUSH
9663: CALL_OW 67
// RemoveUnit ( Frank ) ;
9667: LD_EXP 48
9671: PPUSH
9672: CALL_OW 64
// end else
9676: GO 9690
// SetSide ( Frank , 1 ) ;
9678: LD_EXP 48
9682: PPUSH
9683: LD_INT 1
9685: PPUSH
9686: CALL_OW 235
// send_attack_on_cornel_base := true ;
9690: LD_ADDR_EXP 25
9694: PUSH
9695: LD_INT 1
9697: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9698: LD_INT 35
9700: PPUSH
9701: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
9705: LD_ADDR_EXP 27
9709: PUSH
9710: LD_EXP 27
9714: PPUSH
9715: LD_STRING -
9717: PPUSH
9718: CALL 1101 0 2
9722: ST_TO_ADDR
// if debug then
9723: LD_EXP 1
9727: IFFALSE 9739
// debug_strings := time_to_prepare ;
9729: LD_ADDR_OWVAR 48
9733: PUSH
9734: LD_EXP 27
9738: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
9739: LD_EXP 27
9743: PUSH
9744: LD_INT 0
9746: EQUAL
9747: IFFALSE 9698
// cornel_prepared := true ;
9749: LD_ADDR_EXP 11
9753: PUSH
9754: LD_INT 1
9756: ST_TO_ADDR
// end ;
9757: PPOPN 2
9759: END
// every 0 0$01 trigger cornel_prepared do
9760: LD_EXP 11
9764: IFFALSE 10010
9766: GO 9768
9768: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
9769: LD_EXP 41
9773: PPUSH
9774: LD_STRING D3-Corn-1
9776: PPUSH
9777: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
9781: LD_INT 35
9783: PPUSH
9784: CALL_OW 67
// until cornel_counter = 0 ;
9788: LD_EXP 10
9792: PUSH
9793: LD_INT 0
9795: EQUAL
9796: IFFALSE 9781
// SayRadio ( Cornel , D3a-Corn-1 ) ;
9798: LD_EXP 41
9802: PPUSH
9803: LD_STRING D3a-Corn-1
9805: PPUSH
9806: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
9810: LD_EXP 34
9814: PPUSH
9815: LD_STRING D3a-JMM-1
9817: PPUSH
9818: CALL_OW 88
// end_mission_allowed := true ;
9822: LD_ADDR_EXP 20
9826: PUSH
9827: LD_INT 1
9829: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
9830: LD_STRING M2
9832: PPUSH
9833: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
9837: LD_INT 9
9839: PPUSH
9840: LD_INT 1
9842: PPUSH
9843: CALL_OW 424
// Wait ( 0 0$05 ) ;
9847: LD_INT 175
9849: PPUSH
9850: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
9854: LD_EXP 41
9858: PPUSH
9859: LD_STRING D3a-Corn-2
9861: PPUSH
9862: CALL_OW 94
// cornel_attack := true ;
9866: LD_ADDR_EXP 9
9870: PUSH
9871: LD_INT 1
9873: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
9874: LD_INT 105
9876: PPUSH
9877: CALL_OW 67
// AddMoreTanks ( ) ;
9881: CALL 4759 0 0
// if frank_send_to_scout then
9885: LD_EXP 14
9889: IFFALSE 10010
// begin InitHc ;
9891: CALL_OW 19
// InitUc ;
9895: CALL_OW 18
// uc_side := 8 ;
9899: LD_ADDR_OWVAR 20
9903: PUSH
9904: LD_INT 8
9906: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9907: LD_ADDR_EXP 48
9911: PUSH
9912: LD_STRING Frank
9914: PPUSH
9915: LD_INT 0
9917: PPUSH
9918: CALL 458 0 2
9922: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
9923: LD_EXP 48
9927: PPUSH
9928: LD_INT 6
9930: PPUSH
9931: LD_INT 9
9933: PPUSH
9934: LD_INT 0
9936: PPUSH
9937: CALL_OW 48
// ComCrawl ( Frank ) ;
9941: LD_EXP 48
9945: PPUSH
9946: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
9950: LD_INT 35
9952: PPUSH
9953: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
9957: LD_EXP 34
9961: PPUSH
9962: LD_EXP 48
9966: PPUSH
9967: CALL_OW 296
9971: PUSH
9972: LD_INT 9
9974: LESS
9975: IFFALSE 9950
// SetSide ( Frank , 1 ) ;
9977: LD_EXP 48
9981: PPUSH
9982: LD_INT 1
9984: PPUSH
9985: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
9989: LD_EXP 48
9993: PPUSH
9994: LD_STRING D6a-Frank-1
9996: PPUSH
9997: CALL_OW 88
// ComWalk ( Frank ) ;
10001: LD_EXP 48
10005: PPUSH
10006: CALL_OW 138
// end ; end ;
10010: END
// every 0 0$01 trigger solar_builded do
10011: LD_EXP 13
10015: IFFALSE 10119
10017: GO 10019
10019: DISABLE
// begin Wait ( 0 0$02 ) ;
10020: LD_INT 70
10022: PPUSH
10023: CALL_OW 67
// DialogueOn ;
10027: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10031: LD_EXP 34
10035: PPUSH
10036: LD_STRING D2b-JMM-1
10038: PPUSH
10039: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10043: LD_EXP 45
10047: PUSH
10048: LD_EXP 45
10052: PPUSH
10053: CALL_OW 302
10057: AND
10058: IFFALSE 10108
// begin Say ( Walker , D2b-Sci1-1 ) ;
10060: LD_EXP 45
10064: PPUSH
10065: LD_STRING D2b-Sci1-1
10067: PPUSH
10068: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10072: LD_EXP 34
10076: PPUSH
10077: LD_STRING D2b-JMM-2
10079: PPUSH
10080: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10084: LD_EXP 45
10088: PPUSH
10089: LD_STRING D2b-Sci1-2
10091: PPUSH
10092: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10096: LD_EXP 34
10100: PPUSH
10101: LD_STRING D2b-JMM-3
10103: PPUSH
10104: CALL_OW 88
// end ; DialogueOff ;
10108: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10112: LD_STRING MOutSol
10114: PPUSH
10115: CALL_OW 337
// end ;
10119: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10120: LD_EXP 13
10124: PUSH
10125: LD_EXP 34
10129: PPUSH
10130: CALL_OW 302
10134: AND
10135: PUSH
10136: LD_EXP 34
10140: PPUSH
10141: CALL 935 0 1
10145: AND
10146: PUSH
10147: LD_EXP 15
10151: NOT
10152: AND
10153: IFFALSE 10224
10155: GO 10157
10157: DISABLE
10158: LD_INT 0
10160: PPUSH
// begin jmm_in_veh := true ;
10161: LD_ADDR_EXP 15
10165: PUSH
10166: LD_INT 1
10168: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10169: LD_ADDR_VAR 0 1
10173: PUSH
10174: LD_INT 0
10176: PPUSH
10177: LD_INT 1
10179: PPUSH
10180: CALL_OW 12
10184: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10185: LD_INT 70
10187: PPUSH
10188: CALL_OW 67
// if i then
10192: LD_VAR 0 1
10196: IFFALSE 10212
// Say ( JMM , D2c-JMM-1 ) else
10198: LD_EXP 34
10202: PPUSH
10203: LD_STRING D2c-JMM-1
10205: PPUSH
10206: CALL_OW 88
10210: GO 10224
// Say ( JMM , D2c-JMM-1a ) ;
10212: LD_EXP 34
10216: PPUSH
10217: LD_STRING D2c-JMM-1a
10219: PPUSH
10220: CALL_OW 88
// end ;
10224: PPOPN 1
10226: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10227: LD_EXP 13
10231: PUSH
10232: LD_EXP 35
10236: PPUSH
10237: CALL_OW 302
10241: AND
10242: PUSH
10243: LD_EXP 35
10247: PPUSH
10248: CALL 935 0 1
10252: AND
10253: PUSH
10254: LD_EXP 16
10258: NOT
10259: AND
10260: IFFALSE 10292
10262: GO 10264
10264: DISABLE
// begin bobby_in_veh := true ;
10265: LD_ADDR_EXP 16
10269: PUSH
10270: LD_INT 1
10272: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10273: LD_INT 70
10275: PPUSH
10276: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10280: LD_EXP 35
10284: PPUSH
10285: LD_STRING D2c-Bobby-1
10287: PPUSH
10288: CALL_OW 88
10292: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10293: LD_EXP 13
10297: PUSH
10298: LD_EXP 37
10302: PPUSH
10303: CALL_OW 302
10307: AND
10308: PUSH
10309: LD_EXP 37
10313: PPUSH
10314: CALL 935 0 1
10318: AND
10319: PUSH
10320: LD_EXP 18
10324: NOT
10325: AND
10326: IFFALSE 10358
10328: GO 10330
10330: DISABLE
// begin lisa_in_veh := true ;
10331: LD_ADDR_EXP 18
10335: PUSH
10336: LD_INT 1
10338: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10339: LD_INT 70
10341: PPUSH
10342: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10346: LD_EXP 37
10350: PPUSH
10351: LD_STRING D2c-Lisa-1
10353: PPUSH
10354: CALL_OW 88
10358: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
10359: LD_EXP 13
10363: PUSH
10364: LD_EXP 36
10368: PPUSH
10369: CALL_OW 302
10373: AND
10374: PUSH
10375: LD_EXP 36
10379: PPUSH
10380: CALL 935 0 1
10384: AND
10385: PUSH
10386: LD_EXP 17
10390: NOT
10391: AND
10392: IFFALSE 10463
10394: GO 10396
10396: DISABLE
10397: LD_INT 0
10399: PPUSH
// begin cyrus_in_veh := true ;
10400: LD_ADDR_EXP 17
10404: PUSH
10405: LD_INT 1
10407: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10408: LD_ADDR_VAR 0 1
10412: PUSH
10413: LD_INT 0
10415: PPUSH
10416: LD_INT 1
10418: PPUSH
10419: CALL_OW 12
10423: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10424: LD_INT 70
10426: PPUSH
10427: CALL_OW 67
// if i then
10431: LD_VAR 0 1
10435: IFFALSE 10451
// Say ( Cyrus , D2c-Cyrus-1 ) else
10437: LD_EXP 36
10441: PPUSH
10442: LD_STRING D2c-Cyrus-1
10444: PPUSH
10445: CALL_OW 88
10449: GO 10463
// Say ( Cyrus , D2c-Cyrus-1a ) ;
10451: LD_EXP 36
10455: PPUSH
10456: LD_STRING D2c-Cyrus-1a
10458: PPUSH
10459: CALL_OW 88
// end ;
10463: PPOPN 1
10465: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
10466: LD_EXP 41
10470: PPUSH
10471: LD_INT 16
10473: PPUSH
10474: CALL_OW 308
10478: IFFALSE 10734
10480: GO 10482
10482: DISABLE
10483: LD_INT 0
10485: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
10486: LD_INT 3
10488: PPUSH
10489: LD_EXP 41
10493: PPUSH
10494: CALL_OW 471
// send_attack_on_cornel := true ;
10498: LD_ADDR_EXP 30
10502: PUSH
10503: LD_INT 1
10505: ST_TO_ADDR
// if ru_vehicles then
10506: LD_EXP 53
10510: IFFALSE 10544
// for i in ru_vehicles do
10512: LD_ADDR_VAR 0 1
10516: PUSH
10517: LD_EXP 53
10521: PUSH
10522: FOR_IN
10523: IFFALSE 10542
// ComAgressiveMove ( i , 215 , 69 ) ;
10525: LD_VAR 0 1
10529: PPUSH
10530: LD_INT 215
10532: PPUSH
10533: LD_INT 69
10535: PPUSH
10536: CALL_OW 114
10540: GO 10522
10542: POP
10543: POP
// if ru_patrol then
10544: LD_EXP 50
10548: IFFALSE 10582
// for i in ru_patrol do
10550: LD_ADDR_VAR 0 1
10554: PUSH
10555: LD_EXP 50
10559: PUSH
10560: FOR_IN
10561: IFFALSE 10580
// ComAgressiveMove ( i , 215 , 69 ) ;
10563: LD_VAR 0 1
10567: PPUSH
10568: LD_INT 215
10570: PPUSH
10571: LD_INT 69
10573: PPUSH
10574: CALL_OW 114
10578: GO 10560
10580: POP
10581: POP
// if frank_send_to_scout then
10582: LD_EXP 14
10586: IFFALSE 10600
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
10588: LD_EXP 48
10592: PPUSH
10593: LD_STRING D3b-Frank-1
10595: PPUSH
10596: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
10600: LD_INT 105
10602: PPUSH
10603: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
10607: LD_EXP 41
10611: PPUSH
10612: LD_STRING D4-Corn-1
10614: PPUSH
10615: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10619: LD_INT 35
10621: PPUSH
10622: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 6 ;
10626: LD_INT 22
10628: PUSH
10629: LD_INT 4
10631: PUSH
10632: EMPTY
10633: LIST
10634: LIST
10635: PUSH
10636: LD_INT 21
10638: PUSH
10639: LD_INT 1
10641: PUSH
10642: EMPTY
10643: LIST
10644: LIST
10645: PUSH
10646: LD_INT 50
10648: PUSH
10649: EMPTY
10650: LIST
10651: PUSH
10652: EMPTY
10653: LIST
10654: LIST
10655: LIST
10656: PPUSH
10657: CALL_OW 69
10661: PUSH
10662: LD_INT 6
10664: LESS
10665: IFFALSE 10619
// SayRadio ( Cornel , D5-Corn-1 ) ;
10667: LD_EXP 41
10671: PPUSH
10672: LD_STRING D5-Corn-1
10674: PPUSH
10675: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
10679: LD_EXP 41
10683: PPUSH
10684: LD_EXP 2
10688: PUSH
10689: LD_STRING Cornel
10691: STR
10692: PPUSH
10693: CALL_OW 38
// ChangeSideFog ( 4 , 8 ) ;
10697: LD_INT 4
10699: PPUSH
10700: LD_INT 8
10702: PPUSH
10703: CALL_OW 343
// Wait ( 0 0$01 ) ;
10707: LD_INT 35
10709: PPUSH
10710: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
10714: LD_INT 3
10716: PPUSH
10717: LD_EXP 41
10721: PPUSH
10722: CALL_OW 472
// send_attack_on_cornel := false ;
10726: LD_ADDR_EXP 30
10730: PUSH
10731: LD_INT 0
10733: ST_TO_ADDR
// end ;
10734: PPOPN 1
10736: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
10737: LD_INT 9
10739: PPUSH
10740: LD_INT 22
10742: PUSH
10743: LD_INT 1
10745: PUSH
10746: EMPTY
10747: LIST
10748: LIST
10749: PPUSH
10750: CALL_OW 70
10754: PUSH
10755: LD_EXP 31
10759: OR
10760: IFFALSE 10926
10762: GO 10764
10764: DISABLE
10765: LD_INT 0
10767: PPUSH
10768: PPUSH
// begin enable ;
10769: ENABLE
// if not game_end then
10770: LD_EXP 31
10774: NOT
10775: IFFALSE 10785
// game_end := true ;
10777: LD_ADDR_EXP 31
10781: PUSH
10782: LD_INT 1
10784: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
10785: LD_ADDR_VAR 0 2
10789: PUSH
10790: LD_INT 9
10792: PPUSH
10793: LD_INT 22
10795: PUSH
10796: LD_INT 1
10798: PUSH
10799: EMPTY
10800: LIST
10801: LIST
10802: PPUSH
10803: CALL_OW 70
10807: ST_TO_ADDR
// if not filter then
10808: LD_VAR 0 2
10812: NOT
10813: IFFALSE 10817
// exit ;
10815: GO 10926
// for i in filter do
10817: LD_ADDR_VAR 0 1
10821: PUSH
10822: LD_VAR 0 2
10826: PUSH
10827: FOR_IN
10828: IFFALSE 10924
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
10830: LD_VAR 0 1
10834: PPUSH
10835: CALL_OW 302
10839: PUSH
10840: LD_VAR 0 1
10844: PPUSH
10845: CALL_OW 247
10849: PUSH
10850: LD_INT 2
10852: EQUAL
10853: AND
10854: IFFALSE 10887
// begin veh_on_meta := true ;
10856: LD_ADDR_EXP 26
10860: PUSH
10861: LD_INT 1
10863: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
10864: LD_VAR 0 1
10868: PPUSH
10869: CALL_OW 311
10873: PPUSH
10874: CALL 10929 0 1
// RemoveUnit ( i ) ;
10878: LD_VAR 0 1
10882: PPUSH
10883: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
10887: LD_VAR 0 1
10891: PPUSH
10892: CALL_OW 302
10896: PUSH
10897: LD_VAR 0 1
10901: PPUSH
10902: CALL_OW 247
10906: PUSH
10907: LD_INT 1
10909: EQUAL
10910: AND
10911: IFFALSE 10922
// Save ( i ) ;
10913: LD_VAR 0 1
10917: PPUSH
10918: CALL 10929 0 1
// end ;
10922: GO 10827
10924: POP
10925: POP
// end ;
10926: PPOPN 2
10928: END
// export function Save ( i ) ; begin
10929: LD_INT 0
10931: PPUSH
// if i = JMM then
10932: LD_VAR 0 1
10936: PUSH
10937: LD_EXP 34
10941: EQUAL
10942: IFFALSE 11064
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
10944: LD_EXP 23
10948: PUSH
10949: LD_INT 22
10951: PUSH
10952: LD_INT 1
10954: PUSH
10955: EMPTY
10956: LIST
10957: LIST
10958: PUSH
10959: LD_INT 21
10961: PUSH
10962: LD_INT 1
10964: PUSH
10965: EMPTY
10966: LIST
10967: LIST
10968: PUSH
10969: EMPTY
10970: LIST
10971: LIST
10972: PPUSH
10973: CALL_OW 69
10977: PUSH
10978: LD_INT 1
10980: GREATER
10981: AND
10982: IFFALSE 11039
// begin show_query := false ;
10984: LD_ADDR_EXP 23
10988: PUSH
10989: LD_INT 0
10991: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
10992: LD_STRING Q2
10994: PPUSH
10995: CALL_OW 97
10999: PUSH
11000: LD_INT 1
11002: DOUBLE
11003: EQUAL
11004: IFTRUE 11008
11006: GO 11019
11008: POP
// wait_for_them := true ; 2 :
11009: LD_ADDR_EXP 24
11013: PUSH
11014: LD_INT 1
11016: ST_TO_ADDR
11017: GO 11039
11019: LD_INT 2
11021: DOUBLE
11022: EQUAL
11023: IFTRUE 11027
11025: GO 11038
11027: POP
// wait_for_them := false ; end ;
11028: LD_ADDR_EXP 24
11032: PUSH
11033: LD_INT 0
11035: ST_TO_ADDR
11036: GO 11039
11038: POP
// end ; save_group := save_group ^ JMM ;
11039: LD_ADDR_EXP 22
11043: PUSH
11044: LD_EXP 22
11048: PUSH
11049: LD_EXP 34
11053: ADD
11054: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11055: LD_EXP 34
11059: PPUSH
11060: CALL_OW 64
// end ; if i = Lisa then
11064: LD_VAR 0 1
11068: PUSH
11069: LD_EXP 37
11073: EQUAL
11074: IFFALSE 11101
// begin save_group := save_group ^ Lisa ;
11076: LD_ADDR_EXP 22
11080: PUSH
11081: LD_EXP 22
11085: PUSH
11086: LD_EXP 37
11090: ADD
11091: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11092: LD_EXP 37
11096: PPUSH
11097: CALL_OW 64
// end ; if i = Bobby then
11101: LD_VAR 0 1
11105: PUSH
11106: LD_EXP 35
11110: EQUAL
11111: IFFALSE 11138
// begin save_group := save_group ^ Bobby ;
11113: LD_ADDR_EXP 22
11117: PUSH
11118: LD_EXP 22
11122: PUSH
11123: LD_EXP 35
11127: ADD
11128: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11129: LD_EXP 35
11133: PPUSH
11134: CALL_OW 64
// end ; if i = Cyrus then
11138: LD_VAR 0 1
11142: PUSH
11143: LD_EXP 36
11147: EQUAL
11148: IFFALSE 11175
// begin save_group := save_group ^ Cyrus ;
11150: LD_ADDR_EXP 22
11154: PUSH
11155: LD_EXP 22
11159: PUSH
11160: LD_EXP 36
11164: ADD
11165: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11166: LD_EXP 36
11170: PPUSH
11171: CALL_OW 64
// end ; if i = Khatam then
11175: LD_VAR 0 1
11179: PUSH
11180: LD_EXP 38
11184: EQUAL
11185: IFFALSE 11212
// begin save_group := save_group ^ Khatam ;
11187: LD_ADDR_EXP 22
11191: PUSH
11192: LD_EXP 22
11196: PUSH
11197: LD_EXP 38
11201: ADD
11202: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11203: LD_EXP 38
11207: PPUSH
11208: CALL_OW 64
// end ; if i = Frank then
11212: LD_VAR 0 1
11216: PUSH
11217: LD_EXP 48
11221: EQUAL
11222: IFFALSE 11249
// begin save_group := save_group ^ Frank ;
11224: LD_ADDR_EXP 22
11228: PUSH
11229: LD_EXP 22
11233: PUSH
11234: LD_EXP 48
11238: ADD
11239: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11240: LD_EXP 48
11244: PPUSH
11245: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11249: LD_VAR 0 1
11253: PPUSH
11254: CALL_OW 302
11258: PUSH
11259: LD_VAR 0 1
11263: PPUSH
11264: CALL_OW 247
11268: PUSH
11269: LD_INT 1
11271: EQUAL
11272: AND
11273: PUSH
11274: LD_VAR 0 1
11278: PUSH
11279: LD_EXP 22
11283: IN
11284: NOT
11285: AND
11286: IFFALSE 11313
// begin save_others := save_others ^ i ;
11288: LD_ADDR_EXP 21
11292: PUSH
11293: LD_EXP 21
11297: PUSH
11298: LD_VAR 0 1
11302: ADD
11303: ST_TO_ADDR
// RemoveUnit ( i ) ;
11304: LD_VAR 0 1
11308: PPUSH
11309: CALL_OW 64
// end ; end ;
11313: LD_VAR 0 2
11317: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
11318: LD_EXP 23
11322: NOT
11323: PUSH
11324: LD_EXP 24
11328: NOT
11329: AND
11330: PUSH
11331: LD_INT 22
11333: PUSH
11334: LD_INT 1
11336: PUSH
11337: EMPTY
11338: LIST
11339: LIST
11340: PUSH
11341: LD_INT 21
11343: PUSH
11344: LD_INT 1
11346: PUSH
11347: EMPTY
11348: LIST
11349: LIST
11350: PUSH
11351: EMPTY
11352: LIST
11353: LIST
11354: PPUSH
11355: CALL_OW 69
11359: PUSH
11360: LD_INT 0
11362: EQUAL
11363: OR
11364: IFFALSE 11373
11366: GO 11368
11368: DISABLE
// EndMission ;
11369: CALL 11374 0 0
11373: END
// export function EndMission ; var i ; begin
11374: LD_INT 0
11376: PPUSH
11377: PPUSH
// Wait ( 0 0$02 ) ;
11378: LD_INT 70
11380: PPUSH
11381: CALL_OW 67
// if solar_builded then
11385: LD_EXP 13
11389: IFFALSE 11403
// AddMedal ( Solar1 , 1 ) else
11391: LD_STRING Solar1
11393: PPUSH
11394: LD_INT 1
11396: PPUSH
11397: CALL_OW 101
11401: GO 11414
// AddMedal ( Solar1 , - 1 ) ;
11403: LD_STRING Solar1
11405: PPUSH
11406: LD_INT 1
11408: NEG
11409: PPUSH
11410: CALL_OW 101
// if veh_on_meta then
11414: LD_EXP 26
11418: IFFALSE 11432
// AddMedal ( Solar2 , 1 ) else
11420: LD_STRING Solar2
11422: PPUSH
11423: LD_INT 1
11425: PPUSH
11426: CALL_OW 101
11430: GO 11462
// if solar_builded then
11432: LD_EXP 13
11436: IFFALSE 11451
// AddMedal ( Solar2 , - 1 ) else
11438: LD_STRING Solar2
11440: PPUSH
11441: LD_INT 1
11443: NEG
11444: PPUSH
11445: CALL_OW 101
11449: GO 11462
// AddMedal ( Solar2 , - 2 ) ;
11451: LD_STRING Solar2
11453: PPUSH
11454: LD_INT 2
11456: NEG
11457: PPUSH
11458: CALL_OW 101
// if lose_counter = 0 then
11462: LD_EXP 32
11466: PUSH
11467: LD_INT 0
11469: EQUAL
11470: IFFALSE 11484
// AddMedal ( No , 1 ) else
11472: LD_STRING No
11474: PPUSH
11475: LD_INT 1
11477: PPUSH
11478: CALL_OW 101
11482: GO 11528
// if lose_counter > 0 and lose_counter < 4 then
11484: LD_EXP 32
11488: PUSH
11489: LD_INT 0
11491: GREATER
11492: PUSH
11493: LD_EXP 32
11497: PUSH
11498: LD_INT 4
11500: LESS
11501: AND
11502: IFFALSE 11517
// AddMedal ( No , - 1 ) else
11504: LD_STRING No
11506: PPUSH
11507: LD_INT 1
11509: NEG
11510: PPUSH
11511: CALL_OW 101
11515: GO 11528
// AddMedal ( UpTo4 , - 1 ) ;
11517: LD_STRING UpTo4
11519: PPUSH
11520: LD_INT 1
11522: NEG
11523: PPUSH
11524: CALL_OW 101
// GiveMedals ( MAIN ) ;
11528: LD_STRING MAIN
11530: PPUSH
11531: CALL_OW 102
// if IsDead ( Pokryshkin ) then
11535: LD_EXP 49
11539: PPUSH
11540: CALL_OW 301
11544: IFFALSE 11584
// for i in save_group ^ save_others do
11546: LD_ADDR_VAR 0 2
11550: PUSH
11551: LD_EXP 22
11555: PUSH
11556: LD_EXP 21
11560: ADD
11561: PUSH
11562: FOR_IN
11563: IFFALSE 11582
// AddExperience ( i , skill_combat , 1500 ) ;
11565: LD_VAR 0 2
11569: PPUSH
11570: LD_INT 1
11572: PPUSH
11573: LD_INT 1500
11575: PPUSH
11576: CALL_OW 492
11580: GO 11562
11582: POP
11583: POP
// RewardPeople ( save_group ^ save_others ) ;
11584: LD_EXP 22
11588: PUSH
11589: LD_EXP 21
11593: ADD
11594: PPUSH
11595: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11599: LD_EXP 34
11603: PPUSH
11604: LD_EXP 2
11608: PUSH
11609: LD_STRING JMM
11611: STR
11612: PPUSH
11613: CALL_OW 38
// if Bobby in save_group then
11617: LD_EXP 35
11621: PUSH
11622: LD_EXP 22
11626: IN
11627: IFFALSE 11647
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11629: LD_EXP 35
11633: PPUSH
11634: LD_EXP 2
11638: PUSH
11639: LD_STRING Bobby
11641: STR
11642: PPUSH
11643: CALL_OW 38
// if Cyrus in save_group then
11647: LD_EXP 36
11651: PUSH
11652: LD_EXP 22
11656: IN
11657: IFFALSE 11677
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11659: LD_EXP 36
11663: PPUSH
11664: LD_EXP 2
11668: PUSH
11669: LD_STRING Cyrus
11671: STR
11672: PPUSH
11673: CALL_OW 38
// if Lisa in save_group then
11677: LD_EXP 37
11681: PUSH
11682: LD_EXP 22
11686: IN
11687: IFFALSE 11707
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
11689: LD_EXP 37
11693: PPUSH
11694: LD_EXP 2
11698: PUSH
11699: LD_STRING Lisa
11701: STR
11702: PPUSH
11703: CALL_OW 38
// if Frank in save_group then
11707: LD_EXP 48
11711: PUSH
11712: LD_EXP 22
11716: IN
11717: IFFALSE 11737
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
11719: LD_EXP 48
11723: PPUSH
11724: LD_EXP 2
11728: PUSH
11729: LD_STRING Frank
11731: STR
11732: PPUSH
11733: CALL_OW 38
// if Khatam in save_group then
11737: LD_EXP 38
11741: PUSH
11742: LD_EXP 22
11746: IN
11747: IFFALSE 11767
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
11749: LD_EXP 38
11753: PPUSH
11754: LD_EXP 2
11758: PUSH
11759: LD_STRING Khatam
11761: STR
11762: PPUSH
11763: CALL_OW 38
// if save_others then
11767: LD_EXP 21
11771: IFFALSE 11785
// SaveCharacters ( save_others , 03_others ) ;
11773: LD_EXP 21
11777: PPUSH
11778: LD_STRING 03_others
11780: PPUSH
11781: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) then
11785: LD_EXP 42
11789: PUSH
11790: LD_EXP 42
11794: PPUSH
11795: CALL_OW 302
11799: AND
11800: IFFALSE 11812
// begin ResetFog ;
11802: CALL_OW 335
// DisplayEndingScene ;
11806: CALL 11834 0 0
// end else
11810: GO 11825
// DeleteCharacters ( mission_prefix & Cornel ) ;
11812: LD_EXP 2
11816: PUSH
11817: LD_STRING Cornel
11819: STR
11820: PPUSH
11821: CALL_OW 40
// YouWin ;
11825: CALL_OW 103
// end ;
11829: LD_VAR 0 1
11833: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
11834: LD_INT 0
11836: PPUSH
11837: PPUSH
11838: PPUSH
11839: PPUSH
11840: PPUSH
11841: PPUSH
// InGameOn ;
11842: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
11846: LD_INT 208
11848: PPUSH
11849: LD_INT 62
11851: PPUSH
11852: LD_INT 1
11854: PPUSH
11855: LD_INT 10
11857: NEG
11858: PPUSH
11859: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
11863: LD_INT 208
11865: PPUSH
11866: LD_INT 62
11868: PPUSH
11869: LD_INT 1
11871: PPUSH
11872: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11876: LD_ADDR_VAR 0 3
11880: PUSH
11881: LD_INT 22
11883: PUSH
11884: LD_INT 3
11886: PUSH
11887: EMPTY
11888: LIST
11889: LIST
11890: PUSH
11891: LD_INT 2
11893: PUSH
11894: LD_INT 21
11896: PUSH
11897: LD_INT 2
11899: PUSH
11900: EMPTY
11901: LIST
11902: LIST
11903: PUSH
11904: LD_INT 21
11906: PUSH
11907: LD_INT 1
11909: PUSH
11910: EMPTY
11911: LIST
11912: LIST
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: LIST
11918: PUSH
11919: EMPTY
11920: LIST
11921: LIST
11922: PPUSH
11923: CALL_OW 69
11927: ST_TO_ADDR
// if filter then
11928: LD_VAR 0 3
11932: IFFALSE 11960
// for i in filter do
11934: LD_ADDR_VAR 0 2
11938: PUSH
11939: LD_VAR 0 3
11943: PUSH
11944: FOR_IN
11945: IFFALSE 11958
// RemoveUnit ( i ) ;
11947: LD_VAR 0 2
11951: PPUSH
11952: CALL_OW 64
11956: GO 11944
11958: POP
11959: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
11960: LD_ADDR_VAR 0 3
11964: PUSH
11965: LD_INT 22
11967: PUSH
11968: LD_INT 4
11970: PUSH
11971: EMPTY
11972: LIST
11973: LIST
11974: PUSH
11975: LD_INT 21
11977: PUSH
11978: LD_INT 1
11980: PUSH
11981: EMPTY
11982: LIST
11983: LIST
11984: PUSH
11985: EMPTY
11986: LIST
11987: LIST
11988: PPUSH
11989: CALL_OW 69
11993: ST_TO_ADDR
// if filter then
11994: LD_VAR 0 3
11998: IFFALSE 12029
// for i in filter do
12000: LD_ADDR_VAR 0 2
12004: PUSH
12005: LD_VAR 0 3
12009: PUSH
12010: FOR_IN
12011: IFFALSE 12027
// SetLives ( i , 0 ) ;
12013: LD_VAR 0 2
12017: PPUSH
12018: LD_INT 0
12020: PPUSH
12021: CALL_OW 234
12025: GO 12010
12027: POP
12028: POP
// uc_side := 4 ;
12029: LD_ADDR_OWVAR 20
12033: PUSH
12034: LD_INT 4
12036: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12037: LD_ADDR_VAR 0 4
12041: PUSH
12042: LD_STRING Cornell
12044: PPUSH
12045: LD_INT 0
12047: PPUSH
12048: CALL 458 0 2
12052: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12053: LD_VAR 0 4
12057: PPUSH
12058: LD_INT 208
12060: PPUSH
12061: LD_INT 62
12063: PPUSH
12064: LD_INT 0
12066: PPUSH
12067: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12071: LD_VAR 0 4
12075: PPUSH
12076: LD_INT 100
12078: PPUSH
12079: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12083: LD_INT 3
12085: PPUSH
12086: LD_VAR 0 4
12090: PPUSH
12091: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12095: LD_INT 4
12097: PPUSH
12098: LD_INT 3
12100: PPUSH
12101: LD_INT 1
12103: PPUSH
12104: LD_INT 1
12106: PPUSH
12107: CALL_OW 80
// uc_side := 3 ;
12111: LD_ADDR_OWVAR 20
12115: PUSH
12116: LD_INT 3
12118: ST_TO_ADDR
// uc_nation := 3 ;
12119: LD_ADDR_OWVAR 21
12123: PUSH
12124: LD_INT 3
12126: ST_TO_ADDR
// InitHc ;
12127: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12131: LD_ADDR_VAR 0 5
12135: PUSH
12136: LD_STRING Mikhail
12138: PPUSH
12139: LD_INT 0
12141: PPUSH
12142: CALL 458 0 2
12146: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12147: LD_INT 1
12149: PPUSH
12150: LD_INT 1
12152: PPUSH
12153: LD_INT 0
12155: PPUSH
12156: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12160: LD_ADDR_VAR 0 6
12164: PUSH
12165: LD_VAR 0 6
12169: PUSH
12170: CALL_OW 44
12174: ADD
12175: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12176: LD_ADDR_VAR 0 6
12180: PUSH
12181: LD_VAR 0 6
12185: PUSH
12186: CALL_OW 44
12190: ADD
12191: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12192: LD_INT 2
12194: PPUSH
12195: LD_INT 4
12197: PPUSH
12198: LD_INT 0
12200: PPUSH
12201: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12205: LD_ADDR_VAR 0 6
12209: PUSH
12210: LD_VAR 0 6
12214: PUSH
12215: CALL_OW 44
12219: ADD
12220: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12221: LD_VAR 0 5
12225: PPUSH
12226: LD_INT 17
12228: PPUSH
12229: LD_INT 0
12231: PPUSH
12232: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12236: LD_VAR 0 5
12240: PPUSH
12241: LD_INT 210
12243: PPUSH
12244: LD_INT 63
12246: PPUSH
12247: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12251: LD_VAR 0 5
12255: PPUSH
12256: LD_INT 208
12258: PPUSH
12259: LD_INT 62
12261: PPUSH
12262: CALL_OW 178
// for i in fake_russians do
12266: LD_ADDR_VAR 0 2
12270: PUSH
12271: LD_VAR 0 6
12275: PUSH
12276: FOR_IN
12277: IFFALSE 12355
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12279: LD_VAR 0 2
12283: PPUSH
12284: LD_INT 17
12286: PPUSH
12287: LD_INT 0
12289: PPUSH
12290: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
12294: LD_VAR 0 2
12298: PPUSH
12299: LD_INT 215
12301: PPUSH
12302: LD_INT 67
12304: PPUSH
12305: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
12309: LD_VAR 0 2
12313: PPUSH
12314: LD_INT 208
12316: PPUSH
12317: LD_INT 62
12319: PPUSH
12320: CALL_OW 178
// if GetClass ( i ) = 4 then
12324: LD_VAR 0 2
12328: PPUSH
12329: CALL_OW 257
12333: PUSH
12334: LD_INT 4
12336: EQUAL
12337: IFFALSE 12353
// ComHeal ( i , fake_cornel ) ;
12339: LD_VAR 0 2
12343: PPUSH
12344: LD_VAR 0 4
12348: PPUSH
12349: CALL_OW 128
// end ;
12353: GO 12276
12355: POP
12356: POP
// Wait ( 0 0$01 ) ;
12357: LD_INT 35
12359: PPUSH
12360: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
12364: LD_INT 208
12366: PPUSH
12367: LD_INT 62
12369: PPUSH
12370: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12374: LD_INT 208
12376: PPUSH
12377: LD_INT 62
12379: PPUSH
12380: LD_INT 1
12382: PPUSH
12383: LD_INT 10
12385: NEG
12386: PPUSH
12387: CALL_OW 330
// Wait ( 0 0$15 ) ;
12391: LD_INT 525
12393: PPUSH
12394: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
12398: LD_INT 208
12400: PPUSH
12401: LD_INT 62
12403: PPUSH
12404: LD_INT 1
12406: PPUSH
12407: CALL_OW 331
// ResetFog ;
12411: CALL_OW 335
// InGameOff ;
12415: CALL_OW 9
// end ;
12419: LD_VAR 0 1
12423: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
12424: LD_INT 10
12426: PPUSH
12427: LD_INT 22
12429: PUSH
12430: LD_INT 1
12432: PUSH
12433: EMPTY
12434: LIST
12435: LIST
12436: PPUSH
12437: CALL_OW 70
12441: PUSH
12442: LD_EXP 41
12446: PPUSH
12447: CALL_OW 302
12451: AND
12452: PUSH
12453: LD_INT 22
12455: PUSH
12456: LD_INT 1
12458: PUSH
12459: EMPTY
12460: LIST
12461: LIST
12462: PPUSH
12463: CALL_OW 69
12467: PPUSH
12468: LD_EXP 41
12472: PPUSH
12473: CALL_OW 74
12477: PPUSH
12478: LD_EXP 41
12482: PPUSH
12483: CALL_OW 296
12487: PUSH
12488: LD_INT 30
12490: LESS
12491: OR
12492: IFFALSE 12543
12494: GO 12496
12496: DISABLE
// begin enable ;
12497: ENABLE
// powell_warn := powell_warn + 1 ;
12498: LD_ADDR_EXP 33
12502: PUSH
12503: LD_EXP 33
12507: PUSH
12508: LD_INT 1
12510: PLUS
12511: ST_TO_ADDR
// if powell_warn = 3 then
12512: LD_EXP 33
12516: PUSH
12517: LD_INT 3
12519: EQUAL
12520: IFFALSE 12531
// begin YouLost ( 5 ) ;
12522: LD_STRING 5
12524: PPUSH
12525: CALL_OW 104
// exit ;
12529: GO 12543
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
12531: LD_EXP 43
12535: PPUSH
12536: LD_STRING DWarn-Pow-1
12538: PPUSH
12539: CALL_OW 94
// end ; end_of_file
12543: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
12544: LD_EXP 8
12548: IFFALSE 13884
12550: GO 12552
12552: DISABLE
12553: LD_INT 0
12555: PPUSH
12556: PPUSH
12557: PPUSH
12558: PPUSH
12559: PPUSH
12560: PPUSH
12561: PPUSH
12562: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
12563: LD_EXP 41
12567: PUSH
12568: LD_EXP 42
12572: ADD
12573: PUSH
12574: LD_EXP 6
12578: ADD
12579: PPUSH
12580: LD_INT 250
12582: PPUSH
12583: LD_INT 120
12585: PPUSH
12586: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff [ Bierezov ] ;
12590: LD_ADDR_VAR 0 2
12594: PUSH
12595: LD_EXP 6
12599: PPUSH
12600: LD_INT 25
12602: PUSH
12603: LD_INT 2
12605: PUSH
12606: EMPTY
12607: LIST
12608: LIST
12609: PPUSH
12610: CALL_OW 72
12614: PUSH
12615: LD_EXP 42
12619: PUSH
12620: EMPTY
12621: LIST
12622: DIFF
12623: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
12624: LD_ADDR_VAR 0 3
12628: PUSH
12629: LD_EXP 6
12633: PPUSH
12634: LD_INT 21
12636: PUSH
12637: LD_INT 1
12639: PUSH
12640: EMPTY
12641: LIST
12642: LIST
12643: PPUSH
12644: CALL_OW 72
12648: ST_TO_ADDR
// if not has_eng then
12649: LD_VAR 0 2
12653: NOT
12654: IFFALSE 12737
// begin uc_side := 4 ;
12656: LD_ADDR_OWVAR 20
12660: PUSH
12661: LD_INT 4
12663: ST_TO_ADDR
// uc_nation := 1 ;
12664: LD_ADDR_OWVAR 21
12668: PUSH
12669: LD_INT 1
12671: ST_TO_ADDR
// bc_type := b_depot ;
12672: LD_ADDR_OWVAR 42
12676: PUSH
12677: LD_INT 0
12679: ST_TO_ADDR
// bc_level := 2 ;
12680: LD_ADDR_OWVAR 43
12684: PUSH
12685: LD_INT 2
12687: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
12688: LD_ADDR_VAR 0 4
12692: PUSH
12693: LD_INT 264
12695: PPUSH
12696: LD_INT 120
12698: PPUSH
12699: LD_INT 4
12701: PPUSH
12702: CALL_OW 47
12706: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
12707: LD_INT 264
12709: PPUSH
12710: LD_INT 120
12712: PPUSH
12713: LD_INT 4
12715: PPUSH
12716: LD_INT 10
12718: NEG
12719: PPUSH
12720: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
12724: LD_INT 264
12726: PPUSH
12727: LD_INT 120
12729: PPUSH
12730: LD_INT 4
12732: PPUSH
12733: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
12737: LD_INT 35
12739: PPUSH
12740: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
12744: LD_EXP 41
12748: PPUSH
12749: LD_INT 10
12751: PPUSH
12752: CALL_OW 308
12756: IFFALSE 12737
// if has_eng and not dep then
12758: LD_VAR 0 2
12762: PUSH
12763: LD_VAR 0 4
12767: NOT
12768: AND
12769: IFFALSE 12919
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
12771: LD_VAR 0 2
12775: PPUSH
12776: LD_INT 0
12778: PPUSH
12779: LD_INT 264
12781: PPUSH
12782: LD_INT 120
12784: PPUSH
12785: LD_INT 4
12787: PPUSH
12788: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
12792: LD_INT 35
12794: PPUSH
12795: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
12799: LD_INT 22
12801: PUSH
12802: LD_INT 4
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: PUSH
12809: LD_INT 30
12811: PUSH
12812: LD_INT 0
12814: PUSH
12815: EMPTY
12816: LIST
12817: LIST
12818: PUSH
12819: EMPTY
12820: LIST
12821: LIST
12822: PPUSH
12823: CALL_OW 69
12827: IFFALSE 12792
// ComMoveXY ( filter , 264 , 120 ) ;
12829: LD_VAR 0 3
12833: PPUSH
12834: LD_INT 264
12836: PPUSH
12837: LD_INT 120
12839: PPUSH
12840: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
12844: LD_INT 35
12846: PPUSH
12847: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
12851: LD_INT 22
12853: PUSH
12854: LD_INT 4
12856: PUSH
12857: EMPTY
12858: LIST
12859: LIST
12860: PUSH
12861: LD_INT 30
12863: PUSH
12864: LD_INT 0
12866: PUSH
12867: EMPTY
12868: LIST
12869: LIST
12870: PUSH
12871: LD_INT 3
12873: PUSH
12874: LD_INT 57
12876: PUSH
12877: EMPTY
12878: LIST
12879: PUSH
12880: EMPTY
12881: LIST
12882: LIST
12883: PUSH
12884: EMPTY
12885: LIST
12886: LIST
12887: LIST
12888: PPUSH
12889: CALL_OW 69
12893: IFFALSE 12844
// ComMoveXY ( filter , 247 , 113 ) ;
12895: LD_VAR 0 3
12899: PPUSH
12900: LD_INT 247
12902: PPUSH
12903: LD_INT 113
12905: PPUSH
12906: CALL_OW 111
// Wait ( 0 0$2 ) ;
12910: LD_INT 70
12912: PPUSH
12913: CALL_OW 67
// end else
12917: GO 12931
// begin SetSide ( dep , 4 ) ;
12919: LD_VAR 0 4
12923: PPUSH
12924: LD_INT 4
12926: PPUSH
12927: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
12931: LD_ADDR_VAR 0 4
12935: PUSH
12936: LD_INT 22
12938: PUSH
12939: LD_INT 4
12941: PUSH
12942: EMPTY
12943: LIST
12944: LIST
12945: PUSH
12946: LD_INT 30
12948: PUSH
12949: LD_INT 0
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: PPUSH
12960: CALL_OW 69
12964: PUSH
12965: LD_INT 1
12967: ARRAY
12968: ST_TO_ADDR
// for i = 1 to 3 - has_eng do
12969: LD_ADDR_VAR 0 1
12973: PUSH
12974: DOUBLE
12975: LD_INT 1
12977: DEC
12978: ST_TO_ADDR
12979: LD_INT 3
12981: PUSH
12982: LD_VAR 0 2
12986: MINUS
12987: PUSH
12988: FOR_TO
12989: IFFALSE 13069
// begin if GetClass ( filter [ i ] ) = 2 then
12991: LD_VAR 0 3
12995: PUSH
12996: LD_VAR 0 1
13000: ARRAY
13001: PPUSH
13002: CALL_OW 257
13006: PUSH
13007: LD_INT 2
13009: EQUAL
13010: IFFALSE 13014
// continue ;
13012: GO 12988
// ComEnterUnit ( filter [ i ] , dep ) ;
13014: LD_VAR 0 3
13018: PUSH
13019: LD_VAR 0 1
13023: ARRAY
13024: PPUSH
13025: LD_VAR 0 4
13029: PPUSH
13030: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
13034: LD_VAR 0 3
13038: PUSH
13039: LD_VAR 0 1
13043: ARRAY
13044: PPUSH
13045: LD_INT 2
13047: PPUSH
13048: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
13052: LD_VAR 0 3
13056: PUSH
13057: LD_VAR 0 1
13061: ARRAY
13062: PPUSH
13063: CALL_OW 182
// end ;
13067: GO 12988
13069: POP
13070: POP
// repeat wait ( 0 0$01 ) ;
13071: LD_INT 35
13073: PPUSH
13074: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
13078: LD_VAR 0 3
13082: PPUSH
13083: LD_INT 25
13085: PUSH
13086: LD_INT 2
13088: PUSH
13089: EMPTY
13090: LIST
13091: LIST
13092: PPUSH
13093: CALL_OW 72
13097: PUSH
13098: LD_INT 3
13100: EQUAL
13101: IFFALSE 13071
// if IsInUnit ( Cornel ) then
13103: LD_EXP 41
13107: PPUSH
13108: CALL_OW 310
13112: IFFALSE 13195
// begin cargo := IsInUnit ( Cornel ) ;
13114: LD_ADDR_VAR 0 7
13118: PUSH
13119: LD_EXP 41
13123: PPUSH
13124: CALL_OW 310
13128: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13129: LD_VAR 0 7
13133: PPUSH
13134: LD_INT 1
13136: PPUSH
13137: CALL_OW 289
13141: IFFALSE 13157
// ComGive ( Cornel , dep ) ;
13143: LD_EXP 41
13147: PPUSH
13148: LD_VAR 0 4
13152: PPUSH
13153: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13157: LD_EXP 41
13161: PPUSH
13162: LD_INT 235
13164: PPUSH
13165: LD_INT 122
13167: PPUSH
13168: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13172: LD_EXP 41
13176: PPUSH
13177: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13181: LD_EXP 41
13185: PPUSH
13186: LD_VAR 0 4
13190: PPUSH
13191: CALL_OW 180
// end ; if Bierezov then
13195: LD_EXP 42
13199: IFFALSE 13215
// ComEnterUnit ( Bierezov , dep ) ;
13201: LD_EXP 42
13205: PPUSH
13206: LD_VAR 0 4
13210: PPUSH
13211: CALL_OW 120
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
13215: LD_ADDR_VAR 0 2
13219: PUSH
13220: LD_EXP 6
13224: PPUSH
13225: LD_INT 25
13227: PUSH
13228: LD_INT 2
13230: PUSH
13231: EMPTY
13232: LIST
13233: LIST
13234: PPUSH
13235: CALL_OW 72
13239: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13240: LD_INT 35
13242: PPUSH
13243: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13247: LD_ADDR_VAR 0 6
13251: PUSH
13252: LD_INT 10
13254: PPUSH
13255: CALL_OW 435
13259: ST_TO_ADDR
// if crates then
13260: LD_VAR 0 6
13264: IFFALSE 13293
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
13266: LD_VAR 0 2
13270: PPUSH
13271: LD_VAR 0 6
13275: PUSH
13276: LD_INT 1
13278: ARRAY
13279: PPUSH
13280: LD_VAR 0 6
13284: PUSH
13285: LD_INT 2
13287: ARRAY
13288: PPUSH
13289: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
13293: LD_VAR 0 4
13297: PPUSH
13298: CALL_OW 274
13302: PPUSH
13303: LD_INT 1
13305: PPUSH
13306: CALL_OW 275
13310: PUSH
13311: LD_INT 40
13313: GREATEREQUAL
13314: IFFALSE 13240
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
13316: LD_ADDR_VAR 0 5
13320: PUSH
13321: LD_INT 4
13323: PUSH
13324: LD_INT 256
13326: PUSH
13327: LD_INT 111
13329: PUSH
13330: LD_INT 2
13332: PUSH
13333: EMPTY
13334: LIST
13335: LIST
13336: LIST
13337: LIST
13338: PUSH
13339: LD_INT 31
13341: PUSH
13342: LD_INT 243
13344: PUSH
13345: LD_INT 112
13347: PUSH
13348: LD_INT 2
13350: PUSH
13351: EMPTY
13352: LIST
13353: LIST
13354: LIST
13355: LIST
13356: PUSH
13357: EMPTY
13358: LIST
13359: LIST
13360: ST_TO_ADDR
// for i in blist do
13361: LD_ADDR_VAR 0 1
13365: PUSH
13366: LD_VAR 0 5
13370: PUSH
13371: FOR_IN
13372: IFFALSE 13421
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
13374: LD_VAR 0 2
13378: PPUSH
13379: LD_VAR 0 1
13383: PUSH
13384: LD_INT 1
13386: ARRAY
13387: PPUSH
13388: LD_VAR 0 1
13392: PUSH
13393: LD_INT 2
13395: ARRAY
13396: PPUSH
13397: LD_VAR 0 1
13401: PUSH
13402: LD_INT 3
13404: ARRAY
13405: PPUSH
13406: LD_VAR 0 1
13410: PUSH
13411: LD_INT 4
13413: ARRAY
13414: PPUSH
13415: CALL_OW 205
13419: GO 13371
13421: POP
13422: POP
// repeat wait ( 0 0$01 ) ;
13423: LD_INT 35
13425: PPUSH
13426: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
13430: LD_INT 22
13432: PUSH
13433: LD_INT 4
13435: PUSH
13436: EMPTY
13437: LIST
13438: LIST
13439: PUSH
13440: LD_INT 30
13442: PUSH
13443: LD_INT 4
13445: PUSH
13446: EMPTY
13447: LIST
13448: LIST
13449: PUSH
13450: LD_INT 3
13452: PUSH
13453: LD_INT 57
13455: PUSH
13456: EMPTY
13457: LIST
13458: PUSH
13459: EMPTY
13460: LIST
13461: LIST
13462: PUSH
13463: EMPTY
13464: LIST
13465: LIST
13466: LIST
13467: PPUSH
13468: CALL_OW 69
13472: IFFALSE 13423
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
13474: LD_VAR 0 3
13478: PUSH
13479: LD_VAR 0 2
13483: DIFF
13484: PPUSH
13485: LD_INT 22
13487: PUSH
13488: LD_INT 4
13490: PUSH
13491: EMPTY
13492: LIST
13493: LIST
13494: PUSH
13495: LD_INT 30
13497: PUSH
13498: LD_INT 4
13500: PUSH
13501: EMPTY
13502: LIST
13503: LIST
13504: PUSH
13505: EMPTY
13506: LIST
13507: LIST
13508: PPUSH
13509: CALL_OW 69
13513: PUSH
13514: LD_INT 1
13516: ARRAY
13517: PPUSH
13518: CALL_OW 180
// AddComChangeProfession ( filter diff has_eng , 1 ) ;
13522: LD_VAR 0 3
13526: PUSH
13527: LD_VAR 0 2
13531: DIFF
13532: PPUSH
13533: LD_INT 1
13535: PPUSH
13536: CALL_OW 183
// repeat wait ( 0 0$01 ) ;
13540: LD_INT 35
13542: PPUSH
13543: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
13547: LD_INT 22
13549: PUSH
13550: LD_INT 4
13552: PUSH
13553: EMPTY
13554: LIST
13555: LIST
13556: PUSH
13557: LD_INT 30
13559: PUSH
13560: LD_INT 31
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PUSH
13567: LD_INT 3
13569: PUSH
13570: LD_INT 57
13572: PUSH
13573: EMPTY
13574: LIST
13575: PUSH
13576: EMPTY
13577: LIST
13578: LIST
13579: PUSH
13580: EMPTY
13581: LIST
13582: LIST
13583: LIST
13584: PPUSH
13585: CALL_OW 69
13589: IFFALSE 13540
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
13591: LD_ADDR_VAR 0 8
13595: PUSH
13596: LD_EXP 6
13600: PPUSH
13601: LD_INT 25
13603: PUSH
13604: LD_INT 1
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PPUSH
13611: CALL_OW 72
13615: ST_TO_ADDR
// ComExitBuilding ( sol [ 1 ] ) ;
13616: LD_VAR 0 8
13620: PUSH
13621: LD_INT 1
13623: ARRAY
13624: PPUSH
13625: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
13629: LD_VAR 0 8
13633: PUSH
13634: LD_INT 1
13636: ARRAY
13637: PPUSH
13638: LD_INT 22
13640: PUSH
13641: LD_INT 4
13643: PUSH
13644: EMPTY
13645: LIST
13646: LIST
13647: PUSH
13648: LD_INT 30
13650: PUSH
13651: LD_INT 31
13653: PUSH
13654: EMPTY
13655: LIST
13656: LIST
13657: PUSH
13658: EMPTY
13659: LIST
13660: LIST
13661: PPUSH
13662: CALL_OW 69
13666: PUSH
13667: LD_INT 1
13669: ARRAY
13670: PPUSH
13671: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
13675: LD_VAR 0 2
13679: PPUSH
13680: LD_VAR 0 4
13684: PPUSH
13685: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
13689: LD_INT 35
13691: PPUSH
13692: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13696: LD_ADDR_VAR 0 3
13700: PUSH
13701: LD_INT 22
13703: PUSH
13704: LD_INT 4
13706: PUSH
13707: EMPTY
13708: LIST
13709: LIST
13710: PUSH
13711: LD_INT 21
13713: PUSH
13714: LD_INT 3
13716: PUSH
13717: EMPTY
13718: LIST
13719: LIST
13720: PUSH
13721: LD_INT 3
13723: PUSH
13724: LD_INT 24
13726: PUSH
13727: LD_INT 1000
13729: PUSH
13730: EMPTY
13731: LIST
13732: LIST
13733: PUSH
13734: EMPTY
13735: LIST
13736: LIST
13737: PUSH
13738: EMPTY
13739: LIST
13740: LIST
13741: LIST
13742: PPUSH
13743: CALL_OW 69
13747: ST_TO_ADDR
// if filter and has_eng then
13748: LD_VAR 0 3
13752: PUSH
13753: LD_VAR 0 2
13757: AND
13758: IFFALSE 13824
// begin for i in has_eng do
13760: LD_ADDR_VAR 0 1
13764: PUSH
13765: LD_VAR 0 2
13769: PUSH
13770: FOR_IN
13771: IFFALSE 13820
// begin if IsInUnit ( i ) then
13773: LD_VAR 0 1
13777: PPUSH
13778: CALL_OW 310
13782: IFFALSE 13793
// ComExitBuilding ( i ) ;
13784: LD_VAR 0 1
13788: PPUSH
13789: CALL_OW 122
// Wait ( 3 ) ;
13793: LD_INT 3
13795: PPUSH
13796: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
13800: LD_VAR 0 1
13804: PPUSH
13805: LD_VAR 0 3
13809: PUSH
13810: LD_INT 1
13812: ARRAY
13813: PPUSH
13814: CALL_OW 130
// end ;
13818: GO 13770
13820: POP
13821: POP
// end else
13822: GO 13878
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
13824: LD_VAR 0 2
13828: PUSH
13829: LD_VAR 0 2
13833: PPUSH
13834: LD_INT 56
13836: PUSH
13837: EMPTY
13838: LIST
13839: PPUSH
13840: CALL_OW 72
13844: AND
13845: IFFALSE 13878
// for i in has_eng do
13847: LD_ADDR_VAR 0 1
13851: PUSH
13852: LD_VAR 0 2
13856: PUSH
13857: FOR_IN
13858: IFFALSE 13876
// ComEnterUnit ( i , dep ) ;
13860: LD_VAR 0 1
13864: PPUSH
13865: LD_VAR 0 4
13869: PPUSH
13870: CALL_OW 120
13874: GO 13857
13876: POP
13877: POP
// until cornel_prepared ;
13878: LD_EXP 11
13882: IFFALSE 13689
// end ;
13884: PPOPN 8
13886: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
13887: LD_EXP 11
13891: IFFALSE 14240
13893: GO 13895
13895: DISABLE
13896: LD_INT 0
13898: PPUSH
13899: PPUSH
13900: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
13901: LD_ADDR_VAR 0 2
13905: PUSH
13906: LD_INT 22
13908: PUSH
13909: LD_INT 4
13911: PUSH
13912: EMPTY
13913: LIST
13914: LIST
13915: PUSH
13916: LD_INT 30
13918: PUSH
13919: LD_INT 4
13921: PUSH
13922: EMPTY
13923: LIST
13924: LIST
13925: PUSH
13926: EMPTY
13927: LIST
13928: LIST
13929: PPUSH
13930: CALL_OW 69
13934: PUSH
13935: LD_INT 1
13937: ARRAY
13938: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
13939: LD_EXP 6
13943: PPUSH
13944: CALL_OW 122
// Wait ( 0 0$03 ) ;
13948: LD_INT 105
13950: PPUSH
13951: CALL_OW 67
// for i in cornel_units do
13955: LD_ADDR_VAR 0 1
13959: PUSH
13960: LD_EXP 6
13964: PUSH
13965: FOR_IN
13966: IFFALSE 14042
// begin if GetClass ( i ) in [ 2 , 3 ] then
13968: LD_VAR 0 1
13972: PPUSH
13973: CALL_OW 257
13977: PUSH
13978: LD_INT 2
13980: PUSH
13981: LD_INT 3
13983: PUSH
13984: EMPTY
13985: LIST
13986: LIST
13987: IN
13988: IFFALSE 14025
// begin ComEnterUnit ( i , arm ) ;
13990: LD_VAR 0 1
13994: PPUSH
13995: LD_VAR 0 2
13999: PPUSH
14000: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
14004: LD_VAR 0 1
14008: PPUSH
14009: LD_INT 1
14011: PPUSH
14012: CALL_OW 183
// AddComExitBuilding ( i ) ;
14016: LD_VAR 0 1
14020: PPUSH
14021: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
14025: LD_VAR 0 1
14029: PPUSH
14030: LD_INT 257
14032: PPUSH
14033: LD_INT 121
14035: PPUSH
14036: CALL_OW 171
// end ;
14040: GO 13965
14042: POP
14043: POP
// Wait ( 1 1$00 ) ;
14044: LD_INT 2100
14046: PPUSH
14047: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
14051: LD_ADDR_VAR 0 3
14055: PUSH
14056: LD_EXP 41
14060: PUSH
14061: LD_EXP 42
14065: ADD
14066: PUSH
14067: LD_EXP 6
14071: ADD
14072: PUSH
14073: LD_EXP 6
14077: PPUSH
14078: LD_INT 21
14080: PUSH
14081: LD_INT 2
14083: PUSH
14084: EMPTY
14085: LIST
14086: LIST
14087: PPUSH
14088: CALL_OW 72
14092: DIFF
14093: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
14094: LD_VAR 0 3
14098: PPUSH
14099: LD_INT 248
14101: PPUSH
14102: LD_INT 85
14104: PPUSH
14105: CALL_OW 111
// AddComHold ( filter ) ;
14109: LD_VAR 0 3
14113: PPUSH
14114: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
14118: LD_INT 35
14120: PPUSH
14121: CALL_OW 67
// until cornel_attack ;
14125: LD_EXP 9
14129: IFFALSE 14118
// ComAgressiveMove ( filter , 209 , 63 ) ;
14131: LD_VAR 0 3
14135: PPUSH
14136: LD_INT 209
14138: PPUSH
14139: LD_INT 63
14141: PPUSH
14142: CALL_OW 114
// if Bierezov then
14146: LD_EXP 42
14150: IFFALSE 14240
// begin filter := filter diff Bierezov ;
14152: LD_ADDR_VAR 0 3
14156: PUSH
14157: LD_VAR 0 3
14161: PUSH
14162: LD_EXP 42
14166: DIFF
14167: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
14168: LD_EXP 42
14172: PPUSH
14173: LD_INT 6
14175: PPUSH
14176: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
14180: LD_EXP 42
14184: PPUSH
14185: LD_INT 235
14187: PPUSH
14188: LD_INT 60
14190: PPUSH
14191: CALL_OW 111
// AddComHold ( Bierezov ) ;
14195: LD_EXP 42
14199: PPUSH
14200: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
14204: LD_EXP 42
14208: PPUSH
14209: LD_INT 350
14211: PPUSH
14212: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
14216: LD_EXP 42
14220: PPUSH
14221: LD_INT 198
14223: PPUSH
14224: LD_INT 28
14226: PPUSH
14227: CALL_OW 171
// AddComHold ( Bierezov ) ;
14231: LD_EXP 42
14235: PPUSH
14236: CALL_OW 200
// end ; end ; end_of_file
14240: PPOPN 3
14242: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
14243: LD_EXP 50
14247: PUSH
14248: LD_EXP 29
14252: NOT
14253: AND
14254: PUSH
14255: LD_EXP 30
14259: NOT
14260: AND
14261: IFFALSE 14711
14263: GO 14265
14265: DISABLE
14266: LD_INT 0
14268: PPUSH
14269: PPUSH
14270: PPUSH
14271: PPUSH
// begin enable ;
14272: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14273: LD_ADDR_VAR 0 4
14277: PUSH
14278: LD_INT 81
14280: PUSH
14281: LD_INT 3
14283: PUSH
14284: EMPTY
14285: LIST
14286: LIST
14287: PPUSH
14288: CALL_OW 69
14292: ST_TO_ADDR
// for i = 1 to ru_patrol do
14293: LD_ADDR_VAR 0 2
14297: PUSH
14298: DOUBLE
14299: LD_INT 1
14301: DEC
14302: ST_TO_ADDR
14303: LD_EXP 50
14307: PUSH
14308: FOR_TO
14309: IFFALSE 14709
// begin un := ru_patrol [ i ] ;
14311: LD_ADDR_VAR 0 1
14315: PUSH
14316: LD_EXP 50
14320: PUSH
14321: LD_VAR 0 2
14325: ARRAY
14326: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14327: LD_VAR 0 1
14331: PPUSH
14332: LD_INT 13
14334: PPUSH
14335: CALL_OW 308
14339: IFFALSE 14444
// begin if not ru_alert then
14341: LD_EXP 57
14345: NOT
14346: IFFALSE 14356
// ru_alert := true ;
14348: LD_ADDR_EXP 57
14352: PUSH
14353: LD_INT 1
14355: ST_TO_ADDR
// if not See ( 1 , un ) then
14356: LD_INT 1
14358: PPUSH
14359: LD_VAR 0 1
14363: PPUSH
14364: CALL_OW 292
14368: NOT
14369: IFFALSE 14383
// SetLives ( un , 1000 ) ;
14371: LD_VAR 0 1
14375: PPUSH
14376: LD_INT 1000
14378: PPUSH
14379: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
14383: LD_ADDR_EXP 50
14387: PUSH
14388: LD_EXP 50
14392: PUSH
14393: LD_VAR 0 1
14397: DIFF
14398: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
14399: LD_VAR 0 1
14403: PPUSH
14404: LD_INT 22
14406: PUSH
14407: LD_INT 3
14409: PUSH
14410: EMPTY
14411: LIST
14412: LIST
14413: PUSH
14414: LD_INT 30
14416: PUSH
14417: LD_INT 4
14419: PUSH
14420: EMPTY
14421: LIST
14422: LIST
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: PPUSH
14428: CALL_OW 69
14432: PPUSH
14433: CALL 1031 0 1
14437: PPUSH
14438: CALL_OW 120
// continue ;
14442: GO 14308
// end ; if IsOk ( un ) and not HasTask ( un ) then
14444: LD_VAR 0 1
14448: PPUSH
14449: CALL_OW 302
14453: PUSH
14454: LD_VAR 0 1
14458: PPUSH
14459: CALL_OW 314
14463: NOT
14464: AND
14465: IFFALSE 14558
// begin for j = 1 to ru_firepoints_south [ i ] do
14467: LD_ADDR_VAR 0 3
14471: PUSH
14472: DOUBLE
14473: LD_INT 1
14475: DEC
14476: ST_TO_ADDR
14477: LD_EXP 56
14481: PUSH
14482: LD_VAR 0 2
14486: ARRAY
14487: PUSH
14488: FOR_TO
14489: IFFALSE 14556
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
14491: LD_VAR 0 1
14495: PPUSH
14496: LD_EXP 56
14500: PUSH
14501: LD_VAR 0 2
14505: ARRAY
14506: PUSH
14507: LD_VAR 0 3
14511: ARRAY
14512: PUSH
14513: LD_INT 1
14515: ARRAY
14516: PPUSH
14517: LD_EXP 56
14521: PUSH
14522: LD_VAR 0 2
14526: ARRAY
14527: PUSH
14528: LD_VAR 0 3
14532: ARRAY
14533: PUSH
14534: LD_INT 2
14536: ARRAY
14537: PPUSH
14538: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
14542: LD_VAR 0 1
14546: PPUSH
14547: LD_INT 70
14549: PPUSH
14550: CALL_OW 202
// end ;
14554: GO 14488
14556: POP
14557: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
14558: LD_VAR 0 1
14562: PPUSH
14563: CALL_OW 256
14567: PUSH
14568: LD_INT 700
14570: LESS
14571: PUSH
14572: LD_VAR 0 1
14576: PPUSH
14577: LD_INT 13
14579: PPUSH
14580: CALL_OW 308
14584: NOT
14585: AND
14586: IFFALSE 14638
// begin ComMoveToArea ( un , retreatArea ) ;
14588: LD_VAR 0 1
14592: PPUSH
14593: LD_INT 13
14595: PPUSH
14596: CALL_OW 113
// if not ru_alert_xy then
14600: LD_EXP 58
14604: NOT
14605: IFFALSE 14636
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
14607: LD_ADDR_EXP 58
14611: PUSH
14612: LD_VAR 0 1
14616: PPUSH
14617: CALL_OW 250
14621: PUSH
14622: LD_VAR 0 1
14626: PPUSH
14627: CALL_OW 251
14631: PUSH
14632: EMPTY
14633: LIST
14634: LIST
14635: ST_TO_ADDR
// end else
14636: GO 14707
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
14638: LD_VAR 0 1
14642: PPUSH
14643: LD_VAR 0 4
14647: PPUSH
14648: LD_VAR 0 1
14652: PPUSH
14653: CALL_OW 74
14657: PPUSH
14658: CALL_OW 296
14662: PUSH
14663: LD_INT 9
14665: LESS
14666: PUSH
14667: LD_VAR 0 1
14671: PPUSH
14672: CALL_OW 256
14676: PUSH
14677: LD_INT 500
14679: GREATER
14680: AND
14681: IFFALSE 14707
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
14683: LD_VAR 0 1
14687: PPUSH
14688: LD_VAR 0 4
14692: PPUSH
14693: LD_VAR 0 1
14697: PPUSH
14698: CALL_OW 74
14702: PPUSH
14703: CALL_OW 115
// end ;
14707: GO 14308
14709: POP
14710: POP
// end ;
14711: PPOPN 4
14713: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
14714: LD_EXP 57
14718: PUSH
14719: LD_EXP 58
14723: AND
14724: PUSH
14725: LD_EXP 29
14729: NOT
14730: AND
14731: PUSH
14732: LD_EXP 30
14736: NOT
14737: AND
14738: IFFALSE 14948
14740: GO 14742
14742: DISABLE
14743: LD_INT 0
14745: PPUSH
14746: PPUSH
// begin enable ;
14747: ENABLE
// if not ru_vehicles then
14748: LD_EXP 53
14752: NOT
14753: IFFALSE 14757
// exit ;
14755: GO 14948
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14757: LD_ADDR_VAR 0 2
14761: PUSH
14762: LD_INT 81
14764: PUSH
14765: LD_INT 3
14767: PUSH
14768: EMPTY
14769: LIST
14770: LIST
14771: PPUSH
14772: CALL_OW 69
14776: ST_TO_ADDR
// if ru_vehicles then
14777: LD_EXP 53
14781: IFFALSE 14948
// begin for i in ru_vehicles do
14783: LD_ADDR_VAR 0 1
14787: PUSH
14788: LD_EXP 53
14792: PUSH
14793: FOR_IN
14794: IFFALSE 14946
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
14796: LD_VAR 0 1
14800: PPUSH
14801: CALL_OW 302
14805: PUSH
14806: LD_VAR 0 1
14810: PPUSH
14811: LD_VAR 0 2
14815: PPUSH
14816: LD_VAR 0 1
14820: PPUSH
14821: CALL_OW 74
14825: PPUSH
14826: CALL_OW 296
14830: PUSH
14831: LD_INT 9
14833: LESS
14834: AND
14835: IFFALSE 14861
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
14837: LD_VAR 0 1
14841: PPUSH
14842: LD_VAR 0 2
14846: PPUSH
14847: LD_VAR 0 1
14851: PPUSH
14852: CALL_OW 74
14856: PPUSH
14857: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
14861: LD_VAR 0 1
14865: PPUSH
14866: CALL_OW 314
14870: NOT
14871: PUSH
14872: LD_VAR 0 1
14876: PPUSH
14877: CALL_OW 302
14881: AND
14882: PUSH
14883: LD_VAR 0 1
14887: PPUSH
14888: LD_EXP 58
14892: PUSH
14893: LD_INT 1
14895: ARRAY
14896: PPUSH
14897: LD_EXP 58
14901: PUSH
14902: LD_INT 2
14904: ARRAY
14905: PPUSH
14906: CALL_OW 297
14910: PUSH
14911: LD_INT 10
14913: GREATER
14914: AND
14915: IFFALSE 14944
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
14917: LD_VAR 0 1
14921: PPUSH
14922: LD_EXP 58
14926: PUSH
14927: LD_INT 1
14929: ARRAY
14930: PPUSH
14931: LD_EXP 58
14935: PUSH
14936: LD_INT 2
14938: ARRAY
14939: PPUSH
14940: CALL_OW 114
// end ;
14944: GO 14793
14946: POP
14947: POP
// end ; end ;
14948: PPOPN 2
14950: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
14951: LD_EXP 58
14955: PUSH
14956: LD_EXP 57
14960: AND
14961: PUSH
14962: LD_INT 3
14964: PPUSH
14965: CALL_OW 463
14969: NOT
14970: AND
14971: PUSH
14972: LD_EXP 29
14976: NOT
14977: AND
14978: PUSH
14979: LD_EXP 30
14983: NOT
14984: AND
14985: IFFALSE 15080
14987: GO 14989
14989: DISABLE
14990: LD_INT 0
14992: PPUSH
// begin enable ;
14993: ENABLE
// ru_alert_xy := false ;
14994: LD_ADDR_EXP 58
14998: PUSH
14999: LD_INT 0
15001: ST_TO_ADDR
// ru_alert := false ;
15002: LD_ADDR_EXP 57
15006: PUSH
15007: LD_INT 0
15009: ST_TO_ADDR
// if ru_vehicles then
15010: LD_EXP 53
15014: IFFALSE 15080
// for i in ru_vehicles do
15016: LD_ADDR_VAR 0 1
15020: PUSH
15021: LD_EXP 53
15025: PUSH
15026: FOR_IN
15027: IFFALSE 15078
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
15029: LD_VAR 0 1
15033: PPUSH
15034: CALL_OW 302
15038: PUSH
15039: LD_VAR 0 1
15043: PPUSH
15044: LD_INT 89
15046: PPUSH
15047: LD_INT 36
15049: PPUSH
15050: CALL_OW 297
15054: PUSH
15055: LD_INT 10
15057: GREATER
15058: AND
15059: IFFALSE 15076
// ComMoveXY ( i , 89 , 36 ) ;
15061: LD_VAR 0 1
15065: PPUSH
15066: LD_INT 89
15068: PPUSH
15069: LD_INT 36
15071: PPUSH
15072: CALL_OW 111
15076: GO 15026
15078: POP
15079: POP
// end ;
15080: PPOPN 1
15082: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
15083: LD_EXP 52
15087: PUSH
15088: LD_EXP 29
15092: NOT
15093: AND
15094: PUSH
15095: LD_EXP 30
15099: NOT
15100: AND
15101: IFFALSE 15385
15103: GO 15105
15105: DISABLE
15106: LD_INT 0
15108: PPUSH
15109: PPUSH
15110: PPUSH
// begin enable ;
15111: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15112: LD_ADDR_VAR 0 3
15116: PUSH
15117: LD_INT 81
15119: PUSH
15120: LD_INT 3
15122: PUSH
15123: EMPTY
15124: LIST
15125: LIST
15126: PPUSH
15127: CALL_OW 69
15131: ST_TO_ADDR
// for i = 1 to ru_forest do
15132: LD_ADDR_VAR 0 1
15136: PUSH
15137: DOUBLE
15138: LD_INT 1
15140: DEC
15141: ST_TO_ADDR
15142: LD_EXP 52
15146: PUSH
15147: FOR_TO
15148: IFFALSE 15383
// begin un := ru_forest [ i ] ;
15150: LD_ADDR_VAR 0 2
15154: PUSH
15155: LD_EXP 52
15159: PUSH
15160: LD_VAR 0 1
15164: ARRAY
15165: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15166: LD_VAR 0 2
15170: PPUSH
15171: LD_INT 13
15173: PPUSH
15174: CALL_OW 308
15178: IFFALSE 15268
// begin if not See ( 1 , un ) then
15180: LD_INT 1
15182: PPUSH
15183: LD_VAR 0 2
15187: PPUSH
15188: CALL_OW 292
15192: NOT
15193: IFFALSE 15207
// SetLives ( un , 1000 ) ;
15195: LD_VAR 0 2
15199: PPUSH
15200: LD_INT 1000
15202: PPUSH
15203: CALL_OW 234
// ru_forest := ru_forest diff un ;
15207: LD_ADDR_EXP 52
15211: PUSH
15212: LD_EXP 52
15216: PUSH
15217: LD_VAR 0 2
15221: DIFF
15222: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15223: LD_VAR 0 2
15227: PPUSH
15228: LD_INT 22
15230: PUSH
15231: LD_INT 3
15233: PUSH
15234: EMPTY
15235: LIST
15236: LIST
15237: PUSH
15238: LD_INT 30
15240: PUSH
15241: LD_INT 4
15243: PUSH
15244: EMPTY
15245: LIST
15246: LIST
15247: PUSH
15248: EMPTY
15249: LIST
15250: LIST
15251: PPUSH
15252: CALL_OW 69
15256: PPUSH
15257: CALL 1031 0 1
15261: PPUSH
15262: CALL_OW 120
// continue ;
15266: GO 15147
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15268: LD_VAR 0 2
15272: PPUSH
15273: CALL_OW 256
15277: PUSH
15278: LD_INT 700
15280: LESS
15281: PUSH
15282: LD_VAR 0 2
15286: PPUSH
15287: LD_INT 13
15289: PPUSH
15290: CALL_OW 308
15294: NOT
15295: AND
15296: IFFALSE 15312
// ComMoveToArea ( un , retreatArea ) else
15298: LD_VAR 0 2
15302: PPUSH
15303: LD_INT 13
15305: PPUSH
15306: CALL_OW 113
15310: GO 15381
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15312: LD_VAR 0 2
15316: PPUSH
15317: LD_VAR 0 3
15321: PPUSH
15322: LD_VAR 0 2
15326: PPUSH
15327: CALL_OW 74
15331: PPUSH
15332: CALL_OW 296
15336: PUSH
15337: LD_INT 9
15339: LESS
15340: PUSH
15341: LD_VAR 0 2
15345: PPUSH
15346: CALL_OW 256
15350: PUSH
15351: LD_INT 500
15353: GREATER
15354: AND
15355: IFFALSE 15381
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15357: LD_VAR 0 2
15361: PPUSH
15362: LD_VAR 0 3
15366: PPUSH
15367: LD_VAR 0 2
15371: PPUSH
15372: CALL_OW 74
15376: PPUSH
15377: CALL_OW 115
// end ;
15381: GO 15147
15383: POP
15384: POP
// end ;
15385: PPOPN 3
15387: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
15388: LD_EXP 30
15392: NOT
15393: IFFALSE 15514
15395: GO 15397
15397: DISABLE
15398: LD_INT 0
15400: PPUSH
15401: PPUSH
// begin enable ;
15402: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
15403: LD_ADDR_VAR 0 2
15407: PUSH
15408: LD_INT 22
15410: PUSH
15411: LD_INT 3
15413: PUSH
15414: EMPTY
15415: LIST
15416: LIST
15417: PUSH
15418: LD_INT 21
15420: PUSH
15421: LD_INT 3
15423: PUSH
15424: EMPTY
15425: LIST
15426: LIST
15427: PUSH
15428: EMPTY
15429: LIST
15430: LIST
15431: PPUSH
15432: CALL_OW 69
15436: ST_TO_ADDR
// if filter then
15437: LD_VAR 0 2
15441: IFFALSE 15514
// for i in filter do
15443: LD_ADDR_VAR 0 1
15447: PUSH
15448: LD_VAR 0 2
15452: PUSH
15453: FOR_IN
15454: IFFALSE 15512
// if GetLives ( i ) < 990 then
15456: LD_VAR 0 1
15460: PPUSH
15461: CALL_OW 256
15465: PUSH
15466: LD_INT 990
15468: LESS
15469: IFFALSE 15510
// begin ru_alert := true ;
15471: LD_ADDR_EXP 57
15475: PUSH
15476: LD_INT 1
15478: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
15479: LD_ADDR_EXP 58
15483: PUSH
15484: LD_VAR 0 1
15488: PPUSH
15489: CALL_OW 250
15493: PUSH
15494: LD_VAR 0 1
15498: PPUSH
15499: CALL_OW 251
15503: PUSH
15504: EMPTY
15505: LIST
15506: LIST
15507: ST_TO_ADDR
// break ;
15508: GO 15512
// end ;
15510: GO 15453
15512: POP
15513: POP
// end ;
15514: PPOPN 2
15516: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
15517: LD_EXP 29
15521: IFFALSE 15670
15523: GO 15525
15525: DISABLE
15526: LD_INT 0
15528: PPUSH
15529: PPUSH
15530: PPUSH
15531: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
15532: LD_ADDR_VAR 0 4
15536: PUSH
15537: LD_EXP 53
15541: PUSH
15542: LD_EXP 52
15546: ADD
15547: PUSH
15548: LD_EXP 50
15552: ADD
15553: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
15554: LD_ADDR_VAR 0 3
15558: PUSH
15559: LD_INT 3
15561: PPUSH
15562: LD_INT 81
15564: PUSH
15565: LD_INT 3
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PPUSH
15572: CALL_OW 70
15576: ST_TO_ADDR
// if filter and enemy then
15577: LD_VAR 0 4
15581: PUSH
15582: LD_VAR 0 3
15586: AND
15587: IFFALSE 15670
// repeat wait ( 0 0$01 ) ;
15589: LD_INT 35
15591: PPUSH
15592: CALL_OW 67
// for i in filter do
15596: LD_ADDR_VAR 0 1
15600: PUSH
15601: LD_VAR 0 4
15605: PUSH
15606: FOR_IN
15607: IFFALSE 15635
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15609: LD_VAR 0 1
15613: PPUSH
15614: LD_VAR 0 3
15618: PPUSH
15619: LD_VAR 0 1
15623: PPUSH
15624: CALL_OW 74
15628: PPUSH
15629: CALL_OW 115
// end ;
15633: GO 15606
15635: POP
15636: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
15637: LD_INT 3
15639: PPUSH
15640: LD_INT 81
15642: PUSH
15643: LD_INT 3
15645: PUSH
15646: EMPTY
15647: LIST
15648: LIST
15649: PPUSH
15650: CALL_OW 70
15654: PUSH
15655: LD_INT 0
15657: EQUAL
15658: PUSH
15659: LD_VAR 0 4
15663: PUSH
15664: LD_INT 0
15666: EQUAL
15667: OR
15668: IFFALSE 15589
// end ;
15670: PPOPN 4
15672: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) do var i ;
15673: LD_EXP 25
15677: PUSH
15678: LD_INT 22
15680: PUSH
15681: LD_INT 4
15683: PUSH
15684: EMPTY
15685: LIST
15686: LIST
15687: PUSH
15688: LD_INT 30
15690: PUSH
15691: LD_INT 4
15693: PUSH
15694: EMPTY
15695: LIST
15696: LIST
15697: PUSH
15698: EMPTY
15699: LIST
15700: LIST
15701: PPUSH
15702: CALL_OW 69
15706: AND
15707: IFFALSE 15756
15709: GO 15711
15711: DISABLE
15712: LD_INT 0
15714: PPUSH
// begin if not ru_cornel_attack then
15715: LD_EXP 55
15719: NOT
15720: IFFALSE 15724
// exit ;
15722: GO 15756
// for i in ru_cornel_attack do
15724: LD_ADDR_VAR 0 1
15728: PUSH
15729: LD_EXP 55
15733: PUSH
15734: FOR_IN
15735: IFFALSE 15754
// ComAgressiveMove ( i , 258 , 119 ) ;
15737: LD_VAR 0 1
15741: PPUSH
15742: LD_INT 258
15744: PPUSH
15745: LD_INT 119
15747: PPUSH
15748: CALL_OW 114
15752: GO 15734
15754: POP
15755: POP
// end ; end_of_file
15756: PPOPN 1
15758: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
15759: LD_EXP 5
15763: PUSH
15764: LD_EXP 9
15768: NOT
15769: AND
15770: PUSH
15771: LD_EXP 19
15775: AND
15776: IFFALSE 15888
15778: GO 15780
15780: DISABLE
15781: LD_INT 0
15783: PPUSH
// begin enable ;
15784: ENABLE
// crates_counter := crates_counter - 50 ;
15785: LD_ADDR_EXP 19
15789: PUSH
15790: LD_EXP 19
15794: PUSH
15795: LD_INT 50
15797: MINUS
15798: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
15799: LD_INT 8
15801: PPUSH
15802: LD_INT 2
15804: PPUSH
15805: LD_INT 5
15807: PPUSH
15808: CALL_OW 12
15812: PPUSH
15813: LD_INT 1
15815: PPUSH
15816: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
15820: LD_INT 1785
15822: PPUSH
15823: LD_INT 2345
15825: PPUSH
15826: CALL_OW 12
15830: PPUSH
15831: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
15835: LD_ADDR_VAR 0 1
15839: PUSH
15840: LD_INT 1
15842: PPUSH
15843: LD_OWVAR 67
15847: PUSH
15848: LD_INT 2
15850: PLUS
15851: PPUSH
15852: CALL_OW 12
15856: ST_TO_ADDR
// if r < 3 then
15857: LD_VAR 0 1
15861: PUSH
15862: LD_INT 3
15864: LESS
15865: IFFALSE 15888
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
15867: LD_INT 4
15869: PPUSH
15870: LD_INT 1
15872: PPUSH
15873: LD_INT 5
15875: PPUSH
15876: CALL_OW 12
15880: PPUSH
15881: LD_INT 1
15883: PPUSH
15884: CALL_OW 55
// end ;
15888: PPOPN 1
15890: END
// every 0 0$01 trigger cornel_active do
15891: LD_EXP 8
15895: IFFALSE 15984
15897: GO 15899
15899: DISABLE
// begin Wait ( 0 0$03 ) ;
15900: LD_INT 105
15902: PPUSH
15903: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15907: LD_INT 2
15909: PPUSH
15910: LD_INT 5
15912: PPUSH
15913: CALL_OW 12
15917: PPUSH
15918: LD_INT 10
15920: PPUSH
15921: LD_INT 1
15923: PPUSH
15924: CALL_OW 55
// Wait ( 0 0$13 ) ;
15928: LD_INT 455
15930: PPUSH
15931: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15935: LD_INT 2
15937: PPUSH
15938: LD_INT 5
15940: PPUSH
15941: CALL_OW 12
15945: PPUSH
15946: LD_INT 10
15948: PPUSH
15949: LD_INT 1
15951: PPUSH
15952: CALL_OW 55
// Wait ( 0 0$16 ) ;
15956: LD_INT 560
15958: PPUSH
15959: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15963: LD_INT 2
15965: PPUSH
15966: LD_INT 5
15968: PPUSH
15969: CALL_OW 12
15973: PPUSH
15974: LD_INT 10
15976: PPUSH
15977: LD_INT 1
15979: PPUSH
15980: CALL_OW 55
// end ; end_of_file
15984: END
// every 0 0$01 trigger cornel_prepared do
15985: LD_EXP 11
15989: IFFALSE 16048
15991: GO 15993
15993: DISABLE
// begin enable ;
15994: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
15995: LD_ADDR_OWVAR 47
15999: PUSH
16000: LD_STRING #Am03-1
16002: PUSH
16003: LD_EXP 10
16007: PUSH
16008: EMPTY
16009: LIST
16010: LIST
16011: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
16012: LD_ADDR_EXP 10
16016: PUSH
16017: LD_EXP 10
16021: PPUSH
16022: LD_STRING -
16024: PPUSH
16025: CALL 1101 0 2
16029: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
16030: LD_EXP 10
16034: PUSH
16035: LD_INT 0
16037: EQUAL
16038: IFFALSE 16048
// begin Display_Strings := [ ] ;
16040: LD_ADDR_OWVAR 47
16044: PUSH
16045: EMPTY
16046: ST_TO_ADDR
// disable ;
16047: DISABLE
// end ; end ;
16048: END
// every 0 0$01 trigger debug and debug_strings do
16049: LD_EXP 1
16053: PUSH
16054: LD_OWVAR 48
16058: AND
16059: IFFALSE 16075
16061: GO 16063
16063: DISABLE
// begin enable ;
16064: ENABLE
// Display_Strings := debug_strings ;
16065: LD_ADDR_OWVAR 47
16069: PUSH
16070: LD_OWVAR 48
16074: ST_TO_ADDR
// end ; end_of_file
16075: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
16076: LD_VAR 0 1
16080: PPUSH
16081: CALL_OW 255
16085: PUSH
16086: LD_INT 1
16088: EQUAL
16089: PUSH
16090: LD_EXP 13
16094: NOT
16095: AND
16096: IFFALSE 16106
// solar_builded := true ;
16098: LD_ADDR_EXP 13
16102: PUSH
16103: LD_INT 1
16105: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
16106: LD_VAR 0 1
16110: PPUSH
16111: CALL_OW 255
16115: PUSH
16116: LD_INT 1
16118: EQUAL
16119: PUSH
16120: LD_EXP 27
16124: AND
16125: IFFALSE 16158
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
16127: LD_ADDR_EXP 27
16131: PUSH
16132: LD_EXP 27
16136: PUSH
16137: LD_INT 1750
16139: PUSH
16140: LD_INT 1400
16142: PUSH
16143: LD_INT 1225
16145: PUSH
16146: EMPTY
16147: LIST
16148: LIST
16149: LIST
16150: PUSH
16151: LD_OWVAR 67
16155: ARRAY
16156: PLUS
16157: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
16158: LD_VAR 0 1
16162: PPUSH
16163: CALL_OW 255
16167: PUSH
16168: LD_INT 3
16170: EQUAL
16171: IFFALSE 16189
// ru_vehicles := ru_vehicles ^ veh ;
16173: LD_ADDR_EXP 53
16177: PUSH
16178: LD_EXP 53
16182: PUSH
16183: LD_VAR 0 1
16187: ADD
16188: ST_TO_ADDR
// end ;
16189: PPOPN 2
16191: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
16192: LD_VAR 0 1
16196: PUSH
16197: LD_EXP 50
16201: IN
16202: IFFALSE 16220
// ru_patrol := ru_patrol diff un ;
16204: LD_ADDR_EXP 50
16208: PUSH
16209: LD_EXP 50
16213: PUSH
16214: LD_VAR 0 1
16218: DIFF
16219: ST_TO_ADDR
// if un in ru_forest then
16220: LD_VAR 0 1
16224: PUSH
16225: LD_EXP 52
16229: IN
16230: IFFALSE 16248
// ru_forest := ru_forest diff un ;
16232: LD_ADDR_EXP 52
16236: PUSH
16237: LD_EXP 52
16241: PUSH
16242: LD_VAR 0 1
16246: DIFF
16247: ST_TO_ADDR
// if un in ru_vehicles then
16248: LD_VAR 0 1
16252: PUSH
16253: LD_EXP 53
16257: IN
16258: IFFALSE 16333
// begin ru_vehicles := ru_vehicles diff un ;
16260: LD_ADDR_EXP 53
16264: PUSH
16265: LD_EXP 53
16269: PUSH
16270: LD_VAR 0 1
16274: DIFF
16275: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
16276: LD_ADDR_EXP 54
16280: PUSH
16281: LD_EXP 54
16285: PUSH
16286: LD_VAR 0 1
16290: PPUSH
16291: CALL_OW 265
16295: PUSH
16296: LD_VAR 0 1
16300: PPUSH
16301: CALL_OW 262
16305: PUSH
16306: LD_VAR 0 1
16310: PPUSH
16311: CALL_OW 263
16315: PUSH
16316: LD_VAR 0 1
16320: PPUSH
16321: CALL_OW 264
16325: PUSH
16326: EMPTY
16327: LIST
16328: LIST
16329: LIST
16330: LIST
16331: ADD
16332: ST_TO_ADDR
// end ; if un = JMM then
16333: LD_VAR 0 1
16337: PUSH
16338: LD_EXP 34
16342: EQUAL
16343: IFFALSE 16352
// YouLost ( 0 ) ;
16345: LD_STRING 0
16347: PPUSH
16348: CALL_OW 104
// if un = us_dep_west then
16352: LD_VAR 0 1
16356: PUSH
16357: LD_INT 1
16359: EQUAL
16360: IFFALSE 16369
// YouLost ( 2 ) ;
16362: LD_STRING 2
16364: PPUSH
16365: CALL_OW 104
// if un = Lynch and GetSide ( Lynch ) = 8 then
16369: LD_VAR 0 1
16373: PUSH
16374: LD_EXP 44
16378: EQUAL
16379: PUSH
16380: LD_EXP 44
16384: PPUSH
16385: CALL_OW 255
16389: PUSH
16390: LD_INT 8
16392: EQUAL
16393: AND
16394: IFFALSE 16403
// YouLost ( 4 ) ;
16396: LD_STRING 4
16398: PPUSH
16399: CALL_OW 104
// if un in jmm_units then
16403: LD_VAR 0 1
16407: PUSH
16408: LD_EXP 4
16412: IN
16413: IFFALSE 16429
// lose_counter := lose_counter + 1 ;
16415: LD_ADDR_EXP 32
16419: PUSH
16420: LD_EXP 32
16424: PUSH
16425: LD_INT 1
16427: PLUS
16428: ST_TO_ADDR
// end ;
16429: PPOPN 1
16431: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
16432: LD_INT 0
16434: PPUSH
16435: PPUSH
// begin if GetSide ( driver ) = 3 then
16436: LD_VAR 0 1
16440: PPUSH
16441: CALL_OW 255
16445: PUSH
16446: LD_INT 3
16448: EQUAL
16449: IFFALSE 16527
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
16451: LD_ADDR_VAR 0 6
16455: PUSH
16456: LD_INT 22
16458: PUSH
16459: LD_INT 3
16461: PUSH
16462: EMPTY
16463: LIST
16464: LIST
16465: PUSH
16466: LD_INT 30
16468: PUSH
16469: LD_INT 3
16471: PUSH
16472: EMPTY
16473: LIST
16474: LIST
16475: PUSH
16476: EMPTY
16477: LIST
16478: LIST
16479: PPUSH
16480: CALL_OW 69
16484: PPUSH
16485: CALL 1031 0 1
16489: ST_TO_ADDR
// if place then
16490: LD_VAR 0 6
16494: IFFALSE 16512
// ComEnterUnit ( driver , place ) else
16496: LD_VAR 0 1
16500: PPUSH
16501: LD_VAR 0 6
16505: PPUSH
16506: CALL_OW 120
16510: GO 16527
// ComMoveXY ( driver , 70 , 22 ) ;
16512: LD_VAR 0 1
16516: PPUSH
16517: LD_INT 70
16519: PPUSH
16520: LD_INT 22
16522: PPUSH
16523: CALL_OW 111
// end ; end ;
16527: PPOPN 6
16529: END
// every 0 0$01 trigger not game_end and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) < 4 do
16530: LD_EXP 31
16534: NOT
16535: PUSH
16536: LD_INT 22
16538: PUSH
16539: LD_INT 1
16541: PUSH
16542: EMPTY
16543: LIST
16544: LIST
16545: PUSH
16546: LD_INT 21
16548: PUSH
16549: LD_INT 1
16551: PUSH
16552: EMPTY
16553: LIST
16554: LIST
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: PPUSH
16560: CALL_OW 69
16564: PUSH
16565: LD_INT 22
16567: PUSH
16568: LD_INT 8
16570: PUSH
16571: EMPTY
16572: LIST
16573: LIST
16574: PUSH
16575: LD_INT 21
16577: PUSH
16578: LD_INT 1
16580: PUSH
16581: EMPTY
16582: LIST
16583: LIST
16584: PUSH
16585: EMPTY
16586: LIST
16587: LIST
16588: PPUSH
16589: CALL_OW 69
16593: PLUS
16594: PUSH
16595: LD_INT 4
16597: LESS
16598: AND
16599: IFFALSE 16611
16601: GO 16603
16603: DISABLE
// YouLost ( 1 ) ;
16604: LD_STRING 1
16606: PPUSH
16607: CALL_OW 104
16611: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
16612: LD_INT 1
16614: PPUSH
16615: CALL_OW 255
16619: PUSH
16620: LD_INT 3
16622: EQUAL
16623: IFFALSE 16635
16625: GO 16627
16627: DISABLE
// YouLost ( 3 ) ;
16628: LD_STRING 3
16630: PPUSH
16631: CALL_OW 104
16635: END
