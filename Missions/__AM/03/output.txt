// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 363 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 451 0 0
// PrepareRussian ;
  22: CALL 3008 0 0
// PrepareAmerican ;
  26: CALL 1213 0 0
// PrepareCornell ;
  30: CALL 2237 0 0
// PrepareWesternBase ;
  34: CALL 2463 0 0
// Action ;
  38: CALL 5224 0 0
// end ;
  42: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , cornel_saved , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn , save_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  54: LD_ADDR_EXP 3
  58: PUSH
  59: LD_STRING 02_
  61: ST_TO_ADDR
// mission_prefix := 03_ ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_STRING 03_
  69: ST_TO_ADDR
// jmm_units := 0 ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// cornel_units := 0 ;
  78: LD_ADDR_EXP 6
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// bierezov_exist := false ;
  86: LD_ADDR_EXP 7
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// jmm_on_west := false ;
  94: LD_ADDR_EXP 5
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_active := false ;
 102: LD_ADDR_EXP 8
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_attack := false ;
 110: LD_ADDR_EXP 9
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// cornel_prepared := false ;
 118: LD_ADDR_EXP 11
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 126: LD_ADDR_EXP 10
 130: PUSH
 131: LD_INT 4200
 133: ST_TO_ADDR
// frank_can_return := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// solar_builded := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// frank_send_to_scout := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// jmm_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// bobby_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// cyrus_in_veh := false ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// lisa_in_veh := false ;
 182: LD_ADDR_EXP 18
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 190: LD_ADDR_EXP 28
 194: PUSH
 195: LD_INT 25200
 197: PUSH
 198: LD_INT 23100
 200: PUSH
 201: LD_INT 21000
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: PUSH
 209: LD_OWVAR 67
 213: ARRAY
 214: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 215: LD_ADDR_EXP 19
 219: PUSH
 220: LD_INT 600
 222: PUSH
 223: LD_INT 500
 225: PUSH
 226: LD_INT 400
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: PUSH
 234: LD_OWVAR 67
 238: ARRAY
 239: ST_TO_ADDR
// end_mission_allowed := false ;
 240: LD_ADDR_EXP 20
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// save_others := [ ] ;
 248: LD_ADDR_EXP 21
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// save_group := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// show_query := true ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// wait_for_them := false ;
 270: LD_ADDR_EXP 24
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// veh_on_meta := false ;
 278: LD_ADDR_EXP 27
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_spec_patrol := false ;
 286: LD_ADDR_EXP 29
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// prepare_siege := false ;
 294: LD_ADDR_EXP 30
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// send_attack_on_cornel := false ;
 302: LD_ADDR_EXP 31
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 310: LD_ADDR_EXP 25
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// game_end := false ;
 318: LD_ADDR_EXP 32
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// lose_counter := 0 ;
 326: LD_ADDR_EXP 33
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// powell_warn := 0 ;
 334: LD_ADDR_EXP 34
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// save_counter := 0 ;
 342: LD_ADDR_EXP 35
 346: PUSH
 347: LD_INT 0
 349: ST_TO_ADDR
// cornel_saved := false ;
 350: LD_ADDR_EXP 26
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// end ;
 358: LD_VAR 0 1
 362: RET
// function SetDiplomacy ; begin
 363: LD_INT 0
 365: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 366: LD_INT 1
 368: PPUSH
 369: LD_INT 4
 371: PPUSH
 372: LD_INT 1
 374: PPUSH
 375: LD_INT 1
 377: PPUSH
 378: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 382: LD_INT 1
 384: PPUSH
 385: LD_INT 8
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 398: LD_INT 3
 400: PPUSH
 401: LD_INT 6
 403: PPUSH
 404: LD_INT 1
 406: PPUSH
 407: LD_INT 1
 409: PPUSH
 410: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 414: LD_INT 4
 416: PPUSH
 417: LD_INT 6
 419: PPUSH
 420: LD_INT 0
 422: PPUSH
 423: LD_INT 1
 425: PPUSH
 426: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 430: LD_INT 3
 432: PPUSH
 433: LD_INT 8
 435: PPUSH
 436: LD_INT 0
 438: PPUSH
 439: LD_INT 1
 441: PPUSH
 442: CALL_OW 80
// end ;
 446: LD_VAR 0 1
 450: RET
// export function DebugMode ; var i ; begin
 451: LD_INT 0
 453: PPUSH
 454: PPUSH
// FogOff ( 1 ) ;
 455: LD_INT 1
 457: PPUSH
 458: CALL_OW 344
// debug_strings := [ ] ;
 462: LD_ADDR_OWVAR 48
 466: PUSH
 467: EMPTY
 468: ST_TO_ADDR
// end ; end_of_file
 469: LD_VAR 0 1
 473: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 474: LD_INT 0
 476: PPUSH
 477: PPUSH
// if exist_mode then
 478: LD_VAR 0 2
 482: IFFALSE 507
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 484: LD_ADDR_VAR 0 4
 488: PUSH
 489: LD_EXP 3
 493: PUSH
 494: LD_VAR 0 1
 498: STR
 499: PPUSH
 500: CALL_OW 34
 504: ST_TO_ADDR
 505: GO 522
// unit := NewCharacter ( ident ) ;
 507: LD_ADDR_VAR 0 4
 511: PUSH
 512: LD_VAR 0 1
 516: PPUSH
 517: CALL_OW 25
 521: ST_TO_ADDR
// result := unit ;
 522: LD_ADDR_VAR 0 3
 526: PUSH
 527: LD_VAR 0 4
 531: ST_TO_ADDR
// end ;
 532: LD_VAR 0 3
 536: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 537: LD_INT 0
 539: PPUSH
// uc_side := side ;
 540: LD_ADDR_OWVAR 20
 544: PUSH
 545: LD_VAR 0 1
 549: ST_TO_ADDR
// uc_nation := nation ;
 550: LD_ADDR_OWVAR 21
 554: PUSH
 555: LD_VAR 0 2
 559: ST_TO_ADDR
// vc_chassis := chassis ;
 560: LD_ADDR_OWVAR 37
 564: PUSH
 565: LD_VAR 0 3
 569: ST_TO_ADDR
// vc_engine := engine ;
 570: LD_ADDR_OWVAR 39
 574: PUSH
 575: LD_VAR 0 4
 579: ST_TO_ADDR
// vc_control := control ;
 580: LD_ADDR_OWVAR 38
 584: PUSH
 585: LD_VAR 0 5
 589: ST_TO_ADDR
// vc_weapon := weapon ;
 590: LD_ADDR_OWVAR 40
 594: PUSH
 595: LD_VAR 0 6
 599: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 600: LD_ADDR_OWVAR 41
 604: PUSH
 605: LD_VAR 0 7
 609: ST_TO_ADDR
// result := CreateVehicle ;
 610: LD_ADDR_VAR 0 8
 614: PUSH
 615: CALL_OW 45
 619: ST_TO_ADDR
// end ;
 620: LD_VAR 0 8
 624: RET
// export function SayX ( units , ident ) ; var i ; begin
 625: LD_INT 0
 627: PPUSH
 628: PPUSH
// result := false ;
 629: LD_ADDR_VAR 0 3
 633: PUSH
 634: LD_INT 0
 636: ST_TO_ADDR
// if not units then
 637: LD_VAR 0 1
 641: NOT
 642: IFFALSE 646
// exit ;
 644: GO 700
// for i in units do
 646: LD_ADDR_VAR 0 4
 650: PUSH
 651: LD_VAR 0 1
 655: PUSH
 656: FOR_IN
 657: IFFALSE 698
// if IsOk ( i ) then
 659: LD_VAR 0 4
 663: PPUSH
 664: CALL_OW 302
 668: IFFALSE 696
// begin Say ( i , ident ) ;
 670: LD_VAR 0 4
 674: PPUSH
 675: LD_VAR 0 2
 679: PPUSH
 680: CALL_OW 88
// result := i ;
 684: LD_ADDR_VAR 0 3
 688: PUSH
 689: LD_VAR 0 4
 693: ST_TO_ADDR
// break ;
 694: GO 698
// end ;
 696: GO 656
 698: POP
 699: POP
// end ;
 700: LD_VAR 0 3
 704: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 705: LD_INT 0
 707: PPUSH
 708: PPUSH
 709: PPUSH
 710: PPUSH
// for i = 1 to count do
 711: LD_ADDR_VAR 0 8
 715: PUSH
 716: DOUBLE
 717: LD_INT 1
 719: DEC
 720: ST_TO_ADDR
 721: LD_VAR 0 6
 725: PUSH
 726: FOR_TO
 727: IFFALSE 808
// begin uc_side = side ;
 729: LD_ADDR_OWVAR 20
 733: PUSH
 734: LD_VAR 0 1
 738: ST_TO_ADDR
// uc_nation = nation ;
 739: LD_ADDR_OWVAR 21
 743: PUSH
 744: LD_VAR 0 2
 748: ST_TO_ADDR
// hc_gallery =  ;
 749: LD_ADDR_OWVAR 33
 753: PUSH
 754: LD_STRING 
 756: ST_TO_ADDR
// hc_name =  ;
 757: LD_ADDR_OWVAR 26
 761: PUSH
 762: LD_STRING 
 764: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 765: LD_INT 0
 767: PPUSH
 768: LD_VAR 0 5
 772: PPUSH
 773: LD_VAR 0 4
 777: PPUSH
 778: CALL_OW 380
// un = CreateHuman ;
 782: LD_ADDR_VAR 0 10
 786: PUSH
 787: CALL_OW 44
 791: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 792: LD_VAR 0 10
 796: PPUSH
 797: LD_VAR 0 3
 801: PPUSH
 802: CALL_OW 52
// end ;
 806: GO 726
 808: POP
 809: POP
// end ;
 810: LD_VAR 0 7
 814: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// uc_side := GetSide ( b ) ;
 820: LD_ADDR_OWVAR 20
 824: PUSH
 825: LD_VAR 0 2
 829: PPUSH
 830: CALL_OW 255
 834: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_VAR 0 2
 844: PPUSH
 845: CALL_OW 248
 849: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 850: LD_INT 0
 852: PPUSH
 853: LD_INT 1
 855: PPUSH
 856: LD_VAR 0 1
 860: PPUSH
 861: CALL_OW 380
// un = CreateHuman ;
 865: LD_ADDR_VAR 0 4
 869: PUSH
 870: CALL_OW 44
 874: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 875: LD_ADDR_VAR 0 5
 879: PUSH
 880: LD_VAR 0 2
 884: PPUSH
 885: CALL_OW 254
 889: PUSH
 890: LD_INT 3
 892: MINUS
 893: ST_TO_ADDR
// if dir < 0 then
 894: LD_VAR 0 5
 898: PUSH
 899: LD_INT 0
 901: LESS
 902: IFFALSE 918
// dir := 6 + dir ;
 904: LD_ADDR_VAR 0 5
 908: PUSH
 909: LD_INT 6
 911: PUSH
 912: LD_VAR 0 5
 916: PLUS
 917: ST_TO_ADDR
// SetDir ( un , dir ) ;
 918: LD_VAR 0 4
 922: PPUSH
 923: LD_VAR 0 5
 927: PPUSH
 928: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 932: LD_VAR 0 4
 936: PPUSH
 937: LD_VAR 0 2
 941: PPUSH
 942: CALL_OW 52
// end ;
 946: LD_VAR 0 3
 950: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 951: LD_INT 0
 953: PPUSH
 954: PPUSH
 955: PPUSH
// result := false ;
 956: LD_ADDR_VAR 0 2
 960: PUSH
 961: LD_INT 0
 963: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 964: LD_ADDR_VAR 0 3
 968: PUSH
 969: LD_INT 22
 971: PUSH
 972: LD_INT 1
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 34
 981: PUSH
 982: LD_INT 2
 984: PUSH
 985: EMPTY
 986: LIST
 987: LIST
 988: PUSH
 989: EMPTY
 990: LIST
 991: LIST
 992: PPUSH
 993: CALL_OW 69
 997: ST_TO_ADDR
// for i in filter do
 998: LD_ADDR_VAR 0 4
1002: PUSH
1003: LD_VAR 0 3
1007: PUSH
1008: FOR_IN
1009: IFFALSE 1040
// if IsDrivenBy ( i ) = unit then
1011: LD_VAR 0 4
1015: PPUSH
1016: CALL_OW 311
1020: PUSH
1021: LD_VAR 0 1
1025: EQUAL
1026: IFFALSE 1038
// begin result := true ;
1028: LD_ADDR_VAR 0 2
1032: PUSH
1033: LD_INT 1
1035: ST_TO_ADDR
// break ;
1036: GO 1040
// end ;
1038: GO 1008
1040: POP
1041: POP
// end ;
1042: LD_VAR 0 2
1046: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1047: LD_INT 0
1049: PPUSH
1050: PPUSH
// result := false ;
1051: LD_ADDR_VAR 0 2
1055: PUSH
1056: LD_INT 0
1058: ST_TO_ADDR
// if not blist then
1059: LD_VAR 0 1
1063: NOT
1064: IFFALSE 1068
// exit ;
1066: GO 1112
// for i in blist do
1068: LD_ADDR_VAR 0 3
1072: PUSH
1073: LD_VAR 0 1
1077: PUSH
1078: FOR_IN
1079: IFFALSE 1110
// if UnitsInside ( i ) < 6 then
1081: LD_VAR 0 3
1085: PPUSH
1086: CALL_OW 313
1090: PUSH
1091: LD_INT 6
1093: LESS
1094: IFFALSE 1108
// begin result := i ;
1096: LD_ADDR_VAR 0 2
1100: PUSH
1101: LD_VAR 0 3
1105: ST_TO_ADDR
// break ;
1106: GO 1110
// end ;
1108: GO 1078
1110: POP
1111: POP
// end ;
1112: LD_VAR 0 2
1116: RET
// export function Count ( timer , mode ) ; begin
1117: LD_INT 0
1119: PPUSH
// if not timer then
1120: LD_VAR 0 1
1124: NOT
1125: IFFALSE 1129
// exit ;
1127: GO 1180
// if mode in [ asc , up , + ] then
1129: LD_VAR 0 2
1133: PUSH
1134: LD_STRING asc
1136: PUSH
1137: LD_STRING up
1139: PUSH
1140: LD_STRING +
1142: PUSH
1143: EMPTY
1144: LIST
1145: LIST
1146: LIST
1147: IN
1148: IFFALSE 1166
// result := timer + 0 0$01 else
1150: LD_ADDR_VAR 0 3
1154: PUSH
1155: LD_VAR 0 1
1159: PUSH
1160: LD_INT 35
1162: PLUS
1163: ST_TO_ADDR
1164: GO 1180
// result := timer - 0 0$01 ;
1166: LD_ADDR_VAR 0 3
1170: PUSH
1171: LD_VAR 0 1
1175: PUSH
1176: LD_INT 35
1178: MINUS
1179: ST_TO_ADDR
// end ;
1180: LD_VAR 0 3
1184: RET
// export function Video ( mode ) ; begin
1185: LD_INT 0
1187: PPUSH
// ingame_video = mode ;
1188: LD_ADDR_OWVAR 52
1192: PUSH
1193: LD_VAR 0 1
1197: ST_TO_ADDR
// interface_hidden = mode ;
1198: LD_ADDR_OWVAR 54
1202: PUSH
1203: LD_VAR 0 1
1207: ST_TO_ADDR
// end ; end_of_file
1208: LD_VAR 0 2
1212: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1213: LD_INT 0
1215: PPUSH
1216: PPUSH
1217: PPUSH
1218: PPUSH
1219: PPUSH
1220: PPUSH
1221: PPUSH
1222: PPUSH
// uc_side := 4 ;
1223: LD_ADDR_OWVAR 20
1227: PUSH
1228: LD_INT 4
1230: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1231: LD_ADDR_EXP 45
1235: PUSH
1236: LD_STRING Powell
1238: PPUSH
1239: LD_INT 0
1241: PPUSH
1242: CALL 474 0 2
1246: ST_TO_ADDR
// uc_side := 1 ;
1247: LD_ADDR_OWVAR 20
1251: PUSH
1252: LD_INT 1
1254: ST_TO_ADDR
// uc_nation := 1 ;
1255: LD_ADDR_OWVAR 21
1259: PUSH
1260: LD_INT 1
1262: ST_TO_ADDR
// if debug then
1263: LD_EXP 1
1267: IFFALSE 1397
// begin for i = 1 to 4 do
1269: LD_ADDR_VAR 0 2
1273: PUSH
1274: DOUBLE
1275: LD_INT 1
1277: DEC
1278: ST_TO_ADDR
1279: LD_INT 4
1281: PUSH
1282: FOR_TO
1283: IFFALSE 1334
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1285: LD_INT 0
1287: PPUSH
1288: LD_INT 1
1290: PPUSH
1291: LD_INT 2
1293: PPUSH
1294: CALL_OW 12
1298: PPUSH
1299: LD_INT 3
1301: PPUSH
1302: CALL_OW 380
// un := CreateHuman ;
1306: LD_ADDR_VAR 0 3
1310: PUSH
1311: CALL_OW 44
1315: ST_TO_ADDR
// others := others ^ un ;
1316: LD_ADDR_VAR 0 5
1320: PUSH
1321: LD_VAR 0 5
1325: PUSH
1326: LD_VAR 0 3
1330: ADD
1331: ST_TO_ADDR
// end ;
1332: GO 1282
1334: POP
1335: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1336: LD_ADDR_VAR 0 6
1340: PUSH
1341: LD_INT 21
1343: PUSH
1344: LD_INT 1
1346: PUSH
1347: LD_INT 1
1349: PUSH
1350: LD_INT 51
1352: PUSH
1353: LD_INT 90
1355: PUSH
1356: LD_INT 504
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: LIST
1363: LIST
1364: LIST
1365: LIST
1366: PUSH
1367: LD_INT 21
1369: PUSH
1370: LD_INT 1
1372: PUSH
1373: LD_INT 1
1375: PUSH
1376: LD_INT 51
1378: PUSH
1379: LD_INT 80
1381: PUSH
1382: LD_INT 750
1384: PUSH
1385: EMPTY
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1397: LD_ADDR_EXP 36
1401: PUSH
1402: LD_STRING JMM
1404: PPUSH
1405: LD_EXP 1
1409: NOT
1410: PPUSH
1411: CALL 474 0 2
1415: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1416: LD_ADDR_EXP 37
1420: PUSH
1421: LD_STRING Bobby
1423: PPUSH
1424: LD_EXP 1
1428: NOT
1429: PPUSH
1430: CALL 474 0 2
1434: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1435: LD_ADDR_EXP 38
1439: PUSH
1440: LD_STRING Cyrus
1442: PPUSH
1443: LD_EXP 1
1447: NOT
1448: PPUSH
1449: CALL 474 0 2
1453: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1454: LD_ADDR_EXP 39
1458: PUSH
1459: LD_STRING Lisa
1461: PPUSH
1462: LD_EXP 1
1466: NOT
1467: PPUSH
1468: CALL 474 0 2
1472: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1473: LD_ADDR_EXP 40
1477: PUSH
1478: LD_STRING Khatam
1480: PPUSH
1481: LD_EXP 1
1485: NOT
1486: PPUSH
1487: CALL 474 0 2
1491: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1492: LD_ADDR_EXP 41
1496: PUSH
1497: LD_STRING Brian
1499: PPUSH
1500: LD_EXP 1
1504: NOT
1505: PPUSH
1506: CALL 474 0 2
1510: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1511: LD_ADDR_EXP 42
1515: PUSH
1516: LD_STRING Jerry
1518: PPUSH
1519: LD_EXP 1
1523: NOT
1524: PPUSH
1525: CALL 474 0 2
1529: ST_TO_ADDR
// if Bobby then
1530: LD_EXP 37
1534: IFFALSE 1565
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1536: LD_ADDR_VAR 0 4
1540: PUSH
1541: LD_VAR 0 4
1545: PPUSH
1546: LD_VAR 0 4
1550: PUSH
1551: LD_INT 1
1553: PLUS
1554: PPUSH
1555: LD_EXP 37
1559: PPUSH
1560: CALL_OW 2
1564: ST_TO_ADDR
// if Cyrus then
1565: LD_EXP 38
1569: IFFALSE 1600
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1571: LD_ADDR_VAR 0 4
1575: PUSH
1576: LD_VAR 0 4
1580: PPUSH
1581: LD_VAR 0 4
1585: PUSH
1586: LD_INT 1
1588: PLUS
1589: PPUSH
1590: LD_EXP 38
1594: PPUSH
1595: CALL_OW 2
1599: ST_TO_ADDR
// if Lisa then
1600: LD_EXP 39
1604: IFFALSE 1635
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1606: LD_ADDR_VAR 0 4
1610: PUSH
1611: LD_VAR 0 4
1615: PPUSH
1616: LD_VAR 0 4
1620: PUSH
1621: LD_INT 1
1623: PLUS
1624: PPUSH
1625: LD_EXP 39
1629: PPUSH
1630: CALL_OW 2
1634: ST_TO_ADDR
// if Khatam then
1635: LD_EXP 40
1639: IFFALSE 1670
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1641: LD_ADDR_VAR 0 4
1645: PUSH
1646: LD_VAR 0 4
1650: PPUSH
1651: LD_VAR 0 4
1655: PUSH
1656: LD_INT 1
1658: PLUS
1659: PPUSH
1660: LD_EXP 40
1664: PPUSH
1665: CALL_OW 2
1669: ST_TO_ADDR
// if Brian then
1670: LD_EXP 41
1674: IFFALSE 1705
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1676: LD_ADDR_VAR 0 4
1680: PUSH
1681: LD_VAR 0 4
1685: PPUSH
1686: LD_VAR 0 4
1690: PUSH
1691: LD_INT 1
1693: PLUS
1694: PPUSH
1695: LD_EXP 41
1699: PPUSH
1700: CALL_OW 2
1704: ST_TO_ADDR
// if Jerry then
1705: LD_EXP 42
1709: IFFALSE 1740
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1711: LD_ADDR_VAR 0 4
1715: PUSH
1716: LD_VAR 0 4
1720: PPUSH
1721: LD_VAR 0 4
1725: PUSH
1726: LD_INT 1
1728: PLUS
1729: PPUSH
1730: LD_EXP 42
1734: PPUSH
1735: CALL_OW 2
1739: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1740: LD_STRING 02_other_survivors
1742: PPUSH
1743: CALL_OW 28
1747: IFFALSE 1762
// others := CreateCharacterSet ( 02_other_survivors ) ;
1749: LD_ADDR_VAR 0 5
1753: PUSH
1754: LD_STRING 02_other_survivors
1756: PPUSH
1757: CALL_OW 31
1761: ST_TO_ADDR
// if others then
1762: LD_VAR 0 5
1766: IFFALSE 1791
// begin tmp := tmp ^ others ;
1768: LD_ADDR_VAR 0 4
1772: PUSH
1773: LD_VAR 0 4
1777: PUSH
1778: LD_VAR 0 5
1782: ADD
1783: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1784: LD_STRING 02_other_survivors
1786: PPUSH
1787: CALL_OW 40
// end ; jmm_units := tmp ;
1791: LD_ADDR_EXP 4
1795: PUSH
1796: LD_VAR 0 4
1800: ST_TO_ADDR
// if not vehicles then
1801: LD_VAR 0 6
1805: NOT
1806: IFFALSE 1824
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1808: LD_ADDR_VAR 0 6
1812: PUSH
1813: LD_STRING 02_tanks_1
1815: PPUSH
1816: LD_INT 0
1818: PPUSH
1819: CALL_OW 30
1823: ST_TO_ADDR
// if vehicles then
1824: LD_VAR 0 6
1828: IFFALSE 2022
// begin got_mech := false ;
1830: LD_ADDR_VAR 0 7
1834: PUSH
1835: LD_INT 0
1837: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1838: LD_VAR 0 4
1842: PPUSH
1843: LD_INT 25
1845: PUSH
1846: LD_INT 3
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: PPUSH
1853: CALL_OW 72
1857: IFFALSE 1867
// got_mech := true ;
1859: LD_ADDR_VAR 0 7
1863: PUSH
1864: LD_INT 1
1866: ST_TO_ADDR
// for i = 1 to vehicles do
1867: LD_ADDR_VAR 0 2
1871: PUSH
1872: DOUBLE
1873: LD_INT 1
1875: DEC
1876: ST_TO_ADDR
1877: LD_VAR 0 6
1881: PUSH
1882: FOR_TO
1883: IFFALSE 2020
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1885: LD_ADDR_VAR 0 3
1889: PUSH
1890: LD_INT 1
1892: PPUSH
1893: LD_INT 3
1895: PPUSH
1896: LD_VAR 0 6
1900: PUSH
1901: LD_VAR 0 2
1905: ARRAY
1906: PUSH
1907: LD_INT 1
1909: ARRAY
1910: PPUSH
1911: LD_VAR 0 6
1915: PUSH
1916: LD_VAR 0 2
1920: ARRAY
1921: PUSH
1922: LD_INT 2
1924: ARRAY
1925: PPUSH
1926: LD_VAR 0 6
1930: PUSH
1931: LD_VAR 0 2
1935: ARRAY
1936: PUSH
1937: LD_INT 3
1939: ARRAY
1940: PPUSH
1941: LD_VAR 0 6
1945: PUSH
1946: LD_VAR 0 2
1950: ARRAY
1951: PUSH
1952: LD_INT 4
1954: ARRAY
1955: PPUSH
1956: LD_INT 40
1958: PPUSH
1959: CALL 537 0 7
1963: ST_TO_ADDR
// if not got_mech then
1964: LD_VAR 0 7
1968: NOT
1969: IFFALSE 1995
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1971: LD_VAR 0 3
1975: PPUSH
1976: LD_VAR 0 6
1980: PUSH
1981: LD_VAR 0 2
1985: ARRAY
1986: PUSH
1987: LD_INT 6
1989: ARRAY
1990: PPUSH
1991: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1995: LD_ADDR_VAR 0 4
1999: PUSH
2000: LD_VAR 0 4
2004: PPUSH
2005: LD_INT 1
2007: PPUSH
2008: LD_VAR 0 3
2012: PPUSH
2013: CALL_OW 2
2017: ST_TO_ADDR
// end ;
2018: GO 1882
2020: POP
2021: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
2022: LD_EXP 36
2026: PPUSH
2027: LD_INT 194
2029: PPUSH
2030: LD_INT 119
2032: PPUSH
2033: LD_INT 0
2035: PPUSH
2036: CALL_OW 48
// if tmp then
2040: LD_VAR 0 4
2044: IFFALSE 2169
// begin for i in tmp do
2046: LD_ADDR_VAR 0 2
2050: PUSH
2051: LD_VAR 0 4
2055: PUSH
2056: FOR_IN
2057: IFFALSE 2167
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2059: LD_ADDR_VAR 0 8
2063: PUSH
2064: LD_INT 22
2066: PUSH
2067: LD_INT 1
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: PUSH
2074: LD_INT 21
2076: PUSH
2077: LD_INT 2
2079: PUSH
2080: EMPTY
2081: LIST
2082: LIST
2083: PUSH
2084: LD_INT 58
2086: PUSH
2087: EMPTY
2088: LIST
2089: PUSH
2090: EMPTY
2091: LIST
2092: LIST
2093: LIST
2094: PPUSH
2095: CALL_OW 69
2099: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2100: LD_VAR 0 2
2104: PPUSH
2105: CALL_OW 247
2109: PUSH
2110: LD_INT 1
2112: EQUAL
2113: PUSH
2114: LD_VAR 0 8
2118: AND
2119: IFFALSE 2141
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2121: LD_VAR 0 2
2125: PPUSH
2126: LD_VAR 0 8
2130: PUSH
2131: LD_INT 1
2133: ARRAY
2134: PPUSH
2135: CALL_OW 52
2139: GO 2156
// PlaceUnitArea ( i , startArea , false ) ;
2141: LD_VAR 0 2
2145: PPUSH
2146: LD_INT 1
2148: PPUSH
2149: LD_INT 0
2151: PPUSH
2152: CALL_OW 49
// ComHold ( i ) ;
2156: LD_VAR 0 2
2160: PPUSH
2161: CALL_OW 140
// end ;
2165: GO 2056
2167: POP
2168: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2169: LD_ADDR_EXP 7
2173: PUSH
2174: LD_STRING 02_mikhailStatus_1
2176: PPUSH
2177: LD_INT 0
2179: PPUSH
2180: CALL_OW 30
2184: ST_TO_ADDR
// if not bierezov_exist and not debug then
2185: LD_EXP 7
2189: NOT
2190: PUSH
2191: LD_EXP 1
2195: NOT
2196: AND
2197: IFFALSE 2201
// exit ;
2199: GO 2232
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2201: LD_ADDR_EXP 44
2205: PUSH
2206: LD_STRING Mikhail
2208: PPUSH
2209: LD_INT 0
2211: PPUSH
2212: CALL 474 0 2
2216: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2217: LD_EXP 44
2221: PPUSH
2222: LD_INT 1
2224: PPUSH
2225: LD_INT 0
2227: PPUSH
2228: CALL_OW 49
// end ;
2232: LD_VAR 0 1
2236: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2237: LD_INT 0
2239: PPUSH
2240: PPUSH
2241: PPUSH
2242: PPUSH
// uc_side := 4 ;
2243: LD_ADDR_OWVAR 20
2247: PUSH
2248: LD_INT 4
2250: ST_TO_ADDR
// uc_nation := 1 ;
2251: LD_ADDR_OWVAR 21
2255: PUSH
2256: LD_INT 1
2258: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2259: LD_ADDR_EXP 43
2263: PUSH
2264: LD_STRING Cornell
2266: PPUSH
2267: LD_INT 0
2269: PPUSH
2270: CALL 474 0 2
2274: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2275: LD_ADDR_EXP 6
2279: PUSH
2280: LD_INT 9
2282: PUSH
2283: LD_EXP 4
2287: MINUS
2288: ST_TO_ADDR
// tmp := [ ] ;
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: EMPTY
2295: ST_TO_ADDR
// if cornel_units < 4 then
2296: LD_EXP 6
2300: PUSH
2301: LD_INT 4
2303: LESS
2304: IFFALSE 2314
// cornel_units := 4 ;
2306: LD_ADDR_EXP 6
2310: PUSH
2311: LD_INT 4
2313: ST_TO_ADDR
// for i = 1 to cornel_units do
2314: LD_ADDR_VAR 0 4
2318: PUSH
2319: DOUBLE
2320: LD_INT 1
2322: DEC
2323: ST_TO_ADDR
2324: LD_EXP 6
2328: PUSH
2329: FOR_TO
2330: IFFALSE 2428
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2332: LD_INT 0
2334: PPUSH
2335: LD_INT 1
2337: PUSH
2338: LD_INT 1
2340: PUSH
2341: LD_INT 1
2343: PUSH
2344: LD_INT 2
2346: PUSH
2347: LD_INT 4
2349: PUSH
2350: EMPTY
2351: LIST
2352: LIST
2353: LIST
2354: LIST
2355: LIST
2356: PUSH
2357: LD_VAR 0 4
2361: PUSH
2362: LD_INT 5
2364: MOD
2365: PUSH
2366: LD_INT 1
2368: PLUS
2369: ARRAY
2370: PPUSH
2371: LD_INT 2
2373: PPUSH
2374: CALL_OW 380
// un := CreateHuman ;
2378: LD_ADDR_VAR 0 3
2382: PUSH
2383: CALL_OW 44
2387: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2388: LD_ADDR_VAR 0 2
2392: PUSH
2393: LD_VAR 0 2
2397: PPUSH
2398: LD_INT 1
2400: PPUSH
2401: LD_VAR 0 3
2405: PPUSH
2406: CALL_OW 2
2410: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2411: LD_VAR 0 3
2415: PPUSH
2416: LD_INT 2
2418: PPUSH
2419: LD_INT 0
2421: PPUSH
2422: CALL_OW 49
// end ;
2426: GO 2329
2428: POP
2429: POP
// cornel_units := tmp ;
2430: LD_ADDR_EXP 6
2434: PUSH
2435: LD_VAR 0 2
2439: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2440: LD_EXP 43
2444: PPUSH
2445: LD_INT 191
2447: PPUSH
2448: LD_INT 106
2450: PPUSH
2451: LD_INT 0
2453: PPUSH
2454: CALL_OW 48
// end ;
2458: LD_VAR 0 1
2462: RET
// export function PrepareWesternBase ; var i ; begin
2463: LD_INT 0
2465: PPUSH
2466: PPUSH
// uc_side := 8 ;
2467: LD_ADDR_OWVAR 20
2471: PUSH
2472: LD_INT 8
2474: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2475: LD_ADDR_EXP 46
2479: PUSH
2480: LD_STRING Lynch
2482: PPUSH
2483: LD_INT 0
2485: PPUSH
2486: CALL 474 0 2
2490: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2491: LD_ADDR_EXP 47
2495: PUSH
2496: LD_STRING Walker
2498: PPUSH
2499: LD_INT 0
2501: PPUSH
2502: CALL 474 0 2
2506: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2507: LD_ADDR_EXP 48
2511: PUSH
2512: LD_STRING Turner
2514: PPUSH
2515: LD_INT 0
2517: PPUSH
2518: CALL 474 0 2
2522: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2523: LD_ADDR_EXP 49
2527: PUSH
2528: LD_STRING Jillian
2530: PPUSH
2531: LD_INT 0
2533: PPUSH
2534: CALL 474 0 2
2538: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2539: LD_ADDR_VAR 0 2
2543: PUSH
2544: LD_EXP 46
2548: PUSH
2549: LD_EXP 47
2553: PUSH
2554: LD_EXP 48
2558: PUSH
2559: LD_EXP 49
2563: PUSH
2564: EMPTY
2565: LIST
2566: LIST
2567: LIST
2568: LIST
2569: PUSH
2570: FOR_IN
2571: IFFALSE 2599
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2573: LD_VAR 0 2
2577: PPUSH
2578: LD_INT 3
2580: PPUSH
2581: LD_INT 0
2583: PPUSH
2584: CALL_OW 49
// ComHold ( i ) ;
2588: LD_VAR 0 2
2592: PPUSH
2593: CALL_OW 140
// end ;
2597: GO 2570
2599: POP
2600: POP
// end ;
2601: LD_VAR 0 1
2605: RET
// export function SelectGroup ; var units , selected , i ; begin
2606: LD_INT 0
2608: PPUSH
2609: PPUSH
2610: PPUSH
2611: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2612: LD_ADDR_VAR 0 2
2616: PUSH
2617: LD_EXP 36
2621: PUSH
2622: LD_INT -3
2624: PUSH
2625: EMPTY
2626: LIST
2627: LIST
2628: PUSH
2629: LD_EXP 4
2633: ADD
2634: PUSH
2635: LD_INT -2
2637: PUSH
2638: LD_INT -4
2640: PUSH
2641: LD_EXP 43
2645: PUSH
2646: LD_EXP 44
2650: PUSH
2651: EMPTY
2652: LIST
2653: LIST
2654: LIST
2655: LIST
2656: ADD
2657: PUSH
2658: LD_INT -3
2660: PUSH
2661: EMPTY
2662: LIST
2663: ADD
2664: PUSH
2665: LD_EXP 6
2669: ADD
2670: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: LD_EXP 36
2680: PUSH
2681: LD_STRING Select five characters to go with you
2683: PPUSH
2684: LD_INT 4
2686: PPUSH
2687: LD_INT 4
2689: PPUSH
2690: LD_VAR 0 2
2694: PPUSH
2695: EMPTY
2696: PPUSH
2697: CALL_OW 42
2701: ADD
2702: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2703: LD_ADDR_EXP 6
2707: PUSH
2708: LD_EXP 4
2712: PUSH
2713: LD_EXP 6
2717: UNION
2718: PUSH
2719: LD_VAR 0 3
2723: DIFF
2724: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2725: LD_ADDR_VAR 0 4
2729: PUSH
2730: LD_EXP 6
2734: PUSH
2735: LD_EXP 44
2739: ADD
2740: PUSH
2741: FOR_IN
2742: IFFALSE 2773
// if GetSide ( i ) = 1 then
2744: LD_VAR 0 4
2748: PPUSH
2749: CALL_OW 255
2753: PUSH
2754: LD_INT 1
2756: EQUAL
2757: IFFALSE 2771
// SetSide ( i , 4 ) ;
2759: LD_VAR 0 4
2763: PPUSH
2764: LD_INT 4
2766: PPUSH
2767: CALL_OW 235
2771: GO 2741
2773: POP
2774: POP
// for i in selected do
2775: LD_ADDR_VAR 0 4
2779: PUSH
2780: LD_VAR 0 3
2784: PUSH
2785: FOR_IN
2786: IFFALSE 2817
// if GetSide ( i ) = 4 then
2788: LD_VAR 0 4
2792: PPUSH
2793: CALL_OW 255
2797: PUSH
2798: LD_INT 4
2800: EQUAL
2801: IFFALSE 2815
// SetSide ( i , 1 ) ;
2803: LD_VAR 0 4
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: CALL_OW 235
2815: GO 2785
2817: POP
2818: POP
// jmm_units := jmm_units diff cornel_units ;
2819: LD_ADDR_EXP 4
2823: PUSH
2824: LD_EXP 4
2828: PUSH
2829: LD_EXP 6
2833: DIFF
2834: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2835: LD_EXP 37
2839: PPUSH
2840: CALL_OW 255
2844: PUSH
2845: LD_INT 4
2847: EQUAL
2848: IFFALSE 2863
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2850: LD_EXP 3
2854: PUSH
2855: LD_STRING Bobby
2857: STR
2858: PPUSH
2859: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2863: LD_EXP 38
2867: PPUSH
2868: CALL_OW 255
2872: PUSH
2873: LD_INT 4
2875: EQUAL
2876: IFFALSE 2891
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2878: LD_EXP 3
2882: PUSH
2883: LD_STRING Cyrus
2885: STR
2886: PPUSH
2887: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2891: LD_EXP 39
2895: PPUSH
2896: CALL_OW 255
2900: PUSH
2901: LD_INT 4
2903: EQUAL
2904: IFFALSE 2919
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2906: LD_EXP 3
2910: PUSH
2911: LD_STRING Lisa
2913: STR
2914: PPUSH
2915: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2919: LD_EXP 40
2923: PPUSH
2924: CALL_OW 255
2928: PUSH
2929: LD_INT 4
2931: EQUAL
2932: IFFALSE 2947
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
2934: LD_EXP 3
2938: PUSH
2939: LD_STRING Khatam
2941: STR
2942: PPUSH
2943: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2947: LD_EXP 41
2951: PPUSH
2952: CALL_OW 255
2956: PUSH
2957: LD_INT 4
2959: EQUAL
2960: IFFALSE 2975
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
2962: LD_EXP 3
2966: PUSH
2967: LD_STRING Brian
2969: STR
2970: PPUSH
2971: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2975: LD_EXP 42
2979: PPUSH
2980: CALL_OW 255
2984: PUSH
2985: LD_INT 4
2987: EQUAL
2988: IFFALSE 3003
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
2990: LD_EXP 3
2994: PUSH
2995: LD_STRING Jerry
2997: STR
2998: PPUSH
2999: CALL_OW 40
// end ; end_of_file
3003: LD_VAR 0 1
3007: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
3008: LD_INT 0
3010: PPUSH
3011: PPUSH
3012: PPUSH
3013: PPUSH
3014: PPUSH
3015: PPUSH
3016: PPUSH
3017: PPUSH
3018: PPUSH
3019: PPUSH
3020: PPUSH
3021: PPUSH
3022: PPUSH
// ru_alert := false ;
3023: LD_ADDR_EXP 59
3027: PUSH
3028: LD_INT 0
3030: ST_TO_ADDR
// ru_produce_list := [ ] ;
3031: LD_ADDR_EXP 56
3035: PUSH
3036: EMPTY
3037: ST_TO_ADDR
// if Difficulty > 1 then
3038: LD_OWVAR 67
3042: PUSH
3043: LD_INT 1
3045: GREATER
3046: IFFALSE 3134
// begin uc_side := 3 ;
3048: LD_ADDR_OWVAR 20
3052: PUSH
3053: LD_INT 3
3055: ST_TO_ADDR
// uc_nation := 3 ;
3056: LD_ADDR_OWVAR 21
3060: PUSH
3061: LD_INT 3
3063: ST_TO_ADDR
// bc_type := b_breastwork ;
3064: LD_ADDR_OWVAR 42
3068: PUSH
3069: LD_INT 31
3071: ST_TO_ADDR
// bc_level := Difficulty ;
3072: LD_ADDR_OWVAR 43
3076: PUSH
3077: LD_OWVAR 67
3081: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3082: LD_INT 22
3084: PPUSH
3085: LD_INT 14
3087: PPUSH
3088: LD_INT 0
3090: PPUSH
3091: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3095: LD_INT 48
3097: PPUSH
3098: LD_INT 46
3100: PPUSH
3101: LD_INT 0
3103: PPUSH
3104: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3108: LD_INT 86
3110: PPUSH
3111: LD_INT 65
3113: PPUSH
3114: LD_INT 5
3116: PPUSH
3117: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3121: LD_INT 165
3123: PPUSH
3124: LD_INT 73
3126: PPUSH
3127: LD_INT 5
3129: PPUSH
3130: CALL_OW 47
// end ; if Difficulty = 3 then
3134: LD_OWVAR 67
3138: PUSH
3139: LD_INT 3
3141: EQUAL
3142: IFFALSE 3157
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3144: LD_INT 51
3146: PPUSH
3147: LD_INT 3
3149: PPUSH
3150: LD_INT 2
3152: PPUSH
3153: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3157: LD_ADDR_VAR 0 7
3161: PUSH
3162: LD_INT 22
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: EMPTY
3169: LIST
3170: LIST
3171: PUSH
3172: LD_INT 2
3174: PUSH
3175: LD_INT 30
3177: PUSH
3178: LD_INT 31
3180: PUSH
3181: EMPTY
3182: LIST
3183: LIST
3184: PUSH
3185: LD_INT 30
3187: PUSH
3188: LD_INT 32
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: LIST
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: PPUSH
3204: CALL_OW 69
3208: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3209: LD_ADDR_VAR 0 8
3213: PUSH
3214: LD_INT 22
3216: PUSH
3217: LD_INT 3
3219: PUSH
3220: EMPTY
3221: LIST
3222: LIST
3223: PUSH
3224: LD_INT 30
3226: PUSH
3227: LD_INT 4
3229: PUSH
3230: EMPTY
3231: LIST
3232: LIST
3233: PUSH
3234: EMPTY
3235: LIST
3236: LIST
3237: PPUSH
3238: CALL_OW 69
3242: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3243: LD_ADDR_VAR 0 10
3247: PUSH
3248: LD_INT 22
3250: PUSH
3251: LD_INT 3
3253: PUSH
3254: EMPTY
3255: LIST
3256: LIST
3257: PUSH
3258: LD_INT 30
3260: PUSH
3261: LD_INT 3
3263: PUSH
3264: EMPTY
3265: LIST
3266: LIST
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: PPUSH
3272: CALL_OW 69
3276: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3277: LD_ADDR_VAR 0 9
3281: PUSH
3282: LD_INT 22
3284: PUSH
3285: LD_INT 3
3287: PUSH
3288: EMPTY
3289: LIST
3290: LIST
3291: PUSH
3292: LD_INT 30
3294: PUSH
3295: LD_INT 6
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: PPUSH
3306: CALL_OW 69
3310: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3311: LD_ADDR_VAR 0 2
3315: PUSH
3316: LD_INT 22
3318: PUSH
3319: LD_INT 3
3321: PUSH
3322: EMPTY
3323: LIST
3324: LIST
3325: PUSH
3326: LD_INT 30
3328: PUSH
3329: LD_INT 1
3331: PUSH
3332: EMPTY
3333: LIST
3334: LIST
3335: PUSH
3336: EMPTY
3337: LIST
3338: LIST
3339: PPUSH
3340: CALL_OW 69
3344: PUSH
3345: FOR_IN
3346: IFFALSE 3390
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3348: LD_VAR 0 2
3352: PPUSH
3353: CALL_OW 274
3357: PPUSH
3358: LD_INT 1
3360: PPUSH
3361: LD_INT 5000
3363: PPUSH
3364: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3368: LD_VAR 0 2
3372: PPUSH
3373: CALL_OW 274
3377: PPUSH
3378: LD_INT 2
3380: PPUSH
3381: LD_INT 3000
3383: PPUSH
3384: CALL_OW 277
// end ;
3388: GO 3345
3390: POP
3391: POP
// uc_side := 3 ;
3392: LD_ADDR_OWVAR 20
3396: PUSH
3397: LD_INT 3
3399: ST_TO_ADDR
// uc_nation := 3 ;
3400: LD_ADDR_OWVAR 21
3404: PUSH
3405: LD_INT 3
3407: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3408: LD_ADDR_VAR 0 11
3412: PUSH
3413: LD_INT 2
3415: PUSH
3416: LD_INT 3
3418: PUSH
3419: LD_INT 4
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: LIST
3426: PUSH
3427: LD_OWVAR 67
3431: ARRAY
3432: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3433: LD_ADDR_EXP 51
3437: PUSH
3438: LD_STRING Pokryshkin
3440: PPUSH
3441: LD_INT 0
3443: PPUSH
3444: CALL 474 0 2
3448: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3449: LD_EXP 51
3453: PPUSH
3454: LD_INT 63
3456: PPUSH
3457: LD_INT 21
3459: PPUSH
3460: LD_INT 0
3462: PPUSH
3463: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3467: LD_EXP 51
3471: PPUSH
3472: CALL_OW 140
// InitHc ;
3476: CALL_OW 19
// for i in fac do
3480: LD_ADDR_VAR 0 2
3484: PUSH
3485: LD_VAR 0 10
3489: PUSH
3490: FOR_IN
3491: IFFALSE 3544
// begin for j = 1 to 6 do
3493: LD_ADDR_VAR 0 3
3497: PUSH
3498: DOUBLE
3499: LD_INT 1
3501: DEC
3502: ST_TO_ADDR
3503: LD_INT 6
3505: PUSH
3506: FOR_TO
3507: IFFALSE 3540
// begin PrepareHuman ( false , 3 , skill ) ;
3509: LD_INT 0
3511: PPUSH
3512: LD_INT 3
3514: PPUSH
3515: LD_VAR 0 11
3519: PPUSH
3520: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3524: CALL_OW 44
3528: PPUSH
3529: LD_VAR 0 2
3533: PPUSH
3534: CALL_OW 52
// end ;
3538: GO 3506
3540: POP
3541: POP
// end ;
3542: GO 3490
3544: POP
3545: POP
// for i in lab do
3546: LD_ADDR_VAR 0 2
3550: PUSH
3551: LD_VAR 0 9
3555: PUSH
3556: FOR_IN
3557: IFFALSE 3590
// begin PrepareHuman ( false , 4 , skill ) ;
3559: LD_INT 0
3561: PPUSH
3562: LD_INT 4
3564: PPUSH
3565: LD_VAR 0 11
3569: PPUSH
3570: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3574: CALL_OW 44
3578: PPUSH
3579: LD_VAR 0 2
3583: PPUSH
3584: CALL_OW 52
// end ;
3588: GO 3556
3590: POP
3591: POP
// for i in tw do
3592: LD_ADDR_VAR 0 2
3596: PUSH
3597: LD_VAR 0 7
3601: PUSH
3602: FOR_IN
3603: IFFALSE 3652
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3605: LD_VAR 0 2
3609: PPUSH
3610: LD_INT 42
3612: PUSH
3613: LD_INT 43
3615: PUSH
3616: EMPTY
3617: LIST
3618: LIST
3619: PUSH
3620: LD_INT 1
3622: PPUSH
3623: LD_INT 2
3625: PPUSH
3626: CALL_OW 12
3630: ARRAY
3631: PPUSH
3632: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3636: LD_VAR 0 11
3640: PPUSH
3641: LD_VAR 0 2
3645: PPUSH
3646: CALL 815 0 2
// end ;
3650: GO 3602
3652: POP
3653: POP
// for i in bar do
3654: LD_ADDR_VAR 0 2
3658: PUSH
3659: LD_VAR 0 8
3663: PUSH
3664: FOR_IN
3665: IFFALSE 3698
// begin PrepareHuman ( false , 1 , skill ) ;
3667: LD_INT 0
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: LD_VAR 0 11
3677: PPUSH
3678: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3682: CALL_OW 44
3686: PPUSH
3687: LD_VAR 0 2
3691: PPUSH
3692: CALL_OW 52
// end ;
3696: GO 3664
3698: POP
3699: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3700: LD_ADDR_VAR 0 13
3704: PUSH
3705: LD_INT 100
3707: PUSH
3708: LD_INT 9
3710: PUSH
3711: EMPTY
3712: LIST
3713: LIST
3714: PUSH
3715: LD_INT 135
3717: PUSH
3718: LD_INT 60
3720: PUSH
3721: EMPTY
3722: LIST
3723: LIST
3724: PUSH
3725: LD_INT 41
3727: PUSH
3728: LD_INT 6
3730: PUSH
3731: EMPTY
3732: LIST
3733: LIST
3734: PUSH
3735: LD_INT 22
3737: PUSH
3738: LD_INT 9
3740: PUSH
3741: EMPTY
3742: LIST
3743: LIST
3744: PUSH
3745: LD_INT 84
3747: PUSH
3748: LD_INT 14
3750: PUSH
3751: EMPTY
3752: LIST
3753: LIST
3754: PUSH
3755: EMPTY
3756: LIST
3757: LIST
3758: LIST
3759: LIST
3760: LIST
3761: ST_TO_ADDR
// vehicles := [ ] ;
3762: LD_ADDR_VAR 0 12
3766: PUSH
3767: EMPTY
3768: ST_TO_ADDR
// for i in spot_xy do
3769: LD_ADDR_VAR 0 2
3773: PUSH
3774: LD_VAR 0 13
3778: PUSH
3779: FOR_IN
3780: IFFALSE 3938
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3782: LD_ADDR_VAR 0 6
3786: PUSH
3787: LD_INT 3
3789: PPUSH
3790: LD_INT 3
3792: PPUSH
3793: LD_INT 22
3795: PPUSH
3796: LD_INT 1
3798: PPUSH
3799: LD_INT 1
3801: PPUSH
3802: LD_INT 42
3804: PUSH
3805: LD_INT 43
3807: PUSH
3808: LD_INT 44
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: LIST
3815: PUSH
3816: LD_INT 1
3818: PPUSH
3819: LD_INT 3
3821: PPUSH
3822: CALL_OW 12
3826: ARRAY
3827: PPUSH
3828: LD_INT 100
3830: PPUSH
3831: CALL 537 0 7
3835: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3836: LD_ADDR_VAR 0 12
3840: PUSH
3841: LD_VAR 0 12
3845: PPUSH
3846: LD_VAR 0 12
3850: PUSH
3851: LD_INT 1
3853: PLUS
3854: PPUSH
3855: LD_VAR 0 6
3859: PPUSH
3860: CALL_OW 2
3864: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3865: LD_VAR 0 6
3869: PPUSH
3870: LD_INT 3
3872: PPUSH
3873: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3877: LD_VAR 0 6
3881: PPUSH
3882: LD_VAR 0 2
3886: PUSH
3887: LD_INT 1
3889: ARRAY
3890: PPUSH
3891: LD_VAR 0 2
3895: PUSH
3896: LD_INT 2
3898: ARRAY
3899: PPUSH
3900: LD_INT 0
3902: PPUSH
3903: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3907: LD_INT 0
3909: PPUSH
3910: LD_INT 3
3912: PPUSH
3913: LD_VAR 0 11
3917: PPUSH
3918: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3922: CALL_OW 44
3926: PPUSH
3927: LD_VAR 0 6
3931: PPUSH
3932: CALL_OW 52
// end ;
3936: GO 3779
3938: POP
3939: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3940: LD_ADDR_VAR 0 2
3944: PUSH
3945: DOUBLE
3946: LD_INT 1
3948: DEC
3949: ST_TO_ADDR
3950: LD_INT 5
3952: PUSH
3953: LD_INT 7
3955: PUSH
3956: LD_INT 8
3958: PUSH
3959: EMPTY
3960: LIST
3961: LIST
3962: LIST
3963: PUSH
3964: LD_OWVAR 67
3968: ARRAY
3969: PUSH
3970: FOR_TO
3971: IFFALSE 4031
// begin PrepareHuman ( false , 1 , skill ) ;
3973: LD_INT 0
3975: PPUSH
3976: LD_INT 1
3978: PPUSH
3979: LD_VAR 0 11
3983: PPUSH
3984: CALL_OW 380
// un := CreateHuman ;
3988: LD_ADDR_VAR 0 5
3992: PUSH
3993: CALL_OW 44
3997: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3998: LD_VAR 0 5
4002: PPUSH
4003: LD_INT 11
4005: PPUSH
4006: LD_INT 0
4008: PPUSH
4009: CALL_OW 49
// ru_forest := ru_forest ^ un ;
4013: LD_ADDR_EXP 54
4017: PUSH
4018: LD_EXP 54
4022: PUSH
4023: LD_VAR 0 5
4027: ADD
4028: ST_TO_ADDR
// end ;
4029: GO 3970
4031: POP
4032: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
4033: LD_ADDR_VAR 0 2
4037: PUSH
4038: DOUBLE
4039: LD_INT 1
4041: DEC
4042: ST_TO_ADDR
4043: LD_INT 2
4045: PUSH
4046: LD_INT 3
4048: PUSH
4049: LD_INT 4
4051: PUSH
4052: EMPTY
4053: LIST
4054: LIST
4055: LIST
4056: PUSH
4057: LD_OWVAR 67
4061: ARRAY
4062: PUSH
4063: FOR_TO
4064: IFFALSE 4124
// begin PrepareHuman ( false , 1 , skill ) ;
4066: LD_INT 0
4068: PPUSH
4069: LD_INT 1
4071: PPUSH
4072: LD_VAR 0 11
4076: PPUSH
4077: CALL_OW 380
// un := CreateHuman ;
4081: LD_ADDR_VAR 0 5
4085: PUSH
4086: CALL_OW 44
4090: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4091: LD_VAR 0 5
4095: PPUSH
4096: LD_INT 12
4098: PPUSH
4099: LD_INT 0
4101: PPUSH
4102: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4106: LD_ADDR_EXP 52
4110: PUSH
4111: LD_EXP 52
4115: PUSH
4116: LD_VAR 0 5
4120: ADD
4121: ST_TO_ADDR
// end ;
4122: GO 4063
4124: POP
4125: POP
// for i = 1 to 2 do
4126: LD_ADDR_VAR 0 2
4130: PUSH
4131: DOUBLE
4132: LD_INT 1
4134: DEC
4135: ST_TO_ADDR
4136: LD_INT 2
4138: PUSH
4139: FOR_TO
4140: IFFALSE 4206
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4142: LD_INT 1
4144: PPUSH
4145: LD_INT 1
4147: PPUSH
4148: LD_VAR 0 11
4152: PPUSH
4153: CALL_OW 380
// un := CreateHuman ;
4157: LD_ADDR_VAR 0 5
4161: PUSH
4162: CALL_OW 44
4166: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4167: LD_VAR 0 5
4171: PPUSH
4172: LD_INT 39
4174: PPUSH
4175: LD_INT 12
4177: PPUSH
4178: LD_INT 3
4180: PPUSH
4181: LD_INT 0
4183: PPUSH
4184: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4188: LD_ADDR_EXP 53
4192: PUSH
4193: LD_EXP 53
4197: PUSH
4198: LD_VAR 0 5
4202: ADD
4203: ST_TO_ADDR
// end ;
4204: GO 4139
4206: POP
4207: POP
// for i = 1 to 3 do
4208: LD_ADDR_VAR 0 2
4212: PUSH
4213: DOUBLE
4214: LD_INT 1
4216: DEC
4217: ST_TO_ADDR
4218: LD_INT 3
4220: PUSH
4221: FOR_TO
4222: IFFALSE 4288
// begin PrepareHuman ( false , 1 , skill ) ;
4224: LD_INT 0
4226: PPUSH
4227: LD_INT 1
4229: PPUSH
4230: LD_VAR 0 11
4234: PPUSH
4235: CALL_OW 380
// un := CreateHuman ;
4239: LD_ADDR_VAR 0 5
4243: PUSH
4244: CALL_OW 44
4248: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4249: LD_VAR 0 5
4253: PPUSH
4254: LD_INT 180
4256: PPUSH
4257: LD_INT 11
4259: PPUSH
4260: LD_INT 4
4262: PPUSH
4263: LD_INT 0
4265: PPUSH
4266: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4270: LD_ADDR_EXP 57
4274: PUSH
4275: LD_EXP 57
4279: PUSH
4280: LD_VAR 0 5
4284: ADD
4285: ST_TO_ADDR
// end ;
4286: GO 4221
4288: POP
4289: POP
// ru_vehicles := vehicles ;
4290: LD_ADDR_EXP 55
4294: PUSH
4295: LD_VAR 0 12
4299: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4300: LD_ADDR_EXP 58
4304: PUSH
4305: LD_INT 131
4307: PUSH
4308: LD_INT 121
4310: PUSH
4311: EMPTY
4312: LIST
4313: LIST
4314: PUSH
4315: LD_INT 113
4317: PUSH
4318: LD_INT 90
4320: PUSH
4321: EMPTY
4322: LIST
4323: LIST
4324: PUSH
4325: LD_INT 93
4327: PUSH
4328: LD_INT 62
4330: PUSH
4331: EMPTY
4332: LIST
4333: LIST
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: LIST
4339: PUSH
4340: LD_INT 106
4342: PUSH
4343: LD_INT 54
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 120
4352: PUSH
4353: LD_INT 80
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: LD_INT 143
4362: PUSH
4363: LD_INT 120
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: LIST
4374: PUSH
4375: LD_INT 154
4377: PUSH
4378: LD_INT 116
4380: PUSH
4381: EMPTY
4382: LIST
4383: LIST
4384: PUSH
4385: LD_INT 140
4387: PUSH
4388: LD_INT 93
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 130
4397: PUSH
4398: LD_INT 58
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: LIST
4409: PUSH
4410: LD_INT 105
4412: PUSH
4413: LD_INT 106
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: LD_INT 134
4422: PUSH
4423: LD_INT 98
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 159
4432: PUSH
4433: LD_INT 113
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: LIST
4444: PUSH
4445: EMPTY
4446: LIST
4447: LIST
4448: LIST
4449: LIST
4450: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4451: LD_ADDR_VAR 0 2
4455: PUSH
4456: DOUBLE
4457: LD_INT 1
4459: DEC
4460: ST_TO_ADDR
4461: LD_OWVAR 67
4465: PUSH
4466: LD_INT 1
4468: MINUS
4469: PUSH
4470: FOR_TO
4471: IFFALSE 4504
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4473: LD_ADDR_EXP 56
4477: PUSH
4478: LD_EXP 56
4482: PUSH
4483: LD_INT 22
4485: PUSH
4486: LD_INT 1
4488: PUSH
4489: LD_INT 1
4491: PUSH
4492: LD_INT 43
4494: PUSH
4495: EMPTY
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: ADD
4501: ST_TO_ADDR
4502: GO 4470
4504: POP
4505: POP
// end ;
4506: LD_VAR 0 1
4510: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4511: LD_INT 22
4513: PUSH
4514: LD_INT 3
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: PUSH
4521: LD_INT 21
4523: PUSH
4524: LD_INT 2
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: PUSH
4531: EMPTY
4532: LIST
4533: LIST
4534: PPUSH
4535: CALL_OW 69
4539: IFFALSE 4633
4541: GO 4543
4543: DISABLE
4544: LD_INT 0
4546: PPUSH
4547: PPUSH
// begin enable ;
4548: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4549: LD_ADDR_VAR 0 2
4553: PUSH
4554: LD_INT 22
4556: PUSH
4557: LD_INT 3
4559: PUSH
4560: EMPTY
4561: LIST
4562: LIST
4563: PUSH
4564: LD_INT 21
4566: PUSH
4567: LD_INT 2
4569: PUSH
4570: EMPTY
4571: LIST
4572: LIST
4573: PUSH
4574: EMPTY
4575: LIST
4576: LIST
4577: PPUSH
4578: CALL_OW 69
4582: ST_TO_ADDR
// if filter then
4583: LD_VAR 0 2
4587: IFFALSE 4633
// for i in filter do
4589: LD_ADDR_VAR 0 1
4593: PUSH
4594: LD_VAR 0 2
4598: PUSH
4599: FOR_IN
4600: IFFALSE 4631
// if GetFuel ( i ) < 20 then
4602: LD_VAR 0 1
4606: PPUSH
4607: CALL_OW 261
4611: PUSH
4612: LD_INT 20
4614: LESS
4615: IFFALSE 4629
// SetFuel ( i , 20 ) ;
4617: LD_VAR 0 1
4621: PPUSH
4622: LD_INT 20
4624: PPUSH
4625: CALL_OW 240
4629: GO 4599
4631: POP
4632: POP
// end ;
4633: PPOPN 2
4635: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4636: LD_EXP 56
4640: IFFALSE 4859
4642: GO 4644
4644: DISABLE
4645: LD_INT 0
4647: PPUSH
4648: PPUSH
4649: PPUSH
// begin enable ;
4650: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4651: LD_ADDR_VAR 0 2
4655: PUSH
4656: LD_INT 22
4658: PUSH
4659: LD_INT 3
4661: PUSH
4662: EMPTY
4663: LIST
4664: LIST
4665: PUSH
4666: LD_INT 30
4668: PUSH
4669: LD_INT 3
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: PPUSH
4680: CALL_OW 69
4684: ST_TO_ADDR
// can_produce := [ ] ;
4685: LD_ADDR_VAR 0 3
4689: PUSH
4690: EMPTY
4691: ST_TO_ADDR
// if not fac then
4692: LD_VAR 0 2
4696: NOT
4697: IFFALSE 4702
// begin disable ;
4699: DISABLE
// exit ;
4700: GO 4859
// end ; for i in fac do
4702: LD_ADDR_VAR 0 1
4706: PUSH
4707: LD_VAR 0 2
4711: PUSH
4712: FOR_IN
4713: IFFALSE 4751
// if UnitsInside ( i ) then
4715: LD_VAR 0 1
4719: PPUSH
4720: CALL_OW 313
4724: IFFALSE 4749
// can_produce := Insert ( can_produce , 1 , i ) ;
4726: LD_ADDR_VAR 0 3
4730: PUSH
4731: LD_VAR 0 3
4735: PPUSH
4736: LD_INT 1
4738: PPUSH
4739: LD_VAR 0 1
4743: PPUSH
4744: CALL_OW 2
4748: ST_TO_ADDR
4749: GO 4712
4751: POP
4752: POP
// if not can_produce then
4753: LD_VAR 0 3
4757: NOT
4758: IFFALSE 4762
// exit ;
4760: GO 4859
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4762: LD_VAR 0 3
4766: PUSH
4767: LD_INT 1
4769: PPUSH
4770: LD_VAR 0 3
4774: PPUSH
4775: CALL_OW 12
4779: ARRAY
4780: PPUSH
4781: LD_EXP 56
4785: PUSH
4786: LD_INT 1
4788: ARRAY
4789: PPUSH
4790: LD_EXP 56
4794: PUSH
4795: LD_INT 2
4797: ARRAY
4798: PPUSH
4799: LD_EXP 56
4803: PUSH
4804: LD_INT 3
4806: ARRAY
4807: PPUSH
4808: LD_EXP 56
4812: PUSH
4813: LD_INT 4
4815: ARRAY
4816: PPUSH
4817: CALL_OW 125
// for i = 1 to 4 do
4821: LD_ADDR_VAR 0 1
4825: PUSH
4826: DOUBLE
4827: LD_INT 1
4829: DEC
4830: ST_TO_ADDR
4831: LD_INT 4
4833: PUSH
4834: FOR_TO
4835: IFFALSE 4857
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4837: LD_ADDR_EXP 56
4841: PUSH
4842: LD_EXP 56
4846: PPUSH
4847: LD_INT 1
4849: PPUSH
4850: CALL_OW 3
4854: ST_TO_ADDR
4855: GO 4834
4857: POP
4858: POP
// end ;
4859: PPOPN 3
4861: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4862: LD_INT 0
4864: PPUSH
4865: PPUSH
4866: PPUSH
// for i = 1 to 6 do
4867: LD_ADDR_VAR 0 2
4871: PUSH
4872: DOUBLE
4873: LD_INT 1
4875: DEC
4876: ST_TO_ADDR
4877: LD_INT 6
4879: PUSH
4880: FOR_TO
4881: IFFALSE 5030
// begin PrepareHuman ( false , 3 , 3 ) ;
4883: LD_INT 0
4885: PPUSH
4886: LD_INT 3
4888: PPUSH
4889: LD_INT 3
4891: PPUSH
4892: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4896: LD_ADDR_VAR 0 3
4900: PUSH
4901: LD_INT 3
4903: PPUSH
4904: LD_INT 3
4906: PPUSH
4907: LD_INT 22
4909: PPUSH
4910: LD_INT 1
4912: PPUSH
4913: LD_INT 1
4915: PPUSH
4916: LD_INT 43
4918: PUSH
4919: LD_INT 42
4921: PUSH
4922: EMPTY
4923: LIST
4924: LIST
4925: PUSH
4926: LD_INT 1
4928: PPUSH
4929: LD_INT 2
4931: PPUSH
4932: CALL_OW 12
4936: ARRAY
4937: PPUSH
4938: LD_INT 70
4940: PPUSH
4941: CALL 537 0 7
4945: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4946: LD_VAR 0 3
4950: PPUSH
4951: LD_INT 4
4953: PPUSH
4954: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4958: LD_VAR 0 3
4962: PPUSH
4963: LD_INT 229
4965: PPUSH
4966: LD_INT 44
4968: PPUSH
4969: LD_INT 0
4971: PPUSH
4972: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4976: CALL_OW 44
4980: PPUSH
4981: LD_VAR 0 3
4985: PPUSH
4986: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4990: LD_ADDR_EXP 55
4994: PUSH
4995: LD_EXP 55
4999: PUSH
5000: LD_VAR 0 3
5004: ADD
5005: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
5006: LD_VAR 0 3
5010: PPUSH
5011: LD_INT 191
5013: PPUSH
5014: LD_INT 32
5016: PPUSH
5017: CALL_OW 111
// Wait ( 0 0$02 ) ;
5021: LD_INT 70
5023: PPUSH
5024: CALL_OW 67
// end ;
5028: GO 4880
5030: POP
5031: POP
// end ;
5032: LD_VAR 0 1
5036: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
5037: LD_EXP 30
5041: PUSH
5042: LD_EXP 55
5046: AND
5047: IFFALSE 5221
5049: GO 5051
5051: DISABLE
5052: LD_INT 0
5054: PPUSH
5055: PPUSH
5056: PPUSH
// begin wait ( 0 0$50 ) ;
5057: LD_INT 1750
5059: PPUSH
5060: CALL_OW 67
// tmp := ru_vehicles ;
5064: LD_ADDR_VAR 0 3
5068: PUSH
5069: LD_EXP 55
5073: ST_TO_ADDR
// if not tmp then
5074: LD_VAR 0 3
5078: NOT
5079: IFFALSE 5083
// exit ;
5081: GO 5221
// repeat wait ( 0 0$1 ) ;
5083: LD_INT 35
5085: PPUSH
5086: CALL_OW 67
// for i in tmp do
5090: LD_ADDR_VAR 0 1
5094: PUSH
5095: LD_VAR 0 3
5099: PUSH
5100: FOR_IN
5101: IFFALSE 5212
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5103: LD_ADDR_VAR 0 2
5107: PUSH
5108: LD_INT 22
5110: PUSH
5111: LD_INT 1
5113: PUSH
5114: EMPTY
5115: LIST
5116: LIST
5117: PPUSH
5118: LD_VAR 0 1
5122: PPUSH
5123: CALL_OW 74
5127: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5128: LD_VAR 0 1
5132: PPUSH
5133: LD_VAR 0 2
5137: PPUSH
5138: CALL_OW 296
5142: PUSH
5143: LD_INT 10
5145: GREATER
5146: IFFALSE 5165
// ComAgressiveMove ( i , 69 , 101 ) else
5148: LD_VAR 0 1
5152: PPUSH
5153: LD_INT 69
5155: PPUSH
5156: LD_INT 101
5158: PPUSH
5159: CALL_OW 114
5163: GO 5179
// ComAttackUnit ( i , enemy ) ;
5165: LD_VAR 0 1
5169: PPUSH
5170: LD_VAR 0 2
5174: PPUSH
5175: CALL_OW 115
// if GetLives ( i ) < 250 then
5179: LD_VAR 0 1
5183: PPUSH
5184: CALL_OW 256
5188: PUSH
5189: LD_INT 250
5191: LESS
5192: IFFALSE 5210
// tmp := tmp diff i ;
5194: LD_ADDR_VAR 0 3
5198: PUSH
5199: LD_VAR 0 3
5203: PUSH
5204: LD_VAR 0 1
5208: DIFF
5209: ST_TO_ADDR
// end ;
5210: GO 5100
5212: POP
5213: POP
// until not tmp ;
5214: LD_VAR 0 3
5218: NOT
5219: IFFALSE 5083
// end ; end_of_file
5221: PPOPN 3
5223: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5224: LD_INT 0
5226: PPUSH
5227: PPUSH
5228: PPUSH
5229: PPUSH
5230: PPUSH
5231: PPUSH
5232: PPUSH
// InGameOn ;
5233: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5237: LD_EXP 36
5241: PPUSH
5242: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5246: LD_EXP 36
5250: PPUSH
5251: LD_EXP 43
5255: PPUSH
5256: CALL_OW 119
// if Bierezov then
5260: LD_EXP 44
5264: IFFALSE 5280
// ComTurnUnit ( Bierezov , Cornel ) ;
5266: LD_EXP 44
5270: PPUSH
5271: LD_EXP 43
5275: PPUSH
5276: CALL_OW 119
// for i in jmm_units do
5280: LD_ADDR_VAR 0 2
5284: PUSH
5285: LD_EXP 4
5289: PUSH
5290: FOR_IN
5291: IFFALSE 5309
// ComTurnUnit ( i , Cornel ) ;
5293: LD_VAR 0 2
5297: PPUSH
5298: LD_EXP 43
5302: PPUSH
5303: CALL_OW 119
5307: GO 5290
5309: POP
5310: POP
// units := cornel_units union Cornel ;
5311: LD_ADDR_VAR 0 3
5315: PUSH
5316: LD_EXP 6
5320: PUSH
5321: LD_EXP 43
5325: UNION
5326: ST_TO_ADDR
// repeat wait ( 1 ) ;
5327: LD_INT 1
5329: PPUSH
5330: CALL_OW 67
// for i in units do
5334: LD_ADDR_VAR 0 2
5338: PUSH
5339: LD_VAR 0 3
5343: PUSH
5344: FOR_IN
5345: IFFALSE 5378
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5347: LD_VAR 0 2
5351: PPUSH
5352: LD_EXP 36
5356: PPUSH
5357: CALL_OW 250
5361: PPUSH
5362: LD_EXP 36
5366: PPUSH
5367: CALL_OW 251
5371: PPUSH
5372: CALL_OW 111
5376: GO 5344
5378: POP
5379: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5380: LD_VAR 0 3
5384: PPUSH
5385: LD_INT 92
5387: PUSH
5388: LD_EXP 36
5392: PPUSH
5393: CALL_OW 250
5397: PUSH
5398: LD_EXP 36
5402: PPUSH
5403: CALL_OW 251
5407: PUSH
5408: LD_INT 10
5410: PUSH
5411: EMPTY
5412: LIST
5413: LIST
5414: LIST
5415: LIST
5416: PPUSH
5417: CALL_OW 72
5421: PUSH
5422: LD_VAR 0 3
5426: EQUAL
5427: IFFALSE 5327
// for i in units do
5429: LD_ADDR_VAR 0 2
5433: PUSH
5434: LD_VAR 0 3
5438: PUSH
5439: FOR_IN
5440: IFFALSE 5458
// ComTurnUnit ( i , JMM ) ;
5442: LD_VAR 0 2
5446: PPUSH
5447: LD_EXP 36
5451: PPUSH
5452: CALL_OW 119
5456: GO 5439
5458: POP
5459: POP
// ComTurnUnit ( Cornel , JMM ) ;
5460: LD_EXP 43
5464: PPUSH
5465: LD_EXP 36
5469: PPUSH
5470: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5474: LD_EXP 36
5478: PPUSH
5479: LD_STRING D1-JMM-1
5481: PPUSH
5482: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5486: LD_EXP 43
5490: PPUSH
5491: LD_STRING D1-Corn-1
5493: PPUSH
5494: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5498: LD_EXP 36
5502: PPUSH
5503: LD_EXP 43
5507: PPUSH
5508: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5512: LD_EXP 43
5516: PPUSH
5517: LD_EXP 36
5521: PPUSH
5522: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5526: LD_INT 35
5528: PPUSH
5529: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5533: LD_EXP 36
5537: PPUSH
5538: LD_EXP 43
5542: PPUSH
5543: CALL_OW 296
5547: PUSH
5548: LD_INT 6
5550: LESS
5551: IFFALSE 5526
// ChangeSideFog ( 4 , 1 ) ;
5553: LD_INT 4
5555: PPUSH
5556: LD_INT 1
5558: PPUSH
5559: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5563: LD_EXP 36
5567: PPUSH
5568: LD_EXP 43
5572: PPUSH
5573: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5577: LD_EXP 43
5581: PPUSH
5582: LD_EXP 36
5586: PPUSH
5587: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5591: LD_EXP 36
5595: PPUSH
5596: LD_STRING D1-JMM-2
5598: PPUSH
5599: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5603: LD_EXP 36
5607: PPUSH
5608: LD_STRING D1-JMM-2a
5610: PPUSH
5611: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5615: LD_EXP 43
5619: PPUSH
5620: LD_STRING D1-Corn-2
5622: PPUSH
5623: CALL_OW 88
// if bierezov_exist or debug then
5627: LD_EXP 7
5631: PUSH
5632: LD_EXP 1
5636: OR
5637: IFFALSE 5878
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5639: LD_EXP 43
5643: PPUSH
5644: LD_EXP 44
5648: PPUSH
5649: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5653: LD_INT 10
5655: PPUSH
5656: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5660: LD_EXP 43
5664: PPUSH
5665: LD_STRING D1a-Corn-1
5667: PPUSH
5668: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5672: LD_EXP 36
5676: PPUSH
5677: LD_EXP 44
5681: PPUSH
5682: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5686: LD_EXP 44
5690: PPUSH
5691: LD_EXP 36
5695: PPUSH
5696: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5700: LD_EXP 36
5704: PPUSH
5705: LD_STRING D1a-JMM-1
5707: PPUSH
5708: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5712: LD_EXP 36
5716: PPUSH
5717: LD_EXP 43
5721: PPUSH
5722: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5726: LD_EXP 43
5730: PPUSH
5731: LD_EXP 36
5735: PPUSH
5736: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5740: LD_EXP 43
5744: PPUSH
5745: LD_STRING D1a-Corn-2
5747: PPUSH
5748: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5752: LD_EXP 36
5756: PPUSH
5757: LD_STRING D1a-JMM-2
5759: PPUSH
5760: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5764: LD_EXP 43
5768: PPUSH
5769: LD_STRING D1a-Corn-3
5771: PPUSH
5772: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5776: LD_EXP 36
5780: PPUSH
5781: LD_STRING D1a-JMM-3
5783: PPUSH
5784: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5788: LD_EXP 43
5792: PPUSH
5793: LD_STRING D1a-Corn-4
5795: PPUSH
5796: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5800: LD_EXP 36
5804: PPUSH
5805: LD_STRING D1a-JMM-4
5807: PPUSH
5808: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5812: LD_EXP 43
5816: PPUSH
5817: LD_STRING D1a-Corn-5
5819: PPUSH
5820: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5824: LD_EXP 44
5828: PPUSH
5829: LD_EXP 43
5833: PPUSH
5834: CALL_OW 250
5838: PPUSH
5839: LD_EXP 43
5843: PPUSH
5844: CALL_OW 251
5848: PUSH
5849: LD_INT 2
5851: MINUS
5852: PPUSH
5853: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5857: LD_EXP 44
5861: PPUSH
5862: LD_EXP 43
5866: PPUSH
5867: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5871: LD_INT 10
5873: PPUSH
5874: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5878: LD_EXP 36
5882: PPUSH
5883: LD_STRING D1b-JMM-1
5885: PPUSH
5886: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5890: LD_EXP 43
5894: PPUSH
5895: LD_STRING D1b-Corn-1
5897: PPUSH
5898: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5902: LD_EXP 36
5906: PPUSH
5907: LD_STRING D1b-JMM-2
5909: PPUSH
5910: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5914: LD_EXP 43
5918: PPUSH
5919: LD_STRING D1b-Corn-2
5921: PPUSH
5922: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5926: LD_EXP 36
5930: PPUSH
5931: LD_STRING D1b-JMM-3
5933: PPUSH
5934: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5938: LD_INT 10
5940: PPUSH
5941: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5945: LD_EXP 45
5949: PPUSH
5950: LD_STRING D1b-Pow-3
5952: PPUSH
5953: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5957: LD_EXP 36
5961: PPUSH
5962: LD_STRING D1b-JMM-4
5964: PPUSH
5965: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5969: LD_EXP 43
5973: PPUSH
5974: LD_STRING D1b-Corn-4
5976: PPUSH
5977: CALL_OW 88
// if Khatam then
5981: LD_EXP 40
5985: IFFALSE 6001
// Say ( Khatam , D1b-Khat-4 ) else
5987: LD_EXP 40
5991: PPUSH
5992: LD_STRING D1b-Khat-4
5994: PPUSH
5995: CALL_OW 88
5999: GO 6037
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
6001: LD_EXP 6
6005: PPUSH
6006: LD_INT 26
6008: PUSH
6009: LD_INT 1
6011: PUSH
6012: EMPTY
6013: LIST
6014: LIST
6015: PPUSH
6016: CALL_OW 72
6020: PUSH
6021: LD_EXP 43
6025: PUSH
6026: EMPTY
6027: LIST
6028: DIFF
6029: PPUSH
6030: LD_STRING D1b-Sol1-4
6032: PPUSH
6033: CALL 625 0 2
// if Cyrus then
6037: LD_EXP 38
6041: IFFALSE 6055
// Say ( Cyrus , D1b-Cyrus-4 ) ;
6043: LD_EXP 38
6047: PPUSH
6048: LD_STRING D1b-Cyrus-4
6050: PPUSH
6051: CALL_OW 88
// if Lisa then
6055: LD_EXP 39
6059: IFFALSE 6117
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6061: LD_EXP 39
6065: PPUSH
6066: LD_STRING D1b-Lisa-4
6068: PPUSH
6069: CALL_OW 88
// if Cyrus then
6073: LD_EXP 38
6077: IFFALSE 6117
// begin if not IsInUnit ( Cyrus ) then
6079: LD_EXP 38
6083: PPUSH
6084: CALL_OW 310
6088: NOT
6089: IFFALSE 6105
// ComTurnUnit ( Cyrus , Lisa ) ;
6091: LD_EXP 38
6095: PPUSH
6096: LD_EXP 39
6100: PPUSH
6101: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6105: LD_EXP 38
6109: PPUSH
6110: LD_STRING D1b-Cyrus-5
6112: PPUSH
6113: CALL_OW 88
// end ; end ; SelectGroup ;
6117: CALL 2606 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6121: LD_EXP 36
6125: PPUSH
6126: LD_STRING D1d-JMM-1
6128: PPUSH
6129: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6133: LD_EXP 43
6137: PPUSH
6138: LD_STRING D1d-Corn-1
6140: PPUSH
6141: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6145: LD_ADDR_VAR 0 2
6149: PUSH
6150: LD_EXP 4
6154: PUSH
6155: LD_EXP 6
6159: ADD
6160: PUSH
6161: LD_EXP 36
6165: ADD
6166: PUSH
6167: FOR_IN
6168: IFFALSE 6181
// ComHold ( i ) ;
6170: LD_VAR 0 2
6174: PPUSH
6175: CALL_OW 140
6179: GO 6167
6181: POP
6182: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6183: LD_ADDR_VAR 0 4
6187: PUSH
6188: LD_INT 22
6190: PUSH
6191: LD_INT 1
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: PUSH
6198: LD_INT 21
6200: PUSH
6201: LD_INT 2
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: PUSH
6208: EMPTY
6209: LIST
6210: LIST
6211: PPUSH
6212: CALL_OW 69
6216: ST_TO_ADDR
// if vehicles then
6217: LD_VAR 0 4
6221: IFFALSE 6559
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6223: LD_EXP 6
6227: PPUSH
6228: LD_INT 55
6230: PUSH
6231: EMPTY
6232: LIST
6233: PPUSH
6234: CALL_OW 72
6238: IFFALSE 6277
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6240: LD_ADDR_VAR 0 2
6244: PUSH
6245: LD_EXP 6
6249: PPUSH
6250: LD_INT 55
6252: PUSH
6253: EMPTY
6254: LIST
6255: PPUSH
6256: CALL_OW 72
6260: PUSH
6261: FOR_IN
6262: IFFALSE 6275
// ComExitVehicle ( i ) ;
6264: LD_VAR 0 2
6268: PPUSH
6269: CALL_OW 121
6273: GO 6261
6275: POP
6276: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6277: LD_ADDR_VAR 0 5
6281: PUSH
6282: LD_VAR 0 4
6286: PPUSH
6287: LD_INT 34
6289: PUSH
6290: LD_INT 51
6292: PUSH
6293: EMPTY
6294: LIST
6295: LIST
6296: PPUSH
6297: CALL_OW 72
6301: ST_TO_ADDR
// if cargos then
6302: LD_VAR 0 5
6306: IFFALSE 6489
// begin vehicles := cargos ;
6308: LD_ADDR_VAR 0 4
6312: PUSH
6313: LD_VAR 0 5
6317: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6318: LD_ADDR_VAR 0 6
6322: PUSH
6323: LD_STRING 02_resources_4
6325: PPUSH
6326: LD_INT 0
6328: PPUSH
6329: CALL_OW 30
6333: ST_TO_ADDR
// if debug and not resources then
6334: LD_EXP 1
6338: PUSH
6339: LD_VAR 0 6
6343: NOT
6344: AND
6345: IFFALSE 6355
// resources := 160 ;
6347: LD_ADDR_VAR 0 6
6351: PUSH
6352: LD_INT 160
6354: ST_TO_ADDR
// if resources mod 10 then
6355: LD_VAR 0 6
6359: PUSH
6360: LD_INT 10
6362: MOD
6363: IFFALSE 6385
// resources := resources - resources mod 10 ;
6365: LD_ADDR_VAR 0 6
6369: PUSH
6370: LD_VAR 0 6
6374: PUSH
6375: LD_VAR 0 6
6379: PUSH
6380: LD_INT 10
6382: MOD
6383: MINUS
6384: ST_TO_ADDR
// if resources then
6385: LD_VAR 0 6
6389: IFFALSE 6489
// for i in cargos do
6391: LD_ADDR_VAR 0 2
6395: PUSH
6396: LD_VAR 0 5
6400: PUSH
6401: FOR_IN
6402: IFFALSE 6487
// begin if resources < 100 then
6404: LD_VAR 0 6
6408: PUSH
6409: LD_INT 100
6411: LESS
6412: IFFALSE 6434
// begin cargo := resources ;
6414: LD_ADDR_VAR 0 7
6418: PUSH
6419: LD_VAR 0 6
6423: ST_TO_ADDR
// resources := 0 ;
6424: LD_ADDR_VAR 0 6
6428: PUSH
6429: LD_INT 0
6431: ST_TO_ADDR
// end else
6432: GO 6456
// begin cargo := 100 ;
6434: LD_ADDR_VAR 0 7
6438: PUSH
6439: LD_INT 100
6441: ST_TO_ADDR
// resources := resources - 100 ;
6442: LD_ADDR_VAR 0 6
6446: PUSH
6447: LD_VAR 0 6
6451: PUSH
6452: LD_INT 100
6454: MINUS
6455: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6456: LD_VAR 0 2
6460: PPUSH
6461: LD_INT 1
6463: PPUSH
6464: LD_VAR 0 7
6468: PPUSH
6469: CALL_OW 290
// if resources = 0 then
6473: LD_VAR 0 6
6477: PUSH
6478: LD_INT 0
6480: EQUAL
6481: IFFALSE 6485
// break ;
6483: GO 6487
// end ;
6485: GO 6401
6487: POP
6488: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6489: LD_VAR 0 4
6493: PUSH
6494: LD_INT 1
6496: ARRAY
6497: PPUSH
6498: CALL_OW 311
6502: PPUSH
6503: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6507: LD_VAR 0 4
6511: PUSH
6512: LD_INT 1
6514: ARRAY
6515: PPUSH
6516: LD_INT 4
6518: PPUSH
6519: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6523: LD_EXP 43
6527: PPUSH
6528: LD_VAR 0 4
6532: PUSH
6533: LD_INT 1
6535: ARRAY
6536: PPUSH
6537: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6541: LD_INT 35
6543: PPUSH
6544: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6548: LD_EXP 43
6552: PPUSH
6553: CALL_OW 310
6557: IFFALSE 6541
// end ; InGameOff ;
6559: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6563: LD_STRING M1
6565: PPUSH
6566: CALL_OW 337
// SaveForQuickRestart ;
6570: CALL_OW 22
// cornel_active := true ;
6574: LD_ADDR_EXP 8
6578: PUSH
6579: LD_INT 1
6581: ST_TO_ADDR
// end ;
6582: LD_VAR 0 1
6586: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns , tmp ;
6587: LD_EXP 36
6591: PPUSH
6592: LD_EXP 46
6596: PPUSH
6597: CALL_OW 296
6601: PUSH
6602: LD_INT 10
6604: LESS
6605: IFFALSE 7988
6607: GO 6609
6609: DISABLE
6610: LD_INT 0
6612: PPUSH
6613: PPUSH
6614: PPUSH
6615: PPUSH
6616: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6617: LD_ADDR_VAR 0 2
6621: PUSH
6622: LD_INT 89
6624: PUSH
6625: LD_INT 34
6627: PUSH
6628: EMPTY
6629: LIST
6630: LIST
6631: PUSH
6632: LD_INT 138
6634: PUSH
6635: LD_INT 63
6637: PUSH
6638: EMPTY
6639: LIST
6640: LIST
6641: PUSH
6642: LD_INT 196
6644: PUSH
6645: LD_INT 84
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 135
6654: PUSH
6655: LD_INT 52
6657: PUSH
6658: EMPTY
6659: LIST
6660: LIST
6661: PUSH
6662: LD_INT 103
6664: PUSH
6665: LD_INT 39
6667: PUSH
6668: EMPTY
6669: LIST
6670: LIST
6671: PUSH
6672: LD_INT 58
6674: PUSH
6675: LD_INT 30
6677: PUSH
6678: EMPTY
6679: LIST
6680: LIST
6681: PUSH
6682: LD_INT 38
6684: PUSH
6685: LD_INT 51
6687: PUSH
6688: EMPTY
6689: LIST
6690: LIST
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: LIST
6698: LIST
6699: LIST
6700: ST_TO_ADDR
// Video ( true ) ;
6701: LD_INT 1
6703: PPUSH
6704: CALL 1185 0 1
// if jmm_units then
6708: LD_EXP 4
6712: IFFALSE 6788
// for i in jmm_units do
6714: LD_ADDR_VAR 0 1
6718: PUSH
6719: LD_EXP 4
6723: PUSH
6724: FOR_IN
6725: IFFALSE 6786
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6727: LD_VAR 0 1
6731: PPUSH
6732: LD_EXP 36
6736: PPUSH
6737: CALL_OW 296
6741: PUSH
6742: LD_INT 10
6744: LESS
6745: PUSH
6746: LD_VAR 0 1
6750: PPUSH
6751: CALL_OW 310
6755: NOT
6756: AND
6757: IFFALSE 6775
// ComTurnUnit ( i , JMM ) else
6759: LD_VAR 0 1
6763: PPUSH
6764: LD_EXP 36
6768: PPUSH
6769: CALL_OW 119
6773: GO 6784
// ComHold ( i ) ;
6775: LD_VAR 0 1
6779: PPUSH
6780: CALL_OW 140
// end ;
6784: GO 6724
6786: POP
6787: POP
// if IsInUnit ( JMM ) then
6788: LD_EXP 36
6792: PPUSH
6793: CALL_OW 310
6797: IFFALSE 6822
// begin ComExitVehicle ( JMM ) ;
6799: LD_EXP 36
6803: PPUSH
6804: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6808: LD_EXP 36
6812: PPUSH
6813: LD_EXP 46
6817: PPUSH
6818: CALL_OW 172
// end ; Wait ( 10 ) ;
6822: LD_INT 10
6824: PPUSH
6825: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6829: LD_EXP 36
6833: PPUSH
6834: LD_EXP 46
6838: PPUSH
6839: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6843: LD_INT 35
6845: PPUSH
6846: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6850: LD_EXP 36
6854: PPUSH
6855: LD_EXP 46
6859: PPUSH
6860: CALL_OW 296
6864: PUSH
6865: LD_INT 6
6867: LESS
6868: IFFALSE 6843
// ComTurnUnit ( JMM , Lynch ) ;
6870: LD_EXP 36
6874: PPUSH
6875: LD_EXP 46
6879: PPUSH
6880: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6884: LD_ADDR_VAR 0 1
6888: PUSH
6889: LD_EXP 46
6893: PUSH
6894: LD_EXP 47
6898: PUSH
6899: LD_EXP 48
6903: PUSH
6904: LD_EXP 49
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: LIST
6913: LIST
6914: PUSH
6915: FOR_IN
6916: IFFALSE 6934
// ComTurnUnit ( i , JMM ) ;
6918: LD_VAR 0 1
6922: PPUSH
6923: LD_EXP 36
6927: PPUSH
6928: CALL_OW 119
6932: GO 6915
6934: POP
6935: POP
// Wait ( 0 0$0.3 ) ;
6936: LD_INT 10
6938: PPUSH
6939: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6943: LD_EXP 36
6947: PPUSH
6948: LD_STRING D2-JMM-1
6950: PPUSH
6951: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6955: LD_EXP 46
6959: PPUSH
6960: LD_STRING D2-Sol1-1
6962: PPUSH
6963: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6967: LD_EXP 36
6971: PPUSH
6972: LD_STRING D2-JMM-2
6974: PPUSH
6975: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6979: LD_EXP 46
6983: PPUSH
6984: LD_STRING D2-Sol1-2
6986: PPUSH
6987: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6991: LD_EXP 36
6995: PPUSH
6996: LD_STRING D2-JMM-3
6998: PPUSH
6999: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
7003: LD_EXP 46
7007: PPUSH
7008: LD_STRING D2-Sol1-3
7010: PPUSH
7011: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7015: LD_ADDR_VAR 0 1
7019: PUSH
7020: LD_INT 22
7022: PUSH
7023: LD_INT 8
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: PPUSH
7030: CALL_OW 69
7034: PUSH
7035: FOR_IN
7036: IFFALSE 7052
// SetSide ( i , 1 ) ;
7038: LD_VAR 0 1
7042: PPUSH
7043: LD_INT 1
7045: PPUSH
7046: CALL_OW 235
7050: GO 7035
7052: POP
7053: POP
// Say ( JMM , D2-JMM-4 ) ;
7054: LD_EXP 36
7058: PPUSH
7059: LD_STRING D2-JMM-4
7061: PPUSH
7062: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7066: LD_INT 1
7068: PPUSH
7069: LD_INT 5
7071: PPUSH
7072: CALL_OW 332
// for i = 1 to points do
7076: LD_ADDR_VAR 0 1
7080: PUSH
7081: DOUBLE
7082: LD_INT 1
7084: DEC
7085: ST_TO_ADDR
7086: LD_VAR 0 2
7090: PUSH
7091: FOR_TO
7092: IFFALSE 7267
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7094: LD_VAR 0 2
7098: PUSH
7099: LD_VAR 0 1
7103: ARRAY
7104: PUSH
7105: LD_INT 1
7107: ARRAY
7108: PPUSH
7109: LD_VAR 0 2
7113: PUSH
7114: LD_VAR 0 1
7118: ARRAY
7119: PUSH
7120: LD_INT 2
7122: ARRAY
7123: PPUSH
7124: CALL_OW 84
// if i = 1 then
7128: LD_VAR 0 1
7132: PUSH
7133: LD_INT 1
7135: EQUAL
7136: IFFALSE 7150
// Say ( Lynch , D2-Sol1-4 ) ;
7138: LD_EXP 46
7142: PPUSH
7143: LD_STRING D2-Sol1-4
7145: PPUSH
7146: CALL_OW 88
// if i = 2 then
7150: LD_VAR 0 1
7154: PUSH
7155: LD_INT 2
7157: EQUAL
7158: IFFALSE 7172
// Say ( JMM , D2-JMM-5 ) ;
7160: LD_EXP 36
7164: PPUSH
7165: LD_STRING D2-JMM-5
7167: PPUSH
7168: CALL_OW 88
// if i = 4 then
7172: LD_VAR 0 1
7176: PUSH
7177: LD_INT 4
7179: EQUAL
7180: IFFALSE 7204
// begin RevealFogArea ( 1 , troopsArea ) ;
7182: LD_INT 1
7184: PPUSH
7185: LD_INT 6
7187: PPUSH
7188: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7192: LD_EXP 46
7196: PPUSH
7197: LD_STRING D2-Sol1-5
7199: PPUSH
7200: CALL_OW 88
// end ; if i = 5 then
7204: LD_VAR 0 1
7208: PUSH
7209: LD_INT 5
7211: EQUAL
7212: IFFALSE 7226
// Say ( JMM , D2-JMM-6 ) ;
7214: LD_EXP 36
7218: PPUSH
7219: LD_STRING D2-JMM-6
7221: PPUSH
7222: CALL_OW 88
// if i = 7 then
7226: LD_VAR 0 1
7230: PUSH
7231: LD_INT 7
7233: EQUAL
7234: IFFALSE 7258
// begin RevealFogArea ( 1 , forestArea ) ;
7236: LD_INT 1
7238: PPUSH
7239: LD_INT 7
7241: PPUSH
7242: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7246: LD_EXP 46
7250: PPUSH
7251: LD_STRING D2-Sol1-6
7253: PPUSH
7254: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7258: LD_INT 46
7260: PPUSH
7261: CALL_OW 67
// end ;
7265: GO 7091
7267: POP
7268: POP
// CenterNowOnUnits ( JMM ) ;
7269: LD_EXP 36
7273: PPUSH
7274: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7278: LD_EXP 36
7282: PPUSH
7283: LD_STRING D2-JMM-7
7285: PPUSH
7286: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7290: LD_EXP 46
7294: PPUSH
7295: LD_STRING D2-Sol1-7
7297: PPUSH
7298: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7302: LD_EXP 36
7306: PPUSH
7307: LD_STRING D2-JMM-8
7309: PPUSH
7310: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7314: LD_ADDR_VAR 0 4
7318: PUSH
7319: LD_INT 22
7321: PUSH
7322: LD_INT 1
7324: PUSH
7325: EMPTY
7326: LIST
7327: LIST
7328: PUSH
7329: LD_INT 30
7331: PUSH
7332: LD_INT 31
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: PUSH
7339: EMPTY
7340: LIST
7341: LIST
7342: PPUSH
7343: CALL_OW 69
7347: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7348: LD_EXP 46
7352: PPUSH
7353: LD_VAR 0 4
7357: PUSH
7358: LD_INT 1
7360: ARRAY
7361: PPUSH
7362: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7366: LD_INT 65
7368: PPUSH
7369: LD_INT 101
7371: PPUSH
7372: CALL_OW 428
7376: IFFALSE 7399
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7378: LD_INT 65
7380: PPUSH
7381: LD_INT 101
7383: PPUSH
7384: CALL_OW 428
7388: PPUSH
7389: LD_INT 75
7391: PPUSH
7392: LD_INT 100
7394: PPUSH
7395: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7399: LD_INT 66
7401: PPUSH
7402: LD_INT 103
7404: PPUSH
7405: CALL_OW 428
7409: IFFALSE 7432
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7411: LD_INT 66
7413: PPUSH
7414: LD_INT 103
7416: PPUSH
7417: CALL_OW 428
7421: PPUSH
7422: LD_INT 75
7424: PPUSH
7425: LD_INT 100
7427: PPUSH
7428: CALL_OW 111
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_dist , JMM , 7 ] ] ) ;
7432: LD_ADDR_VAR 0 5
7436: PUSH
7437: LD_INT 22
7439: PUSH
7440: LD_INT 1
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PUSH
7447: LD_INT 21
7449: PUSH
7450: LD_INT 2
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PUSH
7457: LD_INT 91
7459: PUSH
7460: LD_EXP 36
7464: PUSH
7465: LD_INT 7
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: PPUSH
7478: CALL_OW 69
7482: ST_TO_ADDR
// if tmp then
7483: LD_VAR 0 5
7487: IFFALSE 7504
// ComMoveXY ( tmp , 75 , 100 ) ;
7489: LD_VAR 0 5
7493: PPUSH
7494: LD_INT 75
7496: PPUSH
7497: LD_INT 100
7499: PPUSH
7500: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7504: LD_ADDR_VAR 0 3
7508: PUSH
7509: LD_EXP 4
7513: PPUSH
7514: LD_INT 25
7516: PUSH
7517: LD_INT 1
7519: PUSH
7520: EMPTY
7521: LIST
7522: LIST
7523: PPUSH
7524: CALL_OW 72
7528: PPUSH
7529: LD_EXP 36
7533: PPUSH
7534: CALL_OW 74
7538: ST_TO_ADDR
// if sol then
7539: LD_VAR 0 3
7543: IFFALSE 7603
// if GetDistUnits ( JMM , sol ) < 10 then
7545: LD_EXP 36
7549: PPUSH
7550: LD_VAR 0 3
7554: PPUSH
7555: CALL_OW 296
7559: PUSH
7560: LD_INT 10
7562: LESS
7563: IFFALSE 7603
// begin if IsInUnit ( sol ) then
7565: LD_VAR 0 3
7569: PPUSH
7570: CALL_OW 310
7574: IFFALSE 7585
// ComExitVehicle ( sol ) ;
7576: LD_VAR 0 3
7580: PPUSH
7581: CALL_OW 121
// AddComEnterUnit ( sol , buns [ 2 ] ) ;
7585: LD_VAR 0 3
7589: PPUSH
7590: LD_VAR 0 4
7594: PUSH
7595: LD_INT 2
7597: ARRAY
7598: PPUSH
7599: CALL_OW 180
// end ; Wait ( 0 0$0.3 ) ;
7603: LD_INT 10
7605: PPUSH
7606: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7610: LD_EXP 36
7614: PPUSH
7615: LD_INT 65
7617: PPUSH
7618: LD_INT 101
7620: PPUSH
7621: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7625: LD_EXP 36
7629: PPUSH
7630: LD_INT 63
7632: PPUSH
7633: LD_INT 100
7635: PPUSH
7636: CALL_OW 178
// tmp := 0 0$0 ;
7640: LD_ADDR_VAR 0 5
7644: PUSH
7645: LD_INT 0
7647: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7648: LD_INT 35
7650: PPUSH
7651: CALL_OW 67
// tmp := tmp + 0 0$1 ;
7655: LD_ADDR_VAR 0 5
7659: PUSH
7660: LD_VAR 0 5
7664: PUSH
7665: LD_INT 35
7667: PLUS
7668: ST_TO_ADDR
// until IsAt ( JMM , 65 , 101 ) or tmp > 0 0$5 ;
7669: LD_EXP 36
7673: PPUSH
7674: LD_INT 65
7676: PPUSH
7677: LD_INT 101
7679: PPUSH
7680: CALL_OW 307
7684: PUSH
7685: LD_VAR 0 5
7689: PUSH
7690: LD_INT 175
7692: GREATER
7693: OR
7694: IFFALSE 7648
// Say ( JMM , D2a-JMM-1 ) ;
7696: LD_EXP 36
7700: PPUSH
7701: LD_STRING D2a-JMM-1
7703: PPUSH
7704: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7708: LD_EXP 47
7712: PPUSH
7713: LD_INT 66
7715: PPUSH
7716: LD_INT 103
7718: PPUSH
7719: CALL_OW 111
// tmp := 0 0$0 ;
7723: LD_ADDR_VAR 0 5
7727: PUSH
7728: LD_INT 0
7730: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7731: LD_INT 35
7733: PPUSH
7734: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) or tmp > 0 0$5 ;
7738: LD_EXP 47
7742: PPUSH
7743: LD_INT 66
7745: PPUSH
7746: LD_INT 103
7748: PPUSH
7749: CALL_OW 307
7753: PUSH
7754: LD_VAR 0 5
7758: PUSH
7759: LD_INT 175
7761: GREATER
7762: OR
7763: IFFALSE 7731
// ComTurnUnit ( Walker , JMM ) ;
7765: LD_EXP 47
7769: PPUSH
7770: LD_EXP 36
7774: PPUSH
7775: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7779: LD_EXP 47
7783: PPUSH
7784: LD_STRING D2a-Sci1-1
7786: PPUSH
7787: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7791: LD_EXP 36
7795: PPUSH
7796: LD_EXP 47
7800: PPUSH
7801: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7805: LD_EXP 36
7809: PPUSH
7810: LD_STRING D2a-JMM-2
7812: PPUSH
7813: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7817: LD_EXP 47
7821: PPUSH
7822: LD_STRING D2a-Sci1-2
7824: PPUSH
7825: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7829: LD_EXP 36
7833: PPUSH
7834: LD_STRING D2a-JMM-3
7836: PPUSH
7837: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7841: LD_EXP 47
7845: PPUSH
7846: LD_STRING D2a-Sci1-3
7848: PPUSH
7849: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7853: LD_ADDR_EXP 4
7857: PUSH
7858: LD_EXP 4
7862: PUSH
7863: LD_EXP 46
7867: PUSH
7868: LD_EXP 47
7872: PUSH
7873: LD_EXP 48
7877: PUSH
7878: LD_EXP 49
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: LIST
7887: LIST
7888: ADD
7889: ST_TO_ADDR
// for i in jmm_units do
7890: LD_ADDR_VAR 0 1
7894: PUSH
7895: LD_EXP 4
7899: PUSH
7900: FOR_IN
7901: IFFALSE 7926
// if not IsInUnit ( i ) then
7903: LD_VAR 0 1
7907: PPUSH
7908: CALL_OW 310
7912: NOT
7913: IFFALSE 7924
// ComFree ( i ) ;
7915: LD_VAR 0 1
7919: PPUSH
7920: CALL_OW 139
7924: GO 7900
7926: POP
7927: POP
// Video ( false ) ;
7928: LD_INT 0
7930: PPUSH
7931: CALL 1185 0 1
// ChangeMissionObjectives ( MSolar1 ) ;
7935: LD_STRING MSolar1
7937: PPUSH
7938: CALL_OW 337
// jmm_on_west := true ;
7942: LD_ADDR_EXP 5
7946: PUSH
7947: LD_INT 1
7949: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7950: LD_INT 1050
7952: PPUSH
7953: CALL_OW 67
// frank_can_return := true ;
7957: LD_ADDR_EXP 12
7961: PUSH
7962: LD_INT 1
7964: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7965: LD_INT 6300
7967: PPUSH
7968: LD_INT 8400
7970: PPUSH
7971: CALL_OW 12
7975: PPUSH
7976: CALL_OW 67
// send_spec_patrol := true ;
7980: LD_ADDR_EXP 29
7984: PUSH
7985: LD_INT 1
7987: ST_TO_ADDR
// end ;
7988: PPOPN 5
7990: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7991: LD_INT 22
7993: PUSH
7994: LD_INT 1
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: PUSH
8001: LD_INT 34
8003: PUSH
8004: LD_INT 51
8006: PUSH
8007: EMPTY
8008: LIST
8009: LIST
8010: PUSH
8011: LD_INT 92
8013: PUSH
8014: LD_INT 63
8016: PUSH
8017: LD_INT 100
8019: PUSH
8020: LD_INT 5
8022: PUSH
8023: EMPTY
8024: LIST
8025: LIST
8026: LIST
8027: LIST
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: LIST
8033: PUSH
8034: EMPTY
8035: LIST
8036: PPUSH
8037: CALL_OW 69
8041: PUSH
8042: LD_EXP 5
8046: NOT
8047: AND
8048: IFFALSE 8161
8050: GO 8052
8052: DISABLE
8053: LD_INT 0
8055: PPUSH
8056: PPUSH
// begin enable ;
8057: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
8058: LD_ADDR_VAR 0 2
8062: PUSH
8063: LD_INT 22
8065: PUSH
8066: LD_INT 1
8068: PUSH
8069: EMPTY
8070: LIST
8071: LIST
8072: PUSH
8073: LD_INT 34
8075: PUSH
8076: LD_INT 51
8078: PUSH
8079: EMPTY
8080: LIST
8081: LIST
8082: PUSH
8083: LD_INT 92
8085: PUSH
8086: LD_INT 63
8088: PUSH
8089: LD_INT 100
8091: PUSH
8092: LD_INT 5
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: PUSH
8101: EMPTY
8102: LIST
8103: LIST
8104: LIST
8105: PUSH
8106: EMPTY
8107: LIST
8108: PPUSH
8109: CALL_OW 69
8113: ST_TO_ADDR
// if not filter then
8114: LD_VAR 0 2
8118: NOT
8119: IFFALSE 8123
// exit ;
8121: GO 8161
// for i in filter do
8123: LD_ADDR_VAR 0 1
8127: PUSH
8128: LD_VAR 0 2
8132: PUSH
8133: FOR_IN
8134: IFFALSE 8159
// begin SetFuel ( i , 0 ) ;
8136: LD_VAR 0 1
8140: PPUSH
8141: LD_INT 0
8143: PPUSH
8144: CALL_OW 240
// ComStop ( i ) ;
8148: LD_VAR 0 1
8152: PPUSH
8153: CALL_OW 141
// end ;
8157: GO 8133
8159: POP
8160: POP
// end ;
8161: PPOPN 2
8163: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
8164: LD_EXP 29
8168: IFFALSE 9161
8170: GO 8172
8172: DISABLE
8173: LD_INT 0
8175: PPUSH
8176: PPUSH
8177: PPUSH
8178: PPUSH
8179: PPUSH
8180: PPUSH
8181: PPUSH
// begin if not ru_spec_patrol then
8182: LD_EXP 53
8186: NOT
8187: IFFALSE 8191
// exit ;
8189: GO 9161
// dead1 := false ;
8191: LD_ADDR_VAR 0 1
8195: PUSH
8196: LD_INT 0
8198: ST_TO_ADDR
// dead2 := false ;
8199: LD_ADDR_VAR 0 2
8203: PUSH
8204: LD_INT 0
8206: ST_TO_ADDR
// inarea1 := false ;
8207: LD_ADDR_VAR 0 3
8211: PUSH
8212: LD_INT 0
8214: ST_TO_ADDR
// inarea2 := false ;
8215: LD_ADDR_VAR 0 4
8219: PUSH
8220: LD_INT 0
8222: ST_TO_ADDR
// tmp := [ ] ;
8223: LD_ADDR_VAR 0 6
8227: PUSH
8228: EMPTY
8229: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8230: LD_EXP 53
8234: PPUSH
8235: LD_INT 75
8237: PPUSH
8238: LD_INT 101
8240: PPUSH
8241: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8245: LD_INT 35
8247: PPUSH
8248: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8252: LD_INT 1
8254: PPUSH
8255: LD_EXP 53
8259: PUSH
8260: LD_INT 1
8262: ARRAY
8263: PPUSH
8264: CALL_OW 292
8268: IFFALSE 8245
// ComStop ( ru_spec_patrol ) ;
8270: LD_EXP 53
8274: PPUSH
8275: CALL_OW 141
// Wait ( 0 0$02 ) ;
8279: LD_INT 70
8281: PPUSH
8282: CALL_OW 67
// DialogueOn ;
8286: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8290: LD_EXP 53
8294: PUSH
8295: LD_INT 1
8297: ARRAY
8298: PPUSH
8299: LD_STRING D8-Rus1-1
8301: PPUSH
8302: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8306: LD_EXP 36
8310: PPUSH
8311: LD_STRING D8-JMM-1
8313: PPUSH
8314: CALL_OW 88
// DialogueOff ;
8318: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8322: LD_EXP 53
8326: PPUSH
8327: LD_INT 13
8329: PPUSH
8330: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8334: LD_INT 35
8336: PPUSH
8337: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8341: LD_VAR 0 1
8345: NOT
8346: PUSH
8347: LD_EXP 53
8351: PUSH
8352: LD_INT 1
8354: ARRAY
8355: PPUSH
8356: CALL_OW 301
8360: AND
8361: IFFALSE 8371
// dead1 := true ;
8363: LD_ADDR_VAR 0 1
8367: PUSH
8368: LD_INT 1
8370: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8371: LD_VAR 0 2
8375: NOT
8376: PUSH
8377: LD_EXP 53
8381: PUSH
8382: LD_INT 2
8384: ARRAY
8385: PPUSH
8386: CALL_OW 301
8390: AND
8391: IFFALSE 8401
// dead2 := true ;
8393: LD_ADDR_VAR 0 2
8397: PUSH
8398: LD_INT 1
8400: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8401: LD_VAR 0 3
8405: NOT
8406: PUSH
8407: LD_EXP 53
8411: PUSH
8412: LD_INT 1
8414: ARRAY
8415: PPUSH
8416: LD_INT 14
8418: PPUSH
8419: CALL_OW 308
8423: AND
8424: IFFALSE 8434
// inarea1 := true ;
8426: LD_ADDR_VAR 0 3
8430: PUSH
8431: LD_INT 1
8433: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8434: LD_VAR 0 4
8438: NOT
8439: PUSH
8440: LD_EXP 53
8444: PUSH
8445: LD_INT 2
8447: ARRAY
8448: PPUSH
8449: LD_INT 14
8451: PPUSH
8452: CALL_OW 308
8456: AND
8457: IFFALSE 8467
// inarea2 := true ;
8459: LD_ADDR_VAR 0 4
8463: PUSH
8464: LD_INT 1
8466: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8467: LD_VAR 0 1
8471: PUSH
8472: LD_VAR 0 2
8476: AND
8477: PUSH
8478: LD_VAR 0 1
8482: PUSH
8483: LD_VAR 0 4
8487: AND
8488: OR
8489: PUSH
8490: LD_VAR 0 2
8494: PUSH
8495: LD_VAR 0 3
8499: AND
8500: OR
8501: PUSH
8502: LD_VAR 0 3
8506: PUSH
8507: LD_VAR 0 4
8511: AND
8512: OR
8513: IFFALSE 8334
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8515: LD_VAR 0 3
8519: PUSH
8520: LD_VAR 0 4
8524: AND
8525: PUSH
8526: LD_VAR 0 1
8530: PUSH
8531: LD_VAR 0 4
8535: AND
8536: OR
8537: PUSH
8538: LD_VAR 0 2
8542: PUSH
8543: LD_VAR 0 3
8547: AND
8548: OR
8549: IFFALSE 9141
// begin prepare_siege := true ;
8551: LD_ADDR_EXP 30
8555: PUSH
8556: LD_INT 1
8558: ST_TO_ADDR
// DialogueOn ;
8559: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8563: LD_VAR 0 3
8567: PUSH
8568: LD_VAR 0 4
8572: AND
8573: IFFALSE 8589
// Say ( JMM , D8b-JMM-1a ) else
8575: LD_EXP 36
8579: PPUSH
8580: LD_STRING D8b-JMM-1a
8582: PPUSH
8583: CALL_OW 88
8587: GO 8601
// Say ( JMM , D8b-JMM-1 ) ;
8589: LD_EXP 36
8593: PPUSH
8594: LD_STRING D8b-JMM-1
8596: PPUSH
8597: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8601: LD_EXP 4
8605: PPUSH
8606: LD_INT 26
8608: PUSH
8609: LD_INT 1
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: PPUSH
8616: CALL_OW 72
8620: PUSH
8621: LD_EXP 37
8625: PUSH
8626: LD_EXP 38
8630: PUSH
8631: LD_EXP 47
8635: PUSH
8636: LD_EXP 50
8640: PUSH
8641: EMPTY
8642: LIST
8643: LIST
8644: LIST
8645: LIST
8646: DIFF
8647: PPUSH
8648: LD_STRING D8b-Sol1-1
8650: PPUSH
8651: CALL 625 0 2
// if Cyrus and Cyrus in jmm_units then
8655: LD_EXP 38
8659: PUSH
8660: LD_EXP 38
8664: PUSH
8665: LD_EXP 4
8669: IN
8670: AND
8671: IFFALSE 8687
// Say ( Cyrus , D8b-Cyrus-1 ) else
8673: LD_EXP 38
8677: PPUSH
8678: LD_STRING D8b-Cyrus-1
8680: PPUSH
8681: CALL_OW 88
8685: GO 8699
// Say ( JMM , D8b-JMM-1a ) ;
8687: LD_EXP 36
8691: PPUSH
8692: LD_STRING D8b-JMM-1a
8694: PPUSH
8695: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8699: LD_EXP 39
8703: PUSH
8704: LD_EXP 39
8708: PUSH
8709: LD_EXP 4
8713: IN
8714: AND
8715: IFFALSE 8729
// Say ( Lisa , D8b-Lisa-2 ) ;
8717: LD_EXP 39
8721: PPUSH
8722: LD_STRING D8b-Lisa-2
8724: PPUSH
8725: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8729: LD_EXP 37
8733: PUSH
8734: LD_EXP 37
8738: PUSH
8739: LD_EXP 4
8743: IN
8744: AND
8745: IFFALSE 8761
// Say ( Bobby , D8b-Bobby-1 ) else
8747: LD_EXP 37
8751: PPUSH
8752: LD_STRING D8b-Bobby-1
8754: PPUSH
8755: CALL_OW 88
8759: GO 8821
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8761: LD_ADDR_VAR 0 5
8765: PUSH
8766: LD_EXP 4
8770: PPUSH
8771: LD_INT 26
8773: PUSH
8774: LD_INT 1
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PPUSH
8781: CALL_OW 72
8785: PUSH
8786: LD_EXP 37
8790: PUSH
8791: LD_EXP 38
8795: PUSH
8796: LD_EXP 47
8800: PUSH
8801: LD_EXP 50
8805: PUSH
8806: EMPTY
8807: LIST
8808: LIST
8809: LIST
8810: LIST
8811: DIFF
8812: PPUSH
8813: LD_STRING D8b-Sol2-1
8815: PPUSH
8816: CALL 625 0 2
8820: ST_TO_ADDR
// DialogueOff ;
8821: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8825: LD_EXP 38
8829: PUSH
8830: LD_EXP 38
8834: PUSH
8835: LD_EXP 4
8839: IN
8840: AND
8841: IFFALSE 8866
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8843: LD_ADDR_VAR 0 6
8847: PUSH
8848: LD_VAR 0 6
8852: PPUSH
8853: LD_INT 1
8855: PPUSH
8856: LD_EXP 38
8860: PPUSH
8861: CALL_OW 2
8865: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8866: LD_EXP 37
8870: PUSH
8871: LD_EXP 37
8875: PUSH
8876: LD_EXP 4
8880: IN
8881: AND
8882: IFFALSE 8907
// tmp := Insert ( tmp , 1 , Bobby ) ;
8884: LD_ADDR_VAR 0 6
8888: PUSH
8889: LD_VAR 0 6
8893: PPUSH
8894: LD_INT 1
8896: PPUSH
8897: LD_EXP 37
8901: PPUSH
8902: CALL_OW 2
8906: ST_TO_ADDR
// if sol then
8907: LD_VAR 0 5
8911: IFFALSE 8936
// tmp := Insert ( tmp , 1 , sol ) ;
8913: LD_ADDR_VAR 0 6
8917: PUSH
8918: LD_VAR 0 6
8922: PPUSH
8923: LD_INT 1
8925: PPUSH
8926: LD_VAR 0 5
8930: PPUSH
8931: CALL_OW 2
8935: ST_TO_ADDR
// if tmp then
8936: LD_VAR 0 6
8940: IFFALSE 9100
// begin SetSide ( tmp , 8 ) ;
8942: LD_VAR 0 6
8946: PPUSH
8947: LD_INT 8
8949: PPUSH
8950: CALL_OW 235
// ComFree ( tmp ) ;
8954: LD_VAR 0 6
8958: PPUSH
8959: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8963: LD_VAR 0 6
8967: PPUSH
8968: LD_INT 15
8970: PPUSH
8971: CALL_OW 173
// AddComHold ( tmp ) ;
8975: LD_VAR 0 6
8979: PPUSH
8980: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8984: LD_INT 35
8986: PPUSH
8987: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
8991: LD_VAR 0 6
8995: PUSH
8996: LD_INT 1
8998: ARRAY
8999: PPUSH
9000: CALL_OW 314
9004: NOT
9005: IFFALSE 9019
// ComMoveToArea ( tmp , cyrusEscape ) ;
9007: LD_VAR 0 6
9011: PPUSH
9012: LD_INT 15
9014: PPUSH
9015: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
9019: LD_VAR 0 6
9023: PUSH
9024: LD_INT 1
9026: ARRAY
9027: PPUSH
9028: LD_INT 15
9030: PPUSH
9031: CALL_OW 308
9035: IFFALSE 9090
// begin RemoveUnit ( tmp [ 1 ] ) ;
9037: LD_VAR 0 6
9041: PUSH
9042: LD_INT 1
9044: ARRAY
9045: PPUSH
9046: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
9050: LD_ADDR_EXP 4
9054: PUSH
9055: LD_EXP 4
9059: PUSH
9060: LD_VAR 0 6
9064: PUSH
9065: LD_INT 1
9067: ARRAY
9068: DIFF
9069: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
9070: LD_ADDR_VAR 0 6
9074: PUSH
9075: LD_VAR 0 6
9079: PUSH
9080: LD_VAR 0 6
9084: PUSH
9085: LD_INT 1
9087: ARRAY
9088: DIFF
9089: ST_TO_ADDR
// end ; until tmp = 0 ;
9090: LD_VAR 0 6
9094: PUSH
9095: LD_INT 0
9097: EQUAL
9098: IFFALSE 8984
// end ; Wait ( 0 0$30 ) ;
9100: LD_INT 1050
9102: PPUSH
9103: CALL_OW 67
// if ru_spec_patrol then
9107: LD_EXP 53
9111: IFFALSE 9139
// for i in ru_spec_patrol do
9113: LD_ADDR_VAR 0 7
9117: PUSH
9118: LD_EXP 53
9122: PUSH
9123: FOR_IN
9124: IFFALSE 9137
// RemoveUnit ( i ) ;
9126: LD_VAR 0 7
9130: PPUSH
9131: CALL_OW 64
9135: GO 9123
9137: POP
9138: POP
// end else
9139: GO 9161
// begin prepare_siege := false ;
9141: LD_ADDR_EXP 30
9145: PUSH
9146: LD_INT 0
9148: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
9149: LD_EXP 36
9153: PPUSH
9154: LD_STRING D8a-JMM-1
9156: PPUSH
9157: CALL_OW 88
// end ; end ;
9161: PPOPN 7
9163: END
// every 0 0$10 trigger frank_can_return do var i , p , points ;
9164: LD_EXP 12
9168: IFFALSE 10385
9170: GO 9172
9172: DISABLE
9173: LD_INT 0
9175: PPUSH
9176: PPUSH
9177: PPUSH
// begin uc_side := 8 ;
9178: LD_ADDR_OWVAR 20
9182: PUSH
9183: LD_INT 8
9185: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
9186: LD_ADDR_VAR 0 3
9190: PUSH
9191: LD_INT 59
9193: PUSH
9194: LD_INT 71
9196: PUSH
9197: EMPTY
9198: LIST
9199: LIST
9200: PUSH
9201: LD_INT 122
9203: PUSH
9204: LD_INT 117
9206: PUSH
9207: EMPTY
9208: LIST
9209: LIST
9210: PUSH
9211: EMPTY
9212: LIST
9213: LIST
9214: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9215: LD_ADDR_EXP 50
9219: PUSH
9220: LD_STRING Frank
9222: PPUSH
9223: LD_INT 0
9225: PPUSH
9226: CALL 474 0 2
9230: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9231: LD_ADDR_VAR 0 1
9235: PUSH
9236: LD_INT 1
9238: PPUSH
9239: LD_INT 2
9241: PPUSH
9242: CALL_OW 12
9246: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9247: LD_EXP 50
9251: PPUSH
9252: LD_VAR 0 3
9256: PUSH
9257: LD_VAR 0 1
9261: ARRAY
9262: PUSH
9263: LD_INT 1
9265: ARRAY
9266: PPUSH
9267: LD_VAR 0 3
9271: PUSH
9272: LD_VAR 0 1
9276: ARRAY
9277: PUSH
9278: LD_INT 2
9280: ARRAY
9281: PPUSH
9282: LD_INT 0
9284: PPUSH
9285: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9289: LD_EXP 50
9293: PPUSH
9294: LD_INT 1
9296: PPUSH
9297: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9301: LD_INT 35
9303: PPUSH
9304: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 and GetLives ( Frank ) > 250 ;
9308: LD_EXP 50
9312: PPUSH
9313: LD_EXP 36
9317: PPUSH
9318: CALL_OW 296
9322: PUSH
9323: LD_INT 8
9325: LESS
9326: PUSH
9327: LD_EXP 50
9331: PPUSH
9332: CALL_OW 256
9336: PUSH
9337: LD_INT 250
9339: GREATER
9340: AND
9341: IFFALSE 9301
// Video ( true ) ;
9343: LD_INT 1
9345: PPUSH
9346: CALL 1185 0 1
// CenterOnUnits ( JMM ) ;
9350: LD_EXP 36
9354: PPUSH
9355: CALL_OW 85
// if IsInUnit ( JMM ) then
9359: LD_EXP 36
9363: PPUSH
9364: CALL_OW 310
9368: IFFALSE 9379
// ComFree ( JMM ) ;
9370: LD_EXP 36
9374: PPUSH
9375: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9379: LD_EXP 36
9383: PPUSH
9384: LD_EXP 50
9388: PPUSH
9389: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9393: LD_EXP 50
9397: PPUSH
9398: LD_EXP 36
9402: PPUSH
9403: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9407: LD_EXP 36
9411: PPUSH
9412: LD_STRING D6-JMM-1
9414: PPUSH
9415: CALL_OW 88
// p := 0 ;
9419: LD_ADDR_VAR 0 2
9423: PUSH
9424: LD_INT 0
9426: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9427: LD_INT 35
9429: PPUSH
9430: CALL_OW 67
// p := p + 1 ;
9434: LD_ADDR_VAR 0 2
9438: PUSH
9439: LD_VAR 0 2
9443: PUSH
9444: LD_INT 1
9446: PLUS
9447: ST_TO_ADDR
// until GetDistUnits ( JMM , Frank ) < 8 or p > 7 ;
9448: LD_EXP 36
9452: PPUSH
9453: LD_EXP 50
9457: PPUSH
9458: CALL_OW 296
9462: PUSH
9463: LD_INT 8
9465: LESS
9466: PUSH
9467: LD_VAR 0 2
9471: PUSH
9472: LD_INT 7
9474: GREATER
9475: OR
9476: IFFALSE 9427
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9478: LD_EXP 39
9482: PUSH
9483: LD_EXP 39
9487: PPUSH
9488: LD_EXP 50
9492: PPUSH
9493: CALL_OW 296
9497: PUSH
9498: LD_INT 20
9500: LESS
9501: AND
9502: IFFALSE 9527
// begin ComFree ( Lisa ) ;
9504: LD_EXP 39
9508: PPUSH
9509: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9513: LD_EXP 39
9517: PPUSH
9518: LD_EXP 50
9522: PPUSH
9523: CALL_OW 172
// end ; if Lynch then
9527: LD_EXP 46
9531: IFFALSE 9556
// begin ComFree ( Lynch ) ;
9533: LD_EXP 46
9537: PPUSH
9538: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9542: LD_EXP 46
9546: PPUSH
9547: LD_EXP 50
9551: PPUSH
9552: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9556: LD_EXP 36
9560: PPUSH
9561: LD_EXP 50
9565: PPUSH
9566: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9570: LD_EXP 50
9574: PPUSH
9575: LD_EXP 36
9579: PPUSH
9580: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9584: LD_EXP 50
9588: PPUSH
9589: LD_STRING D6-Frank-1
9591: PPUSH
9592: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9596: LD_INT 69
9598: PPUSH
9599: LD_INT 20
9601: PPUSH
9602: LD_INT 1
9604: PPUSH
9605: LD_INT 20
9607: NEG
9608: PPUSH
9609: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9613: LD_INT 69
9615: PPUSH
9616: LD_INT 20
9618: PPUSH
9619: LD_INT 1
9621: PPUSH
9622: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9626: LD_INT 190
9628: PPUSH
9629: LD_INT 31
9631: PPUSH
9632: LD_INT 1
9634: PPUSH
9635: LD_INT 20
9637: NEG
9638: PPUSH
9639: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9643: LD_INT 190
9645: PPUSH
9646: LD_INT 31
9648: PPUSH
9649: LD_INT 1
9651: PPUSH
9652: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9656: LD_INT 69
9658: PPUSH
9659: LD_INT 20
9661: PPUSH
9662: CALL_OW 84
// Wait ( 0 0$02 ) ;
9666: LD_INT 70
9668: PPUSH
9669: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9673: LD_EXP 36
9677: PPUSH
9678: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9682: LD_EXP 39
9686: PUSH
9687: LD_EXP 39
9691: PPUSH
9692: LD_EXP 50
9696: PPUSH
9697: CALL_OW 296
9701: PUSH
9702: LD_INT 20
9704: LESS
9705: AND
9706: PUSH
9707: LD_EXP 39
9711: PPUSH
9712: CALL_OW 302
9716: AND
9717: IFFALSE 9839
// begin ComFree ( Lisa ) ;
9719: LD_EXP 39
9723: PPUSH
9724: CALL_OW 139
// p := 0 ;
9728: LD_ADDR_VAR 0 2
9732: PUSH
9733: LD_INT 0
9735: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9736: LD_INT 35
9738: PPUSH
9739: CALL_OW 67
// p := p + 1 ;
9743: LD_ADDR_VAR 0 2
9747: PUSH
9748: LD_VAR 0 2
9752: PUSH
9753: LD_INT 1
9755: PLUS
9756: ST_TO_ADDR
// until GetDistUnits ( Lisa , Frank ) < 7 or p > 7 ;
9757: LD_EXP 39
9761: PPUSH
9762: LD_EXP 50
9766: PPUSH
9767: CALL_OW 296
9771: PUSH
9772: LD_INT 7
9774: LESS
9775: PUSH
9776: LD_VAR 0 2
9780: PUSH
9781: LD_INT 7
9783: GREATER
9784: OR
9785: IFFALSE 9736
// Say ( Lisa , D6-Lisa-1 ) ;
9787: LD_EXP 39
9791: PPUSH
9792: LD_STRING D6-Lisa-1
9794: PPUSH
9795: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9799: LD_EXP 39
9803: PPUSH
9804: LD_EXP 50
9808: PPUSH
9809: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9813: LD_EXP 50
9817: PPUSH
9818: LD_EXP 39
9822: PPUSH
9823: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9827: LD_EXP 50
9831: PPUSH
9832: LD_STRING D6-Frank-2
9834: PPUSH
9835: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9839: LD_EXP 46
9843: PUSH
9844: LD_EXP 46
9848: PPUSH
9849: LD_EXP 50
9853: PPUSH
9854: CALL_OW 296
9858: PUSH
9859: LD_INT 20
9861: LESS
9862: AND
9863: PUSH
9864: LD_EXP 46
9868: PPUSH
9869: CALL_OW 302
9873: AND
9874: IFFALSE 10055
// begin ComTurnUnit ( Lynch , JMM ) ;
9876: LD_EXP 46
9880: PPUSH
9881: LD_EXP 36
9885: PPUSH
9886: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9890: LD_EXP 50
9894: PPUSH
9895: LD_EXP 36
9899: PPUSH
9900: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9904: LD_EXP 46
9908: PPUSH
9909: LD_STRING D6-Sol1-2
9911: PPUSH
9912: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9916: LD_EXP 36
9920: PPUSH
9921: LD_STRING D6-JMM-2
9923: PPUSH
9924: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9928: LD_EXP 50
9932: PPUSH
9933: LD_STRING D6-Frank-3
9935: PPUSH
9936: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9940: LD_EXP 36
9944: PPUSH
9945: LD_STRING D6-JMM-3
9947: PPUSH
9948: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9952: LD_EXP 50
9956: PPUSH
9957: LD_STRING D6-Frank-4
9959: PPUSH
9960: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9964: LD_EXP 50
9968: PPUSH
9969: LD_STRING D6-Frank-4a
9971: PPUSH
9972: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9976: LD_EXP 36
9980: PPUSH
9981: LD_STRING D6-JMM-4
9983: PPUSH
9984: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9988: LD_EXP 50
9992: PPUSH
9993: LD_STRING D6-Frank-5
9995: PPUSH
9996: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10000: LD_EXP 39
10004: PUSH
10005: LD_EXP 39
10009: PPUSH
10010: CALL_OW 302
10014: AND
10015: IFFALSE 10029
// Say ( Lisa , D6-Lisa-5 ) ;
10017: LD_EXP 39
10021: PPUSH
10022: LD_STRING D6-Lisa-5
10024: PPUSH
10025: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10029: LD_EXP 50
10033: PPUSH
10034: LD_STRING D6-Frank-6
10036: PPUSH
10037: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10041: LD_EXP 36
10045: PPUSH
10046: LD_STRING D6-JMM-6
10048: PPUSH
10049: CALL_OW 88
// end else
10053: GO 10170
// begin ComTurnUnit ( Frank , JMM ) ;
10055: LD_EXP 50
10059: PPUSH
10060: LD_EXP 36
10064: PPUSH
10065: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
10069: LD_EXP 50
10073: PPUSH
10074: LD_STRING D6-Frank-4
10076: PPUSH
10077: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10081: LD_EXP 50
10085: PPUSH
10086: LD_STRING D6-Frank-4a
10088: PPUSH
10089: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10093: LD_EXP 36
10097: PPUSH
10098: LD_STRING D6-JMM-4
10100: PPUSH
10101: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10105: LD_EXP 50
10109: PPUSH
10110: LD_STRING D6-Frank-5
10112: PPUSH
10113: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10117: LD_EXP 39
10121: PUSH
10122: LD_EXP 39
10126: PPUSH
10127: CALL_OW 302
10131: AND
10132: IFFALSE 10146
// Say ( Lisa , D6-Lisa-5 ) ;
10134: LD_EXP 39
10138: PPUSH
10139: LD_STRING D6-Lisa-5
10141: PPUSH
10142: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10146: LD_EXP 50
10150: PPUSH
10151: LD_STRING D6-Frank-6
10153: PPUSH
10154: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10158: LD_EXP 36
10162: PPUSH
10163: LD_STRING D6-JMM-6
10165: PPUSH
10166: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
10170: LD_STRING Q1
10172: PPUSH
10173: CALL_OW 97
10177: PUSH
10178: LD_INT 1
10180: DOUBLE
10181: EQUAL
10182: IFTRUE 10186
10184: GO 10197
10186: POP
// frank_send_to_scout := true ; 2 :
10187: LD_ADDR_EXP 14
10191: PUSH
10192: LD_INT 1
10194: ST_TO_ADDR
10195: GO 10217
10197: LD_INT 2
10199: DOUBLE
10200: EQUAL
10201: IFTRUE 10205
10203: GO 10216
10205: POP
// frank_send_to_scout := false ; end ;
10206: LD_ADDR_EXP 14
10210: PUSH
10211: LD_INT 0
10213: ST_TO_ADDR
10214: GO 10217
10216: POP
// Video ( false ) ;
10217: LD_INT 0
10219: PPUSH
10220: CALL 1185 0 1
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
10224: LD_EXP 36
10228: PUSH
10229: LD_EXP 39
10233: PUSH
10234: LD_EXP 46
10238: PUSH
10239: EMPTY
10240: LIST
10241: LIST
10242: LIST
10243: PPUSH
10244: CALL_OW 139
// if frank_send_to_scout then
10248: LD_EXP 14
10252: IFFALSE 10306
// begin repeat ComMoveToArea ( Frank , cyrusEscape ) ;
10254: LD_EXP 50
10258: PPUSH
10259: LD_INT 15
10261: PPUSH
10262: CALL_OW 113
// wait ( 0 0$01 ) ;
10266: LD_INT 35
10268: PPUSH
10269: CALL_OW 67
// until not See ( 1 , Frank ) ;
10273: LD_INT 1
10275: PPUSH
10276: LD_EXP 50
10280: PPUSH
10281: CALL_OW 292
10285: NOT
10286: IFFALSE 10254
// wait ( 0 0$02 ) ;
10288: LD_INT 70
10290: PPUSH
10291: CALL_OW 67
// RemoveUnit ( Frank ) ;
10295: LD_EXP 50
10299: PPUSH
10300: CALL_OW 64
// end else
10304: GO 10318
// SetSide ( Frank , 1 ) ;
10306: LD_EXP 50
10310: PPUSH
10311: LD_INT 1
10313: PPUSH
10314: CALL_OW 235
// send_attack_on_cornel_base := true ;
10318: LD_ADDR_EXP 25
10322: PUSH
10323: LD_INT 1
10325: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10326: LD_INT 35
10328: PPUSH
10329: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10333: LD_ADDR_EXP 28
10337: PUSH
10338: LD_EXP 28
10342: PPUSH
10343: LD_STRING -
10345: PPUSH
10346: CALL 1117 0 2
10350: ST_TO_ADDR
// if debug then
10351: LD_EXP 1
10355: IFFALSE 10367
// debug_strings := time_to_prepare ;
10357: LD_ADDR_OWVAR 48
10361: PUSH
10362: LD_EXP 28
10366: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10367: LD_EXP 28
10371: PUSH
10372: LD_INT 0
10374: EQUAL
10375: IFFALSE 10326
// cornel_prepared := true ;
10377: LD_ADDR_EXP 11
10381: PUSH
10382: LD_INT 1
10384: ST_TO_ADDR
// end ;
10385: PPOPN 3
10387: END
// every 0 0$01 trigger cornel_prepared do
10388: LD_EXP 11
10392: IFFALSE 10656
10394: GO 10396
10396: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10397: LD_EXP 43
10401: PPUSH
10402: LD_STRING D3-Corn-1
10404: PPUSH
10405: CALL_OW 94
// ChangeMissionObjectives ( MOutWait ) ;
10409: LD_STRING MOutWait
10411: PPUSH
10412: CALL_OW 337
// repeat wait ( 0 0$01 ) ;
10416: LD_INT 35
10418: PPUSH
10419: CALL_OW 67
// until cornel_counter = 0 ;
10423: LD_EXP 10
10427: PUSH
10428: LD_INT 0
10430: EQUAL
10431: IFFALSE 10416
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10433: LD_EXP 43
10437: PPUSH
10438: LD_STRING D3a-Corn-1
10440: PPUSH
10441: CALL_OW 94
// if IsOk ( Cornel ) then
10445: LD_EXP 43
10449: PPUSH
10450: CALL_OW 302
10454: IFFALSE 10468
// Say ( JMM , D3a-JMM-1 ) ;
10456: LD_EXP 36
10460: PPUSH
10461: LD_STRING D3a-JMM-1
10463: PPUSH
10464: CALL_OW 88
// end_mission_allowed := true ;
10468: LD_ADDR_EXP 20
10472: PUSH
10473: LD_INT 1
10475: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10476: LD_STRING M2
10478: PPUSH
10479: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10483: LD_INT 9
10485: PPUSH
10486: LD_INT 1
10488: PPUSH
10489: CALL_OW 424
// Wait ( 0 0$05 ) ;
10493: LD_INT 175
10495: PPUSH
10496: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10500: LD_EXP 43
10504: PPUSH
10505: LD_STRING D3a-Corn-2
10507: PPUSH
10508: CALL_OW 94
// cornel_attack := true ;
10512: LD_ADDR_EXP 9
10516: PUSH
10517: LD_INT 1
10519: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10520: LD_INT 105
10522: PPUSH
10523: CALL_OW 67
// AddMoreTanks ( ) ;
10527: CALL 4862 0 0
// if frank_send_to_scout then
10531: LD_EXP 14
10535: IFFALSE 10656
// begin InitHc ;
10537: CALL_OW 19
// InitUc ;
10541: CALL_OW 18
// uc_side := 8 ;
10545: LD_ADDR_OWVAR 20
10549: PUSH
10550: LD_INT 8
10552: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10553: LD_ADDR_EXP 50
10557: PUSH
10558: LD_STRING Frank
10560: PPUSH
10561: LD_INT 0
10563: PPUSH
10564: CALL 474 0 2
10568: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10569: LD_EXP 50
10573: PPUSH
10574: LD_INT 6
10576: PPUSH
10577: LD_INT 9
10579: PPUSH
10580: LD_INT 0
10582: PPUSH
10583: CALL_OW 48
// ComCrawl ( Frank ) ;
10587: LD_EXP 50
10591: PPUSH
10592: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
10596: LD_INT 35
10598: PPUSH
10599: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
10603: LD_EXP 36
10607: PPUSH
10608: LD_EXP 50
10612: PPUSH
10613: CALL_OW 296
10617: PUSH
10618: LD_INT 9
10620: LESS
10621: IFFALSE 10596
// SetSide ( Frank , 1 ) ;
10623: LD_EXP 50
10627: PPUSH
10628: LD_INT 1
10630: PPUSH
10631: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10635: LD_EXP 50
10639: PPUSH
10640: LD_STRING D6a-Frank-1
10642: PPUSH
10643: CALL_OW 88
// ComWalk ( Frank ) ;
10647: LD_EXP 50
10651: PPUSH
10652: CALL_OW 138
// end ; end ;
10656: END
// every 0 0$01 trigger solar_builded do
10657: LD_EXP 13
10661: IFFALSE 10765
10663: GO 10665
10665: DISABLE
// begin Wait ( 0 0$02 ) ;
10666: LD_INT 70
10668: PPUSH
10669: CALL_OW 67
// DialogueOn ;
10673: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10677: LD_EXP 36
10681: PPUSH
10682: LD_STRING D2b-JMM-1
10684: PPUSH
10685: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10689: LD_EXP 47
10693: PUSH
10694: LD_EXP 47
10698: PPUSH
10699: CALL_OW 302
10703: AND
10704: IFFALSE 10754
// begin Say ( Walker , D2b-Sci1-1 ) ;
10706: LD_EXP 47
10710: PPUSH
10711: LD_STRING D2b-Sci1-1
10713: PPUSH
10714: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10718: LD_EXP 36
10722: PPUSH
10723: LD_STRING D2b-JMM-2
10725: PPUSH
10726: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10730: LD_EXP 47
10734: PPUSH
10735: LD_STRING D2b-Sci1-2
10737: PPUSH
10738: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10742: LD_EXP 36
10746: PPUSH
10747: LD_STRING D2b-JMM-3
10749: PPUSH
10750: CALL_OW 88
// end ; DialogueOff ;
10754: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10758: LD_STRING MOutSol
10760: PPUSH
10761: CALL_OW 337
// end ;
10765: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10766: LD_EXP 13
10770: PUSH
10771: LD_EXP 36
10775: PPUSH
10776: CALL_OW 302
10780: AND
10781: PUSH
10782: LD_EXP 36
10786: PPUSH
10787: CALL 951 0 1
10791: AND
10792: PUSH
10793: LD_EXP 15
10797: NOT
10798: AND
10799: IFFALSE 10870
10801: GO 10803
10803: DISABLE
10804: LD_INT 0
10806: PPUSH
// begin jmm_in_veh := true ;
10807: LD_ADDR_EXP 15
10811: PUSH
10812: LD_INT 1
10814: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10815: LD_ADDR_VAR 0 1
10819: PUSH
10820: LD_INT 0
10822: PPUSH
10823: LD_INT 1
10825: PPUSH
10826: CALL_OW 12
10830: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10831: LD_INT 70
10833: PPUSH
10834: CALL_OW 67
// if i then
10838: LD_VAR 0 1
10842: IFFALSE 10858
// Say ( JMM , D2c-JMM-1 ) else
10844: LD_EXP 36
10848: PPUSH
10849: LD_STRING D2c-JMM-1
10851: PPUSH
10852: CALL_OW 88
10856: GO 10870
// Say ( JMM , D2c-JMM-1a ) ;
10858: LD_EXP 36
10862: PPUSH
10863: LD_STRING D2c-JMM-1a
10865: PPUSH
10866: CALL_OW 88
// end ;
10870: PPOPN 1
10872: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10873: LD_EXP 13
10877: PUSH
10878: LD_EXP 37
10882: PPUSH
10883: CALL_OW 302
10887: AND
10888: PUSH
10889: LD_EXP 37
10893: PPUSH
10894: CALL 951 0 1
10898: AND
10899: PUSH
10900: LD_EXP 16
10904: NOT
10905: AND
10906: IFFALSE 10938
10908: GO 10910
10910: DISABLE
// begin bobby_in_veh := true ;
10911: LD_ADDR_EXP 16
10915: PUSH
10916: LD_INT 1
10918: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10919: LD_INT 70
10921: PPUSH
10922: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10926: LD_EXP 37
10930: PPUSH
10931: LD_STRING D2c-Bobby-1
10933: PPUSH
10934: CALL_OW 88
10938: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10939: LD_EXP 13
10943: PUSH
10944: LD_EXP 39
10948: PPUSH
10949: CALL_OW 302
10953: AND
10954: PUSH
10955: LD_EXP 39
10959: PPUSH
10960: CALL 951 0 1
10964: AND
10965: PUSH
10966: LD_EXP 18
10970: NOT
10971: AND
10972: IFFALSE 11004
10974: GO 10976
10976: DISABLE
// begin lisa_in_veh := true ;
10977: LD_ADDR_EXP 18
10981: PUSH
10982: LD_INT 1
10984: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10985: LD_INT 70
10987: PPUSH
10988: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10992: LD_EXP 39
10996: PPUSH
10997: LD_STRING D2c-Lisa-1
10999: PPUSH
11000: CALL_OW 88
11004: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
11005: LD_EXP 13
11009: PUSH
11010: LD_EXP 38
11014: PPUSH
11015: CALL_OW 302
11019: AND
11020: PUSH
11021: LD_EXP 38
11025: PPUSH
11026: CALL 951 0 1
11030: AND
11031: PUSH
11032: LD_EXP 17
11036: NOT
11037: AND
11038: IFFALSE 11109
11040: GO 11042
11042: DISABLE
11043: LD_INT 0
11045: PPUSH
// begin cyrus_in_veh := true ;
11046: LD_ADDR_EXP 17
11050: PUSH
11051: LD_INT 1
11053: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
11054: LD_ADDR_VAR 0 1
11058: PUSH
11059: LD_INT 0
11061: PPUSH
11062: LD_INT 1
11064: PPUSH
11065: CALL_OW 12
11069: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11070: LD_INT 70
11072: PPUSH
11073: CALL_OW 67
// if i then
11077: LD_VAR 0 1
11081: IFFALSE 11097
// Say ( Cyrus , D2c-Cyrus-1 ) else
11083: LD_EXP 38
11087: PPUSH
11088: LD_STRING D2c-Cyrus-1
11090: PPUSH
11091: CALL_OW 88
11095: GO 11109
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11097: LD_EXP 38
11101: PPUSH
11102: LD_STRING D2c-Cyrus-1a
11104: PPUSH
11105: CALL_OW 88
// end ;
11109: PPOPN 1
11111: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
11112: LD_EXP 43
11116: PPUSH
11117: LD_INT 16
11119: PPUSH
11120: CALL_OW 308
11124: IFFALSE 11405
11126: GO 11128
11128: DISABLE
11129: LD_INT 0
11131: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
11132: LD_INT 3
11134: PPUSH
11135: LD_EXP 43
11139: PPUSH
11140: CALL_OW 471
// send_attack_on_cornel := true ;
11144: LD_ADDR_EXP 31
11148: PUSH
11149: LD_INT 1
11151: ST_TO_ADDR
// if ru_vehicles then
11152: LD_EXP 55
11156: IFFALSE 11190
// for i in ru_vehicles do
11158: LD_ADDR_VAR 0 1
11162: PUSH
11163: LD_EXP 55
11167: PUSH
11168: FOR_IN
11169: IFFALSE 11188
// ComAgressiveMove ( i , 215 , 69 ) ;
11171: LD_VAR 0 1
11175: PPUSH
11176: LD_INT 215
11178: PPUSH
11179: LD_INT 69
11181: PPUSH
11182: CALL_OW 114
11186: GO 11168
11188: POP
11189: POP
// if ru_patrol then
11190: LD_EXP 52
11194: IFFALSE 11228
// for i in ru_patrol do
11196: LD_ADDR_VAR 0 1
11200: PUSH
11201: LD_EXP 52
11205: PUSH
11206: FOR_IN
11207: IFFALSE 11226
// ComAgressiveMove ( i , 215 , 69 ) ;
11209: LD_VAR 0 1
11213: PPUSH
11214: LD_INT 215
11216: PPUSH
11217: LD_INT 69
11219: PPUSH
11220: CALL_OW 114
11224: GO 11206
11226: POP
11227: POP
// if frank_send_to_scout then
11228: LD_EXP 14
11232: IFFALSE 11246
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
11234: LD_EXP 50
11238: PPUSH
11239: LD_STRING D3b-Frank-1
11241: PPUSH
11242: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
11246: LD_INT 105
11248: PPUSH
11249: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
11253: LD_EXP 43
11257: PPUSH
11258: LD_STRING D4-Corn-1
11260: PPUSH
11261: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
11265: LD_INT 35
11267: PPUSH
11268: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) < 6 ;
11272: LD_INT 22
11274: PUSH
11275: LD_INT 4
11277: PUSH
11278: EMPTY
11279: LIST
11280: LIST
11281: PUSH
11282: LD_INT 21
11284: PUSH
11285: LD_INT 1
11287: PUSH
11288: EMPTY
11289: LIST
11290: LIST
11291: PUSH
11292: LD_INT 3
11294: PUSH
11295: LD_INT 24
11297: PUSH
11298: LD_INT 1000
11300: PUSH
11301: EMPTY
11302: LIST
11303: LIST
11304: PUSH
11305: EMPTY
11306: LIST
11307: LIST
11308: PUSH
11309: EMPTY
11310: LIST
11311: LIST
11312: LIST
11313: PPUSH
11314: CALL_OW 69
11318: PUSH
11319: LD_INT 6
11321: LESS
11322: IFFALSE 11265
// if Cornel then
11324: LD_EXP 43
11328: IFFALSE 11368
// begin SayRadio ( Cornel , D5-Corn-1 ) ;
11330: LD_EXP 43
11334: PPUSH
11335: LD_STRING D5-Corn-1
11337: PPUSH
11338: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11342: LD_EXP 43
11346: PPUSH
11347: LD_EXP 2
11351: PUSH
11352: LD_STRING Cornel
11354: STR
11355: PPUSH
11356: CALL_OW 38
// cornel_saved := true ;
11360: LD_ADDR_EXP 26
11364: PUSH
11365: LD_INT 1
11367: ST_TO_ADDR
// end ; ChangeSideFog ( 4 , 8 ) ;
11368: LD_INT 4
11370: PPUSH
11371: LD_INT 8
11373: PPUSH
11374: CALL_OW 343
// Wait ( 0 0$01 ) ;
11378: LD_INT 35
11380: PPUSH
11381: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11385: LD_INT 3
11387: PPUSH
11388: LD_EXP 43
11392: PPUSH
11393: CALL_OW 472
// send_attack_on_cornel := false ;
11397: LD_ADDR_EXP 31
11401: PUSH
11402: LD_INT 0
11404: ST_TO_ADDR
// end ;
11405: PPOPN 1
11407: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11408: LD_INT 9
11410: PPUSH
11411: LD_INT 22
11413: PUSH
11414: LD_INT 1
11416: PUSH
11417: EMPTY
11418: LIST
11419: LIST
11420: PPUSH
11421: CALL_OW 70
11425: PUSH
11426: LD_EXP 32
11430: OR
11431: IFFALSE 11628
11433: GO 11435
11435: DISABLE
11436: LD_INT 0
11438: PPUSH
11439: PPUSH
// begin enable ;
11440: ENABLE
// if not jmm_on_west then
11441: LD_EXP 5
11445: NOT
11446: IFFALSE 11457
// begin YouLost ( 4 ) ;
11448: LD_STRING 4
11450: PPUSH
11451: CALL_OW 104
// exit ;
11455: GO 11628
// end ; if not game_end then
11457: LD_EXP 32
11461: NOT
11462: IFFALSE 11472
// game_end := true ;
11464: LD_ADDR_EXP 32
11468: PUSH
11469: LD_INT 1
11471: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11472: LD_ADDR_VAR 0 2
11476: PUSH
11477: LD_INT 9
11479: PPUSH
11480: LD_INT 22
11482: PUSH
11483: LD_INT 1
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: PPUSH
11490: CALL_OW 70
11494: ST_TO_ADDR
// if not filter then
11495: LD_VAR 0 2
11499: NOT
11500: IFFALSE 11504
// exit ;
11502: GO 11628
// for i in filter do
11504: LD_ADDR_VAR 0 1
11508: PUSH
11509: LD_VAR 0 2
11513: PUSH
11514: FOR_IN
11515: IFFALSE 11626
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle and GetNation ( i ) = nation_american then
11517: LD_VAR 0 1
11521: PPUSH
11522: CALL_OW 302
11526: PUSH
11527: LD_VAR 0 1
11531: PPUSH
11532: CALL_OW 247
11536: PUSH
11537: LD_INT 2
11539: EQUAL
11540: AND
11541: PUSH
11542: LD_VAR 0 1
11546: PPUSH
11547: CALL_OW 248
11551: PUSH
11552: LD_INT 1
11554: EQUAL
11555: AND
11556: IFFALSE 11589
// begin veh_on_meta := true ;
11558: LD_ADDR_EXP 27
11562: PUSH
11563: LD_INT 1
11565: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11566: LD_VAR 0 1
11570: PPUSH
11571: CALL_OW 311
11575: PPUSH
11576: CALL 11631 0 1
// RemoveUnit ( i ) ;
11580: LD_VAR 0 1
11584: PPUSH
11585: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11589: LD_VAR 0 1
11593: PPUSH
11594: CALL_OW 302
11598: PUSH
11599: LD_VAR 0 1
11603: PPUSH
11604: CALL_OW 247
11608: PUSH
11609: LD_INT 1
11611: EQUAL
11612: AND
11613: IFFALSE 11624
// Save ( i ) ;
11615: LD_VAR 0 1
11619: PPUSH
11620: CALL 11631 0 1
// end ;
11624: GO 11514
11626: POP
11627: POP
// end ;
11628: PPOPN 2
11630: END
// export function Save ( i ) ; begin
11631: LD_INT 0
11633: PPUSH
// save_counter := save_counter + 1 ;
11634: LD_ADDR_EXP 35
11638: PUSH
11639: LD_EXP 35
11643: PUSH
11644: LD_INT 1
11646: PLUS
11647: ST_TO_ADDR
// if i = JMM then
11648: LD_VAR 0 1
11652: PUSH
11653: LD_EXP 36
11657: EQUAL
11658: IFFALSE 11780
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11660: LD_EXP 23
11664: PUSH
11665: LD_INT 22
11667: PUSH
11668: LD_INT 1
11670: PUSH
11671: EMPTY
11672: LIST
11673: LIST
11674: PUSH
11675: LD_INT 21
11677: PUSH
11678: LD_INT 1
11680: PUSH
11681: EMPTY
11682: LIST
11683: LIST
11684: PUSH
11685: EMPTY
11686: LIST
11687: LIST
11688: PPUSH
11689: CALL_OW 69
11693: PUSH
11694: LD_INT 1
11696: GREATER
11697: AND
11698: IFFALSE 11755
// begin show_query := false ;
11700: LD_ADDR_EXP 23
11704: PUSH
11705: LD_INT 0
11707: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11708: LD_STRING Q2
11710: PPUSH
11711: CALL_OW 97
11715: PUSH
11716: LD_INT 1
11718: DOUBLE
11719: EQUAL
11720: IFTRUE 11724
11722: GO 11735
11724: POP
// wait_for_them := true ; 2 :
11725: LD_ADDR_EXP 24
11729: PUSH
11730: LD_INT 1
11732: ST_TO_ADDR
11733: GO 11755
11735: LD_INT 2
11737: DOUBLE
11738: EQUAL
11739: IFTRUE 11743
11741: GO 11754
11743: POP
// wait_for_them := false ; end ;
11744: LD_ADDR_EXP 24
11748: PUSH
11749: LD_INT 0
11751: ST_TO_ADDR
11752: GO 11755
11754: POP
// end ; save_group := save_group ^ JMM ;
11755: LD_ADDR_EXP 22
11759: PUSH
11760: LD_EXP 22
11764: PUSH
11765: LD_EXP 36
11769: ADD
11770: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11771: LD_EXP 36
11775: PPUSH
11776: CALL_OW 64
// end ; if i = Lisa then
11780: LD_VAR 0 1
11784: PUSH
11785: LD_EXP 39
11789: EQUAL
11790: IFFALSE 11817
// begin save_group := save_group ^ Lisa ;
11792: LD_ADDR_EXP 22
11796: PUSH
11797: LD_EXP 22
11801: PUSH
11802: LD_EXP 39
11806: ADD
11807: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11808: LD_EXP 39
11812: PPUSH
11813: CALL_OW 64
// end ; if i = Bobby then
11817: LD_VAR 0 1
11821: PUSH
11822: LD_EXP 37
11826: EQUAL
11827: IFFALSE 11854
// begin save_group := save_group ^ Bobby ;
11829: LD_ADDR_EXP 22
11833: PUSH
11834: LD_EXP 22
11838: PUSH
11839: LD_EXP 37
11843: ADD
11844: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11845: LD_EXP 37
11849: PPUSH
11850: CALL_OW 64
// end ; if i = Cyrus then
11854: LD_VAR 0 1
11858: PUSH
11859: LD_EXP 38
11863: EQUAL
11864: IFFALSE 11891
// begin save_group := save_group ^ Cyrus ;
11866: LD_ADDR_EXP 22
11870: PUSH
11871: LD_EXP 22
11875: PUSH
11876: LD_EXP 38
11880: ADD
11881: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11882: LD_EXP 38
11886: PPUSH
11887: CALL_OW 64
// end ; if i = Khatam then
11891: LD_VAR 0 1
11895: PUSH
11896: LD_EXP 40
11900: EQUAL
11901: IFFALSE 11928
// begin save_group := save_group ^ Khatam ;
11903: LD_ADDR_EXP 22
11907: PUSH
11908: LD_EXP 22
11912: PUSH
11913: LD_EXP 40
11917: ADD
11918: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11919: LD_EXP 40
11923: PPUSH
11924: CALL_OW 64
// end ; if i = Frank then
11928: LD_VAR 0 1
11932: PUSH
11933: LD_EXP 50
11937: EQUAL
11938: IFFALSE 11965
// begin save_group := save_group ^ Frank ;
11940: LD_ADDR_EXP 22
11944: PUSH
11945: LD_EXP 22
11949: PUSH
11950: LD_EXP 50
11954: ADD
11955: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11956: LD_EXP 50
11960: PPUSH
11961: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11965: LD_VAR 0 1
11969: PPUSH
11970: CALL_OW 302
11974: PUSH
11975: LD_VAR 0 1
11979: PPUSH
11980: CALL_OW 247
11984: PUSH
11985: LD_INT 1
11987: EQUAL
11988: AND
11989: PUSH
11990: LD_VAR 0 1
11994: PUSH
11995: LD_EXP 22
11999: IN
12000: NOT
12001: AND
12002: IFFALSE 12029
// begin save_others := save_others ^ i ;
12004: LD_ADDR_EXP 21
12008: PUSH
12009: LD_EXP 21
12013: PUSH
12014: LD_VAR 0 1
12018: ADD
12019: ST_TO_ADDR
// RemoveUnit ( i ) ;
12020: LD_VAR 0 1
12024: PPUSH
12025: CALL_OW 64
// end ; end ;
12029: LD_VAR 0 2
12033: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
12034: LD_EXP 23
12038: NOT
12039: PUSH
12040: LD_EXP 24
12044: NOT
12045: AND
12046: PUSH
12047: LD_INT 22
12049: PUSH
12050: LD_INT 1
12052: PUSH
12053: EMPTY
12054: LIST
12055: LIST
12056: PUSH
12057: LD_INT 21
12059: PUSH
12060: LD_INT 1
12062: PUSH
12063: EMPTY
12064: LIST
12065: LIST
12066: PUSH
12067: EMPTY
12068: LIST
12069: LIST
12070: PPUSH
12071: CALL_OW 69
12075: PUSH
12076: LD_INT 0
12078: EQUAL
12079: OR
12080: IFFALSE 12089
12082: GO 12084
12084: DISABLE
// EndMission ;
12085: CALL 12090 0 0
12089: END
// export function EndMission ; var i ; begin
12090: LD_INT 0
12092: PPUSH
12093: PPUSH
// Wait ( 0 0$02 ) ;
12094: LD_INT 70
12096: PPUSH
12097: CALL_OW 67
// if solar_builded then
12101: LD_EXP 13
12105: IFFALSE 12119
// AddMedal ( Solar1 , 1 ) else
12107: LD_STRING Solar1
12109: PPUSH
12110: LD_INT 1
12112: PPUSH
12113: CALL_OW 101
12117: GO 12130
// AddMedal ( Solar1 , - 1 ) ;
12119: LD_STRING Solar1
12121: PPUSH
12122: LD_INT 1
12124: NEG
12125: PPUSH
12126: CALL_OW 101
// if veh_on_meta then
12130: LD_EXP 27
12134: IFFALSE 12148
// AddMedal ( Solar2 , 1 ) else
12136: LD_STRING Solar2
12138: PPUSH
12139: LD_INT 1
12141: PPUSH
12142: CALL_OW 101
12146: GO 12178
// if solar_builded then
12148: LD_EXP 13
12152: IFFALSE 12167
// AddMedal ( Solar2 , - 1 ) else
12154: LD_STRING Solar2
12156: PPUSH
12157: LD_INT 1
12159: NEG
12160: PPUSH
12161: CALL_OW 101
12165: GO 12178
// AddMedal ( Solar2 , - 2 ) ;
12167: LD_STRING Solar2
12169: PPUSH
12170: LD_INT 2
12172: NEG
12173: PPUSH
12174: CALL_OW 101
// if lose_counter = 0 then
12178: LD_EXP 33
12182: PUSH
12183: LD_INT 0
12185: EQUAL
12186: IFFALSE 12200
// AddMedal ( No , 1 ) else
12188: LD_STRING No
12190: PPUSH
12191: LD_INT 1
12193: PPUSH
12194: CALL_OW 101
12198: GO 12244
// if lose_counter > 0 and lose_counter < 4 then
12200: LD_EXP 33
12204: PUSH
12205: LD_INT 0
12207: GREATER
12208: PUSH
12209: LD_EXP 33
12213: PUSH
12214: LD_INT 4
12216: LESS
12217: AND
12218: IFFALSE 12233
// AddMedal ( No , - 1 ) else
12220: LD_STRING No
12222: PPUSH
12223: LD_INT 1
12225: NEG
12226: PPUSH
12227: CALL_OW 101
12231: GO 12244
// AddMedal ( UpTo4 , - 1 ) ;
12233: LD_STRING UpTo4
12235: PPUSH
12236: LD_INT 1
12238: NEG
12239: PPUSH
12240: CALL_OW 101
// GiveMedals ( MAIN ) ;
12244: LD_STRING MAIN
12246: PPUSH
12247: CALL_OW 102
// if IsDead ( Pokryshkin ) then
12251: LD_EXP 51
12255: PPUSH
12256: CALL_OW 301
12260: IFFALSE 12300
// for i in save_group ^ save_others do
12262: LD_ADDR_VAR 0 2
12266: PUSH
12267: LD_EXP 22
12271: PUSH
12272: LD_EXP 21
12276: ADD
12277: PUSH
12278: FOR_IN
12279: IFFALSE 12298
// AddExperience ( i , skill_combat , 1500 ) ;
12281: LD_VAR 0 2
12285: PPUSH
12286: LD_INT 1
12288: PPUSH
12289: LD_INT 1500
12291: PPUSH
12292: CALL_OW 492
12296: GO 12278
12298: POP
12299: POP
// RewardPeople ( save_group ^ save_others ) ;
12300: LD_EXP 22
12304: PUSH
12305: LD_EXP 21
12309: ADD
12310: PPUSH
12311: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
12315: LD_EXP 36
12319: PPUSH
12320: LD_EXP 2
12324: PUSH
12325: LD_STRING JMM
12327: STR
12328: PPUSH
12329: CALL_OW 38
// if Bobby in save_group then
12333: LD_EXP 37
12337: PUSH
12338: LD_EXP 22
12342: IN
12343: IFFALSE 12363
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12345: LD_EXP 37
12349: PPUSH
12350: LD_EXP 2
12354: PUSH
12355: LD_STRING Bobby
12357: STR
12358: PPUSH
12359: CALL_OW 38
// if Cyrus in save_group then
12363: LD_EXP 38
12367: PUSH
12368: LD_EXP 22
12372: IN
12373: IFFALSE 12393
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12375: LD_EXP 38
12379: PPUSH
12380: LD_EXP 2
12384: PUSH
12385: LD_STRING Cyrus
12387: STR
12388: PPUSH
12389: CALL_OW 38
// if Lisa in save_group then
12393: LD_EXP 39
12397: PUSH
12398: LD_EXP 22
12402: IN
12403: IFFALSE 12423
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12405: LD_EXP 39
12409: PPUSH
12410: LD_EXP 2
12414: PUSH
12415: LD_STRING Lisa
12417: STR
12418: PPUSH
12419: CALL_OW 38
// if Frank in save_group then
12423: LD_EXP 50
12427: PUSH
12428: LD_EXP 22
12432: IN
12433: IFFALSE 12453
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12435: LD_EXP 50
12439: PPUSH
12440: LD_EXP 2
12444: PUSH
12445: LD_STRING Frank
12447: STR
12448: PPUSH
12449: CALL_OW 38
// if Khatam in save_group then
12453: LD_EXP 40
12457: PUSH
12458: LD_EXP 22
12462: IN
12463: IFFALSE 12483
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
12465: LD_EXP 40
12469: PPUSH
12470: LD_EXP 2
12474: PUSH
12475: LD_STRING Khatam
12477: STR
12478: PPUSH
12479: CALL_OW 38
// if save_others then
12483: LD_EXP 21
12487: IFFALSE 12501
// SaveCharacters ( save_others , 03_others ) ;
12489: LD_EXP 21
12493: PPUSH
12494: LD_STRING 03_others
12496: PPUSH
12497: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) and cornel_saved then
12501: LD_EXP 44
12505: PUSH
12506: LD_EXP 44
12510: PPUSH
12511: CALL_OW 302
12515: AND
12516: PUSH
12517: LD_EXP 26
12521: AND
12522: IFFALSE 12534
// begin ResetFog ;
12524: CALL_OW 335
// DisplayEndingScene ;
12528: CALL 12556 0 0
// end else
12532: GO 12547
// DeleteCharacters ( mission_prefix & Cornel ) ;
12534: LD_EXP 2
12538: PUSH
12539: LD_STRING Cornel
12541: STR
12542: PPUSH
12543: CALL_OW 40
// YouWin ;
12547: CALL_OW 103
// end ;
12551: LD_VAR 0 1
12555: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
12556: LD_INT 0
12558: PPUSH
12559: PPUSH
12560: PPUSH
12561: PPUSH
12562: PPUSH
12563: PPUSH
// InGameOn ;
12564: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12568: LD_INT 208
12570: PPUSH
12571: LD_INT 62
12573: PPUSH
12574: LD_INT 1
12576: PPUSH
12577: LD_INT 10
12579: NEG
12580: PPUSH
12581: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
12585: LD_INT 208
12587: PPUSH
12588: LD_INT 62
12590: PPUSH
12591: LD_INT 1
12593: PPUSH
12594: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
12598: LD_ADDR_VAR 0 3
12602: PUSH
12603: LD_INT 22
12605: PUSH
12606: LD_INT 3
12608: PUSH
12609: EMPTY
12610: LIST
12611: LIST
12612: PUSH
12613: LD_INT 2
12615: PUSH
12616: LD_INT 21
12618: PUSH
12619: LD_INT 2
12621: PUSH
12622: EMPTY
12623: LIST
12624: LIST
12625: PUSH
12626: LD_INT 21
12628: PUSH
12629: LD_INT 1
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: PUSH
12636: EMPTY
12637: LIST
12638: LIST
12639: LIST
12640: PUSH
12641: EMPTY
12642: LIST
12643: LIST
12644: PPUSH
12645: CALL_OW 69
12649: ST_TO_ADDR
// if filter then
12650: LD_VAR 0 3
12654: IFFALSE 12682
// for i in filter do
12656: LD_ADDR_VAR 0 2
12660: PUSH
12661: LD_VAR 0 3
12665: PUSH
12666: FOR_IN
12667: IFFALSE 12680
// RemoveUnit ( i ) ;
12669: LD_VAR 0 2
12673: PPUSH
12674: CALL_OW 64
12678: GO 12666
12680: POP
12681: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
12682: LD_ADDR_VAR 0 3
12686: PUSH
12687: LD_INT 22
12689: PUSH
12690: LD_INT 4
12692: PUSH
12693: EMPTY
12694: LIST
12695: LIST
12696: PUSH
12697: LD_INT 21
12699: PUSH
12700: LD_INT 1
12702: PUSH
12703: EMPTY
12704: LIST
12705: LIST
12706: PUSH
12707: EMPTY
12708: LIST
12709: LIST
12710: PPUSH
12711: CALL_OW 69
12715: ST_TO_ADDR
// if filter then
12716: LD_VAR 0 3
12720: IFFALSE 12751
// for i in filter do
12722: LD_ADDR_VAR 0 2
12726: PUSH
12727: LD_VAR 0 3
12731: PUSH
12732: FOR_IN
12733: IFFALSE 12749
// SetLives ( i , 0 ) ;
12735: LD_VAR 0 2
12739: PPUSH
12740: LD_INT 0
12742: PPUSH
12743: CALL_OW 234
12747: GO 12732
12749: POP
12750: POP
// uc_side := 4 ;
12751: LD_ADDR_OWVAR 20
12755: PUSH
12756: LD_INT 4
12758: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12759: LD_ADDR_VAR 0 4
12763: PUSH
12764: LD_STRING Cornell
12766: PPUSH
12767: LD_INT 0
12769: PPUSH
12770: CALL 474 0 2
12774: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12775: LD_VAR 0 4
12779: PPUSH
12780: LD_INT 208
12782: PPUSH
12783: LD_INT 62
12785: PPUSH
12786: LD_INT 0
12788: PPUSH
12789: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12793: LD_VAR 0 4
12797: PPUSH
12798: LD_INT 100
12800: PPUSH
12801: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12805: LD_INT 3
12807: PPUSH
12808: LD_VAR 0 4
12812: PPUSH
12813: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12817: LD_INT 4
12819: PPUSH
12820: LD_INT 3
12822: PPUSH
12823: LD_INT 1
12825: PPUSH
12826: LD_INT 1
12828: PPUSH
12829: CALL_OW 80
// uc_side := 3 ;
12833: LD_ADDR_OWVAR 20
12837: PUSH
12838: LD_INT 3
12840: ST_TO_ADDR
// uc_nation := 3 ;
12841: LD_ADDR_OWVAR 21
12845: PUSH
12846: LD_INT 3
12848: ST_TO_ADDR
// InitHc ;
12849: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12853: LD_ADDR_VAR 0 5
12857: PUSH
12858: LD_STRING Mikhail
12860: PPUSH
12861: LD_INT 0
12863: PPUSH
12864: CALL 474 0 2
12868: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12869: LD_INT 1
12871: PPUSH
12872: LD_INT 1
12874: PPUSH
12875: LD_INT 0
12877: PPUSH
12878: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12882: LD_ADDR_VAR 0 6
12886: PUSH
12887: LD_VAR 0 6
12891: PUSH
12892: CALL_OW 44
12896: ADD
12897: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12898: LD_ADDR_VAR 0 6
12902: PUSH
12903: LD_VAR 0 6
12907: PUSH
12908: CALL_OW 44
12912: ADD
12913: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12914: LD_INT 2
12916: PPUSH
12917: LD_INT 4
12919: PPUSH
12920: LD_INT 0
12922: PPUSH
12923: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12927: LD_ADDR_VAR 0 6
12931: PUSH
12932: LD_VAR 0 6
12936: PUSH
12937: CALL_OW 44
12941: ADD
12942: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12943: LD_VAR 0 5
12947: PPUSH
12948: LD_INT 17
12950: PPUSH
12951: LD_INT 0
12953: PPUSH
12954: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12958: LD_VAR 0 5
12962: PPUSH
12963: LD_INT 210
12965: PPUSH
12966: LD_INT 63
12968: PPUSH
12969: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12973: LD_VAR 0 5
12977: PPUSH
12978: LD_INT 208
12980: PPUSH
12981: LD_INT 62
12983: PPUSH
12984: CALL_OW 178
// for i in fake_russians do
12988: LD_ADDR_VAR 0 2
12992: PUSH
12993: LD_VAR 0 6
12997: PUSH
12998: FOR_IN
12999: IFFALSE 13077
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
13001: LD_VAR 0 2
13005: PPUSH
13006: LD_INT 17
13008: PPUSH
13009: LD_INT 0
13011: PPUSH
13012: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
13016: LD_VAR 0 2
13020: PPUSH
13021: LD_INT 215
13023: PPUSH
13024: LD_INT 67
13026: PPUSH
13027: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
13031: LD_VAR 0 2
13035: PPUSH
13036: LD_INT 208
13038: PPUSH
13039: LD_INT 62
13041: PPUSH
13042: CALL_OW 178
// if GetClass ( i ) = 4 then
13046: LD_VAR 0 2
13050: PPUSH
13051: CALL_OW 257
13055: PUSH
13056: LD_INT 4
13058: EQUAL
13059: IFFALSE 13075
// ComHeal ( i , fake_cornel ) ;
13061: LD_VAR 0 2
13065: PPUSH
13066: LD_VAR 0 4
13070: PPUSH
13071: CALL_OW 128
// end ;
13075: GO 12998
13077: POP
13078: POP
// Wait ( 0 0$01 ) ;
13079: LD_INT 35
13081: PPUSH
13082: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
13086: LD_INT 208
13088: PPUSH
13089: LD_INT 62
13091: PPUSH
13092: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
13096: LD_INT 208
13098: PPUSH
13099: LD_INT 62
13101: PPUSH
13102: LD_INT 1
13104: PPUSH
13105: LD_INT 10
13107: NEG
13108: PPUSH
13109: CALL_OW 330
// Wait ( 0 0$15 ) ;
13113: LD_INT 525
13115: PPUSH
13116: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
13120: LD_INT 208
13122: PPUSH
13123: LD_INT 62
13125: PPUSH
13126: LD_INT 1
13128: PPUSH
13129: CALL_OW 331
// ResetFog ;
13133: CALL_OW 335
// InGameOff ;
13137: CALL_OW 9
// end ;
13141: LD_VAR 0 1
13145: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
13146: LD_INT 10
13148: PPUSH
13149: LD_INT 22
13151: PUSH
13152: LD_INT 1
13154: PUSH
13155: EMPTY
13156: LIST
13157: LIST
13158: PPUSH
13159: CALL_OW 70
13163: PUSH
13164: LD_EXP 43
13168: PPUSH
13169: CALL_OW 302
13173: AND
13174: PUSH
13175: LD_INT 22
13177: PUSH
13178: LD_INT 1
13180: PUSH
13181: EMPTY
13182: LIST
13183: LIST
13184: PPUSH
13185: CALL_OW 69
13189: PPUSH
13190: LD_EXP 43
13194: PPUSH
13195: CALL_OW 74
13199: PPUSH
13200: LD_EXP 43
13204: PPUSH
13205: CALL_OW 296
13209: PUSH
13210: LD_INT 30
13212: LESS
13213: OR
13214: IFFALSE 13265
13216: GO 13218
13218: DISABLE
// begin enable ;
13219: ENABLE
// powell_warn := powell_warn + 1 ;
13220: LD_ADDR_EXP 34
13224: PUSH
13225: LD_EXP 34
13229: PUSH
13230: LD_INT 1
13232: PLUS
13233: ST_TO_ADDR
// if powell_warn = 3 then
13234: LD_EXP 34
13238: PUSH
13239: LD_INT 3
13241: EQUAL
13242: IFFALSE 13253
// begin YouLost ( 5 ) ;
13244: LD_STRING 5
13246: PPUSH
13247: CALL_OW 104
// exit ;
13251: GO 13265
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
13253: LD_EXP 45
13257: PPUSH
13258: LD_STRING DWarn-Pow-1
13260: PPUSH
13261: CALL_OW 94
// end ; end_of_file
13265: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
13266: LD_EXP 8
13270: IFFALSE 15107
13272: GO 13274
13274: DISABLE
13275: LD_INT 0
13277: PPUSH
13278: PPUSH
13279: PPUSH
13280: PPUSH
13281: PPUSH
13282: PPUSH
13283: PPUSH
13284: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
13285: LD_EXP 43
13289: PUSH
13290: LD_EXP 44
13294: ADD
13295: PUSH
13296: LD_EXP 6
13300: ADD
13301: PPUSH
13302: LD_INT 250
13304: PPUSH
13305: LD_INT 120
13307: PPUSH
13308: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff Bierezov ;
13312: LD_ADDR_VAR 0 2
13316: PUSH
13317: LD_EXP 6
13321: PPUSH
13322: LD_INT 25
13324: PUSH
13325: LD_INT 2
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: PPUSH
13332: CALL_OW 72
13336: PUSH
13337: LD_EXP 44
13341: DIFF
13342: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) diff has_eng ;
13343: LD_ADDR_VAR 0 3
13347: PUSH
13348: LD_EXP 6
13352: PPUSH
13353: LD_INT 21
13355: PUSH
13356: LD_INT 1
13358: PUSH
13359: EMPTY
13360: LIST
13361: LIST
13362: PPUSH
13363: CALL_OW 72
13367: PUSH
13368: LD_VAR 0 2
13372: DIFF
13373: ST_TO_ADDR
// if not has_eng then
13374: LD_VAR 0 2
13378: NOT
13379: IFFALSE 13462
// begin uc_side := 4 ;
13381: LD_ADDR_OWVAR 20
13385: PUSH
13386: LD_INT 4
13388: ST_TO_ADDR
// uc_nation := 1 ;
13389: LD_ADDR_OWVAR 21
13393: PUSH
13394: LD_INT 1
13396: ST_TO_ADDR
// bc_type := b_depot ;
13397: LD_ADDR_OWVAR 42
13401: PUSH
13402: LD_INT 0
13404: ST_TO_ADDR
// bc_level := 2 ;
13405: LD_ADDR_OWVAR 43
13409: PUSH
13410: LD_INT 2
13412: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13413: LD_ADDR_VAR 0 4
13417: PUSH
13418: LD_INT 264
13420: PPUSH
13421: LD_INT 120
13423: PPUSH
13424: LD_INT 4
13426: PPUSH
13427: CALL_OW 47
13431: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13432: LD_INT 264
13434: PPUSH
13435: LD_INT 120
13437: PPUSH
13438: LD_INT 4
13440: PPUSH
13441: LD_INT 10
13443: NEG
13444: PPUSH
13445: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13449: LD_INT 264
13451: PPUSH
13452: LD_INT 120
13454: PPUSH
13455: LD_INT 4
13457: PPUSH
13458: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13462: LD_INT 35
13464: PPUSH
13465: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) or IsInArea ( IsInUnit ( Cornel ) , cornelBaseArea ) ;
13469: LD_EXP 43
13473: PPUSH
13474: LD_INT 10
13476: PPUSH
13477: CALL_OW 308
13481: PUSH
13482: LD_EXP 43
13486: PPUSH
13487: CALL_OW 310
13491: PPUSH
13492: LD_INT 10
13494: PPUSH
13495: CALL_OW 308
13499: OR
13500: IFFALSE 13462
// if has_eng and not dep then
13502: LD_VAR 0 2
13506: PUSH
13507: LD_VAR 0 4
13511: NOT
13512: AND
13513: IFFALSE 13663
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
13515: LD_VAR 0 2
13519: PPUSH
13520: LD_INT 0
13522: PPUSH
13523: LD_INT 264
13525: PPUSH
13526: LD_INT 120
13528: PPUSH
13529: LD_INT 4
13531: PPUSH
13532: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
13536: LD_INT 35
13538: PPUSH
13539: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
13543: LD_INT 22
13545: PUSH
13546: LD_INT 4
13548: PUSH
13549: EMPTY
13550: LIST
13551: LIST
13552: PUSH
13553: LD_INT 30
13555: PUSH
13556: LD_INT 0
13558: PUSH
13559: EMPTY
13560: LIST
13561: LIST
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PPUSH
13567: CALL_OW 69
13571: IFFALSE 13536
// ComMoveXY ( filter , 264 , 120 ) ;
13573: LD_VAR 0 3
13577: PPUSH
13578: LD_INT 264
13580: PPUSH
13581: LD_INT 120
13583: PPUSH
13584: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
13588: LD_INT 35
13590: PPUSH
13591: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
13595: LD_INT 22
13597: PUSH
13598: LD_INT 4
13600: PUSH
13601: EMPTY
13602: LIST
13603: LIST
13604: PUSH
13605: LD_INT 30
13607: PUSH
13608: LD_INT 0
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: PUSH
13615: LD_INT 3
13617: PUSH
13618: LD_INT 57
13620: PUSH
13621: EMPTY
13622: LIST
13623: PUSH
13624: EMPTY
13625: LIST
13626: LIST
13627: PUSH
13628: EMPTY
13629: LIST
13630: LIST
13631: LIST
13632: PPUSH
13633: CALL_OW 69
13637: IFFALSE 13588
// ComMoveXY ( filter , 247 , 113 ) ;
13639: LD_VAR 0 3
13643: PPUSH
13644: LD_INT 247
13646: PPUSH
13647: LD_INT 113
13649: PPUSH
13650: CALL_OW 111
// Wait ( 0 0$2 ) ;
13654: LD_INT 70
13656: PPUSH
13657: CALL_OW 67
// end else
13661: GO 13675
// begin SetSide ( dep , 4 ) ;
13663: LD_VAR 0 4
13667: PPUSH
13668: LD_INT 4
13670: PPUSH
13671: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
13675: LD_ADDR_VAR 0 4
13679: PUSH
13680: LD_INT 22
13682: PUSH
13683: LD_INT 4
13685: PUSH
13686: EMPTY
13687: LIST
13688: LIST
13689: PUSH
13690: LD_INT 30
13692: PUSH
13693: LD_INT 0
13695: PUSH
13696: EMPTY
13697: LIST
13698: LIST
13699: PUSH
13700: EMPTY
13701: LIST
13702: LIST
13703: PPUSH
13704: CALL_OW 69
13708: PUSH
13709: LD_INT 1
13711: ARRAY
13712: ST_TO_ADDR
// if not has_eng then
13713: LD_VAR 0 2
13717: NOT
13718: IFFALSE 13805
// for i = 1 to 2 do
13720: LD_ADDR_VAR 0 1
13724: PUSH
13725: DOUBLE
13726: LD_INT 1
13728: DEC
13729: ST_TO_ADDR
13730: LD_INT 2
13732: PUSH
13733: FOR_TO
13734: IFFALSE 13803
// begin ComEnterUnit ( filter [ 1 ] , dep ) ;
13736: LD_VAR 0 3
13740: PUSH
13741: LD_INT 1
13743: ARRAY
13744: PPUSH
13745: LD_VAR 0 4
13749: PPUSH
13750: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 2 ) ;
13754: LD_VAR 0 3
13758: PUSH
13759: LD_INT 1
13761: ARRAY
13762: PPUSH
13763: LD_INT 2
13765: PPUSH
13766: CALL_OW 183
// AddComExitBuilding ( filter [ 1 ] ) ;
13770: LD_VAR 0 3
13774: PUSH
13775: LD_INT 1
13777: ARRAY
13778: PPUSH
13779: CALL_OW 182
// filter := Delete ( filter , 1 ) ;
13783: LD_ADDR_VAR 0 3
13787: PUSH
13788: LD_VAR 0 3
13792: PPUSH
13793: LD_INT 1
13795: PPUSH
13796: CALL_OW 3
13800: ST_TO_ADDR
// end ;
13801: GO 13733
13803: POP
13804: POP
// if IsInUnit ( Cornel ) then
13805: LD_EXP 43
13809: PPUSH
13810: CALL_OW 310
13814: IFFALSE 13892
// begin cargo := IsInUnit ( Cornel ) ;
13816: LD_ADDR_VAR 0 7
13820: PUSH
13821: LD_EXP 43
13825: PPUSH
13826: CALL_OW 310
13830: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13831: LD_VAR 0 7
13835: PPUSH
13836: LD_INT 1
13838: PPUSH
13839: CALL_OW 289
13843: IFFALSE 13854
// ComUnload ( cargo ) ;
13845: LD_VAR 0 7
13849: PPUSH
13850: CALL_OW 159
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13854: LD_EXP 43
13858: PPUSH
13859: LD_INT 235
13861: PPUSH
13862: LD_INT 122
13864: PPUSH
13865: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13869: LD_EXP 43
13873: PPUSH
13874: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13878: LD_EXP 43
13882: PPUSH
13883: LD_VAR 0 4
13887: PPUSH
13888: CALL_OW 180
// end ; if Bierezov then
13892: LD_EXP 44
13896: IFFALSE 13944
// begin ComMoveXY ( Bierezov , 260 , 120 ) ;
13898: LD_EXP 44
13902: PPUSH
13903: LD_INT 260
13905: PPUSH
13906: LD_INT 120
13908: PPUSH
13909: CALL_OW 111
// if dep then
13913: LD_VAR 0 4
13917: IFFALSE 13935
// AddComEnterUnit ( Bierezov , dep ) else
13919: LD_EXP 44
13923: PPUSH
13924: LD_VAR 0 4
13928: PPUSH
13929: CALL_OW 180
13933: GO 13944
// AddComHold ( Bierezov ) ;
13935: LD_EXP 44
13939: PPUSH
13940: CALL_OW 200
// end ; wait ( 0 0$15 ) ;
13944: LD_INT 525
13946: PPUSH
13947: CALL_OW 67
// has_eng := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) diff Bierezov ;
13951: LD_ADDR_VAR 0 2
13955: PUSH
13956: LD_INT 22
13958: PUSH
13959: LD_INT 4
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PUSH
13966: LD_INT 25
13968: PUSH
13969: LD_INT 2
13971: PUSH
13972: EMPTY
13973: LIST
13974: LIST
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: PPUSH
13980: CALL_OW 69
13984: PUSH
13985: LD_EXP 44
13989: DIFF
13990: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13991: LD_INT 35
13993: PPUSH
13994: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13998: LD_ADDR_VAR 0 6
14002: PUSH
14003: LD_INT 10
14005: PPUSH
14006: CALL_OW 435
14010: ST_TO_ADDR
// if crates then
14011: LD_VAR 0 6
14015: IFFALSE 14044
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
14017: LD_VAR 0 2
14021: PPUSH
14022: LD_VAR 0 6
14026: PUSH
14027: LD_INT 1
14029: ARRAY
14030: PPUSH
14031: LD_VAR 0 6
14035: PUSH
14036: LD_INT 2
14038: ARRAY
14039: PPUSH
14040: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
14044: LD_VAR 0 4
14048: PPUSH
14049: CALL_OW 274
14053: PPUSH
14054: LD_INT 1
14056: PPUSH
14057: CALL_OW 275
14061: PUSH
14062: LD_INT 40
14064: GREATEREQUAL
14065: IFFALSE 13991
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] , [ b_breastwork , 254 , 114 , 2 ] ] ;
14067: LD_ADDR_VAR 0 5
14071: PUSH
14072: LD_INT 4
14074: PUSH
14075: LD_INT 256
14077: PUSH
14078: LD_INT 111
14080: PUSH
14081: LD_INT 2
14083: PUSH
14084: EMPTY
14085: LIST
14086: LIST
14087: LIST
14088: LIST
14089: PUSH
14090: LD_INT 31
14092: PUSH
14093: LD_INT 243
14095: PUSH
14096: LD_INT 112
14098: PUSH
14099: LD_INT 2
14101: PUSH
14102: EMPTY
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: PUSH
14108: LD_INT 31
14110: PUSH
14111: LD_INT 254
14113: PUSH
14114: LD_INT 114
14116: PUSH
14117: LD_INT 2
14119: PUSH
14120: EMPTY
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: PUSH
14126: EMPTY
14127: LIST
14128: LIST
14129: LIST
14130: ST_TO_ADDR
// for i in blist do
14131: LD_ADDR_VAR 0 1
14135: PUSH
14136: LD_VAR 0 5
14140: PUSH
14141: FOR_IN
14142: IFFALSE 14191
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
14144: LD_VAR 0 2
14148: PPUSH
14149: LD_VAR 0 1
14153: PUSH
14154: LD_INT 1
14156: ARRAY
14157: PPUSH
14158: LD_VAR 0 1
14162: PUSH
14163: LD_INT 2
14165: ARRAY
14166: PPUSH
14167: LD_VAR 0 1
14171: PUSH
14172: LD_INT 3
14174: ARRAY
14175: PPUSH
14176: LD_VAR 0 1
14180: PUSH
14181: LD_INT 4
14183: ARRAY
14184: PPUSH
14185: CALL_OW 205
14189: GO 14141
14191: POP
14192: POP
// repeat wait ( 0 0$01 ) ;
14193: LD_INT 35
14195: PPUSH
14196: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
14200: LD_INT 22
14202: PUSH
14203: LD_INT 4
14205: PUSH
14206: EMPTY
14207: LIST
14208: LIST
14209: PUSH
14210: LD_INT 30
14212: PUSH
14213: LD_INT 4
14215: PUSH
14216: EMPTY
14217: LIST
14218: LIST
14219: PUSH
14220: LD_INT 3
14222: PUSH
14223: LD_INT 57
14225: PUSH
14226: EMPTY
14227: LIST
14228: PUSH
14229: EMPTY
14230: LIST
14231: LIST
14232: PUSH
14233: EMPTY
14234: LIST
14235: LIST
14236: LIST
14237: PPUSH
14238: CALL_OW 69
14242: IFFALSE 14193
// AddComEnterUnit ( filter , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14244: LD_VAR 0 3
14248: PPUSH
14249: LD_INT 22
14251: PUSH
14252: LD_INT 4
14254: PUSH
14255: EMPTY
14256: LIST
14257: LIST
14258: PUSH
14259: LD_INT 30
14261: PUSH
14262: LD_INT 4
14264: PUSH
14265: EMPTY
14266: LIST
14267: LIST
14268: PUSH
14269: EMPTY
14270: LIST
14271: LIST
14272: PPUSH
14273: CALL_OW 69
14277: PUSH
14278: LD_INT 1
14280: ARRAY
14281: PPUSH
14282: CALL_OW 180
// AddComChangeProfession ( filter , 1 ) ;
14286: LD_VAR 0 3
14290: PPUSH
14291: LD_INT 1
14293: PPUSH
14294: CALL_OW 183
// if has_eng > 1 then
14298: LD_VAR 0 2
14302: PUSH
14303: LD_INT 1
14305: GREATER
14306: IFFALSE 14448
// for i = has_eng downto 2 do
14308: LD_ADDR_VAR 0 1
14312: PUSH
14313: DOUBLE
14314: LD_VAR 0 2
14318: INC
14319: ST_TO_ADDR
14320: LD_INT 2
14322: PUSH
14323: FOR_DOWNTO
14324: IFFALSE 14446
// begin if IsInUnit ( has_eng [ i ] ) then
14326: LD_VAR 0 2
14330: PUSH
14331: LD_VAR 0 1
14335: ARRAY
14336: PPUSH
14337: CALL_OW 310
14341: IFFALSE 14358
// ComExitBuilding ( has_eng [ i ] ) ;
14343: LD_VAR 0 2
14347: PUSH
14348: LD_VAR 0 1
14352: ARRAY
14353: PPUSH
14354: CALL_OW 122
// AddComEnterUnit ( has_eng [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14358: LD_VAR 0 2
14362: PUSH
14363: LD_VAR 0 1
14367: ARRAY
14368: PPUSH
14369: LD_INT 22
14371: PUSH
14372: LD_INT 4
14374: PUSH
14375: EMPTY
14376: LIST
14377: LIST
14378: PUSH
14379: LD_INT 30
14381: PUSH
14382: LD_INT 4
14384: PUSH
14385: EMPTY
14386: LIST
14387: LIST
14388: PUSH
14389: EMPTY
14390: LIST
14391: LIST
14392: PPUSH
14393: CALL_OW 69
14397: PUSH
14398: LD_INT 1
14400: ARRAY
14401: PPUSH
14402: CALL_OW 180
// AddComChangeProfession ( has_eng [ i ] , 1 ) ;
14406: LD_VAR 0 2
14410: PUSH
14411: LD_VAR 0 1
14415: ARRAY
14416: PPUSH
14417: LD_INT 1
14419: PPUSH
14420: CALL_OW 183
// has_eng := Delete ( has_eng , i ) ;
14424: LD_ADDR_VAR 0 2
14428: PUSH
14429: LD_VAR 0 2
14433: PPUSH
14434: LD_VAR 0 1
14438: PPUSH
14439: CALL_OW 3
14443: ST_TO_ADDR
// end ;
14444: GO 14323
14446: POP
14447: POP
// repeat wait ( 0 0$01 ) ;
14448: LD_INT 35
14450: PPUSH
14451: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) > 1 ;
14455: LD_INT 22
14457: PUSH
14458: LD_INT 4
14460: PUSH
14461: EMPTY
14462: LIST
14463: LIST
14464: PUSH
14465: LD_INT 30
14467: PUSH
14468: LD_INT 31
14470: PUSH
14471: EMPTY
14472: LIST
14473: LIST
14474: PUSH
14475: LD_INT 3
14477: PUSH
14478: LD_INT 57
14480: PUSH
14481: EMPTY
14482: LIST
14483: PUSH
14484: EMPTY
14485: LIST
14486: LIST
14487: PUSH
14488: EMPTY
14489: LIST
14490: LIST
14491: LIST
14492: PPUSH
14493: CALL_OW 69
14497: PUSH
14498: LD_INT 1
14500: GREATER
14501: IFFALSE 14448
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
14503: LD_ADDR_VAR 0 8
14507: PUSH
14508: LD_EXP 6
14512: PPUSH
14513: LD_INT 25
14515: PUSH
14516: LD_INT 1
14518: PUSH
14519: EMPTY
14520: LIST
14521: LIST
14522: PPUSH
14523: CALL_OW 72
14527: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) do
14528: LD_ADDR_VAR 0 1
14532: PUSH
14533: DOUBLE
14534: LD_INT 1
14536: DEC
14537: ST_TO_ADDR
14538: LD_INT 22
14540: PUSH
14541: LD_INT 4
14543: PUSH
14544: EMPTY
14545: LIST
14546: LIST
14547: PUSH
14548: LD_INT 30
14550: PUSH
14551: LD_INT 31
14553: PUSH
14554: EMPTY
14555: LIST
14556: LIST
14557: PUSH
14558: LD_INT 3
14560: PUSH
14561: LD_INT 57
14563: PUSH
14564: EMPTY
14565: LIST
14566: PUSH
14567: EMPTY
14568: LIST
14569: LIST
14570: PUSH
14571: EMPTY
14572: LIST
14573: LIST
14574: LIST
14575: PPUSH
14576: CALL_OW 69
14580: PUSH
14581: FOR_TO
14582: IFFALSE 14666
// begin if not sol [ i ] then
14584: LD_VAR 0 8
14588: PUSH
14589: LD_VAR 0 1
14593: ARRAY
14594: NOT
14595: IFFALSE 14599
// break ;
14597: GO 14666
// ComExitBuilding ( sol [ i ] ) ;
14599: LD_VAR 0 8
14603: PUSH
14604: LD_VAR 0 1
14608: ARRAY
14609: PPUSH
14610: CALL_OW 122
// AddComEnterUnit ( sol [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
14614: LD_VAR 0 8
14618: PUSH
14619: LD_VAR 0 1
14623: ARRAY
14624: PPUSH
14625: LD_INT 22
14627: PUSH
14628: LD_INT 4
14630: PUSH
14631: EMPTY
14632: LIST
14633: LIST
14634: PUSH
14635: LD_INT 30
14637: PUSH
14638: LD_INT 31
14640: PUSH
14641: EMPTY
14642: LIST
14643: LIST
14644: PUSH
14645: EMPTY
14646: LIST
14647: LIST
14648: PPUSH
14649: CALL_OW 69
14653: PUSH
14654: LD_VAR 0 1
14658: ARRAY
14659: PPUSH
14660: CALL_OW 180
// end ;
14664: GO 14581
14666: POP
14667: POP
// if sol > 3 then
14668: LD_VAR 0 8
14672: PUSH
14673: LD_INT 3
14675: GREATER
14676: IFFALSE 14793
// begin ComExitBuilding ( sol [ 3 ] ) ;
14678: LD_VAR 0 8
14682: PUSH
14683: LD_INT 3
14685: ARRAY
14686: PPUSH
14687: CALL_OW 122
// AddComMoveXY ( sol [ 3 ] , 246 , 94 ) ;
14691: LD_VAR 0 8
14695: PUSH
14696: LD_INT 3
14698: ARRAY
14699: PPUSH
14700: LD_INT 246
14702: PPUSH
14703: LD_INT 94
14705: PPUSH
14706: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$5 ) ;
14710: LD_VAR 0 8
14714: PUSH
14715: LD_INT 3
14717: ARRAY
14718: PPUSH
14719: LD_INT 175
14721: PPUSH
14722: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 224 , 90 ) ;
14726: LD_VAR 0 8
14730: PUSH
14731: LD_INT 3
14733: ARRAY
14734: PPUSH
14735: LD_INT 224
14737: PPUSH
14738: LD_INT 90
14740: PPUSH
14741: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$7 ) ;
14745: LD_VAR 0 8
14749: PUSH
14750: LD_INT 3
14752: ARRAY
14753: PPUSH
14754: LD_INT 245
14756: PPUSH
14757: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 223 , 110 ) ;
14761: LD_VAR 0 8
14765: PUSH
14766: LD_INT 3
14768: ARRAY
14769: PPUSH
14770: LD_INT 223
14772: PPUSH
14773: LD_INT 110
14775: PPUSH
14776: CALL_OW 171
// AddComHold ( sol [ 3 ] ) ;
14780: LD_VAR 0 8
14784: PUSH
14785: LD_INT 3
14787: ARRAY
14788: PPUSH
14789: CALL_OW 200
// end ; ComEnterUnit ( has_eng , dep ) ;
14793: LD_VAR 0 2
14797: PPUSH
14798: LD_VAR 0 4
14802: PPUSH
14803: CALL_OW 120
// if UnitsInside ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) < 6 then
14807: LD_INT 22
14809: PUSH
14810: LD_INT 4
14812: PUSH
14813: EMPTY
14814: LIST
14815: LIST
14816: PUSH
14817: LD_INT 30
14819: PUSH
14820: LD_INT 4
14822: PUSH
14823: EMPTY
14824: LIST
14825: LIST
14826: PUSH
14827: EMPTY
14828: LIST
14829: LIST
14830: PPUSH
14831: CALL_OW 69
14835: PUSH
14836: LD_INT 1
14838: ARRAY
14839: PPUSH
14840: CALL_OW 313
14844: PUSH
14845: LD_INT 6
14847: LESS
14848: IFFALSE 14912
// begin if IsInUnit ( Cornel ) then
14850: LD_EXP 43
14854: PPUSH
14855: CALL_OW 310
14859: IFFALSE 14870
// ComExitBuilding ( Cornel ) ;
14861: LD_EXP 43
14865: PPUSH
14866: CALL_OW 122
// AddComEnterUnit ( Cornel , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14870: LD_EXP 43
14874: PPUSH
14875: LD_INT 22
14877: PUSH
14878: LD_INT 4
14880: PUSH
14881: EMPTY
14882: LIST
14883: LIST
14884: PUSH
14885: LD_INT 30
14887: PUSH
14888: LD_INT 4
14890: PUSH
14891: EMPTY
14892: LIST
14893: LIST
14894: PUSH
14895: EMPTY
14896: LIST
14897: LIST
14898: PPUSH
14899: CALL_OW 69
14903: PUSH
14904: LD_INT 1
14906: ARRAY
14907: PPUSH
14908: CALL_OW 180
// end ; repeat wait ( 0 0$01 ) ;
14912: LD_INT 35
14914: PPUSH
14915: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14919: LD_ADDR_VAR 0 3
14923: PUSH
14924: LD_INT 22
14926: PUSH
14927: LD_INT 4
14929: PUSH
14930: EMPTY
14931: LIST
14932: LIST
14933: PUSH
14934: LD_INT 21
14936: PUSH
14937: LD_INT 3
14939: PUSH
14940: EMPTY
14941: LIST
14942: LIST
14943: PUSH
14944: LD_INT 3
14946: PUSH
14947: LD_INT 24
14949: PUSH
14950: LD_INT 1000
14952: PUSH
14953: EMPTY
14954: LIST
14955: LIST
14956: PUSH
14957: EMPTY
14958: LIST
14959: LIST
14960: PUSH
14961: EMPTY
14962: LIST
14963: LIST
14964: LIST
14965: PPUSH
14966: CALL_OW 69
14970: ST_TO_ADDR
// if filter and has_eng then
14971: LD_VAR 0 3
14975: PUSH
14976: LD_VAR 0 2
14980: AND
14981: IFFALSE 15047
// begin for i in has_eng do
14983: LD_ADDR_VAR 0 1
14987: PUSH
14988: LD_VAR 0 2
14992: PUSH
14993: FOR_IN
14994: IFFALSE 15043
// begin if IsInUnit ( i ) then
14996: LD_VAR 0 1
15000: PPUSH
15001: CALL_OW 310
15005: IFFALSE 15016
// ComExitBuilding ( i ) ;
15007: LD_VAR 0 1
15011: PPUSH
15012: CALL_OW 122
// Wait ( 3 ) ;
15016: LD_INT 3
15018: PPUSH
15019: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
15023: LD_VAR 0 1
15027: PPUSH
15028: LD_VAR 0 3
15032: PUSH
15033: LD_INT 1
15035: ARRAY
15036: PPUSH
15037: CALL_OW 130
// end ;
15041: GO 14993
15043: POP
15044: POP
// end else
15045: GO 15101
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
15047: LD_VAR 0 2
15051: PUSH
15052: LD_VAR 0 2
15056: PPUSH
15057: LD_INT 56
15059: PUSH
15060: EMPTY
15061: LIST
15062: PPUSH
15063: CALL_OW 72
15067: AND
15068: IFFALSE 15101
// for i in has_eng do
15070: LD_ADDR_VAR 0 1
15074: PUSH
15075: LD_VAR 0 2
15079: PUSH
15080: FOR_IN
15081: IFFALSE 15099
// ComEnterUnit ( i , dep ) ;
15083: LD_VAR 0 1
15087: PPUSH
15088: LD_VAR 0 4
15092: PPUSH
15093: CALL_OW 120
15097: GO 15080
15099: POP
15100: POP
// until cornel_prepared ;
15101: LD_EXP 11
15105: IFFALSE 14912
// end ;
15107: PPOPN 8
15109: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
15110: LD_EXP 11
15114: IFFALSE 15513
15116: GO 15118
15118: DISABLE
15119: LD_INT 0
15121: PPUSH
15122: PPUSH
15123: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
15124: LD_ADDR_VAR 0 2
15128: PUSH
15129: LD_INT 22
15131: PUSH
15132: LD_INT 4
15134: PUSH
15135: EMPTY
15136: LIST
15137: LIST
15138: PUSH
15139: LD_INT 30
15141: PUSH
15142: LD_INT 4
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: PUSH
15149: EMPTY
15150: LIST
15151: LIST
15152: PPUSH
15153: CALL_OW 69
15157: PUSH
15158: LD_INT 1
15160: ARRAY
15161: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
15162: LD_EXP 6
15166: PPUSH
15167: CALL_OW 122
// if Bierezov and IsInUnit ( Bierezov ) then
15171: LD_EXP 44
15175: PUSH
15176: LD_EXP 44
15180: PPUSH
15181: CALL_OW 310
15185: AND
15186: IFFALSE 15197
// ComExitBuilding ( Bierezov ) ;
15188: LD_EXP 44
15192: PPUSH
15193: CALL_OW 122
// Wait ( 0 0$03 ) ;
15197: LD_INT 105
15199: PPUSH
15200: CALL_OW 67
// for i in cornel_units do
15204: LD_ADDR_VAR 0 1
15208: PUSH
15209: LD_EXP 6
15213: PUSH
15214: FOR_IN
15215: IFFALSE 15291
// begin if GetClass ( i ) in [ 2 , 3 ] then
15217: LD_VAR 0 1
15221: PPUSH
15222: CALL_OW 257
15226: PUSH
15227: LD_INT 2
15229: PUSH
15230: LD_INT 3
15232: PUSH
15233: EMPTY
15234: LIST
15235: LIST
15236: IN
15237: IFFALSE 15274
// begin ComEnterUnit ( i , arm ) ;
15239: LD_VAR 0 1
15243: PPUSH
15244: LD_VAR 0 2
15248: PPUSH
15249: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
15253: LD_VAR 0 1
15257: PPUSH
15258: LD_INT 1
15260: PPUSH
15261: CALL_OW 183
// AddComExitBuilding ( i ) ;
15265: LD_VAR 0 1
15269: PPUSH
15270: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
15274: LD_VAR 0 1
15278: PPUSH
15279: LD_INT 257
15281: PPUSH
15282: LD_INT 121
15284: PPUSH
15285: CALL_OW 171
// end ;
15289: GO 15214
15291: POP
15292: POP
// Wait ( 1 1$00 ) ;
15293: LD_INT 2100
15295: PPUSH
15296: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
15300: LD_ADDR_VAR 0 3
15304: PUSH
15305: LD_EXP 43
15309: PUSH
15310: LD_EXP 44
15314: ADD
15315: PUSH
15316: LD_EXP 6
15320: ADD
15321: PUSH
15322: LD_EXP 6
15326: PPUSH
15327: LD_INT 21
15329: PUSH
15330: LD_INT 2
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PPUSH
15337: CALL_OW 72
15341: DIFF
15342: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
15343: LD_VAR 0 3
15347: PPUSH
15348: LD_INT 248
15350: PPUSH
15351: LD_INT 85
15353: PPUSH
15354: CALL_OW 111
// AddComHold ( filter ) ;
15358: LD_VAR 0 3
15362: PPUSH
15363: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
15367: LD_INT 35
15369: PPUSH
15370: CALL_OW 67
// until cornel_attack ;
15374: LD_EXP 9
15378: IFFALSE 15367
// ComAgressiveMove ( filter , 209 , 63 ) ;
15380: LD_VAR 0 3
15384: PPUSH
15385: LD_INT 209
15387: PPUSH
15388: LD_INT 63
15390: PPUSH
15391: CALL_OW 114
// ComAgressiveMove ( Cornel , 208 , 62 ) ;
15395: LD_EXP 43
15399: PPUSH
15400: LD_INT 208
15402: PPUSH
15403: LD_INT 62
15405: PPUSH
15406: CALL_OW 114
// AddComHold ( Cornel ) ;
15410: LD_EXP 43
15414: PPUSH
15415: CALL_OW 200
// if Bierezov then
15419: LD_EXP 44
15423: IFFALSE 15513
// begin filter := filter diff Bierezov ;
15425: LD_ADDR_VAR 0 3
15429: PUSH
15430: LD_VAR 0 3
15434: PUSH
15435: LD_EXP 44
15439: DIFF
15440: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
15441: LD_EXP 44
15445: PPUSH
15446: LD_INT 6
15448: PPUSH
15449: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
15453: LD_EXP 44
15457: PPUSH
15458: LD_INT 235
15460: PPUSH
15461: LD_INT 60
15463: PPUSH
15464: CALL_OW 111
// AddComHold ( Bierezov ) ;
15468: LD_EXP 44
15472: PPUSH
15473: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
15477: LD_EXP 44
15481: PPUSH
15482: LD_INT 350
15484: PPUSH
15485: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
15489: LD_EXP 44
15493: PPUSH
15494: LD_INT 198
15496: PPUSH
15497: LD_INT 28
15499: PPUSH
15500: CALL_OW 171
// AddComHold ( Bierezov ) ;
15504: LD_EXP 44
15508: PPUSH
15509: CALL_OW 200
// end ; end ; end_of_file
15513: PPOPN 3
15515: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
15516: LD_EXP 52
15520: PUSH
15521: LD_EXP 30
15525: NOT
15526: AND
15527: PUSH
15528: LD_EXP 31
15532: NOT
15533: AND
15534: IFFALSE 15984
15536: GO 15538
15538: DISABLE
15539: LD_INT 0
15541: PPUSH
15542: PPUSH
15543: PPUSH
15544: PPUSH
// begin enable ;
15545: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15546: LD_ADDR_VAR 0 4
15550: PUSH
15551: LD_INT 81
15553: PUSH
15554: LD_INT 3
15556: PUSH
15557: EMPTY
15558: LIST
15559: LIST
15560: PPUSH
15561: CALL_OW 69
15565: ST_TO_ADDR
// for i = 1 to ru_patrol do
15566: LD_ADDR_VAR 0 2
15570: PUSH
15571: DOUBLE
15572: LD_INT 1
15574: DEC
15575: ST_TO_ADDR
15576: LD_EXP 52
15580: PUSH
15581: FOR_TO
15582: IFFALSE 15982
// begin un := ru_patrol [ i ] ;
15584: LD_ADDR_VAR 0 1
15588: PUSH
15589: LD_EXP 52
15593: PUSH
15594: LD_VAR 0 2
15598: ARRAY
15599: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15600: LD_VAR 0 1
15604: PPUSH
15605: LD_INT 13
15607: PPUSH
15608: CALL_OW 308
15612: IFFALSE 15717
// begin if not ru_alert then
15614: LD_EXP 59
15618: NOT
15619: IFFALSE 15629
// ru_alert := true ;
15621: LD_ADDR_EXP 59
15625: PUSH
15626: LD_INT 1
15628: ST_TO_ADDR
// if not See ( 1 , un ) then
15629: LD_INT 1
15631: PPUSH
15632: LD_VAR 0 1
15636: PPUSH
15637: CALL_OW 292
15641: NOT
15642: IFFALSE 15656
// SetLives ( un , 1000 ) ;
15644: LD_VAR 0 1
15648: PPUSH
15649: LD_INT 1000
15651: PPUSH
15652: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
15656: LD_ADDR_EXP 52
15660: PUSH
15661: LD_EXP 52
15665: PUSH
15666: LD_VAR 0 1
15670: DIFF
15671: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15672: LD_VAR 0 1
15676: PPUSH
15677: LD_INT 22
15679: PUSH
15680: LD_INT 3
15682: PUSH
15683: EMPTY
15684: LIST
15685: LIST
15686: PUSH
15687: LD_INT 30
15689: PUSH
15690: LD_INT 4
15692: PUSH
15693: EMPTY
15694: LIST
15695: LIST
15696: PUSH
15697: EMPTY
15698: LIST
15699: LIST
15700: PPUSH
15701: CALL_OW 69
15705: PPUSH
15706: CALL 1047 0 1
15710: PPUSH
15711: CALL_OW 120
// continue ;
15715: GO 15581
// end ; if IsOk ( un ) and not HasTask ( un ) then
15717: LD_VAR 0 1
15721: PPUSH
15722: CALL_OW 302
15726: PUSH
15727: LD_VAR 0 1
15731: PPUSH
15732: CALL_OW 314
15736: NOT
15737: AND
15738: IFFALSE 15831
// begin for j = 1 to ru_firepoints_south [ i ] do
15740: LD_ADDR_VAR 0 3
15744: PUSH
15745: DOUBLE
15746: LD_INT 1
15748: DEC
15749: ST_TO_ADDR
15750: LD_EXP 58
15754: PUSH
15755: LD_VAR 0 2
15759: ARRAY
15760: PUSH
15761: FOR_TO
15762: IFFALSE 15829
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
15764: LD_VAR 0 1
15768: PPUSH
15769: LD_EXP 58
15773: PUSH
15774: LD_VAR 0 2
15778: ARRAY
15779: PUSH
15780: LD_VAR 0 3
15784: ARRAY
15785: PUSH
15786: LD_INT 1
15788: ARRAY
15789: PPUSH
15790: LD_EXP 58
15794: PUSH
15795: LD_VAR 0 2
15799: ARRAY
15800: PUSH
15801: LD_VAR 0 3
15805: ARRAY
15806: PUSH
15807: LD_INT 2
15809: ARRAY
15810: PPUSH
15811: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
15815: LD_VAR 0 1
15819: PPUSH
15820: LD_INT 70
15822: PPUSH
15823: CALL_OW 202
// end ;
15827: GO 15761
15829: POP
15830: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15831: LD_VAR 0 1
15835: PPUSH
15836: CALL_OW 256
15840: PUSH
15841: LD_INT 700
15843: LESS
15844: PUSH
15845: LD_VAR 0 1
15849: PPUSH
15850: LD_INT 13
15852: PPUSH
15853: CALL_OW 308
15857: NOT
15858: AND
15859: IFFALSE 15911
// begin ComMoveToArea ( un , retreatArea ) ;
15861: LD_VAR 0 1
15865: PPUSH
15866: LD_INT 13
15868: PPUSH
15869: CALL_OW 113
// if not ru_alert_xy then
15873: LD_EXP 60
15877: NOT
15878: IFFALSE 15909
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
15880: LD_ADDR_EXP 60
15884: PUSH
15885: LD_VAR 0 1
15889: PPUSH
15890: CALL_OW 250
15894: PUSH
15895: LD_VAR 0 1
15899: PPUSH
15900: CALL_OW 251
15904: PUSH
15905: EMPTY
15906: LIST
15907: LIST
15908: ST_TO_ADDR
// end else
15909: GO 15980
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15911: LD_VAR 0 1
15915: PPUSH
15916: LD_VAR 0 4
15920: PPUSH
15921: LD_VAR 0 1
15925: PPUSH
15926: CALL_OW 74
15930: PPUSH
15931: CALL_OW 296
15935: PUSH
15936: LD_INT 9
15938: LESS
15939: PUSH
15940: LD_VAR 0 1
15944: PPUSH
15945: CALL_OW 256
15949: PUSH
15950: LD_INT 500
15952: GREATER
15953: AND
15954: IFFALSE 15980
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15956: LD_VAR 0 1
15960: PPUSH
15961: LD_VAR 0 4
15965: PPUSH
15966: LD_VAR 0 1
15970: PPUSH
15971: CALL_OW 74
15975: PPUSH
15976: CALL_OW 115
// end ;
15980: GO 15581
15982: POP
15983: POP
// end ;
15984: PPOPN 4
15986: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
15987: LD_EXP 59
15991: PUSH
15992: LD_EXP 60
15996: AND
15997: PUSH
15998: LD_EXP 30
16002: NOT
16003: AND
16004: PUSH
16005: LD_EXP 31
16009: NOT
16010: AND
16011: IFFALSE 16221
16013: GO 16015
16015: DISABLE
16016: LD_INT 0
16018: PPUSH
16019: PPUSH
// begin enable ;
16020: ENABLE
// if not ru_vehicles then
16021: LD_EXP 55
16025: NOT
16026: IFFALSE 16030
// exit ;
16028: GO 16221
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16030: LD_ADDR_VAR 0 2
16034: PUSH
16035: LD_INT 81
16037: PUSH
16038: LD_INT 3
16040: PUSH
16041: EMPTY
16042: LIST
16043: LIST
16044: PPUSH
16045: CALL_OW 69
16049: ST_TO_ADDR
// if ru_vehicles then
16050: LD_EXP 55
16054: IFFALSE 16221
// begin for i in ru_vehicles do
16056: LD_ADDR_VAR 0 1
16060: PUSH
16061: LD_EXP 55
16065: PUSH
16066: FOR_IN
16067: IFFALSE 16219
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
16069: LD_VAR 0 1
16073: PPUSH
16074: CALL_OW 302
16078: PUSH
16079: LD_VAR 0 1
16083: PPUSH
16084: LD_VAR 0 2
16088: PPUSH
16089: LD_VAR 0 1
16093: PPUSH
16094: CALL_OW 74
16098: PPUSH
16099: CALL_OW 296
16103: PUSH
16104: LD_INT 9
16106: LESS
16107: AND
16108: IFFALSE 16134
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16110: LD_VAR 0 1
16114: PPUSH
16115: LD_VAR 0 2
16119: PPUSH
16120: LD_VAR 0 1
16124: PPUSH
16125: CALL_OW 74
16129: PPUSH
16130: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
16134: LD_VAR 0 1
16138: PPUSH
16139: CALL_OW 314
16143: NOT
16144: PUSH
16145: LD_VAR 0 1
16149: PPUSH
16150: CALL_OW 302
16154: AND
16155: PUSH
16156: LD_VAR 0 1
16160: PPUSH
16161: LD_EXP 60
16165: PUSH
16166: LD_INT 1
16168: ARRAY
16169: PPUSH
16170: LD_EXP 60
16174: PUSH
16175: LD_INT 2
16177: ARRAY
16178: PPUSH
16179: CALL_OW 297
16183: PUSH
16184: LD_INT 10
16186: GREATER
16187: AND
16188: IFFALSE 16217
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
16190: LD_VAR 0 1
16194: PPUSH
16195: LD_EXP 60
16199: PUSH
16200: LD_INT 1
16202: ARRAY
16203: PPUSH
16204: LD_EXP 60
16208: PUSH
16209: LD_INT 2
16211: ARRAY
16212: PPUSH
16213: CALL_OW 114
// end ;
16217: GO 16066
16219: POP
16220: POP
// end ; end ;
16221: PPOPN 2
16223: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
16224: LD_EXP 60
16228: PUSH
16229: LD_EXP 59
16233: AND
16234: PUSH
16235: LD_INT 3
16237: PPUSH
16238: CALL_OW 463
16242: NOT
16243: AND
16244: PUSH
16245: LD_EXP 30
16249: NOT
16250: AND
16251: PUSH
16252: LD_EXP 31
16256: NOT
16257: AND
16258: IFFALSE 16353
16260: GO 16262
16262: DISABLE
16263: LD_INT 0
16265: PPUSH
// begin enable ;
16266: ENABLE
// ru_alert_xy := false ;
16267: LD_ADDR_EXP 60
16271: PUSH
16272: LD_INT 0
16274: ST_TO_ADDR
// ru_alert := false ;
16275: LD_ADDR_EXP 59
16279: PUSH
16280: LD_INT 0
16282: ST_TO_ADDR
// if ru_vehicles then
16283: LD_EXP 55
16287: IFFALSE 16353
// for i in ru_vehicles do
16289: LD_ADDR_VAR 0 1
16293: PUSH
16294: LD_EXP 55
16298: PUSH
16299: FOR_IN
16300: IFFALSE 16351
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
16302: LD_VAR 0 1
16306: PPUSH
16307: CALL_OW 302
16311: PUSH
16312: LD_VAR 0 1
16316: PPUSH
16317: LD_INT 89
16319: PPUSH
16320: LD_INT 36
16322: PPUSH
16323: CALL_OW 297
16327: PUSH
16328: LD_INT 10
16330: GREATER
16331: AND
16332: IFFALSE 16349
// ComMoveXY ( i , 89 , 36 ) ;
16334: LD_VAR 0 1
16338: PPUSH
16339: LD_INT 89
16341: PPUSH
16342: LD_INT 36
16344: PPUSH
16345: CALL_OW 111
16349: GO 16299
16351: POP
16352: POP
// end ;
16353: PPOPN 1
16355: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
16356: LD_EXP 54
16360: PUSH
16361: LD_EXP 30
16365: NOT
16366: AND
16367: PUSH
16368: LD_EXP 31
16372: NOT
16373: AND
16374: IFFALSE 16658
16376: GO 16378
16378: DISABLE
16379: LD_INT 0
16381: PPUSH
16382: PPUSH
16383: PPUSH
// begin enable ;
16384: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16385: LD_ADDR_VAR 0 3
16389: PUSH
16390: LD_INT 81
16392: PUSH
16393: LD_INT 3
16395: PUSH
16396: EMPTY
16397: LIST
16398: LIST
16399: PPUSH
16400: CALL_OW 69
16404: ST_TO_ADDR
// for i = 1 to ru_forest do
16405: LD_ADDR_VAR 0 1
16409: PUSH
16410: DOUBLE
16411: LD_INT 1
16413: DEC
16414: ST_TO_ADDR
16415: LD_EXP 54
16419: PUSH
16420: FOR_TO
16421: IFFALSE 16656
// begin un := ru_forest [ i ] ;
16423: LD_ADDR_VAR 0 2
16427: PUSH
16428: LD_EXP 54
16432: PUSH
16433: LD_VAR 0 1
16437: ARRAY
16438: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
16439: LD_VAR 0 2
16443: PPUSH
16444: LD_INT 13
16446: PPUSH
16447: CALL_OW 308
16451: IFFALSE 16541
// begin if not See ( 1 , un ) then
16453: LD_INT 1
16455: PPUSH
16456: LD_VAR 0 2
16460: PPUSH
16461: CALL_OW 292
16465: NOT
16466: IFFALSE 16480
// SetLives ( un , 1000 ) ;
16468: LD_VAR 0 2
16472: PPUSH
16473: LD_INT 1000
16475: PPUSH
16476: CALL_OW 234
// ru_forest := ru_forest diff un ;
16480: LD_ADDR_EXP 54
16484: PUSH
16485: LD_EXP 54
16489: PUSH
16490: LD_VAR 0 2
16494: DIFF
16495: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
16496: LD_VAR 0 2
16500: PPUSH
16501: LD_INT 22
16503: PUSH
16504: LD_INT 3
16506: PUSH
16507: EMPTY
16508: LIST
16509: LIST
16510: PUSH
16511: LD_INT 30
16513: PUSH
16514: LD_INT 4
16516: PUSH
16517: EMPTY
16518: LIST
16519: LIST
16520: PUSH
16521: EMPTY
16522: LIST
16523: LIST
16524: PPUSH
16525: CALL_OW 69
16529: PPUSH
16530: CALL 1047 0 1
16534: PPUSH
16535: CALL_OW 120
// continue ;
16539: GO 16420
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
16541: LD_VAR 0 2
16545: PPUSH
16546: CALL_OW 256
16550: PUSH
16551: LD_INT 700
16553: LESS
16554: PUSH
16555: LD_VAR 0 2
16559: PPUSH
16560: LD_INT 13
16562: PPUSH
16563: CALL_OW 308
16567: NOT
16568: AND
16569: IFFALSE 16585
// ComMoveToArea ( un , retreatArea ) else
16571: LD_VAR 0 2
16575: PPUSH
16576: LD_INT 13
16578: PPUSH
16579: CALL_OW 113
16583: GO 16654
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
16585: LD_VAR 0 2
16589: PPUSH
16590: LD_VAR 0 3
16594: PPUSH
16595: LD_VAR 0 2
16599: PPUSH
16600: CALL_OW 74
16604: PPUSH
16605: CALL_OW 296
16609: PUSH
16610: LD_INT 9
16612: LESS
16613: PUSH
16614: LD_VAR 0 2
16618: PPUSH
16619: CALL_OW 256
16623: PUSH
16624: LD_INT 500
16626: GREATER
16627: AND
16628: IFFALSE 16654
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
16630: LD_VAR 0 2
16634: PPUSH
16635: LD_VAR 0 3
16639: PPUSH
16640: LD_VAR 0 2
16644: PPUSH
16645: CALL_OW 74
16649: PPUSH
16650: CALL_OW 115
// end ;
16654: GO 16420
16656: POP
16657: POP
// end ;
16658: PPOPN 3
16660: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
16661: LD_EXP 31
16665: NOT
16666: IFFALSE 16787
16668: GO 16670
16670: DISABLE
16671: LD_INT 0
16673: PPUSH
16674: PPUSH
// begin enable ;
16675: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
16676: LD_ADDR_VAR 0 2
16680: PUSH
16681: LD_INT 22
16683: PUSH
16684: LD_INT 3
16686: PUSH
16687: EMPTY
16688: LIST
16689: LIST
16690: PUSH
16691: LD_INT 21
16693: PUSH
16694: LD_INT 3
16696: PUSH
16697: EMPTY
16698: LIST
16699: LIST
16700: PUSH
16701: EMPTY
16702: LIST
16703: LIST
16704: PPUSH
16705: CALL_OW 69
16709: ST_TO_ADDR
// if filter then
16710: LD_VAR 0 2
16714: IFFALSE 16787
// for i in filter do
16716: LD_ADDR_VAR 0 1
16720: PUSH
16721: LD_VAR 0 2
16725: PUSH
16726: FOR_IN
16727: IFFALSE 16785
// if GetLives ( i ) < 990 then
16729: LD_VAR 0 1
16733: PPUSH
16734: CALL_OW 256
16738: PUSH
16739: LD_INT 990
16741: LESS
16742: IFFALSE 16783
// begin ru_alert := true ;
16744: LD_ADDR_EXP 59
16748: PUSH
16749: LD_INT 1
16751: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
16752: LD_ADDR_EXP 60
16756: PUSH
16757: LD_VAR 0 1
16761: PPUSH
16762: CALL_OW 250
16766: PUSH
16767: LD_VAR 0 1
16771: PPUSH
16772: CALL_OW 251
16776: PUSH
16777: EMPTY
16778: LIST
16779: LIST
16780: ST_TO_ADDR
// break ;
16781: GO 16785
// end ;
16783: GO 16726
16785: POP
16786: POP
// end ;
16787: PPOPN 2
16789: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
16790: LD_EXP 30
16794: IFFALSE 16943
16796: GO 16798
16798: DISABLE
16799: LD_INT 0
16801: PPUSH
16802: PPUSH
16803: PPUSH
16804: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
16805: LD_ADDR_VAR 0 4
16809: PUSH
16810: LD_EXP 55
16814: PUSH
16815: LD_EXP 54
16819: ADD
16820: PUSH
16821: LD_EXP 52
16825: ADD
16826: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
16827: LD_ADDR_VAR 0 3
16831: PUSH
16832: LD_INT 3
16834: PPUSH
16835: LD_INT 81
16837: PUSH
16838: LD_INT 3
16840: PUSH
16841: EMPTY
16842: LIST
16843: LIST
16844: PPUSH
16845: CALL_OW 70
16849: ST_TO_ADDR
// if filter and enemy then
16850: LD_VAR 0 4
16854: PUSH
16855: LD_VAR 0 3
16859: AND
16860: IFFALSE 16943
// repeat wait ( 0 0$01 ) ;
16862: LD_INT 35
16864: PPUSH
16865: CALL_OW 67
// for i in filter do
16869: LD_ADDR_VAR 0 1
16873: PUSH
16874: LD_VAR 0 4
16878: PUSH
16879: FOR_IN
16880: IFFALSE 16908
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16882: LD_VAR 0 1
16886: PPUSH
16887: LD_VAR 0 3
16891: PPUSH
16892: LD_VAR 0 1
16896: PPUSH
16897: CALL_OW 74
16901: PPUSH
16902: CALL_OW 115
// end ;
16906: GO 16879
16908: POP
16909: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
16910: LD_INT 3
16912: PPUSH
16913: LD_INT 81
16915: PUSH
16916: LD_INT 3
16918: PUSH
16919: EMPTY
16920: LIST
16921: LIST
16922: PPUSH
16923: CALL_OW 70
16927: PUSH
16928: LD_INT 0
16930: EQUAL
16931: PUSH
16932: LD_VAR 0 4
16936: PUSH
16937: LD_INT 0
16939: EQUAL
16940: OR
16941: IFFALSE 16862
// end ;
16943: PPOPN 4
16945: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) do var i ;
16946: LD_EXP 25
16950: PUSH
16951: LD_INT 22
16953: PUSH
16954: LD_INT 4
16956: PUSH
16957: EMPTY
16958: LIST
16959: LIST
16960: PUSH
16961: LD_INT 30
16963: PUSH
16964: LD_INT 4
16966: PUSH
16967: EMPTY
16968: LIST
16969: LIST
16970: PUSH
16971: LD_INT 3
16973: PUSH
16974: LD_INT 57
16976: PUSH
16977: EMPTY
16978: LIST
16979: PUSH
16980: EMPTY
16981: LIST
16982: LIST
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: LIST
16988: PPUSH
16989: CALL_OW 69
16993: AND
16994: IFFALSE 17043
16996: GO 16998
16998: DISABLE
16999: LD_INT 0
17001: PPUSH
// begin if not ru_cornel_attack then
17002: LD_EXP 57
17006: NOT
17007: IFFALSE 17011
// exit ;
17009: GO 17043
// for i in ru_cornel_attack do
17011: LD_ADDR_VAR 0 1
17015: PUSH
17016: LD_EXP 57
17020: PUSH
17021: FOR_IN
17022: IFFALSE 17041
// ComAgressiveMove ( i , 258 , 119 ) ;
17024: LD_VAR 0 1
17028: PPUSH
17029: LD_INT 258
17031: PPUSH
17032: LD_INT 119
17034: PPUSH
17035: CALL_OW 114
17039: GO 17021
17041: POP
17042: POP
// end ; end_of_file
17043: PPOPN 1
17045: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
17046: LD_EXP 5
17050: PUSH
17051: LD_EXP 9
17055: NOT
17056: AND
17057: PUSH
17058: LD_EXP 19
17062: AND
17063: IFFALSE 17175
17065: GO 17067
17067: DISABLE
17068: LD_INT 0
17070: PPUSH
// begin enable ;
17071: ENABLE
// crates_counter := crates_counter - 50 ;
17072: LD_ADDR_EXP 19
17076: PUSH
17077: LD_EXP 19
17081: PUSH
17082: LD_INT 50
17084: MINUS
17085: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
17086: LD_INT 8
17088: PPUSH
17089: LD_INT 2
17091: PPUSH
17092: LD_INT 5
17094: PPUSH
17095: CALL_OW 12
17099: PPUSH
17100: LD_INT 1
17102: PPUSH
17103: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
17107: LD_INT 1785
17109: PPUSH
17110: LD_INT 2345
17112: PPUSH
17113: CALL_OW 12
17117: PPUSH
17118: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
17122: LD_ADDR_VAR 0 1
17126: PUSH
17127: LD_INT 1
17129: PPUSH
17130: LD_OWVAR 67
17134: PUSH
17135: LD_INT 2
17137: PLUS
17138: PPUSH
17139: CALL_OW 12
17143: ST_TO_ADDR
// if r < 3 then
17144: LD_VAR 0 1
17148: PUSH
17149: LD_INT 3
17151: LESS
17152: IFFALSE 17175
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
17154: LD_INT 4
17156: PPUSH
17157: LD_INT 1
17159: PPUSH
17160: LD_INT 5
17162: PPUSH
17163: CALL_OW 12
17167: PPUSH
17168: LD_INT 1
17170: PPUSH
17171: CALL_OW 55
// end ;
17175: PPOPN 1
17177: END
// every 0 0$01 trigger cornel_active do
17178: LD_EXP 8
17182: IFFALSE 17271
17184: GO 17186
17186: DISABLE
// begin Wait ( 0 0$03 ) ;
17187: LD_INT 105
17189: PPUSH
17190: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17194: LD_INT 2
17196: PPUSH
17197: LD_INT 5
17199: PPUSH
17200: CALL_OW 12
17204: PPUSH
17205: LD_INT 10
17207: PPUSH
17208: LD_INT 1
17210: PPUSH
17211: CALL_OW 55
// Wait ( 0 0$13 ) ;
17215: LD_INT 455
17217: PPUSH
17218: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17222: LD_INT 2
17224: PPUSH
17225: LD_INT 5
17227: PPUSH
17228: CALL_OW 12
17232: PPUSH
17233: LD_INT 10
17235: PPUSH
17236: LD_INT 1
17238: PPUSH
17239: CALL_OW 55
// Wait ( 0 0$16 ) ;
17243: LD_INT 560
17245: PPUSH
17246: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17250: LD_INT 2
17252: PPUSH
17253: LD_INT 5
17255: PPUSH
17256: CALL_OW 12
17260: PPUSH
17261: LD_INT 10
17263: PPUSH
17264: LD_INT 1
17266: PPUSH
17267: CALL_OW 55
// end ; end_of_file
17271: END
// every 0 0$01 trigger cornel_prepared do
17272: LD_EXP 11
17276: IFFALSE 17335
17278: GO 17280
17280: DISABLE
// begin enable ;
17281: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
17282: LD_ADDR_OWVAR 47
17286: PUSH
17287: LD_STRING #Am03-1
17289: PUSH
17290: LD_EXP 10
17294: PUSH
17295: EMPTY
17296: LIST
17297: LIST
17298: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
17299: LD_ADDR_EXP 10
17303: PUSH
17304: LD_EXP 10
17308: PPUSH
17309: LD_STRING -
17311: PPUSH
17312: CALL 1117 0 2
17316: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
17317: LD_EXP 10
17321: PUSH
17322: LD_INT 0
17324: EQUAL
17325: IFFALSE 17335
// begin Display_Strings := [ ] ;
17327: LD_ADDR_OWVAR 47
17331: PUSH
17332: EMPTY
17333: ST_TO_ADDR
// disable ;
17334: DISABLE
// end ; end ;
17335: END
// every 0 0$01 trigger debug and debug_strings do
17336: LD_EXP 1
17340: PUSH
17341: LD_OWVAR 48
17345: AND
17346: IFFALSE 17362
17348: GO 17350
17350: DISABLE
// begin enable ;
17351: ENABLE
// Display_Strings := debug_strings ;
17352: LD_ADDR_OWVAR 47
17356: PUSH
17357: LD_OWVAR 48
17361: ST_TO_ADDR
// end ; end_of_file
17362: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
17363: LD_VAR 0 1
17367: PPUSH
17368: CALL_OW 255
17372: PUSH
17373: LD_INT 1
17375: EQUAL
17376: PUSH
17377: LD_EXP 13
17381: NOT
17382: AND
17383: IFFALSE 17393
// solar_builded := true ;
17385: LD_ADDR_EXP 13
17389: PUSH
17390: LD_INT 1
17392: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
17393: LD_VAR 0 1
17397: PPUSH
17398: CALL_OW 255
17402: PUSH
17403: LD_INT 1
17405: EQUAL
17406: PUSH
17407: LD_EXP 28
17411: AND
17412: IFFALSE 17445
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
17414: LD_ADDR_EXP 28
17418: PUSH
17419: LD_EXP 28
17423: PUSH
17424: LD_INT 1750
17426: PUSH
17427: LD_INT 1400
17429: PUSH
17430: LD_INT 1225
17432: PUSH
17433: EMPTY
17434: LIST
17435: LIST
17436: LIST
17437: PUSH
17438: LD_OWVAR 67
17442: ARRAY
17443: PLUS
17444: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
17445: LD_VAR 0 1
17449: PPUSH
17450: CALL_OW 255
17454: PUSH
17455: LD_INT 3
17457: EQUAL
17458: IFFALSE 17476
// ru_vehicles := ru_vehicles ^ veh ;
17460: LD_ADDR_EXP 55
17464: PUSH
17465: LD_EXP 55
17469: PUSH
17470: LD_VAR 0 1
17474: ADD
17475: ST_TO_ADDR
// end ;
17476: PPOPN 2
17478: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
17479: LD_VAR 0 1
17483: PUSH
17484: LD_EXP 52
17488: IN
17489: IFFALSE 17507
// ru_patrol := ru_patrol diff un ;
17491: LD_ADDR_EXP 52
17495: PUSH
17496: LD_EXP 52
17500: PUSH
17501: LD_VAR 0 1
17505: DIFF
17506: ST_TO_ADDR
// if un in ru_forest then
17507: LD_VAR 0 1
17511: PUSH
17512: LD_EXP 54
17516: IN
17517: IFFALSE 17535
// ru_forest := ru_forest diff un ;
17519: LD_ADDR_EXP 54
17523: PUSH
17524: LD_EXP 54
17528: PUSH
17529: LD_VAR 0 1
17533: DIFF
17534: ST_TO_ADDR
// if un in ru_vehicles then
17535: LD_VAR 0 1
17539: PUSH
17540: LD_EXP 55
17544: IN
17545: IFFALSE 17620
// begin ru_vehicles := ru_vehicles diff un ;
17547: LD_ADDR_EXP 55
17551: PUSH
17552: LD_EXP 55
17556: PUSH
17557: LD_VAR 0 1
17561: DIFF
17562: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
17563: LD_ADDR_EXP 56
17567: PUSH
17568: LD_EXP 56
17572: PUSH
17573: LD_VAR 0 1
17577: PPUSH
17578: CALL_OW 265
17582: PUSH
17583: LD_VAR 0 1
17587: PPUSH
17588: CALL_OW 262
17592: PUSH
17593: LD_VAR 0 1
17597: PPUSH
17598: CALL_OW 263
17602: PUSH
17603: LD_VAR 0 1
17607: PPUSH
17608: CALL_OW 264
17612: PUSH
17613: EMPTY
17614: LIST
17615: LIST
17616: LIST
17617: LIST
17618: ADD
17619: ST_TO_ADDR
// end ; if un = JMM then
17620: LD_VAR 0 1
17624: PUSH
17625: LD_EXP 36
17629: EQUAL
17630: IFFALSE 17639
// YouLost ( 0 ) ;
17632: LD_STRING 0
17634: PPUSH
17635: CALL_OW 104
// if un = us_dep_west then
17639: LD_VAR 0 1
17643: PUSH
17644: LD_INT 1
17646: EQUAL
17647: IFFALSE 17656
// YouLost ( 2 ) ;
17649: LD_STRING 2
17651: PPUSH
17652: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
17656: LD_VAR 0 1
17660: PPUSH
17661: CALL_OW 255
17665: PUSH
17666: LD_INT 8
17668: EQUAL
17669: PUSH
17670: LD_EXP 5
17674: NOT
17675: AND
17676: IFFALSE 17685
// YouLost ( 4 ) ;
17678: LD_STRING 4
17680: PPUSH
17681: CALL_OW 104
// if un in jmm_units then
17685: LD_VAR 0 1
17689: PUSH
17690: LD_EXP 4
17694: IN
17695: IFFALSE 17711
// lose_counter := lose_counter + 1 ;
17697: LD_ADDR_EXP 33
17701: PUSH
17702: LD_EXP 33
17706: PUSH
17707: LD_INT 1
17709: PLUS
17710: ST_TO_ADDR
// end ;
17711: PPOPN 1
17713: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
17714: LD_INT 0
17716: PPUSH
17717: PPUSH
// begin if GetSide ( driver ) = 3 then
17718: LD_VAR 0 1
17722: PPUSH
17723: CALL_OW 255
17727: PUSH
17728: LD_INT 3
17730: EQUAL
17731: IFFALSE 17809
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
17733: LD_ADDR_VAR 0 6
17737: PUSH
17738: LD_INT 22
17740: PUSH
17741: LD_INT 3
17743: PUSH
17744: EMPTY
17745: LIST
17746: LIST
17747: PUSH
17748: LD_INT 30
17750: PUSH
17751: LD_INT 3
17753: PUSH
17754: EMPTY
17755: LIST
17756: LIST
17757: PUSH
17758: EMPTY
17759: LIST
17760: LIST
17761: PPUSH
17762: CALL_OW 69
17766: PPUSH
17767: CALL 1047 0 1
17771: ST_TO_ADDR
// if place then
17772: LD_VAR 0 6
17776: IFFALSE 17794
// ComEnterUnit ( driver , place ) else
17778: LD_VAR 0 1
17782: PPUSH
17783: LD_VAR 0 6
17787: PPUSH
17788: CALL_OW 120
17792: GO 17809
// ComMoveXY ( driver , 70 , 22 ) ;
17794: LD_VAR 0 1
17798: PPUSH
17799: LD_INT 70
17801: PPUSH
17802: LD_INT 22
17804: PPUSH
17805: CALL_OW 111
// end ; end ;
17809: PPOPN 6
17811: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and ( s2 = 4 or ( s2 = 8 and not jmm_on_west ) ) then
17812: LD_VAR 0 1
17816: PUSH
17817: LD_INT 1
17819: EQUAL
17820: PUSH
17821: LD_VAR 0 2
17825: PUSH
17826: LD_INT 4
17828: EQUAL
17829: PUSH
17830: LD_VAR 0 2
17834: PUSH
17835: LD_INT 8
17837: EQUAL
17838: PUSH
17839: LD_EXP 5
17843: NOT
17844: AND
17845: OR
17846: AND
17847: IFFALSE 17856
// YouLost ( 5 ) ;
17849: LD_STRING 5
17851: PPUSH
17852: CALL_OW 104
// end ;
17856: PPOPN 2
17858: END
// every 0 0$01 trigger save_counter + ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
17859: LD_EXP 35
17863: PUSH
17864: LD_INT 22
17866: PUSH
17867: LD_INT 1
17869: PUSH
17870: EMPTY
17871: LIST
17872: LIST
17873: PUSH
17874: LD_INT 21
17876: PUSH
17877: LD_INT 1
17879: PUSH
17880: EMPTY
17881: LIST
17882: LIST
17883: PUSH
17884: EMPTY
17885: LIST
17886: LIST
17887: PPUSH
17888: CALL_OW 69
17892: PUSH
17893: LD_INT 22
17895: PUSH
17896: LD_INT 8
17898: PUSH
17899: EMPTY
17900: LIST
17901: LIST
17902: PUSH
17903: LD_INT 21
17905: PUSH
17906: LD_INT 1
17908: PUSH
17909: EMPTY
17910: LIST
17911: LIST
17912: PUSH
17913: EMPTY
17914: LIST
17915: LIST
17916: PPUSH
17917: CALL_OW 69
17921: ADD
17922: PLUS
17923: PUSH
17924: LD_INT 5
17926: LESS
17927: IFFALSE 17939
17929: GO 17931
17931: DISABLE
// YouLost ( 1 ) ;
17932: LD_STRING 1
17934: PPUSH
17935: CALL_OW 104
17939: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
17940: LD_INT 1
17942: PPUSH
17943: CALL_OW 255
17947: PUSH
17948: LD_INT 3
17950: EQUAL
17951: IFFALSE 17963
17953: GO 17955
17955: DISABLE
// YouLost ( 3 ) ;
17956: LD_STRING 3
17958: PPUSH
17959: CALL_OW 104
17963: END
