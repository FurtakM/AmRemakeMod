// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 307 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 395 0 0
// PrepareRussian ;
  22: CALL 2874 0 0
// PrepareAmerican ;
  26: CALL 1131 0 0
// PrepareCornell ;
  30: CALL 2155 0 0
// PrepareWesternBase ;
  34: CALL 2381 0 0
// Action ;
  38: CALL 3931 0 0
// end ;
  42: END
// export debug ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// jmm_units := 0 ;
  54: LD_ADDR_EXP 2
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// cornel_units := 0 ;
  62: LD_ADDR_EXP 4
  66: PUSH
  67: LD_INT 0
  69: ST_TO_ADDR
// bierezov_exist := false ;
  70: LD_ADDR_EXP 5
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// jmm_on_west := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// cornel_active := false ;
  86: LD_ADDR_EXP 6
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// cornel_attack := false ;
  94: LD_ADDR_EXP 7
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_prepared := false ;
 102: LD_ADDR_EXP 9
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 110: LD_ADDR_EXP 8
 114: PUSH
 115: LD_INT 4200
 117: ST_TO_ADDR
// frank_can_return := false ;
 118: LD_ADDR_EXP 10
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// solar_builded := false ;
 126: LD_ADDR_EXP 11
 130: PUSH
 131: LD_INT 0
 133: ST_TO_ADDR
// frank_send_to_scout := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// jmm_in_veh := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// bobby_in_veh := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// cyrus_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// lisa_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 174: LD_ADDR_EXP 24
 178: PUSH
 179: LD_INT 25200
 181: PUSH
 182: LD_INT 23100
 184: PUSH
 185: LD_INT 21000
 187: PUSH
 188: EMPTY
 189: LIST
 190: LIST
 191: LIST
 192: PUSH
 193: LD_OWVAR 67
 197: ARRAY
 198: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 199: LD_ADDR_EXP 17
 203: PUSH
 204: LD_INT 600
 206: PUSH
 207: LD_INT 500
 209: PUSH
 210: LD_INT 400
 212: PUSH
 213: EMPTY
 214: LIST
 215: LIST
 216: LIST
 217: PUSH
 218: LD_OWVAR 67
 222: ARRAY
 223: ST_TO_ADDR
// end_mission_allowed := false ;
 224: LD_ADDR_EXP 18
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// save_others := [ ] ;
 232: LD_ADDR_EXP 19
 236: PUSH
 237: EMPTY
 238: ST_TO_ADDR
// save_group := [ ] ;
 239: LD_ADDR_EXP 20
 243: PUSH
 244: EMPTY
 245: ST_TO_ADDR
// show_query := true ;
 246: LD_ADDR_EXP 21
 250: PUSH
 251: LD_INT 1
 253: ST_TO_ADDR
// wait_for_them := false ;
 254: LD_ADDR_EXP 22
 258: PUSH
 259: LD_INT 0
 261: ST_TO_ADDR
// veh_on_meta := false ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// send_spec_patrol := false ;
 270: LD_ADDR_EXP 25
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// prepare_siege := false ;
 278: LD_ADDR_EXP 26
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_attack_on_cornel := false ;
 286: LD_ADDR_EXP 27
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// game_end := false ;
 294: LD_ADDR_EXP 28
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// end ;
 302: LD_VAR 0 1
 306: RET
// function SetDiplomacy ; begin
 307: LD_INT 0
 309: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 310: LD_INT 1
 312: PPUSH
 313: LD_INT 4
 315: PPUSH
 316: LD_INT 1
 318: PPUSH
 319: LD_INT 1
 321: PPUSH
 322: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 326: LD_INT 1
 328: PPUSH
 329: LD_INT 8
 331: PPUSH
 332: LD_INT 1
 334: PPUSH
 335: LD_INT 1
 337: PPUSH
 338: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 342: LD_INT 3
 344: PPUSH
 345: LD_INT 6
 347: PPUSH
 348: LD_INT 1
 350: PPUSH
 351: LD_INT 1
 353: PPUSH
 354: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 358: LD_INT 4
 360: PPUSH
 361: LD_INT 6
 363: PPUSH
 364: LD_INT 0
 366: PPUSH
 367: LD_INT 1
 369: PPUSH
 370: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 374: LD_INT 3
 376: PPUSH
 377: LD_INT 8
 379: PPUSH
 380: LD_INT 0
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: CALL_OW 80
// end ;
 390: LD_VAR 0 1
 394: RET
// export function DebugMode ; begin
 395: LD_INT 0
 397: PPUSH
// FogOff ( 1 ) ;
 398: LD_INT 1
 400: PPUSH
 401: CALL_OW 344
// debug_strings := [ ] ;
 405: LD_ADDR_OWVAR 48
 409: PUSH
 410: EMPTY
 411: ST_TO_ADDR
// end ; end_of_file
 412: LD_VAR 0 1
 416: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 417: LD_INT 0
 419: PPUSH
 420: PPUSH
// if exist_mode then
 421: LD_VAR 0 2
 425: IFFALSE 453
// begin unit := CreateCharacter ( ident ) ;
 427: LD_ADDR_VAR 0 4
 431: PUSH
 432: LD_VAR 0 1
 436: PPUSH
 437: CALL_OW 34
 441: ST_TO_ADDR
// DeleteCharacters ( ident ) ;
 442: LD_VAR 0 1
 446: PPUSH
 447: CALL_OW 40
// end else
 451: GO 468
// unit := NewCharacter ( ident ) ;
 453: LD_ADDR_VAR 0 4
 457: PUSH
 458: LD_VAR 0 1
 462: PPUSH
 463: CALL_OW 25
 467: ST_TO_ADDR
// result := unit ;
 468: LD_ADDR_VAR 0 3
 472: PUSH
 473: LD_VAR 0 4
 477: ST_TO_ADDR
// end ;
 478: LD_VAR 0 3
 482: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 483: LD_INT 0
 485: PPUSH
// uc_side := side ;
 486: LD_ADDR_OWVAR 20
 490: PUSH
 491: LD_VAR 0 1
 495: ST_TO_ADDR
// uc_nation := nation ;
 496: LD_ADDR_OWVAR 21
 500: PUSH
 501: LD_VAR 0 2
 505: ST_TO_ADDR
// vc_chassis := chassis ;
 506: LD_ADDR_OWVAR 37
 510: PUSH
 511: LD_VAR 0 3
 515: ST_TO_ADDR
// vc_engine := engine ;
 516: LD_ADDR_OWVAR 39
 520: PUSH
 521: LD_VAR 0 4
 525: ST_TO_ADDR
// vc_control := control ;
 526: LD_ADDR_OWVAR 38
 530: PUSH
 531: LD_VAR 0 5
 535: ST_TO_ADDR
// vc_weapon := weapon ;
 536: LD_ADDR_OWVAR 40
 540: PUSH
 541: LD_VAR 0 6
 545: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 546: LD_ADDR_OWVAR 41
 550: PUSH
 551: LD_VAR 0 7
 555: ST_TO_ADDR
// result := CreateVehicle ;
 556: LD_ADDR_VAR 0 8
 560: PUSH
 561: CALL_OW 45
 565: ST_TO_ADDR
// end ;
 566: LD_VAR 0 8
 570: RET
// export function SayX ( units , ident ) ; var i ; begin
 571: LD_INT 0
 573: PPUSH
 574: PPUSH
// result := false ;
 575: LD_ADDR_VAR 0 3
 579: PUSH
 580: LD_INT 0
 582: ST_TO_ADDR
// if not units then
 583: LD_VAR 0 1
 587: NOT
 588: IFFALSE 592
// exit ;
 590: GO 646
// for i in units do
 592: LD_ADDR_VAR 0 4
 596: PUSH
 597: LD_VAR 0 1
 601: PUSH
 602: FOR_IN
 603: IFFALSE 644
// if IsOk ( i ) then
 605: LD_VAR 0 4
 609: PPUSH
 610: CALL_OW 302
 614: IFFALSE 642
// begin Say ( i , ident ) ;
 616: LD_VAR 0 4
 620: PPUSH
 621: LD_VAR 0 2
 625: PPUSH
 626: CALL_OW 88
// result := i ;
 630: LD_ADDR_VAR 0 3
 634: PUSH
 635: LD_VAR 0 4
 639: ST_TO_ADDR
// break ;
 640: GO 644
// end ;
 642: GO 602
 644: POP
 645: POP
// end ;
 646: LD_VAR 0 3
 650: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 651: LD_INT 0
 653: PPUSH
 654: PPUSH
 655: PPUSH
 656: PPUSH
// for i = 1 to count do
 657: LD_ADDR_VAR 0 8
 661: PUSH
 662: DOUBLE
 663: LD_INT 1
 665: DEC
 666: ST_TO_ADDR
 667: LD_VAR 0 6
 671: PUSH
 672: FOR_TO
 673: IFFALSE 754
// begin uc_side = side ;
 675: LD_ADDR_OWVAR 20
 679: PUSH
 680: LD_VAR 0 1
 684: ST_TO_ADDR
// uc_nation = nation ;
 685: LD_ADDR_OWVAR 21
 689: PUSH
 690: LD_VAR 0 2
 694: ST_TO_ADDR
// hc_gallery =  ;
 695: LD_ADDR_OWVAR 33
 699: PUSH
 700: LD_STRING 
 702: ST_TO_ADDR
// hc_name =  ;
 703: LD_ADDR_OWVAR 26
 707: PUSH
 708: LD_STRING 
 710: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 711: LD_INT 0
 713: PPUSH
 714: LD_VAR 0 5
 718: PPUSH
 719: LD_VAR 0 4
 723: PPUSH
 724: CALL_OW 380
// un = CreateHuman ;
 728: LD_ADDR_VAR 0 10
 732: PUSH
 733: CALL_OW 44
 737: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 738: LD_VAR 0 10
 742: PPUSH
 743: LD_VAR 0 3
 747: PPUSH
 748: CALL_OW 52
// end ;
 752: GO 672
 754: POP
 755: POP
// end ;
 756: LD_VAR 0 7
 760: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 761: LD_INT 0
 763: PPUSH
 764: PPUSH
 765: PPUSH
// uc_side := GetSide ( b ) ;
 766: LD_ADDR_OWVAR 20
 770: PUSH
 771: LD_VAR 0 2
 775: PPUSH
 776: CALL_OW 255
 780: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 781: LD_ADDR_OWVAR 21
 785: PUSH
 786: LD_VAR 0 2
 790: PPUSH
 791: CALL_OW 248
 795: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 796: LD_INT 0
 798: PPUSH
 799: LD_INT 1
 801: PPUSH
 802: LD_VAR 0 1
 806: PPUSH
 807: CALL_OW 380
// un = CreateHuman ;
 811: LD_ADDR_VAR 0 4
 815: PUSH
 816: CALL_OW 44
 820: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 821: LD_ADDR_VAR 0 5
 825: PUSH
 826: LD_VAR 0 2
 830: PPUSH
 831: CALL_OW 254
 835: PUSH
 836: LD_INT 3
 838: MINUS
 839: ST_TO_ADDR
// if dir < 0 then
 840: LD_VAR 0 5
 844: PUSH
 845: LD_INT 0
 847: LESS
 848: IFFALSE 864
// dir := 6 + dir ;
 850: LD_ADDR_VAR 0 5
 854: PUSH
 855: LD_INT 6
 857: PUSH
 858: LD_VAR 0 5
 862: PLUS
 863: ST_TO_ADDR
// SetDir ( un , dir ) ;
 864: LD_VAR 0 4
 868: PPUSH
 869: LD_VAR 0 5
 873: PPUSH
 874: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 878: LD_VAR 0 4
 882: PPUSH
 883: LD_VAR 0 2
 887: PPUSH
 888: CALL_OW 52
// end ;
 892: LD_VAR 0 3
 896: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 897: LD_INT 0
 899: PPUSH
 900: PPUSH
 901: PPUSH
// result := false ;
 902: LD_ADDR_VAR 0 2
 906: PUSH
 907: LD_INT 0
 909: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 910: LD_ADDR_VAR 0 3
 914: PUSH
 915: LD_INT 22
 917: PUSH
 918: LD_INT 1
 920: PUSH
 921: EMPTY
 922: LIST
 923: LIST
 924: PUSH
 925: LD_INT 34
 927: PUSH
 928: LD_INT 2
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: PPUSH
 939: CALL_OW 69
 943: ST_TO_ADDR
// for i in filter do
 944: LD_ADDR_VAR 0 4
 948: PUSH
 949: LD_VAR 0 3
 953: PUSH
 954: FOR_IN
 955: IFFALSE 986
// if IsDrivenBy ( i ) = unit then
 957: LD_VAR 0 4
 961: PPUSH
 962: CALL_OW 311
 966: PUSH
 967: LD_VAR 0 1
 971: EQUAL
 972: IFFALSE 984
// begin result := true ;
 974: LD_ADDR_VAR 0 2
 978: PUSH
 979: LD_INT 1
 981: ST_TO_ADDR
// break ;
 982: GO 986
// end ;
 984: GO 954
 986: POP
 987: POP
// end ;
 988: LD_VAR 0 2
 992: RET
// export function FindFreePlace ( blist ) ; var i ; begin
 993: LD_INT 0
 995: PPUSH
 996: PPUSH
// result := false ;
 997: LD_ADDR_VAR 0 2
1001: PUSH
1002: LD_INT 0
1004: ST_TO_ADDR
// if not blist then
1005: LD_VAR 0 1
1009: NOT
1010: IFFALSE 1014
// exit ;
1012: GO 1058
// for i in blist do
1014: LD_ADDR_VAR 0 3
1018: PUSH
1019: LD_VAR 0 1
1023: PUSH
1024: FOR_IN
1025: IFFALSE 1056
// if UnitsInside ( i ) < 6 then
1027: LD_VAR 0 3
1031: PPUSH
1032: CALL_OW 313
1036: PUSH
1037: LD_INT 6
1039: LESS
1040: IFFALSE 1054
// begin result := i ;
1042: LD_ADDR_VAR 0 2
1046: PUSH
1047: LD_VAR 0 3
1051: ST_TO_ADDR
// break ;
1052: GO 1056
// end ;
1054: GO 1024
1056: POP
1057: POP
// end ;
1058: LD_VAR 0 2
1062: RET
// export function Count ( timer , mode ) ; begin
1063: LD_INT 0
1065: PPUSH
// if not timer then
1066: LD_VAR 0 1
1070: NOT
1071: IFFALSE 1075
// exit ;
1073: GO 1126
// if mode in [ asc , up , + ] then
1075: LD_VAR 0 2
1079: PUSH
1080: LD_STRING asc
1082: PUSH
1083: LD_STRING up
1085: PUSH
1086: LD_STRING +
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: IN
1094: IFFALSE 1112
// result := timer + 0 0$01 else
1096: LD_ADDR_VAR 0 3
1100: PUSH
1101: LD_VAR 0 1
1105: PUSH
1106: LD_INT 35
1108: PLUS
1109: ST_TO_ADDR
1110: GO 1126
// result := timer - 0 0$01 ;
1112: LD_ADDR_VAR 0 3
1116: PUSH
1117: LD_VAR 0 1
1121: PUSH
1122: LD_INT 35
1124: MINUS
1125: ST_TO_ADDR
// end ; end_of_file
1126: LD_VAR 0 3
1130: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1131: LD_INT 0
1133: PPUSH
1134: PPUSH
1135: PPUSH
1136: PPUSH
1137: PPUSH
1138: PPUSH
1139: PPUSH
1140: PPUSH
// uc_side := 4 ;
1141: LD_ADDR_OWVAR 20
1145: PUSH
1146: LD_INT 4
1148: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1149: LD_ADDR_EXP 38
1153: PUSH
1154: LD_STRING Powell
1156: PPUSH
1157: LD_INT 0
1159: PPUSH
1160: CALL 417 0 2
1164: ST_TO_ADDR
// uc_side := 1 ;
1165: LD_ADDR_OWVAR 20
1169: PUSH
1170: LD_INT 1
1172: ST_TO_ADDR
// uc_nation := 1 ;
1173: LD_ADDR_OWVAR 21
1177: PUSH
1178: LD_INT 1
1180: ST_TO_ADDR
// if debug then
1181: LD_EXP 1
1185: IFFALSE 1315
// begin for i = 1 to 4 do
1187: LD_ADDR_VAR 0 2
1191: PUSH
1192: DOUBLE
1193: LD_INT 1
1195: DEC
1196: ST_TO_ADDR
1197: LD_INT 4
1199: PUSH
1200: FOR_TO
1201: IFFALSE 1252
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1203: LD_INT 0
1205: PPUSH
1206: LD_INT 1
1208: PPUSH
1209: LD_INT 2
1211: PPUSH
1212: CALL_OW 12
1216: PPUSH
1217: LD_INT 3
1219: PPUSH
1220: CALL_OW 380
// un := CreateHuman ;
1224: LD_ADDR_VAR 0 3
1228: PUSH
1229: CALL_OW 44
1233: ST_TO_ADDR
// others := others ^ un ;
1234: LD_ADDR_VAR 0 5
1238: PUSH
1239: LD_VAR 0 5
1243: PUSH
1244: LD_VAR 0 3
1248: ADD
1249: ST_TO_ADDR
// end ;
1250: GO 1200
1252: POP
1253: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1254: LD_ADDR_VAR 0 6
1258: PUSH
1259: LD_INT 21
1261: PUSH
1262: LD_INT 1
1264: PUSH
1265: LD_INT 1
1267: PUSH
1268: LD_INT 51
1270: PUSH
1271: LD_INT 90
1273: PUSH
1274: LD_INT 504
1276: PUSH
1277: EMPTY
1278: LIST
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: PUSH
1285: LD_INT 21
1287: PUSH
1288: LD_INT 1
1290: PUSH
1291: LD_INT 1
1293: PUSH
1294: LD_INT 51
1296: PUSH
1297: LD_INT 80
1299: PUSH
1300: LD_INT 750
1302: PUSH
1303: EMPTY
1304: LIST
1305: LIST
1306: LIST
1307: LIST
1308: LIST
1309: LIST
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1315: LD_ADDR_EXP 29
1319: PUSH
1320: LD_STRING JMM
1322: PPUSH
1323: LD_EXP 1
1327: NOT
1328: PPUSH
1329: CALL 417 0 2
1333: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1334: LD_ADDR_EXP 30
1338: PUSH
1339: LD_STRING Bobby
1341: PPUSH
1342: LD_EXP 1
1346: NOT
1347: PPUSH
1348: CALL 417 0 2
1352: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1353: LD_ADDR_EXP 31
1357: PUSH
1358: LD_STRING Cyrus
1360: PPUSH
1361: LD_EXP 1
1365: NOT
1366: PPUSH
1367: CALL 417 0 2
1371: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1372: LD_ADDR_EXP 32
1376: PUSH
1377: LD_STRING Lisa
1379: PPUSH
1380: LD_EXP 1
1384: NOT
1385: PPUSH
1386: CALL 417 0 2
1390: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1391: LD_ADDR_EXP 33
1395: PUSH
1396: LD_STRING Khatam
1398: PPUSH
1399: LD_EXP 1
1403: NOT
1404: PPUSH
1405: CALL 417 0 2
1409: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1410: LD_ADDR_EXP 34
1414: PUSH
1415: LD_STRING Brian
1417: PPUSH
1418: LD_EXP 1
1422: NOT
1423: PPUSH
1424: CALL 417 0 2
1428: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1429: LD_ADDR_EXP 35
1433: PUSH
1434: LD_STRING Jerry
1436: PPUSH
1437: LD_EXP 1
1441: NOT
1442: PPUSH
1443: CALL 417 0 2
1447: ST_TO_ADDR
// if Bobby then
1448: LD_EXP 30
1452: IFFALSE 1483
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1454: LD_ADDR_VAR 0 4
1458: PUSH
1459: LD_VAR 0 4
1463: PPUSH
1464: LD_VAR 0 4
1468: PUSH
1469: LD_INT 1
1471: PLUS
1472: PPUSH
1473: LD_EXP 30
1477: PPUSH
1478: CALL_OW 2
1482: ST_TO_ADDR
// if Cyrus then
1483: LD_EXP 31
1487: IFFALSE 1518
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1489: LD_ADDR_VAR 0 4
1493: PUSH
1494: LD_VAR 0 4
1498: PPUSH
1499: LD_VAR 0 4
1503: PUSH
1504: LD_INT 1
1506: PLUS
1507: PPUSH
1508: LD_EXP 31
1512: PPUSH
1513: CALL_OW 2
1517: ST_TO_ADDR
// if Lisa then
1518: LD_EXP 32
1522: IFFALSE 1553
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1524: LD_ADDR_VAR 0 4
1528: PUSH
1529: LD_VAR 0 4
1533: PPUSH
1534: LD_VAR 0 4
1538: PUSH
1539: LD_INT 1
1541: PLUS
1542: PPUSH
1543: LD_EXP 32
1547: PPUSH
1548: CALL_OW 2
1552: ST_TO_ADDR
// if Khatam then
1553: LD_EXP 33
1557: IFFALSE 1588
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1559: LD_ADDR_VAR 0 4
1563: PUSH
1564: LD_VAR 0 4
1568: PPUSH
1569: LD_VAR 0 4
1573: PUSH
1574: LD_INT 1
1576: PLUS
1577: PPUSH
1578: LD_EXP 33
1582: PPUSH
1583: CALL_OW 2
1587: ST_TO_ADDR
// if Brian then
1588: LD_EXP 34
1592: IFFALSE 1623
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1594: LD_ADDR_VAR 0 4
1598: PUSH
1599: LD_VAR 0 4
1603: PPUSH
1604: LD_VAR 0 4
1608: PUSH
1609: LD_INT 1
1611: PLUS
1612: PPUSH
1613: LD_EXP 34
1617: PPUSH
1618: CALL_OW 2
1622: ST_TO_ADDR
// if Jerry then
1623: LD_EXP 35
1627: IFFALSE 1658
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1629: LD_ADDR_VAR 0 4
1633: PUSH
1634: LD_VAR 0 4
1638: PPUSH
1639: LD_VAR 0 4
1643: PUSH
1644: LD_INT 1
1646: PLUS
1647: PPUSH
1648: LD_EXP 35
1652: PPUSH
1653: CALL_OW 2
1657: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1658: LD_STRING 02_other_survivors
1660: PPUSH
1661: CALL_OW 28
1665: IFFALSE 1680
// others := CreateCharacterSet ( 02_other_survivors ) ;
1667: LD_ADDR_VAR 0 5
1671: PUSH
1672: LD_STRING 02_other_survivors
1674: PPUSH
1675: CALL_OW 31
1679: ST_TO_ADDR
// if others then
1680: LD_VAR 0 5
1684: IFFALSE 1709
// begin tmp := tmp ^ others ;
1686: LD_ADDR_VAR 0 4
1690: PUSH
1691: LD_VAR 0 4
1695: PUSH
1696: LD_VAR 0 5
1700: ADD
1701: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1702: LD_STRING 02_other_survivors
1704: PPUSH
1705: CALL_OW 40
// end ; jmm_units := tmp ;
1709: LD_ADDR_EXP 2
1713: PUSH
1714: LD_VAR 0 4
1718: ST_TO_ADDR
// if not vehicles then
1719: LD_VAR 0 6
1723: NOT
1724: IFFALSE 1742
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1726: LD_ADDR_VAR 0 6
1730: PUSH
1731: LD_STRING 02_tanks_1
1733: PPUSH
1734: LD_INT 0
1736: PPUSH
1737: CALL_OW 30
1741: ST_TO_ADDR
// if vehicles then
1742: LD_VAR 0 6
1746: IFFALSE 1940
// begin got_mech := false ;
1748: LD_ADDR_VAR 0 7
1752: PUSH
1753: LD_INT 0
1755: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1756: LD_VAR 0 4
1760: PPUSH
1761: LD_INT 25
1763: PUSH
1764: LD_INT 3
1766: PUSH
1767: EMPTY
1768: LIST
1769: LIST
1770: PPUSH
1771: CALL_OW 72
1775: IFFALSE 1785
// got_mech := true ;
1777: LD_ADDR_VAR 0 7
1781: PUSH
1782: LD_INT 1
1784: ST_TO_ADDR
// for i = 1 to vehicles do
1785: LD_ADDR_VAR 0 2
1789: PUSH
1790: DOUBLE
1791: LD_INT 1
1793: DEC
1794: ST_TO_ADDR
1795: LD_VAR 0 6
1799: PUSH
1800: FOR_TO
1801: IFFALSE 1938
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1803: LD_ADDR_VAR 0 3
1807: PUSH
1808: LD_INT 1
1810: PPUSH
1811: LD_INT 3
1813: PPUSH
1814: LD_VAR 0 6
1818: PUSH
1819: LD_VAR 0 2
1823: ARRAY
1824: PUSH
1825: LD_INT 1
1827: ARRAY
1828: PPUSH
1829: LD_VAR 0 6
1833: PUSH
1834: LD_VAR 0 2
1838: ARRAY
1839: PUSH
1840: LD_INT 2
1842: ARRAY
1843: PPUSH
1844: LD_VAR 0 6
1848: PUSH
1849: LD_VAR 0 2
1853: ARRAY
1854: PUSH
1855: LD_INT 3
1857: ARRAY
1858: PPUSH
1859: LD_VAR 0 6
1863: PUSH
1864: LD_VAR 0 2
1868: ARRAY
1869: PUSH
1870: LD_INT 4
1872: ARRAY
1873: PPUSH
1874: LD_INT 40
1876: PPUSH
1877: CALL 483 0 7
1881: ST_TO_ADDR
// if not got_mech then
1882: LD_VAR 0 7
1886: NOT
1887: IFFALSE 1913
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1889: LD_VAR 0 3
1893: PPUSH
1894: LD_VAR 0 6
1898: PUSH
1899: LD_VAR 0 2
1903: ARRAY
1904: PUSH
1905: LD_INT 6
1907: ARRAY
1908: PPUSH
1909: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1913: LD_ADDR_VAR 0 4
1917: PUSH
1918: LD_VAR 0 4
1922: PPUSH
1923: LD_INT 1
1925: PPUSH
1926: LD_VAR 0 3
1930: PPUSH
1931: CALL_OW 2
1935: ST_TO_ADDR
// end ;
1936: GO 1800
1938: POP
1939: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1940: LD_EXP 29
1944: PPUSH
1945: LD_INT 194
1947: PPUSH
1948: LD_INT 119
1950: PPUSH
1951: LD_INT 0
1953: PPUSH
1954: CALL_OW 48
// if tmp then
1958: LD_VAR 0 4
1962: IFFALSE 2087
// begin for i in tmp do
1964: LD_ADDR_VAR 0 2
1968: PUSH
1969: LD_VAR 0 4
1973: PUSH
1974: FOR_IN
1975: IFFALSE 2085
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1977: LD_ADDR_VAR 0 8
1981: PUSH
1982: LD_INT 22
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: EMPTY
1989: LIST
1990: LIST
1991: PUSH
1992: LD_INT 21
1994: PUSH
1995: LD_INT 2
1997: PUSH
1998: EMPTY
1999: LIST
2000: LIST
2001: PUSH
2002: LD_INT 58
2004: PUSH
2005: EMPTY
2006: LIST
2007: PUSH
2008: EMPTY
2009: LIST
2010: LIST
2011: LIST
2012: PPUSH
2013: CALL_OW 69
2017: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2018: LD_VAR 0 2
2022: PPUSH
2023: CALL_OW 247
2027: PUSH
2028: LD_INT 1
2030: EQUAL
2031: PUSH
2032: LD_VAR 0 8
2036: AND
2037: IFFALSE 2059
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2039: LD_VAR 0 2
2043: PPUSH
2044: LD_VAR 0 8
2048: PUSH
2049: LD_INT 1
2051: ARRAY
2052: PPUSH
2053: CALL_OW 52
2057: GO 2074
// PlaceUnitArea ( i , startArea , false ) ;
2059: LD_VAR 0 2
2063: PPUSH
2064: LD_INT 1
2066: PPUSH
2067: LD_INT 0
2069: PPUSH
2070: CALL_OW 49
// ComHold ( i ) ;
2074: LD_VAR 0 2
2078: PPUSH
2079: CALL_OW 140
// end ;
2083: GO 1974
2085: POP
2086: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2087: LD_ADDR_EXP 5
2091: PUSH
2092: LD_STRING 02_mikhailStatus_1
2094: PPUSH
2095: LD_INT 0
2097: PPUSH
2098: CALL_OW 30
2102: ST_TO_ADDR
// if not bierezov_exist and not debug then
2103: LD_EXP 5
2107: NOT
2108: PUSH
2109: LD_EXP 1
2113: NOT
2114: AND
2115: IFFALSE 2119
// exit ;
2117: GO 2150
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2119: LD_ADDR_EXP 37
2123: PUSH
2124: LD_STRING Mikhail
2126: PPUSH
2127: LD_INT 0
2129: PPUSH
2130: CALL 417 0 2
2134: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2135: LD_EXP 37
2139: PPUSH
2140: LD_INT 1
2142: PPUSH
2143: LD_INT 0
2145: PPUSH
2146: CALL_OW 49
// end ;
2150: LD_VAR 0 1
2154: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2155: LD_INT 0
2157: PPUSH
2158: PPUSH
2159: PPUSH
2160: PPUSH
// uc_side := 4 ;
2161: LD_ADDR_OWVAR 20
2165: PUSH
2166: LD_INT 4
2168: ST_TO_ADDR
// uc_nation := 1 ;
2169: LD_ADDR_OWVAR 21
2173: PUSH
2174: LD_INT 1
2176: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2177: LD_ADDR_EXP 36
2181: PUSH
2182: LD_STRING Cornell
2184: PPUSH
2185: LD_INT 0
2187: PPUSH
2188: CALL 417 0 2
2192: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
2193: LD_ADDR_EXP 4
2197: PUSH
2198: LD_INT 8
2200: PUSH
2201: LD_EXP 2
2205: MINUS
2206: ST_TO_ADDR
// tmp := [ ] ;
2207: LD_ADDR_VAR 0 2
2211: PUSH
2212: EMPTY
2213: ST_TO_ADDR
// if cornel_units < 3 then
2214: LD_EXP 4
2218: PUSH
2219: LD_INT 3
2221: LESS
2222: IFFALSE 2232
// cornel_units := 3 ;
2224: LD_ADDR_EXP 4
2228: PUSH
2229: LD_INT 3
2231: ST_TO_ADDR
// for i = 1 to cornel_units do
2232: LD_ADDR_VAR 0 4
2236: PUSH
2237: DOUBLE
2238: LD_INT 1
2240: DEC
2241: ST_TO_ADDR
2242: LD_EXP 4
2246: PUSH
2247: FOR_TO
2248: IFFALSE 2346
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2250: LD_INT 0
2252: PPUSH
2253: LD_INT 1
2255: PUSH
2256: LD_INT 1
2258: PUSH
2259: LD_INT 1
2261: PUSH
2262: LD_INT 2
2264: PUSH
2265: LD_INT 4
2267: PUSH
2268: EMPTY
2269: LIST
2270: LIST
2271: LIST
2272: LIST
2273: LIST
2274: PUSH
2275: LD_VAR 0 4
2279: PUSH
2280: LD_INT 5
2282: MOD
2283: PUSH
2284: LD_INT 1
2286: PLUS
2287: ARRAY
2288: PPUSH
2289: LD_INT 2
2291: PPUSH
2292: CALL_OW 380
// un := CreateHuman ;
2296: LD_ADDR_VAR 0 3
2300: PUSH
2301: CALL_OW 44
2305: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2306: LD_ADDR_VAR 0 2
2310: PUSH
2311: LD_VAR 0 2
2315: PPUSH
2316: LD_INT 1
2318: PPUSH
2319: LD_VAR 0 3
2323: PPUSH
2324: CALL_OW 2
2328: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2329: LD_VAR 0 3
2333: PPUSH
2334: LD_INT 2
2336: PPUSH
2337: LD_INT 0
2339: PPUSH
2340: CALL_OW 49
// end ;
2344: GO 2247
2346: POP
2347: POP
// cornel_units := tmp ;
2348: LD_ADDR_EXP 4
2352: PUSH
2353: LD_VAR 0 2
2357: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2358: LD_EXP 36
2362: PPUSH
2363: LD_INT 191
2365: PPUSH
2366: LD_INT 106
2368: PPUSH
2369: LD_INT 0
2371: PPUSH
2372: CALL_OW 48
// end ;
2376: LD_VAR 0 1
2380: RET
// export function PrepareWesternBase ; var i ; begin
2381: LD_INT 0
2383: PPUSH
2384: PPUSH
// uc_side := 8 ;
2385: LD_ADDR_OWVAR 20
2389: PUSH
2390: LD_INT 8
2392: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2393: LD_ADDR_EXP 39
2397: PUSH
2398: LD_STRING Lynch
2400: PPUSH
2401: LD_INT 0
2403: PPUSH
2404: CALL 417 0 2
2408: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2409: LD_ADDR_EXP 40
2413: PUSH
2414: LD_STRING Walker
2416: PPUSH
2417: LD_INT 0
2419: PPUSH
2420: CALL 417 0 2
2424: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2425: LD_ADDR_EXP 41
2429: PUSH
2430: LD_STRING Turner
2432: PPUSH
2433: LD_INT 0
2435: PPUSH
2436: CALL 417 0 2
2440: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2441: LD_ADDR_EXP 42
2445: PUSH
2446: LD_STRING Jillian
2448: PPUSH
2449: LD_INT 0
2451: PPUSH
2452: CALL 417 0 2
2456: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2457: LD_ADDR_VAR 0 2
2461: PUSH
2462: LD_EXP 39
2466: PUSH
2467: LD_EXP 40
2471: PUSH
2472: LD_EXP 41
2476: PUSH
2477: LD_EXP 42
2481: PUSH
2482: EMPTY
2483: LIST
2484: LIST
2485: LIST
2486: LIST
2487: PUSH
2488: FOR_IN
2489: IFFALSE 2517
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2491: LD_VAR 0 2
2495: PPUSH
2496: LD_INT 3
2498: PPUSH
2499: LD_INT 0
2501: PPUSH
2502: CALL_OW 49
// ComHold ( i ) ;
2506: LD_VAR 0 2
2510: PPUSH
2511: CALL_OW 140
// end ;
2515: GO 2488
2517: POP
2518: POP
// end ;
2519: LD_VAR 0 1
2523: RET
// export function SelectGroup ; var units , selected , i ; begin
2524: LD_INT 0
2526: PPUSH
2527: PPUSH
2528: PPUSH
2529: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2530: LD_ADDR_VAR 0 2
2534: PUSH
2535: LD_EXP 29
2539: PUSH
2540: LD_INT -3
2542: PUSH
2543: EMPTY
2544: LIST
2545: LIST
2546: PUSH
2547: LD_EXP 2
2551: ADD
2552: PUSH
2553: LD_INT -2
2555: PUSH
2556: LD_INT -4
2558: PUSH
2559: LD_EXP 36
2563: PUSH
2564: LD_EXP 37
2568: PUSH
2569: EMPTY
2570: LIST
2571: LIST
2572: LIST
2573: LIST
2574: ADD
2575: PUSH
2576: LD_INT -3
2578: PUSH
2579: EMPTY
2580: LIST
2581: ADD
2582: PUSH
2583: LD_EXP 4
2587: ADD
2588: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2589: LD_ADDR_VAR 0 3
2593: PUSH
2594: LD_EXP 29
2598: PUSH
2599: LD_STRING Select five characters to go with you
2601: PPUSH
2602: LD_INT 4
2604: PPUSH
2605: LD_INT 4
2607: PPUSH
2608: LD_VAR 0 2
2612: PPUSH
2613: EMPTY
2614: PPUSH
2615: CALL_OW 42
2619: ADD
2620: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2621: LD_ADDR_EXP 4
2625: PUSH
2626: LD_EXP 2
2630: PUSH
2631: LD_EXP 4
2635: UNION
2636: PUSH
2637: LD_VAR 0 3
2641: DIFF
2642: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2643: LD_ADDR_VAR 0 4
2647: PUSH
2648: LD_EXP 4
2652: PUSH
2653: LD_EXP 37
2657: ADD
2658: PUSH
2659: FOR_IN
2660: IFFALSE 2691
// if GetSide ( i ) = 1 then
2662: LD_VAR 0 4
2666: PPUSH
2667: CALL_OW 255
2671: PUSH
2672: LD_INT 1
2674: EQUAL
2675: IFFALSE 2689
// SetSide ( i , 4 ) ;
2677: LD_VAR 0 4
2681: PPUSH
2682: LD_INT 4
2684: PPUSH
2685: CALL_OW 235
2689: GO 2659
2691: POP
2692: POP
// for i in selected do
2693: LD_ADDR_VAR 0 4
2697: PUSH
2698: LD_VAR 0 3
2702: PUSH
2703: FOR_IN
2704: IFFALSE 2735
// if GetSide ( i ) = 4 then
2706: LD_VAR 0 4
2710: PPUSH
2711: CALL_OW 255
2715: PUSH
2716: LD_INT 4
2718: EQUAL
2719: IFFALSE 2733
// SetSide ( i , 1 ) ;
2721: LD_VAR 0 4
2725: PPUSH
2726: LD_INT 1
2728: PPUSH
2729: CALL_OW 235
2733: GO 2703
2735: POP
2736: POP
// if GetSide ( Bobby ) = 4 then
2737: LD_EXP 30
2741: PPUSH
2742: CALL_OW 255
2746: PUSH
2747: LD_INT 4
2749: EQUAL
2750: IFFALSE 2759
// DeleteCharacters ( Bobby ) ;
2752: LD_STRING Bobby
2754: PPUSH
2755: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2759: LD_EXP 31
2763: PPUSH
2764: CALL_OW 255
2768: PUSH
2769: LD_INT 4
2771: EQUAL
2772: IFFALSE 2781
// DeleteCharacters ( Cyrus ) ;
2774: LD_STRING Cyrus
2776: PPUSH
2777: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2781: LD_EXP 32
2785: PPUSH
2786: CALL_OW 255
2790: PUSH
2791: LD_INT 4
2793: EQUAL
2794: IFFALSE 2803
// DeleteCharacters ( Lisa ) ;
2796: LD_STRING Lisa
2798: PPUSH
2799: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2803: LD_EXP 33
2807: PPUSH
2808: CALL_OW 255
2812: PUSH
2813: LD_INT 4
2815: EQUAL
2816: IFFALSE 2825
// DeleteCharacters ( Khatam ) ;
2818: LD_STRING Khatam
2820: PPUSH
2821: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2825: LD_EXP 34
2829: PPUSH
2830: CALL_OW 255
2834: PUSH
2835: LD_INT 4
2837: EQUAL
2838: IFFALSE 2847
// DeleteCharacters ( Brian ) ;
2840: LD_STRING Brian
2842: PPUSH
2843: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2847: LD_EXP 35
2851: PPUSH
2852: CALL_OW 255
2856: PUSH
2857: LD_INT 4
2859: EQUAL
2860: IFFALSE 2869
// DeleteCharacters ( Jerry ) ;
2862: LD_STRING Jerry
2864: PPUSH
2865: CALL_OW 40
// end ; end_of_file
2869: LD_VAR 0 1
2873: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , b , un , veh , tw , bar , skill , vehicles , spot_xy ; begin
2874: LD_INT 0
2876: PPUSH
2877: PPUSH
2878: PPUSH
2879: PPUSH
2880: PPUSH
2881: PPUSH
2882: PPUSH
2883: PPUSH
2884: PPUSH
2885: PPUSH
// ru_alert := false ;
2886: LD_ADDR_EXP 50
2890: PUSH
2891: LD_INT 0
2893: ST_TO_ADDR
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
2894: LD_ADDR_VAR 0 6
2898: PUSH
2899: LD_INT 22
2901: PUSH
2902: LD_INT 3
2904: PUSH
2905: EMPTY
2906: LIST
2907: LIST
2908: PUSH
2909: LD_INT 2
2911: PUSH
2912: LD_INT 30
2914: PUSH
2915: LD_INT 31
2917: PUSH
2918: EMPTY
2919: LIST
2920: LIST
2921: PUSH
2922: LD_INT 30
2924: PUSH
2925: LD_INT 32
2927: PUSH
2928: EMPTY
2929: LIST
2930: LIST
2931: PUSH
2932: EMPTY
2933: LIST
2934: LIST
2935: LIST
2936: PUSH
2937: EMPTY
2938: LIST
2939: LIST
2940: PPUSH
2941: CALL_OW 69
2945: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
2946: LD_ADDR_VAR 0 7
2950: PUSH
2951: LD_INT 22
2953: PUSH
2954: LD_INT 3
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: PUSH
2961: LD_INT 30
2963: PUSH
2964: LD_INT 4
2966: PUSH
2967: EMPTY
2968: LIST
2969: LIST
2970: PUSH
2971: EMPTY
2972: LIST
2973: LIST
2974: PPUSH
2975: CALL_OW 69
2979: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
2980: LD_ADDR_VAR 0 2
2984: PUSH
2985: LD_INT 22
2987: PUSH
2988: LD_INT 3
2990: PUSH
2991: EMPTY
2992: LIST
2993: LIST
2994: PUSH
2995: LD_INT 30
2997: PUSH
2998: LD_INT 1
3000: PUSH
3001: EMPTY
3002: LIST
3003: LIST
3004: PUSH
3005: EMPTY
3006: LIST
3007: LIST
3008: PPUSH
3009: CALL_OW 69
3013: PUSH
3014: FOR_IN
3015: IFFALSE 3059
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
3017: LD_VAR 0 2
3021: PPUSH
3022: CALL_OW 274
3026: PPUSH
3027: LD_INT 1
3029: PPUSH
3030: LD_INT 1000
3032: PPUSH
3033: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 300 ) ;
3037: LD_VAR 0 2
3041: PPUSH
3042: CALL_OW 274
3046: PPUSH
3047: LD_INT 2
3049: PPUSH
3050: LD_INT 300
3052: PPUSH
3053: CALL_OW 277
// end ;
3057: GO 3014
3059: POP
3060: POP
// uc_side := 3 ;
3061: LD_ADDR_OWVAR 20
3065: PUSH
3066: LD_INT 3
3068: ST_TO_ADDR
// uc_nation := 3 ;
3069: LD_ADDR_OWVAR 21
3073: PUSH
3074: LD_INT 3
3076: ST_TO_ADDR
// skill := [ 2 , 2 , 3 ] [ Difficulty ] ;
3077: LD_ADDR_VAR 0 8
3081: PUSH
3082: LD_INT 2
3084: PUSH
3085: LD_INT 2
3087: PUSH
3088: LD_INT 3
3090: PUSH
3091: EMPTY
3092: LIST
3093: LIST
3094: LIST
3095: PUSH
3096: LD_OWVAR 67
3100: ARRAY
3101: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3102: LD_ADDR_EXP 44
3106: PUSH
3107: LD_STRING Pokryshkin
3109: PPUSH
3110: LD_INT 0
3112: PPUSH
3113: CALL 417 0 2
3117: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3118: LD_EXP 44
3122: PPUSH
3123: LD_INT 63
3125: PPUSH
3126: LD_INT 21
3128: PPUSH
3129: LD_INT 0
3131: PPUSH
3132: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3136: LD_EXP 44
3140: PPUSH
3141: CALL_OW 140
// InitHc ;
3145: CALL_OW 19
// for i in tw do
3149: LD_ADDR_VAR 0 2
3153: PUSH
3154: LD_VAR 0 6
3158: PUSH
3159: FOR_IN
3160: IFFALSE 3209
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3162: LD_VAR 0 2
3166: PPUSH
3167: LD_INT 42
3169: PUSH
3170: LD_INT 43
3172: PUSH
3173: EMPTY
3174: LIST
3175: LIST
3176: PUSH
3177: LD_INT 1
3179: PPUSH
3180: LD_INT 2
3182: PPUSH
3183: CALL_OW 12
3187: ARRAY
3188: PPUSH
3189: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3193: LD_VAR 0 8
3197: PPUSH
3198: LD_VAR 0 2
3202: PPUSH
3203: CALL 761 0 2
// end ;
3207: GO 3159
3209: POP
3210: POP
// for i in bar do
3211: LD_ADDR_VAR 0 2
3215: PUSH
3216: LD_VAR 0 7
3220: PUSH
3221: FOR_IN
3222: IFFALSE 3255
// begin PrepareHuman ( false , 1 , skill ) ;
3224: LD_INT 0
3226: PPUSH
3227: LD_INT 1
3229: PPUSH
3230: LD_VAR 0 8
3234: PPUSH
3235: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3239: CALL_OW 44
3243: PPUSH
3244: LD_VAR 0 2
3248: PPUSH
3249: CALL_OW 52
// end ;
3253: GO 3221
3255: POP
3256: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3257: LD_ADDR_VAR 0 10
3261: PUSH
3262: LD_INT 100
3264: PUSH
3265: LD_INT 9
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: PUSH
3272: LD_INT 135
3274: PUSH
3275: LD_INT 60
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: PUSH
3282: LD_INT 41
3284: PUSH
3285: LD_INT 6
3287: PUSH
3288: EMPTY
3289: LIST
3290: LIST
3291: PUSH
3292: LD_INT 22
3294: PUSH
3295: LD_INT 9
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: PUSH
3302: LD_INT 84
3304: PUSH
3305: LD_INT 14
3307: PUSH
3308: EMPTY
3309: LIST
3310: LIST
3311: PUSH
3312: EMPTY
3313: LIST
3314: LIST
3315: LIST
3316: LIST
3317: LIST
3318: ST_TO_ADDR
// vehicles := [ ] ;
3319: LD_ADDR_VAR 0 9
3323: PUSH
3324: EMPTY
3325: ST_TO_ADDR
// for i in spot_xy do
3326: LD_ADDR_VAR 0 2
3330: PUSH
3331: LD_VAR 0 10
3335: PUSH
3336: FOR_IN
3337: IFFALSE 3495
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3339: LD_ADDR_VAR 0 5
3343: PUSH
3344: LD_INT 3
3346: PPUSH
3347: LD_INT 3
3349: PPUSH
3350: LD_INT 22
3352: PPUSH
3353: LD_INT 1
3355: PPUSH
3356: LD_INT 1
3358: PPUSH
3359: LD_INT 42
3361: PUSH
3362: LD_INT 43
3364: PUSH
3365: LD_INT 44
3367: PUSH
3368: EMPTY
3369: LIST
3370: LIST
3371: LIST
3372: PUSH
3373: LD_INT 1
3375: PPUSH
3376: LD_INT 3
3378: PPUSH
3379: CALL_OW 12
3383: ARRAY
3384: PPUSH
3385: LD_INT 100
3387: PPUSH
3388: CALL 483 0 7
3392: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3393: LD_ADDR_VAR 0 9
3397: PUSH
3398: LD_VAR 0 9
3402: PPUSH
3403: LD_VAR 0 9
3407: PUSH
3408: LD_INT 1
3410: PLUS
3411: PPUSH
3412: LD_VAR 0 5
3416: PPUSH
3417: CALL_OW 2
3421: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3422: LD_VAR 0 5
3426: PPUSH
3427: LD_INT 3
3429: PPUSH
3430: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3434: LD_VAR 0 5
3438: PPUSH
3439: LD_VAR 0 2
3443: PUSH
3444: LD_INT 1
3446: ARRAY
3447: PPUSH
3448: LD_VAR 0 2
3452: PUSH
3453: LD_INT 2
3455: ARRAY
3456: PPUSH
3457: LD_INT 0
3459: PPUSH
3460: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3464: LD_INT 0
3466: PPUSH
3467: LD_INT 3
3469: PPUSH
3470: LD_VAR 0 8
3474: PPUSH
3475: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3479: CALL_OW 44
3483: PPUSH
3484: LD_VAR 0 5
3488: PPUSH
3489: CALL_OW 52
// end ;
3493: GO 3336
3495: POP
3496: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3497: LD_ADDR_VAR 0 2
3501: PUSH
3502: DOUBLE
3503: LD_INT 1
3505: DEC
3506: ST_TO_ADDR
3507: LD_INT 5
3509: PUSH
3510: LD_INT 7
3512: PUSH
3513: LD_INT 8
3515: PUSH
3516: EMPTY
3517: LIST
3518: LIST
3519: LIST
3520: PUSH
3521: LD_OWVAR 67
3525: ARRAY
3526: PUSH
3527: FOR_TO
3528: IFFALSE 3588
// begin PrepareHuman ( false , 1 , skill ) ;
3530: LD_INT 0
3532: PPUSH
3533: LD_INT 1
3535: PPUSH
3536: LD_VAR 0 8
3540: PPUSH
3541: CALL_OW 380
// un := CreateHuman ;
3545: LD_ADDR_VAR 0 4
3549: PUSH
3550: CALL_OW 44
3554: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3555: LD_VAR 0 4
3559: PPUSH
3560: LD_INT 11
3562: PPUSH
3563: LD_INT 0
3565: PPUSH
3566: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3570: LD_ADDR_EXP 47
3574: PUSH
3575: LD_EXP 47
3579: PUSH
3580: LD_VAR 0 4
3584: ADD
3585: ST_TO_ADDR
// end ;
3586: GO 3527
3588: POP
3589: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3590: LD_ADDR_VAR 0 2
3594: PUSH
3595: DOUBLE
3596: LD_INT 1
3598: DEC
3599: ST_TO_ADDR
3600: LD_INT 2
3602: PUSH
3603: LD_INT 3
3605: PUSH
3606: LD_INT 4
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: LIST
3613: PUSH
3614: LD_OWVAR 67
3618: ARRAY
3619: PUSH
3620: FOR_TO
3621: IFFALSE 3681
// begin PrepareHuman ( false , 1 , skill ) ;
3623: LD_INT 0
3625: PPUSH
3626: LD_INT 1
3628: PPUSH
3629: LD_VAR 0 8
3633: PPUSH
3634: CALL_OW 380
// un := CreateHuman ;
3638: LD_ADDR_VAR 0 4
3642: PUSH
3643: CALL_OW 44
3647: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
3648: LD_VAR 0 4
3652: PPUSH
3653: LD_INT 12
3655: PPUSH
3656: LD_INT 0
3658: PPUSH
3659: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
3663: LD_ADDR_EXP 45
3667: PUSH
3668: LD_EXP 45
3672: PUSH
3673: LD_VAR 0 4
3677: ADD
3678: ST_TO_ADDR
// end ;
3679: GO 3620
3681: POP
3682: POP
// for i = 1 to 2 do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: DOUBLE
3689: LD_INT 1
3691: DEC
3692: ST_TO_ADDR
3693: LD_INT 2
3695: PUSH
3696: FOR_TO
3697: IFFALSE 3763
// begin PrepareHuman ( sex_male , 1 , skill ) ;
3699: LD_INT 1
3701: PPUSH
3702: LD_INT 1
3704: PPUSH
3705: LD_VAR 0 8
3709: PPUSH
3710: CALL_OW 380
// un := CreateHuman ;
3714: LD_ADDR_VAR 0 4
3718: PUSH
3719: CALL_OW 44
3723: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
3724: LD_VAR 0 4
3728: PPUSH
3729: LD_INT 39
3731: PPUSH
3732: LD_INT 12
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: LD_INT 0
3740: PPUSH
3741: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
3745: LD_ADDR_EXP 46
3749: PUSH
3750: LD_EXP 46
3754: PUSH
3755: LD_VAR 0 4
3759: ADD
3760: ST_TO_ADDR
// end ;
3761: GO 3696
3763: POP
3764: POP
// ru_vehicles := vehicles ;
3765: LD_ADDR_EXP 48
3769: PUSH
3770: LD_VAR 0 9
3774: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
3775: LD_ADDR_EXP 49
3779: PUSH
3780: LD_INT 131
3782: PUSH
3783: LD_INT 121
3785: PUSH
3786: EMPTY
3787: LIST
3788: LIST
3789: PUSH
3790: LD_INT 113
3792: PUSH
3793: LD_INT 90
3795: PUSH
3796: EMPTY
3797: LIST
3798: LIST
3799: PUSH
3800: LD_INT 93
3802: PUSH
3803: LD_INT 62
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PUSH
3810: EMPTY
3811: LIST
3812: LIST
3813: LIST
3814: PUSH
3815: LD_INT 106
3817: PUSH
3818: LD_INT 54
3820: PUSH
3821: EMPTY
3822: LIST
3823: LIST
3824: PUSH
3825: LD_INT 120
3827: PUSH
3828: LD_INT 80
3830: PUSH
3831: EMPTY
3832: LIST
3833: LIST
3834: PUSH
3835: LD_INT 143
3837: PUSH
3838: LD_INT 120
3840: PUSH
3841: EMPTY
3842: LIST
3843: LIST
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: LIST
3849: PUSH
3850: LD_INT 154
3852: PUSH
3853: LD_INT 116
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PUSH
3860: LD_INT 140
3862: PUSH
3863: LD_INT 93
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: PUSH
3870: LD_INT 130
3872: PUSH
3873: LD_INT 58
3875: PUSH
3876: EMPTY
3877: LIST
3878: LIST
3879: PUSH
3880: EMPTY
3881: LIST
3882: LIST
3883: LIST
3884: PUSH
3885: LD_INT 105
3887: PUSH
3888: LD_INT 106
3890: PUSH
3891: EMPTY
3892: LIST
3893: LIST
3894: PUSH
3895: LD_INT 134
3897: PUSH
3898: LD_INT 98
3900: PUSH
3901: EMPTY
3902: LIST
3903: LIST
3904: PUSH
3905: LD_INT 159
3907: PUSH
3908: LD_INT 113
3910: PUSH
3911: EMPTY
3912: LIST
3913: LIST
3914: PUSH
3915: EMPTY
3916: LIST
3917: LIST
3918: LIST
3919: PUSH
3920: EMPTY
3921: LIST
3922: LIST
3923: LIST
3924: LIST
3925: ST_TO_ADDR
// end ; end_of_file
3926: LD_VAR 0 1
3930: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
3931: LD_INT 0
3933: PPUSH
3934: PPUSH
3935: PPUSH
3936: PPUSH
3937: PPUSH
3938: PPUSH
3939: PPUSH
// InGameOn ;
3940: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
3944: LD_EXP 29
3948: PPUSH
3949: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
3953: LD_EXP 29
3957: PPUSH
3958: LD_EXP 36
3962: PPUSH
3963: CALL_OW 119
// if Bierezov then
3967: LD_EXP 37
3971: IFFALSE 3987
// ComTurnUnit ( Bierezov , Cornel ) ;
3973: LD_EXP 37
3977: PPUSH
3978: LD_EXP 36
3982: PPUSH
3983: CALL_OW 119
// for i in jmm_units do
3987: LD_ADDR_VAR 0 2
3991: PUSH
3992: LD_EXP 2
3996: PUSH
3997: FOR_IN
3998: IFFALSE 4016
// ComTurnUnit ( i , Cornel ) ;
4000: LD_VAR 0 2
4004: PPUSH
4005: LD_EXP 36
4009: PPUSH
4010: CALL_OW 119
4014: GO 3997
4016: POP
4017: POP
// units := cornel_units union Cornel ;
4018: LD_ADDR_VAR 0 3
4022: PUSH
4023: LD_EXP 4
4027: PUSH
4028: LD_EXP 36
4032: UNION
4033: ST_TO_ADDR
// repeat wait ( 1 ) ;
4034: LD_INT 1
4036: PPUSH
4037: CALL_OW 67
// for i in units do
4041: LD_ADDR_VAR 0 2
4045: PUSH
4046: LD_VAR 0 3
4050: PUSH
4051: FOR_IN
4052: IFFALSE 4085
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
4054: LD_VAR 0 2
4058: PPUSH
4059: LD_EXP 29
4063: PPUSH
4064: CALL_OW 250
4068: PPUSH
4069: LD_EXP 29
4073: PPUSH
4074: CALL_OW 251
4078: PPUSH
4079: CALL_OW 111
4083: GO 4051
4085: POP
4086: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
4087: LD_VAR 0 3
4091: PPUSH
4092: LD_INT 92
4094: PUSH
4095: LD_EXP 29
4099: PPUSH
4100: CALL_OW 250
4104: PUSH
4105: LD_EXP 29
4109: PPUSH
4110: CALL_OW 251
4114: PUSH
4115: LD_INT 10
4117: PUSH
4118: EMPTY
4119: LIST
4120: LIST
4121: LIST
4122: LIST
4123: PPUSH
4124: CALL_OW 72
4128: PUSH
4129: LD_VAR 0 3
4133: EQUAL
4134: IFFALSE 4034
// for i in units do
4136: LD_ADDR_VAR 0 2
4140: PUSH
4141: LD_VAR 0 3
4145: PUSH
4146: FOR_IN
4147: IFFALSE 4165
// ComTurnUnit ( i , JMM ) ;
4149: LD_VAR 0 2
4153: PPUSH
4154: LD_EXP 29
4158: PPUSH
4159: CALL_OW 119
4163: GO 4146
4165: POP
4166: POP
// ComTurnUnit ( Cornel , JMM ) ;
4167: LD_EXP 36
4171: PPUSH
4172: LD_EXP 29
4176: PPUSH
4177: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
4181: LD_EXP 29
4185: PPUSH
4186: LD_STRING D1-JMM-1
4188: PPUSH
4189: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
4193: LD_EXP 36
4197: PPUSH
4198: LD_STRING D1-Corn-1
4200: PPUSH
4201: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
4205: LD_EXP 29
4209: PPUSH
4210: LD_EXP 36
4214: PPUSH
4215: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
4219: LD_EXP 36
4223: PPUSH
4224: LD_EXP 29
4228: PPUSH
4229: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
4233: LD_INT 35
4235: PPUSH
4236: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
4240: LD_EXP 29
4244: PPUSH
4245: LD_EXP 36
4249: PPUSH
4250: CALL_OW 296
4254: PUSH
4255: LD_INT 6
4257: LESS
4258: IFFALSE 4233
// ChangeSideFog ( 4 , 1 ) ;
4260: LD_INT 4
4262: PPUSH
4263: LD_INT 1
4265: PPUSH
4266: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
4270: LD_EXP 29
4274: PPUSH
4275: LD_EXP 36
4279: PPUSH
4280: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
4284: LD_EXP 36
4288: PPUSH
4289: LD_EXP 29
4293: PPUSH
4294: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
4298: LD_EXP 29
4302: PPUSH
4303: LD_STRING D1-JMM-2
4305: PPUSH
4306: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
4310: LD_EXP 29
4314: PPUSH
4315: LD_STRING D1-JMM-2a
4317: PPUSH
4318: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
4322: LD_EXP 36
4326: PPUSH
4327: LD_STRING D1-Corn-2
4329: PPUSH
4330: CALL_OW 88
// if bierezov_exist or debug then
4334: LD_EXP 5
4338: PUSH
4339: LD_EXP 1
4343: OR
4344: IFFALSE 4585
// begin ComTurnUnit ( Cornel , Bierezov ) ;
4346: LD_EXP 36
4350: PPUSH
4351: LD_EXP 37
4355: PPUSH
4356: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
4360: LD_INT 10
4362: PPUSH
4363: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
4367: LD_EXP 36
4371: PPUSH
4372: LD_STRING D1a-Corn-1
4374: PPUSH
4375: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
4379: LD_EXP 29
4383: PPUSH
4384: LD_EXP 37
4388: PPUSH
4389: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
4393: LD_EXP 37
4397: PPUSH
4398: LD_EXP 29
4402: PPUSH
4403: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
4407: LD_EXP 29
4411: PPUSH
4412: LD_STRING D1a-JMM-1
4414: PPUSH
4415: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
4419: LD_EXP 29
4423: PPUSH
4424: LD_EXP 36
4428: PPUSH
4429: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
4433: LD_EXP 36
4437: PPUSH
4438: LD_EXP 29
4442: PPUSH
4443: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
4447: LD_EXP 36
4451: PPUSH
4452: LD_STRING D1a-Corn-2
4454: PPUSH
4455: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
4459: LD_EXP 29
4463: PPUSH
4464: LD_STRING D1a-JMM-2
4466: PPUSH
4467: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
4471: LD_EXP 36
4475: PPUSH
4476: LD_STRING D1a-Corn-3
4478: PPUSH
4479: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
4483: LD_EXP 29
4487: PPUSH
4488: LD_STRING D1a-JMM-3
4490: PPUSH
4491: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
4495: LD_EXP 36
4499: PPUSH
4500: LD_STRING D1a-Corn-4
4502: PPUSH
4503: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
4507: LD_EXP 29
4511: PPUSH
4512: LD_STRING D1a-JMM-4
4514: PPUSH
4515: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
4519: LD_EXP 36
4523: PPUSH
4524: LD_STRING D1a-Corn-5
4526: PPUSH
4527: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
4531: LD_EXP 37
4535: PPUSH
4536: LD_EXP 36
4540: PPUSH
4541: CALL_OW 250
4545: PPUSH
4546: LD_EXP 36
4550: PPUSH
4551: CALL_OW 251
4555: PUSH
4556: LD_INT 2
4558: MINUS
4559: PPUSH
4560: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
4564: LD_EXP 37
4568: PPUSH
4569: LD_EXP 36
4573: PPUSH
4574: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
4578: LD_INT 10
4580: PPUSH
4581: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
4585: LD_EXP 29
4589: PPUSH
4590: LD_STRING D1b-JMM-1
4592: PPUSH
4593: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
4597: LD_EXP 36
4601: PPUSH
4602: LD_STRING D1b-Corn-1
4604: PPUSH
4605: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
4609: LD_EXP 29
4613: PPUSH
4614: LD_STRING D1b-JMM-2
4616: PPUSH
4617: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
4621: LD_EXP 36
4625: PPUSH
4626: LD_STRING D1b-Corn-2
4628: PPUSH
4629: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
4633: LD_EXP 29
4637: PPUSH
4638: LD_STRING D1b-JMM-3
4640: PPUSH
4641: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
4645: LD_INT 10
4647: PPUSH
4648: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
4652: LD_EXP 38
4656: PPUSH
4657: LD_STRING D1b-Pow-3
4659: PPUSH
4660: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
4664: LD_EXP 29
4668: PPUSH
4669: LD_STRING D1b-JMM-4
4671: PPUSH
4672: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
4676: LD_EXP 36
4680: PPUSH
4681: LD_STRING D1b-Corn-4
4683: PPUSH
4684: CALL_OW 88
// if Khatam then
4688: LD_EXP 33
4692: IFFALSE 4708
// Say ( Khatam , D1b-Khat-4 ) else
4694: LD_EXP 33
4698: PPUSH
4699: LD_STRING D1b-Khat-4
4701: PPUSH
4702: CALL_OW 88
4706: GO 4744
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
4708: LD_EXP 4
4712: PPUSH
4713: LD_INT 26
4715: PUSH
4716: LD_INT 1
4718: PUSH
4719: EMPTY
4720: LIST
4721: LIST
4722: PPUSH
4723: CALL_OW 72
4727: PUSH
4728: LD_EXP 36
4732: PUSH
4733: EMPTY
4734: LIST
4735: DIFF
4736: PPUSH
4737: LD_STRING D1b-Sol1-4
4739: PPUSH
4740: CALL 571 0 2
// if Cyrus then
4744: LD_EXP 31
4748: IFFALSE 4762
// Say ( Cyrus , D1b-Cyrus-4 ) ;
4750: LD_EXP 31
4754: PPUSH
4755: LD_STRING D1b-Cyrus-4
4757: PPUSH
4758: CALL_OW 88
// if Lisa then
4762: LD_EXP 32
4766: IFFALSE 4824
// begin Say ( Lisa , D1b-Lisa-4 ) ;
4768: LD_EXP 32
4772: PPUSH
4773: LD_STRING D1b-Lisa-4
4775: PPUSH
4776: CALL_OW 88
// if Cyrus then
4780: LD_EXP 31
4784: IFFALSE 4824
// begin if not IsInUnit ( Cyrus ) then
4786: LD_EXP 31
4790: PPUSH
4791: CALL_OW 310
4795: NOT
4796: IFFALSE 4812
// ComTurnUnit ( Cyrus , Lisa ) ;
4798: LD_EXP 31
4802: PPUSH
4803: LD_EXP 32
4807: PPUSH
4808: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
4812: LD_EXP 31
4816: PPUSH
4817: LD_STRING D1b-Cyrus-5
4819: PPUSH
4820: CALL_OW 88
// end ; end ; SelectGroup ;
4824: CALL 2524 0 0
// Say ( JMM , D1d-JMM-1 ) ;
4828: LD_EXP 29
4832: PPUSH
4833: LD_STRING D1d-JMM-1
4835: PPUSH
4836: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
4840: LD_EXP 36
4844: PPUSH
4845: LD_STRING D1d-Corn-1
4847: PPUSH
4848: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
4852: LD_ADDR_VAR 0 2
4856: PUSH
4857: LD_EXP 2
4861: PUSH
4862: LD_EXP 4
4866: ADD
4867: PUSH
4868: LD_EXP 29
4872: ADD
4873: PUSH
4874: FOR_IN
4875: IFFALSE 4888
// ComHold ( i ) ;
4877: LD_VAR 0 2
4881: PPUSH
4882: CALL_OW 140
4886: GO 4874
4888: POP
4889: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
4890: LD_ADDR_VAR 0 4
4894: PUSH
4895: LD_INT 22
4897: PUSH
4898: LD_INT 1
4900: PUSH
4901: EMPTY
4902: LIST
4903: LIST
4904: PUSH
4905: LD_INT 21
4907: PUSH
4908: LD_INT 2
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PUSH
4915: EMPTY
4916: LIST
4917: LIST
4918: PPUSH
4919: CALL_OW 69
4923: ST_TO_ADDR
// if vehicles then
4924: LD_VAR 0 4
4928: IFFALSE 5266
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
4930: LD_EXP 4
4934: PPUSH
4935: LD_INT 55
4937: PUSH
4938: EMPTY
4939: LIST
4940: PPUSH
4941: CALL_OW 72
4945: IFFALSE 4984
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
4947: LD_ADDR_VAR 0 2
4951: PUSH
4952: LD_EXP 4
4956: PPUSH
4957: LD_INT 55
4959: PUSH
4960: EMPTY
4961: LIST
4962: PPUSH
4963: CALL_OW 72
4967: PUSH
4968: FOR_IN
4969: IFFALSE 4982
// ComExitVehicle ( i ) ;
4971: LD_VAR 0 2
4975: PPUSH
4976: CALL_OW 121
4980: GO 4968
4982: POP
4983: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
4984: LD_ADDR_VAR 0 5
4988: PUSH
4989: LD_VAR 0 4
4993: PPUSH
4994: LD_INT 34
4996: PUSH
4997: LD_INT 51
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: PPUSH
5004: CALL_OW 72
5008: ST_TO_ADDR
// if cargos then
5009: LD_VAR 0 5
5013: IFFALSE 5196
// begin vehicles := cargos ;
5015: LD_ADDR_VAR 0 4
5019: PUSH
5020: LD_VAR 0 5
5024: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
5025: LD_ADDR_VAR 0 6
5029: PUSH
5030: LD_STRING 02_resources_4
5032: PPUSH
5033: LD_INT 0
5035: PPUSH
5036: CALL_OW 30
5040: ST_TO_ADDR
// if debug and not resources then
5041: LD_EXP 1
5045: PUSH
5046: LD_VAR 0 6
5050: NOT
5051: AND
5052: IFFALSE 5062
// resources := 160 ;
5054: LD_ADDR_VAR 0 6
5058: PUSH
5059: LD_INT 160
5061: ST_TO_ADDR
// if resources mod 10 then
5062: LD_VAR 0 6
5066: PUSH
5067: LD_INT 10
5069: MOD
5070: IFFALSE 5092
// resources := resources - resources mod 10 ;
5072: LD_ADDR_VAR 0 6
5076: PUSH
5077: LD_VAR 0 6
5081: PUSH
5082: LD_VAR 0 6
5086: PUSH
5087: LD_INT 10
5089: MOD
5090: MINUS
5091: ST_TO_ADDR
// if resources then
5092: LD_VAR 0 6
5096: IFFALSE 5196
// for i in cargos do
5098: LD_ADDR_VAR 0 2
5102: PUSH
5103: LD_VAR 0 5
5107: PUSH
5108: FOR_IN
5109: IFFALSE 5194
// begin if resources < 100 then
5111: LD_VAR 0 6
5115: PUSH
5116: LD_INT 100
5118: LESS
5119: IFFALSE 5141
// begin cargo := resources ;
5121: LD_ADDR_VAR 0 7
5125: PUSH
5126: LD_VAR 0 6
5130: ST_TO_ADDR
// resources := 0 ;
5131: LD_ADDR_VAR 0 6
5135: PUSH
5136: LD_INT 0
5138: ST_TO_ADDR
// end else
5139: GO 5163
// begin cargo := 100 ;
5141: LD_ADDR_VAR 0 7
5145: PUSH
5146: LD_INT 100
5148: ST_TO_ADDR
// resources := resources - 100 ;
5149: LD_ADDR_VAR 0 6
5153: PUSH
5154: LD_VAR 0 6
5158: PUSH
5159: LD_INT 100
5161: MINUS
5162: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
5163: LD_VAR 0 2
5167: PPUSH
5168: LD_INT 1
5170: PPUSH
5171: LD_VAR 0 7
5175: PPUSH
5176: CALL_OW 290
// if resources = 0 then
5180: LD_VAR 0 6
5184: PUSH
5185: LD_INT 0
5187: EQUAL
5188: IFFALSE 5192
// break ;
5190: GO 5194
// end ;
5192: GO 5108
5194: POP
5195: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
5196: LD_VAR 0 4
5200: PUSH
5201: LD_INT 1
5203: ARRAY
5204: PPUSH
5205: CALL_OW 311
5209: PPUSH
5210: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
5214: LD_VAR 0 4
5218: PUSH
5219: LD_INT 1
5221: ARRAY
5222: PPUSH
5223: LD_INT 4
5225: PPUSH
5226: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
5230: LD_EXP 36
5234: PPUSH
5235: LD_VAR 0 4
5239: PUSH
5240: LD_INT 1
5242: ARRAY
5243: PPUSH
5244: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
5248: LD_INT 35
5250: PPUSH
5251: CALL_OW 67
// until IsInUnit ( Cornel ) ;
5255: LD_EXP 36
5259: PPUSH
5260: CALL_OW 310
5264: IFFALSE 5248
// end ; InGameOff ;
5266: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
5270: LD_STRING M1
5272: PPUSH
5273: CALL_OW 337
// SaveForQuickRestart ;
5277: CALL_OW 22
// cornel_active := true ;
5281: LD_ADDR_EXP 6
5285: PUSH
5286: LD_INT 1
5288: ST_TO_ADDR
// end ;
5289: LD_VAR 0 1
5293: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
5294: LD_EXP 29
5298: PPUSH
5299: LD_EXP 39
5303: PPUSH
5304: CALL_OW 296
5308: PUSH
5309: LD_INT 10
5311: LESS
5312: IFFALSE 6427
5314: GO 5316
5316: DISABLE
5317: LD_INT 0
5319: PPUSH
5320: PPUSH
5321: PPUSH
5322: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
5323: LD_ADDR_VAR 0 2
5327: PUSH
5328: LD_INT 89
5330: PUSH
5331: LD_INT 34
5333: PUSH
5334: EMPTY
5335: LIST
5336: LIST
5337: PUSH
5338: LD_INT 138
5340: PUSH
5341: LD_INT 63
5343: PUSH
5344: EMPTY
5345: LIST
5346: LIST
5347: PUSH
5348: LD_INT 196
5350: PUSH
5351: LD_INT 84
5353: PUSH
5354: EMPTY
5355: LIST
5356: LIST
5357: PUSH
5358: LD_INT 135
5360: PUSH
5361: LD_INT 52
5363: PUSH
5364: EMPTY
5365: LIST
5366: LIST
5367: PUSH
5368: LD_INT 103
5370: PUSH
5371: LD_INT 39
5373: PUSH
5374: EMPTY
5375: LIST
5376: LIST
5377: PUSH
5378: LD_INT 58
5380: PUSH
5381: LD_INT 30
5383: PUSH
5384: EMPTY
5385: LIST
5386: LIST
5387: PUSH
5388: LD_INT 38
5390: PUSH
5391: LD_INT 51
5393: PUSH
5394: EMPTY
5395: LIST
5396: LIST
5397: PUSH
5398: EMPTY
5399: LIST
5400: LIST
5401: LIST
5402: LIST
5403: LIST
5404: LIST
5405: LIST
5406: ST_TO_ADDR
// InGameOn ;
5407: CALL_OW 8
// if jmm_units then
5411: LD_EXP 2
5415: IFFALSE 5479
// for i in jmm_units do
5417: LD_ADDR_VAR 0 1
5421: PUSH
5422: LD_EXP 2
5426: PUSH
5427: FOR_IN
5428: IFFALSE 5477
// begin if GetDistUnits ( i , JMM ) < 10 then
5430: LD_VAR 0 1
5434: PPUSH
5435: LD_EXP 29
5439: PPUSH
5440: CALL_OW 296
5444: PUSH
5445: LD_INT 10
5447: LESS
5448: IFFALSE 5466
// ComTurnUnit ( i , JMM ) else
5450: LD_VAR 0 1
5454: PPUSH
5455: LD_EXP 29
5459: PPUSH
5460: CALL_OW 119
5464: GO 5475
// ComHold ( i ) ;
5466: LD_VAR 0 1
5470: PPUSH
5471: CALL_OW 140
// end ;
5475: GO 5427
5477: POP
5478: POP
// ComMoveUnit ( JMM , Lynch ) ;
5479: LD_EXP 29
5483: PPUSH
5484: LD_EXP 39
5488: PPUSH
5489: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5493: LD_INT 35
5495: PPUSH
5496: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
5500: LD_EXP 29
5504: PPUSH
5505: LD_EXP 39
5509: PPUSH
5510: CALL_OW 296
5514: PUSH
5515: LD_INT 6
5517: LESS
5518: IFFALSE 5493
// ComTurnUnit ( JMM , Lynch ) ;
5520: LD_EXP 29
5524: PPUSH
5525: LD_EXP 39
5529: PPUSH
5530: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
5534: LD_ADDR_VAR 0 1
5538: PUSH
5539: LD_EXP 39
5543: PUSH
5544: LD_EXP 40
5548: PUSH
5549: LD_EXP 41
5553: PUSH
5554: LD_EXP 42
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: LIST
5563: LIST
5564: PUSH
5565: FOR_IN
5566: IFFALSE 5584
// ComTurnUnit ( i , JMM ) ;
5568: LD_VAR 0 1
5572: PPUSH
5573: LD_EXP 29
5577: PPUSH
5578: CALL_OW 119
5582: GO 5565
5584: POP
5585: POP
// Wait ( 0 0$0.3 ) ;
5586: LD_INT 10
5588: PPUSH
5589: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
5593: LD_EXP 29
5597: PPUSH
5598: LD_STRING D2-JMM-1
5600: PPUSH
5601: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
5605: LD_EXP 39
5609: PPUSH
5610: LD_STRING D2-Sol1-1
5612: PPUSH
5613: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
5617: LD_EXP 29
5621: PPUSH
5622: LD_STRING D2-JMM-2
5624: PPUSH
5625: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
5629: LD_EXP 39
5633: PPUSH
5634: LD_STRING D2-Sol1-2
5636: PPUSH
5637: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
5641: LD_EXP 29
5645: PPUSH
5646: LD_STRING D2-JMM-3
5648: PPUSH
5649: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
5653: LD_EXP 39
5657: PPUSH
5658: LD_STRING D2-Sol1-3
5660: PPUSH
5661: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
5665: LD_ADDR_VAR 0 1
5669: PUSH
5670: LD_INT 22
5672: PUSH
5673: LD_INT 8
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: PPUSH
5680: CALL_OW 69
5684: PUSH
5685: FOR_IN
5686: IFFALSE 5702
// SetSide ( i , 1 ) ;
5688: LD_VAR 0 1
5692: PPUSH
5693: LD_INT 1
5695: PPUSH
5696: CALL_OW 235
5700: GO 5685
5702: POP
5703: POP
// Say ( JMM , D2-JMM-4 ) ;
5704: LD_EXP 29
5708: PPUSH
5709: LD_STRING D2-JMM-4
5711: PPUSH
5712: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
5716: LD_INT 1
5718: PPUSH
5719: LD_INT 5
5721: PPUSH
5722: CALL_OW 332
// for i = 1 to points do
5726: LD_ADDR_VAR 0 1
5730: PUSH
5731: DOUBLE
5732: LD_INT 1
5734: DEC
5735: ST_TO_ADDR
5736: LD_VAR 0 2
5740: PUSH
5741: FOR_TO
5742: IFFALSE 5917
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
5744: LD_VAR 0 2
5748: PUSH
5749: LD_VAR 0 1
5753: ARRAY
5754: PUSH
5755: LD_INT 1
5757: ARRAY
5758: PPUSH
5759: LD_VAR 0 2
5763: PUSH
5764: LD_VAR 0 1
5768: ARRAY
5769: PUSH
5770: LD_INT 2
5772: ARRAY
5773: PPUSH
5774: CALL_OW 84
// if i = 1 then
5778: LD_VAR 0 1
5782: PUSH
5783: LD_INT 1
5785: EQUAL
5786: IFFALSE 5800
// Say ( Lynch , D2-Sol1-4 ) ;
5788: LD_EXP 39
5792: PPUSH
5793: LD_STRING D2-Sol1-4
5795: PPUSH
5796: CALL_OW 88
// if i = 2 then
5800: LD_VAR 0 1
5804: PUSH
5805: LD_INT 2
5807: EQUAL
5808: IFFALSE 5822
// Say ( JMM , D2-JMM-5 ) ;
5810: LD_EXP 29
5814: PPUSH
5815: LD_STRING D2-JMM-5
5817: PPUSH
5818: CALL_OW 88
// if i = 4 then
5822: LD_VAR 0 1
5826: PUSH
5827: LD_INT 4
5829: EQUAL
5830: IFFALSE 5854
// begin RevealFogArea ( 1 , troopsArea ) ;
5832: LD_INT 1
5834: PPUSH
5835: LD_INT 6
5837: PPUSH
5838: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
5842: LD_EXP 39
5846: PPUSH
5847: LD_STRING D2-Sol1-5
5849: PPUSH
5850: CALL_OW 88
// end ; if i = 5 then
5854: LD_VAR 0 1
5858: PUSH
5859: LD_INT 5
5861: EQUAL
5862: IFFALSE 5876
// Say ( JMM , D2-JMM-6 ) ;
5864: LD_EXP 29
5868: PPUSH
5869: LD_STRING D2-JMM-6
5871: PPUSH
5872: CALL_OW 88
// if i = 7 then
5876: LD_VAR 0 1
5880: PUSH
5881: LD_INT 7
5883: EQUAL
5884: IFFALSE 5908
// begin RevealFogArea ( 1 , forestArea ) ;
5886: LD_INT 1
5888: PPUSH
5889: LD_INT 7
5891: PPUSH
5892: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
5896: LD_EXP 39
5900: PPUSH
5901: LD_STRING D2-Sol1-6
5903: PPUSH
5904: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
5908: LD_INT 46
5910: PPUSH
5911: CALL_OW 67
// end ;
5915: GO 5741
5917: POP
5918: POP
// CenterNowOnUnits ( JMM ) ;
5919: LD_EXP 29
5923: PPUSH
5924: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
5928: LD_EXP 29
5932: PPUSH
5933: LD_STRING D2-JMM-7
5935: PPUSH
5936: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
5940: LD_EXP 39
5944: PPUSH
5945: LD_STRING D2-Sol1-7
5947: PPUSH
5948: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
5952: LD_EXP 29
5956: PPUSH
5957: LD_STRING D2-JMM-8
5959: PPUSH
5960: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
5964: LD_ADDR_VAR 0 4
5968: PUSH
5969: LD_INT 22
5971: PUSH
5972: LD_INT 1
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: PUSH
5979: LD_INT 30
5981: PUSH
5982: LD_INT 31
5984: PUSH
5985: EMPTY
5986: LIST
5987: LIST
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: PPUSH
5993: CALL_OW 69
5997: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
5998: LD_EXP 39
6002: PPUSH
6003: LD_VAR 0 4
6007: PUSH
6008: LD_INT 1
6010: ARRAY
6011: PPUSH
6012: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
6016: LD_ADDR_VAR 0 3
6020: PUSH
6021: LD_EXP 2
6025: PPUSH
6026: LD_INT 25
6028: PUSH
6029: LD_INT 1
6031: PUSH
6032: EMPTY
6033: LIST
6034: LIST
6035: PPUSH
6036: CALL_OW 72
6040: PPUSH
6041: LD_EXP 29
6045: PPUSH
6046: CALL_OW 74
6050: ST_TO_ADDR
// if sol then
6051: LD_VAR 0 3
6055: IFFALSE 6095
// if GetDistUnits ( JMM , sol ) < 10 then
6057: LD_EXP 29
6061: PPUSH
6062: LD_VAR 0 3
6066: PPUSH
6067: CALL_OW 296
6071: PUSH
6072: LD_INT 10
6074: LESS
6075: IFFALSE 6095
// ComEnterUnit ( sol , buns [ 2 ] ) ;
6077: LD_VAR 0 3
6081: PPUSH
6082: LD_VAR 0 4
6086: PUSH
6087: LD_INT 2
6089: ARRAY
6090: PPUSH
6091: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
6095: LD_INT 10
6097: PPUSH
6098: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
6102: LD_EXP 29
6106: PPUSH
6107: LD_INT 65
6109: PPUSH
6110: LD_INT 101
6112: PPUSH
6113: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
6117: LD_EXP 29
6121: PPUSH
6122: LD_INT 63
6124: PPUSH
6125: LD_INT 100
6127: PPUSH
6128: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
6132: LD_INT 35
6134: PPUSH
6135: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
6139: LD_EXP 29
6143: PPUSH
6144: LD_INT 65
6146: PPUSH
6147: LD_INT 101
6149: PPUSH
6150: CALL_OW 307
6154: IFFALSE 6132
// Say ( JMM , D2a-JMM-1 ) ;
6156: LD_EXP 29
6160: PPUSH
6161: LD_STRING D2a-JMM-1
6163: PPUSH
6164: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
6168: LD_EXP 40
6172: PPUSH
6173: LD_INT 66
6175: PPUSH
6176: LD_INT 103
6178: PPUSH
6179: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
6183: LD_INT 35
6185: PPUSH
6186: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
6190: LD_EXP 40
6194: PPUSH
6195: LD_INT 66
6197: PPUSH
6198: LD_INT 103
6200: PPUSH
6201: CALL_OW 307
6205: IFFALSE 6183
// ComTurnUnit ( Walker , JMM ) ;
6207: LD_EXP 40
6211: PPUSH
6212: LD_EXP 29
6216: PPUSH
6217: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
6221: LD_EXP 40
6225: PPUSH
6226: LD_STRING D2a-Sci1-1
6228: PPUSH
6229: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
6233: LD_EXP 29
6237: PPUSH
6238: LD_EXP 40
6242: PPUSH
6243: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
6247: LD_EXP 29
6251: PPUSH
6252: LD_STRING D2a-JMM-2
6254: PPUSH
6255: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
6259: LD_EXP 40
6263: PPUSH
6264: LD_STRING D2a-Sci1-2
6266: PPUSH
6267: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
6271: LD_EXP 29
6275: PPUSH
6276: LD_STRING D2a-JMM-3
6278: PPUSH
6279: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
6283: LD_EXP 40
6287: PPUSH
6288: LD_STRING D2a-Sci1-3
6290: PPUSH
6291: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
6295: LD_ADDR_EXP 2
6299: PUSH
6300: LD_EXP 2
6304: PUSH
6305: LD_EXP 39
6309: PUSH
6310: LD_EXP 40
6314: PUSH
6315: LD_EXP 41
6319: PUSH
6320: LD_EXP 42
6324: PUSH
6325: EMPTY
6326: LIST
6327: LIST
6328: LIST
6329: LIST
6330: ADD
6331: ST_TO_ADDR
// for i in jmm_units do
6332: LD_ADDR_VAR 0 1
6336: PUSH
6337: LD_EXP 2
6341: PUSH
6342: FOR_IN
6343: IFFALSE 6368
// if not IsInUnit ( i ) then
6345: LD_VAR 0 1
6349: PPUSH
6350: CALL_OW 310
6354: NOT
6355: IFFALSE 6366
// ComFree ( i ) ;
6357: LD_VAR 0 1
6361: PPUSH
6362: CALL_OW 139
6366: GO 6342
6368: POP
6369: POP
// InGameOff ;
6370: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
6374: LD_STRING MSolar1
6376: PPUSH
6377: CALL_OW 337
// jmm_on_west := true ;
6381: LD_ADDR_EXP 3
6385: PUSH
6386: LD_INT 1
6388: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
6389: LD_INT 1050
6391: PPUSH
6392: CALL_OW 67
// frank_can_return := true ;
6396: LD_ADDR_EXP 10
6400: PUSH
6401: LD_INT 1
6403: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
6404: LD_INT 6300
6406: PPUSH
6407: LD_INT 8400
6409: PPUSH
6410: CALL_OW 12
6414: PPUSH
6415: CALL_OW 67
// send_spec_patrol := true ;
6419: LD_ADDR_EXP 25
6423: PUSH
6424: LD_INT 1
6426: ST_TO_ADDR
// end ;
6427: PPOPN 4
6429: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
6430: LD_INT 22
6432: PUSH
6433: LD_INT 1
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: PUSH
6440: LD_INT 34
6442: PUSH
6443: LD_INT 51
6445: PUSH
6446: EMPTY
6447: LIST
6448: LIST
6449: PUSH
6450: LD_INT 92
6452: PUSH
6453: LD_INT 63
6455: PUSH
6456: LD_INT 100
6458: PUSH
6459: LD_INT 5
6461: PUSH
6462: EMPTY
6463: LIST
6464: LIST
6465: LIST
6466: LIST
6467: PUSH
6468: EMPTY
6469: LIST
6470: LIST
6471: LIST
6472: PUSH
6473: EMPTY
6474: LIST
6475: PPUSH
6476: CALL_OW 69
6480: PUSH
6481: LD_EXP 3
6485: NOT
6486: AND
6487: IFFALSE 6600
6489: GO 6491
6491: DISABLE
6492: LD_INT 0
6494: PPUSH
6495: PPUSH
// begin enable ;
6496: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
6497: LD_ADDR_VAR 0 2
6501: PUSH
6502: LD_INT 22
6504: PUSH
6505: LD_INT 1
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: PUSH
6512: LD_INT 34
6514: PUSH
6515: LD_INT 51
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PUSH
6522: LD_INT 92
6524: PUSH
6525: LD_INT 63
6527: PUSH
6528: LD_INT 100
6530: PUSH
6531: LD_INT 5
6533: PUSH
6534: EMPTY
6535: LIST
6536: LIST
6537: LIST
6538: LIST
6539: PUSH
6540: EMPTY
6541: LIST
6542: LIST
6543: LIST
6544: PUSH
6545: EMPTY
6546: LIST
6547: PPUSH
6548: CALL_OW 69
6552: ST_TO_ADDR
// if not filter then
6553: LD_VAR 0 2
6557: NOT
6558: IFFALSE 6562
// exit ;
6560: GO 6600
// for i in filter do
6562: LD_ADDR_VAR 0 1
6566: PUSH
6567: LD_VAR 0 2
6571: PUSH
6572: FOR_IN
6573: IFFALSE 6598
// begin SetFuel ( i , 0 ) ;
6575: LD_VAR 0 1
6579: PPUSH
6580: LD_INT 0
6582: PPUSH
6583: CALL_OW 240
// ComStop ( i ) ;
6587: LD_VAR 0 1
6591: PPUSH
6592: CALL_OW 141
// end ;
6596: GO 6572
6598: POP
6599: POP
// end ;
6600: PPOPN 2
6602: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
6603: LD_EXP 25
6607: IFFALSE 7552
6609: GO 6611
6611: DISABLE
6612: LD_INT 0
6614: PPUSH
6615: PPUSH
6616: PPUSH
6617: PPUSH
6618: PPUSH
6619: PPUSH
6620: PPUSH
// begin if not ru_spec_patrol then
6621: LD_EXP 46
6625: NOT
6626: IFFALSE 6630
// exit ;
6628: GO 7552
// dead1 := false ;
6630: LD_ADDR_VAR 0 1
6634: PUSH
6635: LD_INT 0
6637: ST_TO_ADDR
// dead2 := false ;
6638: LD_ADDR_VAR 0 2
6642: PUSH
6643: LD_INT 0
6645: ST_TO_ADDR
// inarea1 := false ;
6646: LD_ADDR_VAR 0 3
6650: PUSH
6651: LD_INT 0
6653: ST_TO_ADDR
// inarea2 := false ;
6654: LD_ADDR_VAR 0 4
6658: PUSH
6659: LD_INT 0
6661: ST_TO_ADDR
// tmp := [ ] ;
6662: LD_ADDR_VAR 0 6
6666: PUSH
6667: EMPTY
6668: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
6669: LD_EXP 46
6673: PPUSH
6674: LD_INT 75
6676: PPUSH
6677: LD_INT 101
6679: PPUSH
6680: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
6684: LD_INT 35
6686: PPUSH
6687: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
6691: LD_INT 1
6693: PPUSH
6694: LD_EXP 46
6698: PUSH
6699: LD_INT 1
6701: ARRAY
6702: PPUSH
6703: CALL_OW 292
6707: IFFALSE 6684
// ComStop ( ru_spec_patrol ) ;
6709: LD_EXP 46
6713: PPUSH
6714: CALL_OW 141
// Wait ( 0 0$02 ) ;
6718: LD_INT 70
6720: PPUSH
6721: CALL_OW 67
// DialogueOn ;
6725: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
6729: LD_EXP 46
6733: PUSH
6734: LD_INT 1
6736: ARRAY
6737: PPUSH
6738: LD_STRING D8-Rus1-1
6740: PPUSH
6741: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
6745: LD_EXP 29
6749: PPUSH
6750: LD_STRING D8-JMM-1
6752: PPUSH
6753: CALL_OW 88
// DialogueOff ;
6757: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
6761: LD_EXP 46
6765: PPUSH
6766: LD_INT 13
6768: PPUSH
6769: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
6773: LD_INT 35
6775: PPUSH
6776: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
6780: LD_VAR 0 1
6784: NOT
6785: PUSH
6786: LD_EXP 46
6790: PUSH
6791: LD_INT 1
6793: ARRAY
6794: PPUSH
6795: CALL_OW 301
6799: AND
6800: IFFALSE 6810
// dead1 := true ;
6802: LD_ADDR_VAR 0 1
6806: PUSH
6807: LD_INT 1
6809: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
6810: LD_VAR 0 2
6814: NOT
6815: PUSH
6816: LD_EXP 46
6820: PUSH
6821: LD_INT 2
6823: ARRAY
6824: PPUSH
6825: CALL_OW 301
6829: AND
6830: IFFALSE 6840
// dead2 := true ;
6832: LD_ADDR_VAR 0 2
6836: PUSH
6837: LD_INT 1
6839: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
6840: LD_VAR 0 3
6844: NOT
6845: PUSH
6846: LD_EXP 46
6850: PUSH
6851: LD_INT 1
6853: ARRAY
6854: PPUSH
6855: LD_INT 14
6857: PPUSH
6858: CALL_OW 308
6862: AND
6863: IFFALSE 6873
// inarea1 := true ;
6865: LD_ADDR_VAR 0 3
6869: PUSH
6870: LD_INT 1
6872: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
6873: LD_VAR 0 4
6877: NOT
6878: PUSH
6879: LD_EXP 46
6883: PUSH
6884: LD_INT 2
6886: ARRAY
6887: PPUSH
6888: LD_INT 14
6890: PPUSH
6891: CALL_OW 308
6895: AND
6896: IFFALSE 6906
// inarea2 := true ;
6898: LD_ADDR_VAR 0 4
6902: PUSH
6903: LD_INT 1
6905: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
6906: LD_VAR 0 1
6910: PUSH
6911: LD_VAR 0 2
6915: AND
6916: PUSH
6917: LD_VAR 0 1
6921: PUSH
6922: LD_VAR 0 4
6926: AND
6927: OR
6928: PUSH
6929: LD_VAR 0 2
6933: PUSH
6934: LD_VAR 0 3
6938: AND
6939: OR
6940: PUSH
6941: LD_VAR 0 3
6945: PUSH
6946: LD_VAR 0 4
6950: AND
6951: OR
6952: IFFALSE 6773
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
6954: LD_VAR 0 3
6958: PUSH
6959: LD_VAR 0 4
6963: AND
6964: PUSH
6965: LD_VAR 0 1
6969: PUSH
6970: LD_VAR 0 4
6974: AND
6975: OR
6976: PUSH
6977: LD_VAR 0 2
6981: PUSH
6982: LD_VAR 0 3
6986: AND
6987: OR
6988: IFFALSE 7532
// begin prepare_siege := true ;
6990: LD_ADDR_EXP 26
6994: PUSH
6995: LD_INT 1
6997: ST_TO_ADDR
// DialogueOn ;
6998: CALL_OW 6
// if ( inarea1 and inarea2 ) then
7002: LD_VAR 0 3
7006: PUSH
7007: LD_VAR 0 4
7011: AND
7012: IFFALSE 7028
// Say ( JMM , D8b-JMM-1a ) else
7014: LD_EXP 29
7018: PPUSH
7019: LD_STRING D8b-JMM-1a
7021: PPUSH
7022: CALL_OW 88
7026: GO 7040
// Say ( JMM , D8b-JMM-1 ) ;
7028: LD_EXP 29
7032: PPUSH
7033: LD_STRING D8b-JMM-1
7035: PPUSH
7036: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
7040: LD_EXP 2
7044: PPUSH
7045: LD_INT 26
7047: PUSH
7048: LD_INT 1
7050: PUSH
7051: EMPTY
7052: LIST
7053: LIST
7054: PPUSH
7055: CALL_OW 72
7059: PUSH
7060: LD_EXP 30
7064: PUSH
7065: LD_EXP 31
7069: PUSH
7070: LD_EXP 40
7074: PUSH
7075: LD_EXP 43
7079: PUSH
7080: EMPTY
7081: LIST
7082: LIST
7083: LIST
7084: LIST
7085: DIFF
7086: PPUSH
7087: LD_STRING D8b-Sol1-1
7089: PPUSH
7090: CALL 571 0 2
// if Cyrus and Cyrus in jmm_units then
7094: LD_EXP 31
7098: PUSH
7099: LD_EXP 31
7103: PUSH
7104: LD_EXP 2
7108: IN
7109: AND
7110: IFFALSE 7126
// Say ( Cyrus , D8b-Cyrus-1 ) else
7112: LD_EXP 31
7116: PPUSH
7117: LD_STRING D8b-Cyrus-1
7119: PPUSH
7120: CALL_OW 88
7124: GO 7138
// Say ( JMM , D8b-JMM-1a ) ;
7126: LD_EXP 29
7130: PPUSH
7131: LD_STRING D8b-JMM-1a
7133: PPUSH
7134: CALL_OW 88
// if Lisa and Lisa in jmm_units then
7138: LD_EXP 32
7142: PUSH
7143: LD_EXP 32
7147: PUSH
7148: LD_EXP 2
7152: IN
7153: AND
7154: IFFALSE 7168
// Say ( Lisa , D8b-Lisa-2 ) ;
7156: LD_EXP 32
7160: PPUSH
7161: LD_STRING D8b-Lisa-2
7163: PPUSH
7164: CALL_OW 88
// if Bobby and Bobby in jmm_units then
7168: LD_EXP 30
7172: PUSH
7173: LD_EXP 30
7177: PUSH
7178: LD_EXP 2
7182: IN
7183: AND
7184: IFFALSE 7200
// Say ( Bobby , D8b-Bobby-1 ) else
7186: LD_EXP 30
7190: PPUSH
7191: LD_STRING D8b-Bobby-1
7193: PPUSH
7194: CALL_OW 88
7198: GO 7260
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
7200: LD_ADDR_VAR 0 5
7204: PUSH
7205: LD_EXP 2
7209: PPUSH
7210: LD_INT 26
7212: PUSH
7213: LD_INT 1
7215: PUSH
7216: EMPTY
7217: LIST
7218: LIST
7219: PPUSH
7220: CALL_OW 72
7224: PUSH
7225: LD_EXP 30
7229: PUSH
7230: LD_EXP 31
7234: PUSH
7235: LD_EXP 40
7239: PUSH
7240: LD_EXP 43
7244: PUSH
7245: EMPTY
7246: LIST
7247: LIST
7248: LIST
7249: LIST
7250: DIFF
7251: PPUSH
7252: LD_STRING D8b-Sol2-1
7254: PPUSH
7255: CALL 571 0 2
7259: ST_TO_ADDR
// DialogueOff ;
7260: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
7264: LD_EXP 31
7268: PUSH
7269: LD_EXP 31
7273: PUSH
7274: LD_EXP 2
7278: IN
7279: AND
7280: IFFALSE 7305
// tmp := Insert ( tmp , 1 , Cyrus ) ;
7282: LD_ADDR_VAR 0 6
7286: PUSH
7287: LD_VAR 0 6
7291: PPUSH
7292: LD_INT 1
7294: PPUSH
7295: LD_EXP 31
7299: PPUSH
7300: CALL_OW 2
7304: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
7305: LD_EXP 30
7309: PUSH
7310: LD_EXP 30
7314: PUSH
7315: LD_EXP 2
7319: IN
7320: AND
7321: IFFALSE 7346
// tmp := Insert ( tmp , 1 , Bobby ) ;
7323: LD_ADDR_VAR 0 6
7327: PUSH
7328: LD_VAR 0 6
7332: PPUSH
7333: LD_INT 1
7335: PPUSH
7336: LD_EXP 30
7340: PPUSH
7341: CALL_OW 2
7345: ST_TO_ADDR
// if sol then
7346: LD_VAR 0 5
7350: IFFALSE 7375
// tmp := Insert ( tmp , 1 , sol ) ;
7352: LD_ADDR_VAR 0 6
7356: PUSH
7357: LD_VAR 0 6
7361: PPUSH
7362: LD_INT 1
7364: PPUSH
7365: LD_VAR 0 5
7369: PPUSH
7370: CALL_OW 2
7374: ST_TO_ADDR
// if tmp then
7375: LD_VAR 0 6
7379: IFFALSE 7491
// begin SetSide ( tmp , 8 ) ;
7381: LD_VAR 0 6
7385: PPUSH
7386: LD_INT 8
7388: PPUSH
7389: CALL_OW 235
// ComFree ( tmp ) ;
7393: LD_VAR 0 6
7397: PPUSH
7398: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
7402: LD_VAR 0 6
7406: PPUSH
7407: LD_INT 15
7409: PPUSH
7410: CALL_OW 173
// AddComHold ( tmp ) ;
7414: LD_VAR 0 6
7418: PPUSH
7419: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7423: LD_INT 35
7425: PPUSH
7426: CALL_OW 67
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
7430: LD_VAR 0 6
7434: PUSH
7435: LD_INT 1
7437: ARRAY
7438: PPUSH
7439: LD_INT 15
7441: PPUSH
7442: CALL_OW 308
7446: IFFALSE 7481
// begin RemoveUnit ( tmp [ 1 ] ) ;
7448: LD_VAR 0 6
7452: PUSH
7453: LD_INT 1
7455: ARRAY
7456: PPUSH
7457: CALL_OW 64
// tmp := tmp diff tmp [ 1 ] ;
7461: LD_ADDR_VAR 0 6
7465: PUSH
7466: LD_VAR 0 6
7470: PUSH
7471: LD_VAR 0 6
7475: PUSH
7476: LD_INT 1
7478: ARRAY
7479: DIFF
7480: ST_TO_ADDR
// end ; until tmp = 0 ;
7481: LD_VAR 0 6
7485: PUSH
7486: LD_INT 0
7488: EQUAL
7489: IFFALSE 7423
// end ; Wait ( 0 0$30 ) ;
7491: LD_INT 1050
7493: PPUSH
7494: CALL_OW 67
// if ru_spec_patrol then
7498: LD_EXP 46
7502: IFFALSE 7530
// for i in ru_spec_patrol do
7504: LD_ADDR_VAR 0 7
7508: PUSH
7509: LD_EXP 46
7513: PUSH
7514: FOR_IN
7515: IFFALSE 7528
// RemoveUnit ( i ) ;
7517: LD_VAR 0 7
7521: PPUSH
7522: CALL_OW 64
7526: GO 7514
7528: POP
7529: POP
// end else
7530: GO 7552
// begin prepare_siege := false ;
7532: LD_ADDR_EXP 26
7536: PUSH
7537: LD_INT 0
7539: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
7540: LD_EXP 29
7544: PPUSH
7545: LD_STRING D8a-JMM-1
7547: PPUSH
7548: CALL_OW 88
// end ; end ;
7552: PPOPN 7
7554: END
// every 0 0$10 trigger frank_can_return do var i , points ;
7555: LD_EXP 10
7559: IFFALSE 8685
7561: GO 7563
7563: DISABLE
7564: LD_INT 0
7566: PPUSH
7567: PPUSH
// begin uc_side := 8 ;
7568: LD_ADDR_OWVAR 20
7572: PUSH
7573: LD_INT 8
7575: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
7576: LD_ADDR_VAR 0 2
7580: PUSH
7581: LD_INT 59
7583: PUSH
7584: LD_INT 71
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: PUSH
7591: LD_INT 122
7593: PUSH
7594: LD_INT 117
7596: PUSH
7597: EMPTY
7598: LIST
7599: LIST
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
7605: LD_ADDR_EXP 43
7609: PUSH
7610: LD_STRING Frank
7612: PPUSH
7613: LD_INT 0
7615: PPUSH
7616: CALL 417 0 2
7620: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
7621: LD_ADDR_VAR 0 1
7625: PUSH
7626: LD_INT 1
7628: PPUSH
7629: LD_INT 2
7631: PPUSH
7632: CALL_OW 12
7636: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
7637: LD_EXP 43
7641: PPUSH
7642: LD_VAR 0 2
7646: PUSH
7647: LD_VAR 0 1
7651: ARRAY
7652: PUSH
7653: LD_INT 1
7655: ARRAY
7656: PPUSH
7657: LD_VAR 0 2
7661: PUSH
7662: LD_VAR 0 1
7666: ARRAY
7667: PUSH
7668: LD_INT 2
7670: ARRAY
7671: PPUSH
7672: LD_INT 0
7674: PPUSH
7675: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
7679: LD_EXP 43
7683: PPUSH
7684: LD_INT 1
7686: PPUSH
7687: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
7691: LD_INT 35
7693: PPUSH
7694: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
7698: LD_EXP 43
7702: PPUSH
7703: LD_EXP 29
7707: PPUSH
7708: CALL_OW 296
7712: PUSH
7713: LD_INT 8
7715: LESS
7716: IFFALSE 7691
// InGameOn ;
7718: CALL_OW 8
// CenterOnUnits ( JMM ) ;
7722: LD_EXP 29
7726: PPUSH
7727: CALL_OW 85
// if IsInUnit ( JMM ) then
7731: LD_EXP 29
7735: PPUSH
7736: CALL_OW 310
7740: IFFALSE 7751
// ComFree ( JMM ) ;
7742: LD_EXP 29
7746: PPUSH
7747: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
7751: LD_EXP 29
7755: PPUSH
7756: LD_EXP 43
7760: PPUSH
7761: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
7765: LD_EXP 43
7769: PPUSH
7770: LD_EXP 29
7774: PPUSH
7775: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
7779: LD_EXP 29
7783: PPUSH
7784: LD_STRING D6-JMM-1
7786: PPUSH
7787: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
7791: LD_INT 35
7793: PPUSH
7794: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
7798: LD_EXP 29
7802: PPUSH
7803: LD_EXP 43
7807: PPUSH
7808: CALL_OW 296
7812: PUSH
7813: LD_INT 8
7815: LESS
7816: IFFALSE 7791
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
7818: LD_EXP 32
7822: PUSH
7823: LD_EXP 32
7827: PPUSH
7828: LD_EXP 43
7832: PPUSH
7833: CALL_OW 296
7837: PUSH
7838: LD_INT 20
7840: LESS
7841: AND
7842: IFFALSE 7867
// begin ComFree ( Lisa ) ;
7844: LD_EXP 32
7848: PPUSH
7849: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
7853: LD_EXP 32
7857: PPUSH
7858: LD_EXP 43
7862: PPUSH
7863: CALL_OW 172
// end ; if Lynch then
7867: LD_EXP 39
7871: IFFALSE 7896
// begin ComFree ( Lynch ) ;
7873: LD_EXP 39
7877: PPUSH
7878: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
7882: LD_EXP 39
7886: PPUSH
7887: LD_EXP 43
7891: PPUSH
7892: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
7896: LD_EXP 29
7900: PPUSH
7901: LD_EXP 43
7905: PPUSH
7906: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
7910: LD_EXP 43
7914: PPUSH
7915: LD_EXP 29
7919: PPUSH
7920: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
7924: LD_EXP 43
7928: PPUSH
7929: LD_STRING D6-Frank-1
7931: PPUSH
7932: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
7936: LD_INT 69
7938: PPUSH
7939: LD_INT 20
7941: PPUSH
7942: LD_INT 1
7944: PPUSH
7945: LD_INT 20
7947: NEG
7948: PPUSH
7949: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
7953: LD_INT 69
7955: PPUSH
7956: LD_INT 20
7958: PPUSH
7959: LD_INT 1
7961: PPUSH
7962: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
7966: LD_INT 190
7968: PPUSH
7969: LD_INT 31
7971: PPUSH
7972: LD_INT 1
7974: PPUSH
7975: LD_INT 20
7977: NEG
7978: PPUSH
7979: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
7983: LD_INT 190
7985: PPUSH
7986: LD_INT 31
7988: PPUSH
7989: LD_INT 1
7991: PPUSH
7992: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
7996: LD_INT 69
7998: PPUSH
7999: LD_INT 20
8001: PPUSH
8002: CALL_OW 84
// Wait ( 0 0$02 ) ;
8006: LD_INT 70
8008: PPUSH
8009: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
8013: LD_EXP 29
8017: PPUSH
8018: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
8022: LD_EXP 32
8026: PUSH
8027: LD_EXP 32
8031: PPUSH
8032: LD_EXP 43
8036: PPUSH
8037: CALL_OW 296
8041: PUSH
8042: LD_INT 20
8044: LESS
8045: AND
8046: PUSH
8047: LD_EXP 32
8051: PPUSH
8052: CALL_OW 302
8056: AND
8057: IFFALSE 8147
// begin ComFree ( Lisa ) ;
8059: LD_EXP 32
8063: PPUSH
8064: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
8068: LD_INT 35
8070: PPUSH
8071: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
8075: LD_EXP 32
8079: PPUSH
8080: LD_EXP 43
8084: PPUSH
8085: CALL_OW 296
8089: PUSH
8090: LD_INT 7
8092: LESS
8093: IFFALSE 8068
// Say ( Lisa , D6-Lisa-1 ) ;
8095: LD_EXP 32
8099: PPUSH
8100: LD_STRING D6-Lisa-1
8102: PPUSH
8103: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
8107: LD_EXP 32
8111: PPUSH
8112: LD_EXP 43
8116: PPUSH
8117: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
8121: LD_EXP 43
8125: PPUSH
8126: LD_EXP 32
8130: PPUSH
8131: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
8135: LD_EXP 43
8139: PPUSH
8140: LD_STRING D6-Frank-2
8142: PPUSH
8143: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
8147: LD_EXP 39
8151: PUSH
8152: LD_EXP 39
8156: PPUSH
8157: LD_EXP 43
8161: PPUSH
8162: CALL_OW 296
8166: PUSH
8167: LD_INT 20
8169: LESS
8170: AND
8171: PUSH
8172: LD_EXP 39
8176: PPUSH
8177: CALL_OW 302
8181: AND
8182: IFFALSE 8363
// begin ComTurnUnit ( Lynch , JMM ) ;
8184: LD_EXP 39
8188: PPUSH
8189: LD_EXP 29
8193: PPUSH
8194: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
8198: LD_EXP 43
8202: PPUSH
8203: LD_EXP 29
8207: PPUSH
8208: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
8212: LD_EXP 39
8216: PPUSH
8217: LD_STRING D6-Sol1-2
8219: PPUSH
8220: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
8224: LD_EXP 29
8228: PPUSH
8229: LD_STRING D6-JMM-2
8231: PPUSH
8232: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
8236: LD_EXP 43
8240: PPUSH
8241: LD_STRING D6-Frank-3
8243: PPUSH
8244: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
8248: LD_EXP 29
8252: PPUSH
8253: LD_STRING D6-JMM-3
8255: PPUSH
8256: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
8260: LD_EXP 43
8264: PPUSH
8265: LD_STRING D6-Frank-4
8267: PPUSH
8268: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
8272: LD_EXP 43
8276: PPUSH
8277: LD_STRING D6-Frank-4a
8279: PPUSH
8280: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
8284: LD_EXP 29
8288: PPUSH
8289: LD_STRING D6-JMM-4
8291: PPUSH
8292: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
8296: LD_EXP 43
8300: PPUSH
8301: LD_STRING D6-Frank-5
8303: PPUSH
8304: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
8308: LD_EXP 32
8312: PUSH
8313: LD_EXP 32
8317: PPUSH
8318: CALL_OW 302
8322: AND
8323: IFFALSE 8337
// Say ( Lisa , D6-Lisa-5 ) ;
8325: LD_EXP 32
8329: PPUSH
8330: LD_STRING D6-Lisa-5
8332: PPUSH
8333: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
8337: LD_EXP 43
8341: PPUSH
8342: LD_STRING D6-Frank-6
8344: PPUSH
8345: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
8349: LD_EXP 29
8353: PPUSH
8354: LD_STRING D6-JMM-6
8356: PPUSH
8357: CALL_OW 88
// end else
8361: GO 8478
// begin ComTurnUnit ( Frank , JMM ) ;
8363: LD_EXP 43
8367: PPUSH
8368: LD_EXP 29
8372: PPUSH
8373: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
8377: LD_EXP 43
8381: PPUSH
8382: LD_STRING D6-Frank-4
8384: PPUSH
8385: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
8389: LD_EXP 43
8393: PPUSH
8394: LD_STRING D6-Frank-4a
8396: PPUSH
8397: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
8401: LD_EXP 29
8405: PPUSH
8406: LD_STRING D6-JMM-4
8408: PPUSH
8409: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
8413: LD_EXP 43
8417: PPUSH
8418: LD_STRING D6-Frank-5
8420: PPUSH
8421: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
8425: LD_EXP 32
8429: PUSH
8430: LD_EXP 32
8434: PPUSH
8435: CALL_OW 302
8439: AND
8440: IFFALSE 8454
// Say ( Lisa , D6-Lisa-5 ) ;
8442: LD_EXP 32
8446: PPUSH
8447: LD_STRING D6-Lisa-5
8449: PPUSH
8450: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
8454: LD_EXP 43
8458: PPUSH
8459: LD_STRING D6-Frank-6
8461: PPUSH
8462: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
8466: LD_EXP 29
8470: PPUSH
8471: LD_STRING D6-JMM-6
8473: PPUSH
8474: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
8478: LD_STRING Q1
8480: PPUSH
8481: CALL_OW 97
8485: PUSH
8486: LD_INT 1
8488: DOUBLE
8489: EQUAL
8490: IFTRUE 8494
8492: GO 8505
8494: POP
// frank_send_to_scout := true ; 2 :
8495: LD_ADDR_EXP 12
8499: PUSH
8500: LD_INT 1
8502: ST_TO_ADDR
8503: GO 8525
8505: LD_INT 2
8507: DOUBLE
8508: EQUAL
8509: IFTRUE 8513
8511: GO 8524
8513: POP
// frank_send_to_scout := false ; end ;
8514: LD_ADDR_EXP 12
8518: PUSH
8519: LD_INT 0
8521: ST_TO_ADDR
8522: GO 8525
8524: POP
// InGameOff ;
8525: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
8529: LD_EXP 29
8533: PUSH
8534: LD_EXP 32
8538: PUSH
8539: LD_EXP 39
8543: PUSH
8544: EMPTY
8545: LIST
8546: LIST
8547: LIST
8548: PPUSH
8549: CALL_OW 139
// if frank_send_to_scout then
8553: LD_EXP 12
8557: IFFALSE 8614
// begin ComMoveXY ( Frank , 130 , 123 ) ;
8559: LD_EXP 43
8563: PPUSH
8564: LD_INT 130
8566: PPUSH
8567: LD_INT 123
8569: PPUSH
8570: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
8574: LD_INT 35
8576: PPUSH
8577: CALL_OW 67
// until not See ( 1 , Frank ) ;
8581: LD_INT 1
8583: PPUSH
8584: LD_EXP 43
8588: PPUSH
8589: CALL_OW 292
8593: NOT
8594: IFFALSE 8574
// Wait ( 0 0$02 ) ;
8596: LD_INT 70
8598: PPUSH
8599: CALL_OW 67
// RemoveUnit ( Frank ) ;
8603: LD_EXP 43
8607: PPUSH
8608: CALL_OW 64
// end else
8612: GO 8626
// SetSide ( Frank , 1 ) ;
8614: LD_EXP 43
8618: PPUSH
8619: LD_INT 1
8621: PPUSH
8622: CALL_OW 235
// repeat wait ( 0 0$01 ) ;
8626: LD_INT 35
8628: PPUSH
8629: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
8633: LD_ADDR_EXP 24
8637: PUSH
8638: LD_EXP 24
8642: PPUSH
8643: LD_STRING -
8645: PPUSH
8646: CALL 1063 0 2
8650: ST_TO_ADDR
// if debug then
8651: LD_EXP 1
8655: IFFALSE 8667
// debug_strings := time_to_prepare ;
8657: LD_ADDR_OWVAR 48
8661: PUSH
8662: LD_EXP 24
8666: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
8667: LD_EXP 24
8671: PUSH
8672: LD_INT 0
8674: EQUAL
8675: IFFALSE 8626
// cornel_prepared := true ;
8677: LD_ADDR_EXP 9
8681: PUSH
8682: LD_INT 1
8684: ST_TO_ADDR
// end ;
8685: PPOPN 2
8687: END
// every 0 0$01 trigger cornel_prepared do
8688: LD_EXP 9
8692: IFFALSE 8918
8694: GO 8696
8696: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
8697: LD_EXP 36
8701: PPUSH
8702: LD_STRING D3-Corn-1
8704: PPUSH
8705: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
8709: LD_INT 35
8711: PPUSH
8712: CALL_OW 67
// until cornel_counter = 0 ;
8716: LD_EXP 8
8720: PUSH
8721: LD_INT 0
8723: EQUAL
8724: IFFALSE 8709
// SayRadio ( Cornel , D3a-Corn-1 ) ;
8726: LD_EXP 36
8730: PPUSH
8731: LD_STRING D3a-Corn-1
8733: PPUSH
8734: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
8738: LD_EXP 29
8742: PPUSH
8743: LD_STRING D3a-JMM-1
8745: PPUSH
8746: CALL_OW 88
// end_mission_allowed := true ;
8750: LD_ADDR_EXP 18
8754: PUSH
8755: LD_INT 1
8757: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
8758: LD_STRING M2
8760: PPUSH
8761: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
8765: LD_INT 9
8767: PPUSH
8768: LD_INT 1
8770: PPUSH
8771: CALL_OW 424
// Wait ( 0 0$05 ) ;
8775: LD_INT 175
8777: PPUSH
8778: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
8782: LD_EXP 36
8786: PPUSH
8787: LD_STRING D3a-Corn-2
8789: PPUSH
8790: CALL_OW 94
// cornel_attack := true ;
8794: LD_ADDR_EXP 7
8798: PUSH
8799: LD_INT 1
8801: ST_TO_ADDR
// if frank_send_to_scout then
8802: LD_EXP 12
8806: IFFALSE 8918
// begin InitHc ;
8808: CALL_OW 19
// InitUc ;
8812: CALL_OW 18
// uc_side := 8 ;
8816: LD_ADDR_OWVAR 20
8820: PUSH
8821: LD_INT 8
8823: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
8824: LD_ADDR_EXP 43
8828: PUSH
8829: LD_STRING Frank
8831: PPUSH
8832: LD_INT 0
8834: PPUSH
8835: CALL 417 0 2
8839: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
8840: LD_EXP 43
8844: PPUSH
8845: LD_INT 6
8847: PPUSH
8848: LD_INT 9
8850: PPUSH
8851: LD_INT 0
8853: PPUSH
8854: CALL_OW 48
// ComCrawl ( Frank ) ;
8858: LD_EXP 43
8862: PPUSH
8863: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
8867: LD_INT 35
8869: PPUSH
8870: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
8874: LD_EXP 29
8878: PPUSH
8879: LD_EXP 43
8883: PPUSH
8884: CALL_OW 296
8888: PUSH
8889: LD_INT 9
8891: LESS
8892: IFFALSE 8867
// SetSide ( Frank , 1 ) ;
8894: LD_EXP 43
8898: PPUSH
8899: LD_INT 1
8901: PPUSH
8902: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
8906: LD_EXP 43
8910: PPUSH
8911: LD_STRING D6a-Frank-1
8913: PPUSH
8914: CALL_OW 88
// end ; end ;
8918: END
// every 0 0$01 trigger solar_builded do
8919: LD_EXP 11
8923: IFFALSE 9027
8925: GO 8927
8927: DISABLE
// begin Wait ( 0 0$02 ) ;
8928: LD_INT 70
8930: PPUSH
8931: CALL_OW 67
// DialogueOn ;
8935: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
8939: LD_EXP 29
8943: PPUSH
8944: LD_STRING D2b-JMM-1
8946: PPUSH
8947: CALL_OW 88
// if Walker and IsOk ( Walker ) then
8951: LD_EXP 40
8955: PUSH
8956: LD_EXP 40
8960: PPUSH
8961: CALL_OW 302
8965: AND
8966: IFFALSE 9016
// begin Say ( Walker , D2b-Sci1-1 ) ;
8968: LD_EXP 40
8972: PPUSH
8973: LD_STRING D2b-Sci1-1
8975: PPUSH
8976: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
8980: LD_EXP 29
8984: PPUSH
8985: LD_STRING D2b-JMM-2
8987: PPUSH
8988: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
8992: LD_EXP 40
8996: PPUSH
8997: LD_STRING D2b-Sci1-2
8999: PPUSH
9000: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
9004: LD_EXP 29
9008: PPUSH
9009: LD_STRING D2b-JMM-3
9011: PPUSH
9012: CALL_OW 88
// end ; DialogueOff ;
9016: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
9020: LD_STRING MOutSol
9022: PPUSH
9023: CALL_OW 337
// end ;
9027: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
9028: LD_EXP 11
9032: PUSH
9033: LD_EXP 29
9037: PPUSH
9038: CALL_OW 302
9042: AND
9043: PUSH
9044: LD_EXP 29
9048: PPUSH
9049: CALL 897 0 1
9053: AND
9054: PUSH
9055: LD_EXP 13
9059: NOT
9060: AND
9061: IFFALSE 9132
9063: GO 9065
9065: DISABLE
9066: LD_INT 0
9068: PPUSH
// begin jmm_in_veh := true ;
9069: LD_ADDR_EXP 13
9073: PUSH
9074: LD_INT 1
9076: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
9077: LD_ADDR_VAR 0 1
9081: PUSH
9082: LD_INT 0
9084: PPUSH
9085: LD_INT 1
9087: PPUSH
9088: CALL_OW 12
9092: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
9093: LD_INT 70
9095: PPUSH
9096: CALL_OW 67
// if i then
9100: LD_VAR 0 1
9104: IFFALSE 9120
// Say ( JMM , D2c-JMM-1 ) else
9106: LD_EXP 29
9110: PPUSH
9111: LD_STRING D2c-JMM-1
9113: PPUSH
9114: CALL_OW 88
9118: GO 9132
// Say ( JMM , D2c-JMM-1a ) ;
9120: LD_EXP 29
9124: PPUSH
9125: LD_STRING D2c-JMM-1a
9127: PPUSH
9128: CALL_OW 88
// end ;
9132: PPOPN 1
9134: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
9135: LD_EXP 11
9139: PUSH
9140: LD_EXP 30
9144: PPUSH
9145: CALL_OW 302
9149: AND
9150: PUSH
9151: LD_EXP 30
9155: PPUSH
9156: CALL 897 0 1
9160: AND
9161: PUSH
9162: LD_EXP 14
9166: NOT
9167: AND
9168: IFFALSE 9200
9170: GO 9172
9172: DISABLE
// begin bobby_in_veh := true ;
9173: LD_ADDR_EXP 14
9177: PUSH
9178: LD_INT 1
9180: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
9181: LD_INT 70
9183: PPUSH
9184: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
9188: LD_EXP 30
9192: PPUSH
9193: LD_STRING D2c-Bobby-1
9195: PPUSH
9196: CALL_OW 88
9200: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
9201: LD_EXP 11
9205: PUSH
9206: LD_EXP 32
9210: PPUSH
9211: CALL_OW 302
9215: AND
9216: PUSH
9217: LD_EXP 32
9221: PPUSH
9222: CALL 897 0 1
9226: AND
9227: PUSH
9228: LD_EXP 16
9232: NOT
9233: AND
9234: IFFALSE 9266
9236: GO 9238
9238: DISABLE
// begin lisa_in_veh := true ;
9239: LD_ADDR_EXP 16
9243: PUSH
9244: LD_INT 1
9246: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
9247: LD_INT 70
9249: PPUSH
9250: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
9254: LD_EXP 32
9258: PPUSH
9259: LD_STRING D2c-Lisa-1
9261: PPUSH
9262: CALL_OW 88
9266: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
9267: LD_EXP 11
9271: PUSH
9272: LD_EXP 31
9276: PPUSH
9277: CALL_OW 302
9281: AND
9282: PUSH
9283: LD_EXP 31
9287: PPUSH
9288: CALL 897 0 1
9292: AND
9293: PUSH
9294: LD_EXP 15
9298: NOT
9299: AND
9300: IFFALSE 9371
9302: GO 9304
9304: DISABLE
9305: LD_INT 0
9307: PPUSH
// begin cyrus_in_veh := true ;
9308: LD_ADDR_EXP 15
9312: PUSH
9313: LD_INT 1
9315: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
9316: LD_ADDR_VAR 0 1
9320: PUSH
9321: LD_INT 0
9323: PPUSH
9324: LD_INT 1
9326: PPUSH
9327: CALL_OW 12
9331: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
9332: LD_INT 70
9334: PPUSH
9335: CALL_OW 67
// if i then
9339: LD_VAR 0 1
9343: IFFALSE 9359
// Say ( Cyrus , D2c-Cyrus-1 ) else
9345: LD_EXP 31
9349: PPUSH
9350: LD_STRING D2c-Cyrus-1
9352: PPUSH
9353: CALL_OW 88
9357: GO 9371
// Say ( Cyrus , D2c-Cyrus-1a ) ;
9359: LD_EXP 31
9363: PPUSH
9364: LD_STRING D2c-Cyrus-1a
9366: PPUSH
9367: CALL_OW 88
// end ;
9371: PPOPN 1
9373: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
9374: LD_EXP 36
9378: PPUSH
9379: LD_INT 16
9381: PPUSH
9382: CALL_OW 308
9386: IFFALSE 9628
9388: GO 9390
9390: DISABLE
9391: LD_INT 0
9393: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
9394: LD_INT 3
9396: PPUSH
9397: LD_EXP 36
9401: PPUSH
9402: CALL_OW 471
// send_attack_on_cornel := true ;
9406: LD_ADDR_EXP 27
9410: PUSH
9411: LD_INT 1
9413: ST_TO_ADDR
// if ru_vehicles then
9414: LD_EXP 48
9418: IFFALSE 9452
// for i in ru_vehicles do
9420: LD_ADDR_VAR 0 1
9424: PUSH
9425: LD_EXP 48
9429: PUSH
9430: FOR_IN
9431: IFFALSE 9450
// ComAgressiveMove ( i , 215 , 69 ) ;
9433: LD_VAR 0 1
9437: PPUSH
9438: LD_INT 215
9440: PPUSH
9441: LD_INT 69
9443: PPUSH
9444: CALL_OW 114
9448: GO 9430
9450: POP
9451: POP
// if ru_patrol then
9452: LD_EXP 45
9456: IFFALSE 9490
// for i in ru_patrol do
9458: LD_ADDR_VAR 0 1
9462: PUSH
9463: LD_EXP 45
9467: PUSH
9468: FOR_IN
9469: IFFALSE 9488
// ComAgressiveMove ( i , 215 , 69 ) ;
9471: LD_VAR 0 1
9475: PPUSH
9476: LD_INT 215
9478: PPUSH
9479: LD_INT 69
9481: PPUSH
9482: CALL_OW 114
9486: GO 9468
9488: POP
9489: POP
// if frank_send_to_scout then
9490: LD_EXP 12
9494: IFFALSE 9508
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
9496: LD_EXP 43
9500: PPUSH
9501: LD_STRING D3b-Frank-1
9503: PPUSH
9504: CALL_OW 94
// end ; Wait ( 0 0$04 ) ;
9508: LD_INT 140
9510: PPUSH
9511: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
9515: LD_EXP 36
9519: PPUSH
9520: LD_STRING D4-Corn-1
9522: PPUSH
9523: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
9527: LD_INT 35
9529: PPUSH
9530: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 5 ;
9534: LD_INT 22
9536: PUSH
9537: LD_INT 4
9539: PUSH
9540: EMPTY
9541: LIST
9542: LIST
9543: PUSH
9544: LD_INT 21
9546: PUSH
9547: LD_INT 1
9549: PUSH
9550: EMPTY
9551: LIST
9552: LIST
9553: PUSH
9554: LD_INT 50
9556: PUSH
9557: EMPTY
9558: LIST
9559: PUSH
9560: EMPTY
9561: LIST
9562: LIST
9563: LIST
9564: PPUSH
9565: CALL_OW 69
9569: PUSH
9570: LD_INT 5
9572: LESS
9573: IFFALSE 9527
// SayRadio ( Cornel , D5-Corn-1 ) ;
9575: LD_EXP 36
9579: PPUSH
9580: LD_STRING D5-Corn-1
9582: PPUSH
9583: CALL_OW 94
// SaveCharacters ( Cornel , Cornel ) ;
9587: LD_EXP 36
9591: PPUSH
9592: LD_STRING Cornel
9594: PPUSH
9595: CALL_OW 38
// ChangeSideFog ( 4 , 8 ) ;
9599: LD_INT 4
9601: PPUSH
9602: LD_INT 8
9604: PPUSH
9605: CALL_OW 343
// Wait ( 0 0$01 ) ;
9609: LD_INT 35
9611: PPUSH
9612: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
9616: LD_INT 3
9618: PPUSH
9619: LD_EXP 36
9623: PPUSH
9624: CALL_OW 472
// end ;
9628: PPOPN 1
9630: END
// every 0 0$02 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
9631: LD_INT 9
9633: PPUSH
9634: LD_INT 22
9636: PUSH
9637: LD_INT 1
9639: PUSH
9640: EMPTY
9641: LIST
9642: LIST
9643: PPUSH
9644: CALL_OW 70
9648: PUSH
9649: LD_EXP 28
9653: OR
9654: IFFALSE 10395
9656: GO 9658
9658: DISABLE
9659: LD_INT 0
9661: PPUSH
9662: PPUSH
// begin enable ;
9663: ENABLE
// if not game_end then
9664: LD_EXP 28
9668: NOT
9669: IFFALSE 9679
// game_end := true ;
9671: LD_ADDR_EXP 28
9675: PUSH
9676: LD_INT 1
9678: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
9679: LD_ADDR_VAR 0 2
9683: PUSH
9684: LD_INT 9
9686: PPUSH
9687: LD_INT 22
9689: PUSH
9690: LD_INT 1
9692: PUSH
9693: EMPTY
9694: LIST
9695: LIST
9696: PPUSH
9697: CALL_OW 70
9701: ST_TO_ADDR
// if not filter then
9702: LD_VAR 0 2
9706: NOT
9707: IFFALSE 9711
// exit ;
9709: GO 10395
// for i in filter do
9711: LD_ADDR_VAR 0 1
9715: PUSH
9716: LD_VAR 0 2
9720: PUSH
9721: FOR_IN
9722: IFFALSE 10393
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
9724: LD_VAR 0 1
9728: PPUSH
9729: CALL_OW 302
9733: PUSH
9734: LD_VAR 0 1
9738: PPUSH
9739: CALL_OW 247
9743: PUSH
9744: LD_INT 2
9746: EQUAL
9747: AND
9748: IFFALSE 9788
// begin veh_on_meta := true ;
9750: LD_ADDR_EXP 23
9754: PUSH
9755: LD_INT 1
9757: ST_TO_ADDR
// ComExitVehicle ( IsInUnit ( i ) ) ;
9758: LD_VAR 0 1
9762: PPUSH
9763: CALL_OW 310
9767: PPUSH
9768: CALL_OW 121
// RemoveUnit ( i ) ;
9772: LD_VAR 0 1
9776: PPUSH
9777: CALL_OW 64
// Wait ( 10 ) ;
9781: LD_INT 10
9783: PPUSH
9784: CALL_OW 67
// end ; if i = JMM then
9788: LD_VAR 0 1
9792: PUSH
9793: LD_EXP 29
9797: EQUAL
9798: IFFALSE 9920
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
9800: LD_EXP 21
9804: PUSH
9805: LD_INT 22
9807: PUSH
9808: LD_INT 1
9810: PUSH
9811: EMPTY
9812: LIST
9813: LIST
9814: PUSH
9815: LD_INT 21
9817: PUSH
9818: LD_INT 1
9820: PUSH
9821: EMPTY
9822: LIST
9823: LIST
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: PPUSH
9829: CALL_OW 69
9833: PUSH
9834: LD_INT 1
9836: GREATER
9837: AND
9838: IFFALSE 9895
// begin show_query := false ;
9840: LD_ADDR_EXP 21
9844: PUSH
9845: LD_INT 0
9847: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
9848: LD_STRING Q2
9850: PPUSH
9851: CALL_OW 97
9855: PUSH
9856: LD_INT 1
9858: DOUBLE
9859: EQUAL
9860: IFTRUE 9864
9862: GO 9875
9864: POP
// wait_for_them := true ; 2 :
9865: LD_ADDR_EXP 22
9869: PUSH
9870: LD_INT 1
9872: ST_TO_ADDR
9873: GO 9895
9875: LD_INT 2
9877: DOUBLE
9878: EQUAL
9879: IFTRUE 9883
9881: GO 9894
9883: POP
// wait_for_them := false ; end ;
9884: LD_ADDR_EXP 22
9888: PUSH
9889: LD_INT 0
9891: ST_TO_ADDR
9892: GO 9895
9894: POP
// end ; save_group := save_group ^ JMM ;
9895: LD_ADDR_EXP 20
9899: PUSH
9900: LD_EXP 20
9904: PUSH
9905: LD_EXP 29
9909: ADD
9910: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
9911: LD_EXP 29
9915: PPUSH
9916: CALL_OW 64
// end ; if i = Lisa then
9920: LD_VAR 0 1
9924: PUSH
9925: LD_EXP 32
9929: EQUAL
9930: IFFALSE 9957
// begin save_group := save_group ^ Lisa ;
9932: LD_ADDR_EXP 20
9936: PUSH
9937: LD_EXP 20
9941: PUSH
9942: LD_EXP 32
9946: ADD
9947: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
9948: LD_EXP 32
9952: PPUSH
9953: CALL_OW 64
// end ; if i = Bobby then
9957: LD_VAR 0 1
9961: PUSH
9962: LD_EXP 30
9966: EQUAL
9967: IFFALSE 9994
// begin save_group := save_group ^ Bobby ;
9969: LD_ADDR_EXP 20
9973: PUSH
9974: LD_EXP 20
9978: PUSH
9979: LD_EXP 30
9983: ADD
9984: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
9985: LD_EXP 30
9989: PPUSH
9990: CALL_OW 64
// end ; if i = Cyrus then
9994: LD_VAR 0 1
9998: PUSH
9999: LD_EXP 31
10003: EQUAL
10004: IFFALSE 10031
// begin save_group := save_group ^ Cyrus ;
10006: LD_ADDR_EXP 20
10010: PUSH
10011: LD_EXP 20
10015: PUSH
10016: LD_EXP 31
10020: ADD
10021: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
10022: LD_EXP 31
10026: PPUSH
10027: CALL_OW 64
// end ; if i = Khatam then
10031: LD_VAR 0 1
10035: PUSH
10036: LD_EXP 33
10040: EQUAL
10041: IFFALSE 10068
// begin save_group := save_group ^ Khatam ;
10043: LD_ADDR_EXP 20
10047: PUSH
10048: LD_EXP 20
10052: PUSH
10053: LD_EXP 33
10057: ADD
10058: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
10059: LD_EXP 33
10063: PPUSH
10064: CALL_OW 64
// end ; if i = Jerry then
10068: LD_VAR 0 1
10072: PUSH
10073: LD_EXP 35
10077: EQUAL
10078: IFFALSE 10105
// begin save_group := save_group ^ Jerry ;
10080: LD_ADDR_EXP 20
10084: PUSH
10085: LD_EXP 20
10089: PUSH
10090: LD_EXP 35
10094: ADD
10095: ST_TO_ADDR
// RemoveUnit ( Jerry ) ;
10096: LD_EXP 35
10100: PPUSH
10101: CALL_OW 64
// end ; if i = Brian then
10105: LD_VAR 0 1
10109: PUSH
10110: LD_EXP 34
10114: EQUAL
10115: IFFALSE 10142
// begin save_group := save_group ^ Brian ;
10117: LD_ADDR_EXP 20
10121: PUSH
10122: LD_EXP 20
10126: PUSH
10127: LD_EXP 34
10131: ADD
10132: ST_TO_ADDR
// RemoveUnit ( Brian ) ;
10133: LD_EXP 34
10137: PPUSH
10138: CALL_OW 64
// end ; if i = Lynch then
10142: LD_VAR 0 1
10146: PUSH
10147: LD_EXP 39
10151: EQUAL
10152: IFFALSE 10179
// begin save_group := save_group ^ Lynch ;
10154: LD_ADDR_EXP 20
10158: PUSH
10159: LD_EXP 20
10163: PUSH
10164: LD_EXP 39
10168: ADD
10169: ST_TO_ADDR
// RemoveUnit ( Lynch ) ;
10170: LD_EXP 39
10174: PPUSH
10175: CALL_OW 64
// end ; if i = Turner then
10179: LD_VAR 0 1
10183: PUSH
10184: LD_EXP 41
10188: EQUAL
10189: IFFALSE 10216
// begin save_group := save_group ^ Turner ;
10191: LD_ADDR_EXP 20
10195: PUSH
10196: LD_EXP 20
10200: PUSH
10201: LD_EXP 41
10205: ADD
10206: ST_TO_ADDR
// RemoveUnit ( Turner ) ;
10207: LD_EXP 41
10211: PPUSH
10212: CALL_OW 64
// end ; if i = Jillian then
10216: LD_VAR 0 1
10220: PUSH
10221: LD_EXP 42
10225: EQUAL
10226: IFFALSE 10253
// begin save_group := save_group ^ Jillian ;
10228: LD_ADDR_EXP 20
10232: PUSH
10233: LD_EXP 20
10237: PUSH
10238: LD_EXP 42
10242: ADD
10243: ST_TO_ADDR
// RemoveUnit ( Jillian ) ;
10244: LD_EXP 42
10248: PPUSH
10249: CALL_OW 64
// end ; if i = Walker then
10253: LD_VAR 0 1
10257: PUSH
10258: LD_EXP 40
10262: EQUAL
10263: IFFALSE 10290
// begin save_group := save_group ^ Walker ;
10265: LD_ADDR_EXP 20
10269: PUSH
10270: LD_EXP 20
10274: PUSH
10275: LD_EXP 40
10279: ADD
10280: ST_TO_ADDR
// RemoveUnit ( Walker ) ;
10281: LD_EXP 40
10285: PPUSH
10286: CALL_OW 64
// end ; if i = Frank then
10290: LD_VAR 0 1
10294: PUSH
10295: LD_EXP 43
10299: EQUAL
10300: IFFALSE 10327
// begin save_group := save_group ^ Frank ;
10302: LD_ADDR_EXP 20
10306: PUSH
10307: LD_EXP 20
10311: PUSH
10312: LD_EXP 43
10316: ADD
10317: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
10318: LD_EXP 43
10322: PPUSH
10323: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and not i in save_group then
10327: LD_VAR 0 1
10331: PPUSH
10332: CALL_OW 302
10336: PUSH
10337: LD_VAR 0 1
10341: PPUSH
10342: CALL_OW 247
10346: PUSH
10347: LD_INT 1
10349: EQUAL
10350: AND
10351: PUSH
10352: LD_VAR 0 1
10356: PUSH
10357: LD_EXP 20
10361: IN
10362: NOT
10363: AND
10364: IFFALSE 10391
// begin save_others := save_others ^ i ;
10366: LD_ADDR_EXP 19
10370: PUSH
10371: LD_EXP 19
10375: PUSH
10376: LD_VAR 0 1
10380: ADD
10381: ST_TO_ADDR
// RemoveUnit ( i ) ;
10382: LD_VAR 0 1
10386: PPUSH
10387: CALL_OW 64
// end ; end ;
10391: GO 9721
10393: POP
10394: POP
// end ;
10395: PPOPN 2
10397: END
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or ( wait_for_them and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 ) do
10398: LD_EXP 21
10402: NOT
10403: PUSH
10404: LD_EXP 22
10408: NOT
10409: AND
10410: PUSH
10411: LD_EXP 22
10415: PUSH
10416: LD_INT 22
10418: PUSH
10419: LD_INT 1
10421: PUSH
10422: EMPTY
10423: LIST
10424: LIST
10425: PUSH
10426: LD_INT 21
10428: PUSH
10429: LD_INT 1
10431: PUSH
10432: EMPTY
10433: LIST
10434: LIST
10435: PUSH
10436: EMPTY
10437: LIST
10438: LIST
10439: PPUSH
10440: CALL_OW 69
10444: PUSH
10445: LD_INT 0
10447: EQUAL
10448: AND
10449: OR
10450: IFFALSE 10459
10452: GO 10454
10454: DISABLE
// EndMission ;
10455: CALL 10460 0 0
10459: END
// export function EndMission ; var counter , i ; begin
10460: LD_INT 0
10462: PPUSH
10463: PPUSH
10464: PPUSH
// if solar_builded then
10465: LD_EXP 11
10469: IFFALSE 10483
// AddMedal ( Solar1 , 1 ) else
10471: LD_STRING Solar1
10473: PPUSH
10474: LD_INT 1
10476: PPUSH
10477: CALL_OW 101
10481: GO 10494
// AddMedal ( Solar1 , - 1 ) ;
10483: LD_STRING Solar1
10485: PPUSH
10486: LD_INT 1
10488: NEG
10489: PPUSH
10490: CALL_OW 101
// if veh_on_meta then
10494: LD_EXP 23
10498: IFFALSE 10512
// AddMedal ( Solar2 , 1 ) else
10500: LD_STRING Solar2
10502: PPUSH
10503: LD_INT 1
10505: PPUSH
10506: CALL_OW 101
10510: GO 10542
// if solar_builded then
10512: LD_EXP 11
10516: IFFALSE 10531
// AddMedal ( Solar2 , - 1 ) else
10518: LD_STRING Solar2
10520: PPUSH
10521: LD_INT 1
10523: NEG
10524: PPUSH
10525: CALL_OW 101
10529: GO 10542
// AddMedal ( Solar2 , - 2 ) ;
10531: LD_STRING Solar2
10533: PPUSH
10534: LD_INT 2
10536: NEG
10537: PPUSH
10538: CALL_OW 101
// counter := save_group + save_others ;
10542: LD_ADDR_VAR 0 2
10546: PUSH
10547: LD_EXP 20
10551: PUSH
10552: LD_EXP 19
10556: PLUS
10557: ST_TO_ADDR
// if counter = 10 then
10558: LD_VAR 0 2
10562: PUSH
10563: LD_INT 10
10565: EQUAL
10566: IFFALSE 10580
// AddMedal ( No , 1 ) else
10568: LD_STRING No
10570: PPUSH
10571: LD_INT 1
10573: PPUSH
10574: CALL_OW 101
10578: GO 10624
// if counter < 10 and counter > 6 then
10580: LD_VAR 0 2
10584: PUSH
10585: LD_INT 10
10587: LESS
10588: PUSH
10589: LD_VAR 0 2
10593: PUSH
10594: LD_INT 6
10596: GREATER
10597: AND
10598: IFFALSE 10613
// AddMedal ( No , - 1 ) else
10600: LD_STRING No
10602: PPUSH
10603: LD_INT 1
10605: NEG
10606: PPUSH
10607: CALL_OW 101
10611: GO 10624
// AddMedal ( UpTo4 , - 1 ) ;
10613: LD_STRING UpTo4
10615: PPUSH
10616: LD_INT 1
10618: NEG
10619: PPUSH
10620: CALL_OW 101
// GiveMedals ( MAIN ) ;
10624: LD_STRING MAIN
10626: PPUSH
10627: CALL_OW 102
// if IsDead ( Pokryshkin ) then
10631: LD_EXP 44
10635: PPUSH
10636: CALL_OW 301
10640: IFFALSE 10680
// for i in save_group ^ save_others do
10642: LD_ADDR_VAR 0 3
10646: PUSH
10647: LD_EXP 20
10651: PUSH
10652: LD_EXP 19
10656: ADD
10657: PUSH
10658: FOR_IN
10659: IFFALSE 10678
// AddExperience ( i , skill_combat , 1500 ) ;
10661: LD_VAR 0 3
10665: PPUSH
10666: LD_INT 1
10668: PPUSH
10669: LD_INT 1500
10671: PPUSH
10672: CALL_OW 492
10676: GO 10658
10678: POP
10679: POP
// RewardPeople ( save_group ^ save_others ) ;
10680: LD_EXP 20
10684: PUSH
10685: LD_EXP 19
10689: ADD
10690: PPUSH
10691: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
10695: LD_EXP 29
10699: PPUSH
10700: LD_STRING JMM
10702: PPUSH
10703: CALL_OW 38
// if Bobby in save_group then
10707: LD_EXP 30
10711: PUSH
10712: LD_EXP 20
10716: IN
10717: IFFALSE 10731
// SaveCharacters ( Bobby , Bobby ) ;
10719: LD_EXP 30
10723: PPUSH
10724: LD_STRING Bobby
10726: PPUSH
10727: CALL_OW 38
// if Cyrus in save_group then
10731: LD_EXP 31
10735: PUSH
10736: LD_EXP 20
10740: IN
10741: IFFALSE 10755
// SaveCharacters ( Cyrus , Cyrus ) ;
10743: LD_EXP 31
10747: PPUSH
10748: LD_STRING Cyrus
10750: PPUSH
10751: CALL_OW 38
// if Lisa in save_group then
10755: LD_EXP 32
10759: PUSH
10760: LD_EXP 20
10764: IN
10765: IFFALSE 10779
// SaveCharacters ( Lisa , Lisa ) ;
10767: LD_EXP 32
10771: PPUSH
10772: LD_STRING Lisa
10774: PPUSH
10775: CALL_OW 38
// if Frank in save_group then
10779: LD_EXP 43
10783: PUSH
10784: LD_EXP 20
10788: IN
10789: IFFALSE 10803
// SaveCharacters ( Frank , Frank ) ;
10791: LD_EXP 43
10795: PPUSH
10796: LD_STRING Frank
10798: PPUSH
10799: CALL_OW 38
// if Khatam in save_group then
10803: LD_EXP 33
10807: PUSH
10808: LD_EXP 20
10812: IN
10813: IFFALSE 10827
// SaveCharacters ( Khatam , Khatam ) ;
10815: LD_EXP 33
10819: PPUSH
10820: LD_STRING Khatam
10822: PPUSH
10823: CALL_OW 38
// if Lynch in save_group then
10827: LD_EXP 39
10831: PUSH
10832: LD_EXP 20
10836: IN
10837: IFFALSE 10851
// SaveCharacters ( Lynch , Lynch ) ;
10839: LD_EXP 39
10843: PPUSH
10844: LD_STRING Lynch
10846: PPUSH
10847: CALL_OW 38
// if Walker in save_group then
10851: LD_EXP 40
10855: PUSH
10856: LD_EXP 20
10860: IN
10861: IFFALSE 10875
// SaveCharacters ( Walker , Walker ) ;
10863: LD_EXP 40
10867: PPUSH
10868: LD_STRING Walker
10870: PPUSH
10871: CALL_OW 38
// if Turner in save_group then
10875: LD_EXP 41
10879: PUSH
10880: LD_EXP 20
10884: IN
10885: IFFALSE 10899
// SaveCharacters ( Turner , Turner ) ;
10887: LD_EXP 41
10891: PPUSH
10892: LD_STRING Turner
10894: PPUSH
10895: CALL_OW 38
// if Jillian in save_group then
10899: LD_EXP 42
10903: PUSH
10904: LD_EXP 20
10908: IN
10909: IFFALSE 10923
// SaveCharacters ( Jillian , Jillian ) ;
10911: LD_EXP 42
10915: PPUSH
10916: LD_STRING Jillian
10918: PPUSH
10919: CALL_OW 38
// if save_others then
10923: LD_EXP 19
10927: IFFALSE 10941
// SaveCharacters ( save_others , 03_others ) ;
10929: LD_EXP 19
10933: PPUSH
10934: LD_STRING 03_others
10936: PPUSH
10937: CALL_OW 38
// if Bierezov then
10941: LD_EXP 37
10945: IFFALSE 10955
// begin ResetFog ;
10947: CALL_OW 335
// DisplayEndingScene ;
10951: CALL 10964 0 0
// end ; YouWin ;
10955: CALL_OW 103
// end ;
10959: LD_VAR 0 1
10963: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
10964: LD_INT 0
10966: PPUSH
10967: PPUSH
10968: PPUSH
10969: PPUSH
10970: PPUSH
10971: PPUSH
// InGameOn ;
10972: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
10976: LD_INT 208
10978: PPUSH
10979: LD_INT 62
10981: PPUSH
10982: LD_INT 1
10984: PPUSH
10985: LD_INT 10
10987: NEG
10988: PPUSH
10989: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
10993: LD_INT 208
10995: PPUSH
10996: LD_INT 62
10998: PPUSH
10999: LD_INT 1
11001: PPUSH
11002: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11006: LD_ADDR_VAR 0 3
11010: PUSH
11011: LD_INT 22
11013: PUSH
11014: LD_INT 3
11016: PUSH
11017: EMPTY
11018: LIST
11019: LIST
11020: PUSH
11021: LD_INT 2
11023: PUSH
11024: LD_INT 21
11026: PUSH
11027: LD_INT 2
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: PUSH
11034: LD_INT 21
11036: PUSH
11037: LD_INT 1
11039: PUSH
11040: EMPTY
11041: LIST
11042: LIST
11043: PUSH
11044: EMPTY
11045: LIST
11046: LIST
11047: LIST
11048: PUSH
11049: EMPTY
11050: LIST
11051: LIST
11052: PPUSH
11053: CALL_OW 69
11057: ST_TO_ADDR
// if filter then
11058: LD_VAR 0 3
11062: IFFALSE 11090
// for i in filter do
11064: LD_ADDR_VAR 0 2
11068: PUSH
11069: LD_VAR 0 3
11073: PUSH
11074: FOR_IN
11075: IFFALSE 11088
// RemoveUnit ( i ) ;
11077: LD_VAR 0 2
11081: PPUSH
11082: CALL_OW 64
11086: GO 11074
11088: POP
11089: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
11090: LD_ADDR_VAR 0 3
11094: PUSH
11095: LD_INT 22
11097: PUSH
11098: LD_INT 4
11100: PUSH
11101: EMPTY
11102: LIST
11103: LIST
11104: PUSH
11105: LD_INT 21
11107: PUSH
11108: LD_INT 1
11110: PUSH
11111: EMPTY
11112: LIST
11113: LIST
11114: PUSH
11115: EMPTY
11116: LIST
11117: LIST
11118: PPUSH
11119: CALL_OW 69
11123: ST_TO_ADDR
// if filter then
11124: LD_VAR 0 3
11128: IFFALSE 11159
// for i in filter do
11130: LD_ADDR_VAR 0 2
11134: PUSH
11135: LD_VAR 0 3
11139: PUSH
11140: FOR_IN
11141: IFFALSE 11157
// SetLives ( i , 0 ) ;
11143: LD_VAR 0 2
11147: PPUSH
11148: LD_INT 0
11150: PPUSH
11151: CALL_OW 234
11155: GO 11140
11157: POP
11158: POP
// uc_side := 4 ;
11159: LD_ADDR_OWVAR 20
11163: PUSH
11164: LD_INT 4
11166: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
11167: LD_ADDR_VAR 0 4
11171: PUSH
11172: LD_STRING Cornell
11174: PPUSH
11175: LD_INT 0
11177: PPUSH
11178: CALL 417 0 2
11182: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
11183: LD_VAR 0 4
11187: PPUSH
11188: LD_INT 208
11190: PPUSH
11191: LD_INT 62
11193: PPUSH
11194: LD_INT 0
11196: PPUSH
11197: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
11201: LD_VAR 0 4
11205: PPUSH
11206: LD_INT 100
11208: PPUSH
11209: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
11213: LD_INT 3
11215: PPUSH
11216: LD_VAR 0 4
11220: PPUSH
11221: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
11225: LD_INT 4
11227: PPUSH
11228: LD_INT 3
11230: PPUSH
11231: LD_INT 1
11233: PPUSH
11234: LD_INT 1
11236: PPUSH
11237: CALL_OW 80
// uc_side := 3 ;
11241: LD_ADDR_OWVAR 20
11245: PUSH
11246: LD_INT 3
11248: ST_TO_ADDR
// uc_nation := 3 ;
11249: LD_ADDR_OWVAR 21
11253: PUSH
11254: LD_INT 3
11256: ST_TO_ADDR
// InitHc ;
11257: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
11261: LD_ADDR_VAR 0 5
11265: PUSH
11266: LD_STRING Mikhail
11268: PPUSH
11269: LD_INT 0
11271: PPUSH
11272: CALL 417 0 2
11276: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
11277: LD_INT 1
11279: PPUSH
11280: LD_INT 1
11282: PPUSH
11283: LD_INT 0
11285: PPUSH
11286: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
11290: LD_ADDR_VAR 0 6
11294: PUSH
11295: LD_VAR 0 6
11299: PUSH
11300: CALL_OW 44
11304: ADD
11305: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
11306: LD_ADDR_VAR 0 6
11310: PUSH
11311: LD_VAR 0 6
11315: PUSH
11316: CALL_OW 44
11320: ADD
11321: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
11322: LD_INT 2
11324: PPUSH
11325: LD_INT 4
11327: PPUSH
11328: LD_INT 0
11330: PPUSH
11331: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
11335: LD_ADDR_VAR 0 6
11339: PUSH
11340: LD_VAR 0 6
11344: PUSH
11345: CALL_OW 44
11349: ADD
11350: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
11351: LD_VAR 0 5
11355: PPUSH
11356: LD_INT 17
11358: PPUSH
11359: LD_INT 0
11361: PPUSH
11362: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
11366: LD_VAR 0 5
11370: PPUSH
11371: LD_INT 210
11373: PPUSH
11374: LD_INT 63
11376: PPUSH
11377: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
11381: LD_VAR 0 5
11385: PPUSH
11386: LD_INT 208
11388: PPUSH
11389: LD_INT 62
11391: PPUSH
11392: CALL_OW 178
// for i in fake_russians do
11396: LD_ADDR_VAR 0 2
11400: PUSH
11401: LD_VAR 0 6
11405: PUSH
11406: FOR_IN
11407: IFFALSE 11485
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
11409: LD_VAR 0 2
11413: PPUSH
11414: LD_INT 17
11416: PPUSH
11417: LD_INT 0
11419: PPUSH
11420: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
11424: LD_VAR 0 2
11428: PPUSH
11429: LD_INT 215
11431: PPUSH
11432: LD_INT 67
11434: PPUSH
11435: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
11439: LD_VAR 0 2
11443: PPUSH
11444: LD_INT 208
11446: PPUSH
11447: LD_INT 62
11449: PPUSH
11450: CALL_OW 178
// if GetClass ( i ) = 4 then
11454: LD_VAR 0 2
11458: PPUSH
11459: CALL_OW 257
11463: PUSH
11464: LD_INT 4
11466: EQUAL
11467: IFFALSE 11483
// ComHeal ( i , fake_cornel ) ;
11469: LD_VAR 0 2
11473: PPUSH
11474: LD_VAR 0 4
11478: PPUSH
11479: CALL_OW 128
// end ;
11483: GO 11406
11485: POP
11486: POP
// Wait ( 0 0$01 ) ;
11487: LD_INT 35
11489: PPUSH
11490: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
11494: LD_INT 208
11496: PPUSH
11497: LD_INT 62
11499: PPUSH
11500: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
11504: LD_INT 208
11506: PPUSH
11507: LD_INT 62
11509: PPUSH
11510: LD_INT 1
11512: PPUSH
11513: LD_INT 10
11515: NEG
11516: PPUSH
11517: CALL_OW 330
// Wait ( 0 0$15 ) ;
11521: LD_INT 525
11523: PPUSH
11524: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
11528: LD_INT 208
11530: PPUSH
11531: LD_INT 62
11533: PPUSH
11534: LD_INT 1
11536: PPUSH
11537: CALL_OW 331
// ResetFog ;
11541: CALL_OW 335
// InGameOff ;
11545: CALL_OW 9
// end ;
11549: LD_VAR 0 1
11553: RET
// every 0 0$30 trigger GetDistUnits ( JMM , Cornel ) < 3 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) do
11554: LD_EXP 29
11558: PPUSH
11559: LD_EXP 36
11563: PPUSH
11564: CALL_OW 296
11568: PUSH
11569: LD_INT 3
11571: LESS
11572: PUSH
11573: LD_INT 22
11575: PUSH
11576: LD_INT 4
11578: PUSH
11579: EMPTY
11580: LIST
11581: LIST
11582: PUSH
11583: LD_INT 21
11585: PUSH
11586: LD_INT 3
11588: PUSH
11589: EMPTY
11590: LIST
11591: LIST
11592: PUSH
11593: EMPTY
11594: LIST
11595: LIST
11596: PPUSH
11597: CALL_OW 69
11601: AND
11602: IFFALSE 11620
11604: GO 11606
11606: DISABLE
// begin enable ;
11607: ENABLE
// SayRadio ( Powell , DWarn-Pow-1 ) ;
11608: LD_EXP 38
11612: PPUSH
11613: LD_STRING DWarn-Pow-1
11615: PPUSH
11616: CALL_OW 94
// end ; end_of_file
11620: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
11621: LD_EXP 6
11625: IFFALSE 12656
11627: GO 11629
11629: DISABLE
11630: LD_INT 0
11632: PPUSH
11633: PPUSH
11634: PPUSH
11635: PPUSH
11636: PPUSH
11637: PPUSH
11638: PPUSH
11639: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
11640: LD_EXP 36
11644: PUSH
11645: LD_EXP 37
11649: ADD
11650: PUSH
11651: LD_EXP 4
11655: ADD
11656: PPUSH
11657: LD_INT 250
11659: PPUSH
11660: LD_INT 120
11662: PPUSH
11663: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
11667: LD_ADDR_VAR 0 2
11671: PUSH
11672: LD_EXP 4
11676: PPUSH
11677: LD_INT 25
11679: PUSH
11680: LD_INT 2
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PPUSH
11687: CALL_OW 72
11691: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
11692: LD_ADDR_VAR 0 3
11696: PUSH
11697: LD_EXP 4
11701: PPUSH
11702: LD_INT 21
11704: PUSH
11705: LD_INT 1
11707: PUSH
11708: EMPTY
11709: LIST
11710: LIST
11711: PPUSH
11712: CALL_OW 72
11716: ST_TO_ADDR
// if not has_eng then
11717: LD_VAR 0 2
11721: NOT
11722: IFFALSE 11805
// begin uc_side := 4 ;
11724: LD_ADDR_OWVAR 20
11728: PUSH
11729: LD_INT 4
11731: ST_TO_ADDR
// uc_nation := 1 ;
11732: LD_ADDR_OWVAR 21
11736: PUSH
11737: LD_INT 1
11739: ST_TO_ADDR
// bc_type := b_depot ;
11740: LD_ADDR_OWVAR 42
11744: PUSH
11745: LD_INT 0
11747: ST_TO_ADDR
// bc_level := 2 ;
11748: LD_ADDR_OWVAR 43
11752: PUSH
11753: LD_INT 2
11755: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
11756: LD_ADDR_VAR 0 4
11760: PUSH
11761: LD_INT 264
11763: PPUSH
11764: LD_INT 120
11766: PPUSH
11767: LD_INT 4
11769: PPUSH
11770: CALL_OW 47
11774: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
11775: LD_INT 264
11777: PPUSH
11778: LD_INT 120
11780: PPUSH
11781: LD_INT 4
11783: PPUSH
11784: LD_INT 10
11786: NEG
11787: PPUSH
11788: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
11792: LD_INT 264
11794: PPUSH
11795: LD_INT 120
11797: PPUSH
11798: LD_INT 4
11800: PPUSH
11801: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
11805: LD_INT 35
11807: PPUSH
11808: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
11812: LD_EXP 36
11816: PPUSH
11817: LD_INT 10
11819: PPUSH
11820: CALL_OW 308
11824: IFFALSE 11805
// if has_eng and not dep then
11826: LD_VAR 0 2
11830: PUSH
11831: LD_VAR 0 4
11835: NOT
11836: AND
11837: IFFALSE 11951
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
11839: LD_VAR 0 2
11843: PPUSH
11844: LD_INT 0
11846: PPUSH
11847: LD_INT 264
11849: PPUSH
11850: LD_INT 120
11852: PPUSH
11853: LD_INT 4
11855: PPUSH
11856: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
11860: LD_INT 35
11862: PPUSH
11863: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
11867: LD_INT 22
11869: PUSH
11870: LD_INT 4
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: PUSH
11877: LD_INT 30
11879: PUSH
11880: LD_INT 0
11882: PUSH
11883: EMPTY
11884: LIST
11885: LIST
11886: PUSH
11887: LD_INT 3
11889: PUSH
11890: LD_INT 57
11892: PUSH
11893: EMPTY
11894: LIST
11895: PUSH
11896: EMPTY
11897: LIST
11898: LIST
11899: PUSH
11900: EMPTY
11901: LIST
11902: LIST
11903: LIST
11904: PPUSH
11905: CALL_OW 69
11909: IFFALSE 11860
// dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
11911: LD_ADDR_VAR 0 4
11915: PUSH
11916: LD_INT 22
11918: PUSH
11919: LD_INT 4
11921: PUSH
11922: EMPTY
11923: LIST
11924: LIST
11925: PUSH
11926: LD_INT 30
11928: PUSH
11929: LD_INT 0
11931: PUSH
11932: EMPTY
11933: LIST
11934: LIST
11935: PUSH
11936: EMPTY
11937: LIST
11938: LIST
11939: PPUSH
11940: CALL_OW 69
11944: PUSH
11945: LD_INT 1
11947: ARRAY
11948: ST_TO_ADDR
// end else
11949: GO 12068
// begin SetSide ( dep , 4 ) ;
11951: LD_VAR 0 4
11955: PPUSH
11956: LD_INT 4
11958: PPUSH
11959: CALL_OW 235
// for i = 1 to 3 do
11963: LD_ADDR_VAR 0 1
11967: PUSH
11968: DOUBLE
11969: LD_INT 1
11971: DEC
11972: ST_TO_ADDR
11973: LD_INT 3
11975: PUSH
11976: FOR_TO
11977: IFFALSE 12034
// begin ComEnterUnit ( filter [ i ] , dep ) ;
11979: LD_VAR 0 3
11983: PUSH
11984: LD_VAR 0 1
11988: ARRAY
11989: PPUSH
11990: LD_VAR 0 4
11994: PPUSH
11995: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
11999: LD_VAR 0 3
12003: PUSH
12004: LD_VAR 0 1
12008: ARRAY
12009: PPUSH
12010: LD_INT 2
12012: PPUSH
12013: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
12017: LD_VAR 0 3
12021: PUSH
12022: LD_VAR 0 1
12026: ARRAY
12027: PPUSH
12028: CALL_OW 182
// end ;
12032: GO 11976
12034: POP
12035: POP
// repeat wait ( 0 0$01 ) ;
12036: LD_INT 35
12038: PPUSH
12039: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
12043: LD_VAR 0 3
12047: PPUSH
12048: LD_INT 25
12050: PUSH
12051: LD_INT 2
12053: PUSH
12054: EMPTY
12055: LIST
12056: LIST
12057: PPUSH
12058: CALL_OW 72
12062: PUSH
12063: LD_INT 3
12065: EQUAL
12066: IFFALSE 12036
// end ; ComEnterUnit ( Bierezov , dep ) ;
12068: LD_EXP 37
12072: PPUSH
12073: LD_VAR 0 4
12077: PPUSH
12078: CALL_OW 120
// if IsInUnit ( Cornel ) then
12082: LD_EXP 36
12086: PPUSH
12087: CALL_OW 310
12091: IFFALSE 12174
// begin cargo := IsInUnit ( Cornel ) ;
12093: LD_ADDR_VAR 0 7
12097: PUSH
12098: LD_EXP 36
12102: PPUSH
12103: CALL_OW 310
12107: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
12108: LD_VAR 0 7
12112: PPUSH
12113: LD_INT 1
12115: PPUSH
12116: CALL_OW 289
12120: IFFALSE 12136
// ComGive ( Cornel , dep ) ;
12122: LD_EXP 36
12126: PPUSH
12127: LD_VAR 0 4
12131: PPUSH
12132: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
12136: LD_EXP 36
12140: PPUSH
12141: LD_INT 235
12143: PPUSH
12144: LD_INT 122
12146: PPUSH
12147: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
12151: LD_EXP 36
12155: PPUSH
12156: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
12160: LD_EXP 36
12164: PPUSH
12165: LD_VAR 0 4
12169: PPUSH
12170: CALL_OW 180
// end ; has_eng := UnitFilter ( filter , [ f_class , 2 ] ) ;
12174: LD_ADDR_VAR 0 2
12178: PUSH
12179: LD_VAR 0 3
12183: PPUSH
12184: LD_INT 25
12186: PUSH
12187: LD_INT 2
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: PPUSH
12194: CALL_OW 72
12198: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
12199: LD_INT 35
12201: PPUSH
12202: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
12206: LD_ADDR_VAR 0 6
12210: PUSH
12211: LD_INT 10
12213: PPUSH
12214: CALL_OW 435
12218: ST_TO_ADDR
// if crates then
12219: LD_VAR 0 6
12223: IFFALSE 12252
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
12225: LD_VAR 0 2
12229: PPUSH
12230: LD_VAR 0 6
12234: PUSH
12235: LD_INT 1
12237: ARRAY
12238: PPUSH
12239: LD_VAR 0 6
12243: PUSH
12244: LD_INT 2
12246: ARRAY
12247: PPUSH
12248: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
12252: LD_VAR 0 4
12256: PPUSH
12257: CALL_OW 274
12261: PPUSH
12262: LD_INT 1
12264: PPUSH
12265: CALL_OW 275
12269: PUSH
12270: LD_INT 40
12272: GREATEREQUAL
12273: IFFALSE 12199
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
12275: LD_ADDR_VAR 0 5
12279: PUSH
12280: LD_INT 4
12282: PUSH
12283: LD_INT 256
12285: PUSH
12286: LD_INT 111
12288: PUSH
12289: LD_INT 2
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: LIST
12296: LIST
12297: PUSH
12298: LD_INT 31
12300: PUSH
12301: LD_INT 243
12303: PUSH
12304: LD_INT 112
12306: PUSH
12307: LD_INT 2
12309: PUSH
12310: EMPTY
12311: LIST
12312: LIST
12313: LIST
12314: LIST
12315: PUSH
12316: EMPTY
12317: LIST
12318: LIST
12319: ST_TO_ADDR
// for i in blist do
12320: LD_ADDR_VAR 0 1
12324: PUSH
12325: LD_VAR 0 5
12329: PUSH
12330: FOR_IN
12331: IFFALSE 12380
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
12333: LD_VAR 0 2
12337: PPUSH
12338: LD_VAR 0 1
12342: PUSH
12343: LD_INT 1
12345: ARRAY
12346: PPUSH
12347: LD_VAR 0 1
12351: PUSH
12352: LD_INT 2
12354: ARRAY
12355: PPUSH
12356: LD_VAR 0 1
12360: PUSH
12361: LD_INT 3
12363: ARRAY
12364: PPUSH
12365: LD_VAR 0 1
12369: PUSH
12370: LD_INT 4
12372: ARRAY
12373: PPUSH
12374: CALL_OW 205
12378: GO 12330
12380: POP
12381: POP
// repeat wait ( 0 0$01 ) ;
12382: LD_INT 35
12384: PPUSH
12385: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
12389: LD_INT 22
12391: PUSH
12392: LD_INT 4
12394: PUSH
12395: EMPTY
12396: LIST
12397: LIST
12398: PUSH
12399: LD_INT 30
12401: PUSH
12402: LD_INT 4
12404: PUSH
12405: EMPTY
12406: LIST
12407: LIST
12408: PUSH
12409: LD_INT 3
12411: PUSH
12412: LD_INT 57
12414: PUSH
12415: EMPTY
12416: LIST
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: PUSH
12422: EMPTY
12423: LIST
12424: LIST
12425: LIST
12426: PPUSH
12427: CALL_OW 69
12431: IFFALSE 12382
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
12433: LD_VAR 0 3
12437: PUSH
12438: LD_VAR 0 2
12442: DIFF
12443: PPUSH
12444: LD_INT 22
12446: PUSH
12447: LD_INT 4
12449: PUSH
12450: EMPTY
12451: LIST
12452: LIST
12453: PUSH
12454: LD_INT 30
12456: PUSH
12457: LD_INT 4
12459: PUSH
12460: EMPTY
12461: LIST
12462: LIST
12463: PUSH
12464: EMPTY
12465: LIST
12466: LIST
12467: PPUSH
12468: CALL_OW 69
12472: PUSH
12473: LD_INT 1
12475: ARRAY
12476: PPUSH
12477: CALL_OW 180
// repeat wait ( 0 0$01 ) ;
12481: LD_INT 35
12483: PPUSH
12484: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
12488: LD_INT 22
12490: PUSH
12491: LD_INT 4
12493: PUSH
12494: EMPTY
12495: LIST
12496: LIST
12497: PUSH
12498: LD_INT 30
12500: PUSH
12501: LD_INT 31
12503: PUSH
12504: EMPTY
12505: LIST
12506: LIST
12507: PUSH
12508: LD_INT 3
12510: PUSH
12511: LD_INT 57
12513: PUSH
12514: EMPTY
12515: LIST
12516: PUSH
12517: EMPTY
12518: LIST
12519: LIST
12520: PUSH
12521: EMPTY
12522: LIST
12523: LIST
12524: LIST
12525: PPUSH
12526: CALL_OW 69
12530: IFFALSE 12481
// sol := filter diff has_eng ;
12532: LD_ADDR_VAR 0 8
12536: PUSH
12537: LD_VAR 0 3
12541: PUSH
12542: LD_VAR 0 2
12546: DIFF
12547: ST_TO_ADDR
// if GetClass ( sol [ 1 ] ) > 1 then
12548: LD_VAR 0 8
12552: PUSH
12553: LD_INT 1
12555: ARRAY
12556: PPUSH
12557: CALL_OW 257
12561: PUSH
12562: LD_INT 1
12564: GREATER
12565: IFFALSE 12583
// SetClass ( sol [ 1 ] , 1 ) ;
12567: LD_VAR 0 8
12571: PUSH
12572: LD_INT 1
12574: ARRAY
12575: PPUSH
12576: LD_INT 1
12578: PPUSH
12579: CALL_OW 336
// ComExitBuilding ( sol [ 1 ] ) ;
12583: LD_VAR 0 8
12587: PUSH
12588: LD_INT 1
12590: ARRAY
12591: PPUSH
12592: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
12596: LD_VAR 0 8
12600: PUSH
12601: LD_INT 1
12603: ARRAY
12604: PPUSH
12605: LD_INT 22
12607: PUSH
12608: LD_INT 4
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: PUSH
12615: LD_INT 30
12617: PUSH
12618: LD_INT 31
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: PPUSH
12629: CALL_OW 69
12633: PUSH
12634: LD_INT 1
12636: ARRAY
12637: PPUSH
12638: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
12642: LD_VAR 0 2
12646: PPUSH
12647: LD_VAR 0 4
12651: PPUSH
12652: CALL_OW 112
// end ;
12656: PPOPN 8
12658: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
12659: LD_EXP 9
12663: IFFALSE 12983
12665: GO 12667
12667: DISABLE
12668: LD_INT 0
12670: PPUSH
12671: PPUSH
12672: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
12673: LD_ADDR_VAR 0 2
12677: PUSH
12678: LD_INT 22
12680: PUSH
12681: LD_INT 4
12683: PUSH
12684: EMPTY
12685: LIST
12686: LIST
12687: PUSH
12688: LD_INT 30
12690: PUSH
12691: LD_INT 4
12693: PUSH
12694: EMPTY
12695: LIST
12696: LIST
12697: PUSH
12698: EMPTY
12699: LIST
12700: LIST
12701: PPUSH
12702: CALL_OW 69
12706: PUSH
12707: LD_INT 1
12709: ARRAY
12710: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
12711: LD_EXP 4
12715: PPUSH
12716: CALL_OW 122
// for i in cornel_units do
12720: LD_ADDR_VAR 0 1
12724: PUSH
12725: LD_EXP 4
12729: PUSH
12730: FOR_IN
12731: IFFALSE 12785
// if GetClass ( i ) = 2 then
12733: LD_VAR 0 1
12737: PPUSH
12738: CALL_OW 257
12742: PUSH
12743: LD_INT 2
12745: EQUAL
12746: IFFALSE 12783
// begin ComEnterUnit ( i , arm ) ;
12748: LD_VAR 0 1
12752: PPUSH
12753: LD_VAR 0 2
12757: PPUSH
12758: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
12762: LD_VAR 0 1
12766: PPUSH
12767: LD_INT 1
12769: PPUSH
12770: CALL_OW 183
// AddComExitBuilding ( i ) ;
12774: LD_VAR 0 1
12778: PPUSH
12779: CALL_OW 182
// end ;
12783: GO 12730
12785: POP
12786: POP
// Wait ( 1 1$00 ) ;
12787: LD_INT 2100
12789: PPUSH
12790: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
12794: LD_ADDR_VAR 0 3
12798: PUSH
12799: LD_EXP 36
12803: PUSH
12804: LD_EXP 37
12808: ADD
12809: PUSH
12810: LD_EXP 4
12814: ADD
12815: PUSH
12816: LD_EXP 4
12820: PPUSH
12821: LD_INT 21
12823: PUSH
12824: LD_INT 2
12826: PUSH
12827: EMPTY
12828: LIST
12829: LIST
12830: PPUSH
12831: CALL_OW 72
12835: DIFF
12836: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
12837: LD_VAR 0 3
12841: PPUSH
12842: LD_INT 248
12844: PPUSH
12845: LD_INT 85
12847: PPUSH
12848: CALL_OW 111
// AddComHold ( filter ) ;
12852: LD_VAR 0 3
12856: PPUSH
12857: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
12861: LD_INT 35
12863: PPUSH
12864: CALL_OW 67
// until cornel_attack ;
12868: LD_EXP 7
12872: IFFALSE 12861
// ComAgressiveMove ( filter , 209 , 63 ) ;
12874: LD_VAR 0 3
12878: PPUSH
12879: LD_INT 209
12881: PPUSH
12882: LD_INT 63
12884: PPUSH
12885: CALL_OW 114
// if Bierezov then
12889: LD_EXP 37
12893: IFFALSE 12983
// begin filter := filter diff Bierezov ;
12895: LD_ADDR_VAR 0 3
12899: PUSH
12900: LD_VAR 0 3
12904: PUSH
12905: LD_EXP 37
12909: DIFF
12910: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
12911: LD_EXP 37
12915: PPUSH
12916: LD_INT 6
12918: PPUSH
12919: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
12923: LD_EXP 37
12927: PPUSH
12928: LD_INT 235
12930: PPUSH
12931: LD_INT 60
12933: PPUSH
12934: CALL_OW 111
// AddComHold ( Bierezov ) ;
12938: LD_EXP 37
12942: PPUSH
12943: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
12947: LD_EXP 37
12951: PPUSH
12952: LD_INT 350
12954: PPUSH
12955: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
12959: LD_EXP 37
12963: PPUSH
12964: LD_INT 198
12966: PPUSH
12967: LD_INT 28
12969: PPUSH
12970: CALL_OW 171
// AddComHold ( Bierezov ) ;
12974: LD_EXP 37
12978: PPUSH
12979: CALL_OW 200
// end ; end ; end_of_file
12983: PPOPN 3
12985: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
12986: LD_EXP 45
12990: PUSH
12991: LD_EXP 26
12995: NOT
12996: AND
12997: PUSH
12998: LD_EXP 27
13002: NOT
13003: AND
13004: IFFALSE 13454
13006: GO 13008
13008: DISABLE
13009: LD_INT 0
13011: PPUSH
13012: PPUSH
13013: PPUSH
13014: PPUSH
// begin enable ;
13015: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
13016: LD_ADDR_VAR 0 4
13020: PUSH
13021: LD_INT 81
13023: PUSH
13024: LD_INT 3
13026: PUSH
13027: EMPTY
13028: LIST
13029: LIST
13030: PPUSH
13031: CALL_OW 69
13035: ST_TO_ADDR
// for i = 1 to ru_patrol do
13036: LD_ADDR_VAR 0 2
13040: PUSH
13041: DOUBLE
13042: LD_INT 1
13044: DEC
13045: ST_TO_ADDR
13046: LD_EXP 45
13050: PUSH
13051: FOR_TO
13052: IFFALSE 13452
// begin un := ru_patrol [ i ] ;
13054: LD_ADDR_VAR 0 1
13058: PUSH
13059: LD_EXP 45
13063: PUSH
13064: LD_VAR 0 2
13068: ARRAY
13069: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
13070: LD_VAR 0 1
13074: PPUSH
13075: LD_INT 13
13077: PPUSH
13078: CALL_OW 308
13082: IFFALSE 13187
// begin if not ru_alert then
13084: LD_EXP 50
13088: NOT
13089: IFFALSE 13099
// ru_alert := true ;
13091: LD_ADDR_EXP 50
13095: PUSH
13096: LD_INT 1
13098: ST_TO_ADDR
// if not See ( 1 , un ) then
13099: LD_INT 1
13101: PPUSH
13102: LD_VAR 0 1
13106: PPUSH
13107: CALL_OW 292
13111: NOT
13112: IFFALSE 13126
// SetLives ( un , 1000 ) ;
13114: LD_VAR 0 1
13118: PPUSH
13119: LD_INT 1000
13121: PPUSH
13122: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
13126: LD_ADDR_EXP 45
13130: PUSH
13131: LD_EXP 45
13135: PUSH
13136: LD_VAR 0 1
13140: DIFF
13141: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
13142: LD_VAR 0 1
13146: PPUSH
13147: LD_INT 22
13149: PUSH
13150: LD_INT 3
13152: PUSH
13153: EMPTY
13154: LIST
13155: LIST
13156: PUSH
13157: LD_INT 30
13159: PUSH
13160: LD_INT 4
13162: PUSH
13163: EMPTY
13164: LIST
13165: LIST
13166: PUSH
13167: EMPTY
13168: LIST
13169: LIST
13170: PPUSH
13171: CALL_OW 69
13175: PPUSH
13176: CALL 993 0 1
13180: PPUSH
13181: CALL_OW 120
// continue ;
13185: GO 13051
// end ; if IsOk ( un ) and not HasTask ( un ) then
13187: LD_VAR 0 1
13191: PPUSH
13192: CALL_OW 302
13196: PUSH
13197: LD_VAR 0 1
13201: PPUSH
13202: CALL_OW 314
13206: NOT
13207: AND
13208: IFFALSE 13301
// begin for j = 1 to ru_firepoints_south [ i ] do
13210: LD_ADDR_VAR 0 3
13214: PUSH
13215: DOUBLE
13216: LD_INT 1
13218: DEC
13219: ST_TO_ADDR
13220: LD_EXP 49
13224: PUSH
13225: LD_VAR 0 2
13229: ARRAY
13230: PUSH
13231: FOR_TO
13232: IFFALSE 13299
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
13234: LD_VAR 0 1
13238: PPUSH
13239: LD_EXP 49
13243: PUSH
13244: LD_VAR 0 2
13248: ARRAY
13249: PUSH
13250: LD_VAR 0 3
13254: ARRAY
13255: PUSH
13256: LD_INT 1
13258: ARRAY
13259: PPUSH
13260: LD_EXP 49
13264: PUSH
13265: LD_VAR 0 2
13269: ARRAY
13270: PUSH
13271: LD_VAR 0 3
13275: ARRAY
13276: PUSH
13277: LD_INT 2
13279: ARRAY
13280: PPUSH
13281: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
13285: LD_VAR 0 1
13289: PPUSH
13290: LD_INT 70
13292: PPUSH
13293: CALL_OW 202
// end ;
13297: GO 13231
13299: POP
13300: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
13301: LD_VAR 0 1
13305: PPUSH
13306: CALL_OW 256
13310: PUSH
13311: LD_INT 700
13313: LESS
13314: PUSH
13315: LD_VAR 0 1
13319: PPUSH
13320: LD_INT 13
13322: PPUSH
13323: CALL_OW 308
13327: NOT
13328: AND
13329: IFFALSE 13381
// begin ComMoveToArea ( un , retreatArea ) ;
13331: LD_VAR 0 1
13335: PPUSH
13336: LD_INT 13
13338: PPUSH
13339: CALL_OW 113
// if not ru_alert_xy then
13343: LD_EXP 51
13347: NOT
13348: IFFALSE 13379
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
13350: LD_ADDR_EXP 51
13354: PUSH
13355: LD_VAR 0 1
13359: PPUSH
13360: CALL_OW 250
13364: PUSH
13365: LD_VAR 0 1
13369: PPUSH
13370: CALL_OW 251
13374: PUSH
13375: EMPTY
13376: LIST
13377: LIST
13378: ST_TO_ADDR
// end else
13379: GO 13450
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
13381: LD_VAR 0 1
13385: PPUSH
13386: LD_VAR 0 4
13390: PPUSH
13391: LD_VAR 0 1
13395: PPUSH
13396: CALL_OW 74
13400: PPUSH
13401: CALL_OW 296
13405: PUSH
13406: LD_INT 9
13408: LESS
13409: PUSH
13410: LD_VAR 0 1
13414: PPUSH
13415: CALL_OW 256
13419: PUSH
13420: LD_INT 500
13422: GREATER
13423: AND
13424: IFFALSE 13450
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
13426: LD_VAR 0 1
13430: PPUSH
13431: LD_VAR 0 4
13435: PPUSH
13436: LD_VAR 0 1
13440: PPUSH
13441: CALL_OW 74
13445: PPUSH
13446: CALL_OW 115
// end ;
13450: GO 13051
13452: POP
13453: POP
// end ;
13454: PPOPN 4
13456: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
13457: LD_EXP 50
13461: PUSH
13462: LD_EXP 51
13466: AND
13467: PUSH
13468: LD_EXP 26
13472: NOT
13473: AND
13474: PUSH
13475: LD_EXP 27
13479: NOT
13480: AND
13481: IFFALSE 13691
13483: GO 13485
13485: DISABLE
13486: LD_INT 0
13488: PPUSH
13489: PPUSH
// begin enable ;
13490: ENABLE
// if not ru_vehicles then
13491: LD_EXP 48
13495: NOT
13496: IFFALSE 13500
// exit ;
13498: GO 13691
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
13500: LD_ADDR_VAR 0 2
13504: PUSH
13505: LD_INT 81
13507: PUSH
13508: LD_INT 3
13510: PUSH
13511: EMPTY
13512: LIST
13513: LIST
13514: PPUSH
13515: CALL_OW 69
13519: ST_TO_ADDR
// if ru_vehicles then
13520: LD_EXP 48
13524: IFFALSE 13691
// begin for i in ru_vehicles do
13526: LD_ADDR_VAR 0 1
13530: PUSH
13531: LD_EXP 48
13535: PUSH
13536: FOR_IN
13537: IFFALSE 13689
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
13539: LD_VAR 0 1
13543: PPUSH
13544: CALL_OW 302
13548: PUSH
13549: LD_VAR 0 1
13553: PPUSH
13554: LD_VAR 0 2
13558: PPUSH
13559: LD_VAR 0 1
13563: PPUSH
13564: CALL_OW 74
13568: PPUSH
13569: CALL_OW 296
13573: PUSH
13574: LD_INT 9
13576: LESS
13577: AND
13578: IFFALSE 13604
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
13580: LD_VAR 0 1
13584: PPUSH
13585: LD_VAR 0 2
13589: PPUSH
13590: LD_VAR 0 1
13594: PPUSH
13595: CALL_OW 74
13599: PPUSH
13600: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
13604: LD_VAR 0 1
13608: PPUSH
13609: CALL_OW 314
13613: NOT
13614: PUSH
13615: LD_VAR 0 1
13619: PPUSH
13620: CALL_OW 302
13624: AND
13625: PUSH
13626: LD_VAR 0 1
13630: PPUSH
13631: LD_EXP 51
13635: PUSH
13636: LD_INT 1
13638: ARRAY
13639: PPUSH
13640: LD_EXP 51
13644: PUSH
13645: LD_INT 2
13647: ARRAY
13648: PPUSH
13649: CALL_OW 297
13653: PUSH
13654: LD_INT 10
13656: GREATER
13657: AND
13658: IFFALSE 13687
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
13660: LD_VAR 0 1
13664: PPUSH
13665: LD_EXP 51
13669: PUSH
13670: LD_INT 1
13672: ARRAY
13673: PPUSH
13674: LD_EXP 51
13678: PUSH
13679: LD_INT 2
13681: ARRAY
13682: PPUSH
13683: CALL_OW 114
// end ;
13687: GO 13536
13689: POP
13690: POP
// end ; end ;
13691: PPOPN 2
13693: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
13694: LD_EXP 51
13698: PUSH
13699: LD_EXP 50
13703: AND
13704: PUSH
13705: LD_INT 3
13707: PPUSH
13708: CALL_OW 463
13712: NOT
13713: AND
13714: PUSH
13715: LD_EXP 26
13719: NOT
13720: AND
13721: PUSH
13722: LD_EXP 27
13726: NOT
13727: AND
13728: IFFALSE 13823
13730: GO 13732
13732: DISABLE
13733: LD_INT 0
13735: PPUSH
// begin enable ;
13736: ENABLE
// ru_alert_xy := false ;
13737: LD_ADDR_EXP 51
13741: PUSH
13742: LD_INT 0
13744: ST_TO_ADDR
// ru_alert := false ;
13745: LD_ADDR_EXP 50
13749: PUSH
13750: LD_INT 0
13752: ST_TO_ADDR
// if ru_vehicles then
13753: LD_EXP 48
13757: IFFALSE 13823
// for i in ru_vehicles do
13759: LD_ADDR_VAR 0 1
13763: PUSH
13764: LD_EXP 48
13768: PUSH
13769: FOR_IN
13770: IFFALSE 13821
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
13772: LD_VAR 0 1
13776: PPUSH
13777: CALL_OW 302
13781: PUSH
13782: LD_VAR 0 1
13786: PPUSH
13787: LD_INT 89
13789: PPUSH
13790: LD_INT 36
13792: PPUSH
13793: CALL_OW 297
13797: PUSH
13798: LD_INT 10
13800: GREATER
13801: AND
13802: IFFALSE 13819
// ComMoveXY ( i , 89 , 36 ) ;
13804: LD_VAR 0 1
13808: PPUSH
13809: LD_INT 89
13811: PPUSH
13812: LD_INT 36
13814: PPUSH
13815: CALL_OW 111
13819: GO 13769
13821: POP
13822: POP
// end ;
13823: PPOPN 1
13825: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
13826: LD_EXP 47
13830: PUSH
13831: LD_EXP 26
13835: NOT
13836: AND
13837: PUSH
13838: LD_EXP 27
13842: NOT
13843: AND
13844: IFFALSE 14128
13846: GO 13848
13848: DISABLE
13849: LD_INT 0
13851: PPUSH
13852: PPUSH
13853: PPUSH
// begin enable ;
13854: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
13855: LD_ADDR_VAR 0 3
13859: PUSH
13860: LD_INT 81
13862: PUSH
13863: LD_INT 3
13865: PUSH
13866: EMPTY
13867: LIST
13868: LIST
13869: PPUSH
13870: CALL_OW 69
13874: ST_TO_ADDR
// for i = 1 to ru_forest do
13875: LD_ADDR_VAR 0 1
13879: PUSH
13880: DOUBLE
13881: LD_INT 1
13883: DEC
13884: ST_TO_ADDR
13885: LD_EXP 47
13889: PUSH
13890: FOR_TO
13891: IFFALSE 14126
// begin un := ru_forest [ i ] ;
13893: LD_ADDR_VAR 0 2
13897: PUSH
13898: LD_EXP 47
13902: PUSH
13903: LD_VAR 0 1
13907: ARRAY
13908: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
13909: LD_VAR 0 2
13913: PPUSH
13914: LD_INT 13
13916: PPUSH
13917: CALL_OW 308
13921: IFFALSE 14011
// begin if not See ( 1 , un ) then
13923: LD_INT 1
13925: PPUSH
13926: LD_VAR 0 2
13930: PPUSH
13931: CALL_OW 292
13935: NOT
13936: IFFALSE 13950
// SetLives ( un , 1000 ) ;
13938: LD_VAR 0 2
13942: PPUSH
13943: LD_INT 1000
13945: PPUSH
13946: CALL_OW 234
// ru_forest := ru_forest diff un ;
13950: LD_ADDR_EXP 47
13954: PUSH
13955: LD_EXP 47
13959: PUSH
13960: LD_VAR 0 2
13964: DIFF
13965: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
13966: LD_VAR 0 2
13970: PPUSH
13971: LD_INT 22
13973: PUSH
13974: LD_INT 3
13976: PUSH
13977: EMPTY
13978: LIST
13979: LIST
13980: PUSH
13981: LD_INT 30
13983: PUSH
13984: LD_INT 4
13986: PUSH
13987: EMPTY
13988: LIST
13989: LIST
13990: PUSH
13991: EMPTY
13992: LIST
13993: LIST
13994: PPUSH
13995: CALL_OW 69
13999: PPUSH
14000: CALL 993 0 1
14004: PPUSH
14005: CALL_OW 120
// continue ;
14009: GO 13890
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
14011: LD_VAR 0 2
14015: PPUSH
14016: CALL_OW 256
14020: PUSH
14021: LD_INT 700
14023: LESS
14024: PUSH
14025: LD_VAR 0 2
14029: PPUSH
14030: LD_INT 13
14032: PPUSH
14033: CALL_OW 308
14037: NOT
14038: AND
14039: IFFALSE 14055
// ComMoveToArea ( un , retreatArea ) else
14041: LD_VAR 0 2
14045: PPUSH
14046: LD_INT 13
14048: PPUSH
14049: CALL_OW 113
14053: GO 14124
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
14055: LD_VAR 0 2
14059: PPUSH
14060: LD_VAR 0 3
14064: PPUSH
14065: LD_VAR 0 2
14069: PPUSH
14070: CALL_OW 74
14074: PPUSH
14075: CALL_OW 296
14079: PUSH
14080: LD_INT 9
14082: LESS
14083: PUSH
14084: LD_VAR 0 2
14088: PPUSH
14089: CALL_OW 256
14093: PUSH
14094: LD_INT 500
14096: GREATER
14097: AND
14098: IFFALSE 14124
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
14100: LD_VAR 0 2
14104: PPUSH
14105: LD_VAR 0 3
14109: PPUSH
14110: LD_VAR 0 2
14114: PPUSH
14115: CALL_OW 74
14119: PPUSH
14120: CALL_OW 115
// end ;
14124: GO 13890
14126: POP
14127: POP
// end ;
14128: PPOPN 3
14130: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
14131: LD_EXP 27
14135: NOT
14136: IFFALSE 14257
14138: GO 14140
14140: DISABLE
14141: LD_INT 0
14143: PPUSH
14144: PPUSH
// begin enable ;
14145: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
14146: LD_ADDR_VAR 0 2
14150: PUSH
14151: LD_INT 22
14153: PUSH
14154: LD_INT 3
14156: PUSH
14157: EMPTY
14158: LIST
14159: LIST
14160: PUSH
14161: LD_INT 21
14163: PUSH
14164: LD_INT 3
14166: PUSH
14167: EMPTY
14168: LIST
14169: LIST
14170: PUSH
14171: EMPTY
14172: LIST
14173: LIST
14174: PPUSH
14175: CALL_OW 69
14179: ST_TO_ADDR
// if filter then
14180: LD_VAR 0 2
14184: IFFALSE 14257
// for i in filter do
14186: LD_ADDR_VAR 0 1
14190: PUSH
14191: LD_VAR 0 2
14195: PUSH
14196: FOR_IN
14197: IFFALSE 14255
// if GetLives ( i ) < 990 then
14199: LD_VAR 0 1
14203: PPUSH
14204: CALL_OW 256
14208: PUSH
14209: LD_INT 990
14211: LESS
14212: IFFALSE 14253
// begin ru_alert := true ;
14214: LD_ADDR_EXP 50
14218: PUSH
14219: LD_INT 1
14221: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
14222: LD_ADDR_EXP 51
14226: PUSH
14227: LD_VAR 0 1
14231: PPUSH
14232: CALL_OW 250
14236: PUSH
14237: LD_VAR 0 1
14241: PPUSH
14242: CALL_OW 251
14246: PUSH
14247: EMPTY
14248: LIST
14249: LIST
14250: ST_TO_ADDR
// break ;
14251: GO 14255
// end ;
14253: GO 14196
14255: POP
14256: POP
// end ;
14257: PPOPN 2
14259: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
14260: LD_EXP 26
14264: IFFALSE 14403
14266: GO 14268
14268: DISABLE
14269: LD_INT 0
14271: PPUSH
14272: PPUSH
14273: PPUSH
14274: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
14275: LD_ADDR_VAR 0 4
14279: PUSH
14280: LD_EXP 48
14284: PUSH
14285: LD_EXP 47
14289: ADD
14290: PUSH
14291: LD_EXP 45
14295: ADD
14296: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
14297: LD_ADDR_VAR 0 3
14301: PUSH
14302: LD_INT 3
14304: PPUSH
14305: LD_INT 81
14307: PUSH
14308: LD_INT 3
14310: PUSH
14311: EMPTY
14312: LIST
14313: LIST
14314: PPUSH
14315: CALL_OW 70
14319: ST_TO_ADDR
// if filter and enemy then
14320: LD_VAR 0 4
14324: PUSH
14325: LD_VAR 0 3
14329: AND
14330: IFFALSE 14403
// repeat wait ( 0 0$01 ) ;
14332: LD_INT 35
14334: PPUSH
14335: CALL_OW 67
// for i in filter do
14339: LD_ADDR_VAR 0 1
14343: PUSH
14344: LD_VAR 0 4
14348: PUSH
14349: FOR_IN
14350: IFFALSE 14378
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
14352: LD_VAR 0 1
14356: PPUSH
14357: LD_VAR 0 3
14361: PPUSH
14362: LD_VAR 0 1
14366: PPUSH
14367: CALL_OW 74
14371: PPUSH
14372: CALL_OW 115
// end ;
14376: GO 14349
14378: POP
14379: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 ;
14380: LD_INT 3
14382: PPUSH
14383: LD_INT 81
14385: PUSH
14386: LD_INT 3
14388: PUSH
14389: EMPTY
14390: LIST
14391: LIST
14392: PPUSH
14393: CALL_OW 70
14397: PUSH
14398: LD_INT 0
14400: EQUAL
14401: IFFALSE 14332
// end ; end_of_file
14403: PPOPN 4
14405: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
14406: LD_EXP 3
14410: PUSH
14411: LD_EXP 7
14415: NOT
14416: AND
14417: PUSH
14418: LD_EXP 17
14422: AND
14423: IFFALSE 14535
14425: GO 14427
14427: DISABLE
14428: LD_INT 0
14430: PPUSH
// begin enable ;
14431: ENABLE
// crates_counter := crates_counter - 50 ;
14432: LD_ADDR_EXP 17
14436: PUSH
14437: LD_EXP 17
14441: PUSH
14442: LD_INT 50
14444: MINUS
14445: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
14446: LD_INT 8
14448: PPUSH
14449: LD_INT 2
14451: PPUSH
14452: LD_INT 5
14454: PPUSH
14455: CALL_OW 12
14459: PPUSH
14460: LD_INT 1
14462: PPUSH
14463: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
14467: LD_INT 1785
14469: PPUSH
14470: LD_INT 2345
14472: PPUSH
14473: CALL_OW 12
14477: PPUSH
14478: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
14482: LD_ADDR_VAR 0 1
14486: PUSH
14487: LD_INT 1
14489: PPUSH
14490: LD_OWVAR 67
14494: PUSH
14495: LD_INT 2
14497: PLUS
14498: PPUSH
14499: CALL_OW 12
14503: ST_TO_ADDR
// if r < 3 then
14504: LD_VAR 0 1
14508: PUSH
14509: LD_INT 3
14511: LESS
14512: IFFALSE 14535
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
14514: LD_INT 4
14516: PPUSH
14517: LD_INT 1
14519: PPUSH
14520: LD_INT 5
14522: PPUSH
14523: CALL_OW 12
14527: PPUSH
14528: LD_INT 1
14530: PPUSH
14531: CALL_OW 55
// end ;
14535: PPOPN 1
14537: END
// every 0 0$01 trigger cornel_active do
14538: LD_EXP 6
14542: IFFALSE 14631
14544: GO 14546
14546: DISABLE
// begin Wait ( 0 0$03 ) ;
14547: LD_INT 105
14549: PPUSH
14550: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
14554: LD_INT 2
14556: PPUSH
14557: LD_INT 5
14559: PPUSH
14560: CALL_OW 12
14564: PPUSH
14565: LD_INT 10
14567: PPUSH
14568: LD_INT 1
14570: PPUSH
14571: CALL_OW 55
// Wait ( 0 0$13 ) ;
14575: LD_INT 455
14577: PPUSH
14578: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
14582: LD_INT 2
14584: PPUSH
14585: LD_INT 5
14587: PPUSH
14588: CALL_OW 12
14592: PPUSH
14593: LD_INT 10
14595: PPUSH
14596: LD_INT 1
14598: PPUSH
14599: CALL_OW 55
// Wait ( 0 0$16 ) ;
14603: LD_INT 560
14605: PPUSH
14606: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
14610: LD_INT 2
14612: PPUSH
14613: LD_INT 5
14615: PPUSH
14616: CALL_OW 12
14620: PPUSH
14621: LD_INT 10
14623: PPUSH
14624: LD_INT 1
14626: PPUSH
14627: CALL_OW 55
// end ; end_of_file
14631: END
// every 0 0$01 trigger cornel_prepared do
14632: LD_EXP 9
14636: IFFALSE 14695
14638: GO 14640
14640: DISABLE
// begin enable ;
14641: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
14642: LD_ADDR_OWVAR 47
14646: PUSH
14647: LD_STRING #Am03-1
14649: PUSH
14650: LD_EXP 8
14654: PUSH
14655: EMPTY
14656: LIST
14657: LIST
14658: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
14659: LD_ADDR_EXP 8
14663: PUSH
14664: LD_EXP 8
14668: PPUSH
14669: LD_STRING -
14671: PPUSH
14672: CALL 1063 0 2
14676: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
14677: LD_EXP 8
14681: PUSH
14682: LD_INT 0
14684: EQUAL
14685: IFFALSE 14695
// begin Display_Strings := [ ] ;
14687: LD_ADDR_OWVAR 47
14691: PUSH
14692: EMPTY
14693: ST_TO_ADDR
// disable ;
14694: DISABLE
// end ; end ;
14695: END
// every 0 0$01 trigger debug and debug_strings do
14696: LD_EXP 1
14700: PUSH
14701: LD_OWVAR 48
14705: AND
14706: IFFALSE 14722
14708: GO 14710
14710: DISABLE
// begin enable ;
14711: ENABLE
// Display_Strings := debug_strings ;
14712: LD_ADDR_OWVAR 47
14716: PUSH
14717: LD_OWVAR 48
14721: ST_TO_ADDR
// end ; end_of_file
14722: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
14723: LD_VAR 0 1
14727: PPUSH
14728: CALL_OW 255
14732: PUSH
14733: LD_INT 1
14735: EQUAL
14736: PUSH
14737: LD_EXP 11
14741: NOT
14742: AND
14743: IFFALSE 14753
// solar_builded := true ;
14745: LD_ADDR_EXP 11
14749: PUSH
14750: LD_INT 1
14752: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
14753: LD_VAR 0 1
14757: PPUSH
14758: CALL_OW 255
14762: PUSH
14763: LD_INT 1
14765: EQUAL
14766: PUSH
14767: LD_EXP 24
14771: AND
14772: IFFALSE 14805
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
14774: LD_ADDR_EXP 24
14778: PUSH
14779: LD_EXP 24
14783: PUSH
14784: LD_INT 1750
14786: PUSH
14787: LD_INT 1400
14789: PUSH
14790: LD_INT 1225
14792: PUSH
14793: EMPTY
14794: LIST
14795: LIST
14796: LIST
14797: PUSH
14798: LD_OWVAR 67
14802: ARRAY
14803: PLUS
14804: ST_TO_ADDR
// end ;
14805: PPOPN 2
14807: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
14808: LD_VAR 0 1
14812: PUSH
14813: LD_EXP 45
14817: IN
14818: IFFALSE 14836
// ru_patrol := ru_patrol diff un ;
14820: LD_ADDR_EXP 45
14824: PUSH
14825: LD_EXP 45
14829: PUSH
14830: LD_VAR 0 1
14834: DIFF
14835: ST_TO_ADDR
// if un in ru_forest then
14836: LD_VAR 0 1
14840: PUSH
14841: LD_EXP 47
14845: IN
14846: IFFALSE 14864
// ru_forest := ru_forest diff un ;
14848: LD_ADDR_EXP 47
14852: PUSH
14853: LD_EXP 47
14857: PUSH
14858: LD_VAR 0 1
14862: DIFF
14863: ST_TO_ADDR
// if un in ru_vehicles then
14864: LD_VAR 0 1
14868: PUSH
14869: LD_EXP 48
14873: IN
14874: IFFALSE 14892
// ru_vehicles := ru_vehicles diff un ;
14876: LD_ADDR_EXP 48
14880: PUSH
14881: LD_EXP 48
14885: PUSH
14886: LD_VAR 0 1
14890: DIFF
14891: ST_TO_ADDR
// if un = JMM then
14892: LD_VAR 0 1
14896: PUSH
14897: LD_EXP 29
14901: EQUAL
14902: IFFALSE 14911
// YouLost ( 0 ) ;
14904: LD_STRING 0
14906: PPUSH
14907: CALL_OW 104
// if un = us_dep_west then
14911: LD_VAR 0 1
14915: PUSH
14916: LD_INT 1
14918: EQUAL
14919: IFFALSE 14928
// YouLost ( 2 ) ;
14921: LD_STRING 2
14923: PPUSH
14924: CALL_OW 104
// if un = Lynch and GetSide ( Lynch ) = 8 then
14928: LD_VAR 0 1
14932: PUSH
14933: LD_EXP 39
14937: EQUAL
14938: PUSH
14939: LD_EXP 39
14943: PPUSH
14944: CALL_OW 255
14948: PUSH
14949: LD_INT 8
14951: EQUAL
14952: AND
14953: IFFALSE 14962
// YouLost ( 4 ) ;
14955: LD_STRING 4
14957: PPUSH
14958: CALL_OW 104
// end ;
14962: PPOPN 1
14964: END
// every 0 0$01 trigger not game_end and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) < 4 do
14965: LD_EXP 28
14969: NOT
14970: PUSH
14971: LD_INT 22
14973: PUSH
14974: LD_INT 1
14976: PUSH
14977: EMPTY
14978: LIST
14979: LIST
14980: PUSH
14981: LD_INT 21
14983: PUSH
14984: LD_INT 1
14986: PUSH
14987: EMPTY
14988: LIST
14989: LIST
14990: PUSH
14991: EMPTY
14992: LIST
14993: LIST
14994: PPUSH
14995: CALL_OW 69
14999: PUSH
15000: LD_INT 22
15002: PUSH
15003: LD_INT 8
15005: PUSH
15006: EMPTY
15007: LIST
15008: LIST
15009: PUSH
15010: LD_INT 21
15012: PUSH
15013: LD_INT 1
15015: PUSH
15016: EMPTY
15017: LIST
15018: LIST
15019: PUSH
15020: EMPTY
15021: LIST
15022: LIST
15023: PPUSH
15024: CALL_OW 69
15028: PLUS
15029: PUSH
15030: LD_INT 4
15032: LESS
15033: AND
15034: IFFALSE 15046
15036: GO 15038
15038: DISABLE
// YouLost ( 1 ) ;
15039: LD_STRING 1
15041: PPUSH
15042: CALL_OW 104
15046: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
15047: LD_INT 1
15049: PPUSH
15050: CALL_OW 255
15054: PUSH
15055: LD_INT 3
15057: EQUAL
15058: IFFALSE 15070
15060: GO 15062
15062: DISABLE
// YouLost ( 3 ) ;
15063: LD_STRING 3
15065: PPUSH
15066: CALL_OW 104
15070: END
