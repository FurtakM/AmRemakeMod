// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 339 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 427 0 0
// PrepareRussian ;
  22: CALL 2920 0 0
// PrepareAmerican ;
  26: CALL 1161 0 0
// PrepareCornell ;
  30: CALL 2185 0 0
// PrepareWesternBase ;
  34: CALL 2411 0 0
// Action ;
  38: CALL 4926 0 0
// end ;
  42: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  54: LD_ADDR_EXP 3
  58: PUSH
  59: LD_STRING 02_
  61: ST_TO_ADDR
// mission_prefix := 03_ ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_STRING 03_
  69: ST_TO_ADDR
// jmm_units := 0 ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// cornel_units := 0 ;
  78: LD_ADDR_EXP 6
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// bierezov_exist := false ;
  86: LD_ADDR_EXP 7
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// jmm_on_west := false ;
  94: LD_ADDR_EXP 5
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_active := false ;
 102: LD_ADDR_EXP 8
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_attack := false ;
 110: LD_ADDR_EXP 9
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// cornel_prepared := false ;
 118: LD_ADDR_EXP 11
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 126: LD_ADDR_EXP 10
 130: PUSH
 131: LD_INT 4200
 133: ST_TO_ADDR
// frank_can_return := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// solar_builded := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// frank_send_to_scout := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// jmm_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// bobby_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// cyrus_in_veh := false ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// lisa_in_veh := false ;
 182: LD_ADDR_EXP 18
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 190: LD_ADDR_EXP 27
 194: PUSH
 195: LD_INT 25200
 197: PUSH
 198: LD_INT 23100
 200: PUSH
 201: LD_INT 21000
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: PUSH
 209: LD_OWVAR 67
 213: ARRAY
 214: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 215: LD_ADDR_EXP 19
 219: PUSH
 220: LD_INT 600
 222: PUSH
 223: LD_INT 500
 225: PUSH
 226: LD_INT 400
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: PUSH
 234: LD_OWVAR 67
 238: ARRAY
 239: ST_TO_ADDR
// end_mission_allowed := false ;
 240: LD_ADDR_EXP 20
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// save_others := [ ] ;
 248: LD_ADDR_EXP 21
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// save_group := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// show_query := true ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// wait_for_them := false ;
 270: LD_ADDR_EXP 24
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// veh_on_meta := false ;
 278: LD_ADDR_EXP 26
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_spec_patrol := false ;
 286: LD_ADDR_EXP 28
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// prepare_siege := false ;
 294: LD_ADDR_EXP 29
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// send_attack_on_cornel := false ;
 302: LD_ADDR_EXP 30
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 310: LD_ADDR_EXP 25
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// game_end := false ;
 318: LD_ADDR_EXP 31
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// lose_counter := 0 ;
 326: LD_ADDR_EXP 32
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// end ;
 334: LD_VAR 0 1
 338: RET
// function SetDiplomacy ; begin
 339: LD_INT 0
 341: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 342: LD_INT 1
 344: PPUSH
 345: LD_INT 4
 347: PPUSH
 348: LD_INT 1
 350: PPUSH
 351: LD_INT 1
 353: PPUSH
 354: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 358: LD_INT 1
 360: PPUSH
 361: LD_INT 8
 363: PPUSH
 364: LD_INT 1
 366: PPUSH
 367: LD_INT 1
 369: PPUSH
 370: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 374: LD_INT 3
 376: PPUSH
 377: LD_INT 6
 379: PPUSH
 380: LD_INT 1
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 390: LD_INT 4
 392: PPUSH
 393: LD_INT 6
 395: PPUSH
 396: LD_INT 0
 398: PPUSH
 399: LD_INT 1
 401: PPUSH
 402: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 406: LD_INT 3
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: LD_INT 0
 414: PPUSH
 415: LD_INT 1
 417: PPUSH
 418: CALL_OW 80
// end ;
 422: LD_VAR 0 1
 426: RET
// export function DebugMode ; var i ; begin
 427: LD_INT 0
 429: PPUSH
 430: PPUSH
// FogOff ( 1 ) ;
 431: LD_INT 1
 433: PPUSH
 434: CALL_OW 344
// debug_strings := [ ] ;
 438: LD_ADDR_OWVAR 48
 442: PUSH
 443: EMPTY
 444: ST_TO_ADDR
// end ; end_of_file
 445: LD_VAR 0 1
 449: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 450: LD_INT 0
 452: PPUSH
 453: PPUSH
// if exist_mode then
 454: LD_VAR 0 2
 458: IFFALSE 483
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 460: LD_ADDR_VAR 0 4
 464: PUSH
 465: LD_EXP 3
 469: PUSH
 470: LD_VAR 0 1
 474: STR
 475: PPUSH
 476: CALL_OW 34
 480: ST_TO_ADDR
 481: GO 498
// unit := NewCharacter ( ident ) ;
 483: LD_ADDR_VAR 0 4
 487: PUSH
 488: LD_VAR 0 1
 492: PPUSH
 493: CALL_OW 25
 497: ST_TO_ADDR
// result := unit ;
 498: LD_ADDR_VAR 0 3
 502: PUSH
 503: LD_VAR 0 4
 507: ST_TO_ADDR
// end ;
 508: LD_VAR 0 3
 512: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 513: LD_INT 0
 515: PPUSH
// uc_side := side ;
 516: LD_ADDR_OWVAR 20
 520: PUSH
 521: LD_VAR 0 1
 525: ST_TO_ADDR
// uc_nation := nation ;
 526: LD_ADDR_OWVAR 21
 530: PUSH
 531: LD_VAR 0 2
 535: ST_TO_ADDR
// vc_chassis := chassis ;
 536: LD_ADDR_OWVAR 37
 540: PUSH
 541: LD_VAR 0 3
 545: ST_TO_ADDR
// vc_engine := engine ;
 546: LD_ADDR_OWVAR 39
 550: PUSH
 551: LD_VAR 0 4
 555: ST_TO_ADDR
// vc_control := control ;
 556: LD_ADDR_OWVAR 38
 560: PUSH
 561: LD_VAR 0 5
 565: ST_TO_ADDR
// vc_weapon := weapon ;
 566: LD_ADDR_OWVAR 40
 570: PUSH
 571: LD_VAR 0 6
 575: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 576: LD_ADDR_OWVAR 41
 580: PUSH
 581: LD_VAR 0 7
 585: ST_TO_ADDR
// result := CreateVehicle ;
 586: LD_ADDR_VAR 0 8
 590: PUSH
 591: CALL_OW 45
 595: ST_TO_ADDR
// end ;
 596: LD_VAR 0 8
 600: RET
// export function SayX ( units , ident ) ; var i ; begin
 601: LD_INT 0
 603: PPUSH
 604: PPUSH
// result := false ;
 605: LD_ADDR_VAR 0 3
 609: PUSH
 610: LD_INT 0
 612: ST_TO_ADDR
// if not units then
 613: LD_VAR 0 1
 617: NOT
 618: IFFALSE 622
// exit ;
 620: GO 676
// for i in units do
 622: LD_ADDR_VAR 0 4
 626: PUSH
 627: LD_VAR 0 1
 631: PUSH
 632: FOR_IN
 633: IFFALSE 674
// if IsOk ( i ) then
 635: LD_VAR 0 4
 639: PPUSH
 640: CALL_OW 302
 644: IFFALSE 672
// begin Say ( i , ident ) ;
 646: LD_VAR 0 4
 650: PPUSH
 651: LD_VAR 0 2
 655: PPUSH
 656: CALL_OW 88
// result := i ;
 660: LD_ADDR_VAR 0 3
 664: PUSH
 665: LD_VAR 0 4
 669: ST_TO_ADDR
// break ;
 670: GO 674
// end ;
 672: GO 632
 674: POP
 675: POP
// end ;
 676: LD_VAR 0 3
 680: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 681: LD_INT 0
 683: PPUSH
 684: PPUSH
 685: PPUSH
 686: PPUSH
// for i = 1 to count do
 687: LD_ADDR_VAR 0 8
 691: PUSH
 692: DOUBLE
 693: LD_INT 1
 695: DEC
 696: ST_TO_ADDR
 697: LD_VAR 0 6
 701: PUSH
 702: FOR_TO
 703: IFFALSE 784
// begin uc_side = side ;
 705: LD_ADDR_OWVAR 20
 709: PUSH
 710: LD_VAR 0 1
 714: ST_TO_ADDR
// uc_nation = nation ;
 715: LD_ADDR_OWVAR 21
 719: PUSH
 720: LD_VAR 0 2
 724: ST_TO_ADDR
// hc_gallery =  ;
 725: LD_ADDR_OWVAR 33
 729: PUSH
 730: LD_STRING 
 732: ST_TO_ADDR
// hc_name =  ;
 733: LD_ADDR_OWVAR 26
 737: PUSH
 738: LD_STRING 
 740: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 741: LD_INT 0
 743: PPUSH
 744: LD_VAR 0 5
 748: PPUSH
 749: LD_VAR 0 4
 753: PPUSH
 754: CALL_OW 380
// un = CreateHuman ;
 758: LD_ADDR_VAR 0 10
 762: PUSH
 763: CALL_OW 44
 767: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 768: LD_VAR 0 10
 772: PPUSH
 773: LD_VAR 0 3
 777: PPUSH
 778: CALL_OW 52
// end ;
 782: GO 702
 784: POP
 785: POP
// end ;
 786: LD_VAR 0 7
 790: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 791: LD_INT 0
 793: PPUSH
 794: PPUSH
 795: PPUSH
// uc_side := GetSide ( b ) ;
 796: LD_ADDR_OWVAR 20
 800: PUSH
 801: LD_VAR 0 2
 805: PPUSH
 806: CALL_OW 255
 810: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 811: LD_ADDR_OWVAR 21
 815: PUSH
 816: LD_VAR 0 2
 820: PPUSH
 821: CALL_OW 248
 825: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 826: LD_INT 0
 828: PPUSH
 829: LD_INT 1
 831: PPUSH
 832: LD_VAR 0 1
 836: PPUSH
 837: CALL_OW 380
// un = CreateHuman ;
 841: LD_ADDR_VAR 0 4
 845: PUSH
 846: CALL_OW 44
 850: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 851: LD_ADDR_VAR 0 5
 855: PUSH
 856: LD_VAR 0 2
 860: PPUSH
 861: CALL_OW 254
 865: PUSH
 866: LD_INT 3
 868: MINUS
 869: ST_TO_ADDR
// if dir < 0 then
 870: LD_VAR 0 5
 874: PUSH
 875: LD_INT 0
 877: LESS
 878: IFFALSE 894
// dir := 6 + dir ;
 880: LD_ADDR_VAR 0 5
 884: PUSH
 885: LD_INT 6
 887: PUSH
 888: LD_VAR 0 5
 892: PLUS
 893: ST_TO_ADDR
// SetDir ( un , dir ) ;
 894: LD_VAR 0 4
 898: PPUSH
 899: LD_VAR 0 5
 903: PPUSH
 904: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 908: LD_VAR 0 4
 912: PPUSH
 913: LD_VAR 0 2
 917: PPUSH
 918: CALL_OW 52
// end ;
 922: LD_VAR 0 3
 926: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 927: LD_INT 0
 929: PPUSH
 930: PPUSH
 931: PPUSH
// result := false ;
 932: LD_ADDR_VAR 0 2
 936: PUSH
 937: LD_INT 0
 939: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 940: LD_ADDR_VAR 0 3
 944: PUSH
 945: LD_INT 22
 947: PUSH
 948: LD_INT 1
 950: PUSH
 951: EMPTY
 952: LIST
 953: LIST
 954: PUSH
 955: LD_INT 34
 957: PUSH
 958: LD_INT 2
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: PUSH
 965: EMPTY
 966: LIST
 967: LIST
 968: PPUSH
 969: CALL_OW 69
 973: ST_TO_ADDR
// for i in filter do
 974: LD_ADDR_VAR 0 4
 978: PUSH
 979: LD_VAR 0 3
 983: PUSH
 984: FOR_IN
 985: IFFALSE 1016
// if IsDrivenBy ( i ) = unit then
 987: LD_VAR 0 4
 991: PPUSH
 992: CALL_OW 311
 996: PUSH
 997: LD_VAR 0 1
1001: EQUAL
1002: IFFALSE 1014
// begin result := true ;
1004: LD_ADDR_VAR 0 2
1008: PUSH
1009: LD_INT 1
1011: ST_TO_ADDR
// break ;
1012: GO 1016
// end ;
1014: GO 984
1016: POP
1017: POP
// end ;
1018: LD_VAR 0 2
1022: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1023: LD_INT 0
1025: PPUSH
1026: PPUSH
// result := false ;
1027: LD_ADDR_VAR 0 2
1031: PUSH
1032: LD_INT 0
1034: ST_TO_ADDR
// if not blist then
1035: LD_VAR 0 1
1039: NOT
1040: IFFALSE 1044
// exit ;
1042: GO 1088
// for i in blist do
1044: LD_ADDR_VAR 0 3
1048: PUSH
1049: LD_VAR 0 1
1053: PUSH
1054: FOR_IN
1055: IFFALSE 1086
// if UnitsInside ( i ) < 6 then
1057: LD_VAR 0 3
1061: PPUSH
1062: CALL_OW 313
1066: PUSH
1067: LD_INT 6
1069: LESS
1070: IFFALSE 1084
// begin result := i ;
1072: LD_ADDR_VAR 0 2
1076: PUSH
1077: LD_VAR 0 3
1081: ST_TO_ADDR
// break ;
1082: GO 1086
// end ;
1084: GO 1054
1086: POP
1087: POP
// end ;
1088: LD_VAR 0 2
1092: RET
// export function Count ( timer , mode ) ; begin
1093: LD_INT 0
1095: PPUSH
// if not timer then
1096: LD_VAR 0 1
1100: NOT
1101: IFFALSE 1105
// exit ;
1103: GO 1156
// if mode in [ asc , up , + ] then
1105: LD_VAR 0 2
1109: PUSH
1110: LD_STRING asc
1112: PUSH
1113: LD_STRING up
1115: PUSH
1116: LD_STRING +
1118: PUSH
1119: EMPTY
1120: LIST
1121: LIST
1122: LIST
1123: IN
1124: IFFALSE 1142
// result := timer + 0 0$01 else
1126: LD_ADDR_VAR 0 3
1130: PUSH
1131: LD_VAR 0 1
1135: PUSH
1136: LD_INT 35
1138: PLUS
1139: ST_TO_ADDR
1140: GO 1156
// result := timer - 0 0$01 ;
1142: LD_ADDR_VAR 0 3
1146: PUSH
1147: LD_VAR 0 1
1151: PUSH
1152: LD_INT 35
1154: MINUS
1155: ST_TO_ADDR
// end ; end_of_file
1156: LD_VAR 0 3
1160: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1161: LD_INT 0
1163: PPUSH
1164: PPUSH
1165: PPUSH
1166: PPUSH
1167: PPUSH
1168: PPUSH
1169: PPUSH
1170: PPUSH
// uc_side := 4 ;
1171: LD_ADDR_OWVAR 20
1175: PUSH
1176: LD_INT 4
1178: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1179: LD_ADDR_EXP 42
1183: PUSH
1184: LD_STRING Powell
1186: PPUSH
1187: LD_INT 0
1189: PPUSH
1190: CALL 450 0 2
1194: ST_TO_ADDR
// uc_side := 1 ;
1195: LD_ADDR_OWVAR 20
1199: PUSH
1200: LD_INT 1
1202: ST_TO_ADDR
// uc_nation := 1 ;
1203: LD_ADDR_OWVAR 21
1207: PUSH
1208: LD_INT 1
1210: ST_TO_ADDR
// if debug then
1211: LD_EXP 1
1215: IFFALSE 1345
// begin for i = 1 to 4 do
1217: LD_ADDR_VAR 0 2
1221: PUSH
1222: DOUBLE
1223: LD_INT 1
1225: DEC
1226: ST_TO_ADDR
1227: LD_INT 4
1229: PUSH
1230: FOR_TO
1231: IFFALSE 1282
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1233: LD_INT 0
1235: PPUSH
1236: LD_INT 1
1238: PPUSH
1239: LD_INT 2
1241: PPUSH
1242: CALL_OW 12
1246: PPUSH
1247: LD_INT 3
1249: PPUSH
1250: CALL_OW 380
// un := CreateHuman ;
1254: LD_ADDR_VAR 0 3
1258: PUSH
1259: CALL_OW 44
1263: ST_TO_ADDR
// others := others ^ un ;
1264: LD_ADDR_VAR 0 5
1268: PUSH
1269: LD_VAR 0 5
1273: PUSH
1274: LD_VAR 0 3
1278: ADD
1279: ST_TO_ADDR
// end ;
1280: GO 1230
1282: POP
1283: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1284: LD_ADDR_VAR 0 6
1288: PUSH
1289: LD_INT 21
1291: PUSH
1292: LD_INT 1
1294: PUSH
1295: LD_INT 1
1297: PUSH
1298: LD_INT 51
1300: PUSH
1301: LD_INT 90
1303: PUSH
1304: LD_INT 504
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: PUSH
1315: LD_INT 21
1317: PUSH
1318: LD_INT 1
1320: PUSH
1321: LD_INT 1
1323: PUSH
1324: LD_INT 51
1326: PUSH
1327: LD_INT 80
1329: PUSH
1330: LD_INT 750
1332: PUSH
1333: EMPTY
1334: LIST
1335: LIST
1336: LIST
1337: LIST
1338: LIST
1339: LIST
1340: PUSH
1341: EMPTY
1342: LIST
1343: LIST
1344: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1345: LD_ADDR_EXP 33
1349: PUSH
1350: LD_STRING JMM
1352: PPUSH
1353: LD_EXP 1
1357: NOT
1358: PPUSH
1359: CALL 450 0 2
1363: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1364: LD_ADDR_EXP 34
1368: PUSH
1369: LD_STRING Bobby
1371: PPUSH
1372: LD_EXP 1
1376: NOT
1377: PPUSH
1378: CALL 450 0 2
1382: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1383: LD_ADDR_EXP 35
1387: PUSH
1388: LD_STRING Cyrus
1390: PPUSH
1391: LD_EXP 1
1395: NOT
1396: PPUSH
1397: CALL 450 0 2
1401: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1402: LD_ADDR_EXP 36
1406: PUSH
1407: LD_STRING Lisa
1409: PPUSH
1410: LD_EXP 1
1414: NOT
1415: PPUSH
1416: CALL 450 0 2
1420: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1421: LD_ADDR_EXP 37
1425: PUSH
1426: LD_STRING Khatam
1428: PPUSH
1429: LD_EXP 1
1433: NOT
1434: PPUSH
1435: CALL 450 0 2
1439: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1440: LD_ADDR_EXP 38
1444: PUSH
1445: LD_STRING Brian
1447: PPUSH
1448: LD_EXP 1
1452: NOT
1453: PPUSH
1454: CALL 450 0 2
1458: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1459: LD_ADDR_EXP 39
1463: PUSH
1464: LD_STRING Jerry
1466: PPUSH
1467: LD_EXP 1
1471: NOT
1472: PPUSH
1473: CALL 450 0 2
1477: ST_TO_ADDR
// if Bobby then
1478: LD_EXP 34
1482: IFFALSE 1513
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1484: LD_ADDR_VAR 0 4
1488: PUSH
1489: LD_VAR 0 4
1493: PPUSH
1494: LD_VAR 0 4
1498: PUSH
1499: LD_INT 1
1501: PLUS
1502: PPUSH
1503: LD_EXP 34
1507: PPUSH
1508: CALL_OW 2
1512: ST_TO_ADDR
// if Cyrus then
1513: LD_EXP 35
1517: IFFALSE 1548
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1519: LD_ADDR_VAR 0 4
1523: PUSH
1524: LD_VAR 0 4
1528: PPUSH
1529: LD_VAR 0 4
1533: PUSH
1534: LD_INT 1
1536: PLUS
1537: PPUSH
1538: LD_EXP 35
1542: PPUSH
1543: CALL_OW 2
1547: ST_TO_ADDR
// if Lisa then
1548: LD_EXP 36
1552: IFFALSE 1583
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1554: LD_ADDR_VAR 0 4
1558: PUSH
1559: LD_VAR 0 4
1563: PPUSH
1564: LD_VAR 0 4
1568: PUSH
1569: LD_INT 1
1571: PLUS
1572: PPUSH
1573: LD_EXP 36
1577: PPUSH
1578: CALL_OW 2
1582: ST_TO_ADDR
// if Khatam then
1583: LD_EXP 37
1587: IFFALSE 1618
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1589: LD_ADDR_VAR 0 4
1593: PUSH
1594: LD_VAR 0 4
1598: PPUSH
1599: LD_VAR 0 4
1603: PUSH
1604: LD_INT 1
1606: PLUS
1607: PPUSH
1608: LD_EXP 37
1612: PPUSH
1613: CALL_OW 2
1617: ST_TO_ADDR
// if Brian then
1618: LD_EXP 38
1622: IFFALSE 1653
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1624: LD_ADDR_VAR 0 4
1628: PUSH
1629: LD_VAR 0 4
1633: PPUSH
1634: LD_VAR 0 4
1638: PUSH
1639: LD_INT 1
1641: PLUS
1642: PPUSH
1643: LD_EXP 38
1647: PPUSH
1648: CALL_OW 2
1652: ST_TO_ADDR
// if Jerry then
1653: LD_EXP 39
1657: IFFALSE 1688
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1659: LD_ADDR_VAR 0 4
1663: PUSH
1664: LD_VAR 0 4
1668: PPUSH
1669: LD_VAR 0 4
1673: PUSH
1674: LD_INT 1
1676: PLUS
1677: PPUSH
1678: LD_EXP 39
1682: PPUSH
1683: CALL_OW 2
1687: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1688: LD_STRING 02_other_survivors
1690: PPUSH
1691: CALL_OW 28
1695: IFFALSE 1710
// others := CreateCharacterSet ( 02_other_survivors ) ;
1697: LD_ADDR_VAR 0 5
1701: PUSH
1702: LD_STRING 02_other_survivors
1704: PPUSH
1705: CALL_OW 31
1709: ST_TO_ADDR
// if others then
1710: LD_VAR 0 5
1714: IFFALSE 1739
// begin tmp := tmp ^ others ;
1716: LD_ADDR_VAR 0 4
1720: PUSH
1721: LD_VAR 0 4
1725: PUSH
1726: LD_VAR 0 5
1730: ADD
1731: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1732: LD_STRING 02_other_survivors
1734: PPUSH
1735: CALL_OW 40
// end ; jmm_units := tmp ;
1739: LD_ADDR_EXP 4
1743: PUSH
1744: LD_VAR 0 4
1748: ST_TO_ADDR
// if not vehicles then
1749: LD_VAR 0 6
1753: NOT
1754: IFFALSE 1772
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1756: LD_ADDR_VAR 0 6
1760: PUSH
1761: LD_STRING 02_tanks_1
1763: PPUSH
1764: LD_INT 0
1766: PPUSH
1767: CALL_OW 30
1771: ST_TO_ADDR
// if vehicles then
1772: LD_VAR 0 6
1776: IFFALSE 1970
// begin got_mech := false ;
1778: LD_ADDR_VAR 0 7
1782: PUSH
1783: LD_INT 0
1785: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1786: LD_VAR 0 4
1790: PPUSH
1791: LD_INT 25
1793: PUSH
1794: LD_INT 3
1796: PUSH
1797: EMPTY
1798: LIST
1799: LIST
1800: PPUSH
1801: CALL_OW 72
1805: IFFALSE 1815
// got_mech := true ;
1807: LD_ADDR_VAR 0 7
1811: PUSH
1812: LD_INT 1
1814: ST_TO_ADDR
// for i = 1 to vehicles do
1815: LD_ADDR_VAR 0 2
1819: PUSH
1820: DOUBLE
1821: LD_INT 1
1823: DEC
1824: ST_TO_ADDR
1825: LD_VAR 0 6
1829: PUSH
1830: FOR_TO
1831: IFFALSE 1968
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1833: LD_ADDR_VAR 0 3
1837: PUSH
1838: LD_INT 1
1840: PPUSH
1841: LD_INT 3
1843: PPUSH
1844: LD_VAR 0 6
1848: PUSH
1849: LD_VAR 0 2
1853: ARRAY
1854: PUSH
1855: LD_INT 1
1857: ARRAY
1858: PPUSH
1859: LD_VAR 0 6
1863: PUSH
1864: LD_VAR 0 2
1868: ARRAY
1869: PUSH
1870: LD_INT 2
1872: ARRAY
1873: PPUSH
1874: LD_VAR 0 6
1878: PUSH
1879: LD_VAR 0 2
1883: ARRAY
1884: PUSH
1885: LD_INT 3
1887: ARRAY
1888: PPUSH
1889: LD_VAR 0 6
1893: PUSH
1894: LD_VAR 0 2
1898: ARRAY
1899: PUSH
1900: LD_INT 4
1902: ARRAY
1903: PPUSH
1904: LD_INT 40
1906: PPUSH
1907: CALL 513 0 7
1911: ST_TO_ADDR
// if not got_mech then
1912: LD_VAR 0 7
1916: NOT
1917: IFFALSE 1943
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1919: LD_VAR 0 3
1923: PPUSH
1924: LD_VAR 0 6
1928: PUSH
1929: LD_VAR 0 2
1933: ARRAY
1934: PUSH
1935: LD_INT 6
1937: ARRAY
1938: PPUSH
1939: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1943: LD_ADDR_VAR 0 4
1947: PUSH
1948: LD_VAR 0 4
1952: PPUSH
1953: LD_INT 1
1955: PPUSH
1956: LD_VAR 0 3
1960: PPUSH
1961: CALL_OW 2
1965: ST_TO_ADDR
// end ;
1966: GO 1830
1968: POP
1969: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1970: LD_EXP 33
1974: PPUSH
1975: LD_INT 194
1977: PPUSH
1978: LD_INT 119
1980: PPUSH
1981: LD_INT 0
1983: PPUSH
1984: CALL_OW 48
// if tmp then
1988: LD_VAR 0 4
1992: IFFALSE 2117
// begin for i in tmp do
1994: LD_ADDR_VAR 0 2
1998: PUSH
1999: LD_VAR 0 4
2003: PUSH
2004: FOR_IN
2005: IFFALSE 2115
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2007: LD_ADDR_VAR 0 8
2011: PUSH
2012: LD_INT 22
2014: PUSH
2015: LD_INT 1
2017: PUSH
2018: EMPTY
2019: LIST
2020: LIST
2021: PUSH
2022: LD_INT 21
2024: PUSH
2025: LD_INT 2
2027: PUSH
2028: EMPTY
2029: LIST
2030: LIST
2031: PUSH
2032: LD_INT 58
2034: PUSH
2035: EMPTY
2036: LIST
2037: PUSH
2038: EMPTY
2039: LIST
2040: LIST
2041: LIST
2042: PPUSH
2043: CALL_OW 69
2047: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2048: LD_VAR 0 2
2052: PPUSH
2053: CALL_OW 247
2057: PUSH
2058: LD_INT 1
2060: EQUAL
2061: PUSH
2062: LD_VAR 0 8
2066: AND
2067: IFFALSE 2089
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2069: LD_VAR 0 2
2073: PPUSH
2074: LD_VAR 0 8
2078: PUSH
2079: LD_INT 1
2081: ARRAY
2082: PPUSH
2083: CALL_OW 52
2087: GO 2104
// PlaceUnitArea ( i , startArea , false ) ;
2089: LD_VAR 0 2
2093: PPUSH
2094: LD_INT 1
2096: PPUSH
2097: LD_INT 0
2099: PPUSH
2100: CALL_OW 49
// ComHold ( i ) ;
2104: LD_VAR 0 2
2108: PPUSH
2109: CALL_OW 140
// end ;
2113: GO 2004
2115: POP
2116: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2117: LD_ADDR_EXP 7
2121: PUSH
2122: LD_STRING 02_mikhailStatus_1
2124: PPUSH
2125: LD_INT 0
2127: PPUSH
2128: CALL_OW 30
2132: ST_TO_ADDR
// if not bierezov_exist and not debug then
2133: LD_EXP 7
2137: NOT
2138: PUSH
2139: LD_EXP 1
2143: NOT
2144: AND
2145: IFFALSE 2149
// exit ;
2147: GO 2180
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2149: LD_ADDR_EXP 41
2153: PUSH
2154: LD_STRING Mikhail
2156: PPUSH
2157: LD_INT 0
2159: PPUSH
2160: CALL 450 0 2
2164: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2165: LD_EXP 41
2169: PPUSH
2170: LD_INT 1
2172: PPUSH
2173: LD_INT 0
2175: PPUSH
2176: CALL_OW 49
// end ;
2180: LD_VAR 0 1
2184: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2185: LD_INT 0
2187: PPUSH
2188: PPUSH
2189: PPUSH
2190: PPUSH
// uc_side := 4 ;
2191: LD_ADDR_OWVAR 20
2195: PUSH
2196: LD_INT 4
2198: ST_TO_ADDR
// uc_nation := 1 ;
2199: LD_ADDR_OWVAR 21
2203: PUSH
2204: LD_INT 1
2206: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2207: LD_ADDR_EXP 40
2211: PUSH
2212: LD_STRING Cornell
2214: PPUSH
2215: LD_INT 0
2217: PPUSH
2218: CALL 450 0 2
2222: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
2223: LD_ADDR_EXP 6
2227: PUSH
2228: LD_INT 8
2230: PUSH
2231: LD_EXP 4
2235: MINUS
2236: ST_TO_ADDR
// tmp := [ ] ;
2237: LD_ADDR_VAR 0 2
2241: PUSH
2242: EMPTY
2243: ST_TO_ADDR
// if cornel_units < 3 then
2244: LD_EXP 6
2248: PUSH
2249: LD_INT 3
2251: LESS
2252: IFFALSE 2262
// cornel_units := 3 ;
2254: LD_ADDR_EXP 6
2258: PUSH
2259: LD_INT 3
2261: ST_TO_ADDR
// for i = 1 to cornel_units do
2262: LD_ADDR_VAR 0 4
2266: PUSH
2267: DOUBLE
2268: LD_INT 1
2270: DEC
2271: ST_TO_ADDR
2272: LD_EXP 6
2276: PUSH
2277: FOR_TO
2278: IFFALSE 2376
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2280: LD_INT 0
2282: PPUSH
2283: LD_INT 1
2285: PUSH
2286: LD_INT 1
2288: PUSH
2289: LD_INT 1
2291: PUSH
2292: LD_INT 2
2294: PUSH
2295: LD_INT 4
2297: PUSH
2298: EMPTY
2299: LIST
2300: LIST
2301: LIST
2302: LIST
2303: LIST
2304: PUSH
2305: LD_VAR 0 4
2309: PUSH
2310: LD_INT 5
2312: MOD
2313: PUSH
2314: LD_INT 1
2316: PLUS
2317: ARRAY
2318: PPUSH
2319: LD_INT 2
2321: PPUSH
2322: CALL_OW 380
// un := CreateHuman ;
2326: LD_ADDR_VAR 0 3
2330: PUSH
2331: CALL_OW 44
2335: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2336: LD_ADDR_VAR 0 2
2340: PUSH
2341: LD_VAR 0 2
2345: PPUSH
2346: LD_INT 1
2348: PPUSH
2349: LD_VAR 0 3
2353: PPUSH
2354: CALL_OW 2
2358: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2359: LD_VAR 0 3
2363: PPUSH
2364: LD_INT 2
2366: PPUSH
2367: LD_INT 0
2369: PPUSH
2370: CALL_OW 49
// end ;
2374: GO 2277
2376: POP
2377: POP
// cornel_units := tmp ;
2378: LD_ADDR_EXP 6
2382: PUSH
2383: LD_VAR 0 2
2387: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2388: LD_EXP 40
2392: PPUSH
2393: LD_INT 191
2395: PPUSH
2396: LD_INT 106
2398: PPUSH
2399: LD_INT 0
2401: PPUSH
2402: CALL_OW 48
// end ;
2406: LD_VAR 0 1
2410: RET
// export function PrepareWesternBase ; var i ; begin
2411: LD_INT 0
2413: PPUSH
2414: PPUSH
// uc_side := 8 ;
2415: LD_ADDR_OWVAR 20
2419: PUSH
2420: LD_INT 8
2422: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2423: LD_ADDR_EXP 43
2427: PUSH
2428: LD_STRING Lynch
2430: PPUSH
2431: LD_INT 0
2433: PPUSH
2434: CALL 450 0 2
2438: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2439: LD_ADDR_EXP 44
2443: PUSH
2444: LD_STRING Walker
2446: PPUSH
2447: LD_INT 0
2449: PPUSH
2450: CALL 450 0 2
2454: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2455: LD_ADDR_EXP 45
2459: PUSH
2460: LD_STRING Turner
2462: PPUSH
2463: LD_INT 0
2465: PPUSH
2466: CALL 450 0 2
2470: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2471: LD_ADDR_EXP 46
2475: PUSH
2476: LD_STRING Jillian
2478: PPUSH
2479: LD_INT 0
2481: PPUSH
2482: CALL 450 0 2
2486: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2487: LD_ADDR_VAR 0 2
2491: PUSH
2492: LD_EXP 43
2496: PUSH
2497: LD_EXP 44
2501: PUSH
2502: LD_EXP 45
2506: PUSH
2507: LD_EXP 46
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: LIST
2516: LIST
2517: PUSH
2518: FOR_IN
2519: IFFALSE 2547
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2521: LD_VAR 0 2
2525: PPUSH
2526: LD_INT 3
2528: PPUSH
2529: LD_INT 0
2531: PPUSH
2532: CALL_OW 49
// ComHold ( i ) ;
2536: LD_VAR 0 2
2540: PPUSH
2541: CALL_OW 140
// end ;
2545: GO 2518
2547: POP
2548: POP
// end ;
2549: LD_VAR 0 1
2553: RET
// export function SelectGroup ; var units , selected , i ; begin
2554: LD_INT 0
2556: PPUSH
2557: PPUSH
2558: PPUSH
2559: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2560: LD_ADDR_VAR 0 2
2564: PUSH
2565: LD_EXP 33
2569: PUSH
2570: LD_INT -3
2572: PUSH
2573: EMPTY
2574: LIST
2575: LIST
2576: PUSH
2577: LD_EXP 4
2581: ADD
2582: PUSH
2583: LD_INT -2
2585: PUSH
2586: LD_INT -4
2588: PUSH
2589: LD_EXP 40
2593: PUSH
2594: LD_EXP 41
2598: PUSH
2599: EMPTY
2600: LIST
2601: LIST
2602: LIST
2603: LIST
2604: ADD
2605: PUSH
2606: LD_INT -3
2608: PUSH
2609: EMPTY
2610: LIST
2611: ADD
2612: PUSH
2613: LD_EXP 6
2617: ADD
2618: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2619: LD_ADDR_VAR 0 3
2623: PUSH
2624: LD_EXP 33
2628: PUSH
2629: LD_STRING Select five characters to go with you
2631: PPUSH
2632: LD_INT 4
2634: PPUSH
2635: LD_INT 4
2637: PPUSH
2638: LD_VAR 0 2
2642: PPUSH
2643: EMPTY
2644: PPUSH
2645: CALL_OW 42
2649: ADD
2650: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2651: LD_ADDR_EXP 6
2655: PUSH
2656: LD_EXP 4
2660: PUSH
2661: LD_EXP 6
2665: UNION
2666: PUSH
2667: LD_VAR 0 3
2671: DIFF
2672: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2673: LD_ADDR_VAR 0 4
2677: PUSH
2678: LD_EXP 6
2682: PUSH
2683: LD_EXP 41
2687: ADD
2688: PUSH
2689: FOR_IN
2690: IFFALSE 2721
// if GetSide ( i ) = 1 then
2692: LD_VAR 0 4
2696: PPUSH
2697: CALL_OW 255
2701: PUSH
2702: LD_INT 1
2704: EQUAL
2705: IFFALSE 2719
// SetSide ( i , 4 ) ;
2707: LD_VAR 0 4
2711: PPUSH
2712: LD_INT 4
2714: PPUSH
2715: CALL_OW 235
2719: GO 2689
2721: POP
2722: POP
// for i in selected do
2723: LD_ADDR_VAR 0 4
2727: PUSH
2728: LD_VAR 0 3
2732: PUSH
2733: FOR_IN
2734: IFFALSE 2765
// if GetSide ( i ) = 4 then
2736: LD_VAR 0 4
2740: PPUSH
2741: CALL_OW 255
2745: PUSH
2746: LD_INT 4
2748: EQUAL
2749: IFFALSE 2763
// SetSide ( i , 1 ) ;
2751: LD_VAR 0 4
2755: PPUSH
2756: LD_INT 1
2758: PPUSH
2759: CALL_OW 235
2763: GO 2733
2765: POP
2766: POP
// jmm_units := jmm_units diff cornel_units ;
2767: LD_ADDR_EXP 4
2771: PUSH
2772: LD_EXP 4
2776: PUSH
2777: LD_EXP 6
2781: DIFF
2782: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2783: LD_EXP 34
2787: PPUSH
2788: CALL_OW 255
2792: PUSH
2793: LD_INT 4
2795: EQUAL
2796: IFFALSE 2805
// DeleteCharacters ( Bobby ) ;
2798: LD_STRING Bobby
2800: PPUSH
2801: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2805: LD_EXP 35
2809: PPUSH
2810: CALL_OW 255
2814: PUSH
2815: LD_INT 4
2817: EQUAL
2818: IFFALSE 2827
// DeleteCharacters ( Cyrus ) ;
2820: LD_STRING Cyrus
2822: PPUSH
2823: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2827: LD_EXP 36
2831: PPUSH
2832: CALL_OW 255
2836: PUSH
2837: LD_INT 4
2839: EQUAL
2840: IFFALSE 2849
// DeleteCharacters ( Lisa ) ;
2842: LD_STRING Lisa
2844: PPUSH
2845: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2849: LD_EXP 37
2853: PPUSH
2854: CALL_OW 255
2858: PUSH
2859: LD_INT 4
2861: EQUAL
2862: IFFALSE 2871
// DeleteCharacters ( Khatam ) ;
2864: LD_STRING Khatam
2866: PPUSH
2867: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2871: LD_EXP 38
2875: PPUSH
2876: CALL_OW 255
2880: PUSH
2881: LD_INT 4
2883: EQUAL
2884: IFFALSE 2893
// DeleteCharacters ( Brian ) ;
2886: LD_STRING Brian
2888: PPUSH
2889: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2893: LD_EXP 39
2897: PPUSH
2898: CALL_OW 255
2902: PUSH
2903: LD_INT 4
2905: EQUAL
2906: IFFALSE 2915
// DeleteCharacters ( Jerry ) ;
2908: LD_STRING Jerry
2910: PPUSH
2911: CALL_OW 40
// end ; end_of_file
2915: LD_VAR 0 1
2919: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
2920: LD_INT 0
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
2930: PPUSH
2931: PPUSH
2932: PPUSH
2933: PPUSH
2934: PPUSH
// ru_alert := false ;
2935: LD_ADDR_EXP 56
2939: PUSH
2940: LD_INT 0
2942: ST_TO_ADDR
// ru_produce_list := [ ] ;
2943: LD_ADDR_EXP 53
2947: PUSH
2948: EMPTY
2949: ST_TO_ADDR
// if Difficulty > 1 then
2950: LD_OWVAR 67
2954: PUSH
2955: LD_INT 1
2957: GREATER
2958: IFFALSE 3046
// begin uc_side := 3 ;
2960: LD_ADDR_OWVAR 20
2964: PUSH
2965: LD_INT 3
2967: ST_TO_ADDR
// uc_nation := 3 ;
2968: LD_ADDR_OWVAR 21
2972: PUSH
2973: LD_INT 3
2975: ST_TO_ADDR
// bc_type := b_breastwork ;
2976: LD_ADDR_OWVAR 42
2980: PUSH
2981: LD_INT 31
2983: ST_TO_ADDR
// bc_level := Difficulty ;
2984: LD_ADDR_OWVAR 43
2988: PUSH
2989: LD_OWVAR 67
2993: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
2994: LD_INT 22
2996: PPUSH
2997: LD_INT 14
2999: PPUSH
3000: LD_INT 0
3002: PPUSH
3003: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3007: LD_INT 48
3009: PPUSH
3010: LD_INT 46
3012: PPUSH
3013: LD_INT 0
3015: PPUSH
3016: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3020: LD_INT 86
3022: PPUSH
3023: LD_INT 65
3025: PPUSH
3026: LD_INT 5
3028: PPUSH
3029: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3033: LD_INT 165
3035: PPUSH
3036: LD_INT 73
3038: PPUSH
3039: LD_INT 5
3041: PPUSH
3042: CALL_OW 47
// end ; tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3046: LD_ADDR_VAR 0 7
3050: PUSH
3051: LD_INT 22
3053: PUSH
3054: LD_INT 3
3056: PUSH
3057: EMPTY
3058: LIST
3059: LIST
3060: PUSH
3061: LD_INT 2
3063: PUSH
3064: LD_INT 30
3066: PUSH
3067: LD_INT 31
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: PUSH
3074: LD_INT 30
3076: PUSH
3077: LD_INT 32
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: PUSH
3084: EMPTY
3085: LIST
3086: LIST
3087: LIST
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: PPUSH
3093: CALL_OW 69
3097: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3098: LD_ADDR_VAR 0 8
3102: PUSH
3103: LD_INT 22
3105: PUSH
3106: LD_INT 3
3108: PUSH
3109: EMPTY
3110: LIST
3111: LIST
3112: PUSH
3113: LD_INT 30
3115: PUSH
3116: LD_INT 4
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: PUSH
3123: EMPTY
3124: LIST
3125: LIST
3126: PPUSH
3127: CALL_OW 69
3131: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3132: LD_ADDR_VAR 0 10
3136: PUSH
3137: LD_INT 22
3139: PUSH
3140: LD_INT 3
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: PUSH
3147: LD_INT 30
3149: PUSH
3150: LD_INT 3
3152: PUSH
3153: EMPTY
3154: LIST
3155: LIST
3156: PUSH
3157: EMPTY
3158: LIST
3159: LIST
3160: PPUSH
3161: CALL_OW 69
3165: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3166: LD_ADDR_VAR 0 9
3170: PUSH
3171: LD_INT 22
3173: PUSH
3174: LD_INT 3
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: PUSH
3181: LD_INT 30
3183: PUSH
3184: LD_INT 6
3186: PUSH
3187: EMPTY
3188: LIST
3189: LIST
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PPUSH
3195: CALL_OW 69
3199: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3200: LD_ADDR_VAR 0 2
3204: PUSH
3205: LD_INT 22
3207: PUSH
3208: LD_INT 3
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: PUSH
3215: LD_INT 30
3217: PUSH
3218: LD_INT 1
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: PPUSH
3229: CALL_OW 69
3233: PUSH
3234: FOR_IN
3235: IFFALSE 3279
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3237: LD_VAR 0 2
3241: PPUSH
3242: CALL_OW 274
3246: PPUSH
3247: LD_INT 1
3249: PPUSH
3250: LD_INT 5000
3252: PPUSH
3253: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3257: LD_VAR 0 2
3261: PPUSH
3262: CALL_OW 274
3266: PPUSH
3267: LD_INT 2
3269: PPUSH
3270: LD_INT 3000
3272: PPUSH
3273: CALL_OW 277
// end ;
3277: GO 3234
3279: POP
3280: POP
// uc_side := 3 ;
3281: LD_ADDR_OWVAR 20
3285: PUSH
3286: LD_INT 3
3288: ST_TO_ADDR
// uc_nation := 3 ;
3289: LD_ADDR_OWVAR 21
3293: PUSH
3294: LD_INT 3
3296: ST_TO_ADDR
// skill := [ 2 , 2 , 3 ] [ Difficulty ] ;
3297: LD_ADDR_VAR 0 11
3301: PUSH
3302: LD_INT 2
3304: PUSH
3305: LD_INT 2
3307: PUSH
3308: LD_INT 3
3310: PUSH
3311: EMPTY
3312: LIST
3313: LIST
3314: LIST
3315: PUSH
3316: LD_OWVAR 67
3320: ARRAY
3321: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3322: LD_ADDR_EXP 48
3326: PUSH
3327: LD_STRING Pokryshkin
3329: PPUSH
3330: LD_INT 0
3332: PPUSH
3333: CALL 450 0 2
3337: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3338: LD_EXP 48
3342: PPUSH
3343: LD_INT 63
3345: PPUSH
3346: LD_INT 21
3348: PPUSH
3349: LD_INT 0
3351: PPUSH
3352: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3356: LD_EXP 48
3360: PPUSH
3361: CALL_OW 140
// InitHc ;
3365: CALL_OW 19
// for i in fac do
3369: LD_ADDR_VAR 0 2
3373: PUSH
3374: LD_VAR 0 10
3378: PUSH
3379: FOR_IN
3380: IFFALSE 3433
// begin for j = 1 to 6 do
3382: LD_ADDR_VAR 0 3
3386: PUSH
3387: DOUBLE
3388: LD_INT 1
3390: DEC
3391: ST_TO_ADDR
3392: LD_INT 6
3394: PUSH
3395: FOR_TO
3396: IFFALSE 3429
// begin PrepareHuman ( false , 3 , skill ) ;
3398: LD_INT 0
3400: PPUSH
3401: LD_INT 3
3403: PPUSH
3404: LD_VAR 0 11
3408: PPUSH
3409: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3413: CALL_OW 44
3417: PPUSH
3418: LD_VAR 0 2
3422: PPUSH
3423: CALL_OW 52
// end ;
3427: GO 3395
3429: POP
3430: POP
// end ;
3431: GO 3379
3433: POP
3434: POP
// for i in lab do
3435: LD_ADDR_VAR 0 2
3439: PUSH
3440: LD_VAR 0 9
3444: PUSH
3445: FOR_IN
3446: IFFALSE 3479
// begin PrepareHuman ( false , 4 , skill ) ;
3448: LD_INT 0
3450: PPUSH
3451: LD_INT 4
3453: PPUSH
3454: LD_VAR 0 11
3458: PPUSH
3459: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3463: CALL_OW 44
3467: PPUSH
3468: LD_VAR 0 2
3472: PPUSH
3473: CALL_OW 52
// end ;
3477: GO 3445
3479: POP
3480: POP
// for i in tw do
3481: LD_ADDR_VAR 0 2
3485: PUSH
3486: LD_VAR 0 7
3490: PUSH
3491: FOR_IN
3492: IFFALSE 3541
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3494: LD_VAR 0 2
3498: PPUSH
3499: LD_INT 42
3501: PUSH
3502: LD_INT 43
3504: PUSH
3505: EMPTY
3506: LIST
3507: LIST
3508: PUSH
3509: LD_INT 1
3511: PPUSH
3512: LD_INT 2
3514: PPUSH
3515: CALL_OW 12
3519: ARRAY
3520: PPUSH
3521: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3525: LD_VAR 0 11
3529: PPUSH
3530: LD_VAR 0 2
3534: PPUSH
3535: CALL 791 0 2
// end ;
3539: GO 3491
3541: POP
3542: POP
// for i in bar do
3543: LD_ADDR_VAR 0 2
3547: PUSH
3548: LD_VAR 0 8
3552: PUSH
3553: FOR_IN
3554: IFFALSE 3587
// begin PrepareHuman ( false , 1 , skill ) ;
3556: LD_INT 0
3558: PPUSH
3559: LD_INT 1
3561: PPUSH
3562: LD_VAR 0 11
3566: PPUSH
3567: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3571: CALL_OW 44
3575: PPUSH
3576: LD_VAR 0 2
3580: PPUSH
3581: CALL_OW 52
// end ;
3585: GO 3553
3587: POP
3588: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3589: LD_ADDR_VAR 0 13
3593: PUSH
3594: LD_INT 100
3596: PUSH
3597: LD_INT 9
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: PUSH
3604: LD_INT 135
3606: PUSH
3607: LD_INT 60
3609: PUSH
3610: EMPTY
3611: LIST
3612: LIST
3613: PUSH
3614: LD_INT 41
3616: PUSH
3617: LD_INT 6
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: PUSH
3624: LD_INT 22
3626: PUSH
3627: LD_INT 9
3629: PUSH
3630: EMPTY
3631: LIST
3632: LIST
3633: PUSH
3634: LD_INT 84
3636: PUSH
3637: LD_INT 14
3639: PUSH
3640: EMPTY
3641: LIST
3642: LIST
3643: PUSH
3644: EMPTY
3645: LIST
3646: LIST
3647: LIST
3648: LIST
3649: LIST
3650: ST_TO_ADDR
// vehicles := [ ] ;
3651: LD_ADDR_VAR 0 12
3655: PUSH
3656: EMPTY
3657: ST_TO_ADDR
// for i in spot_xy do
3658: LD_ADDR_VAR 0 2
3662: PUSH
3663: LD_VAR 0 13
3667: PUSH
3668: FOR_IN
3669: IFFALSE 3827
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3671: LD_ADDR_VAR 0 6
3675: PUSH
3676: LD_INT 3
3678: PPUSH
3679: LD_INT 3
3681: PPUSH
3682: LD_INT 22
3684: PPUSH
3685: LD_INT 1
3687: PPUSH
3688: LD_INT 1
3690: PPUSH
3691: LD_INT 42
3693: PUSH
3694: LD_INT 43
3696: PUSH
3697: LD_INT 44
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: LIST
3704: PUSH
3705: LD_INT 1
3707: PPUSH
3708: LD_INT 3
3710: PPUSH
3711: CALL_OW 12
3715: ARRAY
3716: PPUSH
3717: LD_INT 100
3719: PPUSH
3720: CALL 513 0 7
3724: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3725: LD_ADDR_VAR 0 12
3729: PUSH
3730: LD_VAR 0 12
3734: PPUSH
3735: LD_VAR 0 12
3739: PUSH
3740: LD_INT 1
3742: PLUS
3743: PPUSH
3744: LD_VAR 0 6
3748: PPUSH
3749: CALL_OW 2
3753: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3754: LD_VAR 0 6
3758: PPUSH
3759: LD_INT 3
3761: PPUSH
3762: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3766: LD_VAR 0 6
3770: PPUSH
3771: LD_VAR 0 2
3775: PUSH
3776: LD_INT 1
3778: ARRAY
3779: PPUSH
3780: LD_VAR 0 2
3784: PUSH
3785: LD_INT 2
3787: ARRAY
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3796: LD_INT 0
3798: PPUSH
3799: LD_INT 3
3801: PPUSH
3802: LD_VAR 0 11
3806: PPUSH
3807: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3811: CALL_OW 44
3815: PPUSH
3816: LD_VAR 0 6
3820: PPUSH
3821: CALL_OW 52
// end ;
3825: GO 3668
3827: POP
3828: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3829: LD_ADDR_VAR 0 2
3833: PUSH
3834: DOUBLE
3835: LD_INT 1
3837: DEC
3838: ST_TO_ADDR
3839: LD_INT 5
3841: PUSH
3842: LD_INT 7
3844: PUSH
3845: LD_INT 8
3847: PUSH
3848: EMPTY
3849: LIST
3850: LIST
3851: LIST
3852: PUSH
3853: LD_OWVAR 67
3857: ARRAY
3858: PUSH
3859: FOR_TO
3860: IFFALSE 3920
// begin PrepareHuman ( false , 1 , skill ) ;
3862: LD_INT 0
3864: PPUSH
3865: LD_INT 1
3867: PPUSH
3868: LD_VAR 0 11
3872: PPUSH
3873: CALL_OW 380
// un := CreateHuman ;
3877: LD_ADDR_VAR 0 5
3881: PUSH
3882: CALL_OW 44
3886: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3887: LD_VAR 0 5
3891: PPUSH
3892: LD_INT 11
3894: PPUSH
3895: LD_INT 0
3897: PPUSH
3898: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3902: LD_ADDR_EXP 51
3906: PUSH
3907: LD_EXP 51
3911: PUSH
3912: LD_VAR 0 5
3916: ADD
3917: ST_TO_ADDR
// end ;
3918: GO 3859
3920: POP
3921: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3922: LD_ADDR_VAR 0 2
3926: PUSH
3927: DOUBLE
3928: LD_INT 1
3930: DEC
3931: ST_TO_ADDR
3932: LD_INT 2
3934: PUSH
3935: LD_INT 3
3937: PUSH
3938: LD_INT 4
3940: PUSH
3941: EMPTY
3942: LIST
3943: LIST
3944: LIST
3945: PUSH
3946: LD_OWVAR 67
3950: ARRAY
3951: PUSH
3952: FOR_TO
3953: IFFALSE 4013
// begin PrepareHuman ( false , 1 , skill ) ;
3955: LD_INT 0
3957: PPUSH
3958: LD_INT 1
3960: PPUSH
3961: LD_VAR 0 11
3965: PPUSH
3966: CALL_OW 380
// un := CreateHuman ;
3970: LD_ADDR_VAR 0 5
3974: PUSH
3975: CALL_OW 44
3979: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
3980: LD_VAR 0 5
3984: PPUSH
3985: LD_INT 12
3987: PPUSH
3988: LD_INT 0
3990: PPUSH
3991: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
3995: LD_ADDR_EXP 49
3999: PUSH
4000: LD_EXP 49
4004: PUSH
4005: LD_VAR 0 5
4009: ADD
4010: ST_TO_ADDR
// end ;
4011: GO 3952
4013: POP
4014: POP
// for i = 1 to 2 do
4015: LD_ADDR_VAR 0 2
4019: PUSH
4020: DOUBLE
4021: LD_INT 1
4023: DEC
4024: ST_TO_ADDR
4025: LD_INT 2
4027: PUSH
4028: FOR_TO
4029: IFFALSE 4095
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4031: LD_INT 1
4033: PPUSH
4034: LD_INT 1
4036: PPUSH
4037: LD_VAR 0 11
4041: PPUSH
4042: CALL_OW 380
// un := CreateHuman ;
4046: LD_ADDR_VAR 0 5
4050: PUSH
4051: CALL_OW 44
4055: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4056: LD_VAR 0 5
4060: PPUSH
4061: LD_INT 39
4063: PPUSH
4064: LD_INT 12
4066: PPUSH
4067: LD_INT 3
4069: PPUSH
4070: LD_INT 0
4072: PPUSH
4073: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4077: LD_ADDR_EXP 50
4081: PUSH
4082: LD_EXP 50
4086: PUSH
4087: LD_VAR 0 5
4091: ADD
4092: ST_TO_ADDR
// end ;
4093: GO 4028
4095: POP
4096: POP
// for i = 1 to 3 do
4097: LD_ADDR_VAR 0 2
4101: PUSH
4102: DOUBLE
4103: LD_INT 1
4105: DEC
4106: ST_TO_ADDR
4107: LD_INT 3
4109: PUSH
4110: FOR_TO
4111: IFFALSE 4177
// begin PrepareHuman ( false , 1 , skill ) ;
4113: LD_INT 0
4115: PPUSH
4116: LD_INT 1
4118: PPUSH
4119: LD_VAR 0 11
4123: PPUSH
4124: CALL_OW 380
// un := CreateHuman ;
4128: LD_ADDR_VAR 0 5
4132: PUSH
4133: CALL_OW 44
4137: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4138: LD_VAR 0 5
4142: PPUSH
4143: LD_INT 180
4145: PPUSH
4146: LD_INT 11
4148: PPUSH
4149: LD_INT 4
4151: PPUSH
4152: LD_INT 0
4154: PPUSH
4155: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4159: LD_ADDR_EXP 54
4163: PUSH
4164: LD_EXP 54
4168: PUSH
4169: LD_VAR 0 5
4173: ADD
4174: ST_TO_ADDR
// end ;
4175: GO 4110
4177: POP
4178: POP
// ru_vehicles := vehicles ;
4179: LD_ADDR_EXP 52
4183: PUSH
4184: LD_VAR 0 12
4188: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4189: LD_ADDR_EXP 55
4193: PUSH
4194: LD_INT 131
4196: PUSH
4197: LD_INT 121
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: PUSH
4204: LD_INT 113
4206: PUSH
4207: LD_INT 90
4209: PUSH
4210: EMPTY
4211: LIST
4212: LIST
4213: PUSH
4214: LD_INT 93
4216: PUSH
4217: LD_INT 62
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: PUSH
4224: EMPTY
4225: LIST
4226: LIST
4227: LIST
4228: PUSH
4229: LD_INT 106
4231: PUSH
4232: LD_INT 54
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: PUSH
4239: LD_INT 120
4241: PUSH
4242: LD_INT 80
4244: PUSH
4245: EMPTY
4246: LIST
4247: LIST
4248: PUSH
4249: LD_INT 143
4251: PUSH
4252: LD_INT 120
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 154
4266: PUSH
4267: LD_INT 116
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: PUSH
4274: LD_INT 140
4276: PUSH
4277: LD_INT 93
4279: PUSH
4280: EMPTY
4281: LIST
4282: LIST
4283: PUSH
4284: LD_INT 130
4286: PUSH
4287: LD_INT 58
4289: PUSH
4290: EMPTY
4291: LIST
4292: LIST
4293: PUSH
4294: EMPTY
4295: LIST
4296: LIST
4297: LIST
4298: PUSH
4299: LD_INT 105
4301: PUSH
4302: LD_INT 106
4304: PUSH
4305: EMPTY
4306: LIST
4307: LIST
4308: PUSH
4309: LD_INT 134
4311: PUSH
4312: LD_INT 98
4314: PUSH
4315: EMPTY
4316: LIST
4317: LIST
4318: PUSH
4319: LD_INT 159
4321: PUSH
4322: LD_INT 113
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: LIST
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: LIST
4338: LIST
4339: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4340: LD_ADDR_VAR 0 2
4344: PUSH
4345: DOUBLE
4346: LD_INT 1
4348: DEC
4349: ST_TO_ADDR
4350: LD_OWVAR 67
4354: PUSH
4355: LD_INT 1
4357: MINUS
4358: PUSH
4359: FOR_TO
4360: IFFALSE 4393
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4362: LD_ADDR_EXP 53
4366: PUSH
4367: LD_EXP 53
4371: PUSH
4372: LD_INT 22
4374: PUSH
4375: LD_INT 1
4377: PUSH
4378: LD_INT 1
4380: PUSH
4381: LD_INT 43
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: LIST
4388: LIST
4389: ADD
4390: ST_TO_ADDR
4391: GO 4359
4393: POP
4394: POP
// end ;
4395: LD_VAR 0 1
4399: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4400: LD_INT 22
4402: PUSH
4403: LD_INT 3
4405: PUSH
4406: EMPTY
4407: LIST
4408: LIST
4409: PUSH
4410: LD_INT 21
4412: PUSH
4413: LD_INT 2
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: EMPTY
4421: LIST
4422: LIST
4423: PPUSH
4424: CALL_OW 69
4428: IFFALSE 4522
4430: GO 4432
4432: DISABLE
4433: LD_INT 0
4435: PPUSH
4436: PPUSH
// begin enable ;
4437: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4438: LD_ADDR_VAR 0 2
4442: PUSH
4443: LD_INT 22
4445: PUSH
4446: LD_INT 3
4448: PUSH
4449: EMPTY
4450: LIST
4451: LIST
4452: PUSH
4453: LD_INT 21
4455: PUSH
4456: LD_INT 2
4458: PUSH
4459: EMPTY
4460: LIST
4461: LIST
4462: PUSH
4463: EMPTY
4464: LIST
4465: LIST
4466: PPUSH
4467: CALL_OW 69
4471: ST_TO_ADDR
// if filter then
4472: LD_VAR 0 2
4476: IFFALSE 4522
// for i in filter do
4478: LD_ADDR_VAR 0 1
4482: PUSH
4483: LD_VAR 0 2
4487: PUSH
4488: FOR_IN
4489: IFFALSE 4520
// if GetFuel ( i ) < 20 then
4491: LD_VAR 0 1
4495: PPUSH
4496: CALL_OW 261
4500: PUSH
4501: LD_INT 20
4503: LESS
4504: IFFALSE 4518
// SetFuel ( i , 20 ) ;
4506: LD_VAR 0 1
4510: PPUSH
4511: LD_INT 20
4513: PPUSH
4514: CALL_OW 240
4518: GO 4488
4520: POP
4521: POP
// end ;
4522: PPOPN 2
4524: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4525: LD_EXP 53
4529: IFFALSE 4748
4531: GO 4533
4533: DISABLE
4534: LD_INT 0
4536: PPUSH
4537: PPUSH
4538: PPUSH
// begin enable ;
4539: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4540: LD_ADDR_VAR 0 2
4544: PUSH
4545: LD_INT 22
4547: PUSH
4548: LD_INT 3
4550: PUSH
4551: EMPTY
4552: LIST
4553: LIST
4554: PUSH
4555: LD_INT 30
4557: PUSH
4558: LD_INT 3
4560: PUSH
4561: EMPTY
4562: LIST
4563: LIST
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PPUSH
4569: CALL_OW 69
4573: ST_TO_ADDR
// can_produce := [ ] ;
4574: LD_ADDR_VAR 0 3
4578: PUSH
4579: EMPTY
4580: ST_TO_ADDR
// if not fac then
4581: LD_VAR 0 2
4585: NOT
4586: IFFALSE 4591
// begin disable ;
4588: DISABLE
// exit ;
4589: GO 4748
// end ; for i in fac do
4591: LD_ADDR_VAR 0 1
4595: PUSH
4596: LD_VAR 0 2
4600: PUSH
4601: FOR_IN
4602: IFFALSE 4640
// if UnitsInside ( i ) then
4604: LD_VAR 0 1
4608: PPUSH
4609: CALL_OW 313
4613: IFFALSE 4638
// can_produce := Insert ( can_produce , 1 , i ) ;
4615: LD_ADDR_VAR 0 3
4619: PUSH
4620: LD_VAR 0 3
4624: PPUSH
4625: LD_INT 1
4627: PPUSH
4628: LD_VAR 0 1
4632: PPUSH
4633: CALL_OW 2
4637: ST_TO_ADDR
4638: GO 4601
4640: POP
4641: POP
// if not can_produce then
4642: LD_VAR 0 3
4646: NOT
4647: IFFALSE 4651
// exit ;
4649: GO 4748
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4651: LD_VAR 0 3
4655: PUSH
4656: LD_INT 1
4658: PPUSH
4659: LD_VAR 0 3
4663: PPUSH
4664: CALL_OW 12
4668: ARRAY
4669: PPUSH
4670: LD_EXP 53
4674: PUSH
4675: LD_INT 1
4677: ARRAY
4678: PPUSH
4679: LD_EXP 53
4683: PUSH
4684: LD_INT 2
4686: ARRAY
4687: PPUSH
4688: LD_EXP 53
4692: PUSH
4693: LD_INT 3
4695: ARRAY
4696: PPUSH
4697: LD_EXP 53
4701: PUSH
4702: LD_INT 4
4704: ARRAY
4705: PPUSH
4706: CALL_OW 125
// for i = 1 to 4 do
4710: LD_ADDR_VAR 0 1
4714: PUSH
4715: DOUBLE
4716: LD_INT 1
4718: DEC
4719: ST_TO_ADDR
4720: LD_INT 4
4722: PUSH
4723: FOR_TO
4724: IFFALSE 4746
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4726: LD_ADDR_EXP 53
4730: PUSH
4731: LD_EXP 53
4735: PPUSH
4736: LD_INT 1
4738: PPUSH
4739: CALL_OW 3
4743: ST_TO_ADDR
4744: GO 4723
4746: POP
4747: POP
// end ;
4748: PPOPN 3
4750: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4751: LD_INT 0
4753: PPUSH
4754: PPUSH
4755: PPUSH
// for i = 1 to 6 do
4756: LD_ADDR_VAR 0 2
4760: PUSH
4761: DOUBLE
4762: LD_INT 1
4764: DEC
4765: ST_TO_ADDR
4766: LD_INT 6
4768: PUSH
4769: FOR_TO
4770: IFFALSE 4919
// begin PrepareHuman ( false , 3 , 3 ) ;
4772: LD_INT 0
4774: PPUSH
4775: LD_INT 3
4777: PPUSH
4778: LD_INT 3
4780: PPUSH
4781: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4785: LD_ADDR_VAR 0 3
4789: PUSH
4790: LD_INT 3
4792: PPUSH
4793: LD_INT 3
4795: PPUSH
4796: LD_INT 22
4798: PPUSH
4799: LD_INT 1
4801: PPUSH
4802: LD_INT 1
4804: PPUSH
4805: LD_INT 43
4807: PUSH
4808: LD_INT 42
4810: PUSH
4811: EMPTY
4812: LIST
4813: LIST
4814: PUSH
4815: LD_INT 1
4817: PPUSH
4818: LD_INT 2
4820: PPUSH
4821: CALL_OW 12
4825: ARRAY
4826: PPUSH
4827: LD_INT 70
4829: PPUSH
4830: CALL 513 0 7
4834: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4835: LD_VAR 0 3
4839: PPUSH
4840: LD_INT 4
4842: PPUSH
4843: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4847: LD_VAR 0 3
4851: PPUSH
4852: LD_INT 229
4854: PPUSH
4855: LD_INT 44
4857: PPUSH
4858: LD_INT 0
4860: PPUSH
4861: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4865: CALL_OW 44
4869: PPUSH
4870: LD_VAR 0 3
4874: PPUSH
4875: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4879: LD_ADDR_EXP 52
4883: PUSH
4884: LD_EXP 52
4888: PUSH
4889: LD_VAR 0 3
4893: ADD
4894: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
4895: LD_VAR 0 3
4899: PPUSH
4900: LD_INT 191
4902: PPUSH
4903: LD_INT 32
4905: PPUSH
4906: CALL_OW 111
// Wait ( 0 0$02 ) ;
4910: LD_INT 70
4912: PPUSH
4913: CALL_OW 67
// end ;
4917: GO 4769
4919: POP
4920: POP
// end ; end_of_file
4921: LD_VAR 0 1
4925: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
4926: LD_INT 0
4928: PPUSH
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
4933: PPUSH
4934: PPUSH
// InGameOn ;
4935: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
4939: LD_EXP 33
4943: PPUSH
4944: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
4948: LD_EXP 33
4952: PPUSH
4953: LD_EXP 40
4957: PPUSH
4958: CALL_OW 119
// if Bierezov then
4962: LD_EXP 41
4966: IFFALSE 4982
// ComTurnUnit ( Bierezov , Cornel ) ;
4968: LD_EXP 41
4972: PPUSH
4973: LD_EXP 40
4977: PPUSH
4978: CALL_OW 119
// for i in jmm_units do
4982: LD_ADDR_VAR 0 2
4986: PUSH
4987: LD_EXP 4
4991: PUSH
4992: FOR_IN
4993: IFFALSE 5011
// ComTurnUnit ( i , Cornel ) ;
4995: LD_VAR 0 2
4999: PPUSH
5000: LD_EXP 40
5004: PPUSH
5005: CALL_OW 119
5009: GO 4992
5011: POP
5012: POP
// units := cornel_units union Cornel ;
5013: LD_ADDR_VAR 0 3
5017: PUSH
5018: LD_EXP 6
5022: PUSH
5023: LD_EXP 40
5027: UNION
5028: ST_TO_ADDR
// repeat wait ( 1 ) ;
5029: LD_INT 1
5031: PPUSH
5032: CALL_OW 67
// for i in units do
5036: LD_ADDR_VAR 0 2
5040: PUSH
5041: LD_VAR 0 3
5045: PUSH
5046: FOR_IN
5047: IFFALSE 5080
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5049: LD_VAR 0 2
5053: PPUSH
5054: LD_EXP 33
5058: PPUSH
5059: CALL_OW 250
5063: PPUSH
5064: LD_EXP 33
5068: PPUSH
5069: CALL_OW 251
5073: PPUSH
5074: CALL_OW 111
5078: GO 5046
5080: POP
5081: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5082: LD_VAR 0 3
5086: PPUSH
5087: LD_INT 92
5089: PUSH
5090: LD_EXP 33
5094: PPUSH
5095: CALL_OW 250
5099: PUSH
5100: LD_EXP 33
5104: PPUSH
5105: CALL_OW 251
5109: PUSH
5110: LD_INT 10
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: LIST
5117: LIST
5118: PPUSH
5119: CALL_OW 72
5123: PUSH
5124: LD_VAR 0 3
5128: EQUAL
5129: IFFALSE 5029
// for i in units do
5131: LD_ADDR_VAR 0 2
5135: PUSH
5136: LD_VAR 0 3
5140: PUSH
5141: FOR_IN
5142: IFFALSE 5160
// ComTurnUnit ( i , JMM ) ;
5144: LD_VAR 0 2
5148: PPUSH
5149: LD_EXP 33
5153: PPUSH
5154: CALL_OW 119
5158: GO 5141
5160: POP
5161: POP
// ComTurnUnit ( Cornel , JMM ) ;
5162: LD_EXP 40
5166: PPUSH
5167: LD_EXP 33
5171: PPUSH
5172: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5176: LD_EXP 33
5180: PPUSH
5181: LD_STRING D1-JMM-1
5183: PPUSH
5184: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5188: LD_EXP 40
5192: PPUSH
5193: LD_STRING D1-Corn-1
5195: PPUSH
5196: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5200: LD_EXP 33
5204: PPUSH
5205: LD_EXP 40
5209: PPUSH
5210: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5214: LD_EXP 40
5218: PPUSH
5219: LD_EXP 33
5223: PPUSH
5224: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5228: LD_INT 35
5230: PPUSH
5231: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5235: LD_EXP 33
5239: PPUSH
5240: LD_EXP 40
5244: PPUSH
5245: CALL_OW 296
5249: PUSH
5250: LD_INT 6
5252: LESS
5253: IFFALSE 5228
// ChangeSideFog ( 4 , 1 ) ;
5255: LD_INT 4
5257: PPUSH
5258: LD_INT 1
5260: PPUSH
5261: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5265: LD_EXP 33
5269: PPUSH
5270: LD_EXP 40
5274: PPUSH
5275: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5279: LD_EXP 40
5283: PPUSH
5284: LD_EXP 33
5288: PPUSH
5289: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5293: LD_EXP 33
5297: PPUSH
5298: LD_STRING D1-JMM-2
5300: PPUSH
5301: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5305: LD_EXP 33
5309: PPUSH
5310: LD_STRING D1-JMM-2a
5312: PPUSH
5313: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5317: LD_EXP 40
5321: PPUSH
5322: LD_STRING D1-Corn-2
5324: PPUSH
5325: CALL_OW 88
// if bierezov_exist or debug then
5329: LD_EXP 7
5333: PUSH
5334: LD_EXP 1
5338: OR
5339: IFFALSE 5580
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5341: LD_EXP 40
5345: PPUSH
5346: LD_EXP 41
5350: PPUSH
5351: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5355: LD_INT 10
5357: PPUSH
5358: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5362: LD_EXP 40
5366: PPUSH
5367: LD_STRING D1a-Corn-1
5369: PPUSH
5370: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5374: LD_EXP 33
5378: PPUSH
5379: LD_EXP 41
5383: PPUSH
5384: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5388: LD_EXP 41
5392: PPUSH
5393: LD_EXP 33
5397: PPUSH
5398: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5402: LD_EXP 33
5406: PPUSH
5407: LD_STRING D1a-JMM-1
5409: PPUSH
5410: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5414: LD_EXP 33
5418: PPUSH
5419: LD_EXP 40
5423: PPUSH
5424: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5428: LD_EXP 40
5432: PPUSH
5433: LD_EXP 33
5437: PPUSH
5438: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5442: LD_EXP 40
5446: PPUSH
5447: LD_STRING D1a-Corn-2
5449: PPUSH
5450: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5454: LD_EXP 33
5458: PPUSH
5459: LD_STRING D1a-JMM-2
5461: PPUSH
5462: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5466: LD_EXP 40
5470: PPUSH
5471: LD_STRING D1a-Corn-3
5473: PPUSH
5474: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5478: LD_EXP 33
5482: PPUSH
5483: LD_STRING D1a-JMM-3
5485: PPUSH
5486: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5490: LD_EXP 40
5494: PPUSH
5495: LD_STRING D1a-Corn-4
5497: PPUSH
5498: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5502: LD_EXP 33
5506: PPUSH
5507: LD_STRING D1a-JMM-4
5509: PPUSH
5510: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5514: LD_EXP 40
5518: PPUSH
5519: LD_STRING D1a-Corn-5
5521: PPUSH
5522: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5526: LD_EXP 41
5530: PPUSH
5531: LD_EXP 40
5535: PPUSH
5536: CALL_OW 250
5540: PPUSH
5541: LD_EXP 40
5545: PPUSH
5546: CALL_OW 251
5550: PUSH
5551: LD_INT 2
5553: MINUS
5554: PPUSH
5555: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5559: LD_EXP 41
5563: PPUSH
5564: LD_EXP 40
5568: PPUSH
5569: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5573: LD_INT 10
5575: PPUSH
5576: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5580: LD_EXP 33
5584: PPUSH
5585: LD_STRING D1b-JMM-1
5587: PPUSH
5588: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5592: LD_EXP 40
5596: PPUSH
5597: LD_STRING D1b-Corn-1
5599: PPUSH
5600: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5604: LD_EXP 33
5608: PPUSH
5609: LD_STRING D1b-JMM-2
5611: PPUSH
5612: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5616: LD_EXP 40
5620: PPUSH
5621: LD_STRING D1b-Corn-2
5623: PPUSH
5624: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5628: LD_EXP 33
5632: PPUSH
5633: LD_STRING D1b-JMM-3
5635: PPUSH
5636: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5640: LD_INT 10
5642: PPUSH
5643: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5647: LD_EXP 42
5651: PPUSH
5652: LD_STRING D1b-Pow-3
5654: PPUSH
5655: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5659: LD_EXP 33
5663: PPUSH
5664: LD_STRING D1b-JMM-4
5666: PPUSH
5667: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5671: LD_EXP 40
5675: PPUSH
5676: LD_STRING D1b-Corn-4
5678: PPUSH
5679: CALL_OW 88
// if Khatam then
5683: LD_EXP 37
5687: IFFALSE 5703
// Say ( Khatam , D1b-Khat-4 ) else
5689: LD_EXP 37
5693: PPUSH
5694: LD_STRING D1b-Khat-4
5696: PPUSH
5697: CALL_OW 88
5701: GO 5739
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
5703: LD_EXP 6
5707: PPUSH
5708: LD_INT 26
5710: PUSH
5711: LD_INT 1
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: PPUSH
5718: CALL_OW 72
5722: PUSH
5723: LD_EXP 40
5727: PUSH
5728: EMPTY
5729: LIST
5730: DIFF
5731: PPUSH
5732: LD_STRING D1b-Sol1-4
5734: PPUSH
5735: CALL 601 0 2
// if Cyrus then
5739: LD_EXP 35
5743: IFFALSE 5757
// Say ( Cyrus , D1b-Cyrus-4 ) ;
5745: LD_EXP 35
5749: PPUSH
5750: LD_STRING D1b-Cyrus-4
5752: PPUSH
5753: CALL_OW 88
// if Lisa then
5757: LD_EXP 36
5761: IFFALSE 5819
// begin Say ( Lisa , D1b-Lisa-4 ) ;
5763: LD_EXP 36
5767: PPUSH
5768: LD_STRING D1b-Lisa-4
5770: PPUSH
5771: CALL_OW 88
// if Cyrus then
5775: LD_EXP 35
5779: IFFALSE 5819
// begin if not IsInUnit ( Cyrus ) then
5781: LD_EXP 35
5785: PPUSH
5786: CALL_OW 310
5790: NOT
5791: IFFALSE 5807
// ComTurnUnit ( Cyrus , Lisa ) ;
5793: LD_EXP 35
5797: PPUSH
5798: LD_EXP 36
5802: PPUSH
5803: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
5807: LD_EXP 35
5811: PPUSH
5812: LD_STRING D1b-Cyrus-5
5814: PPUSH
5815: CALL_OW 88
// end ; end ; SelectGroup ;
5819: CALL 2554 0 0
// Say ( JMM , D1d-JMM-1 ) ;
5823: LD_EXP 33
5827: PPUSH
5828: LD_STRING D1d-JMM-1
5830: PPUSH
5831: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
5835: LD_EXP 40
5839: PPUSH
5840: LD_STRING D1d-Corn-1
5842: PPUSH
5843: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
5847: LD_ADDR_VAR 0 2
5851: PUSH
5852: LD_EXP 4
5856: PUSH
5857: LD_EXP 6
5861: ADD
5862: PUSH
5863: LD_EXP 33
5867: ADD
5868: PUSH
5869: FOR_IN
5870: IFFALSE 5883
// ComHold ( i ) ;
5872: LD_VAR 0 2
5876: PPUSH
5877: CALL_OW 140
5881: GO 5869
5883: POP
5884: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
5885: LD_ADDR_VAR 0 4
5889: PUSH
5890: LD_INT 22
5892: PUSH
5893: LD_INT 1
5895: PUSH
5896: EMPTY
5897: LIST
5898: LIST
5899: PUSH
5900: LD_INT 21
5902: PUSH
5903: LD_INT 2
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: PPUSH
5914: CALL_OW 69
5918: ST_TO_ADDR
// if vehicles then
5919: LD_VAR 0 4
5923: IFFALSE 6261
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
5925: LD_EXP 6
5929: PPUSH
5930: LD_INT 55
5932: PUSH
5933: EMPTY
5934: LIST
5935: PPUSH
5936: CALL_OW 72
5940: IFFALSE 5979
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
5942: LD_ADDR_VAR 0 2
5946: PUSH
5947: LD_EXP 6
5951: PPUSH
5952: LD_INT 55
5954: PUSH
5955: EMPTY
5956: LIST
5957: PPUSH
5958: CALL_OW 72
5962: PUSH
5963: FOR_IN
5964: IFFALSE 5977
// ComExitVehicle ( i ) ;
5966: LD_VAR 0 2
5970: PPUSH
5971: CALL_OW 121
5975: GO 5963
5977: POP
5978: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
5979: LD_ADDR_VAR 0 5
5983: PUSH
5984: LD_VAR 0 4
5988: PPUSH
5989: LD_INT 34
5991: PUSH
5992: LD_INT 51
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: PPUSH
5999: CALL_OW 72
6003: ST_TO_ADDR
// if cargos then
6004: LD_VAR 0 5
6008: IFFALSE 6191
// begin vehicles := cargos ;
6010: LD_ADDR_VAR 0 4
6014: PUSH
6015: LD_VAR 0 5
6019: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6020: LD_ADDR_VAR 0 6
6024: PUSH
6025: LD_STRING 02_resources_4
6027: PPUSH
6028: LD_INT 0
6030: PPUSH
6031: CALL_OW 30
6035: ST_TO_ADDR
// if debug and not resources then
6036: LD_EXP 1
6040: PUSH
6041: LD_VAR 0 6
6045: NOT
6046: AND
6047: IFFALSE 6057
// resources := 160 ;
6049: LD_ADDR_VAR 0 6
6053: PUSH
6054: LD_INT 160
6056: ST_TO_ADDR
// if resources mod 10 then
6057: LD_VAR 0 6
6061: PUSH
6062: LD_INT 10
6064: MOD
6065: IFFALSE 6087
// resources := resources - resources mod 10 ;
6067: LD_ADDR_VAR 0 6
6071: PUSH
6072: LD_VAR 0 6
6076: PUSH
6077: LD_VAR 0 6
6081: PUSH
6082: LD_INT 10
6084: MOD
6085: MINUS
6086: ST_TO_ADDR
// if resources then
6087: LD_VAR 0 6
6091: IFFALSE 6191
// for i in cargos do
6093: LD_ADDR_VAR 0 2
6097: PUSH
6098: LD_VAR 0 5
6102: PUSH
6103: FOR_IN
6104: IFFALSE 6189
// begin if resources < 100 then
6106: LD_VAR 0 6
6110: PUSH
6111: LD_INT 100
6113: LESS
6114: IFFALSE 6136
// begin cargo := resources ;
6116: LD_ADDR_VAR 0 7
6120: PUSH
6121: LD_VAR 0 6
6125: ST_TO_ADDR
// resources := 0 ;
6126: LD_ADDR_VAR 0 6
6130: PUSH
6131: LD_INT 0
6133: ST_TO_ADDR
// end else
6134: GO 6158
// begin cargo := 100 ;
6136: LD_ADDR_VAR 0 7
6140: PUSH
6141: LD_INT 100
6143: ST_TO_ADDR
// resources := resources - 100 ;
6144: LD_ADDR_VAR 0 6
6148: PUSH
6149: LD_VAR 0 6
6153: PUSH
6154: LD_INT 100
6156: MINUS
6157: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6158: LD_VAR 0 2
6162: PPUSH
6163: LD_INT 1
6165: PPUSH
6166: LD_VAR 0 7
6170: PPUSH
6171: CALL_OW 290
// if resources = 0 then
6175: LD_VAR 0 6
6179: PUSH
6180: LD_INT 0
6182: EQUAL
6183: IFFALSE 6187
// break ;
6185: GO 6189
// end ;
6187: GO 6103
6189: POP
6190: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6191: LD_VAR 0 4
6195: PUSH
6196: LD_INT 1
6198: ARRAY
6199: PPUSH
6200: CALL_OW 311
6204: PPUSH
6205: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6209: LD_VAR 0 4
6213: PUSH
6214: LD_INT 1
6216: ARRAY
6217: PPUSH
6218: LD_INT 4
6220: PPUSH
6221: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6225: LD_EXP 40
6229: PPUSH
6230: LD_VAR 0 4
6234: PUSH
6235: LD_INT 1
6237: ARRAY
6238: PPUSH
6239: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6243: LD_INT 35
6245: PPUSH
6246: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6250: LD_EXP 40
6254: PPUSH
6255: CALL_OW 310
6259: IFFALSE 6243
// end ; InGameOff ;
6261: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6265: LD_STRING M1
6267: PPUSH
6268: CALL_OW 337
// SaveForQuickRestart ;
6272: CALL_OW 22
// cornel_active := true ;
6276: LD_ADDR_EXP 8
6280: PUSH
6281: LD_INT 1
6283: ST_TO_ADDR
// end ;
6284: LD_VAR 0 1
6288: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
6289: LD_EXP 33
6293: PPUSH
6294: LD_EXP 43
6298: PPUSH
6299: CALL_OW 296
6303: PUSH
6304: LD_INT 10
6306: LESS
6307: IFFALSE 7463
6309: GO 6311
6311: DISABLE
6312: LD_INT 0
6314: PPUSH
6315: PPUSH
6316: PPUSH
6317: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6318: LD_ADDR_VAR 0 2
6322: PUSH
6323: LD_INT 89
6325: PUSH
6326: LD_INT 34
6328: PUSH
6329: EMPTY
6330: LIST
6331: LIST
6332: PUSH
6333: LD_INT 138
6335: PUSH
6336: LD_INT 63
6338: PUSH
6339: EMPTY
6340: LIST
6341: LIST
6342: PUSH
6343: LD_INT 196
6345: PUSH
6346: LD_INT 84
6348: PUSH
6349: EMPTY
6350: LIST
6351: LIST
6352: PUSH
6353: LD_INT 135
6355: PUSH
6356: LD_INT 52
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: PUSH
6363: LD_INT 103
6365: PUSH
6366: LD_INT 39
6368: PUSH
6369: EMPTY
6370: LIST
6371: LIST
6372: PUSH
6373: LD_INT 58
6375: PUSH
6376: LD_INT 30
6378: PUSH
6379: EMPTY
6380: LIST
6381: LIST
6382: PUSH
6383: LD_INT 38
6385: PUSH
6386: LD_INT 51
6388: PUSH
6389: EMPTY
6390: LIST
6391: LIST
6392: PUSH
6393: EMPTY
6394: LIST
6395: LIST
6396: LIST
6397: LIST
6398: LIST
6399: LIST
6400: LIST
6401: ST_TO_ADDR
// InGameOn ;
6402: CALL_OW 8
// if jmm_units then
6406: LD_EXP 4
6410: IFFALSE 6474
// for i in jmm_units do
6412: LD_ADDR_VAR 0 1
6416: PUSH
6417: LD_EXP 4
6421: PUSH
6422: FOR_IN
6423: IFFALSE 6472
// begin if GetDistUnits ( i , JMM ) < 10 then
6425: LD_VAR 0 1
6429: PPUSH
6430: LD_EXP 33
6434: PPUSH
6435: CALL_OW 296
6439: PUSH
6440: LD_INT 10
6442: LESS
6443: IFFALSE 6461
// ComTurnUnit ( i , JMM ) else
6445: LD_VAR 0 1
6449: PPUSH
6450: LD_EXP 33
6454: PPUSH
6455: CALL_OW 119
6459: GO 6470
// ComHold ( i ) ;
6461: LD_VAR 0 1
6465: PPUSH
6466: CALL_OW 140
// end ;
6470: GO 6422
6472: POP
6473: POP
// if IsInUnit ( JMM ) then
6474: LD_EXP 33
6478: PPUSH
6479: CALL_OW 310
6483: IFFALSE 6508
// begin ComExitVehicle ( JMM ) ;
6485: LD_EXP 33
6489: PPUSH
6490: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6494: LD_EXP 33
6498: PPUSH
6499: LD_EXP 43
6503: PPUSH
6504: CALL_OW 172
// end ; Wait ( 10 ) ;
6508: LD_INT 10
6510: PPUSH
6511: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6515: LD_EXP 33
6519: PPUSH
6520: LD_EXP 43
6524: PPUSH
6525: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6529: LD_INT 35
6531: PPUSH
6532: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6536: LD_EXP 33
6540: PPUSH
6541: LD_EXP 43
6545: PPUSH
6546: CALL_OW 296
6550: PUSH
6551: LD_INT 6
6553: LESS
6554: IFFALSE 6529
// ComTurnUnit ( JMM , Lynch ) ;
6556: LD_EXP 33
6560: PPUSH
6561: LD_EXP 43
6565: PPUSH
6566: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6570: LD_ADDR_VAR 0 1
6574: PUSH
6575: LD_EXP 43
6579: PUSH
6580: LD_EXP 44
6584: PUSH
6585: LD_EXP 45
6589: PUSH
6590: LD_EXP 46
6594: PUSH
6595: EMPTY
6596: LIST
6597: LIST
6598: LIST
6599: LIST
6600: PUSH
6601: FOR_IN
6602: IFFALSE 6620
// ComTurnUnit ( i , JMM ) ;
6604: LD_VAR 0 1
6608: PPUSH
6609: LD_EXP 33
6613: PPUSH
6614: CALL_OW 119
6618: GO 6601
6620: POP
6621: POP
// Wait ( 0 0$0.3 ) ;
6622: LD_INT 10
6624: PPUSH
6625: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6629: LD_EXP 33
6633: PPUSH
6634: LD_STRING D2-JMM-1
6636: PPUSH
6637: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6641: LD_EXP 43
6645: PPUSH
6646: LD_STRING D2-Sol1-1
6648: PPUSH
6649: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6653: LD_EXP 33
6657: PPUSH
6658: LD_STRING D2-JMM-2
6660: PPUSH
6661: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6665: LD_EXP 43
6669: PPUSH
6670: LD_STRING D2-Sol1-2
6672: PPUSH
6673: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6677: LD_EXP 33
6681: PPUSH
6682: LD_STRING D2-JMM-3
6684: PPUSH
6685: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
6689: LD_EXP 43
6693: PPUSH
6694: LD_STRING D2-Sol1-3
6696: PPUSH
6697: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6701: LD_ADDR_VAR 0 1
6705: PUSH
6706: LD_INT 22
6708: PUSH
6709: LD_INT 8
6711: PUSH
6712: EMPTY
6713: LIST
6714: LIST
6715: PPUSH
6716: CALL_OW 69
6720: PUSH
6721: FOR_IN
6722: IFFALSE 6738
// SetSide ( i , 1 ) ;
6724: LD_VAR 0 1
6728: PPUSH
6729: LD_INT 1
6731: PPUSH
6732: CALL_OW 235
6736: GO 6721
6738: POP
6739: POP
// Say ( JMM , D2-JMM-4 ) ;
6740: LD_EXP 33
6744: PPUSH
6745: LD_STRING D2-JMM-4
6747: PPUSH
6748: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
6752: LD_INT 1
6754: PPUSH
6755: LD_INT 5
6757: PPUSH
6758: CALL_OW 332
// for i = 1 to points do
6762: LD_ADDR_VAR 0 1
6766: PUSH
6767: DOUBLE
6768: LD_INT 1
6770: DEC
6771: ST_TO_ADDR
6772: LD_VAR 0 2
6776: PUSH
6777: FOR_TO
6778: IFFALSE 6953
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6780: LD_VAR 0 2
6784: PUSH
6785: LD_VAR 0 1
6789: ARRAY
6790: PUSH
6791: LD_INT 1
6793: ARRAY
6794: PPUSH
6795: LD_VAR 0 2
6799: PUSH
6800: LD_VAR 0 1
6804: ARRAY
6805: PUSH
6806: LD_INT 2
6808: ARRAY
6809: PPUSH
6810: CALL_OW 84
// if i = 1 then
6814: LD_VAR 0 1
6818: PUSH
6819: LD_INT 1
6821: EQUAL
6822: IFFALSE 6836
// Say ( Lynch , D2-Sol1-4 ) ;
6824: LD_EXP 43
6828: PPUSH
6829: LD_STRING D2-Sol1-4
6831: PPUSH
6832: CALL_OW 88
// if i = 2 then
6836: LD_VAR 0 1
6840: PUSH
6841: LD_INT 2
6843: EQUAL
6844: IFFALSE 6858
// Say ( JMM , D2-JMM-5 ) ;
6846: LD_EXP 33
6850: PPUSH
6851: LD_STRING D2-JMM-5
6853: PPUSH
6854: CALL_OW 88
// if i = 4 then
6858: LD_VAR 0 1
6862: PUSH
6863: LD_INT 4
6865: EQUAL
6866: IFFALSE 6890
// begin RevealFogArea ( 1 , troopsArea ) ;
6868: LD_INT 1
6870: PPUSH
6871: LD_INT 6
6873: PPUSH
6874: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
6878: LD_EXP 43
6882: PPUSH
6883: LD_STRING D2-Sol1-5
6885: PPUSH
6886: CALL_OW 88
// end ; if i = 5 then
6890: LD_VAR 0 1
6894: PUSH
6895: LD_INT 5
6897: EQUAL
6898: IFFALSE 6912
// Say ( JMM , D2-JMM-6 ) ;
6900: LD_EXP 33
6904: PPUSH
6905: LD_STRING D2-JMM-6
6907: PPUSH
6908: CALL_OW 88
// if i = 7 then
6912: LD_VAR 0 1
6916: PUSH
6917: LD_INT 7
6919: EQUAL
6920: IFFALSE 6944
// begin RevealFogArea ( 1 , forestArea ) ;
6922: LD_INT 1
6924: PPUSH
6925: LD_INT 7
6927: PPUSH
6928: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
6932: LD_EXP 43
6936: PPUSH
6937: LD_STRING D2-Sol1-6
6939: PPUSH
6940: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
6944: LD_INT 46
6946: PPUSH
6947: CALL_OW 67
// end ;
6951: GO 6777
6953: POP
6954: POP
// CenterNowOnUnits ( JMM ) ;
6955: LD_EXP 33
6959: PPUSH
6960: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
6964: LD_EXP 33
6968: PPUSH
6969: LD_STRING D2-JMM-7
6971: PPUSH
6972: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
6976: LD_EXP 43
6980: PPUSH
6981: LD_STRING D2-Sol1-7
6983: PPUSH
6984: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
6988: LD_EXP 33
6992: PPUSH
6993: LD_STRING D2-JMM-8
6995: PPUSH
6996: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7000: LD_ADDR_VAR 0 4
7004: PUSH
7005: LD_INT 22
7007: PUSH
7008: LD_INT 1
7010: PUSH
7011: EMPTY
7012: LIST
7013: LIST
7014: PUSH
7015: LD_INT 30
7017: PUSH
7018: LD_INT 31
7020: PUSH
7021: EMPTY
7022: LIST
7023: LIST
7024: PUSH
7025: EMPTY
7026: LIST
7027: LIST
7028: PPUSH
7029: CALL_OW 69
7033: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7034: LD_EXP 43
7038: PPUSH
7039: LD_VAR 0 4
7043: PUSH
7044: LD_INT 1
7046: ARRAY
7047: PPUSH
7048: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7052: LD_ADDR_VAR 0 3
7056: PUSH
7057: LD_EXP 4
7061: PPUSH
7062: LD_INT 25
7064: PUSH
7065: LD_INT 1
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: PPUSH
7072: CALL_OW 72
7076: PPUSH
7077: LD_EXP 33
7081: PPUSH
7082: CALL_OW 74
7086: ST_TO_ADDR
// if sol then
7087: LD_VAR 0 3
7091: IFFALSE 7131
// if GetDistUnits ( JMM , sol ) < 10 then
7093: LD_EXP 33
7097: PPUSH
7098: LD_VAR 0 3
7102: PPUSH
7103: CALL_OW 296
7107: PUSH
7108: LD_INT 10
7110: LESS
7111: IFFALSE 7131
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7113: LD_VAR 0 3
7117: PPUSH
7118: LD_VAR 0 4
7122: PUSH
7123: LD_INT 2
7125: ARRAY
7126: PPUSH
7127: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7131: LD_INT 10
7133: PPUSH
7134: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7138: LD_EXP 33
7142: PPUSH
7143: LD_INT 65
7145: PPUSH
7146: LD_INT 101
7148: PPUSH
7149: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7153: LD_EXP 33
7157: PPUSH
7158: LD_INT 63
7160: PPUSH
7161: LD_INT 100
7163: PPUSH
7164: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
7168: LD_INT 35
7170: PPUSH
7171: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
7175: LD_EXP 33
7179: PPUSH
7180: LD_INT 65
7182: PPUSH
7183: LD_INT 101
7185: PPUSH
7186: CALL_OW 307
7190: IFFALSE 7168
// Say ( JMM , D2a-JMM-1 ) ;
7192: LD_EXP 33
7196: PPUSH
7197: LD_STRING D2a-JMM-1
7199: PPUSH
7200: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7204: LD_EXP 44
7208: PPUSH
7209: LD_INT 66
7211: PPUSH
7212: LD_INT 103
7214: PPUSH
7215: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
7219: LD_INT 35
7221: PPUSH
7222: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
7226: LD_EXP 44
7230: PPUSH
7231: LD_INT 66
7233: PPUSH
7234: LD_INT 103
7236: PPUSH
7237: CALL_OW 307
7241: IFFALSE 7219
// ComTurnUnit ( Walker , JMM ) ;
7243: LD_EXP 44
7247: PPUSH
7248: LD_EXP 33
7252: PPUSH
7253: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7257: LD_EXP 44
7261: PPUSH
7262: LD_STRING D2a-Sci1-1
7264: PPUSH
7265: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7269: LD_EXP 33
7273: PPUSH
7274: LD_EXP 44
7278: PPUSH
7279: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7283: LD_EXP 33
7287: PPUSH
7288: LD_STRING D2a-JMM-2
7290: PPUSH
7291: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7295: LD_EXP 44
7299: PPUSH
7300: LD_STRING D2a-Sci1-2
7302: PPUSH
7303: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7307: LD_EXP 33
7311: PPUSH
7312: LD_STRING D2a-JMM-3
7314: PPUSH
7315: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7319: LD_EXP 44
7323: PPUSH
7324: LD_STRING D2a-Sci1-3
7326: PPUSH
7327: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7331: LD_ADDR_EXP 4
7335: PUSH
7336: LD_EXP 4
7340: PUSH
7341: LD_EXP 43
7345: PUSH
7346: LD_EXP 44
7350: PUSH
7351: LD_EXP 45
7355: PUSH
7356: LD_EXP 46
7360: PUSH
7361: EMPTY
7362: LIST
7363: LIST
7364: LIST
7365: LIST
7366: ADD
7367: ST_TO_ADDR
// for i in jmm_units do
7368: LD_ADDR_VAR 0 1
7372: PUSH
7373: LD_EXP 4
7377: PUSH
7378: FOR_IN
7379: IFFALSE 7404
// if not IsInUnit ( i ) then
7381: LD_VAR 0 1
7385: PPUSH
7386: CALL_OW 310
7390: NOT
7391: IFFALSE 7402
// ComFree ( i ) ;
7393: LD_VAR 0 1
7397: PPUSH
7398: CALL_OW 139
7402: GO 7378
7404: POP
7405: POP
// InGameOff ;
7406: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
7410: LD_STRING MSolar1
7412: PPUSH
7413: CALL_OW 337
// jmm_on_west := true ;
7417: LD_ADDR_EXP 5
7421: PUSH
7422: LD_INT 1
7424: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7425: LD_INT 1050
7427: PPUSH
7428: CALL_OW 67
// frank_can_return := true ;
7432: LD_ADDR_EXP 12
7436: PUSH
7437: LD_INT 1
7439: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7440: LD_INT 6300
7442: PPUSH
7443: LD_INT 8400
7445: PPUSH
7446: CALL_OW 12
7450: PPUSH
7451: CALL_OW 67
// send_spec_patrol := true ;
7455: LD_ADDR_EXP 28
7459: PUSH
7460: LD_INT 1
7462: ST_TO_ADDR
// end ;
7463: PPOPN 4
7465: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7466: LD_INT 22
7468: PUSH
7469: LD_INT 1
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: PUSH
7476: LD_INT 34
7478: PUSH
7479: LD_INT 51
7481: PUSH
7482: EMPTY
7483: LIST
7484: LIST
7485: PUSH
7486: LD_INT 92
7488: PUSH
7489: LD_INT 63
7491: PUSH
7492: LD_INT 100
7494: PUSH
7495: LD_INT 5
7497: PUSH
7498: EMPTY
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: PUSH
7504: EMPTY
7505: LIST
7506: LIST
7507: LIST
7508: PUSH
7509: EMPTY
7510: LIST
7511: PPUSH
7512: CALL_OW 69
7516: PUSH
7517: LD_EXP 5
7521: NOT
7522: AND
7523: IFFALSE 7636
7525: GO 7527
7527: DISABLE
7528: LD_INT 0
7530: PPUSH
7531: PPUSH
// begin enable ;
7532: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
7533: LD_ADDR_VAR 0 2
7537: PUSH
7538: LD_INT 22
7540: PUSH
7541: LD_INT 1
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PUSH
7548: LD_INT 34
7550: PUSH
7551: LD_INT 51
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: PUSH
7558: LD_INT 92
7560: PUSH
7561: LD_INT 63
7563: PUSH
7564: LD_INT 100
7566: PUSH
7567: LD_INT 5
7569: PUSH
7570: EMPTY
7571: LIST
7572: LIST
7573: LIST
7574: LIST
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: LIST
7580: PUSH
7581: EMPTY
7582: LIST
7583: PPUSH
7584: CALL_OW 69
7588: ST_TO_ADDR
// if not filter then
7589: LD_VAR 0 2
7593: NOT
7594: IFFALSE 7598
// exit ;
7596: GO 7636
// for i in filter do
7598: LD_ADDR_VAR 0 1
7602: PUSH
7603: LD_VAR 0 2
7607: PUSH
7608: FOR_IN
7609: IFFALSE 7634
// begin SetFuel ( i , 0 ) ;
7611: LD_VAR 0 1
7615: PPUSH
7616: LD_INT 0
7618: PPUSH
7619: CALL_OW 240
// ComStop ( i ) ;
7623: LD_VAR 0 1
7627: PPUSH
7628: CALL_OW 141
// end ;
7632: GO 7608
7634: POP
7635: POP
// end ;
7636: PPOPN 2
7638: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
7639: LD_EXP 28
7643: IFFALSE 8608
7645: GO 7647
7647: DISABLE
7648: LD_INT 0
7650: PPUSH
7651: PPUSH
7652: PPUSH
7653: PPUSH
7654: PPUSH
7655: PPUSH
7656: PPUSH
// begin if not ru_spec_patrol then
7657: LD_EXP 50
7661: NOT
7662: IFFALSE 7666
// exit ;
7664: GO 8608
// dead1 := false ;
7666: LD_ADDR_VAR 0 1
7670: PUSH
7671: LD_INT 0
7673: ST_TO_ADDR
// dead2 := false ;
7674: LD_ADDR_VAR 0 2
7678: PUSH
7679: LD_INT 0
7681: ST_TO_ADDR
// inarea1 := false ;
7682: LD_ADDR_VAR 0 3
7686: PUSH
7687: LD_INT 0
7689: ST_TO_ADDR
// inarea2 := false ;
7690: LD_ADDR_VAR 0 4
7694: PUSH
7695: LD_INT 0
7697: ST_TO_ADDR
// tmp := [ ] ;
7698: LD_ADDR_VAR 0 6
7702: PUSH
7703: EMPTY
7704: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
7705: LD_EXP 50
7709: PPUSH
7710: LD_INT 75
7712: PPUSH
7713: LD_INT 101
7715: PPUSH
7716: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
7720: LD_INT 35
7722: PPUSH
7723: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
7727: LD_INT 1
7729: PPUSH
7730: LD_EXP 50
7734: PUSH
7735: LD_INT 1
7737: ARRAY
7738: PPUSH
7739: CALL_OW 292
7743: IFFALSE 7720
// ComStop ( ru_spec_patrol ) ;
7745: LD_EXP 50
7749: PPUSH
7750: CALL_OW 141
// Wait ( 0 0$02 ) ;
7754: LD_INT 70
7756: PPUSH
7757: CALL_OW 67
// DialogueOn ;
7761: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
7765: LD_EXP 50
7769: PUSH
7770: LD_INT 1
7772: ARRAY
7773: PPUSH
7774: LD_STRING D8-Rus1-1
7776: PPUSH
7777: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
7781: LD_EXP 33
7785: PPUSH
7786: LD_STRING D8-JMM-1
7788: PPUSH
7789: CALL_OW 88
// DialogueOff ;
7793: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
7797: LD_EXP 50
7801: PPUSH
7802: LD_INT 13
7804: PPUSH
7805: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
7809: LD_INT 35
7811: PPUSH
7812: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
7816: LD_VAR 0 1
7820: NOT
7821: PUSH
7822: LD_EXP 50
7826: PUSH
7827: LD_INT 1
7829: ARRAY
7830: PPUSH
7831: CALL_OW 301
7835: AND
7836: IFFALSE 7846
// dead1 := true ;
7838: LD_ADDR_VAR 0 1
7842: PUSH
7843: LD_INT 1
7845: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
7846: LD_VAR 0 2
7850: NOT
7851: PUSH
7852: LD_EXP 50
7856: PUSH
7857: LD_INT 2
7859: ARRAY
7860: PPUSH
7861: CALL_OW 301
7865: AND
7866: IFFALSE 7876
// dead2 := true ;
7868: LD_ADDR_VAR 0 2
7872: PUSH
7873: LD_INT 1
7875: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
7876: LD_VAR 0 3
7880: NOT
7881: PUSH
7882: LD_EXP 50
7886: PUSH
7887: LD_INT 1
7889: ARRAY
7890: PPUSH
7891: LD_INT 14
7893: PPUSH
7894: CALL_OW 308
7898: AND
7899: IFFALSE 7909
// inarea1 := true ;
7901: LD_ADDR_VAR 0 3
7905: PUSH
7906: LD_INT 1
7908: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
7909: LD_VAR 0 4
7913: NOT
7914: PUSH
7915: LD_EXP 50
7919: PUSH
7920: LD_INT 2
7922: ARRAY
7923: PPUSH
7924: LD_INT 14
7926: PPUSH
7927: CALL_OW 308
7931: AND
7932: IFFALSE 7942
// inarea2 := true ;
7934: LD_ADDR_VAR 0 4
7938: PUSH
7939: LD_INT 1
7941: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
7942: LD_VAR 0 1
7946: PUSH
7947: LD_VAR 0 2
7951: AND
7952: PUSH
7953: LD_VAR 0 1
7957: PUSH
7958: LD_VAR 0 4
7962: AND
7963: OR
7964: PUSH
7965: LD_VAR 0 2
7969: PUSH
7970: LD_VAR 0 3
7974: AND
7975: OR
7976: PUSH
7977: LD_VAR 0 3
7981: PUSH
7982: LD_VAR 0 4
7986: AND
7987: OR
7988: IFFALSE 7809
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
7990: LD_VAR 0 3
7994: PUSH
7995: LD_VAR 0 4
7999: AND
8000: PUSH
8001: LD_VAR 0 1
8005: PUSH
8006: LD_VAR 0 4
8010: AND
8011: OR
8012: PUSH
8013: LD_VAR 0 2
8017: PUSH
8018: LD_VAR 0 3
8022: AND
8023: OR
8024: IFFALSE 8588
// begin prepare_siege := true ;
8026: LD_ADDR_EXP 29
8030: PUSH
8031: LD_INT 1
8033: ST_TO_ADDR
// DialogueOn ;
8034: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8038: LD_VAR 0 3
8042: PUSH
8043: LD_VAR 0 4
8047: AND
8048: IFFALSE 8064
// Say ( JMM , D8b-JMM-1a ) else
8050: LD_EXP 33
8054: PPUSH
8055: LD_STRING D8b-JMM-1a
8057: PPUSH
8058: CALL_OW 88
8062: GO 8076
// Say ( JMM , D8b-JMM-1 ) ;
8064: LD_EXP 33
8068: PPUSH
8069: LD_STRING D8b-JMM-1
8071: PPUSH
8072: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8076: LD_EXP 4
8080: PPUSH
8081: LD_INT 26
8083: PUSH
8084: LD_INT 1
8086: PUSH
8087: EMPTY
8088: LIST
8089: LIST
8090: PPUSH
8091: CALL_OW 72
8095: PUSH
8096: LD_EXP 34
8100: PUSH
8101: LD_EXP 35
8105: PUSH
8106: LD_EXP 44
8110: PUSH
8111: LD_EXP 47
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: LIST
8120: LIST
8121: DIFF
8122: PPUSH
8123: LD_STRING D8b-Sol1-1
8125: PPUSH
8126: CALL 601 0 2
// if Cyrus and Cyrus in jmm_units then
8130: LD_EXP 35
8134: PUSH
8135: LD_EXP 35
8139: PUSH
8140: LD_EXP 4
8144: IN
8145: AND
8146: IFFALSE 8162
// Say ( Cyrus , D8b-Cyrus-1 ) else
8148: LD_EXP 35
8152: PPUSH
8153: LD_STRING D8b-Cyrus-1
8155: PPUSH
8156: CALL_OW 88
8160: GO 8174
// Say ( JMM , D8b-JMM-1a ) ;
8162: LD_EXP 33
8166: PPUSH
8167: LD_STRING D8b-JMM-1a
8169: PPUSH
8170: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8174: LD_EXP 36
8178: PUSH
8179: LD_EXP 36
8183: PUSH
8184: LD_EXP 4
8188: IN
8189: AND
8190: IFFALSE 8204
// Say ( Lisa , D8b-Lisa-2 ) ;
8192: LD_EXP 36
8196: PPUSH
8197: LD_STRING D8b-Lisa-2
8199: PPUSH
8200: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8204: LD_EXP 34
8208: PUSH
8209: LD_EXP 34
8213: PUSH
8214: LD_EXP 4
8218: IN
8219: AND
8220: IFFALSE 8236
// Say ( Bobby , D8b-Bobby-1 ) else
8222: LD_EXP 34
8226: PPUSH
8227: LD_STRING D8b-Bobby-1
8229: PPUSH
8230: CALL_OW 88
8234: GO 8296
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8236: LD_ADDR_VAR 0 5
8240: PUSH
8241: LD_EXP 4
8245: PPUSH
8246: LD_INT 26
8248: PUSH
8249: LD_INT 1
8251: PUSH
8252: EMPTY
8253: LIST
8254: LIST
8255: PPUSH
8256: CALL_OW 72
8260: PUSH
8261: LD_EXP 34
8265: PUSH
8266: LD_EXP 35
8270: PUSH
8271: LD_EXP 44
8275: PUSH
8276: LD_EXP 47
8280: PUSH
8281: EMPTY
8282: LIST
8283: LIST
8284: LIST
8285: LIST
8286: DIFF
8287: PPUSH
8288: LD_STRING D8b-Sol2-1
8290: PPUSH
8291: CALL 601 0 2
8295: ST_TO_ADDR
// DialogueOff ;
8296: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8300: LD_EXP 35
8304: PUSH
8305: LD_EXP 35
8309: PUSH
8310: LD_EXP 4
8314: IN
8315: AND
8316: IFFALSE 8341
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8318: LD_ADDR_VAR 0 6
8322: PUSH
8323: LD_VAR 0 6
8327: PPUSH
8328: LD_INT 1
8330: PPUSH
8331: LD_EXP 35
8335: PPUSH
8336: CALL_OW 2
8340: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8341: LD_EXP 34
8345: PUSH
8346: LD_EXP 34
8350: PUSH
8351: LD_EXP 4
8355: IN
8356: AND
8357: IFFALSE 8382
// tmp := Insert ( tmp , 1 , Bobby ) ;
8359: LD_ADDR_VAR 0 6
8363: PUSH
8364: LD_VAR 0 6
8368: PPUSH
8369: LD_INT 1
8371: PPUSH
8372: LD_EXP 34
8376: PPUSH
8377: CALL_OW 2
8381: ST_TO_ADDR
// if sol then
8382: LD_VAR 0 5
8386: IFFALSE 8411
// tmp := Insert ( tmp , 1 , sol ) ;
8388: LD_ADDR_VAR 0 6
8392: PUSH
8393: LD_VAR 0 6
8397: PPUSH
8398: LD_INT 1
8400: PPUSH
8401: LD_VAR 0 5
8405: PPUSH
8406: CALL_OW 2
8410: ST_TO_ADDR
// if tmp then
8411: LD_VAR 0 6
8415: IFFALSE 8547
// begin SetSide ( tmp , 8 ) ;
8417: LD_VAR 0 6
8421: PPUSH
8422: LD_INT 8
8424: PPUSH
8425: CALL_OW 235
// ComFree ( tmp ) ;
8429: LD_VAR 0 6
8433: PPUSH
8434: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8438: LD_VAR 0 6
8442: PPUSH
8443: LD_INT 15
8445: PPUSH
8446: CALL_OW 173
// AddComHold ( tmp ) ;
8450: LD_VAR 0 6
8454: PPUSH
8455: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8459: LD_INT 35
8461: PPUSH
8462: CALL_OW 67
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8466: LD_VAR 0 6
8470: PUSH
8471: LD_INT 1
8473: ARRAY
8474: PPUSH
8475: LD_INT 15
8477: PPUSH
8478: CALL_OW 308
8482: IFFALSE 8537
// begin RemoveUnit ( tmp [ 1 ] ) ;
8484: LD_VAR 0 6
8488: PUSH
8489: LD_INT 1
8491: ARRAY
8492: PPUSH
8493: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
8497: LD_ADDR_EXP 4
8501: PUSH
8502: LD_EXP 4
8506: PUSH
8507: LD_VAR 0 6
8511: PUSH
8512: LD_INT 1
8514: ARRAY
8515: DIFF
8516: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
8517: LD_ADDR_VAR 0 6
8521: PUSH
8522: LD_VAR 0 6
8526: PUSH
8527: LD_VAR 0 6
8531: PUSH
8532: LD_INT 1
8534: ARRAY
8535: DIFF
8536: ST_TO_ADDR
// end ; until tmp = 0 ;
8537: LD_VAR 0 6
8541: PUSH
8542: LD_INT 0
8544: EQUAL
8545: IFFALSE 8459
// end ; Wait ( 0 0$30 ) ;
8547: LD_INT 1050
8549: PPUSH
8550: CALL_OW 67
// if ru_spec_patrol then
8554: LD_EXP 50
8558: IFFALSE 8586
// for i in ru_spec_patrol do
8560: LD_ADDR_VAR 0 7
8564: PUSH
8565: LD_EXP 50
8569: PUSH
8570: FOR_IN
8571: IFFALSE 8584
// RemoveUnit ( i ) ;
8573: LD_VAR 0 7
8577: PPUSH
8578: CALL_OW 64
8582: GO 8570
8584: POP
8585: POP
// end else
8586: GO 8608
// begin prepare_siege := false ;
8588: LD_ADDR_EXP 29
8592: PUSH
8593: LD_INT 0
8595: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
8596: LD_EXP 33
8600: PPUSH
8601: LD_STRING D8a-JMM-1
8603: PPUSH
8604: CALL_OW 88
// end ; end ;
8608: PPOPN 7
8610: END
// every 0 0$10 trigger frank_can_return do var i , points ;
8611: LD_EXP 12
8615: IFFALSE 9749
8617: GO 8619
8619: DISABLE
8620: LD_INT 0
8622: PPUSH
8623: PPUSH
// begin uc_side := 8 ;
8624: LD_ADDR_OWVAR 20
8628: PUSH
8629: LD_INT 8
8631: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
8632: LD_ADDR_VAR 0 2
8636: PUSH
8637: LD_INT 59
8639: PUSH
8640: LD_INT 71
8642: PUSH
8643: EMPTY
8644: LIST
8645: LIST
8646: PUSH
8647: LD_INT 122
8649: PUSH
8650: LD_INT 117
8652: PUSH
8653: EMPTY
8654: LIST
8655: LIST
8656: PUSH
8657: EMPTY
8658: LIST
8659: LIST
8660: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
8661: LD_ADDR_EXP 47
8665: PUSH
8666: LD_STRING Frank
8668: PPUSH
8669: LD_INT 0
8671: PPUSH
8672: CALL 450 0 2
8676: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
8677: LD_ADDR_VAR 0 1
8681: PUSH
8682: LD_INT 1
8684: PPUSH
8685: LD_INT 2
8687: PPUSH
8688: CALL_OW 12
8692: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
8693: LD_EXP 47
8697: PPUSH
8698: LD_VAR 0 2
8702: PUSH
8703: LD_VAR 0 1
8707: ARRAY
8708: PUSH
8709: LD_INT 1
8711: ARRAY
8712: PPUSH
8713: LD_VAR 0 2
8717: PUSH
8718: LD_VAR 0 1
8722: ARRAY
8723: PUSH
8724: LD_INT 2
8726: ARRAY
8727: PPUSH
8728: LD_INT 0
8730: PPUSH
8731: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
8735: LD_EXP 47
8739: PPUSH
8740: LD_INT 1
8742: PPUSH
8743: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
8747: LD_INT 35
8749: PPUSH
8750: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
8754: LD_EXP 47
8758: PPUSH
8759: LD_EXP 33
8763: PPUSH
8764: CALL_OW 296
8768: PUSH
8769: LD_INT 8
8771: LESS
8772: IFFALSE 8747
// InGameOn ;
8774: CALL_OW 8
// CenterOnUnits ( JMM ) ;
8778: LD_EXP 33
8782: PPUSH
8783: CALL_OW 85
// if IsInUnit ( JMM ) then
8787: LD_EXP 33
8791: PPUSH
8792: CALL_OW 310
8796: IFFALSE 8807
// ComFree ( JMM ) ;
8798: LD_EXP 33
8802: PPUSH
8803: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
8807: LD_EXP 33
8811: PPUSH
8812: LD_EXP 47
8816: PPUSH
8817: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
8821: LD_EXP 47
8825: PPUSH
8826: LD_EXP 33
8830: PPUSH
8831: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
8835: LD_EXP 33
8839: PPUSH
8840: LD_STRING D6-JMM-1
8842: PPUSH
8843: CALL_OW 88
// repeat wait ( 3 ) ;
8847: LD_INT 3
8849: PPUSH
8850: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
8854: LD_EXP 33
8858: PPUSH
8859: LD_EXP 47
8863: PPUSH
8864: CALL_OW 296
8868: PUSH
8869: LD_INT 8
8871: LESS
8872: IFFALSE 8847
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
8874: LD_EXP 36
8878: PUSH
8879: LD_EXP 36
8883: PPUSH
8884: LD_EXP 47
8888: PPUSH
8889: CALL_OW 296
8893: PUSH
8894: LD_INT 20
8896: LESS
8897: AND
8898: IFFALSE 8923
// begin ComFree ( Lisa ) ;
8900: LD_EXP 36
8904: PPUSH
8905: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
8909: LD_EXP 36
8913: PPUSH
8914: LD_EXP 47
8918: PPUSH
8919: CALL_OW 172
// end ; if Lynch then
8923: LD_EXP 43
8927: IFFALSE 8952
// begin ComFree ( Lynch ) ;
8929: LD_EXP 43
8933: PPUSH
8934: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
8938: LD_EXP 43
8942: PPUSH
8943: LD_EXP 47
8947: PPUSH
8948: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
8952: LD_EXP 33
8956: PPUSH
8957: LD_EXP 47
8961: PPUSH
8962: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
8966: LD_EXP 47
8970: PPUSH
8971: LD_EXP 33
8975: PPUSH
8976: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
8980: LD_EXP 47
8984: PPUSH
8985: LD_STRING D6-Frank-1
8987: PPUSH
8988: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
8992: LD_INT 69
8994: PPUSH
8995: LD_INT 20
8997: PPUSH
8998: LD_INT 1
9000: PPUSH
9001: LD_INT 20
9003: NEG
9004: PPUSH
9005: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9009: LD_INT 69
9011: PPUSH
9012: LD_INT 20
9014: PPUSH
9015: LD_INT 1
9017: PPUSH
9018: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9022: LD_INT 190
9024: PPUSH
9025: LD_INT 31
9027: PPUSH
9028: LD_INT 1
9030: PPUSH
9031: LD_INT 20
9033: NEG
9034: PPUSH
9035: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9039: LD_INT 190
9041: PPUSH
9042: LD_INT 31
9044: PPUSH
9045: LD_INT 1
9047: PPUSH
9048: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9052: LD_INT 69
9054: PPUSH
9055: LD_INT 20
9057: PPUSH
9058: CALL_OW 84
// Wait ( 0 0$02 ) ;
9062: LD_INT 70
9064: PPUSH
9065: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9069: LD_EXP 33
9073: PPUSH
9074: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9078: LD_EXP 36
9082: PUSH
9083: LD_EXP 36
9087: PPUSH
9088: LD_EXP 47
9092: PPUSH
9093: CALL_OW 296
9097: PUSH
9098: LD_INT 20
9100: LESS
9101: AND
9102: PUSH
9103: LD_EXP 36
9107: PPUSH
9108: CALL_OW 302
9112: AND
9113: IFFALSE 9203
// begin ComFree ( Lisa ) ;
9115: LD_EXP 36
9119: PPUSH
9120: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
9124: LD_INT 35
9126: PPUSH
9127: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
9131: LD_EXP 36
9135: PPUSH
9136: LD_EXP 47
9140: PPUSH
9141: CALL_OW 296
9145: PUSH
9146: LD_INT 7
9148: LESS
9149: IFFALSE 9124
// Say ( Lisa , D6-Lisa-1 ) ;
9151: LD_EXP 36
9155: PPUSH
9156: LD_STRING D6-Lisa-1
9158: PPUSH
9159: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9163: LD_EXP 36
9167: PPUSH
9168: LD_EXP 47
9172: PPUSH
9173: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9177: LD_EXP 47
9181: PPUSH
9182: LD_EXP 36
9186: PPUSH
9187: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9191: LD_EXP 47
9195: PPUSH
9196: LD_STRING D6-Frank-2
9198: PPUSH
9199: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9203: LD_EXP 43
9207: PUSH
9208: LD_EXP 43
9212: PPUSH
9213: LD_EXP 47
9217: PPUSH
9218: CALL_OW 296
9222: PUSH
9223: LD_INT 20
9225: LESS
9226: AND
9227: PUSH
9228: LD_EXP 43
9232: PPUSH
9233: CALL_OW 302
9237: AND
9238: IFFALSE 9419
// begin ComTurnUnit ( Lynch , JMM ) ;
9240: LD_EXP 43
9244: PPUSH
9245: LD_EXP 33
9249: PPUSH
9250: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9254: LD_EXP 47
9258: PPUSH
9259: LD_EXP 33
9263: PPUSH
9264: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9268: LD_EXP 43
9272: PPUSH
9273: LD_STRING D6-Sol1-2
9275: PPUSH
9276: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9280: LD_EXP 33
9284: PPUSH
9285: LD_STRING D6-JMM-2
9287: PPUSH
9288: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9292: LD_EXP 47
9296: PPUSH
9297: LD_STRING D6-Frank-3
9299: PPUSH
9300: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9304: LD_EXP 33
9308: PPUSH
9309: LD_STRING D6-JMM-3
9311: PPUSH
9312: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9316: LD_EXP 47
9320: PPUSH
9321: LD_STRING D6-Frank-4
9323: PPUSH
9324: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9328: LD_EXP 47
9332: PPUSH
9333: LD_STRING D6-Frank-4a
9335: PPUSH
9336: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9340: LD_EXP 33
9344: PPUSH
9345: LD_STRING D6-JMM-4
9347: PPUSH
9348: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9352: LD_EXP 47
9356: PPUSH
9357: LD_STRING D6-Frank-5
9359: PPUSH
9360: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9364: LD_EXP 36
9368: PUSH
9369: LD_EXP 36
9373: PPUSH
9374: CALL_OW 302
9378: AND
9379: IFFALSE 9393
// Say ( Lisa , D6-Lisa-5 ) ;
9381: LD_EXP 36
9385: PPUSH
9386: LD_STRING D6-Lisa-5
9388: PPUSH
9389: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9393: LD_EXP 47
9397: PPUSH
9398: LD_STRING D6-Frank-6
9400: PPUSH
9401: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9405: LD_EXP 33
9409: PPUSH
9410: LD_STRING D6-JMM-6
9412: PPUSH
9413: CALL_OW 88
// end else
9417: GO 9534
// begin ComTurnUnit ( Frank , JMM ) ;
9419: LD_EXP 47
9423: PPUSH
9424: LD_EXP 33
9428: PPUSH
9429: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
9433: LD_EXP 47
9437: PPUSH
9438: LD_STRING D6-Frank-4
9440: PPUSH
9441: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9445: LD_EXP 47
9449: PPUSH
9450: LD_STRING D6-Frank-4a
9452: PPUSH
9453: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9457: LD_EXP 33
9461: PPUSH
9462: LD_STRING D6-JMM-4
9464: PPUSH
9465: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9469: LD_EXP 47
9473: PPUSH
9474: LD_STRING D6-Frank-5
9476: PPUSH
9477: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9481: LD_EXP 36
9485: PUSH
9486: LD_EXP 36
9490: PPUSH
9491: CALL_OW 302
9495: AND
9496: IFFALSE 9510
// Say ( Lisa , D6-Lisa-5 ) ;
9498: LD_EXP 36
9502: PPUSH
9503: LD_STRING D6-Lisa-5
9505: PPUSH
9506: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9510: LD_EXP 47
9514: PPUSH
9515: LD_STRING D6-Frank-6
9517: PPUSH
9518: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9522: LD_EXP 33
9526: PPUSH
9527: LD_STRING D6-JMM-6
9529: PPUSH
9530: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
9534: LD_STRING Q1
9536: PPUSH
9537: CALL_OW 97
9541: PUSH
9542: LD_INT 1
9544: DOUBLE
9545: EQUAL
9546: IFTRUE 9550
9548: GO 9561
9550: POP
// frank_send_to_scout := true ; 2 :
9551: LD_ADDR_EXP 14
9555: PUSH
9556: LD_INT 1
9558: ST_TO_ADDR
9559: GO 9581
9561: LD_INT 2
9563: DOUBLE
9564: EQUAL
9565: IFTRUE 9569
9567: GO 9580
9569: POP
// frank_send_to_scout := false ; end ;
9570: LD_ADDR_EXP 14
9574: PUSH
9575: LD_INT 0
9577: ST_TO_ADDR
9578: GO 9581
9580: POP
// InGameOff ;
9581: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
9585: LD_EXP 33
9589: PUSH
9590: LD_EXP 36
9594: PUSH
9595: LD_EXP 43
9599: PUSH
9600: EMPTY
9601: LIST
9602: LIST
9603: LIST
9604: PPUSH
9605: CALL_OW 139
// if frank_send_to_scout then
9609: LD_EXP 14
9613: IFFALSE 9670
// begin ComMoveXY ( Frank , 130 , 123 ) ;
9615: LD_EXP 47
9619: PPUSH
9620: LD_INT 130
9622: PPUSH
9623: LD_INT 123
9625: PPUSH
9626: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
9630: LD_INT 35
9632: PPUSH
9633: CALL_OW 67
// until not See ( 1 , Frank ) ;
9637: LD_INT 1
9639: PPUSH
9640: LD_EXP 47
9644: PPUSH
9645: CALL_OW 292
9649: NOT
9650: IFFALSE 9630
// Wait ( 0 0$02 ) ;
9652: LD_INT 70
9654: PPUSH
9655: CALL_OW 67
// RemoveUnit ( Frank ) ;
9659: LD_EXP 47
9663: PPUSH
9664: CALL_OW 64
// end else
9668: GO 9682
// SetSide ( Frank , 1 ) ;
9670: LD_EXP 47
9674: PPUSH
9675: LD_INT 1
9677: PPUSH
9678: CALL_OW 235
// send_attack_on_cornel_base := true ;
9682: LD_ADDR_EXP 25
9686: PUSH
9687: LD_INT 1
9689: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9690: LD_INT 35
9692: PPUSH
9693: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
9697: LD_ADDR_EXP 27
9701: PUSH
9702: LD_EXP 27
9706: PPUSH
9707: LD_STRING -
9709: PPUSH
9710: CALL 1093 0 2
9714: ST_TO_ADDR
// if debug then
9715: LD_EXP 1
9719: IFFALSE 9731
// debug_strings := time_to_prepare ;
9721: LD_ADDR_OWVAR 48
9725: PUSH
9726: LD_EXP 27
9730: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
9731: LD_EXP 27
9735: PUSH
9736: LD_INT 0
9738: EQUAL
9739: IFFALSE 9690
// cornel_prepared := true ;
9741: LD_ADDR_EXP 11
9745: PUSH
9746: LD_INT 1
9748: ST_TO_ADDR
// end ;
9749: PPOPN 2
9751: END
// every 0 0$01 trigger cornel_prepared do
9752: LD_EXP 11
9756: IFFALSE 10002
9758: GO 9760
9760: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
9761: LD_EXP 40
9765: PPUSH
9766: LD_STRING D3-Corn-1
9768: PPUSH
9769: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
9773: LD_INT 35
9775: PPUSH
9776: CALL_OW 67
// until cornel_counter = 0 ;
9780: LD_EXP 10
9784: PUSH
9785: LD_INT 0
9787: EQUAL
9788: IFFALSE 9773
// SayRadio ( Cornel , D3a-Corn-1 ) ;
9790: LD_EXP 40
9794: PPUSH
9795: LD_STRING D3a-Corn-1
9797: PPUSH
9798: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
9802: LD_EXP 33
9806: PPUSH
9807: LD_STRING D3a-JMM-1
9809: PPUSH
9810: CALL_OW 88
// end_mission_allowed := true ;
9814: LD_ADDR_EXP 20
9818: PUSH
9819: LD_INT 1
9821: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
9822: LD_STRING M2
9824: PPUSH
9825: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
9829: LD_INT 9
9831: PPUSH
9832: LD_INT 1
9834: PPUSH
9835: CALL_OW 424
// Wait ( 0 0$05 ) ;
9839: LD_INT 175
9841: PPUSH
9842: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
9846: LD_EXP 40
9850: PPUSH
9851: LD_STRING D3a-Corn-2
9853: PPUSH
9854: CALL_OW 94
// cornel_attack := true ;
9858: LD_ADDR_EXP 9
9862: PUSH
9863: LD_INT 1
9865: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
9866: LD_INT 105
9868: PPUSH
9869: CALL_OW 67
// AddMoreTanks ( ) ;
9873: CALL 4751 0 0
// if frank_send_to_scout then
9877: LD_EXP 14
9881: IFFALSE 10002
// begin InitHc ;
9883: CALL_OW 19
// InitUc ;
9887: CALL_OW 18
// uc_side := 8 ;
9891: LD_ADDR_OWVAR 20
9895: PUSH
9896: LD_INT 8
9898: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9899: LD_ADDR_EXP 47
9903: PUSH
9904: LD_STRING Frank
9906: PPUSH
9907: LD_INT 0
9909: PPUSH
9910: CALL 450 0 2
9914: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
9915: LD_EXP 47
9919: PPUSH
9920: LD_INT 6
9922: PPUSH
9923: LD_INT 9
9925: PPUSH
9926: LD_INT 0
9928: PPUSH
9929: CALL_OW 48
// ComCrawl ( Frank ) ;
9933: LD_EXP 47
9937: PPUSH
9938: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
9942: LD_INT 35
9944: PPUSH
9945: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
9949: LD_EXP 33
9953: PPUSH
9954: LD_EXP 47
9958: PPUSH
9959: CALL_OW 296
9963: PUSH
9964: LD_INT 9
9966: LESS
9967: IFFALSE 9942
// SetSide ( Frank , 1 ) ;
9969: LD_EXP 47
9973: PPUSH
9974: LD_INT 1
9976: PPUSH
9977: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
9981: LD_EXP 47
9985: PPUSH
9986: LD_STRING D6a-Frank-1
9988: PPUSH
9989: CALL_OW 88
// ComWalk ( Frank ) ;
9993: LD_EXP 47
9997: PPUSH
9998: CALL_OW 138
// end ; end ;
10002: END
// every 0 0$01 trigger solar_builded do
10003: LD_EXP 13
10007: IFFALSE 10111
10009: GO 10011
10011: DISABLE
// begin Wait ( 0 0$02 ) ;
10012: LD_INT 70
10014: PPUSH
10015: CALL_OW 67
// DialogueOn ;
10019: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10023: LD_EXP 33
10027: PPUSH
10028: LD_STRING D2b-JMM-1
10030: PPUSH
10031: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10035: LD_EXP 44
10039: PUSH
10040: LD_EXP 44
10044: PPUSH
10045: CALL_OW 302
10049: AND
10050: IFFALSE 10100
// begin Say ( Walker , D2b-Sci1-1 ) ;
10052: LD_EXP 44
10056: PPUSH
10057: LD_STRING D2b-Sci1-1
10059: PPUSH
10060: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10064: LD_EXP 33
10068: PPUSH
10069: LD_STRING D2b-JMM-2
10071: PPUSH
10072: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10076: LD_EXP 44
10080: PPUSH
10081: LD_STRING D2b-Sci1-2
10083: PPUSH
10084: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10088: LD_EXP 33
10092: PPUSH
10093: LD_STRING D2b-JMM-3
10095: PPUSH
10096: CALL_OW 88
// end ; DialogueOff ;
10100: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10104: LD_STRING MOutSol
10106: PPUSH
10107: CALL_OW 337
// end ;
10111: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10112: LD_EXP 13
10116: PUSH
10117: LD_EXP 33
10121: PPUSH
10122: CALL_OW 302
10126: AND
10127: PUSH
10128: LD_EXP 33
10132: PPUSH
10133: CALL 927 0 1
10137: AND
10138: PUSH
10139: LD_EXP 15
10143: NOT
10144: AND
10145: IFFALSE 10216
10147: GO 10149
10149: DISABLE
10150: LD_INT 0
10152: PPUSH
// begin jmm_in_veh := true ;
10153: LD_ADDR_EXP 15
10157: PUSH
10158: LD_INT 1
10160: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10161: LD_ADDR_VAR 0 1
10165: PUSH
10166: LD_INT 0
10168: PPUSH
10169: LD_INT 1
10171: PPUSH
10172: CALL_OW 12
10176: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10177: LD_INT 70
10179: PPUSH
10180: CALL_OW 67
// if i then
10184: LD_VAR 0 1
10188: IFFALSE 10204
// Say ( JMM , D2c-JMM-1 ) else
10190: LD_EXP 33
10194: PPUSH
10195: LD_STRING D2c-JMM-1
10197: PPUSH
10198: CALL_OW 88
10202: GO 10216
// Say ( JMM , D2c-JMM-1a ) ;
10204: LD_EXP 33
10208: PPUSH
10209: LD_STRING D2c-JMM-1a
10211: PPUSH
10212: CALL_OW 88
// end ;
10216: PPOPN 1
10218: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10219: LD_EXP 13
10223: PUSH
10224: LD_EXP 34
10228: PPUSH
10229: CALL_OW 302
10233: AND
10234: PUSH
10235: LD_EXP 34
10239: PPUSH
10240: CALL 927 0 1
10244: AND
10245: PUSH
10246: LD_EXP 16
10250: NOT
10251: AND
10252: IFFALSE 10284
10254: GO 10256
10256: DISABLE
// begin bobby_in_veh := true ;
10257: LD_ADDR_EXP 16
10261: PUSH
10262: LD_INT 1
10264: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10265: LD_INT 70
10267: PPUSH
10268: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10272: LD_EXP 34
10276: PPUSH
10277: LD_STRING D2c-Bobby-1
10279: PPUSH
10280: CALL_OW 88
10284: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10285: LD_EXP 13
10289: PUSH
10290: LD_EXP 36
10294: PPUSH
10295: CALL_OW 302
10299: AND
10300: PUSH
10301: LD_EXP 36
10305: PPUSH
10306: CALL 927 0 1
10310: AND
10311: PUSH
10312: LD_EXP 18
10316: NOT
10317: AND
10318: IFFALSE 10350
10320: GO 10322
10322: DISABLE
// begin lisa_in_veh := true ;
10323: LD_ADDR_EXP 18
10327: PUSH
10328: LD_INT 1
10330: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10331: LD_INT 70
10333: PPUSH
10334: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10338: LD_EXP 36
10342: PPUSH
10343: LD_STRING D2c-Lisa-1
10345: PPUSH
10346: CALL_OW 88
10350: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
10351: LD_EXP 13
10355: PUSH
10356: LD_EXP 35
10360: PPUSH
10361: CALL_OW 302
10365: AND
10366: PUSH
10367: LD_EXP 35
10371: PPUSH
10372: CALL 927 0 1
10376: AND
10377: PUSH
10378: LD_EXP 17
10382: NOT
10383: AND
10384: IFFALSE 10455
10386: GO 10388
10388: DISABLE
10389: LD_INT 0
10391: PPUSH
// begin cyrus_in_veh := true ;
10392: LD_ADDR_EXP 17
10396: PUSH
10397: LD_INT 1
10399: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10400: LD_ADDR_VAR 0 1
10404: PUSH
10405: LD_INT 0
10407: PPUSH
10408: LD_INT 1
10410: PPUSH
10411: CALL_OW 12
10415: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10416: LD_INT 70
10418: PPUSH
10419: CALL_OW 67
// if i then
10423: LD_VAR 0 1
10427: IFFALSE 10443
// Say ( Cyrus , D2c-Cyrus-1 ) else
10429: LD_EXP 35
10433: PPUSH
10434: LD_STRING D2c-Cyrus-1
10436: PPUSH
10437: CALL_OW 88
10441: GO 10455
// Say ( Cyrus , D2c-Cyrus-1a ) ;
10443: LD_EXP 35
10447: PPUSH
10448: LD_STRING D2c-Cyrus-1a
10450: PPUSH
10451: CALL_OW 88
// end ;
10455: PPOPN 1
10457: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
10458: LD_EXP 40
10462: PPUSH
10463: LD_INT 16
10465: PPUSH
10466: CALL_OW 308
10470: IFFALSE 10726
10472: GO 10474
10474: DISABLE
10475: LD_INT 0
10477: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
10478: LD_INT 3
10480: PPUSH
10481: LD_EXP 40
10485: PPUSH
10486: CALL_OW 471
// send_attack_on_cornel := true ;
10490: LD_ADDR_EXP 30
10494: PUSH
10495: LD_INT 1
10497: ST_TO_ADDR
// if ru_vehicles then
10498: LD_EXP 52
10502: IFFALSE 10536
// for i in ru_vehicles do
10504: LD_ADDR_VAR 0 1
10508: PUSH
10509: LD_EXP 52
10513: PUSH
10514: FOR_IN
10515: IFFALSE 10534
// ComAgressiveMove ( i , 215 , 69 ) ;
10517: LD_VAR 0 1
10521: PPUSH
10522: LD_INT 215
10524: PPUSH
10525: LD_INT 69
10527: PPUSH
10528: CALL_OW 114
10532: GO 10514
10534: POP
10535: POP
// if ru_patrol then
10536: LD_EXP 49
10540: IFFALSE 10574
// for i in ru_patrol do
10542: LD_ADDR_VAR 0 1
10546: PUSH
10547: LD_EXP 49
10551: PUSH
10552: FOR_IN
10553: IFFALSE 10572
// ComAgressiveMove ( i , 215 , 69 ) ;
10555: LD_VAR 0 1
10559: PPUSH
10560: LD_INT 215
10562: PPUSH
10563: LD_INT 69
10565: PPUSH
10566: CALL_OW 114
10570: GO 10552
10572: POP
10573: POP
// if frank_send_to_scout then
10574: LD_EXP 14
10578: IFFALSE 10592
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
10580: LD_EXP 47
10584: PPUSH
10585: LD_STRING D3b-Frank-1
10587: PPUSH
10588: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
10592: LD_INT 105
10594: PPUSH
10595: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
10599: LD_EXP 40
10603: PPUSH
10604: LD_STRING D4-Corn-1
10606: PPUSH
10607: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10611: LD_INT 35
10613: PPUSH
10614: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 6 ;
10618: LD_INT 22
10620: PUSH
10621: LD_INT 4
10623: PUSH
10624: EMPTY
10625: LIST
10626: LIST
10627: PUSH
10628: LD_INT 21
10630: PUSH
10631: LD_INT 1
10633: PUSH
10634: EMPTY
10635: LIST
10636: LIST
10637: PUSH
10638: LD_INT 50
10640: PUSH
10641: EMPTY
10642: LIST
10643: PUSH
10644: EMPTY
10645: LIST
10646: LIST
10647: LIST
10648: PPUSH
10649: CALL_OW 69
10653: PUSH
10654: LD_INT 6
10656: LESS
10657: IFFALSE 10611
// SayRadio ( Cornel , D5-Corn-1 ) ;
10659: LD_EXP 40
10663: PPUSH
10664: LD_STRING D5-Corn-1
10666: PPUSH
10667: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
10671: LD_EXP 40
10675: PPUSH
10676: LD_EXP 2
10680: PUSH
10681: LD_STRING Cornel
10683: STR
10684: PPUSH
10685: CALL_OW 38
// ChangeSideFog ( 4 , 8 ) ;
10689: LD_INT 4
10691: PPUSH
10692: LD_INT 8
10694: PPUSH
10695: CALL_OW 343
// Wait ( 0 0$01 ) ;
10699: LD_INT 35
10701: PPUSH
10702: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
10706: LD_INT 3
10708: PPUSH
10709: LD_EXP 40
10713: PPUSH
10714: CALL_OW 472
// send_attack_on_cornel := false ;
10718: LD_ADDR_EXP 30
10722: PUSH
10723: LD_INT 0
10725: ST_TO_ADDR
// end ;
10726: PPOPN 1
10728: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
10729: LD_INT 9
10731: PPUSH
10732: LD_INT 22
10734: PUSH
10735: LD_INT 1
10737: PUSH
10738: EMPTY
10739: LIST
10740: LIST
10741: PPUSH
10742: CALL_OW 70
10746: PUSH
10747: LD_EXP 31
10751: OR
10752: IFFALSE 10918
10754: GO 10756
10756: DISABLE
10757: LD_INT 0
10759: PPUSH
10760: PPUSH
// begin enable ;
10761: ENABLE
// if not game_end then
10762: LD_EXP 31
10766: NOT
10767: IFFALSE 10777
// game_end := true ;
10769: LD_ADDR_EXP 31
10773: PUSH
10774: LD_INT 1
10776: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
10777: LD_ADDR_VAR 0 2
10781: PUSH
10782: LD_INT 9
10784: PPUSH
10785: LD_INT 22
10787: PUSH
10788: LD_INT 1
10790: PUSH
10791: EMPTY
10792: LIST
10793: LIST
10794: PPUSH
10795: CALL_OW 70
10799: ST_TO_ADDR
// if not filter then
10800: LD_VAR 0 2
10804: NOT
10805: IFFALSE 10809
// exit ;
10807: GO 10918
// for i in filter do
10809: LD_ADDR_VAR 0 1
10813: PUSH
10814: LD_VAR 0 2
10818: PUSH
10819: FOR_IN
10820: IFFALSE 10916
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
10822: LD_VAR 0 1
10826: PPUSH
10827: CALL_OW 302
10831: PUSH
10832: LD_VAR 0 1
10836: PPUSH
10837: CALL_OW 247
10841: PUSH
10842: LD_INT 2
10844: EQUAL
10845: AND
10846: IFFALSE 10879
// begin veh_on_meta := true ;
10848: LD_ADDR_EXP 26
10852: PUSH
10853: LD_INT 1
10855: ST_TO_ADDR
// Save ( IsInUnit ( i ) ) ;
10856: LD_VAR 0 1
10860: PPUSH
10861: CALL_OW 310
10865: PPUSH
10866: CALL 10921 0 1
// RemoveUnit ( i ) ;
10870: LD_VAR 0 1
10874: PPUSH
10875: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
10879: LD_VAR 0 1
10883: PPUSH
10884: CALL_OW 302
10888: PUSH
10889: LD_VAR 0 1
10893: PPUSH
10894: CALL_OW 247
10898: PUSH
10899: LD_INT 1
10901: EQUAL
10902: AND
10903: IFFALSE 10914
// Save ( i ) ;
10905: LD_VAR 0 1
10909: PPUSH
10910: CALL 10921 0 1
// end ;
10914: GO 10819
10916: POP
10917: POP
// end ;
10918: PPOPN 2
10920: END
// export function Save ( i ) ; begin
10921: LD_INT 0
10923: PPUSH
// if i = JMM then
10924: LD_VAR 0 1
10928: PUSH
10929: LD_EXP 33
10933: EQUAL
10934: IFFALSE 11056
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
10936: LD_EXP 23
10940: PUSH
10941: LD_INT 22
10943: PUSH
10944: LD_INT 1
10946: PUSH
10947: EMPTY
10948: LIST
10949: LIST
10950: PUSH
10951: LD_INT 21
10953: PUSH
10954: LD_INT 1
10956: PUSH
10957: EMPTY
10958: LIST
10959: LIST
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: PPUSH
10965: CALL_OW 69
10969: PUSH
10970: LD_INT 1
10972: GREATER
10973: AND
10974: IFFALSE 11031
// begin show_query := false ;
10976: LD_ADDR_EXP 23
10980: PUSH
10981: LD_INT 0
10983: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
10984: LD_STRING Q2
10986: PPUSH
10987: CALL_OW 97
10991: PUSH
10992: LD_INT 1
10994: DOUBLE
10995: EQUAL
10996: IFTRUE 11000
10998: GO 11011
11000: POP
// wait_for_them := true ; 2 :
11001: LD_ADDR_EXP 24
11005: PUSH
11006: LD_INT 1
11008: ST_TO_ADDR
11009: GO 11031
11011: LD_INT 2
11013: DOUBLE
11014: EQUAL
11015: IFTRUE 11019
11017: GO 11030
11019: POP
// wait_for_them := false ; end ;
11020: LD_ADDR_EXP 24
11024: PUSH
11025: LD_INT 0
11027: ST_TO_ADDR
11028: GO 11031
11030: POP
// end ; save_group := save_group ^ JMM ;
11031: LD_ADDR_EXP 22
11035: PUSH
11036: LD_EXP 22
11040: PUSH
11041: LD_EXP 33
11045: ADD
11046: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11047: LD_EXP 33
11051: PPUSH
11052: CALL_OW 64
// end ; if i = Lisa then
11056: LD_VAR 0 1
11060: PUSH
11061: LD_EXP 36
11065: EQUAL
11066: IFFALSE 11093
// begin save_group := save_group ^ Lisa ;
11068: LD_ADDR_EXP 22
11072: PUSH
11073: LD_EXP 22
11077: PUSH
11078: LD_EXP 36
11082: ADD
11083: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11084: LD_EXP 36
11088: PPUSH
11089: CALL_OW 64
// end ; if i = Bobby then
11093: LD_VAR 0 1
11097: PUSH
11098: LD_EXP 34
11102: EQUAL
11103: IFFALSE 11130
// begin save_group := save_group ^ Bobby ;
11105: LD_ADDR_EXP 22
11109: PUSH
11110: LD_EXP 22
11114: PUSH
11115: LD_EXP 34
11119: ADD
11120: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11121: LD_EXP 34
11125: PPUSH
11126: CALL_OW 64
// end ; if i = Cyrus then
11130: LD_VAR 0 1
11134: PUSH
11135: LD_EXP 35
11139: EQUAL
11140: IFFALSE 11167
// begin save_group := save_group ^ Cyrus ;
11142: LD_ADDR_EXP 22
11146: PUSH
11147: LD_EXP 22
11151: PUSH
11152: LD_EXP 35
11156: ADD
11157: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11158: LD_EXP 35
11162: PPUSH
11163: CALL_OW 64
// end ; if i = Khatam then
11167: LD_VAR 0 1
11171: PUSH
11172: LD_EXP 37
11176: EQUAL
11177: IFFALSE 11204
// begin save_group := save_group ^ Khatam ;
11179: LD_ADDR_EXP 22
11183: PUSH
11184: LD_EXP 22
11188: PUSH
11189: LD_EXP 37
11193: ADD
11194: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11195: LD_EXP 37
11199: PPUSH
11200: CALL_OW 64
// end ; if i = Frank then
11204: LD_VAR 0 1
11208: PUSH
11209: LD_EXP 47
11213: EQUAL
11214: IFFALSE 11241
// begin save_group := save_group ^ Frank ;
11216: LD_ADDR_EXP 22
11220: PUSH
11221: LD_EXP 22
11225: PUSH
11226: LD_EXP 47
11230: ADD
11231: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11232: LD_EXP 47
11236: PPUSH
11237: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11241: LD_VAR 0 1
11245: PPUSH
11246: CALL_OW 302
11250: PUSH
11251: LD_VAR 0 1
11255: PPUSH
11256: CALL_OW 247
11260: PUSH
11261: LD_INT 1
11263: EQUAL
11264: AND
11265: PUSH
11266: LD_VAR 0 1
11270: PUSH
11271: LD_EXP 22
11275: IN
11276: NOT
11277: AND
11278: IFFALSE 11305
// begin save_others := save_others ^ i ;
11280: LD_ADDR_EXP 21
11284: PUSH
11285: LD_EXP 21
11289: PUSH
11290: LD_VAR 0 1
11294: ADD
11295: ST_TO_ADDR
// RemoveUnit ( i ) ;
11296: LD_VAR 0 1
11300: PPUSH
11301: CALL_OW 64
// end ; end ;
11305: LD_VAR 0 2
11309: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
11310: LD_EXP 23
11314: NOT
11315: PUSH
11316: LD_EXP 24
11320: NOT
11321: AND
11322: PUSH
11323: LD_INT 22
11325: PUSH
11326: LD_INT 1
11328: PUSH
11329: EMPTY
11330: LIST
11331: LIST
11332: PUSH
11333: LD_INT 21
11335: PUSH
11336: LD_INT 1
11338: PUSH
11339: EMPTY
11340: LIST
11341: LIST
11342: PUSH
11343: EMPTY
11344: LIST
11345: LIST
11346: PPUSH
11347: CALL_OW 69
11351: PUSH
11352: LD_INT 0
11354: EQUAL
11355: OR
11356: IFFALSE 11365
11358: GO 11360
11360: DISABLE
// EndMission ;
11361: CALL 11366 0 0
11365: END
// export function EndMission ; var i ; begin
11366: LD_INT 0
11368: PPUSH
11369: PPUSH
// Wait ( 0 0$02 ) ;
11370: LD_INT 70
11372: PPUSH
11373: CALL_OW 67
// if solar_builded then
11377: LD_EXP 13
11381: IFFALSE 11395
// AddMedal ( Solar1 , 1 ) else
11383: LD_STRING Solar1
11385: PPUSH
11386: LD_INT 1
11388: PPUSH
11389: CALL_OW 101
11393: GO 11406
// AddMedal ( Solar1 , - 1 ) ;
11395: LD_STRING Solar1
11397: PPUSH
11398: LD_INT 1
11400: NEG
11401: PPUSH
11402: CALL_OW 101
// if veh_on_meta then
11406: LD_EXP 26
11410: IFFALSE 11424
// AddMedal ( Solar2 , 1 ) else
11412: LD_STRING Solar2
11414: PPUSH
11415: LD_INT 1
11417: PPUSH
11418: CALL_OW 101
11422: GO 11454
// if solar_builded then
11424: LD_EXP 13
11428: IFFALSE 11443
// AddMedal ( Solar2 , - 1 ) else
11430: LD_STRING Solar2
11432: PPUSH
11433: LD_INT 1
11435: NEG
11436: PPUSH
11437: CALL_OW 101
11441: GO 11454
// AddMedal ( Solar2 , - 2 ) ;
11443: LD_STRING Solar2
11445: PPUSH
11446: LD_INT 2
11448: NEG
11449: PPUSH
11450: CALL_OW 101
// if lose_counter = 0 then
11454: LD_EXP 32
11458: PUSH
11459: LD_INT 0
11461: EQUAL
11462: IFFALSE 11476
// AddMedal ( No , 1 ) else
11464: LD_STRING No
11466: PPUSH
11467: LD_INT 1
11469: PPUSH
11470: CALL_OW 101
11474: GO 11520
// if lose_counter > 0 and lose_counter < 4 then
11476: LD_EXP 32
11480: PUSH
11481: LD_INT 0
11483: GREATER
11484: PUSH
11485: LD_EXP 32
11489: PUSH
11490: LD_INT 4
11492: LESS
11493: AND
11494: IFFALSE 11509
// AddMedal ( No , - 1 ) else
11496: LD_STRING No
11498: PPUSH
11499: LD_INT 1
11501: NEG
11502: PPUSH
11503: CALL_OW 101
11507: GO 11520
// AddMedal ( UpTo4 , - 1 ) ;
11509: LD_STRING UpTo4
11511: PPUSH
11512: LD_INT 1
11514: NEG
11515: PPUSH
11516: CALL_OW 101
// GiveMedals ( MAIN ) ;
11520: LD_STRING MAIN
11522: PPUSH
11523: CALL_OW 102
// if IsDead ( Pokryshkin ) then
11527: LD_EXP 48
11531: PPUSH
11532: CALL_OW 301
11536: IFFALSE 11576
// for i in save_group ^ save_others do
11538: LD_ADDR_VAR 0 2
11542: PUSH
11543: LD_EXP 22
11547: PUSH
11548: LD_EXP 21
11552: ADD
11553: PUSH
11554: FOR_IN
11555: IFFALSE 11574
// AddExperience ( i , skill_combat , 1500 ) ;
11557: LD_VAR 0 2
11561: PPUSH
11562: LD_INT 1
11564: PPUSH
11565: LD_INT 1500
11567: PPUSH
11568: CALL_OW 492
11572: GO 11554
11574: POP
11575: POP
// RewardPeople ( save_group ^ save_others ) ;
11576: LD_EXP 22
11580: PUSH
11581: LD_EXP 21
11585: ADD
11586: PPUSH
11587: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11591: LD_EXP 33
11595: PPUSH
11596: LD_EXP 2
11600: PUSH
11601: LD_STRING JMM
11603: STR
11604: PPUSH
11605: CALL_OW 38
// if Bobby in save_group then
11609: LD_EXP 34
11613: PUSH
11614: LD_EXP 22
11618: IN
11619: IFFALSE 11639
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11621: LD_EXP 34
11625: PPUSH
11626: LD_EXP 2
11630: PUSH
11631: LD_STRING Bobby
11633: STR
11634: PPUSH
11635: CALL_OW 38
// if Cyrus in save_group then
11639: LD_EXP 35
11643: PUSH
11644: LD_EXP 22
11648: IN
11649: IFFALSE 11669
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11651: LD_EXP 35
11655: PPUSH
11656: LD_EXP 2
11660: PUSH
11661: LD_STRING Cyrus
11663: STR
11664: PPUSH
11665: CALL_OW 38
// if Lisa in save_group then
11669: LD_EXP 36
11673: PUSH
11674: LD_EXP 22
11678: IN
11679: IFFALSE 11699
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
11681: LD_EXP 36
11685: PPUSH
11686: LD_EXP 2
11690: PUSH
11691: LD_STRING Lisa
11693: STR
11694: PPUSH
11695: CALL_OW 38
// if Frank in save_group then
11699: LD_EXP 47
11703: PUSH
11704: LD_EXP 22
11708: IN
11709: IFFALSE 11729
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
11711: LD_EXP 47
11715: PPUSH
11716: LD_EXP 2
11720: PUSH
11721: LD_STRING Frank
11723: STR
11724: PPUSH
11725: CALL_OW 38
// if Khatam in save_group then
11729: LD_EXP 37
11733: PUSH
11734: LD_EXP 22
11738: IN
11739: IFFALSE 11759
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
11741: LD_EXP 37
11745: PPUSH
11746: LD_EXP 2
11750: PUSH
11751: LD_STRING Khatam
11753: STR
11754: PPUSH
11755: CALL_OW 38
// if save_others then
11759: LD_EXP 21
11763: IFFALSE 11777
// SaveCharacters ( save_others , 03_others ) ;
11765: LD_EXP 21
11769: PPUSH
11770: LD_STRING 03_others
11772: PPUSH
11773: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) then
11777: LD_EXP 41
11781: PUSH
11782: LD_EXP 41
11786: PPUSH
11787: CALL_OW 302
11791: AND
11792: IFFALSE 11804
// begin ResetFog ;
11794: CALL_OW 335
// DisplayEndingScene ;
11798: CALL 11826 0 0
// end else
11802: GO 11817
// DeleteCharacters ( mission_prefix & Cornel ) ;
11804: LD_EXP 2
11808: PUSH
11809: LD_STRING Cornel
11811: STR
11812: PPUSH
11813: CALL_OW 40
// YouWin ;
11817: CALL_OW 103
// end ;
11821: LD_VAR 0 1
11825: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
11826: LD_INT 0
11828: PPUSH
11829: PPUSH
11830: PPUSH
11831: PPUSH
11832: PPUSH
11833: PPUSH
// InGameOn ;
11834: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
11838: LD_INT 208
11840: PPUSH
11841: LD_INT 62
11843: PPUSH
11844: LD_INT 1
11846: PPUSH
11847: LD_INT 10
11849: NEG
11850: PPUSH
11851: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
11855: LD_INT 208
11857: PPUSH
11858: LD_INT 62
11860: PPUSH
11861: LD_INT 1
11863: PPUSH
11864: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11868: LD_ADDR_VAR 0 3
11872: PUSH
11873: LD_INT 22
11875: PUSH
11876: LD_INT 3
11878: PUSH
11879: EMPTY
11880: LIST
11881: LIST
11882: PUSH
11883: LD_INT 2
11885: PUSH
11886: LD_INT 21
11888: PUSH
11889: LD_INT 2
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: PUSH
11896: LD_INT 21
11898: PUSH
11899: LD_INT 1
11901: PUSH
11902: EMPTY
11903: LIST
11904: LIST
11905: PUSH
11906: EMPTY
11907: LIST
11908: LIST
11909: LIST
11910: PUSH
11911: EMPTY
11912: LIST
11913: LIST
11914: PPUSH
11915: CALL_OW 69
11919: ST_TO_ADDR
// if filter then
11920: LD_VAR 0 3
11924: IFFALSE 11952
// for i in filter do
11926: LD_ADDR_VAR 0 2
11930: PUSH
11931: LD_VAR 0 3
11935: PUSH
11936: FOR_IN
11937: IFFALSE 11950
// RemoveUnit ( i ) ;
11939: LD_VAR 0 2
11943: PPUSH
11944: CALL_OW 64
11948: GO 11936
11950: POP
11951: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
11952: LD_ADDR_VAR 0 3
11956: PUSH
11957: LD_INT 22
11959: PUSH
11960: LD_INT 4
11962: PUSH
11963: EMPTY
11964: LIST
11965: LIST
11966: PUSH
11967: LD_INT 21
11969: PUSH
11970: LD_INT 1
11972: PUSH
11973: EMPTY
11974: LIST
11975: LIST
11976: PUSH
11977: EMPTY
11978: LIST
11979: LIST
11980: PPUSH
11981: CALL_OW 69
11985: ST_TO_ADDR
// if filter then
11986: LD_VAR 0 3
11990: IFFALSE 12021
// for i in filter do
11992: LD_ADDR_VAR 0 2
11996: PUSH
11997: LD_VAR 0 3
12001: PUSH
12002: FOR_IN
12003: IFFALSE 12019
// SetLives ( i , 0 ) ;
12005: LD_VAR 0 2
12009: PPUSH
12010: LD_INT 0
12012: PPUSH
12013: CALL_OW 234
12017: GO 12002
12019: POP
12020: POP
// uc_side := 4 ;
12021: LD_ADDR_OWVAR 20
12025: PUSH
12026: LD_INT 4
12028: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12029: LD_ADDR_VAR 0 4
12033: PUSH
12034: LD_STRING Cornell
12036: PPUSH
12037: LD_INT 0
12039: PPUSH
12040: CALL 450 0 2
12044: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12045: LD_VAR 0 4
12049: PPUSH
12050: LD_INT 208
12052: PPUSH
12053: LD_INT 62
12055: PPUSH
12056: LD_INT 0
12058: PPUSH
12059: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12063: LD_VAR 0 4
12067: PPUSH
12068: LD_INT 100
12070: PPUSH
12071: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12075: LD_INT 3
12077: PPUSH
12078: LD_VAR 0 4
12082: PPUSH
12083: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12087: LD_INT 4
12089: PPUSH
12090: LD_INT 3
12092: PPUSH
12093: LD_INT 1
12095: PPUSH
12096: LD_INT 1
12098: PPUSH
12099: CALL_OW 80
// uc_side := 3 ;
12103: LD_ADDR_OWVAR 20
12107: PUSH
12108: LD_INT 3
12110: ST_TO_ADDR
// uc_nation := 3 ;
12111: LD_ADDR_OWVAR 21
12115: PUSH
12116: LD_INT 3
12118: ST_TO_ADDR
// InitHc ;
12119: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12123: LD_ADDR_VAR 0 5
12127: PUSH
12128: LD_STRING Mikhail
12130: PPUSH
12131: LD_INT 0
12133: PPUSH
12134: CALL 450 0 2
12138: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12139: LD_INT 1
12141: PPUSH
12142: LD_INT 1
12144: PPUSH
12145: LD_INT 0
12147: PPUSH
12148: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12152: LD_ADDR_VAR 0 6
12156: PUSH
12157: LD_VAR 0 6
12161: PUSH
12162: CALL_OW 44
12166: ADD
12167: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12168: LD_ADDR_VAR 0 6
12172: PUSH
12173: LD_VAR 0 6
12177: PUSH
12178: CALL_OW 44
12182: ADD
12183: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12184: LD_INT 2
12186: PPUSH
12187: LD_INT 4
12189: PPUSH
12190: LD_INT 0
12192: PPUSH
12193: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12197: LD_ADDR_VAR 0 6
12201: PUSH
12202: LD_VAR 0 6
12206: PUSH
12207: CALL_OW 44
12211: ADD
12212: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12213: LD_VAR 0 5
12217: PPUSH
12218: LD_INT 17
12220: PPUSH
12221: LD_INT 0
12223: PPUSH
12224: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12228: LD_VAR 0 5
12232: PPUSH
12233: LD_INT 210
12235: PPUSH
12236: LD_INT 63
12238: PPUSH
12239: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12243: LD_VAR 0 5
12247: PPUSH
12248: LD_INT 208
12250: PPUSH
12251: LD_INT 62
12253: PPUSH
12254: CALL_OW 178
// for i in fake_russians do
12258: LD_ADDR_VAR 0 2
12262: PUSH
12263: LD_VAR 0 6
12267: PUSH
12268: FOR_IN
12269: IFFALSE 12347
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12271: LD_VAR 0 2
12275: PPUSH
12276: LD_INT 17
12278: PPUSH
12279: LD_INT 0
12281: PPUSH
12282: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
12286: LD_VAR 0 2
12290: PPUSH
12291: LD_INT 215
12293: PPUSH
12294: LD_INT 67
12296: PPUSH
12297: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
12301: LD_VAR 0 2
12305: PPUSH
12306: LD_INT 208
12308: PPUSH
12309: LD_INT 62
12311: PPUSH
12312: CALL_OW 178
// if GetClass ( i ) = 4 then
12316: LD_VAR 0 2
12320: PPUSH
12321: CALL_OW 257
12325: PUSH
12326: LD_INT 4
12328: EQUAL
12329: IFFALSE 12345
// ComHeal ( i , fake_cornel ) ;
12331: LD_VAR 0 2
12335: PPUSH
12336: LD_VAR 0 4
12340: PPUSH
12341: CALL_OW 128
// end ;
12345: GO 12268
12347: POP
12348: POP
// Wait ( 0 0$01 ) ;
12349: LD_INT 35
12351: PPUSH
12352: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
12356: LD_INT 208
12358: PPUSH
12359: LD_INT 62
12361: PPUSH
12362: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12366: LD_INT 208
12368: PPUSH
12369: LD_INT 62
12371: PPUSH
12372: LD_INT 1
12374: PPUSH
12375: LD_INT 10
12377: NEG
12378: PPUSH
12379: CALL_OW 330
// Wait ( 0 0$15 ) ;
12383: LD_INT 525
12385: PPUSH
12386: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
12390: LD_INT 208
12392: PPUSH
12393: LD_INT 62
12395: PPUSH
12396: LD_INT 1
12398: PPUSH
12399: CALL_OW 331
// ResetFog ;
12403: CALL_OW 335
// InGameOff ;
12407: CALL_OW 9
// end ;
12411: LD_VAR 0 1
12415: RET
// every 0 0$30 trigger GetDistUnits ( JMM , Cornel ) < 3 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) do
12416: LD_EXP 33
12420: PPUSH
12421: LD_EXP 40
12425: PPUSH
12426: CALL_OW 296
12430: PUSH
12431: LD_INT 3
12433: LESS
12434: PUSH
12435: LD_INT 22
12437: PUSH
12438: LD_INT 4
12440: PUSH
12441: EMPTY
12442: LIST
12443: LIST
12444: PUSH
12445: LD_INT 21
12447: PUSH
12448: LD_INT 3
12450: PUSH
12451: EMPTY
12452: LIST
12453: LIST
12454: PUSH
12455: EMPTY
12456: LIST
12457: LIST
12458: PPUSH
12459: CALL_OW 69
12463: AND
12464: IFFALSE 12482
12466: GO 12468
12468: DISABLE
// begin enable ;
12469: ENABLE
// SayRadio ( Powell , DWarn-Pow-1 ) ;
12470: LD_EXP 42
12474: PPUSH
12475: LD_STRING DWarn-Pow-1
12477: PPUSH
12478: CALL_OW 94
// end ; end_of_file
12482: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
12483: LD_EXP 8
12487: IFFALSE 13801
12489: GO 12491
12491: DISABLE
12492: LD_INT 0
12494: PPUSH
12495: PPUSH
12496: PPUSH
12497: PPUSH
12498: PPUSH
12499: PPUSH
12500: PPUSH
12501: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
12502: LD_EXP 40
12506: PUSH
12507: LD_EXP 41
12511: ADD
12512: PUSH
12513: LD_EXP 6
12517: ADD
12518: PPUSH
12519: LD_INT 250
12521: PPUSH
12522: LD_INT 120
12524: PPUSH
12525: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff [ Bierezov ] ;
12529: LD_ADDR_VAR 0 2
12533: PUSH
12534: LD_EXP 6
12538: PPUSH
12539: LD_INT 25
12541: PUSH
12542: LD_INT 2
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PPUSH
12549: CALL_OW 72
12553: PUSH
12554: LD_EXP 41
12558: PUSH
12559: EMPTY
12560: LIST
12561: DIFF
12562: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
12563: LD_ADDR_VAR 0 3
12567: PUSH
12568: LD_EXP 6
12572: PPUSH
12573: LD_INT 21
12575: PUSH
12576: LD_INT 1
12578: PUSH
12579: EMPTY
12580: LIST
12581: LIST
12582: PPUSH
12583: CALL_OW 72
12587: ST_TO_ADDR
// if not has_eng then
12588: LD_VAR 0 2
12592: NOT
12593: IFFALSE 12676
// begin uc_side := 4 ;
12595: LD_ADDR_OWVAR 20
12599: PUSH
12600: LD_INT 4
12602: ST_TO_ADDR
// uc_nation := 1 ;
12603: LD_ADDR_OWVAR 21
12607: PUSH
12608: LD_INT 1
12610: ST_TO_ADDR
// bc_type := b_depot ;
12611: LD_ADDR_OWVAR 42
12615: PUSH
12616: LD_INT 0
12618: ST_TO_ADDR
// bc_level := 2 ;
12619: LD_ADDR_OWVAR 43
12623: PUSH
12624: LD_INT 2
12626: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
12627: LD_ADDR_VAR 0 4
12631: PUSH
12632: LD_INT 264
12634: PPUSH
12635: LD_INT 120
12637: PPUSH
12638: LD_INT 4
12640: PPUSH
12641: CALL_OW 47
12645: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
12646: LD_INT 264
12648: PPUSH
12649: LD_INT 120
12651: PPUSH
12652: LD_INT 4
12654: PPUSH
12655: LD_INT 10
12657: NEG
12658: PPUSH
12659: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
12663: LD_INT 264
12665: PPUSH
12666: LD_INT 120
12668: PPUSH
12669: LD_INT 4
12671: PPUSH
12672: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
12676: LD_INT 35
12678: PPUSH
12679: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
12683: LD_EXP 40
12687: PPUSH
12688: LD_INT 10
12690: PPUSH
12691: CALL_OW 308
12695: IFFALSE 12676
// if has_eng and not dep then
12697: LD_VAR 0 2
12701: PUSH
12702: LD_VAR 0 4
12706: NOT
12707: AND
12708: IFFALSE 12836
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
12710: LD_VAR 0 2
12714: PPUSH
12715: LD_INT 0
12717: PPUSH
12718: LD_INT 264
12720: PPUSH
12721: LD_INT 120
12723: PPUSH
12724: LD_INT 4
12726: PPUSH
12727: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
12731: LD_INT 35
12733: PPUSH
12734: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
12738: LD_INT 22
12740: PUSH
12741: LD_INT 4
12743: PUSH
12744: EMPTY
12745: LIST
12746: LIST
12747: PUSH
12748: LD_INT 30
12750: PUSH
12751: LD_INT 0
12753: PUSH
12754: EMPTY
12755: LIST
12756: LIST
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PPUSH
12762: CALL_OW 69
12766: IFFALSE 12731
// ComMoveXY ( filter , 264 , 120 ) ;
12768: LD_VAR 0 3
12772: PPUSH
12773: LD_INT 264
12775: PPUSH
12776: LD_INT 120
12778: PPUSH
12779: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
12783: LD_INT 35
12785: PPUSH
12786: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
12790: LD_INT 22
12792: PUSH
12793: LD_INT 4
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: LD_INT 30
12802: PUSH
12803: LD_INT 0
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PUSH
12810: LD_INT 3
12812: PUSH
12813: LD_INT 57
12815: PUSH
12816: EMPTY
12817: LIST
12818: PUSH
12819: EMPTY
12820: LIST
12821: LIST
12822: PUSH
12823: EMPTY
12824: LIST
12825: LIST
12826: LIST
12827: PPUSH
12828: CALL_OW 69
12832: IFFALSE 12783
// end else
12834: GO 12848
// begin SetSide ( dep , 4 ) ;
12836: LD_VAR 0 4
12840: PPUSH
12841: LD_INT 4
12843: PPUSH
12844: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
12848: LD_ADDR_VAR 0 4
12852: PUSH
12853: LD_INT 22
12855: PUSH
12856: LD_INT 4
12858: PUSH
12859: EMPTY
12860: LIST
12861: LIST
12862: PUSH
12863: LD_INT 30
12865: PUSH
12866: LD_INT 0
12868: PUSH
12869: EMPTY
12870: LIST
12871: LIST
12872: PUSH
12873: EMPTY
12874: LIST
12875: LIST
12876: PPUSH
12877: CALL_OW 69
12881: PUSH
12882: LD_INT 1
12884: ARRAY
12885: ST_TO_ADDR
// for i = 1 to 3 - has_eng do
12886: LD_ADDR_VAR 0 1
12890: PUSH
12891: DOUBLE
12892: LD_INT 1
12894: DEC
12895: ST_TO_ADDR
12896: LD_INT 3
12898: PUSH
12899: LD_VAR 0 2
12903: MINUS
12904: PUSH
12905: FOR_TO
12906: IFFALSE 12986
// begin if GetClass ( filter [ i ] ) = 2 then
12908: LD_VAR 0 3
12912: PUSH
12913: LD_VAR 0 1
12917: ARRAY
12918: PPUSH
12919: CALL_OW 257
12923: PUSH
12924: LD_INT 2
12926: EQUAL
12927: IFFALSE 12931
// continue ;
12929: GO 12905
// ComEnterUnit ( filter [ i ] , dep ) ;
12931: LD_VAR 0 3
12935: PUSH
12936: LD_VAR 0 1
12940: ARRAY
12941: PPUSH
12942: LD_VAR 0 4
12946: PPUSH
12947: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
12951: LD_VAR 0 3
12955: PUSH
12956: LD_VAR 0 1
12960: ARRAY
12961: PPUSH
12962: LD_INT 2
12964: PPUSH
12965: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
12969: LD_VAR 0 3
12973: PUSH
12974: LD_VAR 0 1
12978: ARRAY
12979: PPUSH
12980: CALL_OW 182
// end ;
12984: GO 12905
12986: POP
12987: POP
// repeat wait ( 0 0$01 ) ;
12988: LD_INT 35
12990: PPUSH
12991: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
12995: LD_VAR 0 3
12999: PPUSH
13000: LD_INT 25
13002: PUSH
13003: LD_INT 2
13005: PUSH
13006: EMPTY
13007: LIST
13008: LIST
13009: PPUSH
13010: CALL_OW 72
13014: PUSH
13015: LD_INT 3
13017: EQUAL
13018: IFFALSE 12988
// if IsInUnit ( Cornel ) then
13020: LD_EXP 40
13024: PPUSH
13025: CALL_OW 310
13029: IFFALSE 13112
// begin cargo := IsInUnit ( Cornel ) ;
13031: LD_ADDR_VAR 0 7
13035: PUSH
13036: LD_EXP 40
13040: PPUSH
13041: CALL_OW 310
13045: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13046: LD_VAR 0 7
13050: PPUSH
13051: LD_INT 1
13053: PPUSH
13054: CALL_OW 289
13058: IFFALSE 13074
// ComGive ( Cornel , dep ) ;
13060: LD_EXP 40
13064: PPUSH
13065: LD_VAR 0 4
13069: PPUSH
13070: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13074: LD_EXP 40
13078: PPUSH
13079: LD_INT 235
13081: PPUSH
13082: LD_INT 122
13084: PPUSH
13085: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13089: LD_EXP 40
13093: PPUSH
13094: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13098: LD_EXP 40
13102: PPUSH
13103: LD_VAR 0 4
13107: PPUSH
13108: CALL_OW 180
// end ; if Bierezov then
13112: LD_EXP 41
13116: IFFALSE 13132
// ComEnterUnit ( Bierezov , dep ) ;
13118: LD_EXP 41
13122: PPUSH
13123: LD_VAR 0 4
13127: PPUSH
13128: CALL_OW 120
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
13132: LD_ADDR_VAR 0 2
13136: PUSH
13137: LD_EXP 6
13141: PPUSH
13142: LD_INT 25
13144: PUSH
13145: LD_INT 2
13147: PUSH
13148: EMPTY
13149: LIST
13150: LIST
13151: PPUSH
13152: CALL_OW 72
13156: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13157: LD_INT 35
13159: PPUSH
13160: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13164: LD_ADDR_VAR 0 6
13168: PUSH
13169: LD_INT 10
13171: PPUSH
13172: CALL_OW 435
13176: ST_TO_ADDR
// if crates then
13177: LD_VAR 0 6
13181: IFFALSE 13210
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
13183: LD_VAR 0 2
13187: PPUSH
13188: LD_VAR 0 6
13192: PUSH
13193: LD_INT 1
13195: ARRAY
13196: PPUSH
13197: LD_VAR 0 6
13201: PUSH
13202: LD_INT 2
13204: ARRAY
13205: PPUSH
13206: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
13210: LD_VAR 0 4
13214: PPUSH
13215: CALL_OW 274
13219: PPUSH
13220: LD_INT 1
13222: PPUSH
13223: CALL_OW 275
13227: PUSH
13228: LD_INT 40
13230: GREATEREQUAL
13231: IFFALSE 13157
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
13233: LD_ADDR_VAR 0 5
13237: PUSH
13238: LD_INT 4
13240: PUSH
13241: LD_INT 256
13243: PUSH
13244: LD_INT 111
13246: PUSH
13247: LD_INT 2
13249: PUSH
13250: EMPTY
13251: LIST
13252: LIST
13253: LIST
13254: LIST
13255: PUSH
13256: LD_INT 31
13258: PUSH
13259: LD_INT 243
13261: PUSH
13262: LD_INT 112
13264: PUSH
13265: LD_INT 2
13267: PUSH
13268: EMPTY
13269: LIST
13270: LIST
13271: LIST
13272: LIST
13273: PUSH
13274: EMPTY
13275: LIST
13276: LIST
13277: ST_TO_ADDR
// for i in blist do
13278: LD_ADDR_VAR 0 1
13282: PUSH
13283: LD_VAR 0 5
13287: PUSH
13288: FOR_IN
13289: IFFALSE 13338
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
13291: LD_VAR 0 2
13295: PPUSH
13296: LD_VAR 0 1
13300: PUSH
13301: LD_INT 1
13303: ARRAY
13304: PPUSH
13305: LD_VAR 0 1
13309: PUSH
13310: LD_INT 2
13312: ARRAY
13313: PPUSH
13314: LD_VAR 0 1
13318: PUSH
13319: LD_INT 3
13321: ARRAY
13322: PPUSH
13323: LD_VAR 0 1
13327: PUSH
13328: LD_INT 4
13330: ARRAY
13331: PPUSH
13332: CALL_OW 205
13336: GO 13288
13338: POP
13339: POP
// repeat wait ( 0 0$01 ) ;
13340: LD_INT 35
13342: PPUSH
13343: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
13347: LD_INT 22
13349: PUSH
13350: LD_INT 4
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PUSH
13357: LD_INT 30
13359: PUSH
13360: LD_INT 4
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: PUSH
13367: LD_INT 3
13369: PUSH
13370: LD_INT 57
13372: PUSH
13373: EMPTY
13374: LIST
13375: PUSH
13376: EMPTY
13377: LIST
13378: LIST
13379: PUSH
13380: EMPTY
13381: LIST
13382: LIST
13383: LIST
13384: PPUSH
13385: CALL_OW 69
13389: IFFALSE 13340
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
13391: LD_VAR 0 3
13395: PUSH
13396: LD_VAR 0 2
13400: DIFF
13401: PPUSH
13402: LD_INT 22
13404: PUSH
13405: LD_INT 4
13407: PUSH
13408: EMPTY
13409: LIST
13410: LIST
13411: PUSH
13412: LD_INT 30
13414: PUSH
13415: LD_INT 4
13417: PUSH
13418: EMPTY
13419: LIST
13420: LIST
13421: PUSH
13422: EMPTY
13423: LIST
13424: LIST
13425: PPUSH
13426: CALL_OW 69
13430: PUSH
13431: LD_INT 1
13433: ARRAY
13434: PPUSH
13435: CALL_OW 180
// AddComChangeProfession ( filter diff has_eng , 1 ) ;
13439: LD_VAR 0 3
13443: PUSH
13444: LD_VAR 0 2
13448: DIFF
13449: PPUSH
13450: LD_INT 1
13452: PPUSH
13453: CALL_OW 183
// repeat wait ( 0 0$01 ) ;
13457: LD_INT 35
13459: PPUSH
13460: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
13464: LD_INT 22
13466: PUSH
13467: LD_INT 4
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: LD_INT 30
13476: PUSH
13477: LD_INT 31
13479: PUSH
13480: EMPTY
13481: LIST
13482: LIST
13483: PUSH
13484: LD_INT 3
13486: PUSH
13487: LD_INT 57
13489: PUSH
13490: EMPTY
13491: LIST
13492: PUSH
13493: EMPTY
13494: LIST
13495: LIST
13496: PUSH
13497: EMPTY
13498: LIST
13499: LIST
13500: LIST
13501: PPUSH
13502: CALL_OW 69
13506: IFFALSE 13457
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
13508: LD_ADDR_VAR 0 8
13512: PUSH
13513: LD_EXP 6
13517: PPUSH
13518: LD_INT 25
13520: PUSH
13521: LD_INT 1
13523: PUSH
13524: EMPTY
13525: LIST
13526: LIST
13527: PPUSH
13528: CALL_OW 72
13532: ST_TO_ADDR
// ComExitBuilding ( sol [ 1 ] ) ;
13533: LD_VAR 0 8
13537: PUSH
13538: LD_INT 1
13540: ARRAY
13541: PPUSH
13542: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
13546: LD_VAR 0 8
13550: PUSH
13551: LD_INT 1
13553: ARRAY
13554: PPUSH
13555: LD_INT 22
13557: PUSH
13558: LD_INT 4
13560: PUSH
13561: EMPTY
13562: LIST
13563: LIST
13564: PUSH
13565: LD_INT 30
13567: PUSH
13568: LD_INT 31
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: PUSH
13575: EMPTY
13576: LIST
13577: LIST
13578: PPUSH
13579: CALL_OW 69
13583: PUSH
13584: LD_INT 1
13586: ARRAY
13587: PPUSH
13588: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
13592: LD_VAR 0 2
13596: PPUSH
13597: LD_VAR 0 4
13601: PPUSH
13602: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
13606: LD_INT 35
13608: PPUSH
13609: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13613: LD_ADDR_VAR 0 3
13617: PUSH
13618: LD_INT 22
13620: PUSH
13621: LD_INT 4
13623: PUSH
13624: EMPTY
13625: LIST
13626: LIST
13627: PUSH
13628: LD_INT 21
13630: PUSH
13631: LD_INT 3
13633: PUSH
13634: EMPTY
13635: LIST
13636: LIST
13637: PUSH
13638: LD_INT 3
13640: PUSH
13641: LD_INT 24
13643: PUSH
13644: LD_INT 1000
13646: PUSH
13647: EMPTY
13648: LIST
13649: LIST
13650: PUSH
13651: EMPTY
13652: LIST
13653: LIST
13654: PUSH
13655: EMPTY
13656: LIST
13657: LIST
13658: LIST
13659: PPUSH
13660: CALL_OW 69
13664: ST_TO_ADDR
// if filter and has_eng then
13665: LD_VAR 0 3
13669: PUSH
13670: LD_VAR 0 2
13674: AND
13675: IFFALSE 13741
// begin for i in has_eng do
13677: LD_ADDR_VAR 0 1
13681: PUSH
13682: LD_VAR 0 2
13686: PUSH
13687: FOR_IN
13688: IFFALSE 13737
// begin if IsInUnit ( i ) then
13690: LD_VAR 0 1
13694: PPUSH
13695: CALL_OW 310
13699: IFFALSE 13710
// ComExitBuilding ( i ) ;
13701: LD_VAR 0 1
13705: PPUSH
13706: CALL_OW 122
// Wait ( 3 ) ;
13710: LD_INT 3
13712: PPUSH
13713: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
13717: LD_VAR 0 1
13721: PPUSH
13722: LD_VAR 0 3
13726: PUSH
13727: LD_INT 1
13729: ARRAY
13730: PPUSH
13731: CALL_OW 130
// end ;
13735: GO 13687
13737: POP
13738: POP
// end else
13739: GO 13795
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
13741: LD_VAR 0 2
13745: PUSH
13746: LD_VAR 0 2
13750: PPUSH
13751: LD_INT 56
13753: PUSH
13754: EMPTY
13755: LIST
13756: PPUSH
13757: CALL_OW 72
13761: AND
13762: IFFALSE 13795
// for i in has_eng do
13764: LD_ADDR_VAR 0 1
13768: PUSH
13769: LD_VAR 0 2
13773: PUSH
13774: FOR_IN
13775: IFFALSE 13793
// ComEnterUnit ( i , dep ) ;
13777: LD_VAR 0 1
13781: PPUSH
13782: LD_VAR 0 4
13786: PPUSH
13787: CALL_OW 120
13791: GO 13774
13793: POP
13794: POP
// until cornel_prepared ;
13795: LD_EXP 11
13799: IFFALSE 13606
// end ;
13801: PPOPN 8
13803: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
13804: LD_EXP 11
13808: IFFALSE 14157
13810: GO 13812
13812: DISABLE
13813: LD_INT 0
13815: PPUSH
13816: PPUSH
13817: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
13818: LD_ADDR_VAR 0 2
13822: PUSH
13823: LD_INT 22
13825: PUSH
13826: LD_INT 4
13828: PUSH
13829: EMPTY
13830: LIST
13831: LIST
13832: PUSH
13833: LD_INT 30
13835: PUSH
13836: LD_INT 4
13838: PUSH
13839: EMPTY
13840: LIST
13841: LIST
13842: PUSH
13843: EMPTY
13844: LIST
13845: LIST
13846: PPUSH
13847: CALL_OW 69
13851: PUSH
13852: LD_INT 1
13854: ARRAY
13855: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
13856: LD_EXP 6
13860: PPUSH
13861: CALL_OW 122
// Wait ( 0 0$03 ) ;
13865: LD_INT 105
13867: PPUSH
13868: CALL_OW 67
// for i in cornel_units do
13872: LD_ADDR_VAR 0 1
13876: PUSH
13877: LD_EXP 6
13881: PUSH
13882: FOR_IN
13883: IFFALSE 13959
// begin if GetClass ( i ) in [ 2 , 3 ] then
13885: LD_VAR 0 1
13889: PPUSH
13890: CALL_OW 257
13894: PUSH
13895: LD_INT 2
13897: PUSH
13898: LD_INT 3
13900: PUSH
13901: EMPTY
13902: LIST
13903: LIST
13904: IN
13905: IFFALSE 13942
// begin ComEnterUnit ( i , arm ) ;
13907: LD_VAR 0 1
13911: PPUSH
13912: LD_VAR 0 2
13916: PPUSH
13917: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
13921: LD_VAR 0 1
13925: PPUSH
13926: LD_INT 1
13928: PPUSH
13929: CALL_OW 183
// AddComExitBuilding ( i ) ;
13933: LD_VAR 0 1
13937: PPUSH
13938: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
13942: LD_VAR 0 1
13946: PPUSH
13947: LD_INT 257
13949: PPUSH
13950: LD_INT 121
13952: PPUSH
13953: CALL_OW 171
// end ;
13957: GO 13882
13959: POP
13960: POP
// Wait ( 1 1$00 ) ;
13961: LD_INT 2100
13963: PPUSH
13964: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
13968: LD_ADDR_VAR 0 3
13972: PUSH
13973: LD_EXP 40
13977: PUSH
13978: LD_EXP 41
13982: ADD
13983: PUSH
13984: LD_EXP 6
13988: ADD
13989: PUSH
13990: LD_EXP 6
13994: PPUSH
13995: LD_INT 21
13997: PUSH
13998: LD_INT 2
14000: PUSH
14001: EMPTY
14002: LIST
14003: LIST
14004: PPUSH
14005: CALL_OW 72
14009: DIFF
14010: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
14011: LD_VAR 0 3
14015: PPUSH
14016: LD_INT 248
14018: PPUSH
14019: LD_INT 85
14021: PPUSH
14022: CALL_OW 111
// AddComHold ( filter ) ;
14026: LD_VAR 0 3
14030: PPUSH
14031: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
14035: LD_INT 35
14037: PPUSH
14038: CALL_OW 67
// until cornel_attack ;
14042: LD_EXP 9
14046: IFFALSE 14035
// ComAgressiveMove ( filter , 209 , 63 ) ;
14048: LD_VAR 0 3
14052: PPUSH
14053: LD_INT 209
14055: PPUSH
14056: LD_INT 63
14058: PPUSH
14059: CALL_OW 114
// if Bierezov then
14063: LD_EXP 41
14067: IFFALSE 14157
// begin filter := filter diff Bierezov ;
14069: LD_ADDR_VAR 0 3
14073: PUSH
14074: LD_VAR 0 3
14078: PUSH
14079: LD_EXP 41
14083: DIFF
14084: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
14085: LD_EXP 41
14089: PPUSH
14090: LD_INT 6
14092: PPUSH
14093: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
14097: LD_EXP 41
14101: PPUSH
14102: LD_INT 235
14104: PPUSH
14105: LD_INT 60
14107: PPUSH
14108: CALL_OW 111
// AddComHold ( Bierezov ) ;
14112: LD_EXP 41
14116: PPUSH
14117: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
14121: LD_EXP 41
14125: PPUSH
14126: LD_INT 350
14128: PPUSH
14129: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
14133: LD_EXP 41
14137: PPUSH
14138: LD_INT 198
14140: PPUSH
14141: LD_INT 28
14143: PPUSH
14144: CALL_OW 171
// AddComHold ( Bierezov ) ;
14148: LD_EXP 41
14152: PPUSH
14153: CALL_OW 200
// end ; end ; end_of_file
14157: PPOPN 3
14159: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
14160: LD_EXP 49
14164: PUSH
14165: LD_EXP 29
14169: NOT
14170: AND
14171: PUSH
14172: LD_EXP 30
14176: NOT
14177: AND
14178: IFFALSE 14628
14180: GO 14182
14182: DISABLE
14183: LD_INT 0
14185: PPUSH
14186: PPUSH
14187: PPUSH
14188: PPUSH
// begin enable ;
14189: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14190: LD_ADDR_VAR 0 4
14194: PUSH
14195: LD_INT 81
14197: PUSH
14198: LD_INT 3
14200: PUSH
14201: EMPTY
14202: LIST
14203: LIST
14204: PPUSH
14205: CALL_OW 69
14209: ST_TO_ADDR
// for i = 1 to ru_patrol do
14210: LD_ADDR_VAR 0 2
14214: PUSH
14215: DOUBLE
14216: LD_INT 1
14218: DEC
14219: ST_TO_ADDR
14220: LD_EXP 49
14224: PUSH
14225: FOR_TO
14226: IFFALSE 14626
// begin un := ru_patrol [ i ] ;
14228: LD_ADDR_VAR 0 1
14232: PUSH
14233: LD_EXP 49
14237: PUSH
14238: LD_VAR 0 2
14242: ARRAY
14243: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14244: LD_VAR 0 1
14248: PPUSH
14249: LD_INT 13
14251: PPUSH
14252: CALL_OW 308
14256: IFFALSE 14361
// begin if not ru_alert then
14258: LD_EXP 56
14262: NOT
14263: IFFALSE 14273
// ru_alert := true ;
14265: LD_ADDR_EXP 56
14269: PUSH
14270: LD_INT 1
14272: ST_TO_ADDR
// if not See ( 1 , un ) then
14273: LD_INT 1
14275: PPUSH
14276: LD_VAR 0 1
14280: PPUSH
14281: CALL_OW 292
14285: NOT
14286: IFFALSE 14300
// SetLives ( un , 1000 ) ;
14288: LD_VAR 0 1
14292: PPUSH
14293: LD_INT 1000
14295: PPUSH
14296: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
14300: LD_ADDR_EXP 49
14304: PUSH
14305: LD_EXP 49
14309: PUSH
14310: LD_VAR 0 1
14314: DIFF
14315: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
14316: LD_VAR 0 1
14320: PPUSH
14321: LD_INT 22
14323: PUSH
14324: LD_INT 3
14326: PUSH
14327: EMPTY
14328: LIST
14329: LIST
14330: PUSH
14331: LD_INT 30
14333: PUSH
14334: LD_INT 4
14336: PUSH
14337: EMPTY
14338: LIST
14339: LIST
14340: PUSH
14341: EMPTY
14342: LIST
14343: LIST
14344: PPUSH
14345: CALL_OW 69
14349: PPUSH
14350: CALL 1023 0 1
14354: PPUSH
14355: CALL_OW 120
// continue ;
14359: GO 14225
// end ; if IsOk ( un ) and not HasTask ( un ) then
14361: LD_VAR 0 1
14365: PPUSH
14366: CALL_OW 302
14370: PUSH
14371: LD_VAR 0 1
14375: PPUSH
14376: CALL_OW 314
14380: NOT
14381: AND
14382: IFFALSE 14475
// begin for j = 1 to ru_firepoints_south [ i ] do
14384: LD_ADDR_VAR 0 3
14388: PUSH
14389: DOUBLE
14390: LD_INT 1
14392: DEC
14393: ST_TO_ADDR
14394: LD_EXP 55
14398: PUSH
14399: LD_VAR 0 2
14403: ARRAY
14404: PUSH
14405: FOR_TO
14406: IFFALSE 14473
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
14408: LD_VAR 0 1
14412: PPUSH
14413: LD_EXP 55
14417: PUSH
14418: LD_VAR 0 2
14422: ARRAY
14423: PUSH
14424: LD_VAR 0 3
14428: ARRAY
14429: PUSH
14430: LD_INT 1
14432: ARRAY
14433: PPUSH
14434: LD_EXP 55
14438: PUSH
14439: LD_VAR 0 2
14443: ARRAY
14444: PUSH
14445: LD_VAR 0 3
14449: ARRAY
14450: PUSH
14451: LD_INT 2
14453: ARRAY
14454: PPUSH
14455: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
14459: LD_VAR 0 1
14463: PPUSH
14464: LD_INT 70
14466: PPUSH
14467: CALL_OW 202
// end ;
14471: GO 14405
14473: POP
14474: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
14475: LD_VAR 0 1
14479: PPUSH
14480: CALL_OW 256
14484: PUSH
14485: LD_INT 700
14487: LESS
14488: PUSH
14489: LD_VAR 0 1
14493: PPUSH
14494: LD_INT 13
14496: PPUSH
14497: CALL_OW 308
14501: NOT
14502: AND
14503: IFFALSE 14555
// begin ComMoveToArea ( un , retreatArea ) ;
14505: LD_VAR 0 1
14509: PPUSH
14510: LD_INT 13
14512: PPUSH
14513: CALL_OW 113
// if not ru_alert_xy then
14517: LD_EXP 57
14521: NOT
14522: IFFALSE 14553
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
14524: LD_ADDR_EXP 57
14528: PUSH
14529: LD_VAR 0 1
14533: PPUSH
14534: CALL_OW 250
14538: PUSH
14539: LD_VAR 0 1
14543: PPUSH
14544: CALL_OW 251
14548: PUSH
14549: EMPTY
14550: LIST
14551: LIST
14552: ST_TO_ADDR
// end else
14553: GO 14624
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
14555: LD_VAR 0 1
14559: PPUSH
14560: LD_VAR 0 4
14564: PPUSH
14565: LD_VAR 0 1
14569: PPUSH
14570: CALL_OW 74
14574: PPUSH
14575: CALL_OW 296
14579: PUSH
14580: LD_INT 9
14582: LESS
14583: PUSH
14584: LD_VAR 0 1
14588: PPUSH
14589: CALL_OW 256
14593: PUSH
14594: LD_INT 500
14596: GREATER
14597: AND
14598: IFFALSE 14624
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
14600: LD_VAR 0 1
14604: PPUSH
14605: LD_VAR 0 4
14609: PPUSH
14610: LD_VAR 0 1
14614: PPUSH
14615: CALL_OW 74
14619: PPUSH
14620: CALL_OW 115
// end ;
14624: GO 14225
14626: POP
14627: POP
// end ;
14628: PPOPN 4
14630: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
14631: LD_EXP 56
14635: PUSH
14636: LD_EXP 57
14640: AND
14641: PUSH
14642: LD_EXP 29
14646: NOT
14647: AND
14648: PUSH
14649: LD_EXP 30
14653: NOT
14654: AND
14655: IFFALSE 14865
14657: GO 14659
14659: DISABLE
14660: LD_INT 0
14662: PPUSH
14663: PPUSH
// begin enable ;
14664: ENABLE
// if not ru_vehicles then
14665: LD_EXP 52
14669: NOT
14670: IFFALSE 14674
// exit ;
14672: GO 14865
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14674: LD_ADDR_VAR 0 2
14678: PUSH
14679: LD_INT 81
14681: PUSH
14682: LD_INT 3
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: PPUSH
14689: CALL_OW 69
14693: ST_TO_ADDR
// if ru_vehicles then
14694: LD_EXP 52
14698: IFFALSE 14865
// begin for i in ru_vehicles do
14700: LD_ADDR_VAR 0 1
14704: PUSH
14705: LD_EXP 52
14709: PUSH
14710: FOR_IN
14711: IFFALSE 14863
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
14713: LD_VAR 0 1
14717: PPUSH
14718: CALL_OW 302
14722: PUSH
14723: LD_VAR 0 1
14727: PPUSH
14728: LD_VAR 0 2
14732: PPUSH
14733: LD_VAR 0 1
14737: PPUSH
14738: CALL_OW 74
14742: PPUSH
14743: CALL_OW 296
14747: PUSH
14748: LD_INT 9
14750: LESS
14751: AND
14752: IFFALSE 14778
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
14754: LD_VAR 0 1
14758: PPUSH
14759: LD_VAR 0 2
14763: PPUSH
14764: LD_VAR 0 1
14768: PPUSH
14769: CALL_OW 74
14773: PPUSH
14774: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
14778: LD_VAR 0 1
14782: PPUSH
14783: CALL_OW 314
14787: NOT
14788: PUSH
14789: LD_VAR 0 1
14793: PPUSH
14794: CALL_OW 302
14798: AND
14799: PUSH
14800: LD_VAR 0 1
14804: PPUSH
14805: LD_EXP 57
14809: PUSH
14810: LD_INT 1
14812: ARRAY
14813: PPUSH
14814: LD_EXP 57
14818: PUSH
14819: LD_INT 2
14821: ARRAY
14822: PPUSH
14823: CALL_OW 297
14827: PUSH
14828: LD_INT 10
14830: GREATER
14831: AND
14832: IFFALSE 14861
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
14834: LD_VAR 0 1
14838: PPUSH
14839: LD_EXP 57
14843: PUSH
14844: LD_INT 1
14846: ARRAY
14847: PPUSH
14848: LD_EXP 57
14852: PUSH
14853: LD_INT 2
14855: ARRAY
14856: PPUSH
14857: CALL_OW 114
// end ;
14861: GO 14710
14863: POP
14864: POP
// end ; end ;
14865: PPOPN 2
14867: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
14868: LD_EXP 57
14872: PUSH
14873: LD_EXP 56
14877: AND
14878: PUSH
14879: LD_INT 3
14881: PPUSH
14882: CALL_OW 463
14886: NOT
14887: AND
14888: PUSH
14889: LD_EXP 29
14893: NOT
14894: AND
14895: PUSH
14896: LD_EXP 30
14900: NOT
14901: AND
14902: IFFALSE 14997
14904: GO 14906
14906: DISABLE
14907: LD_INT 0
14909: PPUSH
// begin enable ;
14910: ENABLE
// ru_alert_xy := false ;
14911: LD_ADDR_EXP 57
14915: PUSH
14916: LD_INT 0
14918: ST_TO_ADDR
// ru_alert := false ;
14919: LD_ADDR_EXP 56
14923: PUSH
14924: LD_INT 0
14926: ST_TO_ADDR
// if ru_vehicles then
14927: LD_EXP 52
14931: IFFALSE 14997
// for i in ru_vehicles do
14933: LD_ADDR_VAR 0 1
14937: PUSH
14938: LD_EXP 52
14942: PUSH
14943: FOR_IN
14944: IFFALSE 14995
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
14946: LD_VAR 0 1
14950: PPUSH
14951: CALL_OW 302
14955: PUSH
14956: LD_VAR 0 1
14960: PPUSH
14961: LD_INT 89
14963: PPUSH
14964: LD_INT 36
14966: PPUSH
14967: CALL_OW 297
14971: PUSH
14972: LD_INT 10
14974: GREATER
14975: AND
14976: IFFALSE 14993
// ComMoveXY ( i , 89 , 36 ) ;
14978: LD_VAR 0 1
14982: PPUSH
14983: LD_INT 89
14985: PPUSH
14986: LD_INT 36
14988: PPUSH
14989: CALL_OW 111
14993: GO 14943
14995: POP
14996: POP
// end ;
14997: PPOPN 1
14999: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
15000: LD_EXP 51
15004: PUSH
15005: LD_EXP 29
15009: NOT
15010: AND
15011: PUSH
15012: LD_EXP 30
15016: NOT
15017: AND
15018: IFFALSE 15302
15020: GO 15022
15022: DISABLE
15023: LD_INT 0
15025: PPUSH
15026: PPUSH
15027: PPUSH
// begin enable ;
15028: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15029: LD_ADDR_VAR 0 3
15033: PUSH
15034: LD_INT 81
15036: PUSH
15037: LD_INT 3
15039: PUSH
15040: EMPTY
15041: LIST
15042: LIST
15043: PPUSH
15044: CALL_OW 69
15048: ST_TO_ADDR
// for i = 1 to ru_forest do
15049: LD_ADDR_VAR 0 1
15053: PUSH
15054: DOUBLE
15055: LD_INT 1
15057: DEC
15058: ST_TO_ADDR
15059: LD_EXP 51
15063: PUSH
15064: FOR_TO
15065: IFFALSE 15300
// begin un := ru_forest [ i ] ;
15067: LD_ADDR_VAR 0 2
15071: PUSH
15072: LD_EXP 51
15076: PUSH
15077: LD_VAR 0 1
15081: ARRAY
15082: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15083: LD_VAR 0 2
15087: PPUSH
15088: LD_INT 13
15090: PPUSH
15091: CALL_OW 308
15095: IFFALSE 15185
// begin if not See ( 1 , un ) then
15097: LD_INT 1
15099: PPUSH
15100: LD_VAR 0 2
15104: PPUSH
15105: CALL_OW 292
15109: NOT
15110: IFFALSE 15124
// SetLives ( un , 1000 ) ;
15112: LD_VAR 0 2
15116: PPUSH
15117: LD_INT 1000
15119: PPUSH
15120: CALL_OW 234
// ru_forest := ru_forest diff un ;
15124: LD_ADDR_EXP 51
15128: PUSH
15129: LD_EXP 51
15133: PUSH
15134: LD_VAR 0 2
15138: DIFF
15139: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15140: LD_VAR 0 2
15144: PPUSH
15145: LD_INT 22
15147: PUSH
15148: LD_INT 3
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: PUSH
15155: LD_INT 30
15157: PUSH
15158: LD_INT 4
15160: PUSH
15161: EMPTY
15162: LIST
15163: LIST
15164: PUSH
15165: EMPTY
15166: LIST
15167: LIST
15168: PPUSH
15169: CALL_OW 69
15173: PPUSH
15174: CALL 1023 0 1
15178: PPUSH
15179: CALL_OW 120
// continue ;
15183: GO 15064
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15185: LD_VAR 0 2
15189: PPUSH
15190: CALL_OW 256
15194: PUSH
15195: LD_INT 700
15197: LESS
15198: PUSH
15199: LD_VAR 0 2
15203: PPUSH
15204: LD_INT 13
15206: PPUSH
15207: CALL_OW 308
15211: NOT
15212: AND
15213: IFFALSE 15229
// ComMoveToArea ( un , retreatArea ) else
15215: LD_VAR 0 2
15219: PPUSH
15220: LD_INT 13
15222: PPUSH
15223: CALL_OW 113
15227: GO 15298
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15229: LD_VAR 0 2
15233: PPUSH
15234: LD_VAR 0 3
15238: PPUSH
15239: LD_VAR 0 2
15243: PPUSH
15244: CALL_OW 74
15248: PPUSH
15249: CALL_OW 296
15253: PUSH
15254: LD_INT 9
15256: LESS
15257: PUSH
15258: LD_VAR 0 2
15262: PPUSH
15263: CALL_OW 256
15267: PUSH
15268: LD_INT 500
15270: GREATER
15271: AND
15272: IFFALSE 15298
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15274: LD_VAR 0 2
15278: PPUSH
15279: LD_VAR 0 3
15283: PPUSH
15284: LD_VAR 0 2
15288: PPUSH
15289: CALL_OW 74
15293: PPUSH
15294: CALL_OW 115
// end ;
15298: GO 15064
15300: POP
15301: POP
// end ;
15302: PPOPN 3
15304: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
15305: LD_EXP 30
15309: NOT
15310: IFFALSE 15431
15312: GO 15314
15314: DISABLE
15315: LD_INT 0
15317: PPUSH
15318: PPUSH
// begin enable ;
15319: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
15320: LD_ADDR_VAR 0 2
15324: PUSH
15325: LD_INT 22
15327: PUSH
15328: LD_INT 3
15330: PUSH
15331: EMPTY
15332: LIST
15333: LIST
15334: PUSH
15335: LD_INT 21
15337: PUSH
15338: LD_INT 3
15340: PUSH
15341: EMPTY
15342: LIST
15343: LIST
15344: PUSH
15345: EMPTY
15346: LIST
15347: LIST
15348: PPUSH
15349: CALL_OW 69
15353: ST_TO_ADDR
// if filter then
15354: LD_VAR 0 2
15358: IFFALSE 15431
// for i in filter do
15360: LD_ADDR_VAR 0 1
15364: PUSH
15365: LD_VAR 0 2
15369: PUSH
15370: FOR_IN
15371: IFFALSE 15429
// if GetLives ( i ) < 990 then
15373: LD_VAR 0 1
15377: PPUSH
15378: CALL_OW 256
15382: PUSH
15383: LD_INT 990
15385: LESS
15386: IFFALSE 15427
// begin ru_alert := true ;
15388: LD_ADDR_EXP 56
15392: PUSH
15393: LD_INT 1
15395: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
15396: LD_ADDR_EXP 57
15400: PUSH
15401: LD_VAR 0 1
15405: PPUSH
15406: CALL_OW 250
15410: PUSH
15411: LD_VAR 0 1
15415: PPUSH
15416: CALL_OW 251
15420: PUSH
15421: EMPTY
15422: LIST
15423: LIST
15424: ST_TO_ADDR
// break ;
15425: GO 15429
// end ;
15427: GO 15370
15429: POP
15430: POP
// end ;
15431: PPOPN 2
15433: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
15434: LD_EXP 29
15438: IFFALSE 15587
15440: GO 15442
15442: DISABLE
15443: LD_INT 0
15445: PPUSH
15446: PPUSH
15447: PPUSH
15448: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
15449: LD_ADDR_VAR 0 4
15453: PUSH
15454: LD_EXP 52
15458: PUSH
15459: LD_EXP 51
15463: ADD
15464: PUSH
15465: LD_EXP 49
15469: ADD
15470: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
15471: LD_ADDR_VAR 0 3
15475: PUSH
15476: LD_INT 3
15478: PPUSH
15479: LD_INT 81
15481: PUSH
15482: LD_INT 3
15484: PUSH
15485: EMPTY
15486: LIST
15487: LIST
15488: PPUSH
15489: CALL_OW 70
15493: ST_TO_ADDR
// if filter and enemy then
15494: LD_VAR 0 4
15498: PUSH
15499: LD_VAR 0 3
15503: AND
15504: IFFALSE 15587
// repeat wait ( 0 0$01 ) ;
15506: LD_INT 35
15508: PPUSH
15509: CALL_OW 67
// for i in filter do
15513: LD_ADDR_VAR 0 1
15517: PUSH
15518: LD_VAR 0 4
15522: PUSH
15523: FOR_IN
15524: IFFALSE 15552
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15526: LD_VAR 0 1
15530: PPUSH
15531: LD_VAR 0 3
15535: PPUSH
15536: LD_VAR 0 1
15540: PPUSH
15541: CALL_OW 74
15545: PPUSH
15546: CALL_OW 115
// end ;
15550: GO 15523
15552: POP
15553: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
15554: LD_INT 3
15556: PPUSH
15557: LD_INT 81
15559: PUSH
15560: LD_INT 3
15562: PUSH
15563: EMPTY
15564: LIST
15565: LIST
15566: PPUSH
15567: CALL_OW 70
15571: PUSH
15572: LD_INT 0
15574: EQUAL
15575: PUSH
15576: LD_VAR 0 4
15580: PUSH
15581: LD_INT 0
15583: EQUAL
15584: OR
15585: IFFALSE 15506
// end ;
15587: PPOPN 4
15589: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) do var i ;
15590: LD_EXP 25
15594: PUSH
15595: LD_INT 22
15597: PUSH
15598: LD_INT 4
15600: PUSH
15601: EMPTY
15602: LIST
15603: LIST
15604: PUSH
15605: LD_INT 30
15607: PUSH
15608: LD_INT 4
15610: PUSH
15611: EMPTY
15612: LIST
15613: LIST
15614: PUSH
15615: EMPTY
15616: LIST
15617: LIST
15618: PPUSH
15619: CALL_OW 69
15623: AND
15624: IFFALSE 15673
15626: GO 15628
15628: DISABLE
15629: LD_INT 0
15631: PPUSH
// begin if not ru_cornel_attack then
15632: LD_EXP 54
15636: NOT
15637: IFFALSE 15641
// exit ;
15639: GO 15673
// for i in ru_cornel_attack do
15641: LD_ADDR_VAR 0 1
15645: PUSH
15646: LD_EXP 54
15650: PUSH
15651: FOR_IN
15652: IFFALSE 15671
// ComAgressiveMove ( i , 258 , 119 ) ;
15654: LD_VAR 0 1
15658: PPUSH
15659: LD_INT 258
15661: PPUSH
15662: LD_INT 119
15664: PPUSH
15665: CALL_OW 114
15669: GO 15651
15671: POP
15672: POP
// end ; end_of_file
15673: PPOPN 1
15675: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
15676: LD_EXP 5
15680: PUSH
15681: LD_EXP 9
15685: NOT
15686: AND
15687: PUSH
15688: LD_EXP 19
15692: AND
15693: IFFALSE 15805
15695: GO 15697
15697: DISABLE
15698: LD_INT 0
15700: PPUSH
// begin enable ;
15701: ENABLE
// crates_counter := crates_counter - 50 ;
15702: LD_ADDR_EXP 19
15706: PUSH
15707: LD_EXP 19
15711: PUSH
15712: LD_INT 50
15714: MINUS
15715: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
15716: LD_INT 8
15718: PPUSH
15719: LD_INT 2
15721: PPUSH
15722: LD_INT 5
15724: PPUSH
15725: CALL_OW 12
15729: PPUSH
15730: LD_INT 1
15732: PPUSH
15733: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
15737: LD_INT 1785
15739: PPUSH
15740: LD_INT 2345
15742: PPUSH
15743: CALL_OW 12
15747: PPUSH
15748: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
15752: LD_ADDR_VAR 0 1
15756: PUSH
15757: LD_INT 1
15759: PPUSH
15760: LD_OWVAR 67
15764: PUSH
15765: LD_INT 2
15767: PLUS
15768: PPUSH
15769: CALL_OW 12
15773: ST_TO_ADDR
// if r < 3 then
15774: LD_VAR 0 1
15778: PUSH
15779: LD_INT 3
15781: LESS
15782: IFFALSE 15805
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
15784: LD_INT 4
15786: PPUSH
15787: LD_INT 1
15789: PPUSH
15790: LD_INT 5
15792: PPUSH
15793: CALL_OW 12
15797: PPUSH
15798: LD_INT 1
15800: PPUSH
15801: CALL_OW 55
// end ;
15805: PPOPN 1
15807: END
// every 0 0$01 trigger cornel_active do
15808: LD_EXP 8
15812: IFFALSE 15901
15814: GO 15816
15816: DISABLE
// begin Wait ( 0 0$03 ) ;
15817: LD_INT 105
15819: PPUSH
15820: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15824: LD_INT 2
15826: PPUSH
15827: LD_INT 5
15829: PPUSH
15830: CALL_OW 12
15834: PPUSH
15835: LD_INT 10
15837: PPUSH
15838: LD_INT 1
15840: PPUSH
15841: CALL_OW 55
// Wait ( 0 0$13 ) ;
15845: LD_INT 455
15847: PPUSH
15848: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15852: LD_INT 2
15854: PPUSH
15855: LD_INT 5
15857: PPUSH
15858: CALL_OW 12
15862: PPUSH
15863: LD_INT 10
15865: PPUSH
15866: LD_INT 1
15868: PPUSH
15869: CALL_OW 55
// Wait ( 0 0$16 ) ;
15873: LD_INT 560
15875: PPUSH
15876: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15880: LD_INT 2
15882: PPUSH
15883: LD_INT 5
15885: PPUSH
15886: CALL_OW 12
15890: PPUSH
15891: LD_INT 10
15893: PPUSH
15894: LD_INT 1
15896: PPUSH
15897: CALL_OW 55
// end ; end_of_file
15901: END
// every 0 0$01 trigger cornel_prepared do
15902: LD_EXP 11
15906: IFFALSE 15965
15908: GO 15910
15910: DISABLE
// begin enable ;
15911: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
15912: LD_ADDR_OWVAR 47
15916: PUSH
15917: LD_STRING #Am03-1
15919: PUSH
15920: LD_EXP 10
15924: PUSH
15925: EMPTY
15926: LIST
15927: LIST
15928: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
15929: LD_ADDR_EXP 10
15933: PUSH
15934: LD_EXP 10
15938: PPUSH
15939: LD_STRING -
15941: PPUSH
15942: CALL 1093 0 2
15946: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
15947: LD_EXP 10
15951: PUSH
15952: LD_INT 0
15954: EQUAL
15955: IFFALSE 15965
// begin Display_Strings := [ ] ;
15957: LD_ADDR_OWVAR 47
15961: PUSH
15962: EMPTY
15963: ST_TO_ADDR
// disable ;
15964: DISABLE
// end ; end ;
15965: END
// every 0 0$01 trigger debug and debug_strings do
15966: LD_EXP 1
15970: PUSH
15971: LD_OWVAR 48
15975: AND
15976: IFFALSE 15992
15978: GO 15980
15980: DISABLE
// begin enable ;
15981: ENABLE
// Display_Strings := debug_strings ;
15982: LD_ADDR_OWVAR 47
15986: PUSH
15987: LD_OWVAR 48
15991: ST_TO_ADDR
// end ; end_of_file
15992: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
15993: LD_VAR 0 1
15997: PPUSH
15998: CALL_OW 255
16002: PUSH
16003: LD_INT 1
16005: EQUAL
16006: PUSH
16007: LD_EXP 13
16011: NOT
16012: AND
16013: IFFALSE 16023
// solar_builded := true ;
16015: LD_ADDR_EXP 13
16019: PUSH
16020: LD_INT 1
16022: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
16023: LD_VAR 0 1
16027: PPUSH
16028: CALL_OW 255
16032: PUSH
16033: LD_INT 1
16035: EQUAL
16036: PUSH
16037: LD_EXP 27
16041: AND
16042: IFFALSE 16075
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
16044: LD_ADDR_EXP 27
16048: PUSH
16049: LD_EXP 27
16053: PUSH
16054: LD_INT 1750
16056: PUSH
16057: LD_INT 1400
16059: PUSH
16060: LD_INT 1225
16062: PUSH
16063: EMPTY
16064: LIST
16065: LIST
16066: LIST
16067: PUSH
16068: LD_OWVAR 67
16072: ARRAY
16073: PLUS
16074: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
16075: LD_VAR 0 1
16079: PPUSH
16080: CALL_OW 255
16084: PUSH
16085: LD_INT 3
16087: EQUAL
16088: IFFALSE 16106
// ru_vehicles := ru_vehicles ^ veh ;
16090: LD_ADDR_EXP 52
16094: PUSH
16095: LD_EXP 52
16099: PUSH
16100: LD_VAR 0 1
16104: ADD
16105: ST_TO_ADDR
// end ;
16106: PPOPN 2
16108: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
16109: LD_VAR 0 1
16113: PUSH
16114: LD_EXP 49
16118: IN
16119: IFFALSE 16137
// ru_patrol := ru_patrol diff un ;
16121: LD_ADDR_EXP 49
16125: PUSH
16126: LD_EXP 49
16130: PUSH
16131: LD_VAR 0 1
16135: DIFF
16136: ST_TO_ADDR
// if un in ru_forest then
16137: LD_VAR 0 1
16141: PUSH
16142: LD_EXP 51
16146: IN
16147: IFFALSE 16165
// ru_forest := ru_forest diff un ;
16149: LD_ADDR_EXP 51
16153: PUSH
16154: LD_EXP 51
16158: PUSH
16159: LD_VAR 0 1
16163: DIFF
16164: ST_TO_ADDR
// if un in ru_vehicles then
16165: LD_VAR 0 1
16169: PUSH
16170: LD_EXP 52
16174: IN
16175: IFFALSE 16250
// begin ru_vehicles := ru_vehicles diff un ;
16177: LD_ADDR_EXP 52
16181: PUSH
16182: LD_EXP 52
16186: PUSH
16187: LD_VAR 0 1
16191: DIFF
16192: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
16193: LD_ADDR_EXP 53
16197: PUSH
16198: LD_EXP 53
16202: PUSH
16203: LD_VAR 0 1
16207: PPUSH
16208: CALL_OW 265
16212: PUSH
16213: LD_VAR 0 1
16217: PPUSH
16218: CALL_OW 262
16222: PUSH
16223: LD_VAR 0 1
16227: PPUSH
16228: CALL_OW 263
16232: PUSH
16233: LD_VAR 0 1
16237: PPUSH
16238: CALL_OW 264
16242: PUSH
16243: EMPTY
16244: LIST
16245: LIST
16246: LIST
16247: LIST
16248: ADD
16249: ST_TO_ADDR
// end ; if un = JMM then
16250: LD_VAR 0 1
16254: PUSH
16255: LD_EXP 33
16259: EQUAL
16260: IFFALSE 16269
// YouLost ( 0 ) ;
16262: LD_STRING 0
16264: PPUSH
16265: CALL_OW 104
// if un = us_dep_west then
16269: LD_VAR 0 1
16273: PUSH
16274: LD_INT 1
16276: EQUAL
16277: IFFALSE 16286
// YouLost ( 2 ) ;
16279: LD_STRING 2
16281: PPUSH
16282: CALL_OW 104
// if un = Lynch and GetSide ( Lynch ) = 8 then
16286: LD_VAR 0 1
16290: PUSH
16291: LD_EXP 43
16295: EQUAL
16296: PUSH
16297: LD_EXP 43
16301: PPUSH
16302: CALL_OW 255
16306: PUSH
16307: LD_INT 8
16309: EQUAL
16310: AND
16311: IFFALSE 16320
// YouLost ( 4 ) ;
16313: LD_STRING 4
16315: PPUSH
16316: CALL_OW 104
// if un in jmm_units then
16320: LD_VAR 0 1
16324: PUSH
16325: LD_EXP 4
16329: IN
16330: IFFALSE 16346
// lose_counter := lose_counter + 1 ;
16332: LD_ADDR_EXP 32
16336: PUSH
16337: LD_EXP 32
16341: PUSH
16342: LD_INT 1
16344: PLUS
16345: ST_TO_ADDR
// end ;
16346: PPOPN 1
16348: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
16349: LD_INT 0
16351: PPUSH
16352: PPUSH
// begin if GetSide ( driver ) = 3 then
16353: LD_VAR 0 1
16357: PPUSH
16358: CALL_OW 255
16362: PUSH
16363: LD_INT 3
16365: EQUAL
16366: IFFALSE 16444
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
16368: LD_ADDR_VAR 0 6
16372: PUSH
16373: LD_INT 22
16375: PUSH
16376: LD_INT 3
16378: PUSH
16379: EMPTY
16380: LIST
16381: LIST
16382: PUSH
16383: LD_INT 30
16385: PUSH
16386: LD_INT 3
16388: PUSH
16389: EMPTY
16390: LIST
16391: LIST
16392: PUSH
16393: EMPTY
16394: LIST
16395: LIST
16396: PPUSH
16397: CALL_OW 69
16401: PPUSH
16402: CALL 1023 0 1
16406: ST_TO_ADDR
// if place then
16407: LD_VAR 0 6
16411: IFFALSE 16429
// ComEnterUnit ( driver , place ) else
16413: LD_VAR 0 1
16417: PPUSH
16418: LD_VAR 0 6
16422: PPUSH
16423: CALL_OW 120
16427: GO 16444
// ComMoveXY ( driver , 70 , 22 ) ;
16429: LD_VAR 0 1
16433: PPUSH
16434: LD_INT 70
16436: PPUSH
16437: LD_INT 22
16439: PPUSH
16440: CALL_OW 111
// end ; end ;
16444: PPOPN 6
16446: END
// every 0 0$01 trigger not game_end and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) < 4 do
16447: LD_EXP 31
16451: NOT
16452: PUSH
16453: LD_INT 22
16455: PUSH
16456: LD_INT 1
16458: PUSH
16459: EMPTY
16460: LIST
16461: LIST
16462: PUSH
16463: LD_INT 21
16465: PUSH
16466: LD_INT 1
16468: PUSH
16469: EMPTY
16470: LIST
16471: LIST
16472: PUSH
16473: EMPTY
16474: LIST
16475: LIST
16476: PPUSH
16477: CALL_OW 69
16481: PUSH
16482: LD_INT 22
16484: PUSH
16485: LD_INT 8
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PUSH
16492: LD_INT 21
16494: PUSH
16495: LD_INT 1
16497: PUSH
16498: EMPTY
16499: LIST
16500: LIST
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: PPUSH
16506: CALL_OW 69
16510: PLUS
16511: PUSH
16512: LD_INT 4
16514: LESS
16515: AND
16516: IFFALSE 16528
16518: GO 16520
16520: DISABLE
// YouLost ( 1 ) ;
16521: LD_STRING 1
16523: PPUSH
16524: CALL_OW 104
16528: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
16529: LD_INT 1
16531: PPUSH
16532: CALL_OW 255
16536: PUSH
16537: LD_INT 3
16539: EQUAL
16540: IFFALSE 16552
16542: GO 16544
16544: DISABLE
// YouLost ( 3 ) ;
16545: LD_STRING 3
16547: PPUSH
16548: CALL_OW 104
16552: END
