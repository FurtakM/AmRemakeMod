// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 355 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 443 0 0
// PrepareRussian ;
  22: CALL 2972 0 0
// PrepareAmerican ;
  26: CALL 1177 0 0
// PrepareCornell ;
  30: CALL 2201 0 0
// PrepareWesternBase ;
  34: CALL 2427 0 0
// Action ;
  38: CALL 5188 0 0
// end ;
  42: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn , save_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  54: LD_ADDR_EXP 3
  58: PUSH
  59: LD_STRING 02_
  61: ST_TO_ADDR
// mission_prefix := 03_ ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_STRING 03_
  69: ST_TO_ADDR
// jmm_units := 0 ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// cornel_units := 0 ;
  78: LD_ADDR_EXP 6
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// bierezov_exist := false ;
  86: LD_ADDR_EXP 7
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// jmm_on_west := false ;
  94: LD_ADDR_EXP 5
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_active := false ;
 102: LD_ADDR_EXP 8
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_attack := false ;
 110: LD_ADDR_EXP 9
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// cornel_prepared := false ;
 118: LD_ADDR_EXP 11
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 126: LD_ADDR_EXP 10
 130: PUSH
 131: LD_INT 4200
 133: ST_TO_ADDR
// frank_can_return := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// solar_builded := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// frank_send_to_scout := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// jmm_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// bobby_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// cyrus_in_veh := false ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// lisa_in_veh := false ;
 182: LD_ADDR_EXP 18
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 190: LD_ADDR_EXP 27
 194: PUSH
 195: LD_INT 25200
 197: PUSH
 198: LD_INT 23100
 200: PUSH
 201: LD_INT 21000
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: PUSH
 209: LD_OWVAR 67
 213: ARRAY
 214: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 215: LD_ADDR_EXP 19
 219: PUSH
 220: LD_INT 600
 222: PUSH
 223: LD_INT 500
 225: PUSH
 226: LD_INT 400
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: PUSH
 234: LD_OWVAR 67
 238: ARRAY
 239: ST_TO_ADDR
// end_mission_allowed := false ;
 240: LD_ADDR_EXP 20
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// save_others := [ ] ;
 248: LD_ADDR_EXP 21
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// save_group := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// show_query := true ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// wait_for_them := false ;
 270: LD_ADDR_EXP 24
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// veh_on_meta := false ;
 278: LD_ADDR_EXP 26
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_spec_patrol := false ;
 286: LD_ADDR_EXP 28
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// prepare_siege := false ;
 294: LD_ADDR_EXP 29
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// send_attack_on_cornel := false ;
 302: LD_ADDR_EXP 30
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 310: LD_ADDR_EXP 25
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// game_end := false ;
 318: LD_ADDR_EXP 31
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// lose_counter := 0 ;
 326: LD_ADDR_EXP 32
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// powell_warn := 0 ;
 334: LD_ADDR_EXP 33
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// save_counter := 0 ;
 342: LD_ADDR_EXP 34
 346: PUSH
 347: LD_INT 0
 349: ST_TO_ADDR
// end ;
 350: LD_VAR 0 1
 354: RET
// function SetDiplomacy ; begin
 355: LD_INT 0
 357: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 358: LD_INT 1
 360: PPUSH
 361: LD_INT 4
 363: PPUSH
 364: LD_INT 1
 366: PPUSH
 367: LD_INT 1
 369: PPUSH
 370: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 374: LD_INT 1
 376: PPUSH
 377: LD_INT 8
 379: PPUSH
 380: LD_INT 1
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 390: LD_INT 3
 392: PPUSH
 393: LD_INT 6
 395: PPUSH
 396: LD_INT 1
 398: PPUSH
 399: LD_INT 1
 401: PPUSH
 402: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 406: LD_INT 4
 408: PPUSH
 409: LD_INT 6
 411: PPUSH
 412: LD_INT 0
 414: PPUSH
 415: LD_INT 1
 417: PPUSH
 418: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 422: LD_INT 3
 424: PPUSH
 425: LD_INT 8
 427: PPUSH
 428: LD_INT 0
 430: PPUSH
 431: LD_INT 1
 433: PPUSH
 434: CALL_OW 80
// end ;
 438: LD_VAR 0 1
 442: RET
// export function DebugMode ; var i ; begin
 443: LD_INT 0
 445: PPUSH
 446: PPUSH
// FogOff ( 1 ) ;
 447: LD_INT 1
 449: PPUSH
 450: CALL_OW 344
// debug_strings := [ ] ;
 454: LD_ADDR_OWVAR 48
 458: PUSH
 459: EMPTY
 460: ST_TO_ADDR
// end ; end_of_file
 461: LD_VAR 0 1
 465: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 466: LD_INT 0
 468: PPUSH
 469: PPUSH
// if exist_mode then
 470: LD_VAR 0 2
 474: IFFALSE 499
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 476: LD_ADDR_VAR 0 4
 480: PUSH
 481: LD_EXP 3
 485: PUSH
 486: LD_VAR 0 1
 490: STR
 491: PPUSH
 492: CALL_OW 34
 496: ST_TO_ADDR
 497: GO 514
// unit := NewCharacter ( ident ) ;
 499: LD_ADDR_VAR 0 4
 503: PUSH
 504: LD_VAR 0 1
 508: PPUSH
 509: CALL_OW 25
 513: ST_TO_ADDR
// result := unit ;
 514: LD_ADDR_VAR 0 3
 518: PUSH
 519: LD_VAR 0 4
 523: ST_TO_ADDR
// end ;
 524: LD_VAR 0 3
 528: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 529: LD_INT 0
 531: PPUSH
// uc_side := side ;
 532: LD_ADDR_OWVAR 20
 536: PUSH
 537: LD_VAR 0 1
 541: ST_TO_ADDR
// uc_nation := nation ;
 542: LD_ADDR_OWVAR 21
 546: PUSH
 547: LD_VAR 0 2
 551: ST_TO_ADDR
// vc_chassis := chassis ;
 552: LD_ADDR_OWVAR 37
 556: PUSH
 557: LD_VAR 0 3
 561: ST_TO_ADDR
// vc_engine := engine ;
 562: LD_ADDR_OWVAR 39
 566: PUSH
 567: LD_VAR 0 4
 571: ST_TO_ADDR
// vc_control := control ;
 572: LD_ADDR_OWVAR 38
 576: PUSH
 577: LD_VAR 0 5
 581: ST_TO_ADDR
// vc_weapon := weapon ;
 582: LD_ADDR_OWVAR 40
 586: PUSH
 587: LD_VAR 0 6
 591: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 592: LD_ADDR_OWVAR 41
 596: PUSH
 597: LD_VAR 0 7
 601: ST_TO_ADDR
// result := CreateVehicle ;
 602: LD_ADDR_VAR 0 8
 606: PUSH
 607: CALL_OW 45
 611: ST_TO_ADDR
// end ;
 612: LD_VAR 0 8
 616: RET
// export function SayX ( units , ident ) ; var i ; begin
 617: LD_INT 0
 619: PPUSH
 620: PPUSH
// result := false ;
 621: LD_ADDR_VAR 0 3
 625: PUSH
 626: LD_INT 0
 628: ST_TO_ADDR
// if not units then
 629: LD_VAR 0 1
 633: NOT
 634: IFFALSE 638
// exit ;
 636: GO 692
// for i in units do
 638: LD_ADDR_VAR 0 4
 642: PUSH
 643: LD_VAR 0 1
 647: PUSH
 648: FOR_IN
 649: IFFALSE 690
// if IsOk ( i ) then
 651: LD_VAR 0 4
 655: PPUSH
 656: CALL_OW 302
 660: IFFALSE 688
// begin Say ( i , ident ) ;
 662: LD_VAR 0 4
 666: PPUSH
 667: LD_VAR 0 2
 671: PPUSH
 672: CALL_OW 88
// result := i ;
 676: LD_ADDR_VAR 0 3
 680: PUSH
 681: LD_VAR 0 4
 685: ST_TO_ADDR
// break ;
 686: GO 690
// end ;
 688: GO 648
 690: POP
 691: POP
// end ;
 692: LD_VAR 0 3
 696: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 697: LD_INT 0
 699: PPUSH
 700: PPUSH
 701: PPUSH
 702: PPUSH
// for i = 1 to count do
 703: LD_ADDR_VAR 0 8
 707: PUSH
 708: DOUBLE
 709: LD_INT 1
 711: DEC
 712: ST_TO_ADDR
 713: LD_VAR 0 6
 717: PUSH
 718: FOR_TO
 719: IFFALSE 800
// begin uc_side = side ;
 721: LD_ADDR_OWVAR 20
 725: PUSH
 726: LD_VAR 0 1
 730: ST_TO_ADDR
// uc_nation = nation ;
 731: LD_ADDR_OWVAR 21
 735: PUSH
 736: LD_VAR 0 2
 740: ST_TO_ADDR
// hc_gallery =  ;
 741: LD_ADDR_OWVAR 33
 745: PUSH
 746: LD_STRING 
 748: ST_TO_ADDR
// hc_name =  ;
 749: LD_ADDR_OWVAR 26
 753: PUSH
 754: LD_STRING 
 756: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 757: LD_INT 0
 759: PPUSH
 760: LD_VAR 0 5
 764: PPUSH
 765: LD_VAR 0 4
 769: PPUSH
 770: CALL_OW 380
// un = CreateHuman ;
 774: LD_ADDR_VAR 0 10
 778: PUSH
 779: CALL_OW 44
 783: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 784: LD_VAR 0 10
 788: PPUSH
 789: LD_VAR 0 3
 793: PPUSH
 794: CALL_OW 52
// end ;
 798: GO 718
 800: POP
 801: POP
// end ;
 802: LD_VAR 0 7
 806: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 807: LD_INT 0
 809: PPUSH
 810: PPUSH
 811: PPUSH
// uc_side := GetSide ( b ) ;
 812: LD_ADDR_OWVAR 20
 816: PUSH
 817: LD_VAR 0 2
 821: PPUSH
 822: CALL_OW 255
 826: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 827: LD_ADDR_OWVAR 21
 831: PUSH
 832: LD_VAR 0 2
 836: PPUSH
 837: CALL_OW 248
 841: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 842: LD_INT 0
 844: PPUSH
 845: LD_INT 1
 847: PPUSH
 848: LD_VAR 0 1
 852: PPUSH
 853: CALL_OW 380
// un = CreateHuman ;
 857: LD_ADDR_VAR 0 4
 861: PUSH
 862: CALL_OW 44
 866: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 867: LD_ADDR_VAR 0 5
 871: PUSH
 872: LD_VAR 0 2
 876: PPUSH
 877: CALL_OW 254
 881: PUSH
 882: LD_INT 3
 884: MINUS
 885: ST_TO_ADDR
// if dir < 0 then
 886: LD_VAR 0 5
 890: PUSH
 891: LD_INT 0
 893: LESS
 894: IFFALSE 910
// dir := 6 + dir ;
 896: LD_ADDR_VAR 0 5
 900: PUSH
 901: LD_INT 6
 903: PUSH
 904: LD_VAR 0 5
 908: PLUS
 909: ST_TO_ADDR
// SetDir ( un , dir ) ;
 910: LD_VAR 0 4
 914: PPUSH
 915: LD_VAR 0 5
 919: PPUSH
 920: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 924: LD_VAR 0 4
 928: PPUSH
 929: LD_VAR 0 2
 933: PPUSH
 934: CALL_OW 52
// end ;
 938: LD_VAR 0 3
 942: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 943: LD_INT 0
 945: PPUSH
 946: PPUSH
 947: PPUSH
// result := false ;
 948: LD_ADDR_VAR 0 2
 952: PUSH
 953: LD_INT 0
 955: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 956: LD_ADDR_VAR 0 3
 960: PUSH
 961: LD_INT 22
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: PUSH
 971: LD_INT 34
 973: PUSH
 974: LD_INT 2
 976: PUSH
 977: EMPTY
 978: LIST
 979: LIST
 980: PUSH
 981: EMPTY
 982: LIST
 983: LIST
 984: PPUSH
 985: CALL_OW 69
 989: ST_TO_ADDR
// for i in filter do
 990: LD_ADDR_VAR 0 4
 994: PUSH
 995: LD_VAR 0 3
 999: PUSH
1000: FOR_IN
1001: IFFALSE 1032
// if IsDrivenBy ( i ) = unit then
1003: LD_VAR 0 4
1007: PPUSH
1008: CALL_OW 311
1012: PUSH
1013: LD_VAR 0 1
1017: EQUAL
1018: IFFALSE 1030
// begin result := true ;
1020: LD_ADDR_VAR 0 2
1024: PUSH
1025: LD_INT 1
1027: ST_TO_ADDR
// break ;
1028: GO 1032
// end ;
1030: GO 1000
1032: POP
1033: POP
// end ;
1034: LD_VAR 0 2
1038: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1039: LD_INT 0
1041: PPUSH
1042: PPUSH
// result := false ;
1043: LD_ADDR_VAR 0 2
1047: PUSH
1048: LD_INT 0
1050: ST_TO_ADDR
// if not blist then
1051: LD_VAR 0 1
1055: NOT
1056: IFFALSE 1060
// exit ;
1058: GO 1104
// for i in blist do
1060: LD_ADDR_VAR 0 3
1064: PUSH
1065: LD_VAR 0 1
1069: PUSH
1070: FOR_IN
1071: IFFALSE 1102
// if UnitsInside ( i ) < 6 then
1073: LD_VAR 0 3
1077: PPUSH
1078: CALL_OW 313
1082: PUSH
1083: LD_INT 6
1085: LESS
1086: IFFALSE 1100
// begin result := i ;
1088: LD_ADDR_VAR 0 2
1092: PUSH
1093: LD_VAR 0 3
1097: ST_TO_ADDR
// break ;
1098: GO 1102
// end ;
1100: GO 1070
1102: POP
1103: POP
// end ;
1104: LD_VAR 0 2
1108: RET
// export function Count ( timer , mode ) ; begin
1109: LD_INT 0
1111: PPUSH
// if not timer then
1112: LD_VAR 0 1
1116: NOT
1117: IFFALSE 1121
// exit ;
1119: GO 1172
// if mode in [ asc , up , + ] then
1121: LD_VAR 0 2
1125: PUSH
1126: LD_STRING asc
1128: PUSH
1129: LD_STRING up
1131: PUSH
1132: LD_STRING +
1134: PUSH
1135: EMPTY
1136: LIST
1137: LIST
1138: LIST
1139: IN
1140: IFFALSE 1158
// result := timer + 0 0$01 else
1142: LD_ADDR_VAR 0 3
1146: PUSH
1147: LD_VAR 0 1
1151: PUSH
1152: LD_INT 35
1154: PLUS
1155: ST_TO_ADDR
1156: GO 1172
// result := timer - 0 0$01 ;
1158: LD_ADDR_VAR 0 3
1162: PUSH
1163: LD_VAR 0 1
1167: PUSH
1168: LD_INT 35
1170: MINUS
1171: ST_TO_ADDR
// end ; end_of_file
1172: LD_VAR 0 3
1176: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1177: LD_INT 0
1179: PPUSH
1180: PPUSH
1181: PPUSH
1182: PPUSH
1183: PPUSH
1184: PPUSH
1185: PPUSH
1186: PPUSH
// uc_side := 4 ;
1187: LD_ADDR_OWVAR 20
1191: PUSH
1192: LD_INT 4
1194: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1195: LD_ADDR_EXP 44
1199: PUSH
1200: LD_STRING Powell
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL 466 0 2
1210: ST_TO_ADDR
// uc_side := 1 ;
1211: LD_ADDR_OWVAR 20
1215: PUSH
1216: LD_INT 1
1218: ST_TO_ADDR
// uc_nation := 1 ;
1219: LD_ADDR_OWVAR 21
1223: PUSH
1224: LD_INT 1
1226: ST_TO_ADDR
// if debug then
1227: LD_EXP 1
1231: IFFALSE 1361
// begin for i = 1 to 4 do
1233: LD_ADDR_VAR 0 2
1237: PUSH
1238: DOUBLE
1239: LD_INT 1
1241: DEC
1242: ST_TO_ADDR
1243: LD_INT 4
1245: PUSH
1246: FOR_TO
1247: IFFALSE 1298
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1249: LD_INT 0
1251: PPUSH
1252: LD_INT 1
1254: PPUSH
1255: LD_INT 2
1257: PPUSH
1258: CALL_OW 12
1262: PPUSH
1263: LD_INT 3
1265: PPUSH
1266: CALL_OW 380
// un := CreateHuman ;
1270: LD_ADDR_VAR 0 3
1274: PUSH
1275: CALL_OW 44
1279: ST_TO_ADDR
// others := others ^ un ;
1280: LD_ADDR_VAR 0 5
1284: PUSH
1285: LD_VAR 0 5
1289: PUSH
1290: LD_VAR 0 3
1294: ADD
1295: ST_TO_ADDR
// end ;
1296: GO 1246
1298: POP
1299: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1300: LD_ADDR_VAR 0 6
1304: PUSH
1305: LD_INT 21
1307: PUSH
1308: LD_INT 1
1310: PUSH
1311: LD_INT 1
1313: PUSH
1314: LD_INT 51
1316: PUSH
1317: LD_INT 90
1319: PUSH
1320: LD_INT 504
1322: PUSH
1323: EMPTY
1324: LIST
1325: LIST
1326: LIST
1327: LIST
1328: LIST
1329: LIST
1330: PUSH
1331: LD_INT 21
1333: PUSH
1334: LD_INT 1
1336: PUSH
1337: LD_INT 1
1339: PUSH
1340: LD_INT 51
1342: PUSH
1343: LD_INT 80
1345: PUSH
1346: LD_INT 750
1348: PUSH
1349: EMPTY
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: LIST
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1361: LD_ADDR_EXP 35
1365: PUSH
1366: LD_STRING JMM
1368: PPUSH
1369: LD_EXP 1
1373: NOT
1374: PPUSH
1375: CALL 466 0 2
1379: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1380: LD_ADDR_EXP 36
1384: PUSH
1385: LD_STRING Bobby
1387: PPUSH
1388: LD_EXP 1
1392: NOT
1393: PPUSH
1394: CALL 466 0 2
1398: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1399: LD_ADDR_EXP 37
1403: PUSH
1404: LD_STRING Cyrus
1406: PPUSH
1407: LD_EXP 1
1411: NOT
1412: PPUSH
1413: CALL 466 0 2
1417: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1418: LD_ADDR_EXP 38
1422: PUSH
1423: LD_STRING Lisa
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: CALL 466 0 2
1436: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1437: LD_ADDR_EXP 39
1441: PUSH
1442: LD_STRING Khatam
1444: PPUSH
1445: LD_EXP 1
1449: NOT
1450: PPUSH
1451: CALL 466 0 2
1455: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1456: LD_ADDR_EXP 40
1460: PUSH
1461: LD_STRING Brian
1463: PPUSH
1464: LD_EXP 1
1468: NOT
1469: PPUSH
1470: CALL 466 0 2
1474: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1475: LD_ADDR_EXP 41
1479: PUSH
1480: LD_STRING Jerry
1482: PPUSH
1483: LD_EXP 1
1487: NOT
1488: PPUSH
1489: CALL 466 0 2
1493: ST_TO_ADDR
// if Bobby then
1494: LD_EXP 36
1498: IFFALSE 1529
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1500: LD_ADDR_VAR 0 4
1504: PUSH
1505: LD_VAR 0 4
1509: PPUSH
1510: LD_VAR 0 4
1514: PUSH
1515: LD_INT 1
1517: PLUS
1518: PPUSH
1519: LD_EXP 36
1523: PPUSH
1524: CALL_OW 2
1528: ST_TO_ADDR
// if Cyrus then
1529: LD_EXP 37
1533: IFFALSE 1564
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1535: LD_ADDR_VAR 0 4
1539: PUSH
1540: LD_VAR 0 4
1544: PPUSH
1545: LD_VAR 0 4
1549: PUSH
1550: LD_INT 1
1552: PLUS
1553: PPUSH
1554: LD_EXP 37
1558: PPUSH
1559: CALL_OW 2
1563: ST_TO_ADDR
// if Lisa then
1564: LD_EXP 38
1568: IFFALSE 1599
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1570: LD_ADDR_VAR 0 4
1574: PUSH
1575: LD_VAR 0 4
1579: PPUSH
1580: LD_VAR 0 4
1584: PUSH
1585: LD_INT 1
1587: PLUS
1588: PPUSH
1589: LD_EXP 38
1593: PPUSH
1594: CALL_OW 2
1598: ST_TO_ADDR
// if Khatam then
1599: LD_EXP 39
1603: IFFALSE 1634
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1605: LD_ADDR_VAR 0 4
1609: PUSH
1610: LD_VAR 0 4
1614: PPUSH
1615: LD_VAR 0 4
1619: PUSH
1620: LD_INT 1
1622: PLUS
1623: PPUSH
1624: LD_EXP 39
1628: PPUSH
1629: CALL_OW 2
1633: ST_TO_ADDR
// if Brian then
1634: LD_EXP 40
1638: IFFALSE 1669
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1640: LD_ADDR_VAR 0 4
1644: PUSH
1645: LD_VAR 0 4
1649: PPUSH
1650: LD_VAR 0 4
1654: PUSH
1655: LD_INT 1
1657: PLUS
1658: PPUSH
1659: LD_EXP 40
1663: PPUSH
1664: CALL_OW 2
1668: ST_TO_ADDR
// if Jerry then
1669: LD_EXP 41
1673: IFFALSE 1704
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1675: LD_ADDR_VAR 0 4
1679: PUSH
1680: LD_VAR 0 4
1684: PPUSH
1685: LD_VAR 0 4
1689: PUSH
1690: LD_INT 1
1692: PLUS
1693: PPUSH
1694: LD_EXP 41
1698: PPUSH
1699: CALL_OW 2
1703: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1704: LD_STRING 02_other_survivors
1706: PPUSH
1707: CALL_OW 28
1711: IFFALSE 1726
// others := CreateCharacterSet ( 02_other_survivors ) ;
1713: LD_ADDR_VAR 0 5
1717: PUSH
1718: LD_STRING 02_other_survivors
1720: PPUSH
1721: CALL_OW 31
1725: ST_TO_ADDR
// if others then
1726: LD_VAR 0 5
1730: IFFALSE 1755
// begin tmp := tmp ^ others ;
1732: LD_ADDR_VAR 0 4
1736: PUSH
1737: LD_VAR 0 4
1741: PUSH
1742: LD_VAR 0 5
1746: ADD
1747: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1748: LD_STRING 02_other_survivors
1750: PPUSH
1751: CALL_OW 40
// end ; jmm_units := tmp ;
1755: LD_ADDR_EXP 4
1759: PUSH
1760: LD_VAR 0 4
1764: ST_TO_ADDR
// if not vehicles then
1765: LD_VAR 0 6
1769: NOT
1770: IFFALSE 1788
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1772: LD_ADDR_VAR 0 6
1776: PUSH
1777: LD_STRING 02_tanks_1
1779: PPUSH
1780: LD_INT 0
1782: PPUSH
1783: CALL_OW 30
1787: ST_TO_ADDR
// if vehicles then
1788: LD_VAR 0 6
1792: IFFALSE 1986
// begin got_mech := false ;
1794: LD_ADDR_VAR 0 7
1798: PUSH
1799: LD_INT 0
1801: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1802: LD_VAR 0 4
1806: PPUSH
1807: LD_INT 25
1809: PUSH
1810: LD_INT 3
1812: PUSH
1813: EMPTY
1814: LIST
1815: LIST
1816: PPUSH
1817: CALL_OW 72
1821: IFFALSE 1831
// got_mech := true ;
1823: LD_ADDR_VAR 0 7
1827: PUSH
1828: LD_INT 1
1830: ST_TO_ADDR
// for i = 1 to vehicles do
1831: LD_ADDR_VAR 0 2
1835: PUSH
1836: DOUBLE
1837: LD_INT 1
1839: DEC
1840: ST_TO_ADDR
1841: LD_VAR 0 6
1845: PUSH
1846: FOR_TO
1847: IFFALSE 1984
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1849: LD_ADDR_VAR 0 3
1853: PUSH
1854: LD_INT 1
1856: PPUSH
1857: LD_INT 3
1859: PPUSH
1860: LD_VAR 0 6
1864: PUSH
1865: LD_VAR 0 2
1869: ARRAY
1870: PUSH
1871: LD_INT 1
1873: ARRAY
1874: PPUSH
1875: LD_VAR 0 6
1879: PUSH
1880: LD_VAR 0 2
1884: ARRAY
1885: PUSH
1886: LD_INT 2
1888: ARRAY
1889: PPUSH
1890: LD_VAR 0 6
1894: PUSH
1895: LD_VAR 0 2
1899: ARRAY
1900: PUSH
1901: LD_INT 3
1903: ARRAY
1904: PPUSH
1905: LD_VAR 0 6
1909: PUSH
1910: LD_VAR 0 2
1914: ARRAY
1915: PUSH
1916: LD_INT 4
1918: ARRAY
1919: PPUSH
1920: LD_INT 40
1922: PPUSH
1923: CALL 529 0 7
1927: ST_TO_ADDR
// if not got_mech then
1928: LD_VAR 0 7
1932: NOT
1933: IFFALSE 1959
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1935: LD_VAR 0 3
1939: PPUSH
1940: LD_VAR 0 6
1944: PUSH
1945: LD_VAR 0 2
1949: ARRAY
1950: PUSH
1951: LD_INT 6
1953: ARRAY
1954: PPUSH
1955: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1959: LD_ADDR_VAR 0 4
1963: PUSH
1964: LD_VAR 0 4
1968: PPUSH
1969: LD_INT 1
1971: PPUSH
1972: LD_VAR 0 3
1976: PPUSH
1977: CALL_OW 2
1981: ST_TO_ADDR
// end ;
1982: GO 1846
1984: POP
1985: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1986: LD_EXP 35
1990: PPUSH
1991: LD_INT 194
1993: PPUSH
1994: LD_INT 119
1996: PPUSH
1997: LD_INT 0
1999: PPUSH
2000: CALL_OW 48
// if tmp then
2004: LD_VAR 0 4
2008: IFFALSE 2133
// begin for i in tmp do
2010: LD_ADDR_VAR 0 2
2014: PUSH
2015: LD_VAR 0 4
2019: PUSH
2020: FOR_IN
2021: IFFALSE 2131
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2023: LD_ADDR_VAR 0 8
2027: PUSH
2028: LD_INT 22
2030: PUSH
2031: LD_INT 1
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PUSH
2038: LD_INT 21
2040: PUSH
2041: LD_INT 2
2043: PUSH
2044: EMPTY
2045: LIST
2046: LIST
2047: PUSH
2048: LD_INT 58
2050: PUSH
2051: EMPTY
2052: LIST
2053: PUSH
2054: EMPTY
2055: LIST
2056: LIST
2057: LIST
2058: PPUSH
2059: CALL_OW 69
2063: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2064: LD_VAR 0 2
2068: PPUSH
2069: CALL_OW 247
2073: PUSH
2074: LD_INT 1
2076: EQUAL
2077: PUSH
2078: LD_VAR 0 8
2082: AND
2083: IFFALSE 2105
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2085: LD_VAR 0 2
2089: PPUSH
2090: LD_VAR 0 8
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PPUSH
2099: CALL_OW 52
2103: GO 2120
// PlaceUnitArea ( i , startArea , false ) ;
2105: LD_VAR 0 2
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_INT 0
2115: PPUSH
2116: CALL_OW 49
// ComHold ( i ) ;
2120: LD_VAR 0 2
2124: PPUSH
2125: CALL_OW 140
// end ;
2129: GO 2020
2131: POP
2132: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2133: LD_ADDR_EXP 7
2137: PUSH
2138: LD_STRING 02_mikhailStatus_1
2140: PPUSH
2141: LD_INT 0
2143: PPUSH
2144: CALL_OW 30
2148: ST_TO_ADDR
// if not bierezov_exist and not debug then
2149: LD_EXP 7
2153: NOT
2154: PUSH
2155: LD_EXP 1
2159: NOT
2160: AND
2161: IFFALSE 2165
// exit ;
2163: GO 2196
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2165: LD_ADDR_EXP 43
2169: PUSH
2170: LD_STRING Mikhail
2172: PPUSH
2173: LD_INT 0
2175: PPUSH
2176: CALL 466 0 2
2180: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2181: LD_EXP 43
2185: PPUSH
2186: LD_INT 1
2188: PPUSH
2189: LD_INT 0
2191: PPUSH
2192: CALL_OW 49
// end ;
2196: LD_VAR 0 1
2200: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2201: LD_INT 0
2203: PPUSH
2204: PPUSH
2205: PPUSH
2206: PPUSH
// uc_side := 4 ;
2207: LD_ADDR_OWVAR 20
2211: PUSH
2212: LD_INT 4
2214: ST_TO_ADDR
// uc_nation := 1 ;
2215: LD_ADDR_OWVAR 21
2219: PUSH
2220: LD_INT 1
2222: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2223: LD_ADDR_EXP 42
2227: PUSH
2228: LD_STRING Cornell
2230: PPUSH
2231: LD_INT 0
2233: PPUSH
2234: CALL 466 0 2
2238: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2239: LD_ADDR_EXP 6
2243: PUSH
2244: LD_INT 9
2246: PUSH
2247: LD_EXP 4
2251: MINUS
2252: ST_TO_ADDR
// tmp := [ ] ;
2253: LD_ADDR_VAR 0 2
2257: PUSH
2258: EMPTY
2259: ST_TO_ADDR
// if cornel_units < 4 then
2260: LD_EXP 6
2264: PUSH
2265: LD_INT 4
2267: LESS
2268: IFFALSE 2278
// cornel_units := 4 ;
2270: LD_ADDR_EXP 6
2274: PUSH
2275: LD_INT 4
2277: ST_TO_ADDR
// for i = 1 to cornel_units do
2278: LD_ADDR_VAR 0 4
2282: PUSH
2283: DOUBLE
2284: LD_INT 1
2286: DEC
2287: ST_TO_ADDR
2288: LD_EXP 6
2292: PUSH
2293: FOR_TO
2294: IFFALSE 2392
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2296: LD_INT 0
2298: PPUSH
2299: LD_INT 1
2301: PUSH
2302: LD_INT 1
2304: PUSH
2305: LD_INT 1
2307: PUSH
2308: LD_INT 2
2310: PUSH
2311: LD_INT 4
2313: PUSH
2314: EMPTY
2315: LIST
2316: LIST
2317: LIST
2318: LIST
2319: LIST
2320: PUSH
2321: LD_VAR 0 4
2325: PUSH
2326: LD_INT 5
2328: MOD
2329: PUSH
2330: LD_INT 1
2332: PLUS
2333: ARRAY
2334: PPUSH
2335: LD_INT 2
2337: PPUSH
2338: CALL_OW 380
// un := CreateHuman ;
2342: LD_ADDR_VAR 0 3
2346: PUSH
2347: CALL_OW 44
2351: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2352: LD_ADDR_VAR 0 2
2356: PUSH
2357: LD_VAR 0 2
2361: PPUSH
2362: LD_INT 1
2364: PPUSH
2365: LD_VAR 0 3
2369: PPUSH
2370: CALL_OW 2
2374: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2375: LD_VAR 0 3
2379: PPUSH
2380: LD_INT 2
2382: PPUSH
2383: LD_INT 0
2385: PPUSH
2386: CALL_OW 49
// end ;
2390: GO 2293
2392: POP
2393: POP
// cornel_units := tmp ;
2394: LD_ADDR_EXP 6
2398: PUSH
2399: LD_VAR 0 2
2403: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2404: LD_EXP 42
2408: PPUSH
2409: LD_INT 191
2411: PPUSH
2412: LD_INT 106
2414: PPUSH
2415: LD_INT 0
2417: PPUSH
2418: CALL_OW 48
// end ;
2422: LD_VAR 0 1
2426: RET
// export function PrepareWesternBase ; var i ; begin
2427: LD_INT 0
2429: PPUSH
2430: PPUSH
// uc_side := 8 ;
2431: LD_ADDR_OWVAR 20
2435: PUSH
2436: LD_INT 8
2438: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2439: LD_ADDR_EXP 45
2443: PUSH
2444: LD_STRING Lynch
2446: PPUSH
2447: LD_INT 0
2449: PPUSH
2450: CALL 466 0 2
2454: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2455: LD_ADDR_EXP 46
2459: PUSH
2460: LD_STRING Walker
2462: PPUSH
2463: LD_INT 0
2465: PPUSH
2466: CALL 466 0 2
2470: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2471: LD_ADDR_EXP 47
2475: PUSH
2476: LD_STRING Turner
2478: PPUSH
2479: LD_INT 0
2481: PPUSH
2482: CALL 466 0 2
2486: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2487: LD_ADDR_EXP 48
2491: PUSH
2492: LD_STRING Jillian
2494: PPUSH
2495: LD_INT 0
2497: PPUSH
2498: CALL 466 0 2
2502: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2503: LD_ADDR_VAR 0 2
2507: PUSH
2508: LD_EXP 45
2512: PUSH
2513: LD_EXP 46
2517: PUSH
2518: LD_EXP 47
2522: PUSH
2523: LD_EXP 48
2527: PUSH
2528: EMPTY
2529: LIST
2530: LIST
2531: LIST
2532: LIST
2533: PUSH
2534: FOR_IN
2535: IFFALSE 2563
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2537: LD_VAR 0 2
2541: PPUSH
2542: LD_INT 3
2544: PPUSH
2545: LD_INT 0
2547: PPUSH
2548: CALL_OW 49
// ComHold ( i ) ;
2552: LD_VAR 0 2
2556: PPUSH
2557: CALL_OW 140
// end ;
2561: GO 2534
2563: POP
2564: POP
// end ;
2565: LD_VAR 0 1
2569: RET
// export function SelectGroup ; var units , selected , i ; begin
2570: LD_INT 0
2572: PPUSH
2573: PPUSH
2574: PPUSH
2575: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2576: LD_ADDR_VAR 0 2
2580: PUSH
2581: LD_EXP 35
2585: PUSH
2586: LD_INT -3
2588: PUSH
2589: EMPTY
2590: LIST
2591: LIST
2592: PUSH
2593: LD_EXP 4
2597: ADD
2598: PUSH
2599: LD_INT -2
2601: PUSH
2602: LD_INT -4
2604: PUSH
2605: LD_EXP 42
2609: PUSH
2610: LD_EXP 43
2614: PUSH
2615: EMPTY
2616: LIST
2617: LIST
2618: LIST
2619: LIST
2620: ADD
2621: PUSH
2622: LD_INT -3
2624: PUSH
2625: EMPTY
2626: LIST
2627: ADD
2628: PUSH
2629: LD_EXP 6
2633: ADD
2634: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2635: LD_ADDR_VAR 0 3
2639: PUSH
2640: LD_EXP 35
2644: PUSH
2645: LD_STRING Select five characters to go with you
2647: PPUSH
2648: LD_INT 4
2650: PPUSH
2651: LD_INT 4
2653: PPUSH
2654: LD_VAR 0 2
2658: PPUSH
2659: EMPTY
2660: PPUSH
2661: CALL_OW 42
2665: ADD
2666: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2667: LD_ADDR_EXP 6
2671: PUSH
2672: LD_EXP 4
2676: PUSH
2677: LD_EXP 6
2681: UNION
2682: PUSH
2683: LD_VAR 0 3
2687: DIFF
2688: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2689: LD_ADDR_VAR 0 4
2693: PUSH
2694: LD_EXP 6
2698: PUSH
2699: LD_EXP 43
2703: ADD
2704: PUSH
2705: FOR_IN
2706: IFFALSE 2737
// if GetSide ( i ) = 1 then
2708: LD_VAR 0 4
2712: PPUSH
2713: CALL_OW 255
2717: PUSH
2718: LD_INT 1
2720: EQUAL
2721: IFFALSE 2735
// SetSide ( i , 4 ) ;
2723: LD_VAR 0 4
2727: PPUSH
2728: LD_INT 4
2730: PPUSH
2731: CALL_OW 235
2735: GO 2705
2737: POP
2738: POP
// for i in selected do
2739: LD_ADDR_VAR 0 4
2743: PUSH
2744: LD_VAR 0 3
2748: PUSH
2749: FOR_IN
2750: IFFALSE 2781
// if GetSide ( i ) = 4 then
2752: LD_VAR 0 4
2756: PPUSH
2757: CALL_OW 255
2761: PUSH
2762: LD_INT 4
2764: EQUAL
2765: IFFALSE 2779
// SetSide ( i , 1 ) ;
2767: LD_VAR 0 4
2771: PPUSH
2772: LD_INT 1
2774: PPUSH
2775: CALL_OW 235
2779: GO 2749
2781: POP
2782: POP
// jmm_units := jmm_units diff cornel_units ;
2783: LD_ADDR_EXP 4
2787: PUSH
2788: LD_EXP 4
2792: PUSH
2793: LD_EXP 6
2797: DIFF
2798: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2799: LD_EXP 36
2803: PPUSH
2804: CALL_OW 255
2808: PUSH
2809: LD_INT 4
2811: EQUAL
2812: IFFALSE 2827
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2814: LD_EXP 3
2818: PUSH
2819: LD_STRING Bobby
2821: STR
2822: PPUSH
2823: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2827: LD_EXP 37
2831: PPUSH
2832: CALL_OW 255
2836: PUSH
2837: LD_INT 4
2839: EQUAL
2840: IFFALSE 2855
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2842: LD_EXP 3
2846: PUSH
2847: LD_STRING Cyrus
2849: STR
2850: PPUSH
2851: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2855: LD_EXP 38
2859: PPUSH
2860: CALL_OW 255
2864: PUSH
2865: LD_INT 4
2867: EQUAL
2868: IFFALSE 2883
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2870: LD_EXP 3
2874: PUSH
2875: LD_STRING Lisa
2877: STR
2878: PPUSH
2879: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2883: LD_EXP 39
2887: PPUSH
2888: CALL_OW 255
2892: PUSH
2893: LD_INT 4
2895: EQUAL
2896: IFFALSE 2911
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
2898: LD_EXP 3
2902: PUSH
2903: LD_STRING Khatam
2905: STR
2906: PPUSH
2907: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2911: LD_EXP 40
2915: PPUSH
2916: CALL_OW 255
2920: PUSH
2921: LD_INT 4
2923: EQUAL
2924: IFFALSE 2939
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
2926: LD_EXP 3
2930: PUSH
2931: LD_STRING Brian
2933: STR
2934: PPUSH
2935: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2939: LD_EXP 41
2943: PPUSH
2944: CALL_OW 255
2948: PUSH
2949: LD_INT 4
2951: EQUAL
2952: IFFALSE 2967
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
2954: LD_EXP 3
2958: PUSH
2959: LD_STRING Jerry
2961: STR
2962: PPUSH
2963: CALL_OW 40
// end ; end_of_file
2967: LD_VAR 0 1
2971: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
2972: LD_INT 0
2974: PPUSH
2975: PPUSH
2976: PPUSH
2977: PPUSH
2978: PPUSH
2979: PPUSH
2980: PPUSH
2981: PPUSH
2982: PPUSH
2983: PPUSH
2984: PPUSH
2985: PPUSH
2986: PPUSH
// ru_alert := false ;
2987: LD_ADDR_EXP 58
2991: PUSH
2992: LD_INT 0
2994: ST_TO_ADDR
// ru_produce_list := [ ] ;
2995: LD_ADDR_EXP 55
2999: PUSH
3000: EMPTY
3001: ST_TO_ADDR
// if Difficulty > 1 then
3002: LD_OWVAR 67
3006: PUSH
3007: LD_INT 1
3009: GREATER
3010: IFFALSE 3098
// begin uc_side := 3 ;
3012: LD_ADDR_OWVAR 20
3016: PUSH
3017: LD_INT 3
3019: ST_TO_ADDR
// uc_nation := 3 ;
3020: LD_ADDR_OWVAR 21
3024: PUSH
3025: LD_INT 3
3027: ST_TO_ADDR
// bc_type := b_breastwork ;
3028: LD_ADDR_OWVAR 42
3032: PUSH
3033: LD_INT 31
3035: ST_TO_ADDR
// bc_level := Difficulty ;
3036: LD_ADDR_OWVAR 43
3040: PUSH
3041: LD_OWVAR 67
3045: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3046: LD_INT 22
3048: PPUSH
3049: LD_INT 14
3051: PPUSH
3052: LD_INT 0
3054: PPUSH
3055: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3059: LD_INT 48
3061: PPUSH
3062: LD_INT 46
3064: PPUSH
3065: LD_INT 0
3067: PPUSH
3068: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3072: LD_INT 86
3074: PPUSH
3075: LD_INT 65
3077: PPUSH
3078: LD_INT 5
3080: PPUSH
3081: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3085: LD_INT 165
3087: PPUSH
3088: LD_INT 73
3090: PPUSH
3091: LD_INT 5
3093: PPUSH
3094: CALL_OW 47
// end ; if Difficulty = 3 then
3098: LD_OWVAR 67
3102: PUSH
3103: LD_INT 3
3105: EQUAL
3106: IFFALSE 3121
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3108: LD_INT 51
3110: PPUSH
3111: LD_INT 3
3113: PPUSH
3114: LD_INT 2
3116: PPUSH
3117: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3121: LD_ADDR_VAR 0 7
3125: PUSH
3126: LD_INT 22
3128: PUSH
3129: LD_INT 3
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: PUSH
3136: LD_INT 2
3138: PUSH
3139: LD_INT 30
3141: PUSH
3142: LD_INT 31
3144: PUSH
3145: EMPTY
3146: LIST
3147: LIST
3148: PUSH
3149: LD_INT 30
3151: PUSH
3152: LD_INT 32
3154: PUSH
3155: EMPTY
3156: LIST
3157: LIST
3158: PUSH
3159: EMPTY
3160: LIST
3161: LIST
3162: LIST
3163: PUSH
3164: EMPTY
3165: LIST
3166: LIST
3167: PPUSH
3168: CALL_OW 69
3172: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3173: LD_ADDR_VAR 0 8
3177: PUSH
3178: LD_INT 22
3180: PUSH
3181: LD_INT 3
3183: PUSH
3184: EMPTY
3185: LIST
3186: LIST
3187: PUSH
3188: LD_INT 30
3190: PUSH
3191: LD_INT 4
3193: PUSH
3194: EMPTY
3195: LIST
3196: LIST
3197: PUSH
3198: EMPTY
3199: LIST
3200: LIST
3201: PPUSH
3202: CALL_OW 69
3206: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3207: LD_ADDR_VAR 0 10
3211: PUSH
3212: LD_INT 22
3214: PUSH
3215: LD_INT 3
3217: PUSH
3218: EMPTY
3219: LIST
3220: LIST
3221: PUSH
3222: LD_INT 30
3224: PUSH
3225: LD_INT 3
3227: PUSH
3228: EMPTY
3229: LIST
3230: LIST
3231: PUSH
3232: EMPTY
3233: LIST
3234: LIST
3235: PPUSH
3236: CALL_OW 69
3240: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3241: LD_ADDR_VAR 0 9
3245: PUSH
3246: LD_INT 22
3248: PUSH
3249: LD_INT 3
3251: PUSH
3252: EMPTY
3253: LIST
3254: LIST
3255: PUSH
3256: LD_INT 30
3258: PUSH
3259: LD_INT 6
3261: PUSH
3262: EMPTY
3263: LIST
3264: LIST
3265: PUSH
3266: EMPTY
3267: LIST
3268: LIST
3269: PPUSH
3270: CALL_OW 69
3274: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3275: LD_ADDR_VAR 0 2
3279: PUSH
3280: LD_INT 22
3282: PUSH
3283: LD_INT 3
3285: PUSH
3286: EMPTY
3287: LIST
3288: LIST
3289: PUSH
3290: LD_INT 30
3292: PUSH
3293: LD_INT 1
3295: PUSH
3296: EMPTY
3297: LIST
3298: LIST
3299: PUSH
3300: EMPTY
3301: LIST
3302: LIST
3303: PPUSH
3304: CALL_OW 69
3308: PUSH
3309: FOR_IN
3310: IFFALSE 3354
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3312: LD_VAR 0 2
3316: PPUSH
3317: CALL_OW 274
3321: PPUSH
3322: LD_INT 1
3324: PPUSH
3325: LD_INT 5000
3327: PPUSH
3328: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3332: LD_VAR 0 2
3336: PPUSH
3337: CALL_OW 274
3341: PPUSH
3342: LD_INT 2
3344: PPUSH
3345: LD_INT 3000
3347: PPUSH
3348: CALL_OW 277
// end ;
3352: GO 3309
3354: POP
3355: POP
// uc_side := 3 ;
3356: LD_ADDR_OWVAR 20
3360: PUSH
3361: LD_INT 3
3363: ST_TO_ADDR
// uc_nation := 3 ;
3364: LD_ADDR_OWVAR 21
3368: PUSH
3369: LD_INT 3
3371: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3372: LD_ADDR_VAR 0 11
3376: PUSH
3377: LD_INT 2
3379: PUSH
3380: LD_INT 3
3382: PUSH
3383: LD_INT 4
3385: PUSH
3386: EMPTY
3387: LIST
3388: LIST
3389: LIST
3390: PUSH
3391: LD_OWVAR 67
3395: ARRAY
3396: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3397: LD_ADDR_EXP 50
3401: PUSH
3402: LD_STRING Pokryshkin
3404: PPUSH
3405: LD_INT 0
3407: PPUSH
3408: CALL 466 0 2
3412: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3413: LD_EXP 50
3417: PPUSH
3418: LD_INT 63
3420: PPUSH
3421: LD_INT 21
3423: PPUSH
3424: LD_INT 0
3426: PPUSH
3427: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3431: LD_EXP 50
3435: PPUSH
3436: CALL_OW 140
// InitHc ;
3440: CALL_OW 19
// for i in fac do
3444: LD_ADDR_VAR 0 2
3448: PUSH
3449: LD_VAR 0 10
3453: PUSH
3454: FOR_IN
3455: IFFALSE 3508
// begin for j = 1 to 6 do
3457: LD_ADDR_VAR 0 3
3461: PUSH
3462: DOUBLE
3463: LD_INT 1
3465: DEC
3466: ST_TO_ADDR
3467: LD_INT 6
3469: PUSH
3470: FOR_TO
3471: IFFALSE 3504
// begin PrepareHuman ( false , 3 , skill ) ;
3473: LD_INT 0
3475: PPUSH
3476: LD_INT 3
3478: PPUSH
3479: LD_VAR 0 11
3483: PPUSH
3484: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3488: CALL_OW 44
3492: PPUSH
3493: LD_VAR 0 2
3497: PPUSH
3498: CALL_OW 52
// end ;
3502: GO 3470
3504: POP
3505: POP
// end ;
3506: GO 3454
3508: POP
3509: POP
// for i in lab do
3510: LD_ADDR_VAR 0 2
3514: PUSH
3515: LD_VAR 0 9
3519: PUSH
3520: FOR_IN
3521: IFFALSE 3554
// begin PrepareHuman ( false , 4 , skill ) ;
3523: LD_INT 0
3525: PPUSH
3526: LD_INT 4
3528: PPUSH
3529: LD_VAR 0 11
3533: PPUSH
3534: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3538: CALL_OW 44
3542: PPUSH
3543: LD_VAR 0 2
3547: PPUSH
3548: CALL_OW 52
// end ;
3552: GO 3520
3554: POP
3555: POP
// for i in tw do
3556: LD_ADDR_VAR 0 2
3560: PUSH
3561: LD_VAR 0 7
3565: PUSH
3566: FOR_IN
3567: IFFALSE 3616
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3569: LD_VAR 0 2
3573: PPUSH
3574: LD_INT 42
3576: PUSH
3577: LD_INT 43
3579: PUSH
3580: EMPTY
3581: LIST
3582: LIST
3583: PUSH
3584: LD_INT 1
3586: PPUSH
3587: LD_INT 2
3589: PPUSH
3590: CALL_OW 12
3594: ARRAY
3595: PPUSH
3596: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3600: LD_VAR 0 11
3604: PPUSH
3605: LD_VAR 0 2
3609: PPUSH
3610: CALL 807 0 2
// end ;
3614: GO 3566
3616: POP
3617: POP
// for i in bar do
3618: LD_ADDR_VAR 0 2
3622: PUSH
3623: LD_VAR 0 8
3627: PUSH
3628: FOR_IN
3629: IFFALSE 3662
// begin PrepareHuman ( false , 1 , skill ) ;
3631: LD_INT 0
3633: PPUSH
3634: LD_INT 1
3636: PPUSH
3637: LD_VAR 0 11
3641: PPUSH
3642: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3646: CALL_OW 44
3650: PPUSH
3651: LD_VAR 0 2
3655: PPUSH
3656: CALL_OW 52
// end ;
3660: GO 3628
3662: POP
3663: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3664: LD_ADDR_VAR 0 13
3668: PUSH
3669: LD_INT 100
3671: PUSH
3672: LD_INT 9
3674: PUSH
3675: EMPTY
3676: LIST
3677: LIST
3678: PUSH
3679: LD_INT 135
3681: PUSH
3682: LD_INT 60
3684: PUSH
3685: EMPTY
3686: LIST
3687: LIST
3688: PUSH
3689: LD_INT 41
3691: PUSH
3692: LD_INT 6
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: LD_INT 22
3701: PUSH
3702: LD_INT 9
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: PUSH
3709: LD_INT 84
3711: PUSH
3712: LD_INT 14
3714: PUSH
3715: EMPTY
3716: LIST
3717: LIST
3718: PUSH
3719: EMPTY
3720: LIST
3721: LIST
3722: LIST
3723: LIST
3724: LIST
3725: ST_TO_ADDR
// vehicles := [ ] ;
3726: LD_ADDR_VAR 0 12
3730: PUSH
3731: EMPTY
3732: ST_TO_ADDR
// for i in spot_xy do
3733: LD_ADDR_VAR 0 2
3737: PUSH
3738: LD_VAR 0 13
3742: PUSH
3743: FOR_IN
3744: IFFALSE 3902
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3746: LD_ADDR_VAR 0 6
3750: PUSH
3751: LD_INT 3
3753: PPUSH
3754: LD_INT 3
3756: PPUSH
3757: LD_INT 22
3759: PPUSH
3760: LD_INT 1
3762: PPUSH
3763: LD_INT 1
3765: PPUSH
3766: LD_INT 42
3768: PUSH
3769: LD_INT 43
3771: PUSH
3772: LD_INT 44
3774: PUSH
3775: EMPTY
3776: LIST
3777: LIST
3778: LIST
3779: PUSH
3780: LD_INT 1
3782: PPUSH
3783: LD_INT 3
3785: PPUSH
3786: CALL_OW 12
3790: ARRAY
3791: PPUSH
3792: LD_INT 100
3794: PPUSH
3795: CALL 529 0 7
3799: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3800: LD_ADDR_VAR 0 12
3804: PUSH
3805: LD_VAR 0 12
3809: PPUSH
3810: LD_VAR 0 12
3814: PUSH
3815: LD_INT 1
3817: PLUS
3818: PPUSH
3819: LD_VAR 0 6
3823: PPUSH
3824: CALL_OW 2
3828: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3829: LD_VAR 0 6
3833: PPUSH
3834: LD_INT 3
3836: PPUSH
3837: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3841: LD_VAR 0 6
3845: PPUSH
3846: LD_VAR 0 2
3850: PUSH
3851: LD_INT 1
3853: ARRAY
3854: PPUSH
3855: LD_VAR 0 2
3859: PUSH
3860: LD_INT 2
3862: ARRAY
3863: PPUSH
3864: LD_INT 0
3866: PPUSH
3867: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3871: LD_INT 0
3873: PPUSH
3874: LD_INT 3
3876: PPUSH
3877: LD_VAR 0 11
3881: PPUSH
3882: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3886: CALL_OW 44
3890: PPUSH
3891: LD_VAR 0 6
3895: PPUSH
3896: CALL_OW 52
// end ;
3900: GO 3743
3902: POP
3903: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3904: LD_ADDR_VAR 0 2
3908: PUSH
3909: DOUBLE
3910: LD_INT 1
3912: DEC
3913: ST_TO_ADDR
3914: LD_INT 5
3916: PUSH
3917: LD_INT 7
3919: PUSH
3920: LD_INT 8
3922: PUSH
3923: EMPTY
3924: LIST
3925: LIST
3926: LIST
3927: PUSH
3928: LD_OWVAR 67
3932: ARRAY
3933: PUSH
3934: FOR_TO
3935: IFFALSE 3995
// begin PrepareHuman ( false , 1 , skill ) ;
3937: LD_INT 0
3939: PPUSH
3940: LD_INT 1
3942: PPUSH
3943: LD_VAR 0 11
3947: PPUSH
3948: CALL_OW 380
// un := CreateHuman ;
3952: LD_ADDR_VAR 0 5
3956: PUSH
3957: CALL_OW 44
3961: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3962: LD_VAR 0 5
3966: PPUSH
3967: LD_INT 11
3969: PPUSH
3970: LD_INT 0
3972: PPUSH
3973: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3977: LD_ADDR_EXP 53
3981: PUSH
3982: LD_EXP 53
3986: PUSH
3987: LD_VAR 0 5
3991: ADD
3992: ST_TO_ADDR
// end ;
3993: GO 3934
3995: POP
3996: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3997: LD_ADDR_VAR 0 2
4001: PUSH
4002: DOUBLE
4003: LD_INT 1
4005: DEC
4006: ST_TO_ADDR
4007: LD_INT 2
4009: PUSH
4010: LD_INT 3
4012: PUSH
4013: LD_INT 4
4015: PUSH
4016: EMPTY
4017: LIST
4018: LIST
4019: LIST
4020: PUSH
4021: LD_OWVAR 67
4025: ARRAY
4026: PUSH
4027: FOR_TO
4028: IFFALSE 4088
// begin PrepareHuman ( false , 1 , skill ) ;
4030: LD_INT 0
4032: PPUSH
4033: LD_INT 1
4035: PPUSH
4036: LD_VAR 0 11
4040: PPUSH
4041: CALL_OW 380
// un := CreateHuman ;
4045: LD_ADDR_VAR 0 5
4049: PUSH
4050: CALL_OW 44
4054: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4055: LD_VAR 0 5
4059: PPUSH
4060: LD_INT 12
4062: PPUSH
4063: LD_INT 0
4065: PPUSH
4066: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4070: LD_ADDR_EXP 51
4074: PUSH
4075: LD_EXP 51
4079: PUSH
4080: LD_VAR 0 5
4084: ADD
4085: ST_TO_ADDR
// end ;
4086: GO 4027
4088: POP
4089: POP
// for i = 1 to 2 do
4090: LD_ADDR_VAR 0 2
4094: PUSH
4095: DOUBLE
4096: LD_INT 1
4098: DEC
4099: ST_TO_ADDR
4100: LD_INT 2
4102: PUSH
4103: FOR_TO
4104: IFFALSE 4170
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4106: LD_INT 1
4108: PPUSH
4109: LD_INT 1
4111: PPUSH
4112: LD_VAR 0 11
4116: PPUSH
4117: CALL_OW 380
// un := CreateHuman ;
4121: LD_ADDR_VAR 0 5
4125: PUSH
4126: CALL_OW 44
4130: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4131: LD_VAR 0 5
4135: PPUSH
4136: LD_INT 39
4138: PPUSH
4139: LD_INT 12
4141: PPUSH
4142: LD_INT 3
4144: PPUSH
4145: LD_INT 0
4147: PPUSH
4148: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4152: LD_ADDR_EXP 52
4156: PUSH
4157: LD_EXP 52
4161: PUSH
4162: LD_VAR 0 5
4166: ADD
4167: ST_TO_ADDR
// end ;
4168: GO 4103
4170: POP
4171: POP
// for i = 1 to 3 do
4172: LD_ADDR_VAR 0 2
4176: PUSH
4177: DOUBLE
4178: LD_INT 1
4180: DEC
4181: ST_TO_ADDR
4182: LD_INT 3
4184: PUSH
4185: FOR_TO
4186: IFFALSE 4252
// begin PrepareHuman ( false , 1 , skill ) ;
4188: LD_INT 0
4190: PPUSH
4191: LD_INT 1
4193: PPUSH
4194: LD_VAR 0 11
4198: PPUSH
4199: CALL_OW 380
// un := CreateHuman ;
4203: LD_ADDR_VAR 0 5
4207: PUSH
4208: CALL_OW 44
4212: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4213: LD_VAR 0 5
4217: PPUSH
4218: LD_INT 180
4220: PPUSH
4221: LD_INT 11
4223: PPUSH
4224: LD_INT 4
4226: PPUSH
4227: LD_INT 0
4229: PPUSH
4230: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4234: LD_ADDR_EXP 56
4238: PUSH
4239: LD_EXP 56
4243: PUSH
4244: LD_VAR 0 5
4248: ADD
4249: ST_TO_ADDR
// end ;
4250: GO 4185
4252: POP
4253: POP
// ru_vehicles := vehicles ;
4254: LD_ADDR_EXP 54
4258: PUSH
4259: LD_VAR 0 12
4263: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4264: LD_ADDR_EXP 57
4268: PUSH
4269: LD_INT 131
4271: PUSH
4272: LD_INT 121
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: PUSH
4279: LD_INT 113
4281: PUSH
4282: LD_INT 90
4284: PUSH
4285: EMPTY
4286: LIST
4287: LIST
4288: PUSH
4289: LD_INT 93
4291: PUSH
4292: LD_INT 62
4294: PUSH
4295: EMPTY
4296: LIST
4297: LIST
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: LIST
4303: PUSH
4304: LD_INT 106
4306: PUSH
4307: LD_INT 54
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: PUSH
4314: LD_INT 120
4316: PUSH
4317: LD_INT 80
4319: PUSH
4320: EMPTY
4321: LIST
4322: LIST
4323: PUSH
4324: LD_INT 143
4326: PUSH
4327: LD_INT 120
4329: PUSH
4330: EMPTY
4331: LIST
4332: LIST
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: LIST
4338: PUSH
4339: LD_INT 154
4341: PUSH
4342: LD_INT 116
4344: PUSH
4345: EMPTY
4346: LIST
4347: LIST
4348: PUSH
4349: LD_INT 140
4351: PUSH
4352: LD_INT 93
4354: PUSH
4355: EMPTY
4356: LIST
4357: LIST
4358: PUSH
4359: LD_INT 130
4361: PUSH
4362: LD_INT 58
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: LIST
4373: PUSH
4374: LD_INT 105
4376: PUSH
4377: LD_INT 106
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: PUSH
4384: LD_INT 134
4386: PUSH
4387: LD_INT 98
4389: PUSH
4390: EMPTY
4391: LIST
4392: LIST
4393: PUSH
4394: LD_INT 159
4396: PUSH
4397: LD_INT 113
4399: PUSH
4400: EMPTY
4401: LIST
4402: LIST
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: LIST
4408: PUSH
4409: EMPTY
4410: LIST
4411: LIST
4412: LIST
4413: LIST
4414: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4415: LD_ADDR_VAR 0 2
4419: PUSH
4420: DOUBLE
4421: LD_INT 1
4423: DEC
4424: ST_TO_ADDR
4425: LD_OWVAR 67
4429: PUSH
4430: LD_INT 1
4432: MINUS
4433: PUSH
4434: FOR_TO
4435: IFFALSE 4468
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4437: LD_ADDR_EXP 55
4441: PUSH
4442: LD_EXP 55
4446: PUSH
4447: LD_INT 22
4449: PUSH
4450: LD_INT 1
4452: PUSH
4453: LD_INT 1
4455: PUSH
4456: LD_INT 43
4458: PUSH
4459: EMPTY
4460: LIST
4461: LIST
4462: LIST
4463: LIST
4464: ADD
4465: ST_TO_ADDR
4466: GO 4434
4468: POP
4469: POP
// end ;
4470: LD_VAR 0 1
4474: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4475: LD_INT 22
4477: PUSH
4478: LD_INT 3
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: PUSH
4485: LD_INT 21
4487: PUSH
4488: LD_INT 2
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: PUSH
4495: EMPTY
4496: LIST
4497: LIST
4498: PPUSH
4499: CALL_OW 69
4503: IFFALSE 4597
4505: GO 4507
4507: DISABLE
4508: LD_INT 0
4510: PPUSH
4511: PPUSH
// begin enable ;
4512: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4513: LD_ADDR_VAR 0 2
4517: PUSH
4518: LD_INT 22
4520: PUSH
4521: LD_INT 3
4523: PUSH
4524: EMPTY
4525: LIST
4526: LIST
4527: PUSH
4528: LD_INT 21
4530: PUSH
4531: LD_INT 2
4533: PUSH
4534: EMPTY
4535: LIST
4536: LIST
4537: PUSH
4538: EMPTY
4539: LIST
4540: LIST
4541: PPUSH
4542: CALL_OW 69
4546: ST_TO_ADDR
// if filter then
4547: LD_VAR 0 2
4551: IFFALSE 4597
// for i in filter do
4553: LD_ADDR_VAR 0 1
4557: PUSH
4558: LD_VAR 0 2
4562: PUSH
4563: FOR_IN
4564: IFFALSE 4595
// if GetFuel ( i ) < 20 then
4566: LD_VAR 0 1
4570: PPUSH
4571: CALL_OW 261
4575: PUSH
4576: LD_INT 20
4578: LESS
4579: IFFALSE 4593
// SetFuel ( i , 20 ) ;
4581: LD_VAR 0 1
4585: PPUSH
4586: LD_INT 20
4588: PPUSH
4589: CALL_OW 240
4593: GO 4563
4595: POP
4596: POP
// end ;
4597: PPOPN 2
4599: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4600: LD_EXP 55
4604: IFFALSE 4823
4606: GO 4608
4608: DISABLE
4609: LD_INT 0
4611: PPUSH
4612: PPUSH
4613: PPUSH
// begin enable ;
4614: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4615: LD_ADDR_VAR 0 2
4619: PUSH
4620: LD_INT 22
4622: PUSH
4623: LD_INT 3
4625: PUSH
4626: EMPTY
4627: LIST
4628: LIST
4629: PUSH
4630: LD_INT 30
4632: PUSH
4633: LD_INT 3
4635: PUSH
4636: EMPTY
4637: LIST
4638: LIST
4639: PUSH
4640: EMPTY
4641: LIST
4642: LIST
4643: PPUSH
4644: CALL_OW 69
4648: ST_TO_ADDR
// can_produce := [ ] ;
4649: LD_ADDR_VAR 0 3
4653: PUSH
4654: EMPTY
4655: ST_TO_ADDR
// if not fac then
4656: LD_VAR 0 2
4660: NOT
4661: IFFALSE 4666
// begin disable ;
4663: DISABLE
// exit ;
4664: GO 4823
// end ; for i in fac do
4666: LD_ADDR_VAR 0 1
4670: PUSH
4671: LD_VAR 0 2
4675: PUSH
4676: FOR_IN
4677: IFFALSE 4715
// if UnitsInside ( i ) then
4679: LD_VAR 0 1
4683: PPUSH
4684: CALL_OW 313
4688: IFFALSE 4713
// can_produce := Insert ( can_produce , 1 , i ) ;
4690: LD_ADDR_VAR 0 3
4694: PUSH
4695: LD_VAR 0 3
4699: PPUSH
4700: LD_INT 1
4702: PPUSH
4703: LD_VAR 0 1
4707: PPUSH
4708: CALL_OW 2
4712: ST_TO_ADDR
4713: GO 4676
4715: POP
4716: POP
// if not can_produce then
4717: LD_VAR 0 3
4721: NOT
4722: IFFALSE 4726
// exit ;
4724: GO 4823
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4726: LD_VAR 0 3
4730: PUSH
4731: LD_INT 1
4733: PPUSH
4734: LD_VAR 0 3
4738: PPUSH
4739: CALL_OW 12
4743: ARRAY
4744: PPUSH
4745: LD_EXP 55
4749: PUSH
4750: LD_INT 1
4752: ARRAY
4753: PPUSH
4754: LD_EXP 55
4758: PUSH
4759: LD_INT 2
4761: ARRAY
4762: PPUSH
4763: LD_EXP 55
4767: PUSH
4768: LD_INT 3
4770: ARRAY
4771: PPUSH
4772: LD_EXP 55
4776: PUSH
4777: LD_INT 4
4779: ARRAY
4780: PPUSH
4781: CALL_OW 125
// for i = 1 to 4 do
4785: LD_ADDR_VAR 0 1
4789: PUSH
4790: DOUBLE
4791: LD_INT 1
4793: DEC
4794: ST_TO_ADDR
4795: LD_INT 4
4797: PUSH
4798: FOR_TO
4799: IFFALSE 4821
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4801: LD_ADDR_EXP 55
4805: PUSH
4806: LD_EXP 55
4810: PPUSH
4811: LD_INT 1
4813: PPUSH
4814: CALL_OW 3
4818: ST_TO_ADDR
4819: GO 4798
4821: POP
4822: POP
// end ;
4823: PPOPN 3
4825: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4826: LD_INT 0
4828: PPUSH
4829: PPUSH
4830: PPUSH
// for i = 1 to 6 do
4831: LD_ADDR_VAR 0 2
4835: PUSH
4836: DOUBLE
4837: LD_INT 1
4839: DEC
4840: ST_TO_ADDR
4841: LD_INT 6
4843: PUSH
4844: FOR_TO
4845: IFFALSE 4994
// begin PrepareHuman ( false , 3 , 3 ) ;
4847: LD_INT 0
4849: PPUSH
4850: LD_INT 3
4852: PPUSH
4853: LD_INT 3
4855: PPUSH
4856: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4860: LD_ADDR_VAR 0 3
4864: PUSH
4865: LD_INT 3
4867: PPUSH
4868: LD_INT 3
4870: PPUSH
4871: LD_INT 22
4873: PPUSH
4874: LD_INT 1
4876: PPUSH
4877: LD_INT 1
4879: PPUSH
4880: LD_INT 43
4882: PUSH
4883: LD_INT 42
4885: PUSH
4886: EMPTY
4887: LIST
4888: LIST
4889: PUSH
4890: LD_INT 1
4892: PPUSH
4893: LD_INT 2
4895: PPUSH
4896: CALL_OW 12
4900: ARRAY
4901: PPUSH
4902: LD_INT 70
4904: PPUSH
4905: CALL 529 0 7
4909: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4910: LD_VAR 0 3
4914: PPUSH
4915: LD_INT 4
4917: PPUSH
4918: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4922: LD_VAR 0 3
4926: PPUSH
4927: LD_INT 229
4929: PPUSH
4930: LD_INT 44
4932: PPUSH
4933: LD_INT 0
4935: PPUSH
4936: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4940: CALL_OW 44
4944: PPUSH
4945: LD_VAR 0 3
4949: PPUSH
4950: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4954: LD_ADDR_EXP 54
4958: PUSH
4959: LD_EXP 54
4963: PUSH
4964: LD_VAR 0 3
4968: ADD
4969: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
4970: LD_VAR 0 3
4974: PPUSH
4975: LD_INT 191
4977: PPUSH
4978: LD_INT 32
4980: PPUSH
4981: CALL_OW 111
// Wait ( 0 0$02 ) ;
4985: LD_INT 70
4987: PPUSH
4988: CALL_OW 67
// end ;
4992: GO 4844
4994: POP
4995: POP
// end ;
4996: LD_VAR 0 1
5000: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
5001: LD_EXP 29
5005: PUSH
5006: LD_EXP 54
5010: AND
5011: IFFALSE 5185
5013: GO 5015
5015: DISABLE
5016: LD_INT 0
5018: PPUSH
5019: PPUSH
5020: PPUSH
// begin wait ( 0 0$50 ) ;
5021: LD_INT 1750
5023: PPUSH
5024: CALL_OW 67
// tmp := ru_vehicles ;
5028: LD_ADDR_VAR 0 3
5032: PUSH
5033: LD_EXP 54
5037: ST_TO_ADDR
// if not tmp then
5038: LD_VAR 0 3
5042: NOT
5043: IFFALSE 5047
// exit ;
5045: GO 5185
// repeat wait ( 0 0$1 ) ;
5047: LD_INT 35
5049: PPUSH
5050: CALL_OW 67
// for i in tmp do
5054: LD_ADDR_VAR 0 1
5058: PUSH
5059: LD_VAR 0 3
5063: PUSH
5064: FOR_IN
5065: IFFALSE 5176
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5067: LD_ADDR_VAR 0 2
5071: PUSH
5072: LD_INT 22
5074: PUSH
5075: LD_INT 1
5077: PUSH
5078: EMPTY
5079: LIST
5080: LIST
5081: PPUSH
5082: LD_VAR 0 1
5086: PPUSH
5087: CALL_OW 74
5091: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5092: LD_VAR 0 1
5096: PPUSH
5097: LD_VAR 0 2
5101: PPUSH
5102: CALL_OW 296
5106: PUSH
5107: LD_INT 10
5109: GREATER
5110: IFFALSE 5129
// ComAgressiveMove ( i , 69 , 101 ) else
5112: LD_VAR 0 1
5116: PPUSH
5117: LD_INT 69
5119: PPUSH
5120: LD_INT 101
5122: PPUSH
5123: CALL_OW 114
5127: GO 5143
// ComAttackUnit ( i , enemy ) ;
5129: LD_VAR 0 1
5133: PPUSH
5134: LD_VAR 0 2
5138: PPUSH
5139: CALL_OW 115
// if GetLives ( i ) < 250 then
5143: LD_VAR 0 1
5147: PPUSH
5148: CALL_OW 256
5152: PUSH
5153: LD_INT 250
5155: LESS
5156: IFFALSE 5174
// tmp := tmp diff i ;
5158: LD_ADDR_VAR 0 3
5162: PUSH
5163: LD_VAR 0 3
5167: PUSH
5168: LD_VAR 0 1
5172: DIFF
5173: ST_TO_ADDR
// end ;
5174: GO 5064
5176: POP
5177: POP
// until not tmp ;
5178: LD_VAR 0 3
5182: NOT
5183: IFFALSE 5047
// end ; end_of_file
5185: PPOPN 3
5187: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5188: LD_INT 0
5190: PPUSH
5191: PPUSH
5192: PPUSH
5193: PPUSH
5194: PPUSH
5195: PPUSH
5196: PPUSH
// InGameOn ;
5197: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5201: LD_EXP 35
5205: PPUSH
5206: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5210: LD_EXP 35
5214: PPUSH
5215: LD_EXP 42
5219: PPUSH
5220: CALL_OW 119
// if Bierezov then
5224: LD_EXP 43
5228: IFFALSE 5244
// ComTurnUnit ( Bierezov , Cornel ) ;
5230: LD_EXP 43
5234: PPUSH
5235: LD_EXP 42
5239: PPUSH
5240: CALL_OW 119
// for i in jmm_units do
5244: LD_ADDR_VAR 0 2
5248: PUSH
5249: LD_EXP 4
5253: PUSH
5254: FOR_IN
5255: IFFALSE 5273
// ComTurnUnit ( i , Cornel ) ;
5257: LD_VAR 0 2
5261: PPUSH
5262: LD_EXP 42
5266: PPUSH
5267: CALL_OW 119
5271: GO 5254
5273: POP
5274: POP
// units := cornel_units union Cornel ;
5275: LD_ADDR_VAR 0 3
5279: PUSH
5280: LD_EXP 6
5284: PUSH
5285: LD_EXP 42
5289: UNION
5290: ST_TO_ADDR
// repeat wait ( 1 ) ;
5291: LD_INT 1
5293: PPUSH
5294: CALL_OW 67
// for i in units do
5298: LD_ADDR_VAR 0 2
5302: PUSH
5303: LD_VAR 0 3
5307: PUSH
5308: FOR_IN
5309: IFFALSE 5342
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5311: LD_VAR 0 2
5315: PPUSH
5316: LD_EXP 35
5320: PPUSH
5321: CALL_OW 250
5325: PPUSH
5326: LD_EXP 35
5330: PPUSH
5331: CALL_OW 251
5335: PPUSH
5336: CALL_OW 111
5340: GO 5308
5342: POP
5343: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5344: LD_VAR 0 3
5348: PPUSH
5349: LD_INT 92
5351: PUSH
5352: LD_EXP 35
5356: PPUSH
5357: CALL_OW 250
5361: PUSH
5362: LD_EXP 35
5366: PPUSH
5367: CALL_OW 251
5371: PUSH
5372: LD_INT 10
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: LIST
5379: LIST
5380: PPUSH
5381: CALL_OW 72
5385: PUSH
5386: LD_VAR 0 3
5390: EQUAL
5391: IFFALSE 5291
// for i in units do
5393: LD_ADDR_VAR 0 2
5397: PUSH
5398: LD_VAR 0 3
5402: PUSH
5403: FOR_IN
5404: IFFALSE 5422
// ComTurnUnit ( i , JMM ) ;
5406: LD_VAR 0 2
5410: PPUSH
5411: LD_EXP 35
5415: PPUSH
5416: CALL_OW 119
5420: GO 5403
5422: POP
5423: POP
// ComTurnUnit ( Cornel , JMM ) ;
5424: LD_EXP 42
5428: PPUSH
5429: LD_EXP 35
5433: PPUSH
5434: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5438: LD_EXP 35
5442: PPUSH
5443: LD_STRING D1-JMM-1
5445: PPUSH
5446: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5450: LD_EXP 42
5454: PPUSH
5455: LD_STRING D1-Corn-1
5457: PPUSH
5458: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5462: LD_EXP 35
5466: PPUSH
5467: LD_EXP 42
5471: PPUSH
5472: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5476: LD_EXP 42
5480: PPUSH
5481: LD_EXP 35
5485: PPUSH
5486: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5490: LD_INT 35
5492: PPUSH
5493: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5497: LD_EXP 35
5501: PPUSH
5502: LD_EXP 42
5506: PPUSH
5507: CALL_OW 296
5511: PUSH
5512: LD_INT 6
5514: LESS
5515: IFFALSE 5490
// ChangeSideFog ( 4 , 1 ) ;
5517: LD_INT 4
5519: PPUSH
5520: LD_INT 1
5522: PPUSH
5523: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5527: LD_EXP 35
5531: PPUSH
5532: LD_EXP 42
5536: PPUSH
5537: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5541: LD_EXP 42
5545: PPUSH
5546: LD_EXP 35
5550: PPUSH
5551: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5555: LD_EXP 35
5559: PPUSH
5560: LD_STRING D1-JMM-2
5562: PPUSH
5563: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5567: LD_EXP 35
5571: PPUSH
5572: LD_STRING D1-JMM-2a
5574: PPUSH
5575: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5579: LD_EXP 42
5583: PPUSH
5584: LD_STRING D1-Corn-2
5586: PPUSH
5587: CALL_OW 88
// if bierezov_exist or debug then
5591: LD_EXP 7
5595: PUSH
5596: LD_EXP 1
5600: OR
5601: IFFALSE 5842
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5603: LD_EXP 42
5607: PPUSH
5608: LD_EXP 43
5612: PPUSH
5613: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5617: LD_INT 10
5619: PPUSH
5620: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5624: LD_EXP 42
5628: PPUSH
5629: LD_STRING D1a-Corn-1
5631: PPUSH
5632: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5636: LD_EXP 35
5640: PPUSH
5641: LD_EXP 43
5645: PPUSH
5646: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5650: LD_EXP 43
5654: PPUSH
5655: LD_EXP 35
5659: PPUSH
5660: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5664: LD_EXP 35
5668: PPUSH
5669: LD_STRING D1a-JMM-1
5671: PPUSH
5672: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5676: LD_EXP 35
5680: PPUSH
5681: LD_EXP 42
5685: PPUSH
5686: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5690: LD_EXP 42
5694: PPUSH
5695: LD_EXP 35
5699: PPUSH
5700: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5704: LD_EXP 42
5708: PPUSH
5709: LD_STRING D1a-Corn-2
5711: PPUSH
5712: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5716: LD_EXP 35
5720: PPUSH
5721: LD_STRING D1a-JMM-2
5723: PPUSH
5724: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5728: LD_EXP 42
5732: PPUSH
5733: LD_STRING D1a-Corn-3
5735: PPUSH
5736: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5740: LD_EXP 35
5744: PPUSH
5745: LD_STRING D1a-JMM-3
5747: PPUSH
5748: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5752: LD_EXP 42
5756: PPUSH
5757: LD_STRING D1a-Corn-4
5759: PPUSH
5760: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5764: LD_EXP 35
5768: PPUSH
5769: LD_STRING D1a-JMM-4
5771: PPUSH
5772: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5776: LD_EXP 42
5780: PPUSH
5781: LD_STRING D1a-Corn-5
5783: PPUSH
5784: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5788: LD_EXP 43
5792: PPUSH
5793: LD_EXP 42
5797: PPUSH
5798: CALL_OW 250
5802: PPUSH
5803: LD_EXP 42
5807: PPUSH
5808: CALL_OW 251
5812: PUSH
5813: LD_INT 2
5815: MINUS
5816: PPUSH
5817: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5821: LD_EXP 43
5825: PPUSH
5826: LD_EXP 42
5830: PPUSH
5831: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5835: LD_INT 10
5837: PPUSH
5838: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5842: LD_EXP 35
5846: PPUSH
5847: LD_STRING D1b-JMM-1
5849: PPUSH
5850: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5854: LD_EXP 42
5858: PPUSH
5859: LD_STRING D1b-Corn-1
5861: PPUSH
5862: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5866: LD_EXP 35
5870: PPUSH
5871: LD_STRING D1b-JMM-2
5873: PPUSH
5874: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5878: LD_EXP 42
5882: PPUSH
5883: LD_STRING D1b-Corn-2
5885: PPUSH
5886: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5890: LD_EXP 35
5894: PPUSH
5895: LD_STRING D1b-JMM-3
5897: PPUSH
5898: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5902: LD_INT 10
5904: PPUSH
5905: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5909: LD_EXP 44
5913: PPUSH
5914: LD_STRING D1b-Pow-3
5916: PPUSH
5917: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5921: LD_EXP 35
5925: PPUSH
5926: LD_STRING D1b-JMM-4
5928: PPUSH
5929: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5933: LD_EXP 42
5937: PPUSH
5938: LD_STRING D1b-Corn-4
5940: PPUSH
5941: CALL_OW 88
// if Khatam then
5945: LD_EXP 39
5949: IFFALSE 5965
// Say ( Khatam , D1b-Khat-4 ) else
5951: LD_EXP 39
5955: PPUSH
5956: LD_STRING D1b-Khat-4
5958: PPUSH
5959: CALL_OW 88
5963: GO 6001
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
5965: LD_EXP 6
5969: PPUSH
5970: LD_INT 26
5972: PUSH
5973: LD_INT 1
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: PPUSH
5980: CALL_OW 72
5984: PUSH
5985: LD_EXP 42
5989: PUSH
5990: EMPTY
5991: LIST
5992: DIFF
5993: PPUSH
5994: LD_STRING D1b-Sol1-4
5996: PPUSH
5997: CALL 617 0 2
// if Cyrus then
6001: LD_EXP 37
6005: IFFALSE 6019
// Say ( Cyrus , D1b-Cyrus-4 ) ;
6007: LD_EXP 37
6011: PPUSH
6012: LD_STRING D1b-Cyrus-4
6014: PPUSH
6015: CALL_OW 88
// if Lisa then
6019: LD_EXP 38
6023: IFFALSE 6081
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6025: LD_EXP 38
6029: PPUSH
6030: LD_STRING D1b-Lisa-4
6032: PPUSH
6033: CALL_OW 88
// if Cyrus then
6037: LD_EXP 37
6041: IFFALSE 6081
// begin if not IsInUnit ( Cyrus ) then
6043: LD_EXP 37
6047: PPUSH
6048: CALL_OW 310
6052: NOT
6053: IFFALSE 6069
// ComTurnUnit ( Cyrus , Lisa ) ;
6055: LD_EXP 37
6059: PPUSH
6060: LD_EXP 38
6064: PPUSH
6065: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6069: LD_EXP 37
6073: PPUSH
6074: LD_STRING D1b-Cyrus-5
6076: PPUSH
6077: CALL_OW 88
// end ; end ; SelectGroup ;
6081: CALL 2570 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6085: LD_EXP 35
6089: PPUSH
6090: LD_STRING D1d-JMM-1
6092: PPUSH
6093: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6097: LD_EXP 42
6101: PPUSH
6102: LD_STRING D1d-Corn-1
6104: PPUSH
6105: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6109: LD_ADDR_VAR 0 2
6113: PUSH
6114: LD_EXP 4
6118: PUSH
6119: LD_EXP 6
6123: ADD
6124: PUSH
6125: LD_EXP 35
6129: ADD
6130: PUSH
6131: FOR_IN
6132: IFFALSE 6145
// ComHold ( i ) ;
6134: LD_VAR 0 2
6138: PPUSH
6139: CALL_OW 140
6143: GO 6131
6145: POP
6146: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6147: LD_ADDR_VAR 0 4
6151: PUSH
6152: LD_INT 22
6154: PUSH
6155: LD_INT 1
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: PUSH
6162: LD_INT 21
6164: PUSH
6165: LD_INT 2
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: PUSH
6172: EMPTY
6173: LIST
6174: LIST
6175: PPUSH
6176: CALL_OW 69
6180: ST_TO_ADDR
// if vehicles then
6181: LD_VAR 0 4
6185: IFFALSE 6523
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6187: LD_EXP 6
6191: PPUSH
6192: LD_INT 55
6194: PUSH
6195: EMPTY
6196: LIST
6197: PPUSH
6198: CALL_OW 72
6202: IFFALSE 6241
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6204: LD_ADDR_VAR 0 2
6208: PUSH
6209: LD_EXP 6
6213: PPUSH
6214: LD_INT 55
6216: PUSH
6217: EMPTY
6218: LIST
6219: PPUSH
6220: CALL_OW 72
6224: PUSH
6225: FOR_IN
6226: IFFALSE 6239
// ComExitVehicle ( i ) ;
6228: LD_VAR 0 2
6232: PPUSH
6233: CALL_OW 121
6237: GO 6225
6239: POP
6240: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6241: LD_ADDR_VAR 0 5
6245: PUSH
6246: LD_VAR 0 4
6250: PPUSH
6251: LD_INT 34
6253: PUSH
6254: LD_INT 51
6256: PUSH
6257: EMPTY
6258: LIST
6259: LIST
6260: PPUSH
6261: CALL_OW 72
6265: ST_TO_ADDR
// if cargos then
6266: LD_VAR 0 5
6270: IFFALSE 6453
// begin vehicles := cargos ;
6272: LD_ADDR_VAR 0 4
6276: PUSH
6277: LD_VAR 0 5
6281: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6282: LD_ADDR_VAR 0 6
6286: PUSH
6287: LD_STRING 02_resources_4
6289: PPUSH
6290: LD_INT 0
6292: PPUSH
6293: CALL_OW 30
6297: ST_TO_ADDR
// if debug and not resources then
6298: LD_EXP 1
6302: PUSH
6303: LD_VAR 0 6
6307: NOT
6308: AND
6309: IFFALSE 6319
// resources := 160 ;
6311: LD_ADDR_VAR 0 6
6315: PUSH
6316: LD_INT 160
6318: ST_TO_ADDR
// if resources mod 10 then
6319: LD_VAR 0 6
6323: PUSH
6324: LD_INT 10
6326: MOD
6327: IFFALSE 6349
// resources := resources - resources mod 10 ;
6329: LD_ADDR_VAR 0 6
6333: PUSH
6334: LD_VAR 0 6
6338: PUSH
6339: LD_VAR 0 6
6343: PUSH
6344: LD_INT 10
6346: MOD
6347: MINUS
6348: ST_TO_ADDR
// if resources then
6349: LD_VAR 0 6
6353: IFFALSE 6453
// for i in cargos do
6355: LD_ADDR_VAR 0 2
6359: PUSH
6360: LD_VAR 0 5
6364: PUSH
6365: FOR_IN
6366: IFFALSE 6451
// begin if resources < 100 then
6368: LD_VAR 0 6
6372: PUSH
6373: LD_INT 100
6375: LESS
6376: IFFALSE 6398
// begin cargo := resources ;
6378: LD_ADDR_VAR 0 7
6382: PUSH
6383: LD_VAR 0 6
6387: ST_TO_ADDR
// resources := 0 ;
6388: LD_ADDR_VAR 0 6
6392: PUSH
6393: LD_INT 0
6395: ST_TO_ADDR
// end else
6396: GO 6420
// begin cargo := 100 ;
6398: LD_ADDR_VAR 0 7
6402: PUSH
6403: LD_INT 100
6405: ST_TO_ADDR
// resources := resources - 100 ;
6406: LD_ADDR_VAR 0 6
6410: PUSH
6411: LD_VAR 0 6
6415: PUSH
6416: LD_INT 100
6418: MINUS
6419: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6420: LD_VAR 0 2
6424: PPUSH
6425: LD_INT 1
6427: PPUSH
6428: LD_VAR 0 7
6432: PPUSH
6433: CALL_OW 290
// if resources = 0 then
6437: LD_VAR 0 6
6441: PUSH
6442: LD_INT 0
6444: EQUAL
6445: IFFALSE 6449
// break ;
6447: GO 6451
// end ;
6449: GO 6365
6451: POP
6452: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6453: LD_VAR 0 4
6457: PUSH
6458: LD_INT 1
6460: ARRAY
6461: PPUSH
6462: CALL_OW 311
6466: PPUSH
6467: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6471: LD_VAR 0 4
6475: PUSH
6476: LD_INT 1
6478: ARRAY
6479: PPUSH
6480: LD_INT 4
6482: PPUSH
6483: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6487: LD_EXP 42
6491: PPUSH
6492: LD_VAR 0 4
6496: PUSH
6497: LD_INT 1
6499: ARRAY
6500: PPUSH
6501: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6505: LD_INT 35
6507: PPUSH
6508: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6512: LD_EXP 42
6516: PPUSH
6517: CALL_OW 310
6521: IFFALSE 6505
// end ; InGameOff ;
6523: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6527: LD_STRING M1
6529: PPUSH
6530: CALL_OW 337
// SaveForQuickRestart ;
6534: CALL_OW 22
// cornel_active := true ;
6538: LD_ADDR_EXP 8
6542: PUSH
6543: LD_INT 1
6545: ST_TO_ADDR
// end ;
6546: LD_VAR 0 1
6550: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns , tmp ;
6551: LD_EXP 35
6555: PPUSH
6556: LD_EXP 45
6560: PPUSH
6561: CALL_OW 296
6565: PUSH
6566: LD_INT 10
6568: LESS
6569: IFFALSE 7926
6571: GO 6573
6573: DISABLE
6574: LD_INT 0
6576: PPUSH
6577: PPUSH
6578: PPUSH
6579: PPUSH
6580: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6581: LD_ADDR_VAR 0 2
6585: PUSH
6586: LD_INT 89
6588: PUSH
6589: LD_INT 34
6591: PUSH
6592: EMPTY
6593: LIST
6594: LIST
6595: PUSH
6596: LD_INT 138
6598: PUSH
6599: LD_INT 63
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: PUSH
6606: LD_INT 196
6608: PUSH
6609: LD_INT 84
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: PUSH
6616: LD_INT 135
6618: PUSH
6619: LD_INT 52
6621: PUSH
6622: EMPTY
6623: LIST
6624: LIST
6625: PUSH
6626: LD_INT 103
6628: PUSH
6629: LD_INT 39
6631: PUSH
6632: EMPTY
6633: LIST
6634: LIST
6635: PUSH
6636: LD_INT 58
6638: PUSH
6639: LD_INT 30
6641: PUSH
6642: EMPTY
6643: LIST
6644: LIST
6645: PUSH
6646: LD_INT 38
6648: PUSH
6649: LD_INT 51
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: PUSH
6656: EMPTY
6657: LIST
6658: LIST
6659: LIST
6660: LIST
6661: LIST
6662: LIST
6663: LIST
6664: ST_TO_ADDR
// InGameOn ;
6665: CALL_OW 8
// if jmm_units then
6669: LD_EXP 4
6673: IFFALSE 6749
// for i in jmm_units do
6675: LD_ADDR_VAR 0 1
6679: PUSH
6680: LD_EXP 4
6684: PUSH
6685: FOR_IN
6686: IFFALSE 6747
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6688: LD_VAR 0 1
6692: PPUSH
6693: LD_EXP 35
6697: PPUSH
6698: CALL_OW 296
6702: PUSH
6703: LD_INT 10
6705: LESS
6706: PUSH
6707: LD_VAR 0 1
6711: PPUSH
6712: CALL_OW 310
6716: NOT
6717: AND
6718: IFFALSE 6736
// ComTurnUnit ( i , JMM ) else
6720: LD_VAR 0 1
6724: PPUSH
6725: LD_EXP 35
6729: PPUSH
6730: CALL_OW 119
6734: GO 6745
// ComHold ( i ) ;
6736: LD_VAR 0 1
6740: PPUSH
6741: CALL_OW 140
// end ;
6745: GO 6685
6747: POP
6748: POP
// if IsInUnit ( JMM ) then
6749: LD_EXP 35
6753: PPUSH
6754: CALL_OW 310
6758: IFFALSE 6783
// begin ComExitVehicle ( JMM ) ;
6760: LD_EXP 35
6764: PPUSH
6765: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6769: LD_EXP 35
6773: PPUSH
6774: LD_EXP 45
6778: PPUSH
6779: CALL_OW 172
// end ; Wait ( 10 ) ;
6783: LD_INT 10
6785: PPUSH
6786: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6790: LD_EXP 35
6794: PPUSH
6795: LD_EXP 45
6799: PPUSH
6800: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6804: LD_INT 35
6806: PPUSH
6807: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6811: LD_EXP 35
6815: PPUSH
6816: LD_EXP 45
6820: PPUSH
6821: CALL_OW 296
6825: PUSH
6826: LD_INT 6
6828: LESS
6829: IFFALSE 6804
// ComTurnUnit ( JMM , Lynch ) ;
6831: LD_EXP 35
6835: PPUSH
6836: LD_EXP 45
6840: PPUSH
6841: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6845: LD_ADDR_VAR 0 1
6849: PUSH
6850: LD_EXP 45
6854: PUSH
6855: LD_EXP 46
6859: PUSH
6860: LD_EXP 47
6864: PUSH
6865: LD_EXP 48
6869: PUSH
6870: EMPTY
6871: LIST
6872: LIST
6873: LIST
6874: LIST
6875: PUSH
6876: FOR_IN
6877: IFFALSE 6895
// ComTurnUnit ( i , JMM ) ;
6879: LD_VAR 0 1
6883: PPUSH
6884: LD_EXP 35
6888: PPUSH
6889: CALL_OW 119
6893: GO 6876
6895: POP
6896: POP
// Wait ( 0 0$0.3 ) ;
6897: LD_INT 10
6899: PPUSH
6900: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6904: LD_EXP 35
6908: PPUSH
6909: LD_STRING D2-JMM-1
6911: PPUSH
6912: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6916: LD_EXP 45
6920: PPUSH
6921: LD_STRING D2-Sol1-1
6923: PPUSH
6924: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6928: LD_EXP 35
6932: PPUSH
6933: LD_STRING D2-JMM-2
6935: PPUSH
6936: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6940: LD_EXP 45
6944: PPUSH
6945: LD_STRING D2-Sol1-2
6947: PPUSH
6948: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6952: LD_EXP 35
6956: PPUSH
6957: LD_STRING D2-JMM-3
6959: PPUSH
6960: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
6964: LD_EXP 45
6968: PPUSH
6969: LD_STRING D2-Sol1-3
6971: PPUSH
6972: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6976: LD_ADDR_VAR 0 1
6980: PUSH
6981: LD_INT 22
6983: PUSH
6984: LD_INT 8
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: PPUSH
6991: CALL_OW 69
6995: PUSH
6996: FOR_IN
6997: IFFALSE 7013
// SetSide ( i , 1 ) ;
6999: LD_VAR 0 1
7003: PPUSH
7004: LD_INT 1
7006: PPUSH
7007: CALL_OW 235
7011: GO 6996
7013: POP
7014: POP
// Say ( JMM , D2-JMM-4 ) ;
7015: LD_EXP 35
7019: PPUSH
7020: LD_STRING D2-JMM-4
7022: PPUSH
7023: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7027: LD_INT 1
7029: PPUSH
7030: LD_INT 5
7032: PPUSH
7033: CALL_OW 332
// for i = 1 to points do
7037: LD_ADDR_VAR 0 1
7041: PUSH
7042: DOUBLE
7043: LD_INT 1
7045: DEC
7046: ST_TO_ADDR
7047: LD_VAR 0 2
7051: PUSH
7052: FOR_TO
7053: IFFALSE 7228
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7055: LD_VAR 0 2
7059: PUSH
7060: LD_VAR 0 1
7064: ARRAY
7065: PUSH
7066: LD_INT 1
7068: ARRAY
7069: PPUSH
7070: LD_VAR 0 2
7074: PUSH
7075: LD_VAR 0 1
7079: ARRAY
7080: PUSH
7081: LD_INT 2
7083: ARRAY
7084: PPUSH
7085: CALL_OW 84
// if i = 1 then
7089: LD_VAR 0 1
7093: PUSH
7094: LD_INT 1
7096: EQUAL
7097: IFFALSE 7111
// Say ( Lynch , D2-Sol1-4 ) ;
7099: LD_EXP 45
7103: PPUSH
7104: LD_STRING D2-Sol1-4
7106: PPUSH
7107: CALL_OW 88
// if i = 2 then
7111: LD_VAR 0 1
7115: PUSH
7116: LD_INT 2
7118: EQUAL
7119: IFFALSE 7133
// Say ( JMM , D2-JMM-5 ) ;
7121: LD_EXP 35
7125: PPUSH
7126: LD_STRING D2-JMM-5
7128: PPUSH
7129: CALL_OW 88
// if i = 4 then
7133: LD_VAR 0 1
7137: PUSH
7138: LD_INT 4
7140: EQUAL
7141: IFFALSE 7165
// begin RevealFogArea ( 1 , troopsArea ) ;
7143: LD_INT 1
7145: PPUSH
7146: LD_INT 6
7148: PPUSH
7149: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7153: LD_EXP 45
7157: PPUSH
7158: LD_STRING D2-Sol1-5
7160: PPUSH
7161: CALL_OW 88
// end ; if i = 5 then
7165: LD_VAR 0 1
7169: PUSH
7170: LD_INT 5
7172: EQUAL
7173: IFFALSE 7187
// Say ( JMM , D2-JMM-6 ) ;
7175: LD_EXP 35
7179: PPUSH
7180: LD_STRING D2-JMM-6
7182: PPUSH
7183: CALL_OW 88
// if i = 7 then
7187: LD_VAR 0 1
7191: PUSH
7192: LD_INT 7
7194: EQUAL
7195: IFFALSE 7219
// begin RevealFogArea ( 1 , forestArea ) ;
7197: LD_INT 1
7199: PPUSH
7200: LD_INT 7
7202: PPUSH
7203: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7207: LD_EXP 45
7211: PPUSH
7212: LD_STRING D2-Sol1-6
7214: PPUSH
7215: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7219: LD_INT 46
7221: PPUSH
7222: CALL_OW 67
// end ;
7226: GO 7052
7228: POP
7229: POP
// CenterNowOnUnits ( JMM ) ;
7230: LD_EXP 35
7234: PPUSH
7235: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7239: LD_EXP 35
7243: PPUSH
7244: LD_STRING D2-JMM-7
7246: PPUSH
7247: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7251: LD_EXP 45
7255: PPUSH
7256: LD_STRING D2-Sol1-7
7258: PPUSH
7259: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7263: LD_EXP 35
7267: PPUSH
7268: LD_STRING D2-JMM-8
7270: PPUSH
7271: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7275: LD_ADDR_VAR 0 4
7279: PUSH
7280: LD_INT 22
7282: PUSH
7283: LD_INT 1
7285: PUSH
7286: EMPTY
7287: LIST
7288: LIST
7289: PUSH
7290: LD_INT 30
7292: PUSH
7293: LD_INT 31
7295: PUSH
7296: EMPTY
7297: LIST
7298: LIST
7299: PUSH
7300: EMPTY
7301: LIST
7302: LIST
7303: PPUSH
7304: CALL_OW 69
7308: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7309: LD_EXP 45
7313: PPUSH
7314: LD_VAR 0 4
7318: PUSH
7319: LD_INT 1
7321: ARRAY
7322: PPUSH
7323: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7327: LD_INT 65
7329: PPUSH
7330: LD_INT 101
7332: PPUSH
7333: CALL_OW 428
7337: IFFALSE 7360
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7339: LD_INT 65
7341: PPUSH
7342: LD_INT 101
7344: PPUSH
7345: CALL_OW 428
7349: PPUSH
7350: LD_INT 75
7352: PPUSH
7353: LD_INT 100
7355: PPUSH
7356: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7360: LD_INT 66
7362: PPUSH
7363: LD_INT 103
7365: PPUSH
7366: CALL_OW 428
7370: IFFALSE 7393
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7372: LD_INT 66
7374: PPUSH
7375: LD_INT 103
7377: PPUSH
7378: CALL_OW 428
7382: PPUSH
7383: LD_INT 75
7385: PPUSH
7386: LD_INT 100
7388: PPUSH
7389: CALL_OW 111
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_dist , JMM , 7 ] ] ) ;
7393: LD_ADDR_VAR 0 5
7397: PUSH
7398: LD_INT 22
7400: PUSH
7401: LD_INT 1
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PUSH
7408: LD_INT 21
7410: PUSH
7411: LD_INT 2
7413: PUSH
7414: EMPTY
7415: LIST
7416: LIST
7417: PUSH
7418: LD_INT 91
7420: PUSH
7421: LD_EXP 35
7425: PUSH
7426: LD_INT 7
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: LIST
7433: PUSH
7434: EMPTY
7435: LIST
7436: LIST
7437: LIST
7438: PPUSH
7439: CALL_OW 69
7443: ST_TO_ADDR
// if tmp then
7444: LD_VAR 0 5
7448: IFFALSE 7465
// ComMoveXY ( tmp , 75 , 100 ) ;
7450: LD_VAR 0 5
7454: PPUSH
7455: LD_INT 75
7457: PPUSH
7458: LD_INT 100
7460: PPUSH
7461: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7465: LD_ADDR_VAR 0 3
7469: PUSH
7470: LD_EXP 4
7474: PPUSH
7475: LD_INT 25
7477: PUSH
7478: LD_INT 1
7480: PUSH
7481: EMPTY
7482: LIST
7483: LIST
7484: PPUSH
7485: CALL_OW 72
7489: PPUSH
7490: LD_EXP 35
7494: PPUSH
7495: CALL_OW 74
7499: ST_TO_ADDR
// if sol then
7500: LD_VAR 0 3
7504: IFFALSE 7544
// if GetDistUnits ( JMM , sol ) < 10 then
7506: LD_EXP 35
7510: PPUSH
7511: LD_VAR 0 3
7515: PPUSH
7516: CALL_OW 296
7520: PUSH
7521: LD_INT 10
7523: LESS
7524: IFFALSE 7544
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7526: LD_VAR 0 3
7530: PPUSH
7531: LD_VAR 0 4
7535: PUSH
7536: LD_INT 2
7538: ARRAY
7539: PPUSH
7540: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7544: LD_INT 10
7546: PPUSH
7547: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7551: LD_EXP 35
7555: PPUSH
7556: LD_INT 65
7558: PPUSH
7559: LD_INT 101
7561: PPUSH
7562: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7566: LD_EXP 35
7570: PPUSH
7571: LD_INT 63
7573: PPUSH
7574: LD_INT 100
7576: PPUSH
7577: CALL_OW 178
// tmp := 0 0$0 ;
7581: LD_ADDR_VAR 0 5
7585: PUSH
7586: LD_INT 0
7588: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7589: LD_INT 35
7591: PPUSH
7592: CALL_OW 67
// tmp := tmp + 0 0$1 ;
7596: LD_ADDR_VAR 0 5
7600: PUSH
7601: LD_VAR 0 5
7605: PUSH
7606: LD_INT 35
7608: PLUS
7609: ST_TO_ADDR
// until IsAt ( JMM , 65 , 101 ) or tmp > 0 0$5 ;
7610: LD_EXP 35
7614: PPUSH
7615: LD_INT 65
7617: PPUSH
7618: LD_INT 101
7620: PPUSH
7621: CALL_OW 307
7625: PUSH
7626: LD_VAR 0 5
7630: PUSH
7631: LD_INT 175
7633: GREATER
7634: OR
7635: IFFALSE 7589
// Say ( JMM , D2a-JMM-1 ) ;
7637: LD_EXP 35
7641: PPUSH
7642: LD_STRING D2a-JMM-1
7644: PPUSH
7645: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7649: LD_EXP 46
7653: PPUSH
7654: LD_INT 66
7656: PPUSH
7657: LD_INT 103
7659: PPUSH
7660: CALL_OW 111
// tmp := 0 0$0 ;
7664: LD_ADDR_VAR 0 5
7668: PUSH
7669: LD_INT 0
7671: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7672: LD_INT 35
7674: PPUSH
7675: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) or tmp > 0 0$5 ;
7679: LD_EXP 46
7683: PPUSH
7684: LD_INT 66
7686: PPUSH
7687: LD_INT 103
7689: PPUSH
7690: CALL_OW 307
7694: PUSH
7695: LD_VAR 0 5
7699: PUSH
7700: LD_INT 175
7702: GREATER
7703: OR
7704: IFFALSE 7672
// ComTurnUnit ( Walker , JMM ) ;
7706: LD_EXP 46
7710: PPUSH
7711: LD_EXP 35
7715: PPUSH
7716: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7720: LD_EXP 46
7724: PPUSH
7725: LD_STRING D2a-Sci1-1
7727: PPUSH
7728: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7732: LD_EXP 35
7736: PPUSH
7737: LD_EXP 46
7741: PPUSH
7742: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7746: LD_EXP 35
7750: PPUSH
7751: LD_STRING D2a-JMM-2
7753: PPUSH
7754: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7758: LD_EXP 46
7762: PPUSH
7763: LD_STRING D2a-Sci1-2
7765: PPUSH
7766: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7770: LD_EXP 35
7774: PPUSH
7775: LD_STRING D2a-JMM-3
7777: PPUSH
7778: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7782: LD_EXP 46
7786: PPUSH
7787: LD_STRING D2a-Sci1-3
7789: PPUSH
7790: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7794: LD_ADDR_EXP 4
7798: PUSH
7799: LD_EXP 4
7803: PUSH
7804: LD_EXP 45
7808: PUSH
7809: LD_EXP 46
7813: PUSH
7814: LD_EXP 47
7818: PUSH
7819: LD_EXP 48
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: LIST
7828: LIST
7829: ADD
7830: ST_TO_ADDR
// for i in jmm_units do
7831: LD_ADDR_VAR 0 1
7835: PUSH
7836: LD_EXP 4
7840: PUSH
7841: FOR_IN
7842: IFFALSE 7867
// if not IsInUnit ( i ) then
7844: LD_VAR 0 1
7848: PPUSH
7849: CALL_OW 310
7853: NOT
7854: IFFALSE 7865
// ComFree ( i ) ;
7856: LD_VAR 0 1
7860: PPUSH
7861: CALL_OW 139
7865: GO 7841
7867: POP
7868: POP
// InGameOff ;
7869: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
7873: LD_STRING MSolar1
7875: PPUSH
7876: CALL_OW 337
// jmm_on_west := true ;
7880: LD_ADDR_EXP 5
7884: PUSH
7885: LD_INT 1
7887: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7888: LD_INT 1050
7890: PPUSH
7891: CALL_OW 67
// frank_can_return := true ;
7895: LD_ADDR_EXP 12
7899: PUSH
7900: LD_INT 1
7902: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7903: LD_INT 6300
7905: PPUSH
7906: LD_INT 8400
7908: PPUSH
7909: CALL_OW 12
7913: PPUSH
7914: CALL_OW 67
// send_spec_patrol := true ;
7918: LD_ADDR_EXP 28
7922: PUSH
7923: LD_INT 1
7925: ST_TO_ADDR
// end ;
7926: PPOPN 5
7928: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7929: LD_INT 22
7931: PUSH
7932: LD_INT 1
7934: PUSH
7935: EMPTY
7936: LIST
7937: LIST
7938: PUSH
7939: LD_INT 34
7941: PUSH
7942: LD_INT 51
7944: PUSH
7945: EMPTY
7946: LIST
7947: LIST
7948: PUSH
7949: LD_INT 92
7951: PUSH
7952: LD_INT 63
7954: PUSH
7955: LD_INT 100
7957: PUSH
7958: LD_INT 5
7960: PUSH
7961: EMPTY
7962: LIST
7963: LIST
7964: LIST
7965: LIST
7966: PUSH
7967: EMPTY
7968: LIST
7969: LIST
7970: LIST
7971: PUSH
7972: EMPTY
7973: LIST
7974: PPUSH
7975: CALL_OW 69
7979: PUSH
7980: LD_EXP 5
7984: NOT
7985: AND
7986: IFFALSE 8099
7988: GO 7990
7990: DISABLE
7991: LD_INT 0
7993: PPUSH
7994: PPUSH
// begin enable ;
7995: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
7996: LD_ADDR_VAR 0 2
8000: PUSH
8001: LD_INT 22
8003: PUSH
8004: LD_INT 1
8006: PUSH
8007: EMPTY
8008: LIST
8009: LIST
8010: PUSH
8011: LD_INT 34
8013: PUSH
8014: LD_INT 51
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: PUSH
8021: LD_INT 92
8023: PUSH
8024: LD_INT 63
8026: PUSH
8027: LD_INT 100
8029: PUSH
8030: LD_INT 5
8032: PUSH
8033: EMPTY
8034: LIST
8035: LIST
8036: LIST
8037: LIST
8038: PUSH
8039: EMPTY
8040: LIST
8041: LIST
8042: LIST
8043: PUSH
8044: EMPTY
8045: LIST
8046: PPUSH
8047: CALL_OW 69
8051: ST_TO_ADDR
// if not filter then
8052: LD_VAR 0 2
8056: NOT
8057: IFFALSE 8061
// exit ;
8059: GO 8099
// for i in filter do
8061: LD_ADDR_VAR 0 1
8065: PUSH
8066: LD_VAR 0 2
8070: PUSH
8071: FOR_IN
8072: IFFALSE 8097
// begin SetFuel ( i , 0 ) ;
8074: LD_VAR 0 1
8078: PPUSH
8079: LD_INT 0
8081: PPUSH
8082: CALL_OW 240
// ComStop ( i ) ;
8086: LD_VAR 0 1
8090: PPUSH
8091: CALL_OW 141
// end ;
8095: GO 8071
8097: POP
8098: POP
// end ;
8099: PPOPN 2
8101: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
8102: LD_EXP 28
8106: IFFALSE 9099
8108: GO 8110
8110: DISABLE
8111: LD_INT 0
8113: PPUSH
8114: PPUSH
8115: PPUSH
8116: PPUSH
8117: PPUSH
8118: PPUSH
8119: PPUSH
// begin if not ru_spec_patrol then
8120: LD_EXP 52
8124: NOT
8125: IFFALSE 8129
// exit ;
8127: GO 9099
// dead1 := false ;
8129: LD_ADDR_VAR 0 1
8133: PUSH
8134: LD_INT 0
8136: ST_TO_ADDR
// dead2 := false ;
8137: LD_ADDR_VAR 0 2
8141: PUSH
8142: LD_INT 0
8144: ST_TO_ADDR
// inarea1 := false ;
8145: LD_ADDR_VAR 0 3
8149: PUSH
8150: LD_INT 0
8152: ST_TO_ADDR
// inarea2 := false ;
8153: LD_ADDR_VAR 0 4
8157: PUSH
8158: LD_INT 0
8160: ST_TO_ADDR
// tmp := [ ] ;
8161: LD_ADDR_VAR 0 6
8165: PUSH
8166: EMPTY
8167: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8168: LD_EXP 52
8172: PPUSH
8173: LD_INT 75
8175: PPUSH
8176: LD_INT 101
8178: PPUSH
8179: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8183: LD_INT 35
8185: PPUSH
8186: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8190: LD_INT 1
8192: PPUSH
8193: LD_EXP 52
8197: PUSH
8198: LD_INT 1
8200: ARRAY
8201: PPUSH
8202: CALL_OW 292
8206: IFFALSE 8183
// ComStop ( ru_spec_patrol ) ;
8208: LD_EXP 52
8212: PPUSH
8213: CALL_OW 141
// Wait ( 0 0$02 ) ;
8217: LD_INT 70
8219: PPUSH
8220: CALL_OW 67
// DialogueOn ;
8224: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8228: LD_EXP 52
8232: PUSH
8233: LD_INT 1
8235: ARRAY
8236: PPUSH
8237: LD_STRING D8-Rus1-1
8239: PPUSH
8240: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8244: LD_EXP 35
8248: PPUSH
8249: LD_STRING D8-JMM-1
8251: PPUSH
8252: CALL_OW 88
// DialogueOff ;
8256: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8260: LD_EXP 52
8264: PPUSH
8265: LD_INT 13
8267: PPUSH
8268: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8272: LD_INT 35
8274: PPUSH
8275: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8279: LD_VAR 0 1
8283: NOT
8284: PUSH
8285: LD_EXP 52
8289: PUSH
8290: LD_INT 1
8292: ARRAY
8293: PPUSH
8294: CALL_OW 301
8298: AND
8299: IFFALSE 8309
// dead1 := true ;
8301: LD_ADDR_VAR 0 1
8305: PUSH
8306: LD_INT 1
8308: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8309: LD_VAR 0 2
8313: NOT
8314: PUSH
8315: LD_EXP 52
8319: PUSH
8320: LD_INT 2
8322: ARRAY
8323: PPUSH
8324: CALL_OW 301
8328: AND
8329: IFFALSE 8339
// dead2 := true ;
8331: LD_ADDR_VAR 0 2
8335: PUSH
8336: LD_INT 1
8338: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8339: LD_VAR 0 3
8343: NOT
8344: PUSH
8345: LD_EXP 52
8349: PUSH
8350: LD_INT 1
8352: ARRAY
8353: PPUSH
8354: LD_INT 14
8356: PPUSH
8357: CALL_OW 308
8361: AND
8362: IFFALSE 8372
// inarea1 := true ;
8364: LD_ADDR_VAR 0 3
8368: PUSH
8369: LD_INT 1
8371: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8372: LD_VAR 0 4
8376: NOT
8377: PUSH
8378: LD_EXP 52
8382: PUSH
8383: LD_INT 2
8385: ARRAY
8386: PPUSH
8387: LD_INT 14
8389: PPUSH
8390: CALL_OW 308
8394: AND
8395: IFFALSE 8405
// inarea2 := true ;
8397: LD_ADDR_VAR 0 4
8401: PUSH
8402: LD_INT 1
8404: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8405: LD_VAR 0 1
8409: PUSH
8410: LD_VAR 0 2
8414: AND
8415: PUSH
8416: LD_VAR 0 1
8420: PUSH
8421: LD_VAR 0 4
8425: AND
8426: OR
8427: PUSH
8428: LD_VAR 0 2
8432: PUSH
8433: LD_VAR 0 3
8437: AND
8438: OR
8439: PUSH
8440: LD_VAR 0 3
8444: PUSH
8445: LD_VAR 0 4
8449: AND
8450: OR
8451: IFFALSE 8272
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8453: LD_VAR 0 3
8457: PUSH
8458: LD_VAR 0 4
8462: AND
8463: PUSH
8464: LD_VAR 0 1
8468: PUSH
8469: LD_VAR 0 4
8473: AND
8474: OR
8475: PUSH
8476: LD_VAR 0 2
8480: PUSH
8481: LD_VAR 0 3
8485: AND
8486: OR
8487: IFFALSE 9079
// begin prepare_siege := true ;
8489: LD_ADDR_EXP 29
8493: PUSH
8494: LD_INT 1
8496: ST_TO_ADDR
// DialogueOn ;
8497: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8501: LD_VAR 0 3
8505: PUSH
8506: LD_VAR 0 4
8510: AND
8511: IFFALSE 8527
// Say ( JMM , D8b-JMM-1a ) else
8513: LD_EXP 35
8517: PPUSH
8518: LD_STRING D8b-JMM-1a
8520: PPUSH
8521: CALL_OW 88
8525: GO 8539
// Say ( JMM , D8b-JMM-1 ) ;
8527: LD_EXP 35
8531: PPUSH
8532: LD_STRING D8b-JMM-1
8534: PPUSH
8535: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8539: LD_EXP 4
8543: PPUSH
8544: LD_INT 26
8546: PUSH
8547: LD_INT 1
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: PPUSH
8554: CALL_OW 72
8558: PUSH
8559: LD_EXP 36
8563: PUSH
8564: LD_EXP 37
8568: PUSH
8569: LD_EXP 46
8573: PUSH
8574: LD_EXP 49
8578: PUSH
8579: EMPTY
8580: LIST
8581: LIST
8582: LIST
8583: LIST
8584: DIFF
8585: PPUSH
8586: LD_STRING D8b-Sol1-1
8588: PPUSH
8589: CALL 617 0 2
// if Cyrus and Cyrus in jmm_units then
8593: LD_EXP 37
8597: PUSH
8598: LD_EXP 37
8602: PUSH
8603: LD_EXP 4
8607: IN
8608: AND
8609: IFFALSE 8625
// Say ( Cyrus , D8b-Cyrus-1 ) else
8611: LD_EXP 37
8615: PPUSH
8616: LD_STRING D8b-Cyrus-1
8618: PPUSH
8619: CALL_OW 88
8623: GO 8637
// Say ( JMM , D8b-JMM-1a ) ;
8625: LD_EXP 35
8629: PPUSH
8630: LD_STRING D8b-JMM-1a
8632: PPUSH
8633: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8637: LD_EXP 38
8641: PUSH
8642: LD_EXP 38
8646: PUSH
8647: LD_EXP 4
8651: IN
8652: AND
8653: IFFALSE 8667
// Say ( Lisa , D8b-Lisa-2 ) ;
8655: LD_EXP 38
8659: PPUSH
8660: LD_STRING D8b-Lisa-2
8662: PPUSH
8663: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8667: LD_EXP 36
8671: PUSH
8672: LD_EXP 36
8676: PUSH
8677: LD_EXP 4
8681: IN
8682: AND
8683: IFFALSE 8699
// Say ( Bobby , D8b-Bobby-1 ) else
8685: LD_EXP 36
8689: PPUSH
8690: LD_STRING D8b-Bobby-1
8692: PPUSH
8693: CALL_OW 88
8697: GO 8759
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8699: LD_ADDR_VAR 0 5
8703: PUSH
8704: LD_EXP 4
8708: PPUSH
8709: LD_INT 26
8711: PUSH
8712: LD_INT 1
8714: PUSH
8715: EMPTY
8716: LIST
8717: LIST
8718: PPUSH
8719: CALL_OW 72
8723: PUSH
8724: LD_EXP 36
8728: PUSH
8729: LD_EXP 37
8733: PUSH
8734: LD_EXP 46
8738: PUSH
8739: LD_EXP 49
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: LIST
8748: LIST
8749: DIFF
8750: PPUSH
8751: LD_STRING D8b-Sol2-1
8753: PPUSH
8754: CALL 617 0 2
8758: ST_TO_ADDR
// DialogueOff ;
8759: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8763: LD_EXP 37
8767: PUSH
8768: LD_EXP 37
8772: PUSH
8773: LD_EXP 4
8777: IN
8778: AND
8779: IFFALSE 8804
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8781: LD_ADDR_VAR 0 6
8785: PUSH
8786: LD_VAR 0 6
8790: PPUSH
8791: LD_INT 1
8793: PPUSH
8794: LD_EXP 37
8798: PPUSH
8799: CALL_OW 2
8803: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8804: LD_EXP 36
8808: PUSH
8809: LD_EXP 36
8813: PUSH
8814: LD_EXP 4
8818: IN
8819: AND
8820: IFFALSE 8845
// tmp := Insert ( tmp , 1 , Bobby ) ;
8822: LD_ADDR_VAR 0 6
8826: PUSH
8827: LD_VAR 0 6
8831: PPUSH
8832: LD_INT 1
8834: PPUSH
8835: LD_EXP 36
8839: PPUSH
8840: CALL_OW 2
8844: ST_TO_ADDR
// if sol then
8845: LD_VAR 0 5
8849: IFFALSE 8874
// tmp := Insert ( tmp , 1 , sol ) ;
8851: LD_ADDR_VAR 0 6
8855: PUSH
8856: LD_VAR 0 6
8860: PPUSH
8861: LD_INT 1
8863: PPUSH
8864: LD_VAR 0 5
8868: PPUSH
8869: CALL_OW 2
8873: ST_TO_ADDR
// if tmp then
8874: LD_VAR 0 6
8878: IFFALSE 9038
// begin SetSide ( tmp , 8 ) ;
8880: LD_VAR 0 6
8884: PPUSH
8885: LD_INT 8
8887: PPUSH
8888: CALL_OW 235
// ComFree ( tmp ) ;
8892: LD_VAR 0 6
8896: PPUSH
8897: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8901: LD_VAR 0 6
8905: PPUSH
8906: LD_INT 15
8908: PPUSH
8909: CALL_OW 173
// AddComHold ( tmp ) ;
8913: LD_VAR 0 6
8917: PPUSH
8918: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8922: LD_INT 35
8924: PPUSH
8925: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
8929: LD_VAR 0 6
8933: PUSH
8934: LD_INT 1
8936: ARRAY
8937: PPUSH
8938: CALL_OW 314
8942: NOT
8943: IFFALSE 8957
// ComMoveToArea ( tmp , cyrusEscape ) ;
8945: LD_VAR 0 6
8949: PPUSH
8950: LD_INT 15
8952: PPUSH
8953: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8957: LD_VAR 0 6
8961: PUSH
8962: LD_INT 1
8964: ARRAY
8965: PPUSH
8966: LD_INT 15
8968: PPUSH
8969: CALL_OW 308
8973: IFFALSE 9028
// begin RemoveUnit ( tmp [ 1 ] ) ;
8975: LD_VAR 0 6
8979: PUSH
8980: LD_INT 1
8982: ARRAY
8983: PPUSH
8984: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
8988: LD_ADDR_EXP 4
8992: PUSH
8993: LD_EXP 4
8997: PUSH
8998: LD_VAR 0 6
9002: PUSH
9003: LD_INT 1
9005: ARRAY
9006: DIFF
9007: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
9008: LD_ADDR_VAR 0 6
9012: PUSH
9013: LD_VAR 0 6
9017: PUSH
9018: LD_VAR 0 6
9022: PUSH
9023: LD_INT 1
9025: ARRAY
9026: DIFF
9027: ST_TO_ADDR
// end ; until tmp = 0 ;
9028: LD_VAR 0 6
9032: PUSH
9033: LD_INT 0
9035: EQUAL
9036: IFFALSE 8922
// end ; Wait ( 0 0$30 ) ;
9038: LD_INT 1050
9040: PPUSH
9041: CALL_OW 67
// if ru_spec_patrol then
9045: LD_EXP 52
9049: IFFALSE 9077
// for i in ru_spec_patrol do
9051: LD_ADDR_VAR 0 7
9055: PUSH
9056: LD_EXP 52
9060: PUSH
9061: FOR_IN
9062: IFFALSE 9075
// RemoveUnit ( i ) ;
9064: LD_VAR 0 7
9068: PPUSH
9069: CALL_OW 64
9073: GO 9061
9075: POP
9076: POP
// end else
9077: GO 9099
// begin prepare_siege := false ;
9079: LD_ADDR_EXP 29
9083: PUSH
9084: LD_INT 0
9086: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
9087: LD_EXP 35
9091: PPUSH
9092: LD_STRING D8a-JMM-1
9094: PPUSH
9095: CALL_OW 88
// end ; end ;
9099: PPOPN 7
9101: END
// every 0 0$10 trigger frank_can_return do var i , p , points ;
9102: LD_EXP 12
9106: IFFALSE 10305
9108: GO 9110
9110: DISABLE
9111: LD_INT 0
9113: PPUSH
9114: PPUSH
9115: PPUSH
// begin uc_side := 8 ;
9116: LD_ADDR_OWVAR 20
9120: PUSH
9121: LD_INT 8
9123: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
9124: LD_ADDR_VAR 0 3
9128: PUSH
9129: LD_INT 59
9131: PUSH
9132: LD_INT 71
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: PUSH
9139: LD_INT 122
9141: PUSH
9142: LD_INT 117
9144: PUSH
9145: EMPTY
9146: LIST
9147: LIST
9148: PUSH
9149: EMPTY
9150: LIST
9151: LIST
9152: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9153: LD_ADDR_EXP 49
9157: PUSH
9158: LD_STRING Frank
9160: PPUSH
9161: LD_INT 0
9163: PPUSH
9164: CALL 466 0 2
9168: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9169: LD_ADDR_VAR 0 1
9173: PUSH
9174: LD_INT 1
9176: PPUSH
9177: LD_INT 2
9179: PPUSH
9180: CALL_OW 12
9184: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9185: LD_EXP 49
9189: PPUSH
9190: LD_VAR 0 3
9194: PUSH
9195: LD_VAR 0 1
9199: ARRAY
9200: PUSH
9201: LD_INT 1
9203: ARRAY
9204: PPUSH
9205: LD_VAR 0 3
9209: PUSH
9210: LD_VAR 0 1
9214: ARRAY
9215: PUSH
9216: LD_INT 2
9218: ARRAY
9219: PPUSH
9220: LD_INT 0
9222: PPUSH
9223: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9227: LD_EXP 49
9231: PPUSH
9232: LD_INT 1
9234: PPUSH
9235: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9239: LD_INT 35
9241: PPUSH
9242: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
9246: LD_EXP 49
9250: PPUSH
9251: LD_EXP 35
9255: PPUSH
9256: CALL_OW 296
9260: PUSH
9261: LD_INT 8
9263: LESS
9264: IFFALSE 9239
// InGameOn ;
9266: CALL_OW 8
// CenterOnUnits ( JMM ) ;
9270: LD_EXP 35
9274: PPUSH
9275: CALL_OW 85
// if IsInUnit ( JMM ) then
9279: LD_EXP 35
9283: PPUSH
9284: CALL_OW 310
9288: IFFALSE 9299
// ComFree ( JMM ) ;
9290: LD_EXP 35
9294: PPUSH
9295: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9299: LD_EXP 35
9303: PPUSH
9304: LD_EXP 49
9308: PPUSH
9309: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9313: LD_EXP 49
9317: PPUSH
9318: LD_EXP 35
9322: PPUSH
9323: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9327: LD_EXP 35
9331: PPUSH
9332: LD_STRING D6-JMM-1
9334: PPUSH
9335: CALL_OW 88
// p := 0 ;
9339: LD_ADDR_VAR 0 2
9343: PUSH
9344: LD_INT 0
9346: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9347: LD_INT 35
9349: PPUSH
9350: CALL_OW 67
// p := p + 1 ;
9354: LD_ADDR_VAR 0 2
9358: PUSH
9359: LD_VAR 0 2
9363: PUSH
9364: LD_INT 1
9366: PLUS
9367: ST_TO_ADDR
// until GetDistUnits ( JMM , Frank ) < 8 or p > 7 ;
9368: LD_EXP 35
9372: PPUSH
9373: LD_EXP 49
9377: PPUSH
9378: CALL_OW 296
9382: PUSH
9383: LD_INT 8
9385: LESS
9386: PUSH
9387: LD_VAR 0 2
9391: PUSH
9392: LD_INT 7
9394: GREATER
9395: OR
9396: IFFALSE 9347
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9398: LD_EXP 38
9402: PUSH
9403: LD_EXP 38
9407: PPUSH
9408: LD_EXP 49
9412: PPUSH
9413: CALL_OW 296
9417: PUSH
9418: LD_INT 20
9420: LESS
9421: AND
9422: IFFALSE 9447
// begin ComFree ( Lisa ) ;
9424: LD_EXP 38
9428: PPUSH
9429: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9433: LD_EXP 38
9437: PPUSH
9438: LD_EXP 49
9442: PPUSH
9443: CALL_OW 172
// end ; if Lynch then
9447: LD_EXP 45
9451: IFFALSE 9476
// begin ComFree ( Lynch ) ;
9453: LD_EXP 45
9457: PPUSH
9458: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9462: LD_EXP 45
9466: PPUSH
9467: LD_EXP 49
9471: PPUSH
9472: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9476: LD_EXP 35
9480: PPUSH
9481: LD_EXP 49
9485: PPUSH
9486: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9490: LD_EXP 49
9494: PPUSH
9495: LD_EXP 35
9499: PPUSH
9500: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9504: LD_EXP 49
9508: PPUSH
9509: LD_STRING D6-Frank-1
9511: PPUSH
9512: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9516: LD_INT 69
9518: PPUSH
9519: LD_INT 20
9521: PPUSH
9522: LD_INT 1
9524: PPUSH
9525: LD_INT 20
9527: NEG
9528: PPUSH
9529: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9533: LD_INT 69
9535: PPUSH
9536: LD_INT 20
9538: PPUSH
9539: LD_INT 1
9541: PPUSH
9542: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9546: LD_INT 190
9548: PPUSH
9549: LD_INT 31
9551: PPUSH
9552: LD_INT 1
9554: PPUSH
9555: LD_INT 20
9557: NEG
9558: PPUSH
9559: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9563: LD_INT 190
9565: PPUSH
9566: LD_INT 31
9568: PPUSH
9569: LD_INT 1
9571: PPUSH
9572: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9576: LD_INT 69
9578: PPUSH
9579: LD_INT 20
9581: PPUSH
9582: CALL_OW 84
// Wait ( 0 0$02 ) ;
9586: LD_INT 70
9588: PPUSH
9589: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9593: LD_EXP 35
9597: PPUSH
9598: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9602: LD_EXP 38
9606: PUSH
9607: LD_EXP 38
9611: PPUSH
9612: LD_EXP 49
9616: PPUSH
9617: CALL_OW 296
9621: PUSH
9622: LD_INT 20
9624: LESS
9625: AND
9626: PUSH
9627: LD_EXP 38
9631: PPUSH
9632: CALL_OW 302
9636: AND
9637: IFFALSE 9759
// begin ComFree ( Lisa ) ;
9639: LD_EXP 38
9643: PPUSH
9644: CALL_OW 139
// p := 0 ;
9648: LD_ADDR_VAR 0 2
9652: PUSH
9653: LD_INT 0
9655: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9656: LD_INT 35
9658: PPUSH
9659: CALL_OW 67
// p := p + 1 ;
9663: LD_ADDR_VAR 0 2
9667: PUSH
9668: LD_VAR 0 2
9672: PUSH
9673: LD_INT 1
9675: PLUS
9676: ST_TO_ADDR
// until GetDistUnits ( Lisa , Frank ) < 7 or p > 7 ;
9677: LD_EXP 38
9681: PPUSH
9682: LD_EXP 49
9686: PPUSH
9687: CALL_OW 296
9691: PUSH
9692: LD_INT 7
9694: LESS
9695: PUSH
9696: LD_VAR 0 2
9700: PUSH
9701: LD_INT 7
9703: GREATER
9704: OR
9705: IFFALSE 9656
// Say ( Lisa , D6-Lisa-1 ) ;
9707: LD_EXP 38
9711: PPUSH
9712: LD_STRING D6-Lisa-1
9714: PPUSH
9715: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9719: LD_EXP 38
9723: PPUSH
9724: LD_EXP 49
9728: PPUSH
9729: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9733: LD_EXP 49
9737: PPUSH
9738: LD_EXP 38
9742: PPUSH
9743: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9747: LD_EXP 49
9751: PPUSH
9752: LD_STRING D6-Frank-2
9754: PPUSH
9755: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9759: LD_EXP 45
9763: PUSH
9764: LD_EXP 45
9768: PPUSH
9769: LD_EXP 49
9773: PPUSH
9774: CALL_OW 296
9778: PUSH
9779: LD_INT 20
9781: LESS
9782: AND
9783: PUSH
9784: LD_EXP 45
9788: PPUSH
9789: CALL_OW 302
9793: AND
9794: IFFALSE 9975
// begin ComTurnUnit ( Lynch , JMM ) ;
9796: LD_EXP 45
9800: PPUSH
9801: LD_EXP 35
9805: PPUSH
9806: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9810: LD_EXP 49
9814: PPUSH
9815: LD_EXP 35
9819: PPUSH
9820: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9824: LD_EXP 45
9828: PPUSH
9829: LD_STRING D6-Sol1-2
9831: PPUSH
9832: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9836: LD_EXP 35
9840: PPUSH
9841: LD_STRING D6-JMM-2
9843: PPUSH
9844: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9848: LD_EXP 49
9852: PPUSH
9853: LD_STRING D6-Frank-3
9855: PPUSH
9856: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9860: LD_EXP 35
9864: PPUSH
9865: LD_STRING D6-JMM-3
9867: PPUSH
9868: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9872: LD_EXP 49
9876: PPUSH
9877: LD_STRING D6-Frank-4
9879: PPUSH
9880: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9884: LD_EXP 49
9888: PPUSH
9889: LD_STRING D6-Frank-4a
9891: PPUSH
9892: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9896: LD_EXP 35
9900: PPUSH
9901: LD_STRING D6-JMM-4
9903: PPUSH
9904: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9908: LD_EXP 49
9912: PPUSH
9913: LD_STRING D6-Frank-5
9915: PPUSH
9916: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9920: LD_EXP 38
9924: PUSH
9925: LD_EXP 38
9929: PPUSH
9930: CALL_OW 302
9934: AND
9935: IFFALSE 9949
// Say ( Lisa , D6-Lisa-5 ) ;
9937: LD_EXP 38
9941: PPUSH
9942: LD_STRING D6-Lisa-5
9944: PPUSH
9945: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9949: LD_EXP 49
9953: PPUSH
9954: LD_STRING D6-Frank-6
9956: PPUSH
9957: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9961: LD_EXP 35
9965: PPUSH
9966: LD_STRING D6-JMM-6
9968: PPUSH
9969: CALL_OW 88
// end else
9973: GO 10090
// begin ComTurnUnit ( Frank , JMM ) ;
9975: LD_EXP 49
9979: PPUSH
9980: LD_EXP 35
9984: PPUSH
9985: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
9989: LD_EXP 49
9993: PPUSH
9994: LD_STRING D6-Frank-4
9996: PPUSH
9997: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10001: LD_EXP 49
10005: PPUSH
10006: LD_STRING D6-Frank-4a
10008: PPUSH
10009: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10013: LD_EXP 35
10017: PPUSH
10018: LD_STRING D6-JMM-4
10020: PPUSH
10021: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10025: LD_EXP 49
10029: PPUSH
10030: LD_STRING D6-Frank-5
10032: PPUSH
10033: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10037: LD_EXP 38
10041: PUSH
10042: LD_EXP 38
10046: PPUSH
10047: CALL_OW 302
10051: AND
10052: IFFALSE 10066
// Say ( Lisa , D6-Lisa-5 ) ;
10054: LD_EXP 38
10058: PPUSH
10059: LD_STRING D6-Lisa-5
10061: PPUSH
10062: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10066: LD_EXP 49
10070: PPUSH
10071: LD_STRING D6-Frank-6
10073: PPUSH
10074: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10078: LD_EXP 35
10082: PPUSH
10083: LD_STRING D6-JMM-6
10085: PPUSH
10086: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
10090: LD_STRING Q1
10092: PPUSH
10093: CALL_OW 97
10097: PUSH
10098: LD_INT 1
10100: DOUBLE
10101: EQUAL
10102: IFTRUE 10106
10104: GO 10117
10106: POP
// frank_send_to_scout := true ; 2 :
10107: LD_ADDR_EXP 14
10111: PUSH
10112: LD_INT 1
10114: ST_TO_ADDR
10115: GO 10137
10117: LD_INT 2
10119: DOUBLE
10120: EQUAL
10121: IFTRUE 10125
10123: GO 10136
10125: POP
// frank_send_to_scout := false ; end ;
10126: LD_ADDR_EXP 14
10130: PUSH
10131: LD_INT 0
10133: ST_TO_ADDR
10134: GO 10137
10136: POP
// InGameOff ;
10137: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
10141: LD_EXP 35
10145: PUSH
10146: LD_EXP 38
10150: PUSH
10151: LD_EXP 45
10155: PUSH
10156: EMPTY
10157: LIST
10158: LIST
10159: LIST
10160: PPUSH
10161: CALL_OW 139
// if frank_send_to_scout then
10165: LD_EXP 14
10169: IFFALSE 10226
// begin ComMoveXY ( Frank , 130 , 123 ) ;
10171: LD_EXP 49
10175: PPUSH
10176: LD_INT 130
10178: PPUSH
10179: LD_INT 123
10181: PPUSH
10182: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
10186: LD_INT 35
10188: PPUSH
10189: CALL_OW 67
// until not See ( 1 , Frank ) ;
10193: LD_INT 1
10195: PPUSH
10196: LD_EXP 49
10200: PPUSH
10201: CALL_OW 292
10205: NOT
10206: IFFALSE 10186
// Wait ( 0 0$02 ) ;
10208: LD_INT 70
10210: PPUSH
10211: CALL_OW 67
// RemoveUnit ( Frank ) ;
10215: LD_EXP 49
10219: PPUSH
10220: CALL_OW 64
// end else
10224: GO 10238
// SetSide ( Frank , 1 ) ;
10226: LD_EXP 49
10230: PPUSH
10231: LD_INT 1
10233: PPUSH
10234: CALL_OW 235
// send_attack_on_cornel_base := true ;
10238: LD_ADDR_EXP 25
10242: PUSH
10243: LD_INT 1
10245: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10253: LD_ADDR_EXP 27
10257: PUSH
10258: LD_EXP 27
10262: PPUSH
10263: LD_STRING -
10265: PPUSH
10266: CALL 1109 0 2
10270: ST_TO_ADDR
// if debug then
10271: LD_EXP 1
10275: IFFALSE 10287
// debug_strings := time_to_prepare ;
10277: LD_ADDR_OWVAR 48
10281: PUSH
10282: LD_EXP 27
10286: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10287: LD_EXP 27
10291: PUSH
10292: LD_INT 0
10294: EQUAL
10295: IFFALSE 10246
// cornel_prepared := true ;
10297: LD_ADDR_EXP 11
10301: PUSH
10302: LD_INT 1
10304: ST_TO_ADDR
// end ;
10305: PPOPN 3
10307: END
// every 0 0$01 trigger cornel_prepared do
10308: LD_EXP 11
10312: IFFALSE 10569
10314: GO 10316
10316: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10317: LD_EXP 42
10321: PPUSH
10322: LD_STRING D3-Corn-1
10324: PPUSH
10325: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10329: LD_INT 35
10331: PPUSH
10332: CALL_OW 67
// until cornel_counter = 0 ;
10336: LD_EXP 10
10340: PUSH
10341: LD_INT 0
10343: EQUAL
10344: IFFALSE 10329
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10346: LD_EXP 42
10350: PPUSH
10351: LD_STRING D3a-Corn-1
10353: PPUSH
10354: CALL_OW 94
// if IsOk ( Cornel ) then
10358: LD_EXP 42
10362: PPUSH
10363: CALL_OW 302
10367: IFFALSE 10381
// Say ( JMM , D3a-JMM-1 ) ;
10369: LD_EXP 35
10373: PPUSH
10374: LD_STRING D3a-JMM-1
10376: PPUSH
10377: CALL_OW 88
// end_mission_allowed := true ;
10381: LD_ADDR_EXP 20
10385: PUSH
10386: LD_INT 1
10388: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10389: LD_STRING M2
10391: PPUSH
10392: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10396: LD_INT 9
10398: PPUSH
10399: LD_INT 1
10401: PPUSH
10402: CALL_OW 424
// Wait ( 0 0$05 ) ;
10406: LD_INT 175
10408: PPUSH
10409: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10413: LD_EXP 42
10417: PPUSH
10418: LD_STRING D3a-Corn-2
10420: PPUSH
10421: CALL_OW 94
// cornel_attack := true ;
10425: LD_ADDR_EXP 9
10429: PUSH
10430: LD_INT 1
10432: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10433: LD_INT 105
10435: PPUSH
10436: CALL_OW 67
// AddMoreTanks ( ) ;
10440: CALL 4826 0 0
// if frank_send_to_scout then
10444: LD_EXP 14
10448: IFFALSE 10569
// begin InitHc ;
10450: CALL_OW 19
// InitUc ;
10454: CALL_OW 18
// uc_side := 8 ;
10458: LD_ADDR_OWVAR 20
10462: PUSH
10463: LD_INT 8
10465: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10466: LD_ADDR_EXP 49
10470: PUSH
10471: LD_STRING Frank
10473: PPUSH
10474: LD_INT 0
10476: PPUSH
10477: CALL 466 0 2
10481: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10482: LD_EXP 49
10486: PPUSH
10487: LD_INT 6
10489: PPUSH
10490: LD_INT 9
10492: PPUSH
10493: LD_INT 0
10495: PPUSH
10496: CALL_OW 48
// ComCrawl ( Frank ) ;
10500: LD_EXP 49
10504: PPUSH
10505: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
10509: LD_INT 35
10511: PPUSH
10512: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
10516: LD_EXP 35
10520: PPUSH
10521: LD_EXP 49
10525: PPUSH
10526: CALL_OW 296
10530: PUSH
10531: LD_INT 9
10533: LESS
10534: IFFALSE 10509
// SetSide ( Frank , 1 ) ;
10536: LD_EXP 49
10540: PPUSH
10541: LD_INT 1
10543: PPUSH
10544: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10548: LD_EXP 49
10552: PPUSH
10553: LD_STRING D6a-Frank-1
10555: PPUSH
10556: CALL_OW 88
// ComWalk ( Frank ) ;
10560: LD_EXP 49
10564: PPUSH
10565: CALL_OW 138
// end ; end ;
10569: END
// every 0 0$01 trigger solar_builded do
10570: LD_EXP 13
10574: IFFALSE 10678
10576: GO 10578
10578: DISABLE
// begin Wait ( 0 0$02 ) ;
10579: LD_INT 70
10581: PPUSH
10582: CALL_OW 67
// DialogueOn ;
10586: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10590: LD_EXP 35
10594: PPUSH
10595: LD_STRING D2b-JMM-1
10597: PPUSH
10598: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10602: LD_EXP 46
10606: PUSH
10607: LD_EXP 46
10611: PPUSH
10612: CALL_OW 302
10616: AND
10617: IFFALSE 10667
// begin Say ( Walker , D2b-Sci1-1 ) ;
10619: LD_EXP 46
10623: PPUSH
10624: LD_STRING D2b-Sci1-1
10626: PPUSH
10627: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10631: LD_EXP 35
10635: PPUSH
10636: LD_STRING D2b-JMM-2
10638: PPUSH
10639: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10643: LD_EXP 46
10647: PPUSH
10648: LD_STRING D2b-Sci1-2
10650: PPUSH
10651: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10655: LD_EXP 35
10659: PPUSH
10660: LD_STRING D2b-JMM-3
10662: PPUSH
10663: CALL_OW 88
// end ; DialogueOff ;
10667: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10671: LD_STRING MOutSol
10673: PPUSH
10674: CALL_OW 337
// end ;
10678: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10679: LD_EXP 13
10683: PUSH
10684: LD_EXP 35
10688: PPUSH
10689: CALL_OW 302
10693: AND
10694: PUSH
10695: LD_EXP 35
10699: PPUSH
10700: CALL 943 0 1
10704: AND
10705: PUSH
10706: LD_EXP 15
10710: NOT
10711: AND
10712: IFFALSE 10783
10714: GO 10716
10716: DISABLE
10717: LD_INT 0
10719: PPUSH
// begin jmm_in_veh := true ;
10720: LD_ADDR_EXP 15
10724: PUSH
10725: LD_INT 1
10727: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10728: LD_ADDR_VAR 0 1
10732: PUSH
10733: LD_INT 0
10735: PPUSH
10736: LD_INT 1
10738: PPUSH
10739: CALL_OW 12
10743: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10744: LD_INT 70
10746: PPUSH
10747: CALL_OW 67
// if i then
10751: LD_VAR 0 1
10755: IFFALSE 10771
// Say ( JMM , D2c-JMM-1 ) else
10757: LD_EXP 35
10761: PPUSH
10762: LD_STRING D2c-JMM-1
10764: PPUSH
10765: CALL_OW 88
10769: GO 10783
// Say ( JMM , D2c-JMM-1a ) ;
10771: LD_EXP 35
10775: PPUSH
10776: LD_STRING D2c-JMM-1a
10778: PPUSH
10779: CALL_OW 88
// end ;
10783: PPOPN 1
10785: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10786: LD_EXP 13
10790: PUSH
10791: LD_EXP 36
10795: PPUSH
10796: CALL_OW 302
10800: AND
10801: PUSH
10802: LD_EXP 36
10806: PPUSH
10807: CALL 943 0 1
10811: AND
10812: PUSH
10813: LD_EXP 16
10817: NOT
10818: AND
10819: IFFALSE 10851
10821: GO 10823
10823: DISABLE
// begin bobby_in_veh := true ;
10824: LD_ADDR_EXP 16
10828: PUSH
10829: LD_INT 1
10831: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10832: LD_INT 70
10834: PPUSH
10835: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10839: LD_EXP 36
10843: PPUSH
10844: LD_STRING D2c-Bobby-1
10846: PPUSH
10847: CALL_OW 88
10851: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10852: LD_EXP 13
10856: PUSH
10857: LD_EXP 38
10861: PPUSH
10862: CALL_OW 302
10866: AND
10867: PUSH
10868: LD_EXP 38
10872: PPUSH
10873: CALL 943 0 1
10877: AND
10878: PUSH
10879: LD_EXP 18
10883: NOT
10884: AND
10885: IFFALSE 10917
10887: GO 10889
10889: DISABLE
// begin lisa_in_veh := true ;
10890: LD_ADDR_EXP 18
10894: PUSH
10895: LD_INT 1
10897: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10898: LD_INT 70
10900: PPUSH
10901: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10905: LD_EXP 38
10909: PPUSH
10910: LD_STRING D2c-Lisa-1
10912: PPUSH
10913: CALL_OW 88
10917: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
10918: LD_EXP 13
10922: PUSH
10923: LD_EXP 37
10927: PPUSH
10928: CALL_OW 302
10932: AND
10933: PUSH
10934: LD_EXP 37
10938: PPUSH
10939: CALL 943 0 1
10943: AND
10944: PUSH
10945: LD_EXP 17
10949: NOT
10950: AND
10951: IFFALSE 11022
10953: GO 10955
10955: DISABLE
10956: LD_INT 0
10958: PPUSH
// begin cyrus_in_veh := true ;
10959: LD_ADDR_EXP 17
10963: PUSH
10964: LD_INT 1
10966: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10967: LD_ADDR_VAR 0 1
10971: PUSH
10972: LD_INT 0
10974: PPUSH
10975: LD_INT 1
10977: PPUSH
10978: CALL_OW 12
10982: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10983: LD_INT 70
10985: PPUSH
10986: CALL_OW 67
// if i then
10990: LD_VAR 0 1
10994: IFFALSE 11010
// Say ( Cyrus , D2c-Cyrus-1 ) else
10996: LD_EXP 37
11000: PPUSH
11001: LD_STRING D2c-Cyrus-1
11003: PPUSH
11004: CALL_OW 88
11008: GO 11022
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11010: LD_EXP 37
11014: PPUSH
11015: LD_STRING D2c-Cyrus-1a
11017: PPUSH
11018: CALL_OW 88
// end ;
11022: PPOPN 1
11024: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
11025: LD_EXP 42
11029: PPUSH
11030: LD_INT 16
11032: PPUSH
11033: CALL_OW 308
11037: IFFALSE 11293
11039: GO 11041
11041: DISABLE
11042: LD_INT 0
11044: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
11045: LD_INT 3
11047: PPUSH
11048: LD_EXP 42
11052: PPUSH
11053: CALL_OW 471
// send_attack_on_cornel := true ;
11057: LD_ADDR_EXP 30
11061: PUSH
11062: LD_INT 1
11064: ST_TO_ADDR
// if ru_vehicles then
11065: LD_EXP 54
11069: IFFALSE 11103
// for i in ru_vehicles do
11071: LD_ADDR_VAR 0 1
11075: PUSH
11076: LD_EXP 54
11080: PUSH
11081: FOR_IN
11082: IFFALSE 11101
// ComAgressiveMove ( i , 215 , 69 ) ;
11084: LD_VAR 0 1
11088: PPUSH
11089: LD_INT 215
11091: PPUSH
11092: LD_INT 69
11094: PPUSH
11095: CALL_OW 114
11099: GO 11081
11101: POP
11102: POP
// if ru_patrol then
11103: LD_EXP 51
11107: IFFALSE 11141
// for i in ru_patrol do
11109: LD_ADDR_VAR 0 1
11113: PUSH
11114: LD_EXP 51
11118: PUSH
11119: FOR_IN
11120: IFFALSE 11139
// ComAgressiveMove ( i , 215 , 69 ) ;
11122: LD_VAR 0 1
11126: PPUSH
11127: LD_INT 215
11129: PPUSH
11130: LD_INT 69
11132: PPUSH
11133: CALL_OW 114
11137: GO 11119
11139: POP
11140: POP
// if frank_send_to_scout then
11141: LD_EXP 14
11145: IFFALSE 11159
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
11147: LD_EXP 49
11151: PPUSH
11152: LD_STRING D3b-Frank-1
11154: PPUSH
11155: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
11159: LD_INT 105
11161: PPUSH
11162: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
11166: LD_EXP 42
11170: PPUSH
11171: LD_STRING D4-Corn-1
11173: PPUSH
11174: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
11178: LD_INT 35
11180: PPUSH
11181: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 6 ;
11185: LD_INT 22
11187: PUSH
11188: LD_INT 4
11190: PUSH
11191: EMPTY
11192: LIST
11193: LIST
11194: PUSH
11195: LD_INT 21
11197: PUSH
11198: LD_INT 1
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PUSH
11205: LD_INT 50
11207: PUSH
11208: EMPTY
11209: LIST
11210: PUSH
11211: EMPTY
11212: LIST
11213: LIST
11214: LIST
11215: PPUSH
11216: CALL_OW 69
11220: PUSH
11221: LD_INT 6
11223: LESS
11224: IFFALSE 11178
// SayRadio ( Cornel , D5-Corn-1 ) ;
11226: LD_EXP 42
11230: PPUSH
11231: LD_STRING D5-Corn-1
11233: PPUSH
11234: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11238: LD_EXP 42
11242: PPUSH
11243: LD_EXP 2
11247: PUSH
11248: LD_STRING Cornel
11250: STR
11251: PPUSH
11252: CALL_OW 38
// ChangeSideFog ( 4 , 8 ) ;
11256: LD_INT 4
11258: PPUSH
11259: LD_INT 8
11261: PPUSH
11262: CALL_OW 343
// Wait ( 0 0$01 ) ;
11266: LD_INT 35
11268: PPUSH
11269: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11273: LD_INT 3
11275: PPUSH
11276: LD_EXP 42
11280: PPUSH
11281: CALL_OW 472
// send_attack_on_cornel := false ;
11285: LD_ADDR_EXP 30
11289: PUSH
11290: LD_INT 0
11292: ST_TO_ADDR
// end ;
11293: PPOPN 1
11295: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11296: LD_INT 9
11298: PPUSH
11299: LD_INT 22
11301: PUSH
11302: LD_INT 1
11304: PUSH
11305: EMPTY
11306: LIST
11307: LIST
11308: PPUSH
11309: CALL_OW 70
11313: PUSH
11314: LD_EXP 31
11318: OR
11319: IFFALSE 11501
11321: GO 11323
11323: DISABLE
11324: LD_INT 0
11326: PPUSH
11327: PPUSH
// begin enable ;
11328: ENABLE
// if not jmm_on_west then
11329: LD_EXP 5
11333: NOT
11334: IFFALSE 11345
// begin YouLost ( 4 ) ;
11336: LD_STRING 4
11338: PPUSH
11339: CALL_OW 104
// exit ;
11343: GO 11501
// end ; if not game_end then
11345: LD_EXP 31
11349: NOT
11350: IFFALSE 11360
// game_end := true ;
11352: LD_ADDR_EXP 31
11356: PUSH
11357: LD_INT 1
11359: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11360: LD_ADDR_VAR 0 2
11364: PUSH
11365: LD_INT 9
11367: PPUSH
11368: LD_INT 22
11370: PUSH
11371: LD_INT 1
11373: PUSH
11374: EMPTY
11375: LIST
11376: LIST
11377: PPUSH
11378: CALL_OW 70
11382: ST_TO_ADDR
// if not filter then
11383: LD_VAR 0 2
11387: NOT
11388: IFFALSE 11392
// exit ;
11390: GO 11501
// for i in filter do
11392: LD_ADDR_VAR 0 1
11396: PUSH
11397: LD_VAR 0 2
11401: PUSH
11402: FOR_IN
11403: IFFALSE 11499
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
11405: LD_VAR 0 1
11409: PPUSH
11410: CALL_OW 302
11414: PUSH
11415: LD_VAR 0 1
11419: PPUSH
11420: CALL_OW 247
11424: PUSH
11425: LD_INT 2
11427: EQUAL
11428: AND
11429: IFFALSE 11462
// begin veh_on_meta := true ;
11431: LD_ADDR_EXP 26
11435: PUSH
11436: LD_INT 1
11438: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11439: LD_VAR 0 1
11443: PPUSH
11444: CALL_OW 311
11448: PPUSH
11449: CALL 11504 0 1
// RemoveUnit ( i ) ;
11453: LD_VAR 0 1
11457: PPUSH
11458: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11462: LD_VAR 0 1
11466: PPUSH
11467: CALL_OW 302
11471: PUSH
11472: LD_VAR 0 1
11476: PPUSH
11477: CALL_OW 247
11481: PUSH
11482: LD_INT 1
11484: EQUAL
11485: AND
11486: IFFALSE 11497
// Save ( i ) ;
11488: LD_VAR 0 1
11492: PPUSH
11493: CALL 11504 0 1
// end ;
11497: GO 11402
11499: POP
11500: POP
// end ;
11501: PPOPN 2
11503: END
// export function Save ( i ) ; begin
11504: LD_INT 0
11506: PPUSH
// save_counter := save_counter + 1 ;
11507: LD_ADDR_EXP 34
11511: PUSH
11512: LD_EXP 34
11516: PUSH
11517: LD_INT 1
11519: PLUS
11520: ST_TO_ADDR
// if i = JMM then
11521: LD_VAR 0 1
11525: PUSH
11526: LD_EXP 35
11530: EQUAL
11531: IFFALSE 11653
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11533: LD_EXP 23
11537: PUSH
11538: LD_INT 22
11540: PUSH
11541: LD_INT 1
11543: PUSH
11544: EMPTY
11545: LIST
11546: LIST
11547: PUSH
11548: LD_INT 21
11550: PUSH
11551: LD_INT 1
11553: PUSH
11554: EMPTY
11555: LIST
11556: LIST
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PPUSH
11562: CALL_OW 69
11566: PUSH
11567: LD_INT 1
11569: GREATER
11570: AND
11571: IFFALSE 11628
// begin show_query := false ;
11573: LD_ADDR_EXP 23
11577: PUSH
11578: LD_INT 0
11580: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11581: LD_STRING Q2
11583: PPUSH
11584: CALL_OW 97
11588: PUSH
11589: LD_INT 1
11591: DOUBLE
11592: EQUAL
11593: IFTRUE 11597
11595: GO 11608
11597: POP
// wait_for_them := true ; 2 :
11598: LD_ADDR_EXP 24
11602: PUSH
11603: LD_INT 1
11605: ST_TO_ADDR
11606: GO 11628
11608: LD_INT 2
11610: DOUBLE
11611: EQUAL
11612: IFTRUE 11616
11614: GO 11627
11616: POP
// wait_for_them := false ; end ;
11617: LD_ADDR_EXP 24
11621: PUSH
11622: LD_INT 0
11624: ST_TO_ADDR
11625: GO 11628
11627: POP
// end ; save_group := save_group ^ JMM ;
11628: LD_ADDR_EXP 22
11632: PUSH
11633: LD_EXP 22
11637: PUSH
11638: LD_EXP 35
11642: ADD
11643: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11644: LD_EXP 35
11648: PPUSH
11649: CALL_OW 64
// end ; if i = Lisa then
11653: LD_VAR 0 1
11657: PUSH
11658: LD_EXP 38
11662: EQUAL
11663: IFFALSE 11690
// begin save_group := save_group ^ Lisa ;
11665: LD_ADDR_EXP 22
11669: PUSH
11670: LD_EXP 22
11674: PUSH
11675: LD_EXP 38
11679: ADD
11680: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11681: LD_EXP 38
11685: PPUSH
11686: CALL_OW 64
// end ; if i = Bobby then
11690: LD_VAR 0 1
11694: PUSH
11695: LD_EXP 36
11699: EQUAL
11700: IFFALSE 11727
// begin save_group := save_group ^ Bobby ;
11702: LD_ADDR_EXP 22
11706: PUSH
11707: LD_EXP 22
11711: PUSH
11712: LD_EXP 36
11716: ADD
11717: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11718: LD_EXP 36
11722: PPUSH
11723: CALL_OW 64
// end ; if i = Cyrus then
11727: LD_VAR 0 1
11731: PUSH
11732: LD_EXP 37
11736: EQUAL
11737: IFFALSE 11764
// begin save_group := save_group ^ Cyrus ;
11739: LD_ADDR_EXP 22
11743: PUSH
11744: LD_EXP 22
11748: PUSH
11749: LD_EXP 37
11753: ADD
11754: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11755: LD_EXP 37
11759: PPUSH
11760: CALL_OW 64
// end ; if i = Khatam then
11764: LD_VAR 0 1
11768: PUSH
11769: LD_EXP 39
11773: EQUAL
11774: IFFALSE 11801
// begin save_group := save_group ^ Khatam ;
11776: LD_ADDR_EXP 22
11780: PUSH
11781: LD_EXP 22
11785: PUSH
11786: LD_EXP 39
11790: ADD
11791: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11792: LD_EXP 39
11796: PPUSH
11797: CALL_OW 64
// end ; if i = Frank then
11801: LD_VAR 0 1
11805: PUSH
11806: LD_EXP 49
11810: EQUAL
11811: IFFALSE 11838
// begin save_group := save_group ^ Frank ;
11813: LD_ADDR_EXP 22
11817: PUSH
11818: LD_EXP 22
11822: PUSH
11823: LD_EXP 49
11827: ADD
11828: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11829: LD_EXP 49
11833: PPUSH
11834: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11838: LD_VAR 0 1
11842: PPUSH
11843: CALL_OW 302
11847: PUSH
11848: LD_VAR 0 1
11852: PPUSH
11853: CALL_OW 247
11857: PUSH
11858: LD_INT 1
11860: EQUAL
11861: AND
11862: PUSH
11863: LD_VAR 0 1
11867: PUSH
11868: LD_EXP 22
11872: IN
11873: NOT
11874: AND
11875: IFFALSE 11902
// begin save_others := save_others ^ i ;
11877: LD_ADDR_EXP 21
11881: PUSH
11882: LD_EXP 21
11886: PUSH
11887: LD_VAR 0 1
11891: ADD
11892: ST_TO_ADDR
// RemoveUnit ( i ) ;
11893: LD_VAR 0 1
11897: PPUSH
11898: CALL_OW 64
// end ; end ;
11902: LD_VAR 0 2
11906: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
11907: LD_EXP 23
11911: NOT
11912: PUSH
11913: LD_EXP 24
11917: NOT
11918: AND
11919: PUSH
11920: LD_INT 22
11922: PUSH
11923: LD_INT 1
11925: PUSH
11926: EMPTY
11927: LIST
11928: LIST
11929: PUSH
11930: LD_INT 21
11932: PUSH
11933: LD_INT 1
11935: PUSH
11936: EMPTY
11937: LIST
11938: LIST
11939: PUSH
11940: EMPTY
11941: LIST
11942: LIST
11943: PPUSH
11944: CALL_OW 69
11948: PUSH
11949: LD_INT 0
11951: EQUAL
11952: OR
11953: IFFALSE 11962
11955: GO 11957
11957: DISABLE
// EndMission ;
11958: CALL 11963 0 0
11962: END
// export function EndMission ; var i ; begin
11963: LD_INT 0
11965: PPUSH
11966: PPUSH
// Wait ( 0 0$02 ) ;
11967: LD_INT 70
11969: PPUSH
11970: CALL_OW 67
// if solar_builded then
11974: LD_EXP 13
11978: IFFALSE 11992
// AddMedal ( Solar1 , 1 ) else
11980: LD_STRING Solar1
11982: PPUSH
11983: LD_INT 1
11985: PPUSH
11986: CALL_OW 101
11990: GO 12003
// AddMedal ( Solar1 , - 1 ) ;
11992: LD_STRING Solar1
11994: PPUSH
11995: LD_INT 1
11997: NEG
11998: PPUSH
11999: CALL_OW 101
// if veh_on_meta then
12003: LD_EXP 26
12007: IFFALSE 12021
// AddMedal ( Solar2 , 1 ) else
12009: LD_STRING Solar2
12011: PPUSH
12012: LD_INT 1
12014: PPUSH
12015: CALL_OW 101
12019: GO 12051
// if solar_builded then
12021: LD_EXP 13
12025: IFFALSE 12040
// AddMedal ( Solar2 , - 1 ) else
12027: LD_STRING Solar2
12029: PPUSH
12030: LD_INT 1
12032: NEG
12033: PPUSH
12034: CALL_OW 101
12038: GO 12051
// AddMedal ( Solar2 , - 2 ) ;
12040: LD_STRING Solar2
12042: PPUSH
12043: LD_INT 2
12045: NEG
12046: PPUSH
12047: CALL_OW 101
// if lose_counter = 0 then
12051: LD_EXP 32
12055: PUSH
12056: LD_INT 0
12058: EQUAL
12059: IFFALSE 12073
// AddMedal ( No , 1 ) else
12061: LD_STRING No
12063: PPUSH
12064: LD_INT 1
12066: PPUSH
12067: CALL_OW 101
12071: GO 12117
// if lose_counter > 0 and lose_counter < 4 then
12073: LD_EXP 32
12077: PUSH
12078: LD_INT 0
12080: GREATER
12081: PUSH
12082: LD_EXP 32
12086: PUSH
12087: LD_INT 4
12089: LESS
12090: AND
12091: IFFALSE 12106
// AddMedal ( No , - 1 ) else
12093: LD_STRING No
12095: PPUSH
12096: LD_INT 1
12098: NEG
12099: PPUSH
12100: CALL_OW 101
12104: GO 12117
// AddMedal ( UpTo4 , - 1 ) ;
12106: LD_STRING UpTo4
12108: PPUSH
12109: LD_INT 1
12111: NEG
12112: PPUSH
12113: CALL_OW 101
// GiveMedals ( MAIN ) ;
12117: LD_STRING MAIN
12119: PPUSH
12120: CALL_OW 102
// if IsDead ( Pokryshkin ) then
12124: LD_EXP 50
12128: PPUSH
12129: CALL_OW 301
12133: IFFALSE 12173
// for i in save_group ^ save_others do
12135: LD_ADDR_VAR 0 2
12139: PUSH
12140: LD_EXP 22
12144: PUSH
12145: LD_EXP 21
12149: ADD
12150: PUSH
12151: FOR_IN
12152: IFFALSE 12171
// AddExperience ( i , skill_combat , 1500 ) ;
12154: LD_VAR 0 2
12158: PPUSH
12159: LD_INT 1
12161: PPUSH
12162: LD_INT 1500
12164: PPUSH
12165: CALL_OW 492
12169: GO 12151
12171: POP
12172: POP
// RewardPeople ( save_group ^ save_others ) ;
12173: LD_EXP 22
12177: PUSH
12178: LD_EXP 21
12182: ADD
12183: PPUSH
12184: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
12188: LD_EXP 35
12192: PPUSH
12193: LD_EXP 2
12197: PUSH
12198: LD_STRING JMM
12200: STR
12201: PPUSH
12202: CALL_OW 38
// if Bobby in save_group then
12206: LD_EXP 36
12210: PUSH
12211: LD_EXP 22
12215: IN
12216: IFFALSE 12236
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12218: LD_EXP 36
12222: PPUSH
12223: LD_EXP 2
12227: PUSH
12228: LD_STRING Bobby
12230: STR
12231: PPUSH
12232: CALL_OW 38
// if Cyrus in save_group then
12236: LD_EXP 37
12240: PUSH
12241: LD_EXP 22
12245: IN
12246: IFFALSE 12266
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12248: LD_EXP 37
12252: PPUSH
12253: LD_EXP 2
12257: PUSH
12258: LD_STRING Cyrus
12260: STR
12261: PPUSH
12262: CALL_OW 38
// if Lisa in save_group then
12266: LD_EXP 38
12270: PUSH
12271: LD_EXP 22
12275: IN
12276: IFFALSE 12296
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12278: LD_EXP 38
12282: PPUSH
12283: LD_EXP 2
12287: PUSH
12288: LD_STRING Lisa
12290: STR
12291: PPUSH
12292: CALL_OW 38
// if Frank in save_group then
12296: LD_EXP 49
12300: PUSH
12301: LD_EXP 22
12305: IN
12306: IFFALSE 12326
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12308: LD_EXP 49
12312: PPUSH
12313: LD_EXP 2
12317: PUSH
12318: LD_STRING Frank
12320: STR
12321: PPUSH
12322: CALL_OW 38
// if Khatam in save_group then
12326: LD_EXP 39
12330: PUSH
12331: LD_EXP 22
12335: IN
12336: IFFALSE 12356
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
12338: LD_EXP 39
12342: PPUSH
12343: LD_EXP 2
12347: PUSH
12348: LD_STRING Khatam
12350: STR
12351: PPUSH
12352: CALL_OW 38
// if save_others then
12356: LD_EXP 21
12360: IFFALSE 12374
// SaveCharacters ( save_others , 03_others ) ;
12362: LD_EXP 21
12366: PPUSH
12367: LD_STRING 03_others
12369: PPUSH
12370: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) then
12374: LD_EXP 43
12378: PUSH
12379: LD_EXP 43
12383: PPUSH
12384: CALL_OW 302
12388: AND
12389: IFFALSE 12401
// begin ResetFog ;
12391: CALL_OW 335
// DisplayEndingScene ;
12395: CALL 12423 0 0
// end else
12399: GO 12414
// DeleteCharacters ( mission_prefix & Cornel ) ;
12401: LD_EXP 2
12405: PUSH
12406: LD_STRING Cornel
12408: STR
12409: PPUSH
12410: CALL_OW 40
// YouWin ;
12414: CALL_OW 103
// end ;
12418: LD_VAR 0 1
12422: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
12423: LD_INT 0
12425: PPUSH
12426: PPUSH
12427: PPUSH
12428: PPUSH
12429: PPUSH
12430: PPUSH
// InGameOn ;
12431: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12435: LD_INT 208
12437: PPUSH
12438: LD_INT 62
12440: PPUSH
12441: LD_INT 1
12443: PPUSH
12444: LD_INT 10
12446: NEG
12447: PPUSH
12448: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
12452: LD_INT 208
12454: PPUSH
12455: LD_INT 62
12457: PPUSH
12458: LD_INT 1
12460: PPUSH
12461: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
12465: LD_ADDR_VAR 0 3
12469: PUSH
12470: LD_INT 22
12472: PUSH
12473: LD_INT 3
12475: PUSH
12476: EMPTY
12477: LIST
12478: LIST
12479: PUSH
12480: LD_INT 2
12482: PUSH
12483: LD_INT 21
12485: PUSH
12486: LD_INT 2
12488: PUSH
12489: EMPTY
12490: LIST
12491: LIST
12492: PUSH
12493: LD_INT 21
12495: PUSH
12496: LD_INT 1
12498: PUSH
12499: EMPTY
12500: LIST
12501: LIST
12502: PUSH
12503: EMPTY
12504: LIST
12505: LIST
12506: LIST
12507: PUSH
12508: EMPTY
12509: LIST
12510: LIST
12511: PPUSH
12512: CALL_OW 69
12516: ST_TO_ADDR
// if filter then
12517: LD_VAR 0 3
12521: IFFALSE 12549
// for i in filter do
12523: LD_ADDR_VAR 0 2
12527: PUSH
12528: LD_VAR 0 3
12532: PUSH
12533: FOR_IN
12534: IFFALSE 12547
// RemoveUnit ( i ) ;
12536: LD_VAR 0 2
12540: PPUSH
12541: CALL_OW 64
12545: GO 12533
12547: POP
12548: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
12549: LD_ADDR_VAR 0 3
12553: PUSH
12554: LD_INT 22
12556: PUSH
12557: LD_INT 4
12559: PUSH
12560: EMPTY
12561: LIST
12562: LIST
12563: PUSH
12564: LD_INT 21
12566: PUSH
12567: LD_INT 1
12569: PUSH
12570: EMPTY
12571: LIST
12572: LIST
12573: PUSH
12574: EMPTY
12575: LIST
12576: LIST
12577: PPUSH
12578: CALL_OW 69
12582: ST_TO_ADDR
// if filter then
12583: LD_VAR 0 3
12587: IFFALSE 12618
// for i in filter do
12589: LD_ADDR_VAR 0 2
12593: PUSH
12594: LD_VAR 0 3
12598: PUSH
12599: FOR_IN
12600: IFFALSE 12616
// SetLives ( i , 0 ) ;
12602: LD_VAR 0 2
12606: PPUSH
12607: LD_INT 0
12609: PPUSH
12610: CALL_OW 234
12614: GO 12599
12616: POP
12617: POP
// uc_side := 4 ;
12618: LD_ADDR_OWVAR 20
12622: PUSH
12623: LD_INT 4
12625: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12626: LD_ADDR_VAR 0 4
12630: PUSH
12631: LD_STRING Cornell
12633: PPUSH
12634: LD_INT 0
12636: PPUSH
12637: CALL 466 0 2
12641: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12642: LD_VAR 0 4
12646: PPUSH
12647: LD_INT 208
12649: PPUSH
12650: LD_INT 62
12652: PPUSH
12653: LD_INT 0
12655: PPUSH
12656: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12660: LD_VAR 0 4
12664: PPUSH
12665: LD_INT 100
12667: PPUSH
12668: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12672: LD_INT 3
12674: PPUSH
12675: LD_VAR 0 4
12679: PPUSH
12680: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12684: LD_INT 4
12686: PPUSH
12687: LD_INT 3
12689: PPUSH
12690: LD_INT 1
12692: PPUSH
12693: LD_INT 1
12695: PPUSH
12696: CALL_OW 80
// uc_side := 3 ;
12700: LD_ADDR_OWVAR 20
12704: PUSH
12705: LD_INT 3
12707: ST_TO_ADDR
// uc_nation := 3 ;
12708: LD_ADDR_OWVAR 21
12712: PUSH
12713: LD_INT 3
12715: ST_TO_ADDR
// InitHc ;
12716: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12720: LD_ADDR_VAR 0 5
12724: PUSH
12725: LD_STRING Mikhail
12727: PPUSH
12728: LD_INT 0
12730: PPUSH
12731: CALL 466 0 2
12735: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12736: LD_INT 1
12738: PPUSH
12739: LD_INT 1
12741: PPUSH
12742: LD_INT 0
12744: PPUSH
12745: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12749: LD_ADDR_VAR 0 6
12753: PUSH
12754: LD_VAR 0 6
12758: PUSH
12759: CALL_OW 44
12763: ADD
12764: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12765: LD_ADDR_VAR 0 6
12769: PUSH
12770: LD_VAR 0 6
12774: PUSH
12775: CALL_OW 44
12779: ADD
12780: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12781: LD_INT 2
12783: PPUSH
12784: LD_INT 4
12786: PPUSH
12787: LD_INT 0
12789: PPUSH
12790: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12794: LD_ADDR_VAR 0 6
12798: PUSH
12799: LD_VAR 0 6
12803: PUSH
12804: CALL_OW 44
12808: ADD
12809: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12810: LD_VAR 0 5
12814: PPUSH
12815: LD_INT 17
12817: PPUSH
12818: LD_INT 0
12820: PPUSH
12821: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12825: LD_VAR 0 5
12829: PPUSH
12830: LD_INT 210
12832: PPUSH
12833: LD_INT 63
12835: PPUSH
12836: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12840: LD_VAR 0 5
12844: PPUSH
12845: LD_INT 208
12847: PPUSH
12848: LD_INT 62
12850: PPUSH
12851: CALL_OW 178
// for i in fake_russians do
12855: LD_ADDR_VAR 0 2
12859: PUSH
12860: LD_VAR 0 6
12864: PUSH
12865: FOR_IN
12866: IFFALSE 12944
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12868: LD_VAR 0 2
12872: PPUSH
12873: LD_INT 17
12875: PPUSH
12876: LD_INT 0
12878: PPUSH
12879: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
12883: LD_VAR 0 2
12887: PPUSH
12888: LD_INT 215
12890: PPUSH
12891: LD_INT 67
12893: PPUSH
12894: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
12898: LD_VAR 0 2
12902: PPUSH
12903: LD_INT 208
12905: PPUSH
12906: LD_INT 62
12908: PPUSH
12909: CALL_OW 178
// if GetClass ( i ) = 4 then
12913: LD_VAR 0 2
12917: PPUSH
12918: CALL_OW 257
12922: PUSH
12923: LD_INT 4
12925: EQUAL
12926: IFFALSE 12942
// ComHeal ( i , fake_cornel ) ;
12928: LD_VAR 0 2
12932: PPUSH
12933: LD_VAR 0 4
12937: PPUSH
12938: CALL_OW 128
// end ;
12942: GO 12865
12944: POP
12945: POP
// Wait ( 0 0$01 ) ;
12946: LD_INT 35
12948: PPUSH
12949: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
12953: LD_INT 208
12955: PPUSH
12956: LD_INT 62
12958: PPUSH
12959: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12963: LD_INT 208
12965: PPUSH
12966: LD_INT 62
12968: PPUSH
12969: LD_INT 1
12971: PPUSH
12972: LD_INT 10
12974: NEG
12975: PPUSH
12976: CALL_OW 330
// Wait ( 0 0$15 ) ;
12980: LD_INT 525
12982: PPUSH
12983: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
12987: LD_INT 208
12989: PPUSH
12990: LD_INT 62
12992: PPUSH
12993: LD_INT 1
12995: PPUSH
12996: CALL_OW 331
// ResetFog ;
13000: CALL_OW 335
// InGameOff ;
13004: CALL_OW 9
// end ;
13008: LD_VAR 0 1
13012: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
13013: LD_INT 10
13015: PPUSH
13016: LD_INT 22
13018: PUSH
13019: LD_INT 1
13021: PUSH
13022: EMPTY
13023: LIST
13024: LIST
13025: PPUSH
13026: CALL_OW 70
13030: PUSH
13031: LD_EXP 42
13035: PPUSH
13036: CALL_OW 302
13040: AND
13041: PUSH
13042: LD_INT 22
13044: PUSH
13045: LD_INT 1
13047: PUSH
13048: EMPTY
13049: LIST
13050: LIST
13051: PPUSH
13052: CALL_OW 69
13056: PPUSH
13057: LD_EXP 42
13061: PPUSH
13062: CALL_OW 74
13066: PPUSH
13067: LD_EXP 42
13071: PPUSH
13072: CALL_OW 296
13076: PUSH
13077: LD_INT 30
13079: LESS
13080: OR
13081: IFFALSE 13132
13083: GO 13085
13085: DISABLE
// begin enable ;
13086: ENABLE
// powell_warn := powell_warn + 1 ;
13087: LD_ADDR_EXP 33
13091: PUSH
13092: LD_EXP 33
13096: PUSH
13097: LD_INT 1
13099: PLUS
13100: ST_TO_ADDR
// if powell_warn = 3 then
13101: LD_EXP 33
13105: PUSH
13106: LD_INT 3
13108: EQUAL
13109: IFFALSE 13120
// begin YouLost ( 5 ) ;
13111: LD_STRING 5
13113: PPUSH
13114: CALL_OW 104
// exit ;
13118: GO 13132
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
13120: LD_EXP 44
13124: PPUSH
13125: LD_STRING DWarn-Pow-1
13127: PPUSH
13128: CALL_OW 94
// end ; end_of_file
13132: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
13133: LD_EXP 8
13137: IFFALSE 14462
13139: GO 13141
13141: DISABLE
13142: LD_INT 0
13144: PPUSH
13145: PPUSH
13146: PPUSH
13147: PPUSH
13148: PPUSH
13149: PPUSH
13150: PPUSH
13151: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
13152: LD_EXP 42
13156: PUSH
13157: LD_EXP 43
13161: ADD
13162: PUSH
13163: LD_EXP 6
13167: ADD
13168: PPUSH
13169: LD_INT 250
13171: PPUSH
13172: LD_INT 120
13174: PPUSH
13175: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff [ Bierezov ] ;
13179: LD_ADDR_VAR 0 2
13183: PUSH
13184: LD_EXP 6
13188: PPUSH
13189: LD_INT 25
13191: PUSH
13192: LD_INT 2
13194: PUSH
13195: EMPTY
13196: LIST
13197: LIST
13198: PPUSH
13199: CALL_OW 72
13203: PUSH
13204: LD_EXP 43
13208: PUSH
13209: EMPTY
13210: LIST
13211: DIFF
13212: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) diff has_eng ;
13213: LD_ADDR_VAR 0 3
13217: PUSH
13218: LD_EXP 6
13222: PPUSH
13223: LD_INT 21
13225: PUSH
13226: LD_INT 1
13228: PUSH
13229: EMPTY
13230: LIST
13231: LIST
13232: PPUSH
13233: CALL_OW 72
13237: PUSH
13238: LD_VAR 0 2
13242: DIFF
13243: ST_TO_ADDR
// if not has_eng then
13244: LD_VAR 0 2
13248: NOT
13249: IFFALSE 13332
// begin uc_side := 4 ;
13251: LD_ADDR_OWVAR 20
13255: PUSH
13256: LD_INT 4
13258: ST_TO_ADDR
// uc_nation := 1 ;
13259: LD_ADDR_OWVAR 21
13263: PUSH
13264: LD_INT 1
13266: ST_TO_ADDR
// bc_type := b_depot ;
13267: LD_ADDR_OWVAR 42
13271: PUSH
13272: LD_INT 0
13274: ST_TO_ADDR
// bc_level := 2 ;
13275: LD_ADDR_OWVAR 43
13279: PUSH
13280: LD_INT 2
13282: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13283: LD_ADDR_VAR 0 4
13287: PUSH
13288: LD_INT 264
13290: PPUSH
13291: LD_INT 120
13293: PPUSH
13294: LD_INT 4
13296: PPUSH
13297: CALL_OW 47
13301: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13302: LD_INT 264
13304: PPUSH
13305: LD_INT 120
13307: PPUSH
13308: LD_INT 4
13310: PPUSH
13311: LD_INT 10
13313: NEG
13314: PPUSH
13315: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13319: LD_INT 264
13321: PPUSH
13322: LD_INT 120
13324: PPUSH
13325: LD_INT 4
13327: PPUSH
13328: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13332: LD_INT 35
13334: PPUSH
13335: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
13339: LD_EXP 42
13343: PPUSH
13344: LD_INT 10
13346: PPUSH
13347: CALL_OW 308
13351: IFFALSE 13332
// if has_eng and not dep then
13353: LD_VAR 0 2
13357: PUSH
13358: LD_VAR 0 4
13362: NOT
13363: AND
13364: IFFALSE 13514
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
13366: LD_VAR 0 2
13370: PPUSH
13371: LD_INT 0
13373: PPUSH
13374: LD_INT 264
13376: PPUSH
13377: LD_INT 120
13379: PPUSH
13380: LD_INT 4
13382: PPUSH
13383: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
13387: LD_INT 35
13389: PPUSH
13390: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
13394: LD_INT 22
13396: PUSH
13397: LD_INT 4
13399: PUSH
13400: EMPTY
13401: LIST
13402: LIST
13403: PUSH
13404: LD_INT 30
13406: PUSH
13407: LD_INT 0
13409: PUSH
13410: EMPTY
13411: LIST
13412: LIST
13413: PUSH
13414: EMPTY
13415: LIST
13416: LIST
13417: PPUSH
13418: CALL_OW 69
13422: IFFALSE 13387
// ComMoveXY ( filter , 264 , 120 ) ;
13424: LD_VAR 0 3
13428: PPUSH
13429: LD_INT 264
13431: PPUSH
13432: LD_INT 120
13434: PPUSH
13435: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
13439: LD_INT 35
13441: PPUSH
13442: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
13446: LD_INT 22
13448: PUSH
13449: LD_INT 4
13451: PUSH
13452: EMPTY
13453: LIST
13454: LIST
13455: PUSH
13456: LD_INT 30
13458: PUSH
13459: LD_INT 0
13461: PUSH
13462: EMPTY
13463: LIST
13464: LIST
13465: PUSH
13466: LD_INT 3
13468: PUSH
13469: LD_INT 57
13471: PUSH
13472: EMPTY
13473: LIST
13474: PUSH
13475: EMPTY
13476: LIST
13477: LIST
13478: PUSH
13479: EMPTY
13480: LIST
13481: LIST
13482: LIST
13483: PPUSH
13484: CALL_OW 69
13488: IFFALSE 13439
// ComMoveXY ( filter , 247 , 113 ) ;
13490: LD_VAR 0 3
13494: PPUSH
13495: LD_INT 247
13497: PPUSH
13498: LD_INT 113
13500: PPUSH
13501: CALL_OW 111
// Wait ( 0 0$2 ) ;
13505: LD_INT 70
13507: PPUSH
13508: CALL_OW 67
// end else
13512: GO 13526
// begin SetSide ( dep , 4 ) ;
13514: LD_VAR 0 4
13518: PPUSH
13519: LD_INT 4
13521: PPUSH
13522: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
13526: LD_ADDR_VAR 0 4
13530: PUSH
13531: LD_INT 22
13533: PUSH
13534: LD_INT 4
13536: PUSH
13537: EMPTY
13538: LIST
13539: LIST
13540: PUSH
13541: LD_INT 30
13543: PUSH
13544: LD_INT 0
13546: PUSH
13547: EMPTY
13548: LIST
13549: LIST
13550: PUSH
13551: EMPTY
13552: LIST
13553: LIST
13554: PPUSH
13555: CALL_OW 69
13559: PUSH
13560: LD_INT 1
13562: ARRAY
13563: ST_TO_ADDR
// for i = 1 to 2 do
13564: LD_ADDR_VAR 0 1
13568: PUSH
13569: DOUBLE
13570: LD_INT 1
13572: DEC
13573: ST_TO_ADDR
13574: LD_INT 2
13576: PUSH
13577: FOR_TO
13578: IFFALSE 13673
// begin ComEnterUnit ( filter [ 1 ] , dep ) ;
13580: LD_VAR 0 3
13584: PUSH
13585: LD_INT 1
13587: ARRAY
13588: PPUSH
13589: LD_VAR 0 4
13593: PPUSH
13594: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 2 ) ;
13598: LD_VAR 0 3
13602: PUSH
13603: LD_INT 1
13605: ARRAY
13606: PPUSH
13607: LD_INT 2
13609: PPUSH
13610: CALL_OW 183
// AddComExitBuilding ( filter [ 1 ] ) ;
13614: LD_VAR 0 3
13618: PUSH
13619: LD_INT 1
13621: ARRAY
13622: PPUSH
13623: CALL_OW 182
// repeat wait ( 0 0$1 ) ;
13627: LD_INT 35
13629: PPUSH
13630: CALL_OW 67
// until GetClass ( filter [ 1 ] ) = 2 ;
13634: LD_VAR 0 3
13638: PUSH
13639: LD_INT 1
13641: ARRAY
13642: PPUSH
13643: CALL_OW 257
13647: PUSH
13648: LD_INT 2
13650: EQUAL
13651: IFFALSE 13627
// filter := Delete ( filter , 1 ) ;
13653: LD_ADDR_VAR 0 3
13657: PUSH
13658: LD_VAR 0 3
13662: PPUSH
13663: LD_INT 1
13665: PPUSH
13666: CALL_OW 3
13670: ST_TO_ADDR
// end ;
13671: GO 13577
13673: POP
13674: POP
// if IsInUnit ( Cornel ) then
13675: LD_EXP 42
13679: PPUSH
13680: CALL_OW 310
13684: IFFALSE 13767
// begin cargo := IsInUnit ( Cornel ) ;
13686: LD_ADDR_VAR 0 7
13690: PUSH
13691: LD_EXP 42
13695: PPUSH
13696: CALL_OW 310
13700: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13701: LD_VAR 0 7
13705: PPUSH
13706: LD_INT 1
13708: PPUSH
13709: CALL_OW 289
13713: IFFALSE 13729
// ComGive ( Cornel , dep ) ;
13715: LD_EXP 42
13719: PPUSH
13720: LD_VAR 0 4
13724: PPUSH
13725: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13729: LD_EXP 42
13733: PPUSH
13734: LD_INT 235
13736: PPUSH
13737: LD_INT 122
13739: PPUSH
13740: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13744: LD_EXP 42
13748: PPUSH
13749: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13753: LD_EXP 42
13757: PPUSH
13758: LD_VAR 0 4
13762: PPUSH
13763: CALL_OW 180
// end ; if Bierezov then
13767: LD_EXP 43
13771: IFFALSE 13787
// ComEnterUnit ( Bierezov , dep ) ;
13773: LD_EXP 43
13777: PPUSH
13778: LD_VAR 0 4
13782: PPUSH
13783: CALL_OW 120
// has_eng := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) diff [ Bierezov ] ;
13787: LD_ADDR_VAR 0 2
13791: PUSH
13792: LD_INT 22
13794: PUSH
13795: LD_INT 4
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: PUSH
13802: LD_INT 25
13804: PUSH
13805: LD_INT 2
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 69
13820: PUSH
13821: LD_EXP 43
13825: PUSH
13826: EMPTY
13827: LIST
13828: DIFF
13829: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13830: LD_INT 35
13832: PPUSH
13833: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13837: LD_ADDR_VAR 0 6
13841: PUSH
13842: LD_INT 10
13844: PPUSH
13845: CALL_OW 435
13849: ST_TO_ADDR
// if crates then
13850: LD_VAR 0 6
13854: IFFALSE 13883
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
13856: LD_VAR 0 2
13860: PPUSH
13861: LD_VAR 0 6
13865: PUSH
13866: LD_INT 1
13868: ARRAY
13869: PPUSH
13870: LD_VAR 0 6
13874: PUSH
13875: LD_INT 2
13877: ARRAY
13878: PPUSH
13879: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
13883: LD_VAR 0 4
13887: PPUSH
13888: CALL_OW 274
13892: PPUSH
13893: LD_INT 1
13895: PPUSH
13896: CALL_OW 275
13900: PUSH
13901: LD_INT 40
13903: GREATEREQUAL
13904: IFFALSE 13830
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
13906: LD_ADDR_VAR 0 5
13910: PUSH
13911: LD_INT 4
13913: PUSH
13914: LD_INT 256
13916: PUSH
13917: LD_INT 111
13919: PUSH
13920: LD_INT 2
13922: PUSH
13923: EMPTY
13924: LIST
13925: LIST
13926: LIST
13927: LIST
13928: PUSH
13929: LD_INT 31
13931: PUSH
13932: LD_INT 243
13934: PUSH
13935: LD_INT 112
13937: PUSH
13938: LD_INT 2
13940: PUSH
13941: EMPTY
13942: LIST
13943: LIST
13944: LIST
13945: LIST
13946: PUSH
13947: EMPTY
13948: LIST
13949: LIST
13950: ST_TO_ADDR
// for i in blist do
13951: LD_ADDR_VAR 0 1
13955: PUSH
13956: LD_VAR 0 5
13960: PUSH
13961: FOR_IN
13962: IFFALSE 14011
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
13964: LD_VAR 0 2
13968: PPUSH
13969: LD_VAR 0 1
13973: PUSH
13974: LD_INT 1
13976: ARRAY
13977: PPUSH
13978: LD_VAR 0 1
13982: PUSH
13983: LD_INT 2
13985: ARRAY
13986: PPUSH
13987: LD_VAR 0 1
13991: PUSH
13992: LD_INT 3
13994: ARRAY
13995: PPUSH
13996: LD_VAR 0 1
14000: PUSH
14001: LD_INT 4
14003: ARRAY
14004: PPUSH
14005: CALL_OW 205
14009: GO 13961
14011: POP
14012: POP
// repeat wait ( 0 0$01 ) ;
14013: LD_INT 35
14015: PPUSH
14016: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
14020: LD_INT 22
14022: PUSH
14023: LD_INT 4
14025: PUSH
14026: EMPTY
14027: LIST
14028: LIST
14029: PUSH
14030: LD_INT 30
14032: PUSH
14033: LD_INT 4
14035: PUSH
14036: EMPTY
14037: LIST
14038: LIST
14039: PUSH
14040: LD_INT 3
14042: PUSH
14043: LD_INT 57
14045: PUSH
14046: EMPTY
14047: LIST
14048: PUSH
14049: EMPTY
14050: LIST
14051: LIST
14052: PUSH
14053: EMPTY
14054: LIST
14055: LIST
14056: LIST
14057: PPUSH
14058: CALL_OW 69
14062: IFFALSE 14013
// AddComEnterUnit ( filter , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14064: LD_VAR 0 3
14068: PPUSH
14069: LD_INT 22
14071: PUSH
14072: LD_INT 4
14074: PUSH
14075: EMPTY
14076: LIST
14077: LIST
14078: PUSH
14079: LD_INT 30
14081: PUSH
14082: LD_INT 4
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: PUSH
14089: EMPTY
14090: LIST
14091: LIST
14092: PPUSH
14093: CALL_OW 69
14097: PUSH
14098: LD_INT 1
14100: ARRAY
14101: PPUSH
14102: CALL_OW 180
// AddComChangeProfession ( filter , 1 ) ;
14106: LD_VAR 0 3
14110: PPUSH
14111: LD_INT 1
14113: PPUSH
14114: CALL_OW 183
// repeat wait ( 0 0$01 ) ;
14118: LD_INT 35
14120: PPUSH
14121: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
14125: LD_INT 22
14127: PUSH
14128: LD_INT 4
14130: PUSH
14131: EMPTY
14132: LIST
14133: LIST
14134: PUSH
14135: LD_INT 30
14137: PUSH
14138: LD_INT 31
14140: PUSH
14141: EMPTY
14142: LIST
14143: LIST
14144: PUSH
14145: LD_INT 3
14147: PUSH
14148: LD_INT 57
14150: PUSH
14151: EMPTY
14152: LIST
14153: PUSH
14154: EMPTY
14155: LIST
14156: LIST
14157: PUSH
14158: EMPTY
14159: LIST
14160: LIST
14161: LIST
14162: PPUSH
14163: CALL_OW 69
14167: IFFALSE 14118
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
14169: LD_ADDR_VAR 0 8
14173: PUSH
14174: LD_EXP 6
14178: PPUSH
14179: LD_INT 25
14181: PUSH
14182: LD_INT 1
14184: PUSH
14185: EMPTY
14186: LIST
14187: LIST
14188: PPUSH
14189: CALL_OW 72
14193: ST_TO_ADDR
// ComExitBuilding ( sol [ 1 ] ) ;
14194: LD_VAR 0 8
14198: PUSH
14199: LD_INT 1
14201: ARRAY
14202: PPUSH
14203: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
14207: LD_VAR 0 8
14211: PUSH
14212: LD_INT 1
14214: ARRAY
14215: PPUSH
14216: LD_INT 22
14218: PUSH
14219: LD_INT 4
14221: PUSH
14222: EMPTY
14223: LIST
14224: LIST
14225: PUSH
14226: LD_INT 30
14228: PUSH
14229: LD_INT 31
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: PUSH
14236: EMPTY
14237: LIST
14238: LIST
14239: PPUSH
14240: CALL_OW 69
14244: PUSH
14245: LD_INT 1
14247: ARRAY
14248: PPUSH
14249: CALL_OW 180
// ComEnterUnit ( has_eng , dep ) ;
14253: LD_VAR 0 2
14257: PPUSH
14258: LD_VAR 0 4
14262: PPUSH
14263: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
14267: LD_INT 35
14269: PPUSH
14270: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14274: LD_ADDR_VAR 0 3
14278: PUSH
14279: LD_INT 22
14281: PUSH
14282: LD_INT 4
14284: PUSH
14285: EMPTY
14286: LIST
14287: LIST
14288: PUSH
14289: LD_INT 21
14291: PUSH
14292: LD_INT 3
14294: PUSH
14295: EMPTY
14296: LIST
14297: LIST
14298: PUSH
14299: LD_INT 3
14301: PUSH
14302: LD_INT 24
14304: PUSH
14305: LD_INT 1000
14307: PUSH
14308: EMPTY
14309: LIST
14310: LIST
14311: PUSH
14312: EMPTY
14313: LIST
14314: LIST
14315: PUSH
14316: EMPTY
14317: LIST
14318: LIST
14319: LIST
14320: PPUSH
14321: CALL_OW 69
14325: ST_TO_ADDR
// if filter and has_eng then
14326: LD_VAR 0 3
14330: PUSH
14331: LD_VAR 0 2
14335: AND
14336: IFFALSE 14402
// begin for i in has_eng do
14338: LD_ADDR_VAR 0 1
14342: PUSH
14343: LD_VAR 0 2
14347: PUSH
14348: FOR_IN
14349: IFFALSE 14398
// begin if IsInUnit ( i ) then
14351: LD_VAR 0 1
14355: PPUSH
14356: CALL_OW 310
14360: IFFALSE 14371
// ComExitBuilding ( i ) ;
14362: LD_VAR 0 1
14366: PPUSH
14367: CALL_OW 122
// Wait ( 3 ) ;
14371: LD_INT 3
14373: PPUSH
14374: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
14378: LD_VAR 0 1
14382: PPUSH
14383: LD_VAR 0 3
14387: PUSH
14388: LD_INT 1
14390: ARRAY
14391: PPUSH
14392: CALL_OW 130
// end ;
14396: GO 14348
14398: POP
14399: POP
// end else
14400: GO 14456
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
14402: LD_VAR 0 2
14406: PUSH
14407: LD_VAR 0 2
14411: PPUSH
14412: LD_INT 56
14414: PUSH
14415: EMPTY
14416: LIST
14417: PPUSH
14418: CALL_OW 72
14422: AND
14423: IFFALSE 14456
// for i in has_eng do
14425: LD_ADDR_VAR 0 1
14429: PUSH
14430: LD_VAR 0 2
14434: PUSH
14435: FOR_IN
14436: IFFALSE 14454
// ComEnterUnit ( i , dep ) ;
14438: LD_VAR 0 1
14442: PPUSH
14443: LD_VAR 0 4
14447: PPUSH
14448: CALL_OW 120
14452: GO 14435
14454: POP
14455: POP
// until cornel_prepared ;
14456: LD_EXP 11
14460: IFFALSE 14267
// end ;
14462: PPOPN 8
14464: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
14465: LD_EXP 11
14469: IFFALSE 14818
14471: GO 14473
14473: DISABLE
14474: LD_INT 0
14476: PPUSH
14477: PPUSH
14478: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
14479: LD_ADDR_VAR 0 2
14483: PUSH
14484: LD_INT 22
14486: PUSH
14487: LD_INT 4
14489: PUSH
14490: EMPTY
14491: LIST
14492: LIST
14493: PUSH
14494: LD_INT 30
14496: PUSH
14497: LD_INT 4
14499: PUSH
14500: EMPTY
14501: LIST
14502: LIST
14503: PUSH
14504: EMPTY
14505: LIST
14506: LIST
14507: PPUSH
14508: CALL_OW 69
14512: PUSH
14513: LD_INT 1
14515: ARRAY
14516: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
14517: LD_EXP 6
14521: PPUSH
14522: CALL_OW 122
// Wait ( 0 0$03 ) ;
14526: LD_INT 105
14528: PPUSH
14529: CALL_OW 67
// for i in cornel_units do
14533: LD_ADDR_VAR 0 1
14537: PUSH
14538: LD_EXP 6
14542: PUSH
14543: FOR_IN
14544: IFFALSE 14620
// begin if GetClass ( i ) in [ 2 , 3 ] then
14546: LD_VAR 0 1
14550: PPUSH
14551: CALL_OW 257
14555: PUSH
14556: LD_INT 2
14558: PUSH
14559: LD_INT 3
14561: PUSH
14562: EMPTY
14563: LIST
14564: LIST
14565: IN
14566: IFFALSE 14603
// begin ComEnterUnit ( i , arm ) ;
14568: LD_VAR 0 1
14572: PPUSH
14573: LD_VAR 0 2
14577: PPUSH
14578: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
14582: LD_VAR 0 1
14586: PPUSH
14587: LD_INT 1
14589: PPUSH
14590: CALL_OW 183
// AddComExitBuilding ( i ) ;
14594: LD_VAR 0 1
14598: PPUSH
14599: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
14603: LD_VAR 0 1
14607: PPUSH
14608: LD_INT 257
14610: PPUSH
14611: LD_INT 121
14613: PPUSH
14614: CALL_OW 171
// end ;
14618: GO 14543
14620: POP
14621: POP
// Wait ( 1 1$00 ) ;
14622: LD_INT 2100
14624: PPUSH
14625: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
14629: LD_ADDR_VAR 0 3
14633: PUSH
14634: LD_EXP 42
14638: PUSH
14639: LD_EXP 43
14643: ADD
14644: PUSH
14645: LD_EXP 6
14649: ADD
14650: PUSH
14651: LD_EXP 6
14655: PPUSH
14656: LD_INT 21
14658: PUSH
14659: LD_INT 2
14661: PUSH
14662: EMPTY
14663: LIST
14664: LIST
14665: PPUSH
14666: CALL_OW 72
14670: DIFF
14671: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
14672: LD_VAR 0 3
14676: PPUSH
14677: LD_INT 248
14679: PPUSH
14680: LD_INT 85
14682: PPUSH
14683: CALL_OW 111
// AddComHold ( filter ) ;
14687: LD_VAR 0 3
14691: PPUSH
14692: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
14696: LD_INT 35
14698: PPUSH
14699: CALL_OW 67
// until cornel_attack ;
14703: LD_EXP 9
14707: IFFALSE 14696
// ComAgressiveMove ( filter , 209 , 63 ) ;
14709: LD_VAR 0 3
14713: PPUSH
14714: LD_INT 209
14716: PPUSH
14717: LD_INT 63
14719: PPUSH
14720: CALL_OW 114
// if Bierezov then
14724: LD_EXP 43
14728: IFFALSE 14818
// begin filter := filter diff Bierezov ;
14730: LD_ADDR_VAR 0 3
14734: PUSH
14735: LD_VAR 0 3
14739: PUSH
14740: LD_EXP 43
14744: DIFF
14745: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
14746: LD_EXP 43
14750: PPUSH
14751: LD_INT 6
14753: PPUSH
14754: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
14758: LD_EXP 43
14762: PPUSH
14763: LD_INT 235
14765: PPUSH
14766: LD_INT 60
14768: PPUSH
14769: CALL_OW 111
// AddComHold ( Bierezov ) ;
14773: LD_EXP 43
14777: PPUSH
14778: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
14782: LD_EXP 43
14786: PPUSH
14787: LD_INT 350
14789: PPUSH
14790: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
14794: LD_EXP 43
14798: PPUSH
14799: LD_INT 198
14801: PPUSH
14802: LD_INT 28
14804: PPUSH
14805: CALL_OW 171
// AddComHold ( Bierezov ) ;
14809: LD_EXP 43
14813: PPUSH
14814: CALL_OW 200
// end ; end ; end_of_file
14818: PPOPN 3
14820: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
14821: LD_EXP 51
14825: PUSH
14826: LD_EXP 29
14830: NOT
14831: AND
14832: PUSH
14833: LD_EXP 30
14837: NOT
14838: AND
14839: IFFALSE 15289
14841: GO 14843
14843: DISABLE
14844: LD_INT 0
14846: PPUSH
14847: PPUSH
14848: PPUSH
14849: PPUSH
// begin enable ;
14850: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14851: LD_ADDR_VAR 0 4
14855: PUSH
14856: LD_INT 81
14858: PUSH
14859: LD_INT 3
14861: PUSH
14862: EMPTY
14863: LIST
14864: LIST
14865: PPUSH
14866: CALL_OW 69
14870: ST_TO_ADDR
// for i = 1 to ru_patrol do
14871: LD_ADDR_VAR 0 2
14875: PUSH
14876: DOUBLE
14877: LD_INT 1
14879: DEC
14880: ST_TO_ADDR
14881: LD_EXP 51
14885: PUSH
14886: FOR_TO
14887: IFFALSE 15287
// begin un := ru_patrol [ i ] ;
14889: LD_ADDR_VAR 0 1
14893: PUSH
14894: LD_EXP 51
14898: PUSH
14899: LD_VAR 0 2
14903: ARRAY
14904: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14905: LD_VAR 0 1
14909: PPUSH
14910: LD_INT 13
14912: PPUSH
14913: CALL_OW 308
14917: IFFALSE 15022
// begin if not ru_alert then
14919: LD_EXP 58
14923: NOT
14924: IFFALSE 14934
// ru_alert := true ;
14926: LD_ADDR_EXP 58
14930: PUSH
14931: LD_INT 1
14933: ST_TO_ADDR
// if not See ( 1 , un ) then
14934: LD_INT 1
14936: PPUSH
14937: LD_VAR 0 1
14941: PPUSH
14942: CALL_OW 292
14946: NOT
14947: IFFALSE 14961
// SetLives ( un , 1000 ) ;
14949: LD_VAR 0 1
14953: PPUSH
14954: LD_INT 1000
14956: PPUSH
14957: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
14961: LD_ADDR_EXP 51
14965: PUSH
14966: LD_EXP 51
14970: PUSH
14971: LD_VAR 0 1
14975: DIFF
14976: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
14977: LD_VAR 0 1
14981: PPUSH
14982: LD_INT 22
14984: PUSH
14985: LD_INT 3
14987: PUSH
14988: EMPTY
14989: LIST
14990: LIST
14991: PUSH
14992: LD_INT 30
14994: PUSH
14995: LD_INT 4
14997: PUSH
14998: EMPTY
14999: LIST
15000: LIST
15001: PUSH
15002: EMPTY
15003: LIST
15004: LIST
15005: PPUSH
15006: CALL_OW 69
15010: PPUSH
15011: CALL 1039 0 1
15015: PPUSH
15016: CALL_OW 120
// continue ;
15020: GO 14886
// end ; if IsOk ( un ) and not HasTask ( un ) then
15022: LD_VAR 0 1
15026: PPUSH
15027: CALL_OW 302
15031: PUSH
15032: LD_VAR 0 1
15036: PPUSH
15037: CALL_OW 314
15041: NOT
15042: AND
15043: IFFALSE 15136
// begin for j = 1 to ru_firepoints_south [ i ] do
15045: LD_ADDR_VAR 0 3
15049: PUSH
15050: DOUBLE
15051: LD_INT 1
15053: DEC
15054: ST_TO_ADDR
15055: LD_EXP 57
15059: PUSH
15060: LD_VAR 0 2
15064: ARRAY
15065: PUSH
15066: FOR_TO
15067: IFFALSE 15134
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
15069: LD_VAR 0 1
15073: PPUSH
15074: LD_EXP 57
15078: PUSH
15079: LD_VAR 0 2
15083: ARRAY
15084: PUSH
15085: LD_VAR 0 3
15089: ARRAY
15090: PUSH
15091: LD_INT 1
15093: ARRAY
15094: PPUSH
15095: LD_EXP 57
15099: PUSH
15100: LD_VAR 0 2
15104: ARRAY
15105: PUSH
15106: LD_VAR 0 3
15110: ARRAY
15111: PUSH
15112: LD_INT 2
15114: ARRAY
15115: PPUSH
15116: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
15120: LD_VAR 0 1
15124: PPUSH
15125: LD_INT 70
15127: PPUSH
15128: CALL_OW 202
// end ;
15132: GO 15066
15134: POP
15135: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15136: LD_VAR 0 1
15140: PPUSH
15141: CALL_OW 256
15145: PUSH
15146: LD_INT 700
15148: LESS
15149: PUSH
15150: LD_VAR 0 1
15154: PPUSH
15155: LD_INT 13
15157: PPUSH
15158: CALL_OW 308
15162: NOT
15163: AND
15164: IFFALSE 15216
// begin ComMoveToArea ( un , retreatArea ) ;
15166: LD_VAR 0 1
15170: PPUSH
15171: LD_INT 13
15173: PPUSH
15174: CALL_OW 113
// if not ru_alert_xy then
15178: LD_EXP 59
15182: NOT
15183: IFFALSE 15214
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
15185: LD_ADDR_EXP 59
15189: PUSH
15190: LD_VAR 0 1
15194: PPUSH
15195: CALL_OW 250
15199: PUSH
15200: LD_VAR 0 1
15204: PPUSH
15205: CALL_OW 251
15209: PUSH
15210: EMPTY
15211: LIST
15212: LIST
15213: ST_TO_ADDR
// end else
15214: GO 15285
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15216: LD_VAR 0 1
15220: PPUSH
15221: LD_VAR 0 4
15225: PPUSH
15226: LD_VAR 0 1
15230: PPUSH
15231: CALL_OW 74
15235: PPUSH
15236: CALL_OW 296
15240: PUSH
15241: LD_INT 9
15243: LESS
15244: PUSH
15245: LD_VAR 0 1
15249: PPUSH
15250: CALL_OW 256
15254: PUSH
15255: LD_INT 500
15257: GREATER
15258: AND
15259: IFFALSE 15285
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15261: LD_VAR 0 1
15265: PPUSH
15266: LD_VAR 0 4
15270: PPUSH
15271: LD_VAR 0 1
15275: PPUSH
15276: CALL_OW 74
15280: PPUSH
15281: CALL_OW 115
// end ;
15285: GO 14886
15287: POP
15288: POP
// end ;
15289: PPOPN 4
15291: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
15292: LD_EXP 58
15296: PUSH
15297: LD_EXP 59
15301: AND
15302: PUSH
15303: LD_EXP 29
15307: NOT
15308: AND
15309: PUSH
15310: LD_EXP 30
15314: NOT
15315: AND
15316: IFFALSE 15526
15318: GO 15320
15320: DISABLE
15321: LD_INT 0
15323: PPUSH
15324: PPUSH
// begin enable ;
15325: ENABLE
// if not ru_vehicles then
15326: LD_EXP 54
15330: NOT
15331: IFFALSE 15335
// exit ;
15333: GO 15526
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15335: LD_ADDR_VAR 0 2
15339: PUSH
15340: LD_INT 81
15342: PUSH
15343: LD_INT 3
15345: PUSH
15346: EMPTY
15347: LIST
15348: LIST
15349: PPUSH
15350: CALL_OW 69
15354: ST_TO_ADDR
// if ru_vehicles then
15355: LD_EXP 54
15359: IFFALSE 15526
// begin for i in ru_vehicles do
15361: LD_ADDR_VAR 0 1
15365: PUSH
15366: LD_EXP 54
15370: PUSH
15371: FOR_IN
15372: IFFALSE 15524
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
15374: LD_VAR 0 1
15378: PPUSH
15379: CALL_OW 302
15383: PUSH
15384: LD_VAR 0 1
15388: PPUSH
15389: LD_VAR 0 2
15393: PPUSH
15394: LD_VAR 0 1
15398: PPUSH
15399: CALL_OW 74
15403: PPUSH
15404: CALL_OW 296
15408: PUSH
15409: LD_INT 9
15411: LESS
15412: AND
15413: IFFALSE 15439
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15415: LD_VAR 0 1
15419: PPUSH
15420: LD_VAR 0 2
15424: PPUSH
15425: LD_VAR 0 1
15429: PPUSH
15430: CALL_OW 74
15434: PPUSH
15435: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
15439: LD_VAR 0 1
15443: PPUSH
15444: CALL_OW 314
15448: NOT
15449: PUSH
15450: LD_VAR 0 1
15454: PPUSH
15455: CALL_OW 302
15459: AND
15460: PUSH
15461: LD_VAR 0 1
15465: PPUSH
15466: LD_EXP 59
15470: PUSH
15471: LD_INT 1
15473: ARRAY
15474: PPUSH
15475: LD_EXP 59
15479: PUSH
15480: LD_INT 2
15482: ARRAY
15483: PPUSH
15484: CALL_OW 297
15488: PUSH
15489: LD_INT 10
15491: GREATER
15492: AND
15493: IFFALSE 15522
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
15495: LD_VAR 0 1
15499: PPUSH
15500: LD_EXP 59
15504: PUSH
15505: LD_INT 1
15507: ARRAY
15508: PPUSH
15509: LD_EXP 59
15513: PUSH
15514: LD_INT 2
15516: ARRAY
15517: PPUSH
15518: CALL_OW 114
// end ;
15522: GO 15371
15524: POP
15525: POP
// end ; end ;
15526: PPOPN 2
15528: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
15529: LD_EXP 59
15533: PUSH
15534: LD_EXP 58
15538: AND
15539: PUSH
15540: LD_INT 3
15542: PPUSH
15543: CALL_OW 463
15547: NOT
15548: AND
15549: PUSH
15550: LD_EXP 29
15554: NOT
15555: AND
15556: PUSH
15557: LD_EXP 30
15561: NOT
15562: AND
15563: IFFALSE 15658
15565: GO 15567
15567: DISABLE
15568: LD_INT 0
15570: PPUSH
// begin enable ;
15571: ENABLE
// ru_alert_xy := false ;
15572: LD_ADDR_EXP 59
15576: PUSH
15577: LD_INT 0
15579: ST_TO_ADDR
// ru_alert := false ;
15580: LD_ADDR_EXP 58
15584: PUSH
15585: LD_INT 0
15587: ST_TO_ADDR
// if ru_vehicles then
15588: LD_EXP 54
15592: IFFALSE 15658
// for i in ru_vehicles do
15594: LD_ADDR_VAR 0 1
15598: PUSH
15599: LD_EXP 54
15603: PUSH
15604: FOR_IN
15605: IFFALSE 15656
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
15607: LD_VAR 0 1
15611: PPUSH
15612: CALL_OW 302
15616: PUSH
15617: LD_VAR 0 1
15621: PPUSH
15622: LD_INT 89
15624: PPUSH
15625: LD_INT 36
15627: PPUSH
15628: CALL_OW 297
15632: PUSH
15633: LD_INT 10
15635: GREATER
15636: AND
15637: IFFALSE 15654
// ComMoveXY ( i , 89 , 36 ) ;
15639: LD_VAR 0 1
15643: PPUSH
15644: LD_INT 89
15646: PPUSH
15647: LD_INT 36
15649: PPUSH
15650: CALL_OW 111
15654: GO 15604
15656: POP
15657: POP
// end ;
15658: PPOPN 1
15660: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
15661: LD_EXP 53
15665: PUSH
15666: LD_EXP 29
15670: NOT
15671: AND
15672: PUSH
15673: LD_EXP 30
15677: NOT
15678: AND
15679: IFFALSE 15963
15681: GO 15683
15683: DISABLE
15684: LD_INT 0
15686: PPUSH
15687: PPUSH
15688: PPUSH
// begin enable ;
15689: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15690: LD_ADDR_VAR 0 3
15694: PUSH
15695: LD_INT 81
15697: PUSH
15698: LD_INT 3
15700: PUSH
15701: EMPTY
15702: LIST
15703: LIST
15704: PPUSH
15705: CALL_OW 69
15709: ST_TO_ADDR
// for i = 1 to ru_forest do
15710: LD_ADDR_VAR 0 1
15714: PUSH
15715: DOUBLE
15716: LD_INT 1
15718: DEC
15719: ST_TO_ADDR
15720: LD_EXP 53
15724: PUSH
15725: FOR_TO
15726: IFFALSE 15961
// begin un := ru_forest [ i ] ;
15728: LD_ADDR_VAR 0 2
15732: PUSH
15733: LD_EXP 53
15737: PUSH
15738: LD_VAR 0 1
15742: ARRAY
15743: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15744: LD_VAR 0 2
15748: PPUSH
15749: LD_INT 13
15751: PPUSH
15752: CALL_OW 308
15756: IFFALSE 15846
// begin if not See ( 1 , un ) then
15758: LD_INT 1
15760: PPUSH
15761: LD_VAR 0 2
15765: PPUSH
15766: CALL_OW 292
15770: NOT
15771: IFFALSE 15785
// SetLives ( un , 1000 ) ;
15773: LD_VAR 0 2
15777: PPUSH
15778: LD_INT 1000
15780: PPUSH
15781: CALL_OW 234
// ru_forest := ru_forest diff un ;
15785: LD_ADDR_EXP 53
15789: PUSH
15790: LD_EXP 53
15794: PUSH
15795: LD_VAR 0 2
15799: DIFF
15800: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15801: LD_VAR 0 2
15805: PPUSH
15806: LD_INT 22
15808: PUSH
15809: LD_INT 3
15811: PUSH
15812: EMPTY
15813: LIST
15814: LIST
15815: PUSH
15816: LD_INT 30
15818: PUSH
15819: LD_INT 4
15821: PUSH
15822: EMPTY
15823: LIST
15824: LIST
15825: PUSH
15826: EMPTY
15827: LIST
15828: LIST
15829: PPUSH
15830: CALL_OW 69
15834: PPUSH
15835: CALL 1039 0 1
15839: PPUSH
15840: CALL_OW 120
// continue ;
15844: GO 15725
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15846: LD_VAR 0 2
15850: PPUSH
15851: CALL_OW 256
15855: PUSH
15856: LD_INT 700
15858: LESS
15859: PUSH
15860: LD_VAR 0 2
15864: PPUSH
15865: LD_INT 13
15867: PPUSH
15868: CALL_OW 308
15872: NOT
15873: AND
15874: IFFALSE 15890
// ComMoveToArea ( un , retreatArea ) else
15876: LD_VAR 0 2
15880: PPUSH
15881: LD_INT 13
15883: PPUSH
15884: CALL_OW 113
15888: GO 15959
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15890: LD_VAR 0 2
15894: PPUSH
15895: LD_VAR 0 3
15899: PPUSH
15900: LD_VAR 0 2
15904: PPUSH
15905: CALL_OW 74
15909: PPUSH
15910: CALL_OW 296
15914: PUSH
15915: LD_INT 9
15917: LESS
15918: PUSH
15919: LD_VAR 0 2
15923: PPUSH
15924: CALL_OW 256
15928: PUSH
15929: LD_INT 500
15931: GREATER
15932: AND
15933: IFFALSE 15959
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15935: LD_VAR 0 2
15939: PPUSH
15940: LD_VAR 0 3
15944: PPUSH
15945: LD_VAR 0 2
15949: PPUSH
15950: CALL_OW 74
15954: PPUSH
15955: CALL_OW 115
// end ;
15959: GO 15725
15961: POP
15962: POP
// end ;
15963: PPOPN 3
15965: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
15966: LD_EXP 30
15970: NOT
15971: IFFALSE 16092
15973: GO 15975
15975: DISABLE
15976: LD_INT 0
15978: PPUSH
15979: PPUSH
// begin enable ;
15980: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
15981: LD_ADDR_VAR 0 2
15985: PUSH
15986: LD_INT 22
15988: PUSH
15989: LD_INT 3
15991: PUSH
15992: EMPTY
15993: LIST
15994: LIST
15995: PUSH
15996: LD_INT 21
15998: PUSH
15999: LD_INT 3
16001: PUSH
16002: EMPTY
16003: LIST
16004: LIST
16005: PUSH
16006: EMPTY
16007: LIST
16008: LIST
16009: PPUSH
16010: CALL_OW 69
16014: ST_TO_ADDR
// if filter then
16015: LD_VAR 0 2
16019: IFFALSE 16092
// for i in filter do
16021: LD_ADDR_VAR 0 1
16025: PUSH
16026: LD_VAR 0 2
16030: PUSH
16031: FOR_IN
16032: IFFALSE 16090
// if GetLives ( i ) < 990 then
16034: LD_VAR 0 1
16038: PPUSH
16039: CALL_OW 256
16043: PUSH
16044: LD_INT 990
16046: LESS
16047: IFFALSE 16088
// begin ru_alert := true ;
16049: LD_ADDR_EXP 58
16053: PUSH
16054: LD_INT 1
16056: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
16057: LD_ADDR_EXP 59
16061: PUSH
16062: LD_VAR 0 1
16066: PPUSH
16067: CALL_OW 250
16071: PUSH
16072: LD_VAR 0 1
16076: PPUSH
16077: CALL_OW 251
16081: PUSH
16082: EMPTY
16083: LIST
16084: LIST
16085: ST_TO_ADDR
// break ;
16086: GO 16090
// end ;
16088: GO 16031
16090: POP
16091: POP
// end ;
16092: PPOPN 2
16094: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
16095: LD_EXP 29
16099: IFFALSE 16248
16101: GO 16103
16103: DISABLE
16104: LD_INT 0
16106: PPUSH
16107: PPUSH
16108: PPUSH
16109: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
16110: LD_ADDR_VAR 0 4
16114: PUSH
16115: LD_EXP 54
16119: PUSH
16120: LD_EXP 53
16124: ADD
16125: PUSH
16126: LD_EXP 51
16130: ADD
16131: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
16132: LD_ADDR_VAR 0 3
16136: PUSH
16137: LD_INT 3
16139: PPUSH
16140: LD_INT 81
16142: PUSH
16143: LD_INT 3
16145: PUSH
16146: EMPTY
16147: LIST
16148: LIST
16149: PPUSH
16150: CALL_OW 70
16154: ST_TO_ADDR
// if filter and enemy then
16155: LD_VAR 0 4
16159: PUSH
16160: LD_VAR 0 3
16164: AND
16165: IFFALSE 16248
// repeat wait ( 0 0$01 ) ;
16167: LD_INT 35
16169: PPUSH
16170: CALL_OW 67
// for i in filter do
16174: LD_ADDR_VAR 0 1
16178: PUSH
16179: LD_VAR 0 4
16183: PUSH
16184: FOR_IN
16185: IFFALSE 16213
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16187: LD_VAR 0 1
16191: PPUSH
16192: LD_VAR 0 3
16196: PPUSH
16197: LD_VAR 0 1
16201: PPUSH
16202: CALL_OW 74
16206: PPUSH
16207: CALL_OW 115
// end ;
16211: GO 16184
16213: POP
16214: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
16215: LD_INT 3
16217: PPUSH
16218: LD_INT 81
16220: PUSH
16221: LD_INT 3
16223: PUSH
16224: EMPTY
16225: LIST
16226: LIST
16227: PPUSH
16228: CALL_OW 70
16232: PUSH
16233: LD_INT 0
16235: EQUAL
16236: PUSH
16237: LD_VAR 0 4
16241: PUSH
16242: LD_INT 0
16244: EQUAL
16245: OR
16246: IFFALSE 16167
// end ;
16248: PPOPN 4
16250: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) do var i ;
16251: LD_EXP 25
16255: PUSH
16256: LD_INT 22
16258: PUSH
16259: LD_INT 4
16261: PUSH
16262: EMPTY
16263: LIST
16264: LIST
16265: PUSH
16266: LD_INT 30
16268: PUSH
16269: LD_INT 4
16271: PUSH
16272: EMPTY
16273: LIST
16274: LIST
16275: PUSH
16276: LD_INT 3
16278: PUSH
16279: LD_INT 57
16281: PUSH
16282: EMPTY
16283: LIST
16284: PUSH
16285: EMPTY
16286: LIST
16287: LIST
16288: PUSH
16289: EMPTY
16290: LIST
16291: LIST
16292: LIST
16293: PPUSH
16294: CALL_OW 69
16298: AND
16299: IFFALSE 16348
16301: GO 16303
16303: DISABLE
16304: LD_INT 0
16306: PPUSH
// begin if not ru_cornel_attack then
16307: LD_EXP 56
16311: NOT
16312: IFFALSE 16316
// exit ;
16314: GO 16348
// for i in ru_cornel_attack do
16316: LD_ADDR_VAR 0 1
16320: PUSH
16321: LD_EXP 56
16325: PUSH
16326: FOR_IN
16327: IFFALSE 16346
// ComAgressiveMove ( i , 258 , 119 ) ;
16329: LD_VAR 0 1
16333: PPUSH
16334: LD_INT 258
16336: PPUSH
16337: LD_INT 119
16339: PPUSH
16340: CALL_OW 114
16344: GO 16326
16346: POP
16347: POP
// end ; end_of_file
16348: PPOPN 1
16350: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
16351: LD_EXP 5
16355: PUSH
16356: LD_EXP 9
16360: NOT
16361: AND
16362: PUSH
16363: LD_EXP 19
16367: AND
16368: IFFALSE 16480
16370: GO 16372
16372: DISABLE
16373: LD_INT 0
16375: PPUSH
// begin enable ;
16376: ENABLE
// crates_counter := crates_counter - 50 ;
16377: LD_ADDR_EXP 19
16381: PUSH
16382: LD_EXP 19
16386: PUSH
16387: LD_INT 50
16389: MINUS
16390: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
16391: LD_INT 8
16393: PPUSH
16394: LD_INT 2
16396: PPUSH
16397: LD_INT 5
16399: PPUSH
16400: CALL_OW 12
16404: PPUSH
16405: LD_INT 1
16407: PPUSH
16408: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
16412: LD_INT 1785
16414: PPUSH
16415: LD_INT 2345
16417: PPUSH
16418: CALL_OW 12
16422: PPUSH
16423: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
16427: LD_ADDR_VAR 0 1
16431: PUSH
16432: LD_INT 1
16434: PPUSH
16435: LD_OWVAR 67
16439: PUSH
16440: LD_INT 2
16442: PLUS
16443: PPUSH
16444: CALL_OW 12
16448: ST_TO_ADDR
// if r < 3 then
16449: LD_VAR 0 1
16453: PUSH
16454: LD_INT 3
16456: LESS
16457: IFFALSE 16480
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
16459: LD_INT 4
16461: PPUSH
16462: LD_INT 1
16464: PPUSH
16465: LD_INT 5
16467: PPUSH
16468: CALL_OW 12
16472: PPUSH
16473: LD_INT 1
16475: PPUSH
16476: CALL_OW 55
// end ;
16480: PPOPN 1
16482: END
// every 0 0$01 trigger cornel_active do
16483: LD_EXP 8
16487: IFFALSE 16576
16489: GO 16491
16491: DISABLE
// begin Wait ( 0 0$03 ) ;
16492: LD_INT 105
16494: PPUSH
16495: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16499: LD_INT 2
16501: PPUSH
16502: LD_INT 5
16504: PPUSH
16505: CALL_OW 12
16509: PPUSH
16510: LD_INT 10
16512: PPUSH
16513: LD_INT 1
16515: PPUSH
16516: CALL_OW 55
// Wait ( 0 0$13 ) ;
16520: LD_INT 455
16522: PPUSH
16523: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16527: LD_INT 2
16529: PPUSH
16530: LD_INT 5
16532: PPUSH
16533: CALL_OW 12
16537: PPUSH
16538: LD_INT 10
16540: PPUSH
16541: LD_INT 1
16543: PPUSH
16544: CALL_OW 55
// Wait ( 0 0$16 ) ;
16548: LD_INT 560
16550: PPUSH
16551: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16555: LD_INT 2
16557: PPUSH
16558: LD_INT 5
16560: PPUSH
16561: CALL_OW 12
16565: PPUSH
16566: LD_INT 10
16568: PPUSH
16569: LD_INT 1
16571: PPUSH
16572: CALL_OW 55
// end ; end_of_file
16576: END
// every 0 0$01 trigger cornel_prepared do
16577: LD_EXP 11
16581: IFFALSE 16640
16583: GO 16585
16585: DISABLE
// begin enable ;
16586: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
16587: LD_ADDR_OWVAR 47
16591: PUSH
16592: LD_STRING #Am03-1
16594: PUSH
16595: LD_EXP 10
16599: PUSH
16600: EMPTY
16601: LIST
16602: LIST
16603: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
16604: LD_ADDR_EXP 10
16608: PUSH
16609: LD_EXP 10
16613: PPUSH
16614: LD_STRING -
16616: PPUSH
16617: CALL 1109 0 2
16621: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
16622: LD_EXP 10
16626: PUSH
16627: LD_INT 0
16629: EQUAL
16630: IFFALSE 16640
// begin Display_Strings := [ ] ;
16632: LD_ADDR_OWVAR 47
16636: PUSH
16637: EMPTY
16638: ST_TO_ADDR
// disable ;
16639: DISABLE
// end ; end ;
16640: END
// every 0 0$01 trigger debug and debug_strings do
16641: LD_EXP 1
16645: PUSH
16646: LD_OWVAR 48
16650: AND
16651: IFFALSE 16667
16653: GO 16655
16655: DISABLE
// begin enable ;
16656: ENABLE
// Display_Strings := debug_strings ;
16657: LD_ADDR_OWVAR 47
16661: PUSH
16662: LD_OWVAR 48
16666: ST_TO_ADDR
// end ; end_of_file
16667: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
16668: LD_VAR 0 1
16672: PPUSH
16673: CALL_OW 255
16677: PUSH
16678: LD_INT 1
16680: EQUAL
16681: PUSH
16682: LD_EXP 13
16686: NOT
16687: AND
16688: IFFALSE 16698
// solar_builded := true ;
16690: LD_ADDR_EXP 13
16694: PUSH
16695: LD_INT 1
16697: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
16698: LD_VAR 0 1
16702: PPUSH
16703: CALL_OW 255
16707: PUSH
16708: LD_INT 1
16710: EQUAL
16711: PUSH
16712: LD_EXP 27
16716: AND
16717: IFFALSE 16750
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
16719: LD_ADDR_EXP 27
16723: PUSH
16724: LD_EXP 27
16728: PUSH
16729: LD_INT 1750
16731: PUSH
16732: LD_INT 1400
16734: PUSH
16735: LD_INT 1225
16737: PUSH
16738: EMPTY
16739: LIST
16740: LIST
16741: LIST
16742: PUSH
16743: LD_OWVAR 67
16747: ARRAY
16748: PLUS
16749: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
16750: LD_VAR 0 1
16754: PPUSH
16755: CALL_OW 255
16759: PUSH
16760: LD_INT 3
16762: EQUAL
16763: IFFALSE 16781
// ru_vehicles := ru_vehicles ^ veh ;
16765: LD_ADDR_EXP 54
16769: PUSH
16770: LD_EXP 54
16774: PUSH
16775: LD_VAR 0 1
16779: ADD
16780: ST_TO_ADDR
// end ;
16781: PPOPN 2
16783: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
16784: LD_VAR 0 1
16788: PUSH
16789: LD_EXP 51
16793: IN
16794: IFFALSE 16812
// ru_patrol := ru_patrol diff un ;
16796: LD_ADDR_EXP 51
16800: PUSH
16801: LD_EXP 51
16805: PUSH
16806: LD_VAR 0 1
16810: DIFF
16811: ST_TO_ADDR
// if un in ru_forest then
16812: LD_VAR 0 1
16816: PUSH
16817: LD_EXP 53
16821: IN
16822: IFFALSE 16840
// ru_forest := ru_forest diff un ;
16824: LD_ADDR_EXP 53
16828: PUSH
16829: LD_EXP 53
16833: PUSH
16834: LD_VAR 0 1
16838: DIFF
16839: ST_TO_ADDR
// if un in ru_vehicles then
16840: LD_VAR 0 1
16844: PUSH
16845: LD_EXP 54
16849: IN
16850: IFFALSE 16925
// begin ru_vehicles := ru_vehicles diff un ;
16852: LD_ADDR_EXP 54
16856: PUSH
16857: LD_EXP 54
16861: PUSH
16862: LD_VAR 0 1
16866: DIFF
16867: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
16868: LD_ADDR_EXP 55
16872: PUSH
16873: LD_EXP 55
16877: PUSH
16878: LD_VAR 0 1
16882: PPUSH
16883: CALL_OW 265
16887: PUSH
16888: LD_VAR 0 1
16892: PPUSH
16893: CALL_OW 262
16897: PUSH
16898: LD_VAR 0 1
16902: PPUSH
16903: CALL_OW 263
16907: PUSH
16908: LD_VAR 0 1
16912: PPUSH
16913: CALL_OW 264
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: LIST
16922: LIST
16923: ADD
16924: ST_TO_ADDR
// end ; if un = JMM then
16925: LD_VAR 0 1
16929: PUSH
16930: LD_EXP 35
16934: EQUAL
16935: IFFALSE 16944
// YouLost ( 0 ) ;
16937: LD_STRING 0
16939: PPUSH
16940: CALL_OW 104
// if un = us_dep_west then
16944: LD_VAR 0 1
16948: PUSH
16949: LD_INT 1
16951: EQUAL
16952: IFFALSE 16961
// YouLost ( 2 ) ;
16954: LD_STRING 2
16956: PPUSH
16957: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
16961: LD_VAR 0 1
16965: PPUSH
16966: CALL_OW 255
16970: PUSH
16971: LD_INT 8
16973: EQUAL
16974: PUSH
16975: LD_EXP 5
16979: NOT
16980: AND
16981: IFFALSE 16990
// YouLost ( 4 ) ;
16983: LD_STRING 4
16985: PPUSH
16986: CALL_OW 104
// if un in jmm_units then
16990: LD_VAR 0 1
16994: PUSH
16995: LD_EXP 4
16999: IN
17000: IFFALSE 17016
// lose_counter := lose_counter + 1 ;
17002: LD_ADDR_EXP 32
17006: PUSH
17007: LD_EXP 32
17011: PUSH
17012: LD_INT 1
17014: PLUS
17015: ST_TO_ADDR
// end ;
17016: PPOPN 1
17018: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
17019: LD_INT 0
17021: PPUSH
17022: PPUSH
// begin if GetSide ( driver ) = 3 then
17023: LD_VAR 0 1
17027: PPUSH
17028: CALL_OW 255
17032: PUSH
17033: LD_INT 3
17035: EQUAL
17036: IFFALSE 17114
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
17038: LD_ADDR_VAR 0 6
17042: PUSH
17043: LD_INT 22
17045: PUSH
17046: LD_INT 3
17048: PUSH
17049: EMPTY
17050: LIST
17051: LIST
17052: PUSH
17053: LD_INT 30
17055: PUSH
17056: LD_INT 3
17058: PUSH
17059: EMPTY
17060: LIST
17061: LIST
17062: PUSH
17063: EMPTY
17064: LIST
17065: LIST
17066: PPUSH
17067: CALL_OW 69
17071: PPUSH
17072: CALL 1039 0 1
17076: ST_TO_ADDR
// if place then
17077: LD_VAR 0 6
17081: IFFALSE 17099
// ComEnterUnit ( driver , place ) else
17083: LD_VAR 0 1
17087: PPUSH
17088: LD_VAR 0 6
17092: PPUSH
17093: CALL_OW 120
17097: GO 17114
// ComMoveXY ( driver , 70 , 22 ) ;
17099: LD_VAR 0 1
17103: PPUSH
17104: LD_INT 70
17106: PPUSH
17107: LD_INT 22
17109: PPUSH
17110: CALL_OW 111
// end ; end ;
17114: PPOPN 6
17116: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and ( s2 = 4 or ( s2 = 8 and not jmm_on_west ) ) then
17117: LD_VAR 0 1
17121: PUSH
17122: LD_INT 1
17124: EQUAL
17125: PUSH
17126: LD_VAR 0 2
17130: PUSH
17131: LD_INT 4
17133: EQUAL
17134: PUSH
17135: LD_VAR 0 2
17139: PUSH
17140: LD_INT 8
17142: EQUAL
17143: PUSH
17144: LD_EXP 5
17148: NOT
17149: AND
17150: OR
17151: AND
17152: IFFALSE 17161
// YouLost ( 5 ) ;
17154: LD_STRING 5
17156: PPUSH
17157: CALL_OW 104
// end ;
17161: PPOPN 2
17163: END
// every 0 0$01 trigger save_counter + ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
17164: LD_EXP 34
17168: PUSH
17169: LD_INT 22
17171: PUSH
17172: LD_INT 1
17174: PUSH
17175: EMPTY
17176: LIST
17177: LIST
17178: PUSH
17179: LD_INT 21
17181: PUSH
17182: LD_INT 1
17184: PUSH
17185: EMPTY
17186: LIST
17187: LIST
17188: PUSH
17189: EMPTY
17190: LIST
17191: LIST
17192: PPUSH
17193: CALL_OW 69
17197: PUSH
17198: LD_INT 22
17200: PUSH
17201: LD_INT 8
17203: PUSH
17204: EMPTY
17205: LIST
17206: LIST
17207: PUSH
17208: LD_INT 21
17210: PUSH
17211: LD_INT 1
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: PUSH
17218: EMPTY
17219: LIST
17220: LIST
17221: PPUSH
17222: CALL_OW 69
17226: ADD
17227: PLUS
17228: PUSH
17229: LD_INT 5
17231: LESS
17232: IFFALSE 17244
17234: GO 17236
17236: DISABLE
// YouLost ( 1 ) ;
17237: LD_STRING 1
17239: PPUSH
17240: CALL_OW 104
17244: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
17245: LD_INT 1
17247: PPUSH
17248: CALL_OW 255
17252: PUSH
17253: LD_INT 3
17255: EQUAL
17256: IFFALSE 17268
17258: GO 17260
17260: DISABLE
// YouLost ( 3 ) ;
17261: LD_STRING 3
17263: PPUSH
17264: CALL_OW 104
17268: END
