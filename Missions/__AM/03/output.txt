// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 339 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 427 0 0
// PrepareRussian ;
  22: CALL 2920 0 0
// PrepareAmerican ;
  26: CALL 1161 0 0
// PrepareCornell ;
  30: CALL 2185 0 0
// PrepareWesternBase ;
  34: CALL 2411 0 0
// Action ;
  38: CALL 4926 0 0
// end ;
  42: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  54: LD_ADDR_EXP 3
  58: PUSH
  59: LD_STRING 02_
  61: ST_TO_ADDR
// mission_prefix := 03_ ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_STRING 03_
  69: ST_TO_ADDR
// jmm_units := 0 ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// cornel_units := 0 ;
  78: LD_ADDR_EXP 6
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// bierezov_exist := false ;
  86: LD_ADDR_EXP 7
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// jmm_on_west := false ;
  94: LD_ADDR_EXP 5
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_active := false ;
 102: LD_ADDR_EXP 8
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_attack := false ;
 110: LD_ADDR_EXP 9
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// cornel_prepared := false ;
 118: LD_ADDR_EXP 11
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 126: LD_ADDR_EXP 10
 130: PUSH
 131: LD_INT 4200
 133: ST_TO_ADDR
// frank_can_return := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// solar_builded := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// frank_send_to_scout := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// jmm_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// bobby_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// cyrus_in_veh := false ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// lisa_in_veh := false ;
 182: LD_ADDR_EXP 18
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 190: LD_ADDR_EXP 27
 194: PUSH
 195: LD_INT 25200
 197: PUSH
 198: LD_INT 23100
 200: PUSH
 201: LD_INT 21000
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: PUSH
 209: LD_OWVAR 67
 213: ARRAY
 214: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 215: LD_ADDR_EXP 19
 219: PUSH
 220: LD_INT 600
 222: PUSH
 223: LD_INT 500
 225: PUSH
 226: LD_INT 400
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: PUSH
 234: LD_OWVAR 67
 238: ARRAY
 239: ST_TO_ADDR
// end_mission_allowed := false ;
 240: LD_ADDR_EXP 20
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// save_others := [ ] ;
 248: LD_ADDR_EXP 21
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// save_group := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// show_query := true ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// wait_for_them := false ;
 270: LD_ADDR_EXP 24
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// veh_on_meta := false ;
 278: LD_ADDR_EXP 26
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_spec_patrol := false ;
 286: LD_ADDR_EXP 28
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// prepare_siege := false ;
 294: LD_ADDR_EXP 29
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// send_attack_on_cornel := false ;
 302: LD_ADDR_EXP 30
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 310: LD_ADDR_EXP 25
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// game_end := false ;
 318: LD_ADDR_EXP 31
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// lose_counter := 0 ;
 326: LD_ADDR_EXP 32
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// end ;
 334: LD_VAR 0 1
 338: RET
// function SetDiplomacy ; begin
 339: LD_INT 0
 341: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 342: LD_INT 1
 344: PPUSH
 345: LD_INT 4
 347: PPUSH
 348: LD_INT 1
 350: PPUSH
 351: LD_INT 1
 353: PPUSH
 354: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 358: LD_INT 1
 360: PPUSH
 361: LD_INT 8
 363: PPUSH
 364: LD_INT 1
 366: PPUSH
 367: LD_INT 1
 369: PPUSH
 370: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 374: LD_INT 3
 376: PPUSH
 377: LD_INT 6
 379: PPUSH
 380: LD_INT 1
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 390: LD_INT 4
 392: PPUSH
 393: LD_INT 6
 395: PPUSH
 396: LD_INT 0
 398: PPUSH
 399: LD_INT 1
 401: PPUSH
 402: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 406: LD_INT 3
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: LD_INT 0
 414: PPUSH
 415: LD_INT 1
 417: PPUSH
 418: CALL_OW 80
// end ;
 422: LD_VAR 0 1
 426: RET
// export function DebugMode ; var i ; begin
 427: LD_INT 0
 429: PPUSH
 430: PPUSH
// FogOff ( 1 ) ;
 431: LD_INT 1
 433: PPUSH
 434: CALL_OW 344
// debug_strings := [ ] ;
 438: LD_ADDR_OWVAR 48
 442: PUSH
 443: EMPTY
 444: ST_TO_ADDR
// end ; end_of_file
 445: LD_VAR 0 1
 449: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 450: LD_INT 0
 452: PPUSH
 453: PPUSH
// if exist_mode then
 454: LD_VAR 0 2
 458: IFFALSE 483
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 460: LD_ADDR_VAR 0 4
 464: PUSH
 465: LD_EXP 3
 469: PUSH
 470: LD_VAR 0 1
 474: STR
 475: PPUSH
 476: CALL_OW 34
 480: ST_TO_ADDR
 481: GO 498
// unit := NewCharacter ( ident ) ;
 483: LD_ADDR_VAR 0 4
 487: PUSH
 488: LD_VAR 0 1
 492: PPUSH
 493: CALL_OW 25
 497: ST_TO_ADDR
// result := unit ;
 498: LD_ADDR_VAR 0 3
 502: PUSH
 503: LD_VAR 0 4
 507: ST_TO_ADDR
// end ;
 508: LD_VAR 0 3
 512: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 513: LD_INT 0
 515: PPUSH
// uc_side := side ;
 516: LD_ADDR_OWVAR 20
 520: PUSH
 521: LD_VAR 0 1
 525: ST_TO_ADDR
// uc_nation := nation ;
 526: LD_ADDR_OWVAR 21
 530: PUSH
 531: LD_VAR 0 2
 535: ST_TO_ADDR
// vc_chassis := chassis ;
 536: LD_ADDR_OWVAR 37
 540: PUSH
 541: LD_VAR 0 3
 545: ST_TO_ADDR
// vc_engine := engine ;
 546: LD_ADDR_OWVAR 39
 550: PUSH
 551: LD_VAR 0 4
 555: ST_TO_ADDR
// vc_control := control ;
 556: LD_ADDR_OWVAR 38
 560: PUSH
 561: LD_VAR 0 5
 565: ST_TO_ADDR
// vc_weapon := weapon ;
 566: LD_ADDR_OWVAR 40
 570: PUSH
 571: LD_VAR 0 6
 575: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 576: LD_ADDR_OWVAR 41
 580: PUSH
 581: LD_VAR 0 7
 585: ST_TO_ADDR
// result := CreateVehicle ;
 586: LD_ADDR_VAR 0 8
 590: PUSH
 591: CALL_OW 45
 595: ST_TO_ADDR
// end ;
 596: LD_VAR 0 8
 600: RET
// export function SayX ( units , ident ) ; var i ; begin
 601: LD_INT 0
 603: PPUSH
 604: PPUSH
// result := false ;
 605: LD_ADDR_VAR 0 3
 609: PUSH
 610: LD_INT 0
 612: ST_TO_ADDR
// if not units then
 613: LD_VAR 0 1
 617: NOT
 618: IFFALSE 622
// exit ;
 620: GO 676
// for i in units do
 622: LD_ADDR_VAR 0 4
 626: PUSH
 627: LD_VAR 0 1
 631: PUSH
 632: FOR_IN
 633: IFFALSE 674
// if IsOk ( i ) then
 635: LD_VAR 0 4
 639: PPUSH
 640: CALL_OW 302
 644: IFFALSE 672
// begin Say ( i , ident ) ;
 646: LD_VAR 0 4
 650: PPUSH
 651: LD_VAR 0 2
 655: PPUSH
 656: CALL_OW 88
// result := i ;
 660: LD_ADDR_VAR 0 3
 664: PUSH
 665: LD_VAR 0 4
 669: ST_TO_ADDR
// break ;
 670: GO 674
// end ;
 672: GO 632
 674: POP
 675: POP
// end ;
 676: LD_VAR 0 3
 680: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 681: LD_INT 0
 683: PPUSH
 684: PPUSH
 685: PPUSH
 686: PPUSH
// for i = 1 to count do
 687: LD_ADDR_VAR 0 8
 691: PUSH
 692: DOUBLE
 693: LD_INT 1
 695: DEC
 696: ST_TO_ADDR
 697: LD_VAR 0 6
 701: PUSH
 702: FOR_TO
 703: IFFALSE 784
// begin uc_side = side ;
 705: LD_ADDR_OWVAR 20
 709: PUSH
 710: LD_VAR 0 1
 714: ST_TO_ADDR
// uc_nation = nation ;
 715: LD_ADDR_OWVAR 21
 719: PUSH
 720: LD_VAR 0 2
 724: ST_TO_ADDR
// hc_gallery =  ;
 725: LD_ADDR_OWVAR 33
 729: PUSH
 730: LD_STRING 
 732: ST_TO_ADDR
// hc_name =  ;
 733: LD_ADDR_OWVAR 26
 737: PUSH
 738: LD_STRING 
 740: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 741: LD_INT 0
 743: PPUSH
 744: LD_VAR 0 5
 748: PPUSH
 749: LD_VAR 0 4
 753: PPUSH
 754: CALL_OW 380
// un = CreateHuman ;
 758: LD_ADDR_VAR 0 10
 762: PUSH
 763: CALL_OW 44
 767: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 768: LD_VAR 0 10
 772: PPUSH
 773: LD_VAR 0 3
 777: PPUSH
 778: CALL_OW 52
// end ;
 782: GO 702
 784: POP
 785: POP
// end ;
 786: LD_VAR 0 7
 790: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 791: LD_INT 0
 793: PPUSH
 794: PPUSH
 795: PPUSH
// uc_side := GetSide ( b ) ;
 796: LD_ADDR_OWVAR 20
 800: PUSH
 801: LD_VAR 0 2
 805: PPUSH
 806: CALL_OW 255
 810: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 811: LD_ADDR_OWVAR 21
 815: PUSH
 816: LD_VAR 0 2
 820: PPUSH
 821: CALL_OW 248
 825: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 826: LD_INT 0
 828: PPUSH
 829: LD_INT 1
 831: PPUSH
 832: LD_VAR 0 1
 836: PPUSH
 837: CALL_OW 380
// un = CreateHuman ;
 841: LD_ADDR_VAR 0 4
 845: PUSH
 846: CALL_OW 44
 850: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 851: LD_ADDR_VAR 0 5
 855: PUSH
 856: LD_VAR 0 2
 860: PPUSH
 861: CALL_OW 254
 865: PUSH
 866: LD_INT 3
 868: MINUS
 869: ST_TO_ADDR
// if dir < 0 then
 870: LD_VAR 0 5
 874: PUSH
 875: LD_INT 0
 877: LESS
 878: IFFALSE 894
// dir := 6 + dir ;
 880: LD_ADDR_VAR 0 5
 884: PUSH
 885: LD_INT 6
 887: PUSH
 888: LD_VAR 0 5
 892: PLUS
 893: ST_TO_ADDR
// SetDir ( un , dir ) ;
 894: LD_VAR 0 4
 898: PPUSH
 899: LD_VAR 0 5
 903: PPUSH
 904: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 908: LD_VAR 0 4
 912: PPUSH
 913: LD_VAR 0 2
 917: PPUSH
 918: CALL_OW 52
// end ;
 922: LD_VAR 0 3
 926: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 927: LD_INT 0
 929: PPUSH
 930: PPUSH
 931: PPUSH
// result := false ;
 932: LD_ADDR_VAR 0 2
 936: PUSH
 937: LD_INT 0
 939: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 940: LD_ADDR_VAR 0 3
 944: PUSH
 945: LD_INT 22
 947: PUSH
 948: LD_INT 1
 950: PUSH
 951: EMPTY
 952: LIST
 953: LIST
 954: PUSH
 955: LD_INT 34
 957: PUSH
 958: LD_INT 2
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: PUSH
 965: EMPTY
 966: LIST
 967: LIST
 968: PPUSH
 969: CALL_OW 69
 973: ST_TO_ADDR
// for i in filter do
 974: LD_ADDR_VAR 0 4
 978: PUSH
 979: LD_VAR 0 3
 983: PUSH
 984: FOR_IN
 985: IFFALSE 1016
// if IsDrivenBy ( i ) = unit then
 987: LD_VAR 0 4
 991: PPUSH
 992: CALL_OW 311
 996: PUSH
 997: LD_VAR 0 1
1001: EQUAL
1002: IFFALSE 1014
// begin result := true ;
1004: LD_ADDR_VAR 0 2
1008: PUSH
1009: LD_INT 1
1011: ST_TO_ADDR
// break ;
1012: GO 1016
// end ;
1014: GO 984
1016: POP
1017: POP
// end ;
1018: LD_VAR 0 2
1022: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1023: LD_INT 0
1025: PPUSH
1026: PPUSH
// result := false ;
1027: LD_ADDR_VAR 0 2
1031: PUSH
1032: LD_INT 0
1034: ST_TO_ADDR
// if not blist then
1035: LD_VAR 0 1
1039: NOT
1040: IFFALSE 1044
// exit ;
1042: GO 1088
// for i in blist do
1044: LD_ADDR_VAR 0 3
1048: PUSH
1049: LD_VAR 0 1
1053: PUSH
1054: FOR_IN
1055: IFFALSE 1086
// if UnitsInside ( i ) < 6 then
1057: LD_VAR 0 3
1061: PPUSH
1062: CALL_OW 313
1066: PUSH
1067: LD_INT 6
1069: LESS
1070: IFFALSE 1084
// begin result := i ;
1072: LD_ADDR_VAR 0 2
1076: PUSH
1077: LD_VAR 0 3
1081: ST_TO_ADDR
// break ;
1082: GO 1086
// end ;
1084: GO 1054
1086: POP
1087: POP
// end ;
1088: LD_VAR 0 2
1092: RET
// export function Count ( timer , mode ) ; begin
1093: LD_INT 0
1095: PPUSH
// if not timer then
1096: LD_VAR 0 1
1100: NOT
1101: IFFALSE 1105
// exit ;
1103: GO 1156
// if mode in [ asc , up , + ] then
1105: LD_VAR 0 2
1109: PUSH
1110: LD_STRING asc
1112: PUSH
1113: LD_STRING up
1115: PUSH
1116: LD_STRING +
1118: PUSH
1119: EMPTY
1120: LIST
1121: LIST
1122: LIST
1123: IN
1124: IFFALSE 1142
// result := timer + 0 0$01 else
1126: LD_ADDR_VAR 0 3
1130: PUSH
1131: LD_VAR 0 1
1135: PUSH
1136: LD_INT 35
1138: PLUS
1139: ST_TO_ADDR
1140: GO 1156
// result := timer - 0 0$01 ;
1142: LD_ADDR_VAR 0 3
1146: PUSH
1147: LD_VAR 0 1
1151: PUSH
1152: LD_INT 35
1154: MINUS
1155: ST_TO_ADDR
// end ; end_of_file
1156: LD_VAR 0 3
1160: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1161: LD_INT 0
1163: PPUSH
1164: PPUSH
1165: PPUSH
1166: PPUSH
1167: PPUSH
1168: PPUSH
1169: PPUSH
1170: PPUSH
// uc_side := 4 ;
1171: LD_ADDR_OWVAR 20
1175: PUSH
1176: LD_INT 4
1178: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1179: LD_ADDR_EXP 42
1183: PUSH
1184: LD_STRING Powell
1186: PPUSH
1187: LD_INT 0
1189: PPUSH
1190: CALL 450 0 2
1194: ST_TO_ADDR
// uc_side := 1 ;
1195: LD_ADDR_OWVAR 20
1199: PUSH
1200: LD_INT 1
1202: ST_TO_ADDR
// uc_nation := 1 ;
1203: LD_ADDR_OWVAR 21
1207: PUSH
1208: LD_INT 1
1210: ST_TO_ADDR
// if debug then
1211: LD_EXP 1
1215: IFFALSE 1345
// begin for i = 1 to 4 do
1217: LD_ADDR_VAR 0 2
1221: PUSH
1222: DOUBLE
1223: LD_INT 1
1225: DEC
1226: ST_TO_ADDR
1227: LD_INT 4
1229: PUSH
1230: FOR_TO
1231: IFFALSE 1282
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1233: LD_INT 0
1235: PPUSH
1236: LD_INT 1
1238: PPUSH
1239: LD_INT 2
1241: PPUSH
1242: CALL_OW 12
1246: PPUSH
1247: LD_INT 3
1249: PPUSH
1250: CALL_OW 380
// un := CreateHuman ;
1254: LD_ADDR_VAR 0 3
1258: PUSH
1259: CALL_OW 44
1263: ST_TO_ADDR
// others := others ^ un ;
1264: LD_ADDR_VAR 0 5
1268: PUSH
1269: LD_VAR 0 5
1273: PUSH
1274: LD_VAR 0 3
1278: ADD
1279: ST_TO_ADDR
// end ;
1280: GO 1230
1282: POP
1283: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1284: LD_ADDR_VAR 0 6
1288: PUSH
1289: LD_INT 21
1291: PUSH
1292: LD_INT 1
1294: PUSH
1295: LD_INT 1
1297: PUSH
1298: LD_INT 51
1300: PUSH
1301: LD_INT 90
1303: PUSH
1304: LD_INT 504
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: PUSH
1315: LD_INT 21
1317: PUSH
1318: LD_INT 1
1320: PUSH
1321: LD_INT 1
1323: PUSH
1324: LD_INT 51
1326: PUSH
1327: LD_INT 80
1329: PUSH
1330: LD_INT 750
1332: PUSH
1333: EMPTY
1334: LIST
1335: LIST
1336: LIST
1337: LIST
1338: LIST
1339: LIST
1340: PUSH
1341: EMPTY
1342: LIST
1343: LIST
1344: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1345: LD_ADDR_EXP 33
1349: PUSH
1350: LD_STRING JMM
1352: PPUSH
1353: LD_EXP 1
1357: NOT
1358: PPUSH
1359: CALL 450 0 2
1363: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1364: LD_ADDR_EXP 34
1368: PUSH
1369: LD_STRING Bobby
1371: PPUSH
1372: LD_EXP 1
1376: NOT
1377: PPUSH
1378: CALL 450 0 2
1382: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1383: LD_ADDR_EXP 35
1387: PUSH
1388: LD_STRING Cyrus
1390: PPUSH
1391: LD_EXP 1
1395: NOT
1396: PPUSH
1397: CALL 450 0 2
1401: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1402: LD_ADDR_EXP 36
1406: PUSH
1407: LD_STRING Lisa
1409: PPUSH
1410: LD_EXP 1
1414: NOT
1415: PPUSH
1416: CALL 450 0 2
1420: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1421: LD_ADDR_EXP 37
1425: PUSH
1426: LD_STRING Khatam
1428: PPUSH
1429: LD_EXP 1
1433: NOT
1434: PPUSH
1435: CALL 450 0 2
1439: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1440: LD_ADDR_EXP 38
1444: PUSH
1445: LD_STRING Brian
1447: PPUSH
1448: LD_EXP 1
1452: NOT
1453: PPUSH
1454: CALL 450 0 2
1458: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1459: LD_ADDR_EXP 39
1463: PUSH
1464: LD_STRING Jerry
1466: PPUSH
1467: LD_EXP 1
1471: NOT
1472: PPUSH
1473: CALL 450 0 2
1477: ST_TO_ADDR
// if Bobby then
1478: LD_EXP 34
1482: IFFALSE 1513
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1484: LD_ADDR_VAR 0 4
1488: PUSH
1489: LD_VAR 0 4
1493: PPUSH
1494: LD_VAR 0 4
1498: PUSH
1499: LD_INT 1
1501: PLUS
1502: PPUSH
1503: LD_EXP 34
1507: PPUSH
1508: CALL_OW 2
1512: ST_TO_ADDR
// if Cyrus then
1513: LD_EXP 35
1517: IFFALSE 1548
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1519: LD_ADDR_VAR 0 4
1523: PUSH
1524: LD_VAR 0 4
1528: PPUSH
1529: LD_VAR 0 4
1533: PUSH
1534: LD_INT 1
1536: PLUS
1537: PPUSH
1538: LD_EXP 35
1542: PPUSH
1543: CALL_OW 2
1547: ST_TO_ADDR
// if Lisa then
1548: LD_EXP 36
1552: IFFALSE 1583
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1554: LD_ADDR_VAR 0 4
1558: PUSH
1559: LD_VAR 0 4
1563: PPUSH
1564: LD_VAR 0 4
1568: PUSH
1569: LD_INT 1
1571: PLUS
1572: PPUSH
1573: LD_EXP 36
1577: PPUSH
1578: CALL_OW 2
1582: ST_TO_ADDR
// if Khatam then
1583: LD_EXP 37
1587: IFFALSE 1618
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1589: LD_ADDR_VAR 0 4
1593: PUSH
1594: LD_VAR 0 4
1598: PPUSH
1599: LD_VAR 0 4
1603: PUSH
1604: LD_INT 1
1606: PLUS
1607: PPUSH
1608: LD_EXP 37
1612: PPUSH
1613: CALL_OW 2
1617: ST_TO_ADDR
// if Brian then
1618: LD_EXP 38
1622: IFFALSE 1653
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1624: LD_ADDR_VAR 0 4
1628: PUSH
1629: LD_VAR 0 4
1633: PPUSH
1634: LD_VAR 0 4
1638: PUSH
1639: LD_INT 1
1641: PLUS
1642: PPUSH
1643: LD_EXP 38
1647: PPUSH
1648: CALL_OW 2
1652: ST_TO_ADDR
// if Jerry then
1653: LD_EXP 39
1657: IFFALSE 1688
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1659: LD_ADDR_VAR 0 4
1663: PUSH
1664: LD_VAR 0 4
1668: PPUSH
1669: LD_VAR 0 4
1673: PUSH
1674: LD_INT 1
1676: PLUS
1677: PPUSH
1678: LD_EXP 39
1682: PPUSH
1683: CALL_OW 2
1687: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1688: LD_STRING 02_other_survivors
1690: PPUSH
1691: CALL_OW 28
1695: IFFALSE 1710
// others := CreateCharacterSet ( 02_other_survivors ) ;
1697: LD_ADDR_VAR 0 5
1701: PUSH
1702: LD_STRING 02_other_survivors
1704: PPUSH
1705: CALL_OW 31
1709: ST_TO_ADDR
// if others then
1710: LD_VAR 0 5
1714: IFFALSE 1739
// begin tmp := tmp ^ others ;
1716: LD_ADDR_VAR 0 4
1720: PUSH
1721: LD_VAR 0 4
1725: PUSH
1726: LD_VAR 0 5
1730: ADD
1731: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1732: LD_STRING 02_other_survivors
1734: PPUSH
1735: CALL_OW 40
// end ; jmm_units := tmp ;
1739: LD_ADDR_EXP 4
1743: PUSH
1744: LD_VAR 0 4
1748: ST_TO_ADDR
// if not vehicles then
1749: LD_VAR 0 6
1753: NOT
1754: IFFALSE 1772
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1756: LD_ADDR_VAR 0 6
1760: PUSH
1761: LD_STRING 02_tanks_1
1763: PPUSH
1764: LD_INT 0
1766: PPUSH
1767: CALL_OW 30
1771: ST_TO_ADDR
// if vehicles then
1772: LD_VAR 0 6
1776: IFFALSE 1970
// begin got_mech := false ;
1778: LD_ADDR_VAR 0 7
1782: PUSH
1783: LD_INT 0
1785: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1786: LD_VAR 0 4
1790: PPUSH
1791: LD_INT 25
1793: PUSH
1794: LD_INT 3
1796: PUSH
1797: EMPTY
1798: LIST
1799: LIST
1800: PPUSH
1801: CALL_OW 72
1805: IFFALSE 1815
// got_mech := true ;
1807: LD_ADDR_VAR 0 7
1811: PUSH
1812: LD_INT 1
1814: ST_TO_ADDR
// for i = 1 to vehicles do
1815: LD_ADDR_VAR 0 2
1819: PUSH
1820: DOUBLE
1821: LD_INT 1
1823: DEC
1824: ST_TO_ADDR
1825: LD_VAR 0 6
1829: PUSH
1830: FOR_TO
1831: IFFALSE 1968
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1833: LD_ADDR_VAR 0 3
1837: PUSH
1838: LD_INT 1
1840: PPUSH
1841: LD_INT 3
1843: PPUSH
1844: LD_VAR 0 6
1848: PUSH
1849: LD_VAR 0 2
1853: ARRAY
1854: PUSH
1855: LD_INT 1
1857: ARRAY
1858: PPUSH
1859: LD_VAR 0 6
1863: PUSH
1864: LD_VAR 0 2
1868: ARRAY
1869: PUSH
1870: LD_INT 2
1872: ARRAY
1873: PPUSH
1874: LD_VAR 0 6
1878: PUSH
1879: LD_VAR 0 2
1883: ARRAY
1884: PUSH
1885: LD_INT 3
1887: ARRAY
1888: PPUSH
1889: LD_VAR 0 6
1893: PUSH
1894: LD_VAR 0 2
1898: ARRAY
1899: PUSH
1900: LD_INT 4
1902: ARRAY
1903: PPUSH
1904: LD_INT 40
1906: PPUSH
1907: CALL 513 0 7
1911: ST_TO_ADDR
// if not got_mech then
1912: LD_VAR 0 7
1916: NOT
1917: IFFALSE 1943
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1919: LD_VAR 0 3
1923: PPUSH
1924: LD_VAR 0 6
1928: PUSH
1929: LD_VAR 0 2
1933: ARRAY
1934: PUSH
1935: LD_INT 6
1937: ARRAY
1938: PPUSH
1939: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1943: LD_ADDR_VAR 0 4
1947: PUSH
1948: LD_VAR 0 4
1952: PPUSH
1953: LD_INT 1
1955: PPUSH
1956: LD_VAR 0 3
1960: PPUSH
1961: CALL_OW 2
1965: ST_TO_ADDR
// end ;
1966: GO 1830
1968: POP
1969: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1970: LD_EXP 33
1974: PPUSH
1975: LD_INT 194
1977: PPUSH
1978: LD_INT 119
1980: PPUSH
1981: LD_INT 0
1983: PPUSH
1984: CALL_OW 48
// if tmp then
1988: LD_VAR 0 4
1992: IFFALSE 2117
// begin for i in tmp do
1994: LD_ADDR_VAR 0 2
1998: PUSH
1999: LD_VAR 0 4
2003: PUSH
2004: FOR_IN
2005: IFFALSE 2115
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2007: LD_ADDR_VAR 0 8
2011: PUSH
2012: LD_INT 22
2014: PUSH
2015: LD_INT 1
2017: PUSH
2018: EMPTY
2019: LIST
2020: LIST
2021: PUSH
2022: LD_INT 21
2024: PUSH
2025: LD_INT 2
2027: PUSH
2028: EMPTY
2029: LIST
2030: LIST
2031: PUSH
2032: LD_INT 58
2034: PUSH
2035: EMPTY
2036: LIST
2037: PUSH
2038: EMPTY
2039: LIST
2040: LIST
2041: LIST
2042: PPUSH
2043: CALL_OW 69
2047: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2048: LD_VAR 0 2
2052: PPUSH
2053: CALL_OW 247
2057: PUSH
2058: LD_INT 1
2060: EQUAL
2061: PUSH
2062: LD_VAR 0 8
2066: AND
2067: IFFALSE 2089
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2069: LD_VAR 0 2
2073: PPUSH
2074: LD_VAR 0 8
2078: PUSH
2079: LD_INT 1
2081: ARRAY
2082: PPUSH
2083: CALL_OW 52
2087: GO 2104
// PlaceUnitArea ( i , startArea , false ) ;
2089: LD_VAR 0 2
2093: PPUSH
2094: LD_INT 1
2096: PPUSH
2097: LD_INT 0
2099: PPUSH
2100: CALL_OW 49
// ComHold ( i ) ;
2104: LD_VAR 0 2
2108: PPUSH
2109: CALL_OW 140
// end ;
2113: GO 2004
2115: POP
2116: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2117: LD_ADDR_EXP 7
2121: PUSH
2122: LD_STRING 02_mikhailStatus_1
2124: PPUSH
2125: LD_INT 0
2127: PPUSH
2128: CALL_OW 30
2132: ST_TO_ADDR
// if not bierezov_exist and not debug then
2133: LD_EXP 7
2137: NOT
2138: PUSH
2139: LD_EXP 1
2143: NOT
2144: AND
2145: IFFALSE 2149
// exit ;
2147: GO 2180
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2149: LD_ADDR_EXP 41
2153: PUSH
2154: LD_STRING Mikhail
2156: PPUSH
2157: LD_INT 0
2159: PPUSH
2160: CALL 450 0 2
2164: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2165: LD_EXP 41
2169: PPUSH
2170: LD_INT 1
2172: PPUSH
2173: LD_INT 0
2175: PPUSH
2176: CALL_OW 49
// end ;
2180: LD_VAR 0 1
2184: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2185: LD_INT 0
2187: PPUSH
2188: PPUSH
2189: PPUSH
2190: PPUSH
// uc_side := 4 ;
2191: LD_ADDR_OWVAR 20
2195: PUSH
2196: LD_INT 4
2198: ST_TO_ADDR
// uc_nation := 1 ;
2199: LD_ADDR_OWVAR 21
2203: PUSH
2204: LD_INT 1
2206: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2207: LD_ADDR_EXP 40
2211: PUSH
2212: LD_STRING Cornell
2214: PPUSH
2215: LD_INT 0
2217: PPUSH
2218: CALL 450 0 2
2222: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
2223: LD_ADDR_EXP 6
2227: PUSH
2228: LD_INT 8
2230: PUSH
2231: LD_EXP 4
2235: MINUS
2236: ST_TO_ADDR
// tmp := [ ] ;
2237: LD_ADDR_VAR 0 2
2241: PUSH
2242: EMPTY
2243: ST_TO_ADDR
// if cornel_units < 3 then
2244: LD_EXP 6
2248: PUSH
2249: LD_INT 3
2251: LESS
2252: IFFALSE 2262
// cornel_units := 3 ;
2254: LD_ADDR_EXP 6
2258: PUSH
2259: LD_INT 3
2261: ST_TO_ADDR
// for i = 1 to cornel_units do
2262: LD_ADDR_VAR 0 4
2266: PUSH
2267: DOUBLE
2268: LD_INT 1
2270: DEC
2271: ST_TO_ADDR
2272: LD_EXP 6
2276: PUSH
2277: FOR_TO
2278: IFFALSE 2376
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2280: LD_INT 0
2282: PPUSH
2283: LD_INT 1
2285: PUSH
2286: LD_INT 1
2288: PUSH
2289: LD_INT 1
2291: PUSH
2292: LD_INT 2
2294: PUSH
2295: LD_INT 4
2297: PUSH
2298: EMPTY
2299: LIST
2300: LIST
2301: LIST
2302: LIST
2303: LIST
2304: PUSH
2305: LD_VAR 0 4
2309: PUSH
2310: LD_INT 5
2312: MOD
2313: PUSH
2314: LD_INT 1
2316: PLUS
2317: ARRAY
2318: PPUSH
2319: LD_INT 2
2321: PPUSH
2322: CALL_OW 380
// un := CreateHuman ;
2326: LD_ADDR_VAR 0 3
2330: PUSH
2331: CALL_OW 44
2335: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2336: LD_ADDR_VAR 0 2
2340: PUSH
2341: LD_VAR 0 2
2345: PPUSH
2346: LD_INT 1
2348: PPUSH
2349: LD_VAR 0 3
2353: PPUSH
2354: CALL_OW 2
2358: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2359: LD_VAR 0 3
2363: PPUSH
2364: LD_INT 2
2366: PPUSH
2367: LD_INT 0
2369: PPUSH
2370: CALL_OW 49
// end ;
2374: GO 2277
2376: POP
2377: POP
// cornel_units := tmp ;
2378: LD_ADDR_EXP 6
2382: PUSH
2383: LD_VAR 0 2
2387: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2388: LD_EXP 40
2392: PPUSH
2393: LD_INT 191
2395: PPUSH
2396: LD_INT 106
2398: PPUSH
2399: LD_INT 0
2401: PPUSH
2402: CALL_OW 48
// end ;
2406: LD_VAR 0 1
2410: RET
// export function PrepareWesternBase ; var i ; begin
2411: LD_INT 0
2413: PPUSH
2414: PPUSH
// uc_side := 8 ;
2415: LD_ADDR_OWVAR 20
2419: PUSH
2420: LD_INT 8
2422: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2423: LD_ADDR_EXP 43
2427: PUSH
2428: LD_STRING Lynch
2430: PPUSH
2431: LD_INT 0
2433: PPUSH
2434: CALL 450 0 2
2438: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2439: LD_ADDR_EXP 44
2443: PUSH
2444: LD_STRING Walker
2446: PPUSH
2447: LD_INT 0
2449: PPUSH
2450: CALL 450 0 2
2454: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2455: LD_ADDR_EXP 45
2459: PUSH
2460: LD_STRING Turner
2462: PPUSH
2463: LD_INT 0
2465: PPUSH
2466: CALL 450 0 2
2470: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2471: LD_ADDR_EXP 46
2475: PUSH
2476: LD_STRING Jillian
2478: PPUSH
2479: LD_INT 0
2481: PPUSH
2482: CALL 450 0 2
2486: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2487: LD_ADDR_VAR 0 2
2491: PUSH
2492: LD_EXP 43
2496: PUSH
2497: LD_EXP 44
2501: PUSH
2502: LD_EXP 45
2506: PUSH
2507: LD_EXP 46
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: LIST
2516: LIST
2517: PUSH
2518: FOR_IN
2519: IFFALSE 2547
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2521: LD_VAR 0 2
2525: PPUSH
2526: LD_INT 3
2528: PPUSH
2529: LD_INT 0
2531: PPUSH
2532: CALL_OW 49
// ComHold ( i ) ;
2536: LD_VAR 0 2
2540: PPUSH
2541: CALL_OW 140
// end ;
2545: GO 2518
2547: POP
2548: POP
// end ;
2549: LD_VAR 0 1
2553: RET
// export function SelectGroup ; var units , selected , i ; begin
2554: LD_INT 0
2556: PPUSH
2557: PPUSH
2558: PPUSH
2559: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2560: LD_ADDR_VAR 0 2
2564: PUSH
2565: LD_EXP 33
2569: PUSH
2570: LD_INT -3
2572: PUSH
2573: EMPTY
2574: LIST
2575: LIST
2576: PUSH
2577: LD_EXP 4
2581: ADD
2582: PUSH
2583: LD_INT -2
2585: PUSH
2586: LD_INT -4
2588: PUSH
2589: LD_EXP 40
2593: PUSH
2594: LD_EXP 41
2598: PUSH
2599: EMPTY
2600: LIST
2601: LIST
2602: LIST
2603: LIST
2604: ADD
2605: PUSH
2606: LD_INT -3
2608: PUSH
2609: EMPTY
2610: LIST
2611: ADD
2612: PUSH
2613: LD_EXP 6
2617: ADD
2618: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2619: LD_ADDR_VAR 0 3
2623: PUSH
2624: LD_EXP 33
2628: PUSH
2629: LD_STRING Select five characters to go with you
2631: PPUSH
2632: LD_INT 4
2634: PPUSH
2635: LD_INT 4
2637: PPUSH
2638: LD_VAR 0 2
2642: PPUSH
2643: EMPTY
2644: PPUSH
2645: CALL_OW 42
2649: ADD
2650: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2651: LD_ADDR_EXP 6
2655: PUSH
2656: LD_EXP 4
2660: PUSH
2661: LD_EXP 6
2665: UNION
2666: PUSH
2667: LD_VAR 0 3
2671: DIFF
2672: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2673: LD_ADDR_VAR 0 4
2677: PUSH
2678: LD_EXP 6
2682: PUSH
2683: LD_EXP 41
2687: ADD
2688: PUSH
2689: FOR_IN
2690: IFFALSE 2721
// if GetSide ( i ) = 1 then
2692: LD_VAR 0 4
2696: PPUSH
2697: CALL_OW 255
2701: PUSH
2702: LD_INT 1
2704: EQUAL
2705: IFFALSE 2719
// SetSide ( i , 4 ) ;
2707: LD_VAR 0 4
2711: PPUSH
2712: LD_INT 4
2714: PPUSH
2715: CALL_OW 235
2719: GO 2689
2721: POP
2722: POP
// for i in selected do
2723: LD_ADDR_VAR 0 4
2727: PUSH
2728: LD_VAR 0 3
2732: PUSH
2733: FOR_IN
2734: IFFALSE 2765
// if GetSide ( i ) = 4 then
2736: LD_VAR 0 4
2740: PPUSH
2741: CALL_OW 255
2745: PUSH
2746: LD_INT 4
2748: EQUAL
2749: IFFALSE 2763
// SetSide ( i , 1 ) ;
2751: LD_VAR 0 4
2755: PPUSH
2756: LD_INT 1
2758: PPUSH
2759: CALL_OW 235
2763: GO 2733
2765: POP
2766: POP
// jmm_units := jmm_units diff cornel_units ;
2767: LD_ADDR_EXP 4
2771: PUSH
2772: LD_EXP 4
2776: PUSH
2777: LD_EXP 6
2781: DIFF
2782: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2783: LD_EXP 34
2787: PPUSH
2788: CALL_OW 255
2792: PUSH
2793: LD_INT 4
2795: EQUAL
2796: IFFALSE 2805
// DeleteCharacters ( Bobby ) ;
2798: LD_STRING Bobby
2800: PPUSH
2801: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2805: LD_EXP 35
2809: PPUSH
2810: CALL_OW 255
2814: PUSH
2815: LD_INT 4
2817: EQUAL
2818: IFFALSE 2827
// DeleteCharacters ( Cyrus ) ;
2820: LD_STRING Cyrus
2822: PPUSH
2823: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2827: LD_EXP 36
2831: PPUSH
2832: CALL_OW 255
2836: PUSH
2837: LD_INT 4
2839: EQUAL
2840: IFFALSE 2849
// DeleteCharacters ( Lisa ) ;
2842: LD_STRING Lisa
2844: PPUSH
2845: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2849: LD_EXP 37
2853: PPUSH
2854: CALL_OW 255
2858: PUSH
2859: LD_INT 4
2861: EQUAL
2862: IFFALSE 2871
// DeleteCharacters ( Khatam ) ;
2864: LD_STRING Khatam
2866: PPUSH
2867: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2871: LD_EXP 38
2875: PPUSH
2876: CALL_OW 255
2880: PUSH
2881: LD_INT 4
2883: EQUAL
2884: IFFALSE 2893
// DeleteCharacters ( Brian ) ;
2886: LD_STRING Brian
2888: PPUSH
2889: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2893: LD_EXP 39
2897: PPUSH
2898: CALL_OW 255
2902: PUSH
2903: LD_INT 4
2905: EQUAL
2906: IFFALSE 2915
// DeleteCharacters ( Jerry ) ;
2908: LD_STRING Jerry
2910: PPUSH
2911: CALL_OW 40
// end ; end_of_file
2915: LD_VAR 0 1
2919: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
2920: LD_INT 0
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
2930: PPUSH
2931: PPUSH
2932: PPUSH
2933: PPUSH
2934: PPUSH
// ru_alert := false ;
2935: LD_ADDR_EXP 56
2939: PUSH
2940: LD_INT 0
2942: ST_TO_ADDR
// ru_produce_list := [ ] ;
2943: LD_ADDR_EXP 53
2947: PUSH
2948: EMPTY
2949: ST_TO_ADDR
// if Difficulty > 1 then
2950: LD_OWVAR 67
2954: PUSH
2955: LD_INT 1
2957: GREATER
2958: IFFALSE 3046
// begin uc_side := 3 ;
2960: LD_ADDR_OWVAR 20
2964: PUSH
2965: LD_INT 3
2967: ST_TO_ADDR
// uc_nation := 3 ;
2968: LD_ADDR_OWVAR 21
2972: PUSH
2973: LD_INT 3
2975: ST_TO_ADDR
// bc_type := b_breastwork ;
2976: LD_ADDR_OWVAR 42
2980: PUSH
2981: LD_INT 31
2983: ST_TO_ADDR
// bc_level := Difficulty ;
2984: LD_ADDR_OWVAR 43
2988: PUSH
2989: LD_OWVAR 67
2993: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
2994: LD_INT 22
2996: PPUSH
2997: LD_INT 14
2999: PPUSH
3000: LD_INT 0
3002: PPUSH
3003: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3007: LD_INT 48
3009: PPUSH
3010: LD_INT 46
3012: PPUSH
3013: LD_INT 0
3015: PPUSH
3016: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3020: LD_INT 86
3022: PPUSH
3023: LD_INT 65
3025: PPUSH
3026: LD_INT 5
3028: PPUSH
3029: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3033: LD_INT 165
3035: PPUSH
3036: LD_INT 73
3038: PPUSH
3039: LD_INT 5
3041: PPUSH
3042: CALL_OW 47
// end ; tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3046: LD_ADDR_VAR 0 7
3050: PUSH
3051: LD_INT 22
3053: PUSH
3054: LD_INT 3
3056: PUSH
3057: EMPTY
3058: LIST
3059: LIST
3060: PUSH
3061: LD_INT 2
3063: PUSH
3064: LD_INT 30
3066: PUSH
3067: LD_INT 31
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: PUSH
3074: LD_INT 30
3076: PUSH
3077: LD_INT 32
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: PUSH
3084: EMPTY
3085: LIST
3086: LIST
3087: LIST
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: PPUSH
3093: CALL_OW 69
3097: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3098: LD_ADDR_VAR 0 8
3102: PUSH
3103: LD_INT 22
3105: PUSH
3106: LD_INT 3
3108: PUSH
3109: EMPTY
3110: LIST
3111: LIST
3112: PUSH
3113: LD_INT 30
3115: PUSH
3116: LD_INT 4
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: PUSH
3123: EMPTY
3124: LIST
3125: LIST
3126: PPUSH
3127: CALL_OW 69
3131: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3132: LD_ADDR_VAR 0 10
3136: PUSH
3137: LD_INT 22
3139: PUSH
3140: LD_INT 3
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: PUSH
3147: LD_INT 30
3149: PUSH
3150: LD_INT 3
3152: PUSH
3153: EMPTY
3154: LIST
3155: LIST
3156: PUSH
3157: EMPTY
3158: LIST
3159: LIST
3160: PPUSH
3161: CALL_OW 69
3165: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3166: LD_ADDR_VAR 0 9
3170: PUSH
3171: LD_INT 22
3173: PUSH
3174: LD_INT 3
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: PUSH
3181: LD_INT 30
3183: PUSH
3184: LD_INT 6
3186: PUSH
3187: EMPTY
3188: LIST
3189: LIST
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PPUSH
3195: CALL_OW 69
3199: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3200: LD_ADDR_VAR 0 2
3204: PUSH
3205: LD_INT 22
3207: PUSH
3208: LD_INT 3
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: PUSH
3215: LD_INT 30
3217: PUSH
3218: LD_INT 1
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: PPUSH
3229: CALL_OW 69
3233: PUSH
3234: FOR_IN
3235: IFFALSE 3279
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3237: LD_VAR 0 2
3241: PPUSH
3242: CALL_OW 274
3246: PPUSH
3247: LD_INT 1
3249: PPUSH
3250: LD_INT 5000
3252: PPUSH
3253: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3257: LD_VAR 0 2
3261: PPUSH
3262: CALL_OW 274
3266: PPUSH
3267: LD_INT 2
3269: PPUSH
3270: LD_INT 3000
3272: PPUSH
3273: CALL_OW 277
// end ;
3277: GO 3234
3279: POP
3280: POP
// uc_side := 3 ;
3281: LD_ADDR_OWVAR 20
3285: PUSH
3286: LD_INT 3
3288: ST_TO_ADDR
// uc_nation := 3 ;
3289: LD_ADDR_OWVAR 21
3293: PUSH
3294: LD_INT 3
3296: ST_TO_ADDR
// skill := [ 2 , 2 , 3 ] [ Difficulty ] ;
3297: LD_ADDR_VAR 0 11
3301: PUSH
3302: LD_INT 2
3304: PUSH
3305: LD_INT 2
3307: PUSH
3308: LD_INT 3
3310: PUSH
3311: EMPTY
3312: LIST
3313: LIST
3314: LIST
3315: PUSH
3316: LD_OWVAR 67
3320: ARRAY
3321: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3322: LD_ADDR_EXP 48
3326: PUSH
3327: LD_STRING Pokryshkin
3329: PPUSH
3330: LD_INT 0
3332: PPUSH
3333: CALL 450 0 2
3337: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3338: LD_EXP 48
3342: PPUSH
3343: LD_INT 63
3345: PPUSH
3346: LD_INT 21
3348: PPUSH
3349: LD_INT 0
3351: PPUSH
3352: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3356: LD_EXP 48
3360: PPUSH
3361: CALL_OW 140
// InitHc ;
3365: CALL_OW 19
// for i in fac do
3369: LD_ADDR_VAR 0 2
3373: PUSH
3374: LD_VAR 0 10
3378: PUSH
3379: FOR_IN
3380: IFFALSE 3433
// begin for j = 1 to 6 do
3382: LD_ADDR_VAR 0 3
3386: PUSH
3387: DOUBLE
3388: LD_INT 1
3390: DEC
3391: ST_TO_ADDR
3392: LD_INT 6
3394: PUSH
3395: FOR_TO
3396: IFFALSE 3429
// begin PrepareHuman ( false , 3 , skill ) ;
3398: LD_INT 0
3400: PPUSH
3401: LD_INT 3
3403: PPUSH
3404: LD_VAR 0 11
3408: PPUSH
3409: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3413: CALL_OW 44
3417: PPUSH
3418: LD_VAR 0 2
3422: PPUSH
3423: CALL_OW 52
// end ;
3427: GO 3395
3429: POP
3430: POP
// end ;
3431: GO 3379
3433: POP
3434: POP
// for i in lab do
3435: LD_ADDR_VAR 0 2
3439: PUSH
3440: LD_VAR 0 9
3444: PUSH
3445: FOR_IN
3446: IFFALSE 3479
// begin PrepareHuman ( false , 4 , skill ) ;
3448: LD_INT 0
3450: PPUSH
3451: LD_INT 4
3453: PPUSH
3454: LD_VAR 0 11
3458: PPUSH
3459: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3463: CALL_OW 44
3467: PPUSH
3468: LD_VAR 0 2
3472: PPUSH
3473: CALL_OW 52
// end ;
3477: GO 3445
3479: POP
3480: POP
// for i in tw do
3481: LD_ADDR_VAR 0 2
3485: PUSH
3486: LD_VAR 0 7
3490: PUSH
3491: FOR_IN
3492: IFFALSE 3541
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3494: LD_VAR 0 2
3498: PPUSH
3499: LD_INT 42
3501: PUSH
3502: LD_INT 43
3504: PUSH
3505: EMPTY
3506: LIST
3507: LIST
3508: PUSH
3509: LD_INT 1
3511: PPUSH
3512: LD_INT 2
3514: PPUSH
3515: CALL_OW 12
3519: ARRAY
3520: PPUSH
3521: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3525: LD_VAR 0 11
3529: PPUSH
3530: LD_VAR 0 2
3534: PPUSH
3535: CALL 791 0 2
// end ;
3539: GO 3491
3541: POP
3542: POP
// for i in bar do
3543: LD_ADDR_VAR 0 2
3547: PUSH
3548: LD_VAR 0 8
3552: PUSH
3553: FOR_IN
3554: IFFALSE 3587
// begin PrepareHuman ( false , 1 , skill ) ;
3556: LD_INT 0
3558: PPUSH
3559: LD_INT 1
3561: PPUSH
3562: LD_VAR 0 11
3566: PPUSH
3567: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3571: CALL_OW 44
3575: PPUSH
3576: LD_VAR 0 2
3580: PPUSH
3581: CALL_OW 52
// end ;
3585: GO 3553
3587: POP
3588: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3589: LD_ADDR_VAR 0 13
3593: PUSH
3594: LD_INT 100
3596: PUSH
3597: LD_INT 9
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: PUSH
3604: LD_INT 135
3606: PUSH
3607: LD_INT 60
3609: PUSH
3610: EMPTY
3611: LIST
3612: LIST
3613: PUSH
3614: LD_INT 41
3616: PUSH
3617: LD_INT 6
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: PUSH
3624: LD_INT 22
3626: PUSH
3627: LD_INT 9
3629: PUSH
3630: EMPTY
3631: LIST
3632: LIST
3633: PUSH
3634: LD_INT 84
3636: PUSH
3637: LD_INT 14
3639: PUSH
3640: EMPTY
3641: LIST
3642: LIST
3643: PUSH
3644: EMPTY
3645: LIST
3646: LIST
3647: LIST
3648: LIST
3649: LIST
3650: ST_TO_ADDR
// vehicles := [ ] ;
3651: LD_ADDR_VAR 0 12
3655: PUSH
3656: EMPTY
3657: ST_TO_ADDR
// for i in spot_xy do
3658: LD_ADDR_VAR 0 2
3662: PUSH
3663: LD_VAR 0 13
3667: PUSH
3668: FOR_IN
3669: IFFALSE 3827
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3671: LD_ADDR_VAR 0 6
3675: PUSH
3676: LD_INT 3
3678: PPUSH
3679: LD_INT 3
3681: PPUSH
3682: LD_INT 22
3684: PPUSH
3685: LD_INT 1
3687: PPUSH
3688: LD_INT 1
3690: PPUSH
3691: LD_INT 42
3693: PUSH
3694: LD_INT 43
3696: PUSH
3697: LD_INT 44
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: LIST
3704: PUSH
3705: LD_INT 1
3707: PPUSH
3708: LD_INT 3
3710: PPUSH
3711: CALL_OW 12
3715: ARRAY
3716: PPUSH
3717: LD_INT 100
3719: PPUSH
3720: CALL 513 0 7
3724: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3725: LD_ADDR_VAR 0 12
3729: PUSH
3730: LD_VAR 0 12
3734: PPUSH
3735: LD_VAR 0 12
3739: PUSH
3740: LD_INT 1
3742: PLUS
3743: PPUSH
3744: LD_VAR 0 6
3748: PPUSH
3749: CALL_OW 2
3753: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3754: LD_VAR 0 6
3758: PPUSH
3759: LD_INT 3
3761: PPUSH
3762: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3766: LD_VAR 0 6
3770: PPUSH
3771: LD_VAR 0 2
3775: PUSH
3776: LD_INT 1
3778: ARRAY
3779: PPUSH
3780: LD_VAR 0 2
3784: PUSH
3785: LD_INT 2
3787: ARRAY
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3796: LD_INT 0
3798: PPUSH
3799: LD_INT 3
3801: PPUSH
3802: LD_VAR 0 11
3806: PPUSH
3807: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3811: CALL_OW 44
3815: PPUSH
3816: LD_VAR 0 6
3820: PPUSH
3821: CALL_OW 52
// end ;
3825: GO 3668
3827: POP
3828: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3829: LD_ADDR_VAR 0 2
3833: PUSH
3834: DOUBLE
3835: LD_INT 1
3837: DEC
3838: ST_TO_ADDR
3839: LD_INT 5
3841: PUSH
3842: LD_INT 7
3844: PUSH
3845: LD_INT 8
3847: PUSH
3848: EMPTY
3849: LIST
3850: LIST
3851: LIST
3852: PUSH
3853: LD_OWVAR 67
3857: ARRAY
3858: PUSH
3859: FOR_TO
3860: IFFALSE 3920
// begin PrepareHuman ( false , 1 , skill ) ;
3862: LD_INT 0
3864: PPUSH
3865: LD_INT 1
3867: PPUSH
3868: LD_VAR 0 11
3872: PPUSH
3873: CALL_OW 380
// un := CreateHuman ;
3877: LD_ADDR_VAR 0 5
3881: PUSH
3882: CALL_OW 44
3886: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3887: LD_VAR 0 5
3891: PPUSH
3892: LD_INT 11
3894: PPUSH
3895: LD_INT 0
3897: PPUSH
3898: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3902: LD_ADDR_EXP 51
3906: PUSH
3907: LD_EXP 51
3911: PUSH
3912: LD_VAR 0 5
3916: ADD
3917: ST_TO_ADDR
// end ;
3918: GO 3859
3920: POP
3921: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3922: LD_ADDR_VAR 0 2
3926: PUSH
3927: DOUBLE
3928: LD_INT 1
3930: DEC
3931: ST_TO_ADDR
3932: LD_INT 2
3934: PUSH
3935: LD_INT 3
3937: PUSH
3938: LD_INT 4
3940: PUSH
3941: EMPTY
3942: LIST
3943: LIST
3944: LIST
3945: PUSH
3946: LD_OWVAR 67
3950: ARRAY
3951: PUSH
3952: FOR_TO
3953: IFFALSE 4013
// begin PrepareHuman ( false , 1 , skill ) ;
3955: LD_INT 0
3957: PPUSH
3958: LD_INT 1
3960: PPUSH
3961: LD_VAR 0 11
3965: PPUSH
3966: CALL_OW 380
// un := CreateHuman ;
3970: LD_ADDR_VAR 0 5
3974: PUSH
3975: CALL_OW 44
3979: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
3980: LD_VAR 0 5
3984: PPUSH
3985: LD_INT 12
3987: PPUSH
3988: LD_INT 0
3990: PPUSH
3991: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
3995: LD_ADDR_EXP 49
3999: PUSH
4000: LD_EXP 49
4004: PUSH
4005: LD_VAR 0 5
4009: ADD
4010: ST_TO_ADDR
// end ;
4011: GO 3952
4013: POP
4014: POP
// for i = 1 to 2 do
4015: LD_ADDR_VAR 0 2
4019: PUSH
4020: DOUBLE
4021: LD_INT 1
4023: DEC
4024: ST_TO_ADDR
4025: LD_INT 2
4027: PUSH
4028: FOR_TO
4029: IFFALSE 4095
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4031: LD_INT 1
4033: PPUSH
4034: LD_INT 1
4036: PPUSH
4037: LD_VAR 0 11
4041: PPUSH
4042: CALL_OW 380
// un := CreateHuman ;
4046: LD_ADDR_VAR 0 5
4050: PUSH
4051: CALL_OW 44
4055: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4056: LD_VAR 0 5
4060: PPUSH
4061: LD_INT 39
4063: PPUSH
4064: LD_INT 12
4066: PPUSH
4067: LD_INT 3
4069: PPUSH
4070: LD_INT 0
4072: PPUSH
4073: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4077: LD_ADDR_EXP 50
4081: PUSH
4082: LD_EXP 50
4086: PUSH
4087: LD_VAR 0 5
4091: ADD
4092: ST_TO_ADDR
// end ;
4093: GO 4028
4095: POP
4096: POP
// for i = 1 to 3 do
4097: LD_ADDR_VAR 0 2
4101: PUSH
4102: DOUBLE
4103: LD_INT 1
4105: DEC
4106: ST_TO_ADDR
4107: LD_INT 3
4109: PUSH
4110: FOR_TO
4111: IFFALSE 4177
// begin PrepareHuman ( false , 1 , skill ) ;
4113: LD_INT 0
4115: PPUSH
4116: LD_INT 1
4118: PPUSH
4119: LD_VAR 0 11
4123: PPUSH
4124: CALL_OW 380
// un := CreateHuman ;
4128: LD_ADDR_VAR 0 5
4132: PUSH
4133: CALL_OW 44
4137: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4138: LD_VAR 0 5
4142: PPUSH
4143: LD_INT 180
4145: PPUSH
4146: LD_INT 11
4148: PPUSH
4149: LD_INT 4
4151: PPUSH
4152: LD_INT 0
4154: PPUSH
4155: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4159: LD_ADDR_EXP 54
4163: PUSH
4164: LD_EXP 54
4168: PUSH
4169: LD_VAR 0 5
4173: ADD
4174: ST_TO_ADDR
// end ;
4175: GO 4110
4177: POP
4178: POP
// ru_vehicles := vehicles ;
4179: LD_ADDR_EXP 52
4183: PUSH
4184: LD_VAR 0 12
4188: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4189: LD_ADDR_EXP 55
4193: PUSH
4194: LD_INT 131
4196: PUSH
4197: LD_INT 121
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: PUSH
4204: LD_INT 113
4206: PUSH
4207: LD_INT 90
4209: PUSH
4210: EMPTY
4211: LIST
4212: LIST
4213: PUSH
4214: LD_INT 93
4216: PUSH
4217: LD_INT 62
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: PUSH
4224: EMPTY
4225: LIST
4226: LIST
4227: LIST
4228: PUSH
4229: LD_INT 106
4231: PUSH
4232: LD_INT 54
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: PUSH
4239: LD_INT 120
4241: PUSH
4242: LD_INT 80
4244: PUSH
4245: EMPTY
4246: LIST
4247: LIST
4248: PUSH
4249: LD_INT 143
4251: PUSH
4252: LD_INT 120
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 154
4266: PUSH
4267: LD_INT 116
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: PUSH
4274: LD_INT 140
4276: PUSH
4277: LD_INT 93
4279: PUSH
4280: EMPTY
4281: LIST
4282: LIST
4283: PUSH
4284: LD_INT 130
4286: PUSH
4287: LD_INT 58
4289: PUSH
4290: EMPTY
4291: LIST
4292: LIST
4293: PUSH
4294: EMPTY
4295: LIST
4296: LIST
4297: LIST
4298: PUSH
4299: LD_INT 105
4301: PUSH
4302: LD_INT 106
4304: PUSH
4305: EMPTY
4306: LIST
4307: LIST
4308: PUSH
4309: LD_INT 134
4311: PUSH
4312: LD_INT 98
4314: PUSH
4315: EMPTY
4316: LIST
4317: LIST
4318: PUSH
4319: LD_INT 159
4321: PUSH
4322: LD_INT 113
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: LIST
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: LIST
4338: LIST
4339: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4340: LD_ADDR_VAR 0 2
4344: PUSH
4345: DOUBLE
4346: LD_INT 1
4348: DEC
4349: ST_TO_ADDR
4350: LD_OWVAR 67
4354: PUSH
4355: LD_INT 1
4357: MINUS
4358: PUSH
4359: FOR_TO
4360: IFFALSE 4393
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4362: LD_ADDR_EXP 53
4366: PUSH
4367: LD_EXP 53
4371: PUSH
4372: LD_INT 22
4374: PUSH
4375: LD_INT 1
4377: PUSH
4378: LD_INT 1
4380: PUSH
4381: LD_INT 43
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: LIST
4388: LIST
4389: ADD
4390: ST_TO_ADDR
4391: GO 4359
4393: POP
4394: POP
// end ;
4395: LD_VAR 0 1
4399: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4400: LD_INT 22
4402: PUSH
4403: LD_INT 3
4405: PUSH
4406: EMPTY
4407: LIST
4408: LIST
4409: PUSH
4410: LD_INT 21
4412: PUSH
4413: LD_INT 2
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: EMPTY
4421: LIST
4422: LIST
4423: PPUSH
4424: CALL_OW 69
4428: IFFALSE 4522
4430: GO 4432
4432: DISABLE
4433: LD_INT 0
4435: PPUSH
4436: PPUSH
// begin enable ;
4437: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4438: LD_ADDR_VAR 0 2
4442: PUSH
4443: LD_INT 22
4445: PUSH
4446: LD_INT 3
4448: PUSH
4449: EMPTY
4450: LIST
4451: LIST
4452: PUSH
4453: LD_INT 21
4455: PUSH
4456: LD_INT 2
4458: PUSH
4459: EMPTY
4460: LIST
4461: LIST
4462: PUSH
4463: EMPTY
4464: LIST
4465: LIST
4466: PPUSH
4467: CALL_OW 69
4471: ST_TO_ADDR
// if filter then
4472: LD_VAR 0 2
4476: IFFALSE 4522
// for i in filter do
4478: LD_ADDR_VAR 0 1
4482: PUSH
4483: LD_VAR 0 2
4487: PUSH
4488: FOR_IN
4489: IFFALSE 4520
// if GetFuel ( i ) < 20 then
4491: LD_VAR 0 1
4495: PPUSH
4496: CALL_OW 261
4500: PUSH
4501: LD_INT 20
4503: LESS
4504: IFFALSE 4518
// SetFuel ( i , 20 ) ;
4506: LD_VAR 0 1
4510: PPUSH
4511: LD_INT 20
4513: PPUSH
4514: CALL_OW 240
4518: GO 4488
4520: POP
4521: POP
// end ;
4522: PPOPN 2
4524: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4525: LD_EXP 53
4529: IFFALSE 4748
4531: GO 4533
4533: DISABLE
4534: LD_INT 0
4536: PPUSH
4537: PPUSH
4538: PPUSH
// begin enable ;
4539: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4540: LD_ADDR_VAR 0 2
4544: PUSH
4545: LD_INT 22
4547: PUSH
4548: LD_INT 3
4550: PUSH
4551: EMPTY
4552: LIST
4553: LIST
4554: PUSH
4555: LD_INT 30
4557: PUSH
4558: LD_INT 3
4560: PUSH
4561: EMPTY
4562: LIST
4563: LIST
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PPUSH
4569: CALL_OW 69
4573: ST_TO_ADDR
// can_produce := [ ] ;
4574: LD_ADDR_VAR 0 3
4578: PUSH
4579: EMPTY
4580: ST_TO_ADDR
// if not fac then
4581: LD_VAR 0 2
4585: NOT
4586: IFFALSE 4591
// begin disable ;
4588: DISABLE
// exit ;
4589: GO 4748
// end ; for i in fac do
4591: LD_ADDR_VAR 0 1
4595: PUSH
4596: LD_VAR 0 2
4600: PUSH
4601: FOR_IN
4602: IFFALSE 4640
// if UnitsInside ( i ) then
4604: LD_VAR 0 1
4608: PPUSH
4609: CALL_OW 313
4613: IFFALSE 4638
// can_produce := Insert ( can_produce , 1 , i ) ;
4615: LD_ADDR_VAR 0 3
4619: PUSH
4620: LD_VAR 0 3
4624: PPUSH
4625: LD_INT 1
4627: PPUSH
4628: LD_VAR 0 1
4632: PPUSH
4633: CALL_OW 2
4637: ST_TO_ADDR
4638: GO 4601
4640: POP
4641: POP
// if not can_produce then
4642: LD_VAR 0 3
4646: NOT
4647: IFFALSE 4651
// exit ;
4649: GO 4748
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4651: LD_VAR 0 3
4655: PUSH
4656: LD_INT 1
4658: PPUSH
4659: LD_VAR 0 3
4663: PPUSH
4664: CALL_OW 12
4668: ARRAY
4669: PPUSH
4670: LD_EXP 53
4674: PUSH
4675: LD_INT 1
4677: ARRAY
4678: PPUSH
4679: LD_EXP 53
4683: PUSH
4684: LD_INT 2
4686: ARRAY
4687: PPUSH
4688: LD_EXP 53
4692: PUSH
4693: LD_INT 3
4695: ARRAY
4696: PPUSH
4697: LD_EXP 53
4701: PUSH
4702: LD_INT 4
4704: ARRAY
4705: PPUSH
4706: CALL_OW 125
// for i = 1 to 4 do
4710: LD_ADDR_VAR 0 1
4714: PUSH
4715: DOUBLE
4716: LD_INT 1
4718: DEC
4719: ST_TO_ADDR
4720: LD_INT 4
4722: PUSH
4723: FOR_TO
4724: IFFALSE 4746
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4726: LD_ADDR_EXP 53
4730: PUSH
4731: LD_EXP 53
4735: PPUSH
4736: LD_INT 1
4738: PPUSH
4739: CALL_OW 3
4743: ST_TO_ADDR
4744: GO 4723
4746: POP
4747: POP
// end ;
4748: PPOPN 3
4750: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4751: LD_INT 0
4753: PPUSH
4754: PPUSH
4755: PPUSH
// for i = 1 to 6 do
4756: LD_ADDR_VAR 0 2
4760: PUSH
4761: DOUBLE
4762: LD_INT 1
4764: DEC
4765: ST_TO_ADDR
4766: LD_INT 6
4768: PUSH
4769: FOR_TO
4770: IFFALSE 4919
// begin PrepareHuman ( false , 3 , 3 ) ;
4772: LD_INT 0
4774: PPUSH
4775: LD_INT 3
4777: PPUSH
4778: LD_INT 3
4780: PPUSH
4781: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4785: LD_ADDR_VAR 0 3
4789: PUSH
4790: LD_INT 3
4792: PPUSH
4793: LD_INT 3
4795: PPUSH
4796: LD_INT 22
4798: PPUSH
4799: LD_INT 1
4801: PPUSH
4802: LD_INT 1
4804: PPUSH
4805: LD_INT 43
4807: PUSH
4808: LD_INT 42
4810: PUSH
4811: EMPTY
4812: LIST
4813: LIST
4814: PUSH
4815: LD_INT 1
4817: PPUSH
4818: LD_INT 2
4820: PPUSH
4821: CALL_OW 12
4825: ARRAY
4826: PPUSH
4827: LD_INT 70
4829: PPUSH
4830: CALL 513 0 7
4834: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4835: LD_VAR 0 3
4839: PPUSH
4840: LD_INT 4
4842: PPUSH
4843: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4847: LD_VAR 0 3
4851: PPUSH
4852: LD_INT 229
4854: PPUSH
4855: LD_INT 44
4857: PPUSH
4858: LD_INT 0
4860: PPUSH
4861: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4865: CALL_OW 44
4869: PPUSH
4870: LD_VAR 0 3
4874: PPUSH
4875: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4879: LD_ADDR_EXP 52
4883: PUSH
4884: LD_EXP 52
4888: PUSH
4889: LD_VAR 0 3
4893: ADD
4894: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
4895: LD_VAR 0 3
4899: PPUSH
4900: LD_INT 191
4902: PPUSH
4903: LD_INT 32
4905: PPUSH
4906: CALL_OW 111
// Wait ( 0 0$02 ) ;
4910: LD_INT 70
4912: PPUSH
4913: CALL_OW 67
// end ;
4917: GO 4769
4919: POP
4920: POP
// end ; end_of_file
4921: LD_VAR 0 1
4925: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
4926: LD_INT 0
4928: PPUSH
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
4933: PPUSH
4934: PPUSH
// InGameOn ;
4935: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
4939: LD_EXP 33
4943: PPUSH
4944: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
4948: LD_EXP 33
4952: PPUSH
4953: LD_EXP 40
4957: PPUSH
4958: CALL_OW 119
// if Bierezov then
4962: LD_EXP 41
4966: IFFALSE 4982
// ComTurnUnit ( Bierezov , Cornel ) ;
4968: LD_EXP 41
4972: PPUSH
4973: LD_EXP 40
4977: PPUSH
4978: CALL_OW 119
// for i in jmm_units do
4982: LD_ADDR_VAR 0 2
4986: PUSH
4987: LD_EXP 4
4991: PUSH
4992: FOR_IN
4993: IFFALSE 5011
// ComTurnUnit ( i , Cornel ) ;
4995: LD_VAR 0 2
4999: PPUSH
5000: LD_EXP 40
5004: PPUSH
5005: CALL_OW 119
5009: GO 4992
5011: POP
5012: POP
// units := cornel_units union Cornel ;
5013: LD_ADDR_VAR 0 3
5017: PUSH
5018: LD_EXP 6
5022: PUSH
5023: LD_EXP 40
5027: UNION
5028: ST_TO_ADDR
// repeat wait ( 1 ) ;
5029: LD_INT 1
5031: PPUSH
5032: CALL_OW 67
// for i in units do
5036: LD_ADDR_VAR 0 2
5040: PUSH
5041: LD_VAR 0 3
5045: PUSH
5046: FOR_IN
5047: IFFALSE 5080
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5049: LD_VAR 0 2
5053: PPUSH
5054: LD_EXP 33
5058: PPUSH
5059: CALL_OW 250
5063: PPUSH
5064: LD_EXP 33
5068: PPUSH
5069: CALL_OW 251
5073: PPUSH
5074: CALL_OW 111
5078: GO 5046
5080: POP
5081: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5082: LD_VAR 0 3
5086: PPUSH
5087: LD_INT 92
5089: PUSH
5090: LD_EXP 33
5094: PPUSH
5095: CALL_OW 250
5099: PUSH
5100: LD_EXP 33
5104: PPUSH
5105: CALL_OW 251
5109: PUSH
5110: LD_INT 10
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: LIST
5117: LIST
5118: PPUSH
5119: CALL_OW 72
5123: PUSH
5124: LD_VAR 0 3
5128: EQUAL
5129: IFFALSE 5029
// for i in units do
5131: LD_ADDR_VAR 0 2
5135: PUSH
5136: LD_VAR 0 3
5140: PUSH
5141: FOR_IN
5142: IFFALSE 5160
// ComTurnUnit ( i , JMM ) ;
5144: LD_VAR 0 2
5148: PPUSH
5149: LD_EXP 33
5153: PPUSH
5154: CALL_OW 119
5158: GO 5141
5160: POP
5161: POP
// ComTurnUnit ( Cornel , JMM ) ;
5162: LD_EXP 40
5166: PPUSH
5167: LD_EXP 33
5171: PPUSH
5172: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5176: LD_EXP 33
5180: PPUSH
5181: LD_STRING D1-JMM-1
5183: PPUSH
5184: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5188: LD_EXP 40
5192: PPUSH
5193: LD_STRING D1-Corn-1
5195: PPUSH
5196: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5200: LD_EXP 33
5204: PPUSH
5205: LD_EXP 40
5209: PPUSH
5210: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5214: LD_EXP 40
5218: PPUSH
5219: LD_EXP 33
5223: PPUSH
5224: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5228: LD_INT 35
5230: PPUSH
5231: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5235: LD_EXP 33
5239: PPUSH
5240: LD_EXP 40
5244: PPUSH
5245: CALL_OW 296
5249: PUSH
5250: LD_INT 6
5252: LESS
5253: IFFALSE 5228
// ChangeSideFog ( 4 , 1 ) ;
5255: LD_INT 4
5257: PPUSH
5258: LD_INT 1
5260: PPUSH
5261: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5265: LD_EXP 33
5269: PPUSH
5270: LD_EXP 40
5274: PPUSH
5275: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5279: LD_EXP 40
5283: PPUSH
5284: LD_EXP 33
5288: PPUSH
5289: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5293: LD_EXP 33
5297: PPUSH
5298: LD_STRING D1-JMM-2
5300: PPUSH
5301: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5305: LD_EXP 33
5309: PPUSH
5310: LD_STRING D1-JMM-2a
5312: PPUSH
5313: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5317: LD_EXP 40
5321: PPUSH
5322: LD_STRING D1-Corn-2
5324: PPUSH
5325: CALL_OW 88
// if bierezov_exist or debug then
5329: LD_EXP 7
5333: PUSH
5334: LD_EXP 1
5338: OR
5339: IFFALSE 5580
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5341: LD_EXP 40
5345: PPUSH
5346: LD_EXP 41
5350: PPUSH
5351: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5355: LD_INT 10
5357: PPUSH
5358: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5362: LD_EXP 40
5366: PPUSH
5367: LD_STRING D1a-Corn-1
5369: PPUSH
5370: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5374: LD_EXP 33
5378: PPUSH
5379: LD_EXP 41
5383: PPUSH
5384: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5388: LD_EXP 41
5392: PPUSH
5393: LD_EXP 33
5397: PPUSH
5398: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5402: LD_EXP 33
5406: PPUSH
5407: LD_STRING D1a-JMM-1
5409: PPUSH
5410: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5414: LD_EXP 33
5418: PPUSH
5419: LD_EXP 40
5423: PPUSH
5424: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5428: LD_EXP 40
5432: PPUSH
5433: LD_EXP 33
5437: PPUSH
5438: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5442: LD_EXP 40
5446: PPUSH
5447: LD_STRING D1a-Corn-2
5449: PPUSH
5450: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5454: LD_EXP 33
5458: PPUSH
5459: LD_STRING D1a-JMM-2
5461: PPUSH
5462: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5466: LD_EXP 40
5470: PPUSH
5471: LD_STRING D1a-Corn-3
5473: PPUSH
5474: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5478: LD_EXP 33
5482: PPUSH
5483: LD_STRING D1a-JMM-3
5485: PPUSH
5486: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5490: LD_EXP 40
5494: PPUSH
5495: LD_STRING D1a-Corn-4
5497: PPUSH
5498: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5502: LD_EXP 33
5506: PPUSH
5507: LD_STRING D1a-JMM-4
5509: PPUSH
5510: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5514: LD_EXP 40
5518: PPUSH
5519: LD_STRING D1a-Corn-5
5521: PPUSH
5522: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5526: LD_EXP 41
5530: PPUSH
5531: LD_EXP 40
5535: PPUSH
5536: CALL_OW 250
5540: PPUSH
5541: LD_EXP 40
5545: PPUSH
5546: CALL_OW 251
5550: PUSH
5551: LD_INT 2
5553: MINUS
5554: PPUSH
5555: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5559: LD_EXP 41
5563: PPUSH
5564: LD_EXP 40
5568: PPUSH
5569: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5573: LD_INT 10
5575: PPUSH
5576: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5580: LD_EXP 33
5584: PPUSH
5585: LD_STRING D1b-JMM-1
5587: PPUSH
5588: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5592: LD_EXP 40
5596: PPUSH
5597: LD_STRING D1b-Corn-1
5599: PPUSH
5600: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5604: LD_EXP 33
5608: PPUSH
5609: LD_STRING D1b-JMM-2
5611: PPUSH
5612: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5616: LD_EXP 40
5620: PPUSH
5621: LD_STRING D1b-Corn-2
5623: PPUSH
5624: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5628: LD_EXP 33
5632: PPUSH
5633: LD_STRING D1b-JMM-3
5635: PPUSH
5636: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5640: LD_INT 10
5642: PPUSH
5643: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5647: LD_EXP 42
5651: PPUSH
5652: LD_STRING D1b-Pow-3
5654: PPUSH
5655: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5659: LD_EXP 33
5663: PPUSH
5664: LD_STRING D1b-JMM-4
5666: PPUSH
5667: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5671: LD_EXP 40
5675: PPUSH
5676: LD_STRING D1b-Corn-4
5678: PPUSH
5679: CALL_OW 88
// if Khatam then
5683: LD_EXP 37
5687: IFFALSE 5703
// Say ( Khatam , D1b-Khat-4 ) else
5689: LD_EXP 37
5693: PPUSH
5694: LD_STRING D1b-Khat-4
5696: PPUSH
5697: CALL_OW 88
5701: GO 5739
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
5703: LD_EXP 6
5707: PPUSH
5708: LD_INT 26
5710: PUSH
5711: LD_INT 1
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: PPUSH
5718: CALL_OW 72
5722: PUSH
5723: LD_EXP 40
5727: PUSH
5728: EMPTY
5729: LIST
5730: DIFF
5731: PPUSH
5732: LD_STRING D1b-Sol1-4
5734: PPUSH
5735: CALL 601 0 2
// if Cyrus then
5739: LD_EXP 35
5743: IFFALSE 5757
// Say ( Cyrus , D1b-Cyrus-4 ) ;
5745: LD_EXP 35
5749: PPUSH
5750: LD_STRING D1b-Cyrus-4
5752: PPUSH
5753: CALL_OW 88
// if Lisa then
5757: LD_EXP 36
5761: IFFALSE 5819
// begin Say ( Lisa , D1b-Lisa-4 ) ;
5763: LD_EXP 36
5767: PPUSH
5768: LD_STRING D1b-Lisa-4
5770: PPUSH
5771: CALL_OW 88
// if Cyrus then
5775: LD_EXP 35
5779: IFFALSE 5819
// begin if not IsInUnit ( Cyrus ) then
5781: LD_EXP 35
5785: PPUSH
5786: CALL_OW 310
5790: NOT
5791: IFFALSE 5807
// ComTurnUnit ( Cyrus , Lisa ) ;
5793: LD_EXP 35
5797: PPUSH
5798: LD_EXP 36
5802: PPUSH
5803: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
5807: LD_EXP 35
5811: PPUSH
5812: LD_STRING D1b-Cyrus-5
5814: PPUSH
5815: CALL_OW 88
// end ; end ; SelectGroup ;
5819: CALL 2554 0 0
// Say ( JMM , D1d-JMM-1 ) ;
5823: LD_EXP 33
5827: PPUSH
5828: LD_STRING D1d-JMM-1
5830: PPUSH
5831: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
5835: LD_EXP 40
5839: PPUSH
5840: LD_STRING D1d-Corn-1
5842: PPUSH
5843: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
5847: LD_ADDR_VAR 0 2
5851: PUSH
5852: LD_EXP 4
5856: PUSH
5857: LD_EXP 6
5861: ADD
5862: PUSH
5863: LD_EXP 33
5867: ADD
5868: PUSH
5869: FOR_IN
5870: IFFALSE 5883
// ComHold ( i ) ;
5872: LD_VAR 0 2
5876: PPUSH
5877: CALL_OW 140
5881: GO 5869
5883: POP
5884: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
5885: LD_ADDR_VAR 0 4
5889: PUSH
5890: LD_INT 22
5892: PUSH
5893: LD_INT 1
5895: PUSH
5896: EMPTY
5897: LIST
5898: LIST
5899: PUSH
5900: LD_INT 21
5902: PUSH
5903: LD_INT 2
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: PPUSH
5914: CALL_OW 69
5918: ST_TO_ADDR
// if vehicles then
5919: LD_VAR 0 4
5923: IFFALSE 6261
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
5925: LD_EXP 6
5929: PPUSH
5930: LD_INT 55
5932: PUSH
5933: EMPTY
5934: LIST
5935: PPUSH
5936: CALL_OW 72
5940: IFFALSE 5979
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
5942: LD_ADDR_VAR 0 2
5946: PUSH
5947: LD_EXP 6
5951: PPUSH
5952: LD_INT 55
5954: PUSH
5955: EMPTY
5956: LIST
5957: PPUSH
5958: CALL_OW 72
5962: PUSH
5963: FOR_IN
5964: IFFALSE 5977
// ComExitVehicle ( i ) ;
5966: LD_VAR 0 2
5970: PPUSH
5971: CALL_OW 121
5975: GO 5963
5977: POP
5978: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
5979: LD_ADDR_VAR 0 5
5983: PUSH
5984: LD_VAR 0 4
5988: PPUSH
5989: LD_INT 34
5991: PUSH
5992: LD_INT 51
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: PPUSH
5999: CALL_OW 72
6003: ST_TO_ADDR
// if cargos then
6004: LD_VAR 0 5
6008: IFFALSE 6191
// begin vehicles := cargos ;
6010: LD_ADDR_VAR 0 4
6014: PUSH
6015: LD_VAR 0 5
6019: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6020: LD_ADDR_VAR 0 6
6024: PUSH
6025: LD_STRING 02_resources_4
6027: PPUSH
6028: LD_INT 0
6030: PPUSH
6031: CALL_OW 30
6035: ST_TO_ADDR
// if debug and not resources then
6036: LD_EXP 1
6040: PUSH
6041: LD_VAR 0 6
6045: NOT
6046: AND
6047: IFFALSE 6057
// resources := 160 ;
6049: LD_ADDR_VAR 0 6
6053: PUSH
6054: LD_INT 160
6056: ST_TO_ADDR
// if resources mod 10 then
6057: LD_VAR 0 6
6061: PUSH
6062: LD_INT 10
6064: MOD
6065: IFFALSE 6087
// resources := resources - resources mod 10 ;
6067: LD_ADDR_VAR 0 6
6071: PUSH
6072: LD_VAR 0 6
6076: PUSH
6077: LD_VAR 0 6
6081: PUSH
6082: LD_INT 10
6084: MOD
6085: MINUS
6086: ST_TO_ADDR
// if resources then
6087: LD_VAR 0 6
6091: IFFALSE 6191
// for i in cargos do
6093: LD_ADDR_VAR 0 2
6097: PUSH
6098: LD_VAR 0 5
6102: PUSH
6103: FOR_IN
6104: IFFALSE 6189
// begin if resources < 100 then
6106: LD_VAR 0 6
6110: PUSH
6111: LD_INT 100
6113: LESS
6114: IFFALSE 6136
// begin cargo := resources ;
6116: LD_ADDR_VAR 0 7
6120: PUSH
6121: LD_VAR 0 6
6125: ST_TO_ADDR
// resources := 0 ;
6126: LD_ADDR_VAR 0 6
6130: PUSH
6131: LD_INT 0
6133: ST_TO_ADDR
// end else
6134: GO 6158
// begin cargo := 100 ;
6136: LD_ADDR_VAR 0 7
6140: PUSH
6141: LD_INT 100
6143: ST_TO_ADDR
// resources := resources - 100 ;
6144: LD_ADDR_VAR 0 6
6148: PUSH
6149: LD_VAR 0 6
6153: PUSH
6154: LD_INT 100
6156: MINUS
6157: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6158: LD_VAR 0 2
6162: PPUSH
6163: LD_INT 1
6165: PPUSH
6166: LD_VAR 0 7
6170: PPUSH
6171: CALL_OW 290
// if resources = 0 then
6175: LD_VAR 0 6
6179: PUSH
6180: LD_INT 0
6182: EQUAL
6183: IFFALSE 6187
// break ;
6185: GO 6189
// end ;
6187: GO 6103
6189: POP
6190: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6191: LD_VAR 0 4
6195: PUSH
6196: LD_INT 1
6198: ARRAY
6199: PPUSH
6200: CALL_OW 311
6204: PPUSH
6205: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6209: LD_VAR 0 4
6213: PUSH
6214: LD_INT 1
6216: ARRAY
6217: PPUSH
6218: LD_INT 4
6220: PPUSH
6221: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6225: LD_EXP 40
6229: PPUSH
6230: LD_VAR 0 4
6234: PUSH
6235: LD_INT 1
6237: ARRAY
6238: PPUSH
6239: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6243: LD_INT 35
6245: PPUSH
6246: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6250: LD_EXP 40
6254: PPUSH
6255: CALL_OW 310
6259: IFFALSE 6243
// end ; InGameOff ;
6261: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6265: LD_STRING M1
6267: PPUSH
6268: CALL_OW 337
// SaveForQuickRestart ;
6272: CALL_OW 22
// cornel_active := true ;
6276: LD_ADDR_EXP 8
6280: PUSH
6281: LD_INT 1
6283: ST_TO_ADDR
// end ;
6284: LD_VAR 0 1
6288: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
6289: LD_EXP 33
6293: PPUSH
6294: LD_EXP 43
6298: PPUSH
6299: CALL_OW 296
6303: PUSH
6304: LD_INT 10
6306: LESS
6307: IFFALSE 7463
6309: GO 6311
6311: DISABLE
6312: LD_INT 0
6314: PPUSH
6315: PPUSH
6316: PPUSH
6317: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6318: LD_ADDR_VAR 0 2
6322: PUSH
6323: LD_INT 89
6325: PUSH
6326: LD_INT 34
6328: PUSH
6329: EMPTY
6330: LIST
6331: LIST
6332: PUSH
6333: LD_INT 138
6335: PUSH
6336: LD_INT 63
6338: PUSH
6339: EMPTY
6340: LIST
6341: LIST
6342: PUSH
6343: LD_INT 196
6345: PUSH
6346: LD_INT 84
6348: PUSH
6349: EMPTY
6350: LIST
6351: LIST
6352: PUSH
6353: LD_INT 135
6355: PUSH
6356: LD_INT 52
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: PUSH
6363: LD_INT 103
6365: PUSH
6366: LD_INT 39
6368: PUSH
6369: EMPTY
6370: LIST
6371: LIST
6372: PUSH
6373: LD_INT 58
6375: PUSH
6376: LD_INT 30
6378: PUSH
6379: EMPTY
6380: LIST
6381: LIST
6382: PUSH
6383: LD_INT 38
6385: PUSH
6386: LD_INT 51
6388: PUSH
6389: EMPTY
6390: LIST
6391: LIST
6392: PUSH
6393: EMPTY
6394: LIST
6395: LIST
6396: LIST
6397: LIST
6398: LIST
6399: LIST
6400: LIST
6401: ST_TO_ADDR
// InGameOn ;
6402: CALL_OW 8
// if jmm_units then
6406: LD_EXP 4
6410: IFFALSE 6474
// for i in jmm_units do
6412: LD_ADDR_VAR 0 1
6416: PUSH
6417: LD_EXP 4
6421: PUSH
6422: FOR_IN
6423: IFFALSE 6472
// begin if GetDistUnits ( i , JMM ) < 10 then
6425: LD_VAR 0 1
6429: PPUSH
6430: LD_EXP 33
6434: PPUSH
6435: CALL_OW 296
6439: PUSH
6440: LD_INT 10
6442: LESS
6443: IFFALSE 6461
// ComTurnUnit ( i , JMM ) else
6445: LD_VAR 0 1
6449: PPUSH
6450: LD_EXP 33
6454: PPUSH
6455: CALL_OW 119
6459: GO 6470
// ComHold ( i ) ;
6461: LD_VAR 0 1
6465: PPUSH
6466: CALL_OW 140
// end ;
6470: GO 6422
6472: POP
6473: POP
// if IsInUnit ( JMM ) then
6474: LD_EXP 33
6478: PPUSH
6479: CALL_OW 310
6483: IFFALSE 6508
// begin ComExitVehicle ( JMM ) ;
6485: LD_EXP 33
6489: PPUSH
6490: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6494: LD_EXP 33
6498: PPUSH
6499: LD_EXP 43
6503: PPUSH
6504: CALL_OW 172
// end ; Wait ( 10 ) ;
6508: LD_INT 10
6510: PPUSH
6511: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6515: LD_EXP 33
6519: PPUSH
6520: LD_EXP 43
6524: PPUSH
6525: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6529: LD_INT 35
6531: PPUSH
6532: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6536: LD_EXP 33
6540: PPUSH
6541: LD_EXP 43
6545: PPUSH
6546: CALL_OW 296
6550: PUSH
6551: LD_INT 6
6553: LESS
6554: IFFALSE 6529
// ComTurnUnit ( JMM , Lynch ) ;
6556: LD_EXP 33
6560: PPUSH
6561: LD_EXP 43
6565: PPUSH
6566: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6570: LD_ADDR_VAR 0 1
6574: PUSH
6575: LD_EXP 43
6579: PUSH
6580: LD_EXP 44
6584: PUSH
6585: LD_EXP 45
6589: PUSH
6590: LD_EXP 46
6594: PUSH
6595: EMPTY
6596: LIST
6597: LIST
6598: LIST
6599: LIST
6600: PUSH
6601: FOR_IN
6602: IFFALSE 6620
// ComTurnUnit ( i , JMM ) ;
6604: LD_VAR 0 1
6608: PPUSH
6609: LD_EXP 33
6613: PPUSH
6614: CALL_OW 119
6618: GO 6601
6620: POP
6621: POP
// Wait ( 0 0$0.3 ) ;
6622: LD_INT 10
6624: PPUSH
6625: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6629: LD_EXP 33
6633: PPUSH
6634: LD_STRING D2-JMM-1
6636: PPUSH
6637: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6641: LD_EXP 43
6645: PPUSH
6646: LD_STRING D2-Sol1-1
6648: PPUSH
6649: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6653: LD_EXP 33
6657: PPUSH
6658: LD_STRING D2-JMM-2
6660: PPUSH
6661: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6665: LD_EXP 43
6669: PPUSH
6670: LD_STRING D2-Sol1-2
6672: PPUSH
6673: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6677: LD_EXP 33
6681: PPUSH
6682: LD_STRING D2-JMM-3
6684: PPUSH
6685: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
6689: LD_EXP 43
6693: PPUSH
6694: LD_STRING D2-Sol1-3
6696: PPUSH
6697: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6701: LD_ADDR_VAR 0 1
6705: PUSH
6706: LD_INT 22
6708: PUSH
6709: LD_INT 8
6711: PUSH
6712: EMPTY
6713: LIST
6714: LIST
6715: PPUSH
6716: CALL_OW 69
6720: PUSH
6721: FOR_IN
6722: IFFALSE 6738
// SetSide ( i , 1 ) ;
6724: LD_VAR 0 1
6728: PPUSH
6729: LD_INT 1
6731: PPUSH
6732: CALL_OW 235
6736: GO 6721
6738: POP
6739: POP
// Say ( JMM , D2-JMM-4 ) ;
6740: LD_EXP 33
6744: PPUSH
6745: LD_STRING D2-JMM-4
6747: PPUSH
6748: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
6752: LD_INT 1
6754: PPUSH
6755: LD_INT 5
6757: PPUSH
6758: CALL_OW 332
// for i = 1 to points do
6762: LD_ADDR_VAR 0 1
6766: PUSH
6767: DOUBLE
6768: LD_INT 1
6770: DEC
6771: ST_TO_ADDR
6772: LD_VAR 0 2
6776: PUSH
6777: FOR_TO
6778: IFFALSE 6953
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6780: LD_VAR 0 2
6784: PUSH
6785: LD_VAR 0 1
6789: ARRAY
6790: PUSH
6791: LD_INT 1
6793: ARRAY
6794: PPUSH
6795: LD_VAR 0 2
6799: PUSH
6800: LD_VAR 0 1
6804: ARRAY
6805: PUSH
6806: LD_INT 2
6808: ARRAY
6809: PPUSH
6810: CALL_OW 84
// if i = 1 then
6814: LD_VAR 0 1
6818: PUSH
6819: LD_INT 1
6821: EQUAL
6822: IFFALSE 6836
// Say ( Lynch , D2-Sol1-4 ) ;
6824: LD_EXP 43
6828: PPUSH
6829: LD_STRING D2-Sol1-4
6831: PPUSH
6832: CALL_OW 88
// if i = 2 then
6836: LD_VAR 0 1
6840: PUSH
6841: LD_INT 2
6843: EQUAL
6844: IFFALSE 6858
// Say ( JMM , D2-JMM-5 ) ;
6846: LD_EXP 33
6850: PPUSH
6851: LD_STRING D2-JMM-5
6853: PPUSH
6854: CALL_OW 88
// if i = 4 then
6858: LD_VAR 0 1
6862: PUSH
6863: LD_INT 4
6865: EQUAL
6866: IFFALSE 6890
// begin RevealFogArea ( 1 , troopsArea ) ;
6868: LD_INT 1
6870: PPUSH
6871: LD_INT 6
6873: PPUSH
6874: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
6878: LD_EXP 43
6882: PPUSH
6883: LD_STRING D2-Sol1-5
6885: PPUSH
6886: CALL_OW 88
// end ; if i = 5 then
6890: LD_VAR 0 1
6894: PUSH
6895: LD_INT 5
6897: EQUAL
6898: IFFALSE 6912
// Say ( JMM , D2-JMM-6 ) ;
6900: LD_EXP 33
6904: PPUSH
6905: LD_STRING D2-JMM-6
6907: PPUSH
6908: CALL_OW 88
// if i = 7 then
6912: LD_VAR 0 1
6916: PUSH
6917: LD_INT 7
6919: EQUAL
6920: IFFALSE 6944
// begin RevealFogArea ( 1 , forestArea ) ;
6922: LD_INT 1
6924: PPUSH
6925: LD_INT 7
6927: PPUSH
6928: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
6932: LD_EXP 43
6936: PPUSH
6937: LD_STRING D2-Sol1-6
6939: PPUSH
6940: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
6944: LD_INT 46
6946: PPUSH
6947: CALL_OW 67
// end ;
6951: GO 6777
6953: POP
6954: POP
// CenterNowOnUnits ( JMM ) ;
6955: LD_EXP 33
6959: PPUSH
6960: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
6964: LD_EXP 33
6968: PPUSH
6969: LD_STRING D2-JMM-7
6971: PPUSH
6972: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
6976: LD_EXP 43
6980: PPUSH
6981: LD_STRING D2-Sol1-7
6983: PPUSH
6984: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
6988: LD_EXP 33
6992: PPUSH
6993: LD_STRING D2-JMM-8
6995: PPUSH
6996: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7000: LD_ADDR_VAR 0 4
7004: PUSH
7005: LD_INT 22
7007: PUSH
7008: LD_INT 1
7010: PUSH
7011: EMPTY
7012: LIST
7013: LIST
7014: PUSH
7015: LD_INT 30
7017: PUSH
7018: LD_INT 31
7020: PUSH
7021: EMPTY
7022: LIST
7023: LIST
7024: PUSH
7025: EMPTY
7026: LIST
7027: LIST
7028: PPUSH
7029: CALL_OW 69
7033: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7034: LD_EXP 43
7038: PPUSH
7039: LD_VAR 0 4
7043: PUSH
7044: LD_INT 1
7046: ARRAY
7047: PPUSH
7048: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7052: LD_ADDR_VAR 0 3
7056: PUSH
7057: LD_EXP 4
7061: PPUSH
7062: LD_INT 25
7064: PUSH
7065: LD_INT 1
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: PPUSH
7072: CALL_OW 72
7076: PPUSH
7077: LD_EXP 33
7081: PPUSH
7082: CALL_OW 74
7086: ST_TO_ADDR
// if sol then
7087: LD_VAR 0 3
7091: IFFALSE 7131
// if GetDistUnits ( JMM , sol ) < 10 then
7093: LD_EXP 33
7097: PPUSH
7098: LD_VAR 0 3
7102: PPUSH
7103: CALL_OW 296
7107: PUSH
7108: LD_INT 10
7110: LESS
7111: IFFALSE 7131
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7113: LD_VAR 0 3
7117: PPUSH
7118: LD_VAR 0 4
7122: PUSH
7123: LD_INT 2
7125: ARRAY
7126: PPUSH
7127: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7131: LD_INT 10
7133: PPUSH
7134: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7138: LD_EXP 33
7142: PPUSH
7143: LD_INT 65
7145: PPUSH
7146: LD_INT 101
7148: PPUSH
7149: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7153: LD_EXP 33
7157: PPUSH
7158: LD_INT 63
7160: PPUSH
7161: LD_INT 100
7163: PPUSH
7164: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
7168: LD_INT 35
7170: PPUSH
7171: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
7175: LD_EXP 33
7179: PPUSH
7180: LD_INT 65
7182: PPUSH
7183: LD_INT 101
7185: PPUSH
7186: CALL_OW 307
7190: IFFALSE 7168
// Say ( JMM , D2a-JMM-1 ) ;
7192: LD_EXP 33
7196: PPUSH
7197: LD_STRING D2a-JMM-1
7199: PPUSH
7200: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7204: LD_EXP 44
7208: PPUSH
7209: LD_INT 66
7211: PPUSH
7212: LD_INT 103
7214: PPUSH
7215: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
7219: LD_INT 35
7221: PPUSH
7222: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
7226: LD_EXP 44
7230: PPUSH
7231: LD_INT 66
7233: PPUSH
7234: LD_INT 103
7236: PPUSH
7237: CALL_OW 307
7241: IFFALSE 7219
// ComTurnUnit ( Walker , JMM ) ;
7243: LD_EXP 44
7247: PPUSH
7248: LD_EXP 33
7252: PPUSH
7253: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7257: LD_EXP 44
7261: PPUSH
7262: LD_STRING D2a-Sci1-1
7264: PPUSH
7265: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7269: LD_EXP 33
7273: PPUSH
7274: LD_EXP 44
7278: PPUSH
7279: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7283: LD_EXP 33
7287: PPUSH
7288: LD_STRING D2a-JMM-2
7290: PPUSH
7291: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7295: LD_EXP 44
7299: PPUSH
7300: LD_STRING D2a-Sci1-2
7302: PPUSH
7303: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7307: LD_EXP 33
7311: PPUSH
7312: LD_STRING D2a-JMM-3
7314: PPUSH
7315: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7319: LD_EXP 44
7323: PPUSH
7324: LD_STRING D2a-Sci1-3
7326: PPUSH
7327: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7331: LD_ADDR_EXP 4
7335: PUSH
7336: LD_EXP 4
7340: PUSH
7341: LD_EXP 43
7345: PUSH
7346: LD_EXP 44
7350: PUSH
7351: LD_EXP 45
7355: PUSH
7356: LD_EXP 46
7360: PUSH
7361: EMPTY
7362: LIST
7363: LIST
7364: LIST
7365: LIST
7366: ADD
7367: ST_TO_ADDR
// for i in jmm_units do
7368: LD_ADDR_VAR 0 1
7372: PUSH
7373: LD_EXP 4
7377: PUSH
7378: FOR_IN
7379: IFFALSE 7404
// if not IsInUnit ( i ) then
7381: LD_VAR 0 1
7385: PPUSH
7386: CALL_OW 310
7390: NOT
7391: IFFALSE 7402
// ComFree ( i ) ;
7393: LD_VAR 0 1
7397: PPUSH
7398: CALL_OW 139
7402: GO 7378
7404: POP
7405: POP
// InGameOff ;
7406: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
7410: LD_STRING MSolar1
7412: PPUSH
7413: CALL_OW 337
// jmm_on_west := true ;
7417: LD_ADDR_EXP 5
7421: PUSH
7422: LD_INT 1
7424: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7425: LD_INT 1050
7427: PPUSH
7428: CALL_OW 67
// frank_can_return := true ;
7432: LD_ADDR_EXP 12
7436: PUSH
7437: LD_INT 1
7439: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7440: LD_INT 6300
7442: PPUSH
7443: LD_INT 8400
7445: PPUSH
7446: CALL_OW 12
7450: PPUSH
7451: CALL_OW 67
// send_spec_patrol := true ;
7455: LD_ADDR_EXP 28
7459: PUSH
7460: LD_INT 1
7462: ST_TO_ADDR
// end ;
7463: PPOPN 4
7465: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7466: LD_INT 22
7468: PUSH
7469: LD_INT 1
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: PUSH
7476: LD_INT 34
7478: PUSH
7479: LD_INT 51
7481: PUSH
7482: EMPTY
7483: LIST
7484: LIST
7485: PUSH
7486: LD_INT 92
7488: PUSH
7489: LD_INT 63
7491: PUSH
7492: LD_INT 100
7494: PUSH
7495: LD_INT 5
7497: PUSH
7498: EMPTY
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: PUSH
7504: EMPTY
7505: LIST
7506: LIST
7507: LIST
7508: PUSH
7509: EMPTY
7510: LIST
7511: PPUSH
7512: CALL_OW 69
7516: PUSH
7517: LD_EXP 5
7521: NOT
7522: AND
7523: IFFALSE 7636
7525: GO 7527
7527: DISABLE
7528: LD_INT 0
7530: PPUSH
7531: PPUSH
// begin enable ;
7532: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
7533: LD_ADDR_VAR 0 2
7537: PUSH
7538: LD_INT 22
7540: PUSH
7541: LD_INT 1
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PUSH
7548: LD_INT 34
7550: PUSH
7551: LD_INT 51
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: PUSH
7558: LD_INT 92
7560: PUSH
7561: LD_INT 63
7563: PUSH
7564: LD_INT 100
7566: PUSH
7567: LD_INT 5
7569: PUSH
7570: EMPTY
7571: LIST
7572: LIST
7573: LIST
7574: LIST
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: LIST
7580: PUSH
7581: EMPTY
7582: LIST
7583: PPUSH
7584: CALL_OW 69
7588: ST_TO_ADDR
// if not filter then
7589: LD_VAR 0 2
7593: NOT
7594: IFFALSE 7598
// exit ;
7596: GO 7636
// for i in filter do
7598: LD_ADDR_VAR 0 1
7602: PUSH
7603: LD_VAR 0 2
7607: PUSH
7608: FOR_IN
7609: IFFALSE 7634
// begin SetFuel ( i , 0 ) ;
7611: LD_VAR 0 1
7615: PPUSH
7616: LD_INT 0
7618: PPUSH
7619: CALL_OW 240
// ComStop ( i ) ;
7623: LD_VAR 0 1
7627: PPUSH
7628: CALL_OW 141
// end ;
7632: GO 7608
7634: POP
7635: POP
// end ;
7636: PPOPN 2
7638: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
7639: LD_EXP 28
7643: IFFALSE 8608
7645: GO 7647
7647: DISABLE
7648: LD_INT 0
7650: PPUSH
7651: PPUSH
7652: PPUSH
7653: PPUSH
7654: PPUSH
7655: PPUSH
7656: PPUSH
// begin if not ru_spec_patrol then
7657: LD_EXP 50
7661: NOT
7662: IFFALSE 7666
// exit ;
7664: GO 8608
// dead1 := false ;
7666: LD_ADDR_VAR 0 1
7670: PUSH
7671: LD_INT 0
7673: ST_TO_ADDR
// dead2 := false ;
7674: LD_ADDR_VAR 0 2
7678: PUSH
7679: LD_INT 0
7681: ST_TO_ADDR
// inarea1 := false ;
7682: LD_ADDR_VAR 0 3
7686: PUSH
7687: LD_INT 0
7689: ST_TO_ADDR
// inarea2 := false ;
7690: LD_ADDR_VAR 0 4
7694: PUSH
7695: LD_INT 0
7697: ST_TO_ADDR
// tmp := [ ] ;
7698: LD_ADDR_VAR 0 6
7702: PUSH
7703: EMPTY
7704: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
7705: LD_EXP 50
7709: PPUSH
7710: LD_INT 75
7712: PPUSH
7713: LD_INT 101
7715: PPUSH
7716: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
7720: LD_INT 35
7722: PPUSH
7723: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
7727: LD_INT 1
7729: PPUSH
7730: LD_EXP 50
7734: PUSH
7735: LD_INT 1
7737: ARRAY
7738: PPUSH
7739: CALL_OW 292
7743: IFFALSE 7720
// ComStop ( ru_spec_patrol ) ;
7745: LD_EXP 50
7749: PPUSH
7750: CALL_OW 141
// Wait ( 0 0$02 ) ;
7754: LD_INT 70
7756: PPUSH
7757: CALL_OW 67
// DialogueOn ;
7761: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
7765: LD_EXP 50
7769: PUSH
7770: LD_INT 1
7772: ARRAY
7773: PPUSH
7774: LD_STRING D8-Rus1-1
7776: PPUSH
7777: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
7781: LD_EXP 33
7785: PPUSH
7786: LD_STRING D8-JMM-1
7788: PPUSH
7789: CALL_OW 88
// DialogueOff ;
7793: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
7797: LD_EXP 50
7801: PPUSH
7802: LD_INT 13
7804: PPUSH
7805: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
7809: LD_INT 35
7811: PPUSH
7812: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
7816: LD_VAR 0 1
7820: NOT
7821: PUSH
7822: LD_EXP 50
7826: PUSH
7827: LD_INT 1
7829: ARRAY
7830: PPUSH
7831: CALL_OW 301
7835: AND
7836: IFFALSE 7846
// dead1 := true ;
7838: LD_ADDR_VAR 0 1
7842: PUSH
7843: LD_INT 1
7845: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
7846: LD_VAR 0 2
7850: NOT
7851: PUSH
7852: LD_EXP 50
7856: PUSH
7857: LD_INT 2
7859: ARRAY
7860: PPUSH
7861: CALL_OW 301
7865: AND
7866: IFFALSE 7876
// dead2 := true ;
7868: LD_ADDR_VAR 0 2
7872: PUSH
7873: LD_INT 1
7875: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
7876: LD_VAR 0 3
7880: NOT
7881: PUSH
7882: LD_EXP 50
7886: PUSH
7887: LD_INT 1
7889: ARRAY
7890: PPUSH
7891: LD_INT 14
7893: PPUSH
7894: CALL_OW 308
7898: AND
7899: IFFALSE 7909
// inarea1 := true ;
7901: LD_ADDR_VAR 0 3
7905: PUSH
7906: LD_INT 1
7908: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
7909: LD_VAR 0 4
7913: NOT
7914: PUSH
7915: LD_EXP 50
7919: PUSH
7920: LD_INT 2
7922: ARRAY
7923: PPUSH
7924: LD_INT 14
7926: PPUSH
7927: CALL_OW 308
7931: AND
7932: IFFALSE 7942
// inarea2 := true ;
7934: LD_ADDR_VAR 0 4
7938: PUSH
7939: LD_INT 1
7941: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
7942: LD_VAR 0 1
7946: PUSH
7947: LD_VAR 0 2
7951: AND
7952: PUSH
7953: LD_VAR 0 1
7957: PUSH
7958: LD_VAR 0 4
7962: AND
7963: OR
7964: PUSH
7965: LD_VAR 0 2
7969: PUSH
7970: LD_VAR 0 3
7974: AND
7975: OR
7976: PUSH
7977: LD_VAR 0 3
7981: PUSH
7982: LD_VAR 0 4
7986: AND
7987: OR
7988: IFFALSE 7809
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
7990: LD_VAR 0 3
7994: PUSH
7995: LD_VAR 0 4
7999: AND
8000: PUSH
8001: LD_VAR 0 1
8005: PUSH
8006: LD_VAR 0 4
8010: AND
8011: OR
8012: PUSH
8013: LD_VAR 0 2
8017: PUSH
8018: LD_VAR 0 3
8022: AND
8023: OR
8024: IFFALSE 8588
// begin prepare_siege := true ;
8026: LD_ADDR_EXP 29
8030: PUSH
8031: LD_INT 1
8033: ST_TO_ADDR
// DialogueOn ;
8034: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8038: LD_VAR 0 3
8042: PUSH
8043: LD_VAR 0 4
8047: AND
8048: IFFALSE 8064
// Say ( JMM , D8b-JMM-1a ) else
8050: LD_EXP 33
8054: PPUSH
8055: LD_STRING D8b-JMM-1a
8057: PPUSH
8058: CALL_OW 88
8062: GO 8076
// Say ( JMM , D8b-JMM-1 ) ;
8064: LD_EXP 33
8068: PPUSH
8069: LD_STRING D8b-JMM-1
8071: PPUSH
8072: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8076: LD_EXP 4
8080: PPUSH
8081: LD_INT 26
8083: PUSH
8084: LD_INT 1
8086: PUSH
8087: EMPTY
8088: LIST
8089: LIST
8090: PPUSH
8091: CALL_OW 72
8095: PUSH
8096: LD_EXP 34
8100: PUSH
8101: LD_EXP 35
8105: PUSH
8106: LD_EXP 44
8110: PUSH
8111: LD_EXP 47
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: LIST
8120: LIST
8121: DIFF
8122: PPUSH
8123: LD_STRING D8b-Sol1-1
8125: PPUSH
8126: CALL 601 0 2
// if Cyrus and Cyrus in jmm_units then
8130: LD_EXP 35
8134: PUSH
8135: LD_EXP 35
8139: PUSH
8140: LD_EXP 4
8144: IN
8145: AND
8146: IFFALSE 8162
// Say ( Cyrus , D8b-Cyrus-1 ) else
8148: LD_EXP 35
8152: PPUSH
8153: LD_STRING D8b-Cyrus-1
8155: PPUSH
8156: CALL_OW 88
8160: GO 8174
// Say ( JMM , D8b-JMM-1a ) ;
8162: LD_EXP 33
8166: PPUSH
8167: LD_STRING D8b-JMM-1a
8169: PPUSH
8170: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8174: LD_EXP 36
8178: PUSH
8179: LD_EXP 36
8183: PUSH
8184: LD_EXP 4
8188: IN
8189: AND
8190: IFFALSE 8204
// Say ( Lisa , D8b-Lisa-2 ) ;
8192: LD_EXP 36
8196: PPUSH
8197: LD_STRING D8b-Lisa-2
8199: PPUSH
8200: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8204: LD_EXP 34
8208: PUSH
8209: LD_EXP 34
8213: PUSH
8214: LD_EXP 4
8218: IN
8219: AND
8220: IFFALSE 8236
// Say ( Bobby , D8b-Bobby-1 ) else
8222: LD_EXP 34
8226: PPUSH
8227: LD_STRING D8b-Bobby-1
8229: PPUSH
8230: CALL_OW 88
8234: GO 8296
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8236: LD_ADDR_VAR 0 5
8240: PUSH
8241: LD_EXP 4
8245: PPUSH
8246: LD_INT 26
8248: PUSH
8249: LD_INT 1
8251: PUSH
8252: EMPTY
8253: LIST
8254: LIST
8255: PPUSH
8256: CALL_OW 72
8260: PUSH
8261: LD_EXP 34
8265: PUSH
8266: LD_EXP 35
8270: PUSH
8271: LD_EXP 44
8275: PUSH
8276: LD_EXP 47
8280: PUSH
8281: EMPTY
8282: LIST
8283: LIST
8284: LIST
8285: LIST
8286: DIFF
8287: PPUSH
8288: LD_STRING D8b-Sol2-1
8290: PPUSH
8291: CALL 601 0 2
8295: ST_TO_ADDR
// DialogueOff ;
8296: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8300: LD_EXP 35
8304: PUSH
8305: LD_EXP 35
8309: PUSH
8310: LD_EXP 4
8314: IN
8315: AND
8316: IFFALSE 8341
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8318: LD_ADDR_VAR 0 6
8322: PUSH
8323: LD_VAR 0 6
8327: PPUSH
8328: LD_INT 1
8330: PPUSH
8331: LD_EXP 35
8335: PPUSH
8336: CALL_OW 2
8340: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8341: LD_EXP 34
8345: PUSH
8346: LD_EXP 34
8350: PUSH
8351: LD_EXP 4
8355: IN
8356: AND
8357: IFFALSE 8382
// tmp := Insert ( tmp , 1 , Bobby ) ;
8359: LD_ADDR_VAR 0 6
8363: PUSH
8364: LD_VAR 0 6
8368: PPUSH
8369: LD_INT 1
8371: PPUSH
8372: LD_EXP 34
8376: PPUSH
8377: CALL_OW 2
8381: ST_TO_ADDR
// if sol then
8382: LD_VAR 0 5
8386: IFFALSE 8411
// tmp := Insert ( tmp , 1 , sol ) ;
8388: LD_ADDR_VAR 0 6
8392: PUSH
8393: LD_VAR 0 6
8397: PPUSH
8398: LD_INT 1
8400: PPUSH
8401: LD_VAR 0 5
8405: PPUSH
8406: CALL_OW 2
8410: ST_TO_ADDR
// if tmp then
8411: LD_VAR 0 6
8415: IFFALSE 8547
// begin SetSide ( tmp , 8 ) ;
8417: LD_VAR 0 6
8421: PPUSH
8422: LD_INT 8
8424: PPUSH
8425: CALL_OW 235
// ComFree ( tmp ) ;
8429: LD_VAR 0 6
8433: PPUSH
8434: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8438: LD_VAR 0 6
8442: PPUSH
8443: LD_INT 15
8445: PPUSH
8446: CALL_OW 173
// AddComHold ( tmp ) ;
8450: LD_VAR 0 6
8454: PPUSH
8455: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8459: LD_INT 35
8461: PPUSH
8462: CALL_OW 67
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8466: LD_VAR 0 6
8470: PUSH
8471: LD_INT 1
8473: ARRAY
8474: PPUSH
8475: LD_INT 15
8477: PPUSH
8478: CALL_OW 308
8482: IFFALSE 8537
// begin RemoveUnit ( tmp [ 1 ] ) ;
8484: LD_VAR 0 6
8488: PUSH
8489: LD_INT 1
8491: ARRAY
8492: PPUSH
8493: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
8497: LD_ADDR_EXP 4
8501: PUSH
8502: LD_EXP 4
8506: PUSH
8507: LD_VAR 0 6
8511: PUSH
8512: LD_INT 1
8514: ARRAY
8515: DIFF
8516: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
8517: LD_ADDR_VAR 0 6
8521: PUSH
8522: LD_VAR 0 6
8526: PUSH
8527: LD_VAR 0 6
8531: PUSH
8532: LD_INT 1
8534: ARRAY
8535: DIFF
8536: ST_TO_ADDR
// end ; until tmp = 0 ;
8537: LD_VAR 0 6
8541: PUSH
8542: LD_INT 0
8544: EQUAL
8545: IFFALSE 8459
// end ; Wait ( 0 0$30 ) ;
8547: LD_INT 1050
8549: PPUSH
8550: CALL_OW 67
// if ru_spec_patrol then
8554: LD_EXP 50
8558: IFFALSE 8586
// for i in ru_spec_patrol do
8560: LD_ADDR_VAR 0 7
8564: PUSH
8565: LD_EXP 50
8569: PUSH
8570: FOR_IN
8571: IFFALSE 8584
// RemoveUnit ( i ) ;
8573: LD_VAR 0 7
8577: PPUSH
8578: CALL_OW 64
8582: GO 8570
8584: POP
8585: POP
// end else
8586: GO 8608
// begin prepare_siege := false ;
8588: LD_ADDR_EXP 29
8592: PUSH
8593: LD_INT 0
8595: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
8596: LD_EXP 33
8600: PPUSH
8601: LD_STRING D8a-JMM-1
8603: PPUSH
8604: CALL_OW 88
// end ; end ;
8608: PPOPN 7
8610: END
// every 0 0$10 trigger frank_can_return do var i , points ;
8611: LD_EXP 12
8615: IFFALSE 9749
8617: GO 8619
8619: DISABLE
8620: LD_INT 0
8622: PPUSH
8623: PPUSH
// begin uc_side := 8 ;
8624: LD_ADDR_OWVAR 20
8628: PUSH
8629: LD_INT 8
8631: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
8632: LD_ADDR_VAR 0 2
8636: PUSH
8637: LD_INT 59
8639: PUSH
8640: LD_INT 71
8642: PUSH
8643: EMPTY
8644: LIST
8645: LIST
8646: PUSH
8647: LD_INT 122
8649: PUSH
8650: LD_INT 117
8652: PUSH
8653: EMPTY
8654: LIST
8655: LIST
8656: PUSH
8657: EMPTY
8658: LIST
8659: LIST
8660: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
8661: LD_ADDR_EXP 47
8665: PUSH
8666: LD_STRING Frank
8668: PPUSH
8669: LD_INT 0
8671: PPUSH
8672: CALL 450 0 2
8676: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
8677: LD_ADDR_VAR 0 1
8681: PUSH
8682: LD_INT 1
8684: PPUSH
8685: LD_INT 2
8687: PPUSH
8688: CALL_OW 12
8692: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
8693: LD_EXP 47
8697: PPUSH
8698: LD_VAR 0 2
8702: PUSH
8703: LD_VAR 0 1
8707: ARRAY
8708: PUSH
8709: LD_INT 1
8711: ARRAY
8712: PPUSH
8713: LD_VAR 0 2
8717: PUSH
8718: LD_VAR 0 1
8722: ARRAY
8723: PUSH
8724: LD_INT 2
8726: ARRAY
8727: PPUSH
8728: LD_INT 0
8730: PPUSH
8731: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
8735: LD_EXP 47
8739: PPUSH
8740: LD_INT 1
8742: PPUSH
8743: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
8747: LD_INT 35
8749: PPUSH
8750: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
8754: LD_EXP 47
8758: PPUSH
8759: LD_EXP 33
8763: PPUSH
8764: CALL_OW 296
8768: PUSH
8769: LD_INT 8
8771: LESS
8772: IFFALSE 8747
// InGameOn ;
8774: CALL_OW 8
// CenterOnUnits ( JMM ) ;
8778: LD_EXP 33
8782: PPUSH
8783: CALL_OW 85
// if IsInUnit ( JMM ) then
8787: LD_EXP 33
8791: PPUSH
8792: CALL_OW 310
8796: IFFALSE 8807
// ComFree ( JMM ) ;
8798: LD_EXP 33
8802: PPUSH
8803: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
8807: LD_EXP 33
8811: PPUSH
8812: LD_EXP 47
8816: PPUSH
8817: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
8821: LD_EXP 47
8825: PPUSH
8826: LD_EXP 33
8830: PPUSH
8831: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
8835: LD_EXP 33
8839: PPUSH
8840: LD_STRING D6-JMM-1
8842: PPUSH
8843: CALL_OW 88
// repeat wait ( 3 ) ;
8847: LD_INT 3
8849: PPUSH
8850: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
8854: LD_EXP 33
8858: PPUSH
8859: LD_EXP 47
8863: PPUSH
8864: CALL_OW 296
8868: PUSH
8869: LD_INT 8
8871: LESS
8872: IFFALSE 8847
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
8874: LD_EXP 36
8878: PUSH
8879: LD_EXP 36
8883: PPUSH
8884: LD_EXP 47
8888: PPUSH
8889: CALL_OW 296
8893: PUSH
8894: LD_INT 20
8896: LESS
8897: AND
8898: IFFALSE 8923
// begin ComFree ( Lisa ) ;
8900: LD_EXP 36
8904: PPUSH
8905: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
8909: LD_EXP 36
8913: PPUSH
8914: LD_EXP 47
8918: PPUSH
8919: CALL_OW 172
// end ; if Lynch then
8923: LD_EXP 43
8927: IFFALSE 8952
// begin ComFree ( Lynch ) ;
8929: LD_EXP 43
8933: PPUSH
8934: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
8938: LD_EXP 43
8942: PPUSH
8943: LD_EXP 47
8947: PPUSH
8948: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
8952: LD_EXP 33
8956: PPUSH
8957: LD_EXP 47
8961: PPUSH
8962: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
8966: LD_EXP 47
8970: PPUSH
8971: LD_EXP 33
8975: PPUSH
8976: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
8980: LD_EXP 47
8984: PPUSH
8985: LD_STRING D6-Frank-1
8987: PPUSH
8988: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
8992: LD_INT 69
8994: PPUSH
8995: LD_INT 20
8997: PPUSH
8998: LD_INT 1
9000: PPUSH
9001: LD_INT 20
9003: NEG
9004: PPUSH
9005: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9009: LD_INT 69
9011: PPUSH
9012: LD_INT 20
9014: PPUSH
9015: LD_INT 1
9017: PPUSH
9018: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9022: LD_INT 190
9024: PPUSH
9025: LD_INT 31
9027: PPUSH
9028: LD_INT 1
9030: PPUSH
9031: LD_INT 20
9033: NEG
9034: PPUSH
9035: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9039: LD_INT 190
9041: PPUSH
9042: LD_INT 31
9044: PPUSH
9045: LD_INT 1
9047: PPUSH
9048: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9052: LD_INT 69
9054: PPUSH
9055: LD_INT 20
9057: PPUSH
9058: CALL_OW 84
// Wait ( 0 0$02 ) ;
9062: LD_INT 70
9064: PPUSH
9065: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9069: LD_EXP 33
9073: PPUSH
9074: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9078: LD_EXP 36
9082: PUSH
9083: LD_EXP 36
9087: PPUSH
9088: LD_EXP 47
9092: PPUSH
9093: CALL_OW 296
9097: PUSH
9098: LD_INT 20
9100: LESS
9101: AND
9102: PUSH
9103: LD_EXP 36
9107: PPUSH
9108: CALL_OW 302
9112: AND
9113: IFFALSE 9203
// begin ComFree ( Lisa ) ;
9115: LD_EXP 36
9119: PPUSH
9120: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
9124: LD_INT 35
9126: PPUSH
9127: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
9131: LD_EXP 36
9135: PPUSH
9136: LD_EXP 47
9140: PPUSH
9141: CALL_OW 296
9145: PUSH
9146: LD_INT 7
9148: LESS
9149: IFFALSE 9124
// Say ( Lisa , D6-Lisa-1 ) ;
9151: LD_EXP 36
9155: PPUSH
9156: LD_STRING D6-Lisa-1
9158: PPUSH
9159: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9163: LD_EXP 36
9167: PPUSH
9168: LD_EXP 47
9172: PPUSH
9173: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9177: LD_EXP 47
9181: PPUSH
9182: LD_EXP 36
9186: PPUSH
9187: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9191: LD_EXP 47
9195: PPUSH
9196: LD_STRING D6-Frank-2
9198: PPUSH
9199: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9203: LD_EXP 43
9207: PUSH
9208: LD_EXP 43
9212: PPUSH
9213: LD_EXP 47
9217: PPUSH
9218: CALL_OW 296
9222: PUSH
9223: LD_INT 20
9225: LESS
9226: AND
9227: PUSH
9228: LD_EXP 43
9232: PPUSH
9233: CALL_OW 302
9237: AND
9238: IFFALSE 9419
// begin ComTurnUnit ( Lynch , JMM ) ;
9240: LD_EXP 43
9244: PPUSH
9245: LD_EXP 33
9249: PPUSH
9250: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9254: LD_EXP 47
9258: PPUSH
9259: LD_EXP 33
9263: PPUSH
9264: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9268: LD_EXP 43
9272: PPUSH
9273: LD_STRING D6-Sol1-2
9275: PPUSH
9276: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9280: LD_EXP 33
9284: PPUSH
9285: LD_STRING D6-JMM-2
9287: PPUSH
9288: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9292: LD_EXP 47
9296: PPUSH
9297: LD_STRING D6-Frank-3
9299: PPUSH
9300: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9304: LD_EXP 33
9308: PPUSH
9309: LD_STRING D6-JMM-3
9311: PPUSH
9312: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9316: LD_EXP 47
9320: PPUSH
9321: LD_STRING D6-Frank-4
9323: PPUSH
9324: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9328: LD_EXP 47
9332: PPUSH
9333: LD_STRING D6-Frank-4a
9335: PPUSH
9336: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9340: LD_EXP 33
9344: PPUSH
9345: LD_STRING D6-JMM-4
9347: PPUSH
9348: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9352: LD_EXP 47
9356: PPUSH
9357: LD_STRING D6-Frank-5
9359: PPUSH
9360: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9364: LD_EXP 36
9368: PUSH
9369: LD_EXP 36
9373: PPUSH
9374: CALL_OW 302
9378: AND
9379: IFFALSE 9393
// Say ( Lisa , D6-Lisa-5 ) ;
9381: LD_EXP 36
9385: PPUSH
9386: LD_STRING D6-Lisa-5
9388: PPUSH
9389: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9393: LD_EXP 47
9397: PPUSH
9398: LD_STRING D6-Frank-6
9400: PPUSH
9401: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9405: LD_EXP 33
9409: PPUSH
9410: LD_STRING D6-JMM-6
9412: PPUSH
9413: CALL_OW 88
// end else
9417: GO 9534
// begin ComTurnUnit ( Frank , JMM ) ;
9419: LD_EXP 47
9423: PPUSH
9424: LD_EXP 33
9428: PPUSH
9429: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
9433: LD_EXP 47
9437: PPUSH
9438: LD_STRING D6-Frank-4
9440: PPUSH
9441: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9445: LD_EXP 47
9449: PPUSH
9450: LD_STRING D6-Frank-4a
9452: PPUSH
9453: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9457: LD_EXP 33
9461: PPUSH
9462: LD_STRING D6-JMM-4
9464: PPUSH
9465: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9469: LD_EXP 47
9473: PPUSH
9474: LD_STRING D6-Frank-5
9476: PPUSH
9477: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9481: LD_EXP 36
9485: PUSH
9486: LD_EXP 36
9490: PPUSH
9491: CALL_OW 302
9495: AND
9496: IFFALSE 9510
// Say ( Lisa , D6-Lisa-5 ) ;
9498: LD_EXP 36
9502: PPUSH
9503: LD_STRING D6-Lisa-5
9505: PPUSH
9506: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9510: LD_EXP 47
9514: PPUSH
9515: LD_STRING D6-Frank-6
9517: PPUSH
9518: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9522: LD_EXP 33
9526: PPUSH
9527: LD_STRING D6-JMM-6
9529: PPUSH
9530: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
9534: LD_STRING Q1
9536: PPUSH
9537: CALL_OW 97
9541: PUSH
9542: LD_INT 1
9544: DOUBLE
9545: EQUAL
9546: IFTRUE 9550
9548: GO 9561
9550: POP
// frank_send_to_scout := true ; 2 :
9551: LD_ADDR_EXP 14
9555: PUSH
9556: LD_INT 1
9558: ST_TO_ADDR
9559: GO 9581
9561: LD_INT 2
9563: DOUBLE
9564: EQUAL
9565: IFTRUE 9569
9567: GO 9580
9569: POP
// frank_send_to_scout := false ; end ;
9570: LD_ADDR_EXP 14
9574: PUSH
9575: LD_INT 0
9577: ST_TO_ADDR
9578: GO 9581
9580: POP
// InGameOff ;
9581: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
9585: LD_EXP 33
9589: PUSH
9590: LD_EXP 36
9594: PUSH
9595: LD_EXP 43
9599: PUSH
9600: EMPTY
9601: LIST
9602: LIST
9603: LIST
9604: PPUSH
9605: CALL_OW 139
// if frank_send_to_scout then
9609: LD_EXP 14
9613: IFFALSE 9670
// begin ComMoveXY ( Frank , 130 , 123 ) ;
9615: LD_EXP 47
9619: PPUSH
9620: LD_INT 130
9622: PPUSH
9623: LD_INT 123
9625: PPUSH
9626: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
9630: LD_INT 35
9632: PPUSH
9633: CALL_OW 67
// until not See ( 1 , Frank ) ;
9637: LD_INT 1
9639: PPUSH
9640: LD_EXP 47
9644: PPUSH
9645: CALL_OW 292
9649: NOT
9650: IFFALSE 9630
// Wait ( 0 0$02 ) ;
9652: LD_INT 70
9654: PPUSH
9655: CALL_OW 67
// RemoveUnit ( Frank ) ;
9659: LD_EXP 47
9663: PPUSH
9664: CALL_OW 64
// end else
9668: GO 9682
// SetSide ( Frank , 1 ) ;
9670: LD_EXP 47
9674: PPUSH
9675: LD_INT 1
9677: PPUSH
9678: CALL_OW 235
// send_attack_on_cornel_base := true ;
9682: LD_ADDR_EXP 25
9686: PUSH
9687: LD_INT 1
9689: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9690: LD_INT 35
9692: PPUSH
9693: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
9697: LD_ADDR_EXP 27
9701: PUSH
9702: LD_EXP 27
9706: PPUSH
9707: LD_STRING -
9709: PPUSH
9710: CALL 1093 0 2
9714: ST_TO_ADDR
// if debug then
9715: LD_EXP 1
9719: IFFALSE 9731
// debug_strings := time_to_prepare ;
9721: LD_ADDR_OWVAR 48
9725: PUSH
9726: LD_EXP 27
9730: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
9731: LD_EXP 27
9735: PUSH
9736: LD_INT 0
9738: EQUAL
9739: IFFALSE 9690
// cornel_prepared := true ;
9741: LD_ADDR_EXP 11
9745: PUSH
9746: LD_INT 1
9748: ST_TO_ADDR
// end ;
9749: PPOPN 2
9751: END
// every 0 0$01 trigger cornel_prepared do
9752: LD_EXP 11
9756: IFFALSE 10002
9758: GO 9760
9760: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
9761: LD_EXP 40
9765: PPUSH
9766: LD_STRING D3-Corn-1
9768: PPUSH
9769: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
9773: LD_INT 35
9775: PPUSH
9776: CALL_OW 67
// until cornel_counter = 0 ;
9780: LD_EXP 10
9784: PUSH
9785: LD_INT 0
9787: EQUAL
9788: IFFALSE 9773
// SayRadio ( Cornel , D3a-Corn-1 ) ;
9790: LD_EXP 40
9794: PPUSH
9795: LD_STRING D3a-Corn-1
9797: PPUSH
9798: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
9802: LD_EXP 33
9806: PPUSH
9807: LD_STRING D3a-JMM-1
9809: PPUSH
9810: CALL_OW 88
// end_mission_allowed := true ;
9814: LD_ADDR_EXP 20
9818: PUSH
9819: LD_INT 1
9821: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
9822: LD_STRING M2
9824: PPUSH
9825: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
9829: LD_INT 9
9831: PPUSH
9832: LD_INT 1
9834: PPUSH
9835: CALL_OW 424
// Wait ( 0 0$05 ) ;
9839: LD_INT 175
9841: PPUSH
9842: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
9846: LD_EXP 40
9850: PPUSH
9851: LD_STRING D3a-Corn-2
9853: PPUSH
9854: CALL_OW 94
// cornel_attack := true ;
9858: LD_ADDR_EXP 9
9862: PUSH
9863: LD_INT 1
9865: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
9866: LD_INT 105
9868: PPUSH
9869: CALL_OW 67
// AddMoreTanks ( ) ;
9873: CALL 4751 0 0
// if frank_send_to_scout then
9877: LD_EXP 14
9881: IFFALSE 10002
// begin InitHc ;
9883: CALL_OW 19
// InitUc ;
9887: CALL_OW 18
// uc_side := 8 ;
9891: LD_ADDR_OWVAR 20
9895: PUSH
9896: LD_INT 8
9898: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9899: LD_ADDR_EXP 47
9903: PUSH
9904: LD_STRING Frank
9906: PPUSH
9907: LD_INT 0
9909: PPUSH
9910: CALL 450 0 2
9914: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
9915: LD_EXP 47
9919: PPUSH
9920: LD_INT 6
9922: PPUSH
9923: LD_INT 9
9925: PPUSH
9926: LD_INT 0
9928: PPUSH
9929: CALL_OW 48
// ComCrawl ( Frank ) ;
9933: LD_EXP 47
9937: PPUSH
9938: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
9942: LD_INT 35
9944: PPUSH
9945: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
9949: LD_EXP 33
9953: PPUSH
9954: LD_EXP 47
9958: PPUSH
9959: CALL_OW 296
9963: PUSH
9964: LD_INT 9
9966: LESS
9967: IFFALSE 9942
// SetSide ( Frank , 1 ) ;
9969: LD_EXP 47
9973: PPUSH
9974: LD_INT 1
9976: PPUSH
9977: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
9981: LD_EXP 47
9985: PPUSH
9986: LD_STRING D6a-Frank-1
9988: PPUSH
9989: CALL_OW 88
// ComWalk ( Frank ) ;
9993: LD_EXP 47
9997: PPUSH
9998: CALL_OW 138
// end ; end ;
10002: END
// every 0 0$01 trigger solar_builded do
10003: LD_EXP 13
10007: IFFALSE 10111
10009: GO 10011
10011: DISABLE
// begin Wait ( 0 0$02 ) ;
10012: LD_INT 70
10014: PPUSH
10015: CALL_OW 67
// DialogueOn ;
10019: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10023: LD_EXP 33
10027: PPUSH
10028: LD_STRING D2b-JMM-1
10030: PPUSH
10031: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10035: LD_EXP 44
10039: PUSH
10040: LD_EXP 44
10044: PPUSH
10045: CALL_OW 302
10049: AND
10050: IFFALSE 10100
// begin Say ( Walker , D2b-Sci1-1 ) ;
10052: LD_EXP 44
10056: PPUSH
10057: LD_STRING D2b-Sci1-1
10059: PPUSH
10060: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10064: LD_EXP 33
10068: PPUSH
10069: LD_STRING D2b-JMM-2
10071: PPUSH
10072: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10076: LD_EXP 44
10080: PPUSH
10081: LD_STRING D2b-Sci1-2
10083: PPUSH
10084: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10088: LD_EXP 33
10092: PPUSH
10093: LD_STRING D2b-JMM-3
10095: PPUSH
10096: CALL_OW 88
// end ; DialogueOff ;
10100: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10104: LD_STRING MOutSol
10106: PPUSH
10107: CALL_OW 337
// end ;
10111: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10112: LD_EXP 13
10116: PUSH
10117: LD_EXP 33
10121: PPUSH
10122: CALL_OW 302
10126: AND
10127: PUSH
10128: LD_EXP 33
10132: PPUSH
10133: CALL 927 0 1
10137: AND
10138: PUSH
10139: LD_EXP 15
10143: NOT
10144: AND
10145: IFFALSE 10216
10147: GO 10149
10149: DISABLE
10150: LD_INT 0
10152: PPUSH
// begin jmm_in_veh := true ;
10153: LD_ADDR_EXP 15
10157: PUSH
10158: LD_INT 1
10160: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10161: LD_ADDR_VAR 0 1
10165: PUSH
10166: LD_INT 0
10168: PPUSH
10169: LD_INT 1
10171: PPUSH
10172: CALL_OW 12
10176: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10177: LD_INT 70
10179: PPUSH
10180: CALL_OW 67
// if i then
10184: LD_VAR 0 1
10188: IFFALSE 10204
// Say ( JMM , D2c-JMM-1 ) else
10190: LD_EXP 33
10194: PPUSH
10195: LD_STRING D2c-JMM-1
10197: PPUSH
10198: CALL_OW 88
10202: GO 10216
// Say ( JMM , D2c-JMM-1a ) ;
10204: LD_EXP 33
10208: PPUSH
10209: LD_STRING D2c-JMM-1a
10211: PPUSH
10212: CALL_OW 88
// end ;
10216: PPOPN 1
10218: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10219: LD_EXP 13
10223: PUSH
10224: LD_EXP 34
10228: PPUSH
10229: CALL_OW 302
10233: AND
10234: PUSH
10235: LD_EXP 34
10239: PPUSH
10240: CALL 927 0 1
10244: AND
10245: PUSH
10246: LD_EXP 16
10250: NOT
10251: AND
10252: IFFALSE 10284
10254: GO 10256
10256: DISABLE
// begin bobby_in_veh := true ;
10257: LD_ADDR_EXP 16
10261: PUSH
10262: LD_INT 1
10264: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10265: LD_INT 70
10267: PPUSH
10268: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10272: LD_EXP 34
10276: PPUSH
10277: LD_STRING D2c-Bobby-1
10279: PPUSH
10280: CALL_OW 88
10284: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10285: LD_EXP 13
10289: PUSH
10290: LD_EXP 36
10294: PPUSH
10295: CALL_OW 302
10299: AND
10300: PUSH
10301: LD_EXP 36
10305: PPUSH
10306: CALL 927 0 1
10310: AND
10311: PUSH
10312: LD_EXP 18
10316: NOT
10317: AND
10318: IFFALSE 10350
10320: GO 10322
10322: DISABLE
// begin lisa_in_veh := true ;
10323: LD_ADDR_EXP 18
10327: PUSH
10328: LD_INT 1
10330: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10331: LD_INT 70
10333: PPUSH
10334: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10338: LD_EXP 36
10342: PPUSH
10343: LD_STRING D2c-Lisa-1
10345: PPUSH
10346: CALL_OW 88
10350: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
10351: LD_EXP 13
10355: PUSH
10356: LD_EXP 35
10360: PPUSH
10361: CALL_OW 302
10365: AND
10366: PUSH
10367: LD_EXP 35
10371: PPUSH
10372: CALL 927 0 1
10376: AND
10377: PUSH
10378: LD_EXP 17
10382: NOT
10383: AND
10384: IFFALSE 10455
10386: GO 10388
10388: DISABLE
10389: LD_INT 0
10391: PPUSH
// begin cyrus_in_veh := true ;
10392: LD_ADDR_EXP 17
10396: PUSH
10397: LD_INT 1
10399: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10400: LD_ADDR_VAR 0 1
10404: PUSH
10405: LD_INT 0
10407: PPUSH
10408: LD_INT 1
10410: PPUSH
10411: CALL_OW 12
10415: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10416: LD_INT 70
10418: PPUSH
10419: CALL_OW 67
// if i then
10423: LD_VAR 0 1
10427: IFFALSE 10443
// Say ( Cyrus , D2c-Cyrus-1 ) else
10429: LD_EXP 35
10433: PPUSH
10434: LD_STRING D2c-Cyrus-1
10436: PPUSH
10437: CALL_OW 88
10441: GO 10455
// Say ( Cyrus , D2c-Cyrus-1a ) ;
10443: LD_EXP 35
10447: PPUSH
10448: LD_STRING D2c-Cyrus-1a
10450: PPUSH
10451: CALL_OW 88
// end ;
10455: PPOPN 1
10457: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
10458: LD_EXP 40
10462: PPUSH
10463: LD_INT 16
10465: PPUSH
10466: CALL_OW 308
10470: IFFALSE 10726
10472: GO 10474
10474: DISABLE
10475: LD_INT 0
10477: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
10478: LD_INT 3
10480: PPUSH
10481: LD_EXP 40
10485: PPUSH
10486: CALL_OW 471
// send_attack_on_cornel := true ;
10490: LD_ADDR_EXP 30
10494: PUSH
10495: LD_INT 1
10497: ST_TO_ADDR
// if ru_vehicles then
10498: LD_EXP 52
10502: IFFALSE 10536
// for i in ru_vehicles do
10504: LD_ADDR_VAR 0 1
10508: PUSH
10509: LD_EXP 52
10513: PUSH
10514: FOR_IN
10515: IFFALSE 10534
// ComAgressiveMove ( i , 215 , 69 ) ;
10517: LD_VAR 0 1
10521: PPUSH
10522: LD_INT 215
10524: PPUSH
10525: LD_INT 69
10527: PPUSH
10528: CALL_OW 114
10532: GO 10514
10534: POP
10535: POP
// if ru_patrol then
10536: LD_EXP 49
10540: IFFALSE 10574
// for i in ru_patrol do
10542: LD_ADDR_VAR 0 1
10546: PUSH
10547: LD_EXP 49
10551: PUSH
10552: FOR_IN
10553: IFFALSE 10572
// ComAgressiveMove ( i , 215 , 69 ) ;
10555: LD_VAR 0 1
10559: PPUSH
10560: LD_INT 215
10562: PPUSH
10563: LD_INT 69
10565: PPUSH
10566: CALL_OW 114
10570: GO 10552
10572: POP
10573: POP
// if frank_send_to_scout then
10574: LD_EXP 14
10578: IFFALSE 10592
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
10580: LD_EXP 47
10584: PPUSH
10585: LD_STRING D3b-Frank-1
10587: PPUSH
10588: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
10592: LD_INT 105
10594: PPUSH
10595: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
10599: LD_EXP 40
10603: PPUSH
10604: LD_STRING D4-Corn-1
10606: PPUSH
10607: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10611: LD_INT 35
10613: PPUSH
10614: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 6 ;
10618: LD_INT 22
10620: PUSH
10621: LD_INT 4
10623: PUSH
10624: EMPTY
10625: LIST
10626: LIST
10627: PUSH
10628: LD_INT 21
10630: PUSH
10631: LD_INT 1
10633: PUSH
10634: EMPTY
10635: LIST
10636: LIST
10637: PUSH
10638: LD_INT 50
10640: PUSH
10641: EMPTY
10642: LIST
10643: PUSH
10644: EMPTY
10645: LIST
10646: LIST
10647: LIST
10648: PPUSH
10649: CALL_OW 69
10653: PUSH
10654: LD_INT 6
10656: LESS
10657: IFFALSE 10611
// SayRadio ( Cornel , D5-Corn-1 ) ;
10659: LD_EXP 40
10663: PPUSH
10664: LD_STRING D5-Corn-1
10666: PPUSH
10667: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
10671: LD_EXP 40
10675: PPUSH
10676: LD_EXP 2
10680: PUSH
10681: LD_STRING Cornel
10683: STR
10684: PPUSH
10685: CALL_OW 38
// ChangeSideFog ( 4 , 8 ) ;
10689: LD_INT 4
10691: PPUSH
10692: LD_INT 8
10694: PPUSH
10695: CALL_OW 343
// Wait ( 0 0$01 ) ;
10699: LD_INT 35
10701: PPUSH
10702: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
10706: LD_INT 3
10708: PPUSH
10709: LD_EXP 40
10713: PPUSH
10714: CALL_OW 472
// send_attack_on_cornel := false ;
10718: LD_ADDR_EXP 30
10722: PUSH
10723: LD_INT 0
10725: ST_TO_ADDR
// end ;
10726: PPOPN 1
10728: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
10729: LD_INT 9
10731: PPUSH
10732: LD_INT 22
10734: PUSH
10735: LD_INT 1
10737: PUSH
10738: EMPTY
10739: LIST
10740: LIST
10741: PPUSH
10742: CALL_OW 70
10746: PUSH
10747: LD_EXP 31
10751: OR
10752: IFFALSE 10918
10754: GO 10756
10756: DISABLE
10757: LD_INT 0
10759: PPUSH
10760: PPUSH
// begin enable ;
10761: ENABLE
// if not game_end then
10762: LD_EXP 31
10766: NOT
10767: IFFALSE 10777
// game_end := true ;
10769: LD_ADDR_EXP 31
10773: PUSH
10774: LD_INT 1
10776: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
10777: LD_ADDR_VAR 0 2
10781: PUSH
10782: LD_INT 9
10784: PPUSH
10785: LD_INT 22
10787: PUSH
10788: LD_INT 1
10790: PUSH
10791: EMPTY
10792: LIST
10793: LIST
10794: PPUSH
10795: CALL_OW 70
10799: ST_TO_ADDR
// if not filter then
10800: LD_VAR 0 2
10804: NOT
10805: IFFALSE 10809
// exit ;
10807: GO 10918
// for i in filter do
10809: LD_ADDR_VAR 0 1
10813: PUSH
10814: LD_VAR 0 2
10818: PUSH
10819: FOR_IN
10820: IFFALSE 10916
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
10822: LD_VAR 0 1
10826: PPUSH
10827: CALL_OW 302
10831: PUSH
10832: LD_VAR 0 1
10836: PPUSH
10837: CALL_OW 247
10841: PUSH
10842: LD_INT 2
10844: EQUAL
10845: AND
10846: IFFALSE 10879
// begin veh_on_meta := true ;
10848: LD_ADDR_EXP 26
10852: PUSH
10853: LD_INT 1
10855: ST_TO_ADDR
// Save ( IsInUnit ( i ) ) ;
10856: LD_VAR 0 1
10860: PPUSH
10861: CALL_OW 310
10865: PPUSH
10866: CALL 10921 0 1
// RemoveUnit ( i ) ;
10870: LD_VAR 0 1
10874: PPUSH
10875: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
10879: LD_VAR 0 1
10883: PPUSH
10884: CALL_OW 302
10888: PUSH
10889: LD_VAR 0 1
10893: PPUSH
10894: CALL_OW 247
10898: PUSH
10899: LD_INT 1
10901: EQUAL
10902: AND
10903: IFFALSE 10914
// Save ( i ) ;
10905: LD_VAR 0 1
10909: PPUSH
10910: CALL 10921 0 1
// end ;
10914: GO 10819
10916: POP
10917: POP
// end ;
10918: PPOPN 2
10920: END
// export function Save ( i ) ; begin
10921: LD_INT 0
10923: PPUSH
// if i = JMM then
10924: LD_VAR 0 1
10928: PUSH
10929: LD_EXP 33
10933: EQUAL
10934: IFFALSE 11056
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
10936: LD_EXP 23
10940: PUSH
10941: LD_INT 22
10943: PUSH
10944: LD_INT 1
10946: PUSH
10947: EMPTY
10948: LIST
10949: LIST
10950: PUSH
10951: LD_INT 21
10953: PUSH
10954: LD_INT 1
10956: PUSH
10957: EMPTY
10958: LIST
10959: LIST
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: PPUSH
10965: CALL_OW 69
10969: PUSH
10970: LD_INT 1
10972: GREATER
10973: AND
10974: IFFALSE 11031
// begin show_query := false ;
10976: LD_ADDR_EXP 23
10980: PUSH
10981: LD_INT 0
10983: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
10984: LD_STRING Q2
10986: PPUSH
10987: CALL_OW 97
10991: PUSH
10992: LD_INT 1
10994: DOUBLE
10995: EQUAL
10996: IFTRUE 11000
10998: GO 11011
11000: POP
// wait_for_them := true ; 2 :
11001: LD_ADDR_EXP 24
11005: PUSH
11006: LD_INT 1
11008: ST_TO_ADDR
11009: GO 11031
11011: LD_INT 2
11013: DOUBLE
11014: EQUAL
11015: IFTRUE 11019
11017: GO 11030
11019: POP
// wait_for_them := false ; end ;
11020: LD_ADDR_EXP 24
11024: PUSH
11025: LD_INT 0
11027: ST_TO_ADDR
11028: GO 11031
11030: POP
// end ; save_group := save_group ^ JMM ;
11031: LD_ADDR_EXP 22
11035: PUSH
11036: LD_EXP 22
11040: PUSH
11041: LD_EXP 33
11045: ADD
11046: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11047: LD_EXP 33
11051: PPUSH
11052: CALL_OW 64
// end ; if i = Lisa then
11056: LD_VAR 0 1
11060: PUSH
11061: LD_EXP 36
11065: EQUAL
11066: IFFALSE 11093
// begin save_group := save_group ^ Lisa ;
11068: LD_ADDR_EXP 22
11072: PUSH
11073: LD_EXP 22
11077: PUSH
11078: LD_EXP 36
11082: ADD
11083: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11084: LD_EXP 36
11088: PPUSH
11089: CALL_OW 64
// end ; if i = Bobby then
11093: LD_VAR 0 1
11097: PUSH
11098: LD_EXP 34
11102: EQUAL
11103: IFFALSE 11130
// begin save_group := save_group ^ Bobby ;
11105: LD_ADDR_EXP 22
11109: PUSH
11110: LD_EXP 22
11114: PUSH
11115: LD_EXP 34
11119: ADD
11120: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11121: LD_EXP 34
11125: PPUSH
11126: CALL_OW 64
// end ; if i = Cyrus then
11130: LD_VAR 0 1
11134: PUSH
11135: LD_EXP 35
11139: EQUAL
11140: IFFALSE 11167
// begin save_group := save_group ^ Cyrus ;
11142: LD_ADDR_EXP 22
11146: PUSH
11147: LD_EXP 22
11151: PUSH
11152: LD_EXP 35
11156: ADD
11157: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11158: LD_EXP 35
11162: PPUSH
11163: CALL_OW 64
// end ; if i = Khatam then
11167: LD_VAR 0 1
11171: PUSH
11172: LD_EXP 37
11176: EQUAL
11177: IFFALSE 11204
// begin save_group := save_group ^ Khatam ;
11179: LD_ADDR_EXP 22
11183: PUSH
11184: LD_EXP 22
11188: PUSH
11189: LD_EXP 37
11193: ADD
11194: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11195: LD_EXP 37
11199: PPUSH
11200: CALL_OW 64
// end ; if i = Frank then
11204: LD_VAR 0 1
11208: PUSH
11209: LD_EXP 47
11213: EQUAL
11214: IFFALSE 11241
// begin save_group := save_group ^ Frank ;
11216: LD_ADDR_EXP 22
11220: PUSH
11221: LD_EXP 22
11225: PUSH
11226: LD_EXP 47
11230: ADD
11231: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11232: LD_EXP 47
11236: PPUSH
11237: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11241: LD_VAR 0 1
11245: PPUSH
11246: CALL_OW 302
11250: PUSH
11251: LD_VAR 0 1
11255: PPUSH
11256: CALL_OW 247
11260: PUSH
11261: LD_INT 1
11263: EQUAL
11264: AND
11265: PUSH
11266: LD_VAR 0 1
11270: PUSH
11271: LD_EXP 22
11275: IN
11276: NOT
11277: AND
11278: IFFALSE 11305
// begin save_others := save_others ^ i ;
11280: LD_ADDR_EXP 21
11284: PUSH
11285: LD_EXP 21
11289: PUSH
11290: LD_VAR 0 1
11294: ADD
11295: ST_TO_ADDR
// RemoveUnit ( i ) ;
11296: LD_VAR 0 1
11300: PPUSH
11301: CALL_OW 64
// end ; end ;
11305: LD_VAR 0 2
11309: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
11310: LD_EXP 23
11314: NOT
11315: PUSH
11316: LD_EXP 24
11320: NOT
11321: AND
11322: PUSH
11323: LD_INT 22
11325: PUSH
11326: LD_INT 1
11328: PUSH
11329: EMPTY
11330: LIST
11331: LIST
11332: PUSH
11333: LD_INT 21
11335: PUSH
11336: LD_INT 1
11338: PUSH
11339: EMPTY
11340: LIST
11341: LIST
11342: PUSH
11343: EMPTY
11344: LIST
11345: LIST
11346: PPUSH
11347: CALL_OW 69
11351: PUSH
11352: LD_INT 0
11354: EQUAL
11355: OR
11356: IFFALSE 11365
11358: GO 11360
11360: DISABLE
// EndMission ;
11361: CALL 11366 0 0
11365: END
// export function EndMission ; var i ; begin
11366: LD_INT 0
11368: PPUSH
11369: PPUSH
// Wait ( 0 0$02 ) ;
11370: LD_INT 70
11372: PPUSH
11373: CALL_OW 67
// if solar_builded then
11377: LD_EXP 13
11381: IFFALSE 11395
// AddMedal ( Solar1 , 1 ) else
11383: LD_STRING Solar1
11385: PPUSH
11386: LD_INT 1
11388: PPUSH
11389: CALL_OW 101
11393: GO 11406
// AddMedal ( Solar1 , - 1 ) ;
11395: LD_STRING Solar1
11397: PPUSH
11398: LD_INT 1
11400: NEG
11401: PPUSH
11402: CALL_OW 101
// if veh_on_meta then
11406: LD_EXP 26
11410: IFFALSE 11424
// AddMedal ( Solar2 , 1 ) else
11412: LD_STRING Solar2
11414: PPUSH
11415: LD_INT 1
11417: PPUSH
11418: CALL_OW 101
11422: GO 11454
// if solar_builded then
11424: LD_EXP 13
11428: IFFALSE 11443
// AddMedal ( Solar2 , - 1 ) else
11430: LD_STRING Solar2
11432: PPUSH
11433: LD_INT 1
11435: NEG
11436: PPUSH
11437: CALL_OW 101
11441: GO 11454
// AddMedal ( Solar2 , - 2 ) ;
11443: LD_STRING Solar2
11445: PPUSH
11446: LD_INT 2
11448: NEG
11449: PPUSH
11450: CALL_OW 101
// if lose_counter = 0 then
11454: LD_EXP 32
11458: PUSH
11459: LD_INT 0
11461: EQUAL
11462: IFFALSE 11476
// AddMedal ( No , 1 ) else
11464: LD_STRING No
11466: PPUSH
11467: LD_INT 1
11469: PPUSH
11470: CALL_OW 101
11474: GO 11520
// if lose_counter > 0 and lose_counter < 4 then
11476: LD_EXP 32
11480: PUSH
11481: LD_INT 0
11483: GREATER
11484: PUSH
11485: LD_EXP 32
11489: PUSH
11490: LD_INT 4
11492: LESS
11493: AND
11494: IFFALSE 11509
// AddMedal ( No , - 1 ) else
11496: LD_STRING No
11498: PPUSH
11499: LD_INT 1
11501: NEG
11502: PPUSH
11503: CALL_OW 101
11507: GO 11520
// AddMedal ( UpTo4 , - 1 ) ;
11509: LD_STRING UpTo4
11511: PPUSH
11512: LD_INT 1
11514: NEG
11515: PPUSH
11516: CALL_OW 101
// GiveMedals ( MAIN ) ;
11520: LD_STRING MAIN
11522: PPUSH
11523: CALL_OW 102
// if IsDead ( Pokryshkin ) then
11527: LD_EXP 48
11531: PPUSH
11532: CALL_OW 301
11536: IFFALSE 11576
// for i in save_group ^ save_others do
11538: LD_ADDR_VAR 0 2
11542: PUSH
11543: LD_EXP 22
11547: PUSH
11548: LD_EXP 21
11552: ADD
11553: PUSH
11554: FOR_IN
11555: IFFALSE 11574
// AddExperience ( i , skill_combat , 1500 ) ;
11557: LD_VAR 0 2
11561: PPUSH
11562: LD_INT 1
11564: PPUSH
11565: LD_INT 1500
11567: PPUSH
11568: CALL_OW 492
11572: GO 11554
11574: POP
11575: POP
// RewardPeople ( save_group ^ save_others ) ;
11576: LD_EXP 22
11580: PUSH
11581: LD_EXP 21
11585: ADD
11586: PPUSH
11587: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11591: LD_EXP 33
11595: PPUSH
11596: LD_EXP 2
11600: PUSH
11601: LD_STRING JMM
11603: STR
11604: PPUSH
11605: CALL_OW 38
// if Bobby in save_group then
11609: LD_EXP 34
11613: PUSH
11614: LD_EXP 22
11618: IN
11619: IFFALSE 11639
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11621: LD_EXP 34
11625: PPUSH
11626: LD_EXP 2
11630: PUSH
11631: LD_STRING Bobby
11633: STR
11634: PPUSH
11635: CALL_OW 38
// if Cyrus in save_group then
11639: LD_EXP 35
11643: PUSH
11644: LD_EXP 22
11648: IN
11649: IFFALSE 11669
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11651: LD_EXP 35
11655: PPUSH
11656: LD_EXP 2
11660: PUSH
11661: LD_STRING Cyrus
11663: STR
11664: PPUSH
11665: CALL_OW 38
// if Lisa in save_group then
11669: LD_EXP 36
11673: PUSH
11674: LD_EXP 22
11678: IN
11679: IFFALSE 11699
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
11681: LD_EXP 36
11685: PPUSH
11686: LD_EXP 2
11690: PUSH
11691: LD_STRING Lisa
11693: STR
11694: PPUSH
11695: CALL_OW 38
// if Frank in save_group then
11699: LD_EXP 47
11703: PUSH
11704: LD_EXP 22
11708: IN
11709: IFFALSE 11729
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
11711: LD_EXP 47
11715: PPUSH
11716: LD_EXP 2
11720: PUSH
11721: LD_STRING Frank
11723: STR
11724: PPUSH
11725: CALL_OW 38
// if Khatam in save_group then
11729: LD_EXP 37
11733: PUSH
11734: LD_EXP 22
11738: IN
11739: IFFALSE 11759
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
11741: LD_EXP 37
11745: PPUSH
11746: LD_EXP 2
11750: PUSH
11751: LD_STRING Khatam
11753: STR
11754: PPUSH
11755: CALL_OW 38
// if save_others then
11759: LD_EXP 21
11763: IFFALSE 11777
// SaveCharacters ( save_others , 03_others ) ;
11765: LD_EXP 21
11769: PPUSH
11770: LD_STRING 03_others
11772: PPUSH
11773: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) then
11777: LD_EXP 41
11781: PUSH
11782: LD_EXP 41
11786: PPUSH
11787: CALL_OW 302
11791: AND
11792: IFFALSE 11804
// begin ResetFog ;
11794: CALL_OW 335
// DisplayEndingScene ;
11798: CALL 11826 0 0
// end else
11802: GO 11817
// DeleteCharacters ( mission_prefix & Cornel ) ;
11804: LD_EXP 2
11808: PUSH
11809: LD_STRING Cornel
11811: STR
11812: PPUSH
11813: CALL_OW 40
// YouWin ;
11817: CALL_OW 103
// end ;
11821: LD_VAR 0 1
11825: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
11826: LD_INT 0
11828: PPUSH
11829: PPUSH
11830: PPUSH
11831: PPUSH
11832: PPUSH
11833: PPUSH
// InGameOn ;
11834: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
11838: LD_INT 208
11840: PPUSH
11841: LD_INT 62
11843: PPUSH
11844: LD_INT 1
11846: PPUSH
11847: LD_INT 10
11849: NEG
11850: PPUSH
11851: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
11855: LD_INT 208
11857: PPUSH
11858: LD_INT 62
11860: PPUSH
11861: LD_INT 1
11863: PPUSH
11864: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11868: LD_ADDR_VAR 0 3
11872: PUSH
11873: LD_INT 22
11875: PUSH
11876: LD_INT 3
11878: PUSH
11879: EMPTY
11880: LIST
11881: LIST
11882: PUSH
11883: LD_INT 2
11885: PUSH
11886: LD_INT 21
11888: PUSH
11889: LD_INT 2
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: PUSH
11896: LD_INT 21
11898: PUSH
11899: LD_INT 1
11901: PUSH
11902: EMPTY
11903: LIST
11904: LIST
11905: PUSH
11906: EMPTY
11907: LIST
11908: LIST
11909: LIST
11910: PUSH
11911: EMPTY
11912: LIST
11913: LIST
11914: PPUSH
11915: CALL_OW 69
11919: ST_TO_ADDR
// if filter then
11920: LD_VAR 0 3
11924: IFFALSE 11952
// for i in filter do
11926: LD_ADDR_VAR 0 2
11930: PUSH
11931: LD_VAR 0 3
11935: PUSH
11936: FOR_IN
11937: IFFALSE 11950
// RemoveUnit ( i ) ;
11939: LD_VAR 0 2
11943: PPUSH
11944: CALL_OW 64
11948: GO 11936
11950: POP
11951: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
11952: LD_ADDR_VAR 0 3
11956: PUSH
11957: LD_INT 22
11959: PUSH
11960: LD_INT 4
11962: PUSH
11963: EMPTY
11964: LIST
11965: LIST
11966: PUSH
11967: LD_INT 21
11969: PUSH
11970: LD_INT 1
11972: PUSH
11973: EMPTY
11974: LIST
11975: LIST
11976: PUSH
11977: EMPTY
11978: LIST
11979: LIST
11980: PPUSH
11981: CALL_OW 69
11985: ST_TO_ADDR
// if filter then
11986: LD_VAR 0 3
11990: IFFALSE 12021
// for i in filter do
11992: LD_ADDR_VAR 0 2
11996: PUSH
11997: LD_VAR 0 3
12001: PUSH
12002: FOR_IN
12003: IFFALSE 12019
// SetLives ( i , 0 ) ;
12005: LD_VAR 0 2
12009: PPUSH
12010: LD_INT 0
12012: PPUSH
12013: CALL_OW 234
12017: GO 12002
12019: POP
12020: POP
// uc_side := 4 ;
12021: LD_ADDR_OWVAR 20
12025: PUSH
12026: LD_INT 4
12028: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12029: LD_ADDR_VAR 0 4
12033: PUSH
12034: LD_STRING Cornell
12036: PPUSH
12037: LD_INT 0
12039: PPUSH
12040: CALL 450 0 2
12044: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12045: LD_VAR 0 4
12049: PPUSH
12050: LD_INT 208
12052: PPUSH
12053: LD_INT 62
12055: PPUSH
12056: LD_INT 0
12058: PPUSH
12059: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12063: LD_VAR 0 4
12067: PPUSH
12068: LD_INT 100
12070: PPUSH
12071: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12075: LD_INT 3
12077: PPUSH
12078: LD_VAR 0 4
12082: PPUSH
12083: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12087: LD_INT 4
12089: PPUSH
12090: LD_INT 3
12092: PPUSH
12093: LD_INT 1
12095: PPUSH
12096: LD_INT 1
12098: PPUSH
12099: CALL_OW 80
// uc_side := 3 ;
12103: LD_ADDR_OWVAR 20
12107: PUSH
12108: LD_INT 3
12110: ST_TO_ADDR
// uc_nation := 3 ;
12111: LD_ADDR_OWVAR 21
12115: PUSH
12116: LD_INT 3
12118: ST_TO_ADDR
// InitHc ;
12119: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12123: LD_ADDR_VAR 0 5
12127: PUSH
12128: LD_STRING Mikhail
12130: PPUSH
12131: LD_INT 0
12133: PPUSH
12134: CALL 450 0 2
12138: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12139: LD_INT 1
12141: PPUSH
12142: LD_INT 1
12144: PPUSH
12145: LD_INT 0
12147: PPUSH
12148: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12152: LD_ADDR_VAR 0 6
12156: PUSH
12157: LD_VAR 0 6
12161: PUSH
12162: CALL_OW 44
12166: ADD
12167: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12168: LD_ADDR_VAR 0 6
12172: PUSH
12173: LD_VAR 0 6
12177: PUSH
12178: CALL_OW 44
12182: ADD
12183: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12184: LD_INT 2
12186: PPUSH
12187: LD_INT 4
12189: PPUSH
12190: LD_INT 0
12192: PPUSH
12193: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12197: LD_ADDR_VAR 0 6
12201: PUSH
12202: LD_VAR 0 6
12206: PUSH
12207: CALL_OW 44
12211: ADD
12212: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12213: LD_VAR 0 5
12217: PPUSH
12218: LD_INT 17
12220: PPUSH
12221: LD_INT 0
12223: PPUSH
12224: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12228: LD_VAR 0 5
12232: PPUSH
12233: LD_INT 210
12235: PPUSH
12236: LD_INT 63
12238: PPUSH
12239: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12243: LD_VAR 0 5
12247: PPUSH
12248: LD_INT 208
12250: PPUSH
12251: LD_INT 62
12253: PPUSH
12254: CALL_OW 178
// for i in fake_russians do
12258: LD_ADDR_VAR 0 2
12262: PUSH
12263: LD_VAR 0 6
12267: PUSH
12268: FOR_IN
12269: IFFALSE 12347
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12271: LD_VAR 0 2
12275: PPUSH
12276: LD_INT 17
12278: PPUSH
12279: LD_INT 0
12281: PPUSH
12282: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
12286: LD_VAR 0 2
12290: PPUSH
12291: LD_INT 215
12293: PPUSH
12294: LD_INT 67
12296: PPUSH
12297: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
12301: LD_VAR 0 2
12305: PPUSH
12306: LD_INT 208
12308: PPUSH
12309: LD_INT 62
12311: PPUSH
12312: CALL_OW 178
// if GetClass ( i ) = 4 then
12316: LD_VAR 0 2
12320: PPUSH
12321: CALL_OW 257
12325: PUSH
12326: LD_INT 4
12328: EQUAL
12329: IFFALSE 12345
// ComHeal ( i , fake_cornel ) ;
12331: LD_VAR 0 2
12335: PPUSH
12336: LD_VAR 0 4
12340: PPUSH
12341: CALL_OW 128
// end ;
12345: GO 12268
12347: POP
12348: POP
// Wait ( 0 0$01 ) ;
12349: LD_INT 35
12351: PPUSH
12352: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
12356: LD_INT 208
12358: PPUSH
12359: LD_INT 62
12361: PPUSH
12362: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12366: LD_INT 208
12368: PPUSH
12369: LD_INT 62
12371: PPUSH
12372: LD_INT 1
12374: PPUSH
12375: LD_INT 10
12377: NEG
12378: PPUSH
12379: CALL_OW 330
// Wait ( 0 0$15 ) ;
12383: LD_INT 525
12385: PPUSH
12386: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
12390: LD_INT 208
12392: PPUSH
12393: LD_INT 62
12395: PPUSH
12396: LD_INT 1
12398: PPUSH
12399: CALL_OW 331
// ResetFog ;
12403: CALL_OW 335
// InGameOff ;
12407: CALL_OW 9
// end ;
12411: LD_VAR 0 1
12415: RET
// every 0 0$30 trigger GetDistUnits ( JMM , Cornel ) < 3 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) do
12416: LD_EXP 33
12420: PPUSH
12421: LD_EXP 40
12425: PPUSH
12426: CALL_OW 296
12430: PUSH
12431: LD_INT 3
12433: LESS
12434: PUSH
12435: LD_INT 22
12437: PUSH
12438: LD_INT 4
12440: PUSH
12441: EMPTY
12442: LIST
12443: LIST
12444: PUSH
12445: LD_INT 21
12447: PUSH
12448: LD_INT 3
12450: PUSH
12451: EMPTY
12452: LIST
12453: LIST
12454: PUSH
12455: EMPTY
12456: LIST
12457: LIST
12458: PPUSH
12459: CALL_OW 69
12463: AND
12464: IFFALSE 12482
12466: GO 12468
12468: DISABLE
// begin enable ;
12469: ENABLE
// SayRadio ( Powell , DWarn-Pow-1 ) ;
12470: LD_EXP 42
12474: PPUSH
12475: LD_STRING DWarn-Pow-1
12477: PPUSH
12478: CALL_OW 94
// end ; end_of_file
12482: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
12483: LD_EXP 8
12487: IFFALSE 13823
12489: GO 12491
12491: DISABLE
12492: LD_INT 0
12494: PPUSH
12495: PPUSH
12496: PPUSH
12497: PPUSH
12498: PPUSH
12499: PPUSH
12500: PPUSH
12501: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
12502: LD_EXP 40
12506: PUSH
12507: LD_EXP 41
12511: ADD
12512: PUSH
12513: LD_EXP 6
12517: ADD
12518: PPUSH
12519: LD_INT 250
12521: PPUSH
12522: LD_INT 120
12524: PPUSH
12525: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff [ Bierezov ] ;
12529: LD_ADDR_VAR 0 2
12533: PUSH
12534: LD_EXP 6
12538: PPUSH
12539: LD_INT 25
12541: PUSH
12542: LD_INT 2
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PPUSH
12549: CALL_OW 72
12553: PUSH
12554: LD_EXP 41
12558: PUSH
12559: EMPTY
12560: LIST
12561: DIFF
12562: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
12563: LD_ADDR_VAR 0 3
12567: PUSH
12568: LD_EXP 6
12572: PPUSH
12573: LD_INT 21
12575: PUSH
12576: LD_INT 1
12578: PUSH
12579: EMPTY
12580: LIST
12581: LIST
12582: PPUSH
12583: CALL_OW 72
12587: ST_TO_ADDR
// if not has_eng then
12588: LD_VAR 0 2
12592: NOT
12593: IFFALSE 12676
// begin uc_side := 4 ;
12595: LD_ADDR_OWVAR 20
12599: PUSH
12600: LD_INT 4
12602: ST_TO_ADDR
// uc_nation := 1 ;
12603: LD_ADDR_OWVAR 21
12607: PUSH
12608: LD_INT 1
12610: ST_TO_ADDR
// bc_type := b_depot ;
12611: LD_ADDR_OWVAR 42
12615: PUSH
12616: LD_INT 0
12618: ST_TO_ADDR
// bc_level := 2 ;
12619: LD_ADDR_OWVAR 43
12623: PUSH
12624: LD_INT 2
12626: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
12627: LD_ADDR_VAR 0 4
12631: PUSH
12632: LD_INT 264
12634: PPUSH
12635: LD_INT 120
12637: PPUSH
12638: LD_INT 4
12640: PPUSH
12641: CALL_OW 47
12645: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
12646: LD_INT 264
12648: PPUSH
12649: LD_INT 120
12651: PPUSH
12652: LD_INT 4
12654: PPUSH
12655: LD_INT 10
12657: NEG
12658: PPUSH
12659: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
12663: LD_INT 264
12665: PPUSH
12666: LD_INT 120
12668: PPUSH
12669: LD_INT 4
12671: PPUSH
12672: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
12676: LD_INT 35
12678: PPUSH
12679: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
12683: LD_EXP 40
12687: PPUSH
12688: LD_INT 10
12690: PPUSH
12691: CALL_OW 308
12695: IFFALSE 12676
// if has_eng and not dep then
12697: LD_VAR 0 2
12701: PUSH
12702: LD_VAR 0 4
12706: NOT
12707: AND
12708: IFFALSE 12858
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
12710: LD_VAR 0 2
12714: PPUSH
12715: LD_INT 0
12717: PPUSH
12718: LD_INT 264
12720: PPUSH
12721: LD_INT 120
12723: PPUSH
12724: LD_INT 4
12726: PPUSH
12727: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
12731: LD_INT 35
12733: PPUSH
12734: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
12738: LD_INT 22
12740: PUSH
12741: LD_INT 4
12743: PUSH
12744: EMPTY
12745: LIST
12746: LIST
12747: PUSH
12748: LD_INT 30
12750: PUSH
12751: LD_INT 0
12753: PUSH
12754: EMPTY
12755: LIST
12756: LIST
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PPUSH
12762: CALL_OW 69
12766: IFFALSE 12731
// ComMoveXY ( filter , 264 , 120 ) ;
12768: LD_VAR 0 3
12772: PPUSH
12773: LD_INT 264
12775: PPUSH
12776: LD_INT 120
12778: PPUSH
12779: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
12783: LD_INT 35
12785: PPUSH
12786: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
12790: LD_INT 22
12792: PUSH
12793: LD_INT 4
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: LD_INT 30
12802: PUSH
12803: LD_INT 0
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PUSH
12810: LD_INT 3
12812: PUSH
12813: LD_INT 57
12815: PUSH
12816: EMPTY
12817: LIST
12818: PUSH
12819: EMPTY
12820: LIST
12821: LIST
12822: PUSH
12823: EMPTY
12824: LIST
12825: LIST
12826: LIST
12827: PPUSH
12828: CALL_OW 69
12832: IFFALSE 12783
// ComMoveXY ( filter , 247 , 113 ) ;
12834: LD_VAR 0 3
12838: PPUSH
12839: LD_INT 247
12841: PPUSH
12842: LD_INT 113
12844: PPUSH
12845: CALL_OW 111
// Wait ( 0 0$2 ) ;
12849: LD_INT 70
12851: PPUSH
12852: CALL_OW 67
// end else
12856: GO 12870
// begin SetSide ( dep , 4 ) ;
12858: LD_VAR 0 4
12862: PPUSH
12863: LD_INT 4
12865: PPUSH
12866: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
12870: LD_ADDR_VAR 0 4
12874: PUSH
12875: LD_INT 22
12877: PUSH
12878: LD_INT 4
12880: PUSH
12881: EMPTY
12882: LIST
12883: LIST
12884: PUSH
12885: LD_INT 30
12887: PUSH
12888: LD_INT 0
12890: PUSH
12891: EMPTY
12892: LIST
12893: LIST
12894: PUSH
12895: EMPTY
12896: LIST
12897: LIST
12898: PPUSH
12899: CALL_OW 69
12903: PUSH
12904: LD_INT 1
12906: ARRAY
12907: ST_TO_ADDR
// for i = 1 to 3 - has_eng do
12908: LD_ADDR_VAR 0 1
12912: PUSH
12913: DOUBLE
12914: LD_INT 1
12916: DEC
12917: ST_TO_ADDR
12918: LD_INT 3
12920: PUSH
12921: LD_VAR 0 2
12925: MINUS
12926: PUSH
12927: FOR_TO
12928: IFFALSE 13008
// begin if GetClass ( filter [ i ] ) = 2 then
12930: LD_VAR 0 3
12934: PUSH
12935: LD_VAR 0 1
12939: ARRAY
12940: PPUSH
12941: CALL_OW 257
12945: PUSH
12946: LD_INT 2
12948: EQUAL
12949: IFFALSE 12953
// continue ;
12951: GO 12927
// ComEnterUnit ( filter [ i ] , dep ) ;
12953: LD_VAR 0 3
12957: PUSH
12958: LD_VAR 0 1
12962: ARRAY
12963: PPUSH
12964: LD_VAR 0 4
12968: PPUSH
12969: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
12973: LD_VAR 0 3
12977: PUSH
12978: LD_VAR 0 1
12982: ARRAY
12983: PPUSH
12984: LD_INT 2
12986: PPUSH
12987: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
12991: LD_VAR 0 3
12995: PUSH
12996: LD_VAR 0 1
13000: ARRAY
13001: PPUSH
13002: CALL_OW 182
// end ;
13006: GO 12927
13008: POP
13009: POP
// repeat wait ( 0 0$01 ) ;
13010: LD_INT 35
13012: PPUSH
13013: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
13017: LD_VAR 0 3
13021: PPUSH
13022: LD_INT 25
13024: PUSH
13025: LD_INT 2
13027: PUSH
13028: EMPTY
13029: LIST
13030: LIST
13031: PPUSH
13032: CALL_OW 72
13036: PUSH
13037: LD_INT 3
13039: EQUAL
13040: IFFALSE 13010
// if IsInUnit ( Cornel ) then
13042: LD_EXP 40
13046: PPUSH
13047: CALL_OW 310
13051: IFFALSE 13134
// begin cargo := IsInUnit ( Cornel ) ;
13053: LD_ADDR_VAR 0 7
13057: PUSH
13058: LD_EXP 40
13062: PPUSH
13063: CALL_OW 310
13067: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13068: LD_VAR 0 7
13072: PPUSH
13073: LD_INT 1
13075: PPUSH
13076: CALL_OW 289
13080: IFFALSE 13096
// ComGive ( Cornel , dep ) ;
13082: LD_EXP 40
13086: PPUSH
13087: LD_VAR 0 4
13091: PPUSH
13092: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13096: LD_EXP 40
13100: PPUSH
13101: LD_INT 235
13103: PPUSH
13104: LD_INT 122
13106: PPUSH
13107: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13111: LD_EXP 40
13115: PPUSH
13116: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13120: LD_EXP 40
13124: PPUSH
13125: LD_VAR 0 4
13129: PPUSH
13130: CALL_OW 180
// end ; if Bierezov then
13134: LD_EXP 41
13138: IFFALSE 13154
// ComEnterUnit ( Bierezov , dep ) ;
13140: LD_EXP 41
13144: PPUSH
13145: LD_VAR 0 4
13149: PPUSH
13150: CALL_OW 120
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
13154: LD_ADDR_VAR 0 2
13158: PUSH
13159: LD_EXP 6
13163: PPUSH
13164: LD_INT 25
13166: PUSH
13167: LD_INT 2
13169: PUSH
13170: EMPTY
13171: LIST
13172: LIST
13173: PPUSH
13174: CALL_OW 72
13178: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13179: LD_INT 35
13181: PPUSH
13182: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13186: LD_ADDR_VAR 0 6
13190: PUSH
13191: LD_INT 10
13193: PPUSH
13194: CALL_OW 435
13198: ST_TO_ADDR
// if crates then
13199: LD_VAR 0 6
13203: IFFALSE 13232
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
13205: LD_VAR 0 2
13209: PPUSH
13210: LD_VAR 0 6
13214: PUSH
13215: LD_INT 1
13217: ARRAY
13218: PPUSH
13219: LD_VAR 0 6
13223: PUSH
13224: LD_INT 2
13226: ARRAY
13227: PPUSH
13228: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
13232: LD_VAR 0 4
13236: PPUSH
13237: CALL_OW 274
13241: PPUSH
13242: LD_INT 1
13244: PPUSH
13245: CALL_OW 275
13249: PUSH
13250: LD_INT 40
13252: GREATEREQUAL
13253: IFFALSE 13179
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
13255: LD_ADDR_VAR 0 5
13259: PUSH
13260: LD_INT 4
13262: PUSH
13263: LD_INT 256
13265: PUSH
13266: LD_INT 111
13268: PUSH
13269: LD_INT 2
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: PUSH
13278: LD_INT 31
13280: PUSH
13281: LD_INT 243
13283: PUSH
13284: LD_INT 112
13286: PUSH
13287: LD_INT 2
13289: PUSH
13290: EMPTY
13291: LIST
13292: LIST
13293: LIST
13294: LIST
13295: PUSH
13296: EMPTY
13297: LIST
13298: LIST
13299: ST_TO_ADDR
// for i in blist do
13300: LD_ADDR_VAR 0 1
13304: PUSH
13305: LD_VAR 0 5
13309: PUSH
13310: FOR_IN
13311: IFFALSE 13360
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
13313: LD_VAR 0 2
13317: PPUSH
13318: LD_VAR 0 1
13322: PUSH
13323: LD_INT 1
13325: ARRAY
13326: PPUSH
13327: LD_VAR 0 1
13331: PUSH
13332: LD_INT 2
13334: ARRAY
13335: PPUSH
13336: LD_VAR 0 1
13340: PUSH
13341: LD_INT 3
13343: ARRAY
13344: PPUSH
13345: LD_VAR 0 1
13349: PUSH
13350: LD_INT 4
13352: ARRAY
13353: PPUSH
13354: CALL_OW 205
13358: GO 13310
13360: POP
13361: POP
// repeat wait ( 0 0$01 ) ;
13362: LD_INT 35
13364: PPUSH
13365: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
13369: LD_INT 22
13371: PUSH
13372: LD_INT 4
13374: PUSH
13375: EMPTY
13376: LIST
13377: LIST
13378: PUSH
13379: LD_INT 30
13381: PUSH
13382: LD_INT 4
13384: PUSH
13385: EMPTY
13386: LIST
13387: LIST
13388: PUSH
13389: LD_INT 3
13391: PUSH
13392: LD_INT 57
13394: PUSH
13395: EMPTY
13396: LIST
13397: PUSH
13398: EMPTY
13399: LIST
13400: LIST
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: LIST
13406: PPUSH
13407: CALL_OW 69
13411: IFFALSE 13362
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
13413: LD_VAR 0 3
13417: PUSH
13418: LD_VAR 0 2
13422: DIFF
13423: PPUSH
13424: LD_INT 22
13426: PUSH
13427: LD_INT 4
13429: PUSH
13430: EMPTY
13431: LIST
13432: LIST
13433: PUSH
13434: LD_INT 30
13436: PUSH
13437: LD_INT 4
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: PUSH
13444: EMPTY
13445: LIST
13446: LIST
13447: PPUSH
13448: CALL_OW 69
13452: PUSH
13453: LD_INT 1
13455: ARRAY
13456: PPUSH
13457: CALL_OW 180
// AddComChangeProfession ( filter diff has_eng , 1 ) ;
13461: LD_VAR 0 3
13465: PUSH
13466: LD_VAR 0 2
13470: DIFF
13471: PPUSH
13472: LD_INT 1
13474: PPUSH
13475: CALL_OW 183
// repeat wait ( 0 0$01 ) ;
13479: LD_INT 35
13481: PPUSH
13482: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
13486: LD_INT 22
13488: PUSH
13489: LD_INT 4
13491: PUSH
13492: EMPTY
13493: LIST
13494: LIST
13495: PUSH
13496: LD_INT 30
13498: PUSH
13499: LD_INT 31
13501: PUSH
13502: EMPTY
13503: LIST
13504: LIST
13505: PUSH
13506: LD_INT 3
13508: PUSH
13509: LD_INT 57
13511: PUSH
13512: EMPTY
13513: LIST
13514: PUSH
13515: EMPTY
13516: LIST
13517: LIST
13518: PUSH
13519: EMPTY
13520: LIST
13521: LIST
13522: LIST
13523: PPUSH
13524: CALL_OW 69
13528: IFFALSE 13479
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
13530: LD_ADDR_VAR 0 8
13534: PUSH
13535: LD_EXP 6
13539: PPUSH
13540: LD_INT 25
13542: PUSH
13543: LD_INT 1
13545: PUSH
13546: EMPTY
13547: LIST
13548: LIST
13549: PPUSH
13550: CALL_OW 72
13554: ST_TO_ADDR
// ComExitBuilding ( sol [ 1 ] ) ;
13555: LD_VAR 0 8
13559: PUSH
13560: LD_INT 1
13562: ARRAY
13563: PPUSH
13564: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
13568: LD_VAR 0 8
13572: PUSH
13573: LD_INT 1
13575: ARRAY
13576: PPUSH
13577: LD_INT 22
13579: PUSH
13580: LD_INT 4
13582: PUSH
13583: EMPTY
13584: LIST
13585: LIST
13586: PUSH
13587: LD_INT 30
13589: PUSH
13590: LD_INT 31
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: PUSH
13597: EMPTY
13598: LIST
13599: LIST
13600: PPUSH
13601: CALL_OW 69
13605: PUSH
13606: LD_INT 1
13608: ARRAY
13609: PPUSH
13610: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
13614: LD_VAR 0 2
13618: PPUSH
13619: LD_VAR 0 4
13623: PPUSH
13624: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
13628: LD_INT 35
13630: PPUSH
13631: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13635: LD_ADDR_VAR 0 3
13639: PUSH
13640: LD_INT 22
13642: PUSH
13643: LD_INT 4
13645: PUSH
13646: EMPTY
13647: LIST
13648: LIST
13649: PUSH
13650: LD_INT 21
13652: PUSH
13653: LD_INT 3
13655: PUSH
13656: EMPTY
13657: LIST
13658: LIST
13659: PUSH
13660: LD_INT 3
13662: PUSH
13663: LD_INT 24
13665: PUSH
13666: LD_INT 1000
13668: PUSH
13669: EMPTY
13670: LIST
13671: LIST
13672: PUSH
13673: EMPTY
13674: LIST
13675: LIST
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: LIST
13681: PPUSH
13682: CALL_OW 69
13686: ST_TO_ADDR
// if filter and has_eng then
13687: LD_VAR 0 3
13691: PUSH
13692: LD_VAR 0 2
13696: AND
13697: IFFALSE 13763
// begin for i in has_eng do
13699: LD_ADDR_VAR 0 1
13703: PUSH
13704: LD_VAR 0 2
13708: PUSH
13709: FOR_IN
13710: IFFALSE 13759
// begin if IsInUnit ( i ) then
13712: LD_VAR 0 1
13716: PPUSH
13717: CALL_OW 310
13721: IFFALSE 13732
// ComExitBuilding ( i ) ;
13723: LD_VAR 0 1
13727: PPUSH
13728: CALL_OW 122
// Wait ( 3 ) ;
13732: LD_INT 3
13734: PPUSH
13735: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
13739: LD_VAR 0 1
13743: PPUSH
13744: LD_VAR 0 3
13748: PUSH
13749: LD_INT 1
13751: ARRAY
13752: PPUSH
13753: CALL_OW 130
// end ;
13757: GO 13709
13759: POP
13760: POP
// end else
13761: GO 13817
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
13763: LD_VAR 0 2
13767: PUSH
13768: LD_VAR 0 2
13772: PPUSH
13773: LD_INT 56
13775: PUSH
13776: EMPTY
13777: LIST
13778: PPUSH
13779: CALL_OW 72
13783: AND
13784: IFFALSE 13817
// for i in has_eng do
13786: LD_ADDR_VAR 0 1
13790: PUSH
13791: LD_VAR 0 2
13795: PUSH
13796: FOR_IN
13797: IFFALSE 13815
// ComEnterUnit ( i , dep ) ;
13799: LD_VAR 0 1
13803: PPUSH
13804: LD_VAR 0 4
13808: PPUSH
13809: CALL_OW 120
13813: GO 13796
13815: POP
13816: POP
// until cornel_prepared ;
13817: LD_EXP 11
13821: IFFALSE 13628
// end ;
13823: PPOPN 8
13825: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
13826: LD_EXP 11
13830: IFFALSE 14179
13832: GO 13834
13834: DISABLE
13835: LD_INT 0
13837: PPUSH
13838: PPUSH
13839: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
13840: LD_ADDR_VAR 0 2
13844: PUSH
13845: LD_INT 22
13847: PUSH
13848: LD_INT 4
13850: PUSH
13851: EMPTY
13852: LIST
13853: LIST
13854: PUSH
13855: LD_INT 30
13857: PUSH
13858: LD_INT 4
13860: PUSH
13861: EMPTY
13862: LIST
13863: LIST
13864: PUSH
13865: EMPTY
13866: LIST
13867: LIST
13868: PPUSH
13869: CALL_OW 69
13873: PUSH
13874: LD_INT 1
13876: ARRAY
13877: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
13878: LD_EXP 6
13882: PPUSH
13883: CALL_OW 122
// Wait ( 0 0$03 ) ;
13887: LD_INT 105
13889: PPUSH
13890: CALL_OW 67
// for i in cornel_units do
13894: LD_ADDR_VAR 0 1
13898: PUSH
13899: LD_EXP 6
13903: PUSH
13904: FOR_IN
13905: IFFALSE 13981
// begin if GetClass ( i ) in [ 2 , 3 ] then
13907: LD_VAR 0 1
13911: PPUSH
13912: CALL_OW 257
13916: PUSH
13917: LD_INT 2
13919: PUSH
13920: LD_INT 3
13922: PUSH
13923: EMPTY
13924: LIST
13925: LIST
13926: IN
13927: IFFALSE 13964
// begin ComEnterUnit ( i , arm ) ;
13929: LD_VAR 0 1
13933: PPUSH
13934: LD_VAR 0 2
13938: PPUSH
13939: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
13943: LD_VAR 0 1
13947: PPUSH
13948: LD_INT 1
13950: PPUSH
13951: CALL_OW 183
// AddComExitBuilding ( i ) ;
13955: LD_VAR 0 1
13959: PPUSH
13960: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
13964: LD_VAR 0 1
13968: PPUSH
13969: LD_INT 257
13971: PPUSH
13972: LD_INT 121
13974: PPUSH
13975: CALL_OW 171
// end ;
13979: GO 13904
13981: POP
13982: POP
// Wait ( 1 1$00 ) ;
13983: LD_INT 2100
13985: PPUSH
13986: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
13990: LD_ADDR_VAR 0 3
13994: PUSH
13995: LD_EXP 40
13999: PUSH
14000: LD_EXP 41
14004: ADD
14005: PUSH
14006: LD_EXP 6
14010: ADD
14011: PUSH
14012: LD_EXP 6
14016: PPUSH
14017: LD_INT 21
14019: PUSH
14020: LD_INT 2
14022: PUSH
14023: EMPTY
14024: LIST
14025: LIST
14026: PPUSH
14027: CALL_OW 72
14031: DIFF
14032: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
14033: LD_VAR 0 3
14037: PPUSH
14038: LD_INT 248
14040: PPUSH
14041: LD_INT 85
14043: PPUSH
14044: CALL_OW 111
// AddComHold ( filter ) ;
14048: LD_VAR 0 3
14052: PPUSH
14053: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
14057: LD_INT 35
14059: PPUSH
14060: CALL_OW 67
// until cornel_attack ;
14064: LD_EXP 9
14068: IFFALSE 14057
// ComAgressiveMove ( filter , 209 , 63 ) ;
14070: LD_VAR 0 3
14074: PPUSH
14075: LD_INT 209
14077: PPUSH
14078: LD_INT 63
14080: PPUSH
14081: CALL_OW 114
// if Bierezov then
14085: LD_EXP 41
14089: IFFALSE 14179
// begin filter := filter diff Bierezov ;
14091: LD_ADDR_VAR 0 3
14095: PUSH
14096: LD_VAR 0 3
14100: PUSH
14101: LD_EXP 41
14105: DIFF
14106: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
14107: LD_EXP 41
14111: PPUSH
14112: LD_INT 6
14114: PPUSH
14115: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
14119: LD_EXP 41
14123: PPUSH
14124: LD_INT 235
14126: PPUSH
14127: LD_INT 60
14129: PPUSH
14130: CALL_OW 111
// AddComHold ( Bierezov ) ;
14134: LD_EXP 41
14138: PPUSH
14139: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
14143: LD_EXP 41
14147: PPUSH
14148: LD_INT 350
14150: PPUSH
14151: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
14155: LD_EXP 41
14159: PPUSH
14160: LD_INT 198
14162: PPUSH
14163: LD_INT 28
14165: PPUSH
14166: CALL_OW 171
// AddComHold ( Bierezov ) ;
14170: LD_EXP 41
14174: PPUSH
14175: CALL_OW 200
// end ; end ; end_of_file
14179: PPOPN 3
14181: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
14182: LD_EXP 49
14186: PUSH
14187: LD_EXP 29
14191: NOT
14192: AND
14193: PUSH
14194: LD_EXP 30
14198: NOT
14199: AND
14200: IFFALSE 14650
14202: GO 14204
14204: DISABLE
14205: LD_INT 0
14207: PPUSH
14208: PPUSH
14209: PPUSH
14210: PPUSH
// begin enable ;
14211: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14212: LD_ADDR_VAR 0 4
14216: PUSH
14217: LD_INT 81
14219: PUSH
14220: LD_INT 3
14222: PUSH
14223: EMPTY
14224: LIST
14225: LIST
14226: PPUSH
14227: CALL_OW 69
14231: ST_TO_ADDR
// for i = 1 to ru_patrol do
14232: LD_ADDR_VAR 0 2
14236: PUSH
14237: DOUBLE
14238: LD_INT 1
14240: DEC
14241: ST_TO_ADDR
14242: LD_EXP 49
14246: PUSH
14247: FOR_TO
14248: IFFALSE 14648
// begin un := ru_patrol [ i ] ;
14250: LD_ADDR_VAR 0 1
14254: PUSH
14255: LD_EXP 49
14259: PUSH
14260: LD_VAR 0 2
14264: ARRAY
14265: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14266: LD_VAR 0 1
14270: PPUSH
14271: LD_INT 13
14273: PPUSH
14274: CALL_OW 308
14278: IFFALSE 14383
// begin if not ru_alert then
14280: LD_EXP 56
14284: NOT
14285: IFFALSE 14295
// ru_alert := true ;
14287: LD_ADDR_EXP 56
14291: PUSH
14292: LD_INT 1
14294: ST_TO_ADDR
// if not See ( 1 , un ) then
14295: LD_INT 1
14297: PPUSH
14298: LD_VAR 0 1
14302: PPUSH
14303: CALL_OW 292
14307: NOT
14308: IFFALSE 14322
// SetLives ( un , 1000 ) ;
14310: LD_VAR 0 1
14314: PPUSH
14315: LD_INT 1000
14317: PPUSH
14318: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
14322: LD_ADDR_EXP 49
14326: PUSH
14327: LD_EXP 49
14331: PUSH
14332: LD_VAR 0 1
14336: DIFF
14337: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
14338: LD_VAR 0 1
14342: PPUSH
14343: LD_INT 22
14345: PUSH
14346: LD_INT 3
14348: PUSH
14349: EMPTY
14350: LIST
14351: LIST
14352: PUSH
14353: LD_INT 30
14355: PUSH
14356: LD_INT 4
14358: PUSH
14359: EMPTY
14360: LIST
14361: LIST
14362: PUSH
14363: EMPTY
14364: LIST
14365: LIST
14366: PPUSH
14367: CALL_OW 69
14371: PPUSH
14372: CALL 1023 0 1
14376: PPUSH
14377: CALL_OW 120
// continue ;
14381: GO 14247
// end ; if IsOk ( un ) and not HasTask ( un ) then
14383: LD_VAR 0 1
14387: PPUSH
14388: CALL_OW 302
14392: PUSH
14393: LD_VAR 0 1
14397: PPUSH
14398: CALL_OW 314
14402: NOT
14403: AND
14404: IFFALSE 14497
// begin for j = 1 to ru_firepoints_south [ i ] do
14406: LD_ADDR_VAR 0 3
14410: PUSH
14411: DOUBLE
14412: LD_INT 1
14414: DEC
14415: ST_TO_ADDR
14416: LD_EXP 55
14420: PUSH
14421: LD_VAR 0 2
14425: ARRAY
14426: PUSH
14427: FOR_TO
14428: IFFALSE 14495
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
14430: LD_VAR 0 1
14434: PPUSH
14435: LD_EXP 55
14439: PUSH
14440: LD_VAR 0 2
14444: ARRAY
14445: PUSH
14446: LD_VAR 0 3
14450: ARRAY
14451: PUSH
14452: LD_INT 1
14454: ARRAY
14455: PPUSH
14456: LD_EXP 55
14460: PUSH
14461: LD_VAR 0 2
14465: ARRAY
14466: PUSH
14467: LD_VAR 0 3
14471: ARRAY
14472: PUSH
14473: LD_INT 2
14475: ARRAY
14476: PPUSH
14477: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
14481: LD_VAR 0 1
14485: PPUSH
14486: LD_INT 70
14488: PPUSH
14489: CALL_OW 202
// end ;
14493: GO 14427
14495: POP
14496: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
14497: LD_VAR 0 1
14501: PPUSH
14502: CALL_OW 256
14506: PUSH
14507: LD_INT 700
14509: LESS
14510: PUSH
14511: LD_VAR 0 1
14515: PPUSH
14516: LD_INT 13
14518: PPUSH
14519: CALL_OW 308
14523: NOT
14524: AND
14525: IFFALSE 14577
// begin ComMoveToArea ( un , retreatArea ) ;
14527: LD_VAR 0 1
14531: PPUSH
14532: LD_INT 13
14534: PPUSH
14535: CALL_OW 113
// if not ru_alert_xy then
14539: LD_EXP 57
14543: NOT
14544: IFFALSE 14575
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
14546: LD_ADDR_EXP 57
14550: PUSH
14551: LD_VAR 0 1
14555: PPUSH
14556: CALL_OW 250
14560: PUSH
14561: LD_VAR 0 1
14565: PPUSH
14566: CALL_OW 251
14570: PUSH
14571: EMPTY
14572: LIST
14573: LIST
14574: ST_TO_ADDR
// end else
14575: GO 14646
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
14577: LD_VAR 0 1
14581: PPUSH
14582: LD_VAR 0 4
14586: PPUSH
14587: LD_VAR 0 1
14591: PPUSH
14592: CALL_OW 74
14596: PPUSH
14597: CALL_OW 296
14601: PUSH
14602: LD_INT 9
14604: LESS
14605: PUSH
14606: LD_VAR 0 1
14610: PPUSH
14611: CALL_OW 256
14615: PUSH
14616: LD_INT 500
14618: GREATER
14619: AND
14620: IFFALSE 14646
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
14622: LD_VAR 0 1
14626: PPUSH
14627: LD_VAR 0 4
14631: PPUSH
14632: LD_VAR 0 1
14636: PPUSH
14637: CALL_OW 74
14641: PPUSH
14642: CALL_OW 115
// end ;
14646: GO 14247
14648: POP
14649: POP
// end ;
14650: PPOPN 4
14652: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
14653: LD_EXP 56
14657: PUSH
14658: LD_EXP 57
14662: AND
14663: PUSH
14664: LD_EXP 29
14668: NOT
14669: AND
14670: PUSH
14671: LD_EXP 30
14675: NOT
14676: AND
14677: IFFALSE 14887
14679: GO 14681
14681: DISABLE
14682: LD_INT 0
14684: PPUSH
14685: PPUSH
// begin enable ;
14686: ENABLE
// if not ru_vehicles then
14687: LD_EXP 52
14691: NOT
14692: IFFALSE 14696
// exit ;
14694: GO 14887
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14696: LD_ADDR_VAR 0 2
14700: PUSH
14701: LD_INT 81
14703: PUSH
14704: LD_INT 3
14706: PUSH
14707: EMPTY
14708: LIST
14709: LIST
14710: PPUSH
14711: CALL_OW 69
14715: ST_TO_ADDR
// if ru_vehicles then
14716: LD_EXP 52
14720: IFFALSE 14887
// begin for i in ru_vehicles do
14722: LD_ADDR_VAR 0 1
14726: PUSH
14727: LD_EXP 52
14731: PUSH
14732: FOR_IN
14733: IFFALSE 14885
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
14735: LD_VAR 0 1
14739: PPUSH
14740: CALL_OW 302
14744: PUSH
14745: LD_VAR 0 1
14749: PPUSH
14750: LD_VAR 0 2
14754: PPUSH
14755: LD_VAR 0 1
14759: PPUSH
14760: CALL_OW 74
14764: PPUSH
14765: CALL_OW 296
14769: PUSH
14770: LD_INT 9
14772: LESS
14773: AND
14774: IFFALSE 14800
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
14776: LD_VAR 0 1
14780: PPUSH
14781: LD_VAR 0 2
14785: PPUSH
14786: LD_VAR 0 1
14790: PPUSH
14791: CALL_OW 74
14795: PPUSH
14796: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
14800: LD_VAR 0 1
14804: PPUSH
14805: CALL_OW 314
14809: NOT
14810: PUSH
14811: LD_VAR 0 1
14815: PPUSH
14816: CALL_OW 302
14820: AND
14821: PUSH
14822: LD_VAR 0 1
14826: PPUSH
14827: LD_EXP 57
14831: PUSH
14832: LD_INT 1
14834: ARRAY
14835: PPUSH
14836: LD_EXP 57
14840: PUSH
14841: LD_INT 2
14843: ARRAY
14844: PPUSH
14845: CALL_OW 297
14849: PUSH
14850: LD_INT 10
14852: GREATER
14853: AND
14854: IFFALSE 14883
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
14856: LD_VAR 0 1
14860: PPUSH
14861: LD_EXP 57
14865: PUSH
14866: LD_INT 1
14868: ARRAY
14869: PPUSH
14870: LD_EXP 57
14874: PUSH
14875: LD_INT 2
14877: ARRAY
14878: PPUSH
14879: CALL_OW 114
// end ;
14883: GO 14732
14885: POP
14886: POP
// end ; end ;
14887: PPOPN 2
14889: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
14890: LD_EXP 57
14894: PUSH
14895: LD_EXP 56
14899: AND
14900: PUSH
14901: LD_INT 3
14903: PPUSH
14904: CALL_OW 463
14908: NOT
14909: AND
14910: PUSH
14911: LD_EXP 29
14915: NOT
14916: AND
14917: PUSH
14918: LD_EXP 30
14922: NOT
14923: AND
14924: IFFALSE 15019
14926: GO 14928
14928: DISABLE
14929: LD_INT 0
14931: PPUSH
// begin enable ;
14932: ENABLE
// ru_alert_xy := false ;
14933: LD_ADDR_EXP 57
14937: PUSH
14938: LD_INT 0
14940: ST_TO_ADDR
// ru_alert := false ;
14941: LD_ADDR_EXP 56
14945: PUSH
14946: LD_INT 0
14948: ST_TO_ADDR
// if ru_vehicles then
14949: LD_EXP 52
14953: IFFALSE 15019
// for i in ru_vehicles do
14955: LD_ADDR_VAR 0 1
14959: PUSH
14960: LD_EXP 52
14964: PUSH
14965: FOR_IN
14966: IFFALSE 15017
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
14968: LD_VAR 0 1
14972: PPUSH
14973: CALL_OW 302
14977: PUSH
14978: LD_VAR 0 1
14982: PPUSH
14983: LD_INT 89
14985: PPUSH
14986: LD_INT 36
14988: PPUSH
14989: CALL_OW 297
14993: PUSH
14994: LD_INT 10
14996: GREATER
14997: AND
14998: IFFALSE 15015
// ComMoveXY ( i , 89 , 36 ) ;
15000: LD_VAR 0 1
15004: PPUSH
15005: LD_INT 89
15007: PPUSH
15008: LD_INT 36
15010: PPUSH
15011: CALL_OW 111
15015: GO 14965
15017: POP
15018: POP
// end ;
15019: PPOPN 1
15021: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
15022: LD_EXP 51
15026: PUSH
15027: LD_EXP 29
15031: NOT
15032: AND
15033: PUSH
15034: LD_EXP 30
15038: NOT
15039: AND
15040: IFFALSE 15324
15042: GO 15044
15044: DISABLE
15045: LD_INT 0
15047: PPUSH
15048: PPUSH
15049: PPUSH
// begin enable ;
15050: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15051: LD_ADDR_VAR 0 3
15055: PUSH
15056: LD_INT 81
15058: PUSH
15059: LD_INT 3
15061: PUSH
15062: EMPTY
15063: LIST
15064: LIST
15065: PPUSH
15066: CALL_OW 69
15070: ST_TO_ADDR
// for i = 1 to ru_forest do
15071: LD_ADDR_VAR 0 1
15075: PUSH
15076: DOUBLE
15077: LD_INT 1
15079: DEC
15080: ST_TO_ADDR
15081: LD_EXP 51
15085: PUSH
15086: FOR_TO
15087: IFFALSE 15322
// begin un := ru_forest [ i ] ;
15089: LD_ADDR_VAR 0 2
15093: PUSH
15094: LD_EXP 51
15098: PUSH
15099: LD_VAR 0 1
15103: ARRAY
15104: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15105: LD_VAR 0 2
15109: PPUSH
15110: LD_INT 13
15112: PPUSH
15113: CALL_OW 308
15117: IFFALSE 15207
// begin if not See ( 1 , un ) then
15119: LD_INT 1
15121: PPUSH
15122: LD_VAR 0 2
15126: PPUSH
15127: CALL_OW 292
15131: NOT
15132: IFFALSE 15146
// SetLives ( un , 1000 ) ;
15134: LD_VAR 0 2
15138: PPUSH
15139: LD_INT 1000
15141: PPUSH
15142: CALL_OW 234
// ru_forest := ru_forest diff un ;
15146: LD_ADDR_EXP 51
15150: PUSH
15151: LD_EXP 51
15155: PUSH
15156: LD_VAR 0 2
15160: DIFF
15161: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15162: LD_VAR 0 2
15166: PPUSH
15167: LD_INT 22
15169: PUSH
15170: LD_INT 3
15172: PUSH
15173: EMPTY
15174: LIST
15175: LIST
15176: PUSH
15177: LD_INT 30
15179: PUSH
15180: LD_INT 4
15182: PUSH
15183: EMPTY
15184: LIST
15185: LIST
15186: PUSH
15187: EMPTY
15188: LIST
15189: LIST
15190: PPUSH
15191: CALL_OW 69
15195: PPUSH
15196: CALL 1023 0 1
15200: PPUSH
15201: CALL_OW 120
// continue ;
15205: GO 15086
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15207: LD_VAR 0 2
15211: PPUSH
15212: CALL_OW 256
15216: PUSH
15217: LD_INT 700
15219: LESS
15220: PUSH
15221: LD_VAR 0 2
15225: PPUSH
15226: LD_INT 13
15228: PPUSH
15229: CALL_OW 308
15233: NOT
15234: AND
15235: IFFALSE 15251
// ComMoveToArea ( un , retreatArea ) else
15237: LD_VAR 0 2
15241: PPUSH
15242: LD_INT 13
15244: PPUSH
15245: CALL_OW 113
15249: GO 15320
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15251: LD_VAR 0 2
15255: PPUSH
15256: LD_VAR 0 3
15260: PPUSH
15261: LD_VAR 0 2
15265: PPUSH
15266: CALL_OW 74
15270: PPUSH
15271: CALL_OW 296
15275: PUSH
15276: LD_INT 9
15278: LESS
15279: PUSH
15280: LD_VAR 0 2
15284: PPUSH
15285: CALL_OW 256
15289: PUSH
15290: LD_INT 500
15292: GREATER
15293: AND
15294: IFFALSE 15320
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15296: LD_VAR 0 2
15300: PPUSH
15301: LD_VAR 0 3
15305: PPUSH
15306: LD_VAR 0 2
15310: PPUSH
15311: CALL_OW 74
15315: PPUSH
15316: CALL_OW 115
// end ;
15320: GO 15086
15322: POP
15323: POP
// end ;
15324: PPOPN 3
15326: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
15327: LD_EXP 30
15331: NOT
15332: IFFALSE 15453
15334: GO 15336
15336: DISABLE
15337: LD_INT 0
15339: PPUSH
15340: PPUSH
// begin enable ;
15341: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
15342: LD_ADDR_VAR 0 2
15346: PUSH
15347: LD_INT 22
15349: PUSH
15350: LD_INT 3
15352: PUSH
15353: EMPTY
15354: LIST
15355: LIST
15356: PUSH
15357: LD_INT 21
15359: PUSH
15360: LD_INT 3
15362: PUSH
15363: EMPTY
15364: LIST
15365: LIST
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PPUSH
15371: CALL_OW 69
15375: ST_TO_ADDR
// if filter then
15376: LD_VAR 0 2
15380: IFFALSE 15453
// for i in filter do
15382: LD_ADDR_VAR 0 1
15386: PUSH
15387: LD_VAR 0 2
15391: PUSH
15392: FOR_IN
15393: IFFALSE 15451
// if GetLives ( i ) < 990 then
15395: LD_VAR 0 1
15399: PPUSH
15400: CALL_OW 256
15404: PUSH
15405: LD_INT 990
15407: LESS
15408: IFFALSE 15449
// begin ru_alert := true ;
15410: LD_ADDR_EXP 56
15414: PUSH
15415: LD_INT 1
15417: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
15418: LD_ADDR_EXP 57
15422: PUSH
15423: LD_VAR 0 1
15427: PPUSH
15428: CALL_OW 250
15432: PUSH
15433: LD_VAR 0 1
15437: PPUSH
15438: CALL_OW 251
15442: PUSH
15443: EMPTY
15444: LIST
15445: LIST
15446: ST_TO_ADDR
// break ;
15447: GO 15451
// end ;
15449: GO 15392
15451: POP
15452: POP
// end ;
15453: PPOPN 2
15455: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
15456: LD_EXP 29
15460: IFFALSE 15609
15462: GO 15464
15464: DISABLE
15465: LD_INT 0
15467: PPUSH
15468: PPUSH
15469: PPUSH
15470: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
15471: LD_ADDR_VAR 0 4
15475: PUSH
15476: LD_EXP 52
15480: PUSH
15481: LD_EXP 51
15485: ADD
15486: PUSH
15487: LD_EXP 49
15491: ADD
15492: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
15493: LD_ADDR_VAR 0 3
15497: PUSH
15498: LD_INT 3
15500: PPUSH
15501: LD_INT 81
15503: PUSH
15504: LD_INT 3
15506: PUSH
15507: EMPTY
15508: LIST
15509: LIST
15510: PPUSH
15511: CALL_OW 70
15515: ST_TO_ADDR
// if filter and enemy then
15516: LD_VAR 0 4
15520: PUSH
15521: LD_VAR 0 3
15525: AND
15526: IFFALSE 15609
// repeat wait ( 0 0$01 ) ;
15528: LD_INT 35
15530: PPUSH
15531: CALL_OW 67
// for i in filter do
15535: LD_ADDR_VAR 0 1
15539: PUSH
15540: LD_VAR 0 4
15544: PUSH
15545: FOR_IN
15546: IFFALSE 15574
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15548: LD_VAR 0 1
15552: PPUSH
15553: LD_VAR 0 3
15557: PPUSH
15558: LD_VAR 0 1
15562: PPUSH
15563: CALL_OW 74
15567: PPUSH
15568: CALL_OW 115
// end ;
15572: GO 15545
15574: POP
15575: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
15576: LD_INT 3
15578: PPUSH
15579: LD_INT 81
15581: PUSH
15582: LD_INT 3
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PPUSH
15589: CALL_OW 70
15593: PUSH
15594: LD_INT 0
15596: EQUAL
15597: PUSH
15598: LD_VAR 0 4
15602: PUSH
15603: LD_INT 0
15605: EQUAL
15606: OR
15607: IFFALSE 15528
// end ;
15609: PPOPN 4
15611: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) do var i ;
15612: LD_EXP 25
15616: PUSH
15617: LD_INT 22
15619: PUSH
15620: LD_INT 4
15622: PUSH
15623: EMPTY
15624: LIST
15625: LIST
15626: PUSH
15627: LD_INT 30
15629: PUSH
15630: LD_INT 4
15632: PUSH
15633: EMPTY
15634: LIST
15635: LIST
15636: PUSH
15637: EMPTY
15638: LIST
15639: LIST
15640: PPUSH
15641: CALL_OW 69
15645: AND
15646: IFFALSE 15695
15648: GO 15650
15650: DISABLE
15651: LD_INT 0
15653: PPUSH
// begin if not ru_cornel_attack then
15654: LD_EXP 54
15658: NOT
15659: IFFALSE 15663
// exit ;
15661: GO 15695
// for i in ru_cornel_attack do
15663: LD_ADDR_VAR 0 1
15667: PUSH
15668: LD_EXP 54
15672: PUSH
15673: FOR_IN
15674: IFFALSE 15693
// ComAgressiveMove ( i , 258 , 119 ) ;
15676: LD_VAR 0 1
15680: PPUSH
15681: LD_INT 258
15683: PPUSH
15684: LD_INT 119
15686: PPUSH
15687: CALL_OW 114
15691: GO 15673
15693: POP
15694: POP
// end ; end_of_file
15695: PPOPN 1
15697: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
15698: LD_EXP 5
15702: PUSH
15703: LD_EXP 9
15707: NOT
15708: AND
15709: PUSH
15710: LD_EXP 19
15714: AND
15715: IFFALSE 15827
15717: GO 15719
15719: DISABLE
15720: LD_INT 0
15722: PPUSH
// begin enable ;
15723: ENABLE
// crates_counter := crates_counter - 50 ;
15724: LD_ADDR_EXP 19
15728: PUSH
15729: LD_EXP 19
15733: PUSH
15734: LD_INT 50
15736: MINUS
15737: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
15738: LD_INT 8
15740: PPUSH
15741: LD_INT 2
15743: PPUSH
15744: LD_INT 5
15746: PPUSH
15747: CALL_OW 12
15751: PPUSH
15752: LD_INT 1
15754: PPUSH
15755: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
15759: LD_INT 1785
15761: PPUSH
15762: LD_INT 2345
15764: PPUSH
15765: CALL_OW 12
15769: PPUSH
15770: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
15774: LD_ADDR_VAR 0 1
15778: PUSH
15779: LD_INT 1
15781: PPUSH
15782: LD_OWVAR 67
15786: PUSH
15787: LD_INT 2
15789: PLUS
15790: PPUSH
15791: CALL_OW 12
15795: ST_TO_ADDR
// if r < 3 then
15796: LD_VAR 0 1
15800: PUSH
15801: LD_INT 3
15803: LESS
15804: IFFALSE 15827
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
15806: LD_INT 4
15808: PPUSH
15809: LD_INT 1
15811: PPUSH
15812: LD_INT 5
15814: PPUSH
15815: CALL_OW 12
15819: PPUSH
15820: LD_INT 1
15822: PPUSH
15823: CALL_OW 55
// end ;
15827: PPOPN 1
15829: END
// every 0 0$01 trigger cornel_active do
15830: LD_EXP 8
15834: IFFALSE 15923
15836: GO 15838
15838: DISABLE
// begin Wait ( 0 0$03 ) ;
15839: LD_INT 105
15841: PPUSH
15842: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15846: LD_INT 2
15848: PPUSH
15849: LD_INT 5
15851: PPUSH
15852: CALL_OW 12
15856: PPUSH
15857: LD_INT 10
15859: PPUSH
15860: LD_INT 1
15862: PPUSH
15863: CALL_OW 55
// Wait ( 0 0$13 ) ;
15867: LD_INT 455
15869: PPUSH
15870: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15874: LD_INT 2
15876: PPUSH
15877: LD_INT 5
15879: PPUSH
15880: CALL_OW 12
15884: PPUSH
15885: LD_INT 10
15887: PPUSH
15888: LD_INT 1
15890: PPUSH
15891: CALL_OW 55
// Wait ( 0 0$16 ) ;
15895: LD_INT 560
15897: PPUSH
15898: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15902: LD_INT 2
15904: PPUSH
15905: LD_INT 5
15907: PPUSH
15908: CALL_OW 12
15912: PPUSH
15913: LD_INT 10
15915: PPUSH
15916: LD_INT 1
15918: PPUSH
15919: CALL_OW 55
// end ; end_of_file
15923: END
// every 0 0$01 trigger cornel_prepared do
15924: LD_EXP 11
15928: IFFALSE 15987
15930: GO 15932
15932: DISABLE
// begin enable ;
15933: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
15934: LD_ADDR_OWVAR 47
15938: PUSH
15939: LD_STRING #Am03-1
15941: PUSH
15942: LD_EXP 10
15946: PUSH
15947: EMPTY
15948: LIST
15949: LIST
15950: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
15951: LD_ADDR_EXP 10
15955: PUSH
15956: LD_EXP 10
15960: PPUSH
15961: LD_STRING -
15963: PPUSH
15964: CALL 1093 0 2
15968: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
15969: LD_EXP 10
15973: PUSH
15974: LD_INT 0
15976: EQUAL
15977: IFFALSE 15987
// begin Display_Strings := [ ] ;
15979: LD_ADDR_OWVAR 47
15983: PUSH
15984: EMPTY
15985: ST_TO_ADDR
// disable ;
15986: DISABLE
// end ; end ;
15987: END
// every 0 0$01 trigger debug and debug_strings do
15988: LD_EXP 1
15992: PUSH
15993: LD_OWVAR 48
15997: AND
15998: IFFALSE 16014
16000: GO 16002
16002: DISABLE
// begin enable ;
16003: ENABLE
// Display_Strings := debug_strings ;
16004: LD_ADDR_OWVAR 47
16008: PUSH
16009: LD_OWVAR 48
16013: ST_TO_ADDR
// end ; end_of_file
16014: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
16015: LD_VAR 0 1
16019: PPUSH
16020: CALL_OW 255
16024: PUSH
16025: LD_INT 1
16027: EQUAL
16028: PUSH
16029: LD_EXP 13
16033: NOT
16034: AND
16035: IFFALSE 16045
// solar_builded := true ;
16037: LD_ADDR_EXP 13
16041: PUSH
16042: LD_INT 1
16044: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
16045: LD_VAR 0 1
16049: PPUSH
16050: CALL_OW 255
16054: PUSH
16055: LD_INT 1
16057: EQUAL
16058: PUSH
16059: LD_EXP 27
16063: AND
16064: IFFALSE 16097
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
16066: LD_ADDR_EXP 27
16070: PUSH
16071: LD_EXP 27
16075: PUSH
16076: LD_INT 1750
16078: PUSH
16079: LD_INT 1400
16081: PUSH
16082: LD_INT 1225
16084: PUSH
16085: EMPTY
16086: LIST
16087: LIST
16088: LIST
16089: PUSH
16090: LD_OWVAR 67
16094: ARRAY
16095: PLUS
16096: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
16097: LD_VAR 0 1
16101: PPUSH
16102: CALL_OW 255
16106: PUSH
16107: LD_INT 3
16109: EQUAL
16110: IFFALSE 16128
// ru_vehicles := ru_vehicles ^ veh ;
16112: LD_ADDR_EXP 52
16116: PUSH
16117: LD_EXP 52
16121: PUSH
16122: LD_VAR 0 1
16126: ADD
16127: ST_TO_ADDR
// end ;
16128: PPOPN 2
16130: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
16131: LD_VAR 0 1
16135: PUSH
16136: LD_EXP 49
16140: IN
16141: IFFALSE 16159
// ru_patrol := ru_patrol diff un ;
16143: LD_ADDR_EXP 49
16147: PUSH
16148: LD_EXP 49
16152: PUSH
16153: LD_VAR 0 1
16157: DIFF
16158: ST_TO_ADDR
// if un in ru_forest then
16159: LD_VAR 0 1
16163: PUSH
16164: LD_EXP 51
16168: IN
16169: IFFALSE 16187
// ru_forest := ru_forest diff un ;
16171: LD_ADDR_EXP 51
16175: PUSH
16176: LD_EXP 51
16180: PUSH
16181: LD_VAR 0 1
16185: DIFF
16186: ST_TO_ADDR
// if un in ru_vehicles then
16187: LD_VAR 0 1
16191: PUSH
16192: LD_EXP 52
16196: IN
16197: IFFALSE 16272
// begin ru_vehicles := ru_vehicles diff un ;
16199: LD_ADDR_EXP 52
16203: PUSH
16204: LD_EXP 52
16208: PUSH
16209: LD_VAR 0 1
16213: DIFF
16214: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
16215: LD_ADDR_EXP 53
16219: PUSH
16220: LD_EXP 53
16224: PUSH
16225: LD_VAR 0 1
16229: PPUSH
16230: CALL_OW 265
16234: PUSH
16235: LD_VAR 0 1
16239: PPUSH
16240: CALL_OW 262
16244: PUSH
16245: LD_VAR 0 1
16249: PPUSH
16250: CALL_OW 263
16254: PUSH
16255: LD_VAR 0 1
16259: PPUSH
16260: CALL_OW 264
16264: PUSH
16265: EMPTY
16266: LIST
16267: LIST
16268: LIST
16269: LIST
16270: ADD
16271: ST_TO_ADDR
// end ; if un = JMM then
16272: LD_VAR 0 1
16276: PUSH
16277: LD_EXP 33
16281: EQUAL
16282: IFFALSE 16291
// YouLost ( 0 ) ;
16284: LD_STRING 0
16286: PPUSH
16287: CALL_OW 104
// if un = us_dep_west then
16291: LD_VAR 0 1
16295: PUSH
16296: LD_INT 1
16298: EQUAL
16299: IFFALSE 16308
// YouLost ( 2 ) ;
16301: LD_STRING 2
16303: PPUSH
16304: CALL_OW 104
// if un = Lynch and GetSide ( Lynch ) = 8 then
16308: LD_VAR 0 1
16312: PUSH
16313: LD_EXP 43
16317: EQUAL
16318: PUSH
16319: LD_EXP 43
16323: PPUSH
16324: CALL_OW 255
16328: PUSH
16329: LD_INT 8
16331: EQUAL
16332: AND
16333: IFFALSE 16342
// YouLost ( 4 ) ;
16335: LD_STRING 4
16337: PPUSH
16338: CALL_OW 104
// if un in jmm_units then
16342: LD_VAR 0 1
16346: PUSH
16347: LD_EXP 4
16351: IN
16352: IFFALSE 16368
// lose_counter := lose_counter + 1 ;
16354: LD_ADDR_EXP 32
16358: PUSH
16359: LD_EXP 32
16363: PUSH
16364: LD_INT 1
16366: PLUS
16367: ST_TO_ADDR
// end ;
16368: PPOPN 1
16370: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
16371: LD_INT 0
16373: PPUSH
16374: PPUSH
// begin if GetSide ( driver ) = 3 then
16375: LD_VAR 0 1
16379: PPUSH
16380: CALL_OW 255
16384: PUSH
16385: LD_INT 3
16387: EQUAL
16388: IFFALSE 16466
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
16390: LD_ADDR_VAR 0 6
16394: PUSH
16395: LD_INT 22
16397: PUSH
16398: LD_INT 3
16400: PUSH
16401: EMPTY
16402: LIST
16403: LIST
16404: PUSH
16405: LD_INT 30
16407: PUSH
16408: LD_INT 3
16410: PUSH
16411: EMPTY
16412: LIST
16413: LIST
16414: PUSH
16415: EMPTY
16416: LIST
16417: LIST
16418: PPUSH
16419: CALL_OW 69
16423: PPUSH
16424: CALL 1023 0 1
16428: ST_TO_ADDR
// if place then
16429: LD_VAR 0 6
16433: IFFALSE 16451
// ComEnterUnit ( driver , place ) else
16435: LD_VAR 0 1
16439: PPUSH
16440: LD_VAR 0 6
16444: PPUSH
16445: CALL_OW 120
16449: GO 16466
// ComMoveXY ( driver , 70 , 22 ) ;
16451: LD_VAR 0 1
16455: PPUSH
16456: LD_INT 70
16458: PPUSH
16459: LD_INT 22
16461: PPUSH
16462: CALL_OW 111
// end ; end ;
16466: PPOPN 6
16468: END
// every 0 0$01 trigger not game_end and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) < 4 do
16469: LD_EXP 31
16473: NOT
16474: PUSH
16475: LD_INT 22
16477: PUSH
16478: LD_INT 1
16480: PUSH
16481: EMPTY
16482: LIST
16483: LIST
16484: PUSH
16485: LD_INT 21
16487: PUSH
16488: LD_INT 1
16490: PUSH
16491: EMPTY
16492: LIST
16493: LIST
16494: PUSH
16495: EMPTY
16496: LIST
16497: LIST
16498: PPUSH
16499: CALL_OW 69
16503: PUSH
16504: LD_INT 22
16506: PUSH
16507: LD_INT 8
16509: PUSH
16510: EMPTY
16511: LIST
16512: LIST
16513: PUSH
16514: LD_INT 21
16516: PUSH
16517: LD_INT 1
16519: PUSH
16520: EMPTY
16521: LIST
16522: LIST
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: PPUSH
16528: CALL_OW 69
16532: PLUS
16533: PUSH
16534: LD_INT 4
16536: LESS
16537: AND
16538: IFFALSE 16550
16540: GO 16542
16542: DISABLE
// YouLost ( 1 ) ;
16543: LD_STRING 1
16545: PPUSH
16546: CALL_OW 104
16550: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
16551: LD_INT 1
16553: PPUSH
16554: CALL_OW 255
16558: PUSH
16559: LD_INT 3
16561: EQUAL
16562: IFFALSE 16574
16564: GO 16566
16566: DISABLE
// YouLost ( 3 ) ;
16567: LD_STRING 3
16569: PPUSH
16570: CALL_OW 104
16574: END
