// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 355 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 443 0 0
// PrepareRussian ;
  22: CALL 2972 0 0
// PrepareAmerican ;
  26: CALL 1177 0 0
// PrepareCornell ;
  30: CALL 2201 0 0
// PrepareWesternBase ;
  34: CALL 2427 0 0
// Action ;
  38: CALL 5188 0 0
// end ;
  42: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn , save_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  54: LD_ADDR_EXP 3
  58: PUSH
  59: LD_STRING 02_
  61: ST_TO_ADDR
// mission_prefix := 03_ ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_STRING 03_
  69: ST_TO_ADDR
// jmm_units := 0 ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// cornel_units := 0 ;
  78: LD_ADDR_EXP 6
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// bierezov_exist := false ;
  86: LD_ADDR_EXP 7
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// jmm_on_west := false ;
  94: LD_ADDR_EXP 5
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_active := false ;
 102: LD_ADDR_EXP 8
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_attack := false ;
 110: LD_ADDR_EXP 9
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// cornel_prepared := false ;
 118: LD_ADDR_EXP 11
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 126: LD_ADDR_EXP 10
 130: PUSH
 131: LD_INT 4200
 133: ST_TO_ADDR
// frank_can_return := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// solar_builded := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// frank_send_to_scout := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// jmm_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// bobby_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// cyrus_in_veh := false ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// lisa_in_veh := false ;
 182: LD_ADDR_EXP 18
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 190: LD_ADDR_EXP 27
 194: PUSH
 195: LD_INT 25200
 197: PUSH
 198: LD_INT 23100
 200: PUSH
 201: LD_INT 21000
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: PUSH
 209: LD_OWVAR 67
 213: ARRAY
 214: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 215: LD_ADDR_EXP 19
 219: PUSH
 220: LD_INT 600
 222: PUSH
 223: LD_INT 500
 225: PUSH
 226: LD_INT 400
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: PUSH
 234: LD_OWVAR 67
 238: ARRAY
 239: ST_TO_ADDR
// end_mission_allowed := false ;
 240: LD_ADDR_EXP 20
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// save_others := [ ] ;
 248: LD_ADDR_EXP 21
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// save_group := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// show_query := true ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// wait_for_them := false ;
 270: LD_ADDR_EXP 24
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// veh_on_meta := false ;
 278: LD_ADDR_EXP 26
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_spec_patrol := false ;
 286: LD_ADDR_EXP 28
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// prepare_siege := false ;
 294: LD_ADDR_EXP 29
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// send_attack_on_cornel := false ;
 302: LD_ADDR_EXP 30
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 310: LD_ADDR_EXP 25
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// game_end := false ;
 318: LD_ADDR_EXP 31
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// lose_counter := 0 ;
 326: LD_ADDR_EXP 32
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// powell_warn := 0 ;
 334: LD_ADDR_EXP 33
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// save_counter := 0 ;
 342: LD_ADDR_EXP 34
 346: PUSH
 347: LD_INT 0
 349: ST_TO_ADDR
// end ;
 350: LD_VAR 0 1
 354: RET
// function SetDiplomacy ; begin
 355: LD_INT 0
 357: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 358: LD_INT 1
 360: PPUSH
 361: LD_INT 4
 363: PPUSH
 364: LD_INT 1
 366: PPUSH
 367: LD_INT 1
 369: PPUSH
 370: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 374: LD_INT 1
 376: PPUSH
 377: LD_INT 8
 379: PPUSH
 380: LD_INT 1
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 390: LD_INT 3
 392: PPUSH
 393: LD_INT 6
 395: PPUSH
 396: LD_INT 1
 398: PPUSH
 399: LD_INT 1
 401: PPUSH
 402: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 406: LD_INT 4
 408: PPUSH
 409: LD_INT 6
 411: PPUSH
 412: LD_INT 0
 414: PPUSH
 415: LD_INT 1
 417: PPUSH
 418: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 422: LD_INT 3
 424: PPUSH
 425: LD_INT 8
 427: PPUSH
 428: LD_INT 0
 430: PPUSH
 431: LD_INT 1
 433: PPUSH
 434: CALL_OW 80
// end ;
 438: LD_VAR 0 1
 442: RET
// export function DebugMode ; var i ; begin
 443: LD_INT 0
 445: PPUSH
 446: PPUSH
// FogOff ( 1 ) ;
 447: LD_INT 1
 449: PPUSH
 450: CALL_OW 344
// debug_strings := [ ] ;
 454: LD_ADDR_OWVAR 48
 458: PUSH
 459: EMPTY
 460: ST_TO_ADDR
// end ; end_of_file
 461: LD_VAR 0 1
 465: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 466: LD_INT 0
 468: PPUSH
 469: PPUSH
// if exist_mode then
 470: LD_VAR 0 2
 474: IFFALSE 499
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 476: LD_ADDR_VAR 0 4
 480: PUSH
 481: LD_EXP 3
 485: PUSH
 486: LD_VAR 0 1
 490: STR
 491: PPUSH
 492: CALL_OW 34
 496: ST_TO_ADDR
 497: GO 514
// unit := NewCharacter ( ident ) ;
 499: LD_ADDR_VAR 0 4
 503: PUSH
 504: LD_VAR 0 1
 508: PPUSH
 509: CALL_OW 25
 513: ST_TO_ADDR
// result := unit ;
 514: LD_ADDR_VAR 0 3
 518: PUSH
 519: LD_VAR 0 4
 523: ST_TO_ADDR
// end ;
 524: LD_VAR 0 3
 528: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 529: LD_INT 0
 531: PPUSH
// uc_side := side ;
 532: LD_ADDR_OWVAR 20
 536: PUSH
 537: LD_VAR 0 1
 541: ST_TO_ADDR
// uc_nation := nation ;
 542: LD_ADDR_OWVAR 21
 546: PUSH
 547: LD_VAR 0 2
 551: ST_TO_ADDR
// vc_chassis := chassis ;
 552: LD_ADDR_OWVAR 37
 556: PUSH
 557: LD_VAR 0 3
 561: ST_TO_ADDR
// vc_engine := engine ;
 562: LD_ADDR_OWVAR 39
 566: PUSH
 567: LD_VAR 0 4
 571: ST_TO_ADDR
// vc_control := control ;
 572: LD_ADDR_OWVAR 38
 576: PUSH
 577: LD_VAR 0 5
 581: ST_TO_ADDR
// vc_weapon := weapon ;
 582: LD_ADDR_OWVAR 40
 586: PUSH
 587: LD_VAR 0 6
 591: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 592: LD_ADDR_OWVAR 41
 596: PUSH
 597: LD_VAR 0 7
 601: ST_TO_ADDR
// result := CreateVehicle ;
 602: LD_ADDR_VAR 0 8
 606: PUSH
 607: CALL_OW 45
 611: ST_TO_ADDR
// end ;
 612: LD_VAR 0 8
 616: RET
// export function SayX ( units , ident ) ; var i ; begin
 617: LD_INT 0
 619: PPUSH
 620: PPUSH
// result := false ;
 621: LD_ADDR_VAR 0 3
 625: PUSH
 626: LD_INT 0
 628: ST_TO_ADDR
// if not units then
 629: LD_VAR 0 1
 633: NOT
 634: IFFALSE 638
// exit ;
 636: GO 692
// for i in units do
 638: LD_ADDR_VAR 0 4
 642: PUSH
 643: LD_VAR 0 1
 647: PUSH
 648: FOR_IN
 649: IFFALSE 690
// if IsOk ( i ) then
 651: LD_VAR 0 4
 655: PPUSH
 656: CALL_OW 302
 660: IFFALSE 688
// begin Say ( i , ident ) ;
 662: LD_VAR 0 4
 666: PPUSH
 667: LD_VAR 0 2
 671: PPUSH
 672: CALL_OW 88
// result := i ;
 676: LD_ADDR_VAR 0 3
 680: PUSH
 681: LD_VAR 0 4
 685: ST_TO_ADDR
// break ;
 686: GO 690
// end ;
 688: GO 648
 690: POP
 691: POP
// end ;
 692: LD_VAR 0 3
 696: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 697: LD_INT 0
 699: PPUSH
 700: PPUSH
 701: PPUSH
 702: PPUSH
// for i = 1 to count do
 703: LD_ADDR_VAR 0 8
 707: PUSH
 708: DOUBLE
 709: LD_INT 1
 711: DEC
 712: ST_TO_ADDR
 713: LD_VAR 0 6
 717: PUSH
 718: FOR_TO
 719: IFFALSE 800
// begin uc_side = side ;
 721: LD_ADDR_OWVAR 20
 725: PUSH
 726: LD_VAR 0 1
 730: ST_TO_ADDR
// uc_nation = nation ;
 731: LD_ADDR_OWVAR 21
 735: PUSH
 736: LD_VAR 0 2
 740: ST_TO_ADDR
// hc_gallery =  ;
 741: LD_ADDR_OWVAR 33
 745: PUSH
 746: LD_STRING 
 748: ST_TO_ADDR
// hc_name =  ;
 749: LD_ADDR_OWVAR 26
 753: PUSH
 754: LD_STRING 
 756: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 757: LD_INT 0
 759: PPUSH
 760: LD_VAR 0 5
 764: PPUSH
 765: LD_VAR 0 4
 769: PPUSH
 770: CALL_OW 380
// un = CreateHuman ;
 774: LD_ADDR_VAR 0 10
 778: PUSH
 779: CALL_OW 44
 783: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 784: LD_VAR 0 10
 788: PPUSH
 789: LD_VAR 0 3
 793: PPUSH
 794: CALL_OW 52
// end ;
 798: GO 718
 800: POP
 801: POP
// end ;
 802: LD_VAR 0 7
 806: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 807: LD_INT 0
 809: PPUSH
 810: PPUSH
 811: PPUSH
// uc_side := GetSide ( b ) ;
 812: LD_ADDR_OWVAR 20
 816: PUSH
 817: LD_VAR 0 2
 821: PPUSH
 822: CALL_OW 255
 826: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 827: LD_ADDR_OWVAR 21
 831: PUSH
 832: LD_VAR 0 2
 836: PPUSH
 837: CALL_OW 248
 841: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 842: LD_INT 0
 844: PPUSH
 845: LD_INT 1
 847: PPUSH
 848: LD_VAR 0 1
 852: PPUSH
 853: CALL_OW 380
// un = CreateHuman ;
 857: LD_ADDR_VAR 0 4
 861: PUSH
 862: CALL_OW 44
 866: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 867: LD_ADDR_VAR 0 5
 871: PUSH
 872: LD_VAR 0 2
 876: PPUSH
 877: CALL_OW 254
 881: PUSH
 882: LD_INT 3
 884: MINUS
 885: ST_TO_ADDR
// if dir < 0 then
 886: LD_VAR 0 5
 890: PUSH
 891: LD_INT 0
 893: LESS
 894: IFFALSE 910
// dir := 6 + dir ;
 896: LD_ADDR_VAR 0 5
 900: PUSH
 901: LD_INT 6
 903: PUSH
 904: LD_VAR 0 5
 908: PLUS
 909: ST_TO_ADDR
// SetDir ( un , dir ) ;
 910: LD_VAR 0 4
 914: PPUSH
 915: LD_VAR 0 5
 919: PPUSH
 920: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 924: LD_VAR 0 4
 928: PPUSH
 929: LD_VAR 0 2
 933: PPUSH
 934: CALL_OW 52
// end ;
 938: LD_VAR 0 3
 942: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 943: LD_INT 0
 945: PPUSH
 946: PPUSH
 947: PPUSH
// result := false ;
 948: LD_ADDR_VAR 0 2
 952: PUSH
 953: LD_INT 0
 955: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 956: LD_ADDR_VAR 0 3
 960: PUSH
 961: LD_INT 22
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: PUSH
 971: LD_INT 34
 973: PUSH
 974: LD_INT 2
 976: PUSH
 977: EMPTY
 978: LIST
 979: LIST
 980: PUSH
 981: EMPTY
 982: LIST
 983: LIST
 984: PPUSH
 985: CALL_OW 69
 989: ST_TO_ADDR
// for i in filter do
 990: LD_ADDR_VAR 0 4
 994: PUSH
 995: LD_VAR 0 3
 999: PUSH
1000: FOR_IN
1001: IFFALSE 1032
// if IsDrivenBy ( i ) = unit then
1003: LD_VAR 0 4
1007: PPUSH
1008: CALL_OW 311
1012: PUSH
1013: LD_VAR 0 1
1017: EQUAL
1018: IFFALSE 1030
// begin result := true ;
1020: LD_ADDR_VAR 0 2
1024: PUSH
1025: LD_INT 1
1027: ST_TO_ADDR
// break ;
1028: GO 1032
// end ;
1030: GO 1000
1032: POP
1033: POP
// end ;
1034: LD_VAR 0 2
1038: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1039: LD_INT 0
1041: PPUSH
1042: PPUSH
// result := false ;
1043: LD_ADDR_VAR 0 2
1047: PUSH
1048: LD_INT 0
1050: ST_TO_ADDR
// if not blist then
1051: LD_VAR 0 1
1055: NOT
1056: IFFALSE 1060
// exit ;
1058: GO 1104
// for i in blist do
1060: LD_ADDR_VAR 0 3
1064: PUSH
1065: LD_VAR 0 1
1069: PUSH
1070: FOR_IN
1071: IFFALSE 1102
// if UnitsInside ( i ) < 6 then
1073: LD_VAR 0 3
1077: PPUSH
1078: CALL_OW 313
1082: PUSH
1083: LD_INT 6
1085: LESS
1086: IFFALSE 1100
// begin result := i ;
1088: LD_ADDR_VAR 0 2
1092: PUSH
1093: LD_VAR 0 3
1097: ST_TO_ADDR
// break ;
1098: GO 1102
// end ;
1100: GO 1070
1102: POP
1103: POP
// end ;
1104: LD_VAR 0 2
1108: RET
// export function Count ( timer , mode ) ; begin
1109: LD_INT 0
1111: PPUSH
// if not timer then
1112: LD_VAR 0 1
1116: NOT
1117: IFFALSE 1121
// exit ;
1119: GO 1172
// if mode in [ asc , up , + ] then
1121: LD_VAR 0 2
1125: PUSH
1126: LD_STRING asc
1128: PUSH
1129: LD_STRING up
1131: PUSH
1132: LD_STRING +
1134: PUSH
1135: EMPTY
1136: LIST
1137: LIST
1138: LIST
1139: IN
1140: IFFALSE 1158
// result := timer + 0 0$01 else
1142: LD_ADDR_VAR 0 3
1146: PUSH
1147: LD_VAR 0 1
1151: PUSH
1152: LD_INT 35
1154: PLUS
1155: ST_TO_ADDR
1156: GO 1172
// result := timer - 0 0$01 ;
1158: LD_ADDR_VAR 0 3
1162: PUSH
1163: LD_VAR 0 1
1167: PUSH
1168: LD_INT 35
1170: MINUS
1171: ST_TO_ADDR
// end ; end_of_file
1172: LD_VAR 0 3
1176: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1177: LD_INT 0
1179: PPUSH
1180: PPUSH
1181: PPUSH
1182: PPUSH
1183: PPUSH
1184: PPUSH
1185: PPUSH
1186: PPUSH
// uc_side := 4 ;
1187: LD_ADDR_OWVAR 20
1191: PUSH
1192: LD_INT 4
1194: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1195: LD_ADDR_EXP 44
1199: PUSH
1200: LD_STRING Powell
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL 466 0 2
1210: ST_TO_ADDR
// uc_side := 1 ;
1211: LD_ADDR_OWVAR 20
1215: PUSH
1216: LD_INT 1
1218: ST_TO_ADDR
// uc_nation := 1 ;
1219: LD_ADDR_OWVAR 21
1223: PUSH
1224: LD_INT 1
1226: ST_TO_ADDR
// if debug then
1227: LD_EXP 1
1231: IFFALSE 1361
// begin for i = 1 to 4 do
1233: LD_ADDR_VAR 0 2
1237: PUSH
1238: DOUBLE
1239: LD_INT 1
1241: DEC
1242: ST_TO_ADDR
1243: LD_INT 4
1245: PUSH
1246: FOR_TO
1247: IFFALSE 1298
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1249: LD_INT 0
1251: PPUSH
1252: LD_INT 1
1254: PPUSH
1255: LD_INT 2
1257: PPUSH
1258: CALL_OW 12
1262: PPUSH
1263: LD_INT 3
1265: PPUSH
1266: CALL_OW 380
// un := CreateHuman ;
1270: LD_ADDR_VAR 0 3
1274: PUSH
1275: CALL_OW 44
1279: ST_TO_ADDR
// others := others ^ un ;
1280: LD_ADDR_VAR 0 5
1284: PUSH
1285: LD_VAR 0 5
1289: PUSH
1290: LD_VAR 0 3
1294: ADD
1295: ST_TO_ADDR
// end ;
1296: GO 1246
1298: POP
1299: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1300: LD_ADDR_VAR 0 6
1304: PUSH
1305: LD_INT 21
1307: PUSH
1308: LD_INT 1
1310: PUSH
1311: LD_INT 1
1313: PUSH
1314: LD_INT 51
1316: PUSH
1317: LD_INT 90
1319: PUSH
1320: LD_INT 504
1322: PUSH
1323: EMPTY
1324: LIST
1325: LIST
1326: LIST
1327: LIST
1328: LIST
1329: LIST
1330: PUSH
1331: LD_INT 21
1333: PUSH
1334: LD_INT 1
1336: PUSH
1337: LD_INT 1
1339: PUSH
1340: LD_INT 51
1342: PUSH
1343: LD_INT 80
1345: PUSH
1346: LD_INT 750
1348: PUSH
1349: EMPTY
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: LIST
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1361: LD_ADDR_EXP 35
1365: PUSH
1366: LD_STRING JMM
1368: PPUSH
1369: LD_EXP 1
1373: NOT
1374: PPUSH
1375: CALL 466 0 2
1379: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1380: LD_ADDR_EXP 36
1384: PUSH
1385: LD_STRING Bobby
1387: PPUSH
1388: LD_EXP 1
1392: NOT
1393: PPUSH
1394: CALL 466 0 2
1398: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1399: LD_ADDR_EXP 37
1403: PUSH
1404: LD_STRING Cyrus
1406: PPUSH
1407: LD_EXP 1
1411: NOT
1412: PPUSH
1413: CALL 466 0 2
1417: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1418: LD_ADDR_EXP 38
1422: PUSH
1423: LD_STRING Lisa
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: CALL 466 0 2
1436: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1437: LD_ADDR_EXP 39
1441: PUSH
1442: LD_STRING Khatam
1444: PPUSH
1445: LD_EXP 1
1449: NOT
1450: PPUSH
1451: CALL 466 0 2
1455: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1456: LD_ADDR_EXP 40
1460: PUSH
1461: LD_STRING Brian
1463: PPUSH
1464: LD_EXP 1
1468: NOT
1469: PPUSH
1470: CALL 466 0 2
1474: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1475: LD_ADDR_EXP 41
1479: PUSH
1480: LD_STRING Jerry
1482: PPUSH
1483: LD_EXP 1
1487: NOT
1488: PPUSH
1489: CALL 466 0 2
1493: ST_TO_ADDR
// if Bobby then
1494: LD_EXP 36
1498: IFFALSE 1529
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1500: LD_ADDR_VAR 0 4
1504: PUSH
1505: LD_VAR 0 4
1509: PPUSH
1510: LD_VAR 0 4
1514: PUSH
1515: LD_INT 1
1517: PLUS
1518: PPUSH
1519: LD_EXP 36
1523: PPUSH
1524: CALL_OW 2
1528: ST_TO_ADDR
// if Cyrus then
1529: LD_EXP 37
1533: IFFALSE 1564
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1535: LD_ADDR_VAR 0 4
1539: PUSH
1540: LD_VAR 0 4
1544: PPUSH
1545: LD_VAR 0 4
1549: PUSH
1550: LD_INT 1
1552: PLUS
1553: PPUSH
1554: LD_EXP 37
1558: PPUSH
1559: CALL_OW 2
1563: ST_TO_ADDR
// if Lisa then
1564: LD_EXP 38
1568: IFFALSE 1599
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1570: LD_ADDR_VAR 0 4
1574: PUSH
1575: LD_VAR 0 4
1579: PPUSH
1580: LD_VAR 0 4
1584: PUSH
1585: LD_INT 1
1587: PLUS
1588: PPUSH
1589: LD_EXP 38
1593: PPUSH
1594: CALL_OW 2
1598: ST_TO_ADDR
// if Khatam then
1599: LD_EXP 39
1603: IFFALSE 1634
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1605: LD_ADDR_VAR 0 4
1609: PUSH
1610: LD_VAR 0 4
1614: PPUSH
1615: LD_VAR 0 4
1619: PUSH
1620: LD_INT 1
1622: PLUS
1623: PPUSH
1624: LD_EXP 39
1628: PPUSH
1629: CALL_OW 2
1633: ST_TO_ADDR
// if Brian then
1634: LD_EXP 40
1638: IFFALSE 1669
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1640: LD_ADDR_VAR 0 4
1644: PUSH
1645: LD_VAR 0 4
1649: PPUSH
1650: LD_VAR 0 4
1654: PUSH
1655: LD_INT 1
1657: PLUS
1658: PPUSH
1659: LD_EXP 40
1663: PPUSH
1664: CALL_OW 2
1668: ST_TO_ADDR
// if Jerry then
1669: LD_EXP 41
1673: IFFALSE 1704
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1675: LD_ADDR_VAR 0 4
1679: PUSH
1680: LD_VAR 0 4
1684: PPUSH
1685: LD_VAR 0 4
1689: PUSH
1690: LD_INT 1
1692: PLUS
1693: PPUSH
1694: LD_EXP 41
1698: PPUSH
1699: CALL_OW 2
1703: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1704: LD_STRING 02_other_survivors
1706: PPUSH
1707: CALL_OW 28
1711: IFFALSE 1726
// others := CreateCharacterSet ( 02_other_survivors ) ;
1713: LD_ADDR_VAR 0 5
1717: PUSH
1718: LD_STRING 02_other_survivors
1720: PPUSH
1721: CALL_OW 31
1725: ST_TO_ADDR
// if others then
1726: LD_VAR 0 5
1730: IFFALSE 1755
// begin tmp := tmp ^ others ;
1732: LD_ADDR_VAR 0 4
1736: PUSH
1737: LD_VAR 0 4
1741: PUSH
1742: LD_VAR 0 5
1746: ADD
1747: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1748: LD_STRING 02_other_survivors
1750: PPUSH
1751: CALL_OW 40
// end ; jmm_units := tmp ;
1755: LD_ADDR_EXP 4
1759: PUSH
1760: LD_VAR 0 4
1764: ST_TO_ADDR
// if not vehicles then
1765: LD_VAR 0 6
1769: NOT
1770: IFFALSE 1788
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1772: LD_ADDR_VAR 0 6
1776: PUSH
1777: LD_STRING 02_tanks_1
1779: PPUSH
1780: LD_INT 0
1782: PPUSH
1783: CALL_OW 30
1787: ST_TO_ADDR
// if vehicles then
1788: LD_VAR 0 6
1792: IFFALSE 1986
// begin got_mech := false ;
1794: LD_ADDR_VAR 0 7
1798: PUSH
1799: LD_INT 0
1801: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1802: LD_VAR 0 4
1806: PPUSH
1807: LD_INT 25
1809: PUSH
1810: LD_INT 3
1812: PUSH
1813: EMPTY
1814: LIST
1815: LIST
1816: PPUSH
1817: CALL_OW 72
1821: IFFALSE 1831
// got_mech := true ;
1823: LD_ADDR_VAR 0 7
1827: PUSH
1828: LD_INT 1
1830: ST_TO_ADDR
// for i = 1 to vehicles do
1831: LD_ADDR_VAR 0 2
1835: PUSH
1836: DOUBLE
1837: LD_INT 1
1839: DEC
1840: ST_TO_ADDR
1841: LD_VAR 0 6
1845: PUSH
1846: FOR_TO
1847: IFFALSE 1984
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1849: LD_ADDR_VAR 0 3
1853: PUSH
1854: LD_INT 1
1856: PPUSH
1857: LD_INT 3
1859: PPUSH
1860: LD_VAR 0 6
1864: PUSH
1865: LD_VAR 0 2
1869: ARRAY
1870: PUSH
1871: LD_INT 1
1873: ARRAY
1874: PPUSH
1875: LD_VAR 0 6
1879: PUSH
1880: LD_VAR 0 2
1884: ARRAY
1885: PUSH
1886: LD_INT 2
1888: ARRAY
1889: PPUSH
1890: LD_VAR 0 6
1894: PUSH
1895: LD_VAR 0 2
1899: ARRAY
1900: PUSH
1901: LD_INT 3
1903: ARRAY
1904: PPUSH
1905: LD_VAR 0 6
1909: PUSH
1910: LD_VAR 0 2
1914: ARRAY
1915: PUSH
1916: LD_INT 4
1918: ARRAY
1919: PPUSH
1920: LD_INT 40
1922: PPUSH
1923: CALL 529 0 7
1927: ST_TO_ADDR
// if not got_mech then
1928: LD_VAR 0 7
1932: NOT
1933: IFFALSE 1959
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1935: LD_VAR 0 3
1939: PPUSH
1940: LD_VAR 0 6
1944: PUSH
1945: LD_VAR 0 2
1949: ARRAY
1950: PUSH
1951: LD_INT 6
1953: ARRAY
1954: PPUSH
1955: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1959: LD_ADDR_VAR 0 4
1963: PUSH
1964: LD_VAR 0 4
1968: PPUSH
1969: LD_INT 1
1971: PPUSH
1972: LD_VAR 0 3
1976: PPUSH
1977: CALL_OW 2
1981: ST_TO_ADDR
// end ;
1982: GO 1846
1984: POP
1985: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1986: LD_EXP 35
1990: PPUSH
1991: LD_INT 194
1993: PPUSH
1994: LD_INT 119
1996: PPUSH
1997: LD_INT 0
1999: PPUSH
2000: CALL_OW 48
// if tmp then
2004: LD_VAR 0 4
2008: IFFALSE 2133
// begin for i in tmp do
2010: LD_ADDR_VAR 0 2
2014: PUSH
2015: LD_VAR 0 4
2019: PUSH
2020: FOR_IN
2021: IFFALSE 2131
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2023: LD_ADDR_VAR 0 8
2027: PUSH
2028: LD_INT 22
2030: PUSH
2031: LD_INT 1
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PUSH
2038: LD_INT 21
2040: PUSH
2041: LD_INT 2
2043: PUSH
2044: EMPTY
2045: LIST
2046: LIST
2047: PUSH
2048: LD_INT 58
2050: PUSH
2051: EMPTY
2052: LIST
2053: PUSH
2054: EMPTY
2055: LIST
2056: LIST
2057: LIST
2058: PPUSH
2059: CALL_OW 69
2063: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2064: LD_VAR 0 2
2068: PPUSH
2069: CALL_OW 247
2073: PUSH
2074: LD_INT 1
2076: EQUAL
2077: PUSH
2078: LD_VAR 0 8
2082: AND
2083: IFFALSE 2105
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2085: LD_VAR 0 2
2089: PPUSH
2090: LD_VAR 0 8
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PPUSH
2099: CALL_OW 52
2103: GO 2120
// PlaceUnitArea ( i , startArea , false ) ;
2105: LD_VAR 0 2
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_INT 0
2115: PPUSH
2116: CALL_OW 49
// ComHold ( i ) ;
2120: LD_VAR 0 2
2124: PPUSH
2125: CALL_OW 140
// end ;
2129: GO 2020
2131: POP
2132: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2133: LD_ADDR_EXP 7
2137: PUSH
2138: LD_STRING 02_mikhailStatus_1
2140: PPUSH
2141: LD_INT 0
2143: PPUSH
2144: CALL_OW 30
2148: ST_TO_ADDR
// if not bierezov_exist and not debug then
2149: LD_EXP 7
2153: NOT
2154: PUSH
2155: LD_EXP 1
2159: NOT
2160: AND
2161: IFFALSE 2165
// exit ;
2163: GO 2196
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2165: LD_ADDR_EXP 43
2169: PUSH
2170: LD_STRING Mikhail
2172: PPUSH
2173: LD_INT 0
2175: PPUSH
2176: CALL 466 0 2
2180: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2181: LD_EXP 43
2185: PPUSH
2186: LD_INT 1
2188: PPUSH
2189: LD_INT 0
2191: PPUSH
2192: CALL_OW 49
// end ;
2196: LD_VAR 0 1
2200: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2201: LD_INT 0
2203: PPUSH
2204: PPUSH
2205: PPUSH
2206: PPUSH
// uc_side := 4 ;
2207: LD_ADDR_OWVAR 20
2211: PUSH
2212: LD_INT 4
2214: ST_TO_ADDR
// uc_nation := 1 ;
2215: LD_ADDR_OWVAR 21
2219: PUSH
2220: LD_INT 1
2222: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2223: LD_ADDR_EXP 42
2227: PUSH
2228: LD_STRING Cornell
2230: PPUSH
2231: LD_INT 0
2233: PPUSH
2234: CALL 466 0 2
2238: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2239: LD_ADDR_EXP 6
2243: PUSH
2244: LD_INT 9
2246: PUSH
2247: LD_EXP 4
2251: MINUS
2252: ST_TO_ADDR
// tmp := [ ] ;
2253: LD_ADDR_VAR 0 2
2257: PUSH
2258: EMPTY
2259: ST_TO_ADDR
// if cornel_units < 4 then
2260: LD_EXP 6
2264: PUSH
2265: LD_INT 4
2267: LESS
2268: IFFALSE 2278
// cornel_units := 4 ;
2270: LD_ADDR_EXP 6
2274: PUSH
2275: LD_INT 4
2277: ST_TO_ADDR
// for i = 1 to cornel_units do
2278: LD_ADDR_VAR 0 4
2282: PUSH
2283: DOUBLE
2284: LD_INT 1
2286: DEC
2287: ST_TO_ADDR
2288: LD_EXP 6
2292: PUSH
2293: FOR_TO
2294: IFFALSE 2392
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2296: LD_INT 0
2298: PPUSH
2299: LD_INT 1
2301: PUSH
2302: LD_INT 1
2304: PUSH
2305: LD_INT 1
2307: PUSH
2308: LD_INT 2
2310: PUSH
2311: LD_INT 4
2313: PUSH
2314: EMPTY
2315: LIST
2316: LIST
2317: LIST
2318: LIST
2319: LIST
2320: PUSH
2321: LD_VAR 0 4
2325: PUSH
2326: LD_INT 5
2328: MOD
2329: PUSH
2330: LD_INT 1
2332: PLUS
2333: ARRAY
2334: PPUSH
2335: LD_INT 2
2337: PPUSH
2338: CALL_OW 380
// un := CreateHuman ;
2342: LD_ADDR_VAR 0 3
2346: PUSH
2347: CALL_OW 44
2351: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2352: LD_ADDR_VAR 0 2
2356: PUSH
2357: LD_VAR 0 2
2361: PPUSH
2362: LD_INT 1
2364: PPUSH
2365: LD_VAR 0 3
2369: PPUSH
2370: CALL_OW 2
2374: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2375: LD_VAR 0 3
2379: PPUSH
2380: LD_INT 2
2382: PPUSH
2383: LD_INT 0
2385: PPUSH
2386: CALL_OW 49
// end ;
2390: GO 2293
2392: POP
2393: POP
// cornel_units := tmp ;
2394: LD_ADDR_EXP 6
2398: PUSH
2399: LD_VAR 0 2
2403: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2404: LD_EXP 42
2408: PPUSH
2409: LD_INT 191
2411: PPUSH
2412: LD_INT 106
2414: PPUSH
2415: LD_INT 0
2417: PPUSH
2418: CALL_OW 48
// end ;
2422: LD_VAR 0 1
2426: RET
// export function PrepareWesternBase ; var i ; begin
2427: LD_INT 0
2429: PPUSH
2430: PPUSH
// uc_side := 8 ;
2431: LD_ADDR_OWVAR 20
2435: PUSH
2436: LD_INT 8
2438: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2439: LD_ADDR_EXP 45
2443: PUSH
2444: LD_STRING Lynch
2446: PPUSH
2447: LD_INT 0
2449: PPUSH
2450: CALL 466 0 2
2454: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2455: LD_ADDR_EXP 46
2459: PUSH
2460: LD_STRING Walker
2462: PPUSH
2463: LD_INT 0
2465: PPUSH
2466: CALL 466 0 2
2470: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2471: LD_ADDR_EXP 47
2475: PUSH
2476: LD_STRING Turner
2478: PPUSH
2479: LD_INT 0
2481: PPUSH
2482: CALL 466 0 2
2486: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2487: LD_ADDR_EXP 48
2491: PUSH
2492: LD_STRING Jillian
2494: PPUSH
2495: LD_INT 0
2497: PPUSH
2498: CALL 466 0 2
2502: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2503: LD_ADDR_VAR 0 2
2507: PUSH
2508: LD_EXP 45
2512: PUSH
2513: LD_EXP 46
2517: PUSH
2518: LD_EXP 47
2522: PUSH
2523: LD_EXP 48
2527: PUSH
2528: EMPTY
2529: LIST
2530: LIST
2531: LIST
2532: LIST
2533: PUSH
2534: FOR_IN
2535: IFFALSE 2563
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2537: LD_VAR 0 2
2541: PPUSH
2542: LD_INT 3
2544: PPUSH
2545: LD_INT 0
2547: PPUSH
2548: CALL_OW 49
// ComHold ( i ) ;
2552: LD_VAR 0 2
2556: PPUSH
2557: CALL_OW 140
// end ;
2561: GO 2534
2563: POP
2564: POP
// end ;
2565: LD_VAR 0 1
2569: RET
// export function SelectGroup ; var units , selected , i ; begin
2570: LD_INT 0
2572: PPUSH
2573: PPUSH
2574: PPUSH
2575: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2576: LD_ADDR_VAR 0 2
2580: PUSH
2581: LD_EXP 35
2585: PUSH
2586: LD_INT -3
2588: PUSH
2589: EMPTY
2590: LIST
2591: LIST
2592: PUSH
2593: LD_EXP 4
2597: ADD
2598: PUSH
2599: LD_INT -2
2601: PUSH
2602: LD_INT -4
2604: PUSH
2605: LD_EXP 42
2609: PUSH
2610: LD_EXP 43
2614: PUSH
2615: EMPTY
2616: LIST
2617: LIST
2618: LIST
2619: LIST
2620: ADD
2621: PUSH
2622: LD_INT -3
2624: PUSH
2625: EMPTY
2626: LIST
2627: ADD
2628: PUSH
2629: LD_EXP 6
2633: ADD
2634: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2635: LD_ADDR_VAR 0 3
2639: PUSH
2640: LD_EXP 35
2644: PUSH
2645: LD_STRING Select five characters to go with you
2647: PPUSH
2648: LD_INT 4
2650: PPUSH
2651: LD_INT 4
2653: PPUSH
2654: LD_VAR 0 2
2658: PPUSH
2659: EMPTY
2660: PPUSH
2661: CALL_OW 42
2665: ADD
2666: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2667: LD_ADDR_EXP 6
2671: PUSH
2672: LD_EXP 4
2676: PUSH
2677: LD_EXP 6
2681: UNION
2682: PUSH
2683: LD_VAR 0 3
2687: DIFF
2688: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2689: LD_ADDR_VAR 0 4
2693: PUSH
2694: LD_EXP 6
2698: PUSH
2699: LD_EXP 43
2703: ADD
2704: PUSH
2705: FOR_IN
2706: IFFALSE 2737
// if GetSide ( i ) = 1 then
2708: LD_VAR 0 4
2712: PPUSH
2713: CALL_OW 255
2717: PUSH
2718: LD_INT 1
2720: EQUAL
2721: IFFALSE 2735
// SetSide ( i , 4 ) ;
2723: LD_VAR 0 4
2727: PPUSH
2728: LD_INT 4
2730: PPUSH
2731: CALL_OW 235
2735: GO 2705
2737: POP
2738: POP
// for i in selected do
2739: LD_ADDR_VAR 0 4
2743: PUSH
2744: LD_VAR 0 3
2748: PUSH
2749: FOR_IN
2750: IFFALSE 2781
// if GetSide ( i ) = 4 then
2752: LD_VAR 0 4
2756: PPUSH
2757: CALL_OW 255
2761: PUSH
2762: LD_INT 4
2764: EQUAL
2765: IFFALSE 2779
// SetSide ( i , 1 ) ;
2767: LD_VAR 0 4
2771: PPUSH
2772: LD_INT 1
2774: PPUSH
2775: CALL_OW 235
2779: GO 2749
2781: POP
2782: POP
// jmm_units := jmm_units diff cornel_units ;
2783: LD_ADDR_EXP 4
2787: PUSH
2788: LD_EXP 4
2792: PUSH
2793: LD_EXP 6
2797: DIFF
2798: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2799: LD_EXP 36
2803: PPUSH
2804: CALL_OW 255
2808: PUSH
2809: LD_INT 4
2811: EQUAL
2812: IFFALSE 2827
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2814: LD_EXP 3
2818: PUSH
2819: LD_STRING Bobby
2821: STR
2822: PPUSH
2823: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2827: LD_EXP 37
2831: PPUSH
2832: CALL_OW 255
2836: PUSH
2837: LD_INT 4
2839: EQUAL
2840: IFFALSE 2855
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2842: LD_EXP 3
2846: PUSH
2847: LD_STRING Cyrus
2849: STR
2850: PPUSH
2851: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2855: LD_EXP 38
2859: PPUSH
2860: CALL_OW 255
2864: PUSH
2865: LD_INT 4
2867: EQUAL
2868: IFFALSE 2883
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2870: LD_EXP 3
2874: PUSH
2875: LD_STRING Lisa
2877: STR
2878: PPUSH
2879: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2883: LD_EXP 39
2887: PPUSH
2888: CALL_OW 255
2892: PUSH
2893: LD_INT 4
2895: EQUAL
2896: IFFALSE 2911
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
2898: LD_EXP 3
2902: PUSH
2903: LD_STRING Khatam
2905: STR
2906: PPUSH
2907: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2911: LD_EXP 40
2915: PPUSH
2916: CALL_OW 255
2920: PUSH
2921: LD_INT 4
2923: EQUAL
2924: IFFALSE 2939
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
2926: LD_EXP 3
2930: PUSH
2931: LD_STRING Brian
2933: STR
2934: PPUSH
2935: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2939: LD_EXP 41
2943: PPUSH
2944: CALL_OW 255
2948: PUSH
2949: LD_INT 4
2951: EQUAL
2952: IFFALSE 2967
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
2954: LD_EXP 3
2958: PUSH
2959: LD_STRING Jerry
2961: STR
2962: PPUSH
2963: CALL_OW 40
// end ; end_of_file
2967: LD_VAR 0 1
2971: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
2972: LD_INT 0
2974: PPUSH
2975: PPUSH
2976: PPUSH
2977: PPUSH
2978: PPUSH
2979: PPUSH
2980: PPUSH
2981: PPUSH
2982: PPUSH
2983: PPUSH
2984: PPUSH
2985: PPUSH
2986: PPUSH
// ru_alert := false ;
2987: LD_ADDR_EXP 58
2991: PUSH
2992: LD_INT 0
2994: ST_TO_ADDR
// ru_produce_list := [ ] ;
2995: LD_ADDR_EXP 55
2999: PUSH
3000: EMPTY
3001: ST_TO_ADDR
// if Difficulty > 1 then
3002: LD_OWVAR 67
3006: PUSH
3007: LD_INT 1
3009: GREATER
3010: IFFALSE 3098
// begin uc_side := 3 ;
3012: LD_ADDR_OWVAR 20
3016: PUSH
3017: LD_INT 3
3019: ST_TO_ADDR
// uc_nation := 3 ;
3020: LD_ADDR_OWVAR 21
3024: PUSH
3025: LD_INT 3
3027: ST_TO_ADDR
// bc_type := b_breastwork ;
3028: LD_ADDR_OWVAR 42
3032: PUSH
3033: LD_INT 31
3035: ST_TO_ADDR
// bc_level := Difficulty ;
3036: LD_ADDR_OWVAR 43
3040: PUSH
3041: LD_OWVAR 67
3045: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3046: LD_INT 22
3048: PPUSH
3049: LD_INT 14
3051: PPUSH
3052: LD_INT 0
3054: PPUSH
3055: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3059: LD_INT 48
3061: PPUSH
3062: LD_INT 46
3064: PPUSH
3065: LD_INT 0
3067: PPUSH
3068: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3072: LD_INT 86
3074: PPUSH
3075: LD_INT 65
3077: PPUSH
3078: LD_INT 5
3080: PPUSH
3081: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3085: LD_INT 165
3087: PPUSH
3088: LD_INT 73
3090: PPUSH
3091: LD_INT 5
3093: PPUSH
3094: CALL_OW 47
// end ; if Difficulty = 3 then
3098: LD_OWVAR 67
3102: PUSH
3103: LD_INT 3
3105: EQUAL
3106: IFFALSE 3121
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3108: LD_INT 51
3110: PPUSH
3111: LD_INT 3
3113: PPUSH
3114: LD_INT 2
3116: PPUSH
3117: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3121: LD_ADDR_VAR 0 7
3125: PUSH
3126: LD_INT 22
3128: PUSH
3129: LD_INT 3
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: PUSH
3136: LD_INT 2
3138: PUSH
3139: LD_INT 30
3141: PUSH
3142: LD_INT 31
3144: PUSH
3145: EMPTY
3146: LIST
3147: LIST
3148: PUSH
3149: LD_INT 30
3151: PUSH
3152: LD_INT 32
3154: PUSH
3155: EMPTY
3156: LIST
3157: LIST
3158: PUSH
3159: EMPTY
3160: LIST
3161: LIST
3162: LIST
3163: PUSH
3164: EMPTY
3165: LIST
3166: LIST
3167: PPUSH
3168: CALL_OW 69
3172: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3173: LD_ADDR_VAR 0 8
3177: PUSH
3178: LD_INT 22
3180: PUSH
3181: LD_INT 3
3183: PUSH
3184: EMPTY
3185: LIST
3186: LIST
3187: PUSH
3188: LD_INT 30
3190: PUSH
3191: LD_INT 4
3193: PUSH
3194: EMPTY
3195: LIST
3196: LIST
3197: PUSH
3198: EMPTY
3199: LIST
3200: LIST
3201: PPUSH
3202: CALL_OW 69
3206: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3207: LD_ADDR_VAR 0 10
3211: PUSH
3212: LD_INT 22
3214: PUSH
3215: LD_INT 3
3217: PUSH
3218: EMPTY
3219: LIST
3220: LIST
3221: PUSH
3222: LD_INT 30
3224: PUSH
3225: LD_INT 3
3227: PUSH
3228: EMPTY
3229: LIST
3230: LIST
3231: PUSH
3232: EMPTY
3233: LIST
3234: LIST
3235: PPUSH
3236: CALL_OW 69
3240: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3241: LD_ADDR_VAR 0 9
3245: PUSH
3246: LD_INT 22
3248: PUSH
3249: LD_INT 3
3251: PUSH
3252: EMPTY
3253: LIST
3254: LIST
3255: PUSH
3256: LD_INT 30
3258: PUSH
3259: LD_INT 6
3261: PUSH
3262: EMPTY
3263: LIST
3264: LIST
3265: PUSH
3266: EMPTY
3267: LIST
3268: LIST
3269: PPUSH
3270: CALL_OW 69
3274: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3275: LD_ADDR_VAR 0 2
3279: PUSH
3280: LD_INT 22
3282: PUSH
3283: LD_INT 3
3285: PUSH
3286: EMPTY
3287: LIST
3288: LIST
3289: PUSH
3290: LD_INT 30
3292: PUSH
3293: LD_INT 1
3295: PUSH
3296: EMPTY
3297: LIST
3298: LIST
3299: PUSH
3300: EMPTY
3301: LIST
3302: LIST
3303: PPUSH
3304: CALL_OW 69
3308: PUSH
3309: FOR_IN
3310: IFFALSE 3354
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3312: LD_VAR 0 2
3316: PPUSH
3317: CALL_OW 274
3321: PPUSH
3322: LD_INT 1
3324: PPUSH
3325: LD_INT 5000
3327: PPUSH
3328: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3332: LD_VAR 0 2
3336: PPUSH
3337: CALL_OW 274
3341: PPUSH
3342: LD_INT 2
3344: PPUSH
3345: LD_INT 3000
3347: PPUSH
3348: CALL_OW 277
// end ;
3352: GO 3309
3354: POP
3355: POP
// uc_side := 3 ;
3356: LD_ADDR_OWVAR 20
3360: PUSH
3361: LD_INT 3
3363: ST_TO_ADDR
// uc_nation := 3 ;
3364: LD_ADDR_OWVAR 21
3368: PUSH
3369: LD_INT 3
3371: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3372: LD_ADDR_VAR 0 11
3376: PUSH
3377: LD_INT 2
3379: PUSH
3380: LD_INT 3
3382: PUSH
3383: LD_INT 4
3385: PUSH
3386: EMPTY
3387: LIST
3388: LIST
3389: LIST
3390: PUSH
3391: LD_OWVAR 67
3395: ARRAY
3396: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3397: LD_ADDR_EXP 50
3401: PUSH
3402: LD_STRING Pokryshkin
3404: PPUSH
3405: LD_INT 0
3407: PPUSH
3408: CALL 466 0 2
3412: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3413: LD_EXP 50
3417: PPUSH
3418: LD_INT 63
3420: PPUSH
3421: LD_INT 21
3423: PPUSH
3424: LD_INT 0
3426: PPUSH
3427: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3431: LD_EXP 50
3435: PPUSH
3436: CALL_OW 140
// InitHc ;
3440: CALL_OW 19
// for i in fac do
3444: LD_ADDR_VAR 0 2
3448: PUSH
3449: LD_VAR 0 10
3453: PUSH
3454: FOR_IN
3455: IFFALSE 3508
// begin for j = 1 to 6 do
3457: LD_ADDR_VAR 0 3
3461: PUSH
3462: DOUBLE
3463: LD_INT 1
3465: DEC
3466: ST_TO_ADDR
3467: LD_INT 6
3469: PUSH
3470: FOR_TO
3471: IFFALSE 3504
// begin PrepareHuman ( false , 3 , skill ) ;
3473: LD_INT 0
3475: PPUSH
3476: LD_INT 3
3478: PPUSH
3479: LD_VAR 0 11
3483: PPUSH
3484: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3488: CALL_OW 44
3492: PPUSH
3493: LD_VAR 0 2
3497: PPUSH
3498: CALL_OW 52
// end ;
3502: GO 3470
3504: POP
3505: POP
// end ;
3506: GO 3454
3508: POP
3509: POP
// for i in lab do
3510: LD_ADDR_VAR 0 2
3514: PUSH
3515: LD_VAR 0 9
3519: PUSH
3520: FOR_IN
3521: IFFALSE 3554
// begin PrepareHuman ( false , 4 , skill ) ;
3523: LD_INT 0
3525: PPUSH
3526: LD_INT 4
3528: PPUSH
3529: LD_VAR 0 11
3533: PPUSH
3534: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3538: CALL_OW 44
3542: PPUSH
3543: LD_VAR 0 2
3547: PPUSH
3548: CALL_OW 52
// end ;
3552: GO 3520
3554: POP
3555: POP
// for i in tw do
3556: LD_ADDR_VAR 0 2
3560: PUSH
3561: LD_VAR 0 7
3565: PUSH
3566: FOR_IN
3567: IFFALSE 3616
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3569: LD_VAR 0 2
3573: PPUSH
3574: LD_INT 42
3576: PUSH
3577: LD_INT 43
3579: PUSH
3580: EMPTY
3581: LIST
3582: LIST
3583: PUSH
3584: LD_INT 1
3586: PPUSH
3587: LD_INT 2
3589: PPUSH
3590: CALL_OW 12
3594: ARRAY
3595: PPUSH
3596: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3600: LD_VAR 0 11
3604: PPUSH
3605: LD_VAR 0 2
3609: PPUSH
3610: CALL 807 0 2
// end ;
3614: GO 3566
3616: POP
3617: POP
// for i in bar do
3618: LD_ADDR_VAR 0 2
3622: PUSH
3623: LD_VAR 0 8
3627: PUSH
3628: FOR_IN
3629: IFFALSE 3662
// begin PrepareHuman ( false , 1 , skill ) ;
3631: LD_INT 0
3633: PPUSH
3634: LD_INT 1
3636: PPUSH
3637: LD_VAR 0 11
3641: PPUSH
3642: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3646: CALL_OW 44
3650: PPUSH
3651: LD_VAR 0 2
3655: PPUSH
3656: CALL_OW 52
// end ;
3660: GO 3628
3662: POP
3663: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3664: LD_ADDR_VAR 0 13
3668: PUSH
3669: LD_INT 100
3671: PUSH
3672: LD_INT 9
3674: PUSH
3675: EMPTY
3676: LIST
3677: LIST
3678: PUSH
3679: LD_INT 135
3681: PUSH
3682: LD_INT 60
3684: PUSH
3685: EMPTY
3686: LIST
3687: LIST
3688: PUSH
3689: LD_INT 41
3691: PUSH
3692: LD_INT 6
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: LD_INT 22
3701: PUSH
3702: LD_INT 9
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: PUSH
3709: LD_INT 84
3711: PUSH
3712: LD_INT 14
3714: PUSH
3715: EMPTY
3716: LIST
3717: LIST
3718: PUSH
3719: EMPTY
3720: LIST
3721: LIST
3722: LIST
3723: LIST
3724: LIST
3725: ST_TO_ADDR
// vehicles := [ ] ;
3726: LD_ADDR_VAR 0 12
3730: PUSH
3731: EMPTY
3732: ST_TO_ADDR
// for i in spot_xy do
3733: LD_ADDR_VAR 0 2
3737: PUSH
3738: LD_VAR 0 13
3742: PUSH
3743: FOR_IN
3744: IFFALSE 3902
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3746: LD_ADDR_VAR 0 6
3750: PUSH
3751: LD_INT 3
3753: PPUSH
3754: LD_INT 3
3756: PPUSH
3757: LD_INT 22
3759: PPUSH
3760: LD_INT 1
3762: PPUSH
3763: LD_INT 1
3765: PPUSH
3766: LD_INT 42
3768: PUSH
3769: LD_INT 43
3771: PUSH
3772: LD_INT 44
3774: PUSH
3775: EMPTY
3776: LIST
3777: LIST
3778: LIST
3779: PUSH
3780: LD_INT 1
3782: PPUSH
3783: LD_INT 3
3785: PPUSH
3786: CALL_OW 12
3790: ARRAY
3791: PPUSH
3792: LD_INT 100
3794: PPUSH
3795: CALL 529 0 7
3799: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3800: LD_ADDR_VAR 0 12
3804: PUSH
3805: LD_VAR 0 12
3809: PPUSH
3810: LD_VAR 0 12
3814: PUSH
3815: LD_INT 1
3817: PLUS
3818: PPUSH
3819: LD_VAR 0 6
3823: PPUSH
3824: CALL_OW 2
3828: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3829: LD_VAR 0 6
3833: PPUSH
3834: LD_INT 3
3836: PPUSH
3837: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3841: LD_VAR 0 6
3845: PPUSH
3846: LD_VAR 0 2
3850: PUSH
3851: LD_INT 1
3853: ARRAY
3854: PPUSH
3855: LD_VAR 0 2
3859: PUSH
3860: LD_INT 2
3862: ARRAY
3863: PPUSH
3864: LD_INT 0
3866: PPUSH
3867: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3871: LD_INT 0
3873: PPUSH
3874: LD_INT 3
3876: PPUSH
3877: LD_VAR 0 11
3881: PPUSH
3882: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3886: CALL_OW 44
3890: PPUSH
3891: LD_VAR 0 6
3895: PPUSH
3896: CALL_OW 52
// end ;
3900: GO 3743
3902: POP
3903: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3904: LD_ADDR_VAR 0 2
3908: PUSH
3909: DOUBLE
3910: LD_INT 1
3912: DEC
3913: ST_TO_ADDR
3914: LD_INT 5
3916: PUSH
3917: LD_INT 7
3919: PUSH
3920: LD_INT 8
3922: PUSH
3923: EMPTY
3924: LIST
3925: LIST
3926: LIST
3927: PUSH
3928: LD_OWVAR 67
3932: ARRAY
3933: PUSH
3934: FOR_TO
3935: IFFALSE 3995
// begin PrepareHuman ( false , 1 , skill ) ;
3937: LD_INT 0
3939: PPUSH
3940: LD_INT 1
3942: PPUSH
3943: LD_VAR 0 11
3947: PPUSH
3948: CALL_OW 380
// un := CreateHuman ;
3952: LD_ADDR_VAR 0 5
3956: PUSH
3957: CALL_OW 44
3961: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3962: LD_VAR 0 5
3966: PPUSH
3967: LD_INT 11
3969: PPUSH
3970: LD_INT 0
3972: PPUSH
3973: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3977: LD_ADDR_EXP 53
3981: PUSH
3982: LD_EXP 53
3986: PUSH
3987: LD_VAR 0 5
3991: ADD
3992: ST_TO_ADDR
// end ;
3993: GO 3934
3995: POP
3996: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3997: LD_ADDR_VAR 0 2
4001: PUSH
4002: DOUBLE
4003: LD_INT 1
4005: DEC
4006: ST_TO_ADDR
4007: LD_INT 2
4009: PUSH
4010: LD_INT 3
4012: PUSH
4013: LD_INT 4
4015: PUSH
4016: EMPTY
4017: LIST
4018: LIST
4019: LIST
4020: PUSH
4021: LD_OWVAR 67
4025: ARRAY
4026: PUSH
4027: FOR_TO
4028: IFFALSE 4088
// begin PrepareHuman ( false , 1 , skill ) ;
4030: LD_INT 0
4032: PPUSH
4033: LD_INT 1
4035: PPUSH
4036: LD_VAR 0 11
4040: PPUSH
4041: CALL_OW 380
// un := CreateHuman ;
4045: LD_ADDR_VAR 0 5
4049: PUSH
4050: CALL_OW 44
4054: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4055: LD_VAR 0 5
4059: PPUSH
4060: LD_INT 12
4062: PPUSH
4063: LD_INT 0
4065: PPUSH
4066: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4070: LD_ADDR_EXP 51
4074: PUSH
4075: LD_EXP 51
4079: PUSH
4080: LD_VAR 0 5
4084: ADD
4085: ST_TO_ADDR
// end ;
4086: GO 4027
4088: POP
4089: POP
// for i = 1 to 2 do
4090: LD_ADDR_VAR 0 2
4094: PUSH
4095: DOUBLE
4096: LD_INT 1
4098: DEC
4099: ST_TO_ADDR
4100: LD_INT 2
4102: PUSH
4103: FOR_TO
4104: IFFALSE 4170
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4106: LD_INT 1
4108: PPUSH
4109: LD_INT 1
4111: PPUSH
4112: LD_VAR 0 11
4116: PPUSH
4117: CALL_OW 380
// un := CreateHuman ;
4121: LD_ADDR_VAR 0 5
4125: PUSH
4126: CALL_OW 44
4130: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4131: LD_VAR 0 5
4135: PPUSH
4136: LD_INT 39
4138: PPUSH
4139: LD_INT 12
4141: PPUSH
4142: LD_INT 3
4144: PPUSH
4145: LD_INT 0
4147: PPUSH
4148: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4152: LD_ADDR_EXP 52
4156: PUSH
4157: LD_EXP 52
4161: PUSH
4162: LD_VAR 0 5
4166: ADD
4167: ST_TO_ADDR
// end ;
4168: GO 4103
4170: POP
4171: POP
// for i = 1 to 3 do
4172: LD_ADDR_VAR 0 2
4176: PUSH
4177: DOUBLE
4178: LD_INT 1
4180: DEC
4181: ST_TO_ADDR
4182: LD_INT 3
4184: PUSH
4185: FOR_TO
4186: IFFALSE 4252
// begin PrepareHuman ( false , 1 , skill ) ;
4188: LD_INT 0
4190: PPUSH
4191: LD_INT 1
4193: PPUSH
4194: LD_VAR 0 11
4198: PPUSH
4199: CALL_OW 380
// un := CreateHuman ;
4203: LD_ADDR_VAR 0 5
4207: PUSH
4208: CALL_OW 44
4212: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4213: LD_VAR 0 5
4217: PPUSH
4218: LD_INT 180
4220: PPUSH
4221: LD_INT 11
4223: PPUSH
4224: LD_INT 4
4226: PPUSH
4227: LD_INT 0
4229: PPUSH
4230: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4234: LD_ADDR_EXP 56
4238: PUSH
4239: LD_EXP 56
4243: PUSH
4244: LD_VAR 0 5
4248: ADD
4249: ST_TO_ADDR
// end ;
4250: GO 4185
4252: POP
4253: POP
// ru_vehicles := vehicles ;
4254: LD_ADDR_EXP 54
4258: PUSH
4259: LD_VAR 0 12
4263: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4264: LD_ADDR_EXP 57
4268: PUSH
4269: LD_INT 131
4271: PUSH
4272: LD_INT 121
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: PUSH
4279: LD_INT 113
4281: PUSH
4282: LD_INT 90
4284: PUSH
4285: EMPTY
4286: LIST
4287: LIST
4288: PUSH
4289: LD_INT 93
4291: PUSH
4292: LD_INT 62
4294: PUSH
4295: EMPTY
4296: LIST
4297: LIST
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: LIST
4303: PUSH
4304: LD_INT 106
4306: PUSH
4307: LD_INT 54
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: PUSH
4314: LD_INT 120
4316: PUSH
4317: LD_INT 80
4319: PUSH
4320: EMPTY
4321: LIST
4322: LIST
4323: PUSH
4324: LD_INT 143
4326: PUSH
4327: LD_INT 120
4329: PUSH
4330: EMPTY
4331: LIST
4332: LIST
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: LIST
4338: PUSH
4339: LD_INT 154
4341: PUSH
4342: LD_INT 116
4344: PUSH
4345: EMPTY
4346: LIST
4347: LIST
4348: PUSH
4349: LD_INT 140
4351: PUSH
4352: LD_INT 93
4354: PUSH
4355: EMPTY
4356: LIST
4357: LIST
4358: PUSH
4359: LD_INT 130
4361: PUSH
4362: LD_INT 58
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: LIST
4373: PUSH
4374: LD_INT 105
4376: PUSH
4377: LD_INT 106
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: PUSH
4384: LD_INT 134
4386: PUSH
4387: LD_INT 98
4389: PUSH
4390: EMPTY
4391: LIST
4392: LIST
4393: PUSH
4394: LD_INT 159
4396: PUSH
4397: LD_INT 113
4399: PUSH
4400: EMPTY
4401: LIST
4402: LIST
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: LIST
4408: PUSH
4409: EMPTY
4410: LIST
4411: LIST
4412: LIST
4413: LIST
4414: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4415: LD_ADDR_VAR 0 2
4419: PUSH
4420: DOUBLE
4421: LD_INT 1
4423: DEC
4424: ST_TO_ADDR
4425: LD_OWVAR 67
4429: PUSH
4430: LD_INT 1
4432: MINUS
4433: PUSH
4434: FOR_TO
4435: IFFALSE 4468
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4437: LD_ADDR_EXP 55
4441: PUSH
4442: LD_EXP 55
4446: PUSH
4447: LD_INT 22
4449: PUSH
4450: LD_INT 1
4452: PUSH
4453: LD_INT 1
4455: PUSH
4456: LD_INT 43
4458: PUSH
4459: EMPTY
4460: LIST
4461: LIST
4462: LIST
4463: LIST
4464: ADD
4465: ST_TO_ADDR
4466: GO 4434
4468: POP
4469: POP
// end ;
4470: LD_VAR 0 1
4474: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4475: LD_INT 22
4477: PUSH
4478: LD_INT 3
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: PUSH
4485: LD_INT 21
4487: PUSH
4488: LD_INT 2
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: PUSH
4495: EMPTY
4496: LIST
4497: LIST
4498: PPUSH
4499: CALL_OW 69
4503: IFFALSE 4597
4505: GO 4507
4507: DISABLE
4508: LD_INT 0
4510: PPUSH
4511: PPUSH
// begin enable ;
4512: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4513: LD_ADDR_VAR 0 2
4517: PUSH
4518: LD_INT 22
4520: PUSH
4521: LD_INT 3
4523: PUSH
4524: EMPTY
4525: LIST
4526: LIST
4527: PUSH
4528: LD_INT 21
4530: PUSH
4531: LD_INT 2
4533: PUSH
4534: EMPTY
4535: LIST
4536: LIST
4537: PUSH
4538: EMPTY
4539: LIST
4540: LIST
4541: PPUSH
4542: CALL_OW 69
4546: ST_TO_ADDR
// if filter then
4547: LD_VAR 0 2
4551: IFFALSE 4597
// for i in filter do
4553: LD_ADDR_VAR 0 1
4557: PUSH
4558: LD_VAR 0 2
4562: PUSH
4563: FOR_IN
4564: IFFALSE 4595
// if GetFuel ( i ) < 20 then
4566: LD_VAR 0 1
4570: PPUSH
4571: CALL_OW 261
4575: PUSH
4576: LD_INT 20
4578: LESS
4579: IFFALSE 4593
// SetFuel ( i , 20 ) ;
4581: LD_VAR 0 1
4585: PPUSH
4586: LD_INT 20
4588: PPUSH
4589: CALL_OW 240
4593: GO 4563
4595: POP
4596: POP
// end ;
4597: PPOPN 2
4599: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4600: LD_EXP 55
4604: IFFALSE 4823
4606: GO 4608
4608: DISABLE
4609: LD_INT 0
4611: PPUSH
4612: PPUSH
4613: PPUSH
// begin enable ;
4614: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4615: LD_ADDR_VAR 0 2
4619: PUSH
4620: LD_INT 22
4622: PUSH
4623: LD_INT 3
4625: PUSH
4626: EMPTY
4627: LIST
4628: LIST
4629: PUSH
4630: LD_INT 30
4632: PUSH
4633: LD_INT 3
4635: PUSH
4636: EMPTY
4637: LIST
4638: LIST
4639: PUSH
4640: EMPTY
4641: LIST
4642: LIST
4643: PPUSH
4644: CALL_OW 69
4648: ST_TO_ADDR
// can_produce := [ ] ;
4649: LD_ADDR_VAR 0 3
4653: PUSH
4654: EMPTY
4655: ST_TO_ADDR
// if not fac then
4656: LD_VAR 0 2
4660: NOT
4661: IFFALSE 4666
// begin disable ;
4663: DISABLE
// exit ;
4664: GO 4823
// end ; for i in fac do
4666: LD_ADDR_VAR 0 1
4670: PUSH
4671: LD_VAR 0 2
4675: PUSH
4676: FOR_IN
4677: IFFALSE 4715
// if UnitsInside ( i ) then
4679: LD_VAR 0 1
4683: PPUSH
4684: CALL_OW 313
4688: IFFALSE 4713
// can_produce := Insert ( can_produce , 1 , i ) ;
4690: LD_ADDR_VAR 0 3
4694: PUSH
4695: LD_VAR 0 3
4699: PPUSH
4700: LD_INT 1
4702: PPUSH
4703: LD_VAR 0 1
4707: PPUSH
4708: CALL_OW 2
4712: ST_TO_ADDR
4713: GO 4676
4715: POP
4716: POP
// if not can_produce then
4717: LD_VAR 0 3
4721: NOT
4722: IFFALSE 4726
// exit ;
4724: GO 4823
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4726: LD_VAR 0 3
4730: PUSH
4731: LD_INT 1
4733: PPUSH
4734: LD_VAR 0 3
4738: PPUSH
4739: CALL_OW 12
4743: ARRAY
4744: PPUSH
4745: LD_EXP 55
4749: PUSH
4750: LD_INT 1
4752: ARRAY
4753: PPUSH
4754: LD_EXP 55
4758: PUSH
4759: LD_INT 2
4761: ARRAY
4762: PPUSH
4763: LD_EXP 55
4767: PUSH
4768: LD_INT 3
4770: ARRAY
4771: PPUSH
4772: LD_EXP 55
4776: PUSH
4777: LD_INT 4
4779: ARRAY
4780: PPUSH
4781: CALL_OW 125
// for i = 1 to 4 do
4785: LD_ADDR_VAR 0 1
4789: PUSH
4790: DOUBLE
4791: LD_INT 1
4793: DEC
4794: ST_TO_ADDR
4795: LD_INT 4
4797: PUSH
4798: FOR_TO
4799: IFFALSE 4821
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4801: LD_ADDR_EXP 55
4805: PUSH
4806: LD_EXP 55
4810: PPUSH
4811: LD_INT 1
4813: PPUSH
4814: CALL_OW 3
4818: ST_TO_ADDR
4819: GO 4798
4821: POP
4822: POP
// end ;
4823: PPOPN 3
4825: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4826: LD_INT 0
4828: PPUSH
4829: PPUSH
4830: PPUSH
// for i = 1 to 6 do
4831: LD_ADDR_VAR 0 2
4835: PUSH
4836: DOUBLE
4837: LD_INT 1
4839: DEC
4840: ST_TO_ADDR
4841: LD_INT 6
4843: PUSH
4844: FOR_TO
4845: IFFALSE 4994
// begin PrepareHuman ( false , 3 , 3 ) ;
4847: LD_INT 0
4849: PPUSH
4850: LD_INT 3
4852: PPUSH
4853: LD_INT 3
4855: PPUSH
4856: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4860: LD_ADDR_VAR 0 3
4864: PUSH
4865: LD_INT 3
4867: PPUSH
4868: LD_INT 3
4870: PPUSH
4871: LD_INT 22
4873: PPUSH
4874: LD_INT 1
4876: PPUSH
4877: LD_INT 1
4879: PPUSH
4880: LD_INT 43
4882: PUSH
4883: LD_INT 42
4885: PUSH
4886: EMPTY
4887: LIST
4888: LIST
4889: PUSH
4890: LD_INT 1
4892: PPUSH
4893: LD_INT 2
4895: PPUSH
4896: CALL_OW 12
4900: ARRAY
4901: PPUSH
4902: LD_INT 70
4904: PPUSH
4905: CALL 529 0 7
4909: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4910: LD_VAR 0 3
4914: PPUSH
4915: LD_INT 4
4917: PPUSH
4918: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4922: LD_VAR 0 3
4926: PPUSH
4927: LD_INT 229
4929: PPUSH
4930: LD_INT 44
4932: PPUSH
4933: LD_INT 0
4935: PPUSH
4936: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4940: CALL_OW 44
4944: PPUSH
4945: LD_VAR 0 3
4949: PPUSH
4950: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4954: LD_ADDR_EXP 54
4958: PUSH
4959: LD_EXP 54
4963: PUSH
4964: LD_VAR 0 3
4968: ADD
4969: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
4970: LD_VAR 0 3
4974: PPUSH
4975: LD_INT 191
4977: PPUSH
4978: LD_INT 32
4980: PPUSH
4981: CALL_OW 111
// Wait ( 0 0$02 ) ;
4985: LD_INT 70
4987: PPUSH
4988: CALL_OW 67
// end ;
4992: GO 4844
4994: POP
4995: POP
// end ;
4996: LD_VAR 0 1
5000: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
5001: LD_EXP 29
5005: PUSH
5006: LD_EXP 54
5010: AND
5011: IFFALSE 5185
5013: GO 5015
5015: DISABLE
5016: LD_INT 0
5018: PPUSH
5019: PPUSH
5020: PPUSH
// begin wait ( 0 0$50 ) ;
5021: LD_INT 1750
5023: PPUSH
5024: CALL_OW 67
// tmp := ru_vehicles ;
5028: LD_ADDR_VAR 0 3
5032: PUSH
5033: LD_EXP 54
5037: ST_TO_ADDR
// if not tmp then
5038: LD_VAR 0 3
5042: NOT
5043: IFFALSE 5047
// exit ;
5045: GO 5185
// repeat wait ( 0 0$1 ) ;
5047: LD_INT 35
5049: PPUSH
5050: CALL_OW 67
// for i in tmp do
5054: LD_ADDR_VAR 0 1
5058: PUSH
5059: LD_VAR 0 3
5063: PUSH
5064: FOR_IN
5065: IFFALSE 5176
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5067: LD_ADDR_VAR 0 2
5071: PUSH
5072: LD_INT 22
5074: PUSH
5075: LD_INT 1
5077: PUSH
5078: EMPTY
5079: LIST
5080: LIST
5081: PPUSH
5082: LD_VAR 0 1
5086: PPUSH
5087: CALL_OW 74
5091: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5092: LD_VAR 0 1
5096: PPUSH
5097: LD_VAR 0 2
5101: PPUSH
5102: CALL_OW 296
5106: PUSH
5107: LD_INT 10
5109: GREATER
5110: IFFALSE 5129
// ComAgressiveMove ( i , 69 , 101 ) else
5112: LD_VAR 0 1
5116: PPUSH
5117: LD_INT 69
5119: PPUSH
5120: LD_INT 101
5122: PPUSH
5123: CALL_OW 114
5127: GO 5143
// ComAttackUnit ( i , enemy ) ;
5129: LD_VAR 0 1
5133: PPUSH
5134: LD_VAR 0 2
5138: PPUSH
5139: CALL_OW 115
// if GetLives ( i ) < 250 then
5143: LD_VAR 0 1
5147: PPUSH
5148: CALL_OW 256
5152: PUSH
5153: LD_INT 250
5155: LESS
5156: IFFALSE 5174
// tmp := tmp diff i ;
5158: LD_ADDR_VAR 0 3
5162: PUSH
5163: LD_VAR 0 3
5167: PUSH
5168: LD_VAR 0 1
5172: DIFF
5173: ST_TO_ADDR
// end ;
5174: GO 5064
5176: POP
5177: POP
// until not tmp ;
5178: LD_VAR 0 3
5182: NOT
5183: IFFALSE 5047
// end ; end_of_file
5185: PPOPN 3
5187: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5188: LD_INT 0
5190: PPUSH
5191: PPUSH
5192: PPUSH
5193: PPUSH
5194: PPUSH
5195: PPUSH
5196: PPUSH
// InGameOn ;
5197: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5201: LD_EXP 35
5205: PPUSH
5206: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5210: LD_EXP 35
5214: PPUSH
5215: LD_EXP 42
5219: PPUSH
5220: CALL_OW 119
// if Bierezov then
5224: LD_EXP 43
5228: IFFALSE 5244
// ComTurnUnit ( Bierezov , Cornel ) ;
5230: LD_EXP 43
5234: PPUSH
5235: LD_EXP 42
5239: PPUSH
5240: CALL_OW 119
// for i in jmm_units do
5244: LD_ADDR_VAR 0 2
5248: PUSH
5249: LD_EXP 4
5253: PUSH
5254: FOR_IN
5255: IFFALSE 5273
// ComTurnUnit ( i , Cornel ) ;
5257: LD_VAR 0 2
5261: PPUSH
5262: LD_EXP 42
5266: PPUSH
5267: CALL_OW 119
5271: GO 5254
5273: POP
5274: POP
// units := cornel_units union Cornel ;
5275: LD_ADDR_VAR 0 3
5279: PUSH
5280: LD_EXP 6
5284: PUSH
5285: LD_EXP 42
5289: UNION
5290: ST_TO_ADDR
// repeat wait ( 1 ) ;
5291: LD_INT 1
5293: PPUSH
5294: CALL_OW 67
// for i in units do
5298: LD_ADDR_VAR 0 2
5302: PUSH
5303: LD_VAR 0 3
5307: PUSH
5308: FOR_IN
5309: IFFALSE 5342
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5311: LD_VAR 0 2
5315: PPUSH
5316: LD_EXP 35
5320: PPUSH
5321: CALL_OW 250
5325: PPUSH
5326: LD_EXP 35
5330: PPUSH
5331: CALL_OW 251
5335: PPUSH
5336: CALL_OW 111
5340: GO 5308
5342: POP
5343: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5344: LD_VAR 0 3
5348: PPUSH
5349: LD_INT 92
5351: PUSH
5352: LD_EXP 35
5356: PPUSH
5357: CALL_OW 250
5361: PUSH
5362: LD_EXP 35
5366: PPUSH
5367: CALL_OW 251
5371: PUSH
5372: LD_INT 10
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: LIST
5379: LIST
5380: PPUSH
5381: CALL_OW 72
5385: PUSH
5386: LD_VAR 0 3
5390: EQUAL
5391: IFFALSE 5291
// for i in units do
5393: LD_ADDR_VAR 0 2
5397: PUSH
5398: LD_VAR 0 3
5402: PUSH
5403: FOR_IN
5404: IFFALSE 5422
// ComTurnUnit ( i , JMM ) ;
5406: LD_VAR 0 2
5410: PPUSH
5411: LD_EXP 35
5415: PPUSH
5416: CALL_OW 119
5420: GO 5403
5422: POP
5423: POP
// ComTurnUnit ( Cornel , JMM ) ;
5424: LD_EXP 42
5428: PPUSH
5429: LD_EXP 35
5433: PPUSH
5434: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5438: LD_EXP 35
5442: PPUSH
5443: LD_STRING D1-JMM-1
5445: PPUSH
5446: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5450: LD_EXP 42
5454: PPUSH
5455: LD_STRING D1-Corn-1
5457: PPUSH
5458: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5462: LD_EXP 35
5466: PPUSH
5467: LD_EXP 42
5471: PPUSH
5472: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5476: LD_EXP 42
5480: PPUSH
5481: LD_EXP 35
5485: PPUSH
5486: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5490: LD_INT 35
5492: PPUSH
5493: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5497: LD_EXP 35
5501: PPUSH
5502: LD_EXP 42
5506: PPUSH
5507: CALL_OW 296
5511: PUSH
5512: LD_INT 6
5514: LESS
5515: IFFALSE 5490
// ChangeSideFog ( 4 , 1 ) ;
5517: LD_INT 4
5519: PPUSH
5520: LD_INT 1
5522: PPUSH
5523: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5527: LD_EXP 35
5531: PPUSH
5532: LD_EXP 42
5536: PPUSH
5537: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5541: LD_EXP 42
5545: PPUSH
5546: LD_EXP 35
5550: PPUSH
5551: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5555: LD_EXP 35
5559: PPUSH
5560: LD_STRING D1-JMM-2
5562: PPUSH
5563: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5567: LD_EXP 35
5571: PPUSH
5572: LD_STRING D1-JMM-2a
5574: PPUSH
5575: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5579: LD_EXP 42
5583: PPUSH
5584: LD_STRING D1-Corn-2
5586: PPUSH
5587: CALL_OW 88
// if bierezov_exist or debug then
5591: LD_EXP 7
5595: PUSH
5596: LD_EXP 1
5600: OR
5601: IFFALSE 5842
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5603: LD_EXP 42
5607: PPUSH
5608: LD_EXP 43
5612: PPUSH
5613: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5617: LD_INT 10
5619: PPUSH
5620: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5624: LD_EXP 42
5628: PPUSH
5629: LD_STRING D1a-Corn-1
5631: PPUSH
5632: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5636: LD_EXP 35
5640: PPUSH
5641: LD_EXP 43
5645: PPUSH
5646: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5650: LD_EXP 43
5654: PPUSH
5655: LD_EXP 35
5659: PPUSH
5660: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5664: LD_EXP 35
5668: PPUSH
5669: LD_STRING D1a-JMM-1
5671: PPUSH
5672: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5676: LD_EXP 35
5680: PPUSH
5681: LD_EXP 42
5685: PPUSH
5686: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5690: LD_EXP 42
5694: PPUSH
5695: LD_EXP 35
5699: PPUSH
5700: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5704: LD_EXP 42
5708: PPUSH
5709: LD_STRING D1a-Corn-2
5711: PPUSH
5712: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5716: LD_EXP 35
5720: PPUSH
5721: LD_STRING D1a-JMM-2
5723: PPUSH
5724: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5728: LD_EXP 42
5732: PPUSH
5733: LD_STRING D1a-Corn-3
5735: PPUSH
5736: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5740: LD_EXP 35
5744: PPUSH
5745: LD_STRING D1a-JMM-3
5747: PPUSH
5748: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5752: LD_EXP 42
5756: PPUSH
5757: LD_STRING D1a-Corn-4
5759: PPUSH
5760: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5764: LD_EXP 35
5768: PPUSH
5769: LD_STRING D1a-JMM-4
5771: PPUSH
5772: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5776: LD_EXP 42
5780: PPUSH
5781: LD_STRING D1a-Corn-5
5783: PPUSH
5784: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5788: LD_EXP 43
5792: PPUSH
5793: LD_EXP 42
5797: PPUSH
5798: CALL_OW 250
5802: PPUSH
5803: LD_EXP 42
5807: PPUSH
5808: CALL_OW 251
5812: PUSH
5813: LD_INT 2
5815: MINUS
5816: PPUSH
5817: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5821: LD_EXP 43
5825: PPUSH
5826: LD_EXP 42
5830: PPUSH
5831: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5835: LD_INT 10
5837: PPUSH
5838: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5842: LD_EXP 35
5846: PPUSH
5847: LD_STRING D1b-JMM-1
5849: PPUSH
5850: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5854: LD_EXP 42
5858: PPUSH
5859: LD_STRING D1b-Corn-1
5861: PPUSH
5862: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5866: LD_EXP 35
5870: PPUSH
5871: LD_STRING D1b-JMM-2
5873: PPUSH
5874: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5878: LD_EXP 42
5882: PPUSH
5883: LD_STRING D1b-Corn-2
5885: PPUSH
5886: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5890: LD_EXP 35
5894: PPUSH
5895: LD_STRING D1b-JMM-3
5897: PPUSH
5898: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5902: LD_INT 10
5904: PPUSH
5905: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5909: LD_EXP 44
5913: PPUSH
5914: LD_STRING D1b-Pow-3
5916: PPUSH
5917: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5921: LD_EXP 35
5925: PPUSH
5926: LD_STRING D1b-JMM-4
5928: PPUSH
5929: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5933: LD_EXP 42
5937: PPUSH
5938: LD_STRING D1b-Corn-4
5940: PPUSH
5941: CALL_OW 88
// if Khatam then
5945: LD_EXP 39
5949: IFFALSE 5965
// Say ( Khatam , D1b-Khat-4 ) else
5951: LD_EXP 39
5955: PPUSH
5956: LD_STRING D1b-Khat-4
5958: PPUSH
5959: CALL_OW 88
5963: GO 6001
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
5965: LD_EXP 6
5969: PPUSH
5970: LD_INT 26
5972: PUSH
5973: LD_INT 1
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: PPUSH
5980: CALL_OW 72
5984: PUSH
5985: LD_EXP 42
5989: PUSH
5990: EMPTY
5991: LIST
5992: DIFF
5993: PPUSH
5994: LD_STRING D1b-Sol1-4
5996: PPUSH
5997: CALL 617 0 2
// if Cyrus then
6001: LD_EXP 37
6005: IFFALSE 6019
// Say ( Cyrus , D1b-Cyrus-4 ) ;
6007: LD_EXP 37
6011: PPUSH
6012: LD_STRING D1b-Cyrus-4
6014: PPUSH
6015: CALL_OW 88
// if Lisa then
6019: LD_EXP 38
6023: IFFALSE 6081
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6025: LD_EXP 38
6029: PPUSH
6030: LD_STRING D1b-Lisa-4
6032: PPUSH
6033: CALL_OW 88
// if Cyrus then
6037: LD_EXP 37
6041: IFFALSE 6081
// begin if not IsInUnit ( Cyrus ) then
6043: LD_EXP 37
6047: PPUSH
6048: CALL_OW 310
6052: NOT
6053: IFFALSE 6069
// ComTurnUnit ( Cyrus , Lisa ) ;
6055: LD_EXP 37
6059: PPUSH
6060: LD_EXP 38
6064: PPUSH
6065: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6069: LD_EXP 37
6073: PPUSH
6074: LD_STRING D1b-Cyrus-5
6076: PPUSH
6077: CALL_OW 88
// end ; end ; SelectGroup ;
6081: CALL 2570 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6085: LD_EXP 35
6089: PPUSH
6090: LD_STRING D1d-JMM-1
6092: PPUSH
6093: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6097: LD_EXP 42
6101: PPUSH
6102: LD_STRING D1d-Corn-1
6104: PPUSH
6105: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6109: LD_ADDR_VAR 0 2
6113: PUSH
6114: LD_EXP 4
6118: PUSH
6119: LD_EXP 6
6123: ADD
6124: PUSH
6125: LD_EXP 35
6129: ADD
6130: PUSH
6131: FOR_IN
6132: IFFALSE 6145
// ComHold ( i ) ;
6134: LD_VAR 0 2
6138: PPUSH
6139: CALL_OW 140
6143: GO 6131
6145: POP
6146: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6147: LD_ADDR_VAR 0 4
6151: PUSH
6152: LD_INT 22
6154: PUSH
6155: LD_INT 1
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: PUSH
6162: LD_INT 21
6164: PUSH
6165: LD_INT 2
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: PUSH
6172: EMPTY
6173: LIST
6174: LIST
6175: PPUSH
6176: CALL_OW 69
6180: ST_TO_ADDR
// if vehicles then
6181: LD_VAR 0 4
6185: IFFALSE 6523
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6187: LD_EXP 6
6191: PPUSH
6192: LD_INT 55
6194: PUSH
6195: EMPTY
6196: LIST
6197: PPUSH
6198: CALL_OW 72
6202: IFFALSE 6241
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6204: LD_ADDR_VAR 0 2
6208: PUSH
6209: LD_EXP 6
6213: PPUSH
6214: LD_INT 55
6216: PUSH
6217: EMPTY
6218: LIST
6219: PPUSH
6220: CALL_OW 72
6224: PUSH
6225: FOR_IN
6226: IFFALSE 6239
// ComExitVehicle ( i ) ;
6228: LD_VAR 0 2
6232: PPUSH
6233: CALL_OW 121
6237: GO 6225
6239: POP
6240: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6241: LD_ADDR_VAR 0 5
6245: PUSH
6246: LD_VAR 0 4
6250: PPUSH
6251: LD_INT 34
6253: PUSH
6254: LD_INT 51
6256: PUSH
6257: EMPTY
6258: LIST
6259: LIST
6260: PPUSH
6261: CALL_OW 72
6265: ST_TO_ADDR
// if cargos then
6266: LD_VAR 0 5
6270: IFFALSE 6453
// begin vehicles := cargos ;
6272: LD_ADDR_VAR 0 4
6276: PUSH
6277: LD_VAR 0 5
6281: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6282: LD_ADDR_VAR 0 6
6286: PUSH
6287: LD_STRING 02_resources_4
6289: PPUSH
6290: LD_INT 0
6292: PPUSH
6293: CALL_OW 30
6297: ST_TO_ADDR
// if debug and not resources then
6298: LD_EXP 1
6302: PUSH
6303: LD_VAR 0 6
6307: NOT
6308: AND
6309: IFFALSE 6319
// resources := 160 ;
6311: LD_ADDR_VAR 0 6
6315: PUSH
6316: LD_INT 160
6318: ST_TO_ADDR
// if resources mod 10 then
6319: LD_VAR 0 6
6323: PUSH
6324: LD_INT 10
6326: MOD
6327: IFFALSE 6349
// resources := resources - resources mod 10 ;
6329: LD_ADDR_VAR 0 6
6333: PUSH
6334: LD_VAR 0 6
6338: PUSH
6339: LD_VAR 0 6
6343: PUSH
6344: LD_INT 10
6346: MOD
6347: MINUS
6348: ST_TO_ADDR
// if resources then
6349: LD_VAR 0 6
6353: IFFALSE 6453
// for i in cargos do
6355: LD_ADDR_VAR 0 2
6359: PUSH
6360: LD_VAR 0 5
6364: PUSH
6365: FOR_IN
6366: IFFALSE 6451
// begin if resources < 100 then
6368: LD_VAR 0 6
6372: PUSH
6373: LD_INT 100
6375: LESS
6376: IFFALSE 6398
// begin cargo := resources ;
6378: LD_ADDR_VAR 0 7
6382: PUSH
6383: LD_VAR 0 6
6387: ST_TO_ADDR
// resources := 0 ;
6388: LD_ADDR_VAR 0 6
6392: PUSH
6393: LD_INT 0
6395: ST_TO_ADDR
// end else
6396: GO 6420
// begin cargo := 100 ;
6398: LD_ADDR_VAR 0 7
6402: PUSH
6403: LD_INT 100
6405: ST_TO_ADDR
// resources := resources - 100 ;
6406: LD_ADDR_VAR 0 6
6410: PUSH
6411: LD_VAR 0 6
6415: PUSH
6416: LD_INT 100
6418: MINUS
6419: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6420: LD_VAR 0 2
6424: PPUSH
6425: LD_INT 1
6427: PPUSH
6428: LD_VAR 0 7
6432: PPUSH
6433: CALL_OW 290
// if resources = 0 then
6437: LD_VAR 0 6
6441: PUSH
6442: LD_INT 0
6444: EQUAL
6445: IFFALSE 6449
// break ;
6447: GO 6451
// end ;
6449: GO 6365
6451: POP
6452: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6453: LD_VAR 0 4
6457: PUSH
6458: LD_INT 1
6460: ARRAY
6461: PPUSH
6462: CALL_OW 311
6466: PPUSH
6467: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6471: LD_VAR 0 4
6475: PUSH
6476: LD_INT 1
6478: ARRAY
6479: PPUSH
6480: LD_INT 4
6482: PPUSH
6483: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6487: LD_EXP 42
6491: PPUSH
6492: LD_VAR 0 4
6496: PUSH
6497: LD_INT 1
6499: ARRAY
6500: PPUSH
6501: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6505: LD_INT 35
6507: PPUSH
6508: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6512: LD_EXP 42
6516: PPUSH
6517: CALL_OW 310
6521: IFFALSE 6505
// end ; InGameOff ;
6523: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6527: LD_STRING M1
6529: PPUSH
6530: CALL_OW 337
// SaveForQuickRestart ;
6534: CALL_OW 22
// cornel_active := true ;
6538: LD_ADDR_EXP 8
6542: PUSH
6543: LD_INT 1
6545: ST_TO_ADDR
// end ;
6546: LD_VAR 0 1
6550: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
6551: LD_EXP 35
6555: PPUSH
6556: LD_EXP 45
6560: PPUSH
6561: CALL_OW 296
6565: PUSH
6566: LD_INT 10
6568: LESS
6569: IFFALSE 7803
6571: GO 6573
6573: DISABLE
6574: LD_INT 0
6576: PPUSH
6577: PPUSH
6578: PPUSH
6579: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6580: LD_ADDR_VAR 0 2
6584: PUSH
6585: LD_INT 89
6587: PUSH
6588: LD_INT 34
6590: PUSH
6591: EMPTY
6592: LIST
6593: LIST
6594: PUSH
6595: LD_INT 138
6597: PUSH
6598: LD_INT 63
6600: PUSH
6601: EMPTY
6602: LIST
6603: LIST
6604: PUSH
6605: LD_INT 196
6607: PUSH
6608: LD_INT 84
6610: PUSH
6611: EMPTY
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 135
6617: PUSH
6618: LD_INT 52
6620: PUSH
6621: EMPTY
6622: LIST
6623: LIST
6624: PUSH
6625: LD_INT 103
6627: PUSH
6628: LD_INT 39
6630: PUSH
6631: EMPTY
6632: LIST
6633: LIST
6634: PUSH
6635: LD_INT 58
6637: PUSH
6638: LD_INT 30
6640: PUSH
6641: EMPTY
6642: LIST
6643: LIST
6644: PUSH
6645: LD_INT 38
6647: PUSH
6648: LD_INT 51
6650: PUSH
6651: EMPTY
6652: LIST
6653: LIST
6654: PUSH
6655: EMPTY
6656: LIST
6657: LIST
6658: LIST
6659: LIST
6660: LIST
6661: LIST
6662: LIST
6663: ST_TO_ADDR
// InGameOn ;
6664: CALL_OW 8
// if jmm_units then
6668: LD_EXP 4
6672: IFFALSE 6748
// for i in jmm_units do
6674: LD_ADDR_VAR 0 1
6678: PUSH
6679: LD_EXP 4
6683: PUSH
6684: FOR_IN
6685: IFFALSE 6746
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6687: LD_VAR 0 1
6691: PPUSH
6692: LD_EXP 35
6696: PPUSH
6697: CALL_OW 296
6701: PUSH
6702: LD_INT 10
6704: LESS
6705: PUSH
6706: LD_VAR 0 1
6710: PPUSH
6711: CALL_OW 310
6715: NOT
6716: AND
6717: IFFALSE 6735
// ComTurnUnit ( i , JMM ) else
6719: LD_VAR 0 1
6723: PPUSH
6724: LD_EXP 35
6728: PPUSH
6729: CALL_OW 119
6733: GO 6744
// ComHold ( i ) ;
6735: LD_VAR 0 1
6739: PPUSH
6740: CALL_OW 140
// end ;
6744: GO 6684
6746: POP
6747: POP
// if IsInUnit ( JMM ) then
6748: LD_EXP 35
6752: PPUSH
6753: CALL_OW 310
6757: IFFALSE 6782
// begin ComExitVehicle ( JMM ) ;
6759: LD_EXP 35
6763: PPUSH
6764: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6768: LD_EXP 35
6772: PPUSH
6773: LD_EXP 45
6777: PPUSH
6778: CALL_OW 172
// end ; Wait ( 10 ) ;
6782: LD_INT 10
6784: PPUSH
6785: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6789: LD_EXP 35
6793: PPUSH
6794: LD_EXP 45
6798: PPUSH
6799: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6803: LD_INT 35
6805: PPUSH
6806: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6810: LD_EXP 35
6814: PPUSH
6815: LD_EXP 45
6819: PPUSH
6820: CALL_OW 296
6824: PUSH
6825: LD_INT 6
6827: LESS
6828: IFFALSE 6803
// ComTurnUnit ( JMM , Lynch ) ;
6830: LD_EXP 35
6834: PPUSH
6835: LD_EXP 45
6839: PPUSH
6840: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6844: LD_ADDR_VAR 0 1
6848: PUSH
6849: LD_EXP 45
6853: PUSH
6854: LD_EXP 46
6858: PUSH
6859: LD_EXP 47
6863: PUSH
6864: LD_EXP 48
6868: PUSH
6869: EMPTY
6870: LIST
6871: LIST
6872: LIST
6873: LIST
6874: PUSH
6875: FOR_IN
6876: IFFALSE 6894
// ComTurnUnit ( i , JMM ) ;
6878: LD_VAR 0 1
6882: PPUSH
6883: LD_EXP 35
6887: PPUSH
6888: CALL_OW 119
6892: GO 6875
6894: POP
6895: POP
// Wait ( 0 0$0.3 ) ;
6896: LD_INT 10
6898: PPUSH
6899: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6903: LD_EXP 35
6907: PPUSH
6908: LD_STRING D2-JMM-1
6910: PPUSH
6911: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6915: LD_EXP 45
6919: PPUSH
6920: LD_STRING D2-Sol1-1
6922: PPUSH
6923: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6927: LD_EXP 35
6931: PPUSH
6932: LD_STRING D2-JMM-2
6934: PPUSH
6935: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6939: LD_EXP 45
6943: PPUSH
6944: LD_STRING D2-Sol1-2
6946: PPUSH
6947: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6951: LD_EXP 35
6955: PPUSH
6956: LD_STRING D2-JMM-3
6958: PPUSH
6959: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
6963: LD_EXP 45
6967: PPUSH
6968: LD_STRING D2-Sol1-3
6970: PPUSH
6971: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6975: LD_ADDR_VAR 0 1
6979: PUSH
6980: LD_INT 22
6982: PUSH
6983: LD_INT 8
6985: PUSH
6986: EMPTY
6987: LIST
6988: LIST
6989: PPUSH
6990: CALL_OW 69
6994: PUSH
6995: FOR_IN
6996: IFFALSE 7012
// SetSide ( i , 1 ) ;
6998: LD_VAR 0 1
7002: PPUSH
7003: LD_INT 1
7005: PPUSH
7006: CALL_OW 235
7010: GO 6995
7012: POP
7013: POP
// Say ( JMM , D2-JMM-4 ) ;
7014: LD_EXP 35
7018: PPUSH
7019: LD_STRING D2-JMM-4
7021: PPUSH
7022: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7026: LD_INT 1
7028: PPUSH
7029: LD_INT 5
7031: PPUSH
7032: CALL_OW 332
// for i = 1 to points do
7036: LD_ADDR_VAR 0 1
7040: PUSH
7041: DOUBLE
7042: LD_INT 1
7044: DEC
7045: ST_TO_ADDR
7046: LD_VAR 0 2
7050: PUSH
7051: FOR_TO
7052: IFFALSE 7227
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7054: LD_VAR 0 2
7058: PUSH
7059: LD_VAR 0 1
7063: ARRAY
7064: PUSH
7065: LD_INT 1
7067: ARRAY
7068: PPUSH
7069: LD_VAR 0 2
7073: PUSH
7074: LD_VAR 0 1
7078: ARRAY
7079: PUSH
7080: LD_INT 2
7082: ARRAY
7083: PPUSH
7084: CALL_OW 84
// if i = 1 then
7088: LD_VAR 0 1
7092: PUSH
7093: LD_INT 1
7095: EQUAL
7096: IFFALSE 7110
// Say ( Lynch , D2-Sol1-4 ) ;
7098: LD_EXP 45
7102: PPUSH
7103: LD_STRING D2-Sol1-4
7105: PPUSH
7106: CALL_OW 88
// if i = 2 then
7110: LD_VAR 0 1
7114: PUSH
7115: LD_INT 2
7117: EQUAL
7118: IFFALSE 7132
// Say ( JMM , D2-JMM-5 ) ;
7120: LD_EXP 35
7124: PPUSH
7125: LD_STRING D2-JMM-5
7127: PPUSH
7128: CALL_OW 88
// if i = 4 then
7132: LD_VAR 0 1
7136: PUSH
7137: LD_INT 4
7139: EQUAL
7140: IFFALSE 7164
// begin RevealFogArea ( 1 , troopsArea ) ;
7142: LD_INT 1
7144: PPUSH
7145: LD_INT 6
7147: PPUSH
7148: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7152: LD_EXP 45
7156: PPUSH
7157: LD_STRING D2-Sol1-5
7159: PPUSH
7160: CALL_OW 88
// end ; if i = 5 then
7164: LD_VAR 0 1
7168: PUSH
7169: LD_INT 5
7171: EQUAL
7172: IFFALSE 7186
// Say ( JMM , D2-JMM-6 ) ;
7174: LD_EXP 35
7178: PPUSH
7179: LD_STRING D2-JMM-6
7181: PPUSH
7182: CALL_OW 88
// if i = 7 then
7186: LD_VAR 0 1
7190: PUSH
7191: LD_INT 7
7193: EQUAL
7194: IFFALSE 7218
// begin RevealFogArea ( 1 , forestArea ) ;
7196: LD_INT 1
7198: PPUSH
7199: LD_INT 7
7201: PPUSH
7202: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7206: LD_EXP 45
7210: PPUSH
7211: LD_STRING D2-Sol1-6
7213: PPUSH
7214: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7218: LD_INT 46
7220: PPUSH
7221: CALL_OW 67
// end ;
7225: GO 7051
7227: POP
7228: POP
// CenterNowOnUnits ( JMM ) ;
7229: LD_EXP 35
7233: PPUSH
7234: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7238: LD_EXP 35
7242: PPUSH
7243: LD_STRING D2-JMM-7
7245: PPUSH
7246: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7250: LD_EXP 45
7254: PPUSH
7255: LD_STRING D2-Sol1-7
7257: PPUSH
7258: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7262: LD_EXP 35
7266: PPUSH
7267: LD_STRING D2-JMM-8
7269: PPUSH
7270: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7274: LD_ADDR_VAR 0 4
7278: PUSH
7279: LD_INT 22
7281: PUSH
7282: LD_INT 1
7284: PUSH
7285: EMPTY
7286: LIST
7287: LIST
7288: PUSH
7289: LD_INT 30
7291: PUSH
7292: LD_INT 31
7294: PUSH
7295: EMPTY
7296: LIST
7297: LIST
7298: PUSH
7299: EMPTY
7300: LIST
7301: LIST
7302: PPUSH
7303: CALL_OW 69
7307: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7308: LD_EXP 45
7312: PPUSH
7313: LD_VAR 0 4
7317: PUSH
7318: LD_INT 1
7320: ARRAY
7321: PPUSH
7322: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7326: LD_INT 65
7328: PPUSH
7329: LD_INT 101
7331: PPUSH
7332: CALL_OW 428
7336: IFFALSE 7359
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7338: LD_INT 65
7340: PPUSH
7341: LD_INT 101
7343: PPUSH
7344: CALL_OW 428
7348: PPUSH
7349: LD_INT 75
7351: PPUSH
7352: LD_INT 100
7354: PPUSH
7355: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7359: LD_INT 66
7361: PPUSH
7362: LD_INT 103
7364: PPUSH
7365: CALL_OW 428
7369: IFFALSE 7392
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7371: LD_INT 66
7373: PPUSH
7374: LD_INT 103
7376: PPUSH
7377: CALL_OW 428
7381: PPUSH
7382: LD_INT 75
7384: PPUSH
7385: LD_INT 100
7387: PPUSH
7388: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7392: LD_ADDR_VAR 0 3
7396: PUSH
7397: LD_EXP 4
7401: PPUSH
7402: LD_INT 25
7404: PUSH
7405: LD_INT 1
7407: PUSH
7408: EMPTY
7409: LIST
7410: LIST
7411: PPUSH
7412: CALL_OW 72
7416: PPUSH
7417: LD_EXP 35
7421: PPUSH
7422: CALL_OW 74
7426: ST_TO_ADDR
// if sol then
7427: LD_VAR 0 3
7431: IFFALSE 7471
// if GetDistUnits ( JMM , sol ) < 10 then
7433: LD_EXP 35
7437: PPUSH
7438: LD_VAR 0 3
7442: PPUSH
7443: CALL_OW 296
7447: PUSH
7448: LD_INT 10
7450: LESS
7451: IFFALSE 7471
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7453: LD_VAR 0 3
7457: PPUSH
7458: LD_VAR 0 4
7462: PUSH
7463: LD_INT 2
7465: ARRAY
7466: PPUSH
7467: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7471: LD_INT 10
7473: PPUSH
7474: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7478: LD_EXP 35
7482: PPUSH
7483: LD_INT 65
7485: PPUSH
7486: LD_INT 101
7488: PPUSH
7489: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7493: LD_EXP 35
7497: PPUSH
7498: LD_INT 63
7500: PPUSH
7501: LD_INT 100
7503: PPUSH
7504: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
7508: LD_INT 35
7510: PPUSH
7511: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
7515: LD_EXP 35
7519: PPUSH
7520: LD_INT 65
7522: PPUSH
7523: LD_INT 101
7525: PPUSH
7526: CALL_OW 307
7530: IFFALSE 7508
// Say ( JMM , D2a-JMM-1 ) ;
7532: LD_EXP 35
7536: PPUSH
7537: LD_STRING D2a-JMM-1
7539: PPUSH
7540: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7544: LD_EXP 46
7548: PPUSH
7549: LD_INT 66
7551: PPUSH
7552: LD_INT 103
7554: PPUSH
7555: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
7559: LD_INT 35
7561: PPUSH
7562: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
7566: LD_EXP 46
7570: PPUSH
7571: LD_INT 66
7573: PPUSH
7574: LD_INT 103
7576: PPUSH
7577: CALL_OW 307
7581: IFFALSE 7559
// ComTurnUnit ( Walker , JMM ) ;
7583: LD_EXP 46
7587: PPUSH
7588: LD_EXP 35
7592: PPUSH
7593: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7597: LD_EXP 46
7601: PPUSH
7602: LD_STRING D2a-Sci1-1
7604: PPUSH
7605: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7609: LD_EXP 35
7613: PPUSH
7614: LD_EXP 46
7618: PPUSH
7619: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7623: LD_EXP 35
7627: PPUSH
7628: LD_STRING D2a-JMM-2
7630: PPUSH
7631: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7635: LD_EXP 46
7639: PPUSH
7640: LD_STRING D2a-Sci1-2
7642: PPUSH
7643: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7647: LD_EXP 35
7651: PPUSH
7652: LD_STRING D2a-JMM-3
7654: PPUSH
7655: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7659: LD_EXP 46
7663: PPUSH
7664: LD_STRING D2a-Sci1-3
7666: PPUSH
7667: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7671: LD_ADDR_EXP 4
7675: PUSH
7676: LD_EXP 4
7680: PUSH
7681: LD_EXP 45
7685: PUSH
7686: LD_EXP 46
7690: PUSH
7691: LD_EXP 47
7695: PUSH
7696: LD_EXP 48
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: ADD
7707: ST_TO_ADDR
// for i in jmm_units do
7708: LD_ADDR_VAR 0 1
7712: PUSH
7713: LD_EXP 4
7717: PUSH
7718: FOR_IN
7719: IFFALSE 7744
// if not IsInUnit ( i ) then
7721: LD_VAR 0 1
7725: PPUSH
7726: CALL_OW 310
7730: NOT
7731: IFFALSE 7742
// ComFree ( i ) ;
7733: LD_VAR 0 1
7737: PPUSH
7738: CALL_OW 139
7742: GO 7718
7744: POP
7745: POP
// InGameOff ;
7746: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
7750: LD_STRING MSolar1
7752: PPUSH
7753: CALL_OW 337
// jmm_on_west := true ;
7757: LD_ADDR_EXP 5
7761: PUSH
7762: LD_INT 1
7764: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7765: LD_INT 1050
7767: PPUSH
7768: CALL_OW 67
// frank_can_return := true ;
7772: LD_ADDR_EXP 12
7776: PUSH
7777: LD_INT 1
7779: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7780: LD_INT 6300
7782: PPUSH
7783: LD_INT 8400
7785: PPUSH
7786: CALL_OW 12
7790: PPUSH
7791: CALL_OW 67
// send_spec_patrol := true ;
7795: LD_ADDR_EXP 28
7799: PUSH
7800: LD_INT 1
7802: ST_TO_ADDR
// end ;
7803: PPOPN 4
7805: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7806: LD_INT 22
7808: PUSH
7809: LD_INT 1
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PUSH
7816: LD_INT 34
7818: PUSH
7819: LD_INT 51
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PUSH
7826: LD_INT 92
7828: PUSH
7829: LD_INT 63
7831: PUSH
7832: LD_INT 100
7834: PUSH
7835: LD_INT 5
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: LIST
7842: LIST
7843: PUSH
7844: EMPTY
7845: LIST
7846: LIST
7847: LIST
7848: PUSH
7849: EMPTY
7850: LIST
7851: PPUSH
7852: CALL_OW 69
7856: PUSH
7857: LD_EXP 5
7861: NOT
7862: AND
7863: IFFALSE 7976
7865: GO 7867
7867: DISABLE
7868: LD_INT 0
7870: PPUSH
7871: PPUSH
// begin enable ;
7872: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
7873: LD_ADDR_VAR 0 2
7877: PUSH
7878: LD_INT 22
7880: PUSH
7881: LD_INT 1
7883: PUSH
7884: EMPTY
7885: LIST
7886: LIST
7887: PUSH
7888: LD_INT 34
7890: PUSH
7891: LD_INT 51
7893: PUSH
7894: EMPTY
7895: LIST
7896: LIST
7897: PUSH
7898: LD_INT 92
7900: PUSH
7901: LD_INT 63
7903: PUSH
7904: LD_INT 100
7906: PUSH
7907: LD_INT 5
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: LIST
7914: LIST
7915: PUSH
7916: EMPTY
7917: LIST
7918: LIST
7919: LIST
7920: PUSH
7921: EMPTY
7922: LIST
7923: PPUSH
7924: CALL_OW 69
7928: ST_TO_ADDR
// if not filter then
7929: LD_VAR 0 2
7933: NOT
7934: IFFALSE 7938
// exit ;
7936: GO 7976
// for i in filter do
7938: LD_ADDR_VAR 0 1
7942: PUSH
7943: LD_VAR 0 2
7947: PUSH
7948: FOR_IN
7949: IFFALSE 7974
// begin SetFuel ( i , 0 ) ;
7951: LD_VAR 0 1
7955: PPUSH
7956: LD_INT 0
7958: PPUSH
7959: CALL_OW 240
// ComStop ( i ) ;
7963: LD_VAR 0 1
7967: PPUSH
7968: CALL_OW 141
// end ;
7972: GO 7948
7974: POP
7975: POP
// end ;
7976: PPOPN 2
7978: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
7979: LD_EXP 28
7983: IFFALSE 8976
7985: GO 7987
7987: DISABLE
7988: LD_INT 0
7990: PPUSH
7991: PPUSH
7992: PPUSH
7993: PPUSH
7994: PPUSH
7995: PPUSH
7996: PPUSH
// begin if not ru_spec_patrol then
7997: LD_EXP 52
8001: NOT
8002: IFFALSE 8006
// exit ;
8004: GO 8976
// dead1 := false ;
8006: LD_ADDR_VAR 0 1
8010: PUSH
8011: LD_INT 0
8013: ST_TO_ADDR
// dead2 := false ;
8014: LD_ADDR_VAR 0 2
8018: PUSH
8019: LD_INT 0
8021: ST_TO_ADDR
// inarea1 := false ;
8022: LD_ADDR_VAR 0 3
8026: PUSH
8027: LD_INT 0
8029: ST_TO_ADDR
// inarea2 := false ;
8030: LD_ADDR_VAR 0 4
8034: PUSH
8035: LD_INT 0
8037: ST_TO_ADDR
// tmp := [ ] ;
8038: LD_ADDR_VAR 0 6
8042: PUSH
8043: EMPTY
8044: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8045: LD_EXP 52
8049: PPUSH
8050: LD_INT 75
8052: PPUSH
8053: LD_INT 101
8055: PPUSH
8056: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8060: LD_INT 35
8062: PPUSH
8063: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8067: LD_INT 1
8069: PPUSH
8070: LD_EXP 52
8074: PUSH
8075: LD_INT 1
8077: ARRAY
8078: PPUSH
8079: CALL_OW 292
8083: IFFALSE 8060
// ComStop ( ru_spec_patrol ) ;
8085: LD_EXP 52
8089: PPUSH
8090: CALL_OW 141
// Wait ( 0 0$02 ) ;
8094: LD_INT 70
8096: PPUSH
8097: CALL_OW 67
// DialogueOn ;
8101: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8105: LD_EXP 52
8109: PUSH
8110: LD_INT 1
8112: ARRAY
8113: PPUSH
8114: LD_STRING D8-Rus1-1
8116: PPUSH
8117: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8121: LD_EXP 35
8125: PPUSH
8126: LD_STRING D8-JMM-1
8128: PPUSH
8129: CALL_OW 88
// DialogueOff ;
8133: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8137: LD_EXP 52
8141: PPUSH
8142: LD_INT 13
8144: PPUSH
8145: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8149: LD_INT 35
8151: PPUSH
8152: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8156: LD_VAR 0 1
8160: NOT
8161: PUSH
8162: LD_EXP 52
8166: PUSH
8167: LD_INT 1
8169: ARRAY
8170: PPUSH
8171: CALL_OW 301
8175: AND
8176: IFFALSE 8186
// dead1 := true ;
8178: LD_ADDR_VAR 0 1
8182: PUSH
8183: LD_INT 1
8185: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8186: LD_VAR 0 2
8190: NOT
8191: PUSH
8192: LD_EXP 52
8196: PUSH
8197: LD_INT 2
8199: ARRAY
8200: PPUSH
8201: CALL_OW 301
8205: AND
8206: IFFALSE 8216
// dead2 := true ;
8208: LD_ADDR_VAR 0 2
8212: PUSH
8213: LD_INT 1
8215: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8216: LD_VAR 0 3
8220: NOT
8221: PUSH
8222: LD_EXP 52
8226: PUSH
8227: LD_INT 1
8229: ARRAY
8230: PPUSH
8231: LD_INT 14
8233: PPUSH
8234: CALL_OW 308
8238: AND
8239: IFFALSE 8249
// inarea1 := true ;
8241: LD_ADDR_VAR 0 3
8245: PUSH
8246: LD_INT 1
8248: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8249: LD_VAR 0 4
8253: NOT
8254: PUSH
8255: LD_EXP 52
8259: PUSH
8260: LD_INT 2
8262: ARRAY
8263: PPUSH
8264: LD_INT 14
8266: PPUSH
8267: CALL_OW 308
8271: AND
8272: IFFALSE 8282
// inarea2 := true ;
8274: LD_ADDR_VAR 0 4
8278: PUSH
8279: LD_INT 1
8281: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8282: LD_VAR 0 1
8286: PUSH
8287: LD_VAR 0 2
8291: AND
8292: PUSH
8293: LD_VAR 0 1
8297: PUSH
8298: LD_VAR 0 4
8302: AND
8303: OR
8304: PUSH
8305: LD_VAR 0 2
8309: PUSH
8310: LD_VAR 0 3
8314: AND
8315: OR
8316: PUSH
8317: LD_VAR 0 3
8321: PUSH
8322: LD_VAR 0 4
8326: AND
8327: OR
8328: IFFALSE 8149
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8330: LD_VAR 0 3
8334: PUSH
8335: LD_VAR 0 4
8339: AND
8340: PUSH
8341: LD_VAR 0 1
8345: PUSH
8346: LD_VAR 0 4
8350: AND
8351: OR
8352: PUSH
8353: LD_VAR 0 2
8357: PUSH
8358: LD_VAR 0 3
8362: AND
8363: OR
8364: IFFALSE 8956
// begin prepare_siege := true ;
8366: LD_ADDR_EXP 29
8370: PUSH
8371: LD_INT 1
8373: ST_TO_ADDR
// DialogueOn ;
8374: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8378: LD_VAR 0 3
8382: PUSH
8383: LD_VAR 0 4
8387: AND
8388: IFFALSE 8404
// Say ( JMM , D8b-JMM-1a ) else
8390: LD_EXP 35
8394: PPUSH
8395: LD_STRING D8b-JMM-1a
8397: PPUSH
8398: CALL_OW 88
8402: GO 8416
// Say ( JMM , D8b-JMM-1 ) ;
8404: LD_EXP 35
8408: PPUSH
8409: LD_STRING D8b-JMM-1
8411: PPUSH
8412: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8416: LD_EXP 4
8420: PPUSH
8421: LD_INT 26
8423: PUSH
8424: LD_INT 1
8426: PUSH
8427: EMPTY
8428: LIST
8429: LIST
8430: PPUSH
8431: CALL_OW 72
8435: PUSH
8436: LD_EXP 36
8440: PUSH
8441: LD_EXP 37
8445: PUSH
8446: LD_EXP 46
8450: PUSH
8451: LD_EXP 49
8455: PUSH
8456: EMPTY
8457: LIST
8458: LIST
8459: LIST
8460: LIST
8461: DIFF
8462: PPUSH
8463: LD_STRING D8b-Sol1-1
8465: PPUSH
8466: CALL 617 0 2
// if Cyrus and Cyrus in jmm_units then
8470: LD_EXP 37
8474: PUSH
8475: LD_EXP 37
8479: PUSH
8480: LD_EXP 4
8484: IN
8485: AND
8486: IFFALSE 8502
// Say ( Cyrus , D8b-Cyrus-1 ) else
8488: LD_EXP 37
8492: PPUSH
8493: LD_STRING D8b-Cyrus-1
8495: PPUSH
8496: CALL_OW 88
8500: GO 8514
// Say ( JMM , D8b-JMM-1a ) ;
8502: LD_EXP 35
8506: PPUSH
8507: LD_STRING D8b-JMM-1a
8509: PPUSH
8510: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8514: LD_EXP 38
8518: PUSH
8519: LD_EXP 38
8523: PUSH
8524: LD_EXP 4
8528: IN
8529: AND
8530: IFFALSE 8544
// Say ( Lisa , D8b-Lisa-2 ) ;
8532: LD_EXP 38
8536: PPUSH
8537: LD_STRING D8b-Lisa-2
8539: PPUSH
8540: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8544: LD_EXP 36
8548: PUSH
8549: LD_EXP 36
8553: PUSH
8554: LD_EXP 4
8558: IN
8559: AND
8560: IFFALSE 8576
// Say ( Bobby , D8b-Bobby-1 ) else
8562: LD_EXP 36
8566: PPUSH
8567: LD_STRING D8b-Bobby-1
8569: PPUSH
8570: CALL_OW 88
8574: GO 8636
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8576: LD_ADDR_VAR 0 5
8580: PUSH
8581: LD_EXP 4
8585: PPUSH
8586: LD_INT 26
8588: PUSH
8589: LD_INT 1
8591: PUSH
8592: EMPTY
8593: LIST
8594: LIST
8595: PPUSH
8596: CALL_OW 72
8600: PUSH
8601: LD_EXP 36
8605: PUSH
8606: LD_EXP 37
8610: PUSH
8611: LD_EXP 46
8615: PUSH
8616: LD_EXP 49
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: LIST
8625: LIST
8626: DIFF
8627: PPUSH
8628: LD_STRING D8b-Sol2-1
8630: PPUSH
8631: CALL 617 0 2
8635: ST_TO_ADDR
// DialogueOff ;
8636: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8640: LD_EXP 37
8644: PUSH
8645: LD_EXP 37
8649: PUSH
8650: LD_EXP 4
8654: IN
8655: AND
8656: IFFALSE 8681
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8658: LD_ADDR_VAR 0 6
8662: PUSH
8663: LD_VAR 0 6
8667: PPUSH
8668: LD_INT 1
8670: PPUSH
8671: LD_EXP 37
8675: PPUSH
8676: CALL_OW 2
8680: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8681: LD_EXP 36
8685: PUSH
8686: LD_EXP 36
8690: PUSH
8691: LD_EXP 4
8695: IN
8696: AND
8697: IFFALSE 8722
// tmp := Insert ( tmp , 1 , Bobby ) ;
8699: LD_ADDR_VAR 0 6
8703: PUSH
8704: LD_VAR 0 6
8708: PPUSH
8709: LD_INT 1
8711: PPUSH
8712: LD_EXP 36
8716: PPUSH
8717: CALL_OW 2
8721: ST_TO_ADDR
// if sol then
8722: LD_VAR 0 5
8726: IFFALSE 8751
// tmp := Insert ( tmp , 1 , sol ) ;
8728: LD_ADDR_VAR 0 6
8732: PUSH
8733: LD_VAR 0 6
8737: PPUSH
8738: LD_INT 1
8740: PPUSH
8741: LD_VAR 0 5
8745: PPUSH
8746: CALL_OW 2
8750: ST_TO_ADDR
// if tmp then
8751: LD_VAR 0 6
8755: IFFALSE 8915
// begin SetSide ( tmp , 8 ) ;
8757: LD_VAR 0 6
8761: PPUSH
8762: LD_INT 8
8764: PPUSH
8765: CALL_OW 235
// ComFree ( tmp ) ;
8769: LD_VAR 0 6
8773: PPUSH
8774: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8778: LD_VAR 0 6
8782: PPUSH
8783: LD_INT 15
8785: PPUSH
8786: CALL_OW 173
// AddComHold ( tmp ) ;
8790: LD_VAR 0 6
8794: PPUSH
8795: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8799: LD_INT 35
8801: PPUSH
8802: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
8806: LD_VAR 0 6
8810: PUSH
8811: LD_INT 1
8813: ARRAY
8814: PPUSH
8815: CALL_OW 314
8819: NOT
8820: IFFALSE 8834
// ComMoveToArea ( tmp , cyrusEscape ) ;
8822: LD_VAR 0 6
8826: PPUSH
8827: LD_INT 15
8829: PPUSH
8830: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8834: LD_VAR 0 6
8838: PUSH
8839: LD_INT 1
8841: ARRAY
8842: PPUSH
8843: LD_INT 15
8845: PPUSH
8846: CALL_OW 308
8850: IFFALSE 8905
// begin RemoveUnit ( tmp [ 1 ] ) ;
8852: LD_VAR 0 6
8856: PUSH
8857: LD_INT 1
8859: ARRAY
8860: PPUSH
8861: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
8865: LD_ADDR_EXP 4
8869: PUSH
8870: LD_EXP 4
8874: PUSH
8875: LD_VAR 0 6
8879: PUSH
8880: LD_INT 1
8882: ARRAY
8883: DIFF
8884: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
8885: LD_ADDR_VAR 0 6
8889: PUSH
8890: LD_VAR 0 6
8894: PUSH
8895: LD_VAR 0 6
8899: PUSH
8900: LD_INT 1
8902: ARRAY
8903: DIFF
8904: ST_TO_ADDR
// end ; until tmp = 0 ;
8905: LD_VAR 0 6
8909: PUSH
8910: LD_INT 0
8912: EQUAL
8913: IFFALSE 8799
// end ; Wait ( 0 0$30 ) ;
8915: LD_INT 1050
8917: PPUSH
8918: CALL_OW 67
// if ru_spec_patrol then
8922: LD_EXP 52
8926: IFFALSE 8954
// for i in ru_spec_patrol do
8928: LD_ADDR_VAR 0 7
8932: PUSH
8933: LD_EXP 52
8937: PUSH
8938: FOR_IN
8939: IFFALSE 8952
// RemoveUnit ( i ) ;
8941: LD_VAR 0 7
8945: PPUSH
8946: CALL_OW 64
8950: GO 8938
8952: POP
8953: POP
// end else
8954: GO 8976
// begin prepare_siege := false ;
8956: LD_ADDR_EXP 29
8960: PUSH
8961: LD_INT 0
8963: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
8964: LD_EXP 35
8968: PPUSH
8969: LD_STRING D8a-JMM-1
8971: PPUSH
8972: CALL_OW 88
// end ; end ;
8976: PPOPN 7
8978: END
// every 0 0$10 trigger frank_can_return do var i , points ;
8979: LD_EXP 12
8983: IFFALSE 10117
8985: GO 8987
8987: DISABLE
8988: LD_INT 0
8990: PPUSH
8991: PPUSH
// begin uc_side := 8 ;
8992: LD_ADDR_OWVAR 20
8996: PUSH
8997: LD_INT 8
8999: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
9000: LD_ADDR_VAR 0 2
9004: PUSH
9005: LD_INT 59
9007: PUSH
9008: LD_INT 71
9010: PUSH
9011: EMPTY
9012: LIST
9013: LIST
9014: PUSH
9015: LD_INT 122
9017: PUSH
9018: LD_INT 117
9020: PUSH
9021: EMPTY
9022: LIST
9023: LIST
9024: PUSH
9025: EMPTY
9026: LIST
9027: LIST
9028: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9029: LD_ADDR_EXP 49
9033: PUSH
9034: LD_STRING Frank
9036: PPUSH
9037: LD_INT 0
9039: PPUSH
9040: CALL 466 0 2
9044: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9045: LD_ADDR_VAR 0 1
9049: PUSH
9050: LD_INT 1
9052: PPUSH
9053: LD_INT 2
9055: PPUSH
9056: CALL_OW 12
9060: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9061: LD_EXP 49
9065: PPUSH
9066: LD_VAR 0 2
9070: PUSH
9071: LD_VAR 0 1
9075: ARRAY
9076: PUSH
9077: LD_INT 1
9079: ARRAY
9080: PPUSH
9081: LD_VAR 0 2
9085: PUSH
9086: LD_VAR 0 1
9090: ARRAY
9091: PUSH
9092: LD_INT 2
9094: ARRAY
9095: PPUSH
9096: LD_INT 0
9098: PPUSH
9099: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9103: LD_EXP 49
9107: PPUSH
9108: LD_INT 1
9110: PPUSH
9111: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9115: LD_INT 35
9117: PPUSH
9118: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
9122: LD_EXP 49
9126: PPUSH
9127: LD_EXP 35
9131: PPUSH
9132: CALL_OW 296
9136: PUSH
9137: LD_INT 8
9139: LESS
9140: IFFALSE 9115
// InGameOn ;
9142: CALL_OW 8
// CenterOnUnits ( JMM ) ;
9146: LD_EXP 35
9150: PPUSH
9151: CALL_OW 85
// if IsInUnit ( JMM ) then
9155: LD_EXP 35
9159: PPUSH
9160: CALL_OW 310
9164: IFFALSE 9175
// ComFree ( JMM ) ;
9166: LD_EXP 35
9170: PPUSH
9171: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9175: LD_EXP 35
9179: PPUSH
9180: LD_EXP 49
9184: PPUSH
9185: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9189: LD_EXP 49
9193: PPUSH
9194: LD_EXP 35
9198: PPUSH
9199: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9203: LD_EXP 35
9207: PPUSH
9208: LD_STRING D6-JMM-1
9210: PPUSH
9211: CALL_OW 88
// repeat wait ( 3 ) ;
9215: LD_INT 3
9217: PPUSH
9218: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
9222: LD_EXP 35
9226: PPUSH
9227: LD_EXP 49
9231: PPUSH
9232: CALL_OW 296
9236: PUSH
9237: LD_INT 8
9239: LESS
9240: IFFALSE 9215
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9242: LD_EXP 38
9246: PUSH
9247: LD_EXP 38
9251: PPUSH
9252: LD_EXP 49
9256: PPUSH
9257: CALL_OW 296
9261: PUSH
9262: LD_INT 20
9264: LESS
9265: AND
9266: IFFALSE 9291
// begin ComFree ( Lisa ) ;
9268: LD_EXP 38
9272: PPUSH
9273: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9277: LD_EXP 38
9281: PPUSH
9282: LD_EXP 49
9286: PPUSH
9287: CALL_OW 172
// end ; if Lynch then
9291: LD_EXP 45
9295: IFFALSE 9320
// begin ComFree ( Lynch ) ;
9297: LD_EXP 45
9301: PPUSH
9302: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9306: LD_EXP 45
9310: PPUSH
9311: LD_EXP 49
9315: PPUSH
9316: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9320: LD_EXP 35
9324: PPUSH
9325: LD_EXP 49
9329: PPUSH
9330: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9334: LD_EXP 49
9338: PPUSH
9339: LD_EXP 35
9343: PPUSH
9344: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9348: LD_EXP 49
9352: PPUSH
9353: LD_STRING D6-Frank-1
9355: PPUSH
9356: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9360: LD_INT 69
9362: PPUSH
9363: LD_INT 20
9365: PPUSH
9366: LD_INT 1
9368: PPUSH
9369: LD_INT 20
9371: NEG
9372: PPUSH
9373: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9377: LD_INT 69
9379: PPUSH
9380: LD_INT 20
9382: PPUSH
9383: LD_INT 1
9385: PPUSH
9386: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9390: LD_INT 190
9392: PPUSH
9393: LD_INT 31
9395: PPUSH
9396: LD_INT 1
9398: PPUSH
9399: LD_INT 20
9401: NEG
9402: PPUSH
9403: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9407: LD_INT 190
9409: PPUSH
9410: LD_INT 31
9412: PPUSH
9413: LD_INT 1
9415: PPUSH
9416: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9420: LD_INT 69
9422: PPUSH
9423: LD_INT 20
9425: PPUSH
9426: CALL_OW 84
// Wait ( 0 0$02 ) ;
9430: LD_INT 70
9432: PPUSH
9433: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9437: LD_EXP 35
9441: PPUSH
9442: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9446: LD_EXP 38
9450: PUSH
9451: LD_EXP 38
9455: PPUSH
9456: LD_EXP 49
9460: PPUSH
9461: CALL_OW 296
9465: PUSH
9466: LD_INT 20
9468: LESS
9469: AND
9470: PUSH
9471: LD_EXP 38
9475: PPUSH
9476: CALL_OW 302
9480: AND
9481: IFFALSE 9571
// begin ComFree ( Lisa ) ;
9483: LD_EXP 38
9487: PPUSH
9488: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
9492: LD_INT 35
9494: PPUSH
9495: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
9499: LD_EXP 38
9503: PPUSH
9504: LD_EXP 49
9508: PPUSH
9509: CALL_OW 296
9513: PUSH
9514: LD_INT 7
9516: LESS
9517: IFFALSE 9492
// Say ( Lisa , D6-Lisa-1 ) ;
9519: LD_EXP 38
9523: PPUSH
9524: LD_STRING D6-Lisa-1
9526: PPUSH
9527: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9531: LD_EXP 38
9535: PPUSH
9536: LD_EXP 49
9540: PPUSH
9541: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9545: LD_EXP 49
9549: PPUSH
9550: LD_EXP 38
9554: PPUSH
9555: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9559: LD_EXP 49
9563: PPUSH
9564: LD_STRING D6-Frank-2
9566: PPUSH
9567: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9571: LD_EXP 45
9575: PUSH
9576: LD_EXP 45
9580: PPUSH
9581: LD_EXP 49
9585: PPUSH
9586: CALL_OW 296
9590: PUSH
9591: LD_INT 20
9593: LESS
9594: AND
9595: PUSH
9596: LD_EXP 45
9600: PPUSH
9601: CALL_OW 302
9605: AND
9606: IFFALSE 9787
// begin ComTurnUnit ( Lynch , JMM ) ;
9608: LD_EXP 45
9612: PPUSH
9613: LD_EXP 35
9617: PPUSH
9618: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9622: LD_EXP 49
9626: PPUSH
9627: LD_EXP 35
9631: PPUSH
9632: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9636: LD_EXP 45
9640: PPUSH
9641: LD_STRING D6-Sol1-2
9643: PPUSH
9644: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9648: LD_EXP 35
9652: PPUSH
9653: LD_STRING D6-JMM-2
9655: PPUSH
9656: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9660: LD_EXP 49
9664: PPUSH
9665: LD_STRING D6-Frank-3
9667: PPUSH
9668: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9672: LD_EXP 35
9676: PPUSH
9677: LD_STRING D6-JMM-3
9679: PPUSH
9680: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9684: LD_EXP 49
9688: PPUSH
9689: LD_STRING D6-Frank-4
9691: PPUSH
9692: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9696: LD_EXP 49
9700: PPUSH
9701: LD_STRING D6-Frank-4a
9703: PPUSH
9704: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9708: LD_EXP 35
9712: PPUSH
9713: LD_STRING D6-JMM-4
9715: PPUSH
9716: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9720: LD_EXP 49
9724: PPUSH
9725: LD_STRING D6-Frank-5
9727: PPUSH
9728: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9732: LD_EXP 38
9736: PUSH
9737: LD_EXP 38
9741: PPUSH
9742: CALL_OW 302
9746: AND
9747: IFFALSE 9761
// Say ( Lisa , D6-Lisa-5 ) ;
9749: LD_EXP 38
9753: PPUSH
9754: LD_STRING D6-Lisa-5
9756: PPUSH
9757: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9761: LD_EXP 49
9765: PPUSH
9766: LD_STRING D6-Frank-6
9768: PPUSH
9769: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9773: LD_EXP 35
9777: PPUSH
9778: LD_STRING D6-JMM-6
9780: PPUSH
9781: CALL_OW 88
// end else
9785: GO 9902
// begin ComTurnUnit ( Frank , JMM ) ;
9787: LD_EXP 49
9791: PPUSH
9792: LD_EXP 35
9796: PPUSH
9797: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
9801: LD_EXP 49
9805: PPUSH
9806: LD_STRING D6-Frank-4
9808: PPUSH
9809: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9813: LD_EXP 49
9817: PPUSH
9818: LD_STRING D6-Frank-4a
9820: PPUSH
9821: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9825: LD_EXP 35
9829: PPUSH
9830: LD_STRING D6-JMM-4
9832: PPUSH
9833: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9837: LD_EXP 49
9841: PPUSH
9842: LD_STRING D6-Frank-5
9844: PPUSH
9845: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9849: LD_EXP 38
9853: PUSH
9854: LD_EXP 38
9858: PPUSH
9859: CALL_OW 302
9863: AND
9864: IFFALSE 9878
// Say ( Lisa , D6-Lisa-5 ) ;
9866: LD_EXP 38
9870: PPUSH
9871: LD_STRING D6-Lisa-5
9873: PPUSH
9874: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9878: LD_EXP 49
9882: PPUSH
9883: LD_STRING D6-Frank-6
9885: PPUSH
9886: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9890: LD_EXP 35
9894: PPUSH
9895: LD_STRING D6-JMM-6
9897: PPUSH
9898: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
9902: LD_STRING Q1
9904: PPUSH
9905: CALL_OW 97
9909: PUSH
9910: LD_INT 1
9912: DOUBLE
9913: EQUAL
9914: IFTRUE 9918
9916: GO 9929
9918: POP
// frank_send_to_scout := true ; 2 :
9919: LD_ADDR_EXP 14
9923: PUSH
9924: LD_INT 1
9926: ST_TO_ADDR
9927: GO 9949
9929: LD_INT 2
9931: DOUBLE
9932: EQUAL
9933: IFTRUE 9937
9935: GO 9948
9937: POP
// frank_send_to_scout := false ; end ;
9938: LD_ADDR_EXP 14
9942: PUSH
9943: LD_INT 0
9945: ST_TO_ADDR
9946: GO 9949
9948: POP
// InGameOff ;
9949: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
9953: LD_EXP 35
9957: PUSH
9958: LD_EXP 38
9962: PUSH
9963: LD_EXP 45
9967: PUSH
9968: EMPTY
9969: LIST
9970: LIST
9971: LIST
9972: PPUSH
9973: CALL_OW 139
// if frank_send_to_scout then
9977: LD_EXP 14
9981: IFFALSE 10038
// begin ComMoveXY ( Frank , 130 , 123 ) ;
9983: LD_EXP 49
9987: PPUSH
9988: LD_INT 130
9990: PPUSH
9991: LD_INT 123
9993: PPUSH
9994: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
9998: LD_INT 35
10000: PPUSH
10001: CALL_OW 67
// until not See ( 1 , Frank ) ;
10005: LD_INT 1
10007: PPUSH
10008: LD_EXP 49
10012: PPUSH
10013: CALL_OW 292
10017: NOT
10018: IFFALSE 9998
// Wait ( 0 0$02 ) ;
10020: LD_INT 70
10022: PPUSH
10023: CALL_OW 67
// RemoveUnit ( Frank ) ;
10027: LD_EXP 49
10031: PPUSH
10032: CALL_OW 64
// end else
10036: GO 10050
// SetSide ( Frank , 1 ) ;
10038: LD_EXP 49
10042: PPUSH
10043: LD_INT 1
10045: PPUSH
10046: CALL_OW 235
// send_attack_on_cornel_base := true ;
10050: LD_ADDR_EXP 25
10054: PUSH
10055: LD_INT 1
10057: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10058: LD_INT 35
10060: PPUSH
10061: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10065: LD_ADDR_EXP 27
10069: PUSH
10070: LD_EXP 27
10074: PPUSH
10075: LD_STRING -
10077: PPUSH
10078: CALL 1109 0 2
10082: ST_TO_ADDR
// if debug then
10083: LD_EXP 1
10087: IFFALSE 10099
// debug_strings := time_to_prepare ;
10089: LD_ADDR_OWVAR 48
10093: PUSH
10094: LD_EXP 27
10098: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10099: LD_EXP 27
10103: PUSH
10104: LD_INT 0
10106: EQUAL
10107: IFFALSE 10058
// cornel_prepared := true ;
10109: LD_ADDR_EXP 11
10113: PUSH
10114: LD_INT 1
10116: ST_TO_ADDR
// end ;
10117: PPOPN 2
10119: END
// every 0 0$01 trigger cornel_prepared do
10120: LD_EXP 11
10124: IFFALSE 10381
10126: GO 10128
10128: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10129: LD_EXP 42
10133: PPUSH
10134: LD_STRING D3-Corn-1
10136: PPUSH
10137: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10141: LD_INT 35
10143: PPUSH
10144: CALL_OW 67
// until cornel_counter = 0 ;
10148: LD_EXP 10
10152: PUSH
10153: LD_INT 0
10155: EQUAL
10156: IFFALSE 10141
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10158: LD_EXP 42
10162: PPUSH
10163: LD_STRING D3a-Corn-1
10165: PPUSH
10166: CALL_OW 94
// if IsOk ( Cornel ) then
10170: LD_EXP 42
10174: PPUSH
10175: CALL_OW 302
10179: IFFALSE 10193
// Say ( JMM , D3a-JMM-1 ) ;
10181: LD_EXP 35
10185: PPUSH
10186: LD_STRING D3a-JMM-1
10188: PPUSH
10189: CALL_OW 88
// end_mission_allowed := true ;
10193: LD_ADDR_EXP 20
10197: PUSH
10198: LD_INT 1
10200: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10201: LD_STRING M2
10203: PPUSH
10204: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10208: LD_INT 9
10210: PPUSH
10211: LD_INT 1
10213: PPUSH
10214: CALL_OW 424
// Wait ( 0 0$05 ) ;
10218: LD_INT 175
10220: PPUSH
10221: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10225: LD_EXP 42
10229: PPUSH
10230: LD_STRING D3a-Corn-2
10232: PPUSH
10233: CALL_OW 94
// cornel_attack := true ;
10237: LD_ADDR_EXP 9
10241: PUSH
10242: LD_INT 1
10244: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10245: LD_INT 105
10247: PPUSH
10248: CALL_OW 67
// AddMoreTanks ( ) ;
10252: CALL 4826 0 0
// if frank_send_to_scout then
10256: LD_EXP 14
10260: IFFALSE 10381
// begin InitHc ;
10262: CALL_OW 19
// InitUc ;
10266: CALL_OW 18
// uc_side := 8 ;
10270: LD_ADDR_OWVAR 20
10274: PUSH
10275: LD_INT 8
10277: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10278: LD_ADDR_EXP 49
10282: PUSH
10283: LD_STRING Frank
10285: PPUSH
10286: LD_INT 0
10288: PPUSH
10289: CALL 466 0 2
10293: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10294: LD_EXP 49
10298: PPUSH
10299: LD_INT 6
10301: PPUSH
10302: LD_INT 9
10304: PPUSH
10305: LD_INT 0
10307: PPUSH
10308: CALL_OW 48
// ComCrawl ( Frank ) ;
10312: LD_EXP 49
10316: PPUSH
10317: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
10321: LD_INT 35
10323: PPUSH
10324: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
10328: LD_EXP 35
10332: PPUSH
10333: LD_EXP 49
10337: PPUSH
10338: CALL_OW 296
10342: PUSH
10343: LD_INT 9
10345: LESS
10346: IFFALSE 10321
// SetSide ( Frank , 1 ) ;
10348: LD_EXP 49
10352: PPUSH
10353: LD_INT 1
10355: PPUSH
10356: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10360: LD_EXP 49
10364: PPUSH
10365: LD_STRING D6a-Frank-1
10367: PPUSH
10368: CALL_OW 88
// ComWalk ( Frank ) ;
10372: LD_EXP 49
10376: PPUSH
10377: CALL_OW 138
// end ; end ;
10381: END
// every 0 0$01 trigger solar_builded do
10382: LD_EXP 13
10386: IFFALSE 10490
10388: GO 10390
10390: DISABLE
// begin Wait ( 0 0$02 ) ;
10391: LD_INT 70
10393: PPUSH
10394: CALL_OW 67
// DialogueOn ;
10398: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10402: LD_EXP 35
10406: PPUSH
10407: LD_STRING D2b-JMM-1
10409: PPUSH
10410: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10414: LD_EXP 46
10418: PUSH
10419: LD_EXP 46
10423: PPUSH
10424: CALL_OW 302
10428: AND
10429: IFFALSE 10479
// begin Say ( Walker , D2b-Sci1-1 ) ;
10431: LD_EXP 46
10435: PPUSH
10436: LD_STRING D2b-Sci1-1
10438: PPUSH
10439: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10443: LD_EXP 35
10447: PPUSH
10448: LD_STRING D2b-JMM-2
10450: PPUSH
10451: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10455: LD_EXP 46
10459: PPUSH
10460: LD_STRING D2b-Sci1-2
10462: PPUSH
10463: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10467: LD_EXP 35
10471: PPUSH
10472: LD_STRING D2b-JMM-3
10474: PPUSH
10475: CALL_OW 88
// end ; DialogueOff ;
10479: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10483: LD_STRING MOutSol
10485: PPUSH
10486: CALL_OW 337
// end ;
10490: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10491: LD_EXP 13
10495: PUSH
10496: LD_EXP 35
10500: PPUSH
10501: CALL_OW 302
10505: AND
10506: PUSH
10507: LD_EXP 35
10511: PPUSH
10512: CALL 943 0 1
10516: AND
10517: PUSH
10518: LD_EXP 15
10522: NOT
10523: AND
10524: IFFALSE 10595
10526: GO 10528
10528: DISABLE
10529: LD_INT 0
10531: PPUSH
// begin jmm_in_veh := true ;
10532: LD_ADDR_EXP 15
10536: PUSH
10537: LD_INT 1
10539: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10540: LD_ADDR_VAR 0 1
10544: PUSH
10545: LD_INT 0
10547: PPUSH
10548: LD_INT 1
10550: PPUSH
10551: CALL_OW 12
10555: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10556: LD_INT 70
10558: PPUSH
10559: CALL_OW 67
// if i then
10563: LD_VAR 0 1
10567: IFFALSE 10583
// Say ( JMM , D2c-JMM-1 ) else
10569: LD_EXP 35
10573: PPUSH
10574: LD_STRING D2c-JMM-1
10576: PPUSH
10577: CALL_OW 88
10581: GO 10595
// Say ( JMM , D2c-JMM-1a ) ;
10583: LD_EXP 35
10587: PPUSH
10588: LD_STRING D2c-JMM-1a
10590: PPUSH
10591: CALL_OW 88
// end ;
10595: PPOPN 1
10597: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10598: LD_EXP 13
10602: PUSH
10603: LD_EXP 36
10607: PPUSH
10608: CALL_OW 302
10612: AND
10613: PUSH
10614: LD_EXP 36
10618: PPUSH
10619: CALL 943 0 1
10623: AND
10624: PUSH
10625: LD_EXP 16
10629: NOT
10630: AND
10631: IFFALSE 10663
10633: GO 10635
10635: DISABLE
// begin bobby_in_veh := true ;
10636: LD_ADDR_EXP 16
10640: PUSH
10641: LD_INT 1
10643: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10644: LD_INT 70
10646: PPUSH
10647: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10651: LD_EXP 36
10655: PPUSH
10656: LD_STRING D2c-Bobby-1
10658: PPUSH
10659: CALL_OW 88
10663: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10664: LD_EXP 13
10668: PUSH
10669: LD_EXP 38
10673: PPUSH
10674: CALL_OW 302
10678: AND
10679: PUSH
10680: LD_EXP 38
10684: PPUSH
10685: CALL 943 0 1
10689: AND
10690: PUSH
10691: LD_EXP 18
10695: NOT
10696: AND
10697: IFFALSE 10729
10699: GO 10701
10701: DISABLE
// begin lisa_in_veh := true ;
10702: LD_ADDR_EXP 18
10706: PUSH
10707: LD_INT 1
10709: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10710: LD_INT 70
10712: PPUSH
10713: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10717: LD_EXP 38
10721: PPUSH
10722: LD_STRING D2c-Lisa-1
10724: PPUSH
10725: CALL_OW 88
10729: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
10730: LD_EXP 13
10734: PUSH
10735: LD_EXP 37
10739: PPUSH
10740: CALL_OW 302
10744: AND
10745: PUSH
10746: LD_EXP 37
10750: PPUSH
10751: CALL 943 0 1
10755: AND
10756: PUSH
10757: LD_EXP 17
10761: NOT
10762: AND
10763: IFFALSE 10834
10765: GO 10767
10767: DISABLE
10768: LD_INT 0
10770: PPUSH
// begin cyrus_in_veh := true ;
10771: LD_ADDR_EXP 17
10775: PUSH
10776: LD_INT 1
10778: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10779: LD_ADDR_VAR 0 1
10783: PUSH
10784: LD_INT 0
10786: PPUSH
10787: LD_INT 1
10789: PPUSH
10790: CALL_OW 12
10794: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10795: LD_INT 70
10797: PPUSH
10798: CALL_OW 67
// if i then
10802: LD_VAR 0 1
10806: IFFALSE 10822
// Say ( Cyrus , D2c-Cyrus-1 ) else
10808: LD_EXP 37
10812: PPUSH
10813: LD_STRING D2c-Cyrus-1
10815: PPUSH
10816: CALL_OW 88
10820: GO 10834
// Say ( Cyrus , D2c-Cyrus-1a ) ;
10822: LD_EXP 37
10826: PPUSH
10827: LD_STRING D2c-Cyrus-1a
10829: PPUSH
10830: CALL_OW 88
// end ;
10834: PPOPN 1
10836: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
10837: LD_EXP 42
10841: PPUSH
10842: LD_INT 16
10844: PPUSH
10845: CALL_OW 308
10849: IFFALSE 11105
10851: GO 10853
10853: DISABLE
10854: LD_INT 0
10856: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
10857: LD_INT 3
10859: PPUSH
10860: LD_EXP 42
10864: PPUSH
10865: CALL_OW 471
// send_attack_on_cornel := true ;
10869: LD_ADDR_EXP 30
10873: PUSH
10874: LD_INT 1
10876: ST_TO_ADDR
// if ru_vehicles then
10877: LD_EXP 54
10881: IFFALSE 10915
// for i in ru_vehicles do
10883: LD_ADDR_VAR 0 1
10887: PUSH
10888: LD_EXP 54
10892: PUSH
10893: FOR_IN
10894: IFFALSE 10913
// ComAgressiveMove ( i , 215 , 69 ) ;
10896: LD_VAR 0 1
10900: PPUSH
10901: LD_INT 215
10903: PPUSH
10904: LD_INT 69
10906: PPUSH
10907: CALL_OW 114
10911: GO 10893
10913: POP
10914: POP
// if ru_patrol then
10915: LD_EXP 51
10919: IFFALSE 10953
// for i in ru_patrol do
10921: LD_ADDR_VAR 0 1
10925: PUSH
10926: LD_EXP 51
10930: PUSH
10931: FOR_IN
10932: IFFALSE 10951
// ComAgressiveMove ( i , 215 , 69 ) ;
10934: LD_VAR 0 1
10938: PPUSH
10939: LD_INT 215
10941: PPUSH
10942: LD_INT 69
10944: PPUSH
10945: CALL_OW 114
10949: GO 10931
10951: POP
10952: POP
// if frank_send_to_scout then
10953: LD_EXP 14
10957: IFFALSE 10971
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
10959: LD_EXP 49
10963: PPUSH
10964: LD_STRING D3b-Frank-1
10966: PPUSH
10967: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
10971: LD_INT 105
10973: PPUSH
10974: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
10978: LD_EXP 42
10982: PPUSH
10983: LD_STRING D4-Corn-1
10985: PPUSH
10986: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10990: LD_INT 35
10992: PPUSH
10993: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 6 ;
10997: LD_INT 22
10999: PUSH
11000: LD_INT 4
11002: PUSH
11003: EMPTY
11004: LIST
11005: LIST
11006: PUSH
11007: LD_INT 21
11009: PUSH
11010: LD_INT 1
11012: PUSH
11013: EMPTY
11014: LIST
11015: LIST
11016: PUSH
11017: LD_INT 50
11019: PUSH
11020: EMPTY
11021: LIST
11022: PUSH
11023: EMPTY
11024: LIST
11025: LIST
11026: LIST
11027: PPUSH
11028: CALL_OW 69
11032: PUSH
11033: LD_INT 6
11035: LESS
11036: IFFALSE 10990
// SayRadio ( Cornel , D5-Corn-1 ) ;
11038: LD_EXP 42
11042: PPUSH
11043: LD_STRING D5-Corn-1
11045: PPUSH
11046: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11050: LD_EXP 42
11054: PPUSH
11055: LD_EXP 2
11059: PUSH
11060: LD_STRING Cornel
11062: STR
11063: PPUSH
11064: CALL_OW 38
// ChangeSideFog ( 4 , 8 ) ;
11068: LD_INT 4
11070: PPUSH
11071: LD_INT 8
11073: PPUSH
11074: CALL_OW 343
// Wait ( 0 0$01 ) ;
11078: LD_INT 35
11080: PPUSH
11081: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11085: LD_INT 3
11087: PPUSH
11088: LD_EXP 42
11092: PPUSH
11093: CALL_OW 472
// send_attack_on_cornel := false ;
11097: LD_ADDR_EXP 30
11101: PUSH
11102: LD_INT 0
11104: ST_TO_ADDR
// end ;
11105: PPOPN 1
11107: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11108: LD_INT 9
11110: PPUSH
11111: LD_INT 22
11113: PUSH
11114: LD_INT 1
11116: PUSH
11117: EMPTY
11118: LIST
11119: LIST
11120: PPUSH
11121: CALL_OW 70
11125: PUSH
11126: LD_EXP 31
11130: OR
11131: IFFALSE 11313
11133: GO 11135
11135: DISABLE
11136: LD_INT 0
11138: PPUSH
11139: PPUSH
// begin enable ;
11140: ENABLE
// if not jmm_on_west then
11141: LD_EXP 5
11145: NOT
11146: IFFALSE 11157
// begin YouLost ( 4 ) ;
11148: LD_STRING 4
11150: PPUSH
11151: CALL_OW 104
// exit ;
11155: GO 11313
// end ; if not game_end then
11157: LD_EXP 31
11161: NOT
11162: IFFALSE 11172
// game_end := true ;
11164: LD_ADDR_EXP 31
11168: PUSH
11169: LD_INT 1
11171: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11172: LD_ADDR_VAR 0 2
11176: PUSH
11177: LD_INT 9
11179: PPUSH
11180: LD_INT 22
11182: PUSH
11183: LD_INT 1
11185: PUSH
11186: EMPTY
11187: LIST
11188: LIST
11189: PPUSH
11190: CALL_OW 70
11194: ST_TO_ADDR
// if not filter then
11195: LD_VAR 0 2
11199: NOT
11200: IFFALSE 11204
// exit ;
11202: GO 11313
// for i in filter do
11204: LD_ADDR_VAR 0 1
11208: PUSH
11209: LD_VAR 0 2
11213: PUSH
11214: FOR_IN
11215: IFFALSE 11311
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
11217: LD_VAR 0 1
11221: PPUSH
11222: CALL_OW 302
11226: PUSH
11227: LD_VAR 0 1
11231: PPUSH
11232: CALL_OW 247
11236: PUSH
11237: LD_INT 2
11239: EQUAL
11240: AND
11241: IFFALSE 11274
// begin veh_on_meta := true ;
11243: LD_ADDR_EXP 26
11247: PUSH
11248: LD_INT 1
11250: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11251: LD_VAR 0 1
11255: PPUSH
11256: CALL_OW 311
11260: PPUSH
11261: CALL 11316 0 1
// RemoveUnit ( i ) ;
11265: LD_VAR 0 1
11269: PPUSH
11270: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11274: LD_VAR 0 1
11278: PPUSH
11279: CALL_OW 302
11283: PUSH
11284: LD_VAR 0 1
11288: PPUSH
11289: CALL_OW 247
11293: PUSH
11294: LD_INT 1
11296: EQUAL
11297: AND
11298: IFFALSE 11309
// Save ( i ) ;
11300: LD_VAR 0 1
11304: PPUSH
11305: CALL 11316 0 1
// end ;
11309: GO 11214
11311: POP
11312: POP
// end ;
11313: PPOPN 2
11315: END
// export function Save ( i ) ; begin
11316: LD_INT 0
11318: PPUSH
// save_counter := save_counter + 1 ;
11319: LD_ADDR_EXP 34
11323: PUSH
11324: LD_EXP 34
11328: PUSH
11329: LD_INT 1
11331: PLUS
11332: ST_TO_ADDR
// if i = JMM then
11333: LD_VAR 0 1
11337: PUSH
11338: LD_EXP 35
11342: EQUAL
11343: IFFALSE 11465
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11345: LD_EXP 23
11349: PUSH
11350: LD_INT 22
11352: PUSH
11353: LD_INT 1
11355: PUSH
11356: EMPTY
11357: LIST
11358: LIST
11359: PUSH
11360: LD_INT 21
11362: PUSH
11363: LD_INT 1
11365: PUSH
11366: EMPTY
11367: LIST
11368: LIST
11369: PUSH
11370: EMPTY
11371: LIST
11372: LIST
11373: PPUSH
11374: CALL_OW 69
11378: PUSH
11379: LD_INT 1
11381: GREATER
11382: AND
11383: IFFALSE 11440
// begin show_query := false ;
11385: LD_ADDR_EXP 23
11389: PUSH
11390: LD_INT 0
11392: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11393: LD_STRING Q2
11395: PPUSH
11396: CALL_OW 97
11400: PUSH
11401: LD_INT 1
11403: DOUBLE
11404: EQUAL
11405: IFTRUE 11409
11407: GO 11420
11409: POP
// wait_for_them := true ; 2 :
11410: LD_ADDR_EXP 24
11414: PUSH
11415: LD_INT 1
11417: ST_TO_ADDR
11418: GO 11440
11420: LD_INT 2
11422: DOUBLE
11423: EQUAL
11424: IFTRUE 11428
11426: GO 11439
11428: POP
// wait_for_them := false ; end ;
11429: LD_ADDR_EXP 24
11433: PUSH
11434: LD_INT 0
11436: ST_TO_ADDR
11437: GO 11440
11439: POP
// end ; save_group := save_group ^ JMM ;
11440: LD_ADDR_EXP 22
11444: PUSH
11445: LD_EXP 22
11449: PUSH
11450: LD_EXP 35
11454: ADD
11455: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11456: LD_EXP 35
11460: PPUSH
11461: CALL_OW 64
// end ; if i = Lisa then
11465: LD_VAR 0 1
11469: PUSH
11470: LD_EXP 38
11474: EQUAL
11475: IFFALSE 11502
// begin save_group := save_group ^ Lisa ;
11477: LD_ADDR_EXP 22
11481: PUSH
11482: LD_EXP 22
11486: PUSH
11487: LD_EXP 38
11491: ADD
11492: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11493: LD_EXP 38
11497: PPUSH
11498: CALL_OW 64
// end ; if i = Bobby then
11502: LD_VAR 0 1
11506: PUSH
11507: LD_EXP 36
11511: EQUAL
11512: IFFALSE 11539
// begin save_group := save_group ^ Bobby ;
11514: LD_ADDR_EXP 22
11518: PUSH
11519: LD_EXP 22
11523: PUSH
11524: LD_EXP 36
11528: ADD
11529: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11530: LD_EXP 36
11534: PPUSH
11535: CALL_OW 64
// end ; if i = Cyrus then
11539: LD_VAR 0 1
11543: PUSH
11544: LD_EXP 37
11548: EQUAL
11549: IFFALSE 11576
// begin save_group := save_group ^ Cyrus ;
11551: LD_ADDR_EXP 22
11555: PUSH
11556: LD_EXP 22
11560: PUSH
11561: LD_EXP 37
11565: ADD
11566: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11567: LD_EXP 37
11571: PPUSH
11572: CALL_OW 64
// end ; if i = Khatam then
11576: LD_VAR 0 1
11580: PUSH
11581: LD_EXP 39
11585: EQUAL
11586: IFFALSE 11613
// begin save_group := save_group ^ Khatam ;
11588: LD_ADDR_EXP 22
11592: PUSH
11593: LD_EXP 22
11597: PUSH
11598: LD_EXP 39
11602: ADD
11603: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11604: LD_EXP 39
11608: PPUSH
11609: CALL_OW 64
// end ; if i = Frank then
11613: LD_VAR 0 1
11617: PUSH
11618: LD_EXP 49
11622: EQUAL
11623: IFFALSE 11650
// begin save_group := save_group ^ Frank ;
11625: LD_ADDR_EXP 22
11629: PUSH
11630: LD_EXP 22
11634: PUSH
11635: LD_EXP 49
11639: ADD
11640: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11641: LD_EXP 49
11645: PPUSH
11646: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11650: LD_VAR 0 1
11654: PPUSH
11655: CALL_OW 302
11659: PUSH
11660: LD_VAR 0 1
11664: PPUSH
11665: CALL_OW 247
11669: PUSH
11670: LD_INT 1
11672: EQUAL
11673: AND
11674: PUSH
11675: LD_VAR 0 1
11679: PUSH
11680: LD_EXP 22
11684: IN
11685: NOT
11686: AND
11687: IFFALSE 11714
// begin save_others := save_others ^ i ;
11689: LD_ADDR_EXP 21
11693: PUSH
11694: LD_EXP 21
11698: PUSH
11699: LD_VAR 0 1
11703: ADD
11704: ST_TO_ADDR
// RemoveUnit ( i ) ;
11705: LD_VAR 0 1
11709: PPUSH
11710: CALL_OW 64
// end ; end ;
11714: LD_VAR 0 2
11718: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
11719: LD_EXP 23
11723: NOT
11724: PUSH
11725: LD_EXP 24
11729: NOT
11730: AND
11731: PUSH
11732: LD_INT 22
11734: PUSH
11735: LD_INT 1
11737: PUSH
11738: EMPTY
11739: LIST
11740: LIST
11741: PUSH
11742: LD_INT 21
11744: PUSH
11745: LD_INT 1
11747: PUSH
11748: EMPTY
11749: LIST
11750: LIST
11751: PUSH
11752: EMPTY
11753: LIST
11754: LIST
11755: PPUSH
11756: CALL_OW 69
11760: PUSH
11761: LD_INT 0
11763: EQUAL
11764: OR
11765: IFFALSE 11774
11767: GO 11769
11769: DISABLE
// EndMission ;
11770: CALL 11775 0 0
11774: END
// export function EndMission ; var i ; begin
11775: LD_INT 0
11777: PPUSH
11778: PPUSH
// Wait ( 0 0$02 ) ;
11779: LD_INT 70
11781: PPUSH
11782: CALL_OW 67
// if solar_builded then
11786: LD_EXP 13
11790: IFFALSE 11804
// AddMedal ( Solar1 , 1 ) else
11792: LD_STRING Solar1
11794: PPUSH
11795: LD_INT 1
11797: PPUSH
11798: CALL_OW 101
11802: GO 11815
// AddMedal ( Solar1 , - 1 ) ;
11804: LD_STRING Solar1
11806: PPUSH
11807: LD_INT 1
11809: NEG
11810: PPUSH
11811: CALL_OW 101
// if veh_on_meta then
11815: LD_EXP 26
11819: IFFALSE 11833
// AddMedal ( Solar2 , 1 ) else
11821: LD_STRING Solar2
11823: PPUSH
11824: LD_INT 1
11826: PPUSH
11827: CALL_OW 101
11831: GO 11863
// if solar_builded then
11833: LD_EXP 13
11837: IFFALSE 11852
// AddMedal ( Solar2 , - 1 ) else
11839: LD_STRING Solar2
11841: PPUSH
11842: LD_INT 1
11844: NEG
11845: PPUSH
11846: CALL_OW 101
11850: GO 11863
// AddMedal ( Solar2 , - 2 ) ;
11852: LD_STRING Solar2
11854: PPUSH
11855: LD_INT 2
11857: NEG
11858: PPUSH
11859: CALL_OW 101
// if lose_counter = 0 then
11863: LD_EXP 32
11867: PUSH
11868: LD_INT 0
11870: EQUAL
11871: IFFALSE 11885
// AddMedal ( No , 1 ) else
11873: LD_STRING No
11875: PPUSH
11876: LD_INT 1
11878: PPUSH
11879: CALL_OW 101
11883: GO 11929
// if lose_counter > 0 and lose_counter < 4 then
11885: LD_EXP 32
11889: PUSH
11890: LD_INT 0
11892: GREATER
11893: PUSH
11894: LD_EXP 32
11898: PUSH
11899: LD_INT 4
11901: LESS
11902: AND
11903: IFFALSE 11918
// AddMedal ( No , - 1 ) else
11905: LD_STRING No
11907: PPUSH
11908: LD_INT 1
11910: NEG
11911: PPUSH
11912: CALL_OW 101
11916: GO 11929
// AddMedal ( UpTo4 , - 1 ) ;
11918: LD_STRING UpTo4
11920: PPUSH
11921: LD_INT 1
11923: NEG
11924: PPUSH
11925: CALL_OW 101
// GiveMedals ( MAIN ) ;
11929: LD_STRING MAIN
11931: PPUSH
11932: CALL_OW 102
// if IsDead ( Pokryshkin ) then
11936: LD_EXP 50
11940: PPUSH
11941: CALL_OW 301
11945: IFFALSE 11985
// for i in save_group ^ save_others do
11947: LD_ADDR_VAR 0 2
11951: PUSH
11952: LD_EXP 22
11956: PUSH
11957: LD_EXP 21
11961: ADD
11962: PUSH
11963: FOR_IN
11964: IFFALSE 11983
// AddExperience ( i , skill_combat , 1500 ) ;
11966: LD_VAR 0 2
11970: PPUSH
11971: LD_INT 1
11973: PPUSH
11974: LD_INT 1500
11976: PPUSH
11977: CALL_OW 492
11981: GO 11963
11983: POP
11984: POP
// RewardPeople ( save_group ^ save_others ) ;
11985: LD_EXP 22
11989: PUSH
11990: LD_EXP 21
11994: ADD
11995: PPUSH
11996: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
12000: LD_EXP 35
12004: PPUSH
12005: LD_EXP 2
12009: PUSH
12010: LD_STRING JMM
12012: STR
12013: PPUSH
12014: CALL_OW 38
// if Bobby in save_group then
12018: LD_EXP 36
12022: PUSH
12023: LD_EXP 22
12027: IN
12028: IFFALSE 12048
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12030: LD_EXP 36
12034: PPUSH
12035: LD_EXP 2
12039: PUSH
12040: LD_STRING Bobby
12042: STR
12043: PPUSH
12044: CALL_OW 38
// if Cyrus in save_group then
12048: LD_EXP 37
12052: PUSH
12053: LD_EXP 22
12057: IN
12058: IFFALSE 12078
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12060: LD_EXP 37
12064: PPUSH
12065: LD_EXP 2
12069: PUSH
12070: LD_STRING Cyrus
12072: STR
12073: PPUSH
12074: CALL_OW 38
// if Lisa in save_group then
12078: LD_EXP 38
12082: PUSH
12083: LD_EXP 22
12087: IN
12088: IFFALSE 12108
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12090: LD_EXP 38
12094: PPUSH
12095: LD_EXP 2
12099: PUSH
12100: LD_STRING Lisa
12102: STR
12103: PPUSH
12104: CALL_OW 38
// if Frank in save_group then
12108: LD_EXP 49
12112: PUSH
12113: LD_EXP 22
12117: IN
12118: IFFALSE 12138
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12120: LD_EXP 49
12124: PPUSH
12125: LD_EXP 2
12129: PUSH
12130: LD_STRING Frank
12132: STR
12133: PPUSH
12134: CALL_OW 38
// if Khatam in save_group then
12138: LD_EXP 39
12142: PUSH
12143: LD_EXP 22
12147: IN
12148: IFFALSE 12168
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
12150: LD_EXP 39
12154: PPUSH
12155: LD_EXP 2
12159: PUSH
12160: LD_STRING Khatam
12162: STR
12163: PPUSH
12164: CALL_OW 38
// if save_others then
12168: LD_EXP 21
12172: IFFALSE 12186
// SaveCharacters ( save_others , 03_others ) ;
12174: LD_EXP 21
12178: PPUSH
12179: LD_STRING 03_others
12181: PPUSH
12182: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) then
12186: LD_EXP 43
12190: PUSH
12191: LD_EXP 43
12195: PPUSH
12196: CALL_OW 302
12200: AND
12201: IFFALSE 12213
// begin ResetFog ;
12203: CALL_OW 335
// DisplayEndingScene ;
12207: CALL 12235 0 0
// end else
12211: GO 12226
// DeleteCharacters ( mission_prefix & Cornel ) ;
12213: LD_EXP 2
12217: PUSH
12218: LD_STRING Cornel
12220: STR
12221: PPUSH
12222: CALL_OW 40
// YouWin ;
12226: CALL_OW 103
// end ;
12230: LD_VAR 0 1
12234: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
12235: LD_INT 0
12237: PPUSH
12238: PPUSH
12239: PPUSH
12240: PPUSH
12241: PPUSH
12242: PPUSH
// InGameOn ;
12243: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12247: LD_INT 208
12249: PPUSH
12250: LD_INT 62
12252: PPUSH
12253: LD_INT 1
12255: PPUSH
12256: LD_INT 10
12258: NEG
12259: PPUSH
12260: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
12264: LD_INT 208
12266: PPUSH
12267: LD_INT 62
12269: PPUSH
12270: LD_INT 1
12272: PPUSH
12273: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
12277: LD_ADDR_VAR 0 3
12281: PUSH
12282: LD_INT 22
12284: PUSH
12285: LD_INT 3
12287: PUSH
12288: EMPTY
12289: LIST
12290: LIST
12291: PUSH
12292: LD_INT 2
12294: PUSH
12295: LD_INT 21
12297: PUSH
12298: LD_INT 2
12300: PUSH
12301: EMPTY
12302: LIST
12303: LIST
12304: PUSH
12305: LD_INT 21
12307: PUSH
12308: LD_INT 1
12310: PUSH
12311: EMPTY
12312: LIST
12313: LIST
12314: PUSH
12315: EMPTY
12316: LIST
12317: LIST
12318: LIST
12319: PUSH
12320: EMPTY
12321: LIST
12322: LIST
12323: PPUSH
12324: CALL_OW 69
12328: ST_TO_ADDR
// if filter then
12329: LD_VAR 0 3
12333: IFFALSE 12361
// for i in filter do
12335: LD_ADDR_VAR 0 2
12339: PUSH
12340: LD_VAR 0 3
12344: PUSH
12345: FOR_IN
12346: IFFALSE 12359
// RemoveUnit ( i ) ;
12348: LD_VAR 0 2
12352: PPUSH
12353: CALL_OW 64
12357: GO 12345
12359: POP
12360: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
12361: LD_ADDR_VAR 0 3
12365: PUSH
12366: LD_INT 22
12368: PUSH
12369: LD_INT 4
12371: PUSH
12372: EMPTY
12373: LIST
12374: LIST
12375: PUSH
12376: LD_INT 21
12378: PUSH
12379: LD_INT 1
12381: PUSH
12382: EMPTY
12383: LIST
12384: LIST
12385: PUSH
12386: EMPTY
12387: LIST
12388: LIST
12389: PPUSH
12390: CALL_OW 69
12394: ST_TO_ADDR
// if filter then
12395: LD_VAR 0 3
12399: IFFALSE 12430
// for i in filter do
12401: LD_ADDR_VAR 0 2
12405: PUSH
12406: LD_VAR 0 3
12410: PUSH
12411: FOR_IN
12412: IFFALSE 12428
// SetLives ( i , 0 ) ;
12414: LD_VAR 0 2
12418: PPUSH
12419: LD_INT 0
12421: PPUSH
12422: CALL_OW 234
12426: GO 12411
12428: POP
12429: POP
// uc_side := 4 ;
12430: LD_ADDR_OWVAR 20
12434: PUSH
12435: LD_INT 4
12437: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12438: LD_ADDR_VAR 0 4
12442: PUSH
12443: LD_STRING Cornell
12445: PPUSH
12446: LD_INT 0
12448: PPUSH
12449: CALL 466 0 2
12453: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12454: LD_VAR 0 4
12458: PPUSH
12459: LD_INT 208
12461: PPUSH
12462: LD_INT 62
12464: PPUSH
12465: LD_INT 0
12467: PPUSH
12468: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12472: LD_VAR 0 4
12476: PPUSH
12477: LD_INT 100
12479: PPUSH
12480: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12484: LD_INT 3
12486: PPUSH
12487: LD_VAR 0 4
12491: PPUSH
12492: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12496: LD_INT 4
12498: PPUSH
12499: LD_INT 3
12501: PPUSH
12502: LD_INT 1
12504: PPUSH
12505: LD_INT 1
12507: PPUSH
12508: CALL_OW 80
// uc_side := 3 ;
12512: LD_ADDR_OWVAR 20
12516: PUSH
12517: LD_INT 3
12519: ST_TO_ADDR
// uc_nation := 3 ;
12520: LD_ADDR_OWVAR 21
12524: PUSH
12525: LD_INT 3
12527: ST_TO_ADDR
// InitHc ;
12528: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12532: LD_ADDR_VAR 0 5
12536: PUSH
12537: LD_STRING Mikhail
12539: PPUSH
12540: LD_INT 0
12542: PPUSH
12543: CALL 466 0 2
12547: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12548: LD_INT 1
12550: PPUSH
12551: LD_INT 1
12553: PPUSH
12554: LD_INT 0
12556: PPUSH
12557: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12561: LD_ADDR_VAR 0 6
12565: PUSH
12566: LD_VAR 0 6
12570: PUSH
12571: CALL_OW 44
12575: ADD
12576: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12577: LD_ADDR_VAR 0 6
12581: PUSH
12582: LD_VAR 0 6
12586: PUSH
12587: CALL_OW 44
12591: ADD
12592: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12593: LD_INT 2
12595: PPUSH
12596: LD_INT 4
12598: PPUSH
12599: LD_INT 0
12601: PPUSH
12602: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12606: LD_ADDR_VAR 0 6
12610: PUSH
12611: LD_VAR 0 6
12615: PUSH
12616: CALL_OW 44
12620: ADD
12621: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12622: LD_VAR 0 5
12626: PPUSH
12627: LD_INT 17
12629: PPUSH
12630: LD_INT 0
12632: PPUSH
12633: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12637: LD_VAR 0 5
12641: PPUSH
12642: LD_INT 210
12644: PPUSH
12645: LD_INT 63
12647: PPUSH
12648: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12652: LD_VAR 0 5
12656: PPUSH
12657: LD_INT 208
12659: PPUSH
12660: LD_INT 62
12662: PPUSH
12663: CALL_OW 178
// for i in fake_russians do
12667: LD_ADDR_VAR 0 2
12671: PUSH
12672: LD_VAR 0 6
12676: PUSH
12677: FOR_IN
12678: IFFALSE 12756
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12680: LD_VAR 0 2
12684: PPUSH
12685: LD_INT 17
12687: PPUSH
12688: LD_INT 0
12690: PPUSH
12691: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
12695: LD_VAR 0 2
12699: PPUSH
12700: LD_INT 215
12702: PPUSH
12703: LD_INT 67
12705: PPUSH
12706: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
12710: LD_VAR 0 2
12714: PPUSH
12715: LD_INT 208
12717: PPUSH
12718: LD_INT 62
12720: PPUSH
12721: CALL_OW 178
// if GetClass ( i ) = 4 then
12725: LD_VAR 0 2
12729: PPUSH
12730: CALL_OW 257
12734: PUSH
12735: LD_INT 4
12737: EQUAL
12738: IFFALSE 12754
// ComHeal ( i , fake_cornel ) ;
12740: LD_VAR 0 2
12744: PPUSH
12745: LD_VAR 0 4
12749: PPUSH
12750: CALL_OW 128
// end ;
12754: GO 12677
12756: POP
12757: POP
// Wait ( 0 0$01 ) ;
12758: LD_INT 35
12760: PPUSH
12761: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
12765: LD_INT 208
12767: PPUSH
12768: LD_INT 62
12770: PPUSH
12771: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12775: LD_INT 208
12777: PPUSH
12778: LD_INT 62
12780: PPUSH
12781: LD_INT 1
12783: PPUSH
12784: LD_INT 10
12786: NEG
12787: PPUSH
12788: CALL_OW 330
// Wait ( 0 0$15 ) ;
12792: LD_INT 525
12794: PPUSH
12795: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
12799: LD_INT 208
12801: PPUSH
12802: LD_INT 62
12804: PPUSH
12805: LD_INT 1
12807: PPUSH
12808: CALL_OW 331
// ResetFog ;
12812: CALL_OW 335
// InGameOff ;
12816: CALL_OW 9
// end ;
12820: LD_VAR 0 1
12824: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
12825: LD_INT 10
12827: PPUSH
12828: LD_INT 22
12830: PUSH
12831: LD_INT 1
12833: PUSH
12834: EMPTY
12835: LIST
12836: LIST
12837: PPUSH
12838: CALL_OW 70
12842: PUSH
12843: LD_EXP 42
12847: PPUSH
12848: CALL_OW 302
12852: AND
12853: PUSH
12854: LD_INT 22
12856: PUSH
12857: LD_INT 1
12859: PUSH
12860: EMPTY
12861: LIST
12862: LIST
12863: PPUSH
12864: CALL_OW 69
12868: PPUSH
12869: LD_EXP 42
12873: PPUSH
12874: CALL_OW 74
12878: PPUSH
12879: LD_EXP 42
12883: PPUSH
12884: CALL_OW 296
12888: PUSH
12889: LD_INT 30
12891: LESS
12892: OR
12893: IFFALSE 12944
12895: GO 12897
12897: DISABLE
// begin enable ;
12898: ENABLE
// powell_warn := powell_warn + 1 ;
12899: LD_ADDR_EXP 33
12903: PUSH
12904: LD_EXP 33
12908: PUSH
12909: LD_INT 1
12911: PLUS
12912: ST_TO_ADDR
// if powell_warn = 3 then
12913: LD_EXP 33
12917: PUSH
12918: LD_INT 3
12920: EQUAL
12921: IFFALSE 12932
// begin YouLost ( 5 ) ;
12923: LD_STRING 5
12925: PPUSH
12926: CALL_OW 104
// exit ;
12930: GO 12944
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
12932: LD_EXP 44
12936: PPUSH
12937: LD_STRING DWarn-Pow-1
12939: PPUSH
12940: CALL_OW 94
// end ; end_of_file
12944: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
12945: LD_EXP 8
12949: IFFALSE 14285
12951: GO 12953
12953: DISABLE
12954: LD_INT 0
12956: PPUSH
12957: PPUSH
12958: PPUSH
12959: PPUSH
12960: PPUSH
12961: PPUSH
12962: PPUSH
12963: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
12964: LD_EXP 42
12968: PUSH
12969: LD_EXP 43
12973: ADD
12974: PUSH
12975: LD_EXP 6
12979: ADD
12980: PPUSH
12981: LD_INT 250
12983: PPUSH
12984: LD_INT 120
12986: PPUSH
12987: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff [ Bierezov ] ;
12991: LD_ADDR_VAR 0 2
12995: PUSH
12996: LD_EXP 6
13000: PPUSH
13001: LD_INT 25
13003: PUSH
13004: LD_INT 2
13006: PUSH
13007: EMPTY
13008: LIST
13009: LIST
13010: PPUSH
13011: CALL_OW 72
13015: PUSH
13016: LD_EXP 43
13020: PUSH
13021: EMPTY
13022: LIST
13023: DIFF
13024: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
13025: LD_ADDR_VAR 0 3
13029: PUSH
13030: LD_EXP 6
13034: PPUSH
13035: LD_INT 21
13037: PUSH
13038: LD_INT 1
13040: PUSH
13041: EMPTY
13042: LIST
13043: LIST
13044: PPUSH
13045: CALL_OW 72
13049: ST_TO_ADDR
// if not has_eng then
13050: LD_VAR 0 2
13054: NOT
13055: IFFALSE 13138
// begin uc_side := 4 ;
13057: LD_ADDR_OWVAR 20
13061: PUSH
13062: LD_INT 4
13064: ST_TO_ADDR
// uc_nation := 1 ;
13065: LD_ADDR_OWVAR 21
13069: PUSH
13070: LD_INT 1
13072: ST_TO_ADDR
// bc_type := b_depot ;
13073: LD_ADDR_OWVAR 42
13077: PUSH
13078: LD_INT 0
13080: ST_TO_ADDR
// bc_level := 2 ;
13081: LD_ADDR_OWVAR 43
13085: PUSH
13086: LD_INT 2
13088: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13089: LD_ADDR_VAR 0 4
13093: PUSH
13094: LD_INT 264
13096: PPUSH
13097: LD_INT 120
13099: PPUSH
13100: LD_INT 4
13102: PPUSH
13103: CALL_OW 47
13107: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13108: LD_INT 264
13110: PPUSH
13111: LD_INT 120
13113: PPUSH
13114: LD_INT 4
13116: PPUSH
13117: LD_INT 10
13119: NEG
13120: PPUSH
13121: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13125: LD_INT 264
13127: PPUSH
13128: LD_INT 120
13130: PPUSH
13131: LD_INT 4
13133: PPUSH
13134: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13138: LD_INT 35
13140: PPUSH
13141: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
13145: LD_EXP 42
13149: PPUSH
13150: LD_INT 10
13152: PPUSH
13153: CALL_OW 308
13157: IFFALSE 13138
// if has_eng and not dep then
13159: LD_VAR 0 2
13163: PUSH
13164: LD_VAR 0 4
13168: NOT
13169: AND
13170: IFFALSE 13320
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
13172: LD_VAR 0 2
13176: PPUSH
13177: LD_INT 0
13179: PPUSH
13180: LD_INT 264
13182: PPUSH
13183: LD_INT 120
13185: PPUSH
13186: LD_INT 4
13188: PPUSH
13189: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
13193: LD_INT 35
13195: PPUSH
13196: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
13200: LD_INT 22
13202: PUSH
13203: LD_INT 4
13205: PUSH
13206: EMPTY
13207: LIST
13208: LIST
13209: PUSH
13210: LD_INT 30
13212: PUSH
13213: LD_INT 0
13215: PUSH
13216: EMPTY
13217: LIST
13218: LIST
13219: PUSH
13220: EMPTY
13221: LIST
13222: LIST
13223: PPUSH
13224: CALL_OW 69
13228: IFFALSE 13193
// ComMoveXY ( filter , 264 , 120 ) ;
13230: LD_VAR 0 3
13234: PPUSH
13235: LD_INT 264
13237: PPUSH
13238: LD_INT 120
13240: PPUSH
13241: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
13245: LD_INT 35
13247: PPUSH
13248: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
13252: LD_INT 22
13254: PUSH
13255: LD_INT 4
13257: PUSH
13258: EMPTY
13259: LIST
13260: LIST
13261: PUSH
13262: LD_INT 30
13264: PUSH
13265: LD_INT 0
13267: PUSH
13268: EMPTY
13269: LIST
13270: LIST
13271: PUSH
13272: LD_INT 3
13274: PUSH
13275: LD_INT 57
13277: PUSH
13278: EMPTY
13279: LIST
13280: PUSH
13281: EMPTY
13282: LIST
13283: LIST
13284: PUSH
13285: EMPTY
13286: LIST
13287: LIST
13288: LIST
13289: PPUSH
13290: CALL_OW 69
13294: IFFALSE 13245
// ComMoveXY ( filter , 247 , 113 ) ;
13296: LD_VAR 0 3
13300: PPUSH
13301: LD_INT 247
13303: PPUSH
13304: LD_INT 113
13306: PPUSH
13307: CALL_OW 111
// Wait ( 0 0$2 ) ;
13311: LD_INT 70
13313: PPUSH
13314: CALL_OW 67
// end else
13318: GO 13332
// begin SetSide ( dep , 4 ) ;
13320: LD_VAR 0 4
13324: PPUSH
13325: LD_INT 4
13327: PPUSH
13328: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
13332: LD_ADDR_VAR 0 4
13336: PUSH
13337: LD_INT 22
13339: PUSH
13340: LD_INT 4
13342: PUSH
13343: EMPTY
13344: LIST
13345: LIST
13346: PUSH
13347: LD_INT 30
13349: PUSH
13350: LD_INT 0
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PUSH
13357: EMPTY
13358: LIST
13359: LIST
13360: PPUSH
13361: CALL_OW 69
13365: PUSH
13366: LD_INT 1
13368: ARRAY
13369: ST_TO_ADDR
// for i = 1 to 2 - has_eng do
13370: LD_ADDR_VAR 0 1
13374: PUSH
13375: DOUBLE
13376: LD_INT 1
13378: DEC
13379: ST_TO_ADDR
13380: LD_INT 2
13382: PUSH
13383: LD_VAR 0 2
13387: MINUS
13388: PUSH
13389: FOR_TO
13390: IFFALSE 13470
// begin if GetClass ( filter [ i ] ) = 2 then
13392: LD_VAR 0 3
13396: PUSH
13397: LD_VAR 0 1
13401: ARRAY
13402: PPUSH
13403: CALL_OW 257
13407: PUSH
13408: LD_INT 2
13410: EQUAL
13411: IFFALSE 13415
// continue ;
13413: GO 13389
// ComEnterUnit ( filter [ i ] , dep ) ;
13415: LD_VAR 0 3
13419: PUSH
13420: LD_VAR 0 1
13424: ARRAY
13425: PPUSH
13426: LD_VAR 0 4
13430: PPUSH
13431: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
13435: LD_VAR 0 3
13439: PUSH
13440: LD_VAR 0 1
13444: ARRAY
13445: PPUSH
13446: LD_INT 2
13448: PPUSH
13449: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
13453: LD_VAR 0 3
13457: PUSH
13458: LD_VAR 0 1
13462: ARRAY
13463: PPUSH
13464: CALL_OW 182
// end ;
13468: GO 13389
13470: POP
13471: POP
// repeat wait ( 0 0$01 ) ;
13472: LD_INT 35
13474: PPUSH
13475: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) >= 2 ;
13479: LD_VAR 0 3
13483: PPUSH
13484: LD_INT 25
13486: PUSH
13487: LD_INT 2
13489: PUSH
13490: EMPTY
13491: LIST
13492: LIST
13493: PPUSH
13494: CALL_OW 72
13498: PUSH
13499: LD_INT 2
13501: GREATEREQUAL
13502: IFFALSE 13472
// if IsInUnit ( Cornel ) then
13504: LD_EXP 42
13508: PPUSH
13509: CALL_OW 310
13513: IFFALSE 13596
// begin cargo := IsInUnit ( Cornel ) ;
13515: LD_ADDR_VAR 0 7
13519: PUSH
13520: LD_EXP 42
13524: PPUSH
13525: CALL_OW 310
13529: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13530: LD_VAR 0 7
13534: PPUSH
13535: LD_INT 1
13537: PPUSH
13538: CALL_OW 289
13542: IFFALSE 13558
// ComGive ( Cornel , dep ) ;
13544: LD_EXP 42
13548: PPUSH
13549: LD_VAR 0 4
13553: PPUSH
13554: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13558: LD_EXP 42
13562: PPUSH
13563: LD_INT 235
13565: PPUSH
13566: LD_INT 122
13568: PPUSH
13569: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13573: LD_EXP 42
13577: PPUSH
13578: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13582: LD_EXP 42
13586: PPUSH
13587: LD_VAR 0 4
13591: PPUSH
13592: CALL_OW 180
// end ; if Bierezov then
13596: LD_EXP 43
13600: IFFALSE 13616
// ComEnterUnit ( Bierezov , dep ) ;
13602: LD_EXP 43
13606: PPUSH
13607: LD_VAR 0 4
13611: PPUSH
13612: CALL_OW 120
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
13616: LD_ADDR_VAR 0 2
13620: PUSH
13621: LD_EXP 6
13625: PPUSH
13626: LD_INT 25
13628: PUSH
13629: LD_INT 2
13631: PUSH
13632: EMPTY
13633: LIST
13634: LIST
13635: PPUSH
13636: CALL_OW 72
13640: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13641: LD_INT 35
13643: PPUSH
13644: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13648: LD_ADDR_VAR 0 6
13652: PUSH
13653: LD_INT 10
13655: PPUSH
13656: CALL_OW 435
13660: ST_TO_ADDR
// if crates then
13661: LD_VAR 0 6
13665: IFFALSE 13694
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
13667: LD_VAR 0 2
13671: PPUSH
13672: LD_VAR 0 6
13676: PUSH
13677: LD_INT 1
13679: ARRAY
13680: PPUSH
13681: LD_VAR 0 6
13685: PUSH
13686: LD_INT 2
13688: ARRAY
13689: PPUSH
13690: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
13694: LD_VAR 0 4
13698: PPUSH
13699: CALL_OW 274
13703: PPUSH
13704: LD_INT 1
13706: PPUSH
13707: CALL_OW 275
13711: PUSH
13712: LD_INT 40
13714: GREATEREQUAL
13715: IFFALSE 13641
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
13717: LD_ADDR_VAR 0 5
13721: PUSH
13722: LD_INT 4
13724: PUSH
13725: LD_INT 256
13727: PUSH
13728: LD_INT 111
13730: PUSH
13731: LD_INT 2
13733: PUSH
13734: EMPTY
13735: LIST
13736: LIST
13737: LIST
13738: LIST
13739: PUSH
13740: LD_INT 31
13742: PUSH
13743: LD_INT 243
13745: PUSH
13746: LD_INT 112
13748: PUSH
13749: LD_INT 2
13751: PUSH
13752: EMPTY
13753: LIST
13754: LIST
13755: LIST
13756: LIST
13757: PUSH
13758: EMPTY
13759: LIST
13760: LIST
13761: ST_TO_ADDR
// for i in blist do
13762: LD_ADDR_VAR 0 1
13766: PUSH
13767: LD_VAR 0 5
13771: PUSH
13772: FOR_IN
13773: IFFALSE 13822
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
13775: LD_VAR 0 2
13779: PPUSH
13780: LD_VAR 0 1
13784: PUSH
13785: LD_INT 1
13787: ARRAY
13788: PPUSH
13789: LD_VAR 0 1
13793: PUSH
13794: LD_INT 2
13796: ARRAY
13797: PPUSH
13798: LD_VAR 0 1
13802: PUSH
13803: LD_INT 3
13805: ARRAY
13806: PPUSH
13807: LD_VAR 0 1
13811: PUSH
13812: LD_INT 4
13814: ARRAY
13815: PPUSH
13816: CALL_OW 205
13820: GO 13772
13822: POP
13823: POP
// repeat wait ( 0 0$01 ) ;
13824: LD_INT 35
13826: PPUSH
13827: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
13831: LD_INT 22
13833: PUSH
13834: LD_INT 4
13836: PUSH
13837: EMPTY
13838: LIST
13839: LIST
13840: PUSH
13841: LD_INT 30
13843: PUSH
13844: LD_INT 4
13846: PUSH
13847: EMPTY
13848: LIST
13849: LIST
13850: PUSH
13851: LD_INT 3
13853: PUSH
13854: LD_INT 57
13856: PUSH
13857: EMPTY
13858: LIST
13859: PUSH
13860: EMPTY
13861: LIST
13862: LIST
13863: PUSH
13864: EMPTY
13865: LIST
13866: LIST
13867: LIST
13868: PPUSH
13869: CALL_OW 69
13873: IFFALSE 13824
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
13875: LD_VAR 0 3
13879: PUSH
13880: LD_VAR 0 2
13884: DIFF
13885: PPUSH
13886: LD_INT 22
13888: PUSH
13889: LD_INT 4
13891: PUSH
13892: EMPTY
13893: LIST
13894: LIST
13895: PUSH
13896: LD_INT 30
13898: PUSH
13899: LD_INT 4
13901: PUSH
13902: EMPTY
13903: LIST
13904: LIST
13905: PUSH
13906: EMPTY
13907: LIST
13908: LIST
13909: PPUSH
13910: CALL_OW 69
13914: PUSH
13915: LD_INT 1
13917: ARRAY
13918: PPUSH
13919: CALL_OW 180
// AddComChangeProfession ( filter diff has_eng , 1 ) ;
13923: LD_VAR 0 3
13927: PUSH
13928: LD_VAR 0 2
13932: DIFF
13933: PPUSH
13934: LD_INT 1
13936: PPUSH
13937: CALL_OW 183
// repeat wait ( 0 0$01 ) ;
13941: LD_INT 35
13943: PPUSH
13944: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
13948: LD_INT 22
13950: PUSH
13951: LD_INT 4
13953: PUSH
13954: EMPTY
13955: LIST
13956: LIST
13957: PUSH
13958: LD_INT 30
13960: PUSH
13961: LD_INT 31
13963: PUSH
13964: EMPTY
13965: LIST
13966: LIST
13967: PUSH
13968: LD_INT 3
13970: PUSH
13971: LD_INT 57
13973: PUSH
13974: EMPTY
13975: LIST
13976: PUSH
13977: EMPTY
13978: LIST
13979: LIST
13980: PUSH
13981: EMPTY
13982: LIST
13983: LIST
13984: LIST
13985: PPUSH
13986: CALL_OW 69
13990: IFFALSE 13941
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
13992: LD_ADDR_VAR 0 8
13996: PUSH
13997: LD_EXP 6
14001: PPUSH
14002: LD_INT 25
14004: PUSH
14005: LD_INT 1
14007: PUSH
14008: EMPTY
14009: LIST
14010: LIST
14011: PPUSH
14012: CALL_OW 72
14016: ST_TO_ADDR
// ComExitBuilding ( sol [ 1 ] ) ;
14017: LD_VAR 0 8
14021: PUSH
14022: LD_INT 1
14024: ARRAY
14025: PPUSH
14026: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
14030: LD_VAR 0 8
14034: PUSH
14035: LD_INT 1
14037: ARRAY
14038: PPUSH
14039: LD_INT 22
14041: PUSH
14042: LD_INT 4
14044: PUSH
14045: EMPTY
14046: LIST
14047: LIST
14048: PUSH
14049: LD_INT 30
14051: PUSH
14052: LD_INT 31
14054: PUSH
14055: EMPTY
14056: LIST
14057: LIST
14058: PUSH
14059: EMPTY
14060: LIST
14061: LIST
14062: PPUSH
14063: CALL_OW 69
14067: PUSH
14068: LD_INT 1
14070: ARRAY
14071: PPUSH
14072: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
14076: LD_VAR 0 2
14080: PPUSH
14081: LD_VAR 0 4
14085: PPUSH
14086: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
14090: LD_INT 35
14092: PPUSH
14093: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14097: LD_ADDR_VAR 0 3
14101: PUSH
14102: LD_INT 22
14104: PUSH
14105: LD_INT 4
14107: PUSH
14108: EMPTY
14109: LIST
14110: LIST
14111: PUSH
14112: LD_INT 21
14114: PUSH
14115: LD_INT 3
14117: PUSH
14118: EMPTY
14119: LIST
14120: LIST
14121: PUSH
14122: LD_INT 3
14124: PUSH
14125: LD_INT 24
14127: PUSH
14128: LD_INT 1000
14130: PUSH
14131: EMPTY
14132: LIST
14133: LIST
14134: PUSH
14135: EMPTY
14136: LIST
14137: LIST
14138: PUSH
14139: EMPTY
14140: LIST
14141: LIST
14142: LIST
14143: PPUSH
14144: CALL_OW 69
14148: ST_TO_ADDR
// if filter and has_eng then
14149: LD_VAR 0 3
14153: PUSH
14154: LD_VAR 0 2
14158: AND
14159: IFFALSE 14225
// begin for i in has_eng do
14161: LD_ADDR_VAR 0 1
14165: PUSH
14166: LD_VAR 0 2
14170: PUSH
14171: FOR_IN
14172: IFFALSE 14221
// begin if IsInUnit ( i ) then
14174: LD_VAR 0 1
14178: PPUSH
14179: CALL_OW 310
14183: IFFALSE 14194
// ComExitBuilding ( i ) ;
14185: LD_VAR 0 1
14189: PPUSH
14190: CALL_OW 122
// Wait ( 3 ) ;
14194: LD_INT 3
14196: PPUSH
14197: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
14201: LD_VAR 0 1
14205: PPUSH
14206: LD_VAR 0 3
14210: PUSH
14211: LD_INT 1
14213: ARRAY
14214: PPUSH
14215: CALL_OW 130
// end ;
14219: GO 14171
14221: POP
14222: POP
// end else
14223: GO 14279
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
14225: LD_VAR 0 2
14229: PUSH
14230: LD_VAR 0 2
14234: PPUSH
14235: LD_INT 56
14237: PUSH
14238: EMPTY
14239: LIST
14240: PPUSH
14241: CALL_OW 72
14245: AND
14246: IFFALSE 14279
// for i in has_eng do
14248: LD_ADDR_VAR 0 1
14252: PUSH
14253: LD_VAR 0 2
14257: PUSH
14258: FOR_IN
14259: IFFALSE 14277
// ComEnterUnit ( i , dep ) ;
14261: LD_VAR 0 1
14265: PPUSH
14266: LD_VAR 0 4
14270: PPUSH
14271: CALL_OW 120
14275: GO 14258
14277: POP
14278: POP
// until cornel_prepared ;
14279: LD_EXP 11
14283: IFFALSE 14090
// end ;
14285: PPOPN 8
14287: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
14288: LD_EXP 11
14292: IFFALSE 14641
14294: GO 14296
14296: DISABLE
14297: LD_INT 0
14299: PPUSH
14300: PPUSH
14301: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
14302: LD_ADDR_VAR 0 2
14306: PUSH
14307: LD_INT 22
14309: PUSH
14310: LD_INT 4
14312: PUSH
14313: EMPTY
14314: LIST
14315: LIST
14316: PUSH
14317: LD_INT 30
14319: PUSH
14320: LD_INT 4
14322: PUSH
14323: EMPTY
14324: LIST
14325: LIST
14326: PUSH
14327: EMPTY
14328: LIST
14329: LIST
14330: PPUSH
14331: CALL_OW 69
14335: PUSH
14336: LD_INT 1
14338: ARRAY
14339: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
14340: LD_EXP 6
14344: PPUSH
14345: CALL_OW 122
// Wait ( 0 0$03 ) ;
14349: LD_INT 105
14351: PPUSH
14352: CALL_OW 67
// for i in cornel_units do
14356: LD_ADDR_VAR 0 1
14360: PUSH
14361: LD_EXP 6
14365: PUSH
14366: FOR_IN
14367: IFFALSE 14443
// begin if GetClass ( i ) in [ 2 , 3 ] then
14369: LD_VAR 0 1
14373: PPUSH
14374: CALL_OW 257
14378: PUSH
14379: LD_INT 2
14381: PUSH
14382: LD_INT 3
14384: PUSH
14385: EMPTY
14386: LIST
14387: LIST
14388: IN
14389: IFFALSE 14426
// begin ComEnterUnit ( i , arm ) ;
14391: LD_VAR 0 1
14395: PPUSH
14396: LD_VAR 0 2
14400: PPUSH
14401: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
14405: LD_VAR 0 1
14409: PPUSH
14410: LD_INT 1
14412: PPUSH
14413: CALL_OW 183
// AddComExitBuilding ( i ) ;
14417: LD_VAR 0 1
14421: PPUSH
14422: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
14426: LD_VAR 0 1
14430: PPUSH
14431: LD_INT 257
14433: PPUSH
14434: LD_INT 121
14436: PPUSH
14437: CALL_OW 171
// end ;
14441: GO 14366
14443: POP
14444: POP
// Wait ( 1 1$00 ) ;
14445: LD_INT 2100
14447: PPUSH
14448: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
14452: LD_ADDR_VAR 0 3
14456: PUSH
14457: LD_EXP 42
14461: PUSH
14462: LD_EXP 43
14466: ADD
14467: PUSH
14468: LD_EXP 6
14472: ADD
14473: PUSH
14474: LD_EXP 6
14478: PPUSH
14479: LD_INT 21
14481: PUSH
14482: LD_INT 2
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: PPUSH
14489: CALL_OW 72
14493: DIFF
14494: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
14495: LD_VAR 0 3
14499: PPUSH
14500: LD_INT 248
14502: PPUSH
14503: LD_INT 85
14505: PPUSH
14506: CALL_OW 111
// AddComHold ( filter ) ;
14510: LD_VAR 0 3
14514: PPUSH
14515: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
14519: LD_INT 35
14521: PPUSH
14522: CALL_OW 67
// until cornel_attack ;
14526: LD_EXP 9
14530: IFFALSE 14519
// ComAgressiveMove ( filter , 209 , 63 ) ;
14532: LD_VAR 0 3
14536: PPUSH
14537: LD_INT 209
14539: PPUSH
14540: LD_INT 63
14542: PPUSH
14543: CALL_OW 114
// if Bierezov then
14547: LD_EXP 43
14551: IFFALSE 14641
// begin filter := filter diff Bierezov ;
14553: LD_ADDR_VAR 0 3
14557: PUSH
14558: LD_VAR 0 3
14562: PUSH
14563: LD_EXP 43
14567: DIFF
14568: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
14569: LD_EXP 43
14573: PPUSH
14574: LD_INT 6
14576: PPUSH
14577: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
14581: LD_EXP 43
14585: PPUSH
14586: LD_INT 235
14588: PPUSH
14589: LD_INT 60
14591: PPUSH
14592: CALL_OW 111
// AddComHold ( Bierezov ) ;
14596: LD_EXP 43
14600: PPUSH
14601: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
14605: LD_EXP 43
14609: PPUSH
14610: LD_INT 350
14612: PPUSH
14613: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
14617: LD_EXP 43
14621: PPUSH
14622: LD_INT 198
14624: PPUSH
14625: LD_INT 28
14627: PPUSH
14628: CALL_OW 171
// AddComHold ( Bierezov ) ;
14632: LD_EXP 43
14636: PPUSH
14637: CALL_OW 200
// end ; end ; end_of_file
14641: PPOPN 3
14643: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
14644: LD_EXP 51
14648: PUSH
14649: LD_EXP 29
14653: NOT
14654: AND
14655: PUSH
14656: LD_EXP 30
14660: NOT
14661: AND
14662: IFFALSE 15112
14664: GO 14666
14666: DISABLE
14667: LD_INT 0
14669: PPUSH
14670: PPUSH
14671: PPUSH
14672: PPUSH
// begin enable ;
14673: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14674: LD_ADDR_VAR 0 4
14678: PUSH
14679: LD_INT 81
14681: PUSH
14682: LD_INT 3
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: PPUSH
14689: CALL_OW 69
14693: ST_TO_ADDR
// for i = 1 to ru_patrol do
14694: LD_ADDR_VAR 0 2
14698: PUSH
14699: DOUBLE
14700: LD_INT 1
14702: DEC
14703: ST_TO_ADDR
14704: LD_EXP 51
14708: PUSH
14709: FOR_TO
14710: IFFALSE 15110
// begin un := ru_patrol [ i ] ;
14712: LD_ADDR_VAR 0 1
14716: PUSH
14717: LD_EXP 51
14721: PUSH
14722: LD_VAR 0 2
14726: ARRAY
14727: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14728: LD_VAR 0 1
14732: PPUSH
14733: LD_INT 13
14735: PPUSH
14736: CALL_OW 308
14740: IFFALSE 14845
// begin if not ru_alert then
14742: LD_EXP 58
14746: NOT
14747: IFFALSE 14757
// ru_alert := true ;
14749: LD_ADDR_EXP 58
14753: PUSH
14754: LD_INT 1
14756: ST_TO_ADDR
// if not See ( 1 , un ) then
14757: LD_INT 1
14759: PPUSH
14760: LD_VAR 0 1
14764: PPUSH
14765: CALL_OW 292
14769: NOT
14770: IFFALSE 14784
// SetLives ( un , 1000 ) ;
14772: LD_VAR 0 1
14776: PPUSH
14777: LD_INT 1000
14779: PPUSH
14780: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
14784: LD_ADDR_EXP 51
14788: PUSH
14789: LD_EXP 51
14793: PUSH
14794: LD_VAR 0 1
14798: DIFF
14799: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
14800: LD_VAR 0 1
14804: PPUSH
14805: LD_INT 22
14807: PUSH
14808: LD_INT 3
14810: PUSH
14811: EMPTY
14812: LIST
14813: LIST
14814: PUSH
14815: LD_INT 30
14817: PUSH
14818: LD_INT 4
14820: PUSH
14821: EMPTY
14822: LIST
14823: LIST
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: PPUSH
14829: CALL_OW 69
14833: PPUSH
14834: CALL 1039 0 1
14838: PPUSH
14839: CALL_OW 120
// continue ;
14843: GO 14709
// end ; if IsOk ( un ) and not HasTask ( un ) then
14845: LD_VAR 0 1
14849: PPUSH
14850: CALL_OW 302
14854: PUSH
14855: LD_VAR 0 1
14859: PPUSH
14860: CALL_OW 314
14864: NOT
14865: AND
14866: IFFALSE 14959
// begin for j = 1 to ru_firepoints_south [ i ] do
14868: LD_ADDR_VAR 0 3
14872: PUSH
14873: DOUBLE
14874: LD_INT 1
14876: DEC
14877: ST_TO_ADDR
14878: LD_EXP 57
14882: PUSH
14883: LD_VAR 0 2
14887: ARRAY
14888: PUSH
14889: FOR_TO
14890: IFFALSE 14957
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
14892: LD_VAR 0 1
14896: PPUSH
14897: LD_EXP 57
14901: PUSH
14902: LD_VAR 0 2
14906: ARRAY
14907: PUSH
14908: LD_VAR 0 3
14912: ARRAY
14913: PUSH
14914: LD_INT 1
14916: ARRAY
14917: PPUSH
14918: LD_EXP 57
14922: PUSH
14923: LD_VAR 0 2
14927: ARRAY
14928: PUSH
14929: LD_VAR 0 3
14933: ARRAY
14934: PUSH
14935: LD_INT 2
14937: ARRAY
14938: PPUSH
14939: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
14943: LD_VAR 0 1
14947: PPUSH
14948: LD_INT 70
14950: PPUSH
14951: CALL_OW 202
// end ;
14955: GO 14889
14957: POP
14958: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
14959: LD_VAR 0 1
14963: PPUSH
14964: CALL_OW 256
14968: PUSH
14969: LD_INT 700
14971: LESS
14972: PUSH
14973: LD_VAR 0 1
14977: PPUSH
14978: LD_INT 13
14980: PPUSH
14981: CALL_OW 308
14985: NOT
14986: AND
14987: IFFALSE 15039
// begin ComMoveToArea ( un , retreatArea ) ;
14989: LD_VAR 0 1
14993: PPUSH
14994: LD_INT 13
14996: PPUSH
14997: CALL_OW 113
// if not ru_alert_xy then
15001: LD_EXP 59
15005: NOT
15006: IFFALSE 15037
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
15008: LD_ADDR_EXP 59
15012: PUSH
15013: LD_VAR 0 1
15017: PPUSH
15018: CALL_OW 250
15022: PUSH
15023: LD_VAR 0 1
15027: PPUSH
15028: CALL_OW 251
15032: PUSH
15033: EMPTY
15034: LIST
15035: LIST
15036: ST_TO_ADDR
// end else
15037: GO 15108
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15039: LD_VAR 0 1
15043: PPUSH
15044: LD_VAR 0 4
15048: PPUSH
15049: LD_VAR 0 1
15053: PPUSH
15054: CALL_OW 74
15058: PPUSH
15059: CALL_OW 296
15063: PUSH
15064: LD_INT 9
15066: LESS
15067: PUSH
15068: LD_VAR 0 1
15072: PPUSH
15073: CALL_OW 256
15077: PUSH
15078: LD_INT 500
15080: GREATER
15081: AND
15082: IFFALSE 15108
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15084: LD_VAR 0 1
15088: PPUSH
15089: LD_VAR 0 4
15093: PPUSH
15094: LD_VAR 0 1
15098: PPUSH
15099: CALL_OW 74
15103: PPUSH
15104: CALL_OW 115
// end ;
15108: GO 14709
15110: POP
15111: POP
// end ;
15112: PPOPN 4
15114: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
15115: LD_EXP 58
15119: PUSH
15120: LD_EXP 59
15124: AND
15125: PUSH
15126: LD_EXP 29
15130: NOT
15131: AND
15132: PUSH
15133: LD_EXP 30
15137: NOT
15138: AND
15139: IFFALSE 15349
15141: GO 15143
15143: DISABLE
15144: LD_INT 0
15146: PPUSH
15147: PPUSH
// begin enable ;
15148: ENABLE
// if not ru_vehicles then
15149: LD_EXP 54
15153: NOT
15154: IFFALSE 15158
// exit ;
15156: GO 15349
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15158: LD_ADDR_VAR 0 2
15162: PUSH
15163: LD_INT 81
15165: PUSH
15166: LD_INT 3
15168: PUSH
15169: EMPTY
15170: LIST
15171: LIST
15172: PPUSH
15173: CALL_OW 69
15177: ST_TO_ADDR
// if ru_vehicles then
15178: LD_EXP 54
15182: IFFALSE 15349
// begin for i in ru_vehicles do
15184: LD_ADDR_VAR 0 1
15188: PUSH
15189: LD_EXP 54
15193: PUSH
15194: FOR_IN
15195: IFFALSE 15347
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
15197: LD_VAR 0 1
15201: PPUSH
15202: CALL_OW 302
15206: PUSH
15207: LD_VAR 0 1
15211: PPUSH
15212: LD_VAR 0 2
15216: PPUSH
15217: LD_VAR 0 1
15221: PPUSH
15222: CALL_OW 74
15226: PPUSH
15227: CALL_OW 296
15231: PUSH
15232: LD_INT 9
15234: LESS
15235: AND
15236: IFFALSE 15262
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15238: LD_VAR 0 1
15242: PPUSH
15243: LD_VAR 0 2
15247: PPUSH
15248: LD_VAR 0 1
15252: PPUSH
15253: CALL_OW 74
15257: PPUSH
15258: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
15262: LD_VAR 0 1
15266: PPUSH
15267: CALL_OW 314
15271: NOT
15272: PUSH
15273: LD_VAR 0 1
15277: PPUSH
15278: CALL_OW 302
15282: AND
15283: PUSH
15284: LD_VAR 0 1
15288: PPUSH
15289: LD_EXP 59
15293: PUSH
15294: LD_INT 1
15296: ARRAY
15297: PPUSH
15298: LD_EXP 59
15302: PUSH
15303: LD_INT 2
15305: ARRAY
15306: PPUSH
15307: CALL_OW 297
15311: PUSH
15312: LD_INT 10
15314: GREATER
15315: AND
15316: IFFALSE 15345
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
15318: LD_VAR 0 1
15322: PPUSH
15323: LD_EXP 59
15327: PUSH
15328: LD_INT 1
15330: ARRAY
15331: PPUSH
15332: LD_EXP 59
15336: PUSH
15337: LD_INT 2
15339: ARRAY
15340: PPUSH
15341: CALL_OW 114
// end ;
15345: GO 15194
15347: POP
15348: POP
// end ; end ;
15349: PPOPN 2
15351: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
15352: LD_EXP 59
15356: PUSH
15357: LD_EXP 58
15361: AND
15362: PUSH
15363: LD_INT 3
15365: PPUSH
15366: CALL_OW 463
15370: NOT
15371: AND
15372: PUSH
15373: LD_EXP 29
15377: NOT
15378: AND
15379: PUSH
15380: LD_EXP 30
15384: NOT
15385: AND
15386: IFFALSE 15481
15388: GO 15390
15390: DISABLE
15391: LD_INT 0
15393: PPUSH
// begin enable ;
15394: ENABLE
// ru_alert_xy := false ;
15395: LD_ADDR_EXP 59
15399: PUSH
15400: LD_INT 0
15402: ST_TO_ADDR
// ru_alert := false ;
15403: LD_ADDR_EXP 58
15407: PUSH
15408: LD_INT 0
15410: ST_TO_ADDR
// if ru_vehicles then
15411: LD_EXP 54
15415: IFFALSE 15481
// for i in ru_vehicles do
15417: LD_ADDR_VAR 0 1
15421: PUSH
15422: LD_EXP 54
15426: PUSH
15427: FOR_IN
15428: IFFALSE 15479
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
15430: LD_VAR 0 1
15434: PPUSH
15435: CALL_OW 302
15439: PUSH
15440: LD_VAR 0 1
15444: PPUSH
15445: LD_INT 89
15447: PPUSH
15448: LD_INT 36
15450: PPUSH
15451: CALL_OW 297
15455: PUSH
15456: LD_INT 10
15458: GREATER
15459: AND
15460: IFFALSE 15477
// ComMoveXY ( i , 89 , 36 ) ;
15462: LD_VAR 0 1
15466: PPUSH
15467: LD_INT 89
15469: PPUSH
15470: LD_INT 36
15472: PPUSH
15473: CALL_OW 111
15477: GO 15427
15479: POP
15480: POP
// end ;
15481: PPOPN 1
15483: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
15484: LD_EXP 53
15488: PUSH
15489: LD_EXP 29
15493: NOT
15494: AND
15495: PUSH
15496: LD_EXP 30
15500: NOT
15501: AND
15502: IFFALSE 15786
15504: GO 15506
15506: DISABLE
15507: LD_INT 0
15509: PPUSH
15510: PPUSH
15511: PPUSH
// begin enable ;
15512: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15513: LD_ADDR_VAR 0 3
15517: PUSH
15518: LD_INT 81
15520: PUSH
15521: LD_INT 3
15523: PUSH
15524: EMPTY
15525: LIST
15526: LIST
15527: PPUSH
15528: CALL_OW 69
15532: ST_TO_ADDR
// for i = 1 to ru_forest do
15533: LD_ADDR_VAR 0 1
15537: PUSH
15538: DOUBLE
15539: LD_INT 1
15541: DEC
15542: ST_TO_ADDR
15543: LD_EXP 53
15547: PUSH
15548: FOR_TO
15549: IFFALSE 15784
// begin un := ru_forest [ i ] ;
15551: LD_ADDR_VAR 0 2
15555: PUSH
15556: LD_EXP 53
15560: PUSH
15561: LD_VAR 0 1
15565: ARRAY
15566: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15567: LD_VAR 0 2
15571: PPUSH
15572: LD_INT 13
15574: PPUSH
15575: CALL_OW 308
15579: IFFALSE 15669
// begin if not See ( 1 , un ) then
15581: LD_INT 1
15583: PPUSH
15584: LD_VAR 0 2
15588: PPUSH
15589: CALL_OW 292
15593: NOT
15594: IFFALSE 15608
// SetLives ( un , 1000 ) ;
15596: LD_VAR 0 2
15600: PPUSH
15601: LD_INT 1000
15603: PPUSH
15604: CALL_OW 234
// ru_forest := ru_forest diff un ;
15608: LD_ADDR_EXP 53
15612: PUSH
15613: LD_EXP 53
15617: PUSH
15618: LD_VAR 0 2
15622: DIFF
15623: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15624: LD_VAR 0 2
15628: PPUSH
15629: LD_INT 22
15631: PUSH
15632: LD_INT 3
15634: PUSH
15635: EMPTY
15636: LIST
15637: LIST
15638: PUSH
15639: LD_INT 30
15641: PUSH
15642: LD_INT 4
15644: PUSH
15645: EMPTY
15646: LIST
15647: LIST
15648: PUSH
15649: EMPTY
15650: LIST
15651: LIST
15652: PPUSH
15653: CALL_OW 69
15657: PPUSH
15658: CALL 1039 0 1
15662: PPUSH
15663: CALL_OW 120
// continue ;
15667: GO 15548
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15669: LD_VAR 0 2
15673: PPUSH
15674: CALL_OW 256
15678: PUSH
15679: LD_INT 700
15681: LESS
15682: PUSH
15683: LD_VAR 0 2
15687: PPUSH
15688: LD_INT 13
15690: PPUSH
15691: CALL_OW 308
15695: NOT
15696: AND
15697: IFFALSE 15713
// ComMoveToArea ( un , retreatArea ) else
15699: LD_VAR 0 2
15703: PPUSH
15704: LD_INT 13
15706: PPUSH
15707: CALL_OW 113
15711: GO 15782
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15713: LD_VAR 0 2
15717: PPUSH
15718: LD_VAR 0 3
15722: PPUSH
15723: LD_VAR 0 2
15727: PPUSH
15728: CALL_OW 74
15732: PPUSH
15733: CALL_OW 296
15737: PUSH
15738: LD_INT 9
15740: LESS
15741: PUSH
15742: LD_VAR 0 2
15746: PPUSH
15747: CALL_OW 256
15751: PUSH
15752: LD_INT 500
15754: GREATER
15755: AND
15756: IFFALSE 15782
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15758: LD_VAR 0 2
15762: PPUSH
15763: LD_VAR 0 3
15767: PPUSH
15768: LD_VAR 0 2
15772: PPUSH
15773: CALL_OW 74
15777: PPUSH
15778: CALL_OW 115
// end ;
15782: GO 15548
15784: POP
15785: POP
// end ;
15786: PPOPN 3
15788: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
15789: LD_EXP 30
15793: NOT
15794: IFFALSE 15915
15796: GO 15798
15798: DISABLE
15799: LD_INT 0
15801: PPUSH
15802: PPUSH
// begin enable ;
15803: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
15804: LD_ADDR_VAR 0 2
15808: PUSH
15809: LD_INT 22
15811: PUSH
15812: LD_INT 3
15814: PUSH
15815: EMPTY
15816: LIST
15817: LIST
15818: PUSH
15819: LD_INT 21
15821: PUSH
15822: LD_INT 3
15824: PUSH
15825: EMPTY
15826: LIST
15827: LIST
15828: PUSH
15829: EMPTY
15830: LIST
15831: LIST
15832: PPUSH
15833: CALL_OW 69
15837: ST_TO_ADDR
// if filter then
15838: LD_VAR 0 2
15842: IFFALSE 15915
// for i in filter do
15844: LD_ADDR_VAR 0 1
15848: PUSH
15849: LD_VAR 0 2
15853: PUSH
15854: FOR_IN
15855: IFFALSE 15913
// if GetLives ( i ) < 990 then
15857: LD_VAR 0 1
15861: PPUSH
15862: CALL_OW 256
15866: PUSH
15867: LD_INT 990
15869: LESS
15870: IFFALSE 15911
// begin ru_alert := true ;
15872: LD_ADDR_EXP 58
15876: PUSH
15877: LD_INT 1
15879: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
15880: LD_ADDR_EXP 59
15884: PUSH
15885: LD_VAR 0 1
15889: PPUSH
15890: CALL_OW 250
15894: PUSH
15895: LD_VAR 0 1
15899: PPUSH
15900: CALL_OW 251
15904: PUSH
15905: EMPTY
15906: LIST
15907: LIST
15908: ST_TO_ADDR
// break ;
15909: GO 15913
// end ;
15911: GO 15854
15913: POP
15914: POP
// end ;
15915: PPOPN 2
15917: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
15918: LD_EXP 29
15922: IFFALSE 16071
15924: GO 15926
15926: DISABLE
15927: LD_INT 0
15929: PPUSH
15930: PPUSH
15931: PPUSH
15932: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
15933: LD_ADDR_VAR 0 4
15937: PUSH
15938: LD_EXP 54
15942: PUSH
15943: LD_EXP 53
15947: ADD
15948: PUSH
15949: LD_EXP 51
15953: ADD
15954: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
15955: LD_ADDR_VAR 0 3
15959: PUSH
15960: LD_INT 3
15962: PPUSH
15963: LD_INT 81
15965: PUSH
15966: LD_INT 3
15968: PUSH
15969: EMPTY
15970: LIST
15971: LIST
15972: PPUSH
15973: CALL_OW 70
15977: ST_TO_ADDR
// if filter and enemy then
15978: LD_VAR 0 4
15982: PUSH
15983: LD_VAR 0 3
15987: AND
15988: IFFALSE 16071
// repeat wait ( 0 0$01 ) ;
15990: LD_INT 35
15992: PPUSH
15993: CALL_OW 67
// for i in filter do
15997: LD_ADDR_VAR 0 1
16001: PUSH
16002: LD_VAR 0 4
16006: PUSH
16007: FOR_IN
16008: IFFALSE 16036
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16010: LD_VAR 0 1
16014: PPUSH
16015: LD_VAR 0 3
16019: PPUSH
16020: LD_VAR 0 1
16024: PPUSH
16025: CALL_OW 74
16029: PPUSH
16030: CALL_OW 115
// end ;
16034: GO 16007
16036: POP
16037: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
16038: LD_INT 3
16040: PPUSH
16041: LD_INT 81
16043: PUSH
16044: LD_INT 3
16046: PUSH
16047: EMPTY
16048: LIST
16049: LIST
16050: PPUSH
16051: CALL_OW 70
16055: PUSH
16056: LD_INT 0
16058: EQUAL
16059: PUSH
16060: LD_VAR 0 4
16064: PUSH
16065: LD_INT 0
16067: EQUAL
16068: OR
16069: IFFALSE 15990
// end ;
16071: PPOPN 4
16073: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) do var i ;
16074: LD_EXP 25
16078: PUSH
16079: LD_INT 22
16081: PUSH
16082: LD_INT 4
16084: PUSH
16085: EMPTY
16086: LIST
16087: LIST
16088: PUSH
16089: LD_INT 30
16091: PUSH
16092: LD_INT 4
16094: PUSH
16095: EMPTY
16096: LIST
16097: LIST
16098: PUSH
16099: EMPTY
16100: LIST
16101: LIST
16102: PPUSH
16103: CALL_OW 69
16107: AND
16108: IFFALSE 16157
16110: GO 16112
16112: DISABLE
16113: LD_INT 0
16115: PPUSH
// begin if not ru_cornel_attack then
16116: LD_EXP 56
16120: NOT
16121: IFFALSE 16125
// exit ;
16123: GO 16157
// for i in ru_cornel_attack do
16125: LD_ADDR_VAR 0 1
16129: PUSH
16130: LD_EXP 56
16134: PUSH
16135: FOR_IN
16136: IFFALSE 16155
// ComAgressiveMove ( i , 258 , 119 ) ;
16138: LD_VAR 0 1
16142: PPUSH
16143: LD_INT 258
16145: PPUSH
16146: LD_INT 119
16148: PPUSH
16149: CALL_OW 114
16153: GO 16135
16155: POP
16156: POP
// end ; end_of_file
16157: PPOPN 1
16159: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
16160: LD_EXP 5
16164: PUSH
16165: LD_EXP 9
16169: NOT
16170: AND
16171: PUSH
16172: LD_EXP 19
16176: AND
16177: IFFALSE 16289
16179: GO 16181
16181: DISABLE
16182: LD_INT 0
16184: PPUSH
// begin enable ;
16185: ENABLE
// crates_counter := crates_counter - 50 ;
16186: LD_ADDR_EXP 19
16190: PUSH
16191: LD_EXP 19
16195: PUSH
16196: LD_INT 50
16198: MINUS
16199: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
16200: LD_INT 8
16202: PPUSH
16203: LD_INT 2
16205: PPUSH
16206: LD_INT 5
16208: PPUSH
16209: CALL_OW 12
16213: PPUSH
16214: LD_INT 1
16216: PPUSH
16217: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
16221: LD_INT 1785
16223: PPUSH
16224: LD_INT 2345
16226: PPUSH
16227: CALL_OW 12
16231: PPUSH
16232: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
16236: LD_ADDR_VAR 0 1
16240: PUSH
16241: LD_INT 1
16243: PPUSH
16244: LD_OWVAR 67
16248: PUSH
16249: LD_INT 2
16251: PLUS
16252: PPUSH
16253: CALL_OW 12
16257: ST_TO_ADDR
// if r < 3 then
16258: LD_VAR 0 1
16262: PUSH
16263: LD_INT 3
16265: LESS
16266: IFFALSE 16289
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
16268: LD_INT 4
16270: PPUSH
16271: LD_INT 1
16273: PPUSH
16274: LD_INT 5
16276: PPUSH
16277: CALL_OW 12
16281: PPUSH
16282: LD_INT 1
16284: PPUSH
16285: CALL_OW 55
// end ;
16289: PPOPN 1
16291: END
// every 0 0$01 trigger cornel_active do
16292: LD_EXP 8
16296: IFFALSE 16385
16298: GO 16300
16300: DISABLE
// begin Wait ( 0 0$03 ) ;
16301: LD_INT 105
16303: PPUSH
16304: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16308: LD_INT 2
16310: PPUSH
16311: LD_INT 5
16313: PPUSH
16314: CALL_OW 12
16318: PPUSH
16319: LD_INT 10
16321: PPUSH
16322: LD_INT 1
16324: PPUSH
16325: CALL_OW 55
// Wait ( 0 0$13 ) ;
16329: LD_INT 455
16331: PPUSH
16332: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16336: LD_INT 2
16338: PPUSH
16339: LD_INT 5
16341: PPUSH
16342: CALL_OW 12
16346: PPUSH
16347: LD_INT 10
16349: PPUSH
16350: LD_INT 1
16352: PPUSH
16353: CALL_OW 55
// Wait ( 0 0$16 ) ;
16357: LD_INT 560
16359: PPUSH
16360: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16364: LD_INT 2
16366: PPUSH
16367: LD_INT 5
16369: PPUSH
16370: CALL_OW 12
16374: PPUSH
16375: LD_INT 10
16377: PPUSH
16378: LD_INT 1
16380: PPUSH
16381: CALL_OW 55
// end ; end_of_file
16385: END
// every 0 0$01 trigger cornel_prepared do
16386: LD_EXP 11
16390: IFFALSE 16449
16392: GO 16394
16394: DISABLE
// begin enable ;
16395: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
16396: LD_ADDR_OWVAR 47
16400: PUSH
16401: LD_STRING #Am03-1
16403: PUSH
16404: LD_EXP 10
16408: PUSH
16409: EMPTY
16410: LIST
16411: LIST
16412: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
16413: LD_ADDR_EXP 10
16417: PUSH
16418: LD_EXP 10
16422: PPUSH
16423: LD_STRING -
16425: PPUSH
16426: CALL 1109 0 2
16430: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
16431: LD_EXP 10
16435: PUSH
16436: LD_INT 0
16438: EQUAL
16439: IFFALSE 16449
// begin Display_Strings := [ ] ;
16441: LD_ADDR_OWVAR 47
16445: PUSH
16446: EMPTY
16447: ST_TO_ADDR
// disable ;
16448: DISABLE
// end ; end ;
16449: END
// every 0 0$01 trigger debug and debug_strings do
16450: LD_EXP 1
16454: PUSH
16455: LD_OWVAR 48
16459: AND
16460: IFFALSE 16476
16462: GO 16464
16464: DISABLE
// begin enable ;
16465: ENABLE
// Display_Strings := debug_strings ;
16466: LD_ADDR_OWVAR 47
16470: PUSH
16471: LD_OWVAR 48
16475: ST_TO_ADDR
// end ; end_of_file
16476: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
16477: LD_VAR 0 1
16481: PPUSH
16482: CALL_OW 255
16486: PUSH
16487: LD_INT 1
16489: EQUAL
16490: PUSH
16491: LD_EXP 13
16495: NOT
16496: AND
16497: IFFALSE 16507
// solar_builded := true ;
16499: LD_ADDR_EXP 13
16503: PUSH
16504: LD_INT 1
16506: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
16507: LD_VAR 0 1
16511: PPUSH
16512: CALL_OW 255
16516: PUSH
16517: LD_INT 1
16519: EQUAL
16520: PUSH
16521: LD_EXP 27
16525: AND
16526: IFFALSE 16559
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
16528: LD_ADDR_EXP 27
16532: PUSH
16533: LD_EXP 27
16537: PUSH
16538: LD_INT 1750
16540: PUSH
16541: LD_INT 1400
16543: PUSH
16544: LD_INT 1225
16546: PUSH
16547: EMPTY
16548: LIST
16549: LIST
16550: LIST
16551: PUSH
16552: LD_OWVAR 67
16556: ARRAY
16557: PLUS
16558: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
16559: LD_VAR 0 1
16563: PPUSH
16564: CALL_OW 255
16568: PUSH
16569: LD_INT 3
16571: EQUAL
16572: IFFALSE 16590
// ru_vehicles := ru_vehicles ^ veh ;
16574: LD_ADDR_EXP 54
16578: PUSH
16579: LD_EXP 54
16583: PUSH
16584: LD_VAR 0 1
16588: ADD
16589: ST_TO_ADDR
// end ;
16590: PPOPN 2
16592: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
16593: LD_VAR 0 1
16597: PUSH
16598: LD_EXP 51
16602: IN
16603: IFFALSE 16621
// ru_patrol := ru_patrol diff un ;
16605: LD_ADDR_EXP 51
16609: PUSH
16610: LD_EXP 51
16614: PUSH
16615: LD_VAR 0 1
16619: DIFF
16620: ST_TO_ADDR
// if un in ru_forest then
16621: LD_VAR 0 1
16625: PUSH
16626: LD_EXP 53
16630: IN
16631: IFFALSE 16649
// ru_forest := ru_forest diff un ;
16633: LD_ADDR_EXP 53
16637: PUSH
16638: LD_EXP 53
16642: PUSH
16643: LD_VAR 0 1
16647: DIFF
16648: ST_TO_ADDR
// if un in ru_vehicles then
16649: LD_VAR 0 1
16653: PUSH
16654: LD_EXP 54
16658: IN
16659: IFFALSE 16734
// begin ru_vehicles := ru_vehicles diff un ;
16661: LD_ADDR_EXP 54
16665: PUSH
16666: LD_EXP 54
16670: PUSH
16671: LD_VAR 0 1
16675: DIFF
16676: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
16677: LD_ADDR_EXP 55
16681: PUSH
16682: LD_EXP 55
16686: PUSH
16687: LD_VAR 0 1
16691: PPUSH
16692: CALL_OW 265
16696: PUSH
16697: LD_VAR 0 1
16701: PPUSH
16702: CALL_OW 262
16706: PUSH
16707: LD_VAR 0 1
16711: PPUSH
16712: CALL_OW 263
16716: PUSH
16717: LD_VAR 0 1
16721: PPUSH
16722: CALL_OW 264
16726: PUSH
16727: EMPTY
16728: LIST
16729: LIST
16730: LIST
16731: LIST
16732: ADD
16733: ST_TO_ADDR
// end ; if un = JMM then
16734: LD_VAR 0 1
16738: PUSH
16739: LD_EXP 35
16743: EQUAL
16744: IFFALSE 16753
// YouLost ( 0 ) ;
16746: LD_STRING 0
16748: PPUSH
16749: CALL_OW 104
// if un = us_dep_west then
16753: LD_VAR 0 1
16757: PUSH
16758: LD_INT 1
16760: EQUAL
16761: IFFALSE 16770
// YouLost ( 2 ) ;
16763: LD_STRING 2
16765: PPUSH
16766: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
16770: LD_VAR 0 1
16774: PPUSH
16775: CALL_OW 255
16779: PUSH
16780: LD_INT 8
16782: EQUAL
16783: PUSH
16784: LD_EXP 5
16788: NOT
16789: AND
16790: IFFALSE 16799
// YouLost ( 4 ) ;
16792: LD_STRING 4
16794: PPUSH
16795: CALL_OW 104
// if un in jmm_units then
16799: LD_VAR 0 1
16803: PUSH
16804: LD_EXP 4
16808: IN
16809: IFFALSE 16825
// lose_counter := lose_counter + 1 ;
16811: LD_ADDR_EXP 32
16815: PUSH
16816: LD_EXP 32
16820: PUSH
16821: LD_INT 1
16823: PLUS
16824: ST_TO_ADDR
// end ;
16825: PPOPN 1
16827: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
16828: LD_INT 0
16830: PPUSH
16831: PPUSH
// begin if GetSide ( driver ) = 3 then
16832: LD_VAR 0 1
16836: PPUSH
16837: CALL_OW 255
16841: PUSH
16842: LD_INT 3
16844: EQUAL
16845: IFFALSE 16923
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
16847: LD_ADDR_VAR 0 6
16851: PUSH
16852: LD_INT 22
16854: PUSH
16855: LD_INT 3
16857: PUSH
16858: EMPTY
16859: LIST
16860: LIST
16861: PUSH
16862: LD_INT 30
16864: PUSH
16865: LD_INT 3
16867: PUSH
16868: EMPTY
16869: LIST
16870: LIST
16871: PUSH
16872: EMPTY
16873: LIST
16874: LIST
16875: PPUSH
16876: CALL_OW 69
16880: PPUSH
16881: CALL 1039 0 1
16885: ST_TO_ADDR
// if place then
16886: LD_VAR 0 6
16890: IFFALSE 16908
// ComEnterUnit ( driver , place ) else
16892: LD_VAR 0 1
16896: PPUSH
16897: LD_VAR 0 6
16901: PPUSH
16902: CALL_OW 120
16906: GO 16923
// ComMoveXY ( driver , 70 , 22 ) ;
16908: LD_VAR 0 1
16912: PPUSH
16913: LD_INT 70
16915: PPUSH
16916: LD_INT 22
16918: PPUSH
16919: CALL_OW 111
// end ; end ;
16923: PPOPN 6
16925: END
// every 0 0$01 trigger save_counter + ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
16926: LD_EXP 34
16930: PUSH
16931: LD_INT 22
16933: PUSH
16934: LD_INT 1
16936: PUSH
16937: EMPTY
16938: LIST
16939: LIST
16940: PUSH
16941: LD_INT 21
16943: PUSH
16944: LD_INT 1
16946: PUSH
16947: EMPTY
16948: LIST
16949: LIST
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: PPUSH
16955: CALL_OW 69
16959: PUSH
16960: LD_INT 22
16962: PUSH
16963: LD_INT 8
16965: PUSH
16966: EMPTY
16967: LIST
16968: LIST
16969: PUSH
16970: LD_INT 21
16972: PUSH
16973: LD_INT 1
16975: PUSH
16976: EMPTY
16977: LIST
16978: LIST
16979: PUSH
16980: EMPTY
16981: LIST
16982: LIST
16983: PPUSH
16984: CALL_OW 69
16988: ADD
16989: PLUS
16990: PUSH
16991: LD_INT 5
16993: LESS
16994: IFFALSE 17006
16996: GO 16998
16998: DISABLE
// YouLost ( 1 ) ;
16999: LD_STRING 1
17001: PPUSH
17002: CALL_OW 104
17006: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
17007: LD_INT 1
17009: PPUSH
17010: CALL_OW 255
17014: PUSH
17015: LD_INT 3
17017: EQUAL
17018: IFFALSE 17030
17020: GO 17022
17022: DISABLE
// YouLost ( 3 ) ;
17023: LD_STRING 3
17025: PPUSH
17026: CALL_OW 104
17030: END
