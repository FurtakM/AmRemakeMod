// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 355 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 443 0 0
// PrepareRussian ;
  22: CALL 2972 0 0
// PrepareAmerican ;
  26: CALL 1177 0 0
// PrepareCornell ;
  30: CALL 2201 0 0
// PrepareWesternBase ;
  34: CALL 2427 0 0
// Action ;
  38: CALL 5188 0 0
// end ;
  42: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn , save_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  54: LD_ADDR_EXP 3
  58: PUSH
  59: LD_STRING 02_
  61: ST_TO_ADDR
// mission_prefix := 03_ ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_STRING 03_
  69: ST_TO_ADDR
// jmm_units := 0 ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// cornel_units := 0 ;
  78: LD_ADDR_EXP 6
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// bierezov_exist := false ;
  86: LD_ADDR_EXP 7
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// jmm_on_west := false ;
  94: LD_ADDR_EXP 5
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_active := false ;
 102: LD_ADDR_EXP 8
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_attack := false ;
 110: LD_ADDR_EXP 9
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// cornel_prepared := false ;
 118: LD_ADDR_EXP 11
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 126: LD_ADDR_EXP 10
 130: PUSH
 131: LD_INT 4200
 133: ST_TO_ADDR
// frank_can_return := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// solar_builded := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// frank_send_to_scout := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// jmm_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// bobby_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// cyrus_in_veh := false ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// lisa_in_veh := false ;
 182: LD_ADDR_EXP 18
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 190: LD_ADDR_EXP 27
 194: PUSH
 195: LD_INT 25200
 197: PUSH
 198: LD_INT 23100
 200: PUSH
 201: LD_INT 21000
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: PUSH
 209: LD_OWVAR 67
 213: ARRAY
 214: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 215: LD_ADDR_EXP 19
 219: PUSH
 220: LD_INT 600
 222: PUSH
 223: LD_INT 500
 225: PUSH
 226: LD_INT 400
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: PUSH
 234: LD_OWVAR 67
 238: ARRAY
 239: ST_TO_ADDR
// end_mission_allowed := false ;
 240: LD_ADDR_EXP 20
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// save_others := [ ] ;
 248: LD_ADDR_EXP 21
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// save_group := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// show_query := true ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// wait_for_them := false ;
 270: LD_ADDR_EXP 24
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// veh_on_meta := false ;
 278: LD_ADDR_EXP 26
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_spec_patrol := false ;
 286: LD_ADDR_EXP 28
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// prepare_siege := false ;
 294: LD_ADDR_EXP 29
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// send_attack_on_cornel := false ;
 302: LD_ADDR_EXP 30
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 310: LD_ADDR_EXP 25
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// game_end := false ;
 318: LD_ADDR_EXP 31
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// lose_counter := 0 ;
 326: LD_ADDR_EXP 32
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// powell_warn := 0 ;
 334: LD_ADDR_EXP 33
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// save_counter := 0 ;
 342: LD_ADDR_EXP 34
 346: PUSH
 347: LD_INT 0
 349: ST_TO_ADDR
// end ;
 350: LD_VAR 0 1
 354: RET
// function SetDiplomacy ; begin
 355: LD_INT 0
 357: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 358: LD_INT 1
 360: PPUSH
 361: LD_INT 4
 363: PPUSH
 364: LD_INT 1
 366: PPUSH
 367: LD_INT 1
 369: PPUSH
 370: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 374: LD_INT 1
 376: PPUSH
 377: LD_INT 8
 379: PPUSH
 380: LD_INT 1
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 390: LD_INT 3
 392: PPUSH
 393: LD_INT 6
 395: PPUSH
 396: LD_INT 1
 398: PPUSH
 399: LD_INT 1
 401: PPUSH
 402: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 406: LD_INT 4
 408: PPUSH
 409: LD_INT 6
 411: PPUSH
 412: LD_INT 0
 414: PPUSH
 415: LD_INT 1
 417: PPUSH
 418: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 422: LD_INT 3
 424: PPUSH
 425: LD_INT 8
 427: PPUSH
 428: LD_INT 0
 430: PPUSH
 431: LD_INT 1
 433: PPUSH
 434: CALL_OW 80
// end ;
 438: LD_VAR 0 1
 442: RET
// export function DebugMode ; var i ; begin
 443: LD_INT 0
 445: PPUSH
 446: PPUSH
// FogOff ( 1 ) ;
 447: LD_INT 1
 449: PPUSH
 450: CALL_OW 344
// debug_strings := [ ] ;
 454: LD_ADDR_OWVAR 48
 458: PUSH
 459: EMPTY
 460: ST_TO_ADDR
// end ; end_of_file
 461: LD_VAR 0 1
 465: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 466: LD_INT 0
 468: PPUSH
 469: PPUSH
// if exist_mode then
 470: LD_VAR 0 2
 474: IFFALSE 499
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 476: LD_ADDR_VAR 0 4
 480: PUSH
 481: LD_EXP 3
 485: PUSH
 486: LD_VAR 0 1
 490: STR
 491: PPUSH
 492: CALL_OW 34
 496: ST_TO_ADDR
 497: GO 514
// unit := NewCharacter ( ident ) ;
 499: LD_ADDR_VAR 0 4
 503: PUSH
 504: LD_VAR 0 1
 508: PPUSH
 509: CALL_OW 25
 513: ST_TO_ADDR
// result := unit ;
 514: LD_ADDR_VAR 0 3
 518: PUSH
 519: LD_VAR 0 4
 523: ST_TO_ADDR
// end ;
 524: LD_VAR 0 3
 528: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 529: LD_INT 0
 531: PPUSH
// uc_side := side ;
 532: LD_ADDR_OWVAR 20
 536: PUSH
 537: LD_VAR 0 1
 541: ST_TO_ADDR
// uc_nation := nation ;
 542: LD_ADDR_OWVAR 21
 546: PUSH
 547: LD_VAR 0 2
 551: ST_TO_ADDR
// vc_chassis := chassis ;
 552: LD_ADDR_OWVAR 37
 556: PUSH
 557: LD_VAR 0 3
 561: ST_TO_ADDR
// vc_engine := engine ;
 562: LD_ADDR_OWVAR 39
 566: PUSH
 567: LD_VAR 0 4
 571: ST_TO_ADDR
// vc_control := control ;
 572: LD_ADDR_OWVAR 38
 576: PUSH
 577: LD_VAR 0 5
 581: ST_TO_ADDR
// vc_weapon := weapon ;
 582: LD_ADDR_OWVAR 40
 586: PUSH
 587: LD_VAR 0 6
 591: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 592: LD_ADDR_OWVAR 41
 596: PUSH
 597: LD_VAR 0 7
 601: ST_TO_ADDR
// result := CreateVehicle ;
 602: LD_ADDR_VAR 0 8
 606: PUSH
 607: CALL_OW 45
 611: ST_TO_ADDR
// end ;
 612: LD_VAR 0 8
 616: RET
// export function SayX ( units , ident ) ; var i ; begin
 617: LD_INT 0
 619: PPUSH
 620: PPUSH
// result := false ;
 621: LD_ADDR_VAR 0 3
 625: PUSH
 626: LD_INT 0
 628: ST_TO_ADDR
// if not units then
 629: LD_VAR 0 1
 633: NOT
 634: IFFALSE 638
// exit ;
 636: GO 692
// for i in units do
 638: LD_ADDR_VAR 0 4
 642: PUSH
 643: LD_VAR 0 1
 647: PUSH
 648: FOR_IN
 649: IFFALSE 690
// if IsOk ( i ) then
 651: LD_VAR 0 4
 655: PPUSH
 656: CALL_OW 302
 660: IFFALSE 688
// begin Say ( i , ident ) ;
 662: LD_VAR 0 4
 666: PPUSH
 667: LD_VAR 0 2
 671: PPUSH
 672: CALL_OW 88
// result := i ;
 676: LD_ADDR_VAR 0 3
 680: PUSH
 681: LD_VAR 0 4
 685: ST_TO_ADDR
// break ;
 686: GO 690
// end ;
 688: GO 648
 690: POP
 691: POP
// end ;
 692: LD_VAR 0 3
 696: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 697: LD_INT 0
 699: PPUSH
 700: PPUSH
 701: PPUSH
 702: PPUSH
// for i = 1 to count do
 703: LD_ADDR_VAR 0 8
 707: PUSH
 708: DOUBLE
 709: LD_INT 1
 711: DEC
 712: ST_TO_ADDR
 713: LD_VAR 0 6
 717: PUSH
 718: FOR_TO
 719: IFFALSE 800
// begin uc_side = side ;
 721: LD_ADDR_OWVAR 20
 725: PUSH
 726: LD_VAR 0 1
 730: ST_TO_ADDR
// uc_nation = nation ;
 731: LD_ADDR_OWVAR 21
 735: PUSH
 736: LD_VAR 0 2
 740: ST_TO_ADDR
// hc_gallery =  ;
 741: LD_ADDR_OWVAR 33
 745: PUSH
 746: LD_STRING 
 748: ST_TO_ADDR
// hc_name =  ;
 749: LD_ADDR_OWVAR 26
 753: PUSH
 754: LD_STRING 
 756: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 757: LD_INT 0
 759: PPUSH
 760: LD_VAR 0 5
 764: PPUSH
 765: LD_VAR 0 4
 769: PPUSH
 770: CALL_OW 380
// un = CreateHuman ;
 774: LD_ADDR_VAR 0 10
 778: PUSH
 779: CALL_OW 44
 783: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 784: LD_VAR 0 10
 788: PPUSH
 789: LD_VAR 0 3
 793: PPUSH
 794: CALL_OW 52
// end ;
 798: GO 718
 800: POP
 801: POP
// end ;
 802: LD_VAR 0 7
 806: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 807: LD_INT 0
 809: PPUSH
 810: PPUSH
 811: PPUSH
// uc_side := GetSide ( b ) ;
 812: LD_ADDR_OWVAR 20
 816: PUSH
 817: LD_VAR 0 2
 821: PPUSH
 822: CALL_OW 255
 826: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 827: LD_ADDR_OWVAR 21
 831: PUSH
 832: LD_VAR 0 2
 836: PPUSH
 837: CALL_OW 248
 841: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 842: LD_INT 0
 844: PPUSH
 845: LD_INT 1
 847: PPUSH
 848: LD_VAR 0 1
 852: PPUSH
 853: CALL_OW 380
// un = CreateHuman ;
 857: LD_ADDR_VAR 0 4
 861: PUSH
 862: CALL_OW 44
 866: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 867: LD_ADDR_VAR 0 5
 871: PUSH
 872: LD_VAR 0 2
 876: PPUSH
 877: CALL_OW 254
 881: PUSH
 882: LD_INT 3
 884: MINUS
 885: ST_TO_ADDR
// if dir < 0 then
 886: LD_VAR 0 5
 890: PUSH
 891: LD_INT 0
 893: LESS
 894: IFFALSE 910
// dir := 6 + dir ;
 896: LD_ADDR_VAR 0 5
 900: PUSH
 901: LD_INT 6
 903: PUSH
 904: LD_VAR 0 5
 908: PLUS
 909: ST_TO_ADDR
// SetDir ( un , dir ) ;
 910: LD_VAR 0 4
 914: PPUSH
 915: LD_VAR 0 5
 919: PPUSH
 920: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 924: LD_VAR 0 4
 928: PPUSH
 929: LD_VAR 0 2
 933: PPUSH
 934: CALL_OW 52
// end ;
 938: LD_VAR 0 3
 942: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 943: LD_INT 0
 945: PPUSH
 946: PPUSH
 947: PPUSH
// result := false ;
 948: LD_ADDR_VAR 0 2
 952: PUSH
 953: LD_INT 0
 955: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 956: LD_ADDR_VAR 0 3
 960: PUSH
 961: LD_INT 22
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: PUSH
 971: LD_INT 34
 973: PUSH
 974: LD_INT 2
 976: PUSH
 977: EMPTY
 978: LIST
 979: LIST
 980: PUSH
 981: EMPTY
 982: LIST
 983: LIST
 984: PPUSH
 985: CALL_OW 69
 989: ST_TO_ADDR
// for i in filter do
 990: LD_ADDR_VAR 0 4
 994: PUSH
 995: LD_VAR 0 3
 999: PUSH
1000: FOR_IN
1001: IFFALSE 1032
// if IsDrivenBy ( i ) = unit then
1003: LD_VAR 0 4
1007: PPUSH
1008: CALL_OW 311
1012: PUSH
1013: LD_VAR 0 1
1017: EQUAL
1018: IFFALSE 1030
// begin result := true ;
1020: LD_ADDR_VAR 0 2
1024: PUSH
1025: LD_INT 1
1027: ST_TO_ADDR
// break ;
1028: GO 1032
// end ;
1030: GO 1000
1032: POP
1033: POP
// end ;
1034: LD_VAR 0 2
1038: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1039: LD_INT 0
1041: PPUSH
1042: PPUSH
// result := false ;
1043: LD_ADDR_VAR 0 2
1047: PUSH
1048: LD_INT 0
1050: ST_TO_ADDR
// if not blist then
1051: LD_VAR 0 1
1055: NOT
1056: IFFALSE 1060
// exit ;
1058: GO 1104
// for i in blist do
1060: LD_ADDR_VAR 0 3
1064: PUSH
1065: LD_VAR 0 1
1069: PUSH
1070: FOR_IN
1071: IFFALSE 1102
// if UnitsInside ( i ) < 6 then
1073: LD_VAR 0 3
1077: PPUSH
1078: CALL_OW 313
1082: PUSH
1083: LD_INT 6
1085: LESS
1086: IFFALSE 1100
// begin result := i ;
1088: LD_ADDR_VAR 0 2
1092: PUSH
1093: LD_VAR 0 3
1097: ST_TO_ADDR
// break ;
1098: GO 1102
// end ;
1100: GO 1070
1102: POP
1103: POP
// end ;
1104: LD_VAR 0 2
1108: RET
// export function Count ( timer , mode ) ; begin
1109: LD_INT 0
1111: PPUSH
// if not timer then
1112: LD_VAR 0 1
1116: NOT
1117: IFFALSE 1121
// exit ;
1119: GO 1172
// if mode in [ asc , up , + ] then
1121: LD_VAR 0 2
1125: PUSH
1126: LD_STRING asc
1128: PUSH
1129: LD_STRING up
1131: PUSH
1132: LD_STRING +
1134: PUSH
1135: EMPTY
1136: LIST
1137: LIST
1138: LIST
1139: IN
1140: IFFALSE 1158
// result := timer + 0 0$01 else
1142: LD_ADDR_VAR 0 3
1146: PUSH
1147: LD_VAR 0 1
1151: PUSH
1152: LD_INT 35
1154: PLUS
1155: ST_TO_ADDR
1156: GO 1172
// result := timer - 0 0$01 ;
1158: LD_ADDR_VAR 0 3
1162: PUSH
1163: LD_VAR 0 1
1167: PUSH
1168: LD_INT 35
1170: MINUS
1171: ST_TO_ADDR
// end ; end_of_file
1172: LD_VAR 0 3
1176: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1177: LD_INT 0
1179: PPUSH
1180: PPUSH
1181: PPUSH
1182: PPUSH
1183: PPUSH
1184: PPUSH
1185: PPUSH
1186: PPUSH
// uc_side := 4 ;
1187: LD_ADDR_OWVAR 20
1191: PUSH
1192: LD_INT 4
1194: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1195: LD_ADDR_EXP 44
1199: PUSH
1200: LD_STRING Powell
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL 466 0 2
1210: ST_TO_ADDR
// uc_side := 1 ;
1211: LD_ADDR_OWVAR 20
1215: PUSH
1216: LD_INT 1
1218: ST_TO_ADDR
// uc_nation := 1 ;
1219: LD_ADDR_OWVAR 21
1223: PUSH
1224: LD_INT 1
1226: ST_TO_ADDR
// if debug then
1227: LD_EXP 1
1231: IFFALSE 1361
// begin for i = 1 to 4 do
1233: LD_ADDR_VAR 0 2
1237: PUSH
1238: DOUBLE
1239: LD_INT 1
1241: DEC
1242: ST_TO_ADDR
1243: LD_INT 4
1245: PUSH
1246: FOR_TO
1247: IFFALSE 1298
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1249: LD_INT 0
1251: PPUSH
1252: LD_INT 1
1254: PPUSH
1255: LD_INT 2
1257: PPUSH
1258: CALL_OW 12
1262: PPUSH
1263: LD_INT 3
1265: PPUSH
1266: CALL_OW 380
// un := CreateHuman ;
1270: LD_ADDR_VAR 0 3
1274: PUSH
1275: CALL_OW 44
1279: ST_TO_ADDR
// others := others ^ un ;
1280: LD_ADDR_VAR 0 5
1284: PUSH
1285: LD_VAR 0 5
1289: PUSH
1290: LD_VAR 0 3
1294: ADD
1295: ST_TO_ADDR
// end ;
1296: GO 1246
1298: POP
1299: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1300: LD_ADDR_VAR 0 6
1304: PUSH
1305: LD_INT 21
1307: PUSH
1308: LD_INT 1
1310: PUSH
1311: LD_INT 1
1313: PUSH
1314: LD_INT 51
1316: PUSH
1317: LD_INT 90
1319: PUSH
1320: LD_INT 504
1322: PUSH
1323: EMPTY
1324: LIST
1325: LIST
1326: LIST
1327: LIST
1328: LIST
1329: LIST
1330: PUSH
1331: LD_INT 21
1333: PUSH
1334: LD_INT 1
1336: PUSH
1337: LD_INT 1
1339: PUSH
1340: LD_INT 51
1342: PUSH
1343: LD_INT 80
1345: PUSH
1346: LD_INT 750
1348: PUSH
1349: EMPTY
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: LIST
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1361: LD_ADDR_EXP 35
1365: PUSH
1366: LD_STRING JMM
1368: PPUSH
1369: LD_EXP 1
1373: NOT
1374: PPUSH
1375: CALL 466 0 2
1379: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1380: LD_ADDR_EXP 36
1384: PUSH
1385: LD_STRING Bobby
1387: PPUSH
1388: LD_EXP 1
1392: NOT
1393: PPUSH
1394: CALL 466 0 2
1398: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1399: LD_ADDR_EXP 37
1403: PUSH
1404: LD_STRING Cyrus
1406: PPUSH
1407: LD_EXP 1
1411: NOT
1412: PPUSH
1413: CALL 466 0 2
1417: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1418: LD_ADDR_EXP 38
1422: PUSH
1423: LD_STRING Lisa
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: CALL 466 0 2
1436: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1437: LD_ADDR_EXP 39
1441: PUSH
1442: LD_STRING Khatam
1444: PPUSH
1445: LD_EXP 1
1449: NOT
1450: PPUSH
1451: CALL 466 0 2
1455: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1456: LD_ADDR_EXP 40
1460: PUSH
1461: LD_STRING Brian
1463: PPUSH
1464: LD_EXP 1
1468: NOT
1469: PPUSH
1470: CALL 466 0 2
1474: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1475: LD_ADDR_EXP 41
1479: PUSH
1480: LD_STRING Jerry
1482: PPUSH
1483: LD_EXP 1
1487: NOT
1488: PPUSH
1489: CALL 466 0 2
1493: ST_TO_ADDR
// if Bobby then
1494: LD_EXP 36
1498: IFFALSE 1529
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1500: LD_ADDR_VAR 0 4
1504: PUSH
1505: LD_VAR 0 4
1509: PPUSH
1510: LD_VAR 0 4
1514: PUSH
1515: LD_INT 1
1517: PLUS
1518: PPUSH
1519: LD_EXP 36
1523: PPUSH
1524: CALL_OW 2
1528: ST_TO_ADDR
// if Cyrus then
1529: LD_EXP 37
1533: IFFALSE 1564
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1535: LD_ADDR_VAR 0 4
1539: PUSH
1540: LD_VAR 0 4
1544: PPUSH
1545: LD_VAR 0 4
1549: PUSH
1550: LD_INT 1
1552: PLUS
1553: PPUSH
1554: LD_EXP 37
1558: PPUSH
1559: CALL_OW 2
1563: ST_TO_ADDR
// if Lisa then
1564: LD_EXP 38
1568: IFFALSE 1599
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1570: LD_ADDR_VAR 0 4
1574: PUSH
1575: LD_VAR 0 4
1579: PPUSH
1580: LD_VAR 0 4
1584: PUSH
1585: LD_INT 1
1587: PLUS
1588: PPUSH
1589: LD_EXP 38
1593: PPUSH
1594: CALL_OW 2
1598: ST_TO_ADDR
// if Khatam then
1599: LD_EXP 39
1603: IFFALSE 1634
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1605: LD_ADDR_VAR 0 4
1609: PUSH
1610: LD_VAR 0 4
1614: PPUSH
1615: LD_VAR 0 4
1619: PUSH
1620: LD_INT 1
1622: PLUS
1623: PPUSH
1624: LD_EXP 39
1628: PPUSH
1629: CALL_OW 2
1633: ST_TO_ADDR
// if Brian then
1634: LD_EXP 40
1638: IFFALSE 1669
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1640: LD_ADDR_VAR 0 4
1644: PUSH
1645: LD_VAR 0 4
1649: PPUSH
1650: LD_VAR 0 4
1654: PUSH
1655: LD_INT 1
1657: PLUS
1658: PPUSH
1659: LD_EXP 40
1663: PPUSH
1664: CALL_OW 2
1668: ST_TO_ADDR
// if Jerry then
1669: LD_EXP 41
1673: IFFALSE 1704
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1675: LD_ADDR_VAR 0 4
1679: PUSH
1680: LD_VAR 0 4
1684: PPUSH
1685: LD_VAR 0 4
1689: PUSH
1690: LD_INT 1
1692: PLUS
1693: PPUSH
1694: LD_EXP 41
1698: PPUSH
1699: CALL_OW 2
1703: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1704: LD_STRING 02_other_survivors
1706: PPUSH
1707: CALL_OW 28
1711: IFFALSE 1726
// others := CreateCharacterSet ( 02_other_survivors ) ;
1713: LD_ADDR_VAR 0 5
1717: PUSH
1718: LD_STRING 02_other_survivors
1720: PPUSH
1721: CALL_OW 31
1725: ST_TO_ADDR
// if others then
1726: LD_VAR 0 5
1730: IFFALSE 1755
// begin tmp := tmp ^ others ;
1732: LD_ADDR_VAR 0 4
1736: PUSH
1737: LD_VAR 0 4
1741: PUSH
1742: LD_VAR 0 5
1746: ADD
1747: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1748: LD_STRING 02_other_survivors
1750: PPUSH
1751: CALL_OW 40
// end ; jmm_units := tmp ;
1755: LD_ADDR_EXP 4
1759: PUSH
1760: LD_VAR 0 4
1764: ST_TO_ADDR
// if not vehicles then
1765: LD_VAR 0 6
1769: NOT
1770: IFFALSE 1788
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1772: LD_ADDR_VAR 0 6
1776: PUSH
1777: LD_STRING 02_tanks_1
1779: PPUSH
1780: LD_INT 0
1782: PPUSH
1783: CALL_OW 30
1787: ST_TO_ADDR
// if vehicles then
1788: LD_VAR 0 6
1792: IFFALSE 1986
// begin got_mech := false ;
1794: LD_ADDR_VAR 0 7
1798: PUSH
1799: LD_INT 0
1801: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1802: LD_VAR 0 4
1806: PPUSH
1807: LD_INT 25
1809: PUSH
1810: LD_INT 3
1812: PUSH
1813: EMPTY
1814: LIST
1815: LIST
1816: PPUSH
1817: CALL_OW 72
1821: IFFALSE 1831
// got_mech := true ;
1823: LD_ADDR_VAR 0 7
1827: PUSH
1828: LD_INT 1
1830: ST_TO_ADDR
// for i = 1 to vehicles do
1831: LD_ADDR_VAR 0 2
1835: PUSH
1836: DOUBLE
1837: LD_INT 1
1839: DEC
1840: ST_TO_ADDR
1841: LD_VAR 0 6
1845: PUSH
1846: FOR_TO
1847: IFFALSE 1984
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1849: LD_ADDR_VAR 0 3
1853: PUSH
1854: LD_INT 1
1856: PPUSH
1857: LD_INT 3
1859: PPUSH
1860: LD_VAR 0 6
1864: PUSH
1865: LD_VAR 0 2
1869: ARRAY
1870: PUSH
1871: LD_INT 1
1873: ARRAY
1874: PPUSH
1875: LD_VAR 0 6
1879: PUSH
1880: LD_VAR 0 2
1884: ARRAY
1885: PUSH
1886: LD_INT 2
1888: ARRAY
1889: PPUSH
1890: LD_VAR 0 6
1894: PUSH
1895: LD_VAR 0 2
1899: ARRAY
1900: PUSH
1901: LD_INT 3
1903: ARRAY
1904: PPUSH
1905: LD_VAR 0 6
1909: PUSH
1910: LD_VAR 0 2
1914: ARRAY
1915: PUSH
1916: LD_INT 4
1918: ARRAY
1919: PPUSH
1920: LD_INT 40
1922: PPUSH
1923: CALL 529 0 7
1927: ST_TO_ADDR
// if not got_mech then
1928: LD_VAR 0 7
1932: NOT
1933: IFFALSE 1959
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1935: LD_VAR 0 3
1939: PPUSH
1940: LD_VAR 0 6
1944: PUSH
1945: LD_VAR 0 2
1949: ARRAY
1950: PUSH
1951: LD_INT 6
1953: ARRAY
1954: PPUSH
1955: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1959: LD_ADDR_VAR 0 4
1963: PUSH
1964: LD_VAR 0 4
1968: PPUSH
1969: LD_INT 1
1971: PPUSH
1972: LD_VAR 0 3
1976: PPUSH
1977: CALL_OW 2
1981: ST_TO_ADDR
// end ;
1982: GO 1846
1984: POP
1985: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1986: LD_EXP 35
1990: PPUSH
1991: LD_INT 194
1993: PPUSH
1994: LD_INT 119
1996: PPUSH
1997: LD_INT 0
1999: PPUSH
2000: CALL_OW 48
// if tmp then
2004: LD_VAR 0 4
2008: IFFALSE 2133
// begin for i in tmp do
2010: LD_ADDR_VAR 0 2
2014: PUSH
2015: LD_VAR 0 4
2019: PUSH
2020: FOR_IN
2021: IFFALSE 2131
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2023: LD_ADDR_VAR 0 8
2027: PUSH
2028: LD_INT 22
2030: PUSH
2031: LD_INT 1
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PUSH
2038: LD_INT 21
2040: PUSH
2041: LD_INT 2
2043: PUSH
2044: EMPTY
2045: LIST
2046: LIST
2047: PUSH
2048: LD_INT 58
2050: PUSH
2051: EMPTY
2052: LIST
2053: PUSH
2054: EMPTY
2055: LIST
2056: LIST
2057: LIST
2058: PPUSH
2059: CALL_OW 69
2063: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2064: LD_VAR 0 2
2068: PPUSH
2069: CALL_OW 247
2073: PUSH
2074: LD_INT 1
2076: EQUAL
2077: PUSH
2078: LD_VAR 0 8
2082: AND
2083: IFFALSE 2105
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2085: LD_VAR 0 2
2089: PPUSH
2090: LD_VAR 0 8
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PPUSH
2099: CALL_OW 52
2103: GO 2120
// PlaceUnitArea ( i , startArea , false ) ;
2105: LD_VAR 0 2
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_INT 0
2115: PPUSH
2116: CALL_OW 49
// ComHold ( i ) ;
2120: LD_VAR 0 2
2124: PPUSH
2125: CALL_OW 140
// end ;
2129: GO 2020
2131: POP
2132: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2133: LD_ADDR_EXP 7
2137: PUSH
2138: LD_STRING 02_mikhailStatus_1
2140: PPUSH
2141: LD_INT 0
2143: PPUSH
2144: CALL_OW 30
2148: ST_TO_ADDR
// if not bierezov_exist and not debug then
2149: LD_EXP 7
2153: NOT
2154: PUSH
2155: LD_EXP 1
2159: NOT
2160: AND
2161: IFFALSE 2165
// exit ;
2163: GO 2196
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2165: LD_ADDR_EXP 43
2169: PUSH
2170: LD_STRING Mikhail
2172: PPUSH
2173: LD_INT 0
2175: PPUSH
2176: CALL 466 0 2
2180: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2181: LD_EXP 43
2185: PPUSH
2186: LD_INT 1
2188: PPUSH
2189: LD_INT 0
2191: PPUSH
2192: CALL_OW 49
// end ;
2196: LD_VAR 0 1
2200: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2201: LD_INT 0
2203: PPUSH
2204: PPUSH
2205: PPUSH
2206: PPUSH
// uc_side := 4 ;
2207: LD_ADDR_OWVAR 20
2211: PUSH
2212: LD_INT 4
2214: ST_TO_ADDR
// uc_nation := 1 ;
2215: LD_ADDR_OWVAR 21
2219: PUSH
2220: LD_INT 1
2222: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2223: LD_ADDR_EXP 42
2227: PUSH
2228: LD_STRING Cornell
2230: PPUSH
2231: LD_INT 0
2233: PPUSH
2234: CALL 466 0 2
2238: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2239: LD_ADDR_EXP 6
2243: PUSH
2244: LD_INT 9
2246: PUSH
2247: LD_EXP 4
2251: MINUS
2252: ST_TO_ADDR
// tmp := [ ] ;
2253: LD_ADDR_VAR 0 2
2257: PUSH
2258: EMPTY
2259: ST_TO_ADDR
// if cornel_units < 4 then
2260: LD_EXP 6
2264: PUSH
2265: LD_INT 4
2267: LESS
2268: IFFALSE 2278
// cornel_units := 4 ;
2270: LD_ADDR_EXP 6
2274: PUSH
2275: LD_INT 4
2277: ST_TO_ADDR
// for i = 1 to cornel_units do
2278: LD_ADDR_VAR 0 4
2282: PUSH
2283: DOUBLE
2284: LD_INT 1
2286: DEC
2287: ST_TO_ADDR
2288: LD_EXP 6
2292: PUSH
2293: FOR_TO
2294: IFFALSE 2392
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2296: LD_INT 0
2298: PPUSH
2299: LD_INT 1
2301: PUSH
2302: LD_INT 1
2304: PUSH
2305: LD_INT 1
2307: PUSH
2308: LD_INT 2
2310: PUSH
2311: LD_INT 4
2313: PUSH
2314: EMPTY
2315: LIST
2316: LIST
2317: LIST
2318: LIST
2319: LIST
2320: PUSH
2321: LD_VAR 0 4
2325: PUSH
2326: LD_INT 5
2328: MOD
2329: PUSH
2330: LD_INT 1
2332: PLUS
2333: ARRAY
2334: PPUSH
2335: LD_INT 2
2337: PPUSH
2338: CALL_OW 380
// un := CreateHuman ;
2342: LD_ADDR_VAR 0 3
2346: PUSH
2347: CALL_OW 44
2351: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2352: LD_ADDR_VAR 0 2
2356: PUSH
2357: LD_VAR 0 2
2361: PPUSH
2362: LD_INT 1
2364: PPUSH
2365: LD_VAR 0 3
2369: PPUSH
2370: CALL_OW 2
2374: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2375: LD_VAR 0 3
2379: PPUSH
2380: LD_INT 2
2382: PPUSH
2383: LD_INT 0
2385: PPUSH
2386: CALL_OW 49
// end ;
2390: GO 2293
2392: POP
2393: POP
// cornel_units := tmp ;
2394: LD_ADDR_EXP 6
2398: PUSH
2399: LD_VAR 0 2
2403: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2404: LD_EXP 42
2408: PPUSH
2409: LD_INT 191
2411: PPUSH
2412: LD_INT 106
2414: PPUSH
2415: LD_INT 0
2417: PPUSH
2418: CALL_OW 48
// end ;
2422: LD_VAR 0 1
2426: RET
// export function PrepareWesternBase ; var i ; begin
2427: LD_INT 0
2429: PPUSH
2430: PPUSH
// uc_side := 8 ;
2431: LD_ADDR_OWVAR 20
2435: PUSH
2436: LD_INT 8
2438: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2439: LD_ADDR_EXP 45
2443: PUSH
2444: LD_STRING Lynch
2446: PPUSH
2447: LD_INT 0
2449: PPUSH
2450: CALL 466 0 2
2454: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2455: LD_ADDR_EXP 46
2459: PUSH
2460: LD_STRING Walker
2462: PPUSH
2463: LD_INT 0
2465: PPUSH
2466: CALL 466 0 2
2470: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2471: LD_ADDR_EXP 47
2475: PUSH
2476: LD_STRING Turner
2478: PPUSH
2479: LD_INT 0
2481: PPUSH
2482: CALL 466 0 2
2486: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2487: LD_ADDR_EXP 48
2491: PUSH
2492: LD_STRING Jillian
2494: PPUSH
2495: LD_INT 0
2497: PPUSH
2498: CALL 466 0 2
2502: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2503: LD_ADDR_VAR 0 2
2507: PUSH
2508: LD_EXP 45
2512: PUSH
2513: LD_EXP 46
2517: PUSH
2518: LD_EXP 47
2522: PUSH
2523: LD_EXP 48
2527: PUSH
2528: EMPTY
2529: LIST
2530: LIST
2531: LIST
2532: LIST
2533: PUSH
2534: FOR_IN
2535: IFFALSE 2563
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2537: LD_VAR 0 2
2541: PPUSH
2542: LD_INT 3
2544: PPUSH
2545: LD_INT 0
2547: PPUSH
2548: CALL_OW 49
// ComHold ( i ) ;
2552: LD_VAR 0 2
2556: PPUSH
2557: CALL_OW 140
// end ;
2561: GO 2534
2563: POP
2564: POP
// end ;
2565: LD_VAR 0 1
2569: RET
// export function SelectGroup ; var units , selected , i ; begin
2570: LD_INT 0
2572: PPUSH
2573: PPUSH
2574: PPUSH
2575: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2576: LD_ADDR_VAR 0 2
2580: PUSH
2581: LD_EXP 35
2585: PUSH
2586: LD_INT -3
2588: PUSH
2589: EMPTY
2590: LIST
2591: LIST
2592: PUSH
2593: LD_EXP 4
2597: ADD
2598: PUSH
2599: LD_INT -2
2601: PUSH
2602: LD_INT -4
2604: PUSH
2605: LD_EXP 42
2609: PUSH
2610: LD_EXP 43
2614: PUSH
2615: EMPTY
2616: LIST
2617: LIST
2618: LIST
2619: LIST
2620: ADD
2621: PUSH
2622: LD_INT -3
2624: PUSH
2625: EMPTY
2626: LIST
2627: ADD
2628: PUSH
2629: LD_EXP 6
2633: ADD
2634: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2635: LD_ADDR_VAR 0 3
2639: PUSH
2640: LD_EXP 35
2644: PUSH
2645: LD_STRING Select five characters to go with you
2647: PPUSH
2648: LD_INT 4
2650: PPUSH
2651: LD_INT 4
2653: PPUSH
2654: LD_VAR 0 2
2658: PPUSH
2659: EMPTY
2660: PPUSH
2661: CALL_OW 42
2665: ADD
2666: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2667: LD_ADDR_EXP 6
2671: PUSH
2672: LD_EXP 4
2676: PUSH
2677: LD_EXP 6
2681: UNION
2682: PUSH
2683: LD_VAR 0 3
2687: DIFF
2688: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2689: LD_ADDR_VAR 0 4
2693: PUSH
2694: LD_EXP 6
2698: PUSH
2699: LD_EXP 43
2703: ADD
2704: PUSH
2705: FOR_IN
2706: IFFALSE 2737
// if GetSide ( i ) = 1 then
2708: LD_VAR 0 4
2712: PPUSH
2713: CALL_OW 255
2717: PUSH
2718: LD_INT 1
2720: EQUAL
2721: IFFALSE 2735
// SetSide ( i , 4 ) ;
2723: LD_VAR 0 4
2727: PPUSH
2728: LD_INT 4
2730: PPUSH
2731: CALL_OW 235
2735: GO 2705
2737: POP
2738: POP
// for i in selected do
2739: LD_ADDR_VAR 0 4
2743: PUSH
2744: LD_VAR 0 3
2748: PUSH
2749: FOR_IN
2750: IFFALSE 2781
// if GetSide ( i ) = 4 then
2752: LD_VAR 0 4
2756: PPUSH
2757: CALL_OW 255
2761: PUSH
2762: LD_INT 4
2764: EQUAL
2765: IFFALSE 2779
// SetSide ( i , 1 ) ;
2767: LD_VAR 0 4
2771: PPUSH
2772: LD_INT 1
2774: PPUSH
2775: CALL_OW 235
2779: GO 2749
2781: POP
2782: POP
// jmm_units := jmm_units diff cornel_units ;
2783: LD_ADDR_EXP 4
2787: PUSH
2788: LD_EXP 4
2792: PUSH
2793: LD_EXP 6
2797: DIFF
2798: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2799: LD_EXP 36
2803: PPUSH
2804: CALL_OW 255
2808: PUSH
2809: LD_INT 4
2811: EQUAL
2812: IFFALSE 2827
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2814: LD_EXP 3
2818: PUSH
2819: LD_STRING Bobby
2821: STR
2822: PPUSH
2823: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2827: LD_EXP 37
2831: PPUSH
2832: CALL_OW 255
2836: PUSH
2837: LD_INT 4
2839: EQUAL
2840: IFFALSE 2855
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2842: LD_EXP 3
2846: PUSH
2847: LD_STRING Cyrus
2849: STR
2850: PPUSH
2851: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2855: LD_EXP 38
2859: PPUSH
2860: CALL_OW 255
2864: PUSH
2865: LD_INT 4
2867: EQUAL
2868: IFFALSE 2883
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2870: LD_EXP 3
2874: PUSH
2875: LD_STRING Lisa
2877: STR
2878: PPUSH
2879: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2883: LD_EXP 39
2887: PPUSH
2888: CALL_OW 255
2892: PUSH
2893: LD_INT 4
2895: EQUAL
2896: IFFALSE 2911
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
2898: LD_EXP 3
2902: PUSH
2903: LD_STRING Khatam
2905: STR
2906: PPUSH
2907: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2911: LD_EXP 40
2915: PPUSH
2916: CALL_OW 255
2920: PUSH
2921: LD_INT 4
2923: EQUAL
2924: IFFALSE 2939
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
2926: LD_EXP 3
2930: PUSH
2931: LD_STRING Brian
2933: STR
2934: PPUSH
2935: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2939: LD_EXP 41
2943: PPUSH
2944: CALL_OW 255
2948: PUSH
2949: LD_INT 4
2951: EQUAL
2952: IFFALSE 2967
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
2954: LD_EXP 3
2958: PUSH
2959: LD_STRING Jerry
2961: STR
2962: PPUSH
2963: CALL_OW 40
// end ; end_of_file
2967: LD_VAR 0 1
2971: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
2972: LD_INT 0
2974: PPUSH
2975: PPUSH
2976: PPUSH
2977: PPUSH
2978: PPUSH
2979: PPUSH
2980: PPUSH
2981: PPUSH
2982: PPUSH
2983: PPUSH
2984: PPUSH
2985: PPUSH
2986: PPUSH
// ru_alert := false ;
2987: LD_ADDR_EXP 58
2991: PUSH
2992: LD_INT 0
2994: ST_TO_ADDR
// ru_produce_list := [ ] ;
2995: LD_ADDR_EXP 55
2999: PUSH
3000: EMPTY
3001: ST_TO_ADDR
// if Difficulty > 1 then
3002: LD_OWVAR 67
3006: PUSH
3007: LD_INT 1
3009: GREATER
3010: IFFALSE 3098
// begin uc_side := 3 ;
3012: LD_ADDR_OWVAR 20
3016: PUSH
3017: LD_INT 3
3019: ST_TO_ADDR
// uc_nation := 3 ;
3020: LD_ADDR_OWVAR 21
3024: PUSH
3025: LD_INT 3
3027: ST_TO_ADDR
// bc_type := b_breastwork ;
3028: LD_ADDR_OWVAR 42
3032: PUSH
3033: LD_INT 31
3035: ST_TO_ADDR
// bc_level := Difficulty ;
3036: LD_ADDR_OWVAR 43
3040: PUSH
3041: LD_OWVAR 67
3045: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3046: LD_INT 22
3048: PPUSH
3049: LD_INT 14
3051: PPUSH
3052: LD_INT 0
3054: PPUSH
3055: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3059: LD_INT 48
3061: PPUSH
3062: LD_INT 46
3064: PPUSH
3065: LD_INT 0
3067: PPUSH
3068: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3072: LD_INT 86
3074: PPUSH
3075: LD_INT 65
3077: PPUSH
3078: LD_INT 5
3080: PPUSH
3081: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3085: LD_INT 165
3087: PPUSH
3088: LD_INT 73
3090: PPUSH
3091: LD_INT 5
3093: PPUSH
3094: CALL_OW 47
// end ; if Difficulty = 3 then
3098: LD_OWVAR 67
3102: PUSH
3103: LD_INT 3
3105: EQUAL
3106: IFFALSE 3121
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3108: LD_INT 51
3110: PPUSH
3111: LD_INT 3
3113: PPUSH
3114: LD_INT 2
3116: PPUSH
3117: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3121: LD_ADDR_VAR 0 7
3125: PUSH
3126: LD_INT 22
3128: PUSH
3129: LD_INT 3
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: PUSH
3136: LD_INT 2
3138: PUSH
3139: LD_INT 30
3141: PUSH
3142: LD_INT 31
3144: PUSH
3145: EMPTY
3146: LIST
3147: LIST
3148: PUSH
3149: LD_INT 30
3151: PUSH
3152: LD_INT 32
3154: PUSH
3155: EMPTY
3156: LIST
3157: LIST
3158: PUSH
3159: EMPTY
3160: LIST
3161: LIST
3162: LIST
3163: PUSH
3164: EMPTY
3165: LIST
3166: LIST
3167: PPUSH
3168: CALL_OW 69
3172: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3173: LD_ADDR_VAR 0 8
3177: PUSH
3178: LD_INT 22
3180: PUSH
3181: LD_INT 3
3183: PUSH
3184: EMPTY
3185: LIST
3186: LIST
3187: PUSH
3188: LD_INT 30
3190: PUSH
3191: LD_INT 4
3193: PUSH
3194: EMPTY
3195: LIST
3196: LIST
3197: PUSH
3198: EMPTY
3199: LIST
3200: LIST
3201: PPUSH
3202: CALL_OW 69
3206: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3207: LD_ADDR_VAR 0 10
3211: PUSH
3212: LD_INT 22
3214: PUSH
3215: LD_INT 3
3217: PUSH
3218: EMPTY
3219: LIST
3220: LIST
3221: PUSH
3222: LD_INT 30
3224: PUSH
3225: LD_INT 3
3227: PUSH
3228: EMPTY
3229: LIST
3230: LIST
3231: PUSH
3232: EMPTY
3233: LIST
3234: LIST
3235: PPUSH
3236: CALL_OW 69
3240: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3241: LD_ADDR_VAR 0 9
3245: PUSH
3246: LD_INT 22
3248: PUSH
3249: LD_INT 3
3251: PUSH
3252: EMPTY
3253: LIST
3254: LIST
3255: PUSH
3256: LD_INT 30
3258: PUSH
3259: LD_INT 6
3261: PUSH
3262: EMPTY
3263: LIST
3264: LIST
3265: PUSH
3266: EMPTY
3267: LIST
3268: LIST
3269: PPUSH
3270: CALL_OW 69
3274: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3275: LD_ADDR_VAR 0 2
3279: PUSH
3280: LD_INT 22
3282: PUSH
3283: LD_INT 3
3285: PUSH
3286: EMPTY
3287: LIST
3288: LIST
3289: PUSH
3290: LD_INT 30
3292: PUSH
3293: LD_INT 1
3295: PUSH
3296: EMPTY
3297: LIST
3298: LIST
3299: PUSH
3300: EMPTY
3301: LIST
3302: LIST
3303: PPUSH
3304: CALL_OW 69
3308: PUSH
3309: FOR_IN
3310: IFFALSE 3354
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3312: LD_VAR 0 2
3316: PPUSH
3317: CALL_OW 274
3321: PPUSH
3322: LD_INT 1
3324: PPUSH
3325: LD_INT 5000
3327: PPUSH
3328: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3332: LD_VAR 0 2
3336: PPUSH
3337: CALL_OW 274
3341: PPUSH
3342: LD_INT 2
3344: PPUSH
3345: LD_INT 3000
3347: PPUSH
3348: CALL_OW 277
// end ;
3352: GO 3309
3354: POP
3355: POP
// uc_side := 3 ;
3356: LD_ADDR_OWVAR 20
3360: PUSH
3361: LD_INT 3
3363: ST_TO_ADDR
// uc_nation := 3 ;
3364: LD_ADDR_OWVAR 21
3368: PUSH
3369: LD_INT 3
3371: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3372: LD_ADDR_VAR 0 11
3376: PUSH
3377: LD_INT 2
3379: PUSH
3380: LD_INT 3
3382: PUSH
3383: LD_INT 4
3385: PUSH
3386: EMPTY
3387: LIST
3388: LIST
3389: LIST
3390: PUSH
3391: LD_OWVAR 67
3395: ARRAY
3396: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3397: LD_ADDR_EXP 50
3401: PUSH
3402: LD_STRING Pokryshkin
3404: PPUSH
3405: LD_INT 0
3407: PPUSH
3408: CALL 466 0 2
3412: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3413: LD_EXP 50
3417: PPUSH
3418: LD_INT 63
3420: PPUSH
3421: LD_INT 21
3423: PPUSH
3424: LD_INT 0
3426: PPUSH
3427: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3431: LD_EXP 50
3435: PPUSH
3436: CALL_OW 140
// InitHc ;
3440: CALL_OW 19
// for i in fac do
3444: LD_ADDR_VAR 0 2
3448: PUSH
3449: LD_VAR 0 10
3453: PUSH
3454: FOR_IN
3455: IFFALSE 3508
// begin for j = 1 to 6 do
3457: LD_ADDR_VAR 0 3
3461: PUSH
3462: DOUBLE
3463: LD_INT 1
3465: DEC
3466: ST_TO_ADDR
3467: LD_INT 6
3469: PUSH
3470: FOR_TO
3471: IFFALSE 3504
// begin PrepareHuman ( false , 3 , skill ) ;
3473: LD_INT 0
3475: PPUSH
3476: LD_INT 3
3478: PPUSH
3479: LD_VAR 0 11
3483: PPUSH
3484: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3488: CALL_OW 44
3492: PPUSH
3493: LD_VAR 0 2
3497: PPUSH
3498: CALL_OW 52
// end ;
3502: GO 3470
3504: POP
3505: POP
// end ;
3506: GO 3454
3508: POP
3509: POP
// for i in lab do
3510: LD_ADDR_VAR 0 2
3514: PUSH
3515: LD_VAR 0 9
3519: PUSH
3520: FOR_IN
3521: IFFALSE 3554
// begin PrepareHuman ( false , 4 , skill ) ;
3523: LD_INT 0
3525: PPUSH
3526: LD_INT 4
3528: PPUSH
3529: LD_VAR 0 11
3533: PPUSH
3534: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3538: CALL_OW 44
3542: PPUSH
3543: LD_VAR 0 2
3547: PPUSH
3548: CALL_OW 52
// end ;
3552: GO 3520
3554: POP
3555: POP
// for i in tw do
3556: LD_ADDR_VAR 0 2
3560: PUSH
3561: LD_VAR 0 7
3565: PUSH
3566: FOR_IN
3567: IFFALSE 3616
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3569: LD_VAR 0 2
3573: PPUSH
3574: LD_INT 42
3576: PUSH
3577: LD_INT 43
3579: PUSH
3580: EMPTY
3581: LIST
3582: LIST
3583: PUSH
3584: LD_INT 1
3586: PPUSH
3587: LD_INT 2
3589: PPUSH
3590: CALL_OW 12
3594: ARRAY
3595: PPUSH
3596: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3600: LD_VAR 0 11
3604: PPUSH
3605: LD_VAR 0 2
3609: PPUSH
3610: CALL 807 0 2
// end ;
3614: GO 3566
3616: POP
3617: POP
// for i in bar do
3618: LD_ADDR_VAR 0 2
3622: PUSH
3623: LD_VAR 0 8
3627: PUSH
3628: FOR_IN
3629: IFFALSE 3662
// begin PrepareHuman ( false , 1 , skill ) ;
3631: LD_INT 0
3633: PPUSH
3634: LD_INT 1
3636: PPUSH
3637: LD_VAR 0 11
3641: PPUSH
3642: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3646: CALL_OW 44
3650: PPUSH
3651: LD_VAR 0 2
3655: PPUSH
3656: CALL_OW 52
// end ;
3660: GO 3628
3662: POP
3663: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3664: LD_ADDR_VAR 0 13
3668: PUSH
3669: LD_INT 100
3671: PUSH
3672: LD_INT 9
3674: PUSH
3675: EMPTY
3676: LIST
3677: LIST
3678: PUSH
3679: LD_INT 135
3681: PUSH
3682: LD_INT 60
3684: PUSH
3685: EMPTY
3686: LIST
3687: LIST
3688: PUSH
3689: LD_INT 41
3691: PUSH
3692: LD_INT 6
3694: PUSH
3695: EMPTY
3696: LIST
3697: LIST
3698: PUSH
3699: LD_INT 22
3701: PUSH
3702: LD_INT 9
3704: PUSH
3705: EMPTY
3706: LIST
3707: LIST
3708: PUSH
3709: LD_INT 84
3711: PUSH
3712: LD_INT 14
3714: PUSH
3715: EMPTY
3716: LIST
3717: LIST
3718: PUSH
3719: EMPTY
3720: LIST
3721: LIST
3722: LIST
3723: LIST
3724: LIST
3725: ST_TO_ADDR
// vehicles := [ ] ;
3726: LD_ADDR_VAR 0 12
3730: PUSH
3731: EMPTY
3732: ST_TO_ADDR
// for i in spot_xy do
3733: LD_ADDR_VAR 0 2
3737: PUSH
3738: LD_VAR 0 13
3742: PUSH
3743: FOR_IN
3744: IFFALSE 3902
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3746: LD_ADDR_VAR 0 6
3750: PUSH
3751: LD_INT 3
3753: PPUSH
3754: LD_INT 3
3756: PPUSH
3757: LD_INT 22
3759: PPUSH
3760: LD_INT 1
3762: PPUSH
3763: LD_INT 1
3765: PPUSH
3766: LD_INT 42
3768: PUSH
3769: LD_INT 43
3771: PUSH
3772: LD_INT 44
3774: PUSH
3775: EMPTY
3776: LIST
3777: LIST
3778: LIST
3779: PUSH
3780: LD_INT 1
3782: PPUSH
3783: LD_INT 3
3785: PPUSH
3786: CALL_OW 12
3790: ARRAY
3791: PPUSH
3792: LD_INT 100
3794: PPUSH
3795: CALL 529 0 7
3799: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3800: LD_ADDR_VAR 0 12
3804: PUSH
3805: LD_VAR 0 12
3809: PPUSH
3810: LD_VAR 0 12
3814: PUSH
3815: LD_INT 1
3817: PLUS
3818: PPUSH
3819: LD_VAR 0 6
3823: PPUSH
3824: CALL_OW 2
3828: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3829: LD_VAR 0 6
3833: PPUSH
3834: LD_INT 3
3836: PPUSH
3837: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3841: LD_VAR 0 6
3845: PPUSH
3846: LD_VAR 0 2
3850: PUSH
3851: LD_INT 1
3853: ARRAY
3854: PPUSH
3855: LD_VAR 0 2
3859: PUSH
3860: LD_INT 2
3862: ARRAY
3863: PPUSH
3864: LD_INT 0
3866: PPUSH
3867: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3871: LD_INT 0
3873: PPUSH
3874: LD_INT 3
3876: PPUSH
3877: LD_VAR 0 11
3881: PPUSH
3882: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3886: CALL_OW 44
3890: PPUSH
3891: LD_VAR 0 6
3895: PPUSH
3896: CALL_OW 52
// end ;
3900: GO 3743
3902: POP
3903: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3904: LD_ADDR_VAR 0 2
3908: PUSH
3909: DOUBLE
3910: LD_INT 1
3912: DEC
3913: ST_TO_ADDR
3914: LD_INT 5
3916: PUSH
3917: LD_INT 7
3919: PUSH
3920: LD_INT 8
3922: PUSH
3923: EMPTY
3924: LIST
3925: LIST
3926: LIST
3927: PUSH
3928: LD_OWVAR 67
3932: ARRAY
3933: PUSH
3934: FOR_TO
3935: IFFALSE 3995
// begin PrepareHuman ( false , 1 , skill ) ;
3937: LD_INT 0
3939: PPUSH
3940: LD_INT 1
3942: PPUSH
3943: LD_VAR 0 11
3947: PPUSH
3948: CALL_OW 380
// un := CreateHuman ;
3952: LD_ADDR_VAR 0 5
3956: PUSH
3957: CALL_OW 44
3961: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3962: LD_VAR 0 5
3966: PPUSH
3967: LD_INT 11
3969: PPUSH
3970: LD_INT 0
3972: PPUSH
3973: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3977: LD_ADDR_EXP 53
3981: PUSH
3982: LD_EXP 53
3986: PUSH
3987: LD_VAR 0 5
3991: ADD
3992: ST_TO_ADDR
// end ;
3993: GO 3934
3995: POP
3996: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3997: LD_ADDR_VAR 0 2
4001: PUSH
4002: DOUBLE
4003: LD_INT 1
4005: DEC
4006: ST_TO_ADDR
4007: LD_INT 2
4009: PUSH
4010: LD_INT 3
4012: PUSH
4013: LD_INT 4
4015: PUSH
4016: EMPTY
4017: LIST
4018: LIST
4019: LIST
4020: PUSH
4021: LD_OWVAR 67
4025: ARRAY
4026: PUSH
4027: FOR_TO
4028: IFFALSE 4088
// begin PrepareHuman ( false , 1 , skill ) ;
4030: LD_INT 0
4032: PPUSH
4033: LD_INT 1
4035: PPUSH
4036: LD_VAR 0 11
4040: PPUSH
4041: CALL_OW 380
// un := CreateHuman ;
4045: LD_ADDR_VAR 0 5
4049: PUSH
4050: CALL_OW 44
4054: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4055: LD_VAR 0 5
4059: PPUSH
4060: LD_INT 12
4062: PPUSH
4063: LD_INT 0
4065: PPUSH
4066: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4070: LD_ADDR_EXP 51
4074: PUSH
4075: LD_EXP 51
4079: PUSH
4080: LD_VAR 0 5
4084: ADD
4085: ST_TO_ADDR
// end ;
4086: GO 4027
4088: POP
4089: POP
// for i = 1 to 2 do
4090: LD_ADDR_VAR 0 2
4094: PUSH
4095: DOUBLE
4096: LD_INT 1
4098: DEC
4099: ST_TO_ADDR
4100: LD_INT 2
4102: PUSH
4103: FOR_TO
4104: IFFALSE 4170
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4106: LD_INT 1
4108: PPUSH
4109: LD_INT 1
4111: PPUSH
4112: LD_VAR 0 11
4116: PPUSH
4117: CALL_OW 380
// un := CreateHuman ;
4121: LD_ADDR_VAR 0 5
4125: PUSH
4126: CALL_OW 44
4130: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4131: LD_VAR 0 5
4135: PPUSH
4136: LD_INT 39
4138: PPUSH
4139: LD_INT 12
4141: PPUSH
4142: LD_INT 3
4144: PPUSH
4145: LD_INT 0
4147: PPUSH
4148: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4152: LD_ADDR_EXP 52
4156: PUSH
4157: LD_EXP 52
4161: PUSH
4162: LD_VAR 0 5
4166: ADD
4167: ST_TO_ADDR
// end ;
4168: GO 4103
4170: POP
4171: POP
// for i = 1 to 3 do
4172: LD_ADDR_VAR 0 2
4176: PUSH
4177: DOUBLE
4178: LD_INT 1
4180: DEC
4181: ST_TO_ADDR
4182: LD_INT 3
4184: PUSH
4185: FOR_TO
4186: IFFALSE 4252
// begin PrepareHuman ( false , 1 , skill ) ;
4188: LD_INT 0
4190: PPUSH
4191: LD_INT 1
4193: PPUSH
4194: LD_VAR 0 11
4198: PPUSH
4199: CALL_OW 380
// un := CreateHuman ;
4203: LD_ADDR_VAR 0 5
4207: PUSH
4208: CALL_OW 44
4212: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4213: LD_VAR 0 5
4217: PPUSH
4218: LD_INT 180
4220: PPUSH
4221: LD_INT 11
4223: PPUSH
4224: LD_INT 4
4226: PPUSH
4227: LD_INT 0
4229: PPUSH
4230: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4234: LD_ADDR_EXP 56
4238: PUSH
4239: LD_EXP 56
4243: PUSH
4244: LD_VAR 0 5
4248: ADD
4249: ST_TO_ADDR
// end ;
4250: GO 4185
4252: POP
4253: POP
// ru_vehicles := vehicles ;
4254: LD_ADDR_EXP 54
4258: PUSH
4259: LD_VAR 0 12
4263: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4264: LD_ADDR_EXP 57
4268: PUSH
4269: LD_INT 131
4271: PUSH
4272: LD_INT 121
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: PUSH
4279: LD_INT 113
4281: PUSH
4282: LD_INT 90
4284: PUSH
4285: EMPTY
4286: LIST
4287: LIST
4288: PUSH
4289: LD_INT 93
4291: PUSH
4292: LD_INT 62
4294: PUSH
4295: EMPTY
4296: LIST
4297: LIST
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: LIST
4303: PUSH
4304: LD_INT 106
4306: PUSH
4307: LD_INT 54
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: PUSH
4314: LD_INT 120
4316: PUSH
4317: LD_INT 80
4319: PUSH
4320: EMPTY
4321: LIST
4322: LIST
4323: PUSH
4324: LD_INT 143
4326: PUSH
4327: LD_INT 120
4329: PUSH
4330: EMPTY
4331: LIST
4332: LIST
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: LIST
4338: PUSH
4339: LD_INT 154
4341: PUSH
4342: LD_INT 116
4344: PUSH
4345: EMPTY
4346: LIST
4347: LIST
4348: PUSH
4349: LD_INT 140
4351: PUSH
4352: LD_INT 93
4354: PUSH
4355: EMPTY
4356: LIST
4357: LIST
4358: PUSH
4359: LD_INT 130
4361: PUSH
4362: LD_INT 58
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: LIST
4373: PUSH
4374: LD_INT 105
4376: PUSH
4377: LD_INT 106
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: PUSH
4384: LD_INT 134
4386: PUSH
4387: LD_INT 98
4389: PUSH
4390: EMPTY
4391: LIST
4392: LIST
4393: PUSH
4394: LD_INT 159
4396: PUSH
4397: LD_INT 113
4399: PUSH
4400: EMPTY
4401: LIST
4402: LIST
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: LIST
4408: PUSH
4409: EMPTY
4410: LIST
4411: LIST
4412: LIST
4413: LIST
4414: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4415: LD_ADDR_VAR 0 2
4419: PUSH
4420: DOUBLE
4421: LD_INT 1
4423: DEC
4424: ST_TO_ADDR
4425: LD_OWVAR 67
4429: PUSH
4430: LD_INT 1
4432: MINUS
4433: PUSH
4434: FOR_TO
4435: IFFALSE 4468
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4437: LD_ADDR_EXP 55
4441: PUSH
4442: LD_EXP 55
4446: PUSH
4447: LD_INT 22
4449: PUSH
4450: LD_INT 1
4452: PUSH
4453: LD_INT 1
4455: PUSH
4456: LD_INT 43
4458: PUSH
4459: EMPTY
4460: LIST
4461: LIST
4462: LIST
4463: LIST
4464: ADD
4465: ST_TO_ADDR
4466: GO 4434
4468: POP
4469: POP
// end ;
4470: LD_VAR 0 1
4474: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4475: LD_INT 22
4477: PUSH
4478: LD_INT 3
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: PUSH
4485: LD_INT 21
4487: PUSH
4488: LD_INT 2
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: PUSH
4495: EMPTY
4496: LIST
4497: LIST
4498: PPUSH
4499: CALL_OW 69
4503: IFFALSE 4597
4505: GO 4507
4507: DISABLE
4508: LD_INT 0
4510: PPUSH
4511: PPUSH
// begin enable ;
4512: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4513: LD_ADDR_VAR 0 2
4517: PUSH
4518: LD_INT 22
4520: PUSH
4521: LD_INT 3
4523: PUSH
4524: EMPTY
4525: LIST
4526: LIST
4527: PUSH
4528: LD_INT 21
4530: PUSH
4531: LD_INT 2
4533: PUSH
4534: EMPTY
4535: LIST
4536: LIST
4537: PUSH
4538: EMPTY
4539: LIST
4540: LIST
4541: PPUSH
4542: CALL_OW 69
4546: ST_TO_ADDR
// if filter then
4547: LD_VAR 0 2
4551: IFFALSE 4597
// for i in filter do
4553: LD_ADDR_VAR 0 1
4557: PUSH
4558: LD_VAR 0 2
4562: PUSH
4563: FOR_IN
4564: IFFALSE 4595
// if GetFuel ( i ) < 20 then
4566: LD_VAR 0 1
4570: PPUSH
4571: CALL_OW 261
4575: PUSH
4576: LD_INT 20
4578: LESS
4579: IFFALSE 4593
// SetFuel ( i , 20 ) ;
4581: LD_VAR 0 1
4585: PPUSH
4586: LD_INT 20
4588: PPUSH
4589: CALL_OW 240
4593: GO 4563
4595: POP
4596: POP
// end ;
4597: PPOPN 2
4599: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4600: LD_EXP 55
4604: IFFALSE 4823
4606: GO 4608
4608: DISABLE
4609: LD_INT 0
4611: PPUSH
4612: PPUSH
4613: PPUSH
// begin enable ;
4614: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4615: LD_ADDR_VAR 0 2
4619: PUSH
4620: LD_INT 22
4622: PUSH
4623: LD_INT 3
4625: PUSH
4626: EMPTY
4627: LIST
4628: LIST
4629: PUSH
4630: LD_INT 30
4632: PUSH
4633: LD_INT 3
4635: PUSH
4636: EMPTY
4637: LIST
4638: LIST
4639: PUSH
4640: EMPTY
4641: LIST
4642: LIST
4643: PPUSH
4644: CALL_OW 69
4648: ST_TO_ADDR
// can_produce := [ ] ;
4649: LD_ADDR_VAR 0 3
4653: PUSH
4654: EMPTY
4655: ST_TO_ADDR
// if not fac then
4656: LD_VAR 0 2
4660: NOT
4661: IFFALSE 4666
// begin disable ;
4663: DISABLE
// exit ;
4664: GO 4823
// end ; for i in fac do
4666: LD_ADDR_VAR 0 1
4670: PUSH
4671: LD_VAR 0 2
4675: PUSH
4676: FOR_IN
4677: IFFALSE 4715
// if UnitsInside ( i ) then
4679: LD_VAR 0 1
4683: PPUSH
4684: CALL_OW 313
4688: IFFALSE 4713
// can_produce := Insert ( can_produce , 1 , i ) ;
4690: LD_ADDR_VAR 0 3
4694: PUSH
4695: LD_VAR 0 3
4699: PPUSH
4700: LD_INT 1
4702: PPUSH
4703: LD_VAR 0 1
4707: PPUSH
4708: CALL_OW 2
4712: ST_TO_ADDR
4713: GO 4676
4715: POP
4716: POP
// if not can_produce then
4717: LD_VAR 0 3
4721: NOT
4722: IFFALSE 4726
// exit ;
4724: GO 4823
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4726: LD_VAR 0 3
4730: PUSH
4731: LD_INT 1
4733: PPUSH
4734: LD_VAR 0 3
4738: PPUSH
4739: CALL_OW 12
4743: ARRAY
4744: PPUSH
4745: LD_EXP 55
4749: PUSH
4750: LD_INT 1
4752: ARRAY
4753: PPUSH
4754: LD_EXP 55
4758: PUSH
4759: LD_INT 2
4761: ARRAY
4762: PPUSH
4763: LD_EXP 55
4767: PUSH
4768: LD_INT 3
4770: ARRAY
4771: PPUSH
4772: LD_EXP 55
4776: PUSH
4777: LD_INT 4
4779: ARRAY
4780: PPUSH
4781: CALL_OW 125
// for i = 1 to 4 do
4785: LD_ADDR_VAR 0 1
4789: PUSH
4790: DOUBLE
4791: LD_INT 1
4793: DEC
4794: ST_TO_ADDR
4795: LD_INT 4
4797: PUSH
4798: FOR_TO
4799: IFFALSE 4821
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4801: LD_ADDR_EXP 55
4805: PUSH
4806: LD_EXP 55
4810: PPUSH
4811: LD_INT 1
4813: PPUSH
4814: CALL_OW 3
4818: ST_TO_ADDR
4819: GO 4798
4821: POP
4822: POP
// end ;
4823: PPOPN 3
4825: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4826: LD_INT 0
4828: PPUSH
4829: PPUSH
4830: PPUSH
// for i = 1 to 6 do
4831: LD_ADDR_VAR 0 2
4835: PUSH
4836: DOUBLE
4837: LD_INT 1
4839: DEC
4840: ST_TO_ADDR
4841: LD_INT 6
4843: PUSH
4844: FOR_TO
4845: IFFALSE 4994
// begin PrepareHuman ( false , 3 , 3 ) ;
4847: LD_INT 0
4849: PPUSH
4850: LD_INT 3
4852: PPUSH
4853: LD_INT 3
4855: PPUSH
4856: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4860: LD_ADDR_VAR 0 3
4864: PUSH
4865: LD_INT 3
4867: PPUSH
4868: LD_INT 3
4870: PPUSH
4871: LD_INT 22
4873: PPUSH
4874: LD_INT 1
4876: PPUSH
4877: LD_INT 1
4879: PPUSH
4880: LD_INT 43
4882: PUSH
4883: LD_INT 42
4885: PUSH
4886: EMPTY
4887: LIST
4888: LIST
4889: PUSH
4890: LD_INT 1
4892: PPUSH
4893: LD_INT 2
4895: PPUSH
4896: CALL_OW 12
4900: ARRAY
4901: PPUSH
4902: LD_INT 70
4904: PPUSH
4905: CALL 529 0 7
4909: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4910: LD_VAR 0 3
4914: PPUSH
4915: LD_INT 4
4917: PPUSH
4918: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4922: LD_VAR 0 3
4926: PPUSH
4927: LD_INT 229
4929: PPUSH
4930: LD_INT 44
4932: PPUSH
4933: LD_INT 0
4935: PPUSH
4936: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4940: CALL_OW 44
4944: PPUSH
4945: LD_VAR 0 3
4949: PPUSH
4950: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4954: LD_ADDR_EXP 54
4958: PUSH
4959: LD_EXP 54
4963: PUSH
4964: LD_VAR 0 3
4968: ADD
4969: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
4970: LD_VAR 0 3
4974: PPUSH
4975: LD_INT 191
4977: PPUSH
4978: LD_INT 32
4980: PPUSH
4981: CALL_OW 111
// Wait ( 0 0$02 ) ;
4985: LD_INT 70
4987: PPUSH
4988: CALL_OW 67
// end ;
4992: GO 4844
4994: POP
4995: POP
// end ;
4996: LD_VAR 0 1
5000: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
5001: LD_EXP 29
5005: PUSH
5006: LD_EXP 54
5010: AND
5011: IFFALSE 5185
5013: GO 5015
5015: DISABLE
5016: LD_INT 0
5018: PPUSH
5019: PPUSH
5020: PPUSH
// begin wait ( 0 0$50 ) ;
5021: LD_INT 1750
5023: PPUSH
5024: CALL_OW 67
// tmp := ru_vehicles ;
5028: LD_ADDR_VAR 0 3
5032: PUSH
5033: LD_EXP 54
5037: ST_TO_ADDR
// if not tmp then
5038: LD_VAR 0 3
5042: NOT
5043: IFFALSE 5047
// exit ;
5045: GO 5185
// repeat wait ( 0 0$1 ) ;
5047: LD_INT 35
5049: PPUSH
5050: CALL_OW 67
// for i in tmp do
5054: LD_ADDR_VAR 0 1
5058: PUSH
5059: LD_VAR 0 3
5063: PUSH
5064: FOR_IN
5065: IFFALSE 5176
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5067: LD_ADDR_VAR 0 2
5071: PUSH
5072: LD_INT 22
5074: PUSH
5075: LD_INT 1
5077: PUSH
5078: EMPTY
5079: LIST
5080: LIST
5081: PPUSH
5082: LD_VAR 0 1
5086: PPUSH
5087: CALL_OW 74
5091: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5092: LD_VAR 0 1
5096: PPUSH
5097: LD_VAR 0 2
5101: PPUSH
5102: CALL_OW 296
5106: PUSH
5107: LD_INT 10
5109: GREATER
5110: IFFALSE 5129
// ComAgressiveMove ( i , 69 , 101 ) else
5112: LD_VAR 0 1
5116: PPUSH
5117: LD_INT 69
5119: PPUSH
5120: LD_INT 101
5122: PPUSH
5123: CALL_OW 114
5127: GO 5143
// ComAttackUnit ( i , enemy ) ;
5129: LD_VAR 0 1
5133: PPUSH
5134: LD_VAR 0 2
5138: PPUSH
5139: CALL_OW 115
// if GetLives ( i ) < 250 then
5143: LD_VAR 0 1
5147: PPUSH
5148: CALL_OW 256
5152: PUSH
5153: LD_INT 250
5155: LESS
5156: IFFALSE 5174
// tmp := tmp diff i ;
5158: LD_ADDR_VAR 0 3
5162: PUSH
5163: LD_VAR 0 3
5167: PUSH
5168: LD_VAR 0 1
5172: DIFF
5173: ST_TO_ADDR
// end ;
5174: GO 5064
5176: POP
5177: POP
// until not tmp ;
5178: LD_VAR 0 3
5182: NOT
5183: IFFALSE 5047
// end ; end_of_file
5185: PPOPN 3
5187: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5188: LD_INT 0
5190: PPUSH
5191: PPUSH
5192: PPUSH
5193: PPUSH
5194: PPUSH
5195: PPUSH
5196: PPUSH
// InGameOn ;
5197: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5201: LD_EXP 35
5205: PPUSH
5206: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5210: LD_EXP 35
5214: PPUSH
5215: LD_EXP 42
5219: PPUSH
5220: CALL_OW 119
// if Bierezov then
5224: LD_EXP 43
5228: IFFALSE 5244
// ComTurnUnit ( Bierezov , Cornel ) ;
5230: LD_EXP 43
5234: PPUSH
5235: LD_EXP 42
5239: PPUSH
5240: CALL_OW 119
// for i in jmm_units do
5244: LD_ADDR_VAR 0 2
5248: PUSH
5249: LD_EXP 4
5253: PUSH
5254: FOR_IN
5255: IFFALSE 5273
// ComTurnUnit ( i , Cornel ) ;
5257: LD_VAR 0 2
5261: PPUSH
5262: LD_EXP 42
5266: PPUSH
5267: CALL_OW 119
5271: GO 5254
5273: POP
5274: POP
// units := cornel_units union Cornel ;
5275: LD_ADDR_VAR 0 3
5279: PUSH
5280: LD_EXP 6
5284: PUSH
5285: LD_EXP 42
5289: UNION
5290: ST_TO_ADDR
// repeat wait ( 1 ) ;
5291: LD_INT 1
5293: PPUSH
5294: CALL_OW 67
// for i in units do
5298: LD_ADDR_VAR 0 2
5302: PUSH
5303: LD_VAR 0 3
5307: PUSH
5308: FOR_IN
5309: IFFALSE 5342
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5311: LD_VAR 0 2
5315: PPUSH
5316: LD_EXP 35
5320: PPUSH
5321: CALL_OW 250
5325: PPUSH
5326: LD_EXP 35
5330: PPUSH
5331: CALL_OW 251
5335: PPUSH
5336: CALL_OW 111
5340: GO 5308
5342: POP
5343: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5344: LD_VAR 0 3
5348: PPUSH
5349: LD_INT 92
5351: PUSH
5352: LD_EXP 35
5356: PPUSH
5357: CALL_OW 250
5361: PUSH
5362: LD_EXP 35
5366: PPUSH
5367: CALL_OW 251
5371: PUSH
5372: LD_INT 10
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: LIST
5379: LIST
5380: PPUSH
5381: CALL_OW 72
5385: PUSH
5386: LD_VAR 0 3
5390: EQUAL
5391: IFFALSE 5291
// for i in units do
5393: LD_ADDR_VAR 0 2
5397: PUSH
5398: LD_VAR 0 3
5402: PUSH
5403: FOR_IN
5404: IFFALSE 5422
// ComTurnUnit ( i , JMM ) ;
5406: LD_VAR 0 2
5410: PPUSH
5411: LD_EXP 35
5415: PPUSH
5416: CALL_OW 119
5420: GO 5403
5422: POP
5423: POP
// ComTurnUnit ( Cornel , JMM ) ;
5424: LD_EXP 42
5428: PPUSH
5429: LD_EXP 35
5433: PPUSH
5434: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5438: LD_EXP 35
5442: PPUSH
5443: LD_STRING D1-JMM-1
5445: PPUSH
5446: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5450: LD_EXP 42
5454: PPUSH
5455: LD_STRING D1-Corn-1
5457: PPUSH
5458: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5462: LD_EXP 35
5466: PPUSH
5467: LD_EXP 42
5471: PPUSH
5472: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5476: LD_EXP 42
5480: PPUSH
5481: LD_EXP 35
5485: PPUSH
5486: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5490: LD_INT 35
5492: PPUSH
5493: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5497: LD_EXP 35
5501: PPUSH
5502: LD_EXP 42
5506: PPUSH
5507: CALL_OW 296
5511: PUSH
5512: LD_INT 6
5514: LESS
5515: IFFALSE 5490
// ChangeSideFog ( 4 , 1 ) ;
5517: LD_INT 4
5519: PPUSH
5520: LD_INT 1
5522: PPUSH
5523: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5527: LD_EXP 35
5531: PPUSH
5532: LD_EXP 42
5536: PPUSH
5537: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5541: LD_EXP 42
5545: PPUSH
5546: LD_EXP 35
5550: PPUSH
5551: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5555: LD_EXP 35
5559: PPUSH
5560: LD_STRING D1-JMM-2
5562: PPUSH
5563: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5567: LD_EXP 35
5571: PPUSH
5572: LD_STRING D1-JMM-2a
5574: PPUSH
5575: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5579: LD_EXP 42
5583: PPUSH
5584: LD_STRING D1-Corn-2
5586: PPUSH
5587: CALL_OW 88
// if bierezov_exist or debug then
5591: LD_EXP 7
5595: PUSH
5596: LD_EXP 1
5600: OR
5601: IFFALSE 5842
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5603: LD_EXP 42
5607: PPUSH
5608: LD_EXP 43
5612: PPUSH
5613: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5617: LD_INT 10
5619: PPUSH
5620: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5624: LD_EXP 42
5628: PPUSH
5629: LD_STRING D1a-Corn-1
5631: PPUSH
5632: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5636: LD_EXP 35
5640: PPUSH
5641: LD_EXP 43
5645: PPUSH
5646: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5650: LD_EXP 43
5654: PPUSH
5655: LD_EXP 35
5659: PPUSH
5660: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5664: LD_EXP 35
5668: PPUSH
5669: LD_STRING D1a-JMM-1
5671: PPUSH
5672: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5676: LD_EXP 35
5680: PPUSH
5681: LD_EXP 42
5685: PPUSH
5686: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5690: LD_EXP 42
5694: PPUSH
5695: LD_EXP 35
5699: PPUSH
5700: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5704: LD_EXP 42
5708: PPUSH
5709: LD_STRING D1a-Corn-2
5711: PPUSH
5712: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5716: LD_EXP 35
5720: PPUSH
5721: LD_STRING D1a-JMM-2
5723: PPUSH
5724: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5728: LD_EXP 42
5732: PPUSH
5733: LD_STRING D1a-Corn-3
5735: PPUSH
5736: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5740: LD_EXP 35
5744: PPUSH
5745: LD_STRING D1a-JMM-3
5747: PPUSH
5748: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5752: LD_EXP 42
5756: PPUSH
5757: LD_STRING D1a-Corn-4
5759: PPUSH
5760: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5764: LD_EXP 35
5768: PPUSH
5769: LD_STRING D1a-JMM-4
5771: PPUSH
5772: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5776: LD_EXP 42
5780: PPUSH
5781: LD_STRING D1a-Corn-5
5783: PPUSH
5784: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5788: LD_EXP 43
5792: PPUSH
5793: LD_EXP 42
5797: PPUSH
5798: CALL_OW 250
5802: PPUSH
5803: LD_EXP 42
5807: PPUSH
5808: CALL_OW 251
5812: PUSH
5813: LD_INT 2
5815: MINUS
5816: PPUSH
5817: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5821: LD_EXP 43
5825: PPUSH
5826: LD_EXP 42
5830: PPUSH
5831: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5835: LD_INT 10
5837: PPUSH
5838: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5842: LD_EXP 35
5846: PPUSH
5847: LD_STRING D1b-JMM-1
5849: PPUSH
5850: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5854: LD_EXP 42
5858: PPUSH
5859: LD_STRING D1b-Corn-1
5861: PPUSH
5862: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5866: LD_EXP 35
5870: PPUSH
5871: LD_STRING D1b-JMM-2
5873: PPUSH
5874: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5878: LD_EXP 42
5882: PPUSH
5883: LD_STRING D1b-Corn-2
5885: PPUSH
5886: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5890: LD_EXP 35
5894: PPUSH
5895: LD_STRING D1b-JMM-3
5897: PPUSH
5898: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5902: LD_INT 10
5904: PPUSH
5905: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5909: LD_EXP 44
5913: PPUSH
5914: LD_STRING D1b-Pow-3
5916: PPUSH
5917: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5921: LD_EXP 35
5925: PPUSH
5926: LD_STRING D1b-JMM-4
5928: PPUSH
5929: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5933: LD_EXP 42
5937: PPUSH
5938: LD_STRING D1b-Corn-4
5940: PPUSH
5941: CALL_OW 88
// if Khatam then
5945: LD_EXP 39
5949: IFFALSE 5965
// Say ( Khatam , D1b-Khat-4 ) else
5951: LD_EXP 39
5955: PPUSH
5956: LD_STRING D1b-Khat-4
5958: PPUSH
5959: CALL_OW 88
5963: GO 6001
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
5965: LD_EXP 6
5969: PPUSH
5970: LD_INT 26
5972: PUSH
5973: LD_INT 1
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: PPUSH
5980: CALL_OW 72
5984: PUSH
5985: LD_EXP 42
5989: PUSH
5990: EMPTY
5991: LIST
5992: DIFF
5993: PPUSH
5994: LD_STRING D1b-Sol1-4
5996: PPUSH
5997: CALL 617 0 2
// if Cyrus then
6001: LD_EXP 37
6005: IFFALSE 6019
// Say ( Cyrus , D1b-Cyrus-4 ) ;
6007: LD_EXP 37
6011: PPUSH
6012: LD_STRING D1b-Cyrus-4
6014: PPUSH
6015: CALL_OW 88
// if Lisa then
6019: LD_EXP 38
6023: IFFALSE 6081
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6025: LD_EXP 38
6029: PPUSH
6030: LD_STRING D1b-Lisa-4
6032: PPUSH
6033: CALL_OW 88
// if Cyrus then
6037: LD_EXP 37
6041: IFFALSE 6081
// begin if not IsInUnit ( Cyrus ) then
6043: LD_EXP 37
6047: PPUSH
6048: CALL_OW 310
6052: NOT
6053: IFFALSE 6069
// ComTurnUnit ( Cyrus , Lisa ) ;
6055: LD_EXP 37
6059: PPUSH
6060: LD_EXP 38
6064: PPUSH
6065: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6069: LD_EXP 37
6073: PPUSH
6074: LD_STRING D1b-Cyrus-5
6076: PPUSH
6077: CALL_OW 88
// end ; end ; SelectGroup ;
6081: CALL 2570 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6085: LD_EXP 35
6089: PPUSH
6090: LD_STRING D1d-JMM-1
6092: PPUSH
6093: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6097: LD_EXP 42
6101: PPUSH
6102: LD_STRING D1d-Corn-1
6104: PPUSH
6105: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6109: LD_ADDR_VAR 0 2
6113: PUSH
6114: LD_EXP 4
6118: PUSH
6119: LD_EXP 6
6123: ADD
6124: PUSH
6125: LD_EXP 35
6129: ADD
6130: PUSH
6131: FOR_IN
6132: IFFALSE 6145
// ComHold ( i ) ;
6134: LD_VAR 0 2
6138: PPUSH
6139: CALL_OW 140
6143: GO 6131
6145: POP
6146: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6147: LD_ADDR_VAR 0 4
6151: PUSH
6152: LD_INT 22
6154: PUSH
6155: LD_INT 1
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: PUSH
6162: LD_INT 21
6164: PUSH
6165: LD_INT 2
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: PUSH
6172: EMPTY
6173: LIST
6174: LIST
6175: PPUSH
6176: CALL_OW 69
6180: ST_TO_ADDR
// if vehicles then
6181: LD_VAR 0 4
6185: IFFALSE 6523
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6187: LD_EXP 6
6191: PPUSH
6192: LD_INT 55
6194: PUSH
6195: EMPTY
6196: LIST
6197: PPUSH
6198: CALL_OW 72
6202: IFFALSE 6241
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6204: LD_ADDR_VAR 0 2
6208: PUSH
6209: LD_EXP 6
6213: PPUSH
6214: LD_INT 55
6216: PUSH
6217: EMPTY
6218: LIST
6219: PPUSH
6220: CALL_OW 72
6224: PUSH
6225: FOR_IN
6226: IFFALSE 6239
// ComExitVehicle ( i ) ;
6228: LD_VAR 0 2
6232: PPUSH
6233: CALL_OW 121
6237: GO 6225
6239: POP
6240: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6241: LD_ADDR_VAR 0 5
6245: PUSH
6246: LD_VAR 0 4
6250: PPUSH
6251: LD_INT 34
6253: PUSH
6254: LD_INT 51
6256: PUSH
6257: EMPTY
6258: LIST
6259: LIST
6260: PPUSH
6261: CALL_OW 72
6265: ST_TO_ADDR
// if cargos then
6266: LD_VAR 0 5
6270: IFFALSE 6453
// begin vehicles := cargos ;
6272: LD_ADDR_VAR 0 4
6276: PUSH
6277: LD_VAR 0 5
6281: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6282: LD_ADDR_VAR 0 6
6286: PUSH
6287: LD_STRING 02_resources_4
6289: PPUSH
6290: LD_INT 0
6292: PPUSH
6293: CALL_OW 30
6297: ST_TO_ADDR
// if debug and not resources then
6298: LD_EXP 1
6302: PUSH
6303: LD_VAR 0 6
6307: NOT
6308: AND
6309: IFFALSE 6319
// resources := 160 ;
6311: LD_ADDR_VAR 0 6
6315: PUSH
6316: LD_INT 160
6318: ST_TO_ADDR
// if resources mod 10 then
6319: LD_VAR 0 6
6323: PUSH
6324: LD_INT 10
6326: MOD
6327: IFFALSE 6349
// resources := resources - resources mod 10 ;
6329: LD_ADDR_VAR 0 6
6333: PUSH
6334: LD_VAR 0 6
6338: PUSH
6339: LD_VAR 0 6
6343: PUSH
6344: LD_INT 10
6346: MOD
6347: MINUS
6348: ST_TO_ADDR
// if resources then
6349: LD_VAR 0 6
6353: IFFALSE 6453
// for i in cargos do
6355: LD_ADDR_VAR 0 2
6359: PUSH
6360: LD_VAR 0 5
6364: PUSH
6365: FOR_IN
6366: IFFALSE 6451
// begin if resources < 100 then
6368: LD_VAR 0 6
6372: PUSH
6373: LD_INT 100
6375: LESS
6376: IFFALSE 6398
// begin cargo := resources ;
6378: LD_ADDR_VAR 0 7
6382: PUSH
6383: LD_VAR 0 6
6387: ST_TO_ADDR
// resources := 0 ;
6388: LD_ADDR_VAR 0 6
6392: PUSH
6393: LD_INT 0
6395: ST_TO_ADDR
// end else
6396: GO 6420
// begin cargo := 100 ;
6398: LD_ADDR_VAR 0 7
6402: PUSH
6403: LD_INT 100
6405: ST_TO_ADDR
// resources := resources - 100 ;
6406: LD_ADDR_VAR 0 6
6410: PUSH
6411: LD_VAR 0 6
6415: PUSH
6416: LD_INT 100
6418: MINUS
6419: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6420: LD_VAR 0 2
6424: PPUSH
6425: LD_INT 1
6427: PPUSH
6428: LD_VAR 0 7
6432: PPUSH
6433: CALL_OW 290
// if resources = 0 then
6437: LD_VAR 0 6
6441: PUSH
6442: LD_INT 0
6444: EQUAL
6445: IFFALSE 6449
// break ;
6447: GO 6451
// end ;
6449: GO 6365
6451: POP
6452: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6453: LD_VAR 0 4
6457: PUSH
6458: LD_INT 1
6460: ARRAY
6461: PPUSH
6462: CALL_OW 311
6466: PPUSH
6467: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6471: LD_VAR 0 4
6475: PUSH
6476: LD_INT 1
6478: ARRAY
6479: PPUSH
6480: LD_INT 4
6482: PPUSH
6483: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6487: LD_EXP 42
6491: PPUSH
6492: LD_VAR 0 4
6496: PUSH
6497: LD_INT 1
6499: ARRAY
6500: PPUSH
6501: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6505: LD_INT 35
6507: PPUSH
6508: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6512: LD_EXP 42
6516: PPUSH
6517: CALL_OW 310
6521: IFFALSE 6505
// end ; InGameOff ;
6523: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6527: LD_STRING M1
6529: PPUSH
6530: CALL_OW 337
// SaveForQuickRestart ;
6534: CALL_OW 22
// cornel_active := true ;
6538: LD_ADDR_EXP 8
6542: PUSH
6543: LD_INT 1
6545: ST_TO_ADDR
// end ;
6546: LD_VAR 0 1
6550: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns , tmp ;
6551: LD_EXP 35
6555: PPUSH
6556: LD_EXP 45
6560: PPUSH
6561: CALL_OW 296
6565: PUSH
6566: LD_INT 10
6568: LESS
6569: IFFALSE 7926
6571: GO 6573
6573: DISABLE
6574: LD_INT 0
6576: PPUSH
6577: PPUSH
6578: PPUSH
6579: PPUSH
6580: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6581: LD_ADDR_VAR 0 2
6585: PUSH
6586: LD_INT 89
6588: PUSH
6589: LD_INT 34
6591: PUSH
6592: EMPTY
6593: LIST
6594: LIST
6595: PUSH
6596: LD_INT 138
6598: PUSH
6599: LD_INT 63
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: PUSH
6606: LD_INT 196
6608: PUSH
6609: LD_INT 84
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: PUSH
6616: LD_INT 135
6618: PUSH
6619: LD_INT 52
6621: PUSH
6622: EMPTY
6623: LIST
6624: LIST
6625: PUSH
6626: LD_INT 103
6628: PUSH
6629: LD_INT 39
6631: PUSH
6632: EMPTY
6633: LIST
6634: LIST
6635: PUSH
6636: LD_INT 58
6638: PUSH
6639: LD_INT 30
6641: PUSH
6642: EMPTY
6643: LIST
6644: LIST
6645: PUSH
6646: LD_INT 38
6648: PUSH
6649: LD_INT 51
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: PUSH
6656: EMPTY
6657: LIST
6658: LIST
6659: LIST
6660: LIST
6661: LIST
6662: LIST
6663: LIST
6664: ST_TO_ADDR
// InGameOn ;
6665: CALL_OW 8
// if jmm_units then
6669: LD_EXP 4
6673: IFFALSE 6749
// for i in jmm_units do
6675: LD_ADDR_VAR 0 1
6679: PUSH
6680: LD_EXP 4
6684: PUSH
6685: FOR_IN
6686: IFFALSE 6747
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6688: LD_VAR 0 1
6692: PPUSH
6693: LD_EXP 35
6697: PPUSH
6698: CALL_OW 296
6702: PUSH
6703: LD_INT 10
6705: LESS
6706: PUSH
6707: LD_VAR 0 1
6711: PPUSH
6712: CALL_OW 310
6716: NOT
6717: AND
6718: IFFALSE 6736
// ComTurnUnit ( i , JMM ) else
6720: LD_VAR 0 1
6724: PPUSH
6725: LD_EXP 35
6729: PPUSH
6730: CALL_OW 119
6734: GO 6745
// ComHold ( i ) ;
6736: LD_VAR 0 1
6740: PPUSH
6741: CALL_OW 140
// end ;
6745: GO 6685
6747: POP
6748: POP
// if IsInUnit ( JMM ) then
6749: LD_EXP 35
6753: PPUSH
6754: CALL_OW 310
6758: IFFALSE 6783
// begin ComExitVehicle ( JMM ) ;
6760: LD_EXP 35
6764: PPUSH
6765: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6769: LD_EXP 35
6773: PPUSH
6774: LD_EXP 45
6778: PPUSH
6779: CALL_OW 172
// end ; Wait ( 10 ) ;
6783: LD_INT 10
6785: PPUSH
6786: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6790: LD_EXP 35
6794: PPUSH
6795: LD_EXP 45
6799: PPUSH
6800: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6804: LD_INT 35
6806: PPUSH
6807: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6811: LD_EXP 35
6815: PPUSH
6816: LD_EXP 45
6820: PPUSH
6821: CALL_OW 296
6825: PUSH
6826: LD_INT 6
6828: LESS
6829: IFFALSE 6804
// ComTurnUnit ( JMM , Lynch ) ;
6831: LD_EXP 35
6835: PPUSH
6836: LD_EXP 45
6840: PPUSH
6841: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6845: LD_ADDR_VAR 0 1
6849: PUSH
6850: LD_EXP 45
6854: PUSH
6855: LD_EXP 46
6859: PUSH
6860: LD_EXP 47
6864: PUSH
6865: LD_EXP 48
6869: PUSH
6870: EMPTY
6871: LIST
6872: LIST
6873: LIST
6874: LIST
6875: PUSH
6876: FOR_IN
6877: IFFALSE 6895
// ComTurnUnit ( i , JMM ) ;
6879: LD_VAR 0 1
6883: PPUSH
6884: LD_EXP 35
6888: PPUSH
6889: CALL_OW 119
6893: GO 6876
6895: POP
6896: POP
// Wait ( 0 0$0.3 ) ;
6897: LD_INT 10
6899: PPUSH
6900: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6904: LD_EXP 35
6908: PPUSH
6909: LD_STRING D2-JMM-1
6911: PPUSH
6912: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6916: LD_EXP 45
6920: PPUSH
6921: LD_STRING D2-Sol1-1
6923: PPUSH
6924: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6928: LD_EXP 35
6932: PPUSH
6933: LD_STRING D2-JMM-2
6935: PPUSH
6936: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6940: LD_EXP 45
6944: PPUSH
6945: LD_STRING D2-Sol1-2
6947: PPUSH
6948: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6952: LD_EXP 35
6956: PPUSH
6957: LD_STRING D2-JMM-3
6959: PPUSH
6960: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
6964: LD_EXP 45
6968: PPUSH
6969: LD_STRING D2-Sol1-3
6971: PPUSH
6972: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6976: LD_ADDR_VAR 0 1
6980: PUSH
6981: LD_INT 22
6983: PUSH
6984: LD_INT 8
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: PPUSH
6991: CALL_OW 69
6995: PUSH
6996: FOR_IN
6997: IFFALSE 7013
// SetSide ( i , 1 ) ;
6999: LD_VAR 0 1
7003: PPUSH
7004: LD_INT 1
7006: PPUSH
7007: CALL_OW 235
7011: GO 6996
7013: POP
7014: POP
// Say ( JMM , D2-JMM-4 ) ;
7015: LD_EXP 35
7019: PPUSH
7020: LD_STRING D2-JMM-4
7022: PPUSH
7023: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7027: LD_INT 1
7029: PPUSH
7030: LD_INT 5
7032: PPUSH
7033: CALL_OW 332
// for i = 1 to points do
7037: LD_ADDR_VAR 0 1
7041: PUSH
7042: DOUBLE
7043: LD_INT 1
7045: DEC
7046: ST_TO_ADDR
7047: LD_VAR 0 2
7051: PUSH
7052: FOR_TO
7053: IFFALSE 7228
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7055: LD_VAR 0 2
7059: PUSH
7060: LD_VAR 0 1
7064: ARRAY
7065: PUSH
7066: LD_INT 1
7068: ARRAY
7069: PPUSH
7070: LD_VAR 0 2
7074: PUSH
7075: LD_VAR 0 1
7079: ARRAY
7080: PUSH
7081: LD_INT 2
7083: ARRAY
7084: PPUSH
7085: CALL_OW 84
// if i = 1 then
7089: LD_VAR 0 1
7093: PUSH
7094: LD_INT 1
7096: EQUAL
7097: IFFALSE 7111
// Say ( Lynch , D2-Sol1-4 ) ;
7099: LD_EXP 45
7103: PPUSH
7104: LD_STRING D2-Sol1-4
7106: PPUSH
7107: CALL_OW 88
// if i = 2 then
7111: LD_VAR 0 1
7115: PUSH
7116: LD_INT 2
7118: EQUAL
7119: IFFALSE 7133
// Say ( JMM , D2-JMM-5 ) ;
7121: LD_EXP 35
7125: PPUSH
7126: LD_STRING D2-JMM-5
7128: PPUSH
7129: CALL_OW 88
// if i = 4 then
7133: LD_VAR 0 1
7137: PUSH
7138: LD_INT 4
7140: EQUAL
7141: IFFALSE 7165
// begin RevealFogArea ( 1 , troopsArea ) ;
7143: LD_INT 1
7145: PPUSH
7146: LD_INT 6
7148: PPUSH
7149: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7153: LD_EXP 45
7157: PPUSH
7158: LD_STRING D2-Sol1-5
7160: PPUSH
7161: CALL_OW 88
// end ; if i = 5 then
7165: LD_VAR 0 1
7169: PUSH
7170: LD_INT 5
7172: EQUAL
7173: IFFALSE 7187
// Say ( JMM , D2-JMM-6 ) ;
7175: LD_EXP 35
7179: PPUSH
7180: LD_STRING D2-JMM-6
7182: PPUSH
7183: CALL_OW 88
// if i = 7 then
7187: LD_VAR 0 1
7191: PUSH
7192: LD_INT 7
7194: EQUAL
7195: IFFALSE 7219
// begin RevealFogArea ( 1 , forestArea ) ;
7197: LD_INT 1
7199: PPUSH
7200: LD_INT 7
7202: PPUSH
7203: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7207: LD_EXP 45
7211: PPUSH
7212: LD_STRING D2-Sol1-6
7214: PPUSH
7215: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7219: LD_INT 46
7221: PPUSH
7222: CALL_OW 67
// end ;
7226: GO 7052
7228: POP
7229: POP
// CenterNowOnUnits ( JMM ) ;
7230: LD_EXP 35
7234: PPUSH
7235: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7239: LD_EXP 35
7243: PPUSH
7244: LD_STRING D2-JMM-7
7246: PPUSH
7247: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7251: LD_EXP 45
7255: PPUSH
7256: LD_STRING D2-Sol1-7
7258: PPUSH
7259: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7263: LD_EXP 35
7267: PPUSH
7268: LD_STRING D2-JMM-8
7270: PPUSH
7271: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7275: LD_ADDR_VAR 0 4
7279: PUSH
7280: LD_INT 22
7282: PUSH
7283: LD_INT 1
7285: PUSH
7286: EMPTY
7287: LIST
7288: LIST
7289: PUSH
7290: LD_INT 30
7292: PUSH
7293: LD_INT 31
7295: PUSH
7296: EMPTY
7297: LIST
7298: LIST
7299: PUSH
7300: EMPTY
7301: LIST
7302: LIST
7303: PPUSH
7304: CALL_OW 69
7308: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7309: LD_EXP 45
7313: PPUSH
7314: LD_VAR 0 4
7318: PUSH
7319: LD_INT 1
7321: ARRAY
7322: PPUSH
7323: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7327: LD_INT 65
7329: PPUSH
7330: LD_INT 101
7332: PPUSH
7333: CALL_OW 428
7337: IFFALSE 7360
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7339: LD_INT 65
7341: PPUSH
7342: LD_INT 101
7344: PPUSH
7345: CALL_OW 428
7349: PPUSH
7350: LD_INT 75
7352: PPUSH
7353: LD_INT 100
7355: PPUSH
7356: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7360: LD_INT 66
7362: PPUSH
7363: LD_INT 103
7365: PPUSH
7366: CALL_OW 428
7370: IFFALSE 7393
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7372: LD_INT 66
7374: PPUSH
7375: LD_INT 103
7377: PPUSH
7378: CALL_OW 428
7382: PPUSH
7383: LD_INT 75
7385: PPUSH
7386: LD_INT 100
7388: PPUSH
7389: CALL_OW 111
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_dist , JMM , 7 ] ] ) ;
7393: LD_ADDR_VAR 0 5
7397: PUSH
7398: LD_INT 22
7400: PUSH
7401: LD_INT 1
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PUSH
7408: LD_INT 21
7410: PUSH
7411: LD_INT 2
7413: PUSH
7414: EMPTY
7415: LIST
7416: LIST
7417: PUSH
7418: LD_INT 91
7420: PUSH
7421: LD_EXP 35
7425: PUSH
7426: LD_INT 7
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: LIST
7433: PUSH
7434: EMPTY
7435: LIST
7436: LIST
7437: LIST
7438: PPUSH
7439: CALL_OW 69
7443: ST_TO_ADDR
// if tmp then
7444: LD_VAR 0 5
7448: IFFALSE 7465
// ComMoveXY ( tmp , 75 , 100 ) ;
7450: LD_VAR 0 5
7454: PPUSH
7455: LD_INT 75
7457: PPUSH
7458: LD_INT 100
7460: PPUSH
7461: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7465: LD_ADDR_VAR 0 3
7469: PUSH
7470: LD_EXP 4
7474: PPUSH
7475: LD_INT 25
7477: PUSH
7478: LD_INT 1
7480: PUSH
7481: EMPTY
7482: LIST
7483: LIST
7484: PPUSH
7485: CALL_OW 72
7489: PPUSH
7490: LD_EXP 35
7494: PPUSH
7495: CALL_OW 74
7499: ST_TO_ADDR
// if sol then
7500: LD_VAR 0 3
7504: IFFALSE 7544
// if GetDistUnits ( JMM , sol ) < 10 then
7506: LD_EXP 35
7510: PPUSH
7511: LD_VAR 0 3
7515: PPUSH
7516: CALL_OW 296
7520: PUSH
7521: LD_INT 10
7523: LESS
7524: IFFALSE 7544
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7526: LD_VAR 0 3
7530: PPUSH
7531: LD_VAR 0 4
7535: PUSH
7536: LD_INT 2
7538: ARRAY
7539: PPUSH
7540: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7544: LD_INT 10
7546: PPUSH
7547: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7551: LD_EXP 35
7555: PPUSH
7556: LD_INT 65
7558: PPUSH
7559: LD_INT 101
7561: PPUSH
7562: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7566: LD_EXP 35
7570: PPUSH
7571: LD_INT 63
7573: PPUSH
7574: LD_INT 100
7576: PPUSH
7577: CALL_OW 178
// tmp := 0 0$0 ;
7581: LD_ADDR_VAR 0 5
7585: PUSH
7586: LD_INT 0
7588: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7589: LD_INT 35
7591: PPUSH
7592: CALL_OW 67
// tmp := tmp + 0 0$1 ;
7596: LD_ADDR_VAR 0 5
7600: PUSH
7601: LD_VAR 0 5
7605: PUSH
7606: LD_INT 35
7608: PLUS
7609: ST_TO_ADDR
// until IsAt ( JMM , 65 , 101 ) or tmp > 0 0$5 ;
7610: LD_EXP 35
7614: PPUSH
7615: LD_INT 65
7617: PPUSH
7618: LD_INT 101
7620: PPUSH
7621: CALL_OW 307
7625: PUSH
7626: LD_VAR 0 5
7630: PUSH
7631: LD_INT 175
7633: GREATER
7634: OR
7635: IFFALSE 7589
// Say ( JMM , D2a-JMM-1 ) ;
7637: LD_EXP 35
7641: PPUSH
7642: LD_STRING D2a-JMM-1
7644: PPUSH
7645: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7649: LD_EXP 46
7653: PPUSH
7654: LD_INT 66
7656: PPUSH
7657: LD_INT 103
7659: PPUSH
7660: CALL_OW 111
// tmp := 0 0$0 ;
7664: LD_ADDR_VAR 0 5
7668: PUSH
7669: LD_INT 0
7671: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7672: LD_INT 35
7674: PPUSH
7675: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) or tmp > 0 0$5 ;
7679: LD_EXP 46
7683: PPUSH
7684: LD_INT 66
7686: PPUSH
7687: LD_INT 103
7689: PPUSH
7690: CALL_OW 307
7694: PUSH
7695: LD_VAR 0 5
7699: PUSH
7700: LD_INT 175
7702: GREATER
7703: OR
7704: IFFALSE 7672
// ComTurnUnit ( Walker , JMM ) ;
7706: LD_EXP 46
7710: PPUSH
7711: LD_EXP 35
7715: PPUSH
7716: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7720: LD_EXP 46
7724: PPUSH
7725: LD_STRING D2a-Sci1-1
7727: PPUSH
7728: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7732: LD_EXP 35
7736: PPUSH
7737: LD_EXP 46
7741: PPUSH
7742: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7746: LD_EXP 35
7750: PPUSH
7751: LD_STRING D2a-JMM-2
7753: PPUSH
7754: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7758: LD_EXP 46
7762: PPUSH
7763: LD_STRING D2a-Sci1-2
7765: PPUSH
7766: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7770: LD_EXP 35
7774: PPUSH
7775: LD_STRING D2a-JMM-3
7777: PPUSH
7778: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7782: LD_EXP 46
7786: PPUSH
7787: LD_STRING D2a-Sci1-3
7789: PPUSH
7790: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7794: LD_ADDR_EXP 4
7798: PUSH
7799: LD_EXP 4
7803: PUSH
7804: LD_EXP 45
7808: PUSH
7809: LD_EXP 46
7813: PUSH
7814: LD_EXP 47
7818: PUSH
7819: LD_EXP 48
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: LIST
7828: LIST
7829: ADD
7830: ST_TO_ADDR
// for i in jmm_units do
7831: LD_ADDR_VAR 0 1
7835: PUSH
7836: LD_EXP 4
7840: PUSH
7841: FOR_IN
7842: IFFALSE 7867
// if not IsInUnit ( i ) then
7844: LD_VAR 0 1
7848: PPUSH
7849: CALL_OW 310
7853: NOT
7854: IFFALSE 7865
// ComFree ( i ) ;
7856: LD_VAR 0 1
7860: PPUSH
7861: CALL_OW 139
7865: GO 7841
7867: POP
7868: POP
// InGameOff ;
7869: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
7873: LD_STRING MSolar1
7875: PPUSH
7876: CALL_OW 337
// jmm_on_west := true ;
7880: LD_ADDR_EXP 5
7884: PUSH
7885: LD_INT 1
7887: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7888: LD_INT 1050
7890: PPUSH
7891: CALL_OW 67
// frank_can_return := true ;
7895: LD_ADDR_EXP 12
7899: PUSH
7900: LD_INT 1
7902: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7903: LD_INT 6300
7905: PPUSH
7906: LD_INT 8400
7908: PPUSH
7909: CALL_OW 12
7913: PPUSH
7914: CALL_OW 67
// send_spec_patrol := true ;
7918: LD_ADDR_EXP 28
7922: PUSH
7923: LD_INT 1
7925: ST_TO_ADDR
// end ;
7926: PPOPN 5
7928: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7929: LD_INT 22
7931: PUSH
7932: LD_INT 1
7934: PUSH
7935: EMPTY
7936: LIST
7937: LIST
7938: PUSH
7939: LD_INT 34
7941: PUSH
7942: LD_INT 51
7944: PUSH
7945: EMPTY
7946: LIST
7947: LIST
7948: PUSH
7949: LD_INT 92
7951: PUSH
7952: LD_INT 63
7954: PUSH
7955: LD_INT 100
7957: PUSH
7958: LD_INT 5
7960: PUSH
7961: EMPTY
7962: LIST
7963: LIST
7964: LIST
7965: LIST
7966: PUSH
7967: EMPTY
7968: LIST
7969: LIST
7970: LIST
7971: PUSH
7972: EMPTY
7973: LIST
7974: PPUSH
7975: CALL_OW 69
7979: PUSH
7980: LD_EXP 5
7984: NOT
7985: AND
7986: IFFALSE 8099
7988: GO 7990
7990: DISABLE
7991: LD_INT 0
7993: PPUSH
7994: PPUSH
// begin enable ;
7995: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
7996: LD_ADDR_VAR 0 2
8000: PUSH
8001: LD_INT 22
8003: PUSH
8004: LD_INT 1
8006: PUSH
8007: EMPTY
8008: LIST
8009: LIST
8010: PUSH
8011: LD_INT 34
8013: PUSH
8014: LD_INT 51
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: PUSH
8021: LD_INT 92
8023: PUSH
8024: LD_INT 63
8026: PUSH
8027: LD_INT 100
8029: PUSH
8030: LD_INT 5
8032: PUSH
8033: EMPTY
8034: LIST
8035: LIST
8036: LIST
8037: LIST
8038: PUSH
8039: EMPTY
8040: LIST
8041: LIST
8042: LIST
8043: PUSH
8044: EMPTY
8045: LIST
8046: PPUSH
8047: CALL_OW 69
8051: ST_TO_ADDR
// if not filter then
8052: LD_VAR 0 2
8056: NOT
8057: IFFALSE 8061
// exit ;
8059: GO 8099
// for i in filter do
8061: LD_ADDR_VAR 0 1
8065: PUSH
8066: LD_VAR 0 2
8070: PUSH
8071: FOR_IN
8072: IFFALSE 8097
// begin SetFuel ( i , 0 ) ;
8074: LD_VAR 0 1
8078: PPUSH
8079: LD_INT 0
8081: PPUSH
8082: CALL_OW 240
// ComStop ( i ) ;
8086: LD_VAR 0 1
8090: PPUSH
8091: CALL_OW 141
// end ;
8095: GO 8071
8097: POP
8098: POP
// end ;
8099: PPOPN 2
8101: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
8102: LD_EXP 28
8106: IFFALSE 9099
8108: GO 8110
8110: DISABLE
8111: LD_INT 0
8113: PPUSH
8114: PPUSH
8115: PPUSH
8116: PPUSH
8117: PPUSH
8118: PPUSH
8119: PPUSH
// begin if not ru_spec_patrol then
8120: LD_EXP 52
8124: NOT
8125: IFFALSE 8129
// exit ;
8127: GO 9099
// dead1 := false ;
8129: LD_ADDR_VAR 0 1
8133: PUSH
8134: LD_INT 0
8136: ST_TO_ADDR
// dead2 := false ;
8137: LD_ADDR_VAR 0 2
8141: PUSH
8142: LD_INT 0
8144: ST_TO_ADDR
// inarea1 := false ;
8145: LD_ADDR_VAR 0 3
8149: PUSH
8150: LD_INT 0
8152: ST_TO_ADDR
// inarea2 := false ;
8153: LD_ADDR_VAR 0 4
8157: PUSH
8158: LD_INT 0
8160: ST_TO_ADDR
// tmp := [ ] ;
8161: LD_ADDR_VAR 0 6
8165: PUSH
8166: EMPTY
8167: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8168: LD_EXP 52
8172: PPUSH
8173: LD_INT 75
8175: PPUSH
8176: LD_INT 101
8178: PPUSH
8179: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8183: LD_INT 35
8185: PPUSH
8186: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8190: LD_INT 1
8192: PPUSH
8193: LD_EXP 52
8197: PUSH
8198: LD_INT 1
8200: ARRAY
8201: PPUSH
8202: CALL_OW 292
8206: IFFALSE 8183
// ComStop ( ru_spec_patrol ) ;
8208: LD_EXP 52
8212: PPUSH
8213: CALL_OW 141
// Wait ( 0 0$02 ) ;
8217: LD_INT 70
8219: PPUSH
8220: CALL_OW 67
// DialogueOn ;
8224: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8228: LD_EXP 52
8232: PUSH
8233: LD_INT 1
8235: ARRAY
8236: PPUSH
8237: LD_STRING D8-Rus1-1
8239: PPUSH
8240: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8244: LD_EXP 35
8248: PPUSH
8249: LD_STRING D8-JMM-1
8251: PPUSH
8252: CALL_OW 88
// DialogueOff ;
8256: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8260: LD_EXP 52
8264: PPUSH
8265: LD_INT 13
8267: PPUSH
8268: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8272: LD_INT 35
8274: PPUSH
8275: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8279: LD_VAR 0 1
8283: NOT
8284: PUSH
8285: LD_EXP 52
8289: PUSH
8290: LD_INT 1
8292: ARRAY
8293: PPUSH
8294: CALL_OW 301
8298: AND
8299: IFFALSE 8309
// dead1 := true ;
8301: LD_ADDR_VAR 0 1
8305: PUSH
8306: LD_INT 1
8308: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8309: LD_VAR 0 2
8313: NOT
8314: PUSH
8315: LD_EXP 52
8319: PUSH
8320: LD_INT 2
8322: ARRAY
8323: PPUSH
8324: CALL_OW 301
8328: AND
8329: IFFALSE 8339
// dead2 := true ;
8331: LD_ADDR_VAR 0 2
8335: PUSH
8336: LD_INT 1
8338: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8339: LD_VAR 0 3
8343: NOT
8344: PUSH
8345: LD_EXP 52
8349: PUSH
8350: LD_INT 1
8352: ARRAY
8353: PPUSH
8354: LD_INT 14
8356: PPUSH
8357: CALL_OW 308
8361: AND
8362: IFFALSE 8372
// inarea1 := true ;
8364: LD_ADDR_VAR 0 3
8368: PUSH
8369: LD_INT 1
8371: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8372: LD_VAR 0 4
8376: NOT
8377: PUSH
8378: LD_EXP 52
8382: PUSH
8383: LD_INT 2
8385: ARRAY
8386: PPUSH
8387: LD_INT 14
8389: PPUSH
8390: CALL_OW 308
8394: AND
8395: IFFALSE 8405
// inarea2 := true ;
8397: LD_ADDR_VAR 0 4
8401: PUSH
8402: LD_INT 1
8404: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8405: LD_VAR 0 1
8409: PUSH
8410: LD_VAR 0 2
8414: AND
8415: PUSH
8416: LD_VAR 0 1
8420: PUSH
8421: LD_VAR 0 4
8425: AND
8426: OR
8427: PUSH
8428: LD_VAR 0 2
8432: PUSH
8433: LD_VAR 0 3
8437: AND
8438: OR
8439: PUSH
8440: LD_VAR 0 3
8444: PUSH
8445: LD_VAR 0 4
8449: AND
8450: OR
8451: IFFALSE 8272
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8453: LD_VAR 0 3
8457: PUSH
8458: LD_VAR 0 4
8462: AND
8463: PUSH
8464: LD_VAR 0 1
8468: PUSH
8469: LD_VAR 0 4
8473: AND
8474: OR
8475: PUSH
8476: LD_VAR 0 2
8480: PUSH
8481: LD_VAR 0 3
8485: AND
8486: OR
8487: IFFALSE 9079
// begin prepare_siege := true ;
8489: LD_ADDR_EXP 29
8493: PUSH
8494: LD_INT 1
8496: ST_TO_ADDR
// DialogueOn ;
8497: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8501: LD_VAR 0 3
8505: PUSH
8506: LD_VAR 0 4
8510: AND
8511: IFFALSE 8527
// Say ( JMM , D8b-JMM-1a ) else
8513: LD_EXP 35
8517: PPUSH
8518: LD_STRING D8b-JMM-1a
8520: PPUSH
8521: CALL_OW 88
8525: GO 8539
// Say ( JMM , D8b-JMM-1 ) ;
8527: LD_EXP 35
8531: PPUSH
8532: LD_STRING D8b-JMM-1
8534: PPUSH
8535: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8539: LD_EXP 4
8543: PPUSH
8544: LD_INT 26
8546: PUSH
8547: LD_INT 1
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: PPUSH
8554: CALL_OW 72
8558: PUSH
8559: LD_EXP 36
8563: PUSH
8564: LD_EXP 37
8568: PUSH
8569: LD_EXP 46
8573: PUSH
8574: LD_EXP 49
8578: PUSH
8579: EMPTY
8580: LIST
8581: LIST
8582: LIST
8583: LIST
8584: DIFF
8585: PPUSH
8586: LD_STRING D8b-Sol1-1
8588: PPUSH
8589: CALL 617 0 2
// if Cyrus and Cyrus in jmm_units then
8593: LD_EXP 37
8597: PUSH
8598: LD_EXP 37
8602: PUSH
8603: LD_EXP 4
8607: IN
8608: AND
8609: IFFALSE 8625
// Say ( Cyrus , D8b-Cyrus-1 ) else
8611: LD_EXP 37
8615: PPUSH
8616: LD_STRING D8b-Cyrus-1
8618: PPUSH
8619: CALL_OW 88
8623: GO 8637
// Say ( JMM , D8b-JMM-1a ) ;
8625: LD_EXP 35
8629: PPUSH
8630: LD_STRING D8b-JMM-1a
8632: PPUSH
8633: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8637: LD_EXP 38
8641: PUSH
8642: LD_EXP 38
8646: PUSH
8647: LD_EXP 4
8651: IN
8652: AND
8653: IFFALSE 8667
// Say ( Lisa , D8b-Lisa-2 ) ;
8655: LD_EXP 38
8659: PPUSH
8660: LD_STRING D8b-Lisa-2
8662: PPUSH
8663: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8667: LD_EXP 36
8671: PUSH
8672: LD_EXP 36
8676: PUSH
8677: LD_EXP 4
8681: IN
8682: AND
8683: IFFALSE 8699
// Say ( Bobby , D8b-Bobby-1 ) else
8685: LD_EXP 36
8689: PPUSH
8690: LD_STRING D8b-Bobby-1
8692: PPUSH
8693: CALL_OW 88
8697: GO 8759
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8699: LD_ADDR_VAR 0 5
8703: PUSH
8704: LD_EXP 4
8708: PPUSH
8709: LD_INT 26
8711: PUSH
8712: LD_INT 1
8714: PUSH
8715: EMPTY
8716: LIST
8717: LIST
8718: PPUSH
8719: CALL_OW 72
8723: PUSH
8724: LD_EXP 36
8728: PUSH
8729: LD_EXP 37
8733: PUSH
8734: LD_EXP 46
8738: PUSH
8739: LD_EXP 49
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: LIST
8748: LIST
8749: DIFF
8750: PPUSH
8751: LD_STRING D8b-Sol2-1
8753: PPUSH
8754: CALL 617 0 2
8758: ST_TO_ADDR
// DialogueOff ;
8759: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8763: LD_EXP 37
8767: PUSH
8768: LD_EXP 37
8772: PUSH
8773: LD_EXP 4
8777: IN
8778: AND
8779: IFFALSE 8804
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8781: LD_ADDR_VAR 0 6
8785: PUSH
8786: LD_VAR 0 6
8790: PPUSH
8791: LD_INT 1
8793: PPUSH
8794: LD_EXP 37
8798: PPUSH
8799: CALL_OW 2
8803: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8804: LD_EXP 36
8808: PUSH
8809: LD_EXP 36
8813: PUSH
8814: LD_EXP 4
8818: IN
8819: AND
8820: IFFALSE 8845
// tmp := Insert ( tmp , 1 , Bobby ) ;
8822: LD_ADDR_VAR 0 6
8826: PUSH
8827: LD_VAR 0 6
8831: PPUSH
8832: LD_INT 1
8834: PPUSH
8835: LD_EXP 36
8839: PPUSH
8840: CALL_OW 2
8844: ST_TO_ADDR
// if sol then
8845: LD_VAR 0 5
8849: IFFALSE 8874
// tmp := Insert ( tmp , 1 , sol ) ;
8851: LD_ADDR_VAR 0 6
8855: PUSH
8856: LD_VAR 0 6
8860: PPUSH
8861: LD_INT 1
8863: PPUSH
8864: LD_VAR 0 5
8868: PPUSH
8869: CALL_OW 2
8873: ST_TO_ADDR
// if tmp then
8874: LD_VAR 0 6
8878: IFFALSE 9038
// begin SetSide ( tmp , 8 ) ;
8880: LD_VAR 0 6
8884: PPUSH
8885: LD_INT 8
8887: PPUSH
8888: CALL_OW 235
// ComFree ( tmp ) ;
8892: LD_VAR 0 6
8896: PPUSH
8897: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8901: LD_VAR 0 6
8905: PPUSH
8906: LD_INT 15
8908: PPUSH
8909: CALL_OW 173
// AddComHold ( tmp ) ;
8913: LD_VAR 0 6
8917: PPUSH
8918: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8922: LD_INT 35
8924: PPUSH
8925: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
8929: LD_VAR 0 6
8933: PUSH
8934: LD_INT 1
8936: ARRAY
8937: PPUSH
8938: CALL_OW 314
8942: NOT
8943: IFFALSE 8957
// ComMoveToArea ( tmp , cyrusEscape ) ;
8945: LD_VAR 0 6
8949: PPUSH
8950: LD_INT 15
8952: PPUSH
8953: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8957: LD_VAR 0 6
8961: PUSH
8962: LD_INT 1
8964: ARRAY
8965: PPUSH
8966: LD_INT 15
8968: PPUSH
8969: CALL_OW 308
8973: IFFALSE 9028
// begin RemoveUnit ( tmp [ 1 ] ) ;
8975: LD_VAR 0 6
8979: PUSH
8980: LD_INT 1
8982: ARRAY
8983: PPUSH
8984: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
8988: LD_ADDR_EXP 4
8992: PUSH
8993: LD_EXP 4
8997: PUSH
8998: LD_VAR 0 6
9002: PUSH
9003: LD_INT 1
9005: ARRAY
9006: DIFF
9007: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
9008: LD_ADDR_VAR 0 6
9012: PUSH
9013: LD_VAR 0 6
9017: PUSH
9018: LD_VAR 0 6
9022: PUSH
9023: LD_INT 1
9025: ARRAY
9026: DIFF
9027: ST_TO_ADDR
// end ; until tmp = 0 ;
9028: LD_VAR 0 6
9032: PUSH
9033: LD_INT 0
9035: EQUAL
9036: IFFALSE 8922
// end ; Wait ( 0 0$30 ) ;
9038: LD_INT 1050
9040: PPUSH
9041: CALL_OW 67
// if ru_spec_patrol then
9045: LD_EXP 52
9049: IFFALSE 9077
// for i in ru_spec_patrol do
9051: LD_ADDR_VAR 0 7
9055: PUSH
9056: LD_EXP 52
9060: PUSH
9061: FOR_IN
9062: IFFALSE 9075
// RemoveUnit ( i ) ;
9064: LD_VAR 0 7
9068: PPUSH
9069: CALL_OW 64
9073: GO 9061
9075: POP
9076: POP
// end else
9077: GO 9099
// begin prepare_siege := false ;
9079: LD_ADDR_EXP 29
9083: PUSH
9084: LD_INT 0
9086: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
9087: LD_EXP 35
9091: PPUSH
9092: LD_STRING D8a-JMM-1
9094: PPUSH
9095: CALL_OW 88
// end ; end ;
9099: PPOPN 7
9101: END
// every 0 0$10 trigger frank_can_return do var i , points ;
9102: LD_EXP 12
9106: IFFALSE 10240
9108: GO 9110
9110: DISABLE
9111: LD_INT 0
9113: PPUSH
9114: PPUSH
// begin uc_side := 8 ;
9115: LD_ADDR_OWVAR 20
9119: PUSH
9120: LD_INT 8
9122: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
9123: LD_ADDR_VAR 0 2
9127: PUSH
9128: LD_INT 59
9130: PUSH
9131: LD_INT 71
9133: PUSH
9134: EMPTY
9135: LIST
9136: LIST
9137: PUSH
9138: LD_INT 122
9140: PUSH
9141: LD_INT 117
9143: PUSH
9144: EMPTY
9145: LIST
9146: LIST
9147: PUSH
9148: EMPTY
9149: LIST
9150: LIST
9151: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9152: LD_ADDR_EXP 49
9156: PUSH
9157: LD_STRING Frank
9159: PPUSH
9160: LD_INT 0
9162: PPUSH
9163: CALL 466 0 2
9167: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9168: LD_ADDR_VAR 0 1
9172: PUSH
9173: LD_INT 1
9175: PPUSH
9176: LD_INT 2
9178: PPUSH
9179: CALL_OW 12
9183: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9184: LD_EXP 49
9188: PPUSH
9189: LD_VAR 0 2
9193: PUSH
9194: LD_VAR 0 1
9198: ARRAY
9199: PUSH
9200: LD_INT 1
9202: ARRAY
9203: PPUSH
9204: LD_VAR 0 2
9208: PUSH
9209: LD_VAR 0 1
9213: ARRAY
9214: PUSH
9215: LD_INT 2
9217: ARRAY
9218: PPUSH
9219: LD_INT 0
9221: PPUSH
9222: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9226: LD_EXP 49
9230: PPUSH
9231: LD_INT 1
9233: PPUSH
9234: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9238: LD_INT 35
9240: PPUSH
9241: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
9245: LD_EXP 49
9249: PPUSH
9250: LD_EXP 35
9254: PPUSH
9255: CALL_OW 296
9259: PUSH
9260: LD_INT 8
9262: LESS
9263: IFFALSE 9238
// InGameOn ;
9265: CALL_OW 8
// CenterOnUnits ( JMM ) ;
9269: LD_EXP 35
9273: PPUSH
9274: CALL_OW 85
// if IsInUnit ( JMM ) then
9278: LD_EXP 35
9282: PPUSH
9283: CALL_OW 310
9287: IFFALSE 9298
// ComFree ( JMM ) ;
9289: LD_EXP 35
9293: PPUSH
9294: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9298: LD_EXP 35
9302: PPUSH
9303: LD_EXP 49
9307: PPUSH
9308: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9312: LD_EXP 49
9316: PPUSH
9317: LD_EXP 35
9321: PPUSH
9322: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9326: LD_EXP 35
9330: PPUSH
9331: LD_STRING D6-JMM-1
9333: PPUSH
9334: CALL_OW 88
// repeat wait ( 3 ) ;
9338: LD_INT 3
9340: PPUSH
9341: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
9345: LD_EXP 35
9349: PPUSH
9350: LD_EXP 49
9354: PPUSH
9355: CALL_OW 296
9359: PUSH
9360: LD_INT 8
9362: LESS
9363: IFFALSE 9338
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9365: LD_EXP 38
9369: PUSH
9370: LD_EXP 38
9374: PPUSH
9375: LD_EXP 49
9379: PPUSH
9380: CALL_OW 296
9384: PUSH
9385: LD_INT 20
9387: LESS
9388: AND
9389: IFFALSE 9414
// begin ComFree ( Lisa ) ;
9391: LD_EXP 38
9395: PPUSH
9396: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9400: LD_EXP 38
9404: PPUSH
9405: LD_EXP 49
9409: PPUSH
9410: CALL_OW 172
// end ; if Lynch then
9414: LD_EXP 45
9418: IFFALSE 9443
// begin ComFree ( Lynch ) ;
9420: LD_EXP 45
9424: PPUSH
9425: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9429: LD_EXP 45
9433: PPUSH
9434: LD_EXP 49
9438: PPUSH
9439: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9443: LD_EXP 35
9447: PPUSH
9448: LD_EXP 49
9452: PPUSH
9453: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9457: LD_EXP 49
9461: PPUSH
9462: LD_EXP 35
9466: PPUSH
9467: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9471: LD_EXP 49
9475: PPUSH
9476: LD_STRING D6-Frank-1
9478: PPUSH
9479: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9483: LD_INT 69
9485: PPUSH
9486: LD_INT 20
9488: PPUSH
9489: LD_INT 1
9491: PPUSH
9492: LD_INT 20
9494: NEG
9495: PPUSH
9496: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9500: LD_INT 69
9502: PPUSH
9503: LD_INT 20
9505: PPUSH
9506: LD_INT 1
9508: PPUSH
9509: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9513: LD_INT 190
9515: PPUSH
9516: LD_INT 31
9518: PPUSH
9519: LD_INT 1
9521: PPUSH
9522: LD_INT 20
9524: NEG
9525: PPUSH
9526: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9530: LD_INT 190
9532: PPUSH
9533: LD_INT 31
9535: PPUSH
9536: LD_INT 1
9538: PPUSH
9539: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9543: LD_INT 69
9545: PPUSH
9546: LD_INT 20
9548: PPUSH
9549: CALL_OW 84
// Wait ( 0 0$02 ) ;
9553: LD_INT 70
9555: PPUSH
9556: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9560: LD_EXP 35
9564: PPUSH
9565: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9569: LD_EXP 38
9573: PUSH
9574: LD_EXP 38
9578: PPUSH
9579: LD_EXP 49
9583: PPUSH
9584: CALL_OW 296
9588: PUSH
9589: LD_INT 20
9591: LESS
9592: AND
9593: PUSH
9594: LD_EXP 38
9598: PPUSH
9599: CALL_OW 302
9603: AND
9604: IFFALSE 9694
// begin ComFree ( Lisa ) ;
9606: LD_EXP 38
9610: PPUSH
9611: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
9615: LD_INT 35
9617: PPUSH
9618: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
9622: LD_EXP 38
9626: PPUSH
9627: LD_EXP 49
9631: PPUSH
9632: CALL_OW 296
9636: PUSH
9637: LD_INT 7
9639: LESS
9640: IFFALSE 9615
// Say ( Lisa , D6-Lisa-1 ) ;
9642: LD_EXP 38
9646: PPUSH
9647: LD_STRING D6-Lisa-1
9649: PPUSH
9650: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9654: LD_EXP 38
9658: PPUSH
9659: LD_EXP 49
9663: PPUSH
9664: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9668: LD_EXP 49
9672: PPUSH
9673: LD_EXP 38
9677: PPUSH
9678: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9682: LD_EXP 49
9686: PPUSH
9687: LD_STRING D6-Frank-2
9689: PPUSH
9690: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9694: LD_EXP 45
9698: PUSH
9699: LD_EXP 45
9703: PPUSH
9704: LD_EXP 49
9708: PPUSH
9709: CALL_OW 296
9713: PUSH
9714: LD_INT 20
9716: LESS
9717: AND
9718: PUSH
9719: LD_EXP 45
9723: PPUSH
9724: CALL_OW 302
9728: AND
9729: IFFALSE 9910
// begin ComTurnUnit ( Lynch , JMM ) ;
9731: LD_EXP 45
9735: PPUSH
9736: LD_EXP 35
9740: PPUSH
9741: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9745: LD_EXP 49
9749: PPUSH
9750: LD_EXP 35
9754: PPUSH
9755: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9759: LD_EXP 45
9763: PPUSH
9764: LD_STRING D6-Sol1-2
9766: PPUSH
9767: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9771: LD_EXP 35
9775: PPUSH
9776: LD_STRING D6-JMM-2
9778: PPUSH
9779: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9783: LD_EXP 49
9787: PPUSH
9788: LD_STRING D6-Frank-3
9790: PPUSH
9791: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9795: LD_EXP 35
9799: PPUSH
9800: LD_STRING D6-JMM-3
9802: PPUSH
9803: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9807: LD_EXP 49
9811: PPUSH
9812: LD_STRING D6-Frank-4
9814: PPUSH
9815: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9819: LD_EXP 49
9823: PPUSH
9824: LD_STRING D6-Frank-4a
9826: PPUSH
9827: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9831: LD_EXP 35
9835: PPUSH
9836: LD_STRING D6-JMM-4
9838: PPUSH
9839: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9843: LD_EXP 49
9847: PPUSH
9848: LD_STRING D6-Frank-5
9850: PPUSH
9851: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9855: LD_EXP 38
9859: PUSH
9860: LD_EXP 38
9864: PPUSH
9865: CALL_OW 302
9869: AND
9870: IFFALSE 9884
// Say ( Lisa , D6-Lisa-5 ) ;
9872: LD_EXP 38
9876: PPUSH
9877: LD_STRING D6-Lisa-5
9879: PPUSH
9880: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9884: LD_EXP 49
9888: PPUSH
9889: LD_STRING D6-Frank-6
9891: PPUSH
9892: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9896: LD_EXP 35
9900: PPUSH
9901: LD_STRING D6-JMM-6
9903: PPUSH
9904: CALL_OW 88
// end else
9908: GO 10025
// begin ComTurnUnit ( Frank , JMM ) ;
9910: LD_EXP 49
9914: PPUSH
9915: LD_EXP 35
9919: PPUSH
9920: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
9924: LD_EXP 49
9928: PPUSH
9929: LD_STRING D6-Frank-4
9931: PPUSH
9932: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9936: LD_EXP 49
9940: PPUSH
9941: LD_STRING D6-Frank-4a
9943: PPUSH
9944: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9948: LD_EXP 35
9952: PPUSH
9953: LD_STRING D6-JMM-4
9955: PPUSH
9956: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9960: LD_EXP 49
9964: PPUSH
9965: LD_STRING D6-Frank-5
9967: PPUSH
9968: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9972: LD_EXP 38
9976: PUSH
9977: LD_EXP 38
9981: PPUSH
9982: CALL_OW 302
9986: AND
9987: IFFALSE 10001
// Say ( Lisa , D6-Lisa-5 ) ;
9989: LD_EXP 38
9993: PPUSH
9994: LD_STRING D6-Lisa-5
9996: PPUSH
9997: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10001: LD_EXP 49
10005: PPUSH
10006: LD_STRING D6-Frank-6
10008: PPUSH
10009: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10013: LD_EXP 35
10017: PPUSH
10018: LD_STRING D6-JMM-6
10020: PPUSH
10021: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
10025: LD_STRING Q1
10027: PPUSH
10028: CALL_OW 97
10032: PUSH
10033: LD_INT 1
10035: DOUBLE
10036: EQUAL
10037: IFTRUE 10041
10039: GO 10052
10041: POP
// frank_send_to_scout := true ; 2 :
10042: LD_ADDR_EXP 14
10046: PUSH
10047: LD_INT 1
10049: ST_TO_ADDR
10050: GO 10072
10052: LD_INT 2
10054: DOUBLE
10055: EQUAL
10056: IFTRUE 10060
10058: GO 10071
10060: POP
// frank_send_to_scout := false ; end ;
10061: LD_ADDR_EXP 14
10065: PUSH
10066: LD_INT 0
10068: ST_TO_ADDR
10069: GO 10072
10071: POP
// InGameOff ;
10072: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
10076: LD_EXP 35
10080: PUSH
10081: LD_EXP 38
10085: PUSH
10086: LD_EXP 45
10090: PUSH
10091: EMPTY
10092: LIST
10093: LIST
10094: LIST
10095: PPUSH
10096: CALL_OW 139
// if frank_send_to_scout then
10100: LD_EXP 14
10104: IFFALSE 10161
// begin ComMoveXY ( Frank , 130 , 123 ) ;
10106: LD_EXP 49
10110: PPUSH
10111: LD_INT 130
10113: PPUSH
10114: LD_INT 123
10116: PPUSH
10117: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
10121: LD_INT 35
10123: PPUSH
10124: CALL_OW 67
// until not See ( 1 , Frank ) ;
10128: LD_INT 1
10130: PPUSH
10131: LD_EXP 49
10135: PPUSH
10136: CALL_OW 292
10140: NOT
10141: IFFALSE 10121
// Wait ( 0 0$02 ) ;
10143: LD_INT 70
10145: PPUSH
10146: CALL_OW 67
// RemoveUnit ( Frank ) ;
10150: LD_EXP 49
10154: PPUSH
10155: CALL_OW 64
// end else
10159: GO 10173
// SetSide ( Frank , 1 ) ;
10161: LD_EXP 49
10165: PPUSH
10166: LD_INT 1
10168: PPUSH
10169: CALL_OW 235
// send_attack_on_cornel_base := true ;
10173: LD_ADDR_EXP 25
10177: PUSH
10178: LD_INT 1
10180: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10181: LD_INT 35
10183: PPUSH
10184: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10188: LD_ADDR_EXP 27
10192: PUSH
10193: LD_EXP 27
10197: PPUSH
10198: LD_STRING -
10200: PPUSH
10201: CALL 1109 0 2
10205: ST_TO_ADDR
// if debug then
10206: LD_EXP 1
10210: IFFALSE 10222
// debug_strings := time_to_prepare ;
10212: LD_ADDR_OWVAR 48
10216: PUSH
10217: LD_EXP 27
10221: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10222: LD_EXP 27
10226: PUSH
10227: LD_INT 0
10229: EQUAL
10230: IFFALSE 10181
// cornel_prepared := true ;
10232: LD_ADDR_EXP 11
10236: PUSH
10237: LD_INT 1
10239: ST_TO_ADDR
// end ;
10240: PPOPN 2
10242: END
// every 0 0$01 trigger cornel_prepared do
10243: LD_EXP 11
10247: IFFALSE 10504
10249: GO 10251
10251: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10252: LD_EXP 42
10256: PPUSH
10257: LD_STRING D3-Corn-1
10259: PPUSH
10260: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10264: LD_INT 35
10266: PPUSH
10267: CALL_OW 67
// until cornel_counter = 0 ;
10271: LD_EXP 10
10275: PUSH
10276: LD_INT 0
10278: EQUAL
10279: IFFALSE 10264
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10281: LD_EXP 42
10285: PPUSH
10286: LD_STRING D3a-Corn-1
10288: PPUSH
10289: CALL_OW 94
// if IsOk ( Cornel ) then
10293: LD_EXP 42
10297: PPUSH
10298: CALL_OW 302
10302: IFFALSE 10316
// Say ( JMM , D3a-JMM-1 ) ;
10304: LD_EXP 35
10308: PPUSH
10309: LD_STRING D3a-JMM-1
10311: PPUSH
10312: CALL_OW 88
// end_mission_allowed := true ;
10316: LD_ADDR_EXP 20
10320: PUSH
10321: LD_INT 1
10323: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10324: LD_STRING M2
10326: PPUSH
10327: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10331: LD_INT 9
10333: PPUSH
10334: LD_INT 1
10336: PPUSH
10337: CALL_OW 424
// Wait ( 0 0$05 ) ;
10341: LD_INT 175
10343: PPUSH
10344: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10348: LD_EXP 42
10352: PPUSH
10353: LD_STRING D3a-Corn-2
10355: PPUSH
10356: CALL_OW 94
// cornel_attack := true ;
10360: LD_ADDR_EXP 9
10364: PUSH
10365: LD_INT 1
10367: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10368: LD_INT 105
10370: PPUSH
10371: CALL_OW 67
// AddMoreTanks ( ) ;
10375: CALL 4826 0 0
// if frank_send_to_scout then
10379: LD_EXP 14
10383: IFFALSE 10504
// begin InitHc ;
10385: CALL_OW 19
// InitUc ;
10389: CALL_OW 18
// uc_side := 8 ;
10393: LD_ADDR_OWVAR 20
10397: PUSH
10398: LD_INT 8
10400: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10401: LD_ADDR_EXP 49
10405: PUSH
10406: LD_STRING Frank
10408: PPUSH
10409: LD_INT 0
10411: PPUSH
10412: CALL 466 0 2
10416: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10417: LD_EXP 49
10421: PPUSH
10422: LD_INT 6
10424: PPUSH
10425: LD_INT 9
10427: PPUSH
10428: LD_INT 0
10430: PPUSH
10431: CALL_OW 48
// ComCrawl ( Frank ) ;
10435: LD_EXP 49
10439: PPUSH
10440: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
10444: LD_INT 35
10446: PPUSH
10447: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
10451: LD_EXP 35
10455: PPUSH
10456: LD_EXP 49
10460: PPUSH
10461: CALL_OW 296
10465: PUSH
10466: LD_INT 9
10468: LESS
10469: IFFALSE 10444
// SetSide ( Frank , 1 ) ;
10471: LD_EXP 49
10475: PPUSH
10476: LD_INT 1
10478: PPUSH
10479: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10483: LD_EXP 49
10487: PPUSH
10488: LD_STRING D6a-Frank-1
10490: PPUSH
10491: CALL_OW 88
// ComWalk ( Frank ) ;
10495: LD_EXP 49
10499: PPUSH
10500: CALL_OW 138
// end ; end ;
10504: END
// every 0 0$01 trigger solar_builded do
10505: LD_EXP 13
10509: IFFALSE 10613
10511: GO 10513
10513: DISABLE
// begin Wait ( 0 0$02 ) ;
10514: LD_INT 70
10516: PPUSH
10517: CALL_OW 67
// DialogueOn ;
10521: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10525: LD_EXP 35
10529: PPUSH
10530: LD_STRING D2b-JMM-1
10532: PPUSH
10533: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10537: LD_EXP 46
10541: PUSH
10542: LD_EXP 46
10546: PPUSH
10547: CALL_OW 302
10551: AND
10552: IFFALSE 10602
// begin Say ( Walker , D2b-Sci1-1 ) ;
10554: LD_EXP 46
10558: PPUSH
10559: LD_STRING D2b-Sci1-1
10561: PPUSH
10562: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10566: LD_EXP 35
10570: PPUSH
10571: LD_STRING D2b-JMM-2
10573: PPUSH
10574: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10578: LD_EXP 46
10582: PPUSH
10583: LD_STRING D2b-Sci1-2
10585: PPUSH
10586: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10590: LD_EXP 35
10594: PPUSH
10595: LD_STRING D2b-JMM-3
10597: PPUSH
10598: CALL_OW 88
// end ; DialogueOff ;
10602: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10606: LD_STRING MOutSol
10608: PPUSH
10609: CALL_OW 337
// end ;
10613: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10614: LD_EXP 13
10618: PUSH
10619: LD_EXP 35
10623: PPUSH
10624: CALL_OW 302
10628: AND
10629: PUSH
10630: LD_EXP 35
10634: PPUSH
10635: CALL 943 0 1
10639: AND
10640: PUSH
10641: LD_EXP 15
10645: NOT
10646: AND
10647: IFFALSE 10718
10649: GO 10651
10651: DISABLE
10652: LD_INT 0
10654: PPUSH
// begin jmm_in_veh := true ;
10655: LD_ADDR_EXP 15
10659: PUSH
10660: LD_INT 1
10662: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10663: LD_ADDR_VAR 0 1
10667: PUSH
10668: LD_INT 0
10670: PPUSH
10671: LD_INT 1
10673: PPUSH
10674: CALL_OW 12
10678: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10679: LD_INT 70
10681: PPUSH
10682: CALL_OW 67
// if i then
10686: LD_VAR 0 1
10690: IFFALSE 10706
// Say ( JMM , D2c-JMM-1 ) else
10692: LD_EXP 35
10696: PPUSH
10697: LD_STRING D2c-JMM-1
10699: PPUSH
10700: CALL_OW 88
10704: GO 10718
// Say ( JMM , D2c-JMM-1a ) ;
10706: LD_EXP 35
10710: PPUSH
10711: LD_STRING D2c-JMM-1a
10713: PPUSH
10714: CALL_OW 88
// end ;
10718: PPOPN 1
10720: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10721: LD_EXP 13
10725: PUSH
10726: LD_EXP 36
10730: PPUSH
10731: CALL_OW 302
10735: AND
10736: PUSH
10737: LD_EXP 36
10741: PPUSH
10742: CALL 943 0 1
10746: AND
10747: PUSH
10748: LD_EXP 16
10752: NOT
10753: AND
10754: IFFALSE 10786
10756: GO 10758
10758: DISABLE
// begin bobby_in_veh := true ;
10759: LD_ADDR_EXP 16
10763: PUSH
10764: LD_INT 1
10766: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10767: LD_INT 70
10769: PPUSH
10770: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10774: LD_EXP 36
10778: PPUSH
10779: LD_STRING D2c-Bobby-1
10781: PPUSH
10782: CALL_OW 88
10786: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10787: LD_EXP 13
10791: PUSH
10792: LD_EXP 38
10796: PPUSH
10797: CALL_OW 302
10801: AND
10802: PUSH
10803: LD_EXP 38
10807: PPUSH
10808: CALL 943 0 1
10812: AND
10813: PUSH
10814: LD_EXP 18
10818: NOT
10819: AND
10820: IFFALSE 10852
10822: GO 10824
10824: DISABLE
// begin lisa_in_veh := true ;
10825: LD_ADDR_EXP 18
10829: PUSH
10830: LD_INT 1
10832: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10833: LD_INT 70
10835: PPUSH
10836: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10840: LD_EXP 38
10844: PPUSH
10845: LD_STRING D2c-Lisa-1
10847: PPUSH
10848: CALL_OW 88
10852: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
10853: LD_EXP 13
10857: PUSH
10858: LD_EXP 37
10862: PPUSH
10863: CALL_OW 302
10867: AND
10868: PUSH
10869: LD_EXP 37
10873: PPUSH
10874: CALL 943 0 1
10878: AND
10879: PUSH
10880: LD_EXP 17
10884: NOT
10885: AND
10886: IFFALSE 10957
10888: GO 10890
10890: DISABLE
10891: LD_INT 0
10893: PPUSH
// begin cyrus_in_veh := true ;
10894: LD_ADDR_EXP 17
10898: PUSH
10899: LD_INT 1
10901: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10902: LD_ADDR_VAR 0 1
10906: PUSH
10907: LD_INT 0
10909: PPUSH
10910: LD_INT 1
10912: PPUSH
10913: CALL_OW 12
10917: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10918: LD_INT 70
10920: PPUSH
10921: CALL_OW 67
// if i then
10925: LD_VAR 0 1
10929: IFFALSE 10945
// Say ( Cyrus , D2c-Cyrus-1 ) else
10931: LD_EXP 37
10935: PPUSH
10936: LD_STRING D2c-Cyrus-1
10938: PPUSH
10939: CALL_OW 88
10943: GO 10957
// Say ( Cyrus , D2c-Cyrus-1a ) ;
10945: LD_EXP 37
10949: PPUSH
10950: LD_STRING D2c-Cyrus-1a
10952: PPUSH
10953: CALL_OW 88
// end ;
10957: PPOPN 1
10959: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
10960: LD_EXP 42
10964: PPUSH
10965: LD_INT 16
10967: PPUSH
10968: CALL_OW 308
10972: IFFALSE 11228
10974: GO 10976
10976: DISABLE
10977: LD_INT 0
10979: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
10980: LD_INT 3
10982: PPUSH
10983: LD_EXP 42
10987: PPUSH
10988: CALL_OW 471
// send_attack_on_cornel := true ;
10992: LD_ADDR_EXP 30
10996: PUSH
10997: LD_INT 1
10999: ST_TO_ADDR
// if ru_vehicles then
11000: LD_EXP 54
11004: IFFALSE 11038
// for i in ru_vehicles do
11006: LD_ADDR_VAR 0 1
11010: PUSH
11011: LD_EXP 54
11015: PUSH
11016: FOR_IN
11017: IFFALSE 11036
// ComAgressiveMove ( i , 215 , 69 ) ;
11019: LD_VAR 0 1
11023: PPUSH
11024: LD_INT 215
11026: PPUSH
11027: LD_INT 69
11029: PPUSH
11030: CALL_OW 114
11034: GO 11016
11036: POP
11037: POP
// if ru_patrol then
11038: LD_EXP 51
11042: IFFALSE 11076
// for i in ru_patrol do
11044: LD_ADDR_VAR 0 1
11048: PUSH
11049: LD_EXP 51
11053: PUSH
11054: FOR_IN
11055: IFFALSE 11074
// ComAgressiveMove ( i , 215 , 69 ) ;
11057: LD_VAR 0 1
11061: PPUSH
11062: LD_INT 215
11064: PPUSH
11065: LD_INT 69
11067: PPUSH
11068: CALL_OW 114
11072: GO 11054
11074: POP
11075: POP
// if frank_send_to_scout then
11076: LD_EXP 14
11080: IFFALSE 11094
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
11082: LD_EXP 49
11086: PPUSH
11087: LD_STRING D3b-Frank-1
11089: PPUSH
11090: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
11094: LD_INT 105
11096: PPUSH
11097: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
11101: LD_EXP 42
11105: PPUSH
11106: LD_STRING D4-Corn-1
11108: PPUSH
11109: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
11113: LD_INT 35
11115: PPUSH
11116: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 6 ;
11120: LD_INT 22
11122: PUSH
11123: LD_INT 4
11125: PUSH
11126: EMPTY
11127: LIST
11128: LIST
11129: PUSH
11130: LD_INT 21
11132: PUSH
11133: LD_INT 1
11135: PUSH
11136: EMPTY
11137: LIST
11138: LIST
11139: PUSH
11140: LD_INT 50
11142: PUSH
11143: EMPTY
11144: LIST
11145: PUSH
11146: EMPTY
11147: LIST
11148: LIST
11149: LIST
11150: PPUSH
11151: CALL_OW 69
11155: PUSH
11156: LD_INT 6
11158: LESS
11159: IFFALSE 11113
// SayRadio ( Cornel , D5-Corn-1 ) ;
11161: LD_EXP 42
11165: PPUSH
11166: LD_STRING D5-Corn-1
11168: PPUSH
11169: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11173: LD_EXP 42
11177: PPUSH
11178: LD_EXP 2
11182: PUSH
11183: LD_STRING Cornel
11185: STR
11186: PPUSH
11187: CALL_OW 38
// ChangeSideFog ( 4 , 8 ) ;
11191: LD_INT 4
11193: PPUSH
11194: LD_INT 8
11196: PPUSH
11197: CALL_OW 343
// Wait ( 0 0$01 ) ;
11201: LD_INT 35
11203: PPUSH
11204: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11208: LD_INT 3
11210: PPUSH
11211: LD_EXP 42
11215: PPUSH
11216: CALL_OW 472
// send_attack_on_cornel := false ;
11220: LD_ADDR_EXP 30
11224: PUSH
11225: LD_INT 0
11227: ST_TO_ADDR
// end ;
11228: PPOPN 1
11230: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11231: LD_INT 9
11233: PPUSH
11234: LD_INT 22
11236: PUSH
11237: LD_INT 1
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: PPUSH
11244: CALL_OW 70
11248: PUSH
11249: LD_EXP 31
11253: OR
11254: IFFALSE 11436
11256: GO 11258
11258: DISABLE
11259: LD_INT 0
11261: PPUSH
11262: PPUSH
// begin enable ;
11263: ENABLE
// if not jmm_on_west then
11264: LD_EXP 5
11268: NOT
11269: IFFALSE 11280
// begin YouLost ( 4 ) ;
11271: LD_STRING 4
11273: PPUSH
11274: CALL_OW 104
// exit ;
11278: GO 11436
// end ; if not game_end then
11280: LD_EXP 31
11284: NOT
11285: IFFALSE 11295
// game_end := true ;
11287: LD_ADDR_EXP 31
11291: PUSH
11292: LD_INT 1
11294: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11295: LD_ADDR_VAR 0 2
11299: PUSH
11300: LD_INT 9
11302: PPUSH
11303: LD_INT 22
11305: PUSH
11306: LD_INT 1
11308: PUSH
11309: EMPTY
11310: LIST
11311: LIST
11312: PPUSH
11313: CALL_OW 70
11317: ST_TO_ADDR
// if not filter then
11318: LD_VAR 0 2
11322: NOT
11323: IFFALSE 11327
// exit ;
11325: GO 11436
// for i in filter do
11327: LD_ADDR_VAR 0 1
11331: PUSH
11332: LD_VAR 0 2
11336: PUSH
11337: FOR_IN
11338: IFFALSE 11434
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
11340: LD_VAR 0 1
11344: PPUSH
11345: CALL_OW 302
11349: PUSH
11350: LD_VAR 0 1
11354: PPUSH
11355: CALL_OW 247
11359: PUSH
11360: LD_INT 2
11362: EQUAL
11363: AND
11364: IFFALSE 11397
// begin veh_on_meta := true ;
11366: LD_ADDR_EXP 26
11370: PUSH
11371: LD_INT 1
11373: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11374: LD_VAR 0 1
11378: PPUSH
11379: CALL_OW 311
11383: PPUSH
11384: CALL 11439 0 1
// RemoveUnit ( i ) ;
11388: LD_VAR 0 1
11392: PPUSH
11393: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11397: LD_VAR 0 1
11401: PPUSH
11402: CALL_OW 302
11406: PUSH
11407: LD_VAR 0 1
11411: PPUSH
11412: CALL_OW 247
11416: PUSH
11417: LD_INT 1
11419: EQUAL
11420: AND
11421: IFFALSE 11432
// Save ( i ) ;
11423: LD_VAR 0 1
11427: PPUSH
11428: CALL 11439 0 1
// end ;
11432: GO 11337
11434: POP
11435: POP
// end ;
11436: PPOPN 2
11438: END
// export function Save ( i ) ; begin
11439: LD_INT 0
11441: PPUSH
// save_counter := save_counter + 1 ;
11442: LD_ADDR_EXP 34
11446: PUSH
11447: LD_EXP 34
11451: PUSH
11452: LD_INT 1
11454: PLUS
11455: ST_TO_ADDR
// if i = JMM then
11456: LD_VAR 0 1
11460: PUSH
11461: LD_EXP 35
11465: EQUAL
11466: IFFALSE 11588
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11468: LD_EXP 23
11472: PUSH
11473: LD_INT 22
11475: PUSH
11476: LD_INT 1
11478: PUSH
11479: EMPTY
11480: LIST
11481: LIST
11482: PUSH
11483: LD_INT 21
11485: PUSH
11486: LD_INT 1
11488: PUSH
11489: EMPTY
11490: LIST
11491: LIST
11492: PUSH
11493: EMPTY
11494: LIST
11495: LIST
11496: PPUSH
11497: CALL_OW 69
11501: PUSH
11502: LD_INT 1
11504: GREATER
11505: AND
11506: IFFALSE 11563
// begin show_query := false ;
11508: LD_ADDR_EXP 23
11512: PUSH
11513: LD_INT 0
11515: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11516: LD_STRING Q2
11518: PPUSH
11519: CALL_OW 97
11523: PUSH
11524: LD_INT 1
11526: DOUBLE
11527: EQUAL
11528: IFTRUE 11532
11530: GO 11543
11532: POP
// wait_for_them := true ; 2 :
11533: LD_ADDR_EXP 24
11537: PUSH
11538: LD_INT 1
11540: ST_TO_ADDR
11541: GO 11563
11543: LD_INT 2
11545: DOUBLE
11546: EQUAL
11547: IFTRUE 11551
11549: GO 11562
11551: POP
// wait_for_them := false ; end ;
11552: LD_ADDR_EXP 24
11556: PUSH
11557: LD_INT 0
11559: ST_TO_ADDR
11560: GO 11563
11562: POP
// end ; save_group := save_group ^ JMM ;
11563: LD_ADDR_EXP 22
11567: PUSH
11568: LD_EXP 22
11572: PUSH
11573: LD_EXP 35
11577: ADD
11578: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11579: LD_EXP 35
11583: PPUSH
11584: CALL_OW 64
// end ; if i = Lisa then
11588: LD_VAR 0 1
11592: PUSH
11593: LD_EXP 38
11597: EQUAL
11598: IFFALSE 11625
// begin save_group := save_group ^ Lisa ;
11600: LD_ADDR_EXP 22
11604: PUSH
11605: LD_EXP 22
11609: PUSH
11610: LD_EXP 38
11614: ADD
11615: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11616: LD_EXP 38
11620: PPUSH
11621: CALL_OW 64
// end ; if i = Bobby then
11625: LD_VAR 0 1
11629: PUSH
11630: LD_EXP 36
11634: EQUAL
11635: IFFALSE 11662
// begin save_group := save_group ^ Bobby ;
11637: LD_ADDR_EXP 22
11641: PUSH
11642: LD_EXP 22
11646: PUSH
11647: LD_EXP 36
11651: ADD
11652: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11653: LD_EXP 36
11657: PPUSH
11658: CALL_OW 64
// end ; if i = Cyrus then
11662: LD_VAR 0 1
11666: PUSH
11667: LD_EXP 37
11671: EQUAL
11672: IFFALSE 11699
// begin save_group := save_group ^ Cyrus ;
11674: LD_ADDR_EXP 22
11678: PUSH
11679: LD_EXP 22
11683: PUSH
11684: LD_EXP 37
11688: ADD
11689: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11690: LD_EXP 37
11694: PPUSH
11695: CALL_OW 64
// end ; if i = Khatam then
11699: LD_VAR 0 1
11703: PUSH
11704: LD_EXP 39
11708: EQUAL
11709: IFFALSE 11736
// begin save_group := save_group ^ Khatam ;
11711: LD_ADDR_EXP 22
11715: PUSH
11716: LD_EXP 22
11720: PUSH
11721: LD_EXP 39
11725: ADD
11726: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11727: LD_EXP 39
11731: PPUSH
11732: CALL_OW 64
// end ; if i = Frank then
11736: LD_VAR 0 1
11740: PUSH
11741: LD_EXP 49
11745: EQUAL
11746: IFFALSE 11773
// begin save_group := save_group ^ Frank ;
11748: LD_ADDR_EXP 22
11752: PUSH
11753: LD_EXP 22
11757: PUSH
11758: LD_EXP 49
11762: ADD
11763: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11764: LD_EXP 49
11768: PPUSH
11769: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11773: LD_VAR 0 1
11777: PPUSH
11778: CALL_OW 302
11782: PUSH
11783: LD_VAR 0 1
11787: PPUSH
11788: CALL_OW 247
11792: PUSH
11793: LD_INT 1
11795: EQUAL
11796: AND
11797: PUSH
11798: LD_VAR 0 1
11802: PUSH
11803: LD_EXP 22
11807: IN
11808: NOT
11809: AND
11810: IFFALSE 11837
// begin save_others := save_others ^ i ;
11812: LD_ADDR_EXP 21
11816: PUSH
11817: LD_EXP 21
11821: PUSH
11822: LD_VAR 0 1
11826: ADD
11827: ST_TO_ADDR
// RemoveUnit ( i ) ;
11828: LD_VAR 0 1
11832: PPUSH
11833: CALL_OW 64
// end ; end ;
11837: LD_VAR 0 2
11841: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
11842: LD_EXP 23
11846: NOT
11847: PUSH
11848: LD_EXP 24
11852: NOT
11853: AND
11854: PUSH
11855: LD_INT 22
11857: PUSH
11858: LD_INT 1
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: PUSH
11865: LD_INT 21
11867: PUSH
11868: LD_INT 1
11870: PUSH
11871: EMPTY
11872: LIST
11873: LIST
11874: PUSH
11875: EMPTY
11876: LIST
11877: LIST
11878: PPUSH
11879: CALL_OW 69
11883: PUSH
11884: LD_INT 0
11886: EQUAL
11887: OR
11888: IFFALSE 11897
11890: GO 11892
11892: DISABLE
// EndMission ;
11893: CALL 11898 0 0
11897: END
// export function EndMission ; var i ; begin
11898: LD_INT 0
11900: PPUSH
11901: PPUSH
// Wait ( 0 0$02 ) ;
11902: LD_INT 70
11904: PPUSH
11905: CALL_OW 67
// if solar_builded then
11909: LD_EXP 13
11913: IFFALSE 11927
// AddMedal ( Solar1 , 1 ) else
11915: LD_STRING Solar1
11917: PPUSH
11918: LD_INT 1
11920: PPUSH
11921: CALL_OW 101
11925: GO 11938
// AddMedal ( Solar1 , - 1 ) ;
11927: LD_STRING Solar1
11929: PPUSH
11930: LD_INT 1
11932: NEG
11933: PPUSH
11934: CALL_OW 101
// if veh_on_meta then
11938: LD_EXP 26
11942: IFFALSE 11956
// AddMedal ( Solar2 , 1 ) else
11944: LD_STRING Solar2
11946: PPUSH
11947: LD_INT 1
11949: PPUSH
11950: CALL_OW 101
11954: GO 11986
// if solar_builded then
11956: LD_EXP 13
11960: IFFALSE 11975
// AddMedal ( Solar2 , - 1 ) else
11962: LD_STRING Solar2
11964: PPUSH
11965: LD_INT 1
11967: NEG
11968: PPUSH
11969: CALL_OW 101
11973: GO 11986
// AddMedal ( Solar2 , - 2 ) ;
11975: LD_STRING Solar2
11977: PPUSH
11978: LD_INT 2
11980: NEG
11981: PPUSH
11982: CALL_OW 101
// if lose_counter = 0 then
11986: LD_EXP 32
11990: PUSH
11991: LD_INT 0
11993: EQUAL
11994: IFFALSE 12008
// AddMedal ( No , 1 ) else
11996: LD_STRING No
11998: PPUSH
11999: LD_INT 1
12001: PPUSH
12002: CALL_OW 101
12006: GO 12052
// if lose_counter > 0 and lose_counter < 4 then
12008: LD_EXP 32
12012: PUSH
12013: LD_INT 0
12015: GREATER
12016: PUSH
12017: LD_EXP 32
12021: PUSH
12022: LD_INT 4
12024: LESS
12025: AND
12026: IFFALSE 12041
// AddMedal ( No , - 1 ) else
12028: LD_STRING No
12030: PPUSH
12031: LD_INT 1
12033: NEG
12034: PPUSH
12035: CALL_OW 101
12039: GO 12052
// AddMedal ( UpTo4 , - 1 ) ;
12041: LD_STRING UpTo4
12043: PPUSH
12044: LD_INT 1
12046: NEG
12047: PPUSH
12048: CALL_OW 101
// GiveMedals ( MAIN ) ;
12052: LD_STRING MAIN
12054: PPUSH
12055: CALL_OW 102
// if IsDead ( Pokryshkin ) then
12059: LD_EXP 50
12063: PPUSH
12064: CALL_OW 301
12068: IFFALSE 12108
// for i in save_group ^ save_others do
12070: LD_ADDR_VAR 0 2
12074: PUSH
12075: LD_EXP 22
12079: PUSH
12080: LD_EXP 21
12084: ADD
12085: PUSH
12086: FOR_IN
12087: IFFALSE 12106
// AddExperience ( i , skill_combat , 1500 ) ;
12089: LD_VAR 0 2
12093: PPUSH
12094: LD_INT 1
12096: PPUSH
12097: LD_INT 1500
12099: PPUSH
12100: CALL_OW 492
12104: GO 12086
12106: POP
12107: POP
// RewardPeople ( save_group ^ save_others ) ;
12108: LD_EXP 22
12112: PUSH
12113: LD_EXP 21
12117: ADD
12118: PPUSH
12119: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
12123: LD_EXP 35
12127: PPUSH
12128: LD_EXP 2
12132: PUSH
12133: LD_STRING JMM
12135: STR
12136: PPUSH
12137: CALL_OW 38
// if Bobby in save_group then
12141: LD_EXP 36
12145: PUSH
12146: LD_EXP 22
12150: IN
12151: IFFALSE 12171
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12153: LD_EXP 36
12157: PPUSH
12158: LD_EXP 2
12162: PUSH
12163: LD_STRING Bobby
12165: STR
12166: PPUSH
12167: CALL_OW 38
// if Cyrus in save_group then
12171: LD_EXP 37
12175: PUSH
12176: LD_EXP 22
12180: IN
12181: IFFALSE 12201
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12183: LD_EXP 37
12187: PPUSH
12188: LD_EXP 2
12192: PUSH
12193: LD_STRING Cyrus
12195: STR
12196: PPUSH
12197: CALL_OW 38
// if Lisa in save_group then
12201: LD_EXP 38
12205: PUSH
12206: LD_EXP 22
12210: IN
12211: IFFALSE 12231
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12213: LD_EXP 38
12217: PPUSH
12218: LD_EXP 2
12222: PUSH
12223: LD_STRING Lisa
12225: STR
12226: PPUSH
12227: CALL_OW 38
// if Frank in save_group then
12231: LD_EXP 49
12235: PUSH
12236: LD_EXP 22
12240: IN
12241: IFFALSE 12261
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12243: LD_EXP 49
12247: PPUSH
12248: LD_EXP 2
12252: PUSH
12253: LD_STRING Frank
12255: STR
12256: PPUSH
12257: CALL_OW 38
// if Khatam in save_group then
12261: LD_EXP 39
12265: PUSH
12266: LD_EXP 22
12270: IN
12271: IFFALSE 12291
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
12273: LD_EXP 39
12277: PPUSH
12278: LD_EXP 2
12282: PUSH
12283: LD_STRING Khatam
12285: STR
12286: PPUSH
12287: CALL_OW 38
// if save_others then
12291: LD_EXP 21
12295: IFFALSE 12309
// SaveCharacters ( save_others , 03_others ) ;
12297: LD_EXP 21
12301: PPUSH
12302: LD_STRING 03_others
12304: PPUSH
12305: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) then
12309: LD_EXP 43
12313: PUSH
12314: LD_EXP 43
12318: PPUSH
12319: CALL_OW 302
12323: AND
12324: IFFALSE 12336
// begin ResetFog ;
12326: CALL_OW 335
// DisplayEndingScene ;
12330: CALL 12358 0 0
// end else
12334: GO 12349
// DeleteCharacters ( mission_prefix & Cornel ) ;
12336: LD_EXP 2
12340: PUSH
12341: LD_STRING Cornel
12343: STR
12344: PPUSH
12345: CALL_OW 40
// YouWin ;
12349: CALL_OW 103
// end ;
12353: LD_VAR 0 1
12357: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
12358: LD_INT 0
12360: PPUSH
12361: PPUSH
12362: PPUSH
12363: PPUSH
12364: PPUSH
12365: PPUSH
// InGameOn ;
12366: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12370: LD_INT 208
12372: PPUSH
12373: LD_INT 62
12375: PPUSH
12376: LD_INT 1
12378: PPUSH
12379: LD_INT 10
12381: NEG
12382: PPUSH
12383: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
12387: LD_INT 208
12389: PPUSH
12390: LD_INT 62
12392: PPUSH
12393: LD_INT 1
12395: PPUSH
12396: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
12400: LD_ADDR_VAR 0 3
12404: PUSH
12405: LD_INT 22
12407: PUSH
12408: LD_INT 3
12410: PUSH
12411: EMPTY
12412: LIST
12413: LIST
12414: PUSH
12415: LD_INT 2
12417: PUSH
12418: LD_INT 21
12420: PUSH
12421: LD_INT 2
12423: PUSH
12424: EMPTY
12425: LIST
12426: LIST
12427: PUSH
12428: LD_INT 21
12430: PUSH
12431: LD_INT 1
12433: PUSH
12434: EMPTY
12435: LIST
12436: LIST
12437: PUSH
12438: EMPTY
12439: LIST
12440: LIST
12441: LIST
12442: PUSH
12443: EMPTY
12444: LIST
12445: LIST
12446: PPUSH
12447: CALL_OW 69
12451: ST_TO_ADDR
// if filter then
12452: LD_VAR 0 3
12456: IFFALSE 12484
// for i in filter do
12458: LD_ADDR_VAR 0 2
12462: PUSH
12463: LD_VAR 0 3
12467: PUSH
12468: FOR_IN
12469: IFFALSE 12482
// RemoveUnit ( i ) ;
12471: LD_VAR 0 2
12475: PPUSH
12476: CALL_OW 64
12480: GO 12468
12482: POP
12483: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
12484: LD_ADDR_VAR 0 3
12488: PUSH
12489: LD_INT 22
12491: PUSH
12492: LD_INT 4
12494: PUSH
12495: EMPTY
12496: LIST
12497: LIST
12498: PUSH
12499: LD_INT 21
12501: PUSH
12502: LD_INT 1
12504: PUSH
12505: EMPTY
12506: LIST
12507: LIST
12508: PUSH
12509: EMPTY
12510: LIST
12511: LIST
12512: PPUSH
12513: CALL_OW 69
12517: ST_TO_ADDR
// if filter then
12518: LD_VAR 0 3
12522: IFFALSE 12553
// for i in filter do
12524: LD_ADDR_VAR 0 2
12528: PUSH
12529: LD_VAR 0 3
12533: PUSH
12534: FOR_IN
12535: IFFALSE 12551
// SetLives ( i , 0 ) ;
12537: LD_VAR 0 2
12541: PPUSH
12542: LD_INT 0
12544: PPUSH
12545: CALL_OW 234
12549: GO 12534
12551: POP
12552: POP
// uc_side := 4 ;
12553: LD_ADDR_OWVAR 20
12557: PUSH
12558: LD_INT 4
12560: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12561: LD_ADDR_VAR 0 4
12565: PUSH
12566: LD_STRING Cornell
12568: PPUSH
12569: LD_INT 0
12571: PPUSH
12572: CALL 466 0 2
12576: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12577: LD_VAR 0 4
12581: PPUSH
12582: LD_INT 208
12584: PPUSH
12585: LD_INT 62
12587: PPUSH
12588: LD_INT 0
12590: PPUSH
12591: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12595: LD_VAR 0 4
12599: PPUSH
12600: LD_INT 100
12602: PPUSH
12603: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12607: LD_INT 3
12609: PPUSH
12610: LD_VAR 0 4
12614: PPUSH
12615: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12619: LD_INT 4
12621: PPUSH
12622: LD_INT 3
12624: PPUSH
12625: LD_INT 1
12627: PPUSH
12628: LD_INT 1
12630: PPUSH
12631: CALL_OW 80
// uc_side := 3 ;
12635: LD_ADDR_OWVAR 20
12639: PUSH
12640: LD_INT 3
12642: ST_TO_ADDR
// uc_nation := 3 ;
12643: LD_ADDR_OWVAR 21
12647: PUSH
12648: LD_INT 3
12650: ST_TO_ADDR
// InitHc ;
12651: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12655: LD_ADDR_VAR 0 5
12659: PUSH
12660: LD_STRING Mikhail
12662: PPUSH
12663: LD_INT 0
12665: PPUSH
12666: CALL 466 0 2
12670: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12671: LD_INT 1
12673: PPUSH
12674: LD_INT 1
12676: PPUSH
12677: LD_INT 0
12679: PPUSH
12680: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12684: LD_ADDR_VAR 0 6
12688: PUSH
12689: LD_VAR 0 6
12693: PUSH
12694: CALL_OW 44
12698: ADD
12699: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12700: LD_ADDR_VAR 0 6
12704: PUSH
12705: LD_VAR 0 6
12709: PUSH
12710: CALL_OW 44
12714: ADD
12715: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12716: LD_INT 2
12718: PPUSH
12719: LD_INT 4
12721: PPUSH
12722: LD_INT 0
12724: PPUSH
12725: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12729: LD_ADDR_VAR 0 6
12733: PUSH
12734: LD_VAR 0 6
12738: PUSH
12739: CALL_OW 44
12743: ADD
12744: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12745: LD_VAR 0 5
12749: PPUSH
12750: LD_INT 17
12752: PPUSH
12753: LD_INT 0
12755: PPUSH
12756: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12760: LD_VAR 0 5
12764: PPUSH
12765: LD_INT 210
12767: PPUSH
12768: LD_INT 63
12770: PPUSH
12771: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12775: LD_VAR 0 5
12779: PPUSH
12780: LD_INT 208
12782: PPUSH
12783: LD_INT 62
12785: PPUSH
12786: CALL_OW 178
// for i in fake_russians do
12790: LD_ADDR_VAR 0 2
12794: PUSH
12795: LD_VAR 0 6
12799: PUSH
12800: FOR_IN
12801: IFFALSE 12879
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12803: LD_VAR 0 2
12807: PPUSH
12808: LD_INT 17
12810: PPUSH
12811: LD_INT 0
12813: PPUSH
12814: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
12818: LD_VAR 0 2
12822: PPUSH
12823: LD_INT 215
12825: PPUSH
12826: LD_INT 67
12828: PPUSH
12829: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
12833: LD_VAR 0 2
12837: PPUSH
12838: LD_INT 208
12840: PPUSH
12841: LD_INT 62
12843: PPUSH
12844: CALL_OW 178
// if GetClass ( i ) = 4 then
12848: LD_VAR 0 2
12852: PPUSH
12853: CALL_OW 257
12857: PUSH
12858: LD_INT 4
12860: EQUAL
12861: IFFALSE 12877
// ComHeal ( i , fake_cornel ) ;
12863: LD_VAR 0 2
12867: PPUSH
12868: LD_VAR 0 4
12872: PPUSH
12873: CALL_OW 128
// end ;
12877: GO 12800
12879: POP
12880: POP
// Wait ( 0 0$01 ) ;
12881: LD_INT 35
12883: PPUSH
12884: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
12888: LD_INT 208
12890: PPUSH
12891: LD_INT 62
12893: PPUSH
12894: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12898: LD_INT 208
12900: PPUSH
12901: LD_INT 62
12903: PPUSH
12904: LD_INT 1
12906: PPUSH
12907: LD_INT 10
12909: NEG
12910: PPUSH
12911: CALL_OW 330
// Wait ( 0 0$15 ) ;
12915: LD_INT 525
12917: PPUSH
12918: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
12922: LD_INT 208
12924: PPUSH
12925: LD_INT 62
12927: PPUSH
12928: LD_INT 1
12930: PPUSH
12931: CALL_OW 331
// ResetFog ;
12935: CALL_OW 335
// InGameOff ;
12939: CALL_OW 9
// end ;
12943: LD_VAR 0 1
12947: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
12948: LD_INT 10
12950: PPUSH
12951: LD_INT 22
12953: PUSH
12954: LD_INT 1
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: PPUSH
12961: CALL_OW 70
12965: PUSH
12966: LD_EXP 42
12970: PPUSH
12971: CALL_OW 302
12975: AND
12976: PUSH
12977: LD_INT 22
12979: PUSH
12980: LD_INT 1
12982: PUSH
12983: EMPTY
12984: LIST
12985: LIST
12986: PPUSH
12987: CALL_OW 69
12991: PPUSH
12992: LD_EXP 42
12996: PPUSH
12997: CALL_OW 74
13001: PPUSH
13002: LD_EXP 42
13006: PPUSH
13007: CALL_OW 296
13011: PUSH
13012: LD_INT 30
13014: LESS
13015: OR
13016: IFFALSE 13067
13018: GO 13020
13020: DISABLE
// begin enable ;
13021: ENABLE
// powell_warn := powell_warn + 1 ;
13022: LD_ADDR_EXP 33
13026: PUSH
13027: LD_EXP 33
13031: PUSH
13032: LD_INT 1
13034: PLUS
13035: ST_TO_ADDR
// if powell_warn = 3 then
13036: LD_EXP 33
13040: PUSH
13041: LD_INT 3
13043: EQUAL
13044: IFFALSE 13055
// begin YouLost ( 5 ) ;
13046: LD_STRING 5
13048: PPUSH
13049: CALL_OW 104
// exit ;
13053: GO 13067
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
13055: LD_EXP 44
13059: PPUSH
13060: LD_STRING DWarn-Pow-1
13062: PPUSH
13063: CALL_OW 94
// end ; end_of_file
13067: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
13068: LD_EXP 8
13072: IFFALSE 14397
13074: GO 13076
13076: DISABLE
13077: LD_INT 0
13079: PPUSH
13080: PPUSH
13081: PPUSH
13082: PPUSH
13083: PPUSH
13084: PPUSH
13085: PPUSH
13086: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
13087: LD_EXP 42
13091: PUSH
13092: LD_EXP 43
13096: ADD
13097: PUSH
13098: LD_EXP 6
13102: ADD
13103: PPUSH
13104: LD_INT 250
13106: PPUSH
13107: LD_INT 120
13109: PPUSH
13110: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff [ Bierezov ] ;
13114: LD_ADDR_VAR 0 2
13118: PUSH
13119: LD_EXP 6
13123: PPUSH
13124: LD_INT 25
13126: PUSH
13127: LD_INT 2
13129: PUSH
13130: EMPTY
13131: LIST
13132: LIST
13133: PPUSH
13134: CALL_OW 72
13138: PUSH
13139: LD_EXP 43
13143: PUSH
13144: EMPTY
13145: LIST
13146: DIFF
13147: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) diff has_eng ;
13148: LD_ADDR_VAR 0 3
13152: PUSH
13153: LD_EXP 6
13157: PPUSH
13158: LD_INT 21
13160: PUSH
13161: LD_INT 1
13163: PUSH
13164: EMPTY
13165: LIST
13166: LIST
13167: PPUSH
13168: CALL_OW 72
13172: PUSH
13173: LD_VAR 0 2
13177: DIFF
13178: ST_TO_ADDR
// if not has_eng then
13179: LD_VAR 0 2
13183: NOT
13184: IFFALSE 13267
// begin uc_side := 4 ;
13186: LD_ADDR_OWVAR 20
13190: PUSH
13191: LD_INT 4
13193: ST_TO_ADDR
// uc_nation := 1 ;
13194: LD_ADDR_OWVAR 21
13198: PUSH
13199: LD_INT 1
13201: ST_TO_ADDR
// bc_type := b_depot ;
13202: LD_ADDR_OWVAR 42
13206: PUSH
13207: LD_INT 0
13209: ST_TO_ADDR
// bc_level := 2 ;
13210: LD_ADDR_OWVAR 43
13214: PUSH
13215: LD_INT 2
13217: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13218: LD_ADDR_VAR 0 4
13222: PUSH
13223: LD_INT 264
13225: PPUSH
13226: LD_INT 120
13228: PPUSH
13229: LD_INT 4
13231: PPUSH
13232: CALL_OW 47
13236: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13237: LD_INT 264
13239: PPUSH
13240: LD_INT 120
13242: PPUSH
13243: LD_INT 4
13245: PPUSH
13246: LD_INT 10
13248: NEG
13249: PPUSH
13250: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13254: LD_INT 264
13256: PPUSH
13257: LD_INT 120
13259: PPUSH
13260: LD_INT 4
13262: PPUSH
13263: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13267: LD_INT 35
13269: PPUSH
13270: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
13274: LD_EXP 42
13278: PPUSH
13279: LD_INT 10
13281: PPUSH
13282: CALL_OW 308
13286: IFFALSE 13267
// if has_eng and not dep then
13288: LD_VAR 0 2
13292: PUSH
13293: LD_VAR 0 4
13297: NOT
13298: AND
13299: IFFALSE 13449
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
13301: LD_VAR 0 2
13305: PPUSH
13306: LD_INT 0
13308: PPUSH
13309: LD_INT 264
13311: PPUSH
13312: LD_INT 120
13314: PPUSH
13315: LD_INT 4
13317: PPUSH
13318: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
13322: LD_INT 35
13324: PPUSH
13325: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
13329: LD_INT 22
13331: PUSH
13332: LD_INT 4
13334: PUSH
13335: EMPTY
13336: LIST
13337: LIST
13338: PUSH
13339: LD_INT 30
13341: PUSH
13342: LD_INT 0
13344: PUSH
13345: EMPTY
13346: LIST
13347: LIST
13348: PUSH
13349: EMPTY
13350: LIST
13351: LIST
13352: PPUSH
13353: CALL_OW 69
13357: IFFALSE 13322
// ComMoveXY ( filter , 264 , 120 ) ;
13359: LD_VAR 0 3
13363: PPUSH
13364: LD_INT 264
13366: PPUSH
13367: LD_INT 120
13369: PPUSH
13370: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
13374: LD_INT 35
13376: PPUSH
13377: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
13381: LD_INT 22
13383: PUSH
13384: LD_INT 4
13386: PUSH
13387: EMPTY
13388: LIST
13389: LIST
13390: PUSH
13391: LD_INT 30
13393: PUSH
13394: LD_INT 0
13396: PUSH
13397: EMPTY
13398: LIST
13399: LIST
13400: PUSH
13401: LD_INT 3
13403: PUSH
13404: LD_INT 57
13406: PUSH
13407: EMPTY
13408: LIST
13409: PUSH
13410: EMPTY
13411: LIST
13412: LIST
13413: PUSH
13414: EMPTY
13415: LIST
13416: LIST
13417: LIST
13418: PPUSH
13419: CALL_OW 69
13423: IFFALSE 13374
// ComMoveXY ( filter , 247 , 113 ) ;
13425: LD_VAR 0 3
13429: PPUSH
13430: LD_INT 247
13432: PPUSH
13433: LD_INT 113
13435: PPUSH
13436: CALL_OW 111
// Wait ( 0 0$2 ) ;
13440: LD_INT 70
13442: PPUSH
13443: CALL_OW 67
// end else
13447: GO 13461
// begin SetSide ( dep , 4 ) ;
13449: LD_VAR 0 4
13453: PPUSH
13454: LD_INT 4
13456: PPUSH
13457: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
13461: LD_ADDR_VAR 0 4
13465: PUSH
13466: LD_INT 22
13468: PUSH
13469: LD_INT 4
13471: PUSH
13472: EMPTY
13473: LIST
13474: LIST
13475: PUSH
13476: LD_INT 30
13478: PUSH
13479: LD_INT 0
13481: PUSH
13482: EMPTY
13483: LIST
13484: LIST
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: PPUSH
13490: CALL_OW 69
13494: PUSH
13495: LD_INT 1
13497: ARRAY
13498: ST_TO_ADDR
// for i = 1 to 2 do
13499: LD_ADDR_VAR 0 1
13503: PUSH
13504: DOUBLE
13505: LD_INT 1
13507: DEC
13508: ST_TO_ADDR
13509: LD_INT 2
13511: PUSH
13512: FOR_TO
13513: IFFALSE 13608
// begin ComEnterUnit ( filter [ 1 ] , dep ) ;
13515: LD_VAR 0 3
13519: PUSH
13520: LD_INT 1
13522: ARRAY
13523: PPUSH
13524: LD_VAR 0 4
13528: PPUSH
13529: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 2 ) ;
13533: LD_VAR 0 3
13537: PUSH
13538: LD_INT 1
13540: ARRAY
13541: PPUSH
13542: LD_INT 2
13544: PPUSH
13545: CALL_OW 183
// AddComExitBuilding ( filter [ 1 ] ) ;
13549: LD_VAR 0 3
13553: PUSH
13554: LD_INT 1
13556: ARRAY
13557: PPUSH
13558: CALL_OW 182
// repeat wait ( 0 0$1 ) ;
13562: LD_INT 35
13564: PPUSH
13565: CALL_OW 67
// until GetClass ( filter [ 1 ] ) = 2 ;
13569: LD_VAR 0 3
13573: PUSH
13574: LD_INT 1
13576: ARRAY
13577: PPUSH
13578: CALL_OW 257
13582: PUSH
13583: LD_INT 2
13585: EQUAL
13586: IFFALSE 13562
// filter := Delete ( filter , 1 ) ;
13588: LD_ADDR_VAR 0 3
13592: PUSH
13593: LD_VAR 0 3
13597: PPUSH
13598: LD_INT 1
13600: PPUSH
13601: CALL_OW 3
13605: ST_TO_ADDR
// end ;
13606: GO 13512
13608: POP
13609: POP
// if IsInUnit ( Cornel ) then
13610: LD_EXP 42
13614: PPUSH
13615: CALL_OW 310
13619: IFFALSE 13702
// begin cargo := IsInUnit ( Cornel ) ;
13621: LD_ADDR_VAR 0 7
13625: PUSH
13626: LD_EXP 42
13630: PPUSH
13631: CALL_OW 310
13635: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13636: LD_VAR 0 7
13640: PPUSH
13641: LD_INT 1
13643: PPUSH
13644: CALL_OW 289
13648: IFFALSE 13664
// ComGive ( Cornel , dep ) ;
13650: LD_EXP 42
13654: PPUSH
13655: LD_VAR 0 4
13659: PPUSH
13660: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13664: LD_EXP 42
13668: PPUSH
13669: LD_INT 235
13671: PPUSH
13672: LD_INT 122
13674: PPUSH
13675: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13679: LD_EXP 42
13683: PPUSH
13684: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13688: LD_EXP 42
13692: PPUSH
13693: LD_VAR 0 4
13697: PPUSH
13698: CALL_OW 180
// end ; if Bierezov then
13702: LD_EXP 43
13706: IFFALSE 13722
// ComEnterUnit ( Bierezov , dep ) ;
13708: LD_EXP 43
13712: PPUSH
13713: LD_VAR 0 4
13717: PPUSH
13718: CALL_OW 120
// has_eng := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) diff [ Bierezov ] ;
13722: LD_ADDR_VAR 0 2
13726: PUSH
13727: LD_INT 22
13729: PUSH
13730: LD_INT 4
13732: PUSH
13733: EMPTY
13734: LIST
13735: LIST
13736: PUSH
13737: LD_INT 25
13739: PUSH
13740: LD_INT 2
13742: PUSH
13743: EMPTY
13744: LIST
13745: LIST
13746: PUSH
13747: EMPTY
13748: LIST
13749: LIST
13750: PPUSH
13751: CALL_OW 69
13755: PUSH
13756: LD_EXP 43
13760: PUSH
13761: EMPTY
13762: LIST
13763: DIFF
13764: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13765: LD_INT 35
13767: PPUSH
13768: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13772: LD_ADDR_VAR 0 6
13776: PUSH
13777: LD_INT 10
13779: PPUSH
13780: CALL_OW 435
13784: ST_TO_ADDR
// if crates then
13785: LD_VAR 0 6
13789: IFFALSE 13818
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
13791: LD_VAR 0 2
13795: PPUSH
13796: LD_VAR 0 6
13800: PUSH
13801: LD_INT 1
13803: ARRAY
13804: PPUSH
13805: LD_VAR 0 6
13809: PUSH
13810: LD_INT 2
13812: ARRAY
13813: PPUSH
13814: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
13818: LD_VAR 0 4
13822: PPUSH
13823: CALL_OW 274
13827: PPUSH
13828: LD_INT 1
13830: PPUSH
13831: CALL_OW 275
13835: PUSH
13836: LD_INT 40
13838: GREATEREQUAL
13839: IFFALSE 13765
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
13841: LD_ADDR_VAR 0 5
13845: PUSH
13846: LD_INT 4
13848: PUSH
13849: LD_INT 256
13851: PUSH
13852: LD_INT 111
13854: PUSH
13855: LD_INT 2
13857: PUSH
13858: EMPTY
13859: LIST
13860: LIST
13861: LIST
13862: LIST
13863: PUSH
13864: LD_INT 31
13866: PUSH
13867: LD_INT 243
13869: PUSH
13870: LD_INT 112
13872: PUSH
13873: LD_INT 2
13875: PUSH
13876: EMPTY
13877: LIST
13878: LIST
13879: LIST
13880: LIST
13881: PUSH
13882: EMPTY
13883: LIST
13884: LIST
13885: ST_TO_ADDR
// for i in blist do
13886: LD_ADDR_VAR 0 1
13890: PUSH
13891: LD_VAR 0 5
13895: PUSH
13896: FOR_IN
13897: IFFALSE 13946
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
13899: LD_VAR 0 2
13903: PPUSH
13904: LD_VAR 0 1
13908: PUSH
13909: LD_INT 1
13911: ARRAY
13912: PPUSH
13913: LD_VAR 0 1
13917: PUSH
13918: LD_INT 2
13920: ARRAY
13921: PPUSH
13922: LD_VAR 0 1
13926: PUSH
13927: LD_INT 3
13929: ARRAY
13930: PPUSH
13931: LD_VAR 0 1
13935: PUSH
13936: LD_INT 4
13938: ARRAY
13939: PPUSH
13940: CALL_OW 205
13944: GO 13896
13946: POP
13947: POP
// repeat wait ( 0 0$01 ) ;
13948: LD_INT 35
13950: PPUSH
13951: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
13955: LD_INT 22
13957: PUSH
13958: LD_INT 4
13960: PUSH
13961: EMPTY
13962: LIST
13963: LIST
13964: PUSH
13965: LD_INT 30
13967: PUSH
13968: LD_INT 4
13970: PUSH
13971: EMPTY
13972: LIST
13973: LIST
13974: PUSH
13975: LD_INT 3
13977: PUSH
13978: LD_INT 57
13980: PUSH
13981: EMPTY
13982: LIST
13983: PUSH
13984: EMPTY
13985: LIST
13986: LIST
13987: PUSH
13988: EMPTY
13989: LIST
13990: LIST
13991: LIST
13992: PPUSH
13993: CALL_OW 69
13997: IFFALSE 13948
// AddComEnterUnit ( filter , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
13999: LD_VAR 0 3
14003: PPUSH
14004: LD_INT 22
14006: PUSH
14007: LD_INT 4
14009: PUSH
14010: EMPTY
14011: LIST
14012: LIST
14013: PUSH
14014: LD_INT 30
14016: PUSH
14017: LD_INT 4
14019: PUSH
14020: EMPTY
14021: LIST
14022: LIST
14023: PUSH
14024: EMPTY
14025: LIST
14026: LIST
14027: PPUSH
14028: CALL_OW 69
14032: PUSH
14033: LD_INT 1
14035: ARRAY
14036: PPUSH
14037: CALL_OW 180
// AddComChangeProfession ( filter , 1 ) ;
14041: LD_VAR 0 3
14045: PPUSH
14046: LD_INT 1
14048: PPUSH
14049: CALL_OW 183
// repeat wait ( 0 0$01 ) ;
14053: LD_INT 35
14055: PPUSH
14056: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
14060: LD_INT 22
14062: PUSH
14063: LD_INT 4
14065: PUSH
14066: EMPTY
14067: LIST
14068: LIST
14069: PUSH
14070: LD_INT 30
14072: PUSH
14073: LD_INT 31
14075: PUSH
14076: EMPTY
14077: LIST
14078: LIST
14079: PUSH
14080: LD_INT 3
14082: PUSH
14083: LD_INT 57
14085: PUSH
14086: EMPTY
14087: LIST
14088: PUSH
14089: EMPTY
14090: LIST
14091: LIST
14092: PUSH
14093: EMPTY
14094: LIST
14095: LIST
14096: LIST
14097: PPUSH
14098: CALL_OW 69
14102: IFFALSE 14053
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
14104: LD_ADDR_VAR 0 8
14108: PUSH
14109: LD_EXP 6
14113: PPUSH
14114: LD_INT 25
14116: PUSH
14117: LD_INT 1
14119: PUSH
14120: EMPTY
14121: LIST
14122: LIST
14123: PPUSH
14124: CALL_OW 72
14128: ST_TO_ADDR
// ComExitBuilding ( sol [ 1 ] ) ;
14129: LD_VAR 0 8
14133: PUSH
14134: LD_INT 1
14136: ARRAY
14137: PPUSH
14138: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
14142: LD_VAR 0 8
14146: PUSH
14147: LD_INT 1
14149: ARRAY
14150: PPUSH
14151: LD_INT 22
14153: PUSH
14154: LD_INT 4
14156: PUSH
14157: EMPTY
14158: LIST
14159: LIST
14160: PUSH
14161: LD_INT 30
14163: PUSH
14164: LD_INT 31
14166: PUSH
14167: EMPTY
14168: LIST
14169: LIST
14170: PUSH
14171: EMPTY
14172: LIST
14173: LIST
14174: PPUSH
14175: CALL_OW 69
14179: PUSH
14180: LD_INT 1
14182: ARRAY
14183: PPUSH
14184: CALL_OW 180
// ComEnterUnit ( has_eng , dep ) ;
14188: LD_VAR 0 2
14192: PPUSH
14193: LD_VAR 0 4
14197: PPUSH
14198: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
14202: LD_INT 35
14204: PPUSH
14205: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14209: LD_ADDR_VAR 0 3
14213: PUSH
14214: LD_INT 22
14216: PUSH
14217: LD_INT 4
14219: PUSH
14220: EMPTY
14221: LIST
14222: LIST
14223: PUSH
14224: LD_INT 21
14226: PUSH
14227: LD_INT 3
14229: PUSH
14230: EMPTY
14231: LIST
14232: LIST
14233: PUSH
14234: LD_INT 3
14236: PUSH
14237: LD_INT 24
14239: PUSH
14240: LD_INT 1000
14242: PUSH
14243: EMPTY
14244: LIST
14245: LIST
14246: PUSH
14247: EMPTY
14248: LIST
14249: LIST
14250: PUSH
14251: EMPTY
14252: LIST
14253: LIST
14254: LIST
14255: PPUSH
14256: CALL_OW 69
14260: ST_TO_ADDR
// if filter and has_eng then
14261: LD_VAR 0 3
14265: PUSH
14266: LD_VAR 0 2
14270: AND
14271: IFFALSE 14337
// begin for i in has_eng do
14273: LD_ADDR_VAR 0 1
14277: PUSH
14278: LD_VAR 0 2
14282: PUSH
14283: FOR_IN
14284: IFFALSE 14333
// begin if IsInUnit ( i ) then
14286: LD_VAR 0 1
14290: PPUSH
14291: CALL_OW 310
14295: IFFALSE 14306
// ComExitBuilding ( i ) ;
14297: LD_VAR 0 1
14301: PPUSH
14302: CALL_OW 122
// Wait ( 3 ) ;
14306: LD_INT 3
14308: PPUSH
14309: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
14313: LD_VAR 0 1
14317: PPUSH
14318: LD_VAR 0 3
14322: PUSH
14323: LD_INT 1
14325: ARRAY
14326: PPUSH
14327: CALL_OW 130
// end ;
14331: GO 14283
14333: POP
14334: POP
// end else
14335: GO 14391
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
14337: LD_VAR 0 2
14341: PUSH
14342: LD_VAR 0 2
14346: PPUSH
14347: LD_INT 56
14349: PUSH
14350: EMPTY
14351: LIST
14352: PPUSH
14353: CALL_OW 72
14357: AND
14358: IFFALSE 14391
// for i in has_eng do
14360: LD_ADDR_VAR 0 1
14364: PUSH
14365: LD_VAR 0 2
14369: PUSH
14370: FOR_IN
14371: IFFALSE 14389
// ComEnterUnit ( i , dep ) ;
14373: LD_VAR 0 1
14377: PPUSH
14378: LD_VAR 0 4
14382: PPUSH
14383: CALL_OW 120
14387: GO 14370
14389: POP
14390: POP
// until cornel_prepared ;
14391: LD_EXP 11
14395: IFFALSE 14202
// end ;
14397: PPOPN 8
14399: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
14400: LD_EXP 11
14404: IFFALSE 14753
14406: GO 14408
14408: DISABLE
14409: LD_INT 0
14411: PPUSH
14412: PPUSH
14413: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
14414: LD_ADDR_VAR 0 2
14418: PUSH
14419: LD_INT 22
14421: PUSH
14422: LD_INT 4
14424: PUSH
14425: EMPTY
14426: LIST
14427: LIST
14428: PUSH
14429: LD_INT 30
14431: PUSH
14432: LD_INT 4
14434: PUSH
14435: EMPTY
14436: LIST
14437: LIST
14438: PUSH
14439: EMPTY
14440: LIST
14441: LIST
14442: PPUSH
14443: CALL_OW 69
14447: PUSH
14448: LD_INT 1
14450: ARRAY
14451: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
14452: LD_EXP 6
14456: PPUSH
14457: CALL_OW 122
// Wait ( 0 0$03 ) ;
14461: LD_INT 105
14463: PPUSH
14464: CALL_OW 67
// for i in cornel_units do
14468: LD_ADDR_VAR 0 1
14472: PUSH
14473: LD_EXP 6
14477: PUSH
14478: FOR_IN
14479: IFFALSE 14555
// begin if GetClass ( i ) in [ 2 , 3 ] then
14481: LD_VAR 0 1
14485: PPUSH
14486: CALL_OW 257
14490: PUSH
14491: LD_INT 2
14493: PUSH
14494: LD_INT 3
14496: PUSH
14497: EMPTY
14498: LIST
14499: LIST
14500: IN
14501: IFFALSE 14538
// begin ComEnterUnit ( i , arm ) ;
14503: LD_VAR 0 1
14507: PPUSH
14508: LD_VAR 0 2
14512: PPUSH
14513: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
14517: LD_VAR 0 1
14521: PPUSH
14522: LD_INT 1
14524: PPUSH
14525: CALL_OW 183
// AddComExitBuilding ( i ) ;
14529: LD_VAR 0 1
14533: PPUSH
14534: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
14538: LD_VAR 0 1
14542: PPUSH
14543: LD_INT 257
14545: PPUSH
14546: LD_INT 121
14548: PPUSH
14549: CALL_OW 171
// end ;
14553: GO 14478
14555: POP
14556: POP
// Wait ( 1 1$00 ) ;
14557: LD_INT 2100
14559: PPUSH
14560: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
14564: LD_ADDR_VAR 0 3
14568: PUSH
14569: LD_EXP 42
14573: PUSH
14574: LD_EXP 43
14578: ADD
14579: PUSH
14580: LD_EXP 6
14584: ADD
14585: PUSH
14586: LD_EXP 6
14590: PPUSH
14591: LD_INT 21
14593: PUSH
14594: LD_INT 2
14596: PUSH
14597: EMPTY
14598: LIST
14599: LIST
14600: PPUSH
14601: CALL_OW 72
14605: DIFF
14606: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
14607: LD_VAR 0 3
14611: PPUSH
14612: LD_INT 248
14614: PPUSH
14615: LD_INT 85
14617: PPUSH
14618: CALL_OW 111
// AddComHold ( filter ) ;
14622: LD_VAR 0 3
14626: PPUSH
14627: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
14631: LD_INT 35
14633: PPUSH
14634: CALL_OW 67
// until cornel_attack ;
14638: LD_EXP 9
14642: IFFALSE 14631
// ComAgressiveMove ( filter , 209 , 63 ) ;
14644: LD_VAR 0 3
14648: PPUSH
14649: LD_INT 209
14651: PPUSH
14652: LD_INT 63
14654: PPUSH
14655: CALL_OW 114
// if Bierezov then
14659: LD_EXP 43
14663: IFFALSE 14753
// begin filter := filter diff Bierezov ;
14665: LD_ADDR_VAR 0 3
14669: PUSH
14670: LD_VAR 0 3
14674: PUSH
14675: LD_EXP 43
14679: DIFF
14680: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
14681: LD_EXP 43
14685: PPUSH
14686: LD_INT 6
14688: PPUSH
14689: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
14693: LD_EXP 43
14697: PPUSH
14698: LD_INT 235
14700: PPUSH
14701: LD_INT 60
14703: PPUSH
14704: CALL_OW 111
// AddComHold ( Bierezov ) ;
14708: LD_EXP 43
14712: PPUSH
14713: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
14717: LD_EXP 43
14721: PPUSH
14722: LD_INT 350
14724: PPUSH
14725: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
14729: LD_EXP 43
14733: PPUSH
14734: LD_INT 198
14736: PPUSH
14737: LD_INT 28
14739: PPUSH
14740: CALL_OW 171
// AddComHold ( Bierezov ) ;
14744: LD_EXP 43
14748: PPUSH
14749: CALL_OW 200
// end ; end ; end_of_file
14753: PPOPN 3
14755: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
14756: LD_EXP 51
14760: PUSH
14761: LD_EXP 29
14765: NOT
14766: AND
14767: PUSH
14768: LD_EXP 30
14772: NOT
14773: AND
14774: IFFALSE 15224
14776: GO 14778
14778: DISABLE
14779: LD_INT 0
14781: PPUSH
14782: PPUSH
14783: PPUSH
14784: PPUSH
// begin enable ;
14785: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14786: LD_ADDR_VAR 0 4
14790: PUSH
14791: LD_INT 81
14793: PUSH
14794: LD_INT 3
14796: PUSH
14797: EMPTY
14798: LIST
14799: LIST
14800: PPUSH
14801: CALL_OW 69
14805: ST_TO_ADDR
// for i = 1 to ru_patrol do
14806: LD_ADDR_VAR 0 2
14810: PUSH
14811: DOUBLE
14812: LD_INT 1
14814: DEC
14815: ST_TO_ADDR
14816: LD_EXP 51
14820: PUSH
14821: FOR_TO
14822: IFFALSE 15222
// begin un := ru_patrol [ i ] ;
14824: LD_ADDR_VAR 0 1
14828: PUSH
14829: LD_EXP 51
14833: PUSH
14834: LD_VAR 0 2
14838: ARRAY
14839: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14840: LD_VAR 0 1
14844: PPUSH
14845: LD_INT 13
14847: PPUSH
14848: CALL_OW 308
14852: IFFALSE 14957
// begin if not ru_alert then
14854: LD_EXP 58
14858: NOT
14859: IFFALSE 14869
// ru_alert := true ;
14861: LD_ADDR_EXP 58
14865: PUSH
14866: LD_INT 1
14868: ST_TO_ADDR
// if not See ( 1 , un ) then
14869: LD_INT 1
14871: PPUSH
14872: LD_VAR 0 1
14876: PPUSH
14877: CALL_OW 292
14881: NOT
14882: IFFALSE 14896
// SetLives ( un , 1000 ) ;
14884: LD_VAR 0 1
14888: PPUSH
14889: LD_INT 1000
14891: PPUSH
14892: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
14896: LD_ADDR_EXP 51
14900: PUSH
14901: LD_EXP 51
14905: PUSH
14906: LD_VAR 0 1
14910: DIFF
14911: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
14912: LD_VAR 0 1
14916: PPUSH
14917: LD_INT 22
14919: PUSH
14920: LD_INT 3
14922: PUSH
14923: EMPTY
14924: LIST
14925: LIST
14926: PUSH
14927: LD_INT 30
14929: PUSH
14930: LD_INT 4
14932: PUSH
14933: EMPTY
14934: LIST
14935: LIST
14936: PUSH
14937: EMPTY
14938: LIST
14939: LIST
14940: PPUSH
14941: CALL_OW 69
14945: PPUSH
14946: CALL 1039 0 1
14950: PPUSH
14951: CALL_OW 120
// continue ;
14955: GO 14821
// end ; if IsOk ( un ) and not HasTask ( un ) then
14957: LD_VAR 0 1
14961: PPUSH
14962: CALL_OW 302
14966: PUSH
14967: LD_VAR 0 1
14971: PPUSH
14972: CALL_OW 314
14976: NOT
14977: AND
14978: IFFALSE 15071
// begin for j = 1 to ru_firepoints_south [ i ] do
14980: LD_ADDR_VAR 0 3
14984: PUSH
14985: DOUBLE
14986: LD_INT 1
14988: DEC
14989: ST_TO_ADDR
14990: LD_EXP 57
14994: PUSH
14995: LD_VAR 0 2
14999: ARRAY
15000: PUSH
15001: FOR_TO
15002: IFFALSE 15069
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
15004: LD_VAR 0 1
15008: PPUSH
15009: LD_EXP 57
15013: PUSH
15014: LD_VAR 0 2
15018: ARRAY
15019: PUSH
15020: LD_VAR 0 3
15024: ARRAY
15025: PUSH
15026: LD_INT 1
15028: ARRAY
15029: PPUSH
15030: LD_EXP 57
15034: PUSH
15035: LD_VAR 0 2
15039: ARRAY
15040: PUSH
15041: LD_VAR 0 3
15045: ARRAY
15046: PUSH
15047: LD_INT 2
15049: ARRAY
15050: PPUSH
15051: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
15055: LD_VAR 0 1
15059: PPUSH
15060: LD_INT 70
15062: PPUSH
15063: CALL_OW 202
// end ;
15067: GO 15001
15069: POP
15070: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15071: LD_VAR 0 1
15075: PPUSH
15076: CALL_OW 256
15080: PUSH
15081: LD_INT 700
15083: LESS
15084: PUSH
15085: LD_VAR 0 1
15089: PPUSH
15090: LD_INT 13
15092: PPUSH
15093: CALL_OW 308
15097: NOT
15098: AND
15099: IFFALSE 15151
// begin ComMoveToArea ( un , retreatArea ) ;
15101: LD_VAR 0 1
15105: PPUSH
15106: LD_INT 13
15108: PPUSH
15109: CALL_OW 113
// if not ru_alert_xy then
15113: LD_EXP 59
15117: NOT
15118: IFFALSE 15149
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
15120: LD_ADDR_EXP 59
15124: PUSH
15125: LD_VAR 0 1
15129: PPUSH
15130: CALL_OW 250
15134: PUSH
15135: LD_VAR 0 1
15139: PPUSH
15140: CALL_OW 251
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: ST_TO_ADDR
// end else
15149: GO 15220
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15151: LD_VAR 0 1
15155: PPUSH
15156: LD_VAR 0 4
15160: PPUSH
15161: LD_VAR 0 1
15165: PPUSH
15166: CALL_OW 74
15170: PPUSH
15171: CALL_OW 296
15175: PUSH
15176: LD_INT 9
15178: LESS
15179: PUSH
15180: LD_VAR 0 1
15184: PPUSH
15185: CALL_OW 256
15189: PUSH
15190: LD_INT 500
15192: GREATER
15193: AND
15194: IFFALSE 15220
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15196: LD_VAR 0 1
15200: PPUSH
15201: LD_VAR 0 4
15205: PPUSH
15206: LD_VAR 0 1
15210: PPUSH
15211: CALL_OW 74
15215: PPUSH
15216: CALL_OW 115
// end ;
15220: GO 14821
15222: POP
15223: POP
// end ;
15224: PPOPN 4
15226: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
15227: LD_EXP 58
15231: PUSH
15232: LD_EXP 59
15236: AND
15237: PUSH
15238: LD_EXP 29
15242: NOT
15243: AND
15244: PUSH
15245: LD_EXP 30
15249: NOT
15250: AND
15251: IFFALSE 15461
15253: GO 15255
15255: DISABLE
15256: LD_INT 0
15258: PPUSH
15259: PPUSH
// begin enable ;
15260: ENABLE
// if not ru_vehicles then
15261: LD_EXP 54
15265: NOT
15266: IFFALSE 15270
// exit ;
15268: GO 15461
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15270: LD_ADDR_VAR 0 2
15274: PUSH
15275: LD_INT 81
15277: PUSH
15278: LD_INT 3
15280: PUSH
15281: EMPTY
15282: LIST
15283: LIST
15284: PPUSH
15285: CALL_OW 69
15289: ST_TO_ADDR
// if ru_vehicles then
15290: LD_EXP 54
15294: IFFALSE 15461
// begin for i in ru_vehicles do
15296: LD_ADDR_VAR 0 1
15300: PUSH
15301: LD_EXP 54
15305: PUSH
15306: FOR_IN
15307: IFFALSE 15459
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
15309: LD_VAR 0 1
15313: PPUSH
15314: CALL_OW 302
15318: PUSH
15319: LD_VAR 0 1
15323: PPUSH
15324: LD_VAR 0 2
15328: PPUSH
15329: LD_VAR 0 1
15333: PPUSH
15334: CALL_OW 74
15338: PPUSH
15339: CALL_OW 296
15343: PUSH
15344: LD_INT 9
15346: LESS
15347: AND
15348: IFFALSE 15374
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15350: LD_VAR 0 1
15354: PPUSH
15355: LD_VAR 0 2
15359: PPUSH
15360: LD_VAR 0 1
15364: PPUSH
15365: CALL_OW 74
15369: PPUSH
15370: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
15374: LD_VAR 0 1
15378: PPUSH
15379: CALL_OW 314
15383: NOT
15384: PUSH
15385: LD_VAR 0 1
15389: PPUSH
15390: CALL_OW 302
15394: AND
15395: PUSH
15396: LD_VAR 0 1
15400: PPUSH
15401: LD_EXP 59
15405: PUSH
15406: LD_INT 1
15408: ARRAY
15409: PPUSH
15410: LD_EXP 59
15414: PUSH
15415: LD_INT 2
15417: ARRAY
15418: PPUSH
15419: CALL_OW 297
15423: PUSH
15424: LD_INT 10
15426: GREATER
15427: AND
15428: IFFALSE 15457
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
15430: LD_VAR 0 1
15434: PPUSH
15435: LD_EXP 59
15439: PUSH
15440: LD_INT 1
15442: ARRAY
15443: PPUSH
15444: LD_EXP 59
15448: PUSH
15449: LD_INT 2
15451: ARRAY
15452: PPUSH
15453: CALL_OW 114
// end ;
15457: GO 15306
15459: POP
15460: POP
// end ; end ;
15461: PPOPN 2
15463: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
15464: LD_EXP 59
15468: PUSH
15469: LD_EXP 58
15473: AND
15474: PUSH
15475: LD_INT 3
15477: PPUSH
15478: CALL_OW 463
15482: NOT
15483: AND
15484: PUSH
15485: LD_EXP 29
15489: NOT
15490: AND
15491: PUSH
15492: LD_EXP 30
15496: NOT
15497: AND
15498: IFFALSE 15593
15500: GO 15502
15502: DISABLE
15503: LD_INT 0
15505: PPUSH
// begin enable ;
15506: ENABLE
// ru_alert_xy := false ;
15507: LD_ADDR_EXP 59
15511: PUSH
15512: LD_INT 0
15514: ST_TO_ADDR
// ru_alert := false ;
15515: LD_ADDR_EXP 58
15519: PUSH
15520: LD_INT 0
15522: ST_TO_ADDR
// if ru_vehicles then
15523: LD_EXP 54
15527: IFFALSE 15593
// for i in ru_vehicles do
15529: LD_ADDR_VAR 0 1
15533: PUSH
15534: LD_EXP 54
15538: PUSH
15539: FOR_IN
15540: IFFALSE 15591
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
15542: LD_VAR 0 1
15546: PPUSH
15547: CALL_OW 302
15551: PUSH
15552: LD_VAR 0 1
15556: PPUSH
15557: LD_INT 89
15559: PPUSH
15560: LD_INT 36
15562: PPUSH
15563: CALL_OW 297
15567: PUSH
15568: LD_INT 10
15570: GREATER
15571: AND
15572: IFFALSE 15589
// ComMoveXY ( i , 89 , 36 ) ;
15574: LD_VAR 0 1
15578: PPUSH
15579: LD_INT 89
15581: PPUSH
15582: LD_INT 36
15584: PPUSH
15585: CALL_OW 111
15589: GO 15539
15591: POP
15592: POP
// end ;
15593: PPOPN 1
15595: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
15596: LD_EXP 53
15600: PUSH
15601: LD_EXP 29
15605: NOT
15606: AND
15607: PUSH
15608: LD_EXP 30
15612: NOT
15613: AND
15614: IFFALSE 15898
15616: GO 15618
15618: DISABLE
15619: LD_INT 0
15621: PPUSH
15622: PPUSH
15623: PPUSH
// begin enable ;
15624: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15625: LD_ADDR_VAR 0 3
15629: PUSH
15630: LD_INT 81
15632: PUSH
15633: LD_INT 3
15635: PUSH
15636: EMPTY
15637: LIST
15638: LIST
15639: PPUSH
15640: CALL_OW 69
15644: ST_TO_ADDR
// for i = 1 to ru_forest do
15645: LD_ADDR_VAR 0 1
15649: PUSH
15650: DOUBLE
15651: LD_INT 1
15653: DEC
15654: ST_TO_ADDR
15655: LD_EXP 53
15659: PUSH
15660: FOR_TO
15661: IFFALSE 15896
// begin un := ru_forest [ i ] ;
15663: LD_ADDR_VAR 0 2
15667: PUSH
15668: LD_EXP 53
15672: PUSH
15673: LD_VAR 0 1
15677: ARRAY
15678: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15679: LD_VAR 0 2
15683: PPUSH
15684: LD_INT 13
15686: PPUSH
15687: CALL_OW 308
15691: IFFALSE 15781
// begin if not See ( 1 , un ) then
15693: LD_INT 1
15695: PPUSH
15696: LD_VAR 0 2
15700: PPUSH
15701: CALL_OW 292
15705: NOT
15706: IFFALSE 15720
// SetLives ( un , 1000 ) ;
15708: LD_VAR 0 2
15712: PPUSH
15713: LD_INT 1000
15715: PPUSH
15716: CALL_OW 234
// ru_forest := ru_forest diff un ;
15720: LD_ADDR_EXP 53
15724: PUSH
15725: LD_EXP 53
15729: PUSH
15730: LD_VAR 0 2
15734: DIFF
15735: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15736: LD_VAR 0 2
15740: PPUSH
15741: LD_INT 22
15743: PUSH
15744: LD_INT 3
15746: PUSH
15747: EMPTY
15748: LIST
15749: LIST
15750: PUSH
15751: LD_INT 30
15753: PUSH
15754: LD_INT 4
15756: PUSH
15757: EMPTY
15758: LIST
15759: LIST
15760: PUSH
15761: EMPTY
15762: LIST
15763: LIST
15764: PPUSH
15765: CALL_OW 69
15769: PPUSH
15770: CALL 1039 0 1
15774: PPUSH
15775: CALL_OW 120
// continue ;
15779: GO 15660
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15781: LD_VAR 0 2
15785: PPUSH
15786: CALL_OW 256
15790: PUSH
15791: LD_INT 700
15793: LESS
15794: PUSH
15795: LD_VAR 0 2
15799: PPUSH
15800: LD_INT 13
15802: PPUSH
15803: CALL_OW 308
15807: NOT
15808: AND
15809: IFFALSE 15825
// ComMoveToArea ( un , retreatArea ) else
15811: LD_VAR 0 2
15815: PPUSH
15816: LD_INT 13
15818: PPUSH
15819: CALL_OW 113
15823: GO 15894
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15825: LD_VAR 0 2
15829: PPUSH
15830: LD_VAR 0 3
15834: PPUSH
15835: LD_VAR 0 2
15839: PPUSH
15840: CALL_OW 74
15844: PPUSH
15845: CALL_OW 296
15849: PUSH
15850: LD_INT 9
15852: LESS
15853: PUSH
15854: LD_VAR 0 2
15858: PPUSH
15859: CALL_OW 256
15863: PUSH
15864: LD_INT 500
15866: GREATER
15867: AND
15868: IFFALSE 15894
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15870: LD_VAR 0 2
15874: PPUSH
15875: LD_VAR 0 3
15879: PPUSH
15880: LD_VAR 0 2
15884: PPUSH
15885: CALL_OW 74
15889: PPUSH
15890: CALL_OW 115
// end ;
15894: GO 15660
15896: POP
15897: POP
// end ;
15898: PPOPN 3
15900: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
15901: LD_EXP 30
15905: NOT
15906: IFFALSE 16027
15908: GO 15910
15910: DISABLE
15911: LD_INT 0
15913: PPUSH
15914: PPUSH
// begin enable ;
15915: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
15916: LD_ADDR_VAR 0 2
15920: PUSH
15921: LD_INT 22
15923: PUSH
15924: LD_INT 3
15926: PUSH
15927: EMPTY
15928: LIST
15929: LIST
15930: PUSH
15931: LD_INT 21
15933: PUSH
15934: LD_INT 3
15936: PUSH
15937: EMPTY
15938: LIST
15939: LIST
15940: PUSH
15941: EMPTY
15942: LIST
15943: LIST
15944: PPUSH
15945: CALL_OW 69
15949: ST_TO_ADDR
// if filter then
15950: LD_VAR 0 2
15954: IFFALSE 16027
// for i in filter do
15956: LD_ADDR_VAR 0 1
15960: PUSH
15961: LD_VAR 0 2
15965: PUSH
15966: FOR_IN
15967: IFFALSE 16025
// if GetLives ( i ) < 990 then
15969: LD_VAR 0 1
15973: PPUSH
15974: CALL_OW 256
15978: PUSH
15979: LD_INT 990
15981: LESS
15982: IFFALSE 16023
// begin ru_alert := true ;
15984: LD_ADDR_EXP 58
15988: PUSH
15989: LD_INT 1
15991: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
15992: LD_ADDR_EXP 59
15996: PUSH
15997: LD_VAR 0 1
16001: PPUSH
16002: CALL_OW 250
16006: PUSH
16007: LD_VAR 0 1
16011: PPUSH
16012: CALL_OW 251
16016: PUSH
16017: EMPTY
16018: LIST
16019: LIST
16020: ST_TO_ADDR
// break ;
16021: GO 16025
// end ;
16023: GO 15966
16025: POP
16026: POP
// end ;
16027: PPOPN 2
16029: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
16030: LD_EXP 29
16034: IFFALSE 16183
16036: GO 16038
16038: DISABLE
16039: LD_INT 0
16041: PPUSH
16042: PPUSH
16043: PPUSH
16044: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
16045: LD_ADDR_VAR 0 4
16049: PUSH
16050: LD_EXP 54
16054: PUSH
16055: LD_EXP 53
16059: ADD
16060: PUSH
16061: LD_EXP 51
16065: ADD
16066: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
16067: LD_ADDR_VAR 0 3
16071: PUSH
16072: LD_INT 3
16074: PPUSH
16075: LD_INT 81
16077: PUSH
16078: LD_INT 3
16080: PUSH
16081: EMPTY
16082: LIST
16083: LIST
16084: PPUSH
16085: CALL_OW 70
16089: ST_TO_ADDR
// if filter and enemy then
16090: LD_VAR 0 4
16094: PUSH
16095: LD_VAR 0 3
16099: AND
16100: IFFALSE 16183
// repeat wait ( 0 0$01 ) ;
16102: LD_INT 35
16104: PPUSH
16105: CALL_OW 67
// for i in filter do
16109: LD_ADDR_VAR 0 1
16113: PUSH
16114: LD_VAR 0 4
16118: PUSH
16119: FOR_IN
16120: IFFALSE 16148
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16122: LD_VAR 0 1
16126: PPUSH
16127: LD_VAR 0 3
16131: PPUSH
16132: LD_VAR 0 1
16136: PPUSH
16137: CALL_OW 74
16141: PPUSH
16142: CALL_OW 115
// end ;
16146: GO 16119
16148: POP
16149: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
16150: LD_INT 3
16152: PPUSH
16153: LD_INT 81
16155: PUSH
16156: LD_INT 3
16158: PUSH
16159: EMPTY
16160: LIST
16161: LIST
16162: PPUSH
16163: CALL_OW 70
16167: PUSH
16168: LD_INT 0
16170: EQUAL
16171: PUSH
16172: LD_VAR 0 4
16176: PUSH
16177: LD_INT 0
16179: EQUAL
16180: OR
16181: IFFALSE 16102
// end ;
16183: PPOPN 4
16185: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) do var i ;
16186: LD_EXP 25
16190: PUSH
16191: LD_INT 22
16193: PUSH
16194: LD_INT 4
16196: PUSH
16197: EMPTY
16198: LIST
16199: LIST
16200: PUSH
16201: LD_INT 30
16203: PUSH
16204: LD_INT 4
16206: PUSH
16207: EMPTY
16208: LIST
16209: LIST
16210: PUSH
16211: LD_INT 3
16213: PUSH
16214: LD_INT 57
16216: PUSH
16217: EMPTY
16218: LIST
16219: PUSH
16220: EMPTY
16221: LIST
16222: LIST
16223: PUSH
16224: EMPTY
16225: LIST
16226: LIST
16227: LIST
16228: PPUSH
16229: CALL_OW 69
16233: AND
16234: IFFALSE 16283
16236: GO 16238
16238: DISABLE
16239: LD_INT 0
16241: PPUSH
// begin if not ru_cornel_attack then
16242: LD_EXP 56
16246: NOT
16247: IFFALSE 16251
// exit ;
16249: GO 16283
// for i in ru_cornel_attack do
16251: LD_ADDR_VAR 0 1
16255: PUSH
16256: LD_EXP 56
16260: PUSH
16261: FOR_IN
16262: IFFALSE 16281
// ComAgressiveMove ( i , 258 , 119 ) ;
16264: LD_VAR 0 1
16268: PPUSH
16269: LD_INT 258
16271: PPUSH
16272: LD_INT 119
16274: PPUSH
16275: CALL_OW 114
16279: GO 16261
16281: POP
16282: POP
// end ; end_of_file
16283: PPOPN 1
16285: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
16286: LD_EXP 5
16290: PUSH
16291: LD_EXP 9
16295: NOT
16296: AND
16297: PUSH
16298: LD_EXP 19
16302: AND
16303: IFFALSE 16415
16305: GO 16307
16307: DISABLE
16308: LD_INT 0
16310: PPUSH
// begin enable ;
16311: ENABLE
// crates_counter := crates_counter - 50 ;
16312: LD_ADDR_EXP 19
16316: PUSH
16317: LD_EXP 19
16321: PUSH
16322: LD_INT 50
16324: MINUS
16325: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
16326: LD_INT 8
16328: PPUSH
16329: LD_INT 2
16331: PPUSH
16332: LD_INT 5
16334: PPUSH
16335: CALL_OW 12
16339: PPUSH
16340: LD_INT 1
16342: PPUSH
16343: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
16347: LD_INT 1785
16349: PPUSH
16350: LD_INT 2345
16352: PPUSH
16353: CALL_OW 12
16357: PPUSH
16358: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
16362: LD_ADDR_VAR 0 1
16366: PUSH
16367: LD_INT 1
16369: PPUSH
16370: LD_OWVAR 67
16374: PUSH
16375: LD_INT 2
16377: PLUS
16378: PPUSH
16379: CALL_OW 12
16383: ST_TO_ADDR
// if r < 3 then
16384: LD_VAR 0 1
16388: PUSH
16389: LD_INT 3
16391: LESS
16392: IFFALSE 16415
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
16394: LD_INT 4
16396: PPUSH
16397: LD_INT 1
16399: PPUSH
16400: LD_INT 5
16402: PPUSH
16403: CALL_OW 12
16407: PPUSH
16408: LD_INT 1
16410: PPUSH
16411: CALL_OW 55
// end ;
16415: PPOPN 1
16417: END
// every 0 0$01 trigger cornel_active do
16418: LD_EXP 8
16422: IFFALSE 16511
16424: GO 16426
16426: DISABLE
// begin Wait ( 0 0$03 ) ;
16427: LD_INT 105
16429: PPUSH
16430: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16434: LD_INT 2
16436: PPUSH
16437: LD_INT 5
16439: PPUSH
16440: CALL_OW 12
16444: PPUSH
16445: LD_INT 10
16447: PPUSH
16448: LD_INT 1
16450: PPUSH
16451: CALL_OW 55
// Wait ( 0 0$13 ) ;
16455: LD_INT 455
16457: PPUSH
16458: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16462: LD_INT 2
16464: PPUSH
16465: LD_INT 5
16467: PPUSH
16468: CALL_OW 12
16472: PPUSH
16473: LD_INT 10
16475: PPUSH
16476: LD_INT 1
16478: PPUSH
16479: CALL_OW 55
// Wait ( 0 0$16 ) ;
16483: LD_INT 560
16485: PPUSH
16486: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16490: LD_INT 2
16492: PPUSH
16493: LD_INT 5
16495: PPUSH
16496: CALL_OW 12
16500: PPUSH
16501: LD_INT 10
16503: PPUSH
16504: LD_INT 1
16506: PPUSH
16507: CALL_OW 55
// end ; end_of_file
16511: END
// every 0 0$01 trigger cornel_prepared do
16512: LD_EXP 11
16516: IFFALSE 16575
16518: GO 16520
16520: DISABLE
// begin enable ;
16521: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
16522: LD_ADDR_OWVAR 47
16526: PUSH
16527: LD_STRING #Am03-1
16529: PUSH
16530: LD_EXP 10
16534: PUSH
16535: EMPTY
16536: LIST
16537: LIST
16538: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
16539: LD_ADDR_EXP 10
16543: PUSH
16544: LD_EXP 10
16548: PPUSH
16549: LD_STRING -
16551: PPUSH
16552: CALL 1109 0 2
16556: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
16557: LD_EXP 10
16561: PUSH
16562: LD_INT 0
16564: EQUAL
16565: IFFALSE 16575
// begin Display_Strings := [ ] ;
16567: LD_ADDR_OWVAR 47
16571: PUSH
16572: EMPTY
16573: ST_TO_ADDR
// disable ;
16574: DISABLE
// end ; end ;
16575: END
// every 0 0$01 trigger debug and debug_strings do
16576: LD_EXP 1
16580: PUSH
16581: LD_OWVAR 48
16585: AND
16586: IFFALSE 16602
16588: GO 16590
16590: DISABLE
// begin enable ;
16591: ENABLE
// Display_Strings := debug_strings ;
16592: LD_ADDR_OWVAR 47
16596: PUSH
16597: LD_OWVAR 48
16601: ST_TO_ADDR
// end ; end_of_file
16602: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
16603: LD_VAR 0 1
16607: PPUSH
16608: CALL_OW 255
16612: PUSH
16613: LD_INT 1
16615: EQUAL
16616: PUSH
16617: LD_EXP 13
16621: NOT
16622: AND
16623: IFFALSE 16633
// solar_builded := true ;
16625: LD_ADDR_EXP 13
16629: PUSH
16630: LD_INT 1
16632: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
16633: LD_VAR 0 1
16637: PPUSH
16638: CALL_OW 255
16642: PUSH
16643: LD_INT 1
16645: EQUAL
16646: PUSH
16647: LD_EXP 27
16651: AND
16652: IFFALSE 16685
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
16654: LD_ADDR_EXP 27
16658: PUSH
16659: LD_EXP 27
16663: PUSH
16664: LD_INT 1750
16666: PUSH
16667: LD_INT 1400
16669: PUSH
16670: LD_INT 1225
16672: PUSH
16673: EMPTY
16674: LIST
16675: LIST
16676: LIST
16677: PUSH
16678: LD_OWVAR 67
16682: ARRAY
16683: PLUS
16684: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
16685: LD_VAR 0 1
16689: PPUSH
16690: CALL_OW 255
16694: PUSH
16695: LD_INT 3
16697: EQUAL
16698: IFFALSE 16716
// ru_vehicles := ru_vehicles ^ veh ;
16700: LD_ADDR_EXP 54
16704: PUSH
16705: LD_EXP 54
16709: PUSH
16710: LD_VAR 0 1
16714: ADD
16715: ST_TO_ADDR
// end ;
16716: PPOPN 2
16718: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
16719: LD_VAR 0 1
16723: PUSH
16724: LD_EXP 51
16728: IN
16729: IFFALSE 16747
// ru_patrol := ru_patrol diff un ;
16731: LD_ADDR_EXP 51
16735: PUSH
16736: LD_EXP 51
16740: PUSH
16741: LD_VAR 0 1
16745: DIFF
16746: ST_TO_ADDR
// if un in ru_forest then
16747: LD_VAR 0 1
16751: PUSH
16752: LD_EXP 53
16756: IN
16757: IFFALSE 16775
// ru_forest := ru_forest diff un ;
16759: LD_ADDR_EXP 53
16763: PUSH
16764: LD_EXP 53
16768: PUSH
16769: LD_VAR 0 1
16773: DIFF
16774: ST_TO_ADDR
// if un in ru_vehicles then
16775: LD_VAR 0 1
16779: PUSH
16780: LD_EXP 54
16784: IN
16785: IFFALSE 16860
// begin ru_vehicles := ru_vehicles diff un ;
16787: LD_ADDR_EXP 54
16791: PUSH
16792: LD_EXP 54
16796: PUSH
16797: LD_VAR 0 1
16801: DIFF
16802: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
16803: LD_ADDR_EXP 55
16807: PUSH
16808: LD_EXP 55
16812: PUSH
16813: LD_VAR 0 1
16817: PPUSH
16818: CALL_OW 265
16822: PUSH
16823: LD_VAR 0 1
16827: PPUSH
16828: CALL_OW 262
16832: PUSH
16833: LD_VAR 0 1
16837: PPUSH
16838: CALL_OW 263
16842: PUSH
16843: LD_VAR 0 1
16847: PPUSH
16848: CALL_OW 264
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: LIST
16857: LIST
16858: ADD
16859: ST_TO_ADDR
// end ; if un = JMM then
16860: LD_VAR 0 1
16864: PUSH
16865: LD_EXP 35
16869: EQUAL
16870: IFFALSE 16879
// YouLost ( 0 ) ;
16872: LD_STRING 0
16874: PPUSH
16875: CALL_OW 104
// if un = us_dep_west then
16879: LD_VAR 0 1
16883: PUSH
16884: LD_INT 1
16886: EQUAL
16887: IFFALSE 16896
// YouLost ( 2 ) ;
16889: LD_STRING 2
16891: PPUSH
16892: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
16896: LD_VAR 0 1
16900: PPUSH
16901: CALL_OW 255
16905: PUSH
16906: LD_INT 8
16908: EQUAL
16909: PUSH
16910: LD_EXP 5
16914: NOT
16915: AND
16916: IFFALSE 16925
// YouLost ( 4 ) ;
16918: LD_STRING 4
16920: PPUSH
16921: CALL_OW 104
// if un in jmm_units then
16925: LD_VAR 0 1
16929: PUSH
16930: LD_EXP 4
16934: IN
16935: IFFALSE 16951
// lose_counter := lose_counter + 1 ;
16937: LD_ADDR_EXP 32
16941: PUSH
16942: LD_EXP 32
16946: PUSH
16947: LD_INT 1
16949: PLUS
16950: ST_TO_ADDR
// end ;
16951: PPOPN 1
16953: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
16954: LD_INT 0
16956: PPUSH
16957: PPUSH
// begin if GetSide ( driver ) = 3 then
16958: LD_VAR 0 1
16962: PPUSH
16963: CALL_OW 255
16967: PUSH
16968: LD_INT 3
16970: EQUAL
16971: IFFALSE 17049
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
16973: LD_ADDR_VAR 0 6
16977: PUSH
16978: LD_INT 22
16980: PUSH
16981: LD_INT 3
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: PUSH
16988: LD_INT 30
16990: PUSH
16991: LD_INT 3
16993: PUSH
16994: EMPTY
16995: LIST
16996: LIST
16997: PUSH
16998: EMPTY
16999: LIST
17000: LIST
17001: PPUSH
17002: CALL_OW 69
17006: PPUSH
17007: CALL 1039 0 1
17011: ST_TO_ADDR
// if place then
17012: LD_VAR 0 6
17016: IFFALSE 17034
// ComEnterUnit ( driver , place ) else
17018: LD_VAR 0 1
17022: PPUSH
17023: LD_VAR 0 6
17027: PPUSH
17028: CALL_OW 120
17032: GO 17049
// ComMoveXY ( driver , 70 , 22 ) ;
17034: LD_VAR 0 1
17038: PPUSH
17039: LD_INT 70
17041: PPUSH
17042: LD_INT 22
17044: PPUSH
17045: CALL_OW 111
// end ; end ;
17049: PPOPN 6
17051: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and ( s2 = 4 or ( s2 = 8 and not jmm_on_west ) ) then
17052: LD_VAR 0 1
17056: PUSH
17057: LD_INT 1
17059: EQUAL
17060: PUSH
17061: LD_VAR 0 2
17065: PUSH
17066: LD_INT 4
17068: EQUAL
17069: PUSH
17070: LD_VAR 0 2
17074: PUSH
17075: LD_INT 8
17077: EQUAL
17078: PUSH
17079: LD_EXP 5
17083: NOT
17084: AND
17085: OR
17086: AND
17087: IFFALSE 17096
// YouLost ( 5 ) ;
17089: LD_STRING 5
17091: PPUSH
17092: CALL_OW 104
// end ;
17096: PPOPN 2
17098: END
// every 0 0$01 trigger save_counter + ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
17099: LD_EXP 34
17103: PUSH
17104: LD_INT 22
17106: PUSH
17107: LD_INT 1
17109: PUSH
17110: EMPTY
17111: LIST
17112: LIST
17113: PUSH
17114: LD_INT 21
17116: PUSH
17117: LD_INT 1
17119: PUSH
17120: EMPTY
17121: LIST
17122: LIST
17123: PUSH
17124: EMPTY
17125: LIST
17126: LIST
17127: PPUSH
17128: CALL_OW 69
17132: PUSH
17133: LD_INT 22
17135: PUSH
17136: LD_INT 8
17138: PUSH
17139: EMPTY
17140: LIST
17141: LIST
17142: PUSH
17143: LD_INT 21
17145: PUSH
17146: LD_INT 1
17148: PUSH
17149: EMPTY
17150: LIST
17151: LIST
17152: PUSH
17153: EMPTY
17154: LIST
17155: LIST
17156: PPUSH
17157: CALL_OW 69
17161: ADD
17162: PLUS
17163: PUSH
17164: LD_INT 5
17166: LESS
17167: IFFALSE 17179
17169: GO 17171
17171: DISABLE
// YouLost ( 1 ) ;
17172: LD_STRING 1
17174: PPUSH
17175: CALL_OW 104
17179: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
17180: LD_INT 1
17182: PPUSH
17183: CALL_OW 255
17187: PUSH
17188: LD_INT 3
17190: EQUAL
17191: IFFALSE 17203
17193: GO 17195
17195: DISABLE
// YouLost ( 3 ) ;
17196: LD_STRING 3
17198: PPUSH
17199: CALL_OW 104
17203: END
