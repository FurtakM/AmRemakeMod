// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 323 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 411 0 0
// PrepareRussian ;
  22: CALL 2923 0 0
// PrepareAmerican ;
  26: CALL 1164 0 0
// PrepareCornell ;
  30: CALL 2188 0 0
// PrepareWesternBase ;
  34: CALL 2414 0 0
// Action ;
  38: CALL 4929 0 0
// end ;
  42: END
// export debug ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// jmm_units := 0 ;
  54: LD_ADDR_EXP 2
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// cornel_units := 0 ;
  62: LD_ADDR_EXP 4
  66: PUSH
  67: LD_INT 0
  69: ST_TO_ADDR
// bierezov_exist := false ;
  70: LD_ADDR_EXP 5
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// jmm_on_west := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// cornel_active := false ;
  86: LD_ADDR_EXP 6
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// cornel_attack := false ;
  94: LD_ADDR_EXP 7
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_prepared := false ;
 102: LD_ADDR_EXP 9
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 110: LD_ADDR_EXP 8
 114: PUSH
 115: LD_INT 4200
 117: ST_TO_ADDR
// frank_can_return := false ;
 118: LD_ADDR_EXP 10
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// solar_builded := false ;
 126: LD_ADDR_EXP 11
 130: PUSH
 131: LD_INT 0
 133: ST_TO_ADDR
// frank_send_to_scout := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// jmm_in_veh := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// bobby_in_veh := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// cyrus_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// lisa_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 174: LD_ADDR_EXP 25
 178: PUSH
 179: LD_INT 25200
 181: PUSH
 182: LD_INT 23100
 184: PUSH
 185: LD_INT 21000
 187: PUSH
 188: EMPTY
 189: LIST
 190: LIST
 191: LIST
 192: PUSH
 193: LD_OWVAR 67
 197: ARRAY
 198: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 199: LD_ADDR_EXP 17
 203: PUSH
 204: LD_INT 600
 206: PUSH
 207: LD_INT 500
 209: PUSH
 210: LD_INT 400
 212: PUSH
 213: EMPTY
 214: LIST
 215: LIST
 216: LIST
 217: PUSH
 218: LD_OWVAR 67
 222: ARRAY
 223: ST_TO_ADDR
// end_mission_allowed := false ;
 224: LD_ADDR_EXP 18
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// save_others := [ ] ;
 232: LD_ADDR_EXP 19
 236: PUSH
 237: EMPTY
 238: ST_TO_ADDR
// save_group := [ ] ;
 239: LD_ADDR_EXP 20
 243: PUSH
 244: EMPTY
 245: ST_TO_ADDR
// show_query := true ;
 246: LD_ADDR_EXP 21
 250: PUSH
 251: LD_INT 1
 253: ST_TO_ADDR
// wait_for_them := false ;
 254: LD_ADDR_EXP 22
 258: PUSH
 259: LD_INT 0
 261: ST_TO_ADDR
// veh_on_meta := false ;
 262: LD_ADDR_EXP 24
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// send_spec_patrol := false ;
 270: LD_ADDR_EXP 26
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// prepare_siege := false ;
 278: LD_ADDR_EXP 27
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_attack_on_cornel := false ;
 286: LD_ADDR_EXP 28
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 294: LD_ADDR_EXP 23
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// game_end := false ;
 302: LD_ADDR_EXP 29
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// lose_counter := 0 ;
 310: LD_ADDR_EXP 30
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// end ;
 318: LD_VAR 0 1
 322: RET
// function SetDiplomacy ; begin
 323: LD_INT 0
 325: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 326: LD_INT 1
 328: PPUSH
 329: LD_INT 4
 331: PPUSH
 332: LD_INT 1
 334: PPUSH
 335: LD_INT 1
 337: PPUSH
 338: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 342: LD_INT 1
 344: PPUSH
 345: LD_INT 8
 347: PPUSH
 348: LD_INT 1
 350: PPUSH
 351: LD_INT 1
 353: PPUSH
 354: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 358: LD_INT 3
 360: PPUSH
 361: LD_INT 6
 363: PPUSH
 364: LD_INT 1
 366: PPUSH
 367: LD_INT 1
 369: PPUSH
 370: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 374: LD_INT 4
 376: PPUSH
 377: LD_INT 6
 379: PPUSH
 380: LD_INT 0
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 390: LD_INT 3
 392: PPUSH
 393: LD_INT 8
 395: PPUSH
 396: LD_INT 0
 398: PPUSH
 399: LD_INT 1
 401: PPUSH
 402: CALL_OW 80
// end ;
 406: LD_VAR 0 1
 410: RET
// export function DebugMode ; var i ; begin
 411: LD_INT 0
 413: PPUSH
 414: PPUSH
// FogOff ( 1 ) ;
 415: LD_INT 1
 417: PPUSH
 418: CALL_OW 344
// debug_strings := [ ] ;
 422: LD_ADDR_OWVAR 48
 426: PUSH
 427: EMPTY
 428: ST_TO_ADDR
// end ; end_of_file
 429: LD_VAR 0 1
 433: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 434: LD_INT 0
 436: PPUSH
 437: PPUSH
// if exist_mode then
 438: LD_VAR 0 2
 442: IFFALSE 461
// unit := CreateCharacter ( ident ) else
 444: LD_ADDR_VAR 0 4
 448: PUSH
 449: LD_VAR 0 1
 453: PPUSH
 454: CALL_OW 34
 458: ST_TO_ADDR
 459: GO 476
// unit := NewCharacter ( ident ) ;
 461: LD_ADDR_VAR 0 4
 465: PUSH
 466: LD_VAR 0 1
 470: PPUSH
 471: CALL_OW 25
 475: ST_TO_ADDR
// result := unit ;
 476: LD_ADDR_VAR 0 3
 480: PUSH
 481: LD_VAR 0 4
 485: ST_TO_ADDR
// end ;
 486: LD_VAR 0 3
 490: RET
// export function KickCharacter ( ident ) ; begin
 491: LD_INT 0
 493: PPUSH
// DeleteCharacters ( " & ident & " ) ;
 494: LD_STRING "
 496: PUSH
 497: LD_VAR 0 1
 501: STR
 502: PUSH
 503: LD_STRING "
 505: STR
 506: PPUSH
 507: CALL_OW 40
// end ;
 511: LD_VAR 0 2
 515: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 516: LD_INT 0
 518: PPUSH
// uc_side := side ;
 519: LD_ADDR_OWVAR 20
 523: PUSH
 524: LD_VAR 0 1
 528: ST_TO_ADDR
// uc_nation := nation ;
 529: LD_ADDR_OWVAR 21
 533: PUSH
 534: LD_VAR 0 2
 538: ST_TO_ADDR
// vc_chassis := chassis ;
 539: LD_ADDR_OWVAR 37
 543: PUSH
 544: LD_VAR 0 3
 548: ST_TO_ADDR
// vc_engine := engine ;
 549: LD_ADDR_OWVAR 39
 553: PUSH
 554: LD_VAR 0 4
 558: ST_TO_ADDR
// vc_control := control ;
 559: LD_ADDR_OWVAR 38
 563: PUSH
 564: LD_VAR 0 5
 568: ST_TO_ADDR
// vc_weapon := weapon ;
 569: LD_ADDR_OWVAR 40
 573: PUSH
 574: LD_VAR 0 6
 578: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 579: LD_ADDR_OWVAR 41
 583: PUSH
 584: LD_VAR 0 7
 588: ST_TO_ADDR
// result := CreateVehicle ;
 589: LD_ADDR_VAR 0 8
 593: PUSH
 594: CALL_OW 45
 598: ST_TO_ADDR
// end ;
 599: LD_VAR 0 8
 603: RET
// export function SayX ( units , ident ) ; var i ; begin
 604: LD_INT 0
 606: PPUSH
 607: PPUSH
// result := false ;
 608: LD_ADDR_VAR 0 3
 612: PUSH
 613: LD_INT 0
 615: ST_TO_ADDR
// if not units then
 616: LD_VAR 0 1
 620: NOT
 621: IFFALSE 625
// exit ;
 623: GO 679
// for i in units do
 625: LD_ADDR_VAR 0 4
 629: PUSH
 630: LD_VAR 0 1
 634: PUSH
 635: FOR_IN
 636: IFFALSE 677
// if IsOk ( i ) then
 638: LD_VAR 0 4
 642: PPUSH
 643: CALL_OW 302
 647: IFFALSE 675
// begin Say ( i , ident ) ;
 649: LD_VAR 0 4
 653: PPUSH
 654: LD_VAR 0 2
 658: PPUSH
 659: CALL_OW 88
// result := i ;
 663: LD_ADDR_VAR 0 3
 667: PUSH
 668: LD_VAR 0 4
 672: ST_TO_ADDR
// break ;
 673: GO 677
// end ;
 675: GO 635
 677: POP
 678: POP
// end ;
 679: LD_VAR 0 3
 683: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 684: LD_INT 0
 686: PPUSH
 687: PPUSH
 688: PPUSH
 689: PPUSH
// for i = 1 to count do
 690: LD_ADDR_VAR 0 8
 694: PUSH
 695: DOUBLE
 696: LD_INT 1
 698: DEC
 699: ST_TO_ADDR
 700: LD_VAR 0 6
 704: PUSH
 705: FOR_TO
 706: IFFALSE 787
// begin uc_side = side ;
 708: LD_ADDR_OWVAR 20
 712: PUSH
 713: LD_VAR 0 1
 717: ST_TO_ADDR
// uc_nation = nation ;
 718: LD_ADDR_OWVAR 21
 722: PUSH
 723: LD_VAR 0 2
 727: ST_TO_ADDR
// hc_gallery =  ;
 728: LD_ADDR_OWVAR 33
 732: PUSH
 733: LD_STRING 
 735: ST_TO_ADDR
// hc_name =  ;
 736: LD_ADDR_OWVAR 26
 740: PUSH
 741: LD_STRING 
 743: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 744: LD_INT 0
 746: PPUSH
 747: LD_VAR 0 5
 751: PPUSH
 752: LD_VAR 0 4
 756: PPUSH
 757: CALL_OW 380
// un = CreateHuman ;
 761: LD_ADDR_VAR 0 10
 765: PUSH
 766: CALL_OW 44
 770: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 771: LD_VAR 0 10
 775: PPUSH
 776: LD_VAR 0 3
 780: PPUSH
 781: CALL_OW 52
// end ;
 785: GO 705
 787: POP
 788: POP
// end ;
 789: LD_VAR 0 7
 793: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 794: LD_INT 0
 796: PPUSH
 797: PPUSH
 798: PPUSH
// uc_side := GetSide ( b ) ;
 799: LD_ADDR_OWVAR 20
 803: PUSH
 804: LD_VAR 0 2
 808: PPUSH
 809: CALL_OW 255
 813: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 814: LD_ADDR_OWVAR 21
 818: PUSH
 819: LD_VAR 0 2
 823: PPUSH
 824: CALL_OW 248
 828: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 829: LD_INT 0
 831: PPUSH
 832: LD_INT 1
 834: PPUSH
 835: LD_VAR 0 1
 839: PPUSH
 840: CALL_OW 380
// un = CreateHuman ;
 844: LD_ADDR_VAR 0 4
 848: PUSH
 849: CALL_OW 44
 853: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 854: LD_ADDR_VAR 0 5
 858: PUSH
 859: LD_VAR 0 2
 863: PPUSH
 864: CALL_OW 254
 868: PUSH
 869: LD_INT 3
 871: MINUS
 872: ST_TO_ADDR
// if dir < 0 then
 873: LD_VAR 0 5
 877: PUSH
 878: LD_INT 0
 880: LESS
 881: IFFALSE 897
// dir := 6 + dir ;
 883: LD_ADDR_VAR 0 5
 887: PUSH
 888: LD_INT 6
 890: PUSH
 891: LD_VAR 0 5
 895: PLUS
 896: ST_TO_ADDR
// SetDir ( un , dir ) ;
 897: LD_VAR 0 4
 901: PPUSH
 902: LD_VAR 0 5
 906: PPUSH
 907: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 911: LD_VAR 0 4
 915: PPUSH
 916: LD_VAR 0 2
 920: PPUSH
 921: CALL_OW 52
// end ;
 925: LD_VAR 0 3
 929: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 930: LD_INT 0
 932: PPUSH
 933: PPUSH
 934: PPUSH
// result := false ;
 935: LD_ADDR_VAR 0 2
 939: PUSH
 940: LD_INT 0
 942: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 943: LD_ADDR_VAR 0 3
 947: PUSH
 948: LD_INT 22
 950: PUSH
 951: LD_INT 1
 953: PUSH
 954: EMPTY
 955: LIST
 956: LIST
 957: PUSH
 958: LD_INT 34
 960: PUSH
 961: LD_INT 2
 963: PUSH
 964: EMPTY
 965: LIST
 966: LIST
 967: PUSH
 968: EMPTY
 969: LIST
 970: LIST
 971: PPUSH
 972: CALL_OW 69
 976: ST_TO_ADDR
// for i in filter do
 977: LD_ADDR_VAR 0 4
 981: PUSH
 982: LD_VAR 0 3
 986: PUSH
 987: FOR_IN
 988: IFFALSE 1019
// if IsDrivenBy ( i ) = unit then
 990: LD_VAR 0 4
 994: PPUSH
 995: CALL_OW 311
 999: PUSH
1000: LD_VAR 0 1
1004: EQUAL
1005: IFFALSE 1017
// begin result := true ;
1007: LD_ADDR_VAR 0 2
1011: PUSH
1012: LD_INT 1
1014: ST_TO_ADDR
// break ;
1015: GO 1019
// end ;
1017: GO 987
1019: POP
1020: POP
// end ;
1021: LD_VAR 0 2
1025: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1026: LD_INT 0
1028: PPUSH
1029: PPUSH
// result := false ;
1030: LD_ADDR_VAR 0 2
1034: PUSH
1035: LD_INT 0
1037: ST_TO_ADDR
// if not blist then
1038: LD_VAR 0 1
1042: NOT
1043: IFFALSE 1047
// exit ;
1045: GO 1091
// for i in blist do
1047: LD_ADDR_VAR 0 3
1051: PUSH
1052: LD_VAR 0 1
1056: PUSH
1057: FOR_IN
1058: IFFALSE 1089
// if UnitsInside ( i ) < 6 then
1060: LD_VAR 0 3
1064: PPUSH
1065: CALL_OW 313
1069: PUSH
1070: LD_INT 6
1072: LESS
1073: IFFALSE 1087
// begin result := i ;
1075: LD_ADDR_VAR 0 2
1079: PUSH
1080: LD_VAR 0 3
1084: ST_TO_ADDR
// break ;
1085: GO 1089
// end ;
1087: GO 1057
1089: POP
1090: POP
// end ;
1091: LD_VAR 0 2
1095: RET
// export function Count ( timer , mode ) ; begin
1096: LD_INT 0
1098: PPUSH
// if not timer then
1099: LD_VAR 0 1
1103: NOT
1104: IFFALSE 1108
// exit ;
1106: GO 1159
// if mode in [ asc , up , + ] then
1108: LD_VAR 0 2
1112: PUSH
1113: LD_STRING asc
1115: PUSH
1116: LD_STRING up
1118: PUSH
1119: LD_STRING +
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: IN
1127: IFFALSE 1145
// result := timer + 0 0$01 else
1129: LD_ADDR_VAR 0 3
1133: PUSH
1134: LD_VAR 0 1
1138: PUSH
1139: LD_INT 35
1141: PLUS
1142: ST_TO_ADDR
1143: GO 1159
// result := timer - 0 0$01 ;
1145: LD_ADDR_VAR 0 3
1149: PUSH
1150: LD_VAR 0 1
1154: PUSH
1155: LD_INT 35
1157: MINUS
1158: ST_TO_ADDR
// end ; end_of_file
1159: LD_VAR 0 3
1163: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1164: LD_INT 0
1166: PPUSH
1167: PPUSH
1168: PPUSH
1169: PPUSH
1170: PPUSH
1171: PPUSH
1172: PPUSH
1173: PPUSH
// uc_side := 4 ;
1174: LD_ADDR_OWVAR 20
1178: PUSH
1179: LD_INT 4
1181: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1182: LD_ADDR_EXP 40
1186: PUSH
1187: LD_STRING Powell
1189: PPUSH
1190: LD_INT 0
1192: PPUSH
1193: CALL 434 0 2
1197: ST_TO_ADDR
// uc_side := 1 ;
1198: LD_ADDR_OWVAR 20
1202: PUSH
1203: LD_INT 1
1205: ST_TO_ADDR
// uc_nation := 1 ;
1206: LD_ADDR_OWVAR 21
1210: PUSH
1211: LD_INT 1
1213: ST_TO_ADDR
// if debug then
1214: LD_EXP 1
1218: IFFALSE 1348
// begin for i = 1 to 4 do
1220: LD_ADDR_VAR 0 2
1224: PUSH
1225: DOUBLE
1226: LD_INT 1
1228: DEC
1229: ST_TO_ADDR
1230: LD_INT 4
1232: PUSH
1233: FOR_TO
1234: IFFALSE 1285
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1236: LD_INT 0
1238: PPUSH
1239: LD_INT 1
1241: PPUSH
1242: LD_INT 2
1244: PPUSH
1245: CALL_OW 12
1249: PPUSH
1250: LD_INT 3
1252: PPUSH
1253: CALL_OW 380
// un := CreateHuman ;
1257: LD_ADDR_VAR 0 3
1261: PUSH
1262: CALL_OW 44
1266: ST_TO_ADDR
// others := others ^ un ;
1267: LD_ADDR_VAR 0 5
1271: PUSH
1272: LD_VAR 0 5
1276: PUSH
1277: LD_VAR 0 3
1281: ADD
1282: ST_TO_ADDR
// end ;
1283: GO 1233
1285: POP
1286: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1287: LD_ADDR_VAR 0 6
1291: PUSH
1292: LD_INT 21
1294: PUSH
1295: LD_INT 1
1297: PUSH
1298: LD_INT 1
1300: PUSH
1301: LD_INT 51
1303: PUSH
1304: LD_INT 90
1306: PUSH
1307: LD_INT 504
1309: PUSH
1310: EMPTY
1311: LIST
1312: LIST
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: PUSH
1318: LD_INT 21
1320: PUSH
1321: LD_INT 1
1323: PUSH
1324: LD_INT 1
1326: PUSH
1327: LD_INT 51
1329: PUSH
1330: LD_INT 80
1332: PUSH
1333: LD_INT 750
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: LIST
1341: LIST
1342: LIST
1343: PUSH
1344: EMPTY
1345: LIST
1346: LIST
1347: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1348: LD_ADDR_EXP 31
1352: PUSH
1353: LD_STRING JMM
1355: PPUSH
1356: LD_EXP 1
1360: NOT
1361: PPUSH
1362: CALL 434 0 2
1366: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1367: LD_ADDR_EXP 32
1371: PUSH
1372: LD_STRING Bobby
1374: PPUSH
1375: LD_EXP 1
1379: NOT
1380: PPUSH
1381: CALL 434 0 2
1385: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1386: LD_ADDR_EXP 33
1390: PUSH
1391: LD_STRING Cyrus
1393: PPUSH
1394: LD_EXP 1
1398: NOT
1399: PPUSH
1400: CALL 434 0 2
1404: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1405: LD_ADDR_EXP 34
1409: PUSH
1410: LD_STRING Lisa
1412: PPUSH
1413: LD_EXP 1
1417: NOT
1418: PPUSH
1419: CALL 434 0 2
1423: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1424: LD_ADDR_EXP 35
1428: PUSH
1429: LD_STRING Khatam
1431: PPUSH
1432: LD_EXP 1
1436: NOT
1437: PPUSH
1438: CALL 434 0 2
1442: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1443: LD_ADDR_EXP 36
1447: PUSH
1448: LD_STRING Brian
1450: PPUSH
1451: LD_EXP 1
1455: NOT
1456: PPUSH
1457: CALL 434 0 2
1461: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1462: LD_ADDR_EXP 37
1466: PUSH
1467: LD_STRING Jerry
1469: PPUSH
1470: LD_EXP 1
1474: NOT
1475: PPUSH
1476: CALL 434 0 2
1480: ST_TO_ADDR
// if Bobby then
1481: LD_EXP 32
1485: IFFALSE 1516
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1487: LD_ADDR_VAR 0 4
1491: PUSH
1492: LD_VAR 0 4
1496: PPUSH
1497: LD_VAR 0 4
1501: PUSH
1502: LD_INT 1
1504: PLUS
1505: PPUSH
1506: LD_EXP 32
1510: PPUSH
1511: CALL_OW 2
1515: ST_TO_ADDR
// if Cyrus then
1516: LD_EXP 33
1520: IFFALSE 1551
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1522: LD_ADDR_VAR 0 4
1526: PUSH
1527: LD_VAR 0 4
1531: PPUSH
1532: LD_VAR 0 4
1536: PUSH
1537: LD_INT 1
1539: PLUS
1540: PPUSH
1541: LD_EXP 33
1545: PPUSH
1546: CALL_OW 2
1550: ST_TO_ADDR
// if Lisa then
1551: LD_EXP 34
1555: IFFALSE 1586
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1557: LD_ADDR_VAR 0 4
1561: PUSH
1562: LD_VAR 0 4
1566: PPUSH
1567: LD_VAR 0 4
1571: PUSH
1572: LD_INT 1
1574: PLUS
1575: PPUSH
1576: LD_EXP 34
1580: PPUSH
1581: CALL_OW 2
1585: ST_TO_ADDR
// if Khatam then
1586: LD_EXP 35
1590: IFFALSE 1621
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1592: LD_ADDR_VAR 0 4
1596: PUSH
1597: LD_VAR 0 4
1601: PPUSH
1602: LD_VAR 0 4
1606: PUSH
1607: LD_INT 1
1609: PLUS
1610: PPUSH
1611: LD_EXP 35
1615: PPUSH
1616: CALL_OW 2
1620: ST_TO_ADDR
// if Brian then
1621: LD_EXP 36
1625: IFFALSE 1656
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1627: LD_ADDR_VAR 0 4
1631: PUSH
1632: LD_VAR 0 4
1636: PPUSH
1637: LD_VAR 0 4
1641: PUSH
1642: LD_INT 1
1644: PLUS
1645: PPUSH
1646: LD_EXP 36
1650: PPUSH
1651: CALL_OW 2
1655: ST_TO_ADDR
// if Jerry then
1656: LD_EXP 37
1660: IFFALSE 1691
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1662: LD_ADDR_VAR 0 4
1666: PUSH
1667: LD_VAR 0 4
1671: PPUSH
1672: LD_VAR 0 4
1676: PUSH
1677: LD_INT 1
1679: PLUS
1680: PPUSH
1681: LD_EXP 37
1685: PPUSH
1686: CALL_OW 2
1690: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1691: LD_STRING 02_other_survivors
1693: PPUSH
1694: CALL_OW 28
1698: IFFALSE 1713
// others := CreateCharacterSet ( 02_other_survivors ) ;
1700: LD_ADDR_VAR 0 5
1704: PUSH
1705: LD_STRING 02_other_survivors
1707: PPUSH
1708: CALL_OW 31
1712: ST_TO_ADDR
// if others then
1713: LD_VAR 0 5
1717: IFFALSE 1742
// begin tmp := tmp ^ others ;
1719: LD_ADDR_VAR 0 4
1723: PUSH
1724: LD_VAR 0 4
1728: PUSH
1729: LD_VAR 0 5
1733: ADD
1734: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1735: LD_STRING 02_other_survivors
1737: PPUSH
1738: CALL_OW 40
// end ; jmm_units := tmp ;
1742: LD_ADDR_EXP 2
1746: PUSH
1747: LD_VAR 0 4
1751: ST_TO_ADDR
// if not vehicles then
1752: LD_VAR 0 6
1756: NOT
1757: IFFALSE 1775
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1759: LD_ADDR_VAR 0 6
1763: PUSH
1764: LD_STRING 02_tanks_1
1766: PPUSH
1767: LD_INT 0
1769: PPUSH
1770: CALL_OW 30
1774: ST_TO_ADDR
// if vehicles then
1775: LD_VAR 0 6
1779: IFFALSE 1973
// begin got_mech := false ;
1781: LD_ADDR_VAR 0 7
1785: PUSH
1786: LD_INT 0
1788: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1789: LD_VAR 0 4
1793: PPUSH
1794: LD_INT 25
1796: PUSH
1797: LD_INT 3
1799: PUSH
1800: EMPTY
1801: LIST
1802: LIST
1803: PPUSH
1804: CALL_OW 72
1808: IFFALSE 1818
// got_mech := true ;
1810: LD_ADDR_VAR 0 7
1814: PUSH
1815: LD_INT 1
1817: ST_TO_ADDR
// for i = 1 to vehicles do
1818: LD_ADDR_VAR 0 2
1822: PUSH
1823: DOUBLE
1824: LD_INT 1
1826: DEC
1827: ST_TO_ADDR
1828: LD_VAR 0 6
1832: PUSH
1833: FOR_TO
1834: IFFALSE 1971
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1836: LD_ADDR_VAR 0 3
1840: PUSH
1841: LD_INT 1
1843: PPUSH
1844: LD_INT 3
1846: PPUSH
1847: LD_VAR 0 6
1851: PUSH
1852: LD_VAR 0 2
1856: ARRAY
1857: PUSH
1858: LD_INT 1
1860: ARRAY
1861: PPUSH
1862: LD_VAR 0 6
1866: PUSH
1867: LD_VAR 0 2
1871: ARRAY
1872: PUSH
1873: LD_INT 2
1875: ARRAY
1876: PPUSH
1877: LD_VAR 0 6
1881: PUSH
1882: LD_VAR 0 2
1886: ARRAY
1887: PUSH
1888: LD_INT 3
1890: ARRAY
1891: PPUSH
1892: LD_VAR 0 6
1896: PUSH
1897: LD_VAR 0 2
1901: ARRAY
1902: PUSH
1903: LD_INT 4
1905: ARRAY
1906: PPUSH
1907: LD_INT 40
1909: PPUSH
1910: CALL 516 0 7
1914: ST_TO_ADDR
// if not got_mech then
1915: LD_VAR 0 7
1919: NOT
1920: IFFALSE 1946
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1922: LD_VAR 0 3
1926: PPUSH
1927: LD_VAR 0 6
1931: PUSH
1932: LD_VAR 0 2
1936: ARRAY
1937: PUSH
1938: LD_INT 6
1940: ARRAY
1941: PPUSH
1942: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1946: LD_ADDR_VAR 0 4
1950: PUSH
1951: LD_VAR 0 4
1955: PPUSH
1956: LD_INT 1
1958: PPUSH
1959: LD_VAR 0 3
1963: PPUSH
1964: CALL_OW 2
1968: ST_TO_ADDR
// end ;
1969: GO 1833
1971: POP
1972: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1973: LD_EXP 31
1977: PPUSH
1978: LD_INT 194
1980: PPUSH
1981: LD_INT 119
1983: PPUSH
1984: LD_INT 0
1986: PPUSH
1987: CALL_OW 48
// if tmp then
1991: LD_VAR 0 4
1995: IFFALSE 2120
// begin for i in tmp do
1997: LD_ADDR_VAR 0 2
2001: PUSH
2002: LD_VAR 0 4
2006: PUSH
2007: FOR_IN
2008: IFFALSE 2118
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2010: LD_ADDR_VAR 0 8
2014: PUSH
2015: LD_INT 22
2017: PUSH
2018: LD_INT 1
2020: PUSH
2021: EMPTY
2022: LIST
2023: LIST
2024: PUSH
2025: LD_INT 21
2027: PUSH
2028: LD_INT 2
2030: PUSH
2031: EMPTY
2032: LIST
2033: LIST
2034: PUSH
2035: LD_INT 58
2037: PUSH
2038: EMPTY
2039: LIST
2040: PUSH
2041: EMPTY
2042: LIST
2043: LIST
2044: LIST
2045: PPUSH
2046: CALL_OW 69
2050: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2051: LD_VAR 0 2
2055: PPUSH
2056: CALL_OW 247
2060: PUSH
2061: LD_INT 1
2063: EQUAL
2064: PUSH
2065: LD_VAR 0 8
2069: AND
2070: IFFALSE 2092
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2072: LD_VAR 0 2
2076: PPUSH
2077: LD_VAR 0 8
2081: PUSH
2082: LD_INT 1
2084: ARRAY
2085: PPUSH
2086: CALL_OW 52
2090: GO 2107
// PlaceUnitArea ( i , startArea , false ) ;
2092: LD_VAR 0 2
2096: PPUSH
2097: LD_INT 1
2099: PPUSH
2100: LD_INT 0
2102: PPUSH
2103: CALL_OW 49
// ComHold ( i ) ;
2107: LD_VAR 0 2
2111: PPUSH
2112: CALL_OW 140
// end ;
2116: GO 2007
2118: POP
2119: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2120: LD_ADDR_EXP 5
2124: PUSH
2125: LD_STRING 02_mikhailStatus_1
2127: PPUSH
2128: LD_INT 0
2130: PPUSH
2131: CALL_OW 30
2135: ST_TO_ADDR
// if not bierezov_exist and not debug then
2136: LD_EXP 5
2140: NOT
2141: PUSH
2142: LD_EXP 1
2146: NOT
2147: AND
2148: IFFALSE 2152
// exit ;
2150: GO 2183
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2152: LD_ADDR_EXP 39
2156: PUSH
2157: LD_STRING Mikhail
2159: PPUSH
2160: LD_INT 0
2162: PPUSH
2163: CALL 434 0 2
2167: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2168: LD_EXP 39
2172: PPUSH
2173: LD_INT 1
2175: PPUSH
2176: LD_INT 0
2178: PPUSH
2179: CALL_OW 49
// end ;
2183: LD_VAR 0 1
2187: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2188: LD_INT 0
2190: PPUSH
2191: PPUSH
2192: PPUSH
2193: PPUSH
// uc_side := 4 ;
2194: LD_ADDR_OWVAR 20
2198: PUSH
2199: LD_INT 4
2201: ST_TO_ADDR
// uc_nation := 1 ;
2202: LD_ADDR_OWVAR 21
2206: PUSH
2207: LD_INT 1
2209: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2210: LD_ADDR_EXP 38
2214: PUSH
2215: LD_STRING Cornell
2217: PPUSH
2218: LD_INT 0
2220: PPUSH
2221: CALL 434 0 2
2225: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
2226: LD_ADDR_EXP 4
2230: PUSH
2231: LD_INT 8
2233: PUSH
2234: LD_EXP 2
2238: MINUS
2239: ST_TO_ADDR
// tmp := [ ] ;
2240: LD_ADDR_VAR 0 2
2244: PUSH
2245: EMPTY
2246: ST_TO_ADDR
// if cornel_units < 3 then
2247: LD_EXP 4
2251: PUSH
2252: LD_INT 3
2254: LESS
2255: IFFALSE 2265
// cornel_units := 3 ;
2257: LD_ADDR_EXP 4
2261: PUSH
2262: LD_INT 3
2264: ST_TO_ADDR
// for i = 1 to cornel_units do
2265: LD_ADDR_VAR 0 4
2269: PUSH
2270: DOUBLE
2271: LD_INT 1
2273: DEC
2274: ST_TO_ADDR
2275: LD_EXP 4
2279: PUSH
2280: FOR_TO
2281: IFFALSE 2379
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2283: LD_INT 0
2285: PPUSH
2286: LD_INT 1
2288: PUSH
2289: LD_INT 1
2291: PUSH
2292: LD_INT 1
2294: PUSH
2295: LD_INT 2
2297: PUSH
2298: LD_INT 4
2300: PUSH
2301: EMPTY
2302: LIST
2303: LIST
2304: LIST
2305: LIST
2306: LIST
2307: PUSH
2308: LD_VAR 0 4
2312: PUSH
2313: LD_INT 5
2315: MOD
2316: PUSH
2317: LD_INT 1
2319: PLUS
2320: ARRAY
2321: PPUSH
2322: LD_INT 2
2324: PPUSH
2325: CALL_OW 380
// un := CreateHuman ;
2329: LD_ADDR_VAR 0 3
2333: PUSH
2334: CALL_OW 44
2338: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2339: LD_ADDR_VAR 0 2
2343: PUSH
2344: LD_VAR 0 2
2348: PPUSH
2349: LD_INT 1
2351: PPUSH
2352: LD_VAR 0 3
2356: PPUSH
2357: CALL_OW 2
2361: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2362: LD_VAR 0 3
2366: PPUSH
2367: LD_INT 2
2369: PPUSH
2370: LD_INT 0
2372: PPUSH
2373: CALL_OW 49
// end ;
2377: GO 2280
2379: POP
2380: POP
// cornel_units := tmp ;
2381: LD_ADDR_EXP 4
2385: PUSH
2386: LD_VAR 0 2
2390: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2391: LD_EXP 38
2395: PPUSH
2396: LD_INT 191
2398: PPUSH
2399: LD_INT 106
2401: PPUSH
2402: LD_INT 0
2404: PPUSH
2405: CALL_OW 48
// end ;
2409: LD_VAR 0 1
2413: RET
// export function PrepareWesternBase ; var i ; begin
2414: LD_INT 0
2416: PPUSH
2417: PPUSH
// uc_side := 8 ;
2418: LD_ADDR_OWVAR 20
2422: PUSH
2423: LD_INT 8
2425: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2426: LD_ADDR_EXP 41
2430: PUSH
2431: LD_STRING Lynch
2433: PPUSH
2434: LD_INT 0
2436: PPUSH
2437: CALL 434 0 2
2441: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2442: LD_ADDR_EXP 42
2446: PUSH
2447: LD_STRING Walker
2449: PPUSH
2450: LD_INT 0
2452: PPUSH
2453: CALL 434 0 2
2457: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2458: LD_ADDR_EXP 43
2462: PUSH
2463: LD_STRING Turner
2465: PPUSH
2466: LD_INT 0
2468: PPUSH
2469: CALL 434 0 2
2473: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2474: LD_ADDR_EXP 44
2478: PUSH
2479: LD_STRING Jillian
2481: PPUSH
2482: LD_INT 0
2484: PPUSH
2485: CALL 434 0 2
2489: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2490: LD_ADDR_VAR 0 2
2494: PUSH
2495: LD_EXP 41
2499: PUSH
2500: LD_EXP 42
2504: PUSH
2505: LD_EXP 43
2509: PUSH
2510: LD_EXP 44
2514: PUSH
2515: EMPTY
2516: LIST
2517: LIST
2518: LIST
2519: LIST
2520: PUSH
2521: FOR_IN
2522: IFFALSE 2550
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2524: LD_VAR 0 2
2528: PPUSH
2529: LD_INT 3
2531: PPUSH
2532: LD_INT 0
2534: PPUSH
2535: CALL_OW 49
// ComHold ( i ) ;
2539: LD_VAR 0 2
2543: PPUSH
2544: CALL_OW 140
// end ;
2548: GO 2521
2550: POP
2551: POP
// end ;
2552: LD_VAR 0 1
2556: RET
// export function SelectGroup ; var units , selected , i ; begin
2557: LD_INT 0
2559: PPUSH
2560: PPUSH
2561: PPUSH
2562: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2563: LD_ADDR_VAR 0 2
2567: PUSH
2568: LD_EXP 31
2572: PUSH
2573: LD_INT -3
2575: PUSH
2576: EMPTY
2577: LIST
2578: LIST
2579: PUSH
2580: LD_EXP 2
2584: ADD
2585: PUSH
2586: LD_INT -2
2588: PUSH
2589: LD_INT -4
2591: PUSH
2592: LD_EXP 38
2596: PUSH
2597: LD_EXP 39
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: LIST
2606: LIST
2607: ADD
2608: PUSH
2609: LD_INT -3
2611: PUSH
2612: EMPTY
2613: LIST
2614: ADD
2615: PUSH
2616: LD_EXP 4
2620: ADD
2621: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2622: LD_ADDR_VAR 0 3
2626: PUSH
2627: LD_EXP 31
2631: PUSH
2632: LD_STRING Select five characters to go with you
2634: PPUSH
2635: LD_INT 4
2637: PPUSH
2638: LD_INT 4
2640: PPUSH
2641: LD_VAR 0 2
2645: PPUSH
2646: EMPTY
2647: PPUSH
2648: CALL_OW 42
2652: ADD
2653: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2654: LD_ADDR_EXP 4
2658: PUSH
2659: LD_EXP 2
2663: PUSH
2664: LD_EXP 4
2668: UNION
2669: PUSH
2670: LD_VAR 0 3
2674: DIFF
2675: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2676: LD_ADDR_VAR 0 4
2680: PUSH
2681: LD_EXP 4
2685: PUSH
2686: LD_EXP 39
2690: ADD
2691: PUSH
2692: FOR_IN
2693: IFFALSE 2724
// if GetSide ( i ) = 1 then
2695: LD_VAR 0 4
2699: PPUSH
2700: CALL_OW 255
2704: PUSH
2705: LD_INT 1
2707: EQUAL
2708: IFFALSE 2722
// SetSide ( i , 4 ) ;
2710: LD_VAR 0 4
2714: PPUSH
2715: LD_INT 4
2717: PPUSH
2718: CALL_OW 235
2722: GO 2692
2724: POP
2725: POP
// for i in selected do
2726: LD_ADDR_VAR 0 4
2730: PUSH
2731: LD_VAR 0 3
2735: PUSH
2736: FOR_IN
2737: IFFALSE 2768
// if GetSide ( i ) = 4 then
2739: LD_VAR 0 4
2743: PPUSH
2744: CALL_OW 255
2748: PUSH
2749: LD_INT 4
2751: EQUAL
2752: IFFALSE 2766
// SetSide ( i , 1 ) ;
2754: LD_VAR 0 4
2758: PPUSH
2759: LD_INT 1
2761: PPUSH
2762: CALL_OW 235
2766: GO 2736
2768: POP
2769: POP
// jmm_units := jmm_units diff cornel_units ;
2770: LD_ADDR_EXP 2
2774: PUSH
2775: LD_EXP 2
2779: PUSH
2780: LD_EXP 4
2784: DIFF
2785: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2786: LD_EXP 32
2790: PPUSH
2791: CALL_OW 255
2795: PUSH
2796: LD_INT 4
2798: EQUAL
2799: IFFALSE 2808
// DeleteCharacters ( Bobby ) ;
2801: LD_STRING Bobby
2803: PPUSH
2804: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2808: LD_EXP 33
2812: PPUSH
2813: CALL_OW 255
2817: PUSH
2818: LD_INT 4
2820: EQUAL
2821: IFFALSE 2830
// DeleteCharacters ( Cyrus ) ;
2823: LD_STRING Cyrus
2825: PPUSH
2826: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2830: LD_EXP 34
2834: PPUSH
2835: CALL_OW 255
2839: PUSH
2840: LD_INT 4
2842: EQUAL
2843: IFFALSE 2852
// DeleteCharacters ( Lisa ) ;
2845: LD_STRING Lisa
2847: PPUSH
2848: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2852: LD_EXP 35
2856: PPUSH
2857: CALL_OW 255
2861: PUSH
2862: LD_INT 4
2864: EQUAL
2865: IFFALSE 2874
// DeleteCharacters ( Khatam ) ;
2867: LD_STRING Khatam
2869: PPUSH
2870: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2874: LD_EXP 36
2878: PPUSH
2879: CALL_OW 255
2883: PUSH
2884: LD_INT 4
2886: EQUAL
2887: IFFALSE 2896
// DeleteCharacters ( Brian ) ;
2889: LD_STRING Brian
2891: PPUSH
2892: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2896: LD_EXP 37
2900: PPUSH
2901: CALL_OW 255
2905: PUSH
2906: LD_INT 4
2908: EQUAL
2909: IFFALSE 2918
// DeleteCharacters ( Jerry ) ;
2911: LD_STRING Jerry
2913: PPUSH
2914: CALL_OW 40
// end ; end_of_file
2918: LD_VAR 0 1
2922: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
2923: LD_INT 0
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
2930: PPUSH
2931: PPUSH
2932: PPUSH
2933: PPUSH
2934: PPUSH
2935: PPUSH
2936: PPUSH
2937: PPUSH
// ru_alert := false ;
2938: LD_ADDR_EXP 54
2942: PUSH
2943: LD_INT 0
2945: ST_TO_ADDR
// ru_produce_list := [ ] ;
2946: LD_ADDR_EXP 51
2950: PUSH
2951: EMPTY
2952: ST_TO_ADDR
// if Difficulty > 1 then
2953: LD_OWVAR 67
2957: PUSH
2958: LD_INT 1
2960: GREATER
2961: IFFALSE 3049
// begin uc_side := 3 ;
2963: LD_ADDR_OWVAR 20
2967: PUSH
2968: LD_INT 3
2970: ST_TO_ADDR
// uc_nation := 3 ;
2971: LD_ADDR_OWVAR 21
2975: PUSH
2976: LD_INT 3
2978: ST_TO_ADDR
// bc_type := b_breastwork ;
2979: LD_ADDR_OWVAR 42
2983: PUSH
2984: LD_INT 31
2986: ST_TO_ADDR
// bc_level := Difficulty ;
2987: LD_ADDR_OWVAR 43
2991: PUSH
2992: LD_OWVAR 67
2996: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
2997: LD_INT 22
2999: PPUSH
3000: LD_INT 14
3002: PPUSH
3003: LD_INT 0
3005: PPUSH
3006: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3010: LD_INT 48
3012: PPUSH
3013: LD_INT 46
3015: PPUSH
3016: LD_INT 0
3018: PPUSH
3019: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3023: LD_INT 86
3025: PPUSH
3026: LD_INT 65
3028: PPUSH
3029: LD_INT 5
3031: PPUSH
3032: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3036: LD_INT 165
3038: PPUSH
3039: LD_INT 73
3041: PPUSH
3042: LD_INT 5
3044: PPUSH
3045: CALL_OW 47
// end ; tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3049: LD_ADDR_VAR 0 7
3053: PUSH
3054: LD_INT 22
3056: PUSH
3057: LD_INT 3
3059: PUSH
3060: EMPTY
3061: LIST
3062: LIST
3063: PUSH
3064: LD_INT 2
3066: PUSH
3067: LD_INT 30
3069: PUSH
3070: LD_INT 31
3072: PUSH
3073: EMPTY
3074: LIST
3075: LIST
3076: PUSH
3077: LD_INT 30
3079: PUSH
3080: LD_INT 32
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: LIST
3091: PUSH
3092: EMPTY
3093: LIST
3094: LIST
3095: PPUSH
3096: CALL_OW 69
3100: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3101: LD_ADDR_VAR 0 8
3105: PUSH
3106: LD_INT 22
3108: PUSH
3109: LD_INT 3
3111: PUSH
3112: EMPTY
3113: LIST
3114: LIST
3115: PUSH
3116: LD_INT 30
3118: PUSH
3119: LD_INT 4
3121: PUSH
3122: EMPTY
3123: LIST
3124: LIST
3125: PUSH
3126: EMPTY
3127: LIST
3128: LIST
3129: PPUSH
3130: CALL_OW 69
3134: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3135: LD_ADDR_VAR 0 10
3139: PUSH
3140: LD_INT 22
3142: PUSH
3143: LD_INT 3
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: LD_INT 30
3152: PUSH
3153: LD_INT 3
3155: PUSH
3156: EMPTY
3157: LIST
3158: LIST
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: PPUSH
3164: CALL_OW 69
3168: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3169: LD_ADDR_VAR 0 9
3173: PUSH
3174: LD_INT 22
3176: PUSH
3177: LD_INT 3
3179: PUSH
3180: EMPTY
3181: LIST
3182: LIST
3183: PUSH
3184: LD_INT 30
3186: PUSH
3187: LD_INT 6
3189: PUSH
3190: EMPTY
3191: LIST
3192: LIST
3193: PUSH
3194: EMPTY
3195: LIST
3196: LIST
3197: PPUSH
3198: CALL_OW 69
3202: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3203: LD_ADDR_VAR 0 2
3207: PUSH
3208: LD_INT 22
3210: PUSH
3211: LD_INT 3
3213: PUSH
3214: EMPTY
3215: LIST
3216: LIST
3217: PUSH
3218: LD_INT 30
3220: PUSH
3221: LD_INT 1
3223: PUSH
3224: EMPTY
3225: LIST
3226: LIST
3227: PUSH
3228: EMPTY
3229: LIST
3230: LIST
3231: PPUSH
3232: CALL_OW 69
3236: PUSH
3237: FOR_IN
3238: IFFALSE 3282
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3240: LD_VAR 0 2
3244: PPUSH
3245: CALL_OW 274
3249: PPUSH
3250: LD_INT 1
3252: PPUSH
3253: LD_INT 5000
3255: PPUSH
3256: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3260: LD_VAR 0 2
3264: PPUSH
3265: CALL_OW 274
3269: PPUSH
3270: LD_INT 2
3272: PPUSH
3273: LD_INT 3000
3275: PPUSH
3276: CALL_OW 277
// end ;
3280: GO 3237
3282: POP
3283: POP
// uc_side := 3 ;
3284: LD_ADDR_OWVAR 20
3288: PUSH
3289: LD_INT 3
3291: ST_TO_ADDR
// uc_nation := 3 ;
3292: LD_ADDR_OWVAR 21
3296: PUSH
3297: LD_INT 3
3299: ST_TO_ADDR
// skill := [ 2 , 2 , 3 ] [ Difficulty ] ;
3300: LD_ADDR_VAR 0 11
3304: PUSH
3305: LD_INT 2
3307: PUSH
3308: LD_INT 2
3310: PUSH
3311: LD_INT 3
3313: PUSH
3314: EMPTY
3315: LIST
3316: LIST
3317: LIST
3318: PUSH
3319: LD_OWVAR 67
3323: ARRAY
3324: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3325: LD_ADDR_EXP 46
3329: PUSH
3330: LD_STRING Pokryshkin
3332: PPUSH
3333: LD_INT 0
3335: PPUSH
3336: CALL 434 0 2
3340: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3341: LD_EXP 46
3345: PPUSH
3346: LD_INT 63
3348: PPUSH
3349: LD_INT 21
3351: PPUSH
3352: LD_INT 0
3354: PPUSH
3355: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3359: LD_EXP 46
3363: PPUSH
3364: CALL_OW 140
// InitHc ;
3368: CALL_OW 19
// for i in fac do
3372: LD_ADDR_VAR 0 2
3376: PUSH
3377: LD_VAR 0 10
3381: PUSH
3382: FOR_IN
3383: IFFALSE 3436
// begin for j = 1 to 6 do
3385: LD_ADDR_VAR 0 3
3389: PUSH
3390: DOUBLE
3391: LD_INT 1
3393: DEC
3394: ST_TO_ADDR
3395: LD_INT 6
3397: PUSH
3398: FOR_TO
3399: IFFALSE 3432
// begin PrepareHuman ( false , 3 , skill ) ;
3401: LD_INT 0
3403: PPUSH
3404: LD_INT 3
3406: PPUSH
3407: LD_VAR 0 11
3411: PPUSH
3412: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3416: CALL_OW 44
3420: PPUSH
3421: LD_VAR 0 2
3425: PPUSH
3426: CALL_OW 52
// end ;
3430: GO 3398
3432: POP
3433: POP
// end ;
3434: GO 3382
3436: POP
3437: POP
// for i in lab do
3438: LD_ADDR_VAR 0 2
3442: PUSH
3443: LD_VAR 0 9
3447: PUSH
3448: FOR_IN
3449: IFFALSE 3482
// begin PrepareHuman ( false , 4 , skill ) ;
3451: LD_INT 0
3453: PPUSH
3454: LD_INT 4
3456: PPUSH
3457: LD_VAR 0 11
3461: PPUSH
3462: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3466: CALL_OW 44
3470: PPUSH
3471: LD_VAR 0 2
3475: PPUSH
3476: CALL_OW 52
// end ;
3480: GO 3448
3482: POP
3483: POP
// for i in tw do
3484: LD_ADDR_VAR 0 2
3488: PUSH
3489: LD_VAR 0 7
3493: PUSH
3494: FOR_IN
3495: IFFALSE 3544
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3497: LD_VAR 0 2
3501: PPUSH
3502: LD_INT 42
3504: PUSH
3505: LD_INT 43
3507: PUSH
3508: EMPTY
3509: LIST
3510: LIST
3511: PUSH
3512: LD_INT 1
3514: PPUSH
3515: LD_INT 2
3517: PPUSH
3518: CALL_OW 12
3522: ARRAY
3523: PPUSH
3524: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3528: LD_VAR 0 11
3532: PPUSH
3533: LD_VAR 0 2
3537: PPUSH
3538: CALL 794 0 2
// end ;
3542: GO 3494
3544: POP
3545: POP
// for i in bar do
3546: LD_ADDR_VAR 0 2
3550: PUSH
3551: LD_VAR 0 8
3555: PUSH
3556: FOR_IN
3557: IFFALSE 3590
// begin PrepareHuman ( false , 1 , skill ) ;
3559: LD_INT 0
3561: PPUSH
3562: LD_INT 1
3564: PPUSH
3565: LD_VAR 0 11
3569: PPUSH
3570: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3574: CALL_OW 44
3578: PPUSH
3579: LD_VAR 0 2
3583: PPUSH
3584: CALL_OW 52
// end ;
3588: GO 3556
3590: POP
3591: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3592: LD_ADDR_VAR 0 13
3596: PUSH
3597: LD_INT 100
3599: PUSH
3600: LD_INT 9
3602: PUSH
3603: EMPTY
3604: LIST
3605: LIST
3606: PUSH
3607: LD_INT 135
3609: PUSH
3610: LD_INT 60
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PUSH
3617: LD_INT 41
3619: PUSH
3620: LD_INT 6
3622: PUSH
3623: EMPTY
3624: LIST
3625: LIST
3626: PUSH
3627: LD_INT 22
3629: PUSH
3630: LD_INT 9
3632: PUSH
3633: EMPTY
3634: LIST
3635: LIST
3636: PUSH
3637: LD_INT 84
3639: PUSH
3640: LD_INT 14
3642: PUSH
3643: EMPTY
3644: LIST
3645: LIST
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: LIST
3651: LIST
3652: LIST
3653: ST_TO_ADDR
// vehicles := [ ] ;
3654: LD_ADDR_VAR 0 12
3658: PUSH
3659: EMPTY
3660: ST_TO_ADDR
// for i in spot_xy do
3661: LD_ADDR_VAR 0 2
3665: PUSH
3666: LD_VAR 0 13
3670: PUSH
3671: FOR_IN
3672: IFFALSE 3830
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3674: LD_ADDR_VAR 0 6
3678: PUSH
3679: LD_INT 3
3681: PPUSH
3682: LD_INT 3
3684: PPUSH
3685: LD_INT 22
3687: PPUSH
3688: LD_INT 1
3690: PPUSH
3691: LD_INT 1
3693: PPUSH
3694: LD_INT 42
3696: PUSH
3697: LD_INT 43
3699: PUSH
3700: LD_INT 44
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: LIST
3707: PUSH
3708: LD_INT 1
3710: PPUSH
3711: LD_INT 3
3713: PPUSH
3714: CALL_OW 12
3718: ARRAY
3719: PPUSH
3720: LD_INT 100
3722: PPUSH
3723: CALL 516 0 7
3727: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3728: LD_ADDR_VAR 0 12
3732: PUSH
3733: LD_VAR 0 12
3737: PPUSH
3738: LD_VAR 0 12
3742: PUSH
3743: LD_INT 1
3745: PLUS
3746: PPUSH
3747: LD_VAR 0 6
3751: PPUSH
3752: CALL_OW 2
3756: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3757: LD_VAR 0 6
3761: PPUSH
3762: LD_INT 3
3764: PPUSH
3765: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3769: LD_VAR 0 6
3773: PPUSH
3774: LD_VAR 0 2
3778: PUSH
3779: LD_INT 1
3781: ARRAY
3782: PPUSH
3783: LD_VAR 0 2
3787: PUSH
3788: LD_INT 2
3790: ARRAY
3791: PPUSH
3792: LD_INT 0
3794: PPUSH
3795: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3799: LD_INT 0
3801: PPUSH
3802: LD_INT 3
3804: PPUSH
3805: LD_VAR 0 11
3809: PPUSH
3810: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3814: CALL_OW 44
3818: PPUSH
3819: LD_VAR 0 6
3823: PPUSH
3824: CALL_OW 52
// end ;
3828: GO 3671
3830: POP
3831: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3832: LD_ADDR_VAR 0 2
3836: PUSH
3837: DOUBLE
3838: LD_INT 1
3840: DEC
3841: ST_TO_ADDR
3842: LD_INT 5
3844: PUSH
3845: LD_INT 7
3847: PUSH
3848: LD_INT 8
3850: PUSH
3851: EMPTY
3852: LIST
3853: LIST
3854: LIST
3855: PUSH
3856: LD_OWVAR 67
3860: ARRAY
3861: PUSH
3862: FOR_TO
3863: IFFALSE 3923
// begin PrepareHuman ( false , 1 , skill ) ;
3865: LD_INT 0
3867: PPUSH
3868: LD_INT 1
3870: PPUSH
3871: LD_VAR 0 11
3875: PPUSH
3876: CALL_OW 380
// un := CreateHuman ;
3880: LD_ADDR_VAR 0 5
3884: PUSH
3885: CALL_OW 44
3889: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3890: LD_VAR 0 5
3894: PPUSH
3895: LD_INT 11
3897: PPUSH
3898: LD_INT 0
3900: PPUSH
3901: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3905: LD_ADDR_EXP 49
3909: PUSH
3910: LD_EXP 49
3914: PUSH
3915: LD_VAR 0 5
3919: ADD
3920: ST_TO_ADDR
// end ;
3921: GO 3862
3923: POP
3924: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3925: LD_ADDR_VAR 0 2
3929: PUSH
3930: DOUBLE
3931: LD_INT 1
3933: DEC
3934: ST_TO_ADDR
3935: LD_INT 2
3937: PUSH
3938: LD_INT 3
3940: PUSH
3941: LD_INT 4
3943: PUSH
3944: EMPTY
3945: LIST
3946: LIST
3947: LIST
3948: PUSH
3949: LD_OWVAR 67
3953: ARRAY
3954: PUSH
3955: FOR_TO
3956: IFFALSE 4016
// begin PrepareHuman ( false , 1 , skill ) ;
3958: LD_INT 0
3960: PPUSH
3961: LD_INT 1
3963: PPUSH
3964: LD_VAR 0 11
3968: PPUSH
3969: CALL_OW 380
// un := CreateHuman ;
3973: LD_ADDR_VAR 0 5
3977: PUSH
3978: CALL_OW 44
3982: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
3983: LD_VAR 0 5
3987: PPUSH
3988: LD_INT 12
3990: PPUSH
3991: LD_INT 0
3993: PPUSH
3994: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
3998: LD_ADDR_EXP 47
4002: PUSH
4003: LD_EXP 47
4007: PUSH
4008: LD_VAR 0 5
4012: ADD
4013: ST_TO_ADDR
// end ;
4014: GO 3955
4016: POP
4017: POP
// for i = 1 to 2 do
4018: LD_ADDR_VAR 0 2
4022: PUSH
4023: DOUBLE
4024: LD_INT 1
4026: DEC
4027: ST_TO_ADDR
4028: LD_INT 2
4030: PUSH
4031: FOR_TO
4032: IFFALSE 4098
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4034: LD_INT 1
4036: PPUSH
4037: LD_INT 1
4039: PPUSH
4040: LD_VAR 0 11
4044: PPUSH
4045: CALL_OW 380
// un := CreateHuman ;
4049: LD_ADDR_VAR 0 5
4053: PUSH
4054: CALL_OW 44
4058: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4059: LD_VAR 0 5
4063: PPUSH
4064: LD_INT 39
4066: PPUSH
4067: LD_INT 12
4069: PPUSH
4070: LD_INT 3
4072: PPUSH
4073: LD_INT 0
4075: PPUSH
4076: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4080: LD_ADDR_EXP 48
4084: PUSH
4085: LD_EXP 48
4089: PUSH
4090: LD_VAR 0 5
4094: ADD
4095: ST_TO_ADDR
// end ;
4096: GO 4031
4098: POP
4099: POP
// for i = 1 to 3 do
4100: LD_ADDR_VAR 0 2
4104: PUSH
4105: DOUBLE
4106: LD_INT 1
4108: DEC
4109: ST_TO_ADDR
4110: LD_INT 3
4112: PUSH
4113: FOR_TO
4114: IFFALSE 4180
// begin PrepareHuman ( false , 1 , skill ) ;
4116: LD_INT 0
4118: PPUSH
4119: LD_INT 1
4121: PPUSH
4122: LD_VAR 0 11
4126: PPUSH
4127: CALL_OW 380
// un := CreateHuman ;
4131: LD_ADDR_VAR 0 5
4135: PUSH
4136: CALL_OW 44
4140: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4141: LD_VAR 0 5
4145: PPUSH
4146: LD_INT 180
4148: PPUSH
4149: LD_INT 11
4151: PPUSH
4152: LD_INT 4
4154: PPUSH
4155: LD_INT 0
4157: PPUSH
4158: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4162: LD_ADDR_EXP 52
4166: PUSH
4167: LD_EXP 52
4171: PUSH
4172: LD_VAR 0 5
4176: ADD
4177: ST_TO_ADDR
// end ;
4178: GO 4113
4180: POP
4181: POP
// ru_vehicles := vehicles ;
4182: LD_ADDR_EXP 50
4186: PUSH
4187: LD_VAR 0 12
4191: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4192: LD_ADDR_EXP 53
4196: PUSH
4197: LD_INT 131
4199: PUSH
4200: LD_INT 121
4202: PUSH
4203: EMPTY
4204: LIST
4205: LIST
4206: PUSH
4207: LD_INT 113
4209: PUSH
4210: LD_INT 90
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: PUSH
4217: LD_INT 93
4219: PUSH
4220: LD_INT 62
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 106
4234: PUSH
4235: LD_INT 54
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 120
4244: PUSH
4245: LD_INT 80
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: LD_INT 143
4254: PUSH
4255: LD_INT 120
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: LIST
4266: PUSH
4267: LD_INT 154
4269: PUSH
4270: LD_INT 116
4272: PUSH
4273: EMPTY
4274: LIST
4275: LIST
4276: PUSH
4277: LD_INT 140
4279: PUSH
4280: LD_INT 93
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PUSH
4287: LD_INT 130
4289: PUSH
4290: LD_INT 58
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: PUSH
4297: EMPTY
4298: LIST
4299: LIST
4300: LIST
4301: PUSH
4302: LD_INT 105
4304: PUSH
4305: LD_INT 106
4307: PUSH
4308: EMPTY
4309: LIST
4310: LIST
4311: PUSH
4312: LD_INT 134
4314: PUSH
4315: LD_INT 98
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: PUSH
4322: LD_INT 159
4324: PUSH
4325: LD_INT 113
4327: PUSH
4328: EMPTY
4329: LIST
4330: LIST
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: LIST
4336: PUSH
4337: EMPTY
4338: LIST
4339: LIST
4340: LIST
4341: LIST
4342: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4343: LD_ADDR_VAR 0 2
4347: PUSH
4348: DOUBLE
4349: LD_INT 1
4351: DEC
4352: ST_TO_ADDR
4353: LD_OWVAR 67
4357: PUSH
4358: LD_INT 1
4360: MINUS
4361: PUSH
4362: FOR_TO
4363: IFFALSE 4396
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4365: LD_ADDR_EXP 51
4369: PUSH
4370: LD_EXP 51
4374: PUSH
4375: LD_INT 22
4377: PUSH
4378: LD_INT 1
4380: PUSH
4381: LD_INT 1
4383: PUSH
4384: LD_INT 43
4386: PUSH
4387: EMPTY
4388: LIST
4389: LIST
4390: LIST
4391: LIST
4392: ADD
4393: ST_TO_ADDR
4394: GO 4362
4396: POP
4397: POP
// end ;
4398: LD_VAR 0 1
4402: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4403: LD_INT 22
4405: PUSH
4406: LD_INT 3
4408: PUSH
4409: EMPTY
4410: LIST
4411: LIST
4412: PUSH
4413: LD_INT 21
4415: PUSH
4416: LD_INT 2
4418: PUSH
4419: EMPTY
4420: LIST
4421: LIST
4422: PUSH
4423: EMPTY
4424: LIST
4425: LIST
4426: PPUSH
4427: CALL_OW 69
4431: IFFALSE 4525
4433: GO 4435
4435: DISABLE
4436: LD_INT 0
4438: PPUSH
4439: PPUSH
// begin enable ;
4440: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4441: LD_ADDR_VAR 0 2
4445: PUSH
4446: LD_INT 22
4448: PUSH
4449: LD_INT 3
4451: PUSH
4452: EMPTY
4453: LIST
4454: LIST
4455: PUSH
4456: LD_INT 21
4458: PUSH
4459: LD_INT 2
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PUSH
4466: EMPTY
4467: LIST
4468: LIST
4469: PPUSH
4470: CALL_OW 69
4474: ST_TO_ADDR
// if filter then
4475: LD_VAR 0 2
4479: IFFALSE 4525
// for i in filter do
4481: LD_ADDR_VAR 0 1
4485: PUSH
4486: LD_VAR 0 2
4490: PUSH
4491: FOR_IN
4492: IFFALSE 4523
// if GetFuel ( i ) < 20 then
4494: LD_VAR 0 1
4498: PPUSH
4499: CALL_OW 261
4503: PUSH
4504: LD_INT 20
4506: LESS
4507: IFFALSE 4521
// SetFuel ( i , 20 ) ;
4509: LD_VAR 0 1
4513: PPUSH
4514: LD_INT 20
4516: PPUSH
4517: CALL_OW 240
4521: GO 4491
4523: POP
4524: POP
// end ;
4525: PPOPN 2
4527: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4528: LD_EXP 51
4532: IFFALSE 4751
4534: GO 4536
4536: DISABLE
4537: LD_INT 0
4539: PPUSH
4540: PPUSH
4541: PPUSH
// begin enable ;
4542: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4543: LD_ADDR_VAR 0 2
4547: PUSH
4548: LD_INT 22
4550: PUSH
4551: LD_INT 3
4553: PUSH
4554: EMPTY
4555: LIST
4556: LIST
4557: PUSH
4558: LD_INT 30
4560: PUSH
4561: LD_INT 3
4563: PUSH
4564: EMPTY
4565: LIST
4566: LIST
4567: PUSH
4568: EMPTY
4569: LIST
4570: LIST
4571: PPUSH
4572: CALL_OW 69
4576: ST_TO_ADDR
// can_produce := [ ] ;
4577: LD_ADDR_VAR 0 3
4581: PUSH
4582: EMPTY
4583: ST_TO_ADDR
// if not fac then
4584: LD_VAR 0 2
4588: NOT
4589: IFFALSE 4594
// begin disable ;
4591: DISABLE
// exit ;
4592: GO 4751
// end ; for i in fac do
4594: LD_ADDR_VAR 0 1
4598: PUSH
4599: LD_VAR 0 2
4603: PUSH
4604: FOR_IN
4605: IFFALSE 4643
// if UnitsInside ( i ) then
4607: LD_VAR 0 1
4611: PPUSH
4612: CALL_OW 313
4616: IFFALSE 4641
// can_produce := Insert ( can_produce , 1 , i ) ;
4618: LD_ADDR_VAR 0 3
4622: PUSH
4623: LD_VAR 0 3
4627: PPUSH
4628: LD_INT 1
4630: PPUSH
4631: LD_VAR 0 1
4635: PPUSH
4636: CALL_OW 2
4640: ST_TO_ADDR
4641: GO 4604
4643: POP
4644: POP
// if not can_produce then
4645: LD_VAR 0 3
4649: NOT
4650: IFFALSE 4654
// exit ;
4652: GO 4751
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4654: LD_VAR 0 3
4658: PUSH
4659: LD_INT 1
4661: PPUSH
4662: LD_VAR 0 3
4666: PPUSH
4667: CALL_OW 12
4671: ARRAY
4672: PPUSH
4673: LD_EXP 51
4677: PUSH
4678: LD_INT 1
4680: ARRAY
4681: PPUSH
4682: LD_EXP 51
4686: PUSH
4687: LD_INT 2
4689: ARRAY
4690: PPUSH
4691: LD_EXP 51
4695: PUSH
4696: LD_INT 3
4698: ARRAY
4699: PPUSH
4700: LD_EXP 51
4704: PUSH
4705: LD_INT 4
4707: ARRAY
4708: PPUSH
4709: CALL_OW 125
// for i = 1 to 4 do
4713: LD_ADDR_VAR 0 1
4717: PUSH
4718: DOUBLE
4719: LD_INT 1
4721: DEC
4722: ST_TO_ADDR
4723: LD_INT 4
4725: PUSH
4726: FOR_TO
4727: IFFALSE 4749
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4729: LD_ADDR_EXP 51
4733: PUSH
4734: LD_EXP 51
4738: PPUSH
4739: LD_INT 1
4741: PPUSH
4742: CALL_OW 3
4746: ST_TO_ADDR
4747: GO 4726
4749: POP
4750: POP
// end ;
4751: PPOPN 3
4753: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4754: LD_INT 0
4756: PPUSH
4757: PPUSH
4758: PPUSH
// for i = 1 to 6 do
4759: LD_ADDR_VAR 0 2
4763: PUSH
4764: DOUBLE
4765: LD_INT 1
4767: DEC
4768: ST_TO_ADDR
4769: LD_INT 6
4771: PUSH
4772: FOR_TO
4773: IFFALSE 4922
// begin PrepareHuman ( false , 3 , 3 ) ;
4775: LD_INT 0
4777: PPUSH
4778: LD_INT 3
4780: PPUSH
4781: LD_INT 3
4783: PPUSH
4784: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4788: LD_ADDR_VAR 0 3
4792: PUSH
4793: LD_INT 3
4795: PPUSH
4796: LD_INT 3
4798: PPUSH
4799: LD_INT 22
4801: PPUSH
4802: LD_INT 1
4804: PPUSH
4805: LD_INT 1
4807: PPUSH
4808: LD_INT 43
4810: PUSH
4811: LD_INT 42
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 1
4820: PPUSH
4821: LD_INT 2
4823: PPUSH
4824: CALL_OW 12
4828: ARRAY
4829: PPUSH
4830: LD_INT 70
4832: PPUSH
4833: CALL 516 0 7
4837: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4838: LD_VAR 0 3
4842: PPUSH
4843: LD_INT 4
4845: PPUSH
4846: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4850: LD_VAR 0 3
4854: PPUSH
4855: LD_INT 229
4857: PPUSH
4858: LD_INT 44
4860: PPUSH
4861: LD_INT 0
4863: PPUSH
4864: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4868: CALL_OW 44
4872: PPUSH
4873: LD_VAR 0 3
4877: PPUSH
4878: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4882: LD_ADDR_EXP 50
4886: PUSH
4887: LD_EXP 50
4891: PUSH
4892: LD_VAR 0 3
4896: ADD
4897: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
4898: LD_VAR 0 3
4902: PPUSH
4903: LD_INT 191
4905: PPUSH
4906: LD_INT 32
4908: PPUSH
4909: CALL_OW 111
// Wait ( 0 0$02 ) ;
4913: LD_INT 70
4915: PPUSH
4916: CALL_OW 67
// end ;
4920: GO 4772
4922: POP
4923: POP
// end ; end_of_file
4924: LD_VAR 0 1
4928: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
4929: LD_INT 0
4931: PPUSH
4932: PPUSH
4933: PPUSH
4934: PPUSH
4935: PPUSH
4936: PPUSH
4937: PPUSH
// InGameOn ;
4938: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
4942: LD_EXP 31
4946: PPUSH
4947: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
4951: LD_EXP 31
4955: PPUSH
4956: LD_EXP 38
4960: PPUSH
4961: CALL_OW 119
// if Bierezov then
4965: LD_EXP 39
4969: IFFALSE 4985
// ComTurnUnit ( Bierezov , Cornel ) ;
4971: LD_EXP 39
4975: PPUSH
4976: LD_EXP 38
4980: PPUSH
4981: CALL_OW 119
// for i in jmm_units do
4985: LD_ADDR_VAR 0 2
4989: PUSH
4990: LD_EXP 2
4994: PUSH
4995: FOR_IN
4996: IFFALSE 5014
// ComTurnUnit ( i , Cornel ) ;
4998: LD_VAR 0 2
5002: PPUSH
5003: LD_EXP 38
5007: PPUSH
5008: CALL_OW 119
5012: GO 4995
5014: POP
5015: POP
// units := cornel_units union Cornel ;
5016: LD_ADDR_VAR 0 3
5020: PUSH
5021: LD_EXP 4
5025: PUSH
5026: LD_EXP 38
5030: UNION
5031: ST_TO_ADDR
// repeat wait ( 1 ) ;
5032: LD_INT 1
5034: PPUSH
5035: CALL_OW 67
// for i in units do
5039: LD_ADDR_VAR 0 2
5043: PUSH
5044: LD_VAR 0 3
5048: PUSH
5049: FOR_IN
5050: IFFALSE 5083
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5052: LD_VAR 0 2
5056: PPUSH
5057: LD_EXP 31
5061: PPUSH
5062: CALL_OW 250
5066: PPUSH
5067: LD_EXP 31
5071: PPUSH
5072: CALL_OW 251
5076: PPUSH
5077: CALL_OW 111
5081: GO 5049
5083: POP
5084: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5085: LD_VAR 0 3
5089: PPUSH
5090: LD_INT 92
5092: PUSH
5093: LD_EXP 31
5097: PPUSH
5098: CALL_OW 250
5102: PUSH
5103: LD_EXP 31
5107: PPUSH
5108: CALL_OW 251
5112: PUSH
5113: LD_INT 10
5115: PUSH
5116: EMPTY
5117: LIST
5118: LIST
5119: LIST
5120: LIST
5121: PPUSH
5122: CALL_OW 72
5126: PUSH
5127: LD_VAR 0 3
5131: EQUAL
5132: IFFALSE 5032
// for i in units do
5134: LD_ADDR_VAR 0 2
5138: PUSH
5139: LD_VAR 0 3
5143: PUSH
5144: FOR_IN
5145: IFFALSE 5163
// ComTurnUnit ( i , JMM ) ;
5147: LD_VAR 0 2
5151: PPUSH
5152: LD_EXP 31
5156: PPUSH
5157: CALL_OW 119
5161: GO 5144
5163: POP
5164: POP
// ComTurnUnit ( Cornel , JMM ) ;
5165: LD_EXP 38
5169: PPUSH
5170: LD_EXP 31
5174: PPUSH
5175: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5179: LD_EXP 31
5183: PPUSH
5184: LD_STRING D1-JMM-1
5186: PPUSH
5187: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5191: LD_EXP 38
5195: PPUSH
5196: LD_STRING D1-Corn-1
5198: PPUSH
5199: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5203: LD_EXP 31
5207: PPUSH
5208: LD_EXP 38
5212: PPUSH
5213: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5217: LD_EXP 38
5221: PPUSH
5222: LD_EXP 31
5226: PPUSH
5227: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5231: LD_INT 35
5233: PPUSH
5234: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5238: LD_EXP 31
5242: PPUSH
5243: LD_EXP 38
5247: PPUSH
5248: CALL_OW 296
5252: PUSH
5253: LD_INT 6
5255: LESS
5256: IFFALSE 5231
// ChangeSideFog ( 4 , 1 ) ;
5258: LD_INT 4
5260: PPUSH
5261: LD_INT 1
5263: PPUSH
5264: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5268: LD_EXP 31
5272: PPUSH
5273: LD_EXP 38
5277: PPUSH
5278: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5282: LD_EXP 38
5286: PPUSH
5287: LD_EXP 31
5291: PPUSH
5292: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5296: LD_EXP 31
5300: PPUSH
5301: LD_STRING D1-JMM-2
5303: PPUSH
5304: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5308: LD_EXP 31
5312: PPUSH
5313: LD_STRING D1-JMM-2a
5315: PPUSH
5316: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5320: LD_EXP 38
5324: PPUSH
5325: LD_STRING D1-Corn-2
5327: PPUSH
5328: CALL_OW 88
// if bierezov_exist or debug then
5332: LD_EXP 5
5336: PUSH
5337: LD_EXP 1
5341: OR
5342: IFFALSE 5583
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5344: LD_EXP 38
5348: PPUSH
5349: LD_EXP 39
5353: PPUSH
5354: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5358: LD_INT 10
5360: PPUSH
5361: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5365: LD_EXP 38
5369: PPUSH
5370: LD_STRING D1a-Corn-1
5372: PPUSH
5373: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5377: LD_EXP 31
5381: PPUSH
5382: LD_EXP 39
5386: PPUSH
5387: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5391: LD_EXP 39
5395: PPUSH
5396: LD_EXP 31
5400: PPUSH
5401: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5405: LD_EXP 31
5409: PPUSH
5410: LD_STRING D1a-JMM-1
5412: PPUSH
5413: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5417: LD_EXP 31
5421: PPUSH
5422: LD_EXP 38
5426: PPUSH
5427: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5431: LD_EXP 38
5435: PPUSH
5436: LD_EXP 31
5440: PPUSH
5441: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5445: LD_EXP 38
5449: PPUSH
5450: LD_STRING D1a-Corn-2
5452: PPUSH
5453: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5457: LD_EXP 31
5461: PPUSH
5462: LD_STRING D1a-JMM-2
5464: PPUSH
5465: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5469: LD_EXP 38
5473: PPUSH
5474: LD_STRING D1a-Corn-3
5476: PPUSH
5477: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5481: LD_EXP 31
5485: PPUSH
5486: LD_STRING D1a-JMM-3
5488: PPUSH
5489: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5493: LD_EXP 38
5497: PPUSH
5498: LD_STRING D1a-Corn-4
5500: PPUSH
5501: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5505: LD_EXP 31
5509: PPUSH
5510: LD_STRING D1a-JMM-4
5512: PPUSH
5513: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5517: LD_EXP 38
5521: PPUSH
5522: LD_STRING D1a-Corn-5
5524: PPUSH
5525: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5529: LD_EXP 39
5533: PPUSH
5534: LD_EXP 38
5538: PPUSH
5539: CALL_OW 250
5543: PPUSH
5544: LD_EXP 38
5548: PPUSH
5549: CALL_OW 251
5553: PUSH
5554: LD_INT 2
5556: MINUS
5557: PPUSH
5558: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5562: LD_EXP 39
5566: PPUSH
5567: LD_EXP 38
5571: PPUSH
5572: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5576: LD_INT 10
5578: PPUSH
5579: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5583: LD_EXP 31
5587: PPUSH
5588: LD_STRING D1b-JMM-1
5590: PPUSH
5591: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5595: LD_EXP 38
5599: PPUSH
5600: LD_STRING D1b-Corn-1
5602: PPUSH
5603: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5607: LD_EXP 31
5611: PPUSH
5612: LD_STRING D1b-JMM-2
5614: PPUSH
5615: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5619: LD_EXP 38
5623: PPUSH
5624: LD_STRING D1b-Corn-2
5626: PPUSH
5627: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5631: LD_EXP 31
5635: PPUSH
5636: LD_STRING D1b-JMM-3
5638: PPUSH
5639: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5643: LD_INT 10
5645: PPUSH
5646: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5650: LD_EXP 40
5654: PPUSH
5655: LD_STRING D1b-Pow-3
5657: PPUSH
5658: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5662: LD_EXP 31
5666: PPUSH
5667: LD_STRING D1b-JMM-4
5669: PPUSH
5670: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5674: LD_EXP 38
5678: PPUSH
5679: LD_STRING D1b-Corn-4
5681: PPUSH
5682: CALL_OW 88
// if Khatam then
5686: LD_EXP 35
5690: IFFALSE 5706
// Say ( Khatam , D1b-Khat-4 ) else
5692: LD_EXP 35
5696: PPUSH
5697: LD_STRING D1b-Khat-4
5699: PPUSH
5700: CALL_OW 88
5704: GO 5742
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
5706: LD_EXP 4
5710: PPUSH
5711: LD_INT 26
5713: PUSH
5714: LD_INT 1
5716: PUSH
5717: EMPTY
5718: LIST
5719: LIST
5720: PPUSH
5721: CALL_OW 72
5725: PUSH
5726: LD_EXP 38
5730: PUSH
5731: EMPTY
5732: LIST
5733: DIFF
5734: PPUSH
5735: LD_STRING D1b-Sol1-4
5737: PPUSH
5738: CALL 604 0 2
// if Cyrus then
5742: LD_EXP 33
5746: IFFALSE 5760
// Say ( Cyrus , D1b-Cyrus-4 ) ;
5748: LD_EXP 33
5752: PPUSH
5753: LD_STRING D1b-Cyrus-4
5755: PPUSH
5756: CALL_OW 88
// if Lisa then
5760: LD_EXP 34
5764: IFFALSE 5822
// begin Say ( Lisa , D1b-Lisa-4 ) ;
5766: LD_EXP 34
5770: PPUSH
5771: LD_STRING D1b-Lisa-4
5773: PPUSH
5774: CALL_OW 88
// if Cyrus then
5778: LD_EXP 33
5782: IFFALSE 5822
// begin if not IsInUnit ( Cyrus ) then
5784: LD_EXP 33
5788: PPUSH
5789: CALL_OW 310
5793: NOT
5794: IFFALSE 5810
// ComTurnUnit ( Cyrus , Lisa ) ;
5796: LD_EXP 33
5800: PPUSH
5801: LD_EXP 34
5805: PPUSH
5806: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
5810: LD_EXP 33
5814: PPUSH
5815: LD_STRING D1b-Cyrus-5
5817: PPUSH
5818: CALL_OW 88
// end ; end ; SelectGroup ;
5822: CALL 2557 0 0
// Say ( JMM , D1d-JMM-1 ) ;
5826: LD_EXP 31
5830: PPUSH
5831: LD_STRING D1d-JMM-1
5833: PPUSH
5834: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
5838: LD_EXP 38
5842: PPUSH
5843: LD_STRING D1d-Corn-1
5845: PPUSH
5846: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
5850: LD_ADDR_VAR 0 2
5854: PUSH
5855: LD_EXP 2
5859: PUSH
5860: LD_EXP 4
5864: ADD
5865: PUSH
5866: LD_EXP 31
5870: ADD
5871: PUSH
5872: FOR_IN
5873: IFFALSE 5886
// ComHold ( i ) ;
5875: LD_VAR 0 2
5879: PPUSH
5880: CALL_OW 140
5884: GO 5872
5886: POP
5887: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
5888: LD_ADDR_VAR 0 4
5892: PUSH
5893: LD_INT 22
5895: PUSH
5896: LD_INT 1
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: PUSH
5903: LD_INT 21
5905: PUSH
5906: LD_INT 2
5908: PUSH
5909: EMPTY
5910: LIST
5911: LIST
5912: PUSH
5913: EMPTY
5914: LIST
5915: LIST
5916: PPUSH
5917: CALL_OW 69
5921: ST_TO_ADDR
// if vehicles then
5922: LD_VAR 0 4
5926: IFFALSE 6264
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
5928: LD_EXP 4
5932: PPUSH
5933: LD_INT 55
5935: PUSH
5936: EMPTY
5937: LIST
5938: PPUSH
5939: CALL_OW 72
5943: IFFALSE 5982
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
5945: LD_ADDR_VAR 0 2
5949: PUSH
5950: LD_EXP 4
5954: PPUSH
5955: LD_INT 55
5957: PUSH
5958: EMPTY
5959: LIST
5960: PPUSH
5961: CALL_OW 72
5965: PUSH
5966: FOR_IN
5967: IFFALSE 5980
// ComExitVehicle ( i ) ;
5969: LD_VAR 0 2
5973: PPUSH
5974: CALL_OW 121
5978: GO 5966
5980: POP
5981: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
5982: LD_ADDR_VAR 0 5
5986: PUSH
5987: LD_VAR 0 4
5991: PPUSH
5992: LD_INT 34
5994: PUSH
5995: LD_INT 51
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: PPUSH
6002: CALL_OW 72
6006: ST_TO_ADDR
// if cargos then
6007: LD_VAR 0 5
6011: IFFALSE 6194
// begin vehicles := cargos ;
6013: LD_ADDR_VAR 0 4
6017: PUSH
6018: LD_VAR 0 5
6022: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6023: LD_ADDR_VAR 0 6
6027: PUSH
6028: LD_STRING 02_resources_4
6030: PPUSH
6031: LD_INT 0
6033: PPUSH
6034: CALL_OW 30
6038: ST_TO_ADDR
// if debug and not resources then
6039: LD_EXP 1
6043: PUSH
6044: LD_VAR 0 6
6048: NOT
6049: AND
6050: IFFALSE 6060
// resources := 160 ;
6052: LD_ADDR_VAR 0 6
6056: PUSH
6057: LD_INT 160
6059: ST_TO_ADDR
// if resources mod 10 then
6060: LD_VAR 0 6
6064: PUSH
6065: LD_INT 10
6067: MOD
6068: IFFALSE 6090
// resources := resources - resources mod 10 ;
6070: LD_ADDR_VAR 0 6
6074: PUSH
6075: LD_VAR 0 6
6079: PUSH
6080: LD_VAR 0 6
6084: PUSH
6085: LD_INT 10
6087: MOD
6088: MINUS
6089: ST_TO_ADDR
// if resources then
6090: LD_VAR 0 6
6094: IFFALSE 6194
// for i in cargos do
6096: LD_ADDR_VAR 0 2
6100: PUSH
6101: LD_VAR 0 5
6105: PUSH
6106: FOR_IN
6107: IFFALSE 6192
// begin if resources < 100 then
6109: LD_VAR 0 6
6113: PUSH
6114: LD_INT 100
6116: LESS
6117: IFFALSE 6139
// begin cargo := resources ;
6119: LD_ADDR_VAR 0 7
6123: PUSH
6124: LD_VAR 0 6
6128: ST_TO_ADDR
// resources := 0 ;
6129: LD_ADDR_VAR 0 6
6133: PUSH
6134: LD_INT 0
6136: ST_TO_ADDR
// end else
6137: GO 6161
// begin cargo := 100 ;
6139: LD_ADDR_VAR 0 7
6143: PUSH
6144: LD_INT 100
6146: ST_TO_ADDR
// resources := resources - 100 ;
6147: LD_ADDR_VAR 0 6
6151: PUSH
6152: LD_VAR 0 6
6156: PUSH
6157: LD_INT 100
6159: MINUS
6160: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6161: LD_VAR 0 2
6165: PPUSH
6166: LD_INT 1
6168: PPUSH
6169: LD_VAR 0 7
6173: PPUSH
6174: CALL_OW 290
// if resources = 0 then
6178: LD_VAR 0 6
6182: PUSH
6183: LD_INT 0
6185: EQUAL
6186: IFFALSE 6190
// break ;
6188: GO 6192
// end ;
6190: GO 6106
6192: POP
6193: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6194: LD_VAR 0 4
6198: PUSH
6199: LD_INT 1
6201: ARRAY
6202: PPUSH
6203: CALL_OW 311
6207: PPUSH
6208: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6212: LD_VAR 0 4
6216: PUSH
6217: LD_INT 1
6219: ARRAY
6220: PPUSH
6221: LD_INT 4
6223: PPUSH
6224: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6228: LD_EXP 38
6232: PPUSH
6233: LD_VAR 0 4
6237: PUSH
6238: LD_INT 1
6240: ARRAY
6241: PPUSH
6242: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6246: LD_INT 35
6248: PPUSH
6249: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6253: LD_EXP 38
6257: PPUSH
6258: CALL_OW 310
6262: IFFALSE 6246
// end ; InGameOff ;
6264: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6268: LD_STRING M1
6270: PPUSH
6271: CALL_OW 337
// SaveForQuickRestart ;
6275: CALL_OW 22
// cornel_active := true ;
6279: LD_ADDR_EXP 6
6283: PUSH
6284: LD_INT 1
6286: ST_TO_ADDR
// end ;
6287: LD_VAR 0 1
6291: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
6292: LD_EXP 31
6296: PPUSH
6297: LD_EXP 41
6301: PPUSH
6302: CALL_OW 296
6306: PUSH
6307: LD_INT 10
6309: LESS
6310: IFFALSE 7452
6312: GO 6314
6314: DISABLE
6315: LD_INT 0
6317: PPUSH
6318: PPUSH
6319: PPUSH
6320: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6321: LD_ADDR_VAR 0 2
6325: PUSH
6326: LD_INT 89
6328: PUSH
6329: LD_INT 34
6331: PUSH
6332: EMPTY
6333: LIST
6334: LIST
6335: PUSH
6336: LD_INT 138
6338: PUSH
6339: LD_INT 63
6341: PUSH
6342: EMPTY
6343: LIST
6344: LIST
6345: PUSH
6346: LD_INT 196
6348: PUSH
6349: LD_INT 84
6351: PUSH
6352: EMPTY
6353: LIST
6354: LIST
6355: PUSH
6356: LD_INT 135
6358: PUSH
6359: LD_INT 52
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: PUSH
6366: LD_INT 103
6368: PUSH
6369: LD_INT 39
6371: PUSH
6372: EMPTY
6373: LIST
6374: LIST
6375: PUSH
6376: LD_INT 58
6378: PUSH
6379: LD_INT 30
6381: PUSH
6382: EMPTY
6383: LIST
6384: LIST
6385: PUSH
6386: LD_INT 38
6388: PUSH
6389: LD_INT 51
6391: PUSH
6392: EMPTY
6393: LIST
6394: LIST
6395: PUSH
6396: EMPTY
6397: LIST
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: LIST
6403: LIST
6404: ST_TO_ADDR
// InGameOn ;
6405: CALL_OW 8
// if jmm_units then
6409: LD_EXP 2
6413: IFFALSE 6477
// for i in jmm_units do
6415: LD_ADDR_VAR 0 1
6419: PUSH
6420: LD_EXP 2
6424: PUSH
6425: FOR_IN
6426: IFFALSE 6475
// begin if GetDistUnits ( i , JMM ) < 10 then
6428: LD_VAR 0 1
6432: PPUSH
6433: LD_EXP 31
6437: PPUSH
6438: CALL_OW 296
6442: PUSH
6443: LD_INT 10
6445: LESS
6446: IFFALSE 6464
// ComTurnUnit ( i , JMM ) else
6448: LD_VAR 0 1
6452: PPUSH
6453: LD_EXP 31
6457: PPUSH
6458: CALL_OW 119
6462: GO 6473
// ComHold ( i ) ;
6464: LD_VAR 0 1
6468: PPUSH
6469: CALL_OW 140
// end ;
6473: GO 6425
6475: POP
6476: POP
// if IsInUnit ( JMM ) then
6477: LD_EXP 31
6481: PPUSH
6482: CALL_OW 310
6486: IFFALSE 6497
// ComExitVehicle ( JMM ) ;
6488: LD_EXP 31
6492: PPUSH
6493: CALL_OW 121
// Wait ( 10 ) ;
6497: LD_INT 10
6499: PPUSH
6500: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6504: LD_EXP 31
6508: PPUSH
6509: LD_EXP 41
6513: PPUSH
6514: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6518: LD_INT 35
6520: PPUSH
6521: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6525: LD_EXP 31
6529: PPUSH
6530: LD_EXP 41
6534: PPUSH
6535: CALL_OW 296
6539: PUSH
6540: LD_INT 6
6542: LESS
6543: IFFALSE 6518
// ComTurnUnit ( JMM , Lynch ) ;
6545: LD_EXP 31
6549: PPUSH
6550: LD_EXP 41
6554: PPUSH
6555: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6559: LD_ADDR_VAR 0 1
6563: PUSH
6564: LD_EXP 41
6568: PUSH
6569: LD_EXP 42
6573: PUSH
6574: LD_EXP 43
6578: PUSH
6579: LD_EXP 44
6583: PUSH
6584: EMPTY
6585: LIST
6586: LIST
6587: LIST
6588: LIST
6589: PUSH
6590: FOR_IN
6591: IFFALSE 6609
// ComTurnUnit ( i , JMM ) ;
6593: LD_VAR 0 1
6597: PPUSH
6598: LD_EXP 31
6602: PPUSH
6603: CALL_OW 119
6607: GO 6590
6609: POP
6610: POP
// Wait ( 0 0$0.3 ) ;
6611: LD_INT 10
6613: PPUSH
6614: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6618: LD_EXP 31
6622: PPUSH
6623: LD_STRING D2-JMM-1
6625: PPUSH
6626: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6630: LD_EXP 41
6634: PPUSH
6635: LD_STRING D2-Sol1-1
6637: PPUSH
6638: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6642: LD_EXP 31
6646: PPUSH
6647: LD_STRING D2-JMM-2
6649: PPUSH
6650: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6654: LD_EXP 41
6658: PPUSH
6659: LD_STRING D2-Sol1-2
6661: PPUSH
6662: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6666: LD_EXP 31
6670: PPUSH
6671: LD_STRING D2-JMM-3
6673: PPUSH
6674: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
6678: LD_EXP 41
6682: PPUSH
6683: LD_STRING D2-Sol1-3
6685: PPUSH
6686: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6690: LD_ADDR_VAR 0 1
6694: PUSH
6695: LD_INT 22
6697: PUSH
6698: LD_INT 8
6700: PUSH
6701: EMPTY
6702: LIST
6703: LIST
6704: PPUSH
6705: CALL_OW 69
6709: PUSH
6710: FOR_IN
6711: IFFALSE 6727
// SetSide ( i , 1 ) ;
6713: LD_VAR 0 1
6717: PPUSH
6718: LD_INT 1
6720: PPUSH
6721: CALL_OW 235
6725: GO 6710
6727: POP
6728: POP
// Say ( JMM , D2-JMM-4 ) ;
6729: LD_EXP 31
6733: PPUSH
6734: LD_STRING D2-JMM-4
6736: PPUSH
6737: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
6741: LD_INT 1
6743: PPUSH
6744: LD_INT 5
6746: PPUSH
6747: CALL_OW 332
// for i = 1 to points do
6751: LD_ADDR_VAR 0 1
6755: PUSH
6756: DOUBLE
6757: LD_INT 1
6759: DEC
6760: ST_TO_ADDR
6761: LD_VAR 0 2
6765: PUSH
6766: FOR_TO
6767: IFFALSE 6942
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6769: LD_VAR 0 2
6773: PUSH
6774: LD_VAR 0 1
6778: ARRAY
6779: PUSH
6780: LD_INT 1
6782: ARRAY
6783: PPUSH
6784: LD_VAR 0 2
6788: PUSH
6789: LD_VAR 0 1
6793: ARRAY
6794: PUSH
6795: LD_INT 2
6797: ARRAY
6798: PPUSH
6799: CALL_OW 84
// if i = 1 then
6803: LD_VAR 0 1
6807: PUSH
6808: LD_INT 1
6810: EQUAL
6811: IFFALSE 6825
// Say ( Lynch , D2-Sol1-4 ) ;
6813: LD_EXP 41
6817: PPUSH
6818: LD_STRING D2-Sol1-4
6820: PPUSH
6821: CALL_OW 88
// if i = 2 then
6825: LD_VAR 0 1
6829: PUSH
6830: LD_INT 2
6832: EQUAL
6833: IFFALSE 6847
// Say ( JMM , D2-JMM-5 ) ;
6835: LD_EXP 31
6839: PPUSH
6840: LD_STRING D2-JMM-5
6842: PPUSH
6843: CALL_OW 88
// if i = 4 then
6847: LD_VAR 0 1
6851: PUSH
6852: LD_INT 4
6854: EQUAL
6855: IFFALSE 6879
// begin RevealFogArea ( 1 , troopsArea ) ;
6857: LD_INT 1
6859: PPUSH
6860: LD_INT 6
6862: PPUSH
6863: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
6867: LD_EXP 41
6871: PPUSH
6872: LD_STRING D2-Sol1-5
6874: PPUSH
6875: CALL_OW 88
// end ; if i = 5 then
6879: LD_VAR 0 1
6883: PUSH
6884: LD_INT 5
6886: EQUAL
6887: IFFALSE 6901
// Say ( JMM , D2-JMM-6 ) ;
6889: LD_EXP 31
6893: PPUSH
6894: LD_STRING D2-JMM-6
6896: PPUSH
6897: CALL_OW 88
// if i = 7 then
6901: LD_VAR 0 1
6905: PUSH
6906: LD_INT 7
6908: EQUAL
6909: IFFALSE 6933
// begin RevealFogArea ( 1 , forestArea ) ;
6911: LD_INT 1
6913: PPUSH
6914: LD_INT 7
6916: PPUSH
6917: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
6921: LD_EXP 41
6925: PPUSH
6926: LD_STRING D2-Sol1-6
6928: PPUSH
6929: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
6933: LD_INT 46
6935: PPUSH
6936: CALL_OW 67
// end ;
6940: GO 6766
6942: POP
6943: POP
// CenterNowOnUnits ( JMM ) ;
6944: LD_EXP 31
6948: PPUSH
6949: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
6953: LD_EXP 31
6957: PPUSH
6958: LD_STRING D2-JMM-7
6960: PPUSH
6961: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
6965: LD_EXP 41
6969: PPUSH
6970: LD_STRING D2-Sol1-7
6972: PPUSH
6973: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
6977: LD_EXP 31
6981: PPUSH
6982: LD_STRING D2-JMM-8
6984: PPUSH
6985: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
6989: LD_ADDR_VAR 0 4
6993: PUSH
6994: LD_INT 22
6996: PUSH
6997: LD_INT 1
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: PUSH
7004: LD_INT 30
7006: PUSH
7007: LD_INT 31
7009: PUSH
7010: EMPTY
7011: LIST
7012: LIST
7013: PUSH
7014: EMPTY
7015: LIST
7016: LIST
7017: PPUSH
7018: CALL_OW 69
7022: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7023: LD_EXP 41
7027: PPUSH
7028: LD_VAR 0 4
7032: PUSH
7033: LD_INT 1
7035: ARRAY
7036: PPUSH
7037: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7041: LD_ADDR_VAR 0 3
7045: PUSH
7046: LD_EXP 2
7050: PPUSH
7051: LD_INT 25
7053: PUSH
7054: LD_INT 1
7056: PUSH
7057: EMPTY
7058: LIST
7059: LIST
7060: PPUSH
7061: CALL_OW 72
7065: PPUSH
7066: LD_EXP 31
7070: PPUSH
7071: CALL_OW 74
7075: ST_TO_ADDR
// if sol then
7076: LD_VAR 0 3
7080: IFFALSE 7120
// if GetDistUnits ( JMM , sol ) < 10 then
7082: LD_EXP 31
7086: PPUSH
7087: LD_VAR 0 3
7091: PPUSH
7092: CALL_OW 296
7096: PUSH
7097: LD_INT 10
7099: LESS
7100: IFFALSE 7120
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7102: LD_VAR 0 3
7106: PPUSH
7107: LD_VAR 0 4
7111: PUSH
7112: LD_INT 2
7114: ARRAY
7115: PPUSH
7116: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7120: LD_INT 10
7122: PPUSH
7123: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7127: LD_EXP 31
7131: PPUSH
7132: LD_INT 65
7134: PPUSH
7135: LD_INT 101
7137: PPUSH
7138: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7142: LD_EXP 31
7146: PPUSH
7147: LD_INT 63
7149: PPUSH
7150: LD_INT 100
7152: PPUSH
7153: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
7157: LD_INT 35
7159: PPUSH
7160: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
7164: LD_EXP 31
7168: PPUSH
7169: LD_INT 65
7171: PPUSH
7172: LD_INT 101
7174: PPUSH
7175: CALL_OW 307
7179: IFFALSE 7157
// Say ( JMM , D2a-JMM-1 ) ;
7181: LD_EXP 31
7185: PPUSH
7186: LD_STRING D2a-JMM-1
7188: PPUSH
7189: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7193: LD_EXP 42
7197: PPUSH
7198: LD_INT 66
7200: PPUSH
7201: LD_INT 103
7203: PPUSH
7204: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
7208: LD_INT 35
7210: PPUSH
7211: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
7215: LD_EXP 42
7219: PPUSH
7220: LD_INT 66
7222: PPUSH
7223: LD_INT 103
7225: PPUSH
7226: CALL_OW 307
7230: IFFALSE 7208
// ComTurnUnit ( Walker , JMM ) ;
7232: LD_EXP 42
7236: PPUSH
7237: LD_EXP 31
7241: PPUSH
7242: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7246: LD_EXP 42
7250: PPUSH
7251: LD_STRING D2a-Sci1-1
7253: PPUSH
7254: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7258: LD_EXP 31
7262: PPUSH
7263: LD_EXP 42
7267: PPUSH
7268: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7272: LD_EXP 31
7276: PPUSH
7277: LD_STRING D2a-JMM-2
7279: PPUSH
7280: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7284: LD_EXP 42
7288: PPUSH
7289: LD_STRING D2a-Sci1-2
7291: PPUSH
7292: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7296: LD_EXP 31
7300: PPUSH
7301: LD_STRING D2a-JMM-3
7303: PPUSH
7304: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7308: LD_EXP 42
7312: PPUSH
7313: LD_STRING D2a-Sci1-3
7315: PPUSH
7316: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7320: LD_ADDR_EXP 2
7324: PUSH
7325: LD_EXP 2
7329: PUSH
7330: LD_EXP 41
7334: PUSH
7335: LD_EXP 42
7339: PUSH
7340: LD_EXP 43
7344: PUSH
7345: LD_EXP 44
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: LIST
7354: LIST
7355: ADD
7356: ST_TO_ADDR
// for i in jmm_units do
7357: LD_ADDR_VAR 0 1
7361: PUSH
7362: LD_EXP 2
7366: PUSH
7367: FOR_IN
7368: IFFALSE 7393
// if not IsInUnit ( i ) then
7370: LD_VAR 0 1
7374: PPUSH
7375: CALL_OW 310
7379: NOT
7380: IFFALSE 7391
// ComFree ( i ) ;
7382: LD_VAR 0 1
7386: PPUSH
7387: CALL_OW 139
7391: GO 7367
7393: POP
7394: POP
// InGameOff ;
7395: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
7399: LD_STRING MSolar1
7401: PPUSH
7402: CALL_OW 337
// jmm_on_west := true ;
7406: LD_ADDR_EXP 3
7410: PUSH
7411: LD_INT 1
7413: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7414: LD_INT 1050
7416: PPUSH
7417: CALL_OW 67
// frank_can_return := true ;
7421: LD_ADDR_EXP 10
7425: PUSH
7426: LD_INT 1
7428: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7429: LD_INT 6300
7431: PPUSH
7432: LD_INT 8400
7434: PPUSH
7435: CALL_OW 12
7439: PPUSH
7440: CALL_OW 67
// send_spec_patrol := true ;
7444: LD_ADDR_EXP 26
7448: PUSH
7449: LD_INT 1
7451: ST_TO_ADDR
// end ;
7452: PPOPN 4
7454: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7455: LD_INT 22
7457: PUSH
7458: LD_INT 1
7460: PUSH
7461: EMPTY
7462: LIST
7463: LIST
7464: PUSH
7465: LD_INT 34
7467: PUSH
7468: LD_INT 51
7470: PUSH
7471: EMPTY
7472: LIST
7473: LIST
7474: PUSH
7475: LD_INT 92
7477: PUSH
7478: LD_INT 63
7480: PUSH
7481: LD_INT 100
7483: PUSH
7484: LD_INT 5
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: LIST
7491: LIST
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: LIST
7497: PUSH
7498: EMPTY
7499: LIST
7500: PPUSH
7501: CALL_OW 69
7505: PUSH
7506: LD_EXP 3
7510: NOT
7511: AND
7512: IFFALSE 7625
7514: GO 7516
7516: DISABLE
7517: LD_INT 0
7519: PPUSH
7520: PPUSH
// begin enable ;
7521: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
7522: LD_ADDR_VAR 0 2
7526: PUSH
7527: LD_INT 22
7529: PUSH
7530: LD_INT 1
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: PUSH
7537: LD_INT 34
7539: PUSH
7540: LD_INT 51
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: PUSH
7547: LD_INT 92
7549: PUSH
7550: LD_INT 63
7552: PUSH
7553: LD_INT 100
7555: PUSH
7556: LD_INT 5
7558: PUSH
7559: EMPTY
7560: LIST
7561: LIST
7562: LIST
7563: LIST
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: LIST
7569: PUSH
7570: EMPTY
7571: LIST
7572: PPUSH
7573: CALL_OW 69
7577: ST_TO_ADDR
// if not filter then
7578: LD_VAR 0 2
7582: NOT
7583: IFFALSE 7587
// exit ;
7585: GO 7625
// for i in filter do
7587: LD_ADDR_VAR 0 1
7591: PUSH
7592: LD_VAR 0 2
7596: PUSH
7597: FOR_IN
7598: IFFALSE 7623
// begin SetFuel ( i , 0 ) ;
7600: LD_VAR 0 1
7604: PPUSH
7605: LD_INT 0
7607: PPUSH
7608: CALL_OW 240
// ComStop ( i ) ;
7612: LD_VAR 0 1
7616: PPUSH
7617: CALL_OW 141
// end ;
7621: GO 7597
7623: POP
7624: POP
// end ;
7625: PPOPN 2
7627: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
7628: LD_EXP 26
7632: IFFALSE 8597
7634: GO 7636
7636: DISABLE
7637: LD_INT 0
7639: PPUSH
7640: PPUSH
7641: PPUSH
7642: PPUSH
7643: PPUSH
7644: PPUSH
7645: PPUSH
// begin if not ru_spec_patrol then
7646: LD_EXP 48
7650: NOT
7651: IFFALSE 7655
// exit ;
7653: GO 8597
// dead1 := false ;
7655: LD_ADDR_VAR 0 1
7659: PUSH
7660: LD_INT 0
7662: ST_TO_ADDR
// dead2 := false ;
7663: LD_ADDR_VAR 0 2
7667: PUSH
7668: LD_INT 0
7670: ST_TO_ADDR
// inarea1 := false ;
7671: LD_ADDR_VAR 0 3
7675: PUSH
7676: LD_INT 0
7678: ST_TO_ADDR
// inarea2 := false ;
7679: LD_ADDR_VAR 0 4
7683: PUSH
7684: LD_INT 0
7686: ST_TO_ADDR
// tmp := [ ] ;
7687: LD_ADDR_VAR 0 6
7691: PUSH
7692: EMPTY
7693: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
7694: LD_EXP 48
7698: PPUSH
7699: LD_INT 75
7701: PPUSH
7702: LD_INT 101
7704: PPUSH
7705: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
7709: LD_INT 35
7711: PPUSH
7712: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
7716: LD_INT 1
7718: PPUSH
7719: LD_EXP 48
7723: PUSH
7724: LD_INT 1
7726: ARRAY
7727: PPUSH
7728: CALL_OW 292
7732: IFFALSE 7709
// ComStop ( ru_spec_patrol ) ;
7734: LD_EXP 48
7738: PPUSH
7739: CALL_OW 141
// Wait ( 0 0$02 ) ;
7743: LD_INT 70
7745: PPUSH
7746: CALL_OW 67
// DialogueOn ;
7750: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
7754: LD_EXP 48
7758: PUSH
7759: LD_INT 1
7761: ARRAY
7762: PPUSH
7763: LD_STRING D8-Rus1-1
7765: PPUSH
7766: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
7770: LD_EXP 31
7774: PPUSH
7775: LD_STRING D8-JMM-1
7777: PPUSH
7778: CALL_OW 88
// DialogueOff ;
7782: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
7786: LD_EXP 48
7790: PPUSH
7791: LD_INT 13
7793: PPUSH
7794: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
7798: LD_INT 35
7800: PPUSH
7801: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
7805: LD_VAR 0 1
7809: NOT
7810: PUSH
7811: LD_EXP 48
7815: PUSH
7816: LD_INT 1
7818: ARRAY
7819: PPUSH
7820: CALL_OW 301
7824: AND
7825: IFFALSE 7835
// dead1 := true ;
7827: LD_ADDR_VAR 0 1
7831: PUSH
7832: LD_INT 1
7834: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
7835: LD_VAR 0 2
7839: NOT
7840: PUSH
7841: LD_EXP 48
7845: PUSH
7846: LD_INT 2
7848: ARRAY
7849: PPUSH
7850: CALL_OW 301
7854: AND
7855: IFFALSE 7865
// dead2 := true ;
7857: LD_ADDR_VAR 0 2
7861: PUSH
7862: LD_INT 1
7864: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
7865: LD_VAR 0 3
7869: NOT
7870: PUSH
7871: LD_EXP 48
7875: PUSH
7876: LD_INT 1
7878: ARRAY
7879: PPUSH
7880: LD_INT 14
7882: PPUSH
7883: CALL_OW 308
7887: AND
7888: IFFALSE 7898
// inarea1 := true ;
7890: LD_ADDR_VAR 0 3
7894: PUSH
7895: LD_INT 1
7897: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
7898: LD_VAR 0 4
7902: NOT
7903: PUSH
7904: LD_EXP 48
7908: PUSH
7909: LD_INT 2
7911: ARRAY
7912: PPUSH
7913: LD_INT 14
7915: PPUSH
7916: CALL_OW 308
7920: AND
7921: IFFALSE 7931
// inarea2 := true ;
7923: LD_ADDR_VAR 0 4
7927: PUSH
7928: LD_INT 1
7930: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
7931: LD_VAR 0 1
7935: PUSH
7936: LD_VAR 0 2
7940: AND
7941: PUSH
7942: LD_VAR 0 1
7946: PUSH
7947: LD_VAR 0 4
7951: AND
7952: OR
7953: PUSH
7954: LD_VAR 0 2
7958: PUSH
7959: LD_VAR 0 3
7963: AND
7964: OR
7965: PUSH
7966: LD_VAR 0 3
7970: PUSH
7971: LD_VAR 0 4
7975: AND
7976: OR
7977: IFFALSE 7798
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
7979: LD_VAR 0 3
7983: PUSH
7984: LD_VAR 0 4
7988: AND
7989: PUSH
7990: LD_VAR 0 1
7994: PUSH
7995: LD_VAR 0 4
7999: AND
8000: OR
8001: PUSH
8002: LD_VAR 0 2
8006: PUSH
8007: LD_VAR 0 3
8011: AND
8012: OR
8013: IFFALSE 8577
// begin prepare_siege := true ;
8015: LD_ADDR_EXP 27
8019: PUSH
8020: LD_INT 1
8022: ST_TO_ADDR
// DialogueOn ;
8023: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8027: LD_VAR 0 3
8031: PUSH
8032: LD_VAR 0 4
8036: AND
8037: IFFALSE 8053
// Say ( JMM , D8b-JMM-1a ) else
8039: LD_EXP 31
8043: PPUSH
8044: LD_STRING D8b-JMM-1a
8046: PPUSH
8047: CALL_OW 88
8051: GO 8065
// Say ( JMM , D8b-JMM-1 ) ;
8053: LD_EXP 31
8057: PPUSH
8058: LD_STRING D8b-JMM-1
8060: PPUSH
8061: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8065: LD_EXP 2
8069: PPUSH
8070: LD_INT 26
8072: PUSH
8073: LD_INT 1
8075: PUSH
8076: EMPTY
8077: LIST
8078: LIST
8079: PPUSH
8080: CALL_OW 72
8084: PUSH
8085: LD_EXP 32
8089: PUSH
8090: LD_EXP 33
8094: PUSH
8095: LD_EXP 42
8099: PUSH
8100: LD_EXP 45
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: LIST
8109: LIST
8110: DIFF
8111: PPUSH
8112: LD_STRING D8b-Sol1-1
8114: PPUSH
8115: CALL 604 0 2
// if Cyrus and Cyrus in jmm_units then
8119: LD_EXP 33
8123: PUSH
8124: LD_EXP 33
8128: PUSH
8129: LD_EXP 2
8133: IN
8134: AND
8135: IFFALSE 8151
// Say ( Cyrus , D8b-Cyrus-1 ) else
8137: LD_EXP 33
8141: PPUSH
8142: LD_STRING D8b-Cyrus-1
8144: PPUSH
8145: CALL_OW 88
8149: GO 8163
// Say ( JMM , D8b-JMM-1a ) ;
8151: LD_EXP 31
8155: PPUSH
8156: LD_STRING D8b-JMM-1a
8158: PPUSH
8159: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8163: LD_EXP 34
8167: PUSH
8168: LD_EXP 34
8172: PUSH
8173: LD_EXP 2
8177: IN
8178: AND
8179: IFFALSE 8193
// Say ( Lisa , D8b-Lisa-2 ) ;
8181: LD_EXP 34
8185: PPUSH
8186: LD_STRING D8b-Lisa-2
8188: PPUSH
8189: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8193: LD_EXP 32
8197: PUSH
8198: LD_EXP 32
8202: PUSH
8203: LD_EXP 2
8207: IN
8208: AND
8209: IFFALSE 8225
// Say ( Bobby , D8b-Bobby-1 ) else
8211: LD_EXP 32
8215: PPUSH
8216: LD_STRING D8b-Bobby-1
8218: PPUSH
8219: CALL_OW 88
8223: GO 8285
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8225: LD_ADDR_VAR 0 5
8229: PUSH
8230: LD_EXP 2
8234: PPUSH
8235: LD_INT 26
8237: PUSH
8238: LD_INT 1
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: PPUSH
8245: CALL_OW 72
8249: PUSH
8250: LD_EXP 32
8254: PUSH
8255: LD_EXP 33
8259: PUSH
8260: LD_EXP 42
8264: PUSH
8265: LD_EXP 45
8269: PUSH
8270: EMPTY
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: DIFF
8276: PPUSH
8277: LD_STRING D8b-Sol2-1
8279: PPUSH
8280: CALL 604 0 2
8284: ST_TO_ADDR
// DialogueOff ;
8285: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8289: LD_EXP 33
8293: PUSH
8294: LD_EXP 33
8298: PUSH
8299: LD_EXP 2
8303: IN
8304: AND
8305: IFFALSE 8330
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8307: LD_ADDR_VAR 0 6
8311: PUSH
8312: LD_VAR 0 6
8316: PPUSH
8317: LD_INT 1
8319: PPUSH
8320: LD_EXP 33
8324: PPUSH
8325: CALL_OW 2
8329: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8330: LD_EXP 32
8334: PUSH
8335: LD_EXP 32
8339: PUSH
8340: LD_EXP 2
8344: IN
8345: AND
8346: IFFALSE 8371
// tmp := Insert ( tmp , 1 , Bobby ) ;
8348: LD_ADDR_VAR 0 6
8352: PUSH
8353: LD_VAR 0 6
8357: PPUSH
8358: LD_INT 1
8360: PPUSH
8361: LD_EXP 32
8365: PPUSH
8366: CALL_OW 2
8370: ST_TO_ADDR
// if sol then
8371: LD_VAR 0 5
8375: IFFALSE 8400
// tmp := Insert ( tmp , 1 , sol ) ;
8377: LD_ADDR_VAR 0 6
8381: PUSH
8382: LD_VAR 0 6
8386: PPUSH
8387: LD_INT 1
8389: PPUSH
8390: LD_VAR 0 5
8394: PPUSH
8395: CALL_OW 2
8399: ST_TO_ADDR
// if tmp then
8400: LD_VAR 0 6
8404: IFFALSE 8536
// begin SetSide ( tmp , 8 ) ;
8406: LD_VAR 0 6
8410: PPUSH
8411: LD_INT 8
8413: PPUSH
8414: CALL_OW 235
// ComFree ( tmp ) ;
8418: LD_VAR 0 6
8422: PPUSH
8423: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8427: LD_VAR 0 6
8431: PPUSH
8432: LD_INT 15
8434: PPUSH
8435: CALL_OW 173
// AddComHold ( tmp ) ;
8439: LD_VAR 0 6
8443: PPUSH
8444: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8448: LD_INT 35
8450: PPUSH
8451: CALL_OW 67
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8455: LD_VAR 0 6
8459: PUSH
8460: LD_INT 1
8462: ARRAY
8463: PPUSH
8464: LD_INT 15
8466: PPUSH
8467: CALL_OW 308
8471: IFFALSE 8526
// begin RemoveUnit ( tmp [ 1 ] ) ;
8473: LD_VAR 0 6
8477: PUSH
8478: LD_INT 1
8480: ARRAY
8481: PPUSH
8482: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
8486: LD_ADDR_EXP 2
8490: PUSH
8491: LD_EXP 2
8495: PUSH
8496: LD_VAR 0 6
8500: PUSH
8501: LD_INT 1
8503: ARRAY
8504: DIFF
8505: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
8506: LD_ADDR_VAR 0 6
8510: PUSH
8511: LD_VAR 0 6
8515: PUSH
8516: LD_VAR 0 6
8520: PUSH
8521: LD_INT 1
8523: ARRAY
8524: DIFF
8525: ST_TO_ADDR
// end ; until tmp = 0 ;
8526: LD_VAR 0 6
8530: PUSH
8531: LD_INT 0
8533: EQUAL
8534: IFFALSE 8448
// end ; Wait ( 0 0$30 ) ;
8536: LD_INT 1050
8538: PPUSH
8539: CALL_OW 67
// if ru_spec_patrol then
8543: LD_EXP 48
8547: IFFALSE 8575
// for i in ru_spec_patrol do
8549: LD_ADDR_VAR 0 7
8553: PUSH
8554: LD_EXP 48
8558: PUSH
8559: FOR_IN
8560: IFFALSE 8573
// RemoveUnit ( i ) ;
8562: LD_VAR 0 7
8566: PPUSH
8567: CALL_OW 64
8571: GO 8559
8573: POP
8574: POP
// end else
8575: GO 8597
// begin prepare_siege := false ;
8577: LD_ADDR_EXP 27
8581: PUSH
8582: LD_INT 0
8584: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
8585: LD_EXP 31
8589: PPUSH
8590: LD_STRING D8a-JMM-1
8592: PPUSH
8593: CALL_OW 88
// end ; end ;
8597: PPOPN 7
8599: END
// every 0 0$10 trigger frank_can_return do var i , points ;
8600: LD_EXP 10
8604: IFFALSE 9738
8606: GO 8608
8608: DISABLE
8609: LD_INT 0
8611: PPUSH
8612: PPUSH
// begin uc_side := 8 ;
8613: LD_ADDR_OWVAR 20
8617: PUSH
8618: LD_INT 8
8620: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
8621: LD_ADDR_VAR 0 2
8625: PUSH
8626: LD_INT 59
8628: PUSH
8629: LD_INT 71
8631: PUSH
8632: EMPTY
8633: LIST
8634: LIST
8635: PUSH
8636: LD_INT 122
8638: PUSH
8639: LD_INT 117
8641: PUSH
8642: EMPTY
8643: LIST
8644: LIST
8645: PUSH
8646: EMPTY
8647: LIST
8648: LIST
8649: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
8650: LD_ADDR_EXP 45
8654: PUSH
8655: LD_STRING Frank
8657: PPUSH
8658: LD_INT 0
8660: PPUSH
8661: CALL 434 0 2
8665: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
8666: LD_ADDR_VAR 0 1
8670: PUSH
8671: LD_INT 1
8673: PPUSH
8674: LD_INT 2
8676: PPUSH
8677: CALL_OW 12
8681: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
8682: LD_EXP 45
8686: PPUSH
8687: LD_VAR 0 2
8691: PUSH
8692: LD_VAR 0 1
8696: ARRAY
8697: PUSH
8698: LD_INT 1
8700: ARRAY
8701: PPUSH
8702: LD_VAR 0 2
8706: PUSH
8707: LD_VAR 0 1
8711: ARRAY
8712: PUSH
8713: LD_INT 2
8715: ARRAY
8716: PPUSH
8717: LD_INT 0
8719: PPUSH
8720: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
8724: LD_EXP 45
8728: PPUSH
8729: LD_INT 1
8731: PPUSH
8732: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
8736: LD_INT 35
8738: PPUSH
8739: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
8743: LD_EXP 45
8747: PPUSH
8748: LD_EXP 31
8752: PPUSH
8753: CALL_OW 296
8757: PUSH
8758: LD_INT 8
8760: LESS
8761: IFFALSE 8736
// InGameOn ;
8763: CALL_OW 8
// CenterOnUnits ( JMM ) ;
8767: LD_EXP 31
8771: PPUSH
8772: CALL_OW 85
// if IsInUnit ( JMM ) then
8776: LD_EXP 31
8780: PPUSH
8781: CALL_OW 310
8785: IFFALSE 8796
// ComFree ( JMM ) ;
8787: LD_EXP 31
8791: PPUSH
8792: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
8796: LD_EXP 31
8800: PPUSH
8801: LD_EXP 45
8805: PPUSH
8806: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
8810: LD_EXP 45
8814: PPUSH
8815: LD_EXP 31
8819: PPUSH
8820: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
8824: LD_EXP 31
8828: PPUSH
8829: LD_STRING D6-JMM-1
8831: PPUSH
8832: CALL_OW 88
// repeat wait ( 3 ) ;
8836: LD_INT 3
8838: PPUSH
8839: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
8843: LD_EXP 31
8847: PPUSH
8848: LD_EXP 45
8852: PPUSH
8853: CALL_OW 296
8857: PUSH
8858: LD_INT 8
8860: LESS
8861: IFFALSE 8836
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
8863: LD_EXP 34
8867: PUSH
8868: LD_EXP 34
8872: PPUSH
8873: LD_EXP 45
8877: PPUSH
8878: CALL_OW 296
8882: PUSH
8883: LD_INT 20
8885: LESS
8886: AND
8887: IFFALSE 8912
// begin ComFree ( Lisa ) ;
8889: LD_EXP 34
8893: PPUSH
8894: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
8898: LD_EXP 34
8902: PPUSH
8903: LD_EXP 45
8907: PPUSH
8908: CALL_OW 172
// end ; if Lynch then
8912: LD_EXP 41
8916: IFFALSE 8941
// begin ComFree ( Lynch ) ;
8918: LD_EXP 41
8922: PPUSH
8923: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
8927: LD_EXP 41
8931: PPUSH
8932: LD_EXP 45
8936: PPUSH
8937: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
8941: LD_EXP 31
8945: PPUSH
8946: LD_EXP 45
8950: PPUSH
8951: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
8955: LD_EXP 45
8959: PPUSH
8960: LD_EXP 31
8964: PPUSH
8965: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
8969: LD_EXP 45
8973: PPUSH
8974: LD_STRING D6-Frank-1
8976: PPUSH
8977: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
8981: LD_INT 69
8983: PPUSH
8984: LD_INT 20
8986: PPUSH
8987: LD_INT 1
8989: PPUSH
8990: LD_INT 20
8992: NEG
8993: PPUSH
8994: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
8998: LD_INT 69
9000: PPUSH
9001: LD_INT 20
9003: PPUSH
9004: LD_INT 1
9006: PPUSH
9007: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9011: LD_INT 190
9013: PPUSH
9014: LD_INT 31
9016: PPUSH
9017: LD_INT 1
9019: PPUSH
9020: LD_INT 20
9022: NEG
9023: PPUSH
9024: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9028: LD_INT 190
9030: PPUSH
9031: LD_INT 31
9033: PPUSH
9034: LD_INT 1
9036: PPUSH
9037: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9041: LD_INT 69
9043: PPUSH
9044: LD_INT 20
9046: PPUSH
9047: CALL_OW 84
// Wait ( 0 0$02 ) ;
9051: LD_INT 70
9053: PPUSH
9054: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9058: LD_EXP 31
9062: PPUSH
9063: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9067: LD_EXP 34
9071: PUSH
9072: LD_EXP 34
9076: PPUSH
9077: LD_EXP 45
9081: PPUSH
9082: CALL_OW 296
9086: PUSH
9087: LD_INT 20
9089: LESS
9090: AND
9091: PUSH
9092: LD_EXP 34
9096: PPUSH
9097: CALL_OW 302
9101: AND
9102: IFFALSE 9192
// begin ComFree ( Lisa ) ;
9104: LD_EXP 34
9108: PPUSH
9109: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
9113: LD_INT 35
9115: PPUSH
9116: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
9120: LD_EXP 34
9124: PPUSH
9125: LD_EXP 45
9129: PPUSH
9130: CALL_OW 296
9134: PUSH
9135: LD_INT 7
9137: LESS
9138: IFFALSE 9113
// Say ( Lisa , D6-Lisa-1 ) ;
9140: LD_EXP 34
9144: PPUSH
9145: LD_STRING D6-Lisa-1
9147: PPUSH
9148: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9152: LD_EXP 34
9156: PPUSH
9157: LD_EXP 45
9161: PPUSH
9162: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9166: LD_EXP 45
9170: PPUSH
9171: LD_EXP 34
9175: PPUSH
9176: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9180: LD_EXP 45
9184: PPUSH
9185: LD_STRING D6-Frank-2
9187: PPUSH
9188: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9192: LD_EXP 41
9196: PUSH
9197: LD_EXP 41
9201: PPUSH
9202: LD_EXP 45
9206: PPUSH
9207: CALL_OW 296
9211: PUSH
9212: LD_INT 20
9214: LESS
9215: AND
9216: PUSH
9217: LD_EXP 41
9221: PPUSH
9222: CALL_OW 302
9226: AND
9227: IFFALSE 9408
// begin ComTurnUnit ( Lynch , JMM ) ;
9229: LD_EXP 41
9233: PPUSH
9234: LD_EXP 31
9238: PPUSH
9239: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9243: LD_EXP 45
9247: PPUSH
9248: LD_EXP 31
9252: PPUSH
9253: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9257: LD_EXP 41
9261: PPUSH
9262: LD_STRING D6-Sol1-2
9264: PPUSH
9265: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9269: LD_EXP 31
9273: PPUSH
9274: LD_STRING D6-JMM-2
9276: PPUSH
9277: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9281: LD_EXP 45
9285: PPUSH
9286: LD_STRING D6-Frank-3
9288: PPUSH
9289: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9293: LD_EXP 31
9297: PPUSH
9298: LD_STRING D6-JMM-3
9300: PPUSH
9301: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9305: LD_EXP 45
9309: PPUSH
9310: LD_STRING D6-Frank-4
9312: PPUSH
9313: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9317: LD_EXP 45
9321: PPUSH
9322: LD_STRING D6-Frank-4a
9324: PPUSH
9325: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9329: LD_EXP 31
9333: PPUSH
9334: LD_STRING D6-JMM-4
9336: PPUSH
9337: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9341: LD_EXP 45
9345: PPUSH
9346: LD_STRING D6-Frank-5
9348: PPUSH
9349: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9353: LD_EXP 34
9357: PUSH
9358: LD_EXP 34
9362: PPUSH
9363: CALL_OW 302
9367: AND
9368: IFFALSE 9382
// Say ( Lisa , D6-Lisa-5 ) ;
9370: LD_EXP 34
9374: PPUSH
9375: LD_STRING D6-Lisa-5
9377: PPUSH
9378: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9382: LD_EXP 45
9386: PPUSH
9387: LD_STRING D6-Frank-6
9389: PPUSH
9390: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9394: LD_EXP 31
9398: PPUSH
9399: LD_STRING D6-JMM-6
9401: PPUSH
9402: CALL_OW 88
// end else
9406: GO 9523
// begin ComTurnUnit ( Frank , JMM ) ;
9408: LD_EXP 45
9412: PPUSH
9413: LD_EXP 31
9417: PPUSH
9418: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
9422: LD_EXP 45
9426: PPUSH
9427: LD_STRING D6-Frank-4
9429: PPUSH
9430: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9434: LD_EXP 45
9438: PPUSH
9439: LD_STRING D6-Frank-4a
9441: PPUSH
9442: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9446: LD_EXP 31
9450: PPUSH
9451: LD_STRING D6-JMM-4
9453: PPUSH
9454: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9458: LD_EXP 45
9462: PPUSH
9463: LD_STRING D6-Frank-5
9465: PPUSH
9466: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9470: LD_EXP 34
9474: PUSH
9475: LD_EXP 34
9479: PPUSH
9480: CALL_OW 302
9484: AND
9485: IFFALSE 9499
// Say ( Lisa , D6-Lisa-5 ) ;
9487: LD_EXP 34
9491: PPUSH
9492: LD_STRING D6-Lisa-5
9494: PPUSH
9495: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9499: LD_EXP 45
9503: PPUSH
9504: LD_STRING D6-Frank-6
9506: PPUSH
9507: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9511: LD_EXP 31
9515: PPUSH
9516: LD_STRING D6-JMM-6
9518: PPUSH
9519: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
9523: LD_STRING Q1
9525: PPUSH
9526: CALL_OW 97
9530: PUSH
9531: LD_INT 1
9533: DOUBLE
9534: EQUAL
9535: IFTRUE 9539
9537: GO 9550
9539: POP
// frank_send_to_scout := true ; 2 :
9540: LD_ADDR_EXP 12
9544: PUSH
9545: LD_INT 1
9547: ST_TO_ADDR
9548: GO 9570
9550: LD_INT 2
9552: DOUBLE
9553: EQUAL
9554: IFTRUE 9558
9556: GO 9569
9558: POP
// frank_send_to_scout := false ; end ;
9559: LD_ADDR_EXP 12
9563: PUSH
9564: LD_INT 0
9566: ST_TO_ADDR
9567: GO 9570
9569: POP
// InGameOff ;
9570: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
9574: LD_EXP 31
9578: PUSH
9579: LD_EXP 34
9583: PUSH
9584: LD_EXP 41
9588: PUSH
9589: EMPTY
9590: LIST
9591: LIST
9592: LIST
9593: PPUSH
9594: CALL_OW 139
// if frank_send_to_scout then
9598: LD_EXP 12
9602: IFFALSE 9659
// begin ComMoveXY ( Frank , 130 , 123 ) ;
9604: LD_EXP 45
9608: PPUSH
9609: LD_INT 130
9611: PPUSH
9612: LD_INT 123
9614: PPUSH
9615: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
9619: LD_INT 35
9621: PPUSH
9622: CALL_OW 67
// until not See ( 1 , Frank ) ;
9626: LD_INT 1
9628: PPUSH
9629: LD_EXP 45
9633: PPUSH
9634: CALL_OW 292
9638: NOT
9639: IFFALSE 9619
// Wait ( 0 0$02 ) ;
9641: LD_INT 70
9643: PPUSH
9644: CALL_OW 67
// RemoveUnit ( Frank ) ;
9648: LD_EXP 45
9652: PPUSH
9653: CALL_OW 64
// end else
9657: GO 9671
// SetSide ( Frank , 1 ) ;
9659: LD_EXP 45
9663: PPUSH
9664: LD_INT 1
9666: PPUSH
9667: CALL_OW 235
// send_attack_on_cornel_base := true ;
9671: LD_ADDR_EXP 23
9675: PUSH
9676: LD_INT 1
9678: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9679: LD_INT 35
9681: PPUSH
9682: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
9686: LD_ADDR_EXP 25
9690: PUSH
9691: LD_EXP 25
9695: PPUSH
9696: LD_STRING -
9698: PPUSH
9699: CALL 1096 0 2
9703: ST_TO_ADDR
// if debug then
9704: LD_EXP 1
9708: IFFALSE 9720
// debug_strings := time_to_prepare ;
9710: LD_ADDR_OWVAR 48
9714: PUSH
9715: LD_EXP 25
9719: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
9720: LD_EXP 25
9724: PUSH
9725: LD_INT 0
9727: EQUAL
9728: IFFALSE 9679
// cornel_prepared := true ;
9730: LD_ADDR_EXP 9
9734: PUSH
9735: LD_INT 1
9737: ST_TO_ADDR
// end ;
9738: PPOPN 2
9740: END
// every 0 0$01 trigger cornel_prepared do
9741: LD_EXP 9
9745: IFFALSE 9991
9747: GO 9749
9749: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
9750: LD_EXP 38
9754: PPUSH
9755: LD_STRING D3-Corn-1
9757: PPUSH
9758: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
9762: LD_INT 35
9764: PPUSH
9765: CALL_OW 67
// until cornel_counter = 0 ;
9769: LD_EXP 8
9773: PUSH
9774: LD_INT 0
9776: EQUAL
9777: IFFALSE 9762
// SayRadio ( Cornel , D3a-Corn-1 ) ;
9779: LD_EXP 38
9783: PPUSH
9784: LD_STRING D3a-Corn-1
9786: PPUSH
9787: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
9791: LD_EXP 31
9795: PPUSH
9796: LD_STRING D3a-JMM-1
9798: PPUSH
9799: CALL_OW 88
// end_mission_allowed := true ;
9803: LD_ADDR_EXP 18
9807: PUSH
9808: LD_INT 1
9810: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
9811: LD_STRING M2
9813: PPUSH
9814: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
9818: LD_INT 9
9820: PPUSH
9821: LD_INT 1
9823: PPUSH
9824: CALL_OW 424
// Wait ( 0 0$05 ) ;
9828: LD_INT 175
9830: PPUSH
9831: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
9835: LD_EXP 38
9839: PPUSH
9840: LD_STRING D3a-Corn-2
9842: PPUSH
9843: CALL_OW 94
// cornel_attack := true ;
9847: LD_ADDR_EXP 7
9851: PUSH
9852: LD_INT 1
9854: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
9855: LD_INT 105
9857: PPUSH
9858: CALL_OW 67
// AddMoreTanks ( ) ;
9862: CALL 4754 0 0
// if frank_send_to_scout then
9866: LD_EXP 12
9870: IFFALSE 9991
// begin InitHc ;
9872: CALL_OW 19
// InitUc ;
9876: CALL_OW 18
// uc_side := 8 ;
9880: LD_ADDR_OWVAR 20
9884: PUSH
9885: LD_INT 8
9887: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9888: LD_ADDR_EXP 45
9892: PUSH
9893: LD_STRING Frank
9895: PPUSH
9896: LD_INT 0
9898: PPUSH
9899: CALL 434 0 2
9903: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
9904: LD_EXP 45
9908: PPUSH
9909: LD_INT 6
9911: PPUSH
9912: LD_INT 9
9914: PPUSH
9915: LD_INT 0
9917: PPUSH
9918: CALL_OW 48
// ComCrawl ( Frank ) ;
9922: LD_EXP 45
9926: PPUSH
9927: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
9931: LD_INT 35
9933: PPUSH
9934: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
9938: LD_EXP 31
9942: PPUSH
9943: LD_EXP 45
9947: PPUSH
9948: CALL_OW 296
9952: PUSH
9953: LD_INT 9
9955: LESS
9956: IFFALSE 9931
// SetSide ( Frank , 1 ) ;
9958: LD_EXP 45
9962: PPUSH
9963: LD_INT 1
9965: PPUSH
9966: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
9970: LD_EXP 45
9974: PPUSH
9975: LD_STRING D6a-Frank-1
9977: PPUSH
9978: CALL_OW 88
// ComWalk ( Frank ) ;
9982: LD_EXP 45
9986: PPUSH
9987: CALL_OW 138
// end ; end ;
9991: END
// every 0 0$01 trigger solar_builded do
9992: LD_EXP 11
9996: IFFALSE 10100
9998: GO 10000
10000: DISABLE
// begin Wait ( 0 0$02 ) ;
10001: LD_INT 70
10003: PPUSH
10004: CALL_OW 67
// DialogueOn ;
10008: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10012: LD_EXP 31
10016: PPUSH
10017: LD_STRING D2b-JMM-1
10019: PPUSH
10020: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10024: LD_EXP 42
10028: PUSH
10029: LD_EXP 42
10033: PPUSH
10034: CALL_OW 302
10038: AND
10039: IFFALSE 10089
// begin Say ( Walker , D2b-Sci1-1 ) ;
10041: LD_EXP 42
10045: PPUSH
10046: LD_STRING D2b-Sci1-1
10048: PPUSH
10049: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10053: LD_EXP 31
10057: PPUSH
10058: LD_STRING D2b-JMM-2
10060: PPUSH
10061: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10065: LD_EXP 42
10069: PPUSH
10070: LD_STRING D2b-Sci1-2
10072: PPUSH
10073: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10077: LD_EXP 31
10081: PPUSH
10082: LD_STRING D2b-JMM-3
10084: PPUSH
10085: CALL_OW 88
// end ; DialogueOff ;
10089: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10093: LD_STRING MOutSol
10095: PPUSH
10096: CALL_OW 337
// end ;
10100: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10101: LD_EXP 11
10105: PUSH
10106: LD_EXP 31
10110: PPUSH
10111: CALL_OW 302
10115: AND
10116: PUSH
10117: LD_EXP 31
10121: PPUSH
10122: CALL 930 0 1
10126: AND
10127: PUSH
10128: LD_EXP 13
10132: NOT
10133: AND
10134: IFFALSE 10205
10136: GO 10138
10138: DISABLE
10139: LD_INT 0
10141: PPUSH
// begin jmm_in_veh := true ;
10142: LD_ADDR_EXP 13
10146: PUSH
10147: LD_INT 1
10149: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10150: LD_ADDR_VAR 0 1
10154: PUSH
10155: LD_INT 0
10157: PPUSH
10158: LD_INT 1
10160: PPUSH
10161: CALL_OW 12
10165: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10166: LD_INT 70
10168: PPUSH
10169: CALL_OW 67
// if i then
10173: LD_VAR 0 1
10177: IFFALSE 10193
// Say ( JMM , D2c-JMM-1 ) else
10179: LD_EXP 31
10183: PPUSH
10184: LD_STRING D2c-JMM-1
10186: PPUSH
10187: CALL_OW 88
10191: GO 10205
// Say ( JMM , D2c-JMM-1a ) ;
10193: LD_EXP 31
10197: PPUSH
10198: LD_STRING D2c-JMM-1a
10200: PPUSH
10201: CALL_OW 88
// end ;
10205: PPOPN 1
10207: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10208: LD_EXP 11
10212: PUSH
10213: LD_EXP 32
10217: PPUSH
10218: CALL_OW 302
10222: AND
10223: PUSH
10224: LD_EXP 32
10228: PPUSH
10229: CALL 930 0 1
10233: AND
10234: PUSH
10235: LD_EXP 14
10239: NOT
10240: AND
10241: IFFALSE 10273
10243: GO 10245
10245: DISABLE
// begin bobby_in_veh := true ;
10246: LD_ADDR_EXP 14
10250: PUSH
10251: LD_INT 1
10253: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10254: LD_INT 70
10256: PPUSH
10257: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10261: LD_EXP 32
10265: PPUSH
10266: LD_STRING D2c-Bobby-1
10268: PPUSH
10269: CALL_OW 88
10273: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10274: LD_EXP 11
10278: PUSH
10279: LD_EXP 34
10283: PPUSH
10284: CALL_OW 302
10288: AND
10289: PUSH
10290: LD_EXP 34
10294: PPUSH
10295: CALL 930 0 1
10299: AND
10300: PUSH
10301: LD_EXP 16
10305: NOT
10306: AND
10307: IFFALSE 10339
10309: GO 10311
10311: DISABLE
// begin lisa_in_veh := true ;
10312: LD_ADDR_EXP 16
10316: PUSH
10317: LD_INT 1
10319: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10320: LD_INT 70
10322: PPUSH
10323: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10327: LD_EXP 34
10331: PPUSH
10332: LD_STRING D2c-Lisa-1
10334: PPUSH
10335: CALL_OW 88
10339: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
10340: LD_EXP 11
10344: PUSH
10345: LD_EXP 33
10349: PPUSH
10350: CALL_OW 302
10354: AND
10355: PUSH
10356: LD_EXP 33
10360: PPUSH
10361: CALL 930 0 1
10365: AND
10366: PUSH
10367: LD_EXP 15
10371: NOT
10372: AND
10373: IFFALSE 10444
10375: GO 10377
10377: DISABLE
10378: LD_INT 0
10380: PPUSH
// begin cyrus_in_veh := true ;
10381: LD_ADDR_EXP 15
10385: PUSH
10386: LD_INT 1
10388: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10389: LD_ADDR_VAR 0 1
10393: PUSH
10394: LD_INT 0
10396: PPUSH
10397: LD_INT 1
10399: PPUSH
10400: CALL_OW 12
10404: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10405: LD_INT 70
10407: PPUSH
10408: CALL_OW 67
// if i then
10412: LD_VAR 0 1
10416: IFFALSE 10432
// Say ( Cyrus , D2c-Cyrus-1 ) else
10418: LD_EXP 33
10422: PPUSH
10423: LD_STRING D2c-Cyrus-1
10425: PPUSH
10426: CALL_OW 88
10430: GO 10444
// Say ( Cyrus , D2c-Cyrus-1a ) ;
10432: LD_EXP 33
10436: PPUSH
10437: LD_STRING D2c-Cyrus-1a
10439: PPUSH
10440: CALL_OW 88
// end ;
10444: PPOPN 1
10446: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
10447: LD_EXP 38
10451: PPUSH
10452: LD_INT 16
10454: PPUSH
10455: CALL_OW 308
10459: IFFALSE 10709
10461: GO 10463
10463: DISABLE
10464: LD_INT 0
10466: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
10467: LD_INT 3
10469: PPUSH
10470: LD_EXP 38
10474: PPUSH
10475: CALL_OW 471
// send_attack_on_cornel := true ;
10479: LD_ADDR_EXP 28
10483: PUSH
10484: LD_INT 1
10486: ST_TO_ADDR
// if ru_vehicles then
10487: LD_EXP 50
10491: IFFALSE 10525
// for i in ru_vehicles do
10493: LD_ADDR_VAR 0 1
10497: PUSH
10498: LD_EXP 50
10502: PUSH
10503: FOR_IN
10504: IFFALSE 10523
// ComAgressiveMove ( i , 215 , 69 ) ;
10506: LD_VAR 0 1
10510: PPUSH
10511: LD_INT 215
10513: PPUSH
10514: LD_INT 69
10516: PPUSH
10517: CALL_OW 114
10521: GO 10503
10523: POP
10524: POP
// if ru_patrol then
10525: LD_EXP 47
10529: IFFALSE 10563
// for i in ru_patrol do
10531: LD_ADDR_VAR 0 1
10535: PUSH
10536: LD_EXP 47
10540: PUSH
10541: FOR_IN
10542: IFFALSE 10561
// ComAgressiveMove ( i , 215 , 69 ) ;
10544: LD_VAR 0 1
10548: PPUSH
10549: LD_INT 215
10551: PPUSH
10552: LD_INT 69
10554: PPUSH
10555: CALL_OW 114
10559: GO 10541
10561: POP
10562: POP
// if frank_send_to_scout then
10563: LD_EXP 12
10567: IFFALSE 10581
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
10569: LD_EXP 45
10573: PPUSH
10574: LD_STRING D3b-Frank-1
10576: PPUSH
10577: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
10581: LD_INT 105
10583: PPUSH
10584: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
10588: LD_EXP 38
10592: PPUSH
10593: LD_STRING D4-Corn-1
10595: PPUSH
10596: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10600: LD_INT 35
10602: PPUSH
10603: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 6 ;
10607: LD_INT 22
10609: PUSH
10610: LD_INT 4
10612: PUSH
10613: EMPTY
10614: LIST
10615: LIST
10616: PUSH
10617: LD_INT 21
10619: PUSH
10620: LD_INT 1
10622: PUSH
10623: EMPTY
10624: LIST
10625: LIST
10626: PUSH
10627: LD_INT 50
10629: PUSH
10630: EMPTY
10631: LIST
10632: PUSH
10633: EMPTY
10634: LIST
10635: LIST
10636: LIST
10637: PPUSH
10638: CALL_OW 69
10642: PUSH
10643: LD_INT 6
10645: LESS
10646: IFFALSE 10600
// SayRadio ( Cornel , D5-Corn-1 ) ;
10648: LD_EXP 38
10652: PPUSH
10653: LD_STRING D5-Corn-1
10655: PPUSH
10656: CALL_OW 94
// SaveCharacters ( Cornel , Cornel ) ;
10660: LD_EXP 38
10664: PPUSH
10665: LD_STRING Cornel
10667: PPUSH
10668: CALL_OW 38
// ChangeSideFog ( 4 , 8 ) ;
10672: LD_INT 4
10674: PPUSH
10675: LD_INT 8
10677: PPUSH
10678: CALL_OW 343
// Wait ( 0 0$01 ) ;
10682: LD_INT 35
10684: PPUSH
10685: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
10689: LD_INT 3
10691: PPUSH
10692: LD_EXP 38
10696: PPUSH
10697: CALL_OW 472
// send_attack_on_cornel := false ;
10701: LD_ADDR_EXP 28
10705: PUSH
10706: LD_INT 0
10708: ST_TO_ADDR
// end ;
10709: PPOPN 1
10711: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
10712: LD_INT 9
10714: PPUSH
10715: LD_INT 22
10717: PUSH
10718: LD_INT 1
10720: PUSH
10721: EMPTY
10722: LIST
10723: LIST
10724: PPUSH
10725: CALL_OW 70
10729: PUSH
10730: LD_EXP 29
10734: OR
10735: IFFALSE 11254
10737: GO 10739
10739: DISABLE
10740: LD_INT 0
10742: PPUSH
10743: PPUSH
// begin enable ;
10744: ENABLE
// if not game_end then
10745: LD_EXP 29
10749: NOT
10750: IFFALSE 10760
// game_end := true ;
10752: LD_ADDR_EXP 29
10756: PUSH
10757: LD_INT 1
10759: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
10760: LD_ADDR_VAR 0 2
10764: PUSH
10765: LD_INT 9
10767: PPUSH
10768: LD_INT 22
10770: PUSH
10771: LD_INT 1
10773: PUSH
10774: EMPTY
10775: LIST
10776: LIST
10777: PPUSH
10778: CALL_OW 70
10782: ST_TO_ADDR
// if not filter then
10783: LD_VAR 0 2
10787: NOT
10788: IFFALSE 10792
// exit ;
10790: GO 11254
// for i in filter do
10792: LD_ADDR_VAR 0 1
10796: PUSH
10797: LD_VAR 0 2
10801: PUSH
10802: FOR_IN
10803: IFFALSE 11252
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
10805: LD_VAR 0 1
10809: PPUSH
10810: CALL_OW 302
10814: PUSH
10815: LD_VAR 0 1
10819: PPUSH
10820: CALL_OW 247
10824: PUSH
10825: LD_INT 2
10827: EQUAL
10828: AND
10829: IFFALSE 10869
// begin veh_on_meta := true ;
10831: LD_ADDR_EXP 24
10835: PUSH
10836: LD_INT 1
10838: ST_TO_ADDR
// ComExitVehicle ( IsInUnit ( i ) ) ;
10839: LD_VAR 0 1
10843: PPUSH
10844: CALL_OW 310
10848: PPUSH
10849: CALL_OW 121
// RemoveUnit ( i ) ;
10853: LD_VAR 0 1
10857: PPUSH
10858: CALL_OW 64
// Wait ( 10 ) ;
10862: LD_INT 10
10864: PPUSH
10865: CALL_OW 67
// end ; if i = JMM then
10869: LD_VAR 0 1
10873: PUSH
10874: LD_EXP 31
10878: EQUAL
10879: IFFALSE 11001
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
10881: LD_EXP 21
10885: PUSH
10886: LD_INT 22
10888: PUSH
10889: LD_INT 1
10891: PUSH
10892: EMPTY
10893: LIST
10894: LIST
10895: PUSH
10896: LD_INT 21
10898: PUSH
10899: LD_INT 1
10901: PUSH
10902: EMPTY
10903: LIST
10904: LIST
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PPUSH
10910: CALL_OW 69
10914: PUSH
10915: LD_INT 1
10917: GREATER
10918: AND
10919: IFFALSE 10976
// begin show_query := false ;
10921: LD_ADDR_EXP 21
10925: PUSH
10926: LD_INT 0
10928: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
10929: LD_STRING Q2
10931: PPUSH
10932: CALL_OW 97
10936: PUSH
10937: LD_INT 1
10939: DOUBLE
10940: EQUAL
10941: IFTRUE 10945
10943: GO 10956
10945: POP
// wait_for_them := true ; 2 :
10946: LD_ADDR_EXP 22
10950: PUSH
10951: LD_INT 1
10953: ST_TO_ADDR
10954: GO 10976
10956: LD_INT 2
10958: DOUBLE
10959: EQUAL
10960: IFTRUE 10964
10962: GO 10975
10964: POP
// wait_for_them := false ; end ;
10965: LD_ADDR_EXP 22
10969: PUSH
10970: LD_INT 0
10972: ST_TO_ADDR
10973: GO 10976
10975: POP
// end ; save_group := save_group ^ JMM ;
10976: LD_ADDR_EXP 20
10980: PUSH
10981: LD_EXP 20
10985: PUSH
10986: LD_EXP 31
10990: ADD
10991: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
10992: LD_EXP 31
10996: PPUSH
10997: CALL_OW 64
// end ; if i = Lisa then
11001: LD_VAR 0 1
11005: PUSH
11006: LD_EXP 34
11010: EQUAL
11011: IFFALSE 11038
// begin save_group := save_group ^ Lisa ;
11013: LD_ADDR_EXP 20
11017: PUSH
11018: LD_EXP 20
11022: PUSH
11023: LD_EXP 34
11027: ADD
11028: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11029: LD_EXP 34
11033: PPUSH
11034: CALL_OW 64
// end ; if i = Bobby then
11038: LD_VAR 0 1
11042: PUSH
11043: LD_EXP 32
11047: EQUAL
11048: IFFALSE 11075
// begin save_group := save_group ^ Bobby ;
11050: LD_ADDR_EXP 20
11054: PUSH
11055: LD_EXP 20
11059: PUSH
11060: LD_EXP 32
11064: ADD
11065: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11066: LD_EXP 32
11070: PPUSH
11071: CALL_OW 64
// end ; if i = Cyrus then
11075: LD_VAR 0 1
11079: PUSH
11080: LD_EXP 33
11084: EQUAL
11085: IFFALSE 11112
// begin save_group := save_group ^ Cyrus ;
11087: LD_ADDR_EXP 20
11091: PUSH
11092: LD_EXP 20
11096: PUSH
11097: LD_EXP 33
11101: ADD
11102: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11103: LD_EXP 33
11107: PPUSH
11108: CALL_OW 64
// end ; if i = Khatam then
11112: LD_VAR 0 1
11116: PUSH
11117: LD_EXP 35
11121: EQUAL
11122: IFFALSE 11149
// begin save_group := save_group ^ Khatam ;
11124: LD_ADDR_EXP 20
11128: PUSH
11129: LD_EXP 20
11133: PUSH
11134: LD_EXP 35
11138: ADD
11139: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11140: LD_EXP 35
11144: PPUSH
11145: CALL_OW 64
// end ; if i = Frank then
11149: LD_VAR 0 1
11153: PUSH
11154: LD_EXP 45
11158: EQUAL
11159: IFFALSE 11186
// begin save_group := save_group ^ Frank ;
11161: LD_ADDR_EXP 20
11165: PUSH
11166: LD_EXP 20
11170: PUSH
11171: LD_EXP 45
11175: ADD
11176: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11177: LD_EXP 45
11181: PPUSH
11182: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11186: LD_VAR 0 1
11190: PPUSH
11191: CALL_OW 302
11195: PUSH
11196: LD_VAR 0 1
11200: PPUSH
11201: CALL_OW 247
11205: PUSH
11206: LD_INT 1
11208: EQUAL
11209: AND
11210: PUSH
11211: LD_VAR 0 1
11215: PUSH
11216: LD_EXP 20
11220: IN
11221: NOT
11222: AND
11223: IFFALSE 11250
// begin save_others := save_others ^ i ;
11225: LD_ADDR_EXP 19
11229: PUSH
11230: LD_EXP 19
11234: PUSH
11235: LD_VAR 0 1
11239: ADD
11240: ST_TO_ADDR
// RemoveUnit ( i ) ;
11241: LD_VAR 0 1
11245: PPUSH
11246: CALL_OW 64
// end ; end ;
11250: GO 10802
11252: POP
11253: POP
// end ;
11254: PPOPN 2
11256: END
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
11257: LD_EXP 21
11261: NOT
11262: PUSH
11263: LD_EXP 22
11267: NOT
11268: AND
11269: PUSH
11270: LD_INT 22
11272: PUSH
11273: LD_INT 1
11275: PUSH
11276: EMPTY
11277: LIST
11278: LIST
11279: PUSH
11280: LD_INT 21
11282: PUSH
11283: LD_INT 1
11285: PUSH
11286: EMPTY
11287: LIST
11288: LIST
11289: PUSH
11290: EMPTY
11291: LIST
11292: LIST
11293: PPUSH
11294: CALL_OW 69
11298: PUSH
11299: LD_INT 0
11301: EQUAL
11302: OR
11303: IFFALSE 11312
11305: GO 11307
11307: DISABLE
// EndMission ;
11308: CALL 11313 0 0
11312: END
// export function EndMission ; var i ; begin
11313: LD_INT 0
11315: PPUSH
11316: PPUSH
// Wait ( 0 0$02 ) ;
11317: LD_INT 70
11319: PPUSH
11320: CALL_OW 67
// if solar_builded then
11324: LD_EXP 11
11328: IFFALSE 11342
// AddMedal ( Solar1 , 1 ) else
11330: LD_STRING Solar1
11332: PPUSH
11333: LD_INT 1
11335: PPUSH
11336: CALL_OW 101
11340: GO 11353
// AddMedal ( Solar1 , - 1 ) ;
11342: LD_STRING Solar1
11344: PPUSH
11345: LD_INT 1
11347: NEG
11348: PPUSH
11349: CALL_OW 101
// if veh_on_meta then
11353: LD_EXP 24
11357: IFFALSE 11371
// AddMedal ( Solar2 , 1 ) else
11359: LD_STRING Solar2
11361: PPUSH
11362: LD_INT 1
11364: PPUSH
11365: CALL_OW 101
11369: GO 11401
// if solar_builded then
11371: LD_EXP 11
11375: IFFALSE 11390
// AddMedal ( Solar2 , - 1 ) else
11377: LD_STRING Solar2
11379: PPUSH
11380: LD_INT 1
11382: NEG
11383: PPUSH
11384: CALL_OW 101
11388: GO 11401
// AddMedal ( Solar2 , - 2 ) ;
11390: LD_STRING Solar2
11392: PPUSH
11393: LD_INT 2
11395: NEG
11396: PPUSH
11397: CALL_OW 101
// if lose_counter = 0 then
11401: LD_EXP 30
11405: PUSH
11406: LD_INT 0
11408: EQUAL
11409: IFFALSE 11423
// AddMedal ( No , 1 ) else
11411: LD_STRING No
11413: PPUSH
11414: LD_INT 1
11416: PPUSH
11417: CALL_OW 101
11421: GO 11467
// if lose_counter > 0 and lose_counter < 4 then
11423: LD_EXP 30
11427: PUSH
11428: LD_INT 0
11430: GREATER
11431: PUSH
11432: LD_EXP 30
11436: PUSH
11437: LD_INT 4
11439: LESS
11440: AND
11441: IFFALSE 11456
// AddMedal ( No , - 1 ) else
11443: LD_STRING No
11445: PPUSH
11446: LD_INT 1
11448: NEG
11449: PPUSH
11450: CALL_OW 101
11454: GO 11467
// AddMedal ( UpTo4 , - 1 ) ;
11456: LD_STRING UpTo4
11458: PPUSH
11459: LD_INT 1
11461: NEG
11462: PPUSH
11463: CALL_OW 101
// GiveMedals ( MAIN ) ;
11467: LD_STRING MAIN
11469: PPUSH
11470: CALL_OW 102
// if IsDead ( Pokryshkin ) then
11474: LD_EXP 46
11478: PPUSH
11479: CALL_OW 301
11483: IFFALSE 11523
// for i in save_group ^ save_others do
11485: LD_ADDR_VAR 0 2
11489: PUSH
11490: LD_EXP 20
11494: PUSH
11495: LD_EXP 19
11499: ADD
11500: PUSH
11501: FOR_IN
11502: IFFALSE 11521
// AddExperience ( i , skill_combat , 1500 ) ;
11504: LD_VAR 0 2
11508: PPUSH
11509: LD_INT 1
11511: PPUSH
11512: LD_INT 1500
11514: PPUSH
11515: CALL_OW 492
11519: GO 11501
11521: POP
11522: POP
// RewardPeople ( save_group ^ save_others ) ;
11523: LD_EXP 20
11527: PUSH
11528: LD_EXP 19
11532: ADD
11533: PPUSH
11534: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
11538: LD_EXP 31
11542: PPUSH
11543: LD_STRING JMM
11545: PPUSH
11546: CALL_OW 38
// if Bobby in save_group then
11550: LD_EXP 32
11554: PUSH
11555: LD_EXP 20
11559: IN
11560: IFFALSE 11576
// SaveCharacters ( Bobby , Bobby ) else
11562: LD_EXP 32
11566: PPUSH
11567: LD_STRING Bobby
11569: PPUSH
11570: CALL_OW 38
11574: GO 11583
// DeleteCharacters ( Bobby ) ;
11576: LD_STRING Bobby
11578: PPUSH
11579: CALL_OW 40
// if Cyrus in save_group then
11583: LD_EXP 33
11587: PUSH
11588: LD_EXP 20
11592: IN
11593: IFFALSE 11609
// SaveCharacters ( Cyrus , Cyrus ) else
11595: LD_EXP 33
11599: PPUSH
11600: LD_STRING Cyrus
11602: PPUSH
11603: CALL_OW 38
11607: GO 11616
// DeleteCharacters ( Cyrus ) ;
11609: LD_STRING Cyrus
11611: PPUSH
11612: CALL_OW 40
// if Lisa in save_group then
11616: LD_EXP 34
11620: PUSH
11621: LD_EXP 20
11625: IN
11626: IFFALSE 11642
// SaveCharacters ( Lisa , Lisa ) else
11628: LD_EXP 34
11632: PPUSH
11633: LD_STRING Lisa
11635: PPUSH
11636: CALL_OW 38
11640: GO 11649
// DeleteCharacters ( Lisa ) ;
11642: LD_STRING Lisa
11644: PPUSH
11645: CALL_OW 40
// if Frank in save_group then
11649: LD_EXP 45
11653: PUSH
11654: LD_EXP 20
11658: IN
11659: IFFALSE 11675
// SaveCharacters ( Frank , Frank ) else
11661: LD_EXP 45
11665: PPUSH
11666: LD_STRING Frank
11668: PPUSH
11669: CALL_OW 38
11673: GO 11682
// DeleteCharacters ( Frank ) ;
11675: LD_STRING Frank
11677: PPUSH
11678: CALL_OW 40
// if Khatam in save_group then
11682: LD_EXP 35
11686: PUSH
11687: LD_EXP 20
11691: IN
11692: IFFALSE 11708
// SaveCharacters ( Khatam , Khatam ) else
11694: LD_EXP 35
11698: PPUSH
11699: LD_STRING Khatam
11701: PPUSH
11702: CALL_OW 38
11706: GO 11715
// DeleteCharacters ( Khatam ) ;
11708: LD_STRING Khatam
11710: PPUSH
11711: CALL_OW 40
// if save_others then
11715: LD_EXP 19
11719: IFFALSE 11733
// SaveCharacters ( save_others , 03_others ) ;
11721: LD_EXP 19
11725: PPUSH
11726: LD_STRING 03_others
11728: PPUSH
11729: CALL_OW 38
// DeleteCharacters ( Brian ) ;
11733: LD_STRING Brian
11735: PPUSH
11736: CALL_OW 40
// DeleteCharacters ( Jimmy ) ;
11740: LD_STRING Jimmy
11742: PPUSH
11743: CALL_OW 40
// if Bierezov and IsOk ( Bierezov ) then
11747: LD_EXP 39
11751: PUSH
11752: LD_EXP 39
11756: PPUSH
11757: CALL_OW 302
11761: AND
11762: IFFALSE 11774
// begin ResetFog ;
11764: CALL_OW 335
// DisplayEndingScene ;
11768: CALL 11790 0 0
// end else
11772: GO 11781
// DeleteCharacters ( Cornel ) ;
11774: LD_STRING Cornel
11776: PPUSH
11777: CALL_OW 40
// YouWin ;
11781: CALL_OW 103
// end ;
11785: LD_VAR 0 1
11789: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
11790: LD_INT 0
11792: PPUSH
11793: PPUSH
11794: PPUSH
11795: PPUSH
11796: PPUSH
11797: PPUSH
// InGameOn ;
11798: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
11802: LD_INT 208
11804: PPUSH
11805: LD_INT 62
11807: PPUSH
11808: LD_INT 1
11810: PPUSH
11811: LD_INT 10
11813: NEG
11814: PPUSH
11815: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
11819: LD_INT 208
11821: PPUSH
11822: LD_INT 62
11824: PPUSH
11825: LD_INT 1
11827: PPUSH
11828: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11832: LD_ADDR_VAR 0 3
11836: PUSH
11837: LD_INT 22
11839: PUSH
11840: LD_INT 3
11842: PUSH
11843: EMPTY
11844: LIST
11845: LIST
11846: PUSH
11847: LD_INT 2
11849: PUSH
11850: LD_INT 21
11852: PUSH
11853: LD_INT 2
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: LD_INT 21
11862: PUSH
11863: LD_INT 1
11865: PUSH
11866: EMPTY
11867: LIST
11868: LIST
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: LIST
11874: PUSH
11875: EMPTY
11876: LIST
11877: LIST
11878: PPUSH
11879: CALL_OW 69
11883: ST_TO_ADDR
// if filter then
11884: LD_VAR 0 3
11888: IFFALSE 11916
// for i in filter do
11890: LD_ADDR_VAR 0 2
11894: PUSH
11895: LD_VAR 0 3
11899: PUSH
11900: FOR_IN
11901: IFFALSE 11914
// RemoveUnit ( i ) ;
11903: LD_VAR 0 2
11907: PPUSH
11908: CALL_OW 64
11912: GO 11900
11914: POP
11915: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
11916: LD_ADDR_VAR 0 3
11920: PUSH
11921: LD_INT 22
11923: PUSH
11924: LD_INT 4
11926: PUSH
11927: EMPTY
11928: LIST
11929: LIST
11930: PUSH
11931: LD_INT 21
11933: PUSH
11934: LD_INT 1
11936: PUSH
11937: EMPTY
11938: LIST
11939: LIST
11940: PUSH
11941: EMPTY
11942: LIST
11943: LIST
11944: PPUSH
11945: CALL_OW 69
11949: ST_TO_ADDR
// if filter then
11950: LD_VAR 0 3
11954: IFFALSE 11985
// for i in filter do
11956: LD_ADDR_VAR 0 2
11960: PUSH
11961: LD_VAR 0 3
11965: PUSH
11966: FOR_IN
11967: IFFALSE 11983
// SetLives ( i , 0 ) ;
11969: LD_VAR 0 2
11973: PPUSH
11974: LD_INT 0
11976: PPUSH
11977: CALL_OW 234
11981: GO 11966
11983: POP
11984: POP
// uc_side := 4 ;
11985: LD_ADDR_OWVAR 20
11989: PUSH
11990: LD_INT 4
11992: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
11993: LD_ADDR_VAR 0 4
11997: PUSH
11998: LD_STRING Cornell
12000: PPUSH
12001: LD_INT 0
12003: PPUSH
12004: CALL 434 0 2
12008: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12009: LD_VAR 0 4
12013: PPUSH
12014: LD_INT 208
12016: PPUSH
12017: LD_INT 62
12019: PPUSH
12020: LD_INT 0
12022: PPUSH
12023: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12027: LD_VAR 0 4
12031: PPUSH
12032: LD_INT 100
12034: PPUSH
12035: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12039: LD_INT 3
12041: PPUSH
12042: LD_VAR 0 4
12046: PPUSH
12047: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12051: LD_INT 4
12053: PPUSH
12054: LD_INT 3
12056: PPUSH
12057: LD_INT 1
12059: PPUSH
12060: LD_INT 1
12062: PPUSH
12063: CALL_OW 80
// uc_side := 3 ;
12067: LD_ADDR_OWVAR 20
12071: PUSH
12072: LD_INT 3
12074: ST_TO_ADDR
// uc_nation := 3 ;
12075: LD_ADDR_OWVAR 21
12079: PUSH
12080: LD_INT 3
12082: ST_TO_ADDR
// InitHc ;
12083: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12087: LD_ADDR_VAR 0 5
12091: PUSH
12092: LD_STRING Mikhail
12094: PPUSH
12095: LD_INT 0
12097: PPUSH
12098: CALL 434 0 2
12102: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12103: LD_INT 1
12105: PPUSH
12106: LD_INT 1
12108: PPUSH
12109: LD_INT 0
12111: PPUSH
12112: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12116: LD_ADDR_VAR 0 6
12120: PUSH
12121: LD_VAR 0 6
12125: PUSH
12126: CALL_OW 44
12130: ADD
12131: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12132: LD_ADDR_VAR 0 6
12136: PUSH
12137: LD_VAR 0 6
12141: PUSH
12142: CALL_OW 44
12146: ADD
12147: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12148: LD_INT 2
12150: PPUSH
12151: LD_INT 4
12153: PPUSH
12154: LD_INT 0
12156: PPUSH
12157: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12161: LD_ADDR_VAR 0 6
12165: PUSH
12166: LD_VAR 0 6
12170: PUSH
12171: CALL_OW 44
12175: ADD
12176: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12177: LD_VAR 0 5
12181: PPUSH
12182: LD_INT 17
12184: PPUSH
12185: LD_INT 0
12187: PPUSH
12188: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12192: LD_VAR 0 5
12196: PPUSH
12197: LD_INT 210
12199: PPUSH
12200: LD_INT 63
12202: PPUSH
12203: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12207: LD_VAR 0 5
12211: PPUSH
12212: LD_INT 208
12214: PPUSH
12215: LD_INT 62
12217: PPUSH
12218: CALL_OW 178
// for i in fake_russians do
12222: LD_ADDR_VAR 0 2
12226: PUSH
12227: LD_VAR 0 6
12231: PUSH
12232: FOR_IN
12233: IFFALSE 12311
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12235: LD_VAR 0 2
12239: PPUSH
12240: LD_INT 17
12242: PPUSH
12243: LD_INT 0
12245: PPUSH
12246: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
12250: LD_VAR 0 2
12254: PPUSH
12255: LD_INT 215
12257: PPUSH
12258: LD_INT 67
12260: PPUSH
12261: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
12265: LD_VAR 0 2
12269: PPUSH
12270: LD_INT 208
12272: PPUSH
12273: LD_INT 62
12275: PPUSH
12276: CALL_OW 178
// if GetClass ( i ) = 4 then
12280: LD_VAR 0 2
12284: PPUSH
12285: CALL_OW 257
12289: PUSH
12290: LD_INT 4
12292: EQUAL
12293: IFFALSE 12309
// ComHeal ( i , fake_cornel ) ;
12295: LD_VAR 0 2
12299: PPUSH
12300: LD_VAR 0 4
12304: PPUSH
12305: CALL_OW 128
// end ;
12309: GO 12232
12311: POP
12312: POP
// Wait ( 0 0$01 ) ;
12313: LD_INT 35
12315: PPUSH
12316: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
12320: LD_INT 208
12322: PPUSH
12323: LD_INT 62
12325: PPUSH
12326: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12330: LD_INT 208
12332: PPUSH
12333: LD_INT 62
12335: PPUSH
12336: LD_INT 1
12338: PPUSH
12339: LD_INT 10
12341: NEG
12342: PPUSH
12343: CALL_OW 330
// Wait ( 0 0$15 ) ;
12347: LD_INT 525
12349: PPUSH
12350: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
12354: LD_INT 208
12356: PPUSH
12357: LD_INT 62
12359: PPUSH
12360: LD_INT 1
12362: PPUSH
12363: CALL_OW 331
// ResetFog ;
12367: CALL_OW 335
// InGameOff ;
12371: CALL_OW 9
// end ;
12375: LD_VAR 0 1
12379: RET
// every 0 0$30 trigger GetDistUnits ( JMM , Cornel ) < 3 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) do
12380: LD_EXP 31
12384: PPUSH
12385: LD_EXP 38
12389: PPUSH
12390: CALL_OW 296
12394: PUSH
12395: LD_INT 3
12397: LESS
12398: PUSH
12399: LD_INT 22
12401: PUSH
12402: LD_INT 4
12404: PUSH
12405: EMPTY
12406: LIST
12407: LIST
12408: PUSH
12409: LD_INT 21
12411: PUSH
12412: LD_INT 3
12414: PUSH
12415: EMPTY
12416: LIST
12417: LIST
12418: PUSH
12419: EMPTY
12420: LIST
12421: LIST
12422: PPUSH
12423: CALL_OW 69
12427: AND
12428: IFFALSE 12446
12430: GO 12432
12432: DISABLE
// begin enable ;
12433: ENABLE
// SayRadio ( Powell , DWarn-Pow-1 ) ;
12434: LD_EXP 40
12438: PPUSH
12439: LD_STRING DWarn-Pow-1
12441: PPUSH
12442: CALL_OW 94
// end ; end_of_file
12446: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
12447: LD_EXP 6
12451: IFFALSE 13677
12453: GO 12455
12455: DISABLE
12456: LD_INT 0
12458: PPUSH
12459: PPUSH
12460: PPUSH
12461: PPUSH
12462: PPUSH
12463: PPUSH
12464: PPUSH
12465: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
12466: LD_EXP 38
12470: PUSH
12471: LD_EXP 39
12475: ADD
12476: PUSH
12477: LD_EXP 4
12481: ADD
12482: PPUSH
12483: LD_INT 250
12485: PPUSH
12486: LD_INT 120
12488: PPUSH
12489: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
12493: LD_ADDR_VAR 0 2
12497: PUSH
12498: LD_EXP 4
12502: PPUSH
12503: LD_INT 25
12505: PUSH
12506: LD_INT 2
12508: PUSH
12509: EMPTY
12510: LIST
12511: LIST
12512: PPUSH
12513: CALL_OW 72
12517: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
12518: LD_ADDR_VAR 0 3
12522: PUSH
12523: LD_EXP 4
12527: PPUSH
12528: LD_INT 21
12530: PUSH
12531: LD_INT 1
12533: PUSH
12534: EMPTY
12535: LIST
12536: LIST
12537: PPUSH
12538: CALL_OW 72
12542: ST_TO_ADDR
// if not has_eng then
12543: LD_VAR 0 2
12547: NOT
12548: IFFALSE 12631
// begin uc_side := 4 ;
12550: LD_ADDR_OWVAR 20
12554: PUSH
12555: LD_INT 4
12557: ST_TO_ADDR
// uc_nation := 1 ;
12558: LD_ADDR_OWVAR 21
12562: PUSH
12563: LD_INT 1
12565: ST_TO_ADDR
// bc_type := b_depot ;
12566: LD_ADDR_OWVAR 42
12570: PUSH
12571: LD_INT 0
12573: ST_TO_ADDR
// bc_level := 2 ;
12574: LD_ADDR_OWVAR 43
12578: PUSH
12579: LD_INT 2
12581: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
12582: LD_ADDR_VAR 0 4
12586: PUSH
12587: LD_INT 264
12589: PPUSH
12590: LD_INT 120
12592: PPUSH
12593: LD_INT 4
12595: PPUSH
12596: CALL_OW 47
12600: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
12601: LD_INT 264
12603: PPUSH
12604: LD_INT 120
12606: PPUSH
12607: LD_INT 4
12609: PPUSH
12610: LD_INT 10
12612: NEG
12613: PPUSH
12614: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
12618: LD_INT 264
12620: PPUSH
12621: LD_INT 120
12623: PPUSH
12624: LD_INT 4
12626: PPUSH
12627: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
12631: LD_INT 35
12633: PPUSH
12634: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
12638: LD_EXP 38
12642: PPUSH
12643: LD_INT 10
12645: PPUSH
12646: CALL_OW 308
12650: IFFALSE 12631
// if has_eng and not dep then
12652: LD_VAR 0 2
12656: PUSH
12657: LD_VAR 0 4
12661: NOT
12662: AND
12663: IFFALSE 12777
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
12665: LD_VAR 0 2
12669: PPUSH
12670: LD_INT 0
12672: PPUSH
12673: LD_INT 264
12675: PPUSH
12676: LD_INT 120
12678: PPUSH
12679: LD_INT 4
12681: PPUSH
12682: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
12686: LD_INT 35
12688: PPUSH
12689: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
12693: LD_INT 22
12695: PUSH
12696: LD_INT 4
12698: PUSH
12699: EMPTY
12700: LIST
12701: LIST
12702: PUSH
12703: LD_INT 30
12705: PUSH
12706: LD_INT 0
12708: PUSH
12709: EMPTY
12710: LIST
12711: LIST
12712: PUSH
12713: LD_INT 3
12715: PUSH
12716: LD_INT 57
12718: PUSH
12719: EMPTY
12720: LIST
12721: PUSH
12722: EMPTY
12723: LIST
12724: LIST
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: LIST
12730: PPUSH
12731: CALL_OW 69
12735: IFFALSE 12686
// dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
12737: LD_ADDR_VAR 0 4
12741: PUSH
12742: LD_INT 22
12744: PUSH
12745: LD_INT 4
12747: PUSH
12748: EMPTY
12749: LIST
12750: LIST
12751: PUSH
12752: LD_INT 30
12754: PUSH
12755: LD_INT 0
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PUSH
12762: EMPTY
12763: LIST
12764: LIST
12765: PPUSH
12766: CALL_OW 69
12770: PUSH
12771: LD_INT 1
12773: ARRAY
12774: ST_TO_ADDR
// end else
12775: GO 12894
// begin SetSide ( dep , 4 ) ;
12777: LD_VAR 0 4
12781: PPUSH
12782: LD_INT 4
12784: PPUSH
12785: CALL_OW 235
// for i = 1 to 3 do
12789: LD_ADDR_VAR 0 1
12793: PUSH
12794: DOUBLE
12795: LD_INT 1
12797: DEC
12798: ST_TO_ADDR
12799: LD_INT 3
12801: PUSH
12802: FOR_TO
12803: IFFALSE 12860
// begin ComEnterUnit ( filter [ i ] , dep ) ;
12805: LD_VAR 0 3
12809: PUSH
12810: LD_VAR 0 1
12814: ARRAY
12815: PPUSH
12816: LD_VAR 0 4
12820: PPUSH
12821: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
12825: LD_VAR 0 3
12829: PUSH
12830: LD_VAR 0 1
12834: ARRAY
12835: PPUSH
12836: LD_INT 2
12838: PPUSH
12839: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
12843: LD_VAR 0 3
12847: PUSH
12848: LD_VAR 0 1
12852: ARRAY
12853: PPUSH
12854: CALL_OW 182
// end ;
12858: GO 12802
12860: POP
12861: POP
// repeat wait ( 0 0$01 ) ;
12862: LD_INT 35
12864: PPUSH
12865: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
12869: LD_VAR 0 3
12873: PPUSH
12874: LD_INT 25
12876: PUSH
12877: LD_INT 2
12879: PUSH
12880: EMPTY
12881: LIST
12882: LIST
12883: PPUSH
12884: CALL_OW 72
12888: PUSH
12889: LD_INT 3
12891: EQUAL
12892: IFFALSE 12862
// end ; if IsInUnit ( Cornel ) then
12894: LD_EXP 38
12898: PPUSH
12899: CALL_OW 310
12903: IFFALSE 12986
// begin cargo := IsInUnit ( Cornel ) ;
12905: LD_ADDR_VAR 0 7
12909: PUSH
12910: LD_EXP 38
12914: PPUSH
12915: CALL_OW 310
12919: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
12920: LD_VAR 0 7
12924: PPUSH
12925: LD_INT 1
12927: PPUSH
12928: CALL_OW 289
12932: IFFALSE 12948
// ComGive ( Cornel , dep ) ;
12934: LD_EXP 38
12938: PPUSH
12939: LD_VAR 0 4
12943: PPUSH
12944: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
12948: LD_EXP 38
12952: PPUSH
12953: LD_INT 235
12955: PPUSH
12956: LD_INT 122
12958: PPUSH
12959: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
12963: LD_EXP 38
12967: PPUSH
12968: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
12972: LD_EXP 38
12976: PPUSH
12977: LD_VAR 0 4
12981: PPUSH
12982: CALL_OW 180
// end ; ComEnterUnit ( Bierezov , dep ) ;
12986: LD_EXP 39
12990: PPUSH
12991: LD_VAR 0 4
12995: PPUSH
12996: CALL_OW 120
// has_eng := UnitFilter ( filter , [ f_class , 2 ] ) ;
13000: LD_ADDR_VAR 0 2
13004: PUSH
13005: LD_VAR 0 3
13009: PPUSH
13010: LD_INT 25
13012: PUSH
13013: LD_INT 2
13015: PUSH
13016: EMPTY
13017: LIST
13018: LIST
13019: PPUSH
13020: CALL_OW 72
13024: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13025: LD_INT 35
13027: PPUSH
13028: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13032: LD_ADDR_VAR 0 6
13036: PUSH
13037: LD_INT 10
13039: PPUSH
13040: CALL_OW 435
13044: ST_TO_ADDR
// if crates then
13045: LD_VAR 0 6
13049: IFFALSE 13078
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
13051: LD_VAR 0 2
13055: PPUSH
13056: LD_VAR 0 6
13060: PUSH
13061: LD_INT 1
13063: ARRAY
13064: PPUSH
13065: LD_VAR 0 6
13069: PUSH
13070: LD_INT 2
13072: ARRAY
13073: PPUSH
13074: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
13078: LD_VAR 0 4
13082: PPUSH
13083: CALL_OW 274
13087: PPUSH
13088: LD_INT 1
13090: PPUSH
13091: CALL_OW 275
13095: PUSH
13096: LD_INT 40
13098: GREATEREQUAL
13099: IFFALSE 13025
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
13101: LD_ADDR_VAR 0 5
13105: PUSH
13106: LD_INT 4
13108: PUSH
13109: LD_INT 256
13111: PUSH
13112: LD_INT 111
13114: PUSH
13115: LD_INT 2
13117: PUSH
13118: EMPTY
13119: LIST
13120: LIST
13121: LIST
13122: LIST
13123: PUSH
13124: LD_INT 31
13126: PUSH
13127: LD_INT 243
13129: PUSH
13130: LD_INT 112
13132: PUSH
13133: LD_INT 2
13135: PUSH
13136: EMPTY
13137: LIST
13138: LIST
13139: LIST
13140: LIST
13141: PUSH
13142: EMPTY
13143: LIST
13144: LIST
13145: ST_TO_ADDR
// for i in blist do
13146: LD_ADDR_VAR 0 1
13150: PUSH
13151: LD_VAR 0 5
13155: PUSH
13156: FOR_IN
13157: IFFALSE 13206
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
13159: LD_VAR 0 2
13163: PPUSH
13164: LD_VAR 0 1
13168: PUSH
13169: LD_INT 1
13171: ARRAY
13172: PPUSH
13173: LD_VAR 0 1
13177: PUSH
13178: LD_INT 2
13180: ARRAY
13181: PPUSH
13182: LD_VAR 0 1
13186: PUSH
13187: LD_INT 3
13189: ARRAY
13190: PPUSH
13191: LD_VAR 0 1
13195: PUSH
13196: LD_INT 4
13198: ARRAY
13199: PPUSH
13200: CALL_OW 205
13204: GO 13156
13206: POP
13207: POP
// repeat wait ( 0 0$01 ) ;
13208: LD_INT 35
13210: PPUSH
13211: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
13215: LD_INT 22
13217: PUSH
13218: LD_INT 4
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: PUSH
13225: LD_INT 30
13227: PUSH
13228: LD_INT 4
13230: PUSH
13231: EMPTY
13232: LIST
13233: LIST
13234: PUSH
13235: LD_INT 3
13237: PUSH
13238: LD_INT 57
13240: PUSH
13241: EMPTY
13242: LIST
13243: PUSH
13244: EMPTY
13245: LIST
13246: LIST
13247: PUSH
13248: EMPTY
13249: LIST
13250: LIST
13251: LIST
13252: PPUSH
13253: CALL_OW 69
13257: IFFALSE 13208
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
13259: LD_VAR 0 3
13263: PUSH
13264: LD_VAR 0 2
13268: DIFF
13269: PPUSH
13270: LD_INT 22
13272: PUSH
13273: LD_INT 4
13275: PUSH
13276: EMPTY
13277: LIST
13278: LIST
13279: PUSH
13280: LD_INT 30
13282: PUSH
13283: LD_INT 4
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: PUSH
13290: EMPTY
13291: LIST
13292: LIST
13293: PPUSH
13294: CALL_OW 69
13298: PUSH
13299: LD_INT 1
13301: ARRAY
13302: PPUSH
13303: CALL_OW 180
// repeat wait ( 0 0$01 ) ;
13307: LD_INT 35
13309: PPUSH
13310: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
13314: LD_INT 22
13316: PUSH
13317: LD_INT 4
13319: PUSH
13320: EMPTY
13321: LIST
13322: LIST
13323: PUSH
13324: LD_INT 30
13326: PUSH
13327: LD_INT 31
13329: PUSH
13330: EMPTY
13331: LIST
13332: LIST
13333: PUSH
13334: LD_INT 3
13336: PUSH
13337: LD_INT 57
13339: PUSH
13340: EMPTY
13341: LIST
13342: PUSH
13343: EMPTY
13344: LIST
13345: LIST
13346: PUSH
13347: EMPTY
13348: LIST
13349: LIST
13350: LIST
13351: PPUSH
13352: CALL_OW 69
13356: IFFALSE 13307
// sol := filter diff has_eng ;
13358: LD_ADDR_VAR 0 8
13362: PUSH
13363: LD_VAR 0 3
13367: PUSH
13368: LD_VAR 0 2
13372: DIFF
13373: ST_TO_ADDR
// if GetClass ( sol [ 1 ] ) > 1 then
13374: LD_VAR 0 8
13378: PUSH
13379: LD_INT 1
13381: ARRAY
13382: PPUSH
13383: CALL_OW 257
13387: PUSH
13388: LD_INT 1
13390: GREATER
13391: IFFALSE 13409
// SetClass ( sol [ 1 ] , 1 ) ;
13393: LD_VAR 0 8
13397: PUSH
13398: LD_INT 1
13400: ARRAY
13401: PPUSH
13402: LD_INT 1
13404: PPUSH
13405: CALL_OW 336
// ComExitBuilding ( sol [ 1 ] ) ;
13409: LD_VAR 0 8
13413: PUSH
13414: LD_INT 1
13416: ARRAY
13417: PPUSH
13418: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
13422: LD_VAR 0 8
13426: PUSH
13427: LD_INT 1
13429: ARRAY
13430: PPUSH
13431: LD_INT 22
13433: PUSH
13434: LD_INT 4
13436: PUSH
13437: EMPTY
13438: LIST
13439: LIST
13440: PUSH
13441: LD_INT 30
13443: PUSH
13444: LD_INT 31
13446: PUSH
13447: EMPTY
13448: LIST
13449: LIST
13450: PUSH
13451: EMPTY
13452: LIST
13453: LIST
13454: PPUSH
13455: CALL_OW 69
13459: PUSH
13460: LD_INT 1
13462: ARRAY
13463: PPUSH
13464: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
13468: LD_VAR 0 2
13472: PPUSH
13473: LD_VAR 0 4
13477: PPUSH
13478: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
13482: LD_INT 35
13484: PPUSH
13485: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13489: LD_ADDR_VAR 0 3
13493: PUSH
13494: LD_INT 22
13496: PUSH
13497: LD_INT 4
13499: PUSH
13500: EMPTY
13501: LIST
13502: LIST
13503: PUSH
13504: LD_INT 21
13506: PUSH
13507: LD_INT 3
13509: PUSH
13510: EMPTY
13511: LIST
13512: LIST
13513: PUSH
13514: LD_INT 3
13516: PUSH
13517: LD_INT 24
13519: PUSH
13520: LD_INT 1000
13522: PUSH
13523: EMPTY
13524: LIST
13525: LIST
13526: PUSH
13527: EMPTY
13528: LIST
13529: LIST
13530: PUSH
13531: EMPTY
13532: LIST
13533: LIST
13534: LIST
13535: PPUSH
13536: CALL_OW 69
13540: ST_TO_ADDR
// if filter and has_eng then
13541: LD_VAR 0 3
13545: PUSH
13546: LD_VAR 0 2
13550: AND
13551: IFFALSE 13617
// begin for i in has_eng do
13553: LD_ADDR_VAR 0 1
13557: PUSH
13558: LD_VAR 0 2
13562: PUSH
13563: FOR_IN
13564: IFFALSE 13613
// begin if IsInUnit ( i ) then
13566: LD_VAR 0 1
13570: PPUSH
13571: CALL_OW 310
13575: IFFALSE 13586
// ComExitBuilding ( i ) ;
13577: LD_VAR 0 1
13581: PPUSH
13582: CALL_OW 122
// Wait ( 3 ) ;
13586: LD_INT 3
13588: PPUSH
13589: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
13593: LD_VAR 0 1
13597: PPUSH
13598: LD_VAR 0 3
13602: PUSH
13603: LD_INT 1
13605: ARRAY
13606: PPUSH
13607: CALL_OW 130
// end ;
13611: GO 13563
13613: POP
13614: POP
// end else
13615: GO 13671
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
13617: LD_VAR 0 2
13621: PUSH
13622: LD_VAR 0 2
13626: PPUSH
13627: LD_INT 56
13629: PUSH
13630: EMPTY
13631: LIST
13632: PPUSH
13633: CALL_OW 72
13637: AND
13638: IFFALSE 13671
// for i in has_eng do
13640: LD_ADDR_VAR 0 1
13644: PUSH
13645: LD_VAR 0 2
13649: PUSH
13650: FOR_IN
13651: IFFALSE 13669
// ComEnterUnit ( i , dep ) ;
13653: LD_VAR 0 1
13657: PPUSH
13658: LD_VAR 0 4
13662: PPUSH
13663: CALL_OW 120
13667: GO 13650
13669: POP
13670: POP
// until cornel_prepared ;
13671: LD_EXP 9
13675: IFFALSE 13482
// end ;
13677: PPOPN 8
13679: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
13680: LD_EXP 9
13684: IFFALSE 14033
13686: GO 13688
13688: DISABLE
13689: LD_INT 0
13691: PPUSH
13692: PPUSH
13693: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
13694: LD_ADDR_VAR 0 2
13698: PUSH
13699: LD_INT 22
13701: PUSH
13702: LD_INT 4
13704: PUSH
13705: EMPTY
13706: LIST
13707: LIST
13708: PUSH
13709: LD_INT 30
13711: PUSH
13712: LD_INT 4
13714: PUSH
13715: EMPTY
13716: LIST
13717: LIST
13718: PUSH
13719: EMPTY
13720: LIST
13721: LIST
13722: PPUSH
13723: CALL_OW 69
13727: PUSH
13728: LD_INT 1
13730: ARRAY
13731: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
13732: LD_EXP 4
13736: PPUSH
13737: CALL_OW 122
// Wait ( 0 0$03 ) ;
13741: LD_INT 105
13743: PPUSH
13744: CALL_OW 67
// for i in cornel_units do
13748: LD_ADDR_VAR 0 1
13752: PUSH
13753: LD_EXP 4
13757: PUSH
13758: FOR_IN
13759: IFFALSE 13835
// begin if GetClass ( i ) in [ 2 , 3 ] then
13761: LD_VAR 0 1
13765: PPUSH
13766: CALL_OW 257
13770: PUSH
13771: LD_INT 2
13773: PUSH
13774: LD_INT 3
13776: PUSH
13777: EMPTY
13778: LIST
13779: LIST
13780: IN
13781: IFFALSE 13818
// begin ComEnterUnit ( i , arm ) ;
13783: LD_VAR 0 1
13787: PPUSH
13788: LD_VAR 0 2
13792: PPUSH
13793: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
13797: LD_VAR 0 1
13801: PPUSH
13802: LD_INT 1
13804: PPUSH
13805: CALL_OW 183
// AddComExitBuilding ( i ) ;
13809: LD_VAR 0 1
13813: PPUSH
13814: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
13818: LD_VAR 0 1
13822: PPUSH
13823: LD_INT 257
13825: PPUSH
13826: LD_INT 121
13828: PPUSH
13829: CALL_OW 171
// end ;
13833: GO 13758
13835: POP
13836: POP
// Wait ( 1 1$00 ) ;
13837: LD_INT 2100
13839: PPUSH
13840: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
13844: LD_ADDR_VAR 0 3
13848: PUSH
13849: LD_EXP 38
13853: PUSH
13854: LD_EXP 39
13858: ADD
13859: PUSH
13860: LD_EXP 4
13864: ADD
13865: PUSH
13866: LD_EXP 4
13870: PPUSH
13871: LD_INT 21
13873: PUSH
13874: LD_INT 2
13876: PUSH
13877: EMPTY
13878: LIST
13879: LIST
13880: PPUSH
13881: CALL_OW 72
13885: DIFF
13886: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
13887: LD_VAR 0 3
13891: PPUSH
13892: LD_INT 248
13894: PPUSH
13895: LD_INT 85
13897: PPUSH
13898: CALL_OW 111
// AddComHold ( filter ) ;
13902: LD_VAR 0 3
13906: PPUSH
13907: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
13911: LD_INT 35
13913: PPUSH
13914: CALL_OW 67
// until cornel_attack ;
13918: LD_EXP 7
13922: IFFALSE 13911
// ComAgressiveMove ( filter , 209 , 63 ) ;
13924: LD_VAR 0 3
13928: PPUSH
13929: LD_INT 209
13931: PPUSH
13932: LD_INT 63
13934: PPUSH
13935: CALL_OW 114
// if Bierezov then
13939: LD_EXP 39
13943: IFFALSE 14033
// begin filter := filter diff Bierezov ;
13945: LD_ADDR_VAR 0 3
13949: PUSH
13950: LD_VAR 0 3
13954: PUSH
13955: LD_EXP 39
13959: DIFF
13960: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
13961: LD_EXP 39
13965: PPUSH
13966: LD_INT 6
13968: PPUSH
13969: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
13973: LD_EXP 39
13977: PPUSH
13978: LD_INT 235
13980: PPUSH
13981: LD_INT 60
13983: PPUSH
13984: CALL_OW 111
// AddComHold ( Bierezov ) ;
13988: LD_EXP 39
13992: PPUSH
13993: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
13997: LD_EXP 39
14001: PPUSH
14002: LD_INT 350
14004: PPUSH
14005: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
14009: LD_EXP 39
14013: PPUSH
14014: LD_INT 198
14016: PPUSH
14017: LD_INT 28
14019: PPUSH
14020: CALL_OW 171
// AddComHold ( Bierezov ) ;
14024: LD_EXP 39
14028: PPUSH
14029: CALL_OW 200
// end ; end ; end_of_file
14033: PPOPN 3
14035: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
14036: LD_EXP 47
14040: PUSH
14041: LD_EXP 27
14045: NOT
14046: AND
14047: PUSH
14048: LD_EXP 28
14052: NOT
14053: AND
14054: IFFALSE 14504
14056: GO 14058
14058: DISABLE
14059: LD_INT 0
14061: PPUSH
14062: PPUSH
14063: PPUSH
14064: PPUSH
// begin enable ;
14065: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14066: LD_ADDR_VAR 0 4
14070: PUSH
14071: LD_INT 81
14073: PUSH
14074: LD_INT 3
14076: PUSH
14077: EMPTY
14078: LIST
14079: LIST
14080: PPUSH
14081: CALL_OW 69
14085: ST_TO_ADDR
// for i = 1 to ru_patrol do
14086: LD_ADDR_VAR 0 2
14090: PUSH
14091: DOUBLE
14092: LD_INT 1
14094: DEC
14095: ST_TO_ADDR
14096: LD_EXP 47
14100: PUSH
14101: FOR_TO
14102: IFFALSE 14502
// begin un := ru_patrol [ i ] ;
14104: LD_ADDR_VAR 0 1
14108: PUSH
14109: LD_EXP 47
14113: PUSH
14114: LD_VAR 0 2
14118: ARRAY
14119: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14120: LD_VAR 0 1
14124: PPUSH
14125: LD_INT 13
14127: PPUSH
14128: CALL_OW 308
14132: IFFALSE 14237
// begin if not ru_alert then
14134: LD_EXP 54
14138: NOT
14139: IFFALSE 14149
// ru_alert := true ;
14141: LD_ADDR_EXP 54
14145: PUSH
14146: LD_INT 1
14148: ST_TO_ADDR
// if not See ( 1 , un ) then
14149: LD_INT 1
14151: PPUSH
14152: LD_VAR 0 1
14156: PPUSH
14157: CALL_OW 292
14161: NOT
14162: IFFALSE 14176
// SetLives ( un , 1000 ) ;
14164: LD_VAR 0 1
14168: PPUSH
14169: LD_INT 1000
14171: PPUSH
14172: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
14176: LD_ADDR_EXP 47
14180: PUSH
14181: LD_EXP 47
14185: PUSH
14186: LD_VAR 0 1
14190: DIFF
14191: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
14192: LD_VAR 0 1
14196: PPUSH
14197: LD_INT 22
14199: PUSH
14200: LD_INT 3
14202: PUSH
14203: EMPTY
14204: LIST
14205: LIST
14206: PUSH
14207: LD_INT 30
14209: PUSH
14210: LD_INT 4
14212: PUSH
14213: EMPTY
14214: LIST
14215: LIST
14216: PUSH
14217: EMPTY
14218: LIST
14219: LIST
14220: PPUSH
14221: CALL_OW 69
14225: PPUSH
14226: CALL 1026 0 1
14230: PPUSH
14231: CALL_OW 120
// continue ;
14235: GO 14101
// end ; if IsOk ( un ) and not HasTask ( un ) then
14237: LD_VAR 0 1
14241: PPUSH
14242: CALL_OW 302
14246: PUSH
14247: LD_VAR 0 1
14251: PPUSH
14252: CALL_OW 314
14256: NOT
14257: AND
14258: IFFALSE 14351
// begin for j = 1 to ru_firepoints_south [ i ] do
14260: LD_ADDR_VAR 0 3
14264: PUSH
14265: DOUBLE
14266: LD_INT 1
14268: DEC
14269: ST_TO_ADDR
14270: LD_EXP 53
14274: PUSH
14275: LD_VAR 0 2
14279: ARRAY
14280: PUSH
14281: FOR_TO
14282: IFFALSE 14349
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
14284: LD_VAR 0 1
14288: PPUSH
14289: LD_EXP 53
14293: PUSH
14294: LD_VAR 0 2
14298: ARRAY
14299: PUSH
14300: LD_VAR 0 3
14304: ARRAY
14305: PUSH
14306: LD_INT 1
14308: ARRAY
14309: PPUSH
14310: LD_EXP 53
14314: PUSH
14315: LD_VAR 0 2
14319: ARRAY
14320: PUSH
14321: LD_VAR 0 3
14325: ARRAY
14326: PUSH
14327: LD_INT 2
14329: ARRAY
14330: PPUSH
14331: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
14335: LD_VAR 0 1
14339: PPUSH
14340: LD_INT 70
14342: PPUSH
14343: CALL_OW 202
// end ;
14347: GO 14281
14349: POP
14350: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
14351: LD_VAR 0 1
14355: PPUSH
14356: CALL_OW 256
14360: PUSH
14361: LD_INT 700
14363: LESS
14364: PUSH
14365: LD_VAR 0 1
14369: PPUSH
14370: LD_INT 13
14372: PPUSH
14373: CALL_OW 308
14377: NOT
14378: AND
14379: IFFALSE 14431
// begin ComMoveToArea ( un , retreatArea ) ;
14381: LD_VAR 0 1
14385: PPUSH
14386: LD_INT 13
14388: PPUSH
14389: CALL_OW 113
// if not ru_alert_xy then
14393: LD_EXP 55
14397: NOT
14398: IFFALSE 14429
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
14400: LD_ADDR_EXP 55
14404: PUSH
14405: LD_VAR 0 1
14409: PPUSH
14410: CALL_OW 250
14414: PUSH
14415: LD_VAR 0 1
14419: PPUSH
14420: CALL_OW 251
14424: PUSH
14425: EMPTY
14426: LIST
14427: LIST
14428: ST_TO_ADDR
// end else
14429: GO 14500
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
14431: LD_VAR 0 1
14435: PPUSH
14436: LD_VAR 0 4
14440: PPUSH
14441: LD_VAR 0 1
14445: PPUSH
14446: CALL_OW 74
14450: PPUSH
14451: CALL_OW 296
14455: PUSH
14456: LD_INT 9
14458: LESS
14459: PUSH
14460: LD_VAR 0 1
14464: PPUSH
14465: CALL_OW 256
14469: PUSH
14470: LD_INT 500
14472: GREATER
14473: AND
14474: IFFALSE 14500
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
14476: LD_VAR 0 1
14480: PPUSH
14481: LD_VAR 0 4
14485: PPUSH
14486: LD_VAR 0 1
14490: PPUSH
14491: CALL_OW 74
14495: PPUSH
14496: CALL_OW 115
// end ;
14500: GO 14101
14502: POP
14503: POP
// end ;
14504: PPOPN 4
14506: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
14507: LD_EXP 54
14511: PUSH
14512: LD_EXP 55
14516: AND
14517: PUSH
14518: LD_EXP 27
14522: NOT
14523: AND
14524: PUSH
14525: LD_EXP 28
14529: NOT
14530: AND
14531: IFFALSE 14741
14533: GO 14535
14535: DISABLE
14536: LD_INT 0
14538: PPUSH
14539: PPUSH
// begin enable ;
14540: ENABLE
// if not ru_vehicles then
14541: LD_EXP 50
14545: NOT
14546: IFFALSE 14550
// exit ;
14548: GO 14741
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14550: LD_ADDR_VAR 0 2
14554: PUSH
14555: LD_INT 81
14557: PUSH
14558: LD_INT 3
14560: PUSH
14561: EMPTY
14562: LIST
14563: LIST
14564: PPUSH
14565: CALL_OW 69
14569: ST_TO_ADDR
// if ru_vehicles then
14570: LD_EXP 50
14574: IFFALSE 14741
// begin for i in ru_vehicles do
14576: LD_ADDR_VAR 0 1
14580: PUSH
14581: LD_EXP 50
14585: PUSH
14586: FOR_IN
14587: IFFALSE 14739
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
14589: LD_VAR 0 1
14593: PPUSH
14594: CALL_OW 302
14598: PUSH
14599: LD_VAR 0 1
14603: PPUSH
14604: LD_VAR 0 2
14608: PPUSH
14609: LD_VAR 0 1
14613: PPUSH
14614: CALL_OW 74
14618: PPUSH
14619: CALL_OW 296
14623: PUSH
14624: LD_INT 9
14626: LESS
14627: AND
14628: IFFALSE 14654
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
14630: LD_VAR 0 1
14634: PPUSH
14635: LD_VAR 0 2
14639: PPUSH
14640: LD_VAR 0 1
14644: PPUSH
14645: CALL_OW 74
14649: PPUSH
14650: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
14654: LD_VAR 0 1
14658: PPUSH
14659: CALL_OW 314
14663: NOT
14664: PUSH
14665: LD_VAR 0 1
14669: PPUSH
14670: CALL_OW 302
14674: AND
14675: PUSH
14676: LD_VAR 0 1
14680: PPUSH
14681: LD_EXP 55
14685: PUSH
14686: LD_INT 1
14688: ARRAY
14689: PPUSH
14690: LD_EXP 55
14694: PUSH
14695: LD_INT 2
14697: ARRAY
14698: PPUSH
14699: CALL_OW 297
14703: PUSH
14704: LD_INT 10
14706: GREATER
14707: AND
14708: IFFALSE 14737
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
14710: LD_VAR 0 1
14714: PPUSH
14715: LD_EXP 55
14719: PUSH
14720: LD_INT 1
14722: ARRAY
14723: PPUSH
14724: LD_EXP 55
14728: PUSH
14729: LD_INT 2
14731: ARRAY
14732: PPUSH
14733: CALL_OW 114
// end ;
14737: GO 14586
14739: POP
14740: POP
// end ; end ;
14741: PPOPN 2
14743: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
14744: LD_EXP 55
14748: PUSH
14749: LD_EXP 54
14753: AND
14754: PUSH
14755: LD_INT 3
14757: PPUSH
14758: CALL_OW 463
14762: NOT
14763: AND
14764: PUSH
14765: LD_EXP 27
14769: NOT
14770: AND
14771: PUSH
14772: LD_EXP 28
14776: NOT
14777: AND
14778: IFFALSE 14873
14780: GO 14782
14782: DISABLE
14783: LD_INT 0
14785: PPUSH
// begin enable ;
14786: ENABLE
// ru_alert_xy := false ;
14787: LD_ADDR_EXP 55
14791: PUSH
14792: LD_INT 0
14794: ST_TO_ADDR
// ru_alert := false ;
14795: LD_ADDR_EXP 54
14799: PUSH
14800: LD_INT 0
14802: ST_TO_ADDR
// if ru_vehicles then
14803: LD_EXP 50
14807: IFFALSE 14873
// for i in ru_vehicles do
14809: LD_ADDR_VAR 0 1
14813: PUSH
14814: LD_EXP 50
14818: PUSH
14819: FOR_IN
14820: IFFALSE 14871
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
14822: LD_VAR 0 1
14826: PPUSH
14827: CALL_OW 302
14831: PUSH
14832: LD_VAR 0 1
14836: PPUSH
14837: LD_INT 89
14839: PPUSH
14840: LD_INT 36
14842: PPUSH
14843: CALL_OW 297
14847: PUSH
14848: LD_INT 10
14850: GREATER
14851: AND
14852: IFFALSE 14869
// ComMoveXY ( i , 89 , 36 ) ;
14854: LD_VAR 0 1
14858: PPUSH
14859: LD_INT 89
14861: PPUSH
14862: LD_INT 36
14864: PPUSH
14865: CALL_OW 111
14869: GO 14819
14871: POP
14872: POP
// end ;
14873: PPOPN 1
14875: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
14876: LD_EXP 49
14880: PUSH
14881: LD_EXP 27
14885: NOT
14886: AND
14887: PUSH
14888: LD_EXP 28
14892: NOT
14893: AND
14894: IFFALSE 15178
14896: GO 14898
14898: DISABLE
14899: LD_INT 0
14901: PPUSH
14902: PPUSH
14903: PPUSH
// begin enable ;
14904: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14905: LD_ADDR_VAR 0 3
14909: PUSH
14910: LD_INT 81
14912: PUSH
14913: LD_INT 3
14915: PUSH
14916: EMPTY
14917: LIST
14918: LIST
14919: PPUSH
14920: CALL_OW 69
14924: ST_TO_ADDR
// for i = 1 to ru_forest do
14925: LD_ADDR_VAR 0 1
14929: PUSH
14930: DOUBLE
14931: LD_INT 1
14933: DEC
14934: ST_TO_ADDR
14935: LD_EXP 49
14939: PUSH
14940: FOR_TO
14941: IFFALSE 15176
// begin un := ru_forest [ i ] ;
14943: LD_ADDR_VAR 0 2
14947: PUSH
14948: LD_EXP 49
14952: PUSH
14953: LD_VAR 0 1
14957: ARRAY
14958: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14959: LD_VAR 0 2
14963: PPUSH
14964: LD_INT 13
14966: PPUSH
14967: CALL_OW 308
14971: IFFALSE 15061
// begin if not See ( 1 , un ) then
14973: LD_INT 1
14975: PPUSH
14976: LD_VAR 0 2
14980: PPUSH
14981: CALL_OW 292
14985: NOT
14986: IFFALSE 15000
// SetLives ( un , 1000 ) ;
14988: LD_VAR 0 2
14992: PPUSH
14993: LD_INT 1000
14995: PPUSH
14996: CALL_OW 234
// ru_forest := ru_forest diff un ;
15000: LD_ADDR_EXP 49
15004: PUSH
15005: LD_EXP 49
15009: PUSH
15010: LD_VAR 0 2
15014: DIFF
15015: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15016: LD_VAR 0 2
15020: PPUSH
15021: LD_INT 22
15023: PUSH
15024: LD_INT 3
15026: PUSH
15027: EMPTY
15028: LIST
15029: LIST
15030: PUSH
15031: LD_INT 30
15033: PUSH
15034: LD_INT 4
15036: PUSH
15037: EMPTY
15038: LIST
15039: LIST
15040: PUSH
15041: EMPTY
15042: LIST
15043: LIST
15044: PPUSH
15045: CALL_OW 69
15049: PPUSH
15050: CALL 1026 0 1
15054: PPUSH
15055: CALL_OW 120
// continue ;
15059: GO 14940
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15061: LD_VAR 0 2
15065: PPUSH
15066: CALL_OW 256
15070: PUSH
15071: LD_INT 700
15073: LESS
15074: PUSH
15075: LD_VAR 0 2
15079: PPUSH
15080: LD_INT 13
15082: PPUSH
15083: CALL_OW 308
15087: NOT
15088: AND
15089: IFFALSE 15105
// ComMoveToArea ( un , retreatArea ) else
15091: LD_VAR 0 2
15095: PPUSH
15096: LD_INT 13
15098: PPUSH
15099: CALL_OW 113
15103: GO 15174
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15105: LD_VAR 0 2
15109: PPUSH
15110: LD_VAR 0 3
15114: PPUSH
15115: LD_VAR 0 2
15119: PPUSH
15120: CALL_OW 74
15124: PPUSH
15125: CALL_OW 296
15129: PUSH
15130: LD_INT 9
15132: LESS
15133: PUSH
15134: LD_VAR 0 2
15138: PPUSH
15139: CALL_OW 256
15143: PUSH
15144: LD_INT 500
15146: GREATER
15147: AND
15148: IFFALSE 15174
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15150: LD_VAR 0 2
15154: PPUSH
15155: LD_VAR 0 3
15159: PPUSH
15160: LD_VAR 0 2
15164: PPUSH
15165: CALL_OW 74
15169: PPUSH
15170: CALL_OW 115
// end ;
15174: GO 14940
15176: POP
15177: POP
// end ;
15178: PPOPN 3
15180: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
15181: LD_EXP 28
15185: NOT
15186: IFFALSE 15307
15188: GO 15190
15190: DISABLE
15191: LD_INT 0
15193: PPUSH
15194: PPUSH
// begin enable ;
15195: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
15196: LD_ADDR_VAR 0 2
15200: PUSH
15201: LD_INT 22
15203: PUSH
15204: LD_INT 3
15206: PUSH
15207: EMPTY
15208: LIST
15209: LIST
15210: PUSH
15211: LD_INT 21
15213: PUSH
15214: LD_INT 3
15216: PUSH
15217: EMPTY
15218: LIST
15219: LIST
15220: PUSH
15221: EMPTY
15222: LIST
15223: LIST
15224: PPUSH
15225: CALL_OW 69
15229: ST_TO_ADDR
// if filter then
15230: LD_VAR 0 2
15234: IFFALSE 15307
// for i in filter do
15236: LD_ADDR_VAR 0 1
15240: PUSH
15241: LD_VAR 0 2
15245: PUSH
15246: FOR_IN
15247: IFFALSE 15305
// if GetLives ( i ) < 990 then
15249: LD_VAR 0 1
15253: PPUSH
15254: CALL_OW 256
15258: PUSH
15259: LD_INT 990
15261: LESS
15262: IFFALSE 15303
// begin ru_alert := true ;
15264: LD_ADDR_EXP 54
15268: PUSH
15269: LD_INT 1
15271: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
15272: LD_ADDR_EXP 55
15276: PUSH
15277: LD_VAR 0 1
15281: PPUSH
15282: CALL_OW 250
15286: PUSH
15287: LD_VAR 0 1
15291: PPUSH
15292: CALL_OW 251
15296: PUSH
15297: EMPTY
15298: LIST
15299: LIST
15300: ST_TO_ADDR
// break ;
15301: GO 15305
// end ;
15303: GO 15246
15305: POP
15306: POP
// end ;
15307: PPOPN 2
15309: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
15310: LD_EXP 27
15314: IFFALSE 15453
15316: GO 15318
15318: DISABLE
15319: LD_INT 0
15321: PPUSH
15322: PPUSH
15323: PPUSH
15324: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
15325: LD_ADDR_VAR 0 4
15329: PUSH
15330: LD_EXP 50
15334: PUSH
15335: LD_EXP 49
15339: ADD
15340: PUSH
15341: LD_EXP 47
15345: ADD
15346: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
15347: LD_ADDR_VAR 0 3
15351: PUSH
15352: LD_INT 3
15354: PPUSH
15355: LD_INT 81
15357: PUSH
15358: LD_INT 3
15360: PUSH
15361: EMPTY
15362: LIST
15363: LIST
15364: PPUSH
15365: CALL_OW 70
15369: ST_TO_ADDR
// if filter and enemy then
15370: LD_VAR 0 4
15374: PUSH
15375: LD_VAR 0 3
15379: AND
15380: IFFALSE 15453
// repeat wait ( 0 0$01 ) ;
15382: LD_INT 35
15384: PPUSH
15385: CALL_OW 67
// for i in filter do
15389: LD_ADDR_VAR 0 1
15393: PUSH
15394: LD_VAR 0 4
15398: PUSH
15399: FOR_IN
15400: IFFALSE 15428
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15402: LD_VAR 0 1
15406: PPUSH
15407: LD_VAR 0 3
15411: PPUSH
15412: LD_VAR 0 1
15416: PPUSH
15417: CALL_OW 74
15421: PPUSH
15422: CALL_OW 115
// end ;
15426: GO 15399
15428: POP
15429: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 ;
15430: LD_INT 3
15432: PPUSH
15433: LD_INT 81
15435: PUSH
15436: LD_INT 3
15438: PUSH
15439: EMPTY
15440: LIST
15441: LIST
15442: PPUSH
15443: CALL_OW 70
15447: PUSH
15448: LD_INT 0
15450: EQUAL
15451: IFFALSE 15382
// end ;
15453: PPOPN 4
15455: END
// every 0 0$03 trigger send_attack_on_cornel_base do var i ;
15456: LD_EXP 23
15460: IFFALSE 15509
15462: GO 15464
15464: DISABLE
15465: LD_INT 0
15467: PPUSH
// begin if not ru_cornel_attack then
15468: LD_EXP 52
15472: NOT
15473: IFFALSE 15477
// exit ;
15475: GO 15509
// for i in ru_cornel_attack do
15477: LD_ADDR_VAR 0 1
15481: PUSH
15482: LD_EXP 52
15486: PUSH
15487: FOR_IN
15488: IFFALSE 15507
// ComAgressiveMove ( i , 258 , 119 ) ;
15490: LD_VAR 0 1
15494: PPUSH
15495: LD_INT 258
15497: PPUSH
15498: LD_INT 119
15500: PPUSH
15501: CALL_OW 114
15505: GO 15487
15507: POP
15508: POP
// end ; end_of_file
15509: PPOPN 1
15511: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
15512: LD_EXP 3
15516: PUSH
15517: LD_EXP 7
15521: NOT
15522: AND
15523: PUSH
15524: LD_EXP 17
15528: AND
15529: IFFALSE 15641
15531: GO 15533
15533: DISABLE
15534: LD_INT 0
15536: PPUSH
// begin enable ;
15537: ENABLE
// crates_counter := crates_counter - 50 ;
15538: LD_ADDR_EXP 17
15542: PUSH
15543: LD_EXP 17
15547: PUSH
15548: LD_INT 50
15550: MINUS
15551: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
15552: LD_INT 8
15554: PPUSH
15555: LD_INT 2
15557: PPUSH
15558: LD_INT 5
15560: PPUSH
15561: CALL_OW 12
15565: PPUSH
15566: LD_INT 1
15568: PPUSH
15569: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
15573: LD_INT 1785
15575: PPUSH
15576: LD_INT 2345
15578: PPUSH
15579: CALL_OW 12
15583: PPUSH
15584: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
15588: LD_ADDR_VAR 0 1
15592: PUSH
15593: LD_INT 1
15595: PPUSH
15596: LD_OWVAR 67
15600: PUSH
15601: LD_INT 2
15603: PLUS
15604: PPUSH
15605: CALL_OW 12
15609: ST_TO_ADDR
// if r < 3 then
15610: LD_VAR 0 1
15614: PUSH
15615: LD_INT 3
15617: LESS
15618: IFFALSE 15641
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
15620: LD_INT 4
15622: PPUSH
15623: LD_INT 1
15625: PPUSH
15626: LD_INT 5
15628: PPUSH
15629: CALL_OW 12
15633: PPUSH
15634: LD_INT 1
15636: PPUSH
15637: CALL_OW 55
// end ;
15641: PPOPN 1
15643: END
// every 0 0$01 trigger cornel_active do
15644: LD_EXP 6
15648: IFFALSE 15737
15650: GO 15652
15652: DISABLE
// begin Wait ( 0 0$03 ) ;
15653: LD_INT 105
15655: PPUSH
15656: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15660: LD_INT 2
15662: PPUSH
15663: LD_INT 5
15665: PPUSH
15666: CALL_OW 12
15670: PPUSH
15671: LD_INT 10
15673: PPUSH
15674: LD_INT 1
15676: PPUSH
15677: CALL_OW 55
// Wait ( 0 0$13 ) ;
15681: LD_INT 455
15683: PPUSH
15684: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15688: LD_INT 2
15690: PPUSH
15691: LD_INT 5
15693: PPUSH
15694: CALL_OW 12
15698: PPUSH
15699: LD_INT 10
15701: PPUSH
15702: LD_INT 1
15704: PPUSH
15705: CALL_OW 55
// Wait ( 0 0$16 ) ;
15709: LD_INT 560
15711: PPUSH
15712: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15716: LD_INT 2
15718: PPUSH
15719: LD_INT 5
15721: PPUSH
15722: CALL_OW 12
15726: PPUSH
15727: LD_INT 10
15729: PPUSH
15730: LD_INT 1
15732: PPUSH
15733: CALL_OW 55
// end ; end_of_file
15737: END
// every 0 0$01 trigger cornel_prepared do
15738: LD_EXP 9
15742: IFFALSE 15801
15744: GO 15746
15746: DISABLE
// begin enable ;
15747: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
15748: LD_ADDR_OWVAR 47
15752: PUSH
15753: LD_STRING #Am03-1
15755: PUSH
15756: LD_EXP 8
15760: PUSH
15761: EMPTY
15762: LIST
15763: LIST
15764: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
15765: LD_ADDR_EXP 8
15769: PUSH
15770: LD_EXP 8
15774: PPUSH
15775: LD_STRING -
15777: PPUSH
15778: CALL 1096 0 2
15782: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
15783: LD_EXP 8
15787: PUSH
15788: LD_INT 0
15790: EQUAL
15791: IFFALSE 15801
// begin Display_Strings := [ ] ;
15793: LD_ADDR_OWVAR 47
15797: PUSH
15798: EMPTY
15799: ST_TO_ADDR
// disable ;
15800: DISABLE
// end ; end ;
15801: END
// every 0 0$01 trigger debug and debug_strings do
15802: LD_EXP 1
15806: PUSH
15807: LD_OWVAR 48
15811: AND
15812: IFFALSE 15828
15814: GO 15816
15816: DISABLE
// begin enable ;
15817: ENABLE
// Display_Strings := debug_strings ;
15818: LD_ADDR_OWVAR 47
15822: PUSH
15823: LD_OWVAR 48
15827: ST_TO_ADDR
// end ; end_of_file
15828: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
15829: LD_VAR 0 1
15833: PPUSH
15834: CALL_OW 255
15838: PUSH
15839: LD_INT 1
15841: EQUAL
15842: PUSH
15843: LD_EXP 11
15847: NOT
15848: AND
15849: IFFALSE 15859
// solar_builded := true ;
15851: LD_ADDR_EXP 11
15855: PUSH
15856: LD_INT 1
15858: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
15859: LD_VAR 0 1
15863: PPUSH
15864: CALL_OW 255
15868: PUSH
15869: LD_INT 1
15871: EQUAL
15872: PUSH
15873: LD_EXP 25
15877: AND
15878: IFFALSE 15911
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
15880: LD_ADDR_EXP 25
15884: PUSH
15885: LD_EXP 25
15889: PUSH
15890: LD_INT 1750
15892: PUSH
15893: LD_INT 1400
15895: PUSH
15896: LD_INT 1225
15898: PUSH
15899: EMPTY
15900: LIST
15901: LIST
15902: LIST
15903: PUSH
15904: LD_OWVAR 67
15908: ARRAY
15909: PLUS
15910: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
15911: LD_VAR 0 1
15915: PPUSH
15916: CALL_OW 255
15920: PUSH
15921: LD_INT 3
15923: EQUAL
15924: IFFALSE 15942
// ru_vehicles := ru_vehicles ^ veh ;
15926: LD_ADDR_EXP 50
15930: PUSH
15931: LD_EXP 50
15935: PUSH
15936: LD_VAR 0 1
15940: ADD
15941: ST_TO_ADDR
// end ;
15942: PPOPN 2
15944: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
15945: LD_VAR 0 1
15949: PUSH
15950: LD_EXP 47
15954: IN
15955: IFFALSE 15973
// ru_patrol := ru_patrol diff un ;
15957: LD_ADDR_EXP 47
15961: PUSH
15962: LD_EXP 47
15966: PUSH
15967: LD_VAR 0 1
15971: DIFF
15972: ST_TO_ADDR
// if un in ru_forest then
15973: LD_VAR 0 1
15977: PUSH
15978: LD_EXP 49
15982: IN
15983: IFFALSE 16001
// ru_forest := ru_forest diff un ;
15985: LD_ADDR_EXP 49
15989: PUSH
15990: LD_EXP 49
15994: PUSH
15995: LD_VAR 0 1
15999: DIFF
16000: ST_TO_ADDR
// if un in ru_vehicles then
16001: LD_VAR 0 1
16005: PUSH
16006: LD_EXP 50
16010: IN
16011: IFFALSE 16086
// begin ru_vehicles := ru_vehicles diff un ;
16013: LD_ADDR_EXP 50
16017: PUSH
16018: LD_EXP 50
16022: PUSH
16023: LD_VAR 0 1
16027: DIFF
16028: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
16029: LD_ADDR_EXP 51
16033: PUSH
16034: LD_EXP 51
16038: PUSH
16039: LD_VAR 0 1
16043: PPUSH
16044: CALL_OW 265
16048: PUSH
16049: LD_VAR 0 1
16053: PPUSH
16054: CALL_OW 262
16058: PUSH
16059: LD_VAR 0 1
16063: PPUSH
16064: CALL_OW 263
16068: PUSH
16069: LD_VAR 0 1
16073: PPUSH
16074: CALL_OW 264
16078: PUSH
16079: EMPTY
16080: LIST
16081: LIST
16082: LIST
16083: LIST
16084: ADD
16085: ST_TO_ADDR
// end ; if un = JMM then
16086: LD_VAR 0 1
16090: PUSH
16091: LD_EXP 31
16095: EQUAL
16096: IFFALSE 16105
// YouLost ( 0 ) ;
16098: LD_STRING 0
16100: PPUSH
16101: CALL_OW 104
// if un = us_dep_west then
16105: LD_VAR 0 1
16109: PUSH
16110: LD_INT 1
16112: EQUAL
16113: IFFALSE 16122
// YouLost ( 2 ) ;
16115: LD_STRING 2
16117: PPUSH
16118: CALL_OW 104
// if un = Lynch and GetSide ( Lynch ) = 8 then
16122: LD_VAR 0 1
16126: PUSH
16127: LD_EXP 41
16131: EQUAL
16132: PUSH
16133: LD_EXP 41
16137: PPUSH
16138: CALL_OW 255
16142: PUSH
16143: LD_INT 8
16145: EQUAL
16146: AND
16147: IFFALSE 16156
// YouLost ( 4 ) ;
16149: LD_STRING 4
16151: PPUSH
16152: CALL_OW 104
// if un in jmm_units then
16156: LD_VAR 0 1
16160: PUSH
16161: LD_EXP 2
16165: IN
16166: IFFALSE 16182
// lose_counter := lose_counter + 1 ;
16168: LD_ADDR_EXP 30
16172: PUSH
16173: LD_EXP 30
16177: PUSH
16178: LD_INT 1
16180: PLUS
16181: ST_TO_ADDR
// end ;
16182: PPOPN 1
16184: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
16185: LD_INT 0
16187: PPUSH
16188: PPUSH
// begin if GetSide ( driver ) = 3 then
16189: LD_VAR 0 1
16193: PPUSH
16194: CALL_OW 255
16198: PUSH
16199: LD_INT 3
16201: EQUAL
16202: IFFALSE 16280
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
16204: LD_ADDR_VAR 0 6
16208: PUSH
16209: LD_INT 22
16211: PUSH
16212: LD_INT 3
16214: PUSH
16215: EMPTY
16216: LIST
16217: LIST
16218: PUSH
16219: LD_INT 30
16221: PUSH
16222: LD_INT 3
16224: PUSH
16225: EMPTY
16226: LIST
16227: LIST
16228: PUSH
16229: EMPTY
16230: LIST
16231: LIST
16232: PPUSH
16233: CALL_OW 69
16237: PPUSH
16238: CALL 1026 0 1
16242: ST_TO_ADDR
// if place then
16243: LD_VAR 0 6
16247: IFFALSE 16265
// ComEnterUnit ( driver , place ) else
16249: LD_VAR 0 1
16253: PPUSH
16254: LD_VAR 0 6
16258: PPUSH
16259: CALL_OW 120
16263: GO 16280
// ComMoveXY ( driver , 70 , 22 ) ;
16265: LD_VAR 0 1
16269: PPUSH
16270: LD_INT 70
16272: PPUSH
16273: LD_INT 22
16275: PPUSH
16276: CALL_OW 111
// end ; end ;
16280: PPOPN 6
16282: END
// every 0 0$01 trigger not game_end and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) < 4 do
16283: LD_EXP 29
16287: NOT
16288: PUSH
16289: LD_INT 22
16291: PUSH
16292: LD_INT 1
16294: PUSH
16295: EMPTY
16296: LIST
16297: LIST
16298: PUSH
16299: LD_INT 21
16301: PUSH
16302: LD_INT 1
16304: PUSH
16305: EMPTY
16306: LIST
16307: LIST
16308: PUSH
16309: EMPTY
16310: LIST
16311: LIST
16312: PPUSH
16313: CALL_OW 69
16317: PUSH
16318: LD_INT 22
16320: PUSH
16321: LD_INT 8
16323: PUSH
16324: EMPTY
16325: LIST
16326: LIST
16327: PUSH
16328: LD_INT 21
16330: PUSH
16331: LD_INT 1
16333: PUSH
16334: EMPTY
16335: LIST
16336: LIST
16337: PUSH
16338: EMPTY
16339: LIST
16340: LIST
16341: PPUSH
16342: CALL_OW 69
16346: PLUS
16347: PUSH
16348: LD_INT 4
16350: LESS
16351: AND
16352: IFFALSE 16364
16354: GO 16356
16356: DISABLE
// YouLost ( 1 ) ;
16357: LD_STRING 1
16359: PPUSH
16360: CALL_OW 104
16364: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
16365: LD_INT 1
16367: PPUSH
16368: CALL_OW 255
16372: PUSH
16373: LD_INT 3
16375: EQUAL
16376: IFFALSE 16388
16378: GO 16380
16380: DISABLE
// YouLost ( 3 ) ;
16381: LD_STRING 3
16383: PPUSH
16384: CALL_OW 104
16388: END
