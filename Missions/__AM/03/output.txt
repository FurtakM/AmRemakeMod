// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 347 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 435 0 0
// PrepareRussian ;
  22: CALL 2964 0 0
// PrepareAmerican ;
  26: CALL 1169 0 0
// PrepareCornell ;
  30: CALL 2193 0 0
// PrepareWesternBase ;
  34: CALL 2419 0 0
// Action ;
  38: CALL 5180 0 0
// end ;
  42: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  54: LD_ADDR_EXP 3
  58: PUSH
  59: LD_STRING 02_
  61: ST_TO_ADDR
// mission_prefix := 03_ ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_STRING 03_
  69: ST_TO_ADDR
// jmm_units := 0 ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// cornel_units := 0 ;
  78: LD_ADDR_EXP 6
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// bierezov_exist := false ;
  86: LD_ADDR_EXP 7
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// jmm_on_west := false ;
  94: LD_ADDR_EXP 5
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_active := false ;
 102: LD_ADDR_EXP 8
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_attack := false ;
 110: LD_ADDR_EXP 9
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// cornel_prepared := false ;
 118: LD_ADDR_EXP 11
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 126: LD_ADDR_EXP 10
 130: PUSH
 131: LD_INT 4200
 133: ST_TO_ADDR
// frank_can_return := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// solar_builded := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// frank_send_to_scout := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// jmm_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// bobby_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// cyrus_in_veh := false ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// lisa_in_veh := false ;
 182: LD_ADDR_EXP 18
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 190: LD_ADDR_EXP 27
 194: PUSH
 195: LD_INT 25200
 197: PUSH
 198: LD_INT 23100
 200: PUSH
 201: LD_INT 21000
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: PUSH
 209: LD_OWVAR 67
 213: ARRAY
 214: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 215: LD_ADDR_EXP 19
 219: PUSH
 220: LD_INT 600
 222: PUSH
 223: LD_INT 500
 225: PUSH
 226: LD_INT 400
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: PUSH
 234: LD_OWVAR 67
 238: ARRAY
 239: ST_TO_ADDR
// end_mission_allowed := false ;
 240: LD_ADDR_EXP 20
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// save_others := [ ] ;
 248: LD_ADDR_EXP 21
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// save_group := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// show_query := true ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// wait_for_them := false ;
 270: LD_ADDR_EXP 24
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// veh_on_meta := false ;
 278: LD_ADDR_EXP 26
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_spec_patrol := false ;
 286: LD_ADDR_EXP 28
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// prepare_siege := false ;
 294: LD_ADDR_EXP 29
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// send_attack_on_cornel := false ;
 302: LD_ADDR_EXP 30
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 310: LD_ADDR_EXP 25
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// game_end := false ;
 318: LD_ADDR_EXP 31
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// lose_counter := 0 ;
 326: LD_ADDR_EXP 32
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// powell_warn := 0 ;
 334: LD_ADDR_EXP 33
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// end ;
 342: LD_VAR 0 1
 346: RET
// function SetDiplomacy ; begin
 347: LD_INT 0
 349: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 4
 355: PPUSH
 356: LD_INT 1
 358: PPUSH
 359: LD_INT 1
 361: PPUSH
 362: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 366: LD_INT 1
 368: PPUSH
 369: LD_INT 8
 371: PPUSH
 372: LD_INT 1
 374: PPUSH
 375: LD_INT 1
 377: PPUSH
 378: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 382: LD_INT 3
 384: PPUSH
 385: LD_INT 6
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 398: LD_INT 4
 400: PPUSH
 401: LD_INT 6
 403: PPUSH
 404: LD_INT 0
 406: PPUSH
 407: LD_INT 1
 409: PPUSH
 410: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 8
 419: PPUSH
 420: LD_INT 0
 422: PPUSH
 423: LD_INT 1
 425: PPUSH
 426: CALL_OW 80
// end ;
 430: LD_VAR 0 1
 434: RET
// export function DebugMode ; var i ; begin
 435: LD_INT 0
 437: PPUSH
 438: PPUSH
// FogOff ( 1 ) ;
 439: LD_INT 1
 441: PPUSH
 442: CALL_OW 344
// debug_strings := [ ] ;
 446: LD_ADDR_OWVAR 48
 450: PUSH
 451: EMPTY
 452: ST_TO_ADDR
// end ; end_of_file
 453: LD_VAR 0 1
 457: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 458: LD_INT 0
 460: PPUSH
 461: PPUSH
// if exist_mode then
 462: LD_VAR 0 2
 466: IFFALSE 491
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 468: LD_ADDR_VAR 0 4
 472: PUSH
 473: LD_EXP 3
 477: PUSH
 478: LD_VAR 0 1
 482: STR
 483: PPUSH
 484: CALL_OW 34
 488: ST_TO_ADDR
 489: GO 506
// unit := NewCharacter ( ident ) ;
 491: LD_ADDR_VAR 0 4
 495: PUSH
 496: LD_VAR 0 1
 500: PPUSH
 501: CALL_OW 25
 505: ST_TO_ADDR
// result := unit ;
 506: LD_ADDR_VAR 0 3
 510: PUSH
 511: LD_VAR 0 4
 515: ST_TO_ADDR
// end ;
 516: LD_VAR 0 3
 520: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 521: LD_INT 0
 523: PPUSH
// uc_side := side ;
 524: LD_ADDR_OWVAR 20
 528: PUSH
 529: LD_VAR 0 1
 533: ST_TO_ADDR
// uc_nation := nation ;
 534: LD_ADDR_OWVAR 21
 538: PUSH
 539: LD_VAR 0 2
 543: ST_TO_ADDR
// vc_chassis := chassis ;
 544: LD_ADDR_OWVAR 37
 548: PUSH
 549: LD_VAR 0 3
 553: ST_TO_ADDR
// vc_engine := engine ;
 554: LD_ADDR_OWVAR 39
 558: PUSH
 559: LD_VAR 0 4
 563: ST_TO_ADDR
// vc_control := control ;
 564: LD_ADDR_OWVAR 38
 568: PUSH
 569: LD_VAR 0 5
 573: ST_TO_ADDR
// vc_weapon := weapon ;
 574: LD_ADDR_OWVAR 40
 578: PUSH
 579: LD_VAR 0 6
 583: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 584: LD_ADDR_OWVAR 41
 588: PUSH
 589: LD_VAR 0 7
 593: ST_TO_ADDR
// result := CreateVehicle ;
 594: LD_ADDR_VAR 0 8
 598: PUSH
 599: CALL_OW 45
 603: ST_TO_ADDR
// end ;
 604: LD_VAR 0 8
 608: RET
// export function SayX ( units , ident ) ; var i ; begin
 609: LD_INT 0
 611: PPUSH
 612: PPUSH
// result := false ;
 613: LD_ADDR_VAR 0 3
 617: PUSH
 618: LD_INT 0
 620: ST_TO_ADDR
// if not units then
 621: LD_VAR 0 1
 625: NOT
 626: IFFALSE 630
// exit ;
 628: GO 684
// for i in units do
 630: LD_ADDR_VAR 0 4
 634: PUSH
 635: LD_VAR 0 1
 639: PUSH
 640: FOR_IN
 641: IFFALSE 682
// if IsOk ( i ) then
 643: LD_VAR 0 4
 647: PPUSH
 648: CALL_OW 302
 652: IFFALSE 680
// begin Say ( i , ident ) ;
 654: LD_VAR 0 4
 658: PPUSH
 659: LD_VAR 0 2
 663: PPUSH
 664: CALL_OW 88
// result := i ;
 668: LD_ADDR_VAR 0 3
 672: PUSH
 673: LD_VAR 0 4
 677: ST_TO_ADDR
// break ;
 678: GO 682
// end ;
 680: GO 640
 682: POP
 683: POP
// end ;
 684: LD_VAR 0 3
 688: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 689: LD_INT 0
 691: PPUSH
 692: PPUSH
 693: PPUSH
 694: PPUSH
// for i = 1 to count do
 695: LD_ADDR_VAR 0 8
 699: PUSH
 700: DOUBLE
 701: LD_INT 1
 703: DEC
 704: ST_TO_ADDR
 705: LD_VAR 0 6
 709: PUSH
 710: FOR_TO
 711: IFFALSE 792
// begin uc_side = side ;
 713: LD_ADDR_OWVAR 20
 717: PUSH
 718: LD_VAR 0 1
 722: ST_TO_ADDR
// uc_nation = nation ;
 723: LD_ADDR_OWVAR 21
 727: PUSH
 728: LD_VAR 0 2
 732: ST_TO_ADDR
// hc_gallery =  ;
 733: LD_ADDR_OWVAR 33
 737: PUSH
 738: LD_STRING 
 740: ST_TO_ADDR
// hc_name =  ;
 741: LD_ADDR_OWVAR 26
 745: PUSH
 746: LD_STRING 
 748: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 749: LD_INT 0
 751: PPUSH
 752: LD_VAR 0 5
 756: PPUSH
 757: LD_VAR 0 4
 761: PPUSH
 762: CALL_OW 380
// un = CreateHuman ;
 766: LD_ADDR_VAR 0 10
 770: PUSH
 771: CALL_OW 44
 775: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 776: LD_VAR 0 10
 780: PPUSH
 781: LD_VAR 0 3
 785: PPUSH
 786: CALL_OW 52
// end ;
 790: GO 710
 792: POP
 793: POP
// end ;
 794: LD_VAR 0 7
 798: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 799: LD_INT 0
 801: PPUSH
 802: PPUSH
 803: PPUSH
// uc_side := GetSide ( b ) ;
 804: LD_ADDR_OWVAR 20
 808: PUSH
 809: LD_VAR 0 2
 813: PPUSH
 814: CALL_OW 255
 818: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 819: LD_ADDR_OWVAR 21
 823: PUSH
 824: LD_VAR 0 2
 828: PPUSH
 829: CALL_OW 248
 833: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 834: LD_INT 0
 836: PPUSH
 837: LD_INT 1
 839: PPUSH
 840: LD_VAR 0 1
 844: PPUSH
 845: CALL_OW 380
// un = CreateHuman ;
 849: LD_ADDR_VAR 0 4
 853: PUSH
 854: CALL_OW 44
 858: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 859: LD_ADDR_VAR 0 5
 863: PUSH
 864: LD_VAR 0 2
 868: PPUSH
 869: CALL_OW 254
 873: PUSH
 874: LD_INT 3
 876: MINUS
 877: ST_TO_ADDR
// if dir < 0 then
 878: LD_VAR 0 5
 882: PUSH
 883: LD_INT 0
 885: LESS
 886: IFFALSE 902
// dir := 6 + dir ;
 888: LD_ADDR_VAR 0 5
 892: PUSH
 893: LD_INT 6
 895: PUSH
 896: LD_VAR 0 5
 900: PLUS
 901: ST_TO_ADDR
// SetDir ( un , dir ) ;
 902: LD_VAR 0 4
 906: PPUSH
 907: LD_VAR 0 5
 911: PPUSH
 912: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 916: LD_VAR 0 4
 920: PPUSH
 921: LD_VAR 0 2
 925: PPUSH
 926: CALL_OW 52
// end ;
 930: LD_VAR 0 3
 934: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 935: LD_INT 0
 937: PPUSH
 938: PPUSH
 939: PPUSH
// result := false ;
 940: LD_ADDR_VAR 0 2
 944: PUSH
 945: LD_INT 0
 947: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 948: LD_ADDR_VAR 0 3
 952: PUSH
 953: LD_INT 22
 955: PUSH
 956: LD_INT 1
 958: PUSH
 959: EMPTY
 960: LIST
 961: LIST
 962: PUSH
 963: LD_INT 34
 965: PUSH
 966: LD_INT 2
 968: PUSH
 969: EMPTY
 970: LIST
 971: LIST
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: PPUSH
 977: CALL_OW 69
 981: ST_TO_ADDR
// for i in filter do
 982: LD_ADDR_VAR 0 4
 986: PUSH
 987: LD_VAR 0 3
 991: PUSH
 992: FOR_IN
 993: IFFALSE 1024
// if IsDrivenBy ( i ) = unit then
 995: LD_VAR 0 4
 999: PPUSH
1000: CALL_OW 311
1004: PUSH
1005: LD_VAR 0 1
1009: EQUAL
1010: IFFALSE 1022
// begin result := true ;
1012: LD_ADDR_VAR 0 2
1016: PUSH
1017: LD_INT 1
1019: ST_TO_ADDR
// break ;
1020: GO 1024
// end ;
1022: GO 992
1024: POP
1025: POP
// end ;
1026: LD_VAR 0 2
1030: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1031: LD_INT 0
1033: PPUSH
1034: PPUSH
// result := false ;
1035: LD_ADDR_VAR 0 2
1039: PUSH
1040: LD_INT 0
1042: ST_TO_ADDR
// if not blist then
1043: LD_VAR 0 1
1047: NOT
1048: IFFALSE 1052
// exit ;
1050: GO 1096
// for i in blist do
1052: LD_ADDR_VAR 0 3
1056: PUSH
1057: LD_VAR 0 1
1061: PUSH
1062: FOR_IN
1063: IFFALSE 1094
// if UnitsInside ( i ) < 6 then
1065: LD_VAR 0 3
1069: PPUSH
1070: CALL_OW 313
1074: PUSH
1075: LD_INT 6
1077: LESS
1078: IFFALSE 1092
// begin result := i ;
1080: LD_ADDR_VAR 0 2
1084: PUSH
1085: LD_VAR 0 3
1089: ST_TO_ADDR
// break ;
1090: GO 1094
// end ;
1092: GO 1062
1094: POP
1095: POP
// end ;
1096: LD_VAR 0 2
1100: RET
// export function Count ( timer , mode ) ; begin
1101: LD_INT 0
1103: PPUSH
// if not timer then
1104: LD_VAR 0 1
1108: NOT
1109: IFFALSE 1113
// exit ;
1111: GO 1164
// if mode in [ asc , up , + ] then
1113: LD_VAR 0 2
1117: PUSH
1118: LD_STRING asc
1120: PUSH
1121: LD_STRING up
1123: PUSH
1124: LD_STRING +
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: LIST
1131: IN
1132: IFFALSE 1150
// result := timer + 0 0$01 else
1134: LD_ADDR_VAR 0 3
1138: PUSH
1139: LD_VAR 0 1
1143: PUSH
1144: LD_INT 35
1146: PLUS
1147: ST_TO_ADDR
1148: GO 1164
// result := timer - 0 0$01 ;
1150: LD_ADDR_VAR 0 3
1154: PUSH
1155: LD_VAR 0 1
1159: PUSH
1160: LD_INT 35
1162: MINUS
1163: ST_TO_ADDR
// end ; end_of_file
1164: LD_VAR 0 3
1168: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1169: LD_INT 0
1171: PPUSH
1172: PPUSH
1173: PPUSH
1174: PPUSH
1175: PPUSH
1176: PPUSH
1177: PPUSH
1178: PPUSH
// uc_side := 4 ;
1179: LD_ADDR_OWVAR 20
1183: PUSH
1184: LD_INT 4
1186: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1187: LD_ADDR_EXP 43
1191: PUSH
1192: LD_STRING Powell
1194: PPUSH
1195: LD_INT 0
1197: PPUSH
1198: CALL 458 0 2
1202: ST_TO_ADDR
// uc_side := 1 ;
1203: LD_ADDR_OWVAR 20
1207: PUSH
1208: LD_INT 1
1210: ST_TO_ADDR
// uc_nation := 1 ;
1211: LD_ADDR_OWVAR 21
1215: PUSH
1216: LD_INT 1
1218: ST_TO_ADDR
// if debug then
1219: LD_EXP 1
1223: IFFALSE 1353
// begin for i = 1 to 4 do
1225: LD_ADDR_VAR 0 2
1229: PUSH
1230: DOUBLE
1231: LD_INT 1
1233: DEC
1234: ST_TO_ADDR
1235: LD_INT 4
1237: PUSH
1238: FOR_TO
1239: IFFALSE 1290
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1241: LD_INT 0
1243: PPUSH
1244: LD_INT 1
1246: PPUSH
1247: LD_INT 2
1249: PPUSH
1250: CALL_OW 12
1254: PPUSH
1255: LD_INT 3
1257: PPUSH
1258: CALL_OW 380
// un := CreateHuman ;
1262: LD_ADDR_VAR 0 3
1266: PUSH
1267: CALL_OW 44
1271: ST_TO_ADDR
// others := others ^ un ;
1272: LD_ADDR_VAR 0 5
1276: PUSH
1277: LD_VAR 0 5
1281: PUSH
1282: LD_VAR 0 3
1286: ADD
1287: ST_TO_ADDR
// end ;
1288: GO 1238
1290: POP
1291: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1292: LD_ADDR_VAR 0 6
1296: PUSH
1297: LD_INT 21
1299: PUSH
1300: LD_INT 1
1302: PUSH
1303: LD_INT 1
1305: PUSH
1306: LD_INT 51
1308: PUSH
1309: LD_INT 90
1311: PUSH
1312: LD_INT 504
1314: PUSH
1315: EMPTY
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: PUSH
1323: LD_INT 21
1325: PUSH
1326: LD_INT 1
1328: PUSH
1329: LD_INT 1
1331: PUSH
1332: LD_INT 51
1334: PUSH
1335: LD_INT 80
1337: PUSH
1338: LD_INT 750
1340: PUSH
1341: EMPTY
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: PUSH
1349: EMPTY
1350: LIST
1351: LIST
1352: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1353: LD_ADDR_EXP 34
1357: PUSH
1358: LD_STRING JMM
1360: PPUSH
1361: LD_EXP 1
1365: NOT
1366: PPUSH
1367: CALL 458 0 2
1371: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1372: LD_ADDR_EXP 35
1376: PUSH
1377: LD_STRING Bobby
1379: PPUSH
1380: LD_EXP 1
1384: NOT
1385: PPUSH
1386: CALL 458 0 2
1390: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1391: LD_ADDR_EXP 36
1395: PUSH
1396: LD_STRING Cyrus
1398: PPUSH
1399: LD_EXP 1
1403: NOT
1404: PPUSH
1405: CALL 458 0 2
1409: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1410: LD_ADDR_EXP 37
1414: PUSH
1415: LD_STRING Lisa
1417: PPUSH
1418: LD_EXP 1
1422: NOT
1423: PPUSH
1424: CALL 458 0 2
1428: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1429: LD_ADDR_EXP 38
1433: PUSH
1434: LD_STRING Khatam
1436: PPUSH
1437: LD_EXP 1
1441: NOT
1442: PPUSH
1443: CALL 458 0 2
1447: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1448: LD_ADDR_EXP 39
1452: PUSH
1453: LD_STRING Brian
1455: PPUSH
1456: LD_EXP 1
1460: NOT
1461: PPUSH
1462: CALL 458 0 2
1466: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1467: LD_ADDR_EXP 40
1471: PUSH
1472: LD_STRING Jerry
1474: PPUSH
1475: LD_EXP 1
1479: NOT
1480: PPUSH
1481: CALL 458 0 2
1485: ST_TO_ADDR
// if Bobby then
1486: LD_EXP 35
1490: IFFALSE 1521
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1492: LD_ADDR_VAR 0 4
1496: PUSH
1497: LD_VAR 0 4
1501: PPUSH
1502: LD_VAR 0 4
1506: PUSH
1507: LD_INT 1
1509: PLUS
1510: PPUSH
1511: LD_EXP 35
1515: PPUSH
1516: CALL_OW 2
1520: ST_TO_ADDR
// if Cyrus then
1521: LD_EXP 36
1525: IFFALSE 1556
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1527: LD_ADDR_VAR 0 4
1531: PUSH
1532: LD_VAR 0 4
1536: PPUSH
1537: LD_VAR 0 4
1541: PUSH
1542: LD_INT 1
1544: PLUS
1545: PPUSH
1546: LD_EXP 36
1550: PPUSH
1551: CALL_OW 2
1555: ST_TO_ADDR
// if Lisa then
1556: LD_EXP 37
1560: IFFALSE 1591
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1562: LD_ADDR_VAR 0 4
1566: PUSH
1567: LD_VAR 0 4
1571: PPUSH
1572: LD_VAR 0 4
1576: PUSH
1577: LD_INT 1
1579: PLUS
1580: PPUSH
1581: LD_EXP 37
1585: PPUSH
1586: CALL_OW 2
1590: ST_TO_ADDR
// if Khatam then
1591: LD_EXP 38
1595: IFFALSE 1626
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1597: LD_ADDR_VAR 0 4
1601: PUSH
1602: LD_VAR 0 4
1606: PPUSH
1607: LD_VAR 0 4
1611: PUSH
1612: LD_INT 1
1614: PLUS
1615: PPUSH
1616: LD_EXP 38
1620: PPUSH
1621: CALL_OW 2
1625: ST_TO_ADDR
// if Brian then
1626: LD_EXP 39
1630: IFFALSE 1661
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1632: LD_ADDR_VAR 0 4
1636: PUSH
1637: LD_VAR 0 4
1641: PPUSH
1642: LD_VAR 0 4
1646: PUSH
1647: LD_INT 1
1649: PLUS
1650: PPUSH
1651: LD_EXP 39
1655: PPUSH
1656: CALL_OW 2
1660: ST_TO_ADDR
// if Jerry then
1661: LD_EXP 40
1665: IFFALSE 1696
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1667: LD_ADDR_VAR 0 4
1671: PUSH
1672: LD_VAR 0 4
1676: PPUSH
1677: LD_VAR 0 4
1681: PUSH
1682: LD_INT 1
1684: PLUS
1685: PPUSH
1686: LD_EXP 40
1690: PPUSH
1691: CALL_OW 2
1695: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1696: LD_STRING 02_other_survivors
1698: PPUSH
1699: CALL_OW 28
1703: IFFALSE 1718
// others := CreateCharacterSet ( 02_other_survivors ) ;
1705: LD_ADDR_VAR 0 5
1709: PUSH
1710: LD_STRING 02_other_survivors
1712: PPUSH
1713: CALL_OW 31
1717: ST_TO_ADDR
// if others then
1718: LD_VAR 0 5
1722: IFFALSE 1747
// begin tmp := tmp ^ others ;
1724: LD_ADDR_VAR 0 4
1728: PUSH
1729: LD_VAR 0 4
1733: PUSH
1734: LD_VAR 0 5
1738: ADD
1739: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1740: LD_STRING 02_other_survivors
1742: PPUSH
1743: CALL_OW 40
// end ; jmm_units := tmp ;
1747: LD_ADDR_EXP 4
1751: PUSH
1752: LD_VAR 0 4
1756: ST_TO_ADDR
// if not vehicles then
1757: LD_VAR 0 6
1761: NOT
1762: IFFALSE 1780
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1764: LD_ADDR_VAR 0 6
1768: PUSH
1769: LD_STRING 02_tanks_1
1771: PPUSH
1772: LD_INT 0
1774: PPUSH
1775: CALL_OW 30
1779: ST_TO_ADDR
// if vehicles then
1780: LD_VAR 0 6
1784: IFFALSE 1978
// begin got_mech := false ;
1786: LD_ADDR_VAR 0 7
1790: PUSH
1791: LD_INT 0
1793: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1794: LD_VAR 0 4
1798: PPUSH
1799: LD_INT 25
1801: PUSH
1802: LD_INT 3
1804: PUSH
1805: EMPTY
1806: LIST
1807: LIST
1808: PPUSH
1809: CALL_OW 72
1813: IFFALSE 1823
// got_mech := true ;
1815: LD_ADDR_VAR 0 7
1819: PUSH
1820: LD_INT 1
1822: ST_TO_ADDR
// for i = 1 to vehicles do
1823: LD_ADDR_VAR 0 2
1827: PUSH
1828: DOUBLE
1829: LD_INT 1
1831: DEC
1832: ST_TO_ADDR
1833: LD_VAR 0 6
1837: PUSH
1838: FOR_TO
1839: IFFALSE 1976
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1841: LD_ADDR_VAR 0 3
1845: PUSH
1846: LD_INT 1
1848: PPUSH
1849: LD_INT 3
1851: PPUSH
1852: LD_VAR 0 6
1856: PUSH
1857: LD_VAR 0 2
1861: ARRAY
1862: PUSH
1863: LD_INT 1
1865: ARRAY
1866: PPUSH
1867: LD_VAR 0 6
1871: PUSH
1872: LD_VAR 0 2
1876: ARRAY
1877: PUSH
1878: LD_INT 2
1880: ARRAY
1881: PPUSH
1882: LD_VAR 0 6
1886: PUSH
1887: LD_VAR 0 2
1891: ARRAY
1892: PUSH
1893: LD_INT 3
1895: ARRAY
1896: PPUSH
1897: LD_VAR 0 6
1901: PUSH
1902: LD_VAR 0 2
1906: ARRAY
1907: PUSH
1908: LD_INT 4
1910: ARRAY
1911: PPUSH
1912: LD_INT 40
1914: PPUSH
1915: CALL 521 0 7
1919: ST_TO_ADDR
// if not got_mech then
1920: LD_VAR 0 7
1924: NOT
1925: IFFALSE 1951
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1927: LD_VAR 0 3
1931: PPUSH
1932: LD_VAR 0 6
1936: PUSH
1937: LD_VAR 0 2
1941: ARRAY
1942: PUSH
1943: LD_INT 6
1945: ARRAY
1946: PPUSH
1947: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1951: LD_ADDR_VAR 0 4
1955: PUSH
1956: LD_VAR 0 4
1960: PPUSH
1961: LD_INT 1
1963: PPUSH
1964: LD_VAR 0 3
1968: PPUSH
1969: CALL_OW 2
1973: ST_TO_ADDR
// end ;
1974: GO 1838
1976: POP
1977: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1978: LD_EXP 34
1982: PPUSH
1983: LD_INT 194
1985: PPUSH
1986: LD_INT 119
1988: PPUSH
1989: LD_INT 0
1991: PPUSH
1992: CALL_OW 48
// if tmp then
1996: LD_VAR 0 4
2000: IFFALSE 2125
// begin for i in tmp do
2002: LD_ADDR_VAR 0 2
2006: PUSH
2007: LD_VAR 0 4
2011: PUSH
2012: FOR_IN
2013: IFFALSE 2123
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2015: LD_ADDR_VAR 0 8
2019: PUSH
2020: LD_INT 22
2022: PUSH
2023: LD_INT 1
2025: PUSH
2026: EMPTY
2027: LIST
2028: LIST
2029: PUSH
2030: LD_INT 21
2032: PUSH
2033: LD_INT 2
2035: PUSH
2036: EMPTY
2037: LIST
2038: LIST
2039: PUSH
2040: LD_INT 58
2042: PUSH
2043: EMPTY
2044: LIST
2045: PUSH
2046: EMPTY
2047: LIST
2048: LIST
2049: LIST
2050: PPUSH
2051: CALL_OW 69
2055: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2056: LD_VAR 0 2
2060: PPUSH
2061: CALL_OW 247
2065: PUSH
2066: LD_INT 1
2068: EQUAL
2069: PUSH
2070: LD_VAR 0 8
2074: AND
2075: IFFALSE 2097
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2077: LD_VAR 0 2
2081: PPUSH
2082: LD_VAR 0 8
2086: PUSH
2087: LD_INT 1
2089: ARRAY
2090: PPUSH
2091: CALL_OW 52
2095: GO 2112
// PlaceUnitArea ( i , startArea , false ) ;
2097: LD_VAR 0 2
2101: PPUSH
2102: LD_INT 1
2104: PPUSH
2105: LD_INT 0
2107: PPUSH
2108: CALL_OW 49
// ComHold ( i ) ;
2112: LD_VAR 0 2
2116: PPUSH
2117: CALL_OW 140
// end ;
2121: GO 2012
2123: POP
2124: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2125: LD_ADDR_EXP 7
2129: PUSH
2130: LD_STRING 02_mikhailStatus_1
2132: PPUSH
2133: LD_INT 0
2135: PPUSH
2136: CALL_OW 30
2140: ST_TO_ADDR
// if not bierezov_exist and not debug then
2141: LD_EXP 7
2145: NOT
2146: PUSH
2147: LD_EXP 1
2151: NOT
2152: AND
2153: IFFALSE 2157
// exit ;
2155: GO 2188
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2157: LD_ADDR_EXP 42
2161: PUSH
2162: LD_STRING Mikhail
2164: PPUSH
2165: LD_INT 0
2167: PPUSH
2168: CALL 458 0 2
2172: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2173: LD_EXP 42
2177: PPUSH
2178: LD_INT 1
2180: PPUSH
2181: LD_INT 0
2183: PPUSH
2184: CALL_OW 49
// end ;
2188: LD_VAR 0 1
2192: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2193: LD_INT 0
2195: PPUSH
2196: PPUSH
2197: PPUSH
2198: PPUSH
// uc_side := 4 ;
2199: LD_ADDR_OWVAR 20
2203: PUSH
2204: LD_INT 4
2206: ST_TO_ADDR
// uc_nation := 1 ;
2207: LD_ADDR_OWVAR 21
2211: PUSH
2212: LD_INT 1
2214: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2215: LD_ADDR_EXP 41
2219: PUSH
2220: LD_STRING Cornell
2222: PPUSH
2223: LD_INT 0
2225: PPUSH
2226: CALL 458 0 2
2230: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2231: LD_ADDR_EXP 6
2235: PUSH
2236: LD_INT 9
2238: PUSH
2239: LD_EXP 4
2243: MINUS
2244: ST_TO_ADDR
// tmp := [ ] ;
2245: LD_ADDR_VAR 0 2
2249: PUSH
2250: EMPTY
2251: ST_TO_ADDR
// if cornel_units < 4 then
2252: LD_EXP 6
2256: PUSH
2257: LD_INT 4
2259: LESS
2260: IFFALSE 2270
// cornel_units := 4 ;
2262: LD_ADDR_EXP 6
2266: PUSH
2267: LD_INT 4
2269: ST_TO_ADDR
// for i = 1 to cornel_units do
2270: LD_ADDR_VAR 0 4
2274: PUSH
2275: DOUBLE
2276: LD_INT 1
2278: DEC
2279: ST_TO_ADDR
2280: LD_EXP 6
2284: PUSH
2285: FOR_TO
2286: IFFALSE 2384
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2288: LD_INT 0
2290: PPUSH
2291: LD_INT 1
2293: PUSH
2294: LD_INT 1
2296: PUSH
2297: LD_INT 1
2299: PUSH
2300: LD_INT 2
2302: PUSH
2303: LD_INT 4
2305: PUSH
2306: EMPTY
2307: LIST
2308: LIST
2309: LIST
2310: LIST
2311: LIST
2312: PUSH
2313: LD_VAR 0 4
2317: PUSH
2318: LD_INT 5
2320: MOD
2321: PUSH
2322: LD_INT 1
2324: PLUS
2325: ARRAY
2326: PPUSH
2327: LD_INT 2
2329: PPUSH
2330: CALL_OW 380
// un := CreateHuman ;
2334: LD_ADDR_VAR 0 3
2338: PUSH
2339: CALL_OW 44
2343: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2344: LD_ADDR_VAR 0 2
2348: PUSH
2349: LD_VAR 0 2
2353: PPUSH
2354: LD_INT 1
2356: PPUSH
2357: LD_VAR 0 3
2361: PPUSH
2362: CALL_OW 2
2366: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2367: LD_VAR 0 3
2371: PPUSH
2372: LD_INT 2
2374: PPUSH
2375: LD_INT 0
2377: PPUSH
2378: CALL_OW 49
// end ;
2382: GO 2285
2384: POP
2385: POP
// cornel_units := tmp ;
2386: LD_ADDR_EXP 6
2390: PUSH
2391: LD_VAR 0 2
2395: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2396: LD_EXP 41
2400: PPUSH
2401: LD_INT 191
2403: PPUSH
2404: LD_INT 106
2406: PPUSH
2407: LD_INT 0
2409: PPUSH
2410: CALL_OW 48
// end ;
2414: LD_VAR 0 1
2418: RET
// export function PrepareWesternBase ; var i ; begin
2419: LD_INT 0
2421: PPUSH
2422: PPUSH
// uc_side := 8 ;
2423: LD_ADDR_OWVAR 20
2427: PUSH
2428: LD_INT 8
2430: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2431: LD_ADDR_EXP 44
2435: PUSH
2436: LD_STRING Lynch
2438: PPUSH
2439: LD_INT 0
2441: PPUSH
2442: CALL 458 0 2
2446: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2447: LD_ADDR_EXP 45
2451: PUSH
2452: LD_STRING Walker
2454: PPUSH
2455: LD_INT 0
2457: PPUSH
2458: CALL 458 0 2
2462: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2463: LD_ADDR_EXP 46
2467: PUSH
2468: LD_STRING Turner
2470: PPUSH
2471: LD_INT 0
2473: PPUSH
2474: CALL 458 0 2
2478: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2479: LD_ADDR_EXP 47
2483: PUSH
2484: LD_STRING Jillian
2486: PPUSH
2487: LD_INT 0
2489: PPUSH
2490: CALL 458 0 2
2494: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2495: LD_ADDR_VAR 0 2
2499: PUSH
2500: LD_EXP 44
2504: PUSH
2505: LD_EXP 45
2509: PUSH
2510: LD_EXP 46
2514: PUSH
2515: LD_EXP 47
2519: PUSH
2520: EMPTY
2521: LIST
2522: LIST
2523: LIST
2524: LIST
2525: PUSH
2526: FOR_IN
2527: IFFALSE 2555
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2529: LD_VAR 0 2
2533: PPUSH
2534: LD_INT 3
2536: PPUSH
2537: LD_INT 0
2539: PPUSH
2540: CALL_OW 49
// ComHold ( i ) ;
2544: LD_VAR 0 2
2548: PPUSH
2549: CALL_OW 140
// end ;
2553: GO 2526
2555: POP
2556: POP
// end ;
2557: LD_VAR 0 1
2561: RET
// export function SelectGroup ; var units , selected , i ; begin
2562: LD_INT 0
2564: PPUSH
2565: PPUSH
2566: PPUSH
2567: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2568: LD_ADDR_VAR 0 2
2572: PUSH
2573: LD_EXP 34
2577: PUSH
2578: LD_INT -3
2580: PUSH
2581: EMPTY
2582: LIST
2583: LIST
2584: PUSH
2585: LD_EXP 4
2589: ADD
2590: PUSH
2591: LD_INT -2
2593: PUSH
2594: LD_INT -4
2596: PUSH
2597: LD_EXP 41
2601: PUSH
2602: LD_EXP 42
2606: PUSH
2607: EMPTY
2608: LIST
2609: LIST
2610: LIST
2611: LIST
2612: ADD
2613: PUSH
2614: LD_INT -3
2616: PUSH
2617: EMPTY
2618: LIST
2619: ADD
2620: PUSH
2621: LD_EXP 6
2625: ADD
2626: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2627: LD_ADDR_VAR 0 3
2631: PUSH
2632: LD_EXP 34
2636: PUSH
2637: LD_STRING Select five characters to go with you
2639: PPUSH
2640: LD_INT 4
2642: PPUSH
2643: LD_INT 4
2645: PPUSH
2646: LD_VAR 0 2
2650: PPUSH
2651: EMPTY
2652: PPUSH
2653: CALL_OW 42
2657: ADD
2658: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2659: LD_ADDR_EXP 6
2663: PUSH
2664: LD_EXP 4
2668: PUSH
2669: LD_EXP 6
2673: UNION
2674: PUSH
2675: LD_VAR 0 3
2679: DIFF
2680: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2681: LD_ADDR_VAR 0 4
2685: PUSH
2686: LD_EXP 6
2690: PUSH
2691: LD_EXP 42
2695: ADD
2696: PUSH
2697: FOR_IN
2698: IFFALSE 2729
// if GetSide ( i ) = 1 then
2700: LD_VAR 0 4
2704: PPUSH
2705: CALL_OW 255
2709: PUSH
2710: LD_INT 1
2712: EQUAL
2713: IFFALSE 2727
// SetSide ( i , 4 ) ;
2715: LD_VAR 0 4
2719: PPUSH
2720: LD_INT 4
2722: PPUSH
2723: CALL_OW 235
2727: GO 2697
2729: POP
2730: POP
// for i in selected do
2731: LD_ADDR_VAR 0 4
2735: PUSH
2736: LD_VAR 0 3
2740: PUSH
2741: FOR_IN
2742: IFFALSE 2773
// if GetSide ( i ) = 4 then
2744: LD_VAR 0 4
2748: PPUSH
2749: CALL_OW 255
2753: PUSH
2754: LD_INT 4
2756: EQUAL
2757: IFFALSE 2771
// SetSide ( i , 1 ) ;
2759: LD_VAR 0 4
2763: PPUSH
2764: LD_INT 1
2766: PPUSH
2767: CALL_OW 235
2771: GO 2741
2773: POP
2774: POP
// jmm_units := jmm_units diff cornel_units ;
2775: LD_ADDR_EXP 4
2779: PUSH
2780: LD_EXP 4
2784: PUSH
2785: LD_EXP 6
2789: DIFF
2790: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2791: LD_EXP 35
2795: PPUSH
2796: CALL_OW 255
2800: PUSH
2801: LD_INT 4
2803: EQUAL
2804: IFFALSE 2819
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2806: LD_EXP 3
2810: PUSH
2811: LD_STRING Bobby
2813: STR
2814: PPUSH
2815: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2819: LD_EXP 36
2823: PPUSH
2824: CALL_OW 255
2828: PUSH
2829: LD_INT 4
2831: EQUAL
2832: IFFALSE 2847
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2834: LD_EXP 3
2838: PUSH
2839: LD_STRING Cyrus
2841: STR
2842: PPUSH
2843: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2847: LD_EXP 37
2851: PPUSH
2852: CALL_OW 255
2856: PUSH
2857: LD_INT 4
2859: EQUAL
2860: IFFALSE 2875
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2862: LD_EXP 3
2866: PUSH
2867: LD_STRING Lisa
2869: STR
2870: PPUSH
2871: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2875: LD_EXP 38
2879: PPUSH
2880: CALL_OW 255
2884: PUSH
2885: LD_INT 4
2887: EQUAL
2888: IFFALSE 2903
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
2890: LD_EXP 3
2894: PUSH
2895: LD_STRING Khatam
2897: STR
2898: PPUSH
2899: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2903: LD_EXP 39
2907: PPUSH
2908: CALL_OW 255
2912: PUSH
2913: LD_INT 4
2915: EQUAL
2916: IFFALSE 2931
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
2918: LD_EXP 3
2922: PUSH
2923: LD_STRING Brian
2925: STR
2926: PPUSH
2927: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2931: LD_EXP 40
2935: PPUSH
2936: CALL_OW 255
2940: PUSH
2941: LD_INT 4
2943: EQUAL
2944: IFFALSE 2959
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
2946: LD_EXP 3
2950: PUSH
2951: LD_STRING Jerry
2953: STR
2954: PPUSH
2955: CALL_OW 40
// end ; end_of_file
2959: LD_VAR 0 1
2963: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
2964: LD_INT 0
2966: PPUSH
2967: PPUSH
2968: PPUSH
2969: PPUSH
2970: PPUSH
2971: PPUSH
2972: PPUSH
2973: PPUSH
2974: PPUSH
2975: PPUSH
2976: PPUSH
2977: PPUSH
2978: PPUSH
// ru_alert := false ;
2979: LD_ADDR_EXP 57
2983: PUSH
2984: LD_INT 0
2986: ST_TO_ADDR
// ru_produce_list := [ ] ;
2987: LD_ADDR_EXP 54
2991: PUSH
2992: EMPTY
2993: ST_TO_ADDR
// if Difficulty > 1 then
2994: LD_OWVAR 67
2998: PUSH
2999: LD_INT 1
3001: GREATER
3002: IFFALSE 3090
// begin uc_side := 3 ;
3004: LD_ADDR_OWVAR 20
3008: PUSH
3009: LD_INT 3
3011: ST_TO_ADDR
// uc_nation := 3 ;
3012: LD_ADDR_OWVAR 21
3016: PUSH
3017: LD_INT 3
3019: ST_TO_ADDR
// bc_type := b_breastwork ;
3020: LD_ADDR_OWVAR 42
3024: PUSH
3025: LD_INT 31
3027: ST_TO_ADDR
// bc_level := Difficulty ;
3028: LD_ADDR_OWVAR 43
3032: PUSH
3033: LD_OWVAR 67
3037: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3038: LD_INT 22
3040: PPUSH
3041: LD_INT 14
3043: PPUSH
3044: LD_INT 0
3046: PPUSH
3047: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3051: LD_INT 48
3053: PPUSH
3054: LD_INT 46
3056: PPUSH
3057: LD_INT 0
3059: PPUSH
3060: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3064: LD_INT 86
3066: PPUSH
3067: LD_INT 65
3069: PPUSH
3070: LD_INT 5
3072: PPUSH
3073: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3077: LD_INT 165
3079: PPUSH
3080: LD_INT 73
3082: PPUSH
3083: LD_INT 5
3085: PPUSH
3086: CALL_OW 47
// end ; if Difficulty = 3 then
3090: LD_OWVAR 67
3094: PUSH
3095: LD_INT 3
3097: EQUAL
3098: IFFALSE 3113
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3100: LD_INT 51
3102: PPUSH
3103: LD_INT 3
3105: PPUSH
3106: LD_INT 2
3108: PPUSH
3109: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3113: LD_ADDR_VAR 0 7
3117: PUSH
3118: LD_INT 22
3120: PUSH
3121: LD_INT 3
3123: PUSH
3124: EMPTY
3125: LIST
3126: LIST
3127: PUSH
3128: LD_INT 2
3130: PUSH
3131: LD_INT 30
3133: PUSH
3134: LD_INT 31
3136: PUSH
3137: EMPTY
3138: LIST
3139: LIST
3140: PUSH
3141: LD_INT 30
3143: PUSH
3144: LD_INT 32
3146: PUSH
3147: EMPTY
3148: LIST
3149: LIST
3150: PUSH
3151: EMPTY
3152: LIST
3153: LIST
3154: LIST
3155: PUSH
3156: EMPTY
3157: LIST
3158: LIST
3159: PPUSH
3160: CALL_OW 69
3164: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3165: LD_ADDR_VAR 0 8
3169: PUSH
3170: LD_INT 22
3172: PUSH
3173: LD_INT 3
3175: PUSH
3176: EMPTY
3177: LIST
3178: LIST
3179: PUSH
3180: LD_INT 30
3182: PUSH
3183: LD_INT 4
3185: PUSH
3186: EMPTY
3187: LIST
3188: LIST
3189: PUSH
3190: EMPTY
3191: LIST
3192: LIST
3193: PPUSH
3194: CALL_OW 69
3198: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3199: LD_ADDR_VAR 0 10
3203: PUSH
3204: LD_INT 22
3206: PUSH
3207: LD_INT 3
3209: PUSH
3210: EMPTY
3211: LIST
3212: LIST
3213: PUSH
3214: LD_INT 30
3216: PUSH
3217: LD_INT 3
3219: PUSH
3220: EMPTY
3221: LIST
3222: LIST
3223: PUSH
3224: EMPTY
3225: LIST
3226: LIST
3227: PPUSH
3228: CALL_OW 69
3232: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3233: LD_ADDR_VAR 0 9
3237: PUSH
3238: LD_INT 22
3240: PUSH
3241: LD_INT 3
3243: PUSH
3244: EMPTY
3245: LIST
3246: LIST
3247: PUSH
3248: LD_INT 30
3250: PUSH
3251: LD_INT 6
3253: PUSH
3254: EMPTY
3255: LIST
3256: LIST
3257: PUSH
3258: EMPTY
3259: LIST
3260: LIST
3261: PPUSH
3262: CALL_OW 69
3266: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3267: LD_ADDR_VAR 0 2
3271: PUSH
3272: LD_INT 22
3274: PUSH
3275: LD_INT 3
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: PUSH
3282: LD_INT 30
3284: PUSH
3285: LD_INT 1
3287: PUSH
3288: EMPTY
3289: LIST
3290: LIST
3291: PUSH
3292: EMPTY
3293: LIST
3294: LIST
3295: PPUSH
3296: CALL_OW 69
3300: PUSH
3301: FOR_IN
3302: IFFALSE 3346
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3304: LD_VAR 0 2
3308: PPUSH
3309: CALL_OW 274
3313: PPUSH
3314: LD_INT 1
3316: PPUSH
3317: LD_INT 5000
3319: PPUSH
3320: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3324: LD_VAR 0 2
3328: PPUSH
3329: CALL_OW 274
3333: PPUSH
3334: LD_INT 2
3336: PPUSH
3337: LD_INT 3000
3339: PPUSH
3340: CALL_OW 277
// end ;
3344: GO 3301
3346: POP
3347: POP
// uc_side := 3 ;
3348: LD_ADDR_OWVAR 20
3352: PUSH
3353: LD_INT 3
3355: ST_TO_ADDR
// uc_nation := 3 ;
3356: LD_ADDR_OWVAR 21
3360: PUSH
3361: LD_INT 3
3363: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3364: LD_ADDR_VAR 0 11
3368: PUSH
3369: LD_INT 2
3371: PUSH
3372: LD_INT 3
3374: PUSH
3375: LD_INT 4
3377: PUSH
3378: EMPTY
3379: LIST
3380: LIST
3381: LIST
3382: PUSH
3383: LD_OWVAR 67
3387: ARRAY
3388: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3389: LD_ADDR_EXP 49
3393: PUSH
3394: LD_STRING Pokryshkin
3396: PPUSH
3397: LD_INT 0
3399: PPUSH
3400: CALL 458 0 2
3404: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3405: LD_EXP 49
3409: PPUSH
3410: LD_INT 63
3412: PPUSH
3413: LD_INT 21
3415: PPUSH
3416: LD_INT 0
3418: PPUSH
3419: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3423: LD_EXP 49
3427: PPUSH
3428: CALL_OW 140
// InitHc ;
3432: CALL_OW 19
// for i in fac do
3436: LD_ADDR_VAR 0 2
3440: PUSH
3441: LD_VAR 0 10
3445: PUSH
3446: FOR_IN
3447: IFFALSE 3500
// begin for j = 1 to 6 do
3449: LD_ADDR_VAR 0 3
3453: PUSH
3454: DOUBLE
3455: LD_INT 1
3457: DEC
3458: ST_TO_ADDR
3459: LD_INT 6
3461: PUSH
3462: FOR_TO
3463: IFFALSE 3496
// begin PrepareHuman ( false , 3 , skill ) ;
3465: LD_INT 0
3467: PPUSH
3468: LD_INT 3
3470: PPUSH
3471: LD_VAR 0 11
3475: PPUSH
3476: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3480: CALL_OW 44
3484: PPUSH
3485: LD_VAR 0 2
3489: PPUSH
3490: CALL_OW 52
// end ;
3494: GO 3462
3496: POP
3497: POP
// end ;
3498: GO 3446
3500: POP
3501: POP
// for i in lab do
3502: LD_ADDR_VAR 0 2
3506: PUSH
3507: LD_VAR 0 9
3511: PUSH
3512: FOR_IN
3513: IFFALSE 3546
// begin PrepareHuman ( false , 4 , skill ) ;
3515: LD_INT 0
3517: PPUSH
3518: LD_INT 4
3520: PPUSH
3521: LD_VAR 0 11
3525: PPUSH
3526: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3530: CALL_OW 44
3534: PPUSH
3535: LD_VAR 0 2
3539: PPUSH
3540: CALL_OW 52
// end ;
3544: GO 3512
3546: POP
3547: POP
// for i in tw do
3548: LD_ADDR_VAR 0 2
3552: PUSH
3553: LD_VAR 0 7
3557: PUSH
3558: FOR_IN
3559: IFFALSE 3608
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3561: LD_VAR 0 2
3565: PPUSH
3566: LD_INT 42
3568: PUSH
3569: LD_INT 43
3571: PUSH
3572: EMPTY
3573: LIST
3574: LIST
3575: PUSH
3576: LD_INT 1
3578: PPUSH
3579: LD_INT 2
3581: PPUSH
3582: CALL_OW 12
3586: ARRAY
3587: PPUSH
3588: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3592: LD_VAR 0 11
3596: PPUSH
3597: LD_VAR 0 2
3601: PPUSH
3602: CALL 799 0 2
// end ;
3606: GO 3558
3608: POP
3609: POP
// for i in bar do
3610: LD_ADDR_VAR 0 2
3614: PUSH
3615: LD_VAR 0 8
3619: PUSH
3620: FOR_IN
3621: IFFALSE 3654
// begin PrepareHuman ( false , 1 , skill ) ;
3623: LD_INT 0
3625: PPUSH
3626: LD_INT 1
3628: PPUSH
3629: LD_VAR 0 11
3633: PPUSH
3634: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3638: CALL_OW 44
3642: PPUSH
3643: LD_VAR 0 2
3647: PPUSH
3648: CALL_OW 52
// end ;
3652: GO 3620
3654: POP
3655: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3656: LD_ADDR_VAR 0 13
3660: PUSH
3661: LD_INT 100
3663: PUSH
3664: LD_INT 9
3666: PUSH
3667: EMPTY
3668: LIST
3669: LIST
3670: PUSH
3671: LD_INT 135
3673: PUSH
3674: LD_INT 60
3676: PUSH
3677: EMPTY
3678: LIST
3679: LIST
3680: PUSH
3681: LD_INT 41
3683: PUSH
3684: LD_INT 6
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: PUSH
3691: LD_INT 22
3693: PUSH
3694: LD_INT 9
3696: PUSH
3697: EMPTY
3698: LIST
3699: LIST
3700: PUSH
3701: LD_INT 84
3703: PUSH
3704: LD_INT 14
3706: PUSH
3707: EMPTY
3708: LIST
3709: LIST
3710: PUSH
3711: EMPTY
3712: LIST
3713: LIST
3714: LIST
3715: LIST
3716: LIST
3717: ST_TO_ADDR
// vehicles := [ ] ;
3718: LD_ADDR_VAR 0 12
3722: PUSH
3723: EMPTY
3724: ST_TO_ADDR
// for i in spot_xy do
3725: LD_ADDR_VAR 0 2
3729: PUSH
3730: LD_VAR 0 13
3734: PUSH
3735: FOR_IN
3736: IFFALSE 3894
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3738: LD_ADDR_VAR 0 6
3742: PUSH
3743: LD_INT 3
3745: PPUSH
3746: LD_INT 3
3748: PPUSH
3749: LD_INT 22
3751: PPUSH
3752: LD_INT 1
3754: PPUSH
3755: LD_INT 1
3757: PPUSH
3758: LD_INT 42
3760: PUSH
3761: LD_INT 43
3763: PUSH
3764: LD_INT 44
3766: PUSH
3767: EMPTY
3768: LIST
3769: LIST
3770: LIST
3771: PUSH
3772: LD_INT 1
3774: PPUSH
3775: LD_INT 3
3777: PPUSH
3778: CALL_OW 12
3782: ARRAY
3783: PPUSH
3784: LD_INT 100
3786: PPUSH
3787: CALL 521 0 7
3791: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3792: LD_ADDR_VAR 0 12
3796: PUSH
3797: LD_VAR 0 12
3801: PPUSH
3802: LD_VAR 0 12
3806: PUSH
3807: LD_INT 1
3809: PLUS
3810: PPUSH
3811: LD_VAR 0 6
3815: PPUSH
3816: CALL_OW 2
3820: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3821: LD_VAR 0 6
3825: PPUSH
3826: LD_INT 3
3828: PPUSH
3829: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3833: LD_VAR 0 6
3837: PPUSH
3838: LD_VAR 0 2
3842: PUSH
3843: LD_INT 1
3845: ARRAY
3846: PPUSH
3847: LD_VAR 0 2
3851: PUSH
3852: LD_INT 2
3854: ARRAY
3855: PPUSH
3856: LD_INT 0
3858: PPUSH
3859: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3863: LD_INT 0
3865: PPUSH
3866: LD_INT 3
3868: PPUSH
3869: LD_VAR 0 11
3873: PPUSH
3874: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3878: CALL_OW 44
3882: PPUSH
3883: LD_VAR 0 6
3887: PPUSH
3888: CALL_OW 52
// end ;
3892: GO 3735
3894: POP
3895: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3896: LD_ADDR_VAR 0 2
3900: PUSH
3901: DOUBLE
3902: LD_INT 1
3904: DEC
3905: ST_TO_ADDR
3906: LD_INT 5
3908: PUSH
3909: LD_INT 7
3911: PUSH
3912: LD_INT 8
3914: PUSH
3915: EMPTY
3916: LIST
3917: LIST
3918: LIST
3919: PUSH
3920: LD_OWVAR 67
3924: ARRAY
3925: PUSH
3926: FOR_TO
3927: IFFALSE 3987
// begin PrepareHuman ( false , 1 , skill ) ;
3929: LD_INT 0
3931: PPUSH
3932: LD_INT 1
3934: PPUSH
3935: LD_VAR 0 11
3939: PPUSH
3940: CALL_OW 380
// un := CreateHuman ;
3944: LD_ADDR_VAR 0 5
3948: PUSH
3949: CALL_OW 44
3953: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3954: LD_VAR 0 5
3958: PPUSH
3959: LD_INT 11
3961: PPUSH
3962: LD_INT 0
3964: PPUSH
3965: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3969: LD_ADDR_EXP 52
3973: PUSH
3974: LD_EXP 52
3978: PUSH
3979: LD_VAR 0 5
3983: ADD
3984: ST_TO_ADDR
// end ;
3985: GO 3926
3987: POP
3988: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3989: LD_ADDR_VAR 0 2
3993: PUSH
3994: DOUBLE
3995: LD_INT 1
3997: DEC
3998: ST_TO_ADDR
3999: LD_INT 2
4001: PUSH
4002: LD_INT 3
4004: PUSH
4005: LD_INT 4
4007: PUSH
4008: EMPTY
4009: LIST
4010: LIST
4011: LIST
4012: PUSH
4013: LD_OWVAR 67
4017: ARRAY
4018: PUSH
4019: FOR_TO
4020: IFFALSE 4080
// begin PrepareHuman ( false , 1 , skill ) ;
4022: LD_INT 0
4024: PPUSH
4025: LD_INT 1
4027: PPUSH
4028: LD_VAR 0 11
4032: PPUSH
4033: CALL_OW 380
// un := CreateHuman ;
4037: LD_ADDR_VAR 0 5
4041: PUSH
4042: CALL_OW 44
4046: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4047: LD_VAR 0 5
4051: PPUSH
4052: LD_INT 12
4054: PPUSH
4055: LD_INT 0
4057: PPUSH
4058: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4062: LD_ADDR_EXP 50
4066: PUSH
4067: LD_EXP 50
4071: PUSH
4072: LD_VAR 0 5
4076: ADD
4077: ST_TO_ADDR
// end ;
4078: GO 4019
4080: POP
4081: POP
// for i = 1 to 2 do
4082: LD_ADDR_VAR 0 2
4086: PUSH
4087: DOUBLE
4088: LD_INT 1
4090: DEC
4091: ST_TO_ADDR
4092: LD_INT 2
4094: PUSH
4095: FOR_TO
4096: IFFALSE 4162
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4098: LD_INT 1
4100: PPUSH
4101: LD_INT 1
4103: PPUSH
4104: LD_VAR 0 11
4108: PPUSH
4109: CALL_OW 380
// un := CreateHuman ;
4113: LD_ADDR_VAR 0 5
4117: PUSH
4118: CALL_OW 44
4122: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4123: LD_VAR 0 5
4127: PPUSH
4128: LD_INT 39
4130: PPUSH
4131: LD_INT 12
4133: PPUSH
4134: LD_INT 3
4136: PPUSH
4137: LD_INT 0
4139: PPUSH
4140: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4144: LD_ADDR_EXP 51
4148: PUSH
4149: LD_EXP 51
4153: PUSH
4154: LD_VAR 0 5
4158: ADD
4159: ST_TO_ADDR
// end ;
4160: GO 4095
4162: POP
4163: POP
// for i = 1 to 3 do
4164: LD_ADDR_VAR 0 2
4168: PUSH
4169: DOUBLE
4170: LD_INT 1
4172: DEC
4173: ST_TO_ADDR
4174: LD_INT 3
4176: PUSH
4177: FOR_TO
4178: IFFALSE 4244
// begin PrepareHuman ( false , 1 , skill ) ;
4180: LD_INT 0
4182: PPUSH
4183: LD_INT 1
4185: PPUSH
4186: LD_VAR 0 11
4190: PPUSH
4191: CALL_OW 380
// un := CreateHuman ;
4195: LD_ADDR_VAR 0 5
4199: PUSH
4200: CALL_OW 44
4204: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4205: LD_VAR 0 5
4209: PPUSH
4210: LD_INT 180
4212: PPUSH
4213: LD_INT 11
4215: PPUSH
4216: LD_INT 4
4218: PPUSH
4219: LD_INT 0
4221: PPUSH
4222: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4226: LD_ADDR_EXP 55
4230: PUSH
4231: LD_EXP 55
4235: PUSH
4236: LD_VAR 0 5
4240: ADD
4241: ST_TO_ADDR
// end ;
4242: GO 4177
4244: POP
4245: POP
// ru_vehicles := vehicles ;
4246: LD_ADDR_EXP 53
4250: PUSH
4251: LD_VAR 0 12
4255: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4256: LD_ADDR_EXP 56
4260: PUSH
4261: LD_INT 131
4263: PUSH
4264: LD_INT 121
4266: PUSH
4267: EMPTY
4268: LIST
4269: LIST
4270: PUSH
4271: LD_INT 113
4273: PUSH
4274: LD_INT 90
4276: PUSH
4277: EMPTY
4278: LIST
4279: LIST
4280: PUSH
4281: LD_INT 93
4283: PUSH
4284: LD_INT 62
4286: PUSH
4287: EMPTY
4288: LIST
4289: LIST
4290: PUSH
4291: EMPTY
4292: LIST
4293: LIST
4294: LIST
4295: PUSH
4296: LD_INT 106
4298: PUSH
4299: LD_INT 54
4301: PUSH
4302: EMPTY
4303: LIST
4304: LIST
4305: PUSH
4306: LD_INT 120
4308: PUSH
4309: LD_INT 80
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: PUSH
4316: LD_INT 143
4318: PUSH
4319: LD_INT 120
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: PUSH
4326: EMPTY
4327: LIST
4328: LIST
4329: LIST
4330: PUSH
4331: LD_INT 154
4333: PUSH
4334: LD_INT 116
4336: PUSH
4337: EMPTY
4338: LIST
4339: LIST
4340: PUSH
4341: LD_INT 140
4343: PUSH
4344: LD_INT 93
4346: PUSH
4347: EMPTY
4348: LIST
4349: LIST
4350: PUSH
4351: LD_INT 130
4353: PUSH
4354: LD_INT 58
4356: PUSH
4357: EMPTY
4358: LIST
4359: LIST
4360: PUSH
4361: EMPTY
4362: LIST
4363: LIST
4364: LIST
4365: PUSH
4366: LD_INT 105
4368: PUSH
4369: LD_INT 106
4371: PUSH
4372: EMPTY
4373: LIST
4374: LIST
4375: PUSH
4376: LD_INT 134
4378: PUSH
4379: LD_INT 98
4381: PUSH
4382: EMPTY
4383: LIST
4384: LIST
4385: PUSH
4386: LD_INT 159
4388: PUSH
4389: LD_INT 113
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: LIST
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: LIST
4405: LIST
4406: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4407: LD_ADDR_VAR 0 2
4411: PUSH
4412: DOUBLE
4413: LD_INT 1
4415: DEC
4416: ST_TO_ADDR
4417: LD_OWVAR 67
4421: PUSH
4422: LD_INT 1
4424: MINUS
4425: PUSH
4426: FOR_TO
4427: IFFALSE 4460
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4429: LD_ADDR_EXP 54
4433: PUSH
4434: LD_EXP 54
4438: PUSH
4439: LD_INT 22
4441: PUSH
4442: LD_INT 1
4444: PUSH
4445: LD_INT 1
4447: PUSH
4448: LD_INT 43
4450: PUSH
4451: EMPTY
4452: LIST
4453: LIST
4454: LIST
4455: LIST
4456: ADD
4457: ST_TO_ADDR
4458: GO 4426
4460: POP
4461: POP
// end ;
4462: LD_VAR 0 1
4466: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4467: LD_INT 22
4469: PUSH
4470: LD_INT 3
4472: PUSH
4473: EMPTY
4474: LIST
4475: LIST
4476: PUSH
4477: LD_INT 21
4479: PUSH
4480: LD_INT 2
4482: PUSH
4483: EMPTY
4484: LIST
4485: LIST
4486: PUSH
4487: EMPTY
4488: LIST
4489: LIST
4490: PPUSH
4491: CALL_OW 69
4495: IFFALSE 4589
4497: GO 4499
4499: DISABLE
4500: LD_INT 0
4502: PPUSH
4503: PPUSH
// begin enable ;
4504: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4505: LD_ADDR_VAR 0 2
4509: PUSH
4510: LD_INT 22
4512: PUSH
4513: LD_INT 3
4515: PUSH
4516: EMPTY
4517: LIST
4518: LIST
4519: PUSH
4520: LD_INT 21
4522: PUSH
4523: LD_INT 2
4525: PUSH
4526: EMPTY
4527: LIST
4528: LIST
4529: PUSH
4530: EMPTY
4531: LIST
4532: LIST
4533: PPUSH
4534: CALL_OW 69
4538: ST_TO_ADDR
// if filter then
4539: LD_VAR 0 2
4543: IFFALSE 4589
// for i in filter do
4545: LD_ADDR_VAR 0 1
4549: PUSH
4550: LD_VAR 0 2
4554: PUSH
4555: FOR_IN
4556: IFFALSE 4587
// if GetFuel ( i ) < 20 then
4558: LD_VAR 0 1
4562: PPUSH
4563: CALL_OW 261
4567: PUSH
4568: LD_INT 20
4570: LESS
4571: IFFALSE 4585
// SetFuel ( i , 20 ) ;
4573: LD_VAR 0 1
4577: PPUSH
4578: LD_INT 20
4580: PPUSH
4581: CALL_OW 240
4585: GO 4555
4587: POP
4588: POP
// end ;
4589: PPOPN 2
4591: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4592: LD_EXP 54
4596: IFFALSE 4815
4598: GO 4600
4600: DISABLE
4601: LD_INT 0
4603: PPUSH
4604: PPUSH
4605: PPUSH
// begin enable ;
4606: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4607: LD_ADDR_VAR 0 2
4611: PUSH
4612: LD_INT 22
4614: PUSH
4615: LD_INT 3
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: PUSH
4622: LD_INT 30
4624: PUSH
4625: LD_INT 3
4627: PUSH
4628: EMPTY
4629: LIST
4630: LIST
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: PPUSH
4636: CALL_OW 69
4640: ST_TO_ADDR
// can_produce := [ ] ;
4641: LD_ADDR_VAR 0 3
4645: PUSH
4646: EMPTY
4647: ST_TO_ADDR
// if not fac then
4648: LD_VAR 0 2
4652: NOT
4653: IFFALSE 4658
// begin disable ;
4655: DISABLE
// exit ;
4656: GO 4815
// end ; for i in fac do
4658: LD_ADDR_VAR 0 1
4662: PUSH
4663: LD_VAR 0 2
4667: PUSH
4668: FOR_IN
4669: IFFALSE 4707
// if UnitsInside ( i ) then
4671: LD_VAR 0 1
4675: PPUSH
4676: CALL_OW 313
4680: IFFALSE 4705
// can_produce := Insert ( can_produce , 1 , i ) ;
4682: LD_ADDR_VAR 0 3
4686: PUSH
4687: LD_VAR 0 3
4691: PPUSH
4692: LD_INT 1
4694: PPUSH
4695: LD_VAR 0 1
4699: PPUSH
4700: CALL_OW 2
4704: ST_TO_ADDR
4705: GO 4668
4707: POP
4708: POP
// if not can_produce then
4709: LD_VAR 0 3
4713: NOT
4714: IFFALSE 4718
// exit ;
4716: GO 4815
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4718: LD_VAR 0 3
4722: PUSH
4723: LD_INT 1
4725: PPUSH
4726: LD_VAR 0 3
4730: PPUSH
4731: CALL_OW 12
4735: ARRAY
4736: PPUSH
4737: LD_EXP 54
4741: PUSH
4742: LD_INT 1
4744: ARRAY
4745: PPUSH
4746: LD_EXP 54
4750: PUSH
4751: LD_INT 2
4753: ARRAY
4754: PPUSH
4755: LD_EXP 54
4759: PUSH
4760: LD_INT 3
4762: ARRAY
4763: PPUSH
4764: LD_EXP 54
4768: PUSH
4769: LD_INT 4
4771: ARRAY
4772: PPUSH
4773: CALL_OW 125
// for i = 1 to 4 do
4777: LD_ADDR_VAR 0 1
4781: PUSH
4782: DOUBLE
4783: LD_INT 1
4785: DEC
4786: ST_TO_ADDR
4787: LD_INT 4
4789: PUSH
4790: FOR_TO
4791: IFFALSE 4813
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4793: LD_ADDR_EXP 54
4797: PUSH
4798: LD_EXP 54
4802: PPUSH
4803: LD_INT 1
4805: PPUSH
4806: CALL_OW 3
4810: ST_TO_ADDR
4811: GO 4790
4813: POP
4814: POP
// end ;
4815: PPOPN 3
4817: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4818: LD_INT 0
4820: PPUSH
4821: PPUSH
4822: PPUSH
// for i = 1 to 6 do
4823: LD_ADDR_VAR 0 2
4827: PUSH
4828: DOUBLE
4829: LD_INT 1
4831: DEC
4832: ST_TO_ADDR
4833: LD_INT 6
4835: PUSH
4836: FOR_TO
4837: IFFALSE 4986
// begin PrepareHuman ( false , 3 , 3 ) ;
4839: LD_INT 0
4841: PPUSH
4842: LD_INT 3
4844: PPUSH
4845: LD_INT 3
4847: PPUSH
4848: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4852: LD_ADDR_VAR 0 3
4856: PUSH
4857: LD_INT 3
4859: PPUSH
4860: LD_INT 3
4862: PPUSH
4863: LD_INT 22
4865: PPUSH
4866: LD_INT 1
4868: PPUSH
4869: LD_INT 1
4871: PPUSH
4872: LD_INT 43
4874: PUSH
4875: LD_INT 42
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: PUSH
4882: LD_INT 1
4884: PPUSH
4885: LD_INT 2
4887: PPUSH
4888: CALL_OW 12
4892: ARRAY
4893: PPUSH
4894: LD_INT 70
4896: PPUSH
4897: CALL 521 0 7
4901: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4902: LD_VAR 0 3
4906: PPUSH
4907: LD_INT 4
4909: PPUSH
4910: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4914: LD_VAR 0 3
4918: PPUSH
4919: LD_INT 229
4921: PPUSH
4922: LD_INT 44
4924: PPUSH
4925: LD_INT 0
4927: PPUSH
4928: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4932: CALL_OW 44
4936: PPUSH
4937: LD_VAR 0 3
4941: PPUSH
4942: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4946: LD_ADDR_EXP 53
4950: PUSH
4951: LD_EXP 53
4955: PUSH
4956: LD_VAR 0 3
4960: ADD
4961: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
4962: LD_VAR 0 3
4966: PPUSH
4967: LD_INT 191
4969: PPUSH
4970: LD_INT 32
4972: PPUSH
4973: CALL_OW 111
// Wait ( 0 0$02 ) ;
4977: LD_INT 70
4979: PPUSH
4980: CALL_OW 67
// end ;
4984: GO 4836
4986: POP
4987: POP
// end ;
4988: LD_VAR 0 1
4992: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
4993: LD_EXP 29
4997: PUSH
4998: LD_EXP 53
5002: AND
5003: IFFALSE 5177
5005: GO 5007
5007: DISABLE
5008: LD_INT 0
5010: PPUSH
5011: PPUSH
5012: PPUSH
// begin wait ( 0 0$50 ) ;
5013: LD_INT 1750
5015: PPUSH
5016: CALL_OW 67
// tmp := ru_vehicles ;
5020: LD_ADDR_VAR 0 3
5024: PUSH
5025: LD_EXP 53
5029: ST_TO_ADDR
// if not tmp then
5030: LD_VAR 0 3
5034: NOT
5035: IFFALSE 5039
// exit ;
5037: GO 5177
// repeat wait ( 0 0$1 ) ;
5039: LD_INT 35
5041: PPUSH
5042: CALL_OW 67
// for i in tmp do
5046: LD_ADDR_VAR 0 1
5050: PUSH
5051: LD_VAR 0 3
5055: PUSH
5056: FOR_IN
5057: IFFALSE 5168
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5059: LD_ADDR_VAR 0 2
5063: PUSH
5064: LD_INT 22
5066: PUSH
5067: LD_INT 1
5069: PUSH
5070: EMPTY
5071: LIST
5072: LIST
5073: PPUSH
5074: LD_VAR 0 1
5078: PPUSH
5079: CALL_OW 74
5083: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5084: LD_VAR 0 1
5088: PPUSH
5089: LD_VAR 0 2
5093: PPUSH
5094: CALL_OW 296
5098: PUSH
5099: LD_INT 10
5101: GREATER
5102: IFFALSE 5121
// ComAgressiveMove ( i , 69 , 101 ) else
5104: LD_VAR 0 1
5108: PPUSH
5109: LD_INT 69
5111: PPUSH
5112: LD_INT 101
5114: PPUSH
5115: CALL_OW 114
5119: GO 5135
// ComAttackUnit ( i , enemy ) ;
5121: LD_VAR 0 1
5125: PPUSH
5126: LD_VAR 0 2
5130: PPUSH
5131: CALL_OW 115
// if GetLives ( i ) < 250 then
5135: LD_VAR 0 1
5139: PPUSH
5140: CALL_OW 256
5144: PUSH
5145: LD_INT 250
5147: LESS
5148: IFFALSE 5166
// tmp := tmp diff i ;
5150: LD_ADDR_VAR 0 3
5154: PUSH
5155: LD_VAR 0 3
5159: PUSH
5160: LD_VAR 0 1
5164: DIFF
5165: ST_TO_ADDR
// end ;
5166: GO 5056
5168: POP
5169: POP
// until not tmp ;
5170: LD_VAR 0 3
5174: NOT
5175: IFFALSE 5039
// end ; end_of_file
5177: PPOPN 3
5179: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5180: LD_INT 0
5182: PPUSH
5183: PPUSH
5184: PPUSH
5185: PPUSH
5186: PPUSH
5187: PPUSH
5188: PPUSH
// InGameOn ;
5189: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5193: LD_EXP 34
5197: PPUSH
5198: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5202: LD_EXP 34
5206: PPUSH
5207: LD_EXP 41
5211: PPUSH
5212: CALL_OW 119
// if Bierezov then
5216: LD_EXP 42
5220: IFFALSE 5236
// ComTurnUnit ( Bierezov , Cornel ) ;
5222: LD_EXP 42
5226: PPUSH
5227: LD_EXP 41
5231: PPUSH
5232: CALL_OW 119
// for i in jmm_units do
5236: LD_ADDR_VAR 0 2
5240: PUSH
5241: LD_EXP 4
5245: PUSH
5246: FOR_IN
5247: IFFALSE 5265
// ComTurnUnit ( i , Cornel ) ;
5249: LD_VAR 0 2
5253: PPUSH
5254: LD_EXP 41
5258: PPUSH
5259: CALL_OW 119
5263: GO 5246
5265: POP
5266: POP
// units := cornel_units union Cornel ;
5267: LD_ADDR_VAR 0 3
5271: PUSH
5272: LD_EXP 6
5276: PUSH
5277: LD_EXP 41
5281: UNION
5282: ST_TO_ADDR
// repeat wait ( 1 ) ;
5283: LD_INT 1
5285: PPUSH
5286: CALL_OW 67
// for i in units do
5290: LD_ADDR_VAR 0 2
5294: PUSH
5295: LD_VAR 0 3
5299: PUSH
5300: FOR_IN
5301: IFFALSE 5334
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5303: LD_VAR 0 2
5307: PPUSH
5308: LD_EXP 34
5312: PPUSH
5313: CALL_OW 250
5317: PPUSH
5318: LD_EXP 34
5322: PPUSH
5323: CALL_OW 251
5327: PPUSH
5328: CALL_OW 111
5332: GO 5300
5334: POP
5335: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5336: LD_VAR 0 3
5340: PPUSH
5341: LD_INT 92
5343: PUSH
5344: LD_EXP 34
5348: PPUSH
5349: CALL_OW 250
5353: PUSH
5354: LD_EXP 34
5358: PPUSH
5359: CALL_OW 251
5363: PUSH
5364: LD_INT 10
5366: PUSH
5367: EMPTY
5368: LIST
5369: LIST
5370: LIST
5371: LIST
5372: PPUSH
5373: CALL_OW 72
5377: PUSH
5378: LD_VAR 0 3
5382: EQUAL
5383: IFFALSE 5283
// for i in units do
5385: LD_ADDR_VAR 0 2
5389: PUSH
5390: LD_VAR 0 3
5394: PUSH
5395: FOR_IN
5396: IFFALSE 5414
// ComTurnUnit ( i , JMM ) ;
5398: LD_VAR 0 2
5402: PPUSH
5403: LD_EXP 34
5407: PPUSH
5408: CALL_OW 119
5412: GO 5395
5414: POP
5415: POP
// ComTurnUnit ( Cornel , JMM ) ;
5416: LD_EXP 41
5420: PPUSH
5421: LD_EXP 34
5425: PPUSH
5426: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5430: LD_EXP 34
5434: PPUSH
5435: LD_STRING D1-JMM-1
5437: PPUSH
5438: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5442: LD_EXP 41
5446: PPUSH
5447: LD_STRING D1-Corn-1
5449: PPUSH
5450: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5454: LD_EXP 34
5458: PPUSH
5459: LD_EXP 41
5463: PPUSH
5464: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5468: LD_EXP 41
5472: PPUSH
5473: LD_EXP 34
5477: PPUSH
5478: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5482: LD_INT 35
5484: PPUSH
5485: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5489: LD_EXP 34
5493: PPUSH
5494: LD_EXP 41
5498: PPUSH
5499: CALL_OW 296
5503: PUSH
5504: LD_INT 6
5506: LESS
5507: IFFALSE 5482
// ChangeSideFog ( 4 , 1 ) ;
5509: LD_INT 4
5511: PPUSH
5512: LD_INT 1
5514: PPUSH
5515: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5519: LD_EXP 34
5523: PPUSH
5524: LD_EXP 41
5528: PPUSH
5529: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5533: LD_EXP 41
5537: PPUSH
5538: LD_EXP 34
5542: PPUSH
5543: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5547: LD_EXP 34
5551: PPUSH
5552: LD_STRING D1-JMM-2
5554: PPUSH
5555: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5559: LD_EXP 34
5563: PPUSH
5564: LD_STRING D1-JMM-2a
5566: PPUSH
5567: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5571: LD_EXP 41
5575: PPUSH
5576: LD_STRING D1-Corn-2
5578: PPUSH
5579: CALL_OW 88
// if bierezov_exist or debug then
5583: LD_EXP 7
5587: PUSH
5588: LD_EXP 1
5592: OR
5593: IFFALSE 5834
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5595: LD_EXP 41
5599: PPUSH
5600: LD_EXP 42
5604: PPUSH
5605: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5609: LD_INT 10
5611: PPUSH
5612: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5616: LD_EXP 41
5620: PPUSH
5621: LD_STRING D1a-Corn-1
5623: PPUSH
5624: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5628: LD_EXP 34
5632: PPUSH
5633: LD_EXP 42
5637: PPUSH
5638: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5642: LD_EXP 42
5646: PPUSH
5647: LD_EXP 34
5651: PPUSH
5652: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5656: LD_EXP 34
5660: PPUSH
5661: LD_STRING D1a-JMM-1
5663: PPUSH
5664: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5668: LD_EXP 34
5672: PPUSH
5673: LD_EXP 41
5677: PPUSH
5678: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5682: LD_EXP 41
5686: PPUSH
5687: LD_EXP 34
5691: PPUSH
5692: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5696: LD_EXP 41
5700: PPUSH
5701: LD_STRING D1a-Corn-2
5703: PPUSH
5704: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5708: LD_EXP 34
5712: PPUSH
5713: LD_STRING D1a-JMM-2
5715: PPUSH
5716: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5720: LD_EXP 41
5724: PPUSH
5725: LD_STRING D1a-Corn-3
5727: PPUSH
5728: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5732: LD_EXP 34
5736: PPUSH
5737: LD_STRING D1a-JMM-3
5739: PPUSH
5740: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5744: LD_EXP 41
5748: PPUSH
5749: LD_STRING D1a-Corn-4
5751: PPUSH
5752: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5756: LD_EXP 34
5760: PPUSH
5761: LD_STRING D1a-JMM-4
5763: PPUSH
5764: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5768: LD_EXP 41
5772: PPUSH
5773: LD_STRING D1a-Corn-5
5775: PPUSH
5776: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5780: LD_EXP 42
5784: PPUSH
5785: LD_EXP 41
5789: PPUSH
5790: CALL_OW 250
5794: PPUSH
5795: LD_EXP 41
5799: PPUSH
5800: CALL_OW 251
5804: PUSH
5805: LD_INT 2
5807: MINUS
5808: PPUSH
5809: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5813: LD_EXP 42
5817: PPUSH
5818: LD_EXP 41
5822: PPUSH
5823: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5827: LD_INT 10
5829: PPUSH
5830: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5834: LD_EXP 34
5838: PPUSH
5839: LD_STRING D1b-JMM-1
5841: PPUSH
5842: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5846: LD_EXP 41
5850: PPUSH
5851: LD_STRING D1b-Corn-1
5853: PPUSH
5854: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5858: LD_EXP 34
5862: PPUSH
5863: LD_STRING D1b-JMM-2
5865: PPUSH
5866: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5870: LD_EXP 41
5874: PPUSH
5875: LD_STRING D1b-Corn-2
5877: PPUSH
5878: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5882: LD_EXP 34
5886: PPUSH
5887: LD_STRING D1b-JMM-3
5889: PPUSH
5890: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5894: LD_INT 10
5896: PPUSH
5897: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5901: LD_EXP 43
5905: PPUSH
5906: LD_STRING D1b-Pow-3
5908: PPUSH
5909: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5913: LD_EXP 34
5917: PPUSH
5918: LD_STRING D1b-JMM-4
5920: PPUSH
5921: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5925: LD_EXP 41
5929: PPUSH
5930: LD_STRING D1b-Corn-4
5932: PPUSH
5933: CALL_OW 88
// if Khatam then
5937: LD_EXP 38
5941: IFFALSE 5957
// Say ( Khatam , D1b-Khat-4 ) else
5943: LD_EXP 38
5947: PPUSH
5948: LD_STRING D1b-Khat-4
5950: PPUSH
5951: CALL_OW 88
5955: GO 5993
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
5957: LD_EXP 6
5961: PPUSH
5962: LD_INT 26
5964: PUSH
5965: LD_INT 1
5967: PUSH
5968: EMPTY
5969: LIST
5970: LIST
5971: PPUSH
5972: CALL_OW 72
5976: PUSH
5977: LD_EXP 41
5981: PUSH
5982: EMPTY
5983: LIST
5984: DIFF
5985: PPUSH
5986: LD_STRING D1b-Sol1-4
5988: PPUSH
5989: CALL 609 0 2
// if Cyrus then
5993: LD_EXP 36
5997: IFFALSE 6011
// Say ( Cyrus , D1b-Cyrus-4 ) ;
5999: LD_EXP 36
6003: PPUSH
6004: LD_STRING D1b-Cyrus-4
6006: PPUSH
6007: CALL_OW 88
// if Lisa then
6011: LD_EXP 37
6015: IFFALSE 6073
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6017: LD_EXP 37
6021: PPUSH
6022: LD_STRING D1b-Lisa-4
6024: PPUSH
6025: CALL_OW 88
// if Cyrus then
6029: LD_EXP 36
6033: IFFALSE 6073
// begin if not IsInUnit ( Cyrus ) then
6035: LD_EXP 36
6039: PPUSH
6040: CALL_OW 310
6044: NOT
6045: IFFALSE 6061
// ComTurnUnit ( Cyrus , Lisa ) ;
6047: LD_EXP 36
6051: PPUSH
6052: LD_EXP 37
6056: PPUSH
6057: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6061: LD_EXP 36
6065: PPUSH
6066: LD_STRING D1b-Cyrus-5
6068: PPUSH
6069: CALL_OW 88
// end ; end ; SelectGroup ;
6073: CALL 2562 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6077: LD_EXP 34
6081: PPUSH
6082: LD_STRING D1d-JMM-1
6084: PPUSH
6085: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6089: LD_EXP 41
6093: PPUSH
6094: LD_STRING D1d-Corn-1
6096: PPUSH
6097: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6101: LD_ADDR_VAR 0 2
6105: PUSH
6106: LD_EXP 4
6110: PUSH
6111: LD_EXP 6
6115: ADD
6116: PUSH
6117: LD_EXP 34
6121: ADD
6122: PUSH
6123: FOR_IN
6124: IFFALSE 6137
// ComHold ( i ) ;
6126: LD_VAR 0 2
6130: PPUSH
6131: CALL_OW 140
6135: GO 6123
6137: POP
6138: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6139: LD_ADDR_VAR 0 4
6143: PUSH
6144: LD_INT 22
6146: PUSH
6147: LD_INT 1
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: PUSH
6154: LD_INT 21
6156: PUSH
6157: LD_INT 2
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: PPUSH
6168: CALL_OW 69
6172: ST_TO_ADDR
// if vehicles then
6173: LD_VAR 0 4
6177: IFFALSE 6515
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6179: LD_EXP 6
6183: PPUSH
6184: LD_INT 55
6186: PUSH
6187: EMPTY
6188: LIST
6189: PPUSH
6190: CALL_OW 72
6194: IFFALSE 6233
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6196: LD_ADDR_VAR 0 2
6200: PUSH
6201: LD_EXP 6
6205: PPUSH
6206: LD_INT 55
6208: PUSH
6209: EMPTY
6210: LIST
6211: PPUSH
6212: CALL_OW 72
6216: PUSH
6217: FOR_IN
6218: IFFALSE 6231
// ComExitVehicle ( i ) ;
6220: LD_VAR 0 2
6224: PPUSH
6225: CALL_OW 121
6229: GO 6217
6231: POP
6232: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6233: LD_ADDR_VAR 0 5
6237: PUSH
6238: LD_VAR 0 4
6242: PPUSH
6243: LD_INT 34
6245: PUSH
6246: LD_INT 51
6248: PUSH
6249: EMPTY
6250: LIST
6251: LIST
6252: PPUSH
6253: CALL_OW 72
6257: ST_TO_ADDR
// if cargos then
6258: LD_VAR 0 5
6262: IFFALSE 6445
// begin vehicles := cargos ;
6264: LD_ADDR_VAR 0 4
6268: PUSH
6269: LD_VAR 0 5
6273: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6274: LD_ADDR_VAR 0 6
6278: PUSH
6279: LD_STRING 02_resources_4
6281: PPUSH
6282: LD_INT 0
6284: PPUSH
6285: CALL_OW 30
6289: ST_TO_ADDR
// if debug and not resources then
6290: LD_EXP 1
6294: PUSH
6295: LD_VAR 0 6
6299: NOT
6300: AND
6301: IFFALSE 6311
// resources := 160 ;
6303: LD_ADDR_VAR 0 6
6307: PUSH
6308: LD_INT 160
6310: ST_TO_ADDR
// if resources mod 10 then
6311: LD_VAR 0 6
6315: PUSH
6316: LD_INT 10
6318: MOD
6319: IFFALSE 6341
// resources := resources - resources mod 10 ;
6321: LD_ADDR_VAR 0 6
6325: PUSH
6326: LD_VAR 0 6
6330: PUSH
6331: LD_VAR 0 6
6335: PUSH
6336: LD_INT 10
6338: MOD
6339: MINUS
6340: ST_TO_ADDR
// if resources then
6341: LD_VAR 0 6
6345: IFFALSE 6445
// for i in cargos do
6347: LD_ADDR_VAR 0 2
6351: PUSH
6352: LD_VAR 0 5
6356: PUSH
6357: FOR_IN
6358: IFFALSE 6443
// begin if resources < 100 then
6360: LD_VAR 0 6
6364: PUSH
6365: LD_INT 100
6367: LESS
6368: IFFALSE 6390
// begin cargo := resources ;
6370: LD_ADDR_VAR 0 7
6374: PUSH
6375: LD_VAR 0 6
6379: ST_TO_ADDR
// resources := 0 ;
6380: LD_ADDR_VAR 0 6
6384: PUSH
6385: LD_INT 0
6387: ST_TO_ADDR
// end else
6388: GO 6412
// begin cargo := 100 ;
6390: LD_ADDR_VAR 0 7
6394: PUSH
6395: LD_INT 100
6397: ST_TO_ADDR
// resources := resources - 100 ;
6398: LD_ADDR_VAR 0 6
6402: PUSH
6403: LD_VAR 0 6
6407: PUSH
6408: LD_INT 100
6410: MINUS
6411: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6412: LD_VAR 0 2
6416: PPUSH
6417: LD_INT 1
6419: PPUSH
6420: LD_VAR 0 7
6424: PPUSH
6425: CALL_OW 290
// if resources = 0 then
6429: LD_VAR 0 6
6433: PUSH
6434: LD_INT 0
6436: EQUAL
6437: IFFALSE 6441
// break ;
6439: GO 6443
// end ;
6441: GO 6357
6443: POP
6444: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6445: LD_VAR 0 4
6449: PUSH
6450: LD_INT 1
6452: ARRAY
6453: PPUSH
6454: CALL_OW 311
6458: PPUSH
6459: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6463: LD_VAR 0 4
6467: PUSH
6468: LD_INT 1
6470: ARRAY
6471: PPUSH
6472: LD_INT 4
6474: PPUSH
6475: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6479: LD_EXP 41
6483: PPUSH
6484: LD_VAR 0 4
6488: PUSH
6489: LD_INT 1
6491: ARRAY
6492: PPUSH
6493: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6497: LD_INT 35
6499: PPUSH
6500: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6504: LD_EXP 41
6508: PPUSH
6509: CALL_OW 310
6513: IFFALSE 6497
// end ; InGameOff ;
6515: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6519: LD_STRING M1
6521: PPUSH
6522: CALL_OW 337
// SaveForQuickRestart ;
6526: CALL_OW 22
// cornel_active := true ;
6530: LD_ADDR_EXP 8
6534: PUSH
6535: LD_INT 1
6537: ST_TO_ADDR
// end ;
6538: LD_VAR 0 1
6542: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
6543: LD_EXP 34
6547: PPUSH
6548: LD_EXP 44
6552: PPUSH
6553: CALL_OW 296
6557: PUSH
6558: LD_INT 10
6560: LESS
6561: IFFALSE 7795
6563: GO 6565
6565: DISABLE
6566: LD_INT 0
6568: PPUSH
6569: PPUSH
6570: PPUSH
6571: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6572: LD_ADDR_VAR 0 2
6576: PUSH
6577: LD_INT 89
6579: PUSH
6580: LD_INT 34
6582: PUSH
6583: EMPTY
6584: LIST
6585: LIST
6586: PUSH
6587: LD_INT 138
6589: PUSH
6590: LD_INT 63
6592: PUSH
6593: EMPTY
6594: LIST
6595: LIST
6596: PUSH
6597: LD_INT 196
6599: PUSH
6600: LD_INT 84
6602: PUSH
6603: EMPTY
6604: LIST
6605: LIST
6606: PUSH
6607: LD_INT 135
6609: PUSH
6610: LD_INT 52
6612: PUSH
6613: EMPTY
6614: LIST
6615: LIST
6616: PUSH
6617: LD_INT 103
6619: PUSH
6620: LD_INT 39
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: PUSH
6627: LD_INT 58
6629: PUSH
6630: LD_INT 30
6632: PUSH
6633: EMPTY
6634: LIST
6635: LIST
6636: PUSH
6637: LD_INT 38
6639: PUSH
6640: LD_INT 51
6642: PUSH
6643: EMPTY
6644: LIST
6645: LIST
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: LIST
6651: LIST
6652: LIST
6653: LIST
6654: LIST
6655: ST_TO_ADDR
// InGameOn ;
6656: CALL_OW 8
// if jmm_units then
6660: LD_EXP 4
6664: IFFALSE 6740
// for i in jmm_units do
6666: LD_ADDR_VAR 0 1
6670: PUSH
6671: LD_EXP 4
6675: PUSH
6676: FOR_IN
6677: IFFALSE 6738
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6679: LD_VAR 0 1
6683: PPUSH
6684: LD_EXP 34
6688: PPUSH
6689: CALL_OW 296
6693: PUSH
6694: LD_INT 10
6696: LESS
6697: PUSH
6698: LD_VAR 0 1
6702: PPUSH
6703: CALL_OW 310
6707: NOT
6708: AND
6709: IFFALSE 6727
// ComTurnUnit ( i , JMM ) else
6711: LD_VAR 0 1
6715: PPUSH
6716: LD_EXP 34
6720: PPUSH
6721: CALL_OW 119
6725: GO 6736
// ComHold ( i ) ;
6727: LD_VAR 0 1
6731: PPUSH
6732: CALL_OW 140
// end ;
6736: GO 6676
6738: POP
6739: POP
// if IsInUnit ( JMM ) then
6740: LD_EXP 34
6744: PPUSH
6745: CALL_OW 310
6749: IFFALSE 6774
// begin ComExitVehicle ( JMM ) ;
6751: LD_EXP 34
6755: PPUSH
6756: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6760: LD_EXP 34
6764: PPUSH
6765: LD_EXP 44
6769: PPUSH
6770: CALL_OW 172
// end ; Wait ( 10 ) ;
6774: LD_INT 10
6776: PPUSH
6777: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6781: LD_EXP 34
6785: PPUSH
6786: LD_EXP 44
6790: PPUSH
6791: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6795: LD_INT 35
6797: PPUSH
6798: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6802: LD_EXP 34
6806: PPUSH
6807: LD_EXP 44
6811: PPUSH
6812: CALL_OW 296
6816: PUSH
6817: LD_INT 6
6819: LESS
6820: IFFALSE 6795
// ComTurnUnit ( JMM , Lynch ) ;
6822: LD_EXP 34
6826: PPUSH
6827: LD_EXP 44
6831: PPUSH
6832: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6836: LD_ADDR_VAR 0 1
6840: PUSH
6841: LD_EXP 44
6845: PUSH
6846: LD_EXP 45
6850: PUSH
6851: LD_EXP 46
6855: PUSH
6856: LD_EXP 47
6860: PUSH
6861: EMPTY
6862: LIST
6863: LIST
6864: LIST
6865: LIST
6866: PUSH
6867: FOR_IN
6868: IFFALSE 6886
// ComTurnUnit ( i , JMM ) ;
6870: LD_VAR 0 1
6874: PPUSH
6875: LD_EXP 34
6879: PPUSH
6880: CALL_OW 119
6884: GO 6867
6886: POP
6887: POP
// Wait ( 0 0$0.3 ) ;
6888: LD_INT 10
6890: PPUSH
6891: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6895: LD_EXP 34
6899: PPUSH
6900: LD_STRING D2-JMM-1
6902: PPUSH
6903: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6907: LD_EXP 44
6911: PPUSH
6912: LD_STRING D2-Sol1-1
6914: PPUSH
6915: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6919: LD_EXP 34
6923: PPUSH
6924: LD_STRING D2-JMM-2
6926: PPUSH
6927: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6931: LD_EXP 44
6935: PPUSH
6936: LD_STRING D2-Sol1-2
6938: PPUSH
6939: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6943: LD_EXP 34
6947: PPUSH
6948: LD_STRING D2-JMM-3
6950: PPUSH
6951: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
6955: LD_EXP 44
6959: PPUSH
6960: LD_STRING D2-Sol1-3
6962: PPUSH
6963: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6967: LD_ADDR_VAR 0 1
6971: PUSH
6972: LD_INT 22
6974: PUSH
6975: LD_INT 8
6977: PUSH
6978: EMPTY
6979: LIST
6980: LIST
6981: PPUSH
6982: CALL_OW 69
6986: PUSH
6987: FOR_IN
6988: IFFALSE 7004
// SetSide ( i , 1 ) ;
6990: LD_VAR 0 1
6994: PPUSH
6995: LD_INT 1
6997: PPUSH
6998: CALL_OW 235
7002: GO 6987
7004: POP
7005: POP
// Say ( JMM , D2-JMM-4 ) ;
7006: LD_EXP 34
7010: PPUSH
7011: LD_STRING D2-JMM-4
7013: PPUSH
7014: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7018: LD_INT 1
7020: PPUSH
7021: LD_INT 5
7023: PPUSH
7024: CALL_OW 332
// for i = 1 to points do
7028: LD_ADDR_VAR 0 1
7032: PUSH
7033: DOUBLE
7034: LD_INT 1
7036: DEC
7037: ST_TO_ADDR
7038: LD_VAR 0 2
7042: PUSH
7043: FOR_TO
7044: IFFALSE 7219
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7046: LD_VAR 0 2
7050: PUSH
7051: LD_VAR 0 1
7055: ARRAY
7056: PUSH
7057: LD_INT 1
7059: ARRAY
7060: PPUSH
7061: LD_VAR 0 2
7065: PUSH
7066: LD_VAR 0 1
7070: ARRAY
7071: PUSH
7072: LD_INT 2
7074: ARRAY
7075: PPUSH
7076: CALL_OW 84
// if i = 1 then
7080: LD_VAR 0 1
7084: PUSH
7085: LD_INT 1
7087: EQUAL
7088: IFFALSE 7102
// Say ( Lynch , D2-Sol1-4 ) ;
7090: LD_EXP 44
7094: PPUSH
7095: LD_STRING D2-Sol1-4
7097: PPUSH
7098: CALL_OW 88
// if i = 2 then
7102: LD_VAR 0 1
7106: PUSH
7107: LD_INT 2
7109: EQUAL
7110: IFFALSE 7124
// Say ( JMM , D2-JMM-5 ) ;
7112: LD_EXP 34
7116: PPUSH
7117: LD_STRING D2-JMM-5
7119: PPUSH
7120: CALL_OW 88
// if i = 4 then
7124: LD_VAR 0 1
7128: PUSH
7129: LD_INT 4
7131: EQUAL
7132: IFFALSE 7156
// begin RevealFogArea ( 1 , troopsArea ) ;
7134: LD_INT 1
7136: PPUSH
7137: LD_INT 6
7139: PPUSH
7140: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7144: LD_EXP 44
7148: PPUSH
7149: LD_STRING D2-Sol1-5
7151: PPUSH
7152: CALL_OW 88
// end ; if i = 5 then
7156: LD_VAR 0 1
7160: PUSH
7161: LD_INT 5
7163: EQUAL
7164: IFFALSE 7178
// Say ( JMM , D2-JMM-6 ) ;
7166: LD_EXP 34
7170: PPUSH
7171: LD_STRING D2-JMM-6
7173: PPUSH
7174: CALL_OW 88
// if i = 7 then
7178: LD_VAR 0 1
7182: PUSH
7183: LD_INT 7
7185: EQUAL
7186: IFFALSE 7210
// begin RevealFogArea ( 1 , forestArea ) ;
7188: LD_INT 1
7190: PPUSH
7191: LD_INT 7
7193: PPUSH
7194: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7198: LD_EXP 44
7202: PPUSH
7203: LD_STRING D2-Sol1-6
7205: PPUSH
7206: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7210: LD_INT 46
7212: PPUSH
7213: CALL_OW 67
// end ;
7217: GO 7043
7219: POP
7220: POP
// CenterNowOnUnits ( JMM ) ;
7221: LD_EXP 34
7225: PPUSH
7226: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7230: LD_EXP 34
7234: PPUSH
7235: LD_STRING D2-JMM-7
7237: PPUSH
7238: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7242: LD_EXP 44
7246: PPUSH
7247: LD_STRING D2-Sol1-7
7249: PPUSH
7250: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7254: LD_EXP 34
7258: PPUSH
7259: LD_STRING D2-JMM-8
7261: PPUSH
7262: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7266: LD_ADDR_VAR 0 4
7270: PUSH
7271: LD_INT 22
7273: PUSH
7274: LD_INT 1
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: PUSH
7281: LD_INT 30
7283: PUSH
7284: LD_INT 31
7286: PUSH
7287: EMPTY
7288: LIST
7289: LIST
7290: PUSH
7291: EMPTY
7292: LIST
7293: LIST
7294: PPUSH
7295: CALL_OW 69
7299: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7300: LD_EXP 44
7304: PPUSH
7305: LD_VAR 0 4
7309: PUSH
7310: LD_INT 1
7312: ARRAY
7313: PPUSH
7314: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7318: LD_INT 65
7320: PPUSH
7321: LD_INT 101
7323: PPUSH
7324: CALL_OW 428
7328: IFFALSE 7351
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7330: LD_INT 65
7332: PPUSH
7333: LD_INT 101
7335: PPUSH
7336: CALL_OW 428
7340: PPUSH
7341: LD_INT 75
7343: PPUSH
7344: LD_INT 100
7346: PPUSH
7347: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7351: LD_INT 66
7353: PPUSH
7354: LD_INT 103
7356: PPUSH
7357: CALL_OW 428
7361: IFFALSE 7384
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7363: LD_INT 66
7365: PPUSH
7366: LD_INT 103
7368: PPUSH
7369: CALL_OW 428
7373: PPUSH
7374: LD_INT 75
7376: PPUSH
7377: LD_INT 100
7379: PPUSH
7380: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7384: LD_ADDR_VAR 0 3
7388: PUSH
7389: LD_EXP 4
7393: PPUSH
7394: LD_INT 25
7396: PUSH
7397: LD_INT 1
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: PPUSH
7404: CALL_OW 72
7408: PPUSH
7409: LD_EXP 34
7413: PPUSH
7414: CALL_OW 74
7418: ST_TO_ADDR
// if sol then
7419: LD_VAR 0 3
7423: IFFALSE 7463
// if GetDistUnits ( JMM , sol ) < 10 then
7425: LD_EXP 34
7429: PPUSH
7430: LD_VAR 0 3
7434: PPUSH
7435: CALL_OW 296
7439: PUSH
7440: LD_INT 10
7442: LESS
7443: IFFALSE 7463
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7445: LD_VAR 0 3
7449: PPUSH
7450: LD_VAR 0 4
7454: PUSH
7455: LD_INT 2
7457: ARRAY
7458: PPUSH
7459: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7463: LD_INT 10
7465: PPUSH
7466: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7470: LD_EXP 34
7474: PPUSH
7475: LD_INT 65
7477: PPUSH
7478: LD_INT 101
7480: PPUSH
7481: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7485: LD_EXP 34
7489: PPUSH
7490: LD_INT 63
7492: PPUSH
7493: LD_INT 100
7495: PPUSH
7496: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
7500: LD_INT 35
7502: PPUSH
7503: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
7507: LD_EXP 34
7511: PPUSH
7512: LD_INT 65
7514: PPUSH
7515: LD_INT 101
7517: PPUSH
7518: CALL_OW 307
7522: IFFALSE 7500
// Say ( JMM , D2a-JMM-1 ) ;
7524: LD_EXP 34
7528: PPUSH
7529: LD_STRING D2a-JMM-1
7531: PPUSH
7532: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7536: LD_EXP 45
7540: PPUSH
7541: LD_INT 66
7543: PPUSH
7544: LD_INT 103
7546: PPUSH
7547: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
7551: LD_INT 35
7553: PPUSH
7554: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
7558: LD_EXP 45
7562: PPUSH
7563: LD_INT 66
7565: PPUSH
7566: LD_INT 103
7568: PPUSH
7569: CALL_OW 307
7573: IFFALSE 7551
// ComTurnUnit ( Walker , JMM ) ;
7575: LD_EXP 45
7579: PPUSH
7580: LD_EXP 34
7584: PPUSH
7585: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7589: LD_EXP 45
7593: PPUSH
7594: LD_STRING D2a-Sci1-1
7596: PPUSH
7597: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7601: LD_EXP 34
7605: PPUSH
7606: LD_EXP 45
7610: PPUSH
7611: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7615: LD_EXP 34
7619: PPUSH
7620: LD_STRING D2a-JMM-2
7622: PPUSH
7623: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7627: LD_EXP 45
7631: PPUSH
7632: LD_STRING D2a-Sci1-2
7634: PPUSH
7635: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7639: LD_EXP 34
7643: PPUSH
7644: LD_STRING D2a-JMM-3
7646: PPUSH
7647: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7651: LD_EXP 45
7655: PPUSH
7656: LD_STRING D2a-Sci1-3
7658: PPUSH
7659: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7663: LD_ADDR_EXP 4
7667: PUSH
7668: LD_EXP 4
7672: PUSH
7673: LD_EXP 44
7677: PUSH
7678: LD_EXP 45
7682: PUSH
7683: LD_EXP 46
7687: PUSH
7688: LD_EXP 47
7692: PUSH
7693: EMPTY
7694: LIST
7695: LIST
7696: LIST
7697: LIST
7698: ADD
7699: ST_TO_ADDR
// for i in jmm_units do
7700: LD_ADDR_VAR 0 1
7704: PUSH
7705: LD_EXP 4
7709: PUSH
7710: FOR_IN
7711: IFFALSE 7736
// if not IsInUnit ( i ) then
7713: LD_VAR 0 1
7717: PPUSH
7718: CALL_OW 310
7722: NOT
7723: IFFALSE 7734
// ComFree ( i ) ;
7725: LD_VAR 0 1
7729: PPUSH
7730: CALL_OW 139
7734: GO 7710
7736: POP
7737: POP
// InGameOff ;
7738: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
7742: LD_STRING MSolar1
7744: PPUSH
7745: CALL_OW 337
// jmm_on_west := true ;
7749: LD_ADDR_EXP 5
7753: PUSH
7754: LD_INT 1
7756: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7757: LD_INT 1050
7759: PPUSH
7760: CALL_OW 67
// frank_can_return := true ;
7764: LD_ADDR_EXP 12
7768: PUSH
7769: LD_INT 1
7771: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7772: LD_INT 6300
7774: PPUSH
7775: LD_INT 8400
7777: PPUSH
7778: CALL_OW 12
7782: PPUSH
7783: CALL_OW 67
// send_spec_patrol := true ;
7787: LD_ADDR_EXP 28
7791: PUSH
7792: LD_INT 1
7794: ST_TO_ADDR
// end ;
7795: PPOPN 4
7797: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7798: LD_INT 22
7800: PUSH
7801: LD_INT 1
7803: PUSH
7804: EMPTY
7805: LIST
7806: LIST
7807: PUSH
7808: LD_INT 34
7810: PUSH
7811: LD_INT 51
7813: PUSH
7814: EMPTY
7815: LIST
7816: LIST
7817: PUSH
7818: LD_INT 92
7820: PUSH
7821: LD_INT 63
7823: PUSH
7824: LD_INT 100
7826: PUSH
7827: LD_INT 5
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: LIST
7834: LIST
7835: PUSH
7836: EMPTY
7837: LIST
7838: LIST
7839: LIST
7840: PUSH
7841: EMPTY
7842: LIST
7843: PPUSH
7844: CALL_OW 69
7848: PUSH
7849: LD_EXP 5
7853: NOT
7854: AND
7855: IFFALSE 7968
7857: GO 7859
7859: DISABLE
7860: LD_INT 0
7862: PPUSH
7863: PPUSH
// begin enable ;
7864: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
7865: LD_ADDR_VAR 0 2
7869: PUSH
7870: LD_INT 22
7872: PUSH
7873: LD_INT 1
7875: PUSH
7876: EMPTY
7877: LIST
7878: LIST
7879: PUSH
7880: LD_INT 34
7882: PUSH
7883: LD_INT 51
7885: PUSH
7886: EMPTY
7887: LIST
7888: LIST
7889: PUSH
7890: LD_INT 92
7892: PUSH
7893: LD_INT 63
7895: PUSH
7896: LD_INT 100
7898: PUSH
7899: LD_INT 5
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: LIST
7906: LIST
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: LIST
7912: PUSH
7913: EMPTY
7914: LIST
7915: PPUSH
7916: CALL_OW 69
7920: ST_TO_ADDR
// if not filter then
7921: LD_VAR 0 2
7925: NOT
7926: IFFALSE 7930
// exit ;
7928: GO 7968
// for i in filter do
7930: LD_ADDR_VAR 0 1
7934: PUSH
7935: LD_VAR 0 2
7939: PUSH
7940: FOR_IN
7941: IFFALSE 7966
// begin SetFuel ( i , 0 ) ;
7943: LD_VAR 0 1
7947: PPUSH
7948: LD_INT 0
7950: PPUSH
7951: CALL_OW 240
// ComStop ( i ) ;
7955: LD_VAR 0 1
7959: PPUSH
7960: CALL_OW 141
// end ;
7964: GO 7940
7966: POP
7967: POP
// end ;
7968: PPOPN 2
7970: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
7971: LD_EXP 28
7975: IFFALSE 8968
7977: GO 7979
7979: DISABLE
7980: LD_INT 0
7982: PPUSH
7983: PPUSH
7984: PPUSH
7985: PPUSH
7986: PPUSH
7987: PPUSH
7988: PPUSH
// begin if not ru_spec_patrol then
7989: LD_EXP 51
7993: NOT
7994: IFFALSE 7998
// exit ;
7996: GO 8968
// dead1 := false ;
7998: LD_ADDR_VAR 0 1
8002: PUSH
8003: LD_INT 0
8005: ST_TO_ADDR
// dead2 := false ;
8006: LD_ADDR_VAR 0 2
8010: PUSH
8011: LD_INT 0
8013: ST_TO_ADDR
// inarea1 := false ;
8014: LD_ADDR_VAR 0 3
8018: PUSH
8019: LD_INT 0
8021: ST_TO_ADDR
// inarea2 := false ;
8022: LD_ADDR_VAR 0 4
8026: PUSH
8027: LD_INT 0
8029: ST_TO_ADDR
// tmp := [ ] ;
8030: LD_ADDR_VAR 0 6
8034: PUSH
8035: EMPTY
8036: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8037: LD_EXP 51
8041: PPUSH
8042: LD_INT 75
8044: PPUSH
8045: LD_INT 101
8047: PPUSH
8048: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8052: LD_INT 35
8054: PPUSH
8055: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8059: LD_INT 1
8061: PPUSH
8062: LD_EXP 51
8066: PUSH
8067: LD_INT 1
8069: ARRAY
8070: PPUSH
8071: CALL_OW 292
8075: IFFALSE 8052
// ComStop ( ru_spec_patrol ) ;
8077: LD_EXP 51
8081: PPUSH
8082: CALL_OW 141
// Wait ( 0 0$02 ) ;
8086: LD_INT 70
8088: PPUSH
8089: CALL_OW 67
// DialogueOn ;
8093: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8097: LD_EXP 51
8101: PUSH
8102: LD_INT 1
8104: ARRAY
8105: PPUSH
8106: LD_STRING D8-Rus1-1
8108: PPUSH
8109: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8113: LD_EXP 34
8117: PPUSH
8118: LD_STRING D8-JMM-1
8120: PPUSH
8121: CALL_OW 88
// DialogueOff ;
8125: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8129: LD_EXP 51
8133: PPUSH
8134: LD_INT 13
8136: PPUSH
8137: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8141: LD_INT 35
8143: PPUSH
8144: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8148: LD_VAR 0 1
8152: NOT
8153: PUSH
8154: LD_EXP 51
8158: PUSH
8159: LD_INT 1
8161: ARRAY
8162: PPUSH
8163: CALL_OW 301
8167: AND
8168: IFFALSE 8178
// dead1 := true ;
8170: LD_ADDR_VAR 0 1
8174: PUSH
8175: LD_INT 1
8177: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8178: LD_VAR 0 2
8182: NOT
8183: PUSH
8184: LD_EXP 51
8188: PUSH
8189: LD_INT 2
8191: ARRAY
8192: PPUSH
8193: CALL_OW 301
8197: AND
8198: IFFALSE 8208
// dead2 := true ;
8200: LD_ADDR_VAR 0 2
8204: PUSH
8205: LD_INT 1
8207: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8208: LD_VAR 0 3
8212: NOT
8213: PUSH
8214: LD_EXP 51
8218: PUSH
8219: LD_INT 1
8221: ARRAY
8222: PPUSH
8223: LD_INT 14
8225: PPUSH
8226: CALL_OW 308
8230: AND
8231: IFFALSE 8241
// inarea1 := true ;
8233: LD_ADDR_VAR 0 3
8237: PUSH
8238: LD_INT 1
8240: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8241: LD_VAR 0 4
8245: NOT
8246: PUSH
8247: LD_EXP 51
8251: PUSH
8252: LD_INT 2
8254: ARRAY
8255: PPUSH
8256: LD_INT 14
8258: PPUSH
8259: CALL_OW 308
8263: AND
8264: IFFALSE 8274
// inarea2 := true ;
8266: LD_ADDR_VAR 0 4
8270: PUSH
8271: LD_INT 1
8273: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8274: LD_VAR 0 1
8278: PUSH
8279: LD_VAR 0 2
8283: AND
8284: PUSH
8285: LD_VAR 0 1
8289: PUSH
8290: LD_VAR 0 4
8294: AND
8295: OR
8296: PUSH
8297: LD_VAR 0 2
8301: PUSH
8302: LD_VAR 0 3
8306: AND
8307: OR
8308: PUSH
8309: LD_VAR 0 3
8313: PUSH
8314: LD_VAR 0 4
8318: AND
8319: OR
8320: IFFALSE 8141
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8322: LD_VAR 0 3
8326: PUSH
8327: LD_VAR 0 4
8331: AND
8332: PUSH
8333: LD_VAR 0 1
8337: PUSH
8338: LD_VAR 0 4
8342: AND
8343: OR
8344: PUSH
8345: LD_VAR 0 2
8349: PUSH
8350: LD_VAR 0 3
8354: AND
8355: OR
8356: IFFALSE 8948
// begin prepare_siege := true ;
8358: LD_ADDR_EXP 29
8362: PUSH
8363: LD_INT 1
8365: ST_TO_ADDR
// DialogueOn ;
8366: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8370: LD_VAR 0 3
8374: PUSH
8375: LD_VAR 0 4
8379: AND
8380: IFFALSE 8396
// Say ( JMM , D8b-JMM-1a ) else
8382: LD_EXP 34
8386: PPUSH
8387: LD_STRING D8b-JMM-1a
8389: PPUSH
8390: CALL_OW 88
8394: GO 8408
// Say ( JMM , D8b-JMM-1 ) ;
8396: LD_EXP 34
8400: PPUSH
8401: LD_STRING D8b-JMM-1
8403: PPUSH
8404: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8408: LD_EXP 4
8412: PPUSH
8413: LD_INT 26
8415: PUSH
8416: LD_INT 1
8418: PUSH
8419: EMPTY
8420: LIST
8421: LIST
8422: PPUSH
8423: CALL_OW 72
8427: PUSH
8428: LD_EXP 35
8432: PUSH
8433: LD_EXP 36
8437: PUSH
8438: LD_EXP 45
8442: PUSH
8443: LD_EXP 48
8447: PUSH
8448: EMPTY
8449: LIST
8450: LIST
8451: LIST
8452: LIST
8453: DIFF
8454: PPUSH
8455: LD_STRING D8b-Sol1-1
8457: PPUSH
8458: CALL 609 0 2
// if Cyrus and Cyrus in jmm_units then
8462: LD_EXP 36
8466: PUSH
8467: LD_EXP 36
8471: PUSH
8472: LD_EXP 4
8476: IN
8477: AND
8478: IFFALSE 8494
// Say ( Cyrus , D8b-Cyrus-1 ) else
8480: LD_EXP 36
8484: PPUSH
8485: LD_STRING D8b-Cyrus-1
8487: PPUSH
8488: CALL_OW 88
8492: GO 8506
// Say ( JMM , D8b-JMM-1a ) ;
8494: LD_EXP 34
8498: PPUSH
8499: LD_STRING D8b-JMM-1a
8501: PPUSH
8502: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8506: LD_EXP 37
8510: PUSH
8511: LD_EXP 37
8515: PUSH
8516: LD_EXP 4
8520: IN
8521: AND
8522: IFFALSE 8536
// Say ( Lisa , D8b-Lisa-2 ) ;
8524: LD_EXP 37
8528: PPUSH
8529: LD_STRING D8b-Lisa-2
8531: PPUSH
8532: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8536: LD_EXP 35
8540: PUSH
8541: LD_EXP 35
8545: PUSH
8546: LD_EXP 4
8550: IN
8551: AND
8552: IFFALSE 8568
// Say ( Bobby , D8b-Bobby-1 ) else
8554: LD_EXP 35
8558: PPUSH
8559: LD_STRING D8b-Bobby-1
8561: PPUSH
8562: CALL_OW 88
8566: GO 8628
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8568: LD_ADDR_VAR 0 5
8572: PUSH
8573: LD_EXP 4
8577: PPUSH
8578: LD_INT 26
8580: PUSH
8581: LD_INT 1
8583: PUSH
8584: EMPTY
8585: LIST
8586: LIST
8587: PPUSH
8588: CALL_OW 72
8592: PUSH
8593: LD_EXP 35
8597: PUSH
8598: LD_EXP 36
8602: PUSH
8603: LD_EXP 45
8607: PUSH
8608: LD_EXP 48
8612: PUSH
8613: EMPTY
8614: LIST
8615: LIST
8616: LIST
8617: LIST
8618: DIFF
8619: PPUSH
8620: LD_STRING D8b-Sol2-1
8622: PPUSH
8623: CALL 609 0 2
8627: ST_TO_ADDR
// DialogueOff ;
8628: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8632: LD_EXP 36
8636: PUSH
8637: LD_EXP 36
8641: PUSH
8642: LD_EXP 4
8646: IN
8647: AND
8648: IFFALSE 8673
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8650: LD_ADDR_VAR 0 6
8654: PUSH
8655: LD_VAR 0 6
8659: PPUSH
8660: LD_INT 1
8662: PPUSH
8663: LD_EXP 36
8667: PPUSH
8668: CALL_OW 2
8672: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8673: LD_EXP 35
8677: PUSH
8678: LD_EXP 35
8682: PUSH
8683: LD_EXP 4
8687: IN
8688: AND
8689: IFFALSE 8714
// tmp := Insert ( tmp , 1 , Bobby ) ;
8691: LD_ADDR_VAR 0 6
8695: PUSH
8696: LD_VAR 0 6
8700: PPUSH
8701: LD_INT 1
8703: PPUSH
8704: LD_EXP 35
8708: PPUSH
8709: CALL_OW 2
8713: ST_TO_ADDR
// if sol then
8714: LD_VAR 0 5
8718: IFFALSE 8743
// tmp := Insert ( tmp , 1 , sol ) ;
8720: LD_ADDR_VAR 0 6
8724: PUSH
8725: LD_VAR 0 6
8729: PPUSH
8730: LD_INT 1
8732: PPUSH
8733: LD_VAR 0 5
8737: PPUSH
8738: CALL_OW 2
8742: ST_TO_ADDR
// if tmp then
8743: LD_VAR 0 6
8747: IFFALSE 8907
// begin SetSide ( tmp , 8 ) ;
8749: LD_VAR 0 6
8753: PPUSH
8754: LD_INT 8
8756: PPUSH
8757: CALL_OW 235
// ComFree ( tmp ) ;
8761: LD_VAR 0 6
8765: PPUSH
8766: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8770: LD_VAR 0 6
8774: PPUSH
8775: LD_INT 15
8777: PPUSH
8778: CALL_OW 173
// AddComHold ( tmp ) ;
8782: LD_VAR 0 6
8786: PPUSH
8787: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8791: LD_INT 35
8793: PPUSH
8794: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
8798: LD_VAR 0 6
8802: PUSH
8803: LD_INT 1
8805: ARRAY
8806: PPUSH
8807: CALL_OW 314
8811: NOT
8812: IFFALSE 8826
// ComMoveToArea ( tmp , cyrusEscape ) ;
8814: LD_VAR 0 6
8818: PPUSH
8819: LD_INT 15
8821: PPUSH
8822: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8826: LD_VAR 0 6
8830: PUSH
8831: LD_INT 1
8833: ARRAY
8834: PPUSH
8835: LD_INT 15
8837: PPUSH
8838: CALL_OW 308
8842: IFFALSE 8897
// begin RemoveUnit ( tmp [ 1 ] ) ;
8844: LD_VAR 0 6
8848: PUSH
8849: LD_INT 1
8851: ARRAY
8852: PPUSH
8853: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
8857: LD_ADDR_EXP 4
8861: PUSH
8862: LD_EXP 4
8866: PUSH
8867: LD_VAR 0 6
8871: PUSH
8872: LD_INT 1
8874: ARRAY
8875: DIFF
8876: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
8877: LD_ADDR_VAR 0 6
8881: PUSH
8882: LD_VAR 0 6
8886: PUSH
8887: LD_VAR 0 6
8891: PUSH
8892: LD_INT 1
8894: ARRAY
8895: DIFF
8896: ST_TO_ADDR
// end ; until tmp = 0 ;
8897: LD_VAR 0 6
8901: PUSH
8902: LD_INT 0
8904: EQUAL
8905: IFFALSE 8791
// end ; Wait ( 0 0$30 ) ;
8907: LD_INT 1050
8909: PPUSH
8910: CALL_OW 67
// if ru_spec_patrol then
8914: LD_EXP 51
8918: IFFALSE 8946
// for i in ru_spec_patrol do
8920: LD_ADDR_VAR 0 7
8924: PUSH
8925: LD_EXP 51
8929: PUSH
8930: FOR_IN
8931: IFFALSE 8944
// RemoveUnit ( i ) ;
8933: LD_VAR 0 7
8937: PPUSH
8938: CALL_OW 64
8942: GO 8930
8944: POP
8945: POP
// end else
8946: GO 8968
// begin prepare_siege := false ;
8948: LD_ADDR_EXP 29
8952: PUSH
8953: LD_INT 0
8955: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
8956: LD_EXP 34
8960: PPUSH
8961: LD_STRING D8a-JMM-1
8963: PPUSH
8964: CALL_OW 88
// end ; end ;
8968: PPOPN 7
8970: END
// every 0 0$10 trigger frank_can_return do var i , points ;
8971: LD_EXP 12
8975: IFFALSE 10109
8977: GO 8979
8979: DISABLE
8980: LD_INT 0
8982: PPUSH
8983: PPUSH
// begin uc_side := 8 ;
8984: LD_ADDR_OWVAR 20
8988: PUSH
8989: LD_INT 8
8991: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
8992: LD_ADDR_VAR 0 2
8996: PUSH
8997: LD_INT 59
8999: PUSH
9000: LD_INT 71
9002: PUSH
9003: EMPTY
9004: LIST
9005: LIST
9006: PUSH
9007: LD_INT 122
9009: PUSH
9010: LD_INT 117
9012: PUSH
9013: EMPTY
9014: LIST
9015: LIST
9016: PUSH
9017: EMPTY
9018: LIST
9019: LIST
9020: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9021: LD_ADDR_EXP 48
9025: PUSH
9026: LD_STRING Frank
9028: PPUSH
9029: LD_INT 0
9031: PPUSH
9032: CALL 458 0 2
9036: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9037: LD_ADDR_VAR 0 1
9041: PUSH
9042: LD_INT 1
9044: PPUSH
9045: LD_INT 2
9047: PPUSH
9048: CALL_OW 12
9052: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9053: LD_EXP 48
9057: PPUSH
9058: LD_VAR 0 2
9062: PUSH
9063: LD_VAR 0 1
9067: ARRAY
9068: PUSH
9069: LD_INT 1
9071: ARRAY
9072: PPUSH
9073: LD_VAR 0 2
9077: PUSH
9078: LD_VAR 0 1
9082: ARRAY
9083: PUSH
9084: LD_INT 2
9086: ARRAY
9087: PPUSH
9088: LD_INT 0
9090: PPUSH
9091: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9095: LD_EXP 48
9099: PPUSH
9100: LD_INT 1
9102: PPUSH
9103: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9107: LD_INT 35
9109: PPUSH
9110: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
9114: LD_EXP 48
9118: PPUSH
9119: LD_EXP 34
9123: PPUSH
9124: CALL_OW 296
9128: PUSH
9129: LD_INT 8
9131: LESS
9132: IFFALSE 9107
// InGameOn ;
9134: CALL_OW 8
// CenterOnUnits ( JMM ) ;
9138: LD_EXP 34
9142: PPUSH
9143: CALL_OW 85
// if IsInUnit ( JMM ) then
9147: LD_EXP 34
9151: PPUSH
9152: CALL_OW 310
9156: IFFALSE 9167
// ComFree ( JMM ) ;
9158: LD_EXP 34
9162: PPUSH
9163: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9167: LD_EXP 34
9171: PPUSH
9172: LD_EXP 48
9176: PPUSH
9177: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9181: LD_EXP 48
9185: PPUSH
9186: LD_EXP 34
9190: PPUSH
9191: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9195: LD_EXP 34
9199: PPUSH
9200: LD_STRING D6-JMM-1
9202: PPUSH
9203: CALL_OW 88
// repeat wait ( 3 ) ;
9207: LD_INT 3
9209: PPUSH
9210: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
9214: LD_EXP 34
9218: PPUSH
9219: LD_EXP 48
9223: PPUSH
9224: CALL_OW 296
9228: PUSH
9229: LD_INT 8
9231: LESS
9232: IFFALSE 9207
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9234: LD_EXP 37
9238: PUSH
9239: LD_EXP 37
9243: PPUSH
9244: LD_EXP 48
9248: PPUSH
9249: CALL_OW 296
9253: PUSH
9254: LD_INT 20
9256: LESS
9257: AND
9258: IFFALSE 9283
// begin ComFree ( Lisa ) ;
9260: LD_EXP 37
9264: PPUSH
9265: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9269: LD_EXP 37
9273: PPUSH
9274: LD_EXP 48
9278: PPUSH
9279: CALL_OW 172
// end ; if Lynch then
9283: LD_EXP 44
9287: IFFALSE 9312
// begin ComFree ( Lynch ) ;
9289: LD_EXP 44
9293: PPUSH
9294: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9298: LD_EXP 44
9302: PPUSH
9303: LD_EXP 48
9307: PPUSH
9308: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9312: LD_EXP 34
9316: PPUSH
9317: LD_EXP 48
9321: PPUSH
9322: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9326: LD_EXP 48
9330: PPUSH
9331: LD_EXP 34
9335: PPUSH
9336: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9340: LD_EXP 48
9344: PPUSH
9345: LD_STRING D6-Frank-1
9347: PPUSH
9348: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9352: LD_INT 69
9354: PPUSH
9355: LD_INT 20
9357: PPUSH
9358: LD_INT 1
9360: PPUSH
9361: LD_INT 20
9363: NEG
9364: PPUSH
9365: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9369: LD_INT 69
9371: PPUSH
9372: LD_INT 20
9374: PPUSH
9375: LD_INT 1
9377: PPUSH
9378: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9382: LD_INT 190
9384: PPUSH
9385: LD_INT 31
9387: PPUSH
9388: LD_INT 1
9390: PPUSH
9391: LD_INT 20
9393: NEG
9394: PPUSH
9395: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9399: LD_INT 190
9401: PPUSH
9402: LD_INT 31
9404: PPUSH
9405: LD_INT 1
9407: PPUSH
9408: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9412: LD_INT 69
9414: PPUSH
9415: LD_INT 20
9417: PPUSH
9418: CALL_OW 84
// Wait ( 0 0$02 ) ;
9422: LD_INT 70
9424: PPUSH
9425: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9429: LD_EXP 34
9433: PPUSH
9434: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9438: LD_EXP 37
9442: PUSH
9443: LD_EXP 37
9447: PPUSH
9448: LD_EXP 48
9452: PPUSH
9453: CALL_OW 296
9457: PUSH
9458: LD_INT 20
9460: LESS
9461: AND
9462: PUSH
9463: LD_EXP 37
9467: PPUSH
9468: CALL_OW 302
9472: AND
9473: IFFALSE 9563
// begin ComFree ( Lisa ) ;
9475: LD_EXP 37
9479: PPUSH
9480: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
9484: LD_INT 35
9486: PPUSH
9487: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
9491: LD_EXP 37
9495: PPUSH
9496: LD_EXP 48
9500: PPUSH
9501: CALL_OW 296
9505: PUSH
9506: LD_INT 7
9508: LESS
9509: IFFALSE 9484
// Say ( Lisa , D6-Lisa-1 ) ;
9511: LD_EXP 37
9515: PPUSH
9516: LD_STRING D6-Lisa-1
9518: PPUSH
9519: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9523: LD_EXP 37
9527: PPUSH
9528: LD_EXP 48
9532: PPUSH
9533: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9537: LD_EXP 48
9541: PPUSH
9542: LD_EXP 37
9546: PPUSH
9547: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9551: LD_EXP 48
9555: PPUSH
9556: LD_STRING D6-Frank-2
9558: PPUSH
9559: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9563: LD_EXP 44
9567: PUSH
9568: LD_EXP 44
9572: PPUSH
9573: LD_EXP 48
9577: PPUSH
9578: CALL_OW 296
9582: PUSH
9583: LD_INT 20
9585: LESS
9586: AND
9587: PUSH
9588: LD_EXP 44
9592: PPUSH
9593: CALL_OW 302
9597: AND
9598: IFFALSE 9779
// begin ComTurnUnit ( Lynch , JMM ) ;
9600: LD_EXP 44
9604: PPUSH
9605: LD_EXP 34
9609: PPUSH
9610: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9614: LD_EXP 48
9618: PPUSH
9619: LD_EXP 34
9623: PPUSH
9624: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9628: LD_EXP 44
9632: PPUSH
9633: LD_STRING D6-Sol1-2
9635: PPUSH
9636: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9640: LD_EXP 34
9644: PPUSH
9645: LD_STRING D6-JMM-2
9647: PPUSH
9648: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9652: LD_EXP 48
9656: PPUSH
9657: LD_STRING D6-Frank-3
9659: PPUSH
9660: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9664: LD_EXP 34
9668: PPUSH
9669: LD_STRING D6-JMM-3
9671: PPUSH
9672: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9676: LD_EXP 48
9680: PPUSH
9681: LD_STRING D6-Frank-4
9683: PPUSH
9684: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9688: LD_EXP 48
9692: PPUSH
9693: LD_STRING D6-Frank-4a
9695: PPUSH
9696: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9700: LD_EXP 34
9704: PPUSH
9705: LD_STRING D6-JMM-4
9707: PPUSH
9708: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9712: LD_EXP 48
9716: PPUSH
9717: LD_STRING D6-Frank-5
9719: PPUSH
9720: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9724: LD_EXP 37
9728: PUSH
9729: LD_EXP 37
9733: PPUSH
9734: CALL_OW 302
9738: AND
9739: IFFALSE 9753
// Say ( Lisa , D6-Lisa-5 ) ;
9741: LD_EXP 37
9745: PPUSH
9746: LD_STRING D6-Lisa-5
9748: PPUSH
9749: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9753: LD_EXP 48
9757: PPUSH
9758: LD_STRING D6-Frank-6
9760: PPUSH
9761: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9765: LD_EXP 34
9769: PPUSH
9770: LD_STRING D6-JMM-6
9772: PPUSH
9773: CALL_OW 88
// end else
9777: GO 9894
// begin ComTurnUnit ( Frank , JMM ) ;
9779: LD_EXP 48
9783: PPUSH
9784: LD_EXP 34
9788: PPUSH
9789: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
9793: LD_EXP 48
9797: PPUSH
9798: LD_STRING D6-Frank-4
9800: PPUSH
9801: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9805: LD_EXP 48
9809: PPUSH
9810: LD_STRING D6-Frank-4a
9812: PPUSH
9813: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9817: LD_EXP 34
9821: PPUSH
9822: LD_STRING D6-JMM-4
9824: PPUSH
9825: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9829: LD_EXP 48
9833: PPUSH
9834: LD_STRING D6-Frank-5
9836: PPUSH
9837: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9841: LD_EXP 37
9845: PUSH
9846: LD_EXP 37
9850: PPUSH
9851: CALL_OW 302
9855: AND
9856: IFFALSE 9870
// Say ( Lisa , D6-Lisa-5 ) ;
9858: LD_EXP 37
9862: PPUSH
9863: LD_STRING D6-Lisa-5
9865: PPUSH
9866: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9870: LD_EXP 48
9874: PPUSH
9875: LD_STRING D6-Frank-6
9877: PPUSH
9878: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9882: LD_EXP 34
9886: PPUSH
9887: LD_STRING D6-JMM-6
9889: PPUSH
9890: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
9894: LD_STRING Q1
9896: PPUSH
9897: CALL_OW 97
9901: PUSH
9902: LD_INT 1
9904: DOUBLE
9905: EQUAL
9906: IFTRUE 9910
9908: GO 9921
9910: POP
// frank_send_to_scout := true ; 2 :
9911: LD_ADDR_EXP 14
9915: PUSH
9916: LD_INT 1
9918: ST_TO_ADDR
9919: GO 9941
9921: LD_INT 2
9923: DOUBLE
9924: EQUAL
9925: IFTRUE 9929
9927: GO 9940
9929: POP
// frank_send_to_scout := false ; end ;
9930: LD_ADDR_EXP 14
9934: PUSH
9935: LD_INT 0
9937: ST_TO_ADDR
9938: GO 9941
9940: POP
// InGameOff ;
9941: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
9945: LD_EXP 34
9949: PUSH
9950: LD_EXP 37
9954: PUSH
9955: LD_EXP 44
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: LIST
9964: PPUSH
9965: CALL_OW 139
// if frank_send_to_scout then
9969: LD_EXP 14
9973: IFFALSE 10030
// begin ComMoveXY ( Frank , 130 , 123 ) ;
9975: LD_EXP 48
9979: PPUSH
9980: LD_INT 130
9982: PPUSH
9983: LD_INT 123
9985: PPUSH
9986: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
9990: LD_INT 35
9992: PPUSH
9993: CALL_OW 67
// until not See ( 1 , Frank ) ;
9997: LD_INT 1
9999: PPUSH
10000: LD_EXP 48
10004: PPUSH
10005: CALL_OW 292
10009: NOT
10010: IFFALSE 9990
// Wait ( 0 0$02 ) ;
10012: LD_INT 70
10014: PPUSH
10015: CALL_OW 67
// RemoveUnit ( Frank ) ;
10019: LD_EXP 48
10023: PPUSH
10024: CALL_OW 64
// end else
10028: GO 10042
// SetSide ( Frank , 1 ) ;
10030: LD_EXP 48
10034: PPUSH
10035: LD_INT 1
10037: PPUSH
10038: CALL_OW 235
// send_attack_on_cornel_base := true ;
10042: LD_ADDR_EXP 25
10046: PUSH
10047: LD_INT 1
10049: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10050: LD_INT 35
10052: PPUSH
10053: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10057: LD_ADDR_EXP 27
10061: PUSH
10062: LD_EXP 27
10066: PPUSH
10067: LD_STRING -
10069: PPUSH
10070: CALL 1101 0 2
10074: ST_TO_ADDR
// if debug then
10075: LD_EXP 1
10079: IFFALSE 10091
// debug_strings := time_to_prepare ;
10081: LD_ADDR_OWVAR 48
10085: PUSH
10086: LD_EXP 27
10090: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10091: LD_EXP 27
10095: PUSH
10096: LD_INT 0
10098: EQUAL
10099: IFFALSE 10050
// cornel_prepared := true ;
10101: LD_ADDR_EXP 11
10105: PUSH
10106: LD_INT 1
10108: ST_TO_ADDR
// end ;
10109: PPOPN 2
10111: END
// every 0 0$01 trigger cornel_prepared do
10112: LD_EXP 11
10116: IFFALSE 10373
10118: GO 10120
10120: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10121: LD_EXP 41
10125: PPUSH
10126: LD_STRING D3-Corn-1
10128: PPUSH
10129: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10133: LD_INT 35
10135: PPUSH
10136: CALL_OW 67
// until cornel_counter = 0 ;
10140: LD_EXP 10
10144: PUSH
10145: LD_INT 0
10147: EQUAL
10148: IFFALSE 10133
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10150: LD_EXP 41
10154: PPUSH
10155: LD_STRING D3a-Corn-1
10157: PPUSH
10158: CALL_OW 94
// if IsOk ( Cornel ) then
10162: LD_EXP 41
10166: PPUSH
10167: CALL_OW 302
10171: IFFALSE 10185
// Say ( JMM , D3a-JMM-1 ) ;
10173: LD_EXP 34
10177: PPUSH
10178: LD_STRING D3a-JMM-1
10180: PPUSH
10181: CALL_OW 88
// end_mission_allowed := true ;
10185: LD_ADDR_EXP 20
10189: PUSH
10190: LD_INT 1
10192: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10193: LD_STRING M2
10195: PPUSH
10196: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10200: LD_INT 9
10202: PPUSH
10203: LD_INT 1
10205: PPUSH
10206: CALL_OW 424
// Wait ( 0 0$05 ) ;
10210: LD_INT 175
10212: PPUSH
10213: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10217: LD_EXP 41
10221: PPUSH
10222: LD_STRING D3a-Corn-2
10224: PPUSH
10225: CALL_OW 94
// cornel_attack := true ;
10229: LD_ADDR_EXP 9
10233: PUSH
10234: LD_INT 1
10236: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10237: LD_INT 105
10239: PPUSH
10240: CALL_OW 67
// AddMoreTanks ( ) ;
10244: CALL 4818 0 0
// if frank_send_to_scout then
10248: LD_EXP 14
10252: IFFALSE 10373
// begin InitHc ;
10254: CALL_OW 19
// InitUc ;
10258: CALL_OW 18
// uc_side := 8 ;
10262: LD_ADDR_OWVAR 20
10266: PUSH
10267: LD_INT 8
10269: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10270: LD_ADDR_EXP 48
10274: PUSH
10275: LD_STRING Frank
10277: PPUSH
10278: LD_INT 0
10280: PPUSH
10281: CALL 458 0 2
10285: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10286: LD_EXP 48
10290: PPUSH
10291: LD_INT 6
10293: PPUSH
10294: LD_INT 9
10296: PPUSH
10297: LD_INT 0
10299: PPUSH
10300: CALL_OW 48
// ComCrawl ( Frank ) ;
10304: LD_EXP 48
10308: PPUSH
10309: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
10313: LD_INT 35
10315: PPUSH
10316: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
10320: LD_EXP 34
10324: PPUSH
10325: LD_EXP 48
10329: PPUSH
10330: CALL_OW 296
10334: PUSH
10335: LD_INT 9
10337: LESS
10338: IFFALSE 10313
// SetSide ( Frank , 1 ) ;
10340: LD_EXP 48
10344: PPUSH
10345: LD_INT 1
10347: PPUSH
10348: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10352: LD_EXP 48
10356: PPUSH
10357: LD_STRING D6a-Frank-1
10359: PPUSH
10360: CALL_OW 88
// ComWalk ( Frank ) ;
10364: LD_EXP 48
10368: PPUSH
10369: CALL_OW 138
// end ; end ;
10373: END
// every 0 0$01 trigger solar_builded do
10374: LD_EXP 13
10378: IFFALSE 10482
10380: GO 10382
10382: DISABLE
// begin Wait ( 0 0$02 ) ;
10383: LD_INT 70
10385: PPUSH
10386: CALL_OW 67
// DialogueOn ;
10390: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10394: LD_EXP 34
10398: PPUSH
10399: LD_STRING D2b-JMM-1
10401: PPUSH
10402: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10406: LD_EXP 45
10410: PUSH
10411: LD_EXP 45
10415: PPUSH
10416: CALL_OW 302
10420: AND
10421: IFFALSE 10471
// begin Say ( Walker , D2b-Sci1-1 ) ;
10423: LD_EXP 45
10427: PPUSH
10428: LD_STRING D2b-Sci1-1
10430: PPUSH
10431: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10435: LD_EXP 34
10439: PPUSH
10440: LD_STRING D2b-JMM-2
10442: PPUSH
10443: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10447: LD_EXP 45
10451: PPUSH
10452: LD_STRING D2b-Sci1-2
10454: PPUSH
10455: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10459: LD_EXP 34
10463: PPUSH
10464: LD_STRING D2b-JMM-3
10466: PPUSH
10467: CALL_OW 88
// end ; DialogueOff ;
10471: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10475: LD_STRING MOutSol
10477: PPUSH
10478: CALL_OW 337
// end ;
10482: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10483: LD_EXP 13
10487: PUSH
10488: LD_EXP 34
10492: PPUSH
10493: CALL_OW 302
10497: AND
10498: PUSH
10499: LD_EXP 34
10503: PPUSH
10504: CALL 935 0 1
10508: AND
10509: PUSH
10510: LD_EXP 15
10514: NOT
10515: AND
10516: IFFALSE 10587
10518: GO 10520
10520: DISABLE
10521: LD_INT 0
10523: PPUSH
// begin jmm_in_veh := true ;
10524: LD_ADDR_EXP 15
10528: PUSH
10529: LD_INT 1
10531: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10532: LD_ADDR_VAR 0 1
10536: PUSH
10537: LD_INT 0
10539: PPUSH
10540: LD_INT 1
10542: PPUSH
10543: CALL_OW 12
10547: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10548: LD_INT 70
10550: PPUSH
10551: CALL_OW 67
// if i then
10555: LD_VAR 0 1
10559: IFFALSE 10575
// Say ( JMM , D2c-JMM-1 ) else
10561: LD_EXP 34
10565: PPUSH
10566: LD_STRING D2c-JMM-1
10568: PPUSH
10569: CALL_OW 88
10573: GO 10587
// Say ( JMM , D2c-JMM-1a ) ;
10575: LD_EXP 34
10579: PPUSH
10580: LD_STRING D2c-JMM-1a
10582: PPUSH
10583: CALL_OW 88
// end ;
10587: PPOPN 1
10589: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10590: LD_EXP 13
10594: PUSH
10595: LD_EXP 35
10599: PPUSH
10600: CALL_OW 302
10604: AND
10605: PUSH
10606: LD_EXP 35
10610: PPUSH
10611: CALL 935 0 1
10615: AND
10616: PUSH
10617: LD_EXP 16
10621: NOT
10622: AND
10623: IFFALSE 10655
10625: GO 10627
10627: DISABLE
// begin bobby_in_veh := true ;
10628: LD_ADDR_EXP 16
10632: PUSH
10633: LD_INT 1
10635: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10636: LD_INT 70
10638: PPUSH
10639: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10643: LD_EXP 35
10647: PPUSH
10648: LD_STRING D2c-Bobby-1
10650: PPUSH
10651: CALL_OW 88
10655: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10656: LD_EXP 13
10660: PUSH
10661: LD_EXP 37
10665: PPUSH
10666: CALL_OW 302
10670: AND
10671: PUSH
10672: LD_EXP 37
10676: PPUSH
10677: CALL 935 0 1
10681: AND
10682: PUSH
10683: LD_EXP 18
10687: NOT
10688: AND
10689: IFFALSE 10721
10691: GO 10693
10693: DISABLE
// begin lisa_in_veh := true ;
10694: LD_ADDR_EXP 18
10698: PUSH
10699: LD_INT 1
10701: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10702: LD_INT 70
10704: PPUSH
10705: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10709: LD_EXP 37
10713: PPUSH
10714: LD_STRING D2c-Lisa-1
10716: PPUSH
10717: CALL_OW 88
10721: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
10722: LD_EXP 13
10726: PUSH
10727: LD_EXP 36
10731: PPUSH
10732: CALL_OW 302
10736: AND
10737: PUSH
10738: LD_EXP 36
10742: PPUSH
10743: CALL 935 0 1
10747: AND
10748: PUSH
10749: LD_EXP 17
10753: NOT
10754: AND
10755: IFFALSE 10826
10757: GO 10759
10759: DISABLE
10760: LD_INT 0
10762: PPUSH
// begin cyrus_in_veh := true ;
10763: LD_ADDR_EXP 17
10767: PUSH
10768: LD_INT 1
10770: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10771: LD_ADDR_VAR 0 1
10775: PUSH
10776: LD_INT 0
10778: PPUSH
10779: LD_INT 1
10781: PPUSH
10782: CALL_OW 12
10786: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10787: LD_INT 70
10789: PPUSH
10790: CALL_OW 67
// if i then
10794: LD_VAR 0 1
10798: IFFALSE 10814
// Say ( Cyrus , D2c-Cyrus-1 ) else
10800: LD_EXP 36
10804: PPUSH
10805: LD_STRING D2c-Cyrus-1
10807: PPUSH
10808: CALL_OW 88
10812: GO 10826
// Say ( Cyrus , D2c-Cyrus-1a ) ;
10814: LD_EXP 36
10818: PPUSH
10819: LD_STRING D2c-Cyrus-1a
10821: PPUSH
10822: CALL_OW 88
// end ;
10826: PPOPN 1
10828: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
10829: LD_EXP 41
10833: PPUSH
10834: LD_INT 16
10836: PPUSH
10837: CALL_OW 308
10841: IFFALSE 11097
10843: GO 10845
10845: DISABLE
10846: LD_INT 0
10848: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
10849: LD_INT 3
10851: PPUSH
10852: LD_EXP 41
10856: PPUSH
10857: CALL_OW 471
// send_attack_on_cornel := true ;
10861: LD_ADDR_EXP 30
10865: PUSH
10866: LD_INT 1
10868: ST_TO_ADDR
// if ru_vehicles then
10869: LD_EXP 53
10873: IFFALSE 10907
// for i in ru_vehicles do
10875: LD_ADDR_VAR 0 1
10879: PUSH
10880: LD_EXP 53
10884: PUSH
10885: FOR_IN
10886: IFFALSE 10905
// ComAgressiveMove ( i , 215 , 69 ) ;
10888: LD_VAR 0 1
10892: PPUSH
10893: LD_INT 215
10895: PPUSH
10896: LD_INT 69
10898: PPUSH
10899: CALL_OW 114
10903: GO 10885
10905: POP
10906: POP
// if ru_patrol then
10907: LD_EXP 50
10911: IFFALSE 10945
// for i in ru_patrol do
10913: LD_ADDR_VAR 0 1
10917: PUSH
10918: LD_EXP 50
10922: PUSH
10923: FOR_IN
10924: IFFALSE 10943
// ComAgressiveMove ( i , 215 , 69 ) ;
10926: LD_VAR 0 1
10930: PPUSH
10931: LD_INT 215
10933: PPUSH
10934: LD_INT 69
10936: PPUSH
10937: CALL_OW 114
10941: GO 10923
10943: POP
10944: POP
// if frank_send_to_scout then
10945: LD_EXP 14
10949: IFFALSE 10963
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
10951: LD_EXP 48
10955: PPUSH
10956: LD_STRING D3b-Frank-1
10958: PPUSH
10959: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
10963: LD_INT 105
10965: PPUSH
10966: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
10970: LD_EXP 41
10974: PPUSH
10975: LD_STRING D4-Corn-1
10977: PPUSH
10978: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10982: LD_INT 35
10984: PPUSH
10985: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 6 ;
10989: LD_INT 22
10991: PUSH
10992: LD_INT 4
10994: PUSH
10995: EMPTY
10996: LIST
10997: LIST
10998: PUSH
10999: LD_INT 21
11001: PUSH
11002: LD_INT 1
11004: PUSH
11005: EMPTY
11006: LIST
11007: LIST
11008: PUSH
11009: LD_INT 50
11011: PUSH
11012: EMPTY
11013: LIST
11014: PUSH
11015: EMPTY
11016: LIST
11017: LIST
11018: LIST
11019: PPUSH
11020: CALL_OW 69
11024: PUSH
11025: LD_INT 6
11027: LESS
11028: IFFALSE 10982
// SayRadio ( Cornel , D5-Corn-1 ) ;
11030: LD_EXP 41
11034: PPUSH
11035: LD_STRING D5-Corn-1
11037: PPUSH
11038: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11042: LD_EXP 41
11046: PPUSH
11047: LD_EXP 2
11051: PUSH
11052: LD_STRING Cornel
11054: STR
11055: PPUSH
11056: CALL_OW 38
// ChangeSideFog ( 4 , 8 ) ;
11060: LD_INT 4
11062: PPUSH
11063: LD_INT 8
11065: PPUSH
11066: CALL_OW 343
// Wait ( 0 0$01 ) ;
11070: LD_INT 35
11072: PPUSH
11073: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11077: LD_INT 3
11079: PPUSH
11080: LD_EXP 41
11084: PPUSH
11085: CALL_OW 472
// send_attack_on_cornel := false ;
11089: LD_ADDR_EXP 30
11093: PUSH
11094: LD_INT 0
11096: ST_TO_ADDR
// end ;
11097: PPOPN 1
11099: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11100: LD_INT 9
11102: PPUSH
11103: LD_INT 22
11105: PUSH
11106: LD_INT 1
11108: PUSH
11109: EMPTY
11110: LIST
11111: LIST
11112: PPUSH
11113: CALL_OW 70
11117: PUSH
11118: LD_EXP 31
11122: OR
11123: IFFALSE 11305
11125: GO 11127
11127: DISABLE
11128: LD_INT 0
11130: PPUSH
11131: PPUSH
// begin enable ;
11132: ENABLE
// if not jmm_on_west then
11133: LD_EXP 5
11137: NOT
11138: IFFALSE 11149
// begin YouLost ( 4 ) ;
11140: LD_STRING 4
11142: PPUSH
11143: CALL_OW 104
// exit ;
11147: GO 11305
// end ; if not game_end then
11149: LD_EXP 31
11153: NOT
11154: IFFALSE 11164
// game_end := true ;
11156: LD_ADDR_EXP 31
11160: PUSH
11161: LD_INT 1
11163: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11164: LD_ADDR_VAR 0 2
11168: PUSH
11169: LD_INT 9
11171: PPUSH
11172: LD_INT 22
11174: PUSH
11175: LD_INT 1
11177: PUSH
11178: EMPTY
11179: LIST
11180: LIST
11181: PPUSH
11182: CALL_OW 70
11186: ST_TO_ADDR
// if not filter then
11187: LD_VAR 0 2
11191: NOT
11192: IFFALSE 11196
// exit ;
11194: GO 11305
// for i in filter do
11196: LD_ADDR_VAR 0 1
11200: PUSH
11201: LD_VAR 0 2
11205: PUSH
11206: FOR_IN
11207: IFFALSE 11303
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
11209: LD_VAR 0 1
11213: PPUSH
11214: CALL_OW 302
11218: PUSH
11219: LD_VAR 0 1
11223: PPUSH
11224: CALL_OW 247
11228: PUSH
11229: LD_INT 2
11231: EQUAL
11232: AND
11233: IFFALSE 11266
// begin veh_on_meta := true ;
11235: LD_ADDR_EXP 26
11239: PUSH
11240: LD_INT 1
11242: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11243: LD_VAR 0 1
11247: PPUSH
11248: CALL_OW 311
11252: PPUSH
11253: CALL 11308 0 1
// RemoveUnit ( i ) ;
11257: LD_VAR 0 1
11261: PPUSH
11262: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11266: LD_VAR 0 1
11270: PPUSH
11271: CALL_OW 302
11275: PUSH
11276: LD_VAR 0 1
11280: PPUSH
11281: CALL_OW 247
11285: PUSH
11286: LD_INT 1
11288: EQUAL
11289: AND
11290: IFFALSE 11301
// Save ( i ) ;
11292: LD_VAR 0 1
11296: PPUSH
11297: CALL 11308 0 1
// end ;
11301: GO 11206
11303: POP
11304: POP
// end ;
11305: PPOPN 2
11307: END
// export function Save ( i ) ; begin
11308: LD_INT 0
11310: PPUSH
// if i = JMM then
11311: LD_VAR 0 1
11315: PUSH
11316: LD_EXP 34
11320: EQUAL
11321: IFFALSE 11443
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11323: LD_EXP 23
11327: PUSH
11328: LD_INT 22
11330: PUSH
11331: LD_INT 1
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: PUSH
11338: LD_INT 21
11340: PUSH
11341: LD_INT 1
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PUSH
11348: EMPTY
11349: LIST
11350: LIST
11351: PPUSH
11352: CALL_OW 69
11356: PUSH
11357: LD_INT 1
11359: GREATER
11360: AND
11361: IFFALSE 11418
// begin show_query := false ;
11363: LD_ADDR_EXP 23
11367: PUSH
11368: LD_INT 0
11370: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11371: LD_STRING Q2
11373: PPUSH
11374: CALL_OW 97
11378: PUSH
11379: LD_INT 1
11381: DOUBLE
11382: EQUAL
11383: IFTRUE 11387
11385: GO 11398
11387: POP
// wait_for_them := true ; 2 :
11388: LD_ADDR_EXP 24
11392: PUSH
11393: LD_INT 1
11395: ST_TO_ADDR
11396: GO 11418
11398: LD_INT 2
11400: DOUBLE
11401: EQUAL
11402: IFTRUE 11406
11404: GO 11417
11406: POP
// wait_for_them := false ; end ;
11407: LD_ADDR_EXP 24
11411: PUSH
11412: LD_INT 0
11414: ST_TO_ADDR
11415: GO 11418
11417: POP
// end ; save_group := save_group ^ JMM ;
11418: LD_ADDR_EXP 22
11422: PUSH
11423: LD_EXP 22
11427: PUSH
11428: LD_EXP 34
11432: ADD
11433: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11434: LD_EXP 34
11438: PPUSH
11439: CALL_OW 64
// end ; if i = Lisa then
11443: LD_VAR 0 1
11447: PUSH
11448: LD_EXP 37
11452: EQUAL
11453: IFFALSE 11480
// begin save_group := save_group ^ Lisa ;
11455: LD_ADDR_EXP 22
11459: PUSH
11460: LD_EXP 22
11464: PUSH
11465: LD_EXP 37
11469: ADD
11470: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11471: LD_EXP 37
11475: PPUSH
11476: CALL_OW 64
// end ; if i = Bobby then
11480: LD_VAR 0 1
11484: PUSH
11485: LD_EXP 35
11489: EQUAL
11490: IFFALSE 11517
// begin save_group := save_group ^ Bobby ;
11492: LD_ADDR_EXP 22
11496: PUSH
11497: LD_EXP 22
11501: PUSH
11502: LD_EXP 35
11506: ADD
11507: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11508: LD_EXP 35
11512: PPUSH
11513: CALL_OW 64
// end ; if i = Cyrus then
11517: LD_VAR 0 1
11521: PUSH
11522: LD_EXP 36
11526: EQUAL
11527: IFFALSE 11554
// begin save_group := save_group ^ Cyrus ;
11529: LD_ADDR_EXP 22
11533: PUSH
11534: LD_EXP 22
11538: PUSH
11539: LD_EXP 36
11543: ADD
11544: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11545: LD_EXP 36
11549: PPUSH
11550: CALL_OW 64
// end ; if i = Khatam then
11554: LD_VAR 0 1
11558: PUSH
11559: LD_EXP 38
11563: EQUAL
11564: IFFALSE 11591
// begin save_group := save_group ^ Khatam ;
11566: LD_ADDR_EXP 22
11570: PUSH
11571: LD_EXP 22
11575: PUSH
11576: LD_EXP 38
11580: ADD
11581: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11582: LD_EXP 38
11586: PPUSH
11587: CALL_OW 64
// end ; if i = Frank then
11591: LD_VAR 0 1
11595: PUSH
11596: LD_EXP 48
11600: EQUAL
11601: IFFALSE 11628
// begin save_group := save_group ^ Frank ;
11603: LD_ADDR_EXP 22
11607: PUSH
11608: LD_EXP 22
11612: PUSH
11613: LD_EXP 48
11617: ADD
11618: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11619: LD_EXP 48
11623: PPUSH
11624: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11628: LD_VAR 0 1
11632: PPUSH
11633: CALL_OW 302
11637: PUSH
11638: LD_VAR 0 1
11642: PPUSH
11643: CALL_OW 247
11647: PUSH
11648: LD_INT 1
11650: EQUAL
11651: AND
11652: PUSH
11653: LD_VAR 0 1
11657: PUSH
11658: LD_EXP 22
11662: IN
11663: NOT
11664: AND
11665: IFFALSE 11692
// begin save_others := save_others ^ i ;
11667: LD_ADDR_EXP 21
11671: PUSH
11672: LD_EXP 21
11676: PUSH
11677: LD_VAR 0 1
11681: ADD
11682: ST_TO_ADDR
// RemoveUnit ( i ) ;
11683: LD_VAR 0 1
11687: PPUSH
11688: CALL_OW 64
// end ; end ;
11692: LD_VAR 0 2
11696: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
11697: LD_EXP 23
11701: NOT
11702: PUSH
11703: LD_EXP 24
11707: NOT
11708: AND
11709: PUSH
11710: LD_INT 22
11712: PUSH
11713: LD_INT 1
11715: PUSH
11716: EMPTY
11717: LIST
11718: LIST
11719: PUSH
11720: LD_INT 21
11722: PUSH
11723: LD_INT 1
11725: PUSH
11726: EMPTY
11727: LIST
11728: LIST
11729: PUSH
11730: EMPTY
11731: LIST
11732: LIST
11733: PPUSH
11734: CALL_OW 69
11738: PUSH
11739: LD_INT 0
11741: EQUAL
11742: OR
11743: IFFALSE 11752
11745: GO 11747
11747: DISABLE
// EndMission ;
11748: CALL 11753 0 0
11752: END
// export function EndMission ; var i ; begin
11753: LD_INT 0
11755: PPUSH
11756: PPUSH
// Wait ( 0 0$02 ) ;
11757: LD_INT 70
11759: PPUSH
11760: CALL_OW 67
// if solar_builded then
11764: LD_EXP 13
11768: IFFALSE 11782
// AddMedal ( Solar1 , 1 ) else
11770: LD_STRING Solar1
11772: PPUSH
11773: LD_INT 1
11775: PPUSH
11776: CALL_OW 101
11780: GO 11793
// AddMedal ( Solar1 , - 1 ) ;
11782: LD_STRING Solar1
11784: PPUSH
11785: LD_INT 1
11787: NEG
11788: PPUSH
11789: CALL_OW 101
// if veh_on_meta then
11793: LD_EXP 26
11797: IFFALSE 11811
// AddMedal ( Solar2 , 1 ) else
11799: LD_STRING Solar2
11801: PPUSH
11802: LD_INT 1
11804: PPUSH
11805: CALL_OW 101
11809: GO 11841
// if solar_builded then
11811: LD_EXP 13
11815: IFFALSE 11830
// AddMedal ( Solar2 , - 1 ) else
11817: LD_STRING Solar2
11819: PPUSH
11820: LD_INT 1
11822: NEG
11823: PPUSH
11824: CALL_OW 101
11828: GO 11841
// AddMedal ( Solar2 , - 2 ) ;
11830: LD_STRING Solar2
11832: PPUSH
11833: LD_INT 2
11835: NEG
11836: PPUSH
11837: CALL_OW 101
// if lose_counter = 0 then
11841: LD_EXP 32
11845: PUSH
11846: LD_INT 0
11848: EQUAL
11849: IFFALSE 11863
// AddMedal ( No , 1 ) else
11851: LD_STRING No
11853: PPUSH
11854: LD_INT 1
11856: PPUSH
11857: CALL_OW 101
11861: GO 11907
// if lose_counter > 0 and lose_counter < 4 then
11863: LD_EXP 32
11867: PUSH
11868: LD_INT 0
11870: GREATER
11871: PUSH
11872: LD_EXP 32
11876: PUSH
11877: LD_INT 4
11879: LESS
11880: AND
11881: IFFALSE 11896
// AddMedal ( No , - 1 ) else
11883: LD_STRING No
11885: PPUSH
11886: LD_INT 1
11888: NEG
11889: PPUSH
11890: CALL_OW 101
11894: GO 11907
// AddMedal ( UpTo4 , - 1 ) ;
11896: LD_STRING UpTo4
11898: PPUSH
11899: LD_INT 1
11901: NEG
11902: PPUSH
11903: CALL_OW 101
// GiveMedals ( MAIN ) ;
11907: LD_STRING MAIN
11909: PPUSH
11910: CALL_OW 102
// if IsDead ( Pokryshkin ) then
11914: LD_EXP 49
11918: PPUSH
11919: CALL_OW 301
11923: IFFALSE 11963
// for i in save_group ^ save_others do
11925: LD_ADDR_VAR 0 2
11929: PUSH
11930: LD_EXP 22
11934: PUSH
11935: LD_EXP 21
11939: ADD
11940: PUSH
11941: FOR_IN
11942: IFFALSE 11961
// AddExperience ( i , skill_combat , 1500 ) ;
11944: LD_VAR 0 2
11948: PPUSH
11949: LD_INT 1
11951: PPUSH
11952: LD_INT 1500
11954: PPUSH
11955: CALL_OW 492
11959: GO 11941
11961: POP
11962: POP
// RewardPeople ( save_group ^ save_others ) ;
11963: LD_EXP 22
11967: PUSH
11968: LD_EXP 21
11972: ADD
11973: PPUSH
11974: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11978: LD_EXP 34
11982: PPUSH
11983: LD_EXP 2
11987: PUSH
11988: LD_STRING JMM
11990: STR
11991: PPUSH
11992: CALL_OW 38
// if Bobby in save_group then
11996: LD_EXP 35
12000: PUSH
12001: LD_EXP 22
12005: IN
12006: IFFALSE 12026
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12008: LD_EXP 35
12012: PPUSH
12013: LD_EXP 2
12017: PUSH
12018: LD_STRING Bobby
12020: STR
12021: PPUSH
12022: CALL_OW 38
// if Cyrus in save_group then
12026: LD_EXP 36
12030: PUSH
12031: LD_EXP 22
12035: IN
12036: IFFALSE 12056
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12038: LD_EXP 36
12042: PPUSH
12043: LD_EXP 2
12047: PUSH
12048: LD_STRING Cyrus
12050: STR
12051: PPUSH
12052: CALL_OW 38
// if Lisa in save_group then
12056: LD_EXP 37
12060: PUSH
12061: LD_EXP 22
12065: IN
12066: IFFALSE 12086
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12068: LD_EXP 37
12072: PPUSH
12073: LD_EXP 2
12077: PUSH
12078: LD_STRING Lisa
12080: STR
12081: PPUSH
12082: CALL_OW 38
// if Frank in save_group then
12086: LD_EXP 48
12090: PUSH
12091: LD_EXP 22
12095: IN
12096: IFFALSE 12116
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12098: LD_EXP 48
12102: PPUSH
12103: LD_EXP 2
12107: PUSH
12108: LD_STRING Frank
12110: STR
12111: PPUSH
12112: CALL_OW 38
// if Khatam in save_group then
12116: LD_EXP 38
12120: PUSH
12121: LD_EXP 22
12125: IN
12126: IFFALSE 12146
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
12128: LD_EXP 38
12132: PPUSH
12133: LD_EXP 2
12137: PUSH
12138: LD_STRING Khatam
12140: STR
12141: PPUSH
12142: CALL_OW 38
// if save_others then
12146: LD_EXP 21
12150: IFFALSE 12164
// SaveCharacters ( save_others , 03_others ) ;
12152: LD_EXP 21
12156: PPUSH
12157: LD_STRING 03_others
12159: PPUSH
12160: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) then
12164: LD_EXP 42
12168: PUSH
12169: LD_EXP 42
12173: PPUSH
12174: CALL_OW 302
12178: AND
12179: IFFALSE 12191
// begin ResetFog ;
12181: CALL_OW 335
// DisplayEndingScene ;
12185: CALL 12213 0 0
// end else
12189: GO 12204
// DeleteCharacters ( mission_prefix & Cornel ) ;
12191: LD_EXP 2
12195: PUSH
12196: LD_STRING Cornel
12198: STR
12199: PPUSH
12200: CALL_OW 40
// YouWin ;
12204: CALL_OW 103
// end ;
12208: LD_VAR 0 1
12212: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
12213: LD_INT 0
12215: PPUSH
12216: PPUSH
12217: PPUSH
12218: PPUSH
12219: PPUSH
12220: PPUSH
// InGameOn ;
12221: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12225: LD_INT 208
12227: PPUSH
12228: LD_INT 62
12230: PPUSH
12231: LD_INT 1
12233: PPUSH
12234: LD_INT 10
12236: NEG
12237: PPUSH
12238: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
12242: LD_INT 208
12244: PPUSH
12245: LD_INT 62
12247: PPUSH
12248: LD_INT 1
12250: PPUSH
12251: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
12255: LD_ADDR_VAR 0 3
12259: PUSH
12260: LD_INT 22
12262: PUSH
12263: LD_INT 3
12265: PUSH
12266: EMPTY
12267: LIST
12268: LIST
12269: PUSH
12270: LD_INT 2
12272: PUSH
12273: LD_INT 21
12275: PUSH
12276: LD_INT 2
12278: PUSH
12279: EMPTY
12280: LIST
12281: LIST
12282: PUSH
12283: LD_INT 21
12285: PUSH
12286: LD_INT 1
12288: PUSH
12289: EMPTY
12290: LIST
12291: LIST
12292: PUSH
12293: EMPTY
12294: LIST
12295: LIST
12296: LIST
12297: PUSH
12298: EMPTY
12299: LIST
12300: LIST
12301: PPUSH
12302: CALL_OW 69
12306: ST_TO_ADDR
// if filter then
12307: LD_VAR 0 3
12311: IFFALSE 12339
// for i in filter do
12313: LD_ADDR_VAR 0 2
12317: PUSH
12318: LD_VAR 0 3
12322: PUSH
12323: FOR_IN
12324: IFFALSE 12337
// RemoveUnit ( i ) ;
12326: LD_VAR 0 2
12330: PPUSH
12331: CALL_OW 64
12335: GO 12323
12337: POP
12338: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
12339: LD_ADDR_VAR 0 3
12343: PUSH
12344: LD_INT 22
12346: PUSH
12347: LD_INT 4
12349: PUSH
12350: EMPTY
12351: LIST
12352: LIST
12353: PUSH
12354: LD_INT 21
12356: PUSH
12357: LD_INT 1
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: PUSH
12364: EMPTY
12365: LIST
12366: LIST
12367: PPUSH
12368: CALL_OW 69
12372: ST_TO_ADDR
// if filter then
12373: LD_VAR 0 3
12377: IFFALSE 12408
// for i in filter do
12379: LD_ADDR_VAR 0 2
12383: PUSH
12384: LD_VAR 0 3
12388: PUSH
12389: FOR_IN
12390: IFFALSE 12406
// SetLives ( i , 0 ) ;
12392: LD_VAR 0 2
12396: PPUSH
12397: LD_INT 0
12399: PPUSH
12400: CALL_OW 234
12404: GO 12389
12406: POP
12407: POP
// uc_side := 4 ;
12408: LD_ADDR_OWVAR 20
12412: PUSH
12413: LD_INT 4
12415: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12416: LD_ADDR_VAR 0 4
12420: PUSH
12421: LD_STRING Cornell
12423: PPUSH
12424: LD_INT 0
12426: PPUSH
12427: CALL 458 0 2
12431: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12432: LD_VAR 0 4
12436: PPUSH
12437: LD_INT 208
12439: PPUSH
12440: LD_INT 62
12442: PPUSH
12443: LD_INT 0
12445: PPUSH
12446: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12450: LD_VAR 0 4
12454: PPUSH
12455: LD_INT 100
12457: PPUSH
12458: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12462: LD_INT 3
12464: PPUSH
12465: LD_VAR 0 4
12469: PPUSH
12470: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12474: LD_INT 4
12476: PPUSH
12477: LD_INT 3
12479: PPUSH
12480: LD_INT 1
12482: PPUSH
12483: LD_INT 1
12485: PPUSH
12486: CALL_OW 80
// uc_side := 3 ;
12490: LD_ADDR_OWVAR 20
12494: PUSH
12495: LD_INT 3
12497: ST_TO_ADDR
// uc_nation := 3 ;
12498: LD_ADDR_OWVAR 21
12502: PUSH
12503: LD_INT 3
12505: ST_TO_ADDR
// InitHc ;
12506: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12510: LD_ADDR_VAR 0 5
12514: PUSH
12515: LD_STRING Mikhail
12517: PPUSH
12518: LD_INT 0
12520: PPUSH
12521: CALL 458 0 2
12525: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12526: LD_INT 1
12528: PPUSH
12529: LD_INT 1
12531: PPUSH
12532: LD_INT 0
12534: PPUSH
12535: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12539: LD_ADDR_VAR 0 6
12543: PUSH
12544: LD_VAR 0 6
12548: PUSH
12549: CALL_OW 44
12553: ADD
12554: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12555: LD_ADDR_VAR 0 6
12559: PUSH
12560: LD_VAR 0 6
12564: PUSH
12565: CALL_OW 44
12569: ADD
12570: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12571: LD_INT 2
12573: PPUSH
12574: LD_INT 4
12576: PPUSH
12577: LD_INT 0
12579: PPUSH
12580: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12584: LD_ADDR_VAR 0 6
12588: PUSH
12589: LD_VAR 0 6
12593: PUSH
12594: CALL_OW 44
12598: ADD
12599: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12600: LD_VAR 0 5
12604: PPUSH
12605: LD_INT 17
12607: PPUSH
12608: LD_INT 0
12610: PPUSH
12611: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12615: LD_VAR 0 5
12619: PPUSH
12620: LD_INT 210
12622: PPUSH
12623: LD_INT 63
12625: PPUSH
12626: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12630: LD_VAR 0 5
12634: PPUSH
12635: LD_INT 208
12637: PPUSH
12638: LD_INT 62
12640: PPUSH
12641: CALL_OW 178
// for i in fake_russians do
12645: LD_ADDR_VAR 0 2
12649: PUSH
12650: LD_VAR 0 6
12654: PUSH
12655: FOR_IN
12656: IFFALSE 12734
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12658: LD_VAR 0 2
12662: PPUSH
12663: LD_INT 17
12665: PPUSH
12666: LD_INT 0
12668: PPUSH
12669: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
12673: LD_VAR 0 2
12677: PPUSH
12678: LD_INT 215
12680: PPUSH
12681: LD_INT 67
12683: PPUSH
12684: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
12688: LD_VAR 0 2
12692: PPUSH
12693: LD_INT 208
12695: PPUSH
12696: LD_INT 62
12698: PPUSH
12699: CALL_OW 178
// if GetClass ( i ) = 4 then
12703: LD_VAR 0 2
12707: PPUSH
12708: CALL_OW 257
12712: PUSH
12713: LD_INT 4
12715: EQUAL
12716: IFFALSE 12732
// ComHeal ( i , fake_cornel ) ;
12718: LD_VAR 0 2
12722: PPUSH
12723: LD_VAR 0 4
12727: PPUSH
12728: CALL_OW 128
// end ;
12732: GO 12655
12734: POP
12735: POP
// Wait ( 0 0$01 ) ;
12736: LD_INT 35
12738: PPUSH
12739: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
12743: LD_INT 208
12745: PPUSH
12746: LD_INT 62
12748: PPUSH
12749: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12753: LD_INT 208
12755: PPUSH
12756: LD_INT 62
12758: PPUSH
12759: LD_INT 1
12761: PPUSH
12762: LD_INT 10
12764: NEG
12765: PPUSH
12766: CALL_OW 330
// Wait ( 0 0$15 ) ;
12770: LD_INT 525
12772: PPUSH
12773: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
12777: LD_INT 208
12779: PPUSH
12780: LD_INT 62
12782: PPUSH
12783: LD_INT 1
12785: PPUSH
12786: CALL_OW 331
// ResetFog ;
12790: CALL_OW 335
// InGameOff ;
12794: CALL_OW 9
// end ;
12798: LD_VAR 0 1
12802: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
12803: LD_INT 10
12805: PPUSH
12806: LD_INT 22
12808: PUSH
12809: LD_INT 1
12811: PUSH
12812: EMPTY
12813: LIST
12814: LIST
12815: PPUSH
12816: CALL_OW 70
12820: PUSH
12821: LD_EXP 41
12825: PPUSH
12826: CALL_OW 302
12830: AND
12831: PUSH
12832: LD_INT 22
12834: PUSH
12835: LD_INT 1
12837: PUSH
12838: EMPTY
12839: LIST
12840: LIST
12841: PPUSH
12842: CALL_OW 69
12846: PPUSH
12847: LD_EXP 41
12851: PPUSH
12852: CALL_OW 74
12856: PPUSH
12857: LD_EXP 41
12861: PPUSH
12862: CALL_OW 296
12866: PUSH
12867: LD_INT 30
12869: LESS
12870: OR
12871: IFFALSE 12922
12873: GO 12875
12875: DISABLE
// begin enable ;
12876: ENABLE
// powell_warn := powell_warn + 1 ;
12877: LD_ADDR_EXP 33
12881: PUSH
12882: LD_EXP 33
12886: PUSH
12887: LD_INT 1
12889: PLUS
12890: ST_TO_ADDR
// if powell_warn = 3 then
12891: LD_EXP 33
12895: PUSH
12896: LD_INT 3
12898: EQUAL
12899: IFFALSE 12910
// begin YouLost ( 5 ) ;
12901: LD_STRING 5
12903: PPUSH
12904: CALL_OW 104
// exit ;
12908: GO 12922
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
12910: LD_EXP 43
12914: PPUSH
12915: LD_STRING DWarn-Pow-1
12917: PPUSH
12918: CALL_OW 94
// end ; end_of_file
12922: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
12923: LD_EXP 8
12927: IFFALSE 14263
12929: GO 12931
12931: DISABLE
12932: LD_INT 0
12934: PPUSH
12935: PPUSH
12936: PPUSH
12937: PPUSH
12938: PPUSH
12939: PPUSH
12940: PPUSH
12941: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
12942: LD_EXP 41
12946: PUSH
12947: LD_EXP 42
12951: ADD
12952: PUSH
12953: LD_EXP 6
12957: ADD
12958: PPUSH
12959: LD_INT 250
12961: PPUSH
12962: LD_INT 120
12964: PPUSH
12965: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff [ Bierezov ] ;
12969: LD_ADDR_VAR 0 2
12973: PUSH
12974: LD_EXP 6
12978: PPUSH
12979: LD_INT 25
12981: PUSH
12982: LD_INT 2
12984: PUSH
12985: EMPTY
12986: LIST
12987: LIST
12988: PPUSH
12989: CALL_OW 72
12993: PUSH
12994: LD_EXP 42
12998: PUSH
12999: EMPTY
13000: LIST
13001: DIFF
13002: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
13003: LD_ADDR_VAR 0 3
13007: PUSH
13008: LD_EXP 6
13012: PPUSH
13013: LD_INT 21
13015: PUSH
13016: LD_INT 1
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: PPUSH
13023: CALL_OW 72
13027: ST_TO_ADDR
// if not has_eng then
13028: LD_VAR 0 2
13032: NOT
13033: IFFALSE 13116
// begin uc_side := 4 ;
13035: LD_ADDR_OWVAR 20
13039: PUSH
13040: LD_INT 4
13042: ST_TO_ADDR
// uc_nation := 1 ;
13043: LD_ADDR_OWVAR 21
13047: PUSH
13048: LD_INT 1
13050: ST_TO_ADDR
// bc_type := b_depot ;
13051: LD_ADDR_OWVAR 42
13055: PUSH
13056: LD_INT 0
13058: ST_TO_ADDR
// bc_level := 2 ;
13059: LD_ADDR_OWVAR 43
13063: PUSH
13064: LD_INT 2
13066: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13067: LD_ADDR_VAR 0 4
13071: PUSH
13072: LD_INT 264
13074: PPUSH
13075: LD_INT 120
13077: PPUSH
13078: LD_INT 4
13080: PPUSH
13081: CALL_OW 47
13085: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13086: LD_INT 264
13088: PPUSH
13089: LD_INT 120
13091: PPUSH
13092: LD_INT 4
13094: PPUSH
13095: LD_INT 10
13097: NEG
13098: PPUSH
13099: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13103: LD_INT 264
13105: PPUSH
13106: LD_INT 120
13108: PPUSH
13109: LD_INT 4
13111: PPUSH
13112: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13116: LD_INT 35
13118: PPUSH
13119: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
13123: LD_EXP 41
13127: PPUSH
13128: LD_INT 10
13130: PPUSH
13131: CALL_OW 308
13135: IFFALSE 13116
// if has_eng and not dep then
13137: LD_VAR 0 2
13141: PUSH
13142: LD_VAR 0 4
13146: NOT
13147: AND
13148: IFFALSE 13298
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
13150: LD_VAR 0 2
13154: PPUSH
13155: LD_INT 0
13157: PPUSH
13158: LD_INT 264
13160: PPUSH
13161: LD_INT 120
13163: PPUSH
13164: LD_INT 4
13166: PPUSH
13167: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
13171: LD_INT 35
13173: PPUSH
13174: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
13178: LD_INT 22
13180: PUSH
13181: LD_INT 4
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: PUSH
13188: LD_INT 30
13190: PUSH
13191: LD_INT 0
13193: PUSH
13194: EMPTY
13195: LIST
13196: LIST
13197: PUSH
13198: EMPTY
13199: LIST
13200: LIST
13201: PPUSH
13202: CALL_OW 69
13206: IFFALSE 13171
// ComMoveXY ( filter , 264 , 120 ) ;
13208: LD_VAR 0 3
13212: PPUSH
13213: LD_INT 264
13215: PPUSH
13216: LD_INT 120
13218: PPUSH
13219: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
13223: LD_INT 35
13225: PPUSH
13226: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
13230: LD_INT 22
13232: PUSH
13233: LD_INT 4
13235: PUSH
13236: EMPTY
13237: LIST
13238: LIST
13239: PUSH
13240: LD_INT 30
13242: PUSH
13243: LD_INT 0
13245: PUSH
13246: EMPTY
13247: LIST
13248: LIST
13249: PUSH
13250: LD_INT 3
13252: PUSH
13253: LD_INT 57
13255: PUSH
13256: EMPTY
13257: LIST
13258: PUSH
13259: EMPTY
13260: LIST
13261: LIST
13262: PUSH
13263: EMPTY
13264: LIST
13265: LIST
13266: LIST
13267: PPUSH
13268: CALL_OW 69
13272: IFFALSE 13223
// ComMoveXY ( filter , 247 , 113 ) ;
13274: LD_VAR 0 3
13278: PPUSH
13279: LD_INT 247
13281: PPUSH
13282: LD_INT 113
13284: PPUSH
13285: CALL_OW 111
// Wait ( 0 0$2 ) ;
13289: LD_INT 70
13291: PPUSH
13292: CALL_OW 67
// end else
13296: GO 13310
// begin SetSide ( dep , 4 ) ;
13298: LD_VAR 0 4
13302: PPUSH
13303: LD_INT 4
13305: PPUSH
13306: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
13310: LD_ADDR_VAR 0 4
13314: PUSH
13315: LD_INT 22
13317: PUSH
13318: LD_INT 4
13320: PUSH
13321: EMPTY
13322: LIST
13323: LIST
13324: PUSH
13325: LD_INT 30
13327: PUSH
13328: LD_INT 0
13330: PUSH
13331: EMPTY
13332: LIST
13333: LIST
13334: PUSH
13335: EMPTY
13336: LIST
13337: LIST
13338: PPUSH
13339: CALL_OW 69
13343: PUSH
13344: LD_INT 1
13346: ARRAY
13347: ST_TO_ADDR
// for i = 1 to 2 - has_eng do
13348: LD_ADDR_VAR 0 1
13352: PUSH
13353: DOUBLE
13354: LD_INT 1
13356: DEC
13357: ST_TO_ADDR
13358: LD_INT 2
13360: PUSH
13361: LD_VAR 0 2
13365: MINUS
13366: PUSH
13367: FOR_TO
13368: IFFALSE 13448
// begin if GetClass ( filter [ i ] ) = 2 then
13370: LD_VAR 0 3
13374: PUSH
13375: LD_VAR 0 1
13379: ARRAY
13380: PPUSH
13381: CALL_OW 257
13385: PUSH
13386: LD_INT 2
13388: EQUAL
13389: IFFALSE 13393
// continue ;
13391: GO 13367
// ComEnterUnit ( filter [ i ] , dep ) ;
13393: LD_VAR 0 3
13397: PUSH
13398: LD_VAR 0 1
13402: ARRAY
13403: PPUSH
13404: LD_VAR 0 4
13408: PPUSH
13409: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
13413: LD_VAR 0 3
13417: PUSH
13418: LD_VAR 0 1
13422: ARRAY
13423: PPUSH
13424: LD_INT 2
13426: PPUSH
13427: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
13431: LD_VAR 0 3
13435: PUSH
13436: LD_VAR 0 1
13440: ARRAY
13441: PPUSH
13442: CALL_OW 182
// end ;
13446: GO 13367
13448: POP
13449: POP
// repeat wait ( 0 0$01 ) ;
13450: LD_INT 35
13452: PPUSH
13453: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) >= 2 ;
13457: LD_VAR 0 3
13461: PPUSH
13462: LD_INT 25
13464: PUSH
13465: LD_INT 2
13467: PUSH
13468: EMPTY
13469: LIST
13470: LIST
13471: PPUSH
13472: CALL_OW 72
13476: PUSH
13477: LD_INT 2
13479: GREATEREQUAL
13480: IFFALSE 13450
// if IsInUnit ( Cornel ) then
13482: LD_EXP 41
13486: PPUSH
13487: CALL_OW 310
13491: IFFALSE 13574
// begin cargo := IsInUnit ( Cornel ) ;
13493: LD_ADDR_VAR 0 7
13497: PUSH
13498: LD_EXP 41
13502: PPUSH
13503: CALL_OW 310
13507: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13508: LD_VAR 0 7
13512: PPUSH
13513: LD_INT 1
13515: PPUSH
13516: CALL_OW 289
13520: IFFALSE 13536
// ComGive ( Cornel , dep ) ;
13522: LD_EXP 41
13526: PPUSH
13527: LD_VAR 0 4
13531: PPUSH
13532: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13536: LD_EXP 41
13540: PPUSH
13541: LD_INT 235
13543: PPUSH
13544: LD_INT 122
13546: PPUSH
13547: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13551: LD_EXP 41
13555: PPUSH
13556: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13560: LD_EXP 41
13564: PPUSH
13565: LD_VAR 0 4
13569: PPUSH
13570: CALL_OW 180
// end ; if Bierezov then
13574: LD_EXP 42
13578: IFFALSE 13594
// ComEnterUnit ( Bierezov , dep ) ;
13580: LD_EXP 42
13584: PPUSH
13585: LD_VAR 0 4
13589: PPUSH
13590: CALL_OW 120
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
13594: LD_ADDR_VAR 0 2
13598: PUSH
13599: LD_EXP 6
13603: PPUSH
13604: LD_INT 25
13606: PUSH
13607: LD_INT 2
13609: PUSH
13610: EMPTY
13611: LIST
13612: LIST
13613: PPUSH
13614: CALL_OW 72
13618: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13619: LD_INT 35
13621: PPUSH
13622: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13626: LD_ADDR_VAR 0 6
13630: PUSH
13631: LD_INT 10
13633: PPUSH
13634: CALL_OW 435
13638: ST_TO_ADDR
// if crates then
13639: LD_VAR 0 6
13643: IFFALSE 13672
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
13645: LD_VAR 0 2
13649: PPUSH
13650: LD_VAR 0 6
13654: PUSH
13655: LD_INT 1
13657: ARRAY
13658: PPUSH
13659: LD_VAR 0 6
13663: PUSH
13664: LD_INT 2
13666: ARRAY
13667: PPUSH
13668: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
13672: LD_VAR 0 4
13676: PPUSH
13677: CALL_OW 274
13681: PPUSH
13682: LD_INT 1
13684: PPUSH
13685: CALL_OW 275
13689: PUSH
13690: LD_INT 40
13692: GREATEREQUAL
13693: IFFALSE 13619
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
13695: LD_ADDR_VAR 0 5
13699: PUSH
13700: LD_INT 4
13702: PUSH
13703: LD_INT 256
13705: PUSH
13706: LD_INT 111
13708: PUSH
13709: LD_INT 2
13711: PUSH
13712: EMPTY
13713: LIST
13714: LIST
13715: LIST
13716: LIST
13717: PUSH
13718: LD_INT 31
13720: PUSH
13721: LD_INT 243
13723: PUSH
13724: LD_INT 112
13726: PUSH
13727: LD_INT 2
13729: PUSH
13730: EMPTY
13731: LIST
13732: LIST
13733: LIST
13734: LIST
13735: PUSH
13736: EMPTY
13737: LIST
13738: LIST
13739: ST_TO_ADDR
// for i in blist do
13740: LD_ADDR_VAR 0 1
13744: PUSH
13745: LD_VAR 0 5
13749: PUSH
13750: FOR_IN
13751: IFFALSE 13800
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
13753: LD_VAR 0 2
13757: PPUSH
13758: LD_VAR 0 1
13762: PUSH
13763: LD_INT 1
13765: ARRAY
13766: PPUSH
13767: LD_VAR 0 1
13771: PUSH
13772: LD_INT 2
13774: ARRAY
13775: PPUSH
13776: LD_VAR 0 1
13780: PUSH
13781: LD_INT 3
13783: ARRAY
13784: PPUSH
13785: LD_VAR 0 1
13789: PUSH
13790: LD_INT 4
13792: ARRAY
13793: PPUSH
13794: CALL_OW 205
13798: GO 13750
13800: POP
13801: POP
// repeat wait ( 0 0$01 ) ;
13802: LD_INT 35
13804: PPUSH
13805: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
13809: LD_INT 22
13811: PUSH
13812: LD_INT 4
13814: PUSH
13815: EMPTY
13816: LIST
13817: LIST
13818: PUSH
13819: LD_INT 30
13821: PUSH
13822: LD_INT 4
13824: PUSH
13825: EMPTY
13826: LIST
13827: LIST
13828: PUSH
13829: LD_INT 3
13831: PUSH
13832: LD_INT 57
13834: PUSH
13835: EMPTY
13836: LIST
13837: PUSH
13838: EMPTY
13839: LIST
13840: LIST
13841: PUSH
13842: EMPTY
13843: LIST
13844: LIST
13845: LIST
13846: PPUSH
13847: CALL_OW 69
13851: IFFALSE 13802
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
13853: LD_VAR 0 3
13857: PUSH
13858: LD_VAR 0 2
13862: DIFF
13863: PPUSH
13864: LD_INT 22
13866: PUSH
13867: LD_INT 4
13869: PUSH
13870: EMPTY
13871: LIST
13872: LIST
13873: PUSH
13874: LD_INT 30
13876: PUSH
13877: LD_INT 4
13879: PUSH
13880: EMPTY
13881: LIST
13882: LIST
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: PPUSH
13888: CALL_OW 69
13892: PUSH
13893: LD_INT 1
13895: ARRAY
13896: PPUSH
13897: CALL_OW 180
// AddComChangeProfession ( filter diff has_eng , 1 ) ;
13901: LD_VAR 0 3
13905: PUSH
13906: LD_VAR 0 2
13910: DIFF
13911: PPUSH
13912: LD_INT 1
13914: PPUSH
13915: CALL_OW 183
// repeat wait ( 0 0$01 ) ;
13919: LD_INT 35
13921: PPUSH
13922: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
13926: LD_INT 22
13928: PUSH
13929: LD_INT 4
13931: PUSH
13932: EMPTY
13933: LIST
13934: LIST
13935: PUSH
13936: LD_INT 30
13938: PUSH
13939: LD_INT 31
13941: PUSH
13942: EMPTY
13943: LIST
13944: LIST
13945: PUSH
13946: LD_INT 3
13948: PUSH
13949: LD_INT 57
13951: PUSH
13952: EMPTY
13953: LIST
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PUSH
13959: EMPTY
13960: LIST
13961: LIST
13962: LIST
13963: PPUSH
13964: CALL_OW 69
13968: IFFALSE 13919
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
13970: LD_ADDR_VAR 0 8
13974: PUSH
13975: LD_EXP 6
13979: PPUSH
13980: LD_INT 25
13982: PUSH
13983: LD_INT 1
13985: PUSH
13986: EMPTY
13987: LIST
13988: LIST
13989: PPUSH
13990: CALL_OW 72
13994: ST_TO_ADDR
// ComExitBuilding ( sol [ 1 ] ) ;
13995: LD_VAR 0 8
13999: PUSH
14000: LD_INT 1
14002: ARRAY
14003: PPUSH
14004: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
14008: LD_VAR 0 8
14012: PUSH
14013: LD_INT 1
14015: ARRAY
14016: PPUSH
14017: LD_INT 22
14019: PUSH
14020: LD_INT 4
14022: PUSH
14023: EMPTY
14024: LIST
14025: LIST
14026: PUSH
14027: LD_INT 30
14029: PUSH
14030: LD_INT 31
14032: PUSH
14033: EMPTY
14034: LIST
14035: LIST
14036: PUSH
14037: EMPTY
14038: LIST
14039: LIST
14040: PPUSH
14041: CALL_OW 69
14045: PUSH
14046: LD_INT 1
14048: ARRAY
14049: PPUSH
14050: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
14054: LD_VAR 0 2
14058: PPUSH
14059: LD_VAR 0 4
14063: PPUSH
14064: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
14068: LD_INT 35
14070: PPUSH
14071: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14075: LD_ADDR_VAR 0 3
14079: PUSH
14080: LD_INT 22
14082: PUSH
14083: LD_INT 4
14085: PUSH
14086: EMPTY
14087: LIST
14088: LIST
14089: PUSH
14090: LD_INT 21
14092: PUSH
14093: LD_INT 3
14095: PUSH
14096: EMPTY
14097: LIST
14098: LIST
14099: PUSH
14100: LD_INT 3
14102: PUSH
14103: LD_INT 24
14105: PUSH
14106: LD_INT 1000
14108: PUSH
14109: EMPTY
14110: LIST
14111: LIST
14112: PUSH
14113: EMPTY
14114: LIST
14115: LIST
14116: PUSH
14117: EMPTY
14118: LIST
14119: LIST
14120: LIST
14121: PPUSH
14122: CALL_OW 69
14126: ST_TO_ADDR
// if filter and has_eng then
14127: LD_VAR 0 3
14131: PUSH
14132: LD_VAR 0 2
14136: AND
14137: IFFALSE 14203
// begin for i in has_eng do
14139: LD_ADDR_VAR 0 1
14143: PUSH
14144: LD_VAR 0 2
14148: PUSH
14149: FOR_IN
14150: IFFALSE 14199
// begin if IsInUnit ( i ) then
14152: LD_VAR 0 1
14156: PPUSH
14157: CALL_OW 310
14161: IFFALSE 14172
// ComExitBuilding ( i ) ;
14163: LD_VAR 0 1
14167: PPUSH
14168: CALL_OW 122
// Wait ( 3 ) ;
14172: LD_INT 3
14174: PPUSH
14175: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
14179: LD_VAR 0 1
14183: PPUSH
14184: LD_VAR 0 3
14188: PUSH
14189: LD_INT 1
14191: ARRAY
14192: PPUSH
14193: CALL_OW 130
// end ;
14197: GO 14149
14199: POP
14200: POP
// end else
14201: GO 14257
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
14203: LD_VAR 0 2
14207: PUSH
14208: LD_VAR 0 2
14212: PPUSH
14213: LD_INT 56
14215: PUSH
14216: EMPTY
14217: LIST
14218: PPUSH
14219: CALL_OW 72
14223: AND
14224: IFFALSE 14257
// for i in has_eng do
14226: LD_ADDR_VAR 0 1
14230: PUSH
14231: LD_VAR 0 2
14235: PUSH
14236: FOR_IN
14237: IFFALSE 14255
// ComEnterUnit ( i , dep ) ;
14239: LD_VAR 0 1
14243: PPUSH
14244: LD_VAR 0 4
14248: PPUSH
14249: CALL_OW 120
14253: GO 14236
14255: POP
14256: POP
// until cornel_prepared ;
14257: LD_EXP 11
14261: IFFALSE 14068
// end ;
14263: PPOPN 8
14265: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
14266: LD_EXP 11
14270: IFFALSE 14619
14272: GO 14274
14274: DISABLE
14275: LD_INT 0
14277: PPUSH
14278: PPUSH
14279: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
14280: LD_ADDR_VAR 0 2
14284: PUSH
14285: LD_INT 22
14287: PUSH
14288: LD_INT 4
14290: PUSH
14291: EMPTY
14292: LIST
14293: LIST
14294: PUSH
14295: LD_INT 30
14297: PUSH
14298: LD_INT 4
14300: PUSH
14301: EMPTY
14302: LIST
14303: LIST
14304: PUSH
14305: EMPTY
14306: LIST
14307: LIST
14308: PPUSH
14309: CALL_OW 69
14313: PUSH
14314: LD_INT 1
14316: ARRAY
14317: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
14318: LD_EXP 6
14322: PPUSH
14323: CALL_OW 122
// Wait ( 0 0$03 ) ;
14327: LD_INT 105
14329: PPUSH
14330: CALL_OW 67
// for i in cornel_units do
14334: LD_ADDR_VAR 0 1
14338: PUSH
14339: LD_EXP 6
14343: PUSH
14344: FOR_IN
14345: IFFALSE 14421
// begin if GetClass ( i ) in [ 2 , 3 ] then
14347: LD_VAR 0 1
14351: PPUSH
14352: CALL_OW 257
14356: PUSH
14357: LD_INT 2
14359: PUSH
14360: LD_INT 3
14362: PUSH
14363: EMPTY
14364: LIST
14365: LIST
14366: IN
14367: IFFALSE 14404
// begin ComEnterUnit ( i , arm ) ;
14369: LD_VAR 0 1
14373: PPUSH
14374: LD_VAR 0 2
14378: PPUSH
14379: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
14383: LD_VAR 0 1
14387: PPUSH
14388: LD_INT 1
14390: PPUSH
14391: CALL_OW 183
// AddComExitBuilding ( i ) ;
14395: LD_VAR 0 1
14399: PPUSH
14400: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
14404: LD_VAR 0 1
14408: PPUSH
14409: LD_INT 257
14411: PPUSH
14412: LD_INT 121
14414: PPUSH
14415: CALL_OW 171
// end ;
14419: GO 14344
14421: POP
14422: POP
// Wait ( 1 1$00 ) ;
14423: LD_INT 2100
14425: PPUSH
14426: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
14430: LD_ADDR_VAR 0 3
14434: PUSH
14435: LD_EXP 41
14439: PUSH
14440: LD_EXP 42
14444: ADD
14445: PUSH
14446: LD_EXP 6
14450: ADD
14451: PUSH
14452: LD_EXP 6
14456: PPUSH
14457: LD_INT 21
14459: PUSH
14460: LD_INT 2
14462: PUSH
14463: EMPTY
14464: LIST
14465: LIST
14466: PPUSH
14467: CALL_OW 72
14471: DIFF
14472: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
14473: LD_VAR 0 3
14477: PPUSH
14478: LD_INT 248
14480: PPUSH
14481: LD_INT 85
14483: PPUSH
14484: CALL_OW 111
// AddComHold ( filter ) ;
14488: LD_VAR 0 3
14492: PPUSH
14493: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
14497: LD_INT 35
14499: PPUSH
14500: CALL_OW 67
// until cornel_attack ;
14504: LD_EXP 9
14508: IFFALSE 14497
// ComAgressiveMove ( filter , 209 , 63 ) ;
14510: LD_VAR 0 3
14514: PPUSH
14515: LD_INT 209
14517: PPUSH
14518: LD_INT 63
14520: PPUSH
14521: CALL_OW 114
// if Bierezov then
14525: LD_EXP 42
14529: IFFALSE 14619
// begin filter := filter diff Bierezov ;
14531: LD_ADDR_VAR 0 3
14535: PUSH
14536: LD_VAR 0 3
14540: PUSH
14541: LD_EXP 42
14545: DIFF
14546: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
14547: LD_EXP 42
14551: PPUSH
14552: LD_INT 6
14554: PPUSH
14555: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
14559: LD_EXP 42
14563: PPUSH
14564: LD_INT 235
14566: PPUSH
14567: LD_INT 60
14569: PPUSH
14570: CALL_OW 111
// AddComHold ( Bierezov ) ;
14574: LD_EXP 42
14578: PPUSH
14579: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
14583: LD_EXP 42
14587: PPUSH
14588: LD_INT 350
14590: PPUSH
14591: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
14595: LD_EXP 42
14599: PPUSH
14600: LD_INT 198
14602: PPUSH
14603: LD_INT 28
14605: PPUSH
14606: CALL_OW 171
// AddComHold ( Bierezov ) ;
14610: LD_EXP 42
14614: PPUSH
14615: CALL_OW 200
// end ; end ; end_of_file
14619: PPOPN 3
14621: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
14622: LD_EXP 50
14626: PUSH
14627: LD_EXP 29
14631: NOT
14632: AND
14633: PUSH
14634: LD_EXP 30
14638: NOT
14639: AND
14640: IFFALSE 15090
14642: GO 14644
14644: DISABLE
14645: LD_INT 0
14647: PPUSH
14648: PPUSH
14649: PPUSH
14650: PPUSH
// begin enable ;
14651: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14652: LD_ADDR_VAR 0 4
14656: PUSH
14657: LD_INT 81
14659: PUSH
14660: LD_INT 3
14662: PUSH
14663: EMPTY
14664: LIST
14665: LIST
14666: PPUSH
14667: CALL_OW 69
14671: ST_TO_ADDR
// for i = 1 to ru_patrol do
14672: LD_ADDR_VAR 0 2
14676: PUSH
14677: DOUBLE
14678: LD_INT 1
14680: DEC
14681: ST_TO_ADDR
14682: LD_EXP 50
14686: PUSH
14687: FOR_TO
14688: IFFALSE 15088
// begin un := ru_patrol [ i ] ;
14690: LD_ADDR_VAR 0 1
14694: PUSH
14695: LD_EXP 50
14699: PUSH
14700: LD_VAR 0 2
14704: ARRAY
14705: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14706: LD_VAR 0 1
14710: PPUSH
14711: LD_INT 13
14713: PPUSH
14714: CALL_OW 308
14718: IFFALSE 14823
// begin if not ru_alert then
14720: LD_EXP 57
14724: NOT
14725: IFFALSE 14735
// ru_alert := true ;
14727: LD_ADDR_EXP 57
14731: PUSH
14732: LD_INT 1
14734: ST_TO_ADDR
// if not See ( 1 , un ) then
14735: LD_INT 1
14737: PPUSH
14738: LD_VAR 0 1
14742: PPUSH
14743: CALL_OW 292
14747: NOT
14748: IFFALSE 14762
// SetLives ( un , 1000 ) ;
14750: LD_VAR 0 1
14754: PPUSH
14755: LD_INT 1000
14757: PPUSH
14758: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
14762: LD_ADDR_EXP 50
14766: PUSH
14767: LD_EXP 50
14771: PUSH
14772: LD_VAR 0 1
14776: DIFF
14777: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
14778: LD_VAR 0 1
14782: PPUSH
14783: LD_INT 22
14785: PUSH
14786: LD_INT 3
14788: PUSH
14789: EMPTY
14790: LIST
14791: LIST
14792: PUSH
14793: LD_INT 30
14795: PUSH
14796: LD_INT 4
14798: PUSH
14799: EMPTY
14800: LIST
14801: LIST
14802: PUSH
14803: EMPTY
14804: LIST
14805: LIST
14806: PPUSH
14807: CALL_OW 69
14811: PPUSH
14812: CALL 1031 0 1
14816: PPUSH
14817: CALL_OW 120
// continue ;
14821: GO 14687
// end ; if IsOk ( un ) and not HasTask ( un ) then
14823: LD_VAR 0 1
14827: PPUSH
14828: CALL_OW 302
14832: PUSH
14833: LD_VAR 0 1
14837: PPUSH
14838: CALL_OW 314
14842: NOT
14843: AND
14844: IFFALSE 14937
// begin for j = 1 to ru_firepoints_south [ i ] do
14846: LD_ADDR_VAR 0 3
14850: PUSH
14851: DOUBLE
14852: LD_INT 1
14854: DEC
14855: ST_TO_ADDR
14856: LD_EXP 56
14860: PUSH
14861: LD_VAR 0 2
14865: ARRAY
14866: PUSH
14867: FOR_TO
14868: IFFALSE 14935
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
14870: LD_VAR 0 1
14874: PPUSH
14875: LD_EXP 56
14879: PUSH
14880: LD_VAR 0 2
14884: ARRAY
14885: PUSH
14886: LD_VAR 0 3
14890: ARRAY
14891: PUSH
14892: LD_INT 1
14894: ARRAY
14895: PPUSH
14896: LD_EXP 56
14900: PUSH
14901: LD_VAR 0 2
14905: ARRAY
14906: PUSH
14907: LD_VAR 0 3
14911: ARRAY
14912: PUSH
14913: LD_INT 2
14915: ARRAY
14916: PPUSH
14917: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
14921: LD_VAR 0 1
14925: PPUSH
14926: LD_INT 70
14928: PPUSH
14929: CALL_OW 202
// end ;
14933: GO 14867
14935: POP
14936: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
14937: LD_VAR 0 1
14941: PPUSH
14942: CALL_OW 256
14946: PUSH
14947: LD_INT 700
14949: LESS
14950: PUSH
14951: LD_VAR 0 1
14955: PPUSH
14956: LD_INT 13
14958: PPUSH
14959: CALL_OW 308
14963: NOT
14964: AND
14965: IFFALSE 15017
// begin ComMoveToArea ( un , retreatArea ) ;
14967: LD_VAR 0 1
14971: PPUSH
14972: LD_INT 13
14974: PPUSH
14975: CALL_OW 113
// if not ru_alert_xy then
14979: LD_EXP 58
14983: NOT
14984: IFFALSE 15015
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
14986: LD_ADDR_EXP 58
14990: PUSH
14991: LD_VAR 0 1
14995: PPUSH
14996: CALL_OW 250
15000: PUSH
15001: LD_VAR 0 1
15005: PPUSH
15006: CALL_OW 251
15010: PUSH
15011: EMPTY
15012: LIST
15013: LIST
15014: ST_TO_ADDR
// end else
15015: GO 15086
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15017: LD_VAR 0 1
15021: PPUSH
15022: LD_VAR 0 4
15026: PPUSH
15027: LD_VAR 0 1
15031: PPUSH
15032: CALL_OW 74
15036: PPUSH
15037: CALL_OW 296
15041: PUSH
15042: LD_INT 9
15044: LESS
15045: PUSH
15046: LD_VAR 0 1
15050: PPUSH
15051: CALL_OW 256
15055: PUSH
15056: LD_INT 500
15058: GREATER
15059: AND
15060: IFFALSE 15086
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15062: LD_VAR 0 1
15066: PPUSH
15067: LD_VAR 0 4
15071: PPUSH
15072: LD_VAR 0 1
15076: PPUSH
15077: CALL_OW 74
15081: PPUSH
15082: CALL_OW 115
// end ;
15086: GO 14687
15088: POP
15089: POP
// end ;
15090: PPOPN 4
15092: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
15093: LD_EXP 57
15097: PUSH
15098: LD_EXP 58
15102: AND
15103: PUSH
15104: LD_EXP 29
15108: NOT
15109: AND
15110: PUSH
15111: LD_EXP 30
15115: NOT
15116: AND
15117: IFFALSE 15327
15119: GO 15121
15121: DISABLE
15122: LD_INT 0
15124: PPUSH
15125: PPUSH
// begin enable ;
15126: ENABLE
// if not ru_vehicles then
15127: LD_EXP 53
15131: NOT
15132: IFFALSE 15136
// exit ;
15134: GO 15327
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15136: LD_ADDR_VAR 0 2
15140: PUSH
15141: LD_INT 81
15143: PUSH
15144: LD_INT 3
15146: PUSH
15147: EMPTY
15148: LIST
15149: LIST
15150: PPUSH
15151: CALL_OW 69
15155: ST_TO_ADDR
// if ru_vehicles then
15156: LD_EXP 53
15160: IFFALSE 15327
// begin for i in ru_vehicles do
15162: LD_ADDR_VAR 0 1
15166: PUSH
15167: LD_EXP 53
15171: PUSH
15172: FOR_IN
15173: IFFALSE 15325
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
15175: LD_VAR 0 1
15179: PPUSH
15180: CALL_OW 302
15184: PUSH
15185: LD_VAR 0 1
15189: PPUSH
15190: LD_VAR 0 2
15194: PPUSH
15195: LD_VAR 0 1
15199: PPUSH
15200: CALL_OW 74
15204: PPUSH
15205: CALL_OW 296
15209: PUSH
15210: LD_INT 9
15212: LESS
15213: AND
15214: IFFALSE 15240
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15216: LD_VAR 0 1
15220: PPUSH
15221: LD_VAR 0 2
15225: PPUSH
15226: LD_VAR 0 1
15230: PPUSH
15231: CALL_OW 74
15235: PPUSH
15236: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
15240: LD_VAR 0 1
15244: PPUSH
15245: CALL_OW 314
15249: NOT
15250: PUSH
15251: LD_VAR 0 1
15255: PPUSH
15256: CALL_OW 302
15260: AND
15261: PUSH
15262: LD_VAR 0 1
15266: PPUSH
15267: LD_EXP 58
15271: PUSH
15272: LD_INT 1
15274: ARRAY
15275: PPUSH
15276: LD_EXP 58
15280: PUSH
15281: LD_INT 2
15283: ARRAY
15284: PPUSH
15285: CALL_OW 297
15289: PUSH
15290: LD_INT 10
15292: GREATER
15293: AND
15294: IFFALSE 15323
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
15296: LD_VAR 0 1
15300: PPUSH
15301: LD_EXP 58
15305: PUSH
15306: LD_INT 1
15308: ARRAY
15309: PPUSH
15310: LD_EXP 58
15314: PUSH
15315: LD_INT 2
15317: ARRAY
15318: PPUSH
15319: CALL_OW 114
// end ;
15323: GO 15172
15325: POP
15326: POP
// end ; end ;
15327: PPOPN 2
15329: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
15330: LD_EXP 58
15334: PUSH
15335: LD_EXP 57
15339: AND
15340: PUSH
15341: LD_INT 3
15343: PPUSH
15344: CALL_OW 463
15348: NOT
15349: AND
15350: PUSH
15351: LD_EXP 29
15355: NOT
15356: AND
15357: PUSH
15358: LD_EXP 30
15362: NOT
15363: AND
15364: IFFALSE 15459
15366: GO 15368
15368: DISABLE
15369: LD_INT 0
15371: PPUSH
// begin enable ;
15372: ENABLE
// ru_alert_xy := false ;
15373: LD_ADDR_EXP 58
15377: PUSH
15378: LD_INT 0
15380: ST_TO_ADDR
// ru_alert := false ;
15381: LD_ADDR_EXP 57
15385: PUSH
15386: LD_INT 0
15388: ST_TO_ADDR
// if ru_vehicles then
15389: LD_EXP 53
15393: IFFALSE 15459
// for i in ru_vehicles do
15395: LD_ADDR_VAR 0 1
15399: PUSH
15400: LD_EXP 53
15404: PUSH
15405: FOR_IN
15406: IFFALSE 15457
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
15408: LD_VAR 0 1
15412: PPUSH
15413: CALL_OW 302
15417: PUSH
15418: LD_VAR 0 1
15422: PPUSH
15423: LD_INT 89
15425: PPUSH
15426: LD_INT 36
15428: PPUSH
15429: CALL_OW 297
15433: PUSH
15434: LD_INT 10
15436: GREATER
15437: AND
15438: IFFALSE 15455
// ComMoveXY ( i , 89 , 36 ) ;
15440: LD_VAR 0 1
15444: PPUSH
15445: LD_INT 89
15447: PPUSH
15448: LD_INT 36
15450: PPUSH
15451: CALL_OW 111
15455: GO 15405
15457: POP
15458: POP
// end ;
15459: PPOPN 1
15461: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
15462: LD_EXP 52
15466: PUSH
15467: LD_EXP 29
15471: NOT
15472: AND
15473: PUSH
15474: LD_EXP 30
15478: NOT
15479: AND
15480: IFFALSE 15764
15482: GO 15484
15484: DISABLE
15485: LD_INT 0
15487: PPUSH
15488: PPUSH
15489: PPUSH
// begin enable ;
15490: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15491: LD_ADDR_VAR 0 3
15495: PUSH
15496: LD_INT 81
15498: PUSH
15499: LD_INT 3
15501: PUSH
15502: EMPTY
15503: LIST
15504: LIST
15505: PPUSH
15506: CALL_OW 69
15510: ST_TO_ADDR
// for i = 1 to ru_forest do
15511: LD_ADDR_VAR 0 1
15515: PUSH
15516: DOUBLE
15517: LD_INT 1
15519: DEC
15520: ST_TO_ADDR
15521: LD_EXP 52
15525: PUSH
15526: FOR_TO
15527: IFFALSE 15762
// begin un := ru_forest [ i ] ;
15529: LD_ADDR_VAR 0 2
15533: PUSH
15534: LD_EXP 52
15538: PUSH
15539: LD_VAR 0 1
15543: ARRAY
15544: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15545: LD_VAR 0 2
15549: PPUSH
15550: LD_INT 13
15552: PPUSH
15553: CALL_OW 308
15557: IFFALSE 15647
// begin if not See ( 1 , un ) then
15559: LD_INT 1
15561: PPUSH
15562: LD_VAR 0 2
15566: PPUSH
15567: CALL_OW 292
15571: NOT
15572: IFFALSE 15586
// SetLives ( un , 1000 ) ;
15574: LD_VAR 0 2
15578: PPUSH
15579: LD_INT 1000
15581: PPUSH
15582: CALL_OW 234
// ru_forest := ru_forest diff un ;
15586: LD_ADDR_EXP 52
15590: PUSH
15591: LD_EXP 52
15595: PUSH
15596: LD_VAR 0 2
15600: DIFF
15601: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15602: LD_VAR 0 2
15606: PPUSH
15607: LD_INT 22
15609: PUSH
15610: LD_INT 3
15612: PUSH
15613: EMPTY
15614: LIST
15615: LIST
15616: PUSH
15617: LD_INT 30
15619: PUSH
15620: LD_INT 4
15622: PUSH
15623: EMPTY
15624: LIST
15625: LIST
15626: PUSH
15627: EMPTY
15628: LIST
15629: LIST
15630: PPUSH
15631: CALL_OW 69
15635: PPUSH
15636: CALL 1031 0 1
15640: PPUSH
15641: CALL_OW 120
// continue ;
15645: GO 15526
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15647: LD_VAR 0 2
15651: PPUSH
15652: CALL_OW 256
15656: PUSH
15657: LD_INT 700
15659: LESS
15660: PUSH
15661: LD_VAR 0 2
15665: PPUSH
15666: LD_INT 13
15668: PPUSH
15669: CALL_OW 308
15673: NOT
15674: AND
15675: IFFALSE 15691
// ComMoveToArea ( un , retreatArea ) else
15677: LD_VAR 0 2
15681: PPUSH
15682: LD_INT 13
15684: PPUSH
15685: CALL_OW 113
15689: GO 15760
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15691: LD_VAR 0 2
15695: PPUSH
15696: LD_VAR 0 3
15700: PPUSH
15701: LD_VAR 0 2
15705: PPUSH
15706: CALL_OW 74
15710: PPUSH
15711: CALL_OW 296
15715: PUSH
15716: LD_INT 9
15718: LESS
15719: PUSH
15720: LD_VAR 0 2
15724: PPUSH
15725: CALL_OW 256
15729: PUSH
15730: LD_INT 500
15732: GREATER
15733: AND
15734: IFFALSE 15760
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15736: LD_VAR 0 2
15740: PPUSH
15741: LD_VAR 0 3
15745: PPUSH
15746: LD_VAR 0 2
15750: PPUSH
15751: CALL_OW 74
15755: PPUSH
15756: CALL_OW 115
// end ;
15760: GO 15526
15762: POP
15763: POP
// end ;
15764: PPOPN 3
15766: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
15767: LD_EXP 30
15771: NOT
15772: IFFALSE 15893
15774: GO 15776
15776: DISABLE
15777: LD_INT 0
15779: PPUSH
15780: PPUSH
// begin enable ;
15781: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
15782: LD_ADDR_VAR 0 2
15786: PUSH
15787: LD_INT 22
15789: PUSH
15790: LD_INT 3
15792: PUSH
15793: EMPTY
15794: LIST
15795: LIST
15796: PUSH
15797: LD_INT 21
15799: PUSH
15800: LD_INT 3
15802: PUSH
15803: EMPTY
15804: LIST
15805: LIST
15806: PUSH
15807: EMPTY
15808: LIST
15809: LIST
15810: PPUSH
15811: CALL_OW 69
15815: ST_TO_ADDR
// if filter then
15816: LD_VAR 0 2
15820: IFFALSE 15893
// for i in filter do
15822: LD_ADDR_VAR 0 1
15826: PUSH
15827: LD_VAR 0 2
15831: PUSH
15832: FOR_IN
15833: IFFALSE 15891
// if GetLives ( i ) < 990 then
15835: LD_VAR 0 1
15839: PPUSH
15840: CALL_OW 256
15844: PUSH
15845: LD_INT 990
15847: LESS
15848: IFFALSE 15889
// begin ru_alert := true ;
15850: LD_ADDR_EXP 57
15854: PUSH
15855: LD_INT 1
15857: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
15858: LD_ADDR_EXP 58
15862: PUSH
15863: LD_VAR 0 1
15867: PPUSH
15868: CALL_OW 250
15872: PUSH
15873: LD_VAR 0 1
15877: PPUSH
15878: CALL_OW 251
15882: PUSH
15883: EMPTY
15884: LIST
15885: LIST
15886: ST_TO_ADDR
// break ;
15887: GO 15891
// end ;
15889: GO 15832
15891: POP
15892: POP
// end ;
15893: PPOPN 2
15895: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
15896: LD_EXP 29
15900: IFFALSE 16049
15902: GO 15904
15904: DISABLE
15905: LD_INT 0
15907: PPUSH
15908: PPUSH
15909: PPUSH
15910: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
15911: LD_ADDR_VAR 0 4
15915: PUSH
15916: LD_EXP 53
15920: PUSH
15921: LD_EXP 52
15925: ADD
15926: PUSH
15927: LD_EXP 50
15931: ADD
15932: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
15933: LD_ADDR_VAR 0 3
15937: PUSH
15938: LD_INT 3
15940: PPUSH
15941: LD_INT 81
15943: PUSH
15944: LD_INT 3
15946: PUSH
15947: EMPTY
15948: LIST
15949: LIST
15950: PPUSH
15951: CALL_OW 70
15955: ST_TO_ADDR
// if filter and enemy then
15956: LD_VAR 0 4
15960: PUSH
15961: LD_VAR 0 3
15965: AND
15966: IFFALSE 16049
// repeat wait ( 0 0$01 ) ;
15968: LD_INT 35
15970: PPUSH
15971: CALL_OW 67
// for i in filter do
15975: LD_ADDR_VAR 0 1
15979: PUSH
15980: LD_VAR 0 4
15984: PUSH
15985: FOR_IN
15986: IFFALSE 16014
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15988: LD_VAR 0 1
15992: PPUSH
15993: LD_VAR 0 3
15997: PPUSH
15998: LD_VAR 0 1
16002: PPUSH
16003: CALL_OW 74
16007: PPUSH
16008: CALL_OW 115
// end ;
16012: GO 15985
16014: POP
16015: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
16016: LD_INT 3
16018: PPUSH
16019: LD_INT 81
16021: PUSH
16022: LD_INT 3
16024: PUSH
16025: EMPTY
16026: LIST
16027: LIST
16028: PPUSH
16029: CALL_OW 70
16033: PUSH
16034: LD_INT 0
16036: EQUAL
16037: PUSH
16038: LD_VAR 0 4
16042: PUSH
16043: LD_INT 0
16045: EQUAL
16046: OR
16047: IFFALSE 15968
// end ;
16049: PPOPN 4
16051: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) do var i ;
16052: LD_EXP 25
16056: PUSH
16057: LD_INT 22
16059: PUSH
16060: LD_INT 4
16062: PUSH
16063: EMPTY
16064: LIST
16065: LIST
16066: PUSH
16067: LD_INT 30
16069: PUSH
16070: LD_INT 4
16072: PUSH
16073: EMPTY
16074: LIST
16075: LIST
16076: PUSH
16077: EMPTY
16078: LIST
16079: LIST
16080: PPUSH
16081: CALL_OW 69
16085: AND
16086: IFFALSE 16135
16088: GO 16090
16090: DISABLE
16091: LD_INT 0
16093: PPUSH
// begin if not ru_cornel_attack then
16094: LD_EXP 55
16098: NOT
16099: IFFALSE 16103
// exit ;
16101: GO 16135
// for i in ru_cornel_attack do
16103: LD_ADDR_VAR 0 1
16107: PUSH
16108: LD_EXP 55
16112: PUSH
16113: FOR_IN
16114: IFFALSE 16133
// ComAgressiveMove ( i , 258 , 119 ) ;
16116: LD_VAR 0 1
16120: PPUSH
16121: LD_INT 258
16123: PPUSH
16124: LD_INT 119
16126: PPUSH
16127: CALL_OW 114
16131: GO 16113
16133: POP
16134: POP
// end ; end_of_file
16135: PPOPN 1
16137: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
16138: LD_EXP 5
16142: PUSH
16143: LD_EXP 9
16147: NOT
16148: AND
16149: PUSH
16150: LD_EXP 19
16154: AND
16155: IFFALSE 16267
16157: GO 16159
16159: DISABLE
16160: LD_INT 0
16162: PPUSH
// begin enable ;
16163: ENABLE
// crates_counter := crates_counter - 50 ;
16164: LD_ADDR_EXP 19
16168: PUSH
16169: LD_EXP 19
16173: PUSH
16174: LD_INT 50
16176: MINUS
16177: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
16178: LD_INT 8
16180: PPUSH
16181: LD_INT 2
16183: PPUSH
16184: LD_INT 5
16186: PPUSH
16187: CALL_OW 12
16191: PPUSH
16192: LD_INT 1
16194: PPUSH
16195: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
16199: LD_INT 1785
16201: PPUSH
16202: LD_INT 2345
16204: PPUSH
16205: CALL_OW 12
16209: PPUSH
16210: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
16214: LD_ADDR_VAR 0 1
16218: PUSH
16219: LD_INT 1
16221: PPUSH
16222: LD_OWVAR 67
16226: PUSH
16227: LD_INT 2
16229: PLUS
16230: PPUSH
16231: CALL_OW 12
16235: ST_TO_ADDR
// if r < 3 then
16236: LD_VAR 0 1
16240: PUSH
16241: LD_INT 3
16243: LESS
16244: IFFALSE 16267
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
16246: LD_INT 4
16248: PPUSH
16249: LD_INT 1
16251: PPUSH
16252: LD_INT 5
16254: PPUSH
16255: CALL_OW 12
16259: PPUSH
16260: LD_INT 1
16262: PPUSH
16263: CALL_OW 55
// end ;
16267: PPOPN 1
16269: END
// every 0 0$01 trigger cornel_active do
16270: LD_EXP 8
16274: IFFALSE 16363
16276: GO 16278
16278: DISABLE
// begin Wait ( 0 0$03 ) ;
16279: LD_INT 105
16281: PPUSH
16282: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16286: LD_INT 2
16288: PPUSH
16289: LD_INT 5
16291: PPUSH
16292: CALL_OW 12
16296: PPUSH
16297: LD_INT 10
16299: PPUSH
16300: LD_INT 1
16302: PPUSH
16303: CALL_OW 55
// Wait ( 0 0$13 ) ;
16307: LD_INT 455
16309: PPUSH
16310: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16314: LD_INT 2
16316: PPUSH
16317: LD_INT 5
16319: PPUSH
16320: CALL_OW 12
16324: PPUSH
16325: LD_INT 10
16327: PPUSH
16328: LD_INT 1
16330: PPUSH
16331: CALL_OW 55
// Wait ( 0 0$16 ) ;
16335: LD_INT 560
16337: PPUSH
16338: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
16342: LD_INT 2
16344: PPUSH
16345: LD_INT 5
16347: PPUSH
16348: CALL_OW 12
16352: PPUSH
16353: LD_INT 10
16355: PPUSH
16356: LD_INT 1
16358: PPUSH
16359: CALL_OW 55
// end ; end_of_file
16363: END
// every 0 0$01 trigger cornel_prepared do
16364: LD_EXP 11
16368: IFFALSE 16427
16370: GO 16372
16372: DISABLE
// begin enable ;
16373: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
16374: LD_ADDR_OWVAR 47
16378: PUSH
16379: LD_STRING #Am03-1
16381: PUSH
16382: LD_EXP 10
16386: PUSH
16387: EMPTY
16388: LIST
16389: LIST
16390: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
16391: LD_ADDR_EXP 10
16395: PUSH
16396: LD_EXP 10
16400: PPUSH
16401: LD_STRING -
16403: PPUSH
16404: CALL 1101 0 2
16408: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
16409: LD_EXP 10
16413: PUSH
16414: LD_INT 0
16416: EQUAL
16417: IFFALSE 16427
// begin Display_Strings := [ ] ;
16419: LD_ADDR_OWVAR 47
16423: PUSH
16424: EMPTY
16425: ST_TO_ADDR
// disable ;
16426: DISABLE
// end ; end ;
16427: END
// every 0 0$01 trigger debug and debug_strings do
16428: LD_EXP 1
16432: PUSH
16433: LD_OWVAR 48
16437: AND
16438: IFFALSE 16454
16440: GO 16442
16442: DISABLE
// begin enable ;
16443: ENABLE
// Display_Strings := debug_strings ;
16444: LD_ADDR_OWVAR 47
16448: PUSH
16449: LD_OWVAR 48
16453: ST_TO_ADDR
// end ; end_of_file
16454: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
16455: LD_VAR 0 1
16459: PPUSH
16460: CALL_OW 255
16464: PUSH
16465: LD_INT 1
16467: EQUAL
16468: PUSH
16469: LD_EXP 13
16473: NOT
16474: AND
16475: IFFALSE 16485
// solar_builded := true ;
16477: LD_ADDR_EXP 13
16481: PUSH
16482: LD_INT 1
16484: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
16485: LD_VAR 0 1
16489: PPUSH
16490: CALL_OW 255
16494: PUSH
16495: LD_INT 1
16497: EQUAL
16498: PUSH
16499: LD_EXP 27
16503: AND
16504: IFFALSE 16537
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
16506: LD_ADDR_EXP 27
16510: PUSH
16511: LD_EXP 27
16515: PUSH
16516: LD_INT 1750
16518: PUSH
16519: LD_INT 1400
16521: PUSH
16522: LD_INT 1225
16524: PUSH
16525: EMPTY
16526: LIST
16527: LIST
16528: LIST
16529: PUSH
16530: LD_OWVAR 67
16534: ARRAY
16535: PLUS
16536: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
16537: LD_VAR 0 1
16541: PPUSH
16542: CALL_OW 255
16546: PUSH
16547: LD_INT 3
16549: EQUAL
16550: IFFALSE 16568
// ru_vehicles := ru_vehicles ^ veh ;
16552: LD_ADDR_EXP 53
16556: PUSH
16557: LD_EXP 53
16561: PUSH
16562: LD_VAR 0 1
16566: ADD
16567: ST_TO_ADDR
// end ;
16568: PPOPN 2
16570: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
16571: LD_VAR 0 1
16575: PUSH
16576: LD_EXP 50
16580: IN
16581: IFFALSE 16599
// ru_patrol := ru_patrol diff un ;
16583: LD_ADDR_EXP 50
16587: PUSH
16588: LD_EXP 50
16592: PUSH
16593: LD_VAR 0 1
16597: DIFF
16598: ST_TO_ADDR
// if un in ru_forest then
16599: LD_VAR 0 1
16603: PUSH
16604: LD_EXP 52
16608: IN
16609: IFFALSE 16627
// ru_forest := ru_forest diff un ;
16611: LD_ADDR_EXP 52
16615: PUSH
16616: LD_EXP 52
16620: PUSH
16621: LD_VAR 0 1
16625: DIFF
16626: ST_TO_ADDR
// if un in ru_vehicles then
16627: LD_VAR 0 1
16631: PUSH
16632: LD_EXP 53
16636: IN
16637: IFFALSE 16712
// begin ru_vehicles := ru_vehicles diff un ;
16639: LD_ADDR_EXP 53
16643: PUSH
16644: LD_EXP 53
16648: PUSH
16649: LD_VAR 0 1
16653: DIFF
16654: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
16655: LD_ADDR_EXP 54
16659: PUSH
16660: LD_EXP 54
16664: PUSH
16665: LD_VAR 0 1
16669: PPUSH
16670: CALL_OW 265
16674: PUSH
16675: LD_VAR 0 1
16679: PPUSH
16680: CALL_OW 262
16684: PUSH
16685: LD_VAR 0 1
16689: PPUSH
16690: CALL_OW 263
16694: PUSH
16695: LD_VAR 0 1
16699: PPUSH
16700: CALL_OW 264
16704: PUSH
16705: EMPTY
16706: LIST
16707: LIST
16708: LIST
16709: LIST
16710: ADD
16711: ST_TO_ADDR
// end ; if un = JMM then
16712: LD_VAR 0 1
16716: PUSH
16717: LD_EXP 34
16721: EQUAL
16722: IFFALSE 16731
// YouLost ( 0 ) ;
16724: LD_STRING 0
16726: PPUSH
16727: CALL_OW 104
// if un = us_dep_west then
16731: LD_VAR 0 1
16735: PUSH
16736: LD_INT 1
16738: EQUAL
16739: IFFALSE 16748
// YouLost ( 2 ) ;
16741: LD_STRING 2
16743: PPUSH
16744: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
16748: LD_VAR 0 1
16752: PPUSH
16753: CALL_OW 255
16757: PUSH
16758: LD_INT 8
16760: EQUAL
16761: PUSH
16762: LD_EXP 5
16766: NOT
16767: AND
16768: IFFALSE 16777
// YouLost ( 4 ) ;
16770: LD_STRING 4
16772: PPUSH
16773: CALL_OW 104
// if un in jmm_units then
16777: LD_VAR 0 1
16781: PUSH
16782: LD_EXP 4
16786: IN
16787: IFFALSE 16803
// lose_counter := lose_counter + 1 ;
16789: LD_ADDR_EXP 32
16793: PUSH
16794: LD_EXP 32
16798: PUSH
16799: LD_INT 1
16801: PLUS
16802: ST_TO_ADDR
// end ;
16803: PPOPN 1
16805: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
16806: LD_INT 0
16808: PPUSH
16809: PPUSH
// begin if GetSide ( driver ) = 3 then
16810: LD_VAR 0 1
16814: PPUSH
16815: CALL_OW 255
16819: PUSH
16820: LD_INT 3
16822: EQUAL
16823: IFFALSE 16901
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
16825: LD_ADDR_VAR 0 6
16829: PUSH
16830: LD_INT 22
16832: PUSH
16833: LD_INT 3
16835: PUSH
16836: EMPTY
16837: LIST
16838: LIST
16839: PUSH
16840: LD_INT 30
16842: PUSH
16843: LD_INT 3
16845: PUSH
16846: EMPTY
16847: LIST
16848: LIST
16849: PUSH
16850: EMPTY
16851: LIST
16852: LIST
16853: PPUSH
16854: CALL_OW 69
16858: PPUSH
16859: CALL 1031 0 1
16863: ST_TO_ADDR
// if place then
16864: LD_VAR 0 6
16868: IFFALSE 16886
// ComEnterUnit ( driver , place ) else
16870: LD_VAR 0 1
16874: PPUSH
16875: LD_VAR 0 6
16879: PPUSH
16880: CALL_OW 120
16884: GO 16901
// ComMoveXY ( driver , 70 , 22 ) ;
16886: LD_VAR 0 1
16890: PPUSH
16891: LD_INT 70
16893: PPUSH
16894: LD_INT 22
16896: PPUSH
16897: CALL_OW 111
// end ; end ;
16901: PPOPN 6
16903: END
// every 0 0$01 trigger not game_end and ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
16904: LD_EXP 31
16908: NOT
16909: PUSH
16910: LD_INT 22
16912: PUSH
16913: LD_INT 1
16915: PUSH
16916: EMPTY
16917: LIST
16918: LIST
16919: PUSH
16920: LD_INT 21
16922: PUSH
16923: LD_INT 1
16925: PUSH
16926: EMPTY
16927: LIST
16928: LIST
16929: PUSH
16930: EMPTY
16931: LIST
16932: LIST
16933: PPUSH
16934: CALL_OW 69
16938: PUSH
16939: LD_INT 22
16941: PUSH
16942: LD_INT 8
16944: PUSH
16945: EMPTY
16946: LIST
16947: LIST
16948: PUSH
16949: LD_INT 21
16951: PUSH
16952: LD_INT 1
16954: PUSH
16955: EMPTY
16956: LIST
16957: LIST
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: PPUSH
16963: CALL_OW 69
16967: ADD
16968: PUSH
16969: LD_INT 5
16971: LESS
16972: AND
16973: IFFALSE 16985
16975: GO 16977
16977: DISABLE
// YouLost ( 1 ) ;
16978: LD_STRING 1
16980: PPUSH
16981: CALL_OW 104
16985: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
16986: LD_INT 1
16988: PPUSH
16989: CALL_OW 255
16993: PUSH
16994: LD_INT 3
16996: EQUAL
16997: IFFALSE 17009
16999: GO 17001
17001: DISABLE
// YouLost ( 3 ) ;
17002: LD_STRING 3
17004: PPUSH
17005: CALL_OW 104
17009: END
