// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 250 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 338 0 0
// PrepareRussian ;
  22: CALL 2645 0 0
// PrepareAmerican ;
  26: CALL 902 0 0
// PrepareCornell ;
  30: CALL 1926 0 0
// PrepareWesternBase ;
  34: CALL 2152 0 0
// Action ;
  38: CALL 3304 0 0
// end ;
  42: END
// export debug ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , veh_on_meta ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// jmm_units := 0 ;
  54: LD_ADDR_EXP 2
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// cornel_units := 0 ;
  62: LD_ADDR_EXP 4
  66: PUSH
  67: LD_INT 0
  69: ST_TO_ADDR
// bierezov_exist := false ;
  70: LD_ADDR_EXP 5
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// jmm_on_west := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// cornel_active := false ;
  86: LD_ADDR_EXP 6
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// cornel_attack := false ;
  94: LD_ADDR_EXP 7
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_prepared := false ;
 102: LD_ADDR_EXP 9
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 110: LD_ADDR_EXP 8
 114: PUSH
 115: LD_INT 4200
 117: ST_TO_ADDR
// frank_can_return := false ;
 118: LD_ADDR_EXP 10
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// solar_builded := false ;
 126: LD_ADDR_EXP 11
 130: PUSH
 131: LD_INT 0
 133: ST_TO_ADDR
// frank_send_to_scout := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// jmm_in_veh := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// bobby_in_veh := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// cyrus_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// lisa_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// crates_counter := [ 1200 , 1000 , 800 ] [ Difficulty ] ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 1200
 181: PUSH
 182: LD_INT 1000
 184: PUSH
 185: LD_INT 800
 187: PUSH
 188: EMPTY
 189: LIST
 190: LIST
 191: LIST
 192: PUSH
 193: LD_OWVAR 67
 197: ARRAY
 198: ST_TO_ADDR
// end_mission_allowed := false ;
 199: LD_ADDR_EXP 18
 203: PUSH
 204: LD_INT 0
 206: ST_TO_ADDR
// save_others := [ ] ;
 207: LD_ADDR_EXP 19
 211: PUSH
 212: EMPTY
 213: ST_TO_ADDR
// save_group := [ ] ;
 214: LD_ADDR_EXP 20
 218: PUSH
 219: EMPTY
 220: ST_TO_ADDR
// show_query := false ;
 221: LD_ADDR_EXP 21
 225: PUSH
 226: LD_INT 0
 228: ST_TO_ADDR
// wait_for_them := false ;
 229: LD_ADDR_EXP 22
 233: PUSH
 234: LD_INT 0
 236: ST_TO_ADDR
// veh_on_meta := false ;
 237: LD_ADDR_EXP 23
 241: PUSH
 242: LD_INT 0
 244: ST_TO_ADDR
// end ;
 245: LD_VAR 0 1
 249: RET
// function SetDiplomacy ; begin
 250: LD_INT 0
 252: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 4
 258: PPUSH
 259: LD_INT 1
 261: PPUSH
 262: LD_INT 1
 264: PPUSH
 265: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 269: LD_INT 1
 271: PPUSH
 272: LD_INT 8
 274: PPUSH
 275: LD_INT 1
 277: PPUSH
 278: LD_INT 1
 280: PPUSH
 281: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 285: LD_INT 3
 287: PPUSH
 288: LD_INT 6
 290: PPUSH
 291: LD_INT 1
 293: PPUSH
 294: LD_INT 1
 296: PPUSH
 297: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 301: LD_INT 4
 303: PPUSH
 304: LD_INT 6
 306: PPUSH
 307: LD_INT 0
 309: PPUSH
 310: LD_INT 1
 312: PPUSH
 313: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 317: LD_INT 3
 319: PPUSH
 320: LD_INT 8
 322: PPUSH
 323: LD_INT 0
 325: PPUSH
 326: LD_INT 1
 328: PPUSH
 329: CALL_OW 80
// end ;
 333: LD_VAR 0 1
 337: RET
// export function DebugMode ; begin
 338: LD_INT 0
 340: PPUSH
// FogOff ( 1 ) ;
 341: LD_INT 1
 343: PPUSH
 344: CALL_OW 344
// end ; end_of_file
 348: LD_VAR 0 1
 352: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 353: LD_INT 0
 355: PPUSH
 356: PPUSH
// if exist_mode then
 357: LD_VAR 0 2
 361: IFFALSE 380
// unit := CreateCharacter ( ident ) else
 363: LD_ADDR_VAR 0 4
 367: PUSH
 368: LD_VAR 0 1
 372: PPUSH
 373: CALL_OW 34
 377: ST_TO_ADDR
 378: GO 395
// unit := NewCharacter ( ident ) ;
 380: LD_ADDR_VAR 0 4
 384: PUSH
 385: LD_VAR 0 1
 389: PPUSH
 390: CALL_OW 25
 394: ST_TO_ADDR
// result := unit ;
 395: LD_ADDR_VAR 0 3
 399: PUSH
 400: LD_VAR 0 4
 404: ST_TO_ADDR
// end ;
 405: LD_VAR 0 3
 409: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 410: LD_INT 0
 412: PPUSH
// uc_side := side ;
 413: LD_ADDR_OWVAR 20
 417: PUSH
 418: LD_VAR 0 1
 422: ST_TO_ADDR
// uc_nation := nation ;
 423: LD_ADDR_OWVAR 21
 427: PUSH
 428: LD_VAR 0 2
 432: ST_TO_ADDR
// vc_chassis := chassis ;
 433: LD_ADDR_OWVAR 37
 437: PUSH
 438: LD_VAR 0 3
 442: ST_TO_ADDR
// vc_engine := engine ;
 443: LD_ADDR_OWVAR 39
 447: PUSH
 448: LD_VAR 0 4
 452: ST_TO_ADDR
// vc_control := control ;
 453: LD_ADDR_OWVAR 38
 457: PUSH
 458: LD_VAR 0 5
 462: ST_TO_ADDR
// vc_weapon := weapon ;
 463: LD_ADDR_OWVAR 40
 467: PUSH
 468: LD_VAR 0 6
 472: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 473: LD_ADDR_OWVAR 41
 477: PUSH
 478: LD_VAR 0 7
 482: ST_TO_ADDR
// result := CreateVehicle ;
 483: LD_ADDR_VAR 0 8
 487: PUSH
 488: CALL_OW 45
 492: ST_TO_ADDR
// end ;
 493: LD_VAR 0 8
 497: RET
// export function SayX ( units , ident ) ; var i ; begin
 498: LD_INT 0
 500: PPUSH
 501: PPUSH
// if not units then
 502: LD_VAR 0 1
 506: NOT
 507: IFFALSE 511
// exit ;
 509: GO 555
// for i in ident do
 511: LD_ADDR_VAR 0 4
 515: PUSH
 516: LD_VAR 0 2
 520: PUSH
 521: FOR_IN
 522: IFFALSE 553
// if IsOk ( i ) then
 524: LD_VAR 0 4
 528: PPUSH
 529: CALL_OW 302
 533: IFFALSE 551
// begin Say ( i , ident ) ;
 535: LD_VAR 0 4
 539: PPUSH
 540: LD_VAR 0 2
 544: PPUSH
 545: CALL_OW 88
// break ;
 549: GO 553
// end ;
 551: GO 521
 553: POP
 554: POP
// end ;
 555: LD_VAR 0 3
 559: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 560: LD_INT 0
 562: PPUSH
 563: PPUSH
 564: PPUSH
 565: PPUSH
// for i = 1 to count do
 566: LD_ADDR_VAR 0 8
 570: PUSH
 571: DOUBLE
 572: LD_INT 1
 574: DEC
 575: ST_TO_ADDR
 576: LD_VAR 0 6
 580: PUSH
 581: FOR_TO
 582: IFFALSE 663
// begin uc_side = side ;
 584: LD_ADDR_OWVAR 20
 588: PUSH
 589: LD_VAR 0 1
 593: ST_TO_ADDR
// uc_nation = nation ;
 594: LD_ADDR_OWVAR 21
 598: PUSH
 599: LD_VAR 0 2
 603: ST_TO_ADDR
// hc_gallery =  ;
 604: LD_ADDR_OWVAR 33
 608: PUSH
 609: LD_STRING 
 611: ST_TO_ADDR
// hc_name =  ;
 612: LD_ADDR_OWVAR 26
 616: PUSH
 617: LD_STRING 
 619: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 620: LD_INT 0
 622: PPUSH
 623: LD_VAR 0 5
 627: PPUSH
 628: LD_VAR 0 4
 632: PPUSH
 633: CALL_OW 380
// un = CreateHuman ;
 637: LD_ADDR_VAR 0 10
 641: PUSH
 642: CALL_OW 44
 646: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 647: LD_VAR 0 10
 651: PPUSH
 652: LD_VAR 0 3
 656: PPUSH
 657: CALL_OW 52
// end ;
 661: GO 581
 663: POP
 664: POP
// end ;
 665: LD_VAR 0 7
 669: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 670: LD_INT 0
 672: PPUSH
 673: PPUSH
 674: PPUSH
// uc_side := GetSide ( b ) ;
 675: LD_ADDR_OWVAR 20
 679: PUSH
 680: LD_VAR 0 2
 684: PPUSH
 685: CALL_OW 255
 689: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 690: LD_ADDR_OWVAR 21
 694: PUSH
 695: LD_VAR 0 2
 699: PPUSH
 700: CALL_OW 248
 704: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 705: LD_INT 0
 707: PPUSH
 708: LD_INT 1
 710: PPUSH
 711: LD_VAR 0 1
 715: PPUSH
 716: CALL_OW 380
// un = CreateHuman ;
 720: LD_ADDR_VAR 0 4
 724: PUSH
 725: CALL_OW 44
 729: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 730: LD_ADDR_VAR 0 5
 734: PUSH
 735: LD_VAR 0 2
 739: PPUSH
 740: CALL_OW 254
 744: PUSH
 745: LD_INT 3
 747: MINUS
 748: ST_TO_ADDR
// if dir < 0 then
 749: LD_VAR 0 5
 753: PUSH
 754: LD_INT 0
 756: LESS
 757: IFFALSE 773
// dir := 6 + dir ;
 759: LD_ADDR_VAR 0 5
 763: PUSH
 764: LD_INT 6
 766: PUSH
 767: LD_VAR 0 5
 771: PLUS
 772: ST_TO_ADDR
// SetDir ( un , dir ) ;
 773: LD_VAR 0 4
 777: PPUSH
 778: LD_VAR 0 5
 782: PPUSH
 783: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 787: LD_VAR 0 4
 791: PPUSH
 792: LD_VAR 0 2
 796: PPUSH
 797: CALL_OW 52
// end ;
 801: LD_VAR 0 3
 805: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 806: LD_INT 0
 808: PPUSH
 809: PPUSH
 810: PPUSH
// result := false ;
 811: LD_ADDR_VAR 0 2
 815: PUSH
 816: LD_INT 0
 818: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 819: LD_ADDR_VAR 0 3
 823: PUSH
 824: LD_INT 22
 826: PUSH
 827: LD_INT 1
 829: PUSH
 830: EMPTY
 831: LIST
 832: LIST
 833: PUSH
 834: LD_INT 34
 836: PUSH
 837: LD_INT 2
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: PPUSH
 848: CALL_OW 69
 852: ST_TO_ADDR
// for i in filter do
 853: LD_ADDR_VAR 0 4
 857: PUSH
 858: LD_VAR 0 3
 862: PUSH
 863: FOR_IN
 864: IFFALSE 895
// if IsDrivenBy ( i ) = unit then
 866: LD_VAR 0 4
 870: PPUSH
 871: CALL_OW 311
 875: PUSH
 876: LD_VAR 0 1
 880: EQUAL
 881: IFFALSE 893
// begin result := true ;
 883: LD_ADDR_VAR 0 2
 887: PUSH
 888: LD_INT 1
 890: ST_TO_ADDR
// break ;
 891: GO 895
// end ;
 893: GO 863
 895: POP
 896: POP
// end ; end_of_file
 897: LD_VAR 0 2
 901: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
 902: LD_INT 0
 904: PPUSH
 905: PPUSH
 906: PPUSH
 907: PPUSH
 908: PPUSH
 909: PPUSH
 910: PPUSH
 911: PPUSH
// uc_side := 4 ;
 912: LD_ADDR_OWVAR 20
 916: PUSH
 917: LD_INT 4
 919: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
 920: LD_ADDR_EXP 33
 924: PUSH
 925: LD_STRING Powell
 927: PPUSH
 928: LD_INT 0
 930: PPUSH
 931: CALL 353 0 2
 935: ST_TO_ADDR
// uc_side := 1 ;
 936: LD_ADDR_OWVAR 20
 940: PUSH
 941: LD_INT 1
 943: ST_TO_ADDR
// uc_nation := 1 ;
 944: LD_ADDR_OWVAR 21
 948: PUSH
 949: LD_INT 1
 951: ST_TO_ADDR
// if debug then
 952: LD_EXP 1
 956: IFFALSE 1086
// begin for i = 1 to 4 do
 958: LD_ADDR_VAR 0 2
 962: PUSH
 963: DOUBLE
 964: LD_INT 1
 966: DEC
 967: ST_TO_ADDR
 968: LD_INT 4
 970: PUSH
 971: FOR_TO
 972: IFFALSE 1023
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
 974: LD_INT 0
 976: PPUSH
 977: LD_INT 1
 979: PPUSH
 980: LD_INT 2
 982: PPUSH
 983: CALL_OW 12
 987: PPUSH
 988: LD_INT 3
 990: PPUSH
 991: CALL_OW 380
// un := CreateHuman ;
 995: LD_ADDR_VAR 0 3
 999: PUSH
1000: CALL_OW 44
1004: ST_TO_ADDR
// others := others ^ un ;
1005: LD_ADDR_VAR 0 5
1009: PUSH
1010: LD_VAR 0 5
1014: PUSH
1015: LD_VAR 0 3
1019: ADD
1020: ST_TO_ADDR
// end ;
1021: GO 971
1023: POP
1024: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1025: LD_ADDR_VAR 0 6
1029: PUSH
1030: LD_INT 21
1032: PUSH
1033: LD_INT 1
1035: PUSH
1036: LD_INT 1
1038: PUSH
1039: LD_INT 51
1041: PUSH
1042: LD_INT 90
1044: PUSH
1045: LD_INT 504
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: PUSH
1056: LD_INT 21
1058: PUSH
1059: LD_INT 1
1061: PUSH
1062: LD_INT 1
1064: PUSH
1065: LD_INT 51
1067: PUSH
1068: LD_INT 80
1070: PUSH
1071: LD_INT 750
1073: PUSH
1074: EMPTY
1075: LIST
1076: LIST
1077: LIST
1078: LIST
1079: LIST
1080: LIST
1081: PUSH
1082: EMPTY
1083: LIST
1084: LIST
1085: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1086: LD_ADDR_EXP 24
1090: PUSH
1091: LD_STRING JMM
1093: PPUSH
1094: LD_EXP 1
1098: NOT
1099: PPUSH
1100: CALL 353 0 2
1104: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1105: LD_ADDR_EXP 25
1109: PUSH
1110: LD_STRING Bobby
1112: PPUSH
1113: LD_EXP 1
1117: NOT
1118: PPUSH
1119: CALL 353 0 2
1123: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1124: LD_ADDR_EXP 26
1128: PUSH
1129: LD_STRING Cyrus
1131: PPUSH
1132: LD_EXP 1
1136: NOT
1137: PPUSH
1138: CALL 353 0 2
1142: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1143: LD_ADDR_EXP 27
1147: PUSH
1148: LD_STRING Lisa
1150: PPUSH
1151: LD_EXP 1
1155: NOT
1156: PPUSH
1157: CALL 353 0 2
1161: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1162: LD_ADDR_EXP 28
1166: PUSH
1167: LD_STRING Khatam
1169: PPUSH
1170: LD_EXP 1
1174: NOT
1175: PPUSH
1176: CALL 353 0 2
1180: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1181: LD_ADDR_EXP 29
1185: PUSH
1186: LD_STRING Brian
1188: PPUSH
1189: LD_EXP 1
1193: NOT
1194: PPUSH
1195: CALL 353 0 2
1199: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1200: LD_ADDR_EXP 30
1204: PUSH
1205: LD_STRING Jerry
1207: PPUSH
1208: LD_EXP 1
1212: NOT
1213: PPUSH
1214: CALL 353 0 2
1218: ST_TO_ADDR
// if Bobby then
1219: LD_EXP 25
1223: IFFALSE 1254
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1225: LD_ADDR_VAR 0 4
1229: PUSH
1230: LD_VAR 0 4
1234: PPUSH
1235: LD_VAR 0 4
1239: PUSH
1240: LD_INT 1
1242: PLUS
1243: PPUSH
1244: LD_EXP 25
1248: PPUSH
1249: CALL_OW 2
1253: ST_TO_ADDR
// if Cyrus then
1254: LD_EXP 26
1258: IFFALSE 1289
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1260: LD_ADDR_VAR 0 4
1264: PUSH
1265: LD_VAR 0 4
1269: PPUSH
1270: LD_VAR 0 4
1274: PUSH
1275: LD_INT 1
1277: PLUS
1278: PPUSH
1279: LD_EXP 26
1283: PPUSH
1284: CALL_OW 2
1288: ST_TO_ADDR
// if Lisa then
1289: LD_EXP 27
1293: IFFALSE 1324
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1295: LD_ADDR_VAR 0 4
1299: PUSH
1300: LD_VAR 0 4
1304: PPUSH
1305: LD_VAR 0 4
1309: PUSH
1310: LD_INT 1
1312: PLUS
1313: PPUSH
1314: LD_EXP 27
1318: PPUSH
1319: CALL_OW 2
1323: ST_TO_ADDR
// if Khatam then
1324: LD_EXP 28
1328: IFFALSE 1359
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1330: LD_ADDR_VAR 0 4
1334: PUSH
1335: LD_VAR 0 4
1339: PPUSH
1340: LD_VAR 0 4
1344: PUSH
1345: LD_INT 1
1347: PLUS
1348: PPUSH
1349: LD_EXP 28
1353: PPUSH
1354: CALL_OW 2
1358: ST_TO_ADDR
// if Brian then
1359: LD_EXP 29
1363: IFFALSE 1394
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1365: LD_ADDR_VAR 0 4
1369: PUSH
1370: LD_VAR 0 4
1374: PPUSH
1375: LD_VAR 0 4
1379: PUSH
1380: LD_INT 1
1382: PLUS
1383: PPUSH
1384: LD_EXP 29
1388: PPUSH
1389: CALL_OW 2
1393: ST_TO_ADDR
// if Jerry then
1394: LD_EXP 30
1398: IFFALSE 1429
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1400: LD_ADDR_VAR 0 4
1404: PUSH
1405: LD_VAR 0 4
1409: PPUSH
1410: LD_VAR 0 4
1414: PUSH
1415: LD_INT 1
1417: PLUS
1418: PPUSH
1419: LD_EXP 30
1423: PPUSH
1424: CALL_OW 2
1428: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1429: LD_STRING 02_other_survivors
1431: PPUSH
1432: CALL_OW 28
1436: IFFALSE 1451
// others := CreateCharacterSet ( 02_other_survivors ) ;
1438: LD_ADDR_VAR 0 5
1442: PUSH
1443: LD_STRING 02_other_survivors
1445: PPUSH
1446: CALL_OW 31
1450: ST_TO_ADDR
// if others then
1451: LD_VAR 0 5
1455: IFFALSE 1480
// begin tmp := tmp ^ others ;
1457: LD_ADDR_VAR 0 4
1461: PUSH
1462: LD_VAR 0 4
1466: PUSH
1467: LD_VAR 0 5
1471: ADD
1472: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1473: LD_STRING 02_other_survivors
1475: PPUSH
1476: CALL_OW 40
// end ; jmm_units := tmp ;
1480: LD_ADDR_EXP 2
1484: PUSH
1485: LD_VAR 0 4
1489: ST_TO_ADDR
// if not vehicles then
1490: LD_VAR 0 6
1494: NOT
1495: IFFALSE 1513
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1497: LD_ADDR_VAR 0 6
1501: PUSH
1502: LD_STRING 02_tanks_1
1504: PPUSH
1505: LD_INT 0
1507: PPUSH
1508: CALL_OW 30
1512: ST_TO_ADDR
// if vehicles then
1513: LD_VAR 0 6
1517: IFFALSE 1711
// begin got_mech := false ;
1519: LD_ADDR_VAR 0 7
1523: PUSH
1524: LD_INT 0
1526: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1527: LD_VAR 0 4
1531: PPUSH
1532: LD_INT 25
1534: PUSH
1535: LD_INT 3
1537: PUSH
1538: EMPTY
1539: LIST
1540: LIST
1541: PPUSH
1542: CALL_OW 72
1546: IFFALSE 1556
// got_mech := true ;
1548: LD_ADDR_VAR 0 7
1552: PUSH
1553: LD_INT 1
1555: ST_TO_ADDR
// for i = 1 to vehicles do
1556: LD_ADDR_VAR 0 2
1560: PUSH
1561: DOUBLE
1562: LD_INT 1
1564: DEC
1565: ST_TO_ADDR
1566: LD_VAR 0 6
1570: PUSH
1571: FOR_TO
1572: IFFALSE 1709
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1574: LD_ADDR_VAR 0 3
1578: PUSH
1579: LD_INT 1
1581: PPUSH
1582: LD_INT 3
1584: PPUSH
1585: LD_VAR 0 6
1589: PUSH
1590: LD_VAR 0 2
1594: ARRAY
1595: PUSH
1596: LD_INT 1
1598: ARRAY
1599: PPUSH
1600: LD_VAR 0 6
1604: PUSH
1605: LD_VAR 0 2
1609: ARRAY
1610: PUSH
1611: LD_INT 2
1613: ARRAY
1614: PPUSH
1615: LD_VAR 0 6
1619: PUSH
1620: LD_VAR 0 2
1624: ARRAY
1625: PUSH
1626: LD_INT 3
1628: ARRAY
1629: PPUSH
1630: LD_VAR 0 6
1634: PUSH
1635: LD_VAR 0 2
1639: ARRAY
1640: PUSH
1641: LD_INT 4
1643: ARRAY
1644: PPUSH
1645: LD_INT 40
1647: PPUSH
1648: CALL 410 0 7
1652: ST_TO_ADDR
// if not got_mech then
1653: LD_VAR 0 7
1657: NOT
1658: IFFALSE 1684
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1660: LD_VAR 0 3
1664: PPUSH
1665: LD_VAR 0 6
1669: PUSH
1670: LD_VAR 0 2
1674: ARRAY
1675: PUSH
1676: LD_INT 6
1678: ARRAY
1679: PPUSH
1680: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1684: LD_ADDR_VAR 0 4
1688: PUSH
1689: LD_VAR 0 4
1693: PPUSH
1694: LD_INT 1
1696: PPUSH
1697: LD_VAR 0 3
1701: PPUSH
1702: CALL_OW 2
1706: ST_TO_ADDR
// end ;
1707: GO 1571
1709: POP
1710: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1711: LD_EXP 24
1715: PPUSH
1716: LD_INT 194
1718: PPUSH
1719: LD_INT 119
1721: PPUSH
1722: LD_INT 0
1724: PPUSH
1725: CALL_OW 48
// if tmp then
1729: LD_VAR 0 4
1733: IFFALSE 1858
// begin for i in tmp do
1735: LD_ADDR_VAR 0 2
1739: PUSH
1740: LD_VAR 0 4
1744: PUSH
1745: FOR_IN
1746: IFFALSE 1856
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1748: LD_ADDR_VAR 0 8
1752: PUSH
1753: LD_INT 22
1755: PUSH
1756: LD_INT 1
1758: PUSH
1759: EMPTY
1760: LIST
1761: LIST
1762: PUSH
1763: LD_INT 21
1765: PUSH
1766: LD_INT 2
1768: PUSH
1769: EMPTY
1770: LIST
1771: LIST
1772: PUSH
1773: LD_INT 58
1775: PUSH
1776: EMPTY
1777: LIST
1778: PUSH
1779: EMPTY
1780: LIST
1781: LIST
1782: LIST
1783: PPUSH
1784: CALL_OW 69
1788: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
1789: LD_VAR 0 2
1793: PPUSH
1794: CALL_OW 247
1798: PUSH
1799: LD_INT 1
1801: EQUAL
1802: PUSH
1803: LD_VAR 0 8
1807: AND
1808: IFFALSE 1830
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
1810: LD_VAR 0 2
1814: PPUSH
1815: LD_VAR 0 8
1819: PUSH
1820: LD_INT 1
1822: ARRAY
1823: PPUSH
1824: CALL_OW 52
1828: GO 1845
// PlaceUnitArea ( i , startArea , false ) ;
1830: LD_VAR 0 2
1834: PPUSH
1835: LD_INT 1
1837: PPUSH
1838: LD_INT 0
1840: PPUSH
1841: CALL_OW 49
// ComHold ( i ) ;
1845: LD_VAR 0 2
1849: PPUSH
1850: CALL_OW 140
// end ;
1854: GO 1745
1856: POP
1857: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
1858: LD_ADDR_EXP 5
1862: PUSH
1863: LD_STRING 02_mikhailStatus_1
1865: PPUSH
1866: LD_INT 0
1868: PPUSH
1869: CALL_OW 30
1873: ST_TO_ADDR
// if not bierezov_exist and not debug then
1874: LD_EXP 5
1878: NOT
1879: PUSH
1880: LD_EXP 1
1884: NOT
1885: AND
1886: IFFALSE 1890
// exit ;
1888: GO 1921
// Bierezov = PrepareUnit ( Mikhail , false ) ;
1890: LD_ADDR_EXP 32
1894: PUSH
1895: LD_STRING Mikhail
1897: PPUSH
1898: LD_INT 0
1900: PPUSH
1901: CALL 353 0 2
1905: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
1906: LD_EXP 32
1910: PPUSH
1911: LD_INT 1
1913: PPUSH
1914: LD_INT 0
1916: PPUSH
1917: CALL_OW 49
// end ;
1921: LD_VAR 0 1
1925: RET
// export function PrepareCornell ; var tmp , un , i ; begin
1926: LD_INT 0
1928: PPUSH
1929: PPUSH
1930: PPUSH
1931: PPUSH
// uc_side := 4 ;
1932: LD_ADDR_OWVAR 20
1936: PUSH
1937: LD_INT 4
1939: ST_TO_ADDR
// uc_nation := 1 ;
1940: LD_ADDR_OWVAR 21
1944: PUSH
1945: LD_INT 1
1947: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
1948: LD_ADDR_EXP 31
1952: PUSH
1953: LD_STRING Cornell
1955: PPUSH
1956: LD_INT 0
1958: PPUSH
1959: CALL 353 0 2
1963: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
1964: LD_ADDR_EXP 4
1968: PUSH
1969: LD_INT 8
1971: PUSH
1972: LD_EXP 2
1976: MINUS
1977: ST_TO_ADDR
// tmp := [ ] ;
1978: LD_ADDR_VAR 0 2
1982: PUSH
1983: EMPTY
1984: ST_TO_ADDR
// if cornel_units < 4 then
1985: LD_EXP 4
1989: PUSH
1990: LD_INT 4
1992: LESS
1993: IFFALSE 2003
// cornel_units := 4 ;
1995: LD_ADDR_EXP 4
1999: PUSH
2000: LD_INT 4
2002: ST_TO_ADDR
// for i = 1 to cornel_units do
2003: LD_ADDR_VAR 0 4
2007: PUSH
2008: DOUBLE
2009: LD_INT 1
2011: DEC
2012: ST_TO_ADDR
2013: LD_EXP 4
2017: PUSH
2018: FOR_TO
2019: IFFALSE 2117
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2021: LD_INT 0
2023: PPUSH
2024: LD_INT 1
2026: PUSH
2027: LD_INT 1
2029: PUSH
2030: LD_INT 1
2032: PUSH
2033: LD_INT 2
2035: PUSH
2036: LD_INT 4
2038: PUSH
2039: EMPTY
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: PUSH
2046: LD_VAR 0 4
2050: PUSH
2051: LD_INT 5
2053: MOD
2054: PUSH
2055: LD_INT 1
2057: PLUS
2058: ARRAY
2059: PPUSH
2060: LD_INT 2
2062: PPUSH
2063: CALL_OW 380
// un := CreateHuman ;
2067: LD_ADDR_VAR 0 3
2071: PUSH
2072: CALL_OW 44
2076: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2077: LD_ADDR_VAR 0 2
2081: PUSH
2082: LD_VAR 0 2
2086: PPUSH
2087: LD_INT 1
2089: PPUSH
2090: LD_VAR 0 3
2094: PPUSH
2095: CALL_OW 2
2099: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2100: LD_VAR 0 3
2104: PPUSH
2105: LD_INT 2
2107: PPUSH
2108: LD_INT 0
2110: PPUSH
2111: CALL_OW 49
// end ;
2115: GO 2018
2117: POP
2118: POP
// cornel_units := tmp ;
2119: LD_ADDR_EXP 4
2123: PUSH
2124: LD_VAR 0 2
2128: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2129: LD_EXP 31
2133: PPUSH
2134: LD_INT 191
2136: PPUSH
2137: LD_INT 106
2139: PPUSH
2140: LD_INT 0
2142: PPUSH
2143: CALL_OW 48
// end ;
2147: LD_VAR 0 1
2151: RET
// export function PrepareWesternBase ; var i ; begin
2152: LD_INT 0
2154: PPUSH
2155: PPUSH
// uc_side := 8 ;
2156: LD_ADDR_OWVAR 20
2160: PUSH
2161: LD_INT 8
2163: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2164: LD_ADDR_EXP 34
2168: PUSH
2169: LD_STRING Lynch
2171: PPUSH
2172: LD_INT 0
2174: PPUSH
2175: CALL 353 0 2
2179: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2180: LD_ADDR_EXP 35
2184: PUSH
2185: LD_STRING Walker
2187: PPUSH
2188: LD_INT 0
2190: PPUSH
2191: CALL 353 0 2
2195: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2196: LD_ADDR_EXP 36
2200: PUSH
2201: LD_STRING Turner
2203: PPUSH
2204: LD_INT 0
2206: PPUSH
2207: CALL 353 0 2
2211: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2212: LD_ADDR_EXP 37
2216: PUSH
2217: LD_STRING Jillian
2219: PPUSH
2220: LD_INT 0
2222: PPUSH
2223: CALL 353 0 2
2227: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2228: LD_ADDR_VAR 0 2
2232: PUSH
2233: LD_EXP 34
2237: PUSH
2238: LD_EXP 35
2242: PUSH
2243: LD_EXP 36
2247: PUSH
2248: LD_EXP 37
2252: PUSH
2253: EMPTY
2254: LIST
2255: LIST
2256: LIST
2257: LIST
2258: PUSH
2259: FOR_IN
2260: IFFALSE 2288
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2262: LD_VAR 0 2
2266: PPUSH
2267: LD_INT 3
2269: PPUSH
2270: LD_INT 0
2272: PPUSH
2273: CALL_OW 49
// ComHold ( i ) ;
2277: LD_VAR 0 2
2281: PPUSH
2282: CALL_OW 140
// end ;
2286: GO 2259
2288: POP
2289: POP
// end ;
2290: LD_VAR 0 1
2294: RET
// export function SelectGroup ; var units , selected , i ; begin
2295: LD_INT 0
2297: PPUSH
2298: PPUSH
2299: PPUSH
2300: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2301: LD_ADDR_VAR 0 2
2305: PUSH
2306: LD_EXP 24
2310: PUSH
2311: LD_INT -3
2313: PUSH
2314: EMPTY
2315: LIST
2316: LIST
2317: PUSH
2318: LD_EXP 2
2322: ADD
2323: PUSH
2324: LD_INT -2
2326: PUSH
2327: LD_INT -4
2329: PUSH
2330: LD_EXP 31
2334: PUSH
2335: LD_EXP 32
2339: PUSH
2340: EMPTY
2341: LIST
2342: LIST
2343: LIST
2344: LIST
2345: ADD
2346: PUSH
2347: LD_INT -3
2349: PUSH
2350: EMPTY
2351: LIST
2352: ADD
2353: PUSH
2354: LD_EXP 4
2358: ADD
2359: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2360: LD_ADDR_VAR 0 3
2364: PUSH
2365: LD_EXP 24
2369: PUSH
2370: LD_STRING Select five characters to go with you
2372: PPUSH
2373: LD_INT 4
2375: PPUSH
2376: LD_INT 4
2378: PPUSH
2379: LD_VAR 0 2
2383: PPUSH
2384: EMPTY
2385: PPUSH
2386: CALL_OW 42
2390: ADD
2391: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2392: LD_ADDR_EXP 4
2396: PUSH
2397: LD_EXP 2
2401: PUSH
2402: LD_EXP 4
2406: UNION
2407: PUSH
2408: LD_VAR 0 3
2412: DIFF
2413: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2414: LD_ADDR_VAR 0 4
2418: PUSH
2419: LD_EXP 4
2423: PUSH
2424: LD_EXP 32
2428: ADD
2429: PUSH
2430: FOR_IN
2431: IFFALSE 2462
// if GetSide ( i ) = 1 then
2433: LD_VAR 0 4
2437: PPUSH
2438: CALL_OW 255
2442: PUSH
2443: LD_INT 1
2445: EQUAL
2446: IFFALSE 2460
// SetSide ( i , 4 ) ;
2448: LD_VAR 0 4
2452: PPUSH
2453: LD_INT 4
2455: PPUSH
2456: CALL_OW 235
2460: GO 2430
2462: POP
2463: POP
// for i in selected do
2464: LD_ADDR_VAR 0 4
2468: PUSH
2469: LD_VAR 0 3
2473: PUSH
2474: FOR_IN
2475: IFFALSE 2506
// if GetSide ( i ) = 4 then
2477: LD_VAR 0 4
2481: PPUSH
2482: CALL_OW 255
2486: PUSH
2487: LD_INT 4
2489: EQUAL
2490: IFFALSE 2504
// SetSide ( i , 1 ) ;
2492: LD_VAR 0 4
2496: PPUSH
2497: LD_INT 1
2499: PPUSH
2500: CALL_OW 235
2504: GO 2474
2506: POP
2507: POP
// if GetSide ( Bobby ) = 4 then
2508: LD_EXP 25
2512: PPUSH
2513: CALL_OW 255
2517: PUSH
2518: LD_INT 4
2520: EQUAL
2521: IFFALSE 2530
// DeleteCharacters ( Bobby ) ;
2523: LD_STRING Bobby
2525: PPUSH
2526: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2530: LD_EXP 26
2534: PPUSH
2535: CALL_OW 255
2539: PUSH
2540: LD_INT 4
2542: EQUAL
2543: IFFALSE 2552
// DeleteCharacters ( Cyrus ) ;
2545: LD_STRING Cyrus
2547: PPUSH
2548: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2552: LD_EXP 27
2556: PPUSH
2557: CALL_OW 255
2561: PUSH
2562: LD_INT 4
2564: EQUAL
2565: IFFALSE 2574
// DeleteCharacters ( Lisa ) ;
2567: LD_STRING Lisa
2569: PPUSH
2570: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2574: LD_EXP 28
2578: PPUSH
2579: CALL_OW 255
2583: PUSH
2584: LD_INT 4
2586: EQUAL
2587: IFFALSE 2596
// DeleteCharacters ( Khatam ) ;
2589: LD_STRING Khatam
2591: PPUSH
2592: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2596: LD_EXP 29
2600: PPUSH
2601: CALL_OW 255
2605: PUSH
2606: LD_INT 4
2608: EQUAL
2609: IFFALSE 2618
// DeleteCharacters ( Brian ) ;
2611: LD_STRING Brian
2613: PPUSH
2614: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2618: LD_EXP 30
2622: PPUSH
2623: CALL_OW 255
2627: PUSH
2628: LD_INT 4
2630: EQUAL
2631: IFFALSE 2640
// DeleteCharacters ( Jerry ) ;
2633: LD_STRING Jerry
2635: PPUSH
2636: CALL_OW 40
// end ; end_of_file
2640: LD_VAR 0 1
2644: RET
// export Pokryshkin ; export ru_patrol , ru_forest ; export function PrepareRussian ; var i , b , un , veh , tw , bar , skill , vehicles , spot_xy ; begin
2645: LD_INT 0
2647: PPUSH
2648: PPUSH
2649: PPUSH
2650: PPUSH
2651: PPUSH
2652: PPUSH
2653: PPUSH
2654: PPUSH
2655: PPUSH
2656: PPUSH
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
2657: LD_ADDR_VAR 0 6
2661: PUSH
2662: LD_INT 22
2664: PUSH
2665: LD_INT 3
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: PUSH
2672: LD_INT 2
2674: PUSH
2675: LD_INT 30
2677: PUSH
2678: LD_INT 31
2680: PUSH
2681: EMPTY
2682: LIST
2683: LIST
2684: PUSH
2685: LD_INT 30
2687: PUSH
2688: LD_INT 32
2690: PUSH
2691: EMPTY
2692: LIST
2693: LIST
2694: PUSH
2695: EMPTY
2696: LIST
2697: LIST
2698: LIST
2699: PUSH
2700: EMPTY
2701: LIST
2702: LIST
2703: PPUSH
2704: CALL_OW 69
2708: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
2709: LD_ADDR_VAR 0 7
2713: PUSH
2714: LD_INT 22
2716: PUSH
2717: LD_INT 3
2719: PUSH
2720: EMPTY
2721: LIST
2722: LIST
2723: PUSH
2724: LD_INT 30
2726: PUSH
2727: LD_INT 4
2729: PUSH
2730: EMPTY
2731: LIST
2732: LIST
2733: PUSH
2734: EMPTY
2735: LIST
2736: LIST
2737: PPUSH
2738: CALL_OW 69
2742: ST_TO_ADDR
// uc_side := 3 ;
2743: LD_ADDR_OWVAR 20
2747: PUSH
2748: LD_INT 3
2750: ST_TO_ADDR
// uc_nation := 3 ;
2751: LD_ADDR_OWVAR 21
2755: PUSH
2756: LD_INT 3
2758: ST_TO_ADDR
// skill := [ 2 , 2 , 3 ] [ Difficulty ] ;
2759: LD_ADDR_VAR 0 8
2763: PUSH
2764: LD_INT 2
2766: PUSH
2767: LD_INT 2
2769: PUSH
2770: LD_INT 3
2772: PUSH
2773: EMPTY
2774: LIST
2775: LIST
2776: LIST
2777: PUSH
2778: LD_OWVAR 67
2782: ARRAY
2783: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
2784: LD_ADDR_EXP 39
2788: PUSH
2789: LD_STRING Pokryshkin
2791: PPUSH
2792: LD_INT 0
2794: PPUSH
2795: CALL 353 0 2
2799: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
2800: LD_EXP 39
2804: PPUSH
2805: LD_INT 63
2807: PPUSH
2808: LD_INT 21
2810: PPUSH
2811: LD_INT 0
2813: PPUSH
2814: CALL_OW 48
// ComHold ( Pokryshkin ) ;
2818: LD_EXP 39
2822: PPUSH
2823: CALL_OW 140
// InitHc ;
2827: CALL_OW 19
// for i in tw do
2831: LD_ADDR_VAR 0 2
2835: PUSH
2836: LD_VAR 0 6
2840: PUSH
2841: FOR_IN
2842: IFFALSE 2891
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
2844: LD_VAR 0 2
2848: PPUSH
2849: LD_INT 42
2851: PUSH
2852: LD_INT 43
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: PUSH
2859: LD_INT 1
2861: PPUSH
2862: LD_INT 2
2864: PPUSH
2865: CALL_OW 12
2869: ARRAY
2870: PPUSH
2871: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
2875: LD_VAR 0 8
2879: PPUSH
2880: LD_VAR 0 2
2884: PPUSH
2885: CALL 670 0 2
// end ;
2889: GO 2841
2891: POP
2892: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
2893: LD_ADDR_VAR 0 10
2897: PUSH
2898: LD_INT 100
2900: PUSH
2901: LD_INT 9
2903: PUSH
2904: EMPTY
2905: LIST
2906: LIST
2907: PUSH
2908: LD_INT 135
2910: PUSH
2911: LD_INT 60
2913: PUSH
2914: EMPTY
2915: LIST
2916: LIST
2917: PUSH
2918: LD_INT 41
2920: PUSH
2921: LD_INT 6
2923: PUSH
2924: EMPTY
2925: LIST
2926: LIST
2927: PUSH
2928: LD_INT 22
2930: PUSH
2931: LD_INT 9
2933: PUSH
2934: EMPTY
2935: LIST
2936: LIST
2937: PUSH
2938: LD_INT 84
2940: PUSH
2941: LD_INT 14
2943: PUSH
2944: EMPTY
2945: LIST
2946: LIST
2947: PUSH
2948: EMPTY
2949: LIST
2950: LIST
2951: LIST
2952: LIST
2953: LIST
2954: ST_TO_ADDR
// vehicles := [ ] ;
2955: LD_ADDR_VAR 0 9
2959: PUSH
2960: EMPTY
2961: ST_TO_ADDR
// for i in spot_xy do
2962: LD_ADDR_VAR 0 2
2966: PUSH
2967: LD_VAR 0 10
2971: PUSH
2972: FOR_IN
2973: IFFALSE 3127
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
2975: LD_ADDR_VAR 0 5
2979: PUSH
2980: LD_INT 3
2982: PPUSH
2983: LD_INT 3
2985: PPUSH
2986: LD_INT 22
2988: PPUSH
2989: LD_INT 1
2991: PPUSH
2992: LD_INT 1
2994: PPUSH
2995: LD_INT 42
2997: PUSH
2998: LD_INT 43
3000: PUSH
3001: EMPTY
3002: LIST
3003: LIST
3004: PUSH
3005: LD_INT 1
3007: PPUSH
3008: LD_INT 2
3010: PPUSH
3011: CALL_OW 12
3015: ARRAY
3016: PPUSH
3017: LD_INT 100
3019: PPUSH
3020: CALL 410 0 7
3024: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3025: LD_ADDR_VAR 0 9
3029: PUSH
3030: LD_VAR 0 9
3034: PPUSH
3035: LD_VAR 0 9
3039: PUSH
3040: LD_INT 1
3042: PLUS
3043: PPUSH
3044: LD_VAR 0 5
3048: PPUSH
3049: CALL_OW 2
3053: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3054: LD_VAR 0 5
3058: PPUSH
3059: LD_INT 3
3061: PPUSH
3062: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3066: LD_VAR 0 5
3070: PPUSH
3071: LD_VAR 0 2
3075: PUSH
3076: LD_INT 1
3078: ARRAY
3079: PPUSH
3080: LD_VAR 0 2
3084: PUSH
3085: LD_INT 2
3087: ARRAY
3088: PPUSH
3089: LD_INT 0
3091: PPUSH
3092: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3096: LD_INT 0
3098: PPUSH
3099: LD_INT 3
3101: PPUSH
3102: LD_VAR 0 8
3106: PPUSH
3107: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3111: CALL_OW 44
3115: PPUSH
3116: LD_VAR 0 5
3120: PPUSH
3121: CALL_OW 52
// end ;
3125: GO 2972
3127: POP
3128: POP
// for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
3129: LD_ADDR_VAR 0 2
3133: PUSH
3134: DOUBLE
3135: LD_INT 1
3137: DEC
3138: ST_TO_ADDR
3139: LD_INT 3
3141: PUSH
3142: LD_INT 4
3144: PUSH
3145: LD_INT 5
3147: PUSH
3148: EMPTY
3149: LIST
3150: LIST
3151: LIST
3152: PUSH
3153: LD_OWVAR 67
3157: ARRAY
3158: PUSH
3159: FOR_TO
3160: IFFALSE 3220
// begin PrepareHuman ( false , 1 , skill ) ;
3162: LD_INT 0
3164: PPUSH
3165: LD_INT 1
3167: PPUSH
3168: LD_VAR 0 8
3172: PPUSH
3173: CALL_OW 380
// un := CreateHuman ;
3177: LD_ADDR_VAR 0 4
3181: PUSH
3182: CALL_OW 44
3186: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3187: LD_VAR 0 4
3191: PPUSH
3192: LD_INT 11
3194: PPUSH
3195: LD_INT 0
3197: PPUSH
3198: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3202: LD_ADDR_EXP 41
3206: PUSH
3207: LD_EXP 41
3211: PUSH
3212: LD_VAR 0 4
3216: ADD
3217: ST_TO_ADDR
// end ;
3218: GO 3159
3220: POP
3221: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3222: LD_ADDR_VAR 0 2
3226: PUSH
3227: DOUBLE
3228: LD_INT 1
3230: DEC
3231: ST_TO_ADDR
3232: LD_INT 2
3234: PUSH
3235: LD_INT 3
3237: PUSH
3238: LD_INT 4
3240: PUSH
3241: EMPTY
3242: LIST
3243: LIST
3244: LIST
3245: PUSH
3246: LD_OWVAR 67
3250: ARRAY
3251: PUSH
3252: FOR_TO
3253: IFFALSE 3297
// begin PrepareHuman ( false , 1 , skill ) ;
3255: LD_INT 0
3257: PPUSH
3258: LD_INT 1
3260: PPUSH
3261: LD_VAR 0 8
3265: PPUSH
3266: CALL_OW 380
// un := CreateHuman ;
3270: LD_ADDR_VAR 0 4
3274: PUSH
3275: CALL_OW 44
3279: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
3280: LD_VAR 0 4
3284: PPUSH
3285: LD_INT 12
3287: PPUSH
3288: LD_INT 0
3290: PPUSH
3291: CALL_OW 49
// end ;
3295: GO 3252
3297: POP
3298: POP
// end ; end_of_file
3299: LD_VAR 0 1
3303: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
3304: LD_INT 0
3306: PPUSH
3307: PPUSH
3308: PPUSH
3309: PPUSH
3310: PPUSH
3311: PPUSH
3312: PPUSH
// InGameOn ;
3313: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
3317: LD_EXP 24
3321: PPUSH
3322: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
3326: LD_EXP 24
3330: PPUSH
3331: LD_EXP 31
3335: PPUSH
3336: CALL_OW 119
// if Bierezov then
3340: LD_EXP 32
3344: IFFALSE 3360
// ComTurnUnit ( Bierezov , Cornel ) ;
3346: LD_EXP 32
3350: PPUSH
3351: LD_EXP 31
3355: PPUSH
3356: CALL_OW 119
// for i in jmm_units do
3360: LD_ADDR_VAR 0 2
3364: PUSH
3365: LD_EXP 2
3369: PUSH
3370: FOR_IN
3371: IFFALSE 3389
// ComTurnUnit ( i , Cornel ) ;
3373: LD_VAR 0 2
3377: PPUSH
3378: LD_EXP 31
3382: PPUSH
3383: CALL_OW 119
3387: GO 3370
3389: POP
3390: POP
// units := cornel_units union Cornel ;
3391: LD_ADDR_VAR 0 3
3395: PUSH
3396: LD_EXP 4
3400: PUSH
3401: LD_EXP 31
3405: UNION
3406: ST_TO_ADDR
// repeat wait ( 1 ) ;
3407: LD_INT 1
3409: PPUSH
3410: CALL_OW 67
// for i in units do
3414: LD_ADDR_VAR 0 2
3418: PUSH
3419: LD_VAR 0 3
3423: PUSH
3424: FOR_IN
3425: IFFALSE 3458
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
3427: LD_VAR 0 2
3431: PPUSH
3432: LD_EXP 24
3436: PPUSH
3437: CALL_OW 250
3441: PPUSH
3442: LD_EXP 24
3446: PPUSH
3447: CALL_OW 251
3451: PPUSH
3452: CALL_OW 111
3456: GO 3424
3458: POP
3459: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
3460: LD_VAR 0 3
3464: PPUSH
3465: LD_INT 92
3467: PUSH
3468: LD_EXP 24
3472: PPUSH
3473: CALL_OW 250
3477: PUSH
3478: LD_EXP 24
3482: PPUSH
3483: CALL_OW 251
3487: PUSH
3488: LD_INT 10
3490: PUSH
3491: EMPTY
3492: LIST
3493: LIST
3494: LIST
3495: LIST
3496: PPUSH
3497: CALL_OW 72
3501: PUSH
3502: LD_VAR 0 3
3506: EQUAL
3507: IFFALSE 3407
// for i in units do
3509: LD_ADDR_VAR 0 2
3513: PUSH
3514: LD_VAR 0 3
3518: PUSH
3519: FOR_IN
3520: IFFALSE 3538
// ComTurnUnit ( i , JMM ) ;
3522: LD_VAR 0 2
3526: PPUSH
3527: LD_EXP 24
3531: PPUSH
3532: CALL_OW 119
3536: GO 3519
3538: POP
3539: POP
// ComTurnUnit ( Cornel , JMM ) ;
3540: LD_EXP 31
3544: PPUSH
3545: LD_EXP 24
3549: PPUSH
3550: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
3554: LD_EXP 24
3558: PPUSH
3559: LD_STRING D1-JMM-1
3561: PPUSH
3562: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
3566: LD_EXP 31
3570: PPUSH
3571: LD_STRING D1-Corn-1
3573: PPUSH
3574: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
3578: LD_EXP 24
3582: PPUSH
3583: LD_EXP 31
3587: PPUSH
3588: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
3592: LD_EXP 31
3596: PPUSH
3597: LD_EXP 24
3601: PPUSH
3602: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
3606: LD_INT 35
3608: PPUSH
3609: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
3613: LD_EXP 24
3617: PPUSH
3618: LD_EXP 31
3622: PPUSH
3623: CALL_OW 296
3627: PUSH
3628: LD_INT 6
3630: LESS
3631: IFFALSE 3606
// ChangeSideFog ( 4 , 1 ) ;
3633: LD_INT 4
3635: PPUSH
3636: LD_INT 1
3638: PPUSH
3639: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
3643: LD_EXP 24
3647: PPUSH
3648: LD_EXP 31
3652: PPUSH
3653: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
3657: LD_EXP 31
3661: PPUSH
3662: LD_EXP 24
3666: PPUSH
3667: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
3671: LD_EXP 24
3675: PPUSH
3676: LD_STRING D1-JMM-2
3678: PPUSH
3679: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
3683: LD_EXP 24
3687: PPUSH
3688: LD_STRING D1-JMM-2a
3690: PPUSH
3691: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
3695: LD_EXP 31
3699: PPUSH
3700: LD_STRING D1-Corn-2
3702: PPUSH
3703: CALL_OW 88
// if bierezov_exist or debug then
3707: LD_EXP 5
3711: PUSH
3712: LD_EXP 1
3716: OR
3717: IFFALSE 3958
// begin ComTurnUnit ( Cornel , Bierezov ) ;
3719: LD_EXP 31
3723: PPUSH
3724: LD_EXP 32
3728: PPUSH
3729: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
3733: LD_INT 10
3735: PPUSH
3736: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
3740: LD_EXP 31
3744: PPUSH
3745: LD_STRING D1a-Corn-1
3747: PPUSH
3748: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
3752: LD_EXP 24
3756: PPUSH
3757: LD_EXP 32
3761: PPUSH
3762: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
3766: LD_EXP 32
3770: PPUSH
3771: LD_EXP 24
3775: PPUSH
3776: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
3780: LD_EXP 24
3784: PPUSH
3785: LD_STRING D1a-JMM-1
3787: PPUSH
3788: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
3792: LD_EXP 24
3796: PPUSH
3797: LD_EXP 31
3801: PPUSH
3802: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
3806: LD_EXP 31
3810: PPUSH
3811: LD_EXP 24
3815: PPUSH
3816: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
3820: LD_EXP 31
3824: PPUSH
3825: LD_STRING D1a-Corn-2
3827: PPUSH
3828: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
3832: LD_EXP 24
3836: PPUSH
3837: LD_STRING D1a-JMM-2
3839: PPUSH
3840: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
3844: LD_EXP 31
3848: PPUSH
3849: LD_STRING D1a-Corn-3
3851: PPUSH
3852: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
3856: LD_EXP 24
3860: PPUSH
3861: LD_STRING D1a-JMM-3
3863: PPUSH
3864: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
3868: LD_EXP 31
3872: PPUSH
3873: LD_STRING D1a-Corn-4
3875: PPUSH
3876: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
3880: LD_EXP 24
3884: PPUSH
3885: LD_STRING D1a-JMM-4
3887: PPUSH
3888: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
3892: LD_EXP 31
3896: PPUSH
3897: LD_STRING D1a-Corn-5
3899: PPUSH
3900: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
3904: LD_EXP 32
3908: PPUSH
3909: LD_EXP 31
3913: PPUSH
3914: CALL_OW 250
3918: PPUSH
3919: LD_EXP 31
3923: PPUSH
3924: CALL_OW 251
3928: PUSH
3929: LD_INT 2
3931: MINUS
3932: PPUSH
3933: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
3937: LD_EXP 32
3941: PPUSH
3942: LD_EXP 31
3946: PPUSH
3947: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
3951: LD_INT 10
3953: PPUSH
3954: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
3958: LD_EXP 24
3962: PPUSH
3963: LD_STRING D1b-JMM-1
3965: PPUSH
3966: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
3970: LD_EXP 31
3974: PPUSH
3975: LD_STRING D1b-Corn-1
3977: PPUSH
3978: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
3982: LD_EXP 24
3986: PPUSH
3987: LD_STRING D1b-JMM-2
3989: PPUSH
3990: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
3994: LD_EXP 31
3998: PPUSH
3999: LD_STRING D1b-Corn-2
4001: PPUSH
4002: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
4006: LD_EXP 24
4010: PPUSH
4011: LD_STRING D1b-JMM-3
4013: PPUSH
4014: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
4018: LD_INT 10
4020: PPUSH
4021: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
4025: LD_EXP 33
4029: PPUSH
4030: LD_STRING D1b-Pow-3
4032: PPUSH
4033: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
4037: LD_EXP 24
4041: PPUSH
4042: LD_STRING D1b-JMM-4
4044: PPUSH
4045: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
4049: LD_EXP 31
4053: PPUSH
4054: LD_STRING D1b-Corn-4
4056: PPUSH
4057: CALL_OW 88
// if Khatam then
4061: LD_EXP 28
4065: IFFALSE 4081
// Say ( Khatam , D1b-Khat-4 ) else
4067: LD_EXP 28
4071: PPUSH
4072: LD_STRING D1b-Khat-4
4074: PPUSH
4075: CALL_OW 88
4079: GO 4117
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
4081: LD_EXP 4
4085: PPUSH
4086: LD_INT 26
4088: PUSH
4089: LD_INT 1
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: PPUSH
4096: CALL_OW 72
4100: PUSH
4101: LD_EXP 31
4105: PUSH
4106: EMPTY
4107: LIST
4108: DIFF
4109: PPUSH
4110: LD_STRING D1b-Sol1-4
4112: PPUSH
4113: CALL 498 0 2
// if Cyrus then
4117: LD_EXP 26
4121: IFFALSE 4135
// Say ( Cyrus , D1b-Cyrus-4 ) ;
4123: LD_EXP 26
4127: PPUSH
4128: LD_STRING D1b-Cyrus-4
4130: PPUSH
4131: CALL_OW 88
// if Lisa then
4135: LD_EXP 27
4139: IFFALSE 4197
// begin Say ( Lisa , D1b-Lisa-4 ) ;
4141: LD_EXP 27
4145: PPUSH
4146: LD_STRING D1b-Lisa-4
4148: PPUSH
4149: CALL_OW 88
// if Cyrus then
4153: LD_EXP 26
4157: IFFALSE 4197
// begin if not IsInUnit ( Cyrus ) then
4159: LD_EXP 26
4163: PPUSH
4164: CALL_OW 310
4168: NOT
4169: IFFALSE 4185
// ComTurnUnit ( Cyrus , Lisa ) ;
4171: LD_EXP 26
4175: PPUSH
4176: LD_EXP 27
4180: PPUSH
4181: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
4185: LD_EXP 26
4189: PPUSH
4190: LD_STRING D1b-Cyrus-5
4192: PPUSH
4193: CALL_OW 88
// end ; end ; SelectGroup ;
4197: CALL 2295 0 0
// Say ( JMM , D1d-JMM-1 ) ;
4201: LD_EXP 24
4205: PPUSH
4206: LD_STRING D1d-JMM-1
4208: PPUSH
4209: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
4213: LD_EXP 31
4217: PPUSH
4218: LD_STRING D1d-Corn-1
4220: PPUSH
4221: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
4225: LD_ADDR_VAR 0 2
4229: PUSH
4230: LD_EXP 2
4234: PUSH
4235: LD_EXP 4
4239: ADD
4240: PUSH
4241: LD_EXP 24
4245: ADD
4246: PUSH
4247: FOR_IN
4248: IFFALSE 4261
// ComHold ( i ) ;
4250: LD_VAR 0 2
4254: PPUSH
4255: CALL_OW 140
4259: GO 4247
4261: POP
4262: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
4263: LD_ADDR_VAR 0 4
4267: PUSH
4268: LD_INT 22
4270: PUSH
4271: LD_INT 1
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: PUSH
4278: LD_INT 21
4280: PUSH
4281: LD_INT 2
4283: PUSH
4284: EMPTY
4285: LIST
4286: LIST
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: PPUSH
4292: CALL_OW 69
4296: ST_TO_ADDR
// if vehicles then
4297: LD_VAR 0 4
4301: IFFALSE 4639
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
4303: LD_EXP 4
4307: PPUSH
4308: LD_INT 55
4310: PUSH
4311: EMPTY
4312: LIST
4313: PPUSH
4314: CALL_OW 72
4318: IFFALSE 4357
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
4320: LD_ADDR_VAR 0 2
4324: PUSH
4325: LD_EXP 4
4329: PPUSH
4330: LD_INT 55
4332: PUSH
4333: EMPTY
4334: LIST
4335: PPUSH
4336: CALL_OW 72
4340: PUSH
4341: FOR_IN
4342: IFFALSE 4355
// ComExitVehicle ( i ) ;
4344: LD_VAR 0 2
4348: PPUSH
4349: CALL_OW 121
4353: GO 4341
4355: POP
4356: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
4357: LD_ADDR_VAR 0 5
4361: PUSH
4362: LD_VAR 0 4
4366: PPUSH
4367: LD_INT 34
4369: PUSH
4370: LD_INT 51
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PPUSH
4377: CALL_OW 72
4381: ST_TO_ADDR
// if cargos then
4382: LD_VAR 0 5
4386: IFFALSE 4569
// begin vehicles := cargos ;
4388: LD_ADDR_VAR 0 4
4392: PUSH
4393: LD_VAR 0 5
4397: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
4398: LD_ADDR_VAR 0 6
4402: PUSH
4403: LD_STRING 02_resources_4
4405: PPUSH
4406: LD_INT 0
4408: PPUSH
4409: CALL_OW 30
4413: ST_TO_ADDR
// if debug and not resources then
4414: LD_EXP 1
4418: PUSH
4419: LD_VAR 0 6
4423: NOT
4424: AND
4425: IFFALSE 4435
// resources := 160 ;
4427: LD_ADDR_VAR 0 6
4431: PUSH
4432: LD_INT 160
4434: ST_TO_ADDR
// if resources mod 10 then
4435: LD_VAR 0 6
4439: PUSH
4440: LD_INT 10
4442: MOD
4443: IFFALSE 4465
// resources := resources - resources mod 10 ;
4445: LD_ADDR_VAR 0 6
4449: PUSH
4450: LD_VAR 0 6
4454: PUSH
4455: LD_VAR 0 6
4459: PUSH
4460: LD_INT 10
4462: MOD
4463: MINUS
4464: ST_TO_ADDR
// if resources then
4465: LD_VAR 0 6
4469: IFFALSE 4569
// for i in cargos do
4471: LD_ADDR_VAR 0 2
4475: PUSH
4476: LD_VAR 0 5
4480: PUSH
4481: FOR_IN
4482: IFFALSE 4567
// begin if resources < 100 then
4484: LD_VAR 0 6
4488: PUSH
4489: LD_INT 100
4491: LESS
4492: IFFALSE 4514
// begin cargo := resources ;
4494: LD_ADDR_VAR 0 7
4498: PUSH
4499: LD_VAR 0 6
4503: ST_TO_ADDR
// resources := 0 ;
4504: LD_ADDR_VAR 0 6
4508: PUSH
4509: LD_INT 0
4511: ST_TO_ADDR
// end else
4512: GO 4536
// begin cargo := 100 ;
4514: LD_ADDR_VAR 0 7
4518: PUSH
4519: LD_INT 100
4521: ST_TO_ADDR
// resources := resources - 100 ;
4522: LD_ADDR_VAR 0 6
4526: PUSH
4527: LD_VAR 0 6
4531: PUSH
4532: LD_INT 100
4534: MINUS
4535: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
4536: LD_VAR 0 2
4540: PPUSH
4541: LD_INT 1
4543: PPUSH
4544: LD_VAR 0 7
4548: PPUSH
4549: CALL_OW 290
// if resources = 0 then
4553: LD_VAR 0 6
4557: PUSH
4558: LD_INT 0
4560: EQUAL
4561: IFFALSE 4565
// break ;
4563: GO 4567
// end ;
4565: GO 4481
4567: POP
4568: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
4569: LD_VAR 0 4
4573: PUSH
4574: LD_INT 1
4576: ARRAY
4577: PPUSH
4578: CALL_OW 311
4582: PPUSH
4583: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
4587: LD_VAR 0 4
4591: PUSH
4592: LD_INT 1
4594: ARRAY
4595: PPUSH
4596: LD_INT 4
4598: PPUSH
4599: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
4603: LD_EXP 31
4607: PPUSH
4608: LD_VAR 0 4
4612: PUSH
4613: LD_INT 1
4615: ARRAY
4616: PPUSH
4617: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
4621: LD_INT 35
4623: PPUSH
4624: CALL_OW 67
// until IsInUnit ( Cornel ) ;
4628: LD_EXP 31
4632: PPUSH
4633: CALL_OW 310
4637: IFFALSE 4621
// end ; InGameOff ;
4639: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
4643: LD_STRING M1
4645: PPUSH
4646: CALL_OW 337
// cornel_active := true ;
4650: LD_ADDR_EXP 6
4654: PUSH
4655: LD_INT 1
4657: ST_TO_ADDR
// end ;
4658: LD_VAR 0 1
4662: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
4663: LD_EXP 24
4667: PPUSH
4668: LD_EXP 34
4672: PPUSH
4673: CALL_OW 296
4677: PUSH
4678: LD_INT 10
4680: LESS
4681: IFFALSE 5773
4683: GO 4685
4685: DISABLE
4686: LD_INT 0
4688: PPUSH
4689: PPUSH
4690: PPUSH
4691: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
4692: LD_ADDR_VAR 0 2
4696: PUSH
4697: LD_INT 89
4699: PUSH
4700: LD_INT 34
4702: PUSH
4703: EMPTY
4704: LIST
4705: LIST
4706: PUSH
4707: LD_INT 138
4709: PUSH
4710: LD_INT 63
4712: PUSH
4713: EMPTY
4714: LIST
4715: LIST
4716: PUSH
4717: LD_INT 196
4719: PUSH
4720: LD_INT 84
4722: PUSH
4723: EMPTY
4724: LIST
4725: LIST
4726: PUSH
4727: LD_INT 135
4729: PUSH
4730: LD_INT 52
4732: PUSH
4733: EMPTY
4734: LIST
4735: LIST
4736: PUSH
4737: LD_INT 103
4739: PUSH
4740: LD_INT 39
4742: PUSH
4743: EMPTY
4744: LIST
4745: LIST
4746: PUSH
4747: LD_INT 58
4749: PUSH
4750: LD_INT 30
4752: PUSH
4753: EMPTY
4754: LIST
4755: LIST
4756: PUSH
4757: LD_INT 38
4759: PUSH
4760: LD_INT 51
4762: PUSH
4763: EMPTY
4764: LIST
4765: LIST
4766: PUSH
4767: EMPTY
4768: LIST
4769: LIST
4770: LIST
4771: LIST
4772: LIST
4773: LIST
4774: LIST
4775: ST_TO_ADDR
// InGameOn ;
4776: CALL_OW 8
// if jmm_units then
4780: LD_EXP 2
4784: IFFALSE 4848
// for i in jmm_units do
4786: LD_ADDR_VAR 0 1
4790: PUSH
4791: LD_EXP 2
4795: PUSH
4796: FOR_IN
4797: IFFALSE 4846
// begin if GetDistUnits ( i , JMM ) < 10 then
4799: LD_VAR 0 1
4803: PPUSH
4804: LD_EXP 24
4808: PPUSH
4809: CALL_OW 296
4813: PUSH
4814: LD_INT 10
4816: LESS
4817: IFFALSE 4835
// ComTurnUnit ( i , JMM ) else
4819: LD_VAR 0 1
4823: PPUSH
4824: LD_EXP 24
4828: PPUSH
4829: CALL_OW 119
4833: GO 4844
// ComHold ( i ) ;
4835: LD_VAR 0 1
4839: PPUSH
4840: CALL_OW 140
// end ;
4844: GO 4796
4846: POP
4847: POP
// ComMoveUnit ( JMM , Lynch ) ;
4848: LD_EXP 24
4852: PPUSH
4853: LD_EXP 34
4857: PPUSH
4858: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
4862: LD_INT 35
4864: PPUSH
4865: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
4869: LD_EXP 24
4873: PPUSH
4874: LD_EXP 34
4878: PPUSH
4879: CALL_OW 296
4883: PUSH
4884: LD_INT 6
4886: LESS
4887: IFFALSE 4862
// ComTurnUnit ( JMM , Lynch ) ;
4889: LD_EXP 24
4893: PPUSH
4894: LD_EXP 34
4898: PPUSH
4899: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
4903: LD_ADDR_VAR 0 1
4907: PUSH
4908: LD_EXP 34
4912: PUSH
4913: LD_EXP 35
4917: PUSH
4918: LD_EXP 36
4922: PUSH
4923: LD_EXP 37
4927: PUSH
4928: EMPTY
4929: LIST
4930: LIST
4931: LIST
4932: LIST
4933: PUSH
4934: FOR_IN
4935: IFFALSE 4953
// ComTurnUnit ( i , JMM ) ;
4937: LD_VAR 0 1
4941: PPUSH
4942: LD_EXP 24
4946: PPUSH
4947: CALL_OW 119
4951: GO 4934
4953: POP
4954: POP
// Wait ( 0 0$0.3 ) ;
4955: LD_INT 10
4957: PPUSH
4958: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
4962: LD_EXP 24
4966: PPUSH
4967: LD_STRING D2-JMM-1
4969: PPUSH
4970: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
4974: LD_EXP 34
4978: PPUSH
4979: LD_STRING D2-Sol1-1
4981: PPUSH
4982: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
4986: LD_EXP 24
4990: PPUSH
4991: LD_STRING D2-JMM-2
4993: PPUSH
4994: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
4998: LD_EXP 34
5002: PPUSH
5003: LD_STRING D2-Sol1-2
5005: PPUSH
5006: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
5010: LD_EXP 24
5014: PPUSH
5015: LD_STRING D2-JMM-3
5017: PPUSH
5018: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
5022: LD_EXP 34
5026: PPUSH
5027: LD_STRING D2-Sol1-3
5029: PPUSH
5030: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
5034: LD_ADDR_VAR 0 1
5038: PUSH
5039: LD_INT 22
5041: PUSH
5042: LD_INT 8
5044: PUSH
5045: EMPTY
5046: LIST
5047: LIST
5048: PPUSH
5049: CALL_OW 69
5053: PUSH
5054: FOR_IN
5055: IFFALSE 5071
// SetSide ( i , 1 ) ;
5057: LD_VAR 0 1
5061: PPUSH
5062: LD_INT 1
5064: PPUSH
5065: CALL_OW 235
5069: GO 5054
5071: POP
5072: POP
// Say ( JMM , D2-JMM-4 ) ;
5073: LD_EXP 24
5077: PPUSH
5078: LD_STRING D2-JMM-4
5080: PPUSH
5081: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
5085: LD_INT 1
5087: PPUSH
5088: LD_INT 5
5090: PPUSH
5091: CALL_OW 332
// for i = 1 to points do
5095: LD_ADDR_VAR 0 1
5099: PUSH
5100: DOUBLE
5101: LD_INT 1
5103: DEC
5104: ST_TO_ADDR
5105: LD_VAR 0 2
5109: PUSH
5110: FOR_TO
5111: IFFALSE 5286
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
5113: LD_VAR 0 2
5117: PUSH
5118: LD_VAR 0 1
5122: ARRAY
5123: PUSH
5124: LD_INT 1
5126: ARRAY
5127: PPUSH
5128: LD_VAR 0 2
5132: PUSH
5133: LD_VAR 0 1
5137: ARRAY
5138: PUSH
5139: LD_INT 2
5141: ARRAY
5142: PPUSH
5143: CALL_OW 84
// if i = 1 then
5147: LD_VAR 0 1
5151: PUSH
5152: LD_INT 1
5154: EQUAL
5155: IFFALSE 5169
// Say ( Lynch , D2-Sol1-4 ) ;
5157: LD_EXP 34
5161: PPUSH
5162: LD_STRING D2-Sol1-4
5164: PPUSH
5165: CALL_OW 88
// if i = 2 then
5169: LD_VAR 0 1
5173: PUSH
5174: LD_INT 2
5176: EQUAL
5177: IFFALSE 5191
// Say ( JMM , D2-JMM-5 ) ;
5179: LD_EXP 24
5183: PPUSH
5184: LD_STRING D2-JMM-5
5186: PPUSH
5187: CALL_OW 88
// if i = 4 then
5191: LD_VAR 0 1
5195: PUSH
5196: LD_INT 4
5198: EQUAL
5199: IFFALSE 5223
// begin RevealFogArea ( 1 , troopsArea ) ;
5201: LD_INT 1
5203: PPUSH
5204: LD_INT 6
5206: PPUSH
5207: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
5211: LD_EXP 34
5215: PPUSH
5216: LD_STRING D2-Sol1-5
5218: PPUSH
5219: CALL_OW 88
// end ; if i = 5 then
5223: LD_VAR 0 1
5227: PUSH
5228: LD_INT 5
5230: EQUAL
5231: IFFALSE 5245
// Say ( JMM , D2-JMM-6 ) ;
5233: LD_EXP 24
5237: PPUSH
5238: LD_STRING D2-JMM-6
5240: PPUSH
5241: CALL_OW 88
// if i = 7 then
5245: LD_VAR 0 1
5249: PUSH
5250: LD_INT 7
5252: EQUAL
5253: IFFALSE 5277
// begin RevealFogArea ( 1 , forestArea ) ;
5255: LD_INT 1
5257: PPUSH
5258: LD_INT 7
5260: PPUSH
5261: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
5265: LD_EXP 34
5269: PPUSH
5270: LD_STRING D2-Sol1-6
5272: PPUSH
5273: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
5277: LD_INT 46
5279: PPUSH
5280: CALL_OW 67
// end ;
5284: GO 5110
5286: POP
5287: POP
// CenterNowOnUnits ( JMM ) ;
5288: LD_EXP 24
5292: PPUSH
5293: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
5297: LD_EXP 24
5301: PPUSH
5302: LD_STRING D2-JMM-7
5304: PPUSH
5305: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
5309: LD_EXP 34
5313: PPUSH
5314: LD_STRING D2-Sol1-7
5316: PPUSH
5317: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
5321: LD_EXP 24
5325: PPUSH
5326: LD_STRING D2-JMM-8
5328: PPUSH
5329: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
5333: LD_ADDR_VAR 0 4
5337: PUSH
5338: LD_INT 22
5340: PUSH
5341: LD_INT 1
5343: PUSH
5344: EMPTY
5345: LIST
5346: LIST
5347: PUSH
5348: LD_INT 30
5350: PUSH
5351: LD_INT 31
5353: PUSH
5354: EMPTY
5355: LIST
5356: LIST
5357: PUSH
5358: EMPTY
5359: LIST
5360: LIST
5361: PPUSH
5362: CALL_OW 69
5366: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
5367: LD_EXP 34
5371: PPUSH
5372: LD_VAR 0 4
5376: PUSH
5377: LD_INT 1
5379: ARRAY
5380: PPUSH
5381: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
5385: LD_ADDR_VAR 0 3
5389: PUSH
5390: LD_EXP 2
5394: PPUSH
5395: LD_INT 25
5397: PUSH
5398: LD_INT 1
5400: PUSH
5401: EMPTY
5402: LIST
5403: LIST
5404: PPUSH
5405: CALL_OW 72
5409: PPUSH
5410: LD_EXP 24
5414: PPUSH
5415: CALL_OW 74
5419: ST_TO_ADDR
// if sol then
5420: LD_VAR 0 3
5424: IFFALSE 5464
// if GetDistUnits ( JMM , sol ) < 10 then
5426: LD_EXP 24
5430: PPUSH
5431: LD_VAR 0 3
5435: PPUSH
5436: CALL_OW 296
5440: PUSH
5441: LD_INT 10
5443: LESS
5444: IFFALSE 5464
// ComEnterUnit ( sol , buns [ 2 ] ) ;
5446: LD_VAR 0 3
5450: PPUSH
5451: LD_VAR 0 4
5455: PUSH
5456: LD_INT 2
5458: ARRAY
5459: PPUSH
5460: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
5464: LD_INT 10
5466: PPUSH
5467: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
5471: LD_EXP 24
5475: PPUSH
5476: LD_INT 65
5478: PPUSH
5479: LD_INT 101
5481: PPUSH
5482: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
5486: LD_EXP 24
5490: PPUSH
5491: LD_INT 63
5493: PPUSH
5494: LD_INT 100
5496: PPUSH
5497: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
5501: LD_INT 35
5503: PPUSH
5504: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
5508: LD_EXP 24
5512: PPUSH
5513: LD_INT 65
5515: PPUSH
5516: LD_INT 101
5518: PPUSH
5519: CALL_OW 307
5523: IFFALSE 5501
// Say ( JMM , D2a-JMM-1 ) ;
5525: LD_EXP 24
5529: PPUSH
5530: LD_STRING D2a-JMM-1
5532: PPUSH
5533: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
5537: LD_EXP 35
5541: PPUSH
5542: LD_INT 66
5544: PPUSH
5545: LD_INT 103
5547: PPUSH
5548: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
5552: LD_INT 35
5554: PPUSH
5555: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
5559: LD_EXP 35
5563: PPUSH
5564: LD_INT 66
5566: PPUSH
5567: LD_INT 103
5569: PPUSH
5570: CALL_OW 307
5574: IFFALSE 5552
// ComTurnUnit ( Walker , JMM ) ;
5576: LD_EXP 35
5580: PPUSH
5581: LD_EXP 24
5585: PPUSH
5586: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
5590: LD_EXP 35
5594: PPUSH
5595: LD_STRING D2a-Sci1-1
5597: PPUSH
5598: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
5602: LD_EXP 24
5606: PPUSH
5607: LD_EXP 35
5611: PPUSH
5612: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
5616: LD_EXP 24
5620: PPUSH
5621: LD_STRING D2a-JMM-2
5623: PPUSH
5624: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
5628: LD_EXP 35
5632: PPUSH
5633: LD_STRING D2a-Sci1-2
5635: PPUSH
5636: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
5640: LD_EXP 24
5644: PPUSH
5645: LD_STRING D2a-JMM-3
5647: PPUSH
5648: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
5652: LD_EXP 35
5656: PPUSH
5657: LD_STRING D2a-Sci1-3
5659: PPUSH
5660: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
5664: LD_ADDR_EXP 2
5668: PUSH
5669: LD_EXP 2
5673: PUSH
5674: LD_EXP 34
5678: PUSH
5679: LD_EXP 35
5683: PUSH
5684: LD_EXP 36
5688: PUSH
5689: LD_EXP 37
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: LIST
5698: LIST
5699: ADD
5700: ST_TO_ADDR
// for i in jmm_units do
5701: LD_ADDR_VAR 0 1
5705: PUSH
5706: LD_EXP 2
5710: PUSH
5711: FOR_IN
5712: IFFALSE 5737
// if not IsInUnit ( i ) then
5714: LD_VAR 0 1
5718: PPUSH
5719: CALL_OW 310
5723: NOT
5724: IFFALSE 5735
// ComFree ( i ) ;
5726: LD_VAR 0 1
5730: PPUSH
5731: CALL_OW 139
5735: GO 5711
5737: POP
5738: POP
// InGameOff ;
5739: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
5743: LD_STRING MSolar1
5745: PPUSH
5746: CALL_OW 337
// jmm_on_west := true ;
5750: LD_ADDR_EXP 3
5754: PUSH
5755: LD_INT 1
5757: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
5758: LD_INT 1050
5760: PPUSH
5761: CALL_OW 67
// frank_can_return := true ;
5765: LD_ADDR_EXP 10
5769: PUSH
5770: LD_INT 1
5772: ST_TO_ADDR
// end ;
5773: PPOPN 4
5775: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
5776: LD_INT 22
5778: PUSH
5779: LD_INT 1
5781: PUSH
5782: EMPTY
5783: LIST
5784: LIST
5785: PUSH
5786: LD_INT 34
5788: PUSH
5789: LD_INT 51
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: PUSH
5796: LD_INT 92
5798: PUSH
5799: LD_INT 63
5801: PUSH
5802: LD_INT 100
5804: PUSH
5805: LD_INT 5
5807: PUSH
5808: EMPTY
5809: LIST
5810: LIST
5811: LIST
5812: LIST
5813: PUSH
5814: EMPTY
5815: LIST
5816: LIST
5817: LIST
5818: PUSH
5819: EMPTY
5820: LIST
5821: PPUSH
5822: CALL_OW 69
5826: PUSH
5827: LD_EXP 3
5831: NOT
5832: AND
5833: IFFALSE 5946
5835: GO 5837
5837: DISABLE
5838: LD_INT 0
5840: PPUSH
5841: PPUSH
// begin enable ;
5842: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
5843: LD_ADDR_VAR 0 2
5847: PUSH
5848: LD_INT 22
5850: PUSH
5851: LD_INT 1
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: PUSH
5858: LD_INT 34
5860: PUSH
5861: LD_INT 51
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: PUSH
5868: LD_INT 92
5870: PUSH
5871: LD_INT 63
5873: PUSH
5874: LD_INT 100
5876: PUSH
5877: LD_INT 5
5879: PUSH
5880: EMPTY
5881: LIST
5882: LIST
5883: LIST
5884: LIST
5885: PUSH
5886: EMPTY
5887: LIST
5888: LIST
5889: LIST
5890: PUSH
5891: EMPTY
5892: LIST
5893: PPUSH
5894: CALL_OW 69
5898: ST_TO_ADDR
// if not filter then
5899: LD_VAR 0 2
5903: NOT
5904: IFFALSE 5908
// exit ;
5906: GO 5946
// for i in filter do
5908: LD_ADDR_VAR 0 1
5912: PUSH
5913: LD_VAR 0 2
5917: PUSH
5918: FOR_IN
5919: IFFALSE 5944
// begin SetFuel ( i , 0 ) ;
5921: LD_VAR 0 1
5925: PPUSH
5926: LD_INT 0
5928: PPUSH
5929: CALL_OW 240
// ComStop ( i ) ;
5933: LD_VAR 0 1
5937: PPUSH
5938: CALL_OW 141
// end ;
5942: GO 5918
5944: POP
5945: POP
// end ;
5946: PPOPN 2
5948: END
// every 0 0$10 trigger frank_can_return do var i , points ;
5949: LD_EXP 10
5953: IFFALSE 6948
5955: GO 5957
5957: DISABLE
5958: LD_INT 0
5960: PPUSH
5961: PPUSH
// begin uc_side := 8 ;
5962: LD_ADDR_OWVAR 20
5966: PUSH
5967: LD_INT 8
5969: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
5970: LD_ADDR_VAR 0 2
5974: PUSH
5975: LD_INT 59
5977: PUSH
5978: LD_INT 71
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: PUSH
5985: LD_INT 122
5987: PUSH
5988: LD_INT 117
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
5999: LD_ADDR_EXP 38
6003: PUSH
6004: LD_STRING Frank
6006: PPUSH
6007: LD_INT 0
6009: PPUSH
6010: CALL 353 0 2
6014: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
6015: LD_ADDR_VAR 0 1
6019: PUSH
6020: LD_INT 1
6022: PPUSH
6023: LD_INT 2
6025: PPUSH
6026: CALL_OW 12
6030: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
6031: LD_EXP 38
6035: PPUSH
6036: LD_VAR 0 2
6040: PUSH
6041: LD_VAR 0 1
6045: ARRAY
6046: PUSH
6047: LD_INT 1
6049: ARRAY
6050: PPUSH
6051: LD_VAR 0 2
6055: PUSH
6056: LD_VAR 0 1
6060: ARRAY
6061: PUSH
6062: LD_INT 2
6064: ARRAY
6065: PPUSH
6066: LD_INT 0
6068: PPUSH
6069: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
6073: LD_EXP 38
6077: PPUSH
6078: LD_INT 1
6080: PPUSH
6081: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
6085: LD_INT 35
6087: PPUSH
6088: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
6092: LD_EXP 38
6096: PPUSH
6097: LD_EXP 24
6101: PPUSH
6102: CALL_OW 296
6106: PUSH
6107: LD_INT 8
6109: LESS
6110: IFFALSE 6085
// InGameOn ;
6112: CALL_OW 8
// if IsInUnit ( JMM ) then
6116: LD_EXP 24
6120: PPUSH
6121: CALL_OW 310
6125: IFFALSE 6136
// ComFree ( JMM ) ;
6127: LD_EXP 24
6131: PPUSH
6132: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
6136: LD_EXP 24
6140: PPUSH
6141: LD_EXP 38
6145: PPUSH
6146: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
6150: LD_EXP 38
6154: PPUSH
6155: LD_EXP 24
6159: PPUSH
6160: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
6164: LD_EXP 24
6168: PPUSH
6169: LD_STRING D6-JMM-1
6171: PPUSH
6172: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
6176: LD_INT 35
6178: PPUSH
6179: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
6183: LD_EXP 24
6187: PPUSH
6188: LD_EXP 38
6192: PPUSH
6193: CALL_OW 296
6197: PUSH
6198: LD_INT 8
6200: LESS
6201: IFFALSE 6176
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
6203: LD_EXP 27
6207: PUSH
6208: LD_EXP 27
6212: PPUSH
6213: LD_EXP 38
6217: PPUSH
6218: CALL_OW 296
6222: PUSH
6223: LD_INT 20
6225: LESS
6226: AND
6227: IFFALSE 6252
// begin ComFree ( Lisa ) ;
6229: LD_EXP 27
6233: PPUSH
6234: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
6238: LD_EXP 27
6242: PPUSH
6243: LD_EXP 38
6247: PPUSH
6248: CALL_OW 172
// end ; if Lynch then
6252: LD_EXP 34
6256: IFFALSE 6281
// begin ComFree ( Lynch ) ;
6258: LD_EXP 34
6262: PPUSH
6263: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
6267: LD_EXP 34
6271: PPUSH
6272: LD_EXP 38
6276: PPUSH
6277: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
6281: LD_EXP 24
6285: PPUSH
6286: LD_EXP 38
6290: PPUSH
6291: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
6295: LD_EXP 38
6299: PPUSH
6300: LD_EXP 24
6304: PPUSH
6305: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
6309: LD_EXP 38
6313: PPUSH
6314: LD_STRING D6-Frank-1
6316: PPUSH
6317: CALL_OW 88
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
6321: LD_EXP 27
6325: PUSH
6326: LD_EXP 27
6330: PPUSH
6331: LD_EXP 38
6335: PPUSH
6336: CALL_OW 296
6340: PUSH
6341: LD_INT 20
6343: LESS
6344: AND
6345: PUSH
6346: LD_EXP 27
6350: PPUSH
6351: CALL_OW 302
6355: AND
6356: IFFALSE 6437
// begin repeat wait ( 0 0$01 ) ;
6358: LD_INT 35
6360: PPUSH
6361: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
6365: LD_EXP 27
6369: PPUSH
6370: LD_EXP 38
6374: PPUSH
6375: CALL_OW 296
6379: PUSH
6380: LD_INT 7
6382: LESS
6383: IFFALSE 6358
// Say ( Lisa , D6-Lisa-1 ) ;
6385: LD_EXP 27
6389: PPUSH
6390: LD_STRING D6-Lisa-1
6392: PPUSH
6393: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
6397: LD_EXP 27
6401: PPUSH
6402: LD_EXP 38
6406: PPUSH
6407: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
6411: LD_EXP 38
6415: PPUSH
6416: LD_EXP 27
6420: PPUSH
6421: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
6425: LD_EXP 38
6429: PPUSH
6430: LD_STRING D6-Frank-2
6432: PPUSH
6433: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
6437: LD_EXP 34
6441: PUSH
6442: LD_EXP 34
6446: PPUSH
6447: LD_EXP 38
6451: PPUSH
6452: CALL_OW 296
6456: PUSH
6457: LD_INT 20
6459: LESS
6460: AND
6461: PUSH
6462: LD_EXP 34
6466: PPUSH
6467: CALL_OW 302
6471: AND
6472: IFFALSE 6653
// begin ComTurnUnit ( Lynch , JMM ) ;
6474: LD_EXP 34
6478: PPUSH
6479: LD_EXP 24
6483: PPUSH
6484: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
6488: LD_EXP 38
6492: PPUSH
6493: LD_EXP 24
6497: PPUSH
6498: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
6502: LD_EXP 34
6506: PPUSH
6507: LD_STRING D6-Sol1-2
6509: PPUSH
6510: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
6514: LD_EXP 24
6518: PPUSH
6519: LD_STRING D6-JMM-2
6521: PPUSH
6522: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
6526: LD_EXP 38
6530: PPUSH
6531: LD_STRING D6-Frank-3
6533: PPUSH
6534: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
6538: LD_EXP 24
6542: PPUSH
6543: LD_STRING D6-JMM-3
6545: PPUSH
6546: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
6550: LD_EXP 38
6554: PPUSH
6555: LD_STRING D6-Frank-4
6557: PPUSH
6558: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
6562: LD_EXP 38
6566: PPUSH
6567: LD_STRING D6-Frank-4a
6569: PPUSH
6570: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
6574: LD_EXP 24
6578: PPUSH
6579: LD_STRING D6-JMM-4
6581: PPUSH
6582: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
6586: LD_EXP 38
6590: PPUSH
6591: LD_STRING D6-Frank-5
6593: PPUSH
6594: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
6598: LD_EXP 27
6602: PUSH
6603: LD_EXP 27
6607: PPUSH
6608: CALL_OW 302
6612: AND
6613: IFFALSE 6627
// Say ( Lisa , D6-Lisa-5 ) ;
6615: LD_EXP 27
6619: PPUSH
6620: LD_STRING D6-Lisa-5
6622: PPUSH
6623: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
6627: LD_EXP 38
6631: PPUSH
6632: LD_STRING D6-Frank-6
6634: PPUSH
6635: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
6639: LD_EXP 24
6643: PPUSH
6644: LD_STRING D6-JMM-6
6646: PPUSH
6647: CALL_OW 88
// end else
6651: GO 6768
// begin ComTurnUnit ( Frank , JMM ) ;
6653: LD_EXP 38
6657: PPUSH
6658: LD_EXP 24
6662: PPUSH
6663: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
6667: LD_EXP 38
6671: PPUSH
6672: LD_STRING D6-Frank-4
6674: PPUSH
6675: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
6679: LD_EXP 38
6683: PPUSH
6684: LD_STRING D6-Frank-4a
6686: PPUSH
6687: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
6691: LD_EXP 24
6695: PPUSH
6696: LD_STRING D6-JMM-4
6698: PPUSH
6699: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
6703: LD_EXP 38
6707: PPUSH
6708: LD_STRING D6-Frank-5
6710: PPUSH
6711: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
6715: LD_EXP 27
6719: PUSH
6720: LD_EXP 27
6724: PPUSH
6725: CALL_OW 302
6729: AND
6730: IFFALSE 6744
// Say ( Lisa , D6-Lisa-5 ) ;
6732: LD_EXP 27
6736: PPUSH
6737: LD_STRING D6-Lisa-5
6739: PPUSH
6740: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
6744: LD_EXP 38
6748: PPUSH
6749: LD_STRING D6-Frank-6
6751: PPUSH
6752: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
6756: LD_EXP 24
6760: PPUSH
6761: LD_STRING D6-JMM-6
6763: PPUSH
6764: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
6768: LD_STRING Q1
6770: PPUSH
6771: CALL_OW 97
6775: PUSH
6776: LD_INT 1
6778: DOUBLE
6779: EQUAL
6780: IFTRUE 6784
6782: GO 6795
6784: POP
// frank_send_to_scout := true ; 2 :
6785: LD_ADDR_EXP 12
6789: PUSH
6790: LD_INT 1
6792: ST_TO_ADDR
6793: GO 6815
6795: LD_INT 2
6797: DOUBLE
6798: EQUAL
6799: IFTRUE 6803
6801: GO 6814
6803: POP
// frank_send_to_scout := false ; end ;
6804: LD_ADDR_EXP 12
6808: PUSH
6809: LD_INT 0
6811: ST_TO_ADDR
6812: GO 6815
6814: POP
// InGameOff ;
6815: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
6819: LD_EXP 24
6823: PUSH
6824: LD_EXP 27
6828: PUSH
6829: LD_EXP 34
6833: PUSH
6834: EMPTY
6835: LIST
6836: LIST
6837: LIST
6838: PPUSH
6839: CALL_OW 139
// if frank_send_to_scout then
6843: LD_EXP 12
6847: IFFALSE 6904
// begin ComMoveXY ( Frank , 130 , 123 ) ;
6849: LD_EXP 38
6853: PPUSH
6854: LD_INT 130
6856: PPUSH
6857: LD_INT 123
6859: PPUSH
6860: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
6864: LD_INT 35
6866: PPUSH
6867: CALL_OW 67
// until not See ( 1 , Frank ) ;
6871: LD_INT 1
6873: PPUSH
6874: LD_EXP 38
6878: PPUSH
6879: CALL_OW 292
6883: NOT
6884: IFFALSE 6864
// Wait ( 0 0$02 ) ;
6886: LD_INT 70
6888: PPUSH
6889: CALL_OW 67
// RemoveUnit ( Frank ) ;
6893: LD_EXP 38
6897: PPUSH
6898: CALL_OW 64
// end else
6902: GO 6916
// SetSide ( Frank , 1 ) ;
6904: LD_EXP 38
6908: PPUSH
6909: LD_INT 1
6911: PPUSH
6912: CALL_OW 235
// Wait ( [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ) ;
6916: LD_INT 25200
6918: PUSH
6919: LD_INT 23100
6921: PUSH
6922: LD_INT 21000
6924: PUSH
6925: EMPTY
6926: LIST
6927: LIST
6928: LIST
6929: PUSH
6930: LD_OWVAR 67
6934: ARRAY
6935: PPUSH
6936: CALL_OW 67
// cornel_prepared := true ;
6940: LD_ADDR_EXP 9
6944: PUSH
6945: LD_INT 1
6947: ST_TO_ADDR
// end ;
6948: PPOPN 2
6950: END
// every 0 0$01 trigger cornel_prepared do
6951: LD_EXP 9
6955: IFFALSE 7175
6957: GO 6959
6959: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
6960: LD_EXP 31
6964: PPUSH
6965: LD_STRING D3-Corn-1
6967: PPUSH
6968: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
6972: LD_INT 35
6974: PPUSH
6975: CALL_OW 67
// until cornel_counter = 0 ;
6979: LD_EXP 8
6983: PUSH
6984: LD_INT 0
6986: EQUAL
6987: IFFALSE 6972
// SayRadio ( Cornel , D3a-Corn-1 ) ;
6989: LD_EXP 31
6993: PPUSH
6994: LD_STRING D3a-Corn-1
6996: PPUSH
6997: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
7001: LD_EXP 24
7005: PPUSH
7006: LD_STRING D3a-JMM-1
7008: PPUSH
7009: CALL_OW 88
// end_mission_allowed := true ;
7013: LD_ADDR_EXP 18
7017: PUSH
7018: LD_INT 1
7020: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
7021: LD_STRING M2
7023: PPUSH
7024: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
7028: LD_INT 9
7030: PPUSH
7031: LD_INT 1
7033: PPUSH
7034: CALL_OW 424
// Wait ( 0 0$05 ) ;
7038: LD_INT 175
7040: PPUSH
7041: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
7045: LD_EXP 31
7049: PPUSH
7050: LD_STRING D3a-Corn-2
7052: PPUSH
7053: CALL_OW 94
// cornel_attack := true ;
7057: LD_ADDR_EXP 7
7061: PUSH
7062: LD_INT 1
7064: ST_TO_ADDR
// if frank_send_to_scout then
7065: LD_EXP 12
7069: IFFALSE 7175
// begin InitHc ;
7071: CALL_OW 19
// InitUc ;
7075: CALL_OW 18
// uc_side := 8 ;
7079: LD_ADDR_OWVAR 20
7083: PUSH
7084: LD_INT 8
7086: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
7087: LD_ADDR_EXP 38
7091: PUSH
7092: LD_STRING Frank
7094: PPUSH
7095: LD_INT 0
7097: PPUSH
7098: CALL 353 0 2
7102: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
7103: LD_EXP 38
7107: PPUSH
7108: LD_INT 6
7110: PPUSH
7111: LD_INT 9
7113: PPUSH
7114: LD_INT 0
7116: PPUSH
7117: CALL_OW 48
// ComCrawl ( Frank ) ;
7121: LD_EXP 38
7125: PPUSH
7126: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
7130: LD_INT 35
7132: PPUSH
7133: CALL_OW 67
// until See ( 1 , Frank ) ;
7137: LD_INT 1
7139: PPUSH
7140: LD_EXP 38
7144: PPUSH
7145: CALL_OW 292
7149: IFFALSE 7130
// SetSide ( Frank , 1 ) ;
7151: LD_EXP 38
7155: PPUSH
7156: LD_INT 1
7158: PPUSH
7159: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
7163: LD_EXP 38
7167: PPUSH
7168: LD_STRING D6a-Frank-1
7170: PPUSH
7171: CALL_OW 88
// end ; end ;
7175: END
// every 0 0$01 trigger solar_builded do
7176: LD_EXP 11
7180: IFFALSE 7284
7182: GO 7184
7184: DISABLE
// begin Wait ( 0 0$02 ) ;
7185: LD_INT 70
7187: PPUSH
7188: CALL_OW 67
// DialogueOn ;
7192: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
7196: LD_EXP 24
7200: PPUSH
7201: LD_STRING D2b-JMM-1
7203: PPUSH
7204: CALL_OW 88
// if Walker and IsOk ( Walker ) then
7208: LD_EXP 35
7212: PUSH
7213: LD_EXP 35
7217: PPUSH
7218: CALL_OW 302
7222: AND
7223: IFFALSE 7273
// begin Say ( Walker , D2b-Sci1-1 ) ;
7225: LD_EXP 35
7229: PPUSH
7230: LD_STRING D2b-Sci1-1
7232: PPUSH
7233: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
7237: LD_EXP 24
7241: PPUSH
7242: LD_STRING D2b-JMM-2
7244: PPUSH
7245: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
7249: LD_EXP 35
7253: PPUSH
7254: LD_STRING D2b-Sci1-2
7256: PPUSH
7257: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
7261: LD_EXP 24
7265: PPUSH
7266: LD_STRING D2b-JMM-3
7268: PPUSH
7269: CALL_OW 88
// end ; DialogueOff ;
7273: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
7277: LD_STRING MOutSol
7279: PPUSH
7280: CALL_OW 337
// end ;
7284: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
7285: LD_EXP 11
7289: PUSH
7290: LD_EXP 24
7294: PPUSH
7295: CALL_OW 302
7299: AND
7300: PUSH
7301: LD_EXP 24
7305: PPUSH
7306: CALL 806 0 1
7310: AND
7311: PUSH
7312: LD_EXP 13
7316: NOT
7317: AND
7318: IFFALSE 7389
7320: GO 7322
7322: DISABLE
7323: LD_INT 0
7325: PPUSH
// begin jmm_in_veh := true ;
7326: LD_ADDR_EXP 13
7330: PUSH
7331: LD_INT 1
7333: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
7334: LD_ADDR_VAR 0 1
7338: PUSH
7339: LD_INT 0
7341: PPUSH
7342: LD_INT 1
7344: PPUSH
7345: CALL_OW 12
7349: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
7350: LD_INT 70
7352: PPUSH
7353: CALL_OW 67
// if i then
7357: LD_VAR 0 1
7361: IFFALSE 7377
// Say ( JMM , D2c-JMM-1 ) else
7363: LD_EXP 24
7367: PPUSH
7368: LD_STRING D2c-JMM-1
7370: PPUSH
7371: CALL_OW 88
7375: GO 7389
// Say ( JMM , D2c-JMM-1a ) ;
7377: LD_EXP 24
7381: PPUSH
7382: LD_STRING D2c-JMM-1a
7384: PPUSH
7385: CALL_OW 88
// end ;
7389: PPOPN 1
7391: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
7392: LD_EXP 11
7396: PUSH
7397: LD_EXP 25
7401: PPUSH
7402: CALL_OW 302
7406: AND
7407: PUSH
7408: LD_EXP 25
7412: PPUSH
7413: CALL 806 0 1
7417: AND
7418: PUSH
7419: LD_EXP 14
7423: NOT
7424: AND
7425: IFFALSE 7457
7427: GO 7429
7429: DISABLE
// begin bobby_in_veh := true ;
7430: LD_ADDR_EXP 14
7434: PUSH
7435: LD_INT 1
7437: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
7438: LD_INT 70
7440: PPUSH
7441: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
7445: LD_EXP 25
7449: PPUSH
7450: LD_STRING D2c-Bobby-1
7452: PPUSH
7453: CALL_OW 88
7457: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
7458: LD_EXP 11
7462: PUSH
7463: LD_EXP 27
7467: PPUSH
7468: CALL_OW 302
7472: AND
7473: PUSH
7474: LD_EXP 27
7478: PPUSH
7479: CALL 806 0 1
7483: AND
7484: PUSH
7485: LD_EXP 16
7489: NOT
7490: AND
7491: IFFALSE 7523
7493: GO 7495
7495: DISABLE
// begin lisa_in_veh := true ;
7496: LD_ADDR_EXP 16
7500: PUSH
7501: LD_INT 1
7503: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
7504: LD_INT 70
7506: PPUSH
7507: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
7511: LD_EXP 27
7515: PPUSH
7516: LD_STRING D2c-Lisa-1
7518: PPUSH
7519: CALL_OW 88
7523: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
7524: LD_EXP 11
7528: PUSH
7529: LD_EXP 26
7533: PPUSH
7534: CALL_OW 302
7538: AND
7539: PUSH
7540: LD_EXP 26
7544: PPUSH
7545: CALL 806 0 1
7549: AND
7550: PUSH
7551: LD_EXP 15
7555: NOT
7556: AND
7557: IFFALSE 7628
7559: GO 7561
7561: DISABLE
7562: LD_INT 0
7564: PPUSH
// begin cyrus_in_veh := true ;
7565: LD_ADDR_EXP 15
7569: PUSH
7570: LD_INT 1
7572: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
7573: LD_ADDR_VAR 0 1
7577: PUSH
7578: LD_INT 0
7580: PPUSH
7581: LD_INT 1
7583: PPUSH
7584: CALL_OW 12
7588: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
7589: LD_INT 70
7591: PPUSH
7592: CALL_OW 67
// if i then
7596: LD_VAR 0 1
7600: IFFALSE 7616
// Say ( Cyrus , D2c-Cyrus-1 ) else
7602: LD_EXP 26
7606: PPUSH
7607: LD_STRING D2c-Cyrus-1
7609: PPUSH
7610: CALL_OW 88
7614: GO 7628
// Say ( Cyrus , D2c-Cyrus-1a ) ;
7616: LD_EXP 26
7620: PPUSH
7621: LD_STRING D2c-Cyrus-1a
7623: PPUSH
7624: CALL_OW 88
// end ;
7628: PPOPN 1
7630: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) do var i , filter ;
7631: LD_INT 9
7633: PPUSH
7634: LD_INT 22
7636: PUSH
7637: LD_INT 1
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: PPUSH
7644: CALL_OW 70
7648: IFFALSE 8364
7650: GO 7652
7652: DISABLE
7653: LD_INT 0
7655: PPUSH
7656: PPUSH
// begin enable ;
7657: ENABLE
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
7658: LD_ADDR_VAR 0 2
7662: PUSH
7663: LD_INT 9
7665: PPUSH
7666: LD_INT 22
7668: PUSH
7669: LD_INT 1
7671: PUSH
7672: EMPTY
7673: LIST
7674: LIST
7675: PPUSH
7676: CALL_OW 70
7680: ST_TO_ADDR
// if not filter then
7681: LD_VAR 0 2
7685: NOT
7686: IFFALSE 7690
// exit ;
7688: GO 8364
// for i in filter do
7690: LD_ADDR_VAR 0 1
7694: PUSH
7695: LD_VAR 0 2
7699: PUSH
7700: FOR_IN
7701: IFFALSE 8362
// begin if i = JMM then
7703: LD_VAR 0 1
7707: PUSH
7708: LD_EXP 24
7712: EQUAL
7713: IFFALSE 7846
// begin if show_query then
7715: LD_EXP 21
7719: IFFALSE 7776
// begin show_query := false ;
7721: LD_ADDR_EXP 21
7725: PUSH
7726: LD_INT 0
7728: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
7729: LD_STRING Q2
7731: PPUSH
7732: CALL_OW 97
7736: PUSH
7737: LD_INT 1
7739: DOUBLE
7740: EQUAL
7741: IFTRUE 7745
7743: GO 7756
7745: POP
// wait_for_them := true ; 2 :
7746: LD_ADDR_EXP 22
7750: PUSH
7751: LD_INT 1
7753: ST_TO_ADDR
7754: GO 7776
7756: LD_INT 2
7758: DOUBLE
7759: EQUAL
7760: IFTRUE 7764
7762: GO 7775
7764: POP
// wait_for_them := false ; end ;
7765: LD_ADDR_EXP 22
7769: PUSH
7770: LD_INT 0
7772: ST_TO_ADDR
7773: GO 7776
7775: POP
// end ; if not wait_for_them or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 1 then
7776: LD_EXP 22
7780: NOT
7781: PUSH
7782: LD_INT 22
7784: PUSH
7785: LD_INT 1
7787: PUSH
7788: EMPTY
7789: LIST
7790: LIST
7791: PUSH
7792: LD_INT 21
7794: PUSH
7795: LD_INT 1
7797: PUSH
7798: EMPTY
7799: LIST
7800: LIST
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: PPUSH
7806: CALL_OW 69
7810: PUSH
7811: LD_INT 1
7813: EQUAL
7814: OR
7815: IFFALSE 7846
// begin save_group := save_group ^ JMM ;
7817: LD_ADDR_EXP 20
7821: PUSH
7822: LD_EXP 20
7826: PUSH
7827: LD_EXP 24
7831: ADD
7832: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
7833: LD_EXP 24
7837: PPUSH
7838: CALL_OW 64
// EndMission ;
7842: CALL 8367 0 0
// end ; end ; if i = Lisa then
7846: LD_VAR 0 1
7850: PUSH
7851: LD_EXP 27
7855: EQUAL
7856: IFFALSE 7883
// begin save_group := save_group ^ Lisa ;
7858: LD_ADDR_EXP 20
7862: PUSH
7863: LD_EXP 20
7867: PUSH
7868: LD_EXP 27
7872: ADD
7873: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
7874: LD_EXP 27
7878: PPUSH
7879: CALL_OW 64
// end ; if i = Bobby then
7883: LD_VAR 0 1
7887: PUSH
7888: LD_EXP 25
7892: EQUAL
7893: IFFALSE 7920
// begin save_group := save_group ^ Bobby ;
7895: LD_ADDR_EXP 20
7899: PUSH
7900: LD_EXP 20
7904: PUSH
7905: LD_EXP 25
7909: ADD
7910: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
7911: LD_EXP 25
7915: PPUSH
7916: CALL_OW 64
// end ; if i = Cyrus then
7920: LD_VAR 0 1
7924: PUSH
7925: LD_EXP 26
7929: EQUAL
7930: IFFALSE 7957
// begin save_group := save_group ^ Cyrus ;
7932: LD_ADDR_EXP 20
7936: PUSH
7937: LD_EXP 20
7941: PUSH
7942: LD_EXP 26
7946: ADD
7947: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
7948: LD_EXP 26
7952: PPUSH
7953: CALL_OW 64
// end ; if i = Khatam then
7957: LD_VAR 0 1
7961: PUSH
7962: LD_EXP 28
7966: EQUAL
7967: IFFALSE 7994
// begin save_group := save_group ^ Khatam ;
7969: LD_ADDR_EXP 20
7973: PUSH
7974: LD_EXP 20
7978: PUSH
7979: LD_EXP 28
7983: ADD
7984: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
7985: LD_EXP 28
7989: PPUSH
7990: CALL_OW 64
// end ; if i = Jerry then
7994: LD_VAR 0 1
7998: PUSH
7999: LD_EXP 30
8003: EQUAL
8004: IFFALSE 8031
// begin save_group := save_group ^ Jerry ;
8006: LD_ADDR_EXP 20
8010: PUSH
8011: LD_EXP 20
8015: PUSH
8016: LD_EXP 30
8020: ADD
8021: ST_TO_ADDR
// RemoveUnit ( Jerry ) ;
8022: LD_EXP 30
8026: PPUSH
8027: CALL_OW 64
// end ; if i = Brian then
8031: LD_VAR 0 1
8035: PUSH
8036: LD_EXP 29
8040: EQUAL
8041: IFFALSE 8068
// begin save_group := save_group ^ Brian ;
8043: LD_ADDR_EXP 20
8047: PUSH
8048: LD_EXP 20
8052: PUSH
8053: LD_EXP 29
8057: ADD
8058: ST_TO_ADDR
// RemoveUnit ( Brian ) ;
8059: LD_EXP 29
8063: PPUSH
8064: CALL_OW 64
// end ; if i = Lynch then
8068: LD_VAR 0 1
8072: PUSH
8073: LD_EXP 34
8077: EQUAL
8078: IFFALSE 8105
// begin save_group := save_group ^ Lynch ;
8080: LD_ADDR_EXP 20
8084: PUSH
8085: LD_EXP 20
8089: PUSH
8090: LD_EXP 34
8094: ADD
8095: ST_TO_ADDR
// RemoveUnit ( Lynch ) ;
8096: LD_EXP 34
8100: PPUSH
8101: CALL_OW 64
// end ; if i = Turner then
8105: LD_VAR 0 1
8109: PUSH
8110: LD_EXP 36
8114: EQUAL
8115: IFFALSE 8142
// begin save_group := save_group ^ Turner ;
8117: LD_ADDR_EXP 20
8121: PUSH
8122: LD_EXP 20
8126: PUSH
8127: LD_EXP 36
8131: ADD
8132: ST_TO_ADDR
// RemoveUnit ( Turner ) ;
8133: LD_EXP 36
8137: PPUSH
8138: CALL_OW 64
// end ; if i = Jillian then
8142: LD_VAR 0 1
8146: PUSH
8147: LD_EXP 37
8151: EQUAL
8152: IFFALSE 8179
// begin save_group := save_group ^ Jillian ;
8154: LD_ADDR_EXP 20
8158: PUSH
8159: LD_EXP 20
8163: PUSH
8164: LD_EXP 37
8168: ADD
8169: ST_TO_ADDR
// RemoveUnit ( Jillian ) ;
8170: LD_EXP 37
8174: PPUSH
8175: CALL_OW 64
// end ; if i = Walker then
8179: LD_VAR 0 1
8183: PUSH
8184: LD_EXP 35
8188: EQUAL
8189: IFFALSE 8216
// begin save_group := save_group ^ Walker ;
8191: LD_ADDR_EXP 20
8195: PUSH
8196: LD_EXP 20
8200: PUSH
8201: LD_EXP 35
8205: ADD
8206: ST_TO_ADDR
// RemoveUnit ( Walker ) ;
8207: LD_EXP 35
8211: PPUSH
8212: CALL_OW 64
// end ; if i = Frank then
8216: LD_VAR 0 1
8220: PUSH
8221: LD_EXP 38
8225: EQUAL
8226: IFFALSE 8253
// begin save_group := save_group ^ Frank ;
8228: LD_ADDR_EXP 20
8232: PUSH
8233: LD_EXP 20
8237: PUSH
8238: LD_EXP 38
8242: ADD
8243: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
8244: LD_EXP 38
8248: PPUSH
8249: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and not i in save_group then
8253: LD_VAR 0 1
8257: PPUSH
8258: CALL_OW 302
8262: PUSH
8263: LD_VAR 0 1
8267: PPUSH
8268: CALL_OW 247
8272: PUSH
8273: LD_INT 1
8275: EQUAL
8276: AND
8277: PUSH
8278: LD_VAR 0 1
8282: PUSH
8283: LD_EXP 20
8287: IN
8288: NOT
8289: AND
8290: IFFALSE 8317
// begin save_others := save_others ^ i ;
8292: LD_ADDR_EXP 19
8296: PUSH
8297: LD_EXP 19
8301: PUSH
8302: LD_VAR 0 1
8306: ADD
8307: ST_TO_ADDR
// RemoveUnit ( i ) ;
8308: LD_VAR 0 1
8312: PPUSH
8313: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_vehicle then
8317: LD_VAR 0 1
8321: PPUSH
8322: CALL_OW 302
8326: PUSH
8327: LD_VAR 0 1
8331: PPUSH
8332: CALL_OW 247
8336: PUSH
8337: LD_INT 2
8339: EQUAL
8340: AND
8341: IFFALSE 8360
// begin veh_on_meta := true ;
8343: LD_ADDR_EXP 23
8347: PUSH
8348: LD_INT 1
8350: ST_TO_ADDR
// RemoveUnit ( i ) ;
8351: LD_VAR 0 1
8355: PPUSH
8356: CALL_OW 64
// end ; end ;
8360: GO 7700
8362: POP
8363: POP
// end ;
8364: PPOPN 2
8366: END
// export function EndMission ; var counter ; begin
8367: LD_INT 0
8369: PPUSH
8370: PPUSH
// if solar_builded then
8371: LD_EXP 11
8375: IFFALSE 8389
// AddMedal ( Solar1 , 1 ) else
8377: LD_STRING Solar1
8379: PPUSH
8380: LD_INT 1
8382: PPUSH
8383: CALL_OW 101
8387: GO 8400
// AddMedal ( Solar1 , - 1 ) ;
8389: LD_STRING Solar1
8391: PPUSH
8392: LD_INT 1
8394: NEG
8395: PPUSH
8396: CALL_OW 101
// if veh_on_meta then
8400: LD_EXP 23
8404: IFFALSE 8418
// AddMedal ( Solar2 , 1 ) else
8406: LD_STRING Solar2
8408: PPUSH
8409: LD_INT 1
8411: PPUSH
8412: CALL_OW 101
8416: GO 8448
// if solar_builded then
8418: LD_EXP 11
8422: IFFALSE 8437
// AddMedal ( Solar2 , - 1 ) else
8424: LD_STRING Solar2
8426: PPUSH
8427: LD_INT 1
8429: NEG
8430: PPUSH
8431: CALL_OW 101
8435: GO 8448
// AddMedal ( Solar2 , - 2 ) ;
8437: LD_STRING Solar2
8439: PPUSH
8440: LD_INT 2
8442: NEG
8443: PPUSH
8444: CALL_OW 101
// counter := save_group ^ save_others ;
8448: LD_ADDR_VAR 0 2
8452: PUSH
8453: LD_EXP 20
8457: PUSH
8458: LD_EXP 19
8462: ADD
8463: ST_TO_ADDR
// if counter = 10 then
8464: LD_VAR 0 2
8468: PUSH
8469: LD_INT 10
8471: EQUAL
8472: IFFALSE 8486
// AddMedal ( No , 1 ) else
8474: LD_STRING No
8476: PPUSH
8477: LD_INT 1
8479: PPUSH
8480: CALL_OW 101
8484: GO 8530
// if counter < 10 and counter > 6 then
8486: LD_VAR 0 2
8490: PUSH
8491: LD_INT 10
8493: LESS
8494: PUSH
8495: LD_VAR 0 2
8499: PUSH
8500: LD_INT 6
8502: GREATER
8503: AND
8504: IFFALSE 8519
// AddMedal ( No , - 1 ) else
8506: LD_STRING No
8508: PPUSH
8509: LD_INT 1
8511: NEG
8512: PPUSH
8513: CALL_OW 101
8517: GO 8530
// AddMedal ( UpTo4 , - 1 ) ;
8519: LD_STRING UpTo4
8521: PPUSH
8522: LD_INT 1
8524: NEG
8525: PPUSH
8526: CALL_OW 101
// GiveMedals ( MAIN ) ;
8530: LD_STRING MAIN
8532: PPUSH
8533: CALL_OW 102
// RewardPeople ( save_group ^ save_others ) ;
8537: LD_EXP 20
8541: PUSH
8542: LD_EXP 19
8546: ADD
8547: PPUSH
8548: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
8552: LD_EXP 24
8556: PPUSH
8557: LD_STRING JMM
8559: PPUSH
8560: CALL_OW 38
// if Bobby in save_group then
8564: LD_EXP 25
8568: PUSH
8569: LD_EXP 20
8573: IN
8574: IFFALSE 8588
// SaveCharacters ( Bobby , Bobby ) ;
8576: LD_EXP 25
8580: PPUSH
8581: LD_STRING Bobby
8583: PPUSH
8584: CALL_OW 38
// if Cyrus in save_group then
8588: LD_EXP 26
8592: PUSH
8593: LD_EXP 20
8597: IN
8598: IFFALSE 8612
// SaveCharacters ( Cyrus , Cyrus ) ;
8600: LD_EXP 26
8604: PPUSH
8605: LD_STRING Cyrus
8607: PPUSH
8608: CALL_OW 38
// if Lisa in save_group then
8612: LD_EXP 27
8616: PUSH
8617: LD_EXP 20
8621: IN
8622: IFFALSE 8636
// SaveCharacters ( Lisa , Lisa ) ;
8624: LD_EXP 27
8628: PPUSH
8629: LD_STRING Lisa
8631: PPUSH
8632: CALL_OW 38
// if Frank in save_group then
8636: LD_EXP 38
8640: PUSH
8641: LD_EXP 20
8645: IN
8646: IFFALSE 8660
// SaveCharacters ( Frank , Frank ) ;
8648: LD_EXP 38
8652: PPUSH
8653: LD_STRING Frank
8655: PPUSH
8656: CALL_OW 38
// if Khatam in save_group then
8660: LD_EXP 28
8664: PUSH
8665: LD_EXP 20
8669: IN
8670: IFFALSE 8684
// SaveCharacters ( Khatam , Khatam ) ;
8672: LD_EXP 28
8676: PPUSH
8677: LD_STRING Khatam
8679: PPUSH
8680: CALL_OW 38
// if save_others then
8684: LD_EXP 19
8688: IFFALSE 8702
// SaveCharacters ( save_others , 03_others ) ;
8690: LD_EXP 19
8694: PPUSH
8695: LD_STRING 03_others
8697: PPUSH
8698: CALL_OW 38
// YouWin ;
8702: CALL_OW 103
// end ; end_of_file
8706: LD_VAR 0 1
8710: RET
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
8711: LD_EXP 6
8715: IFFALSE 9705
8717: GO 8719
8719: DISABLE
8720: LD_INT 0
8722: PPUSH
8723: PPUSH
8724: PPUSH
8725: PPUSH
8726: PPUSH
8727: PPUSH
8728: PPUSH
8729: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
8730: LD_EXP 31
8734: PUSH
8735: LD_EXP 32
8739: ADD
8740: PUSH
8741: LD_EXP 4
8745: ADD
8746: PPUSH
8747: LD_INT 250
8749: PPUSH
8750: LD_INT 120
8752: PPUSH
8753: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
8757: LD_ADDR_VAR 0 2
8761: PUSH
8762: LD_EXP 4
8766: PPUSH
8767: LD_INT 25
8769: PUSH
8770: LD_INT 2
8772: PUSH
8773: EMPTY
8774: LIST
8775: LIST
8776: PPUSH
8777: CALL_OW 72
8781: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
8782: LD_ADDR_VAR 0 3
8786: PUSH
8787: LD_EXP 4
8791: PPUSH
8792: LD_INT 21
8794: PUSH
8795: LD_INT 1
8797: PUSH
8798: EMPTY
8799: LIST
8800: LIST
8801: PPUSH
8802: CALL_OW 72
8806: ST_TO_ADDR
// if not has_eng then
8807: LD_VAR 0 2
8811: NOT
8812: IFFALSE 8895
// begin uc_side := 4 ;
8814: LD_ADDR_OWVAR 20
8818: PUSH
8819: LD_INT 4
8821: ST_TO_ADDR
// uc_nation := 1 ;
8822: LD_ADDR_OWVAR 21
8826: PUSH
8827: LD_INT 1
8829: ST_TO_ADDR
// bc_type := b_depot ;
8830: LD_ADDR_OWVAR 42
8834: PUSH
8835: LD_INT 0
8837: ST_TO_ADDR
// bc_level := 2 ;
8838: LD_ADDR_OWVAR 43
8842: PUSH
8843: LD_INT 2
8845: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
8846: LD_ADDR_VAR 0 4
8850: PUSH
8851: LD_INT 264
8853: PPUSH
8854: LD_INT 120
8856: PPUSH
8857: LD_INT 4
8859: PPUSH
8860: CALL_OW 47
8864: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
8865: LD_INT 264
8867: PPUSH
8868: LD_INT 120
8870: PPUSH
8871: LD_INT 4
8873: PPUSH
8874: LD_INT 10
8876: NEG
8877: PPUSH
8878: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
8882: LD_INT 264
8884: PPUSH
8885: LD_INT 120
8887: PPUSH
8888: LD_INT 4
8890: PPUSH
8891: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
8895: LD_INT 35
8897: PPUSH
8898: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
8902: LD_EXP 31
8906: PPUSH
8907: LD_INT 10
8909: PPUSH
8910: CALL_OW 308
8914: IFFALSE 8895
// if has_eng and not dep then
8916: LD_VAR 0 2
8920: PUSH
8921: LD_VAR 0 4
8925: NOT
8926: AND
8927: IFFALSE 9041
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
8929: LD_VAR 0 2
8933: PPUSH
8934: LD_INT 0
8936: PPUSH
8937: LD_INT 264
8939: PPUSH
8940: LD_INT 120
8942: PPUSH
8943: LD_INT 4
8945: PPUSH
8946: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
8950: LD_INT 35
8952: PPUSH
8953: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
8957: LD_INT 22
8959: PUSH
8960: LD_INT 4
8962: PUSH
8963: EMPTY
8964: LIST
8965: LIST
8966: PUSH
8967: LD_INT 30
8969: PUSH
8970: LD_INT 0
8972: PUSH
8973: EMPTY
8974: LIST
8975: LIST
8976: PUSH
8977: LD_INT 3
8979: PUSH
8980: LD_INT 57
8982: PUSH
8983: EMPTY
8984: LIST
8985: PUSH
8986: EMPTY
8987: LIST
8988: LIST
8989: PUSH
8990: EMPTY
8991: LIST
8992: LIST
8993: LIST
8994: PPUSH
8995: CALL_OW 69
8999: IFFALSE 8950
// dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
9001: LD_ADDR_VAR 0 4
9005: PUSH
9006: LD_INT 22
9008: PUSH
9009: LD_INT 4
9011: PUSH
9012: EMPTY
9013: LIST
9014: LIST
9015: PUSH
9016: LD_INT 30
9018: PUSH
9019: LD_INT 0
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: PUSH
9026: EMPTY
9027: LIST
9028: LIST
9029: PPUSH
9030: CALL_OW 69
9034: PUSH
9035: LD_INT 1
9037: ARRAY
9038: ST_TO_ADDR
// end else
9039: GO 9158
// begin SetSide ( dep , 4 ) ;
9041: LD_VAR 0 4
9045: PPUSH
9046: LD_INT 4
9048: PPUSH
9049: CALL_OW 235
// for i = 1 to 3 do
9053: LD_ADDR_VAR 0 1
9057: PUSH
9058: DOUBLE
9059: LD_INT 1
9061: DEC
9062: ST_TO_ADDR
9063: LD_INT 3
9065: PUSH
9066: FOR_TO
9067: IFFALSE 9124
// begin ComEnterUnit ( filter [ i ] , dep ) ;
9069: LD_VAR 0 3
9073: PUSH
9074: LD_VAR 0 1
9078: ARRAY
9079: PPUSH
9080: LD_VAR 0 4
9084: PPUSH
9085: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
9089: LD_VAR 0 3
9093: PUSH
9094: LD_VAR 0 1
9098: ARRAY
9099: PPUSH
9100: LD_INT 2
9102: PPUSH
9103: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
9107: LD_VAR 0 3
9111: PUSH
9112: LD_VAR 0 1
9116: ARRAY
9117: PPUSH
9118: CALL_OW 182
// end ;
9122: GO 9066
9124: POP
9125: POP
// repeat wait ( 0 0$01 ) ;
9126: LD_INT 35
9128: PPUSH
9129: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
9133: LD_VAR 0 3
9137: PPUSH
9138: LD_INT 25
9140: PUSH
9141: LD_INT 2
9143: PUSH
9144: EMPTY
9145: LIST
9146: LIST
9147: PPUSH
9148: CALL_OW 72
9152: PUSH
9153: LD_INT 3
9155: EQUAL
9156: IFFALSE 9126
// end ; ComEnterUnit ( Bierezov , dep ) ;
9158: LD_EXP 32
9162: PPUSH
9163: LD_VAR 0 4
9167: PPUSH
9168: CALL_OW 120
// if IsInUnit ( Cornel ) then
9172: LD_EXP 31
9176: PPUSH
9177: CALL_OW 310
9181: IFFALSE 9264
// begin cargo := IsInUnit ( Cornel ) ;
9183: LD_ADDR_VAR 0 7
9187: PUSH
9188: LD_EXP 31
9192: PPUSH
9193: CALL_OW 310
9197: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
9198: LD_VAR 0 7
9202: PPUSH
9203: LD_INT 1
9205: PPUSH
9206: CALL_OW 289
9210: IFFALSE 9226
// ComGive ( Cornel , dep ) ;
9212: LD_EXP 31
9216: PPUSH
9217: LD_VAR 0 4
9221: PPUSH
9222: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
9226: LD_EXP 31
9230: PPUSH
9231: LD_INT 235
9233: PPUSH
9234: LD_INT 122
9236: PPUSH
9237: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
9241: LD_EXP 31
9245: PPUSH
9246: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
9250: LD_EXP 31
9254: PPUSH
9255: LD_VAR 0 4
9259: PPUSH
9260: CALL_OW 180
// end ; has_eng := UnitFilter ( filter , [ f_class , 2 ] ) ;
9264: LD_ADDR_VAR 0 2
9268: PUSH
9269: LD_VAR 0 3
9273: PPUSH
9274: LD_INT 25
9276: PUSH
9277: LD_INT 2
9279: PUSH
9280: EMPTY
9281: LIST
9282: LIST
9283: PPUSH
9284: CALL_OW 72
9288: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9289: LD_INT 35
9291: PPUSH
9292: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
9296: LD_ADDR_VAR 0 6
9300: PUSH
9301: LD_INT 10
9303: PPUSH
9304: CALL_OW 435
9308: ST_TO_ADDR
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
9309: LD_VAR 0 2
9313: PPUSH
9314: LD_VAR 0 6
9318: PUSH
9319: LD_INT 1
9321: ARRAY
9322: PPUSH
9323: LD_VAR 0 6
9327: PUSH
9328: LD_INT 2
9330: ARRAY
9331: PPUSH
9332: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 100 ;
9336: LD_VAR 0 4
9340: PPUSH
9341: CALL_OW 274
9345: PPUSH
9346: LD_INT 1
9348: PPUSH
9349: CALL_OW 275
9353: PUSH
9354: LD_INT 100
9356: GREATEREQUAL
9357: IFFALSE 9289
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
9359: LD_ADDR_VAR 0 5
9363: PUSH
9364: LD_INT 4
9366: PUSH
9367: LD_INT 256
9369: PUSH
9370: LD_INT 111
9372: PUSH
9373: LD_INT 2
9375: PUSH
9376: EMPTY
9377: LIST
9378: LIST
9379: LIST
9380: LIST
9381: PUSH
9382: LD_INT 31
9384: PUSH
9385: LD_INT 243
9387: PUSH
9388: LD_INT 112
9390: PUSH
9391: LD_INT 2
9393: PUSH
9394: EMPTY
9395: LIST
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: EMPTY
9401: LIST
9402: LIST
9403: ST_TO_ADDR
// for i in blist do
9404: LD_ADDR_VAR 0 1
9408: PUSH
9409: LD_VAR 0 5
9413: PUSH
9414: FOR_IN
9415: IFFALSE 9464
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
9417: LD_VAR 0 2
9421: PPUSH
9422: LD_VAR 0 1
9426: PUSH
9427: LD_INT 1
9429: ARRAY
9430: PPUSH
9431: LD_VAR 0 1
9435: PUSH
9436: LD_INT 2
9438: ARRAY
9439: PPUSH
9440: LD_VAR 0 1
9444: PUSH
9445: LD_INT 3
9447: ARRAY
9448: PPUSH
9449: LD_VAR 0 1
9453: PUSH
9454: LD_INT 4
9456: ARRAY
9457: PPUSH
9458: CALL_OW 205
9462: GO 9414
9464: POP
9465: POP
// repeat wait ( 0 0$01 ) ;
9466: LD_INT 35
9468: PPUSH
9469: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
9473: LD_INT 22
9475: PUSH
9476: LD_INT 4
9478: PUSH
9479: EMPTY
9480: LIST
9481: LIST
9482: PUSH
9483: LD_INT 30
9485: PUSH
9486: LD_INT 4
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PUSH
9493: LD_INT 3
9495: PUSH
9496: LD_INT 57
9498: PUSH
9499: EMPTY
9500: LIST
9501: PUSH
9502: EMPTY
9503: LIST
9504: LIST
9505: PUSH
9506: EMPTY
9507: LIST
9508: LIST
9509: LIST
9510: PPUSH
9511: CALL_OW 69
9515: IFFALSE 9466
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
9517: LD_VAR 0 3
9521: PUSH
9522: LD_VAR 0 2
9526: DIFF
9527: PPUSH
9528: LD_INT 22
9530: PUSH
9531: LD_INT 4
9533: PUSH
9534: EMPTY
9535: LIST
9536: LIST
9537: PUSH
9538: LD_INT 30
9540: PUSH
9541: LD_INT 4
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: PUSH
9548: EMPTY
9549: LIST
9550: LIST
9551: PPUSH
9552: CALL_OW 69
9556: PUSH
9557: LD_INT 1
9559: ARRAY
9560: PPUSH
9561: CALL_OW 180
// repeat wait ( 0 0$01 ) ;
9565: LD_INT 35
9567: PPUSH
9568: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
9572: LD_INT 22
9574: PUSH
9575: LD_INT 4
9577: PUSH
9578: EMPTY
9579: LIST
9580: LIST
9581: PUSH
9582: LD_INT 30
9584: PUSH
9585: LD_INT 31
9587: PUSH
9588: EMPTY
9589: LIST
9590: LIST
9591: PUSH
9592: LD_INT 3
9594: PUSH
9595: LD_INT 57
9597: PUSH
9598: EMPTY
9599: LIST
9600: PUSH
9601: EMPTY
9602: LIST
9603: LIST
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: LIST
9609: PPUSH
9610: CALL_OW 69
9614: IFFALSE 9565
// sol := filter diff has_eng ;
9616: LD_ADDR_VAR 0 8
9620: PUSH
9621: LD_VAR 0 3
9625: PUSH
9626: LD_VAR 0 2
9630: DIFF
9631: ST_TO_ADDR
// ComExitBuilding ( sol [ 1 ] ) ;
9632: LD_VAR 0 8
9636: PUSH
9637: LD_INT 1
9639: ARRAY
9640: PPUSH
9641: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
9645: LD_VAR 0 8
9649: PUSH
9650: LD_INT 1
9652: ARRAY
9653: PPUSH
9654: LD_INT 22
9656: PUSH
9657: LD_INT 4
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: PUSH
9664: LD_INT 30
9666: PUSH
9667: LD_INT 31
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: PUSH
9674: EMPTY
9675: LIST
9676: LIST
9677: PPUSH
9678: CALL_OW 69
9682: PUSH
9683: LD_INT 1
9685: ARRAY
9686: PPUSH
9687: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
9691: LD_VAR 0 2
9695: PPUSH
9696: LD_VAR 0 4
9700: PPUSH
9701: CALL_OW 112
// end ;
9705: PPOPN 8
9707: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
9708: LD_EXP 9
9712: IFFALSE 10032
9714: GO 9716
9716: DISABLE
9717: LD_INT 0
9719: PPUSH
9720: PPUSH
9721: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
9722: LD_ADDR_VAR 0 2
9726: PUSH
9727: LD_INT 22
9729: PUSH
9730: LD_INT 4
9732: PUSH
9733: EMPTY
9734: LIST
9735: LIST
9736: PUSH
9737: LD_INT 30
9739: PUSH
9740: LD_INT 4
9742: PUSH
9743: EMPTY
9744: LIST
9745: LIST
9746: PUSH
9747: EMPTY
9748: LIST
9749: LIST
9750: PPUSH
9751: CALL_OW 69
9755: PUSH
9756: LD_INT 1
9758: ARRAY
9759: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
9760: LD_EXP 4
9764: PPUSH
9765: CALL_OW 122
// for i in cornel_units do
9769: LD_ADDR_VAR 0 1
9773: PUSH
9774: LD_EXP 4
9778: PUSH
9779: FOR_IN
9780: IFFALSE 9834
// if GetClass ( i ) = 2 then
9782: LD_VAR 0 1
9786: PPUSH
9787: CALL_OW 257
9791: PUSH
9792: LD_INT 2
9794: EQUAL
9795: IFFALSE 9832
// begin ComEnterUnit ( i , arm ) ;
9797: LD_VAR 0 1
9801: PPUSH
9802: LD_VAR 0 2
9806: PPUSH
9807: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
9811: LD_VAR 0 1
9815: PPUSH
9816: LD_INT 1
9818: PPUSH
9819: CALL_OW 183
// AddComExitBuilding ( i ) ;
9823: LD_VAR 0 1
9827: PPUSH
9828: CALL_OW 182
// end ;
9832: GO 9779
9834: POP
9835: POP
// Wait ( 1 1$00 ) ;
9836: LD_INT 2100
9838: PPUSH
9839: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
9843: LD_ADDR_VAR 0 3
9847: PUSH
9848: LD_EXP 31
9852: PUSH
9853: LD_EXP 32
9857: ADD
9858: PUSH
9859: LD_EXP 4
9863: ADD
9864: PUSH
9865: LD_EXP 4
9869: PPUSH
9870: LD_INT 21
9872: PUSH
9873: LD_INT 2
9875: PUSH
9876: EMPTY
9877: LIST
9878: LIST
9879: PPUSH
9880: CALL_OW 72
9884: DIFF
9885: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
9886: LD_VAR 0 3
9890: PPUSH
9891: LD_INT 248
9893: PPUSH
9894: LD_INT 85
9896: PPUSH
9897: CALL_OW 111
// AddComHold ( filter ) ;
9901: LD_VAR 0 3
9905: PPUSH
9906: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
9910: LD_INT 35
9912: PPUSH
9913: CALL_OW 67
// until cornel_attack ;
9917: LD_EXP 7
9921: IFFALSE 9910
// ComAgressiveMove ( filter , 209 , 63 ) ;
9923: LD_VAR 0 3
9927: PPUSH
9928: LD_INT 209
9930: PPUSH
9931: LD_INT 63
9933: PPUSH
9934: CALL_OW 114
// if Bierezov then
9938: LD_EXP 32
9942: IFFALSE 10032
// begin filter := filter diff Bierezov ;
9944: LD_ADDR_VAR 0 3
9948: PUSH
9949: LD_VAR 0 3
9953: PUSH
9954: LD_EXP 32
9958: DIFF
9959: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
9960: LD_EXP 32
9964: PPUSH
9965: LD_INT 6
9967: PPUSH
9968: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
9972: LD_EXP 32
9976: PPUSH
9977: LD_INT 235
9979: PPUSH
9980: LD_INT 60
9982: PPUSH
9983: CALL_OW 111
// AddComHold ( Bierezov ) ;
9987: LD_EXP 32
9991: PPUSH
9992: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
9996: LD_EXP 32
10000: PPUSH
10001: LD_INT 350
10003: PPUSH
10004: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
10008: LD_EXP 32
10012: PPUSH
10013: LD_INT 198
10015: PPUSH
10016: LD_INT 28
10018: PPUSH
10019: CALL_OW 171
// AddComHold ( Bierezov ) ;
10023: LD_EXP 32
10027: PPUSH
10028: CALL_OW 200
// end ; end ; end_of_file end_of_file
10032: PPOPN 3
10034: END
// every 0 0$50 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
10035: LD_EXP 3
10039: PUSH
10040: LD_EXP 7
10044: NOT
10045: AND
10046: PUSH
10047: LD_EXP 17
10051: AND
10052: IFFALSE 10164
10054: GO 10056
10056: DISABLE
10057: LD_INT 0
10059: PPUSH
// begin enable ;
10060: ENABLE
// crates_counter := crates_counter - 50 ;
10061: LD_ADDR_EXP 17
10065: PUSH
10066: LD_EXP 17
10070: PUSH
10071: LD_INT 50
10073: MINUS
10074: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
10075: LD_INT 8
10077: PPUSH
10078: LD_INT 2
10080: PPUSH
10081: LD_INT 5
10083: PPUSH
10084: CALL_OW 12
10088: PPUSH
10089: LD_INT 1
10091: PPUSH
10092: CALL_OW 55
// Wait ( Rand ( 0 0$11 , 0 0$37 ) ) ;
10096: LD_INT 385
10098: PPUSH
10099: LD_INT 1295
10101: PPUSH
10102: CALL_OW 12
10106: PPUSH
10107: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
10111: LD_ADDR_VAR 0 1
10115: PUSH
10116: LD_INT 1
10118: PPUSH
10119: LD_OWVAR 67
10123: PUSH
10124: LD_INT 2
10126: PLUS
10127: PPUSH
10128: CALL_OW 12
10132: ST_TO_ADDR
// if r < 3 then
10133: LD_VAR 0 1
10137: PUSH
10138: LD_INT 3
10140: LESS
10141: IFFALSE 10164
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
10143: LD_INT 4
10145: PPUSH
10146: LD_INT 1
10148: PPUSH
10149: LD_INT 5
10151: PPUSH
10152: CALL_OW 12
10156: PPUSH
10157: LD_INT 1
10159: PPUSH
10160: CALL_OW 55
// end ;
10164: PPOPN 1
10166: END
// every 0 0$01 trigger cornel_active do
10167: LD_EXP 6
10171: IFFALSE 10260
10173: GO 10175
10175: DISABLE
// begin Wait ( 0 0$03 ) ;
10176: LD_INT 105
10178: PPUSH
10179: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
10183: LD_INT 2
10185: PPUSH
10186: LD_INT 5
10188: PPUSH
10189: CALL_OW 12
10193: PPUSH
10194: LD_INT 10
10196: PPUSH
10197: LD_INT 1
10199: PPUSH
10200: CALL_OW 55
// Wait ( 0 0$13 ) ;
10204: LD_INT 455
10206: PPUSH
10207: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
10211: LD_INT 2
10213: PPUSH
10214: LD_INT 5
10216: PPUSH
10217: CALL_OW 12
10221: PPUSH
10222: LD_INT 10
10224: PPUSH
10225: LD_INT 1
10227: PPUSH
10228: CALL_OW 55
// Wait ( 0 0$16 ) ;
10232: LD_INT 560
10234: PPUSH
10235: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
10239: LD_INT 2
10241: PPUSH
10242: LD_INT 5
10244: PPUSH
10245: CALL_OW 12
10249: PPUSH
10250: LD_INT 10
10252: PPUSH
10253: LD_INT 1
10255: PPUSH
10256: CALL_OW 55
// end ; end_of_file
10260: END
// every 0 0$01 trigger cornel_prepared do
10261: LD_EXP 9
10265: IFFALSE 10302
10267: GO 10269
10269: DISABLE
// begin enable ;
10270: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
10271: LD_ADDR_OWVAR 47
10275: PUSH
10276: LD_STRING #Am03-1
10278: PUSH
10279: LD_EXP 8
10283: PUSH
10284: EMPTY
10285: LIST
10286: LIST
10287: ST_TO_ADDR
// cornel_counter := cornel_counter - 0 0$01 ;
10288: LD_ADDR_EXP 8
10292: PUSH
10293: LD_EXP 8
10297: PUSH
10298: LD_INT 35
10300: MINUS
10301: ST_TO_ADDR
// end ; end_of_file
10302: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
10303: LD_VAR 0 1
10307: PPUSH
10308: CALL_OW 255
10312: PUSH
10313: LD_INT 1
10315: EQUAL
10316: PUSH
10317: LD_EXP 11
10321: NOT
10322: AND
10323: IFFALSE 10333
// solar_builded := true ;
10325: LD_ADDR_EXP 11
10329: PUSH
10330: LD_INT 1
10332: ST_TO_ADDR
// end ;
10333: PPOPN 2
10335: END
