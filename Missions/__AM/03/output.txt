// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 323 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 411 0 0
// PrepareRussian ;
  22: CALL 2898 0 0
// PrepareAmerican ;
  26: CALL 1139 0 0
// PrepareCornell ;
  30: CALL 2163 0 0
// PrepareWesternBase ;
  34: CALL 2389 0 0
// Action ;
  38: CALL 4904 0 0
// end ;
  42: END
// export debug ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// jmm_units := 0 ;
  54: LD_ADDR_EXP 2
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// cornel_units := 0 ;
  62: LD_ADDR_EXP 4
  66: PUSH
  67: LD_INT 0
  69: ST_TO_ADDR
// bierezov_exist := false ;
  70: LD_ADDR_EXP 5
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// jmm_on_west := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// cornel_active := false ;
  86: LD_ADDR_EXP 6
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// cornel_attack := false ;
  94: LD_ADDR_EXP 7
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_prepared := false ;
 102: LD_ADDR_EXP 9
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 110: LD_ADDR_EXP 8
 114: PUSH
 115: LD_INT 4200
 117: ST_TO_ADDR
// frank_can_return := false ;
 118: LD_ADDR_EXP 10
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// solar_builded := false ;
 126: LD_ADDR_EXP 11
 130: PUSH
 131: LD_INT 0
 133: ST_TO_ADDR
// frank_send_to_scout := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// jmm_in_veh := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// bobby_in_veh := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// cyrus_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// lisa_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 174: LD_ADDR_EXP 25
 178: PUSH
 179: LD_INT 25200
 181: PUSH
 182: LD_INT 23100
 184: PUSH
 185: LD_INT 21000
 187: PUSH
 188: EMPTY
 189: LIST
 190: LIST
 191: LIST
 192: PUSH
 193: LD_OWVAR 67
 197: ARRAY
 198: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 199: LD_ADDR_EXP 17
 203: PUSH
 204: LD_INT 600
 206: PUSH
 207: LD_INT 500
 209: PUSH
 210: LD_INT 400
 212: PUSH
 213: EMPTY
 214: LIST
 215: LIST
 216: LIST
 217: PUSH
 218: LD_OWVAR 67
 222: ARRAY
 223: ST_TO_ADDR
// end_mission_allowed := false ;
 224: LD_ADDR_EXP 18
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// save_others := [ ] ;
 232: LD_ADDR_EXP 19
 236: PUSH
 237: EMPTY
 238: ST_TO_ADDR
// save_group := [ ] ;
 239: LD_ADDR_EXP 20
 243: PUSH
 244: EMPTY
 245: ST_TO_ADDR
// show_query := true ;
 246: LD_ADDR_EXP 21
 250: PUSH
 251: LD_INT 1
 253: ST_TO_ADDR
// wait_for_them := false ;
 254: LD_ADDR_EXP 22
 258: PUSH
 259: LD_INT 0
 261: ST_TO_ADDR
// veh_on_meta := false ;
 262: LD_ADDR_EXP 24
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// send_spec_patrol := false ;
 270: LD_ADDR_EXP 26
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// prepare_siege := false ;
 278: LD_ADDR_EXP 27
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_attack_on_cornel := false ;
 286: LD_ADDR_EXP 28
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 294: LD_ADDR_EXP 23
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// game_end := false ;
 302: LD_ADDR_EXP 29
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// lose_counter := 0 ;
 310: LD_ADDR_EXP 30
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// end ;
 318: LD_VAR 0 1
 322: RET
// function SetDiplomacy ; begin
 323: LD_INT 0
 325: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 326: LD_INT 1
 328: PPUSH
 329: LD_INT 4
 331: PPUSH
 332: LD_INT 1
 334: PPUSH
 335: LD_INT 1
 337: PPUSH
 338: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 342: LD_INT 1
 344: PPUSH
 345: LD_INT 8
 347: PPUSH
 348: LD_INT 1
 350: PPUSH
 351: LD_INT 1
 353: PPUSH
 354: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 358: LD_INT 3
 360: PPUSH
 361: LD_INT 6
 363: PPUSH
 364: LD_INT 1
 366: PPUSH
 367: LD_INT 1
 369: PPUSH
 370: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 374: LD_INT 4
 376: PPUSH
 377: LD_INT 6
 379: PPUSH
 380: LD_INT 0
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 390: LD_INT 3
 392: PPUSH
 393: LD_INT 8
 395: PPUSH
 396: LD_INT 0
 398: PPUSH
 399: LD_INT 1
 401: PPUSH
 402: CALL_OW 80
// end ;
 406: LD_VAR 0 1
 410: RET
// export function DebugMode ; var i ; begin
 411: LD_INT 0
 413: PPUSH
 414: PPUSH
// FogOff ( 1 ) ;
 415: LD_INT 1
 417: PPUSH
 418: CALL_OW 344
// debug_strings := [ ] ;
 422: LD_ADDR_OWVAR 48
 426: PUSH
 427: EMPTY
 428: ST_TO_ADDR
// end ; end_of_file
 429: LD_VAR 0 1
 433: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 434: LD_INT 0
 436: PPUSH
 437: PPUSH
// if exist_mode then
 438: LD_VAR 0 2
 442: IFFALSE 461
// unit := CreateCharacter ( ident ) else
 444: LD_ADDR_VAR 0 4
 448: PUSH
 449: LD_VAR 0 1
 453: PPUSH
 454: CALL_OW 34
 458: ST_TO_ADDR
 459: GO 476
// unit := NewCharacter ( ident ) ;
 461: LD_ADDR_VAR 0 4
 465: PUSH
 466: LD_VAR 0 1
 470: PPUSH
 471: CALL_OW 25
 475: ST_TO_ADDR
// result := unit ;
 476: LD_ADDR_VAR 0 3
 480: PUSH
 481: LD_VAR 0 4
 485: ST_TO_ADDR
// end ;
 486: LD_VAR 0 3
 490: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 491: LD_INT 0
 493: PPUSH
// uc_side := side ;
 494: LD_ADDR_OWVAR 20
 498: PUSH
 499: LD_VAR 0 1
 503: ST_TO_ADDR
// uc_nation := nation ;
 504: LD_ADDR_OWVAR 21
 508: PUSH
 509: LD_VAR 0 2
 513: ST_TO_ADDR
// vc_chassis := chassis ;
 514: LD_ADDR_OWVAR 37
 518: PUSH
 519: LD_VAR 0 3
 523: ST_TO_ADDR
// vc_engine := engine ;
 524: LD_ADDR_OWVAR 39
 528: PUSH
 529: LD_VAR 0 4
 533: ST_TO_ADDR
// vc_control := control ;
 534: LD_ADDR_OWVAR 38
 538: PUSH
 539: LD_VAR 0 5
 543: ST_TO_ADDR
// vc_weapon := weapon ;
 544: LD_ADDR_OWVAR 40
 548: PUSH
 549: LD_VAR 0 6
 553: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 554: LD_ADDR_OWVAR 41
 558: PUSH
 559: LD_VAR 0 7
 563: ST_TO_ADDR
// result := CreateVehicle ;
 564: LD_ADDR_VAR 0 8
 568: PUSH
 569: CALL_OW 45
 573: ST_TO_ADDR
// end ;
 574: LD_VAR 0 8
 578: RET
// export function SayX ( units , ident ) ; var i ; begin
 579: LD_INT 0
 581: PPUSH
 582: PPUSH
// result := false ;
 583: LD_ADDR_VAR 0 3
 587: PUSH
 588: LD_INT 0
 590: ST_TO_ADDR
// if not units then
 591: LD_VAR 0 1
 595: NOT
 596: IFFALSE 600
// exit ;
 598: GO 654
// for i in units do
 600: LD_ADDR_VAR 0 4
 604: PUSH
 605: LD_VAR 0 1
 609: PUSH
 610: FOR_IN
 611: IFFALSE 652
// if IsOk ( i ) then
 613: LD_VAR 0 4
 617: PPUSH
 618: CALL_OW 302
 622: IFFALSE 650
// begin Say ( i , ident ) ;
 624: LD_VAR 0 4
 628: PPUSH
 629: LD_VAR 0 2
 633: PPUSH
 634: CALL_OW 88
// result := i ;
 638: LD_ADDR_VAR 0 3
 642: PUSH
 643: LD_VAR 0 4
 647: ST_TO_ADDR
// break ;
 648: GO 652
// end ;
 650: GO 610
 652: POP
 653: POP
// end ;
 654: LD_VAR 0 3
 658: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 659: LD_INT 0
 661: PPUSH
 662: PPUSH
 663: PPUSH
 664: PPUSH
// for i = 1 to count do
 665: LD_ADDR_VAR 0 8
 669: PUSH
 670: DOUBLE
 671: LD_INT 1
 673: DEC
 674: ST_TO_ADDR
 675: LD_VAR 0 6
 679: PUSH
 680: FOR_TO
 681: IFFALSE 762
// begin uc_side = side ;
 683: LD_ADDR_OWVAR 20
 687: PUSH
 688: LD_VAR 0 1
 692: ST_TO_ADDR
// uc_nation = nation ;
 693: LD_ADDR_OWVAR 21
 697: PUSH
 698: LD_VAR 0 2
 702: ST_TO_ADDR
// hc_gallery =  ;
 703: LD_ADDR_OWVAR 33
 707: PUSH
 708: LD_STRING 
 710: ST_TO_ADDR
// hc_name =  ;
 711: LD_ADDR_OWVAR 26
 715: PUSH
 716: LD_STRING 
 718: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 719: LD_INT 0
 721: PPUSH
 722: LD_VAR 0 5
 726: PPUSH
 727: LD_VAR 0 4
 731: PPUSH
 732: CALL_OW 380
// un = CreateHuman ;
 736: LD_ADDR_VAR 0 10
 740: PUSH
 741: CALL_OW 44
 745: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 746: LD_VAR 0 10
 750: PPUSH
 751: LD_VAR 0 3
 755: PPUSH
 756: CALL_OW 52
// end ;
 760: GO 680
 762: POP
 763: POP
// end ;
 764: LD_VAR 0 7
 768: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 769: LD_INT 0
 771: PPUSH
 772: PPUSH
 773: PPUSH
// uc_side := GetSide ( b ) ;
 774: LD_ADDR_OWVAR 20
 778: PUSH
 779: LD_VAR 0 2
 783: PPUSH
 784: CALL_OW 255
 788: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 789: LD_ADDR_OWVAR 21
 793: PUSH
 794: LD_VAR 0 2
 798: PPUSH
 799: CALL_OW 248
 803: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 804: LD_INT 0
 806: PPUSH
 807: LD_INT 1
 809: PPUSH
 810: LD_VAR 0 1
 814: PPUSH
 815: CALL_OW 380
// un = CreateHuman ;
 819: LD_ADDR_VAR 0 4
 823: PUSH
 824: CALL_OW 44
 828: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 829: LD_ADDR_VAR 0 5
 833: PUSH
 834: LD_VAR 0 2
 838: PPUSH
 839: CALL_OW 254
 843: PUSH
 844: LD_INT 3
 846: MINUS
 847: ST_TO_ADDR
// if dir < 0 then
 848: LD_VAR 0 5
 852: PUSH
 853: LD_INT 0
 855: LESS
 856: IFFALSE 872
// dir := 6 + dir ;
 858: LD_ADDR_VAR 0 5
 862: PUSH
 863: LD_INT 6
 865: PUSH
 866: LD_VAR 0 5
 870: PLUS
 871: ST_TO_ADDR
// SetDir ( un , dir ) ;
 872: LD_VAR 0 4
 876: PPUSH
 877: LD_VAR 0 5
 881: PPUSH
 882: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 886: LD_VAR 0 4
 890: PPUSH
 891: LD_VAR 0 2
 895: PPUSH
 896: CALL_OW 52
// end ;
 900: LD_VAR 0 3
 904: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 905: LD_INT 0
 907: PPUSH
 908: PPUSH
 909: PPUSH
// result := false ;
 910: LD_ADDR_VAR 0 2
 914: PUSH
 915: LD_INT 0
 917: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 918: LD_ADDR_VAR 0 3
 922: PUSH
 923: LD_INT 22
 925: PUSH
 926: LD_INT 1
 928: PUSH
 929: EMPTY
 930: LIST
 931: LIST
 932: PUSH
 933: LD_INT 34
 935: PUSH
 936: LD_INT 2
 938: PUSH
 939: EMPTY
 940: LIST
 941: LIST
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: PPUSH
 947: CALL_OW 69
 951: ST_TO_ADDR
// for i in filter do
 952: LD_ADDR_VAR 0 4
 956: PUSH
 957: LD_VAR 0 3
 961: PUSH
 962: FOR_IN
 963: IFFALSE 994
// if IsDrivenBy ( i ) = unit then
 965: LD_VAR 0 4
 969: PPUSH
 970: CALL_OW 311
 974: PUSH
 975: LD_VAR 0 1
 979: EQUAL
 980: IFFALSE 992
// begin result := true ;
 982: LD_ADDR_VAR 0 2
 986: PUSH
 987: LD_INT 1
 989: ST_TO_ADDR
// break ;
 990: GO 994
// end ;
 992: GO 962
 994: POP
 995: POP
// end ;
 996: LD_VAR 0 2
1000: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1001: LD_INT 0
1003: PPUSH
1004: PPUSH
// result := false ;
1005: LD_ADDR_VAR 0 2
1009: PUSH
1010: LD_INT 0
1012: ST_TO_ADDR
// if not blist then
1013: LD_VAR 0 1
1017: NOT
1018: IFFALSE 1022
// exit ;
1020: GO 1066
// for i in blist do
1022: LD_ADDR_VAR 0 3
1026: PUSH
1027: LD_VAR 0 1
1031: PUSH
1032: FOR_IN
1033: IFFALSE 1064
// if UnitsInside ( i ) < 6 then
1035: LD_VAR 0 3
1039: PPUSH
1040: CALL_OW 313
1044: PUSH
1045: LD_INT 6
1047: LESS
1048: IFFALSE 1062
// begin result := i ;
1050: LD_ADDR_VAR 0 2
1054: PUSH
1055: LD_VAR 0 3
1059: ST_TO_ADDR
// break ;
1060: GO 1064
// end ;
1062: GO 1032
1064: POP
1065: POP
// end ;
1066: LD_VAR 0 2
1070: RET
// export function Count ( timer , mode ) ; begin
1071: LD_INT 0
1073: PPUSH
// if not timer then
1074: LD_VAR 0 1
1078: NOT
1079: IFFALSE 1083
// exit ;
1081: GO 1134
// if mode in [ asc , up , + ] then
1083: LD_VAR 0 2
1087: PUSH
1088: LD_STRING asc
1090: PUSH
1091: LD_STRING up
1093: PUSH
1094: LD_STRING +
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: IN
1102: IFFALSE 1120
// result := timer + 0 0$01 else
1104: LD_ADDR_VAR 0 3
1108: PUSH
1109: LD_VAR 0 1
1113: PUSH
1114: LD_INT 35
1116: PLUS
1117: ST_TO_ADDR
1118: GO 1134
// result := timer - 0 0$01 ;
1120: LD_ADDR_VAR 0 3
1124: PUSH
1125: LD_VAR 0 1
1129: PUSH
1130: LD_INT 35
1132: MINUS
1133: ST_TO_ADDR
// end ; end_of_file
1134: LD_VAR 0 3
1138: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1139: LD_INT 0
1141: PPUSH
1142: PPUSH
1143: PPUSH
1144: PPUSH
1145: PPUSH
1146: PPUSH
1147: PPUSH
1148: PPUSH
// uc_side := 4 ;
1149: LD_ADDR_OWVAR 20
1153: PUSH
1154: LD_INT 4
1156: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1157: LD_ADDR_EXP 40
1161: PUSH
1162: LD_STRING Powell
1164: PPUSH
1165: LD_INT 0
1167: PPUSH
1168: CALL 434 0 2
1172: ST_TO_ADDR
// uc_side := 1 ;
1173: LD_ADDR_OWVAR 20
1177: PUSH
1178: LD_INT 1
1180: ST_TO_ADDR
// uc_nation := 1 ;
1181: LD_ADDR_OWVAR 21
1185: PUSH
1186: LD_INT 1
1188: ST_TO_ADDR
// if debug then
1189: LD_EXP 1
1193: IFFALSE 1323
// begin for i = 1 to 4 do
1195: LD_ADDR_VAR 0 2
1199: PUSH
1200: DOUBLE
1201: LD_INT 1
1203: DEC
1204: ST_TO_ADDR
1205: LD_INT 4
1207: PUSH
1208: FOR_TO
1209: IFFALSE 1260
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1211: LD_INT 0
1213: PPUSH
1214: LD_INT 1
1216: PPUSH
1217: LD_INT 2
1219: PPUSH
1220: CALL_OW 12
1224: PPUSH
1225: LD_INT 3
1227: PPUSH
1228: CALL_OW 380
// un := CreateHuman ;
1232: LD_ADDR_VAR 0 3
1236: PUSH
1237: CALL_OW 44
1241: ST_TO_ADDR
// others := others ^ un ;
1242: LD_ADDR_VAR 0 5
1246: PUSH
1247: LD_VAR 0 5
1251: PUSH
1252: LD_VAR 0 3
1256: ADD
1257: ST_TO_ADDR
// end ;
1258: GO 1208
1260: POP
1261: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1262: LD_ADDR_VAR 0 6
1266: PUSH
1267: LD_INT 21
1269: PUSH
1270: LD_INT 1
1272: PUSH
1273: LD_INT 1
1275: PUSH
1276: LD_INT 51
1278: PUSH
1279: LD_INT 90
1281: PUSH
1282: LD_INT 504
1284: PUSH
1285: EMPTY
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: PUSH
1293: LD_INT 21
1295: PUSH
1296: LD_INT 1
1298: PUSH
1299: LD_INT 1
1301: PUSH
1302: LD_INT 51
1304: PUSH
1305: LD_INT 80
1307: PUSH
1308: LD_INT 750
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: PUSH
1319: EMPTY
1320: LIST
1321: LIST
1322: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1323: LD_ADDR_EXP 31
1327: PUSH
1328: LD_STRING JMM
1330: PPUSH
1331: LD_EXP 1
1335: NOT
1336: PPUSH
1337: CALL 434 0 2
1341: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1342: LD_ADDR_EXP 32
1346: PUSH
1347: LD_STRING Bobby
1349: PPUSH
1350: LD_EXP 1
1354: NOT
1355: PPUSH
1356: CALL 434 0 2
1360: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1361: LD_ADDR_EXP 33
1365: PUSH
1366: LD_STRING Cyrus
1368: PPUSH
1369: LD_EXP 1
1373: NOT
1374: PPUSH
1375: CALL 434 0 2
1379: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1380: LD_ADDR_EXP 34
1384: PUSH
1385: LD_STRING Lisa
1387: PPUSH
1388: LD_EXP 1
1392: NOT
1393: PPUSH
1394: CALL 434 0 2
1398: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1399: LD_ADDR_EXP 35
1403: PUSH
1404: LD_STRING Khatam
1406: PPUSH
1407: LD_EXP 1
1411: NOT
1412: PPUSH
1413: CALL 434 0 2
1417: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1418: LD_ADDR_EXP 36
1422: PUSH
1423: LD_STRING Brian
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: CALL 434 0 2
1436: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1437: LD_ADDR_EXP 37
1441: PUSH
1442: LD_STRING Jerry
1444: PPUSH
1445: LD_EXP 1
1449: NOT
1450: PPUSH
1451: CALL 434 0 2
1455: ST_TO_ADDR
// if Bobby then
1456: LD_EXP 32
1460: IFFALSE 1491
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1462: LD_ADDR_VAR 0 4
1466: PUSH
1467: LD_VAR 0 4
1471: PPUSH
1472: LD_VAR 0 4
1476: PUSH
1477: LD_INT 1
1479: PLUS
1480: PPUSH
1481: LD_EXP 32
1485: PPUSH
1486: CALL_OW 2
1490: ST_TO_ADDR
// if Cyrus then
1491: LD_EXP 33
1495: IFFALSE 1526
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1497: LD_ADDR_VAR 0 4
1501: PUSH
1502: LD_VAR 0 4
1506: PPUSH
1507: LD_VAR 0 4
1511: PUSH
1512: LD_INT 1
1514: PLUS
1515: PPUSH
1516: LD_EXP 33
1520: PPUSH
1521: CALL_OW 2
1525: ST_TO_ADDR
// if Lisa then
1526: LD_EXP 34
1530: IFFALSE 1561
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1532: LD_ADDR_VAR 0 4
1536: PUSH
1537: LD_VAR 0 4
1541: PPUSH
1542: LD_VAR 0 4
1546: PUSH
1547: LD_INT 1
1549: PLUS
1550: PPUSH
1551: LD_EXP 34
1555: PPUSH
1556: CALL_OW 2
1560: ST_TO_ADDR
// if Khatam then
1561: LD_EXP 35
1565: IFFALSE 1596
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1567: LD_ADDR_VAR 0 4
1571: PUSH
1572: LD_VAR 0 4
1576: PPUSH
1577: LD_VAR 0 4
1581: PUSH
1582: LD_INT 1
1584: PLUS
1585: PPUSH
1586: LD_EXP 35
1590: PPUSH
1591: CALL_OW 2
1595: ST_TO_ADDR
// if Brian then
1596: LD_EXP 36
1600: IFFALSE 1631
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1602: LD_ADDR_VAR 0 4
1606: PUSH
1607: LD_VAR 0 4
1611: PPUSH
1612: LD_VAR 0 4
1616: PUSH
1617: LD_INT 1
1619: PLUS
1620: PPUSH
1621: LD_EXP 36
1625: PPUSH
1626: CALL_OW 2
1630: ST_TO_ADDR
// if Jerry then
1631: LD_EXP 37
1635: IFFALSE 1666
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1637: LD_ADDR_VAR 0 4
1641: PUSH
1642: LD_VAR 0 4
1646: PPUSH
1647: LD_VAR 0 4
1651: PUSH
1652: LD_INT 1
1654: PLUS
1655: PPUSH
1656: LD_EXP 37
1660: PPUSH
1661: CALL_OW 2
1665: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1666: LD_STRING 02_other_survivors
1668: PPUSH
1669: CALL_OW 28
1673: IFFALSE 1688
// others := CreateCharacterSet ( 02_other_survivors ) ;
1675: LD_ADDR_VAR 0 5
1679: PUSH
1680: LD_STRING 02_other_survivors
1682: PPUSH
1683: CALL_OW 31
1687: ST_TO_ADDR
// if others then
1688: LD_VAR 0 5
1692: IFFALSE 1717
// begin tmp := tmp ^ others ;
1694: LD_ADDR_VAR 0 4
1698: PUSH
1699: LD_VAR 0 4
1703: PUSH
1704: LD_VAR 0 5
1708: ADD
1709: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1710: LD_STRING 02_other_survivors
1712: PPUSH
1713: CALL_OW 40
// end ; jmm_units := tmp ;
1717: LD_ADDR_EXP 2
1721: PUSH
1722: LD_VAR 0 4
1726: ST_TO_ADDR
// if not vehicles then
1727: LD_VAR 0 6
1731: NOT
1732: IFFALSE 1750
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1734: LD_ADDR_VAR 0 6
1738: PUSH
1739: LD_STRING 02_tanks_1
1741: PPUSH
1742: LD_INT 0
1744: PPUSH
1745: CALL_OW 30
1749: ST_TO_ADDR
// if vehicles then
1750: LD_VAR 0 6
1754: IFFALSE 1948
// begin got_mech := false ;
1756: LD_ADDR_VAR 0 7
1760: PUSH
1761: LD_INT 0
1763: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1764: LD_VAR 0 4
1768: PPUSH
1769: LD_INT 25
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PPUSH
1779: CALL_OW 72
1783: IFFALSE 1793
// got_mech := true ;
1785: LD_ADDR_VAR 0 7
1789: PUSH
1790: LD_INT 1
1792: ST_TO_ADDR
// for i = 1 to vehicles do
1793: LD_ADDR_VAR 0 2
1797: PUSH
1798: DOUBLE
1799: LD_INT 1
1801: DEC
1802: ST_TO_ADDR
1803: LD_VAR 0 6
1807: PUSH
1808: FOR_TO
1809: IFFALSE 1946
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1811: LD_ADDR_VAR 0 3
1815: PUSH
1816: LD_INT 1
1818: PPUSH
1819: LD_INT 3
1821: PPUSH
1822: LD_VAR 0 6
1826: PUSH
1827: LD_VAR 0 2
1831: ARRAY
1832: PUSH
1833: LD_INT 1
1835: ARRAY
1836: PPUSH
1837: LD_VAR 0 6
1841: PUSH
1842: LD_VAR 0 2
1846: ARRAY
1847: PUSH
1848: LD_INT 2
1850: ARRAY
1851: PPUSH
1852: LD_VAR 0 6
1856: PUSH
1857: LD_VAR 0 2
1861: ARRAY
1862: PUSH
1863: LD_INT 3
1865: ARRAY
1866: PPUSH
1867: LD_VAR 0 6
1871: PUSH
1872: LD_VAR 0 2
1876: ARRAY
1877: PUSH
1878: LD_INT 4
1880: ARRAY
1881: PPUSH
1882: LD_INT 40
1884: PPUSH
1885: CALL 491 0 7
1889: ST_TO_ADDR
// if not got_mech then
1890: LD_VAR 0 7
1894: NOT
1895: IFFALSE 1921
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1897: LD_VAR 0 3
1901: PPUSH
1902: LD_VAR 0 6
1906: PUSH
1907: LD_VAR 0 2
1911: ARRAY
1912: PUSH
1913: LD_INT 6
1915: ARRAY
1916: PPUSH
1917: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1921: LD_ADDR_VAR 0 4
1925: PUSH
1926: LD_VAR 0 4
1930: PPUSH
1931: LD_INT 1
1933: PPUSH
1934: LD_VAR 0 3
1938: PPUSH
1939: CALL_OW 2
1943: ST_TO_ADDR
// end ;
1944: GO 1808
1946: POP
1947: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1948: LD_EXP 31
1952: PPUSH
1953: LD_INT 194
1955: PPUSH
1956: LD_INT 119
1958: PPUSH
1959: LD_INT 0
1961: PPUSH
1962: CALL_OW 48
// if tmp then
1966: LD_VAR 0 4
1970: IFFALSE 2095
// begin for i in tmp do
1972: LD_ADDR_VAR 0 2
1976: PUSH
1977: LD_VAR 0 4
1981: PUSH
1982: FOR_IN
1983: IFFALSE 2093
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1985: LD_ADDR_VAR 0 8
1989: PUSH
1990: LD_INT 22
1992: PUSH
1993: LD_INT 1
1995: PUSH
1996: EMPTY
1997: LIST
1998: LIST
1999: PUSH
2000: LD_INT 21
2002: PUSH
2003: LD_INT 2
2005: PUSH
2006: EMPTY
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 58
2012: PUSH
2013: EMPTY
2014: LIST
2015: PUSH
2016: EMPTY
2017: LIST
2018: LIST
2019: LIST
2020: PPUSH
2021: CALL_OW 69
2025: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2026: LD_VAR 0 2
2030: PPUSH
2031: CALL_OW 247
2035: PUSH
2036: LD_INT 1
2038: EQUAL
2039: PUSH
2040: LD_VAR 0 8
2044: AND
2045: IFFALSE 2067
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2047: LD_VAR 0 2
2051: PPUSH
2052: LD_VAR 0 8
2056: PUSH
2057: LD_INT 1
2059: ARRAY
2060: PPUSH
2061: CALL_OW 52
2065: GO 2082
// PlaceUnitArea ( i , startArea , false ) ;
2067: LD_VAR 0 2
2071: PPUSH
2072: LD_INT 1
2074: PPUSH
2075: LD_INT 0
2077: PPUSH
2078: CALL_OW 49
// ComHold ( i ) ;
2082: LD_VAR 0 2
2086: PPUSH
2087: CALL_OW 140
// end ;
2091: GO 1982
2093: POP
2094: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2095: LD_ADDR_EXP 5
2099: PUSH
2100: LD_STRING 02_mikhailStatus_1
2102: PPUSH
2103: LD_INT 0
2105: PPUSH
2106: CALL_OW 30
2110: ST_TO_ADDR
// if not bierezov_exist and not debug then
2111: LD_EXP 5
2115: NOT
2116: PUSH
2117: LD_EXP 1
2121: NOT
2122: AND
2123: IFFALSE 2127
// exit ;
2125: GO 2158
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2127: LD_ADDR_EXP 39
2131: PUSH
2132: LD_STRING Mikhail
2134: PPUSH
2135: LD_INT 0
2137: PPUSH
2138: CALL 434 0 2
2142: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2143: LD_EXP 39
2147: PPUSH
2148: LD_INT 1
2150: PPUSH
2151: LD_INT 0
2153: PPUSH
2154: CALL_OW 49
// end ;
2158: LD_VAR 0 1
2162: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2163: LD_INT 0
2165: PPUSH
2166: PPUSH
2167: PPUSH
2168: PPUSH
// uc_side := 4 ;
2169: LD_ADDR_OWVAR 20
2173: PUSH
2174: LD_INT 4
2176: ST_TO_ADDR
// uc_nation := 1 ;
2177: LD_ADDR_OWVAR 21
2181: PUSH
2182: LD_INT 1
2184: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2185: LD_ADDR_EXP 38
2189: PUSH
2190: LD_STRING Cornell
2192: PPUSH
2193: LD_INT 0
2195: PPUSH
2196: CALL 434 0 2
2200: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
2201: LD_ADDR_EXP 4
2205: PUSH
2206: LD_INT 8
2208: PUSH
2209: LD_EXP 2
2213: MINUS
2214: ST_TO_ADDR
// tmp := [ ] ;
2215: LD_ADDR_VAR 0 2
2219: PUSH
2220: EMPTY
2221: ST_TO_ADDR
// if cornel_units < 3 then
2222: LD_EXP 4
2226: PUSH
2227: LD_INT 3
2229: LESS
2230: IFFALSE 2240
// cornel_units := 3 ;
2232: LD_ADDR_EXP 4
2236: PUSH
2237: LD_INT 3
2239: ST_TO_ADDR
// for i = 1 to cornel_units do
2240: LD_ADDR_VAR 0 4
2244: PUSH
2245: DOUBLE
2246: LD_INT 1
2248: DEC
2249: ST_TO_ADDR
2250: LD_EXP 4
2254: PUSH
2255: FOR_TO
2256: IFFALSE 2354
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2258: LD_INT 0
2260: PPUSH
2261: LD_INT 1
2263: PUSH
2264: LD_INT 1
2266: PUSH
2267: LD_INT 1
2269: PUSH
2270: LD_INT 2
2272: PUSH
2273: LD_INT 4
2275: PUSH
2276: EMPTY
2277: LIST
2278: LIST
2279: LIST
2280: LIST
2281: LIST
2282: PUSH
2283: LD_VAR 0 4
2287: PUSH
2288: LD_INT 5
2290: MOD
2291: PUSH
2292: LD_INT 1
2294: PLUS
2295: ARRAY
2296: PPUSH
2297: LD_INT 2
2299: PPUSH
2300: CALL_OW 380
// un := CreateHuman ;
2304: LD_ADDR_VAR 0 3
2308: PUSH
2309: CALL_OW 44
2313: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2314: LD_ADDR_VAR 0 2
2318: PUSH
2319: LD_VAR 0 2
2323: PPUSH
2324: LD_INT 1
2326: PPUSH
2327: LD_VAR 0 3
2331: PPUSH
2332: CALL_OW 2
2336: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2337: LD_VAR 0 3
2341: PPUSH
2342: LD_INT 2
2344: PPUSH
2345: LD_INT 0
2347: PPUSH
2348: CALL_OW 49
// end ;
2352: GO 2255
2354: POP
2355: POP
// cornel_units := tmp ;
2356: LD_ADDR_EXP 4
2360: PUSH
2361: LD_VAR 0 2
2365: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2366: LD_EXP 38
2370: PPUSH
2371: LD_INT 191
2373: PPUSH
2374: LD_INT 106
2376: PPUSH
2377: LD_INT 0
2379: PPUSH
2380: CALL_OW 48
// end ;
2384: LD_VAR 0 1
2388: RET
// export function PrepareWesternBase ; var i ; begin
2389: LD_INT 0
2391: PPUSH
2392: PPUSH
// uc_side := 8 ;
2393: LD_ADDR_OWVAR 20
2397: PUSH
2398: LD_INT 8
2400: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2401: LD_ADDR_EXP 41
2405: PUSH
2406: LD_STRING Lynch
2408: PPUSH
2409: LD_INT 0
2411: PPUSH
2412: CALL 434 0 2
2416: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2417: LD_ADDR_EXP 42
2421: PUSH
2422: LD_STRING Walker
2424: PPUSH
2425: LD_INT 0
2427: PPUSH
2428: CALL 434 0 2
2432: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2433: LD_ADDR_EXP 43
2437: PUSH
2438: LD_STRING Turner
2440: PPUSH
2441: LD_INT 0
2443: PPUSH
2444: CALL 434 0 2
2448: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2449: LD_ADDR_EXP 44
2453: PUSH
2454: LD_STRING Jillian
2456: PPUSH
2457: LD_INT 0
2459: PPUSH
2460: CALL 434 0 2
2464: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2465: LD_ADDR_VAR 0 2
2469: PUSH
2470: LD_EXP 41
2474: PUSH
2475: LD_EXP 42
2479: PUSH
2480: LD_EXP 43
2484: PUSH
2485: LD_EXP 44
2489: PUSH
2490: EMPTY
2491: LIST
2492: LIST
2493: LIST
2494: LIST
2495: PUSH
2496: FOR_IN
2497: IFFALSE 2525
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2499: LD_VAR 0 2
2503: PPUSH
2504: LD_INT 3
2506: PPUSH
2507: LD_INT 0
2509: PPUSH
2510: CALL_OW 49
// ComHold ( i ) ;
2514: LD_VAR 0 2
2518: PPUSH
2519: CALL_OW 140
// end ;
2523: GO 2496
2525: POP
2526: POP
// end ;
2527: LD_VAR 0 1
2531: RET
// export function SelectGroup ; var units , selected , i ; begin
2532: LD_INT 0
2534: PPUSH
2535: PPUSH
2536: PPUSH
2537: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2538: LD_ADDR_VAR 0 2
2542: PUSH
2543: LD_EXP 31
2547: PUSH
2548: LD_INT -3
2550: PUSH
2551: EMPTY
2552: LIST
2553: LIST
2554: PUSH
2555: LD_EXP 2
2559: ADD
2560: PUSH
2561: LD_INT -2
2563: PUSH
2564: LD_INT -4
2566: PUSH
2567: LD_EXP 38
2571: PUSH
2572: LD_EXP 39
2576: PUSH
2577: EMPTY
2578: LIST
2579: LIST
2580: LIST
2581: LIST
2582: ADD
2583: PUSH
2584: LD_INT -3
2586: PUSH
2587: EMPTY
2588: LIST
2589: ADD
2590: PUSH
2591: LD_EXP 4
2595: ADD
2596: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2597: LD_ADDR_VAR 0 3
2601: PUSH
2602: LD_EXP 31
2606: PUSH
2607: LD_STRING Select five characters to go with you
2609: PPUSH
2610: LD_INT 4
2612: PPUSH
2613: LD_INT 4
2615: PPUSH
2616: LD_VAR 0 2
2620: PPUSH
2621: EMPTY
2622: PPUSH
2623: CALL_OW 42
2627: ADD
2628: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2629: LD_ADDR_EXP 4
2633: PUSH
2634: LD_EXP 2
2638: PUSH
2639: LD_EXP 4
2643: UNION
2644: PUSH
2645: LD_VAR 0 3
2649: DIFF
2650: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2651: LD_ADDR_VAR 0 4
2655: PUSH
2656: LD_EXP 4
2660: PUSH
2661: LD_EXP 39
2665: ADD
2666: PUSH
2667: FOR_IN
2668: IFFALSE 2699
// if GetSide ( i ) = 1 then
2670: LD_VAR 0 4
2674: PPUSH
2675: CALL_OW 255
2679: PUSH
2680: LD_INT 1
2682: EQUAL
2683: IFFALSE 2697
// SetSide ( i , 4 ) ;
2685: LD_VAR 0 4
2689: PPUSH
2690: LD_INT 4
2692: PPUSH
2693: CALL_OW 235
2697: GO 2667
2699: POP
2700: POP
// for i in selected do
2701: LD_ADDR_VAR 0 4
2705: PUSH
2706: LD_VAR 0 3
2710: PUSH
2711: FOR_IN
2712: IFFALSE 2743
// if GetSide ( i ) = 4 then
2714: LD_VAR 0 4
2718: PPUSH
2719: CALL_OW 255
2723: PUSH
2724: LD_INT 4
2726: EQUAL
2727: IFFALSE 2741
// SetSide ( i , 1 ) ;
2729: LD_VAR 0 4
2733: PPUSH
2734: LD_INT 1
2736: PPUSH
2737: CALL_OW 235
2741: GO 2711
2743: POP
2744: POP
// jmm_units := jmm_units diff cornel_units ;
2745: LD_ADDR_EXP 2
2749: PUSH
2750: LD_EXP 2
2754: PUSH
2755: LD_EXP 4
2759: DIFF
2760: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2761: LD_EXP 32
2765: PPUSH
2766: CALL_OW 255
2770: PUSH
2771: LD_INT 4
2773: EQUAL
2774: IFFALSE 2783
// DeleteCharacters ( Bobby ) ;
2776: LD_STRING Bobby
2778: PPUSH
2779: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2783: LD_EXP 33
2787: PPUSH
2788: CALL_OW 255
2792: PUSH
2793: LD_INT 4
2795: EQUAL
2796: IFFALSE 2805
// DeleteCharacters ( Cyrus ) ;
2798: LD_STRING Cyrus
2800: PPUSH
2801: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2805: LD_EXP 34
2809: PPUSH
2810: CALL_OW 255
2814: PUSH
2815: LD_INT 4
2817: EQUAL
2818: IFFALSE 2827
// DeleteCharacters ( Lisa ) ;
2820: LD_STRING Lisa
2822: PPUSH
2823: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2827: LD_EXP 35
2831: PPUSH
2832: CALL_OW 255
2836: PUSH
2837: LD_INT 4
2839: EQUAL
2840: IFFALSE 2849
// DeleteCharacters ( Khatam ) ;
2842: LD_STRING Khatam
2844: PPUSH
2845: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2849: LD_EXP 36
2853: PPUSH
2854: CALL_OW 255
2858: PUSH
2859: LD_INT 4
2861: EQUAL
2862: IFFALSE 2871
// DeleteCharacters ( Brian ) ;
2864: LD_STRING Brian
2866: PPUSH
2867: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2871: LD_EXP 37
2875: PPUSH
2876: CALL_OW 255
2880: PUSH
2881: LD_INT 4
2883: EQUAL
2884: IFFALSE 2893
// DeleteCharacters ( Jerry ) ;
2886: LD_STRING Jerry
2888: PPUSH
2889: CALL_OW 40
// end ; end_of_file
2893: LD_VAR 0 1
2897: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
2898: LD_INT 0
2900: PPUSH
2901: PPUSH
2902: PPUSH
2903: PPUSH
2904: PPUSH
2905: PPUSH
2906: PPUSH
2907: PPUSH
2908: PPUSH
2909: PPUSH
2910: PPUSH
2911: PPUSH
2912: PPUSH
// ru_alert := false ;
2913: LD_ADDR_EXP 54
2917: PUSH
2918: LD_INT 0
2920: ST_TO_ADDR
// ru_produce_list := [ ] ;
2921: LD_ADDR_EXP 51
2925: PUSH
2926: EMPTY
2927: ST_TO_ADDR
// if Difficulty > 1 then
2928: LD_OWVAR 67
2932: PUSH
2933: LD_INT 1
2935: GREATER
2936: IFFALSE 3024
// begin uc_side := 3 ;
2938: LD_ADDR_OWVAR 20
2942: PUSH
2943: LD_INT 3
2945: ST_TO_ADDR
// uc_nation := 3 ;
2946: LD_ADDR_OWVAR 21
2950: PUSH
2951: LD_INT 3
2953: ST_TO_ADDR
// bc_type := b_breastwork ;
2954: LD_ADDR_OWVAR 42
2958: PUSH
2959: LD_INT 31
2961: ST_TO_ADDR
// bc_level := Difficulty ;
2962: LD_ADDR_OWVAR 43
2966: PUSH
2967: LD_OWVAR 67
2971: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
2972: LD_INT 22
2974: PPUSH
2975: LD_INT 14
2977: PPUSH
2978: LD_INT 0
2980: PPUSH
2981: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
2985: LD_INT 48
2987: PPUSH
2988: LD_INT 46
2990: PPUSH
2991: LD_INT 0
2993: PPUSH
2994: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
2998: LD_INT 86
3000: PPUSH
3001: LD_INT 65
3003: PPUSH
3004: LD_INT 5
3006: PPUSH
3007: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3011: LD_INT 165
3013: PPUSH
3014: LD_INT 73
3016: PPUSH
3017: LD_INT 5
3019: PPUSH
3020: CALL_OW 47
// end ; tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3024: LD_ADDR_VAR 0 7
3028: PUSH
3029: LD_INT 22
3031: PUSH
3032: LD_INT 3
3034: PUSH
3035: EMPTY
3036: LIST
3037: LIST
3038: PUSH
3039: LD_INT 2
3041: PUSH
3042: LD_INT 30
3044: PUSH
3045: LD_INT 31
3047: PUSH
3048: EMPTY
3049: LIST
3050: LIST
3051: PUSH
3052: LD_INT 30
3054: PUSH
3055: LD_INT 32
3057: PUSH
3058: EMPTY
3059: LIST
3060: LIST
3061: PUSH
3062: EMPTY
3063: LIST
3064: LIST
3065: LIST
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: PPUSH
3071: CALL_OW 69
3075: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3076: LD_ADDR_VAR 0 8
3080: PUSH
3081: LD_INT 22
3083: PUSH
3084: LD_INT 3
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 30
3093: PUSH
3094: LD_INT 4
3096: PUSH
3097: EMPTY
3098: LIST
3099: LIST
3100: PUSH
3101: EMPTY
3102: LIST
3103: LIST
3104: PPUSH
3105: CALL_OW 69
3109: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3110: LD_ADDR_VAR 0 10
3114: PUSH
3115: LD_INT 22
3117: PUSH
3118: LD_INT 3
3120: PUSH
3121: EMPTY
3122: LIST
3123: LIST
3124: PUSH
3125: LD_INT 30
3127: PUSH
3128: LD_INT 3
3130: PUSH
3131: EMPTY
3132: LIST
3133: LIST
3134: PUSH
3135: EMPTY
3136: LIST
3137: LIST
3138: PPUSH
3139: CALL_OW 69
3143: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3144: LD_ADDR_VAR 0 9
3148: PUSH
3149: LD_INT 22
3151: PUSH
3152: LD_INT 3
3154: PUSH
3155: EMPTY
3156: LIST
3157: LIST
3158: PUSH
3159: LD_INT 30
3161: PUSH
3162: LD_INT 6
3164: PUSH
3165: EMPTY
3166: LIST
3167: LIST
3168: PUSH
3169: EMPTY
3170: LIST
3171: LIST
3172: PPUSH
3173: CALL_OW 69
3177: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3178: LD_ADDR_VAR 0 2
3182: PUSH
3183: LD_INT 22
3185: PUSH
3186: LD_INT 3
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: PUSH
3193: LD_INT 30
3195: PUSH
3196: LD_INT 1
3198: PUSH
3199: EMPTY
3200: LIST
3201: LIST
3202: PUSH
3203: EMPTY
3204: LIST
3205: LIST
3206: PPUSH
3207: CALL_OW 69
3211: PUSH
3212: FOR_IN
3213: IFFALSE 3257
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3215: LD_VAR 0 2
3219: PPUSH
3220: CALL_OW 274
3224: PPUSH
3225: LD_INT 1
3227: PPUSH
3228: LD_INT 5000
3230: PPUSH
3231: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3235: LD_VAR 0 2
3239: PPUSH
3240: CALL_OW 274
3244: PPUSH
3245: LD_INT 2
3247: PPUSH
3248: LD_INT 3000
3250: PPUSH
3251: CALL_OW 277
// end ;
3255: GO 3212
3257: POP
3258: POP
// uc_side := 3 ;
3259: LD_ADDR_OWVAR 20
3263: PUSH
3264: LD_INT 3
3266: ST_TO_ADDR
// uc_nation := 3 ;
3267: LD_ADDR_OWVAR 21
3271: PUSH
3272: LD_INT 3
3274: ST_TO_ADDR
// skill := [ 2 , 2 , 3 ] [ Difficulty ] ;
3275: LD_ADDR_VAR 0 11
3279: PUSH
3280: LD_INT 2
3282: PUSH
3283: LD_INT 2
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: EMPTY
3290: LIST
3291: LIST
3292: LIST
3293: PUSH
3294: LD_OWVAR 67
3298: ARRAY
3299: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3300: LD_ADDR_EXP 46
3304: PUSH
3305: LD_STRING Pokryshkin
3307: PPUSH
3308: LD_INT 0
3310: PPUSH
3311: CALL 434 0 2
3315: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3316: LD_EXP 46
3320: PPUSH
3321: LD_INT 63
3323: PPUSH
3324: LD_INT 21
3326: PPUSH
3327: LD_INT 0
3329: PPUSH
3330: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3334: LD_EXP 46
3338: PPUSH
3339: CALL_OW 140
// InitHc ;
3343: CALL_OW 19
// for i in fac do
3347: LD_ADDR_VAR 0 2
3351: PUSH
3352: LD_VAR 0 10
3356: PUSH
3357: FOR_IN
3358: IFFALSE 3411
// begin for j = 1 to 6 do
3360: LD_ADDR_VAR 0 3
3364: PUSH
3365: DOUBLE
3366: LD_INT 1
3368: DEC
3369: ST_TO_ADDR
3370: LD_INT 6
3372: PUSH
3373: FOR_TO
3374: IFFALSE 3407
// begin PrepareHuman ( false , 3 , skill ) ;
3376: LD_INT 0
3378: PPUSH
3379: LD_INT 3
3381: PPUSH
3382: LD_VAR 0 11
3386: PPUSH
3387: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3391: CALL_OW 44
3395: PPUSH
3396: LD_VAR 0 2
3400: PPUSH
3401: CALL_OW 52
// end ;
3405: GO 3373
3407: POP
3408: POP
// end ;
3409: GO 3357
3411: POP
3412: POP
// for i in lab do
3413: LD_ADDR_VAR 0 2
3417: PUSH
3418: LD_VAR 0 9
3422: PUSH
3423: FOR_IN
3424: IFFALSE 3457
// begin PrepareHuman ( false , 4 , skill ) ;
3426: LD_INT 0
3428: PPUSH
3429: LD_INT 4
3431: PPUSH
3432: LD_VAR 0 11
3436: PPUSH
3437: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3441: CALL_OW 44
3445: PPUSH
3446: LD_VAR 0 2
3450: PPUSH
3451: CALL_OW 52
// end ;
3455: GO 3423
3457: POP
3458: POP
// for i in tw do
3459: LD_ADDR_VAR 0 2
3463: PUSH
3464: LD_VAR 0 7
3468: PUSH
3469: FOR_IN
3470: IFFALSE 3519
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3472: LD_VAR 0 2
3476: PPUSH
3477: LD_INT 42
3479: PUSH
3480: LD_INT 43
3482: PUSH
3483: EMPTY
3484: LIST
3485: LIST
3486: PUSH
3487: LD_INT 1
3489: PPUSH
3490: LD_INT 2
3492: PPUSH
3493: CALL_OW 12
3497: ARRAY
3498: PPUSH
3499: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3503: LD_VAR 0 11
3507: PPUSH
3508: LD_VAR 0 2
3512: PPUSH
3513: CALL 769 0 2
// end ;
3517: GO 3469
3519: POP
3520: POP
// for i in bar do
3521: LD_ADDR_VAR 0 2
3525: PUSH
3526: LD_VAR 0 8
3530: PUSH
3531: FOR_IN
3532: IFFALSE 3565
// begin PrepareHuman ( false , 1 , skill ) ;
3534: LD_INT 0
3536: PPUSH
3537: LD_INT 1
3539: PPUSH
3540: LD_VAR 0 11
3544: PPUSH
3545: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3549: CALL_OW 44
3553: PPUSH
3554: LD_VAR 0 2
3558: PPUSH
3559: CALL_OW 52
// end ;
3563: GO 3531
3565: POP
3566: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3567: LD_ADDR_VAR 0 13
3571: PUSH
3572: LD_INT 100
3574: PUSH
3575: LD_INT 9
3577: PUSH
3578: EMPTY
3579: LIST
3580: LIST
3581: PUSH
3582: LD_INT 135
3584: PUSH
3585: LD_INT 60
3587: PUSH
3588: EMPTY
3589: LIST
3590: LIST
3591: PUSH
3592: LD_INT 41
3594: PUSH
3595: LD_INT 6
3597: PUSH
3598: EMPTY
3599: LIST
3600: LIST
3601: PUSH
3602: LD_INT 22
3604: PUSH
3605: LD_INT 9
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: PUSH
3612: LD_INT 84
3614: PUSH
3615: LD_INT 14
3617: PUSH
3618: EMPTY
3619: LIST
3620: LIST
3621: PUSH
3622: EMPTY
3623: LIST
3624: LIST
3625: LIST
3626: LIST
3627: LIST
3628: ST_TO_ADDR
// vehicles := [ ] ;
3629: LD_ADDR_VAR 0 12
3633: PUSH
3634: EMPTY
3635: ST_TO_ADDR
// for i in spot_xy do
3636: LD_ADDR_VAR 0 2
3640: PUSH
3641: LD_VAR 0 13
3645: PUSH
3646: FOR_IN
3647: IFFALSE 3805
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3649: LD_ADDR_VAR 0 6
3653: PUSH
3654: LD_INT 3
3656: PPUSH
3657: LD_INT 3
3659: PPUSH
3660: LD_INT 22
3662: PPUSH
3663: LD_INT 1
3665: PPUSH
3666: LD_INT 1
3668: PPUSH
3669: LD_INT 42
3671: PUSH
3672: LD_INT 43
3674: PUSH
3675: LD_INT 44
3677: PUSH
3678: EMPTY
3679: LIST
3680: LIST
3681: LIST
3682: PUSH
3683: LD_INT 1
3685: PPUSH
3686: LD_INT 3
3688: PPUSH
3689: CALL_OW 12
3693: ARRAY
3694: PPUSH
3695: LD_INT 100
3697: PPUSH
3698: CALL 491 0 7
3702: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3703: LD_ADDR_VAR 0 12
3707: PUSH
3708: LD_VAR 0 12
3712: PPUSH
3713: LD_VAR 0 12
3717: PUSH
3718: LD_INT 1
3720: PLUS
3721: PPUSH
3722: LD_VAR 0 6
3726: PPUSH
3727: CALL_OW 2
3731: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3732: LD_VAR 0 6
3736: PPUSH
3737: LD_INT 3
3739: PPUSH
3740: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3744: LD_VAR 0 6
3748: PPUSH
3749: LD_VAR 0 2
3753: PUSH
3754: LD_INT 1
3756: ARRAY
3757: PPUSH
3758: LD_VAR 0 2
3762: PUSH
3763: LD_INT 2
3765: ARRAY
3766: PPUSH
3767: LD_INT 0
3769: PPUSH
3770: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3774: LD_INT 0
3776: PPUSH
3777: LD_INT 3
3779: PPUSH
3780: LD_VAR 0 11
3784: PPUSH
3785: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3789: CALL_OW 44
3793: PPUSH
3794: LD_VAR 0 6
3798: PPUSH
3799: CALL_OW 52
// end ;
3803: GO 3646
3805: POP
3806: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3807: LD_ADDR_VAR 0 2
3811: PUSH
3812: DOUBLE
3813: LD_INT 1
3815: DEC
3816: ST_TO_ADDR
3817: LD_INT 5
3819: PUSH
3820: LD_INT 7
3822: PUSH
3823: LD_INT 8
3825: PUSH
3826: EMPTY
3827: LIST
3828: LIST
3829: LIST
3830: PUSH
3831: LD_OWVAR 67
3835: ARRAY
3836: PUSH
3837: FOR_TO
3838: IFFALSE 3898
// begin PrepareHuman ( false , 1 , skill ) ;
3840: LD_INT 0
3842: PPUSH
3843: LD_INT 1
3845: PPUSH
3846: LD_VAR 0 11
3850: PPUSH
3851: CALL_OW 380
// un := CreateHuman ;
3855: LD_ADDR_VAR 0 5
3859: PUSH
3860: CALL_OW 44
3864: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3865: LD_VAR 0 5
3869: PPUSH
3870: LD_INT 11
3872: PPUSH
3873: LD_INT 0
3875: PPUSH
3876: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3880: LD_ADDR_EXP 49
3884: PUSH
3885: LD_EXP 49
3889: PUSH
3890: LD_VAR 0 5
3894: ADD
3895: ST_TO_ADDR
// end ;
3896: GO 3837
3898: POP
3899: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3900: LD_ADDR_VAR 0 2
3904: PUSH
3905: DOUBLE
3906: LD_INT 1
3908: DEC
3909: ST_TO_ADDR
3910: LD_INT 2
3912: PUSH
3913: LD_INT 3
3915: PUSH
3916: LD_INT 4
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: LIST
3923: PUSH
3924: LD_OWVAR 67
3928: ARRAY
3929: PUSH
3930: FOR_TO
3931: IFFALSE 3991
// begin PrepareHuman ( false , 1 , skill ) ;
3933: LD_INT 0
3935: PPUSH
3936: LD_INT 1
3938: PPUSH
3939: LD_VAR 0 11
3943: PPUSH
3944: CALL_OW 380
// un := CreateHuman ;
3948: LD_ADDR_VAR 0 5
3952: PUSH
3953: CALL_OW 44
3957: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
3958: LD_VAR 0 5
3962: PPUSH
3963: LD_INT 12
3965: PPUSH
3966: LD_INT 0
3968: PPUSH
3969: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
3973: LD_ADDR_EXP 47
3977: PUSH
3978: LD_EXP 47
3982: PUSH
3983: LD_VAR 0 5
3987: ADD
3988: ST_TO_ADDR
// end ;
3989: GO 3930
3991: POP
3992: POP
// for i = 1 to 2 do
3993: LD_ADDR_VAR 0 2
3997: PUSH
3998: DOUBLE
3999: LD_INT 1
4001: DEC
4002: ST_TO_ADDR
4003: LD_INT 2
4005: PUSH
4006: FOR_TO
4007: IFFALSE 4073
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4009: LD_INT 1
4011: PPUSH
4012: LD_INT 1
4014: PPUSH
4015: LD_VAR 0 11
4019: PPUSH
4020: CALL_OW 380
// un := CreateHuman ;
4024: LD_ADDR_VAR 0 5
4028: PUSH
4029: CALL_OW 44
4033: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4034: LD_VAR 0 5
4038: PPUSH
4039: LD_INT 39
4041: PPUSH
4042: LD_INT 12
4044: PPUSH
4045: LD_INT 3
4047: PPUSH
4048: LD_INT 0
4050: PPUSH
4051: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4055: LD_ADDR_EXP 48
4059: PUSH
4060: LD_EXP 48
4064: PUSH
4065: LD_VAR 0 5
4069: ADD
4070: ST_TO_ADDR
// end ;
4071: GO 4006
4073: POP
4074: POP
// for i = 1 to 3 do
4075: LD_ADDR_VAR 0 2
4079: PUSH
4080: DOUBLE
4081: LD_INT 1
4083: DEC
4084: ST_TO_ADDR
4085: LD_INT 3
4087: PUSH
4088: FOR_TO
4089: IFFALSE 4155
// begin PrepareHuman ( false , 1 , skill ) ;
4091: LD_INT 0
4093: PPUSH
4094: LD_INT 1
4096: PPUSH
4097: LD_VAR 0 11
4101: PPUSH
4102: CALL_OW 380
// un := CreateHuman ;
4106: LD_ADDR_VAR 0 5
4110: PUSH
4111: CALL_OW 44
4115: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4116: LD_VAR 0 5
4120: PPUSH
4121: LD_INT 180
4123: PPUSH
4124: LD_INT 11
4126: PPUSH
4127: LD_INT 4
4129: PPUSH
4130: LD_INT 0
4132: PPUSH
4133: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4137: LD_ADDR_EXP 52
4141: PUSH
4142: LD_EXP 52
4146: PUSH
4147: LD_VAR 0 5
4151: ADD
4152: ST_TO_ADDR
// end ;
4153: GO 4088
4155: POP
4156: POP
// ru_vehicles := vehicles ;
4157: LD_ADDR_EXP 50
4161: PUSH
4162: LD_VAR 0 12
4166: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4167: LD_ADDR_EXP 53
4171: PUSH
4172: LD_INT 131
4174: PUSH
4175: LD_INT 121
4177: PUSH
4178: EMPTY
4179: LIST
4180: LIST
4181: PUSH
4182: LD_INT 113
4184: PUSH
4185: LD_INT 90
4187: PUSH
4188: EMPTY
4189: LIST
4190: LIST
4191: PUSH
4192: LD_INT 93
4194: PUSH
4195: LD_INT 62
4197: PUSH
4198: EMPTY
4199: LIST
4200: LIST
4201: PUSH
4202: EMPTY
4203: LIST
4204: LIST
4205: LIST
4206: PUSH
4207: LD_INT 106
4209: PUSH
4210: LD_INT 54
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: PUSH
4217: LD_INT 120
4219: PUSH
4220: LD_INT 80
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: PUSH
4227: LD_INT 143
4229: PUSH
4230: LD_INT 120
4232: PUSH
4233: EMPTY
4234: LIST
4235: LIST
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 154
4244: PUSH
4245: LD_INT 116
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: LD_INT 140
4254: PUSH
4255: LD_INT 93
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: PUSH
4262: LD_INT 130
4264: PUSH
4265: LD_INT 58
4267: PUSH
4268: EMPTY
4269: LIST
4270: LIST
4271: PUSH
4272: EMPTY
4273: LIST
4274: LIST
4275: LIST
4276: PUSH
4277: LD_INT 105
4279: PUSH
4280: LD_INT 106
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PUSH
4287: LD_INT 134
4289: PUSH
4290: LD_INT 98
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: PUSH
4297: LD_INT 159
4299: PUSH
4300: LD_INT 113
4302: PUSH
4303: EMPTY
4304: LIST
4305: LIST
4306: PUSH
4307: EMPTY
4308: LIST
4309: LIST
4310: LIST
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: LIST
4316: LIST
4317: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4318: LD_ADDR_VAR 0 2
4322: PUSH
4323: DOUBLE
4324: LD_INT 1
4326: DEC
4327: ST_TO_ADDR
4328: LD_OWVAR 67
4332: PUSH
4333: LD_INT 1
4335: MINUS
4336: PUSH
4337: FOR_TO
4338: IFFALSE 4371
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4340: LD_ADDR_EXP 51
4344: PUSH
4345: LD_EXP 51
4349: PUSH
4350: LD_INT 22
4352: PUSH
4353: LD_INT 1
4355: PUSH
4356: LD_INT 1
4358: PUSH
4359: LD_INT 43
4361: PUSH
4362: EMPTY
4363: LIST
4364: LIST
4365: LIST
4366: LIST
4367: ADD
4368: ST_TO_ADDR
4369: GO 4337
4371: POP
4372: POP
// end ;
4373: LD_VAR 0 1
4377: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4378: LD_INT 22
4380: PUSH
4381: LD_INT 3
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PUSH
4388: LD_INT 21
4390: PUSH
4391: LD_INT 2
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PPUSH
4402: CALL_OW 69
4406: IFFALSE 4500
4408: GO 4410
4410: DISABLE
4411: LD_INT 0
4413: PPUSH
4414: PPUSH
// begin enable ;
4415: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4416: LD_ADDR_VAR 0 2
4420: PUSH
4421: LD_INT 22
4423: PUSH
4424: LD_INT 3
4426: PUSH
4427: EMPTY
4428: LIST
4429: LIST
4430: PUSH
4431: LD_INT 21
4433: PUSH
4434: LD_INT 2
4436: PUSH
4437: EMPTY
4438: LIST
4439: LIST
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: PPUSH
4445: CALL_OW 69
4449: ST_TO_ADDR
// if filter then
4450: LD_VAR 0 2
4454: IFFALSE 4500
// for i in filter do
4456: LD_ADDR_VAR 0 1
4460: PUSH
4461: LD_VAR 0 2
4465: PUSH
4466: FOR_IN
4467: IFFALSE 4498
// if GetFuel ( i ) < 20 then
4469: LD_VAR 0 1
4473: PPUSH
4474: CALL_OW 261
4478: PUSH
4479: LD_INT 20
4481: LESS
4482: IFFALSE 4496
// SetFuel ( i , 20 ) ;
4484: LD_VAR 0 1
4488: PPUSH
4489: LD_INT 20
4491: PPUSH
4492: CALL_OW 240
4496: GO 4466
4498: POP
4499: POP
// end ;
4500: PPOPN 2
4502: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4503: LD_EXP 51
4507: IFFALSE 4726
4509: GO 4511
4511: DISABLE
4512: LD_INT 0
4514: PPUSH
4515: PPUSH
4516: PPUSH
// begin enable ;
4517: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4518: LD_ADDR_VAR 0 2
4522: PUSH
4523: LD_INT 22
4525: PUSH
4526: LD_INT 3
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: PUSH
4533: LD_INT 30
4535: PUSH
4536: LD_INT 3
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: PUSH
4543: EMPTY
4544: LIST
4545: LIST
4546: PPUSH
4547: CALL_OW 69
4551: ST_TO_ADDR
// can_produce := [ ] ;
4552: LD_ADDR_VAR 0 3
4556: PUSH
4557: EMPTY
4558: ST_TO_ADDR
// if not fac then
4559: LD_VAR 0 2
4563: NOT
4564: IFFALSE 4569
// begin disable ;
4566: DISABLE
// exit ;
4567: GO 4726
// end ; for i in fac do
4569: LD_ADDR_VAR 0 1
4573: PUSH
4574: LD_VAR 0 2
4578: PUSH
4579: FOR_IN
4580: IFFALSE 4618
// if UnitsInside ( i ) then
4582: LD_VAR 0 1
4586: PPUSH
4587: CALL_OW 313
4591: IFFALSE 4616
// can_produce := Insert ( can_produce , 1 , i ) ;
4593: LD_ADDR_VAR 0 3
4597: PUSH
4598: LD_VAR 0 3
4602: PPUSH
4603: LD_INT 1
4605: PPUSH
4606: LD_VAR 0 1
4610: PPUSH
4611: CALL_OW 2
4615: ST_TO_ADDR
4616: GO 4579
4618: POP
4619: POP
// if not can_produce then
4620: LD_VAR 0 3
4624: NOT
4625: IFFALSE 4629
// exit ;
4627: GO 4726
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4629: LD_VAR 0 3
4633: PUSH
4634: LD_INT 1
4636: PPUSH
4637: LD_VAR 0 3
4641: PPUSH
4642: CALL_OW 12
4646: ARRAY
4647: PPUSH
4648: LD_EXP 51
4652: PUSH
4653: LD_INT 1
4655: ARRAY
4656: PPUSH
4657: LD_EXP 51
4661: PUSH
4662: LD_INT 2
4664: ARRAY
4665: PPUSH
4666: LD_EXP 51
4670: PUSH
4671: LD_INT 3
4673: ARRAY
4674: PPUSH
4675: LD_EXP 51
4679: PUSH
4680: LD_INT 4
4682: ARRAY
4683: PPUSH
4684: CALL_OW 125
// for i = 1 to 4 do
4688: LD_ADDR_VAR 0 1
4692: PUSH
4693: DOUBLE
4694: LD_INT 1
4696: DEC
4697: ST_TO_ADDR
4698: LD_INT 4
4700: PUSH
4701: FOR_TO
4702: IFFALSE 4724
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4704: LD_ADDR_EXP 51
4708: PUSH
4709: LD_EXP 51
4713: PPUSH
4714: LD_INT 1
4716: PPUSH
4717: CALL_OW 3
4721: ST_TO_ADDR
4722: GO 4701
4724: POP
4725: POP
// end ;
4726: PPOPN 3
4728: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4729: LD_INT 0
4731: PPUSH
4732: PPUSH
4733: PPUSH
// for i = 1 to 6 do
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: DOUBLE
4740: LD_INT 1
4742: DEC
4743: ST_TO_ADDR
4744: LD_INT 6
4746: PUSH
4747: FOR_TO
4748: IFFALSE 4897
// begin PrepareHuman ( false , 3 , 3 ) ;
4750: LD_INT 0
4752: PPUSH
4753: LD_INT 3
4755: PPUSH
4756: LD_INT 3
4758: PPUSH
4759: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4763: LD_ADDR_VAR 0 3
4767: PUSH
4768: LD_INT 3
4770: PPUSH
4771: LD_INT 3
4773: PPUSH
4774: LD_INT 22
4776: PPUSH
4777: LD_INT 1
4779: PPUSH
4780: LD_INT 1
4782: PPUSH
4783: LD_INT 43
4785: PUSH
4786: LD_INT 42
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: LD_INT 1
4795: PPUSH
4796: LD_INT 2
4798: PPUSH
4799: CALL_OW 12
4803: ARRAY
4804: PPUSH
4805: LD_INT 70
4807: PPUSH
4808: CALL 491 0 7
4812: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4813: LD_VAR 0 3
4817: PPUSH
4818: LD_INT 4
4820: PPUSH
4821: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4825: LD_VAR 0 3
4829: PPUSH
4830: LD_INT 229
4832: PPUSH
4833: LD_INT 44
4835: PPUSH
4836: LD_INT 0
4838: PPUSH
4839: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4843: CALL_OW 44
4847: PPUSH
4848: LD_VAR 0 3
4852: PPUSH
4853: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4857: LD_ADDR_EXP 50
4861: PUSH
4862: LD_EXP 50
4866: PUSH
4867: LD_VAR 0 3
4871: ADD
4872: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
4873: LD_VAR 0 3
4877: PPUSH
4878: LD_INT 191
4880: PPUSH
4881: LD_INT 32
4883: PPUSH
4884: CALL_OW 111
// Wait ( 0 0$02 ) ;
4888: LD_INT 70
4890: PPUSH
4891: CALL_OW 67
// end ;
4895: GO 4747
4897: POP
4898: POP
// end ; end_of_file
4899: LD_VAR 0 1
4903: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
4904: LD_INT 0
4906: PPUSH
4907: PPUSH
4908: PPUSH
4909: PPUSH
4910: PPUSH
4911: PPUSH
4912: PPUSH
// InGameOn ;
4913: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
4917: LD_EXP 31
4921: PPUSH
4922: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
4926: LD_EXP 31
4930: PPUSH
4931: LD_EXP 38
4935: PPUSH
4936: CALL_OW 119
// if Bierezov then
4940: LD_EXP 39
4944: IFFALSE 4960
// ComTurnUnit ( Bierezov , Cornel ) ;
4946: LD_EXP 39
4950: PPUSH
4951: LD_EXP 38
4955: PPUSH
4956: CALL_OW 119
// for i in jmm_units do
4960: LD_ADDR_VAR 0 2
4964: PUSH
4965: LD_EXP 2
4969: PUSH
4970: FOR_IN
4971: IFFALSE 4989
// ComTurnUnit ( i , Cornel ) ;
4973: LD_VAR 0 2
4977: PPUSH
4978: LD_EXP 38
4982: PPUSH
4983: CALL_OW 119
4987: GO 4970
4989: POP
4990: POP
// units := cornel_units union Cornel ;
4991: LD_ADDR_VAR 0 3
4995: PUSH
4996: LD_EXP 4
5000: PUSH
5001: LD_EXP 38
5005: UNION
5006: ST_TO_ADDR
// repeat wait ( 1 ) ;
5007: LD_INT 1
5009: PPUSH
5010: CALL_OW 67
// for i in units do
5014: LD_ADDR_VAR 0 2
5018: PUSH
5019: LD_VAR 0 3
5023: PUSH
5024: FOR_IN
5025: IFFALSE 5058
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5027: LD_VAR 0 2
5031: PPUSH
5032: LD_EXP 31
5036: PPUSH
5037: CALL_OW 250
5041: PPUSH
5042: LD_EXP 31
5046: PPUSH
5047: CALL_OW 251
5051: PPUSH
5052: CALL_OW 111
5056: GO 5024
5058: POP
5059: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5060: LD_VAR 0 3
5064: PPUSH
5065: LD_INT 92
5067: PUSH
5068: LD_EXP 31
5072: PPUSH
5073: CALL_OW 250
5077: PUSH
5078: LD_EXP 31
5082: PPUSH
5083: CALL_OW 251
5087: PUSH
5088: LD_INT 10
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: LIST
5095: LIST
5096: PPUSH
5097: CALL_OW 72
5101: PUSH
5102: LD_VAR 0 3
5106: EQUAL
5107: IFFALSE 5007
// for i in units do
5109: LD_ADDR_VAR 0 2
5113: PUSH
5114: LD_VAR 0 3
5118: PUSH
5119: FOR_IN
5120: IFFALSE 5138
// ComTurnUnit ( i , JMM ) ;
5122: LD_VAR 0 2
5126: PPUSH
5127: LD_EXP 31
5131: PPUSH
5132: CALL_OW 119
5136: GO 5119
5138: POP
5139: POP
// ComTurnUnit ( Cornel , JMM ) ;
5140: LD_EXP 38
5144: PPUSH
5145: LD_EXP 31
5149: PPUSH
5150: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5154: LD_EXP 31
5158: PPUSH
5159: LD_STRING D1-JMM-1
5161: PPUSH
5162: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5166: LD_EXP 38
5170: PPUSH
5171: LD_STRING D1-Corn-1
5173: PPUSH
5174: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5178: LD_EXP 31
5182: PPUSH
5183: LD_EXP 38
5187: PPUSH
5188: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5192: LD_EXP 38
5196: PPUSH
5197: LD_EXP 31
5201: PPUSH
5202: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5206: LD_INT 35
5208: PPUSH
5209: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5213: LD_EXP 31
5217: PPUSH
5218: LD_EXP 38
5222: PPUSH
5223: CALL_OW 296
5227: PUSH
5228: LD_INT 6
5230: LESS
5231: IFFALSE 5206
// ChangeSideFog ( 4 , 1 ) ;
5233: LD_INT 4
5235: PPUSH
5236: LD_INT 1
5238: PPUSH
5239: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5243: LD_EXP 31
5247: PPUSH
5248: LD_EXP 38
5252: PPUSH
5253: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5257: LD_EXP 38
5261: PPUSH
5262: LD_EXP 31
5266: PPUSH
5267: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5271: LD_EXP 31
5275: PPUSH
5276: LD_STRING D1-JMM-2
5278: PPUSH
5279: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5283: LD_EXP 31
5287: PPUSH
5288: LD_STRING D1-JMM-2a
5290: PPUSH
5291: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5295: LD_EXP 38
5299: PPUSH
5300: LD_STRING D1-Corn-2
5302: PPUSH
5303: CALL_OW 88
// if bierezov_exist or debug then
5307: LD_EXP 5
5311: PUSH
5312: LD_EXP 1
5316: OR
5317: IFFALSE 5558
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5319: LD_EXP 38
5323: PPUSH
5324: LD_EXP 39
5328: PPUSH
5329: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5333: LD_INT 10
5335: PPUSH
5336: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5340: LD_EXP 38
5344: PPUSH
5345: LD_STRING D1a-Corn-1
5347: PPUSH
5348: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5352: LD_EXP 31
5356: PPUSH
5357: LD_EXP 39
5361: PPUSH
5362: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5366: LD_EXP 39
5370: PPUSH
5371: LD_EXP 31
5375: PPUSH
5376: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5380: LD_EXP 31
5384: PPUSH
5385: LD_STRING D1a-JMM-1
5387: PPUSH
5388: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5392: LD_EXP 31
5396: PPUSH
5397: LD_EXP 38
5401: PPUSH
5402: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5406: LD_EXP 38
5410: PPUSH
5411: LD_EXP 31
5415: PPUSH
5416: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5420: LD_EXP 38
5424: PPUSH
5425: LD_STRING D1a-Corn-2
5427: PPUSH
5428: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5432: LD_EXP 31
5436: PPUSH
5437: LD_STRING D1a-JMM-2
5439: PPUSH
5440: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5444: LD_EXP 38
5448: PPUSH
5449: LD_STRING D1a-Corn-3
5451: PPUSH
5452: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5456: LD_EXP 31
5460: PPUSH
5461: LD_STRING D1a-JMM-3
5463: PPUSH
5464: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5468: LD_EXP 38
5472: PPUSH
5473: LD_STRING D1a-Corn-4
5475: PPUSH
5476: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5480: LD_EXP 31
5484: PPUSH
5485: LD_STRING D1a-JMM-4
5487: PPUSH
5488: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5492: LD_EXP 38
5496: PPUSH
5497: LD_STRING D1a-Corn-5
5499: PPUSH
5500: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5504: LD_EXP 39
5508: PPUSH
5509: LD_EXP 38
5513: PPUSH
5514: CALL_OW 250
5518: PPUSH
5519: LD_EXP 38
5523: PPUSH
5524: CALL_OW 251
5528: PUSH
5529: LD_INT 2
5531: MINUS
5532: PPUSH
5533: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5537: LD_EXP 39
5541: PPUSH
5542: LD_EXP 38
5546: PPUSH
5547: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5551: LD_INT 10
5553: PPUSH
5554: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5558: LD_EXP 31
5562: PPUSH
5563: LD_STRING D1b-JMM-1
5565: PPUSH
5566: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5570: LD_EXP 38
5574: PPUSH
5575: LD_STRING D1b-Corn-1
5577: PPUSH
5578: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5582: LD_EXP 31
5586: PPUSH
5587: LD_STRING D1b-JMM-2
5589: PPUSH
5590: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5594: LD_EXP 38
5598: PPUSH
5599: LD_STRING D1b-Corn-2
5601: PPUSH
5602: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5606: LD_EXP 31
5610: PPUSH
5611: LD_STRING D1b-JMM-3
5613: PPUSH
5614: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5618: LD_INT 10
5620: PPUSH
5621: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5625: LD_EXP 40
5629: PPUSH
5630: LD_STRING D1b-Pow-3
5632: PPUSH
5633: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5637: LD_EXP 31
5641: PPUSH
5642: LD_STRING D1b-JMM-4
5644: PPUSH
5645: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5649: LD_EXP 38
5653: PPUSH
5654: LD_STRING D1b-Corn-4
5656: PPUSH
5657: CALL_OW 88
// if Khatam then
5661: LD_EXP 35
5665: IFFALSE 5681
// Say ( Khatam , D1b-Khat-4 ) else
5667: LD_EXP 35
5671: PPUSH
5672: LD_STRING D1b-Khat-4
5674: PPUSH
5675: CALL_OW 88
5679: GO 5717
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
5681: LD_EXP 4
5685: PPUSH
5686: LD_INT 26
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: EMPTY
5693: LIST
5694: LIST
5695: PPUSH
5696: CALL_OW 72
5700: PUSH
5701: LD_EXP 38
5705: PUSH
5706: EMPTY
5707: LIST
5708: DIFF
5709: PPUSH
5710: LD_STRING D1b-Sol1-4
5712: PPUSH
5713: CALL 579 0 2
// if Cyrus then
5717: LD_EXP 33
5721: IFFALSE 5735
// Say ( Cyrus , D1b-Cyrus-4 ) ;
5723: LD_EXP 33
5727: PPUSH
5728: LD_STRING D1b-Cyrus-4
5730: PPUSH
5731: CALL_OW 88
// if Lisa then
5735: LD_EXP 34
5739: IFFALSE 5797
// begin Say ( Lisa , D1b-Lisa-4 ) ;
5741: LD_EXP 34
5745: PPUSH
5746: LD_STRING D1b-Lisa-4
5748: PPUSH
5749: CALL_OW 88
// if Cyrus then
5753: LD_EXP 33
5757: IFFALSE 5797
// begin if not IsInUnit ( Cyrus ) then
5759: LD_EXP 33
5763: PPUSH
5764: CALL_OW 310
5768: NOT
5769: IFFALSE 5785
// ComTurnUnit ( Cyrus , Lisa ) ;
5771: LD_EXP 33
5775: PPUSH
5776: LD_EXP 34
5780: PPUSH
5781: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
5785: LD_EXP 33
5789: PPUSH
5790: LD_STRING D1b-Cyrus-5
5792: PPUSH
5793: CALL_OW 88
// end ; end ; SelectGroup ;
5797: CALL 2532 0 0
// Say ( JMM , D1d-JMM-1 ) ;
5801: LD_EXP 31
5805: PPUSH
5806: LD_STRING D1d-JMM-1
5808: PPUSH
5809: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
5813: LD_EXP 38
5817: PPUSH
5818: LD_STRING D1d-Corn-1
5820: PPUSH
5821: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
5825: LD_ADDR_VAR 0 2
5829: PUSH
5830: LD_EXP 2
5834: PUSH
5835: LD_EXP 4
5839: ADD
5840: PUSH
5841: LD_EXP 31
5845: ADD
5846: PUSH
5847: FOR_IN
5848: IFFALSE 5861
// ComHold ( i ) ;
5850: LD_VAR 0 2
5854: PPUSH
5855: CALL_OW 140
5859: GO 5847
5861: POP
5862: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
5863: LD_ADDR_VAR 0 4
5867: PUSH
5868: LD_INT 22
5870: PUSH
5871: LD_INT 1
5873: PUSH
5874: EMPTY
5875: LIST
5876: LIST
5877: PUSH
5878: LD_INT 21
5880: PUSH
5881: LD_INT 2
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: PUSH
5888: EMPTY
5889: LIST
5890: LIST
5891: PPUSH
5892: CALL_OW 69
5896: ST_TO_ADDR
// if vehicles then
5897: LD_VAR 0 4
5901: IFFALSE 6239
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
5903: LD_EXP 4
5907: PPUSH
5908: LD_INT 55
5910: PUSH
5911: EMPTY
5912: LIST
5913: PPUSH
5914: CALL_OW 72
5918: IFFALSE 5957
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
5920: LD_ADDR_VAR 0 2
5924: PUSH
5925: LD_EXP 4
5929: PPUSH
5930: LD_INT 55
5932: PUSH
5933: EMPTY
5934: LIST
5935: PPUSH
5936: CALL_OW 72
5940: PUSH
5941: FOR_IN
5942: IFFALSE 5955
// ComExitVehicle ( i ) ;
5944: LD_VAR 0 2
5948: PPUSH
5949: CALL_OW 121
5953: GO 5941
5955: POP
5956: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
5957: LD_ADDR_VAR 0 5
5961: PUSH
5962: LD_VAR 0 4
5966: PPUSH
5967: LD_INT 34
5969: PUSH
5970: LD_INT 51
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: PPUSH
5977: CALL_OW 72
5981: ST_TO_ADDR
// if cargos then
5982: LD_VAR 0 5
5986: IFFALSE 6169
// begin vehicles := cargos ;
5988: LD_ADDR_VAR 0 4
5992: PUSH
5993: LD_VAR 0 5
5997: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
5998: LD_ADDR_VAR 0 6
6002: PUSH
6003: LD_STRING 02_resources_4
6005: PPUSH
6006: LD_INT 0
6008: PPUSH
6009: CALL_OW 30
6013: ST_TO_ADDR
// if debug and not resources then
6014: LD_EXP 1
6018: PUSH
6019: LD_VAR 0 6
6023: NOT
6024: AND
6025: IFFALSE 6035
// resources := 160 ;
6027: LD_ADDR_VAR 0 6
6031: PUSH
6032: LD_INT 160
6034: ST_TO_ADDR
// if resources mod 10 then
6035: LD_VAR 0 6
6039: PUSH
6040: LD_INT 10
6042: MOD
6043: IFFALSE 6065
// resources := resources - resources mod 10 ;
6045: LD_ADDR_VAR 0 6
6049: PUSH
6050: LD_VAR 0 6
6054: PUSH
6055: LD_VAR 0 6
6059: PUSH
6060: LD_INT 10
6062: MOD
6063: MINUS
6064: ST_TO_ADDR
// if resources then
6065: LD_VAR 0 6
6069: IFFALSE 6169
// for i in cargos do
6071: LD_ADDR_VAR 0 2
6075: PUSH
6076: LD_VAR 0 5
6080: PUSH
6081: FOR_IN
6082: IFFALSE 6167
// begin if resources < 100 then
6084: LD_VAR 0 6
6088: PUSH
6089: LD_INT 100
6091: LESS
6092: IFFALSE 6114
// begin cargo := resources ;
6094: LD_ADDR_VAR 0 7
6098: PUSH
6099: LD_VAR 0 6
6103: ST_TO_ADDR
// resources := 0 ;
6104: LD_ADDR_VAR 0 6
6108: PUSH
6109: LD_INT 0
6111: ST_TO_ADDR
// end else
6112: GO 6136
// begin cargo := 100 ;
6114: LD_ADDR_VAR 0 7
6118: PUSH
6119: LD_INT 100
6121: ST_TO_ADDR
// resources := resources - 100 ;
6122: LD_ADDR_VAR 0 6
6126: PUSH
6127: LD_VAR 0 6
6131: PUSH
6132: LD_INT 100
6134: MINUS
6135: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6136: LD_VAR 0 2
6140: PPUSH
6141: LD_INT 1
6143: PPUSH
6144: LD_VAR 0 7
6148: PPUSH
6149: CALL_OW 290
// if resources = 0 then
6153: LD_VAR 0 6
6157: PUSH
6158: LD_INT 0
6160: EQUAL
6161: IFFALSE 6165
// break ;
6163: GO 6167
// end ;
6165: GO 6081
6167: POP
6168: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6169: LD_VAR 0 4
6173: PUSH
6174: LD_INT 1
6176: ARRAY
6177: PPUSH
6178: CALL_OW 311
6182: PPUSH
6183: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6187: LD_VAR 0 4
6191: PUSH
6192: LD_INT 1
6194: ARRAY
6195: PPUSH
6196: LD_INT 4
6198: PPUSH
6199: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6203: LD_EXP 38
6207: PPUSH
6208: LD_VAR 0 4
6212: PUSH
6213: LD_INT 1
6215: ARRAY
6216: PPUSH
6217: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6221: LD_INT 35
6223: PPUSH
6224: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6228: LD_EXP 38
6232: PPUSH
6233: CALL_OW 310
6237: IFFALSE 6221
// end ; InGameOff ;
6239: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6243: LD_STRING M1
6245: PPUSH
6246: CALL_OW 337
// SaveForQuickRestart ;
6250: CALL_OW 22
// cornel_active := true ;
6254: LD_ADDR_EXP 6
6258: PUSH
6259: LD_INT 1
6261: ST_TO_ADDR
// end ;
6262: LD_VAR 0 1
6266: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
6267: LD_EXP 31
6271: PPUSH
6272: LD_EXP 41
6276: PPUSH
6277: CALL_OW 296
6281: PUSH
6282: LD_INT 10
6284: LESS
6285: IFFALSE 7427
6287: GO 6289
6289: DISABLE
6290: LD_INT 0
6292: PPUSH
6293: PPUSH
6294: PPUSH
6295: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6296: LD_ADDR_VAR 0 2
6300: PUSH
6301: LD_INT 89
6303: PUSH
6304: LD_INT 34
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: PUSH
6311: LD_INT 138
6313: PUSH
6314: LD_INT 63
6316: PUSH
6317: EMPTY
6318: LIST
6319: LIST
6320: PUSH
6321: LD_INT 196
6323: PUSH
6324: LD_INT 84
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: PUSH
6331: LD_INT 135
6333: PUSH
6334: LD_INT 52
6336: PUSH
6337: EMPTY
6338: LIST
6339: LIST
6340: PUSH
6341: LD_INT 103
6343: PUSH
6344: LD_INT 39
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: PUSH
6351: LD_INT 58
6353: PUSH
6354: LD_INT 30
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: PUSH
6361: LD_INT 38
6363: PUSH
6364: LD_INT 51
6366: PUSH
6367: EMPTY
6368: LIST
6369: LIST
6370: PUSH
6371: EMPTY
6372: LIST
6373: LIST
6374: LIST
6375: LIST
6376: LIST
6377: LIST
6378: LIST
6379: ST_TO_ADDR
// InGameOn ;
6380: CALL_OW 8
// if jmm_units then
6384: LD_EXP 2
6388: IFFALSE 6452
// for i in jmm_units do
6390: LD_ADDR_VAR 0 1
6394: PUSH
6395: LD_EXP 2
6399: PUSH
6400: FOR_IN
6401: IFFALSE 6450
// begin if GetDistUnits ( i , JMM ) < 10 then
6403: LD_VAR 0 1
6407: PPUSH
6408: LD_EXP 31
6412: PPUSH
6413: CALL_OW 296
6417: PUSH
6418: LD_INT 10
6420: LESS
6421: IFFALSE 6439
// ComTurnUnit ( i , JMM ) else
6423: LD_VAR 0 1
6427: PPUSH
6428: LD_EXP 31
6432: PPUSH
6433: CALL_OW 119
6437: GO 6448
// ComHold ( i ) ;
6439: LD_VAR 0 1
6443: PPUSH
6444: CALL_OW 140
// end ;
6448: GO 6400
6450: POP
6451: POP
// if IsInUnit ( JMM ) then
6452: LD_EXP 31
6456: PPUSH
6457: CALL_OW 310
6461: IFFALSE 6472
// ComExitVehicle ( JMM ) ;
6463: LD_EXP 31
6467: PPUSH
6468: CALL_OW 121
// Wait ( 10 ) ;
6472: LD_INT 10
6474: PPUSH
6475: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6479: LD_EXP 31
6483: PPUSH
6484: LD_EXP 41
6488: PPUSH
6489: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6493: LD_INT 35
6495: PPUSH
6496: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6500: LD_EXP 31
6504: PPUSH
6505: LD_EXP 41
6509: PPUSH
6510: CALL_OW 296
6514: PUSH
6515: LD_INT 6
6517: LESS
6518: IFFALSE 6493
// ComTurnUnit ( JMM , Lynch ) ;
6520: LD_EXP 31
6524: PPUSH
6525: LD_EXP 41
6529: PPUSH
6530: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6534: LD_ADDR_VAR 0 1
6538: PUSH
6539: LD_EXP 41
6543: PUSH
6544: LD_EXP 42
6548: PUSH
6549: LD_EXP 43
6553: PUSH
6554: LD_EXP 44
6558: PUSH
6559: EMPTY
6560: LIST
6561: LIST
6562: LIST
6563: LIST
6564: PUSH
6565: FOR_IN
6566: IFFALSE 6584
// ComTurnUnit ( i , JMM ) ;
6568: LD_VAR 0 1
6572: PPUSH
6573: LD_EXP 31
6577: PPUSH
6578: CALL_OW 119
6582: GO 6565
6584: POP
6585: POP
// Wait ( 0 0$0.3 ) ;
6586: LD_INT 10
6588: PPUSH
6589: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6593: LD_EXP 31
6597: PPUSH
6598: LD_STRING D2-JMM-1
6600: PPUSH
6601: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6605: LD_EXP 41
6609: PPUSH
6610: LD_STRING D2-Sol1-1
6612: PPUSH
6613: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6617: LD_EXP 31
6621: PPUSH
6622: LD_STRING D2-JMM-2
6624: PPUSH
6625: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6629: LD_EXP 41
6633: PPUSH
6634: LD_STRING D2-Sol1-2
6636: PPUSH
6637: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6641: LD_EXP 31
6645: PPUSH
6646: LD_STRING D2-JMM-3
6648: PPUSH
6649: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
6653: LD_EXP 41
6657: PPUSH
6658: LD_STRING D2-Sol1-3
6660: PPUSH
6661: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6665: LD_ADDR_VAR 0 1
6669: PUSH
6670: LD_INT 22
6672: PUSH
6673: LD_INT 8
6675: PUSH
6676: EMPTY
6677: LIST
6678: LIST
6679: PPUSH
6680: CALL_OW 69
6684: PUSH
6685: FOR_IN
6686: IFFALSE 6702
// SetSide ( i , 1 ) ;
6688: LD_VAR 0 1
6692: PPUSH
6693: LD_INT 1
6695: PPUSH
6696: CALL_OW 235
6700: GO 6685
6702: POP
6703: POP
// Say ( JMM , D2-JMM-4 ) ;
6704: LD_EXP 31
6708: PPUSH
6709: LD_STRING D2-JMM-4
6711: PPUSH
6712: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
6716: LD_INT 1
6718: PPUSH
6719: LD_INT 5
6721: PPUSH
6722: CALL_OW 332
// for i = 1 to points do
6726: LD_ADDR_VAR 0 1
6730: PUSH
6731: DOUBLE
6732: LD_INT 1
6734: DEC
6735: ST_TO_ADDR
6736: LD_VAR 0 2
6740: PUSH
6741: FOR_TO
6742: IFFALSE 6917
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6744: LD_VAR 0 2
6748: PUSH
6749: LD_VAR 0 1
6753: ARRAY
6754: PUSH
6755: LD_INT 1
6757: ARRAY
6758: PPUSH
6759: LD_VAR 0 2
6763: PUSH
6764: LD_VAR 0 1
6768: ARRAY
6769: PUSH
6770: LD_INT 2
6772: ARRAY
6773: PPUSH
6774: CALL_OW 84
// if i = 1 then
6778: LD_VAR 0 1
6782: PUSH
6783: LD_INT 1
6785: EQUAL
6786: IFFALSE 6800
// Say ( Lynch , D2-Sol1-4 ) ;
6788: LD_EXP 41
6792: PPUSH
6793: LD_STRING D2-Sol1-4
6795: PPUSH
6796: CALL_OW 88
// if i = 2 then
6800: LD_VAR 0 1
6804: PUSH
6805: LD_INT 2
6807: EQUAL
6808: IFFALSE 6822
// Say ( JMM , D2-JMM-5 ) ;
6810: LD_EXP 31
6814: PPUSH
6815: LD_STRING D2-JMM-5
6817: PPUSH
6818: CALL_OW 88
// if i = 4 then
6822: LD_VAR 0 1
6826: PUSH
6827: LD_INT 4
6829: EQUAL
6830: IFFALSE 6854
// begin RevealFogArea ( 1 , troopsArea ) ;
6832: LD_INT 1
6834: PPUSH
6835: LD_INT 6
6837: PPUSH
6838: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
6842: LD_EXP 41
6846: PPUSH
6847: LD_STRING D2-Sol1-5
6849: PPUSH
6850: CALL_OW 88
// end ; if i = 5 then
6854: LD_VAR 0 1
6858: PUSH
6859: LD_INT 5
6861: EQUAL
6862: IFFALSE 6876
// Say ( JMM , D2-JMM-6 ) ;
6864: LD_EXP 31
6868: PPUSH
6869: LD_STRING D2-JMM-6
6871: PPUSH
6872: CALL_OW 88
// if i = 7 then
6876: LD_VAR 0 1
6880: PUSH
6881: LD_INT 7
6883: EQUAL
6884: IFFALSE 6908
// begin RevealFogArea ( 1 , forestArea ) ;
6886: LD_INT 1
6888: PPUSH
6889: LD_INT 7
6891: PPUSH
6892: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
6896: LD_EXP 41
6900: PPUSH
6901: LD_STRING D2-Sol1-6
6903: PPUSH
6904: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
6908: LD_INT 46
6910: PPUSH
6911: CALL_OW 67
// end ;
6915: GO 6741
6917: POP
6918: POP
// CenterNowOnUnits ( JMM ) ;
6919: LD_EXP 31
6923: PPUSH
6924: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
6928: LD_EXP 31
6932: PPUSH
6933: LD_STRING D2-JMM-7
6935: PPUSH
6936: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
6940: LD_EXP 41
6944: PPUSH
6945: LD_STRING D2-Sol1-7
6947: PPUSH
6948: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
6952: LD_EXP 31
6956: PPUSH
6957: LD_STRING D2-JMM-8
6959: PPUSH
6960: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
6964: LD_ADDR_VAR 0 4
6968: PUSH
6969: LD_INT 22
6971: PUSH
6972: LD_INT 1
6974: PUSH
6975: EMPTY
6976: LIST
6977: LIST
6978: PUSH
6979: LD_INT 30
6981: PUSH
6982: LD_INT 31
6984: PUSH
6985: EMPTY
6986: LIST
6987: LIST
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PPUSH
6993: CALL_OW 69
6997: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
6998: LD_EXP 41
7002: PPUSH
7003: LD_VAR 0 4
7007: PUSH
7008: LD_INT 1
7010: ARRAY
7011: PPUSH
7012: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7016: LD_ADDR_VAR 0 3
7020: PUSH
7021: LD_EXP 2
7025: PPUSH
7026: LD_INT 25
7028: PUSH
7029: LD_INT 1
7031: PUSH
7032: EMPTY
7033: LIST
7034: LIST
7035: PPUSH
7036: CALL_OW 72
7040: PPUSH
7041: LD_EXP 31
7045: PPUSH
7046: CALL_OW 74
7050: ST_TO_ADDR
// if sol then
7051: LD_VAR 0 3
7055: IFFALSE 7095
// if GetDistUnits ( JMM , sol ) < 10 then
7057: LD_EXP 31
7061: PPUSH
7062: LD_VAR 0 3
7066: PPUSH
7067: CALL_OW 296
7071: PUSH
7072: LD_INT 10
7074: LESS
7075: IFFALSE 7095
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7077: LD_VAR 0 3
7081: PPUSH
7082: LD_VAR 0 4
7086: PUSH
7087: LD_INT 2
7089: ARRAY
7090: PPUSH
7091: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7095: LD_INT 10
7097: PPUSH
7098: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7102: LD_EXP 31
7106: PPUSH
7107: LD_INT 65
7109: PPUSH
7110: LD_INT 101
7112: PPUSH
7113: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7117: LD_EXP 31
7121: PPUSH
7122: LD_INT 63
7124: PPUSH
7125: LD_INT 100
7127: PPUSH
7128: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
7132: LD_INT 35
7134: PPUSH
7135: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
7139: LD_EXP 31
7143: PPUSH
7144: LD_INT 65
7146: PPUSH
7147: LD_INT 101
7149: PPUSH
7150: CALL_OW 307
7154: IFFALSE 7132
// Say ( JMM , D2a-JMM-1 ) ;
7156: LD_EXP 31
7160: PPUSH
7161: LD_STRING D2a-JMM-1
7163: PPUSH
7164: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7168: LD_EXP 42
7172: PPUSH
7173: LD_INT 66
7175: PPUSH
7176: LD_INT 103
7178: PPUSH
7179: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
7183: LD_INT 35
7185: PPUSH
7186: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
7190: LD_EXP 42
7194: PPUSH
7195: LD_INT 66
7197: PPUSH
7198: LD_INT 103
7200: PPUSH
7201: CALL_OW 307
7205: IFFALSE 7183
// ComTurnUnit ( Walker , JMM ) ;
7207: LD_EXP 42
7211: PPUSH
7212: LD_EXP 31
7216: PPUSH
7217: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7221: LD_EXP 42
7225: PPUSH
7226: LD_STRING D2a-Sci1-1
7228: PPUSH
7229: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7233: LD_EXP 31
7237: PPUSH
7238: LD_EXP 42
7242: PPUSH
7243: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7247: LD_EXP 31
7251: PPUSH
7252: LD_STRING D2a-JMM-2
7254: PPUSH
7255: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7259: LD_EXP 42
7263: PPUSH
7264: LD_STRING D2a-Sci1-2
7266: PPUSH
7267: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7271: LD_EXP 31
7275: PPUSH
7276: LD_STRING D2a-JMM-3
7278: PPUSH
7279: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7283: LD_EXP 42
7287: PPUSH
7288: LD_STRING D2a-Sci1-3
7290: PPUSH
7291: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7295: LD_ADDR_EXP 2
7299: PUSH
7300: LD_EXP 2
7304: PUSH
7305: LD_EXP 41
7309: PUSH
7310: LD_EXP 42
7314: PUSH
7315: LD_EXP 43
7319: PUSH
7320: LD_EXP 44
7324: PUSH
7325: EMPTY
7326: LIST
7327: LIST
7328: LIST
7329: LIST
7330: ADD
7331: ST_TO_ADDR
// for i in jmm_units do
7332: LD_ADDR_VAR 0 1
7336: PUSH
7337: LD_EXP 2
7341: PUSH
7342: FOR_IN
7343: IFFALSE 7368
// if not IsInUnit ( i ) then
7345: LD_VAR 0 1
7349: PPUSH
7350: CALL_OW 310
7354: NOT
7355: IFFALSE 7366
// ComFree ( i ) ;
7357: LD_VAR 0 1
7361: PPUSH
7362: CALL_OW 139
7366: GO 7342
7368: POP
7369: POP
// InGameOff ;
7370: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
7374: LD_STRING MSolar1
7376: PPUSH
7377: CALL_OW 337
// jmm_on_west := true ;
7381: LD_ADDR_EXP 3
7385: PUSH
7386: LD_INT 1
7388: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7389: LD_INT 1050
7391: PPUSH
7392: CALL_OW 67
// frank_can_return := true ;
7396: LD_ADDR_EXP 10
7400: PUSH
7401: LD_INT 1
7403: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7404: LD_INT 6300
7406: PPUSH
7407: LD_INT 8400
7409: PPUSH
7410: CALL_OW 12
7414: PPUSH
7415: CALL_OW 67
// send_spec_patrol := true ;
7419: LD_ADDR_EXP 26
7423: PUSH
7424: LD_INT 1
7426: ST_TO_ADDR
// end ;
7427: PPOPN 4
7429: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7430: LD_INT 22
7432: PUSH
7433: LD_INT 1
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: PUSH
7440: LD_INT 34
7442: PUSH
7443: LD_INT 51
7445: PUSH
7446: EMPTY
7447: LIST
7448: LIST
7449: PUSH
7450: LD_INT 92
7452: PUSH
7453: LD_INT 63
7455: PUSH
7456: LD_INT 100
7458: PUSH
7459: LD_INT 5
7461: PUSH
7462: EMPTY
7463: LIST
7464: LIST
7465: LIST
7466: LIST
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: PPUSH
7476: CALL_OW 69
7480: PUSH
7481: LD_EXP 3
7485: NOT
7486: AND
7487: IFFALSE 7600
7489: GO 7491
7491: DISABLE
7492: LD_INT 0
7494: PPUSH
7495: PPUSH
// begin enable ;
7496: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
7497: LD_ADDR_VAR 0 2
7501: PUSH
7502: LD_INT 22
7504: PUSH
7505: LD_INT 1
7507: PUSH
7508: EMPTY
7509: LIST
7510: LIST
7511: PUSH
7512: LD_INT 34
7514: PUSH
7515: LD_INT 51
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: PUSH
7522: LD_INT 92
7524: PUSH
7525: LD_INT 63
7527: PUSH
7528: LD_INT 100
7530: PUSH
7531: LD_INT 5
7533: PUSH
7534: EMPTY
7535: LIST
7536: LIST
7537: LIST
7538: LIST
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: LIST
7544: PUSH
7545: EMPTY
7546: LIST
7547: PPUSH
7548: CALL_OW 69
7552: ST_TO_ADDR
// if not filter then
7553: LD_VAR 0 2
7557: NOT
7558: IFFALSE 7562
// exit ;
7560: GO 7600
// for i in filter do
7562: LD_ADDR_VAR 0 1
7566: PUSH
7567: LD_VAR 0 2
7571: PUSH
7572: FOR_IN
7573: IFFALSE 7598
// begin SetFuel ( i , 0 ) ;
7575: LD_VAR 0 1
7579: PPUSH
7580: LD_INT 0
7582: PPUSH
7583: CALL_OW 240
// ComStop ( i ) ;
7587: LD_VAR 0 1
7591: PPUSH
7592: CALL_OW 141
// end ;
7596: GO 7572
7598: POP
7599: POP
// end ;
7600: PPOPN 2
7602: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
7603: LD_EXP 26
7607: IFFALSE 8572
7609: GO 7611
7611: DISABLE
7612: LD_INT 0
7614: PPUSH
7615: PPUSH
7616: PPUSH
7617: PPUSH
7618: PPUSH
7619: PPUSH
7620: PPUSH
// begin if not ru_spec_patrol then
7621: LD_EXP 48
7625: NOT
7626: IFFALSE 7630
// exit ;
7628: GO 8572
// dead1 := false ;
7630: LD_ADDR_VAR 0 1
7634: PUSH
7635: LD_INT 0
7637: ST_TO_ADDR
// dead2 := false ;
7638: LD_ADDR_VAR 0 2
7642: PUSH
7643: LD_INT 0
7645: ST_TO_ADDR
// inarea1 := false ;
7646: LD_ADDR_VAR 0 3
7650: PUSH
7651: LD_INT 0
7653: ST_TO_ADDR
// inarea2 := false ;
7654: LD_ADDR_VAR 0 4
7658: PUSH
7659: LD_INT 0
7661: ST_TO_ADDR
// tmp := [ ] ;
7662: LD_ADDR_VAR 0 6
7666: PUSH
7667: EMPTY
7668: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
7669: LD_EXP 48
7673: PPUSH
7674: LD_INT 75
7676: PPUSH
7677: LD_INT 101
7679: PPUSH
7680: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
7684: LD_INT 35
7686: PPUSH
7687: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
7691: LD_INT 1
7693: PPUSH
7694: LD_EXP 48
7698: PUSH
7699: LD_INT 1
7701: ARRAY
7702: PPUSH
7703: CALL_OW 292
7707: IFFALSE 7684
// ComStop ( ru_spec_patrol ) ;
7709: LD_EXP 48
7713: PPUSH
7714: CALL_OW 141
// Wait ( 0 0$02 ) ;
7718: LD_INT 70
7720: PPUSH
7721: CALL_OW 67
// DialogueOn ;
7725: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
7729: LD_EXP 48
7733: PUSH
7734: LD_INT 1
7736: ARRAY
7737: PPUSH
7738: LD_STRING D8-Rus1-1
7740: PPUSH
7741: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
7745: LD_EXP 31
7749: PPUSH
7750: LD_STRING D8-JMM-1
7752: PPUSH
7753: CALL_OW 88
// DialogueOff ;
7757: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
7761: LD_EXP 48
7765: PPUSH
7766: LD_INT 13
7768: PPUSH
7769: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
7773: LD_INT 35
7775: PPUSH
7776: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
7780: LD_VAR 0 1
7784: NOT
7785: PUSH
7786: LD_EXP 48
7790: PUSH
7791: LD_INT 1
7793: ARRAY
7794: PPUSH
7795: CALL_OW 301
7799: AND
7800: IFFALSE 7810
// dead1 := true ;
7802: LD_ADDR_VAR 0 1
7806: PUSH
7807: LD_INT 1
7809: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
7810: LD_VAR 0 2
7814: NOT
7815: PUSH
7816: LD_EXP 48
7820: PUSH
7821: LD_INT 2
7823: ARRAY
7824: PPUSH
7825: CALL_OW 301
7829: AND
7830: IFFALSE 7840
// dead2 := true ;
7832: LD_ADDR_VAR 0 2
7836: PUSH
7837: LD_INT 1
7839: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
7840: LD_VAR 0 3
7844: NOT
7845: PUSH
7846: LD_EXP 48
7850: PUSH
7851: LD_INT 1
7853: ARRAY
7854: PPUSH
7855: LD_INT 14
7857: PPUSH
7858: CALL_OW 308
7862: AND
7863: IFFALSE 7873
// inarea1 := true ;
7865: LD_ADDR_VAR 0 3
7869: PUSH
7870: LD_INT 1
7872: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
7873: LD_VAR 0 4
7877: NOT
7878: PUSH
7879: LD_EXP 48
7883: PUSH
7884: LD_INT 2
7886: ARRAY
7887: PPUSH
7888: LD_INT 14
7890: PPUSH
7891: CALL_OW 308
7895: AND
7896: IFFALSE 7906
// inarea2 := true ;
7898: LD_ADDR_VAR 0 4
7902: PUSH
7903: LD_INT 1
7905: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
7906: LD_VAR 0 1
7910: PUSH
7911: LD_VAR 0 2
7915: AND
7916: PUSH
7917: LD_VAR 0 1
7921: PUSH
7922: LD_VAR 0 4
7926: AND
7927: OR
7928: PUSH
7929: LD_VAR 0 2
7933: PUSH
7934: LD_VAR 0 3
7938: AND
7939: OR
7940: PUSH
7941: LD_VAR 0 3
7945: PUSH
7946: LD_VAR 0 4
7950: AND
7951: OR
7952: IFFALSE 7773
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
7954: LD_VAR 0 3
7958: PUSH
7959: LD_VAR 0 4
7963: AND
7964: PUSH
7965: LD_VAR 0 1
7969: PUSH
7970: LD_VAR 0 4
7974: AND
7975: OR
7976: PUSH
7977: LD_VAR 0 2
7981: PUSH
7982: LD_VAR 0 3
7986: AND
7987: OR
7988: IFFALSE 8552
// begin prepare_siege := true ;
7990: LD_ADDR_EXP 27
7994: PUSH
7995: LD_INT 1
7997: ST_TO_ADDR
// DialogueOn ;
7998: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8002: LD_VAR 0 3
8006: PUSH
8007: LD_VAR 0 4
8011: AND
8012: IFFALSE 8028
// Say ( JMM , D8b-JMM-1a ) else
8014: LD_EXP 31
8018: PPUSH
8019: LD_STRING D8b-JMM-1a
8021: PPUSH
8022: CALL_OW 88
8026: GO 8040
// Say ( JMM , D8b-JMM-1 ) ;
8028: LD_EXP 31
8032: PPUSH
8033: LD_STRING D8b-JMM-1
8035: PPUSH
8036: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8040: LD_EXP 2
8044: PPUSH
8045: LD_INT 26
8047: PUSH
8048: LD_INT 1
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: PPUSH
8055: CALL_OW 72
8059: PUSH
8060: LD_EXP 32
8064: PUSH
8065: LD_EXP 33
8069: PUSH
8070: LD_EXP 42
8074: PUSH
8075: LD_EXP 45
8079: PUSH
8080: EMPTY
8081: LIST
8082: LIST
8083: LIST
8084: LIST
8085: DIFF
8086: PPUSH
8087: LD_STRING D8b-Sol1-1
8089: PPUSH
8090: CALL 579 0 2
// if Cyrus and Cyrus in jmm_units then
8094: LD_EXP 33
8098: PUSH
8099: LD_EXP 33
8103: PUSH
8104: LD_EXP 2
8108: IN
8109: AND
8110: IFFALSE 8126
// Say ( Cyrus , D8b-Cyrus-1 ) else
8112: LD_EXP 33
8116: PPUSH
8117: LD_STRING D8b-Cyrus-1
8119: PPUSH
8120: CALL_OW 88
8124: GO 8138
// Say ( JMM , D8b-JMM-1a ) ;
8126: LD_EXP 31
8130: PPUSH
8131: LD_STRING D8b-JMM-1a
8133: PPUSH
8134: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8138: LD_EXP 34
8142: PUSH
8143: LD_EXP 34
8147: PUSH
8148: LD_EXP 2
8152: IN
8153: AND
8154: IFFALSE 8168
// Say ( Lisa , D8b-Lisa-2 ) ;
8156: LD_EXP 34
8160: PPUSH
8161: LD_STRING D8b-Lisa-2
8163: PPUSH
8164: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8168: LD_EXP 32
8172: PUSH
8173: LD_EXP 32
8177: PUSH
8178: LD_EXP 2
8182: IN
8183: AND
8184: IFFALSE 8200
// Say ( Bobby , D8b-Bobby-1 ) else
8186: LD_EXP 32
8190: PPUSH
8191: LD_STRING D8b-Bobby-1
8193: PPUSH
8194: CALL_OW 88
8198: GO 8260
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8200: LD_ADDR_VAR 0 5
8204: PUSH
8205: LD_EXP 2
8209: PPUSH
8210: LD_INT 26
8212: PUSH
8213: LD_INT 1
8215: PUSH
8216: EMPTY
8217: LIST
8218: LIST
8219: PPUSH
8220: CALL_OW 72
8224: PUSH
8225: LD_EXP 32
8229: PUSH
8230: LD_EXP 33
8234: PUSH
8235: LD_EXP 42
8239: PUSH
8240: LD_EXP 45
8244: PUSH
8245: EMPTY
8246: LIST
8247: LIST
8248: LIST
8249: LIST
8250: DIFF
8251: PPUSH
8252: LD_STRING D8b-Sol2-1
8254: PPUSH
8255: CALL 579 0 2
8259: ST_TO_ADDR
// DialogueOff ;
8260: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8264: LD_EXP 33
8268: PUSH
8269: LD_EXP 33
8273: PUSH
8274: LD_EXP 2
8278: IN
8279: AND
8280: IFFALSE 8305
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8282: LD_ADDR_VAR 0 6
8286: PUSH
8287: LD_VAR 0 6
8291: PPUSH
8292: LD_INT 1
8294: PPUSH
8295: LD_EXP 33
8299: PPUSH
8300: CALL_OW 2
8304: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8305: LD_EXP 32
8309: PUSH
8310: LD_EXP 32
8314: PUSH
8315: LD_EXP 2
8319: IN
8320: AND
8321: IFFALSE 8346
// tmp := Insert ( tmp , 1 , Bobby ) ;
8323: LD_ADDR_VAR 0 6
8327: PUSH
8328: LD_VAR 0 6
8332: PPUSH
8333: LD_INT 1
8335: PPUSH
8336: LD_EXP 32
8340: PPUSH
8341: CALL_OW 2
8345: ST_TO_ADDR
// if sol then
8346: LD_VAR 0 5
8350: IFFALSE 8375
// tmp := Insert ( tmp , 1 , sol ) ;
8352: LD_ADDR_VAR 0 6
8356: PUSH
8357: LD_VAR 0 6
8361: PPUSH
8362: LD_INT 1
8364: PPUSH
8365: LD_VAR 0 5
8369: PPUSH
8370: CALL_OW 2
8374: ST_TO_ADDR
// if tmp then
8375: LD_VAR 0 6
8379: IFFALSE 8511
// begin SetSide ( tmp , 8 ) ;
8381: LD_VAR 0 6
8385: PPUSH
8386: LD_INT 8
8388: PPUSH
8389: CALL_OW 235
// ComFree ( tmp ) ;
8393: LD_VAR 0 6
8397: PPUSH
8398: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8402: LD_VAR 0 6
8406: PPUSH
8407: LD_INT 15
8409: PPUSH
8410: CALL_OW 173
// AddComHold ( tmp ) ;
8414: LD_VAR 0 6
8418: PPUSH
8419: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8423: LD_INT 35
8425: PPUSH
8426: CALL_OW 67
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8430: LD_VAR 0 6
8434: PUSH
8435: LD_INT 1
8437: ARRAY
8438: PPUSH
8439: LD_INT 15
8441: PPUSH
8442: CALL_OW 308
8446: IFFALSE 8501
// begin RemoveUnit ( tmp [ 1 ] ) ;
8448: LD_VAR 0 6
8452: PUSH
8453: LD_INT 1
8455: ARRAY
8456: PPUSH
8457: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
8461: LD_ADDR_EXP 2
8465: PUSH
8466: LD_EXP 2
8470: PUSH
8471: LD_VAR 0 6
8475: PUSH
8476: LD_INT 1
8478: ARRAY
8479: DIFF
8480: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
8481: LD_ADDR_VAR 0 6
8485: PUSH
8486: LD_VAR 0 6
8490: PUSH
8491: LD_VAR 0 6
8495: PUSH
8496: LD_INT 1
8498: ARRAY
8499: DIFF
8500: ST_TO_ADDR
// end ; until tmp = 0 ;
8501: LD_VAR 0 6
8505: PUSH
8506: LD_INT 0
8508: EQUAL
8509: IFFALSE 8423
// end ; Wait ( 0 0$30 ) ;
8511: LD_INT 1050
8513: PPUSH
8514: CALL_OW 67
// if ru_spec_patrol then
8518: LD_EXP 48
8522: IFFALSE 8550
// for i in ru_spec_patrol do
8524: LD_ADDR_VAR 0 7
8528: PUSH
8529: LD_EXP 48
8533: PUSH
8534: FOR_IN
8535: IFFALSE 8548
// RemoveUnit ( i ) ;
8537: LD_VAR 0 7
8541: PPUSH
8542: CALL_OW 64
8546: GO 8534
8548: POP
8549: POP
// end else
8550: GO 8572
// begin prepare_siege := false ;
8552: LD_ADDR_EXP 27
8556: PUSH
8557: LD_INT 0
8559: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
8560: LD_EXP 31
8564: PPUSH
8565: LD_STRING D8a-JMM-1
8567: PPUSH
8568: CALL_OW 88
// end ; end ;
8572: PPOPN 7
8574: END
// every 0 0$10 trigger frank_can_return do var i , points ;
8575: LD_EXP 10
8579: IFFALSE 9713
8581: GO 8583
8583: DISABLE
8584: LD_INT 0
8586: PPUSH
8587: PPUSH
// begin uc_side := 8 ;
8588: LD_ADDR_OWVAR 20
8592: PUSH
8593: LD_INT 8
8595: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
8596: LD_ADDR_VAR 0 2
8600: PUSH
8601: LD_INT 59
8603: PUSH
8604: LD_INT 71
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: PUSH
8611: LD_INT 122
8613: PUSH
8614: LD_INT 117
8616: PUSH
8617: EMPTY
8618: LIST
8619: LIST
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
8625: LD_ADDR_EXP 45
8629: PUSH
8630: LD_STRING Frank
8632: PPUSH
8633: LD_INT 0
8635: PPUSH
8636: CALL 434 0 2
8640: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
8641: LD_ADDR_VAR 0 1
8645: PUSH
8646: LD_INT 1
8648: PPUSH
8649: LD_INT 2
8651: PPUSH
8652: CALL_OW 12
8656: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
8657: LD_EXP 45
8661: PPUSH
8662: LD_VAR 0 2
8666: PUSH
8667: LD_VAR 0 1
8671: ARRAY
8672: PUSH
8673: LD_INT 1
8675: ARRAY
8676: PPUSH
8677: LD_VAR 0 2
8681: PUSH
8682: LD_VAR 0 1
8686: ARRAY
8687: PUSH
8688: LD_INT 2
8690: ARRAY
8691: PPUSH
8692: LD_INT 0
8694: PPUSH
8695: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
8699: LD_EXP 45
8703: PPUSH
8704: LD_INT 1
8706: PPUSH
8707: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
8711: LD_INT 35
8713: PPUSH
8714: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
8718: LD_EXP 45
8722: PPUSH
8723: LD_EXP 31
8727: PPUSH
8728: CALL_OW 296
8732: PUSH
8733: LD_INT 8
8735: LESS
8736: IFFALSE 8711
// InGameOn ;
8738: CALL_OW 8
// CenterOnUnits ( JMM ) ;
8742: LD_EXP 31
8746: PPUSH
8747: CALL_OW 85
// if IsInUnit ( JMM ) then
8751: LD_EXP 31
8755: PPUSH
8756: CALL_OW 310
8760: IFFALSE 8771
// ComFree ( JMM ) ;
8762: LD_EXP 31
8766: PPUSH
8767: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
8771: LD_EXP 31
8775: PPUSH
8776: LD_EXP 45
8780: PPUSH
8781: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
8785: LD_EXP 45
8789: PPUSH
8790: LD_EXP 31
8794: PPUSH
8795: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
8799: LD_EXP 31
8803: PPUSH
8804: LD_STRING D6-JMM-1
8806: PPUSH
8807: CALL_OW 88
// repeat wait ( 3 ) ;
8811: LD_INT 3
8813: PPUSH
8814: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
8818: LD_EXP 31
8822: PPUSH
8823: LD_EXP 45
8827: PPUSH
8828: CALL_OW 296
8832: PUSH
8833: LD_INT 8
8835: LESS
8836: IFFALSE 8811
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
8838: LD_EXP 34
8842: PUSH
8843: LD_EXP 34
8847: PPUSH
8848: LD_EXP 45
8852: PPUSH
8853: CALL_OW 296
8857: PUSH
8858: LD_INT 20
8860: LESS
8861: AND
8862: IFFALSE 8887
// begin ComFree ( Lisa ) ;
8864: LD_EXP 34
8868: PPUSH
8869: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
8873: LD_EXP 34
8877: PPUSH
8878: LD_EXP 45
8882: PPUSH
8883: CALL_OW 172
// end ; if Lynch then
8887: LD_EXP 41
8891: IFFALSE 8916
// begin ComFree ( Lynch ) ;
8893: LD_EXP 41
8897: PPUSH
8898: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
8902: LD_EXP 41
8906: PPUSH
8907: LD_EXP 45
8911: PPUSH
8912: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
8916: LD_EXP 31
8920: PPUSH
8921: LD_EXP 45
8925: PPUSH
8926: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
8930: LD_EXP 45
8934: PPUSH
8935: LD_EXP 31
8939: PPUSH
8940: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
8944: LD_EXP 45
8948: PPUSH
8949: LD_STRING D6-Frank-1
8951: PPUSH
8952: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
8956: LD_INT 69
8958: PPUSH
8959: LD_INT 20
8961: PPUSH
8962: LD_INT 1
8964: PPUSH
8965: LD_INT 20
8967: NEG
8968: PPUSH
8969: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
8973: LD_INT 69
8975: PPUSH
8976: LD_INT 20
8978: PPUSH
8979: LD_INT 1
8981: PPUSH
8982: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
8986: LD_INT 190
8988: PPUSH
8989: LD_INT 31
8991: PPUSH
8992: LD_INT 1
8994: PPUSH
8995: LD_INT 20
8997: NEG
8998: PPUSH
8999: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9003: LD_INT 190
9005: PPUSH
9006: LD_INT 31
9008: PPUSH
9009: LD_INT 1
9011: PPUSH
9012: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9016: LD_INT 69
9018: PPUSH
9019: LD_INT 20
9021: PPUSH
9022: CALL_OW 84
// Wait ( 0 0$02 ) ;
9026: LD_INT 70
9028: PPUSH
9029: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9033: LD_EXP 31
9037: PPUSH
9038: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9042: LD_EXP 34
9046: PUSH
9047: LD_EXP 34
9051: PPUSH
9052: LD_EXP 45
9056: PPUSH
9057: CALL_OW 296
9061: PUSH
9062: LD_INT 20
9064: LESS
9065: AND
9066: PUSH
9067: LD_EXP 34
9071: PPUSH
9072: CALL_OW 302
9076: AND
9077: IFFALSE 9167
// begin ComFree ( Lisa ) ;
9079: LD_EXP 34
9083: PPUSH
9084: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
9088: LD_INT 35
9090: PPUSH
9091: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
9095: LD_EXP 34
9099: PPUSH
9100: LD_EXP 45
9104: PPUSH
9105: CALL_OW 296
9109: PUSH
9110: LD_INT 7
9112: LESS
9113: IFFALSE 9088
// Say ( Lisa , D6-Lisa-1 ) ;
9115: LD_EXP 34
9119: PPUSH
9120: LD_STRING D6-Lisa-1
9122: PPUSH
9123: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9127: LD_EXP 34
9131: PPUSH
9132: LD_EXP 45
9136: PPUSH
9137: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9141: LD_EXP 45
9145: PPUSH
9146: LD_EXP 34
9150: PPUSH
9151: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9155: LD_EXP 45
9159: PPUSH
9160: LD_STRING D6-Frank-2
9162: PPUSH
9163: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9167: LD_EXP 41
9171: PUSH
9172: LD_EXP 41
9176: PPUSH
9177: LD_EXP 45
9181: PPUSH
9182: CALL_OW 296
9186: PUSH
9187: LD_INT 20
9189: LESS
9190: AND
9191: PUSH
9192: LD_EXP 41
9196: PPUSH
9197: CALL_OW 302
9201: AND
9202: IFFALSE 9383
// begin ComTurnUnit ( Lynch , JMM ) ;
9204: LD_EXP 41
9208: PPUSH
9209: LD_EXP 31
9213: PPUSH
9214: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9218: LD_EXP 45
9222: PPUSH
9223: LD_EXP 31
9227: PPUSH
9228: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9232: LD_EXP 41
9236: PPUSH
9237: LD_STRING D6-Sol1-2
9239: PPUSH
9240: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9244: LD_EXP 31
9248: PPUSH
9249: LD_STRING D6-JMM-2
9251: PPUSH
9252: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9256: LD_EXP 45
9260: PPUSH
9261: LD_STRING D6-Frank-3
9263: PPUSH
9264: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9268: LD_EXP 31
9272: PPUSH
9273: LD_STRING D6-JMM-3
9275: PPUSH
9276: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9280: LD_EXP 45
9284: PPUSH
9285: LD_STRING D6-Frank-4
9287: PPUSH
9288: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9292: LD_EXP 45
9296: PPUSH
9297: LD_STRING D6-Frank-4a
9299: PPUSH
9300: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9304: LD_EXP 31
9308: PPUSH
9309: LD_STRING D6-JMM-4
9311: PPUSH
9312: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9316: LD_EXP 45
9320: PPUSH
9321: LD_STRING D6-Frank-5
9323: PPUSH
9324: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9328: LD_EXP 34
9332: PUSH
9333: LD_EXP 34
9337: PPUSH
9338: CALL_OW 302
9342: AND
9343: IFFALSE 9357
// Say ( Lisa , D6-Lisa-5 ) ;
9345: LD_EXP 34
9349: PPUSH
9350: LD_STRING D6-Lisa-5
9352: PPUSH
9353: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9357: LD_EXP 45
9361: PPUSH
9362: LD_STRING D6-Frank-6
9364: PPUSH
9365: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9369: LD_EXP 31
9373: PPUSH
9374: LD_STRING D6-JMM-6
9376: PPUSH
9377: CALL_OW 88
// end else
9381: GO 9498
// begin ComTurnUnit ( Frank , JMM ) ;
9383: LD_EXP 45
9387: PPUSH
9388: LD_EXP 31
9392: PPUSH
9393: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
9397: LD_EXP 45
9401: PPUSH
9402: LD_STRING D6-Frank-4
9404: PPUSH
9405: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9409: LD_EXP 45
9413: PPUSH
9414: LD_STRING D6-Frank-4a
9416: PPUSH
9417: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9421: LD_EXP 31
9425: PPUSH
9426: LD_STRING D6-JMM-4
9428: PPUSH
9429: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9433: LD_EXP 45
9437: PPUSH
9438: LD_STRING D6-Frank-5
9440: PPUSH
9441: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9445: LD_EXP 34
9449: PUSH
9450: LD_EXP 34
9454: PPUSH
9455: CALL_OW 302
9459: AND
9460: IFFALSE 9474
// Say ( Lisa , D6-Lisa-5 ) ;
9462: LD_EXP 34
9466: PPUSH
9467: LD_STRING D6-Lisa-5
9469: PPUSH
9470: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9474: LD_EXP 45
9478: PPUSH
9479: LD_STRING D6-Frank-6
9481: PPUSH
9482: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9486: LD_EXP 31
9490: PPUSH
9491: LD_STRING D6-JMM-6
9493: PPUSH
9494: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
9498: LD_STRING Q1
9500: PPUSH
9501: CALL_OW 97
9505: PUSH
9506: LD_INT 1
9508: DOUBLE
9509: EQUAL
9510: IFTRUE 9514
9512: GO 9525
9514: POP
// frank_send_to_scout := true ; 2 :
9515: LD_ADDR_EXP 12
9519: PUSH
9520: LD_INT 1
9522: ST_TO_ADDR
9523: GO 9545
9525: LD_INT 2
9527: DOUBLE
9528: EQUAL
9529: IFTRUE 9533
9531: GO 9544
9533: POP
// frank_send_to_scout := false ; end ;
9534: LD_ADDR_EXP 12
9538: PUSH
9539: LD_INT 0
9541: ST_TO_ADDR
9542: GO 9545
9544: POP
// InGameOff ;
9545: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
9549: LD_EXP 31
9553: PUSH
9554: LD_EXP 34
9558: PUSH
9559: LD_EXP 41
9563: PUSH
9564: EMPTY
9565: LIST
9566: LIST
9567: LIST
9568: PPUSH
9569: CALL_OW 139
// if frank_send_to_scout then
9573: LD_EXP 12
9577: IFFALSE 9634
// begin ComMoveXY ( Frank , 130 , 123 ) ;
9579: LD_EXP 45
9583: PPUSH
9584: LD_INT 130
9586: PPUSH
9587: LD_INT 123
9589: PPUSH
9590: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
9594: LD_INT 35
9596: PPUSH
9597: CALL_OW 67
// until not See ( 1 , Frank ) ;
9601: LD_INT 1
9603: PPUSH
9604: LD_EXP 45
9608: PPUSH
9609: CALL_OW 292
9613: NOT
9614: IFFALSE 9594
// Wait ( 0 0$02 ) ;
9616: LD_INT 70
9618: PPUSH
9619: CALL_OW 67
// RemoveUnit ( Frank ) ;
9623: LD_EXP 45
9627: PPUSH
9628: CALL_OW 64
// end else
9632: GO 9646
// SetSide ( Frank , 1 ) ;
9634: LD_EXP 45
9638: PPUSH
9639: LD_INT 1
9641: PPUSH
9642: CALL_OW 235
// send_attack_on_cornel_base := true ;
9646: LD_ADDR_EXP 23
9650: PUSH
9651: LD_INT 1
9653: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9654: LD_INT 35
9656: PPUSH
9657: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
9661: LD_ADDR_EXP 25
9665: PUSH
9666: LD_EXP 25
9670: PPUSH
9671: LD_STRING -
9673: PPUSH
9674: CALL 1071 0 2
9678: ST_TO_ADDR
// if debug then
9679: LD_EXP 1
9683: IFFALSE 9695
// debug_strings := time_to_prepare ;
9685: LD_ADDR_OWVAR 48
9689: PUSH
9690: LD_EXP 25
9694: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
9695: LD_EXP 25
9699: PUSH
9700: LD_INT 0
9702: EQUAL
9703: IFFALSE 9654
// cornel_prepared := true ;
9705: LD_ADDR_EXP 9
9709: PUSH
9710: LD_INT 1
9712: ST_TO_ADDR
// end ;
9713: PPOPN 2
9715: END
// every 0 0$01 trigger cornel_prepared do
9716: LD_EXP 9
9720: IFFALSE 9966
9722: GO 9724
9724: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
9725: LD_EXP 38
9729: PPUSH
9730: LD_STRING D3-Corn-1
9732: PPUSH
9733: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
9737: LD_INT 35
9739: PPUSH
9740: CALL_OW 67
// until cornel_counter = 0 ;
9744: LD_EXP 8
9748: PUSH
9749: LD_INT 0
9751: EQUAL
9752: IFFALSE 9737
// SayRadio ( Cornel , D3a-Corn-1 ) ;
9754: LD_EXP 38
9758: PPUSH
9759: LD_STRING D3a-Corn-1
9761: PPUSH
9762: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
9766: LD_EXP 31
9770: PPUSH
9771: LD_STRING D3a-JMM-1
9773: PPUSH
9774: CALL_OW 88
// end_mission_allowed := true ;
9778: LD_ADDR_EXP 18
9782: PUSH
9783: LD_INT 1
9785: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
9786: LD_STRING M2
9788: PPUSH
9789: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
9793: LD_INT 9
9795: PPUSH
9796: LD_INT 1
9798: PPUSH
9799: CALL_OW 424
// Wait ( 0 0$05 ) ;
9803: LD_INT 175
9805: PPUSH
9806: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
9810: LD_EXP 38
9814: PPUSH
9815: LD_STRING D3a-Corn-2
9817: PPUSH
9818: CALL_OW 94
// cornel_attack := true ;
9822: LD_ADDR_EXP 7
9826: PUSH
9827: LD_INT 1
9829: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
9830: LD_INT 105
9832: PPUSH
9833: CALL_OW 67
// AddMoreTanks ( ) ;
9837: CALL 4729 0 0
// if frank_send_to_scout then
9841: LD_EXP 12
9845: IFFALSE 9966
// begin InitHc ;
9847: CALL_OW 19
// InitUc ;
9851: CALL_OW 18
// uc_side := 8 ;
9855: LD_ADDR_OWVAR 20
9859: PUSH
9860: LD_INT 8
9862: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9863: LD_ADDR_EXP 45
9867: PUSH
9868: LD_STRING Frank
9870: PPUSH
9871: LD_INT 0
9873: PPUSH
9874: CALL 434 0 2
9878: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
9879: LD_EXP 45
9883: PPUSH
9884: LD_INT 6
9886: PPUSH
9887: LD_INT 9
9889: PPUSH
9890: LD_INT 0
9892: PPUSH
9893: CALL_OW 48
// ComCrawl ( Frank ) ;
9897: LD_EXP 45
9901: PPUSH
9902: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
9906: LD_INT 35
9908: PPUSH
9909: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
9913: LD_EXP 31
9917: PPUSH
9918: LD_EXP 45
9922: PPUSH
9923: CALL_OW 296
9927: PUSH
9928: LD_INT 9
9930: LESS
9931: IFFALSE 9906
// SetSide ( Frank , 1 ) ;
9933: LD_EXP 45
9937: PPUSH
9938: LD_INT 1
9940: PPUSH
9941: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
9945: LD_EXP 45
9949: PPUSH
9950: LD_STRING D6a-Frank-1
9952: PPUSH
9953: CALL_OW 88
// ComWalk ( Frank ) ;
9957: LD_EXP 45
9961: PPUSH
9962: CALL_OW 138
// end ; end ;
9966: END
// every 0 0$01 trigger solar_builded do
9967: LD_EXP 11
9971: IFFALSE 10075
9973: GO 9975
9975: DISABLE
// begin Wait ( 0 0$02 ) ;
9976: LD_INT 70
9978: PPUSH
9979: CALL_OW 67
// DialogueOn ;
9983: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
9987: LD_EXP 31
9991: PPUSH
9992: LD_STRING D2b-JMM-1
9994: PPUSH
9995: CALL_OW 88
// if Walker and IsOk ( Walker ) then
9999: LD_EXP 42
10003: PUSH
10004: LD_EXP 42
10008: PPUSH
10009: CALL_OW 302
10013: AND
10014: IFFALSE 10064
// begin Say ( Walker , D2b-Sci1-1 ) ;
10016: LD_EXP 42
10020: PPUSH
10021: LD_STRING D2b-Sci1-1
10023: PPUSH
10024: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10028: LD_EXP 31
10032: PPUSH
10033: LD_STRING D2b-JMM-2
10035: PPUSH
10036: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10040: LD_EXP 42
10044: PPUSH
10045: LD_STRING D2b-Sci1-2
10047: PPUSH
10048: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10052: LD_EXP 31
10056: PPUSH
10057: LD_STRING D2b-JMM-3
10059: PPUSH
10060: CALL_OW 88
// end ; DialogueOff ;
10064: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10068: LD_STRING MOutSol
10070: PPUSH
10071: CALL_OW 337
// end ;
10075: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10076: LD_EXP 11
10080: PUSH
10081: LD_EXP 31
10085: PPUSH
10086: CALL_OW 302
10090: AND
10091: PUSH
10092: LD_EXP 31
10096: PPUSH
10097: CALL 905 0 1
10101: AND
10102: PUSH
10103: LD_EXP 13
10107: NOT
10108: AND
10109: IFFALSE 10180
10111: GO 10113
10113: DISABLE
10114: LD_INT 0
10116: PPUSH
// begin jmm_in_veh := true ;
10117: LD_ADDR_EXP 13
10121: PUSH
10122: LD_INT 1
10124: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10125: LD_ADDR_VAR 0 1
10129: PUSH
10130: LD_INT 0
10132: PPUSH
10133: LD_INT 1
10135: PPUSH
10136: CALL_OW 12
10140: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10141: LD_INT 70
10143: PPUSH
10144: CALL_OW 67
// if i then
10148: LD_VAR 0 1
10152: IFFALSE 10168
// Say ( JMM , D2c-JMM-1 ) else
10154: LD_EXP 31
10158: PPUSH
10159: LD_STRING D2c-JMM-1
10161: PPUSH
10162: CALL_OW 88
10166: GO 10180
// Say ( JMM , D2c-JMM-1a ) ;
10168: LD_EXP 31
10172: PPUSH
10173: LD_STRING D2c-JMM-1a
10175: PPUSH
10176: CALL_OW 88
// end ;
10180: PPOPN 1
10182: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10183: LD_EXP 11
10187: PUSH
10188: LD_EXP 32
10192: PPUSH
10193: CALL_OW 302
10197: AND
10198: PUSH
10199: LD_EXP 32
10203: PPUSH
10204: CALL 905 0 1
10208: AND
10209: PUSH
10210: LD_EXP 14
10214: NOT
10215: AND
10216: IFFALSE 10248
10218: GO 10220
10220: DISABLE
// begin bobby_in_veh := true ;
10221: LD_ADDR_EXP 14
10225: PUSH
10226: LD_INT 1
10228: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10229: LD_INT 70
10231: PPUSH
10232: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10236: LD_EXP 32
10240: PPUSH
10241: LD_STRING D2c-Bobby-1
10243: PPUSH
10244: CALL_OW 88
10248: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10249: LD_EXP 11
10253: PUSH
10254: LD_EXP 34
10258: PPUSH
10259: CALL_OW 302
10263: AND
10264: PUSH
10265: LD_EXP 34
10269: PPUSH
10270: CALL 905 0 1
10274: AND
10275: PUSH
10276: LD_EXP 16
10280: NOT
10281: AND
10282: IFFALSE 10314
10284: GO 10286
10286: DISABLE
// begin lisa_in_veh := true ;
10287: LD_ADDR_EXP 16
10291: PUSH
10292: LD_INT 1
10294: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10295: LD_INT 70
10297: PPUSH
10298: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10302: LD_EXP 34
10306: PPUSH
10307: LD_STRING D2c-Lisa-1
10309: PPUSH
10310: CALL_OW 88
10314: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
10315: LD_EXP 11
10319: PUSH
10320: LD_EXP 33
10324: PPUSH
10325: CALL_OW 302
10329: AND
10330: PUSH
10331: LD_EXP 33
10335: PPUSH
10336: CALL 905 0 1
10340: AND
10341: PUSH
10342: LD_EXP 15
10346: NOT
10347: AND
10348: IFFALSE 10419
10350: GO 10352
10352: DISABLE
10353: LD_INT 0
10355: PPUSH
// begin cyrus_in_veh := true ;
10356: LD_ADDR_EXP 15
10360: PUSH
10361: LD_INT 1
10363: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10364: LD_ADDR_VAR 0 1
10368: PUSH
10369: LD_INT 0
10371: PPUSH
10372: LD_INT 1
10374: PPUSH
10375: CALL_OW 12
10379: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10380: LD_INT 70
10382: PPUSH
10383: CALL_OW 67
// if i then
10387: LD_VAR 0 1
10391: IFFALSE 10407
// Say ( Cyrus , D2c-Cyrus-1 ) else
10393: LD_EXP 33
10397: PPUSH
10398: LD_STRING D2c-Cyrus-1
10400: PPUSH
10401: CALL_OW 88
10405: GO 10419
// Say ( Cyrus , D2c-Cyrus-1a ) ;
10407: LD_EXP 33
10411: PPUSH
10412: LD_STRING D2c-Cyrus-1a
10414: PPUSH
10415: CALL_OW 88
// end ;
10419: PPOPN 1
10421: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
10422: LD_EXP 38
10426: PPUSH
10427: LD_INT 16
10429: PPUSH
10430: CALL_OW 308
10434: IFFALSE 10684
10436: GO 10438
10438: DISABLE
10439: LD_INT 0
10441: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
10442: LD_INT 3
10444: PPUSH
10445: LD_EXP 38
10449: PPUSH
10450: CALL_OW 471
// send_attack_on_cornel := true ;
10454: LD_ADDR_EXP 28
10458: PUSH
10459: LD_INT 1
10461: ST_TO_ADDR
// if ru_vehicles then
10462: LD_EXP 50
10466: IFFALSE 10500
// for i in ru_vehicles do
10468: LD_ADDR_VAR 0 1
10472: PUSH
10473: LD_EXP 50
10477: PUSH
10478: FOR_IN
10479: IFFALSE 10498
// ComAgressiveMove ( i , 215 , 69 ) ;
10481: LD_VAR 0 1
10485: PPUSH
10486: LD_INT 215
10488: PPUSH
10489: LD_INT 69
10491: PPUSH
10492: CALL_OW 114
10496: GO 10478
10498: POP
10499: POP
// if ru_patrol then
10500: LD_EXP 47
10504: IFFALSE 10538
// for i in ru_patrol do
10506: LD_ADDR_VAR 0 1
10510: PUSH
10511: LD_EXP 47
10515: PUSH
10516: FOR_IN
10517: IFFALSE 10536
// ComAgressiveMove ( i , 215 , 69 ) ;
10519: LD_VAR 0 1
10523: PPUSH
10524: LD_INT 215
10526: PPUSH
10527: LD_INT 69
10529: PPUSH
10530: CALL_OW 114
10534: GO 10516
10536: POP
10537: POP
// if frank_send_to_scout then
10538: LD_EXP 12
10542: IFFALSE 10556
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
10544: LD_EXP 45
10548: PPUSH
10549: LD_STRING D3b-Frank-1
10551: PPUSH
10552: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
10556: LD_INT 105
10558: PPUSH
10559: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
10563: LD_EXP 38
10567: PPUSH
10568: LD_STRING D4-Corn-1
10570: PPUSH
10571: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10575: LD_INT 35
10577: PPUSH
10578: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 6 ;
10582: LD_INT 22
10584: PUSH
10585: LD_INT 4
10587: PUSH
10588: EMPTY
10589: LIST
10590: LIST
10591: PUSH
10592: LD_INT 21
10594: PUSH
10595: LD_INT 1
10597: PUSH
10598: EMPTY
10599: LIST
10600: LIST
10601: PUSH
10602: LD_INT 50
10604: PUSH
10605: EMPTY
10606: LIST
10607: PUSH
10608: EMPTY
10609: LIST
10610: LIST
10611: LIST
10612: PPUSH
10613: CALL_OW 69
10617: PUSH
10618: LD_INT 6
10620: LESS
10621: IFFALSE 10575
// SayRadio ( Cornel , D5-Corn-1 ) ;
10623: LD_EXP 38
10627: PPUSH
10628: LD_STRING D5-Corn-1
10630: PPUSH
10631: CALL_OW 94
// SaveCharacters ( Cornel , Cornel ) ;
10635: LD_EXP 38
10639: PPUSH
10640: LD_STRING Cornel
10642: PPUSH
10643: CALL_OW 38
// ChangeSideFog ( 4 , 8 ) ;
10647: LD_INT 4
10649: PPUSH
10650: LD_INT 8
10652: PPUSH
10653: CALL_OW 343
// Wait ( 0 0$01 ) ;
10657: LD_INT 35
10659: PPUSH
10660: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
10664: LD_INT 3
10666: PPUSH
10667: LD_EXP 38
10671: PPUSH
10672: CALL_OW 472
// send_attack_on_cornel := false ;
10676: LD_ADDR_EXP 28
10680: PUSH
10681: LD_INT 0
10683: ST_TO_ADDR
// end ;
10684: PPOPN 1
10686: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
10687: LD_INT 9
10689: PPUSH
10690: LD_INT 22
10692: PUSH
10693: LD_INT 1
10695: PUSH
10696: EMPTY
10697: LIST
10698: LIST
10699: PPUSH
10700: CALL_OW 70
10704: PUSH
10705: LD_EXP 29
10709: OR
10710: IFFALSE 11229
10712: GO 10714
10714: DISABLE
10715: LD_INT 0
10717: PPUSH
10718: PPUSH
// begin enable ;
10719: ENABLE
// if not game_end then
10720: LD_EXP 29
10724: NOT
10725: IFFALSE 10735
// game_end := true ;
10727: LD_ADDR_EXP 29
10731: PUSH
10732: LD_INT 1
10734: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
10735: LD_ADDR_VAR 0 2
10739: PUSH
10740: LD_INT 9
10742: PPUSH
10743: LD_INT 22
10745: PUSH
10746: LD_INT 1
10748: PUSH
10749: EMPTY
10750: LIST
10751: LIST
10752: PPUSH
10753: CALL_OW 70
10757: ST_TO_ADDR
// if not filter then
10758: LD_VAR 0 2
10762: NOT
10763: IFFALSE 10767
// exit ;
10765: GO 11229
// for i in filter do
10767: LD_ADDR_VAR 0 1
10771: PUSH
10772: LD_VAR 0 2
10776: PUSH
10777: FOR_IN
10778: IFFALSE 11227
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
10780: LD_VAR 0 1
10784: PPUSH
10785: CALL_OW 302
10789: PUSH
10790: LD_VAR 0 1
10794: PPUSH
10795: CALL_OW 247
10799: PUSH
10800: LD_INT 2
10802: EQUAL
10803: AND
10804: IFFALSE 10844
// begin veh_on_meta := true ;
10806: LD_ADDR_EXP 24
10810: PUSH
10811: LD_INT 1
10813: ST_TO_ADDR
// ComExitVehicle ( IsInUnit ( i ) ) ;
10814: LD_VAR 0 1
10818: PPUSH
10819: CALL_OW 310
10823: PPUSH
10824: CALL_OW 121
// RemoveUnit ( i ) ;
10828: LD_VAR 0 1
10832: PPUSH
10833: CALL_OW 64
// Wait ( 10 ) ;
10837: LD_INT 10
10839: PPUSH
10840: CALL_OW 67
// end ; if i = JMM then
10844: LD_VAR 0 1
10848: PUSH
10849: LD_EXP 31
10853: EQUAL
10854: IFFALSE 10976
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
10856: LD_EXP 21
10860: PUSH
10861: LD_INT 22
10863: PUSH
10864: LD_INT 1
10866: PUSH
10867: EMPTY
10868: LIST
10869: LIST
10870: PUSH
10871: LD_INT 21
10873: PUSH
10874: LD_INT 1
10876: PUSH
10877: EMPTY
10878: LIST
10879: LIST
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PPUSH
10885: CALL_OW 69
10889: PUSH
10890: LD_INT 1
10892: GREATER
10893: AND
10894: IFFALSE 10951
// begin show_query := false ;
10896: LD_ADDR_EXP 21
10900: PUSH
10901: LD_INT 0
10903: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
10904: LD_STRING Q2
10906: PPUSH
10907: CALL_OW 97
10911: PUSH
10912: LD_INT 1
10914: DOUBLE
10915: EQUAL
10916: IFTRUE 10920
10918: GO 10931
10920: POP
// wait_for_them := true ; 2 :
10921: LD_ADDR_EXP 22
10925: PUSH
10926: LD_INT 1
10928: ST_TO_ADDR
10929: GO 10951
10931: LD_INT 2
10933: DOUBLE
10934: EQUAL
10935: IFTRUE 10939
10937: GO 10950
10939: POP
// wait_for_them := false ; end ;
10940: LD_ADDR_EXP 22
10944: PUSH
10945: LD_INT 0
10947: ST_TO_ADDR
10948: GO 10951
10950: POP
// end ; save_group := save_group ^ JMM ;
10951: LD_ADDR_EXP 20
10955: PUSH
10956: LD_EXP 20
10960: PUSH
10961: LD_EXP 31
10965: ADD
10966: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
10967: LD_EXP 31
10971: PPUSH
10972: CALL_OW 64
// end ; if i = Lisa then
10976: LD_VAR 0 1
10980: PUSH
10981: LD_EXP 34
10985: EQUAL
10986: IFFALSE 11013
// begin save_group := save_group ^ Lisa ;
10988: LD_ADDR_EXP 20
10992: PUSH
10993: LD_EXP 20
10997: PUSH
10998: LD_EXP 34
11002: ADD
11003: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11004: LD_EXP 34
11008: PPUSH
11009: CALL_OW 64
// end ; if i = Bobby then
11013: LD_VAR 0 1
11017: PUSH
11018: LD_EXP 32
11022: EQUAL
11023: IFFALSE 11050
// begin save_group := save_group ^ Bobby ;
11025: LD_ADDR_EXP 20
11029: PUSH
11030: LD_EXP 20
11034: PUSH
11035: LD_EXP 32
11039: ADD
11040: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11041: LD_EXP 32
11045: PPUSH
11046: CALL_OW 64
// end ; if i = Cyrus then
11050: LD_VAR 0 1
11054: PUSH
11055: LD_EXP 33
11059: EQUAL
11060: IFFALSE 11087
// begin save_group := save_group ^ Cyrus ;
11062: LD_ADDR_EXP 20
11066: PUSH
11067: LD_EXP 20
11071: PUSH
11072: LD_EXP 33
11076: ADD
11077: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11078: LD_EXP 33
11082: PPUSH
11083: CALL_OW 64
// end ; if i = Khatam then
11087: LD_VAR 0 1
11091: PUSH
11092: LD_EXP 35
11096: EQUAL
11097: IFFALSE 11124
// begin save_group := save_group ^ Khatam ;
11099: LD_ADDR_EXP 20
11103: PUSH
11104: LD_EXP 20
11108: PUSH
11109: LD_EXP 35
11113: ADD
11114: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11115: LD_EXP 35
11119: PPUSH
11120: CALL_OW 64
// end ; if i = Frank then
11124: LD_VAR 0 1
11128: PUSH
11129: LD_EXP 45
11133: EQUAL
11134: IFFALSE 11161
// begin save_group := save_group ^ Frank ;
11136: LD_ADDR_EXP 20
11140: PUSH
11141: LD_EXP 20
11145: PUSH
11146: LD_EXP 45
11150: ADD
11151: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11152: LD_EXP 45
11156: PPUSH
11157: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11161: LD_VAR 0 1
11165: PPUSH
11166: CALL_OW 302
11170: PUSH
11171: LD_VAR 0 1
11175: PPUSH
11176: CALL_OW 247
11180: PUSH
11181: LD_INT 1
11183: EQUAL
11184: AND
11185: PUSH
11186: LD_VAR 0 1
11190: PUSH
11191: LD_EXP 20
11195: IN
11196: NOT
11197: AND
11198: IFFALSE 11225
// begin save_others := save_others ^ i ;
11200: LD_ADDR_EXP 19
11204: PUSH
11205: LD_EXP 19
11209: PUSH
11210: LD_VAR 0 1
11214: ADD
11215: ST_TO_ADDR
// RemoveUnit ( i ) ;
11216: LD_VAR 0 1
11220: PPUSH
11221: CALL_OW 64
// end ; end ;
11225: GO 10777
11227: POP
11228: POP
// end ;
11229: PPOPN 2
11231: END
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
11232: LD_EXP 21
11236: NOT
11237: PUSH
11238: LD_EXP 22
11242: NOT
11243: AND
11244: PUSH
11245: LD_INT 22
11247: PUSH
11248: LD_INT 1
11250: PUSH
11251: EMPTY
11252: LIST
11253: LIST
11254: PUSH
11255: LD_INT 21
11257: PUSH
11258: LD_INT 1
11260: PUSH
11261: EMPTY
11262: LIST
11263: LIST
11264: PUSH
11265: EMPTY
11266: LIST
11267: LIST
11268: PPUSH
11269: CALL_OW 69
11273: PUSH
11274: LD_INT 0
11276: EQUAL
11277: OR
11278: IFFALSE 11287
11280: GO 11282
11282: DISABLE
// EndMission ;
11283: CALL 11288 0 0
11287: END
// export function EndMission ; var i ; begin
11288: LD_INT 0
11290: PPUSH
11291: PPUSH
// Wait ( 0 0$02 ) ;
11292: LD_INT 70
11294: PPUSH
11295: CALL_OW 67
// if solar_builded then
11299: LD_EXP 11
11303: IFFALSE 11317
// AddMedal ( Solar1 , 1 ) else
11305: LD_STRING Solar1
11307: PPUSH
11308: LD_INT 1
11310: PPUSH
11311: CALL_OW 101
11315: GO 11328
// AddMedal ( Solar1 , - 1 ) ;
11317: LD_STRING Solar1
11319: PPUSH
11320: LD_INT 1
11322: NEG
11323: PPUSH
11324: CALL_OW 101
// if veh_on_meta then
11328: LD_EXP 24
11332: IFFALSE 11346
// AddMedal ( Solar2 , 1 ) else
11334: LD_STRING Solar2
11336: PPUSH
11337: LD_INT 1
11339: PPUSH
11340: CALL_OW 101
11344: GO 11376
// if solar_builded then
11346: LD_EXP 11
11350: IFFALSE 11365
// AddMedal ( Solar2 , - 1 ) else
11352: LD_STRING Solar2
11354: PPUSH
11355: LD_INT 1
11357: NEG
11358: PPUSH
11359: CALL_OW 101
11363: GO 11376
// AddMedal ( Solar2 , - 2 ) ;
11365: LD_STRING Solar2
11367: PPUSH
11368: LD_INT 2
11370: NEG
11371: PPUSH
11372: CALL_OW 101
// if lose_counter = 0 then
11376: LD_EXP 30
11380: PUSH
11381: LD_INT 0
11383: EQUAL
11384: IFFALSE 11398
// AddMedal ( No , 1 ) else
11386: LD_STRING No
11388: PPUSH
11389: LD_INT 1
11391: PPUSH
11392: CALL_OW 101
11396: GO 11442
// if lose_counter > 0 and lose_counter < 4 then
11398: LD_EXP 30
11402: PUSH
11403: LD_INT 0
11405: GREATER
11406: PUSH
11407: LD_EXP 30
11411: PUSH
11412: LD_INT 4
11414: LESS
11415: AND
11416: IFFALSE 11431
// AddMedal ( No , - 1 ) else
11418: LD_STRING No
11420: PPUSH
11421: LD_INT 1
11423: NEG
11424: PPUSH
11425: CALL_OW 101
11429: GO 11442
// AddMedal ( UpTo4 , - 1 ) ;
11431: LD_STRING UpTo4
11433: PPUSH
11434: LD_INT 1
11436: NEG
11437: PPUSH
11438: CALL_OW 101
// GiveMedals ( MAIN ) ;
11442: LD_STRING MAIN
11444: PPUSH
11445: CALL_OW 102
// if IsDead ( Pokryshkin ) then
11449: LD_EXP 46
11453: PPUSH
11454: CALL_OW 301
11458: IFFALSE 11498
// for i in save_group ^ save_others do
11460: LD_ADDR_VAR 0 2
11464: PUSH
11465: LD_EXP 20
11469: PUSH
11470: LD_EXP 19
11474: ADD
11475: PUSH
11476: FOR_IN
11477: IFFALSE 11496
// AddExperience ( i , skill_combat , 1500 ) ;
11479: LD_VAR 0 2
11483: PPUSH
11484: LD_INT 1
11486: PPUSH
11487: LD_INT 1500
11489: PPUSH
11490: CALL_OW 492
11494: GO 11476
11496: POP
11497: POP
// RewardPeople ( save_group ^ save_others ) ;
11498: LD_EXP 20
11502: PUSH
11503: LD_EXP 19
11507: ADD
11508: PPUSH
11509: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
11513: LD_EXP 31
11517: PPUSH
11518: LD_STRING JMM
11520: PPUSH
11521: CALL_OW 38
// if Bobby in save_group then
11525: LD_EXP 32
11529: PUSH
11530: LD_EXP 20
11534: IN
11535: IFFALSE 11551
// SaveCharacters ( Bobby , Bobby ) else
11537: LD_EXP 32
11541: PPUSH
11542: LD_STRING Bobby
11544: PPUSH
11545: CALL_OW 38
11549: GO 11558
// DeleteCharacters ( Bobby ) ;
11551: LD_STRING Bobby
11553: PPUSH
11554: CALL_OW 40
// if Cyrus in save_group then
11558: LD_EXP 33
11562: PUSH
11563: LD_EXP 20
11567: IN
11568: IFFALSE 11584
// SaveCharacters ( Cyrus , Cyrus ) else
11570: LD_EXP 33
11574: PPUSH
11575: LD_STRING Cyrus
11577: PPUSH
11578: CALL_OW 38
11582: GO 11591
// DeleteCharacters ( Cyrus ) ;
11584: LD_STRING Cyrus
11586: PPUSH
11587: CALL_OW 40
// if Lisa in save_group then
11591: LD_EXP 34
11595: PUSH
11596: LD_EXP 20
11600: IN
11601: IFFALSE 11617
// SaveCharacters ( Lisa , Lisa ) else
11603: LD_EXP 34
11607: PPUSH
11608: LD_STRING Lisa
11610: PPUSH
11611: CALL_OW 38
11615: GO 11624
// DeleteCharacters ( Lisa ) ;
11617: LD_STRING Lisa
11619: PPUSH
11620: CALL_OW 40
// if Frank in save_group then
11624: LD_EXP 45
11628: PUSH
11629: LD_EXP 20
11633: IN
11634: IFFALSE 11650
// SaveCharacters ( Frank , Frank ) else
11636: LD_EXP 45
11640: PPUSH
11641: LD_STRING Frank
11643: PPUSH
11644: CALL_OW 38
11648: GO 11657
// DeleteCharacters ( Frank ) ;
11650: LD_STRING Frank
11652: PPUSH
11653: CALL_OW 40
// if Khatam in save_group then
11657: LD_EXP 35
11661: PUSH
11662: LD_EXP 20
11666: IN
11667: IFFALSE 11683
// SaveCharacters ( Khatam , Khatam ) else
11669: LD_EXP 35
11673: PPUSH
11674: LD_STRING Khatam
11676: PPUSH
11677: CALL_OW 38
11681: GO 11690
// DeleteCharacters ( Khatam ) ;
11683: LD_STRING Khatam
11685: PPUSH
11686: CALL_OW 40
// if save_others then
11690: LD_EXP 19
11694: IFFALSE 11708
// SaveCharacters ( save_others , 03_others ) ;
11696: LD_EXP 19
11700: PPUSH
11701: LD_STRING 03_others
11703: PPUSH
11704: CALL_OW 38
// DeleteCharacters ( Brian ) ;
11708: LD_STRING Brian
11710: PPUSH
11711: CALL_OW 40
// DeleteCharacters ( Jimmy ) ;
11715: LD_STRING Jimmy
11717: PPUSH
11718: CALL_OW 40
// if Bierezov and IsOk ( Bierezov ) then
11722: LD_EXP 39
11726: PUSH
11727: LD_EXP 39
11731: PPUSH
11732: CALL_OW 302
11736: AND
11737: IFFALSE 11749
// begin ResetFog ;
11739: CALL_OW 335
// DisplayEndingScene ;
11743: CALL 11765 0 0
// end else
11747: GO 11756
// DeleteCharacters ( Cornel ) ;
11749: LD_STRING Cornel
11751: PPUSH
11752: CALL_OW 40
// YouWin ;
11756: CALL_OW 103
// end ;
11760: LD_VAR 0 1
11764: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
11765: LD_INT 0
11767: PPUSH
11768: PPUSH
11769: PPUSH
11770: PPUSH
11771: PPUSH
11772: PPUSH
// InGameOn ;
11773: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
11777: LD_INT 208
11779: PPUSH
11780: LD_INT 62
11782: PPUSH
11783: LD_INT 1
11785: PPUSH
11786: LD_INT 10
11788: NEG
11789: PPUSH
11790: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
11794: LD_INT 208
11796: PPUSH
11797: LD_INT 62
11799: PPUSH
11800: LD_INT 1
11802: PPUSH
11803: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11807: LD_ADDR_VAR 0 3
11811: PUSH
11812: LD_INT 22
11814: PUSH
11815: LD_INT 3
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: PUSH
11822: LD_INT 2
11824: PUSH
11825: LD_INT 21
11827: PUSH
11828: LD_INT 2
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: PUSH
11835: LD_INT 21
11837: PUSH
11838: LD_INT 1
11840: PUSH
11841: EMPTY
11842: LIST
11843: LIST
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: LIST
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PPUSH
11854: CALL_OW 69
11858: ST_TO_ADDR
// if filter then
11859: LD_VAR 0 3
11863: IFFALSE 11891
// for i in filter do
11865: LD_ADDR_VAR 0 2
11869: PUSH
11870: LD_VAR 0 3
11874: PUSH
11875: FOR_IN
11876: IFFALSE 11889
// RemoveUnit ( i ) ;
11878: LD_VAR 0 2
11882: PPUSH
11883: CALL_OW 64
11887: GO 11875
11889: POP
11890: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
11891: LD_ADDR_VAR 0 3
11895: PUSH
11896: LD_INT 22
11898: PUSH
11899: LD_INT 4
11901: PUSH
11902: EMPTY
11903: LIST
11904: LIST
11905: PUSH
11906: LD_INT 21
11908: PUSH
11909: LD_INT 1
11911: PUSH
11912: EMPTY
11913: LIST
11914: LIST
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: PPUSH
11920: CALL_OW 69
11924: ST_TO_ADDR
// if filter then
11925: LD_VAR 0 3
11929: IFFALSE 11960
// for i in filter do
11931: LD_ADDR_VAR 0 2
11935: PUSH
11936: LD_VAR 0 3
11940: PUSH
11941: FOR_IN
11942: IFFALSE 11958
// SetLives ( i , 0 ) ;
11944: LD_VAR 0 2
11948: PPUSH
11949: LD_INT 0
11951: PPUSH
11952: CALL_OW 234
11956: GO 11941
11958: POP
11959: POP
// uc_side := 4 ;
11960: LD_ADDR_OWVAR 20
11964: PUSH
11965: LD_INT 4
11967: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
11968: LD_ADDR_VAR 0 4
11972: PUSH
11973: LD_STRING Cornell
11975: PPUSH
11976: LD_INT 0
11978: PPUSH
11979: CALL 434 0 2
11983: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
11984: LD_VAR 0 4
11988: PPUSH
11989: LD_INT 208
11991: PPUSH
11992: LD_INT 62
11994: PPUSH
11995: LD_INT 0
11997: PPUSH
11998: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12002: LD_VAR 0 4
12006: PPUSH
12007: LD_INT 100
12009: PPUSH
12010: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12014: LD_INT 3
12016: PPUSH
12017: LD_VAR 0 4
12021: PPUSH
12022: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12026: LD_INT 4
12028: PPUSH
12029: LD_INT 3
12031: PPUSH
12032: LD_INT 1
12034: PPUSH
12035: LD_INT 1
12037: PPUSH
12038: CALL_OW 80
// uc_side := 3 ;
12042: LD_ADDR_OWVAR 20
12046: PUSH
12047: LD_INT 3
12049: ST_TO_ADDR
// uc_nation := 3 ;
12050: LD_ADDR_OWVAR 21
12054: PUSH
12055: LD_INT 3
12057: ST_TO_ADDR
// InitHc ;
12058: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12062: LD_ADDR_VAR 0 5
12066: PUSH
12067: LD_STRING Mikhail
12069: PPUSH
12070: LD_INT 0
12072: PPUSH
12073: CALL 434 0 2
12077: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12078: LD_INT 1
12080: PPUSH
12081: LD_INT 1
12083: PPUSH
12084: LD_INT 0
12086: PPUSH
12087: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12091: LD_ADDR_VAR 0 6
12095: PUSH
12096: LD_VAR 0 6
12100: PUSH
12101: CALL_OW 44
12105: ADD
12106: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12107: LD_ADDR_VAR 0 6
12111: PUSH
12112: LD_VAR 0 6
12116: PUSH
12117: CALL_OW 44
12121: ADD
12122: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12123: LD_INT 2
12125: PPUSH
12126: LD_INT 4
12128: PPUSH
12129: LD_INT 0
12131: PPUSH
12132: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12136: LD_ADDR_VAR 0 6
12140: PUSH
12141: LD_VAR 0 6
12145: PUSH
12146: CALL_OW 44
12150: ADD
12151: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12152: LD_VAR 0 5
12156: PPUSH
12157: LD_INT 17
12159: PPUSH
12160: LD_INT 0
12162: PPUSH
12163: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12167: LD_VAR 0 5
12171: PPUSH
12172: LD_INT 210
12174: PPUSH
12175: LD_INT 63
12177: PPUSH
12178: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12182: LD_VAR 0 5
12186: PPUSH
12187: LD_INT 208
12189: PPUSH
12190: LD_INT 62
12192: PPUSH
12193: CALL_OW 178
// for i in fake_russians do
12197: LD_ADDR_VAR 0 2
12201: PUSH
12202: LD_VAR 0 6
12206: PUSH
12207: FOR_IN
12208: IFFALSE 12286
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12210: LD_VAR 0 2
12214: PPUSH
12215: LD_INT 17
12217: PPUSH
12218: LD_INT 0
12220: PPUSH
12221: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
12225: LD_VAR 0 2
12229: PPUSH
12230: LD_INT 215
12232: PPUSH
12233: LD_INT 67
12235: PPUSH
12236: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
12240: LD_VAR 0 2
12244: PPUSH
12245: LD_INT 208
12247: PPUSH
12248: LD_INT 62
12250: PPUSH
12251: CALL_OW 178
// if GetClass ( i ) = 4 then
12255: LD_VAR 0 2
12259: PPUSH
12260: CALL_OW 257
12264: PUSH
12265: LD_INT 4
12267: EQUAL
12268: IFFALSE 12284
// ComHeal ( i , fake_cornel ) ;
12270: LD_VAR 0 2
12274: PPUSH
12275: LD_VAR 0 4
12279: PPUSH
12280: CALL_OW 128
// end ;
12284: GO 12207
12286: POP
12287: POP
// Wait ( 0 0$01 ) ;
12288: LD_INT 35
12290: PPUSH
12291: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
12295: LD_INT 208
12297: PPUSH
12298: LD_INT 62
12300: PPUSH
12301: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12305: LD_INT 208
12307: PPUSH
12308: LD_INT 62
12310: PPUSH
12311: LD_INT 1
12313: PPUSH
12314: LD_INT 10
12316: NEG
12317: PPUSH
12318: CALL_OW 330
// Wait ( 0 0$15 ) ;
12322: LD_INT 525
12324: PPUSH
12325: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
12329: LD_INT 208
12331: PPUSH
12332: LD_INT 62
12334: PPUSH
12335: LD_INT 1
12337: PPUSH
12338: CALL_OW 331
// ResetFog ;
12342: CALL_OW 335
// InGameOff ;
12346: CALL_OW 9
// end ;
12350: LD_VAR 0 1
12354: RET
// every 0 0$30 trigger GetDistUnits ( JMM , Cornel ) < 3 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) do
12355: LD_EXP 31
12359: PPUSH
12360: LD_EXP 38
12364: PPUSH
12365: CALL_OW 296
12369: PUSH
12370: LD_INT 3
12372: LESS
12373: PUSH
12374: LD_INT 22
12376: PUSH
12377: LD_INT 4
12379: PUSH
12380: EMPTY
12381: LIST
12382: LIST
12383: PUSH
12384: LD_INT 21
12386: PUSH
12387: LD_INT 3
12389: PUSH
12390: EMPTY
12391: LIST
12392: LIST
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PPUSH
12398: CALL_OW 69
12402: AND
12403: IFFALSE 12421
12405: GO 12407
12407: DISABLE
// begin enable ;
12408: ENABLE
// SayRadio ( Powell , DWarn-Pow-1 ) ;
12409: LD_EXP 40
12413: PPUSH
12414: LD_STRING DWarn-Pow-1
12416: PPUSH
12417: CALL_OW 94
// end ; end_of_file
12421: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
12422: LD_EXP 6
12426: IFFALSE 13661
12428: GO 12430
12430: DISABLE
12431: LD_INT 0
12433: PPUSH
12434: PPUSH
12435: PPUSH
12436: PPUSH
12437: PPUSH
12438: PPUSH
12439: PPUSH
12440: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
12441: LD_EXP 38
12445: PUSH
12446: LD_EXP 39
12450: ADD
12451: PUSH
12452: LD_EXP 4
12456: ADD
12457: PPUSH
12458: LD_INT 250
12460: PPUSH
12461: LD_INT 120
12463: PPUSH
12464: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff [ Bierezov ] ;
12468: LD_ADDR_VAR 0 2
12472: PUSH
12473: LD_EXP 4
12477: PPUSH
12478: LD_INT 25
12480: PUSH
12481: LD_INT 2
12483: PUSH
12484: EMPTY
12485: LIST
12486: LIST
12487: PPUSH
12488: CALL_OW 72
12492: PUSH
12493: LD_EXP 39
12497: PUSH
12498: EMPTY
12499: LIST
12500: DIFF
12501: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
12502: LD_ADDR_VAR 0 3
12506: PUSH
12507: LD_EXP 4
12511: PPUSH
12512: LD_INT 21
12514: PUSH
12515: LD_INT 1
12517: PUSH
12518: EMPTY
12519: LIST
12520: LIST
12521: PPUSH
12522: CALL_OW 72
12526: ST_TO_ADDR
// if not has_eng then
12527: LD_VAR 0 2
12531: NOT
12532: IFFALSE 12615
// begin uc_side := 4 ;
12534: LD_ADDR_OWVAR 20
12538: PUSH
12539: LD_INT 4
12541: ST_TO_ADDR
// uc_nation := 1 ;
12542: LD_ADDR_OWVAR 21
12546: PUSH
12547: LD_INT 1
12549: ST_TO_ADDR
// bc_type := b_depot ;
12550: LD_ADDR_OWVAR 42
12554: PUSH
12555: LD_INT 0
12557: ST_TO_ADDR
// bc_level := 2 ;
12558: LD_ADDR_OWVAR 43
12562: PUSH
12563: LD_INT 2
12565: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
12566: LD_ADDR_VAR 0 4
12570: PUSH
12571: LD_INT 264
12573: PPUSH
12574: LD_INT 120
12576: PPUSH
12577: LD_INT 4
12579: PPUSH
12580: CALL_OW 47
12584: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
12585: LD_INT 264
12587: PPUSH
12588: LD_INT 120
12590: PPUSH
12591: LD_INT 4
12593: PPUSH
12594: LD_INT 10
12596: NEG
12597: PPUSH
12598: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
12602: LD_INT 264
12604: PPUSH
12605: LD_INT 120
12607: PPUSH
12608: LD_INT 4
12610: PPUSH
12611: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
12615: LD_INT 35
12617: PPUSH
12618: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
12622: LD_EXP 38
12626: PPUSH
12627: LD_INT 10
12629: PPUSH
12630: CALL_OW 308
12634: IFFALSE 12615
// if has_eng and not dep then
12636: LD_VAR 0 2
12640: PUSH
12641: LD_VAR 0 4
12645: NOT
12646: AND
12647: IFFALSE 12761
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
12649: LD_VAR 0 2
12653: PPUSH
12654: LD_INT 0
12656: PPUSH
12657: LD_INT 264
12659: PPUSH
12660: LD_INT 120
12662: PPUSH
12663: LD_INT 4
12665: PPUSH
12666: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
12670: LD_INT 35
12672: PPUSH
12673: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
12677: LD_INT 22
12679: PUSH
12680: LD_INT 4
12682: PUSH
12683: EMPTY
12684: LIST
12685: LIST
12686: PUSH
12687: LD_INT 30
12689: PUSH
12690: LD_INT 0
12692: PUSH
12693: EMPTY
12694: LIST
12695: LIST
12696: PUSH
12697: LD_INT 3
12699: PUSH
12700: LD_INT 57
12702: PUSH
12703: EMPTY
12704: LIST
12705: PUSH
12706: EMPTY
12707: LIST
12708: LIST
12709: PUSH
12710: EMPTY
12711: LIST
12712: LIST
12713: LIST
12714: PPUSH
12715: CALL_OW 69
12719: IFFALSE 12670
// dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
12721: LD_ADDR_VAR 0 4
12725: PUSH
12726: LD_INT 22
12728: PUSH
12729: LD_INT 4
12731: PUSH
12732: EMPTY
12733: LIST
12734: LIST
12735: PUSH
12736: LD_INT 30
12738: PUSH
12739: LD_INT 0
12741: PUSH
12742: EMPTY
12743: LIST
12744: LIST
12745: PUSH
12746: EMPTY
12747: LIST
12748: LIST
12749: PPUSH
12750: CALL_OW 69
12754: PUSH
12755: LD_INT 1
12757: ARRAY
12758: ST_TO_ADDR
// end else
12759: GO 12878
// begin SetSide ( dep , 4 ) ;
12761: LD_VAR 0 4
12765: PPUSH
12766: LD_INT 4
12768: PPUSH
12769: CALL_OW 235
// for i = 1 to 3 do
12773: LD_ADDR_VAR 0 1
12777: PUSH
12778: DOUBLE
12779: LD_INT 1
12781: DEC
12782: ST_TO_ADDR
12783: LD_INT 3
12785: PUSH
12786: FOR_TO
12787: IFFALSE 12844
// begin ComEnterUnit ( filter [ i ] , dep ) ;
12789: LD_VAR 0 3
12793: PUSH
12794: LD_VAR 0 1
12798: ARRAY
12799: PPUSH
12800: LD_VAR 0 4
12804: PPUSH
12805: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
12809: LD_VAR 0 3
12813: PUSH
12814: LD_VAR 0 1
12818: ARRAY
12819: PPUSH
12820: LD_INT 2
12822: PPUSH
12823: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
12827: LD_VAR 0 3
12831: PUSH
12832: LD_VAR 0 1
12836: ARRAY
12837: PPUSH
12838: CALL_OW 182
// end ;
12842: GO 12786
12844: POP
12845: POP
// repeat wait ( 0 0$01 ) ;
12846: LD_INT 35
12848: PPUSH
12849: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
12853: LD_VAR 0 3
12857: PPUSH
12858: LD_INT 25
12860: PUSH
12861: LD_INT 2
12863: PUSH
12864: EMPTY
12865: LIST
12866: LIST
12867: PPUSH
12868: CALL_OW 72
12872: PUSH
12873: LD_INT 3
12875: EQUAL
12876: IFFALSE 12846
// end ; if IsInUnit ( Cornel ) then
12878: LD_EXP 38
12882: PPUSH
12883: CALL_OW 310
12887: IFFALSE 12970
// begin cargo := IsInUnit ( Cornel ) ;
12889: LD_ADDR_VAR 0 7
12893: PUSH
12894: LD_EXP 38
12898: PPUSH
12899: CALL_OW 310
12903: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
12904: LD_VAR 0 7
12908: PPUSH
12909: LD_INT 1
12911: PPUSH
12912: CALL_OW 289
12916: IFFALSE 12932
// ComGive ( Cornel , dep ) ;
12918: LD_EXP 38
12922: PPUSH
12923: LD_VAR 0 4
12927: PPUSH
12928: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
12932: LD_EXP 38
12936: PPUSH
12937: LD_INT 235
12939: PPUSH
12940: LD_INT 122
12942: PPUSH
12943: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
12947: LD_EXP 38
12951: PPUSH
12952: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
12956: LD_EXP 38
12960: PPUSH
12961: LD_VAR 0 4
12965: PPUSH
12966: CALL_OW 180
// end ; ComEnterUnit ( Bierezov , dep ) ;
12970: LD_EXP 39
12974: PPUSH
12975: LD_VAR 0 4
12979: PPUSH
12980: CALL_OW 120
// has_eng := UnitFilter ( filter , [ f_class , 2 ] ) ;
12984: LD_ADDR_VAR 0 2
12988: PUSH
12989: LD_VAR 0 3
12993: PPUSH
12994: LD_INT 25
12996: PUSH
12997: LD_INT 2
12999: PUSH
13000: EMPTY
13001: LIST
13002: LIST
13003: PPUSH
13004: CALL_OW 72
13008: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13009: LD_INT 35
13011: PPUSH
13012: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13016: LD_ADDR_VAR 0 6
13020: PUSH
13021: LD_INT 10
13023: PPUSH
13024: CALL_OW 435
13028: ST_TO_ADDR
// if crates then
13029: LD_VAR 0 6
13033: IFFALSE 13062
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
13035: LD_VAR 0 2
13039: PPUSH
13040: LD_VAR 0 6
13044: PUSH
13045: LD_INT 1
13047: ARRAY
13048: PPUSH
13049: LD_VAR 0 6
13053: PUSH
13054: LD_INT 2
13056: ARRAY
13057: PPUSH
13058: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
13062: LD_VAR 0 4
13066: PPUSH
13067: CALL_OW 274
13071: PPUSH
13072: LD_INT 1
13074: PPUSH
13075: CALL_OW 275
13079: PUSH
13080: LD_INT 40
13082: GREATEREQUAL
13083: IFFALSE 13009
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
13085: LD_ADDR_VAR 0 5
13089: PUSH
13090: LD_INT 4
13092: PUSH
13093: LD_INT 256
13095: PUSH
13096: LD_INT 111
13098: PUSH
13099: LD_INT 2
13101: PUSH
13102: EMPTY
13103: LIST
13104: LIST
13105: LIST
13106: LIST
13107: PUSH
13108: LD_INT 31
13110: PUSH
13111: LD_INT 243
13113: PUSH
13114: LD_INT 112
13116: PUSH
13117: LD_INT 2
13119: PUSH
13120: EMPTY
13121: LIST
13122: LIST
13123: LIST
13124: LIST
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: ST_TO_ADDR
// for i in blist do
13130: LD_ADDR_VAR 0 1
13134: PUSH
13135: LD_VAR 0 5
13139: PUSH
13140: FOR_IN
13141: IFFALSE 13190
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
13143: LD_VAR 0 2
13147: PPUSH
13148: LD_VAR 0 1
13152: PUSH
13153: LD_INT 1
13155: ARRAY
13156: PPUSH
13157: LD_VAR 0 1
13161: PUSH
13162: LD_INT 2
13164: ARRAY
13165: PPUSH
13166: LD_VAR 0 1
13170: PUSH
13171: LD_INT 3
13173: ARRAY
13174: PPUSH
13175: LD_VAR 0 1
13179: PUSH
13180: LD_INT 4
13182: ARRAY
13183: PPUSH
13184: CALL_OW 205
13188: GO 13140
13190: POP
13191: POP
// repeat wait ( 0 0$01 ) ;
13192: LD_INT 35
13194: PPUSH
13195: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
13199: LD_INT 22
13201: PUSH
13202: LD_INT 4
13204: PUSH
13205: EMPTY
13206: LIST
13207: LIST
13208: PUSH
13209: LD_INT 30
13211: PUSH
13212: LD_INT 4
13214: PUSH
13215: EMPTY
13216: LIST
13217: LIST
13218: PUSH
13219: LD_INT 3
13221: PUSH
13222: LD_INT 57
13224: PUSH
13225: EMPTY
13226: LIST
13227: PUSH
13228: EMPTY
13229: LIST
13230: LIST
13231: PUSH
13232: EMPTY
13233: LIST
13234: LIST
13235: LIST
13236: PPUSH
13237: CALL_OW 69
13241: IFFALSE 13192
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
13243: LD_VAR 0 3
13247: PUSH
13248: LD_VAR 0 2
13252: DIFF
13253: PPUSH
13254: LD_INT 22
13256: PUSH
13257: LD_INT 4
13259: PUSH
13260: EMPTY
13261: LIST
13262: LIST
13263: PUSH
13264: LD_INT 30
13266: PUSH
13267: LD_INT 4
13269: PUSH
13270: EMPTY
13271: LIST
13272: LIST
13273: PUSH
13274: EMPTY
13275: LIST
13276: LIST
13277: PPUSH
13278: CALL_OW 69
13282: PUSH
13283: LD_INT 1
13285: ARRAY
13286: PPUSH
13287: CALL_OW 180
// repeat wait ( 0 0$01 ) ;
13291: LD_INT 35
13293: PPUSH
13294: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
13298: LD_INT 22
13300: PUSH
13301: LD_INT 4
13303: PUSH
13304: EMPTY
13305: LIST
13306: LIST
13307: PUSH
13308: LD_INT 30
13310: PUSH
13311: LD_INT 31
13313: PUSH
13314: EMPTY
13315: LIST
13316: LIST
13317: PUSH
13318: LD_INT 3
13320: PUSH
13321: LD_INT 57
13323: PUSH
13324: EMPTY
13325: LIST
13326: PUSH
13327: EMPTY
13328: LIST
13329: LIST
13330: PUSH
13331: EMPTY
13332: LIST
13333: LIST
13334: LIST
13335: PPUSH
13336: CALL_OW 69
13340: IFFALSE 13291
// sol := filter diff has_eng ;
13342: LD_ADDR_VAR 0 8
13346: PUSH
13347: LD_VAR 0 3
13351: PUSH
13352: LD_VAR 0 2
13356: DIFF
13357: ST_TO_ADDR
// if GetClass ( sol [ 1 ] ) > 1 then
13358: LD_VAR 0 8
13362: PUSH
13363: LD_INT 1
13365: ARRAY
13366: PPUSH
13367: CALL_OW 257
13371: PUSH
13372: LD_INT 1
13374: GREATER
13375: IFFALSE 13393
// SetClass ( sol [ 1 ] , 1 ) ;
13377: LD_VAR 0 8
13381: PUSH
13382: LD_INT 1
13384: ARRAY
13385: PPUSH
13386: LD_INT 1
13388: PPUSH
13389: CALL_OW 336
// ComExitBuilding ( sol [ 1 ] ) ;
13393: LD_VAR 0 8
13397: PUSH
13398: LD_INT 1
13400: ARRAY
13401: PPUSH
13402: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
13406: LD_VAR 0 8
13410: PUSH
13411: LD_INT 1
13413: ARRAY
13414: PPUSH
13415: LD_INT 22
13417: PUSH
13418: LD_INT 4
13420: PUSH
13421: EMPTY
13422: LIST
13423: LIST
13424: PUSH
13425: LD_INT 30
13427: PUSH
13428: LD_INT 31
13430: PUSH
13431: EMPTY
13432: LIST
13433: LIST
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: PPUSH
13439: CALL_OW 69
13443: PUSH
13444: LD_INT 1
13446: ARRAY
13447: PPUSH
13448: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
13452: LD_VAR 0 2
13456: PPUSH
13457: LD_VAR 0 4
13461: PPUSH
13462: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
13466: LD_INT 35
13468: PPUSH
13469: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13473: LD_ADDR_VAR 0 3
13477: PUSH
13478: LD_INT 22
13480: PUSH
13481: LD_INT 4
13483: PUSH
13484: EMPTY
13485: LIST
13486: LIST
13487: PUSH
13488: LD_INT 21
13490: PUSH
13491: LD_INT 3
13493: PUSH
13494: EMPTY
13495: LIST
13496: LIST
13497: PUSH
13498: LD_INT 3
13500: PUSH
13501: LD_INT 24
13503: PUSH
13504: LD_INT 1000
13506: PUSH
13507: EMPTY
13508: LIST
13509: LIST
13510: PUSH
13511: EMPTY
13512: LIST
13513: LIST
13514: PUSH
13515: EMPTY
13516: LIST
13517: LIST
13518: LIST
13519: PPUSH
13520: CALL_OW 69
13524: ST_TO_ADDR
// if filter and has_eng then
13525: LD_VAR 0 3
13529: PUSH
13530: LD_VAR 0 2
13534: AND
13535: IFFALSE 13601
// begin for i in has_eng do
13537: LD_ADDR_VAR 0 1
13541: PUSH
13542: LD_VAR 0 2
13546: PUSH
13547: FOR_IN
13548: IFFALSE 13597
// begin if IsInUnit ( i ) then
13550: LD_VAR 0 1
13554: PPUSH
13555: CALL_OW 310
13559: IFFALSE 13570
// ComExitBuilding ( i ) ;
13561: LD_VAR 0 1
13565: PPUSH
13566: CALL_OW 122
// Wait ( 3 ) ;
13570: LD_INT 3
13572: PPUSH
13573: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
13577: LD_VAR 0 1
13581: PPUSH
13582: LD_VAR 0 3
13586: PUSH
13587: LD_INT 1
13589: ARRAY
13590: PPUSH
13591: CALL_OW 130
// end ;
13595: GO 13547
13597: POP
13598: POP
// end else
13599: GO 13655
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
13601: LD_VAR 0 2
13605: PUSH
13606: LD_VAR 0 2
13610: PPUSH
13611: LD_INT 56
13613: PUSH
13614: EMPTY
13615: LIST
13616: PPUSH
13617: CALL_OW 72
13621: AND
13622: IFFALSE 13655
// for i in has_eng do
13624: LD_ADDR_VAR 0 1
13628: PUSH
13629: LD_VAR 0 2
13633: PUSH
13634: FOR_IN
13635: IFFALSE 13653
// ComEnterUnit ( i , dep ) ;
13637: LD_VAR 0 1
13641: PPUSH
13642: LD_VAR 0 4
13646: PPUSH
13647: CALL_OW 120
13651: GO 13634
13653: POP
13654: POP
// until cornel_prepared ;
13655: LD_EXP 9
13659: IFFALSE 13466
// end ;
13661: PPOPN 8
13663: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
13664: LD_EXP 9
13668: IFFALSE 14017
13670: GO 13672
13672: DISABLE
13673: LD_INT 0
13675: PPUSH
13676: PPUSH
13677: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
13678: LD_ADDR_VAR 0 2
13682: PUSH
13683: LD_INT 22
13685: PUSH
13686: LD_INT 4
13688: PUSH
13689: EMPTY
13690: LIST
13691: LIST
13692: PUSH
13693: LD_INT 30
13695: PUSH
13696: LD_INT 4
13698: PUSH
13699: EMPTY
13700: LIST
13701: LIST
13702: PUSH
13703: EMPTY
13704: LIST
13705: LIST
13706: PPUSH
13707: CALL_OW 69
13711: PUSH
13712: LD_INT 1
13714: ARRAY
13715: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
13716: LD_EXP 4
13720: PPUSH
13721: CALL_OW 122
// Wait ( 0 0$03 ) ;
13725: LD_INT 105
13727: PPUSH
13728: CALL_OW 67
// for i in cornel_units do
13732: LD_ADDR_VAR 0 1
13736: PUSH
13737: LD_EXP 4
13741: PUSH
13742: FOR_IN
13743: IFFALSE 13819
// begin if GetClass ( i ) in [ 2 , 3 ] then
13745: LD_VAR 0 1
13749: PPUSH
13750: CALL_OW 257
13754: PUSH
13755: LD_INT 2
13757: PUSH
13758: LD_INT 3
13760: PUSH
13761: EMPTY
13762: LIST
13763: LIST
13764: IN
13765: IFFALSE 13802
// begin ComEnterUnit ( i , arm ) ;
13767: LD_VAR 0 1
13771: PPUSH
13772: LD_VAR 0 2
13776: PPUSH
13777: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
13781: LD_VAR 0 1
13785: PPUSH
13786: LD_INT 1
13788: PPUSH
13789: CALL_OW 183
// AddComExitBuilding ( i ) ;
13793: LD_VAR 0 1
13797: PPUSH
13798: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
13802: LD_VAR 0 1
13806: PPUSH
13807: LD_INT 257
13809: PPUSH
13810: LD_INT 121
13812: PPUSH
13813: CALL_OW 171
// end ;
13817: GO 13742
13819: POP
13820: POP
// Wait ( 1 1$00 ) ;
13821: LD_INT 2100
13823: PPUSH
13824: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
13828: LD_ADDR_VAR 0 3
13832: PUSH
13833: LD_EXP 38
13837: PUSH
13838: LD_EXP 39
13842: ADD
13843: PUSH
13844: LD_EXP 4
13848: ADD
13849: PUSH
13850: LD_EXP 4
13854: PPUSH
13855: LD_INT 21
13857: PUSH
13858: LD_INT 2
13860: PUSH
13861: EMPTY
13862: LIST
13863: LIST
13864: PPUSH
13865: CALL_OW 72
13869: DIFF
13870: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
13871: LD_VAR 0 3
13875: PPUSH
13876: LD_INT 248
13878: PPUSH
13879: LD_INT 85
13881: PPUSH
13882: CALL_OW 111
// AddComHold ( filter ) ;
13886: LD_VAR 0 3
13890: PPUSH
13891: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
13895: LD_INT 35
13897: PPUSH
13898: CALL_OW 67
// until cornel_attack ;
13902: LD_EXP 7
13906: IFFALSE 13895
// ComAgressiveMove ( filter , 209 , 63 ) ;
13908: LD_VAR 0 3
13912: PPUSH
13913: LD_INT 209
13915: PPUSH
13916: LD_INT 63
13918: PPUSH
13919: CALL_OW 114
// if Bierezov then
13923: LD_EXP 39
13927: IFFALSE 14017
// begin filter := filter diff Bierezov ;
13929: LD_ADDR_VAR 0 3
13933: PUSH
13934: LD_VAR 0 3
13938: PUSH
13939: LD_EXP 39
13943: DIFF
13944: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
13945: LD_EXP 39
13949: PPUSH
13950: LD_INT 6
13952: PPUSH
13953: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
13957: LD_EXP 39
13961: PPUSH
13962: LD_INT 235
13964: PPUSH
13965: LD_INT 60
13967: PPUSH
13968: CALL_OW 111
// AddComHold ( Bierezov ) ;
13972: LD_EXP 39
13976: PPUSH
13977: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
13981: LD_EXP 39
13985: PPUSH
13986: LD_INT 350
13988: PPUSH
13989: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
13993: LD_EXP 39
13997: PPUSH
13998: LD_INT 198
14000: PPUSH
14001: LD_INT 28
14003: PPUSH
14004: CALL_OW 171
// AddComHold ( Bierezov ) ;
14008: LD_EXP 39
14012: PPUSH
14013: CALL_OW 200
// end ; end ; end_of_file
14017: PPOPN 3
14019: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
14020: LD_EXP 47
14024: PUSH
14025: LD_EXP 27
14029: NOT
14030: AND
14031: PUSH
14032: LD_EXP 28
14036: NOT
14037: AND
14038: IFFALSE 14488
14040: GO 14042
14042: DISABLE
14043: LD_INT 0
14045: PPUSH
14046: PPUSH
14047: PPUSH
14048: PPUSH
// begin enable ;
14049: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14050: LD_ADDR_VAR 0 4
14054: PUSH
14055: LD_INT 81
14057: PUSH
14058: LD_INT 3
14060: PUSH
14061: EMPTY
14062: LIST
14063: LIST
14064: PPUSH
14065: CALL_OW 69
14069: ST_TO_ADDR
// for i = 1 to ru_patrol do
14070: LD_ADDR_VAR 0 2
14074: PUSH
14075: DOUBLE
14076: LD_INT 1
14078: DEC
14079: ST_TO_ADDR
14080: LD_EXP 47
14084: PUSH
14085: FOR_TO
14086: IFFALSE 14486
// begin un := ru_patrol [ i ] ;
14088: LD_ADDR_VAR 0 1
14092: PUSH
14093: LD_EXP 47
14097: PUSH
14098: LD_VAR 0 2
14102: ARRAY
14103: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14104: LD_VAR 0 1
14108: PPUSH
14109: LD_INT 13
14111: PPUSH
14112: CALL_OW 308
14116: IFFALSE 14221
// begin if not ru_alert then
14118: LD_EXP 54
14122: NOT
14123: IFFALSE 14133
// ru_alert := true ;
14125: LD_ADDR_EXP 54
14129: PUSH
14130: LD_INT 1
14132: ST_TO_ADDR
// if not See ( 1 , un ) then
14133: LD_INT 1
14135: PPUSH
14136: LD_VAR 0 1
14140: PPUSH
14141: CALL_OW 292
14145: NOT
14146: IFFALSE 14160
// SetLives ( un , 1000 ) ;
14148: LD_VAR 0 1
14152: PPUSH
14153: LD_INT 1000
14155: PPUSH
14156: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
14160: LD_ADDR_EXP 47
14164: PUSH
14165: LD_EXP 47
14169: PUSH
14170: LD_VAR 0 1
14174: DIFF
14175: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
14176: LD_VAR 0 1
14180: PPUSH
14181: LD_INT 22
14183: PUSH
14184: LD_INT 3
14186: PUSH
14187: EMPTY
14188: LIST
14189: LIST
14190: PUSH
14191: LD_INT 30
14193: PUSH
14194: LD_INT 4
14196: PUSH
14197: EMPTY
14198: LIST
14199: LIST
14200: PUSH
14201: EMPTY
14202: LIST
14203: LIST
14204: PPUSH
14205: CALL_OW 69
14209: PPUSH
14210: CALL 1001 0 1
14214: PPUSH
14215: CALL_OW 120
// continue ;
14219: GO 14085
// end ; if IsOk ( un ) and not HasTask ( un ) then
14221: LD_VAR 0 1
14225: PPUSH
14226: CALL_OW 302
14230: PUSH
14231: LD_VAR 0 1
14235: PPUSH
14236: CALL_OW 314
14240: NOT
14241: AND
14242: IFFALSE 14335
// begin for j = 1 to ru_firepoints_south [ i ] do
14244: LD_ADDR_VAR 0 3
14248: PUSH
14249: DOUBLE
14250: LD_INT 1
14252: DEC
14253: ST_TO_ADDR
14254: LD_EXP 53
14258: PUSH
14259: LD_VAR 0 2
14263: ARRAY
14264: PUSH
14265: FOR_TO
14266: IFFALSE 14333
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
14268: LD_VAR 0 1
14272: PPUSH
14273: LD_EXP 53
14277: PUSH
14278: LD_VAR 0 2
14282: ARRAY
14283: PUSH
14284: LD_VAR 0 3
14288: ARRAY
14289: PUSH
14290: LD_INT 1
14292: ARRAY
14293: PPUSH
14294: LD_EXP 53
14298: PUSH
14299: LD_VAR 0 2
14303: ARRAY
14304: PUSH
14305: LD_VAR 0 3
14309: ARRAY
14310: PUSH
14311: LD_INT 2
14313: ARRAY
14314: PPUSH
14315: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
14319: LD_VAR 0 1
14323: PPUSH
14324: LD_INT 70
14326: PPUSH
14327: CALL_OW 202
// end ;
14331: GO 14265
14333: POP
14334: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
14335: LD_VAR 0 1
14339: PPUSH
14340: CALL_OW 256
14344: PUSH
14345: LD_INT 700
14347: LESS
14348: PUSH
14349: LD_VAR 0 1
14353: PPUSH
14354: LD_INT 13
14356: PPUSH
14357: CALL_OW 308
14361: NOT
14362: AND
14363: IFFALSE 14415
// begin ComMoveToArea ( un , retreatArea ) ;
14365: LD_VAR 0 1
14369: PPUSH
14370: LD_INT 13
14372: PPUSH
14373: CALL_OW 113
// if not ru_alert_xy then
14377: LD_EXP 55
14381: NOT
14382: IFFALSE 14413
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
14384: LD_ADDR_EXP 55
14388: PUSH
14389: LD_VAR 0 1
14393: PPUSH
14394: CALL_OW 250
14398: PUSH
14399: LD_VAR 0 1
14403: PPUSH
14404: CALL_OW 251
14408: PUSH
14409: EMPTY
14410: LIST
14411: LIST
14412: ST_TO_ADDR
// end else
14413: GO 14484
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
14415: LD_VAR 0 1
14419: PPUSH
14420: LD_VAR 0 4
14424: PPUSH
14425: LD_VAR 0 1
14429: PPUSH
14430: CALL_OW 74
14434: PPUSH
14435: CALL_OW 296
14439: PUSH
14440: LD_INT 9
14442: LESS
14443: PUSH
14444: LD_VAR 0 1
14448: PPUSH
14449: CALL_OW 256
14453: PUSH
14454: LD_INT 500
14456: GREATER
14457: AND
14458: IFFALSE 14484
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
14460: LD_VAR 0 1
14464: PPUSH
14465: LD_VAR 0 4
14469: PPUSH
14470: LD_VAR 0 1
14474: PPUSH
14475: CALL_OW 74
14479: PPUSH
14480: CALL_OW 115
// end ;
14484: GO 14085
14486: POP
14487: POP
// end ;
14488: PPOPN 4
14490: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
14491: LD_EXP 54
14495: PUSH
14496: LD_EXP 55
14500: AND
14501: PUSH
14502: LD_EXP 27
14506: NOT
14507: AND
14508: PUSH
14509: LD_EXP 28
14513: NOT
14514: AND
14515: IFFALSE 14725
14517: GO 14519
14519: DISABLE
14520: LD_INT 0
14522: PPUSH
14523: PPUSH
// begin enable ;
14524: ENABLE
// if not ru_vehicles then
14525: LD_EXP 50
14529: NOT
14530: IFFALSE 14534
// exit ;
14532: GO 14725
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14534: LD_ADDR_VAR 0 2
14538: PUSH
14539: LD_INT 81
14541: PUSH
14542: LD_INT 3
14544: PUSH
14545: EMPTY
14546: LIST
14547: LIST
14548: PPUSH
14549: CALL_OW 69
14553: ST_TO_ADDR
// if ru_vehicles then
14554: LD_EXP 50
14558: IFFALSE 14725
// begin for i in ru_vehicles do
14560: LD_ADDR_VAR 0 1
14564: PUSH
14565: LD_EXP 50
14569: PUSH
14570: FOR_IN
14571: IFFALSE 14723
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
14573: LD_VAR 0 1
14577: PPUSH
14578: CALL_OW 302
14582: PUSH
14583: LD_VAR 0 1
14587: PPUSH
14588: LD_VAR 0 2
14592: PPUSH
14593: LD_VAR 0 1
14597: PPUSH
14598: CALL_OW 74
14602: PPUSH
14603: CALL_OW 296
14607: PUSH
14608: LD_INT 9
14610: LESS
14611: AND
14612: IFFALSE 14638
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
14614: LD_VAR 0 1
14618: PPUSH
14619: LD_VAR 0 2
14623: PPUSH
14624: LD_VAR 0 1
14628: PPUSH
14629: CALL_OW 74
14633: PPUSH
14634: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
14638: LD_VAR 0 1
14642: PPUSH
14643: CALL_OW 314
14647: NOT
14648: PUSH
14649: LD_VAR 0 1
14653: PPUSH
14654: CALL_OW 302
14658: AND
14659: PUSH
14660: LD_VAR 0 1
14664: PPUSH
14665: LD_EXP 55
14669: PUSH
14670: LD_INT 1
14672: ARRAY
14673: PPUSH
14674: LD_EXP 55
14678: PUSH
14679: LD_INT 2
14681: ARRAY
14682: PPUSH
14683: CALL_OW 297
14687: PUSH
14688: LD_INT 10
14690: GREATER
14691: AND
14692: IFFALSE 14721
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
14694: LD_VAR 0 1
14698: PPUSH
14699: LD_EXP 55
14703: PUSH
14704: LD_INT 1
14706: ARRAY
14707: PPUSH
14708: LD_EXP 55
14712: PUSH
14713: LD_INT 2
14715: ARRAY
14716: PPUSH
14717: CALL_OW 114
// end ;
14721: GO 14570
14723: POP
14724: POP
// end ; end ;
14725: PPOPN 2
14727: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
14728: LD_EXP 55
14732: PUSH
14733: LD_EXP 54
14737: AND
14738: PUSH
14739: LD_INT 3
14741: PPUSH
14742: CALL_OW 463
14746: NOT
14747: AND
14748: PUSH
14749: LD_EXP 27
14753: NOT
14754: AND
14755: PUSH
14756: LD_EXP 28
14760: NOT
14761: AND
14762: IFFALSE 14857
14764: GO 14766
14766: DISABLE
14767: LD_INT 0
14769: PPUSH
// begin enable ;
14770: ENABLE
// ru_alert_xy := false ;
14771: LD_ADDR_EXP 55
14775: PUSH
14776: LD_INT 0
14778: ST_TO_ADDR
// ru_alert := false ;
14779: LD_ADDR_EXP 54
14783: PUSH
14784: LD_INT 0
14786: ST_TO_ADDR
// if ru_vehicles then
14787: LD_EXP 50
14791: IFFALSE 14857
// for i in ru_vehicles do
14793: LD_ADDR_VAR 0 1
14797: PUSH
14798: LD_EXP 50
14802: PUSH
14803: FOR_IN
14804: IFFALSE 14855
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
14806: LD_VAR 0 1
14810: PPUSH
14811: CALL_OW 302
14815: PUSH
14816: LD_VAR 0 1
14820: PPUSH
14821: LD_INT 89
14823: PPUSH
14824: LD_INT 36
14826: PPUSH
14827: CALL_OW 297
14831: PUSH
14832: LD_INT 10
14834: GREATER
14835: AND
14836: IFFALSE 14853
// ComMoveXY ( i , 89 , 36 ) ;
14838: LD_VAR 0 1
14842: PPUSH
14843: LD_INT 89
14845: PPUSH
14846: LD_INT 36
14848: PPUSH
14849: CALL_OW 111
14853: GO 14803
14855: POP
14856: POP
// end ;
14857: PPOPN 1
14859: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
14860: LD_EXP 49
14864: PUSH
14865: LD_EXP 27
14869: NOT
14870: AND
14871: PUSH
14872: LD_EXP 28
14876: NOT
14877: AND
14878: IFFALSE 15162
14880: GO 14882
14882: DISABLE
14883: LD_INT 0
14885: PPUSH
14886: PPUSH
14887: PPUSH
// begin enable ;
14888: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14889: LD_ADDR_VAR 0 3
14893: PUSH
14894: LD_INT 81
14896: PUSH
14897: LD_INT 3
14899: PUSH
14900: EMPTY
14901: LIST
14902: LIST
14903: PPUSH
14904: CALL_OW 69
14908: ST_TO_ADDR
// for i = 1 to ru_forest do
14909: LD_ADDR_VAR 0 1
14913: PUSH
14914: DOUBLE
14915: LD_INT 1
14917: DEC
14918: ST_TO_ADDR
14919: LD_EXP 49
14923: PUSH
14924: FOR_TO
14925: IFFALSE 15160
// begin un := ru_forest [ i ] ;
14927: LD_ADDR_VAR 0 2
14931: PUSH
14932: LD_EXP 49
14936: PUSH
14937: LD_VAR 0 1
14941: ARRAY
14942: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14943: LD_VAR 0 2
14947: PPUSH
14948: LD_INT 13
14950: PPUSH
14951: CALL_OW 308
14955: IFFALSE 15045
// begin if not See ( 1 , un ) then
14957: LD_INT 1
14959: PPUSH
14960: LD_VAR 0 2
14964: PPUSH
14965: CALL_OW 292
14969: NOT
14970: IFFALSE 14984
// SetLives ( un , 1000 ) ;
14972: LD_VAR 0 2
14976: PPUSH
14977: LD_INT 1000
14979: PPUSH
14980: CALL_OW 234
// ru_forest := ru_forest diff un ;
14984: LD_ADDR_EXP 49
14988: PUSH
14989: LD_EXP 49
14993: PUSH
14994: LD_VAR 0 2
14998: DIFF
14999: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15000: LD_VAR 0 2
15004: PPUSH
15005: LD_INT 22
15007: PUSH
15008: LD_INT 3
15010: PUSH
15011: EMPTY
15012: LIST
15013: LIST
15014: PUSH
15015: LD_INT 30
15017: PUSH
15018: LD_INT 4
15020: PUSH
15021: EMPTY
15022: LIST
15023: LIST
15024: PUSH
15025: EMPTY
15026: LIST
15027: LIST
15028: PPUSH
15029: CALL_OW 69
15033: PPUSH
15034: CALL 1001 0 1
15038: PPUSH
15039: CALL_OW 120
// continue ;
15043: GO 14924
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15045: LD_VAR 0 2
15049: PPUSH
15050: CALL_OW 256
15054: PUSH
15055: LD_INT 700
15057: LESS
15058: PUSH
15059: LD_VAR 0 2
15063: PPUSH
15064: LD_INT 13
15066: PPUSH
15067: CALL_OW 308
15071: NOT
15072: AND
15073: IFFALSE 15089
// ComMoveToArea ( un , retreatArea ) else
15075: LD_VAR 0 2
15079: PPUSH
15080: LD_INT 13
15082: PPUSH
15083: CALL_OW 113
15087: GO 15158
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15089: LD_VAR 0 2
15093: PPUSH
15094: LD_VAR 0 3
15098: PPUSH
15099: LD_VAR 0 2
15103: PPUSH
15104: CALL_OW 74
15108: PPUSH
15109: CALL_OW 296
15113: PUSH
15114: LD_INT 9
15116: LESS
15117: PUSH
15118: LD_VAR 0 2
15122: PPUSH
15123: CALL_OW 256
15127: PUSH
15128: LD_INT 500
15130: GREATER
15131: AND
15132: IFFALSE 15158
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15134: LD_VAR 0 2
15138: PPUSH
15139: LD_VAR 0 3
15143: PPUSH
15144: LD_VAR 0 2
15148: PPUSH
15149: CALL_OW 74
15153: PPUSH
15154: CALL_OW 115
// end ;
15158: GO 14924
15160: POP
15161: POP
// end ;
15162: PPOPN 3
15164: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
15165: LD_EXP 28
15169: NOT
15170: IFFALSE 15291
15172: GO 15174
15174: DISABLE
15175: LD_INT 0
15177: PPUSH
15178: PPUSH
// begin enable ;
15179: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
15180: LD_ADDR_VAR 0 2
15184: PUSH
15185: LD_INT 22
15187: PUSH
15188: LD_INT 3
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PUSH
15195: LD_INT 21
15197: PUSH
15198: LD_INT 3
15200: PUSH
15201: EMPTY
15202: LIST
15203: LIST
15204: PUSH
15205: EMPTY
15206: LIST
15207: LIST
15208: PPUSH
15209: CALL_OW 69
15213: ST_TO_ADDR
// if filter then
15214: LD_VAR 0 2
15218: IFFALSE 15291
// for i in filter do
15220: LD_ADDR_VAR 0 1
15224: PUSH
15225: LD_VAR 0 2
15229: PUSH
15230: FOR_IN
15231: IFFALSE 15289
// if GetLives ( i ) < 990 then
15233: LD_VAR 0 1
15237: PPUSH
15238: CALL_OW 256
15242: PUSH
15243: LD_INT 990
15245: LESS
15246: IFFALSE 15287
// begin ru_alert := true ;
15248: LD_ADDR_EXP 54
15252: PUSH
15253: LD_INT 1
15255: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
15256: LD_ADDR_EXP 55
15260: PUSH
15261: LD_VAR 0 1
15265: PPUSH
15266: CALL_OW 250
15270: PUSH
15271: LD_VAR 0 1
15275: PPUSH
15276: CALL_OW 251
15280: PUSH
15281: EMPTY
15282: LIST
15283: LIST
15284: ST_TO_ADDR
// break ;
15285: GO 15289
// end ;
15287: GO 15230
15289: POP
15290: POP
// end ;
15291: PPOPN 2
15293: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
15294: LD_EXP 27
15298: IFFALSE 15447
15300: GO 15302
15302: DISABLE
15303: LD_INT 0
15305: PPUSH
15306: PPUSH
15307: PPUSH
15308: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
15309: LD_ADDR_VAR 0 4
15313: PUSH
15314: LD_EXP 50
15318: PUSH
15319: LD_EXP 49
15323: ADD
15324: PUSH
15325: LD_EXP 47
15329: ADD
15330: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
15331: LD_ADDR_VAR 0 3
15335: PUSH
15336: LD_INT 3
15338: PPUSH
15339: LD_INT 81
15341: PUSH
15342: LD_INT 3
15344: PUSH
15345: EMPTY
15346: LIST
15347: LIST
15348: PPUSH
15349: CALL_OW 70
15353: ST_TO_ADDR
// if filter and enemy then
15354: LD_VAR 0 4
15358: PUSH
15359: LD_VAR 0 3
15363: AND
15364: IFFALSE 15447
// repeat wait ( 0 0$01 ) ;
15366: LD_INT 35
15368: PPUSH
15369: CALL_OW 67
// for i in filter do
15373: LD_ADDR_VAR 0 1
15377: PUSH
15378: LD_VAR 0 4
15382: PUSH
15383: FOR_IN
15384: IFFALSE 15412
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15386: LD_VAR 0 1
15390: PPUSH
15391: LD_VAR 0 3
15395: PPUSH
15396: LD_VAR 0 1
15400: PPUSH
15401: CALL_OW 74
15405: PPUSH
15406: CALL_OW 115
// end ;
15410: GO 15383
15412: POP
15413: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
15414: LD_INT 3
15416: PPUSH
15417: LD_INT 81
15419: PUSH
15420: LD_INT 3
15422: PUSH
15423: EMPTY
15424: LIST
15425: LIST
15426: PPUSH
15427: CALL_OW 70
15431: PUSH
15432: LD_INT 0
15434: EQUAL
15435: PUSH
15436: LD_VAR 0 4
15440: PUSH
15441: LD_INT 0
15443: EQUAL
15444: OR
15445: IFFALSE 15366
// end ;
15447: PPOPN 4
15449: END
// every 0 0$03 trigger send_attack_on_cornel_base do var i ;
15450: LD_EXP 23
15454: IFFALSE 15503
15456: GO 15458
15458: DISABLE
15459: LD_INT 0
15461: PPUSH
// begin if not ru_cornel_attack then
15462: LD_EXP 52
15466: NOT
15467: IFFALSE 15471
// exit ;
15469: GO 15503
// for i in ru_cornel_attack do
15471: LD_ADDR_VAR 0 1
15475: PUSH
15476: LD_EXP 52
15480: PUSH
15481: FOR_IN
15482: IFFALSE 15501
// ComAgressiveMove ( i , 258 , 119 ) ;
15484: LD_VAR 0 1
15488: PPUSH
15489: LD_INT 258
15491: PPUSH
15492: LD_INT 119
15494: PPUSH
15495: CALL_OW 114
15499: GO 15481
15501: POP
15502: POP
// end ; end_of_file
15503: PPOPN 1
15505: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
15506: LD_EXP 3
15510: PUSH
15511: LD_EXP 7
15515: NOT
15516: AND
15517: PUSH
15518: LD_EXP 17
15522: AND
15523: IFFALSE 15635
15525: GO 15527
15527: DISABLE
15528: LD_INT 0
15530: PPUSH
// begin enable ;
15531: ENABLE
// crates_counter := crates_counter - 50 ;
15532: LD_ADDR_EXP 17
15536: PUSH
15537: LD_EXP 17
15541: PUSH
15542: LD_INT 50
15544: MINUS
15545: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
15546: LD_INT 8
15548: PPUSH
15549: LD_INT 2
15551: PPUSH
15552: LD_INT 5
15554: PPUSH
15555: CALL_OW 12
15559: PPUSH
15560: LD_INT 1
15562: PPUSH
15563: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
15567: LD_INT 1785
15569: PPUSH
15570: LD_INT 2345
15572: PPUSH
15573: CALL_OW 12
15577: PPUSH
15578: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
15582: LD_ADDR_VAR 0 1
15586: PUSH
15587: LD_INT 1
15589: PPUSH
15590: LD_OWVAR 67
15594: PUSH
15595: LD_INT 2
15597: PLUS
15598: PPUSH
15599: CALL_OW 12
15603: ST_TO_ADDR
// if r < 3 then
15604: LD_VAR 0 1
15608: PUSH
15609: LD_INT 3
15611: LESS
15612: IFFALSE 15635
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
15614: LD_INT 4
15616: PPUSH
15617: LD_INT 1
15619: PPUSH
15620: LD_INT 5
15622: PPUSH
15623: CALL_OW 12
15627: PPUSH
15628: LD_INT 1
15630: PPUSH
15631: CALL_OW 55
// end ;
15635: PPOPN 1
15637: END
// every 0 0$01 trigger cornel_active do
15638: LD_EXP 6
15642: IFFALSE 15731
15644: GO 15646
15646: DISABLE
// begin Wait ( 0 0$03 ) ;
15647: LD_INT 105
15649: PPUSH
15650: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15654: LD_INT 2
15656: PPUSH
15657: LD_INT 5
15659: PPUSH
15660: CALL_OW 12
15664: PPUSH
15665: LD_INT 10
15667: PPUSH
15668: LD_INT 1
15670: PPUSH
15671: CALL_OW 55
// Wait ( 0 0$13 ) ;
15675: LD_INT 455
15677: PPUSH
15678: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15682: LD_INT 2
15684: PPUSH
15685: LD_INT 5
15687: PPUSH
15688: CALL_OW 12
15692: PPUSH
15693: LD_INT 10
15695: PPUSH
15696: LD_INT 1
15698: PPUSH
15699: CALL_OW 55
// Wait ( 0 0$16 ) ;
15703: LD_INT 560
15705: PPUSH
15706: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15710: LD_INT 2
15712: PPUSH
15713: LD_INT 5
15715: PPUSH
15716: CALL_OW 12
15720: PPUSH
15721: LD_INT 10
15723: PPUSH
15724: LD_INT 1
15726: PPUSH
15727: CALL_OW 55
// end ; end_of_file
15731: END
// every 0 0$01 trigger cornel_prepared do
15732: LD_EXP 9
15736: IFFALSE 15795
15738: GO 15740
15740: DISABLE
// begin enable ;
15741: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
15742: LD_ADDR_OWVAR 47
15746: PUSH
15747: LD_STRING #Am03-1
15749: PUSH
15750: LD_EXP 8
15754: PUSH
15755: EMPTY
15756: LIST
15757: LIST
15758: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
15759: LD_ADDR_EXP 8
15763: PUSH
15764: LD_EXP 8
15768: PPUSH
15769: LD_STRING -
15771: PPUSH
15772: CALL 1071 0 2
15776: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
15777: LD_EXP 8
15781: PUSH
15782: LD_INT 0
15784: EQUAL
15785: IFFALSE 15795
// begin Display_Strings := [ ] ;
15787: LD_ADDR_OWVAR 47
15791: PUSH
15792: EMPTY
15793: ST_TO_ADDR
// disable ;
15794: DISABLE
// end ; end ;
15795: END
// every 0 0$01 trigger debug and debug_strings do
15796: LD_EXP 1
15800: PUSH
15801: LD_OWVAR 48
15805: AND
15806: IFFALSE 15822
15808: GO 15810
15810: DISABLE
// begin enable ;
15811: ENABLE
// Display_Strings := debug_strings ;
15812: LD_ADDR_OWVAR 47
15816: PUSH
15817: LD_OWVAR 48
15821: ST_TO_ADDR
// end ; end_of_file
15822: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
15823: LD_VAR 0 1
15827: PPUSH
15828: CALL_OW 255
15832: PUSH
15833: LD_INT 1
15835: EQUAL
15836: PUSH
15837: LD_EXP 11
15841: NOT
15842: AND
15843: IFFALSE 15853
// solar_builded := true ;
15845: LD_ADDR_EXP 11
15849: PUSH
15850: LD_INT 1
15852: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
15853: LD_VAR 0 1
15857: PPUSH
15858: CALL_OW 255
15862: PUSH
15863: LD_INT 1
15865: EQUAL
15866: PUSH
15867: LD_EXP 25
15871: AND
15872: IFFALSE 15905
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
15874: LD_ADDR_EXP 25
15878: PUSH
15879: LD_EXP 25
15883: PUSH
15884: LD_INT 1750
15886: PUSH
15887: LD_INT 1400
15889: PUSH
15890: LD_INT 1225
15892: PUSH
15893: EMPTY
15894: LIST
15895: LIST
15896: LIST
15897: PUSH
15898: LD_OWVAR 67
15902: ARRAY
15903: PLUS
15904: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
15905: LD_VAR 0 1
15909: PPUSH
15910: CALL_OW 255
15914: PUSH
15915: LD_INT 3
15917: EQUAL
15918: IFFALSE 15936
// ru_vehicles := ru_vehicles ^ veh ;
15920: LD_ADDR_EXP 50
15924: PUSH
15925: LD_EXP 50
15929: PUSH
15930: LD_VAR 0 1
15934: ADD
15935: ST_TO_ADDR
// end ;
15936: PPOPN 2
15938: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
15939: LD_VAR 0 1
15943: PUSH
15944: LD_EXP 47
15948: IN
15949: IFFALSE 15967
// ru_patrol := ru_patrol diff un ;
15951: LD_ADDR_EXP 47
15955: PUSH
15956: LD_EXP 47
15960: PUSH
15961: LD_VAR 0 1
15965: DIFF
15966: ST_TO_ADDR
// if un in ru_forest then
15967: LD_VAR 0 1
15971: PUSH
15972: LD_EXP 49
15976: IN
15977: IFFALSE 15995
// ru_forest := ru_forest diff un ;
15979: LD_ADDR_EXP 49
15983: PUSH
15984: LD_EXP 49
15988: PUSH
15989: LD_VAR 0 1
15993: DIFF
15994: ST_TO_ADDR
// if un in ru_vehicles then
15995: LD_VAR 0 1
15999: PUSH
16000: LD_EXP 50
16004: IN
16005: IFFALSE 16080
// begin ru_vehicles := ru_vehicles diff un ;
16007: LD_ADDR_EXP 50
16011: PUSH
16012: LD_EXP 50
16016: PUSH
16017: LD_VAR 0 1
16021: DIFF
16022: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
16023: LD_ADDR_EXP 51
16027: PUSH
16028: LD_EXP 51
16032: PUSH
16033: LD_VAR 0 1
16037: PPUSH
16038: CALL_OW 265
16042: PUSH
16043: LD_VAR 0 1
16047: PPUSH
16048: CALL_OW 262
16052: PUSH
16053: LD_VAR 0 1
16057: PPUSH
16058: CALL_OW 263
16062: PUSH
16063: LD_VAR 0 1
16067: PPUSH
16068: CALL_OW 264
16072: PUSH
16073: EMPTY
16074: LIST
16075: LIST
16076: LIST
16077: LIST
16078: ADD
16079: ST_TO_ADDR
// end ; if un = JMM then
16080: LD_VAR 0 1
16084: PUSH
16085: LD_EXP 31
16089: EQUAL
16090: IFFALSE 16099
// YouLost ( 0 ) ;
16092: LD_STRING 0
16094: PPUSH
16095: CALL_OW 104
// if un = us_dep_west then
16099: LD_VAR 0 1
16103: PUSH
16104: LD_INT 1
16106: EQUAL
16107: IFFALSE 16116
// YouLost ( 2 ) ;
16109: LD_STRING 2
16111: PPUSH
16112: CALL_OW 104
// if un = Lynch and GetSide ( Lynch ) = 8 then
16116: LD_VAR 0 1
16120: PUSH
16121: LD_EXP 41
16125: EQUAL
16126: PUSH
16127: LD_EXP 41
16131: PPUSH
16132: CALL_OW 255
16136: PUSH
16137: LD_INT 8
16139: EQUAL
16140: AND
16141: IFFALSE 16150
// YouLost ( 4 ) ;
16143: LD_STRING 4
16145: PPUSH
16146: CALL_OW 104
// if un in jmm_units then
16150: LD_VAR 0 1
16154: PUSH
16155: LD_EXP 2
16159: IN
16160: IFFALSE 16176
// lose_counter := lose_counter + 1 ;
16162: LD_ADDR_EXP 30
16166: PUSH
16167: LD_EXP 30
16171: PUSH
16172: LD_INT 1
16174: PLUS
16175: ST_TO_ADDR
// end ;
16176: PPOPN 1
16178: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
16179: LD_INT 0
16181: PPUSH
16182: PPUSH
// begin if GetSide ( driver ) = 3 then
16183: LD_VAR 0 1
16187: PPUSH
16188: CALL_OW 255
16192: PUSH
16193: LD_INT 3
16195: EQUAL
16196: IFFALSE 16274
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
16198: LD_ADDR_VAR 0 6
16202: PUSH
16203: LD_INT 22
16205: PUSH
16206: LD_INT 3
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: PUSH
16213: LD_INT 30
16215: PUSH
16216: LD_INT 3
16218: PUSH
16219: EMPTY
16220: LIST
16221: LIST
16222: PUSH
16223: EMPTY
16224: LIST
16225: LIST
16226: PPUSH
16227: CALL_OW 69
16231: PPUSH
16232: CALL 1001 0 1
16236: ST_TO_ADDR
// if place then
16237: LD_VAR 0 6
16241: IFFALSE 16259
// ComEnterUnit ( driver , place ) else
16243: LD_VAR 0 1
16247: PPUSH
16248: LD_VAR 0 6
16252: PPUSH
16253: CALL_OW 120
16257: GO 16274
// ComMoveXY ( driver , 70 , 22 ) ;
16259: LD_VAR 0 1
16263: PPUSH
16264: LD_INT 70
16266: PPUSH
16267: LD_INT 22
16269: PPUSH
16270: CALL_OW 111
// end ; end ;
16274: PPOPN 6
16276: END
// every 0 0$01 trigger not game_end and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) < 4 do
16277: LD_EXP 29
16281: NOT
16282: PUSH
16283: LD_INT 22
16285: PUSH
16286: LD_INT 1
16288: PUSH
16289: EMPTY
16290: LIST
16291: LIST
16292: PUSH
16293: LD_INT 21
16295: PUSH
16296: LD_INT 1
16298: PUSH
16299: EMPTY
16300: LIST
16301: LIST
16302: PUSH
16303: EMPTY
16304: LIST
16305: LIST
16306: PPUSH
16307: CALL_OW 69
16311: PUSH
16312: LD_INT 22
16314: PUSH
16315: LD_INT 8
16317: PUSH
16318: EMPTY
16319: LIST
16320: LIST
16321: PUSH
16322: LD_INT 21
16324: PUSH
16325: LD_INT 1
16327: PUSH
16328: EMPTY
16329: LIST
16330: LIST
16331: PUSH
16332: EMPTY
16333: LIST
16334: LIST
16335: PPUSH
16336: CALL_OW 69
16340: PLUS
16341: PUSH
16342: LD_INT 4
16344: LESS
16345: AND
16346: IFFALSE 16358
16348: GO 16350
16350: DISABLE
// YouLost ( 1 ) ;
16351: LD_STRING 1
16353: PPUSH
16354: CALL_OW 104
16358: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
16359: LD_INT 1
16361: PPUSH
16362: CALL_OW 255
16366: PUSH
16367: LD_INT 3
16369: EQUAL
16370: IFFALSE 16382
16372: GO 16374
16374: DISABLE
// YouLost ( 3 ) ;
16375: LD_STRING 3
16377: PPUSH
16378: CALL_OW 104
16382: END
