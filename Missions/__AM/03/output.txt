// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 339 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 427 0 0
// PrepareRussian ;
  22: CALL 2920 0 0
// PrepareAmerican ;
  26: CALL 1161 0 0
// PrepareCornell ;
  30: CALL 2185 0 0
// PrepareWesternBase ;
  34: CALL 2411 0 0
// Action ;
  38: CALL 4926 0 0
// end ;
  42: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := 1 ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 1
  53: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  54: LD_ADDR_EXP 3
  58: PUSH
  59: LD_STRING 02_
  61: ST_TO_ADDR
// mission_prefix := 03_ ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_STRING 03_
  69: ST_TO_ADDR
// jmm_units := 0 ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// cornel_units := 0 ;
  78: LD_ADDR_EXP 6
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// bierezov_exist := false ;
  86: LD_ADDR_EXP 7
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// jmm_on_west := false ;
  94: LD_ADDR_EXP 5
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_active := false ;
 102: LD_ADDR_EXP 8
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_attack := false ;
 110: LD_ADDR_EXP 9
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// cornel_prepared := false ;
 118: LD_ADDR_EXP 11
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 126: LD_ADDR_EXP 10
 130: PUSH
 131: LD_INT 4200
 133: ST_TO_ADDR
// frank_can_return := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// solar_builded := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// frank_send_to_scout := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// jmm_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// bobby_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// cyrus_in_veh := false ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// lisa_in_veh := false ;
 182: LD_ADDR_EXP 18
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 190: LD_ADDR_EXP 27
 194: PUSH
 195: LD_INT 25200
 197: PUSH
 198: LD_INT 23100
 200: PUSH
 201: LD_INT 21000
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: PUSH
 209: LD_OWVAR 67
 213: ARRAY
 214: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 215: LD_ADDR_EXP 19
 219: PUSH
 220: LD_INT 600
 222: PUSH
 223: LD_INT 500
 225: PUSH
 226: LD_INT 400
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: PUSH
 234: LD_OWVAR 67
 238: ARRAY
 239: ST_TO_ADDR
// end_mission_allowed := false ;
 240: LD_ADDR_EXP 20
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// save_others := [ ] ;
 248: LD_ADDR_EXP 21
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// save_group := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// show_query := true ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// wait_for_them := false ;
 270: LD_ADDR_EXP 24
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// veh_on_meta := false ;
 278: LD_ADDR_EXP 26
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_spec_patrol := false ;
 286: LD_ADDR_EXP 28
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// prepare_siege := false ;
 294: LD_ADDR_EXP 29
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// send_attack_on_cornel := false ;
 302: LD_ADDR_EXP 30
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 310: LD_ADDR_EXP 25
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// game_end := false ;
 318: LD_ADDR_EXP 31
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// lose_counter := 0 ;
 326: LD_ADDR_EXP 32
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// end ;
 334: LD_VAR 0 1
 338: RET
// function SetDiplomacy ; begin
 339: LD_INT 0
 341: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 342: LD_INT 1
 344: PPUSH
 345: LD_INT 4
 347: PPUSH
 348: LD_INT 1
 350: PPUSH
 351: LD_INT 1
 353: PPUSH
 354: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 358: LD_INT 1
 360: PPUSH
 361: LD_INT 8
 363: PPUSH
 364: LD_INT 1
 366: PPUSH
 367: LD_INT 1
 369: PPUSH
 370: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 374: LD_INT 3
 376: PPUSH
 377: LD_INT 6
 379: PPUSH
 380: LD_INT 1
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 390: LD_INT 4
 392: PPUSH
 393: LD_INT 6
 395: PPUSH
 396: LD_INT 0
 398: PPUSH
 399: LD_INT 1
 401: PPUSH
 402: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 406: LD_INT 3
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: LD_INT 0
 414: PPUSH
 415: LD_INT 1
 417: PPUSH
 418: CALL_OW 80
// end ;
 422: LD_VAR 0 1
 426: RET
// export function DebugMode ; var i ; begin
 427: LD_INT 0
 429: PPUSH
 430: PPUSH
// FogOff ( 1 ) ;
 431: LD_INT 1
 433: PPUSH
 434: CALL_OW 344
// debug_strings := [ ] ;
 438: LD_ADDR_OWVAR 48
 442: PUSH
 443: EMPTY
 444: ST_TO_ADDR
// end ; end_of_file
 445: LD_VAR 0 1
 449: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 450: LD_INT 0
 452: PPUSH
 453: PPUSH
// if exist_mode then
 454: LD_VAR 0 2
 458: IFFALSE 483
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 460: LD_ADDR_VAR 0 4
 464: PUSH
 465: LD_EXP 3
 469: PUSH
 470: LD_VAR 0 1
 474: STR
 475: PPUSH
 476: CALL_OW 34
 480: ST_TO_ADDR
 481: GO 498
// unit := NewCharacter ( ident ) ;
 483: LD_ADDR_VAR 0 4
 487: PUSH
 488: LD_VAR 0 1
 492: PPUSH
 493: CALL_OW 25
 497: ST_TO_ADDR
// result := unit ;
 498: LD_ADDR_VAR 0 3
 502: PUSH
 503: LD_VAR 0 4
 507: ST_TO_ADDR
// end ;
 508: LD_VAR 0 3
 512: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 513: LD_INT 0
 515: PPUSH
// uc_side := side ;
 516: LD_ADDR_OWVAR 20
 520: PUSH
 521: LD_VAR 0 1
 525: ST_TO_ADDR
// uc_nation := nation ;
 526: LD_ADDR_OWVAR 21
 530: PUSH
 531: LD_VAR 0 2
 535: ST_TO_ADDR
// vc_chassis := chassis ;
 536: LD_ADDR_OWVAR 37
 540: PUSH
 541: LD_VAR 0 3
 545: ST_TO_ADDR
// vc_engine := engine ;
 546: LD_ADDR_OWVAR 39
 550: PUSH
 551: LD_VAR 0 4
 555: ST_TO_ADDR
// vc_control := control ;
 556: LD_ADDR_OWVAR 38
 560: PUSH
 561: LD_VAR 0 5
 565: ST_TO_ADDR
// vc_weapon := weapon ;
 566: LD_ADDR_OWVAR 40
 570: PUSH
 571: LD_VAR 0 6
 575: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 576: LD_ADDR_OWVAR 41
 580: PUSH
 581: LD_VAR 0 7
 585: ST_TO_ADDR
// result := CreateVehicle ;
 586: LD_ADDR_VAR 0 8
 590: PUSH
 591: CALL_OW 45
 595: ST_TO_ADDR
// end ;
 596: LD_VAR 0 8
 600: RET
// export function SayX ( units , ident ) ; var i ; begin
 601: LD_INT 0
 603: PPUSH
 604: PPUSH
// result := false ;
 605: LD_ADDR_VAR 0 3
 609: PUSH
 610: LD_INT 0
 612: ST_TO_ADDR
// if not units then
 613: LD_VAR 0 1
 617: NOT
 618: IFFALSE 622
// exit ;
 620: GO 676
// for i in units do
 622: LD_ADDR_VAR 0 4
 626: PUSH
 627: LD_VAR 0 1
 631: PUSH
 632: FOR_IN
 633: IFFALSE 674
// if IsOk ( i ) then
 635: LD_VAR 0 4
 639: PPUSH
 640: CALL_OW 302
 644: IFFALSE 672
// begin Say ( i , ident ) ;
 646: LD_VAR 0 4
 650: PPUSH
 651: LD_VAR 0 2
 655: PPUSH
 656: CALL_OW 88
// result := i ;
 660: LD_ADDR_VAR 0 3
 664: PUSH
 665: LD_VAR 0 4
 669: ST_TO_ADDR
// break ;
 670: GO 674
// end ;
 672: GO 632
 674: POP
 675: POP
// end ;
 676: LD_VAR 0 3
 680: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 681: LD_INT 0
 683: PPUSH
 684: PPUSH
 685: PPUSH
 686: PPUSH
// for i = 1 to count do
 687: LD_ADDR_VAR 0 8
 691: PUSH
 692: DOUBLE
 693: LD_INT 1
 695: DEC
 696: ST_TO_ADDR
 697: LD_VAR 0 6
 701: PUSH
 702: FOR_TO
 703: IFFALSE 784
// begin uc_side = side ;
 705: LD_ADDR_OWVAR 20
 709: PUSH
 710: LD_VAR 0 1
 714: ST_TO_ADDR
// uc_nation = nation ;
 715: LD_ADDR_OWVAR 21
 719: PUSH
 720: LD_VAR 0 2
 724: ST_TO_ADDR
// hc_gallery =  ;
 725: LD_ADDR_OWVAR 33
 729: PUSH
 730: LD_STRING 
 732: ST_TO_ADDR
// hc_name =  ;
 733: LD_ADDR_OWVAR 26
 737: PUSH
 738: LD_STRING 
 740: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 741: LD_INT 0
 743: PPUSH
 744: LD_VAR 0 5
 748: PPUSH
 749: LD_VAR 0 4
 753: PPUSH
 754: CALL_OW 380
// un = CreateHuman ;
 758: LD_ADDR_VAR 0 10
 762: PUSH
 763: CALL_OW 44
 767: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 768: LD_VAR 0 10
 772: PPUSH
 773: LD_VAR 0 3
 777: PPUSH
 778: CALL_OW 52
// end ;
 782: GO 702
 784: POP
 785: POP
// end ;
 786: LD_VAR 0 7
 790: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 791: LD_INT 0
 793: PPUSH
 794: PPUSH
 795: PPUSH
// uc_side := GetSide ( b ) ;
 796: LD_ADDR_OWVAR 20
 800: PUSH
 801: LD_VAR 0 2
 805: PPUSH
 806: CALL_OW 255
 810: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 811: LD_ADDR_OWVAR 21
 815: PUSH
 816: LD_VAR 0 2
 820: PPUSH
 821: CALL_OW 248
 825: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 826: LD_INT 0
 828: PPUSH
 829: LD_INT 1
 831: PPUSH
 832: LD_VAR 0 1
 836: PPUSH
 837: CALL_OW 380
// un = CreateHuman ;
 841: LD_ADDR_VAR 0 4
 845: PUSH
 846: CALL_OW 44
 850: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 851: LD_ADDR_VAR 0 5
 855: PUSH
 856: LD_VAR 0 2
 860: PPUSH
 861: CALL_OW 254
 865: PUSH
 866: LD_INT 3
 868: MINUS
 869: ST_TO_ADDR
// if dir < 0 then
 870: LD_VAR 0 5
 874: PUSH
 875: LD_INT 0
 877: LESS
 878: IFFALSE 894
// dir := 6 + dir ;
 880: LD_ADDR_VAR 0 5
 884: PUSH
 885: LD_INT 6
 887: PUSH
 888: LD_VAR 0 5
 892: PLUS
 893: ST_TO_ADDR
// SetDir ( un , dir ) ;
 894: LD_VAR 0 4
 898: PPUSH
 899: LD_VAR 0 5
 903: PPUSH
 904: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 908: LD_VAR 0 4
 912: PPUSH
 913: LD_VAR 0 2
 917: PPUSH
 918: CALL_OW 52
// end ;
 922: LD_VAR 0 3
 926: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 927: LD_INT 0
 929: PPUSH
 930: PPUSH
 931: PPUSH
// result := false ;
 932: LD_ADDR_VAR 0 2
 936: PUSH
 937: LD_INT 0
 939: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 940: LD_ADDR_VAR 0 3
 944: PUSH
 945: LD_INT 22
 947: PUSH
 948: LD_INT 1
 950: PUSH
 951: EMPTY
 952: LIST
 953: LIST
 954: PUSH
 955: LD_INT 34
 957: PUSH
 958: LD_INT 2
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: PUSH
 965: EMPTY
 966: LIST
 967: LIST
 968: PPUSH
 969: CALL_OW 69
 973: ST_TO_ADDR
// for i in filter do
 974: LD_ADDR_VAR 0 4
 978: PUSH
 979: LD_VAR 0 3
 983: PUSH
 984: FOR_IN
 985: IFFALSE 1016
// if IsDrivenBy ( i ) = unit then
 987: LD_VAR 0 4
 991: PPUSH
 992: CALL_OW 311
 996: PUSH
 997: LD_VAR 0 1
1001: EQUAL
1002: IFFALSE 1014
// begin result := true ;
1004: LD_ADDR_VAR 0 2
1008: PUSH
1009: LD_INT 1
1011: ST_TO_ADDR
// break ;
1012: GO 1016
// end ;
1014: GO 984
1016: POP
1017: POP
// end ;
1018: LD_VAR 0 2
1022: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1023: LD_INT 0
1025: PPUSH
1026: PPUSH
// result := false ;
1027: LD_ADDR_VAR 0 2
1031: PUSH
1032: LD_INT 0
1034: ST_TO_ADDR
// if not blist then
1035: LD_VAR 0 1
1039: NOT
1040: IFFALSE 1044
// exit ;
1042: GO 1088
// for i in blist do
1044: LD_ADDR_VAR 0 3
1048: PUSH
1049: LD_VAR 0 1
1053: PUSH
1054: FOR_IN
1055: IFFALSE 1086
// if UnitsInside ( i ) < 6 then
1057: LD_VAR 0 3
1061: PPUSH
1062: CALL_OW 313
1066: PUSH
1067: LD_INT 6
1069: LESS
1070: IFFALSE 1084
// begin result := i ;
1072: LD_ADDR_VAR 0 2
1076: PUSH
1077: LD_VAR 0 3
1081: ST_TO_ADDR
// break ;
1082: GO 1086
// end ;
1084: GO 1054
1086: POP
1087: POP
// end ;
1088: LD_VAR 0 2
1092: RET
// export function Count ( timer , mode ) ; begin
1093: LD_INT 0
1095: PPUSH
// if not timer then
1096: LD_VAR 0 1
1100: NOT
1101: IFFALSE 1105
// exit ;
1103: GO 1156
// if mode in [ asc , up , + ] then
1105: LD_VAR 0 2
1109: PUSH
1110: LD_STRING asc
1112: PUSH
1113: LD_STRING up
1115: PUSH
1116: LD_STRING +
1118: PUSH
1119: EMPTY
1120: LIST
1121: LIST
1122: LIST
1123: IN
1124: IFFALSE 1142
// result := timer + 0 0$01 else
1126: LD_ADDR_VAR 0 3
1130: PUSH
1131: LD_VAR 0 1
1135: PUSH
1136: LD_INT 35
1138: PLUS
1139: ST_TO_ADDR
1140: GO 1156
// result := timer - 0 0$01 ;
1142: LD_ADDR_VAR 0 3
1146: PUSH
1147: LD_VAR 0 1
1151: PUSH
1152: LD_INT 35
1154: MINUS
1155: ST_TO_ADDR
// end ; end_of_file
1156: LD_VAR 0 3
1160: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1161: LD_INT 0
1163: PPUSH
1164: PPUSH
1165: PPUSH
1166: PPUSH
1167: PPUSH
1168: PPUSH
1169: PPUSH
1170: PPUSH
// uc_side := 4 ;
1171: LD_ADDR_OWVAR 20
1175: PUSH
1176: LD_INT 4
1178: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1179: LD_ADDR_EXP 42
1183: PUSH
1184: LD_STRING Powell
1186: PPUSH
1187: LD_INT 0
1189: PPUSH
1190: CALL 450 0 2
1194: ST_TO_ADDR
// uc_side := 1 ;
1195: LD_ADDR_OWVAR 20
1199: PUSH
1200: LD_INT 1
1202: ST_TO_ADDR
// uc_nation := 1 ;
1203: LD_ADDR_OWVAR 21
1207: PUSH
1208: LD_INT 1
1210: ST_TO_ADDR
// if debug then
1211: LD_EXP 1
1215: IFFALSE 1345
// begin for i = 1 to 4 do
1217: LD_ADDR_VAR 0 2
1221: PUSH
1222: DOUBLE
1223: LD_INT 1
1225: DEC
1226: ST_TO_ADDR
1227: LD_INT 4
1229: PUSH
1230: FOR_TO
1231: IFFALSE 1282
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1233: LD_INT 0
1235: PPUSH
1236: LD_INT 1
1238: PPUSH
1239: LD_INT 2
1241: PPUSH
1242: CALL_OW 12
1246: PPUSH
1247: LD_INT 3
1249: PPUSH
1250: CALL_OW 380
// un := CreateHuman ;
1254: LD_ADDR_VAR 0 3
1258: PUSH
1259: CALL_OW 44
1263: ST_TO_ADDR
// others := others ^ un ;
1264: LD_ADDR_VAR 0 5
1268: PUSH
1269: LD_VAR 0 5
1273: PUSH
1274: LD_VAR 0 3
1278: ADD
1279: ST_TO_ADDR
// end ;
1280: GO 1230
1282: POP
1283: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1284: LD_ADDR_VAR 0 6
1288: PUSH
1289: LD_INT 21
1291: PUSH
1292: LD_INT 1
1294: PUSH
1295: LD_INT 1
1297: PUSH
1298: LD_INT 51
1300: PUSH
1301: LD_INT 90
1303: PUSH
1304: LD_INT 504
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: PUSH
1315: LD_INT 21
1317: PUSH
1318: LD_INT 1
1320: PUSH
1321: LD_INT 1
1323: PUSH
1324: LD_INT 51
1326: PUSH
1327: LD_INT 80
1329: PUSH
1330: LD_INT 750
1332: PUSH
1333: EMPTY
1334: LIST
1335: LIST
1336: LIST
1337: LIST
1338: LIST
1339: LIST
1340: PUSH
1341: EMPTY
1342: LIST
1343: LIST
1344: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1345: LD_ADDR_EXP 33
1349: PUSH
1350: LD_STRING JMM
1352: PPUSH
1353: LD_EXP 1
1357: NOT
1358: PPUSH
1359: CALL 450 0 2
1363: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1364: LD_ADDR_EXP 34
1368: PUSH
1369: LD_STRING Bobby
1371: PPUSH
1372: LD_EXP 1
1376: NOT
1377: PPUSH
1378: CALL 450 0 2
1382: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1383: LD_ADDR_EXP 35
1387: PUSH
1388: LD_STRING Cyrus
1390: PPUSH
1391: LD_EXP 1
1395: NOT
1396: PPUSH
1397: CALL 450 0 2
1401: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1402: LD_ADDR_EXP 36
1406: PUSH
1407: LD_STRING Lisa
1409: PPUSH
1410: LD_EXP 1
1414: NOT
1415: PPUSH
1416: CALL 450 0 2
1420: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1421: LD_ADDR_EXP 37
1425: PUSH
1426: LD_STRING Khatam
1428: PPUSH
1429: LD_EXP 1
1433: NOT
1434: PPUSH
1435: CALL 450 0 2
1439: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1440: LD_ADDR_EXP 38
1444: PUSH
1445: LD_STRING Brian
1447: PPUSH
1448: LD_EXP 1
1452: NOT
1453: PPUSH
1454: CALL 450 0 2
1458: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1459: LD_ADDR_EXP 39
1463: PUSH
1464: LD_STRING Jerry
1466: PPUSH
1467: LD_EXP 1
1471: NOT
1472: PPUSH
1473: CALL 450 0 2
1477: ST_TO_ADDR
// if Bobby then
1478: LD_EXP 34
1482: IFFALSE 1513
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1484: LD_ADDR_VAR 0 4
1488: PUSH
1489: LD_VAR 0 4
1493: PPUSH
1494: LD_VAR 0 4
1498: PUSH
1499: LD_INT 1
1501: PLUS
1502: PPUSH
1503: LD_EXP 34
1507: PPUSH
1508: CALL_OW 2
1512: ST_TO_ADDR
// if Cyrus then
1513: LD_EXP 35
1517: IFFALSE 1548
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1519: LD_ADDR_VAR 0 4
1523: PUSH
1524: LD_VAR 0 4
1528: PPUSH
1529: LD_VAR 0 4
1533: PUSH
1534: LD_INT 1
1536: PLUS
1537: PPUSH
1538: LD_EXP 35
1542: PPUSH
1543: CALL_OW 2
1547: ST_TO_ADDR
// if Lisa then
1548: LD_EXP 36
1552: IFFALSE 1583
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1554: LD_ADDR_VAR 0 4
1558: PUSH
1559: LD_VAR 0 4
1563: PPUSH
1564: LD_VAR 0 4
1568: PUSH
1569: LD_INT 1
1571: PLUS
1572: PPUSH
1573: LD_EXP 36
1577: PPUSH
1578: CALL_OW 2
1582: ST_TO_ADDR
// if Khatam then
1583: LD_EXP 37
1587: IFFALSE 1618
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1589: LD_ADDR_VAR 0 4
1593: PUSH
1594: LD_VAR 0 4
1598: PPUSH
1599: LD_VAR 0 4
1603: PUSH
1604: LD_INT 1
1606: PLUS
1607: PPUSH
1608: LD_EXP 37
1612: PPUSH
1613: CALL_OW 2
1617: ST_TO_ADDR
// if Brian then
1618: LD_EXP 38
1622: IFFALSE 1653
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1624: LD_ADDR_VAR 0 4
1628: PUSH
1629: LD_VAR 0 4
1633: PPUSH
1634: LD_VAR 0 4
1638: PUSH
1639: LD_INT 1
1641: PLUS
1642: PPUSH
1643: LD_EXP 38
1647: PPUSH
1648: CALL_OW 2
1652: ST_TO_ADDR
// if Jerry then
1653: LD_EXP 39
1657: IFFALSE 1688
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1659: LD_ADDR_VAR 0 4
1663: PUSH
1664: LD_VAR 0 4
1668: PPUSH
1669: LD_VAR 0 4
1673: PUSH
1674: LD_INT 1
1676: PLUS
1677: PPUSH
1678: LD_EXP 39
1682: PPUSH
1683: CALL_OW 2
1687: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1688: LD_STRING 02_other_survivors
1690: PPUSH
1691: CALL_OW 28
1695: IFFALSE 1710
// others := CreateCharacterSet ( 02_other_survivors ) ;
1697: LD_ADDR_VAR 0 5
1701: PUSH
1702: LD_STRING 02_other_survivors
1704: PPUSH
1705: CALL_OW 31
1709: ST_TO_ADDR
// if others then
1710: LD_VAR 0 5
1714: IFFALSE 1739
// begin tmp := tmp ^ others ;
1716: LD_ADDR_VAR 0 4
1720: PUSH
1721: LD_VAR 0 4
1725: PUSH
1726: LD_VAR 0 5
1730: ADD
1731: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1732: LD_STRING 02_other_survivors
1734: PPUSH
1735: CALL_OW 40
// end ; jmm_units := tmp ;
1739: LD_ADDR_EXP 4
1743: PUSH
1744: LD_VAR 0 4
1748: ST_TO_ADDR
// if not vehicles then
1749: LD_VAR 0 6
1753: NOT
1754: IFFALSE 1772
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1756: LD_ADDR_VAR 0 6
1760: PUSH
1761: LD_STRING 02_tanks_1
1763: PPUSH
1764: LD_INT 0
1766: PPUSH
1767: CALL_OW 30
1771: ST_TO_ADDR
// if vehicles then
1772: LD_VAR 0 6
1776: IFFALSE 1970
// begin got_mech := false ;
1778: LD_ADDR_VAR 0 7
1782: PUSH
1783: LD_INT 0
1785: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1786: LD_VAR 0 4
1790: PPUSH
1791: LD_INT 25
1793: PUSH
1794: LD_INT 3
1796: PUSH
1797: EMPTY
1798: LIST
1799: LIST
1800: PPUSH
1801: CALL_OW 72
1805: IFFALSE 1815
// got_mech := true ;
1807: LD_ADDR_VAR 0 7
1811: PUSH
1812: LD_INT 1
1814: ST_TO_ADDR
// for i = 1 to vehicles do
1815: LD_ADDR_VAR 0 2
1819: PUSH
1820: DOUBLE
1821: LD_INT 1
1823: DEC
1824: ST_TO_ADDR
1825: LD_VAR 0 6
1829: PUSH
1830: FOR_TO
1831: IFFALSE 1968
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1833: LD_ADDR_VAR 0 3
1837: PUSH
1838: LD_INT 1
1840: PPUSH
1841: LD_INT 3
1843: PPUSH
1844: LD_VAR 0 6
1848: PUSH
1849: LD_VAR 0 2
1853: ARRAY
1854: PUSH
1855: LD_INT 1
1857: ARRAY
1858: PPUSH
1859: LD_VAR 0 6
1863: PUSH
1864: LD_VAR 0 2
1868: ARRAY
1869: PUSH
1870: LD_INT 2
1872: ARRAY
1873: PPUSH
1874: LD_VAR 0 6
1878: PUSH
1879: LD_VAR 0 2
1883: ARRAY
1884: PUSH
1885: LD_INT 3
1887: ARRAY
1888: PPUSH
1889: LD_VAR 0 6
1893: PUSH
1894: LD_VAR 0 2
1898: ARRAY
1899: PUSH
1900: LD_INT 4
1902: ARRAY
1903: PPUSH
1904: LD_INT 40
1906: PPUSH
1907: CALL 513 0 7
1911: ST_TO_ADDR
// if not got_mech then
1912: LD_VAR 0 7
1916: NOT
1917: IFFALSE 1943
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1919: LD_VAR 0 3
1923: PPUSH
1924: LD_VAR 0 6
1928: PUSH
1929: LD_VAR 0 2
1933: ARRAY
1934: PUSH
1935: LD_INT 6
1937: ARRAY
1938: PPUSH
1939: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1943: LD_ADDR_VAR 0 4
1947: PUSH
1948: LD_VAR 0 4
1952: PPUSH
1953: LD_INT 1
1955: PPUSH
1956: LD_VAR 0 3
1960: PPUSH
1961: CALL_OW 2
1965: ST_TO_ADDR
// end ;
1966: GO 1830
1968: POP
1969: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1970: LD_EXP 33
1974: PPUSH
1975: LD_INT 194
1977: PPUSH
1978: LD_INT 119
1980: PPUSH
1981: LD_INT 0
1983: PPUSH
1984: CALL_OW 48
// if tmp then
1988: LD_VAR 0 4
1992: IFFALSE 2117
// begin for i in tmp do
1994: LD_ADDR_VAR 0 2
1998: PUSH
1999: LD_VAR 0 4
2003: PUSH
2004: FOR_IN
2005: IFFALSE 2115
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2007: LD_ADDR_VAR 0 8
2011: PUSH
2012: LD_INT 22
2014: PUSH
2015: LD_INT 1
2017: PUSH
2018: EMPTY
2019: LIST
2020: LIST
2021: PUSH
2022: LD_INT 21
2024: PUSH
2025: LD_INT 2
2027: PUSH
2028: EMPTY
2029: LIST
2030: LIST
2031: PUSH
2032: LD_INT 58
2034: PUSH
2035: EMPTY
2036: LIST
2037: PUSH
2038: EMPTY
2039: LIST
2040: LIST
2041: LIST
2042: PPUSH
2043: CALL_OW 69
2047: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2048: LD_VAR 0 2
2052: PPUSH
2053: CALL_OW 247
2057: PUSH
2058: LD_INT 1
2060: EQUAL
2061: PUSH
2062: LD_VAR 0 8
2066: AND
2067: IFFALSE 2089
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2069: LD_VAR 0 2
2073: PPUSH
2074: LD_VAR 0 8
2078: PUSH
2079: LD_INT 1
2081: ARRAY
2082: PPUSH
2083: CALL_OW 52
2087: GO 2104
// PlaceUnitArea ( i , startArea , false ) ;
2089: LD_VAR 0 2
2093: PPUSH
2094: LD_INT 1
2096: PPUSH
2097: LD_INT 0
2099: PPUSH
2100: CALL_OW 49
// ComHold ( i ) ;
2104: LD_VAR 0 2
2108: PPUSH
2109: CALL_OW 140
// end ;
2113: GO 2004
2115: POP
2116: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2117: LD_ADDR_EXP 7
2121: PUSH
2122: LD_STRING 02_mikhailStatus_1
2124: PPUSH
2125: LD_INT 0
2127: PPUSH
2128: CALL_OW 30
2132: ST_TO_ADDR
// if not bierezov_exist and not debug then
2133: LD_EXP 7
2137: NOT
2138: PUSH
2139: LD_EXP 1
2143: NOT
2144: AND
2145: IFFALSE 2149
// exit ;
2147: GO 2180
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2149: LD_ADDR_EXP 41
2153: PUSH
2154: LD_STRING Mikhail
2156: PPUSH
2157: LD_INT 0
2159: PPUSH
2160: CALL 450 0 2
2164: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2165: LD_EXP 41
2169: PPUSH
2170: LD_INT 1
2172: PPUSH
2173: LD_INT 0
2175: PPUSH
2176: CALL_OW 49
// end ;
2180: LD_VAR 0 1
2184: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2185: LD_INT 0
2187: PPUSH
2188: PPUSH
2189: PPUSH
2190: PPUSH
// uc_side := 4 ;
2191: LD_ADDR_OWVAR 20
2195: PUSH
2196: LD_INT 4
2198: ST_TO_ADDR
// uc_nation := 1 ;
2199: LD_ADDR_OWVAR 21
2203: PUSH
2204: LD_INT 1
2206: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2207: LD_ADDR_EXP 40
2211: PUSH
2212: LD_STRING Cornell
2214: PPUSH
2215: LD_INT 0
2217: PPUSH
2218: CALL 450 0 2
2222: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
2223: LD_ADDR_EXP 6
2227: PUSH
2228: LD_INT 8
2230: PUSH
2231: LD_EXP 4
2235: MINUS
2236: ST_TO_ADDR
// tmp := [ ] ;
2237: LD_ADDR_VAR 0 2
2241: PUSH
2242: EMPTY
2243: ST_TO_ADDR
// if cornel_units < 3 then
2244: LD_EXP 6
2248: PUSH
2249: LD_INT 3
2251: LESS
2252: IFFALSE 2262
// cornel_units := 3 ;
2254: LD_ADDR_EXP 6
2258: PUSH
2259: LD_INT 3
2261: ST_TO_ADDR
// for i = 1 to cornel_units do
2262: LD_ADDR_VAR 0 4
2266: PUSH
2267: DOUBLE
2268: LD_INT 1
2270: DEC
2271: ST_TO_ADDR
2272: LD_EXP 6
2276: PUSH
2277: FOR_TO
2278: IFFALSE 2376
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2280: LD_INT 0
2282: PPUSH
2283: LD_INT 1
2285: PUSH
2286: LD_INT 1
2288: PUSH
2289: LD_INT 1
2291: PUSH
2292: LD_INT 2
2294: PUSH
2295: LD_INT 4
2297: PUSH
2298: EMPTY
2299: LIST
2300: LIST
2301: LIST
2302: LIST
2303: LIST
2304: PUSH
2305: LD_VAR 0 4
2309: PUSH
2310: LD_INT 5
2312: MOD
2313: PUSH
2314: LD_INT 1
2316: PLUS
2317: ARRAY
2318: PPUSH
2319: LD_INT 2
2321: PPUSH
2322: CALL_OW 380
// un := CreateHuman ;
2326: LD_ADDR_VAR 0 3
2330: PUSH
2331: CALL_OW 44
2335: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2336: LD_ADDR_VAR 0 2
2340: PUSH
2341: LD_VAR 0 2
2345: PPUSH
2346: LD_INT 1
2348: PPUSH
2349: LD_VAR 0 3
2353: PPUSH
2354: CALL_OW 2
2358: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2359: LD_VAR 0 3
2363: PPUSH
2364: LD_INT 2
2366: PPUSH
2367: LD_INT 0
2369: PPUSH
2370: CALL_OW 49
// end ;
2374: GO 2277
2376: POP
2377: POP
// cornel_units := tmp ;
2378: LD_ADDR_EXP 6
2382: PUSH
2383: LD_VAR 0 2
2387: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2388: LD_EXP 40
2392: PPUSH
2393: LD_INT 191
2395: PPUSH
2396: LD_INT 106
2398: PPUSH
2399: LD_INT 0
2401: PPUSH
2402: CALL_OW 48
// end ;
2406: LD_VAR 0 1
2410: RET
// export function PrepareWesternBase ; var i ; begin
2411: LD_INT 0
2413: PPUSH
2414: PPUSH
// uc_side := 8 ;
2415: LD_ADDR_OWVAR 20
2419: PUSH
2420: LD_INT 8
2422: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2423: LD_ADDR_EXP 43
2427: PUSH
2428: LD_STRING Lynch
2430: PPUSH
2431: LD_INT 0
2433: PPUSH
2434: CALL 450 0 2
2438: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2439: LD_ADDR_EXP 44
2443: PUSH
2444: LD_STRING Walker
2446: PPUSH
2447: LD_INT 0
2449: PPUSH
2450: CALL 450 0 2
2454: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2455: LD_ADDR_EXP 45
2459: PUSH
2460: LD_STRING Turner
2462: PPUSH
2463: LD_INT 0
2465: PPUSH
2466: CALL 450 0 2
2470: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2471: LD_ADDR_EXP 46
2475: PUSH
2476: LD_STRING Jillian
2478: PPUSH
2479: LD_INT 0
2481: PPUSH
2482: CALL 450 0 2
2486: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2487: LD_ADDR_VAR 0 2
2491: PUSH
2492: LD_EXP 43
2496: PUSH
2497: LD_EXP 44
2501: PUSH
2502: LD_EXP 45
2506: PUSH
2507: LD_EXP 46
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: LIST
2516: LIST
2517: PUSH
2518: FOR_IN
2519: IFFALSE 2547
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2521: LD_VAR 0 2
2525: PPUSH
2526: LD_INT 3
2528: PPUSH
2529: LD_INT 0
2531: PPUSH
2532: CALL_OW 49
// ComHold ( i ) ;
2536: LD_VAR 0 2
2540: PPUSH
2541: CALL_OW 140
// end ;
2545: GO 2518
2547: POP
2548: POP
// end ;
2549: LD_VAR 0 1
2553: RET
// export function SelectGroup ; var units , selected , i ; begin
2554: LD_INT 0
2556: PPUSH
2557: PPUSH
2558: PPUSH
2559: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2560: LD_ADDR_VAR 0 2
2564: PUSH
2565: LD_EXP 33
2569: PUSH
2570: LD_INT -3
2572: PUSH
2573: EMPTY
2574: LIST
2575: LIST
2576: PUSH
2577: LD_EXP 4
2581: ADD
2582: PUSH
2583: LD_INT -2
2585: PUSH
2586: LD_INT -4
2588: PUSH
2589: LD_EXP 40
2593: PUSH
2594: LD_EXP 41
2598: PUSH
2599: EMPTY
2600: LIST
2601: LIST
2602: LIST
2603: LIST
2604: ADD
2605: PUSH
2606: LD_INT -3
2608: PUSH
2609: EMPTY
2610: LIST
2611: ADD
2612: PUSH
2613: LD_EXP 6
2617: ADD
2618: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2619: LD_ADDR_VAR 0 3
2623: PUSH
2624: LD_EXP 33
2628: PUSH
2629: LD_STRING Select five characters to go with you
2631: PPUSH
2632: LD_INT 4
2634: PPUSH
2635: LD_INT 4
2637: PPUSH
2638: LD_VAR 0 2
2642: PPUSH
2643: EMPTY
2644: PPUSH
2645: CALL_OW 42
2649: ADD
2650: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2651: LD_ADDR_EXP 6
2655: PUSH
2656: LD_EXP 4
2660: PUSH
2661: LD_EXP 6
2665: UNION
2666: PUSH
2667: LD_VAR 0 3
2671: DIFF
2672: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2673: LD_ADDR_VAR 0 4
2677: PUSH
2678: LD_EXP 6
2682: PUSH
2683: LD_EXP 41
2687: ADD
2688: PUSH
2689: FOR_IN
2690: IFFALSE 2721
// if GetSide ( i ) = 1 then
2692: LD_VAR 0 4
2696: PPUSH
2697: CALL_OW 255
2701: PUSH
2702: LD_INT 1
2704: EQUAL
2705: IFFALSE 2719
// SetSide ( i , 4 ) ;
2707: LD_VAR 0 4
2711: PPUSH
2712: LD_INT 4
2714: PPUSH
2715: CALL_OW 235
2719: GO 2689
2721: POP
2722: POP
// for i in selected do
2723: LD_ADDR_VAR 0 4
2727: PUSH
2728: LD_VAR 0 3
2732: PUSH
2733: FOR_IN
2734: IFFALSE 2765
// if GetSide ( i ) = 4 then
2736: LD_VAR 0 4
2740: PPUSH
2741: CALL_OW 255
2745: PUSH
2746: LD_INT 4
2748: EQUAL
2749: IFFALSE 2763
// SetSide ( i , 1 ) ;
2751: LD_VAR 0 4
2755: PPUSH
2756: LD_INT 1
2758: PPUSH
2759: CALL_OW 235
2763: GO 2733
2765: POP
2766: POP
// jmm_units := jmm_units diff cornel_units ;
2767: LD_ADDR_EXP 4
2771: PUSH
2772: LD_EXP 4
2776: PUSH
2777: LD_EXP 6
2781: DIFF
2782: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2783: LD_EXP 34
2787: PPUSH
2788: CALL_OW 255
2792: PUSH
2793: LD_INT 4
2795: EQUAL
2796: IFFALSE 2805
// DeleteCharacters ( Bobby ) ;
2798: LD_STRING Bobby
2800: PPUSH
2801: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2805: LD_EXP 35
2809: PPUSH
2810: CALL_OW 255
2814: PUSH
2815: LD_INT 4
2817: EQUAL
2818: IFFALSE 2827
// DeleteCharacters ( Cyrus ) ;
2820: LD_STRING Cyrus
2822: PPUSH
2823: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2827: LD_EXP 36
2831: PPUSH
2832: CALL_OW 255
2836: PUSH
2837: LD_INT 4
2839: EQUAL
2840: IFFALSE 2849
// DeleteCharacters ( Lisa ) ;
2842: LD_STRING Lisa
2844: PPUSH
2845: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2849: LD_EXP 37
2853: PPUSH
2854: CALL_OW 255
2858: PUSH
2859: LD_INT 4
2861: EQUAL
2862: IFFALSE 2871
// DeleteCharacters ( Khatam ) ;
2864: LD_STRING Khatam
2866: PPUSH
2867: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2871: LD_EXP 38
2875: PPUSH
2876: CALL_OW 255
2880: PUSH
2881: LD_INT 4
2883: EQUAL
2884: IFFALSE 2893
// DeleteCharacters ( Brian ) ;
2886: LD_STRING Brian
2888: PPUSH
2889: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2893: LD_EXP 39
2897: PPUSH
2898: CALL_OW 255
2902: PUSH
2903: LD_INT 4
2905: EQUAL
2906: IFFALSE 2915
// DeleteCharacters ( Jerry ) ;
2908: LD_STRING Jerry
2910: PPUSH
2911: CALL_OW 40
// end ; end_of_file
2915: LD_VAR 0 1
2919: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
2920: LD_INT 0
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
2930: PPUSH
2931: PPUSH
2932: PPUSH
2933: PPUSH
2934: PPUSH
// ru_alert := false ;
2935: LD_ADDR_EXP 56
2939: PUSH
2940: LD_INT 0
2942: ST_TO_ADDR
// ru_produce_list := [ ] ;
2943: LD_ADDR_EXP 53
2947: PUSH
2948: EMPTY
2949: ST_TO_ADDR
// if Difficulty > 1 then
2950: LD_OWVAR 67
2954: PUSH
2955: LD_INT 1
2957: GREATER
2958: IFFALSE 3046
// begin uc_side := 3 ;
2960: LD_ADDR_OWVAR 20
2964: PUSH
2965: LD_INT 3
2967: ST_TO_ADDR
// uc_nation := 3 ;
2968: LD_ADDR_OWVAR 21
2972: PUSH
2973: LD_INT 3
2975: ST_TO_ADDR
// bc_type := b_breastwork ;
2976: LD_ADDR_OWVAR 42
2980: PUSH
2981: LD_INT 31
2983: ST_TO_ADDR
// bc_level := Difficulty ;
2984: LD_ADDR_OWVAR 43
2988: PUSH
2989: LD_OWVAR 67
2993: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
2994: LD_INT 22
2996: PPUSH
2997: LD_INT 14
2999: PPUSH
3000: LD_INT 0
3002: PPUSH
3003: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3007: LD_INT 48
3009: PPUSH
3010: LD_INT 46
3012: PPUSH
3013: LD_INT 0
3015: PPUSH
3016: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3020: LD_INT 86
3022: PPUSH
3023: LD_INT 65
3025: PPUSH
3026: LD_INT 5
3028: PPUSH
3029: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3033: LD_INT 165
3035: PPUSH
3036: LD_INT 73
3038: PPUSH
3039: LD_INT 5
3041: PPUSH
3042: CALL_OW 47
// end ; tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3046: LD_ADDR_VAR 0 7
3050: PUSH
3051: LD_INT 22
3053: PUSH
3054: LD_INT 3
3056: PUSH
3057: EMPTY
3058: LIST
3059: LIST
3060: PUSH
3061: LD_INT 2
3063: PUSH
3064: LD_INT 30
3066: PUSH
3067: LD_INT 31
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: PUSH
3074: LD_INT 30
3076: PUSH
3077: LD_INT 32
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: PUSH
3084: EMPTY
3085: LIST
3086: LIST
3087: LIST
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: PPUSH
3093: CALL_OW 69
3097: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3098: LD_ADDR_VAR 0 8
3102: PUSH
3103: LD_INT 22
3105: PUSH
3106: LD_INT 3
3108: PUSH
3109: EMPTY
3110: LIST
3111: LIST
3112: PUSH
3113: LD_INT 30
3115: PUSH
3116: LD_INT 4
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: PUSH
3123: EMPTY
3124: LIST
3125: LIST
3126: PPUSH
3127: CALL_OW 69
3131: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3132: LD_ADDR_VAR 0 10
3136: PUSH
3137: LD_INT 22
3139: PUSH
3140: LD_INT 3
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: PUSH
3147: LD_INT 30
3149: PUSH
3150: LD_INT 3
3152: PUSH
3153: EMPTY
3154: LIST
3155: LIST
3156: PUSH
3157: EMPTY
3158: LIST
3159: LIST
3160: PPUSH
3161: CALL_OW 69
3165: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3166: LD_ADDR_VAR 0 9
3170: PUSH
3171: LD_INT 22
3173: PUSH
3174: LD_INT 3
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: PUSH
3181: LD_INT 30
3183: PUSH
3184: LD_INT 6
3186: PUSH
3187: EMPTY
3188: LIST
3189: LIST
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PPUSH
3195: CALL_OW 69
3199: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3200: LD_ADDR_VAR 0 2
3204: PUSH
3205: LD_INT 22
3207: PUSH
3208: LD_INT 3
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: PUSH
3215: LD_INT 30
3217: PUSH
3218: LD_INT 1
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: PPUSH
3229: CALL_OW 69
3233: PUSH
3234: FOR_IN
3235: IFFALSE 3279
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3237: LD_VAR 0 2
3241: PPUSH
3242: CALL_OW 274
3246: PPUSH
3247: LD_INT 1
3249: PPUSH
3250: LD_INT 5000
3252: PPUSH
3253: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3257: LD_VAR 0 2
3261: PPUSH
3262: CALL_OW 274
3266: PPUSH
3267: LD_INT 2
3269: PPUSH
3270: LD_INT 3000
3272: PPUSH
3273: CALL_OW 277
// end ;
3277: GO 3234
3279: POP
3280: POP
// uc_side := 3 ;
3281: LD_ADDR_OWVAR 20
3285: PUSH
3286: LD_INT 3
3288: ST_TO_ADDR
// uc_nation := 3 ;
3289: LD_ADDR_OWVAR 21
3293: PUSH
3294: LD_INT 3
3296: ST_TO_ADDR
// skill := [ 2 , 2 , 3 ] [ Difficulty ] ;
3297: LD_ADDR_VAR 0 11
3301: PUSH
3302: LD_INT 2
3304: PUSH
3305: LD_INT 2
3307: PUSH
3308: LD_INT 3
3310: PUSH
3311: EMPTY
3312: LIST
3313: LIST
3314: LIST
3315: PUSH
3316: LD_OWVAR 67
3320: ARRAY
3321: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3322: LD_ADDR_EXP 48
3326: PUSH
3327: LD_STRING Pokryshkin
3329: PPUSH
3330: LD_INT 0
3332: PPUSH
3333: CALL 450 0 2
3337: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3338: LD_EXP 48
3342: PPUSH
3343: LD_INT 63
3345: PPUSH
3346: LD_INT 21
3348: PPUSH
3349: LD_INT 0
3351: PPUSH
3352: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3356: LD_EXP 48
3360: PPUSH
3361: CALL_OW 140
// InitHc ;
3365: CALL_OW 19
// for i in fac do
3369: LD_ADDR_VAR 0 2
3373: PUSH
3374: LD_VAR 0 10
3378: PUSH
3379: FOR_IN
3380: IFFALSE 3433
// begin for j = 1 to 6 do
3382: LD_ADDR_VAR 0 3
3386: PUSH
3387: DOUBLE
3388: LD_INT 1
3390: DEC
3391: ST_TO_ADDR
3392: LD_INT 6
3394: PUSH
3395: FOR_TO
3396: IFFALSE 3429
// begin PrepareHuman ( false , 3 , skill ) ;
3398: LD_INT 0
3400: PPUSH
3401: LD_INT 3
3403: PPUSH
3404: LD_VAR 0 11
3408: PPUSH
3409: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3413: CALL_OW 44
3417: PPUSH
3418: LD_VAR 0 2
3422: PPUSH
3423: CALL_OW 52
// end ;
3427: GO 3395
3429: POP
3430: POP
// end ;
3431: GO 3379
3433: POP
3434: POP
// for i in lab do
3435: LD_ADDR_VAR 0 2
3439: PUSH
3440: LD_VAR 0 9
3444: PUSH
3445: FOR_IN
3446: IFFALSE 3479
// begin PrepareHuman ( false , 4 , skill ) ;
3448: LD_INT 0
3450: PPUSH
3451: LD_INT 4
3453: PPUSH
3454: LD_VAR 0 11
3458: PPUSH
3459: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3463: CALL_OW 44
3467: PPUSH
3468: LD_VAR 0 2
3472: PPUSH
3473: CALL_OW 52
// end ;
3477: GO 3445
3479: POP
3480: POP
// for i in tw do
3481: LD_ADDR_VAR 0 2
3485: PUSH
3486: LD_VAR 0 7
3490: PUSH
3491: FOR_IN
3492: IFFALSE 3541
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3494: LD_VAR 0 2
3498: PPUSH
3499: LD_INT 42
3501: PUSH
3502: LD_INT 43
3504: PUSH
3505: EMPTY
3506: LIST
3507: LIST
3508: PUSH
3509: LD_INT 1
3511: PPUSH
3512: LD_INT 2
3514: PPUSH
3515: CALL_OW 12
3519: ARRAY
3520: PPUSH
3521: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3525: LD_VAR 0 11
3529: PPUSH
3530: LD_VAR 0 2
3534: PPUSH
3535: CALL 791 0 2
// end ;
3539: GO 3491
3541: POP
3542: POP
// for i in bar do
3543: LD_ADDR_VAR 0 2
3547: PUSH
3548: LD_VAR 0 8
3552: PUSH
3553: FOR_IN
3554: IFFALSE 3587
// begin PrepareHuman ( false , 1 , skill ) ;
3556: LD_INT 0
3558: PPUSH
3559: LD_INT 1
3561: PPUSH
3562: LD_VAR 0 11
3566: PPUSH
3567: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3571: CALL_OW 44
3575: PPUSH
3576: LD_VAR 0 2
3580: PPUSH
3581: CALL_OW 52
// end ;
3585: GO 3553
3587: POP
3588: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3589: LD_ADDR_VAR 0 13
3593: PUSH
3594: LD_INT 100
3596: PUSH
3597: LD_INT 9
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: PUSH
3604: LD_INT 135
3606: PUSH
3607: LD_INT 60
3609: PUSH
3610: EMPTY
3611: LIST
3612: LIST
3613: PUSH
3614: LD_INT 41
3616: PUSH
3617: LD_INT 6
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: PUSH
3624: LD_INT 22
3626: PUSH
3627: LD_INT 9
3629: PUSH
3630: EMPTY
3631: LIST
3632: LIST
3633: PUSH
3634: LD_INT 84
3636: PUSH
3637: LD_INT 14
3639: PUSH
3640: EMPTY
3641: LIST
3642: LIST
3643: PUSH
3644: EMPTY
3645: LIST
3646: LIST
3647: LIST
3648: LIST
3649: LIST
3650: ST_TO_ADDR
// vehicles := [ ] ;
3651: LD_ADDR_VAR 0 12
3655: PUSH
3656: EMPTY
3657: ST_TO_ADDR
// for i in spot_xy do
3658: LD_ADDR_VAR 0 2
3662: PUSH
3663: LD_VAR 0 13
3667: PUSH
3668: FOR_IN
3669: IFFALSE 3827
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3671: LD_ADDR_VAR 0 6
3675: PUSH
3676: LD_INT 3
3678: PPUSH
3679: LD_INT 3
3681: PPUSH
3682: LD_INT 22
3684: PPUSH
3685: LD_INT 1
3687: PPUSH
3688: LD_INT 1
3690: PPUSH
3691: LD_INT 42
3693: PUSH
3694: LD_INT 43
3696: PUSH
3697: LD_INT 44
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: LIST
3704: PUSH
3705: LD_INT 1
3707: PPUSH
3708: LD_INT 3
3710: PPUSH
3711: CALL_OW 12
3715: ARRAY
3716: PPUSH
3717: LD_INT 100
3719: PPUSH
3720: CALL 513 0 7
3724: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3725: LD_ADDR_VAR 0 12
3729: PUSH
3730: LD_VAR 0 12
3734: PPUSH
3735: LD_VAR 0 12
3739: PUSH
3740: LD_INT 1
3742: PLUS
3743: PPUSH
3744: LD_VAR 0 6
3748: PPUSH
3749: CALL_OW 2
3753: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3754: LD_VAR 0 6
3758: PPUSH
3759: LD_INT 3
3761: PPUSH
3762: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3766: LD_VAR 0 6
3770: PPUSH
3771: LD_VAR 0 2
3775: PUSH
3776: LD_INT 1
3778: ARRAY
3779: PPUSH
3780: LD_VAR 0 2
3784: PUSH
3785: LD_INT 2
3787: ARRAY
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3796: LD_INT 0
3798: PPUSH
3799: LD_INT 3
3801: PPUSH
3802: LD_VAR 0 11
3806: PPUSH
3807: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3811: CALL_OW 44
3815: PPUSH
3816: LD_VAR 0 6
3820: PPUSH
3821: CALL_OW 52
// end ;
3825: GO 3668
3827: POP
3828: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3829: LD_ADDR_VAR 0 2
3833: PUSH
3834: DOUBLE
3835: LD_INT 1
3837: DEC
3838: ST_TO_ADDR
3839: LD_INT 5
3841: PUSH
3842: LD_INT 7
3844: PUSH
3845: LD_INT 8
3847: PUSH
3848: EMPTY
3849: LIST
3850: LIST
3851: LIST
3852: PUSH
3853: LD_OWVAR 67
3857: ARRAY
3858: PUSH
3859: FOR_TO
3860: IFFALSE 3920
// begin PrepareHuman ( false , 1 , skill ) ;
3862: LD_INT 0
3864: PPUSH
3865: LD_INT 1
3867: PPUSH
3868: LD_VAR 0 11
3872: PPUSH
3873: CALL_OW 380
// un := CreateHuman ;
3877: LD_ADDR_VAR 0 5
3881: PUSH
3882: CALL_OW 44
3886: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3887: LD_VAR 0 5
3891: PPUSH
3892: LD_INT 11
3894: PPUSH
3895: LD_INT 0
3897: PPUSH
3898: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3902: LD_ADDR_EXP 51
3906: PUSH
3907: LD_EXP 51
3911: PUSH
3912: LD_VAR 0 5
3916: ADD
3917: ST_TO_ADDR
// end ;
3918: GO 3859
3920: POP
3921: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3922: LD_ADDR_VAR 0 2
3926: PUSH
3927: DOUBLE
3928: LD_INT 1
3930: DEC
3931: ST_TO_ADDR
3932: LD_INT 2
3934: PUSH
3935: LD_INT 3
3937: PUSH
3938: LD_INT 4
3940: PUSH
3941: EMPTY
3942: LIST
3943: LIST
3944: LIST
3945: PUSH
3946: LD_OWVAR 67
3950: ARRAY
3951: PUSH
3952: FOR_TO
3953: IFFALSE 4013
// begin PrepareHuman ( false , 1 , skill ) ;
3955: LD_INT 0
3957: PPUSH
3958: LD_INT 1
3960: PPUSH
3961: LD_VAR 0 11
3965: PPUSH
3966: CALL_OW 380
// un := CreateHuman ;
3970: LD_ADDR_VAR 0 5
3974: PUSH
3975: CALL_OW 44
3979: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
3980: LD_VAR 0 5
3984: PPUSH
3985: LD_INT 12
3987: PPUSH
3988: LD_INT 0
3990: PPUSH
3991: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
3995: LD_ADDR_EXP 49
3999: PUSH
4000: LD_EXP 49
4004: PUSH
4005: LD_VAR 0 5
4009: ADD
4010: ST_TO_ADDR
// end ;
4011: GO 3952
4013: POP
4014: POP
// for i = 1 to 2 do
4015: LD_ADDR_VAR 0 2
4019: PUSH
4020: DOUBLE
4021: LD_INT 1
4023: DEC
4024: ST_TO_ADDR
4025: LD_INT 2
4027: PUSH
4028: FOR_TO
4029: IFFALSE 4095
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4031: LD_INT 1
4033: PPUSH
4034: LD_INT 1
4036: PPUSH
4037: LD_VAR 0 11
4041: PPUSH
4042: CALL_OW 380
// un := CreateHuman ;
4046: LD_ADDR_VAR 0 5
4050: PUSH
4051: CALL_OW 44
4055: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4056: LD_VAR 0 5
4060: PPUSH
4061: LD_INT 39
4063: PPUSH
4064: LD_INT 12
4066: PPUSH
4067: LD_INT 3
4069: PPUSH
4070: LD_INT 0
4072: PPUSH
4073: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4077: LD_ADDR_EXP 50
4081: PUSH
4082: LD_EXP 50
4086: PUSH
4087: LD_VAR 0 5
4091: ADD
4092: ST_TO_ADDR
// end ;
4093: GO 4028
4095: POP
4096: POP
// for i = 1 to 3 do
4097: LD_ADDR_VAR 0 2
4101: PUSH
4102: DOUBLE
4103: LD_INT 1
4105: DEC
4106: ST_TO_ADDR
4107: LD_INT 3
4109: PUSH
4110: FOR_TO
4111: IFFALSE 4177
// begin PrepareHuman ( false , 1 , skill ) ;
4113: LD_INT 0
4115: PPUSH
4116: LD_INT 1
4118: PPUSH
4119: LD_VAR 0 11
4123: PPUSH
4124: CALL_OW 380
// un := CreateHuman ;
4128: LD_ADDR_VAR 0 5
4132: PUSH
4133: CALL_OW 44
4137: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4138: LD_VAR 0 5
4142: PPUSH
4143: LD_INT 180
4145: PPUSH
4146: LD_INT 11
4148: PPUSH
4149: LD_INT 4
4151: PPUSH
4152: LD_INT 0
4154: PPUSH
4155: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4159: LD_ADDR_EXP 54
4163: PUSH
4164: LD_EXP 54
4168: PUSH
4169: LD_VAR 0 5
4173: ADD
4174: ST_TO_ADDR
// end ;
4175: GO 4110
4177: POP
4178: POP
// ru_vehicles := vehicles ;
4179: LD_ADDR_EXP 52
4183: PUSH
4184: LD_VAR 0 12
4188: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4189: LD_ADDR_EXP 55
4193: PUSH
4194: LD_INT 131
4196: PUSH
4197: LD_INT 121
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: PUSH
4204: LD_INT 113
4206: PUSH
4207: LD_INT 90
4209: PUSH
4210: EMPTY
4211: LIST
4212: LIST
4213: PUSH
4214: LD_INT 93
4216: PUSH
4217: LD_INT 62
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: PUSH
4224: EMPTY
4225: LIST
4226: LIST
4227: LIST
4228: PUSH
4229: LD_INT 106
4231: PUSH
4232: LD_INT 54
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: PUSH
4239: LD_INT 120
4241: PUSH
4242: LD_INT 80
4244: PUSH
4245: EMPTY
4246: LIST
4247: LIST
4248: PUSH
4249: LD_INT 143
4251: PUSH
4252: LD_INT 120
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 154
4266: PUSH
4267: LD_INT 116
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: PUSH
4274: LD_INT 140
4276: PUSH
4277: LD_INT 93
4279: PUSH
4280: EMPTY
4281: LIST
4282: LIST
4283: PUSH
4284: LD_INT 130
4286: PUSH
4287: LD_INT 58
4289: PUSH
4290: EMPTY
4291: LIST
4292: LIST
4293: PUSH
4294: EMPTY
4295: LIST
4296: LIST
4297: LIST
4298: PUSH
4299: LD_INT 105
4301: PUSH
4302: LD_INT 106
4304: PUSH
4305: EMPTY
4306: LIST
4307: LIST
4308: PUSH
4309: LD_INT 134
4311: PUSH
4312: LD_INT 98
4314: PUSH
4315: EMPTY
4316: LIST
4317: LIST
4318: PUSH
4319: LD_INT 159
4321: PUSH
4322: LD_INT 113
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: LIST
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: LIST
4338: LIST
4339: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4340: LD_ADDR_VAR 0 2
4344: PUSH
4345: DOUBLE
4346: LD_INT 1
4348: DEC
4349: ST_TO_ADDR
4350: LD_OWVAR 67
4354: PUSH
4355: LD_INT 1
4357: MINUS
4358: PUSH
4359: FOR_TO
4360: IFFALSE 4393
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4362: LD_ADDR_EXP 53
4366: PUSH
4367: LD_EXP 53
4371: PUSH
4372: LD_INT 22
4374: PUSH
4375: LD_INT 1
4377: PUSH
4378: LD_INT 1
4380: PUSH
4381: LD_INT 43
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: LIST
4388: LIST
4389: ADD
4390: ST_TO_ADDR
4391: GO 4359
4393: POP
4394: POP
// end ;
4395: LD_VAR 0 1
4399: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4400: LD_INT 22
4402: PUSH
4403: LD_INT 3
4405: PUSH
4406: EMPTY
4407: LIST
4408: LIST
4409: PUSH
4410: LD_INT 21
4412: PUSH
4413: LD_INT 2
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: EMPTY
4421: LIST
4422: LIST
4423: PPUSH
4424: CALL_OW 69
4428: IFFALSE 4522
4430: GO 4432
4432: DISABLE
4433: LD_INT 0
4435: PPUSH
4436: PPUSH
// begin enable ;
4437: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4438: LD_ADDR_VAR 0 2
4442: PUSH
4443: LD_INT 22
4445: PUSH
4446: LD_INT 3
4448: PUSH
4449: EMPTY
4450: LIST
4451: LIST
4452: PUSH
4453: LD_INT 21
4455: PUSH
4456: LD_INT 2
4458: PUSH
4459: EMPTY
4460: LIST
4461: LIST
4462: PUSH
4463: EMPTY
4464: LIST
4465: LIST
4466: PPUSH
4467: CALL_OW 69
4471: ST_TO_ADDR
// if filter then
4472: LD_VAR 0 2
4476: IFFALSE 4522
// for i in filter do
4478: LD_ADDR_VAR 0 1
4482: PUSH
4483: LD_VAR 0 2
4487: PUSH
4488: FOR_IN
4489: IFFALSE 4520
// if GetFuel ( i ) < 20 then
4491: LD_VAR 0 1
4495: PPUSH
4496: CALL_OW 261
4500: PUSH
4501: LD_INT 20
4503: LESS
4504: IFFALSE 4518
// SetFuel ( i , 20 ) ;
4506: LD_VAR 0 1
4510: PPUSH
4511: LD_INT 20
4513: PPUSH
4514: CALL_OW 240
4518: GO 4488
4520: POP
4521: POP
// end ;
4522: PPOPN 2
4524: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4525: LD_EXP 53
4529: IFFALSE 4748
4531: GO 4533
4533: DISABLE
4534: LD_INT 0
4536: PPUSH
4537: PPUSH
4538: PPUSH
// begin enable ;
4539: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4540: LD_ADDR_VAR 0 2
4544: PUSH
4545: LD_INT 22
4547: PUSH
4548: LD_INT 3
4550: PUSH
4551: EMPTY
4552: LIST
4553: LIST
4554: PUSH
4555: LD_INT 30
4557: PUSH
4558: LD_INT 3
4560: PUSH
4561: EMPTY
4562: LIST
4563: LIST
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PPUSH
4569: CALL_OW 69
4573: ST_TO_ADDR
// can_produce := [ ] ;
4574: LD_ADDR_VAR 0 3
4578: PUSH
4579: EMPTY
4580: ST_TO_ADDR
// if not fac then
4581: LD_VAR 0 2
4585: NOT
4586: IFFALSE 4591
// begin disable ;
4588: DISABLE
// exit ;
4589: GO 4748
// end ; for i in fac do
4591: LD_ADDR_VAR 0 1
4595: PUSH
4596: LD_VAR 0 2
4600: PUSH
4601: FOR_IN
4602: IFFALSE 4640
// if UnitsInside ( i ) then
4604: LD_VAR 0 1
4608: PPUSH
4609: CALL_OW 313
4613: IFFALSE 4638
// can_produce := Insert ( can_produce , 1 , i ) ;
4615: LD_ADDR_VAR 0 3
4619: PUSH
4620: LD_VAR 0 3
4624: PPUSH
4625: LD_INT 1
4627: PPUSH
4628: LD_VAR 0 1
4632: PPUSH
4633: CALL_OW 2
4637: ST_TO_ADDR
4638: GO 4601
4640: POP
4641: POP
// if not can_produce then
4642: LD_VAR 0 3
4646: NOT
4647: IFFALSE 4651
// exit ;
4649: GO 4748
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4651: LD_VAR 0 3
4655: PUSH
4656: LD_INT 1
4658: PPUSH
4659: LD_VAR 0 3
4663: PPUSH
4664: CALL_OW 12
4668: ARRAY
4669: PPUSH
4670: LD_EXP 53
4674: PUSH
4675: LD_INT 1
4677: ARRAY
4678: PPUSH
4679: LD_EXP 53
4683: PUSH
4684: LD_INT 2
4686: ARRAY
4687: PPUSH
4688: LD_EXP 53
4692: PUSH
4693: LD_INT 3
4695: ARRAY
4696: PPUSH
4697: LD_EXP 53
4701: PUSH
4702: LD_INT 4
4704: ARRAY
4705: PPUSH
4706: CALL_OW 125
// for i = 1 to 4 do
4710: LD_ADDR_VAR 0 1
4714: PUSH
4715: DOUBLE
4716: LD_INT 1
4718: DEC
4719: ST_TO_ADDR
4720: LD_INT 4
4722: PUSH
4723: FOR_TO
4724: IFFALSE 4746
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4726: LD_ADDR_EXP 53
4730: PUSH
4731: LD_EXP 53
4735: PPUSH
4736: LD_INT 1
4738: PPUSH
4739: CALL_OW 3
4743: ST_TO_ADDR
4744: GO 4723
4746: POP
4747: POP
// end ;
4748: PPOPN 3
4750: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4751: LD_INT 0
4753: PPUSH
4754: PPUSH
4755: PPUSH
// for i = 1 to 6 do
4756: LD_ADDR_VAR 0 2
4760: PUSH
4761: DOUBLE
4762: LD_INT 1
4764: DEC
4765: ST_TO_ADDR
4766: LD_INT 6
4768: PUSH
4769: FOR_TO
4770: IFFALSE 4919
// begin PrepareHuman ( false , 3 , 3 ) ;
4772: LD_INT 0
4774: PPUSH
4775: LD_INT 3
4777: PPUSH
4778: LD_INT 3
4780: PPUSH
4781: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4785: LD_ADDR_VAR 0 3
4789: PUSH
4790: LD_INT 3
4792: PPUSH
4793: LD_INT 3
4795: PPUSH
4796: LD_INT 22
4798: PPUSH
4799: LD_INT 1
4801: PPUSH
4802: LD_INT 1
4804: PPUSH
4805: LD_INT 43
4807: PUSH
4808: LD_INT 42
4810: PUSH
4811: EMPTY
4812: LIST
4813: LIST
4814: PUSH
4815: LD_INT 1
4817: PPUSH
4818: LD_INT 2
4820: PPUSH
4821: CALL_OW 12
4825: ARRAY
4826: PPUSH
4827: LD_INT 70
4829: PPUSH
4830: CALL 513 0 7
4834: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4835: LD_VAR 0 3
4839: PPUSH
4840: LD_INT 4
4842: PPUSH
4843: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4847: LD_VAR 0 3
4851: PPUSH
4852: LD_INT 229
4854: PPUSH
4855: LD_INT 44
4857: PPUSH
4858: LD_INT 0
4860: PPUSH
4861: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4865: CALL_OW 44
4869: PPUSH
4870: LD_VAR 0 3
4874: PPUSH
4875: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4879: LD_ADDR_EXP 52
4883: PUSH
4884: LD_EXP 52
4888: PUSH
4889: LD_VAR 0 3
4893: ADD
4894: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
4895: LD_VAR 0 3
4899: PPUSH
4900: LD_INT 191
4902: PPUSH
4903: LD_INT 32
4905: PPUSH
4906: CALL_OW 111
// Wait ( 0 0$02 ) ;
4910: LD_INT 70
4912: PPUSH
4913: CALL_OW 67
// end ;
4917: GO 4769
4919: POP
4920: POP
// end ; end_of_file
4921: LD_VAR 0 1
4925: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
4926: LD_INT 0
4928: PPUSH
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
4933: PPUSH
4934: PPUSH
// InGameOn ;
4935: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
4939: LD_EXP 33
4943: PPUSH
4944: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
4948: LD_EXP 33
4952: PPUSH
4953: LD_EXP 40
4957: PPUSH
4958: CALL_OW 119
// if Bierezov then
4962: LD_EXP 41
4966: IFFALSE 4982
// ComTurnUnit ( Bierezov , Cornel ) ;
4968: LD_EXP 41
4972: PPUSH
4973: LD_EXP 40
4977: PPUSH
4978: CALL_OW 119
// for i in jmm_units do
4982: LD_ADDR_VAR 0 2
4986: PUSH
4987: LD_EXP 4
4991: PUSH
4992: FOR_IN
4993: IFFALSE 5011
// ComTurnUnit ( i , Cornel ) ;
4995: LD_VAR 0 2
4999: PPUSH
5000: LD_EXP 40
5004: PPUSH
5005: CALL_OW 119
5009: GO 4992
5011: POP
5012: POP
// units := cornel_units union Cornel ;
5013: LD_ADDR_VAR 0 3
5017: PUSH
5018: LD_EXP 6
5022: PUSH
5023: LD_EXP 40
5027: UNION
5028: ST_TO_ADDR
// repeat wait ( 1 ) ;
5029: LD_INT 1
5031: PPUSH
5032: CALL_OW 67
// for i in units do
5036: LD_ADDR_VAR 0 2
5040: PUSH
5041: LD_VAR 0 3
5045: PUSH
5046: FOR_IN
5047: IFFALSE 5080
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5049: LD_VAR 0 2
5053: PPUSH
5054: LD_EXP 33
5058: PPUSH
5059: CALL_OW 250
5063: PPUSH
5064: LD_EXP 33
5068: PPUSH
5069: CALL_OW 251
5073: PPUSH
5074: CALL_OW 111
5078: GO 5046
5080: POP
5081: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5082: LD_VAR 0 3
5086: PPUSH
5087: LD_INT 92
5089: PUSH
5090: LD_EXP 33
5094: PPUSH
5095: CALL_OW 250
5099: PUSH
5100: LD_EXP 33
5104: PPUSH
5105: CALL_OW 251
5109: PUSH
5110: LD_INT 10
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: LIST
5117: LIST
5118: PPUSH
5119: CALL_OW 72
5123: PUSH
5124: LD_VAR 0 3
5128: EQUAL
5129: IFFALSE 5029
// for i in units do
5131: LD_ADDR_VAR 0 2
5135: PUSH
5136: LD_VAR 0 3
5140: PUSH
5141: FOR_IN
5142: IFFALSE 5160
// ComTurnUnit ( i , JMM ) ;
5144: LD_VAR 0 2
5148: PPUSH
5149: LD_EXP 33
5153: PPUSH
5154: CALL_OW 119
5158: GO 5141
5160: POP
5161: POP
// ComTurnUnit ( Cornel , JMM ) ;
5162: LD_EXP 40
5166: PPUSH
5167: LD_EXP 33
5171: PPUSH
5172: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5176: LD_EXP 33
5180: PPUSH
5181: LD_STRING D1-JMM-1
5183: PPUSH
5184: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5188: LD_EXP 40
5192: PPUSH
5193: LD_STRING D1-Corn-1
5195: PPUSH
5196: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5200: LD_EXP 33
5204: PPUSH
5205: LD_EXP 40
5209: PPUSH
5210: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5214: LD_EXP 40
5218: PPUSH
5219: LD_EXP 33
5223: PPUSH
5224: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5228: LD_INT 35
5230: PPUSH
5231: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5235: LD_EXP 33
5239: PPUSH
5240: LD_EXP 40
5244: PPUSH
5245: CALL_OW 296
5249: PUSH
5250: LD_INT 6
5252: LESS
5253: IFFALSE 5228
// ChangeSideFog ( 4 , 1 ) ;
5255: LD_INT 4
5257: PPUSH
5258: LD_INT 1
5260: PPUSH
5261: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5265: LD_EXP 33
5269: PPUSH
5270: LD_EXP 40
5274: PPUSH
5275: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5279: LD_EXP 40
5283: PPUSH
5284: LD_EXP 33
5288: PPUSH
5289: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5293: LD_EXP 33
5297: PPUSH
5298: LD_STRING D1-JMM-2
5300: PPUSH
5301: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5305: LD_EXP 33
5309: PPUSH
5310: LD_STRING D1-JMM-2a
5312: PPUSH
5313: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5317: LD_EXP 40
5321: PPUSH
5322: LD_STRING D1-Corn-2
5324: PPUSH
5325: CALL_OW 88
// if bierezov_exist or debug then
5329: LD_EXP 7
5333: PUSH
5334: LD_EXP 1
5338: OR
5339: IFFALSE 5580
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5341: LD_EXP 40
5345: PPUSH
5346: LD_EXP 41
5350: PPUSH
5351: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5355: LD_INT 10
5357: PPUSH
5358: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5362: LD_EXP 40
5366: PPUSH
5367: LD_STRING D1a-Corn-1
5369: PPUSH
5370: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5374: LD_EXP 33
5378: PPUSH
5379: LD_EXP 41
5383: PPUSH
5384: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5388: LD_EXP 41
5392: PPUSH
5393: LD_EXP 33
5397: PPUSH
5398: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5402: LD_EXP 33
5406: PPUSH
5407: LD_STRING D1a-JMM-1
5409: PPUSH
5410: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5414: LD_EXP 33
5418: PPUSH
5419: LD_EXP 40
5423: PPUSH
5424: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5428: LD_EXP 40
5432: PPUSH
5433: LD_EXP 33
5437: PPUSH
5438: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5442: LD_EXP 40
5446: PPUSH
5447: LD_STRING D1a-Corn-2
5449: PPUSH
5450: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5454: LD_EXP 33
5458: PPUSH
5459: LD_STRING D1a-JMM-2
5461: PPUSH
5462: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5466: LD_EXP 40
5470: PPUSH
5471: LD_STRING D1a-Corn-3
5473: PPUSH
5474: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5478: LD_EXP 33
5482: PPUSH
5483: LD_STRING D1a-JMM-3
5485: PPUSH
5486: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5490: LD_EXP 40
5494: PPUSH
5495: LD_STRING D1a-Corn-4
5497: PPUSH
5498: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5502: LD_EXP 33
5506: PPUSH
5507: LD_STRING D1a-JMM-4
5509: PPUSH
5510: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5514: LD_EXP 40
5518: PPUSH
5519: LD_STRING D1a-Corn-5
5521: PPUSH
5522: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5526: LD_EXP 41
5530: PPUSH
5531: LD_EXP 40
5535: PPUSH
5536: CALL_OW 250
5540: PPUSH
5541: LD_EXP 40
5545: PPUSH
5546: CALL_OW 251
5550: PUSH
5551: LD_INT 2
5553: MINUS
5554: PPUSH
5555: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5559: LD_EXP 41
5563: PPUSH
5564: LD_EXP 40
5568: PPUSH
5569: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5573: LD_INT 10
5575: PPUSH
5576: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5580: LD_EXP 33
5584: PPUSH
5585: LD_STRING D1b-JMM-1
5587: PPUSH
5588: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5592: LD_EXP 40
5596: PPUSH
5597: LD_STRING D1b-Corn-1
5599: PPUSH
5600: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5604: LD_EXP 33
5608: PPUSH
5609: LD_STRING D1b-JMM-2
5611: PPUSH
5612: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5616: LD_EXP 40
5620: PPUSH
5621: LD_STRING D1b-Corn-2
5623: PPUSH
5624: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5628: LD_EXP 33
5632: PPUSH
5633: LD_STRING D1b-JMM-3
5635: PPUSH
5636: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5640: LD_INT 10
5642: PPUSH
5643: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5647: LD_EXP 42
5651: PPUSH
5652: LD_STRING D1b-Pow-3
5654: PPUSH
5655: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5659: LD_EXP 33
5663: PPUSH
5664: LD_STRING D1b-JMM-4
5666: PPUSH
5667: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5671: LD_EXP 40
5675: PPUSH
5676: LD_STRING D1b-Corn-4
5678: PPUSH
5679: CALL_OW 88
// if Khatam then
5683: LD_EXP 37
5687: IFFALSE 5703
// Say ( Khatam , D1b-Khat-4 ) else
5689: LD_EXP 37
5693: PPUSH
5694: LD_STRING D1b-Khat-4
5696: PPUSH
5697: CALL_OW 88
5701: GO 5739
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
5703: LD_EXP 6
5707: PPUSH
5708: LD_INT 26
5710: PUSH
5711: LD_INT 1
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: PPUSH
5718: CALL_OW 72
5722: PUSH
5723: LD_EXP 40
5727: PUSH
5728: EMPTY
5729: LIST
5730: DIFF
5731: PPUSH
5732: LD_STRING D1b-Sol1-4
5734: PPUSH
5735: CALL 601 0 2
// if Cyrus then
5739: LD_EXP 35
5743: IFFALSE 5757
// Say ( Cyrus , D1b-Cyrus-4 ) ;
5745: LD_EXP 35
5749: PPUSH
5750: LD_STRING D1b-Cyrus-4
5752: PPUSH
5753: CALL_OW 88
// if Lisa then
5757: LD_EXP 36
5761: IFFALSE 5819
// begin Say ( Lisa , D1b-Lisa-4 ) ;
5763: LD_EXP 36
5767: PPUSH
5768: LD_STRING D1b-Lisa-4
5770: PPUSH
5771: CALL_OW 88
// if Cyrus then
5775: LD_EXP 35
5779: IFFALSE 5819
// begin if not IsInUnit ( Cyrus ) then
5781: LD_EXP 35
5785: PPUSH
5786: CALL_OW 310
5790: NOT
5791: IFFALSE 5807
// ComTurnUnit ( Cyrus , Lisa ) ;
5793: LD_EXP 35
5797: PPUSH
5798: LD_EXP 36
5802: PPUSH
5803: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
5807: LD_EXP 35
5811: PPUSH
5812: LD_STRING D1b-Cyrus-5
5814: PPUSH
5815: CALL_OW 88
// end ; end ; SelectGroup ;
5819: CALL 2554 0 0
// Say ( JMM , D1d-JMM-1 ) ;
5823: LD_EXP 33
5827: PPUSH
5828: LD_STRING D1d-JMM-1
5830: PPUSH
5831: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
5835: LD_EXP 40
5839: PPUSH
5840: LD_STRING D1d-Corn-1
5842: PPUSH
5843: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
5847: LD_ADDR_VAR 0 2
5851: PUSH
5852: LD_EXP 4
5856: PUSH
5857: LD_EXP 6
5861: ADD
5862: PUSH
5863: LD_EXP 33
5867: ADD
5868: PUSH
5869: FOR_IN
5870: IFFALSE 5883
// ComHold ( i ) ;
5872: LD_VAR 0 2
5876: PPUSH
5877: CALL_OW 140
5881: GO 5869
5883: POP
5884: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
5885: LD_ADDR_VAR 0 4
5889: PUSH
5890: LD_INT 22
5892: PUSH
5893: LD_INT 1
5895: PUSH
5896: EMPTY
5897: LIST
5898: LIST
5899: PUSH
5900: LD_INT 21
5902: PUSH
5903: LD_INT 2
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: PPUSH
5914: CALL_OW 69
5918: ST_TO_ADDR
// if vehicles then
5919: LD_VAR 0 4
5923: IFFALSE 6261
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
5925: LD_EXP 6
5929: PPUSH
5930: LD_INT 55
5932: PUSH
5933: EMPTY
5934: LIST
5935: PPUSH
5936: CALL_OW 72
5940: IFFALSE 5979
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
5942: LD_ADDR_VAR 0 2
5946: PUSH
5947: LD_EXP 6
5951: PPUSH
5952: LD_INT 55
5954: PUSH
5955: EMPTY
5956: LIST
5957: PPUSH
5958: CALL_OW 72
5962: PUSH
5963: FOR_IN
5964: IFFALSE 5977
// ComExitVehicle ( i ) ;
5966: LD_VAR 0 2
5970: PPUSH
5971: CALL_OW 121
5975: GO 5963
5977: POP
5978: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
5979: LD_ADDR_VAR 0 5
5983: PUSH
5984: LD_VAR 0 4
5988: PPUSH
5989: LD_INT 34
5991: PUSH
5992: LD_INT 51
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: PPUSH
5999: CALL_OW 72
6003: ST_TO_ADDR
// if cargos then
6004: LD_VAR 0 5
6008: IFFALSE 6191
// begin vehicles := cargos ;
6010: LD_ADDR_VAR 0 4
6014: PUSH
6015: LD_VAR 0 5
6019: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6020: LD_ADDR_VAR 0 6
6024: PUSH
6025: LD_STRING 02_resources_4
6027: PPUSH
6028: LD_INT 0
6030: PPUSH
6031: CALL_OW 30
6035: ST_TO_ADDR
// if debug and not resources then
6036: LD_EXP 1
6040: PUSH
6041: LD_VAR 0 6
6045: NOT
6046: AND
6047: IFFALSE 6057
// resources := 160 ;
6049: LD_ADDR_VAR 0 6
6053: PUSH
6054: LD_INT 160
6056: ST_TO_ADDR
// if resources mod 10 then
6057: LD_VAR 0 6
6061: PUSH
6062: LD_INT 10
6064: MOD
6065: IFFALSE 6087
// resources := resources - resources mod 10 ;
6067: LD_ADDR_VAR 0 6
6071: PUSH
6072: LD_VAR 0 6
6076: PUSH
6077: LD_VAR 0 6
6081: PUSH
6082: LD_INT 10
6084: MOD
6085: MINUS
6086: ST_TO_ADDR
// if resources then
6087: LD_VAR 0 6
6091: IFFALSE 6191
// for i in cargos do
6093: LD_ADDR_VAR 0 2
6097: PUSH
6098: LD_VAR 0 5
6102: PUSH
6103: FOR_IN
6104: IFFALSE 6189
// begin if resources < 100 then
6106: LD_VAR 0 6
6110: PUSH
6111: LD_INT 100
6113: LESS
6114: IFFALSE 6136
// begin cargo := resources ;
6116: LD_ADDR_VAR 0 7
6120: PUSH
6121: LD_VAR 0 6
6125: ST_TO_ADDR
// resources := 0 ;
6126: LD_ADDR_VAR 0 6
6130: PUSH
6131: LD_INT 0
6133: ST_TO_ADDR
// end else
6134: GO 6158
// begin cargo := 100 ;
6136: LD_ADDR_VAR 0 7
6140: PUSH
6141: LD_INT 100
6143: ST_TO_ADDR
// resources := resources - 100 ;
6144: LD_ADDR_VAR 0 6
6148: PUSH
6149: LD_VAR 0 6
6153: PUSH
6154: LD_INT 100
6156: MINUS
6157: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6158: LD_VAR 0 2
6162: PPUSH
6163: LD_INT 1
6165: PPUSH
6166: LD_VAR 0 7
6170: PPUSH
6171: CALL_OW 290
// if resources = 0 then
6175: LD_VAR 0 6
6179: PUSH
6180: LD_INT 0
6182: EQUAL
6183: IFFALSE 6187
// break ;
6185: GO 6189
// end ;
6187: GO 6103
6189: POP
6190: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6191: LD_VAR 0 4
6195: PUSH
6196: LD_INT 1
6198: ARRAY
6199: PPUSH
6200: CALL_OW 311
6204: PPUSH
6205: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6209: LD_VAR 0 4
6213: PUSH
6214: LD_INT 1
6216: ARRAY
6217: PPUSH
6218: LD_INT 4
6220: PPUSH
6221: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6225: LD_EXP 40
6229: PPUSH
6230: LD_VAR 0 4
6234: PUSH
6235: LD_INT 1
6237: ARRAY
6238: PPUSH
6239: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6243: LD_INT 35
6245: PPUSH
6246: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6250: LD_EXP 40
6254: PPUSH
6255: CALL_OW 310
6259: IFFALSE 6243
// end ; InGameOff ;
6261: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6265: LD_STRING M1
6267: PPUSH
6268: CALL_OW 337
// SaveForQuickRestart ;
6272: CALL_OW 22
// cornel_active := true ;
6276: LD_ADDR_EXP 8
6280: PUSH
6281: LD_INT 1
6283: ST_TO_ADDR
// end ;
6284: LD_VAR 0 1
6288: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
6289: LD_EXP 33
6293: PPUSH
6294: LD_EXP 43
6298: PPUSH
6299: CALL_OW 296
6303: PUSH
6304: LD_INT 10
6306: LESS
6307: IFFALSE 7463
6309: GO 6311
6311: DISABLE
6312: LD_INT 0
6314: PPUSH
6315: PPUSH
6316: PPUSH
6317: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6318: LD_ADDR_VAR 0 2
6322: PUSH
6323: LD_INT 89
6325: PUSH
6326: LD_INT 34
6328: PUSH
6329: EMPTY
6330: LIST
6331: LIST
6332: PUSH
6333: LD_INT 138
6335: PUSH
6336: LD_INT 63
6338: PUSH
6339: EMPTY
6340: LIST
6341: LIST
6342: PUSH
6343: LD_INT 196
6345: PUSH
6346: LD_INT 84
6348: PUSH
6349: EMPTY
6350: LIST
6351: LIST
6352: PUSH
6353: LD_INT 135
6355: PUSH
6356: LD_INT 52
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: PUSH
6363: LD_INT 103
6365: PUSH
6366: LD_INT 39
6368: PUSH
6369: EMPTY
6370: LIST
6371: LIST
6372: PUSH
6373: LD_INT 58
6375: PUSH
6376: LD_INT 30
6378: PUSH
6379: EMPTY
6380: LIST
6381: LIST
6382: PUSH
6383: LD_INT 38
6385: PUSH
6386: LD_INT 51
6388: PUSH
6389: EMPTY
6390: LIST
6391: LIST
6392: PUSH
6393: EMPTY
6394: LIST
6395: LIST
6396: LIST
6397: LIST
6398: LIST
6399: LIST
6400: LIST
6401: ST_TO_ADDR
// InGameOn ;
6402: CALL_OW 8
// if jmm_units then
6406: LD_EXP 4
6410: IFFALSE 6474
// for i in jmm_units do
6412: LD_ADDR_VAR 0 1
6416: PUSH
6417: LD_EXP 4
6421: PUSH
6422: FOR_IN
6423: IFFALSE 6472
// begin if GetDistUnits ( i , JMM ) < 10 then
6425: LD_VAR 0 1
6429: PPUSH
6430: LD_EXP 33
6434: PPUSH
6435: CALL_OW 296
6439: PUSH
6440: LD_INT 10
6442: LESS
6443: IFFALSE 6461
// ComTurnUnit ( i , JMM ) else
6445: LD_VAR 0 1
6449: PPUSH
6450: LD_EXP 33
6454: PPUSH
6455: CALL_OW 119
6459: GO 6470
// ComHold ( i ) ;
6461: LD_VAR 0 1
6465: PPUSH
6466: CALL_OW 140
// end ;
6470: GO 6422
6472: POP
6473: POP
// if IsInUnit ( JMM ) then
6474: LD_EXP 33
6478: PPUSH
6479: CALL_OW 310
6483: IFFALSE 6508
// begin ComExitVehicle ( JMM ) ;
6485: LD_EXP 33
6489: PPUSH
6490: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6494: LD_EXP 33
6498: PPUSH
6499: LD_EXP 43
6503: PPUSH
6504: CALL_OW 172
// end ; Wait ( 10 ) ;
6508: LD_INT 10
6510: PPUSH
6511: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6515: LD_EXP 33
6519: PPUSH
6520: LD_EXP 43
6524: PPUSH
6525: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6529: LD_INT 35
6531: PPUSH
6532: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6536: LD_EXP 33
6540: PPUSH
6541: LD_EXP 43
6545: PPUSH
6546: CALL_OW 296
6550: PUSH
6551: LD_INT 6
6553: LESS
6554: IFFALSE 6529
// ComTurnUnit ( JMM , Lynch ) ;
6556: LD_EXP 33
6560: PPUSH
6561: LD_EXP 43
6565: PPUSH
6566: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6570: LD_ADDR_VAR 0 1
6574: PUSH
6575: LD_EXP 43
6579: PUSH
6580: LD_EXP 44
6584: PUSH
6585: LD_EXP 45
6589: PUSH
6590: LD_EXP 46
6594: PUSH
6595: EMPTY
6596: LIST
6597: LIST
6598: LIST
6599: LIST
6600: PUSH
6601: FOR_IN
6602: IFFALSE 6620
// ComTurnUnit ( i , JMM ) ;
6604: LD_VAR 0 1
6608: PPUSH
6609: LD_EXP 33
6613: PPUSH
6614: CALL_OW 119
6618: GO 6601
6620: POP
6621: POP
// Wait ( 0 0$0.3 ) ;
6622: LD_INT 10
6624: PPUSH
6625: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6629: LD_EXP 33
6633: PPUSH
6634: LD_STRING D2-JMM-1
6636: PPUSH
6637: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6641: LD_EXP 43
6645: PPUSH
6646: LD_STRING D2-Sol1-1
6648: PPUSH
6649: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6653: LD_EXP 33
6657: PPUSH
6658: LD_STRING D2-JMM-2
6660: PPUSH
6661: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6665: LD_EXP 43
6669: PPUSH
6670: LD_STRING D2-Sol1-2
6672: PPUSH
6673: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6677: LD_EXP 33
6681: PPUSH
6682: LD_STRING D2-JMM-3
6684: PPUSH
6685: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
6689: LD_EXP 43
6693: PPUSH
6694: LD_STRING D2-Sol1-3
6696: PPUSH
6697: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6701: LD_ADDR_VAR 0 1
6705: PUSH
6706: LD_INT 22
6708: PUSH
6709: LD_INT 8
6711: PUSH
6712: EMPTY
6713: LIST
6714: LIST
6715: PPUSH
6716: CALL_OW 69
6720: PUSH
6721: FOR_IN
6722: IFFALSE 6738
// SetSide ( i , 1 ) ;
6724: LD_VAR 0 1
6728: PPUSH
6729: LD_INT 1
6731: PPUSH
6732: CALL_OW 235
6736: GO 6721
6738: POP
6739: POP
// Say ( JMM , D2-JMM-4 ) ;
6740: LD_EXP 33
6744: PPUSH
6745: LD_STRING D2-JMM-4
6747: PPUSH
6748: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
6752: LD_INT 1
6754: PPUSH
6755: LD_INT 5
6757: PPUSH
6758: CALL_OW 332
// for i = 1 to points do
6762: LD_ADDR_VAR 0 1
6766: PUSH
6767: DOUBLE
6768: LD_INT 1
6770: DEC
6771: ST_TO_ADDR
6772: LD_VAR 0 2
6776: PUSH
6777: FOR_TO
6778: IFFALSE 6953
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6780: LD_VAR 0 2
6784: PUSH
6785: LD_VAR 0 1
6789: ARRAY
6790: PUSH
6791: LD_INT 1
6793: ARRAY
6794: PPUSH
6795: LD_VAR 0 2
6799: PUSH
6800: LD_VAR 0 1
6804: ARRAY
6805: PUSH
6806: LD_INT 2
6808: ARRAY
6809: PPUSH
6810: CALL_OW 84
// if i = 1 then
6814: LD_VAR 0 1
6818: PUSH
6819: LD_INT 1
6821: EQUAL
6822: IFFALSE 6836
// Say ( Lynch , D2-Sol1-4 ) ;
6824: LD_EXP 43
6828: PPUSH
6829: LD_STRING D2-Sol1-4
6831: PPUSH
6832: CALL_OW 88
// if i = 2 then
6836: LD_VAR 0 1
6840: PUSH
6841: LD_INT 2
6843: EQUAL
6844: IFFALSE 6858
// Say ( JMM , D2-JMM-5 ) ;
6846: LD_EXP 33
6850: PPUSH
6851: LD_STRING D2-JMM-5
6853: PPUSH
6854: CALL_OW 88
// if i = 4 then
6858: LD_VAR 0 1
6862: PUSH
6863: LD_INT 4
6865: EQUAL
6866: IFFALSE 6890
// begin RevealFogArea ( 1 , troopsArea ) ;
6868: LD_INT 1
6870: PPUSH
6871: LD_INT 6
6873: PPUSH
6874: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
6878: LD_EXP 43
6882: PPUSH
6883: LD_STRING D2-Sol1-5
6885: PPUSH
6886: CALL_OW 88
// end ; if i = 5 then
6890: LD_VAR 0 1
6894: PUSH
6895: LD_INT 5
6897: EQUAL
6898: IFFALSE 6912
// Say ( JMM , D2-JMM-6 ) ;
6900: LD_EXP 33
6904: PPUSH
6905: LD_STRING D2-JMM-6
6907: PPUSH
6908: CALL_OW 88
// if i = 7 then
6912: LD_VAR 0 1
6916: PUSH
6917: LD_INT 7
6919: EQUAL
6920: IFFALSE 6944
// begin RevealFogArea ( 1 , forestArea ) ;
6922: LD_INT 1
6924: PPUSH
6925: LD_INT 7
6927: PPUSH
6928: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
6932: LD_EXP 43
6936: PPUSH
6937: LD_STRING D2-Sol1-6
6939: PPUSH
6940: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
6944: LD_INT 46
6946: PPUSH
6947: CALL_OW 67
// end ;
6951: GO 6777
6953: POP
6954: POP
// CenterNowOnUnits ( JMM ) ;
6955: LD_EXP 33
6959: PPUSH
6960: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
6964: LD_EXP 33
6968: PPUSH
6969: LD_STRING D2-JMM-7
6971: PPUSH
6972: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
6976: LD_EXP 43
6980: PPUSH
6981: LD_STRING D2-Sol1-7
6983: PPUSH
6984: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
6988: LD_EXP 33
6992: PPUSH
6993: LD_STRING D2-JMM-8
6995: PPUSH
6996: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7000: LD_ADDR_VAR 0 4
7004: PUSH
7005: LD_INT 22
7007: PUSH
7008: LD_INT 1
7010: PUSH
7011: EMPTY
7012: LIST
7013: LIST
7014: PUSH
7015: LD_INT 30
7017: PUSH
7018: LD_INT 31
7020: PUSH
7021: EMPTY
7022: LIST
7023: LIST
7024: PUSH
7025: EMPTY
7026: LIST
7027: LIST
7028: PPUSH
7029: CALL_OW 69
7033: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7034: LD_EXP 43
7038: PPUSH
7039: LD_VAR 0 4
7043: PUSH
7044: LD_INT 1
7046: ARRAY
7047: PPUSH
7048: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7052: LD_ADDR_VAR 0 3
7056: PUSH
7057: LD_EXP 4
7061: PPUSH
7062: LD_INT 25
7064: PUSH
7065: LD_INT 1
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: PPUSH
7072: CALL_OW 72
7076: PPUSH
7077: LD_EXP 33
7081: PPUSH
7082: CALL_OW 74
7086: ST_TO_ADDR
// if sol then
7087: LD_VAR 0 3
7091: IFFALSE 7131
// if GetDistUnits ( JMM , sol ) < 10 then
7093: LD_EXP 33
7097: PPUSH
7098: LD_VAR 0 3
7102: PPUSH
7103: CALL_OW 296
7107: PUSH
7108: LD_INT 10
7110: LESS
7111: IFFALSE 7131
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7113: LD_VAR 0 3
7117: PPUSH
7118: LD_VAR 0 4
7122: PUSH
7123: LD_INT 2
7125: ARRAY
7126: PPUSH
7127: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7131: LD_INT 10
7133: PPUSH
7134: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7138: LD_EXP 33
7142: PPUSH
7143: LD_INT 65
7145: PPUSH
7146: LD_INT 101
7148: PPUSH
7149: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7153: LD_EXP 33
7157: PPUSH
7158: LD_INT 63
7160: PPUSH
7161: LD_INT 100
7163: PPUSH
7164: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
7168: LD_INT 35
7170: PPUSH
7171: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
7175: LD_EXP 33
7179: PPUSH
7180: LD_INT 65
7182: PPUSH
7183: LD_INT 101
7185: PPUSH
7186: CALL_OW 307
7190: IFFALSE 7168
// Say ( JMM , D2a-JMM-1 ) ;
7192: LD_EXP 33
7196: PPUSH
7197: LD_STRING D2a-JMM-1
7199: PPUSH
7200: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7204: LD_EXP 44
7208: PPUSH
7209: LD_INT 66
7211: PPUSH
7212: LD_INT 103
7214: PPUSH
7215: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
7219: LD_INT 35
7221: PPUSH
7222: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
7226: LD_EXP 44
7230: PPUSH
7231: LD_INT 66
7233: PPUSH
7234: LD_INT 103
7236: PPUSH
7237: CALL_OW 307
7241: IFFALSE 7219
// ComTurnUnit ( Walker , JMM ) ;
7243: LD_EXP 44
7247: PPUSH
7248: LD_EXP 33
7252: PPUSH
7253: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7257: LD_EXP 44
7261: PPUSH
7262: LD_STRING D2a-Sci1-1
7264: PPUSH
7265: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7269: LD_EXP 33
7273: PPUSH
7274: LD_EXP 44
7278: PPUSH
7279: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7283: LD_EXP 33
7287: PPUSH
7288: LD_STRING D2a-JMM-2
7290: PPUSH
7291: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7295: LD_EXP 44
7299: PPUSH
7300: LD_STRING D2a-Sci1-2
7302: PPUSH
7303: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7307: LD_EXP 33
7311: PPUSH
7312: LD_STRING D2a-JMM-3
7314: PPUSH
7315: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7319: LD_EXP 44
7323: PPUSH
7324: LD_STRING D2a-Sci1-3
7326: PPUSH
7327: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7331: LD_ADDR_EXP 4
7335: PUSH
7336: LD_EXP 4
7340: PUSH
7341: LD_EXP 43
7345: PUSH
7346: LD_EXP 44
7350: PUSH
7351: LD_EXP 45
7355: PUSH
7356: LD_EXP 46
7360: PUSH
7361: EMPTY
7362: LIST
7363: LIST
7364: LIST
7365: LIST
7366: ADD
7367: ST_TO_ADDR
// for i in jmm_units do
7368: LD_ADDR_VAR 0 1
7372: PUSH
7373: LD_EXP 4
7377: PUSH
7378: FOR_IN
7379: IFFALSE 7404
// if not IsInUnit ( i ) then
7381: LD_VAR 0 1
7385: PPUSH
7386: CALL_OW 310
7390: NOT
7391: IFFALSE 7402
// ComFree ( i ) ;
7393: LD_VAR 0 1
7397: PPUSH
7398: CALL_OW 139
7402: GO 7378
7404: POP
7405: POP
// InGameOff ;
7406: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
7410: LD_STRING MSolar1
7412: PPUSH
7413: CALL_OW 337
// jmm_on_west := true ;
7417: LD_ADDR_EXP 5
7421: PUSH
7422: LD_INT 1
7424: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7425: LD_INT 1050
7427: PPUSH
7428: CALL_OW 67
// frank_can_return := true ;
7432: LD_ADDR_EXP 12
7436: PUSH
7437: LD_INT 1
7439: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7440: LD_INT 6300
7442: PPUSH
7443: LD_INT 8400
7445: PPUSH
7446: CALL_OW 12
7450: PPUSH
7451: CALL_OW 67
// send_spec_patrol := true ;
7455: LD_ADDR_EXP 28
7459: PUSH
7460: LD_INT 1
7462: ST_TO_ADDR
// end ;
7463: PPOPN 4
7465: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7466: LD_INT 22
7468: PUSH
7469: LD_INT 1
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: PUSH
7476: LD_INT 34
7478: PUSH
7479: LD_INT 51
7481: PUSH
7482: EMPTY
7483: LIST
7484: LIST
7485: PUSH
7486: LD_INT 92
7488: PUSH
7489: LD_INT 63
7491: PUSH
7492: LD_INT 100
7494: PUSH
7495: LD_INT 5
7497: PUSH
7498: EMPTY
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: PUSH
7504: EMPTY
7505: LIST
7506: LIST
7507: LIST
7508: PUSH
7509: EMPTY
7510: LIST
7511: PPUSH
7512: CALL_OW 69
7516: PUSH
7517: LD_EXP 5
7521: NOT
7522: AND
7523: IFFALSE 7636
7525: GO 7527
7527: DISABLE
7528: LD_INT 0
7530: PPUSH
7531: PPUSH
// begin enable ;
7532: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
7533: LD_ADDR_VAR 0 2
7537: PUSH
7538: LD_INT 22
7540: PUSH
7541: LD_INT 1
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PUSH
7548: LD_INT 34
7550: PUSH
7551: LD_INT 51
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: PUSH
7558: LD_INT 92
7560: PUSH
7561: LD_INT 63
7563: PUSH
7564: LD_INT 100
7566: PUSH
7567: LD_INT 5
7569: PUSH
7570: EMPTY
7571: LIST
7572: LIST
7573: LIST
7574: LIST
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: LIST
7580: PUSH
7581: EMPTY
7582: LIST
7583: PPUSH
7584: CALL_OW 69
7588: ST_TO_ADDR
// if not filter then
7589: LD_VAR 0 2
7593: NOT
7594: IFFALSE 7598
// exit ;
7596: GO 7636
// for i in filter do
7598: LD_ADDR_VAR 0 1
7602: PUSH
7603: LD_VAR 0 2
7607: PUSH
7608: FOR_IN
7609: IFFALSE 7634
// begin SetFuel ( i , 0 ) ;
7611: LD_VAR 0 1
7615: PPUSH
7616: LD_INT 0
7618: PPUSH
7619: CALL_OW 240
// ComStop ( i ) ;
7623: LD_VAR 0 1
7627: PPUSH
7628: CALL_OW 141
// end ;
7632: GO 7608
7634: POP
7635: POP
// end ;
7636: PPOPN 2
7638: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
7639: LD_EXP 28
7643: IFFALSE 8608
7645: GO 7647
7647: DISABLE
7648: LD_INT 0
7650: PPUSH
7651: PPUSH
7652: PPUSH
7653: PPUSH
7654: PPUSH
7655: PPUSH
7656: PPUSH
// begin if not ru_spec_patrol then
7657: LD_EXP 50
7661: NOT
7662: IFFALSE 7666
// exit ;
7664: GO 8608
// dead1 := false ;
7666: LD_ADDR_VAR 0 1
7670: PUSH
7671: LD_INT 0
7673: ST_TO_ADDR
// dead2 := false ;
7674: LD_ADDR_VAR 0 2
7678: PUSH
7679: LD_INT 0
7681: ST_TO_ADDR
// inarea1 := false ;
7682: LD_ADDR_VAR 0 3
7686: PUSH
7687: LD_INT 0
7689: ST_TO_ADDR
// inarea2 := false ;
7690: LD_ADDR_VAR 0 4
7694: PUSH
7695: LD_INT 0
7697: ST_TO_ADDR
// tmp := [ ] ;
7698: LD_ADDR_VAR 0 6
7702: PUSH
7703: EMPTY
7704: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
7705: LD_EXP 50
7709: PPUSH
7710: LD_INT 75
7712: PPUSH
7713: LD_INT 101
7715: PPUSH
7716: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
7720: LD_INT 35
7722: PPUSH
7723: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
7727: LD_INT 1
7729: PPUSH
7730: LD_EXP 50
7734: PUSH
7735: LD_INT 1
7737: ARRAY
7738: PPUSH
7739: CALL_OW 292
7743: IFFALSE 7720
// ComStop ( ru_spec_patrol ) ;
7745: LD_EXP 50
7749: PPUSH
7750: CALL_OW 141
// Wait ( 0 0$02 ) ;
7754: LD_INT 70
7756: PPUSH
7757: CALL_OW 67
// DialogueOn ;
7761: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
7765: LD_EXP 50
7769: PUSH
7770: LD_INT 1
7772: ARRAY
7773: PPUSH
7774: LD_STRING D8-Rus1-1
7776: PPUSH
7777: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
7781: LD_EXP 33
7785: PPUSH
7786: LD_STRING D8-JMM-1
7788: PPUSH
7789: CALL_OW 88
// DialogueOff ;
7793: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
7797: LD_EXP 50
7801: PPUSH
7802: LD_INT 13
7804: PPUSH
7805: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
7809: LD_INT 35
7811: PPUSH
7812: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
7816: LD_VAR 0 1
7820: NOT
7821: PUSH
7822: LD_EXP 50
7826: PUSH
7827: LD_INT 1
7829: ARRAY
7830: PPUSH
7831: CALL_OW 301
7835: AND
7836: IFFALSE 7846
// dead1 := true ;
7838: LD_ADDR_VAR 0 1
7842: PUSH
7843: LD_INT 1
7845: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
7846: LD_VAR 0 2
7850: NOT
7851: PUSH
7852: LD_EXP 50
7856: PUSH
7857: LD_INT 2
7859: ARRAY
7860: PPUSH
7861: CALL_OW 301
7865: AND
7866: IFFALSE 7876
// dead2 := true ;
7868: LD_ADDR_VAR 0 2
7872: PUSH
7873: LD_INT 1
7875: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
7876: LD_VAR 0 3
7880: NOT
7881: PUSH
7882: LD_EXP 50
7886: PUSH
7887: LD_INT 1
7889: ARRAY
7890: PPUSH
7891: LD_INT 14
7893: PPUSH
7894: CALL_OW 308
7898: AND
7899: IFFALSE 7909
// inarea1 := true ;
7901: LD_ADDR_VAR 0 3
7905: PUSH
7906: LD_INT 1
7908: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
7909: LD_VAR 0 4
7913: NOT
7914: PUSH
7915: LD_EXP 50
7919: PUSH
7920: LD_INT 2
7922: ARRAY
7923: PPUSH
7924: LD_INT 14
7926: PPUSH
7927: CALL_OW 308
7931: AND
7932: IFFALSE 7942
// inarea2 := true ;
7934: LD_ADDR_VAR 0 4
7938: PUSH
7939: LD_INT 1
7941: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
7942: LD_VAR 0 1
7946: PUSH
7947: LD_VAR 0 2
7951: AND
7952: PUSH
7953: LD_VAR 0 1
7957: PUSH
7958: LD_VAR 0 4
7962: AND
7963: OR
7964: PUSH
7965: LD_VAR 0 2
7969: PUSH
7970: LD_VAR 0 3
7974: AND
7975: OR
7976: PUSH
7977: LD_VAR 0 3
7981: PUSH
7982: LD_VAR 0 4
7986: AND
7987: OR
7988: IFFALSE 7809
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
7990: LD_VAR 0 3
7994: PUSH
7995: LD_VAR 0 4
7999: AND
8000: PUSH
8001: LD_VAR 0 1
8005: PUSH
8006: LD_VAR 0 4
8010: AND
8011: OR
8012: PUSH
8013: LD_VAR 0 2
8017: PUSH
8018: LD_VAR 0 3
8022: AND
8023: OR
8024: IFFALSE 8588
// begin prepare_siege := true ;
8026: LD_ADDR_EXP 29
8030: PUSH
8031: LD_INT 1
8033: ST_TO_ADDR
// DialogueOn ;
8034: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8038: LD_VAR 0 3
8042: PUSH
8043: LD_VAR 0 4
8047: AND
8048: IFFALSE 8064
// Say ( JMM , D8b-JMM-1a ) else
8050: LD_EXP 33
8054: PPUSH
8055: LD_STRING D8b-JMM-1a
8057: PPUSH
8058: CALL_OW 88
8062: GO 8076
// Say ( JMM , D8b-JMM-1 ) ;
8064: LD_EXP 33
8068: PPUSH
8069: LD_STRING D8b-JMM-1
8071: PPUSH
8072: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8076: LD_EXP 4
8080: PPUSH
8081: LD_INT 26
8083: PUSH
8084: LD_INT 1
8086: PUSH
8087: EMPTY
8088: LIST
8089: LIST
8090: PPUSH
8091: CALL_OW 72
8095: PUSH
8096: LD_EXP 34
8100: PUSH
8101: LD_EXP 35
8105: PUSH
8106: LD_EXP 44
8110: PUSH
8111: LD_EXP 47
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: LIST
8120: LIST
8121: DIFF
8122: PPUSH
8123: LD_STRING D8b-Sol1-1
8125: PPUSH
8126: CALL 601 0 2
// if Cyrus and Cyrus in jmm_units then
8130: LD_EXP 35
8134: PUSH
8135: LD_EXP 35
8139: PUSH
8140: LD_EXP 4
8144: IN
8145: AND
8146: IFFALSE 8162
// Say ( Cyrus , D8b-Cyrus-1 ) else
8148: LD_EXP 35
8152: PPUSH
8153: LD_STRING D8b-Cyrus-1
8155: PPUSH
8156: CALL_OW 88
8160: GO 8174
// Say ( JMM , D8b-JMM-1a ) ;
8162: LD_EXP 33
8166: PPUSH
8167: LD_STRING D8b-JMM-1a
8169: PPUSH
8170: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8174: LD_EXP 36
8178: PUSH
8179: LD_EXP 36
8183: PUSH
8184: LD_EXP 4
8188: IN
8189: AND
8190: IFFALSE 8204
// Say ( Lisa , D8b-Lisa-2 ) ;
8192: LD_EXP 36
8196: PPUSH
8197: LD_STRING D8b-Lisa-2
8199: PPUSH
8200: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8204: LD_EXP 34
8208: PUSH
8209: LD_EXP 34
8213: PUSH
8214: LD_EXP 4
8218: IN
8219: AND
8220: IFFALSE 8236
// Say ( Bobby , D8b-Bobby-1 ) else
8222: LD_EXP 34
8226: PPUSH
8227: LD_STRING D8b-Bobby-1
8229: PPUSH
8230: CALL_OW 88
8234: GO 8296
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8236: LD_ADDR_VAR 0 5
8240: PUSH
8241: LD_EXP 4
8245: PPUSH
8246: LD_INT 26
8248: PUSH
8249: LD_INT 1
8251: PUSH
8252: EMPTY
8253: LIST
8254: LIST
8255: PPUSH
8256: CALL_OW 72
8260: PUSH
8261: LD_EXP 34
8265: PUSH
8266: LD_EXP 35
8270: PUSH
8271: LD_EXP 44
8275: PUSH
8276: LD_EXP 47
8280: PUSH
8281: EMPTY
8282: LIST
8283: LIST
8284: LIST
8285: LIST
8286: DIFF
8287: PPUSH
8288: LD_STRING D8b-Sol2-1
8290: PPUSH
8291: CALL 601 0 2
8295: ST_TO_ADDR
// DialogueOff ;
8296: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8300: LD_EXP 35
8304: PUSH
8305: LD_EXP 35
8309: PUSH
8310: LD_EXP 4
8314: IN
8315: AND
8316: IFFALSE 8341
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8318: LD_ADDR_VAR 0 6
8322: PUSH
8323: LD_VAR 0 6
8327: PPUSH
8328: LD_INT 1
8330: PPUSH
8331: LD_EXP 35
8335: PPUSH
8336: CALL_OW 2
8340: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8341: LD_EXP 34
8345: PUSH
8346: LD_EXP 34
8350: PUSH
8351: LD_EXP 4
8355: IN
8356: AND
8357: IFFALSE 8382
// tmp := Insert ( tmp , 1 , Bobby ) ;
8359: LD_ADDR_VAR 0 6
8363: PUSH
8364: LD_VAR 0 6
8368: PPUSH
8369: LD_INT 1
8371: PPUSH
8372: LD_EXP 34
8376: PPUSH
8377: CALL_OW 2
8381: ST_TO_ADDR
// if sol then
8382: LD_VAR 0 5
8386: IFFALSE 8411
// tmp := Insert ( tmp , 1 , sol ) ;
8388: LD_ADDR_VAR 0 6
8392: PUSH
8393: LD_VAR 0 6
8397: PPUSH
8398: LD_INT 1
8400: PPUSH
8401: LD_VAR 0 5
8405: PPUSH
8406: CALL_OW 2
8410: ST_TO_ADDR
// if tmp then
8411: LD_VAR 0 6
8415: IFFALSE 8547
// begin SetSide ( tmp , 8 ) ;
8417: LD_VAR 0 6
8421: PPUSH
8422: LD_INT 8
8424: PPUSH
8425: CALL_OW 235
// ComFree ( tmp ) ;
8429: LD_VAR 0 6
8433: PPUSH
8434: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8438: LD_VAR 0 6
8442: PPUSH
8443: LD_INT 15
8445: PPUSH
8446: CALL_OW 173
// AddComHold ( tmp ) ;
8450: LD_VAR 0 6
8454: PPUSH
8455: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8459: LD_INT 35
8461: PPUSH
8462: CALL_OW 67
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8466: LD_VAR 0 6
8470: PUSH
8471: LD_INT 1
8473: ARRAY
8474: PPUSH
8475: LD_INT 15
8477: PPUSH
8478: CALL_OW 308
8482: IFFALSE 8537
// begin RemoveUnit ( tmp [ 1 ] ) ;
8484: LD_VAR 0 6
8488: PUSH
8489: LD_INT 1
8491: ARRAY
8492: PPUSH
8493: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
8497: LD_ADDR_EXP 4
8501: PUSH
8502: LD_EXP 4
8506: PUSH
8507: LD_VAR 0 6
8511: PUSH
8512: LD_INT 1
8514: ARRAY
8515: DIFF
8516: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
8517: LD_ADDR_VAR 0 6
8521: PUSH
8522: LD_VAR 0 6
8526: PUSH
8527: LD_VAR 0 6
8531: PUSH
8532: LD_INT 1
8534: ARRAY
8535: DIFF
8536: ST_TO_ADDR
// end ; until tmp = 0 ;
8537: LD_VAR 0 6
8541: PUSH
8542: LD_INT 0
8544: EQUAL
8545: IFFALSE 8459
// end ; Wait ( 0 0$30 ) ;
8547: LD_INT 1050
8549: PPUSH
8550: CALL_OW 67
// if ru_spec_patrol then
8554: LD_EXP 50
8558: IFFALSE 8586
// for i in ru_spec_patrol do
8560: LD_ADDR_VAR 0 7
8564: PUSH
8565: LD_EXP 50
8569: PUSH
8570: FOR_IN
8571: IFFALSE 8584
// RemoveUnit ( i ) ;
8573: LD_VAR 0 7
8577: PPUSH
8578: CALL_OW 64
8582: GO 8570
8584: POP
8585: POP
// end else
8586: GO 8608
// begin prepare_siege := false ;
8588: LD_ADDR_EXP 29
8592: PUSH
8593: LD_INT 0
8595: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
8596: LD_EXP 33
8600: PPUSH
8601: LD_STRING D8a-JMM-1
8603: PPUSH
8604: CALL_OW 88
// end ; end ;
8608: PPOPN 7
8610: END
// every 0 0$10 trigger frank_can_return do var i , points ;
8611: LD_EXP 12
8615: IFFALSE 9749
8617: GO 8619
8619: DISABLE
8620: LD_INT 0
8622: PPUSH
8623: PPUSH
// begin uc_side := 8 ;
8624: LD_ADDR_OWVAR 20
8628: PUSH
8629: LD_INT 8
8631: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
8632: LD_ADDR_VAR 0 2
8636: PUSH
8637: LD_INT 59
8639: PUSH
8640: LD_INT 71
8642: PUSH
8643: EMPTY
8644: LIST
8645: LIST
8646: PUSH
8647: LD_INT 122
8649: PUSH
8650: LD_INT 117
8652: PUSH
8653: EMPTY
8654: LIST
8655: LIST
8656: PUSH
8657: EMPTY
8658: LIST
8659: LIST
8660: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
8661: LD_ADDR_EXP 47
8665: PUSH
8666: LD_STRING Frank
8668: PPUSH
8669: LD_INT 0
8671: PPUSH
8672: CALL 450 0 2
8676: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
8677: LD_ADDR_VAR 0 1
8681: PUSH
8682: LD_INT 1
8684: PPUSH
8685: LD_INT 2
8687: PPUSH
8688: CALL_OW 12
8692: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
8693: LD_EXP 47
8697: PPUSH
8698: LD_VAR 0 2
8702: PUSH
8703: LD_VAR 0 1
8707: ARRAY
8708: PUSH
8709: LD_INT 1
8711: ARRAY
8712: PPUSH
8713: LD_VAR 0 2
8717: PUSH
8718: LD_VAR 0 1
8722: ARRAY
8723: PUSH
8724: LD_INT 2
8726: ARRAY
8727: PPUSH
8728: LD_INT 0
8730: PPUSH
8731: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
8735: LD_EXP 47
8739: PPUSH
8740: LD_INT 1
8742: PPUSH
8743: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
8747: LD_INT 35
8749: PPUSH
8750: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
8754: LD_EXP 47
8758: PPUSH
8759: LD_EXP 33
8763: PPUSH
8764: CALL_OW 296
8768: PUSH
8769: LD_INT 8
8771: LESS
8772: IFFALSE 8747
// InGameOn ;
8774: CALL_OW 8
// CenterOnUnits ( JMM ) ;
8778: LD_EXP 33
8782: PPUSH
8783: CALL_OW 85
// if IsInUnit ( JMM ) then
8787: LD_EXP 33
8791: PPUSH
8792: CALL_OW 310
8796: IFFALSE 8807
// ComFree ( JMM ) ;
8798: LD_EXP 33
8802: PPUSH
8803: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
8807: LD_EXP 33
8811: PPUSH
8812: LD_EXP 47
8816: PPUSH
8817: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
8821: LD_EXP 47
8825: PPUSH
8826: LD_EXP 33
8830: PPUSH
8831: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
8835: LD_EXP 33
8839: PPUSH
8840: LD_STRING D6-JMM-1
8842: PPUSH
8843: CALL_OW 88
// repeat wait ( 3 ) ;
8847: LD_INT 3
8849: PPUSH
8850: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
8854: LD_EXP 33
8858: PPUSH
8859: LD_EXP 47
8863: PPUSH
8864: CALL_OW 296
8868: PUSH
8869: LD_INT 8
8871: LESS
8872: IFFALSE 8847
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
8874: LD_EXP 36
8878: PUSH
8879: LD_EXP 36
8883: PPUSH
8884: LD_EXP 47
8888: PPUSH
8889: CALL_OW 296
8893: PUSH
8894: LD_INT 20
8896: LESS
8897: AND
8898: IFFALSE 8923
// begin ComFree ( Lisa ) ;
8900: LD_EXP 36
8904: PPUSH
8905: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
8909: LD_EXP 36
8913: PPUSH
8914: LD_EXP 47
8918: PPUSH
8919: CALL_OW 172
// end ; if Lynch then
8923: LD_EXP 43
8927: IFFALSE 8952
// begin ComFree ( Lynch ) ;
8929: LD_EXP 43
8933: PPUSH
8934: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
8938: LD_EXP 43
8942: PPUSH
8943: LD_EXP 47
8947: PPUSH
8948: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
8952: LD_EXP 33
8956: PPUSH
8957: LD_EXP 47
8961: PPUSH
8962: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
8966: LD_EXP 47
8970: PPUSH
8971: LD_EXP 33
8975: PPUSH
8976: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
8980: LD_EXP 47
8984: PPUSH
8985: LD_STRING D6-Frank-1
8987: PPUSH
8988: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
8992: LD_INT 69
8994: PPUSH
8995: LD_INT 20
8997: PPUSH
8998: LD_INT 1
9000: PPUSH
9001: LD_INT 20
9003: NEG
9004: PPUSH
9005: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9009: LD_INT 69
9011: PPUSH
9012: LD_INT 20
9014: PPUSH
9015: LD_INT 1
9017: PPUSH
9018: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9022: LD_INT 190
9024: PPUSH
9025: LD_INT 31
9027: PPUSH
9028: LD_INT 1
9030: PPUSH
9031: LD_INT 20
9033: NEG
9034: PPUSH
9035: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9039: LD_INT 190
9041: PPUSH
9042: LD_INT 31
9044: PPUSH
9045: LD_INT 1
9047: PPUSH
9048: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9052: LD_INT 69
9054: PPUSH
9055: LD_INT 20
9057: PPUSH
9058: CALL_OW 84
// Wait ( 0 0$02 ) ;
9062: LD_INT 70
9064: PPUSH
9065: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9069: LD_EXP 33
9073: PPUSH
9074: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9078: LD_EXP 36
9082: PUSH
9083: LD_EXP 36
9087: PPUSH
9088: LD_EXP 47
9092: PPUSH
9093: CALL_OW 296
9097: PUSH
9098: LD_INT 20
9100: LESS
9101: AND
9102: PUSH
9103: LD_EXP 36
9107: PPUSH
9108: CALL_OW 302
9112: AND
9113: IFFALSE 9203
// begin ComFree ( Lisa ) ;
9115: LD_EXP 36
9119: PPUSH
9120: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
9124: LD_INT 35
9126: PPUSH
9127: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
9131: LD_EXP 36
9135: PPUSH
9136: LD_EXP 47
9140: PPUSH
9141: CALL_OW 296
9145: PUSH
9146: LD_INT 7
9148: LESS
9149: IFFALSE 9124
// Say ( Lisa , D6-Lisa-1 ) ;
9151: LD_EXP 36
9155: PPUSH
9156: LD_STRING D6-Lisa-1
9158: PPUSH
9159: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9163: LD_EXP 36
9167: PPUSH
9168: LD_EXP 47
9172: PPUSH
9173: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9177: LD_EXP 47
9181: PPUSH
9182: LD_EXP 36
9186: PPUSH
9187: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9191: LD_EXP 47
9195: PPUSH
9196: LD_STRING D6-Frank-2
9198: PPUSH
9199: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9203: LD_EXP 43
9207: PUSH
9208: LD_EXP 43
9212: PPUSH
9213: LD_EXP 47
9217: PPUSH
9218: CALL_OW 296
9222: PUSH
9223: LD_INT 20
9225: LESS
9226: AND
9227: PUSH
9228: LD_EXP 43
9232: PPUSH
9233: CALL_OW 302
9237: AND
9238: IFFALSE 9419
// begin ComTurnUnit ( Lynch , JMM ) ;
9240: LD_EXP 43
9244: PPUSH
9245: LD_EXP 33
9249: PPUSH
9250: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9254: LD_EXP 47
9258: PPUSH
9259: LD_EXP 33
9263: PPUSH
9264: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9268: LD_EXP 43
9272: PPUSH
9273: LD_STRING D6-Sol1-2
9275: PPUSH
9276: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9280: LD_EXP 33
9284: PPUSH
9285: LD_STRING D6-JMM-2
9287: PPUSH
9288: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9292: LD_EXP 47
9296: PPUSH
9297: LD_STRING D6-Frank-3
9299: PPUSH
9300: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9304: LD_EXP 33
9308: PPUSH
9309: LD_STRING D6-JMM-3
9311: PPUSH
9312: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9316: LD_EXP 47
9320: PPUSH
9321: LD_STRING D6-Frank-4
9323: PPUSH
9324: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9328: LD_EXP 47
9332: PPUSH
9333: LD_STRING D6-Frank-4a
9335: PPUSH
9336: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9340: LD_EXP 33
9344: PPUSH
9345: LD_STRING D6-JMM-4
9347: PPUSH
9348: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9352: LD_EXP 47
9356: PPUSH
9357: LD_STRING D6-Frank-5
9359: PPUSH
9360: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9364: LD_EXP 36
9368: PUSH
9369: LD_EXP 36
9373: PPUSH
9374: CALL_OW 302
9378: AND
9379: IFFALSE 9393
// Say ( Lisa , D6-Lisa-5 ) ;
9381: LD_EXP 36
9385: PPUSH
9386: LD_STRING D6-Lisa-5
9388: PPUSH
9389: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9393: LD_EXP 47
9397: PPUSH
9398: LD_STRING D6-Frank-6
9400: PPUSH
9401: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9405: LD_EXP 33
9409: PPUSH
9410: LD_STRING D6-JMM-6
9412: PPUSH
9413: CALL_OW 88
// end else
9417: GO 9534
// begin ComTurnUnit ( Frank , JMM ) ;
9419: LD_EXP 47
9423: PPUSH
9424: LD_EXP 33
9428: PPUSH
9429: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
9433: LD_EXP 47
9437: PPUSH
9438: LD_STRING D6-Frank-4
9440: PPUSH
9441: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9445: LD_EXP 47
9449: PPUSH
9450: LD_STRING D6-Frank-4a
9452: PPUSH
9453: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9457: LD_EXP 33
9461: PPUSH
9462: LD_STRING D6-JMM-4
9464: PPUSH
9465: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9469: LD_EXP 47
9473: PPUSH
9474: LD_STRING D6-Frank-5
9476: PPUSH
9477: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9481: LD_EXP 36
9485: PUSH
9486: LD_EXP 36
9490: PPUSH
9491: CALL_OW 302
9495: AND
9496: IFFALSE 9510
// Say ( Lisa , D6-Lisa-5 ) ;
9498: LD_EXP 36
9502: PPUSH
9503: LD_STRING D6-Lisa-5
9505: PPUSH
9506: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9510: LD_EXP 47
9514: PPUSH
9515: LD_STRING D6-Frank-6
9517: PPUSH
9518: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9522: LD_EXP 33
9526: PPUSH
9527: LD_STRING D6-JMM-6
9529: PPUSH
9530: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
9534: LD_STRING Q1
9536: PPUSH
9537: CALL_OW 97
9541: PUSH
9542: LD_INT 1
9544: DOUBLE
9545: EQUAL
9546: IFTRUE 9550
9548: GO 9561
9550: POP
// frank_send_to_scout := true ; 2 :
9551: LD_ADDR_EXP 14
9555: PUSH
9556: LD_INT 1
9558: ST_TO_ADDR
9559: GO 9581
9561: LD_INT 2
9563: DOUBLE
9564: EQUAL
9565: IFTRUE 9569
9567: GO 9580
9569: POP
// frank_send_to_scout := false ; end ;
9570: LD_ADDR_EXP 14
9574: PUSH
9575: LD_INT 0
9577: ST_TO_ADDR
9578: GO 9581
9580: POP
// InGameOff ;
9581: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
9585: LD_EXP 33
9589: PUSH
9590: LD_EXP 36
9594: PUSH
9595: LD_EXP 43
9599: PUSH
9600: EMPTY
9601: LIST
9602: LIST
9603: LIST
9604: PPUSH
9605: CALL_OW 139
// if frank_send_to_scout then
9609: LD_EXP 14
9613: IFFALSE 9670
// begin ComMoveXY ( Frank , 130 , 123 ) ;
9615: LD_EXP 47
9619: PPUSH
9620: LD_INT 130
9622: PPUSH
9623: LD_INT 123
9625: PPUSH
9626: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
9630: LD_INT 35
9632: PPUSH
9633: CALL_OW 67
// until not See ( 1 , Frank ) ;
9637: LD_INT 1
9639: PPUSH
9640: LD_EXP 47
9644: PPUSH
9645: CALL_OW 292
9649: NOT
9650: IFFALSE 9630
// Wait ( 0 0$02 ) ;
9652: LD_INT 70
9654: PPUSH
9655: CALL_OW 67
// RemoveUnit ( Frank ) ;
9659: LD_EXP 47
9663: PPUSH
9664: CALL_OW 64
// end else
9668: GO 9682
// SetSide ( Frank , 1 ) ;
9670: LD_EXP 47
9674: PPUSH
9675: LD_INT 1
9677: PPUSH
9678: CALL_OW 235
// send_attack_on_cornel_base := true ;
9682: LD_ADDR_EXP 25
9686: PUSH
9687: LD_INT 1
9689: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9690: LD_INT 35
9692: PPUSH
9693: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
9697: LD_ADDR_EXP 27
9701: PUSH
9702: LD_EXP 27
9706: PPUSH
9707: LD_STRING -
9709: PPUSH
9710: CALL 1093 0 2
9714: ST_TO_ADDR
// if debug then
9715: LD_EXP 1
9719: IFFALSE 9731
// debug_strings := time_to_prepare ;
9721: LD_ADDR_OWVAR 48
9725: PUSH
9726: LD_EXP 27
9730: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
9731: LD_EXP 27
9735: PUSH
9736: LD_INT 0
9738: EQUAL
9739: IFFALSE 9690
// cornel_prepared := true ;
9741: LD_ADDR_EXP 11
9745: PUSH
9746: LD_INT 1
9748: ST_TO_ADDR
// end ;
9749: PPOPN 2
9751: END
// every 0 0$01 trigger cornel_prepared do
9752: LD_EXP 11
9756: IFFALSE 10002
9758: GO 9760
9760: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
9761: LD_EXP 40
9765: PPUSH
9766: LD_STRING D3-Corn-1
9768: PPUSH
9769: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
9773: LD_INT 35
9775: PPUSH
9776: CALL_OW 67
// until cornel_counter = 0 ;
9780: LD_EXP 10
9784: PUSH
9785: LD_INT 0
9787: EQUAL
9788: IFFALSE 9773
// SayRadio ( Cornel , D3a-Corn-1 ) ;
9790: LD_EXP 40
9794: PPUSH
9795: LD_STRING D3a-Corn-1
9797: PPUSH
9798: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
9802: LD_EXP 33
9806: PPUSH
9807: LD_STRING D3a-JMM-1
9809: PPUSH
9810: CALL_OW 88
// end_mission_allowed := true ;
9814: LD_ADDR_EXP 20
9818: PUSH
9819: LD_INT 1
9821: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
9822: LD_STRING M2
9824: PPUSH
9825: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
9829: LD_INT 9
9831: PPUSH
9832: LD_INT 1
9834: PPUSH
9835: CALL_OW 424
// Wait ( 0 0$05 ) ;
9839: LD_INT 175
9841: PPUSH
9842: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
9846: LD_EXP 40
9850: PPUSH
9851: LD_STRING D3a-Corn-2
9853: PPUSH
9854: CALL_OW 94
// cornel_attack := true ;
9858: LD_ADDR_EXP 9
9862: PUSH
9863: LD_INT 1
9865: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
9866: LD_INT 105
9868: PPUSH
9869: CALL_OW 67
// AddMoreTanks ( ) ;
9873: CALL 4751 0 0
// if frank_send_to_scout then
9877: LD_EXP 14
9881: IFFALSE 10002
// begin InitHc ;
9883: CALL_OW 19
// InitUc ;
9887: CALL_OW 18
// uc_side := 8 ;
9891: LD_ADDR_OWVAR 20
9895: PUSH
9896: LD_INT 8
9898: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9899: LD_ADDR_EXP 47
9903: PUSH
9904: LD_STRING Frank
9906: PPUSH
9907: LD_INT 0
9909: PPUSH
9910: CALL 450 0 2
9914: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
9915: LD_EXP 47
9919: PPUSH
9920: LD_INT 6
9922: PPUSH
9923: LD_INT 9
9925: PPUSH
9926: LD_INT 0
9928: PPUSH
9929: CALL_OW 48
// ComCrawl ( Frank ) ;
9933: LD_EXP 47
9937: PPUSH
9938: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
9942: LD_INT 35
9944: PPUSH
9945: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
9949: LD_EXP 33
9953: PPUSH
9954: LD_EXP 47
9958: PPUSH
9959: CALL_OW 296
9963: PUSH
9964: LD_INT 9
9966: LESS
9967: IFFALSE 9942
// SetSide ( Frank , 1 ) ;
9969: LD_EXP 47
9973: PPUSH
9974: LD_INT 1
9976: PPUSH
9977: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
9981: LD_EXP 47
9985: PPUSH
9986: LD_STRING D6a-Frank-1
9988: PPUSH
9989: CALL_OW 88
// ComWalk ( Frank ) ;
9993: LD_EXP 47
9997: PPUSH
9998: CALL_OW 138
// end ; end ;
10002: END
// every 0 0$01 trigger solar_builded do
10003: LD_EXP 13
10007: IFFALSE 10111
10009: GO 10011
10011: DISABLE
// begin Wait ( 0 0$02 ) ;
10012: LD_INT 70
10014: PPUSH
10015: CALL_OW 67
// DialogueOn ;
10019: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10023: LD_EXP 33
10027: PPUSH
10028: LD_STRING D2b-JMM-1
10030: PPUSH
10031: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10035: LD_EXP 44
10039: PUSH
10040: LD_EXP 44
10044: PPUSH
10045: CALL_OW 302
10049: AND
10050: IFFALSE 10100
// begin Say ( Walker , D2b-Sci1-1 ) ;
10052: LD_EXP 44
10056: PPUSH
10057: LD_STRING D2b-Sci1-1
10059: PPUSH
10060: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10064: LD_EXP 33
10068: PPUSH
10069: LD_STRING D2b-JMM-2
10071: PPUSH
10072: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10076: LD_EXP 44
10080: PPUSH
10081: LD_STRING D2b-Sci1-2
10083: PPUSH
10084: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10088: LD_EXP 33
10092: PPUSH
10093: LD_STRING D2b-JMM-3
10095: PPUSH
10096: CALL_OW 88
// end ; DialogueOff ;
10100: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10104: LD_STRING MOutSol
10106: PPUSH
10107: CALL_OW 337
// end ;
10111: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10112: LD_EXP 13
10116: PUSH
10117: LD_EXP 33
10121: PPUSH
10122: CALL_OW 302
10126: AND
10127: PUSH
10128: LD_EXP 33
10132: PPUSH
10133: CALL 927 0 1
10137: AND
10138: PUSH
10139: LD_EXP 15
10143: NOT
10144: AND
10145: IFFALSE 10216
10147: GO 10149
10149: DISABLE
10150: LD_INT 0
10152: PPUSH
// begin jmm_in_veh := true ;
10153: LD_ADDR_EXP 15
10157: PUSH
10158: LD_INT 1
10160: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10161: LD_ADDR_VAR 0 1
10165: PUSH
10166: LD_INT 0
10168: PPUSH
10169: LD_INT 1
10171: PPUSH
10172: CALL_OW 12
10176: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10177: LD_INT 70
10179: PPUSH
10180: CALL_OW 67
// if i then
10184: LD_VAR 0 1
10188: IFFALSE 10204
// Say ( JMM , D2c-JMM-1 ) else
10190: LD_EXP 33
10194: PPUSH
10195: LD_STRING D2c-JMM-1
10197: PPUSH
10198: CALL_OW 88
10202: GO 10216
// Say ( JMM , D2c-JMM-1a ) ;
10204: LD_EXP 33
10208: PPUSH
10209: LD_STRING D2c-JMM-1a
10211: PPUSH
10212: CALL_OW 88
// end ;
10216: PPOPN 1
10218: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10219: LD_EXP 13
10223: PUSH
10224: LD_EXP 34
10228: PPUSH
10229: CALL_OW 302
10233: AND
10234: PUSH
10235: LD_EXP 34
10239: PPUSH
10240: CALL 927 0 1
10244: AND
10245: PUSH
10246: LD_EXP 16
10250: NOT
10251: AND
10252: IFFALSE 10284
10254: GO 10256
10256: DISABLE
// begin bobby_in_veh := true ;
10257: LD_ADDR_EXP 16
10261: PUSH
10262: LD_INT 1
10264: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10265: LD_INT 70
10267: PPUSH
10268: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10272: LD_EXP 34
10276: PPUSH
10277: LD_STRING D2c-Bobby-1
10279: PPUSH
10280: CALL_OW 88
10284: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10285: LD_EXP 13
10289: PUSH
10290: LD_EXP 36
10294: PPUSH
10295: CALL_OW 302
10299: AND
10300: PUSH
10301: LD_EXP 36
10305: PPUSH
10306: CALL 927 0 1
10310: AND
10311: PUSH
10312: LD_EXP 18
10316: NOT
10317: AND
10318: IFFALSE 10350
10320: GO 10322
10322: DISABLE
// begin lisa_in_veh := true ;
10323: LD_ADDR_EXP 18
10327: PUSH
10328: LD_INT 1
10330: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10331: LD_INT 70
10333: PPUSH
10334: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10338: LD_EXP 36
10342: PPUSH
10343: LD_STRING D2c-Lisa-1
10345: PPUSH
10346: CALL_OW 88
10350: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
10351: LD_EXP 13
10355: PUSH
10356: LD_EXP 35
10360: PPUSH
10361: CALL_OW 302
10365: AND
10366: PUSH
10367: LD_EXP 35
10371: PPUSH
10372: CALL 927 0 1
10376: AND
10377: PUSH
10378: LD_EXP 17
10382: NOT
10383: AND
10384: IFFALSE 10455
10386: GO 10388
10388: DISABLE
10389: LD_INT 0
10391: PPUSH
// begin cyrus_in_veh := true ;
10392: LD_ADDR_EXP 17
10396: PUSH
10397: LD_INT 1
10399: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10400: LD_ADDR_VAR 0 1
10404: PUSH
10405: LD_INT 0
10407: PPUSH
10408: LD_INT 1
10410: PPUSH
10411: CALL_OW 12
10415: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10416: LD_INT 70
10418: PPUSH
10419: CALL_OW 67
// if i then
10423: LD_VAR 0 1
10427: IFFALSE 10443
// Say ( Cyrus , D2c-Cyrus-1 ) else
10429: LD_EXP 35
10433: PPUSH
10434: LD_STRING D2c-Cyrus-1
10436: PPUSH
10437: CALL_OW 88
10441: GO 10455
// Say ( Cyrus , D2c-Cyrus-1a ) ;
10443: LD_EXP 35
10447: PPUSH
10448: LD_STRING D2c-Cyrus-1a
10450: PPUSH
10451: CALL_OW 88
// end ;
10455: PPOPN 1
10457: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
10458: LD_EXP 40
10462: PPUSH
10463: LD_INT 16
10465: PPUSH
10466: CALL_OW 308
10470: IFFALSE 10726
10472: GO 10474
10474: DISABLE
10475: LD_INT 0
10477: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
10478: LD_INT 3
10480: PPUSH
10481: LD_EXP 40
10485: PPUSH
10486: CALL_OW 471
// send_attack_on_cornel := true ;
10490: LD_ADDR_EXP 30
10494: PUSH
10495: LD_INT 1
10497: ST_TO_ADDR
// if ru_vehicles then
10498: LD_EXP 52
10502: IFFALSE 10536
// for i in ru_vehicles do
10504: LD_ADDR_VAR 0 1
10508: PUSH
10509: LD_EXP 52
10513: PUSH
10514: FOR_IN
10515: IFFALSE 10534
// ComAgressiveMove ( i , 215 , 69 ) ;
10517: LD_VAR 0 1
10521: PPUSH
10522: LD_INT 215
10524: PPUSH
10525: LD_INT 69
10527: PPUSH
10528: CALL_OW 114
10532: GO 10514
10534: POP
10535: POP
// if ru_patrol then
10536: LD_EXP 49
10540: IFFALSE 10574
// for i in ru_patrol do
10542: LD_ADDR_VAR 0 1
10546: PUSH
10547: LD_EXP 49
10551: PUSH
10552: FOR_IN
10553: IFFALSE 10572
// ComAgressiveMove ( i , 215 , 69 ) ;
10555: LD_VAR 0 1
10559: PPUSH
10560: LD_INT 215
10562: PPUSH
10563: LD_INT 69
10565: PPUSH
10566: CALL_OW 114
10570: GO 10552
10572: POP
10573: POP
// if frank_send_to_scout then
10574: LD_EXP 14
10578: IFFALSE 10592
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
10580: LD_EXP 47
10584: PPUSH
10585: LD_STRING D3b-Frank-1
10587: PPUSH
10588: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
10592: LD_INT 105
10594: PPUSH
10595: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
10599: LD_EXP 40
10603: PPUSH
10604: LD_STRING D4-Corn-1
10606: PPUSH
10607: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10611: LD_INT 35
10613: PPUSH
10614: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 6 ;
10618: LD_INT 22
10620: PUSH
10621: LD_INT 4
10623: PUSH
10624: EMPTY
10625: LIST
10626: LIST
10627: PUSH
10628: LD_INT 21
10630: PUSH
10631: LD_INT 1
10633: PUSH
10634: EMPTY
10635: LIST
10636: LIST
10637: PUSH
10638: LD_INT 50
10640: PUSH
10641: EMPTY
10642: LIST
10643: PUSH
10644: EMPTY
10645: LIST
10646: LIST
10647: LIST
10648: PPUSH
10649: CALL_OW 69
10653: PUSH
10654: LD_INT 6
10656: LESS
10657: IFFALSE 10611
// SayRadio ( Cornel , D5-Corn-1 ) ;
10659: LD_EXP 40
10663: PPUSH
10664: LD_STRING D5-Corn-1
10666: PPUSH
10667: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
10671: LD_EXP 40
10675: PPUSH
10676: LD_EXP 2
10680: PUSH
10681: LD_STRING Cornel
10683: STR
10684: PPUSH
10685: CALL_OW 38
// ChangeSideFog ( 4 , 8 ) ;
10689: LD_INT 4
10691: PPUSH
10692: LD_INT 8
10694: PPUSH
10695: CALL_OW 343
// Wait ( 0 0$01 ) ;
10699: LD_INT 35
10701: PPUSH
10702: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
10706: LD_INT 3
10708: PPUSH
10709: LD_EXP 40
10713: PPUSH
10714: CALL_OW 472
// send_attack_on_cornel := false ;
10718: LD_ADDR_EXP 30
10722: PUSH
10723: LD_INT 0
10725: ST_TO_ADDR
// end ;
10726: PPOPN 1
10728: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
10729: LD_INT 9
10731: PPUSH
10732: LD_INT 22
10734: PUSH
10735: LD_INT 1
10737: PUSH
10738: EMPTY
10739: LIST
10740: LIST
10741: PPUSH
10742: CALL_OW 70
10746: PUSH
10747: LD_EXP 31
10751: OR
10752: IFFALSE 11271
10754: GO 10756
10756: DISABLE
10757: LD_INT 0
10759: PPUSH
10760: PPUSH
// begin enable ;
10761: ENABLE
// if not game_end then
10762: LD_EXP 31
10766: NOT
10767: IFFALSE 10777
// game_end := true ;
10769: LD_ADDR_EXP 31
10773: PUSH
10774: LD_INT 1
10776: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
10777: LD_ADDR_VAR 0 2
10781: PUSH
10782: LD_INT 9
10784: PPUSH
10785: LD_INT 22
10787: PUSH
10788: LD_INT 1
10790: PUSH
10791: EMPTY
10792: LIST
10793: LIST
10794: PPUSH
10795: CALL_OW 70
10799: ST_TO_ADDR
// if not filter then
10800: LD_VAR 0 2
10804: NOT
10805: IFFALSE 10809
// exit ;
10807: GO 11271
// for i in filter do
10809: LD_ADDR_VAR 0 1
10813: PUSH
10814: LD_VAR 0 2
10818: PUSH
10819: FOR_IN
10820: IFFALSE 11269
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
10822: LD_VAR 0 1
10826: PPUSH
10827: CALL_OW 302
10831: PUSH
10832: LD_VAR 0 1
10836: PPUSH
10837: CALL_OW 247
10841: PUSH
10842: LD_INT 2
10844: EQUAL
10845: AND
10846: IFFALSE 10886
// begin veh_on_meta := true ;
10848: LD_ADDR_EXP 26
10852: PUSH
10853: LD_INT 1
10855: ST_TO_ADDR
// ComExitVehicle ( IsInUnit ( i ) ) ;
10856: LD_VAR 0 1
10860: PPUSH
10861: CALL_OW 310
10865: PPUSH
10866: CALL_OW 121
// RemoveUnit ( i ) ;
10870: LD_VAR 0 1
10874: PPUSH
10875: CALL_OW 64
// Wait ( 10 ) ;
10879: LD_INT 10
10881: PPUSH
10882: CALL_OW 67
// end ; if i = JMM then
10886: LD_VAR 0 1
10890: PUSH
10891: LD_EXP 33
10895: EQUAL
10896: IFFALSE 11018
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
10898: LD_EXP 23
10902: PUSH
10903: LD_INT 22
10905: PUSH
10906: LD_INT 1
10908: PUSH
10909: EMPTY
10910: LIST
10911: LIST
10912: PUSH
10913: LD_INT 21
10915: PUSH
10916: LD_INT 1
10918: PUSH
10919: EMPTY
10920: LIST
10921: LIST
10922: PUSH
10923: EMPTY
10924: LIST
10925: LIST
10926: PPUSH
10927: CALL_OW 69
10931: PUSH
10932: LD_INT 1
10934: GREATER
10935: AND
10936: IFFALSE 10993
// begin show_query := false ;
10938: LD_ADDR_EXP 23
10942: PUSH
10943: LD_INT 0
10945: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
10946: LD_STRING Q2
10948: PPUSH
10949: CALL_OW 97
10953: PUSH
10954: LD_INT 1
10956: DOUBLE
10957: EQUAL
10958: IFTRUE 10962
10960: GO 10973
10962: POP
// wait_for_them := true ; 2 :
10963: LD_ADDR_EXP 24
10967: PUSH
10968: LD_INT 1
10970: ST_TO_ADDR
10971: GO 10993
10973: LD_INT 2
10975: DOUBLE
10976: EQUAL
10977: IFTRUE 10981
10979: GO 10992
10981: POP
// wait_for_them := false ; end ;
10982: LD_ADDR_EXP 24
10986: PUSH
10987: LD_INT 0
10989: ST_TO_ADDR
10990: GO 10993
10992: POP
// end ; save_group := save_group ^ JMM ;
10993: LD_ADDR_EXP 22
10997: PUSH
10998: LD_EXP 22
11002: PUSH
11003: LD_EXP 33
11007: ADD
11008: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11009: LD_EXP 33
11013: PPUSH
11014: CALL_OW 64
// end ; if i = Lisa then
11018: LD_VAR 0 1
11022: PUSH
11023: LD_EXP 36
11027: EQUAL
11028: IFFALSE 11055
// begin save_group := save_group ^ Lisa ;
11030: LD_ADDR_EXP 22
11034: PUSH
11035: LD_EXP 22
11039: PUSH
11040: LD_EXP 36
11044: ADD
11045: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11046: LD_EXP 36
11050: PPUSH
11051: CALL_OW 64
// end ; if i = Bobby then
11055: LD_VAR 0 1
11059: PUSH
11060: LD_EXP 34
11064: EQUAL
11065: IFFALSE 11092
// begin save_group := save_group ^ Bobby ;
11067: LD_ADDR_EXP 22
11071: PUSH
11072: LD_EXP 22
11076: PUSH
11077: LD_EXP 34
11081: ADD
11082: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11083: LD_EXP 34
11087: PPUSH
11088: CALL_OW 64
// end ; if i = Cyrus then
11092: LD_VAR 0 1
11096: PUSH
11097: LD_EXP 35
11101: EQUAL
11102: IFFALSE 11129
// begin save_group := save_group ^ Cyrus ;
11104: LD_ADDR_EXP 22
11108: PUSH
11109: LD_EXP 22
11113: PUSH
11114: LD_EXP 35
11118: ADD
11119: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11120: LD_EXP 35
11124: PPUSH
11125: CALL_OW 64
// end ; if i = Khatam then
11129: LD_VAR 0 1
11133: PUSH
11134: LD_EXP 37
11138: EQUAL
11139: IFFALSE 11166
// begin save_group := save_group ^ Khatam ;
11141: LD_ADDR_EXP 22
11145: PUSH
11146: LD_EXP 22
11150: PUSH
11151: LD_EXP 37
11155: ADD
11156: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11157: LD_EXP 37
11161: PPUSH
11162: CALL_OW 64
// end ; if i = Frank then
11166: LD_VAR 0 1
11170: PUSH
11171: LD_EXP 47
11175: EQUAL
11176: IFFALSE 11203
// begin save_group := save_group ^ Frank ;
11178: LD_ADDR_EXP 22
11182: PUSH
11183: LD_EXP 22
11187: PUSH
11188: LD_EXP 47
11192: ADD
11193: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11194: LD_EXP 47
11198: PPUSH
11199: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11203: LD_VAR 0 1
11207: PPUSH
11208: CALL_OW 302
11212: PUSH
11213: LD_VAR 0 1
11217: PPUSH
11218: CALL_OW 247
11222: PUSH
11223: LD_INT 1
11225: EQUAL
11226: AND
11227: PUSH
11228: LD_VAR 0 1
11232: PUSH
11233: LD_EXP 22
11237: IN
11238: NOT
11239: AND
11240: IFFALSE 11267
// begin save_others := save_others ^ i ;
11242: LD_ADDR_EXP 21
11246: PUSH
11247: LD_EXP 21
11251: PUSH
11252: LD_VAR 0 1
11256: ADD
11257: ST_TO_ADDR
// RemoveUnit ( i ) ;
11258: LD_VAR 0 1
11262: PPUSH
11263: CALL_OW 64
// end ; end ;
11267: GO 10819
11269: POP
11270: POP
// end ;
11271: PPOPN 2
11273: END
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
11274: LD_EXP 23
11278: NOT
11279: PUSH
11280: LD_EXP 24
11284: NOT
11285: AND
11286: PUSH
11287: LD_INT 22
11289: PUSH
11290: LD_INT 1
11292: PUSH
11293: EMPTY
11294: LIST
11295: LIST
11296: PUSH
11297: LD_INT 21
11299: PUSH
11300: LD_INT 1
11302: PUSH
11303: EMPTY
11304: LIST
11305: LIST
11306: PUSH
11307: EMPTY
11308: LIST
11309: LIST
11310: PPUSH
11311: CALL_OW 69
11315: PUSH
11316: LD_INT 0
11318: EQUAL
11319: OR
11320: IFFALSE 11329
11322: GO 11324
11324: DISABLE
// EndMission ;
11325: CALL 11330 0 0
11329: END
// export function EndMission ; var i ; begin
11330: LD_INT 0
11332: PPUSH
11333: PPUSH
// Wait ( 0 0$02 ) ;
11334: LD_INT 70
11336: PPUSH
11337: CALL_OW 67
// if solar_builded then
11341: LD_EXP 13
11345: IFFALSE 11359
// AddMedal ( Solar1 , 1 ) else
11347: LD_STRING Solar1
11349: PPUSH
11350: LD_INT 1
11352: PPUSH
11353: CALL_OW 101
11357: GO 11370
// AddMedal ( Solar1 , - 1 ) ;
11359: LD_STRING Solar1
11361: PPUSH
11362: LD_INT 1
11364: NEG
11365: PPUSH
11366: CALL_OW 101
// if veh_on_meta then
11370: LD_EXP 26
11374: IFFALSE 11388
// AddMedal ( Solar2 , 1 ) else
11376: LD_STRING Solar2
11378: PPUSH
11379: LD_INT 1
11381: PPUSH
11382: CALL_OW 101
11386: GO 11418
// if solar_builded then
11388: LD_EXP 13
11392: IFFALSE 11407
// AddMedal ( Solar2 , - 1 ) else
11394: LD_STRING Solar2
11396: PPUSH
11397: LD_INT 1
11399: NEG
11400: PPUSH
11401: CALL_OW 101
11405: GO 11418
// AddMedal ( Solar2 , - 2 ) ;
11407: LD_STRING Solar2
11409: PPUSH
11410: LD_INT 2
11412: NEG
11413: PPUSH
11414: CALL_OW 101
// if lose_counter = 0 then
11418: LD_EXP 32
11422: PUSH
11423: LD_INT 0
11425: EQUAL
11426: IFFALSE 11440
// AddMedal ( No , 1 ) else
11428: LD_STRING No
11430: PPUSH
11431: LD_INT 1
11433: PPUSH
11434: CALL_OW 101
11438: GO 11484
// if lose_counter > 0 and lose_counter < 4 then
11440: LD_EXP 32
11444: PUSH
11445: LD_INT 0
11447: GREATER
11448: PUSH
11449: LD_EXP 32
11453: PUSH
11454: LD_INT 4
11456: LESS
11457: AND
11458: IFFALSE 11473
// AddMedal ( No , - 1 ) else
11460: LD_STRING No
11462: PPUSH
11463: LD_INT 1
11465: NEG
11466: PPUSH
11467: CALL_OW 101
11471: GO 11484
// AddMedal ( UpTo4 , - 1 ) ;
11473: LD_STRING UpTo4
11475: PPUSH
11476: LD_INT 1
11478: NEG
11479: PPUSH
11480: CALL_OW 101
// GiveMedals ( MAIN ) ;
11484: LD_STRING MAIN
11486: PPUSH
11487: CALL_OW 102
// if IsDead ( Pokryshkin ) then
11491: LD_EXP 48
11495: PPUSH
11496: CALL_OW 301
11500: IFFALSE 11540
// for i in save_group ^ save_others do
11502: LD_ADDR_VAR 0 2
11506: PUSH
11507: LD_EXP 22
11511: PUSH
11512: LD_EXP 21
11516: ADD
11517: PUSH
11518: FOR_IN
11519: IFFALSE 11538
// AddExperience ( i , skill_combat , 1500 ) ;
11521: LD_VAR 0 2
11525: PPUSH
11526: LD_INT 1
11528: PPUSH
11529: LD_INT 1500
11531: PPUSH
11532: CALL_OW 492
11536: GO 11518
11538: POP
11539: POP
// RewardPeople ( save_group ^ save_others ) ;
11540: LD_EXP 22
11544: PUSH
11545: LD_EXP 21
11549: ADD
11550: PPUSH
11551: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
11555: LD_EXP 33
11559: PPUSH
11560: LD_EXP 2
11564: PUSH
11565: LD_STRING JMM
11567: STR
11568: PPUSH
11569: CALL_OW 38
// if Bobby in save_group then
11573: LD_EXP 34
11577: PUSH
11578: LD_EXP 22
11582: IN
11583: IFFALSE 11603
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
11585: LD_EXP 34
11589: PPUSH
11590: LD_EXP 2
11594: PUSH
11595: LD_STRING Bobby
11597: STR
11598: PPUSH
11599: CALL_OW 38
// if Cyrus in save_group then
11603: LD_EXP 35
11607: PUSH
11608: LD_EXP 22
11612: IN
11613: IFFALSE 11633
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
11615: LD_EXP 35
11619: PPUSH
11620: LD_EXP 2
11624: PUSH
11625: LD_STRING Cyrus
11627: STR
11628: PPUSH
11629: CALL_OW 38
// if Lisa in save_group then
11633: LD_EXP 36
11637: PUSH
11638: LD_EXP 22
11642: IN
11643: IFFALSE 11663
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
11645: LD_EXP 36
11649: PPUSH
11650: LD_EXP 2
11654: PUSH
11655: LD_STRING Lisa
11657: STR
11658: PPUSH
11659: CALL_OW 38
// if Frank in save_group then
11663: LD_EXP 47
11667: PUSH
11668: LD_EXP 22
11672: IN
11673: IFFALSE 11693
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
11675: LD_EXP 47
11679: PPUSH
11680: LD_EXP 2
11684: PUSH
11685: LD_STRING Frank
11687: STR
11688: PPUSH
11689: CALL_OW 38
// if Khatam in save_group then
11693: LD_EXP 37
11697: PUSH
11698: LD_EXP 22
11702: IN
11703: IFFALSE 11723
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
11705: LD_EXP 37
11709: PPUSH
11710: LD_EXP 2
11714: PUSH
11715: LD_STRING Khatam
11717: STR
11718: PPUSH
11719: CALL_OW 38
// if save_others then
11723: LD_EXP 21
11727: IFFALSE 11741
// SaveCharacters ( save_others , 03_others ) ;
11729: LD_EXP 21
11733: PPUSH
11734: LD_STRING 03_others
11736: PPUSH
11737: CALL_OW 38
// DeleteCharacters ( mission_prefix & Brian ) ;
11741: LD_EXP 2
11745: PUSH
11746: LD_STRING Brian
11748: STR
11749: PPUSH
11750: CALL_OW 40
// DeleteCharacters ( mission_prefix & Jimmy ) ;
11754: LD_EXP 2
11758: PUSH
11759: LD_STRING Jimmy
11761: STR
11762: PPUSH
11763: CALL_OW 40
// if Bierezov and IsOk ( Bierezov ) then
11767: LD_EXP 41
11771: PUSH
11772: LD_EXP 41
11776: PPUSH
11777: CALL_OW 302
11781: AND
11782: IFFALSE 11794
// begin ResetFog ;
11784: CALL_OW 335
// DisplayEndingScene ;
11788: CALL 11816 0 0
// end else
11792: GO 11807
// DeleteCharacters ( mission_prefix & Cornel ) ;
11794: LD_EXP 2
11798: PUSH
11799: LD_STRING Cornel
11801: STR
11802: PPUSH
11803: CALL_OW 40
// YouWin ;
11807: CALL_OW 103
// end ;
11811: LD_VAR 0 1
11815: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
11816: LD_INT 0
11818: PPUSH
11819: PPUSH
11820: PPUSH
11821: PPUSH
11822: PPUSH
11823: PPUSH
// InGameOn ;
11824: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
11828: LD_INT 208
11830: PPUSH
11831: LD_INT 62
11833: PPUSH
11834: LD_INT 1
11836: PPUSH
11837: LD_INT 10
11839: NEG
11840: PPUSH
11841: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
11845: LD_INT 208
11847: PPUSH
11848: LD_INT 62
11850: PPUSH
11851: LD_INT 1
11853: PPUSH
11854: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11858: LD_ADDR_VAR 0 3
11862: PUSH
11863: LD_INT 22
11865: PUSH
11866: LD_INT 3
11868: PUSH
11869: EMPTY
11870: LIST
11871: LIST
11872: PUSH
11873: LD_INT 2
11875: PUSH
11876: LD_INT 21
11878: PUSH
11879: LD_INT 2
11881: PUSH
11882: EMPTY
11883: LIST
11884: LIST
11885: PUSH
11886: LD_INT 21
11888: PUSH
11889: LD_INT 1
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: PUSH
11896: EMPTY
11897: LIST
11898: LIST
11899: LIST
11900: PUSH
11901: EMPTY
11902: LIST
11903: LIST
11904: PPUSH
11905: CALL_OW 69
11909: ST_TO_ADDR
// if filter then
11910: LD_VAR 0 3
11914: IFFALSE 11942
// for i in filter do
11916: LD_ADDR_VAR 0 2
11920: PUSH
11921: LD_VAR 0 3
11925: PUSH
11926: FOR_IN
11927: IFFALSE 11940
// RemoveUnit ( i ) ;
11929: LD_VAR 0 2
11933: PPUSH
11934: CALL_OW 64
11938: GO 11926
11940: POP
11941: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
11942: LD_ADDR_VAR 0 3
11946: PUSH
11947: LD_INT 22
11949: PUSH
11950: LD_INT 4
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: PUSH
11957: LD_INT 21
11959: PUSH
11960: LD_INT 1
11962: PUSH
11963: EMPTY
11964: LIST
11965: LIST
11966: PUSH
11967: EMPTY
11968: LIST
11969: LIST
11970: PPUSH
11971: CALL_OW 69
11975: ST_TO_ADDR
// if filter then
11976: LD_VAR 0 3
11980: IFFALSE 12011
// for i in filter do
11982: LD_ADDR_VAR 0 2
11986: PUSH
11987: LD_VAR 0 3
11991: PUSH
11992: FOR_IN
11993: IFFALSE 12009
// SetLives ( i , 0 ) ;
11995: LD_VAR 0 2
11999: PPUSH
12000: LD_INT 0
12002: PPUSH
12003: CALL_OW 234
12007: GO 11992
12009: POP
12010: POP
// uc_side := 4 ;
12011: LD_ADDR_OWVAR 20
12015: PUSH
12016: LD_INT 4
12018: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12019: LD_ADDR_VAR 0 4
12023: PUSH
12024: LD_STRING Cornell
12026: PPUSH
12027: LD_INT 0
12029: PPUSH
12030: CALL 450 0 2
12034: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12035: LD_VAR 0 4
12039: PPUSH
12040: LD_INT 208
12042: PPUSH
12043: LD_INT 62
12045: PPUSH
12046: LD_INT 0
12048: PPUSH
12049: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12053: LD_VAR 0 4
12057: PPUSH
12058: LD_INT 100
12060: PPUSH
12061: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12065: LD_INT 3
12067: PPUSH
12068: LD_VAR 0 4
12072: PPUSH
12073: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12077: LD_INT 4
12079: PPUSH
12080: LD_INT 3
12082: PPUSH
12083: LD_INT 1
12085: PPUSH
12086: LD_INT 1
12088: PPUSH
12089: CALL_OW 80
// uc_side := 3 ;
12093: LD_ADDR_OWVAR 20
12097: PUSH
12098: LD_INT 3
12100: ST_TO_ADDR
// uc_nation := 3 ;
12101: LD_ADDR_OWVAR 21
12105: PUSH
12106: LD_INT 3
12108: ST_TO_ADDR
// InitHc ;
12109: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12113: LD_ADDR_VAR 0 5
12117: PUSH
12118: LD_STRING Mikhail
12120: PPUSH
12121: LD_INT 0
12123: PPUSH
12124: CALL 450 0 2
12128: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12129: LD_INT 1
12131: PPUSH
12132: LD_INT 1
12134: PPUSH
12135: LD_INT 0
12137: PPUSH
12138: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12142: LD_ADDR_VAR 0 6
12146: PUSH
12147: LD_VAR 0 6
12151: PUSH
12152: CALL_OW 44
12156: ADD
12157: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12158: LD_ADDR_VAR 0 6
12162: PUSH
12163: LD_VAR 0 6
12167: PUSH
12168: CALL_OW 44
12172: ADD
12173: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12174: LD_INT 2
12176: PPUSH
12177: LD_INT 4
12179: PPUSH
12180: LD_INT 0
12182: PPUSH
12183: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12187: LD_ADDR_VAR 0 6
12191: PUSH
12192: LD_VAR 0 6
12196: PUSH
12197: CALL_OW 44
12201: ADD
12202: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12203: LD_VAR 0 5
12207: PPUSH
12208: LD_INT 17
12210: PPUSH
12211: LD_INT 0
12213: PPUSH
12214: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12218: LD_VAR 0 5
12222: PPUSH
12223: LD_INT 210
12225: PPUSH
12226: LD_INT 63
12228: PPUSH
12229: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12233: LD_VAR 0 5
12237: PPUSH
12238: LD_INT 208
12240: PPUSH
12241: LD_INT 62
12243: PPUSH
12244: CALL_OW 178
// for i in fake_russians do
12248: LD_ADDR_VAR 0 2
12252: PUSH
12253: LD_VAR 0 6
12257: PUSH
12258: FOR_IN
12259: IFFALSE 12337
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12261: LD_VAR 0 2
12265: PPUSH
12266: LD_INT 17
12268: PPUSH
12269: LD_INT 0
12271: PPUSH
12272: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
12276: LD_VAR 0 2
12280: PPUSH
12281: LD_INT 215
12283: PPUSH
12284: LD_INT 67
12286: PPUSH
12287: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
12291: LD_VAR 0 2
12295: PPUSH
12296: LD_INT 208
12298: PPUSH
12299: LD_INT 62
12301: PPUSH
12302: CALL_OW 178
// if GetClass ( i ) = 4 then
12306: LD_VAR 0 2
12310: PPUSH
12311: CALL_OW 257
12315: PUSH
12316: LD_INT 4
12318: EQUAL
12319: IFFALSE 12335
// ComHeal ( i , fake_cornel ) ;
12321: LD_VAR 0 2
12325: PPUSH
12326: LD_VAR 0 4
12330: PPUSH
12331: CALL_OW 128
// end ;
12335: GO 12258
12337: POP
12338: POP
// Wait ( 0 0$01 ) ;
12339: LD_INT 35
12341: PPUSH
12342: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
12346: LD_INT 208
12348: PPUSH
12349: LD_INT 62
12351: PPUSH
12352: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12356: LD_INT 208
12358: PPUSH
12359: LD_INT 62
12361: PPUSH
12362: LD_INT 1
12364: PPUSH
12365: LD_INT 10
12367: NEG
12368: PPUSH
12369: CALL_OW 330
// Wait ( 0 0$15 ) ;
12373: LD_INT 525
12375: PPUSH
12376: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
12380: LD_INT 208
12382: PPUSH
12383: LD_INT 62
12385: PPUSH
12386: LD_INT 1
12388: PPUSH
12389: CALL_OW 331
// ResetFog ;
12393: CALL_OW 335
// InGameOff ;
12397: CALL_OW 9
// end ;
12401: LD_VAR 0 1
12405: RET
// every 0 0$30 trigger GetDistUnits ( JMM , Cornel ) < 3 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) do
12406: LD_EXP 33
12410: PPUSH
12411: LD_EXP 40
12415: PPUSH
12416: CALL_OW 296
12420: PUSH
12421: LD_INT 3
12423: LESS
12424: PUSH
12425: LD_INT 22
12427: PUSH
12428: LD_INT 4
12430: PUSH
12431: EMPTY
12432: LIST
12433: LIST
12434: PUSH
12435: LD_INT 21
12437: PUSH
12438: LD_INT 3
12440: PUSH
12441: EMPTY
12442: LIST
12443: LIST
12444: PUSH
12445: EMPTY
12446: LIST
12447: LIST
12448: PPUSH
12449: CALL_OW 69
12453: AND
12454: IFFALSE 12472
12456: GO 12458
12458: DISABLE
// begin enable ;
12459: ENABLE
// SayRadio ( Powell , DWarn-Pow-1 ) ;
12460: LD_EXP 42
12464: PPUSH
12465: LD_STRING DWarn-Pow-1
12467: PPUSH
12468: CALL_OW 94
// end ; end_of_file
12472: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
12473: LD_EXP 8
12477: IFFALSE 13791
12479: GO 12481
12481: DISABLE
12482: LD_INT 0
12484: PPUSH
12485: PPUSH
12486: PPUSH
12487: PPUSH
12488: PPUSH
12489: PPUSH
12490: PPUSH
12491: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
12492: LD_EXP 40
12496: PUSH
12497: LD_EXP 41
12501: ADD
12502: PUSH
12503: LD_EXP 6
12507: ADD
12508: PPUSH
12509: LD_INT 250
12511: PPUSH
12512: LD_INT 120
12514: PPUSH
12515: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff [ Bierezov ] ;
12519: LD_ADDR_VAR 0 2
12523: PUSH
12524: LD_EXP 6
12528: PPUSH
12529: LD_INT 25
12531: PUSH
12532: LD_INT 2
12534: PUSH
12535: EMPTY
12536: LIST
12537: LIST
12538: PPUSH
12539: CALL_OW 72
12543: PUSH
12544: LD_EXP 41
12548: PUSH
12549: EMPTY
12550: LIST
12551: DIFF
12552: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
12553: LD_ADDR_VAR 0 3
12557: PUSH
12558: LD_EXP 6
12562: PPUSH
12563: LD_INT 21
12565: PUSH
12566: LD_INT 1
12568: PUSH
12569: EMPTY
12570: LIST
12571: LIST
12572: PPUSH
12573: CALL_OW 72
12577: ST_TO_ADDR
// if not has_eng then
12578: LD_VAR 0 2
12582: NOT
12583: IFFALSE 12666
// begin uc_side := 4 ;
12585: LD_ADDR_OWVAR 20
12589: PUSH
12590: LD_INT 4
12592: ST_TO_ADDR
// uc_nation := 1 ;
12593: LD_ADDR_OWVAR 21
12597: PUSH
12598: LD_INT 1
12600: ST_TO_ADDR
// bc_type := b_depot ;
12601: LD_ADDR_OWVAR 42
12605: PUSH
12606: LD_INT 0
12608: ST_TO_ADDR
// bc_level := 2 ;
12609: LD_ADDR_OWVAR 43
12613: PUSH
12614: LD_INT 2
12616: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
12617: LD_ADDR_VAR 0 4
12621: PUSH
12622: LD_INT 264
12624: PPUSH
12625: LD_INT 120
12627: PPUSH
12628: LD_INT 4
12630: PPUSH
12631: CALL_OW 47
12635: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
12636: LD_INT 264
12638: PPUSH
12639: LD_INT 120
12641: PPUSH
12642: LD_INT 4
12644: PPUSH
12645: LD_INT 10
12647: NEG
12648: PPUSH
12649: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
12653: LD_INT 264
12655: PPUSH
12656: LD_INT 120
12658: PPUSH
12659: LD_INT 4
12661: PPUSH
12662: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
12666: LD_INT 35
12668: PPUSH
12669: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
12673: LD_EXP 40
12677: PPUSH
12678: LD_INT 10
12680: PPUSH
12681: CALL_OW 308
12685: IFFALSE 12666
// if has_eng and not dep then
12687: LD_VAR 0 2
12691: PUSH
12692: LD_VAR 0 4
12696: NOT
12697: AND
12698: IFFALSE 12826
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
12700: LD_VAR 0 2
12704: PPUSH
12705: LD_INT 0
12707: PPUSH
12708: LD_INT 264
12710: PPUSH
12711: LD_INT 120
12713: PPUSH
12714: LD_INT 4
12716: PPUSH
12717: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
12721: LD_INT 35
12723: PPUSH
12724: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
12728: LD_INT 22
12730: PUSH
12731: LD_INT 4
12733: PUSH
12734: EMPTY
12735: LIST
12736: LIST
12737: PUSH
12738: LD_INT 30
12740: PUSH
12741: LD_INT 0
12743: PUSH
12744: EMPTY
12745: LIST
12746: LIST
12747: PUSH
12748: EMPTY
12749: LIST
12750: LIST
12751: PPUSH
12752: CALL_OW 69
12756: IFFALSE 12721
// ComMoveXY ( filter , 264 , 120 ) ;
12758: LD_VAR 0 3
12762: PPUSH
12763: LD_INT 264
12765: PPUSH
12766: LD_INT 120
12768: PPUSH
12769: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
12773: LD_INT 35
12775: PPUSH
12776: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
12780: LD_INT 22
12782: PUSH
12783: LD_INT 4
12785: PUSH
12786: EMPTY
12787: LIST
12788: LIST
12789: PUSH
12790: LD_INT 30
12792: PUSH
12793: LD_INT 0
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: LD_INT 3
12802: PUSH
12803: LD_INT 57
12805: PUSH
12806: EMPTY
12807: LIST
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: LIST
12817: PPUSH
12818: CALL_OW 69
12822: IFFALSE 12773
// end else
12824: GO 12838
// begin SetSide ( dep , 4 ) ;
12826: LD_VAR 0 4
12830: PPUSH
12831: LD_INT 4
12833: PPUSH
12834: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
12838: LD_ADDR_VAR 0 4
12842: PUSH
12843: LD_INT 22
12845: PUSH
12846: LD_INT 4
12848: PUSH
12849: EMPTY
12850: LIST
12851: LIST
12852: PUSH
12853: LD_INT 30
12855: PUSH
12856: LD_INT 0
12858: PUSH
12859: EMPTY
12860: LIST
12861: LIST
12862: PUSH
12863: EMPTY
12864: LIST
12865: LIST
12866: PPUSH
12867: CALL_OW 69
12871: PUSH
12872: LD_INT 1
12874: ARRAY
12875: ST_TO_ADDR
// for i = 1 to 3 - has_eng do
12876: LD_ADDR_VAR 0 1
12880: PUSH
12881: DOUBLE
12882: LD_INT 1
12884: DEC
12885: ST_TO_ADDR
12886: LD_INT 3
12888: PUSH
12889: LD_VAR 0 2
12893: MINUS
12894: PUSH
12895: FOR_TO
12896: IFFALSE 12976
// begin if GetClass ( filter [ i ] ) = 2 then
12898: LD_VAR 0 3
12902: PUSH
12903: LD_VAR 0 1
12907: ARRAY
12908: PPUSH
12909: CALL_OW 257
12913: PUSH
12914: LD_INT 2
12916: EQUAL
12917: IFFALSE 12921
// continue ;
12919: GO 12895
// ComEnterUnit ( filter [ i ] , dep ) ;
12921: LD_VAR 0 3
12925: PUSH
12926: LD_VAR 0 1
12930: ARRAY
12931: PPUSH
12932: LD_VAR 0 4
12936: PPUSH
12937: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
12941: LD_VAR 0 3
12945: PUSH
12946: LD_VAR 0 1
12950: ARRAY
12951: PPUSH
12952: LD_INT 2
12954: PPUSH
12955: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
12959: LD_VAR 0 3
12963: PUSH
12964: LD_VAR 0 1
12968: ARRAY
12969: PPUSH
12970: CALL_OW 182
// end ;
12974: GO 12895
12976: POP
12977: POP
// repeat wait ( 0 0$01 ) ;
12978: LD_INT 35
12980: PPUSH
12981: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
12985: LD_VAR 0 3
12989: PPUSH
12990: LD_INT 25
12992: PUSH
12993: LD_INT 2
12995: PUSH
12996: EMPTY
12997: LIST
12998: LIST
12999: PPUSH
13000: CALL_OW 72
13004: PUSH
13005: LD_INT 3
13007: EQUAL
13008: IFFALSE 12978
// if IsInUnit ( Cornel ) then
13010: LD_EXP 40
13014: PPUSH
13015: CALL_OW 310
13019: IFFALSE 13102
// begin cargo := IsInUnit ( Cornel ) ;
13021: LD_ADDR_VAR 0 7
13025: PUSH
13026: LD_EXP 40
13030: PPUSH
13031: CALL_OW 310
13035: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13036: LD_VAR 0 7
13040: PPUSH
13041: LD_INT 1
13043: PPUSH
13044: CALL_OW 289
13048: IFFALSE 13064
// ComGive ( Cornel , dep ) ;
13050: LD_EXP 40
13054: PPUSH
13055: LD_VAR 0 4
13059: PPUSH
13060: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13064: LD_EXP 40
13068: PPUSH
13069: LD_INT 235
13071: PPUSH
13072: LD_INT 122
13074: PPUSH
13075: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13079: LD_EXP 40
13083: PPUSH
13084: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13088: LD_EXP 40
13092: PPUSH
13093: LD_VAR 0 4
13097: PPUSH
13098: CALL_OW 180
// end ; if Bierezov then
13102: LD_EXP 41
13106: IFFALSE 13122
// ComEnterUnit ( Bierezov , dep ) ;
13108: LD_EXP 41
13112: PPUSH
13113: LD_VAR 0 4
13117: PPUSH
13118: CALL_OW 120
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
13122: LD_ADDR_VAR 0 2
13126: PUSH
13127: LD_EXP 6
13131: PPUSH
13132: LD_INT 25
13134: PUSH
13135: LD_INT 2
13137: PUSH
13138: EMPTY
13139: LIST
13140: LIST
13141: PPUSH
13142: CALL_OW 72
13146: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13147: LD_INT 35
13149: PPUSH
13150: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13154: LD_ADDR_VAR 0 6
13158: PUSH
13159: LD_INT 10
13161: PPUSH
13162: CALL_OW 435
13166: ST_TO_ADDR
// if crates then
13167: LD_VAR 0 6
13171: IFFALSE 13200
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
13173: LD_VAR 0 2
13177: PPUSH
13178: LD_VAR 0 6
13182: PUSH
13183: LD_INT 1
13185: ARRAY
13186: PPUSH
13187: LD_VAR 0 6
13191: PUSH
13192: LD_INT 2
13194: ARRAY
13195: PPUSH
13196: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
13200: LD_VAR 0 4
13204: PPUSH
13205: CALL_OW 274
13209: PPUSH
13210: LD_INT 1
13212: PPUSH
13213: CALL_OW 275
13217: PUSH
13218: LD_INT 40
13220: GREATEREQUAL
13221: IFFALSE 13147
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
13223: LD_ADDR_VAR 0 5
13227: PUSH
13228: LD_INT 4
13230: PUSH
13231: LD_INT 256
13233: PUSH
13234: LD_INT 111
13236: PUSH
13237: LD_INT 2
13239: PUSH
13240: EMPTY
13241: LIST
13242: LIST
13243: LIST
13244: LIST
13245: PUSH
13246: LD_INT 31
13248: PUSH
13249: LD_INT 243
13251: PUSH
13252: LD_INT 112
13254: PUSH
13255: LD_INT 2
13257: PUSH
13258: EMPTY
13259: LIST
13260: LIST
13261: LIST
13262: LIST
13263: PUSH
13264: EMPTY
13265: LIST
13266: LIST
13267: ST_TO_ADDR
// for i in blist do
13268: LD_ADDR_VAR 0 1
13272: PUSH
13273: LD_VAR 0 5
13277: PUSH
13278: FOR_IN
13279: IFFALSE 13328
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
13281: LD_VAR 0 2
13285: PPUSH
13286: LD_VAR 0 1
13290: PUSH
13291: LD_INT 1
13293: ARRAY
13294: PPUSH
13295: LD_VAR 0 1
13299: PUSH
13300: LD_INT 2
13302: ARRAY
13303: PPUSH
13304: LD_VAR 0 1
13308: PUSH
13309: LD_INT 3
13311: ARRAY
13312: PPUSH
13313: LD_VAR 0 1
13317: PUSH
13318: LD_INT 4
13320: ARRAY
13321: PPUSH
13322: CALL_OW 205
13326: GO 13278
13328: POP
13329: POP
// repeat wait ( 0 0$01 ) ;
13330: LD_INT 35
13332: PPUSH
13333: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
13337: LD_INT 22
13339: PUSH
13340: LD_INT 4
13342: PUSH
13343: EMPTY
13344: LIST
13345: LIST
13346: PUSH
13347: LD_INT 30
13349: PUSH
13350: LD_INT 4
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PUSH
13357: LD_INT 3
13359: PUSH
13360: LD_INT 57
13362: PUSH
13363: EMPTY
13364: LIST
13365: PUSH
13366: EMPTY
13367: LIST
13368: LIST
13369: PUSH
13370: EMPTY
13371: LIST
13372: LIST
13373: LIST
13374: PPUSH
13375: CALL_OW 69
13379: IFFALSE 13330
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
13381: LD_VAR 0 3
13385: PUSH
13386: LD_VAR 0 2
13390: DIFF
13391: PPUSH
13392: LD_INT 22
13394: PUSH
13395: LD_INT 4
13397: PUSH
13398: EMPTY
13399: LIST
13400: LIST
13401: PUSH
13402: LD_INT 30
13404: PUSH
13405: LD_INT 4
13407: PUSH
13408: EMPTY
13409: LIST
13410: LIST
13411: PUSH
13412: EMPTY
13413: LIST
13414: LIST
13415: PPUSH
13416: CALL_OW 69
13420: PUSH
13421: LD_INT 1
13423: ARRAY
13424: PPUSH
13425: CALL_OW 180
// AddComChangeProfession ( filter diff has_eng , 1 ) ;
13429: LD_VAR 0 3
13433: PUSH
13434: LD_VAR 0 2
13438: DIFF
13439: PPUSH
13440: LD_INT 1
13442: PPUSH
13443: CALL_OW 183
// repeat wait ( 0 0$01 ) ;
13447: LD_INT 35
13449: PPUSH
13450: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
13454: LD_INT 22
13456: PUSH
13457: LD_INT 4
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 30
13466: PUSH
13467: LD_INT 31
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: LD_INT 3
13476: PUSH
13477: LD_INT 57
13479: PUSH
13480: EMPTY
13481: LIST
13482: PUSH
13483: EMPTY
13484: LIST
13485: LIST
13486: PUSH
13487: EMPTY
13488: LIST
13489: LIST
13490: LIST
13491: PPUSH
13492: CALL_OW 69
13496: IFFALSE 13447
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
13498: LD_ADDR_VAR 0 8
13502: PUSH
13503: LD_EXP 6
13507: PPUSH
13508: LD_INT 25
13510: PUSH
13511: LD_INT 1
13513: PUSH
13514: EMPTY
13515: LIST
13516: LIST
13517: PPUSH
13518: CALL_OW 72
13522: ST_TO_ADDR
// ComExitBuilding ( sol [ 1 ] ) ;
13523: LD_VAR 0 8
13527: PUSH
13528: LD_INT 1
13530: ARRAY
13531: PPUSH
13532: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
13536: LD_VAR 0 8
13540: PUSH
13541: LD_INT 1
13543: ARRAY
13544: PPUSH
13545: LD_INT 22
13547: PUSH
13548: LD_INT 4
13550: PUSH
13551: EMPTY
13552: LIST
13553: LIST
13554: PUSH
13555: LD_INT 30
13557: PUSH
13558: LD_INT 31
13560: PUSH
13561: EMPTY
13562: LIST
13563: LIST
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: PPUSH
13569: CALL_OW 69
13573: PUSH
13574: LD_INT 1
13576: ARRAY
13577: PPUSH
13578: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
13582: LD_VAR 0 2
13586: PPUSH
13587: LD_VAR 0 4
13591: PPUSH
13592: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
13596: LD_INT 35
13598: PPUSH
13599: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13603: LD_ADDR_VAR 0 3
13607: PUSH
13608: LD_INT 22
13610: PUSH
13611: LD_INT 4
13613: PUSH
13614: EMPTY
13615: LIST
13616: LIST
13617: PUSH
13618: LD_INT 21
13620: PUSH
13621: LD_INT 3
13623: PUSH
13624: EMPTY
13625: LIST
13626: LIST
13627: PUSH
13628: LD_INT 3
13630: PUSH
13631: LD_INT 24
13633: PUSH
13634: LD_INT 1000
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: PUSH
13641: EMPTY
13642: LIST
13643: LIST
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: LIST
13649: PPUSH
13650: CALL_OW 69
13654: ST_TO_ADDR
// if filter and has_eng then
13655: LD_VAR 0 3
13659: PUSH
13660: LD_VAR 0 2
13664: AND
13665: IFFALSE 13731
// begin for i in has_eng do
13667: LD_ADDR_VAR 0 1
13671: PUSH
13672: LD_VAR 0 2
13676: PUSH
13677: FOR_IN
13678: IFFALSE 13727
// begin if IsInUnit ( i ) then
13680: LD_VAR 0 1
13684: PPUSH
13685: CALL_OW 310
13689: IFFALSE 13700
// ComExitBuilding ( i ) ;
13691: LD_VAR 0 1
13695: PPUSH
13696: CALL_OW 122
// Wait ( 3 ) ;
13700: LD_INT 3
13702: PPUSH
13703: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
13707: LD_VAR 0 1
13711: PPUSH
13712: LD_VAR 0 3
13716: PUSH
13717: LD_INT 1
13719: ARRAY
13720: PPUSH
13721: CALL_OW 130
// end ;
13725: GO 13677
13727: POP
13728: POP
// end else
13729: GO 13785
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
13731: LD_VAR 0 2
13735: PUSH
13736: LD_VAR 0 2
13740: PPUSH
13741: LD_INT 56
13743: PUSH
13744: EMPTY
13745: LIST
13746: PPUSH
13747: CALL_OW 72
13751: AND
13752: IFFALSE 13785
// for i in has_eng do
13754: LD_ADDR_VAR 0 1
13758: PUSH
13759: LD_VAR 0 2
13763: PUSH
13764: FOR_IN
13765: IFFALSE 13783
// ComEnterUnit ( i , dep ) ;
13767: LD_VAR 0 1
13771: PPUSH
13772: LD_VAR 0 4
13776: PPUSH
13777: CALL_OW 120
13781: GO 13764
13783: POP
13784: POP
// until cornel_prepared ;
13785: LD_EXP 11
13789: IFFALSE 13596
// end ;
13791: PPOPN 8
13793: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
13794: LD_EXP 11
13798: IFFALSE 14147
13800: GO 13802
13802: DISABLE
13803: LD_INT 0
13805: PPUSH
13806: PPUSH
13807: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
13808: LD_ADDR_VAR 0 2
13812: PUSH
13813: LD_INT 22
13815: PUSH
13816: LD_INT 4
13818: PUSH
13819: EMPTY
13820: LIST
13821: LIST
13822: PUSH
13823: LD_INT 30
13825: PUSH
13826: LD_INT 4
13828: PUSH
13829: EMPTY
13830: LIST
13831: LIST
13832: PUSH
13833: EMPTY
13834: LIST
13835: LIST
13836: PPUSH
13837: CALL_OW 69
13841: PUSH
13842: LD_INT 1
13844: ARRAY
13845: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
13846: LD_EXP 6
13850: PPUSH
13851: CALL_OW 122
// Wait ( 0 0$03 ) ;
13855: LD_INT 105
13857: PPUSH
13858: CALL_OW 67
// for i in cornel_units do
13862: LD_ADDR_VAR 0 1
13866: PUSH
13867: LD_EXP 6
13871: PUSH
13872: FOR_IN
13873: IFFALSE 13949
// begin if GetClass ( i ) in [ 2 , 3 ] then
13875: LD_VAR 0 1
13879: PPUSH
13880: CALL_OW 257
13884: PUSH
13885: LD_INT 2
13887: PUSH
13888: LD_INT 3
13890: PUSH
13891: EMPTY
13892: LIST
13893: LIST
13894: IN
13895: IFFALSE 13932
// begin ComEnterUnit ( i , arm ) ;
13897: LD_VAR 0 1
13901: PPUSH
13902: LD_VAR 0 2
13906: PPUSH
13907: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
13911: LD_VAR 0 1
13915: PPUSH
13916: LD_INT 1
13918: PPUSH
13919: CALL_OW 183
// AddComExitBuilding ( i ) ;
13923: LD_VAR 0 1
13927: PPUSH
13928: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
13932: LD_VAR 0 1
13936: PPUSH
13937: LD_INT 257
13939: PPUSH
13940: LD_INT 121
13942: PPUSH
13943: CALL_OW 171
// end ;
13947: GO 13872
13949: POP
13950: POP
// Wait ( 1 1$00 ) ;
13951: LD_INT 2100
13953: PPUSH
13954: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
13958: LD_ADDR_VAR 0 3
13962: PUSH
13963: LD_EXP 40
13967: PUSH
13968: LD_EXP 41
13972: ADD
13973: PUSH
13974: LD_EXP 6
13978: ADD
13979: PUSH
13980: LD_EXP 6
13984: PPUSH
13985: LD_INT 21
13987: PUSH
13988: LD_INT 2
13990: PUSH
13991: EMPTY
13992: LIST
13993: LIST
13994: PPUSH
13995: CALL_OW 72
13999: DIFF
14000: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
14001: LD_VAR 0 3
14005: PPUSH
14006: LD_INT 248
14008: PPUSH
14009: LD_INT 85
14011: PPUSH
14012: CALL_OW 111
// AddComHold ( filter ) ;
14016: LD_VAR 0 3
14020: PPUSH
14021: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
14025: LD_INT 35
14027: PPUSH
14028: CALL_OW 67
// until cornel_attack ;
14032: LD_EXP 9
14036: IFFALSE 14025
// ComAgressiveMove ( filter , 209 , 63 ) ;
14038: LD_VAR 0 3
14042: PPUSH
14043: LD_INT 209
14045: PPUSH
14046: LD_INT 63
14048: PPUSH
14049: CALL_OW 114
// if Bierezov then
14053: LD_EXP 41
14057: IFFALSE 14147
// begin filter := filter diff Bierezov ;
14059: LD_ADDR_VAR 0 3
14063: PUSH
14064: LD_VAR 0 3
14068: PUSH
14069: LD_EXP 41
14073: DIFF
14074: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
14075: LD_EXP 41
14079: PPUSH
14080: LD_INT 6
14082: PPUSH
14083: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
14087: LD_EXP 41
14091: PPUSH
14092: LD_INT 235
14094: PPUSH
14095: LD_INT 60
14097: PPUSH
14098: CALL_OW 111
// AddComHold ( Bierezov ) ;
14102: LD_EXP 41
14106: PPUSH
14107: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
14111: LD_EXP 41
14115: PPUSH
14116: LD_INT 350
14118: PPUSH
14119: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
14123: LD_EXP 41
14127: PPUSH
14128: LD_INT 198
14130: PPUSH
14131: LD_INT 28
14133: PPUSH
14134: CALL_OW 171
// AddComHold ( Bierezov ) ;
14138: LD_EXP 41
14142: PPUSH
14143: CALL_OW 200
// end ; end ; end_of_file
14147: PPOPN 3
14149: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
14150: LD_EXP 49
14154: PUSH
14155: LD_EXP 29
14159: NOT
14160: AND
14161: PUSH
14162: LD_EXP 30
14166: NOT
14167: AND
14168: IFFALSE 14618
14170: GO 14172
14172: DISABLE
14173: LD_INT 0
14175: PPUSH
14176: PPUSH
14177: PPUSH
14178: PPUSH
// begin enable ;
14179: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14180: LD_ADDR_VAR 0 4
14184: PUSH
14185: LD_INT 81
14187: PUSH
14188: LD_INT 3
14190: PUSH
14191: EMPTY
14192: LIST
14193: LIST
14194: PPUSH
14195: CALL_OW 69
14199: ST_TO_ADDR
// for i = 1 to ru_patrol do
14200: LD_ADDR_VAR 0 2
14204: PUSH
14205: DOUBLE
14206: LD_INT 1
14208: DEC
14209: ST_TO_ADDR
14210: LD_EXP 49
14214: PUSH
14215: FOR_TO
14216: IFFALSE 14616
// begin un := ru_patrol [ i ] ;
14218: LD_ADDR_VAR 0 1
14222: PUSH
14223: LD_EXP 49
14227: PUSH
14228: LD_VAR 0 2
14232: ARRAY
14233: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14234: LD_VAR 0 1
14238: PPUSH
14239: LD_INT 13
14241: PPUSH
14242: CALL_OW 308
14246: IFFALSE 14351
// begin if not ru_alert then
14248: LD_EXP 56
14252: NOT
14253: IFFALSE 14263
// ru_alert := true ;
14255: LD_ADDR_EXP 56
14259: PUSH
14260: LD_INT 1
14262: ST_TO_ADDR
// if not See ( 1 , un ) then
14263: LD_INT 1
14265: PPUSH
14266: LD_VAR 0 1
14270: PPUSH
14271: CALL_OW 292
14275: NOT
14276: IFFALSE 14290
// SetLives ( un , 1000 ) ;
14278: LD_VAR 0 1
14282: PPUSH
14283: LD_INT 1000
14285: PPUSH
14286: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
14290: LD_ADDR_EXP 49
14294: PUSH
14295: LD_EXP 49
14299: PUSH
14300: LD_VAR 0 1
14304: DIFF
14305: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
14306: LD_VAR 0 1
14310: PPUSH
14311: LD_INT 22
14313: PUSH
14314: LD_INT 3
14316: PUSH
14317: EMPTY
14318: LIST
14319: LIST
14320: PUSH
14321: LD_INT 30
14323: PUSH
14324: LD_INT 4
14326: PUSH
14327: EMPTY
14328: LIST
14329: LIST
14330: PUSH
14331: EMPTY
14332: LIST
14333: LIST
14334: PPUSH
14335: CALL_OW 69
14339: PPUSH
14340: CALL 1023 0 1
14344: PPUSH
14345: CALL_OW 120
// continue ;
14349: GO 14215
// end ; if IsOk ( un ) and not HasTask ( un ) then
14351: LD_VAR 0 1
14355: PPUSH
14356: CALL_OW 302
14360: PUSH
14361: LD_VAR 0 1
14365: PPUSH
14366: CALL_OW 314
14370: NOT
14371: AND
14372: IFFALSE 14465
// begin for j = 1 to ru_firepoints_south [ i ] do
14374: LD_ADDR_VAR 0 3
14378: PUSH
14379: DOUBLE
14380: LD_INT 1
14382: DEC
14383: ST_TO_ADDR
14384: LD_EXP 55
14388: PUSH
14389: LD_VAR 0 2
14393: ARRAY
14394: PUSH
14395: FOR_TO
14396: IFFALSE 14463
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
14398: LD_VAR 0 1
14402: PPUSH
14403: LD_EXP 55
14407: PUSH
14408: LD_VAR 0 2
14412: ARRAY
14413: PUSH
14414: LD_VAR 0 3
14418: ARRAY
14419: PUSH
14420: LD_INT 1
14422: ARRAY
14423: PPUSH
14424: LD_EXP 55
14428: PUSH
14429: LD_VAR 0 2
14433: ARRAY
14434: PUSH
14435: LD_VAR 0 3
14439: ARRAY
14440: PUSH
14441: LD_INT 2
14443: ARRAY
14444: PPUSH
14445: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
14449: LD_VAR 0 1
14453: PPUSH
14454: LD_INT 70
14456: PPUSH
14457: CALL_OW 202
// end ;
14461: GO 14395
14463: POP
14464: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
14465: LD_VAR 0 1
14469: PPUSH
14470: CALL_OW 256
14474: PUSH
14475: LD_INT 700
14477: LESS
14478: PUSH
14479: LD_VAR 0 1
14483: PPUSH
14484: LD_INT 13
14486: PPUSH
14487: CALL_OW 308
14491: NOT
14492: AND
14493: IFFALSE 14545
// begin ComMoveToArea ( un , retreatArea ) ;
14495: LD_VAR 0 1
14499: PPUSH
14500: LD_INT 13
14502: PPUSH
14503: CALL_OW 113
// if not ru_alert_xy then
14507: LD_EXP 57
14511: NOT
14512: IFFALSE 14543
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
14514: LD_ADDR_EXP 57
14518: PUSH
14519: LD_VAR 0 1
14523: PPUSH
14524: CALL_OW 250
14528: PUSH
14529: LD_VAR 0 1
14533: PPUSH
14534: CALL_OW 251
14538: PUSH
14539: EMPTY
14540: LIST
14541: LIST
14542: ST_TO_ADDR
// end else
14543: GO 14614
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
14545: LD_VAR 0 1
14549: PPUSH
14550: LD_VAR 0 4
14554: PPUSH
14555: LD_VAR 0 1
14559: PPUSH
14560: CALL_OW 74
14564: PPUSH
14565: CALL_OW 296
14569: PUSH
14570: LD_INT 9
14572: LESS
14573: PUSH
14574: LD_VAR 0 1
14578: PPUSH
14579: CALL_OW 256
14583: PUSH
14584: LD_INT 500
14586: GREATER
14587: AND
14588: IFFALSE 14614
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
14590: LD_VAR 0 1
14594: PPUSH
14595: LD_VAR 0 4
14599: PPUSH
14600: LD_VAR 0 1
14604: PPUSH
14605: CALL_OW 74
14609: PPUSH
14610: CALL_OW 115
// end ;
14614: GO 14215
14616: POP
14617: POP
// end ;
14618: PPOPN 4
14620: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
14621: LD_EXP 56
14625: PUSH
14626: LD_EXP 57
14630: AND
14631: PUSH
14632: LD_EXP 29
14636: NOT
14637: AND
14638: PUSH
14639: LD_EXP 30
14643: NOT
14644: AND
14645: IFFALSE 14855
14647: GO 14649
14649: DISABLE
14650: LD_INT 0
14652: PPUSH
14653: PPUSH
// begin enable ;
14654: ENABLE
// if not ru_vehicles then
14655: LD_EXP 52
14659: NOT
14660: IFFALSE 14664
// exit ;
14662: GO 14855
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14664: LD_ADDR_VAR 0 2
14668: PUSH
14669: LD_INT 81
14671: PUSH
14672: LD_INT 3
14674: PUSH
14675: EMPTY
14676: LIST
14677: LIST
14678: PPUSH
14679: CALL_OW 69
14683: ST_TO_ADDR
// if ru_vehicles then
14684: LD_EXP 52
14688: IFFALSE 14855
// begin for i in ru_vehicles do
14690: LD_ADDR_VAR 0 1
14694: PUSH
14695: LD_EXP 52
14699: PUSH
14700: FOR_IN
14701: IFFALSE 14853
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
14703: LD_VAR 0 1
14707: PPUSH
14708: CALL_OW 302
14712: PUSH
14713: LD_VAR 0 1
14717: PPUSH
14718: LD_VAR 0 2
14722: PPUSH
14723: LD_VAR 0 1
14727: PPUSH
14728: CALL_OW 74
14732: PPUSH
14733: CALL_OW 296
14737: PUSH
14738: LD_INT 9
14740: LESS
14741: AND
14742: IFFALSE 14768
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
14744: LD_VAR 0 1
14748: PPUSH
14749: LD_VAR 0 2
14753: PPUSH
14754: LD_VAR 0 1
14758: PPUSH
14759: CALL_OW 74
14763: PPUSH
14764: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
14768: LD_VAR 0 1
14772: PPUSH
14773: CALL_OW 314
14777: NOT
14778: PUSH
14779: LD_VAR 0 1
14783: PPUSH
14784: CALL_OW 302
14788: AND
14789: PUSH
14790: LD_VAR 0 1
14794: PPUSH
14795: LD_EXP 57
14799: PUSH
14800: LD_INT 1
14802: ARRAY
14803: PPUSH
14804: LD_EXP 57
14808: PUSH
14809: LD_INT 2
14811: ARRAY
14812: PPUSH
14813: CALL_OW 297
14817: PUSH
14818: LD_INT 10
14820: GREATER
14821: AND
14822: IFFALSE 14851
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
14824: LD_VAR 0 1
14828: PPUSH
14829: LD_EXP 57
14833: PUSH
14834: LD_INT 1
14836: ARRAY
14837: PPUSH
14838: LD_EXP 57
14842: PUSH
14843: LD_INT 2
14845: ARRAY
14846: PPUSH
14847: CALL_OW 114
// end ;
14851: GO 14700
14853: POP
14854: POP
// end ; end ;
14855: PPOPN 2
14857: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
14858: LD_EXP 57
14862: PUSH
14863: LD_EXP 56
14867: AND
14868: PUSH
14869: LD_INT 3
14871: PPUSH
14872: CALL_OW 463
14876: NOT
14877: AND
14878: PUSH
14879: LD_EXP 29
14883: NOT
14884: AND
14885: PUSH
14886: LD_EXP 30
14890: NOT
14891: AND
14892: IFFALSE 14987
14894: GO 14896
14896: DISABLE
14897: LD_INT 0
14899: PPUSH
// begin enable ;
14900: ENABLE
// ru_alert_xy := false ;
14901: LD_ADDR_EXP 57
14905: PUSH
14906: LD_INT 0
14908: ST_TO_ADDR
// ru_alert := false ;
14909: LD_ADDR_EXP 56
14913: PUSH
14914: LD_INT 0
14916: ST_TO_ADDR
// if ru_vehicles then
14917: LD_EXP 52
14921: IFFALSE 14987
// for i in ru_vehicles do
14923: LD_ADDR_VAR 0 1
14927: PUSH
14928: LD_EXP 52
14932: PUSH
14933: FOR_IN
14934: IFFALSE 14985
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
14936: LD_VAR 0 1
14940: PPUSH
14941: CALL_OW 302
14945: PUSH
14946: LD_VAR 0 1
14950: PPUSH
14951: LD_INT 89
14953: PPUSH
14954: LD_INT 36
14956: PPUSH
14957: CALL_OW 297
14961: PUSH
14962: LD_INT 10
14964: GREATER
14965: AND
14966: IFFALSE 14983
// ComMoveXY ( i , 89 , 36 ) ;
14968: LD_VAR 0 1
14972: PPUSH
14973: LD_INT 89
14975: PPUSH
14976: LD_INT 36
14978: PPUSH
14979: CALL_OW 111
14983: GO 14933
14985: POP
14986: POP
// end ;
14987: PPOPN 1
14989: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
14990: LD_EXP 51
14994: PUSH
14995: LD_EXP 29
14999: NOT
15000: AND
15001: PUSH
15002: LD_EXP 30
15006: NOT
15007: AND
15008: IFFALSE 15292
15010: GO 15012
15012: DISABLE
15013: LD_INT 0
15015: PPUSH
15016: PPUSH
15017: PPUSH
// begin enable ;
15018: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15019: LD_ADDR_VAR 0 3
15023: PUSH
15024: LD_INT 81
15026: PUSH
15027: LD_INT 3
15029: PUSH
15030: EMPTY
15031: LIST
15032: LIST
15033: PPUSH
15034: CALL_OW 69
15038: ST_TO_ADDR
// for i = 1 to ru_forest do
15039: LD_ADDR_VAR 0 1
15043: PUSH
15044: DOUBLE
15045: LD_INT 1
15047: DEC
15048: ST_TO_ADDR
15049: LD_EXP 51
15053: PUSH
15054: FOR_TO
15055: IFFALSE 15290
// begin un := ru_forest [ i ] ;
15057: LD_ADDR_VAR 0 2
15061: PUSH
15062: LD_EXP 51
15066: PUSH
15067: LD_VAR 0 1
15071: ARRAY
15072: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15073: LD_VAR 0 2
15077: PPUSH
15078: LD_INT 13
15080: PPUSH
15081: CALL_OW 308
15085: IFFALSE 15175
// begin if not See ( 1 , un ) then
15087: LD_INT 1
15089: PPUSH
15090: LD_VAR 0 2
15094: PPUSH
15095: CALL_OW 292
15099: NOT
15100: IFFALSE 15114
// SetLives ( un , 1000 ) ;
15102: LD_VAR 0 2
15106: PPUSH
15107: LD_INT 1000
15109: PPUSH
15110: CALL_OW 234
// ru_forest := ru_forest diff un ;
15114: LD_ADDR_EXP 51
15118: PUSH
15119: LD_EXP 51
15123: PUSH
15124: LD_VAR 0 2
15128: DIFF
15129: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15130: LD_VAR 0 2
15134: PPUSH
15135: LD_INT 22
15137: PUSH
15138: LD_INT 3
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: PUSH
15145: LD_INT 30
15147: PUSH
15148: LD_INT 4
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: PUSH
15155: EMPTY
15156: LIST
15157: LIST
15158: PPUSH
15159: CALL_OW 69
15163: PPUSH
15164: CALL 1023 0 1
15168: PPUSH
15169: CALL_OW 120
// continue ;
15173: GO 15054
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15175: LD_VAR 0 2
15179: PPUSH
15180: CALL_OW 256
15184: PUSH
15185: LD_INT 700
15187: LESS
15188: PUSH
15189: LD_VAR 0 2
15193: PPUSH
15194: LD_INT 13
15196: PPUSH
15197: CALL_OW 308
15201: NOT
15202: AND
15203: IFFALSE 15219
// ComMoveToArea ( un , retreatArea ) else
15205: LD_VAR 0 2
15209: PPUSH
15210: LD_INT 13
15212: PPUSH
15213: CALL_OW 113
15217: GO 15288
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15219: LD_VAR 0 2
15223: PPUSH
15224: LD_VAR 0 3
15228: PPUSH
15229: LD_VAR 0 2
15233: PPUSH
15234: CALL_OW 74
15238: PPUSH
15239: CALL_OW 296
15243: PUSH
15244: LD_INT 9
15246: LESS
15247: PUSH
15248: LD_VAR 0 2
15252: PPUSH
15253: CALL_OW 256
15257: PUSH
15258: LD_INT 500
15260: GREATER
15261: AND
15262: IFFALSE 15288
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15264: LD_VAR 0 2
15268: PPUSH
15269: LD_VAR 0 3
15273: PPUSH
15274: LD_VAR 0 2
15278: PPUSH
15279: CALL_OW 74
15283: PPUSH
15284: CALL_OW 115
// end ;
15288: GO 15054
15290: POP
15291: POP
// end ;
15292: PPOPN 3
15294: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
15295: LD_EXP 30
15299: NOT
15300: IFFALSE 15421
15302: GO 15304
15304: DISABLE
15305: LD_INT 0
15307: PPUSH
15308: PPUSH
// begin enable ;
15309: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
15310: LD_ADDR_VAR 0 2
15314: PUSH
15315: LD_INT 22
15317: PUSH
15318: LD_INT 3
15320: PUSH
15321: EMPTY
15322: LIST
15323: LIST
15324: PUSH
15325: LD_INT 21
15327: PUSH
15328: LD_INT 3
15330: PUSH
15331: EMPTY
15332: LIST
15333: LIST
15334: PUSH
15335: EMPTY
15336: LIST
15337: LIST
15338: PPUSH
15339: CALL_OW 69
15343: ST_TO_ADDR
// if filter then
15344: LD_VAR 0 2
15348: IFFALSE 15421
// for i in filter do
15350: LD_ADDR_VAR 0 1
15354: PUSH
15355: LD_VAR 0 2
15359: PUSH
15360: FOR_IN
15361: IFFALSE 15419
// if GetLives ( i ) < 990 then
15363: LD_VAR 0 1
15367: PPUSH
15368: CALL_OW 256
15372: PUSH
15373: LD_INT 990
15375: LESS
15376: IFFALSE 15417
// begin ru_alert := true ;
15378: LD_ADDR_EXP 56
15382: PUSH
15383: LD_INT 1
15385: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
15386: LD_ADDR_EXP 57
15390: PUSH
15391: LD_VAR 0 1
15395: PPUSH
15396: CALL_OW 250
15400: PUSH
15401: LD_VAR 0 1
15405: PPUSH
15406: CALL_OW 251
15410: PUSH
15411: EMPTY
15412: LIST
15413: LIST
15414: ST_TO_ADDR
// break ;
15415: GO 15419
// end ;
15417: GO 15360
15419: POP
15420: POP
// end ;
15421: PPOPN 2
15423: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
15424: LD_EXP 29
15428: IFFALSE 15577
15430: GO 15432
15432: DISABLE
15433: LD_INT 0
15435: PPUSH
15436: PPUSH
15437: PPUSH
15438: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
15439: LD_ADDR_VAR 0 4
15443: PUSH
15444: LD_EXP 52
15448: PUSH
15449: LD_EXP 51
15453: ADD
15454: PUSH
15455: LD_EXP 49
15459: ADD
15460: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
15461: LD_ADDR_VAR 0 3
15465: PUSH
15466: LD_INT 3
15468: PPUSH
15469: LD_INT 81
15471: PUSH
15472: LD_INT 3
15474: PUSH
15475: EMPTY
15476: LIST
15477: LIST
15478: PPUSH
15479: CALL_OW 70
15483: ST_TO_ADDR
// if filter and enemy then
15484: LD_VAR 0 4
15488: PUSH
15489: LD_VAR 0 3
15493: AND
15494: IFFALSE 15577
// repeat wait ( 0 0$01 ) ;
15496: LD_INT 35
15498: PPUSH
15499: CALL_OW 67
// for i in filter do
15503: LD_ADDR_VAR 0 1
15507: PUSH
15508: LD_VAR 0 4
15512: PUSH
15513: FOR_IN
15514: IFFALSE 15542
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15516: LD_VAR 0 1
15520: PPUSH
15521: LD_VAR 0 3
15525: PPUSH
15526: LD_VAR 0 1
15530: PPUSH
15531: CALL_OW 74
15535: PPUSH
15536: CALL_OW 115
// end ;
15540: GO 15513
15542: POP
15543: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
15544: LD_INT 3
15546: PPUSH
15547: LD_INT 81
15549: PUSH
15550: LD_INT 3
15552: PUSH
15553: EMPTY
15554: LIST
15555: LIST
15556: PPUSH
15557: CALL_OW 70
15561: PUSH
15562: LD_INT 0
15564: EQUAL
15565: PUSH
15566: LD_VAR 0 4
15570: PUSH
15571: LD_INT 0
15573: EQUAL
15574: OR
15575: IFFALSE 15496
// end ;
15577: PPOPN 4
15579: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) do var i ;
15580: LD_EXP 25
15584: PUSH
15585: LD_INT 22
15587: PUSH
15588: LD_INT 4
15590: PUSH
15591: EMPTY
15592: LIST
15593: LIST
15594: PUSH
15595: LD_INT 30
15597: PUSH
15598: LD_INT 4
15600: PUSH
15601: EMPTY
15602: LIST
15603: LIST
15604: PUSH
15605: EMPTY
15606: LIST
15607: LIST
15608: PPUSH
15609: CALL_OW 69
15613: AND
15614: IFFALSE 15663
15616: GO 15618
15618: DISABLE
15619: LD_INT 0
15621: PPUSH
// begin if not ru_cornel_attack then
15622: LD_EXP 54
15626: NOT
15627: IFFALSE 15631
// exit ;
15629: GO 15663
// for i in ru_cornel_attack do
15631: LD_ADDR_VAR 0 1
15635: PUSH
15636: LD_EXP 54
15640: PUSH
15641: FOR_IN
15642: IFFALSE 15661
// ComAgressiveMove ( i , 258 , 119 ) ;
15644: LD_VAR 0 1
15648: PPUSH
15649: LD_INT 258
15651: PPUSH
15652: LD_INT 119
15654: PPUSH
15655: CALL_OW 114
15659: GO 15641
15661: POP
15662: POP
// end ; end_of_file
15663: PPOPN 1
15665: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
15666: LD_EXP 5
15670: PUSH
15671: LD_EXP 9
15675: NOT
15676: AND
15677: PUSH
15678: LD_EXP 19
15682: AND
15683: IFFALSE 15795
15685: GO 15687
15687: DISABLE
15688: LD_INT 0
15690: PPUSH
// begin enable ;
15691: ENABLE
// crates_counter := crates_counter - 50 ;
15692: LD_ADDR_EXP 19
15696: PUSH
15697: LD_EXP 19
15701: PUSH
15702: LD_INT 50
15704: MINUS
15705: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
15706: LD_INT 8
15708: PPUSH
15709: LD_INT 2
15711: PPUSH
15712: LD_INT 5
15714: PPUSH
15715: CALL_OW 12
15719: PPUSH
15720: LD_INT 1
15722: PPUSH
15723: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
15727: LD_INT 1785
15729: PPUSH
15730: LD_INT 2345
15732: PPUSH
15733: CALL_OW 12
15737: PPUSH
15738: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
15742: LD_ADDR_VAR 0 1
15746: PUSH
15747: LD_INT 1
15749: PPUSH
15750: LD_OWVAR 67
15754: PUSH
15755: LD_INT 2
15757: PLUS
15758: PPUSH
15759: CALL_OW 12
15763: ST_TO_ADDR
// if r < 3 then
15764: LD_VAR 0 1
15768: PUSH
15769: LD_INT 3
15771: LESS
15772: IFFALSE 15795
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
15774: LD_INT 4
15776: PPUSH
15777: LD_INT 1
15779: PPUSH
15780: LD_INT 5
15782: PPUSH
15783: CALL_OW 12
15787: PPUSH
15788: LD_INT 1
15790: PPUSH
15791: CALL_OW 55
// end ;
15795: PPOPN 1
15797: END
// every 0 0$01 trigger cornel_active do
15798: LD_EXP 8
15802: IFFALSE 15891
15804: GO 15806
15806: DISABLE
// begin Wait ( 0 0$03 ) ;
15807: LD_INT 105
15809: PPUSH
15810: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15814: LD_INT 2
15816: PPUSH
15817: LD_INT 5
15819: PPUSH
15820: CALL_OW 12
15824: PPUSH
15825: LD_INT 10
15827: PPUSH
15828: LD_INT 1
15830: PPUSH
15831: CALL_OW 55
// Wait ( 0 0$13 ) ;
15835: LD_INT 455
15837: PPUSH
15838: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15842: LD_INT 2
15844: PPUSH
15845: LD_INT 5
15847: PPUSH
15848: CALL_OW 12
15852: PPUSH
15853: LD_INT 10
15855: PPUSH
15856: LD_INT 1
15858: PPUSH
15859: CALL_OW 55
// Wait ( 0 0$16 ) ;
15863: LD_INT 560
15865: PPUSH
15866: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15870: LD_INT 2
15872: PPUSH
15873: LD_INT 5
15875: PPUSH
15876: CALL_OW 12
15880: PPUSH
15881: LD_INT 10
15883: PPUSH
15884: LD_INT 1
15886: PPUSH
15887: CALL_OW 55
// end ; end_of_file
15891: END
// every 0 0$01 trigger cornel_prepared do
15892: LD_EXP 11
15896: IFFALSE 15955
15898: GO 15900
15900: DISABLE
// begin enable ;
15901: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
15902: LD_ADDR_OWVAR 47
15906: PUSH
15907: LD_STRING #Am03-1
15909: PUSH
15910: LD_EXP 10
15914: PUSH
15915: EMPTY
15916: LIST
15917: LIST
15918: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
15919: LD_ADDR_EXP 10
15923: PUSH
15924: LD_EXP 10
15928: PPUSH
15929: LD_STRING -
15931: PPUSH
15932: CALL 1093 0 2
15936: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
15937: LD_EXP 10
15941: PUSH
15942: LD_INT 0
15944: EQUAL
15945: IFFALSE 15955
// begin Display_Strings := [ ] ;
15947: LD_ADDR_OWVAR 47
15951: PUSH
15952: EMPTY
15953: ST_TO_ADDR
// disable ;
15954: DISABLE
// end ; end ;
15955: END
// every 0 0$01 trigger debug and debug_strings do
15956: LD_EXP 1
15960: PUSH
15961: LD_OWVAR 48
15965: AND
15966: IFFALSE 15982
15968: GO 15970
15970: DISABLE
// begin enable ;
15971: ENABLE
// Display_Strings := debug_strings ;
15972: LD_ADDR_OWVAR 47
15976: PUSH
15977: LD_OWVAR 48
15981: ST_TO_ADDR
// end ; end_of_file
15982: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
15983: LD_VAR 0 1
15987: PPUSH
15988: CALL_OW 255
15992: PUSH
15993: LD_INT 1
15995: EQUAL
15996: PUSH
15997: LD_EXP 13
16001: NOT
16002: AND
16003: IFFALSE 16013
// solar_builded := true ;
16005: LD_ADDR_EXP 13
16009: PUSH
16010: LD_INT 1
16012: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
16013: LD_VAR 0 1
16017: PPUSH
16018: CALL_OW 255
16022: PUSH
16023: LD_INT 1
16025: EQUAL
16026: PUSH
16027: LD_EXP 27
16031: AND
16032: IFFALSE 16065
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
16034: LD_ADDR_EXP 27
16038: PUSH
16039: LD_EXP 27
16043: PUSH
16044: LD_INT 1750
16046: PUSH
16047: LD_INT 1400
16049: PUSH
16050: LD_INT 1225
16052: PUSH
16053: EMPTY
16054: LIST
16055: LIST
16056: LIST
16057: PUSH
16058: LD_OWVAR 67
16062: ARRAY
16063: PLUS
16064: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
16065: LD_VAR 0 1
16069: PPUSH
16070: CALL_OW 255
16074: PUSH
16075: LD_INT 3
16077: EQUAL
16078: IFFALSE 16096
// ru_vehicles := ru_vehicles ^ veh ;
16080: LD_ADDR_EXP 52
16084: PUSH
16085: LD_EXP 52
16089: PUSH
16090: LD_VAR 0 1
16094: ADD
16095: ST_TO_ADDR
// end ;
16096: PPOPN 2
16098: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
16099: LD_VAR 0 1
16103: PUSH
16104: LD_EXP 49
16108: IN
16109: IFFALSE 16127
// ru_patrol := ru_patrol diff un ;
16111: LD_ADDR_EXP 49
16115: PUSH
16116: LD_EXP 49
16120: PUSH
16121: LD_VAR 0 1
16125: DIFF
16126: ST_TO_ADDR
// if un in ru_forest then
16127: LD_VAR 0 1
16131: PUSH
16132: LD_EXP 51
16136: IN
16137: IFFALSE 16155
// ru_forest := ru_forest diff un ;
16139: LD_ADDR_EXP 51
16143: PUSH
16144: LD_EXP 51
16148: PUSH
16149: LD_VAR 0 1
16153: DIFF
16154: ST_TO_ADDR
// if un in ru_vehicles then
16155: LD_VAR 0 1
16159: PUSH
16160: LD_EXP 52
16164: IN
16165: IFFALSE 16240
// begin ru_vehicles := ru_vehicles diff un ;
16167: LD_ADDR_EXP 52
16171: PUSH
16172: LD_EXP 52
16176: PUSH
16177: LD_VAR 0 1
16181: DIFF
16182: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
16183: LD_ADDR_EXP 53
16187: PUSH
16188: LD_EXP 53
16192: PUSH
16193: LD_VAR 0 1
16197: PPUSH
16198: CALL_OW 265
16202: PUSH
16203: LD_VAR 0 1
16207: PPUSH
16208: CALL_OW 262
16212: PUSH
16213: LD_VAR 0 1
16217: PPUSH
16218: CALL_OW 263
16222: PUSH
16223: LD_VAR 0 1
16227: PPUSH
16228: CALL_OW 264
16232: PUSH
16233: EMPTY
16234: LIST
16235: LIST
16236: LIST
16237: LIST
16238: ADD
16239: ST_TO_ADDR
// end ; if un = JMM then
16240: LD_VAR 0 1
16244: PUSH
16245: LD_EXP 33
16249: EQUAL
16250: IFFALSE 16259
// YouLost ( 0 ) ;
16252: LD_STRING 0
16254: PPUSH
16255: CALL_OW 104
// if un = us_dep_west then
16259: LD_VAR 0 1
16263: PUSH
16264: LD_INT 1
16266: EQUAL
16267: IFFALSE 16276
// YouLost ( 2 ) ;
16269: LD_STRING 2
16271: PPUSH
16272: CALL_OW 104
// if un = Lynch and GetSide ( Lynch ) = 8 then
16276: LD_VAR 0 1
16280: PUSH
16281: LD_EXP 43
16285: EQUAL
16286: PUSH
16287: LD_EXP 43
16291: PPUSH
16292: CALL_OW 255
16296: PUSH
16297: LD_INT 8
16299: EQUAL
16300: AND
16301: IFFALSE 16310
// YouLost ( 4 ) ;
16303: LD_STRING 4
16305: PPUSH
16306: CALL_OW 104
// if un in jmm_units then
16310: LD_VAR 0 1
16314: PUSH
16315: LD_EXP 4
16319: IN
16320: IFFALSE 16336
// lose_counter := lose_counter + 1 ;
16322: LD_ADDR_EXP 32
16326: PUSH
16327: LD_EXP 32
16331: PUSH
16332: LD_INT 1
16334: PLUS
16335: ST_TO_ADDR
// end ;
16336: PPOPN 1
16338: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
16339: LD_INT 0
16341: PPUSH
16342: PPUSH
// begin if GetSide ( driver ) = 3 then
16343: LD_VAR 0 1
16347: PPUSH
16348: CALL_OW 255
16352: PUSH
16353: LD_INT 3
16355: EQUAL
16356: IFFALSE 16434
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
16358: LD_ADDR_VAR 0 6
16362: PUSH
16363: LD_INT 22
16365: PUSH
16366: LD_INT 3
16368: PUSH
16369: EMPTY
16370: LIST
16371: LIST
16372: PUSH
16373: LD_INT 30
16375: PUSH
16376: LD_INT 3
16378: PUSH
16379: EMPTY
16380: LIST
16381: LIST
16382: PUSH
16383: EMPTY
16384: LIST
16385: LIST
16386: PPUSH
16387: CALL_OW 69
16391: PPUSH
16392: CALL 1023 0 1
16396: ST_TO_ADDR
// if place then
16397: LD_VAR 0 6
16401: IFFALSE 16419
// ComEnterUnit ( driver , place ) else
16403: LD_VAR 0 1
16407: PPUSH
16408: LD_VAR 0 6
16412: PPUSH
16413: CALL_OW 120
16417: GO 16434
// ComMoveXY ( driver , 70 , 22 ) ;
16419: LD_VAR 0 1
16423: PPUSH
16424: LD_INT 70
16426: PPUSH
16427: LD_INT 22
16429: PPUSH
16430: CALL_OW 111
// end ; end ;
16434: PPOPN 6
16436: END
// every 0 0$01 trigger not game_end and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) < 4 do
16437: LD_EXP 31
16441: NOT
16442: PUSH
16443: LD_INT 22
16445: PUSH
16446: LD_INT 1
16448: PUSH
16449: EMPTY
16450: LIST
16451: LIST
16452: PUSH
16453: LD_INT 21
16455: PUSH
16456: LD_INT 1
16458: PUSH
16459: EMPTY
16460: LIST
16461: LIST
16462: PUSH
16463: EMPTY
16464: LIST
16465: LIST
16466: PPUSH
16467: CALL_OW 69
16471: PUSH
16472: LD_INT 22
16474: PUSH
16475: LD_INT 8
16477: PUSH
16478: EMPTY
16479: LIST
16480: LIST
16481: PUSH
16482: LD_INT 21
16484: PUSH
16485: LD_INT 1
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PUSH
16492: EMPTY
16493: LIST
16494: LIST
16495: PPUSH
16496: CALL_OW 69
16500: PLUS
16501: PUSH
16502: LD_INT 4
16504: LESS
16505: AND
16506: IFFALSE 16518
16508: GO 16510
16510: DISABLE
// YouLost ( 1 ) ;
16511: LD_STRING 1
16513: PPUSH
16514: CALL_OW 104
16518: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
16519: LD_INT 1
16521: PPUSH
16522: CALL_OW 255
16526: PUSH
16527: LD_INT 3
16529: EQUAL
16530: IFFALSE 16542
16532: GO 16534
16534: DISABLE
// YouLost ( 3 ) ;
16535: LD_STRING 3
16537: PPUSH
16538: CALL_OW 104
16542: END
