// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 19 0 0
// if debug then
   8: LD_EXP 1
  12: IFFALSE 18
// DebugMode ;
  14: CALL 59 0 0
// end ;
  18: END
// export debug ; export jmm_units , cornel_units , bierezov_exist ; function Init ; begin
  19: LD_INT 0
  21: PPUSH
// debug := true ;
  22: LD_ADDR_EXP 1
  26: PUSH
  27: LD_INT 1
  29: ST_TO_ADDR
// jmm_units := 0 ;
  30: LD_ADDR_EXP 2
  34: PUSH
  35: LD_INT 0
  37: ST_TO_ADDR
// cornel_units := 0 ;
  38: LD_ADDR_EXP 3
  42: PUSH
  43: LD_INT 0
  45: ST_TO_ADDR
// bierezov_exist := false ;
  46: LD_ADDR_EXP 4
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// end ;
  54: LD_VAR 0 1
  58: RET
// export function DebugMode ; begin
  59: LD_INT 0
  61: PPUSH
// end ; end_of_file
  62: LD_VAR 0 1
  66: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
  67: LD_INT 0
  69: PPUSH
  70: PPUSH
// if exist_mode then
  71: LD_VAR 0 2
  75: IFFALSE 94
// unit := CreateCharacter ( ident ) else
  77: LD_ADDR_VAR 0 4
  81: PUSH
  82: LD_VAR 0 1
  86: PPUSH
  87: CALL_OW 34
  91: ST_TO_ADDR
  92: GO 109
// unit := NewCharacter ( ident ) ;
  94: LD_ADDR_VAR 0 4
  98: PUSH
  99: LD_VAR 0 1
 103: PPUSH
 104: CALL_OW 25
 108: ST_TO_ADDR
// result := unit ;
 109: LD_ADDR_VAR 0 3
 113: PUSH
 114: LD_VAR 0 4
 118: ST_TO_ADDR
// end ;
 119: LD_VAR 0 3
 123: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 124: LD_INT 0
 126: PPUSH
// uc_side := side ;
 127: LD_ADDR_OWVAR 20
 131: PUSH
 132: LD_VAR 0 1
 136: ST_TO_ADDR
// uc_nation := nation ;
 137: LD_ADDR_OWVAR 21
 141: PUSH
 142: LD_VAR 0 2
 146: ST_TO_ADDR
// vc_chassis := chassis ;
 147: LD_ADDR_OWVAR 37
 151: PUSH
 152: LD_VAR 0 3
 156: ST_TO_ADDR
// vc_engine := engine ;
 157: LD_ADDR_OWVAR 39
 161: PUSH
 162: LD_VAR 0 4
 166: ST_TO_ADDR
// vc_control := control ;
 167: LD_ADDR_OWVAR 38
 171: PUSH
 172: LD_VAR 0 5
 176: ST_TO_ADDR
// vc_weapon := weapon ;
 177: LD_ADDR_OWVAR 40
 181: PUSH
 182: LD_VAR 0 6
 186: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 187: LD_ADDR_OWVAR 41
 191: PUSH
 192: LD_VAR 0 7
 196: ST_TO_ADDR
// result := CreateVehicle ;
 197: LD_ADDR_VAR 0 8
 201: PUSH
 202: CALL_OW 45
 206: ST_TO_ADDR
// end ;
 207: LD_VAR 0 8
 211: RET
// export function SayX ( units , ident ) ; var i ; begin
 212: LD_INT 0
 214: PPUSH
 215: PPUSH
// if not units then
 216: LD_VAR 0 1
 220: NOT
 221: IFFALSE 225
// exit ;
 223: GO 269
// for i in ident do
 225: LD_ADDR_VAR 0 4
 229: PUSH
 230: LD_VAR 0 2
 234: PUSH
 235: FOR_IN
 236: IFFALSE 267
// if IsOk ( i ) then
 238: LD_VAR 0 4
 242: PPUSH
 243: CALL_OW 302
 247: IFFALSE 265
// begin Say ( i , ident ) ;
 249: LD_VAR 0 4
 253: PPUSH
 254: LD_VAR 0 2
 258: PPUSH
 259: CALL_OW 88
// break ;
 263: GO 267
// end ;
 265: GO 235
 267: POP
 268: POP
// end ;
 269: LD_VAR 0 3
 273: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 274: LD_INT 0
 276: PPUSH
 277: PPUSH
 278: PPUSH
 279: PPUSH
// for i = 1 to count do
 280: LD_ADDR_VAR 0 8
 284: PUSH
 285: DOUBLE
 286: LD_INT 1
 288: DEC
 289: ST_TO_ADDR
 290: LD_VAR 0 6
 294: PUSH
 295: FOR_TO
 296: IFFALSE 377
// begin uc_side = side ;
 298: LD_ADDR_OWVAR 20
 302: PUSH
 303: LD_VAR 0 1
 307: ST_TO_ADDR
// uc_nation = nation ;
 308: LD_ADDR_OWVAR 21
 312: PUSH
 313: LD_VAR 0 2
 317: ST_TO_ADDR
// hc_gallery =  ;
 318: LD_ADDR_OWVAR 33
 322: PUSH
 323: LD_STRING 
 325: ST_TO_ADDR
// hc_name =  ;
 326: LD_ADDR_OWVAR 26
 330: PUSH
 331: LD_STRING 
 333: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 334: LD_INT 0
 336: PPUSH
 337: LD_VAR 0 5
 341: PPUSH
 342: LD_VAR 0 4
 346: PPUSH
 347: CALL_OW 380
// un = CreateHuman ;
 351: LD_ADDR_VAR 0 10
 355: PUSH
 356: CALL_OW 44
 360: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 361: LD_VAR 0 10
 365: PPUSH
 366: LD_VAR 0 3
 370: PPUSH
 371: CALL_OW 52
// end ;
 375: GO 295
 377: POP
 378: POP
// end ;
 379: LD_VAR 0 7
 383: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 384: LD_INT 0
 386: PPUSH
 387: PPUSH
 388: PPUSH
// uc_side := GetSide ( b ) ;
 389: LD_ADDR_OWVAR 20
 393: PUSH
 394: LD_VAR 0 2
 398: PPUSH
 399: CALL_OW 255
 403: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 404: LD_ADDR_OWVAR 21
 408: PUSH
 409: LD_VAR 0 2
 413: PPUSH
 414: CALL_OW 248
 418: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 419: LD_INT 0
 421: PPUSH
 422: LD_INT 1
 424: PPUSH
 425: LD_VAR 0 1
 429: PPUSH
 430: CALL_OW 380
// un = CreateHuman ;
 434: LD_ADDR_VAR 0 4
 438: PUSH
 439: CALL_OW 44
 443: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 444: LD_ADDR_VAR 0 5
 448: PUSH
 449: LD_VAR 0 2
 453: PPUSH
 454: CALL_OW 254
 458: PUSH
 459: LD_INT 3
 461: MINUS
 462: ST_TO_ADDR
// if dir < 0 then
 463: LD_VAR 0 5
 467: PUSH
 468: LD_INT 0
 470: LESS
 471: IFFALSE 487
// dir := 6 + dir ;
 473: LD_ADDR_VAR 0 5
 477: PUSH
 478: LD_INT 6
 480: PUSH
 481: LD_VAR 0 5
 485: PLUS
 486: ST_TO_ADDR
// SetDir ( un , dir ) ;
 487: LD_VAR 0 4
 491: PPUSH
 492: LD_VAR 0 5
 496: PPUSH
 497: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 501: LD_VAR 0 4
 505: PPUSH
 506: LD_VAR 0 2
 510: PPUSH
 511: CALL_OW 52
// end ; end_of_file
 515: LD_VAR 0 3
 519: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
 520: LD_INT 0
 522: PPUSH
 523: PPUSH
 524: PPUSH
 525: PPUSH
 526: PPUSH
 527: PPUSH
 528: PPUSH
 529: PPUSH
// uc_side := 4 ;
 530: LD_ADDR_OWVAR 20
 534: PUSH
 535: LD_INT 4
 537: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
 538: LD_ADDR_EXP 14
 542: PUSH
 543: LD_STRING Powell
 545: PPUSH
 546: LD_INT 0
 548: PPUSH
 549: CALL 67 0 2
 553: ST_TO_ADDR
// uc_side := 1 ;
 554: LD_ADDR_OWVAR 20
 558: PUSH
 559: LD_INT 1
 561: ST_TO_ADDR
// uc_nation := 1 ;
 562: LD_ADDR_OWVAR 21
 566: PUSH
 567: LD_INT 1
 569: ST_TO_ADDR
// if debug then
 570: LD_EXP 1
 574: IFFALSE 643
// begin for i = 1 to 4 do
 576: LD_ADDR_VAR 0 2
 580: PUSH
 581: DOUBLE
 582: LD_INT 1
 584: DEC
 585: ST_TO_ADDR
 586: LD_INT 4
 588: PUSH
 589: FOR_TO
 590: IFFALSE 641
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
 592: LD_INT 0
 594: PPUSH
 595: LD_INT 1
 597: PPUSH
 598: LD_INT 2
 600: PPUSH
 601: CALL_OW 12
 605: PPUSH
 606: LD_INT 3
 608: PPUSH
 609: CALL_OW 380
// un := CreateHuman ;
 613: LD_ADDR_VAR 0 3
 617: PUSH
 618: CALL_OW 44
 622: ST_TO_ADDR
// others := others ^ un ;
 623: LD_ADDR_VAR 0 5
 627: PUSH
 628: LD_VAR 0 5
 632: PUSH
 633: LD_VAR 0 3
 637: ADD
 638: ST_TO_ADDR
// end ;
 639: GO 589
 641: POP
 642: POP
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
 643: LD_ADDR_EXP 5
 647: PUSH
 648: LD_STRING JMM
 650: PPUSH
 651: LD_EXP 1
 655: NOT
 656: PPUSH
 657: CALL 67 0 2
 661: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
 662: LD_ADDR_EXP 6
 666: PUSH
 667: LD_STRING Bobby
 669: PPUSH
 670: LD_EXP 1
 674: NOT
 675: PPUSH
 676: CALL 67 0 2
 680: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
 681: LD_ADDR_EXP 7
 685: PUSH
 686: LD_STRING Cyrus
 688: PPUSH
 689: LD_EXP 1
 693: NOT
 694: PPUSH
 695: CALL 67 0 2
 699: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
 700: LD_ADDR_EXP 8
 704: PUSH
 705: LD_STRING Lisa
 707: PPUSH
 708: LD_EXP 1
 712: NOT
 713: PPUSH
 714: CALL 67 0 2
 718: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
 719: LD_ADDR_EXP 9
 723: PUSH
 724: LD_STRING Khatam
 726: PPUSH
 727: LD_EXP 1
 731: NOT
 732: PPUSH
 733: CALL 67 0 2
 737: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
 738: LD_ADDR_EXP 10
 742: PUSH
 743: LD_STRING Brian
 745: PPUSH
 746: LD_EXP 1
 750: NOT
 751: PPUSH
 752: CALL 67 0 2
 756: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
 757: LD_ADDR_EXP 11
 761: PUSH
 762: LD_STRING Jerry
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: CALL 67 0 2
 775: ST_TO_ADDR
// if Bobby then
 776: LD_EXP 6
 780: IFFALSE 811
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
 782: LD_ADDR_VAR 0 4
 786: PUSH
 787: LD_VAR 0 4
 791: PPUSH
 792: LD_VAR 0 4
 796: PUSH
 797: LD_INT 1
 799: PLUS
 800: PPUSH
 801: LD_EXP 6
 805: PPUSH
 806: CALL_OW 2
 810: ST_TO_ADDR
// if Cyrus then
 811: LD_EXP 7
 815: IFFALSE 846
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
 817: LD_ADDR_VAR 0 4
 821: PUSH
 822: LD_VAR 0 4
 826: PPUSH
 827: LD_VAR 0 4
 831: PUSH
 832: LD_INT 1
 834: PLUS
 835: PPUSH
 836: LD_EXP 7
 840: PPUSH
 841: CALL_OW 2
 845: ST_TO_ADDR
// if Lisa then
 846: LD_EXP 8
 850: IFFALSE 881
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
 852: LD_ADDR_VAR 0 4
 856: PUSH
 857: LD_VAR 0 4
 861: PPUSH
 862: LD_VAR 0 4
 866: PUSH
 867: LD_INT 1
 869: PLUS
 870: PPUSH
 871: LD_EXP 8
 875: PPUSH
 876: CALL_OW 2
 880: ST_TO_ADDR
// if Khatam then
 881: LD_EXP 9
 885: IFFALSE 916
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
 887: LD_ADDR_VAR 0 4
 891: PUSH
 892: LD_VAR 0 4
 896: PPUSH
 897: LD_VAR 0 4
 901: PUSH
 902: LD_INT 1
 904: PLUS
 905: PPUSH
 906: LD_EXP 9
 910: PPUSH
 911: CALL_OW 2
 915: ST_TO_ADDR
// if Brian then
 916: LD_EXP 10
 920: IFFALSE 951
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
 922: LD_ADDR_VAR 0 4
 926: PUSH
 927: LD_VAR 0 4
 931: PPUSH
 932: LD_VAR 0 4
 936: PUSH
 937: LD_INT 1
 939: PLUS
 940: PPUSH
 941: LD_EXP 10
 945: PPUSH
 946: CALL_OW 2
 950: ST_TO_ADDR
// if Jerry then
 951: LD_EXP 11
 955: IFFALSE 986
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
 957: LD_ADDR_VAR 0 4
 961: PUSH
 962: LD_VAR 0 4
 966: PPUSH
 967: LD_VAR 0 4
 971: PUSH
 972: LD_INT 1
 974: PLUS
 975: PPUSH
 976: LD_EXP 11
 980: PPUSH
 981: CALL_OW 2
 985: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
 986: LD_STRING 02_other_survivors
 988: PPUSH
 989: CALL_OW 28
 993: IFFALSE 1008
// others := CreateCharacterSet ( 02_other_survivors ) ;
 995: LD_ADDR_VAR 0 5
 999: PUSH
1000: LD_STRING 02_other_survivors
1002: PPUSH
1003: CALL_OW 31
1007: ST_TO_ADDR
// if others then
1008: LD_VAR 0 5
1012: IFFALSE 1037
// begin tmp := tmp ^ others ;
1014: LD_ADDR_VAR 0 4
1018: PUSH
1019: LD_VAR 0 4
1023: PUSH
1024: LD_VAR 0 5
1028: ADD
1029: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1030: LD_STRING 02_other_survivors
1032: PPUSH
1033: CALL_OW 40
// end ; jmm_units := tmp ;
1037: LD_ADDR_EXP 2
1041: PUSH
1042: LD_VAR 0 4
1046: ST_TO_ADDR
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1047: LD_ADDR_VAR 0 6
1051: PUSH
1052: LD_STRING 02_tanks_1
1054: PPUSH
1055: LD_INT 0
1057: PPUSH
1058: CALL_OW 30
1062: ST_TO_ADDR
// if vehicles then
1063: LD_VAR 0 6
1067: IFFALSE 1261
// begin got_mech := false ;
1069: LD_ADDR_VAR 0 7
1073: PUSH
1074: LD_INT 0
1076: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1077: LD_VAR 0 4
1081: PPUSH
1082: LD_INT 25
1084: PUSH
1085: LD_INT 3
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: PPUSH
1092: CALL_OW 72
1096: IFFALSE 1106
// got_mech := true ;
1098: LD_ADDR_VAR 0 7
1102: PUSH
1103: LD_INT 1
1105: ST_TO_ADDR
// for i = 1 to vehicles do
1106: LD_ADDR_VAR 0 2
1110: PUSH
1111: DOUBLE
1112: LD_INT 1
1114: DEC
1115: ST_TO_ADDR
1116: LD_VAR 0 6
1120: PUSH
1121: FOR_TO
1122: IFFALSE 1259
// begin un := PrepareTank ( 1 , 1 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 20 ) ;
1124: LD_ADDR_VAR 0 3
1128: PUSH
1129: LD_INT 1
1131: PPUSH
1132: LD_INT 1
1134: PPUSH
1135: LD_VAR 0 6
1139: PUSH
1140: LD_VAR 0 2
1144: ARRAY
1145: PUSH
1146: LD_INT 1
1148: ARRAY
1149: PPUSH
1150: LD_VAR 0 6
1154: PUSH
1155: LD_VAR 0 2
1159: ARRAY
1160: PUSH
1161: LD_INT 2
1163: ARRAY
1164: PPUSH
1165: LD_VAR 0 6
1169: PUSH
1170: LD_VAR 0 2
1174: ARRAY
1175: PUSH
1176: LD_INT 3
1178: ARRAY
1179: PPUSH
1180: LD_VAR 0 6
1184: PUSH
1185: LD_VAR 0 2
1189: ARRAY
1190: PUSH
1191: LD_INT 4
1193: ARRAY
1194: PPUSH
1195: LD_INT 20
1197: PPUSH
1198: CALL 124 0 7
1202: ST_TO_ADDR
// if not got_mech then
1203: LD_VAR 0 7
1207: NOT
1208: IFFALSE 1234
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1210: LD_VAR 0 3
1214: PPUSH
1215: LD_VAR 0 6
1219: PUSH
1220: LD_VAR 0 2
1224: ARRAY
1225: PUSH
1226: LD_INT 6
1228: ARRAY
1229: PPUSH
1230: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1234: LD_ADDR_VAR 0 4
1238: PUSH
1239: LD_VAR 0 4
1243: PPUSH
1244: LD_INT 1
1246: PPUSH
1247: LD_VAR 0 3
1251: PPUSH
1252: CALL_OW 2
1256: ST_TO_ADDR
// end ;
1257: GO 1121
1259: POP
1260: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1261: LD_EXP 5
1265: PPUSH
1266: LD_INT 194
1268: PPUSH
1269: LD_INT 119
1271: PPUSH
1272: LD_INT 0
1274: PPUSH
1275: CALL_OW 48
// if tmp then
1279: LD_VAR 0 4
1283: IFFALSE 1408
// begin for i in tmp do
1285: LD_ADDR_VAR 0 2
1289: PUSH
1290: LD_VAR 0 4
1294: PUSH
1295: FOR_IN
1296: IFFALSE 1406
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1298: LD_ADDR_VAR 0 8
1302: PUSH
1303: LD_INT 22
1305: PUSH
1306: LD_INT 1
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: PUSH
1313: LD_INT 21
1315: PUSH
1316: LD_INT 2
1318: PUSH
1319: EMPTY
1320: LIST
1321: LIST
1322: PUSH
1323: LD_INT 58
1325: PUSH
1326: EMPTY
1327: LIST
1328: PUSH
1329: EMPTY
1330: LIST
1331: LIST
1332: LIST
1333: PPUSH
1334: CALL_OW 69
1338: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
1339: LD_VAR 0 2
1343: PPUSH
1344: CALL_OW 247
1348: PUSH
1349: LD_INT 1
1351: EQUAL
1352: PUSH
1353: LD_VAR 0 8
1357: AND
1358: IFFALSE 1380
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
1360: LD_VAR 0 2
1364: PPUSH
1365: LD_VAR 0 8
1369: PUSH
1370: LD_INT 1
1372: ARRAY
1373: PPUSH
1374: CALL_OW 52
1378: GO 1395
// PlaceUnitArea ( i , startArea , false ) ;
1380: LD_VAR 0 2
1384: PPUSH
1385: LD_INT 1
1387: PPUSH
1388: LD_INT 0
1390: PPUSH
1391: CALL_OW 49
// ComHold ( i ) ;
1395: LD_VAR 0 2
1399: PPUSH
1400: CALL_OW 140
// end ;
1404: GO 1295
1406: POP
1407: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
1408: LD_ADDR_EXP 4
1412: PUSH
1413: LD_STRING 02_mikhailStatus_1
1415: PPUSH
1416: LD_INT 0
1418: PPUSH
1419: CALL_OW 30
1423: ST_TO_ADDR
// if not bierezov_exist then
1424: LD_EXP 4
1428: NOT
1429: IFFALSE 1433
// exit ;
1431: GO 1464
// Bierezov = PrepareUnit ( Mikhail , false ) ;
1433: LD_ADDR_EXP 13
1437: PUSH
1438: LD_STRING Mikhail
1440: PPUSH
1441: LD_INT 0
1443: PPUSH
1444: CALL 67 0 2
1448: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
1449: LD_EXP 13
1453: PPUSH
1454: LD_INT 1
1456: PPUSH
1457: LD_INT 0
1459: PPUSH
1460: CALL_OW 49
// end ;
1464: LD_VAR 0 1
1468: RET
// export function PrepareCornell ; var tmp , un , i ; begin
1469: LD_INT 0
1471: PPUSH
1472: PPUSH
1473: PPUSH
1474: PPUSH
// uc_side := 4 ;
1475: LD_ADDR_OWVAR 20
1479: PUSH
1480: LD_INT 4
1482: ST_TO_ADDR
// uc_nation := 1 ;
1483: LD_ADDR_OWVAR 21
1487: PUSH
1488: LD_INT 1
1490: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
1491: LD_ADDR_EXP 12
1495: PUSH
1496: LD_STRING Cornell
1498: PPUSH
1499: LD_INT 0
1501: PPUSH
1502: CALL 67 0 2
1506: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
1507: LD_ADDR_EXP 3
1511: PUSH
1512: LD_INT 8
1514: PUSH
1515: LD_EXP 2
1519: MINUS
1520: ST_TO_ADDR
// if cornel_units < 4 then
1521: LD_EXP 3
1525: PUSH
1526: LD_INT 4
1528: LESS
1529: IFFALSE 1539
// cornel_units := 4 ;
1531: LD_ADDR_EXP 3
1535: PUSH
1536: LD_INT 4
1538: ST_TO_ADDR
// for i = 1 to cornel_units do
1539: LD_ADDR_VAR 0 4
1543: PUSH
1544: DOUBLE
1545: LD_INT 1
1547: DEC
1548: ST_TO_ADDR
1549: LD_EXP 3
1553: PUSH
1554: FOR_TO
1555: IFFALSE 1642
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ rand ( 1 , 5 ) ] , 3 ) ;
1557: LD_INT 0
1559: PPUSH
1560: LD_INT 1
1562: PUSH
1563: LD_INT 1
1565: PUSH
1566: LD_INT 1
1568: PUSH
1569: LD_INT 2
1571: PUSH
1572: LD_INT 4
1574: PUSH
1575: EMPTY
1576: LIST
1577: LIST
1578: LIST
1579: LIST
1580: LIST
1581: PUSH
1582: LD_INT 1
1584: PPUSH
1585: LD_INT 5
1587: PPUSH
1588: CALL_OW 12
1592: ARRAY
1593: PPUSH
1594: LD_INT 3
1596: PPUSH
1597: CALL_OW 380
// un := CreateHuman ;
1601: LD_ADDR_VAR 0 3
1605: PUSH
1606: CALL_OW 44
1610: ST_TO_ADDR
// tmp := Insert ( tmp , tmp + 1 , un ) ;
1611: LD_ADDR_VAR 0 2
1615: PUSH
1616: LD_VAR 0 2
1620: PPUSH
1621: LD_VAR 0 2
1625: PUSH
1626: LD_INT 1
1628: PLUS
1629: PPUSH
1630: LD_VAR 0 3
1634: PPUSH
1635: CALL_OW 2
1639: ST_TO_ADDR
// end ;
1640: GO 1554
1642: POP
1643: POP
// end ;
1644: LD_VAR 0 1
1648: RET
// export function PrepareWesternBase ; begin
1649: LD_INT 0
1651: PPUSH
// uc_side := 4 ;
1652: LD_ADDR_OWVAR 20
1656: PUSH
1657: LD_INT 4
1659: ST_TO_ADDR
// uc_nation := 1 ;
1660: LD_ADDR_OWVAR 21
1664: PUSH
1665: LD_INT 1
1667: ST_TO_ADDR
// end ;
1668: LD_VAR 0 1
1672: RET
// export function SelectGroup ; var units , selected , i ; begin
1673: LD_INT 0
1675: PPUSH
1676: PPUSH
1677: PPUSH
1678: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
1679: LD_ADDR_VAR 0 2
1683: PUSH
1684: LD_EXP 5
1688: PUSH
1689: LD_INT -3
1691: PUSH
1692: EMPTY
1693: LIST
1694: LIST
1695: PUSH
1696: LD_EXP 2
1700: ADD
1701: PUSH
1702: LD_INT -2
1704: PUSH
1705: LD_INT -4
1707: PUSH
1708: LD_EXP 12
1712: PUSH
1713: LD_EXP 13
1717: PUSH
1718: EMPTY
1719: LIST
1720: LIST
1721: LIST
1722: LIST
1723: ADD
1724: PUSH
1725: LD_INT -3
1727: PUSH
1728: EMPTY
1729: LIST
1730: ADD
1731: PUSH
1732: LD_EXP 3
1736: ADD
1737: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
1738: LD_ADDR_VAR 0 3
1742: PUSH
1743: LD_EXP 5
1747: PUSH
1748: LD_STRING Select five characters to go with you
1750: PPUSH
1751: LD_INT 4
1753: PPUSH
1754: LD_INT 4
1756: PPUSH
1757: LD_VAR 0 2
1761: PPUSH
1762: EMPTY
1763: PPUSH
1764: CALL_OW 42
1768: ADD
1769: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
1770: LD_ADDR_EXP 3
1774: PUSH
1775: LD_EXP 2
1779: PUSH
1780: LD_EXP 3
1784: UNION
1785: PUSH
1786: LD_VAR 0 3
1790: DIFF
1791: ST_TO_ADDR
// for i in cornel_units do
1792: LD_ADDR_VAR 0 4
1796: PUSH
1797: LD_EXP 3
1801: PUSH
1802: FOR_IN
1803: IFFALSE 1834
// if GetSide ( i ) = 1 then
1805: LD_VAR 0 4
1809: PPUSH
1810: CALL_OW 255
1814: PUSH
1815: LD_INT 1
1817: EQUAL
1818: IFFALSE 1832
// SetSide ( i , 4 ) ;
1820: LD_VAR 0 4
1824: PPUSH
1825: LD_INT 4
1827: PPUSH
1828: CALL_OW 235
1832: GO 1802
1834: POP
1835: POP
// for i in selected do
1836: LD_ADDR_VAR 0 4
1840: PUSH
1841: LD_VAR 0 3
1845: PUSH
1846: FOR_IN
1847: IFFALSE 1878
// if GetSide ( i ) = 4 then
1849: LD_VAR 0 4
1853: PPUSH
1854: CALL_OW 255
1858: PUSH
1859: LD_INT 4
1861: EQUAL
1862: IFFALSE 1876
// SetSide ( i , 1 ) ;
1864: LD_VAR 0 4
1868: PPUSH
1869: LD_INT 1
1871: PPUSH
1872: CALL_OW 235
1876: GO 1846
1878: POP
1879: POP
// if GetSide ( Bobby ) = 4 then
1880: LD_EXP 6
1884: PPUSH
1885: CALL_OW 255
1889: PUSH
1890: LD_INT 4
1892: EQUAL
1893: IFFALSE 1902
// DeleteCharacters ( Bobby ) ;
1895: LD_STRING Bobby
1897: PPUSH
1898: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
1902: LD_EXP 7
1906: PPUSH
1907: CALL_OW 255
1911: PUSH
1912: LD_INT 4
1914: EQUAL
1915: IFFALSE 1924
// DeleteCharacters ( Cyrus ) ;
1917: LD_STRING Cyrus
1919: PPUSH
1920: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
1924: LD_EXP 8
1928: PPUSH
1929: CALL_OW 255
1933: PUSH
1934: LD_INT 4
1936: EQUAL
1937: IFFALSE 1946
// DeleteCharacters ( Lisa ) ;
1939: LD_STRING Lisa
1941: PPUSH
1942: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
1946: LD_EXP 9
1950: PPUSH
1951: CALL_OW 255
1955: PUSH
1956: LD_INT 4
1958: EQUAL
1959: IFFALSE 1968
// DeleteCharacters ( Khatam ) ;
1961: LD_STRING Khatam
1963: PPUSH
1964: CALL_OW 40
// if GetSide ( Brian ) = 4 then
1968: LD_EXP 10
1972: PPUSH
1973: CALL_OW 255
1977: PUSH
1978: LD_INT 4
1980: EQUAL
1981: IFFALSE 1990
// DeleteCharacters ( Brian ) ;
1983: LD_STRING Brian
1985: PPUSH
1986: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
1990: LD_EXP 11
1994: PPUSH
1995: CALL_OW 255
1999: PUSH
2000: LD_INT 4
2002: EQUAL
2003: IFFALSE 2012
// DeleteCharacters ( Jerry ) ;
2005: LD_STRING Jerry
2007: PPUSH
2008: CALL_OW 40
// end ; end_of_file end_of_file
2012: LD_VAR 0 1
2016: RET
// export function Action ; begin
2017: LD_INT 0
2019: PPUSH
// InGameOn ;
2020: CALL_OW 8
// Say ( JMM , D1-JMM-1 ) ;
2024: LD_EXP 5
2028: PPUSH
2029: LD_STRING D1-JMM-1
2031: PPUSH
2032: CALL_OW 88
// Say ( Cornel , D1-Con-1 ) ;
2036: LD_EXP 12
2040: PPUSH
2041: LD_STRING D1-Con-1
2043: PPUSH
2044: CALL_OW 88
// Say ( JMM , D1-JMM-2 ) ;
2048: LD_EXP 5
2052: PPUSH
2053: LD_STRING D1-JMM-2
2055: PPUSH
2056: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
2060: LD_EXP 5
2064: PPUSH
2065: LD_STRING D1-JMM-2a
2067: PPUSH
2068: CALL_OW 88
// Say ( Cornel , D1-Con-2 ) ;
2072: LD_EXP 12
2076: PPUSH
2077: LD_STRING D1-Con-2
2079: PPUSH
2080: CALL_OW 88
// if bierezov_exist then
2084: LD_EXP 4
2088: IFFALSE 2329
// begin ComTurnUnit ( Cornel , Bierezov ) ;
2090: LD_EXP 12
2094: PPUSH
2095: LD_EXP 13
2099: PPUSH
2100: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
2104: LD_INT 10
2106: PPUSH
2107: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
2111: LD_EXP 12
2115: PPUSH
2116: LD_STRING D1a-Corn-1
2118: PPUSH
2119: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
2123: LD_EXP 5
2127: PPUSH
2128: LD_EXP 13
2132: PPUSH
2133: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
2137: LD_EXP 13
2141: PPUSH
2142: LD_EXP 5
2146: PPUSH
2147: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
2151: LD_EXP 5
2155: PPUSH
2156: LD_STRING D1a-JMM-1
2158: PPUSH
2159: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
2163: LD_EXP 5
2167: PPUSH
2168: LD_EXP 12
2172: PPUSH
2173: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
2177: LD_EXP 12
2181: PPUSH
2182: LD_EXP 5
2186: PPUSH
2187: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
2191: LD_EXP 12
2195: PPUSH
2196: LD_STRING D1a-Corn-2
2198: PPUSH
2199: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
2203: LD_EXP 5
2207: PPUSH
2208: LD_STRING D1a-JMM-2
2210: PPUSH
2211: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
2215: LD_EXP 12
2219: PPUSH
2220: LD_STRING D1a-Corn-3
2222: PPUSH
2223: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
2227: LD_EXP 5
2231: PPUSH
2232: LD_STRING D1a-JMM-3
2234: PPUSH
2235: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
2239: LD_EXP 12
2243: PPUSH
2244: LD_STRING D1a-Corn-4
2246: PPUSH
2247: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
2251: LD_EXP 5
2255: PPUSH
2256: LD_STRING D1a-JMM-4
2258: PPUSH
2259: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
2263: LD_EXP 12
2267: PPUSH
2268: LD_STRING D1a-Corn-5
2270: PPUSH
2271: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel + 4 ) , GetY ( Cornel ) ) ;
2275: LD_EXP 13
2279: PPUSH
2280: LD_EXP 12
2284: PUSH
2285: LD_INT 4
2287: PLUS
2288: PPUSH
2289: CALL_OW 250
2293: PPUSH
2294: LD_EXP 12
2298: PPUSH
2299: CALL_OW 251
2303: PPUSH
2304: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
2308: LD_EXP 13
2312: PPUSH
2313: LD_EXP 12
2317: PPUSH
2318: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
2322: LD_INT 10
2324: PPUSH
2325: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
2329: LD_EXP 5
2333: PPUSH
2334: LD_STRING D1b-JMM-1
2336: PPUSH
2337: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
2341: LD_EXP 12
2345: PPUSH
2346: LD_STRING D1b-Corn-1
2348: PPUSH
2349: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
2353: LD_EXP 5
2357: PPUSH
2358: LD_STRING D1b-JMM-2
2360: PPUSH
2361: CALL_OW 88
// Say ( Cornel , D1b-JMM-3 ) ;
2365: LD_EXP 12
2369: PPUSH
2370: LD_STRING D1b-JMM-3
2372: PPUSH
2373: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
2377: LD_INT 10
2379: PPUSH
2380: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
2384: LD_EXP 14
2388: PPUSH
2389: LD_STRING D1b-Pow-3
2391: PPUSH
2392: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
2396: LD_EXP 5
2400: PPUSH
2401: LD_STRING D1b-JMM-4
2403: PPUSH
2404: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
2408: LD_EXP 12
2412: PPUSH
2413: LD_STRING D1b-Corn-4
2415: PPUSH
2416: CALL_OW 88
// if Khatam then
2420: LD_EXP 9
2424: IFFALSE 2440
// Say ( Khatam , D1b-Khat-4 ) else
2426: LD_EXP 9
2430: PPUSH
2431: LD_STRING D1b-Khat-4
2433: PPUSH
2434: CALL_OW 88
2438: GO 2476
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
2440: LD_EXP 3
2444: PPUSH
2445: LD_INT 26
2447: PUSH
2448: LD_INT 1
2450: PUSH
2451: EMPTY
2452: LIST
2453: LIST
2454: PPUSH
2455: CALL_OW 72
2459: PUSH
2460: LD_EXP 12
2464: PUSH
2465: EMPTY
2466: LIST
2467: DIFF
2468: PPUSH
2469: LD_STRING D1b-Sol1-4
2471: PPUSH
2472: CALL 212 0 2
// if Cyrus then
2476: LD_EXP 7
2480: IFFALSE 2494
// Say ( Cyrus , D1b-Cyrus-4 ) ;
2482: LD_EXP 7
2486: PPUSH
2487: LD_STRING D1b-Cyrus-4
2489: PPUSH
2490: CALL_OW 88
// if Lisa then
2494: LD_EXP 8
2498: IFFALSE 2530
// begin Say ( Lisa , D1b-Lisa-4 ) ;
2500: LD_EXP 8
2504: PPUSH
2505: LD_STRING D1b-Lisa-4
2507: PPUSH
2508: CALL_OW 88
// if Cyrus then
2512: LD_EXP 7
2516: IFFALSE 2530
// Say ( Cyrus , D1b-Cyrus-5 ) ;
2518: LD_EXP 7
2522: PPUSH
2523: LD_STRING D1b-Cyrus-5
2525: PPUSH
2526: CALL_OW 88
// end ; InGameOff ;
2530: CALL_OW 9
// SelectGroup ;
2534: CALL 1673 0 0
// ChangeMissionObjectives ( M1 ) ;
2538: LD_STRING M1
2540: PPUSH
2541: CALL_OW 337
// DialogueOn ;
2545: CALL_OW 6
// Say ( JMM , D1d-JMM-1 ) ;
2549: LD_EXP 5
2553: PPUSH
2554: LD_STRING D1d-JMM-1
2556: PPUSH
2557: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
2561: LD_EXP 12
2565: PPUSH
2566: LD_STRING D1d-Corn-1
2568: PPUSH
2569: CALL_OW 88
// DialogueOff ;
2573: CALL_OW 7
// end ;
2577: LD_VAR 0 1
2581: RET
