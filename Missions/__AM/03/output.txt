// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 250 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 338 0 0
// PrepareRussian ;
  22: CALL 2645 0 0
// PrepareAmerican ;
  26: CALL 902 0 0
// PrepareCornell ;
  30: CALL 1926 0 0
// PrepareWesternBase ;
  34: CALL 2152 0 0
// Action ;
  38: CALL 3385 0 0
// end ;
  42: END
// export debug ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , veh_on_meta ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// jmm_units := 0 ;
  54: LD_ADDR_EXP 2
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// cornel_units := 0 ;
  62: LD_ADDR_EXP 4
  66: PUSH
  67: LD_INT 0
  69: ST_TO_ADDR
// bierezov_exist := false ;
  70: LD_ADDR_EXP 5
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// jmm_on_west := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// cornel_active := false ;
  86: LD_ADDR_EXP 6
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// cornel_attack := false ;
  94: LD_ADDR_EXP 7
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_prepared := false ;
 102: LD_ADDR_EXP 9
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 110: LD_ADDR_EXP 8
 114: PUSH
 115: LD_INT 4200
 117: ST_TO_ADDR
// frank_can_return := false ;
 118: LD_ADDR_EXP 10
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// solar_builded := false ;
 126: LD_ADDR_EXP 11
 130: PUSH
 131: LD_INT 0
 133: ST_TO_ADDR
// frank_send_to_scout := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// jmm_in_veh := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// bobby_in_veh := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// cyrus_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// lisa_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// crates_counter := [ 1200 , 1000 , 800 ] [ Difficulty ] ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 1200
 181: PUSH
 182: LD_INT 1000
 184: PUSH
 185: LD_INT 800
 187: PUSH
 188: EMPTY
 189: LIST
 190: LIST
 191: LIST
 192: PUSH
 193: LD_OWVAR 67
 197: ARRAY
 198: ST_TO_ADDR
// end_mission_allowed := false ;
 199: LD_ADDR_EXP 18
 203: PUSH
 204: LD_INT 0
 206: ST_TO_ADDR
// save_others := [ ] ;
 207: LD_ADDR_EXP 19
 211: PUSH
 212: EMPTY
 213: ST_TO_ADDR
// save_group := [ ] ;
 214: LD_ADDR_EXP 20
 218: PUSH
 219: EMPTY
 220: ST_TO_ADDR
// show_query := false ;
 221: LD_ADDR_EXP 21
 225: PUSH
 226: LD_INT 0
 228: ST_TO_ADDR
// wait_for_them := false ;
 229: LD_ADDR_EXP 22
 233: PUSH
 234: LD_INT 0
 236: ST_TO_ADDR
// veh_on_meta := false ;
 237: LD_ADDR_EXP 23
 241: PUSH
 242: LD_INT 0
 244: ST_TO_ADDR
// end ;
 245: LD_VAR 0 1
 249: RET
// function SetDiplomacy ; begin
 250: LD_INT 0
 252: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 4
 258: PPUSH
 259: LD_INT 1
 261: PPUSH
 262: LD_INT 1
 264: PPUSH
 265: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 269: LD_INT 1
 271: PPUSH
 272: LD_INT 8
 274: PPUSH
 275: LD_INT 1
 277: PPUSH
 278: LD_INT 1
 280: PPUSH
 281: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 285: LD_INT 3
 287: PPUSH
 288: LD_INT 6
 290: PPUSH
 291: LD_INT 1
 293: PPUSH
 294: LD_INT 1
 296: PPUSH
 297: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 301: LD_INT 4
 303: PPUSH
 304: LD_INT 6
 306: PPUSH
 307: LD_INT 0
 309: PPUSH
 310: LD_INT 1
 312: PPUSH
 313: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 317: LD_INT 3
 319: PPUSH
 320: LD_INT 8
 322: PPUSH
 323: LD_INT 0
 325: PPUSH
 326: LD_INT 1
 328: PPUSH
 329: CALL_OW 80
// end ;
 333: LD_VAR 0 1
 337: RET
// export function DebugMode ; begin
 338: LD_INT 0
 340: PPUSH
// FogOff ( 1 ) ;
 341: LD_INT 1
 343: PPUSH
 344: CALL_OW 344
// end ; end_of_file
 348: LD_VAR 0 1
 352: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 353: LD_INT 0
 355: PPUSH
 356: PPUSH
// if exist_mode then
 357: LD_VAR 0 2
 361: IFFALSE 380
// unit := CreateCharacter ( ident ) else
 363: LD_ADDR_VAR 0 4
 367: PUSH
 368: LD_VAR 0 1
 372: PPUSH
 373: CALL_OW 34
 377: ST_TO_ADDR
 378: GO 395
// unit := NewCharacter ( ident ) ;
 380: LD_ADDR_VAR 0 4
 384: PUSH
 385: LD_VAR 0 1
 389: PPUSH
 390: CALL_OW 25
 394: ST_TO_ADDR
// result := unit ;
 395: LD_ADDR_VAR 0 3
 399: PUSH
 400: LD_VAR 0 4
 404: ST_TO_ADDR
// end ;
 405: LD_VAR 0 3
 409: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 410: LD_INT 0
 412: PPUSH
// uc_side := side ;
 413: LD_ADDR_OWVAR 20
 417: PUSH
 418: LD_VAR 0 1
 422: ST_TO_ADDR
// uc_nation := nation ;
 423: LD_ADDR_OWVAR 21
 427: PUSH
 428: LD_VAR 0 2
 432: ST_TO_ADDR
// vc_chassis := chassis ;
 433: LD_ADDR_OWVAR 37
 437: PUSH
 438: LD_VAR 0 3
 442: ST_TO_ADDR
// vc_engine := engine ;
 443: LD_ADDR_OWVAR 39
 447: PUSH
 448: LD_VAR 0 4
 452: ST_TO_ADDR
// vc_control := control ;
 453: LD_ADDR_OWVAR 38
 457: PUSH
 458: LD_VAR 0 5
 462: ST_TO_ADDR
// vc_weapon := weapon ;
 463: LD_ADDR_OWVAR 40
 467: PUSH
 468: LD_VAR 0 6
 472: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 473: LD_ADDR_OWVAR 41
 477: PUSH
 478: LD_VAR 0 7
 482: ST_TO_ADDR
// result := CreateVehicle ;
 483: LD_ADDR_VAR 0 8
 487: PUSH
 488: CALL_OW 45
 492: ST_TO_ADDR
// end ;
 493: LD_VAR 0 8
 497: RET
// export function SayX ( units , ident ) ; var i ; begin
 498: LD_INT 0
 500: PPUSH
 501: PPUSH
// if not units then
 502: LD_VAR 0 1
 506: NOT
 507: IFFALSE 511
// exit ;
 509: GO 555
// for i in ident do
 511: LD_ADDR_VAR 0 4
 515: PUSH
 516: LD_VAR 0 2
 520: PUSH
 521: FOR_IN
 522: IFFALSE 553
// if IsOk ( i ) then
 524: LD_VAR 0 4
 528: PPUSH
 529: CALL_OW 302
 533: IFFALSE 551
// begin Say ( i , ident ) ;
 535: LD_VAR 0 4
 539: PPUSH
 540: LD_VAR 0 2
 544: PPUSH
 545: CALL_OW 88
// break ;
 549: GO 553
// end ;
 551: GO 521
 553: POP
 554: POP
// end ;
 555: LD_VAR 0 3
 559: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 560: LD_INT 0
 562: PPUSH
 563: PPUSH
 564: PPUSH
 565: PPUSH
// for i = 1 to count do
 566: LD_ADDR_VAR 0 8
 570: PUSH
 571: DOUBLE
 572: LD_INT 1
 574: DEC
 575: ST_TO_ADDR
 576: LD_VAR 0 6
 580: PUSH
 581: FOR_TO
 582: IFFALSE 663
// begin uc_side = side ;
 584: LD_ADDR_OWVAR 20
 588: PUSH
 589: LD_VAR 0 1
 593: ST_TO_ADDR
// uc_nation = nation ;
 594: LD_ADDR_OWVAR 21
 598: PUSH
 599: LD_VAR 0 2
 603: ST_TO_ADDR
// hc_gallery =  ;
 604: LD_ADDR_OWVAR 33
 608: PUSH
 609: LD_STRING 
 611: ST_TO_ADDR
// hc_name =  ;
 612: LD_ADDR_OWVAR 26
 616: PUSH
 617: LD_STRING 
 619: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 620: LD_INT 0
 622: PPUSH
 623: LD_VAR 0 5
 627: PPUSH
 628: LD_VAR 0 4
 632: PPUSH
 633: CALL_OW 380
// un = CreateHuman ;
 637: LD_ADDR_VAR 0 10
 641: PUSH
 642: CALL_OW 44
 646: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 647: LD_VAR 0 10
 651: PPUSH
 652: LD_VAR 0 3
 656: PPUSH
 657: CALL_OW 52
// end ;
 661: GO 581
 663: POP
 664: POP
// end ;
 665: LD_VAR 0 7
 669: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 670: LD_INT 0
 672: PPUSH
 673: PPUSH
 674: PPUSH
// uc_side := GetSide ( b ) ;
 675: LD_ADDR_OWVAR 20
 679: PUSH
 680: LD_VAR 0 2
 684: PPUSH
 685: CALL_OW 255
 689: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 690: LD_ADDR_OWVAR 21
 694: PUSH
 695: LD_VAR 0 2
 699: PPUSH
 700: CALL_OW 248
 704: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 705: LD_INT 0
 707: PPUSH
 708: LD_INT 1
 710: PPUSH
 711: LD_VAR 0 1
 715: PPUSH
 716: CALL_OW 380
// un = CreateHuman ;
 720: LD_ADDR_VAR 0 4
 724: PUSH
 725: CALL_OW 44
 729: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 730: LD_ADDR_VAR 0 5
 734: PUSH
 735: LD_VAR 0 2
 739: PPUSH
 740: CALL_OW 254
 744: PUSH
 745: LD_INT 3
 747: MINUS
 748: ST_TO_ADDR
// if dir < 0 then
 749: LD_VAR 0 5
 753: PUSH
 754: LD_INT 0
 756: LESS
 757: IFFALSE 773
// dir := 6 + dir ;
 759: LD_ADDR_VAR 0 5
 763: PUSH
 764: LD_INT 6
 766: PUSH
 767: LD_VAR 0 5
 771: PLUS
 772: ST_TO_ADDR
// SetDir ( un , dir ) ;
 773: LD_VAR 0 4
 777: PPUSH
 778: LD_VAR 0 5
 782: PPUSH
 783: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 787: LD_VAR 0 4
 791: PPUSH
 792: LD_VAR 0 2
 796: PPUSH
 797: CALL_OW 52
// end ;
 801: LD_VAR 0 3
 805: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 806: LD_INT 0
 808: PPUSH
 809: PPUSH
 810: PPUSH
// result := false ;
 811: LD_ADDR_VAR 0 2
 815: PUSH
 816: LD_INT 0
 818: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 819: LD_ADDR_VAR 0 3
 823: PUSH
 824: LD_INT 22
 826: PUSH
 827: LD_INT 1
 829: PUSH
 830: EMPTY
 831: LIST
 832: LIST
 833: PUSH
 834: LD_INT 34
 836: PUSH
 837: LD_INT 2
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: PPUSH
 848: CALL_OW 69
 852: ST_TO_ADDR
// for i in filter do
 853: LD_ADDR_VAR 0 4
 857: PUSH
 858: LD_VAR 0 3
 862: PUSH
 863: FOR_IN
 864: IFFALSE 895
// if IsDrivenBy ( i ) = unit then
 866: LD_VAR 0 4
 870: PPUSH
 871: CALL_OW 311
 875: PUSH
 876: LD_VAR 0 1
 880: EQUAL
 881: IFFALSE 893
// begin result := true ;
 883: LD_ADDR_VAR 0 2
 887: PUSH
 888: LD_INT 1
 890: ST_TO_ADDR
// break ;
 891: GO 895
// end ;
 893: GO 863
 895: POP
 896: POP
// end ; end_of_file
 897: LD_VAR 0 2
 901: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
 902: LD_INT 0
 904: PPUSH
 905: PPUSH
 906: PPUSH
 907: PPUSH
 908: PPUSH
 909: PPUSH
 910: PPUSH
 911: PPUSH
// uc_side := 4 ;
 912: LD_ADDR_OWVAR 20
 916: PUSH
 917: LD_INT 4
 919: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
 920: LD_ADDR_EXP 33
 924: PUSH
 925: LD_STRING Powell
 927: PPUSH
 928: LD_INT 0
 930: PPUSH
 931: CALL 353 0 2
 935: ST_TO_ADDR
// uc_side := 1 ;
 936: LD_ADDR_OWVAR 20
 940: PUSH
 941: LD_INT 1
 943: ST_TO_ADDR
// uc_nation := 1 ;
 944: LD_ADDR_OWVAR 21
 948: PUSH
 949: LD_INT 1
 951: ST_TO_ADDR
// if debug then
 952: LD_EXP 1
 956: IFFALSE 1086
// begin for i = 1 to 4 do
 958: LD_ADDR_VAR 0 2
 962: PUSH
 963: DOUBLE
 964: LD_INT 1
 966: DEC
 967: ST_TO_ADDR
 968: LD_INT 4
 970: PUSH
 971: FOR_TO
 972: IFFALSE 1023
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
 974: LD_INT 0
 976: PPUSH
 977: LD_INT 1
 979: PPUSH
 980: LD_INT 2
 982: PPUSH
 983: CALL_OW 12
 987: PPUSH
 988: LD_INT 3
 990: PPUSH
 991: CALL_OW 380
// un := CreateHuman ;
 995: LD_ADDR_VAR 0 3
 999: PUSH
1000: CALL_OW 44
1004: ST_TO_ADDR
// others := others ^ un ;
1005: LD_ADDR_VAR 0 5
1009: PUSH
1010: LD_VAR 0 5
1014: PUSH
1015: LD_VAR 0 3
1019: ADD
1020: ST_TO_ADDR
// end ;
1021: GO 971
1023: POP
1024: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1025: LD_ADDR_VAR 0 6
1029: PUSH
1030: LD_INT 21
1032: PUSH
1033: LD_INT 1
1035: PUSH
1036: LD_INT 1
1038: PUSH
1039: LD_INT 51
1041: PUSH
1042: LD_INT 90
1044: PUSH
1045: LD_INT 504
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: PUSH
1056: LD_INT 21
1058: PUSH
1059: LD_INT 1
1061: PUSH
1062: LD_INT 1
1064: PUSH
1065: LD_INT 51
1067: PUSH
1068: LD_INT 80
1070: PUSH
1071: LD_INT 750
1073: PUSH
1074: EMPTY
1075: LIST
1076: LIST
1077: LIST
1078: LIST
1079: LIST
1080: LIST
1081: PUSH
1082: EMPTY
1083: LIST
1084: LIST
1085: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1086: LD_ADDR_EXP 24
1090: PUSH
1091: LD_STRING JMM
1093: PPUSH
1094: LD_EXP 1
1098: NOT
1099: PPUSH
1100: CALL 353 0 2
1104: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1105: LD_ADDR_EXP 25
1109: PUSH
1110: LD_STRING Bobby
1112: PPUSH
1113: LD_EXP 1
1117: NOT
1118: PPUSH
1119: CALL 353 0 2
1123: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1124: LD_ADDR_EXP 26
1128: PUSH
1129: LD_STRING Cyrus
1131: PPUSH
1132: LD_EXP 1
1136: NOT
1137: PPUSH
1138: CALL 353 0 2
1142: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1143: LD_ADDR_EXP 27
1147: PUSH
1148: LD_STRING Lisa
1150: PPUSH
1151: LD_EXP 1
1155: NOT
1156: PPUSH
1157: CALL 353 0 2
1161: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1162: LD_ADDR_EXP 28
1166: PUSH
1167: LD_STRING Khatam
1169: PPUSH
1170: LD_EXP 1
1174: NOT
1175: PPUSH
1176: CALL 353 0 2
1180: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1181: LD_ADDR_EXP 29
1185: PUSH
1186: LD_STRING Brian
1188: PPUSH
1189: LD_EXP 1
1193: NOT
1194: PPUSH
1195: CALL 353 0 2
1199: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1200: LD_ADDR_EXP 30
1204: PUSH
1205: LD_STRING Jerry
1207: PPUSH
1208: LD_EXP 1
1212: NOT
1213: PPUSH
1214: CALL 353 0 2
1218: ST_TO_ADDR
// if Bobby then
1219: LD_EXP 25
1223: IFFALSE 1254
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1225: LD_ADDR_VAR 0 4
1229: PUSH
1230: LD_VAR 0 4
1234: PPUSH
1235: LD_VAR 0 4
1239: PUSH
1240: LD_INT 1
1242: PLUS
1243: PPUSH
1244: LD_EXP 25
1248: PPUSH
1249: CALL_OW 2
1253: ST_TO_ADDR
// if Cyrus then
1254: LD_EXP 26
1258: IFFALSE 1289
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1260: LD_ADDR_VAR 0 4
1264: PUSH
1265: LD_VAR 0 4
1269: PPUSH
1270: LD_VAR 0 4
1274: PUSH
1275: LD_INT 1
1277: PLUS
1278: PPUSH
1279: LD_EXP 26
1283: PPUSH
1284: CALL_OW 2
1288: ST_TO_ADDR
// if Lisa then
1289: LD_EXP 27
1293: IFFALSE 1324
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1295: LD_ADDR_VAR 0 4
1299: PUSH
1300: LD_VAR 0 4
1304: PPUSH
1305: LD_VAR 0 4
1309: PUSH
1310: LD_INT 1
1312: PLUS
1313: PPUSH
1314: LD_EXP 27
1318: PPUSH
1319: CALL_OW 2
1323: ST_TO_ADDR
// if Khatam then
1324: LD_EXP 28
1328: IFFALSE 1359
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1330: LD_ADDR_VAR 0 4
1334: PUSH
1335: LD_VAR 0 4
1339: PPUSH
1340: LD_VAR 0 4
1344: PUSH
1345: LD_INT 1
1347: PLUS
1348: PPUSH
1349: LD_EXP 28
1353: PPUSH
1354: CALL_OW 2
1358: ST_TO_ADDR
// if Brian then
1359: LD_EXP 29
1363: IFFALSE 1394
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1365: LD_ADDR_VAR 0 4
1369: PUSH
1370: LD_VAR 0 4
1374: PPUSH
1375: LD_VAR 0 4
1379: PUSH
1380: LD_INT 1
1382: PLUS
1383: PPUSH
1384: LD_EXP 29
1388: PPUSH
1389: CALL_OW 2
1393: ST_TO_ADDR
// if Jerry then
1394: LD_EXP 30
1398: IFFALSE 1429
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1400: LD_ADDR_VAR 0 4
1404: PUSH
1405: LD_VAR 0 4
1409: PPUSH
1410: LD_VAR 0 4
1414: PUSH
1415: LD_INT 1
1417: PLUS
1418: PPUSH
1419: LD_EXP 30
1423: PPUSH
1424: CALL_OW 2
1428: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1429: LD_STRING 02_other_survivors
1431: PPUSH
1432: CALL_OW 28
1436: IFFALSE 1451
// others := CreateCharacterSet ( 02_other_survivors ) ;
1438: LD_ADDR_VAR 0 5
1442: PUSH
1443: LD_STRING 02_other_survivors
1445: PPUSH
1446: CALL_OW 31
1450: ST_TO_ADDR
// if others then
1451: LD_VAR 0 5
1455: IFFALSE 1480
// begin tmp := tmp ^ others ;
1457: LD_ADDR_VAR 0 4
1461: PUSH
1462: LD_VAR 0 4
1466: PUSH
1467: LD_VAR 0 5
1471: ADD
1472: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1473: LD_STRING 02_other_survivors
1475: PPUSH
1476: CALL_OW 40
// end ; jmm_units := tmp ;
1480: LD_ADDR_EXP 2
1484: PUSH
1485: LD_VAR 0 4
1489: ST_TO_ADDR
// if not vehicles then
1490: LD_VAR 0 6
1494: NOT
1495: IFFALSE 1513
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1497: LD_ADDR_VAR 0 6
1501: PUSH
1502: LD_STRING 02_tanks_1
1504: PPUSH
1505: LD_INT 0
1507: PPUSH
1508: CALL_OW 30
1512: ST_TO_ADDR
// if vehicles then
1513: LD_VAR 0 6
1517: IFFALSE 1711
// begin got_mech := false ;
1519: LD_ADDR_VAR 0 7
1523: PUSH
1524: LD_INT 0
1526: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1527: LD_VAR 0 4
1531: PPUSH
1532: LD_INT 25
1534: PUSH
1535: LD_INT 3
1537: PUSH
1538: EMPTY
1539: LIST
1540: LIST
1541: PPUSH
1542: CALL_OW 72
1546: IFFALSE 1556
// got_mech := true ;
1548: LD_ADDR_VAR 0 7
1552: PUSH
1553: LD_INT 1
1555: ST_TO_ADDR
// for i = 1 to vehicles do
1556: LD_ADDR_VAR 0 2
1560: PUSH
1561: DOUBLE
1562: LD_INT 1
1564: DEC
1565: ST_TO_ADDR
1566: LD_VAR 0 6
1570: PUSH
1571: FOR_TO
1572: IFFALSE 1709
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1574: LD_ADDR_VAR 0 3
1578: PUSH
1579: LD_INT 1
1581: PPUSH
1582: LD_INT 3
1584: PPUSH
1585: LD_VAR 0 6
1589: PUSH
1590: LD_VAR 0 2
1594: ARRAY
1595: PUSH
1596: LD_INT 1
1598: ARRAY
1599: PPUSH
1600: LD_VAR 0 6
1604: PUSH
1605: LD_VAR 0 2
1609: ARRAY
1610: PUSH
1611: LD_INT 2
1613: ARRAY
1614: PPUSH
1615: LD_VAR 0 6
1619: PUSH
1620: LD_VAR 0 2
1624: ARRAY
1625: PUSH
1626: LD_INT 3
1628: ARRAY
1629: PPUSH
1630: LD_VAR 0 6
1634: PUSH
1635: LD_VAR 0 2
1639: ARRAY
1640: PUSH
1641: LD_INT 4
1643: ARRAY
1644: PPUSH
1645: LD_INT 40
1647: PPUSH
1648: CALL 410 0 7
1652: ST_TO_ADDR
// if not got_mech then
1653: LD_VAR 0 7
1657: NOT
1658: IFFALSE 1684
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1660: LD_VAR 0 3
1664: PPUSH
1665: LD_VAR 0 6
1669: PUSH
1670: LD_VAR 0 2
1674: ARRAY
1675: PUSH
1676: LD_INT 6
1678: ARRAY
1679: PPUSH
1680: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1684: LD_ADDR_VAR 0 4
1688: PUSH
1689: LD_VAR 0 4
1693: PPUSH
1694: LD_INT 1
1696: PPUSH
1697: LD_VAR 0 3
1701: PPUSH
1702: CALL_OW 2
1706: ST_TO_ADDR
// end ;
1707: GO 1571
1709: POP
1710: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1711: LD_EXP 24
1715: PPUSH
1716: LD_INT 194
1718: PPUSH
1719: LD_INT 119
1721: PPUSH
1722: LD_INT 0
1724: PPUSH
1725: CALL_OW 48
// if tmp then
1729: LD_VAR 0 4
1733: IFFALSE 1858
// begin for i in tmp do
1735: LD_ADDR_VAR 0 2
1739: PUSH
1740: LD_VAR 0 4
1744: PUSH
1745: FOR_IN
1746: IFFALSE 1856
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1748: LD_ADDR_VAR 0 8
1752: PUSH
1753: LD_INT 22
1755: PUSH
1756: LD_INT 1
1758: PUSH
1759: EMPTY
1760: LIST
1761: LIST
1762: PUSH
1763: LD_INT 21
1765: PUSH
1766: LD_INT 2
1768: PUSH
1769: EMPTY
1770: LIST
1771: LIST
1772: PUSH
1773: LD_INT 58
1775: PUSH
1776: EMPTY
1777: LIST
1778: PUSH
1779: EMPTY
1780: LIST
1781: LIST
1782: LIST
1783: PPUSH
1784: CALL_OW 69
1788: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
1789: LD_VAR 0 2
1793: PPUSH
1794: CALL_OW 247
1798: PUSH
1799: LD_INT 1
1801: EQUAL
1802: PUSH
1803: LD_VAR 0 8
1807: AND
1808: IFFALSE 1830
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
1810: LD_VAR 0 2
1814: PPUSH
1815: LD_VAR 0 8
1819: PUSH
1820: LD_INT 1
1822: ARRAY
1823: PPUSH
1824: CALL_OW 52
1828: GO 1845
// PlaceUnitArea ( i , startArea , false ) ;
1830: LD_VAR 0 2
1834: PPUSH
1835: LD_INT 1
1837: PPUSH
1838: LD_INT 0
1840: PPUSH
1841: CALL_OW 49
// ComHold ( i ) ;
1845: LD_VAR 0 2
1849: PPUSH
1850: CALL_OW 140
// end ;
1854: GO 1745
1856: POP
1857: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
1858: LD_ADDR_EXP 5
1862: PUSH
1863: LD_STRING 02_mikhailStatus_1
1865: PPUSH
1866: LD_INT 0
1868: PPUSH
1869: CALL_OW 30
1873: ST_TO_ADDR
// if not bierezov_exist and not debug then
1874: LD_EXP 5
1878: NOT
1879: PUSH
1880: LD_EXP 1
1884: NOT
1885: AND
1886: IFFALSE 1890
// exit ;
1888: GO 1921
// Bierezov = PrepareUnit ( Mikhail , false ) ;
1890: LD_ADDR_EXP 32
1894: PUSH
1895: LD_STRING Mikhail
1897: PPUSH
1898: LD_INT 0
1900: PPUSH
1901: CALL 353 0 2
1905: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
1906: LD_EXP 32
1910: PPUSH
1911: LD_INT 1
1913: PPUSH
1914: LD_INT 0
1916: PPUSH
1917: CALL_OW 49
// end ;
1921: LD_VAR 0 1
1925: RET
// export function PrepareCornell ; var tmp , un , i ; begin
1926: LD_INT 0
1928: PPUSH
1929: PPUSH
1930: PPUSH
1931: PPUSH
// uc_side := 4 ;
1932: LD_ADDR_OWVAR 20
1936: PUSH
1937: LD_INT 4
1939: ST_TO_ADDR
// uc_nation := 1 ;
1940: LD_ADDR_OWVAR 21
1944: PUSH
1945: LD_INT 1
1947: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
1948: LD_ADDR_EXP 31
1952: PUSH
1953: LD_STRING Cornell
1955: PPUSH
1956: LD_INT 0
1958: PPUSH
1959: CALL 353 0 2
1963: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
1964: LD_ADDR_EXP 4
1968: PUSH
1969: LD_INT 8
1971: PUSH
1972: LD_EXP 2
1976: MINUS
1977: ST_TO_ADDR
// tmp := [ ] ;
1978: LD_ADDR_VAR 0 2
1982: PUSH
1983: EMPTY
1984: ST_TO_ADDR
// if cornel_units < 4 then
1985: LD_EXP 4
1989: PUSH
1990: LD_INT 4
1992: LESS
1993: IFFALSE 2003
// cornel_units := 4 ;
1995: LD_ADDR_EXP 4
1999: PUSH
2000: LD_INT 4
2002: ST_TO_ADDR
// for i = 1 to cornel_units do
2003: LD_ADDR_VAR 0 4
2007: PUSH
2008: DOUBLE
2009: LD_INT 1
2011: DEC
2012: ST_TO_ADDR
2013: LD_EXP 4
2017: PUSH
2018: FOR_TO
2019: IFFALSE 2117
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2021: LD_INT 0
2023: PPUSH
2024: LD_INT 1
2026: PUSH
2027: LD_INT 1
2029: PUSH
2030: LD_INT 1
2032: PUSH
2033: LD_INT 2
2035: PUSH
2036: LD_INT 4
2038: PUSH
2039: EMPTY
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: PUSH
2046: LD_VAR 0 4
2050: PUSH
2051: LD_INT 5
2053: MOD
2054: PUSH
2055: LD_INT 1
2057: PLUS
2058: ARRAY
2059: PPUSH
2060: LD_INT 2
2062: PPUSH
2063: CALL_OW 380
// un := CreateHuman ;
2067: LD_ADDR_VAR 0 3
2071: PUSH
2072: CALL_OW 44
2076: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2077: LD_ADDR_VAR 0 2
2081: PUSH
2082: LD_VAR 0 2
2086: PPUSH
2087: LD_INT 1
2089: PPUSH
2090: LD_VAR 0 3
2094: PPUSH
2095: CALL_OW 2
2099: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2100: LD_VAR 0 3
2104: PPUSH
2105: LD_INT 2
2107: PPUSH
2108: LD_INT 0
2110: PPUSH
2111: CALL_OW 49
// end ;
2115: GO 2018
2117: POP
2118: POP
// cornel_units := tmp ;
2119: LD_ADDR_EXP 4
2123: PUSH
2124: LD_VAR 0 2
2128: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2129: LD_EXP 31
2133: PPUSH
2134: LD_INT 191
2136: PPUSH
2137: LD_INT 106
2139: PPUSH
2140: LD_INT 0
2142: PPUSH
2143: CALL_OW 48
// end ;
2147: LD_VAR 0 1
2151: RET
// export function PrepareWesternBase ; var i ; begin
2152: LD_INT 0
2154: PPUSH
2155: PPUSH
// uc_side := 8 ;
2156: LD_ADDR_OWVAR 20
2160: PUSH
2161: LD_INT 8
2163: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2164: LD_ADDR_EXP 34
2168: PUSH
2169: LD_STRING Lynch
2171: PPUSH
2172: LD_INT 0
2174: PPUSH
2175: CALL 353 0 2
2179: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2180: LD_ADDR_EXP 35
2184: PUSH
2185: LD_STRING Walker
2187: PPUSH
2188: LD_INT 0
2190: PPUSH
2191: CALL 353 0 2
2195: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2196: LD_ADDR_EXP 36
2200: PUSH
2201: LD_STRING Turner
2203: PPUSH
2204: LD_INT 0
2206: PPUSH
2207: CALL 353 0 2
2211: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2212: LD_ADDR_EXP 37
2216: PUSH
2217: LD_STRING Jillian
2219: PPUSH
2220: LD_INT 0
2222: PPUSH
2223: CALL 353 0 2
2227: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2228: LD_ADDR_VAR 0 2
2232: PUSH
2233: LD_EXP 34
2237: PUSH
2238: LD_EXP 35
2242: PUSH
2243: LD_EXP 36
2247: PUSH
2248: LD_EXP 37
2252: PUSH
2253: EMPTY
2254: LIST
2255: LIST
2256: LIST
2257: LIST
2258: PUSH
2259: FOR_IN
2260: IFFALSE 2288
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2262: LD_VAR 0 2
2266: PPUSH
2267: LD_INT 3
2269: PPUSH
2270: LD_INT 0
2272: PPUSH
2273: CALL_OW 49
// ComHold ( i ) ;
2277: LD_VAR 0 2
2281: PPUSH
2282: CALL_OW 140
// end ;
2286: GO 2259
2288: POP
2289: POP
// end ;
2290: LD_VAR 0 1
2294: RET
// export function SelectGroup ; var units , selected , i ; begin
2295: LD_INT 0
2297: PPUSH
2298: PPUSH
2299: PPUSH
2300: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2301: LD_ADDR_VAR 0 2
2305: PUSH
2306: LD_EXP 24
2310: PUSH
2311: LD_INT -3
2313: PUSH
2314: EMPTY
2315: LIST
2316: LIST
2317: PUSH
2318: LD_EXP 2
2322: ADD
2323: PUSH
2324: LD_INT -2
2326: PUSH
2327: LD_INT -4
2329: PUSH
2330: LD_EXP 31
2334: PUSH
2335: LD_EXP 32
2339: PUSH
2340: EMPTY
2341: LIST
2342: LIST
2343: LIST
2344: LIST
2345: ADD
2346: PUSH
2347: LD_INT -3
2349: PUSH
2350: EMPTY
2351: LIST
2352: ADD
2353: PUSH
2354: LD_EXP 4
2358: ADD
2359: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2360: LD_ADDR_VAR 0 3
2364: PUSH
2365: LD_EXP 24
2369: PUSH
2370: LD_STRING Select five characters to go with you
2372: PPUSH
2373: LD_INT 4
2375: PPUSH
2376: LD_INT 4
2378: PPUSH
2379: LD_VAR 0 2
2383: PPUSH
2384: EMPTY
2385: PPUSH
2386: CALL_OW 42
2390: ADD
2391: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2392: LD_ADDR_EXP 4
2396: PUSH
2397: LD_EXP 2
2401: PUSH
2402: LD_EXP 4
2406: UNION
2407: PUSH
2408: LD_VAR 0 3
2412: DIFF
2413: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2414: LD_ADDR_VAR 0 4
2418: PUSH
2419: LD_EXP 4
2423: PUSH
2424: LD_EXP 32
2428: ADD
2429: PUSH
2430: FOR_IN
2431: IFFALSE 2462
// if GetSide ( i ) = 1 then
2433: LD_VAR 0 4
2437: PPUSH
2438: CALL_OW 255
2442: PUSH
2443: LD_INT 1
2445: EQUAL
2446: IFFALSE 2460
// SetSide ( i , 4 ) ;
2448: LD_VAR 0 4
2452: PPUSH
2453: LD_INT 4
2455: PPUSH
2456: CALL_OW 235
2460: GO 2430
2462: POP
2463: POP
// for i in selected do
2464: LD_ADDR_VAR 0 4
2468: PUSH
2469: LD_VAR 0 3
2473: PUSH
2474: FOR_IN
2475: IFFALSE 2506
// if GetSide ( i ) = 4 then
2477: LD_VAR 0 4
2481: PPUSH
2482: CALL_OW 255
2486: PUSH
2487: LD_INT 4
2489: EQUAL
2490: IFFALSE 2504
// SetSide ( i , 1 ) ;
2492: LD_VAR 0 4
2496: PPUSH
2497: LD_INT 1
2499: PPUSH
2500: CALL_OW 235
2504: GO 2474
2506: POP
2507: POP
// if GetSide ( Bobby ) = 4 then
2508: LD_EXP 25
2512: PPUSH
2513: CALL_OW 255
2517: PUSH
2518: LD_INT 4
2520: EQUAL
2521: IFFALSE 2530
// DeleteCharacters ( Bobby ) ;
2523: LD_STRING Bobby
2525: PPUSH
2526: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2530: LD_EXP 26
2534: PPUSH
2535: CALL_OW 255
2539: PUSH
2540: LD_INT 4
2542: EQUAL
2543: IFFALSE 2552
// DeleteCharacters ( Cyrus ) ;
2545: LD_STRING Cyrus
2547: PPUSH
2548: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2552: LD_EXP 27
2556: PPUSH
2557: CALL_OW 255
2561: PUSH
2562: LD_INT 4
2564: EQUAL
2565: IFFALSE 2574
// DeleteCharacters ( Lisa ) ;
2567: LD_STRING Lisa
2569: PPUSH
2570: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2574: LD_EXP 28
2578: PPUSH
2579: CALL_OW 255
2583: PUSH
2584: LD_INT 4
2586: EQUAL
2587: IFFALSE 2596
// DeleteCharacters ( Khatam ) ;
2589: LD_STRING Khatam
2591: PPUSH
2592: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2596: LD_EXP 29
2600: PPUSH
2601: CALL_OW 255
2605: PUSH
2606: LD_INT 4
2608: EQUAL
2609: IFFALSE 2618
// DeleteCharacters ( Brian ) ;
2611: LD_STRING Brian
2613: PPUSH
2614: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2618: LD_EXP 30
2622: PPUSH
2623: CALL_OW 255
2627: PUSH
2628: LD_INT 4
2630: EQUAL
2631: IFFALSE 2640
// DeleteCharacters ( Jerry ) ;
2633: LD_STRING Jerry
2635: PPUSH
2636: CALL_OW 40
// end ; end_of_file
2640: LD_VAR 0 1
2644: RET
// export Pokryshkin ; export ru_patrol , ru_forest ; export function PrepareRussian ; var i , b , un , veh , tw , bar , skill , vehicles , spot_xy ; begin
2645: LD_INT 0
2647: PPUSH
2648: PPUSH
2649: PPUSH
2650: PPUSH
2651: PPUSH
2652: PPUSH
2653: PPUSH
2654: PPUSH
2655: PPUSH
2656: PPUSH
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
2657: LD_ADDR_VAR 0 6
2661: PUSH
2662: LD_INT 22
2664: PUSH
2665: LD_INT 3
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: PUSH
2672: LD_INT 2
2674: PUSH
2675: LD_INT 30
2677: PUSH
2678: LD_INT 31
2680: PUSH
2681: EMPTY
2682: LIST
2683: LIST
2684: PUSH
2685: LD_INT 30
2687: PUSH
2688: LD_INT 32
2690: PUSH
2691: EMPTY
2692: LIST
2693: LIST
2694: PUSH
2695: EMPTY
2696: LIST
2697: LIST
2698: LIST
2699: PUSH
2700: EMPTY
2701: LIST
2702: LIST
2703: PPUSH
2704: CALL_OW 69
2708: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
2709: LD_ADDR_VAR 0 7
2713: PUSH
2714: LD_INT 22
2716: PUSH
2717: LD_INT 3
2719: PUSH
2720: EMPTY
2721: LIST
2722: LIST
2723: PUSH
2724: LD_INT 30
2726: PUSH
2727: LD_INT 4
2729: PUSH
2730: EMPTY
2731: LIST
2732: LIST
2733: PUSH
2734: EMPTY
2735: LIST
2736: LIST
2737: PPUSH
2738: CALL_OW 69
2742: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
2743: LD_ADDR_VAR 0 2
2747: PUSH
2748: LD_INT 22
2750: PUSH
2751: LD_INT 3
2753: PUSH
2754: EMPTY
2755: LIST
2756: LIST
2757: PUSH
2758: LD_INT 30
2760: PUSH
2761: LD_INT 1
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: PUSH
2768: EMPTY
2769: LIST
2770: LIST
2771: PPUSH
2772: CALL_OW 69
2776: PUSH
2777: FOR_IN
2778: IFFALSE 2822
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
2780: LD_VAR 0 2
2784: PPUSH
2785: CALL_OW 274
2789: PPUSH
2790: LD_INT 1
2792: PPUSH
2793: LD_INT 1000
2795: PPUSH
2796: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 300 ) ;
2800: LD_VAR 0 2
2804: PPUSH
2805: CALL_OW 274
2809: PPUSH
2810: LD_INT 2
2812: PPUSH
2813: LD_INT 300
2815: PPUSH
2816: CALL_OW 277
// end ;
2820: GO 2777
2822: POP
2823: POP
// uc_side := 3 ;
2824: LD_ADDR_OWVAR 20
2828: PUSH
2829: LD_INT 3
2831: ST_TO_ADDR
// uc_nation := 3 ;
2832: LD_ADDR_OWVAR 21
2836: PUSH
2837: LD_INT 3
2839: ST_TO_ADDR
// skill := [ 2 , 2 , 3 ] [ Difficulty ] ;
2840: LD_ADDR_VAR 0 8
2844: PUSH
2845: LD_INT 2
2847: PUSH
2848: LD_INT 2
2850: PUSH
2851: LD_INT 3
2853: PUSH
2854: EMPTY
2855: LIST
2856: LIST
2857: LIST
2858: PUSH
2859: LD_OWVAR 67
2863: ARRAY
2864: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
2865: LD_ADDR_EXP 39
2869: PUSH
2870: LD_STRING Pokryshkin
2872: PPUSH
2873: LD_INT 0
2875: PPUSH
2876: CALL 353 0 2
2880: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
2881: LD_EXP 39
2885: PPUSH
2886: LD_INT 63
2888: PPUSH
2889: LD_INT 21
2891: PPUSH
2892: LD_INT 0
2894: PPUSH
2895: CALL_OW 48
// ComHold ( Pokryshkin ) ;
2899: LD_EXP 39
2903: PPUSH
2904: CALL_OW 140
// InitHc ;
2908: CALL_OW 19
// for i in tw do
2912: LD_ADDR_VAR 0 2
2916: PUSH
2917: LD_VAR 0 6
2921: PUSH
2922: FOR_IN
2923: IFFALSE 2972
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
2925: LD_VAR 0 2
2929: PPUSH
2930: LD_INT 42
2932: PUSH
2933: LD_INT 43
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PUSH
2940: LD_INT 1
2942: PPUSH
2943: LD_INT 2
2945: PPUSH
2946: CALL_OW 12
2950: ARRAY
2951: PPUSH
2952: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
2956: LD_VAR 0 8
2960: PPUSH
2961: LD_VAR 0 2
2965: PPUSH
2966: CALL 670 0 2
// end ;
2970: GO 2922
2972: POP
2973: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
2974: LD_ADDR_VAR 0 10
2978: PUSH
2979: LD_INT 100
2981: PUSH
2982: LD_INT 9
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: PUSH
2989: LD_INT 135
2991: PUSH
2992: LD_INT 60
2994: PUSH
2995: EMPTY
2996: LIST
2997: LIST
2998: PUSH
2999: LD_INT 41
3001: PUSH
3002: LD_INT 6
3004: PUSH
3005: EMPTY
3006: LIST
3007: LIST
3008: PUSH
3009: LD_INT 22
3011: PUSH
3012: LD_INT 9
3014: PUSH
3015: EMPTY
3016: LIST
3017: LIST
3018: PUSH
3019: LD_INT 84
3021: PUSH
3022: LD_INT 14
3024: PUSH
3025: EMPTY
3026: LIST
3027: LIST
3028: PUSH
3029: EMPTY
3030: LIST
3031: LIST
3032: LIST
3033: LIST
3034: LIST
3035: ST_TO_ADDR
// vehicles := [ ] ;
3036: LD_ADDR_VAR 0 9
3040: PUSH
3041: EMPTY
3042: ST_TO_ADDR
// for i in spot_xy do
3043: LD_ADDR_VAR 0 2
3047: PUSH
3048: LD_VAR 0 10
3052: PUSH
3053: FOR_IN
3054: IFFALSE 3208
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
3056: LD_ADDR_VAR 0 5
3060: PUSH
3061: LD_INT 3
3063: PPUSH
3064: LD_INT 3
3066: PPUSH
3067: LD_INT 22
3069: PPUSH
3070: LD_INT 1
3072: PPUSH
3073: LD_INT 1
3075: PPUSH
3076: LD_INT 42
3078: PUSH
3079: LD_INT 43
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: PUSH
3086: LD_INT 1
3088: PPUSH
3089: LD_INT 2
3091: PPUSH
3092: CALL_OW 12
3096: ARRAY
3097: PPUSH
3098: LD_INT 100
3100: PPUSH
3101: CALL 410 0 7
3105: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3106: LD_ADDR_VAR 0 9
3110: PUSH
3111: LD_VAR 0 9
3115: PPUSH
3116: LD_VAR 0 9
3120: PUSH
3121: LD_INT 1
3123: PLUS
3124: PPUSH
3125: LD_VAR 0 5
3129: PPUSH
3130: CALL_OW 2
3134: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3135: LD_VAR 0 5
3139: PPUSH
3140: LD_INT 3
3142: PPUSH
3143: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3147: LD_VAR 0 5
3151: PPUSH
3152: LD_VAR 0 2
3156: PUSH
3157: LD_INT 1
3159: ARRAY
3160: PPUSH
3161: LD_VAR 0 2
3165: PUSH
3166: LD_INT 2
3168: ARRAY
3169: PPUSH
3170: LD_INT 0
3172: PPUSH
3173: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3177: LD_INT 0
3179: PPUSH
3180: LD_INT 3
3182: PPUSH
3183: LD_VAR 0 8
3187: PPUSH
3188: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3192: CALL_OW 44
3196: PPUSH
3197: LD_VAR 0 5
3201: PPUSH
3202: CALL_OW 52
// end ;
3206: GO 3053
3208: POP
3209: POP
// for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
3210: LD_ADDR_VAR 0 2
3214: PUSH
3215: DOUBLE
3216: LD_INT 1
3218: DEC
3219: ST_TO_ADDR
3220: LD_INT 3
3222: PUSH
3223: LD_INT 4
3225: PUSH
3226: LD_INT 5
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: LIST
3233: PUSH
3234: LD_OWVAR 67
3238: ARRAY
3239: PUSH
3240: FOR_TO
3241: IFFALSE 3301
// begin PrepareHuman ( false , 1 , skill ) ;
3243: LD_INT 0
3245: PPUSH
3246: LD_INT 1
3248: PPUSH
3249: LD_VAR 0 8
3253: PPUSH
3254: CALL_OW 380
// un := CreateHuman ;
3258: LD_ADDR_VAR 0 4
3262: PUSH
3263: CALL_OW 44
3267: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3268: LD_VAR 0 4
3272: PPUSH
3273: LD_INT 11
3275: PPUSH
3276: LD_INT 0
3278: PPUSH
3279: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3283: LD_ADDR_EXP 41
3287: PUSH
3288: LD_EXP 41
3292: PUSH
3293: LD_VAR 0 4
3297: ADD
3298: ST_TO_ADDR
// end ;
3299: GO 3240
3301: POP
3302: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3303: LD_ADDR_VAR 0 2
3307: PUSH
3308: DOUBLE
3309: LD_INT 1
3311: DEC
3312: ST_TO_ADDR
3313: LD_INT 2
3315: PUSH
3316: LD_INT 3
3318: PUSH
3319: LD_INT 4
3321: PUSH
3322: EMPTY
3323: LIST
3324: LIST
3325: LIST
3326: PUSH
3327: LD_OWVAR 67
3331: ARRAY
3332: PUSH
3333: FOR_TO
3334: IFFALSE 3378
// begin PrepareHuman ( false , 1 , skill ) ;
3336: LD_INT 0
3338: PPUSH
3339: LD_INT 1
3341: PPUSH
3342: LD_VAR 0 8
3346: PPUSH
3347: CALL_OW 380
// un := CreateHuman ;
3351: LD_ADDR_VAR 0 4
3355: PUSH
3356: CALL_OW 44
3360: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
3361: LD_VAR 0 4
3365: PPUSH
3366: LD_INT 12
3368: PPUSH
3369: LD_INT 0
3371: PPUSH
3372: CALL_OW 49
// end ;
3376: GO 3333
3378: POP
3379: POP
// end ; end_of_file
3380: LD_VAR 0 1
3384: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
3385: LD_INT 0
3387: PPUSH
3388: PPUSH
3389: PPUSH
3390: PPUSH
3391: PPUSH
3392: PPUSH
3393: PPUSH
// InGameOn ;
3394: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
3398: LD_EXP 24
3402: PPUSH
3403: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
3407: LD_EXP 24
3411: PPUSH
3412: LD_EXP 31
3416: PPUSH
3417: CALL_OW 119
// if Bierezov then
3421: LD_EXP 32
3425: IFFALSE 3441
// ComTurnUnit ( Bierezov , Cornel ) ;
3427: LD_EXP 32
3431: PPUSH
3432: LD_EXP 31
3436: PPUSH
3437: CALL_OW 119
// for i in jmm_units do
3441: LD_ADDR_VAR 0 2
3445: PUSH
3446: LD_EXP 2
3450: PUSH
3451: FOR_IN
3452: IFFALSE 3470
// ComTurnUnit ( i , Cornel ) ;
3454: LD_VAR 0 2
3458: PPUSH
3459: LD_EXP 31
3463: PPUSH
3464: CALL_OW 119
3468: GO 3451
3470: POP
3471: POP
// units := cornel_units union Cornel ;
3472: LD_ADDR_VAR 0 3
3476: PUSH
3477: LD_EXP 4
3481: PUSH
3482: LD_EXP 31
3486: UNION
3487: ST_TO_ADDR
// repeat wait ( 1 ) ;
3488: LD_INT 1
3490: PPUSH
3491: CALL_OW 67
// for i in units do
3495: LD_ADDR_VAR 0 2
3499: PUSH
3500: LD_VAR 0 3
3504: PUSH
3505: FOR_IN
3506: IFFALSE 3539
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
3508: LD_VAR 0 2
3512: PPUSH
3513: LD_EXP 24
3517: PPUSH
3518: CALL_OW 250
3522: PPUSH
3523: LD_EXP 24
3527: PPUSH
3528: CALL_OW 251
3532: PPUSH
3533: CALL_OW 111
3537: GO 3505
3539: POP
3540: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
3541: LD_VAR 0 3
3545: PPUSH
3546: LD_INT 92
3548: PUSH
3549: LD_EXP 24
3553: PPUSH
3554: CALL_OW 250
3558: PUSH
3559: LD_EXP 24
3563: PPUSH
3564: CALL_OW 251
3568: PUSH
3569: LD_INT 10
3571: PUSH
3572: EMPTY
3573: LIST
3574: LIST
3575: LIST
3576: LIST
3577: PPUSH
3578: CALL_OW 72
3582: PUSH
3583: LD_VAR 0 3
3587: EQUAL
3588: IFFALSE 3488
// for i in units do
3590: LD_ADDR_VAR 0 2
3594: PUSH
3595: LD_VAR 0 3
3599: PUSH
3600: FOR_IN
3601: IFFALSE 3619
// ComTurnUnit ( i , JMM ) ;
3603: LD_VAR 0 2
3607: PPUSH
3608: LD_EXP 24
3612: PPUSH
3613: CALL_OW 119
3617: GO 3600
3619: POP
3620: POP
// ComTurnUnit ( Cornel , JMM ) ;
3621: LD_EXP 31
3625: PPUSH
3626: LD_EXP 24
3630: PPUSH
3631: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
3635: LD_EXP 24
3639: PPUSH
3640: LD_STRING D1-JMM-1
3642: PPUSH
3643: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
3647: LD_EXP 31
3651: PPUSH
3652: LD_STRING D1-Corn-1
3654: PPUSH
3655: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
3659: LD_EXP 24
3663: PPUSH
3664: LD_EXP 31
3668: PPUSH
3669: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
3673: LD_EXP 31
3677: PPUSH
3678: LD_EXP 24
3682: PPUSH
3683: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
3687: LD_INT 35
3689: PPUSH
3690: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
3694: LD_EXP 24
3698: PPUSH
3699: LD_EXP 31
3703: PPUSH
3704: CALL_OW 296
3708: PUSH
3709: LD_INT 6
3711: LESS
3712: IFFALSE 3687
// ChangeSideFog ( 4 , 1 ) ;
3714: LD_INT 4
3716: PPUSH
3717: LD_INT 1
3719: PPUSH
3720: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
3724: LD_EXP 24
3728: PPUSH
3729: LD_EXP 31
3733: PPUSH
3734: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
3738: LD_EXP 31
3742: PPUSH
3743: LD_EXP 24
3747: PPUSH
3748: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
3752: LD_EXP 24
3756: PPUSH
3757: LD_STRING D1-JMM-2
3759: PPUSH
3760: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
3764: LD_EXP 24
3768: PPUSH
3769: LD_STRING D1-JMM-2a
3771: PPUSH
3772: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
3776: LD_EXP 31
3780: PPUSH
3781: LD_STRING D1-Corn-2
3783: PPUSH
3784: CALL_OW 88
// if bierezov_exist or debug then
3788: LD_EXP 5
3792: PUSH
3793: LD_EXP 1
3797: OR
3798: IFFALSE 4039
// begin ComTurnUnit ( Cornel , Bierezov ) ;
3800: LD_EXP 31
3804: PPUSH
3805: LD_EXP 32
3809: PPUSH
3810: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
3814: LD_INT 10
3816: PPUSH
3817: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
3821: LD_EXP 31
3825: PPUSH
3826: LD_STRING D1a-Corn-1
3828: PPUSH
3829: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
3833: LD_EXP 24
3837: PPUSH
3838: LD_EXP 32
3842: PPUSH
3843: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
3847: LD_EXP 32
3851: PPUSH
3852: LD_EXP 24
3856: PPUSH
3857: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
3861: LD_EXP 24
3865: PPUSH
3866: LD_STRING D1a-JMM-1
3868: PPUSH
3869: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
3873: LD_EXP 24
3877: PPUSH
3878: LD_EXP 31
3882: PPUSH
3883: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
3887: LD_EXP 31
3891: PPUSH
3892: LD_EXP 24
3896: PPUSH
3897: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
3901: LD_EXP 31
3905: PPUSH
3906: LD_STRING D1a-Corn-2
3908: PPUSH
3909: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
3913: LD_EXP 24
3917: PPUSH
3918: LD_STRING D1a-JMM-2
3920: PPUSH
3921: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
3925: LD_EXP 31
3929: PPUSH
3930: LD_STRING D1a-Corn-3
3932: PPUSH
3933: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
3937: LD_EXP 24
3941: PPUSH
3942: LD_STRING D1a-JMM-3
3944: PPUSH
3945: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
3949: LD_EXP 31
3953: PPUSH
3954: LD_STRING D1a-Corn-4
3956: PPUSH
3957: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
3961: LD_EXP 24
3965: PPUSH
3966: LD_STRING D1a-JMM-4
3968: PPUSH
3969: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
3973: LD_EXP 31
3977: PPUSH
3978: LD_STRING D1a-Corn-5
3980: PPUSH
3981: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
3985: LD_EXP 32
3989: PPUSH
3990: LD_EXP 31
3994: PPUSH
3995: CALL_OW 250
3999: PPUSH
4000: LD_EXP 31
4004: PPUSH
4005: CALL_OW 251
4009: PUSH
4010: LD_INT 2
4012: MINUS
4013: PPUSH
4014: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
4018: LD_EXP 32
4022: PPUSH
4023: LD_EXP 31
4027: PPUSH
4028: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
4032: LD_INT 10
4034: PPUSH
4035: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
4039: LD_EXP 24
4043: PPUSH
4044: LD_STRING D1b-JMM-1
4046: PPUSH
4047: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
4051: LD_EXP 31
4055: PPUSH
4056: LD_STRING D1b-Corn-1
4058: PPUSH
4059: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
4063: LD_EXP 24
4067: PPUSH
4068: LD_STRING D1b-JMM-2
4070: PPUSH
4071: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
4075: LD_EXP 31
4079: PPUSH
4080: LD_STRING D1b-Corn-2
4082: PPUSH
4083: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
4087: LD_EXP 24
4091: PPUSH
4092: LD_STRING D1b-JMM-3
4094: PPUSH
4095: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
4099: LD_INT 10
4101: PPUSH
4102: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
4106: LD_EXP 33
4110: PPUSH
4111: LD_STRING D1b-Pow-3
4113: PPUSH
4114: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
4118: LD_EXP 24
4122: PPUSH
4123: LD_STRING D1b-JMM-4
4125: PPUSH
4126: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
4130: LD_EXP 31
4134: PPUSH
4135: LD_STRING D1b-Corn-4
4137: PPUSH
4138: CALL_OW 88
// if Khatam then
4142: LD_EXP 28
4146: IFFALSE 4162
// Say ( Khatam , D1b-Khat-4 ) else
4148: LD_EXP 28
4152: PPUSH
4153: LD_STRING D1b-Khat-4
4155: PPUSH
4156: CALL_OW 88
4160: GO 4198
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
4162: LD_EXP 4
4166: PPUSH
4167: LD_INT 26
4169: PUSH
4170: LD_INT 1
4172: PUSH
4173: EMPTY
4174: LIST
4175: LIST
4176: PPUSH
4177: CALL_OW 72
4181: PUSH
4182: LD_EXP 31
4186: PUSH
4187: EMPTY
4188: LIST
4189: DIFF
4190: PPUSH
4191: LD_STRING D1b-Sol1-4
4193: PPUSH
4194: CALL 498 0 2
// if Cyrus then
4198: LD_EXP 26
4202: IFFALSE 4216
// Say ( Cyrus , D1b-Cyrus-4 ) ;
4204: LD_EXP 26
4208: PPUSH
4209: LD_STRING D1b-Cyrus-4
4211: PPUSH
4212: CALL_OW 88
// if Lisa then
4216: LD_EXP 27
4220: IFFALSE 4278
// begin Say ( Lisa , D1b-Lisa-4 ) ;
4222: LD_EXP 27
4226: PPUSH
4227: LD_STRING D1b-Lisa-4
4229: PPUSH
4230: CALL_OW 88
// if Cyrus then
4234: LD_EXP 26
4238: IFFALSE 4278
// begin if not IsInUnit ( Cyrus ) then
4240: LD_EXP 26
4244: PPUSH
4245: CALL_OW 310
4249: NOT
4250: IFFALSE 4266
// ComTurnUnit ( Cyrus , Lisa ) ;
4252: LD_EXP 26
4256: PPUSH
4257: LD_EXP 27
4261: PPUSH
4262: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
4266: LD_EXP 26
4270: PPUSH
4271: LD_STRING D1b-Cyrus-5
4273: PPUSH
4274: CALL_OW 88
// end ; end ; SelectGroup ;
4278: CALL 2295 0 0
// Say ( JMM , D1d-JMM-1 ) ;
4282: LD_EXP 24
4286: PPUSH
4287: LD_STRING D1d-JMM-1
4289: PPUSH
4290: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
4294: LD_EXP 31
4298: PPUSH
4299: LD_STRING D1d-Corn-1
4301: PPUSH
4302: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
4306: LD_ADDR_VAR 0 2
4310: PUSH
4311: LD_EXP 2
4315: PUSH
4316: LD_EXP 4
4320: ADD
4321: PUSH
4322: LD_EXP 24
4326: ADD
4327: PUSH
4328: FOR_IN
4329: IFFALSE 4342
// ComHold ( i ) ;
4331: LD_VAR 0 2
4335: PPUSH
4336: CALL_OW 140
4340: GO 4328
4342: POP
4343: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
4344: LD_ADDR_VAR 0 4
4348: PUSH
4349: LD_INT 22
4351: PUSH
4352: LD_INT 1
4354: PUSH
4355: EMPTY
4356: LIST
4357: LIST
4358: PUSH
4359: LD_INT 21
4361: PUSH
4362: LD_INT 2
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: PPUSH
4373: CALL_OW 69
4377: ST_TO_ADDR
// if vehicles then
4378: LD_VAR 0 4
4382: IFFALSE 4720
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
4384: LD_EXP 4
4388: PPUSH
4389: LD_INT 55
4391: PUSH
4392: EMPTY
4393: LIST
4394: PPUSH
4395: CALL_OW 72
4399: IFFALSE 4438
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
4401: LD_ADDR_VAR 0 2
4405: PUSH
4406: LD_EXP 4
4410: PPUSH
4411: LD_INT 55
4413: PUSH
4414: EMPTY
4415: LIST
4416: PPUSH
4417: CALL_OW 72
4421: PUSH
4422: FOR_IN
4423: IFFALSE 4436
// ComExitVehicle ( i ) ;
4425: LD_VAR 0 2
4429: PPUSH
4430: CALL_OW 121
4434: GO 4422
4436: POP
4437: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
4438: LD_ADDR_VAR 0 5
4442: PUSH
4443: LD_VAR 0 4
4447: PPUSH
4448: LD_INT 34
4450: PUSH
4451: LD_INT 51
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: PPUSH
4458: CALL_OW 72
4462: ST_TO_ADDR
// if cargos then
4463: LD_VAR 0 5
4467: IFFALSE 4650
// begin vehicles := cargos ;
4469: LD_ADDR_VAR 0 4
4473: PUSH
4474: LD_VAR 0 5
4478: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
4479: LD_ADDR_VAR 0 6
4483: PUSH
4484: LD_STRING 02_resources_4
4486: PPUSH
4487: LD_INT 0
4489: PPUSH
4490: CALL_OW 30
4494: ST_TO_ADDR
// if debug and not resources then
4495: LD_EXP 1
4499: PUSH
4500: LD_VAR 0 6
4504: NOT
4505: AND
4506: IFFALSE 4516
// resources := 160 ;
4508: LD_ADDR_VAR 0 6
4512: PUSH
4513: LD_INT 160
4515: ST_TO_ADDR
// if resources mod 10 then
4516: LD_VAR 0 6
4520: PUSH
4521: LD_INT 10
4523: MOD
4524: IFFALSE 4546
// resources := resources - resources mod 10 ;
4526: LD_ADDR_VAR 0 6
4530: PUSH
4531: LD_VAR 0 6
4535: PUSH
4536: LD_VAR 0 6
4540: PUSH
4541: LD_INT 10
4543: MOD
4544: MINUS
4545: ST_TO_ADDR
// if resources then
4546: LD_VAR 0 6
4550: IFFALSE 4650
// for i in cargos do
4552: LD_ADDR_VAR 0 2
4556: PUSH
4557: LD_VAR 0 5
4561: PUSH
4562: FOR_IN
4563: IFFALSE 4648
// begin if resources < 100 then
4565: LD_VAR 0 6
4569: PUSH
4570: LD_INT 100
4572: LESS
4573: IFFALSE 4595
// begin cargo := resources ;
4575: LD_ADDR_VAR 0 7
4579: PUSH
4580: LD_VAR 0 6
4584: ST_TO_ADDR
// resources := 0 ;
4585: LD_ADDR_VAR 0 6
4589: PUSH
4590: LD_INT 0
4592: ST_TO_ADDR
// end else
4593: GO 4617
// begin cargo := 100 ;
4595: LD_ADDR_VAR 0 7
4599: PUSH
4600: LD_INT 100
4602: ST_TO_ADDR
// resources := resources - 100 ;
4603: LD_ADDR_VAR 0 6
4607: PUSH
4608: LD_VAR 0 6
4612: PUSH
4613: LD_INT 100
4615: MINUS
4616: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
4617: LD_VAR 0 2
4621: PPUSH
4622: LD_INT 1
4624: PPUSH
4625: LD_VAR 0 7
4629: PPUSH
4630: CALL_OW 290
// if resources = 0 then
4634: LD_VAR 0 6
4638: PUSH
4639: LD_INT 0
4641: EQUAL
4642: IFFALSE 4646
// break ;
4644: GO 4648
// end ;
4646: GO 4562
4648: POP
4649: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
4650: LD_VAR 0 4
4654: PUSH
4655: LD_INT 1
4657: ARRAY
4658: PPUSH
4659: CALL_OW 311
4663: PPUSH
4664: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
4668: LD_VAR 0 4
4672: PUSH
4673: LD_INT 1
4675: ARRAY
4676: PPUSH
4677: LD_INT 4
4679: PPUSH
4680: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
4684: LD_EXP 31
4688: PPUSH
4689: LD_VAR 0 4
4693: PUSH
4694: LD_INT 1
4696: ARRAY
4697: PPUSH
4698: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
4702: LD_INT 35
4704: PPUSH
4705: CALL_OW 67
// until IsInUnit ( Cornel ) ;
4709: LD_EXP 31
4713: PPUSH
4714: CALL_OW 310
4718: IFFALSE 4702
// end ; InGameOff ;
4720: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
4724: LD_STRING M1
4726: PPUSH
4727: CALL_OW 337
// cornel_active := true ;
4731: LD_ADDR_EXP 6
4735: PUSH
4736: LD_INT 1
4738: ST_TO_ADDR
// end ;
4739: LD_VAR 0 1
4743: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
4744: LD_EXP 24
4748: PPUSH
4749: LD_EXP 34
4753: PPUSH
4754: CALL_OW 296
4758: PUSH
4759: LD_INT 10
4761: LESS
4762: IFFALSE 5854
4764: GO 4766
4766: DISABLE
4767: LD_INT 0
4769: PPUSH
4770: PPUSH
4771: PPUSH
4772: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
4773: LD_ADDR_VAR 0 2
4777: PUSH
4778: LD_INT 89
4780: PUSH
4781: LD_INT 34
4783: PUSH
4784: EMPTY
4785: LIST
4786: LIST
4787: PUSH
4788: LD_INT 138
4790: PUSH
4791: LD_INT 63
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: PUSH
4798: LD_INT 196
4800: PUSH
4801: LD_INT 84
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PUSH
4808: LD_INT 135
4810: PUSH
4811: LD_INT 52
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 103
4820: PUSH
4821: LD_INT 39
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PUSH
4828: LD_INT 58
4830: PUSH
4831: LD_INT 30
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PUSH
4838: LD_INT 38
4840: PUSH
4841: LD_INT 51
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: LIST
4852: LIST
4853: LIST
4854: LIST
4855: LIST
4856: ST_TO_ADDR
// InGameOn ;
4857: CALL_OW 8
// if jmm_units then
4861: LD_EXP 2
4865: IFFALSE 4929
// for i in jmm_units do
4867: LD_ADDR_VAR 0 1
4871: PUSH
4872: LD_EXP 2
4876: PUSH
4877: FOR_IN
4878: IFFALSE 4927
// begin if GetDistUnits ( i , JMM ) < 10 then
4880: LD_VAR 0 1
4884: PPUSH
4885: LD_EXP 24
4889: PPUSH
4890: CALL_OW 296
4894: PUSH
4895: LD_INT 10
4897: LESS
4898: IFFALSE 4916
// ComTurnUnit ( i , JMM ) else
4900: LD_VAR 0 1
4904: PPUSH
4905: LD_EXP 24
4909: PPUSH
4910: CALL_OW 119
4914: GO 4925
// ComHold ( i ) ;
4916: LD_VAR 0 1
4920: PPUSH
4921: CALL_OW 140
// end ;
4925: GO 4877
4927: POP
4928: POP
// ComMoveUnit ( JMM , Lynch ) ;
4929: LD_EXP 24
4933: PPUSH
4934: LD_EXP 34
4938: PPUSH
4939: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
4943: LD_INT 35
4945: PPUSH
4946: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
4950: LD_EXP 24
4954: PPUSH
4955: LD_EXP 34
4959: PPUSH
4960: CALL_OW 296
4964: PUSH
4965: LD_INT 6
4967: LESS
4968: IFFALSE 4943
// ComTurnUnit ( JMM , Lynch ) ;
4970: LD_EXP 24
4974: PPUSH
4975: LD_EXP 34
4979: PPUSH
4980: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
4984: LD_ADDR_VAR 0 1
4988: PUSH
4989: LD_EXP 34
4993: PUSH
4994: LD_EXP 35
4998: PUSH
4999: LD_EXP 36
5003: PUSH
5004: LD_EXP 37
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: PUSH
5015: FOR_IN
5016: IFFALSE 5034
// ComTurnUnit ( i , JMM ) ;
5018: LD_VAR 0 1
5022: PPUSH
5023: LD_EXP 24
5027: PPUSH
5028: CALL_OW 119
5032: GO 5015
5034: POP
5035: POP
// Wait ( 0 0$0.3 ) ;
5036: LD_INT 10
5038: PPUSH
5039: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
5043: LD_EXP 24
5047: PPUSH
5048: LD_STRING D2-JMM-1
5050: PPUSH
5051: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
5055: LD_EXP 34
5059: PPUSH
5060: LD_STRING D2-Sol1-1
5062: PPUSH
5063: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
5067: LD_EXP 24
5071: PPUSH
5072: LD_STRING D2-JMM-2
5074: PPUSH
5075: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
5079: LD_EXP 34
5083: PPUSH
5084: LD_STRING D2-Sol1-2
5086: PPUSH
5087: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
5091: LD_EXP 24
5095: PPUSH
5096: LD_STRING D2-JMM-3
5098: PPUSH
5099: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
5103: LD_EXP 34
5107: PPUSH
5108: LD_STRING D2-Sol1-3
5110: PPUSH
5111: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
5115: LD_ADDR_VAR 0 1
5119: PUSH
5120: LD_INT 22
5122: PUSH
5123: LD_INT 8
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PPUSH
5130: CALL_OW 69
5134: PUSH
5135: FOR_IN
5136: IFFALSE 5152
// SetSide ( i , 1 ) ;
5138: LD_VAR 0 1
5142: PPUSH
5143: LD_INT 1
5145: PPUSH
5146: CALL_OW 235
5150: GO 5135
5152: POP
5153: POP
// Say ( JMM , D2-JMM-4 ) ;
5154: LD_EXP 24
5158: PPUSH
5159: LD_STRING D2-JMM-4
5161: PPUSH
5162: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
5166: LD_INT 1
5168: PPUSH
5169: LD_INT 5
5171: PPUSH
5172: CALL_OW 332
// for i = 1 to points do
5176: LD_ADDR_VAR 0 1
5180: PUSH
5181: DOUBLE
5182: LD_INT 1
5184: DEC
5185: ST_TO_ADDR
5186: LD_VAR 0 2
5190: PUSH
5191: FOR_TO
5192: IFFALSE 5367
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
5194: LD_VAR 0 2
5198: PUSH
5199: LD_VAR 0 1
5203: ARRAY
5204: PUSH
5205: LD_INT 1
5207: ARRAY
5208: PPUSH
5209: LD_VAR 0 2
5213: PUSH
5214: LD_VAR 0 1
5218: ARRAY
5219: PUSH
5220: LD_INT 2
5222: ARRAY
5223: PPUSH
5224: CALL_OW 84
// if i = 1 then
5228: LD_VAR 0 1
5232: PUSH
5233: LD_INT 1
5235: EQUAL
5236: IFFALSE 5250
// Say ( Lynch , D2-Sol1-4 ) ;
5238: LD_EXP 34
5242: PPUSH
5243: LD_STRING D2-Sol1-4
5245: PPUSH
5246: CALL_OW 88
// if i = 2 then
5250: LD_VAR 0 1
5254: PUSH
5255: LD_INT 2
5257: EQUAL
5258: IFFALSE 5272
// Say ( JMM , D2-JMM-5 ) ;
5260: LD_EXP 24
5264: PPUSH
5265: LD_STRING D2-JMM-5
5267: PPUSH
5268: CALL_OW 88
// if i = 4 then
5272: LD_VAR 0 1
5276: PUSH
5277: LD_INT 4
5279: EQUAL
5280: IFFALSE 5304
// begin RevealFogArea ( 1 , troopsArea ) ;
5282: LD_INT 1
5284: PPUSH
5285: LD_INT 6
5287: PPUSH
5288: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
5292: LD_EXP 34
5296: PPUSH
5297: LD_STRING D2-Sol1-5
5299: PPUSH
5300: CALL_OW 88
// end ; if i = 5 then
5304: LD_VAR 0 1
5308: PUSH
5309: LD_INT 5
5311: EQUAL
5312: IFFALSE 5326
// Say ( JMM , D2-JMM-6 ) ;
5314: LD_EXP 24
5318: PPUSH
5319: LD_STRING D2-JMM-6
5321: PPUSH
5322: CALL_OW 88
// if i = 7 then
5326: LD_VAR 0 1
5330: PUSH
5331: LD_INT 7
5333: EQUAL
5334: IFFALSE 5358
// begin RevealFogArea ( 1 , forestArea ) ;
5336: LD_INT 1
5338: PPUSH
5339: LD_INT 7
5341: PPUSH
5342: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
5346: LD_EXP 34
5350: PPUSH
5351: LD_STRING D2-Sol1-6
5353: PPUSH
5354: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
5358: LD_INT 46
5360: PPUSH
5361: CALL_OW 67
// end ;
5365: GO 5191
5367: POP
5368: POP
// CenterNowOnUnits ( JMM ) ;
5369: LD_EXP 24
5373: PPUSH
5374: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
5378: LD_EXP 24
5382: PPUSH
5383: LD_STRING D2-JMM-7
5385: PPUSH
5386: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
5390: LD_EXP 34
5394: PPUSH
5395: LD_STRING D2-Sol1-7
5397: PPUSH
5398: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
5402: LD_EXP 24
5406: PPUSH
5407: LD_STRING D2-JMM-8
5409: PPUSH
5410: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
5414: LD_ADDR_VAR 0 4
5418: PUSH
5419: LD_INT 22
5421: PUSH
5422: LD_INT 1
5424: PUSH
5425: EMPTY
5426: LIST
5427: LIST
5428: PUSH
5429: LD_INT 30
5431: PUSH
5432: LD_INT 31
5434: PUSH
5435: EMPTY
5436: LIST
5437: LIST
5438: PUSH
5439: EMPTY
5440: LIST
5441: LIST
5442: PPUSH
5443: CALL_OW 69
5447: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
5448: LD_EXP 34
5452: PPUSH
5453: LD_VAR 0 4
5457: PUSH
5458: LD_INT 1
5460: ARRAY
5461: PPUSH
5462: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
5466: LD_ADDR_VAR 0 3
5470: PUSH
5471: LD_EXP 2
5475: PPUSH
5476: LD_INT 25
5478: PUSH
5479: LD_INT 1
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PPUSH
5486: CALL_OW 72
5490: PPUSH
5491: LD_EXP 24
5495: PPUSH
5496: CALL_OW 74
5500: ST_TO_ADDR
// if sol then
5501: LD_VAR 0 3
5505: IFFALSE 5545
// if GetDistUnits ( JMM , sol ) < 10 then
5507: LD_EXP 24
5511: PPUSH
5512: LD_VAR 0 3
5516: PPUSH
5517: CALL_OW 296
5521: PUSH
5522: LD_INT 10
5524: LESS
5525: IFFALSE 5545
// ComEnterUnit ( sol , buns [ 2 ] ) ;
5527: LD_VAR 0 3
5531: PPUSH
5532: LD_VAR 0 4
5536: PUSH
5537: LD_INT 2
5539: ARRAY
5540: PPUSH
5541: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
5545: LD_INT 10
5547: PPUSH
5548: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
5552: LD_EXP 24
5556: PPUSH
5557: LD_INT 65
5559: PPUSH
5560: LD_INT 101
5562: PPUSH
5563: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
5567: LD_EXP 24
5571: PPUSH
5572: LD_INT 63
5574: PPUSH
5575: LD_INT 100
5577: PPUSH
5578: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
5582: LD_INT 35
5584: PPUSH
5585: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
5589: LD_EXP 24
5593: PPUSH
5594: LD_INT 65
5596: PPUSH
5597: LD_INT 101
5599: PPUSH
5600: CALL_OW 307
5604: IFFALSE 5582
// Say ( JMM , D2a-JMM-1 ) ;
5606: LD_EXP 24
5610: PPUSH
5611: LD_STRING D2a-JMM-1
5613: PPUSH
5614: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
5618: LD_EXP 35
5622: PPUSH
5623: LD_INT 66
5625: PPUSH
5626: LD_INT 103
5628: PPUSH
5629: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
5633: LD_INT 35
5635: PPUSH
5636: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
5640: LD_EXP 35
5644: PPUSH
5645: LD_INT 66
5647: PPUSH
5648: LD_INT 103
5650: PPUSH
5651: CALL_OW 307
5655: IFFALSE 5633
// ComTurnUnit ( Walker , JMM ) ;
5657: LD_EXP 35
5661: PPUSH
5662: LD_EXP 24
5666: PPUSH
5667: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
5671: LD_EXP 35
5675: PPUSH
5676: LD_STRING D2a-Sci1-1
5678: PPUSH
5679: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
5683: LD_EXP 24
5687: PPUSH
5688: LD_EXP 35
5692: PPUSH
5693: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
5697: LD_EXP 24
5701: PPUSH
5702: LD_STRING D2a-JMM-2
5704: PPUSH
5705: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
5709: LD_EXP 35
5713: PPUSH
5714: LD_STRING D2a-Sci1-2
5716: PPUSH
5717: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
5721: LD_EXP 24
5725: PPUSH
5726: LD_STRING D2a-JMM-3
5728: PPUSH
5729: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
5733: LD_EXP 35
5737: PPUSH
5738: LD_STRING D2a-Sci1-3
5740: PPUSH
5741: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
5745: LD_ADDR_EXP 2
5749: PUSH
5750: LD_EXP 2
5754: PUSH
5755: LD_EXP 34
5759: PUSH
5760: LD_EXP 35
5764: PUSH
5765: LD_EXP 36
5769: PUSH
5770: LD_EXP 37
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: LIST
5779: LIST
5780: ADD
5781: ST_TO_ADDR
// for i in jmm_units do
5782: LD_ADDR_VAR 0 1
5786: PUSH
5787: LD_EXP 2
5791: PUSH
5792: FOR_IN
5793: IFFALSE 5818
// if not IsInUnit ( i ) then
5795: LD_VAR 0 1
5799: PPUSH
5800: CALL_OW 310
5804: NOT
5805: IFFALSE 5816
// ComFree ( i ) ;
5807: LD_VAR 0 1
5811: PPUSH
5812: CALL_OW 139
5816: GO 5792
5818: POP
5819: POP
// InGameOff ;
5820: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
5824: LD_STRING MSolar1
5826: PPUSH
5827: CALL_OW 337
// jmm_on_west := true ;
5831: LD_ADDR_EXP 3
5835: PUSH
5836: LD_INT 1
5838: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
5839: LD_INT 1050
5841: PPUSH
5842: CALL_OW 67
// frank_can_return := true ;
5846: LD_ADDR_EXP 10
5850: PUSH
5851: LD_INT 1
5853: ST_TO_ADDR
// end ;
5854: PPOPN 4
5856: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
5857: LD_INT 22
5859: PUSH
5860: LD_INT 1
5862: PUSH
5863: EMPTY
5864: LIST
5865: LIST
5866: PUSH
5867: LD_INT 34
5869: PUSH
5870: LD_INT 51
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: PUSH
5877: LD_INT 92
5879: PUSH
5880: LD_INT 63
5882: PUSH
5883: LD_INT 100
5885: PUSH
5886: LD_INT 5
5888: PUSH
5889: EMPTY
5890: LIST
5891: LIST
5892: LIST
5893: LIST
5894: PUSH
5895: EMPTY
5896: LIST
5897: LIST
5898: LIST
5899: PUSH
5900: EMPTY
5901: LIST
5902: PPUSH
5903: CALL_OW 69
5907: PUSH
5908: LD_EXP 3
5912: NOT
5913: AND
5914: IFFALSE 6027
5916: GO 5918
5918: DISABLE
5919: LD_INT 0
5921: PPUSH
5922: PPUSH
// begin enable ;
5923: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
5924: LD_ADDR_VAR 0 2
5928: PUSH
5929: LD_INT 22
5931: PUSH
5932: LD_INT 1
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: PUSH
5939: LD_INT 34
5941: PUSH
5942: LD_INT 51
5944: PUSH
5945: EMPTY
5946: LIST
5947: LIST
5948: PUSH
5949: LD_INT 92
5951: PUSH
5952: LD_INT 63
5954: PUSH
5955: LD_INT 100
5957: PUSH
5958: LD_INT 5
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: LIST
5965: LIST
5966: PUSH
5967: EMPTY
5968: LIST
5969: LIST
5970: LIST
5971: PUSH
5972: EMPTY
5973: LIST
5974: PPUSH
5975: CALL_OW 69
5979: ST_TO_ADDR
// if not filter then
5980: LD_VAR 0 2
5984: NOT
5985: IFFALSE 5989
// exit ;
5987: GO 6027
// for i in filter do
5989: LD_ADDR_VAR 0 1
5993: PUSH
5994: LD_VAR 0 2
5998: PUSH
5999: FOR_IN
6000: IFFALSE 6025
// begin SetFuel ( i , 0 ) ;
6002: LD_VAR 0 1
6006: PPUSH
6007: LD_INT 0
6009: PPUSH
6010: CALL_OW 240
// ComStop ( i ) ;
6014: LD_VAR 0 1
6018: PPUSH
6019: CALL_OW 141
// end ;
6023: GO 5999
6025: POP
6026: POP
// end ;
6027: PPOPN 2
6029: END
// every 0 0$10 trigger frank_can_return do var i , points ;
6030: LD_EXP 10
6034: IFFALSE 7029
6036: GO 6038
6038: DISABLE
6039: LD_INT 0
6041: PPUSH
6042: PPUSH
// begin uc_side := 8 ;
6043: LD_ADDR_OWVAR 20
6047: PUSH
6048: LD_INT 8
6050: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
6051: LD_ADDR_VAR 0 2
6055: PUSH
6056: LD_INT 59
6058: PUSH
6059: LD_INT 71
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 122
6068: PUSH
6069: LD_INT 117
6071: PUSH
6072: EMPTY
6073: LIST
6074: LIST
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
6080: LD_ADDR_EXP 38
6084: PUSH
6085: LD_STRING Frank
6087: PPUSH
6088: LD_INT 0
6090: PPUSH
6091: CALL 353 0 2
6095: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
6096: LD_ADDR_VAR 0 1
6100: PUSH
6101: LD_INT 1
6103: PPUSH
6104: LD_INT 2
6106: PPUSH
6107: CALL_OW 12
6111: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
6112: LD_EXP 38
6116: PPUSH
6117: LD_VAR 0 2
6121: PUSH
6122: LD_VAR 0 1
6126: ARRAY
6127: PUSH
6128: LD_INT 1
6130: ARRAY
6131: PPUSH
6132: LD_VAR 0 2
6136: PUSH
6137: LD_VAR 0 1
6141: ARRAY
6142: PUSH
6143: LD_INT 2
6145: ARRAY
6146: PPUSH
6147: LD_INT 0
6149: PPUSH
6150: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
6154: LD_EXP 38
6158: PPUSH
6159: LD_INT 1
6161: PPUSH
6162: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
6166: LD_INT 35
6168: PPUSH
6169: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
6173: LD_EXP 38
6177: PPUSH
6178: LD_EXP 24
6182: PPUSH
6183: CALL_OW 296
6187: PUSH
6188: LD_INT 8
6190: LESS
6191: IFFALSE 6166
// InGameOn ;
6193: CALL_OW 8
// if IsInUnit ( JMM ) then
6197: LD_EXP 24
6201: PPUSH
6202: CALL_OW 310
6206: IFFALSE 6217
// ComFree ( JMM ) ;
6208: LD_EXP 24
6212: PPUSH
6213: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
6217: LD_EXP 24
6221: PPUSH
6222: LD_EXP 38
6226: PPUSH
6227: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
6231: LD_EXP 38
6235: PPUSH
6236: LD_EXP 24
6240: PPUSH
6241: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
6245: LD_EXP 24
6249: PPUSH
6250: LD_STRING D6-JMM-1
6252: PPUSH
6253: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
6257: LD_INT 35
6259: PPUSH
6260: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
6264: LD_EXP 24
6268: PPUSH
6269: LD_EXP 38
6273: PPUSH
6274: CALL_OW 296
6278: PUSH
6279: LD_INT 8
6281: LESS
6282: IFFALSE 6257
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
6284: LD_EXP 27
6288: PUSH
6289: LD_EXP 27
6293: PPUSH
6294: LD_EXP 38
6298: PPUSH
6299: CALL_OW 296
6303: PUSH
6304: LD_INT 20
6306: LESS
6307: AND
6308: IFFALSE 6333
// begin ComFree ( Lisa ) ;
6310: LD_EXP 27
6314: PPUSH
6315: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
6319: LD_EXP 27
6323: PPUSH
6324: LD_EXP 38
6328: PPUSH
6329: CALL_OW 172
// end ; if Lynch then
6333: LD_EXP 34
6337: IFFALSE 6362
// begin ComFree ( Lynch ) ;
6339: LD_EXP 34
6343: PPUSH
6344: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
6348: LD_EXP 34
6352: PPUSH
6353: LD_EXP 38
6357: PPUSH
6358: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
6362: LD_EXP 24
6366: PPUSH
6367: LD_EXP 38
6371: PPUSH
6372: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
6376: LD_EXP 38
6380: PPUSH
6381: LD_EXP 24
6385: PPUSH
6386: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
6390: LD_EXP 38
6394: PPUSH
6395: LD_STRING D6-Frank-1
6397: PPUSH
6398: CALL_OW 88
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
6402: LD_EXP 27
6406: PUSH
6407: LD_EXP 27
6411: PPUSH
6412: LD_EXP 38
6416: PPUSH
6417: CALL_OW 296
6421: PUSH
6422: LD_INT 20
6424: LESS
6425: AND
6426: PUSH
6427: LD_EXP 27
6431: PPUSH
6432: CALL_OW 302
6436: AND
6437: IFFALSE 6518
// begin repeat wait ( 0 0$01 ) ;
6439: LD_INT 35
6441: PPUSH
6442: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
6446: LD_EXP 27
6450: PPUSH
6451: LD_EXP 38
6455: PPUSH
6456: CALL_OW 296
6460: PUSH
6461: LD_INT 7
6463: LESS
6464: IFFALSE 6439
// Say ( Lisa , D6-Lisa-1 ) ;
6466: LD_EXP 27
6470: PPUSH
6471: LD_STRING D6-Lisa-1
6473: PPUSH
6474: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
6478: LD_EXP 27
6482: PPUSH
6483: LD_EXP 38
6487: PPUSH
6488: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
6492: LD_EXP 38
6496: PPUSH
6497: LD_EXP 27
6501: PPUSH
6502: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
6506: LD_EXP 38
6510: PPUSH
6511: LD_STRING D6-Frank-2
6513: PPUSH
6514: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
6518: LD_EXP 34
6522: PUSH
6523: LD_EXP 34
6527: PPUSH
6528: LD_EXP 38
6532: PPUSH
6533: CALL_OW 296
6537: PUSH
6538: LD_INT 20
6540: LESS
6541: AND
6542: PUSH
6543: LD_EXP 34
6547: PPUSH
6548: CALL_OW 302
6552: AND
6553: IFFALSE 6734
// begin ComTurnUnit ( Lynch , JMM ) ;
6555: LD_EXP 34
6559: PPUSH
6560: LD_EXP 24
6564: PPUSH
6565: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
6569: LD_EXP 38
6573: PPUSH
6574: LD_EXP 24
6578: PPUSH
6579: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
6583: LD_EXP 34
6587: PPUSH
6588: LD_STRING D6-Sol1-2
6590: PPUSH
6591: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
6595: LD_EXP 24
6599: PPUSH
6600: LD_STRING D6-JMM-2
6602: PPUSH
6603: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
6607: LD_EXP 38
6611: PPUSH
6612: LD_STRING D6-Frank-3
6614: PPUSH
6615: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
6619: LD_EXP 24
6623: PPUSH
6624: LD_STRING D6-JMM-3
6626: PPUSH
6627: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
6631: LD_EXP 38
6635: PPUSH
6636: LD_STRING D6-Frank-4
6638: PPUSH
6639: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
6643: LD_EXP 38
6647: PPUSH
6648: LD_STRING D6-Frank-4a
6650: PPUSH
6651: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
6655: LD_EXP 24
6659: PPUSH
6660: LD_STRING D6-JMM-4
6662: PPUSH
6663: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
6667: LD_EXP 38
6671: PPUSH
6672: LD_STRING D6-Frank-5
6674: PPUSH
6675: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
6679: LD_EXP 27
6683: PUSH
6684: LD_EXP 27
6688: PPUSH
6689: CALL_OW 302
6693: AND
6694: IFFALSE 6708
// Say ( Lisa , D6-Lisa-5 ) ;
6696: LD_EXP 27
6700: PPUSH
6701: LD_STRING D6-Lisa-5
6703: PPUSH
6704: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
6708: LD_EXP 38
6712: PPUSH
6713: LD_STRING D6-Frank-6
6715: PPUSH
6716: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
6720: LD_EXP 24
6724: PPUSH
6725: LD_STRING D6-JMM-6
6727: PPUSH
6728: CALL_OW 88
// end else
6732: GO 6849
// begin ComTurnUnit ( Frank , JMM ) ;
6734: LD_EXP 38
6738: PPUSH
6739: LD_EXP 24
6743: PPUSH
6744: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
6748: LD_EXP 38
6752: PPUSH
6753: LD_STRING D6-Frank-4
6755: PPUSH
6756: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
6760: LD_EXP 38
6764: PPUSH
6765: LD_STRING D6-Frank-4a
6767: PPUSH
6768: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
6772: LD_EXP 24
6776: PPUSH
6777: LD_STRING D6-JMM-4
6779: PPUSH
6780: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
6784: LD_EXP 38
6788: PPUSH
6789: LD_STRING D6-Frank-5
6791: PPUSH
6792: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
6796: LD_EXP 27
6800: PUSH
6801: LD_EXP 27
6805: PPUSH
6806: CALL_OW 302
6810: AND
6811: IFFALSE 6825
// Say ( Lisa , D6-Lisa-5 ) ;
6813: LD_EXP 27
6817: PPUSH
6818: LD_STRING D6-Lisa-5
6820: PPUSH
6821: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
6825: LD_EXP 38
6829: PPUSH
6830: LD_STRING D6-Frank-6
6832: PPUSH
6833: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
6837: LD_EXP 24
6841: PPUSH
6842: LD_STRING D6-JMM-6
6844: PPUSH
6845: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
6849: LD_STRING Q1
6851: PPUSH
6852: CALL_OW 97
6856: PUSH
6857: LD_INT 1
6859: DOUBLE
6860: EQUAL
6861: IFTRUE 6865
6863: GO 6876
6865: POP
// frank_send_to_scout := true ; 2 :
6866: LD_ADDR_EXP 12
6870: PUSH
6871: LD_INT 1
6873: ST_TO_ADDR
6874: GO 6896
6876: LD_INT 2
6878: DOUBLE
6879: EQUAL
6880: IFTRUE 6884
6882: GO 6895
6884: POP
// frank_send_to_scout := false ; end ;
6885: LD_ADDR_EXP 12
6889: PUSH
6890: LD_INT 0
6892: ST_TO_ADDR
6893: GO 6896
6895: POP
// InGameOff ;
6896: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
6900: LD_EXP 24
6904: PUSH
6905: LD_EXP 27
6909: PUSH
6910: LD_EXP 34
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: LIST
6919: PPUSH
6920: CALL_OW 139
// if frank_send_to_scout then
6924: LD_EXP 12
6928: IFFALSE 6985
// begin ComMoveXY ( Frank , 130 , 123 ) ;
6930: LD_EXP 38
6934: PPUSH
6935: LD_INT 130
6937: PPUSH
6938: LD_INT 123
6940: PPUSH
6941: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
6945: LD_INT 35
6947: PPUSH
6948: CALL_OW 67
// until not See ( 1 , Frank ) ;
6952: LD_INT 1
6954: PPUSH
6955: LD_EXP 38
6959: PPUSH
6960: CALL_OW 292
6964: NOT
6965: IFFALSE 6945
// Wait ( 0 0$02 ) ;
6967: LD_INT 70
6969: PPUSH
6970: CALL_OW 67
// RemoveUnit ( Frank ) ;
6974: LD_EXP 38
6978: PPUSH
6979: CALL_OW 64
// end else
6983: GO 6997
// SetSide ( Frank , 1 ) ;
6985: LD_EXP 38
6989: PPUSH
6990: LD_INT 1
6992: PPUSH
6993: CALL_OW 235
// Wait ( [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ) ;
6997: LD_INT 25200
6999: PUSH
7000: LD_INT 23100
7002: PUSH
7003: LD_INT 21000
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: LIST
7010: PUSH
7011: LD_OWVAR 67
7015: ARRAY
7016: PPUSH
7017: CALL_OW 67
// cornel_prepared := true ;
7021: LD_ADDR_EXP 9
7025: PUSH
7026: LD_INT 1
7028: ST_TO_ADDR
// end ;
7029: PPOPN 2
7031: END
// every 0 0$01 trigger cornel_prepared do
7032: LD_EXP 9
7036: IFFALSE 7256
7038: GO 7040
7040: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
7041: LD_EXP 31
7045: PPUSH
7046: LD_STRING D3-Corn-1
7048: PPUSH
7049: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
7053: LD_INT 35
7055: PPUSH
7056: CALL_OW 67
// until cornel_counter = 0 ;
7060: LD_EXP 8
7064: PUSH
7065: LD_INT 0
7067: EQUAL
7068: IFFALSE 7053
// SayRadio ( Cornel , D3a-Corn-1 ) ;
7070: LD_EXP 31
7074: PPUSH
7075: LD_STRING D3a-Corn-1
7077: PPUSH
7078: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
7082: LD_EXP 24
7086: PPUSH
7087: LD_STRING D3a-JMM-1
7089: PPUSH
7090: CALL_OW 88
// end_mission_allowed := true ;
7094: LD_ADDR_EXP 18
7098: PUSH
7099: LD_INT 1
7101: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
7102: LD_STRING M2
7104: PPUSH
7105: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
7109: LD_INT 9
7111: PPUSH
7112: LD_INT 1
7114: PPUSH
7115: CALL_OW 424
// Wait ( 0 0$05 ) ;
7119: LD_INT 175
7121: PPUSH
7122: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
7126: LD_EXP 31
7130: PPUSH
7131: LD_STRING D3a-Corn-2
7133: PPUSH
7134: CALL_OW 94
// cornel_attack := true ;
7138: LD_ADDR_EXP 7
7142: PUSH
7143: LD_INT 1
7145: ST_TO_ADDR
// if frank_send_to_scout then
7146: LD_EXP 12
7150: IFFALSE 7256
// begin InitHc ;
7152: CALL_OW 19
// InitUc ;
7156: CALL_OW 18
// uc_side := 8 ;
7160: LD_ADDR_OWVAR 20
7164: PUSH
7165: LD_INT 8
7167: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
7168: LD_ADDR_EXP 38
7172: PUSH
7173: LD_STRING Frank
7175: PPUSH
7176: LD_INT 0
7178: PPUSH
7179: CALL 353 0 2
7183: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
7184: LD_EXP 38
7188: PPUSH
7189: LD_INT 6
7191: PPUSH
7192: LD_INT 9
7194: PPUSH
7195: LD_INT 0
7197: PPUSH
7198: CALL_OW 48
// ComCrawl ( Frank ) ;
7202: LD_EXP 38
7206: PPUSH
7207: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
7211: LD_INT 35
7213: PPUSH
7214: CALL_OW 67
// until See ( 1 , Frank ) ;
7218: LD_INT 1
7220: PPUSH
7221: LD_EXP 38
7225: PPUSH
7226: CALL_OW 292
7230: IFFALSE 7211
// SetSide ( Frank , 1 ) ;
7232: LD_EXP 38
7236: PPUSH
7237: LD_INT 1
7239: PPUSH
7240: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
7244: LD_EXP 38
7248: PPUSH
7249: LD_STRING D6a-Frank-1
7251: PPUSH
7252: CALL_OW 88
// end ; end ;
7256: END
// every 0 0$01 trigger solar_builded do
7257: LD_EXP 11
7261: IFFALSE 7365
7263: GO 7265
7265: DISABLE
// begin Wait ( 0 0$02 ) ;
7266: LD_INT 70
7268: PPUSH
7269: CALL_OW 67
// DialogueOn ;
7273: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
7277: LD_EXP 24
7281: PPUSH
7282: LD_STRING D2b-JMM-1
7284: PPUSH
7285: CALL_OW 88
// if Walker and IsOk ( Walker ) then
7289: LD_EXP 35
7293: PUSH
7294: LD_EXP 35
7298: PPUSH
7299: CALL_OW 302
7303: AND
7304: IFFALSE 7354
// begin Say ( Walker , D2b-Sci1-1 ) ;
7306: LD_EXP 35
7310: PPUSH
7311: LD_STRING D2b-Sci1-1
7313: PPUSH
7314: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
7318: LD_EXP 24
7322: PPUSH
7323: LD_STRING D2b-JMM-2
7325: PPUSH
7326: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
7330: LD_EXP 35
7334: PPUSH
7335: LD_STRING D2b-Sci1-2
7337: PPUSH
7338: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
7342: LD_EXP 24
7346: PPUSH
7347: LD_STRING D2b-JMM-3
7349: PPUSH
7350: CALL_OW 88
// end ; DialogueOff ;
7354: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
7358: LD_STRING MOutSol
7360: PPUSH
7361: CALL_OW 337
// end ;
7365: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
7366: LD_EXP 11
7370: PUSH
7371: LD_EXP 24
7375: PPUSH
7376: CALL_OW 302
7380: AND
7381: PUSH
7382: LD_EXP 24
7386: PPUSH
7387: CALL 806 0 1
7391: AND
7392: PUSH
7393: LD_EXP 13
7397: NOT
7398: AND
7399: IFFALSE 7470
7401: GO 7403
7403: DISABLE
7404: LD_INT 0
7406: PPUSH
// begin jmm_in_veh := true ;
7407: LD_ADDR_EXP 13
7411: PUSH
7412: LD_INT 1
7414: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
7415: LD_ADDR_VAR 0 1
7419: PUSH
7420: LD_INT 0
7422: PPUSH
7423: LD_INT 1
7425: PPUSH
7426: CALL_OW 12
7430: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
7431: LD_INT 70
7433: PPUSH
7434: CALL_OW 67
// if i then
7438: LD_VAR 0 1
7442: IFFALSE 7458
// Say ( JMM , D2c-JMM-1 ) else
7444: LD_EXP 24
7448: PPUSH
7449: LD_STRING D2c-JMM-1
7451: PPUSH
7452: CALL_OW 88
7456: GO 7470
// Say ( JMM , D2c-JMM-1a ) ;
7458: LD_EXP 24
7462: PPUSH
7463: LD_STRING D2c-JMM-1a
7465: PPUSH
7466: CALL_OW 88
// end ;
7470: PPOPN 1
7472: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
7473: LD_EXP 11
7477: PUSH
7478: LD_EXP 25
7482: PPUSH
7483: CALL_OW 302
7487: AND
7488: PUSH
7489: LD_EXP 25
7493: PPUSH
7494: CALL 806 0 1
7498: AND
7499: PUSH
7500: LD_EXP 14
7504: NOT
7505: AND
7506: IFFALSE 7538
7508: GO 7510
7510: DISABLE
// begin bobby_in_veh := true ;
7511: LD_ADDR_EXP 14
7515: PUSH
7516: LD_INT 1
7518: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
7519: LD_INT 70
7521: PPUSH
7522: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
7526: LD_EXP 25
7530: PPUSH
7531: LD_STRING D2c-Bobby-1
7533: PPUSH
7534: CALL_OW 88
7538: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
7539: LD_EXP 11
7543: PUSH
7544: LD_EXP 27
7548: PPUSH
7549: CALL_OW 302
7553: AND
7554: PUSH
7555: LD_EXP 27
7559: PPUSH
7560: CALL 806 0 1
7564: AND
7565: PUSH
7566: LD_EXP 16
7570: NOT
7571: AND
7572: IFFALSE 7604
7574: GO 7576
7576: DISABLE
// begin lisa_in_veh := true ;
7577: LD_ADDR_EXP 16
7581: PUSH
7582: LD_INT 1
7584: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
7585: LD_INT 70
7587: PPUSH
7588: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
7592: LD_EXP 27
7596: PPUSH
7597: LD_STRING D2c-Lisa-1
7599: PPUSH
7600: CALL_OW 88
7604: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
7605: LD_EXP 11
7609: PUSH
7610: LD_EXP 26
7614: PPUSH
7615: CALL_OW 302
7619: AND
7620: PUSH
7621: LD_EXP 26
7625: PPUSH
7626: CALL 806 0 1
7630: AND
7631: PUSH
7632: LD_EXP 15
7636: NOT
7637: AND
7638: IFFALSE 7709
7640: GO 7642
7642: DISABLE
7643: LD_INT 0
7645: PPUSH
// begin cyrus_in_veh := true ;
7646: LD_ADDR_EXP 15
7650: PUSH
7651: LD_INT 1
7653: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
7654: LD_ADDR_VAR 0 1
7658: PUSH
7659: LD_INT 0
7661: PPUSH
7662: LD_INT 1
7664: PPUSH
7665: CALL_OW 12
7669: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
7670: LD_INT 70
7672: PPUSH
7673: CALL_OW 67
// if i then
7677: LD_VAR 0 1
7681: IFFALSE 7697
// Say ( Cyrus , D2c-Cyrus-1 ) else
7683: LD_EXP 26
7687: PPUSH
7688: LD_STRING D2c-Cyrus-1
7690: PPUSH
7691: CALL_OW 88
7695: GO 7709
// Say ( Cyrus , D2c-Cyrus-1a ) ;
7697: LD_EXP 26
7701: PPUSH
7702: LD_STRING D2c-Cyrus-1a
7704: PPUSH
7705: CALL_OW 88
// end ;
7709: PPOPN 1
7711: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) do var i , filter ;
7712: LD_INT 9
7714: PPUSH
7715: LD_INT 22
7717: PUSH
7718: LD_INT 1
7720: PUSH
7721: EMPTY
7722: LIST
7723: LIST
7724: PPUSH
7725: CALL_OW 70
7729: IFFALSE 8445
7731: GO 7733
7733: DISABLE
7734: LD_INT 0
7736: PPUSH
7737: PPUSH
// begin enable ;
7738: ENABLE
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
7739: LD_ADDR_VAR 0 2
7743: PUSH
7744: LD_INT 9
7746: PPUSH
7747: LD_INT 22
7749: PUSH
7750: LD_INT 1
7752: PUSH
7753: EMPTY
7754: LIST
7755: LIST
7756: PPUSH
7757: CALL_OW 70
7761: ST_TO_ADDR
// if not filter then
7762: LD_VAR 0 2
7766: NOT
7767: IFFALSE 7771
// exit ;
7769: GO 8445
// for i in filter do
7771: LD_ADDR_VAR 0 1
7775: PUSH
7776: LD_VAR 0 2
7780: PUSH
7781: FOR_IN
7782: IFFALSE 8443
// begin if i = JMM then
7784: LD_VAR 0 1
7788: PUSH
7789: LD_EXP 24
7793: EQUAL
7794: IFFALSE 7927
// begin if show_query then
7796: LD_EXP 21
7800: IFFALSE 7857
// begin show_query := false ;
7802: LD_ADDR_EXP 21
7806: PUSH
7807: LD_INT 0
7809: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
7810: LD_STRING Q2
7812: PPUSH
7813: CALL_OW 97
7817: PUSH
7818: LD_INT 1
7820: DOUBLE
7821: EQUAL
7822: IFTRUE 7826
7824: GO 7837
7826: POP
// wait_for_them := true ; 2 :
7827: LD_ADDR_EXP 22
7831: PUSH
7832: LD_INT 1
7834: ST_TO_ADDR
7835: GO 7857
7837: LD_INT 2
7839: DOUBLE
7840: EQUAL
7841: IFTRUE 7845
7843: GO 7856
7845: POP
// wait_for_them := false ; end ;
7846: LD_ADDR_EXP 22
7850: PUSH
7851: LD_INT 0
7853: ST_TO_ADDR
7854: GO 7857
7856: POP
// end ; if not wait_for_them or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 1 then
7857: LD_EXP 22
7861: NOT
7862: PUSH
7863: LD_INT 22
7865: PUSH
7866: LD_INT 1
7868: PUSH
7869: EMPTY
7870: LIST
7871: LIST
7872: PUSH
7873: LD_INT 21
7875: PUSH
7876: LD_INT 1
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PPUSH
7887: CALL_OW 69
7891: PUSH
7892: LD_INT 1
7894: EQUAL
7895: OR
7896: IFFALSE 7927
// begin save_group := save_group ^ JMM ;
7898: LD_ADDR_EXP 20
7902: PUSH
7903: LD_EXP 20
7907: PUSH
7908: LD_EXP 24
7912: ADD
7913: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
7914: LD_EXP 24
7918: PPUSH
7919: CALL_OW 64
// EndMission ;
7923: CALL 8448 0 0
// end ; end ; if i = Lisa then
7927: LD_VAR 0 1
7931: PUSH
7932: LD_EXP 27
7936: EQUAL
7937: IFFALSE 7964
// begin save_group := save_group ^ Lisa ;
7939: LD_ADDR_EXP 20
7943: PUSH
7944: LD_EXP 20
7948: PUSH
7949: LD_EXP 27
7953: ADD
7954: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
7955: LD_EXP 27
7959: PPUSH
7960: CALL_OW 64
// end ; if i = Bobby then
7964: LD_VAR 0 1
7968: PUSH
7969: LD_EXP 25
7973: EQUAL
7974: IFFALSE 8001
// begin save_group := save_group ^ Bobby ;
7976: LD_ADDR_EXP 20
7980: PUSH
7981: LD_EXP 20
7985: PUSH
7986: LD_EXP 25
7990: ADD
7991: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
7992: LD_EXP 25
7996: PPUSH
7997: CALL_OW 64
// end ; if i = Cyrus then
8001: LD_VAR 0 1
8005: PUSH
8006: LD_EXP 26
8010: EQUAL
8011: IFFALSE 8038
// begin save_group := save_group ^ Cyrus ;
8013: LD_ADDR_EXP 20
8017: PUSH
8018: LD_EXP 20
8022: PUSH
8023: LD_EXP 26
8027: ADD
8028: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
8029: LD_EXP 26
8033: PPUSH
8034: CALL_OW 64
// end ; if i = Khatam then
8038: LD_VAR 0 1
8042: PUSH
8043: LD_EXP 28
8047: EQUAL
8048: IFFALSE 8075
// begin save_group := save_group ^ Khatam ;
8050: LD_ADDR_EXP 20
8054: PUSH
8055: LD_EXP 20
8059: PUSH
8060: LD_EXP 28
8064: ADD
8065: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
8066: LD_EXP 28
8070: PPUSH
8071: CALL_OW 64
// end ; if i = Jerry then
8075: LD_VAR 0 1
8079: PUSH
8080: LD_EXP 30
8084: EQUAL
8085: IFFALSE 8112
// begin save_group := save_group ^ Jerry ;
8087: LD_ADDR_EXP 20
8091: PUSH
8092: LD_EXP 20
8096: PUSH
8097: LD_EXP 30
8101: ADD
8102: ST_TO_ADDR
// RemoveUnit ( Jerry ) ;
8103: LD_EXP 30
8107: PPUSH
8108: CALL_OW 64
// end ; if i = Brian then
8112: LD_VAR 0 1
8116: PUSH
8117: LD_EXP 29
8121: EQUAL
8122: IFFALSE 8149
// begin save_group := save_group ^ Brian ;
8124: LD_ADDR_EXP 20
8128: PUSH
8129: LD_EXP 20
8133: PUSH
8134: LD_EXP 29
8138: ADD
8139: ST_TO_ADDR
// RemoveUnit ( Brian ) ;
8140: LD_EXP 29
8144: PPUSH
8145: CALL_OW 64
// end ; if i = Lynch then
8149: LD_VAR 0 1
8153: PUSH
8154: LD_EXP 34
8158: EQUAL
8159: IFFALSE 8186
// begin save_group := save_group ^ Lynch ;
8161: LD_ADDR_EXP 20
8165: PUSH
8166: LD_EXP 20
8170: PUSH
8171: LD_EXP 34
8175: ADD
8176: ST_TO_ADDR
// RemoveUnit ( Lynch ) ;
8177: LD_EXP 34
8181: PPUSH
8182: CALL_OW 64
// end ; if i = Turner then
8186: LD_VAR 0 1
8190: PUSH
8191: LD_EXP 36
8195: EQUAL
8196: IFFALSE 8223
// begin save_group := save_group ^ Turner ;
8198: LD_ADDR_EXP 20
8202: PUSH
8203: LD_EXP 20
8207: PUSH
8208: LD_EXP 36
8212: ADD
8213: ST_TO_ADDR
// RemoveUnit ( Turner ) ;
8214: LD_EXP 36
8218: PPUSH
8219: CALL_OW 64
// end ; if i = Jillian then
8223: LD_VAR 0 1
8227: PUSH
8228: LD_EXP 37
8232: EQUAL
8233: IFFALSE 8260
// begin save_group := save_group ^ Jillian ;
8235: LD_ADDR_EXP 20
8239: PUSH
8240: LD_EXP 20
8244: PUSH
8245: LD_EXP 37
8249: ADD
8250: ST_TO_ADDR
// RemoveUnit ( Jillian ) ;
8251: LD_EXP 37
8255: PPUSH
8256: CALL_OW 64
// end ; if i = Walker then
8260: LD_VAR 0 1
8264: PUSH
8265: LD_EXP 35
8269: EQUAL
8270: IFFALSE 8297
// begin save_group := save_group ^ Walker ;
8272: LD_ADDR_EXP 20
8276: PUSH
8277: LD_EXP 20
8281: PUSH
8282: LD_EXP 35
8286: ADD
8287: ST_TO_ADDR
// RemoveUnit ( Walker ) ;
8288: LD_EXP 35
8292: PPUSH
8293: CALL_OW 64
// end ; if i = Frank then
8297: LD_VAR 0 1
8301: PUSH
8302: LD_EXP 38
8306: EQUAL
8307: IFFALSE 8334
// begin save_group := save_group ^ Frank ;
8309: LD_ADDR_EXP 20
8313: PUSH
8314: LD_EXP 20
8318: PUSH
8319: LD_EXP 38
8323: ADD
8324: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
8325: LD_EXP 38
8329: PPUSH
8330: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and not i in save_group then
8334: LD_VAR 0 1
8338: PPUSH
8339: CALL_OW 302
8343: PUSH
8344: LD_VAR 0 1
8348: PPUSH
8349: CALL_OW 247
8353: PUSH
8354: LD_INT 1
8356: EQUAL
8357: AND
8358: PUSH
8359: LD_VAR 0 1
8363: PUSH
8364: LD_EXP 20
8368: IN
8369: NOT
8370: AND
8371: IFFALSE 8398
// begin save_others := save_others ^ i ;
8373: LD_ADDR_EXP 19
8377: PUSH
8378: LD_EXP 19
8382: PUSH
8383: LD_VAR 0 1
8387: ADD
8388: ST_TO_ADDR
// RemoveUnit ( i ) ;
8389: LD_VAR 0 1
8393: PPUSH
8394: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_vehicle then
8398: LD_VAR 0 1
8402: PPUSH
8403: CALL_OW 302
8407: PUSH
8408: LD_VAR 0 1
8412: PPUSH
8413: CALL_OW 247
8417: PUSH
8418: LD_INT 2
8420: EQUAL
8421: AND
8422: IFFALSE 8441
// begin veh_on_meta := true ;
8424: LD_ADDR_EXP 23
8428: PUSH
8429: LD_INT 1
8431: ST_TO_ADDR
// RemoveUnit ( i ) ;
8432: LD_VAR 0 1
8436: PPUSH
8437: CALL_OW 64
// end ; end ;
8441: GO 7781
8443: POP
8444: POP
// end ;
8445: PPOPN 2
8447: END
// export function EndMission ; var counter ; begin
8448: LD_INT 0
8450: PPUSH
8451: PPUSH
// if solar_builded then
8452: LD_EXP 11
8456: IFFALSE 8470
// AddMedal ( Solar1 , 1 ) else
8458: LD_STRING Solar1
8460: PPUSH
8461: LD_INT 1
8463: PPUSH
8464: CALL_OW 101
8468: GO 8481
// AddMedal ( Solar1 , - 1 ) ;
8470: LD_STRING Solar1
8472: PPUSH
8473: LD_INT 1
8475: NEG
8476: PPUSH
8477: CALL_OW 101
// if veh_on_meta then
8481: LD_EXP 23
8485: IFFALSE 8499
// AddMedal ( Solar2 , 1 ) else
8487: LD_STRING Solar2
8489: PPUSH
8490: LD_INT 1
8492: PPUSH
8493: CALL_OW 101
8497: GO 8529
// if solar_builded then
8499: LD_EXP 11
8503: IFFALSE 8518
// AddMedal ( Solar2 , - 1 ) else
8505: LD_STRING Solar2
8507: PPUSH
8508: LD_INT 1
8510: NEG
8511: PPUSH
8512: CALL_OW 101
8516: GO 8529
// AddMedal ( Solar2 , - 2 ) ;
8518: LD_STRING Solar2
8520: PPUSH
8521: LD_INT 2
8523: NEG
8524: PPUSH
8525: CALL_OW 101
// counter := save_group ^ save_others ;
8529: LD_ADDR_VAR 0 2
8533: PUSH
8534: LD_EXP 20
8538: PUSH
8539: LD_EXP 19
8543: ADD
8544: ST_TO_ADDR
// if counter = 10 then
8545: LD_VAR 0 2
8549: PUSH
8550: LD_INT 10
8552: EQUAL
8553: IFFALSE 8567
// AddMedal ( No , 1 ) else
8555: LD_STRING No
8557: PPUSH
8558: LD_INT 1
8560: PPUSH
8561: CALL_OW 101
8565: GO 8611
// if counter < 10 and counter > 6 then
8567: LD_VAR 0 2
8571: PUSH
8572: LD_INT 10
8574: LESS
8575: PUSH
8576: LD_VAR 0 2
8580: PUSH
8581: LD_INT 6
8583: GREATER
8584: AND
8585: IFFALSE 8600
// AddMedal ( No , - 1 ) else
8587: LD_STRING No
8589: PPUSH
8590: LD_INT 1
8592: NEG
8593: PPUSH
8594: CALL_OW 101
8598: GO 8611
// AddMedal ( UpTo4 , - 1 ) ;
8600: LD_STRING UpTo4
8602: PPUSH
8603: LD_INT 1
8605: NEG
8606: PPUSH
8607: CALL_OW 101
// GiveMedals ( MAIN ) ;
8611: LD_STRING MAIN
8613: PPUSH
8614: CALL_OW 102
// RewardPeople ( save_group ^ save_others ) ;
8618: LD_EXP 20
8622: PUSH
8623: LD_EXP 19
8627: ADD
8628: PPUSH
8629: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
8633: LD_EXP 24
8637: PPUSH
8638: LD_STRING JMM
8640: PPUSH
8641: CALL_OW 38
// if Bobby in save_group then
8645: LD_EXP 25
8649: PUSH
8650: LD_EXP 20
8654: IN
8655: IFFALSE 8669
// SaveCharacters ( Bobby , Bobby ) ;
8657: LD_EXP 25
8661: PPUSH
8662: LD_STRING Bobby
8664: PPUSH
8665: CALL_OW 38
// if Cyrus in save_group then
8669: LD_EXP 26
8673: PUSH
8674: LD_EXP 20
8678: IN
8679: IFFALSE 8693
// SaveCharacters ( Cyrus , Cyrus ) ;
8681: LD_EXP 26
8685: PPUSH
8686: LD_STRING Cyrus
8688: PPUSH
8689: CALL_OW 38
// if Lisa in save_group then
8693: LD_EXP 27
8697: PUSH
8698: LD_EXP 20
8702: IN
8703: IFFALSE 8717
// SaveCharacters ( Lisa , Lisa ) ;
8705: LD_EXP 27
8709: PPUSH
8710: LD_STRING Lisa
8712: PPUSH
8713: CALL_OW 38
// if Frank in save_group then
8717: LD_EXP 38
8721: PUSH
8722: LD_EXP 20
8726: IN
8727: IFFALSE 8741
// SaveCharacters ( Frank , Frank ) ;
8729: LD_EXP 38
8733: PPUSH
8734: LD_STRING Frank
8736: PPUSH
8737: CALL_OW 38
// if Khatam in save_group then
8741: LD_EXP 28
8745: PUSH
8746: LD_EXP 20
8750: IN
8751: IFFALSE 8765
// SaveCharacters ( Khatam , Khatam ) ;
8753: LD_EXP 28
8757: PPUSH
8758: LD_STRING Khatam
8760: PPUSH
8761: CALL_OW 38
// if save_others then
8765: LD_EXP 19
8769: IFFALSE 8783
// SaveCharacters ( save_others , 03_others ) ;
8771: LD_EXP 19
8775: PPUSH
8776: LD_STRING 03_others
8778: PPUSH
8779: CALL_OW 38
// YouWin ;
8783: CALL_OW 103
// end ; end_of_file
8787: LD_VAR 0 1
8791: RET
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
8792: LD_EXP 6
8796: IFFALSE 9792
8798: GO 8800
8800: DISABLE
8801: LD_INT 0
8803: PPUSH
8804: PPUSH
8805: PPUSH
8806: PPUSH
8807: PPUSH
8808: PPUSH
8809: PPUSH
8810: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
8811: LD_EXP 31
8815: PUSH
8816: LD_EXP 32
8820: ADD
8821: PUSH
8822: LD_EXP 4
8826: ADD
8827: PPUSH
8828: LD_INT 250
8830: PPUSH
8831: LD_INT 120
8833: PPUSH
8834: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
8838: LD_ADDR_VAR 0 2
8842: PUSH
8843: LD_EXP 4
8847: PPUSH
8848: LD_INT 25
8850: PUSH
8851: LD_INT 2
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PPUSH
8858: CALL_OW 72
8862: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
8863: LD_ADDR_VAR 0 3
8867: PUSH
8868: LD_EXP 4
8872: PPUSH
8873: LD_INT 21
8875: PUSH
8876: LD_INT 1
8878: PUSH
8879: EMPTY
8880: LIST
8881: LIST
8882: PPUSH
8883: CALL_OW 72
8887: ST_TO_ADDR
// if not has_eng then
8888: LD_VAR 0 2
8892: NOT
8893: IFFALSE 8976
// begin uc_side := 4 ;
8895: LD_ADDR_OWVAR 20
8899: PUSH
8900: LD_INT 4
8902: ST_TO_ADDR
// uc_nation := 1 ;
8903: LD_ADDR_OWVAR 21
8907: PUSH
8908: LD_INT 1
8910: ST_TO_ADDR
// bc_type := b_depot ;
8911: LD_ADDR_OWVAR 42
8915: PUSH
8916: LD_INT 0
8918: ST_TO_ADDR
// bc_level := 2 ;
8919: LD_ADDR_OWVAR 43
8923: PUSH
8924: LD_INT 2
8926: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
8927: LD_ADDR_VAR 0 4
8931: PUSH
8932: LD_INT 264
8934: PPUSH
8935: LD_INT 120
8937: PPUSH
8938: LD_INT 4
8940: PPUSH
8941: CALL_OW 47
8945: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
8946: LD_INT 264
8948: PPUSH
8949: LD_INT 120
8951: PPUSH
8952: LD_INT 4
8954: PPUSH
8955: LD_INT 10
8957: NEG
8958: PPUSH
8959: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
8963: LD_INT 264
8965: PPUSH
8966: LD_INT 120
8968: PPUSH
8969: LD_INT 4
8971: PPUSH
8972: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
8976: LD_INT 35
8978: PPUSH
8979: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
8983: LD_EXP 31
8987: PPUSH
8988: LD_INT 10
8990: PPUSH
8991: CALL_OW 308
8995: IFFALSE 8976
// if has_eng and not dep then
8997: LD_VAR 0 2
9001: PUSH
9002: LD_VAR 0 4
9006: NOT
9007: AND
9008: IFFALSE 9122
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
9010: LD_VAR 0 2
9014: PPUSH
9015: LD_INT 0
9017: PPUSH
9018: LD_INT 264
9020: PPUSH
9021: LD_INT 120
9023: PPUSH
9024: LD_INT 4
9026: PPUSH
9027: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
9031: LD_INT 35
9033: PPUSH
9034: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
9038: LD_INT 22
9040: PUSH
9041: LD_INT 4
9043: PUSH
9044: EMPTY
9045: LIST
9046: LIST
9047: PUSH
9048: LD_INT 30
9050: PUSH
9051: LD_INT 0
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: PUSH
9058: LD_INT 3
9060: PUSH
9061: LD_INT 57
9063: PUSH
9064: EMPTY
9065: LIST
9066: PUSH
9067: EMPTY
9068: LIST
9069: LIST
9070: PUSH
9071: EMPTY
9072: LIST
9073: LIST
9074: LIST
9075: PPUSH
9076: CALL_OW 69
9080: IFFALSE 9031
// dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
9082: LD_ADDR_VAR 0 4
9086: PUSH
9087: LD_INT 22
9089: PUSH
9090: LD_INT 4
9092: PUSH
9093: EMPTY
9094: LIST
9095: LIST
9096: PUSH
9097: LD_INT 30
9099: PUSH
9100: LD_INT 0
9102: PUSH
9103: EMPTY
9104: LIST
9105: LIST
9106: PUSH
9107: EMPTY
9108: LIST
9109: LIST
9110: PPUSH
9111: CALL_OW 69
9115: PUSH
9116: LD_INT 1
9118: ARRAY
9119: ST_TO_ADDR
// end else
9120: GO 9239
// begin SetSide ( dep , 4 ) ;
9122: LD_VAR 0 4
9126: PPUSH
9127: LD_INT 4
9129: PPUSH
9130: CALL_OW 235
// for i = 1 to 3 do
9134: LD_ADDR_VAR 0 1
9138: PUSH
9139: DOUBLE
9140: LD_INT 1
9142: DEC
9143: ST_TO_ADDR
9144: LD_INT 3
9146: PUSH
9147: FOR_TO
9148: IFFALSE 9205
// begin ComEnterUnit ( filter [ i ] , dep ) ;
9150: LD_VAR 0 3
9154: PUSH
9155: LD_VAR 0 1
9159: ARRAY
9160: PPUSH
9161: LD_VAR 0 4
9165: PPUSH
9166: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
9170: LD_VAR 0 3
9174: PUSH
9175: LD_VAR 0 1
9179: ARRAY
9180: PPUSH
9181: LD_INT 2
9183: PPUSH
9184: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
9188: LD_VAR 0 3
9192: PUSH
9193: LD_VAR 0 1
9197: ARRAY
9198: PPUSH
9199: CALL_OW 182
// end ;
9203: GO 9147
9205: POP
9206: POP
// repeat wait ( 0 0$01 ) ;
9207: LD_INT 35
9209: PPUSH
9210: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
9214: LD_VAR 0 3
9218: PPUSH
9219: LD_INT 25
9221: PUSH
9222: LD_INT 2
9224: PUSH
9225: EMPTY
9226: LIST
9227: LIST
9228: PPUSH
9229: CALL_OW 72
9233: PUSH
9234: LD_INT 3
9236: EQUAL
9237: IFFALSE 9207
// end ; ComEnterUnit ( Bierezov , dep ) ;
9239: LD_EXP 32
9243: PPUSH
9244: LD_VAR 0 4
9248: PPUSH
9249: CALL_OW 120
// if IsInUnit ( Cornel ) then
9253: LD_EXP 31
9257: PPUSH
9258: CALL_OW 310
9262: IFFALSE 9345
// begin cargo := IsInUnit ( Cornel ) ;
9264: LD_ADDR_VAR 0 7
9268: PUSH
9269: LD_EXP 31
9273: PPUSH
9274: CALL_OW 310
9278: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
9279: LD_VAR 0 7
9283: PPUSH
9284: LD_INT 1
9286: PPUSH
9287: CALL_OW 289
9291: IFFALSE 9307
// ComGive ( Cornel , dep ) ;
9293: LD_EXP 31
9297: PPUSH
9298: LD_VAR 0 4
9302: PPUSH
9303: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
9307: LD_EXP 31
9311: PPUSH
9312: LD_INT 235
9314: PPUSH
9315: LD_INT 122
9317: PPUSH
9318: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
9322: LD_EXP 31
9326: PPUSH
9327: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
9331: LD_EXP 31
9335: PPUSH
9336: LD_VAR 0 4
9340: PPUSH
9341: CALL_OW 180
// end ; has_eng := UnitFilter ( filter , [ f_class , 2 ] ) ;
9345: LD_ADDR_VAR 0 2
9349: PUSH
9350: LD_VAR 0 3
9354: PPUSH
9355: LD_INT 25
9357: PUSH
9358: LD_INT 2
9360: PUSH
9361: EMPTY
9362: LIST
9363: LIST
9364: PPUSH
9365: CALL_OW 72
9369: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9370: LD_INT 35
9372: PPUSH
9373: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
9377: LD_ADDR_VAR 0 6
9381: PUSH
9382: LD_INT 10
9384: PPUSH
9385: CALL_OW 435
9389: ST_TO_ADDR
// if crates then
9390: LD_VAR 0 6
9394: IFFALSE 9423
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
9396: LD_VAR 0 2
9400: PPUSH
9401: LD_VAR 0 6
9405: PUSH
9406: LD_INT 1
9408: ARRAY
9409: PPUSH
9410: LD_VAR 0 6
9414: PUSH
9415: LD_INT 2
9417: ARRAY
9418: PPUSH
9419: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 100 ;
9423: LD_VAR 0 4
9427: PPUSH
9428: CALL_OW 274
9432: PPUSH
9433: LD_INT 1
9435: PPUSH
9436: CALL_OW 275
9440: PUSH
9441: LD_INT 100
9443: GREATEREQUAL
9444: IFFALSE 9370
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
9446: LD_ADDR_VAR 0 5
9450: PUSH
9451: LD_INT 4
9453: PUSH
9454: LD_INT 256
9456: PUSH
9457: LD_INT 111
9459: PUSH
9460: LD_INT 2
9462: PUSH
9463: EMPTY
9464: LIST
9465: LIST
9466: LIST
9467: LIST
9468: PUSH
9469: LD_INT 31
9471: PUSH
9472: LD_INT 243
9474: PUSH
9475: LD_INT 112
9477: PUSH
9478: LD_INT 2
9480: PUSH
9481: EMPTY
9482: LIST
9483: LIST
9484: LIST
9485: LIST
9486: PUSH
9487: EMPTY
9488: LIST
9489: LIST
9490: ST_TO_ADDR
// for i in blist do
9491: LD_ADDR_VAR 0 1
9495: PUSH
9496: LD_VAR 0 5
9500: PUSH
9501: FOR_IN
9502: IFFALSE 9551
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
9504: LD_VAR 0 2
9508: PPUSH
9509: LD_VAR 0 1
9513: PUSH
9514: LD_INT 1
9516: ARRAY
9517: PPUSH
9518: LD_VAR 0 1
9522: PUSH
9523: LD_INT 2
9525: ARRAY
9526: PPUSH
9527: LD_VAR 0 1
9531: PUSH
9532: LD_INT 3
9534: ARRAY
9535: PPUSH
9536: LD_VAR 0 1
9540: PUSH
9541: LD_INT 4
9543: ARRAY
9544: PPUSH
9545: CALL_OW 205
9549: GO 9501
9551: POP
9552: POP
// repeat wait ( 0 0$01 ) ;
9553: LD_INT 35
9555: PPUSH
9556: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
9560: LD_INT 22
9562: PUSH
9563: LD_INT 4
9565: PUSH
9566: EMPTY
9567: LIST
9568: LIST
9569: PUSH
9570: LD_INT 30
9572: PUSH
9573: LD_INT 4
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: PUSH
9580: LD_INT 3
9582: PUSH
9583: LD_INT 57
9585: PUSH
9586: EMPTY
9587: LIST
9588: PUSH
9589: EMPTY
9590: LIST
9591: LIST
9592: PUSH
9593: EMPTY
9594: LIST
9595: LIST
9596: LIST
9597: PPUSH
9598: CALL_OW 69
9602: IFFALSE 9553
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
9604: LD_VAR 0 3
9608: PUSH
9609: LD_VAR 0 2
9613: DIFF
9614: PPUSH
9615: LD_INT 22
9617: PUSH
9618: LD_INT 4
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: PUSH
9625: LD_INT 30
9627: PUSH
9628: LD_INT 4
9630: PUSH
9631: EMPTY
9632: LIST
9633: LIST
9634: PUSH
9635: EMPTY
9636: LIST
9637: LIST
9638: PPUSH
9639: CALL_OW 69
9643: PUSH
9644: LD_INT 1
9646: ARRAY
9647: PPUSH
9648: CALL_OW 180
// repeat wait ( 0 0$01 ) ;
9652: LD_INT 35
9654: PPUSH
9655: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
9659: LD_INT 22
9661: PUSH
9662: LD_INT 4
9664: PUSH
9665: EMPTY
9666: LIST
9667: LIST
9668: PUSH
9669: LD_INT 30
9671: PUSH
9672: LD_INT 31
9674: PUSH
9675: EMPTY
9676: LIST
9677: LIST
9678: PUSH
9679: LD_INT 3
9681: PUSH
9682: LD_INT 57
9684: PUSH
9685: EMPTY
9686: LIST
9687: PUSH
9688: EMPTY
9689: LIST
9690: LIST
9691: PUSH
9692: EMPTY
9693: LIST
9694: LIST
9695: LIST
9696: PPUSH
9697: CALL_OW 69
9701: IFFALSE 9652
// sol := filter diff has_eng ;
9703: LD_ADDR_VAR 0 8
9707: PUSH
9708: LD_VAR 0 3
9712: PUSH
9713: LD_VAR 0 2
9717: DIFF
9718: ST_TO_ADDR
// ComExitBuilding ( sol [ 1 ] ) ;
9719: LD_VAR 0 8
9723: PUSH
9724: LD_INT 1
9726: ARRAY
9727: PPUSH
9728: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
9732: LD_VAR 0 8
9736: PUSH
9737: LD_INT 1
9739: ARRAY
9740: PPUSH
9741: LD_INT 22
9743: PUSH
9744: LD_INT 4
9746: PUSH
9747: EMPTY
9748: LIST
9749: LIST
9750: PUSH
9751: LD_INT 30
9753: PUSH
9754: LD_INT 31
9756: PUSH
9757: EMPTY
9758: LIST
9759: LIST
9760: PUSH
9761: EMPTY
9762: LIST
9763: LIST
9764: PPUSH
9765: CALL_OW 69
9769: PUSH
9770: LD_INT 1
9772: ARRAY
9773: PPUSH
9774: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
9778: LD_VAR 0 2
9782: PPUSH
9783: LD_VAR 0 4
9787: PPUSH
9788: CALL_OW 112
// end ;
9792: PPOPN 8
9794: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
9795: LD_EXP 9
9799: IFFALSE 10119
9801: GO 9803
9803: DISABLE
9804: LD_INT 0
9806: PPUSH
9807: PPUSH
9808: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
9809: LD_ADDR_VAR 0 2
9813: PUSH
9814: LD_INT 22
9816: PUSH
9817: LD_INT 4
9819: PUSH
9820: EMPTY
9821: LIST
9822: LIST
9823: PUSH
9824: LD_INT 30
9826: PUSH
9827: LD_INT 4
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PUSH
9834: EMPTY
9835: LIST
9836: LIST
9837: PPUSH
9838: CALL_OW 69
9842: PUSH
9843: LD_INT 1
9845: ARRAY
9846: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
9847: LD_EXP 4
9851: PPUSH
9852: CALL_OW 122
// for i in cornel_units do
9856: LD_ADDR_VAR 0 1
9860: PUSH
9861: LD_EXP 4
9865: PUSH
9866: FOR_IN
9867: IFFALSE 9921
// if GetClass ( i ) = 2 then
9869: LD_VAR 0 1
9873: PPUSH
9874: CALL_OW 257
9878: PUSH
9879: LD_INT 2
9881: EQUAL
9882: IFFALSE 9919
// begin ComEnterUnit ( i , arm ) ;
9884: LD_VAR 0 1
9888: PPUSH
9889: LD_VAR 0 2
9893: PPUSH
9894: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
9898: LD_VAR 0 1
9902: PPUSH
9903: LD_INT 1
9905: PPUSH
9906: CALL_OW 183
// AddComExitBuilding ( i ) ;
9910: LD_VAR 0 1
9914: PPUSH
9915: CALL_OW 182
// end ;
9919: GO 9866
9921: POP
9922: POP
// Wait ( 1 1$00 ) ;
9923: LD_INT 2100
9925: PPUSH
9926: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
9930: LD_ADDR_VAR 0 3
9934: PUSH
9935: LD_EXP 31
9939: PUSH
9940: LD_EXP 32
9944: ADD
9945: PUSH
9946: LD_EXP 4
9950: ADD
9951: PUSH
9952: LD_EXP 4
9956: PPUSH
9957: LD_INT 21
9959: PUSH
9960: LD_INT 2
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: PPUSH
9967: CALL_OW 72
9971: DIFF
9972: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
9973: LD_VAR 0 3
9977: PPUSH
9978: LD_INT 248
9980: PPUSH
9981: LD_INT 85
9983: PPUSH
9984: CALL_OW 111
// AddComHold ( filter ) ;
9988: LD_VAR 0 3
9992: PPUSH
9993: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
9997: LD_INT 35
9999: PPUSH
10000: CALL_OW 67
// until cornel_attack ;
10004: LD_EXP 7
10008: IFFALSE 9997
// ComAgressiveMove ( filter , 209 , 63 ) ;
10010: LD_VAR 0 3
10014: PPUSH
10015: LD_INT 209
10017: PPUSH
10018: LD_INT 63
10020: PPUSH
10021: CALL_OW 114
// if Bierezov then
10025: LD_EXP 32
10029: IFFALSE 10119
// begin filter := filter diff Bierezov ;
10031: LD_ADDR_VAR 0 3
10035: PUSH
10036: LD_VAR 0 3
10040: PUSH
10041: LD_EXP 32
10045: DIFF
10046: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
10047: LD_EXP 32
10051: PPUSH
10052: LD_INT 6
10054: PPUSH
10055: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
10059: LD_EXP 32
10063: PPUSH
10064: LD_INT 235
10066: PPUSH
10067: LD_INT 60
10069: PPUSH
10070: CALL_OW 111
// AddComHold ( Bierezov ) ;
10074: LD_EXP 32
10078: PPUSH
10079: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
10083: LD_EXP 32
10087: PPUSH
10088: LD_INT 350
10090: PPUSH
10091: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
10095: LD_EXP 32
10099: PPUSH
10100: LD_INT 198
10102: PPUSH
10103: LD_INT 28
10105: PPUSH
10106: CALL_OW 171
// AddComHold ( Bierezov ) ;
10110: LD_EXP 32
10114: PPUSH
10115: CALL_OW 200
// end ; end ; end_of_file end_of_file
10119: PPOPN 3
10121: END
// every 0 0$50 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
10122: LD_EXP 3
10126: PUSH
10127: LD_EXP 7
10131: NOT
10132: AND
10133: PUSH
10134: LD_EXP 17
10138: AND
10139: IFFALSE 10251
10141: GO 10143
10143: DISABLE
10144: LD_INT 0
10146: PPUSH
// begin enable ;
10147: ENABLE
// crates_counter := crates_counter - 50 ;
10148: LD_ADDR_EXP 17
10152: PUSH
10153: LD_EXP 17
10157: PUSH
10158: LD_INT 50
10160: MINUS
10161: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
10162: LD_INT 8
10164: PPUSH
10165: LD_INT 2
10167: PPUSH
10168: LD_INT 5
10170: PPUSH
10171: CALL_OW 12
10175: PPUSH
10176: LD_INT 1
10178: PPUSH
10179: CALL_OW 55
// Wait ( Rand ( 0 0$11 , 0 0$37 ) ) ;
10183: LD_INT 385
10185: PPUSH
10186: LD_INT 1295
10188: PPUSH
10189: CALL_OW 12
10193: PPUSH
10194: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
10198: LD_ADDR_VAR 0 1
10202: PUSH
10203: LD_INT 1
10205: PPUSH
10206: LD_OWVAR 67
10210: PUSH
10211: LD_INT 2
10213: PLUS
10214: PPUSH
10215: CALL_OW 12
10219: ST_TO_ADDR
// if r < 3 then
10220: LD_VAR 0 1
10224: PUSH
10225: LD_INT 3
10227: LESS
10228: IFFALSE 10251
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
10230: LD_INT 4
10232: PPUSH
10233: LD_INT 1
10235: PPUSH
10236: LD_INT 5
10238: PPUSH
10239: CALL_OW 12
10243: PPUSH
10244: LD_INT 1
10246: PPUSH
10247: CALL_OW 55
// end ;
10251: PPOPN 1
10253: END
// every 0 0$01 trigger cornel_active do
10254: LD_EXP 6
10258: IFFALSE 10347
10260: GO 10262
10262: DISABLE
// begin Wait ( 0 0$03 ) ;
10263: LD_INT 105
10265: PPUSH
10266: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
10270: LD_INT 2
10272: PPUSH
10273: LD_INT 5
10275: PPUSH
10276: CALL_OW 12
10280: PPUSH
10281: LD_INT 10
10283: PPUSH
10284: LD_INT 1
10286: PPUSH
10287: CALL_OW 55
// Wait ( 0 0$13 ) ;
10291: LD_INT 455
10293: PPUSH
10294: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
10298: LD_INT 2
10300: PPUSH
10301: LD_INT 5
10303: PPUSH
10304: CALL_OW 12
10308: PPUSH
10309: LD_INT 10
10311: PPUSH
10312: LD_INT 1
10314: PPUSH
10315: CALL_OW 55
// Wait ( 0 0$16 ) ;
10319: LD_INT 560
10321: PPUSH
10322: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
10326: LD_INT 2
10328: PPUSH
10329: LD_INT 5
10331: PPUSH
10332: CALL_OW 12
10336: PPUSH
10337: LD_INT 10
10339: PPUSH
10340: LD_INT 1
10342: PPUSH
10343: CALL_OW 55
// end ; end_of_file
10347: END
// every 0 0$01 trigger cornel_prepared do
10348: LD_EXP 9
10352: IFFALSE 10407
10354: GO 10356
10356: DISABLE
// begin enable ;
10357: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
10358: LD_ADDR_OWVAR 47
10362: PUSH
10363: LD_STRING #Am03-1
10365: PUSH
10366: LD_EXP 8
10370: PUSH
10371: EMPTY
10372: LIST
10373: LIST
10374: ST_TO_ADDR
// cornel_counter := cornel_counter - 0 0$01 ;
10375: LD_ADDR_EXP 8
10379: PUSH
10380: LD_EXP 8
10384: PUSH
10385: LD_INT 35
10387: MINUS
10388: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
10389: LD_EXP 8
10393: PUSH
10394: LD_INT 0
10396: EQUAL
10397: IFFALSE 10407
// begin Display_Strings := [ ] ;
10399: LD_ADDR_OWVAR 47
10403: PUSH
10404: EMPTY
10405: ST_TO_ADDR
// disable ;
10406: DISABLE
// end ; end ; end_of_file
10407: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
10408: LD_VAR 0 1
10412: PPUSH
10413: CALL_OW 255
10417: PUSH
10418: LD_INT 1
10420: EQUAL
10421: PUSH
10422: LD_EXP 11
10426: NOT
10427: AND
10428: IFFALSE 10438
// solar_builded := true ;
10430: LD_ADDR_EXP 11
10434: PUSH
10435: LD_INT 1
10437: ST_TO_ADDR
// end ;
10438: PPOPN 2
10440: END
