// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 363 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 451 0 0
// PrepareRussian ;
  22: CALL 3008 0 0
// PrepareAmerican ;
  26: CALL 1213 0 0
// PrepareCornell ;
  30: CALL 2237 0 0
// PrepareWesternBase ;
  34: CALL 2463 0 0
// Action ;
  38: CALL 5224 0 0
// end ;
  42: END
// export debug ; export mission_prefix , mission_prefix_prev ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , cornel_saved , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter , powell_warn , save_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// mission_prefix_prev := 02_ ;
  54: LD_ADDR_EXP 3
  58: PUSH
  59: LD_STRING 02_
  61: ST_TO_ADDR
// mission_prefix := 03_ ;
  62: LD_ADDR_EXP 2
  66: PUSH
  67: LD_STRING 03_
  69: ST_TO_ADDR
// jmm_units := 0 ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// cornel_units := 0 ;
  78: LD_ADDR_EXP 6
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// bierezov_exist := false ;
  86: LD_ADDR_EXP 7
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// jmm_on_west := false ;
  94: LD_ADDR_EXP 5
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_active := false ;
 102: LD_ADDR_EXP 8
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_attack := false ;
 110: LD_ADDR_EXP 9
 114: PUSH
 115: LD_INT 0
 117: ST_TO_ADDR
// cornel_prepared := false ;
 118: LD_ADDR_EXP 11
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 126: LD_ADDR_EXP 10
 130: PUSH
 131: LD_INT 4200
 133: ST_TO_ADDR
// frank_can_return := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// solar_builded := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// frank_send_to_scout := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// jmm_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// bobby_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// cyrus_in_veh := false ;
 174: LD_ADDR_EXP 17
 178: PUSH
 179: LD_INT 0
 181: ST_TO_ADDR
// lisa_in_veh := false ;
 182: LD_ADDR_EXP 18
 186: PUSH
 187: LD_INT 0
 189: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 190: LD_ADDR_EXP 28
 194: PUSH
 195: LD_INT 25200
 197: PUSH
 198: LD_INT 23100
 200: PUSH
 201: LD_INT 21000
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: LIST
 208: PUSH
 209: LD_OWVAR 67
 213: ARRAY
 214: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 215: LD_ADDR_EXP 19
 219: PUSH
 220: LD_INT 600
 222: PUSH
 223: LD_INT 500
 225: PUSH
 226: LD_INT 400
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: PUSH
 234: LD_OWVAR 67
 238: ARRAY
 239: ST_TO_ADDR
// end_mission_allowed := false ;
 240: LD_ADDR_EXP 20
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// save_others := [ ] ;
 248: LD_ADDR_EXP 21
 252: PUSH
 253: EMPTY
 254: ST_TO_ADDR
// save_group := [ ] ;
 255: LD_ADDR_EXP 22
 259: PUSH
 260: EMPTY
 261: ST_TO_ADDR
// show_query := true ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 1
 269: ST_TO_ADDR
// wait_for_them := false ;
 270: LD_ADDR_EXP 24
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// veh_on_meta := false ;
 278: LD_ADDR_EXP 27
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_spec_patrol := false ;
 286: LD_ADDR_EXP 29
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// prepare_siege := false ;
 294: LD_ADDR_EXP 30
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// send_attack_on_cornel := false ;
 302: LD_ADDR_EXP 31
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 310: LD_ADDR_EXP 25
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// game_end := false ;
 318: LD_ADDR_EXP 32
 322: PUSH
 323: LD_INT 0
 325: ST_TO_ADDR
// lose_counter := 0 ;
 326: LD_ADDR_EXP 33
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// powell_warn := 0 ;
 334: LD_ADDR_EXP 34
 338: PUSH
 339: LD_INT 0
 341: ST_TO_ADDR
// save_counter := 0 ;
 342: LD_ADDR_EXP 35
 346: PUSH
 347: LD_INT 0
 349: ST_TO_ADDR
// cornel_saved := false ;
 350: LD_ADDR_EXP 26
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// end ;
 358: LD_VAR 0 1
 362: RET
// function SetDiplomacy ; begin
 363: LD_INT 0
 365: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 366: LD_INT 1
 368: PPUSH
 369: LD_INT 4
 371: PPUSH
 372: LD_INT 1
 374: PPUSH
 375: LD_INT 1
 377: PPUSH
 378: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 382: LD_INT 1
 384: PPUSH
 385: LD_INT 8
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 398: LD_INT 3
 400: PPUSH
 401: LD_INT 6
 403: PPUSH
 404: LD_INT 1
 406: PPUSH
 407: LD_INT 1
 409: PPUSH
 410: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 414: LD_INT 4
 416: PPUSH
 417: LD_INT 6
 419: PPUSH
 420: LD_INT 0
 422: PPUSH
 423: LD_INT 1
 425: PPUSH
 426: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 430: LD_INT 3
 432: PPUSH
 433: LD_INT 8
 435: PPUSH
 436: LD_INT 0
 438: PPUSH
 439: LD_INT 1
 441: PPUSH
 442: CALL_OW 80
// end ;
 446: LD_VAR 0 1
 450: RET
// export function DebugMode ; var i ; begin
 451: LD_INT 0
 453: PPUSH
 454: PPUSH
// FogOff ( 1 ) ;
 455: LD_INT 1
 457: PPUSH
 458: CALL_OW 344
// debug_strings := [ ] ;
 462: LD_ADDR_OWVAR 48
 466: PUSH
 467: EMPTY
 468: ST_TO_ADDR
// end ; end_of_file
 469: LD_VAR 0 1
 473: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 474: LD_INT 0
 476: PPUSH
 477: PPUSH
// if exist_mode then
 478: LD_VAR 0 2
 482: IFFALSE 507
// unit := CreateCharacter ( mission_prefix_prev & ident ) else
 484: LD_ADDR_VAR 0 4
 488: PUSH
 489: LD_EXP 3
 493: PUSH
 494: LD_VAR 0 1
 498: STR
 499: PPUSH
 500: CALL_OW 34
 504: ST_TO_ADDR
 505: GO 522
// unit := NewCharacter ( ident ) ;
 507: LD_ADDR_VAR 0 4
 511: PUSH
 512: LD_VAR 0 1
 516: PPUSH
 517: CALL_OW 25
 521: ST_TO_ADDR
// result := unit ;
 522: LD_ADDR_VAR 0 3
 526: PUSH
 527: LD_VAR 0 4
 531: ST_TO_ADDR
// end ;
 532: LD_VAR 0 3
 536: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 537: LD_INT 0
 539: PPUSH
// uc_side := side ;
 540: LD_ADDR_OWVAR 20
 544: PUSH
 545: LD_VAR 0 1
 549: ST_TO_ADDR
// uc_nation := nation ;
 550: LD_ADDR_OWVAR 21
 554: PUSH
 555: LD_VAR 0 2
 559: ST_TO_ADDR
// vc_chassis := chassis ;
 560: LD_ADDR_OWVAR 37
 564: PUSH
 565: LD_VAR 0 3
 569: ST_TO_ADDR
// vc_engine := engine ;
 570: LD_ADDR_OWVAR 39
 574: PUSH
 575: LD_VAR 0 4
 579: ST_TO_ADDR
// vc_control := control ;
 580: LD_ADDR_OWVAR 38
 584: PUSH
 585: LD_VAR 0 5
 589: ST_TO_ADDR
// vc_weapon := weapon ;
 590: LD_ADDR_OWVAR 40
 594: PUSH
 595: LD_VAR 0 6
 599: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 600: LD_ADDR_OWVAR 41
 604: PUSH
 605: LD_VAR 0 7
 609: ST_TO_ADDR
// result := CreateVehicle ;
 610: LD_ADDR_VAR 0 8
 614: PUSH
 615: CALL_OW 45
 619: ST_TO_ADDR
// end ;
 620: LD_VAR 0 8
 624: RET
// export function SayX ( units , ident ) ; var i ; begin
 625: LD_INT 0
 627: PPUSH
 628: PPUSH
// result := false ;
 629: LD_ADDR_VAR 0 3
 633: PUSH
 634: LD_INT 0
 636: ST_TO_ADDR
// if not units then
 637: LD_VAR 0 1
 641: NOT
 642: IFFALSE 646
// exit ;
 644: GO 700
// for i in units do
 646: LD_ADDR_VAR 0 4
 650: PUSH
 651: LD_VAR 0 1
 655: PUSH
 656: FOR_IN
 657: IFFALSE 698
// if IsOk ( i ) then
 659: LD_VAR 0 4
 663: PPUSH
 664: CALL_OW 302
 668: IFFALSE 696
// begin Say ( i , ident ) ;
 670: LD_VAR 0 4
 674: PPUSH
 675: LD_VAR 0 2
 679: PPUSH
 680: CALL_OW 88
// result := i ;
 684: LD_ADDR_VAR 0 3
 688: PUSH
 689: LD_VAR 0 4
 693: ST_TO_ADDR
// break ;
 694: GO 698
// end ;
 696: GO 656
 698: POP
 699: POP
// end ;
 700: LD_VAR 0 3
 704: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 705: LD_INT 0
 707: PPUSH
 708: PPUSH
 709: PPUSH
 710: PPUSH
// for i = 1 to count do
 711: LD_ADDR_VAR 0 8
 715: PUSH
 716: DOUBLE
 717: LD_INT 1
 719: DEC
 720: ST_TO_ADDR
 721: LD_VAR 0 6
 725: PUSH
 726: FOR_TO
 727: IFFALSE 808
// begin uc_side = side ;
 729: LD_ADDR_OWVAR 20
 733: PUSH
 734: LD_VAR 0 1
 738: ST_TO_ADDR
// uc_nation = nation ;
 739: LD_ADDR_OWVAR 21
 743: PUSH
 744: LD_VAR 0 2
 748: ST_TO_ADDR
// hc_gallery =  ;
 749: LD_ADDR_OWVAR 33
 753: PUSH
 754: LD_STRING 
 756: ST_TO_ADDR
// hc_name =  ;
 757: LD_ADDR_OWVAR 26
 761: PUSH
 762: LD_STRING 
 764: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 765: LD_INT 0
 767: PPUSH
 768: LD_VAR 0 5
 772: PPUSH
 773: LD_VAR 0 4
 777: PPUSH
 778: CALL_OW 380
// un = CreateHuman ;
 782: LD_ADDR_VAR 0 10
 786: PUSH
 787: CALL_OW 44
 791: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 792: LD_VAR 0 10
 796: PPUSH
 797: LD_VAR 0 3
 801: PPUSH
 802: CALL_OW 52
// end ;
 806: GO 726
 808: POP
 809: POP
// end ;
 810: LD_VAR 0 7
 814: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 815: LD_INT 0
 817: PPUSH
 818: PPUSH
 819: PPUSH
// uc_side := GetSide ( b ) ;
 820: LD_ADDR_OWVAR 20
 824: PUSH
 825: LD_VAR 0 2
 829: PPUSH
 830: CALL_OW 255
 834: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_VAR 0 2
 844: PPUSH
 845: CALL_OW 248
 849: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 850: LD_INT 0
 852: PPUSH
 853: LD_INT 1
 855: PPUSH
 856: LD_VAR 0 1
 860: PPUSH
 861: CALL_OW 380
// un = CreateHuman ;
 865: LD_ADDR_VAR 0 4
 869: PUSH
 870: CALL_OW 44
 874: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 875: LD_ADDR_VAR 0 5
 879: PUSH
 880: LD_VAR 0 2
 884: PPUSH
 885: CALL_OW 254
 889: PUSH
 890: LD_INT 3
 892: MINUS
 893: ST_TO_ADDR
// if dir < 0 then
 894: LD_VAR 0 5
 898: PUSH
 899: LD_INT 0
 901: LESS
 902: IFFALSE 918
// dir := 6 + dir ;
 904: LD_ADDR_VAR 0 5
 908: PUSH
 909: LD_INT 6
 911: PUSH
 912: LD_VAR 0 5
 916: PLUS
 917: ST_TO_ADDR
// SetDir ( un , dir ) ;
 918: LD_VAR 0 4
 922: PPUSH
 923: LD_VAR 0 5
 927: PPUSH
 928: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 932: LD_VAR 0 4
 936: PPUSH
 937: LD_VAR 0 2
 941: PPUSH
 942: CALL_OW 52
// end ;
 946: LD_VAR 0 3
 950: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 951: LD_INT 0
 953: PPUSH
 954: PPUSH
 955: PPUSH
// result := false ;
 956: LD_ADDR_VAR 0 2
 960: PUSH
 961: LD_INT 0
 963: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 964: LD_ADDR_VAR 0 3
 968: PUSH
 969: LD_INT 22
 971: PUSH
 972: LD_INT 1
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 34
 981: PUSH
 982: LD_INT 2
 984: PUSH
 985: EMPTY
 986: LIST
 987: LIST
 988: PUSH
 989: EMPTY
 990: LIST
 991: LIST
 992: PPUSH
 993: CALL_OW 69
 997: ST_TO_ADDR
// for i in filter do
 998: LD_ADDR_VAR 0 4
1002: PUSH
1003: LD_VAR 0 3
1007: PUSH
1008: FOR_IN
1009: IFFALSE 1040
// if IsDrivenBy ( i ) = unit then
1011: LD_VAR 0 4
1015: PPUSH
1016: CALL_OW 311
1020: PUSH
1021: LD_VAR 0 1
1025: EQUAL
1026: IFFALSE 1038
// begin result := true ;
1028: LD_ADDR_VAR 0 2
1032: PUSH
1033: LD_INT 1
1035: ST_TO_ADDR
// break ;
1036: GO 1040
// end ;
1038: GO 1008
1040: POP
1041: POP
// end ;
1042: LD_VAR 0 2
1046: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1047: LD_INT 0
1049: PPUSH
1050: PPUSH
// result := false ;
1051: LD_ADDR_VAR 0 2
1055: PUSH
1056: LD_INT 0
1058: ST_TO_ADDR
// if not blist then
1059: LD_VAR 0 1
1063: NOT
1064: IFFALSE 1068
// exit ;
1066: GO 1112
// for i in blist do
1068: LD_ADDR_VAR 0 3
1072: PUSH
1073: LD_VAR 0 1
1077: PUSH
1078: FOR_IN
1079: IFFALSE 1110
// if UnitsInside ( i ) < 6 then
1081: LD_VAR 0 3
1085: PPUSH
1086: CALL_OW 313
1090: PUSH
1091: LD_INT 6
1093: LESS
1094: IFFALSE 1108
// begin result := i ;
1096: LD_ADDR_VAR 0 2
1100: PUSH
1101: LD_VAR 0 3
1105: ST_TO_ADDR
// break ;
1106: GO 1110
// end ;
1108: GO 1078
1110: POP
1111: POP
// end ;
1112: LD_VAR 0 2
1116: RET
// export function Count ( timer , mode ) ; begin
1117: LD_INT 0
1119: PPUSH
// if not timer then
1120: LD_VAR 0 1
1124: NOT
1125: IFFALSE 1129
// exit ;
1127: GO 1180
// if mode in [ asc , up , + ] then
1129: LD_VAR 0 2
1133: PUSH
1134: LD_STRING asc
1136: PUSH
1137: LD_STRING up
1139: PUSH
1140: LD_STRING +
1142: PUSH
1143: EMPTY
1144: LIST
1145: LIST
1146: LIST
1147: IN
1148: IFFALSE 1166
// result := timer + 0 0$01 else
1150: LD_ADDR_VAR 0 3
1154: PUSH
1155: LD_VAR 0 1
1159: PUSH
1160: LD_INT 35
1162: PLUS
1163: ST_TO_ADDR
1164: GO 1180
// result := timer - 0 0$01 ;
1166: LD_ADDR_VAR 0 3
1170: PUSH
1171: LD_VAR 0 1
1175: PUSH
1176: LD_INT 35
1178: MINUS
1179: ST_TO_ADDR
// end ;
1180: LD_VAR 0 3
1184: RET
// export function Video ( mode ) ; begin
1185: LD_INT 0
1187: PPUSH
// ingame_video = mode ;
1188: LD_ADDR_OWVAR 52
1192: PUSH
1193: LD_VAR 0 1
1197: ST_TO_ADDR
// interface_hidden = mode ;
1198: LD_ADDR_OWVAR 54
1202: PUSH
1203: LD_VAR 0 1
1207: ST_TO_ADDR
// end ; end_of_file
1208: LD_VAR 0 2
1212: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1213: LD_INT 0
1215: PPUSH
1216: PPUSH
1217: PPUSH
1218: PPUSH
1219: PPUSH
1220: PPUSH
1221: PPUSH
1222: PPUSH
// uc_side := 4 ;
1223: LD_ADDR_OWVAR 20
1227: PUSH
1228: LD_INT 4
1230: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1231: LD_ADDR_EXP 45
1235: PUSH
1236: LD_STRING Powell
1238: PPUSH
1239: LD_INT 0
1241: PPUSH
1242: CALL 474 0 2
1246: ST_TO_ADDR
// uc_side := 1 ;
1247: LD_ADDR_OWVAR 20
1251: PUSH
1252: LD_INT 1
1254: ST_TO_ADDR
// uc_nation := 1 ;
1255: LD_ADDR_OWVAR 21
1259: PUSH
1260: LD_INT 1
1262: ST_TO_ADDR
// if debug then
1263: LD_EXP 1
1267: IFFALSE 1397
// begin for i = 1 to 4 do
1269: LD_ADDR_VAR 0 2
1273: PUSH
1274: DOUBLE
1275: LD_INT 1
1277: DEC
1278: ST_TO_ADDR
1279: LD_INT 4
1281: PUSH
1282: FOR_TO
1283: IFFALSE 1334
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1285: LD_INT 0
1287: PPUSH
1288: LD_INT 1
1290: PPUSH
1291: LD_INT 2
1293: PPUSH
1294: CALL_OW 12
1298: PPUSH
1299: LD_INT 3
1301: PPUSH
1302: CALL_OW 380
// un := CreateHuman ;
1306: LD_ADDR_VAR 0 3
1310: PUSH
1311: CALL_OW 44
1315: ST_TO_ADDR
// others := others ^ un ;
1316: LD_ADDR_VAR 0 5
1320: PUSH
1321: LD_VAR 0 5
1325: PUSH
1326: LD_VAR 0 3
1330: ADD
1331: ST_TO_ADDR
// end ;
1332: GO 1282
1334: POP
1335: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1336: LD_ADDR_VAR 0 6
1340: PUSH
1341: LD_INT 21
1343: PUSH
1344: LD_INT 1
1346: PUSH
1347: LD_INT 1
1349: PUSH
1350: LD_INT 51
1352: PUSH
1353: LD_INT 90
1355: PUSH
1356: LD_INT 504
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: LIST
1363: LIST
1364: LIST
1365: LIST
1366: PUSH
1367: LD_INT 21
1369: PUSH
1370: LD_INT 1
1372: PUSH
1373: LD_INT 1
1375: PUSH
1376: LD_INT 51
1378: PUSH
1379: LD_INT 80
1381: PUSH
1382: LD_INT 750
1384: PUSH
1385: EMPTY
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1397: LD_ADDR_EXP 36
1401: PUSH
1402: LD_STRING JMM
1404: PPUSH
1405: LD_EXP 1
1409: NOT
1410: PPUSH
1411: CALL 474 0 2
1415: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1416: LD_ADDR_EXP 37
1420: PUSH
1421: LD_STRING Bobby
1423: PPUSH
1424: LD_EXP 1
1428: NOT
1429: PPUSH
1430: CALL 474 0 2
1434: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1435: LD_ADDR_EXP 38
1439: PUSH
1440: LD_STRING Cyrus
1442: PPUSH
1443: LD_EXP 1
1447: NOT
1448: PPUSH
1449: CALL 474 0 2
1453: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1454: LD_ADDR_EXP 39
1458: PUSH
1459: LD_STRING Lisa
1461: PPUSH
1462: LD_EXP 1
1466: NOT
1467: PPUSH
1468: CALL 474 0 2
1472: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1473: LD_ADDR_EXP 40
1477: PUSH
1478: LD_STRING Khatam
1480: PPUSH
1481: LD_EXP 1
1485: NOT
1486: PPUSH
1487: CALL 474 0 2
1491: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1492: LD_ADDR_EXP 41
1496: PUSH
1497: LD_STRING Brian
1499: PPUSH
1500: LD_EXP 1
1504: NOT
1505: PPUSH
1506: CALL 474 0 2
1510: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1511: LD_ADDR_EXP 42
1515: PUSH
1516: LD_STRING Jerry
1518: PPUSH
1519: LD_EXP 1
1523: NOT
1524: PPUSH
1525: CALL 474 0 2
1529: ST_TO_ADDR
// if Bobby then
1530: LD_EXP 37
1534: IFFALSE 1565
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1536: LD_ADDR_VAR 0 4
1540: PUSH
1541: LD_VAR 0 4
1545: PPUSH
1546: LD_VAR 0 4
1550: PUSH
1551: LD_INT 1
1553: PLUS
1554: PPUSH
1555: LD_EXP 37
1559: PPUSH
1560: CALL_OW 2
1564: ST_TO_ADDR
// if Cyrus then
1565: LD_EXP 38
1569: IFFALSE 1600
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1571: LD_ADDR_VAR 0 4
1575: PUSH
1576: LD_VAR 0 4
1580: PPUSH
1581: LD_VAR 0 4
1585: PUSH
1586: LD_INT 1
1588: PLUS
1589: PPUSH
1590: LD_EXP 38
1594: PPUSH
1595: CALL_OW 2
1599: ST_TO_ADDR
// if Lisa then
1600: LD_EXP 39
1604: IFFALSE 1635
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1606: LD_ADDR_VAR 0 4
1610: PUSH
1611: LD_VAR 0 4
1615: PPUSH
1616: LD_VAR 0 4
1620: PUSH
1621: LD_INT 1
1623: PLUS
1624: PPUSH
1625: LD_EXP 39
1629: PPUSH
1630: CALL_OW 2
1634: ST_TO_ADDR
// if Khatam then
1635: LD_EXP 40
1639: IFFALSE 1670
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1641: LD_ADDR_VAR 0 4
1645: PUSH
1646: LD_VAR 0 4
1650: PPUSH
1651: LD_VAR 0 4
1655: PUSH
1656: LD_INT 1
1658: PLUS
1659: PPUSH
1660: LD_EXP 40
1664: PPUSH
1665: CALL_OW 2
1669: ST_TO_ADDR
// if Brian then
1670: LD_EXP 41
1674: IFFALSE 1705
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1676: LD_ADDR_VAR 0 4
1680: PUSH
1681: LD_VAR 0 4
1685: PPUSH
1686: LD_VAR 0 4
1690: PUSH
1691: LD_INT 1
1693: PLUS
1694: PPUSH
1695: LD_EXP 41
1699: PPUSH
1700: CALL_OW 2
1704: ST_TO_ADDR
// if Jerry then
1705: LD_EXP 42
1709: IFFALSE 1740
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1711: LD_ADDR_VAR 0 4
1715: PUSH
1716: LD_VAR 0 4
1720: PPUSH
1721: LD_VAR 0 4
1725: PUSH
1726: LD_INT 1
1728: PLUS
1729: PPUSH
1730: LD_EXP 42
1734: PPUSH
1735: CALL_OW 2
1739: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1740: LD_STRING 02_other_survivors
1742: PPUSH
1743: CALL_OW 28
1747: IFFALSE 1762
// others := CreateCharacterSet ( 02_other_survivors ) ;
1749: LD_ADDR_VAR 0 5
1753: PUSH
1754: LD_STRING 02_other_survivors
1756: PPUSH
1757: CALL_OW 31
1761: ST_TO_ADDR
// if others then
1762: LD_VAR 0 5
1766: IFFALSE 1791
// begin tmp := tmp ^ others ;
1768: LD_ADDR_VAR 0 4
1772: PUSH
1773: LD_VAR 0 4
1777: PUSH
1778: LD_VAR 0 5
1782: ADD
1783: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1784: LD_STRING 02_other_survivors
1786: PPUSH
1787: CALL_OW 40
// end ; jmm_units := tmp ;
1791: LD_ADDR_EXP 4
1795: PUSH
1796: LD_VAR 0 4
1800: ST_TO_ADDR
// if not vehicles then
1801: LD_VAR 0 6
1805: NOT
1806: IFFALSE 1824
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1808: LD_ADDR_VAR 0 6
1812: PUSH
1813: LD_STRING 02_tanks_1
1815: PPUSH
1816: LD_INT 0
1818: PPUSH
1819: CALL_OW 30
1823: ST_TO_ADDR
// if vehicles then
1824: LD_VAR 0 6
1828: IFFALSE 2022
// begin got_mech := false ;
1830: LD_ADDR_VAR 0 7
1834: PUSH
1835: LD_INT 0
1837: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1838: LD_VAR 0 4
1842: PPUSH
1843: LD_INT 25
1845: PUSH
1846: LD_INT 3
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: PPUSH
1853: CALL_OW 72
1857: IFFALSE 1867
// got_mech := true ;
1859: LD_ADDR_VAR 0 7
1863: PUSH
1864: LD_INT 1
1866: ST_TO_ADDR
// for i = 1 to vehicles do
1867: LD_ADDR_VAR 0 2
1871: PUSH
1872: DOUBLE
1873: LD_INT 1
1875: DEC
1876: ST_TO_ADDR
1877: LD_VAR 0 6
1881: PUSH
1882: FOR_TO
1883: IFFALSE 2020
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1885: LD_ADDR_VAR 0 3
1889: PUSH
1890: LD_INT 1
1892: PPUSH
1893: LD_INT 3
1895: PPUSH
1896: LD_VAR 0 6
1900: PUSH
1901: LD_VAR 0 2
1905: ARRAY
1906: PUSH
1907: LD_INT 1
1909: ARRAY
1910: PPUSH
1911: LD_VAR 0 6
1915: PUSH
1916: LD_VAR 0 2
1920: ARRAY
1921: PUSH
1922: LD_INT 2
1924: ARRAY
1925: PPUSH
1926: LD_VAR 0 6
1930: PUSH
1931: LD_VAR 0 2
1935: ARRAY
1936: PUSH
1937: LD_INT 3
1939: ARRAY
1940: PPUSH
1941: LD_VAR 0 6
1945: PUSH
1946: LD_VAR 0 2
1950: ARRAY
1951: PUSH
1952: LD_INT 4
1954: ARRAY
1955: PPUSH
1956: LD_INT 40
1958: PPUSH
1959: CALL 537 0 7
1963: ST_TO_ADDR
// if not got_mech then
1964: LD_VAR 0 7
1968: NOT
1969: IFFALSE 1995
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1971: LD_VAR 0 3
1975: PPUSH
1976: LD_VAR 0 6
1980: PUSH
1981: LD_VAR 0 2
1985: ARRAY
1986: PUSH
1987: LD_INT 6
1989: ARRAY
1990: PPUSH
1991: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1995: LD_ADDR_VAR 0 4
1999: PUSH
2000: LD_VAR 0 4
2004: PPUSH
2005: LD_INT 1
2007: PPUSH
2008: LD_VAR 0 3
2012: PPUSH
2013: CALL_OW 2
2017: ST_TO_ADDR
// end ;
2018: GO 1882
2020: POP
2021: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
2022: LD_EXP 36
2026: PPUSH
2027: LD_INT 194
2029: PPUSH
2030: LD_INT 119
2032: PPUSH
2033: LD_INT 0
2035: PPUSH
2036: CALL_OW 48
// if tmp then
2040: LD_VAR 0 4
2044: IFFALSE 2169
// begin for i in tmp do
2046: LD_ADDR_VAR 0 2
2050: PUSH
2051: LD_VAR 0 4
2055: PUSH
2056: FOR_IN
2057: IFFALSE 2167
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2059: LD_ADDR_VAR 0 8
2063: PUSH
2064: LD_INT 22
2066: PUSH
2067: LD_INT 1
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: PUSH
2074: LD_INT 21
2076: PUSH
2077: LD_INT 2
2079: PUSH
2080: EMPTY
2081: LIST
2082: LIST
2083: PUSH
2084: LD_INT 58
2086: PUSH
2087: EMPTY
2088: LIST
2089: PUSH
2090: EMPTY
2091: LIST
2092: LIST
2093: LIST
2094: PPUSH
2095: CALL_OW 69
2099: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2100: LD_VAR 0 2
2104: PPUSH
2105: CALL_OW 247
2109: PUSH
2110: LD_INT 1
2112: EQUAL
2113: PUSH
2114: LD_VAR 0 8
2118: AND
2119: IFFALSE 2141
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2121: LD_VAR 0 2
2125: PPUSH
2126: LD_VAR 0 8
2130: PUSH
2131: LD_INT 1
2133: ARRAY
2134: PPUSH
2135: CALL_OW 52
2139: GO 2156
// PlaceUnitArea ( i , startArea , false ) ;
2141: LD_VAR 0 2
2145: PPUSH
2146: LD_INT 1
2148: PPUSH
2149: LD_INT 0
2151: PPUSH
2152: CALL_OW 49
// ComHold ( i ) ;
2156: LD_VAR 0 2
2160: PPUSH
2161: CALL_OW 140
// end ;
2165: GO 2056
2167: POP
2168: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2169: LD_ADDR_EXP 7
2173: PUSH
2174: LD_STRING 02_mikhailStatus_1
2176: PPUSH
2177: LD_INT 0
2179: PPUSH
2180: CALL_OW 30
2184: ST_TO_ADDR
// if not bierezov_exist and not debug then
2185: LD_EXP 7
2189: NOT
2190: PUSH
2191: LD_EXP 1
2195: NOT
2196: AND
2197: IFFALSE 2201
// exit ;
2199: GO 2232
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2201: LD_ADDR_EXP 44
2205: PUSH
2206: LD_STRING Mikhail
2208: PPUSH
2209: LD_INT 0
2211: PPUSH
2212: CALL 474 0 2
2216: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2217: LD_EXP 44
2221: PPUSH
2222: LD_INT 1
2224: PPUSH
2225: LD_INT 0
2227: PPUSH
2228: CALL_OW 49
// end ;
2232: LD_VAR 0 1
2236: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2237: LD_INT 0
2239: PPUSH
2240: PPUSH
2241: PPUSH
2242: PPUSH
// uc_side := 4 ;
2243: LD_ADDR_OWVAR 20
2247: PUSH
2248: LD_INT 4
2250: ST_TO_ADDR
// uc_nation := 1 ;
2251: LD_ADDR_OWVAR 21
2255: PUSH
2256: LD_INT 1
2258: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2259: LD_ADDR_EXP 43
2263: PUSH
2264: LD_STRING Cornell
2266: PPUSH
2267: LD_INT 0
2269: PPUSH
2270: CALL 474 0 2
2274: ST_TO_ADDR
// cornel_units := 9 - jmm_units ;
2275: LD_ADDR_EXP 6
2279: PUSH
2280: LD_INT 9
2282: PUSH
2283: LD_EXP 4
2287: MINUS
2288: ST_TO_ADDR
// tmp := [ ] ;
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: EMPTY
2295: ST_TO_ADDR
// if cornel_units < 4 then
2296: LD_EXP 6
2300: PUSH
2301: LD_INT 4
2303: LESS
2304: IFFALSE 2314
// cornel_units := 4 ;
2306: LD_ADDR_EXP 6
2310: PUSH
2311: LD_INT 4
2313: ST_TO_ADDR
// for i = 1 to cornel_units do
2314: LD_ADDR_VAR 0 4
2318: PUSH
2319: DOUBLE
2320: LD_INT 1
2322: DEC
2323: ST_TO_ADDR
2324: LD_EXP 6
2328: PUSH
2329: FOR_TO
2330: IFFALSE 2428
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2332: LD_INT 0
2334: PPUSH
2335: LD_INT 1
2337: PUSH
2338: LD_INT 1
2340: PUSH
2341: LD_INT 1
2343: PUSH
2344: LD_INT 2
2346: PUSH
2347: LD_INT 4
2349: PUSH
2350: EMPTY
2351: LIST
2352: LIST
2353: LIST
2354: LIST
2355: LIST
2356: PUSH
2357: LD_VAR 0 4
2361: PUSH
2362: LD_INT 5
2364: MOD
2365: PUSH
2366: LD_INT 1
2368: PLUS
2369: ARRAY
2370: PPUSH
2371: LD_INT 2
2373: PPUSH
2374: CALL_OW 380
// un := CreateHuman ;
2378: LD_ADDR_VAR 0 3
2382: PUSH
2383: CALL_OW 44
2387: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2388: LD_ADDR_VAR 0 2
2392: PUSH
2393: LD_VAR 0 2
2397: PPUSH
2398: LD_INT 1
2400: PPUSH
2401: LD_VAR 0 3
2405: PPUSH
2406: CALL_OW 2
2410: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2411: LD_VAR 0 3
2415: PPUSH
2416: LD_INT 2
2418: PPUSH
2419: LD_INT 0
2421: PPUSH
2422: CALL_OW 49
// end ;
2426: GO 2329
2428: POP
2429: POP
// cornel_units := tmp ;
2430: LD_ADDR_EXP 6
2434: PUSH
2435: LD_VAR 0 2
2439: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2440: LD_EXP 43
2444: PPUSH
2445: LD_INT 191
2447: PPUSH
2448: LD_INT 106
2450: PPUSH
2451: LD_INT 0
2453: PPUSH
2454: CALL_OW 48
// end ;
2458: LD_VAR 0 1
2462: RET
// export function PrepareWesternBase ; var i ; begin
2463: LD_INT 0
2465: PPUSH
2466: PPUSH
// uc_side := 8 ;
2467: LD_ADDR_OWVAR 20
2471: PUSH
2472: LD_INT 8
2474: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2475: LD_ADDR_EXP 46
2479: PUSH
2480: LD_STRING Lynch
2482: PPUSH
2483: LD_INT 0
2485: PPUSH
2486: CALL 474 0 2
2490: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2491: LD_ADDR_EXP 47
2495: PUSH
2496: LD_STRING Walker
2498: PPUSH
2499: LD_INT 0
2501: PPUSH
2502: CALL 474 0 2
2506: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2507: LD_ADDR_EXP 48
2511: PUSH
2512: LD_STRING Turner
2514: PPUSH
2515: LD_INT 0
2517: PPUSH
2518: CALL 474 0 2
2522: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2523: LD_ADDR_EXP 49
2527: PUSH
2528: LD_STRING Jillian
2530: PPUSH
2531: LD_INT 0
2533: PPUSH
2534: CALL 474 0 2
2538: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2539: LD_ADDR_VAR 0 2
2543: PUSH
2544: LD_EXP 46
2548: PUSH
2549: LD_EXP 47
2553: PUSH
2554: LD_EXP 48
2558: PUSH
2559: LD_EXP 49
2563: PUSH
2564: EMPTY
2565: LIST
2566: LIST
2567: LIST
2568: LIST
2569: PUSH
2570: FOR_IN
2571: IFFALSE 2599
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2573: LD_VAR 0 2
2577: PPUSH
2578: LD_INT 3
2580: PPUSH
2581: LD_INT 0
2583: PPUSH
2584: CALL_OW 49
// ComHold ( i ) ;
2588: LD_VAR 0 2
2592: PPUSH
2593: CALL_OW 140
// end ;
2597: GO 2570
2599: POP
2600: POP
// end ;
2601: LD_VAR 0 1
2605: RET
// export function SelectGroup ; var units , selected , i ; begin
2606: LD_INT 0
2608: PPUSH
2609: PPUSH
2610: PPUSH
2611: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2612: LD_ADDR_VAR 0 2
2616: PUSH
2617: LD_EXP 36
2621: PUSH
2622: LD_INT -3
2624: PUSH
2625: EMPTY
2626: LIST
2627: LIST
2628: PUSH
2629: LD_EXP 4
2633: ADD
2634: PUSH
2635: LD_INT -2
2637: PUSH
2638: LD_INT -4
2640: PUSH
2641: LD_EXP 43
2645: PUSH
2646: LD_EXP 44
2650: PUSH
2651: EMPTY
2652: LIST
2653: LIST
2654: LIST
2655: LIST
2656: ADD
2657: PUSH
2658: LD_INT -3
2660: PUSH
2661: EMPTY
2662: LIST
2663: ADD
2664: PUSH
2665: LD_EXP 6
2669: ADD
2670: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: LD_EXP 36
2680: PUSH
2681: LD_STRING Select five characters to go with you
2683: PPUSH
2684: LD_INT 4
2686: PPUSH
2687: LD_INT 4
2689: PPUSH
2690: LD_VAR 0 2
2694: PPUSH
2695: EMPTY
2696: PPUSH
2697: CALL_OW 42
2701: ADD
2702: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2703: LD_ADDR_EXP 6
2707: PUSH
2708: LD_EXP 4
2712: PUSH
2713: LD_EXP 6
2717: UNION
2718: PUSH
2719: LD_VAR 0 3
2723: DIFF
2724: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2725: LD_ADDR_VAR 0 4
2729: PUSH
2730: LD_EXP 6
2734: PUSH
2735: LD_EXP 44
2739: ADD
2740: PUSH
2741: FOR_IN
2742: IFFALSE 2773
// if GetSide ( i ) = 1 then
2744: LD_VAR 0 4
2748: PPUSH
2749: CALL_OW 255
2753: PUSH
2754: LD_INT 1
2756: EQUAL
2757: IFFALSE 2771
// SetSide ( i , 4 ) ;
2759: LD_VAR 0 4
2763: PPUSH
2764: LD_INT 4
2766: PPUSH
2767: CALL_OW 235
2771: GO 2741
2773: POP
2774: POP
// for i in selected do
2775: LD_ADDR_VAR 0 4
2779: PUSH
2780: LD_VAR 0 3
2784: PUSH
2785: FOR_IN
2786: IFFALSE 2817
// if GetSide ( i ) = 4 then
2788: LD_VAR 0 4
2792: PPUSH
2793: CALL_OW 255
2797: PUSH
2798: LD_INT 4
2800: EQUAL
2801: IFFALSE 2815
// SetSide ( i , 1 ) ;
2803: LD_VAR 0 4
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: CALL_OW 235
2815: GO 2785
2817: POP
2818: POP
// jmm_units := jmm_units diff cornel_units ;
2819: LD_ADDR_EXP 4
2823: PUSH
2824: LD_EXP 4
2828: PUSH
2829: LD_EXP 6
2833: DIFF
2834: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2835: LD_EXP 37
2839: PPUSH
2840: CALL_OW 255
2844: PUSH
2845: LD_INT 4
2847: EQUAL
2848: IFFALSE 2863
// DeleteCharacters ( mission_prefix_prev & Bobby ) ;
2850: LD_EXP 3
2854: PUSH
2855: LD_STRING Bobby
2857: STR
2858: PPUSH
2859: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2863: LD_EXP 38
2867: PPUSH
2868: CALL_OW 255
2872: PUSH
2873: LD_INT 4
2875: EQUAL
2876: IFFALSE 2891
// DeleteCharacters ( mission_prefix_prev & Cyrus ) ;
2878: LD_EXP 3
2882: PUSH
2883: LD_STRING Cyrus
2885: STR
2886: PPUSH
2887: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2891: LD_EXP 39
2895: PPUSH
2896: CALL_OW 255
2900: PUSH
2901: LD_INT 4
2903: EQUAL
2904: IFFALSE 2919
// DeleteCharacters ( mission_prefix_prev & Lisa ) ;
2906: LD_EXP 3
2910: PUSH
2911: LD_STRING Lisa
2913: STR
2914: PPUSH
2915: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2919: LD_EXP 40
2923: PPUSH
2924: CALL_OW 255
2928: PUSH
2929: LD_INT 4
2931: EQUAL
2932: IFFALSE 2947
// DeleteCharacters ( mission_prefix_prev & Khatam ) ;
2934: LD_EXP 3
2938: PUSH
2939: LD_STRING Khatam
2941: STR
2942: PPUSH
2943: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2947: LD_EXP 41
2951: PPUSH
2952: CALL_OW 255
2956: PUSH
2957: LD_INT 4
2959: EQUAL
2960: IFFALSE 2975
// DeleteCharacters ( mission_prefix_prev & Brian ) ;
2962: LD_EXP 3
2966: PUSH
2967: LD_STRING Brian
2969: STR
2970: PPUSH
2971: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2975: LD_EXP 42
2979: PPUSH
2980: CALL_OW 255
2984: PUSH
2985: LD_INT 4
2987: EQUAL
2988: IFFALSE 3003
// DeleteCharacters ( mission_prefix_prev & Jerry ) ;
2990: LD_EXP 3
2994: PUSH
2995: LD_STRING Jerry
2997: STR
2998: PPUSH
2999: CALL_OW 40
// end ; end_of_file
3003: LD_VAR 0 1
3007: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
3008: LD_INT 0
3010: PPUSH
3011: PPUSH
3012: PPUSH
3013: PPUSH
3014: PPUSH
3015: PPUSH
3016: PPUSH
3017: PPUSH
3018: PPUSH
3019: PPUSH
3020: PPUSH
3021: PPUSH
3022: PPUSH
// ru_alert := false ;
3023: LD_ADDR_EXP 59
3027: PUSH
3028: LD_INT 0
3030: ST_TO_ADDR
// ru_produce_list := [ ] ;
3031: LD_ADDR_EXP 56
3035: PUSH
3036: EMPTY
3037: ST_TO_ADDR
// if Difficulty > 1 then
3038: LD_OWVAR 67
3042: PUSH
3043: LD_INT 1
3045: GREATER
3046: IFFALSE 3134
// begin uc_side := 3 ;
3048: LD_ADDR_OWVAR 20
3052: PUSH
3053: LD_INT 3
3055: ST_TO_ADDR
// uc_nation := 3 ;
3056: LD_ADDR_OWVAR 21
3060: PUSH
3061: LD_INT 3
3063: ST_TO_ADDR
// bc_type := b_breastwork ;
3064: LD_ADDR_OWVAR 42
3068: PUSH
3069: LD_INT 31
3071: ST_TO_ADDR
// bc_level := Difficulty ;
3072: LD_ADDR_OWVAR 43
3076: PUSH
3077: LD_OWVAR 67
3081: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
3082: LD_INT 22
3084: PPUSH
3085: LD_INT 14
3087: PPUSH
3088: LD_INT 0
3090: PPUSH
3091: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3095: LD_INT 48
3097: PPUSH
3098: LD_INT 46
3100: PPUSH
3101: LD_INT 0
3103: PPUSH
3104: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3108: LD_INT 86
3110: PPUSH
3111: LD_INT 65
3113: PPUSH
3114: LD_INT 5
3116: PPUSH
3117: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3121: LD_INT 165
3123: PPUSH
3124: LD_INT 73
3126: PPUSH
3127: LD_INT 5
3129: PPUSH
3130: CALL_OW 47
// end ; if Difficulty = 3 then
3134: LD_OWVAR 67
3138: PUSH
3139: LD_INT 3
3141: EQUAL
3142: IFFALSE 3157
// SetTech ( tech_weap1 , 3 , state_researched ) ;
3144: LD_INT 51
3146: PPUSH
3147: LD_INT 3
3149: PPUSH
3150: LD_INT 2
3152: PPUSH
3153: CALL_OW 322
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3157: LD_ADDR_VAR 0 7
3161: PUSH
3162: LD_INT 22
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: EMPTY
3169: LIST
3170: LIST
3171: PUSH
3172: LD_INT 2
3174: PUSH
3175: LD_INT 30
3177: PUSH
3178: LD_INT 31
3180: PUSH
3181: EMPTY
3182: LIST
3183: LIST
3184: PUSH
3185: LD_INT 30
3187: PUSH
3188: LD_INT 32
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: LIST
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: PPUSH
3204: CALL_OW 69
3208: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3209: LD_ADDR_VAR 0 8
3213: PUSH
3214: LD_INT 22
3216: PUSH
3217: LD_INT 3
3219: PUSH
3220: EMPTY
3221: LIST
3222: LIST
3223: PUSH
3224: LD_INT 30
3226: PUSH
3227: LD_INT 4
3229: PUSH
3230: EMPTY
3231: LIST
3232: LIST
3233: PUSH
3234: EMPTY
3235: LIST
3236: LIST
3237: PPUSH
3238: CALL_OW 69
3242: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3243: LD_ADDR_VAR 0 10
3247: PUSH
3248: LD_INT 22
3250: PUSH
3251: LD_INT 3
3253: PUSH
3254: EMPTY
3255: LIST
3256: LIST
3257: PUSH
3258: LD_INT 30
3260: PUSH
3261: LD_INT 3
3263: PUSH
3264: EMPTY
3265: LIST
3266: LIST
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: PPUSH
3272: CALL_OW 69
3276: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3277: LD_ADDR_VAR 0 9
3281: PUSH
3282: LD_INT 22
3284: PUSH
3285: LD_INT 3
3287: PUSH
3288: EMPTY
3289: LIST
3290: LIST
3291: PUSH
3292: LD_INT 30
3294: PUSH
3295: LD_INT 6
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: PUSH
3302: EMPTY
3303: LIST
3304: LIST
3305: PPUSH
3306: CALL_OW 69
3310: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3311: LD_ADDR_VAR 0 2
3315: PUSH
3316: LD_INT 22
3318: PUSH
3319: LD_INT 3
3321: PUSH
3322: EMPTY
3323: LIST
3324: LIST
3325: PUSH
3326: LD_INT 30
3328: PUSH
3329: LD_INT 1
3331: PUSH
3332: EMPTY
3333: LIST
3334: LIST
3335: PUSH
3336: EMPTY
3337: LIST
3338: LIST
3339: PPUSH
3340: CALL_OW 69
3344: PUSH
3345: FOR_IN
3346: IFFALSE 3390
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3348: LD_VAR 0 2
3352: PPUSH
3353: CALL_OW 274
3357: PPUSH
3358: LD_INT 1
3360: PPUSH
3361: LD_INT 5000
3363: PPUSH
3364: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3368: LD_VAR 0 2
3372: PPUSH
3373: CALL_OW 274
3377: PPUSH
3378: LD_INT 2
3380: PPUSH
3381: LD_INT 3000
3383: PPUSH
3384: CALL_OW 277
// end ;
3388: GO 3345
3390: POP
3391: POP
// uc_side := 3 ;
3392: LD_ADDR_OWVAR 20
3396: PUSH
3397: LD_INT 3
3399: ST_TO_ADDR
// uc_nation := 3 ;
3400: LD_ADDR_OWVAR 21
3404: PUSH
3405: LD_INT 3
3407: ST_TO_ADDR
// skill := [ 2 , 3 , 4 ] [ Difficulty ] ;
3408: LD_ADDR_VAR 0 11
3412: PUSH
3413: LD_INT 2
3415: PUSH
3416: LD_INT 3
3418: PUSH
3419: LD_INT 4
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: LIST
3426: PUSH
3427: LD_OWVAR 67
3431: ARRAY
3432: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3433: LD_ADDR_EXP 51
3437: PUSH
3438: LD_STRING Pokryshkin
3440: PPUSH
3441: LD_INT 0
3443: PPUSH
3444: CALL 474 0 2
3448: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3449: LD_EXP 51
3453: PPUSH
3454: LD_INT 63
3456: PPUSH
3457: LD_INT 21
3459: PPUSH
3460: LD_INT 0
3462: PPUSH
3463: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3467: LD_EXP 51
3471: PPUSH
3472: CALL_OW 140
// InitHc ;
3476: CALL_OW 19
// for i in fac do
3480: LD_ADDR_VAR 0 2
3484: PUSH
3485: LD_VAR 0 10
3489: PUSH
3490: FOR_IN
3491: IFFALSE 3544
// begin for j = 1 to 6 do
3493: LD_ADDR_VAR 0 3
3497: PUSH
3498: DOUBLE
3499: LD_INT 1
3501: DEC
3502: ST_TO_ADDR
3503: LD_INT 6
3505: PUSH
3506: FOR_TO
3507: IFFALSE 3540
// begin PrepareHuman ( false , 3 , skill ) ;
3509: LD_INT 0
3511: PPUSH
3512: LD_INT 3
3514: PPUSH
3515: LD_VAR 0 11
3519: PPUSH
3520: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3524: CALL_OW 44
3528: PPUSH
3529: LD_VAR 0 2
3533: PPUSH
3534: CALL_OW 52
// end ;
3538: GO 3506
3540: POP
3541: POP
// end ;
3542: GO 3490
3544: POP
3545: POP
// for i in lab do
3546: LD_ADDR_VAR 0 2
3550: PUSH
3551: LD_VAR 0 9
3555: PUSH
3556: FOR_IN
3557: IFFALSE 3590
// begin PrepareHuman ( false , 4 , skill ) ;
3559: LD_INT 0
3561: PPUSH
3562: LD_INT 4
3564: PPUSH
3565: LD_VAR 0 11
3569: PPUSH
3570: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3574: CALL_OW 44
3578: PPUSH
3579: LD_VAR 0 2
3583: PPUSH
3584: CALL_OW 52
// end ;
3588: GO 3556
3590: POP
3591: POP
// for i in tw do
3592: LD_ADDR_VAR 0 2
3596: PUSH
3597: LD_VAR 0 7
3601: PUSH
3602: FOR_IN
3603: IFFALSE 3652
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3605: LD_VAR 0 2
3609: PPUSH
3610: LD_INT 42
3612: PUSH
3613: LD_INT 43
3615: PUSH
3616: EMPTY
3617: LIST
3618: LIST
3619: PUSH
3620: LD_INT 1
3622: PPUSH
3623: LD_INT 2
3625: PPUSH
3626: CALL_OW 12
3630: ARRAY
3631: PPUSH
3632: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3636: LD_VAR 0 11
3640: PPUSH
3641: LD_VAR 0 2
3645: PPUSH
3646: CALL 815 0 2
// end ;
3650: GO 3602
3652: POP
3653: POP
// for i in bar do
3654: LD_ADDR_VAR 0 2
3658: PUSH
3659: LD_VAR 0 8
3663: PUSH
3664: FOR_IN
3665: IFFALSE 3698
// begin PrepareHuman ( false , 1 , skill ) ;
3667: LD_INT 0
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: LD_VAR 0 11
3677: PPUSH
3678: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3682: CALL_OW 44
3686: PPUSH
3687: LD_VAR 0 2
3691: PPUSH
3692: CALL_OW 52
// end ;
3696: GO 3664
3698: POP
3699: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3700: LD_ADDR_VAR 0 13
3704: PUSH
3705: LD_INT 100
3707: PUSH
3708: LD_INT 9
3710: PUSH
3711: EMPTY
3712: LIST
3713: LIST
3714: PUSH
3715: LD_INT 135
3717: PUSH
3718: LD_INT 60
3720: PUSH
3721: EMPTY
3722: LIST
3723: LIST
3724: PUSH
3725: LD_INT 41
3727: PUSH
3728: LD_INT 6
3730: PUSH
3731: EMPTY
3732: LIST
3733: LIST
3734: PUSH
3735: LD_INT 22
3737: PUSH
3738: LD_INT 9
3740: PUSH
3741: EMPTY
3742: LIST
3743: LIST
3744: PUSH
3745: LD_INT 84
3747: PUSH
3748: LD_INT 14
3750: PUSH
3751: EMPTY
3752: LIST
3753: LIST
3754: PUSH
3755: EMPTY
3756: LIST
3757: LIST
3758: LIST
3759: LIST
3760: LIST
3761: ST_TO_ADDR
// vehicles := [ ] ;
3762: LD_ADDR_VAR 0 12
3766: PUSH
3767: EMPTY
3768: ST_TO_ADDR
// for i in spot_xy do
3769: LD_ADDR_VAR 0 2
3773: PUSH
3774: LD_VAR 0 13
3778: PUSH
3779: FOR_IN
3780: IFFALSE 3938
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3782: LD_ADDR_VAR 0 6
3786: PUSH
3787: LD_INT 3
3789: PPUSH
3790: LD_INT 3
3792: PPUSH
3793: LD_INT 22
3795: PPUSH
3796: LD_INT 1
3798: PPUSH
3799: LD_INT 1
3801: PPUSH
3802: LD_INT 42
3804: PUSH
3805: LD_INT 43
3807: PUSH
3808: LD_INT 44
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: LIST
3815: PUSH
3816: LD_INT 1
3818: PPUSH
3819: LD_INT 3
3821: PPUSH
3822: CALL_OW 12
3826: ARRAY
3827: PPUSH
3828: LD_INT 100
3830: PPUSH
3831: CALL 537 0 7
3835: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3836: LD_ADDR_VAR 0 12
3840: PUSH
3841: LD_VAR 0 12
3845: PPUSH
3846: LD_VAR 0 12
3850: PUSH
3851: LD_INT 1
3853: PLUS
3854: PPUSH
3855: LD_VAR 0 6
3859: PPUSH
3860: CALL_OW 2
3864: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3865: LD_VAR 0 6
3869: PPUSH
3870: LD_INT 3
3872: PPUSH
3873: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3877: LD_VAR 0 6
3881: PPUSH
3882: LD_VAR 0 2
3886: PUSH
3887: LD_INT 1
3889: ARRAY
3890: PPUSH
3891: LD_VAR 0 2
3895: PUSH
3896: LD_INT 2
3898: ARRAY
3899: PPUSH
3900: LD_INT 0
3902: PPUSH
3903: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3907: LD_INT 0
3909: PPUSH
3910: LD_INT 3
3912: PPUSH
3913: LD_VAR 0 11
3917: PPUSH
3918: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3922: CALL_OW 44
3926: PPUSH
3927: LD_VAR 0 6
3931: PPUSH
3932: CALL_OW 52
// end ;
3936: GO 3779
3938: POP
3939: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3940: LD_ADDR_VAR 0 2
3944: PUSH
3945: DOUBLE
3946: LD_INT 1
3948: DEC
3949: ST_TO_ADDR
3950: LD_INT 5
3952: PUSH
3953: LD_INT 7
3955: PUSH
3956: LD_INT 8
3958: PUSH
3959: EMPTY
3960: LIST
3961: LIST
3962: LIST
3963: PUSH
3964: LD_OWVAR 67
3968: ARRAY
3969: PUSH
3970: FOR_TO
3971: IFFALSE 4031
// begin PrepareHuman ( false , 1 , skill ) ;
3973: LD_INT 0
3975: PPUSH
3976: LD_INT 1
3978: PPUSH
3979: LD_VAR 0 11
3983: PPUSH
3984: CALL_OW 380
// un := CreateHuman ;
3988: LD_ADDR_VAR 0 5
3992: PUSH
3993: CALL_OW 44
3997: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3998: LD_VAR 0 5
4002: PPUSH
4003: LD_INT 11
4005: PPUSH
4006: LD_INT 0
4008: PPUSH
4009: CALL_OW 49
// ru_forest := ru_forest ^ un ;
4013: LD_ADDR_EXP 54
4017: PUSH
4018: LD_EXP 54
4022: PUSH
4023: LD_VAR 0 5
4027: ADD
4028: ST_TO_ADDR
// end ;
4029: GO 3970
4031: POP
4032: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
4033: LD_ADDR_VAR 0 2
4037: PUSH
4038: DOUBLE
4039: LD_INT 1
4041: DEC
4042: ST_TO_ADDR
4043: LD_INT 2
4045: PUSH
4046: LD_INT 3
4048: PUSH
4049: LD_INT 4
4051: PUSH
4052: EMPTY
4053: LIST
4054: LIST
4055: LIST
4056: PUSH
4057: LD_OWVAR 67
4061: ARRAY
4062: PUSH
4063: FOR_TO
4064: IFFALSE 4124
// begin PrepareHuman ( false , 1 , skill ) ;
4066: LD_INT 0
4068: PPUSH
4069: LD_INT 1
4071: PPUSH
4072: LD_VAR 0 11
4076: PPUSH
4077: CALL_OW 380
// un := CreateHuman ;
4081: LD_ADDR_VAR 0 5
4085: PUSH
4086: CALL_OW 44
4090: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
4091: LD_VAR 0 5
4095: PPUSH
4096: LD_INT 12
4098: PPUSH
4099: LD_INT 0
4101: PPUSH
4102: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
4106: LD_ADDR_EXP 52
4110: PUSH
4111: LD_EXP 52
4115: PUSH
4116: LD_VAR 0 5
4120: ADD
4121: ST_TO_ADDR
// end ;
4122: GO 4063
4124: POP
4125: POP
// for i = 1 to 2 do
4126: LD_ADDR_VAR 0 2
4130: PUSH
4131: DOUBLE
4132: LD_INT 1
4134: DEC
4135: ST_TO_ADDR
4136: LD_INT 2
4138: PUSH
4139: FOR_TO
4140: IFFALSE 4206
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4142: LD_INT 1
4144: PPUSH
4145: LD_INT 1
4147: PPUSH
4148: LD_VAR 0 11
4152: PPUSH
4153: CALL_OW 380
// un := CreateHuman ;
4157: LD_ADDR_VAR 0 5
4161: PUSH
4162: CALL_OW 44
4166: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4167: LD_VAR 0 5
4171: PPUSH
4172: LD_INT 39
4174: PPUSH
4175: LD_INT 12
4177: PPUSH
4178: LD_INT 3
4180: PPUSH
4181: LD_INT 0
4183: PPUSH
4184: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4188: LD_ADDR_EXP 53
4192: PUSH
4193: LD_EXP 53
4197: PUSH
4198: LD_VAR 0 5
4202: ADD
4203: ST_TO_ADDR
// end ;
4204: GO 4139
4206: POP
4207: POP
// for i = 1 to 3 do
4208: LD_ADDR_VAR 0 2
4212: PUSH
4213: DOUBLE
4214: LD_INT 1
4216: DEC
4217: ST_TO_ADDR
4218: LD_INT 3
4220: PUSH
4221: FOR_TO
4222: IFFALSE 4288
// begin PrepareHuman ( false , 1 , skill ) ;
4224: LD_INT 0
4226: PPUSH
4227: LD_INT 1
4229: PPUSH
4230: LD_VAR 0 11
4234: PPUSH
4235: CALL_OW 380
// un := CreateHuman ;
4239: LD_ADDR_VAR 0 5
4243: PUSH
4244: CALL_OW 44
4248: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4249: LD_VAR 0 5
4253: PPUSH
4254: LD_INT 180
4256: PPUSH
4257: LD_INT 11
4259: PPUSH
4260: LD_INT 4
4262: PPUSH
4263: LD_INT 0
4265: PPUSH
4266: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4270: LD_ADDR_EXP 57
4274: PUSH
4275: LD_EXP 57
4279: PUSH
4280: LD_VAR 0 5
4284: ADD
4285: ST_TO_ADDR
// end ;
4286: GO 4221
4288: POP
4289: POP
// ru_vehicles := vehicles ;
4290: LD_ADDR_EXP 55
4294: PUSH
4295: LD_VAR 0 12
4299: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4300: LD_ADDR_EXP 58
4304: PUSH
4305: LD_INT 131
4307: PUSH
4308: LD_INT 121
4310: PUSH
4311: EMPTY
4312: LIST
4313: LIST
4314: PUSH
4315: LD_INT 113
4317: PUSH
4318: LD_INT 90
4320: PUSH
4321: EMPTY
4322: LIST
4323: LIST
4324: PUSH
4325: LD_INT 93
4327: PUSH
4328: LD_INT 62
4330: PUSH
4331: EMPTY
4332: LIST
4333: LIST
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: LIST
4339: PUSH
4340: LD_INT 106
4342: PUSH
4343: LD_INT 54
4345: PUSH
4346: EMPTY
4347: LIST
4348: LIST
4349: PUSH
4350: LD_INT 120
4352: PUSH
4353: LD_INT 80
4355: PUSH
4356: EMPTY
4357: LIST
4358: LIST
4359: PUSH
4360: LD_INT 143
4362: PUSH
4363: LD_INT 120
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: LIST
4374: PUSH
4375: LD_INT 154
4377: PUSH
4378: LD_INT 116
4380: PUSH
4381: EMPTY
4382: LIST
4383: LIST
4384: PUSH
4385: LD_INT 140
4387: PUSH
4388: LD_INT 93
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 130
4397: PUSH
4398: LD_INT 58
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: LIST
4409: PUSH
4410: LD_INT 105
4412: PUSH
4413: LD_INT 106
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: LD_INT 134
4422: PUSH
4423: LD_INT 98
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 159
4432: PUSH
4433: LD_INT 113
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: LIST
4444: PUSH
4445: EMPTY
4446: LIST
4447: LIST
4448: LIST
4449: LIST
4450: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4451: LD_ADDR_VAR 0 2
4455: PUSH
4456: DOUBLE
4457: LD_INT 1
4459: DEC
4460: ST_TO_ADDR
4461: LD_OWVAR 67
4465: PUSH
4466: LD_INT 1
4468: MINUS
4469: PUSH
4470: FOR_TO
4471: IFFALSE 4504
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4473: LD_ADDR_EXP 56
4477: PUSH
4478: LD_EXP 56
4482: PUSH
4483: LD_INT 22
4485: PUSH
4486: LD_INT 1
4488: PUSH
4489: LD_INT 1
4491: PUSH
4492: LD_INT 43
4494: PUSH
4495: EMPTY
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: ADD
4501: ST_TO_ADDR
4502: GO 4470
4504: POP
4505: POP
// end ;
4506: LD_VAR 0 1
4510: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4511: LD_INT 22
4513: PUSH
4514: LD_INT 3
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: PUSH
4521: LD_INT 21
4523: PUSH
4524: LD_INT 2
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: PUSH
4531: EMPTY
4532: LIST
4533: LIST
4534: PPUSH
4535: CALL_OW 69
4539: IFFALSE 4633
4541: GO 4543
4543: DISABLE
4544: LD_INT 0
4546: PPUSH
4547: PPUSH
// begin enable ;
4548: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4549: LD_ADDR_VAR 0 2
4553: PUSH
4554: LD_INT 22
4556: PUSH
4557: LD_INT 3
4559: PUSH
4560: EMPTY
4561: LIST
4562: LIST
4563: PUSH
4564: LD_INT 21
4566: PUSH
4567: LD_INT 2
4569: PUSH
4570: EMPTY
4571: LIST
4572: LIST
4573: PUSH
4574: EMPTY
4575: LIST
4576: LIST
4577: PPUSH
4578: CALL_OW 69
4582: ST_TO_ADDR
// if filter then
4583: LD_VAR 0 2
4587: IFFALSE 4633
// for i in filter do
4589: LD_ADDR_VAR 0 1
4593: PUSH
4594: LD_VAR 0 2
4598: PUSH
4599: FOR_IN
4600: IFFALSE 4631
// if GetFuel ( i ) < 20 then
4602: LD_VAR 0 1
4606: PPUSH
4607: CALL_OW 261
4611: PUSH
4612: LD_INT 20
4614: LESS
4615: IFFALSE 4629
// SetFuel ( i , 20 ) ;
4617: LD_VAR 0 1
4621: PPUSH
4622: LD_INT 20
4624: PPUSH
4625: CALL_OW 240
4629: GO 4599
4631: POP
4632: POP
// end ;
4633: PPOPN 2
4635: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4636: LD_EXP 56
4640: IFFALSE 4859
4642: GO 4644
4644: DISABLE
4645: LD_INT 0
4647: PPUSH
4648: PPUSH
4649: PPUSH
// begin enable ;
4650: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4651: LD_ADDR_VAR 0 2
4655: PUSH
4656: LD_INT 22
4658: PUSH
4659: LD_INT 3
4661: PUSH
4662: EMPTY
4663: LIST
4664: LIST
4665: PUSH
4666: LD_INT 30
4668: PUSH
4669: LD_INT 3
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: PPUSH
4680: CALL_OW 69
4684: ST_TO_ADDR
// can_produce := [ ] ;
4685: LD_ADDR_VAR 0 3
4689: PUSH
4690: EMPTY
4691: ST_TO_ADDR
// if not fac then
4692: LD_VAR 0 2
4696: NOT
4697: IFFALSE 4702
// begin disable ;
4699: DISABLE
// exit ;
4700: GO 4859
// end ; for i in fac do
4702: LD_ADDR_VAR 0 1
4706: PUSH
4707: LD_VAR 0 2
4711: PUSH
4712: FOR_IN
4713: IFFALSE 4751
// if UnitsInside ( i ) then
4715: LD_VAR 0 1
4719: PPUSH
4720: CALL_OW 313
4724: IFFALSE 4749
// can_produce := Insert ( can_produce , 1 , i ) ;
4726: LD_ADDR_VAR 0 3
4730: PUSH
4731: LD_VAR 0 3
4735: PPUSH
4736: LD_INT 1
4738: PPUSH
4739: LD_VAR 0 1
4743: PPUSH
4744: CALL_OW 2
4748: ST_TO_ADDR
4749: GO 4712
4751: POP
4752: POP
// if not can_produce then
4753: LD_VAR 0 3
4757: NOT
4758: IFFALSE 4762
// exit ;
4760: GO 4859
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4762: LD_VAR 0 3
4766: PUSH
4767: LD_INT 1
4769: PPUSH
4770: LD_VAR 0 3
4774: PPUSH
4775: CALL_OW 12
4779: ARRAY
4780: PPUSH
4781: LD_EXP 56
4785: PUSH
4786: LD_INT 1
4788: ARRAY
4789: PPUSH
4790: LD_EXP 56
4794: PUSH
4795: LD_INT 2
4797: ARRAY
4798: PPUSH
4799: LD_EXP 56
4803: PUSH
4804: LD_INT 3
4806: ARRAY
4807: PPUSH
4808: LD_EXP 56
4812: PUSH
4813: LD_INT 4
4815: ARRAY
4816: PPUSH
4817: CALL_OW 125
// for i = 1 to 4 do
4821: LD_ADDR_VAR 0 1
4825: PUSH
4826: DOUBLE
4827: LD_INT 1
4829: DEC
4830: ST_TO_ADDR
4831: LD_INT 4
4833: PUSH
4834: FOR_TO
4835: IFFALSE 4857
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4837: LD_ADDR_EXP 56
4841: PUSH
4842: LD_EXP 56
4846: PPUSH
4847: LD_INT 1
4849: PPUSH
4850: CALL_OW 3
4854: ST_TO_ADDR
4855: GO 4834
4857: POP
4858: POP
// end ;
4859: PPOPN 3
4861: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4862: LD_INT 0
4864: PPUSH
4865: PPUSH
4866: PPUSH
// for i = 1 to 6 do
4867: LD_ADDR_VAR 0 2
4871: PUSH
4872: DOUBLE
4873: LD_INT 1
4875: DEC
4876: ST_TO_ADDR
4877: LD_INT 6
4879: PUSH
4880: FOR_TO
4881: IFFALSE 5030
// begin PrepareHuman ( false , 3 , 3 ) ;
4883: LD_INT 0
4885: PPUSH
4886: LD_INT 3
4888: PPUSH
4889: LD_INT 3
4891: PPUSH
4892: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4896: LD_ADDR_VAR 0 3
4900: PUSH
4901: LD_INT 3
4903: PPUSH
4904: LD_INT 3
4906: PPUSH
4907: LD_INT 22
4909: PPUSH
4910: LD_INT 1
4912: PPUSH
4913: LD_INT 1
4915: PPUSH
4916: LD_INT 43
4918: PUSH
4919: LD_INT 42
4921: PUSH
4922: EMPTY
4923: LIST
4924: LIST
4925: PUSH
4926: LD_INT 1
4928: PPUSH
4929: LD_INT 2
4931: PPUSH
4932: CALL_OW 12
4936: ARRAY
4937: PPUSH
4938: LD_INT 70
4940: PPUSH
4941: CALL 537 0 7
4945: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4946: LD_VAR 0 3
4950: PPUSH
4951: LD_INT 4
4953: PPUSH
4954: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4958: LD_VAR 0 3
4962: PPUSH
4963: LD_INT 229
4965: PPUSH
4966: LD_INT 44
4968: PPUSH
4969: LD_INT 0
4971: PPUSH
4972: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4976: CALL_OW 44
4980: PPUSH
4981: LD_VAR 0 3
4985: PPUSH
4986: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4990: LD_ADDR_EXP 55
4994: PUSH
4995: LD_EXP 55
4999: PUSH
5000: LD_VAR 0 3
5004: ADD
5005: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
5006: LD_VAR 0 3
5010: PPUSH
5011: LD_INT 191
5013: PPUSH
5014: LD_INT 32
5016: PPUSH
5017: CALL_OW 111
// Wait ( 0 0$02 ) ;
5021: LD_INT 70
5023: PPUSH
5024: CALL_OW 67
// end ;
5028: GO 4880
5030: POP
5031: POP
// end ;
5032: LD_VAR 0 1
5036: RET
// every 0 0$1 trigger prepare_siege and ru_vehicles do var i , enemy , tmp ;
5037: LD_EXP 30
5041: PUSH
5042: LD_EXP 55
5046: AND
5047: IFFALSE 5221
5049: GO 5051
5051: DISABLE
5052: LD_INT 0
5054: PPUSH
5055: PPUSH
5056: PPUSH
// begin wait ( 0 0$50 ) ;
5057: LD_INT 1750
5059: PPUSH
5060: CALL_OW 67
// tmp := ru_vehicles ;
5064: LD_ADDR_VAR 0 3
5068: PUSH
5069: LD_EXP 55
5073: ST_TO_ADDR
// if not tmp then
5074: LD_VAR 0 3
5078: NOT
5079: IFFALSE 5083
// exit ;
5081: GO 5221
// repeat wait ( 0 0$1 ) ;
5083: LD_INT 35
5085: PPUSH
5086: CALL_OW 67
// for i in tmp do
5090: LD_ADDR_VAR 0 1
5094: PUSH
5095: LD_VAR 0 3
5099: PUSH
5100: FOR_IN
5101: IFFALSE 5212
// begin enemy := NearestUnitToUnit ( [ f_side , 1 ] , i ) ;
5103: LD_ADDR_VAR 0 2
5107: PUSH
5108: LD_INT 22
5110: PUSH
5111: LD_INT 1
5113: PUSH
5114: EMPTY
5115: LIST
5116: LIST
5117: PPUSH
5118: LD_VAR 0 1
5122: PPUSH
5123: CALL_OW 74
5127: ST_TO_ADDR
// if GetDistUnits ( i , enemy ) > 10 then
5128: LD_VAR 0 1
5132: PPUSH
5133: LD_VAR 0 2
5137: PPUSH
5138: CALL_OW 296
5142: PUSH
5143: LD_INT 10
5145: GREATER
5146: IFFALSE 5165
// ComAgressiveMove ( i , 69 , 101 ) else
5148: LD_VAR 0 1
5152: PPUSH
5153: LD_INT 69
5155: PPUSH
5156: LD_INT 101
5158: PPUSH
5159: CALL_OW 114
5163: GO 5179
// ComAttackUnit ( i , enemy ) ;
5165: LD_VAR 0 1
5169: PPUSH
5170: LD_VAR 0 2
5174: PPUSH
5175: CALL_OW 115
// if GetLives ( i ) < 250 then
5179: LD_VAR 0 1
5183: PPUSH
5184: CALL_OW 256
5188: PUSH
5189: LD_INT 250
5191: LESS
5192: IFFALSE 5210
// tmp := tmp diff i ;
5194: LD_ADDR_VAR 0 3
5198: PUSH
5199: LD_VAR 0 3
5203: PUSH
5204: LD_VAR 0 1
5208: DIFF
5209: ST_TO_ADDR
// end ;
5210: GO 5100
5212: POP
5213: POP
// until not tmp ;
5214: LD_VAR 0 3
5218: NOT
5219: IFFALSE 5083
// end ; end_of_file
5221: PPOPN 3
5223: END
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
5224: LD_INT 0
5226: PPUSH
5227: PPUSH
5228: PPUSH
5229: PPUSH
5230: PPUSH
5231: PPUSH
5232: PPUSH
// InGameOn ;
5233: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
5237: LD_EXP 36
5241: PPUSH
5242: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
5246: LD_EXP 36
5250: PPUSH
5251: LD_EXP 43
5255: PPUSH
5256: CALL_OW 119
// if Bierezov then
5260: LD_EXP 44
5264: IFFALSE 5280
// ComTurnUnit ( Bierezov , Cornel ) ;
5266: LD_EXP 44
5270: PPUSH
5271: LD_EXP 43
5275: PPUSH
5276: CALL_OW 119
// for i in jmm_units do
5280: LD_ADDR_VAR 0 2
5284: PUSH
5285: LD_EXP 4
5289: PUSH
5290: FOR_IN
5291: IFFALSE 5309
// ComTurnUnit ( i , Cornel ) ;
5293: LD_VAR 0 2
5297: PPUSH
5298: LD_EXP 43
5302: PPUSH
5303: CALL_OW 119
5307: GO 5290
5309: POP
5310: POP
// units := cornel_units union Cornel ;
5311: LD_ADDR_VAR 0 3
5315: PUSH
5316: LD_EXP 6
5320: PUSH
5321: LD_EXP 43
5325: UNION
5326: ST_TO_ADDR
// repeat wait ( 1 ) ;
5327: LD_INT 1
5329: PPUSH
5330: CALL_OW 67
// for i in units do
5334: LD_ADDR_VAR 0 2
5338: PUSH
5339: LD_VAR 0 3
5343: PUSH
5344: FOR_IN
5345: IFFALSE 5378
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5347: LD_VAR 0 2
5351: PPUSH
5352: LD_EXP 36
5356: PPUSH
5357: CALL_OW 250
5361: PPUSH
5362: LD_EXP 36
5366: PPUSH
5367: CALL_OW 251
5371: PPUSH
5372: CALL_OW 111
5376: GO 5344
5378: POP
5379: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5380: LD_VAR 0 3
5384: PPUSH
5385: LD_INT 92
5387: PUSH
5388: LD_EXP 36
5392: PPUSH
5393: CALL_OW 250
5397: PUSH
5398: LD_EXP 36
5402: PPUSH
5403: CALL_OW 251
5407: PUSH
5408: LD_INT 10
5410: PUSH
5411: EMPTY
5412: LIST
5413: LIST
5414: LIST
5415: LIST
5416: PPUSH
5417: CALL_OW 72
5421: PUSH
5422: LD_VAR 0 3
5426: EQUAL
5427: IFFALSE 5327
// for i in units do
5429: LD_ADDR_VAR 0 2
5433: PUSH
5434: LD_VAR 0 3
5438: PUSH
5439: FOR_IN
5440: IFFALSE 5458
// ComTurnUnit ( i , JMM ) ;
5442: LD_VAR 0 2
5446: PPUSH
5447: LD_EXP 36
5451: PPUSH
5452: CALL_OW 119
5456: GO 5439
5458: POP
5459: POP
// ComTurnUnit ( Cornel , JMM ) ;
5460: LD_EXP 43
5464: PPUSH
5465: LD_EXP 36
5469: PPUSH
5470: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5474: LD_EXP 36
5478: PPUSH
5479: LD_STRING D1-JMM-1
5481: PPUSH
5482: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5486: LD_EXP 43
5490: PPUSH
5491: LD_STRING D1-Corn-1
5493: PPUSH
5494: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5498: LD_EXP 36
5502: PPUSH
5503: LD_EXP 43
5507: PPUSH
5508: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5512: LD_EXP 43
5516: PPUSH
5517: LD_EXP 36
5521: PPUSH
5522: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5526: LD_INT 35
5528: PPUSH
5529: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5533: LD_EXP 36
5537: PPUSH
5538: LD_EXP 43
5542: PPUSH
5543: CALL_OW 296
5547: PUSH
5548: LD_INT 6
5550: LESS
5551: IFFALSE 5526
// ChangeSideFog ( 4 , 1 ) ;
5553: LD_INT 4
5555: PPUSH
5556: LD_INT 1
5558: PPUSH
5559: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5563: LD_EXP 36
5567: PPUSH
5568: LD_EXP 43
5572: PPUSH
5573: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5577: LD_EXP 43
5581: PPUSH
5582: LD_EXP 36
5586: PPUSH
5587: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5591: LD_EXP 36
5595: PPUSH
5596: LD_STRING D1-JMM-2
5598: PPUSH
5599: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5603: LD_EXP 36
5607: PPUSH
5608: LD_STRING D1-JMM-2a
5610: PPUSH
5611: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5615: LD_EXP 43
5619: PPUSH
5620: LD_STRING D1-Corn-2
5622: PPUSH
5623: CALL_OW 88
// if bierezov_exist or debug then
5627: LD_EXP 7
5631: PUSH
5632: LD_EXP 1
5636: OR
5637: IFFALSE 5878
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5639: LD_EXP 43
5643: PPUSH
5644: LD_EXP 44
5648: PPUSH
5649: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5653: LD_INT 10
5655: PPUSH
5656: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5660: LD_EXP 43
5664: PPUSH
5665: LD_STRING D1a-Corn-1
5667: PPUSH
5668: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5672: LD_EXP 36
5676: PPUSH
5677: LD_EXP 44
5681: PPUSH
5682: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5686: LD_EXP 44
5690: PPUSH
5691: LD_EXP 36
5695: PPUSH
5696: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5700: LD_EXP 36
5704: PPUSH
5705: LD_STRING D1a-JMM-1
5707: PPUSH
5708: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5712: LD_EXP 36
5716: PPUSH
5717: LD_EXP 43
5721: PPUSH
5722: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5726: LD_EXP 43
5730: PPUSH
5731: LD_EXP 36
5735: PPUSH
5736: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5740: LD_EXP 43
5744: PPUSH
5745: LD_STRING D1a-Corn-2
5747: PPUSH
5748: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5752: LD_EXP 36
5756: PPUSH
5757: LD_STRING D1a-JMM-2
5759: PPUSH
5760: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5764: LD_EXP 43
5768: PPUSH
5769: LD_STRING D1a-Corn-3
5771: PPUSH
5772: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5776: LD_EXP 36
5780: PPUSH
5781: LD_STRING D1a-JMM-3
5783: PPUSH
5784: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5788: LD_EXP 43
5792: PPUSH
5793: LD_STRING D1a-Corn-4
5795: PPUSH
5796: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5800: LD_EXP 36
5804: PPUSH
5805: LD_STRING D1a-JMM-4
5807: PPUSH
5808: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5812: LD_EXP 43
5816: PPUSH
5817: LD_STRING D1a-Corn-5
5819: PPUSH
5820: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5824: LD_EXP 44
5828: PPUSH
5829: LD_EXP 43
5833: PPUSH
5834: CALL_OW 250
5838: PPUSH
5839: LD_EXP 43
5843: PPUSH
5844: CALL_OW 251
5848: PUSH
5849: LD_INT 2
5851: MINUS
5852: PPUSH
5853: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5857: LD_EXP 44
5861: PPUSH
5862: LD_EXP 43
5866: PPUSH
5867: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5871: LD_INT 10
5873: PPUSH
5874: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5878: LD_EXP 36
5882: PPUSH
5883: LD_STRING D1b-JMM-1
5885: PPUSH
5886: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5890: LD_EXP 43
5894: PPUSH
5895: LD_STRING D1b-Corn-1
5897: PPUSH
5898: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5902: LD_EXP 36
5906: PPUSH
5907: LD_STRING D1b-JMM-2
5909: PPUSH
5910: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5914: LD_EXP 43
5918: PPUSH
5919: LD_STRING D1b-Corn-2
5921: PPUSH
5922: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5926: LD_EXP 36
5930: PPUSH
5931: LD_STRING D1b-JMM-3
5933: PPUSH
5934: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5938: LD_INT 10
5940: PPUSH
5941: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5945: LD_EXP 45
5949: PPUSH
5950: LD_STRING D1b-Pow-3
5952: PPUSH
5953: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5957: LD_EXP 36
5961: PPUSH
5962: LD_STRING D1b-JMM-4
5964: PPUSH
5965: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5969: LD_EXP 43
5973: PPUSH
5974: LD_STRING D1b-Corn-4
5976: PPUSH
5977: CALL_OW 88
// if Khatam then
5981: LD_EXP 40
5985: IFFALSE 6001
// Say ( Khatam , D1b-Khat-4 ) else
5987: LD_EXP 40
5991: PPUSH
5992: LD_STRING D1b-Khat-4
5994: PPUSH
5995: CALL_OW 88
5999: GO 6037
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
6001: LD_EXP 6
6005: PPUSH
6006: LD_INT 26
6008: PUSH
6009: LD_INT 1
6011: PUSH
6012: EMPTY
6013: LIST
6014: LIST
6015: PPUSH
6016: CALL_OW 72
6020: PUSH
6021: LD_EXP 43
6025: PUSH
6026: EMPTY
6027: LIST
6028: DIFF
6029: PPUSH
6030: LD_STRING D1b-Sol1-4
6032: PPUSH
6033: CALL 625 0 2
// if Cyrus then
6037: LD_EXP 38
6041: IFFALSE 6055
// Say ( Cyrus , D1b-Cyrus-4 ) ;
6043: LD_EXP 38
6047: PPUSH
6048: LD_STRING D1b-Cyrus-4
6050: PPUSH
6051: CALL_OW 88
// if Lisa then
6055: LD_EXP 39
6059: IFFALSE 6117
// begin Say ( Lisa , D1b-Lisa-4 ) ;
6061: LD_EXP 39
6065: PPUSH
6066: LD_STRING D1b-Lisa-4
6068: PPUSH
6069: CALL_OW 88
// if Cyrus then
6073: LD_EXP 38
6077: IFFALSE 6117
// begin if not IsInUnit ( Cyrus ) then
6079: LD_EXP 38
6083: PPUSH
6084: CALL_OW 310
6088: NOT
6089: IFFALSE 6105
// ComTurnUnit ( Cyrus , Lisa ) ;
6091: LD_EXP 38
6095: PPUSH
6096: LD_EXP 39
6100: PPUSH
6101: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
6105: LD_EXP 38
6109: PPUSH
6110: LD_STRING D1b-Cyrus-5
6112: PPUSH
6113: CALL_OW 88
// end ; end ; SelectGroup ;
6117: CALL 2606 0 0
// Say ( JMM , D1d-JMM-1 ) ;
6121: LD_EXP 36
6125: PPUSH
6126: LD_STRING D1d-JMM-1
6128: PPUSH
6129: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
6133: LD_EXP 43
6137: PPUSH
6138: LD_STRING D1d-Corn-1
6140: PPUSH
6141: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
6145: LD_ADDR_VAR 0 2
6149: PUSH
6150: LD_EXP 4
6154: PUSH
6155: LD_EXP 6
6159: ADD
6160: PUSH
6161: LD_EXP 36
6165: ADD
6166: PUSH
6167: FOR_IN
6168: IFFALSE 6181
// ComHold ( i ) ;
6170: LD_VAR 0 2
6174: PPUSH
6175: CALL_OW 140
6179: GO 6167
6181: POP
6182: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
6183: LD_ADDR_VAR 0 4
6187: PUSH
6188: LD_INT 22
6190: PUSH
6191: LD_INT 1
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: PUSH
6198: LD_INT 21
6200: PUSH
6201: LD_INT 2
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: PUSH
6208: EMPTY
6209: LIST
6210: LIST
6211: PPUSH
6212: CALL_OW 69
6216: ST_TO_ADDR
// if vehicles then
6217: LD_VAR 0 4
6221: IFFALSE 6559
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
6223: LD_EXP 6
6227: PPUSH
6228: LD_INT 55
6230: PUSH
6231: EMPTY
6232: LIST
6233: PPUSH
6234: CALL_OW 72
6238: IFFALSE 6277
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
6240: LD_ADDR_VAR 0 2
6244: PUSH
6245: LD_EXP 6
6249: PPUSH
6250: LD_INT 55
6252: PUSH
6253: EMPTY
6254: LIST
6255: PPUSH
6256: CALL_OW 72
6260: PUSH
6261: FOR_IN
6262: IFFALSE 6275
// ComExitVehicle ( i ) ;
6264: LD_VAR 0 2
6268: PPUSH
6269: CALL_OW 121
6273: GO 6261
6275: POP
6276: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
6277: LD_ADDR_VAR 0 5
6281: PUSH
6282: LD_VAR 0 4
6286: PPUSH
6287: LD_INT 34
6289: PUSH
6290: LD_INT 51
6292: PUSH
6293: EMPTY
6294: LIST
6295: LIST
6296: PPUSH
6297: CALL_OW 72
6301: ST_TO_ADDR
// if cargos then
6302: LD_VAR 0 5
6306: IFFALSE 6489
// begin vehicles := cargos ;
6308: LD_ADDR_VAR 0 4
6312: PUSH
6313: LD_VAR 0 5
6317: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6318: LD_ADDR_VAR 0 6
6322: PUSH
6323: LD_STRING 02_resources_4
6325: PPUSH
6326: LD_INT 0
6328: PPUSH
6329: CALL_OW 30
6333: ST_TO_ADDR
// if debug and not resources then
6334: LD_EXP 1
6338: PUSH
6339: LD_VAR 0 6
6343: NOT
6344: AND
6345: IFFALSE 6355
// resources := 160 ;
6347: LD_ADDR_VAR 0 6
6351: PUSH
6352: LD_INT 160
6354: ST_TO_ADDR
// if resources mod 10 then
6355: LD_VAR 0 6
6359: PUSH
6360: LD_INT 10
6362: MOD
6363: IFFALSE 6385
// resources := resources - resources mod 10 ;
6365: LD_ADDR_VAR 0 6
6369: PUSH
6370: LD_VAR 0 6
6374: PUSH
6375: LD_VAR 0 6
6379: PUSH
6380: LD_INT 10
6382: MOD
6383: MINUS
6384: ST_TO_ADDR
// if resources then
6385: LD_VAR 0 6
6389: IFFALSE 6489
// for i in cargos do
6391: LD_ADDR_VAR 0 2
6395: PUSH
6396: LD_VAR 0 5
6400: PUSH
6401: FOR_IN
6402: IFFALSE 6487
// begin if resources < 100 then
6404: LD_VAR 0 6
6408: PUSH
6409: LD_INT 100
6411: LESS
6412: IFFALSE 6434
// begin cargo := resources ;
6414: LD_ADDR_VAR 0 7
6418: PUSH
6419: LD_VAR 0 6
6423: ST_TO_ADDR
// resources := 0 ;
6424: LD_ADDR_VAR 0 6
6428: PUSH
6429: LD_INT 0
6431: ST_TO_ADDR
// end else
6432: GO 6456
// begin cargo := 100 ;
6434: LD_ADDR_VAR 0 7
6438: PUSH
6439: LD_INT 100
6441: ST_TO_ADDR
// resources := resources - 100 ;
6442: LD_ADDR_VAR 0 6
6446: PUSH
6447: LD_VAR 0 6
6451: PUSH
6452: LD_INT 100
6454: MINUS
6455: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6456: LD_VAR 0 2
6460: PPUSH
6461: LD_INT 1
6463: PPUSH
6464: LD_VAR 0 7
6468: PPUSH
6469: CALL_OW 290
// if resources = 0 then
6473: LD_VAR 0 6
6477: PUSH
6478: LD_INT 0
6480: EQUAL
6481: IFFALSE 6485
// break ;
6483: GO 6487
// end ;
6485: GO 6401
6487: POP
6488: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6489: LD_VAR 0 4
6493: PUSH
6494: LD_INT 1
6496: ARRAY
6497: PPUSH
6498: CALL_OW 311
6502: PPUSH
6503: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6507: LD_VAR 0 4
6511: PUSH
6512: LD_INT 1
6514: ARRAY
6515: PPUSH
6516: LD_INT 4
6518: PPUSH
6519: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6523: LD_EXP 43
6527: PPUSH
6528: LD_VAR 0 4
6532: PUSH
6533: LD_INT 1
6535: ARRAY
6536: PPUSH
6537: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6541: LD_INT 35
6543: PPUSH
6544: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6548: LD_EXP 43
6552: PPUSH
6553: CALL_OW 310
6557: IFFALSE 6541
// end ; InGameOff ;
6559: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6563: LD_STRING M1
6565: PPUSH
6566: CALL_OW 337
// SaveForQuickRestart ;
6570: CALL_OW 22
// cornel_active := true ;
6574: LD_ADDR_EXP 8
6578: PUSH
6579: LD_INT 1
6581: ST_TO_ADDR
// end ;
6582: LD_VAR 0 1
6586: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns , tmp ;
6587: LD_EXP 36
6591: PPUSH
6592: LD_EXP 46
6596: PPUSH
6597: CALL_OW 296
6601: PUSH
6602: LD_INT 10
6604: LESS
6605: IFFALSE 7988
6607: GO 6609
6609: DISABLE
6610: LD_INT 0
6612: PPUSH
6613: PPUSH
6614: PPUSH
6615: PPUSH
6616: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6617: LD_ADDR_VAR 0 2
6621: PUSH
6622: LD_INT 89
6624: PUSH
6625: LD_INT 34
6627: PUSH
6628: EMPTY
6629: LIST
6630: LIST
6631: PUSH
6632: LD_INT 138
6634: PUSH
6635: LD_INT 63
6637: PUSH
6638: EMPTY
6639: LIST
6640: LIST
6641: PUSH
6642: LD_INT 196
6644: PUSH
6645: LD_INT 84
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 135
6654: PUSH
6655: LD_INT 52
6657: PUSH
6658: EMPTY
6659: LIST
6660: LIST
6661: PUSH
6662: LD_INT 103
6664: PUSH
6665: LD_INT 39
6667: PUSH
6668: EMPTY
6669: LIST
6670: LIST
6671: PUSH
6672: LD_INT 58
6674: PUSH
6675: LD_INT 30
6677: PUSH
6678: EMPTY
6679: LIST
6680: LIST
6681: PUSH
6682: LD_INT 38
6684: PUSH
6685: LD_INT 51
6687: PUSH
6688: EMPTY
6689: LIST
6690: LIST
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: LIST
6698: LIST
6699: LIST
6700: ST_TO_ADDR
// Video ( true ) ;
6701: LD_INT 1
6703: PPUSH
6704: CALL 1185 0 1
// if jmm_units then
6708: LD_EXP 4
6712: IFFALSE 6788
// for i in jmm_units do
6714: LD_ADDR_VAR 0 1
6718: PUSH
6719: LD_EXP 4
6723: PUSH
6724: FOR_IN
6725: IFFALSE 6786
// begin if GetDistUnits ( i , JMM ) < 10 and not IsInUnit ( i ) then
6727: LD_VAR 0 1
6731: PPUSH
6732: LD_EXP 36
6736: PPUSH
6737: CALL_OW 296
6741: PUSH
6742: LD_INT 10
6744: LESS
6745: PUSH
6746: LD_VAR 0 1
6750: PPUSH
6751: CALL_OW 310
6755: NOT
6756: AND
6757: IFFALSE 6775
// ComTurnUnit ( i , JMM ) else
6759: LD_VAR 0 1
6763: PPUSH
6764: LD_EXP 36
6768: PPUSH
6769: CALL_OW 119
6773: GO 6784
// ComHold ( i ) ;
6775: LD_VAR 0 1
6779: PPUSH
6780: CALL_OW 140
// end ;
6784: GO 6724
6786: POP
6787: POP
// if IsInUnit ( JMM ) then
6788: LD_EXP 36
6792: PPUSH
6793: CALL_OW 310
6797: IFFALSE 6822
// begin ComExitVehicle ( JMM ) ;
6799: LD_EXP 36
6803: PPUSH
6804: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6808: LD_EXP 36
6812: PPUSH
6813: LD_EXP 46
6817: PPUSH
6818: CALL_OW 172
// end ; Wait ( 10 ) ;
6822: LD_INT 10
6824: PPUSH
6825: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6829: LD_EXP 36
6833: PPUSH
6834: LD_EXP 46
6838: PPUSH
6839: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6843: LD_INT 35
6845: PPUSH
6846: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6850: LD_EXP 36
6854: PPUSH
6855: LD_EXP 46
6859: PPUSH
6860: CALL_OW 296
6864: PUSH
6865: LD_INT 6
6867: LESS
6868: IFFALSE 6843
// ComTurnUnit ( JMM , Lynch ) ;
6870: LD_EXP 36
6874: PPUSH
6875: LD_EXP 46
6879: PPUSH
6880: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6884: LD_ADDR_VAR 0 1
6888: PUSH
6889: LD_EXP 46
6893: PUSH
6894: LD_EXP 47
6898: PUSH
6899: LD_EXP 48
6903: PUSH
6904: LD_EXP 49
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: LIST
6913: LIST
6914: PUSH
6915: FOR_IN
6916: IFFALSE 6934
// ComTurnUnit ( i , JMM ) ;
6918: LD_VAR 0 1
6922: PPUSH
6923: LD_EXP 36
6927: PPUSH
6928: CALL_OW 119
6932: GO 6915
6934: POP
6935: POP
// Wait ( 0 0$0.3 ) ;
6936: LD_INT 10
6938: PPUSH
6939: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6943: LD_EXP 36
6947: PPUSH
6948: LD_STRING D2-JMM-1
6950: PPUSH
6951: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6955: LD_EXP 46
6959: PPUSH
6960: LD_STRING D2-Sol1-1
6962: PPUSH
6963: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6967: LD_EXP 36
6971: PPUSH
6972: LD_STRING D2-JMM-2
6974: PPUSH
6975: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6979: LD_EXP 46
6983: PPUSH
6984: LD_STRING D2-Sol1-2
6986: PPUSH
6987: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6991: LD_EXP 36
6995: PPUSH
6996: LD_STRING D2-JMM-3
6998: PPUSH
6999: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
7003: LD_EXP 46
7007: PPUSH
7008: LD_STRING D2-Sol1-3
7010: PPUSH
7011: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
7015: LD_ADDR_VAR 0 1
7019: PUSH
7020: LD_INT 22
7022: PUSH
7023: LD_INT 8
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: PPUSH
7030: CALL_OW 69
7034: PUSH
7035: FOR_IN
7036: IFFALSE 7052
// SetSide ( i , 1 ) ;
7038: LD_VAR 0 1
7042: PPUSH
7043: LD_INT 1
7045: PPUSH
7046: CALL_OW 235
7050: GO 7035
7052: POP
7053: POP
// Say ( JMM , D2-JMM-4 ) ;
7054: LD_EXP 36
7058: PPUSH
7059: LD_STRING D2-JMM-4
7061: PPUSH
7062: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
7066: LD_INT 1
7068: PPUSH
7069: LD_INT 5
7071: PPUSH
7072: CALL_OW 332
// for i = 1 to points do
7076: LD_ADDR_VAR 0 1
7080: PUSH
7081: DOUBLE
7082: LD_INT 1
7084: DEC
7085: ST_TO_ADDR
7086: LD_VAR 0 2
7090: PUSH
7091: FOR_TO
7092: IFFALSE 7267
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
7094: LD_VAR 0 2
7098: PUSH
7099: LD_VAR 0 1
7103: ARRAY
7104: PUSH
7105: LD_INT 1
7107: ARRAY
7108: PPUSH
7109: LD_VAR 0 2
7113: PUSH
7114: LD_VAR 0 1
7118: ARRAY
7119: PUSH
7120: LD_INT 2
7122: ARRAY
7123: PPUSH
7124: CALL_OW 84
// if i = 1 then
7128: LD_VAR 0 1
7132: PUSH
7133: LD_INT 1
7135: EQUAL
7136: IFFALSE 7150
// Say ( Lynch , D2-Sol1-4 ) ;
7138: LD_EXP 46
7142: PPUSH
7143: LD_STRING D2-Sol1-4
7145: PPUSH
7146: CALL_OW 88
// if i = 2 then
7150: LD_VAR 0 1
7154: PUSH
7155: LD_INT 2
7157: EQUAL
7158: IFFALSE 7172
// Say ( JMM , D2-JMM-5 ) ;
7160: LD_EXP 36
7164: PPUSH
7165: LD_STRING D2-JMM-5
7167: PPUSH
7168: CALL_OW 88
// if i = 4 then
7172: LD_VAR 0 1
7176: PUSH
7177: LD_INT 4
7179: EQUAL
7180: IFFALSE 7204
// begin RevealFogArea ( 1 , troopsArea ) ;
7182: LD_INT 1
7184: PPUSH
7185: LD_INT 6
7187: PPUSH
7188: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
7192: LD_EXP 46
7196: PPUSH
7197: LD_STRING D2-Sol1-5
7199: PPUSH
7200: CALL_OW 88
// end ; if i = 5 then
7204: LD_VAR 0 1
7208: PUSH
7209: LD_INT 5
7211: EQUAL
7212: IFFALSE 7226
// Say ( JMM , D2-JMM-6 ) ;
7214: LD_EXP 36
7218: PPUSH
7219: LD_STRING D2-JMM-6
7221: PPUSH
7222: CALL_OW 88
// if i = 7 then
7226: LD_VAR 0 1
7230: PUSH
7231: LD_INT 7
7233: EQUAL
7234: IFFALSE 7258
// begin RevealFogArea ( 1 , forestArea ) ;
7236: LD_INT 1
7238: PPUSH
7239: LD_INT 7
7241: PPUSH
7242: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
7246: LD_EXP 46
7250: PPUSH
7251: LD_STRING D2-Sol1-6
7253: PPUSH
7254: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
7258: LD_INT 46
7260: PPUSH
7261: CALL_OW 67
// end ;
7265: GO 7091
7267: POP
7268: POP
// CenterNowOnUnits ( JMM ) ;
7269: LD_EXP 36
7273: PPUSH
7274: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
7278: LD_EXP 36
7282: PPUSH
7283: LD_STRING D2-JMM-7
7285: PPUSH
7286: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
7290: LD_EXP 46
7294: PPUSH
7295: LD_STRING D2-Sol1-7
7297: PPUSH
7298: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
7302: LD_EXP 36
7306: PPUSH
7307: LD_STRING D2-JMM-8
7309: PPUSH
7310: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
7314: LD_ADDR_VAR 0 4
7318: PUSH
7319: LD_INT 22
7321: PUSH
7322: LD_INT 1
7324: PUSH
7325: EMPTY
7326: LIST
7327: LIST
7328: PUSH
7329: LD_INT 30
7331: PUSH
7332: LD_INT 31
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: PUSH
7339: EMPTY
7340: LIST
7341: LIST
7342: PPUSH
7343: CALL_OW 69
7347: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7348: LD_EXP 46
7352: PPUSH
7353: LD_VAR 0 4
7357: PUSH
7358: LD_INT 1
7360: ARRAY
7361: PPUSH
7362: CALL_OW 120
// if HexInfo ( 65 , 101 ) then
7366: LD_INT 65
7368: PPUSH
7369: LD_INT 101
7371: PPUSH
7372: CALL_OW 428
7376: IFFALSE 7399
// ComMoveXY ( HexInfo ( 65 , 101 ) , 75 , 100 ) ;
7378: LD_INT 65
7380: PPUSH
7381: LD_INT 101
7383: PPUSH
7384: CALL_OW 428
7388: PPUSH
7389: LD_INT 75
7391: PPUSH
7392: LD_INT 100
7394: PPUSH
7395: CALL_OW 111
// if HexInfo ( 66 , 103 ) then
7399: LD_INT 66
7401: PPUSH
7402: LD_INT 103
7404: PPUSH
7405: CALL_OW 428
7409: IFFALSE 7432
// ComMoveXY ( HexInfo ( 66 , 103 ) , 75 , 100 ) ;
7411: LD_INT 66
7413: PPUSH
7414: LD_INT 103
7416: PPUSH
7417: CALL_OW 428
7421: PPUSH
7422: LD_INT 75
7424: PPUSH
7425: LD_INT 100
7427: PPUSH
7428: CALL_OW 111
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_dist , JMM , 7 ] ] ) ;
7432: LD_ADDR_VAR 0 5
7436: PUSH
7437: LD_INT 22
7439: PUSH
7440: LD_INT 1
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PUSH
7447: LD_INT 21
7449: PUSH
7450: LD_INT 2
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PUSH
7457: LD_INT 91
7459: PUSH
7460: LD_EXP 36
7464: PUSH
7465: LD_INT 7
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: PPUSH
7478: CALL_OW 69
7482: ST_TO_ADDR
// if tmp then
7483: LD_VAR 0 5
7487: IFFALSE 7504
// ComMoveXY ( tmp , 75 , 100 ) ;
7489: LD_VAR 0 5
7493: PPUSH
7494: LD_INT 75
7496: PPUSH
7497: LD_INT 100
7499: PPUSH
7500: CALL_OW 111
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7504: LD_ADDR_VAR 0 3
7508: PUSH
7509: LD_EXP 4
7513: PPUSH
7514: LD_INT 25
7516: PUSH
7517: LD_INT 1
7519: PUSH
7520: EMPTY
7521: LIST
7522: LIST
7523: PPUSH
7524: CALL_OW 72
7528: PPUSH
7529: LD_EXP 36
7533: PPUSH
7534: CALL_OW 74
7538: ST_TO_ADDR
// if sol then
7539: LD_VAR 0 3
7543: IFFALSE 7603
// if GetDistUnits ( JMM , sol ) < 10 then
7545: LD_EXP 36
7549: PPUSH
7550: LD_VAR 0 3
7554: PPUSH
7555: CALL_OW 296
7559: PUSH
7560: LD_INT 10
7562: LESS
7563: IFFALSE 7603
// begin if IsInUnit ( sol ) then
7565: LD_VAR 0 3
7569: PPUSH
7570: CALL_OW 310
7574: IFFALSE 7585
// ComExitVehicle ( sol ) ;
7576: LD_VAR 0 3
7580: PPUSH
7581: CALL_OW 121
// AddComEnterUnit ( sol , buns [ 2 ] ) ;
7585: LD_VAR 0 3
7589: PPUSH
7590: LD_VAR 0 4
7594: PUSH
7595: LD_INT 2
7597: ARRAY
7598: PPUSH
7599: CALL_OW 180
// end ; Wait ( 0 0$0.3 ) ;
7603: LD_INT 10
7605: PPUSH
7606: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7610: LD_EXP 36
7614: PPUSH
7615: LD_INT 65
7617: PPUSH
7618: LD_INT 101
7620: PPUSH
7621: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7625: LD_EXP 36
7629: PPUSH
7630: LD_INT 63
7632: PPUSH
7633: LD_INT 100
7635: PPUSH
7636: CALL_OW 178
// tmp := 0 0$0 ;
7640: LD_ADDR_VAR 0 5
7644: PUSH
7645: LD_INT 0
7647: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7648: LD_INT 35
7650: PPUSH
7651: CALL_OW 67
// tmp := tmp + 0 0$1 ;
7655: LD_ADDR_VAR 0 5
7659: PUSH
7660: LD_VAR 0 5
7664: PUSH
7665: LD_INT 35
7667: PLUS
7668: ST_TO_ADDR
// until IsAt ( JMM , 65 , 101 ) or tmp > 0 0$5 ;
7669: LD_EXP 36
7673: PPUSH
7674: LD_INT 65
7676: PPUSH
7677: LD_INT 101
7679: PPUSH
7680: CALL_OW 307
7684: PUSH
7685: LD_VAR 0 5
7689: PUSH
7690: LD_INT 175
7692: GREATER
7693: OR
7694: IFFALSE 7648
// Say ( JMM , D2a-JMM-1 ) ;
7696: LD_EXP 36
7700: PPUSH
7701: LD_STRING D2a-JMM-1
7703: PPUSH
7704: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7708: LD_EXP 47
7712: PPUSH
7713: LD_INT 66
7715: PPUSH
7716: LD_INT 103
7718: PPUSH
7719: CALL_OW 111
// tmp := 0 0$0 ;
7723: LD_ADDR_VAR 0 5
7727: PUSH
7728: LD_INT 0
7730: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
7731: LD_INT 35
7733: PPUSH
7734: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) or tmp > 0 0$5 ;
7738: LD_EXP 47
7742: PPUSH
7743: LD_INT 66
7745: PPUSH
7746: LD_INT 103
7748: PPUSH
7749: CALL_OW 307
7753: PUSH
7754: LD_VAR 0 5
7758: PUSH
7759: LD_INT 175
7761: GREATER
7762: OR
7763: IFFALSE 7731
// ComTurnUnit ( Walker , JMM ) ;
7765: LD_EXP 47
7769: PPUSH
7770: LD_EXP 36
7774: PPUSH
7775: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7779: LD_EXP 47
7783: PPUSH
7784: LD_STRING D2a-Sci1-1
7786: PPUSH
7787: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7791: LD_EXP 36
7795: PPUSH
7796: LD_EXP 47
7800: PPUSH
7801: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7805: LD_EXP 36
7809: PPUSH
7810: LD_STRING D2a-JMM-2
7812: PPUSH
7813: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7817: LD_EXP 47
7821: PPUSH
7822: LD_STRING D2a-Sci1-2
7824: PPUSH
7825: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7829: LD_EXP 36
7833: PPUSH
7834: LD_STRING D2a-JMM-3
7836: PPUSH
7837: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7841: LD_EXP 47
7845: PPUSH
7846: LD_STRING D2a-Sci1-3
7848: PPUSH
7849: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7853: LD_ADDR_EXP 4
7857: PUSH
7858: LD_EXP 4
7862: PUSH
7863: LD_EXP 46
7867: PUSH
7868: LD_EXP 47
7872: PUSH
7873: LD_EXP 48
7877: PUSH
7878: LD_EXP 49
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: LIST
7887: LIST
7888: ADD
7889: ST_TO_ADDR
// for i in jmm_units do
7890: LD_ADDR_VAR 0 1
7894: PUSH
7895: LD_EXP 4
7899: PUSH
7900: FOR_IN
7901: IFFALSE 7926
// if not IsInUnit ( i ) then
7903: LD_VAR 0 1
7907: PPUSH
7908: CALL_OW 310
7912: NOT
7913: IFFALSE 7924
// ComFree ( i ) ;
7915: LD_VAR 0 1
7919: PPUSH
7920: CALL_OW 139
7924: GO 7900
7926: POP
7927: POP
// Video ( false ) ;
7928: LD_INT 0
7930: PPUSH
7931: CALL 1185 0 1
// ChangeMissionObjectives ( MSolar1 ) ;
7935: LD_STRING MSolar1
7937: PPUSH
7938: CALL_OW 337
// jmm_on_west := true ;
7942: LD_ADDR_EXP 5
7946: PUSH
7947: LD_INT 1
7949: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7950: LD_INT 1050
7952: PPUSH
7953: CALL_OW 67
// frank_can_return := true ;
7957: LD_ADDR_EXP 12
7961: PUSH
7962: LD_INT 1
7964: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7965: LD_INT 6300
7967: PPUSH
7968: LD_INT 8400
7970: PPUSH
7971: CALL_OW 12
7975: PPUSH
7976: CALL_OW 67
// send_spec_patrol := true ;
7980: LD_ADDR_EXP 29
7984: PUSH
7985: LD_INT 1
7987: ST_TO_ADDR
// end ;
7988: PPOPN 5
7990: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7991: LD_INT 22
7993: PUSH
7994: LD_INT 1
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: PUSH
8001: LD_INT 34
8003: PUSH
8004: LD_INT 51
8006: PUSH
8007: EMPTY
8008: LIST
8009: LIST
8010: PUSH
8011: LD_INT 92
8013: PUSH
8014: LD_INT 63
8016: PUSH
8017: LD_INT 100
8019: PUSH
8020: LD_INT 5
8022: PUSH
8023: EMPTY
8024: LIST
8025: LIST
8026: LIST
8027: LIST
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: LIST
8033: PUSH
8034: EMPTY
8035: LIST
8036: PPUSH
8037: CALL_OW 69
8041: PUSH
8042: LD_EXP 5
8046: NOT
8047: AND
8048: IFFALSE 8161
8050: GO 8052
8052: DISABLE
8053: LD_INT 0
8055: PPUSH
8056: PPUSH
// begin enable ;
8057: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
8058: LD_ADDR_VAR 0 2
8062: PUSH
8063: LD_INT 22
8065: PUSH
8066: LD_INT 1
8068: PUSH
8069: EMPTY
8070: LIST
8071: LIST
8072: PUSH
8073: LD_INT 34
8075: PUSH
8076: LD_INT 51
8078: PUSH
8079: EMPTY
8080: LIST
8081: LIST
8082: PUSH
8083: LD_INT 92
8085: PUSH
8086: LD_INT 63
8088: PUSH
8089: LD_INT 100
8091: PUSH
8092: LD_INT 5
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: PUSH
8101: EMPTY
8102: LIST
8103: LIST
8104: LIST
8105: PUSH
8106: EMPTY
8107: LIST
8108: PPUSH
8109: CALL_OW 69
8113: ST_TO_ADDR
// if not filter then
8114: LD_VAR 0 2
8118: NOT
8119: IFFALSE 8123
// exit ;
8121: GO 8161
// for i in filter do
8123: LD_ADDR_VAR 0 1
8127: PUSH
8128: LD_VAR 0 2
8132: PUSH
8133: FOR_IN
8134: IFFALSE 8159
// begin SetFuel ( i , 0 ) ;
8136: LD_VAR 0 1
8140: PPUSH
8141: LD_INT 0
8143: PPUSH
8144: CALL_OW 240
// ComStop ( i ) ;
8148: LD_VAR 0 1
8152: PPUSH
8153: CALL_OW 141
// end ;
8157: GO 8133
8159: POP
8160: POP
// end ;
8161: PPOPN 2
8163: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
8164: LD_EXP 29
8168: IFFALSE 9161
8170: GO 8172
8172: DISABLE
8173: LD_INT 0
8175: PPUSH
8176: PPUSH
8177: PPUSH
8178: PPUSH
8179: PPUSH
8180: PPUSH
8181: PPUSH
// begin if not ru_spec_patrol then
8182: LD_EXP 53
8186: NOT
8187: IFFALSE 8191
// exit ;
8189: GO 9161
// dead1 := false ;
8191: LD_ADDR_VAR 0 1
8195: PUSH
8196: LD_INT 0
8198: ST_TO_ADDR
// dead2 := false ;
8199: LD_ADDR_VAR 0 2
8203: PUSH
8204: LD_INT 0
8206: ST_TO_ADDR
// inarea1 := false ;
8207: LD_ADDR_VAR 0 3
8211: PUSH
8212: LD_INT 0
8214: ST_TO_ADDR
// inarea2 := false ;
8215: LD_ADDR_VAR 0 4
8219: PUSH
8220: LD_INT 0
8222: ST_TO_ADDR
// tmp := [ ] ;
8223: LD_ADDR_VAR 0 6
8227: PUSH
8228: EMPTY
8229: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
8230: LD_EXP 53
8234: PPUSH
8235: LD_INT 75
8237: PPUSH
8238: LD_INT 101
8240: PPUSH
8241: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
8245: LD_INT 35
8247: PPUSH
8248: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
8252: LD_INT 1
8254: PPUSH
8255: LD_EXP 53
8259: PUSH
8260: LD_INT 1
8262: ARRAY
8263: PPUSH
8264: CALL_OW 292
8268: IFFALSE 8245
// ComStop ( ru_spec_patrol ) ;
8270: LD_EXP 53
8274: PPUSH
8275: CALL_OW 141
// Wait ( 0 0$02 ) ;
8279: LD_INT 70
8281: PPUSH
8282: CALL_OW 67
// DialogueOn ;
8286: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
8290: LD_EXP 53
8294: PUSH
8295: LD_INT 1
8297: ARRAY
8298: PPUSH
8299: LD_STRING D8-Rus1-1
8301: PPUSH
8302: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
8306: LD_EXP 36
8310: PPUSH
8311: LD_STRING D8-JMM-1
8313: PPUSH
8314: CALL_OW 88
// DialogueOff ;
8318: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
8322: LD_EXP 53
8326: PPUSH
8327: LD_INT 13
8329: PPUSH
8330: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
8334: LD_INT 35
8336: PPUSH
8337: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
8341: LD_VAR 0 1
8345: NOT
8346: PUSH
8347: LD_EXP 53
8351: PUSH
8352: LD_INT 1
8354: ARRAY
8355: PPUSH
8356: CALL_OW 301
8360: AND
8361: IFFALSE 8371
// dead1 := true ;
8363: LD_ADDR_VAR 0 1
8367: PUSH
8368: LD_INT 1
8370: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
8371: LD_VAR 0 2
8375: NOT
8376: PUSH
8377: LD_EXP 53
8381: PUSH
8382: LD_INT 2
8384: ARRAY
8385: PPUSH
8386: CALL_OW 301
8390: AND
8391: IFFALSE 8401
// dead2 := true ;
8393: LD_ADDR_VAR 0 2
8397: PUSH
8398: LD_INT 1
8400: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
8401: LD_VAR 0 3
8405: NOT
8406: PUSH
8407: LD_EXP 53
8411: PUSH
8412: LD_INT 1
8414: ARRAY
8415: PPUSH
8416: LD_INT 14
8418: PPUSH
8419: CALL_OW 308
8423: AND
8424: IFFALSE 8434
// inarea1 := true ;
8426: LD_ADDR_VAR 0 3
8430: PUSH
8431: LD_INT 1
8433: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
8434: LD_VAR 0 4
8438: NOT
8439: PUSH
8440: LD_EXP 53
8444: PUSH
8445: LD_INT 2
8447: ARRAY
8448: PPUSH
8449: LD_INT 14
8451: PPUSH
8452: CALL_OW 308
8456: AND
8457: IFFALSE 8467
// inarea2 := true ;
8459: LD_ADDR_VAR 0 4
8463: PUSH
8464: LD_INT 1
8466: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
8467: LD_VAR 0 1
8471: PUSH
8472: LD_VAR 0 2
8476: AND
8477: PUSH
8478: LD_VAR 0 1
8482: PUSH
8483: LD_VAR 0 4
8487: AND
8488: OR
8489: PUSH
8490: LD_VAR 0 2
8494: PUSH
8495: LD_VAR 0 3
8499: AND
8500: OR
8501: PUSH
8502: LD_VAR 0 3
8506: PUSH
8507: LD_VAR 0 4
8511: AND
8512: OR
8513: IFFALSE 8334
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
8515: LD_VAR 0 3
8519: PUSH
8520: LD_VAR 0 4
8524: AND
8525: PUSH
8526: LD_VAR 0 1
8530: PUSH
8531: LD_VAR 0 4
8535: AND
8536: OR
8537: PUSH
8538: LD_VAR 0 2
8542: PUSH
8543: LD_VAR 0 3
8547: AND
8548: OR
8549: IFFALSE 9141
// begin prepare_siege := true ;
8551: LD_ADDR_EXP 30
8555: PUSH
8556: LD_INT 1
8558: ST_TO_ADDR
// DialogueOn ;
8559: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8563: LD_VAR 0 3
8567: PUSH
8568: LD_VAR 0 4
8572: AND
8573: IFFALSE 8589
// Say ( JMM , D8b-JMM-1a ) else
8575: LD_EXP 36
8579: PPUSH
8580: LD_STRING D8b-JMM-1a
8582: PPUSH
8583: CALL_OW 88
8587: GO 8601
// Say ( JMM , D8b-JMM-1 ) ;
8589: LD_EXP 36
8593: PPUSH
8594: LD_STRING D8b-JMM-1
8596: PPUSH
8597: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8601: LD_EXP 4
8605: PPUSH
8606: LD_INT 26
8608: PUSH
8609: LD_INT 1
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: PPUSH
8616: CALL_OW 72
8620: PUSH
8621: LD_EXP 37
8625: PUSH
8626: LD_EXP 38
8630: PUSH
8631: LD_EXP 47
8635: PUSH
8636: LD_EXP 50
8640: PUSH
8641: EMPTY
8642: LIST
8643: LIST
8644: LIST
8645: LIST
8646: DIFF
8647: PPUSH
8648: LD_STRING D8b-Sol1-1
8650: PPUSH
8651: CALL 625 0 2
// if Cyrus and Cyrus in jmm_units then
8655: LD_EXP 38
8659: PUSH
8660: LD_EXP 38
8664: PUSH
8665: LD_EXP 4
8669: IN
8670: AND
8671: IFFALSE 8687
// Say ( Cyrus , D8b-Cyrus-1 ) else
8673: LD_EXP 38
8677: PPUSH
8678: LD_STRING D8b-Cyrus-1
8680: PPUSH
8681: CALL_OW 88
8685: GO 8699
// Say ( JMM , D8b-JMM-1a ) ;
8687: LD_EXP 36
8691: PPUSH
8692: LD_STRING D8b-JMM-1a
8694: PPUSH
8695: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8699: LD_EXP 39
8703: PUSH
8704: LD_EXP 39
8708: PUSH
8709: LD_EXP 4
8713: IN
8714: AND
8715: IFFALSE 8729
// Say ( Lisa , D8b-Lisa-2 ) ;
8717: LD_EXP 39
8721: PPUSH
8722: LD_STRING D8b-Lisa-2
8724: PPUSH
8725: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8729: LD_EXP 37
8733: PUSH
8734: LD_EXP 37
8738: PUSH
8739: LD_EXP 4
8743: IN
8744: AND
8745: IFFALSE 8761
// Say ( Bobby , D8b-Bobby-1 ) else
8747: LD_EXP 37
8751: PPUSH
8752: LD_STRING D8b-Bobby-1
8754: PPUSH
8755: CALL_OW 88
8759: GO 8821
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8761: LD_ADDR_VAR 0 5
8765: PUSH
8766: LD_EXP 4
8770: PPUSH
8771: LD_INT 26
8773: PUSH
8774: LD_INT 1
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PPUSH
8781: CALL_OW 72
8785: PUSH
8786: LD_EXP 37
8790: PUSH
8791: LD_EXP 38
8795: PUSH
8796: LD_EXP 47
8800: PUSH
8801: LD_EXP 50
8805: PUSH
8806: EMPTY
8807: LIST
8808: LIST
8809: LIST
8810: LIST
8811: DIFF
8812: PPUSH
8813: LD_STRING D8b-Sol2-1
8815: PPUSH
8816: CALL 625 0 2
8820: ST_TO_ADDR
// DialogueOff ;
8821: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8825: LD_EXP 38
8829: PUSH
8830: LD_EXP 38
8834: PUSH
8835: LD_EXP 4
8839: IN
8840: AND
8841: IFFALSE 8866
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8843: LD_ADDR_VAR 0 6
8847: PUSH
8848: LD_VAR 0 6
8852: PPUSH
8853: LD_INT 1
8855: PPUSH
8856: LD_EXP 38
8860: PPUSH
8861: CALL_OW 2
8865: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8866: LD_EXP 37
8870: PUSH
8871: LD_EXP 37
8875: PUSH
8876: LD_EXP 4
8880: IN
8881: AND
8882: IFFALSE 8907
// tmp := Insert ( tmp , 1 , Bobby ) ;
8884: LD_ADDR_VAR 0 6
8888: PUSH
8889: LD_VAR 0 6
8893: PPUSH
8894: LD_INT 1
8896: PPUSH
8897: LD_EXP 37
8901: PPUSH
8902: CALL_OW 2
8906: ST_TO_ADDR
// if sol then
8907: LD_VAR 0 5
8911: IFFALSE 8936
// tmp := Insert ( tmp , 1 , sol ) ;
8913: LD_ADDR_VAR 0 6
8917: PUSH
8918: LD_VAR 0 6
8922: PPUSH
8923: LD_INT 1
8925: PPUSH
8926: LD_VAR 0 5
8930: PPUSH
8931: CALL_OW 2
8935: ST_TO_ADDR
// if tmp then
8936: LD_VAR 0 6
8940: IFFALSE 9100
// begin SetSide ( tmp , 8 ) ;
8942: LD_VAR 0 6
8946: PPUSH
8947: LD_INT 8
8949: PPUSH
8950: CALL_OW 235
// ComFree ( tmp ) ;
8954: LD_VAR 0 6
8958: PPUSH
8959: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8963: LD_VAR 0 6
8967: PPUSH
8968: LD_INT 15
8970: PPUSH
8971: CALL_OW 173
// AddComHold ( tmp ) ;
8975: LD_VAR 0 6
8979: PPUSH
8980: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8984: LD_INT 35
8986: PPUSH
8987: CALL_OW 67
// if not HasTask ( tmp [ 1 ] ) then
8991: LD_VAR 0 6
8995: PUSH
8996: LD_INT 1
8998: ARRAY
8999: PPUSH
9000: CALL_OW 314
9004: NOT
9005: IFFALSE 9019
// ComMoveToArea ( tmp , cyrusEscape ) ;
9007: LD_VAR 0 6
9011: PPUSH
9012: LD_INT 15
9014: PPUSH
9015: CALL_OW 113
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
9019: LD_VAR 0 6
9023: PUSH
9024: LD_INT 1
9026: ARRAY
9027: PPUSH
9028: LD_INT 15
9030: PPUSH
9031: CALL_OW 308
9035: IFFALSE 9090
// begin RemoveUnit ( tmp [ 1 ] ) ;
9037: LD_VAR 0 6
9041: PUSH
9042: LD_INT 1
9044: ARRAY
9045: PPUSH
9046: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
9050: LD_ADDR_EXP 4
9054: PUSH
9055: LD_EXP 4
9059: PUSH
9060: LD_VAR 0 6
9064: PUSH
9065: LD_INT 1
9067: ARRAY
9068: DIFF
9069: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
9070: LD_ADDR_VAR 0 6
9074: PUSH
9075: LD_VAR 0 6
9079: PUSH
9080: LD_VAR 0 6
9084: PUSH
9085: LD_INT 1
9087: ARRAY
9088: DIFF
9089: ST_TO_ADDR
// end ; until tmp = 0 ;
9090: LD_VAR 0 6
9094: PUSH
9095: LD_INT 0
9097: EQUAL
9098: IFFALSE 8984
// end ; Wait ( 0 0$30 ) ;
9100: LD_INT 1050
9102: PPUSH
9103: CALL_OW 67
// if ru_spec_patrol then
9107: LD_EXP 53
9111: IFFALSE 9139
// for i in ru_spec_patrol do
9113: LD_ADDR_VAR 0 7
9117: PUSH
9118: LD_EXP 53
9122: PUSH
9123: FOR_IN
9124: IFFALSE 9137
// RemoveUnit ( i ) ;
9126: LD_VAR 0 7
9130: PPUSH
9131: CALL_OW 64
9135: GO 9123
9137: POP
9138: POP
// end else
9139: GO 9161
// begin prepare_siege := false ;
9141: LD_ADDR_EXP 30
9145: PUSH
9146: LD_INT 0
9148: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
9149: LD_EXP 36
9153: PPUSH
9154: LD_STRING D8a-JMM-1
9156: PPUSH
9157: CALL_OW 88
// end ; end ;
9161: PPOPN 7
9163: END
// every 0 0$10 trigger frank_can_return do var i , p , points ;
9164: LD_EXP 12
9168: IFFALSE 10385
9170: GO 9172
9172: DISABLE
9173: LD_INT 0
9175: PPUSH
9176: PPUSH
9177: PPUSH
// begin uc_side := 8 ;
9178: LD_ADDR_OWVAR 20
9182: PUSH
9183: LD_INT 8
9185: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
9186: LD_ADDR_VAR 0 3
9190: PUSH
9191: LD_INT 59
9193: PUSH
9194: LD_INT 71
9196: PUSH
9197: EMPTY
9198: LIST
9199: LIST
9200: PUSH
9201: LD_INT 122
9203: PUSH
9204: LD_INT 117
9206: PUSH
9207: EMPTY
9208: LIST
9209: LIST
9210: PUSH
9211: EMPTY
9212: LIST
9213: LIST
9214: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9215: LD_ADDR_EXP 50
9219: PUSH
9220: LD_STRING Frank
9222: PPUSH
9223: LD_INT 0
9225: PPUSH
9226: CALL 474 0 2
9230: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
9231: LD_ADDR_VAR 0 1
9235: PUSH
9236: LD_INT 1
9238: PPUSH
9239: LD_INT 2
9241: PPUSH
9242: CALL_OW 12
9246: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
9247: LD_EXP 50
9251: PPUSH
9252: LD_VAR 0 3
9256: PUSH
9257: LD_VAR 0 1
9261: ARRAY
9262: PUSH
9263: LD_INT 1
9265: ARRAY
9266: PPUSH
9267: LD_VAR 0 3
9271: PUSH
9272: LD_VAR 0 1
9276: ARRAY
9277: PUSH
9278: LD_INT 2
9280: ARRAY
9281: PPUSH
9282: LD_INT 0
9284: PPUSH
9285: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
9289: LD_EXP 50
9293: PPUSH
9294: LD_INT 1
9296: PPUSH
9297: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
9301: LD_INT 35
9303: PPUSH
9304: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 and GetLives ( Frank ) > 250 ;
9308: LD_EXP 50
9312: PPUSH
9313: LD_EXP 36
9317: PPUSH
9318: CALL_OW 296
9322: PUSH
9323: LD_INT 8
9325: LESS
9326: PUSH
9327: LD_EXP 50
9331: PPUSH
9332: CALL_OW 256
9336: PUSH
9337: LD_INT 250
9339: GREATER
9340: AND
9341: IFFALSE 9301
// Video ( true ) ;
9343: LD_INT 1
9345: PPUSH
9346: CALL 1185 0 1
// CenterOnUnits ( JMM ) ;
9350: LD_EXP 36
9354: PPUSH
9355: CALL_OW 85
// if IsInUnit ( JMM ) then
9359: LD_EXP 36
9363: PPUSH
9364: CALL_OW 310
9368: IFFALSE 9379
// ComFree ( JMM ) ;
9370: LD_EXP 36
9374: PPUSH
9375: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
9379: LD_EXP 36
9383: PPUSH
9384: LD_EXP 50
9388: PPUSH
9389: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
9393: LD_EXP 50
9397: PPUSH
9398: LD_EXP 36
9402: PPUSH
9403: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
9407: LD_EXP 36
9411: PPUSH
9412: LD_STRING D6-JMM-1
9414: PPUSH
9415: CALL_OW 88
// p := 0 ;
9419: LD_ADDR_VAR 0 2
9423: PUSH
9424: LD_INT 0
9426: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9427: LD_INT 35
9429: PPUSH
9430: CALL_OW 67
// p := p + 1 ;
9434: LD_ADDR_VAR 0 2
9438: PUSH
9439: LD_VAR 0 2
9443: PUSH
9444: LD_INT 1
9446: PLUS
9447: ST_TO_ADDR
// until GetDistUnits ( JMM , Frank ) < 8 or p > 7 ;
9448: LD_EXP 36
9452: PPUSH
9453: LD_EXP 50
9457: PPUSH
9458: CALL_OW 296
9462: PUSH
9463: LD_INT 8
9465: LESS
9466: PUSH
9467: LD_VAR 0 2
9471: PUSH
9472: LD_INT 7
9474: GREATER
9475: OR
9476: IFFALSE 9427
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
9478: LD_EXP 39
9482: PUSH
9483: LD_EXP 39
9487: PPUSH
9488: LD_EXP 50
9492: PPUSH
9493: CALL_OW 296
9497: PUSH
9498: LD_INT 20
9500: LESS
9501: AND
9502: IFFALSE 9527
// begin ComFree ( Lisa ) ;
9504: LD_EXP 39
9508: PPUSH
9509: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
9513: LD_EXP 39
9517: PPUSH
9518: LD_EXP 50
9522: PPUSH
9523: CALL_OW 172
// end ; if Lynch then
9527: LD_EXP 46
9531: IFFALSE 9556
// begin ComFree ( Lynch ) ;
9533: LD_EXP 46
9537: PPUSH
9538: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
9542: LD_EXP 46
9546: PPUSH
9547: LD_EXP 50
9551: PPUSH
9552: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
9556: LD_EXP 36
9560: PPUSH
9561: LD_EXP 50
9565: PPUSH
9566: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9570: LD_EXP 50
9574: PPUSH
9575: LD_EXP 36
9579: PPUSH
9580: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
9584: LD_EXP 50
9588: PPUSH
9589: LD_STRING D6-Frank-1
9591: PPUSH
9592: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
9596: LD_INT 69
9598: PPUSH
9599: LD_INT 20
9601: PPUSH
9602: LD_INT 1
9604: PPUSH
9605: LD_INT 20
9607: NEG
9608: PPUSH
9609: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
9613: LD_INT 69
9615: PPUSH
9616: LD_INT 20
9618: PPUSH
9619: LD_INT 1
9621: PPUSH
9622: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9626: LD_INT 190
9628: PPUSH
9629: LD_INT 31
9631: PPUSH
9632: LD_INT 1
9634: PPUSH
9635: LD_INT 20
9637: NEG
9638: PPUSH
9639: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9643: LD_INT 190
9645: PPUSH
9646: LD_INT 31
9648: PPUSH
9649: LD_INT 1
9651: PPUSH
9652: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9656: LD_INT 69
9658: PPUSH
9659: LD_INT 20
9661: PPUSH
9662: CALL_OW 84
// Wait ( 0 0$02 ) ;
9666: LD_INT 70
9668: PPUSH
9669: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9673: LD_EXP 36
9677: PPUSH
9678: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9682: LD_EXP 39
9686: PUSH
9687: LD_EXP 39
9691: PPUSH
9692: LD_EXP 50
9696: PPUSH
9697: CALL_OW 296
9701: PUSH
9702: LD_INT 20
9704: LESS
9705: AND
9706: PUSH
9707: LD_EXP 39
9711: PPUSH
9712: CALL_OW 302
9716: AND
9717: IFFALSE 9839
// begin ComFree ( Lisa ) ;
9719: LD_EXP 39
9723: PPUSH
9724: CALL_OW 139
// p := 0 ;
9728: LD_ADDR_VAR 0 2
9732: PUSH
9733: LD_INT 0
9735: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9736: LD_INT 35
9738: PPUSH
9739: CALL_OW 67
// p := p + 1 ;
9743: LD_ADDR_VAR 0 2
9747: PUSH
9748: LD_VAR 0 2
9752: PUSH
9753: LD_INT 1
9755: PLUS
9756: ST_TO_ADDR
// until GetDistUnits ( Lisa , Frank ) < 7 or p > 7 ;
9757: LD_EXP 39
9761: PPUSH
9762: LD_EXP 50
9766: PPUSH
9767: CALL_OW 296
9771: PUSH
9772: LD_INT 7
9774: LESS
9775: PUSH
9776: LD_VAR 0 2
9780: PUSH
9781: LD_INT 7
9783: GREATER
9784: OR
9785: IFFALSE 9736
// Say ( Lisa , D6-Lisa-1 ) ;
9787: LD_EXP 39
9791: PPUSH
9792: LD_STRING D6-Lisa-1
9794: PPUSH
9795: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9799: LD_EXP 39
9803: PPUSH
9804: LD_EXP 50
9808: PPUSH
9809: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9813: LD_EXP 50
9817: PPUSH
9818: LD_EXP 39
9822: PPUSH
9823: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9827: LD_EXP 50
9831: PPUSH
9832: LD_STRING D6-Frank-2
9834: PPUSH
9835: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9839: LD_EXP 46
9843: PUSH
9844: LD_EXP 46
9848: PPUSH
9849: LD_EXP 50
9853: PPUSH
9854: CALL_OW 296
9858: PUSH
9859: LD_INT 20
9861: LESS
9862: AND
9863: PUSH
9864: LD_EXP 46
9868: PPUSH
9869: CALL_OW 302
9873: AND
9874: IFFALSE 10055
// begin ComTurnUnit ( Lynch , JMM ) ;
9876: LD_EXP 46
9880: PPUSH
9881: LD_EXP 36
9885: PPUSH
9886: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9890: LD_EXP 50
9894: PPUSH
9895: LD_EXP 36
9899: PPUSH
9900: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9904: LD_EXP 46
9908: PPUSH
9909: LD_STRING D6-Sol1-2
9911: PPUSH
9912: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9916: LD_EXP 36
9920: PPUSH
9921: LD_STRING D6-JMM-2
9923: PPUSH
9924: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9928: LD_EXP 50
9932: PPUSH
9933: LD_STRING D6-Frank-3
9935: PPUSH
9936: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9940: LD_EXP 36
9944: PPUSH
9945: LD_STRING D6-JMM-3
9947: PPUSH
9948: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9952: LD_EXP 50
9956: PPUSH
9957: LD_STRING D6-Frank-4
9959: PPUSH
9960: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9964: LD_EXP 50
9968: PPUSH
9969: LD_STRING D6-Frank-4a
9971: PPUSH
9972: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9976: LD_EXP 36
9980: PPUSH
9981: LD_STRING D6-JMM-4
9983: PPUSH
9984: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9988: LD_EXP 50
9992: PPUSH
9993: LD_STRING D6-Frank-5
9995: PPUSH
9996: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10000: LD_EXP 39
10004: PUSH
10005: LD_EXP 39
10009: PPUSH
10010: CALL_OW 302
10014: AND
10015: IFFALSE 10029
// Say ( Lisa , D6-Lisa-5 ) ;
10017: LD_EXP 39
10021: PPUSH
10022: LD_STRING D6-Lisa-5
10024: PPUSH
10025: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10029: LD_EXP 50
10033: PPUSH
10034: LD_STRING D6-Frank-6
10036: PPUSH
10037: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10041: LD_EXP 36
10045: PPUSH
10046: LD_STRING D6-JMM-6
10048: PPUSH
10049: CALL_OW 88
// end else
10053: GO 10170
// begin ComTurnUnit ( Frank , JMM ) ;
10055: LD_EXP 50
10059: PPUSH
10060: LD_EXP 36
10064: PPUSH
10065: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
10069: LD_EXP 50
10073: PPUSH
10074: LD_STRING D6-Frank-4
10076: PPUSH
10077: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
10081: LD_EXP 50
10085: PPUSH
10086: LD_STRING D6-Frank-4a
10088: PPUSH
10089: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
10093: LD_EXP 36
10097: PPUSH
10098: LD_STRING D6-JMM-4
10100: PPUSH
10101: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
10105: LD_EXP 50
10109: PPUSH
10110: LD_STRING D6-Frank-5
10112: PPUSH
10113: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
10117: LD_EXP 39
10121: PUSH
10122: LD_EXP 39
10126: PPUSH
10127: CALL_OW 302
10131: AND
10132: IFFALSE 10146
// Say ( Lisa , D6-Lisa-5 ) ;
10134: LD_EXP 39
10138: PPUSH
10139: LD_STRING D6-Lisa-5
10141: PPUSH
10142: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
10146: LD_EXP 50
10150: PPUSH
10151: LD_STRING D6-Frank-6
10153: PPUSH
10154: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
10158: LD_EXP 36
10162: PPUSH
10163: LD_STRING D6-JMM-6
10165: PPUSH
10166: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
10170: LD_STRING Q1
10172: PPUSH
10173: CALL_OW 97
10177: PUSH
10178: LD_INT 1
10180: DOUBLE
10181: EQUAL
10182: IFTRUE 10186
10184: GO 10197
10186: POP
// frank_send_to_scout := true ; 2 :
10187: LD_ADDR_EXP 14
10191: PUSH
10192: LD_INT 1
10194: ST_TO_ADDR
10195: GO 10217
10197: LD_INT 2
10199: DOUBLE
10200: EQUAL
10201: IFTRUE 10205
10203: GO 10216
10205: POP
// frank_send_to_scout := false ; end ;
10206: LD_ADDR_EXP 14
10210: PUSH
10211: LD_INT 0
10213: ST_TO_ADDR
10214: GO 10217
10216: POP
// Video ( false ) ;
10217: LD_INT 0
10219: PPUSH
10220: CALL 1185 0 1
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
10224: LD_EXP 36
10228: PUSH
10229: LD_EXP 39
10233: PUSH
10234: LD_EXP 46
10238: PUSH
10239: EMPTY
10240: LIST
10241: LIST
10242: LIST
10243: PPUSH
10244: CALL_OW 139
// if frank_send_to_scout then
10248: LD_EXP 14
10252: IFFALSE 10306
// begin repeat ComMoveToArea ( Frank , cyrusEscape ) ;
10254: LD_EXP 50
10258: PPUSH
10259: LD_INT 15
10261: PPUSH
10262: CALL_OW 113
// wait ( 0 0$01 ) ;
10266: LD_INT 35
10268: PPUSH
10269: CALL_OW 67
// until not See ( 1 , Frank ) ;
10273: LD_INT 1
10275: PPUSH
10276: LD_EXP 50
10280: PPUSH
10281: CALL_OW 292
10285: NOT
10286: IFFALSE 10254
// wait ( 0 0$02 ) ;
10288: LD_INT 70
10290: PPUSH
10291: CALL_OW 67
// RemoveUnit ( Frank ) ;
10295: LD_EXP 50
10299: PPUSH
10300: CALL_OW 64
// end else
10304: GO 10318
// SetSide ( Frank , 1 ) ;
10306: LD_EXP 50
10310: PPUSH
10311: LD_INT 1
10313: PPUSH
10314: CALL_OW 235
// send_attack_on_cornel_base := true ;
10318: LD_ADDR_EXP 25
10322: PUSH
10323: LD_INT 1
10325: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
10326: LD_INT 35
10328: PPUSH
10329: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
10333: LD_ADDR_EXP 28
10337: PUSH
10338: LD_EXP 28
10342: PPUSH
10343: LD_STRING -
10345: PPUSH
10346: CALL 1117 0 2
10350: ST_TO_ADDR
// if debug then
10351: LD_EXP 1
10355: IFFALSE 10367
// debug_strings := time_to_prepare ;
10357: LD_ADDR_OWVAR 48
10361: PUSH
10362: LD_EXP 28
10366: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
10367: LD_EXP 28
10371: PUSH
10372: LD_INT 0
10374: EQUAL
10375: IFFALSE 10326
// cornel_prepared := true ;
10377: LD_ADDR_EXP 11
10381: PUSH
10382: LD_INT 1
10384: ST_TO_ADDR
// end ;
10385: PPOPN 3
10387: END
// every 0 0$01 trigger cornel_prepared do
10388: LD_EXP 11
10392: IFFALSE 10656
10394: GO 10396
10396: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
10397: LD_EXP 43
10401: PPUSH
10402: LD_STRING D3-Corn-1
10404: PPUSH
10405: CALL_OW 94
// ChangeMissionObjectives ( MOutWait ) ;
10409: LD_STRING MOutWait
10411: PPUSH
10412: CALL_OW 337
// repeat wait ( 0 0$01 ) ;
10416: LD_INT 35
10418: PPUSH
10419: CALL_OW 67
// until cornel_counter = 0 ;
10423: LD_EXP 10
10427: PUSH
10428: LD_INT 0
10430: EQUAL
10431: IFFALSE 10416
// SayRadio ( Cornel , D3a-Corn-1 ) ;
10433: LD_EXP 43
10437: PPUSH
10438: LD_STRING D3a-Corn-1
10440: PPUSH
10441: CALL_OW 94
// if IsOk ( Cornel ) then
10445: LD_EXP 43
10449: PPUSH
10450: CALL_OW 302
10454: IFFALSE 10468
// Say ( JMM , D3a-JMM-1 ) ;
10456: LD_EXP 36
10460: PPUSH
10461: LD_STRING D3a-JMM-1
10463: PPUSH
10464: CALL_OW 88
// end_mission_allowed := true ;
10468: LD_ADDR_EXP 20
10472: PUSH
10473: LD_INT 1
10475: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
10476: LD_STRING M2
10478: PPUSH
10479: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
10483: LD_INT 9
10485: PPUSH
10486: LD_INT 1
10488: PPUSH
10489: CALL_OW 424
// Wait ( 0 0$05 ) ;
10493: LD_INT 175
10495: PPUSH
10496: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
10500: LD_EXP 43
10504: PPUSH
10505: LD_STRING D3a-Corn-2
10507: PPUSH
10508: CALL_OW 94
// cornel_attack := true ;
10512: LD_ADDR_EXP 9
10516: PUSH
10517: LD_INT 1
10519: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
10520: LD_INT 105
10522: PPUSH
10523: CALL_OW 67
// AddMoreTanks ( ) ;
10527: CALL 4862 0 0
// if frank_send_to_scout then
10531: LD_EXP 14
10535: IFFALSE 10656
// begin InitHc ;
10537: CALL_OW 19
// InitUc ;
10541: CALL_OW 18
// uc_side := 8 ;
10545: LD_ADDR_OWVAR 20
10549: PUSH
10550: LD_INT 8
10552: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
10553: LD_ADDR_EXP 50
10557: PUSH
10558: LD_STRING Frank
10560: PPUSH
10561: LD_INT 0
10563: PPUSH
10564: CALL 474 0 2
10568: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
10569: LD_EXP 50
10573: PPUSH
10574: LD_INT 6
10576: PPUSH
10577: LD_INT 9
10579: PPUSH
10580: LD_INT 0
10582: PPUSH
10583: CALL_OW 48
// ComCrawl ( Frank ) ;
10587: LD_EXP 50
10591: PPUSH
10592: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
10596: LD_INT 35
10598: PPUSH
10599: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
10603: LD_EXP 36
10607: PPUSH
10608: LD_EXP 50
10612: PPUSH
10613: CALL_OW 296
10617: PUSH
10618: LD_INT 9
10620: LESS
10621: IFFALSE 10596
// SetSide ( Frank , 1 ) ;
10623: LD_EXP 50
10627: PPUSH
10628: LD_INT 1
10630: PPUSH
10631: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
10635: LD_EXP 50
10639: PPUSH
10640: LD_STRING D6a-Frank-1
10642: PPUSH
10643: CALL_OW 88
// ComWalk ( Frank ) ;
10647: LD_EXP 50
10651: PPUSH
10652: CALL_OW 138
// end ; end ;
10656: END
// every 0 0$01 trigger solar_builded do
10657: LD_EXP 13
10661: IFFALSE 10765
10663: GO 10665
10665: DISABLE
// begin Wait ( 0 0$02 ) ;
10666: LD_INT 70
10668: PPUSH
10669: CALL_OW 67
// DialogueOn ;
10673: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10677: LD_EXP 36
10681: PPUSH
10682: LD_STRING D2b-JMM-1
10684: PPUSH
10685: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10689: LD_EXP 47
10693: PUSH
10694: LD_EXP 47
10698: PPUSH
10699: CALL_OW 302
10703: AND
10704: IFFALSE 10754
// begin Say ( Walker , D2b-Sci1-1 ) ;
10706: LD_EXP 47
10710: PPUSH
10711: LD_STRING D2b-Sci1-1
10713: PPUSH
10714: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10718: LD_EXP 36
10722: PPUSH
10723: LD_STRING D2b-JMM-2
10725: PPUSH
10726: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10730: LD_EXP 47
10734: PPUSH
10735: LD_STRING D2b-Sci1-2
10737: PPUSH
10738: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10742: LD_EXP 36
10746: PPUSH
10747: LD_STRING D2b-JMM-3
10749: PPUSH
10750: CALL_OW 88
// end ; DialogueOff ;
10754: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10758: LD_STRING MOutSol
10760: PPUSH
10761: CALL_OW 337
// end ;
10765: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10766: LD_EXP 13
10770: PUSH
10771: LD_EXP 36
10775: PPUSH
10776: CALL_OW 302
10780: AND
10781: PUSH
10782: LD_EXP 36
10786: PPUSH
10787: CALL 951 0 1
10791: AND
10792: PUSH
10793: LD_EXP 15
10797: NOT
10798: AND
10799: IFFALSE 10870
10801: GO 10803
10803: DISABLE
10804: LD_INT 0
10806: PPUSH
// begin jmm_in_veh := true ;
10807: LD_ADDR_EXP 15
10811: PUSH
10812: LD_INT 1
10814: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10815: LD_ADDR_VAR 0 1
10819: PUSH
10820: LD_INT 0
10822: PPUSH
10823: LD_INT 1
10825: PPUSH
10826: CALL_OW 12
10830: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10831: LD_INT 70
10833: PPUSH
10834: CALL_OW 67
// if i then
10838: LD_VAR 0 1
10842: IFFALSE 10858
// Say ( JMM , D2c-JMM-1 ) else
10844: LD_EXP 36
10848: PPUSH
10849: LD_STRING D2c-JMM-1
10851: PPUSH
10852: CALL_OW 88
10856: GO 10870
// Say ( JMM , D2c-JMM-1a ) ;
10858: LD_EXP 36
10862: PPUSH
10863: LD_STRING D2c-JMM-1a
10865: PPUSH
10866: CALL_OW 88
// end ;
10870: PPOPN 1
10872: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10873: LD_EXP 13
10877: PUSH
10878: LD_EXP 37
10882: PPUSH
10883: CALL_OW 302
10887: AND
10888: PUSH
10889: LD_EXP 37
10893: PPUSH
10894: CALL 951 0 1
10898: AND
10899: PUSH
10900: LD_EXP 16
10904: NOT
10905: AND
10906: IFFALSE 10938
10908: GO 10910
10910: DISABLE
// begin bobby_in_veh := true ;
10911: LD_ADDR_EXP 16
10915: PUSH
10916: LD_INT 1
10918: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10919: LD_INT 70
10921: PPUSH
10922: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10926: LD_EXP 37
10930: PPUSH
10931: LD_STRING D2c-Bobby-1
10933: PPUSH
10934: CALL_OW 88
10938: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10939: LD_EXP 13
10943: PUSH
10944: LD_EXP 39
10948: PPUSH
10949: CALL_OW 302
10953: AND
10954: PUSH
10955: LD_EXP 39
10959: PPUSH
10960: CALL 951 0 1
10964: AND
10965: PUSH
10966: LD_EXP 18
10970: NOT
10971: AND
10972: IFFALSE 11004
10974: GO 10976
10976: DISABLE
// begin lisa_in_veh := true ;
10977: LD_ADDR_EXP 18
10981: PUSH
10982: LD_INT 1
10984: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10985: LD_INT 70
10987: PPUSH
10988: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10992: LD_EXP 39
10996: PPUSH
10997: LD_STRING D2c-Lisa-1
10999: PPUSH
11000: CALL_OW 88
11004: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
11005: LD_EXP 13
11009: PUSH
11010: LD_EXP 38
11014: PPUSH
11015: CALL_OW 302
11019: AND
11020: PUSH
11021: LD_EXP 38
11025: PPUSH
11026: CALL 951 0 1
11030: AND
11031: PUSH
11032: LD_EXP 17
11036: NOT
11037: AND
11038: IFFALSE 11109
11040: GO 11042
11042: DISABLE
11043: LD_INT 0
11045: PPUSH
// begin cyrus_in_veh := true ;
11046: LD_ADDR_EXP 17
11050: PUSH
11051: LD_INT 1
11053: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
11054: LD_ADDR_VAR 0 1
11058: PUSH
11059: LD_INT 0
11061: PPUSH
11062: LD_INT 1
11064: PPUSH
11065: CALL_OW 12
11069: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
11070: LD_INT 70
11072: PPUSH
11073: CALL_OW 67
// if i then
11077: LD_VAR 0 1
11081: IFFALSE 11097
// Say ( Cyrus , D2c-Cyrus-1 ) else
11083: LD_EXP 38
11087: PPUSH
11088: LD_STRING D2c-Cyrus-1
11090: PPUSH
11091: CALL_OW 88
11095: GO 11109
// Say ( Cyrus , D2c-Cyrus-1a ) ;
11097: LD_EXP 38
11101: PPUSH
11102: LD_STRING D2c-Cyrus-1a
11104: PPUSH
11105: CALL_OW 88
// end ;
11109: PPOPN 1
11111: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
11112: LD_EXP 43
11116: PPUSH
11117: LD_INT 16
11119: PPUSH
11120: CALL_OW 308
11124: IFFALSE 11405
11126: GO 11128
11128: DISABLE
11129: LD_INT 0
11131: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
11132: LD_INT 3
11134: PPUSH
11135: LD_EXP 43
11139: PPUSH
11140: CALL_OW 471
// send_attack_on_cornel := true ;
11144: LD_ADDR_EXP 31
11148: PUSH
11149: LD_INT 1
11151: ST_TO_ADDR
// if ru_vehicles then
11152: LD_EXP 55
11156: IFFALSE 11190
// for i in ru_vehicles do
11158: LD_ADDR_VAR 0 1
11162: PUSH
11163: LD_EXP 55
11167: PUSH
11168: FOR_IN
11169: IFFALSE 11188
// ComAgressiveMove ( i , 215 , 69 ) ;
11171: LD_VAR 0 1
11175: PPUSH
11176: LD_INT 215
11178: PPUSH
11179: LD_INT 69
11181: PPUSH
11182: CALL_OW 114
11186: GO 11168
11188: POP
11189: POP
// if ru_patrol then
11190: LD_EXP 52
11194: IFFALSE 11228
// for i in ru_patrol do
11196: LD_ADDR_VAR 0 1
11200: PUSH
11201: LD_EXP 52
11205: PUSH
11206: FOR_IN
11207: IFFALSE 11226
// ComAgressiveMove ( i , 215 , 69 ) ;
11209: LD_VAR 0 1
11213: PPUSH
11214: LD_INT 215
11216: PPUSH
11217: LD_INT 69
11219: PPUSH
11220: CALL_OW 114
11224: GO 11206
11226: POP
11227: POP
// if frank_send_to_scout then
11228: LD_EXP 14
11232: IFFALSE 11246
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
11234: LD_EXP 50
11238: PPUSH
11239: LD_STRING D3b-Frank-1
11241: PPUSH
11242: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
11246: LD_INT 105
11248: PPUSH
11249: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
11253: LD_EXP 43
11257: PPUSH
11258: LD_STRING D4-Corn-1
11260: PPUSH
11261: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
11265: LD_INT 35
11267: PPUSH
11268: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) < 6 ;
11272: LD_INT 22
11274: PUSH
11275: LD_INT 4
11277: PUSH
11278: EMPTY
11279: LIST
11280: LIST
11281: PUSH
11282: LD_INT 21
11284: PUSH
11285: LD_INT 1
11287: PUSH
11288: EMPTY
11289: LIST
11290: LIST
11291: PUSH
11292: LD_INT 3
11294: PUSH
11295: LD_INT 24
11297: PUSH
11298: LD_INT 1000
11300: PUSH
11301: EMPTY
11302: LIST
11303: LIST
11304: PUSH
11305: EMPTY
11306: LIST
11307: LIST
11308: PUSH
11309: EMPTY
11310: LIST
11311: LIST
11312: LIST
11313: PPUSH
11314: CALL_OW 69
11318: PUSH
11319: LD_INT 6
11321: LESS
11322: IFFALSE 11265
// if Cornel then
11324: LD_EXP 43
11328: IFFALSE 11368
// begin SayRadio ( Cornel , D5-Corn-1 ) ;
11330: LD_EXP 43
11334: PPUSH
11335: LD_STRING D5-Corn-1
11337: PPUSH
11338: CALL_OW 94
// SaveCharacters ( Cornel , mission_prefix & Cornel ) ;
11342: LD_EXP 43
11346: PPUSH
11347: LD_EXP 2
11351: PUSH
11352: LD_STRING Cornel
11354: STR
11355: PPUSH
11356: CALL_OW 38
// cornel_saved := true ;
11360: LD_ADDR_EXP 26
11364: PUSH
11365: LD_INT 1
11367: ST_TO_ADDR
// end ; ChangeSideFog ( 4 , 8 ) ;
11368: LD_INT 4
11370: PPUSH
11371: LD_INT 8
11373: PPUSH
11374: CALL_OW 343
// Wait ( 0 0$01 ) ;
11378: LD_INT 35
11380: PPUSH
11381: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
11385: LD_INT 3
11387: PPUSH
11388: LD_EXP 43
11392: PPUSH
11393: CALL_OW 472
// send_attack_on_cornel := false ;
11397: LD_ADDR_EXP 31
11401: PUSH
11402: LD_INT 0
11404: ST_TO_ADDR
// end ;
11405: PPOPN 1
11407: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
11408: LD_INT 9
11410: PPUSH
11411: LD_INT 22
11413: PUSH
11414: LD_INT 1
11416: PUSH
11417: EMPTY
11418: LIST
11419: LIST
11420: PPUSH
11421: CALL_OW 70
11425: PUSH
11426: LD_EXP 32
11430: OR
11431: IFFALSE 11628
11433: GO 11435
11435: DISABLE
11436: LD_INT 0
11438: PPUSH
11439: PPUSH
// begin enable ;
11440: ENABLE
// if not jmm_on_west then
11441: LD_EXP 5
11445: NOT
11446: IFFALSE 11457
// begin YouLost ( 4 ) ;
11448: LD_STRING 4
11450: PPUSH
11451: CALL_OW 104
// exit ;
11455: GO 11628
// end ; if not game_end then
11457: LD_EXP 32
11461: NOT
11462: IFFALSE 11472
// game_end := true ;
11464: LD_ADDR_EXP 32
11468: PUSH
11469: LD_INT 1
11471: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
11472: LD_ADDR_VAR 0 2
11476: PUSH
11477: LD_INT 9
11479: PPUSH
11480: LD_INT 22
11482: PUSH
11483: LD_INT 1
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: PPUSH
11490: CALL_OW 70
11494: ST_TO_ADDR
// if not filter then
11495: LD_VAR 0 2
11499: NOT
11500: IFFALSE 11504
// exit ;
11502: GO 11628
// for i in filter do
11504: LD_ADDR_VAR 0 1
11508: PUSH
11509: LD_VAR 0 2
11513: PUSH
11514: FOR_IN
11515: IFFALSE 11626
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle and GetNation ( i ) = nation_american then
11517: LD_VAR 0 1
11521: PPUSH
11522: CALL_OW 302
11526: PUSH
11527: LD_VAR 0 1
11531: PPUSH
11532: CALL_OW 247
11536: PUSH
11537: LD_INT 2
11539: EQUAL
11540: AND
11541: PUSH
11542: LD_VAR 0 1
11546: PPUSH
11547: CALL_OW 248
11551: PUSH
11552: LD_INT 1
11554: EQUAL
11555: AND
11556: IFFALSE 11589
// begin veh_on_meta := true ;
11558: LD_ADDR_EXP 27
11562: PUSH
11563: LD_INT 1
11565: ST_TO_ADDR
// Save ( IsDrivenBy ( i ) ) ;
11566: LD_VAR 0 1
11570: PPUSH
11571: CALL_OW 311
11575: PPUSH
11576: CALL 11631 0 1
// RemoveUnit ( i ) ;
11580: LD_VAR 0 1
11584: PPUSH
11585: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human then
11589: LD_VAR 0 1
11593: PPUSH
11594: CALL_OW 302
11598: PUSH
11599: LD_VAR 0 1
11603: PPUSH
11604: CALL_OW 247
11608: PUSH
11609: LD_INT 1
11611: EQUAL
11612: AND
11613: IFFALSE 11624
// Save ( i ) ;
11615: LD_VAR 0 1
11619: PPUSH
11620: CALL 11631 0 1
// end ;
11624: GO 11514
11626: POP
11627: POP
// end ;
11628: PPOPN 2
11630: END
// export function Save ( i ) ; begin
11631: LD_INT 0
11633: PPUSH
// save_counter := save_counter + 1 ;
11634: LD_ADDR_EXP 35
11638: PUSH
11639: LD_EXP 35
11643: PUSH
11644: LD_INT 1
11646: PLUS
11647: ST_TO_ADDR
// if i = JMM then
11648: LD_VAR 0 1
11652: PUSH
11653: LD_EXP 36
11657: EQUAL
11658: IFFALSE 11780
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
11660: LD_EXP 23
11664: PUSH
11665: LD_INT 22
11667: PUSH
11668: LD_INT 1
11670: PUSH
11671: EMPTY
11672: LIST
11673: LIST
11674: PUSH
11675: LD_INT 21
11677: PUSH
11678: LD_INT 1
11680: PUSH
11681: EMPTY
11682: LIST
11683: LIST
11684: PUSH
11685: EMPTY
11686: LIST
11687: LIST
11688: PPUSH
11689: CALL_OW 69
11693: PUSH
11694: LD_INT 1
11696: GREATER
11697: AND
11698: IFFALSE 11755
// begin show_query := false ;
11700: LD_ADDR_EXP 23
11704: PUSH
11705: LD_INT 0
11707: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
11708: LD_STRING Q2
11710: PPUSH
11711: CALL_OW 97
11715: PUSH
11716: LD_INT 1
11718: DOUBLE
11719: EQUAL
11720: IFTRUE 11724
11722: GO 11735
11724: POP
// wait_for_them := true ; 2 :
11725: LD_ADDR_EXP 24
11729: PUSH
11730: LD_INT 1
11732: ST_TO_ADDR
11733: GO 11755
11735: LD_INT 2
11737: DOUBLE
11738: EQUAL
11739: IFTRUE 11743
11741: GO 11754
11743: POP
// wait_for_them := false ; end ;
11744: LD_ADDR_EXP 24
11748: PUSH
11749: LD_INT 0
11751: ST_TO_ADDR
11752: GO 11755
11754: POP
// end ; save_group := save_group ^ JMM ;
11755: LD_ADDR_EXP 22
11759: PUSH
11760: LD_EXP 22
11764: PUSH
11765: LD_EXP 36
11769: ADD
11770: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
11771: LD_EXP 36
11775: PPUSH
11776: CALL_OW 64
// end ; if i = Lisa then
11780: LD_VAR 0 1
11784: PUSH
11785: LD_EXP 39
11789: EQUAL
11790: IFFALSE 11817
// begin save_group := save_group ^ Lisa ;
11792: LD_ADDR_EXP 22
11796: PUSH
11797: LD_EXP 22
11801: PUSH
11802: LD_EXP 39
11806: ADD
11807: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11808: LD_EXP 39
11812: PPUSH
11813: CALL_OW 64
// end ; if i = Bobby then
11817: LD_VAR 0 1
11821: PUSH
11822: LD_EXP 37
11826: EQUAL
11827: IFFALSE 11854
// begin save_group := save_group ^ Bobby ;
11829: LD_ADDR_EXP 22
11833: PUSH
11834: LD_EXP 22
11838: PUSH
11839: LD_EXP 37
11843: ADD
11844: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11845: LD_EXP 37
11849: PPUSH
11850: CALL_OW 64
// end ; if i = Cyrus then
11854: LD_VAR 0 1
11858: PUSH
11859: LD_EXP 38
11863: EQUAL
11864: IFFALSE 11891
// begin save_group := save_group ^ Cyrus ;
11866: LD_ADDR_EXP 22
11870: PUSH
11871: LD_EXP 22
11875: PUSH
11876: LD_EXP 38
11880: ADD
11881: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11882: LD_EXP 38
11886: PPUSH
11887: CALL_OW 64
// end ; if i = Khatam then
11891: LD_VAR 0 1
11895: PUSH
11896: LD_EXP 40
11900: EQUAL
11901: IFFALSE 11928
// begin save_group := save_group ^ Khatam ;
11903: LD_ADDR_EXP 22
11907: PUSH
11908: LD_EXP 22
11912: PUSH
11913: LD_EXP 40
11917: ADD
11918: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11919: LD_EXP 40
11923: PPUSH
11924: CALL_OW 64
// end ; if i = Frank then
11928: LD_VAR 0 1
11932: PUSH
11933: LD_EXP 50
11937: EQUAL
11938: IFFALSE 11965
// begin save_group := save_group ^ Frank ;
11940: LD_ADDR_EXP 22
11944: PUSH
11945: LD_EXP 22
11949: PUSH
11950: LD_EXP 50
11954: ADD
11955: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11956: LD_EXP 50
11960: PPUSH
11961: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11965: LD_VAR 0 1
11969: PPUSH
11970: CALL_OW 302
11974: PUSH
11975: LD_VAR 0 1
11979: PPUSH
11980: CALL_OW 247
11984: PUSH
11985: LD_INT 1
11987: EQUAL
11988: AND
11989: PUSH
11990: LD_VAR 0 1
11994: PUSH
11995: LD_EXP 22
11999: IN
12000: NOT
12001: AND
12002: IFFALSE 12029
// begin save_others := save_others ^ i ;
12004: LD_ADDR_EXP 21
12008: PUSH
12009: LD_EXP 21
12013: PUSH
12014: LD_VAR 0 1
12018: ADD
12019: ST_TO_ADDR
// RemoveUnit ( i ) ;
12020: LD_VAR 0 1
12024: PPUSH
12025: CALL_OW 64
// end ; end ;
12029: LD_VAR 0 2
12033: RET
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
12034: LD_EXP 23
12038: NOT
12039: PUSH
12040: LD_EXP 24
12044: NOT
12045: AND
12046: PUSH
12047: LD_INT 22
12049: PUSH
12050: LD_INT 1
12052: PUSH
12053: EMPTY
12054: LIST
12055: LIST
12056: PUSH
12057: LD_INT 21
12059: PUSH
12060: LD_INT 1
12062: PUSH
12063: EMPTY
12064: LIST
12065: LIST
12066: PUSH
12067: EMPTY
12068: LIST
12069: LIST
12070: PPUSH
12071: CALL_OW 69
12075: PUSH
12076: LD_INT 0
12078: EQUAL
12079: OR
12080: IFFALSE 12089
12082: GO 12084
12084: DISABLE
// EndMission ;
12085: CALL 12090 0 0
12089: END
// export function EndMission ; var i ; begin
12090: LD_INT 0
12092: PPUSH
12093: PPUSH
// Wait ( 0 0$02 ) ;
12094: LD_INT 70
12096: PPUSH
12097: CALL_OW 67
// if solar_builded then
12101: LD_EXP 13
12105: IFFALSE 12119
// AddMedal ( Solar1 , 1 ) else
12107: LD_STRING Solar1
12109: PPUSH
12110: LD_INT 1
12112: PPUSH
12113: CALL_OW 101
12117: GO 12130
// AddMedal ( Solar1 , - 1 ) ;
12119: LD_STRING Solar1
12121: PPUSH
12122: LD_INT 1
12124: NEG
12125: PPUSH
12126: CALL_OW 101
// if veh_on_meta then
12130: LD_EXP 27
12134: IFFALSE 12148
// AddMedal ( Solar2 , 1 ) else
12136: LD_STRING Solar2
12138: PPUSH
12139: LD_INT 1
12141: PPUSH
12142: CALL_OW 101
12146: GO 12178
// if solar_builded then
12148: LD_EXP 13
12152: IFFALSE 12167
// AddMedal ( Solar2 , - 1 ) else
12154: LD_STRING Solar2
12156: PPUSH
12157: LD_INT 1
12159: NEG
12160: PPUSH
12161: CALL_OW 101
12165: GO 12178
// AddMedal ( Solar2 , - 2 ) ;
12167: LD_STRING Solar2
12169: PPUSH
12170: LD_INT 2
12172: NEG
12173: PPUSH
12174: CALL_OW 101
// if lose_counter = 0 then
12178: LD_EXP 33
12182: PUSH
12183: LD_INT 0
12185: EQUAL
12186: IFFALSE 12200
// AddMedal ( No , 1 ) else
12188: LD_STRING No
12190: PPUSH
12191: LD_INT 1
12193: PPUSH
12194: CALL_OW 101
12198: GO 12244
// if lose_counter > 0 and lose_counter < 4 then
12200: LD_EXP 33
12204: PUSH
12205: LD_INT 0
12207: GREATER
12208: PUSH
12209: LD_EXP 33
12213: PUSH
12214: LD_INT 4
12216: LESS
12217: AND
12218: IFFALSE 12233
// AddMedal ( No , - 1 ) else
12220: LD_STRING No
12222: PPUSH
12223: LD_INT 1
12225: NEG
12226: PPUSH
12227: CALL_OW 101
12231: GO 12244
// AddMedal ( UpTo4 , - 1 ) ;
12233: LD_STRING UpTo4
12235: PPUSH
12236: LD_INT 1
12238: NEG
12239: PPUSH
12240: CALL_OW 101
// GiveMedals ( MAIN ) ;
12244: LD_STRING MAIN
12246: PPUSH
12247: CALL_OW 102
// if IsDead ( Pokryshkin ) then
12251: LD_EXP 51
12255: PPUSH
12256: CALL_OW 301
12260: IFFALSE 12300
// for i in save_group ^ save_others do
12262: LD_ADDR_VAR 0 2
12266: PUSH
12267: LD_EXP 22
12271: PUSH
12272: LD_EXP 21
12276: ADD
12277: PUSH
12278: FOR_IN
12279: IFFALSE 12298
// AddExperience ( i , skill_combat , 1500 ) ;
12281: LD_VAR 0 2
12285: PPUSH
12286: LD_INT 1
12288: PPUSH
12289: LD_INT 1500
12291: PPUSH
12292: CALL_OW 492
12296: GO 12278
12298: POP
12299: POP
// RewardPeople ( save_group ^ save_others ) ;
12300: LD_EXP 22
12304: PUSH
12305: LD_EXP 21
12309: ADD
12310: PPUSH
12311: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
12315: LD_EXP 36
12319: PPUSH
12320: LD_EXP 2
12324: PUSH
12325: LD_STRING JMM
12327: STR
12328: PPUSH
12329: CALL_OW 38
// if Bobby in save_group then
12333: LD_EXP 37
12337: PUSH
12338: LD_EXP 22
12342: IN
12343: IFFALSE 12363
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
12345: LD_EXP 37
12349: PPUSH
12350: LD_EXP 2
12354: PUSH
12355: LD_STRING Bobby
12357: STR
12358: PPUSH
12359: CALL_OW 38
// if Cyrus in save_group then
12363: LD_EXP 38
12367: PUSH
12368: LD_EXP 22
12372: IN
12373: IFFALSE 12393
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
12375: LD_EXP 38
12379: PPUSH
12380: LD_EXP 2
12384: PUSH
12385: LD_STRING Cyrus
12387: STR
12388: PPUSH
12389: CALL_OW 38
// if Lisa in save_group then
12393: LD_EXP 39
12397: PUSH
12398: LD_EXP 22
12402: IN
12403: IFFALSE 12423
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
12405: LD_EXP 39
12409: PPUSH
12410: LD_EXP 2
12414: PUSH
12415: LD_STRING Lisa
12417: STR
12418: PPUSH
12419: CALL_OW 38
// if Frank in save_group then
12423: LD_EXP 50
12427: PUSH
12428: LD_EXP 22
12432: IN
12433: IFFALSE 12453
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
12435: LD_EXP 50
12439: PPUSH
12440: LD_EXP 2
12444: PUSH
12445: LD_STRING Frank
12447: STR
12448: PPUSH
12449: CALL_OW 38
// if Khatam in save_group then
12453: LD_EXP 40
12457: PUSH
12458: LD_EXP 22
12462: IN
12463: IFFALSE 12483
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
12465: LD_EXP 40
12469: PPUSH
12470: LD_EXP 2
12474: PUSH
12475: LD_STRING Khatam
12477: STR
12478: PPUSH
12479: CALL_OW 38
// if save_others then
12483: LD_EXP 21
12487: IFFALSE 12501
// SaveCharacters ( save_others , 03_others ) ;
12489: LD_EXP 21
12493: PPUSH
12494: LD_STRING 03_others
12496: PPUSH
12497: CALL_OW 38
// if Bierezov and IsOk ( Bierezov ) and cornel_saved then
12501: LD_EXP 44
12505: PUSH
12506: LD_EXP 44
12510: PPUSH
12511: CALL_OW 302
12515: AND
12516: PUSH
12517: LD_EXP 26
12521: AND
12522: IFFALSE 12534
// begin ResetFog ;
12524: CALL_OW 335
// DisplayEndingScene ;
12528: CALL 12556 0 0
// end else
12532: GO 12547
// DeleteCharacters ( mission_prefix & Cornel ) ;
12534: LD_EXP 2
12538: PUSH
12539: LD_STRING Cornel
12541: STR
12542: PPUSH
12543: CALL_OW 40
// YouWin ;
12547: CALL_OW 103
// end ;
12551: LD_VAR 0 1
12555: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
12556: LD_INT 0
12558: PPUSH
12559: PPUSH
12560: PPUSH
12561: PPUSH
12562: PPUSH
12563: PPUSH
// InGameOn ;
12564: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12568: LD_INT 208
12570: PPUSH
12571: LD_INT 62
12573: PPUSH
12574: LD_INT 1
12576: PPUSH
12577: LD_INT 10
12579: NEG
12580: PPUSH
12581: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
12585: LD_INT 208
12587: PPUSH
12588: LD_INT 62
12590: PPUSH
12591: LD_INT 1
12593: PPUSH
12594: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
12598: LD_ADDR_VAR 0 3
12602: PUSH
12603: LD_INT 22
12605: PUSH
12606: LD_INT 3
12608: PUSH
12609: EMPTY
12610: LIST
12611: LIST
12612: PUSH
12613: LD_INT 2
12615: PUSH
12616: LD_INT 21
12618: PUSH
12619: LD_INT 2
12621: PUSH
12622: EMPTY
12623: LIST
12624: LIST
12625: PUSH
12626: LD_INT 21
12628: PUSH
12629: LD_INT 1
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: PUSH
12636: EMPTY
12637: LIST
12638: LIST
12639: LIST
12640: PUSH
12641: EMPTY
12642: LIST
12643: LIST
12644: PPUSH
12645: CALL_OW 69
12649: ST_TO_ADDR
// if filter then
12650: LD_VAR 0 3
12654: IFFALSE 12682
// for i in filter do
12656: LD_ADDR_VAR 0 2
12660: PUSH
12661: LD_VAR 0 3
12665: PUSH
12666: FOR_IN
12667: IFFALSE 12680
// RemoveUnit ( i ) ;
12669: LD_VAR 0 2
12673: PPUSH
12674: CALL_OW 64
12678: GO 12666
12680: POP
12681: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
12682: LD_ADDR_VAR 0 3
12686: PUSH
12687: LD_INT 22
12689: PUSH
12690: LD_INT 4
12692: PUSH
12693: EMPTY
12694: LIST
12695: LIST
12696: PUSH
12697: LD_INT 21
12699: PUSH
12700: LD_INT 1
12702: PUSH
12703: EMPTY
12704: LIST
12705: LIST
12706: PUSH
12707: EMPTY
12708: LIST
12709: LIST
12710: PPUSH
12711: CALL_OW 69
12715: ST_TO_ADDR
// if filter then
12716: LD_VAR 0 3
12720: IFFALSE 12751
// for i in filter do
12722: LD_ADDR_VAR 0 2
12726: PUSH
12727: LD_VAR 0 3
12731: PUSH
12732: FOR_IN
12733: IFFALSE 12749
// SetLives ( i , 0 ) ;
12735: LD_VAR 0 2
12739: PPUSH
12740: LD_INT 0
12742: PPUSH
12743: CALL_OW 234
12747: GO 12732
12749: POP
12750: POP
// uc_side := 4 ;
12751: LD_ADDR_OWVAR 20
12755: PUSH
12756: LD_INT 4
12758: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
12759: LD_ADDR_VAR 0 4
12763: PUSH
12764: LD_STRING Cornell
12766: PPUSH
12767: LD_INT 0
12769: PPUSH
12770: CALL 474 0 2
12774: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
12775: LD_VAR 0 4
12779: PPUSH
12780: LD_INT 208
12782: PPUSH
12783: LD_INT 62
12785: PPUSH
12786: LD_INT 0
12788: PPUSH
12789: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12793: LD_VAR 0 4
12797: PPUSH
12798: LD_INT 100
12800: PPUSH
12801: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12805: LD_INT 3
12807: PPUSH
12808: LD_VAR 0 4
12812: PPUSH
12813: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12817: LD_INT 4
12819: PPUSH
12820: LD_INT 3
12822: PPUSH
12823: LD_INT 1
12825: PPUSH
12826: LD_INT 1
12828: PPUSH
12829: CALL_OW 80
// uc_side := 3 ;
12833: LD_ADDR_OWVAR 20
12837: PUSH
12838: LD_INT 3
12840: ST_TO_ADDR
// uc_nation := 3 ;
12841: LD_ADDR_OWVAR 21
12845: PUSH
12846: LD_INT 3
12848: ST_TO_ADDR
// InitHc ;
12849: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12853: LD_ADDR_VAR 0 5
12857: PUSH
12858: LD_STRING Mikhail
12860: PPUSH
12861: LD_INT 0
12863: PPUSH
12864: CALL 474 0 2
12868: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12869: LD_INT 1
12871: PPUSH
12872: LD_INT 1
12874: PPUSH
12875: LD_INT 0
12877: PPUSH
12878: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12882: LD_ADDR_VAR 0 6
12886: PUSH
12887: LD_VAR 0 6
12891: PUSH
12892: CALL_OW 44
12896: ADD
12897: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12898: LD_ADDR_VAR 0 6
12902: PUSH
12903: LD_VAR 0 6
12907: PUSH
12908: CALL_OW 44
12912: ADD
12913: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12914: LD_INT 2
12916: PPUSH
12917: LD_INT 4
12919: PPUSH
12920: LD_INT 0
12922: PPUSH
12923: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12927: LD_ADDR_VAR 0 6
12931: PUSH
12932: LD_VAR 0 6
12936: PUSH
12937: CALL_OW 44
12941: ADD
12942: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12943: LD_VAR 0 5
12947: PPUSH
12948: LD_INT 17
12950: PPUSH
12951: LD_INT 0
12953: PPUSH
12954: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12958: LD_VAR 0 5
12962: PPUSH
12963: LD_INT 210
12965: PPUSH
12966: LD_INT 63
12968: PPUSH
12969: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12973: LD_VAR 0 5
12977: PPUSH
12978: LD_INT 208
12980: PPUSH
12981: LD_INT 62
12983: PPUSH
12984: CALL_OW 178
// for i in fake_russians do
12988: LD_ADDR_VAR 0 2
12992: PUSH
12993: LD_VAR 0 6
12997: PUSH
12998: FOR_IN
12999: IFFALSE 13077
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
13001: LD_VAR 0 2
13005: PPUSH
13006: LD_INT 17
13008: PPUSH
13009: LD_INT 0
13011: PPUSH
13012: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
13016: LD_VAR 0 2
13020: PPUSH
13021: LD_INT 215
13023: PPUSH
13024: LD_INT 67
13026: PPUSH
13027: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
13031: LD_VAR 0 2
13035: PPUSH
13036: LD_INT 208
13038: PPUSH
13039: LD_INT 62
13041: PPUSH
13042: CALL_OW 178
// if GetClass ( i ) = 4 then
13046: LD_VAR 0 2
13050: PPUSH
13051: CALL_OW 257
13055: PUSH
13056: LD_INT 4
13058: EQUAL
13059: IFFALSE 13075
// ComHeal ( i , fake_cornel ) ;
13061: LD_VAR 0 2
13065: PPUSH
13066: LD_VAR 0 4
13070: PPUSH
13071: CALL_OW 128
// end ;
13075: GO 12998
13077: POP
13078: POP
// Wait ( 0 0$01 ) ;
13079: LD_INT 35
13081: PPUSH
13082: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
13086: LD_INT 208
13088: PPUSH
13089: LD_INT 62
13091: PPUSH
13092: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
13096: LD_INT 208
13098: PPUSH
13099: LD_INT 62
13101: PPUSH
13102: LD_INT 1
13104: PPUSH
13105: LD_INT 10
13107: NEG
13108: PPUSH
13109: CALL_OW 330
// Wait ( 0 0$15 ) ;
13113: LD_INT 525
13115: PPUSH
13116: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
13120: LD_INT 208
13122: PPUSH
13123: LD_INT 62
13125: PPUSH
13126: LD_INT 1
13128: PPUSH
13129: CALL_OW 331
// ResetFog ;
13133: CALL_OW 335
// InGameOff ;
13137: CALL_OW 9
// end ;
13141: LD_VAR 0 1
13145: RET
// every 0 0$15 trigger ( FilterUnitsInArea ( cornelBaseArea , [ f_side , 1 ] ) and IsOk ( Cornel ) ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , Cornel ) , Cornel ) < 30 do
13146: LD_INT 10
13148: PPUSH
13149: LD_INT 22
13151: PUSH
13152: LD_INT 1
13154: PUSH
13155: EMPTY
13156: LIST
13157: LIST
13158: PPUSH
13159: CALL_OW 70
13163: PUSH
13164: LD_EXP 43
13168: PPUSH
13169: CALL_OW 302
13173: AND
13174: PUSH
13175: LD_INT 22
13177: PUSH
13178: LD_INT 1
13180: PUSH
13181: EMPTY
13182: LIST
13183: LIST
13184: PPUSH
13185: CALL_OW 69
13189: PPUSH
13190: LD_EXP 43
13194: PPUSH
13195: CALL_OW 74
13199: PPUSH
13200: LD_EXP 43
13204: PPUSH
13205: CALL_OW 296
13209: PUSH
13210: LD_INT 30
13212: LESS
13213: OR
13214: IFFALSE 13265
13216: GO 13218
13218: DISABLE
// begin enable ;
13219: ENABLE
// powell_warn := powell_warn + 1 ;
13220: LD_ADDR_EXP 34
13224: PUSH
13225: LD_EXP 34
13229: PUSH
13230: LD_INT 1
13232: PLUS
13233: ST_TO_ADDR
// if powell_warn = 3 then
13234: LD_EXP 34
13238: PUSH
13239: LD_INT 3
13241: EQUAL
13242: IFFALSE 13253
// begin YouLost ( 5 ) ;
13244: LD_STRING 5
13246: PPUSH
13247: CALL_OW 104
// exit ;
13251: GO 13265
// end ; SayRadio ( Powell , DWarn-Pow-1 ) ;
13253: LD_EXP 45
13257: PPUSH
13258: LD_STRING DWarn-Pow-1
13260: PPUSH
13261: CALL_OW 94
// end ; end_of_file
13265: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
13266: LD_EXP 8
13270: IFFALSE 14995
13272: GO 13274
13274: DISABLE
13275: LD_INT 0
13277: PPUSH
13278: PPUSH
13279: PPUSH
13280: PPUSH
13281: PPUSH
13282: PPUSH
13283: PPUSH
13284: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
13285: LD_EXP 43
13289: PUSH
13290: LD_EXP 44
13294: ADD
13295: PUSH
13296: LD_EXP 6
13300: ADD
13301: PPUSH
13302: LD_INT 250
13304: PPUSH
13305: LD_INT 120
13307: PPUSH
13308: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff Bierezov ;
13312: LD_ADDR_VAR 0 2
13316: PUSH
13317: LD_EXP 6
13321: PPUSH
13322: LD_INT 25
13324: PUSH
13325: LD_INT 2
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: PPUSH
13332: CALL_OW 72
13336: PUSH
13337: LD_EXP 44
13341: DIFF
13342: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) diff has_eng ;
13343: LD_ADDR_VAR 0 3
13347: PUSH
13348: LD_EXP 6
13352: PPUSH
13353: LD_INT 21
13355: PUSH
13356: LD_INT 1
13358: PUSH
13359: EMPTY
13360: LIST
13361: LIST
13362: PPUSH
13363: CALL_OW 72
13367: PUSH
13368: LD_VAR 0 2
13372: DIFF
13373: ST_TO_ADDR
// if not has_eng then
13374: LD_VAR 0 2
13378: NOT
13379: IFFALSE 13462
// begin uc_side := 4 ;
13381: LD_ADDR_OWVAR 20
13385: PUSH
13386: LD_INT 4
13388: ST_TO_ADDR
// uc_nation := 1 ;
13389: LD_ADDR_OWVAR 21
13393: PUSH
13394: LD_INT 1
13396: ST_TO_ADDR
// bc_type := b_depot ;
13397: LD_ADDR_OWVAR 42
13401: PUSH
13402: LD_INT 0
13404: ST_TO_ADDR
// bc_level := 2 ;
13405: LD_ADDR_OWVAR 43
13409: PUSH
13410: LD_INT 2
13412: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
13413: LD_ADDR_VAR 0 4
13417: PUSH
13418: LD_INT 264
13420: PPUSH
13421: LD_INT 120
13423: PPUSH
13424: LD_INT 4
13426: PPUSH
13427: CALL_OW 47
13431: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
13432: LD_INT 264
13434: PPUSH
13435: LD_INT 120
13437: PPUSH
13438: LD_INT 4
13440: PPUSH
13441: LD_INT 10
13443: NEG
13444: PPUSH
13445: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
13449: LD_INT 264
13451: PPUSH
13452: LD_INT 120
13454: PPUSH
13455: LD_INT 4
13457: PPUSH
13458: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
13462: LD_INT 35
13464: PPUSH
13465: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) or IsInArea ( IsInUnit ( Cornel ) , cornelBaseArea ) ;
13469: LD_EXP 43
13473: PPUSH
13474: LD_INT 10
13476: PPUSH
13477: CALL_OW 308
13481: PUSH
13482: LD_EXP 43
13486: PPUSH
13487: CALL_OW 310
13491: PPUSH
13492: LD_INT 10
13494: PPUSH
13495: CALL_OW 308
13499: OR
13500: IFFALSE 13462
// if has_eng and not dep then
13502: LD_VAR 0 2
13506: PUSH
13507: LD_VAR 0 4
13511: NOT
13512: AND
13513: IFFALSE 13663
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
13515: LD_VAR 0 2
13519: PPUSH
13520: LD_INT 0
13522: PPUSH
13523: LD_INT 264
13525: PPUSH
13526: LD_INT 120
13528: PPUSH
13529: LD_INT 4
13531: PPUSH
13532: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
13536: LD_INT 35
13538: PPUSH
13539: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) ;
13543: LD_INT 22
13545: PUSH
13546: LD_INT 4
13548: PUSH
13549: EMPTY
13550: LIST
13551: LIST
13552: PUSH
13553: LD_INT 30
13555: PUSH
13556: LD_INT 0
13558: PUSH
13559: EMPTY
13560: LIST
13561: LIST
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PPUSH
13567: CALL_OW 69
13571: IFFALSE 13536
// ComMoveXY ( filter , 264 , 120 ) ;
13573: LD_VAR 0 3
13577: PPUSH
13578: LD_INT 264
13580: PPUSH
13581: LD_INT 120
13583: PPUSH
13584: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
13588: LD_INT 35
13590: PPUSH
13591: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
13595: LD_INT 22
13597: PUSH
13598: LD_INT 4
13600: PUSH
13601: EMPTY
13602: LIST
13603: LIST
13604: PUSH
13605: LD_INT 30
13607: PUSH
13608: LD_INT 0
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: PUSH
13615: LD_INT 3
13617: PUSH
13618: LD_INT 57
13620: PUSH
13621: EMPTY
13622: LIST
13623: PUSH
13624: EMPTY
13625: LIST
13626: LIST
13627: PUSH
13628: EMPTY
13629: LIST
13630: LIST
13631: LIST
13632: PPUSH
13633: CALL_OW 69
13637: IFFALSE 13588
// ComMoveXY ( filter , 247 , 113 ) ;
13639: LD_VAR 0 3
13643: PPUSH
13644: LD_INT 247
13646: PPUSH
13647: LD_INT 113
13649: PPUSH
13650: CALL_OW 111
// Wait ( 0 0$2 ) ;
13654: LD_INT 70
13656: PPUSH
13657: CALL_OW 67
// end else
13661: GO 13675
// begin SetSide ( dep , 4 ) ;
13663: LD_VAR 0 4
13667: PPUSH
13668: LD_INT 4
13670: PPUSH
13671: CALL_OW 235
// end ; dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
13675: LD_ADDR_VAR 0 4
13679: PUSH
13680: LD_INT 22
13682: PUSH
13683: LD_INT 4
13685: PUSH
13686: EMPTY
13687: LIST
13688: LIST
13689: PUSH
13690: LD_INT 30
13692: PUSH
13693: LD_INT 0
13695: PUSH
13696: EMPTY
13697: LIST
13698: LIST
13699: PUSH
13700: EMPTY
13701: LIST
13702: LIST
13703: PPUSH
13704: CALL_OW 69
13708: PUSH
13709: LD_INT 1
13711: ARRAY
13712: ST_TO_ADDR
// for i = 1 to 2 do
13713: LD_ADDR_VAR 0 1
13717: PUSH
13718: DOUBLE
13719: LD_INT 1
13721: DEC
13722: ST_TO_ADDR
13723: LD_INT 2
13725: PUSH
13726: FOR_TO
13727: IFFALSE 13796
// begin ComEnterUnit ( filter [ 1 ] , dep ) ;
13729: LD_VAR 0 3
13733: PUSH
13734: LD_INT 1
13736: ARRAY
13737: PPUSH
13738: LD_VAR 0 4
13742: PPUSH
13743: CALL_OW 120
// AddComChangeProfession ( filter [ 1 ] , 2 ) ;
13747: LD_VAR 0 3
13751: PUSH
13752: LD_INT 1
13754: ARRAY
13755: PPUSH
13756: LD_INT 2
13758: PPUSH
13759: CALL_OW 183
// AddComExitBuilding ( filter [ 1 ] ) ;
13763: LD_VAR 0 3
13767: PUSH
13768: LD_INT 1
13770: ARRAY
13771: PPUSH
13772: CALL_OW 182
// filter := Delete ( filter , 1 ) ;
13776: LD_ADDR_VAR 0 3
13780: PUSH
13781: LD_VAR 0 3
13785: PPUSH
13786: LD_INT 1
13788: PPUSH
13789: CALL_OW 3
13793: ST_TO_ADDR
// end ;
13794: GO 13726
13796: POP
13797: POP
// if IsInUnit ( Cornel ) then
13798: LD_EXP 43
13802: PPUSH
13803: CALL_OW 310
13807: IFFALSE 13885
// begin cargo := IsInUnit ( Cornel ) ;
13809: LD_ADDR_VAR 0 7
13813: PUSH
13814: LD_EXP 43
13818: PPUSH
13819: CALL_OW 310
13823: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
13824: LD_VAR 0 7
13828: PPUSH
13829: LD_INT 1
13831: PPUSH
13832: CALL_OW 289
13836: IFFALSE 13847
// ComUnload ( cargo ) ;
13838: LD_VAR 0 7
13842: PPUSH
13843: CALL_OW 159
// AddComMoveXY ( Cornel , 235 , 122 ) ;
13847: LD_EXP 43
13851: PPUSH
13852: LD_INT 235
13854: PPUSH
13855: LD_INT 122
13857: PPUSH
13858: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
13862: LD_EXP 43
13866: PPUSH
13867: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
13871: LD_EXP 43
13875: PPUSH
13876: LD_VAR 0 4
13880: PPUSH
13881: CALL_OW 180
// end ; if Bierezov then
13885: LD_EXP 44
13889: IFFALSE 13937
// begin ComMoveXY ( Bierezov , 260 , 120 ) ;
13891: LD_EXP 44
13895: PPUSH
13896: LD_INT 260
13898: PPUSH
13899: LD_INT 120
13901: PPUSH
13902: CALL_OW 111
// if dep then
13906: LD_VAR 0 4
13910: IFFALSE 13928
// AddComEnterUnit ( Bierezov , dep ) else
13912: LD_EXP 44
13916: PPUSH
13917: LD_VAR 0 4
13921: PPUSH
13922: CALL_OW 180
13926: GO 13937
// AddComHold ( Bierezov ) ;
13928: LD_EXP 44
13932: PPUSH
13933: CALL_OW 200
// end ; wait ( 0 0$10 ) ;
13937: LD_INT 350
13939: PPUSH
13940: CALL_OW 67
// has_eng := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 2 ] ] ) diff Bierezov ;
13944: LD_ADDR_VAR 0 2
13948: PUSH
13949: LD_INT 22
13951: PUSH
13952: LD_INT 4
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PUSH
13959: LD_INT 25
13961: PUSH
13962: LD_INT 2
13964: PUSH
13965: EMPTY
13966: LIST
13967: LIST
13968: PUSH
13969: EMPTY
13970: LIST
13971: LIST
13972: PPUSH
13973: CALL_OW 69
13977: PUSH
13978: LD_EXP 44
13982: DIFF
13983: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13984: LD_INT 35
13986: PPUSH
13987: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13991: LD_ADDR_VAR 0 6
13995: PUSH
13996: LD_INT 10
13998: PPUSH
13999: CALL_OW 435
14003: ST_TO_ADDR
// if crates then
14004: LD_VAR 0 6
14008: IFFALSE 14037
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
14010: LD_VAR 0 2
14014: PPUSH
14015: LD_VAR 0 6
14019: PUSH
14020: LD_INT 1
14022: ARRAY
14023: PPUSH
14024: LD_VAR 0 6
14028: PUSH
14029: LD_INT 2
14031: ARRAY
14032: PPUSH
14033: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
14037: LD_VAR 0 4
14041: PPUSH
14042: CALL_OW 274
14046: PPUSH
14047: LD_INT 1
14049: PPUSH
14050: CALL_OW 275
14054: PUSH
14055: LD_INT 40
14057: GREATEREQUAL
14058: IFFALSE 13984
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] , [ b_breastwork , 254 , 114 , 2 ] ] ;
14060: LD_ADDR_VAR 0 5
14064: PUSH
14065: LD_INT 4
14067: PUSH
14068: LD_INT 256
14070: PUSH
14071: LD_INT 111
14073: PUSH
14074: LD_INT 2
14076: PUSH
14077: EMPTY
14078: LIST
14079: LIST
14080: LIST
14081: LIST
14082: PUSH
14083: LD_INT 31
14085: PUSH
14086: LD_INT 243
14088: PUSH
14089: LD_INT 112
14091: PUSH
14092: LD_INT 2
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: LIST
14099: LIST
14100: PUSH
14101: LD_INT 31
14103: PUSH
14104: LD_INT 254
14106: PUSH
14107: LD_INT 114
14109: PUSH
14110: LD_INT 2
14112: PUSH
14113: EMPTY
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: PUSH
14119: EMPTY
14120: LIST
14121: LIST
14122: LIST
14123: ST_TO_ADDR
// for i in blist do
14124: LD_ADDR_VAR 0 1
14128: PUSH
14129: LD_VAR 0 5
14133: PUSH
14134: FOR_IN
14135: IFFALSE 14184
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
14137: LD_VAR 0 2
14141: PPUSH
14142: LD_VAR 0 1
14146: PUSH
14147: LD_INT 1
14149: ARRAY
14150: PPUSH
14151: LD_VAR 0 1
14155: PUSH
14156: LD_INT 2
14158: ARRAY
14159: PPUSH
14160: LD_VAR 0 1
14164: PUSH
14165: LD_INT 3
14167: ARRAY
14168: PPUSH
14169: LD_VAR 0 1
14173: PUSH
14174: LD_INT 4
14176: ARRAY
14177: PPUSH
14178: CALL_OW 205
14182: GO 14134
14184: POP
14185: POP
// repeat wait ( 0 0$01 ) ;
14186: LD_INT 35
14188: PPUSH
14189: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
14193: LD_INT 22
14195: PUSH
14196: LD_INT 4
14198: PUSH
14199: EMPTY
14200: LIST
14201: LIST
14202: PUSH
14203: LD_INT 30
14205: PUSH
14206: LD_INT 4
14208: PUSH
14209: EMPTY
14210: LIST
14211: LIST
14212: PUSH
14213: LD_INT 3
14215: PUSH
14216: LD_INT 57
14218: PUSH
14219: EMPTY
14220: LIST
14221: PUSH
14222: EMPTY
14223: LIST
14224: LIST
14225: PUSH
14226: EMPTY
14227: LIST
14228: LIST
14229: LIST
14230: PPUSH
14231: CALL_OW 69
14235: IFFALSE 14186
// AddComEnterUnit ( filter , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14237: LD_VAR 0 3
14241: PPUSH
14242: LD_INT 22
14244: PUSH
14245: LD_INT 4
14247: PUSH
14248: EMPTY
14249: LIST
14250: LIST
14251: PUSH
14252: LD_INT 30
14254: PUSH
14255: LD_INT 4
14257: PUSH
14258: EMPTY
14259: LIST
14260: LIST
14261: PUSH
14262: EMPTY
14263: LIST
14264: LIST
14265: PPUSH
14266: CALL_OW 69
14270: PUSH
14271: LD_INT 1
14273: ARRAY
14274: PPUSH
14275: CALL_OW 180
// AddComChangeProfession ( filter , 1 ) ;
14279: LD_VAR 0 3
14283: PPUSH
14284: LD_INT 1
14286: PPUSH
14287: CALL_OW 183
// repeat wait ( 0 0$01 ) ;
14291: LD_INT 35
14293: PPUSH
14294: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) > 1 ;
14298: LD_INT 22
14300: PUSH
14301: LD_INT 4
14303: PUSH
14304: EMPTY
14305: LIST
14306: LIST
14307: PUSH
14308: LD_INT 30
14310: PUSH
14311: LD_INT 31
14313: PUSH
14314: EMPTY
14315: LIST
14316: LIST
14317: PUSH
14318: LD_INT 3
14320: PUSH
14321: LD_INT 57
14323: PUSH
14324: EMPTY
14325: LIST
14326: PUSH
14327: EMPTY
14328: LIST
14329: LIST
14330: PUSH
14331: EMPTY
14332: LIST
14333: LIST
14334: LIST
14335: PPUSH
14336: CALL_OW 69
14340: PUSH
14341: LD_INT 1
14343: GREATER
14344: IFFALSE 14291
// sol := UnitFilter ( cornel_units , [ f_class , 1 ] ) ;
14346: LD_ADDR_VAR 0 8
14350: PUSH
14351: LD_EXP 6
14355: PPUSH
14356: LD_INT 25
14358: PUSH
14359: LD_INT 1
14361: PUSH
14362: EMPTY
14363: LIST
14364: LIST
14365: PPUSH
14366: CALL_OW 72
14370: ST_TO_ADDR
// for i = 1 to FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) do
14371: LD_ADDR_VAR 0 1
14375: PUSH
14376: DOUBLE
14377: LD_INT 1
14379: DEC
14380: ST_TO_ADDR
14381: LD_INT 22
14383: PUSH
14384: LD_INT 4
14386: PUSH
14387: EMPTY
14388: LIST
14389: LIST
14390: PUSH
14391: LD_INT 30
14393: PUSH
14394: LD_INT 31
14396: PUSH
14397: EMPTY
14398: LIST
14399: LIST
14400: PUSH
14401: LD_INT 3
14403: PUSH
14404: LD_INT 57
14406: PUSH
14407: EMPTY
14408: LIST
14409: PUSH
14410: EMPTY
14411: LIST
14412: LIST
14413: PUSH
14414: EMPTY
14415: LIST
14416: LIST
14417: LIST
14418: PPUSH
14419: CALL_OW 69
14423: PUSH
14424: FOR_TO
14425: IFFALSE 14509
// begin if not sol [ i ] then
14427: LD_VAR 0 8
14431: PUSH
14432: LD_VAR 0 1
14436: ARRAY
14437: NOT
14438: IFFALSE 14442
// break ;
14440: GO 14509
// ComExitBuilding ( sol [ i ] ) ;
14442: LD_VAR 0 8
14446: PUSH
14447: LD_VAR 0 1
14451: ARRAY
14452: PPUSH
14453: CALL_OW 122
// AddComEnterUnit ( sol [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
14457: LD_VAR 0 8
14461: PUSH
14462: LD_VAR 0 1
14466: ARRAY
14467: PPUSH
14468: LD_INT 22
14470: PUSH
14471: LD_INT 4
14473: PUSH
14474: EMPTY
14475: LIST
14476: LIST
14477: PUSH
14478: LD_INT 30
14480: PUSH
14481: LD_INT 31
14483: PUSH
14484: EMPTY
14485: LIST
14486: LIST
14487: PUSH
14488: EMPTY
14489: LIST
14490: LIST
14491: PPUSH
14492: CALL_OW 69
14496: PUSH
14497: LD_VAR 0 1
14501: ARRAY
14502: PPUSH
14503: CALL_OW 180
// end ;
14507: GO 14424
14509: POP
14510: POP
// if sol > 2 then
14511: LD_VAR 0 8
14515: PUSH
14516: LD_INT 2
14518: GREATER
14519: IFFALSE 14636
// begin ComExitBuilding ( sol [ 3 ] ) ;
14521: LD_VAR 0 8
14525: PUSH
14526: LD_INT 3
14528: ARRAY
14529: PPUSH
14530: CALL_OW 122
// AddComMoveXY ( sol [ 3 ] , 246 , 94 ) ;
14534: LD_VAR 0 8
14538: PUSH
14539: LD_INT 3
14541: ARRAY
14542: PPUSH
14543: LD_INT 246
14545: PPUSH
14546: LD_INT 94
14548: PPUSH
14549: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$5 ) ;
14553: LD_VAR 0 8
14557: PUSH
14558: LD_INT 3
14560: ARRAY
14561: PPUSH
14562: LD_INT 175
14564: PPUSH
14565: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 224 , 90 ) ;
14569: LD_VAR 0 8
14573: PUSH
14574: LD_INT 3
14576: ARRAY
14577: PPUSH
14578: LD_INT 224
14580: PPUSH
14581: LD_INT 90
14583: PPUSH
14584: CALL_OW 171
// AddComWait ( sol [ 3 ] , 0 0$7 ) ;
14588: LD_VAR 0 8
14592: PUSH
14593: LD_INT 3
14595: ARRAY
14596: PPUSH
14597: LD_INT 245
14599: PPUSH
14600: CALL_OW 202
// AddComMoveXY ( sol [ 3 ] , 223 , 110 ) ;
14604: LD_VAR 0 8
14608: PUSH
14609: LD_INT 3
14611: ARRAY
14612: PPUSH
14613: LD_INT 223
14615: PPUSH
14616: LD_INT 110
14618: PPUSH
14619: CALL_OW 171
// AddComHold ( sol [ 3 ] ) ;
14623: LD_VAR 0 8
14627: PUSH
14628: LD_INT 3
14630: ARRAY
14631: PPUSH
14632: CALL_OW 200
// end ; if has_eng > 1 then
14636: LD_VAR 0 2
14640: PUSH
14641: LD_INT 1
14643: GREATER
14644: IFFALSE 14786
// for i = has_eng downto 2 do
14646: LD_ADDR_VAR 0 1
14650: PUSH
14651: DOUBLE
14652: LD_VAR 0 2
14656: INC
14657: ST_TO_ADDR
14658: LD_INT 2
14660: PUSH
14661: FOR_DOWNTO
14662: IFFALSE 14784
// begin if IsInUnit ( has_eng [ i ] ) then
14664: LD_VAR 0 2
14668: PUSH
14669: LD_VAR 0 1
14673: ARRAY
14674: PPUSH
14675: CALL_OW 310
14679: IFFALSE 14696
// ComExitBuilding ( has_eng [ i ] ) ;
14681: LD_VAR 0 2
14685: PUSH
14686: LD_VAR 0 1
14690: ARRAY
14691: PPUSH
14692: CALL_OW 122
// AddComEnterUnit ( has_eng [ i ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
14696: LD_VAR 0 2
14700: PUSH
14701: LD_VAR 0 1
14705: ARRAY
14706: PPUSH
14707: LD_INT 22
14709: PUSH
14710: LD_INT 4
14712: PUSH
14713: EMPTY
14714: LIST
14715: LIST
14716: PUSH
14717: LD_INT 30
14719: PUSH
14720: LD_INT 4
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: PUSH
14727: EMPTY
14728: LIST
14729: LIST
14730: PPUSH
14731: CALL_OW 69
14735: PUSH
14736: LD_INT 1
14738: ARRAY
14739: PPUSH
14740: CALL_OW 180
// AddComChangeProfession ( has_eng [ i ] , 1 ) ;
14744: LD_VAR 0 2
14748: PUSH
14749: LD_VAR 0 1
14753: ARRAY
14754: PPUSH
14755: LD_INT 1
14757: PPUSH
14758: CALL_OW 183
// has_eng := Delete ( has_eng , i ) ;
14762: LD_ADDR_VAR 0 2
14766: PUSH
14767: LD_VAR 0 2
14771: PPUSH
14772: LD_VAR 0 1
14776: PPUSH
14777: CALL_OW 3
14781: ST_TO_ADDR
// end ;
14782: GO 14661
14784: POP
14785: POP
// ComEnterUnit ( has_eng , dep ) ;
14786: LD_VAR 0 2
14790: PPUSH
14791: LD_VAR 0 4
14795: PPUSH
14796: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
14800: LD_INT 35
14802: PPUSH
14803: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
14807: LD_ADDR_VAR 0 3
14811: PUSH
14812: LD_INT 22
14814: PUSH
14815: LD_INT 4
14817: PUSH
14818: EMPTY
14819: LIST
14820: LIST
14821: PUSH
14822: LD_INT 21
14824: PUSH
14825: LD_INT 3
14827: PUSH
14828: EMPTY
14829: LIST
14830: LIST
14831: PUSH
14832: LD_INT 3
14834: PUSH
14835: LD_INT 24
14837: PUSH
14838: LD_INT 1000
14840: PUSH
14841: EMPTY
14842: LIST
14843: LIST
14844: PUSH
14845: EMPTY
14846: LIST
14847: LIST
14848: PUSH
14849: EMPTY
14850: LIST
14851: LIST
14852: LIST
14853: PPUSH
14854: CALL_OW 69
14858: ST_TO_ADDR
// if filter and has_eng then
14859: LD_VAR 0 3
14863: PUSH
14864: LD_VAR 0 2
14868: AND
14869: IFFALSE 14935
// begin for i in has_eng do
14871: LD_ADDR_VAR 0 1
14875: PUSH
14876: LD_VAR 0 2
14880: PUSH
14881: FOR_IN
14882: IFFALSE 14931
// begin if IsInUnit ( i ) then
14884: LD_VAR 0 1
14888: PPUSH
14889: CALL_OW 310
14893: IFFALSE 14904
// ComExitBuilding ( i ) ;
14895: LD_VAR 0 1
14899: PPUSH
14900: CALL_OW 122
// Wait ( 3 ) ;
14904: LD_INT 3
14906: PPUSH
14907: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
14911: LD_VAR 0 1
14915: PPUSH
14916: LD_VAR 0 3
14920: PUSH
14921: LD_INT 1
14923: ARRAY
14924: PPUSH
14925: CALL_OW 130
// end ;
14929: GO 14881
14931: POP
14932: POP
// end else
14933: GO 14989
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
14935: LD_VAR 0 2
14939: PUSH
14940: LD_VAR 0 2
14944: PPUSH
14945: LD_INT 56
14947: PUSH
14948: EMPTY
14949: LIST
14950: PPUSH
14951: CALL_OW 72
14955: AND
14956: IFFALSE 14989
// for i in has_eng do
14958: LD_ADDR_VAR 0 1
14962: PUSH
14963: LD_VAR 0 2
14967: PUSH
14968: FOR_IN
14969: IFFALSE 14987
// ComEnterUnit ( i , dep ) ;
14971: LD_VAR 0 1
14975: PPUSH
14976: LD_VAR 0 4
14980: PPUSH
14981: CALL_OW 120
14985: GO 14968
14987: POP
14988: POP
// until cornel_prepared ;
14989: LD_EXP 11
14993: IFFALSE 14800
// end ;
14995: PPOPN 8
14997: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
14998: LD_EXP 11
15002: IFFALSE 15401
15004: GO 15006
15006: DISABLE
15007: LD_INT 0
15009: PPUSH
15010: PPUSH
15011: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
15012: LD_ADDR_VAR 0 2
15016: PUSH
15017: LD_INT 22
15019: PUSH
15020: LD_INT 4
15022: PUSH
15023: EMPTY
15024: LIST
15025: LIST
15026: PUSH
15027: LD_INT 30
15029: PUSH
15030: LD_INT 4
15032: PUSH
15033: EMPTY
15034: LIST
15035: LIST
15036: PUSH
15037: EMPTY
15038: LIST
15039: LIST
15040: PPUSH
15041: CALL_OW 69
15045: PUSH
15046: LD_INT 1
15048: ARRAY
15049: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
15050: LD_EXP 6
15054: PPUSH
15055: CALL_OW 122
// if Bierezov and IsInUnit ( Bierezov ) then
15059: LD_EXP 44
15063: PUSH
15064: LD_EXP 44
15068: PPUSH
15069: CALL_OW 310
15073: AND
15074: IFFALSE 15085
// ComExitBuilding ( Bierezov ) ;
15076: LD_EXP 44
15080: PPUSH
15081: CALL_OW 122
// Wait ( 0 0$03 ) ;
15085: LD_INT 105
15087: PPUSH
15088: CALL_OW 67
// for i in cornel_units do
15092: LD_ADDR_VAR 0 1
15096: PUSH
15097: LD_EXP 6
15101: PUSH
15102: FOR_IN
15103: IFFALSE 15179
// begin if GetClass ( i ) in [ 2 , 3 ] then
15105: LD_VAR 0 1
15109: PPUSH
15110: CALL_OW 257
15114: PUSH
15115: LD_INT 2
15117: PUSH
15118: LD_INT 3
15120: PUSH
15121: EMPTY
15122: LIST
15123: LIST
15124: IN
15125: IFFALSE 15162
// begin ComEnterUnit ( i , arm ) ;
15127: LD_VAR 0 1
15131: PPUSH
15132: LD_VAR 0 2
15136: PPUSH
15137: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
15141: LD_VAR 0 1
15145: PPUSH
15146: LD_INT 1
15148: PPUSH
15149: CALL_OW 183
// AddComExitBuilding ( i ) ;
15153: LD_VAR 0 1
15157: PPUSH
15158: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
15162: LD_VAR 0 1
15166: PPUSH
15167: LD_INT 257
15169: PPUSH
15170: LD_INT 121
15172: PPUSH
15173: CALL_OW 171
// end ;
15177: GO 15102
15179: POP
15180: POP
// Wait ( 1 1$00 ) ;
15181: LD_INT 2100
15183: PPUSH
15184: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
15188: LD_ADDR_VAR 0 3
15192: PUSH
15193: LD_EXP 43
15197: PUSH
15198: LD_EXP 44
15202: ADD
15203: PUSH
15204: LD_EXP 6
15208: ADD
15209: PUSH
15210: LD_EXP 6
15214: PPUSH
15215: LD_INT 21
15217: PUSH
15218: LD_INT 2
15220: PUSH
15221: EMPTY
15222: LIST
15223: LIST
15224: PPUSH
15225: CALL_OW 72
15229: DIFF
15230: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
15231: LD_VAR 0 3
15235: PPUSH
15236: LD_INT 248
15238: PPUSH
15239: LD_INT 85
15241: PPUSH
15242: CALL_OW 111
// AddComHold ( filter ) ;
15246: LD_VAR 0 3
15250: PPUSH
15251: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
15255: LD_INT 35
15257: PPUSH
15258: CALL_OW 67
// until cornel_attack ;
15262: LD_EXP 9
15266: IFFALSE 15255
// ComAgressiveMove ( filter , 209 , 63 ) ;
15268: LD_VAR 0 3
15272: PPUSH
15273: LD_INT 209
15275: PPUSH
15276: LD_INT 63
15278: PPUSH
15279: CALL_OW 114
// ComAgressiveMove ( Cornel , 208 , 62 ) ;
15283: LD_EXP 43
15287: PPUSH
15288: LD_INT 208
15290: PPUSH
15291: LD_INT 62
15293: PPUSH
15294: CALL_OW 114
// AddComHold ( Cornel ) ;
15298: LD_EXP 43
15302: PPUSH
15303: CALL_OW 200
// if Bierezov then
15307: LD_EXP 44
15311: IFFALSE 15401
// begin filter := filter diff Bierezov ;
15313: LD_ADDR_VAR 0 3
15317: PUSH
15318: LD_VAR 0 3
15322: PUSH
15323: LD_EXP 44
15327: DIFF
15328: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
15329: LD_EXP 44
15333: PPUSH
15334: LD_INT 6
15336: PPUSH
15337: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
15341: LD_EXP 44
15345: PPUSH
15346: LD_INT 235
15348: PPUSH
15349: LD_INT 60
15351: PPUSH
15352: CALL_OW 111
// AddComHold ( Bierezov ) ;
15356: LD_EXP 44
15360: PPUSH
15361: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
15365: LD_EXP 44
15369: PPUSH
15370: LD_INT 350
15372: PPUSH
15373: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
15377: LD_EXP 44
15381: PPUSH
15382: LD_INT 198
15384: PPUSH
15385: LD_INT 28
15387: PPUSH
15388: CALL_OW 171
// AddComHold ( Bierezov ) ;
15392: LD_EXP 44
15396: PPUSH
15397: CALL_OW 200
// end ; end ; end_of_file
15401: PPOPN 3
15403: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
15404: LD_EXP 52
15408: PUSH
15409: LD_EXP 30
15413: NOT
15414: AND
15415: PUSH
15416: LD_EXP 31
15420: NOT
15421: AND
15422: IFFALSE 15872
15424: GO 15426
15426: DISABLE
15427: LD_INT 0
15429: PPUSH
15430: PPUSH
15431: PPUSH
15432: PPUSH
// begin enable ;
15433: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15434: LD_ADDR_VAR 0 4
15438: PUSH
15439: LD_INT 81
15441: PUSH
15442: LD_INT 3
15444: PUSH
15445: EMPTY
15446: LIST
15447: LIST
15448: PPUSH
15449: CALL_OW 69
15453: ST_TO_ADDR
// for i = 1 to ru_patrol do
15454: LD_ADDR_VAR 0 2
15458: PUSH
15459: DOUBLE
15460: LD_INT 1
15462: DEC
15463: ST_TO_ADDR
15464: LD_EXP 52
15468: PUSH
15469: FOR_TO
15470: IFFALSE 15870
// begin un := ru_patrol [ i ] ;
15472: LD_ADDR_VAR 0 1
15476: PUSH
15477: LD_EXP 52
15481: PUSH
15482: LD_VAR 0 2
15486: ARRAY
15487: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
15488: LD_VAR 0 1
15492: PPUSH
15493: LD_INT 13
15495: PPUSH
15496: CALL_OW 308
15500: IFFALSE 15605
// begin if not ru_alert then
15502: LD_EXP 59
15506: NOT
15507: IFFALSE 15517
// ru_alert := true ;
15509: LD_ADDR_EXP 59
15513: PUSH
15514: LD_INT 1
15516: ST_TO_ADDR
// if not See ( 1 , un ) then
15517: LD_INT 1
15519: PPUSH
15520: LD_VAR 0 1
15524: PPUSH
15525: CALL_OW 292
15529: NOT
15530: IFFALSE 15544
// SetLives ( un , 1000 ) ;
15532: LD_VAR 0 1
15536: PPUSH
15537: LD_INT 1000
15539: PPUSH
15540: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
15544: LD_ADDR_EXP 52
15548: PUSH
15549: LD_EXP 52
15553: PUSH
15554: LD_VAR 0 1
15558: DIFF
15559: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15560: LD_VAR 0 1
15564: PPUSH
15565: LD_INT 22
15567: PUSH
15568: LD_INT 3
15570: PUSH
15571: EMPTY
15572: LIST
15573: LIST
15574: PUSH
15575: LD_INT 30
15577: PUSH
15578: LD_INT 4
15580: PUSH
15581: EMPTY
15582: LIST
15583: LIST
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PPUSH
15589: CALL_OW 69
15593: PPUSH
15594: CALL 1047 0 1
15598: PPUSH
15599: CALL_OW 120
// continue ;
15603: GO 15469
// end ; if IsOk ( un ) and not HasTask ( un ) then
15605: LD_VAR 0 1
15609: PPUSH
15610: CALL_OW 302
15614: PUSH
15615: LD_VAR 0 1
15619: PPUSH
15620: CALL_OW 314
15624: NOT
15625: AND
15626: IFFALSE 15719
// begin for j = 1 to ru_firepoints_south [ i ] do
15628: LD_ADDR_VAR 0 3
15632: PUSH
15633: DOUBLE
15634: LD_INT 1
15636: DEC
15637: ST_TO_ADDR
15638: LD_EXP 58
15642: PUSH
15643: LD_VAR 0 2
15647: ARRAY
15648: PUSH
15649: FOR_TO
15650: IFFALSE 15717
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
15652: LD_VAR 0 1
15656: PPUSH
15657: LD_EXP 58
15661: PUSH
15662: LD_VAR 0 2
15666: ARRAY
15667: PUSH
15668: LD_VAR 0 3
15672: ARRAY
15673: PUSH
15674: LD_INT 1
15676: ARRAY
15677: PPUSH
15678: LD_EXP 58
15682: PUSH
15683: LD_VAR 0 2
15687: ARRAY
15688: PUSH
15689: LD_VAR 0 3
15693: ARRAY
15694: PUSH
15695: LD_INT 2
15697: ARRAY
15698: PPUSH
15699: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
15703: LD_VAR 0 1
15707: PPUSH
15708: LD_INT 70
15710: PPUSH
15711: CALL_OW 202
// end ;
15715: GO 15649
15717: POP
15718: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15719: LD_VAR 0 1
15723: PPUSH
15724: CALL_OW 256
15728: PUSH
15729: LD_INT 700
15731: LESS
15732: PUSH
15733: LD_VAR 0 1
15737: PPUSH
15738: LD_INT 13
15740: PPUSH
15741: CALL_OW 308
15745: NOT
15746: AND
15747: IFFALSE 15799
// begin ComMoveToArea ( un , retreatArea ) ;
15749: LD_VAR 0 1
15753: PPUSH
15754: LD_INT 13
15756: PPUSH
15757: CALL_OW 113
// if not ru_alert_xy then
15761: LD_EXP 60
15765: NOT
15766: IFFALSE 15797
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
15768: LD_ADDR_EXP 60
15772: PUSH
15773: LD_VAR 0 1
15777: PPUSH
15778: CALL_OW 250
15782: PUSH
15783: LD_VAR 0 1
15787: PPUSH
15788: CALL_OW 251
15792: PUSH
15793: EMPTY
15794: LIST
15795: LIST
15796: ST_TO_ADDR
// end else
15797: GO 15868
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15799: LD_VAR 0 1
15803: PPUSH
15804: LD_VAR 0 4
15808: PPUSH
15809: LD_VAR 0 1
15813: PPUSH
15814: CALL_OW 74
15818: PPUSH
15819: CALL_OW 296
15823: PUSH
15824: LD_INT 9
15826: LESS
15827: PUSH
15828: LD_VAR 0 1
15832: PPUSH
15833: CALL_OW 256
15837: PUSH
15838: LD_INT 500
15840: GREATER
15841: AND
15842: IFFALSE 15868
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15844: LD_VAR 0 1
15848: PPUSH
15849: LD_VAR 0 4
15853: PPUSH
15854: LD_VAR 0 1
15858: PPUSH
15859: CALL_OW 74
15863: PPUSH
15864: CALL_OW 115
// end ;
15868: GO 15469
15870: POP
15871: POP
// end ;
15872: PPOPN 4
15874: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
15875: LD_EXP 59
15879: PUSH
15880: LD_EXP 60
15884: AND
15885: PUSH
15886: LD_EXP 30
15890: NOT
15891: AND
15892: PUSH
15893: LD_EXP 31
15897: NOT
15898: AND
15899: IFFALSE 16109
15901: GO 15903
15903: DISABLE
15904: LD_INT 0
15906: PPUSH
15907: PPUSH
// begin enable ;
15908: ENABLE
// if not ru_vehicles then
15909: LD_EXP 55
15913: NOT
15914: IFFALSE 15918
// exit ;
15916: GO 16109
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
15918: LD_ADDR_VAR 0 2
15922: PUSH
15923: LD_INT 81
15925: PUSH
15926: LD_INT 3
15928: PUSH
15929: EMPTY
15930: LIST
15931: LIST
15932: PPUSH
15933: CALL_OW 69
15937: ST_TO_ADDR
// if ru_vehicles then
15938: LD_EXP 55
15942: IFFALSE 16109
// begin for i in ru_vehicles do
15944: LD_ADDR_VAR 0 1
15948: PUSH
15949: LD_EXP 55
15953: PUSH
15954: FOR_IN
15955: IFFALSE 16107
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
15957: LD_VAR 0 1
15961: PPUSH
15962: CALL_OW 302
15966: PUSH
15967: LD_VAR 0 1
15971: PPUSH
15972: LD_VAR 0 2
15976: PPUSH
15977: LD_VAR 0 1
15981: PPUSH
15982: CALL_OW 74
15986: PPUSH
15987: CALL_OW 296
15991: PUSH
15992: LD_INT 9
15994: LESS
15995: AND
15996: IFFALSE 16022
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15998: LD_VAR 0 1
16002: PPUSH
16003: LD_VAR 0 2
16007: PPUSH
16008: LD_VAR 0 1
16012: PPUSH
16013: CALL_OW 74
16017: PPUSH
16018: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
16022: LD_VAR 0 1
16026: PPUSH
16027: CALL_OW 314
16031: NOT
16032: PUSH
16033: LD_VAR 0 1
16037: PPUSH
16038: CALL_OW 302
16042: AND
16043: PUSH
16044: LD_VAR 0 1
16048: PPUSH
16049: LD_EXP 60
16053: PUSH
16054: LD_INT 1
16056: ARRAY
16057: PPUSH
16058: LD_EXP 60
16062: PUSH
16063: LD_INT 2
16065: ARRAY
16066: PPUSH
16067: CALL_OW 297
16071: PUSH
16072: LD_INT 10
16074: GREATER
16075: AND
16076: IFFALSE 16105
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
16078: LD_VAR 0 1
16082: PPUSH
16083: LD_EXP 60
16087: PUSH
16088: LD_INT 1
16090: ARRAY
16091: PPUSH
16092: LD_EXP 60
16096: PUSH
16097: LD_INT 2
16099: ARRAY
16100: PPUSH
16101: CALL_OW 114
// end ;
16105: GO 15954
16107: POP
16108: POP
// end ; end ;
16109: PPOPN 2
16111: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
16112: LD_EXP 60
16116: PUSH
16117: LD_EXP 59
16121: AND
16122: PUSH
16123: LD_INT 3
16125: PPUSH
16126: CALL_OW 463
16130: NOT
16131: AND
16132: PUSH
16133: LD_EXP 30
16137: NOT
16138: AND
16139: PUSH
16140: LD_EXP 31
16144: NOT
16145: AND
16146: IFFALSE 16241
16148: GO 16150
16150: DISABLE
16151: LD_INT 0
16153: PPUSH
// begin enable ;
16154: ENABLE
// ru_alert_xy := false ;
16155: LD_ADDR_EXP 60
16159: PUSH
16160: LD_INT 0
16162: ST_TO_ADDR
// ru_alert := false ;
16163: LD_ADDR_EXP 59
16167: PUSH
16168: LD_INT 0
16170: ST_TO_ADDR
// if ru_vehicles then
16171: LD_EXP 55
16175: IFFALSE 16241
// for i in ru_vehicles do
16177: LD_ADDR_VAR 0 1
16181: PUSH
16182: LD_EXP 55
16186: PUSH
16187: FOR_IN
16188: IFFALSE 16239
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
16190: LD_VAR 0 1
16194: PPUSH
16195: CALL_OW 302
16199: PUSH
16200: LD_VAR 0 1
16204: PPUSH
16205: LD_INT 89
16207: PPUSH
16208: LD_INT 36
16210: PPUSH
16211: CALL_OW 297
16215: PUSH
16216: LD_INT 10
16218: GREATER
16219: AND
16220: IFFALSE 16237
// ComMoveXY ( i , 89 , 36 ) ;
16222: LD_VAR 0 1
16226: PPUSH
16227: LD_INT 89
16229: PPUSH
16230: LD_INT 36
16232: PPUSH
16233: CALL_OW 111
16237: GO 16187
16239: POP
16240: POP
// end ;
16241: PPOPN 1
16243: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
16244: LD_EXP 54
16248: PUSH
16249: LD_EXP 30
16253: NOT
16254: AND
16255: PUSH
16256: LD_EXP 31
16260: NOT
16261: AND
16262: IFFALSE 16546
16264: GO 16266
16266: DISABLE
16267: LD_INT 0
16269: PPUSH
16270: PPUSH
16271: PPUSH
// begin enable ;
16272: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
16273: LD_ADDR_VAR 0 3
16277: PUSH
16278: LD_INT 81
16280: PUSH
16281: LD_INT 3
16283: PUSH
16284: EMPTY
16285: LIST
16286: LIST
16287: PPUSH
16288: CALL_OW 69
16292: ST_TO_ADDR
// for i = 1 to ru_forest do
16293: LD_ADDR_VAR 0 1
16297: PUSH
16298: DOUBLE
16299: LD_INT 1
16301: DEC
16302: ST_TO_ADDR
16303: LD_EXP 54
16307: PUSH
16308: FOR_TO
16309: IFFALSE 16544
// begin un := ru_forest [ i ] ;
16311: LD_ADDR_VAR 0 2
16315: PUSH
16316: LD_EXP 54
16320: PUSH
16321: LD_VAR 0 1
16325: ARRAY
16326: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
16327: LD_VAR 0 2
16331: PPUSH
16332: LD_INT 13
16334: PPUSH
16335: CALL_OW 308
16339: IFFALSE 16429
// begin if not See ( 1 , un ) then
16341: LD_INT 1
16343: PPUSH
16344: LD_VAR 0 2
16348: PPUSH
16349: CALL_OW 292
16353: NOT
16354: IFFALSE 16368
// SetLives ( un , 1000 ) ;
16356: LD_VAR 0 2
16360: PPUSH
16361: LD_INT 1000
16363: PPUSH
16364: CALL_OW 234
// ru_forest := ru_forest diff un ;
16368: LD_ADDR_EXP 54
16372: PUSH
16373: LD_EXP 54
16377: PUSH
16378: LD_VAR 0 2
16382: DIFF
16383: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
16384: LD_VAR 0 2
16388: PPUSH
16389: LD_INT 22
16391: PUSH
16392: LD_INT 3
16394: PUSH
16395: EMPTY
16396: LIST
16397: LIST
16398: PUSH
16399: LD_INT 30
16401: PUSH
16402: LD_INT 4
16404: PUSH
16405: EMPTY
16406: LIST
16407: LIST
16408: PUSH
16409: EMPTY
16410: LIST
16411: LIST
16412: PPUSH
16413: CALL_OW 69
16417: PPUSH
16418: CALL 1047 0 1
16422: PPUSH
16423: CALL_OW 120
// continue ;
16427: GO 16308
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
16429: LD_VAR 0 2
16433: PPUSH
16434: CALL_OW 256
16438: PUSH
16439: LD_INT 700
16441: LESS
16442: PUSH
16443: LD_VAR 0 2
16447: PPUSH
16448: LD_INT 13
16450: PPUSH
16451: CALL_OW 308
16455: NOT
16456: AND
16457: IFFALSE 16473
// ComMoveToArea ( un , retreatArea ) else
16459: LD_VAR 0 2
16463: PPUSH
16464: LD_INT 13
16466: PPUSH
16467: CALL_OW 113
16471: GO 16542
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
16473: LD_VAR 0 2
16477: PPUSH
16478: LD_VAR 0 3
16482: PPUSH
16483: LD_VAR 0 2
16487: PPUSH
16488: CALL_OW 74
16492: PPUSH
16493: CALL_OW 296
16497: PUSH
16498: LD_INT 9
16500: LESS
16501: PUSH
16502: LD_VAR 0 2
16506: PPUSH
16507: CALL_OW 256
16511: PUSH
16512: LD_INT 500
16514: GREATER
16515: AND
16516: IFFALSE 16542
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
16518: LD_VAR 0 2
16522: PPUSH
16523: LD_VAR 0 3
16527: PPUSH
16528: LD_VAR 0 2
16532: PPUSH
16533: CALL_OW 74
16537: PPUSH
16538: CALL_OW 115
// end ;
16542: GO 16308
16544: POP
16545: POP
// end ;
16546: PPOPN 3
16548: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
16549: LD_EXP 31
16553: NOT
16554: IFFALSE 16675
16556: GO 16558
16558: DISABLE
16559: LD_INT 0
16561: PPUSH
16562: PPUSH
// begin enable ;
16563: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
16564: LD_ADDR_VAR 0 2
16568: PUSH
16569: LD_INT 22
16571: PUSH
16572: LD_INT 3
16574: PUSH
16575: EMPTY
16576: LIST
16577: LIST
16578: PUSH
16579: LD_INT 21
16581: PUSH
16582: LD_INT 3
16584: PUSH
16585: EMPTY
16586: LIST
16587: LIST
16588: PUSH
16589: EMPTY
16590: LIST
16591: LIST
16592: PPUSH
16593: CALL_OW 69
16597: ST_TO_ADDR
// if filter then
16598: LD_VAR 0 2
16602: IFFALSE 16675
// for i in filter do
16604: LD_ADDR_VAR 0 1
16608: PUSH
16609: LD_VAR 0 2
16613: PUSH
16614: FOR_IN
16615: IFFALSE 16673
// if GetLives ( i ) < 990 then
16617: LD_VAR 0 1
16621: PPUSH
16622: CALL_OW 256
16626: PUSH
16627: LD_INT 990
16629: LESS
16630: IFFALSE 16671
// begin ru_alert := true ;
16632: LD_ADDR_EXP 59
16636: PUSH
16637: LD_INT 1
16639: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
16640: LD_ADDR_EXP 60
16644: PUSH
16645: LD_VAR 0 1
16649: PPUSH
16650: CALL_OW 250
16654: PUSH
16655: LD_VAR 0 1
16659: PPUSH
16660: CALL_OW 251
16664: PUSH
16665: EMPTY
16666: LIST
16667: LIST
16668: ST_TO_ADDR
// break ;
16669: GO 16673
// end ;
16671: GO 16614
16673: POP
16674: POP
// end ;
16675: PPOPN 2
16677: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
16678: LD_EXP 30
16682: IFFALSE 16831
16684: GO 16686
16686: DISABLE
16687: LD_INT 0
16689: PPUSH
16690: PPUSH
16691: PPUSH
16692: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
16693: LD_ADDR_VAR 0 4
16697: PUSH
16698: LD_EXP 55
16702: PUSH
16703: LD_EXP 54
16707: ADD
16708: PUSH
16709: LD_EXP 52
16713: ADD
16714: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
16715: LD_ADDR_VAR 0 3
16719: PUSH
16720: LD_INT 3
16722: PPUSH
16723: LD_INT 81
16725: PUSH
16726: LD_INT 3
16728: PUSH
16729: EMPTY
16730: LIST
16731: LIST
16732: PPUSH
16733: CALL_OW 70
16737: ST_TO_ADDR
// if filter and enemy then
16738: LD_VAR 0 4
16742: PUSH
16743: LD_VAR 0 3
16747: AND
16748: IFFALSE 16831
// repeat wait ( 0 0$01 ) ;
16750: LD_INT 35
16752: PPUSH
16753: CALL_OW 67
// for i in filter do
16757: LD_ADDR_VAR 0 1
16761: PUSH
16762: LD_VAR 0 4
16766: PUSH
16767: FOR_IN
16768: IFFALSE 16796
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
16770: LD_VAR 0 1
16774: PPUSH
16775: LD_VAR 0 3
16779: PPUSH
16780: LD_VAR 0 1
16784: PPUSH
16785: CALL_OW 74
16789: PPUSH
16790: CALL_OW 115
// end ;
16794: GO 16767
16796: POP
16797: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
16798: LD_INT 3
16800: PPUSH
16801: LD_INT 81
16803: PUSH
16804: LD_INT 3
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: PPUSH
16811: CALL_OW 70
16815: PUSH
16816: LD_INT 0
16818: EQUAL
16819: PUSH
16820: LD_VAR 0 4
16824: PUSH
16825: LD_INT 0
16827: EQUAL
16828: OR
16829: IFFALSE 16750
// end ;
16831: PPOPN 4
16833: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) do var i ;
16834: LD_EXP 25
16838: PUSH
16839: LD_INT 22
16841: PUSH
16842: LD_INT 4
16844: PUSH
16845: EMPTY
16846: LIST
16847: LIST
16848: PUSH
16849: LD_INT 30
16851: PUSH
16852: LD_INT 4
16854: PUSH
16855: EMPTY
16856: LIST
16857: LIST
16858: PUSH
16859: LD_INT 3
16861: PUSH
16862: LD_INT 57
16864: PUSH
16865: EMPTY
16866: LIST
16867: PUSH
16868: EMPTY
16869: LIST
16870: LIST
16871: PUSH
16872: EMPTY
16873: LIST
16874: LIST
16875: LIST
16876: PPUSH
16877: CALL_OW 69
16881: AND
16882: IFFALSE 16931
16884: GO 16886
16886: DISABLE
16887: LD_INT 0
16889: PPUSH
// begin if not ru_cornel_attack then
16890: LD_EXP 57
16894: NOT
16895: IFFALSE 16899
// exit ;
16897: GO 16931
// for i in ru_cornel_attack do
16899: LD_ADDR_VAR 0 1
16903: PUSH
16904: LD_EXP 57
16908: PUSH
16909: FOR_IN
16910: IFFALSE 16929
// ComAgressiveMove ( i , 258 , 119 ) ;
16912: LD_VAR 0 1
16916: PPUSH
16917: LD_INT 258
16919: PPUSH
16920: LD_INT 119
16922: PPUSH
16923: CALL_OW 114
16927: GO 16909
16929: POP
16930: POP
// end ; end_of_file
16931: PPOPN 1
16933: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
16934: LD_EXP 5
16938: PUSH
16939: LD_EXP 9
16943: NOT
16944: AND
16945: PUSH
16946: LD_EXP 19
16950: AND
16951: IFFALSE 17063
16953: GO 16955
16955: DISABLE
16956: LD_INT 0
16958: PPUSH
// begin enable ;
16959: ENABLE
// crates_counter := crates_counter - 50 ;
16960: LD_ADDR_EXP 19
16964: PUSH
16965: LD_EXP 19
16969: PUSH
16970: LD_INT 50
16972: MINUS
16973: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
16974: LD_INT 8
16976: PPUSH
16977: LD_INT 2
16979: PPUSH
16980: LD_INT 5
16982: PPUSH
16983: CALL_OW 12
16987: PPUSH
16988: LD_INT 1
16990: PPUSH
16991: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
16995: LD_INT 1785
16997: PPUSH
16998: LD_INT 2345
17000: PPUSH
17001: CALL_OW 12
17005: PPUSH
17006: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
17010: LD_ADDR_VAR 0 1
17014: PUSH
17015: LD_INT 1
17017: PPUSH
17018: LD_OWVAR 67
17022: PUSH
17023: LD_INT 2
17025: PLUS
17026: PPUSH
17027: CALL_OW 12
17031: ST_TO_ADDR
// if r < 3 then
17032: LD_VAR 0 1
17036: PUSH
17037: LD_INT 3
17039: LESS
17040: IFFALSE 17063
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
17042: LD_INT 4
17044: PPUSH
17045: LD_INT 1
17047: PPUSH
17048: LD_INT 5
17050: PPUSH
17051: CALL_OW 12
17055: PPUSH
17056: LD_INT 1
17058: PPUSH
17059: CALL_OW 55
// end ;
17063: PPOPN 1
17065: END
// every 0 0$01 trigger cornel_active do
17066: LD_EXP 8
17070: IFFALSE 17159
17072: GO 17074
17074: DISABLE
// begin Wait ( 0 0$03 ) ;
17075: LD_INT 105
17077: PPUSH
17078: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17082: LD_INT 2
17084: PPUSH
17085: LD_INT 5
17087: PPUSH
17088: CALL_OW 12
17092: PPUSH
17093: LD_INT 10
17095: PPUSH
17096: LD_INT 1
17098: PPUSH
17099: CALL_OW 55
// Wait ( 0 0$13 ) ;
17103: LD_INT 455
17105: PPUSH
17106: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17110: LD_INT 2
17112: PPUSH
17113: LD_INT 5
17115: PPUSH
17116: CALL_OW 12
17120: PPUSH
17121: LD_INT 10
17123: PPUSH
17124: LD_INT 1
17126: PPUSH
17127: CALL_OW 55
// Wait ( 0 0$16 ) ;
17131: LD_INT 560
17133: PPUSH
17134: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
17138: LD_INT 2
17140: PPUSH
17141: LD_INT 5
17143: PPUSH
17144: CALL_OW 12
17148: PPUSH
17149: LD_INT 10
17151: PPUSH
17152: LD_INT 1
17154: PPUSH
17155: CALL_OW 55
// end ; end_of_file
17159: END
// every 0 0$01 trigger cornel_prepared do
17160: LD_EXP 11
17164: IFFALSE 17223
17166: GO 17168
17168: DISABLE
// begin enable ;
17169: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
17170: LD_ADDR_OWVAR 47
17174: PUSH
17175: LD_STRING #Am03-1
17177: PUSH
17178: LD_EXP 10
17182: PUSH
17183: EMPTY
17184: LIST
17185: LIST
17186: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
17187: LD_ADDR_EXP 10
17191: PUSH
17192: LD_EXP 10
17196: PPUSH
17197: LD_STRING -
17199: PPUSH
17200: CALL 1117 0 2
17204: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
17205: LD_EXP 10
17209: PUSH
17210: LD_INT 0
17212: EQUAL
17213: IFFALSE 17223
// begin Display_Strings := [ ] ;
17215: LD_ADDR_OWVAR 47
17219: PUSH
17220: EMPTY
17221: ST_TO_ADDR
// disable ;
17222: DISABLE
// end ; end ;
17223: END
// every 0 0$01 trigger debug and debug_strings do
17224: LD_EXP 1
17228: PUSH
17229: LD_OWVAR 48
17233: AND
17234: IFFALSE 17250
17236: GO 17238
17238: DISABLE
// begin enable ;
17239: ENABLE
// Display_Strings := debug_strings ;
17240: LD_ADDR_OWVAR 47
17244: PUSH
17245: LD_OWVAR 48
17249: ST_TO_ADDR
// end ; end_of_file
17250: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
17251: LD_VAR 0 1
17255: PPUSH
17256: CALL_OW 255
17260: PUSH
17261: LD_INT 1
17263: EQUAL
17264: PUSH
17265: LD_EXP 13
17269: NOT
17270: AND
17271: IFFALSE 17281
// solar_builded := true ;
17273: LD_ADDR_EXP 13
17277: PUSH
17278: LD_INT 1
17280: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
17281: LD_VAR 0 1
17285: PPUSH
17286: CALL_OW 255
17290: PUSH
17291: LD_INT 1
17293: EQUAL
17294: PUSH
17295: LD_EXP 28
17299: AND
17300: IFFALSE 17333
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
17302: LD_ADDR_EXP 28
17306: PUSH
17307: LD_EXP 28
17311: PUSH
17312: LD_INT 1750
17314: PUSH
17315: LD_INT 1400
17317: PUSH
17318: LD_INT 1225
17320: PUSH
17321: EMPTY
17322: LIST
17323: LIST
17324: LIST
17325: PUSH
17326: LD_OWVAR 67
17330: ARRAY
17331: PLUS
17332: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
17333: LD_VAR 0 1
17337: PPUSH
17338: CALL_OW 255
17342: PUSH
17343: LD_INT 3
17345: EQUAL
17346: IFFALSE 17364
// ru_vehicles := ru_vehicles ^ veh ;
17348: LD_ADDR_EXP 55
17352: PUSH
17353: LD_EXP 55
17357: PUSH
17358: LD_VAR 0 1
17362: ADD
17363: ST_TO_ADDR
// end ;
17364: PPOPN 2
17366: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
17367: LD_VAR 0 1
17371: PUSH
17372: LD_EXP 52
17376: IN
17377: IFFALSE 17395
// ru_patrol := ru_patrol diff un ;
17379: LD_ADDR_EXP 52
17383: PUSH
17384: LD_EXP 52
17388: PUSH
17389: LD_VAR 0 1
17393: DIFF
17394: ST_TO_ADDR
// if un in ru_forest then
17395: LD_VAR 0 1
17399: PUSH
17400: LD_EXP 54
17404: IN
17405: IFFALSE 17423
// ru_forest := ru_forest diff un ;
17407: LD_ADDR_EXP 54
17411: PUSH
17412: LD_EXP 54
17416: PUSH
17417: LD_VAR 0 1
17421: DIFF
17422: ST_TO_ADDR
// if un in ru_vehicles then
17423: LD_VAR 0 1
17427: PUSH
17428: LD_EXP 55
17432: IN
17433: IFFALSE 17508
// begin ru_vehicles := ru_vehicles diff un ;
17435: LD_ADDR_EXP 55
17439: PUSH
17440: LD_EXP 55
17444: PUSH
17445: LD_VAR 0 1
17449: DIFF
17450: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
17451: LD_ADDR_EXP 56
17455: PUSH
17456: LD_EXP 56
17460: PUSH
17461: LD_VAR 0 1
17465: PPUSH
17466: CALL_OW 265
17470: PUSH
17471: LD_VAR 0 1
17475: PPUSH
17476: CALL_OW 262
17480: PUSH
17481: LD_VAR 0 1
17485: PPUSH
17486: CALL_OW 263
17490: PUSH
17491: LD_VAR 0 1
17495: PPUSH
17496: CALL_OW 264
17500: PUSH
17501: EMPTY
17502: LIST
17503: LIST
17504: LIST
17505: LIST
17506: ADD
17507: ST_TO_ADDR
// end ; if un = JMM then
17508: LD_VAR 0 1
17512: PUSH
17513: LD_EXP 36
17517: EQUAL
17518: IFFALSE 17527
// YouLost ( 0 ) ;
17520: LD_STRING 0
17522: PPUSH
17523: CALL_OW 104
// if un = us_dep_west then
17527: LD_VAR 0 1
17531: PUSH
17532: LD_INT 1
17534: EQUAL
17535: IFFALSE 17544
// YouLost ( 2 ) ;
17537: LD_STRING 2
17539: PPUSH
17540: CALL_OW 104
// if GetSide ( un ) = 8 and not jmm_on_west then
17544: LD_VAR 0 1
17548: PPUSH
17549: CALL_OW 255
17553: PUSH
17554: LD_INT 8
17556: EQUAL
17557: PUSH
17558: LD_EXP 5
17562: NOT
17563: AND
17564: IFFALSE 17573
// YouLost ( 4 ) ;
17566: LD_STRING 4
17568: PPUSH
17569: CALL_OW 104
// if un in jmm_units then
17573: LD_VAR 0 1
17577: PUSH
17578: LD_EXP 4
17582: IN
17583: IFFALSE 17599
// lose_counter := lose_counter + 1 ;
17585: LD_ADDR_EXP 33
17589: PUSH
17590: LD_EXP 33
17594: PUSH
17595: LD_INT 1
17597: PLUS
17598: ST_TO_ADDR
// end ;
17599: PPOPN 1
17601: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
17602: LD_INT 0
17604: PPUSH
17605: PPUSH
// begin if GetSide ( driver ) = 3 then
17606: LD_VAR 0 1
17610: PPUSH
17611: CALL_OW 255
17615: PUSH
17616: LD_INT 3
17618: EQUAL
17619: IFFALSE 17697
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
17621: LD_ADDR_VAR 0 6
17625: PUSH
17626: LD_INT 22
17628: PUSH
17629: LD_INT 3
17631: PUSH
17632: EMPTY
17633: LIST
17634: LIST
17635: PUSH
17636: LD_INT 30
17638: PUSH
17639: LD_INT 3
17641: PUSH
17642: EMPTY
17643: LIST
17644: LIST
17645: PUSH
17646: EMPTY
17647: LIST
17648: LIST
17649: PPUSH
17650: CALL_OW 69
17654: PPUSH
17655: CALL 1047 0 1
17659: ST_TO_ADDR
// if place then
17660: LD_VAR 0 6
17664: IFFALSE 17682
// ComEnterUnit ( driver , place ) else
17666: LD_VAR 0 1
17670: PPUSH
17671: LD_VAR 0 6
17675: PPUSH
17676: CALL_OW 120
17680: GO 17697
// ComMoveXY ( driver , 70 , 22 ) ;
17682: LD_VAR 0 1
17686: PPUSH
17687: LD_INT 70
17689: PPUSH
17690: LD_INT 22
17692: PPUSH
17693: CALL_OW 111
// end ; end ;
17697: PPOPN 6
17699: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and ( s2 = 4 or ( s2 = 8 and not jmm_on_west ) ) then
17700: LD_VAR 0 1
17704: PUSH
17705: LD_INT 1
17707: EQUAL
17708: PUSH
17709: LD_VAR 0 2
17713: PUSH
17714: LD_INT 4
17716: EQUAL
17717: PUSH
17718: LD_VAR 0 2
17722: PUSH
17723: LD_INT 8
17725: EQUAL
17726: PUSH
17727: LD_EXP 5
17731: NOT
17732: AND
17733: OR
17734: AND
17735: IFFALSE 17744
// YouLost ( 5 ) ;
17737: LD_STRING 5
17739: PPUSH
17740: CALL_OW 104
// end ;
17744: PPOPN 2
17746: END
// every 0 0$01 trigger save_counter + ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ) < 5 do
17747: LD_EXP 35
17751: PUSH
17752: LD_INT 22
17754: PUSH
17755: LD_INT 1
17757: PUSH
17758: EMPTY
17759: LIST
17760: LIST
17761: PUSH
17762: LD_INT 21
17764: PUSH
17765: LD_INT 1
17767: PUSH
17768: EMPTY
17769: LIST
17770: LIST
17771: PUSH
17772: EMPTY
17773: LIST
17774: LIST
17775: PPUSH
17776: CALL_OW 69
17780: PUSH
17781: LD_INT 22
17783: PUSH
17784: LD_INT 8
17786: PUSH
17787: EMPTY
17788: LIST
17789: LIST
17790: PUSH
17791: LD_INT 21
17793: PUSH
17794: LD_INT 1
17796: PUSH
17797: EMPTY
17798: LIST
17799: LIST
17800: PUSH
17801: EMPTY
17802: LIST
17803: LIST
17804: PPUSH
17805: CALL_OW 69
17809: ADD
17810: PLUS
17811: PUSH
17812: LD_INT 5
17814: LESS
17815: IFFALSE 17827
17817: GO 17819
17819: DISABLE
// YouLost ( 1 ) ;
17820: LD_STRING 1
17822: PPUSH
17823: CALL_OW 104
17827: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
17828: LD_INT 1
17830: PPUSH
17831: CALL_OW 255
17835: PUSH
17836: LD_INT 3
17838: EQUAL
17839: IFFALSE 17851
17841: GO 17843
17843: DISABLE
// YouLost ( 3 ) ;
17844: LD_STRING 3
17846: PPUSH
17847: CALL_OW 104
17851: END
