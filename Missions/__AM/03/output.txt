// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 323 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 411 0 0
// PrepareRussian ;
  22: CALL 2898 0 0
// PrepareAmerican ;
  26: CALL 1139 0 0
// PrepareCornell ;
  30: CALL 2163 0 0
// PrepareWesternBase ;
  34: CALL 2389 0 0
// Action ;
  38: CALL 4904 0 0
// end ;
  42: END
// export debug ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// jmm_units := 0 ;
  54: LD_ADDR_EXP 2
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// cornel_units := 0 ;
  62: LD_ADDR_EXP 4
  66: PUSH
  67: LD_INT 0
  69: ST_TO_ADDR
// bierezov_exist := false ;
  70: LD_ADDR_EXP 5
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// jmm_on_west := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// cornel_active := false ;
  86: LD_ADDR_EXP 6
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// cornel_attack := false ;
  94: LD_ADDR_EXP 7
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_prepared := false ;
 102: LD_ADDR_EXP 9
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 110: LD_ADDR_EXP 8
 114: PUSH
 115: LD_INT 4200
 117: ST_TO_ADDR
// frank_can_return := false ;
 118: LD_ADDR_EXP 10
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// solar_builded := false ;
 126: LD_ADDR_EXP 11
 130: PUSH
 131: LD_INT 0
 133: ST_TO_ADDR
// frank_send_to_scout := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// jmm_in_veh := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// bobby_in_veh := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// cyrus_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// lisa_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 174: LD_ADDR_EXP 25
 178: PUSH
 179: LD_INT 25200
 181: PUSH
 182: LD_INT 23100
 184: PUSH
 185: LD_INT 21000
 187: PUSH
 188: EMPTY
 189: LIST
 190: LIST
 191: LIST
 192: PUSH
 193: LD_OWVAR 67
 197: ARRAY
 198: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 199: LD_ADDR_EXP 17
 203: PUSH
 204: LD_INT 600
 206: PUSH
 207: LD_INT 500
 209: PUSH
 210: LD_INT 400
 212: PUSH
 213: EMPTY
 214: LIST
 215: LIST
 216: LIST
 217: PUSH
 218: LD_OWVAR 67
 222: ARRAY
 223: ST_TO_ADDR
// end_mission_allowed := false ;
 224: LD_ADDR_EXP 18
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// save_others := [ ] ;
 232: LD_ADDR_EXP 19
 236: PUSH
 237: EMPTY
 238: ST_TO_ADDR
// save_group := [ ] ;
 239: LD_ADDR_EXP 20
 243: PUSH
 244: EMPTY
 245: ST_TO_ADDR
// show_query := true ;
 246: LD_ADDR_EXP 21
 250: PUSH
 251: LD_INT 1
 253: ST_TO_ADDR
// wait_for_them := false ;
 254: LD_ADDR_EXP 22
 258: PUSH
 259: LD_INT 0
 261: ST_TO_ADDR
// veh_on_meta := false ;
 262: LD_ADDR_EXP 24
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// send_spec_patrol := false ;
 270: LD_ADDR_EXP 26
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// prepare_siege := false ;
 278: LD_ADDR_EXP 27
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_attack_on_cornel := false ;
 286: LD_ADDR_EXP 28
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 294: LD_ADDR_EXP 23
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// game_end := false ;
 302: LD_ADDR_EXP 29
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// lose_counter := 0 ;
 310: LD_ADDR_EXP 30
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// end ;
 318: LD_VAR 0 1
 322: RET
// function SetDiplomacy ; begin
 323: LD_INT 0
 325: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 326: LD_INT 1
 328: PPUSH
 329: LD_INT 4
 331: PPUSH
 332: LD_INT 1
 334: PPUSH
 335: LD_INT 1
 337: PPUSH
 338: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 342: LD_INT 1
 344: PPUSH
 345: LD_INT 8
 347: PPUSH
 348: LD_INT 1
 350: PPUSH
 351: LD_INT 1
 353: PPUSH
 354: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 358: LD_INT 3
 360: PPUSH
 361: LD_INT 6
 363: PPUSH
 364: LD_INT 1
 366: PPUSH
 367: LD_INT 1
 369: PPUSH
 370: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 374: LD_INT 4
 376: PPUSH
 377: LD_INT 6
 379: PPUSH
 380: LD_INT 0
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 390: LD_INT 3
 392: PPUSH
 393: LD_INT 8
 395: PPUSH
 396: LD_INT 0
 398: PPUSH
 399: LD_INT 1
 401: PPUSH
 402: CALL_OW 80
// end ;
 406: LD_VAR 0 1
 410: RET
// export function DebugMode ; var i ; begin
 411: LD_INT 0
 413: PPUSH
 414: PPUSH
// FogOff ( 1 ) ;
 415: LD_INT 1
 417: PPUSH
 418: CALL_OW 344
// debug_strings := [ ] ;
 422: LD_ADDR_OWVAR 48
 426: PUSH
 427: EMPTY
 428: ST_TO_ADDR
// end ; end_of_file
 429: LD_VAR 0 1
 433: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 434: LD_INT 0
 436: PPUSH
 437: PPUSH
// if exist_mode then
 438: LD_VAR 0 2
 442: IFFALSE 461
// unit := CreateCharacter ( ident ) else
 444: LD_ADDR_VAR 0 4
 448: PUSH
 449: LD_VAR 0 1
 453: PPUSH
 454: CALL_OW 34
 458: ST_TO_ADDR
 459: GO 476
// unit := NewCharacter ( ident ) ;
 461: LD_ADDR_VAR 0 4
 465: PUSH
 466: LD_VAR 0 1
 470: PPUSH
 471: CALL_OW 25
 475: ST_TO_ADDR
// result := unit ;
 476: LD_ADDR_VAR 0 3
 480: PUSH
 481: LD_VAR 0 4
 485: ST_TO_ADDR
// end ;
 486: LD_VAR 0 3
 490: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 491: LD_INT 0
 493: PPUSH
// uc_side := side ;
 494: LD_ADDR_OWVAR 20
 498: PUSH
 499: LD_VAR 0 1
 503: ST_TO_ADDR
// uc_nation := nation ;
 504: LD_ADDR_OWVAR 21
 508: PUSH
 509: LD_VAR 0 2
 513: ST_TO_ADDR
// vc_chassis := chassis ;
 514: LD_ADDR_OWVAR 37
 518: PUSH
 519: LD_VAR 0 3
 523: ST_TO_ADDR
// vc_engine := engine ;
 524: LD_ADDR_OWVAR 39
 528: PUSH
 529: LD_VAR 0 4
 533: ST_TO_ADDR
// vc_control := control ;
 534: LD_ADDR_OWVAR 38
 538: PUSH
 539: LD_VAR 0 5
 543: ST_TO_ADDR
// vc_weapon := weapon ;
 544: LD_ADDR_OWVAR 40
 548: PUSH
 549: LD_VAR 0 6
 553: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 554: LD_ADDR_OWVAR 41
 558: PUSH
 559: LD_VAR 0 7
 563: ST_TO_ADDR
// result := CreateVehicle ;
 564: LD_ADDR_VAR 0 8
 568: PUSH
 569: CALL_OW 45
 573: ST_TO_ADDR
// end ;
 574: LD_VAR 0 8
 578: RET
// export function SayX ( units , ident ) ; var i ; begin
 579: LD_INT 0
 581: PPUSH
 582: PPUSH
// result := false ;
 583: LD_ADDR_VAR 0 3
 587: PUSH
 588: LD_INT 0
 590: ST_TO_ADDR
// if not units then
 591: LD_VAR 0 1
 595: NOT
 596: IFFALSE 600
// exit ;
 598: GO 654
// for i in units do
 600: LD_ADDR_VAR 0 4
 604: PUSH
 605: LD_VAR 0 1
 609: PUSH
 610: FOR_IN
 611: IFFALSE 652
// if IsOk ( i ) then
 613: LD_VAR 0 4
 617: PPUSH
 618: CALL_OW 302
 622: IFFALSE 650
// begin Say ( i , ident ) ;
 624: LD_VAR 0 4
 628: PPUSH
 629: LD_VAR 0 2
 633: PPUSH
 634: CALL_OW 88
// result := i ;
 638: LD_ADDR_VAR 0 3
 642: PUSH
 643: LD_VAR 0 4
 647: ST_TO_ADDR
// break ;
 648: GO 652
// end ;
 650: GO 610
 652: POP
 653: POP
// end ;
 654: LD_VAR 0 3
 658: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 659: LD_INT 0
 661: PPUSH
 662: PPUSH
 663: PPUSH
 664: PPUSH
// for i = 1 to count do
 665: LD_ADDR_VAR 0 8
 669: PUSH
 670: DOUBLE
 671: LD_INT 1
 673: DEC
 674: ST_TO_ADDR
 675: LD_VAR 0 6
 679: PUSH
 680: FOR_TO
 681: IFFALSE 762
// begin uc_side = side ;
 683: LD_ADDR_OWVAR 20
 687: PUSH
 688: LD_VAR 0 1
 692: ST_TO_ADDR
// uc_nation = nation ;
 693: LD_ADDR_OWVAR 21
 697: PUSH
 698: LD_VAR 0 2
 702: ST_TO_ADDR
// hc_gallery =  ;
 703: LD_ADDR_OWVAR 33
 707: PUSH
 708: LD_STRING 
 710: ST_TO_ADDR
// hc_name =  ;
 711: LD_ADDR_OWVAR 26
 715: PUSH
 716: LD_STRING 
 718: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 719: LD_INT 0
 721: PPUSH
 722: LD_VAR 0 5
 726: PPUSH
 727: LD_VAR 0 4
 731: PPUSH
 732: CALL_OW 380
// un = CreateHuman ;
 736: LD_ADDR_VAR 0 10
 740: PUSH
 741: CALL_OW 44
 745: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 746: LD_VAR 0 10
 750: PPUSH
 751: LD_VAR 0 3
 755: PPUSH
 756: CALL_OW 52
// end ;
 760: GO 680
 762: POP
 763: POP
// end ;
 764: LD_VAR 0 7
 768: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 769: LD_INT 0
 771: PPUSH
 772: PPUSH
 773: PPUSH
// uc_side := GetSide ( b ) ;
 774: LD_ADDR_OWVAR 20
 778: PUSH
 779: LD_VAR 0 2
 783: PPUSH
 784: CALL_OW 255
 788: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 789: LD_ADDR_OWVAR 21
 793: PUSH
 794: LD_VAR 0 2
 798: PPUSH
 799: CALL_OW 248
 803: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 804: LD_INT 0
 806: PPUSH
 807: LD_INT 1
 809: PPUSH
 810: LD_VAR 0 1
 814: PPUSH
 815: CALL_OW 380
// un = CreateHuman ;
 819: LD_ADDR_VAR 0 4
 823: PUSH
 824: CALL_OW 44
 828: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 829: LD_ADDR_VAR 0 5
 833: PUSH
 834: LD_VAR 0 2
 838: PPUSH
 839: CALL_OW 254
 843: PUSH
 844: LD_INT 3
 846: MINUS
 847: ST_TO_ADDR
// if dir < 0 then
 848: LD_VAR 0 5
 852: PUSH
 853: LD_INT 0
 855: LESS
 856: IFFALSE 872
// dir := 6 + dir ;
 858: LD_ADDR_VAR 0 5
 862: PUSH
 863: LD_INT 6
 865: PUSH
 866: LD_VAR 0 5
 870: PLUS
 871: ST_TO_ADDR
// SetDir ( un , dir ) ;
 872: LD_VAR 0 4
 876: PPUSH
 877: LD_VAR 0 5
 881: PPUSH
 882: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 886: LD_VAR 0 4
 890: PPUSH
 891: LD_VAR 0 2
 895: PPUSH
 896: CALL_OW 52
// end ;
 900: LD_VAR 0 3
 904: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 905: LD_INT 0
 907: PPUSH
 908: PPUSH
 909: PPUSH
// result := false ;
 910: LD_ADDR_VAR 0 2
 914: PUSH
 915: LD_INT 0
 917: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 918: LD_ADDR_VAR 0 3
 922: PUSH
 923: LD_INT 22
 925: PUSH
 926: LD_INT 1
 928: PUSH
 929: EMPTY
 930: LIST
 931: LIST
 932: PUSH
 933: LD_INT 34
 935: PUSH
 936: LD_INT 2
 938: PUSH
 939: EMPTY
 940: LIST
 941: LIST
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: PPUSH
 947: CALL_OW 69
 951: ST_TO_ADDR
// for i in filter do
 952: LD_ADDR_VAR 0 4
 956: PUSH
 957: LD_VAR 0 3
 961: PUSH
 962: FOR_IN
 963: IFFALSE 994
// if IsDrivenBy ( i ) = unit then
 965: LD_VAR 0 4
 969: PPUSH
 970: CALL_OW 311
 974: PUSH
 975: LD_VAR 0 1
 979: EQUAL
 980: IFFALSE 992
// begin result := true ;
 982: LD_ADDR_VAR 0 2
 986: PUSH
 987: LD_INT 1
 989: ST_TO_ADDR
// break ;
 990: GO 994
// end ;
 992: GO 962
 994: POP
 995: POP
// end ;
 996: LD_VAR 0 2
1000: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1001: LD_INT 0
1003: PPUSH
1004: PPUSH
// result := false ;
1005: LD_ADDR_VAR 0 2
1009: PUSH
1010: LD_INT 0
1012: ST_TO_ADDR
// if not blist then
1013: LD_VAR 0 1
1017: NOT
1018: IFFALSE 1022
// exit ;
1020: GO 1066
// for i in blist do
1022: LD_ADDR_VAR 0 3
1026: PUSH
1027: LD_VAR 0 1
1031: PUSH
1032: FOR_IN
1033: IFFALSE 1064
// if UnitsInside ( i ) < 6 then
1035: LD_VAR 0 3
1039: PPUSH
1040: CALL_OW 313
1044: PUSH
1045: LD_INT 6
1047: LESS
1048: IFFALSE 1062
// begin result := i ;
1050: LD_ADDR_VAR 0 2
1054: PUSH
1055: LD_VAR 0 3
1059: ST_TO_ADDR
// break ;
1060: GO 1064
// end ;
1062: GO 1032
1064: POP
1065: POP
// end ;
1066: LD_VAR 0 2
1070: RET
// export function Count ( timer , mode ) ; begin
1071: LD_INT 0
1073: PPUSH
// if not timer then
1074: LD_VAR 0 1
1078: NOT
1079: IFFALSE 1083
// exit ;
1081: GO 1134
// if mode in [ asc , up , + ] then
1083: LD_VAR 0 2
1087: PUSH
1088: LD_STRING asc
1090: PUSH
1091: LD_STRING up
1093: PUSH
1094: LD_STRING +
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: IN
1102: IFFALSE 1120
// result := timer + 0 0$01 else
1104: LD_ADDR_VAR 0 3
1108: PUSH
1109: LD_VAR 0 1
1113: PUSH
1114: LD_INT 35
1116: PLUS
1117: ST_TO_ADDR
1118: GO 1134
// result := timer - 0 0$01 ;
1120: LD_ADDR_VAR 0 3
1124: PUSH
1125: LD_VAR 0 1
1129: PUSH
1130: LD_INT 35
1132: MINUS
1133: ST_TO_ADDR
// end ; end_of_file
1134: LD_VAR 0 3
1138: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1139: LD_INT 0
1141: PPUSH
1142: PPUSH
1143: PPUSH
1144: PPUSH
1145: PPUSH
1146: PPUSH
1147: PPUSH
1148: PPUSH
// uc_side := 4 ;
1149: LD_ADDR_OWVAR 20
1153: PUSH
1154: LD_INT 4
1156: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1157: LD_ADDR_EXP 40
1161: PUSH
1162: LD_STRING Powell
1164: PPUSH
1165: LD_INT 0
1167: PPUSH
1168: CALL 434 0 2
1172: ST_TO_ADDR
// uc_side := 1 ;
1173: LD_ADDR_OWVAR 20
1177: PUSH
1178: LD_INT 1
1180: ST_TO_ADDR
// uc_nation := 1 ;
1181: LD_ADDR_OWVAR 21
1185: PUSH
1186: LD_INT 1
1188: ST_TO_ADDR
// if debug then
1189: LD_EXP 1
1193: IFFALSE 1323
// begin for i = 1 to 4 do
1195: LD_ADDR_VAR 0 2
1199: PUSH
1200: DOUBLE
1201: LD_INT 1
1203: DEC
1204: ST_TO_ADDR
1205: LD_INT 4
1207: PUSH
1208: FOR_TO
1209: IFFALSE 1260
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1211: LD_INT 0
1213: PPUSH
1214: LD_INT 1
1216: PPUSH
1217: LD_INT 2
1219: PPUSH
1220: CALL_OW 12
1224: PPUSH
1225: LD_INT 3
1227: PPUSH
1228: CALL_OW 380
// un := CreateHuman ;
1232: LD_ADDR_VAR 0 3
1236: PUSH
1237: CALL_OW 44
1241: ST_TO_ADDR
// others := others ^ un ;
1242: LD_ADDR_VAR 0 5
1246: PUSH
1247: LD_VAR 0 5
1251: PUSH
1252: LD_VAR 0 3
1256: ADD
1257: ST_TO_ADDR
// end ;
1258: GO 1208
1260: POP
1261: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1262: LD_ADDR_VAR 0 6
1266: PUSH
1267: LD_INT 21
1269: PUSH
1270: LD_INT 1
1272: PUSH
1273: LD_INT 1
1275: PUSH
1276: LD_INT 51
1278: PUSH
1279: LD_INT 90
1281: PUSH
1282: LD_INT 504
1284: PUSH
1285: EMPTY
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: PUSH
1293: LD_INT 21
1295: PUSH
1296: LD_INT 1
1298: PUSH
1299: LD_INT 1
1301: PUSH
1302: LD_INT 51
1304: PUSH
1305: LD_INT 80
1307: PUSH
1308: LD_INT 750
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: PUSH
1319: EMPTY
1320: LIST
1321: LIST
1322: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1323: LD_ADDR_EXP 31
1327: PUSH
1328: LD_STRING JMM
1330: PPUSH
1331: LD_EXP 1
1335: NOT
1336: PPUSH
1337: CALL 434 0 2
1341: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1342: LD_ADDR_EXP 32
1346: PUSH
1347: LD_STRING Bobby
1349: PPUSH
1350: LD_EXP 1
1354: NOT
1355: PPUSH
1356: CALL 434 0 2
1360: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1361: LD_ADDR_EXP 33
1365: PUSH
1366: LD_STRING Cyrus
1368: PPUSH
1369: LD_EXP 1
1373: NOT
1374: PPUSH
1375: CALL 434 0 2
1379: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1380: LD_ADDR_EXP 34
1384: PUSH
1385: LD_STRING Lisa
1387: PPUSH
1388: LD_EXP 1
1392: NOT
1393: PPUSH
1394: CALL 434 0 2
1398: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1399: LD_ADDR_EXP 35
1403: PUSH
1404: LD_STRING Khatam
1406: PPUSH
1407: LD_EXP 1
1411: NOT
1412: PPUSH
1413: CALL 434 0 2
1417: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1418: LD_ADDR_EXP 36
1422: PUSH
1423: LD_STRING Brian
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: CALL 434 0 2
1436: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1437: LD_ADDR_EXP 37
1441: PUSH
1442: LD_STRING Jerry
1444: PPUSH
1445: LD_EXP 1
1449: NOT
1450: PPUSH
1451: CALL 434 0 2
1455: ST_TO_ADDR
// if Bobby then
1456: LD_EXP 32
1460: IFFALSE 1491
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1462: LD_ADDR_VAR 0 4
1466: PUSH
1467: LD_VAR 0 4
1471: PPUSH
1472: LD_VAR 0 4
1476: PUSH
1477: LD_INT 1
1479: PLUS
1480: PPUSH
1481: LD_EXP 32
1485: PPUSH
1486: CALL_OW 2
1490: ST_TO_ADDR
// if Cyrus then
1491: LD_EXP 33
1495: IFFALSE 1526
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1497: LD_ADDR_VAR 0 4
1501: PUSH
1502: LD_VAR 0 4
1506: PPUSH
1507: LD_VAR 0 4
1511: PUSH
1512: LD_INT 1
1514: PLUS
1515: PPUSH
1516: LD_EXP 33
1520: PPUSH
1521: CALL_OW 2
1525: ST_TO_ADDR
// if Lisa then
1526: LD_EXP 34
1530: IFFALSE 1561
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1532: LD_ADDR_VAR 0 4
1536: PUSH
1537: LD_VAR 0 4
1541: PPUSH
1542: LD_VAR 0 4
1546: PUSH
1547: LD_INT 1
1549: PLUS
1550: PPUSH
1551: LD_EXP 34
1555: PPUSH
1556: CALL_OW 2
1560: ST_TO_ADDR
// if Khatam then
1561: LD_EXP 35
1565: IFFALSE 1596
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1567: LD_ADDR_VAR 0 4
1571: PUSH
1572: LD_VAR 0 4
1576: PPUSH
1577: LD_VAR 0 4
1581: PUSH
1582: LD_INT 1
1584: PLUS
1585: PPUSH
1586: LD_EXP 35
1590: PPUSH
1591: CALL_OW 2
1595: ST_TO_ADDR
// if Brian then
1596: LD_EXP 36
1600: IFFALSE 1631
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1602: LD_ADDR_VAR 0 4
1606: PUSH
1607: LD_VAR 0 4
1611: PPUSH
1612: LD_VAR 0 4
1616: PUSH
1617: LD_INT 1
1619: PLUS
1620: PPUSH
1621: LD_EXP 36
1625: PPUSH
1626: CALL_OW 2
1630: ST_TO_ADDR
// if Jerry then
1631: LD_EXP 37
1635: IFFALSE 1666
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1637: LD_ADDR_VAR 0 4
1641: PUSH
1642: LD_VAR 0 4
1646: PPUSH
1647: LD_VAR 0 4
1651: PUSH
1652: LD_INT 1
1654: PLUS
1655: PPUSH
1656: LD_EXP 37
1660: PPUSH
1661: CALL_OW 2
1665: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1666: LD_STRING 02_other_survivors
1668: PPUSH
1669: CALL_OW 28
1673: IFFALSE 1688
// others := CreateCharacterSet ( 02_other_survivors ) ;
1675: LD_ADDR_VAR 0 5
1679: PUSH
1680: LD_STRING 02_other_survivors
1682: PPUSH
1683: CALL_OW 31
1687: ST_TO_ADDR
// if others then
1688: LD_VAR 0 5
1692: IFFALSE 1717
// begin tmp := tmp ^ others ;
1694: LD_ADDR_VAR 0 4
1698: PUSH
1699: LD_VAR 0 4
1703: PUSH
1704: LD_VAR 0 5
1708: ADD
1709: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1710: LD_STRING 02_other_survivors
1712: PPUSH
1713: CALL_OW 40
// end ; jmm_units := tmp ;
1717: LD_ADDR_EXP 2
1721: PUSH
1722: LD_VAR 0 4
1726: ST_TO_ADDR
// if not vehicles then
1727: LD_VAR 0 6
1731: NOT
1732: IFFALSE 1750
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1734: LD_ADDR_VAR 0 6
1738: PUSH
1739: LD_STRING 02_tanks_1
1741: PPUSH
1742: LD_INT 0
1744: PPUSH
1745: CALL_OW 30
1749: ST_TO_ADDR
// if vehicles then
1750: LD_VAR 0 6
1754: IFFALSE 1948
// begin got_mech := false ;
1756: LD_ADDR_VAR 0 7
1760: PUSH
1761: LD_INT 0
1763: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1764: LD_VAR 0 4
1768: PPUSH
1769: LD_INT 25
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PPUSH
1779: CALL_OW 72
1783: IFFALSE 1793
// got_mech := true ;
1785: LD_ADDR_VAR 0 7
1789: PUSH
1790: LD_INT 1
1792: ST_TO_ADDR
// for i = 1 to vehicles do
1793: LD_ADDR_VAR 0 2
1797: PUSH
1798: DOUBLE
1799: LD_INT 1
1801: DEC
1802: ST_TO_ADDR
1803: LD_VAR 0 6
1807: PUSH
1808: FOR_TO
1809: IFFALSE 1946
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1811: LD_ADDR_VAR 0 3
1815: PUSH
1816: LD_INT 1
1818: PPUSH
1819: LD_INT 3
1821: PPUSH
1822: LD_VAR 0 6
1826: PUSH
1827: LD_VAR 0 2
1831: ARRAY
1832: PUSH
1833: LD_INT 1
1835: ARRAY
1836: PPUSH
1837: LD_VAR 0 6
1841: PUSH
1842: LD_VAR 0 2
1846: ARRAY
1847: PUSH
1848: LD_INT 2
1850: ARRAY
1851: PPUSH
1852: LD_VAR 0 6
1856: PUSH
1857: LD_VAR 0 2
1861: ARRAY
1862: PUSH
1863: LD_INT 3
1865: ARRAY
1866: PPUSH
1867: LD_VAR 0 6
1871: PUSH
1872: LD_VAR 0 2
1876: ARRAY
1877: PUSH
1878: LD_INT 4
1880: ARRAY
1881: PPUSH
1882: LD_INT 40
1884: PPUSH
1885: CALL 491 0 7
1889: ST_TO_ADDR
// if not got_mech then
1890: LD_VAR 0 7
1894: NOT
1895: IFFALSE 1921
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1897: LD_VAR 0 3
1901: PPUSH
1902: LD_VAR 0 6
1906: PUSH
1907: LD_VAR 0 2
1911: ARRAY
1912: PUSH
1913: LD_INT 6
1915: ARRAY
1916: PPUSH
1917: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1921: LD_ADDR_VAR 0 4
1925: PUSH
1926: LD_VAR 0 4
1930: PPUSH
1931: LD_INT 1
1933: PPUSH
1934: LD_VAR 0 3
1938: PPUSH
1939: CALL_OW 2
1943: ST_TO_ADDR
// end ;
1944: GO 1808
1946: POP
1947: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1948: LD_EXP 31
1952: PPUSH
1953: LD_INT 194
1955: PPUSH
1956: LD_INT 119
1958: PPUSH
1959: LD_INT 0
1961: PPUSH
1962: CALL_OW 48
// if tmp then
1966: LD_VAR 0 4
1970: IFFALSE 2095
// begin for i in tmp do
1972: LD_ADDR_VAR 0 2
1976: PUSH
1977: LD_VAR 0 4
1981: PUSH
1982: FOR_IN
1983: IFFALSE 2093
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1985: LD_ADDR_VAR 0 8
1989: PUSH
1990: LD_INT 22
1992: PUSH
1993: LD_INT 1
1995: PUSH
1996: EMPTY
1997: LIST
1998: LIST
1999: PUSH
2000: LD_INT 21
2002: PUSH
2003: LD_INT 2
2005: PUSH
2006: EMPTY
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 58
2012: PUSH
2013: EMPTY
2014: LIST
2015: PUSH
2016: EMPTY
2017: LIST
2018: LIST
2019: LIST
2020: PPUSH
2021: CALL_OW 69
2025: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2026: LD_VAR 0 2
2030: PPUSH
2031: CALL_OW 247
2035: PUSH
2036: LD_INT 1
2038: EQUAL
2039: PUSH
2040: LD_VAR 0 8
2044: AND
2045: IFFALSE 2067
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2047: LD_VAR 0 2
2051: PPUSH
2052: LD_VAR 0 8
2056: PUSH
2057: LD_INT 1
2059: ARRAY
2060: PPUSH
2061: CALL_OW 52
2065: GO 2082
// PlaceUnitArea ( i , startArea , false ) ;
2067: LD_VAR 0 2
2071: PPUSH
2072: LD_INT 1
2074: PPUSH
2075: LD_INT 0
2077: PPUSH
2078: CALL_OW 49
// ComHold ( i ) ;
2082: LD_VAR 0 2
2086: PPUSH
2087: CALL_OW 140
// end ;
2091: GO 1982
2093: POP
2094: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2095: LD_ADDR_EXP 5
2099: PUSH
2100: LD_STRING 02_mikhailStatus_1
2102: PPUSH
2103: LD_INT 0
2105: PPUSH
2106: CALL_OW 30
2110: ST_TO_ADDR
// if not bierezov_exist and not debug then
2111: LD_EXP 5
2115: NOT
2116: PUSH
2117: LD_EXP 1
2121: NOT
2122: AND
2123: IFFALSE 2127
// exit ;
2125: GO 2158
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2127: LD_ADDR_EXP 39
2131: PUSH
2132: LD_STRING Mikhail
2134: PPUSH
2135: LD_INT 0
2137: PPUSH
2138: CALL 434 0 2
2142: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2143: LD_EXP 39
2147: PPUSH
2148: LD_INT 1
2150: PPUSH
2151: LD_INT 0
2153: PPUSH
2154: CALL_OW 49
// end ;
2158: LD_VAR 0 1
2162: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2163: LD_INT 0
2165: PPUSH
2166: PPUSH
2167: PPUSH
2168: PPUSH
// uc_side := 4 ;
2169: LD_ADDR_OWVAR 20
2173: PUSH
2174: LD_INT 4
2176: ST_TO_ADDR
// uc_nation := 1 ;
2177: LD_ADDR_OWVAR 21
2181: PUSH
2182: LD_INT 1
2184: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2185: LD_ADDR_EXP 38
2189: PUSH
2190: LD_STRING Cornell
2192: PPUSH
2193: LD_INT 0
2195: PPUSH
2196: CALL 434 0 2
2200: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
2201: LD_ADDR_EXP 4
2205: PUSH
2206: LD_INT 8
2208: PUSH
2209: LD_EXP 2
2213: MINUS
2214: ST_TO_ADDR
// tmp := [ ] ;
2215: LD_ADDR_VAR 0 2
2219: PUSH
2220: EMPTY
2221: ST_TO_ADDR
// if cornel_units < 3 then
2222: LD_EXP 4
2226: PUSH
2227: LD_INT 3
2229: LESS
2230: IFFALSE 2240
// cornel_units := 3 ;
2232: LD_ADDR_EXP 4
2236: PUSH
2237: LD_INT 3
2239: ST_TO_ADDR
// for i = 1 to cornel_units do
2240: LD_ADDR_VAR 0 4
2244: PUSH
2245: DOUBLE
2246: LD_INT 1
2248: DEC
2249: ST_TO_ADDR
2250: LD_EXP 4
2254: PUSH
2255: FOR_TO
2256: IFFALSE 2354
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2258: LD_INT 0
2260: PPUSH
2261: LD_INT 1
2263: PUSH
2264: LD_INT 1
2266: PUSH
2267: LD_INT 1
2269: PUSH
2270: LD_INT 2
2272: PUSH
2273: LD_INT 4
2275: PUSH
2276: EMPTY
2277: LIST
2278: LIST
2279: LIST
2280: LIST
2281: LIST
2282: PUSH
2283: LD_VAR 0 4
2287: PUSH
2288: LD_INT 5
2290: MOD
2291: PUSH
2292: LD_INT 1
2294: PLUS
2295: ARRAY
2296: PPUSH
2297: LD_INT 2
2299: PPUSH
2300: CALL_OW 380
// un := CreateHuman ;
2304: LD_ADDR_VAR 0 3
2308: PUSH
2309: CALL_OW 44
2313: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2314: LD_ADDR_VAR 0 2
2318: PUSH
2319: LD_VAR 0 2
2323: PPUSH
2324: LD_INT 1
2326: PPUSH
2327: LD_VAR 0 3
2331: PPUSH
2332: CALL_OW 2
2336: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2337: LD_VAR 0 3
2341: PPUSH
2342: LD_INT 2
2344: PPUSH
2345: LD_INT 0
2347: PPUSH
2348: CALL_OW 49
// end ;
2352: GO 2255
2354: POP
2355: POP
// cornel_units := tmp ;
2356: LD_ADDR_EXP 4
2360: PUSH
2361: LD_VAR 0 2
2365: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2366: LD_EXP 38
2370: PPUSH
2371: LD_INT 191
2373: PPUSH
2374: LD_INT 106
2376: PPUSH
2377: LD_INT 0
2379: PPUSH
2380: CALL_OW 48
// end ;
2384: LD_VAR 0 1
2388: RET
// export function PrepareWesternBase ; var i ; begin
2389: LD_INT 0
2391: PPUSH
2392: PPUSH
// uc_side := 8 ;
2393: LD_ADDR_OWVAR 20
2397: PUSH
2398: LD_INT 8
2400: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2401: LD_ADDR_EXP 41
2405: PUSH
2406: LD_STRING Lynch
2408: PPUSH
2409: LD_INT 0
2411: PPUSH
2412: CALL 434 0 2
2416: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2417: LD_ADDR_EXP 42
2421: PUSH
2422: LD_STRING Walker
2424: PPUSH
2425: LD_INT 0
2427: PPUSH
2428: CALL 434 0 2
2432: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2433: LD_ADDR_EXP 43
2437: PUSH
2438: LD_STRING Turner
2440: PPUSH
2441: LD_INT 0
2443: PPUSH
2444: CALL 434 0 2
2448: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2449: LD_ADDR_EXP 44
2453: PUSH
2454: LD_STRING Jillian
2456: PPUSH
2457: LD_INT 0
2459: PPUSH
2460: CALL 434 0 2
2464: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2465: LD_ADDR_VAR 0 2
2469: PUSH
2470: LD_EXP 41
2474: PUSH
2475: LD_EXP 42
2479: PUSH
2480: LD_EXP 43
2484: PUSH
2485: LD_EXP 44
2489: PUSH
2490: EMPTY
2491: LIST
2492: LIST
2493: LIST
2494: LIST
2495: PUSH
2496: FOR_IN
2497: IFFALSE 2525
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2499: LD_VAR 0 2
2503: PPUSH
2504: LD_INT 3
2506: PPUSH
2507: LD_INT 0
2509: PPUSH
2510: CALL_OW 49
// ComHold ( i ) ;
2514: LD_VAR 0 2
2518: PPUSH
2519: CALL_OW 140
// end ;
2523: GO 2496
2525: POP
2526: POP
// end ;
2527: LD_VAR 0 1
2531: RET
// export function SelectGroup ; var units , selected , i ; begin
2532: LD_INT 0
2534: PPUSH
2535: PPUSH
2536: PPUSH
2537: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2538: LD_ADDR_VAR 0 2
2542: PUSH
2543: LD_EXP 31
2547: PUSH
2548: LD_INT -3
2550: PUSH
2551: EMPTY
2552: LIST
2553: LIST
2554: PUSH
2555: LD_EXP 2
2559: ADD
2560: PUSH
2561: LD_INT -2
2563: PUSH
2564: LD_INT -4
2566: PUSH
2567: LD_EXP 38
2571: PUSH
2572: LD_EXP 39
2576: PUSH
2577: EMPTY
2578: LIST
2579: LIST
2580: LIST
2581: LIST
2582: ADD
2583: PUSH
2584: LD_INT -3
2586: PUSH
2587: EMPTY
2588: LIST
2589: ADD
2590: PUSH
2591: LD_EXP 4
2595: ADD
2596: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2597: LD_ADDR_VAR 0 3
2601: PUSH
2602: LD_EXP 31
2606: PUSH
2607: LD_STRING Select five characters to go with you
2609: PPUSH
2610: LD_INT 4
2612: PPUSH
2613: LD_INT 4
2615: PPUSH
2616: LD_VAR 0 2
2620: PPUSH
2621: EMPTY
2622: PPUSH
2623: CALL_OW 42
2627: ADD
2628: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2629: LD_ADDR_EXP 4
2633: PUSH
2634: LD_EXP 2
2638: PUSH
2639: LD_EXP 4
2643: UNION
2644: PUSH
2645: LD_VAR 0 3
2649: DIFF
2650: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2651: LD_ADDR_VAR 0 4
2655: PUSH
2656: LD_EXP 4
2660: PUSH
2661: LD_EXP 39
2665: ADD
2666: PUSH
2667: FOR_IN
2668: IFFALSE 2699
// if GetSide ( i ) = 1 then
2670: LD_VAR 0 4
2674: PPUSH
2675: CALL_OW 255
2679: PUSH
2680: LD_INT 1
2682: EQUAL
2683: IFFALSE 2697
// SetSide ( i , 4 ) ;
2685: LD_VAR 0 4
2689: PPUSH
2690: LD_INT 4
2692: PPUSH
2693: CALL_OW 235
2697: GO 2667
2699: POP
2700: POP
// for i in selected do
2701: LD_ADDR_VAR 0 4
2705: PUSH
2706: LD_VAR 0 3
2710: PUSH
2711: FOR_IN
2712: IFFALSE 2743
// if GetSide ( i ) = 4 then
2714: LD_VAR 0 4
2718: PPUSH
2719: CALL_OW 255
2723: PUSH
2724: LD_INT 4
2726: EQUAL
2727: IFFALSE 2741
// SetSide ( i , 1 ) ;
2729: LD_VAR 0 4
2733: PPUSH
2734: LD_INT 1
2736: PPUSH
2737: CALL_OW 235
2741: GO 2711
2743: POP
2744: POP
// jmm_units := jmm_units diff cornel_units ;
2745: LD_ADDR_EXP 2
2749: PUSH
2750: LD_EXP 2
2754: PUSH
2755: LD_EXP 4
2759: DIFF
2760: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2761: LD_EXP 32
2765: PPUSH
2766: CALL_OW 255
2770: PUSH
2771: LD_INT 4
2773: EQUAL
2774: IFFALSE 2783
// DeleteCharacters ( Bobby ) ;
2776: LD_STRING Bobby
2778: PPUSH
2779: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2783: LD_EXP 33
2787: PPUSH
2788: CALL_OW 255
2792: PUSH
2793: LD_INT 4
2795: EQUAL
2796: IFFALSE 2805
// DeleteCharacters ( Cyrus ) ;
2798: LD_STRING Cyrus
2800: PPUSH
2801: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2805: LD_EXP 34
2809: PPUSH
2810: CALL_OW 255
2814: PUSH
2815: LD_INT 4
2817: EQUAL
2818: IFFALSE 2827
// DeleteCharacters ( Lisa ) ;
2820: LD_STRING Lisa
2822: PPUSH
2823: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2827: LD_EXP 35
2831: PPUSH
2832: CALL_OW 255
2836: PUSH
2837: LD_INT 4
2839: EQUAL
2840: IFFALSE 2849
// DeleteCharacters ( Khatam ) ;
2842: LD_STRING Khatam
2844: PPUSH
2845: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2849: LD_EXP 36
2853: PPUSH
2854: CALL_OW 255
2858: PUSH
2859: LD_INT 4
2861: EQUAL
2862: IFFALSE 2871
// DeleteCharacters ( Brian ) ;
2864: LD_STRING Brian
2866: PPUSH
2867: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2871: LD_EXP 37
2875: PPUSH
2876: CALL_OW 255
2880: PUSH
2881: LD_INT 4
2883: EQUAL
2884: IFFALSE 2893
// DeleteCharacters ( Jerry ) ;
2886: LD_STRING Jerry
2888: PPUSH
2889: CALL_OW 40
// end ; end_of_file
2893: LD_VAR 0 1
2897: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
2898: LD_INT 0
2900: PPUSH
2901: PPUSH
2902: PPUSH
2903: PPUSH
2904: PPUSH
2905: PPUSH
2906: PPUSH
2907: PPUSH
2908: PPUSH
2909: PPUSH
2910: PPUSH
2911: PPUSH
2912: PPUSH
// ru_alert := false ;
2913: LD_ADDR_EXP 54
2917: PUSH
2918: LD_INT 0
2920: ST_TO_ADDR
// ru_produce_list := [ ] ;
2921: LD_ADDR_EXP 51
2925: PUSH
2926: EMPTY
2927: ST_TO_ADDR
// if Difficulty > 1 then
2928: LD_OWVAR 67
2932: PUSH
2933: LD_INT 1
2935: GREATER
2936: IFFALSE 3024
// begin uc_side := 3 ;
2938: LD_ADDR_OWVAR 20
2942: PUSH
2943: LD_INT 3
2945: ST_TO_ADDR
// uc_nation := 3 ;
2946: LD_ADDR_OWVAR 21
2950: PUSH
2951: LD_INT 3
2953: ST_TO_ADDR
// bc_type := b_breastwork ;
2954: LD_ADDR_OWVAR 42
2958: PUSH
2959: LD_INT 31
2961: ST_TO_ADDR
// bc_level := Difficulty ;
2962: LD_ADDR_OWVAR 43
2966: PUSH
2967: LD_OWVAR 67
2971: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
2972: LD_INT 22
2974: PPUSH
2975: LD_INT 14
2977: PPUSH
2978: LD_INT 0
2980: PPUSH
2981: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
2985: LD_INT 48
2987: PPUSH
2988: LD_INT 46
2990: PPUSH
2991: LD_INT 0
2993: PPUSH
2994: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
2998: LD_INT 86
3000: PPUSH
3001: LD_INT 65
3003: PPUSH
3004: LD_INT 5
3006: PPUSH
3007: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3011: LD_INT 165
3013: PPUSH
3014: LD_INT 73
3016: PPUSH
3017: LD_INT 5
3019: PPUSH
3020: CALL_OW 47
// end ; tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3024: LD_ADDR_VAR 0 7
3028: PUSH
3029: LD_INT 22
3031: PUSH
3032: LD_INT 3
3034: PUSH
3035: EMPTY
3036: LIST
3037: LIST
3038: PUSH
3039: LD_INT 2
3041: PUSH
3042: LD_INT 30
3044: PUSH
3045: LD_INT 31
3047: PUSH
3048: EMPTY
3049: LIST
3050: LIST
3051: PUSH
3052: LD_INT 30
3054: PUSH
3055: LD_INT 32
3057: PUSH
3058: EMPTY
3059: LIST
3060: LIST
3061: PUSH
3062: EMPTY
3063: LIST
3064: LIST
3065: LIST
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: PPUSH
3071: CALL_OW 69
3075: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3076: LD_ADDR_VAR 0 8
3080: PUSH
3081: LD_INT 22
3083: PUSH
3084: LD_INT 3
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 30
3093: PUSH
3094: LD_INT 4
3096: PUSH
3097: EMPTY
3098: LIST
3099: LIST
3100: PUSH
3101: EMPTY
3102: LIST
3103: LIST
3104: PPUSH
3105: CALL_OW 69
3109: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3110: LD_ADDR_VAR 0 10
3114: PUSH
3115: LD_INT 22
3117: PUSH
3118: LD_INT 3
3120: PUSH
3121: EMPTY
3122: LIST
3123: LIST
3124: PUSH
3125: LD_INT 30
3127: PUSH
3128: LD_INT 3
3130: PUSH
3131: EMPTY
3132: LIST
3133: LIST
3134: PUSH
3135: EMPTY
3136: LIST
3137: LIST
3138: PPUSH
3139: CALL_OW 69
3143: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3144: LD_ADDR_VAR 0 9
3148: PUSH
3149: LD_INT 22
3151: PUSH
3152: LD_INT 3
3154: PUSH
3155: EMPTY
3156: LIST
3157: LIST
3158: PUSH
3159: LD_INT 30
3161: PUSH
3162: LD_INT 6
3164: PUSH
3165: EMPTY
3166: LIST
3167: LIST
3168: PUSH
3169: EMPTY
3170: LIST
3171: LIST
3172: PPUSH
3173: CALL_OW 69
3177: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3178: LD_ADDR_VAR 0 2
3182: PUSH
3183: LD_INT 22
3185: PUSH
3186: LD_INT 3
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: PUSH
3193: LD_INT 30
3195: PUSH
3196: LD_INT 1
3198: PUSH
3199: EMPTY
3200: LIST
3201: LIST
3202: PUSH
3203: EMPTY
3204: LIST
3205: LIST
3206: PPUSH
3207: CALL_OW 69
3211: PUSH
3212: FOR_IN
3213: IFFALSE 3257
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3215: LD_VAR 0 2
3219: PPUSH
3220: CALL_OW 274
3224: PPUSH
3225: LD_INT 1
3227: PPUSH
3228: LD_INT 5000
3230: PPUSH
3231: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3235: LD_VAR 0 2
3239: PPUSH
3240: CALL_OW 274
3244: PPUSH
3245: LD_INT 2
3247: PPUSH
3248: LD_INT 3000
3250: PPUSH
3251: CALL_OW 277
// end ;
3255: GO 3212
3257: POP
3258: POP
// uc_side := 3 ;
3259: LD_ADDR_OWVAR 20
3263: PUSH
3264: LD_INT 3
3266: ST_TO_ADDR
// uc_nation := 3 ;
3267: LD_ADDR_OWVAR 21
3271: PUSH
3272: LD_INT 3
3274: ST_TO_ADDR
// skill := [ 2 , 2 , 3 ] [ Difficulty ] ;
3275: LD_ADDR_VAR 0 11
3279: PUSH
3280: LD_INT 2
3282: PUSH
3283: LD_INT 2
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: EMPTY
3290: LIST
3291: LIST
3292: LIST
3293: PUSH
3294: LD_OWVAR 67
3298: ARRAY
3299: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3300: LD_ADDR_EXP 46
3304: PUSH
3305: LD_STRING Pokryshkin
3307: PPUSH
3308: LD_INT 0
3310: PPUSH
3311: CALL 434 0 2
3315: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3316: LD_EXP 46
3320: PPUSH
3321: LD_INT 63
3323: PPUSH
3324: LD_INT 21
3326: PPUSH
3327: LD_INT 0
3329: PPUSH
3330: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3334: LD_EXP 46
3338: PPUSH
3339: CALL_OW 140
// InitHc ;
3343: CALL_OW 19
// for i in fac do
3347: LD_ADDR_VAR 0 2
3351: PUSH
3352: LD_VAR 0 10
3356: PUSH
3357: FOR_IN
3358: IFFALSE 3411
// begin for j = 1 to 6 do
3360: LD_ADDR_VAR 0 3
3364: PUSH
3365: DOUBLE
3366: LD_INT 1
3368: DEC
3369: ST_TO_ADDR
3370: LD_INT 6
3372: PUSH
3373: FOR_TO
3374: IFFALSE 3407
// begin PrepareHuman ( false , 3 , skill ) ;
3376: LD_INT 0
3378: PPUSH
3379: LD_INT 3
3381: PPUSH
3382: LD_VAR 0 11
3386: PPUSH
3387: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3391: CALL_OW 44
3395: PPUSH
3396: LD_VAR 0 2
3400: PPUSH
3401: CALL_OW 52
// end ;
3405: GO 3373
3407: POP
3408: POP
// end ;
3409: GO 3357
3411: POP
3412: POP
// for i in lab do
3413: LD_ADDR_VAR 0 2
3417: PUSH
3418: LD_VAR 0 9
3422: PUSH
3423: FOR_IN
3424: IFFALSE 3457
// begin PrepareHuman ( false , 4 , skill ) ;
3426: LD_INT 0
3428: PPUSH
3429: LD_INT 4
3431: PPUSH
3432: LD_VAR 0 11
3436: PPUSH
3437: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3441: CALL_OW 44
3445: PPUSH
3446: LD_VAR 0 2
3450: PPUSH
3451: CALL_OW 52
// end ;
3455: GO 3423
3457: POP
3458: POP
// for i in tw do
3459: LD_ADDR_VAR 0 2
3463: PUSH
3464: LD_VAR 0 7
3468: PUSH
3469: FOR_IN
3470: IFFALSE 3519
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3472: LD_VAR 0 2
3476: PPUSH
3477: LD_INT 42
3479: PUSH
3480: LD_INT 43
3482: PUSH
3483: EMPTY
3484: LIST
3485: LIST
3486: PUSH
3487: LD_INT 1
3489: PPUSH
3490: LD_INT 2
3492: PPUSH
3493: CALL_OW 12
3497: ARRAY
3498: PPUSH
3499: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3503: LD_VAR 0 11
3507: PPUSH
3508: LD_VAR 0 2
3512: PPUSH
3513: CALL 769 0 2
// end ;
3517: GO 3469
3519: POP
3520: POP
// for i in bar do
3521: LD_ADDR_VAR 0 2
3525: PUSH
3526: LD_VAR 0 8
3530: PUSH
3531: FOR_IN
3532: IFFALSE 3565
// begin PrepareHuman ( false , 1 , skill ) ;
3534: LD_INT 0
3536: PPUSH
3537: LD_INT 1
3539: PPUSH
3540: LD_VAR 0 11
3544: PPUSH
3545: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3549: CALL_OW 44
3553: PPUSH
3554: LD_VAR 0 2
3558: PPUSH
3559: CALL_OW 52
// end ;
3563: GO 3531
3565: POP
3566: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3567: LD_ADDR_VAR 0 13
3571: PUSH
3572: LD_INT 100
3574: PUSH
3575: LD_INT 9
3577: PUSH
3578: EMPTY
3579: LIST
3580: LIST
3581: PUSH
3582: LD_INT 135
3584: PUSH
3585: LD_INT 60
3587: PUSH
3588: EMPTY
3589: LIST
3590: LIST
3591: PUSH
3592: LD_INT 41
3594: PUSH
3595: LD_INT 6
3597: PUSH
3598: EMPTY
3599: LIST
3600: LIST
3601: PUSH
3602: LD_INT 22
3604: PUSH
3605: LD_INT 9
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: PUSH
3612: LD_INT 84
3614: PUSH
3615: LD_INT 14
3617: PUSH
3618: EMPTY
3619: LIST
3620: LIST
3621: PUSH
3622: EMPTY
3623: LIST
3624: LIST
3625: LIST
3626: LIST
3627: LIST
3628: ST_TO_ADDR
// vehicles := [ ] ;
3629: LD_ADDR_VAR 0 12
3633: PUSH
3634: EMPTY
3635: ST_TO_ADDR
// for i in spot_xy do
3636: LD_ADDR_VAR 0 2
3640: PUSH
3641: LD_VAR 0 13
3645: PUSH
3646: FOR_IN
3647: IFFALSE 3805
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3649: LD_ADDR_VAR 0 6
3653: PUSH
3654: LD_INT 3
3656: PPUSH
3657: LD_INT 3
3659: PPUSH
3660: LD_INT 22
3662: PPUSH
3663: LD_INT 1
3665: PPUSH
3666: LD_INT 1
3668: PPUSH
3669: LD_INT 42
3671: PUSH
3672: LD_INT 43
3674: PUSH
3675: LD_INT 44
3677: PUSH
3678: EMPTY
3679: LIST
3680: LIST
3681: LIST
3682: PUSH
3683: LD_INT 1
3685: PPUSH
3686: LD_INT 3
3688: PPUSH
3689: CALL_OW 12
3693: ARRAY
3694: PPUSH
3695: LD_INT 100
3697: PPUSH
3698: CALL 491 0 7
3702: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3703: LD_ADDR_VAR 0 12
3707: PUSH
3708: LD_VAR 0 12
3712: PPUSH
3713: LD_VAR 0 12
3717: PUSH
3718: LD_INT 1
3720: PLUS
3721: PPUSH
3722: LD_VAR 0 6
3726: PPUSH
3727: CALL_OW 2
3731: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3732: LD_VAR 0 6
3736: PPUSH
3737: LD_INT 3
3739: PPUSH
3740: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3744: LD_VAR 0 6
3748: PPUSH
3749: LD_VAR 0 2
3753: PUSH
3754: LD_INT 1
3756: ARRAY
3757: PPUSH
3758: LD_VAR 0 2
3762: PUSH
3763: LD_INT 2
3765: ARRAY
3766: PPUSH
3767: LD_INT 0
3769: PPUSH
3770: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3774: LD_INT 0
3776: PPUSH
3777: LD_INT 3
3779: PPUSH
3780: LD_VAR 0 11
3784: PPUSH
3785: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3789: CALL_OW 44
3793: PPUSH
3794: LD_VAR 0 6
3798: PPUSH
3799: CALL_OW 52
// end ;
3803: GO 3646
3805: POP
3806: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3807: LD_ADDR_VAR 0 2
3811: PUSH
3812: DOUBLE
3813: LD_INT 1
3815: DEC
3816: ST_TO_ADDR
3817: LD_INT 5
3819: PUSH
3820: LD_INT 7
3822: PUSH
3823: LD_INT 8
3825: PUSH
3826: EMPTY
3827: LIST
3828: LIST
3829: LIST
3830: PUSH
3831: LD_OWVAR 67
3835: ARRAY
3836: PUSH
3837: FOR_TO
3838: IFFALSE 3898
// begin PrepareHuman ( false , 1 , skill ) ;
3840: LD_INT 0
3842: PPUSH
3843: LD_INT 1
3845: PPUSH
3846: LD_VAR 0 11
3850: PPUSH
3851: CALL_OW 380
// un := CreateHuman ;
3855: LD_ADDR_VAR 0 5
3859: PUSH
3860: CALL_OW 44
3864: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3865: LD_VAR 0 5
3869: PPUSH
3870: LD_INT 11
3872: PPUSH
3873: LD_INT 0
3875: PPUSH
3876: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3880: LD_ADDR_EXP 49
3884: PUSH
3885: LD_EXP 49
3889: PUSH
3890: LD_VAR 0 5
3894: ADD
3895: ST_TO_ADDR
// end ;
3896: GO 3837
3898: POP
3899: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3900: LD_ADDR_VAR 0 2
3904: PUSH
3905: DOUBLE
3906: LD_INT 1
3908: DEC
3909: ST_TO_ADDR
3910: LD_INT 2
3912: PUSH
3913: LD_INT 3
3915: PUSH
3916: LD_INT 4
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: LIST
3923: PUSH
3924: LD_OWVAR 67
3928: ARRAY
3929: PUSH
3930: FOR_TO
3931: IFFALSE 3991
// begin PrepareHuman ( false , 1 , skill ) ;
3933: LD_INT 0
3935: PPUSH
3936: LD_INT 1
3938: PPUSH
3939: LD_VAR 0 11
3943: PPUSH
3944: CALL_OW 380
// un := CreateHuman ;
3948: LD_ADDR_VAR 0 5
3952: PUSH
3953: CALL_OW 44
3957: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
3958: LD_VAR 0 5
3962: PPUSH
3963: LD_INT 12
3965: PPUSH
3966: LD_INT 0
3968: PPUSH
3969: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
3973: LD_ADDR_EXP 47
3977: PUSH
3978: LD_EXP 47
3982: PUSH
3983: LD_VAR 0 5
3987: ADD
3988: ST_TO_ADDR
// end ;
3989: GO 3930
3991: POP
3992: POP
// for i = 1 to 2 do
3993: LD_ADDR_VAR 0 2
3997: PUSH
3998: DOUBLE
3999: LD_INT 1
4001: DEC
4002: ST_TO_ADDR
4003: LD_INT 2
4005: PUSH
4006: FOR_TO
4007: IFFALSE 4073
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4009: LD_INT 1
4011: PPUSH
4012: LD_INT 1
4014: PPUSH
4015: LD_VAR 0 11
4019: PPUSH
4020: CALL_OW 380
// un := CreateHuman ;
4024: LD_ADDR_VAR 0 5
4028: PUSH
4029: CALL_OW 44
4033: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4034: LD_VAR 0 5
4038: PPUSH
4039: LD_INT 39
4041: PPUSH
4042: LD_INT 12
4044: PPUSH
4045: LD_INT 3
4047: PPUSH
4048: LD_INT 0
4050: PPUSH
4051: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4055: LD_ADDR_EXP 48
4059: PUSH
4060: LD_EXP 48
4064: PUSH
4065: LD_VAR 0 5
4069: ADD
4070: ST_TO_ADDR
// end ;
4071: GO 4006
4073: POP
4074: POP
// for i = 1 to 3 do
4075: LD_ADDR_VAR 0 2
4079: PUSH
4080: DOUBLE
4081: LD_INT 1
4083: DEC
4084: ST_TO_ADDR
4085: LD_INT 3
4087: PUSH
4088: FOR_TO
4089: IFFALSE 4155
// begin PrepareHuman ( false , 1 , skill ) ;
4091: LD_INT 0
4093: PPUSH
4094: LD_INT 1
4096: PPUSH
4097: LD_VAR 0 11
4101: PPUSH
4102: CALL_OW 380
// un := CreateHuman ;
4106: LD_ADDR_VAR 0 5
4110: PUSH
4111: CALL_OW 44
4115: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4116: LD_VAR 0 5
4120: PPUSH
4121: LD_INT 180
4123: PPUSH
4124: LD_INT 11
4126: PPUSH
4127: LD_INT 4
4129: PPUSH
4130: LD_INT 0
4132: PPUSH
4133: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4137: LD_ADDR_EXP 52
4141: PUSH
4142: LD_EXP 52
4146: PUSH
4147: LD_VAR 0 5
4151: ADD
4152: ST_TO_ADDR
// end ;
4153: GO 4088
4155: POP
4156: POP
// ru_vehicles := vehicles ;
4157: LD_ADDR_EXP 50
4161: PUSH
4162: LD_VAR 0 12
4166: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4167: LD_ADDR_EXP 53
4171: PUSH
4172: LD_INT 131
4174: PUSH
4175: LD_INT 121
4177: PUSH
4178: EMPTY
4179: LIST
4180: LIST
4181: PUSH
4182: LD_INT 113
4184: PUSH
4185: LD_INT 90
4187: PUSH
4188: EMPTY
4189: LIST
4190: LIST
4191: PUSH
4192: LD_INT 93
4194: PUSH
4195: LD_INT 62
4197: PUSH
4198: EMPTY
4199: LIST
4200: LIST
4201: PUSH
4202: EMPTY
4203: LIST
4204: LIST
4205: LIST
4206: PUSH
4207: LD_INT 106
4209: PUSH
4210: LD_INT 54
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: PUSH
4217: LD_INT 120
4219: PUSH
4220: LD_INT 80
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: PUSH
4227: LD_INT 143
4229: PUSH
4230: LD_INT 120
4232: PUSH
4233: EMPTY
4234: LIST
4235: LIST
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 154
4244: PUSH
4245: LD_INT 116
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: LD_INT 140
4254: PUSH
4255: LD_INT 93
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: PUSH
4262: LD_INT 130
4264: PUSH
4265: LD_INT 58
4267: PUSH
4268: EMPTY
4269: LIST
4270: LIST
4271: PUSH
4272: EMPTY
4273: LIST
4274: LIST
4275: LIST
4276: PUSH
4277: LD_INT 105
4279: PUSH
4280: LD_INT 106
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PUSH
4287: LD_INT 134
4289: PUSH
4290: LD_INT 98
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: PUSH
4297: LD_INT 159
4299: PUSH
4300: LD_INT 113
4302: PUSH
4303: EMPTY
4304: LIST
4305: LIST
4306: PUSH
4307: EMPTY
4308: LIST
4309: LIST
4310: LIST
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: LIST
4316: LIST
4317: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4318: LD_ADDR_VAR 0 2
4322: PUSH
4323: DOUBLE
4324: LD_INT 1
4326: DEC
4327: ST_TO_ADDR
4328: LD_OWVAR 67
4332: PUSH
4333: LD_INT 1
4335: MINUS
4336: PUSH
4337: FOR_TO
4338: IFFALSE 4371
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4340: LD_ADDR_EXP 51
4344: PUSH
4345: LD_EXP 51
4349: PUSH
4350: LD_INT 22
4352: PUSH
4353: LD_INT 1
4355: PUSH
4356: LD_INT 1
4358: PUSH
4359: LD_INT 43
4361: PUSH
4362: EMPTY
4363: LIST
4364: LIST
4365: LIST
4366: LIST
4367: ADD
4368: ST_TO_ADDR
4369: GO 4337
4371: POP
4372: POP
// end ;
4373: LD_VAR 0 1
4377: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4378: LD_INT 22
4380: PUSH
4381: LD_INT 3
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PUSH
4388: LD_INT 21
4390: PUSH
4391: LD_INT 2
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PPUSH
4402: CALL_OW 69
4406: IFFALSE 4500
4408: GO 4410
4410: DISABLE
4411: LD_INT 0
4413: PPUSH
4414: PPUSH
// begin enable ;
4415: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4416: LD_ADDR_VAR 0 2
4420: PUSH
4421: LD_INT 22
4423: PUSH
4424: LD_INT 3
4426: PUSH
4427: EMPTY
4428: LIST
4429: LIST
4430: PUSH
4431: LD_INT 21
4433: PUSH
4434: LD_INT 2
4436: PUSH
4437: EMPTY
4438: LIST
4439: LIST
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: PPUSH
4445: CALL_OW 69
4449: ST_TO_ADDR
// if filter then
4450: LD_VAR 0 2
4454: IFFALSE 4500
// for i in filter do
4456: LD_ADDR_VAR 0 1
4460: PUSH
4461: LD_VAR 0 2
4465: PUSH
4466: FOR_IN
4467: IFFALSE 4498
// if GetFuel ( i ) < 20 then
4469: LD_VAR 0 1
4473: PPUSH
4474: CALL_OW 261
4478: PUSH
4479: LD_INT 20
4481: LESS
4482: IFFALSE 4496
// SetFuel ( i , 20 ) ;
4484: LD_VAR 0 1
4488: PPUSH
4489: LD_INT 20
4491: PPUSH
4492: CALL_OW 240
4496: GO 4466
4498: POP
4499: POP
// end ;
4500: PPOPN 2
4502: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4503: LD_EXP 51
4507: IFFALSE 4726
4509: GO 4511
4511: DISABLE
4512: LD_INT 0
4514: PPUSH
4515: PPUSH
4516: PPUSH
// begin enable ;
4517: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4518: LD_ADDR_VAR 0 2
4522: PUSH
4523: LD_INT 22
4525: PUSH
4526: LD_INT 3
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: PUSH
4533: LD_INT 30
4535: PUSH
4536: LD_INT 3
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: PUSH
4543: EMPTY
4544: LIST
4545: LIST
4546: PPUSH
4547: CALL_OW 69
4551: ST_TO_ADDR
// can_produce := [ ] ;
4552: LD_ADDR_VAR 0 3
4556: PUSH
4557: EMPTY
4558: ST_TO_ADDR
// if not fac then
4559: LD_VAR 0 2
4563: NOT
4564: IFFALSE 4569
// begin disable ;
4566: DISABLE
// exit ;
4567: GO 4726
// end ; for i in fac do
4569: LD_ADDR_VAR 0 1
4573: PUSH
4574: LD_VAR 0 2
4578: PUSH
4579: FOR_IN
4580: IFFALSE 4618
// if UnitsInside ( i ) then
4582: LD_VAR 0 1
4586: PPUSH
4587: CALL_OW 313
4591: IFFALSE 4616
// can_produce := Insert ( can_produce , 1 , i ) ;
4593: LD_ADDR_VAR 0 3
4597: PUSH
4598: LD_VAR 0 3
4602: PPUSH
4603: LD_INT 1
4605: PPUSH
4606: LD_VAR 0 1
4610: PPUSH
4611: CALL_OW 2
4615: ST_TO_ADDR
4616: GO 4579
4618: POP
4619: POP
// if not can_produce then
4620: LD_VAR 0 3
4624: NOT
4625: IFFALSE 4629
// exit ;
4627: GO 4726
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4629: LD_VAR 0 3
4633: PUSH
4634: LD_INT 1
4636: PPUSH
4637: LD_VAR 0 3
4641: PPUSH
4642: CALL_OW 12
4646: ARRAY
4647: PPUSH
4648: LD_EXP 51
4652: PUSH
4653: LD_INT 1
4655: ARRAY
4656: PPUSH
4657: LD_EXP 51
4661: PUSH
4662: LD_INT 2
4664: ARRAY
4665: PPUSH
4666: LD_EXP 51
4670: PUSH
4671: LD_INT 3
4673: ARRAY
4674: PPUSH
4675: LD_EXP 51
4679: PUSH
4680: LD_INT 4
4682: ARRAY
4683: PPUSH
4684: CALL_OW 125
// for i = 1 to 4 do
4688: LD_ADDR_VAR 0 1
4692: PUSH
4693: DOUBLE
4694: LD_INT 1
4696: DEC
4697: ST_TO_ADDR
4698: LD_INT 4
4700: PUSH
4701: FOR_TO
4702: IFFALSE 4724
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4704: LD_ADDR_EXP 51
4708: PUSH
4709: LD_EXP 51
4713: PPUSH
4714: LD_INT 1
4716: PPUSH
4717: CALL_OW 3
4721: ST_TO_ADDR
4722: GO 4701
4724: POP
4725: POP
// end ;
4726: PPOPN 3
4728: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4729: LD_INT 0
4731: PPUSH
4732: PPUSH
4733: PPUSH
// for i = 1 to 6 do
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: DOUBLE
4740: LD_INT 1
4742: DEC
4743: ST_TO_ADDR
4744: LD_INT 6
4746: PUSH
4747: FOR_TO
4748: IFFALSE 4897
// begin PrepareHuman ( false , 3 , 3 ) ;
4750: LD_INT 0
4752: PPUSH
4753: LD_INT 3
4755: PPUSH
4756: LD_INT 3
4758: PPUSH
4759: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4763: LD_ADDR_VAR 0 3
4767: PUSH
4768: LD_INT 3
4770: PPUSH
4771: LD_INT 3
4773: PPUSH
4774: LD_INT 22
4776: PPUSH
4777: LD_INT 1
4779: PPUSH
4780: LD_INT 1
4782: PPUSH
4783: LD_INT 43
4785: PUSH
4786: LD_INT 42
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: LD_INT 1
4795: PPUSH
4796: LD_INT 2
4798: PPUSH
4799: CALL_OW 12
4803: ARRAY
4804: PPUSH
4805: LD_INT 70
4807: PPUSH
4808: CALL 491 0 7
4812: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4813: LD_VAR 0 3
4817: PPUSH
4818: LD_INT 4
4820: PPUSH
4821: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4825: LD_VAR 0 3
4829: PPUSH
4830: LD_INT 229
4832: PPUSH
4833: LD_INT 44
4835: PPUSH
4836: LD_INT 0
4838: PPUSH
4839: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4843: CALL_OW 44
4847: PPUSH
4848: LD_VAR 0 3
4852: PPUSH
4853: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4857: LD_ADDR_EXP 50
4861: PUSH
4862: LD_EXP 50
4866: PUSH
4867: LD_VAR 0 3
4871: ADD
4872: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
4873: LD_VAR 0 3
4877: PPUSH
4878: LD_INT 191
4880: PPUSH
4881: LD_INT 32
4883: PPUSH
4884: CALL_OW 111
// Wait ( 0 0$02 ) ;
4888: LD_INT 70
4890: PPUSH
4891: CALL_OW 67
// end ;
4895: GO 4747
4897: POP
4898: POP
// end ; end_of_file
4899: LD_VAR 0 1
4903: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
4904: LD_INT 0
4906: PPUSH
4907: PPUSH
4908: PPUSH
4909: PPUSH
4910: PPUSH
4911: PPUSH
4912: PPUSH
// InGameOn ;
4913: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
4917: LD_EXP 31
4921: PPUSH
4922: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
4926: LD_EXP 31
4930: PPUSH
4931: LD_EXP 38
4935: PPUSH
4936: CALL_OW 119
// if Bierezov then
4940: LD_EXP 39
4944: IFFALSE 4960
// ComTurnUnit ( Bierezov , Cornel ) ;
4946: LD_EXP 39
4950: PPUSH
4951: LD_EXP 38
4955: PPUSH
4956: CALL_OW 119
// for i in jmm_units do
4960: LD_ADDR_VAR 0 2
4964: PUSH
4965: LD_EXP 2
4969: PUSH
4970: FOR_IN
4971: IFFALSE 4989
// ComTurnUnit ( i , Cornel ) ;
4973: LD_VAR 0 2
4977: PPUSH
4978: LD_EXP 38
4982: PPUSH
4983: CALL_OW 119
4987: GO 4970
4989: POP
4990: POP
// units := cornel_units union Cornel ;
4991: LD_ADDR_VAR 0 3
4995: PUSH
4996: LD_EXP 4
5000: PUSH
5001: LD_EXP 38
5005: UNION
5006: ST_TO_ADDR
// repeat wait ( 1 ) ;
5007: LD_INT 1
5009: PPUSH
5010: CALL_OW 67
// for i in units do
5014: LD_ADDR_VAR 0 2
5018: PUSH
5019: LD_VAR 0 3
5023: PUSH
5024: FOR_IN
5025: IFFALSE 5058
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5027: LD_VAR 0 2
5031: PPUSH
5032: LD_EXP 31
5036: PPUSH
5037: CALL_OW 250
5041: PPUSH
5042: LD_EXP 31
5046: PPUSH
5047: CALL_OW 251
5051: PPUSH
5052: CALL_OW 111
5056: GO 5024
5058: POP
5059: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5060: LD_VAR 0 3
5064: PPUSH
5065: LD_INT 92
5067: PUSH
5068: LD_EXP 31
5072: PPUSH
5073: CALL_OW 250
5077: PUSH
5078: LD_EXP 31
5082: PPUSH
5083: CALL_OW 251
5087: PUSH
5088: LD_INT 10
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: LIST
5095: LIST
5096: PPUSH
5097: CALL_OW 72
5101: PUSH
5102: LD_VAR 0 3
5106: EQUAL
5107: IFFALSE 5007
// for i in units do
5109: LD_ADDR_VAR 0 2
5113: PUSH
5114: LD_VAR 0 3
5118: PUSH
5119: FOR_IN
5120: IFFALSE 5138
// ComTurnUnit ( i , JMM ) ;
5122: LD_VAR 0 2
5126: PPUSH
5127: LD_EXP 31
5131: PPUSH
5132: CALL_OW 119
5136: GO 5119
5138: POP
5139: POP
// ComTurnUnit ( Cornel , JMM ) ;
5140: LD_EXP 38
5144: PPUSH
5145: LD_EXP 31
5149: PPUSH
5150: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5154: LD_EXP 31
5158: PPUSH
5159: LD_STRING D1-JMM-1
5161: PPUSH
5162: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5166: LD_EXP 38
5170: PPUSH
5171: LD_STRING D1-Corn-1
5173: PPUSH
5174: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5178: LD_EXP 31
5182: PPUSH
5183: LD_EXP 38
5187: PPUSH
5188: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5192: LD_EXP 38
5196: PPUSH
5197: LD_EXP 31
5201: PPUSH
5202: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5206: LD_INT 35
5208: PPUSH
5209: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5213: LD_EXP 31
5217: PPUSH
5218: LD_EXP 38
5222: PPUSH
5223: CALL_OW 296
5227: PUSH
5228: LD_INT 6
5230: LESS
5231: IFFALSE 5206
// ChangeSideFog ( 4 , 1 ) ;
5233: LD_INT 4
5235: PPUSH
5236: LD_INT 1
5238: PPUSH
5239: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5243: LD_EXP 31
5247: PPUSH
5248: LD_EXP 38
5252: PPUSH
5253: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5257: LD_EXP 38
5261: PPUSH
5262: LD_EXP 31
5266: PPUSH
5267: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5271: LD_EXP 31
5275: PPUSH
5276: LD_STRING D1-JMM-2
5278: PPUSH
5279: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5283: LD_EXP 31
5287: PPUSH
5288: LD_STRING D1-JMM-2a
5290: PPUSH
5291: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5295: LD_EXP 38
5299: PPUSH
5300: LD_STRING D1-Corn-2
5302: PPUSH
5303: CALL_OW 88
// if bierezov_exist or debug then
5307: LD_EXP 5
5311: PUSH
5312: LD_EXP 1
5316: OR
5317: IFFALSE 5558
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5319: LD_EXP 38
5323: PPUSH
5324: LD_EXP 39
5328: PPUSH
5329: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5333: LD_INT 10
5335: PPUSH
5336: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5340: LD_EXP 38
5344: PPUSH
5345: LD_STRING D1a-Corn-1
5347: PPUSH
5348: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5352: LD_EXP 31
5356: PPUSH
5357: LD_EXP 39
5361: PPUSH
5362: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5366: LD_EXP 39
5370: PPUSH
5371: LD_EXP 31
5375: PPUSH
5376: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5380: LD_EXP 31
5384: PPUSH
5385: LD_STRING D1a-JMM-1
5387: PPUSH
5388: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5392: LD_EXP 31
5396: PPUSH
5397: LD_EXP 38
5401: PPUSH
5402: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5406: LD_EXP 38
5410: PPUSH
5411: LD_EXP 31
5415: PPUSH
5416: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5420: LD_EXP 38
5424: PPUSH
5425: LD_STRING D1a-Corn-2
5427: PPUSH
5428: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5432: LD_EXP 31
5436: PPUSH
5437: LD_STRING D1a-JMM-2
5439: PPUSH
5440: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5444: LD_EXP 38
5448: PPUSH
5449: LD_STRING D1a-Corn-3
5451: PPUSH
5452: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5456: LD_EXP 31
5460: PPUSH
5461: LD_STRING D1a-JMM-3
5463: PPUSH
5464: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5468: LD_EXP 38
5472: PPUSH
5473: LD_STRING D1a-Corn-4
5475: PPUSH
5476: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5480: LD_EXP 31
5484: PPUSH
5485: LD_STRING D1a-JMM-4
5487: PPUSH
5488: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5492: LD_EXP 38
5496: PPUSH
5497: LD_STRING D1a-Corn-5
5499: PPUSH
5500: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5504: LD_EXP 39
5508: PPUSH
5509: LD_EXP 38
5513: PPUSH
5514: CALL_OW 250
5518: PPUSH
5519: LD_EXP 38
5523: PPUSH
5524: CALL_OW 251
5528: PUSH
5529: LD_INT 2
5531: MINUS
5532: PPUSH
5533: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5537: LD_EXP 39
5541: PPUSH
5542: LD_EXP 38
5546: PPUSH
5547: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5551: LD_INT 10
5553: PPUSH
5554: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5558: LD_EXP 31
5562: PPUSH
5563: LD_STRING D1b-JMM-1
5565: PPUSH
5566: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5570: LD_EXP 38
5574: PPUSH
5575: LD_STRING D1b-Corn-1
5577: PPUSH
5578: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5582: LD_EXP 31
5586: PPUSH
5587: LD_STRING D1b-JMM-2
5589: PPUSH
5590: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5594: LD_EXP 38
5598: PPUSH
5599: LD_STRING D1b-Corn-2
5601: PPUSH
5602: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5606: LD_EXP 31
5610: PPUSH
5611: LD_STRING D1b-JMM-3
5613: PPUSH
5614: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5618: LD_INT 10
5620: PPUSH
5621: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5625: LD_EXP 40
5629: PPUSH
5630: LD_STRING D1b-Pow-3
5632: PPUSH
5633: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5637: LD_EXP 31
5641: PPUSH
5642: LD_STRING D1b-JMM-4
5644: PPUSH
5645: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5649: LD_EXP 38
5653: PPUSH
5654: LD_STRING D1b-Corn-4
5656: PPUSH
5657: CALL_OW 88
// if Khatam then
5661: LD_EXP 35
5665: IFFALSE 5681
// Say ( Khatam , D1b-Khat-4 ) else
5667: LD_EXP 35
5671: PPUSH
5672: LD_STRING D1b-Khat-4
5674: PPUSH
5675: CALL_OW 88
5679: GO 5717
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
5681: LD_EXP 4
5685: PPUSH
5686: LD_INT 26
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: EMPTY
5693: LIST
5694: LIST
5695: PPUSH
5696: CALL_OW 72
5700: PUSH
5701: LD_EXP 38
5705: PUSH
5706: EMPTY
5707: LIST
5708: DIFF
5709: PPUSH
5710: LD_STRING D1b-Sol1-4
5712: PPUSH
5713: CALL 579 0 2
// if Cyrus then
5717: LD_EXP 33
5721: IFFALSE 5735
// Say ( Cyrus , D1b-Cyrus-4 ) ;
5723: LD_EXP 33
5727: PPUSH
5728: LD_STRING D1b-Cyrus-4
5730: PPUSH
5731: CALL_OW 88
// if Lisa then
5735: LD_EXP 34
5739: IFFALSE 5797
// begin Say ( Lisa , D1b-Lisa-4 ) ;
5741: LD_EXP 34
5745: PPUSH
5746: LD_STRING D1b-Lisa-4
5748: PPUSH
5749: CALL_OW 88
// if Cyrus then
5753: LD_EXP 33
5757: IFFALSE 5797
// begin if not IsInUnit ( Cyrus ) then
5759: LD_EXP 33
5763: PPUSH
5764: CALL_OW 310
5768: NOT
5769: IFFALSE 5785
// ComTurnUnit ( Cyrus , Lisa ) ;
5771: LD_EXP 33
5775: PPUSH
5776: LD_EXP 34
5780: PPUSH
5781: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
5785: LD_EXP 33
5789: PPUSH
5790: LD_STRING D1b-Cyrus-5
5792: PPUSH
5793: CALL_OW 88
// end ; end ; SelectGroup ;
5797: CALL 2532 0 0
// Say ( JMM , D1d-JMM-1 ) ;
5801: LD_EXP 31
5805: PPUSH
5806: LD_STRING D1d-JMM-1
5808: PPUSH
5809: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
5813: LD_EXP 38
5817: PPUSH
5818: LD_STRING D1d-Corn-1
5820: PPUSH
5821: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
5825: LD_ADDR_VAR 0 2
5829: PUSH
5830: LD_EXP 2
5834: PUSH
5835: LD_EXP 4
5839: ADD
5840: PUSH
5841: LD_EXP 31
5845: ADD
5846: PUSH
5847: FOR_IN
5848: IFFALSE 5861
// ComHold ( i ) ;
5850: LD_VAR 0 2
5854: PPUSH
5855: CALL_OW 140
5859: GO 5847
5861: POP
5862: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
5863: LD_ADDR_VAR 0 4
5867: PUSH
5868: LD_INT 22
5870: PUSH
5871: LD_INT 1
5873: PUSH
5874: EMPTY
5875: LIST
5876: LIST
5877: PUSH
5878: LD_INT 21
5880: PUSH
5881: LD_INT 2
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: PUSH
5888: EMPTY
5889: LIST
5890: LIST
5891: PPUSH
5892: CALL_OW 69
5896: ST_TO_ADDR
// if vehicles then
5897: LD_VAR 0 4
5901: IFFALSE 6239
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
5903: LD_EXP 4
5907: PPUSH
5908: LD_INT 55
5910: PUSH
5911: EMPTY
5912: LIST
5913: PPUSH
5914: CALL_OW 72
5918: IFFALSE 5957
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
5920: LD_ADDR_VAR 0 2
5924: PUSH
5925: LD_EXP 4
5929: PPUSH
5930: LD_INT 55
5932: PUSH
5933: EMPTY
5934: LIST
5935: PPUSH
5936: CALL_OW 72
5940: PUSH
5941: FOR_IN
5942: IFFALSE 5955
// ComExitVehicle ( i ) ;
5944: LD_VAR 0 2
5948: PPUSH
5949: CALL_OW 121
5953: GO 5941
5955: POP
5956: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
5957: LD_ADDR_VAR 0 5
5961: PUSH
5962: LD_VAR 0 4
5966: PPUSH
5967: LD_INT 34
5969: PUSH
5970: LD_INT 51
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: PPUSH
5977: CALL_OW 72
5981: ST_TO_ADDR
// if cargos then
5982: LD_VAR 0 5
5986: IFFALSE 6169
// begin vehicles := cargos ;
5988: LD_ADDR_VAR 0 4
5992: PUSH
5993: LD_VAR 0 5
5997: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
5998: LD_ADDR_VAR 0 6
6002: PUSH
6003: LD_STRING 02_resources_4
6005: PPUSH
6006: LD_INT 0
6008: PPUSH
6009: CALL_OW 30
6013: ST_TO_ADDR
// if debug and not resources then
6014: LD_EXP 1
6018: PUSH
6019: LD_VAR 0 6
6023: NOT
6024: AND
6025: IFFALSE 6035
// resources := 160 ;
6027: LD_ADDR_VAR 0 6
6031: PUSH
6032: LD_INT 160
6034: ST_TO_ADDR
// if resources mod 10 then
6035: LD_VAR 0 6
6039: PUSH
6040: LD_INT 10
6042: MOD
6043: IFFALSE 6065
// resources := resources - resources mod 10 ;
6045: LD_ADDR_VAR 0 6
6049: PUSH
6050: LD_VAR 0 6
6054: PUSH
6055: LD_VAR 0 6
6059: PUSH
6060: LD_INT 10
6062: MOD
6063: MINUS
6064: ST_TO_ADDR
// if resources then
6065: LD_VAR 0 6
6069: IFFALSE 6169
// for i in cargos do
6071: LD_ADDR_VAR 0 2
6075: PUSH
6076: LD_VAR 0 5
6080: PUSH
6081: FOR_IN
6082: IFFALSE 6167
// begin if resources < 100 then
6084: LD_VAR 0 6
6088: PUSH
6089: LD_INT 100
6091: LESS
6092: IFFALSE 6114
// begin cargo := resources ;
6094: LD_ADDR_VAR 0 7
6098: PUSH
6099: LD_VAR 0 6
6103: ST_TO_ADDR
// resources := 0 ;
6104: LD_ADDR_VAR 0 6
6108: PUSH
6109: LD_INT 0
6111: ST_TO_ADDR
// end else
6112: GO 6136
// begin cargo := 100 ;
6114: LD_ADDR_VAR 0 7
6118: PUSH
6119: LD_INT 100
6121: ST_TO_ADDR
// resources := resources - 100 ;
6122: LD_ADDR_VAR 0 6
6126: PUSH
6127: LD_VAR 0 6
6131: PUSH
6132: LD_INT 100
6134: MINUS
6135: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6136: LD_VAR 0 2
6140: PPUSH
6141: LD_INT 1
6143: PPUSH
6144: LD_VAR 0 7
6148: PPUSH
6149: CALL_OW 290
// if resources = 0 then
6153: LD_VAR 0 6
6157: PUSH
6158: LD_INT 0
6160: EQUAL
6161: IFFALSE 6165
// break ;
6163: GO 6167
// end ;
6165: GO 6081
6167: POP
6168: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6169: LD_VAR 0 4
6173: PUSH
6174: LD_INT 1
6176: ARRAY
6177: PPUSH
6178: CALL_OW 311
6182: PPUSH
6183: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6187: LD_VAR 0 4
6191: PUSH
6192: LD_INT 1
6194: ARRAY
6195: PPUSH
6196: LD_INT 4
6198: PPUSH
6199: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6203: LD_EXP 38
6207: PPUSH
6208: LD_VAR 0 4
6212: PUSH
6213: LD_INT 1
6215: ARRAY
6216: PPUSH
6217: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6221: LD_INT 35
6223: PPUSH
6224: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6228: LD_EXP 38
6232: PPUSH
6233: CALL_OW 310
6237: IFFALSE 6221
// end ; InGameOff ;
6239: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6243: LD_STRING M1
6245: PPUSH
6246: CALL_OW 337
// SaveForQuickRestart ;
6250: CALL_OW 22
// cornel_active := true ;
6254: LD_ADDR_EXP 6
6258: PUSH
6259: LD_INT 1
6261: ST_TO_ADDR
// end ;
6262: LD_VAR 0 1
6266: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
6267: LD_EXP 31
6271: PPUSH
6272: LD_EXP 41
6276: PPUSH
6277: CALL_OW 296
6281: PUSH
6282: LD_INT 10
6284: LESS
6285: IFFALSE 7441
6287: GO 6289
6289: DISABLE
6290: LD_INT 0
6292: PPUSH
6293: PPUSH
6294: PPUSH
6295: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6296: LD_ADDR_VAR 0 2
6300: PUSH
6301: LD_INT 89
6303: PUSH
6304: LD_INT 34
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: PUSH
6311: LD_INT 138
6313: PUSH
6314: LD_INT 63
6316: PUSH
6317: EMPTY
6318: LIST
6319: LIST
6320: PUSH
6321: LD_INT 196
6323: PUSH
6324: LD_INT 84
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: PUSH
6331: LD_INT 135
6333: PUSH
6334: LD_INT 52
6336: PUSH
6337: EMPTY
6338: LIST
6339: LIST
6340: PUSH
6341: LD_INT 103
6343: PUSH
6344: LD_INT 39
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: PUSH
6351: LD_INT 58
6353: PUSH
6354: LD_INT 30
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: PUSH
6361: LD_INT 38
6363: PUSH
6364: LD_INT 51
6366: PUSH
6367: EMPTY
6368: LIST
6369: LIST
6370: PUSH
6371: EMPTY
6372: LIST
6373: LIST
6374: LIST
6375: LIST
6376: LIST
6377: LIST
6378: LIST
6379: ST_TO_ADDR
// InGameOn ;
6380: CALL_OW 8
// if jmm_units then
6384: LD_EXP 2
6388: IFFALSE 6452
// for i in jmm_units do
6390: LD_ADDR_VAR 0 1
6394: PUSH
6395: LD_EXP 2
6399: PUSH
6400: FOR_IN
6401: IFFALSE 6450
// begin if GetDistUnits ( i , JMM ) < 10 then
6403: LD_VAR 0 1
6407: PPUSH
6408: LD_EXP 31
6412: PPUSH
6413: CALL_OW 296
6417: PUSH
6418: LD_INT 10
6420: LESS
6421: IFFALSE 6439
// ComTurnUnit ( i , JMM ) else
6423: LD_VAR 0 1
6427: PPUSH
6428: LD_EXP 31
6432: PPUSH
6433: CALL_OW 119
6437: GO 6448
// ComHold ( i ) ;
6439: LD_VAR 0 1
6443: PPUSH
6444: CALL_OW 140
// end ;
6448: GO 6400
6450: POP
6451: POP
// if IsInUnit ( JMM ) then
6452: LD_EXP 31
6456: PPUSH
6457: CALL_OW 310
6461: IFFALSE 6486
// begin ComExitVehicle ( JMM ) ;
6463: LD_EXP 31
6467: PPUSH
6468: CALL_OW 121
// AddComMoveUnit ( JMM , Lynch ) ;
6472: LD_EXP 31
6476: PPUSH
6477: LD_EXP 41
6481: PPUSH
6482: CALL_OW 172
// end ; Wait ( 10 ) ;
6486: LD_INT 10
6488: PPUSH
6489: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6493: LD_EXP 31
6497: PPUSH
6498: LD_EXP 41
6502: PPUSH
6503: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6507: LD_INT 35
6509: PPUSH
6510: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6514: LD_EXP 31
6518: PPUSH
6519: LD_EXP 41
6523: PPUSH
6524: CALL_OW 296
6528: PUSH
6529: LD_INT 6
6531: LESS
6532: IFFALSE 6507
// ComTurnUnit ( JMM , Lynch ) ;
6534: LD_EXP 31
6538: PPUSH
6539: LD_EXP 41
6543: PPUSH
6544: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6548: LD_ADDR_VAR 0 1
6552: PUSH
6553: LD_EXP 41
6557: PUSH
6558: LD_EXP 42
6562: PUSH
6563: LD_EXP 43
6567: PUSH
6568: LD_EXP 44
6572: PUSH
6573: EMPTY
6574: LIST
6575: LIST
6576: LIST
6577: LIST
6578: PUSH
6579: FOR_IN
6580: IFFALSE 6598
// ComTurnUnit ( i , JMM ) ;
6582: LD_VAR 0 1
6586: PPUSH
6587: LD_EXP 31
6591: PPUSH
6592: CALL_OW 119
6596: GO 6579
6598: POP
6599: POP
// Wait ( 0 0$0.3 ) ;
6600: LD_INT 10
6602: PPUSH
6603: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6607: LD_EXP 31
6611: PPUSH
6612: LD_STRING D2-JMM-1
6614: PPUSH
6615: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6619: LD_EXP 41
6623: PPUSH
6624: LD_STRING D2-Sol1-1
6626: PPUSH
6627: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6631: LD_EXP 31
6635: PPUSH
6636: LD_STRING D2-JMM-2
6638: PPUSH
6639: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6643: LD_EXP 41
6647: PPUSH
6648: LD_STRING D2-Sol1-2
6650: PPUSH
6651: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6655: LD_EXP 31
6659: PPUSH
6660: LD_STRING D2-JMM-3
6662: PPUSH
6663: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
6667: LD_EXP 41
6671: PPUSH
6672: LD_STRING D2-Sol1-3
6674: PPUSH
6675: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6679: LD_ADDR_VAR 0 1
6683: PUSH
6684: LD_INT 22
6686: PUSH
6687: LD_INT 8
6689: PUSH
6690: EMPTY
6691: LIST
6692: LIST
6693: PPUSH
6694: CALL_OW 69
6698: PUSH
6699: FOR_IN
6700: IFFALSE 6716
// SetSide ( i , 1 ) ;
6702: LD_VAR 0 1
6706: PPUSH
6707: LD_INT 1
6709: PPUSH
6710: CALL_OW 235
6714: GO 6699
6716: POP
6717: POP
// Say ( JMM , D2-JMM-4 ) ;
6718: LD_EXP 31
6722: PPUSH
6723: LD_STRING D2-JMM-4
6725: PPUSH
6726: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
6730: LD_INT 1
6732: PPUSH
6733: LD_INT 5
6735: PPUSH
6736: CALL_OW 332
// for i = 1 to points do
6740: LD_ADDR_VAR 0 1
6744: PUSH
6745: DOUBLE
6746: LD_INT 1
6748: DEC
6749: ST_TO_ADDR
6750: LD_VAR 0 2
6754: PUSH
6755: FOR_TO
6756: IFFALSE 6931
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6758: LD_VAR 0 2
6762: PUSH
6763: LD_VAR 0 1
6767: ARRAY
6768: PUSH
6769: LD_INT 1
6771: ARRAY
6772: PPUSH
6773: LD_VAR 0 2
6777: PUSH
6778: LD_VAR 0 1
6782: ARRAY
6783: PUSH
6784: LD_INT 2
6786: ARRAY
6787: PPUSH
6788: CALL_OW 84
// if i = 1 then
6792: LD_VAR 0 1
6796: PUSH
6797: LD_INT 1
6799: EQUAL
6800: IFFALSE 6814
// Say ( Lynch , D2-Sol1-4 ) ;
6802: LD_EXP 41
6806: PPUSH
6807: LD_STRING D2-Sol1-4
6809: PPUSH
6810: CALL_OW 88
// if i = 2 then
6814: LD_VAR 0 1
6818: PUSH
6819: LD_INT 2
6821: EQUAL
6822: IFFALSE 6836
// Say ( JMM , D2-JMM-5 ) ;
6824: LD_EXP 31
6828: PPUSH
6829: LD_STRING D2-JMM-5
6831: PPUSH
6832: CALL_OW 88
// if i = 4 then
6836: LD_VAR 0 1
6840: PUSH
6841: LD_INT 4
6843: EQUAL
6844: IFFALSE 6868
// begin RevealFogArea ( 1 , troopsArea ) ;
6846: LD_INT 1
6848: PPUSH
6849: LD_INT 6
6851: PPUSH
6852: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
6856: LD_EXP 41
6860: PPUSH
6861: LD_STRING D2-Sol1-5
6863: PPUSH
6864: CALL_OW 88
// end ; if i = 5 then
6868: LD_VAR 0 1
6872: PUSH
6873: LD_INT 5
6875: EQUAL
6876: IFFALSE 6890
// Say ( JMM , D2-JMM-6 ) ;
6878: LD_EXP 31
6882: PPUSH
6883: LD_STRING D2-JMM-6
6885: PPUSH
6886: CALL_OW 88
// if i = 7 then
6890: LD_VAR 0 1
6894: PUSH
6895: LD_INT 7
6897: EQUAL
6898: IFFALSE 6922
// begin RevealFogArea ( 1 , forestArea ) ;
6900: LD_INT 1
6902: PPUSH
6903: LD_INT 7
6905: PPUSH
6906: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
6910: LD_EXP 41
6914: PPUSH
6915: LD_STRING D2-Sol1-6
6917: PPUSH
6918: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
6922: LD_INT 46
6924: PPUSH
6925: CALL_OW 67
// end ;
6929: GO 6755
6931: POP
6932: POP
// CenterNowOnUnits ( JMM ) ;
6933: LD_EXP 31
6937: PPUSH
6938: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
6942: LD_EXP 31
6946: PPUSH
6947: LD_STRING D2-JMM-7
6949: PPUSH
6950: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
6954: LD_EXP 41
6958: PPUSH
6959: LD_STRING D2-Sol1-7
6961: PPUSH
6962: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
6966: LD_EXP 31
6970: PPUSH
6971: LD_STRING D2-JMM-8
6973: PPUSH
6974: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
6978: LD_ADDR_VAR 0 4
6982: PUSH
6983: LD_INT 22
6985: PUSH
6986: LD_INT 1
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PUSH
6993: LD_INT 30
6995: PUSH
6996: LD_INT 31
6998: PUSH
6999: EMPTY
7000: LIST
7001: LIST
7002: PUSH
7003: EMPTY
7004: LIST
7005: LIST
7006: PPUSH
7007: CALL_OW 69
7011: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
7012: LD_EXP 41
7016: PPUSH
7017: LD_VAR 0 4
7021: PUSH
7022: LD_INT 1
7024: ARRAY
7025: PPUSH
7026: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7030: LD_ADDR_VAR 0 3
7034: PUSH
7035: LD_EXP 2
7039: PPUSH
7040: LD_INT 25
7042: PUSH
7043: LD_INT 1
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: PPUSH
7050: CALL_OW 72
7054: PPUSH
7055: LD_EXP 31
7059: PPUSH
7060: CALL_OW 74
7064: ST_TO_ADDR
// if sol then
7065: LD_VAR 0 3
7069: IFFALSE 7109
// if GetDistUnits ( JMM , sol ) < 10 then
7071: LD_EXP 31
7075: PPUSH
7076: LD_VAR 0 3
7080: PPUSH
7081: CALL_OW 296
7085: PUSH
7086: LD_INT 10
7088: LESS
7089: IFFALSE 7109
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7091: LD_VAR 0 3
7095: PPUSH
7096: LD_VAR 0 4
7100: PUSH
7101: LD_INT 2
7103: ARRAY
7104: PPUSH
7105: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7109: LD_INT 10
7111: PPUSH
7112: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7116: LD_EXP 31
7120: PPUSH
7121: LD_INT 65
7123: PPUSH
7124: LD_INT 101
7126: PPUSH
7127: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7131: LD_EXP 31
7135: PPUSH
7136: LD_INT 63
7138: PPUSH
7139: LD_INT 100
7141: PPUSH
7142: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
7146: LD_INT 35
7148: PPUSH
7149: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
7153: LD_EXP 31
7157: PPUSH
7158: LD_INT 65
7160: PPUSH
7161: LD_INT 101
7163: PPUSH
7164: CALL_OW 307
7168: IFFALSE 7146
// Say ( JMM , D2a-JMM-1 ) ;
7170: LD_EXP 31
7174: PPUSH
7175: LD_STRING D2a-JMM-1
7177: PPUSH
7178: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7182: LD_EXP 42
7186: PPUSH
7187: LD_INT 66
7189: PPUSH
7190: LD_INT 103
7192: PPUSH
7193: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
7197: LD_INT 35
7199: PPUSH
7200: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
7204: LD_EXP 42
7208: PPUSH
7209: LD_INT 66
7211: PPUSH
7212: LD_INT 103
7214: PPUSH
7215: CALL_OW 307
7219: IFFALSE 7197
// ComTurnUnit ( Walker , JMM ) ;
7221: LD_EXP 42
7225: PPUSH
7226: LD_EXP 31
7230: PPUSH
7231: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7235: LD_EXP 42
7239: PPUSH
7240: LD_STRING D2a-Sci1-1
7242: PPUSH
7243: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7247: LD_EXP 31
7251: PPUSH
7252: LD_EXP 42
7256: PPUSH
7257: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7261: LD_EXP 31
7265: PPUSH
7266: LD_STRING D2a-JMM-2
7268: PPUSH
7269: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7273: LD_EXP 42
7277: PPUSH
7278: LD_STRING D2a-Sci1-2
7280: PPUSH
7281: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7285: LD_EXP 31
7289: PPUSH
7290: LD_STRING D2a-JMM-3
7292: PPUSH
7293: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7297: LD_EXP 42
7301: PPUSH
7302: LD_STRING D2a-Sci1-3
7304: PPUSH
7305: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7309: LD_ADDR_EXP 2
7313: PUSH
7314: LD_EXP 2
7318: PUSH
7319: LD_EXP 41
7323: PUSH
7324: LD_EXP 42
7328: PUSH
7329: LD_EXP 43
7333: PUSH
7334: LD_EXP 44
7338: PUSH
7339: EMPTY
7340: LIST
7341: LIST
7342: LIST
7343: LIST
7344: ADD
7345: ST_TO_ADDR
// for i in jmm_units do
7346: LD_ADDR_VAR 0 1
7350: PUSH
7351: LD_EXP 2
7355: PUSH
7356: FOR_IN
7357: IFFALSE 7382
// if not IsInUnit ( i ) then
7359: LD_VAR 0 1
7363: PPUSH
7364: CALL_OW 310
7368: NOT
7369: IFFALSE 7380
// ComFree ( i ) ;
7371: LD_VAR 0 1
7375: PPUSH
7376: CALL_OW 139
7380: GO 7356
7382: POP
7383: POP
// InGameOff ;
7384: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
7388: LD_STRING MSolar1
7390: PPUSH
7391: CALL_OW 337
// jmm_on_west := true ;
7395: LD_ADDR_EXP 3
7399: PUSH
7400: LD_INT 1
7402: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7403: LD_INT 1050
7405: PPUSH
7406: CALL_OW 67
// frank_can_return := true ;
7410: LD_ADDR_EXP 10
7414: PUSH
7415: LD_INT 1
7417: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7418: LD_INT 6300
7420: PPUSH
7421: LD_INT 8400
7423: PPUSH
7424: CALL_OW 12
7428: PPUSH
7429: CALL_OW 67
// send_spec_patrol := true ;
7433: LD_ADDR_EXP 26
7437: PUSH
7438: LD_INT 1
7440: ST_TO_ADDR
// end ;
7441: PPOPN 4
7443: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7444: LD_INT 22
7446: PUSH
7447: LD_INT 1
7449: PUSH
7450: EMPTY
7451: LIST
7452: LIST
7453: PUSH
7454: LD_INT 34
7456: PUSH
7457: LD_INT 51
7459: PUSH
7460: EMPTY
7461: LIST
7462: LIST
7463: PUSH
7464: LD_INT 92
7466: PUSH
7467: LD_INT 63
7469: PUSH
7470: LD_INT 100
7472: PUSH
7473: LD_INT 5
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: LIST
7480: LIST
7481: PUSH
7482: EMPTY
7483: LIST
7484: LIST
7485: LIST
7486: PUSH
7487: EMPTY
7488: LIST
7489: PPUSH
7490: CALL_OW 69
7494: PUSH
7495: LD_EXP 3
7499: NOT
7500: AND
7501: IFFALSE 7614
7503: GO 7505
7505: DISABLE
7506: LD_INT 0
7508: PPUSH
7509: PPUSH
// begin enable ;
7510: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
7511: LD_ADDR_VAR 0 2
7515: PUSH
7516: LD_INT 22
7518: PUSH
7519: LD_INT 1
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: LD_INT 34
7528: PUSH
7529: LD_INT 51
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: PUSH
7536: LD_INT 92
7538: PUSH
7539: LD_INT 63
7541: PUSH
7542: LD_INT 100
7544: PUSH
7545: LD_INT 5
7547: PUSH
7548: EMPTY
7549: LIST
7550: LIST
7551: LIST
7552: LIST
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: LIST
7558: PUSH
7559: EMPTY
7560: LIST
7561: PPUSH
7562: CALL_OW 69
7566: ST_TO_ADDR
// if not filter then
7567: LD_VAR 0 2
7571: NOT
7572: IFFALSE 7576
// exit ;
7574: GO 7614
// for i in filter do
7576: LD_ADDR_VAR 0 1
7580: PUSH
7581: LD_VAR 0 2
7585: PUSH
7586: FOR_IN
7587: IFFALSE 7612
// begin SetFuel ( i , 0 ) ;
7589: LD_VAR 0 1
7593: PPUSH
7594: LD_INT 0
7596: PPUSH
7597: CALL_OW 240
// ComStop ( i ) ;
7601: LD_VAR 0 1
7605: PPUSH
7606: CALL_OW 141
// end ;
7610: GO 7586
7612: POP
7613: POP
// end ;
7614: PPOPN 2
7616: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
7617: LD_EXP 26
7621: IFFALSE 8586
7623: GO 7625
7625: DISABLE
7626: LD_INT 0
7628: PPUSH
7629: PPUSH
7630: PPUSH
7631: PPUSH
7632: PPUSH
7633: PPUSH
7634: PPUSH
// begin if not ru_spec_patrol then
7635: LD_EXP 48
7639: NOT
7640: IFFALSE 7644
// exit ;
7642: GO 8586
// dead1 := false ;
7644: LD_ADDR_VAR 0 1
7648: PUSH
7649: LD_INT 0
7651: ST_TO_ADDR
// dead2 := false ;
7652: LD_ADDR_VAR 0 2
7656: PUSH
7657: LD_INT 0
7659: ST_TO_ADDR
// inarea1 := false ;
7660: LD_ADDR_VAR 0 3
7664: PUSH
7665: LD_INT 0
7667: ST_TO_ADDR
// inarea2 := false ;
7668: LD_ADDR_VAR 0 4
7672: PUSH
7673: LD_INT 0
7675: ST_TO_ADDR
// tmp := [ ] ;
7676: LD_ADDR_VAR 0 6
7680: PUSH
7681: EMPTY
7682: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
7683: LD_EXP 48
7687: PPUSH
7688: LD_INT 75
7690: PPUSH
7691: LD_INT 101
7693: PPUSH
7694: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
7698: LD_INT 35
7700: PPUSH
7701: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
7705: LD_INT 1
7707: PPUSH
7708: LD_EXP 48
7712: PUSH
7713: LD_INT 1
7715: ARRAY
7716: PPUSH
7717: CALL_OW 292
7721: IFFALSE 7698
// ComStop ( ru_spec_patrol ) ;
7723: LD_EXP 48
7727: PPUSH
7728: CALL_OW 141
// Wait ( 0 0$02 ) ;
7732: LD_INT 70
7734: PPUSH
7735: CALL_OW 67
// DialogueOn ;
7739: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
7743: LD_EXP 48
7747: PUSH
7748: LD_INT 1
7750: ARRAY
7751: PPUSH
7752: LD_STRING D8-Rus1-1
7754: PPUSH
7755: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
7759: LD_EXP 31
7763: PPUSH
7764: LD_STRING D8-JMM-1
7766: PPUSH
7767: CALL_OW 88
// DialogueOff ;
7771: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
7775: LD_EXP 48
7779: PPUSH
7780: LD_INT 13
7782: PPUSH
7783: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
7787: LD_INT 35
7789: PPUSH
7790: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
7794: LD_VAR 0 1
7798: NOT
7799: PUSH
7800: LD_EXP 48
7804: PUSH
7805: LD_INT 1
7807: ARRAY
7808: PPUSH
7809: CALL_OW 301
7813: AND
7814: IFFALSE 7824
// dead1 := true ;
7816: LD_ADDR_VAR 0 1
7820: PUSH
7821: LD_INT 1
7823: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
7824: LD_VAR 0 2
7828: NOT
7829: PUSH
7830: LD_EXP 48
7834: PUSH
7835: LD_INT 2
7837: ARRAY
7838: PPUSH
7839: CALL_OW 301
7843: AND
7844: IFFALSE 7854
// dead2 := true ;
7846: LD_ADDR_VAR 0 2
7850: PUSH
7851: LD_INT 1
7853: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
7854: LD_VAR 0 3
7858: NOT
7859: PUSH
7860: LD_EXP 48
7864: PUSH
7865: LD_INT 1
7867: ARRAY
7868: PPUSH
7869: LD_INT 14
7871: PPUSH
7872: CALL_OW 308
7876: AND
7877: IFFALSE 7887
// inarea1 := true ;
7879: LD_ADDR_VAR 0 3
7883: PUSH
7884: LD_INT 1
7886: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
7887: LD_VAR 0 4
7891: NOT
7892: PUSH
7893: LD_EXP 48
7897: PUSH
7898: LD_INT 2
7900: ARRAY
7901: PPUSH
7902: LD_INT 14
7904: PPUSH
7905: CALL_OW 308
7909: AND
7910: IFFALSE 7920
// inarea2 := true ;
7912: LD_ADDR_VAR 0 4
7916: PUSH
7917: LD_INT 1
7919: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
7920: LD_VAR 0 1
7924: PUSH
7925: LD_VAR 0 2
7929: AND
7930: PUSH
7931: LD_VAR 0 1
7935: PUSH
7936: LD_VAR 0 4
7940: AND
7941: OR
7942: PUSH
7943: LD_VAR 0 2
7947: PUSH
7948: LD_VAR 0 3
7952: AND
7953: OR
7954: PUSH
7955: LD_VAR 0 3
7959: PUSH
7960: LD_VAR 0 4
7964: AND
7965: OR
7966: IFFALSE 7787
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
7968: LD_VAR 0 3
7972: PUSH
7973: LD_VAR 0 4
7977: AND
7978: PUSH
7979: LD_VAR 0 1
7983: PUSH
7984: LD_VAR 0 4
7988: AND
7989: OR
7990: PUSH
7991: LD_VAR 0 2
7995: PUSH
7996: LD_VAR 0 3
8000: AND
8001: OR
8002: IFFALSE 8566
// begin prepare_siege := true ;
8004: LD_ADDR_EXP 27
8008: PUSH
8009: LD_INT 1
8011: ST_TO_ADDR
// DialogueOn ;
8012: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8016: LD_VAR 0 3
8020: PUSH
8021: LD_VAR 0 4
8025: AND
8026: IFFALSE 8042
// Say ( JMM , D8b-JMM-1a ) else
8028: LD_EXP 31
8032: PPUSH
8033: LD_STRING D8b-JMM-1a
8035: PPUSH
8036: CALL_OW 88
8040: GO 8054
// Say ( JMM , D8b-JMM-1 ) ;
8042: LD_EXP 31
8046: PPUSH
8047: LD_STRING D8b-JMM-1
8049: PPUSH
8050: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8054: LD_EXP 2
8058: PPUSH
8059: LD_INT 26
8061: PUSH
8062: LD_INT 1
8064: PUSH
8065: EMPTY
8066: LIST
8067: LIST
8068: PPUSH
8069: CALL_OW 72
8073: PUSH
8074: LD_EXP 32
8078: PUSH
8079: LD_EXP 33
8083: PUSH
8084: LD_EXP 42
8088: PUSH
8089: LD_EXP 45
8093: PUSH
8094: EMPTY
8095: LIST
8096: LIST
8097: LIST
8098: LIST
8099: DIFF
8100: PPUSH
8101: LD_STRING D8b-Sol1-1
8103: PPUSH
8104: CALL 579 0 2
// if Cyrus and Cyrus in jmm_units then
8108: LD_EXP 33
8112: PUSH
8113: LD_EXP 33
8117: PUSH
8118: LD_EXP 2
8122: IN
8123: AND
8124: IFFALSE 8140
// Say ( Cyrus , D8b-Cyrus-1 ) else
8126: LD_EXP 33
8130: PPUSH
8131: LD_STRING D8b-Cyrus-1
8133: PPUSH
8134: CALL_OW 88
8138: GO 8152
// Say ( JMM , D8b-JMM-1a ) ;
8140: LD_EXP 31
8144: PPUSH
8145: LD_STRING D8b-JMM-1a
8147: PPUSH
8148: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8152: LD_EXP 34
8156: PUSH
8157: LD_EXP 34
8161: PUSH
8162: LD_EXP 2
8166: IN
8167: AND
8168: IFFALSE 8182
// Say ( Lisa , D8b-Lisa-2 ) ;
8170: LD_EXP 34
8174: PPUSH
8175: LD_STRING D8b-Lisa-2
8177: PPUSH
8178: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8182: LD_EXP 32
8186: PUSH
8187: LD_EXP 32
8191: PUSH
8192: LD_EXP 2
8196: IN
8197: AND
8198: IFFALSE 8214
// Say ( Bobby , D8b-Bobby-1 ) else
8200: LD_EXP 32
8204: PPUSH
8205: LD_STRING D8b-Bobby-1
8207: PPUSH
8208: CALL_OW 88
8212: GO 8274
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8214: LD_ADDR_VAR 0 5
8218: PUSH
8219: LD_EXP 2
8223: PPUSH
8224: LD_INT 26
8226: PUSH
8227: LD_INT 1
8229: PUSH
8230: EMPTY
8231: LIST
8232: LIST
8233: PPUSH
8234: CALL_OW 72
8238: PUSH
8239: LD_EXP 32
8243: PUSH
8244: LD_EXP 33
8248: PUSH
8249: LD_EXP 42
8253: PUSH
8254: LD_EXP 45
8258: PUSH
8259: EMPTY
8260: LIST
8261: LIST
8262: LIST
8263: LIST
8264: DIFF
8265: PPUSH
8266: LD_STRING D8b-Sol2-1
8268: PPUSH
8269: CALL 579 0 2
8273: ST_TO_ADDR
// DialogueOff ;
8274: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8278: LD_EXP 33
8282: PUSH
8283: LD_EXP 33
8287: PUSH
8288: LD_EXP 2
8292: IN
8293: AND
8294: IFFALSE 8319
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8296: LD_ADDR_VAR 0 6
8300: PUSH
8301: LD_VAR 0 6
8305: PPUSH
8306: LD_INT 1
8308: PPUSH
8309: LD_EXP 33
8313: PPUSH
8314: CALL_OW 2
8318: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8319: LD_EXP 32
8323: PUSH
8324: LD_EXP 32
8328: PUSH
8329: LD_EXP 2
8333: IN
8334: AND
8335: IFFALSE 8360
// tmp := Insert ( tmp , 1 , Bobby ) ;
8337: LD_ADDR_VAR 0 6
8341: PUSH
8342: LD_VAR 0 6
8346: PPUSH
8347: LD_INT 1
8349: PPUSH
8350: LD_EXP 32
8354: PPUSH
8355: CALL_OW 2
8359: ST_TO_ADDR
// if sol then
8360: LD_VAR 0 5
8364: IFFALSE 8389
// tmp := Insert ( tmp , 1 , sol ) ;
8366: LD_ADDR_VAR 0 6
8370: PUSH
8371: LD_VAR 0 6
8375: PPUSH
8376: LD_INT 1
8378: PPUSH
8379: LD_VAR 0 5
8383: PPUSH
8384: CALL_OW 2
8388: ST_TO_ADDR
// if tmp then
8389: LD_VAR 0 6
8393: IFFALSE 8525
// begin SetSide ( tmp , 8 ) ;
8395: LD_VAR 0 6
8399: PPUSH
8400: LD_INT 8
8402: PPUSH
8403: CALL_OW 235
// ComFree ( tmp ) ;
8407: LD_VAR 0 6
8411: PPUSH
8412: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8416: LD_VAR 0 6
8420: PPUSH
8421: LD_INT 15
8423: PPUSH
8424: CALL_OW 173
// AddComHold ( tmp ) ;
8428: LD_VAR 0 6
8432: PPUSH
8433: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8437: LD_INT 35
8439: PPUSH
8440: CALL_OW 67
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8444: LD_VAR 0 6
8448: PUSH
8449: LD_INT 1
8451: ARRAY
8452: PPUSH
8453: LD_INT 15
8455: PPUSH
8456: CALL_OW 308
8460: IFFALSE 8515
// begin RemoveUnit ( tmp [ 1 ] ) ;
8462: LD_VAR 0 6
8466: PUSH
8467: LD_INT 1
8469: ARRAY
8470: PPUSH
8471: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
8475: LD_ADDR_EXP 2
8479: PUSH
8480: LD_EXP 2
8484: PUSH
8485: LD_VAR 0 6
8489: PUSH
8490: LD_INT 1
8492: ARRAY
8493: DIFF
8494: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
8495: LD_ADDR_VAR 0 6
8499: PUSH
8500: LD_VAR 0 6
8504: PUSH
8505: LD_VAR 0 6
8509: PUSH
8510: LD_INT 1
8512: ARRAY
8513: DIFF
8514: ST_TO_ADDR
// end ; until tmp = 0 ;
8515: LD_VAR 0 6
8519: PUSH
8520: LD_INT 0
8522: EQUAL
8523: IFFALSE 8437
// end ; Wait ( 0 0$30 ) ;
8525: LD_INT 1050
8527: PPUSH
8528: CALL_OW 67
// if ru_spec_patrol then
8532: LD_EXP 48
8536: IFFALSE 8564
// for i in ru_spec_patrol do
8538: LD_ADDR_VAR 0 7
8542: PUSH
8543: LD_EXP 48
8547: PUSH
8548: FOR_IN
8549: IFFALSE 8562
// RemoveUnit ( i ) ;
8551: LD_VAR 0 7
8555: PPUSH
8556: CALL_OW 64
8560: GO 8548
8562: POP
8563: POP
// end else
8564: GO 8586
// begin prepare_siege := false ;
8566: LD_ADDR_EXP 27
8570: PUSH
8571: LD_INT 0
8573: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
8574: LD_EXP 31
8578: PPUSH
8579: LD_STRING D8a-JMM-1
8581: PPUSH
8582: CALL_OW 88
// end ; end ;
8586: PPOPN 7
8588: END
// every 0 0$10 trigger frank_can_return do var i , points ;
8589: LD_EXP 10
8593: IFFALSE 9727
8595: GO 8597
8597: DISABLE
8598: LD_INT 0
8600: PPUSH
8601: PPUSH
// begin uc_side := 8 ;
8602: LD_ADDR_OWVAR 20
8606: PUSH
8607: LD_INT 8
8609: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
8610: LD_ADDR_VAR 0 2
8614: PUSH
8615: LD_INT 59
8617: PUSH
8618: LD_INT 71
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: PUSH
8625: LD_INT 122
8627: PUSH
8628: LD_INT 117
8630: PUSH
8631: EMPTY
8632: LIST
8633: LIST
8634: PUSH
8635: EMPTY
8636: LIST
8637: LIST
8638: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
8639: LD_ADDR_EXP 45
8643: PUSH
8644: LD_STRING Frank
8646: PPUSH
8647: LD_INT 0
8649: PPUSH
8650: CALL 434 0 2
8654: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
8655: LD_ADDR_VAR 0 1
8659: PUSH
8660: LD_INT 1
8662: PPUSH
8663: LD_INT 2
8665: PPUSH
8666: CALL_OW 12
8670: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
8671: LD_EXP 45
8675: PPUSH
8676: LD_VAR 0 2
8680: PUSH
8681: LD_VAR 0 1
8685: ARRAY
8686: PUSH
8687: LD_INT 1
8689: ARRAY
8690: PPUSH
8691: LD_VAR 0 2
8695: PUSH
8696: LD_VAR 0 1
8700: ARRAY
8701: PUSH
8702: LD_INT 2
8704: ARRAY
8705: PPUSH
8706: LD_INT 0
8708: PPUSH
8709: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
8713: LD_EXP 45
8717: PPUSH
8718: LD_INT 1
8720: PPUSH
8721: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
8725: LD_INT 35
8727: PPUSH
8728: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
8732: LD_EXP 45
8736: PPUSH
8737: LD_EXP 31
8741: PPUSH
8742: CALL_OW 296
8746: PUSH
8747: LD_INT 8
8749: LESS
8750: IFFALSE 8725
// InGameOn ;
8752: CALL_OW 8
// CenterOnUnits ( JMM ) ;
8756: LD_EXP 31
8760: PPUSH
8761: CALL_OW 85
// if IsInUnit ( JMM ) then
8765: LD_EXP 31
8769: PPUSH
8770: CALL_OW 310
8774: IFFALSE 8785
// ComFree ( JMM ) ;
8776: LD_EXP 31
8780: PPUSH
8781: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
8785: LD_EXP 31
8789: PPUSH
8790: LD_EXP 45
8794: PPUSH
8795: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
8799: LD_EXP 45
8803: PPUSH
8804: LD_EXP 31
8808: PPUSH
8809: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
8813: LD_EXP 31
8817: PPUSH
8818: LD_STRING D6-JMM-1
8820: PPUSH
8821: CALL_OW 88
// repeat wait ( 3 ) ;
8825: LD_INT 3
8827: PPUSH
8828: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
8832: LD_EXP 31
8836: PPUSH
8837: LD_EXP 45
8841: PPUSH
8842: CALL_OW 296
8846: PUSH
8847: LD_INT 8
8849: LESS
8850: IFFALSE 8825
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
8852: LD_EXP 34
8856: PUSH
8857: LD_EXP 34
8861: PPUSH
8862: LD_EXP 45
8866: PPUSH
8867: CALL_OW 296
8871: PUSH
8872: LD_INT 20
8874: LESS
8875: AND
8876: IFFALSE 8901
// begin ComFree ( Lisa ) ;
8878: LD_EXP 34
8882: PPUSH
8883: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
8887: LD_EXP 34
8891: PPUSH
8892: LD_EXP 45
8896: PPUSH
8897: CALL_OW 172
// end ; if Lynch then
8901: LD_EXP 41
8905: IFFALSE 8930
// begin ComFree ( Lynch ) ;
8907: LD_EXP 41
8911: PPUSH
8912: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
8916: LD_EXP 41
8920: PPUSH
8921: LD_EXP 45
8925: PPUSH
8926: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
8930: LD_EXP 31
8934: PPUSH
8935: LD_EXP 45
8939: PPUSH
8940: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
8944: LD_EXP 45
8948: PPUSH
8949: LD_EXP 31
8953: PPUSH
8954: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
8958: LD_EXP 45
8962: PPUSH
8963: LD_STRING D6-Frank-1
8965: PPUSH
8966: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
8970: LD_INT 69
8972: PPUSH
8973: LD_INT 20
8975: PPUSH
8976: LD_INT 1
8978: PPUSH
8979: LD_INT 20
8981: NEG
8982: PPUSH
8983: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
8987: LD_INT 69
8989: PPUSH
8990: LD_INT 20
8992: PPUSH
8993: LD_INT 1
8995: PPUSH
8996: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
9000: LD_INT 190
9002: PPUSH
9003: LD_INT 31
9005: PPUSH
9006: LD_INT 1
9008: PPUSH
9009: LD_INT 20
9011: NEG
9012: PPUSH
9013: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9017: LD_INT 190
9019: PPUSH
9020: LD_INT 31
9022: PPUSH
9023: LD_INT 1
9025: PPUSH
9026: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9030: LD_INT 69
9032: PPUSH
9033: LD_INT 20
9035: PPUSH
9036: CALL_OW 84
// Wait ( 0 0$02 ) ;
9040: LD_INT 70
9042: PPUSH
9043: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9047: LD_EXP 31
9051: PPUSH
9052: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9056: LD_EXP 34
9060: PUSH
9061: LD_EXP 34
9065: PPUSH
9066: LD_EXP 45
9070: PPUSH
9071: CALL_OW 296
9075: PUSH
9076: LD_INT 20
9078: LESS
9079: AND
9080: PUSH
9081: LD_EXP 34
9085: PPUSH
9086: CALL_OW 302
9090: AND
9091: IFFALSE 9181
// begin ComFree ( Lisa ) ;
9093: LD_EXP 34
9097: PPUSH
9098: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
9102: LD_INT 35
9104: PPUSH
9105: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
9109: LD_EXP 34
9113: PPUSH
9114: LD_EXP 45
9118: PPUSH
9119: CALL_OW 296
9123: PUSH
9124: LD_INT 7
9126: LESS
9127: IFFALSE 9102
// Say ( Lisa , D6-Lisa-1 ) ;
9129: LD_EXP 34
9133: PPUSH
9134: LD_STRING D6-Lisa-1
9136: PPUSH
9137: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9141: LD_EXP 34
9145: PPUSH
9146: LD_EXP 45
9150: PPUSH
9151: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9155: LD_EXP 45
9159: PPUSH
9160: LD_EXP 34
9164: PPUSH
9165: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9169: LD_EXP 45
9173: PPUSH
9174: LD_STRING D6-Frank-2
9176: PPUSH
9177: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9181: LD_EXP 41
9185: PUSH
9186: LD_EXP 41
9190: PPUSH
9191: LD_EXP 45
9195: PPUSH
9196: CALL_OW 296
9200: PUSH
9201: LD_INT 20
9203: LESS
9204: AND
9205: PUSH
9206: LD_EXP 41
9210: PPUSH
9211: CALL_OW 302
9215: AND
9216: IFFALSE 9397
// begin ComTurnUnit ( Lynch , JMM ) ;
9218: LD_EXP 41
9222: PPUSH
9223: LD_EXP 31
9227: PPUSH
9228: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9232: LD_EXP 45
9236: PPUSH
9237: LD_EXP 31
9241: PPUSH
9242: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9246: LD_EXP 41
9250: PPUSH
9251: LD_STRING D6-Sol1-2
9253: PPUSH
9254: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9258: LD_EXP 31
9262: PPUSH
9263: LD_STRING D6-JMM-2
9265: PPUSH
9266: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9270: LD_EXP 45
9274: PPUSH
9275: LD_STRING D6-Frank-3
9277: PPUSH
9278: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9282: LD_EXP 31
9286: PPUSH
9287: LD_STRING D6-JMM-3
9289: PPUSH
9290: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9294: LD_EXP 45
9298: PPUSH
9299: LD_STRING D6-Frank-4
9301: PPUSH
9302: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9306: LD_EXP 45
9310: PPUSH
9311: LD_STRING D6-Frank-4a
9313: PPUSH
9314: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9318: LD_EXP 31
9322: PPUSH
9323: LD_STRING D6-JMM-4
9325: PPUSH
9326: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9330: LD_EXP 45
9334: PPUSH
9335: LD_STRING D6-Frank-5
9337: PPUSH
9338: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9342: LD_EXP 34
9346: PUSH
9347: LD_EXP 34
9351: PPUSH
9352: CALL_OW 302
9356: AND
9357: IFFALSE 9371
// Say ( Lisa , D6-Lisa-5 ) ;
9359: LD_EXP 34
9363: PPUSH
9364: LD_STRING D6-Lisa-5
9366: PPUSH
9367: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9371: LD_EXP 45
9375: PPUSH
9376: LD_STRING D6-Frank-6
9378: PPUSH
9379: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9383: LD_EXP 31
9387: PPUSH
9388: LD_STRING D6-JMM-6
9390: PPUSH
9391: CALL_OW 88
// end else
9395: GO 9512
// begin ComTurnUnit ( Frank , JMM ) ;
9397: LD_EXP 45
9401: PPUSH
9402: LD_EXP 31
9406: PPUSH
9407: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
9411: LD_EXP 45
9415: PPUSH
9416: LD_STRING D6-Frank-4
9418: PPUSH
9419: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9423: LD_EXP 45
9427: PPUSH
9428: LD_STRING D6-Frank-4a
9430: PPUSH
9431: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9435: LD_EXP 31
9439: PPUSH
9440: LD_STRING D6-JMM-4
9442: PPUSH
9443: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9447: LD_EXP 45
9451: PPUSH
9452: LD_STRING D6-Frank-5
9454: PPUSH
9455: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9459: LD_EXP 34
9463: PUSH
9464: LD_EXP 34
9468: PPUSH
9469: CALL_OW 302
9473: AND
9474: IFFALSE 9488
// Say ( Lisa , D6-Lisa-5 ) ;
9476: LD_EXP 34
9480: PPUSH
9481: LD_STRING D6-Lisa-5
9483: PPUSH
9484: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9488: LD_EXP 45
9492: PPUSH
9493: LD_STRING D6-Frank-6
9495: PPUSH
9496: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9500: LD_EXP 31
9504: PPUSH
9505: LD_STRING D6-JMM-6
9507: PPUSH
9508: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
9512: LD_STRING Q1
9514: PPUSH
9515: CALL_OW 97
9519: PUSH
9520: LD_INT 1
9522: DOUBLE
9523: EQUAL
9524: IFTRUE 9528
9526: GO 9539
9528: POP
// frank_send_to_scout := true ; 2 :
9529: LD_ADDR_EXP 12
9533: PUSH
9534: LD_INT 1
9536: ST_TO_ADDR
9537: GO 9559
9539: LD_INT 2
9541: DOUBLE
9542: EQUAL
9543: IFTRUE 9547
9545: GO 9558
9547: POP
// frank_send_to_scout := false ; end ;
9548: LD_ADDR_EXP 12
9552: PUSH
9553: LD_INT 0
9555: ST_TO_ADDR
9556: GO 9559
9558: POP
// InGameOff ;
9559: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
9563: LD_EXP 31
9567: PUSH
9568: LD_EXP 34
9572: PUSH
9573: LD_EXP 41
9577: PUSH
9578: EMPTY
9579: LIST
9580: LIST
9581: LIST
9582: PPUSH
9583: CALL_OW 139
// if frank_send_to_scout then
9587: LD_EXP 12
9591: IFFALSE 9648
// begin ComMoveXY ( Frank , 130 , 123 ) ;
9593: LD_EXP 45
9597: PPUSH
9598: LD_INT 130
9600: PPUSH
9601: LD_INT 123
9603: PPUSH
9604: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
9608: LD_INT 35
9610: PPUSH
9611: CALL_OW 67
// until not See ( 1 , Frank ) ;
9615: LD_INT 1
9617: PPUSH
9618: LD_EXP 45
9622: PPUSH
9623: CALL_OW 292
9627: NOT
9628: IFFALSE 9608
// Wait ( 0 0$02 ) ;
9630: LD_INT 70
9632: PPUSH
9633: CALL_OW 67
// RemoveUnit ( Frank ) ;
9637: LD_EXP 45
9641: PPUSH
9642: CALL_OW 64
// end else
9646: GO 9660
// SetSide ( Frank , 1 ) ;
9648: LD_EXP 45
9652: PPUSH
9653: LD_INT 1
9655: PPUSH
9656: CALL_OW 235
// send_attack_on_cornel_base := true ;
9660: LD_ADDR_EXP 23
9664: PUSH
9665: LD_INT 1
9667: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9668: LD_INT 35
9670: PPUSH
9671: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
9675: LD_ADDR_EXP 25
9679: PUSH
9680: LD_EXP 25
9684: PPUSH
9685: LD_STRING -
9687: PPUSH
9688: CALL 1071 0 2
9692: ST_TO_ADDR
// if debug then
9693: LD_EXP 1
9697: IFFALSE 9709
// debug_strings := time_to_prepare ;
9699: LD_ADDR_OWVAR 48
9703: PUSH
9704: LD_EXP 25
9708: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
9709: LD_EXP 25
9713: PUSH
9714: LD_INT 0
9716: EQUAL
9717: IFFALSE 9668
// cornel_prepared := true ;
9719: LD_ADDR_EXP 9
9723: PUSH
9724: LD_INT 1
9726: ST_TO_ADDR
// end ;
9727: PPOPN 2
9729: END
// every 0 0$01 trigger cornel_prepared do
9730: LD_EXP 9
9734: IFFALSE 9980
9736: GO 9738
9738: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
9739: LD_EXP 38
9743: PPUSH
9744: LD_STRING D3-Corn-1
9746: PPUSH
9747: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
9751: LD_INT 35
9753: PPUSH
9754: CALL_OW 67
// until cornel_counter = 0 ;
9758: LD_EXP 8
9762: PUSH
9763: LD_INT 0
9765: EQUAL
9766: IFFALSE 9751
// SayRadio ( Cornel , D3a-Corn-1 ) ;
9768: LD_EXP 38
9772: PPUSH
9773: LD_STRING D3a-Corn-1
9775: PPUSH
9776: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
9780: LD_EXP 31
9784: PPUSH
9785: LD_STRING D3a-JMM-1
9787: PPUSH
9788: CALL_OW 88
// end_mission_allowed := true ;
9792: LD_ADDR_EXP 18
9796: PUSH
9797: LD_INT 1
9799: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
9800: LD_STRING M2
9802: PPUSH
9803: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
9807: LD_INT 9
9809: PPUSH
9810: LD_INT 1
9812: PPUSH
9813: CALL_OW 424
// Wait ( 0 0$05 ) ;
9817: LD_INT 175
9819: PPUSH
9820: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
9824: LD_EXP 38
9828: PPUSH
9829: LD_STRING D3a-Corn-2
9831: PPUSH
9832: CALL_OW 94
// cornel_attack := true ;
9836: LD_ADDR_EXP 7
9840: PUSH
9841: LD_INT 1
9843: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
9844: LD_INT 105
9846: PPUSH
9847: CALL_OW 67
// AddMoreTanks ( ) ;
9851: CALL 4729 0 0
// if frank_send_to_scout then
9855: LD_EXP 12
9859: IFFALSE 9980
// begin InitHc ;
9861: CALL_OW 19
// InitUc ;
9865: CALL_OW 18
// uc_side := 8 ;
9869: LD_ADDR_OWVAR 20
9873: PUSH
9874: LD_INT 8
9876: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9877: LD_ADDR_EXP 45
9881: PUSH
9882: LD_STRING Frank
9884: PPUSH
9885: LD_INT 0
9887: PPUSH
9888: CALL 434 0 2
9892: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
9893: LD_EXP 45
9897: PPUSH
9898: LD_INT 6
9900: PPUSH
9901: LD_INT 9
9903: PPUSH
9904: LD_INT 0
9906: PPUSH
9907: CALL_OW 48
// ComCrawl ( Frank ) ;
9911: LD_EXP 45
9915: PPUSH
9916: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
9920: LD_INT 35
9922: PPUSH
9923: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
9927: LD_EXP 31
9931: PPUSH
9932: LD_EXP 45
9936: PPUSH
9937: CALL_OW 296
9941: PUSH
9942: LD_INT 9
9944: LESS
9945: IFFALSE 9920
// SetSide ( Frank , 1 ) ;
9947: LD_EXP 45
9951: PPUSH
9952: LD_INT 1
9954: PPUSH
9955: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
9959: LD_EXP 45
9963: PPUSH
9964: LD_STRING D6a-Frank-1
9966: PPUSH
9967: CALL_OW 88
// ComWalk ( Frank ) ;
9971: LD_EXP 45
9975: PPUSH
9976: CALL_OW 138
// end ; end ;
9980: END
// every 0 0$01 trigger solar_builded do
9981: LD_EXP 11
9985: IFFALSE 10089
9987: GO 9989
9989: DISABLE
// begin Wait ( 0 0$02 ) ;
9990: LD_INT 70
9992: PPUSH
9993: CALL_OW 67
// DialogueOn ;
9997: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
10001: LD_EXP 31
10005: PPUSH
10006: LD_STRING D2b-JMM-1
10008: PPUSH
10009: CALL_OW 88
// if Walker and IsOk ( Walker ) then
10013: LD_EXP 42
10017: PUSH
10018: LD_EXP 42
10022: PPUSH
10023: CALL_OW 302
10027: AND
10028: IFFALSE 10078
// begin Say ( Walker , D2b-Sci1-1 ) ;
10030: LD_EXP 42
10034: PPUSH
10035: LD_STRING D2b-Sci1-1
10037: PPUSH
10038: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10042: LD_EXP 31
10046: PPUSH
10047: LD_STRING D2b-JMM-2
10049: PPUSH
10050: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10054: LD_EXP 42
10058: PPUSH
10059: LD_STRING D2b-Sci1-2
10061: PPUSH
10062: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10066: LD_EXP 31
10070: PPUSH
10071: LD_STRING D2b-JMM-3
10073: PPUSH
10074: CALL_OW 88
// end ; DialogueOff ;
10078: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10082: LD_STRING MOutSol
10084: PPUSH
10085: CALL_OW 337
// end ;
10089: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10090: LD_EXP 11
10094: PUSH
10095: LD_EXP 31
10099: PPUSH
10100: CALL_OW 302
10104: AND
10105: PUSH
10106: LD_EXP 31
10110: PPUSH
10111: CALL 905 0 1
10115: AND
10116: PUSH
10117: LD_EXP 13
10121: NOT
10122: AND
10123: IFFALSE 10194
10125: GO 10127
10127: DISABLE
10128: LD_INT 0
10130: PPUSH
// begin jmm_in_veh := true ;
10131: LD_ADDR_EXP 13
10135: PUSH
10136: LD_INT 1
10138: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10139: LD_ADDR_VAR 0 1
10143: PUSH
10144: LD_INT 0
10146: PPUSH
10147: LD_INT 1
10149: PPUSH
10150: CALL_OW 12
10154: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10155: LD_INT 70
10157: PPUSH
10158: CALL_OW 67
// if i then
10162: LD_VAR 0 1
10166: IFFALSE 10182
// Say ( JMM , D2c-JMM-1 ) else
10168: LD_EXP 31
10172: PPUSH
10173: LD_STRING D2c-JMM-1
10175: PPUSH
10176: CALL_OW 88
10180: GO 10194
// Say ( JMM , D2c-JMM-1a ) ;
10182: LD_EXP 31
10186: PPUSH
10187: LD_STRING D2c-JMM-1a
10189: PPUSH
10190: CALL_OW 88
// end ;
10194: PPOPN 1
10196: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10197: LD_EXP 11
10201: PUSH
10202: LD_EXP 32
10206: PPUSH
10207: CALL_OW 302
10211: AND
10212: PUSH
10213: LD_EXP 32
10217: PPUSH
10218: CALL 905 0 1
10222: AND
10223: PUSH
10224: LD_EXP 14
10228: NOT
10229: AND
10230: IFFALSE 10262
10232: GO 10234
10234: DISABLE
// begin bobby_in_veh := true ;
10235: LD_ADDR_EXP 14
10239: PUSH
10240: LD_INT 1
10242: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10243: LD_INT 70
10245: PPUSH
10246: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10250: LD_EXP 32
10254: PPUSH
10255: LD_STRING D2c-Bobby-1
10257: PPUSH
10258: CALL_OW 88
10262: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10263: LD_EXP 11
10267: PUSH
10268: LD_EXP 34
10272: PPUSH
10273: CALL_OW 302
10277: AND
10278: PUSH
10279: LD_EXP 34
10283: PPUSH
10284: CALL 905 0 1
10288: AND
10289: PUSH
10290: LD_EXP 16
10294: NOT
10295: AND
10296: IFFALSE 10328
10298: GO 10300
10300: DISABLE
// begin lisa_in_veh := true ;
10301: LD_ADDR_EXP 16
10305: PUSH
10306: LD_INT 1
10308: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10309: LD_INT 70
10311: PPUSH
10312: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10316: LD_EXP 34
10320: PPUSH
10321: LD_STRING D2c-Lisa-1
10323: PPUSH
10324: CALL_OW 88
10328: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
10329: LD_EXP 11
10333: PUSH
10334: LD_EXP 33
10338: PPUSH
10339: CALL_OW 302
10343: AND
10344: PUSH
10345: LD_EXP 33
10349: PPUSH
10350: CALL 905 0 1
10354: AND
10355: PUSH
10356: LD_EXP 15
10360: NOT
10361: AND
10362: IFFALSE 10433
10364: GO 10366
10366: DISABLE
10367: LD_INT 0
10369: PPUSH
// begin cyrus_in_veh := true ;
10370: LD_ADDR_EXP 15
10374: PUSH
10375: LD_INT 1
10377: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10378: LD_ADDR_VAR 0 1
10382: PUSH
10383: LD_INT 0
10385: PPUSH
10386: LD_INT 1
10388: PPUSH
10389: CALL_OW 12
10393: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10394: LD_INT 70
10396: PPUSH
10397: CALL_OW 67
// if i then
10401: LD_VAR 0 1
10405: IFFALSE 10421
// Say ( Cyrus , D2c-Cyrus-1 ) else
10407: LD_EXP 33
10411: PPUSH
10412: LD_STRING D2c-Cyrus-1
10414: PPUSH
10415: CALL_OW 88
10419: GO 10433
// Say ( Cyrus , D2c-Cyrus-1a ) ;
10421: LD_EXP 33
10425: PPUSH
10426: LD_STRING D2c-Cyrus-1a
10428: PPUSH
10429: CALL_OW 88
// end ;
10433: PPOPN 1
10435: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
10436: LD_EXP 38
10440: PPUSH
10441: LD_INT 16
10443: PPUSH
10444: CALL_OW 308
10448: IFFALSE 10698
10450: GO 10452
10452: DISABLE
10453: LD_INT 0
10455: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
10456: LD_INT 3
10458: PPUSH
10459: LD_EXP 38
10463: PPUSH
10464: CALL_OW 471
// send_attack_on_cornel := true ;
10468: LD_ADDR_EXP 28
10472: PUSH
10473: LD_INT 1
10475: ST_TO_ADDR
// if ru_vehicles then
10476: LD_EXP 50
10480: IFFALSE 10514
// for i in ru_vehicles do
10482: LD_ADDR_VAR 0 1
10486: PUSH
10487: LD_EXP 50
10491: PUSH
10492: FOR_IN
10493: IFFALSE 10512
// ComAgressiveMove ( i , 215 , 69 ) ;
10495: LD_VAR 0 1
10499: PPUSH
10500: LD_INT 215
10502: PPUSH
10503: LD_INT 69
10505: PPUSH
10506: CALL_OW 114
10510: GO 10492
10512: POP
10513: POP
// if ru_patrol then
10514: LD_EXP 47
10518: IFFALSE 10552
// for i in ru_patrol do
10520: LD_ADDR_VAR 0 1
10524: PUSH
10525: LD_EXP 47
10529: PUSH
10530: FOR_IN
10531: IFFALSE 10550
// ComAgressiveMove ( i , 215 , 69 ) ;
10533: LD_VAR 0 1
10537: PPUSH
10538: LD_INT 215
10540: PPUSH
10541: LD_INT 69
10543: PPUSH
10544: CALL_OW 114
10548: GO 10530
10550: POP
10551: POP
// if frank_send_to_scout then
10552: LD_EXP 12
10556: IFFALSE 10570
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
10558: LD_EXP 45
10562: PPUSH
10563: LD_STRING D3b-Frank-1
10565: PPUSH
10566: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
10570: LD_INT 105
10572: PPUSH
10573: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
10577: LD_EXP 38
10581: PPUSH
10582: LD_STRING D4-Corn-1
10584: PPUSH
10585: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10589: LD_INT 35
10591: PPUSH
10592: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 6 ;
10596: LD_INT 22
10598: PUSH
10599: LD_INT 4
10601: PUSH
10602: EMPTY
10603: LIST
10604: LIST
10605: PUSH
10606: LD_INT 21
10608: PUSH
10609: LD_INT 1
10611: PUSH
10612: EMPTY
10613: LIST
10614: LIST
10615: PUSH
10616: LD_INT 50
10618: PUSH
10619: EMPTY
10620: LIST
10621: PUSH
10622: EMPTY
10623: LIST
10624: LIST
10625: LIST
10626: PPUSH
10627: CALL_OW 69
10631: PUSH
10632: LD_INT 6
10634: LESS
10635: IFFALSE 10589
// SayRadio ( Cornel , D5-Corn-1 ) ;
10637: LD_EXP 38
10641: PPUSH
10642: LD_STRING D5-Corn-1
10644: PPUSH
10645: CALL_OW 94
// SaveCharacters ( Cornel , Cornel ) ;
10649: LD_EXP 38
10653: PPUSH
10654: LD_STRING Cornel
10656: PPUSH
10657: CALL_OW 38
// ChangeSideFog ( 4 , 8 ) ;
10661: LD_INT 4
10663: PPUSH
10664: LD_INT 8
10666: PPUSH
10667: CALL_OW 343
// Wait ( 0 0$01 ) ;
10671: LD_INT 35
10673: PPUSH
10674: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
10678: LD_INT 3
10680: PPUSH
10681: LD_EXP 38
10685: PPUSH
10686: CALL_OW 472
// send_attack_on_cornel := false ;
10690: LD_ADDR_EXP 28
10694: PUSH
10695: LD_INT 0
10697: ST_TO_ADDR
// end ;
10698: PPOPN 1
10700: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
10701: LD_INT 9
10703: PPUSH
10704: LD_INT 22
10706: PUSH
10707: LD_INT 1
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: PPUSH
10714: CALL_OW 70
10718: PUSH
10719: LD_EXP 29
10723: OR
10724: IFFALSE 11243
10726: GO 10728
10728: DISABLE
10729: LD_INT 0
10731: PPUSH
10732: PPUSH
// begin enable ;
10733: ENABLE
// if not game_end then
10734: LD_EXP 29
10738: NOT
10739: IFFALSE 10749
// game_end := true ;
10741: LD_ADDR_EXP 29
10745: PUSH
10746: LD_INT 1
10748: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
10749: LD_ADDR_VAR 0 2
10753: PUSH
10754: LD_INT 9
10756: PPUSH
10757: LD_INT 22
10759: PUSH
10760: LD_INT 1
10762: PUSH
10763: EMPTY
10764: LIST
10765: LIST
10766: PPUSH
10767: CALL_OW 70
10771: ST_TO_ADDR
// if not filter then
10772: LD_VAR 0 2
10776: NOT
10777: IFFALSE 10781
// exit ;
10779: GO 11243
// for i in filter do
10781: LD_ADDR_VAR 0 1
10785: PUSH
10786: LD_VAR 0 2
10790: PUSH
10791: FOR_IN
10792: IFFALSE 11241
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
10794: LD_VAR 0 1
10798: PPUSH
10799: CALL_OW 302
10803: PUSH
10804: LD_VAR 0 1
10808: PPUSH
10809: CALL_OW 247
10813: PUSH
10814: LD_INT 2
10816: EQUAL
10817: AND
10818: IFFALSE 10858
// begin veh_on_meta := true ;
10820: LD_ADDR_EXP 24
10824: PUSH
10825: LD_INT 1
10827: ST_TO_ADDR
// ComExitVehicle ( IsInUnit ( i ) ) ;
10828: LD_VAR 0 1
10832: PPUSH
10833: CALL_OW 310
10837: PPUSH
10838: CALL_OW 121
// RemoveUnit ( i ) ;
10842: LD_VAR 0 1
10846: PPUSH
10847: CALL_OW 64
// Wait ( 10 ) ;
10851: LD_INT 10
10853: PPUSH
10854: CALL_OW 67
// end ; if i = JMM then
10858: LD_VAR 0 1
10862: PUSH
10863: LD_EXP 31
10867: EQUAL
10868: IFFALSE 10990
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
10870: LD_EXP 21
10874: PUSH
10875: LD_INT 22
10877: PUSH
10878: LD_INT 1
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PUSH
10885: LD_INT 21
10887: PUSH
10888: LD_INT 1
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: PPUSH
10899: CALL_OW 69
10903: PUSH
10904: LD_INT 1
10906: GREATER
10907: AND
10908: IFFALSE 10965
// begin show_query := false ;
10910: LD_ADDR_EXP 21
10914: PUSH
10915: LD_INT 0
10917: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
10918: LD_STRING Q2
10920: PPUSH
10921: CALL_OW 97
10925: PUSH
10926: LD_INT 1
10928: DOUBLE
10929: EQUAL
10930: IFTRUE 10934
10932: GO 10945
10934: POP
// wait_for_them := true ; 2 :
10935: LD_ADDR_EXP 22
10939: PUSH
10940: LD_INT 1
10942: ST_TO_ADDR
10943: GO 10965
10945: LD_INT 2
10947: DOUBLE
10948: EQUAL
10949: IFTRUE 10953
10951: GO 10964
10953: POP
// wait_for_them := false ; end ;
10954: LD_ADDR_EXP 22
10958: PUSH
10959: LD_INT 0
10961: ST_TO_ADDR
10962: GO 10965
10964: POP
// end ; save_group := save_group ^ JMM ;
10965: LD_ADDR_EXP 20
10969: PUSH
10970: LD_EXP 20
10974: PUSH
10975: LD_EXP 31
10979: ADD
10980: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
10981: LD_EXP 31
10985: PPUSH
10986: CALL_OW 64
// end ; if i = Lisa then
10990: LD_VAR 0 1
10994: PUSH
10995: LD_EXP 34
10999: EQUAL
11000: IFFALSE 11027
// begin save_group := save_group ^ Lisa ;
11002: LD_ADDR_EXP 20
11006: PUSH
11007: LD_EXP 20
11011: PUSH
11012: LD_EXP 34
11016: ADD
11017: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11018: LD_EXP 34
11022: PPUSH
11023: CALL_OW 64
// end ; if i = Bobby then
11027: LD_VAR 0 1
11031: PUSH
11032: LD_EXP 32
11036: EQUAL
11037: IFFALSE 11064
// begin save_group := save_group ^ Bobby ;
11039: LD_ADDR_EXP 20
11043: PUSH
11044: LD_EXP 20
11048: PUSH
11049: LD_EXP 32
11053: ADD
11054: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11055: LD_EXP 32
11059: PPUSH
11060: CALL_OW 64
// end ; if i = Cyrus then
11064: LD_VAR 0 1
11068: PUSH
11069: LD_EXP 33
11073: EQUAL
11074: IFFALSE 11101
// begin save_group := save_group ^ Cyrus ;
11076: LD_ADDR_EXP 20
11080: PUSH
11081: LD_EXP 20
11085: PUSH
11086: LD_EXP 33
11090: ADD
11091: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11092: LD_EXP 33
11096: PPUSH
11097: CALL_OW 64
// end ; if i = Khatam then
11101: LD_VAR 0 1
11105: PUSH
11106: LD_EXP 35
11110: EQUAL
11111: IFFALSE 11138
// begin save_group := save_group ^ Khatam ;
11113: LD_ADDR_EXP 20
11117: PUSH
11118: LD_EXP 20
11122: PUSH
11123: LD_EXP 35
11127: ADD
11128: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11129: LD_EXP 35
11133: PPUSH
11134: CALL_OW 64
// end ; if i = Frank then
11138: LD_VAR 0 1
11142: PUSH
11143: LD_EXP 45
11147: EQUAL
11148: IFFALSE 11175
// begin save_group := save_group ^ Frank ;
11150: LD_ADDR_EXP 20
11154: PUSH
11155: LD_EXP 20
11159: PUSH
11160: LD_EXP 45
11164: ADD
11165: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11166: LD_EXP 45
11170: PPUSH
11171: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11175: LD_VAR 0 1
11179: PPUSH
11180: CALL_OW 302
11184: PUSH
11185: LD_VAR 0 1
11189: PPUSH
11190: CALL_OW 247
11194: PUSH
11195: LD_INT 1
11197: EQUAL
11198: AND
11199: PUSH
11200: LD_VAR 0 1
11204: PUSH
11205: LD_EXP 20
11209: IN
11210: NOT
11211: AND
11212: IFFALSE 11239
// begin save_others := save_others ^ i ;
11214: LD_ADDR_EXP 19
11218: PUSH
11219: LD_EXP 19
11223: PUSH
11224: LD_VAR 0 1
11228: ADD
11229: ST_TO_ADDR
// RemoveUnit ( i ) ;
11230: LD_VAR 0 1
11234: PPUSH
11235: CALL_OW 64
// end ; end ;
11239: GO 10791
11241: POP
11242: POP
// end ;
11243: PPOPN 2
11245: END
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
11246: LD_EXP 21
11250: NOT
11251: PUSH
11252: LD_EXP 22
11256: NOT
11257: AND
11258: PUSH
11259: LD_INT 22
11261: PUSH
11262: LD_INT 1
11264: PUSH
11265: EMPTY
11266: LIST
11267: LIST
11268: PUSH
11269: LD_INT 21
11271: PUSH
11272: LD_INT 1
11274: PUSH
11275: EMPTY
11276: LIST
11277: LIST
11278: PUSH
11279: EMPTY
11280: LIST
11281: LIST
11282: PPUSH
11283: CALL_OW 69
11287: PUSH
11288: LD_INT 0
11290: EQUAL
11291: OR
11292: IFFALSE 11301
11294: GO 11296
11296: DISABLE
// EndMission ;
11297: CALL 11302 0 0
11301: END
// export function EndMission ; var i ; begin
11302: LD_INT 0
11304: PPUSH
11305: PPUSH
// Wait ( 0 0$02 ) ;
11306: LD_INT 70
11308: PPUSH
11309: CALL_OW 67
// if solar_builded then
11313: LD_EXP 11
11317: IFFALSE 11331
// AddMedal ( Solar1 , 1 ) else
11319: LD_STRING Solar1
11321: PPUSH
11322: LD_INT 1
11324: PPUSH
11325: CALL_OW 101
11329: GO 11342
// AddMedal ( Solar1 , - 1 ) ;
11331: LD_STRING Solar1
11333: PPUSH
11334: LD_INT 1
11336: NEG
11337: PPUSH
11338: CALL_OW 101
// if veh_on_meta then
11342: LD_EXP 24
11346: IFFALSE 11360
// AddMedal ( Solar2 , 1 ) else
11348: LD_STRING Solar2
11350: PPUSH
11351: LD_INT 1
11353: PPUSH
11354: CALL_OW 101
11358: GO 11390
// if solar_builded then
11360: LD_EXP 11
11364: IFFALSE 11379
// AddMedal ( Solar2 , - 1 ) else
11366: LD_STRING Solar2
11368: PPUSH
11369: LD_INT 1
11371: NEG
11372: PPUSH
11373: CALL_OW 101
11377: GO 11390
// AddMedal ( Solar2 , - 2 ) ;
11379: LD_STRING Solar2
11381: PPUSH
11382: LD_INT 2
11384: NEG
11385: PPUSH
11386: CALL_OW 101
// if lose_counter = 0 then
11390: LD_EXP 30
11394: PUSH
11395: LD_INT 0
11397: EQUAL
11398: IFFALSE 11412
// AddMedal ( No , 1 ) else
11400: LD_STRING No
11402: PPUSH
11403: LD_INT 1
11405: PPUSH
11406: CALL_OW 101
11410: GO 11456
// if lose_counter > 0 and lose_counter < 4 then
11412: LD_EXP 30
11416: PUSH
11417: LD_INT 0
11419: GREATER
11420: PUSH
11421: LD_EXP 30
11425: PUSH
11426: LD_INT 4
11428: LESS
11429: AND
11430: IFFALSE 11445
// AddMedal ( No , - 1 ) else
11432: LD_STRING No
11434: PPUSH
11435: LD_INT 1
11437: NEG
11438: PPUSH
11439: CALL_OW 101
11443: GO 11456
// AddMedal ( UpTo4 , - 1 ) ;
11445: LD_STRING UpTo4
11447: PPUSH
11448: LD_INT 1
11450: NEG
11451: PPUSH
11452: CALL_OW 101
// GiveMedals ( MAIN ) ;
11456: LD_STRING MAIN
11458: PPUSH
11459: CALL_OW 102
// if IsDead ( Pokryshkin ) then
11463: LD_EXP 46
11467: PPUSH
11468: CALL_OW 301
11472: IFFALSE 11512
// for i in save_group ^ save_others do
11474: LD_ADDR_VAR 0 2
11478: PUSH
11479: LD_EXP 20
11483: PUSH
11484: LD_EXP 19
11488: ADD
11489: PUSH
11490: FOR_IN
11491: IFFALSE 11510
// AddExperience ( i , skill_combat , 1500 ) ;
11493: LD_VAR 0 2
11497: PPUSH
11498: LD_INT 1
11500: PPUSH
11501: LD_INT 1500
11503: PPUSH
11504: CALL_OW 492
11508: GO 11490
11510: POP
11511: POP
// RewardPeople ( save_group ^ save_others ) ;
11512: LD_EXP 20
11516: PUSH
11517: LD_EXP 19
11521: ADD
11522: PPUSH
11523: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
11527: LD_EXP 31
11531: PPUSH
11532: LD_STRING JMM
11534: PPUSH
11535: CALL_OW 38
// if Bobby in save_group then
11539: LD_EXP 32
11543: PUSH
11544: LD_EXP 20
11548: IN
11549: IFFALSE 11565
// SaveCharacters ( Bobby , Bobby ) else
11551: LD_EXP 32
11555: PPUSH
11556: LD_STRING Bobby
11558: PPUSH
11559: CALL_OW 38
11563: GO 11572
// DeleteCharacters ( Bobby ) ;
11565: LD_STRING Bobby
11567: PPUSH
11568: CALL_OW 40
// if Cyrus in save_group then
11572: LD_EXP 33
11576: PUSH
11577: LD_EXP 20
11581: IN
11582: IFFALSE 11598
// SaveCharacters ( Cyrus , Cyrus ) else
11584: LD_EXP 33
11588: PPUSH
11589: LD_STRING Cyrus
11591: PPUSH
11592: CALL_OW 38
11596: GO 11605
// DeleteCharacters ( Cyrus ) ;
11598: LD_STRING Cyrus
11600: PPUSH
11601: CALL_OW 40
// if Lisa in save_group then
11605: LD_EXP 34
11609: PUSH
11610: LD_EXP 20
11614: IN
11615: IFFALSE 11631
// SaveCharacters ( Lisa , Lisa ) else
11617: LD_EXP 34
11621: PPUSH
11622: LD_STRING Lisa
11624: PPUSH
11625: CALL_OW 38
11629: GO 11638
// DeleteCharacters ( Lisa ) ;
11631: LD_STRING Lisa
11633: PPUSH
11634: CALL_OW 40
// if Frank in save_group then
11638: LD_EXP 45
11642: PUSH
11643: LD_EXP 20
11647: IN
11648: IFFALSE 11664
// SaveCharacters ( Frank , Frank ) else
11650: LD_EXP 45
11654: PPUSH
11655: LD_STRING Frank
11657: PPUSH
11658: CALL_OW 38
11662: GO 11671
// DeleteCharacters ( Frank ) ;
11664: LD_STRING Frank
11666: PPUSH
11667: CALL_OW 40
// if Khatam in save_group then
11671: LD_EXP 35
11675: PUSH
11676: LD_EXP 20
11680: IN
11681: IFFALSE 11697
// SaveCharacters ( Khatam , Khatam ) else
11683: LD_EXP 35
11687: PPUSH
11688: LD_STRING Khatam
11690: PPUSH
11691: CALL_OW 38
11695: GO 11704
// DeleteCharacters ( Khatam ) ;
11697: LD_STRING Khatam
11699: PPUSH
11700: CALL_OW 40
// if save_others then
11704: LD_EXP 19
11708: IFFALSE 11722
// SaveCharacters ( save_others , 03_others ) ;
11710: LD_EXP 19
11714: PPUSH
11715: LD_STRING 03_others
11717: PPUSH
11718: CALL_OW 38
// DeleteCharacters ( Brian ) ;
11722: LD_STRING Brian
11724: PPUSH
11725: CALL_OW 40
// DeleteCharacters ( Jimmy ) ;
11729: LD_STRING Jimmy
11731: PPUSH
11732: CALL_OW 40
// if Bierezov and IsOk ( Bierezov ) then
11736: LD_EXP 39
11740: PUSH
11741: LD_EXP 39
11745: PPUSH
11746: CALL_OW 302
11750: AND
11751: IFFALSE 11763
// begin ResetFog ;
11753: CALL_OW 335
// DisplayEndingScene ;
11757: CALL 11779 0 0
// end else
11761: GO 11770
// DeleteCharacters ( Cornel ) ;
11763: LD_STRING Cornel
11765: PPUSH
11766: CALL_OW 40
// YouWin ;
11770: CALL_OW 103
// end ;
11774: LD_VAR 0 1
11778: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
11779: LD_INT 0
11781: PPUSH
11782: PPUSH
11783: PPUSH
11784: PPUSH
11785: PPUSH
11786: PPUSH
// InGameOn ;
11787: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
11791: LD_INT 208
11793: PPUSH
11794: LD_INT 62
11796: PPUSH
11797: LD_INT 1
11799: PPUSH
11800: LD_INT 10
11802: NEG
11803: PPUSH
11804: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
11808: LD_INT 208
11810: PPUSH
11811: LD_INT 62
11813: PPUSH
11814: LD_INT 1
11816: PPUSH
11817: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11821: LD_ADDR_VAR 0 3
11825: PUSH
11826: LD_INT 22
11828: PUSH
11829: LD_INT 3
11831: PUSH
11832: EMPTY
11833: LIST
11834: LIST
11835: PUSH
11836: LD_INT 2
11838: PUSH
11839: LD_INT 21
11841: PUSH
11842: LD_INT 2
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: PUSH
11849: LD_INT 21
11851: PUSH
11852: LD_INT 1
11854: PUSH
11855: EMPTY
11856: LIST
11857: LIST
11858: PUSH
11859: EMPTY
11860: LIST
11861: LIST
11862: LIST
11863: PUSH
11864: EMPTY
11865: LIST
11866: LIST
11867: PPUSH
11868: CALL_OW 69
11872: ST_TO_ADDR
// if filter then
11873: LD_VAR 0 3
11877: IFFALSE 11905
// for i in filter do
11879: LD_ADDR_VAR 0 2
11883: PUSH
11884: LD_VAR 0 3
11888: PUSH
11889: FOR_IN
11890: IFFALSE 11903
// RemoveUnit ( i ) ;
11892: LD_VAR 0 2
11896: PPUSH
11897: CALL_OW 64
11901: GO 11889
11903: POP
11904: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
11905: LD_ADDR_VAR 0 3
11909: PUSH
11910: LD_INT 22
11912: PUSH
11913: LD_INT 4
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: PUSH
11920: LD_INT 21
11922: PUSH
11923: LD_INT 1
11925: PUSH
11926: EMPTY
11927: LIST
11928: LIST
11929: PUSH
11930: EMPTY
11931: LIST
11932: LIST
11933: PPUSH
11934: CALL_OW 69
11938: ST_TO_ADDR
// if filter then
11939: LD_VAR 0 3
11943: IFFALSE 11974
// for i in filter do
11945: LD_ADDR_VAR 0 2
11949: PUSH
11950: LD_VAR 0 3
11954: PUSH
11955: FOR_IN
11956: IFFALSE 11972
// SetLives ( i , 0 ) ;
11958: LD_VAR 0 2
11962: PPUSH
11963: LD_INT 0
11965: PPUSH
11966: CALL_OW 234
11970: GO 11955
11972: POP
11973: POP
// uc_side := 4 ;
11974: LD_ADDR_OWVAR 20
11978: PUSH
11979: LD_INT 4
11981: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
11982: LD_ADDR_VAR 0 4
11986: PUSH
11987: LD_STRING Cornell
11989: PPUSH
11990: LD_INT 0
11992: PPUSH
11993: CALL 434 0 2
11997: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
11998: LD_VAR 0 4
12002: PPUSH
12003: LD_INT 208
12005: PPUSH
12006: LD_INT 62
12008: PPUSH
12009: LD_INT 0
12011: PPUSH
12012: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12016: LD_VAR 0 4
12020: PPUSH
12021: LD_INT 100
12023: PPUSH
12024: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12028: LD_INT 3
12030: PPUSH
12031: LD_VAR 0 4
12035: PPUSH
12036: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12040: LD_INT 4
12042: PPUSH
12043: LD_INT 3
12045: PPUSH
12046: LD_INT 1
12048: PPUSH
12049: LD_INT 1
12051: PPUSH
12052: CALL_OW 80
// uc_side := 3 ;
12056: LD_ADDR_OWVAR 20
12060: PUSH
12061: LD_INT 3
12063: ST_TO_ADDR
// uc_nation := 3 ;
12064: LD_ADDR_OWVAR 21
12068: PUSH
12069: LD_INT 3
12071: ST_TO_ADDR
// InitHc ;
12072: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12076: LD_ADDR_VAR 0 5
12080: PUSH
12081: LD_STRING Mikhail
12083: PPUSH
12084: LD_INT 0
12086: PPUSH
12087: CALL 434 0 2
12091: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12092: LD_INT 1
12094: PPUSH
12095: LD_INT 1
12097: PPUSH
12098: LD_INT 0
12100: PPUSH
12101: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12105: LD_ADDR_VAR 0 6
12109: PUSH
12110: LD_VAR 0 6
12114: PUSH
12115: CALL_OW 44
12119: ADD
12120: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12121: LD_ADDR_VAR 0 6
12125: PUSH
12126: LD_VAR 0 6
12130: PUSH
12131: CALL_OW 44
12135: ADD
12136: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12137: LD_INT 2
12139: PPUSH
12140: LD_INT 4
12142: PPUSH
12143: LD_INT 0
12145: PPUSH
12146: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12150: LD_ADDR_VAR 0 6
12154: PUSH
12155: LD_VAR 0 6
12159: PUSH
12160: CALL_OW 44
12164: ADD
12165: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12166: LD_VAR 0 5
12170: PPUSH
12171: LD_INT 17
12173: PPUSH
12174: LD_INT 0
12176: PPUSH
12177: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12181: LD_VAR 0 5
12185: PPUSH
12186: LD_INT 210
12188: PPUSH
12189: LD_INT 63
12191: PPUSH
12192: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12196: LD_VAR 0 5
12200: PPUSH
12201: LD_INT 208
12203: PPUSH
12204: LD_INT 62
12206: PPUSH
12207: CALL_OW 178
// for i in fake_russians do
12211: LD_ADDR_VAR 0 2
12215: PUSH
12216: LD_VAR 0 6
12220: PUSH
12221: FOR_IN
12222: IFFALSE 12300
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12224: LD_VAR 0 2
12228: PPUSH
12229: LD_INT 17
12231: PPUSH
12232: LD_INT 0
12234: PPUSH
12235: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
12239: LD_VAR 0 2
12243: PPUSH
12244: LD_INT 215
12246: PPUSH
12247: LD_INT 67
12249: PPUSH
12250: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
12254: LD_VAR 0 2
12258: PPUSH
12259: LD_INT 208
12261: PPUSH
12262: LD_INT 62
12264: PPUSH
12265: CALL_OW 178
// if GetClass ( i ) = 4 then
12269: LD_VAR 0 2
12273: PPUSH
12274: CALL_OW 257
12278: PUSH
12279: LD_INT 4
12281: EQUAL
12282: IFFALSE 12298
// ComHeal ( i , fake_cornel ) ;
12284: LD_VAR 0 2
12288: PPUSH
12289: LD_VAR 0 4
12293: PPUSH
12294: CALL_OW 128
// end ;
12298: GO 12221
12300: POP
12301: POP
// Wait ( 0 0$01 ) ;
12302: LD_INT 35
12304: PPUSH
12305: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
12309: LD_INT 208
12311: PPUSH
12312: LD_INT 62
12314: PPUSH
12315: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12319: LD_INT 208
12321: PPUSH
12322: LD_INT 62
12324: PPUSH
12325: LD_INT 1
12327: PPUSH
12328: LD_INT 10
12330: NEG
12331: PPUSH
12332: CALL_OW 330
// Wait ( 0 0$15 ) ;
12336: LD_INT 525
12338: PPUSH
12339: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
12343: LD_INT 208
12345: PPUSH
12346: LD_INT 62
12348: PPUSH
12349: LD_INT 1
12351: PPUSH
12352: CALL_OW 331
// ResetFog ;
12356: CALL_OW 335
// InGameOff ;
12360: CALL_OW 9
// end ;
12364: LD_VAR 0 1
12368: RET
// every 0 0$30 trigger GetDistUnits ( JMM , Cornel ) < 3 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) do
12369: LD_EXP 31
12373: PPUSH
12374: LD_EXP 38
12378: PPUSH
12379: CALL_OW 296
12383: PUSH
12384: LD_INT 3
12386: LESS
12387: PUSH
12388: LD_INT 22
12390: PUSH
12391: LD_INT 4
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PUSH
12398: LD_INT 21
12400: PUSH
12401: LD_INT 3
12403: PUSH
12404: EMPTY
12405: LIST
12406: LIST
12407: PUSH
12408: EMPTY
12409: LIST
12410: LIST
12411: PPUSH
12412: CALL_OW 69
12416: AND
12417: IFFALSE 12435
12419: GO 12421
12421: DISABLE
// begin enable ;
12422: ENABLE
// SayRadio ( Powell , DWarn-Pow-1 ) ;
12423: LD_EXP 40
12427: PPUSH
12428: LD_STRING DWarn-Pow-1
12430: PPUSH
12431: CALL_OW 94
// end ; end_of_file
12435: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
12436: LD_EXP 6
12440: IFFALSE 13675
12442: GO 12444
12444: DISABLE
12445: LD_INT 0
12447: PPUSH
12448: PPUSH
12449: PPUSH
12450: PPUSH
12451: PPUSH
12452: PPUSH
12453: PPUSH
12454: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
12455: LD_EXP 38
12459: PUSH
12460: LD_EXP 39
12464: ADD
12465: PUSH
12466: LD_EXP 4
12470: ADD
12471: PPUSH
12472: LD_INT 250
12474: PPUSH
12475: LD_INT 120
12477: PPUSH
12478: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) diff [ Bierezov ] ;
12482: LD_ADDR_VAR 0 2
12486: PUSH
12487: LD_EXP 4
12491: PPUSH
12492: LD_INT 25
12494: PUSH
12495: LD_INT 2
12497: PUSH
12498: EMPTY
12499: LIST
12500: LIST
12501: PPUSH
12502: CALL_OW 72
12506: PUSH
12507: LD_EXP 39
12511: PUSH
12512: EMPTY
12513: LIST
12514: DIFF
12515: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
12516: LD_ADDR_VAR 0 3
12520: PUSH
12521: LD_EXP 4
12525: PPUSH
12526: LD_INT 21
12528: PUSH
12529: LD_INT 1
12531: PUSH
12532: EMPTY
12533: LIST
12534: LIST
12535: PPUSH
12536: CALL_OW 72
12540: ST_TO_ADDR
// if not has_eng then
12541: LD_VAR 0 2
12545: NOT
12546: IFFALSE 12629
// begin uc_side := 4 ;
12548: LD_ADDR_OWVAR 20
12552: PUSH
12553: LD_INT 4
12555: ST_TO_ADDR
// uc_nation := 1 ;
12556: LD_ADDR_OWVAR 21
12560: PUSH
12561: LD_INT 1
12563: ST_TO_ADDR
// bc_type := b_depot ;
12564: LD_ADDR_OWVAR 42
12568: PUSH
12569: LD_INT 0
12571: ST_TO_ADDR
// bc_level := 2 ;
12572: LD_ADDR_OWVAR 43
12576: PUSH
12577: LD_INT 2
12579: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
12580: LD_ADDR_VAR 0 4
12584: PUSH
12585: LD_INT 264
12587: PPUSH
12588: LD_INT 120
12590: PPUSH
12591: LD_INT 4
12593: PPUSH
12594: CALL_OW 47
12598: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
12599: LD_INT 264
12601: PPUSH
12602: LD_INT 120
12604: PPUSH
12605: LD_INT 4
12607: PPUSH
12608: LD_INT 10
12610: NEG
12611: PPUSH
12612: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
12616: LD_INT 264
12618: PPUSH
12619: LD_INT 120
12621: PPUSH
12622: LD_INT 4
12624: PPUSH
12625: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
12629: LD_INT 35
12631: PPUSH
12632: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
12636: LD_EXP 38
12640: PPUSH
12641: LD_INT 10
12643: PPUSH
12644: CALL_OW 308
12648: IFFALSE 12629
// if has_eng and not dep then
12650: LD_VAR 0 2
12654: PUSH
12655: LD_VAR 0 4
12659: NOT
12660: AND
12661: IFFALSE 12775
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
12663: LD_VAR 0 2
12667: PPUSH
12668: LD_INT 0
12670: PPUSH
12671: LD_INT 264
12673: PPUSH
12674: LD_INT 120
12676: PPUSH
12677: LD_INT 4
12679: PPUSH
12680: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
12684: LD_INT 35
12686: PPUSH
12687: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
12691: LD_INT 22
12693: PUSH
12694: LD_INT 4
12696: PUSH
12697: EMPTY
12698: LIST
12699: LIST
12700: PUSH
12701: LD_INT 30
12703: PUSH
12704: LD_INT 0
12706: PUSH
12707: EMPTY
12708: LIST
12709: LIST
12710: PUSH
12711: LD_INT 3
12713: PUSH
12714: LD_INT 57
12716: PUSH
12717: EMPTY
12718: LIST
12719: PUSH
12720: EMPTY
12721: LIST
12722: LIST
12723: PUSH
12724: EMPTY
12725: LIST
12726: LIST
12727: LIST
12728: PPUSH
12729: CALL_OW 69
12733: IFFALSE 12684
// dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
12735: LD_ADDR_VAR 0 4
12739: PUSH
12740: LD_INT 22
12742: PUSH
12743: LD_INT 4
12745: PUSH
12746: EMPTY
12747: LIST
12748: LIST
12749: PUSH
12750: LD_INT 30
12752: PUSH
12753: LD_INT 0
12755: PUSH
12756: EMPTY
12757: LIST
12758: LIST
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PPUSH
12764: CALL_OW 69
12768: PUSH
12769: LD_INT 1
12771: ARRAY
12772: ST_TO_ADDR
// end else
12773: GO 12892
// begin SetSide ( dep , 4 ) ;
12775: LD_VAR 0 4
12779: PPUSH
12780: LD_INT 4
12782: PPUSH
12783: CALL_OW 235
// for i = 1 to 3 do
12787: LD_ADDR_VAR 0 1
12791: PUSH
12792: DOUBLE
12793: LD_INT 1
12795: DEC
12796: ST_TO_ADDR
12797: LD_INT 3
12799: PUSH
12800: FOR_TO
12801: IFFALSE 12858
// begin ComEnterUnit ( filter [ i ] , dep ) ;
12803: LD_VAR 0 3
12807: PUSH
12808: LD_VAR 0 1
12812: ARRAY
12813: PPUSH
12814: LD_VAR 0 4
12818: PPUSH
12819: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
12823: LD_VAR 0 3
12827: PUSH
12828: LD_VAR 0 1
12832: ARRAY
12833: PPUSH
12834: LD_INT 2
12836: PPUSH
12837: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
12841: LD_VAR 0 3
12845: PUSH
12846: LD_VAR 0 1
12850: ARRAY
12851: PPUSH
12852: CALL_OW 182
// end ;
12856: GO 12800
12858: POP
12859: POP
// repeat wait ( 0 0$01 ) ;
12860: LD_INT 35
12862: PPUSH
12863: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
12867: LD_VAR 0 3
12871: PPUSH
12872: LD_INT 25
12874: PUSH
12875: LD_INT 2
12877: PUSH
12878: EMPTY
12879: LIST
12880: LIST
12881: PPUSH
12882: CALL_OW 72
12886: PUSH
12887: LD_INT 3
12889: EQUAL
12890: IFFALSE 12860
// end ; if IsInUnit ( Cornel ) then
12892: LD_EXP 38
12896: PPUSH
12897: CALL_OW 310
12901: IFFALSE 12984
// begin cargo := IsInUnit ( Cornel ) ;
12903: LD_ADDR_VAR 0 7
12907: PUSH
12908: LD_EXP 38
12912: PPUSH
12913: CALL_OW 310
12917: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
12918: LD_VAR 0 7
12922: PPUSH
12923: LD_INT 1
12925: PPUSH
12926: CALL_OW 289
12930: IFFALSE 12946
// ComGive ( Cornel , dep ) ;
12932: LD_EXP 38
12936: PPUSH
12937: LD_VAR 0 4
12941: PPUSH
12942: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
12946: LD_EXP 38
12950: PPUSH
12951: LD_INT 235
12953: PPUSH
12954: LD_INT 122
12956: PPUSH
12957: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
12961: LD_EXP 38
12965: PPUSH
12966: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
12970: LD_EXP 38
12974: PPUSH
12975: LD_VAR 0 4
12979: PPUSH
12980: CALL_OW 180
// end ; ComEnterUnit ( Bierezov , dep ) ;
12984: LD_EXP 39
12988: PPUSH
12989: LD_VAR 0 4
12993: PPUSH
12994: CALL_OW 120
// has_eng := UnitFilter ( filter , [ f_class , 2 ] ) ;
12998: LD_ADDR_VAR 0 2
13002: PUSH
13003: LD_VAR 0 3
13007: PPUSH
13008: LD_INT 25
13010: PUSH
13011: LD_INT 2
13013: PUSH
13014: EMPTY
13015: LIST
13016: LIST
13017: PPUSH
13018: CALL_OW 72
13022: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13023: LD_INT 35
13025: PPUSH
13026: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13030: LD_ADDR_VAR 0 6
13034: PUSH
13035: LD_INT 10
13037: PPUSH
13038: CALL_OW 435
13042: ST_TO_ADDR
// if crates then
13043: LD_VAR 0 6
13047: IFFALSE 13076
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
13049: LD_VAR 0 2
13053: PPUSH
13054: LD_VAR 0 6
13058: PUSH
13059: LD_INT 1
13061: ARRAY
13062: PPUSH
13063: LD_VAR 0 6
13067: PUSH
13068: LD_INT 2
13070: ARRAY
13071: PPUSH
13072: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
13076: LD_VAR 0 4
13080: PPUSH
13081: CALL_OW 274
13085: PPUSH
13086: LD_INT 1
13088: PPUSH
13089: CALL_OW 275
13093: PUSH
13094: LD_INT 40
13096: GREATEREQUAL
13097: IFFALSE 13023
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
13099: LD_ADDR_VAR 0 5
13103: PUSH
13104: LD_INT 4
13106: PUSH
13107: LD_INT 256
13109: PUSH
13110: LD_INT 111
13112: PUSH
13113: LD_INT 2
13115: PUSH
13116: EMPTY
13117: LIST
13118: LIST
13119: LIST
13120: LIST
13121: PUSH
13122: LD_INT 31
13124: PUSH
13125: LD_INT 243
13127: PUSH
13128: LD_INT 112
13130: PUSH
13131: LD_INT 2
13133: PUSH
13134: EMPTY
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: PUSH
13140: EMPTY
13141: LIST
13142: LIST
13143: ST_TO_ADDR
// for i in blist do
13144: LD_ADDR_VAR 0 1
13148: PUSH
13149: LD_VAR 0 5
13153: PUSH
13154: FOR_IN
13155: IFFALSE 13204
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
13157: LD_VAR 0 2
13161: PPUSH
13162: LD_VAR 0 1
13166: PUSH
13167: LD_INT 1
13169: ARRAY
13170: PPUSH
13171: LD_VAR 0 1
13175: PUSH
13176: LD_INT 2
13178: ARRAY
13179: PPUSH
13180: LD_VAR 0 1
13184: PUSH
13185: LD_INT 3
13187: ARRAY
13188: PPUSH
13189: LD_VAR 0 1
13193: PUSH
13194: LD_INT 4
13196: ARRAY
13197: PPUSH
13198: CALL_OW 205
13202: GO 13154
13204: POP
13205: POP
// repeat wait ( 0 0$01 ) ;
13206: LD_INT 35
13208: PPUSH
13209: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
13213: LD_INT 22
13215: PUSH
13216: LD_INT 4
13218: PUSH
13219: EMPTY
13220: LIST
13221: LIST
13222: PUSH
13223: LD_INT 30
13225: PUSH
13226: LD_INT 4
13228: PUSH
13229: EMPTY
13230: LIST
13231: LIST
13232: PUSH
13233: LD_INT 3
13235: PUSH
13236: LD_INT 57
13238: PUSH
13239: EMPTY
13240: LIST
13241: PUSH
13242: EMPTY
13243: LIST
13244: LIST
13245: PUSH
13246: EMPTY
13247: LIST
13248: LIST
13249: LIST
13250: PPUSH
13251: CALL_OW 69
13255: IFFALSE 13206
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
13257: LD_VAR 0 3
13261: PUSH
13262: LD_VAR 0 2
13266: DIFF
13267: PPUSH
13268: LD_INT 22
13270: PUSH
13271: LD_INT 4
13273: PUSH
13274: EMPTY
13275: LIST
13276: LIST
13277: PUSH
13278: LD_INT 30
13280: PUSH
13281: LD_INT 4
13283: PUSH
13284: EMPTY
13285: LIST
13286: LIST
13287: PUSH
13288: EMPTY
13289: LIST
13290: LIST
13291: PPUSH
13292: CALL_OW 69
13296: PUSH
13297: LD_INT 1
13299: ARRAY
13300: PPUSH
13301: CALL_OW 180
// repeat wait ( 0 0$01 ) ;
13305: LD_INT 35
13307: PPUSH
13308: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
13312: LD_INT 22
13314: PUSH
13315: LD_INT 4
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PUSH
13322: LD_INT 30
13324: PUSH
13325: LD_INT 31
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: PUSH
13332: LD_INT 3
13334: PUSH
13335: LD_INT 57
13337: PUSH
13338: EMPTY
13339: LIST
13340: PUSH
13341: EMPTY
13342: LIST
13343: LIST
13344: PUSH
13345: EMPTY
13346: LIST
13347: LIST
13348: LIST
13349: PPUSH
13350: CALL_OW 69
13354: IFFALSE 13305
// sol := filter diff has_eng ;
13356: LD_ADDR_VAR 0 8
13360: PUSH
13361: LD_VAR 0 3
13365: PUSH
13366: LD_VAR 0 2
13370: DIFF
13371: ST_TO_ADDR
// if GetClass ( sol [ 1 ] ) > 1 then
13372: LD_VAR 0 8
13376: PUSH
13377: LD_INT 1
13379: ARRAY
13380: PPUSH
13381: CALL_OW 257
13385: PUSH
13386: LD_INT 1
13388: GREATER
13389: IFFALSE 13407
// SetClass ( sol [ 1 ] , 1 ) ;
13391: LD_VAR 0 8
13395: PUSH
13396: LD_INT 1
13398: ARRAY
13399: PPUSH
13400: LD_INT 1
13402: PPUSH
13403: CALL_OW 336
// ComExitBuilding ( sol [ 1 ] ) ;
13407: LD_VAR 0 8
13411: PUSH
13412: LD_INT 1
13414: ARRAY
13415: PPUSH
13416: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
13420: LD_VAR 0 8
13424: PUSH
13425: LD_INT 1
13427: ARRAY
13428: PPUSH
13429: LD_INT 22
13431: PUSH
13432: LD_INT 4
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: PUSH
13439: LD_INT 30
13441: PUSH
13442: LD_INT 31
13444: PUSH
13445: EMPTY
13446: LIST
13447: LIST
13448: PUSH
13449: EMPTY
13450: LIST
13451: LIST
13452: PPUSH
13453: CALL_OW 69
13457: PUSH
13458: LD_INT 1
13460: ARRAY
13461: PPUSH
13462: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
13466: LD_VAR 0 2
13470: PPUSH
13471: LD_VAR 0 4
13475: PPUSH
13476: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
13480: LD_INT 35
13482: PPUSH
13483: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13487: LD_ADDR_VAR 0 3
13491: PUSH
13492: LD_INT 22
13494: PUSH
13495: LD_INT 4
13497: PUSH
13498: EMPTY
13499: LIST
13500: LIST
13501: PUSH
13502: LD_INT 21
13504: PUSH
13505: LD_INT 3
13507: PUSH
13508: EMPTY
13509: LIST
13510: LIST
13511: PUSH
13512: LD_INT 3
13514: PUSH
13515: LD_INT 24
13517: PUSH
13518: LD_INT 1000
13520: PUSH
13521: EMPTY
13522: LIST
13523: LIST
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: PUSH
13529: EMPTY
13530: LIST
13531: LIST
13532: LIST
13533: PPUSH
13534: CALL_OW 69
13538: ST_TO_ADDR
// if filter and has_eng then
13539: LD_VAR 0 3
13543: PUSH
13544: LD_VAR 0 2
13548: AND
13549: IFFALSE 13615
// begin for i in has_eng do
13551: LD_ADDR_VAR 0 1
13555: PUSH
13556: LD_VAR 0 2
13560: PUSH
13561: FOR_IN
13562: IFFALSE 13611
// begin if IsInUnit ( i ) then
13564: LD_VAR 0 1
13568: PPUSH
13569: CALL_OW 310
13573: IFFALSE 13584
// ComExitBuilding ( i ) ;
13575: LD_VAR 0 1
13579: PPUSH
13580: CALL_OW 122
// Wait ( 3 ) ;
13584: LD_INT 3
13586: PPUSH
13587: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
13591: LD_VAR 0 1
13595: PPUSH
13596: LD_VAR 0 3
13600: PUSH
13601: LD_INT 1
13603: ARRAY
13604: PPUSH
13605: CALL_OW 130
// end ;
13609: GO 13561
13611: POP
13612: POP
// end else
13613: GO 13669
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
13615: LD_VAR 0 2
13619: PUSH
13620: LD_VAR 0 2
13624: PPUSH
13625: LD_INT 56
13627: PUSH
13628: EMPTY
13629: LIST
13630: PPUSH
13631: CALL_OW 72
13635: AND
13636: IFFALSE 13669
// for i in has_eng do
13638: LD_ADDR_VAR 0 1
13642: PUSH
13643: LD_VAR 0 2
13647: PUSH
13648: FOR_IN
13649: IFFALSE 13667
// ComEnterUnit ( i , dep ) ;
13651: LD_VAR 0 1
13655: PPUSH
13656: LD_VAR 0 4
13660: PPUSH
13661: CALL_OW 120
13665: GO 13648
13667: POP
13668: POP
// until cornel_prepared ;
13669: LD_EXP 9
13673: IFFALSE 13480
// end ;
13675: PPOPN 8
13677: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
13678: LD_EXP 9
13682: IFFALSE 14031
13684: GO 13686
13686: DISABLE
13687: LD_INT 0
13689: PPUSH
13690: PPUSH
13691: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
13692: LD_ADDR_VAR 0 2
13696: PUSH
13697: LD_INT 22
13699: PUSH
13700: LD_INT 4
13702: PUSH
13703: EMPTY
13704: LIST
13705: LIST
13706: PUSH
13707: LD_INT 30
13709: PUSH
13710: LD_INT 4
13712: PUSH
13713: EMPTY
13714: LIST
13715: LIST
13716: PUSH
13717: EMPTY
13718: LIST
13719: LIST
13720: PPUSH
13721: CALL_OW 69
13725: PUSH
13726: LD_INT 1
13728: ARRAY
13729: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
13730: LD_EXP 4
13734: PPUSH
13735: CALL_OW 122
// Wait ( 0 0$03 ) ;
13739: LD_INT 105
13741: PPUSH
13742: CALL_OW 67
// for i in cornel_units do
13746: LD_ADDR_VAR 0 1
13750: PUSH
13751: LD_EXP 4
13755: PUSH
13756: FOR_IN
13757: IFFALSE 13833
// begin if GetClass ( i ) in [ 2 , 3 ] then
13759: LD_VAR 0 1
13763: PPUSH
13764: CALL_OW 257
13768: PUSH
13769: LD_INT 2
13771: PUSH
13772: LD_INT 3
13774: PUSH
13775: EMPTY
13776: LIST
13777: LIST
13778: IN
13779: IFFALSE 13816
// begin ComEnterUnit ( i , arm ) ;
13781: LD_VAR 0 1
13785: PPUSH
13786: LD_VAR 0 2
13790: PPUSH
13791: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
13795: LD_VAR 0 1
13799: PPUSH
13800: LD_INT 1
13802: PPUSH
13803: CALL_OW 183
// AddComExitBuilding ( i ) ;
13807: LD_VAR 0 1
13811: PPUSH
13812: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
13816: LD_VAR 0 1
13820: PPUSH
13821: LD_INT 257
13823: PPUSH
13824: LD_INT 121
13826: PPUSH
13827: CALL_OW 171
// end ;
13831: GO 13756
13833: POP
13834: POP
// Wait ( 1 1$00 ) ;
13835: LD_INT 2100
13837: PPUSH
13838: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
13842: LD_ADDR_VAR 0 3
13846: PUSH
13847: LD_EXP 38
13851: PUSH
13852: LD_EXP 39
13856: ADD
13857: PUSH
13858: LD_EXP 4
13862: ADD
13863: PUSH
13864: LD_EXP 4
13868: PPUSH
13869: LD_INT 21
13871: PUSH
13872: LD_INT 2
13874: PUSH
13875: EMPTY
13876: LIST
13877: LIST
13878: PPUSH
13879: CALL_OW 72
13883: DIFF
13884: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
13885: LD_VAR 0 3
13889: PPUSH
13890: LD_INT 248
13892: PPUSH
13893: LD_INT 85
13895: PPUSH
13896: CALL_OW 111
// AddComHold ( filter ) ;
13900: LD_VAR 0 3
13904: PPUSH
13905: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
13909: LD_INT 35
13911: PPUSH
13912: CALL_OW 67
// until cornel_attack ;
13916: LD_EXP 7
13920: IFFALSE 13909
// ComAgressiveMove ( filter , 209 , 63 ) ;
13922: LD_VAR 0 3
13926: PPUSH
13927: LD_INT 209
13929: PPUSH
13930: LD_INT 63
13932: PPUSH
13933: CALL_OW 114
// if Bierezov then
13937: LD_EXP 39
13941: IFFALSE 14031
// begin filter := filter diff Bierezov ;
13943: LD_ADDR_VAR 0 3
13947: PUSH
13948: LD_VAR 0 3
13952: PUSH
13953: LD_EXP 39
13957: DIFF
13958: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
13959: LD_EXP 39
13963: PPUSH
13964: LD_INT 6
13966: PPUSH
13967: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
13971: LD_EXP 39
13975: PPUSH
13976: LD_INT 235
13978: PPUSH
13979: LD_INT 60
13981: PPUSH
13982: CALL_OW 111
// AddComHold ( Bierezov ) ;
13986: LD_EXP 39
13990: PPUSH
13991: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
13995: LD_EXP 39
13999: PPUSH
14000: LD_INT 350
14002: PPUSH
14003: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
14007: LD_EXP 39
14011: PPUSH
14012: LD_INT 198
14014: PPUSH
14015: LD_INT 28
14017: PPUSH
14018: CALL_OW 171
// AddComHold ( Bierezov ) ;
14022: LD_EXP 39
14026: PPUSH
14027: CALL_OW 200
// end ; end ; end_of_file
14031: PPOPN 3
14033: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
14034: LD_EXP 47
14038: PUSH
14039: LD_EXP 27
14043: NOT
14044: AND
14045: PUSH
14046: LD_EXP 28
14050: NOT
14051: AND
14052: IFFALSE 14502
14054: GO 14056
14056: DISABLE
14057: LD_INT 0
14059: PPUSH
14060: PPUSH
14061: PPUSH
14062: PPUSH
// begin enable ;
14063: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14064: LD_ADDR_VAR 0 4
14068: PUSH
14069: LD_INT 81
14071: PUSH
14072: LD_INT 3
14074: PUSH
14075: EMPTY
14076: LIST
14077: LIST
14078: PPUSH
14079: CALL_OW 69
14083: ST_TO_ADDR
// for i = 1 to ru_patrol do
14084: LD_ADDR_VAR 0 2
14088: PUSH
14089: DOUBLE
14090: LD_INT 1
14092: DEC
14093: ST_TO_ADDR
14094: LD_EXP 47
14098: PUSH
14099: FOR_TO
14100: IFFALSE 14500
// begin un := ru_patrol [ i ] ;
14102: LD_ADDR_VAR 0 1
14106: PUSH
14107: LD_EXP 47
14111: PUSH
14112: LD_VAR 0 2
14116: ARRAY
14117: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14118: LD_VAR 0 1
14122: PPUSH
14123: LD_INT 13
14125: PPUSH
14126: CALL_OW 308
14130: IFFALSE 14235
// begin if not ru_alert then
14132: LD_EXP 54
14136: NOT
14137: IFFALSE 14147
// ru_alert := true ;
14139: LD_ADDR_EXP 54
14143: PUSH
14144: LD_INT 1
14146: ST_TO_ADDR
// if not See ( 1 , un ) then
14147: LD_INT 1
14149: PPUSH
14150: LD_VAR 0 1
14154: PPUSH
14155: CALL_OW 292
14159: NOT
14160: IFFALSE 14174
// SetLives ( un , 1000 ) ;
14162: LD_VAR 0 1
14166: PPUSH
14167: LD_INT 1000
14169: PPUSH
14170: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
14174: LD_ADDR_EXP 47
14178: PUSH
14179: LD_EXP 47
14183: PUSH
14184: LD_VAR 0 1
14188: DIFF
14189: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
14190: LD_VAR 0 1
14194: PPUSH
14195: LD_INT 22
14197: PUSH
14198: LD_INT 3
14200: PUSH
14201: EMPTY
14202: LIST
14203: LIST
14204: PUSH
14205: LD_INT 30
14207: PUSH
14208: LD_INT 4
14210: PUSH
14211: EMPTY
14212: LIST
14213: LIST
14214: PUSH
14215: EMPTY
14216: LIST
14217: LIST
14218: PPUSH
14219: CALL_OW 69
14223: PPUSH
14224: CALL 1001 0 1
14228: PPUSH
14229: CALL_OW 120
// continue ;
14233: GO 14099
// end ; if IsOk ( un ) and not HasTask ( un ) then
14235: LD_VAR 0 1
14239: PPUSH
14240: CALL_OW 302
14244: PUSH
14245: LD_VAR 0 1
14249: PPUSH
14250: CALL_OW 314
14254: NOT
14255: AND
14256: IFFALSE 14349
// begin for j = 1 to ru_firepoints_south [ i ] do
14258: LD_ADDR_VAR 0 3
14262: PUSH
14263: DOUBLE
14264: LD_INT 1
14266: DEC
14267: ST_TO_ADDR
14268: LD_EXP 53
14272: PUSH
14273: LD_VAR 0 2
14277: ARRAY
14278: PUSH
14279: FOR_TO
14280: IFFALSE 14347
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
14282: LD_VAR 0 1
14286: PPUSH
14287: LD_EXP 53
14291: PUSH
14292: LD_VAR 0 2
14296: ARRAY
14297: PUSH
14298: LD_VAR 0 3
14302: ARRAY
14303: PUSH
14304: LD_INT 1
14306: ARRAY
14307: PPUSH
14308: LD_EXP 53
14312: PUSH
14313: LD_VAR 0 2
14317: ARRAY
14318: PUSH
14319: LD_VAR 0 3
14323: ARRAY
14324: PUSH
14325: LD_INT 2
14327: ARRAY
14328: PPUSH
14329: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
14333: LD_VAR 0 1
14337: PPUSH
14338: LD_INT 70
14340: PPUSH
14341: CALL_OW 202
// end ;
14345: GO 14279
14347: POP
14348: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
14349: LD_VAR 0 1
14353: PPUSH
14354: CALL_OW 256
14358: PUSH
14359: LD_INT 700
14361: LESS
14362: PUSH
14363: LD_VAR 0 1
14367: PPUSH
14368: LD_INT 13
14370: PPUSH
14371: CALL_OW 308
14375: NOT
14376: AND
14377: IFFALSE 14429
// begin ComMoveToArea ( un , retreatArea ) ;
14379: LD_VAR 0 1
14383: PPUSH
14384: LD_INT 13
14386: PPUSH
14387: CALL_OW 113
// if not ru_alert_xy then
14391: LD_EXP 55
14395: NOT
14396: IFFALSE 14427
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
14398: LD_ADDR_EXP 55
14402: PUSH
14403: LD_VAR 0 1
14407: PPUSH
14408: CALL_OW 250
14412: PUSH
14413: LD_VAR 0 1
14417: PPUSH
14418: CALL_OW 251
14422: PUSH
14423: EMPTY
14424: LIST
14425: LIST
14426: ST_TO_ADDR
// end else
14427: GO 14498
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
14429: LD_VAR 0 1
14433: PPUSH
14434: LD_VAR 0 4
14438: PPUSH
14439: LD_VAR 0 1
14443: PPUSH
14444: CALL_OW 74
14448: PPUSH
14449: CALL_OW 296
14453: PUSH
14454: LD_INT 9
14456: LESS
14457: PUSH
14458: LD_VAR 0 1
14462: PPUSH
14463: CALL_OW 256
14467: PUSH
14468: LD_INT 500
14470: GREATER
14471: AND
14472: IFFALSE 14498
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
14474: LD_VAR 0 1
14478: PPUSH
14479: LD_VAR 0 4
14483: PPUSH
14484: LD_VAR 0 1
14488: PPUSH
14489: CALL_OW 74
14493: PPUSH
14494: CALL_OW 115
// end ;
14498: GO 14099
14500: POP
14501: POP
// end ;
14502: PPOPN 4
14504: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
14505: LD_EXP 54
14509: PUSH
14510: LD_EXP 55
14514: AND
14515: PUSH
14516: LD_EXP 27
14520: NOT
14521: AND
14522: PUSH
14523: LD_EXP 28
14527: NOT
14528: AND
14529: IFFALSE 14739
14531: GO 14533
14533: DISABLE
14534: LD_INT 0
14536: PPUSH
14537: PPUSH
// begin enable ;
14538: ENABLE
// if not ru_vehicles then
14539: LD_EXP 50
14543: NOT
14544: IFFALSE 14548
// exit ;
14546: GO 14739
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14548: LD_ADDR_VAR 0 2
14552: PUSH
14553: LD_INT 81
14555: PUSH
14556: LD_INT 3
14558: PUSH
14559: EMPTY
14560: LIST
14561: LIST
14562: PPUSH
14563: CALL_OW 69
14567: ST_TO_ADDR
// if ru_vehicles then
14568: LD_EXP 50
14572: IFFALSE 14739
// begin for i in ru_vehicles do
14574: LD_ADDR_VAR 0 1
14578: PUSH
14579: LD_EXP 50
14583: PUSH
14584: FOR_IN
14585: IFFALSE 14737
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
14587: LD_VAR 0 1
14591: PPUSH
14592: CALL_OW 302
14596: PUSH
14597: LD_VAR 0 1
14601: PPUSH
14602: LD_VAR 0 2
14606: PPUSH
14607: LD_VAR 0 1
14611: PPUSH
14612: CALL_OW 74
14616: PPUSH
14617: CALL_OW 296
14621: PUSH
14622: LD_INT 9
14624: LESS
14625: AND
14626: IFFALSE 14652
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
14628: LD_VAR 0 1
14632: PPUSH
14633: LD_VAR 0 2
14637: PPUSH
14638: LD_VAR 0 1
14642: PPUSH
14643: CALL_OW 74
14647: PPUSH
14648: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
14652: LD_VAR 0 1
14656: PPUSH
14657: CALL_OW 314
14661: NOT
14662: PUSH
14663: LD_VAR 0 1
14667: PPUSH
14668: CALL_OW 302
14672: AND
14673: PUSH
14674: LD_VAR 0 1
14678: PPUSH
14679: LD_EXP 55
14683: PUSH
14684: LD_INT 1
14686: ARRAY
14687: PPUSH
14688: LD_EXP 55
14692: PUSH
14693: LD_INT 2
14695: ARRAY
14696: PPUSH
14697: CALL_OW 297
14701: PUSH
14702: LD_INT 10
14704: GREATER
14705: AND
14706: IFFALSE 14735
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
14708: LD_VAR 0 1
14712: PPUSH
14713: LD_EXP 55
14717: PUSH
14718: LD_INT 1
14720: ARRAY
14721: PPUSH
14722: LD_EXP 55
14726: PUSH
14727: LD_INT 2
14729: ARRAY
14730: PPUSH
14731: CALL_OW 114
// end ;
14735: GO 14584
14737: POP
14738: POP
// end ; end ;
14739: PPOPN 2
14741: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
14742: LD_EXP 55
14746: PUSH
14747: LD_EXP 54
14751: AND
14752: PUSH
14753: LD_INT 3
14755: PPUSH
14756: CALL_OW 463
14760: NOT
14761: AND
14762: PUSH
14763: LD_EXP 27
14767: NOT
14768: AND
14769: PUSH
14770: LD_EXP 28
14774: NOT
14775: AND
14776: IFFALSE 14871
14778: GO 14780
14780: DISABLE
14781: LD_INT 0
14783: PPUSH
// begin enable ;
14784: ENABLE
// ru_alert_xy := false ;
14785: LD_ADDR_EXP 55
14789: PUSH
14790: LD_INT 0
14792: ST_TO_ADDR
// ru_alert := false ;
14793: LD_ADDR_EXP 54
14797: PUSH
14798: LD_INT 0
14800: ST_TO_ADDR
// if ru_vehicles then
14801: LD_EXP 50
14805: IFFALSE 14871
// for i in ru_vehicles do
14807: LD_ADDR_VAR 0 1
14811: PUSH
14812: LD_EXP 50
14816: PUSH
14817: FOR_IN
14818: IFFALSE 14869
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
14820: LD_VAR 0 1
14824: PPUSH
14825: CALL_OW 302
14829: PUSH
14830: LD_VAR 0 1
14834: PPUSH
14835: LD_INT 89
14837: PPUSH
14838: LD_INT 36
14840: PPUSH
14841: CALL_OW 297
14845: PUSH
14846: LD_INT 10
14848: GREATER
14849: AND
14850: IFFALSE 14867
// ComMoveXY ( i , 89 , 36 ) ;
14852: LD_VAR 0 1
14856: PPUSH
14857: LD_INT 89
14859: PPUSH
14860: LD_INT 36
14862: PPUSH
14863: CALL_OW 111
14867: GO 14817
14869: POP
14870: POP
// end ;
14871: PPOPN 1
14873: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
14874: LD_EXP 49
14878: PUSH
14879: LD_EXP 27
14883: NOT
14884: AND
14885: PUSH
14886: LD_EXP 28
14890: NOT
14891: AND
14892: IFFALSE 15176
14894: GO 14896
14896: DISABLE
14897: LD_INT 0
14899: PPUSH
14900: PPUSH
14901: PPUSH
// begin enable ;
14902: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14903: LD_ADDR_VAR 0 3
14907: PUSH
14908: LD_INT 81
14910: PUSH
14911: LD_INT 3
14913: PUSH
14914: EMPTY
14915: LIST
14916: LIST
14917: PPUSH
14918: CALL_OW 69
14922: ST_TO_ADDR
// for i = 1 to ru_forest do
14923: LD_ADDR_VAR 0 1
14927: PUSH
14928: DOUBLE
14929: LD_INT 1
14931: DEC
14932: ST_TO_ADDR
14933: LD_EXP 49
14937: PUSH
14938: FOR_TO
14939: IFFALSE 15174
// begin un := ru_forest [ i ] ;
14941: LD_ADDR_VAR 0 2
14945: PUSH
14946: LD_EXP 49
14950: PUSH
14951: LD_VAR 0 1
14955: ARRAY
14956: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14957: LD_VAR 0 2
14961: PPUSH
14962: LD_INT 13
14964: PPUSH
14965: CALL_OW 308
14969: IFFALSE 15059
// begin if not See ( 1 , un ) then
14971: LD_INT 1
14973: PPUSH
14974: LD_VAR 0 2
14978: PPUSH
14979: CALL_OW 292
14983: NOT
14984: IFFALSE 14998
// SetLives ( un , 1000 ) ;
14986: LD_VAR 0 2
14990: PPUSH
14991: LD_INT 1000
14993: PPUSH
14994: CALL_OW 234
// ru_forest := ru_forest diff un ;
14998: LD_ADDR_EXP 49
15002: PUSH
15003: LD_EXP 49
15007: PUSH
15008: LD_VAR 0 2
15012: DIFF
15013: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
15014: LD_VAR 0 2
15018: PPUSH
15019: LD_INT 22
15021: PUSH
15022: LD_INT 3
15024: PUSH
15025: EMPTY
15026: LIST
15027: LIST
15028: PUSH
15029: LD_INT 30
15031: PUSH
15032: LD_INT 4
15034: PUSH
15035: EMPTY
15036: LIST
15037: LIST
15038: PUSH
15039: EMPTY
15040: LIST
15041: LIST
15042: PPUSH
15043: CALL_OW 69
15047: PPUSH
15048: CALL 1001 0 1
15052: PPUSH
15053: CALL_OW 120
// continue ;
15057: GO 14938
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15059: LD_VAR 0 2
15063: PPUSH
15064: CALL_OW 256
15068: PUSH
15069: LD_INT 700
15071: LESS
15072: PUSH
15073: LD_VAR 0 2
15077: PPUSH
15078: LD_INT 13
15080: PPUSH
15081: CALL_OW 308
15085: NOT
15086: AND
15087: IFFALSE 15103
// ComMoveToArea ( un , retreatArea ) else
15089: LD_VAR 0 2
15093: PPUSH
15094: LD_INT 13
15096: PPUSH
15097: CALL_OW 113
15101: GO 15172
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15103: LD_VAR 0 2
15107: PPUSH
15108: LD_VAR 0 3
15112: PPUSH
15113: LD_VAR 0 2
15117: PPUSH
15118: CALL_OW 74
15122: PPUSH
15123: CALL_OW 296
15127: PUSH
15128: LD_INT 9
15130: LESS
15131: PUSH
15132: LD_VAR 0 2
15136: PPUSH
15137: CALL_OW 256
15141: PUSH
15142: LD_INT 500
15144: GREATER
15145: AND
15146: IFFALSE 15172
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15148: LD_VAR 0 2
15152: PPUSH
15153: LD_VAR 0 3
15157: PPUSH
15158: LD_VAR 0 2
15162: PPUSH
15163: CALL_OW 74
15167: PPUSH
15168: CALL_OW 115
// end ;
15172: GO 14938
15174: POP
15175: POP
// end ;
15176: PPOPN 3
15178: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
15179: LD_EXP 28
15183: NOT
15184: IFFALSE 15305
15186: GO 15188
15188: DISABLE
15189: LD_INT 0
15191: PPUSH
15192: PPUSH
// begin enable ;
15193: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
15194: LD_ADDR_VAR 0 2
15198: PUSH
15199: LD_INT 22
15201: PUSH
15202: LD_INT 3
15204: PUSH
15205: EMPTY
15206: LIST
15207: LIST
15208: PUSH
15209: LD_INT 21
15211: PUSH
15212: LD_INT 3
15214: PUSH
15215: EMPTY
15216: LIST
15217: LIST
15218: PUSH
15219: EMPTY
15220: LIST
15221: LIST
15222: PPUSH
15223: CALL_OW 69
15227: ST_TO_ADDR
// if filter then
15228: LD_VAR 0 2
15232: IFFALSE 15305
// for i in filter do
15234: LD_ADDR_VAR 0 1
15238: PUSH
15239: LD_VAR 0 2
15243: PUSH
15244: FOR_IN
15245: IFFALSE 15303
// if GetLives ( i ) < 990 then
15247: LD_VAR 0 1
15251: PPUSH
15252: CALL_OW 256
15256: PUSH
15257: LD_INT 990
15259: LESS
15260: IFFALSE 15301
// begin ru_alert := true ;
15262: LD_ADDR_EXP 54
15266: PUSH
15267: LD_INT 1
15269: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
15270: LD_ADDR_EXP 55
15274: PUSH
15275: LD_VAR 0 1
15279: PPUSH
15280: CALL_OW 250
15284: PUSH
15285: LD_VAR 0 1
15289: PPUSH
15290: CALL_OW 251
15294: PUSH
15295: EMPTY
15296: LIST
15297: LIST
15298: ST_TO_ADDR
// break ;
15299: GO 15303
// end ;
15301: GO 15244
15303: POP
15304: POP
// end ;
15305: PPOPN 2
15307: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
15308: LD_EXP 27
15312: IFFALSE 15461
15314: GO 15316
15316: DISABLE
15317: LD_INT 0
15319: PPUSH
15320: PPUSH
15321: PPUSH
15322: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
15323: LD_ADDR_VAR 0 4
15327: PUSH
15328: LD_EXP 50
15332: PUSH
15333: LD_EXP 49
15337: ADD
15338: PUSH
15339: LD_EXP 47
15343: ADD
15344: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
15345: LD_ADDR_VAR 0 3
15349: PUSH
15350: LD_INT 3
15352: PPUSH
15353: LD_INT 81
15355: PUSH
15356: LD_INT 3
15358: PUSH
15359: EMPTY
15360: LIST
15361: LIST
15362: PPUSH
15363: CALL_OW 70
15367: ST_TO_ADDR
// if filter and enemy then
15368: LD_VAR 0 4
15372: PUSH
15373: LD_VAR 0 3
15377: AND
15378: IFFALSE 15461
// repeat wait ( 0 0$01 ) ;
15380: LD_INT 35
15382: PPUSH
15383: CALL_OW 67
// for i in filter do
15387: LD_ADDR_VAR 0 1
15391: PUSH
15392: LD_VAR 0 4
15396: PUSH
15397: FOR_IN
15398: IFFALSE 15426
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15400: LD_VAR 0 1
15404: PPUSH
15405: LD_VAR 0 3
15409: PPUSH
15410: LD_VAR 0 1
15414: PPUSH
15415: CALL_OW 74
15419: PPUSH
15420: CALL_OW 115
// end ;
15424: GO 15397
15426: POP
15427: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
15428: LD_INT 3
15430: PPUSH
15431: LD_INT 81
15433: PUSH
15434: LD_INT 3
15436: PUSH
15437: EMPTY
15438: LIST
15439: LIST
15440: PPUSH
15441: CALL_OW 70
15445: PUSH
15446: LD_INT 0
15448: EQUAL
15449: PUSH
15450: LD_VAR 0 4
15454: PUSH
15455: LD_INT 0
15457: EQUAL
15458: OR
15459: IFFALSE 15380
// end ;
15461: PPOPN 4
15463: END
// every 0 0$03 trigger send_attack_on_cornel_base and FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) do var i ;
15464: LD_EXP 23
15468: PUSH
15469: LD_INT 22
15471: PUSH
15472: LD_INT 4
15474: PUSH
15475: EMPTY
15476: LIST
15477: LIST
15478: PUSH
15479: LD_INT 30
15481: PUSH
15482: LD_INT 4
15484: PUSH
15485: EMPTY
15486: LIST
15487: LIST
15488: PUSH
15489: EMPTY
15490: LIST
15491: LIST
15492: PPUSH
15493: CALL_OW 69
15497: AND
15498: IFFALSE 15547
15500: GO 15502
15502: DISABLE
15503: LD_INT 0
15505: PPUSH
// begin if not ru_cornel_attack then
15506: LD_EXP 52
15510: NOT
15511: IFFALSE 15515
// exit ;
15513: GO 15547
// for i in ru_cornel_attack do
15515: LD_ADDR_VAR 0 1
15519: PUSH
15520: LD_EXP 52
15524: PUSH
15525: FOR_IN
15526: IFFALSE 15545
// ComAgressiveMove ( i , 258 , 119 ) ;
15528: LD_VAR 0 1
15532: PPUSH
15533: LD_INT 258
15535: PPUSH
15536: LD_INT 119
15538: PPUSH
15539: CALL_OW 114
15543: GO 15525
15545: POP
15546: POP
// end ; end_of_file
15547: PPOPN 1
15549: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
15550: LD_EXP 3
15554: PUSH
15555: LD_EXP 7
15559: NOT
15560: AND
15561: PUSH
15562: LD_EXP 17
15566: AND
15567: IFFALSE 15679
15569: GO 15571
15571: DISABLE
15572: LD_INT 0
15574: PPUSH
// begin enable ;
15575: ENABLE
// crates_counter := crates_counter - 50 ;
15576: LD_ADDR_EXP 17
15580: PUSH
15581: LD_EXP 17
15585: PUSH
15586: LD_INT 50
15588: MINUS
15589: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
15590: LD_INT 8
15592: PPUSH
15593: LD_INT 2
15595: PPUSH
15596: LD_INT 5
15598: PPUSH
15599: CALL_OW 12
15603: PPUSH
15604: LD_INT 1
15606: PPUSH
15607: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
15611: LD_INT 1785
15613: PPUSH
15614: LD_INT 2345
15616: PPUSH
15617: CALL_OW 12
15621: PPUSH
15622: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
15626: LD_ADDR_VAR 0 1
15630: PUSH
15631: LD_INT 1
15633: PPUSH
15634: LD_OWVAR 67
15638: PUSH
15639: LD_INT 2
15641: PLUS
15642: PPUSH
15643: CALL_OW 12
15647: ST_TO_ADDR
// if r < 3 then
15648: LD_VAR 0 1
15652: PUSH
15653: LD_INT 3
15655: LESS
15656: IFFALSE 15679
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
15658: LD_INT 4
15660: PPUSH
15661: LD_INT 1
15663: PPUSH
15664: LD_INT 5
15666: PPUSH
15667: CALL_OW 12
15671: PPUSH
15672: LD_INT 1
15674: PPUSH
15675: CALL_OW 55
// end ;
15679: PPOPN 1
15681: END
// every 0 0$01 trigger cornel_active do
15682: LD_EXP 6
15686: IFFALSE 15775
15688: GO 15690
15690: DISABLE
// begin Wait ( 0 0$03 ) ;
15691: LD_INT 105
15693: PPUSH
15694: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15698: LD_INT 2
15700: PPUSH
15701: LD_INT 5
15703: PPUSH
15704: CALL_OW 12
15708: PPUSH
15709: LD_INT 10
15711: PPUSH
15712: LD_INT 1
15714: PPUSH
15715: CALL_OW 55
// Wait ( 0 0$13 ) ;
15719: LD_INT 455
15721: PPUSH
15722: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15726: LD_INT 2
15728: PPUSH
15729: LD_INT 5
15731: PPUSH
15732: CALL_OW 12
15736: PPUSH
15737: LD_INT 10
15739: PPUSH
15740: LD_INT 1
15742: PPUSH
15743: CALL_OW 55
// Wait ( 0 0$16 ) ;
15747: LD_INT 560
15749: PPUSH
15750: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15754: LD_INT 2
15756: PPUSH
15757: LD_INT 5
15759: PPUSH
15760: CALL_OW 12
15764: PPUSH
15765: LD_INT 10
15767: PPUSH
15768: LD_INT 1
15770: PPUSH
15771: CALL_OW 55
// end ; end_of_file
15775: END
// every 0 0$01 trigger cornel_prepared do
15776: LD_EXP 9
15780: IFFALSE 15839
15782: GO 15784
15784: DISABLE
// begin enable ;
15785: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
15786: LD_ADDR_OWVAR 47
15790: PUSH
15791: LD_STRING #Am03-1
15793: PUSH
15794: LD_EXP 8
15798: PUSH
15799: EMPTY
15800: LIST
15801: LIST
15802: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
15803: LD_ADDR_EXP 8
15807: PUSH
15808: LD_EXP 8
15812: PPUSH
15813: LD_STRING -
15815: PPUSH
15816: CALL 1071 0 2
15820: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
15821: LD_EXP 8
15825: PUSH
15826: LD_INT 0
15828: EQUAL
15829: IFFALSE 15839
// begin Display_Strings := [ ] ;
15831: LD_ADDR_OWVAR 47
15835: PUSH
15836: EMPTY
15837: ST_TO_ADDR
// disable ;
15838: DISABLE
// end ; end ;
15839: END
// every 0 0$01 trigger debug and debug_strings do
15840: LD_EXP 1
15844: PUSH
15845: LD_OWVAR 48
15849: AND
15850: IFFALSE 15866
15852: GO 15854
15854: DISABLE
// begin enable ;
15855: ENABLE
// Display_Strings := debug_strings ;
15856: LD_ADDR_OWVAR 47
15860: PUSH
15861: LD_OWVAR 48
15865: ST_TO_ADDR
// end ; end_of_file
15866: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
15867: LD_VAR 0 1
15871: PPUSH
15872: CALL_OW 255
15876: PUSH
15877: LD_INT 1
15879: EQUAL
15880: PUSH
15881: LD_EXP 11
15885: NOT
15886: AND
15887: IFFALSE 15897
// solar_builded := true ;
15889: LD_ADDR_EXP 11
15893: PUSH
15894: LD_INT 1
15896: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
15897: LD_VAR 0 1
15901: PPUSH
15902: CALL_OW 255
15906: PUSH
15907: LD_INT 1
15909: EQUAL
15910: PUSH
15911: LD_EXP 25
15915: AND
15916: IFFALSE 15949
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
15918: LD_ADDR_EXP 25
15922: PUSH
15923: LD_EXP 25
15927: PUSH
15928: LD_INT 1750
15930: PUSH
15931: LD_INT 1400
15933: PUSH
15934: LD_INT 1225
15936: PUSH
15937: EMPTY
15938: LIST
15939: LIST
15940: LIST
15941: PUSH
15942: LD_OWVAR 67
15946: ARRAY
15947: PLUS
15948: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
15949: LD_VAR 0 1
15953: PPUSH
15954: CALL_OW 255
15958: PUSH
15959: LD_INT 3
15961: EQUAL
15962: IFFALSE 15980
// ru_vehicles := ru_vehicles ^ veh ;
15964: LD_ADDR_EXP 50
15968: PUSH
15969: LD_EXP 50
15973: PUSH
15974: LD_VAR 0 1
15978: ADD
15979: ST_TO_ADDR
// end ;
15980: PPOPN 2
15982: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
15983: LD_VAR 0 1
15987: PUSH
15988: LD_EXP 47
15992: IN
15993: IFFALSE 16011
// ru_patrol := ru_patrol diff un ;
15995: LD_ADDR_EXP 47
15999: PUSH
16000: LD_EXP 47
16004: PUSH
16005: LD_VAR 0 1
16009: DIFF
16010: ST_TO_ADDR
// if un in ru_forest then
16011: LD_VAR 0 1
16015: PUSH
16016: LD_EXP 49
16020: IN
16021: IFFALSE 16039
// ru_forest := ru_forest diff un ;
16023: LD_ADDR_EXP 49
16027: PUSH
16028: LD_EXP 49
16032: PUSH
16033: LD_VAR 0 1
16037: DIFF
16038: ST_TO_ADDR
// if un in ru_vehicles then
16039: LD_VAR 0 1
16043: PUSH
16044: LD_EXP 50
16048: IN
16049: IFFALSE 16124
// begin ru_vehicles := ru_vehicles diff un ;
16051: LD_ADDR_EXP 50
16055: PUSH
16056: LD_EXP 50
16060: PUSH
16061: LD_VAR 0 1
16065: DIFF
16066: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
16067: LD_ADDR_EXP 51
16071: PUSH
16072: LD_EXP 51
16076: PUSH
16077: LD_VAR 0 1
16081: PPUSH
16082: CALL_OW 265
16086: PUSH
16087: LD_VAR 0 1
16091: PPUSH
16092: CALL_OW 262
16096: PUSH
16097: LD_VAR 0 1
16101: PPUSH
16102: CALL_OW 263
16106: PUSH
16107: LD_VAR 0 1
16111: PPUSH
16112: CALL_OW 264
16116: PUSH
16117: EMPTY
16118: LIST
16119: LIST
16120: LIST
16121: LIST
16122: ADD
16123: ST_TO_ADDR
// end ; if un = JMM then
16124: LD_VAR 0 1
16128: PUSH
16129: LD_EXP 31
16133: EQUAL
16134: IFFALSE 16143
// YouLost ( 0 ) ;
16136: LD_STRING 0
16138: PPUSH
16139: CALL_OW 104
// if un = us_dep_west then
16143: LD_VAR 0 1
16147: PUSH
16148: LD_INT 1
16150: EQUAL
16151: IFFALSE 16160
// YouLost ( 2 ) ;
16153: LD_STRING 2
16155: PPUSH
16156: CALL_OW 104
// if un = Lynch and GetSide ( Lynch ) = 8 then
16160: LD_VAR 0 1
16164: PUSH
16165: LD_EXP 41
16169: EQUAL
16170: PUSH
16171: LD_EXP 41
16175: PPUSH
16176: CALL_OW 255
16180: PUSH
16181: LD_INT 8
16183: EQUAL
16184: AND
16185: IFFALSE 16194
// YouLost ( 4 ) ;
16187: LD_STRING 4
16189: PPUSH
16190: CALL_OW 104
// if un in jmm_units then
16194: LD_VAR 0 1
16198: PUSH
16199: LD_EXP 2
16203: IN
16204: IFFALSE 16220
// lose_counter := lose_counter + 1 ;
16206: LD_ADDR_EXP 30
16210: PUSH
16211: LD_EXP 30
16215: PUSH
16216: LD_INT 1
16218: PLUS
16219: ST_TO_ADDR
// end ;
16220: PPOPN 1
16222: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
16223: LD_INT 0
16225: PPUSH
16226: PPUSH
// begin if GetSide ( driver ) = 3 then
16227: LD_VAR 0 1
16231: PPUSH
16232: CALL_OW 255
16236: PUSH
16237: LD_INT 3
16239: EQUAL
16240: IFFALSE 16318
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
16242: LD_ADDR_VAR 0 6
16246: PUSH
16247: LD_INT 22
16249: PUSH
16250: LD_INT 3
16252: PUSH
16253: EMPTY
16254: LIST
16255: LIST
16256: PUSH
16257: LD_INT 30
16259: PUSH
16260: LD_INT 3
16262: PUSH
16263: EMPTY
16264: LIST
16265: LIST
16266: PUSH
16267: EMPTY
16268: LIST
16269: LIST
16270: PPUSH
16271: CALL_OW 69
16275: PPUSH
16276: CALL 1001 0 1
16280: ST_TO_ADDR
// if place then
16281: LD_VAR 0 6
16285: IFFALSE 16303
// ComEnterUnit ( driver , place ) else
16287: LD_VAR 0 1
16291: PPUSH
16292: LD_VAR 0 6
16296: PPUSH
16297: CALL_OW 120
16301: GO 16318
// ComMoveXY ( driver , 70 , 22 ) ;
16303: LD_VAR 0 1
16307: PPUSH
16308: LD_INT 70
16310: PPUSH
16311: LD_INT 22
16313: PPUSH
16314: CALL_OW 111
// end ; end ;
16318: PPOPN 6
16320: END
// every 0 0$01 trigger not game_end and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) < 4 do
16321: LD_EXP 29
16325: NOT
16326: PUSH
16327: LD_INT 22
16329: PUSH
16330: LD_INT 1
16332: PUSH
16333: EMPTY
16334: LIST
16335: LIST
16336: PUSH
16337: LD_INT 21
16339: PUSH
16340: LD_INT 1
16342: PUSH
16343: EMPTY
16344: LIST
16345: LIST
16346: PUSH
16347: EMPTY
16348: LIST
16349: LIST
16350: PPUSH
16351: CALL_OW 69
16355: PUSH
16356: LD_INT 22
16358: PUSH
16359: LD_INT 8
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PUSH
16366: LD_INT 21
16368: PUSH
16369: LD_INT 1
16371: PUSH
16372: EMPTY
16373: LIST
16374: LIST
16375: PUSH
16376: EMPTY
16377: LIST
16378: LIST
16379: PPUSH
16380: CALL_OW 69
16384: PLUS
16385: PUSH
16386: LD_INT 4
16388: LESS
16389: AND
16390: IFFALSE 16402
16392: GO 16394
16394: DISABLE
// YouLost ( 1 ) ;
16395: LD_STRING 1
16397: PPUSH
16398: CALL_OW 104
16402: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
16403: LD_INT 1
16405: PPUSH
16406: CALL_OW 255
16410: PUSH
16411: LD_INT 3
16413: EQUAL
16414: IFFALSE 16426
16416: GO 16418
16418: DISABLE
// YouLost ( 3 ) ;
16419: LD_STRING 3
16421: PPUSH
16422: CALL_OW 104
16426: END
