// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 323 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 411 0 0
// PrepareRussian ;
  22: CALL 2898 0 0
// PrepareAmerican ;
  26: CALL 1139 0 0
// PrepareCornell ;
  30: CALL 2163 0 0
// PrepareWesternBase ;
  34: CALL 2389 0 0
// Action ;
  38: CALL 4904 0 0
// end ;
  42: END
// export debug ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// jmm_units := 0 ;
  54: LD_ADDR_EXP 2
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// cornel_units := 0 ;
  62: LD_ADDR_EXP 4
  66: PUSH
  67: LD_INT 0
  69: ST_TO_ADDR
// bierezov_exist := false ;
  70: LD_ADDR_EXP 5
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// jmm_on_west := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// cornel_active := false ;
  86: LD_ADDR_EXP 6
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// cornel_attack := false ;
  94: LD_ADDR_EXP 7
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_prepared := false ;
 102: LD_ADDR_EXP 9
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 110: LD_ADDR_EXP 8
 114: PUSH
 115: LD_INT 4200
 117: ST_TO_ADDR
// frank_can_return := false ;
 118: LD_ADDR_EXP 10
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// solar_builded := false ;
 126: LD_ADDR_EXP 11
 130: PUSH
 131: LD_INT 0
 133: ST_TO_ADDR
// frank_send_to_scout := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// jmm_in_veh := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// bobby_in_veh := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// cyrus_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// lisa_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 174: LD_ADDR_EXP 25
 178: PUSH
 179: LD_INT 25200
 181: PUSH
 182: LD_INT 23100
 184: PUSH
 185: LD_INT 21000
 187: PUSH
 188: EMPTY
 189: LIST
 190: LIST
 191: LIST
 192: PUSH
 193: LD_OWVAR 67
 197: ARRAY
 198: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 199: LD_ADDR_EXP 17
 203: PUSH
 204: LD_INT 600
 206: PUSH
 207: LD_INT 500
 209: PUSH
 210: LD_INT 400
 212: PUSH
 213: EMPTY
 214: LIST
 215: LIST
 216: LIST
 217: PUSH
 218: LD_OWVAR 67
 222: ARRAY
 223: ST_TO_ADDR
// end_mission_allowed := false ;
 224: LD_ADDR_EXP 18
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// save_others := [ ] ;
 232: LD_ADDR_EXP 19
 236: PUSH
 237: EMPTY
 238: ST_TO_ADDR
// save_group := [ ] ;
 239: LD_ADDR_EXP 20
 243: PUSH
 244: EMPTY
 245: ST_TO_ADDR
// show_query := true ;
 246: LD_ADDR_EXP 21
 250: PUSH
 251: LD_INT 1
 253: ST_TO_ADDR
// wait_for_them := false ;
 254: LD_ADDR_EXP 22
 258: PUSH
 259: LD_INT 0
 261: ST_TO_ADDR
// veh_on_meta := false ;
 262: LD_ADDR_EXP 24
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// send_spec_patrol := false ;
 270: LD_ADDR_EXP 26
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// prepare_siege := false ;
 278: LD_ADDR_EXP 27
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_attack_on_cornel := false ;
 286: LD_ADDR_EXP 28
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 294: LD_ADDR_EXP 23
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// game_end := false ;
 302: LD_ADDR_EXP 29
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// lose_counter := 0 ;
 310: LD_ADDR_EXP 30
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// end ;
 318: LD_VAR 0 1
 322: RET
// function SetDiplomacy ; begin
 323: LD_INT 0
 325: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 326: LD_INT 1
 328: PPUSH
 329: LD_INT 4
 331: PPUSH
 332: LD_INT 1
 334: PPUSH
 335: LD_INT 1
 337: PPUSH
 338: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 342: LD_INT 1
 344: PPUSH
 345: LD_INT 8
 347: PPUSH
 348: LD_INT 1
 350: PPUSH
 351: LD_INT 1
 353: PPUSH
 354: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 358: LD_INT 3
 360: PPUSH
 361: LD_INT 6
 363: PPUSH
 364: LD_INT 1
 366: PPUSH
 367: LD_INT 1
 369: PPUSH
 370: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 374: LD_INT 4
 376: PPUSH
 377: LD_INT 6
 379: PPUSH
 380: LD_INT 0
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 390: LD_INT 3
 392: PPUSH
 393: LD_INT 8
 395: PPUSH
 396: LD_INT 0
 398: PPUSH
 399: LD_INT 1
 401: PPUSH
 402: CALL_OW 80
// end ;
 406: LD_VAR 0 1
 410: RET
// export function DebugMode ; var i ; begin
 411: LD_INT 0
 413: PPUSH
 414: PPUSH
// FogOff ( 1 ) ;
 415: LD_INT 1
 417: PPUSH
 418: CALL_OW 344
// debug_strings := [ ] ;
 422: LD_ADDR_OWVAR 48
 426: PUSH
 427: EMPTY
 428: ST_TO_ADDR
// end ; end_of_file
 429: LD_VAR 0 1
 433: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 434: LD_INT 0
 436: PPUSH
 437: PPUSH
// if exist_mode then
 438: LD_VAR 0 2
 442: IFFALSE 461
// unit := CreateCharacter ( ident ) else
 444: LD_ADDR_VAR 0 4
 448: PUSH
 449: LD_VAR 0 1
 453: PPUSH
 454: CALL_OW 34
 458: ST_TO_ADDR
 459: GO 476
// unit := NewCharacter ( ident ) ;
 461: LD_ADDR_VAR 0 4
 465: PUSH
 466: LD_VAR 0 1
 470: PPUSH
 471: CALL_OW 25
 475: ST_TO_ADDR
// result := unit ;
 476: LD_ADDR_VAR 0 3
 480: PUSH
 481: LD_VAR 0 4
 485: ST_TO_ADDR
// end ;
 486: LD_VAR 0 3
 490: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 491: LD_INT 0
 493: PPUSH
// uc_side := side ;
 494: LD_ADDR_OWVAR 20
 498: PUSH
 499: LD_VAR 0 1
 503: ST_TO_ADDR
// uc_nation := nation ;
 504: LD_ADDR_OWVAR 21
 508: PUSH
 509: LD_VAR 0 2
 513: ST_TO_ADDR
// vc_chassis := chassis ;
 514: LD_ADDR_OWVAR 37
 518: PUSH
 519: LD_VAR 0 3
 523: ST_TO_ADDR
// vc_engine := engine ;
 524: LD_ADDR_OWVAR 39
 528: PUSH
 529: LD_VAR 0 4
 533: ST_TO_ADDR
// vc_control := control ;
 534: LD_ADDR_OWVAR 38
 538: PUSH
 539: LD_VAR 0 5
 543: ST_TO_ADDR
// vc_weapon := weapon ;
 544: LD_ADDR_OWVAR 40
 548: PUSH
 549: LD_VAR 0 6
 553: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 554: LD_ADDR_OWVAR 41
 558: PUSH
 559: LD_VAR 0 7
 563: ST_TO_ADDR
// result := CreateVehicle ;
 564: LD_ADDR_VAR 0 8
 568: PUSH
 569: CALL_OW 45
 573: ST_TO_ADDR
// end ;
 574: LD_VAR 0 8
 578: RET
// export function SayX ( units , ident ) ; var i ; begin
 579: LD_INT 0
 581: PPUSH
 582: PPUSH
// result := false ;
 583: LD_ADDR_VAR 0 3
 587: PUSH
 588: LD_INT 0
 590: ST_TO_ADDR
// if not units then
 591: LD_VAR 0 1
 595: NOT
 596: IFFALSE 600
// exit ;
 598: GO 654
// for i in units do
 600: LD_ADDR_VAR 0 4
 604: PUSH
 605: LD_VAR 0 1
 609: PUSH
 610: FOR_IN
 611: IFFALSE 652
// if IsOk ( i ) then
 613: LD_VAR 0 4
 617: PPUSH
 618: CALL_OW 302
 622: IFFALSE 650
// begin Say ( i , ident ) ;
 624: LD_VAR 0 4
 628: PPUSH
 629: LD_VAR 0 2
 633: PPUSH
 634: CALL_OW 88
// result := i ;
 638: LD_ADDR_VAR 0 3
 642: PUSH
 643: LD_VAR 0 4
 647: ST_TO_ADDR
// break ;
 648: GO 652
// end ;
 650: GO 610
 652: POP
 653: POP
// end ;
 654: LD_VAR 0 3
 658: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 659: LD_INT 0
 661: PPUSH
 662: PPUSH
 663: PPUSH
 664: PPUSH
// for i = 1 to count do
 665: LD_ADDR_VAR 0 8
 669: PUSH
 670: DOUBLE
 671: LD_INT 1
 673: DEC
 674: ST_TO_ADDR
 675: LD_VAR 0 6
 679: PUSH
 680: FOR_TO
 681: IFFALSE 762
// begin uc_side = side ;
 683: LD_ADDR_OWVAR 20
 687: PUSH
 688: LD_VAR 0 1
 692: ST_TO_ADDR
// uc_nation = nation ;
 693: LD_ADDR_OWVAR 21
 697: PUSH
 698: LD_VAR 0 2
 702: ST_TO_ADDR
// hc_gallery =  ;
 703: LD_ADDR_OWVAR 33
 707: PUSH
 708: LD_STRING 
 710: ST_TO_ADDR
// hc_name =  ;
 711: LD_ADDR_OWVAR 26
 715: PUSH
 716: LD_STRING 
 718: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 719: LD_INT 0
 721: PPUSH
 722: LD_VAR 0 5
 726: PPUSH
 727: LD_VAR 0 4
 731: PPUSH
 732: CALL_OW 380
// un = CreateHuman ;
 736: LD_ADDR_VAR 0 10
 740: PUSH
 741: CALL_OW 44
 745: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 746: LD_VAR 0 10
 750: PPUSH
 751: LD_VAR 0 3
 755: PPUSH
 756: CALL_OW 52
// end ;
 760: GO 680
 762: POP
 763: POP
// end ;
 764: LD_VAR 0 7
 768: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 769: LD_INT 0
 771: PPUSH
 772: PPUSH
 773: PPUSH
// uc_side := GetSide ( b ) ;
 774: LD_ADDR_OWVAR 20
 778: PUSH
 779: LD_VAR 0 2
 783: PPUSH
 784: CALL_OW 255
 788: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 789: LD_ADDR_OWVAR 21
 793: PUSH
 794: LD_VAR 0 2
 798: PPUSH
 799: CALL_OW 248
 803: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 804: LD_INT 0
 806: PPUSH
 807: LD_INT 1
 809: PPUSH
 810: LD_VAR 0 1
 814: PPUSH
 815: CALL_OW 380
// un = CreateHuman ;
 819: LD_ADDR_VAR 0 4
 823: PUSH
 824: CALL_OW 44
 828: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 829: LD_ADDR_VAR 0 5
 833: PUSH
 834: LD_VAR 0 2
 838: PPUSH
 839: CALL_OW 254
 843: PUSH
 844: LD_INT 3
 846: MINUS
 847: ST_TO_ADDR
// if dir < 0 then
 848: LD_VAR 0 5
 852: PUSH
 853: LD_INT 0
 855: LESS
 856: IFFALSE 872
// dir := 6 + dir ;
 858: LD_ADDR_VAR 0 5
 862: PUSH
 863: LD_INT 6
 865: PUSH
 866: LD_VAR 0 5
 870: PLUS
 871: ST_TO_ADDR
// SetDir ( un , dir ) ;
 872: LD_VAR 0 4
 876: PPUSH
 877: LD_VAR 0 5
 881: PPUSH
 882: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 886: LD_VAR 0 4
 890: PPUSH
 891: LD_VAR 0 2
 895: PPUSH
 896: CALL_OW 52
// end ;
 900: LD_VAR 0 3
 904: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 905: LD_INT 0
 907: PPUSH
 908: PPUSH
 909: PPUSH
// result := false ;
 910: LD_ADDR_VAR 0 2
 914: PUSH
 915: LD_INT 0
 917: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 918: LD_ADDR_VAR 0 3
 922: PUSH
 923: LD_INT 22
 925: PUSH
 926: LD_INT 1
 928: PUSH
 929: EMPTY
 930: LIST
 931: LIST
 932: PUSH
 933: LD_INT 34
 935: PUSH
 936: LD_INT 2
 938: PUSH
 939: EMPTY
 940: LIST
 941: LIST
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: PPUSH
 947: CALL_OW 69
 951: ST_TO_ADDR
// for i in filter do
 952: LD_ADDR_VAR 0 4
 956: PUSH
 957: LD_VAR 0 3
 961: PUSH
 962: FOR_IN
 963: IFFALSE 994
// if IsDrivenBy ( i ) = unit then
 965: LD_VAR 0 4
 969: PPUSH
 970: CALL_OW 311
 974: PUSH
 975: LD_VAR 0 1
 979: EQUAL
 980: IFFALSE 992
// begin result := true ;
 982: LD_ADDR_VAR 0 2
 986: PUSH
 987: LD_INT 1
 989: ST_TO_ADDR
// break ;
 990: GO 994
// end ;
 992: GO 962
 994: POP
 995: POP
// end ;
 996: LD_VAR 0 2
1000: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1001: LD_INT 0
1003: PPUSH
1004: PPUSH
// result := false ;
1005: LD_ADDR_VAR 0 2
1009: PUSH
1010: LD_INT 0
1012: ST_TO_ADDR
// if not blist then
1013: LD_VAR 0 1
1017: NOT
1018: IFFALSE 1022
// exit ;
1020: GO 1066
// for i in blist do
1022: LD_ADDR_VAR 0 3
1026: PUSH
1027: LD_VAR 0 1
1031: PUSH
1032: FOR_IN
1033: IFFALSE 1064
// if UnitsInside ( i ) < 6 then
1035: LD_VAR 0 3
1039: PPUSH
1040: CALL_OW 313
1044: PUSH
1045: LD_INT 6
1047: LESS
1048: IFFALSE 1062
// begin result := i ;
1050: LD_ADDR_VAR 0 2
1054: PUSH
1055: LD_VAR 0 3
1059: ST_TO_ADDR
// break ;
1060: GO 1064
// end ;
1062: GO 1032
1064: POP
1065: POP
// end ;
1066: LD_VAR 0 2
1070: RET
// export function Count ( timer , mode ) ; begin
1071: LD_INT 0
1073: PPUSH
// if not timer then
1074: LD_VAR 0 1
1078: NOT
1079: IFFALSE 1083
// exit ;
1081: GO 1134
// if mode in [ asc , up , + ] then
1083: LD_VAR 0 2
1087: PUSH
1088: LD_STRING asc
1090: PUSH
1091: LD_STRING up
1093: PUSH
1094: LD_STRING +
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: IN
1102: IFFALSE 1120
// result := timer + 0 0$01 else
1104: LD_ADDR_VAR 0 3
1108: PUSH
1109: LD_VAR 0 1
1113: PUSH
1114: LD_INT 35
1116: PLUS
1117: ST_TO_ADDR
1118: GO 1134
// result := timer - 0 0$01 ;
1120: LD_ADDR_VAR 0 3
1124: PUSH
1125: LD_VAR 0 1
1129: PUSH
1130: LD_INT 35
1132: MINUS
1133: ST_TO_ADDR
// end ; end_of_file
1134: LD_VAR 0 3
1138: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1139: LD_INT 0
1141: PPUSH
1142: PPUSH
1143: PPUSH
1144: PPUSH
1145: PPUSH
1146: PPUSH
1147: PPUSH
1148: PPUSH
// uc_side := 4 ;
1149: LD_ADDR_OWVAR 20
1153: PUSH
1154: LD_INT 4
1156: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1157: LD_ADDR_EXP 40
1161: PUSH
1162: LD_STRING Powell
1164: PPUSH
1165: LD_INT 0
1167: PPUSH
1168: CALL 434 0 2
1172: ST_TO_ADDR
// uc_side := 1 ;
1173: LD_ADDR_OWVAR 20
1177: PUSH
1178: LD_INT 1
1180: ST_TO_ADDR
// uc_nation := 1 ;
1181: LD_ADDR_OWVAR 21
1185: PUSH
1186: LD_INT 1
1188: ST_TO_ADDR
// if debug then
1189: LD_EXP 1
1193: IFFALSE 1323
// begin for i = 1 to 4 do
1195: LD_ADDR_VAR 0 2
1199: PUSH
1200: DOUBLE
1201: LD_INT 1
1203: DEC
1204: ST_TO_ADDR
1205: LD_INT 4
1207: PUSH
1208: FOR_TO
1209: IFFALSE 1260
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1211: LD_INT 0
1213: PPUSH
1214: LD_INT 1
1216: PPUSH
1217: LD_INT 2
1219: PPUSH
1220: CALL_OW 12
1224: PPUSH
1225: LD_INT 3
1227: PPUSH
1228: CALL_OW 380
// un := CreateHuman ;
1232: LD_ADDR_VAR 0 3
1236: PUSH
1237: CALL_OW 44
1241: ST_TO_ADDR
// others := others ^ un ;
1242: LD_ADDR_VAR 0 5
1246: PUSH
1247: LD_VAR 0 5
1251: PUSH
1252: LD_VAR 0 3
1256: ADD
1257: ST_TO_ADDR
// end ;
1258: GO 1208
1260: POP
1261: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1262: LD_ADDR_VAR 0 6
1266: PUSH
1267: LD_INT 21
1269: PUSH
1270: LD_INT 1
1272: PUSH
1273: LD_INT 1
1275: PUSH
1276: LD_INT 51
1278: PUSH
1279: LD_INT 90
1281: PUSH
1282: LD_INT 504
1284: PUSH
1285: EMPTY
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: PUSH
1293: LD_INT 21
1295: PUSH
1296: LD_INT 1
1298: PUSH
1299: LD_INT 1
1301: PUSH
1302: LD_INT 51
1304: PUSH
1305: LD_INT 80
1307: PUSH
1308: LD_INT 750
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: PUSH
1319: EMPTY
1320: LIST
1321: LIST
1322: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1323: LD_ADDR_EXP 31
1327: PUSH
1328: LD_STRING JMM
1330: PPUSH
1331: LD_EXP 1
1335: NOT
1336: PPUSH
1337: CALL 434 0 2
1341: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1342: LD_ADDR_EXP 32
1346: PUSH
1347: LD_STRING Bobby
1349: PPUSH
1350: LD_EXP 1
1354: NOT
1355: PPUSH
1356: CALL 434 0 2
1360: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1361: LD_ADDR_EXP 33
1365: PUSH
1366: LD_STRING Cyrus
1368: PPUSH
1369: LD_EXP 1
1373: NOT
1374: PPUSH
1375: CALL 434 0 2
1379: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1380: LD_ADDR_EXP 34
1384: PUSH
1385: LD_STRING Lisa
1387: PPUSH
1388: LD_EXP 1
1392: NOT
1393: PPUSH
1394: CALL 434 0 2
1398: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1399: LD_ADDR_EXP 35
1403: PUSH
1404: LD_STRING Khatam
1406: PPUSH
1407: LD_EXP 1
1411: NOT
1412: PPUSH
1413: CALL 434 0 2
1417: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1418: LD_ADDR_EXP 36
1422: PUSH
1423: LD_STRING Brian
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: CALL 434 0 2
1436: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1437: LD_ADDR_EXP 37
1441: PUSH
1442: LD_STRING Jerry
1444: PPUSH
1445: LD_EXP 1
1449: NOT
1450: PPUSH
1451: CALL 434 0 2
1455: ST_TO_ADDR
// if Bobby then
1456: LD_EXP 32
1460: IFFALSE 1491
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1462: LD_ADDR_VAR 0 4
1466: PUSH
1467: LD_VAR 0 4
1471: PPUSH
1472: LD_VAR 0 4
1476: PUSH
1477: LD_INT 1
1479: PLUS
1480: PPUSH
1481: LD_EXP 32
1485: PPUSH
1486: CALL_OW 2
1490: ST_TO_ADDR
// if Cyrus then
1491: LD_EXP 33
1495: IFFALSE 1526
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1497: LD_ADDR_VAR 0 4
1501: PUSH
1502: LD_VAR 0 4
1506: PPUSH
1507: LD_VAR 0 4
1511: PUSH
1512: LD_INT 1
1514: PLUS
1515: PPUSH
1516: LD_EXP 33
1520: PPUSH
1521: CALL_OW 2
1525: ST_TO_ADDR
// if Lisa then
1526: LD_EXP 34
1530: IFFALSE 1561
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1532: LD_ADDR_VAR 0 4
1536: PUSH
1537: LD_VAR 0 4
1541: PPUSH
1542: LD_VAR 0 4
1546: PUSH
1547: LD_INT 1
1549: PLUS
1550: PPUSH
1551: LD_EXP 34
1555: PPUSH
1556: CALL_OW 2
1560: ST_TO_ADDR
// if Khatam then
1561: LD_EXP 35
1565: IFFALSE 1596
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1567: LD_ADDR_VAR 0 4
1571: PUSH
1572: LD_VAR 0 4
1576: PPUSH
1577: LD_VAR 0 4
1581: PUSH
1582: LD_INT 1
1584: PLUS
1585: PPUSH
1586: LD_EXP 35
1590: PPUSH
1591: CALL_OW 2
1595: ST_TO_ADDR
// if Brian then
1596: LD_EXP 36
1600: IFFALSE 1631
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1602: LD_ADDR_VAR 0 4
1606: PUSH
1607: LD_VAR 0 4
1611: PPUSH
1612: LD_VAR 0 4
1616: PUSH
1617: LD_INT 1
1619: PLUS
1620: PPUSH
1621: LD_EXP 36
1625: PPUSH
1626: CALL_OW 2
1630: ST_TO_ADDR
// if Jerry then
1631: LD_EXP 37
1635: IFFALSE 1666
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1637: LD_ADDR_VAR 0 4
1641: PUSH
1642: LD_VAR 0 4
1646: PPUSH
1647: LD_VAR 0 4
1651: PUSH
1652: LD_INT 1
1654: PLUS
1655: PPUSH
1656: LD_EXP 37
1660: PPUSH
1661: CALL_OW 2
1665: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1666: LD_STRING 02_other_survivors
1668: PPUSH
1669: CALL_OW 28
1673: IFFALSE 1688
// others := CreateCharacterSet ( 02_other_survivors ) ;
1675: LD_ADDR_VAR 0 5
1679: PUSH
1680: LD_STRING 02_other_survivors
1682: PPUSH
1683: CALL_OW 31
1687: ST_TO_ADDR
// if others then
1688: LD_VAR 0 5
1692: IFFALSE 1717
// begin tmp := tmp ^ others ;
1694: LD_ADDR_VAR 0 4
1698: PUSH
1699: LD_VAR 0 4
1703: PUSH
1704: LD_VAR 0 5
1708: ADD
1709: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1710: LD_STRING 02_other_survivors
1712: PPUSH
1713: CALL_OW 40
// end ; jmm_units := tmp ;
1717: LD_ADDR_EXP 2
1721: PUSH
1722: LD_VAR 0 4
1726: ST_TO_ADDR
// if not vehicles then
1727: LD_VAR 0 6
1731: NOT
1732: IFFALSE 1750
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1734: LD_ADDR_VAR 0 6
1738: PUSH
1739: LD_STRING 02_tanks_1
1741: PPUSH
1742: LD_INT 0
1744: PPUSH
1745: CALL_OW 30
1749: ST_TO_ADDR
// if vehicles then
1750: LD_VAR 0 6
1754: IFFALSE 1948
// begin got_mech := false ;
1756: LD_ADDR_VAR 0 7
1760: PUSH
1761: LD_INT 0
1763: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1764: LD_VAR 0 4
1768: PPUSH
1769: LD_INT 25
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PPUSH
1779: CALL_OW 72
1783: IFFALSE 1793
// got_mech := true ;
1785: LD_ADDR_VAR 0 7
1789: PUSH
1790: LD_INT 1
1792: ST_TO_ADDR
// for i = 1 to vehicles do
1793: LD_ADDR_VAR 0 2
1797: PUSH
1798: DOUBLE
1799: LD_INT 1
1801: DEC
1802: ST_TO_ADDR
1803: LD_VAR 0 6
1807: PUSH
1808: FOR_TO
1809: IFFALSE 1946
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1811: LD_ADDR_VAR 0 3
1815: PUSH
1816: LD_INT 1
1818: PPUSH
1819: LD_INT 3
1821: PPUSH
1822: LD_VAR 0 6
1826: PUSH
1827: LD_VAR 0 2
1831: ARRAY
1832: PUSH
1833: LD_INT 1
1835: ARRAY
1836: PPUSH
1837: LD_VAR 0 6
1841: PUSH
1842: LD_VAR 0 2
1846: ARRAY
1847: PUSH
1848: LD_INT 2
1850: ARRAY
1851: PPUSH
1852: LD_VAR 0 6
1856: PUSH
1857: LD_VAR 0 2
1861: ARRAY
1862: PUSH
1863: LD_INT 3
1865: ARRAY
1866: PPUSH
1867: LD_VAR 0 6
1871: PUSH
1872: LD_VAR 0 2
1876: ARRAY
1877: PUSH
1878: LD_INT 4
1880: ARRAY
1881: PPUSH
1882: LD_INT 40
1884: PPUSH
1885: CALL 491 0 7
1889: ST_TO_ADDR
// if not got_mech then
1890: LD_VAR 0 7
1894: NOT
1895: IFFALSE 1921
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1897: LD_VAR 0 3
1901: PPUSH
1902: LD_VAR 0 6
1906: PUSH
1907: LD_VAR 0 2
1911: ARRAY
1912: PUSH
1913: LD_INT 6
1915: ARRAY
1916: PPUSH
1917: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1921: LD_ADDR_VAR 0 4
1925: PUSH
1926: LD_VAR 0 4
1930: PPUSH
1931: LD_INT 1
1933: PPUSH
1934: LD_VAR 0 3
1938: PPUSH
1939: CALL_OW 2
1943: ST_TO_ADDR
// end ;
1944: GO 1808
1946: POP
1947: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1948: LD_EXP 31
1952: PPUSH
1953: LD_INT 194
1955: PPUSH
1956: LD_INT 119
1958: PPUSH
1959: LD_INT 0
1961: PPUSH
1962: CALL_OW 48
// if tmp then
1966: LD_VAR 0 4
1970: IFFALSE 2095
// begin for i in tmp do
1972: LD_ADDR_VAR 0 2
1976: PUSH
1977: LD_VAR 0 4
1981: PUSH
1982: FOR_IN
1983: IFFALSE 2093
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1985: LD_ADDR_VAR 0 8
1989: PUSH
1990: LD_INT 22
1992: PUSH
1993: LD_INT 1
1995: PUSH
1996: EMPTY
1997: LIST
1998: LIST
1999: PUSH
2000: LD_INT 21
2002: PUSH
2003: LD_INT 2
2005: PUSH
2006: EMPTY
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 58
2012: PUSH
2013: EMPTY
2014: LIST
2015: PUSH
2016: EMPTY
2017: LIST
2018: LIST
2019: LIST
2020: PPUSH
2021: CALL_OW 69
2025: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2026: LD_VAR 0 2
2030: PPUSH
2031: CALL_OW 247
2035: PUSH
2036: LD_INT 1
2038: EQUAL
2039: PUSH
2040: LD_VAR 0 8
2044: AND
2045: IFFALSE 2067
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2047: LD_VAR 0 2
2051: PPUSH
2052: LD_VAR 0 8
2056: PUSH
2057: LD_INT 1
2059: ARRAY
2060: PPUSH
2061: CALL_OW 52
2065: GO 2082
// PlaceUnitArea ( i , startArea , false ) ;
2067: LD_VAR 0 2
2071: PPUSH
2072: LD_INT 1
2074: PPUSH
2075: LD_INT 0
2077: PPUSH
2078: CALL_OW 49
// ComHold ( i ) ;
2082: LD_VAR 0 2
2086: PPUSH
2087: CALL_OW 140
// end ;
2091: GO 1982
2093: POP
2094: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2095: LD_ADDR_EXP 5
2099: PUSH
2100: LD_STRING 02_mikhailStatus_1
2102: PPUSH
2103: LD_INT 0
2105: PPUSH
2106: CALL_OW 30
2110: ST_TO_ADDR
// if not bierezov_exist and not debug then
2111: LD_EXP 5
2115: NOT
2116: PUSH
2117: LD_EXP 1
2121: NOT
2122: AND
2123: IFFALSE 2127
// exit ;
2125: GO 2158
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2127: LD_ADDR_EXP 39
2131: PUSH
2132: LD_STRING Mikhail
2134: PPUSH
2135: LD_INT 0
2137: PPUSH
2138: CALL 434 0 2
2142: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2143: LD_EXP 39
2147: PPUSH
2148: LD_INT 1
2150: PPUSH
2151: LD_INT 0
2153: PPUSH
2154: CALL_OW 49
// end ;
2158: LD_VAR 0 1
2162: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2163: LD_INT 0
2165: PPUSH
2166: PPUSH
2167: PPUSH
2168: PPUSH
// uc_side := 4 ;
2169: LD_ADDR_OWVAR 20
2173: PUSH
2174: LD_INT 4
2176: ST_TO_ADDR
// uc_nation := 1 ;
2177: LD_ADDR_OWVAR 21
2181: PUSH
2182: LD_INT 1
2184: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2185: LD_ADDR_EXP 38
2189: PUSH
2190: LD_STRING Cornell
2192: PPUSH
2193: LD_INT 0
2195: PPUSH
2196: CALL 434 0 2
2200: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
2201: LD_ADDR_EXP 4
2205: PUSH
2206: LD_INT 8
2208: PUSH
2209: LD_EXP 2
2213: MINUS
2214: ST_TO_ADDR
// tmp := [ ] ;
2215: LD_ADDR_VAR 0 2
2219: PUSH
2220: EMPTY
2221: ST_TO_ADDR
// if cornel_units < 3 then
2222: LD_EXP 4
2226: PUSH
2227: LD_INT 3
2229: LESS
2230: IFFALSE 2240
// cornel_units := 3 ;
2232: LD_ADDR_EXP 4
2236: PUSH
2237: LD_INT 3
2239: ST_TO_ADDR
// for i = 1 to cornel_units do
2240: LD_ADDR_VAR 0 4
2244: PUSH
2245: DOUBLE
2246: LD_INT 1
2248: DEC
2249: ST_TO_ADDR
2250: LD_EXP 4
2254: PUSH
2255: FOR_TO
2256: IFFALSE 2354
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2258: LD_INT 0
2260: PPUSH
2261: LD_INT 1
2263: PUSH
2264: LD_INT 1
2266: PUSH
2267: LD_INT 1
2269: PUSH
2270: LD_INT 2
2272: PUSH
2273: LD_INT 4
2275: PUSH
2276: EMPTY
2277: LIST
2278: LIST
2279: LIST
2280: LIST
2281: LIST
2282: PUSH
2283: LD_VAR 0 4
2287: PUSH
2288: LD_INT 5
2290: MOD
2291: PUSH
2292: LD_INT 1
2294: PLUS
2295: ARRAY
2296: PPUSH
2297: LD_INT 2
2299: PPUSH
2300: CALL_OW 380
// un := CreateHuman ;
2304: LD_ADDR_VAR 0 3
2308: PUSH
2309: CALL_OW 44
2313: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2314: LD_ADDR_VAR 0 2
2318: PUSH
2319: LD_VAR 0 2
2323: PPUSH
2324: LD_INT 1
2326: PPUSH
2327: LD_VAR 0 3
2331: PPUSH
2332: CALL_OW 2
2336: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2337: LD_VAR 0 3
2341: PPUSH
2342: LD_INT 2
2344: PPUSH
2345: LD_INT 0
2347: PPUSH
2348: CALL_OW 49
// end ;
2352: GO 2255
2354: POP
2355: POP
// cornel_units := tmp ;
2356: LD_ADDR_EXP 4
2360: PUSH
2361: LD_VAR 0 2
2365: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2366: LD_EXP 38
2370: PPUSH
2371: LD_INT 191
2373: PPUSH
2374: LD_INT 106
2376: PPUSH
2377: LD_INT 0
2379: PPUSH
2380: CALL_OW 48
// end ;
2384: LD_VAR 0 1
2388: RET
// export function PrepareWesternBase ; var i ; begin
2389: LD_INT 0
2391: PPUSH
2392: PPUSH
// uc_side := 8 ;
2393: LD_ADDR_OWVAR 20
2397: PUSH
2398: LD_INT 8
2400: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2401: LD_ADDR_EXP 41
2405: PUSH
2406: LD_STRING Lynch
2408: PPUSH
2409: LD_INT 0
2411: PPUSH
2412: CALL 434 0 2
2416: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2417: LD_ADDR_EXP 42
2421: PUSH
2422: LD_STRING Walker
2424: PPUSH
2425: LD_INT 0
2427: PPUSH
2428: CALL 434 0 2
2432: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2433: LD_ADDR_EXP 43
2437: PUSH
2438: LD_STRING Turner
2440: PPUSH
2441: LD_INT 0
2443: PPUSH
2444: CALL 434 0 2
2448: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2449: LD_ADDR_EXP 44
2453: PUSH
2454: LD_STRING Jillian
2456: PPUSH
2457: LD_INT 0
2459: PPUSH
2460: CALL 434 0 2
2464: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2465: LD_ADDR_VAR 0 2
2469: PUSH
2470: LD_EXP 41
2474: PUSH
2475: LD_EXP 42
2479: PUSH
2480: LD_EXP 43
2484: PUSH
2485: LD_EXP 44
2489: PUSH
2490: EMPTY
2491: LIST
2492: LIST
2493: LIST
2494: LIST
2495: PUSH
2496: FOR_IN
2497: IFFALSE 2525
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2499: LD_VAR 0 2
2503: PPUSH
2504: LD_INT 3
2506: PPUSH
2507: LD_INT 0
2509: PPUSH
2510: CALL_OW 49
// ComHold ( i ) ;
2514: LD_VAR 0 2
2518: PPUSH
2519: CALL_OW 140
// end ;
2523: GO 2496
2525: POP
2526: POP
// end ;
2527: LD_VAR 0 1
2531: RET
// export function SelectGroup ; var units , selected , i ; begin
2532: LD_INT 0
2534: PPUSH
2535: PPUSH
2536: PPUSH
2537: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2538: LD_ADDR_VAR 0 2
2542: PUSH
2543: LD_EXP 31
2547: PUSH
2548: LD_INT -3
2550: PUSH
2551: EMPTY
2552: LIST
2553: LIST
2554: PUSH
2555: LD_EXP 2
2559: ADD
2560: PUSH
2561: LD_INT -2
2563: PUSH
2564: LD_INT -4
2566: PUSH
2567: LD_EXP 38
2571: PUSH
2572: LD_EXP 39
2576: PUSH
2577: EMPTY
2578: LIST
2579: LIST
2580: LIST
2581: LIST
2582: ADD
2583: PUSH
2584: LD_INT -3
2586: PUSH
2587: EMPTY
2588: LIST
2589: ADD
2590: PUSH
2591: LD_EXP 4
2595: ADD
2596: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2597: LD_ADDR_VAR 0 3
2601: PUSH
2602: LD_EXP 31
2606: PUSH
2607: LD_STRING Select five characters to go with you
2609: PPUSH
2610: LD_INT 4
2612: PPUSH
2613: LD_INT 4
2615: PPUSH
2616: LD_VAR 0 2
2620: PPUSH
2621: EMPTY
2622: PPUSH
2623: CALL_OW 42
2627: ADD
2628: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2629: LD_ADDR_EXP 4
2633: PUSH
2634: LD_EXP 2
2638: PUSH
2639: LD_EXP 4
2643: UNION
2644: PUSH
2645: LD_VAR 0 3
2649: DIFF
2650: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2651: LD_ADDR_VAR 0 4
2655: PUSH
2656: LD_EXP 4
2660: PUSH
2661: LD_EXP 39
2665: ADD
2666: PUSH
2667: FOR_IN
2668: IFFALSE 2699
// if GetSide ( i ) = 1 then
2670: LD_VAR 0 4
2674: PPUSH
2675: CALL_OW 255
2679: PUSH
2680: LD_INT 1
2682: EQUAL
2683: IFFALSE 2697
// SetSide ( i , 4 ) ;
2685: LD_VAR 0 4
2689: PPUSH
2690: LD_INT 4
2692: PPUSH
2693: CALL_OW 235
2697: GO 2667
2699: POP
2700: POP
// for i in selected do
2701: LD_ADDR_VAR 0 4
2705: PUSH
2706: LD_VAR 0 3
2710: PUSH
2711: FOR_IN
2712: IFFALSE 2743
// if GetSide ( i ) = 4 then
2714: LD_VAR 0 4
2718: PPUSH
2719: CALL_OW 255
2723: PUSH
2724: LD_INT 4
2726: EQUAL
2727: IFFALSE 2741
// SetSide ( i , 1 ) ;
2729: LD_VAR 0 4
2733: PPUSH
2734: LD_INT 1
2736: PPUSH
2737: CALL_OW 235
2741: GO 2711
2743: POP
2744: POP
// jmm_units := jmm_units diff cornel_units ;
2745: LD_ADDR_EXP 2
2749: PUSH
2750: LD_EXP 2
2754: PUSH
2755: LD_EXP 4
2759: DIFF
2760: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2761: LD_EXP 32
2765: PPUSH
2766: CALL_OW 255
2770: PUSH
2771: LD_INT 4
2773: EQUAL
2774: IFFALSE 2783
// DeleteCharacters ( Bobby ) ;
2776: LD_STRING Bobby
2778: PPUSH
2779: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2783: LD_EXP 33
2787: PPUSH
2788: CALL_OW 255
2792: PUSH
2793: LD_INT 4
2795: EQUAL
2796: IFFALSE 2805
// DeleteCharacters ( Cyrus ) ;
2798: LD_STRING Cyrus
2800: PPUSH
2801: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2805: LD_EXP 34
2809: PPUSH
2810: CALL_OW 255
2814: PUSH
2815: LD_INT 4
2817: EQUAL
2818: IFFALSE 2827
// DeleteCharacters ( Lisa ) ;
2820: LD_STRING Lisa
2822: PPUSH
2823: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2827: LD_EXP 35
2831: PPUSH
2832: CALL_OW 255
2836: PUSH
2837: LD_INT 4
2839: EQUAL
2840: IFFALSE 2849
// DeleteCharacters ( Khatam ) ;
2842: LD_STRING Khatam
2844: PPUSH
2845: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2849: LD_EXP 36
2853: PPUSH
2854: CALL_OW 255
2858: PUSH
2859: LD_INT 4
2861: EQUAL
2862: IFFALSE 2871
// DeleteCharacters ( Brian ) ;
2864: LD_STRING Brian
2866: PPUSH
2867: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2871: LD_EXP 37
2875: PPUSH
2876: CALL_OW 255
2880: PUSH
2881: LD_INT 4
2883: EQUAL
2884: IFFALSE 2893
// DeleteCharacters ( Jerry ) ;
2886: LD_STRING Jerry
2888: PPUSH
2889: CALL_OW 40
// end ; end_of_file
2893: LD_VAR 0 1
2897: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
2898: LD_INT 0
2900: PPUSH
2901: PPUSH
2902: PPUSH
2903: PPUSH
2904: PPUSH
2905: PPUSH
2906: PPUSH
2907: PPUSH
2908: PPUSH
2909: PPUSH
2910: PPUSH
2911: PPUSH
2912: PPUSH
// ru_alert := false ;
2913: LD_ADDR_EXP 54
2917: PUSH
2918: LD_INT 0
2920: ST_TO_ADDR
// ru_produce_list := [ ] ;
2921: LD_ADDR_EXP 51
2925: PUSH
2926: EMPTY
2927: ST_TO_ADDR
// if Difficulty > 1 then
2928: LD_OWVAR 67
2932: PUSH
2933: LD_INT 1
2935: GREATER
2936: IFFALSE 3024
// begin uc_side := 3 ;
2938: LD_ADDR_OWVAR 20
2942: PUSH
2943: LD_INT 3
2945: ST_TO_ADDR
// uc_nation := 3 ;
2946: LD_ADDR_OWVAR 21
2950: PUSH
2951: LD_INT 3
2953: ST_TO_ADDR
// bc_type := b_breastwork ;
2954: LD_ADDR_OWVAR 42
2958: PUSH
2959: LD_INT 31
2961: ST_TO_ADDR
// bc_level := Difficulty ;
2962: LD_ADDR_OWVAR 43
2966: PUSH
2967: LD_OWVAR 67
2971: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
2972: LD_INT 22
2974: PPUSH
2975: LD_INT 14
2977: PPUSH
2978: LD_INT 0
2980: PPUSH
2981: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
2985: LD_INT 48
2987: PPUSH
2988: LD_INT 46
2990: PPUSH
2991: LD_INT 0
2993: PPUSH
2994: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
2998: LD_INT 86
3000: PPUSH
3001: LD_INT 65
3003: PPUSH
3004: LD_INT 5
3006: PPUSH
3007: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3011: LD_INT 165
3013: PPUSH
3014: LD_INT 73
3016: PPUSH
3017: LD_INT 5
3019: PPUSH
3020: CALL_OW 47
// end ; tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3024: LD_ADDR_VAR 0 7
3028: PUSH
3029: LD_INT 22
3031: PUSH
3032: LD_INT 3
3034: PUSH
3035: EMPTY
3036: LIST
3037: LIST
3038: PUSH
3039: LD_INT 2
3041: PUSH
3042: LD_INT 30
3044: PUSH
3045: LD_INT 31
3047: PUSH
3048: EMPTY
3049: LIST
3050: LIST
3051: PUSH
3052: LD_INT 30
3054: PUSH
3055: LD_INT 32
3057: PUSH
3058: EMPTY
3059: LIST
3060: LIST
3061: PUSH
3062: EMPTY
3063: LIST
3064: LIST
3065: LIST
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: PPUSH
3071: CALL_OW 69
3075: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3076: LD_ADDR_VAR 0 8
3080: PUSH
3081: LD_INT 22
3083: PUSH
3084: LD_INT 3
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 30
3093: PUSH
3094: LD_INT 4
3096: PUSH
3097: EMPTY
3098: LIST
3099: LIST
3100: PUSH
3101: EMPTY
3102: LIST
3103: LIST
3104: PPUSH
3105: CALL_OW 69
3109: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3110: LD_ADDR_VAR 0 10
3114: PUSH
3115: LD_INT 22
3117: PUSH
3118: LD_INT 3
3120: PUSH
3121: EMPTY
3122: LIST
3123: LIST
3124: PUSH
3125: LD_INT 30
3127: PUSH
3128: LD_INT 3
3130: PUSH
3131: EMPTY
3132: LIST
3133: LIST
3134: PUSH
3135: EMPTY
3136: LIST
3137: LIST
3138: PPUSH
3139: CALL_OW 69
3143: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3144: LD_ADDR_VAR 0 9
3148: PUSH
3149: LD_INT 22
3151: PUSH
3152: LD_INT 3
3154: PUSH
3155: EMPTY
3156: LIST
3157: LIST
3158: PUSH
3159: LD_INT 30
3161: PUSH
3162: LD_INT 6
3164: PUSH
3165: EMPTY
3166: LIST
3167: LIST
3168: PUSH
3169: EMPTY
3170: LIST
3171: LIST
3172: PPUSH
3173: CALL_OW 69
3177: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3178: LD_ADDR_VAR 0 2
3182: PUSH
3183: LD_INT 22
3185: PUSH
3186: LD_INT 3
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: PUSH
3193: LD_INT 30
3195: PUSH
3196: LD_INT 1
3198: PUSH
3199: EMPTY
3200: LIST
3201: LIST
3202: PUSH
3203: EMPTY
3204: LIST
3205: LIST
3206: PPUSH
3207: CALL_OW 69
3211: PUSH
3212: FOR_IN
3213: IFFALSE 3257
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3215: LD_VAR 0 2
3219: PPUSH
3220: CALL_OW 274
3224: PPUSH
3225: LD_INT 1
3227: PPUSH
3228: LD_INT 5000
3230: PPUSH
3231: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3235: LD_VAR 0 2
3239: PPUSH
3240: CALL_OW 274
3244: PPUSH
3245: LD_INT 2
3247: PPUSH
3248: LD_INT 3000
3250: PPUSH
3251: CALL_OW 277
// end ;
3255: GO 3212
3257: POP
3258: POP
// uc_side := 3 ;
3259: LD_ADDR_OWVAR 20
3263: PUSH
3264: LD_INT 3
3266: ST_TO_ADDR
// uc_nation := 3 ;
3267: LD_ADDR_OWVAR 21
3271: PUSH
3272: LD_INT 3
3274: ST_TO_ADDR
// skill := [ 2 , 2 , 3 ] [ Difficulty ] ;
3275: LD_ADDR_VAR 0 11
3279: PUSH
3280: LD_INT 2
3282: PUSH
3283: LD_INT 2
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: EMPTY
3290: LIST
3291: LIST
3292: LIST
3293: PUSH
3294: LD_OWVAR 67
3298: ARRAY
3299: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3300: LD_ADDR_EXP 46
3304: PUSH
3305: LD_STRING Pokryshkin
3307: PPUSH
3308: LD_INT 0
3310: PPUSH
3311: CALL 434 0 2
3315: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3316: LD_EXP 46
3320: PPUSH
3321: LD_INT 63
3323: PPUSH
3324: LD_INT 21
3326: PPUSH
3327: LD_INT 0
3329: PPUSH
3330: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3334: LD_EXP 46
3338: PPUSH
3339: CALL_OW 140
// InitHc ;
3343: CALL_OW 19
// for i in fac do
3347: LD_ADDR_VAR 0 2
3351: PUSH
3352: LD_VAR 0 10
3356: PUSH
3357: FOR_IN
3358: IFFALSE 3411
// begin for j = 1 to 6 do
3360: LD_ADDR_VAR 0 3
3364: PUSH
3365: DOUBLE
3366: LD_INT 1
3368: DEC
3369: ST_TO_ADDR
3370: LD_INT 6
3372: PUSH
3373: FOR_TO
3374: IFFALSE 3407
// begin PrepareHuman ( false , 3 , skill ) ;
3376: LD_INT 0
3378: PPUSH
3379: LD_INT 3
3381: PPUSH
3382: LD_VAR 0 11
3386: PPUSH
3387: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3391: CALL_OW 44
3395: PPUSH
3396: LD_VAR 0 2
3400: PPUSH
3401: CALL_OW 52
// end ;
3405: GO 3373
3407: POP
3408: POP
// end ;
3409: GO 3357
3411: POP
3412: POP
// for i in lab do
3413: LD_ADDR_VAR 0 2
3417: PUSH
3418: LD_VAR 0 9
3422: PUSH
3423: FOR_IN
3424: IFFALSE 3457
// begin PrepareHuman ( false , 4 , skill ) ;
3426: LD_INT 0
3428: PPUSH
3429: LD_INT 4
3431: PPUSH
3432: LD_VAR 0 11
3436: PPUSH
3437: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3441: CALL_OW 44
3445: PPUSH
3446: LD_VAR 0 2
3450: PPUSH
3451: CALL_OW 52
// end ;
3455: GO 3423
3457: POP
3458: POP
// for i in tw do
3459: LD_ADDR_VAR 0 2
3463: PUSH
3464: LD_VAR 0 7
3468: PUSH
3469: FOR_IN
3470: IFFALSE 3519
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3472: LD_VAR 0 2
3476: PPUSH
3477: LD_INT 42
3479: PUSH
3480: LD_INT 43
3482: PUSH
3483: EMPTY
3484: LIST
3485: LIST
3486: PUSH
3487: LD_INT 1
3489: PPUSH
3490: LD_INT 2
3492: PPUSH
3493: CALL_OW 12
3497: ARRAY
3498: PPUSH
3499: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3503: LD_VAR 0 11
3507: PPUSH
3508: LD_VAR 0 2
3512: PPUSH
3513: CALL 769 0 2
// end ;
3517: GO 3469
3519: POP
3520: POP
// for i in bar do
3521: LD_ADDR_VAR 0 2
3525: PUSH
3526: LD_VAR 0 8
3530: PUSH
3531: FOR_IN
3532: IFFALSE 3565
// begin PrepareHuman ( false , 1 , skill ) ;
3534: LD_INT 0
3536: PPUSH
3537: LD_INT 1
3539: PPUSH
3540: LD_VAR 0 11
3544: PPUSH
3545: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3549: CALL_OW 44
3553: PPUSH
3554: LD_VAR 0 2
3558: PPUSH
3559: CALL_OW 52
// end ;
3563: GO 3531
3565: POP
3566: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3567: LD_ADDR_VAR 0 13
3571: PUSH
3572: LD_INT 100
3574: PUSH
3575: LD_INT 9
3577: PUSH
3578: EMPTY
3579: LIST
3580: LIST
3581: PUSH
3582: LD_INT 135
3584: PUSH
3585: LD_INT 60
3587: PUSH
3588: EMPTY
3589: LIST
3590: LIST
3591: PUSH
3592: LD_INT 41
3594: PUSH
3595: LD_INT 6
3597: PUSH
3598: EMPTY
3599: LIST
3600: LIST
3601: PUSH
3602: LD_INT 22
3604: PUSH
3605: LD_INT 9
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: PUSH
3612: LD_INT 84
3614: PUSH
3615: LD_INT 14
3617: PUSH
3618: EMPTY
3619: LIST
3620: LIST
3621: PUSH
3622: EMPTY
3623: LIST
3624: LIST
3625: LIST
3626: LIST
3627: LIST
3628: ST_TO_ADDR
// vehicles := [ ] ;
3629: LD_ADDR_VAR 0 12
3633: PUSH
3634: EMPTY
3635: ST_TO_ADDR
// for i in spot_xy do
3636: LD_ADDR_VAR 0 2
3640: PUSH
3641: LD_VAR 0 13
3645: PUSH
3646: FOR_IN
3647: IFFALSE 3805
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3649: LD_ADDR_VAR 0 6
3653: PUSH
3654: LD_INT 3
3656: PPUSH
3657: LD_INT 3
3659: PPUSH
3660: LD_INT 22
3662: PPUSH
3663: LD_INT 1
3665: PPUSH
3666: LD_INT 1
3668: PPUSH
3669: LD_INT 42
3671: PUSH
3672: LD_INT 43
3674: PUSH
3675: LD_INT 44
3677: PUSH
3678: EMPTY
3679: LIST
3680: LIST
3681: LIST
3682: PUSH
3683: LD_INT 1
3685: PPUSH
3686: LD_INT 3
3688: PPUSH
3689: CALL_OW 12
3693: ARRAY
3694: PPUSH
3695: LD_INT 100
3697: PPUSH
3698: CALL 491 0 7
3702: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3703: LD_ADDR_VAR 0 12
3707: PUSH
3708: LD_VAR 0 12
3712: PPUSH
3713: LD_VAR 0 12
3717: PUSH
3718: LD_INT 1
3720: PLUS
3721: PPUSH
3722: LD_VAR 0 6
3726: PPUSH
3727: CALL_OW 2
3731: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3732: LD_VAR 0 6
3736: PPUSH
3737: LD_INT 3
3739: PPUSH
3740: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3744: LD_VAR 0 6
3748: PPUSH
3749: LD_VAR 0 2
3753: PUSH
3754: LD_INT 1
3756: ARRAY
3757: PPUSH
3758: LD_VAR 0 2
3762: PUSH
3763: LD_INT 2
3765: ARRAY
3766: PPUSH
3767: LD_INT 0
3769: PPUSH
3770: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3774: LD_INT 0
3776: PPUSH
3777: LD_INT 3
3779: PPUSH
3780: LD_VAR 0 11
3784: PPUSH
3785: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3789: CALL_OW 44
3793: PPUSH
3794: LD_VAR 0 6
3798: PPUSH
3799: CALL_OW 52
// end ;
3803: GO 3646
3805: POP
3806: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3807: LD_ADDR_VAR 0 2
3811: PUSH
3812: DOUBLE
3813: LD_INT 1
3815: DEC
3816: ST_TO_ADDR
3817: LD_INT 5
3819: PUSH
3820: LD_INT 7
3822: PUSH
3823: LD_INT 8
3825: PUSH
3826: EMPTY
3827: LIST
3828: LIST
3829: LIST
3830: PUSH
3831: LD_OWVAR 67
3835: ARRAY
3836: PUSH
3837: FOR_TO
3838: IFFALSE 3898
// begin PrepareHuman ( false , 1 , skill ) ;
3840: LD_INT 0
3842: PPUSH
3843: LD_INT 1
3845: PPUSH
3846: LD_VAR 0 11
3850: PPUSH
3851: CALL_OW 380
// un := CreateHuman ;
3855: LD_ADDR_VAR 0 5
3859: PUSH
3860: CALL_OW 44
3864: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3865: LD_VAR 0 5
3869: PPUSH
3870: LD_INT 11
3872: PPUSH
3873: LD_INT 0
3875: PPUSH
3876: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3880: LD_ADDR_EXP 49
3884: PUSH
3885: LD_EXP 49
3889: PUSH
3890: LD_VAR 0 5
3894: ADD
3895: ST_TO_ADDR
// end ;
3896: GO 3837
3898: POP
3899: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3900: LD_ADDR_VAR 0 2
3904: PUSH
3905: DOUBLE
3906: LD_INT 1
3908: DEC
3909: ST_TO_ADDR
3910: LD_INT 2
3912: PUSH
3913: LD_INT 3
3915: PUSH
3916: LD_INT 4
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: LIST
3923: PUSH
3924: LD_OWVAR 67
3928: ARRAY
3929: PUSH
3930: FOR_TO
3931: IFFALSE 3991
// begin PrepareHuman ( false , 1 , skill ) ;
3933: LD_INT 0
3935: PPUSH
3936: LD_INT 1
3938: PPUSH
3939: LD_VAR 0 11
3943: PPUSH
3944: CALL_OW 380
// un := CreateHuman ;
3948: LD_ADDR_VAR 0 5
3952: PUSH
3953: CALL_OW 44
3957: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
3958: LD_VAR 0 5
3962: PPUSH
3963: LD_INT 12
3965: PPUSH
3966: LD_INT 0
3968: PPUSH
3969: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
3973: LD_ADDR_EXP 47
3977: PUSH
3978: LD_EXP 47
3982: PUSH
3983: LD_VAR 0 5
3987: ADD
3988: ST_TO_ADDR
// end ;
3989: GO 3930
3991: POP
3992: POP
// for i = 1 to 2 do
3993: LD_ADDR_VAR 0 2
3997: PUSH
3998: DOUBLE
3999: LD_INT 1
4001: DEC
4002: ST_TO_ADDR
4003: LD_INT 2
4005: PUSH
4006: FOR_TO
4007: IFFALSE 4073
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4009: LD_INT 1
4011: PPUSH
4012: LD_INT 1
4014: PPUSH
4015: LD_VAR 0 11
4019: PPUSH
4020: CALL_OW 380
// un := CreateHuman ;
4024: LD_ADDR_VAR 0 5
4028: PUSH
4029: CALL_OW 44
4033: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4034: LD_VAR 0 5
4038: PPUSH
4039: LD_INT 39
4041: PPUSH
4042: LD_INT 12
4044: PPUSH
4045: LD_INT 3
4047: PPUSH
4048: LD_INT 0
4050: PPUSH
4051: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4055: LD_ADDR_EXP 48
4059: PUSH
4060: LD_EXP 48
4064: PUSH
4065: LD_VAR 0 5
4069: ADD
4070: ST_TO_ADDR
// end ;
4071: GO 4006
4073: POP
4074: POP
// for i = 1 to 3 do
4075: LD_ADDR_VAR 0 2
4079: PUSH
4080: DOUBLE
4081: LD_INT 1
4083: DEC
4084: ST_TO_ADDR
4085: LD_INT 3
4087: PUSH
4088: FOR_TO
4089: IFFALSE 4155
// begin PrepareHuman ( false , 1 , skill ) ;
4091: LD_INT 0
4093: PPUSH
4094: LD_INT 1
4096: PPUSH
4097: LD_VAR 0 11
4101: PPUSH
4102: CALL_OW 380
// un := CreateHuman ;
4106: LD_ADDR_VAR 0 5
4110: PUSH
4111: CALL_OW 44
4115: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4116: LD_VAR 0 5
4120: PPUSH
4121: LD_INT 180
4123: PPUSH
4124: LD_INT 11
4126: PPUSH
4127: LD_INT 4
4129: PPUSH
4130: LD_INT 0
4132: PPUSH
4133: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4137: LD_ADDR_EXP 52
4141: PUSH
4142: LD_EXP 52
4146: PUSH
4147: LD_VAR 0 5
4151: ADD
4152: ST_TO_ADDR
// end ;
4153: GO 4088
4155: POP
4156: POP
// ru_vehicles := vehicles ;
4157: LD_ADDR_EXP 50
4161: PUSH
4162: LD_VAR 0 12
4166: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4167: LD_ADDR_EXP 53
4171: PUSH
4172: LD_INT 131
4174: PUSH
4175: LD_INT 121
4177: PUSH
4178: EMPTY
4179: LIST
4180: LIST
4181: PUSH
4182: LD_INT 113
4184: PUSH
4185: LD_INT 90
4187: PUSH
4188: EMPTY
4189: LIST
4190: LIST
4191: PUSH
4192: LD_INT 93
4194: PUSH
4195: LD_INT 62
4197: PUSH
4198: EMPTY
4199: LIST
4200: LIST
4201: PUSH
4202: EMPTY
4203: LIST
4204: LIST
4205: LIST
4206: PUSH
4207: LD_INT 106
4209: PUSH
4210: LD_INT 54
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: PUSH
4217: LD_INT 120
4219: PUSH
4220: LD_INT 80
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: PUSH
4227: LD_INT 143
4229: PUSH
4230: LD_INT 120
4232: PUSH
4233: EMPTY
4234: LIST
4235: LIST
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 154
4244: PUSH
4245: LD_INT 116
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: LD_INT 140
4254: PUSH
4255: LD_INT 93
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: PUSH
4262: LD_INT 130
4264: PUSH
4265: LD_INT 58
4267: PUSH
4268: EMPTY
4269: LIST
4270: LIST
4271: PUSH
4272: EMPTY
4273: LIST
4274: LIST
4275: LIST
4276: PUSH
4277: LD_INT 105
4279: PUSH
4280: LD_INT 106
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PUSH
4287: LD_INT 134
4289: PUSH
4290: LD_INT 98
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: PUSH
4297: LD_INT 159
4299: PUSH
4300: LD_INT 113
4302: PUSH
4303: EMPTY
4304: LIST
4305: LIST
4306: PUSH
4307: EMPTY
4308: LIST
4309: LIST
4310: LIST
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: LIST
4316: LIST
4317: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4318: LD_ADDR_VAR 0 2
4322: PUSH
4323: DOUBLE
4324: LD_INT 1
4326: DEC
4327: ST_TO_ADDR
4328: LD_OWVAR 67
4332: PUSH
4333: LD_INT 1
4335: MINUS
4336: PUSH
4337: FOR_TO
4338: IFFALSE 4371
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4340: LD_ADDR_EXP 51
4344: PUSH
4345: LD_EXP 51
4349: PUSH
4350: LD_INT 22
4352: PUSH
4353: LD_INT 1
4355: PUSH
4356: LD_INT 1
4358: PUSH
4359: LD_INT 43
4361: PUSH
4362: EMPTY
4363: LIST
4364: LIST
4365: LIST
4366: LIST
4367: ADD
4368: ST_TO_ADDR
4369: GO 4337
4371: POP
4372: POP
// end ;
4373: LD_VAR 0 1
4377: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4378: LD_INT 22
4380: PUSH
4381: LD_INT 3
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PUSH
4388: LD_INT 21
4390: PUSH
4391: LD_INT 2
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PPUSH
4402: CALL_OW 69
4406: IFFALSE 4500
4408: GO 4410
4410: DISABLE
4411: LD_INT 0
4413: PPUSH
4414: PPUSH
// begin enable ;
4415: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4416: LD_ADDR_VAR 0 2
4420: PUSH
4421: LD_INT 22
4423: PUSH
4424: LD_INT 3
4426: PUSH
4427: EMPTY
4428: LIST
4429: LIST
4430: PUSH
4431: LD_INT 21
4433: PUSH
4434: LD_INT 2
4436: PUSH
4437: EMPTY
4438: LIST
4439: LIST
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: PPUSH
4445: CALL_OW 69
4449: ST_TO_ADDR
// if filter then
4450: LD_VAR 0 2
4454: IFFALSE 4500
// for i in filter do
4456: LD_ADDR_VAR 0 1
4460: PUSH
4461: LD_VAR 0 2
4465: PUSH
4466: FOR_IN
4467: IFFALSE 4498
// if GetFuel ( i ) < 20 then
4469: LD_VAR 0 1
4473: PPUSH
4474: CALL_OW 261
4478: PUSH
4479: LD_INT 20
4481: LESS
4482: IFFALSE 4496
// SetFuel ( i , 20 ) ;
4484: LD_VAR 0 1
4488: PPUSH
4489: LD_INT 20
4491: PPUSH
4492: CALL_OW 240
4496: GO 4466
4498: POP
4499: POP
// end ;
4500: PPOPN 2
4502: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4503: LD_EXP 51
4507: IFFALSE 4726
4509: GO 4511
4511: DISABLE
4512: LD_INT 0
4514: PPUSH
4515: PPUSH
4516: PPUSH
// begin enable ;
4517: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4518: LD_ADDR_VAR 0 2
4522: PUSH
4523: LD_INT 22
4525: PUSH
4526: LD_INT 3
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: PUSH
4533: LD_INT 30
4535: PUSH
4536: LD_INT 3
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: PUSH
4543: EMPTY
4544: LIST
4545: LIST
4546: PPUSH
4547: CALL_OW 69
4551: ST_TO_ADDR
// can_produce := [ ] ;
4552: LD_ADDR_VAR 0 3
4556: PUSH
4557: EMPTY
4558: ST_TO_ADDR
// if not fac then
4559: LD_VAR 0 2
4563: NOT
4564: IFFALSE 4569
// begin disable ;
4566: DISABLE
// exit ;
4567: GO 4726
// end ; for i in fac do
4569: LD_ADDR_VAR 0 1
4573: PUSH
4574: LD_VAR 0 2
4578: PUSH
4579: FOR_IN
4580: IFFALSE 4618
// if UnitsInside ( i ) then
4582: LD_VAR 0 1
4586: PPUSH
4587: CALL_OW 313
4591: IFFALSE 4616
// can_produce := Insert ( can_produce , 1 , i ) ;
4593: LD_ADDR_VAR 0 3
4597: PUSH
4598: LD_VAR 0 3
4602: PPUSH
4603: LD_INT 1
4605: PPUSH
4606: LD_VAR 0 1
4610: PPUSH
4611: CALL_OW 2
4615: ST_TO_ADDR
4616: GO 4579
4618: POP
4619: POP
// if not can_produce then
4620: LD_VAR 0 3
4624: NOT
4625: IFFALSE 4629
// exit ;
4627: GO 4726
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4629: LD_VAR 0 3
4633: PUSH
4634: LD_INT 1
4636: PPUSH
4637: LD_VAR 0 3
4641: PPUSH
4642: CALL_OW 12
4646: ARRAY
4647: PPUSH
4648: LD_EXP 51
4652: PUSH
4653: LD_INT 1
4655: ARRAY
4656: PPUSH
4657: LD_EXP 51
4661: PUSH
4662: LD_INT 2
4664: ARRAY
4665: PPUSH
4666: LD_EXP 51
4670: PUSH
4671: LD_INT 3
4673: ARRAY
4674: PPUSH
4675: LD_EXP 51
4679: PUSH
4680: LD_INT 4
4682: ARRAY
4683: PPUSH
4684: CALL_OW 125
// for i = 1 to 4 do
4688: LD_ADDR_VAR 0 1
4692: PUSH
4693: DOUBLE
4694: LD_INT 1
4696: DEC
4697: ST_TO_ADDR
4698: LD_INT 4
4700: PUSH
4701: FOR_TO
4702: IFFALSE 4724
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4704: LD_ADDR_EXP 51
4708: PUSH
4709: LD_EXP 51
4713: PPUSH
4714: LD_INT 1
4716: PPUSH
4717: CALL_OW 3
4721: ST_TO_ADDR
4722: GO 4701
4724: POP
4725: POP
// end ;
4726: PPOPN 3
4728: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4729: LD_INT 0
4731: PPUSH
4732: PPUSH
4733: PPUSH
// for i = 1 to 6 do
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: DOUBLE
4740: LD_INT 1
4742: DEC
4743: ST_TO_ADDR
4744: LD_INT 6
4746: PUSH
4747: FOR_TO
4748: IFFALSE 4897
// begin PrepareHuman ( false , 3 , 3 ) ;
4750: LD_INT 0
4752: PPUSH
4753: LD_INT 3
4755: PPUSH
4756: LD_INT 3
4758: PPUSH
4759: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4763: LD_ADDR_VAR 0 3
4767: PUSH
4768: LD_INT 3
4770: PPUSH
4771: LD_INT 3
4773: PPUSH
4774: LD_INT 22
4776: PPUSH
4777: LD_INT 1
4779: PPUSH
4780: LD_INT 1
4782: PPUSH
4783: LD_INT 43
4785: PUSH
4786: LD_INT 42
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: LD_INT 1
4795: PPUSH
4796: LD_INT 2
4798: PPUSH
4799: CALL_OW 12
4803: ARRAY
4804: PPUSH
4805: LD_INT 70
4807: PPUSH
4808: CALL 491 0 7
4812: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4813: LD_VAR 0 3
4817: PPUSH
4818: LD_INT 4
4820: PPUSH
4821: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4825: LD_VAR 0 3
4829: PPUSH
4830: LD_INT 229
4832: PPUSH
4833: LD_INT 44
4835: PPUSH
4836: LD_INT 0
4838: PPUSH
4839: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4843: CALL_OW 44
4847: PPUSH
4848: LD_VAR 0 3
4852: PPUSH
4853: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4857: LD_ADDR_EXP 50
4861: PUSH
4862: LD_EXP 50
4866: PUSH
4867: LD_VAR 0 3
4871: ADD
4872: ST_TO_ADDR
// ComMoveXY ( veh , 191 , 32 ) ;
4873: LD_VAR 0 3
4877: PPUSH
4878: LD_INT 191
4880: PPUSH
4881: LD_INT 32
4883: PPUSH
4884: CALL_OW 111
// Wait ( 0 0$02 ) ;
4888: LD_INT 70
4890: PPUSH
4891: CALL_OW 67
// end ;
4895: GO 4747
4897: POP
4898: POP
// end ; end_of_file
4899: LD_VAR 0 1
4903: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
4904: LD_INT 0
4906: PPUSH
4907: PPUSH
4908: PPUSH
4909: PPUSH
4910: PPUSH
4911: PPUSH
4912: PPUSH
// InGameOn ;
4913: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
4917: LD_EXP 31
4921: PPUSH
4922: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
4926: LD_EXP 31
4930: PPUSH
4931: LD_EXP 38
4935: PPUSH
4936: CALL_OW 119
// if Bierezov then
4940: LD_EXP 39
4944: IFFALSE 4960
// ComTurnUnit ( Bierezov , Cornel ) ;
4946: LD_EXP 39
4950: PPUSH
4951: LD_EXP 38
4955: PPUSH
4956: CALL_OW 119
// for i in jmm_units do
4960: LD_ADDR_VAR 0 2
4964: PUSH
4965: LD_EXP 2
4969: PUSH
4970: FOR_IN
4971: IFFALSE 4989
// ComTurnUnit ( i , Cornel ) ;
4973: LD_VAR 0 2
4977: PPUSH
4978: LD_EXP 38
4982: PPUSH
4983: CALL_OW 119
4987: GO 4970
4989: POP
4990: POP
// units := cornel_units union Cornel ;
4991: LD_ADDR_VAR 0 3
4995: PUSH
4996: LD_EXP 4
5000: PUSH
5001: LD_EXP 38
5005: UNION
5006: ST_TO_ADDR
// repeat wait ( 1 ) ;
5007: LD_INT 1
5009: PPUSH
5010: CALL_OW 67
// for i in units do
5014: LD_ADDR_VAR 0 2
5018: PUSH
5019: LD_VAR 0 3
5023: PUSH
5024: FOR_IN
5025: IFFALSE 5058
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5027: LD_VAR 0 2
5031: PPUSH
5032: LD_EXP 31
5036: PPUSH
5037: CALL_OW 250
5041: PPUSH
5042: LD_EXP 31
5046: PPUSH
5047: CALL_OW 251
5051: PPUSH
5052: CALL_OW 111
5056: GO 5024
5058: POP
5059: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5060: LD_VAR 0 3
5064: PPUSH
5065: LD_INT 92
5067: PUSH
5068: LD_EXP 31
5072: PPUSH
5073: CALL_OW 250
5077: PUSH
5078: LD_EXP 31
5082: PPUSH
5083: CALL_OW 251
5087: PUSH
5088: LD_INT 10
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: LIST
5095: LIST
5096: PPUSH
5097: CALL_OW 72
5101: PUSH
5102: LD_VAR 0 3
5106: EQUAL
5107: IFFALSE 5007
// for i in units do
5109: LD_ADDR_VAR 0 2
5113: PUSH
5114: LD_VAR 0 3
5118: PUSH
5119: FOR_IN
5120: IFFALSE 5138
// ComTurnUnit ( i , JMM ) ;
5122: LD_VAR 0 2
5126: PPUSH
5127: LD_EXP 31
5131: PPUSH
5132: CALL_OW 119
5136: GO 5119
5138: POP
5139: POP
// ComTurnUnit ( Cornel , JMM ) ;
5140: LD_EXP 38
5144: PPUSH
5145: LD_EXP 31
5149: PPUSH
5150: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5154: LD_EXP 31
5158: PPUSH
5159: LD_STRING D1-JMM-1
5161: PPUSH
5162: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5166: LD_EXP 38
5170: PPUSH
5171: LD_STRING D1-Corn-1
5173: PPUSH
5174: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5178: LD_EXP 31
5182: PPUSH
5183: LD_EXP 38
5187: PPUSH
5188: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5192: LD_EXP 38
5196: PPUSH
5197: LD_EXP 31
5201: PPUSH
5202: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5206: LD_INT 35
5208: PPUSH
5209: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5213: LD_EXP 31
5217: PPUSH
5218: LD_EXP 38
5222: PPUSH
5223: CALL_OW 296
5227: PUSH
5228: LD_INT 6
5230: LESS
5231: IFFALSE 5206
// ChangeSideFog ( 4 , 1 ) ;
5233: LD_INT 4
5235: PPUSH
5236: LD_INT 1
5238: PPUSH
5239: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5243: LD_EXP 31
5247: PPUSH
5248: LD_EXP 38
5252: PPUSH
5253: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5257: LD_EXP 38
5261: PPUSH
5262: LD_EXP 31
5266: PPUSH
5267: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5271: LD_EXP 31
5275: PPUSH
5276: LD_STRING D1-JMM-2
5278: PPUSH
5279: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5283: LD_EXP 31
5287: PPUSH
5288: LD_STRING D1-JMM-2a
5290: PPUSH
5291: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5295: LD_EXP 38
5299: PPUSH
5300: LD_STRING D1-Corn-2
5302: PPUSH
5303: CALL_OW 88
// if bierezov_exist or debug then
5307: LD_EXP 5
5311: PUSH
5312: LD_EXP 1
5316: OR
5317: IFFALSE 5558
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5319: LD_EXP 38
5323: PPUSH
5324: LD_EXP 39
5328: PPUSH
5329: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5333: LD_INT 10
5335: PPUSH
5336: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5340: LD_EXP 38
5344: PPUSH
5345: LD_STRING D1a-Corn-1
5347: PPUSH
5348: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5352: LD_EXP 31
5356: PPUSH
5357: LD_EXP 39
5361: PPUSH
5362: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5366: LD_EXP 39
5370: PPUSH
5371: LD_EXP 31
5375: PPUSH
5376: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5380: LD_EXP 31
5384: PPUSH
5385: LD_STRING D1a-JMM-1
5387: PPUSH
5388: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5392: LD_EXP 31
5396: PPUSH
5397: LD_EXP 38
5401: PPUSH
5402: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5406: LD_EXP 38
5410: PPUSH
5411: LD_EXP 31
5415: PPUSH
5416: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5420: LD_EXP 38
5424: PPUSH
5425: LD_STRING D1a-Corn-2
5427: PPUSH
5428: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5432: LD_EXP 31
5436: PPUSH
5437: LD_STRING D1a-JMM-2
5439: PPUSH
5440: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5444: LD_EXP 38
5448: PPUSH
5449: LD_STRING D1a-Corn-3
5451: PPUSH
5452: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5456: LD_EXP 31
5460: PPUSH
5461: LD_STRING D1a-JMM-3
5463: PPUSH
5464: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5468: LD_EXP 38
5472: PPUSH
5473: LD_STRING D1a-Corn-4
5475: PPUSH
5476: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5480: LD_EXP 31
5484: PPUSH
5485: LD_STRING D1a-JMM-4
5487: PPUSH
5488: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5492: LD_EXP 38
5496: PPUSH
5497: LD_STRING D1a-Corn-5
5499: PPUSH
5500: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5504: LD_EXP 39
5508: PPUSH
5509: LD_EXP 38
5513: PPUSH
5514: CALL_OW 250
5518: PPUSH
5519: LD_EXP 38
5523: PPUSH
5524: CALL_OW 251
5528: PUSH
5529: LD_INT 2
5531: MINUS
5532: PPUSH
5533: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5537: LD_EXP 39
5541: PPUSH
5542: LD_EXP 38
5546: PPUSH
5547: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5551: LD_INT 10
5553: PPUSH
5554: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5558: LD_EXP 31
5562: PPUSH
5563: LD_STRING D1b-JMM-1
5565: PPUSH
5566: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5570: LD_EXP 38
5574: PPUSH
5575: LD_STRING D1b-Corn-1
5577: PPUSH
5578: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5582: LD_EXP 31
5586: PPUSH
5587: LD_STRING D1b-JMM-2
5589: PPUSH
5590: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5594: LD_EXP 38
5598: PPUSH
5599: LD_STRING D1b-Corn-2
5601: PPUSH
5602: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5606: LD_EXP 31
5610: PPUSH
5611: LD_STRING D1b-JMM-3
5613: PPUSH
5614: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5618: LD_INT 10
5620: PPUSH
5621: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5625: LD_EXP 40
5629: PPUSH
5630: LD_STRING D1b-Pow-3
5632: PPUSH
5633: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5637: LD_EXP 31
5641: PPUSH
5642: LD_STRING D1b-JMM-4
5644: PPUSH
5645: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5649: LD_EXP 38
5653: PPUSH
5654: LD_STRING D1b-Corn-4
5656: PPUSH
5657: CALL_OW 88
// if Khatam then
5661: LD_EXP 35
5665: IFFALSE 5681
// Say ( Khatam , D1b-Khat-4 ) else
5667: LD_EXP 35
5671: PPUSH
5672: LD_STRING D1b-Khat-4
5674: PPUSH
5675: CALL_OW 88
5679: GO 5717
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
5681: LD_EXP 4
5685: PPUSH
5686: LD_INT 26
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: EMPTY
5693: LIST
5694: LIST
5695: PPUSH
5696: CALL_OW 72
5700: PUSH
5701: LD_EXP 38
5705: PUSH
5706: EMPTY
5707: LIST
5708: DIFF
5709: PPUSH
5710: LD_STRING D1b-Sol1-4
5712: PPUSH
5713: CALL 579 0 2
// if Cyrus then
5717: LD_EXP 33
5721: IFFALSE 5735
// Say ( Cyrus , D1b-Cyrus-4 ) ;
5723: LD_EXP 33
5727: PPUSH
5728: LD_STRING D1b-Cyrus-4
5730: PPUSH
5731: CALL_OW 88
// if Lisa then
5735: LD_EXP 34
5739: IFFALSE 5797
// begin Say ( Lisa , D1b-Lisa-4 ) ;
5741: LD_EXP 34
5745: PPUSH
5746: LD_STRING D1b-Lisa-4
5748: PPUSH
5749: CALL_OW 88
// if Cyrus then
5753: LD_EXP 33
5757: IFFALSE 5797
// begin if not IsInUnit ( Cyrus ) then
5759: LD_EXP 33
5763: PPUSH
5764: CALL_OW 310
5768: NOT
5769: IFFALSE 5785
// ComTurnUnit ( Cyrus , Lisa ) ;
5771: LD_EXP 33
5775: PPUSH
5776: LD_EXP 34
5780: PPUSH
5781: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
5785: LD_EXP 33
5789: PPUSH
5790: LD_STRING D1b-Cyrus-5
5792: PPUSH
5793: CALL_OW 88
// end ; end ; SelectGroup ;
5797: CALL 2532 0 0
// Say ( JMM , D1d-JMM-1 ) ;
5801: LD_EXP 31
5805: PPUSH
5806: LD_STRING D1d-JMM-1
5808: PPUSH
5809: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
5813: LD_EXP 38
5817: PPUSH
5818: LD_STRING D1d-Corn-1
5820: PPUSH
5821: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
5825: LD_ADDR_VAR 0 2
5829: PUSH
5830: LD_EXP 2
5834: PUSH
5835: LD_EXP 4
5839: ADD
5840: PUSH
5841: LD_EXP 31
5845: ADD
5846: PUSH
5847: FOR_IN
5848: IFFALSE 5861
// ComHold ( i ) ;
5850: LD_VAR 0 2
5854: PPUSH
5855: CALL_OW 140
5859: GO 5847
5861: POP
5862: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
5863: LD_ADDR_VAR 0 4
5867: PUSH
5868: LD_INT 22
5870: PUSH
5871: LD_INT 1
5873: PUSH
5874: EMPTY
5875: LIST
5876: LIST
5877: PUSH
5878: LD_INT 21
5880: PUSH
5881: LD_INT 2
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: PUSH
5888: EMPTY
5889: LIST
5890: LIST
5891: PPUSH
5892: CALL_OW 69
5896: ST_TO_ADDR
// if vehicles then
5897: LD_VAR 0 4
5901: IFFALSE 6239
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
5903: LD_EXP 4
5907: PPUSH
5908: LD_INT 55
5910: PUSH
5911: EMPTY
5912: LIST
5913: PPUSH
5914: CALL_OW 72
5918: IFFALSE 5957
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
5920: LD_ADDR_VAR 0 2
5924: PUSH
5925: LD_EXP 4
5929: PPUSH
5930: LD_INT 55
5932: PUSH
5933: EMPTY
5934: LIST
5935: PPUSH
5936: CALL_OW 72
5940: PUSH
5941: FOR_IN
5942: IFFALSE 5955
// ComExitVehicle ( i ) ;
5944: LD_VAR 0 2
5948: PPUSH
5949: CALL_OW 121
5953: GO 5941
5955: POP
5956: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
5957: LD_ADDR_VAR 0 5
5961: PUSH
5962: LD_VAR 0 4
5966: PPUSH
5967: LD_INT 34
5969: PUSH
5970: LD_INT 51
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: PPUSH
5977: CALL_OW 72
5981: ST_TO_ADDR
// if cargos then
5982: LD_VAR 0 5
5986: IFFALSE 6169
// begin vehicles := cargos ;
5988: LD_ADDR_VAR 0 4
5992: PUSH
5993: LD_VAR 0 5
5997: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
5998: LD_ADDR_VAR 0 6
6002: PUSH
6003: LD_STRING 02_resources_4
6005: PPUSH
6006: LD_INT 0
6008: PPUSH
6009: CALL_OW 30
6013: ST_TO_ADDR
// if debug and not resources then
6014: LD_EXP 1
6018: PUSH
6019: LD_VAR 0 6
6023: NOT
6024: AND
6025: IFFALSE 6035
// resources := 160 ;
6027: LD_ADDR_VAR 0 6
6031: PUSH
6032: LD_INT 160
6034: ST_TO_ADDR
// if resources mod 10 then
6035: LD_VAR 0 6
6039: PUSH
6040: LD_INT 10
6042: MOD
6043: IFFALSE 6065
// resources := resources - resources mod 10 ;
6045: LD_ADDR_VAR 0 6
6049: PUSH
6050: LD_VAR 0 6
6054: PUSH
6055: LD_VAR 0 6
6059: PUSH
6060: LD_INT 10
6062: MOD
6063: MINUS
6064: ST_TO_ADDR
// if resources then
6065: LD_VAR 0 6
6069: IFFALSE 6169
// for i in cargos do
6071: LD_ADDR_VAR 0 2
6075: PUSH
6076: LD_VAR 0 5
6080: PUSH
6081: FOR_IN
6082: IFFALSE 6167
// begin if resources < 100 then
6084: LD_VAR 0 6
6088: PUSH
6089: LD_INT 100
6091: LESS
6092: IFFALSE 6114
// begin cargo := resources ;
6094: LD_ADDR_VAR 0 7
6098: PUSH
6099: LD_VAR 0 6
6103: ST_TO_ADDR
// resources := 0 ;
6104: LD_ADDR_VAR 0 6
6108: PUSH
6109: LD_INT 0
6111: ST_TO_ADDR
// end else
6112: GO 6136
// begin cargo := 100 ;
6114: LD_ADDR_VAR 0 7
6118: PUSH
6119: LD_INT 100
6121: ST_TO_ADDR
// resources := resources - 100 ;
6122: LD_ADDR_VAR 0 6
6126: PUSH
6127: LD_VAR 0 6
6131: PUSH
6132: LD_INT 100
6134: MINUS
6135: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6136: LD_VAR 0 2
6140: PPUSH
6141: LD_INT 1
6143: PPUSH
6144: LD_VAR 0 7
6148: PPUSH
6149: CALL_OW 290
// if resources = 0 then
6153: LD_VAR 0 6
6157: PUSH
6158: LD_INT 0
6160: EQUAL
6161: IFFALSE 6165
// break ;
6163: GO 6167
// end ;
6165: GO 6081
6167: POP
6168: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6169: LD_VAR 0 4
6173: PUSH
6174: LD_INT 1
6176: ARRAY
6177: PPUSH
6178: CALL_OW 311
6182: PPUSH
6183: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6187: LD_VAR 0 4
6191: PUSH
6192: LD_INT 1
6194: ARRAY
6195: PPUSH
6196: LD_INT 4
6198: PPUSH
6199: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6203: LD_EXP 38
6207: PPUSH
6208: LD_VAR 0 4
6212: PUSH
6213: LD_INT 1
6215: ARRAY
6216: PPUSH
6217: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6221: LD_INT 35
6223: PPUSH
6224: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6228: LD_EXP 38
6232: PPUSH
6233: CALL_OW 310
6237: IFFALSE 6221
// end ; InGameOff ;
6239: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6243: LD_STRING M1
6245: PPUSH
6246: CALL_OW 337
// SaveForQuickRestart ;
6250: CALL_OW 22
// cornel_active := true ;
6254: LD_ADDR_EXP 6
6258: PUSH
6259: LD_INT 1
6261: ST_TO_ADDR
// end ;
6262: LD_VAR 0 1
6266: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
6267: LD_EXP 31
6271: PPUSH
6272: LD_EXP 41
6276: PPUSH
6277: CALL_OW 296
6281: PUSH
6282: LD_INT 10
6284: LESS
6285: IFFALSE 7427
6287: GO 6289
6289: DISABLE
6290: LD_INT 0
6292: PPUSH
6293: PPUSH
6294: PPUSH
6295: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6296: LD_ADDR_VAR 0 2
6300: PUSH
6301: LD_INT 89
6303: PUSH
6304: LD_INT 34
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: PUSH
6311: LD_INT 138
6313: PUSH
6314: LD_INT 63
6316: PUSH
6317: EMPTY
6318: LIST
6319: LIST
6320: PUSH
6321: LD_INT 196
6323: PUSH
6324: LD_INT 84
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: PUSH
6331: LD_INT 135
6333: PUSH
6334: LD_INT 52
6336: PUSH
6337: EMPTY
6338: LIST
6339: LIST
6340: PUSH
6341: LD_INT 103
6343: PUSH
6344: LD_INT 39
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: PUSH
6351: LD_INT 58
6353: PUSH
6354: LD_INT 30
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: PUSH
6361: LD_INT 38
6363: PUSH
6364: LD_INT 51
6366: PUSH
6367: EMPTY
6368: LIST
6369: LIST
6370: PUSH
6371: EMPTY
6372: LIST
6373: LIST
6374: LIST
6375: LIST
6376: LIST
6377: LIST
6378: LIST
6379: ST_TO_ADDR
// InGameOn ;
6380: CALL_OW 8
// if jmm_units then
6384: LD_EXP 2
6388: IFFALSE 6452
// for i in jmm_units do
6390: LD_ADDR_VAR 0 1
6394: PUSH
6395: LD_EXP 2
6399: PUSH
6400: FOR_IN
6401: IFFALSE 6450
// begin if GetDistUnits ( i , JMM ) < 10 then
6403: LD_VAR 0 1
6407: PPUSH
6408: LD_EXP 31
6412: PPUSH
6413: CALL_OW 296
6417: PUSH
6418: LD_INT 10
6420: LESS
6421: IFFALSE 6439
// ComTurnUnit ( i , JMM ) else
6423: LD_VAR 0 1
6427: PPUSH
6428: LD_EXP 31
6432: PPUSH
6433: CALL_OW 119
6437: GO 6448
// ComHold ( i ) ;
6439: LD_VAR 0 1
6443: PPUSH
6444: CALL_OW 140
// end ;
6448: GO 6400
6450: POP
6451: POP
// if IsInUnit ( JMM ) then
6452: LD_EXP 31
6456: PPUSH
6457: CALL_OW 310
6461: IFFALSE 6472
// ComExitVehicle ( JMM ) ;
6463: LD_EXP 31
6467: PPUSH
6468: CALL_OW 121
// Wait ( 10 ) ;
6472: LD_INT 10
6474: PPUSH
6475: CALL_OW 67
// AddComMoveUnit ( JMM , Lynch ) ;
6479: LD_EXP 31
6483: PPUSH
6484: LD_EXP 41
6488: PPUSH
6489: CALL_OW 172
// repeat wait ( 0 0$01 ) ;
6493: LD_INT 35
6495: PPUSH
6496: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6500: LD_EXP 31
6504: PPUSH
6505: LD_EXP 41
6509: PPUSH
6510: CALL_OW 296
6514: PUSH
6515: LD_INT 6
6517: LESS
6518: IFFALSE 6493
// ComTurnUnit ( JMM , Lynch ) ;
6520: LD_EXP 31
6524: PPUSH
6525: LD_EXP 41
6529: PPUSH
6530: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6534: LD_ADDR_VAR 0 1
6538: PUSH
6539: LD_EXP 41
6543: PUSH
6544: LD_EXP 42
6548: PUSH
6549: LD_EXP 43
6553: PUSH
6554: LD_EXP 44
6558: PUSH
6559: EMPTY
6560: LIST
6561: LIST
6562: LIST
6563: LIST
6564: PUSH
6565: FOR_IN
6566: IFFALSE 6584
// ComTurnUnit ( i , JMM ) ;
6568: LD_VAR 0 1
6572: PPUSH
6573: LD_EXP 31
6577: PPUSH
6578: CALL_OW 119
6582: GO 6565
6584: POP
6585: POP
// Wait ( 0 0$0.3 ) ;
6586: LD_INT 10
6588: PPUSH
6589: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6593: LD_EXP 31
6597: PPUSH
6598: LD_STRING D2-JMM-1
6600: PPUSH
6601: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6605: LD_EXP 41
6609: PPUSH
6610: LD_STRING D2-Sol1-1
6612: PPUSH
6613: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6617: LD_EXP 31
6621: PPUSH
6622: LD_STRING D2-JMM-2
6624: PPUSH
6625: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6629: LD_EXP 41
6633: PPUSH
6634: LD_STRING D2-Sol1-2
6636: PPUSH
6637: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6641: LD_EXP 31
6645: PPUSH
6646: LD_STRING D2-JMM-3
6648: PPUSH
6649: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
6653: LD_EXP 41
6657: PPUSH
6658: LD_STRING D2-Sol1-3
6660: PPUSH
6661: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6665: LD_ADDR_VAR 0 1
6669: PUSH
6670: LD_INT 22
6672: PUSH
6673: LD_INT 8
6675: PUSH
6676: EMPTY
6677: LIST
6678: LIST
6679: PPUSH
6680: CALL_OW 69
6684: PUSH
6685: FOR_IN
6686: IFFALSE 6702
// SetSide ( i , 1 ) ;
6688: LD_VAR 0 1
6692: PPUSH
6693: LD_INT 1
6695: PPUSH
6696: CALL_OW 235
6700: GO 6685
6702: POP
6703: POP
// Say ( JMM , D2-JMM-4 ) ;
6704: LD_EXP 31
6708: PPUSH
6709: LD_STRING D2-JMM-4
6711: PPUSH
6712: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
6716: LD_INT 1
6718: PPUSH
6719: LD_INT 5
6721: PPUSH
6722: CALL_OW 332
// for i = 1 to points do
6726: LD_ADDR_VAR 0 1
6730: PUSH
6731: DOUBLE
6732: LD_INT 1
6734: DEC
6735: ST_TO_ADDR
6736: LD_VAR 0 2
6740: PUSH
6741: FOR_TO
6742: IFFALSE 6917
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6744: LD_VAR 0 2
6748: PUSH
6749: LD_VAR 0 1
6753: ARRAY
6754: PUSH
6755: LD_INT 1
6757: ARRAY
6758: PPUSH
6759: LD_VAR 0 2
6763: PUSH
6764: LD_VAR 0 1
6768: ARRAY
6769: PUSH
6770: LD_INT 2
6772: ARRAY
6773: PPUSH
6774: CALL_OW 84
// if i = 1 then
6778: LD_VAR 0 1
6782: PUSH
6783: LD_INT 1
6785: EQUAL
6786: IFFALSE 6800
// Say ( Lynch , D2-Sol1-4 ) ;
6788: LD_EXP 41
6792: PPUSH
6793: LD_STRING D2-Sol1-4
6795: PPUSH
6796: CALL_OW 88
// if i = 2 then
6800: LD_VAR 0 1
6804: PUSH
6805: LD_INT 2
6807: EQUAL
6808: IFFALSE 6822
// Say ( JMM , D2-JMM-5 ) ;
6810: LD_EXP 31
6814: PPUSH
6815: LD_STRING D2-JMM-5
6817: PPUSH
6818: CALL_OW 88
// if i = 4 then
6822: LD_VAR 0 1
6826: PUSH
6827: LD_INT 4
6829: EQUAL
6830: IFFALSE 6854
// begin RevealFogArea ( 1 , troopsArea ) ;
6832: LD_INT 1
6834: PPUSH
6835: LD_INT 6
6837: PPUSH
6838: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
6842: LD_EXP 41
6846: PPUSH
6847: LD_STRING D2-Sol1-5
6849: PPUSH
6850: CALL_OW 88
// end ; if i = 5 then
6854: LD_VAR 0 1
6858: PUSH
6859: LD_INT 5
6861: EQUAL
6862: IFFALSE 6876
// Say ( JMM , D2-JMM-6 ) ;
6864: LD_EXP 31
6868: PPUSH
6869: LD_STRING D2-JMM-6
6871: PPUSH
6872: CALL_OW 88
// if i = 7 then
6876: LD_VAR 0 1
6880: PUSH
6881: LD_INT 7
6883: EQUAL
6884: IFFALSE 6908
// begin RevealFogArea ( 1 , forestArea ) ;
6886: LD_INT 1
6888: PPUSH
6889: LD_INT 7
6891: PPUSH
6892: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
6896: LD_EXP 41
6900: PPUSH
6901: LD_STRING D2-Sol1-6
6903: PPUSH
6904: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
6908: LD_INT 46
6910: PPUSH
6911: CALL_OW 67
// end ;
6915: GO 6741
6917: POP
6918: POP
// CenterNowOnUnits ( JMM ) ;
6919: LD_EXP 31
6923: PPUSH
6924: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
6928: LD_EXP 31
6932: PPUSH
6933: LD_STRING D2-JMM-7
6935: PPUSH
6936: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
6940: LD_EXP 41
6944: PPUSH
6945: LD_STRING D2-Sol1-7
6947: PPUSH
6948: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
6952: LD_EXP 31
6956: PPUSH
6957: LD_STRING D2-JMM-8
6959: PPUSH
6960: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
6964: LD_ADDR_VAR 0 4
6968: PUSH
6969: LD_INT 22
6971: PUSH
6972: LD_INT 1
6974: PUSH
6975: EMPTY
6976: LIST
6977: LIST
6978: PUSH
6979: LD_INT 30
6981: PUSH
6982: LD_INT 31
6984: PUSH
6985: EMPTY
6986: LIST
6987: LIST
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PPUSH
6993: CALL_OW 69
6997: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
6998: LD_EXP 41
7002: PPUSH
7003: LD_VAR 0 4
7007: PUSH
7008: LD_INT 1
7010: ARRAY
7011: PPUSH
7012: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7016: LD_ADDR_VAR 0 3
7020: PUSH
7021: LD_EXP 2
7025: PPUSH
7026: LD_INT 25
7028: PUSH
7029: LD_INT 1
7031: PUSH
7032: EMPTY
7033: LIST
7034: LIST
7035: PPUSH
7036: CALL_OW 72
7040: PPUSH
7041: LD_EXP 31
7045: PPUSH
7046: CALL_OW 74
7050: ST_TO_ADDR
// if sol then
7051: LD_VAR 0 3
7055: IFFALSE 7095
// if GetDistUnits ( JMM , sol ) < 10 then
7057: LD_EXP 31
7061: PPUSH
7062: LD_VAR 0 3
7066: PPUSH
7067: CALL_OW 296
7071: PUSH
7072: LD_INT 10
7074: LESS
7075: IFFALSE 7095
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7077: LD_VAR 0 3
7081: PPUSH
7082: LD_VAR 0 4
7086: PUSH
7087: LD_INT 2
7089: ARRAY
7090: PPUSH
7091: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7095: LD_INT 10
7097: PPUSH
7098: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7102: LD_EXP 31
7106: PPUSH
7107: LD_INT 65
7109: PPUSH
7110: LD_INT 101
7112: PPUSH
7113: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7117: LD_EXP 31
7121: PPUSH
7122: LD_INT 63
7124: PPUSH
7125: LD_INT 100
7127: PPUSH
7128: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
7132: LD_INT 35
7134: PPUSH
7135: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
7139: LD_EXP 31
7143: PPUSH
7144: LD_INT 65
7146: PPUSH
7147: LD_INT 101
7149: PPUSH
7150: CALL_OW 307
7154: IFFALSE 7132
// Say ( JMM , D2a-JMM-1 ) ;
7156: LD_EXP 31
7160: PPUSH
7161: LD_STRING D2a-JMM-1
7163: PPUSH
7164: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7168: LD_EXP 42
7172: PPUSH
7173: LD_INT 66
7175: PPUSH
7176: LD_INT 103
7178: PPUSH
7179: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
7183: LD_INT 35
7185: PPUSH
7186: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
7190: LD_EXP 42
7194: PPUSH
7195: LD_INT 66
7197: PPUSH
7198: LD_INT 103
7200: PPUSH
7201: CALL_OW 307
7205: IFFALSE 7183
// ComTurnUnit ( Walker , JMM ) ;
7207: LD_EXP 42
7211: PPUSH
7212: LD_EXP 31
7216: PPUSH
7217: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7221: LD_EXP 42
7225: PPUSH
7226: LD_STRING D2a-Sci1-1
7228: PPUSH
7229: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7233: LD_EXP 31
7237: PPUSH
7238: LD_EXP 42
7242: PPUSH
7243: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7247: LD_EXP 31
7251: PPUSH
7252: LD_STRING D2a-JMM-2
7254: PPUSH
7255: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7259: LD_EXP 42
7263: PPUSH
7264: LD_STRING D2a-Sci1-2
7266: PPUSH
7267: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7271: LD_EXP 31
7275: PPUSH
7276: LD_STRING D2a-JMM-3
7278: PPUSH
7279: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7283: LD_EXP 42
7287: PPUSH
7288: LD_STRING D2a-Sci1-3
7290: PPUSH
7291: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7295: LD_ADDR_EXP 2
7299: PUSH
7300: LD_EXP 2
7304: PUSH
7305: LD_EXP 41
7309: PUSH
7310: LD_EXP 42
7314: PUSH
7315: LD_EXP 43
7319: PUSH
7320: LD_EXP 44
7324: PUSH
7325: EMPTY
7326: LIST
7327: LIST
7328: LIST
7329: LIST
7330: ADD
7331: ST_TO_ADDR
// for i in jmm_units do
7332: LD_ADDR_VAR 0 1
7336: PUSH
7337: LD_EXP 2
7341: PUSH
7342: FOR_IN
7343: IFFALSE 7368
// if not IsInUnit ( i ) then
7345: LD_VAR 0 1
7349: PPUSH
7350: CALL_OW 310
7354: NOT
7355: IFFALSE 7366
// ComFree ( i ) ;
7357: LD_VAR 0 1
7361: PPUSH
7362: CALL_OW 139
7366: GO 7342
7368: POP
7369: POP
// InGameOff ;
7370: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
7374: LD_STRING MSolar1
7376: PPUSH
7377: CALL_OW 337
// jmm_on_west := true ;
7381: LD_ADDR_EXP 3
7385: PUSH
7386: LD_INT 1
7388: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7389: LD_INT 1050
7391: PPUSH
7392: CALL_OW 67
// frank_can_return := true ;
7396: LD_ADDR_EXP 10
7400: PUSH
7401: LD_INT 1
7403: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7404: LD_INT 6300
7406: PPUSH
7407: LD_INT 8400
7409: PPUSH
7410: CALL_OW 12
7414: PPUSH
7415: CALL_OW 67
// send_spec_patrol := true ;
7419: LD_ADDR_EXP 26
7423: PUSH
7424: LD_INT 1
7426: ST_TO_ADDR
// end ;
7427: PPOPN 4
7429: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7430: LD_INT 22
7432: PUSH
7433: LD_INT 1
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: PUSH
7440: LD_INT 34
7442: PUSH
7443: LD_INT 51
7445: PUSH
7446: EMPTY
7447: LIST
7448: LIST
7449: PUSH
7450: LD_INT 92
7452: PUSH
7453: LD_INT 63
7455: PUSH
7456: LD_INT 100
7458: PUSH
7459: LD_INT 5
7461: PUSH
7462: EMPTY
7463: LIST
7464: LIST
7465: LIST
7466: LIST
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: PPUSH
7476: CALL_OW 69
7480: PUSH
7481: LD_EXP 3
7485: NOT
7486: AND
7487: IFFALSE 7600
7489: GO 7491
7491: DISABLE
7492: LD_INT 0
7494: PPUSH
7495: PPUSH
// begin enable ;
7496: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
7497: LD_ADDR_VAR 0 2
7501: PUSH
7502: LD_INT 22
7504: PUSH
7505: LD_INT 1
7507: PUSH
7508: EMPTY
7509: LIST
7510: LIST
7511: PUSH
7512: LD_INT 34
7514: PUSH
7515: LD_INT 51
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: PUSH
7522: LD_INT 92
7524: PUSH
7525: LD_INT 63
7527: PUSH
7528: LD_INT 100
7530: PUSH
7531: LD_INT 5
7533: PUSH
7534: EMPTY
7535: LIST
7536: LIST
7537: LIST
7538: LIST
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: LIST
7544: PUSH
7545: EMPTY
7546: LIST
7547: PPUSH
7548: CALL_OW 69
7552: ST_TO_ADDR
// if not filter then
7553: LD_VAR 0 2
7557: NOT
7558: IFFALSE 7562
// exit ;
7560: GO 7600
// for i in filter do
7562: LD_ADDR_VAR 0 1
7566: PUSH
7567: LD_VAR 0 2
7571: PUSH
7572: FOR_IN
7573: IFFALSE 7598
// begin SetFuel ( i , 0 ) ;
7575: LD_VAR 0 1
7579: PPUSH
7580: LD_INT 0
7582: PPUSH
7583: CALL_OW 240
// ComStop ( i ) ;
7587: LD_VAR 0 1
7591: PPUSH
7592: CALL_OW 141
// end ;
7596: GO 7572
7598: POP
7599: POP
// end ;
7600: PPOPN 2
7602: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
7603: LD_EXP 26
7607: IFFALSE 8572
7609: GO 7611
7611: DISABLE
7612: LD_INT 0
7614: PPUSH
7615: PPUSH
7616: PPUSH
7617: PPUSH
7618: PPUSH
7619: PPUSH
7620: PPUSH
// begin if not ru_spec_patrol then
7621: LD_EXP 48
7625: NOT
7626: IFFALSE 7630
// exit ;
7628: GO 8572
// dead1 := false ;
7630: LD_ADDR_VAR 0 1
7634: PUSH
7635: LD_INT 0
7637: ST_TO_ADDR
// dead2 := false ;
7638: LD_ADDR_VAR 0 2
7642: PUSH
7643: LD_INT 0
7645: ST_TO_ADDR
// inarea1 := false ;
7646: LD_ADDR_VAR 0 3
7650: PUSH
7651: LD_INT 0
7653: ST_TO_ADDR
// inarea2 := false ;
7654: LD_ADDR_VAR 0 4
7658: PUSH
7659: LD_INT 0
7661: ST_TO_ADDR
// tmp := [ ] ;
7662: LD_ADDR_VAR 0 6
7666: PUSH
7667: EMPTY
7668: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
7669: LD_EXP 48
7673: PPUSH
7674: LD_INT 75
7676: PPUSH
7677: LD_INT 101
7679: PPUSH
7680: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
7684: LD_INT 35
7686: PPUSH
7687: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
7691: LD_INT 1
7693: PPUSH
7694: LD_EXP 48
7698: PUSH
7699: LD_INT 1
7701: ARRAY
7702: PPUSH
7703: CALL_OW 292
7707: IFFALSE 7684
// ComStop ( ru_spec_patrol ) ;
7709: LD_EXP 48
7713: PPUSH
7714: CALL_OW 141
// Wait ( 0 0$02 ) ;
7718: LD_INT 70
7720: PPUSH
7721: CALL_OW 67
// DialogueOn ;
7725: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
7729: LD_EXP 48
7733: PUSH
7734: LD_INT 1
7736: ARRAY
7737: PPUSH
7738: LD_STRING D8-Rus1-1
7740: PPUSH
7741: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
7745: LD_EXP 31
7749: PPUSH
7750: LD_STRING D8-JMM-1
7752: PPUSH
7753: CALL_OW 88
// DialogueOff ;
7757: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
7761: LD_EXP 48
7765: PPUSH
7766: LD_INT 13
7768: PPUSH
7769: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
7773: LD_INT 35
7775: PPUSH
7776: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
7780: LD_VAR 0 1
7784: NOT
7785: PUSH
7786: LD_EXP 48
7790: PUSH
7791: LD_INT 1
7793: ARRAY
7794: PPUSH
7795: CALL_OW 301
7799: AND
7800: IFFALSE 7810
// dead1 := true ;
7802: LD_ADDR_VAR 0 1
7806: PUSH
7807: LD_INT 1
7809: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
7810: LD_VAR 0 2
7814: NOT
7815: PUSH
7816: LD_EXP 48
7820: PUSH
7821: LD_INT 2
7823: ARRAY
7824: PPUSH
7825: CALL_OW 301
7829: AND
7830: IFFALSE 7840
// dead2 := true ;
7832: LD_ADDR_VAR 0 2
7836: PUSH
7837: LD_INT 1
7839: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
7840: LD_VAR 0 3
7844: NOT
7845: PUSH
7846: LD_EXP 48
7850: PUSH
7851: LD_INT 1
7853: ARRAY
7854: PPUSH
7855: LD_INT 14
7857: PPUSH
7858: CALL_OW 308
7862: AND
7863: IFFALSE 7873
// inarea1 := true ;
7865: LD_ADDR_VAR 0 3
7869: PUSH
7870: LD_INT 1
7872: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
7873: LD_VAR 0 4
7877: NOT
7878: PUSH
7879: LD_EXP 48
7883: PUSH
7884: LD_INT 2
7886: ARRAY
7887: PPUSH
7888: LD_INT 14
7890: PPUSH
7891: CALL_OW 308
7895: AND
7896: IFFALSE 7906
// inarea2 := true ;
7898: LD_ADDR_VAR 0 4
7902: PUSH
7903: LD_INT 1
7905: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
7906: LD_VAR 0 1
7910: PUSH
7911: LD_VAR 0 2
7915: AND
7916: PUSH
7917: LD_VAR 0 1
7921: PUSH
7922: LD_VAR 0 4
7926: AND
7927: OR
7928: PUSH
7929: LD_VAR 0 2
7933: PUSH
7934: LD_VAR 0 3
7938: AND
7939: OR
7940: PUSH
7941: LD_VAR 0 3
7945: PUSH
7946: LD_VAR 0 4
7950: AND
7951: OR
7952: IFFALSE 7773
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
7954: LD_VAR 0 3
7958: PUSH
7959: LD_VAR 0 4
7963: AND
7964: PUSH
7965: LD_VAR 0 1
7969: PUSH
7970: LD_VAR 0 4
7974: AND
7975: OR
7976: PUSH
7977: LD_VAR 0 2
7981: PUSH
7982: LD_VAR 0 3
7986: AND
7987: OR
7988: IFFALSE 8552
// begin prepare_siege := true ;
7990: LD_ADDR_EXP 27
7994: PUSH
7995: LD_INT 1
7997: ST_TO_ADDR
// DialogueOn ;
7998: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8002: LD_VAR 0 3
8006: PUSH
8007: LD_VAR 0 4
8011: AND
8012: IFFALSE 8028
// Say ( JMM , D8b-JMM-1a ) else
8014: LD_EXP 31
8018: PPUSH
8019: LD_STRING D8b-JMM-1a
8021: PPUSH
8022: CALL_OW 88
8026: GO 8040
// Say ( JMM , D8b-JMM-1 ) ;
8028: LD_EXP 31
8032: PPUSH
8033: LD_STRING D8b-JMM-1
8035: PPUSH
8036: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8040: LD_EXP 2
8044: PPUSH
8045: LD_INT 26
8047: PUSH
8048: LD_INT 1
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: PPUSH
8055: CALL_OW 72
8059: PUSH
8060: LD_EXP 32
8064: PUSH
8065: LD_EXP 33
8069: PUSH
8070: LD_EXP 42
8074: PUSH
8075: LD_EXP 45
8079: PUSH
8080: EMPTY
8081: LIST
8082: LIST
8083: LIST
8084: LIST
8085: DIFF
8086: PPUSH
8087: LD_STRING D8b-Sol1-1
8089: PPUSH
8090: CALL 579 0 2
// if Cyrus and Cyrus in jmm_units then
8094: LD_EXP 33
8098: PUSH
8099: LD_EXP 33
8103: PUSH
8104: LD_EXP 2
8108: IN
8109: AND
8110: IFFALSE 8126
// Say ( Cyrus , D8b-Cyrus-1 ) else
8112: LD_EXP 33
8116: PPUSH
8117: LD_STRING D8b-Cyrus-1
8119: PPUSH
8120: CALL_OW 88
8124: GO 8138
// Say ( JMM , D8b-JMM-1a ) ;
8126: LD_EXP 31
8130: PPUSH
8131: LD_STRING D8b-JMM-1a
8133: PPUSH
8134: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8138: LD_EXP 34
8142: PUSH
8143: LD_EXP 34
8147: PUSH
8148: LD_EXP 2
8152: IN
8153: AND
8154: IFFALSE 8168
// Say ( Lisa , D8b-Lisa-2 ) ;
8156: LD_EXP 34
8160: PPUSH
8161: LD_STRING D8b-Lisa-2
8163: PPUSH
8164: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8168: LD_EXP 32
8172: PUSH
8173: LD_EXP 32
8177: PUSH
8178: LD_EXP 2
8182: IN
8183: AND
8184: IFFALSE 8200
// Say ( Bobby , D8b-Bobby-1 ) else
8186: LD_EXP 32
8190: PPUSH
8191: LD_STRING D8b-Bobby-1
8193: PPUSH
8194: CALL_OW 88
8198: GO 8260
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8200: LD_ADDR_VAR 0 5
8204: PUSH
8205: LD_EXP 2
8209: PPUSH
8210: LD_INT 26
8212: PUSH
8213: LD_INT 1
8215: PUSH
8216: EMPTY
8217: LIST
8218: LIST
8219: PPUSH
8220: CALL_OW 72
8224: PUSH
8225: LD_EXP 32
8229: PUSH
8230: LD_EXP 33
8234: PUSH
8235: LD_EXP 42
8239: PUSH
8240: LD_EXP 45
8244: PUSH
8245: EMPTY
8246: LIST
8247: LIST
8248: LIST
8249: LIST
8250: DIFF
8251: PPUSH
8252: LD_STRING D8b-Sol2-1
8254: PPUSH
8255: CALL 579 0 2
8259: ST_TO_ADDR
// DialogueOff ;
8260: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8264: LD_EXP 33
8268: PUSH
8269: LD_EXP 33
8273: PUSH
8274: LD_EXP 2
8278: IN
8279: AND
8280: IFFALSE 8305
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8282: LD_ADDR_VAR 0 6
8286: PUSH
8287: LD_VAR 0 6
8291: PPUSH
8292: LD_INT 1
8294: PPUSH
8295: LD_EXP 33
8299: PPUSH
8300: CALL_OW 2
8304: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8305: LD_EXP 32
8309: PUSH
8310: LD_EXP 32
8314: PUSH
8315: LD_EXP 2
8319: IN
8320: AND
8321: IFFALSE 8346
// tmp := Insert ( tmp , 1 , Bobby ) ;
8323: LD_ADDR_VAR 0 6
8327: PUSH
8328: LD_VAR 0 6
8332: PPUSH
8333: LD_INT 1
8335: PPUSH
8336: LD_EXP 32
8340: PPUSH
8341: CALL_OW 2
8345: ST_TO_ADDR
// if sol then
8346: LD_VAR 0 5
8350: IFFALSE 8375
// tmp := Insert ( tmp , 1 , sol ) ;
8352: LD_ADDR_VAR 0 6
8356: PUSH
8357: LD_VAR 0 6
8361: PPUSH
8362: LD_INT 1
8364: PPUSH
8365: LD_VAR 0 5
8369: PPUSH
8370: CALL_OW 2
8374: ST_TO_ADDR
// if tmp then
8375: LD_VAR 0 6
8379: IFFALSE 8511
// begin SetSide ( tmp , 8 ) ;
8381: LD_VAR 0 6
8385: PPUSH
8386: LD_INT 8
8388: PPUSH
8389: CALL_OW 235
// ComFree ( tmp ) ;
8393: LD_VAR 0 6
8397: PPUSH
8398: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8402: LD_VAR 0 6
8406: PPUSH
8407: LD_INT 15
8409: PPUSH
8410: CALL_OW 173
// AddComHold ( tmp ) ;
8414: LD_VAR 0 6
8418: PPUSH
8419: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8423: LD_INT 35
8425: PPUSH
8426: CALL_OW 67
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8430: LD_VAR 0 6
8434: PUSH
8435: LD_INT 1
8437: ARRAY
8438: PPUSH
8439: LD_INT 15
8441: PPUSH
8442: CALL_OW 308
8446: IFFALSE 8501
// begin RemoveUnit ( tmp [ 1 ] ) ;
8448: LD_VAR 0 6
8452: PUSH
8453: LD_INT 1
8455: ARRAY
8456: PPUSH
8457: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
8461: LD_ADDR_EXP 2
8465: PUSH
8466: LD_EXP 2
8470: PUSH
8471: LD_VAR 0 6
8475: PUSH
8476: LD_INT 1
8478: ARRAY
8479: DIFF
8480: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
8481: LD_ADDR_VAR 0 6
8485: PUSH
8486: LD_VAR 0 6
8490: PUSH
8491: LD_VAR 0 6
8495: PUSH
8496: LD_INT 1
8498: ARRAY
8499: DIFF
8500: ST_TO_ADDR
// end ; until tmp = 0 ;
8501: LD_VAR 0 6
8505: PUSH
8506: LD_INT 0
8508: EQUAL
8509: IFFALSE 8423
// end ; Wait ( 0 0$30 ) ;
8511: LD_INT 1050
8513: PPUSH
8514: CALL_OW 67
// if ru_spec_patrol then
8518: LD_EXP 48
8522: IFFALSE 8550
// for i in ru_spec_patrol do
8524: LD_ADDR_VAR 0 7
8528: PUSH
8529: LD_EXP 48
8533: PUSH
8534: FOR_IN
8535: IFFALSE 8548
// RemoveUnit ( i ) ;
8537: LD_VAR 0 7
8541: PPUSH
8542: CALL_OW 64
8546: GO 8534
8548: POP
8549: POP
// end else
8550: GO 8572
// begin prepare_siege := false ;
8552: LD_ADDR_EXP 27
8556: PUSH
8557: LD_INT 0
8559: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
8560: LD_EXP 31
8564: PPUSH
8565: LD_STRING D8a-JMM-1
8567: PPUSH
8568: CALL_OW 88
// end ; end ;
8572: PPOPN 7
8574: END
// every 0 0$10 trigger frank_can_return do var i , points ;
8575: LD_EXP 10
8579: IFFALSE 9713
8581: GO 8583
8583: DISABLE
8584: LD_INT 0
8586: PPUSH
8587: PPUSH
// begin uc_side := 8 ;
8588: LD_ADDR_OWVAR 20
8592: PUSH
8593: LD_INT 8
8595: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
8596: LD_ADDR_VAR 0 2
8600: PUSH
8601: LD_INT 59
8603: PUSH
8604: LD_INT 71
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: PUSH
8611: LD_INT 122
8613: PUSH
8614: LD_INT 117
8616: PUSH
8617: EMPTY
8618: LIST
8619: LIST
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
8625: LD_ADDR_EXP 45
8629: PUSH
8630: LD_STRING Frank
8632: PPUSH
8633: LD_INT 0
8635: PPUSH
8636: CALL 434 0 2
8640: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
8641: LD_ADDR_VAR 0 1
8645: PUSH
8646: LD_INT 1
8648: PPUSH
8649: LD_INT 2
8651: PPUSH
8652: CALL_OW 12
8656: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
8657: LD_EXP 45
8661: PPUSH
8662: LD_VAR 0 2
8666: PUSH
8667: LD_VAR 0 1
8671: ARRAY
8672: PUSH
8673: LD_INT 1
8675: ARRAY
8676: PPUSH
8677: LD_VAR 0 2
8681: PUSH
8682: LD_VAR 0 1
8686: ARRAY
8687: PUSH
8688: LD_INT 2
8690: ARRAY
8691: PPUSH
8692: LD_INT 0
8694: PPUSH
8695: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
8699: LD_EXP 45
8703: PPUSH
8704: LD_INT 1
8706: PPUSH
8707: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
8711: LD_INT 35
8713: PPUSH
8714: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
8718: LD_EXP 45
8722: PPUSH
8723: LD_EXP 31
8727: PPUSH
8728: CALL_OW 296
8732: PUSH
8733: LD_INT 8
8735: LESS
8736: IFFALSE 8711
// InGameOn ;
8738: CALL_OW 8
// CenterOnUnits ( JMM ) ;
8742: LD_EXP 31
8746: PPUSH
8747: CALL_OW 85
// if IsInUnit ( JMM ) then
8751: LD_EXP 31
8755: PPUSH
8756: CALL_OW 310
8760: IFFALSE 8771
// ComFree ( JMM ) ;
8762: LD_EXP 31
8766: PPUSH
8767: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
8771: LD_EXP 31
8775: PPUSH
8776: LD_EXP 45
8780: PPUSH
8781: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
8785: LD_EXP 45
8789: PPUSH
8790: LD_EXP 31
8794: PPUSH
8795: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
8799: LD_EXP 31
8803: PPUSH
8804: LD_STRING D6-JMM-1
8806: PPUSH
8807: CALL_OW 88
// repeat wait ( 3 ) ;
8811: LD_INT 3
8813: PPUSH
8814: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
8818: LD_EXP 31
8822: PPUSH
8823: LD_EXP 45
8827: PPUSH
8828: CALL_OW 296
8832: PUSH
8833: LD_INT 8
8835: LESS
8836: IFFALSE 8811
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
8838: LD_EXP 34
8842: PUSH
8843: LD_EXP 34
8847: PPUSH
8848: LD_EXP 45
8852: PPUSH
8853: CALL_OW 296
8857: PUSH
8858: LD_INT 20
8860: LESS
8861: AND
8862: IFFALSE 8887
// begin ComFree ( Lisa ) ;
8864: LD_EXP 34
8868: PPUSH
8869: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
8873: LD_EXP 34
8877: PPUSH
8878: LD_EXP 45
8882: PPUSH
8883: CALL_OW 172
// end ; if Lynch then
8887: LD_EXP 41
8891: IFFALSE 8916
// begin ComFree ( Lynch ) ;
8893: LD_EXP 41
8897: PPUSH
8898: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
8902: LD_EXP 41
8906: PPUSH
8907: LD_EXP 45
8911: PPUSH
8912: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
8916: LD_EXP 31
8920: PPUSH
8921: LD_EXP 45
8925: PPUSH
8926: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
8930: LD_EXP 45
8934: PPUSH
8935: LD_EXP 31
8939: PPUSH
8940: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
8944: LD_EXP 45
8948: PPUSH
8949: LD_STRING D6-Frank-1
8951: PPUSH
8952: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
8956: LD_INT 69
8958: PPUSH
8959: LD_INT 20
8961: PPUSH
8962: LD_INT 1
8964: PPUSH
8965: LD_INT 20
8967: NEG
8968: PPUSH
8969: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
8973: LD_INT 69
8975: PPUSH
8976: LD_INT 20
8978: PPUSH
8979: LD_INT 1
8981: PPUSH
8982: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
8986: LD_INT 190
8988: PPUSH
8989: LD_INT 31
8991: PPUSH
8992: LD_INT 1
8994: PPUSH
8995: LD_INT 20
8997: NEG
8998: PPUSH
8999: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9003: LD_INT 190
9005: PPUSH
9006: LD_INT 31
9008: PPUSH
9009: LD_INT 1
9011: PPUSH
9012: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9016: LD_INT 69
9018: PPUSH
9019: LD_INT 20
9021: PPUSH
9022: CALL_OW 84
// Wait ( 0 0$02 ) ;
9026: LD_INT 70
9028: PPUSH
9029: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9033: LD_EXP 31
9037: PPUSH
9038: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9042: LD_EXP 34
9046: PUSH
9047: LD_EXP 34
9051: PPUSH
9052: LD_EXP 45
9056: PPUSH
9057: CALL_OW 296
9061: PUSH
9062: LD_INT 20
9064: LESS
9065: AND
9066: PUSH
9067: LD_EXP 34
9071: PPUSH
9072: CALL_OW 302
9076: AND
9077: IFFALSE 9167
// begin ComFree ( Lisa ) ;
9079: LD_EXP 34
9083: PPUSH
9084: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
9088: LD_INT 35
9090: PPUSH
9091: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
9095: LD_EXP 34
9099: PPUSH
9100: LD_EXP 45
9104: PPUSH
9105: CALL_OW 296
9109: PUSH
9110: LD_INT 7
9112: LESS
9113: IFFALSE 9088
// Say ( Lisa , D6-Lisa-1 ) ;
9115: LD_EXP 34
9119: PPUSH
9120: LD_STRING D6-Lisa-1
9122: PPUSH
9123: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9127: LD_EXP 34
9131: PPUSH
9132: LD_EXP 45
9136: PPUSH
9137: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9141: LD_EXP 45
9145: PPUSH
9146: LD_EXP 34
9150: PPUSH
9151: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9155: LD_EXP 45
9159: PPUSH
9160: LD_STRING D6-Frank-2
9162: PPUSH
9163: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9167: LD_EXP 41
9171: PUSH
9172: LD_EXP 41
9176: PPUSH
9177: LD_EXP 45
9181: PPUSH
9182: CALL_OW 296
9186: PUSH
9187: LD_INT 20
9189: LESS
9190: AND
9191: PUSH
9192: LD_EXP 41
9196: PPUSH
9197: CALL_OW 302
9201: AND
9202: IFFALSE 9383
// begin ComTurnUnit ( Lynch , JMM ) ;
9204: LD_EXP 41
9208: PPUSH
9209: LD_EXP 31
9213: PPUSH
9214: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9218: LD_EXP 45
9222: PPUSH
9223: LD_EXP 31
9227: PPUSH
9228: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9232: LD_EXP 41
9236: PPUSH
9237: LD_STRING D6-Sol1-2
9239: PPUSH
9240: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9244: LD_EXP 31
9248: PPUSH
9249: LD_STRING D6-JMM-2
9251: PPUSH
9252: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9256: LD_EXP 45
9260: PPUSH
9261: LD_STRING D6-Frank-3
9263: PPUSH
9264: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9268: LD_EXP 31
9272: PPUSH
9273: LD_STRING D6-JMM-3
9275: PPUSH
9276: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9280: LD_EXP 45
9284: PPUSH
9285: LD_STRING D6-Frank-4
9287: PPUSH
9288: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9292: LD_EXP 45
9296: PPUSH
9297: LD_STRING D6-Frank-4a
9299: PPUSH
9300: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9304: LD_EXP 31
9308: PPUSH
9309: LD_STRING D6-JMM-4
9311: PPUSH
9312: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9316: LD_EXP 45
9320: PPUSH
9321: LD_STRING D6-Frank-5
9323: PPUSH
9324: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9328: LD_EXP 34
9332: PUSH
9333: LD_EXP 34
9337: PPUSH
9338: CALL_OW 302
9342: AND
9343: IFFALSE 9357
// Say ( Lisa , D6-Lisa-5 ) ;
9345: LD_EXP 34
9349: PPUSH
9350: LD_STRING D6-Lisa-5
9352: PPUSH
9353: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9357: LD_EXP 45
9361: PPUSH
9362: LD_STRING D6-Frank-6
9364: PPUSH
9365: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9369: LD_EXP 31
9373: PPUSH
9374: LD_STRING D6-JMM-6
9376: PPUSH
9377: CALL_OW 88
// end else
9381: GO 9498
// begin ComTurnUnit ( Frank , JMM ) ;
9383: LD_EXP 45
9387: PPUSH
9388: LD_EXP 31
9392: PPUSH
9393: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
9397: LD_EXP 45
9401: PPUSH
9402: LD_STRING D6-Frank-4
9404: PPUSH
9405: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9409: LD_EXP 45
9413: PPUSH
9414: LD_STRING D6-Frank-4a
9416: PPUSH
9417: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9421: LD_EXP 31
9425: PPUSH
9426: LD_STRING D6-JMM-4
9428: PPUSH
9429: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9433: LD_EXP 45
9437: PPUSH
9438: LD_STRING D6-Frank-5
9440: PPUSH
9441: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9445: LD_EXP 34
9449: PUSH
9450: LD_EXP 34
9454: PPUSH
9455: CALL_OW 302
9459: AND
9460: IFFALSE 9474
// Say ( Lisa , D6-Lisa-5 ) ;
9462: LD_EXP 34
9466: PPUSH
9467: LD_STRING D6-Lisa-5
9469: PPUSH
9470: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9474: LD_EXP 45
9478: PPUSH
9479: LD_STRING D6-Frank-6
9481: PPUSH
9482: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9486: LD_EXP 31
9490: PPUSH
9491: LD_STRING D6-JMM-6
9493: PPUSH
9494: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
9498: LD_STRING Q1
9500: PPUSH
9501: CALL_OW 97
9505: PUSH
9506: LD_INT 1
9508: DOUBLE
9509: EQUAL
9510: IFTRUE 9514
9512: GO 9525
9514: POP
// frank_send_to_scout := true ; 2 :
9515: LD_ADDR_EXP 12
9519: PUSH
9520: LD_INT 1
9522: ST_TO_ADDR
9523: GO 9545
9525: LD_INT 2
9527: DOUBLE
9528: EQUAL
9529: IFTRUE 9533
9531: GO 9544
9533: POP
// frank_send_to_scout := false ; end ;
9534: LD_ADDR_EXP 12
9538: PUSH
9539: LD_INT 0
9541: ST_TO_ADDR
9542: GO 9545
9544: POP
// InGameOff ;
9545: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
9549: LD_EXP 31
9553: PUSH
9554: LD_EXP 34
9558: PUSH
9559: LD_EXP 41
9563: PUSH
9564: EMPTY
9565: LIST
9566: LIST
9567: LIST
9568: PPUSH
9569: CALL_OW 139
// if frank_send_to_scout then
9573: LD_EXP 12
9577: IFFALSE 9634
// begin ComMoveXY ( Frank , 130 , 123 ) ;
9579: LD_EXP 45
9583: PPUSH
9584: LD_INT 130
9586: PPUSH
9587: LD_INT 123
9589: PPUSH
9590: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
9594: LD_INT 35
9596: PPUSH
9597: CALL_OW 67
// until not See ( 1 , Frank ) ;
9601: LD_INT 1
9603: PPUSH
9604: LD_EXP 45
9608: PPUSH
9609: CALL_OW 292
9613: NOT
9614: IFFALSE 9594
// Wait ( 0 0$02 ) ;
9616: LD_INT 70
9618: PPUSH
9619: CALL_OW 67
// RemoveUnit ( Frank ) ;
9623: LD_EXP 45
9627: PPUSH
9628: CALL_OW 64
// end else
9632: GO 9646
// SetSide ( Frank , 1 ) ;
9634: LD_EXP 45
9638: PPUSH
9639: LD_INT 1
9641: PPUSH
9642: CALL_OW 235
// send_attack_on_cornel_base := true ;
9646: LD_ADDR_EXP 23
9650: PUSH
9651: LD_INT 1
9653: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9654: LD_INT 35
9656: PPUSH
9657: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
9661: LD_ADDR_EXP 25
9665: PUSH
9666: LD_EXP 25
9670: PPUSH
9671: LD_STRING -
9673: PPUSH
9674: CALL 1071 0 2
9678: ST_TO_ADDR
// if debug then
9679: LD_EXP 1
9683: IFFALSE 9695
// debug_strings := time_to_prepare ;
9685: LD_ADDR_OWVAR 48
9689: PUSH
9690: LD_EXP 25
9694: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
9695: LD_EXP 25
9699: PUSH
9700: LD_INT 0
9702: EQUAL
9703: IFFALSE 9654
// cornel_prepared := true ;
9705: LD_ADDR_EXP 9
9709: PUSH
9710: LD_INT 1
9712: ST_TO_ADDR
// end ;
9713: PPOPN 2
9715: END
// every 0 0$01 trigger cornel_prepared do
9716: LD_EXP 9
9720: IFFALSE 9966
9722: GO 9724
9724: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
9725: LD_EXP 38
9729: PPUSH
9730: LD_STRING D3-Corn-1
9732: PPUSH
9733: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
9737: LD_INT 35
9739: PPUSH
9740: CALL_OW 67
// until cornel_counter = 0 ;
9744: LD_EXP 8
9748: PUSH
9749: LD_INT 0
9751: EQUAL
9752: IFFALSE 9737
// SayRadio ( Cornel , D3a-Corn-1 ) ;
9754: LD_EXP 38
9758: PPUSH
9759: LD_STRING D3a-Corn-1
9761: PPUSH
9762: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
9766: LD_EXP 31
9770: PPUSH
9771: LD_STRING D3a-JMM-1
9773: PPUSH
9774: CALL_OW 88
// end_mission_allowed := true ;
9778: LD_ADDR_EXP 18
9782: PUSH
9783: LD_INT 1
9785: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
9786: LD_STRING M2
9788: PPUSH
9789: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
9793: LD_INT 9
9795: PPUSH
9796: LD_INT 1
9798: PPUSH
9799: CALL_OW 424
// Wait ( 0 0$05 ) ;
9803: LD_INT 175
9805: PPUSH
9806: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
9810: LD_EXP 38
9814: PPUSH
9815: LD_STRING D3a-Corn-2
9817: PPUSH
9818: CALL_OW 94
// cornel_attack := true ;
9822: LD_ADDR_EXP 7
9826: PUSH
9827: LD_INT 1
9829: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
9830: LD_INT 105
9832: PPUSH
9833: CALL_OW 67
// AddMoreTanks ( ) ;
9837: CALL 4729 0 0
// if frank_send_to_scout then
9841: LD_EXP 12
9845: IFFALSE 9966
// begin InitHc ;
9847: CALL_OW 19
// InitUc ;
9851: CALL_OW 18
// uc_side := 8 ;
9855: LD_ADDR_OWVAR 20
9859: PUSH
9860: LD_INT 8
9862: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9863: LD_ADDR_EXP 45
9867: PUSH
9868: LD_STRING Frank
9870: PPUSH
9871: LD_INT 0
9873: PPUSH
9874: CALL 434 0 2
9878: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
9879: LD_EXP 45
9883: PPUSH
9884: LD_INT 6
9886: PPUSH
9887: LD_INT 9
9889: PPUSH
9890: LD_INT 0
9892: PPUSH
9893: CALL_OW 48
// ComCrawl ( Frank ) ;
9897: LD_EXP 45
9901: PPUSH
9902: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
9906: LD_INT 35
9908: PPUSH
9909: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
9913: LD_EXP 31
9917: PPUSH
9918: LD_EXP 45
9922: PPUSH
9923: CALL_OW 296
9927: PUSH
9928: LD_INT 9
9930: LESS
9931: IFFALSE 9906
// SetSide ( Frank , 1 ) ;
9933: LD_EXP 45
9937: PPUSH
9938: LD_INT 1
9940: PPUSH
9941: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
9945: LD_EXP 45
9949: PPUSH
9950: LD_STRING D6a-Frank-1
9952: PPUSH
9953: CALL_OW 88
// ComWalk ( Frank ) ;
9957: LD_EXP 45
9961: PPUSH
9962: CALL_OW 138
// end ; end ;
9966: END
// every 0 0$01 trigger solar_builded do
9967: LD_EXP 11
9971: IFFALSE 10075
9973: GO 9975
9975: DISABLE
// begin Wait ( 0 0$02 ) ;
9976: LD_INT 70
9978: PPUSH
9979: CALL_OW 67
// DialogueOn ;
9983: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
9987: LD_EXP 31
9991: PPUSH
9992: LD_STRING D2b-JMM-1
9994: PPUSH
9995: CALL_OW 88
// if Walker and IsOk ( Walker ) then
9999: LD_EXP 42
10003: PUSH
10004: LD_EXP 42
10008: PPUSH
10009: CALL_OW 302
10013: AND
10014: IFFALSE 10064
// begin Say ( Walker , D2b-Sci1-1 ) ;
10016: LD_EXP 42
10020: PPUSH
10021: LD_STRING D2b-Sci1-1
10023: PPUSH
10024: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10028: LD_EXP 31
10032: PPUSH
10033: LD_STRING D2b-JMM-2
10035: PPUSH
10036: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10040: LD_EXP 42
10044: PPUSH
10045: LD_STRING D2b-Sci1-2
10047: PPUSH
10048: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10052: LD_EXP 31
10056: PPUSH
10057: LD_STRING D2b-JMM-3
10059: PPUSH
10060: CALL_OW 88
// end ; DialogueOff ;
10064: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10068: LD_STRING MOutSol
10070: PPUSH
10071: CALL_OW 337
// end ;
10075: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10076: LD_EXP 11
10080: PUSH
10081: LD_EXP 31
10085: PPUSH
10086: CALL_OW 302
10090: AND
10091: PUSH
10092: LD_EXP 31
10096: PPUSH
10097: CALL 905 0 1
10101: AND
10102: PUSH
10103: LD_EXP 13
10107: NOT
10108: AND
10109: IFFALSE 10180
10111: GO 10113
10113: DISABLE
10114: LD_INT 0
10116: PPUSH
// begin jmm_in_veh := true ;
10117: LD_ADDR_EXP 13
10121: PUSH
10122: LD_INT 1
10124: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10125: LD_ADDR_VAR 0 1
10129: PUSH
10130: LD_INT 0
10132: PPUSH
10133: LD_INT 1
10135: PPUSH
10136: CALL_OW 12
10140: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10141: LD_INT 70
10143: PPUSH
10144: CALL_OW 67
// if i then
10148: LD_VAR 0 1
10152: IFFALSE 10168
// Say ( JMM , D2c-JMM-1 ) else
10154: LD_EXP 31
10158: PPUSH
10159: LD_STRING D2c-JMM-1
10161: PPUSH
10162: CALL_OW 88
10166: GO 10180
// Say ( JMM , D2c-JMM-1a ) ;
10168: LD_EXP 31
10172: PPUSH
10173: LD_STRING D2c-JMM-1a
10175: PPUSH
10176: CALL_OW 88
// end ;
10180: PPOPN 1
10182: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10183: LD_EXP 11
10187: PUSH
10188: LD_EXP 32
10192: PPUSH
10193: CALL_OW 302
10197: AND
10198: PUSH
10199: LD_EXP 32
10203: PPUSH
10204: CALL 905 0 1
10208: AND
10209: PUSH
10210: LD_EXP 14
10214: NOT
10215: AND
10216: IFFALSE 10248
10218: GO 10220
10220: DISABLE
// begin bobby_in_veh := true ;
10221: LD_ADDR_EXP 14
10225: PUSH
10226: LD_INT 1
10228: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10229: LD_INT 70
10231: PPUSH
10232: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10236: LD_EXP 32
10240: PPUSH
10241: LD_STRING D2c-Bobby-1
10243: PPUSH
10244: CALL_OW 88
10248: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10249: LD_EXP 11
10253: PUSH
10254: LD_EXP 34
10258: PPUSH
10259: CALL_OW 302
10263: AND
10264: PUSH
10265: LD_EXP 34
10269: PPUSH
10270: CALL 905 0 1
10274: AND
10275: PUSH
10276: LD_EXP 16
10280: NOT
10281: AND
10282: IFFALSE 10314
10284: GO 10286
10286: DISABLE
// begin lisa_in_veh := true ;
10287: LD_ADDR_EXP 16
10291: PUSH
10292: LD_INT 1
10294: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10295: LD_INT 70
10297: PPUSH
10298: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10302: LD_EXP 34
10306: PPUSH
10307: LD_STRING D2c-Lisa-1
10309: PPUSH
10310: CALL_OW 88
10314: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
10315: LD_EXP 11
10319: PUSH
10320: LD_EXP 33
10324: PPUSH
10325: CALL_OW 302
10329: AND
10330: PUSH
10331: LD_EXP 33
10335: PPUSH
10336: CALL 905 0 1
10340: AND
10341: PUSH
10342: LD_EXP 15
10346: NOT
10347: AND
10348: IFFALSE 10419
10350: GO 10352
10352: DISABLE
10353: LD_INT 0
10355: PPUSH
// begin cyrus_in_veh := true ;
10356: LD_ADDR_EXP 15
10360: PUSH
10361: LD_INT 1
10363: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10364: LD_ADDR_VAR 0 1
10368: PUSH
10369: LD_INT 0
10371: PPUSH
10372: LD_INT 1
10374: PPUSH
10375: CALL_OW 12
10379: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10380: LD_INT 70
10382: PPUSH
10383: CALL_OW 67
// if i then
10387: LD_VAR 0 1
10391: IFFALSE 10407
// Say ( Cyrus , D2c-Cyrus-1 ) else
10393: LD_EXP 33
10397: PPUSH
10398: LD_STRING D2c-Cyrus-1
10400: PPUSH
10401: CALL_OW 88
10405: GO 10419
// Say ( Cyrus , D2c-Cyrus-1a ) ;
10407: LD_EXP 33
10411: PPUSH
10412: LD_STRING D2c-Cyrus-1a
10414: PPUSH
10415: CALL_OW 88
// end ;
10419: PPOPN 1
10421: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
10422: LD_EXP 38
10426: PPUSH
10427: LD_INT 16
10429: PPUSH
10430: CALL_OW 308
10434: IFFALSE 10684
10436: GO 10438
10438: DISABLE
10439: LD_INT 0
10441: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
10442: LD_INT 3
10444: PPUSH
10445: LD_EXP 38
10449: PPUSH
10450: CALL_OW 471
// send_attack_on_cornel := true ;
10454: LD_ADDR_EXP 28
10458: PUSH
10459: LD_INT 1
10461: ST_TO_ADDR
// if ru_vehicles then
10462: LD_EXP 50
10466: IFFALSE 10500
// for i in ru_vehicles do
10468: LD_ADDR_VAR 0 1
10472: PUSH
10473: LD_EXP 50
10477: PUSH
10478: FOR_IN
10479: IFFALSE 10498
// ComAgressiveMove ( i , 215 , 69 ) ;
10481: LD_VAR 0 1
10485: PPUSH
10486: LD_INT 215
10488: PPUSH
10489: LD_INT 69
10491: PPUSH
10492: CALL_OW 114
10496: GO 10478
10498: POP
10499: POP
// if ru_patrol then
10500: LD_EXP 47
10504: IFFALSE 10538
// for i in ru_patrol do
10506: LD_ADDR_VAR 0 1
10510: PUSH
10511: LD_EXP 47
10515: PUSH
10516: FOR_IN
10517: IFFALSE 10536
// ComAgressiveMove ( i , 215 , 69 ) ;
10519: LD_VAR 0 1
10523: PPUSH
10524: LD_INT 215
10526: PPUSH
10527: LD_INT 69
10529: PPUSH
10530: CALL_OW 114
10534: GO 10516
10536: POP
10537: POP
// if frank_send_to_scout then
10538: LD_EXP 12
10542: IFFALSE 10556
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
10544: LD_EXP 45
10548: PPUSH
10549: LD_STRING D3b-Frank-1
10551: PPUSH
10552: CALL_OW 94
// end ; Wait ( 0 0$03 ) ;
10556: LD_INT 105
10558: PPUSH
10559: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
10563: LD_EXP 38
10567: PPUSH
10568: LD_STRING D4-Corn-1
10570: PPUSH
10571: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10575: LD_INT 35
10577: PPUSH
10578: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 6 ;
10582: LD_INT 22
10584: PUSH
10585: LD_INT 4
10587: PUSH
10588: EMPTY
10589: LIST
10590: LIST
10591: PUSH
10592: LD_INT 21
10594: PUSH
10595: LD_INT 1
10597: PUSH
10598: EMPTY
10599: LIST
10600: LIST
10601: PUSH
10602: LD_INT 50
10604: PUSH
10605: EMPTY
10606: LIST
10607: PUSH
10608: EMPTY
10609: LIST
10610: LIST
10611: LIST
10612: PPUSH
10613: CALL_OW 69
10617: PUSH
10618: LD_INT 6
10620: LESS
10621: IFFALSE 10575
// SayRadio ( Cornel , D5-Corn-1 ) ;
10623: LD_EXP 38
10627: PPUSH
10628: LD_STRING D5-Corn-1
10630: PPUSH
10631: CALL_OW 94
// SaveCharacters ( Cornel , Cornel ) ;
10635: LD_EXP 38
10639: PPUSH
10640: LD_STRING Cornel
10642: PPUSH
10643: CALL_OW 38
// ChangeSideFog ( 4 , 8 ) ;
10647: LD_INT 4
10649: PPUSH
10650: LD_INT 8
10652: PPUSH
10653: CALL_OW 343
// Wait ( 0 0$01 ) ;
10657: LD_INT 35
10659: PPUSH
10660: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
10664: LD_INT 3
10666: PPUSH
10667: LD_EXP 38
10671: PPUSH
10672: CALL_OW 472
// send_attack_on_cornel := false ;
10676: LD_ADDR_EXP 28
10680: PUSH
10681: LD_INT 0
10683: ST_TO_ADDR
// end ;
10684: PPOPN 1
10686: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
10687: LD_INT 9
10689: PPUSH
10690: LD_INT 22
10692: PUSH
10693: LD_INT 1
10695: PUSH
10696: EMPTY
10697: LIST
10698: LIST
10699: PPUSH
10700: CALL_OW 70
10704: PUSH
10705: LD_EXP 29
10709: OR
10710: IFFALSE 11229
10712: GO 10714
10714: DISABLE
10715: LD_INT 0
10717: PPUSH
10718: PPUSH
// begin enable ;
10719: ENABLE
// if not game_end then
10720: LD_EXP 29
10724: NOT
10725: IFFALSE 10735
// game_end := true ;
10727: LD_ADDR_EXP 29
10731: PUSH
10732: LD_INT 1
10734: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
10735: LD_ADDR_VAR 0 2
10739: PUSH
10740: LD_INT 9
10742: PPUSH
10743: LD_INT 22
10745: PUSH
10746: LD_INT 1
10748: PUSH
10749: EMPTY
10750: LIST
10751: LIST
10752: PPUSH
10753: CALL_OW 70
10757: ST_TO_ADDR
// if not filter then
10758: LD_VAR 0 2
10762: NOT
10763: IFFALSE 10767
// exit ;
10765: GO 11229
// for i in filter do
10767: LD_ADDR_VAR 0 1
10771: PUSH
10772: LD_VAR 0 2
10776: PUSH
10777: FOR_IN
10778: IFFALSE 11227
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
10780: LD_VAR 0 1
10784: PPUSH
10785: CALL_OW 302
10789: PUSH
10790: LD_VAR 0 1
10794: PPUSH
10795: CALL_OW 247
10799: PUSH
10800: LD_INT 2
10802: EQUAL
10803: AND
10804: IFFALSE 10844
// begin veh_on_meta := true ;
10806: LD_ADDR_EXP 24
10810: PUSH
10811: LD_INT 1
10813: ST_TO_ADDR
// ComExitVehicle ( IsInUnit ( i ) ) ;
10814: LD_VAR 0 1
10818: PPUSH
10819: CALL_OW 310
10823: PPUSH
10824: CALL_OW 121
// RemoveUnit ( i ) ;
10828: LD_VAR 0 1
10832: PPUSH
10833: CALL_OW 64
// Wait ( 10 ) ;
10837: LD_INT 10
10839: PPUSH
10840: CALL_OW 67
// end ; if i = JMM then
10844: LD_VAR 0 1
10848: PUSH
10849: LD_EXP 31
10853: EQUAL
10854: IFFALSE 10976
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
10856: LD_EXP 21
10860: PUSH
10861: LD_INT 22
10863: PUSH
10864: LD_INT 1
10866: PUSH
10867: EMPTY
10868: LIST
10869: LIST
10870: PUSH
10871: LD_INT 21
10873: PUSH
10874: LD_INT 1
10876: PUSH
10877: EMPTY
10878: LIST
10879: LIST
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PPUSH
10885: CALL_OW 69
10889: PUSH
10890: LD_INT 1
10892: GREATER
10893: AND
10894: IFFALSE 10951
// begin show_query := false ;
10896: LD_ADDR_EXP 21
10900: PUSH
10901: LD_INT 0
10903: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
10904: LD_STRING Q2
10906: PPUSH
10907: CALL_OW 97
10911: PUSH
10912: LD_INT 1
10914: DOUBLE
10915: EQUAL
10916: IFTRUE 10920
10918: GO 10931
10920: POP
// wait_for_them := true ; 2 :
10921: LD_ADDR_EXP 22
10925: PUSH
10926: LD_INT 1
10928: ST_TO_ADDR
10929: GO 10951
10931: LD_INT 2
10933: DOUBLE
10934: EQUAL
10935: IFTRUE 10939
10937: GO 10950
10939: POP
// wait_for_them := false ; end ;
10940: LD_ADDR_EXP 22
10944: PUSH
10945: LD_INT 0
10947: ST_TO_ADDR
10948: GO 10951
10950: POP
// end ; save_group := save_group ^ JMM ;
10951: LD_ADDR_EXP 20
10955: PUSH
10956: LD_EXP 20
10960: PUSH
10961: LD_EXP 31
10965: ADD
10966: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
10967: LD_EXP 31
10971: PPUSH
10972: CALL_OW 64
// end ; if i = Lisa then
10976: LD_VAR 0 1
10980: PUSH
10981: LD_EXP 34
10985: EQUAL
10986: IFFALSE 11013
// begin save_group := save_group ^ Lisa ;
10988: LD_ADDR_EXP 20
10992: PUSH
10993: LD_EXP 20
10997: PUSH
10998: LD_EXP 34
11002: ADD
11003: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11004: LD_EXP 34
11008: PPUSH
11009: CALL_OW 64
// end ; if i = Bobby then
11013: LD_VAR 0 1
11017: PUSH
11018: LD_EXP 32
11022: EQUAL
11023: IFFALSE 11050
// begin save_group := save_group ^ Bobby ;
11025: LD_ADDR_EXP 20
11029: PUSH
11030: LD_EXP 20
11034: PUSH
11035: LD_EXP 32
11039: ADD
11040: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11041: LD_EXP 32
11045: PPUSH
11046: CALL_OW 64
// end ; if i = Cyrus then
11050: LD_VAR 0 1
11054: PUSH
11055: LD_EXP 33
11059: EQUAL
11060: IFFALSE 11087
// begin save_group := save_group ^ Cyrus ;
11062: LD_ADDR_EXP 20
11066: PUSH
11067: LD_EXP 20
11071: PUSH
11072: LD_EXP 33
11076: ADD
11077: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11078: LD_EXP 33
11082: PPUSH
11083: CALL_OW 64
// end ; if i = Khatam then
11087: LD_VAR 0 1
11091: PUSH
11092: LD_EXP 35
11096: EQUAL
11097: IFFALSE 11124
// begin save_group := save_group ^ Khatam ;
11099: LD_ADDR_EXP 20
11103: PUSH
11104: LD_EXP 20
11108: PUSH
11109: LD_EXP 35
11113: ADD
11114: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11115: LD_EXP 35
11119: PPUSH
11120: CALL_OW 64
// end ; if i = Frank then
11124: LD_VAR 0 1
11128: PUSH
11129: LD_EXP 45
11133: EQUAL
11134: IFFALSE 11161
// begin save_group := save_group ^ Frank ;
11136: LD_ADDR_EXP 20
11140: PUSH
11141: LD_EXP 20
11145: PUSH
11146: LD_EXP 45
11150: ADD
11151: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11152: LD_EXP 45
11156: PPUSH
11157: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11161: LD_VAR 0 1
11165: PPUSH
11166: CALL_OW 302
11170: PUSH
11171: LD_VAR 0 1
11175: PPUSH
11176: CALL_OW 247
11180: PUSH
11181: LD_INT 1
11183: EQUAL
11184: AND
11185: PUSH
11186: LD_VAR 0 1
11190: PUSH
11191: LD_EXP 20
11195: IN
11196: NOT
11197: AND
11198: IFFALSE 11225
// begin save_others := save_others ^ i ;
11200: LD_ADDR_EXP 19
11204: PUSH
11205: LD_EXP 19
11209: PUSH
11210: LD_VAR 0 1
11214: ADD
11215: ST_TO_ADDR
// RemoveUnit ( i ) ;
11216: LD_VAR 0 1
11220: PPUSH
11221: CALL_OW 64
// end ; end ;
11225: GO 10777
11227: POP
11228: POP
// end ;
11229: PPOPN 2
11231: END
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
11232: LD_EXP 21
11236: NOT
11237: PUSH
11238: LD_EXP 22
11242: NOT
11243: AND
11244: PUSH
11245: LD_INT 22
11247: PUSH
11248: LD_INT 1
11250: PUSH
11251: EMPTY
11252: LIST
11253: LIST
11254: PUSH
11255: LD_INT 21
11257: PUSH
11258: LD_INT 1
11260: PUSH
11261: EMPTY
11262: LIST
11263: LIST
11264: PUSH
11265: EMPTY
11266: LIST
11267: LIST
11268: PPUSH
11269: CALL_OW 69
11273: PUSH
11274: LD_INT 0
11276: EQUAL
11277: OR
11278: IFFALSE 11287
11280: GO 11282
11282: DISABLE
// EndMission ;
11283: CALL 11288 0 0
11287: END
// export function EndMission ; var i ; begin
11288: LD_INT 0
11290: PPUSH
11291: PPUSH
// Wait ( 0 0$02 ) ;
11292: LD_INT 70
11294: PPUSH
11295: CALL_OW 67
// if solar_builded then
11299: LD_EXP 11
11303: IFFALSE 11317
// AddMedal ( Solar1 , 1 ) else
11305: LD_STRING Solar1
11307: PPUSH
11308: LD_INT 1
11310: PPUSH
11311: CALL_OW 101
11315: GO 11328
// AddMedal ( Solar1 , - 1 ) ;
11317: LD_STRING Solar1
11319: PPUSH
11320: LD_INT 1
11322: NEG
11323: PPUSH
11324: CALL_OW 101
// if veh_on_meta then
11328: LD_EXP 24
11332: IFFALSE 11346
// AddMedal ( Solar2 , 1 ) else
11334: LD_STRING Solar2
11336: PPUSH
11337: LD_INT 1
11339: PPUSH
11340: CALL_OW 101
11344: GO 11376
// if solar_builded then
11346: LD_EXP 11
11350: IFFALSE 11365
// AddMedal ( Solar2 , - 1 ) else
11352: LD_STRING Solar2
11354: PPUSH
11355: LD_INT 1
11357: NEG
11358: PPUSH
11359: CALL_OW 101
11363: GO 11376
// AddMedal ( Solar2 , - 2 ) ;
11365: LD_STRING Solar2
11367: PPUSH
11368: LD_INT 2
11370: NEG
11371: PPUSH
11372: CALL_OW 101
// if lose_counter = 0 then
11376: LD_EXP 30
11380: PUSH
11381: LD_INT 0
11383: EQUAL
11384: IFFALSE 11398
// AddMedal ( No , 1 ) else
11386: LD_STRING No
11388: PPUSH
11389: LD_INT 1
11391: PPUSH
11392: CALL_OW 101
11396: GO 11442
// if lose_counter > 0 and lose_counter < 4 then
11398: LD_EXP 30
11402: PUSH
11403: LD_INT 0
11405: GREATER
11406: PUSH
11407: LD_EXP 30
11411: PUSH
11412: LD_INT 4
11414: LESS
11415: AND
11416: IFFALSE 11431
// AddMedal ( No , - 1 ) else
11418: LD_STRING No
11420: PPUSH
11421: LD_INT 1
11423: NEG
11424: PPUSH
11425: CALL_OW 101
11429: GO 11442
// AddMedal ( UpTo4 , - 1 ) ;
11431: LD_STRING UpTo4
11433: PPUSH
11434: LD_INT 1
11436: NEG
11437: PPUSH
11438: CALL_OW 101
// GiveMedals ( MAIN ) ;
11442: LD_STRING MAIN
11444: PPUSH
11445: CALL_OW 102
// if IsDead ( Pokryshkin ) then
11449: LD_EXP 46
11453: PPUSH
11454: CALL_OW 301
11458: IFFALSE 11498
// for i in save_group ^ save_others do
11460: LD_ADDR_VAR 0 2
11464: PUSH
11465: LD_EXP 20
11469: PUSH
11470: LD_EXP 19
11474: ADD
11475: PUSH
11476: FOR_IN
11477: IFFALSE 11496
// AddExperience ( i , skill_combat , 1500 ) ;
11479: LD_VAR 0 2
11483: PPUSH
11484: LD_INT 1
11486: PPUSH
11487: LD_INT 1500
11489: PPUSH
11490: CALL_OW 492
11494: GO 11476
11496: POP
11497: POP
// RewardPeople ( save_group ^ save_others ) ;
11498: LD_EXP 20
11502: PUSH
11503: LD_EXP 19
11507: ADD
11508: PPUSH
11509: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
11513: LD_EXP 31
11517: PPUSH
11518: LD_STRING JMM
11520: PPUSH
11521: CALL_OW 38
// if Bobby in save_group then
11525: LD_EXP 32
11529: PUSH
11530: LD_EXP 20
11534: IN
11535: IFFALSE 11551
// SaveCharacters ( Bobby , Bobby ) else
11537: LD_EXP 32
11541: PPUSH
11542: LD_STRING Bobby
11544: PPUSH
11545: CALL_OW 38
11549: GO 11558
// DeleteCharacters ( Bobby ) ;
11551: LD_STRING Bobby
11553: PPUSH
11554: CALL_OW 40
// if Cyrus in save_group then
11558: LD_EXP 33
11562: PUSH
11563: LD_EXP 20
11567: IN
11568: IFFALSE 11584
// SaveCharacters ( Cyrus , Cyrus ) else
11570: LD_EXP 33
11574: PPUSH
11575: LD_STRING Cyrus
11577: PPUSH
11578: CALL_OW 38
11582: GO 11591
// DeleteCharacters ( Cyrus ) ;
11584: LD_STRING Cyrus
11586: PPUSH
11587: CALL_OW 40
// if Lisa in save_group then
11591: LD_EXP 34
11595: PUSH
11596: LD_EXP 20
11600: IN
11601: IFFALSE 11617
// SaveCharacters ( Lisa , Lisa ) else
11603: LD_EXP 34
11607: PPUSH
11608: LD_STRING Lisa
11610: PPUSH
11611: CALL_OW 38
11615: GO 11624
// DeleteCharacters ( Lisa ) ;
11617: LD_STRING Lisa
11619: PPUSH
11620: CALL_OW 40
// if Frank in save_group then
11624: LD_EXP 45
11628: PUSH
11629: LD_EXP 20
11633: IN
11634: IFFALSE 11650
// SaveCharacters ( Frank , Frank ) else
11636: LD_EXP 45
11640: PPUSH
11641: LD_STRING Frank
11643: PPUSH
11644: CALL_OW 38
11648: GO 11657
// DeleteCharacters ( Frank ) ;
11650: LD_STRING Frank
11652: PPUSH
11653: CALL_OW 40
// if Khatam in save_group then
11657: LD_EXP 35
11661: PUSH
11662: LD_EXP 20
11666: IN
11667: IFFALSE 11683
// SaveCharacters ( Khatam , Khatam ) else
11669: LD_EXP 35
11673: PPUSH
11674: LD_STRING Khatam
11676: PPUSH
11677: CALL_OW 38
11681: GO 11690
// DeleteCharacters ( Khatam ) ;
11683: LD_STRING Khatam
11685: PPUSH
11686: CALL_OW 40
// if save_others then
11690: LD_EXP 19
11694: IFFALSE 11708
// SaveCharacters ( save_others , 03_others ) ;
11696: LD_EXP 19
11700: PPUSH
11701: LD_STRING 03_others
11703: PPUSH
11704: CALL_OW 38
// DeleteCharacters ( Brian ) ;
11708: LD_STRING Brian
11710: PPUSH
11711: CALL_OW 40
// DeleteCharacters ( Jimmy ) ;
11715: LD_STRING Jimmy
11717: PPUSH
11718: CALL_OW 40
// if Bierezov and IsOk ( Bierezov ) then
11722: LD_EXP 39
11726: PUSH
11727: LD_EXP 39
11731: PPUSH
11732: CALL_OW 302
11736: AND
11737: IFFALSE 11749
// begin ResetFog ;
11739: CALL_OW 335
// DisplayEndingScene ;
11743: CALL 11765 0 0
// end else
11747: GO 11756
// DeleteCharacters ( Cornel ) ;
11749: LD_STRING Cornel
11751: PPUSH
11752: CALL_OW 40
// YouWin ;
11756: CALL_OW 103
// end ;
11760: LD_VAR 0 1
11764: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
11765: LD_INT 0
11767: PPUSH
11768: PPUSH
11769: PPUSH
11770: PPUSH
11771: PPUSH
11772: PPUSH
// InGameOn ;
11773: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
11777: LD_INT 208
11779: PPUSH
11780: LD_INT 62
11782: PPUSH
11783: LD_INT 1
11785: PPUSH
11786: LD_INT 10
11788: NEG
11789: PPUSH
11790: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
11794: LD_INT 208
11796: PPUSH
11797: LD_INT 62
11799: PPUSH
11800: LD_INT 1
11802: PPUSH
11803: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11807: LD_ADDR_VAR 0 3
11811: PUSH
11812: LD_INT 22
11814: PUSH
11815: LD_INT 3
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: PUSH
11822: LD_INT 2
11824: PUSH
11825: LD_INT 21
11827: PUSH
11828: LD_INT 2
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: PUSH
11835: LD_INT 21
11837: PUSH
11838: LD_INT 1
11840: PUSH
11841: EMPTY
11842: LIST
11843: LIST
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: LIST
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PPUSH
11854: CALL_OW 69
11858: ST_TO_ADDR
// if filter then
11859: LD_VAR 0 3
11863: IFFALSE 11891
// for i in filter do
11865: LD_ADDR_VAR 0 2
11869: PUSH
11870: LD_VAR 0 3
11874: PUSH
11875: FOR_IN
11876: IFFALSE 11889
// RemoveUnit ( i ) ;
11878: LD_VAR 0 2
11882: PPUSH
11883: CALL_OW 64
11887: GO 11875
11889: POP
11890: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
11891: LD_ADDR_VAR 0 3
11895: PUSH
11896: LD_INT 22
11898: PUSH
11899: LD_INT 4
11901: PUSH
11902: EMPTY
11903: LIST
11904: LIST
11905: PUSH
11906: LD_INT 21
11908: PUSH
11909: LD_INT 1
11911: PUSH
11912: EMPTY
11913: LIST
11914: LIST
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: PPUSH
11920: CALL_OW 69
11924: ST_TO_ADDR
// if filter then
11925: LD_VAR 0 3
11929: IFFALSE 11960
// for i in filter do
11931: LD_ADDR_VAR 0 2
11935: PUSH
11936: LD_VAR 0 3
11940: PUSH
11941: FOR_IN
11942: IFFALSE 11958
// SetLives ( i , 0 ) ;
11944: LD_VAR 0 2
11948: PPUSH
11949: LD_INT 0
11951: PPUSH
11952: CALL_OW 234
11956: GO 11941
11958: POP
11959: POP
// uc_side := 4 ;
11960: LD_ADDR_OWVAR 20
11964: PUSH
11965: LD_INT 4
11967: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
11968: LD_ADDR_VAR 0 4
11972: PUSH
11973: LD_STRING Cornell
11975: PPUSH
11976: LD_INT 0
11978: PPUSH
11979: CALL 434 0 2
11983: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
11984: LD_VAR 0 4
11988: PPUSH
11989: LD_INT 208
11991: PPUSH
11992: LD_INT 62
11994: PPUSH
11995: LD_INT 0
11997: PPUSH
11998: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12002: LD_VAR 0 4
12006: PPUSH
12007: LD_INT 100
12009: PPUSH
12010: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12014: LD_INT 3
12016: PPUSH
12017: LD_VAR 0 4
12021: PPUSH
12022: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12026: LD_INT 4
12028: PPUSH
12029: LD_INT 3
12031: PPUSH
12032: LD_INT 1
12034: PPUSH
12035: LD_INT 1
12037: PPUSH
12038: CALL_OW 80
// uc_side := 3 ;
12042: LD_ADDR_OWVAR 20
12046: PUSH
12047: LD_INT 3
12049: ST_TO_ADDR
// uc_nation := 3 ;
12050: LD_ADDR_OWVAR 21
12054: PUSH
12055: LD_INT 3
12057: ST_TO_ADDR
// InitHc ;
12058: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12062: LD_ADDR_VAR 0 5
12066: PUSH
12067: LD_STRING Mikhail
12069: PPUSH
12070: LD_INT 0
12072: PPUSH
12073: CALL 434 0 2
12077: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12078: LD_INT 1
12080: PPUSH
12081: LD_INT 1
12083: PPUSH
12084: LD_INT 0
12086: PPUSH
12087: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12091: LD_ADDR_VAR 0 6
12095: PUSH
12096: LD_VAR 0 6
12100: PUSH
12101: CALL_OW 44
12105: ADD
12106: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12107: LD_ADDR_VAR 0 6
12111: PUSH
12112: LD_VAR 0 6
12116: PUSH
12117: CALL_OW 44
12121: ADD
12122: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12123: LD_INT 2
12125: PPUSH
12126: LD_INT 4
12128: PPUSH
12129: LD_INT 0
12131: PPUSH
12132: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12136: LD_ADDR_VAR 0 6
12140: PUSH
12141: LD_VAR 0 6
12145: PUSH
12146: CALL_OW 44
12150: ADD
12151: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12152: LD_VAR 0 5
12156: PPUSH
12157: LD_INT 17
12159: PPUSH
12160: LD_INT 0
12162: PPUSH
12163: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12167: LD_VAR 0 5
12171: PPUSH
12172: LD_INT 210
12174: PPUSH
12175: LD_INT 63
12177: PPUSH
12178: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12182: LD_VAR 0 5
12186: PPUSH
12187: LD_INT 208
12189: PPUSH
12190: LD_INT 62
12192: PPUSH
12193: CALL_OW 178
// for i in fake_russians do
12197: LD_ADDR_VAR 0 2
12201: PUSH
12202: LD_VAR 0 6
12206: PUSH
12207: FOR_IN
12208: IFFALSE 12286
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12210: LD_VAR 0 2
12214: PPUSH
12215: LD_INT 17
12217: PPUSH
12218: LD_INT 0
12220: PPUSH
12221: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
12225: LD_VAR 0 2
12229: PPUSH
12230: LD_INT 215
12232: PPUSH
12233: LD_INT 67
12235: PPUSH
12236: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
12240: LD_VAR 0 2
12244: PPUSH
12245: LD_INT 208
12247: PPUSH
12248: LD_INT 62
12250: PPUSH
12251: CALL_OW 178
// if GetClass ( i ) = 4 then
12255: LD_VAR 0 2
12259: PPUSH
12260: CALL_OW 257
12264: PUSH
12265: LD_INT 4
12267: EQUAL
12268: IFFALSE 12284
// ComHeal ( i , fake_cornel ) ;
12270: LD_VAR 0 2
12274: PPUSH
12275: LD_VAR 0 4
12279: PPUSH
12280: CALL_OW 128
// end ;
12284: GO 12207
12286: POP
12287: POP
// Wait ( 0 0$01 ) ;
12288: LD_INT 35
12290: PPUSH
12291: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
12295: LD_INT 208
12297: PPUSH
12298: LD_INT 62
12300: PPUSH
12301: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12305: LD_INT 208
12307: PPUSH
12308: LD_INT 62
12310: PPUSH
12311: LD_INT 1
12313: PPUSH
12314: LD_INT 10
12316: NEG
12317: PPUSH
12318: CALL_OW 330
// Wait ( 0 0$15 ) ;
12322: LD_INT 525
12324: PPUSH
12325: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
12329: LD_INT 208
12331: PPUSH
12332: LD_INT 62
12334: PPUSH
12335: LD_INT 1
12337: PPUSH
12338: CALL_OW 331
// ResetFog ;
12342: CALL_OW 335
// InGameOff ;
12346: CALL_OW 9
// end ;
12350: LD_VAR 0 1
12354: RET
// every 0 0$30 trigger GetDistUnits ( JMM , Cornel ) < 3 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) do
12355: LD_EXP 31
12359: PPUSH
12360: LD_EXP 38
12364: PPUSH
12365: CALL_OW 296
12369: PUSH
12370: LD_INT 3
12372: LESS
12373: PUSH
12374: LD_INT 22
12376: PUSH
12377: LD_INT 4
12379: PUSH
12380: EMPTY
12381: LIST
12382: LIST
12383: PUSH
12384: LD_INT 21
12386: PUSH
12387: LD_INT 3
12389: PUSH
12390: EMPTY
12391: LIST
12392: LIST
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PPUSH
12398: CALL_OW 69
12402: AND
12403: IFFALSE 12421
12405: GO 12407
12407: DISABLE
// begin enable ;
12408: ENABLE
// SayRadio ( Powell , DWarn-Pow-1 ) ;
12409: LD_EXP 40
12413: PPUSH
12414: LD_STRING DWarn-Pow-1
12416: PPUSH
12417: CALL_OW 94
// end ; end_of_file
12421: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
12422: LD_EXP 6
12426: IFFALSE 13652
12428: GO 12430
12430: DISABLE
12431: LD_INT 0
12433: PPUSH
12434: PPUSH
12435: PPUSH
12436: PPUSH
12437: PPUSH
12438: PPUSH
12439: PPUSH
12440: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
12441: LD_EXP 38
12445: PUSH
12446: LD_EXP 39
12450: ADD
12451: PUSH
12452: LD_EXP 4
12456: ADD
12457: PPUSH
12458: LD_INT 250
12460: PPUSH
12461: LD_INT 120
12463: PPUSH
12464: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
12468: LD_ADDR_VAR 0 2
12472: PUSH
12473: LD_EXP 4
12477: PPUSH
12478: LD_INT 25
12480: PUSH
12481: LD_INT 2
12483: PUSH
12484: EMPTY
12485: LIST
12486: LIST
12487: PPUSH
12488: CALL_OW 72
12492: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
12493: LD_ADDR_VAR 0 3
12497: PUSH
12498: LD_EXP 4
12502: PPUSH
12503: LD_INT 21
12505: PUSH
12506: LD_INT 1
12508: PUSH
12509: EMPTY
12510: LIST
12511: LIST
12512: PPUSH
12513: CALL_OW 72
12517: ST_TO_ADDR
// if not has_eng then
12518: LD_VAR 0 2
12522: NOT
12523: IFFALSE 12606
// begin uc_side := 4 ;
12525: LD_ADDR_OWVAR 20
12529: PUSH
12530: LD_INT 4
12532: ST_TO_ADDR
// uc_nation := 1 ;
12533: LD_ADDR_OWVAR 21
12537: PUSH
12538: LD_INT 1
12540: ST_TO_ADDR
// bc_type := b_depot ;
12541: LD_ADDR_OWVAR 42
12545: PUSH
12546: LD_INT 0
12548: ST_TO_ADDR
// bc_level := 2 ;
12549: LD_ADDR_OWVAR 43
12553: PUSH
12554: LD_INT 2
12556: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
12557: LD_ADDR_VAR 0 4
12561: PUSH
12562: LD_INT 264
12564: PPUSH
12565: LD_INT 120
12567: PPUSH
12568: LD_INT 4
12570: PPUSH
12571: CALL_OW 47
12575: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
12576: LD_INT 264
12578: PPUSH
12579: LD_INT 120
12581: PPUSH
12582: LD_INT 4
12584: PPUSH
12585: LD_INT 10
12587: NEG
12588: PPUSH
12589: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
12593: LD_INT 264
12595: PPUSH
12596: LD_INT 120
12598: PPUSH
12599: LD_INT 4
12601: PPUSH
12602: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
12606: LD_INT 35
12608: PPUSH
12609: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
12613: LD_EXP 38
12617: PPUSH
12618: LD_INT 10
12620: PPUSH
12621: CALL_OW 308
12625: IFFALSE 12606
// if has_eng and not dep then
12627: LD_VAR 0 2
12631: PUSH
12632: LD_VAR 0 4
12636: NOT
12637: AND
12638: IFFALSE 12752
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
12640: LD_VAR 0 2
12644: PPUSH
12645: LD_INT 0
12647: PPUSH
12648: LD_INT 264
12650: PPUSH
12651: LD_INT 120
12653: PPUSH
12654: LD_INT 4
12656: PPUSH
12657: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
12661: LD_INT 35
12663: PPUSH
12664: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
12668: LD_INT 22
12670: PUSH
12671: LD_INT 4
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: PUSH
12678: LD_INT 30
12680: PUSH
12681: LD_INT 0
12683: PUSH
12684: EMPTY
12685: LIST
12686: LIST
12687: PUSH
12688: LD_INT 3
12690: PUSH
12691: LD_INT 57
12693: PUSH
12694: EMPTY
12695: LIST
12696: PUSH
12697: EMPTY
12698: LIST
12699: LIST
12700: PUSH
12701: EMPTY
12702: LIST
12703: LIST
12704: LIST
12705: PPUSH
12706: CALL_OW 69
12710: IFFALSE 12661
// dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
12712: LD_ADDR_VAR 0 4
12716: PUSH
12717: LD_INT 22
12719: PUSH
12720: LD_INT 4
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: PUSH
12727: LD_INT 30
12729: PUSH
12730: LD_INT 0
12732: PUSH
12733: EMPTY
12734: LIST
12735: LIST
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: PPUSH
12741: CALL_OW 69
12745: PUSH
12746: LD_INT 1
12748: ARRAY
12749: ST_TO_ADDR
// end else
12750: GO 12869
// begin SetSide ( dep , 4 ) ;
12752: LD_VAR 0 4
12756: PPUSH
12757: LD_INT 4
12759: PPUSH
12760: CALL_OW 235
// for i = 1 to 3 do
12764: LD_ADDR_VAR 0 1
12768: PUSH
12769: DOUBLE
12770: LD_INT 1
12772: DEC
12773: ST_TO_ADDR
12774: LD_INT 3
12776: PUSH
12777: FOR_TO
12778: IFFALSE 12835
// begin ComEnterUnit ( filter [ i ] , dep ) ;
12780: LD_VAR 0 3
12784: PUSH
12785: LD_VAR 0 1
12789: ARRAY
12790: PPUSH
12791: LD_VAR 0 4
12795: PPUSH
12796: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
12800: LD_VAR 0 3
12804: PUSH
12805: LD_VAR 0 1
12809: ARRAY
12810: PPUSH
12811: LD_INT 2
12813: PPUSH
12814: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
12818: LD_VAR 0 3
12822: PUSH
12823: LD_VAR 0 1
12827: ARRAY
12828: PPUSH
12829: CALL_OW 182
// end ;
12833: GO 12777
12835: POP
12836: POP
// repeat wait ( 0 0$01 ) ;
12837: LD_INT 35
12839: PPUSH
12840: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
12844: LD_VAR 0 3
12848: PPUSH
12849: LD_INT 25
12851: PUSH
12852: LD_INT 2
12854: PUSH
12855: EMPTY
12856: LIST
12857: LIST
12858: PPUSH
12859: CALL_OW 72
12863: PUSH
12864: LD_INT 3
12866: EQUAL
12867: IFFALSE 12837
// end ; if IsInUnit ( Cornel ) then
12869: LD_EXP 38
12873: PPUSH
12874: CALL_OW 310
12878: IFFALSE 12961
// begin cargo := IsInUnit ( Cornel ) ;
12880: LD_ADDR_VAR 0 7
12884: PUSH
12885: LD_EXP 38
12889: PPUSH
12890: CALL_OW 310
12894: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
12895: LD_VAR 0 7
12899: PPUSH
12900: LD_INT 1
12902: PPUSH
12903: CALL_OW 289
12907: IFFALSE 12923
// ComGive ( Cornel , dep ) ;
12909: LD_EXP 38
12913: PPUSH
12914: LD_VAR 0 4
12918: PPUSH
12919: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
12923: LD_EXP 38
12927: PPUSH
12928: LD_INT 235
12930: PPUSH
12931: LD_INT 122
12933: PPUSH
12934: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
12938: LD_EXP 38
12942: PPUSH
12943: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
12947: LD_EXP 38
12951: PPUSH
12952: LD_VAR 0 4
12956: PPUSH
12957: CALL_OW 180
// end ; ComEnterUnit ( Bierezov , dep ) ;
12961: LD_EXP 39
12965: PPUSH
12966: LD_VAR 0 4
12970: PPUSH
12971: CALL_OW 120
// has_eng := UnitFilter ( filter , [ f_class , 2 ] ) ;
12975: LD_ADDR_VAR 0 2
12979: PUSH
12980: LD_VAR 0 3
12984: PPUSH
12985: LD_INT 25
12987: PUSH
12988: LD_INT 2
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: PPUSH
12995: CALL_OW 72
12999: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
13000: LD_INT 35
13002: PPUSH
13003: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13007: LD_ADDR_VAR 0 6
13011: PUSH
13012: LD_INT 10
13014: PPUSH
13015: CALL_OW 435
13019: ST_TO_ADDR
// if crates then
13020: LD_VAR 0 6
13024: IFFALSE 13053
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
13026: LD_VAR 0 2
13030: PPUSH
13031: LD_VAR 0 6
13035: PUSH
13036: LD_INT 1
13038: ARRAY
13039: PPUSH
13040: LD_VAR 0 6
13044: PUSH
13045: LD_INT 2
13047: ARRAY
13048: PPUSH
13049: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
13053: LD_VAR 0 4
13057: PPUSH
13058: CALL_OW 274
13062: PPUSH
13063: LD_INT 1
13065: PPUSH
13066: CALL_OW 275
13070: PUSH
13071: LD_INT 40
13073: GREATEREQUAL
13074: IFFALSE 13000
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
13076: LD_ADDR_VAR 0 5
13080: PUSH
13081: LD_INT 4
13083: PUSH
13084: LD_INT 256
13086: PUSH
13087: LD_INT 111
13089: PUSH
13090: LD_INT 2
13092: PUSH
13093: EMPTY
13094: LIST
13095: LIST
13096: LIST
13097: LIST
13098: PUSH
13099: LD_INT 31
13101: PUSH
13102: LD_INT 243
13104: PUSH
13105: LD_INT 112
13107: PUSH
13108: LD_INT 2
13110: PUSH
13111: EMPTY
13112: LIST
13113: LIST
13114: LIST
13115: LIST
13116: PUSH
13117: EMPTY
13118: LIST
13119: LIST
13120: ST_TO_ADDR
// for i in blist do
13121: LD_ADDR_VAR 0 1
13125: PUSH
13126: LD_VAR 0 5
13130: PUSH
13131: FOR_IN
13132: IFFALSE 13181
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
13134: LD_VAR 0 2
13138: PPUSH
13139: LD_VAR 0 1
13143: PUSH
13144: LD_INT 1
13146: ARRAY
13147: PPUSH
13148: LD_VAR 0 1
13152: PUSH
13153: LD_INT 2
13155: ARRAY
13156: PPUSH
13157: LD_VAR 0 1
13161: PUSH
13162: LD_INT 3
13164: ARRAY
13165: PPUSH
13166: LD_VAR 0 1
13170: PUSH
13171: LD_INT 4
13173: ARRAY
13174: PPUSH
13175: CALL_OW 205
13179: GO 13131
13181: POP
13182: POP
// repeat wait ( 0 0$01 ) ;
13183: LD_INT 35
13185: PPUSH
13186: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
13190: LD_INT 22
13192: PUSH
13193: LD_INT 4
13195: PUSH
13196: EMPTY
13197: LIST
13198: LIST
13199: PUSH
13200: LD_INT 30
13202: PUSH
13203: LD_INT 4
13205: PUSH
13206: EMPTY
13207: LIST
13208: LIST
13209: PUSH
13210: LD_INT 3
13212: PUSH
13213: LD_INT 57
13215: PUSH
13216: EMPTY
13217: LIST
13218: PUSH
13219: EMPTY
13220: LIST
13221: LIST
13222: PUSH
13223: EMPTY
13224: LIST
13225: LIST
13226: LIST
13227: PPUSH
13228: CALL_OW 69
13232: IFFALSE 13183
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
13234: LD_VAR 0 3
13238: PUSH
13239: LD_VAR 0 2
13243: DIFF
13244: PPUSH
13245: LD_INT 22
13247: PUSH
13248: LD_INT 4
13250: PUSH
13251: EMPTY
13252: LIST
13253: LIST
13254: PUSH
13255: LD_INT 30
13257: PUSH
13258: LD_INT 4
13260: PUSH
13261: EMPTY
13262: LIST
13263: LIST
13264: PUSH
13265: EMPTY
13266: LIST
13267: LIST
13268: PPUSH
13269: CALL_OW 69
13273: PUSH
13274: LD_INT 1
13276: ARRAY
13277: PPUSH
13278: CALL_OW 180
// repeat wait ( 0 0$01 ) ;
13282: LD_INT 35
13284: PPUSH
13285: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
13289: LD_INT 22
13291: PUSH
13292: LD_INT 4
13294: PUSH
13295: EMPTY
13296: LIST
13297: LIST
13298: PUSH
13299: LD_INT 30
13301: PUSH
13302: LD_INT 31
13304: PUSH
13305: EMPTY
13306: LIST
13307: LIST
13308: PUSH
13309: LD_INT 3
13311: PUSH
13312: LD_INT 57
13314: PUSH
13315: EMPTY
13316: LIST
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PUSH
13322: EMPTY
13323: LIST
13324: LIST
13325: LIST
13326: PPUSH
13327: CALL_OW 69
13331: IFFALSE 13282
// sol := filter diff has_eng ;
13333: LD_ADDR_VAR 0 8
13337: PUSH
13338: LD_VAR 0 3
13342: PUSH
13343: LD_VAR 0 2
13347: DIFF
13348: ST_TO_ADDR
// if GetClass ( sol [ 1 ] ) > 1 then
13349: LD_VAR 0 8
13353: PUSH
13354: LD_INT 1
13356: ARRAY
13357: PPUSH
13358: CALL_OW 257
13362: PUSH
13363: LD_INT 1
13365: GREATER
13366: IFFALSE 13384
// SetClass ( sol [ 1 ] , 1 ) ;
13368: LD_VAR 0 8
13372: PUSH
13373: LD_INT 1
13375: ARRAY
13376: PPUSH
13377: LD_INT 1
13379: PPUSH
13380: CALL_OW 336
// ComExitBuilding ( sol [ 1 ] ) ;
13384: LD_VAR 0 8
13388: PUSH
13389: LD_INT 1
13391: ARRAY
13392: PPUSH
13393: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
13397: LD_VAR 0 8
13401: PUSH
13402: LD_INT 1
13404: ARRAY
13405: PPUSH
13406: LD_INT 22
13408: PUSH
13409: LD_INT 4
13411: PUSH
13412: EMPTY
13413: LIST
13414: LIST
13415: PUSH
13416: LD_INT 30
13418: PUSH
13419: LD_INT 31
13421: PUSH
13422: EMPTY
13423: LIST
13424: LIST
13425: PUSH
13426: EMPTY
13427: LIST
13428: LIST
13429: PPUSH
13430: CALL_OW 69
13434: PUSH
13435: LD_INT 1
13437: ARRAY
13438: PPUSH
13439: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
13443: LD_VAR 0 2
13447: PPUSH
13448: LD_VAR 0 4
13452: PPUSH
13453: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
13457: LD_INT 35
13459: PPUSH
13460: CALL_OW 67
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
13464: LD_ADDR_VAR 0 3
13468: PUSH
13469: LD_INT 22
13471: PUSH
13472: LD_INT 4
13474: PUSH
13475: EMPTY
13476: LIST
13477: LIST
13478: PUSH
13479: LD_INT 21
13481: PUSH
13482: LD_INT 3
13484: PUSH
13485: EMPTY
13486: LIST
13487: LIST
13488: PUSH
13489: LD_INT 3
13491: PUSH
13492: LD_INT 24
13494: PUSH
13495: LD_INT 1000
13497: PUSH
13498: EMPTY
13499: LIST
13500: LIST
13501: PUSH
13502: EMPTY
13503: LIST
13504: LIST
13505: PUSH
13506: EMPTY
13507: LIST
13508: LIST
13509: LIST
13510: PPUSH
13511: CALL_OW 69
13515: ST_TO_ADDR
// if filter and has_eng then
13516: LD_VAR 0 3
13520: PUSH
13521: LD_VAR 0 2
13525: AND
13526: IFFALSE 13592
// begin for i in has_eng do
13528: LD_ADDR_VAR 0 1
13532: PUSH
13533: LD_VAR 0 2
13537: PUSH
13538: FOR_IN
13539: IFFALSE 13588
// begin if IsInUnit ( i ) then
13541: LD_VAR 0 1
13545: PPUSH
13546: CALL_OW 310
13550: IFFALSE 13561
// ComExitBuilding ( i ) ;
13552: LD_VAR 0 1
13556: PPUSH
13557: CALL_OW 122
// Wait ( 3 ) ;
13561: LD_INT 3
13563: PPUSH
13564: CALL_OW 67
// ComRepairBuilding ( i , filter [ 1 ] ) ;
13568: LD_VAR 0 1
13572: PPUSH
13573: LD_VAR 0 3
13577: PUSH
13578: LD_INT 1
13580: ARRAY
13581: PPUSH
13582: CALL_OW 130
// end ;
13586: GO 13538
13588: POP
13589: POP
// end else
13590: GO 13646
// if has_eng and UnitFilter ( has_eng , [ f_outside ] ) then
13592: LD_VAR 0 2
13596: PUSH
13597: LD_VAR 0 2
13601: PPUSH
13602: LD_INT 56
13604: PUSH
13605: EMPTY
13606: LIST
13607: PPUSH
13608: CALL_OW 72
13612: AND
13613: IFFALSE 13646
// for i in has_eng do
13615: LD_ADDR_VAR 0 1
13619: PUSH
13620: LD_VAR 0 2
13624: PUSH
13625: FOR_IN
13626: IFFALSE 13644
// ComEnterUnit ( i , dep ) ;
13628: LD_VAR 0 1
13632: PPUSH
13633: LD_VAR 0 4
13637: PPUSH
13638: CALL_OW 120
13642: GO 13625
13644: POP
13645: POP
// until cornel_prepared ;
13646: LD_EXP 9
13650: IFFALSE 13457
// end ;
13652: PPOPN 8
13654: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
13655: LD_EXP 9
13659: IFFALSE 14008
13661: GO 13663
13663: DISABLE
13664: LD_INT 0
13666: PPUSH
13667: PPUSH
13668: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
13669: LD_ADDR_VAR 0 2
13673: PUSH
13674: LD_INT 22
13676: PUSH
13677: LD_INT 4
13679: PUSH
13680: EMPTY
13681: LIST
13682: LIST
13683: PUSH
13684: LD_INT 30
13686: PUSH
13687: LD_INT 4
13689: PUSH
13690: EMPTY
13691: LIST
13692: LIST
13693: PUSH
13694: EMPTY
13695: LIST
13696: LIST
13697: PPUSH
13698: CALL_OW 69
13702: PUSH
13703: LD_INT 1
13705: ARRAY
13706: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
13707: LD_EXP 4
13711: PPUSH
13712: CALL_OW 122
// Wait ( 0 0$03 ) ;
13716: LD_INT 105
13718: PPUSH
13719: CALL_OW 67
// for i in cornel_units do
13723: LD_ADDR_VAR 0 1
13727: PUSH
13728: LD_EXP 4
13732: PUSH
13733: FOR_IN
13734: IFFALSE 13810
// begin if GetClass ( i ) in [ 2 , 3 ] then
13736: LD_VAR 0 1
13740: PPUSH
13741: CALL_OW 257
13745: PUSH
13746: LD_INT 2
13748: PUSH
13749: LD_INT 3
13751: PUSH
13752: EMPTY
13753: LIST
13754: LIST
13755: IN
13756: IFFALSE 13793
// begin ComEnterUnit ( i , arm ) ;
13758: LD_VAR 0 1
13762: PPUSH
13763: LD_VAR 0 2
13767: PPUSH
13768: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
13772: LD_VAR 0 1
13776: PPUSH
13777: LD_INT 1
13779: PPUSH
13780: CALL_OW 183
// AddComExitBuilding ( i ) ;
13784: LD_VAR 0 1
13788: PPUSH
13789: CALL_OW 182
// end ; AddComMoveXY ( i , 257 , 121 ) ;
13793: LD_VAR 0 1
13797: PPUSH
13798: LD_INT 257
13800: PPUSH
13801: LD_INT 121
13803: PPUSH
13804: CALL_OW 171
// end ;
13808: GO 13733
13810: POP
13811: POP
// Wait ( 1 1$00 ) ;
13812: LD_INT 2100
13814: PPUSH
13815: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
13819: LD_ADDR_VAR 0 3
13823: PUSH
13824: LD_EXP 38
13828: PUSH
13829: LD_EXP 39
13833: ADD
13834: PUSH
13835: LD_EXP 4
13839: ADD
13840: PUSH
13841: LD_EXP 4
13845: PPUSH
13846: LD_INT 21
13848: PUSH
13849: LD_INT 2
13851: PUSH
13852: EMPTY
13853: LIST
13854: LIST
13855: PPUSH
13856: CALL_OW 72
13860: DIFF
13861: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
13862: LD_VAR 0 3
13866: PPUSH
13867: LD_INT 248
13869: PPUSH
13870: LD_INT 85
13872: PPUSH
13873: CALL_OW 111
// AddComHold ( filter ) ;
13877: LD_VAR 0 3
13881: PPUSH
13882: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
13886: LD_INT 35
13888: PPUSH
13889: CALL_OW 67
// until cornel_attack ;
13893: LD_EXP 7
13897: IFFALSE 13886
// ComAgressiveMove ( filter , 209 , 63 ) ;
13899: LD_VAR 0 3
13903: PPUSH
13904: LD_INT 209
13906: PPUSH
13907: LD_INT 63
13909: PPUSH
13910: CALL_OW 114
// if Bierezov then
13914: LD_EXP 39
13918: IFFALSE 14008
// begin filter := filter diff Bierezov ;
13920: LD_ADDR_VAR 0 3
13924: PUSH
13925: LD_VAR 0 3
13929: PUSH
13930: LD_EXP 39
13934: DIFF
13935: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
13936: LD_EXP 39
13940: PPUSH
13941: LD_INT 6
13943: PPUSH
13944: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
13948: LD_EXP 39
13952: PPUSH
13953: LD_INT 235
13955: PPUSH
13956: LD_INT 60
13958: PPUSH
13959: CALL_OW 111
// AddComHold ( Bierezov ) ;
13963: LD_EXP 39
13967: PPUSH
13968: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
13972: LD_EXP 39
13976: PPUSH
13977: LD_INT 350
13979: PPUSH
13980: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
13984: LD_EXP 39
13988: PPUSH
13989: LD_INT 198
13991: PPUSH
13992: LD_INT 28
13994: PPUSH
13995: CALL_OW 171
// AddComHold ( Bierezov ) ;
13999: LD_EXP 39
14003: PPUSH
14004: CALL_OW 200
// end ; end ; end_of_file
14008: PPOPN 3
14010: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
14011: LD_EXP 47
14015: PUSH
14016: LD_EXP 27
14020: NOT
14021: AND
14022: PUSH
14023: LD_EXP 28
14027: NOT
14028: AND
14029: IFFALSE 14479
14031: GO 14033
14033: DISABLE
14034: LD_INT 0
14036: PPUSH
14037: PPUSH
14038: PPUSH
14039: PPUSH
// begin enable ;
14040: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14041: LD_ADDR_VAR 0 4
14045: PUSH
14046: LD_INT 81
14048: PUSH
14049: LD_INT 3
14051: PUSH
14052: EMPTY
14053: LIST
14054: LIST
14055: PPUSH
14056: CALL_OW 69
14060: ST_TO_ADDR
// for i = 1 to ru_patrol do
14061: LD_ADDR_VAR 0 2
14065: PUSH
14066: DOUBLE
14067: LD_INT 1
14069: DEC
14070: ST_TO_ADDR
14071: LD_EXP 47
14075: PUSH
14076: FOR_TO
14077: IFFALSE 14477
// begin un := ru_patrol [ i ] ;
14079: LD_ADDR_VAR 0 1
14083: PUSH
14084: LD_EXP 47
14088: PUSH
14089: LD_VAR 0 2
14093: ARRAY
14094: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14095: LD_VAR 0 1
14099: PPUSH
14100: LD_INT 13
14102: PPUSH
14103: CALL_OW 308
14107: IFFALSE 14212
// begin if not ru_alert then
14109: LD_EXP 54
14113: NOT
14114: IFFALSE 14124
// ru_alert := true ;
14116: LD_ADDR_EXP 54
14120: PUSH
14121: LD_INT 1
14123: ST_TO_ADDR
// if not See ( 1 , un ) then
14124: LD_INT 1
14126: PPUSH
14127: LD_VAR 0 1
14131: PPUSH
14132: CALL_OW 292
14136: NOT
14137: IFFALSE 14151
// SetLives ( un , 1000 ) ;
14139: LD_VAR 0 1
14143: PPUSH
14144: LD_INT 1000
14146: PPUSH
14147: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
14151: LD_ADDR_EXP 47
14155: PUSH
14156: LD_EXP 47
14160: PUSH
14161: LD_VAR 0 1
14165: DIFF
14166: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
14167: LD_VAR 0 1
14171: PPUSH
14172: LD_INT 22
14174: PUSH
14175: LD_INT 3
14177: PUSH
14178: EMPTY
14179: LIST
14180: LIST
14181: PUSH
14182: LD_INT 30
14184: PUSH
14185: LD_INT 4
14187: PUSH
14188: EMPTY
14189: LIST
14190: LIST
14191: PUSH
14192: EMPTY
14193: LIST
14194: LIST
14195: PPUSH
14196: CALL_OW 69
14200: PPUSH
14201: CALL 1001 0 1
14205: PPUSH
14206: CALL_OW 120
// continue ;
14210: GO 14076
// end ; if IsOk ( un ) and not HasTask ( un ) then
14212: LD_VAR 0 1
14216: PPUSH
14217: CALL_OW 302
14221: PUSH
14222: LD_VAR 0 1
14226: PPUSH
14227: CALL_OW 314
14231: NOT
14232: AND
14233: IFFALSE 14326
// begin for j = 1 to ru_firepoints_south [ i ] do
14235: LD_ADDR_VAR 0 3
14239: PUSH
14240: DOUBLE
14241: LD_INT 1
14243: DEC
14244: ST_TO_ADDR
14245: LD_EXP 53
14249: PUSH
14250: LD_VAR 0 2
14254: ARRAY
14255: PUSH
14256: FOR_TO
14257: IFFALSE 14324
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
14259: LD_VAR 0 1
14263: PPUSH
14264: LD_EXP 53
14268: PUSH
14269: LD_VAR 0 2
14273: ARRAY
14274: PUSH
14275: LD_VAR 0 3
14279: ARRAY
14280: PUSH
14281: LD_INT 1
14283: ARRAY
14284: PPUSH
14285: LD_EXP 53
14289: PUSH
14290: LD_VAR 0 2
14294: ARRAY
14295: PUSH
14296: LD_VAR 0 3
14300: ARRAY
14301: PUSH
14302: LD_INT 2
14304: ARRAY
14305: PPUSH
14306: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
14310: LD_VAR 0 1
14314: PPUSH
14315: LD_INT 70
14317: PPUSH
14318: CALL_OW 202
// end ;
14322: GO 14256
14324: POP
14325: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
14326: LD_VAR 0 1
14330: PPUSH
14331: CALL_OW 256
14335: PUSH
14336: LD_INT 700
14338: LESS
14339: PUSH
14340: LD_VAR 0 1
14344: PPUSH
14345: LD_INT 13
14347: PPUSH
14348: CALL_OW 308
14352: NOT
14353: AND
14354: IFFALSE 14406
// begin ComMoveToArea ( un , retreatArea ) ;
14356: LD_VAR 0 1
14360: PPUSH
14361: LD_INT 13
14363: PPUSH
14364: CALL_OW 113
// if not ru_alert_xy then
14368: LD_EXP 55
14372: NOT
14373: IFFALSE 14404
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
14375: LD_ADDR_EXP 55
14379: PUSH
14380: LD_VAR 0 1
14384: PPUSH
14385: CALL_OW 250
14389: PUSH
14390: LD_VAR 0 1
14394: PPUSH
14395: CALL_OW 251
14399: PUSH
14400: EMPTY
14401: LIST
14402: LIST
14403: ST_TO_ADDR
// end else
14404: GO 14475
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
14406: LD_VAR 0 1
14410: PPUSH
14411: LD_VAR 0 4
14415: PPUSH
14416: LD_VAR 0 1
14420: PPUSH
14421: CALL_OW 74
14425: PPUSH
14426: CALL_OW 296
14430: PUSH
14431: LD_INT 9
14433: LESS
14434: PUSH
14435: LD_VAR 0 1
14439: PPUSH
14440: CALL_OW 256
14444: PUSH
14445: LD_INT 500
14447: GREATER
14448: AND
14449: IFFALSE 14475
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
14451: LD_VAR 0 1
14455: PPUSH
14456: LD_VAR 0 4
14460: PPUSH
14461: LD_VAR 0 1
14465: PPUSH
14466: CALL_OW 74
14470: PPUSH
14471: CALL_OW 115
// end ;
14475: GO 14076
14477: POP
14478: POP
// end ;
14479: PPOPN 4
14481: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
14482: LD_EXP 54
14486: PUSH
14487: LD_EXP 55
14491: AND
14492: PUSH
14493: LD_EXP 27
14497: NOT
14498: AND
14499: PUSH
14500: LD_EXP 28
14504: NOT
14505: AND
14506: IFFALSE 14716
14508: GO 14510
14510: DISABLE
14511: LD_INT 0
14513: PPUSH
14514: PPUSH
// begin enable ;
14515: ENABLE
// if not ru_vehicles then
14516: LD_EXP 50
14520: NOT
14521: IFFALSE 14525
// exit ;
14523: GO 14716
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14525: LD_ADDR_VAR 0 2
14529: PUSH
14530: LD_INT 81
14532: PUSH
14533: LD_INT 3
14535: PUSH
14536: EMPTY
14537: LIST
14538: LIST
14539: PPUSH
14540: CALL_OW 69
14544: ST_TO_ADDR
// if ru_vehicles then
14545: LD_EXP 50
14549: IFFALSE 14716
// begin for i in ru_vehicles do
14551: LD_ADDR_VAR 0 1
14555: PUSH
14556: LD_EXP 50
14560: PUSH
14561: FOR_IN
14562: IFFALSE 14714
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
14564: LD_VAR 0 1
14568: PPUSH
14569: CALL_OW 302
14573: PUSH
14574: LD_VAR 0 1
14578: PPUSH
14579: LD_VAR 0 2
14583: PPUSH
14584: LD_VAR 0 1
14588: PPUSH
14589: CALL_OW 74
14593: PPUSH
14594: CALL_OW 296
14598: PUSH
14599: LD_INT 9
14601: LESS
14602: AND
14603: IFFALSE 14629
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
14605: LD_VAR 0 1
14609: PPUSH
14610: LD_VAR 0 2
14614: PPUSH
14615: LD_VAR 0 1
14619: PPUSH
14620: CALL_OW 74
14624: PPUSH
14625: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
14629: LD_VAR 0 1
14633: PPUSH
14634: CALL_OW 314
14638: NOT
14639: PUSH
14640: LD_VAR 0 1
14644: PPUSH
14645: CALL_OW 302
14649: AND
14650: PUSH
14651: LD_VAR 0 1
14655: PPUSH
14656: LD_EXP 55
14660: PUSH
14661: LD_INT 1
14663: ARRAY
14664: PPUSH
14665: LD_EXP 55
14669: PUSH
14670: LD_INT 2
14672: ARRAY
14673: PPUSH
14674: CALL_OW 297
14678: PUSH
14679: LD_INT 10
14681: GREATER
14682: AND
14683: IFFALSE 14712
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
14685: LD_VAR 0 1
14689: PPUSH
14690: LD_EXP 55
14694: PUSH
14695: LD_INT 1
14697: ARRAY
14698: PPUSH
14699: LD_EXP 55
14703: PUSH
14704: LD_INT 2
14706: ARRAY
14707: PPUSH
14708: CALL_OW 114
// end ;
14712: GO 14561
14714: POP
14715: POP
// end ; end ;
14716: PPOPN 2
14718: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
14719: LD_EXP 55
14723: PUSH
14724: LD_EXP 54
14728: AND
14729: PUSH
14730: LD_INT 3
14732: PPUSH
14733: CALL_OW 463
14737: NOT
14738: AND
14739: PUSH
14740: LD_EXP 27
14744: NOT
14745: AND
14746: PUSH
14747: LD_EXP 28
14751: NOT
14752: AND
14753: IFFALSE 14848
14755: GO 14757
14757: DISABLE
14758: LD_INT 0
14760: PPUSH
// begin enable ;
14761: ENABLE
// ru_alert_xy := false ;
14762: LD_ADDR_EXP 55
14766: PUSH
14767: LD_INT 0
14769: ST_TO_ADDR
// ru_alert := false ;
14770: LD_ADDR_EXP 54
14774: PUSH
14775: LD_INT 0
14777: ST_TO_ADDR
// if ru_vehicles then
14778: LD_EXP 50
14782: IFFALSE 14848
// for i in ru_vehicles do
14784: LD_ADDR_VAR 0 1
14788: PUSH
14789: LD_EXP 50
14793: PUSH
14794: FOR_IN
14795: IFFALSE 14846
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
14797: LD_VAR 0 1
14801: PPUSH
14802: CALL_OW 302
14806: PUSH
14807: LD_VAR 0 1
14811: PPUSH
14812: LD_INT 89
14814: PPUSH
14815: LD_INT 36
14817: PPUSH
14818: CALL_OW 297
14822: PUSH
14823: LD_INT 10
14825: GREATER
14826: AND
14827: IFFALSE 14844
// ComMoveXY ( i , 89 , 36 ) ;
14829: LD_VAR 0 1
14833: PPUSH
14834: LD_INT 89
14836: PPUSH
14837: LD_INT 36
14839: PPUSH
14840: CALL_OW 111
14844: GO 14794
14846: POP
14847: POP
// end ;
14848: PPOPN 1
14850: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
14851: LD_EXP 49
14855: PUSH
14856: LD_EXP 27
14860: NOT
14861: AND
14862: PUSH
14863: LD_EXP 28
14867: NOT
14868: AND
14869: IFFALSE 15153
14871: GO 14873
14873: DISABLE
14874: LD_INT 0
14876: PPUSH
14877: PPUSH
14878: PPUSH
// begin enable ;
14879: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14880: LD_ADDR_VAR 0 3
14884: PUSH
14885: LD_INT 81
14887: PUSH
14888: LD_INT 3
14890: PUSH
14891: EMPTY
14892: LIST
14893: LIST
14894: PPUSH
14895: CALL_OW 69
14899: ST_TO_ADDR
// for i = 1 to ru_forest do
14900: LD_ADDR_VAR 0 1
14904: PUSH
14905: DOUBLE
14906: LD_INT 1
14908: DEC
14909: ST_TO_ADDR
14910: LD_EXP 49
14914: PUSH
14915: FOR_TO
14916: IFFALSE 15151
// begin un := ru_forest [ i ] ;
14918: LD_ADDR_VAR 0 2
14922: PUSH
14923: LD_EXP 49
14927: PUSH
14928: LD_VAR 0 1
14932: ARRAY
14933: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14934: LD_VAR 0 2
14938: PPUSH
14939: LD_INT 13
14941: PPUSH
14942: CALL_OW 308
14946: IFFALSE 15036
// begin if not See ( 1 , un ) then
14948: LD_INT 1
14950: PPUSH
14951: LD_VAR 0 2
14955: PPUSH
14956: CALL_OW 292
14960: NOT
14961: IFFALSE 14975
// SetLives ( un , 1000 ) ;
14963: LD_VAR 0 2
14967: PPUSH
14968: LD_INT 1000
14970: PPUSH
14971: CALL_OW 234
// ru_forest := ru_forest diff un ;
14975: LD_ADDR_EXP 49
14979: PUSH
14980: LD_EXP 49
14984: PUSH
14985: LD_VAR 0 2
14989: DIFF
14990: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
14991: LD_VAR 0 2
14995: PPUSH
14996: LD_INT 22
14998: PUSH
14999: LD_INT 3
15001: PUSH
15002: EMPTY
15003: LIST
15004: LIST
15005: PUSH
15006: LD_INT 30
15008: PUSH
15009: LD_INT 4
15011: PUSH
15012: EMPTY
15013: LIST
15014: LIST
15015: PUSH
15016: EMPTY
15017: LIST
15018: LIST
15019: PPUSH
15020: CALL_OW 69
15024: PPUSH
15025: CALL 1001 0 1
15029: PPUSH
15030: CALL_OW 120
// continue ;
15034: GO 14915
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
15036: LD_VAR 0 2
15040: PPUSH
15041: CALL_OW 256
15045: PUSH
15046: LD_INT 700
15048: LESS
15049: PUSH
15050: LD_VAR 0 2
15054: PPUSH
15055: LD_INT 13
15057: PPUSH
15058: CALL_OW 308
15062: NOT
15063: AND
15064: IFFALSE 15080
// ComMoveToArea ( un , retreatArea ) else
15066: LD_VAR 0 2
15070: PPUSH
15071: LD_INT 13
15073: PPUSH
15074: CALL_OW 113
15078: GO 15149
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
15080: LD_VAR 0 2
15084: PPUSH
15085: LD_VAR 0 3
15089: PPUSH
15090: LD_VAR 0 2
15094: PPUSH
15095: CALL_OW 74
15099: PPUSH
15100: CALL_OW 296
15104: PUSH
15105: LD_INT 9
15107: LESS
15108: PUSH
15109: LD_VAR 0 2
15113: PPUSH
15114: CALL_OW 256
15118: PUSH
15119: LD_INT 500
15121: GREATER
15122: AND
15123: IFFALSE 15149
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
15125: LD_VAR 0 2
15129: PPUSH
15130: LD_VAR 0 3
15134: PPUSH
15135: LD_VAR 0 2
15139: PPUSH
15140: CALL_OW 74
15144: PPUSH
15145: CALL_OW 115
// end ;
15149: GO 14915
15151: POP
15152: POP
// end ;
15153: PPOPN 3
15155: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
15156: LD_EXP 28
15160: NOT
15161: IFFALSE 15282
15163: GO 15165
15165: DISABLE
15166: LD_INT 0
15168: PPUSH
15169: PPUSH
// begin enable ;
15170: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
15171: LD_ADDR_VAR 0 2
15175: PUSH
15176: LD_INT 22
15178: PUSH
15179: LD_INT 3
15181: PUSH
15182: EMPTY
15183: LIST
15184: LIST
15185: PUSH
15186: LD_INT 21
15188: PUSH
15189: LD_INT 3
15191: PUSH
15192: EMPTY
15193: LIST
15194: LIST
15195: PUSH
15196: EMPTY
15197: LIST
15198: LIST
15199: PPUSH
15200: CALL_OW 69
15204: ST_TO_ADDR
// if filter then
15205: LD_VAR 0 2
15209: IFFALSE 15282
// for i in filter do
15211: LD_ADDR_VAR 0 1
15215: PUSH
15216: LD_VAR 0 2
15220: PUSH
15221: FOR_IN
15222: IFFALSE 15280
// if GetLives ( i ) < 990 then
15224: LD_VAR 0 1
15228: PPUSH
15229: CALL_OW 256
15233: PUSH
15234: LD_INT 990
15236: LESS
15237: IFFALSE 15278
// begin ru_alert := true ;
15239: LD_ADDR_EXP 54
15243: PUSH
15244: LD_INT 1
15246: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
15247: LD_ADDR_EXP 55
15251: PUSH
15252: LD_VAR 0 1
15256: PPUSH
15257: CALL_OW 250
15261: PUSH
15262: LD_VAR 0 1
15266: PPUSH
15267: CALL_OW 251
15271: PUSH
15272: EMPTY
15273: LIST
15274: LIST
15275: ST_TO_ADDR
// break ;
15276: GO 15280
// end ;
15278: GO 15221
15280: POP
15281: POP
// end ;
15282: PPOPN 2
15284: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
15285: LD_EXP 27
15289: IFFALSE 15438
15291: GO 15293
15293: DISABLE
15294: LD_INT 0
15296: PPUSH
15297: PPUSH
15298: PPUSH
15299: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
15300: LD_ADDR_VAR 0 4
15304: PUSH
15305: LD_EXP 50
15309: PUSH
15310: LD_EXP 49
15314: ADD
15315: PUSH
15316: LD_EXP 47
15320: ADD
15321: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
15322: LD_ADDR_VAR 0 3
15326: PUSH
15327: LD_INT 3
15329: PPUSH
15330: LD_INT 81
15332: PUSH
15333: LD_INT 3
15335: PUSH
15336: EMPTY
15337: LIST
15338: LIST
15339: PPUSH
15340: CALL_OW 70
15344: ST_TO_ADDR
// if filter and enemy then
15345: LD_VAR 0 4
15349: PUSH
15350: LD_VAR 0 3
15354: AND
15355: IFFALSE 15438
// repeat wait ( 0 0$01 ) ;
15357: LD_INT 35
15359: PPUSH
15360: CALL_OW 67
// for i in filter do
15364: LD_ADDR_VAR 0 1
15368: PUSH
15369: LD_VAR 0 4
15373: PUSH
15374: FOR_IN
15375: IFFALSE 15403
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15377: LD_VAR 0 1
15381: PPUSH
15382: LD_VAR 0 3
15386: PPUSH
15387: LD_VAR 0 1
15391: PPUSH
15392: CALL_OW 74
15396: PPUSH
15397: CALL_OW 115
// end ;
15401: GO 15374
15403: POP
15404: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 or filter = 0 ;
15405: LD_INT 3
15407: PPUSH
15408: LD_INT 81
15410: PUSH
15411: LD_INT 3
15413: PUSH
15414: EMPTY
15415: LIST
15416: LIST
15417: PPUSH
15418: CALL_OW 70
15422: PUSH
15423: LD_INT 0
15425: EQUAL
15426: PUSH
15427: LD_VAR 0 4
15431: PUSH
15432: LD_INT 0
15434: EQUAL
15435: OR
15436: IFFALSE 15357
// end ;
15438: PPOPN 4
15440: END
// every 0 0$03 trigger send_attack_on_cornel_base do var i ;
15441: LD_EXP 23
15445: IFFALSE 15494
15447: GO 15449
15449: DISABLE
15450: LD_INT 0
15452: PPUSH
// begin if not ru_cornel_attack then
15453: LD_EXP 52
15457: NOT
15458: IFFALSE 15462
// exit ;
15460: GO 15494
// for i in ru_cornel_attack do
15462: LD_ADDR_VAR 0 1
15466: PUSH
15467: LD_EXP 52
15471: PUSH
15472: FOR_IN
15473: IFFALSE 15492
// ComAgressiveMove ( i , 258 , 119 ) ;
15475: LD_VAR 0 1
15479: PPUSH
15480: LD_INT 258
15482: PPUSH
15483: LD_INT 119
15485: PPUSH
15486: CALL_OW 114
15490: GO 15472
15492: POP
15493: POP
// end ; end_of_file
15494: PPOPN 1
15496: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
15497: LD_EXP 3
15501: PUSH
15502: LD_EXP 7
15506: NOT
15507: AND
15508: PUSH
15509: LD_EXP 17
15513: AND
15514: IFFALSE 15626
15516: GO 15518
15518: DISABLE
15519: LD_INT 0
15521: PPUSH
// begin enable ;
15522: ENABLE
// crates_counter := crates_counter - 50 ;
15523: LD_ADDR_EXP 17
15527: PUSH
15528: LD_EXP 17
15532: PUSH
15533: LD_INT 50
15535: MINUS
15536: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
15537: LD_INT 8
15539: PPUSH
15540: LD_INT 2
15542: PPUSH
15543: LD_INT 5
15545: PPUSH
15546: CALL_OW 12
15550: PPUSH
15551: LD_INT 1
15553: PPUSH
15554: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
15558: LD_INT 1785
15560: PPUSH
15561: LD_INT 2345
15563: PPUSH
15564: CALL_OW 12
15568: PPUSH
15569: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
15573: LD_ADDR_VAR 0 1
15577: PUSH
15578: LD_INT 1
15580: PPUSH
15581: LD_OWVAR 67
15585: PUSH
15586: LD_INT 2
15588: PLUS
15589: PPUSH
15590: CALL_OW 12
15594: ST_TO_ADDR
// if r < 3 then
15595: LD_VAR 0 1
15599: PUSH
15600: LD_INT 3
15602: LESS
15603: IFFALSE 15626
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
15605: LD_INT 4
15607: PPUSH
15608: LD_INT 1
15610: PPUSH
15611: LD_INT 5
15613: PPUSH
15614: CALL_OW 12
15618: PPUSH
15619: LD_INT 1
15621: PPUSH
15622: CALL_OW 55
// end ;
15626: PPOPN 1
15628: END
// every 0 0$01 trigger cornel_active do
15629: LD_EXP 6
15633: IFFALSE 15722
15635: GO 15637
15637: DISABLE
// begin Wait ( 0 0$03 ) ;
15638: LD_INT 105
15640: PPUSH
15641: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15645: LD_INT 2
15647: PPUSH
15648: LD_INT 5
15650: PPUSH
15651: CALL_OW 12
15655: PPUSH
15656: LD_INT 10
15658: PPUSH
15659: LD_INT 1
15661: PPUSH
15662: CALL_OW 55
// Wait ( 0 0$13 ) ;
15666: LD_INT 455
15668: PPUSH
15669: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15673: LD_INT 2
15675: PPUSH
15676: LD_INT 5
15678: PPUSH
15679: CALL_OW 12
15683: PPUSH
15684: LD_INT 10
15686: PPUSH
15687: LD_INT 1
15689: PPUSH
15690: CALL_OW 55
// Wait ( 0 0$16 ) ;
15694: LD_INT 560
15696: PPUSH
15697: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15701: LD_INT 2
15703: PPUSH
15704: LD_INT 5
15706: PPUSH
15707: CALL_OW 12
15711: PPUSH
15712: LD_INT 10
15714: PPUSH
15715: LD_INT 1
15717: PPUSH
15718: CALL_OW 55
// end ; end_of_file
15722: END
// every 0 0$01 trigger cornel_prepared do
15723: LD_EXP 9
15727: IFFALSE 15786
15729: GO 15731
15731: DISABLE
// begin enable ;
15732: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
15733: LD_ADDR_OWVAR 47
15737: PUSH
15738: LD_STRING #Am03-1
15740: PUSH
15741: LD_EXP 8
15745: PUSH
15746: EMPTY
15747: LIST
15748: LIST
15749: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
15750: LD_ADDR_EXP 8
15754: PUSH
15755: LD_EXP 8
15759: PPUSH
15760: LD_STRING -
15762: PPUSH
15763: CALL 1071 0 2
15767: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
15768: LD_EXP 8
15772: PUSH
15773: LD_INT 0
15775: EQUAL
15776: IFFALSE 15786
// begin Display_Strings := [ ] ;
15778: LD_ADDR_OWVAR 47
15782: PUSH
15783: EMPTY
15784: ST_TO_ADDR
// disable ;
15785: DISABLE
// end ; end ;
15786: END
// every 0 0$01 trigger debug and debug_strings do
15787: LD_EXP 1
15791: PUSH
15792: LD_OWVAR 48
15796: AND
15797: IFFALSE 15813
15799: GO 15801
15801: DISABLE
// begin enable ;
15802: ENABLE
// Display_Strings := debug_strings ;
15803: LD_ADDR_OWVAR 47
15807: PUSH
15808: LD_OWVAR 48
15812: ST_TO_ADDR
// end ; end_of_file
15813: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
15814: LD_VAR 0 1
15818: PPUSH
15819: CALL_OW 255
15823: PUSH
15824: LD_INT 1
15826: EQUAL
15827: PUSH
15828: LD_EXP 11
15832: NOT
15833: AND
15834: IFFALSE 15844
// solar_builded := true ;
15836: LD_ADDR_EXP 11
15840: PUSH
15841: LD_INT 1
15843: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
15844: LD_VAR 0 1
15848: PPUSH
15849: CALL_OW 255
15853: PUSH
15854: LD_INT 1
15856: EQUAL
15857: PUSH
15858: LD_EXP 25
15862: AND
15863: IFFALSE 15896
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
15865: LD_ADDR_EXP 25
15869: PUSH
15870: LD_EXP 25
15874: PUSH
15875: LD_INT 1750
15877: PUSH
15878: LD_INT 1400
15880: PUSH
15881: LD_INT 1225
15883: PUSH
15884: EMPTY
15885: LIST
15886: LIST
15887: LIST
15888: PUSH
15889: LD_OWVAR 67
15893: ARRAY
15894: PLUS
15895: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
15896: LD_VAR 0 1
15900: PPUSH
15901: CALL_OW 255
15905: PUSH
15906: LD_INT 3
15908: EQUAL
15909: IFFALSE 15927
// ru_vehicles := ru_vehicles ^ veh ;
15911: LD_ADDR_EXP 50
15915: PUSH
15916: LD_EXP 50
15920: PUSH
15921: LD_VAR 0 1
15925: ADD
15926: ST_TO_ADDR
// end ;
15927: PPOPN 2
15929: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
15930: LD_VAR 0 1
15934: PUSH
15935: LD_EXP 47
15939: IN
15940: IFFALSE 15958
// ru_patrol := ru_patrol diff un ;
15942: LD_ADDR_EXP 47
15946: PUSH
15947: LD_EXP 47
15951: PUSH
15952: LD_VAR 0 1
15956: DIFF
15957: ST_TO_ADDR
// if un in ru_forest then
15958: LD_VAR 0 1
15962: PUSH
15963: LD_EXP 49
15967: IN
15968: IFFALSE 15986
// ru_forest := ru_forest diff un ;
15970: LD_ADDR_EXP 49
15974: PUSH
15975: LD_EXP 49
15979: PUSH
15980: LD_VAR 0 1
15984: DIFF
15985: ST_TO_ADDR
// if un in ru_vehicles then
15986: LD_VAR 0 1
15990: PUSH
15991: LD_EXP 50
15995: IN
15996: IFFALSE 16071
// begin ru_vehicles := ru_vehicles diff un ;
15998: LD_ADDR_EXP 50
16002: PUSH
16003: LD_EXP 50
16007: PUSH
16008: LD_VAR 0 1
16012: DIFF
16013: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
16014: LD_ADDR_EXP 51
16018: PUSH
16019: LD_EXP 51
16023: PUSH
16024: LD_VAR 0 1
16028: PPUSH
16029: CALL_OW 265
16033: PUSH
16034: LD_VAR 0 1
16038: PPUSH
16039: CALL_OW 262
16043: PUSH
16044: LD_VAR 0 1
16048: PPUSH
16049: CALL_OW 263
16053: PUSH
16054: LD_VAR 0 1
16058: PPUSH
16059: CALL_OW 264
16063: PUSH
16064: EMPTY
16065: LIST
16066: LIST
16067: LIST
16068: LIST
16069: ADD
16070: ST_TO_ADDR
// end ; if un = JMM then
16071: LD_VAR 0 1
16075: PUSH
16076: LD_EXP 31
16080: EQUAL
16081: IFFALSE 16090
// YouLost ( 0 ) ;
16083: LD_STRING 0
16085: PPUSH
16086: CALL_OW 104
// if un = us_dep_west then
16090: LD_VAR 0 1
16094: PUSH
16095: LD_INT 1
16097: EQUAL
16098: IFFALSE 16107
// YouLost ( 2 ) ;
16100: LD_STRING 2
16102: PPUSH
16103: CALL_OW 104
// if un = Lynch and GetSide ( Lynch ) = 8 then
16107: LD_VAR 0 1
16111: PUSH
16112: LD_EXP 41
16116: EQUAL
16117: PUSH
16118: LD_EXP 41
16122: PPUSH
16123: CALL_OW 255
16127: PUSH
16128: LD_INT 8
16130: EQUAL
16131: AND
16132: IFFALSE 16141
// YouLost ( 4 ) ;
16134: LD_STRING 4
16136: PPUSH
16137: CALL_OW 104
// if un in jmm_units then
16141: LD_VAR 0 1
16145: PUSH
16146: LD_EXP 2
16150: IN
16151: IFFALSE 16167
// lose_counter := lose_counter + 1 ;
16153: LD_ADDR_EXP 30
16157: PUSH
16158: LD_EXP 30
16162: PUSH
16163: LD_INT 1
16165: PLUS
16166: ST_TO_ADDR
// end ;
16167: PPOPN 1
16169: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
16170: LD_INT 0
16172: PPUSH
16173: PPUSH
// begin if GetSide ( driver ) = 3 then
16174: LD_VAR 0 1
16178: PPUSH
16179: CALL_OW 255
16183: PUSH
16184: LD_INT 3
16186: EQUAL
16187: IFFALSE 16265
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
16189: LD_ADDR_VAR 0 6
16193: PUSH
16194: LD_INT 22
16196: PUSH
16197: LD_INT 3
16199: PUSH
16200: EMPTY
16201: LIST
16202: LIST
16203: PUSH
16204: LD_INT 30
16206: PUSH
16207: LD_INT 3
16209: PUSH
16210: EMPTY
16211: LIST
16212: LIST
16213: PUSH
16214: EMPTY
16215: LIST
16216: LIST
16217: PPUSH
16218: CALL_OW 69
16222: PPUSH
16223: CALL 1001 0 1
16227: ST_TO_ADDR
// if place then
16228: LD_VAR 0 6
16232: IFFALSE 16250
// ComEnterUnit ( driver , place ) else
16234: LD_VAR 0 1
16238: PPUSH
16239: LD_VAR 0 6
16243: PPUSH
16244: CALL_OW 120
16248: GO 16265
// ComMoveXY ( driver , 70 , 22 ) ;
16250: LD_VAR 0 1
16254: PPUSH
16255: LD_INT 70
16257: PPUSH
16258: LD_INT 22
16260: PPUSH
16261: CALL_OW 111
// end ; end ;
16265: PPOPN 6
16267: END
// every 0 0$01 trigger not game_end and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) < 4 do
16268: LD_EXP 29
16272: NOT
16273: PUSH
16274: LD_INT 22
16276: PUSH
16277: LD_INT 1
16279: PUSH
16280: EMPTY
16281: LIST
16282: LIST
16283: PUSH
16284: LD_INT 21
16286: PUSH
16287: LD_INT 1
16289: PUSH
16290: EMPTY
16291: LIST
16292: LIST
16293: PUSH
16294: EMPTY
16295: LIST
16296: LIST
16297: PPUSH
16298: CALL_OW 69
16302: PUSH
16303: LD_INT 22
16305: PUSH
16306: LD_INT 8
16308: PUSH
16309: EMPTY
16310: LIST
16311: LIST
16312: PUSH
16313: LD_INT 21
16315: PUSH
16316: LD_INT 1
16318: PUSH
16319: EMPTY
16320: LIST
16321: LIST
16322: PUSH
16323: EMPTY
16324: LIST
16325: LIST
16326: PPUSH
16327: CALL_OW 69
16331: PLUS
16332: PUSH
16333: LD_INT 4
16335: LESS
16336: AND
16337: IFFALSE 16349
16339: GO 16341
16341: DISABLE
// YouLost ( 1 ) ;
16342: LD_STRING 1
16344: PPUSH
16345: CALL_OW 104
16349: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
16350: LD_INT 1
16352: PPUSH
16353: CALL_OW 255
16357: PUSH
16358: LD_INT 3
16360: EQUAL
16361: IFFALSE 16373
16363: GO 16365
16365: DISABLE
// YouLost ( 3 ) ;
16366: LD_STRING 3
16368: PPUSH
16369: CALL_OW 104
16373: END
