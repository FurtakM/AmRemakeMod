// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 323 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 411 0 0
// PrepareRussian ;
  22: CALL 2923 0 0
// PrepareAmerican ;
  26: CALL 1164 0 0
// PrepareCornell ;
  30: CALL 2188 0 0
// PrepareWesternBase ;
  34: CALL 2414 0 0
// Action ;
  38: CALL 4929 0 0
// end ;
  42: END
// export debug ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , send_attack_on_cornel_base , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// jmm_units := 0 ;
  54: LD_ADDR_EXP 2
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// cornel_units := 0 ;
  62: LD_ADDR_EXP 4
  66: PUSH
  67: LD_INT 0
  69: ST_TO_ADDR
// bierezov_exist := false ;
  70: LD_ADDR_EXP 5
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// jmm_on_west := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// cornel_active := false ;
  86: LD_ADDR_EXP 6
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// cornel_attack := false ;
  94: LD_ADDR_EXP 7
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_prepared := false ;
 102: LD_ADDR_EXP 9
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 110: LD_ADDR_EXP 8
 114: PUSH
 115: LD_INT 4200
 117: ST_TO_ADDR
// frank_can_return := false ;
 118: LD_ADDR_EXP 10
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// solar_builded := false ;
 126: LD_ADDR_EXP 11
 130: PUSH
 131: LD_INT 0
 133: ST_TO_ADDR
// frank_send_to_scout := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// jmm_in_veh := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// bobby_in_veh := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// cyrus_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// lisa_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 174: LD_ADDR_EXP 25
 178: PUSH
 179: LD_INT 25200
 181: PUSH
 182: LD_INT 23100
 184: PUSH
 185: LD_INT 21000
 187: PUSH
 188: EMPTY
 189: LIST
 190: LIST
 191: LIST
 192: PUSH
 193: LD_OWVAR 67
 197: ARRAY
 198: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 199: LD_ADDR_EXP 17
 203: PUSH
 204: LD_INT 600
 206: PUSH
 207: LD_INT 500
 209: PUSH
 210: LD_INT 400
 212: PUSH
 213: EMPTY
 214: LIST
 215: LIST
 216: LIST
 217: PUSH
 218: LD_OWVAR 67
 222: ARRAY
 223: ST_TO_ADDR
// end_mission_allowed := false ;
 224: LD_ADDR_EXP 18
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// save_others := [ ] ;
 232: LD_ADDR_EXP 19
 236: PUSH
 237: EMPTY
 238: ST_TO_ADDR
// save_group := [ ] ;
 239: LD_ADDR_EXP 20
 243: PUSH
 244: EMPTY
 245: ST_TO_ADDR
// show_query := true ;
 246: LD_ADDR_EXP 21
 250: PUSH
 251: LD_INT 1
 253: ST_TO_ADDR
// wait_for_them := false ;
 254: LD_ADDR_EXP 22
 258: PUSH
 259: LD_INT 0
 261: ST_TO_ADDR
// veh_on_meta := false ;
 262: LD_ADDR_EXP 24
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// send_spec_patrol := false ;
 270: LD_ADDR_EXP 26
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// prepare_siege := false ;
 278: LD_ADDR_EXP 27
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_attack_on_cornel := false ;
 286: LD_ADDR_EXP 28
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// send_attack_on_cornel_base := false ;
 294: LD_ADDR_EXP 23
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// game_end := false ;
 302: LD_ADDR_EXP 29
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// lose_counter := 0 ;
 310: LD_ADDR_EXP 30
 314: PUSH
 315: LD_INT 0
 317: ST_TO_ADDR
// end ;
 318: LD_VAR 0 1
 322: RET
// function SetDiplomacy ; begin
 323: LD_INT 0
 325: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 326: LD_INT 1
 328: PPUSH
 329: LD_INT 4
 331: PPUSH
 332: LD_INT 1
 334: PPUSH
 335: LD_INT 1
 337: PPUSH
 338: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 342: LD_INT 1
 344: PPUSH
 345: LD_INT 8
 347: PPUSH
 348: LD_INT 1
 350: PPUSH
 351: LD_INT 1
 353: PPUSH
 354: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 358: LD_INT 3
 360: PPUSH
 361: LD_INT 6
 363: PPUSH
 364: LD_INT 1
 366: PPUSH
 367: LD_INT 1
 369: PPUSH
 370: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 374: LD_INT 4
 376: PPUSH
 377: LD_INT 6
 379: PPUSH
 380: LD_INT 0
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 390: LD_INT 3
 392: PPUSH
 393: LD_INT 8
 395: PPUSH
 396: LD_INT 0
 398: PPUSH
 399: LD_INT 1
 401: PPUSH
 402: CALL_OW 80
// end ;
 406: LD_VAR 0 1
 410: RET
// export function DebugMode ; var i ; begin
 411: LD_INT 0
 413: PPUSH
 414: PPUSH
// FogOff ( 1 ) ;
 415: LD_INT 1
 417: PPUSH
 418: CALL_OW 344
// debug_strings := [ ] ;
 422: LD_ADDR_OWVAR 48
 426: PUSH
 427: EMPTY
 428: ST_TO_ADDR
// end ; end_of_file
 429: LD_VAR 0 1
 433: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 434: LD_INT 0
 436: PPUSH
 437: PPUSH
// if exist_mode then
 438: LD_VAR 0 2
 442: IFFALSE 461
// unit := CreateCharacter ( ident ) else
 444: LD_ADDR_VAR 0 4
 448: PUSH
 449: LD_VAR 0 1
 453: PPUSH
 454: CALL_OW 34
 458: ST_TO_ADDR
 459: GO 476
// unit := NewCharacter ( ident ) ;
 461: LD_ADDR_VAR 0 4
 465: PUSH
 466: LD_VAR 0 1
 470: PPUSH
 471: CALL_OW 25
 475: ST_TO_ADDR
// result := unit ;
 476: LD_ADDR_VAR 0 3
 480: PUSH
 481: LD_VAR 0 4
 485: ST_TO_ADDR
// end ;
 486: LD_VAR 0 3
 490: RET
// export function KickCharacter ( ident ) ; begin
 491: LD_INT 0
 493: PPUSH
// DeleteCharacters ( " & ident & " ) ;
 494: LD_STRING "
 496: PUSH
 497: LD_VAR 0 1
 501: STR
 502: PUSH
 503: LD_STRING "
 505: STR
 506: PPUSH
 507: CALL_OW 40
// end ;
 511: LD_VAR 0 2
 515: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 516: LD_INT 0
 518: PPUSH
// uc_side := side ;
 519: LD_ADDR_OWVAR 20
 523: PUSH
 524: LD_VAR 0 1
 528: ST_TO_ADDR
// uc_nation := nation ;
 529: LD_ADDR_OWVAR 21
 533: PUSH
 534: LD_VAR 0 2
 538: ST_TO_ADDR
// vc_chassis := chassis ;
 539: LD_ADDR_OWVAR 37
 543: PUSH
 544: LD_VAR 0 3
 548: ST_TO_ADDR
// vc_engine := engine ;
 549: LD_ADDR_OWVAR 39
 553: PUSH
 554: LD_VAR 0 4
 558: ST_TO_ADDR
// vc_control := control ;
 559: LD_ADDR_OWVAR 38
 563: PUSH
 564: LD_VAR 0 5
 568: ST_TO_ADDR
// vc_weapon := weapon ;
 569: LD_ADDR_OWVAR 40
 573: PUSH
 574: LD_VAR 0 6
 578: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 579: LD_ADDR_OWVAR 41
 583: PUSH
 584: LD_VAR 0 7
 588: ST_TO_ADDR
// result := CreateVehicle ;
 589: LD_ADDR_VAR 0 8
 593: PUSH
 594: CALL_OW 45
 598: ST_TO_ADDR
// end ;
 599: LD_VAR 0 8
 603: RET
// export function SayX ( units , ident ) ; var i ; begin
 604: LD_INT 0
 606: PPUSH
 607: PPUSH
// result := false ;
 608: LD_ADDR_VAR 0 3
 612: PUSH
 613: LD_INT 0
 615: ST_TO_ADDR
// if not units then
 616: LD_VAR 0 1
 620: NOT
 621: IFFALSE 625
// exit ;
 623: GO 679
// for i in units do
 625: LD_ADDR_VAR 0 4
 629: PUSH
 630: LD_VAR 0 1
 634: PUSH
 635: FOR_IN
 636: IFFALSE 677
// if IsOk ( i ) then
 638: LD_VAR 0 4
 642: PPUSH
 643: CALL_OW 302
 647: IFFALSE 675
// begin Say ( i , ident ) ;
 649: LD_VAR 0 4
 653: PPUSH
 654: LD_VAR 0 2
 658: PPUSH
 659: CALL_OW 88
// result := i ;
 663: LD_ADDR_VAR 0 3
 667: PUSH
 668: LD_VAR 0 4
 672: ST_TO_ADDR
// break ;
 673: GO 677
// end ;
 675: GO 635
 677: POP
 678: POP
// end ;
 679: LD_VAR 0 3
 683: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 684: LD_INT 0
 686: PPUSH
 687: PPUSH
 688: PPUSH
 689: PPUSH
// for i = 1 to count do
 690: LD_ADDR_VAR 0 8
 694: PUSH
 695: DOUBLE
 696: LD_INT 1
 698: DEC
 699: ST_TO_ADDR
 700: LD_VAR 0 6
 704: PUSH
 705: FOR_TO
 706: IFFALSE 787
// begin uc_side = side ;
 708: LD_ADDR_OWVAR 20
 712: PUSH
 713: LD_VAR 0 1
 717: ST_TO_ADDR
// uc_nation = nation ;
 718: LD_ADDR_OWVAR 21
 722: PUSH
 723: LD_VAR 0 2
 727: ST_TO_ADDR
// hc_gallery =  ;
 728: LD_ADDR_OWVAR 33
 732: PUSH
 733: LD_STRING 
 735: ST_TO_ADDR
// hc_name =  ;
 736: LD_ADDR_OWVAR 26
 740: PUSH
 741: LD_STRING 
 743: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 744: LD_INT 0
 746: PPUSH
 747: LD_VAR 0 5
 751: PPUSH
 752: LD_VAR 0 4
 756: PPUSH
 757: CALL_OW 380
// un = CreateHuman ;
 761: LD_ADDR_VAR 0 10
 765: PUSH
 766: CALL_OW 44
 770: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 771: LD_VAR 0 10
 775: PPUSH
 776: LD_VAR 0 3
 780: PPUSH
 781: CALL_OW 52
// end ;
 785: GO 705
 787: POP
 788: POP
// end ;
 789: LD_VAR 0 7
 793: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 794: LD_INT 0
 796: PPUSH
 797: PPUSH
 798: PPUSH
// uc_side := GetSide ( b ) ;
 799: LD_ADDR_OWVAR 20
 803: PUSH
 804: LD_VAR 0 2
 808: PPUSH
 809: CALL_OW 255
 813: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 814: LD_ADDR_OWVAR 21
 818: PUSH
 819: LD_VAR 0 2
 823: PPUSH
 824: CALL_OW 248
 828: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 829: LD_INT 0
 831: PPUSH
 832: LD_INT 1
 834: PPUSH
 835: LD_VAR 0 1
 839: PPUSH
 840: CALL_OW 380
// un = CreateHuman ;
 844: LD_ADDR_VAR 0 4
 848: PUSH
 849: CALL_OW 44
 853: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 854: LD_ADDR_VAR 0 5
 858: PUSH
 859: LD_VAR 0 2
 863: PPUSH
 864: CALL_OW 254
 868: PUSH
 869: LD_INT 3
 871: MINUS
 872: ST_TO_ADDR
// if dir < 0 then
 873: LD_VAR 0 5
 877: PUSH
 878: LD_INT 0
 880: LESS
 881: IFFALSE 897
// dir := 6 + dir ;
 883: LD_ADDR_VAR 0 5
 887: PUSH
 888: LD_INT 6
 890: PUSH
 891: LD_VAR 0 5
 895: PLUS
 896: ST_TO_ADDR
// SetDir ( un , dir ) ;
 897: LD_VAR 0 4
 901: PPUSH
 902: LD_VAR 0 5
 906: PPUSH
 907: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 911: LD_VAR 0 4
 915: PPUSH
 916: LD_VAR 0 2
 920: PPUSH
 921: CALL_OW 52
// end ;
 925: LD_VAR 0 3
 929: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 930: LD_INT 0
 932: PPUSH
 933: PPUSH
 934: PPUSH
// result := false ;
 935: LD_ADDR_VAR 0 2
 939: PUSH
 940: LD_INT 0
 942: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 943: LD_ADDR_VAR 0 3
 947: PUSH
 948: LD_INT 22
 950: PUSH
 951: LD_INT 1
 953: PUSH
 954: EMPTY
 955: LIST
 956: LIST
 957: PUSH
 958: LD_INT 34
 960: PUSH
 961: LD_INT 2
 963: PUSH
 964: EMPTY
 965: LIST
 966: LIST
 967: PUSH
 968: EMPTY
 969: LIST
 970: LIST
 971: PPUSH
 972: CALL_OW 69
 976: ST_TO_ADDR
// for i in filter do
 977: LD_ADDR_VAR 0 4
 981: PUSH
 982: LD_VAR 0 3
 986: PUSH
 987: FOR_IN
 988: IFFALSE 1019
// if IsDrivenBy ( i ) = unit then
 990: LD_VAR 0 4
 994: PPUSH
 995: CALL_OW 311
 999: PUSH
1000: LD_VAR 0 1
1004: EQUAL
1005: IFFALSE 1017
// begin result := true ;
1007: LD_ADDR_VAR 0 2
1011: PUSH
1012: LD_INT 1
1014: ST_TO_ADDR
// break ;
1015: GO 1019
// end ;
1017: GO 987
1019: POP
1020: POP
// end ;
1021: LD_VAR 0 2
1025: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1026: LD_INT 0
1028: PPUSH
1029: PPUSH
// result := false ;
1030: LD_ADDR_VAR 0 2
1034: PUSH
1035: LD_INT 0
1037: ST_TO_ADDR
// if not blist then
1038: LD_VAR 0 1
1042: NOT
1043: IFFALSE 1047
// exit ;
1045: GO 1091
// for i in blist do
1047: LD_ADDR_VAR 0 3
1051: PUSH
1052: LD_VAR 0 1
1056: PUSH
1057: FOR_IN
1058: IFFALSE 1089
// if UnitsInside ( i ) < 6 then
1060: LD_VAR 0 3
1064: PPUSH
1065: CALL_OW 313
1069: PUSH
1070: LD_INT 6
1072: LESS
1073: IFFALSE 1087
// begin result := i ;
1075: LD_ADDR_VAR 0 2
1079: PUSH
1080: LD_VAR 0 3
1084: ST_TO_ADDR
// break ;
1085: GO 1089
// end ;
1087: GO 1057
1089: POP
1090: POP
// end ;
1091: LD_VAR 0 2
1095: RET
// export function Count ( timer , mode ) ; begin
1096: LD_INT 0
1098: PPUSH
// if not timer then
1099: LD_VAR 0 1
1103: NOT
1104: IFFALSE 1108
// exit ;
1106: GO 1159
// if mode in [ asc , up , + ] then
1108: LD_VAR 0 2
1112: PUSH
1113: LD_STRING asc
1115: PUSH
1116: LD_STRING up
1118: PUSH
1119: LD_STRING +
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: IN
1127: IFFALSE 1145
// result := timer + 0 0$01 else
1129: LD_ADDR_VAR 0 3
1133: PUSH
1134: LD_VAR 0 1
1138: PUSH
1139: LD_INT 35
1141: PLUS
1142: ST_TO_ADDR
1143: GO 1159
// result := timer - 0 0$01 ;
1145: LD_ADDR_VAR 0 3
1149: PUSH
1150: LD_VAR 0 1
1154: PUSH
1155: LD_INT 35
1157: MINUS
1158: ST_TO_ADDR
// end ; end_of_file
1159: LD_VAR 0 3
1163: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1164: LD_INT 0
1166: PPUSH
1167: PPUSH
1168: PPUSH
1169: PPUSH
1170: PPUSH
1171: PPUSH
1172: PPUSH
1173: PPUSH
// uc_side := 4 ;
1174: LD_ADDR_OWVAR 20
1178: PUSH
1179: LD_INT 4
1181: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1182: LD_ADDR_EXP 40
1186: PUSH
1187: LD_STRING Powell
1189: PPUSH
1190: LD_INT 0
1192: PPUSH
1193: CALL 434 0 2
1197: ST_TO_ADDR
// uc_side := 1 ;
1198: LD_ADDR_OWVAR 20
1202: PUSH
1203: LD_INT 1
1205: ST_TO_ADDR
// uc_nation := 1 ;
1206: LD_ADDR_OWVAR 21
1210: PUSH
1211: LD_INT 1
1213: ST_TO_ADDR
// if debug then
1214: LD_EXP 1
1218: IFFALSE 1348
// begin for i = 1 to 4 do
1220: LD_ADDR_VAR 0 2
1224: PUSH
1225: DOUBLE
1226: LD_INT 1
1228: DEC
1229: ST_TO_ADDR
1230: LD_INT 4
1232: PUSH
1233: FOR_TO
1234: IFFALSE 1285
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1236: LD_INT 0
1238: PPUSH
1239: LD_INT 1
1241: PPUSH
1242: LD_INT 2
1244: PPUSH
1245: CALL_OW 12
1249: PPUSH
1250: LD_INT 3
1252: PPUSH
1253: CALL_OW 380
// un := CreateHuman ;
1257: LD_ADDR_VAR 0 3
1261: PUSH
1262: CALL_OW 44
1266: ST_TO_ADDR
// others := others ^ un ;
1267: LD_ADDR_VAR 0 5
1271: PUSH
1272: LD_VAR 0 5
1276: PUSH
1277: LD_VAR 0 3
1281: ADD
1282: ST_TO_ADDR
// end ;
1283: GO 1233
1285: POP
1286: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1287: LD_ADDR_VAR 0 6
1291: PUSH
1292: LD_INT 21
1294: PUSH
1295: LD_INT 1
1297: PUSH
1298: LD_INT 1
1300: PUSH
1301: LD_INT 51
1303: PUSH
1304: LD_INT 90
1306: PUSH
1307: LD_INT 504
1309: PUSH
1310: EMPTY
1311: LIST
1312: LIST
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: PUSH
1318: LD_INT 21
1320: PUSH
1321: LD_INT 1
1323: PUSH
1324: LD_INT 1
1326: PUSH
1327: LD_INT 51
1329: PUSH
1330: LD_INT 80
1332: PUSH
1333: LD_INT 750
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: LIST
1341: LIST
1342: LIST
1343: PUSH
1344: EMPTY
1345: LIST
1346: LIST
1347: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1348: LD_ADDR_EXP 31
1352: PUSH
1353: LD_STRING JMM
1355: PPUSH
1356: LD_EXP 1
1360: NOT
1361: PPUSH
1362: CALL 434 0 2
1366: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1367: LD_ADDR_EXP 32
1371: PUSH
1372: LD_STRING Bobby
1374: PPUSH
1375: LD_EXP 1
1379: NOT
1380: PPUSH
1381: CALL 434 0 2
1385: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1386: LD_ADDR_EXP 33
1390: PUSH
1391: LD_STRING Cyrus
1393: PPUSH
1394: LD_EXP 1
1398: NOT
1399: PPUSH
1400: CALL 434 0 2
1404: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1405: LD_ADDR_EXP 34
1409: PUSH
1410: LD_STRING Lisa
1412: PPUSH
1413: LD_EXP 1
1417: NOT
1418: PPUSH
1419: CALL 434 0 2
1423: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1424: LD_ADDR_EXP 35
1428: PUSH
1429: LD_STRING Khatam
1431: PPUSH
1432: LD_EXP 1
1436: NOT
1437: PPUSH
1438: CALL 434 0 2
1442: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1443: LD_ADDR_EXP 36
1447: PUSH
1448: LD_STRING Brian
1450: PPUSH
1451: LD_EXP 1
1455: NOT
1456: PPUSH
1457: CALL 434 0 2
1461: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1462: LD_ADDR_EXP 37
1466: PUSH
1467: LD_STRING Jerry
1469: PPUSH
1470: LD_EXP 1
1474: NOT
1475: PPUSH
1476: CALL 434 0 2
1480: ST_TO_ADDR
// if Bobby then
1481: LD_EXP 32
1485: IFFALSE 1516
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1487: LD_ADDR_VAR 0 4
1491: PUSH
1492: LD_VAR 0 4
1496: PPUSH
1497: LD_VAR 0 4
1501: PUSH
1502: LD_INT 1
1504: PLUS
1505: PPUSH
1506: LD_EXP 32
1510: PPUSH
1511: CALL_OW 2
1515: ST_TO_ADDR
// if Cyrus then
1516: LD_EXP 33
1520: IFFALSE 1551
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1522: LD_ADDR_VAR 0 4
1526: PUSH
1527: LD_VAR 0 4
1531: PPUSH
1532: LD_VAR 0 4
1536: PUSH
1537: LD_INT 1
1539: PLUS
1540: PPUSH
1541: LD_EXP 33
1545: PPUSH
1546: CALL_OW 2
1550: ST_TO_ADDR
// if Lisa then
1551: LD_EXP 34
1555: IFFALSE 1586
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1557: LD_ADDR_VAR 0 4
1561: PUSH
1562: LD_VAR 0 4
1566: PPUSH
1567: LD_VAR 0 4
1571: PUSH
1572: LD_INT 1
1574: PLUS
1575: PPUSH
1576: LD_EXP 34
1580: PPUSH
1581: CALL_OW 2
1585: ST_TO_ADDR
// if Khatam then
1586: LD_EXP 35
1590: IFFALSE 1621
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1592: LD_ADDR_VAR 0 4
1596: PUSH
1597: LD_VAR 0 4
1601: PPUSH
1602: LD_VAR 0 4
1606: PUSH
1607: LD_INT 1
1609: PLUS
1610: PPUSH
1611: LD_EXP 35
1615: PPUSH
1616: CALL_OW 2
1620: ST_TO_ADDR
// if Brian then
1621: LD_EXP 36
1625: IFFALSE 1656
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1627: LD_ADDR_VAR 0 4
1631: PUSH
1632: LD_VAR 0 4
1636: PPUSH
1637: LD_VAR 0 4
1641: PUSH
1642: LD_INT 1
1644: PLUS
1645: PPUSH
1646: LD_EXP 36
1650: PPUSH
1651: CALL_OW 2
1655: ST_TO_ADDR
// if Jerry then
1656: LD_EXP 37
1660: IFFALSE 1691
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1662: LD_ADDR_VAR 0 4
1666: PUSH
1667: LD_VAR 0 4
1671: PPUSH
1672: LD_VAR 0 4
1676: PUSH
1677: LD_INT 1
1679: PLUS
1680: PPUSH
1681: LD_EXP 37
1685: PPUSH
1686: CALL_OW 2
1690: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1691: LD_STRING 02_other_survivors
1693: PPUSH
1694: CALL_OW 28
1698: IFFALSE 1713
// others := CreateCharacterSet ( 02_other_survivors ) ;
1700: LD_ADDR_VAR 0 5
1704: PUSH
1705: LD_STRING 02_other_survivors
1707: PPUSH
1708: CALL_OW 31
1712: ST_TO_ADDR
// if others then
1713: LD_VAR 0 5
1717: IFFALSE 1742
// begin tmp := tmp ^ others ;
1719: LD_ADDR_VAR 0 4
1723: PUSH
1724: LD_VAR 0 4
1728: PUSH
1729: LD_VAR 0 5
1733: ADD
1734: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1735: LD_STRING 02_other_survivors
1737: PPUSH
1738: CALL_OW 40
// end ; jmm_units := tmp ;
1742: LD_ADDR_EXP 2
1746: PUSH
1747: LD_VAR 0 4
1751: ST_TO_ADDR
// if not vehicles then
1752: LD_VAR 0 6
1756: NOT
1757: IFFALSE 1775
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1759: LD_ADDR_VAR 0 6
1763: PUSH
1764: LD_STRING 02_tanks_1
1766: PPUSH
1767: LD_INT 0
1769: PPUSH
1770: CALL_OW 30
1774: ST_TO_ADDR
// if vehicles then
1775: LD_VAR 0 6
1779: IFFALSE 1973
// begin got_mech := false ;
1781: LD_ADDR_VAR 0 7
1785: PUSH
1786: LD_INT 0
1788: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1789: LD_VAR 0 4
1793: PPUSH
1794: LD_INT 25
1796: PUSH
1797: LD_INT 3
1799: PUSH
1800: EMPTY
1801: LIST
1802: LIST
1803: PPUSH
1804: CALL_OW 72
1808: IFFALSE 1818
// got_mech := true ;
1810: LD_ADDR_VAR 0 7
1814: PUSH
1815: LD_INT 1
1817: ST_TO_ADDR
// for i = 1 to vehicles do
1818: LD_ADDR_VAR 0 2
1822: PUSH
1823: DOUBLE
1824: LD_INT 1
1826: DEC
1827: ST_TO_ADDR
1828: LD_VAR 0 6
1832: PUSH
1833: FOR_TO
1834: IFFALSE 1971
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1836: LD_ADDR_VAR 0 3
1840: PUSH
1841: LD_INT 1
1843: PPUSH
1844: LD_INT 3
1846: PPUSH
1847: LD_VAR 0 6
1851: PUSH
1852: LD_VAR 0 2
1856: ARRAY
1857: PUSH
1858: LD_INT 1
1860: ARRAY
1861: PPUSH
1862: LD_VAR 0 6
1866: PUSH
1867: LD_VAR 0 2
1871: ARRAY
1872: PUSH
1873: LD_INT 2
1875: ARRAY
1876: PPUSH
1877: LD_VAR 0 6
1881: PUSH
1882: LD_VAR 0 2
1886: ARRAY
1887: PUSH
1888: LD_INT 3
1890: ARRAY
1891: PPUSH
1892: LD_VAR 0 6
1896: PUSH
1897: LD_VAR 0 2
1901: ARRAY
1902: PUSH
1903: LD_INT 4
1905: ARRAY
1906: PPUSH
1907: LD_INT 40
1909: PPUSH
1910: CALL 516 0 7
1914: ST_TO_ADDR
// if not got_mech then
1915: LD_VAR 0 7
1919: NOT
1920: IFFALSE 1946
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1922: LD_VAR 0 3
1926: PPUSH
1927: LD_VAR 0 6
1931: PUSH
1932: LD_VAR 0 2
1936: ARRAY
1937: PUSH
1938: LD_INT 6
1940: ARRAY
1941: PPUSH
1942: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1946: LD_ADDR_VAR 0 4
1950: PUSH
1951: LD_VAR 0 4
1955: PPUSH
1956: LD_INT 1
1958: PPUSH
1959: LD_VAR 0 3
1963: PPUSH
1964: CALL_OW 2
1968: ST_TO_ADDR
// end ;
1969: GO 1833
1971: POP
1972: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1973: LD_EXP 31
1977: PPUSH
1978: LD_INT 194
1980: PPUSH
1981: LD_INT 119
1983: PPUSH
1984: LD_INT 0
1986: PPUSH
1987: CALL_OW 48
// if tmp then
1991: LD_VAR 0 4
1995: IFFALSE 2120
// begin for i in tmp do
1997: LD_ADDR_VAR 0 2
2001: PUSH
2002: LD_VAR 0 4
2006: PUSH
2007: FOR_IN
2008: IFFALSE 2118
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2010: LD_ADDR_VAR 0 8
2014: PUSH
2015: LD_INT 22
2017: PUSH
2018: LD_INT 1
2020: PUSH
2021: EMPTY
2022: LIST
2023: LIST
2024: PUSH
2025: LD_INT 21
2027: PUSH
2028: LD_INT 2
2030: PUSH
2031: EMPTY
2032: LIST
2033: LIST
2034: PUSH
2035: LD_INT 58
2037: PUSH
2038: EMPTY
2039: LIST
2040: PUSH
2041: EMPTY
2042: LIST
2043: LIST
2044: LIST
2045: PPUSH
2046: CALL_OW 69
2050: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2051: LD_VAR 0 2
2055: PPUSH
2056: CALL_OW 247
2060: PUSH
2061: LD_INT 1
2063: EQUAL
2064: PUSH
2065: LD_VAR 0 8
2069: AND
2070: IFFALSE 2092
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2072: LD_VAR 0 2
2076: PPUSH
2077: LD_VAR 0 8
2081: PUSH
2082: LD_INT 1
2084: ARRAY
2085: PPUSH
2086: CALL_OW 52
2090: GO 2107
// PlaceUnitArea ( i , startArea , false ) ;
2092: LD_VAR 0 2
2096: PPUSH
2097: LD_INT 1
2099: PPUSH
2100: LD_INT 0
2102: PPUSH
2103: CALL_OW 49
// ComHold ( i ) ;
2107: LD_VAR 0 2
2111: PPUSH
2112: CALL_OW 140
// end ;
2116: GO 2007
2118: POP
2119: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2120: LD_ADDR_EXP 5
2124: PUSH
2125: LD_STRING 02_mikhailStatus_1
2127: PPUSH
2128: LD_INT 0
2130: PPUSH
2131: CALL_OW 30
2135: ST_TO_ADDR
// if not bierezov_exist and not debug then
2136: LD_EXP 5
2140: NOT
2141: PUSH
2142: LD_EXP 1
2146: NOT
2147: AND
2148: IFFALSE 2152
// exit ;
2150: GO 2183
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2152: LD_ADDR_EXP 39
2156: PUSH
2157: LD_STRING Mikhail
2159: PPUSH
2160: LD_INT 0
2162: PPUSH
2163: CALL 434 0 2
2167: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2168: LD_EXP 39
2172: PPUSH
2173: LD_INT 1
2175: PPUSH
2176: LD_INT 0
2178: PPUSH
2179: CALL_OW 49
// end ;
2183: LD_VAR 0 1
2187: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2188: LD_INT 0
2190: PPUSH
2191: PPUSH
2192: PPUSH
2193: PPUSH
// uc_side := 4 ;
2194: LD_ADDR_OWVAR 20
2198: PUSH
2199: LD_INT 4
2201: ST_TO_ADDR
// uc_nation := 1 ;
2202: LD_ADDR_OWVAR 21
2206: PUSH
2207: LD_INT 1
2209: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2210: LD_ADDR_EXP 38
2214: PUSH
2215: LD_STRING Cornell
2217: PPUSH
2218: LD_INT 0
2220: PPUSH
2221: CALL 434 0 2
2225: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
2226: LD_ADDR_EXP 4
2230: PUSH
2231: LD_INT 8
2233: PUSH
2234: LD_EXP 2
2238: MINUS
2239: ST_TO_ADDR
// tmp := [ ] ;
2240: LD_ADDR_VAR 0 2
2244: PUSH
2245: EMPTY
2246: ST_TO_ADDR
// if cornel_units < 3 then
2247: LD_EXP 4
2251: PUSH
2252: LD_INT 3
2254: LESS
2255: IFFALSE 2265
// cornel_units := 3 ;
2257: LD_ADDR_EXP 4
2261: PUSH
2262: LD_INT 3
2264: ST_TO_ADDR
// for i = 1 to cornel_units do
2265: LD_ADDR_VAR 0 4
2269: PUSH
2270: DOUBLE
2271: LD_INT 1
2273: DEC
2274: ST_TO_ADDR
2275: LD_EXP 4
2279: PUSH
2280: FOR_TO
2281: IFFALSE 2379
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2283: LD_INT 0
2285: PPUSH
2286: LD_INT 1
2288: PUSH
2289: LD_INT 1
2291: PUSH
2292: LD_INT 1
2294: PUSH
2295: LD_INT 2
2297: PUSH
2298: LD_INT 4
2300: PUSH
2301: EMPTY
2302: LIST
2303: LIST
2304: LIST
2305: LIST
2306: LIST
2307: PUSH
2308: LD_VAR 0 4
2312: PUSH
2313: LD_INT 5
2315: MOD
2316: PUSH
2317: LD_INT 1
2319: PLUS
2320: ARRAY
2321: PPUSH
2322: LD_INT 2
2324: PPUSH
2325: CALL_OW 380
// un := CreateHuman ;
2329: LD_ADDR_VAR 0 3
2333: PUSH
2334: CALL_OW 44
2338: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2339: LD_ADDR_VAR 0 2
2343: PUSH
2344: LD_VAR 0 2
2348: PPUSH
2349: LD_INT 1
2351: PPUSH
2352: LD_VAR 0 3
2356: PPUSH
2357: CALL_OW 2
2361: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2362: LD_VAR 0 3
2366: PPUSH
2367: LD_INT 2
2369: PPUSH
2370: LD_INT 0
2372: PPUSH
2373: CALL_OW 49
// end ;
2377: GO 2280
2379: POP
2380: POP
// cornel_units := tmp ;
2381: LD_ADDR_EXP 4
2385: PUSH
2386: LD_VAR 0 2
2390: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2391: LD_EXP 38
2395: PPUSH
2396: LD_INT 191
2398: PPUSH
2399: LD_INT 106
2401: PPUSH
2402: LD_INT 0
2404: PPUSH
2405: CALL_OW 48
// end ;
2409: LD_VAR 0 1
2413: RET
// export function PrepareWesternBase ; var i ; begin
2414: LD_INT 0
2416: PPUSH
2417: PPUSH
// uc_side := 8 ;
2418: LD_ADDR_OWVAR 20
2422: PUSH
2423: LD_INT 8
2425: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2426: LD_ADDR_EXP 41
2430: PUSH
2431: LD_STRING Lynch
2433: PPUSH
2434: LD_INT 0
2436: PPUSH
2437: CALL 434 0 2
2441: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2442: LD_ADDR_EXP 42
2446: PUSH
2447: LD_STRING Walker
2449: PPUSH
2450: LD_INT 0
2452: PPUSH
2453: CALL 434 0 2
2457: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2458: LD_ADDR_EXP 43
2462: PUSH
2463: LD_STRING Turner
2465: PPUSH
2466: LD_INT 0
2468: PPUSH
2469: CALL 434 0 2
2473: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2474: LD_ADDR_EXP 44
2478: PUSH
2479: LD_STRING Jillian
2481: PPUSH
2482: LD_INT 0
2484: PPUSH
2485: CALL 434 0 2
2489: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2490: LD_ADDR_VAR 0 2
2494: PUSH
2495: LD_EXP 41
2499: PUSH
2500: LD_EXP 42
2504: PUSH
2505: LD_EXP 43
2509: PUSH
2510: LD_EXP 44
2514: PUSH
2515: EMPTY
2516: LIST
2517: LIST
2518: LIST
2519: LIST
2520: PUSH
2521: FOR_IN
2522: IFFALSE 2550
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2524: LD_VAR 0 2
2528: PPUSH
2529: LD_INT 3
2531: PPUSH
2532: LD_INT 0
2534: PPUSH
2535: CALL_OW 49
// ComHold ( i ) ;
2539: LD_VAR 0 2
2543: PPUSH
2544: CALL_OW 140
// end ;
2548: GO 2521
2550: POP
2551: POP
// end ;
2552: LD_VAR 0 1
2556: RET
// export function SelectGroup ; var units , selected , i ; begin
2557: LD_INT 0
2559: PPUSH
2560: PPUSH
2561: PPUSH
2562: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2563: LD_ADDR_VAR 0 2
2567: PUSH
2568: LD_EXP 31
2572: PUSH
2573: LD_INT -3
2575: PUSH
2576: EMPTY
2577: LIST
2578: LIST
2579: PUSH
2580: LD_EXP 2
2584: ADD
2585: PUSH
2586: LD_INT -2
2588: PUSH
2589: LD_INT -4
2591: PUSH
2592: LD_EXP 38
2596: PUSH
2597: LD_EXP 39
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: LIST
2606: LIST
2607: ADD
2608: PUSH
2609: LD_INT -3
2611: PUSH
2612: EMPTY
2613: LIST
2614: ADD
2615: PUSH
2616: LD_EXP 4
2620: ADD
2621: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2622: LD_ADDR_VAR 0 3
2626: PUSH
2627: LD_EXP 31
2631: PUSH
2632: LD_STRING Select five characters to go with you
2634: PPUSH
2635: LD_INT 4
2637: PPUSH
2638: LD_INT 4
2640: PPUSH
2641: LD_VAR 0 2
2645: PPUSH
2646: EMPTY
2647: PPUSH
2648: CALL_OW 42
2652: ADD
2653: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2654: LD_ADDR_EXP 4
2658: PUSH
2659: LD_EXP 2
2663: PUSH
2664: LD_EXP 4
2668: UNION
2669: PUSH
2670: LD_VAR 0 3
2674: DIFF
2675: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2676: LD_ADDR_VAR 0 4
2680: PUSH
2681: LD_EXP 4
2685: PUSH
2686: LD_EXP 39
2690: ADD
2691: PUSH
2692: FOR_IN
2693: IFFALSE 2724
// if GetSide ( i ) = 1 then
2695: LD_VAR 0 4
2699: PPUSH
2700: CALL_OW 255
2704: PUSH
2705: LD_INT 1
2707: EQUAL
2708: IFFALSE 2722
// SetSide ( i , 4 ) ;
2710: LD_VAR 0 4
2714: PPUSH
2715: LD_INT 4
2717: PPUSH
2718: CALL_OW 235
2722: GO 2692
2724: POP
2725: POP
// for i in selected do
2726: LD_ADDR_VAR 0 4
2730: PUSH
2731: LD_VAR 0 3
2735: PUSH
2736: FOR_IN
2737: IFFALSE 2768
// if GetSide ( i ) = 4 then
2739: LD_VAR 0 4
2743: PPUSH
2744: CALL_OW 255
2748: PUSH
2749: LD_INT 4
2751: EQUAL
2752: IFFALSE 2766
// SetSide ( i , 1 ) ;
2754: LD_VAR 0 4
2758: PPUSH
2759: LD_INT 1
2761: PPUSH
2762: CALL_OW 235
2766: GO 2736
2768: POP
2769: POP
// jmm_units := jmm_units diff cornel_units ;
2770: LD_ADDR_EXP 2
2774: PUSH
2775: LD_EXP 2
2779: PUSH
2780: LD_EXP 4
2784: DIFF
2785: ST_TO_ADDR
// if GetSide ( Bobby ) = 4 then
2786: LD_EXP 32
2790: PPUSH
2791: CALL_OW 255
2795: PUSH
2796: LD_INT 4
2798: EQUAL
2799: IFFALSE 2808
// DeleteCharacters ( Bobby ) ;
2801: LD_STRING Bobby
2803: PPUSH
2804: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2808: LD_EXP 33
2812: PPUSH
2813: CALL_OW 255
2817: PUSH
2818: LD_INT 4
2820: EQUAL
2821: IFFALSE 2830
// DeleteCharacters ( Cyrus ) ;
2823: LD_STRING Cyrus
2825: PPUSH
2826: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2830: LD_EXP 34
2834: PPUSH
2835: CALL_OW 255
2839: PUSH
2840: LD_INT 4
2842: EQUAL
2843: IFFALSE 2852
// DeleteCharacters ( Lisa ) ;
2845: LD_STRING Lisa
2847: PPUSH
2848: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2852: LD_EXP 35
2856: PPUSH
2857: CALL_OW 255
2861: PUSH
2862: LD_INT 4
2864: EQUAL
2865: IFFALSE 2874
// DeleteCharacters ( Khatam ) ;
2867: LD_STRING Khatam
2869: PPUSH
2870: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2874: LD_EXP 36
2878: PPUSH
2879: CALL_OW 255
2883: PUSH
2884: LD_INT 4
2886: EQUAL
2887: IFFALSE 2896
// DeleteCharacters ( Brian ) ;
2889: LD_STRING Brian
2891: PPUSH
2892: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2896: LD_EXP 37
2900: PPUSH
2901: CALL_OW 255
2905: PUSH
2906: LD_INT 4
2908: EQUAL
2909: IFFALSE 2918
// DeleteCharacters ( Jerry ) ;
2911: LD_STRING Jerry
2913: PPUSH
2914: CALL_OW 40
// end ; end_of_file
2918: LD_VAR 0 1
2922: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles , ru_produce_list , ru_cornel_attack ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , j , b , un , veh , tw , bar , lab , fac , skill , vehicles , spot_xy ; begin
2923: LD_INT 0
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
2930: PPUSH
2931: PPUSH
2932: PPUSH
2933: PPUSH
2934: PPUSH
2935: PPUSH
2936: PPUSH
2937: PPUSH
// ru_alert := false ;
2938: LD_ADDR_EXP 54
2942: PUSH
2943: LD_INT 0
2945: ST_TO_ADDR
// ru_produce_list := [ ] ;
2946: LD_ADDR_EXP 51
2950: PUSH
2951: EMPTY
2952: ST_TO_ADDR
// if Difficulty > 1 then
2953: LD_OWVAR 67
2957: PUSH
2958: LD_INT 1
2960: GREATER
2961: IFFALSE 3049
// begin uc_side := 3 ;
2963: LD_ADDR_OWVAR 20
2967: PUSH
2968: LD_INT 3
2970: ST_TO_ADDR
// uc_nation := 3 ;
2971: LD_ADDR_OWVAR 21
2975: PUSH
2976: LD_INT 3
2978: ST_TO_ADDR
// bc_type := b_breastwork ;
2979: LD_ADDR_OWVAR 42
2983: PUSH
2984: LD_INT 31
2986: ST_TO_ADDR
// bc_level := Difficulty ;
2987: LD_ADDR_OWVAR 43
2991: PUSH
2992: LD_OWVAR 67
2996: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 22 , 14 , 0 ) ;
2997: LD_INT 22
2999: PPUSH
3000: LD_INT 14
3002: PPUSH
3003: LD_INT 0
3005: PPUSH
3006: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 48 , 46 , 0 ) ;
3010: LD_INT 48
3012: PPUSH
3013: LD_INT 46
3015: PPUSH
3016: LD_INT 0
3018: PPUSH
3019: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 86 , 65 , 5 ) ;
3023: LD_INT 86
3025: PPUSH
3026: LD_INT 65
3028: PPUSH
3029: LD_INT 5
3031: PPUSH
3032: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 165 , 73 , 5 ) ;
3036: LD_INT 165
3038: PPUSH
3039: LD_INT 73
3041: PPUSH
3042: LD_INT 5
3044: PPUSH
3045: CALL_OW 47
// end ; tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
3049: LD_ADDR_VAR 0 7
3053: PUSH
3054: LD_INT 22
3056: PUSH
3057: LD_INT 3
3059: PUSH
3060: EMPTY
3061: LIST
3062: LIST
3063: PUSH
3064: LD_INT 2
3066: PUSH
3067: LD_INT 30
3069: PUSH
3070: LD_INT 31
3072: PUSH
3073: EMPTY
3074: LIST
3075: LIST
3076: PUSH
3077: LD_INT 30
3079: PUSH
3080: LD_INT 32
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: LIST
3091: PUSH
3092: EMPTY
3093: LIST
3094: LIST
3095: PPUSH
3096: CALL_OW 69
3100: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
3101: LD_ADDR_VAR 0 8
3105: PUSH
3106: LD_INT 22
3108: PUSH
3109: LD_INT 3
3111: PUSH
3112: EMPTY
3113: LIST
3114: LIST
3115: PUSH
3116: LD_INT 30
3118: PUSH
3119: LD_INT 4
3121: PUSH
3122: EMPTY
3123: LIST
3124: LIST
3125: PUSH
3126: EMPTY
3127: LIST
3128: LIST
3129: PPUSH
3130: CALL_OW 69
3134: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3135: LD_ADDR_VAR 0 10
3139: PUSH
3140: LD_INT 22
3142: PUSH
3143: LD_INT 3
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: LD_INT 30
3152: PUSH
3153: LD_INT 3
3155: PUSH
3156: EMPTY
3157: LIST
3158: LIST
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: PPUSH
3164: CALL_OW 69
3168: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_lab ] ] ) ;
3169: LD_ADDR_VAR 0 9
3173: PUSH
3174: LD_INT 22
3176: PUSH
3177: LD_INT 3
3179: PUSH
3180: EMPTY
3181: LIST
3182: LIST
3183: PUSH
3184: LD_INT 30
3186: PUSH
3187: LD_INT 6
3189: PUSH
3190: EMPTY
3191: LIST
3192: LIST
3193: PUSH
3194: EMPTY
3195: LIST
3196: LIST
3197: PPUSH
3198: CALL_OW 69
3202: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3203: LD_ADDR_VAR 0 2
3207: PUSH
3208: LD_INT 22
3210: PUSH
3211: LD_INT 3
3213: PUSH
3214: EMPTY
3215: LIST
3216: LIST
3217: PUSH
3218: LD_INT 30
3220: PUSH
3221: LD_INT 1
3223: PUSH
3224: EMPTY
3225: LIST
3226: LIST
3227: PUSH
3228: EMPTY
3229: LIST
3230: LIST
3231: PPUSH
3232: CALL_OW 69
3236: PUSH
3237: FOR_IN
3238: IFFALSE 3282
// begin SetResourceType ( GetBase ( i ) , mat_cans , 5000 ) ;
3240: LD_VAR 0 2
3244: PPUSH
3245: CALL_OW 274
3249: PPUSH
3250: LD_INT 1
3252: PPUSH
3253: LD_INT 5000
3255: PPUSH
3256: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 3000 ) ;
3260: LD_VAR 0 2
3264: PPUSH
3265: CALL_OW 274
3269: PPUSH
3270: LD_INT 2
3272: PPUSH
3273: LD_INT 3000
3275: PPUSH
3276: CALL_OW 277
// end ;
3280: GO 3237
3282: POP
3283: POP
// uc_side := 3 ;
3284: LD_ADDR_OWVAR 20
3288: PUSH
3289: LD_INT 3
3291: ST_TO_ADDR
// uc_nation := 3 ;
3292: LD_ADDR_OWVAR 21
3296: PUSH
3297: LD_INT 3
3299: ST_TO_ADDR
// skill := [ 2 , 2 , 3 ] [ Difficulty ] ;
3300: LD_ADDR_VAR 0 11
3304: PUSH
3305: LD_INT 2
3307: PUSH
3308: LD_INT 2
3310: PUSH
3311: LD_INT 3
3313: PUSH
3314: EMPTY
3315: LIST
3316: LIST
3317: LIST
3318: PUSH
3319: LD_OWVAR 67
3323: ARRAY
3324: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3325: LD_ADDR_EXP 46
3329: PUSH
3330: LD_STRING Pokryshkin
3332: PPUSH
3333: LD_INT 0
3335: PPUSH
3336: CALL 434 0 2
3340: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3341: LD_EXP 46
3345: PPUSH
3346: LD_INT 63
3348: PPUSH
3349: LD_INT 21
3351: PPUSH
3352: LD_INT 0
3354: PPUSH
3355: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3359: LD_EXP 46
3363: PPUSH
3364: CALL_OW 140
// InitHc ;
3368: CALL_OW 19
// for i in fac do
3372: LD_ADDR_VAR 0 2
3376: PUSH
3377: LD_VAR 0 10
3381: PUSH
3382: FOR_IN
3383: IFFALSE 3436
// begin for j = 1 to 6 do
3385: LD_ADDR_VAR 0 3
3389: PUSH
3390: DOUBLE
3391: LD_INT 1
3393: DEC
3394: ST_TO_ADDR
3395: LD_INT 6
3397: PUSH
3398: FOR_TO
3399: IFFALSE 3432
// begin PrepareHuman ( false , 3 , skill ) ;
3401: LD_INT 0
3403: PPUSH
3404: LD_INT 3
3406: PPUSH
3407: LD_VAR 0 11
3411: PPUSH
3412: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3416: CALL_OW 44
3420: PPUSH
3421: LD_VAR 0 2
3425: PPUSH
3426: CALL_OW 52
// end ;
3430: GO 3398
3432: POP
3433: POP
// end ;
3434: GO 3382
3436: POP
3437: POP
// for i in lab do
3438: LD_ADDR_VAR 0 2
3442: PUSH
3443: LD_VAR 0 9
3447: PUSH
3448: FOR_IN
3449: IFFALSE 3482
// begin PrepareHuman ( false , 4 , skill ) ;
3451: LD_INT 0
3453: PPUSH
3454: LD_INT 4
3456: PPUSH
3457: LD_VAR 0 11
3461: PPUSH
3462: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3466: CALL_OW 44
3470: PPUSH
3471: LD_VAR 0 2
3475: PPUSH
3476: CALL_OW 52
// end ;
3480: GO 3448
3482: POP
3483: POP
// for i in tw do
3484: LD_ADDR_VAR 0 2
3488: PUSH
3489: LD_VAR 0 7
3493: PUSH
3494: FOR_IN
3495: IFFALSE 3544
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3497: LD_VAR 0 2
3501: PPUSH
3502: LD_INT 42
3504: PUSH
3505: LD_INT 43
3507: PUSH
3508: EMPTY
3509: LIST
3510: LIST
3511: PUSH
3512: LD_INT 1
3514: PPUSH
3515: LD_INT 2
3517: PPUSH
3518: CALL_OW 12
3522: ARRAY
3523: PPUSH
3524: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3528: LD_VAR 0 11
3532: PPUSH
3533: LD_VAR 0 2
3537: PPUSH
3538: CALL 794 0 2
// end ;
3542: GO 3494
3544: POP
3545: POP
// for i in bar do
3546: LD_ADDR_VAR 0 2
3550: PUSH
3551: LD_VAR 0 8
3555: PUSH
3556: FOR_IN
3557: IFFALSE 3590
// begin PrepareHuman ( false , 1 , skill ) ;
3559: LD_INT 0
3561: PPUSH
3562: LD_INT 1
3564: PPUSH
3565: LD_VAR 0 11
3569: PPUSH
3570: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3574: CALL_OW 44
3578: PPUSH
3579: LD_VAR 0 2
3583: PPUSH
3584: CALL_OW 52
// end ;
3588: GO 3556
3590: POP
3591: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3592: LD_ADDR_VAR 0 13
3596: PUSH
3597: LD_INT 100
3599: PUSH
3600: LD_INT 9
3602: PUSH
3603: EMPTY
3604: LIST
3605: LIST
3606: PUSH
3607: LD_INT 135
3609: PUSH
3610: LD_INT 60
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PUSH
3617: LD_INT 41
3619: PUSH
3620: LD_INT 6
3622: PUSH
3623: EMPTY
3624: LIST
3625: LIST
3626: PUSH
3627: LD_INT 22
3629: PUSH
3630: LD_INT 9
3632: PUSH
3633: EMPTY
3634: LIST
3635: LIST
3636: PUSH
3637: LD_INT 84
3639: PUSH
3640: LD_INT 14
3642: PUSH
3643: EMPTY
3644: LIST
3645: LIST
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: LIST
3651: LIST
3652: LIST
3653: ST_TO_ADDR
// vehicles := [ ] ;
3654: LD_ADDR_VAR 0 12
3658: PUSH
3659: EMPTY
3660: ST_TO_ADDR
// for i in spot_xy do
3661: LD_ADDR_VAR 0 2
3665: PUSH
3666: LD_VAR 0 13
3670: PUSH
3671: FOR_IN
3672: IFFALSE 3830
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3674: LD_ADDR_VAR 0 6
3678: PUSH
3679: LD_INT 3
3681: PPUSH
3682: LD_INT 3
3684: PPUSH
3685: LD_INT 22
3687: PPUSH
3688: LD_INT 1
3690: PPUSH
3691: LD_INT 1
3693: PPUSH
3694: LD_INT 42
3696: PUSH
3697: LD_INT 43
3699: PUSH
3700: LD_INT 44
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: LIST
3707: PUSH
3708: LD_INT 1
3710: PPUSH
3711: LD_INT 3
3713: PPUSH
3714: CALL_OW 12
3718: ARRAY
3719: PPUSH
3720: LD_INT 100
3722: PPUSH
3723: CALL 516 0 7
3727: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3728: LD_ADDR_VAR 0 12
3732: PUSH
3733: LD_VAR 0 12
3737: PPUSH
3738: LD_VAR 0 12
3742: PUSH
3743: LD_INT 1
3745: PLUS
3746: PPUSH
3747: LD_VAR 0 6
3751: PPUSH
3752: CALL_OW 2
3756: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3757: LD_VAR 0 6
3761: PPUSH
3762: LD_INT 3
3764: PPUSH
3765: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3769: LD_VAR 0 6
3773: PPUSH
3774: LD_VAR 0 2
3778: PUSH
3779: LD_INT 1
3781: ARRAY
3782: PPUSH
3783: LD_VAR 0 2
3787: PUSH
3788: LD_INT 2
3790: ARRAY
3791: PPUSH
3792: LD_INT 0
3794: PPUSH
3795: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3799: LD_INT 0
3801: PPUSH
3802: LD_INT 3
3804: PPUSH
3805: LD_VAR 0 11
3809: PPUSH
3810: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3814: CALL_OW 44
3818: PPUSH
3819: LD_VAR 0 6
3823: PPUSH
3824: CALL_OW 52
// end ;
3828: GO 3671
3830: POP
3831: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3832: LD_ADDR_VAR 0 2
3836: PUSH
3837: DOUBLE
3838: LD_INT 1
3840: DEC
3841: ST_TO_ADDR
3842: LD_INT 5
3844: PUSH
3845: LD_INT 7
3847: PUSH
3848: LD_INT 8
3850: PUSH
3851: EMPTY
3852: LIST
3853: LIST
3854: LIST
3855: PUSH
3856: LD_OWVAR 67
3860: ARRAY
3861: PUSH
3862: FOR_TO
3863: IFFALSE 3923
// begin PrepareHuman ( false , 1 , skill ) ;
3865: LD_INT 0
3867: PPUSH
3868: LD_INT 1
3870: PPUSH
3871: LD_VAR 0 11
3875: PPUSH
3876: CALL_OW 380
// un := CreateHuman ;
3880: LD_ADDR_VAR 0 5
3884: PUSH
3885: CALL_OW 44
3889: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3890: LD_VAR 0 5
3894: PPUSH
3895: LD_INT 11
3897: PPUSH
3898: LD_INT 0
3900: PPUSH
3901: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3905: LD_ADDR_EXP 49
3909: PUSH
3910: LD_EXP 49
3914: PUSH
3915: LD_VAR 0 5
3919: ADD
3920: ST_TO_ADDR
// end ;
3921: GO 3862
3923: POP
3924: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3925: LD_ADDR_VAR 0 2
3929: PUSH
3930: DOUBLE
3931: LD_INT 1
3933: DEC
3934: ST_TO_ADDR
3935: LD_INT 2
3937: PUSH
3938: LD_INT 3
3940: PUSH
3941: LD_INT 4
3943: PUSH
3944: EMPTY
3945: LIST
3946: LIST
3947: LIST
3948: PUSH
3949: LD_OWVAR 67
3953: ARRAY
3954: PUSH
3955: FOR_TO
3956: IFFALSE 4016
// begin PrepareHuman ( false , 1 , skill ) ;
3958: LD_INT 0
3960: PPUSH
3961: LD_INT 1
3963: PPUSH
3964: LD_VAR 0 11
3968: PPUSH
3969: CALL_OW 380
// un := CreateHuman ;
3973: LD_ADDR_VAR 0 5
3977: PUSH
3978: CALL_OW 44
3982: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
3983: LD_VAR 0 5
3987: PPUSH
3988: LD_INT 12
3990: PPUSH
3991: LD_INT 0
3993: PPUSH
3994: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
3998: LD_ADDR_EXP 47
4002: PUSH
4003: LD_EXP 47
4007: PUSH
4008: LD_VAR 0 5
4012: ADD
4013: ST_TO_ADDR
// end ;
4014: GO 3955
4016: POP
4017: POP
// for i = 1 to 2 do
4018: LD_ADDR_VAR 0 2
4022: PUSH
4023: DOUBLE
4024: LD_INT 1
4026: DEC
4027: ST_TO_ADDR
4028: LD_INT 2
4030: PUSH
4031: FOR_TO
4032: IFFALSE 4098
// begin PrepareHuman ( sex_male , 1 , skill ) ;
4034: LD_INT 1
4036: PPUSH
4037: LD_INT 1
4039: PPUSH
4040: LD_VAR 0 11
4044: PPUSH
4045: CALL_OW 380
// un := CreateHuman ;
4049: LD_ADDR_VAR 0 5
4053: PUSH
4054: CALL_OW 44
4058: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
4059: LD_VAR 0 5
4063: PPUSH
4064: LD_INT 39
4066: PPUSH
4067: LD_INT 12
4069: PPUSH
4070: LD_INT 3
4072: PPUSH
4073: LD_INT 0
4075: PPUSH
4076: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
4080: LD_ADDR_EXP 48
4084: PUSH
4085: LD_EXP 48
4089: PUSH
4090: LD_VAR 0 5
4094: ADD
4095: ST_TO_ADDR
// end ;
4096: GO 4031
4098: POP
4099: POP
// for i = 1 to 3 do
4100: LD_ADDR_VAR 0 2
4104: PUSH
4105: DOUBLE
4106: LD_INT 1
4108: DEC
4109: ST_TO_ADDR
4110: LD_INT 3
4112: PUSH
4113: FOR_TO
4114: IFFALSE 4180
// begin PrepareHuman ( false , 1 , skill ) ;
4116: LD_INT 0
4118: PPUSH
4119: LD_INT 1
4121: PPUSH
4122: LD_VAR 0 11
4126: PPUSH
4127: CALL_OW 380
// un := CreateHuman ;
4131: LD_ADDR_VAR 0 5
4135: PUSH
4136: CALL_OW 44
4140: ST_TO_ADDR
// PlaceUnitXYR ( un , 180 , 11 , 4 , false ) ;
4141: LD_VAR 0 5
4145: PPUSH
4146: LD_INT 180
4148: PPUSH
4149: LD_INT 11
4151: PPUSH
4152: LD_INT 4
4154: PPUSH
4155: LD_INT 0
4157: PPUSH
4158: CALL_OW 50
// ru_cornel_attack := ru_cornel_attack ^ un ;
4162: LD_ADDR_EXP 52
4166: PUSH
4167: LD_EXP 52
4171: PUSH
4172: LD_VAR 0 5
4176: ADD
4177: ST_TO_ADDR
// end ;
4178: GO 4113
4180: POP
4181: POP
// ru_vehicles := vehicles ;
4182: LD_ADDR_EXP 50
4186: PUSH
4187: LD_VAR 0 12
4191: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
4192: LD_ADDR_EXP 53
4196: PUSH
4197: LD_INT 131
4199: PUSH
4200: LD_INT 121
4202: PUSH
4203: EMPTY
4204: LIST
4205: LIST
4206: PUSH
4207: LD_INT 113
4209: PUSH
4210: LD_INT 90
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: PUSH
4217: LD_INT 93
4219: PUSH
4220: LD_INT 62
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 106
4234: PUSH
4235: LD_INT 54
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 120
4244: PUSH
4245: LD_INT 80
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: LD_INT 143
4254: PUSH
4255: LD_INT 120
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: LIST
4266: PUSH
4267: LD_INT 154
4269: PUSH
4270: LD_INT 116
4272: PUSH
4273: EMPTY
4274: LIST
4275: LIST
4276: PUSH
4277: LD_INT 140
4279: PUSH
4280: LD_INT 93
4282: PUSH
4283: EMPTY
4284: LIST
4285: LIST
4286: PUSH
4287: LD_INT 130
4289: PUSH
4290: LD_INT 58
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: PUSH
4297: EMPTY
4298: LIST
4299: LIST
4300: LIST
4301: PUSH
4302: LD_INT 105
4304: PUSH
4305: LD_INT 106
4307: PUSH
4308: EMPTY
4309: LIST
4310: LIST
4311: PUSH
4312: LD_INT 134
4314: PUSH
4315: LD_INT 98
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: PUSH
4322: LD_INT 159
4324: PUSH
4325: LD_INT 113
4327: PUSH
4328: EMPTY
4329: LIST
4330: LIST
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: LIST
4336: PUSH
4337: EMPTY
4338: LIST
4339: LIST
4340: LIST
4341: LIST
4342: ST_TO_ADDR
// for i = 1 to Difficulty - 1 do
4343: LD_ADDR_VAR 0 2
4347: PUSH
4348: DOUBLE
4349: LD_INT 1
4351: DEC
4352: ST_TO_ADDR
4353: LD_OWVAR 67
4357: PUSH
4358: LD_INT 1
4360: MINUS
4361: PUSH
4362: FOR_TO
4363: IFFALSE 4396
// ru_produce_list := ru_produce_list ^ [ ru_medium_tracked , engine_combustion , control_manual , ru_gatling_gun ] ;
4365: LD_ADDR_EXP 51
4369: PUSH
4370: LD_EXP 51
4374: PUSH
4375: LD_INT 22
4377: PUSH
4378: LD_INT 1
4380: PUSH
4381: LD_INT 1
4383: PUSH
4384: LD_INT 43
4386: PUSH
4387: EMPTY
4388: LIST
4389: LIST
4390: LIST
4391: LIST
4392: ADD
4393: ST_TO_ADDR
4394: GO 4362
4396: POP
4397: POP
// end ;
4398: LD_VAR 0 1
4402: RET
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , filter ;
4403: LD_INT 22
4405: PUSH
4406: LD_INT 3
4408: PUSH
4409: EMPTY
4410: LIST
4411: LIST
4412: PUSH
4413: LD_INT 21
4415: PUSH
4416: LD_INT 2
4418: PUSH
4419: EMPTY
4420: LIST
4421: LIST
4422: PUSH
4423: EMPTY
4424: LIST
4425: LIST
4426: PPUSH
4427: CALL_OW 69
4431: IFFALSE 4525
4433: GO 4435
4435: DISABLE
4436: LD_INT 0
4438: PPUSH
4439: PPUSH
// begin enable ;
4440: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) ;
4441: LD_ADDR_VAR 0 2
4445: PUSH
4446: LD_INT 22
4448: PUSH
4449: LD_INT 3
4451: PUSH
4452: EMPTY
4453: LIST
4454: LIST
4455: PUSH
4456: LD_INT 21
4458: PUSH
4459: LD_INT 2
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PUSH
4466: EMPTY
4467: LIST
4468: LIST
4469: PPUSH
4470: CALL_OW 69
4474: ST_TO_ADDR
// if filter then
4475: LD_VAR 0 2
4479: IFFALSE 4525
// for i in filter do
4481: LD_ADDR_VAR 0 1
4485: PUSH
4486: LD_VAR 0 2
4490: PUSH
4491: FOR_IN
4492: IFFALSE 4523
// if GetFuel ( i ) < 20 then
4494: LD_VAR 0 1
4498: PPUSH
4499: CALL_OW 261
4503: PUSH
4504: LD_INT 20
4506: LESS
4507: IFFALSE 4521
// SetFuel ( i , 20 ) ;
4509: LD_VAR 0 1
4513: PPUSH
4514: LD_INT 20
4516: PPUSH
4517: CALL_OW 240
4521: GO 4491
4523: POP
4524: POP
// end ;
4525: PPOPN 2
4527: END
// every 0 0$01 trigger ru_produce_list do var i , fac , can_produce ;
4528: LD_EXP 51
4532: IFFALSE 4751
4534: GO 4536
4536: DISABLE
4537: LD_INT 0
4539: PPUSH
4540: PPUSH
4541: PPUSH
// begin enable ;
4542: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4543: LD_ADDR_VAR 0 2
4547: PUSH
4548: LD_INT 22
4550: PUSH
4551: LD_INT 3
4553: PUSH
4554: EMPTY
4555: LIST
4556: LIST
4557: PUSH
4558: LD_INT 30
4560: PUSH
4561: LD_INT 3
4563: PUSH
4564: EMPTY
4565: LIST
4566: LIST
4567: PUSH
4568: EMPTY
4569: LIST
4570: LIST
4571: PPUSH
4572: CALL_OW 69
4576: ST_TO_ADDR
// can_produce := [ ] ;
4577: LD_ADDR_VAR 0 3
4581: PUSH
4582: EMPTY
4583: ST_TO_ADDR
// if not fac then
4584: LD_VAR 0 2
4588: NOT
4589: IFFALSE 4594
// begin disable ;
4591: DISABLE
// exit ;
4592: GO 4751
// end ; for i in fac do
4594: LD_ADDR_VAR 0 1
4598: PUSH
4599: LD_VAR 0 2
4603: PUSH
4604: FOR_IN
4605: IFFALSE 4643
// if UnitsInside ( i ) then
4607: LD_VAR 0 1
4611: PPUSH
4612: CALL_OW 313
4616: IFFALSE 4641
// can_produce := Insert ( can_produce , 1 , i ) ;
4618: LD_ADDR_VAR 0 3
4622: PUSH
4623: LD_VAR 0 3
4627: PPUSH
4628: LD_INT 1
4630: PPUSH
4631: LD_VAR 0 1
4635: PPUSH
4636: CALL_OW 2
4640: ST_TO_ADDR
4641: GO 4604
4643: POP
4644: POP
// if not can_produce then
4645: LD_VAR 0 3
4649: NOT
4650: IFFALSE 4654
// exit ;
4652: GO 4751
// ComConstruct ( can_produce [ rand ( 1 , can_produce ) ] , ru_produce_list [ 1 ] , ru_produce_list [ 2 ] , ru_produce_list [ 3 ] , ru_produce_list [ 4 ] ) ;
4654: LD_VAR 0 3
4658: PUSH
4659: LD_INT 1
4661: PPUSH
4662: LD_VAR 0 3
4666: PPUSH
4667: CALL_OW 12
4671: ARRAY
4672: PPUSH
4673: LD_EXP 51
4677: PUSH
4678: LD_INT 1
4680: ARRAY
4681: PPUSH
4682: LD_EXP 51
4686: PUSH
4687: LD_INT 2
4689: ARRAY
4690: PPUSH
4691: LD_EXP 51
4695: PUSH
4696: LD_INT 3
4698: ARRAY
4699: PPUSH
4700: LD_EXP 51
4704: PUSH
4705: LD_INT 4
4707: ARRAY
4708: PPUSH
4709: CALL_OW 125
// for i = 1 to 4 do
4713: LD_ADDR_VAR 0 1
4717: PUSH
4718: DOUBLE
4719: LD_INT 1
4721: DEC
4722: ST_TO_ADDR
4723: LD_INT 4
4725: PUSH
4726: FOR_TO
4727: IFFALSE 4749
// ru_produce_list := Delete ( ru_produce_list , 1 ) ;
4729: LD_ADDR_EXP 51
4733: PUSH
4734: LD_EXP 51
4738: PPUSH
4739: LD_INT 1
4741: PPUSH
4742: CALL_OW 3
4746: ST_TO_ADDR
4747: GO 4726
4749: POP
4750: POP
// end ;
4751: PPOPN 3
4753: END
// export function AddMoreTanks ( ) ; var i , veh ; begin
4754: LD_INT 0
4756: PPUSH
4757: PPUSH
4758: PPUSH
// for i = 1 to 6 do
4759: LD_ADDR_VAR 0 2
4763: PUSH
4764: DOUBLE
4765: LD_INT 1
4767: DEC
4768: ST_TO_ADDR
4769: LD_INT 6
4771: PUSH
4772: FOR_TO
4773: IFFALSE 4922
// begin PrepareHuman ( false , 3 , 3 ) ;
4775: LD_INT 0
4777: PPUSH
4778: LD_INT 3
4780: PPUSH
4781: LD_INT 3
4783: PPUSH
4784: CALL_OW 380
// veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 2 ) ] , 70 ) ;
4788: LD_ADDR_VAR 0 3
4792: PUSH
4793: LD_INT 3
4795: PPUSH
4796: LD_INT 3
4798: PPUSH
4799: LD_INT 22
4801: PPUSH
4802: LD_INT 1
4804: PPUSH
4805: LD_INT 1
4807: PPUSH
4808: LD_INT 43
4810: PUSH
4811: LD_INT 42
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 1
4820: PPUSH
4821: LD_INT 2
4823: PPUSH
4824: CALL_OW 12
4828: ARRAY
4829: PPUSH
4830: LD_INT 70
4832: PPUSH
4833: CALL 516 0 7
4837: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4838: LD_VAR 0 3
4842: PPUSH
4843: LD_INT 4
4845: PPUSH
4846: CALL_OW 233
// PlaceUnitXY ( veh , 229 , 44 , false ) ;
4850: LD_VAR 0 3
4854: PPUSH
4855: LD_INT 229
4857: PPUSH
4858: LD_INT 44
4860: PPUSH
4861: LD_INT 0
4863: PPUSH
4864: CALL_OW 48
// PlaceHumanInUnit ( CreateHuman , veh ) ;
4868: CALL_OW 44
4872: PPUSH
4873: LD_VAR 0 3
4877: PPUSH
4878: CALL_OW 52
// ru_vehicles := ru_vehicles ^ veh ;
4882: LD_ADDR_EXP 50
4886: PUSH
4887: LD_EXP 50
4891: PUSH
4892: LD_VAR 0 3
4896: ADD
4897: ST_TO_ADDR
// ComMoveXY ( veh , 218 , 40 ) ;
4898: LD_VAR 0 3
4902: PPUSH
4903: LD_INT 218
4905: PPUSH
4906: LD_INT 40
4908: PPUSH
4909: CALL_OW 111
// Wait ( 0 0$02 ) ;
4913: LD_INT 70
4915: PPUSH
4916: CALL_OW 67
// end ;
4920: GO 4772
4922: POP
4923: POP
// end ; end_of_file
4924: LD_VAR 0 1
4928: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
4929: LD_INT 0
4931: PPUSH
4932: PPUSH
4933: PPUSH
4934: PPUSH
4935: PPUSH
4936: PPUSH
4937: PPUSH
// InGameOn ;
4938: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
4942: LD_EXP 31
4946: PPUSH
4947: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
4951: LD_EXP 31
4955: PPUSH
4956: LD_EXP 38
4960: PPUSH
4961: CALL_OW 119
// if Bierezov then
4965: LD_EXP 39
4969: IFFALSE 4985
// ComTurnUnit ( Bierezov , Cornel ) ;
4971: LD_EXP 39
4975: PPUSH
4976: LD_EXP 38
4980: PPUSH
4981: CALL_OW 119
// for i in jmm_units do
4985: LD_ADDR_VAR 0 2
4989: PUSH
4990: LD_EXP 2
4994: PUSH
4995: FOR_IN
4996: IFFALSE 5014
// ComTurnUnit ( i , Cornel ) ;
4998: LD_VAR 0 2
5002: PPUSH
5003: LD_EXP 38
5007: PPUSH
5008: CALL_OW 119
5012: GO 4995
5014: POP
5015: POP
// units := cornel_units union Cornel ;
5016: LD_ADDR_VAR 0 3
5020: PUSH
5021: LD_EXP 4
5025: PUSH
5026: LD_EXP 38
5030: UNION
5031: ST_TO_ADDR
// repeat wait ( 1 ) ;
5032: LD_INT 1
5034: PPUSH
5035: CALL_OW 67
// for i in units do
5039: LD_ADDR_VAR 0 2
5043: PUSH
5044: LD_VAR 0 3
5048: PUSH
5049: FOR_IN
5050: IFFALSE 5083
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
5052: LD_VAR 0 2
5056: PPUSH
5057: LD_EXP 31
5061: PPUSH
5062: CALL_OW 250
5066: PPUSH
5067: LD_EXP 31
5071: PPUSH
5072: CALL_OW 251
5076: PPUSH
5077: CALL_OW 111
5081: GO 5049
5083: POP
5084: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
5085: LD_VAR 0 3
5089: PPUSH
5090: LD_INT 92
5092: PUSH
5093: LD_EXP 31
5097: PPUSH
5098: CALL_OW 250
5102: PUSH
5103: LD_EXP 31
5107: PPUSH
5108: CALL_OW 251
5112: PUSH
5113: LD_INT 10
5115: PUSH
5116: EMPTY
5117: LIST
5118: LIST
5119: LIST
5120: LIST
5121: PPUSH
5122: CALL_OW 72
5126: PUSH
5127: LD_VAR 0 3
5131: EQUAL
5132: IFFALSE 5032
// for i in units do
5134: LD_ADDR_VAR 0 2
5138: PUSH
5139: LD_VAR 0 3
5143: PUSH
5144: FOR_IN
5145: IFFALSE 5163
// ComTurnUnit ( i , JMM ) ;
5147: LD_VAR 0 2
5151: PPUSH
5152: LD_EXP 31
5156: PPUSH
5157: CALL_OW 119
5161: GO 5144
5163: POP
5164: POP
// ComTurnUnit ( Cornel , JMM ) ;
5165: LD_EXP 38
5169: PPUSH
5170: LD_EXP 31
5174: PPUSH
5175: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
5179: LD_EXP 31
5183: PPUSH
5184: LD_STRING D1-JMM-1
5186: PPUSH
5187: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
5191: LD_EXP 38
5195: PPUSH
5196: LD_STRING D1-Corn-1
5198: PPUSH
5199: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
5203: LD_EXP 31
5207: PPUSH
5208: LD_EXP 38
5212: PPUSH
5213: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
5217: LD_EXP 38
5221: PPUSH
5222: LD_EXP 31
5226: PPUSH
5227: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5231: LD_INT 35
5233: PPUSH
5234: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
5238: LD_EXP 31
5242: PPUSH
5243: LD_EXP 38
5247: PPUSH
5248: CALL_OW 296
5252: PUSH
5253: LD_INT 6
5255: LESS
5256: IFFALSE 5231
// ChangeSideFog ( 4 , 1 ) ;
5258: LD_INT 4
5260: PPUSH
5261: LD_INT 1
5263: PPUSH
5264: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
5268: LD_EXP 31
5272: PPUSH
5273: LD_EXP 38
5277: PPUSH
5278: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5282: LD_EXP 38
5286: PPUSH
5287: LD_EXP 31
5291: PPUSH
5292: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
5296: LD_EXP 31
5300: PPUSH
5301: LD_STRING D1-JMM-2
5303: PPUSH
5304: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
5308: LD_EXP 31
5312: PPUSH
5313: LD_STRING D1-JMM-2a
5315: PPUSH
5316: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
5320: LD_EXP 38
5324: PPUSH
5325: LD_STRING D1-Corn-2
5327: PPUSH
5328: CALL_OW 88
// if bierezov_exist or debug then
5332: LD_EXP 5
5336: PUSH
5337: LD_EXP 1
5341: OR
5342: IFFALSE 5583
// begin ComTurnUnit ( Cornel , Bierezov ) ;
5344: LD_EXP 38
5348: PPUSH
5349: LD_EXP 39
5353: PPUSH
5354: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
5358: LD_INT 10
5360: PPUSH
5361: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
5365: LD_EXP 38
5369: PPUSH
5370: LD_STRING D1a-Corn-1
5372: PPUSH
5373: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
5377: LD_EXP 31
5381: PPUSH
5382: LD_EXP 39
5386: PPUSH
5387: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
5391: LD_EXP 39
5395: PPUSH
5396: LD_EXP 31
5400: PPUSH
5401: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
5405: LD_EXP 31
5409: PPUSH
5410: LD_STRING D1a-JMM-1
5412: PPUSH
5413: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
5417: LD_EXP 31
5421: PPUSH
5422: LD_EXP 38
5426: PPUSH
5427: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
5431: LD_EXP 38
5435: PPUSH
5436: LD_EXP 31
5440: PPUSH
5441: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
5445: LD_EXP 38
5449: PPUSH
5450: LD_STRING D1a-Corn-2
5452: PPUSH
5453: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
5457: LD_EXP 31
5461: PPUSH
5462: LD_STRING D1a-JMM-2
5464: PPUSH
5465: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
5469: LD_EXP 38
5473: PPUSH
5474: LD_STRING D1a-Corn-3
5476: PPUSH
5477: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
5481: LD_EXP 31
5485: PPUSH
5486: LD_STRING D1a-JMM-3
5488: PPUSH
5489: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
5493: LD_EXP 38
5497: PPUSH
5498: LD_STRING D1a-Corn-4
5500: PPUSH
5501: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
5505: LD_EXP 31
5509: PPUSH
5510: LD_STRING D1a-JMM-4
5512: PPUSH
5513: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
5517: LD_EXP 38
5521: PPUSH
5522: LD_STRING D1a-Corn-5
5524: PPUSH
5525: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
5529: LD_EXP 39
5533: PPUSH
5534: LD_EXP 38
5538: PPUSH
5539: CALL_OW 250
5543: PPUSH
5544: LD_EXP 38
5548: PPUSH
5549: CALL_OW 251
5553: PUSH
5554: LD_INT 2
5556: MINUS
5557: PPUSH
5558: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
5562: LD_EXP 39
5566: PPUSH
5567: LD_EXP 38
5571: PPUSH
5572: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
5576: LD_INT 10
5578: PPUSH
5579: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
5583: LD_EXP 31
5587: PPUSH
5588: LD_STRING D1b-JMM-1
5590: PPUSH
5591: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
5595: LD_EXP 38
5599: PPUSH
5600: LD_STRING D1b-Corn-1
5602: PPUSH
5603: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
5607: LD_EXP 31
5611: PPUSH
5612: LD_STRING D1b-JMM-2
5614: PPUSH
5615: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
5619: LD_EXP 38
5623: PPUSH
5624: LD_STRING D1b-Corn-2
5626: PPUSH
5627: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
5631: LD_EXP 31
5635: PPUSH
5636: LD_STRING D1b-JMM-3
5638: PPUSH
5639: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
5643: LD_INT 10
5645: PPUSH
5646: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
5650: LD_EXP 40
5654: PPUSH
5655: LD_STRING D1b-Pow-3
5657: PPUSH
5658: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
5662: LD_EXP 31
5666: PPUSH
5667: LD_STRING D1b-JMM-4
5669: PPUSH
5670: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
5674: LD_EXP 38
5678: PPUSH
5679: LD_STRING D1b-Corn-4
5681: PPUSH
5682: CALL_OW 88
// if Khatam then
5686: LD_EXP 35
5690: IFFALSE 5706
// Say ( Khatam , D1b-Khat-4 ) else
5692: LD_EXP 35
5696: PPUSH
5697: LD_STRING D1b-Khat-4
5699: PPUSH
5700: CALL_OW 88
5704: GO 5742
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
5706: LD_EXP 4
5710: PPUSH
5711: LD_INT 26
5713: PUSH
5714: LD_INT 1
5716: PUSH
5717: EMPTY
5718: LIST
5719: LIST
5720: PPUSH
5721: CALL_OW 72
5725: PUSH
5726: LD_EXP 38
5730: PUSH
5731: EMPTY
5732: LIST
5733: DIFF
5734: PPUSH
5735: LD_STRING D1b-Sol1-4
5737: PPUSH
5738: CALL 604 0 2
// if Cyrus then
5742: LD_EXP 33
5746: IFFALSE 5760
// Say ( Cyrus , D1b-Cyrus-4 ) ;
5748: LD_EXP 33
5752: PPUSH
5753: LD_STRING D1b-Cyrus-4
5755: PPUSH
5756: CALL_OW 88
// if Lisa then
5760: LD_EXP 34
5764: IFFALSE 5822
// begin Say ( Lisa , D1b-Lisa-4 ) ;
5766: LD_EXP 34
5770: PPUSH
5771: LD_STRING D1b-Lisa-4
5773: PPUSH
5774: CALL_OW 88
// if Cyrus then
5778: LD_EXP 33
5782: IFFALSE 5822
// begin if not IsInUnit ( Cyrus ) then
5784: LD_EXP 33
5788: PPUSH
5789: CALL_OW 310
5793: NOT
5794: IFFALSE 5810
// ComTurnUnit ( Cyrus , Lisa ) ;
5796: LD_EXP 33
5800: PPUSH
5801: LD_EXP 34
5805: PPUSH
5806: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
5810: LD_EXP 33
5814: PPUSH
5815: LD_STRING D1b-Cyrus-5
5817: PPUSH
5818: CALL_OW 88
// end ; end ; SelectGroup ;
5822: CALL 2557 0 0
// Say ( JMM , D1d-JMM-1 ) ;
5826: LD_EXP 31
5830: PPUSH
5831: LD_STRING D1d-JMM-1
5833: PPUSH
5834: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
5838: LD_EXP 38
5842: PPUSH
5843: LD_STRING D1d-Corn-1
5845: PPUSH
5846: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
5850: LD_ADDR_VAR 0 2
5854: PUSH
5855: LD_EXP 2
5859: PUSH
5860: LD_EXP 4
5864: ADD
5865: PUSH
5866: LD_EXP 31
5870: ADD
5871: PUSH
5872: FOR_IN
5873: IFFALSE 5886
// ComHold ( i ) ;
5875: LD_VAR 0 2
5879: PPUSH
5880: CALL_OW 140
5884: GO 5872
5886: POP
5887: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
5888: LD_ADDR_VAR 0 4
5892: PUSH
5893: LD_INT 22
5895: PUSH
5896: LD_INT 1
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: PUSH
5903: LD_INT 21
5905: PUSH
5906: LD_INT 2
5908: PUSH
5909: EMPTY
5910: LIST
5911: LIST
5912: PUSH
5913: EMPTY
5914: LIST
5915: LIST
5916: PPUSH
5917: CALL_OW 69
5921: ST_TO_ADDR
// if vehicles then
5922: LD_VAR 0 4
5926: IFFALSE 6264
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
5928: LD_EXP 4
5932: PPUSH
5933: LD_INT 55
5935: PUSH
5936: EMPTY
5937: LIST
5938: PPUSH
5939: CALL_OW 72
5943: IFFALSE 5982
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
5945: LD_ADDR_VAR 0 2
5949: PUSH
5950: LD_EXP 4
5954: PPUSH
5955: LD_INT 55
5957: PUSH
5958: EMPTY
5959: LIST
5960: PPUSH
5961: CALL_OW 72
5965: PUSH
5966: FOR_IN
5967: IFFALSE 5980
// ComExitVehicle ( i ) ;
5969: LD_VAR 0 2
5973: PPUSH
5974: CALL_OW 121
5978: GO 5966
5980: POP
5981: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
5982: LD_ADDR_VAR 0 5
5986: PUSH
5987: LD_VAR 0 4
5991: PPUSH
5992: LD_INT 34
5994: PUSH
5995: LD_INT 51
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: PPUSH
6002: CALL_OW 72
6006: ST_TO_ADDR
// if cargos then
6007: LD_VAR 0 5
6011: IFFALSE 6194
// begin vehicles := cargos ;
6013: LD_ADDR_VAR 0 4
6017: PUSH
6018: LD_VAR 0 5
6022: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
6023: LD_ADDR_VAR 0 6
6027: PUSH
6028: LD_STRING 02_resources_4
6030: PPUSH
6031: LD_INT 0
6033: PPUSH
6034: CALL_OW 30
6038: ST_TO_ADDR
// if debug and not resources then
6039: LD_EXP 1
6043: PUSH
6044: LD_VAR 0 6
6048: NOT
6049: AND
6050: IFFALSE 6060
// resources := 160 ;
6052: LD_ADDR_VAR 0 6
6056: PUSH
6057: LD_INT 160
6059: ST_TO_ADDR
// if resources mod 10 then
6060: LD_VAR 0 6
6064: PUSH
6065: LD_INT 10
6067: MOD
6068: IFFALSE 6090
// resources := resources - resources mod 10 ;
6070: LD_ADDR_VAR 0 6
6074: PUSH
6075: LD_VAR 0 6
6079: PUSH
6080: LD_VAR 0 6
6084: PUSH
6085: LD_INT 10
6087: MOD
6088: MINUS
6089: ST_TO_ADDR
// if resources then
6090: LD_VAR 0 6
6094: IFFALSE 6194
// for i in cargos do
6096: LD_ADDR_VAR 0 2
6100: PUSH
6101: LD_VAR 0 5
6105: PUSH
6106: FOR_IN
6107: IFFALSE 6192
// begin if resources < 100 then
6109: LD_VAR 0 6
6113: PUSH
6114: LD_INT 100
6116: LESS
6117: IFFALSE 6139
// begin cargo := resources ;
6119: LD_ADDR_VAR 0 7
6123: PUSH
6124: LD_VAR 0 6
6128: ST_TO_ADDR
// resources := 0 ;
6129: LD_ADDR_VAR 0 6
6133: PUSH
6134: LD_INT 0
6136: ST_TO_ADDR
// end else
6137: GO 6161
// begin cargo := 100 ;
6139: LD_ADDR_VAR 0 7
6143: PUSH
6144: LD_INT 100
6146: ST_TO_ADDR
// resources := resources - 100 ;
6147: LD_ADDR_VAR 0 6
6151: PUSH
6152: LD_VAR 0 6
6156: PUSH
6157: LD_INT 100
6159: MINUS
6160: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
6161: LD_VAR 0 2
6165: PPUSH
6166: LD_INT 1
6168: PPUSH
6169: LD_VAR 0 7
6173: PPUSH
6174: CALL_OW 290
// if resources = 0 then
6178: LD_VAR 0 6
6182: PUSH
6183: LD_INT 0
6185: EQUAL
6186: IFFALSE 6190
// break ;
6188: GO 6192
// end ;
6190: GO 6106
6192: POP
6193: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
6194: LD_VAR 0 4
6198: PUSH
6199: LD_INT 1
6201: ARRAY
6202: PPUSH
6203: CALL_OW 311
6207: PPUSH
6208: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
6212: LD_VAR 0 4
6216: PUSH
6217: LD_INT 1
6219: ARRAY
6220: PPUSH
6221: LD_INT 4
6223: PPUSH
6224: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
6228: LD_EXP 38
6232: PPUSH
6233: LD_VAR 0 4
6237: PUSH
6238: LD_INT 1
6240: ARRAY
6241: PPUSH
6242: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
6246: LD_INT 35
6248: PPUSH
6249: CALL_OW 67
// until IsInUnit ( Cornel ) ;
6253: LD_EXP 38
6257: PPUSH
6258: CALL_OW 310
6262: IFFALSE 6246
// end ; InGameOff ;
6264: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6268: LD_STRING M1
6270: PPUSH
6271: CALL_OW 337
// SaveForQuickRestart ;
6275: CALL_OW 22
// cornel_active := true ;
6279: LD_ADDR_EXP 6
6283: PUSH
6284: LD_INT 1
6286: ST_TO_ADDR
// end ;
6287: LD_VAR 0 1
6291: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
6292: LD_EXP 31
6296: PPUSH
6297: LD_EXP 41
6301: PPUSH
6302: CALL_OW 296
6306: PUSH
6307: LD_INT 10
6309: LESS
6310: IFFALSE 7425
6312: GO 6314
6314: DISABLE
6315: LD_INT 0
6317: PPUSH
6318: PPUSH
6319: PPUSH
6320: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
6321: LD_ADDR_VAR 0 2
6325: PUSH
6326: LD_INT 89
6328: PUSH
6329: LD_INT 34
6331: PUSH
6332: EMPTY
6333: LIST
6334: LIST
6335: PUSH
6336: LD_INT 138
6338: PUSH
6339: LD_INT 63
6341: PUSH
6342: EMPTY
6343: LIST
6344: LIST
6345: PUSH
6346: LD_INT 196
6348: PUSH
6349: LD_INT 84
6351: PUSH
6352: EMPTY
6353: LIST
6354: LIST
6355: PUSH
6356: LD_INT 135
6358: PUSH
6359: LD_INT 52
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: PUSH
6366: LD_INT 103
6368: PUSH
6369: LD_INT 39
6371: PUSH
6372: EMPTY
6373: LIST
6374: LIST
6375: PUSH
6376: LD_INT 58
6378: PUSH
6379: LD_INT 30
6381: PUSH
6382: EMPTY
6383: LIST
6384: LIST
6385: PUSH
6386: LD_INT 38
6388: PUSH
6389: LD_INT 51
6391: PUSH
6392: EMPTY
6393: LIST
6394: LIST
6395: PUSH
6396: EMPTY
6397: LIST
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: LIST
6403: LIST
6404: ST_TO_ADDR
// InGameOn ;
6405: CALL_OW 8
// if jmm_units then
6409: LD_EXP 2
6413: IFFALSE 6477
// for i in jmm_units do
6415: LD_ADDR_VAR 0 1
6419: PUSH
6420: LD_EXP 2
6424: PUSH
6425: FOR_IN
6426: IFFALSE 6475
// begin if GetDistUnits ( i , JMM ) < 10 then
6428: LD_VAR 0 1
6432: PPUSH
6433: LD_EXP 31
6437: PPUSH
6438: CALL_OW 296
6442: PUSH
6443: LD_INT 10
6445: LESS
6446: IFFALSE 6464
// ComTurnUnit ( i , JMM ) else
6448: LD_VAR 0 1
6452: PPUSH
6453: LD_EXP 31
6457: PPUSH
6458: CALL_OW 119
6462: GO 6473
// ComHold ( i ) ;
6464: LD_VAR 0 1
6468: PPUSH
6469: CALL_OW 140
// end ;
6473: GO 6425
6475: POP
6476: POP
// ComMoveUnit ( JMM , Lynch ) ;
6477: LD_EXP 31
6481: PPUSH
6482: LD_EXP 41
6486: PPUSH
6487: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
6491: LD_INT 35
6493: PPUSH
6494: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
6498: LD_EXP 31
6502: PPUSH
6503: LD_EXP 41
6507: PPUSH
6508: CALL_OW 296
6512: PUSH
6513: LD_INT 6
6515: LESS
6516: IFFALSE 6491
// ComTurnUnit ( JMM , Lynch ) ;
6518: LD_EXP 31
6522: PPUSH
6523: LD_EXP 41
6527: PPUSH
6528: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
6532: LD_ADDR_VAR 0 1
6536: PUSH
6537: LD_EXP 41
6541: PUSH
6542: LD_EXP 42
6546: PUSH
6547: LD_EXP 43
6551: PUSH
6552: LD_EXP 44
6556: PUSH
6557: EMPTY
6558: LIST
6559: LIST
6560: LIST
6561: LIST
6562: PUSH
6563: FOR_IN
6564: IFFALSE 6582
// ComTurnUnit ( i , JMM ) ;
6566: LD_VAR 0 1
6570: PPUSH
6571: LD_EXP 31
6575: PPUSH
6576: CALL_OW 119
6580: GO 6563
6582: POP
6583: POP
// Wait ( 0 0$0.3 ) ;
6584: LD_INT 10
6586: PPUSH
6587: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
6591: LD_EXP 31
6595: PPUSH
6596: LD_STRING D2-JMM-1
6598: PPUSH
6599: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
6603: LD_EXP 41
6607: PPUSH
6608: LD_STRING D2-Sol1-1
6610: PPUSH
6611: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
6615: LD_EXP 31
6619: PPUSH
6620: LD_STRING D2-JMM-2
6622: PPUSH
6623: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
6627: LD_EXP 41
6631: PPUSH
6632: LD_STRING D2-Sol1-2
6634: PPUSH
6635: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
6639: LD_EXP 31
6643: PPUSH
6644: LD_STRING D2-JMM-3
6646: PPUSH
6647: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
6651: LD_EXP 41
6655: PPUSH
6656: LD_STRING D2-Sol1-3
6658: PPUSH
6659: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
6663: LD_ADDR_VAR 0 1
6667: PUSH
6668: LD_INT 22
6670: PUSH
6671: LD_INT 8
6673: PUSH
6674: EMPTY
6675: LIST
6676: LIST
6677: PPUSH
6678: CALL_OW 69
6682: PUSH
6683: FOR_IN
6684: IFFALSE 6700
// SetSide ( i , 1 ) ;
6686: LD_VAR 0 1
6690: PPUSH
6691: LD_INT 1
6693: PPUSH
6694: CALL_OW 235
6698: GO 6683
6700: POP
6701: POP
// Say ( JMM , D2-JMM-4 ) ;
6702: LD_EXP 31
6706: PPUSH
6707: LD_STRING D2-JMM-4
6709: PPUSH
6710: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
6714: LD_INT 1
6716: PPUSH
6717: LD_INT 5
6719: PPUSH
6720: CALL_OW 332
// for i = 1 to points do
6724: LD_ADDR_VAR 0 1
6728: PUSH
6729: DOUBLE
6730: LD_INT 1
6732: DEC
6733: ST_TO_ADDR
6734: LD_VAR 0 2
6738: PUSH
6739: FOR_TO
6740: IFFALSE 6915
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6742: LD_VAR 0 2
6746: PUSH
6747: LD_VAR 0 1
6751: ARRAY
6752: PUSH
6753: LD_INT 1
6755: ARRAY
6756: PPUSH
6757: LD_VAR 0 2
6761: PUSH
6762: LD_VAR 0 1
6766: ARRAY
6767: PUSH
6768: LD_INT 2
6770: ARRAY
6771: PPUSH
6772: CALL_OW 84
// if i = 1 then
6776: LD_VAR 0 1
6780: PUSH
6781: LD_INT 1
6783: EQUAL
6784: IFFALSE 6798
// Say ( Lynch , D2-Sol1-4 ) ;
6786: LD_EXP 41
6790: PPUSH
6791: LD_STRING D2-Sol1-4
6793: PPUSH
6794: CALL_OW 88
// if i = 2 then
6798: LD_VAR 0 1
6802: PUSH
6803: LD_INT 2
6805: EQUAL
6806: IFFALSE 6820
// Say ( JMM , D2-JMM-5 ) ;
6808: LD_EXP 31
6812: PPUSH
6813: LD_STRING D2-JMM-5
6815: PPUSH
6816: CALL_OW 88
// if i = 4 then
6820: LD_VAR 0 1
6824: PUSH
6825: LD_INT 4
6827: EQUAL
6828: IFFALSE 6852
// begin RevealFogArea ( 1 , troopsArea ) ;
6830: LD_INT 1
6832: PPUSH
6833: LD_INT 6
6835: PPUSH
6836: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
6840: LD_EXP 41
6844: PPUSH
6845: LD_STRING D2-Sol1-5
6847: PPUSH
6848: CALL_OW 88
// end ; if i = 5 then
6852: LD_VAR 0 1
6856: PUSH
6857: LD_INT 5
6859: EQUAL
6860: IFFALSE 6874
// Say ( JMM , D2-JMM-6 ) ;
6862: LD_EXP 31
6866: PPUSH
6867: LD_STRING D2-JMM-6
6869: PPUSH
6870: CALL_OW 88
// if i = 7 then
6874: LD_VAR 0 1
6878: PUSH
6879: LD_INT 7
6881: EQUAL
6882: IFFALSE 6906
// begin RevealFogArea ( 1 , forestArea ) ;
6884: LD_INT 1
6886: PPUSH
6887: LD_INT 7
6889: PPUSH
6890: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
6894: LD_EXP 41
6898: PPUSH
6899: LD_STRING D2-Sol1-6
6901: PPUSH
6902: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
6906: LD_INT 46
6908: PPUSH
6909: CALL_OW 67
// end ;
6913: GO 6739
6915: POP
6916: POP
// CenterNowOnUnits ( JMM ) ;
6917: LD_EXP 31
6921: PPUSH
6922: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
6926: LD_EXP 31
6930: PPUSH
6931: LD_STRING D2-JMM-7
6933: PPUSH
6934: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
6938: LD_EXP 41
6942: PPUSH
6943: LD_STRING D2-Sol1-7
6945: PPUSH
6946: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
6950: LD_EXP 31
6954: PPUSH
6955: LD_STRING D2-JMM-8
6957: PPUSH
6958: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
6962: LD_ADDR_VAR 0 4
6966: PUSH
6967: LD_INT 22
6969: PUSH
6970: LD_INT 1
6972: PUSH
6973: EMPTY
6974: LIST
6975: LIST
6976: PUSH
6977: LD_INT 30
6979: PUSH
6980: LD_INT 31
6982: PUSH
6983: EMPTY
6984: LIST
6985: LIST
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: PPUSH
6991: CALL_OW 69
6995: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
6996: LD_EXP 41
7000: PPUSH
7001: LD_VAR 0 4
7005: PUSH
7006: LD_INT 1
7008: ARRAY
7009: PPUSH
7010: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
7014: LD_ADDR_VAR 0 3
7018: PUSH
7019: LD_EXP 2
7023: PPUSH
7024: LD_INT 25
7026: PUSH
7027: LD_INT 1
7029: PUSH
7030: EMPTY
7031: LIST
7032: LIST
7033: PPUSH
7034: CALL_OW 72
7038: PPUSH
7039: LD_EXP 31
7043: PPUSH
7044: CALL_OW 74
7048: ST_TO_ADDR
// if sol then
7049: LD_VAR 0 3
7053: IFFALSE 7093
// if GetDistUnits ( JMM , sol ) < 10 then
7055: LD_EXP 31
7059: PPUSH
7060: LD_VAR 0 3
7064: PPUSH
7065: CALL_OW 296
7069: PUSH
7070: LD_INT 10
7072: LESS
7073: IFFALSE 7093
// ComEnterUnit ( sol , buns [ 2 ] ) ;
7075: LD_VAR 0 3
7079: PPUSH
7080: LD_VAR 0 4
7084: PUSH
7085: LD_INT 2
7087: ARRAY
7088: PPUSH
7089: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
7093: LD_INT 10
7095: PPUSH
7096: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
7100: LD_EXP 31
7104: PPUSH
7105: LD_INT 65
7107: PPUSH
7108: LD_INT 101
7110: PPUSH
7111: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
7115: LD_EXP 31
7119: PPUSH
7120: LD_INT 63
7122: PPUSH
7123: LD_INT 100
7125: PPUSH
7126: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
7130: LD_INT 35
7132: PPUSH
7133: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
7137: LD_EXP 31
7141: PPUSH
7142: LD_INT 65
7144: PPUSH
7145: LD_INT 101
7147: PPUSH
7148: CALL_OW 307
7152: IFFALSE 7130
// Say ( JMM , D2a-JMM-1 ) ;
7154: LD_EXP 31
7158: PPUSH
7159: LD_STRING D2a-JMM-1
7161: PPUSH
7162: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
7166: LD_EXP 42
7170: PPUSH
7171: LD_INT 66
7173: PPUSH
7174: LD_INT 103
7176: PPUSH
7177: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
7181: LD_INT 35
7183: PPUSH
7184: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
7188: LD_EXP 42
7192: PPUSH
7193: LD_INT 66
7195: PPUSH
7196: LD_INT 103
7198: PPUSH
7199: CALL_OW 307
7203: IFFALSE 7181
// ComTurnUnit ( Walker , JMM ) ;
7205: LD_EXP 42
7209: PPUSH
7210: LD_EXP 31
7214: PPUSH
7215: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
7219: LD_EXP 42
7223: PPUSH
7224: LD_STRING D2a-Sci1-1
7226: PPUSH
7227: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
7231: LD_EXP 31
7235: PPUSH
7236: LD_EXP 42
7240: PPUSH
7241: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
7245: LD_EXP 31
7249: PPUSH
7250: LD_STRING D2a-JMM-2
7252: PPUSH
7253: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
7257: LD_EXP 42
7261: PPUSH
7262: LD_STRING D2a-Sci1-2
7264: PPUSH
7265: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
7269: LD_EXP 31
7273: PPUSH
7274: LD_STRING D2a-JMM-3
7276: PPUSH
7277: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
7281: LD_EXP 42
7285: PPUSH
7286: LD_STRING D2a-Sci1-3
7288: PPUSH
7289: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
7293: LD_ADDR_EXP 2
7297: PUSH
7298: LD_EXP 2
7302: PUSH
7303: LD_EXP 41
7307: PUSH
7308: LD_EXP 42
7312: PUSH
7313: LD_EXP 43
7317: PUSH
7318: LD_EXP 44
7322: PUSH
7323: EMPTY
7324: LIST
7325: LIST
7326: LIST
7327: LIST
7328: ADD
7329: ST_TO_ADDR
// for i in jmm_units do
7330: LD_ADDR_VAR 0 1
7334: PUSH
7335: LD_EXP 2
7339: PUSH
7340: FOR_IN
7341: IFFALSE 7366
// if not IsInUnit ( i ) then
7343: LD_VAR 0 1
7347: PPUSH
7348: CALL_OW 310
7352: NOT
7353: IFFALSE 7364
// ComFree ( i ) ;
7355: LD_VAR 0 1
7359: PPUSH
7360: CALL_OW 139
7364: GO 7340
7366: POP
7367: POP
// InGameOff ;
7368: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
7372: LD_STRING MSolar1
7374: PPUSH
7375: CALL_OW 337
// jmm_on_west := true ;
7379: LD_ADDR_EXP 3
7383: PUSH
7384: LD_INT 1
7386: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
7387: LD_INT 1050
7389: PPUSH
7390: CALL_OW 67
// frank_can_return := true ;
7394: LD_ADDR_EXP 10
7398: PUSH
7399: LD_INT 1
7401: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
7402: LD_INT 6300
7404: PPUSH
7405: LD_INT 8400
7407: PPUSH
7408: CALL_OW 12
7412: PPUSH
7413: CALL_OW 67
// send_spec_patrol := true ;
7417: LD_ADDR_EXP 26
7421: PUSH
7422: LD_INT 1
7424: ST_TO_ADDR
// end ;
7425: PPOPN 4
7427: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
7428: LD_INT 22
7430: PUSH
7431: LD_INT 1
7433: PUSH
7434: EMPTY
7435: LIST
7436: LIST
7437: PUSH
7438: LD_INT 34
7440: PUSH
7441: LD_INT 51
7443: PUSH
7444: EMPTY
7445: LIST
7446: LIST
7447: PUSH
7448: LD_INT 92
7450: PUSH
7451: LD_INT 63
7453: PUSH
7454: LD_INT 100
7456: PUSH
7457: LD_INT 5
7459: PUSH
7460: EMPTY
7461: LIST
7462: LIST
7463: LIST
7464: LIST
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: LIST
7470: PUSH
7471: EMPTY
7472: LIST
7473: PPUSH
7474: CALL_OW 69
7478: PUSH
7479: LD_EXP 3
7483: NOT
7484: AND
7485: IFFALSE 7598
7487: GO 7489
7489: DISABLE
7490: LD_INT 0
7492: PPUSH
7493: PPUSH
// begin enable ;
7494: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
7495: LD_ADDR_VAR 0 2
7499: PUSH
7500: LD_INT 22
7502: PUSH
7503: LD_INT 1
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: PUSH
7510: LD_INT 34
7512: PUSH
7513: LD_INT 51
7515: PUSH
7516: EMPTY
7517: LIST
7518: LIST
7519: PUSH
7520: LD_INT 92
7522: PUSH
7523: LD_INT 63
7525: PUSH
7526: LD_INT 100
7528: PUSH
7529: LD_INT 5
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: LIST
7536: LIST
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: LIST
7542: PUSH
7543: EMPTY
7544: LIST
7545: PPUSH
7546: CALL_OW 69
7550: ST_TO_ADDR
// if not filter then
7551: LD_VAR 0 2
7555: NOT
7556: IFFALSE 7560
// exit ;
7558: GO 7598
// for i in filter do
7560: LD_ADDR_VAR 0 1
7564: PUSH
7565: LD_VAR 0 2
7569: PUSH
7570: FOR_IN
7571: IFFALSE 7596
// begin SetFuel ( i , 0 ) ;
7573: LD_VAR 0 1
7577: PPUSH
7578: LD_INT 0
7580: PPUSH
7581: CALL_OW 240
// ComStop ( i ) ;
7585: LD_VAR 0 1
7589: PPUSH
7590: CALL_OW 141
// end ;
7594: GO 7570
7596: POP
7597: POP
// end ;
7598: PPOPN 2
7600: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
7601: LD_EXP 26
7605: IFFALSE 8570
7607: GO 7609
7609: DISABLE
7610: LD_INT 0
7612: PPUSH
7613: PPUSH
7614: PPUSH
7615: PPUSH
7616: PPUSH
7617: PPUSH
7618: PPUSH
// begin if not ru_spec_patrol then
7619: LD_EXP 48
7623: NOT
7624: IFFALSE 7628
// exit ;
7626: GO 8570
// dead1 := false ;
7628: LD_ADDR_VAR 0 1
7632: PUSH
7633: LD_INT 0
7635: ST_TO_ADDR
// dead2 := false ;
7636: LD_ADDR_VAR 0 2
7640: PUSH
7641: LD_INT 0
7643: ST_TO_ADDR
// inarea1 := false ;
7644: LD_ADDR_VAR 0 3
7648: PUSH
7649: LD_INT 0
7651: ST_TO_ADDR
// inarea2 := false ;
7652: LD_ADDR_VAR 0 4
7656: PUSH
7657: LD_INT 0
7659: ST_TO_ADDR
// tmp := [ ] ;
7660: LD_ADDR_VAR 0 6
7664: PUSH
7665: EMPTY
7666: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
7667: LD_EXP 48
7671: PPUSH
7672: LD_INT 75
7674: PPUSH
7675: LD_INT 101
7677: PPUSH
7678: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
7682: LD_INT 35
7684: PPUSH
7685: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
7689: LD_INT 1
7691: PPUSH
7692: LD_EXP 48
7696: PUSH
7697: LD_INT 1
7699: ARRAY
7700: PPUSH
7701: CALL_OW 292
7705: IFFALSE 7682
// ComStop ( ru_spec_patrol ) ;
7707: LD_EXP 48
7711: PPUSH
7712: CALL_OW 141
// Wait ( 0 0$02 ) ;
7716: LD_INT 70
7718: PPUSH
7719: CALL_OW 67
// DialogueOn ;
7723: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
7727: LD_EXP 48
7731: PUSH
7732: LD_INT 1
7734: ARRAY
7735: PPUSH
7736: LD_STRING D8-Rus1-1
7738: PPUSH
7739: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
7743: LD_EXP 31
7747: PPUSH
7748: LD_STRING D8-JMM-1
7750: PPUSH
7751: CALL_OW 88
// DialogueOff ;
7755: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
7759: LD_EXP 48
7763: PPUSH
7764: LD_INT 13
7766: PPUSH
7767: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
7771: LD_INT 35
7773: PPUSH
7774: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
7778: LD_VAR 0 1
7782: NOT
7783: PUSH
7784: LD_EXP 48
7788: PUSH
7789: LD_INT 1
7791: ARRAY
7792: PPUSH
7793: CALL_OW 301
7797: AND
7798: IFFALSE 7808
// dead1 := true ;
7800: LD_ADDR_VAR 0 1
7804: PUSH
7805: LD_INT 1
7807: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
7808: LD_VAR 0 2
7812: NOT
7813: PUSH
7814: LD_EXP 48
7818: PUSH
7819: LD_INT 2
7821: ARRAY
7822: PPUSH
7823: CALL_OW 301
7827: AND
7828: IFFALSE 7838
// dead2 := true ;
7830: LD_ADDR_VAR 0 2
7834: PUSH
7835: LD_INT 1
7837: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
7838: LD_VAR 0 3
7842: NOT
7843: PUSH
7844: LD_EXP 48
7848: PUSH
7849: LD_INT 1
7851: ARRAY
7852: PPUSH
7853: LD_INT 14
7855: PPUSH
7856: CALL_OW 308
7860: AND
7861: IFFALSE 7871
// inarea1 := true ;
7863: LD_ADDR_VAR 0 3
7867: PUSH
7868: LD_INT 1
7870: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
7871: LD_VAR 0 4
7875: NOT
7876: PUSH
7877: LD_EXP 48
7881: PUSH
7882: LD_INT 2
7884: ARRAY
7885: PPUSH
7886: LD_INT 14
7888: PPUSH
7889: CALL_OW 308
7893: AND
7894: IFFALSE 7904
// inarea2 := true ;
7896: LD_ADDR_VAR 0 4
7900: PUSH
7901: LD_INT 1
7903: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
7904: LD_VAR 0 1
7908: PUSH
7909: LD_VAR 0 2
7913: AND
7914: PUSH
7915: LD_VAR 0 1
7919: PUSH
7920: LD_VAR 0 4
7924: AND
7925: OR
7926: PUSH
7927: LD_VAR 0 2
7931: PUSH
7932: LD_VAR 0 3
7936: AND
7937: OR
7938: PUSH
7939: LD_VAR 0 3
7943: PUSH
7944: LD_VAR 0 4
7948: AND
7949: OR
7950: IFFALSE 7771
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
7952: LD_VAR 0 3
7956: PUSH
7957: LD_VAR 0 4
7961: AND
7962: PUSH
7963: LD_VAR 0 1
7967: PUSH
7968: LD_VAR 0 4
7972: AND
7973: OR
7974: PUSH
7975: LD_VAR 0 2
7979: PUSH
7980: LD_VAR 0 3
7984: AND
7985: OR
7986: IFFALSE 8550
// begin prepare_siege := true ;
7988: LD_ADDR_EXP 27
7992: PUSH
7993: LD_INT 1
7995: ST_TO_ADDR
// DialogueOn ;
7996: CALL_OW 6
// if ( inarea1 and inarea2 ) then
8000: LD_VAR 0 3
8004: PUSH
8005: LD_VAR 0 4
8009: AND
8010: IFFALSE 8026
// Say ( JMM , D8b-JMM-1a ) else
8012: LD_EXP 31
8016: PPUSH
8017: LD_STRING D8b-JMM-1a
8019: PPUSH
8020: CALL_OW 88
8024: GO 8038
// Say ( JMM , D8b-JMM-1 ) ;
8026: LD_EXP 31
8030: PPUSH
8031: LD_STRING D8b-JMM-1
8033: PPUSH
8034: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
8038: LD_EXP 2
8042: PPUSH
8043: LD_INT 26
8045: PUSH
8046: LD_INT 1
8048: PUSH
8049: EMPTY
8050: LIST
8051: LIST
8052: PPUSH
8053: CALL_OW 72
8057: PUSH
8058: LD_EXP 32
8062: PUSH
8063: LD_EXP 33
8067: PUSH
8068: LD_EXP 42
8072: PUSH
8073: LD_EXP 45
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: LIST
8082: LIST
8083: DIFF
8084: PPUSH
8085: LD_STRING D8b-Sol1-1
8087: PPUSH
8088: CALL 604 0 2
// if Cyrus and Cyrus in jmm_units then
8092: LD_EXP 33
8096: PUSH
8097: LD_EXP 33
8101: PUSH
8102: LD_EXP 2
8106: IN
8107: AND
8108: IFFALSE 8124
// Say ( Cyrus , D8b-Cyrus-1 ) else
8110: LD_EXP 33
8114: PPUSH
8115: LD_STRING D8b-Cyrus-1
8117: PPUSH
8118: CALL_OW 88
8122: GO 8136
// Say ( JMM , D8b-JMM-1a ) ;
8124: LD_EXP 31
8128: PPUSH
8129: LD_STRING D8b-JMM-1a
8131: PPUSH
8132: CALL_OW 88
// if Lisa and Lisa in jmm_units then
8136: LD_EXP 34
8140: PUSH
8141: LD_EXP 34
8145: PUSH
8146: LD_EXP 2
8150: IN
8151: AND
8152: IFFALSE 8166
// Say ( Lisa , D8b-Lisa-2 ) ;
8154: LD_EXP 34
8158: PPUSH
8159: LD_STRING D8b-Lisa-2
8161: PPUSH
8162: CALL_OW 88
// if Bobby and Bobby in jmm_units then
8166: LD_EXP 32
8170: PUSH
8171: LD_EXP 32
8175: PUSH
8176: LD_EXP 2
8180: IN
8181: AND
8182: IFFALSE 8198
// Say ( Bobby , D8b-Bobby-1 ) else
8184: LD_EXP 32
8188: PPUSH
8189: LD_STRING D8b-Bobby-1
8191: PPUSH
8192: CALL_OW 88
8196: GO 8258
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
8198: LD_ADDR_VAR 0 5
8202: PUSH
8203: LD_EXP 2
8207: PPUSH
8208: LD_INT 26
8210: PUSH
8211: LD_INT 1
8213: PUSH
8214: EMPTY
8215: LIST
8216: LIST
8217: PPUSH
8218: CALL_OW 72
8222: PUSH
8223: LD_EXP 32
8227: PUSH
8228: LD_EXP 33
8232: PUSH
8233: LD_EXP 42
8237: PUSH
8238: LD_EXP 45
8242: PUSH
8243: EMPTY
8244: LIST
8245: LIST
8246: LIST
8247: LIST
8248: DIFF
8249: PPUSH
8250: LD_STRING D8b-Sol2-1
8252: PPUSH
8253: CALL 604 0 2
8257: ST_TO_ADDR
// DialogueOff ;
8258: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
8262: LD_EXP 33
8266: PUSH
8267: LD_EXP 33
8271: PUSH
8272: LD_EXP 2
8276: IN
8277: AND
8278: IFFALSE 8303
// tmp := Insert ( tmp , 1 , Cyrus ) ;
8280: LD_ADDR_VAR 0 6
8284: PUSH
8285: LD_VAR 0 6
8289: PPUSH
8290: LD_INT 1
8292: PPUSH
8293: LD_EXP 33
8297: PPUSH
8298: CALL_OW 2
8302: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
8303: LD_EXP 32
8307: PUSH
8308: LD_EXP 32
8312: PUSH
8313: LD_EXP 2
8317: IN
8318: AND
8319: IFFALSE 8344
// tmp := Insert ( tmp , 1 , Bobby ) ;
8321: LD_ADDR_VAR 0 6
8325: PUSH
8326: LD_VAR 0 6
8330: PPUSH
8331: LD_INT 1
8333: PPUSH
8334: LD_EXP 32
8338: PPUSH
8339: CALL_OW 2
8343: ST_TO_ADDR
// if sol then
8344: LD_VAR 0 5
8348: IFFALSE 8373
// tmp := Insert ( tmp , 1 , sol ) ;
8350: LD_ADDR_VAR 0 6
8354: PUSH
8355: LD_VAR 0 6
8359: PPUSH
8360: LD_INT 1
8362: PPUSH
8363: LD_VAR 0 5
8367: PPUSH
8368: CALL_OW 2
8372: ST_TO_ADDR
// if tmp then
8373: LD_VAR 0 6
8377: IFFALSE 8509
// begin SetSide ( tmp , 8 ) ;
8379: LD_VAR 0 6
8383: PPUSH
8384: LD_INT 8
8386: PPUSH
8387: CALL_OW 235
// ComFree ( tmp ) ;
8391: LD_VAR 0 6
8395: PPUSH
8396: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
8400: LD_VAR 0 6
8404: PPUSH
8405: LD_INT 15
8407: PPUSH
8408: CALL_OW 173
// AddComHold ( tmp ) ;
8412: LD_VAR 0 6
8416: PPUSH
8417: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
8421: LD_INT 35
8423: PPUSH
8424: CALL_OW 67
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
8428: LD_VAR 0 6
8432: PUSH
8433: LD_INT 1
8435: ARRAY
8436: PPUSH
8437: LD_INT 15
8439: PPUSH
8440: CALL_OW 308
8444: IFFALSE 8499
// begin RemoveUnit ( tmp [ 1 ] ) ;
8446: LD_VAR 0 6
8450: PUSH
8451: LD_INT 1
8453: ARRAY
8454: PPUSH
8455: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
8459: LD_ADDR_EXP 2
8463: PUSH
8464: LD_EXP 2
8468: PUSH
8469: LD_VAR 0 6
8473: PUSH
8474: LD_INT 1
8476: ARRAY
8477: DIFF
8478: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
8479: LD_ADDR_VAR 0 6
8483: PUSH
8484: LD_VAR 0 6
8488: PUSH
8489: LD_VAR 0 6
8493: PUSH
8494: LD_INT 1
8496: ARRAY
8497: DIFF
8498: ST_TO_ADDR
// end ; until tmp = 0 ;
8499: LD_VAR 0 6
8503: PUSH
8504: LD_INT 0
8506: EQUAL
8507: IFFALSE 8421
// end ; Wait ( 0 0$30 ) ;
8509: LD_INT 1050
8511: PPUSH
8512: CALL_OW 67
// if ru_spec_patrol then
8516: LD_EXP 48
8520: IFFALSE 8548
// for i in ru_spec_patrol do
8522: LD_ADDR_VAR 0 7
8526: PUSH
8527: LD_EXP 48
8531: PUSH
8532: FOR_IN
8533: IFFALSE 8546
// RemoveUnit ( i ) ;
8535: LD_VAR 0 7
8539: PPUSH
8540: CALL_OW 64
8544: GO 8532
8546: POP
8547: POP
// end else
8548: GO 8570
// begin prepare_siege := false ;
8550: LD_ADDR_EXP 27
8554: PUSH
8555: LD_INT 0
8557: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
8558: LD_EXP 31
8562: PPUSH
8563: LD_STRING D8a-JMM-1
8565: PPUSH
8566: CALL_OW 88
// end ; end ;
8570: PPOPN 7
8572: END
// every 0 0$10 trigger frank_can_return do var i , points ;
8573: LD_EXP 10
8577: IFFALSE 9711
8579: GO 8581
8581: DISABLE
8582: LD_INT 0
8584: PPUSH
8585: PPUSH
// begin uc_side := 8 ;
8586: LD_ADDR_OWVAR 20
8590: PUSH
8591: LD_INT 8
8593: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
8594: LD_ADDR_VAR 0 2
8598: PUSH
8599: LD_INT 59
8601: PUSH
8602: LD_INT 71
8604: PUSH
8605: EMPTY
8606: LIST
8607: LIST
8608: PUSH
8609: LD_INT 122
8611: PUSH
8612: LD_INT 117
8614: PUSH
8615: EMPTY
8616: LIST
8617: LIST
8618: PUSH
8619: EMPTY
8620: LIST
8621: LIST
8622: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
8623: LD_ADDR_EXP 45
8627: PUSH
8628: LD_STRING Frank
8630: PPUSH
8631: LD_INT 0
8633: PPUSH
8634: CALL 434 0 2
8638: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
8639: LD_ADDR_VAR 0 1
8643: PUSH
8644: LD_INT 1
8646: PPUSH
8647: LD_INT 2
8649: PPUSH
8650: CALL_OW 12
8654: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
8655: LD_EXP 45
8659: PPUSH
8660: LD_VAR 0 2
8664: PUSH
8665: LD_VAR 0 1
8669: ARRAY
8670: PUSH
8671: LD_INT 1
8673: ARRAY
8674: PPUSH
8675: LD_VAR 0 2
8679: PUSH
8680: LD_VAR 0 1
8684: ARRAY
8685: PUSH
8686: LD_INT 2
8688: ARRAY
8689: PPUSH
8690: LD_INT 0
8692: PPUSH
8693: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
8697: LD_EXP 45
8701: PPUSH
8702: LD_INT 1
8704: PPUSH
8705: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
8709: LD_INT 35
8711: PPUSH
8712: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
8716: LD_EXP 45
8720: PPUSH
8721: LD_EXP 31
8725: PPUSH
8726: CALL_OW 296
8730: PUSH
8731: LD_INT 8
8733: LESS
8734: IFFALSE 8709
// InGameOn ;
8736: CALL_OW 8
// CenterOnUnits ( JMM ) ;
8740: LD_EXP 31
8744: PPUSH
8745: CALL_OW 85
// if IsInUnit ( JMM ) then
8749: LD_EXP 31
8753: PPUSH
8754: CALL_OW 310
8758: IFFALSE 8769
// ComFree ( JMM ) ;
8760: LD_EXP 31
8764: PPUSH
8765: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
8769: LD_EXP 31
8773: PPUSH
8774: LD_EXP 45
8778: PPUSH
8779: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
8783: LD_EXP 45
8787: PPUSH
8788: LD_EXP 31
8792: PPUSH
8793: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
8797: LD_EXP 31
8801: PPUSH
8802: LD_STRING D6-JMM-1
8804: PPUSH
8805: CALL_OW 88
// repeat wait ( 3 ) ;
8809: LD_INT 3
8811: PPUSH
8812: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
8816: LD_EXP 31
8820: PPUSH
8821: LD_EXP 45
8825: PPUSH
8826: CALL_OW 296
8830: PUSH
8831: LD_INT 8
8833: LESS
8834: IFFALSE 8809
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
8836: LD_EXP 34
8840: PUSH
8841: LD_EXP 34
8845: PPUSH
8846: LD_EXP 45
8850: PPUSH
8851: CALL_OW 296
8855: PUSH
8856: LD_INT 20
8858: LESS
8859: AND
8860: IFFALSE 8885
// begin ComFree ( Lisa ) ;
8862: LD_EXP 34
8866: PPUSH
8867: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
8871: LD_EXP 34
8875: PPUSH
8876: LD_EXP 45
8880: PPUSH
8881: CALL_OW 172
// end ; if Lynch then
8885: LD_EXP 41
8889: IFFALSE 8914
// begin ComFree ( Lynch ) ;
8891: LD_EXP 41
8895: PPUSH
8896: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
8900: LD_EXP 41
8904: PPUSH
8905: LD_EXP 45
8909: PPUSH
8910: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
8914: LD_EXP 31
8918: PPUSH
8919: LD_EXP 45
8923: PPUSH
8924: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
8928: LD_EXP 45
8932: PPUSH
8933: LD_EXP 31
8937: PPUSH
8938: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
8942: LD_EXP 45
8946: PPUSH
8947: LD_STRING D6-Frank-1
8949: PPUSH
8950: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
8954: LD_INT 69
8956: PPUSH
8957: LD_INT 20
8959: PPUSH
8960: LD_INT 1
8962: PPUSH
8963: LD_INT 20
8965: NEG
8966: PPUSH
8967: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
8971: LD_INT 69
8973: PPUSH
8974: LD_INT 20
8976: PPUSH
8977: LD_INT 1
8979: PPUSH
8980: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
8984: LD_INT 190
8986: PPUSH
8987: LD_INT 31
8989: PPUSH
8990: LD_INT 1
8992: PPUSH
8993: LD_INT 20
8995: NEG
8996: PPUSH
8997: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
9001: LD_INT 190
9003: PPUSH
9004: LD_INT 31
9006: PPUSH
9007: LD_INT 1
9009: PPUSH
9010: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
9014: LD_INT 69
9016: PPUSH
9017: LD_INT 20
9019: PPUSH
9020: CALL_OW 84
// Wait ( 0 0$02 ) ;
9024: LD_INT 70
9026: PPUSH
9027: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
9031: LD_EXP 31
9035: PPUSH
9036: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
9040: LD_EXP 34
9044: PUSH
9045: LD_EXP 34
9049: PPUSH
9050: LD_EXP 45
9054: PPUSH
9055: CALL_OW 296
9059: PUSH
9060: LD_INT 20
9062: LESS
9063: AND
9064: PUSH
9065: LD_EXP 34
9069: PPUSH
9070: CALL_OW 302
9074: AND
9075: IFFALSE 9165
// begin ComFree ( Lisa ) ;
9077: LD_EXP 34
9081: PPUSH
9082: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
9086: LD_INT 35
9088: PPUSH
9089: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
9093: LD_EXP 34
9097: PPUSH
9098: LD_EXP 45
9102: PPUSH
9103: CALL_OW 296
9107: PUSH
9108: LD_INT 7
9110: LESS
9111: IFFALSE 9086
// Say ( Lisa , D6-Lisa-1 ) ;
9113: LD_EXP 34
9117: PPUSH
9118: LD_STRING D6-Lisa-1
9120: PPUSH
9121: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
9125: LD_EXP 34
9129: PPUSH
9130: LD_EXP 45
9134: PPUSH
9135: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
9139: LD_EXP 45
9143: PPUSH
9144: LD_EXP 34
9148: PPUSH
9149: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
9153: LD_EXP 45
9157: PPUSH
9158: LD_STRING D6-Frank-2
9160: PPUSH
9161: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
9165: LD_EXP 41
9169: PUSH
9170: LD_EXP 41
9174: PPUSH
9175: LD_EXP 45
9179: PPUSH
9180: CALL_OW 296
9184: PUSH
9185: LD_INT 20
9187: LESS
9188: AND
9189: PUSH
9190: LD_EXP 41
9194: PPUSH
9195: CALL_OW 302
9199: AND
9200: IFFALSE 9381
// begin ComTurnUnit ( Lynch , JMM ) ;
9202: LD_EXP 41
9206: PPUSH
9207: LD_EXP 31
9211: PPUSH
9212: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
9216: LD_EXP 45
9220: PPUSH
9221: LD_EXP 31
9225: PPUSH
9226: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
9230: LD_EXP 41
9234: PPUSH
9235: LD_STRING D6-Sol1-2
9237: PPUSH
9238: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
9242: LD_EXP 31
9246: PPUSH
9247: LD_STRING D6-JMM-2
9249: PPUSH
9250: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
9254: LD_EXP 45
9258: PPUSH
9259: LD_STRING D6-Frank-3
9261: PPUSH
9262: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
9266: LD_EXP 31
9270: PPUSH
9271: LD_STRING D6-JMM-3
9273: PPUSH
9274: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
9278: LD_EXP 45
9282: PPUSH
9283: LD_STRING D6-Frank-4
9285: PPUSH
9286: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9290: LD_EXP 45
9294: PPUSH
9295: LD_STRING D6-Frank-4a
9297: PPUSH
9298: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9302: LD_EXP 31
9306: PPUSH
9307: LD_STRING D6-JMM-4
9309: PPUSH
9310: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9314: LD_EXP 45
9318: PPUSH
9319: LD_STRING D6-Frank-5
9321: PPUSH
9322: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9326: LD_EXP 34
9330: PUSH
9331: LD_EXP 34
9335: PPUSH
9336: CALL_OW 302
9340: AND
9341: IFFALSE 9355
// Say ( Lisa , D6-Lisa-5 ) ;
9343: LD_EXP 34
9347: PPUSH
9348: LD_STRING D6-Lisa-5
9350: PPUSH
9351: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9355: LD_EXP 45
9359: PPUSH
9360: LD_STRING D6-Frank-6
9362: PPUSH
9363: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9367: LD_EXP 31
9371: PPUSH
9372: LD_STRING D6-JMM-6
9374: PPUSH
9375: CALL_OW 88
// end else
9379: GO 9496
// begin ComTurnUnit ( Frank , JMM ) ;
9381: LD_EXP 45
9385: PPUSH
9386: LD_EXP 31
9390: PPUSH
9391: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
9395: LD_EXP 45
9399: PPUSH
9400: LD_STRING D6-Frank-4
9402: PPUSH
9403: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
9407: LD_EXP 45
9411: PPUSH
9412: LD_STRING D6-Frank-4a
9414: PPUSH
9415: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
9419: LD_EXP 31
9423: PPUSH
9424: LD_STRING D6-JMM-4
9426: PPUSH
9427: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
9431: LD_EXP 45
9435: PPUSH
9436: LD_STRING D6-Frank-5
9438: PPUSH
9439: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
9443: LD_EXP 34
9447: PUSH
9448: LD_EXP 34
9452: PPUSH
9453: CALL_OW 302
9457: AND
9458: IFFALSE 9472
// Say ( Lisa , D6-Lisa-5 ) ;
9460: LD_EXP 34
9464: PPUSH
9465: LD_STRING D6-Lisa-5
9467: PPUSH
9468: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
9472: LD_EXP 45
9476: PPUSH
9477: LD_STRING D6-Frank-6
9479: PPUSH
9480: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
9484: LD_EXP 31
9488: PPUSH
9489: LD_STRING D6-JMM-6
9491: PPUSH
9492: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
9496: LD_STRING Q1
9498: PPUSH
9499: CALL_OW 97
9503: PUSH
9504: LD_INT 1
9506: DOUBLE
9507: EQUAL
9508: IFTRUE 9512
9510: GO 9523
9512: POP
// frank_send_to_scout := true ; 2 :
9513: LD_ADDR_EXP 12
9517: PUSH
9518: LD_INT 1
9520: ST_TO_ADDR
9521: GO 9543
9523: LD_INT 2
9525: DOUBLE
9526: EQUAL
9527: IFTRUE 9531
9529: GO 9542
9531: POP
// frank_send_to_scout := false ; end ;
9532: LD_ADDR_EXP 12
9536: PUSH
9537: LD_INT 0
9539: ST_TO_ADDR
9540: GO 9543
9542: POP
// InGameOff ;
9543: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
9547: LD_EXP 31
9551: PUSH
9552: LD_EXP 34
9556: PUSH
9557: LD_EXP 41
9561: PUSH
9562: EMPTY
9563: LIST
9564: LIST
9565: LIST
9566: PPUSH
9567: CALL_OW 139
// if frank_send_to_scout then
9571: LD_EXP 12
9575: IFFALSE 9632
// begin ComMoveXY ( Frank , 130 , 123 ) ;
9577: LD_EXP 45
9581: PPUSH
9582: LD_INT 130
9584: PPUSH
9585: LD_INT 123
9587: PPUSH
9588: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
9592: LD_INT 35
9594: PPUSH
9595: CALL_OW 67
// until not See ( 1 , Frank ) ;
9599: LD_INT 1
9601: PPUSH
9602: LD_EXP 45
9606: PPUSH
9607: CALL_OW 292
9611: NOT
9612: IFFALSE 9592
// Wait ( 0 0$02 ) ;
9614: LD_INT 70
9616: PPUSH
9617: CALL_OW 67
// RemoveUnit ( Frank ) ;
9621: LD_EXP 45
9625: PPUSH
9626: CALL_OW 64
// end else
9630: GO 9644
// SetSide ( Frank , 1 ) ;
9632: LD_EXP 45
9636: PPUSH
9637: LD_INT 1
9639: PPUSH
9640: CALL_OW 235
// send_attack_on_cornel_base := true ;
9644: LD_ADDR_EXP 23
9648: PUSH
9649: LD_INT 1
9651: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9652: LD_INT 35
9654: PPUSH
9655: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
9659: LD_ADDR_EXP 25
9663: PUSH
9664: LD_EXP 25
9668: PPUSH
9669: LD_STRING -
9671: PPUSH
9672: CALL 1096 0 2
9676: ST_TO_ADDR
// if debug then
9677: LD_EXP 1
9681: IFFALSE 9693
// debug_strings := time_to_prepare ;
9683: LD_ADDR_OWVAR 48
9687: PUSH
9688: LD_EXP 25
9692: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
9693: LD_EXP 25
9697: PUSH
9698: LD_INT 0
9700: EQUAL
9701: IFFALSE 9652
// cornel_prepared := true ;
9703: LD_ADDR_EXP 9
9707: PUSH
9708: LD_INT 1
9710: ST_TO_ADDR
// end ;
9711: PPOPN 2
9713: END
// every 0 0$01 trigger cornel_prepared do
9714: LD_EXP 9
9718: IFFALSE 9964
9720: GO 9722
9722: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
9723: LD_EXP 38
9727: PPUSH
9728: LD_STRING D3-Corn-1
9730: PPUSH
9731: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
9735: LD_INT 35
9737: PPUSH
9738: CALL_OW 67
// until cornel_counter = 0 ;
9742: LD_EXP 8
9746: PUSH
9747: LD_INT 0
9749: EQUAL
9750: IFFALSE 9735
// SayRadio ( Cornel , D3a-Corn-1 ) ;
9752: LD_EXP 38
9756: PPUSH
9757: LD_STRING D3a-Corn-1
9759: PPUSH
9760: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
9764: LD_EXP 31
9768: PPUSH
9769: LD_STRING D3a-JMM-1
9771: PPUSH
9772: CALL_OW 88
// end_mission_allowed := true ;
9776: LD_ADDR_EXP 18
9780: PUSH
9781: LD_INT 1
9783: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
9784: LD_STRING M2
9786: PPUSH
9787: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
9791: LD_INT 9
9793: PPUSH
9794: LD_INT 1
9796: PPUSH
9797: CALL_OW 424
// Wait ( 0 0$05 ) ;
9801: LD_INT 175
9803: PPUSH
9804: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
9808: LD_EXP 38
9812: PPUSH
9813: LD_STRING D3a-Corn-2
9815: PPUSH
9816: CALL_OW 94
// cornel_attack := true ;
9820: LD_ADDR_EXP 7
9824: PUSH
9825: LD_INT 1
9827: ST_TO_ADDR
// Wait ( 0 0$03 ) ;
9828: LD_INT 105
9830: PPUSH
9831: CALL_OW 67
// AddMoreTanks ( ) ;
9835: CALL 4754 0 0
// if frank_send_to_scout then
9839: LD_EXP 12
9843: IFFALSE 9964
// begin InitHc ;
9845: CALL_OW 19
// InitUc ;
9849: CALL_OW 18
// uc_side := 8 ;
9853: LD_ADDR_OWVAR 20
9857: PUSH
9858: LD_INT 8
9860: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
9861: LD_ADDR_EXP 45
9865: PUSH
9866: LD_STRING Frank
9868: PPUSH
9869: LD_INT 0
9871: PPUSH
9872: CALL 434 0 2
9876: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
9877: LD_EXP 45
9881: PPUSH
9882: LD_INT 6
9884: PPUSH
9885: LD_INT 9
9887: PPUSH
9888: LD_INT 0
9890: PPUSH
9891: CALL_OW 48
// ComCrawl ( Frank ) ;
9895: LD_EXP 45
9899: PPUSH
9900: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
9904: LD_INT 35
9906: PPUSH
9907: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
9911: LD_EXP 31
9915: PPUSH
9916: LD_EXP 45
9920: PPUSH
9921: CALL_OW 296
9925: PUSH
9926: LD_INT 9
9928: LESS
9929: IFFALSE 9904
// SetSide ( Frank , 1 ) ;
9931: LD_EXP 45
9935: PPUSH
9936: LD_INT 1
9938: PPUSH
9939: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
9943: LD_EXP 45
9947: PPUSH
9948: LD_STRING D6a-Frank-1
9950: PPUSH
9951: CALL_OW 88
// ComWalk ( Frank ) ;
9955: LD_EXP 45
9959: PPUSH
9960: CALL_OW 138
// end ; end ;
9964: END
// every 0 0$01 trigger solar_builded do
9965: LD_EXP 11
9969: IFFALSE 10073
9971: GO 9973
9973: DISABLE
// begin Wait ( 0 0$02 ) ;
9974: LD_INT 70
9976: PPUSH
9977: CALL_OW 67
// DialogueOn ;
9981: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
9985: LD_EXP 31
9989: PPUSH
9990: LD_STRING D2b-JMM-1
9992: PPUSH
9993: CALL_OW 88
// if Walker and IsOk ( Walker ) then
9997: LD_EXP 42
10001: PUSH
10002: LD_EXP 42
10006: PPUSH
10007: CALL_OW 302
10011: AND
10012: IFFALSE 10062
// begin Say ( Walker , D2b-Sci1-1 ) ;
10014: LD_EXP 42
10018: PPUSH
10019: LD_STRING D2b-Sci1-1
10021: PPUSH
10022: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
10026: LD_EXP 31
10030: PPUSH
10031: LD_STRING D2b-JMM-2
10033: PPUSH
10034: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
10038: LD_EXP 42
10042: PPUSH
10043: LD_STRING D2b-Sci1-2
10045: PPUSH
10046: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
10050: LD_EXP 31
10054: PPUSH
10055: LD_STRING D2b-JMM-3
10057: PPUSH
10058: CALL_OW 88
// end ; DialogueOff ;
10062: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
10066: LD_STRING MOutSol
10068: PPUSH
10069: CALL_OW 337
// end ;
10073: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
10074: LD_EXP 11
10078: PUSH
10079: LD_EXP 31
10083: PPUSH
10084: CALL_OW 302
10088: AND
10089: PUSH
10090: LD_EXP 31
10094: PPUSH
10095: CALL 930 0 1
10099: AND
10100: PUSH
10101: LD_EXP 13
10105: NOT
10106: AND
10107: IFFALSE 10178
10109: GO 10111
10111: DISABLE
10112: LD_INT 0
10114: PPUSH
// begin jmm_in_veh := true ;
10115: LD_ADDR_EXP 13
10119: PUSH
10120: LD_INT 1
10122: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10123: LD_ADDR_VAR 0 1
10127: PUSH
10128: LD_INT 0
10130: PPUSH
10131: LD_INT 1
10133: PPUSH
10134: CALL_OW 12
10138: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10139: LD_INT 70
10141: PPUSH
10142: CALL_OW 67
// if i then
10146: LD_VAR 0 1
10150: IFFALSE 10166
// Say ( JMM , D2c-JMM-1 ) else
10152: LD_EXP 31
10156: PPUSH
10157: LD_STRING D2c-JMM-1
10159: PPUSH
10160: CALL_OW 88
10164: GO 10178
// Say ( JMM , D2c-JMM-1a ) ;
10166: LD_EXP 31
10170: PPUSH
10171: LD_STRING D2c-JMM-1a
10173: PPUSH
10174: CALL_OW 88
// end ;
10178: PPOPN 1
10180: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
10181: LD_EXP 11
10185: PUSH
10186: LD_EXP 32
10190: PPUSH
10191: CALL_OW 302
10195: AND
10196: PUSH
10197: LD_EXP 32
10201: PPUSH
10202: CALL 930 0 1
10206: AND
10207: PUSH
10208: LD_EXP 14
10212: NOT
10213: AND
10214: IFFALSE 10246
10216: GO 10218
10218: DISABLE
// begin bobby_in_veh := true ;
10219: LD_ADDR_EXP 14
10223: PUSH
10224: LD_INT 1
10226: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10227: LD_INT 70
10229: PPUSH
10230: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
10234: LD_EXP 32
10238: PPUSH
10239: LD_STRING D2c-Bobby-1
10241: PPUSH
10242: CALL_OW 88
10246: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
10247: LD_EXP 11
10251: PUSH
10252: LD_EXP 34
10256: PPUSH
10257: CALL_OW 302
10261: AND
10262: PUSH
10263: LD_EXP 34
10267: PPUSH
10268: CALL 930 0 1
10272: AND
10273: PUSH
10274: LD_EXP 16
10278: NOT
10279: AND
10280: IFFALSE 10312
10282: GO 10284
10284: DISABLE
// begin lisa_in_veh := true ;
10285: LD_ADDR_EXP 16
10289: PUSH
10290: LD_INT 1
10292: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10293: LD_INT 70
10295: PPUSH
10296: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
10300: LD_EXP 34
10304: PPUSH
10305: LD_STRING D2c-Lisa-1
10307: PPUSH
10308: CALL_OW 88
10312: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
10313: LD_EXP 11
10317: PUSH
10318: LD_EXP 33
10322: PPUSH
10323: CALL_OW 302
10327: AND
10328: PUSH
10329: LD_EXP 33
10333: PPUSH
10334: CALL 930 0 1
10338: AND
10339: PUSH
10340: LD_EXP 15
10344: NOT
10345: AND
10346: IFFALSE 10417
10348: GO 10350
10350: DISABLE
10351: LD_INT 0
10353: PPUSH
// begin cyrus_in_veh := true ;
10354: LD_ADDR_EXP 15
10358: PUSH
10359: LD_INT 1
10361: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
10362: LD_ADDR_VAR 0 1
10366: PUSH
10367: LD_INT 0
10369: PPUSH
10370: LD_INT 1
10372: PPUSH
10373: CALL_OW 12
10377: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
10378: LD_INT 70
10380: PPUSH
10381: CALL_OW 67
// if i then
10385: LD_VAR 0 1
10389: IFFALSE 10405
// Say ( Cyrus , D2c-Cyrus-1 ) else
10391: LD_EXP 33
10395: PPUSH
10396: LD_STRING D2c-Cyrus-1
10398: PPUSH
10399: CALL_OW 88
10403: GO 10417
// Say ( Cyrus , D2c-Cyrus-1a ) ;
10405: LD_EXP 33
10409: PPUSH
10410: LD_STRING D2c-Cyrus-1a
10412: PPUSH
10413: CALL_OW 88
// end ;
10417: PPOPN 1
10419: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
10420: LD_EXP 38
10424: PPUSH
10425: LD_INT 16
10427: PPUSH
10428: CALL_OW 308
10432: IFFALSE 10682
10434: GO 10436
10436: DISABLE
10437: LD_INT 0
10439: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
10440: LD_INT 3
10442: PPUSH
10443: LD_EXP 38
10447: PPUSH
10448: CALL_OW 471
// send_attack_on_cornel := true ;
10452: LD_ADDR_EXP 28
10456: PUSH
10457: LD_INT 1
10459: ST_TO_ADDR
// if ru_vehicles then
10460: LD_EXP 50
10464: IFFALSE 10498
// for i in ru_vehicles do
10466: LD_ADDR_VAR 0 1
10470: PUSH
10471: LD_EXP 50
10475: PUSH
10476: FOR_IN
10477: IFFALSE 10496
// ComAgressiveMove ( i , 215 , 69 ) ;
10479: LD_VAR 0 1
10483: PPUSH
10484: LD_INT 215
10486: PPUSH
10487: LD_INT 69
10489: PPUSH
10490: CALL_OW 114
10494: GO 10476
10496: POP
10497: POP
// if ru_patrol then
10498: LD_EXP 47
10502: IFFALSE 10536
// for i in ru_patrol do
10504: LD_ADDR_VAR 0 1
10508: PUSH
10509: LD_EXP 47
10513: PUSH
10514: FOR_IN
10515: IFFALSE 10534
// ComAgressiveMove ( i , 215 , 69 ) ;
10517: LD_VAR 0 1
10521: PPUSH
10522: LD_INT 215
10524: PPUSH
10525: LD_INT 69
10527: PPUSH
10528: CALL_OW 114
10532: GO 10514
10534: POP
10535: POP
// if frank_send_to_scout then
10536: LD_EXP 12
10540: IFFALSE 10554
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
10542: LD_EXP 45
10546: PPUSH
10547: LD_STRING D3b-Frank-1
10549: PPUSH
10550: CALL_OW 94
// end ; Wait ( 0 0$04 ) ;
10554: LD_INT 140
10556: PPUSH
10557: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
10561: LD_EXP 38
10565: PPUSH
10566: LD_STRING D4-Corn-1
10568: PPUSH
10569: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
10573: LD_INT 35
10575: PPUSH
10576: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 5 ;
10580: LD_INT 22
10582: PUSH
10583: LD_INT 4
10585: PUSH
10586: EMPTY
10587: LIST
10588: LIST
10589: PUSH
10590: LD_INT 21
10592: PUSH
10593: LD_INT 1
10595: PUSH
10596: EMPTY
10597: LIST
10598: LIST
10599: PUSH
10600: LD_INT 50
10602: PUSH
10603: EMPTY
10604: LIST
10605: PUSH
10606: EMPTY
10607: LIST
10608: LIST
10609: LIST
10610: PPUSH
10611: CALL_OW 69
10615: PUSH
10616: LD_INT 5
10618: LESS
10619: IFFALSE 10573
// SayRadio ( Cornel , D5-Corn-1 ) ;
10621: LD_EXP 38
10625: PPUSH
10626: LD_STRING D5-Corn-1
10628: PPUSH
10629: CALL_OW 94
// SaveCharacters ( Cornel , Cornel ) ;
10633: LD_EXP 38
10637: PPUSH
10638: LD_STRING Cornel
10640: PPUSH
10641: CALL_OW 38
// ChangeSideFog ( 4 , 8 ) ;
10645: LD_INT 4
10647: PPUSH
10648: LD_INT 8
10650: PPUSH
10651: CALL_OW 343
// Wait ( 0 0$01 ) ;
10655: LD_INT 35
10657: PPUSH
10658: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
10662: LD_INT 3
10664: PPUSH
10665: LD_EXP 38
10669: PPUSH
10670: CALL_OW 472
// send_attack_on_cornel := false ;
10674: LD_ADDR_EXP 28
10678: PUSH
10679: LD_INT 0
10681: ST_TO_ADDR
// end ;
10682: PPOPN 1
10684: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
10685: LD_INT 9
10687: PPUSH
10688: LD_INT 22
10690: PUSH
10691: LD_INT 1
10693: PUSH
10694: EMPTY
10695: LIST
10696: LIST
10697: PPUSH
10698: CALL_OW 70
10702: PUSH
10703: LD_EXP 29
10707: OR
10708: IFFALSE 11227
10710: GO 10712
10712: DISABLE
10713: LD_INT 0
10715: PPUSH
10716: PPUSH
// begin enable ;
10717: ENABLE
// if not game_end then
10718: LD_EXP 29
10722: NOT
10723: IFFALSE 10733
// game_end := true ;
10725: LD_ADDR_EXP 29
10729: PUSH
10730: LD_INT 1
10732: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
10733: LD_ADDR_VAR 0 2
10737: PUSH
10738: LD_INT 9
10740: PPUSH
10741: LD_INT 22
10743: PUSH
10744: LD_INT 1
10746: PUSH
10747: EMPTY
10748: LIST
10749: LIST
10750: PPUSH
10751: CALL_OW 70
10755: ST_TO_ADDR
// if not filter then
10756: LD_VAR 0 2
10760: NOT
10761: IFFALSE 10765
// exit ;
10763: GO 11227
// for i in filter do
10765: LD_ADDR_VAR 0 1
10769: PUSH
10770: LD_VAR 0 2
10774: PUSH
10775: FOR_IN
10776: IFFALSE 11225
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
10778: LD_VAR 0 1
10782: PPUSH
10783: CALL_OW 302
10787: PUSH
10788: LD_VAR 0 1
10792: PPUSH
10793: CALL_OW 247
10797: PUSH
10798: LD_INT 2
10800: EQUAL
10801: AND
10802: IFFALSE 10842
// begin veh_on_meta := true ;
10804: LD_ADDR_EXP 24
10808: PUSH
10809: LD_INT 1
10811: ST_TO_ADDR
// ComExitVehicle ( IsInUnit ( i ) ) ;
10812: LD_VAR 0 1
10816: PPUSH
10817: CALL_OW 310
10821: PPUSH
10822: CALL_OW 121
// RemoveUnit ( i ) ;
10826: LD_VAR 0 1
10830: PPUSH
10831: CALL_OW 64
// Wait ( 10 ) ;
10835: LD_INT 10
10837: PPUSH
10838: CALL_OW 67
// end ; if i = JMM then
10842: LD_VAR 0 1
10846: PUSH
10847: LD_EXP 31
10851: EQUAL
10852: IFFALSE 10974
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
10854: LD_EXP 21
10858: PUSH
10859: LD_INT 22
10861: PUSH
10862: LD_INT 1
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: PUSH
10869: LD_INT 21
10871: PUSH
10872: LD_INT 1
10874: PUSH
10875: EMPTY
10876: LIST
10877: LIST
10878: PUSH
10879: EMPTY
10880: LIST
10881: LIST
10882: PPUSH
10883: CALL_OW 69
10887: PUSH
10888: LD_INT 1
10890: GREATER
10891: AND
10892: IFFALSE 10949
// begin show_query := false ;
10894: LD_ADDR_EXP 21
10898: PUSH
10899: LD_INT 0
10901: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
10902: LD_STRING Q2
10904: PPUSH
10905: CALL_OW 97
10909: PUSH
10910: LD_INT 1
10912: DOUBLE
10913: EQUAL
10914: IFTRUE 10918
10916: GO 10929
10918: POP
// wait_for_them := true ; 2 :
10919: LD_ADDR_EXP 22
10923: PUSH
10924: LD_INT 1
10926: ST_TO_ADDR
10927: GO 10949
10929: LD_INT 2
10931: DOUBLE
10932: EQUAL
10933: IFTRUE 10937
10935: GO 10948
10937: POP
// wait_for_them := false ; end ;
10938: LD_ADDR_EXP 22
10942: PUSH
10943: LD_INT 0
10945: ST_TO_ADDR
10946: GO 10949
10948: POP
// end ; save_group := save_group ^ JMM ;
10949: LD_ADDR_EXP 20
10953: PUSH
10954: LD_EXP 20
10958: PUSH
10959: LD_EXP 31
10963: ADD
10964: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
10965: LD_EXP 31
10969: PPUSH
10970: CALL_OW 64
// end ; if i = Lisa then
10974: LD_VAR 0 1
10978: PUSH
10979: LD_EXP 34
10983: EQUAL
10984: IFFALSE 11011
// begin save_group := save_group ^ Lisa ;
10986: LD_ADDR_EXP 20
10990: PUSH
10991: LD_EXP 20
10995: PUSH
10996: LD_EXP 34
11000: ADD
11001: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
11002: LD_EXP 34
11006: PPUSH
11007: CALL_OW 64
// end ; if i = Bobby then
11011: LD_VAR 0 1
11015: PUSH
11016: LD_EXP 32
11020: EQUAL
11021: IFFALSE 11048
// begin save_group := save_group ^ Bobby ;
11023: LD_ADDR_EXP 20
11027: PUSH
11028: LD_EXP 20
11032: PUSH
11033: LD_EXP 32
11037: ADD
11038: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
11039: LD_EXP 32
11043: PPUSH
11044: CALL_OW 64
// end ; if i = Cyrus then
11048: LD_VAR 0 1
11052: PUSH
11053: LD_EXP 33
11057: EQUAL
11058: IFFALSE 11085
// begin save_group := save_group ^ Cyrus ;
11060: LD_ADDR_EXP 20
11064: PUSH
11065: LD_EXP 20
11069: PUSH
11070: LD_EXP 33
11074: ADD
11075: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
11076: LD_EXP 33
11080: PPUSH
11081: CALL_OW 64
// end ; if i = Khatam then
11085: LD_VAR 0 1
11089: PUSH
11090: LD_EXP 35
11094: EQUAL
11095: IFFALSE 11122
// begin save_group := save_group ^ Khatam ;
11097: LD_ADDR_EXP 20
11101: PUSH
11102: LD_EXP 20
11106: PUSH
11107: LD_EXP 35
11111: ADD
11112: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
11113: LD_EXP 35
11117: PPUSH
11118: CALL_OW 64
// end ; if i = Frank then
11122: LD_VAR 0 1
11126: PUSH
11127: LD_EXP 45
11131: EQUAL
11132: IFFALSE 11159
// begin save_group := save_group ^ Frank ;
11134: LD_ADDR_EXP 20
11138: PUSH
11139: LD_EXP 20
11143: PUSH
11144: LD_EXP 45
11148: ADD
11149: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
11150: LD_EXP 45
11154: PPUSH
11155: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and ( not i in save_group ) then
11159: LD_VAR 0 1
11163: PPUSH
11164: CALL_OW 302
11168: PUSH
11169: LD_VAR 0 1
11173: PPUSH
11174: CALL_OW 247
11178: PUSH
11179: LD_INT 1
11181: EQUAL
11182: AND
11183: PUSH
11184: LD_VAR 0 1
11188: PUSH
11189: LD_EXP 20
11193: IN
11194: NOT
11195: AND
11196: IFFALSE 11223
// begin save_others := save_others ^ i ;
11198: LD_ADDR_EXP 19
11202: PUSH
11203: LD_EXP 19
11207: PUSH
11208: LD_VAR 0 1
11212: ADD
11213: ST_TO_ADDR
// RemoveUnit ( i ) ;
11214: LD_VAR 0 1
11218: PPUSH
11219: CALL_OW 64
// end ; end ;
11223: GO 10775
11225: POP
11226: POP
// end ;
11227: PPOPN 2
11229: END
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 do
11230: LD_EXP 21
11234: NOT
11235: PUSH
11236: LD_EXP 22
11240: NOT
11241: AND
11242: PUSH
11243: LD_INT 22
11245: PUSH
11246: LD_INT 1
11248: PUSH
11249: EMPTY
11250: LIST
11251: LIST
11252: PUSH
11253: LD_INT 21
11255: PUSH
11256: LD_INT 1
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: PUSH
11263: EMPTY
11264: LIST
11265: LIST
11266: PPUSH
11267: CALL_OW 69
11271: PUSH
11272: LD_INT 0
11274: EQUAL
11275: OR
11276: IFFALSE 11285
11278: GO 11280
11280: DISABLE
// EndMission ;
11281: CALL 11286 0 0
11285: END
// export function EndMission ; var i ; begin
11286: LD_INT 0
11288: PPUSH
11289: PPUSH
// Wait ( 0 0$02 ) ;
11290: LD_INT 70
11292: PPUSH
11293: CALL_OW 67
// if solar_builded then
11297: LD_EXP 11
11301: IFFALSE 11315
// AddMedal ( Solar1 , 1 ) else
11303: LD_STRING Solar1
11305: PPUSH
11306: LD_INT 1
11308: PPUSH
11309: CALL_OW 101
11313: GO 11326
// AddMedal ( Solar1 , - 1 ) ;
11315: LD_STRING Solar1
11317: PPUSH
11318: LD_INT 1
11320: NEG
11321: PPUSH
11322: CALL_OW 101
// if veh_on_meta then
11326: LD_EXP 24
11330: IFFALSE 11344
// AddMedal ( Solar2 , 1 ) else
11332: LD_STRING Solar2
11334: PPUSH
11335: LD_INT 1
11337: PPUSH
11338: CALL_OW 101
11342: GO 11374
// if solar_builded then
11344: LD_EXP 11
11348: IFFALSE 11363
// AddMedal ( Solar2 , - 1 ) else
11350: LD_STRING Solar2
11352: PPUSH
11353: LD_INT 1
11355: NEG
11356: PPUSH
11357: CALL_OW 101
11361: GO 11374
// AddMedal ( Solar2 , - 2 ) ;
11363: LD_STRING Solar2
11365: PPUSH
11366: LD_INT 2
11368: NEG
11369: PPUSH
11370: CALL_OW 101
// if lose_counter = 0 then
11374: LD_EXP 30
11378: PUSH
11379: LD_INT 0
11381: EQUAL
11382: IFFALSE 11396
// AddMedal ( No , 1 ) else
11384: LD_STRING No
11386: PPUSH
11387: LD_INT 1
11389: PPUSH
11390: CALL_OW 101
11394: GO 11440
// if lose_counter > 0 and lose_counter < 4 then
11396: LD_EXP 30
11400: PUSH
11401: LD_INT 0
11403: GREATER
11404: PUSH
11405: LD_EXP 30
11409: PUSH
11410: LD_INT 4
11412: LESS
11413: AND
11414: IFFALSE 11429
// AddMedal ( No , - 1 ) else
11416: LD_STRING No
11418: PPUSH
11419: LD_INT 1
11421: NEG
11422: PPUSH
11423: CALL_OW 101
11427: GO 11440
// AddMedal ( UpTo4 , - 1 ) ;
11429: LD_STRING UpTo4
11431: PPUSH
11432: LD_INT 1
11434: NEG
11435: PPUSH
11436: CALL_OW 101
// GiveMedals ( MAIN ) ;
11440: LD_STRING MAIN
11442: PPUSH
11443: CALL_OW 102
// if IsDead ( Pokryshkin ) then
11447: LD_EXP 46
11451: PPUSH
11452: CALL_OW 301
11456: IFFALSE 11496
// for i in save_group ^ save_others do
11458: LD_ADDR_VAR 0 2
11462: PUSH
11463: LD_EXP 20
11467: PUSH
11468: LD_EXP 19
11472: ADD
11473: PUSH
11474: FOR_IN
11475: IFFALSE 11494
// AddExperience ( i , skill_combat , 1500 ) ;
11477: LD_VAR 0 2
11481: PPUSH
11482: LD_INT 1
11484: PPUSH
11485: LD_INT 1500
11487: PPUSH
11488: CALL_OW 492
11492: GO 11474
11494: POP
11495: POP
// RewardPeople ( save_group ^ save_others ) ;
11496: LD_EXP 20
11500: PUSH
11501: LD_EXP 19
11505: ADD
11506: PPUSH
11507: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
11511: LD_EXP 31
11515: PPUSH
11516: LD_STRING JMM
11518: PPUSH
11519: CALL_OW 38
// if Bobby in save_group then
11523: LD_EXP 32
11527: PUSH
11528: LD_EXP 20
11532: IN
11533: IFFALSE 11549
// SaveCharacters ( Bobby , Bobby ) else
11535: LD_EXP 32
11539: PPUSH
11540: LD_STRING Bobby
11542: PPUSH
11543: CALL_OW 38
11547: GO 11556
// DeleteCharacters ( Bobby ) ;
11549: LD_STRING Bobby
11551: PPUSH
11552: CALL_OW 40
// if Cyrus in save_group then
11556: LD_EXP 33
11560: PUSH
11561: LD_EXP 20
11565: IN
11566: IFFALSE 11582
// SaveCharacters ( Cyrus , Cyrus ) else
11568: LD_EXP 33
11572: PPUSH
11573: LD_STRING Cyrus
11575: PPUSH
11576: CALL_OW 38
11580: GO 11589
// DeleteCharacters ( Cyrus ) ;
11582: LD_STRING Cyrus
11584: PPUSH
11585: CALL_OW 40
// if Lisa in save_group then
11589: LD_EXP 34
11593: PUSH
11594: LD_EXP 20
11598: IN
11599: IFFALSE 11615
// SaveCharacters ( Lisa , Lisa ) else
11601: LD_EXP 34
11605: PPUSH
11606: LD_STRING Lisa
11608: PPUSH
11609: CALL_OW 38
11613: GO 11622
// DeleteCharacters ( Lisa ) ;
11615: LD_STRING Lisa
11617: PPUSH
11618: CALL_OW 40
// if Frank in save_group then
11622: LD_EXP 45
11626: PUSH
11627: LD_EXP 20
11631: IN
11632: IFFALSE 11648
// SaveCharacters ( Frank , Frank ) else
11634: LD_EXP 45
11638: PPUSH
11639: LD_STRING Frank
11641: PPUSH
11642: CALL_OW 38
11646: GO 11655
// DeleteCharacters ( Frank ) ;
11648: LD_STRING Frank
11650: PPUSH
11651: CALL_OW 40
// if Khatam in save_group then
11655: LD_EXP 35
11659: PUSH
11660: LD_EXP 20
11664: IN
11665: IFFALSE 11681
// SaveCharacters ( Khatam , Khatam ) else
11667: LD_EXP 35
11671: PPUSH
11672: LD_STRING Khatam
11674: PPUSH
11675: CALL_OW 38
11679: GO 11688
// DeleteCharacters ( Khatam ) ;
11681: LD_STRING Khatam
11683: PPUSH
11684: CALL_OW 40
// if save_others then
11688: LD_EXP 19
11692: IFFALSE 11706
// SaveCharacters ( save_others , 03_others ) ;
11694: LD_EXP 19
11698: PPUSH
11699: LD_STRING 03_others
11701: PPUSH
11702: CALL_OW 38
// DeleteCharacters ( Brian ) ;
11706: LD_STRING Brian
11708: PPUSH
11709: CALL_OW 40
// DeleteCharacters ( Jimmy ) ;
11713: LD_STRING Jimmy
11715: PPUSH
11716: CALL_OW 40
// if Bierezov and IsOk ( Bierezov ) then
11720: LD_EXP 39
11724: PUSH
11725: LD_EXP 39
11729: PPUSH
11730: CALL_OW 302
11734: AND
11735: IFFALSE 11747
// begin ResetFog ;
11737: CALL_OW 335
// DisplayEndingScene ;
11741: CALL 11763 0 0
// end else
11745: GO 11754
// DeleteCharacters ( Cornel ) ;
11747: LD_STRING Cornel
11749: PPUSH
11750: CALL_OW 40
// YouWin ;
11754: CALL_OW 103
// end ;
11758: LD_VAR 0 1
11762: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
11763: LD_INT 0
11765: PPUSH
11766: PPUSH
11767: PPUSH
11768: PPUSH
11769: PPUSH
11770: PPUSH
// InGameOn ;
11771: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
11775: LD_INT 208
11777: PPUSH
11778: LD_INT 62
11780: PPUSH
11781: LD_INT 1
11783: PPUSH
11784: LD_INT 10
11786: NEG
11787: PPUSH
11788: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
11792: LD_INT 208
11794: PPUSH
11795: LD_INT 62
11797: PPUSH
11798: LD_INT 1
11800: PPUSH
11801: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
11805: LD_ADDR_VAR 0 3
11809: PUSH
11810: LD_INT 22
11812: PUSH
11813: LD_INT 3
11815: PUSH
11816: EMPTY
11817: LIST
11818: LIST
11819: PUSH
11820: LD_INT 2
11822: PUSH
11823: LD_INT 21
11825: PUSH
11826: LD_INT 2
11828: PUSH
11829: EMPTY
11830: LIST
11831: LIST
11832: PUSH
11833: LD_INT 21
11835: PUSH
11836: LD_INT 1
11838: PUSH
11839: EMPTY
11840: LIST
11841: LIST
11842: PUSH
11843: EMPTY
11844: LIST
11845: LIST
11846: LIST
11847: PUSH
11848: EMPTY
11849: LIST
11850: LIST
11851: PPUSH
11852: CALL_OW 69
11856: ST_TO_ADDR
// if filter then
11857: LD_VAR 0 3
11861: IFFALSE 11889
// for i in filter do
11863: LD_ADDR_VAR 0 2
11867: PUSH
11868: LD_VAR 0 3
11872: PUSH
11873: FOR_IN
11874: IFFALSE 11887
// RemoveUnit ( i ) ;
11876: LD_VAR 0 2
11880: PPUSH
11881: CALL_OW 64
11885: GO 11873
11887: POP
11888: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
11889: LD_ADDR_VAR 0 3
11893: PUSH
11894: LD_INT 22
11896: PUSH
11897: LD_INT 4
11899: PUSH
11900: EMPTY
11901: LIST
11902: LIST
11903: PUSH
11904: LD_INT 21
11906: PUSH
11907: LD_INT 1
11909: PUSH
11910: EMPTY
11911: LIST
11912: LIST
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: PPUSH
11918: CALL_OW 69
11922: ST_TO_ADDR
// if filter then
11923: LD_VAR 0 3
11927: IFFALSE 11958
// for i in filter do
11929: LD_ADDR_VAR 0 2
11933: PUSH
11934: LD_VAR 0 3
11938: PUSH
11939: FOR_IN
11940: IFFALSE 11956
// SetLives ( i , 0 ) ;
11942: LD_VAR 0 2
11946: PPUSH
11947: LD_INT 0
11949: PPUSH
11950: CALL_OW 234
11954: GO 11939
11956: POP
11957: POP
// uc_side := 4 ;
11958: LD_ADDR_OWVAR 20
11962: PUSH
11963: LD_INT 4
11965: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
11966: LD_ADDR_VAR 0 4
11970: PUSH
11971: LD_STRING Cornell
11973: PPUSH
11974: LD_INT 0
11976: PPUSH
11977: CALL 434 0 2
11981: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
11982: LD_VAR 0 4
11986: PPUSH
11987: LD_INT 208
11989: PPUSH
11990: LD_INT 62
11992: PPUSH
11993: LD_INT 0
11995: PPUSH
11996: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
12000: LD_VAR 0 4
12004: PPUSH
12005: LD_INT 100
12007: PPUSH
12008: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
12012: LD_INT 3
12014: PPUSH
12015: LD_VAR 0 4
12019: PPUSH
12020: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
12024: LD_INT 4
12026: PPUSH
12027: LD_INT 3
12029: PPUSH
12030: LD_INT 1
12032: PPUSH
12033: LD_INT 1
12035: PPUSH
12036: CALL_OW 80
// uc_side := 3 ;
12040: LD_ADDR_OWVAR 20
12044: PUSH
12045: LD_INT 3
12047: ST_TO_ADDR
// uc_nation := 3 ;
12048: LD_ADDR_OWVAR 21
12052: PUSH
12053: LD_INT 3
12055: ST_TO_ADDR
// InitHc ;
12056: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
12060: LD_ADDR_VAR 0 5
12064: PUSH
12065: LD_STRING Mikhail
12067: PPUSH
12068: LD_INT 0
12070: PPUSH
12071: CALL 434 0 2
12075: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
12076: LD_INT 1
12078: PPUSH
12079: LD_INT 1
12081: PPUSH
12082: LD_INT 0
12084: PPUSH
12085: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12089: LD_ADDR_VAR 0 6
12093: PUSH
12094: LD_VAR 0 6
12098: PUSH
12099: CALL_OW 44
12103: ADD
12104: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
12105: LD_ADDR_VAR 0 6
12109: PUSH
12110: LD_VAR 0 6
12114: PUSH
12115: CALL_OW 44
12119: ADD
12120: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
12121: LD_INT 2
12123: PPUSH
12124: LD_INT 4
12126: PPUSH
12127: LD_INT 0
12129: PPUSH
12130: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
12134: LD_ADDR_VAR 0 6
12138: PUSH
12139: LD_VAR 0 6
12143: PUSH
12144: CALL_OW 44
12148: ADD
12149: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
12150: LD_VAR 0 5
12154: PPUSH
12155: LD_INT 17
12157: PPUSH
12158: LD_INT 0
12160: PPUSH
12161: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
12165: LD_VAR 0 5
12169: PPUSH
12170: LD_INT 210
12172: PPUSH
12173: LD_INT 63
12175: PPUSH
12176: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
12180: LD_VAR 0 5
12184: PPUSH
12185: LD_INT 208
12187: PPUSH
12188: LD_INT 62
12190: PPUSH
12191: CALL_OW 178
// for i in fake_russians do
12195: LD_ADDR_VAR 0 2
12199: PUSH
12200: LD_VAR 0 6
12204: PUSH
12205: FOR_IN
12206: IFFALSE 12284
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
12208: LD_VAR 0 2
12212: PPUSH
12213: LD_INT 17
12215: PPUSH
12216: LD_INT 0
12218: PPUSH
12219: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
12223: LD_VAR 0 2
12227: PPUSH
12228: LD_INT 215
12230: PPUSH
12231: LD_INT 67
12233: PPUSH
12234: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
12238: LD_VAR 0 2
12242: PPUSH
12243: LD_INT 208
12245: PPUSH
12246: LD_INT 62
12248: PPUSH
12249: CALL_OW 178
// if GetClass ( i ) = 4 then
12253: LD_VAR 0 2
12257: PPUSH
12258: CALL_OW 257
12262: PUSH
12263: LD_INT 4
12265: EQUAL
12266: IFFALSE 12282
// ComHeal ( i , fake_cornel ) ;
12268: LD_VAR 0 2
12272: PPUSH
12273: LD_VAR 0 4
12277: PPUSH
12278: CALL_OW 128
// end ;
12282: GO 12205
12284: POP
12285: POP
// Wait ( 0 0$01 ) ;
12286: LD_INT 35
12288: PPUSH
12289: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
12293: LD_INT 208
12295: PPUSH
12296: LD_INT 62
12298: PPUSH
12299: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
12303: LD_INT 208
12305: PPUSH
12306: LD_INT 62
12308: PPUSH
12309: LD_INT 1
12311: PPUSH
12312: LD_INT 10
12314: NEG
12315: PPUSH
12316: CALL_OW 330
// Wait ( 0 0$15 ) ;
12320: LD_INT 525
12322: PPUSH
12323: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
12327: LD_INT 208
12329: PPUSH
12330: LD_INT 62
12332: PPUSH
12333: LD_INT 1
12335: PPUSH
12336: CALL_OW 331
// ResetFog ;
12340: CALL_OW 335
// InGameOff ;
12344: CALL_OW 9
// end ;
12348: LD_VAR 0 1
12352: RET
// every 0 0$30 trigger GetDistUnits ( JMM , Cornel ) < 3 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) do
12353: LD_EXP 31
12357: PPUSH
12358: LD_EXP 38
12362: PPUSH
12363: CALL_OW 296
12367: PUSH
12368: LD_INT 3
12370: LESS
12371: PUSH
12372: LD_INT 22
12374: PUSH
12375: LD_INT 4
12377: PUSH
12378: EMPTY
12379: LIST
12380: LIST
12381: PUSH
12382: LD_INT 21
12384: PUSH
12385: LD_INT 3
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: PPUSH
12396: CALL_OW 69
12400: AND
12401: IFFALSE 12419
12403: GO 12405
12405: DISABLE
// begin enable ;
12406: ENABLE
// SayRadio ( Powell , DWarn-Pow-1 ) ;
12407: LD_EXP 40
12411: PPUSH
12412: LD_STRING DWarn-Pow-1
12414: PPUSH
12415: CALL_OW 94
// end ; end_of_file
12419: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
12420: LD_EXP 6
12424: IFFALSE 13455
12426: GO 12428
12428: DISABLE
12429: LD_INT 0
12431: PPUSH
12432: PPUSH
12433: PPUSH
12434: PPUSH
12435: PPUSH
12436: PPUSH
12437: PPUSH
12438: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
12439: LD_EXP 38
12443: PUSH
12444: LD_EXP 39
12448: ADD
12449: PUSH
12450: LD_EXP 4
12454: ADD
12455: PPUSH
12456: LD_INT 250
12458: PPUSH
12459: LD_INT 120
12461: PPUSH
12462: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
12466: LD_ADDR_VAR 0 2
12470: PUSH
12471: LD_EXP 4
12475: PPUSH
12476: LD_INT 25
12478: PUSH
12479: LD_INT 2
12481: PUSH
12482: EMPTY
12483: LIST
12484: LIST
12485: PPUSH
12486: CALL_OW 72
12490: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
12491: LD_ADDR_VAR 0 3
12495: PUSH
12496: LD_EXP 4
12500: PPUSH
12501: LD_INT 21
12503: PUSH
12504: LD_INT 1
12506: PUSH
12507: EMPTY
12508: LIST
12509: LIST
12510: PPUSH
12511: CALL_OW 72
12515: ST_TO_ADDR
// if not has_eng then
12516: LD_VAR 0 2
12520: NOT
12521: IFFALSE 12604
// begin uc_side := 4 ;
12523: LD_ADDR_OWVAR 20
12527: PUSH
12528: LD_INT 4
12530: ST_TO_ADDR
// uc_nation := 1 ;
12531: LD_ADDR_OWVAR 21
12535: PUSH
12536: LD_INT 1
12538: ST_TO_ADDR
// bc_type := b_depot ;
12539: LD_ADDR_OWVAR 42
12543: PUSH
12544: LD_INT 0
12546: ST_TO_ADDR
// bc_level := 2 ;
12547: LD_ADDR_OWVAR 43
12551: PUSH
12552: LD_INT 2
12554: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
12555: LD_ADDR_VAR 0 4
12559: PUSH
12560: LD_INT 264
12562: PPUSH
12563: LD_INT 120
12565: PPUSH
12566: LD_INT 4
12568: PPUSH
12569: CALL_OW 47
12573: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
12574: LD_INT 264
12576: PPUSH
12577: LD_INT 120
12579: PPUSH
12580: LD_INT 4
12582: PPUSH
12583: LD_INT 10
12585: NEG
12586: PPUSH
12587: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
12591: LD_INT 264
12593: PPUSH
12594: LD_INT 120
12596: PPUSH
12597: LD_INT 4
12599: PPUSH
12600: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
12604: LD_INT 35
12606: PPUSH
12607: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
12611: LD_EXP 38
12615: PPUSH
12616: LD_INT 10
12618: PPUSH
12619: CALL_OW 308
12623: IFFALSE 12604
// if has_eng and not dep then
12625: LD_VAR 0 2
12629: PUSH
12630: LD_VAR 0 4
12634: NOT
12635: AND
12636: IFFALSE 12750
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
12638: LD_VAR 0 2
12642: PPUSH
12643: LD_INT 0
12645: PPUSH
12646: LD_INT 264
12648: PPUSH
12649: LD_INT 120
12651: PPUSH
12652: LD_INT 4
12654: PPUSH
12655: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
12659: LD_INT 35
12661: PPUSH
12662: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
12666: LD_INT 22
12668: PUSH
12669: LD_INT 4
12671: PUSH
12672: EMPTY
12673: LIST
12674: LIST
12675: PUSH
12676: LD_INT 30
12678: PUSH
12679: LD_INT 0
12681: PUSH
12682: EMPTY
12683: LIST
12684: LIST
12685: PUSH
12686: LD_INT 3
12688: PUSH
12689: LD_INT 57
12691: PUSH
12692: EMPTY
12693: LIST
12694: PUSH
12695: EMPTY
12696: LIST
12697: LIST
12698: PUSH
12699: EMPTY
12700: LIST
12701: LIST
12702: LIST
12703: PPUSH
12704: CALL_OW 69
12708: IFFALSE 12659
// dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
12710: LD_ADDR_VAR 0 4
12714: PUSH
12715: LD_INT 22
12717: PUSH
12718: LD_INT 4
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: PUSH
12725: LD_INT 30
12727: PUSH
12728: LD_INT 0
12730: PUSH
12731: EMPTY
12732: LIST
12733: LIST
12734: PUSH
12735: EMPTY
12736: LIST
12737: LIST
12738: PPUSH
12739: CALL_OW 69
12743: PUSH
12744: LD_INT 1
12746: ARRAY
12747: ST_TO_ADDR
// end else
12748: GO 12867
// begin SetSide ( dep , 4 ) ;
12750: LD_VAR 0 4
12754: PPUSH
12755: LD_INT 4
12757: PPUSH
12758: CALL_OW 235
// for i = 1 to 3 do
12762: LD_ADDR_VAR 0 1
12766: PUSH
12767: DOUBLE
12768: LD_INT 1
12770: DEC
12771: ST_TO_ADDR
12772: LD_INT 3
12774: PUSH
12775: FOR_TO
12776: IFFALSE 12833
// begin ComEnterUnit ( filter [ i ] , dep ) ;
12778: LD_VAR 0 3
12782: PUSH
12783: LD_VAR 0 1
12787: ARRAY
12788: PPUSH
12789: LD_VAR 0 4
12793: PPUSH
12794: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
12798: LD_VAR 0 3
12802: PUSH
12803: LD_VAR 0 1
12807: ARRAY
12808: PPUSH
12809: LD_INT 2
12811: PPUSH
12812: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
12816: LD_VAR 0 3
12820: PUSH
12821: LD_VAR 0 1
12825: ARRAY
12826: PPUSH
12827: CALL_OW 182
// end ;
12831: GO 12775
12833: POP
12834: POP
// repeat wait ( 0 0$01 ) ;
12835: LD_INT 35
12837: PPUSH
12838: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
12842: LD_VAR 0 3
12846: PPUSH
12847: LD_INT 25
12849: PUSH
12850: LD_INT 2
12852: PUSH
12853: EMPTY
12854: LIST
12855: LIST
12856: PPUSH
12857: CALL_OW 72
12861: PUSH
12862: LD_INT 3
12864: EQUAL
12865: IFFALSE 12835
// end ; if IsInUnit ( Cornel ) then
12867: LD_EXP 38
12871: PPUSH
12872: CALL_OW 310
12876: IFFALSE 12959
// begin cargo := IsInUnit ( Cornel ) ;
12878: LD_ADDR_VAR 0 7
12882: PUSH
12883: LD_EXP 38
12887: PPUSH
12888: CALL_OW 310
12892: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
12893: LD_VAR 0 7
12897: PPUSH
12898: LD_INT 1
12900: PPUSH
12901: CALL_OW 289
12905: IFFALSE 12921
// ComGive ( Cornel , dep ) ;
12907: LD_EXP 38
12911: PPUSH
12912: LD_VAR 0 4
12916: PPUSH
12917: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
12921: LD_EXP 38
12925: PPUSH
12926: LD_INT 235
12928: PPUSH
12929: LD_INT 122
12931: PPUSH
12932: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
12936: LD_EXP 38
12940: PPUSH
12941: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
12945: LD_EXP 38
12949: PPUSH
12950: LD_VAR 0 4
12954: PPUSH
12955: CALL_OW 180
// end ; ComEnterUnit ( Bierezov , dep ) ;
12959: LD_EXP 39
12963: PPUSH
12964: LD_VAR 0 4
12968: PPUSH
12969: CALL_OW 120
// has_eng := UnitFilter ( filter , [ f_class , 2 ] ) ;
12973: LD_ADDR_VAR 0 2
12977: PUSH
12978: LD_VAR 0 3
12982: PPUSH
12983: LD_INT 25
12985: PUSH
12986: LD_INT 2
12988: PUSH
12989: EMPTY
12990: LIST
12991: LIST
12992: PPUSH
12993: CALL_OW 72
12997: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
12998: LD_INT 35
13000: PPUSH
13001: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
13005: LD_ADDR_VAR 0 6
13009: PUSH
13010: LD_INT 10
13012: PPUSH
13013: CALL_OW 435
13017: ST_TO_ADDR
// if crates then
13018: LD_VAR 0 6
13022: IFFALSE 13051
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
13024: LD_VAR 0 2
13028: PPUSH
13029: LD_VAR 0 6
13033: PUSH
13034: LD_INT 1
13036: ARRAY
13037: PPUSH
13038: LD_VAR 0 6
13042: PUSH
13043: LD_INT 2
13045: ARRAY
13046: PPUSH
13047: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
13051: LD_VAR 0 4
13055: PPUSH
13056: CALL_OW 274
13060: PPUSH
13061: LD_INT 1
13063: PPUSH
13064: CALL_OW 275
13068: PUSH
13069: LD_INT 40
13071: GREATEREQUAL
13072: IFFALSE 12998
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
13074: LD_ADDR_VAR 0 5
13078: PUSH
13079: LD_INT 4
13081: PUSH
13082: LD_INT 256
13084: PUSH
13085: LD_INT 111
13087: PUSH
13088: LD_INT 2
13090: PUSH
13091: EMPTY
13092: LIST
13093: LIST
13094: LIST
13095: LIST
13096: PUSH
13097: LD_INT 31
13099: PUSH
13100: LD_INT 243
13102: PUSH
13103: LD_INT 112
13105: PUSH
13106: LD_INT 2
13108: PUSH
13109: EMPTY
13110: LIST
13111: LIST
13112: LIST
13113: LIST
13114: PUSH
13115: EMPTY
13116: LIST
13117: LIST
13118: ST_TO_ADDR
// for i in blist do
13119: LD_ADDR_VAR 0 1
13123: PUSH
13124: LD_VAR 0 5
13128: PUSH
13129: FOR_IN
13130: IFFALSE 13179
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
13132: LD_VAR 0 2
13136: PPUSH
13137: LD_VAR 0 1
13141: PUSH
13142: LD_INT 1
13144: ARRAY
13145: PPUSH
13146: LD_VAR 0 1
13150: PUSH
13151: LD_INT 2
13153: ARRAY
13154: PPUSH
13155: LD_VAR 0 1
13159: PUSH
13160: LD_INT 3
13162: ARRAY
13163: PPUSH
13164: LD_VAR 0 1
13168: PUSH
13169: LD_INT 4
13171: ARRAY
13172: PPUSH
13173: CALL_OW 205
13177: GO 13129
13179: POP
13180: POP
// repeat wait ( 0 0$01 ) ;
13181: LD_INT 35
13183: PPUSH
13184: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
13188: LD_INT 22
13190: PUSH
13191: LD_INT 4
13193: PUSH
13194: EMPTY
13195: LIST
13196: LIST
13197: PUSH
13198: LD_INT 30
13200: PUSH
13201: LD_INT 4
13203: PUSH
13204: EMPTY
13205: LIST
13206: LIST
13207: PUSH
13208: LD_INT 3
13210: PUSH
13211: LD_INT 57
13213: PUSH
13214: EMPTY
13215: LIST
13216: PUSH
13217: EMPTY
13218: LIST
13219: LIST
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: LIST
13225: PPUSH
13226: CALL_OW 69
13230: IFFALSE 13181
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
13232: LD_VAR 0 3
13236: PUSH
13237: LD_VAR 0 2
13241: DIFF
13242: PPUSH
13243: LD_INT 22
13245: PUSH
13246: LD_INT 4
13248: PUSH
13249: EMPTY
13250: LIST
13251: LIST
13252: PUSH
13253: LD_INT 30
13255: PUSH
13256: LD_INT 4
13258: PUSH
13259: EMPTY
13260: LIST
13261: LIST
13262: PUSH
13263: EMPTY
13264: LIST
13265: LIST
13266: PPUSH
13267: CALL_OW 69
13271: PUSH
13272: LD_INT 1
13274: ARRAY
13275: PPUSH
13276: CALL_OW 180
// repeat wait ( 0 0$01 ) ;
13280: LD_INT 35
13282: PPUSH
13283: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
13287: LD_INT 22
13289: PUSH
13290: LD_INT 4
13292: PUSH
13293: EMPTY
13294: LIST
13295: LIST
13296: PUSH
13297: LD_INT 30
13299: PUSH
13300: LD_INT 31
13302: PUSH
13303: EMPTY
13304: LIST
13305: LIST
13306: PUSH
13307: LD_INT 3
13309: PUSH
13310: LD_INT 57
13312: PUSH
13313: EMPTY
13314: LIST
13315: PUSH
13316: EMPTY
13317: LIST
13318: LIST
13319: PUSH
13320: EMPTY
13321: LIST
13322: LIST
13323: LIST
13324: PPUSH
13325: CALL_OW 69
13329: IFFALSE 13280
// sol := filter diff has_eng ;
13331: LD_ADDR_VAR 0 8
13335: PUSH
13336: LD_VAR 0 3
13340: PUSH
13341: LD_VAR 0 2
13345: DIFF
13346: ST_TO_ADDR
// if GetClass ( sol [ 1 ] ) > 1 then
13347: LD_VAR 0 8
13351: PUSH
13352: LD_INT 1
13354: ARRAY
13355: PPUSH
13356: CALL_OW 257
13360: PUSH
13361: LD_INT 1
13363: GREATER
13364: IFFALSE 13382
// SetClass ( sol [ 1 ] , 1 ) ;
13366: LD_VAR 0 8
13370: PUSH
13371: LD_INT 1
13373: ARRAY
13374: PPUSH
13375: LD_INT 1
13377: PPUSH
13378: CALL_OW 336
// ComExitBuilding ( sol [ 1 ] ) ;
13382: LD_VAR 0 8
13386: PUSH
13387: LD_INT 1
13389: ARRAY
13390: PPUSH
13391: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
13395: LD_VAR 0 8
13399: PUSH
13400: LD_INT 1
13402: ARRAY
13403: PPUSH
13404: LD_INT 22
13406: PUSH
13407: LD_INT 4
13409: PUSH
13410: EMPTY
13411: LIST
13412: LIST
13413: PUSH
13414: LD_INT 30
13416: PUSH
13417: LD_INT 31
13419: PUSH
13420: EMPTY
13421: LIST
13422: LIST
13423: PUSH
13424: EMPTY
13425: LIST
13426: LIST
13427: PPUSH
13428: CALL_OW 69
13432: PUSH
13433: LD_INT 1
13435: ARRAY
13436: PPUSH
13437: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
13441: LD_VAR 0 2
13445: PPUSH
13446: LD_VAR 0 4
13450: PPUSH
13451: CALL_OW 112
// end ;
13455: PPOPN 8
13457: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
13458: LD_EXP 9
13462: IFFALSE 13782
13464: GO 13466
13466: DISABLE
13467: LD_INT 0
13469: PPUSH
13470: PPUSH
13471: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
13472: LD_ADDR_VAR 0 2
13476: PUSH
13477: LD_INT 22
13479: PUSH
13480: LD_INT 4
13482: PUSH
13483: EMPTY
13484: LIST
13485: LIST
13486: PUSH
13487: LD_INT 30
13489: PUSH
13490: LD_INT 4
13492: PUSH
13493: EMPTY
13494: LIST
13495: LIST
13496: PUSH
13497: EMPTY
13498: LIST
13499: LIST
13500: PPUSH
13501: CALL_OW 69
13505: PUSH
13506: LD_INT 1
13508: ARRAY
13509: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
13510: LD_EXP 4
13514: PPUSH
13515: CALL_OW 122
// for i in cornel_units do
13519: LD_ADDR_VAR 0 1
13523: PUSH
13524: LD_EXP 4
13528: PUSH
13529: FOR_IN
13530: IFFALSE 13584
// if GetClass ( i ) = 2 then
13532: LD_VAR 0 1
13536: PPUSH
13537: CALL_OW 257
13541: PUSH
13542: LD_INT 2
13544: EQUAL
13545: IFFALSE 13582
// begin ComEnterUnit ( i , arm ) ;
13547: LD_VAR 0 1
13551: PPUSH
13552: LD_VAR 0 2
13556: PPUSH
13557: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
13561: LD_VAR 0 1
13565: PPUSH
13566: LD_INT 1
13568: PPUSH
13569: CALL_OW 183
// AddComExitBuilding ( i ) ;
13573: LD_VAR 0 1
13577: PPUSH
13578: CALL_OW 182
// end ;
13582: GO 13529
13584: POP
13585: POP
// Wait ( 1 1$00 ) ;
13586: LD_INT 2100
13588: PPUSH
13589: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
13593: LD_ADDR_VAR 0 3
13597: PUSH
13598: LD_EXP 38
13602: PUSH
13603: LD_EXP 39
13607: ADD
13608: PUSH
13609: LD_EXP 4
13613: ADD
13614: PUSH
13615: LD_EXP 4
13619: PPUSH
13620: LD_INT 21
13622: PUSH
13623: LD_INT 2
13625: PUSH
13626: EMPTY
13627: LIST
13628: LIST
13629: PPUSH
13630: CALL_OW 72
13634: DIFF
13635: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
13636: LD_VAR 0 3
13640: PPUSH
13641: LD_INT 248
13643: PPUSH
13644: LD_INT 85
13646: PPUSH
13647: CALL_OW 111
// AddComHold ( filter ) ;
13651: LD_VAR 0 3
13655: PPUSH
13656: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
13660: LD_INT 35
13662: PPUSH
13663: CALL_OW 67
// until cornel_attack ;
13667: LD_EXP 7
13671: IFFALSE 13660
// ComAgressiveMove ( filter , 209 , 63 ) ;
13673: LD_VAR 0 3
13677: PPUSH
13678: LD_INT 209
13680: PPUSH
13681: LD_INT 63
13683: PPUSH
13684: CALL_OW 114
// if Bierezov then
13688: LD_EXP 39
13692: IFFALSE 13782
// begin filter := filter diff Bierezov ;
13694: LD_ADDR_VAR 0 3
13698: PUSH
13699: LD_VAR 0 3
13703: PUSH
13704: LD_EXP 39
13708: DIFF
13709: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
13710: LD_EXP 39
13714: PPUSH
13715: LD_INT 6
13717: PPUSH
13718: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
13722: LD_EXP 39
13726: PPUSH
13727: LD_INT 235
13729: PPUSH
13730: LD_INT 60
13732: PPUSH
13733: CALL_OW 111
// AddComHold ( Bierezov ) ;
13737: LD_EXP 39
13741: PPUSH
13742: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
13746: LD_EXP 39
13750: PPUSH
13751: LD_INT 350
13753: PPUSH
13754: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
13758: LD_EXP 39
13762: PPUSH
13763: LD_INT 198
13765: PPUSH
13766: LD_INT 28
13768: PPUSH
13769: CALL_OW 171
// AddComHold ( Bierezov ) ;
13773: LD_EXP 39
13777: PPUSH
13778: CALL_OW 200
// end ; end ; end_of_file
13782: PPOPN 3
13784: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
13785: LD_EXP 47
13789: PUSH
13790: LD_EXP 27
13794: NOT
13795: AND
13796: PUSH
13797: LD_EXP 28
13801: NOT
13802: AND
13803: IFFALSE 14253
13805: GO 13807
13807: DISABLE
13808: LD_INT 0
13810: PPUSH
13811: PPUSH
13812: PPUSH
13813: PPUSH
// begin enable ;
13814: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
13815: LD_ADDR_VAR 0 4
13819: PUSH
13820: LD_INT 81
13822: PUSH
13823: LD_INT 3
13825: PUSH
13826: EMPTY
13827: LIST
13828: LIST
13829: PPUSH
13830: CALL_OW 69
13834: ST_TO_ADDR
// for i = 1 to ru_patrol do
13835: LD_ADDR_VAR 0 2
13839: PUSH
13840: DOUBLE
13841: LD_INT 1
13843: DEC
13844: ST_TO_ADDR
13845: LD_EXP 47
13849: PUSH
13850: FOR_TO
13851: IFFALSE 14251
// begin un := ru_patrol [ i ] ;
13853: LD_ADDR_VAR 0 1
13857: PUSH
13858: LD_EXP 47
13862: PUSH
13863: LD_VAR 0 2
13867: ARRAY
13868: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
13869: LD_VAR 0 1
13873: PPUSH
13874: LD_INT 13
13876: PPUSH
13877: CALL_OW 308
13881: IFFALSE 13986
// begin if not ru_alert then
13883: LD_EXP 54
13887: NOT
13888: IFFALSE 13898
// ru_alert := true ;
13890: LD_ADDR_EXP 54
13894: PUSH
13895: LD_INT 1
13897: ST_TO_ADDR
// if not See ( 1 , un ) then
13898: LD_INT 1
13900: PPUSH
13901: LD_VAR 0 1
13905: PPUSH
13906: CALL_OW 292
13910: NOT
13911: IFFALSE 13925
// SetLives ( un , 1000 ) ;
13913: LD_VAR 0 1
13917: PPUSH
13918: LD_INT 1000
13920: PPUSH
13921: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
13925: LD_ADDR_EXP 47
13929: PUSH
13930: LD_EXP 47
13934: PUSH
13935: LD_VAR 0 1
13939: DIFF
13940: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
13941: LD_VAR 0 1
13945: PPUSH
13946: LD_INT 22
13948: PUSH
13949: LD_INT 3
13951: PUSH
13952: EMPTY
13953: LIST
13954: LIST
13955: PUSH
13956: LD_INT 30
13958: PUSH
13959: LD_INT 4
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PUSH
13966: EMPTY
13967: LIST
13968: LIST
13969: PPUSH
13970: CALL_OW 69
13974: PPUSH
13975: CALL 1026 0 1
13979: PPUSH
13980: CALL_OW 120
// continue ;
13984: GO 13850
// end ; if IsOk ( un ) and not HasTask ( un ) then
13986: LD_VAR 0 1
13990: PPUSH
13991: CALL_OW 302
13995: PUSH
13996: LD_VAR 0 1
14000: PPUSH
14001: CALL_OW 314
14005: NOT
14006: AND
14007: IFFALSE 14100
// begin for j = 1 to ru_firepoints_south [ i ] do
14009: LD_ADDR_VAR 0 3
14013: PUSH
14014: DOUBLE
14015: LD_INT 1
14017: DEC
14018: ST_TO_ADDR
14019: LD_EXP 53
14023: PUSH
14024: LD_VAR 0 2
14028: ARRAY
14029: PUSH
14030: FOR_TO
14031: IFFALSE 14098
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
14033: LD_VAR 0 1
14037: PPUSH
14038: LD_EXP 53
14042: PUSH
14043: LD_VAR 0 2
14047: ARRAY
14048: PUSH
14049: LD_VAR 0 3
14053: ARRAY
14054: PUSH
14055: LD_INT 1
14057: ARRAY
14058: PPUSH
14059: LD_EXP 53
14063: PUSH
14064: LD_VAR 0 2
14068: ARRAY
14069: PUSH
14070: LD_VAR 0 3
14074: ARRAY
14075: PUSH
14076: LD_INT 2
14078: ARRAY
14079: PPUSH
14080: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
14084: LD_VAR 0 1
14088: PPUSH
14089: LD_INT 70
14091: PPUSH
14092: CALL_OW 202
// end ;
14096: GO 14030
14098: POP
14099: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
14100: LD_VAR 0 1
14104: PPUSH
14105: CALL_OW 256
14109: PUSH
14110: LD_INT 700
14112: LESS
14113: PUSH
14114: LD_VAR 0 1
14118: PPUSH
14119: LD_INT 13
14121: PPUSH
14122: CALL_OW 308
14126: NOT
14127: AND
14128: IFFALSE 14180
// begin ComMoveToArea ( un , retreatArea ) ;
14130: LD_VAR 0 1
14134: PPUSH
14135: LD_INT 13
14137: PPUSH
14138: CALL_OW 113
// if not ru_alert_xy then
14142: LD_EXP 55
14146: NOT
14147: IFFALSE 14178
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
14149: LD_ADDR_EXP 55
14153: PUSH
14154: LD_VAR 0 1
14158: PPUSH
14159: CALL_OW 250
14163: PUSH
14164: LD_VAR 0 1
14168: PPUSH
14169: CALL_OW 251
14173: PUSH
14174: EMPTY
14175: LIST
14176: LIST
14177: ST_TO_ADDR
// end else
14178: GO 14249
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
14180: LD_VAR 0 1
14184: PPUSH
14185: LD_VAR 0 4
14189: PPUSH
14190: LD_VAR 0 1
14194: PPUSH
14195: CALL_OW 74
14199: PPUSH
14200: CALL_OW 296
14204: PUSH
14205: LD_INT 9
14207: LESS
14208: PUSH
14209: LD_VAR 0 1
14213: PPUSH
14214: CALL_OW 256
14218: PUSH
14219: LD_INT 500
14221: GREATER
14222: AND
14223: IFFALSE 14249
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
14225: LD_VAR 0 1
14229: PPUSH
14230: LD_VAR 0 4
14234: PPUSH
14235: LD_VAR 0 1
14239: PPUSH
14240: CALL_OW 74
14244: PPUSH
14245: CALL_OW 115
// end ;
14249: GO 13850
14251: POP
14252: POP
// end ;
14253: PPOPN 4
14255: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
14256: LD_EXP 54
14260: PUSH
14261: LD_EXP 55
14265: AND
14266: PUSH
14267: LD_EXP 27
14271: NOT
14272: AND
14273: PUSH
14274: LD_EXP 28
14278: NOT
14279: AND
14280: IFFALSE 14490
14282: GO 14284
14284: DISABLE
14285: LD_INT 0
14287: PPUSH
14288: PPUSH
// begin enable ;
14289: ENABLE
// if not ru_vehicles then
14290: LD_EXP 50
14294: NOT
14295: IFFALSE 14299
// exit ;
14297: GO 14490
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14299: LD_ADDR_VAR 0 2
14303: PUSH
14304: LD_INT 81
14306: PUSH
14307: LD_INT 3
14309: PUSH
14310: EMPTY
14311: LIST
14312: LIST
14313: PPUSH
14314: CALL_OW 69
14318: ST_TO_ADDR
// if ru_vehicles then
14319: LD_EXP 50
14323: IFFALSE 14490
// begin for i in ru_vehicles do
14325: LD_ADDR_VAR 0 1
14329: PUSH
14330: LD_EXP 50
14334: PUSH
14335: FOR_IN
14336: IFFALSE 14488
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
14338: LD_VAR 0 1
14342: PPUSH
14343: CALL_OW 302
14347: PUSH
14348: LD_VAR 0 1
14352: PPUSH
14353: LD_VAR 0 2
14357: PPUSH
14358: LD_VAR 0 1
14362: PPUSH
14363: CALL_OW 74
14367: PPUSH
14368: CALL_OW 296
14372: PUSH
14373: LD_INT 9
14375: LESS
14376: AND
14377: IFFALSE 14403
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
14379: LD_VAR 0 1
14383: PPUSH
14384: LD_VAR 0 2
14388: PPUSH
14389: LD_VAR 0 1
14393: PPUSH
14394: CALL_OW 74
14398: PPUSH
14399: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
14403: LD_VAR 0 1
14407: PPUSH
14408: CALL_OW 314
14412: NOT
14413: PUSH
14414: LD_VAR 0 1
14418: PPUSH
14419: CALL_OW 302
14423: AND
14424: PUSH
14425: LD_VAR 0 1
14429: PPUSH
14430: LD_EXP 55
14434: PUSH
14435: LD_INT 1
14437: ARRAY
14438: PPUSH
14439: LD_EXP 55
14443: PUSH
14444: LD_INT 2
14446: ARRAY
14447: PPUSH
14448: CALL_OW 297
14452: PUSH
14453: LD_INT 10
14455: GREATER
14456: AND
14457: IFFALSE 14486
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
14459: LD_VAR 0 1
14463: PPUSH
14464: LD_EXP 55
14468: PUSH
14469: LD_INT 1
14471: ARRAY
14472: PPUSH
14473: LD_EXP 55
14477: PUSH
14478: LD_INT 2
14480: ARRAY
14481: PPUSH
14482: CALL_OW 114
// end ;
14486: GO 14335
14488: POP
14489: POP
// end ; end ;
14490: PPOPN 2
14492: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
14493: LD_EXP 55
14497: PUSH
14498: LD_EXP 54
14502: AND
14503: PUSH
14504: LD_INT 3
14506: PPUSH
14507: CALL_OW 463
14511: NOT
14512: AND
14513: PUSH
14514: LD_EXP 27
14518: NOT
14519: AND
14520: PUSH
14521: LD_EXP 28
14525: NOT
14526: AND
14527: IFFALSE 14622
14529: GO 14531
14531: DISABLE
14532: LD_INT 0
14534: PPUSH
// begin enable ;
14535: ENABLE
// ru_alert_xy := false ;
14536: LD_ADDR_EXP 55
14540: PUSH
14541: LD_INT 0
14543: ST_TO_ADDR
// ru_alert := false ;
14544: LD_ADDR_EXP 54
14548: PUSH
14549: LD_INT 0
14551: ST_TO_ADDR
// if ru_vehicles then
14552: LD_EXP 50
14556: IFFALSE 14622
// for i in ru_vehicles do
14558: LD_ADDR_VAR 0 1
14562: PUSH
14563: LD_EXP 50
14567: PUSH
14568: FOR_IN
14569: IFFALSE 14620
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
14571: LD_VAR 0 1
14575: PPUSH
14576: CALL_OW 302
14580: PUSH
14581: LD_VAR 0 1
14585: PPUSH
14586: LD_INT 89
14588: PPUSH
14589: LD_INT 36
14591: PPUSH
14592: CALL_OW 297
14596: PUSH
14597: LD_INT 10
14599: GREATER
14600: AND
14601: IFFALSE 14618
// ComMoveXY ( i , 89 , 36 ) ;
14603: LD_VAR 0 1
14607: PPUSH
14608: LD_INT 89
14610: PPUSH
14611: LD_INT 36
14613: PPUSH
14614: CALL_OW 111
14618: GO 14568
14620: POP
14621: POP
// end ;
14622: PPOPN 1
14624: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
14625: LD_EXP 49
14629: PUSH
14630: LD_EXP 27
14634: NOT
14635: AND
14636: PUSH
14637: LD_EXP 28
14641: NOT
14642: AND
14643: IFFALSE 14927
14645: GO 14647
14647: DISABLE
14648: LD_INT 0
14650: PPUSH
14651: PPUSH
14652: PPUSH
// begin enable ;
14653: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
14654: LD_ADDR_VAR 0 3
14658: PUSH
14659: LD_INT 81
14661: PUSH
14662: LD_INT 3
14664: PUSH
14665: EMPTY
14666: LIST
14667: LIST
14668: PPUSH
14669: CALL_OW 69
14673: ST_TO_ADDR
// for i = 1 to ru_forest do
14674: LD_ADDR_VAR 0 1
14678: PUSH
14679: DOUBLE
14680: LD_INT 1
14682: DEC
14683: ST_TO_ADDR
14684: LD_EXP 49
14688: PUSH
14689: FOR_TO
14690: IFFALSE 14925
// begin un := ru_forest [ i ] ;
14692: LD_ADDR_VAR 0 2
14696: PUSH
14697: LD_EXP 49
14701: PUSH
14702: LD_VAR 0 1
14706: ARRAY
14707: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
14708: LD_VAR 0 2
14712: PPUSH
14713: LD_INT 13
14715: PPUSH
14716: CALL_OW 308
14720: IFFALSE 14810
// begin if not See ( 1 , un ) then
14722: LD_INT 1
14724: PPUSH
14725: LD_VAR 0 2
14729: PPUSH
14730: CALL_OW 292
14734: NOT
14735: IFFALSE 14749
// SetLives ( un , 1000 ) ;
14737: LD_VAR 0 2
14741: PPUSH
14742: LD_INT 1000
14744: PPUSH
14745: CALL_OW 234
// ru_forest := ru_forest diff un ;
14749: LD_ADDR_EXP 49
14753: PUSH
14754: LD_EXP 49
14758: PUSH
14759: LD_VAR 0 2
14763: DIFF
14764: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
14765: LD_VAR 0 2
14769: PPUSH
14770: LD_INT 22
14772: PUSH
14773: LD_INT 3
14775: PUSH
14776: EMPTY
14777: LIST
14778: LIST
14779: PUSH
14780: LD_INT 30
14782: PUSH
14783: LD_INT 4
14785: PUSH
14786: EMPTY
14787: LIST
14788: LIST
14789: PUSH
14790: EMPTY
14791: LIST
14792: LIST
14793: PPUSH
14794: CALL_OW 69
14798: PPUSH
14799: CALL 1026 0 1
14803: PPUSH
14804: CALL_OW 120
// continue ;
14808: GO 14689
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
14810: LD_VAR 0 2
14814: PPUSH
14815: CALL_OW 256
14819: PUSH
14820: LD_INT 700
14822: LESS
14823: PUSH
14824: LD_VAR 0 2
14828: PPUSH
14829: LD_INT 13
14831: PPUSH
14832: CALL_OW 308
14836: NOT
14837: AND
14838: IFFALSE 14854
// ComMoveToArea ( un , retreatArea ) else
14840: LD_VAR 0 2
14844: PPUSH
14845: LD_INT 13
14847: PPUSH
14848: CALL_OW 113
14852: GO 14923
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
14854: LD_VAR 0 2
14858: PPUSH
14859: LD_VAR 0 3
14863: PPUSH
14864: LD_VAR 0 2
14868: PPUSH
14869: CALL_OW 74
14873: PPUSH
14874: CALL_OW 296
14878: PUSH
14879: LD_INT 9
14881: LESS
14882: PUSH
14883: LD_VAR 0 2
14887: PPUSH
14888: CALL_OW 256
14892: PUSH
14893: LD_INT 500
14895: GREATER
14896: AND
14897: IFFALSE 14923
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
14899: LD_VAR 0 2
14903: PPUSH
14904: LD_VAR 0 3
14908: PPUSH
14909: LD_VAR 0 2
14913: PPUSH
14914: CALL_OW 74
14918: PPUSH
14919: CALL_OW 115
// end ;
14923: GO 14689
14925: POP
14926: POP
// end ;
14927: PPOPN 3
14929: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
14930: LD_EXP 28
14934: NOT
14935: IFFALSE 15056
14937: GO 14939
14939: DISABLE
14940: LD_INT 0
14942: PPUSH
14943: PPUSH
// begin enable ;
14944: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
14945: LD_ADDR_VAR 0 2
14949: PUSH
14950: LD_INT 22
14952: PUSH
14953: LD_INT 3
14955: PUSH
14956: EMPTY
14957: LIST
14958: LIST
14959: PUSH
14960: LD_INT 21
14962: PUSH
14963: LD_INT 3
14965: PUSH
14966: EMPTY
14967: LIST
14968: LIST
14969: PUSH
14970: EMPTY
14971: LIST
14972: LIST
14973: PPUSH
14974: CALL_OW 69
14978: ST_TO_ADDR
// if filter then
14979: LD_VAR 0 2
14983: IFFALSE 15056
// for i in filter do
14985: LD_ADDR_VAR 0 1
14989: PUSH
14990: LD_VAR 0 2
14994: PUSH
14995: FOR_IN
14996: IFFALSE 15054
// if GetLives ( i ) < 990 then
14998: LD_VAR 0 1
15002: PPUSH
15003: CALL_OW 256
15007: PUSH
15008: LD_INT 990
15010: LESS
15011: IFFALSE 15052
// begin ru_alert := true ;
15013: LD_ADDR_EXP 54
15017: PUSH
15018: LD_INT 1
15020: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
15021: LD_ADDR_EXP 55
15025: PUSH
15026: LD_VAR 0 1
15030: PPUSH
15031: CALL_OW 250
15035: PUSH
15036: LD_VAR 0 1
15040: PPUSH
15041: CALL_OW 251
15045: PUSH
15046: EMPTY
15047: LIST
15048: LIST
15049: ST_TO_ADDR
// break ;
15050: GO 15054
// end ;
15052: GO 14995
15054: POP
15055: POP
// end ;
15056: PPOPN 2
15058: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
15059: LD_EXP 27
15063: IFFALSE 15202
15065: GO 15067
15067: DISABLE
15068: LD_INT 0
15070: PPUSH
15071: PPUSH
15072: PPUSH
15073: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
15074: LD_ADDR_VAR 0 4
15078: PUSH
15079: LD_EXP 50
15083: PUSH
15084: LD_EXP 49
15088: ADD
15089: PUSH
15090: LD_EXP 47
15094: ADD
15095: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
15096: LD_ADDR_VAR 0 3
15100: PUSH
15101: LD_INT 3
15103: PPUSH
15104: LD_INT 81
15106: PUSH
15107: LD_INT 3
15109: PUSH
15110: EMPTY
15111: LIST
15112: LIST
15113: PPUSH
15114: CALL_OW 70
15118: ST_TO_ADDR
// if filter and enemy then
15119: LD_VAR 0 4
15123: PUSH
15124: LD_VAR 0 3
15128: AND
15129: IFFALSE 15202
// repeat wait ( 0 0$01 ) ;
15131: LD_INT 35
15133: PPUSH
15134: CALL_OW 67
// for i in filter do
15138: LD_ADDR_VAR 0 1
15142: PUSH
15143: LD_VAR 0 4
15147: PUSH
15148: FOR_IN
15149: IFFALSE 15177
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
15151: LD_VAR 0 1
15155: PPUSH
15156: LD_VAR 0 3
15160: PPUSH
15161: LD_VAR 0 1
15165: PPUSH
15166: CALL_OW 74
15170: PPUSH
15171: CALL_OW 115
// end ;
15175: GO 15148
15177: POP
15178: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 ;
15179: LD_INT 3
15181: PPUSH
15182: LD_INT 81
15184: PUSH
15185: LD_INT 3
15187: PUSH
15188: EMPTY
15189: LIST
15190: LIST
15191: PPUSH
15192: CALL_OW 70
15196: PUSH
15197: LD_INT 0
15199: EQUAL
15200: IFFALSE 15131
// end ;
15202: PPOPN 4
15204: END
// every 0 0$03 trigger send_attack_on_cornel_base do var i ;
15205: LD_EXP 23
15209: IFFALSE 15258
15211: GO 15213
15213: DISABLE
15214: LD_INT 0
15216: PPUSH
// begin if not ru_cornel_attack then
15217: LD_EXP 52
15221: NOT
15222: IFFALSE 15226
// exit ;
15224: GO 15258
// for i in ru_cornel_attack do
15226: LD_ADDR_VAR 0 1
15230: PUSH
15231: LD_EXP 52
15235: PUSH
15236: FOR_IN
15237: IFFALSE 15256
// ComAgressiveMove ( i , 258 , 119 ) ;
15239: LD_VAR 0 1
15243: PPUSH
15244: LD_INT 258
15246: PPUSH
15247: LD_INT 119
15249: PPUSH
15250: CALL_OW 114
15254: GO 15236
15256: POP
15257: POP
// end ; end_of_file
15258: PPOPN 1
15260: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
15261: LD_EXP 3
15265: PUSH
15266: LD_EXP 7
15270: NOT
15271: AND
15272: PUSH
15273: LD_EXP 17
15277: AND
15278: IFFALSE 15390
15280: GO 15282
15282: DISABLE
15283: LD_INT 0
15285: PPUSH
// begin enable ;
15286: ENABLE
// crates_counter := crates_counter - 50 ;
15287: LD_ADDR_EXP 17
15291: PUSH
15292: LD_EXP 17
15296: PUSH
15297: LD_INT 50
15299: MINUS
15300: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
15301: LD_INT 8
15303: PPUSH
15304: LD_INT 2
15306: PPUSH
15307: LD_INT 5
15309: PPUSH
15310: CALL_OW 12
15314: PPUSH
15315: LD_INT 1
15317: PPUSH
15318: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
15322: LD_INT 1785
15324: PPUSH
15325: LD_INT 2345
15327: PPUSH
15328: CALL_OW 12
15332: PPUSH
15333: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
15337: LD_ADDR_VAR 0 1
15341: PUSH
15342: LD_INT 1
15344: PPUSH
15345: LD_OWVAR 67
15349: PUSH
15350: LD_INT 2
15352: PLUS
15353: PPUSH
15354: CALL_OW 12
15358: ST_TO_ADDR
// if r < 3 then
15359: LD_VAR 0 1
15363: PUSH
15364: LD_INT 3
15366: LESS
15367: IFFALSE 15390
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
15369: LD_INT 4
15371: PPUSH
15372: LD_INT 1
15374: PPUSH
15375: LD_INT 5
15377: PPUSH
15378: CALL_OW 12
15382: PPUSH
15383: LD_INT 1
15385: PPUSH
15386: CALL_OW 55
// end ;
15390: PPOPN 1
15392: END
// every 0 0$01 trigger cornel_active do
15393: LD_EXP 6
15397: IFFALSE 15486
15399: GO 15401
15401: DISABLE
// begin Wait ( 0 0$03 ) ;
15402: LD_INT 105
15404: PPUSH
15405: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15409: LD_INT 2
15411: PPUSH
15412: LD_INT 5
15414: PPUSH
15415: CALL_OW 12
15419: PPUSH
15420: LD_INT 10
15422: PPUSH
15423: LD_INT 1
15425: PPUSH
15426: CALL_OW 55
// Wait ( 0 0$13 ) ;
15430: LD_INT 455
15432: PPUSH
15433: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15437: LD_INT 2
15439: PPUSH
15440: LD_INT 5
15442: PPUSH
15443: CALL_OW 12
15447: PPUSH
15448: LD_INT 10
15450: PPUSH
15451: LD_INT 1
15453: PPUSH
15454: CALL_OW 55
// Wait ( 0 0$16 ) ;
15458: LD_INT 560
15460: PPUSH
15461: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
15465: LD_INT 2
15467: PPUSH
15468: LD_INT 5
15470: PPUSH
15471: CALL_OW 12
15475: PPUSH
15476: LD_INT 10
15478: PPUSH
15479: LD_INT 1
15481: PPUSH
15482: CALL_OW 55
// end ; end_of_file
15486: END
// every 0 0$01 trigger cornel_prepared do
15487: LD_EXP 9
15491: IFFALSE 15550
15493: GO 15495
15495: DISABLE
// begin enable ;
15496: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
15497: LD_ADDR_OWVAR 47
15501: PUSH
15502: LD_STRING #Am03-1
15504: PUSH
15505: LD_EXP 8
15509: PUSH
15510: EMPTY
15511: LIST
15512: LIST
15513: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
15514: LD_ADDR_EXP 8
15518: PUSH
15519: LD_EXP 8
15523: PPUSH
15524: LD_STRING -
15526: PPUSH
15527: CALL 1096 0 2
15531: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
15532: LD_EXP 8
15536: PUSH
15537: LD_INT 0
15539: EQUAL
15540: IFFALSE 15550
// begin Display_Strings := [ ] ;
15542: LD_ADDR_OWVAR 47
15546: PUSH
15547: EMPTY
15548: ST_TO_ADDR
// disable ;
15549: DISABLE
// end ; end ;
15550: END
// every 0 0$01 trigger debug and debug_strings do
15551: LD_EXP 1
15555: PUSH
15556: LD_OWVAR 48
15560: AND
15561: IFFALSE 15577
15563: GO 15565
15565: DISABLE
// begin enable ;
15566: ENABLE
// Display_Strings := debug_strings ;
15567: LD_ADDR_OWVAR 47
15571: PUSH
15572: LD_OWVAR 48
15576: ST_TO_ADDR
// end ; end_of_file
15577: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
15578: LD_VAR 0 1
15582: PPUSH
15583: CALL_OW 255
15587: PUSH
15588: LD_INT 1
15590: EQUAL
15591: PUSH
15592: LD_EXP 11
15596: NOT
15597: AND
15598: IFFALSE 15608
// solar_builded := true ;
15600: LD_ADDR_EXP 11
15604: PUSH
15605: LD_INT 1
15607: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
15608: LD_VAR 0 1
15612: PPUSH
15613: CALL_OW 255
15617: PUSH
15618: LD_INT 1
15620: EQUAL
15621: PUSH
15622: LD_EXP 25
15626: AND
15627: IFFALSE 15660
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
15629: LD_ADDR_EXP 25
15633: PUSH
15634: LD_EXP 25
15638: PUSH
15639: LD_INT 1750
15641: PUSH
15642: LD_INT 1400
15644: PUSH
15645: LD_INT 1225
15647: PUSH
15648: EMPTY
15649: LIST
15650: LIST
15651: LIST
15652: PUSH
15653: LD_OWVAR 67
15657: ARRAY
15658: PLUS
15659: ST_TO_ADDR
// if GetSide ( veh ) = 3 then
15660: LD_VAR 0 1
15664: PPUSH
15665: CALL_OW 255
15669: PUSH
15670: LD_INT 3
15672: EQUAL
15673: IFFALSE 15691
// ru_vehicles := ru_vehicles ^ veh ;
15675: LD_ADDR_EXP 50
15679: PUSH
15680: LD_EXP 50
15684: PUSH
15685: LD_VAR 0 1
15689: ADD
15690: ST_TO_ADDR
// end ;
15691: PPOPN 2
15693: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
15694: LD_VAR 0 1
15698: PUSH
15699: LD_EXP 47
15703: IN
15704: IFFALSE 15722
// ru_patrol := ru_patrol diff un ;
15706: LD_ADDR_EXP 47
15710: PUSH
15711: LD_EXP 47
15715: PUSH
15716: LD_VAR 0 1
15720: DIFF
15721: ST_TO_ADDR
// if un in ru_forest then
15722: LD_VAR 0 1
15726: PUSH
15727: LD_EXP 49
15731: IN
15732: IFFALSE 15750
// ru_forest := ru_forest diff un ;
15734: LD_ADDR_EXP 49
15738: PUSH
15739: LD_EXP 49
15743: PUSH
15744: LD_VAR 0 1
15748: DIFF
15749: ST_TO_ADDR
// if un in ru_vehicles then
15750: LD_VAR 0 1
15754: PUSH
15755: LD_EXP 50
15759: IN
15760: IFFALSE 15835
// begin ru_vehicles := ru_vehicles diff un ;
15762: LD_ADDR_EXP 50
15766: PUSH
15767: LD_EXP 50
15771: PUSH
15772: LD_VAR 0 1
15776: DIFF
15777: ST_TO_ADDR
// ru_produce_list := ru_produce_list ^ [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ;
15778: LD_ADDR_EXP 51
15782: PUSH
15783: LD_EXP 51
15787: PUSH
15788: LD_VAR 0 1
15792: PPUSH
15793: CALL_OW 265
15797: PUSH
15798: LD_VAR 0 1
15802: PPUSH
15803: CALL_OW 262
15807: PUSH
15808: LD_VAR 0 1
15812: PPUSH
15813: CALL_OW 263
15817: PUSH
15818: LD_VAR 0 1
15822: PPUSH
15823: CALL_OW 264
15827: PUSH
15828: EMPTY
15829: LIST
15830: LIST
15831: LIST
15832: LIST
15833: ADD
15834: ST_TO_ADDR
// end ; if un = JMM then
15835: LD_VAR 0 1
15839: PUSH
15840: LD_EXP 31
15844: EQUAL
15845: IFFALSE 15854
// YouLost ( 0 ) ;
15847: LD_STRING 0
15849: PPUSH
15850: CALL_OW 104
// if un = us_dep_west then
15854: LD_VAR 0 1
15858: PUSH
15859: LD_INT 1
15861: EQUAL
15862: IFFALSE 15871
// YouLost ( 2 ) ;
15864: LD_STRING 2
15866: PPUSH
15867: CALL_OW 104
// if un = Lynch and GetSide ( Lynch ) = 8 then
15871: LD_VAR 0 1
15875: PUSH
15876: LD_EXP 41
15880: EQUAL
15881: PUSH
15882: LD_EXP 41
15886: PPUSH
15887: CALL_OW 255
15891: PUSH
15892: LD_INT 8
15894: EQUAL
15895: AND
15896: IFFALSE 15905
// YouLost ( 4 ) ;
15898: LD_STRING 4
15900: PPUSH
15901: CALL_OW 104
// if un in jmm_units then
15905: LD_VAR 0 1
15909: PUSH
15910: LD_EXP 2
15914: IN
15915: IFFALSE 15931
// lose_counter := lose_counter + 1 ;
15917: LD_ADDR_EXP 30
15921: PUSH
15922: LD_EXP 30
15926: PUSH
15927: LD_INT 1
15929: PLUS
15930: ST_TO_ADDR
// end ;
15931: PPOPN 1
15933: END
// on EvacuateVehicle ( driver , vehicle , p1 , p2 ) do var i , place ;
15934: LD_INT 0
15936: PPUSH
15937: PPUSH
// begin if GetSide ( driver ) = 3 then
15938: LD_VAR 0 1
15942: PPUSH
15943: CALL_OW 255
15947: PUSH
15948: LD_INT 3
15950: EQUAL
15951: IFFALSE 16029
// begin place := FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ) ;
15953: LD_ADDR_VAR 0 6
15957: PUSH
15958: LD_INT 22
15960: PUSH
15961: LD_INT 3
15963: PUSH
15964: EMPTY
15965: LIST
15966: LIST
15967: PUSH
15968: LD_INT 30
15970: PUSH
15971: LD_INT 3
15973: PUSH
15974: EMPTY
15975: LIST
15976: LIST
15977: PUSH
15978: EMPTY
15979: LIST
15980: LIST
15981: PPUSH
15982: CALL_OW 69
15986: PPUSH
15987: CALL 1026 0 1
15991: ST_TO_ADDR
// if place then
15992: LD_VAR 0 6
15996: IFFALSE 16014
// ComEnterUnit ( driver , place ) else
15998: LD_VAR 0 1
16002: PPUSH
16003: LD_VAR 0 6
16007: PPUSH
16008: CALL_OW 120
16012: GO 16029
// ComMoveXY ( driver , 70 , 22 ) ;
16014: LD_VAR 0 1
16018: PPUSH
16019: LD_INT 70
16021: PPUSH
16022: LD_INT 22
16024: PPUSH
16025: CALL_OW 111
// end ; end ;
16029: PPOPN 6
16031: END
// every 0 0$01 trigger not game_end and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) < 4 do
16032: LD_EXP 29
16036: NOT
16037: PUSH
16038: LD_INT 22
16040: PUSH
16041: LD_INT 1
16043: PUSH
16044: EMPTY
16045: LIST
16046: LIST
16047: PUSH
16048: LD_INT 21
16050: PUSH
16051: LD_INT 1
16053: PUSH
16054: EMPTY
16055: LIST
16056: LIST
16057: PUSH
16058: EMPTY
16059: LIST
16060: LIST
16061: PPUSH
16062: CALL_OW 69
16066: PUSH
16067: LD_INT 22
16069: PUSH
16070: LD_INT 8
16072: PUSH
16073: EMPTY
16074: LIST
16075: LIST
16076: PUSH
16077: LD_INT 21
16079: PUSH
16080: LD_INT 1
16082: PUSH
16083: EMPTY
16084: LIST
16085: LIST
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: PPUSH
16091: CALL_OW 69
16095: PLUS
16096: PUSH
16097: LD_INT 4
16099: LESS
16100: AND
16101: IFFALSE 16113
16103: GO 16105
16105: DISABLE
// YouLost ( 1 ) ;
16106: LD_STRING 1
16108: PPUSH
16109: CALL_OW 104
16113: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
16114: LD_INT 1
16116: PPUSH
16117: CALL_OW 255
16121: PUSH
16122: LD_INT 3
16124: EQUAL
16125: IFFALSE 16137
16127: GO 16129
16129: DISABLE
// YouLost ( 3 ) ;
16130: LD_STRING 3
16132: PPUSH
16133: CALL_OW 104
16137: END
