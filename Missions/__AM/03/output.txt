// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 315 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 403 0 0
// PrepareRussian ;
  22: CALL 2899 0 0
// PrepareAmerican ;
  26: CALL 1156 0 0
// PrepareCornell ;
  30: CALL 2180 0 0
// PrepareWesternBase ;
  34: CALL 2406 0 0
// Action ;
  38: CALL 3956 0 0
// end ;
  42: END
// export debug ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end , lose_counter ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// jmm_units := 0 ;
  54: LD_ADDR_EXP 2
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// cornel_units := 0 ;
  62: LD_ADDR_EXP 4
  66: PUSH
  67: LD_INT 0
  69: ST_TO_ADDR
// bierezov_exist := false ;
  70: LD_ADDR_EXP 5
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// jmm_on_west := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// cornel_active := false ;
  86: LD_ADDR_EXP 6
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// cornel_attack := false ;
  94: LD_ADDR_EXP 7
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_prepared := false ;
 102: LD_ADDR_EXP 9
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 110: LD_ADDR_EXP 8
 114: PUSH
 115: LD_INT 4200
 117: ST_TO_ADDR
// frank_can_return := false ;
 118: LD_ADDR_EXP 10
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// solar_builded := false ;
 126: LD_ADDR_EXP 11
 130: PUSH
 131: LD_INT 0
 133: ST_TO_ADDR
// frank_send_to_scout := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// jmm_in_veh := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// bobby_in_veh := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// cyrus_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// lisa_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 174: LD_ADDR_EXP 24
 178: PUSH
 179: LD_INT 25200
 181: PUSH
 182: LD_INT 23100
 184: PUSH
 185: LD_INT 21000
 187: PUSH
 188: EMPTY
 189: LIST
 190: LIST
 191: LIST
 192: PUSH
 193: LD_OWVAR 67
 197: ARRAY
 198: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 199: LD_ADDR_EXP 17
 203: PUSH
 204: LD_INT 600
 206: PUSH
 207: LD_INT 500
 209: PUSH
 210: LD_INT 400
 212: PUSH
 213: EMPTY
 214: LIST
 215: LIST
 216: LIST
 217: PUSH
 218: LD_OWVAR 67
 222: ARRAY
 223: ST_TO_ADDR
// end_mission_allowed := false ;
 224: LD_ADDR_EXP 18
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// save_others := [ ] ;
 232: LD_ADDR_EXP 19
 236: PUSH
 237: EMPTY
 238: ST_TO_ADDR
// save_group := [ ] ;
 239: LD_ADDR_EXP 20
 243: PUSH
 244: EMPTY
 245: ST_TO_ADDR
// show_query := true ;
 246: LD_ADDR_EXP 21
 250: PUSH
 251: LD_INT 1
 253: ST_TO_ADDR
// wait_for_them := false ;
 254: LD_ADDR_EXP 22
 258: PUSH
 259: LD_INT 0
 261: ST_TO_ADDR
// veh_on_meta := false ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// send_spec_patrol := false ;
 270: LD_ADDR_EXP 25
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// prepare_siege := false ;
 278: LD_ADDR_EXP 26
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_attack_on_cornel := false ;
 286: LD_ADDR_EXP 27
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// game_end := false ;
 294: LD_ADDR_EXP 28
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// lose_counter := 0 ;
 302: LD_ADDR_EXP 29
 306: PUSH
 307: LD_INT 0
 309: ST_TO_ADDR
// end ;
 310: LD_VAR 0 1
 314: RET
// function SetDiplomacy ; begin
 315: LD_INT 0
 317: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 318: LD_INT 1
 320: PPUSH
 321: LD_INT 4
 323: PPUSH
 324: LD_INT 1
 326: PPUSH
 327: LD_INT 1
 329: PPUSH
 330: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 334: LD_INT 1
 336: PPUSH
 337: LD_INT 8
 339: PPUSH
 340: LD_INT 1
 342: PPUSH
 343: LD_INT 1
 345: PPUSH
 346: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 350: LD_INT 3
 352: PPUSH
 353: LD_INT 6
 355: PPUSH
 356: LD_INT 1
 358: PPUSH
 359: LD_INT 1
 361: PPUSH
 362: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 366: LD_INT 4
 368: PPUSH
 369: LD_INT 6
 371: PPUSH
 372: LD_INT 0
 374: PPUSH
 375: LD_INT 1
 377: PPUSH
 378: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 382: LD_INT 3
 384: PPUSH
 385: LD_INT 8
 387: PPUSH
 388: LD_INT 0
 390: PPUSH
 391: LD_INT 1
 393: PPUSH
 394: CALL_OW 80
// end ;
 398: LD_VAR 0 1
 402: RET
// export function DebugMode ; var i ; begin
 403: LD_INT 0
 405: PPUSH
 406: PPUSH
// FogOff ( 1 ) ;
 407: LD_INT 1
 409: PPUSH
 410: CALL_OW 344
// debug_strings := [ ] ;
 414: LD_ADDR_OWVAR 48
 418: PUSH
 419: EMPTY
 420: ST_TO_ADDR
// end ; end_of_file
 421: LD_VAR 0 1
 425: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 426: LD_INT 0
 428: PPUSH
 429: PPUSH
// if exist_mode then
 430: LD_VAR 0 2
 434: IFFALSE 453
// unit := CreateCharacter ( ident ) else
 436: LD_ADDR_VAR 0 4
 440: PUSH
 441: LD_VAR 0 1
 445: PPUSH
 446: CALL_OW 34
 450: ST_TO_ADDR
 451: GO 468
// unit := NewCharacter ( ident ) ;
 453: LD_ADDR_VAR 0 4
 457: PUSH
 458: LD_VAR 0 1
 462: PPUSH
 463: CALL_OW 25
 467: ST_TO_ADDR
// result := unit ;
 468: LD_ADDR_VAR 0 3
 472: PUSH
 473: LD_VAR 0 4
 477: ST_TO_ADDR
// end ;
 478: LD_VAR 0 3
 482: RET
// export function KickCharacter ( ident ) ; begin
 483: LD_INT 0
 485: PPUSH
// DeleteCharacters ( " & ident & " ) ;
 486: LD_STRING "
 488: PUSH
 489: LD_VAR 0 1
 493: STR
 494: PUSH
 495: LD_STRING "
 497: STR
 498: PPUSH
 499: CALL_OW 40
// end ;
 503: LD_VAR 0 2
 507: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 508: LD_INT 0
 510: PPUSH
// uc_side := side ;
 511: LD_ADDR_OWVAR 20
 515: PUSH
 516: LD_VAR 0 1
 520: ST_TO_ADDR
// uc_nation := nation ;
 521: LD_ADDR_OWVAR 21
 525: PUSH
 526: LD_VAR 0 2
 530: ST_TO_ADDR
// vc_chassis := chassis ;
 531: LD_ADDR_OWVAR 37
 535: PUSH
 536: LD_VAR 0 3
 540: ST_TO_ADDR
// vc_engine := engine ;
 541: LD_ADDR_OWVAR 39
 545: PUSH
 546: LD_VAR 0 4
 550: ST_TO_ADDR
// vc_control := control ;
 551: LD_ADDR_OWVAR 38
 555: PUSH
 556: LD_VAR 0 5
 560: ST_TO_ADDR
// vc_weapon := weapon ;
 561: LD_ADDR_OWVAR 40
 565: PUSH
 566: LD_VAR 0 6
 570: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 571: LD_ADDR_OWVAR 41
 575: PUSH
 576: LD_VAR 0 7
 580: ST_TO_ADDR
// result := CreateVehicle ;
 581: LD_ADDR_VAR 0 8
 585: PUSH
 586: CALL_OW 45
 590: ST_TO_ADDR
// end ;
 591: LD_VAR 0 8
 595: RET
// export function SayX ( units , ident ) ; var i ; begin
 596: LD_INT 0
 598: PPUSH
 599: PPUSH
// result := false ;
 600: LD_ADDR_VAR 0 3
 604: PUSH
 605: LD_INT 0
 607: ST_TO_ADDR
// if not units then
 608: LD_VAR 0 1
 612: NOT
 613: IFFALSE 617
// exit ;
 615: GO 671
// for i in units do
 617: LD_ADDR_VAR 0 4
 621: PUSH
 622: LD_VAR 0 1
 626: PUSH
 627: FOR_IN
 628: IFFALSE 669
// if IsOk ( i ) then
 630: LD_VAR 0 4
 634: PPUSH
 635: CALL_OW 302
 639: IFFALSE 667
// begin Say ( i , ident ) ;
 641: LD_VAR 0 4
 645: PPUSH
 646: LD_VAR 0 2
 650: PPUSH
 651: CALL_OW 88
// result := i ;
 655: LD_ADDR_VAR 0 3
 659: PUSH
 660: LD_VAR 0 4
 664: ST_TO_ADDR
// break ;
 665: GO 669
// end ;
 667: GO 627
 669: POP
 670: POP
// end ;
 671: LD_VAR 0 3
 675: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 676: LD_INT 0
 678: PPUSH
 679: PPUSH
 680: PPUSH
 681: PPUSH
// for i = 1 to count do
 682: LD_ADDR_VAR 0 8
 686: PUSH
 687: DOUBLE
 688: LD_INT 1
 690: DEC
 691: ST_TO_ADDR
 692: LD_VAR 0 6
 696: PUSH
 697: FOR_TO
 698: IFFALSE 779
// begin uc_side = side ;
 700: LD_ADDR_OWVAR 20
 704: PUSH
 705: LD_VAR 0 1
 709: ST_TO_ADDR
// uc_nation = nation ;
 710: LD_ADDR_OWVAR 21
 714: PUSH
 715: LD_VAR 0 2
 719: ST_TO_ADDR
// hc_gallery =  ;
 720: LD_ADDR_OWVAR 33
 724: PUSH
 725: LD_STRING 
 727: ST_TO_ADDR
// hc_name =  ;
 728: LD_ADDR_OWVAR 26
 732: PUSH
 733: LD_STRING 
 735: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 736: LD_INT 0
 738: PPUSH
 739: LD_VAR 0 5
 743: PPUSH
 744: LD_VAR 0 4
 748: PPUSH
 749: CALL_OW 380
// un = CreateHuman ;
 753: LD_ADDR_VAR 0 10
 757: PUSH
 758: CALL_OW 44
 762: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 763: LD_VAR 0 10
 767: PPUSH
 768: LD_VAR 0 3
 772: PPUSH
 773: CALL_OW 52
// end ;
 777: GO 697
 779: POP
 780: POP
// end ;
 781: LD_VAR 0 7
 785: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 786: LD_INT 0
 788: PPUSH
 789: PPUSH
 790: PPUSH
// uc_side := GetSide ( b ) ;
 791: LD_ADDR_OWVAR 20
 795: PUSH
 796: LD_VAR 0 2
 800: PPUSH
 801: CALL_OW 255
 805: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 806: LD_ADDR_OWVAR 21
 810: PUSH
 811: LD_VAR 0 2
 815: PPUSH
 816: CALL_OW 248
 820: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 821: LD_INT 0
 823: PPUSH
 824: LD_INT 1
 826: PPUSH
 827: LD_VAR 0 1
 831: PPUSH
 832: CALL_OW 380
// un = CreateHuman ;
 836: LD_ADDR_VAR 0 4
 840: PUSH
 841: CALL_OW 44
 845: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 846: LD_ADDR_VAR 0 5
 850: PUSH
 851: LD_VAR 0 2
 855: PPUSH
 856: CALL_OW 254
 860: PUSH
 861: LD_INT 3
 863: MINUS
 864: ST_TO_ADDR
// if dir < 0 then
 865: LD_VAR 0 5
 869: PUSH
 870: LD_INT 0
 872: LESS
 873: IFFALSE 889
// dir := 6 + dir ;
 875: LD_ADDR_VAR 0 5
 879: PUSH
 880: LD_INT 6
 882: PUSH
 883: LD_VAR 0 5
 887: PLUS
 888: ST_TO_ADDR
// SetDir ( un , dir ) ;
 889: LD_VAR 0 4
 893: PPUSH
 894: LD_VAR 0 5
 898: PPUSH
 899: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 903: LD_VAR 0 4
 907: PPUSH
 908: LD_VAR 0 2
 912: PPUSH
 913: CALL_OW 52
// end ;
 917: LD_VAR 0 3
 921: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 922: LD_INT 0
 924: PPUSH
 925: PPUSH
 926: PPUSH
// result := false ;
 927: LD_ADDR_VAR 0 2
 931: PUSH
 932: LD_INT 0
 934: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 935: LD_ADDR_VAR 0 3
 939: PUSH
 940: LD_INT 22
 942: PUSH
 943: LD_INT 1
 945: PUSH
 946: EMPTY
 947: LIST
 948: LIST
 949: PUSH
 950: LD_INT 34
 952: PUSH
 953: LD_INT 2
 955: PUSH
 956: EMPTY
 957: LIST
 958: LIST
 959: PUSH
 960: EMPTY
 961: LIST
 962: LIST
 963: PPUSH
 964: CALL_OW 69
 968: ST_TO_ADDR
// for i in filter do
 969: LD_ADDR_VAR 0 4
 973: PUSH
 974: LD_VAR 0 3
 978: PUSH
 979: FOR_IN
 980: IFFALSE 1011
// if IsDrivenBy ( i ) = unit then
 982: LD_VAR 0 4
 986: PPUSH
 987: CALL_OW 311
 991: PUSH
 992: LD_VAR 0 1
 996: EQUAL
 997: IFFALSE 1009
// begin result := true ;
 999: LD_ADDR_VAR 0 2
1003: PUSH
1004: LD_INT 1
1006: ST_TO_ADDR
// break ;
1007: GO 1011
// end ;
1009: GO 979
1011: POP
1012: POP
// end ;
1013: LD_VAR 0 2
1017: RET
// export function FindFreePlace ( blist ) ; var i ; begin
1018: LD_INT 0
1020: PPUSH
1021: PPUSH
// result := false ;
1022: LD_ADDR_VAR 0 2
1026: PUSH
1027: LD_INT 0
1029: ST_TO_ADDR
// if not blist then
1030: LD_VAR 0 1
1034: NOT
1035: IFFALSE 1039
// exit ;
1037: GO 1083
// for i in blist do
1039: LD_ADDR_VAR 0 3
1043: PUSH
1044: LD_VAR 0 1
1048: PUSH
1049: FOR_IN
1050: IFFALSE 1081
// if UnitsInside ( i ) < 6 then
1052: LD_VAR 0 3
1056: PPUSH
1057: CALL_OW 313
1061: PUSH
1062: LD_INT 6
1064: LESS
1065: IFFALSE 1079
// begin result := i ;
1067: LD_ADDR_VAR 0 2
1071: PUSH
1072: LD_VAR 0 3
1076: ST_TO_ADDR
// break ;
1077: GO 1081
// end ;
1079: GO 1049
1081: POP
1082: POP
// end ;
1083: LD_VAR 0 2
1087: RET
// export function Count ( timer , mode ) ; begin
1088: LD_INT 0
1090: PPUSH
// if not timer then
1091: LD_VAR 0 1
1095: NOT
1096: IFFALSE 1100
// exit ;
1098: GO 1151
// if mode in [ asc , up , + ] then
1100: LD_VAR 0 2
1104: PUSH
1105: LD_STRING asc
1107: PUSH
1108: LD_STRING up
1110: PUSH
1111: LD_STRING +
1113: PUSH
1114: EMPTY
1115: LIST
1116: LIST
1117: LIST
1118: IN
1119: IFFALSE 1137
// result := timer + 0 0$01 else
1121: LD_ADDR_VAR 0 3
1125: PUSH
1126: LD_VAR 0 1
1130: PUSH
1131: LD_INT 35
1133: PLUS
1134: ST_TO_ADDR
1135: GO 1151
// result := timer - 0 0$01 ;
1137: LD_ADDR_VAR 0 3
1141: PUSH
1142: LD_VAR 0 1
1146: PUSH
1147: LD_INT 35
1149: MINUS
1150: ST_TO_ADDR
// end ; end_of_file
1151: LD_VAR 0 3
1155: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1156: LD_INT 0
1158: PPUSH
1159: PPUSH
1160: PPUSH
1161: PPUSH
1162: PPUSH
1163: PPUSH
1164: PPUSH
1165: PPUSH
// uc_side := 4 ;
1166: LD_ADDR_OWVAR 20
1170: PUSH
1171: LD_INT 4
1173: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1174: LD_ADDR_EXP 39
1178: PUSH
1179: LD_STRING Powell
1181: PPUSH
1182: LD_INT 0
1184: PPUSH
1185: CALL 426 0 2
1189: ST_TO_ADDR
// uc_side := 1 ;
1190: LD_ADDR_OWVAR 20
1194: PUSH
1195: LD_INT 1
1197: ST_TO_ADDR
// uc_nation := 1 ;
1198: LD_ADDR_OWVAR 21
1202: PUSH
1203: LD_INT 1
1205: ST_TO_ADDR
// if debug then
1206: LD_EXP 1
1210: IFFALSE 1340
// begin for i = 1 to 4 do
1212: LD_ADDR_VAR 0 2
1216: PUSH
1217: DOUBLE
1218: LD_INT 1
1220: DEC
1221: ST_TO_ADDR
1222: LD_INT 4
1224: PUSH
1225: FOR_TO
1226: IFFALSE 1277
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1228: LD_INT 0
1230: PPUSH
1231: LD_INT 1
1233: PPUSH
1234: LD_INT 2
1236: PPUSH
1237: CALL_OW 12
1241: PPUSH
1242: LD_INT 3
1244: PPUSH
1245: CALL_OW 380
// un := CreateHuman ;
1249: LD_ADDR_VAR 0 3
1253: PUSH
1254: CALL_OW 44
1258: ST_TO_ADDR
// others := others ^ un ;
1259: LD_ADDR_VAR 0 5
1263: PUSH
1264: LD_VAR 0 5
1268: PUSH
1269: LD_VAR 0 3
1273: ADD
1274: ST_TO_ADDR
// end ;
1275: GO 1225
1277: POP
1278: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1279: LD_ADDR_VAR 0 6
1283: PUSH
1284: LD_INT 21
1286: PUSH
1287: LD_INT 1
1289: PUSH
1290: LD_INT 1
1292: PUSH
1293: LD_INT 51
1295: PUSH
1296: LD_INT 90
1298: PUSH
1299: LD_INT 504
1301: PUSH
1302: EMPTY
1303: LIST
1304: LIST
1305: LIST
1306: LIST
1307: LIST
1308: LIST
1309: PUSH
1310: LD_INT 21
1312: PUSH
1313: LD_INT 1
1315: PUSH
1316: LD_INT 1
1318: PUSH
1319: LD_INT 51
1321: PUSH
1322: LD_INT 80
1324: PUSH
1325: LD_INT 750
1327: PUSH
1328: EMPTY
1329: LIST
1330: LIST
1331: LIST
1332: LIST
1333: LIST
1334: LIST
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1340: LD_ADDR_EXP 30
1344: PUSH
1345: LD_STRING JMM
1347: PPUSH
1348: LD_EXP 1
1352: NOT
1353: PPUSH
1354: CALL 426 0 2
1358: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1359: LD_ADDR_EXP 31
1363: PUSH
1364: LD_STRING Bobby
1366: PPUSH
1367: LD_EXP 1
1371: NOT
1372: PPUSH
1373: CALL 426 0 2
1377: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1378: LD_ADDR_EXP 32
1382: PUSH
1383: LD_STRING Cyrus
1385: PPUSH
1386: LD_EXP 1
1390: NOT
1391: PPUSH
1392: CALL 426 0 2
1396: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1397: LD_ADDR_EXP 33
1401: PUSH
1402: LD_STRING Lisa
1404: PPUSH
1405: LD_EXP 1
1409: NOT
1410: PPUSH
1411: CALL 426 0 2
1415: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1416: LD_ADDR_EXP 34
1420: PUSH
1421: LD_STRING Khatam
1423: PPUSH
1424: LD_EXP 1
1428: NOT
1429: PPUSH
1430: CALL 426 0 2
1434: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1435: LD_ADDR_EXP 35
1439: PUSH
1440: LD_STRING Brian
1442: PPUSH
1443: LD_EXP 1
1447: NOT
1448: PPUSH
1449: CALL 426 0 2
1453: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1454: LD_ADDR_EXP 36
1458: PUSH
1459: LD_STRING Jerry
1461: PPUSH
1462: LD_EXP 1
1466: NOT
1467: PPUSH
1468: CALL 426 0 2
1472: ST_TO_ADDR
// if Bobby then
1473: LD_EXP 31
1477: IFFALSE 1508
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1479: LD_ADDR_VAR 0 4
1483: PUSH
1484: LD_VAR 0 4
1488: PPUSH
1489: LD_VAR 0 4
1493: PUSH
1494: LD_INT 1
1496: PLUS
1497: PPUSH
1498: LD_EXP 31
1502: PPUSH
1503: CALL_OW 2
1507: ST_TO_ADDR
// if Cyrus then
1508: LD_EXP 32
1512: IFFALSE 1543
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1514: LD_ADDR_VAR 0 4
1518: PUSH
1519: LD_VAR 0 4
1523: PPUSH
1524: LD_VAR 0 4
1528: PUSH
1529: LD_INT 1
1531: PLUS
1532: PPUSH
1533: LD_EXP 32
1537: PPUSH
1538: CALL_OW 2
1542: ST_TO_ADDR
// if Lisa then
1543: LD_EXP 33
1547: IFFALSE 1578
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1549: LD_ADDR_VAR 0 4
1553: PUSH
1554: LD_VAR 0 4
1558: PPUSH
1559: LD_VAR 0 4
1563: PUSH
1564: LD_INT 1
1566: PLUS
1567: PPUSH
1568: LD_EXP 33
1572: PPUSH
1573: CALL_OW 2
1577: ST_TO_ADDR
// if Khatam then
1578: LD_EXP 34
1582: IFFALSE 1613
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1584: LD_ADDR_VAR 0 4
1588: PUSH
1589: LD_VAR 0 4
1593: PPUSH
1594: LD_VAR 0 4
1598: PUSH
1599: LD_INT 1
1601: PLUS
1602: PPUSH
1603: LD_EXP 34
1607: PPUSH
1608: CALL_OW 2
1612: ST_TO_ADDR
// if Brian then
1613: LD_EXP 35
1617: IFFALSE 1648
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1619: LD_ADDR_VAR 0 4
1623: PUSH
1624: LD_VAR 0 4
1628: PPUSH
1629: LD_VAR 0 4
1633: PUSH
1634: LD_INT 1
1636: PLUS
1637: PPUSH
1638: LD_EXP 35
1642: PPUSH
1643: CALL_OW 2
1647: ST_TO_ADDR
// if Jerry then
1648: LD_EXP 36
1652: IFFALSE 1683
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1654: LD_ADDR_VAR 0 4
1658: PUSH
1659: LD_VAR 0 4
1663: PPUSH
1664: LD_VAR 0 4
1668: PUSH
1669: LD_INT 1
1671: PLUS
1672: PPUSH
1673: LD_EXP 36
1677: PPUSH
1678: CALL_OW 2
1682: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1683: LD_STRING 02_other_survivors
1685: PPUSH
1686: CALL_OW 28
1690: IFFALSE 1705
// others := CreateCharacterSet ( 02_other_survivors ) ;
1692: LD_ADDR_VAR 0 5
1696: PUSH
1697: LD_STRING 02_other_survivors
1699: PPUSH
1700: CALL_OW 31
1704: ST_TO_ADDR
// if others then
1705: LD_VAR 0 5
1709: IFFALSE 1734
// begin tmp := tmp ^ others ;
1711: LD_ADDR_VAR 0 4
1715: PUSH
1716: LD_VAR 0 4
1720: PUSH
1721: LD_VAR 0 5
1725: ADD
1726: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1727: LD_STRING 02_other_survivors
1729: PPUSH
1730: CALL_OW 40
// end ; jmm_units := tmp ;
1734: LD_ADDR_EXP 2
1738: PUSH
1739: LD_VAR 0 4
1743: ST_TO_ADDR
// if not vehicles then
1744: LD_VAR 0 6
1748: NOT
1749: IFFALSE 1767
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1751: LD_ADDR_VAR 0 6
1755: PUSH
1756: LD_STRING 02_tanks_1
1758: PPUSH
1759: LD_INT 0
1761: PPUSH
1762: CALL_OW 30
1766: ST_TO_ADDR
// if vehicles then
1767: LD_VAR 0 6
1771: IFFALSE 1965
// begin got_mech := false ;
1773: LD_ADDR_VAR 0 7
1777: PUSH
1778: LD_INT 0
1780: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1781: LD_VAR 0 4
1785: PPUSH
1786: LD_INT 25
1788: PUSH
1789: LD_INT 3
1791: PUSH
1792: EMPTY
1793: LIST
1794: LIST
1795: PPUSH
1796: CALL_OW 72
1800: IFFALSE 1810
// got_mech := true ;
1802: LD_ADDR_VAR 0 7
1806: PUSH
1807: LD_INT 1
1809: ST_TO_ADDR
// for i = 1 to vehicles do
1810: LD_ADDR_VAR 0 2
1814: PUSH
1815: DOUBLE
1816: LD_INT 1
1818: DEC
1819: ST_TO_ADDR
1820: LD_VAR 0 6
1824: PUSH
1825: FOR_TO
1826: IFFALSE 1963
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1828: LD_ADDR_VAR 0 3
1832: PUSH
1833: LD_INT 1
1835: PPUSH
1836: LD_INT 3
1838: PPUSH
1839: LD_VAR 0 6
1843: PUSH
1844: LD_VAR 0 2
1848: ARRAY
1849: PUSH
1850: LD_INT 1
1852: ARRAY
1853: PPUSH
1854: LD_VAR 0 6
1858: PUSH
1859: LD_VAR 0 2
1863: ARRAY
1864: PUSH
1865: LD_INT 2
1867: ARRAY
1868: PPUSH
1869: LD_VAR 0 6
1873: PUSH
1874: LD_VAR 0 2
1878: ARRAY
1879: PUSH
1880: LD_INT 3
1882: ARRAY
1883: PPUSH
1884: LD_VAR 0 6
1888: PUSH
1889: LD_VAR 0 2
1893: ARRAY
1894: PUSH
1895: LD_INT 4
1897: ARRAY
1898: PPUSH
1899: LD_INT 40
1901: PPUSH
1902: CALL 508 0 7
1906: ST_TO_ADDR
// if not got_mech then
1907: LD_VAR 0 7
1911: NOT
1912: IFFALSE 1938
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1914: LD_VAR 0 3
1918: PPUSH
1919: LD_VAR 0 6
1923: PUSH
1924: LD_VAR 0 2
1928: ARRAY
1929: PUSH
1930: LD_INT 6
1932: ARRAY
1933: PPUSH
1934: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1938: LD_ADDR_VAR 0 4
1942: PUSH
1943: LD_VAR 0 4
1947: PPUSH
1948: LD_INT 1
1950: PPUSH
1951: LD_VAR 0 3
1955: PPUSH
1956: CALL_OW 2
1960: ST_TO_ADDR
// end ;
1961: GO 1825
1963: POP
1964: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1965: LD_EXP 30
1969: PPUSH
1970: LD_INT 194
1972: PPUSH
1973: LD_INT 119
1975: PPUSH
1976: LD_INT 0
1978: PPUSH
1979: CALL_OW 48
// if tmp then
1983: LD_VAR 0 4
1987: IFFALSE 2112
// begin for i in tmp do
1989: LD_ADDR_VAR 0 2
1993: PUSH
1994: LD_VAR 0 4
1998: PUSH
1999: FOR_IN
2000: IFFALSE 2110
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2002: LD_ADDR_VAR 0 8
2006: PUSH
2007: LD_INT 22
2009: PUSH
2010: LD_INT 1
2012: PUSH
2013: EMPTY
2014: LIST
2015: LIST
2016: PUSH
2017: LD_INT 21
2019: PUSH
2020: LD_INT 2
2022: PUSH
2023: EMPTY
2024: LIST
2025: LIST
2026: PUSH
2027: LD_INT 58
2029: PUSH
2030: EMPTY
2031: LIST
2032: PUSH
2033: EMPTY
2034: LIST
2035: LIST
2036: LIST
2037: PPUSH
2038: CALL_OW 69
2042: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2043: LD_VAR 0 2
2047: PPUSH
2048: CALL_OW 247
2052: PUSH
2053: LD_INT 1
2055: EQUAL
2056: PUSH
2057: LD_VAR 0 8
2061: AND
2062: IFFALSE 2084
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2064: LD_VAR 0 2
2068: PPUSH
2069: LD_VAR 0 8
2073: PUSH
2074: LD_INT 1
2076: ARRAY
2077: PPUSH
2078: CALL_OW 52
2082: GO 2099
// PlaceUnitArea ( i , startArea , false ) ;
2084: LD_VAR 0 2
2088: PPUSH
2089: LD_INT 1
2091: PPUSH
2092: LD_INT 0
2094: PPUSH
2095: CALL_OW 49
// ComHold ( i ) ;
2099: LD_VAR 0 2
2103: PPUSH
2104: CALL_OW 140
// end ;
2108: GO 1999
2110: POP
2111: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2112: LD_ADDR_EXP 5
2116: PUSH
2117: LD_STRING 02_mikhailStatus_1
2119: PPUSH
2120: LD_INT 0
2122: PPUSH
2123: CALL_OW 30
2127: ST_TO_ADDR
// if not bierezov_exist and not debug then
2128: LD_EXP 5
2132: NOT
2133: PUSH
2134: LD_EXP 1
2138: NOT
2139: AND
2140: IFFALSE 2144
// exit ;
2142: GO 2175
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2144: LD_ADDR_EXP 38
2148: PUSH
2149: LD_STRING Mikhail
2151: PPUSH
2152: LD_INT 0
2154: PPUSH
2155: CALL 426 0 2
2159: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2160: LD_EXP 38
2164: PPUSH
2165: LD_INT 1
2167: PPUSH
2168: LD_INT 0
2170: PPUSH
2171: CALL_OW 49
// end ;
2175: LD_VAR 0 1
2179: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2180: LD_INT 0
2182: PPUSH
2183: PPUSH
2184: PPUSH
2185: PPUSH
// uc_side := 4 ;
2186: LD_ADDR_OWVAR 20
2190: PUSH
2191: LD_INT 4
2193: ST_TO_ADDR
// uc_nation := 1 ;
2194: LD_ADDR_OWVAR 21
2198: PUSH
2199: LD_INT 1
2201: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2202: LD_ADDR_EXP 37
2206: PUSH
2207: LD_STRING Cornell
2209: PPUSH
2210: LD_INT 0
2212: PPUSH
2213: CALL 426 0 2
2217: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
2218: LD_ADDR_EXP 4
2222: PUSH
2223: LD_INT 8
2225: PUSH
2226: LD_EXP 2
2230: MINUS
2231: ST_TO_ADDR
// tmp := [ ] ;
2232: LD_ADDR_VAR 0 2
2236: PUSH
2237: EMPTY
2238: ST_TO_ADDR
// if cornel_units < 3 then
2239: LD_EXP 4
2243: PUSH
2244: LD_INT 3
2246: LESS
2247: IFFALSE 2257
// cornel_units := 3 ;
2249: LD_ADDR_EXP 4
2253: PUSH
2254: LD_INT 3
2256: ST_TO_ADDR
// for i = 1 to cornel_units do
2257: LD_ADDR_VAR 0 4
2261: PUSH
2262: DOUBLE
2263: LD_INT 1
2265: DEC
2266: ST_TO_ADDR
2267: LD_EXP 4
2271: PUSH
2272: FOR_TO
2273: IFFALSE 2371
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2275: LD_INT 0
2277: PPUSH
2278: LD_INT 1
2280: PUSH
2281: LD_INT 1
2283: PUSH
2284: LD_INT 1
2286: PUSH
2287: LD_INT 2
2289: PUSH
2290: LD_INT 4
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: LIST
2297: LIST
2298: LIST
2299: PUSH
2300: LD_VAR 0 4
2304: PUSH
2305: LD_INT 5
2307: MOD
2308: PUSH
2309: LD_INT 1
2311: PLUS
2312: ARRAY
2313: PPUSH
2314: LD_INT 2
2316: PPUSH
2317: CALL_OW 380
// un := CreateHuman ;
2321: LD_ADDR_VAR 0 3
2325: PUSH
2326: CALL_OW 44
2330: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2331: LD_ADDR_VAR 0 2
2335: PUSH
2336: LD_VAR 0 2
2340: PPUSH
2341: LD_INT 1
2343: PPUSH
2344: LD_VAR 0 3
2348: PPUSH
2349: CALL_OW 2
2353: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2354: LD_VAR 0 3
2358: PPUSH
2359: LD_INT 2
2361: PPUSH
2362: LD_INT 0
2364: PPUSH
2365: CALL_OW 49
// end ;
2369: GO 2272
2371: POP
2372: POP
// cornel_units := tmp ;
2373: LD_ADDR_EXP 4
2377: PUSH
2378: LD_VAR 0 2
2382: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2383: LD_EXP 37
2387: PPUSH
2388: LD_INT 191
2390: PPUSH
2391: LD_INT 106
2393: PPUSH
2394: LD_INT 0
2396: PPUSH
2397: CALL_OW 48
// end ;
2401: LD_VAR 0 1
2405: RET
// export function PrepareWesternBase ; var i ; begin
2406: LD_INT 0
2408: PPUSH
2409: PPUSH
// uc_side := 8 ;
2410: LD_ADDR_OWVAR 20
2414: PUSH
2415: LD_INT 8
2417: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2418: LD_ADDR_EXP 40
2422: PUSH
2423: LD_STRING Lynch
2425: PPUSH
2426: LD_INT 0
2428: PPUSH
2429: CALL 426 0 2
2433: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2434: LD_ADDR_EXP 41
2438: PUSH
2439: LD_STRING Walker
2441: PPUSH
2442: LD_INT 0
2444: PPUSH
2445: CALL 426 0 2
2449: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2450: LD_ADDR_EXP 42
2454: PUSH
2455: LD_STRING Turner
2457: PPUSH
2458: LD_INT 0
2460: PPUSH
2461: CALL 426 0 2
2465: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2466: LD_ADDR_EXP 43
2470: PUSH
2471: LD_STRING Jillian
2473: PPUSH
2474: LD_INT 0
2476: PPUSH
2477: CALL 426 0 2
2481: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2482: LD_ADDR_VAR 0 2
2486: PUSH
2487: LD_EXP 40
2491: PUSH
2492: LD_EXP 41
2496: PUSH
2497: LD_EXP 42
2501: PUSH
2502: LD_EXP 43
2506: PUSH
2507: EMPTY
2508: LIST
2509: LIST
2510: LIST
2511: LIST
2512: PUSH
2513: FOR_IN
2514: IFFALSE 2542
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2516: LD_VAR 0 2
2520: PPUSH
2521: LD_INT 3
2523: PPUSH
2524: LD_INT 0
2526: PPUSH
2527: CALL_OW 49
// ComHold ( i ) ;
2531: LD_VAR 0 2
2535: PPUSH
2536: CALL_OW 140
// end ;
2540: GO 2513
2542: POP
2543: POP
// end ;
2544: LD_VAR 0 1
2548: RET
// export function SelectGroup ; var units , selected , i ; begin
2549: LD_INT 0
2551: PPUSH
2552: PPUSH
2553: PPUSH
2554: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2555: LD_ADDR_VAR 0 2
2559: PUSH
2560: LD_EXP 30
2564: PUSH
2565: LD_INT -3
2567: PUSH
2568: EMPTY
2569: LIST
2570: LIST
2571: PUSH
2572: LD_EXP 2
2576: ADD
2577: PUSH
2578: LD_INT -2
2580: PUSH
2581: LD_INT -4
2583: PUSH
2584: LD_EXP 37
2588: PUSH
2589: LD_EXP 38
2593: PUSH
2594: EMPTY
2595: LIST
2596: LIST
2597: LIST
2598: LIST
2599: ADD
2600: PUSH
2601: LD_INT -3
2603: PUSH
2604: EMPTY
2605: LIST
2606: ADD
2607: PUSH
2608: LD_EXP 4
2612: ADD
2613: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2614: LD_ADDR_VAR 0 3
2618: PUSH
2619: LD_EXP 30
2623: PUSH
2624: LD_STRING Select five characters to go with you
2626: PPUSH
2627: LD_INT 4
2629: PPUSH
2630: LD_INT 4
2632: PPUSH
2633: LD_VAR 0 2
2637: PPUSH
2638: EMPTY
2639: PPUSH
2640: CALL_OW 42
2644: ADD
2645: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2646: LD_ADDR_EXP 4
2650: PUSH
2651: LD_EXP 2
2655: PUSH
2656: LD_EXP 4
2660: UNION
2661: PUSH
2662: LD_VAR 0 3
2666: DIFF
2667: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2668: LD_ADDR_VAR 0 4
2672: PUSH
2673: LD_EXP 4
2677: PUSH
2678: LD_EXP 38
2682: ADD
2683: PUSH
2684: FOR_IN
2685: IFFALSE 2716
// if GetSide ( i ) = 1 then
2687: LD_VAR 0 4
2691: PPUSH
2692: CALL_OW 255
2696: PUSH
2697: LD_INT 1
2699: EQUAL
2700: IFFALSE 2714
// SetSide ( i , 4 ) ;
2702: LD_VAR 0 4
2706: PPUSH
2707: LD_INT 4
2709: PPUSH
2710: CALL_OW 235
2714: GO 2684
2716: POP
2717: POP
// for i in selected do
2718: LD_ADDR_VAR 0 4
2722: PUSH
2723: LD_VAR 0 3
2727: PUSH
2728: FOR_IN
2729: IFFALSE 2760
// if GetSide ( i ) = 4 then
2731: LD_VAR 0 4
2735: PPUSH
2736: CALL_OW 255
2740: PUSH
2741: LD_INT 4
2743: EQUAL
2744: IFFALSE 2758
// SetSide ( i , 1 ) ;
2746: LD_VAR 0 4
2750: PPUSH
2751: LD_INT 1
2753: PPUSH
2754: CALL_OW 235
2758: GO 2728
2760: POP
2761: POP
// if GetSide ( Bobby ) = 4 then
2762: LD_EXP 31
2766: PPUSH
2767: CALL_OW 255
2771: PUSH
2772: LD_INT 4
2774: EQUAL
2775: IFFALSE 2784
// DeleteCharacters ( Bobby ) ;
2777: LD_STRING Bobby
2779: PPUSH
2780: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2784: LD_EXP 32
2788: PPUSH
2789: CALL_OW 255
2793: PUSH
2794: LD_INT 4
2796: EQUAL
2797: IFFALSE 2806
// DeleteCharacters ( Cyrus ) ;
2799: LD_STRING Cyrus
2801: PPUSH
2802: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2806: LD_EXP 33
2810: PPUSH
2811: CALL_OW 255
2815: PUSH
2816: LD_INT 4
2818: EQUAL
2819: IFFALSE 2828
// DeleteCharacters ( Lisa ) ;
2821: LD_STRING Lisa
2823: PPUSH
2824: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2828: LD_EXP 34
2832: PPUSH
2833: CALL_OW 255
2837: PUSH
2838: LD_INT 4
2840: EQUAL
2841: IFFALSE 2850
// DeleteCharacters ( Khatam ) ;
2843: LD_STRING Khatam
2845: PPUSH
2846: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2850: LD_EXP 35
2854: PPUSH
2855: CALL_OW 255
2859: PUSH
2860: LD_INT 4
2862: EQUAL
2863: IFFALSE 2872
// DeleteCharacters ( Brian ) ;
2865: LD_STRING Brian
2867: PPUSH
2868: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2872: LD_EXP 36
2876: PPUSH
2877: CALL_OW 255
2881: PUSH
2882: LD_INT 4
2884: EQUAL
2885: IFFALSE 2894
// DeleteCharacters ( Jerry ) ;
2887: LD_STRING Jerry
2889: PPUSH
2890: CALL_OW 40
// end ; end_of_file
2894: LD_VAR 0 1
2898: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , b , un , veh , tw , bar , skill , vehicles , spot_xy ; begin
2899: LD_INT 0
2901: PPUSH
2902: PPUSH
2903: PPUSH
2904: PPUSH
2905: PPUSH
2906: PPUSH
2907: PPUSH
2908: PPUSH
2909: PPUSH
2910: PPUSH
// ru_alert := false ;
2911: LD_ADDR_EXP 51
2915: PUSH
2916: LD_INT 0
2918: ST_TO_ADDR
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
2919: LD_ADDR_VAR 0 6
2923: PUSH
2924: LD_INT 22
2926: PUSH
2927: LD_INT 3
2929: PUSH
2930: EMPTY
2931: LIST
2932: LIST
2933: PUSH
2934: LD_INT 2
2936: PUSH
2937: LD_INT 30
2939: PUSH
2940: LD_INT 31
2942: PUSH
2943: EMPTY
2944: LIST
2945: LIST
2946: PUSH
2947: LD_INT 30
2949: PUSH
2950: LD_INT 32
2952: PUSH
2953: EMPTY
2954: LIST
2955: LIST
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: LIST
2961: PUSH
2962: EMPTY
2963: LIST
2964: LIST
2965: PPUSH
2966: CALL_OW 69
2970: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
2971: LD_ADDR_VAR 0 7
2975: PUSH
2976: LD_INT 22
2978: PUSH
2979: LD_INT 3
2981: PUSH
2982: EMPTY
2983: LIST
2984: LIST
2985: PUSH
2986: LD_INT 30
2988: PUSH
2989: LD_INT 4
2991: PUSH
2992: EMPTY
2993: LIST
2994: LIST
2995: PUSH
2996: EMPTY
2997: LIST
2998: LIST
2999: PPUSH
3000: CALL_OW 69
3004: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
3005: LD_ADDR_VAR 0 2
3009: PUSH
3010: LD_INT 22
3012: PUSH
3013: LD_INT 3
3015: PUSH
3016: EMPTY
3017: LIST
3018: LIST
3019: PUSH
3020: LD_INT 30
3022: PUSH
3023: LD_INT 1
3025: PUSH
3026: EMPTY
3027: LIST
3028: LIST
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: PPUSH
3034: CALL_OW 69
3038: PUSH
3039: FOR_IN
3040: IFFALSE 3084
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
3042: LD_VAR 0 2
3046: PPUSH
3047: CALL_OW 274
3051: PPUSH
3052: LD_INT 1
3054: PPUSH
3055: LD_INT 1000
3057: PPUSH
3058: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 300 ) ;
3062: LD_VAR 0 2
3066: PPUSH
3067: CALL_OW 274
3071: PPUSH
3072: LD_INT 2
3074: PPUSH
3075: LD_INT 300
3077: PPUSH
3078: CALL_OW 277
// end ;
3082: GO 3039
3084: POP
3085: POP
// uc_side := 3 ;
3086: LD_ADDR_OWVAR 20
3090: PUSH
3091: LD_INT 3
3093: ST_TO_ADDR
// uc_nation := 3 ;
3094: LD_ADDR_OWVAR 21
3098: PUSH
3099: LD_INT 3
3101: ST_TO_ADDR
// skill := [ 2 , 2 , 3 ] [ Difficulty ] ;
3102: LD_ADDR_VAR 0 8
3106: PUSH
3107: LD_INT 2
3109: PUSH
3110: LD_INT 2
3112: PUSH
3113: LD_INT 3
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: LIST
3120: PUSH
3121: LD_OWVAR 67
3125: ARRAY
3126: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3127: LD_ADDR_EXP 45
3131: PUSH
3132: LD_STRING Pokryshkin
3134: PPUSH
3135: LD_INT 0
3137: PPUSH
3138: CALL 426 0 2
3142: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3143: LD_EXP 45
3147: PPUSH
3148: LD_INT 63
3150: PPUSH
3151: LD_INT 21
3153: PPUSH
3154: LD_INT 0
3156: PPUSH
3157: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3161: LD_EXP 45
3165: PPUSH
3166: CALL_OW 140
// InitHc ;
3170: CALL_OW 19
// for i in tw do
3174: LD_ADDR_VAR 0 2
3178: PUSH
3179: LD_VAR 0 6
3183: PUSH
3184: FOR_IN
3185: IFFALSE 3234
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3187: LD_VAR 0 2
3191: PPUSH
3192: LD_INT 42
3194: PUSH
3195: LD_INT 43
3197: PUSH
3198: EMPTY
3199: LIST
3200: LIST
3201: PUSH
3202: LD_INT 1
3204: PPUSH
3205: LD_INT 2
3207: PPUSH
3208: CALL_OW 12
3212: ARRAY
3213: PPUSH
3214: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3218: LD_VAR 0 8
3222: PPUSH
3223: LD_VAR 0 2
3227: PPUSH
3228: CALL 786 0 2
// end ;
3232: GO 3184
3234: POP
3235: POP
// for i in bar do
3236: LD_ADDR_VAR 0 2
3240: PUSH
3241: LD_VAR 0 7
3245: PUSH
3246: FOR_IN
3247: IFFALSE 3280
// begin PrepareHuman ( false , 1 , skill ) ;
3249: LD_INT 0
3251: PPUSH
3252: LD_INT 1
3254: PPUSH
3255: LD_VAR 0 8
3259: PPUSH
3260: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
3264: CALL_OW 44
3268: PPUSH
3269: LD_VAR 0 2
3273: PPUSH
3274: CALL_OW 52
// end ;
3278: GO 3246
3280: POP
3281: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3282: LD_ADDR_VAR 0 10
3286: PUSH
3287: LD_INT 100
3289: PUSH
3290: LD_INT 9
3292: PUSH
3293: EMPTY
3294: LIST
3295: LIST
3296: PUSH
3297: LD_INT 135
3299: PUSH
3300: LD_INT 60
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 41
3309: PUSH
3310: LD_INT 6
3312: PUSH
3313: EMPTY
3314: LIST
3315: LIST
3316: PUSH
3317: LD_INT 22
3319: PUSH
3320: LD_INT 9
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: PUSH
3327: LD_INT 84
3329: PUSH
3330: LD_INT 14
3332: PUSH
3333: EMPTY
3334: LIST
3335: LIST
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: LIST
3342: LIST
3343: ST_TO_ADDR
// vehicles := [ ] ;
3344: LD_ADDR_VAR 0 9
3348: PUSH
3349: EMPTY
3350: ST_TO_ADDR
// for i in spot_xy do
3351: LD_ADDR_VAR 0 2
3355: PUSH
3356: LD_VAR 0 10
3360: PUSH
3361: FOR_IN
3362: IFFALSE 3520
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun ] [ rand ( 1 , 3 ) ] , 100 ) ;
3364: LD_ADDR_VAR 0 5
3368: PUSH
3369: LD_INT 3
3371: PPUSH
3372: LD_INT 3
3374: PPUSH
3375: LD_INT 22
3377: PPUSH
3378: LD_INT 1
3380: PPUSH
3381: LD_INT 1
3383: PPUSH
3384: LD_INT 42
3386: PUSH
3387: LD_INT 43
3389: PUSH
3390: LD_INT 44
3392: PUSH
3393: EMPTY
3394: LIST
3395: LIST
3396: LIST
3397: PUSH
3398: LD_INT 1
3400: PPUSH
3401: LD_INT 3
3403: PPUSH
3404: CALL_OW 12
3408: ARRAY
3409: PPUSH
3410: LD_INT 100
3412: PPUSH
3413: CALL 508 0 7
3417: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3418: LD_ADDR_VAR 0 9
3422: PUSH
3423: LD_VAR 0 9
3427: PPUSH
3428: LD_VAR 0 9
3432: PUSH
3433: LD_INT 1
3435: PLUS
3436: PPUSH
3437: LD_VAR 0 5
3441: PPUSH
3442: CALL_OW 2
3446: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3447: LD_VAR 0 5
3451: PPUSH
3452: LD_INT 3
3454: PPUSH
3455: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3459: LD_VAR 0 5
3463: PPUSH
3464: LD_VAR 0 2
3468: PUSH
3469: LD_INT 1
3471: ARRAY
3472: PPUSH
3473: LD_VAR 0 2
3477: PUSH
3478: LD_INT 2
3480: ARRAY
3481: PPUSH
3482: LD_INT 0
3484: PPUSH
3485: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3489: LD_INT 0
3491: PPUSH
3492: LD_INT 3
3494: PPUSH
3495: LD_VAR 0 8
3499: PPUSH
3500: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3504: CALL_OW 44
3508: PPUSH
3509: LD_VAR 0 5
3513: PPUSH
3514: CALL_OW 52
// end ;
3518: GO 3361
3520: POP
3521: POP
// for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
3522: LD_ADDR_VAR 0 2
3526: PUSH
3527: DOUBLE
3528: LD_INT 1
3530: DEC
3531: ST_TO_ADDR
3532: LD_INT 5
3534: PUSH
3535: LD_INT 7
3537: PUSH
3538: LD_INT 8
3540: PUSH
3541: EMPTY
3542: LIST
3543: LIST
3544: LIST
3545: PUSH
3546: LD_OWVAR 67
3550: ARRAY
3551: PUSH
3552: FOR_TO
3553: IFFALSE 3613
// begin PrepareHuman ( false , 1 , skill ) ;
3555: LD_INT 0
3557: PPUSH
3558: LD_INT 1
3560: PPUSH
3561: LD_VAR 0 8
3565: PPUSH
3566: CALL_OW 380
// un := CreateHuman ;
3570: LD_ADDR_VAR 0 4
3574: PUSH
3575: CALL_OW 44
3579: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3580: LD_VAR 0 4
3584: PPUSH
3585: LD_INT 11
3587: PPUSH
3588: LD_INT 0
3590: PPUSH
3591: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3595: LD_ADDR_EXP 48
3599: PUSH
3600: LD_EXP 48
3604: PUSH
3605: LD_VAR 0 4
3609: ADD
3610: ST_TO_ADDR
// end ;
3611: GO 3552
3613: POP
3614: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3615: LD_ADDR_VAR 0 2
3619: PUSH
3620: DOUBLE
3621: LD_INT 1
3623: DEC
3624: ST_TO_ADDR
3625: LD_INT 2
3627: PUSH
3628: LD_INT 3
3630: PUSH
3631: LD_INT 4
3633: PUSH
3634: EMPTY
3635: LIST
3636: LIST
3637: LIST
3638: PUSH
3639: LD_OWVAR 67
3643: ARRAY
3644: PUSH
3645: FOR_TO
3646: IFFALSE 3706
// begin PrepareHuman ( false , 1 , skill ) ;
3648: LD_INT 0
3650: PPUSH
3651: LD_INT 1
3653: PPUSH
3654: LD_VAR 0 8
3658: PPUSH
3659: CALL_OW 380
// un := CreateHuman ;
3663: LD_ADDR_VAR 0 4
3667: PUSH
3668: CALL_OW 44
3672: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
3673: LD_VAR 0 4
3677: PPUSH
3678: LD_INT 12
3680: PPUSH
3681: LD_INT 0
3683: PPUSH
3684: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
3688: LD_ADDR_EXP 46
3692: PUSH
3693: LD_EXP 46
3697: PUSH
3698: LD_VAR 0 4
3702: ADD
3703: ST_TO_ADDR
// end ;
3704: GO 3645
3706: POP
3707: POP
// for i = 1 to 2 do
3708: LD_ADDR_VAR 0 2
3712: PUSH
3713: DOUBLE
3714: LD_INT 1
3716: DEC
3717: ST_TO_ADDR
3718: LD_INT 2
3720: PUSH
3721: FOR_TO
3722: IFFALSE 3788
// begin PrepareHuman ( sex_male , 1 , skill ) ;
3724: LD_INT 1
3726: PPUSH
3727: LD_INT 1
3729: PPUSH
3730: LD_VAR 0 8
3734: PPUSH
3735: CALL_OW 380
// un := CreateHuman ;
3739: LD_ADDR_VAR 0 4
3743: PUSH
3744: CALL_OW 44
3748: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
3749: LD_VAR 0 4
3753: PPUSH
3754: LD_INT 39
3756: PPUSH
3757: LD_INT 12
3759: PPUSH
3760: LD_INT 3
3762: PPUSH
3763: LD_INT 0
3765: PPUSH
3766: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
3770: LD_ADDR_EXP 47
3774: PUSH
3775: LD_EXP 47
3779: PUSH
3780: LD_VAR 0 4
3784: ADD
3785: ST_TO_ADDR
// end ;
3786: GO 3721
3788: POP
3789: POP
// ru_vehicles := vehicles ;
3790: LD_ADDR_EXP 49
3794: PUSH
3795: LD_VAR 0 9
3799: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
3800: LD_ADDR_EXP 50
3804: PUSH
3805: LD_INT 131
3807: PUSH
3808: LD_INT 121
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PUSH
3815: LD_INT 113
3817: PUSH
3818: LD_INT 90
3820: PUSH
3821: EMPTY
3822: LIST
3823: LIST
3824: PUSH
3825: LD_INT 93
3827: PUSH
3828: LD_INT 62
3830: PUSH
3831: EMPTY
3832: LIST
3833: LIST
3834: PUSH
3835: EMPTY
3836: LIST
3837: LIST
3838: LIST
3839: PUSH
3840: LD_INT 106
3842: PUSH
3843: LD_INT 54
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: PUSH
3850: LD_INT 120
3852: PUSH
3853: LD_INT 80
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PUSH
3860: LD_INT 143
3862: PUSH
3863: LD_INT 120
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: LIST
3874: PUSH
3875: LD_INT 154
3877: PUSH
3878: LD_INT 116
3880: PUSH
3881: EMPTY
3882: LIST
3883: LIST
3884: PUSH
3885: LD_INT 140
3887: PUSH
3888: LD_INT 93
3890: PUSH
3891: EMPTY
3892: LIST
3893: LIST
3894: PUSH
3895: LD_INT 130
3897: PUSH
3898: LD_INT 58
3900: PUSH
3901: EMPTY
3902: LIST
3903: LIST
3904: PUSH
3905: EMPTY
3906: LIST
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 105
3912: PUSH
3913: LD_INT 106
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PUSH
3920: LD_INT 134
3922: PUSH
3923: LD_INT 98
3925: PUSH
3926: EMPTY
3927: LIST
3928: LIST
3929: PUSH
3930: LD_INT 159
3932: PUSH
3933: LD_INT 113
3935: PUSH
3936: EMPTY
3937: LIST
3938: LIST
3939: PUSH
3940: EMPTY
3941: LIST
3942: LIST
3943: LIST
3944: PUSH
3945: EMPTY
3946: LIST
3947: LIST
3948: LIST
3949: LIST
3950: ST_TO_ADDR
// end ; end_of_file
3951: LD_VAR 0 1
3955: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
3956: LD_INT 0
3958: PPUSH
3959: PPUSH
3960: PPUSH
3961: PPUSH
3962: PPUSH
3963: PPUSH
3964: PPUSH
// InGameOn ;
3965: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
3969: LD_EXP 30
3973: PPUSH
3974: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
3978: LD_EXP 30
3982: PPUSH
3983: LD_EXP 37
3987: PPUSH
3988: CALL_OW 119
// if Bierezov then
3992: LD_EXP 38
3996: IFFALSE 4012
// ComTurnUnit ( Bierezov , Cornel ) ;
3998: LD_EXP 38
4002: PPUSH
4003: LD_EXP 37
4007: PPUSH
4008: CALL_OW 119
// for i in jmm_units do
4012: LD_ADDR_VAR 0 2
4016: PUSH
4017: LD_EXP 2
4021: PUSH
4022: FOR_IN
4023: IFFALSE 4041
// ComTurnUnit ( i , Cornel ) ;
4025: LD_VAR 0 2
4029: PPUSH
4030: LD_EXP 37
4034: PPUSH
4035: CALL_OW 119
4039: GO 4022
4041: POP
4042: POP
// units := cornel_units union Cornel ;
4043: LD_ADDR_VAR 0 3
4047: PUSH
4048: LD_EXP 4
4052: PUSH
4053: LD_EXP 37
4057: UNION
4058: ST_TO_ADDR
// repeat wait ( 1 ) ;
4059: LD_INT 1
4061: PPUSH
4062: CALL_OW 67
// for i in units do
4066: LD_ADDR_VAR 0 2
4070: PUSH
4071: LD_VAR 0 3
4075: PUSH
4076: FOR_IN
4077: IFFALSE 4110
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
4079: LD_VAR 0 2
4083: PPUSH
4084: LD_EXP 30
4088: PPUSH
4089: CALL_OW 250
4093: PPUSH
4094: LD_EXP 30
4098: PPUSH
4099: CALL_OW 251
4103: PPUSH
4104: CALL_OW 111
4108: GO 4076
4110: POP
4111: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
4112: LD_VAR 0 3
4116: PPUSH
4117: LD_INT 92
4119: PUSH
4120: LD_EXP 30
4124: PPUSH
4125: CALL_OW 250
4129: PUSH
4130: LD_EXP 30
4134: PPUSH
4135: CALL_OW 251
4139: PUSH
4140: LD_INT 10
4142: PUSH
4143: EMPTY
4144: LIST
4145: LIST
4146: LIST
4147: LIST
4148: PPUSH
4149: CALL_OW 72
4153: PUSH
4154: LD_VAR 0 3
4158: EQUAL
4159: IFFALSE 4059
// for i in units do
4161: LD_ADDR_VAR 0 2
4165: PUSH
4166: LD_VAR 0 3
4170: PUSH
4171: FOR_IN
4172: IFFALSE 4190
// ComTurnUnit ( i , JMM ) ;
4174: LD_VAR 0 2
4178: PPUSH
4179: LD_EXP 30
4183: PPUSH
4184: CALL_OW 119
4188: GO 4171
4190: POP
4191: POP
// ComTurnUnit ( Cornel , JMM ) ;
4192: LD_EXP 37
4196: PPUSH
4197: LD_EXP 30
4201: PPUSH
4202: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
4206: LD_EXP 30
4210: PPUSH
4211: LD_STRING D1-JMM-1
4213: PPUSH
4214: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
4218: LD_EXP 37
4222: PPUSH
4223: LD_STRING D1-Corn-1
4225: PPUSH
4226: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
4230: LD_EXP 30
4234: PPUSH
4235: LD_EXP 37
4239: PPUSH
4240: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
4244: LD_EXP 37
4248: PPUSH
4249: LD_EXP 30
4253: PPUSH
4254: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
4258: LD_INT 35
4260: PPUSH
4261: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
4265: LD_EXP 30
4269: PPUSH
4270: LD_EXP 37
4274: PPUSH
4275: CALL_OW 296
4279: PUSH
4280: LD_INT 6
4282: LESS
4283: IFFALSE 4258
// ChangeSideFog ( 4 , 1 ) ;
4285: LD_INT 4
4287: PPUSH
4288: LD_INT 1
4290: PPUSH
4291: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
4295: LD_EXP 30
4299: PPUSH
4300: LD_EXP 37
4304: PPUSH
4305: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
4309: LD_EXP 37
4313: PPUSH
4314: LD_EXP 30
4318: PPUSH
4319: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
4323: LD_EXP 30
4327: PPUSH
4328: LD_STRING D1-JMM-2
4330: PPUSH
4331: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
4335: LD_EXP 30
4339: PPUSH
4340: LD_STRING D1-JMM-2a
4342: PPUSH
4343: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
4347: LD_EXP 37
4351: PPUSH
4352: LD_STRING D1-Corn-2
4354: PPUSH
4355: CALL_OW 88
// if bierezov_exist or debug then
4359: LD_EXP 5
4363: PUSH
4364: LD_EXP 1
4368: OR
4369: IFFALSE 4610
// begin ComTurnUnit ( Cornel , Bierezov ) ;
4371: LD_EXP 37
4375: PPUSH
4376: LD_EXP 38
4380: PPUSH
4381: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
4385: LD_INT 10
4387: PPUSH
4388: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
4392: LD_EXP 37
4396: PPUSH
4397: LD_STRING D1a-Corn-1
4399: PPUSH
4400: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
4404: LD_EXP 30
4408: PPUSH
4409: LD_EXP 38
4413: PPUSH
4414: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
4418: LD_EXP 38
4422: PPUSH
4423: LD_EXP 30
4427: PPUSH
4428: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
4432: LD_EXP 30
4436: PPUSH
4437: LD_STRING D1a-JMM-1
4439: PPUSH
4440: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
4444: LD_EXP 30
4448: PPUSH
4449: LD_EXP 37
4453: PPUSH
4454: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
4458: LD_EXP 37
4462: PPUSH
4463: LD_EXP 30
4467: PPUSH
4468: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
4472: LD_EXP 37
4476: PPUSH
4477: LD_STRING D1a-Corn-2
4479: PPUSH
4480: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
4484: LD_EXP 30
4488: PPUSH
4489: LD_STRING D1a-JMM-2
4491: PPUSH
4492: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
4496: LD_EXP 37
4500: PPUSH
4501: LD_STRING D1a-Corn-3
4503: PPUSH
4504: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
4508: LD_EXP 30
4512: PPUSH
4513: LD_STRING D1a-JMM-3
4515: PPUSH
4516: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
4520: LD_EXP 37
4524: PPUSH
4525: LD_STRING D1a-Corn-4
4527: PPUSH
4528: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
4532: LD_EXP 30
4536: PPUSH
4537: LD_STRING D1a-JMM-4
4539: PPUSH
4540: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
4544: LD_EXP 37
4548: PPUSH
4549: LD_STRING D1a-Corn-5
4551: PPUSH
4552: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
4556: LD_EXP 38
4560: PPUSH
4561: LD_EXP 37
4565: PPUSH
4566: CALL_OW 250
4570: PPUSH
4571: LD_EXP 37
4575: PPUSH
4576: CALL_OW 251
4580: PUSH
4581: LD_INT 2
4583: MINUS
4584: PPUSH
4585: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
4589: LD_EXP 38
4593: PPUSH
4594: LD_EXP 37
4598: PPUSH
4599: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
4603: LD_INT 10
4605: PPUSH
4606: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
4610: LD_EXP 30
4614: PPUSH
4615: LD_STRING D1b-JMM-1
4617: PPUSH
4618: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
4622: LD_EXP 37
4626: PPUSH
4627: LD_STRING D1b-Corn-1
4629: PPUSH
4630: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
4634: LD_EXP 30
4638: PPUSH
4639: LD_STRING D1b-JMM-2
4641: PPUSH
4642: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
4646: LD_EXP 37
4650: PPUSH
4651: LD_STRING D1b-Corn-2
4653: PPUSH
4654: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
4658: LD_EXP 30
4662: PPUSH
4663: LD_STRING D1b-JMM-3
4665: PPUSH
4666: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
4670: LD_INT 10
4672: PPUSH
4673: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
4677: LD_EXP 39
4681: PPUSH
4682: LD_STRING D1b-Pow-3
4684: PPUSH
4685: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
4689: LD_EXP 30
4693: PPUSH
4694: LD_STRING D1b-JMM-4
4696: PPUSH
4697: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
4701: LD_EXP 37
4705: PPUSH
4706: LD_STRING D1b-Corn-4
4708: PPUSH
4709: CALL_OW 88
// if Khatam then
4713: LD_EXP 34
4717: IFFALSE 4733
// Say ( Khatam , D1b-Khat-4 ) else
4719: LD_EXP 34
4723: PPUSH
4724: LD_STRING D1b-Khat-4
4726: PPUSH
4727: CALL_OW 88
4731: GO 4769
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
4733: LD_EXP 4
4737: PPUSH
4738: LD_INT 26
4740: PUSH
4741: LD_INT 1
4743: PUSH
4744: EMPTY
4745: LIST
4746: LIST
4747: PPUSH
4748: CALL_OW 72
4752: PUSH
4753: LD_EXP 37
4757: PUSH
4758: EMPTY
4759: LIST
4760: DIFF
4761: PPUSH
4762: LD_STRING D1b-Sol1-4
4764: PPUSH
4765: CALL 596 0 2
// if Cyrus then
4769: LD_EXP 32
4773: IFFALSE 4787
// Say ( Cyrus , D1b-Cyrus-4 ) ;
4775: LD_EXP 32
4779: PPUSH
4780: LD_STRING D1b-Cyrus-4
4782: PPUSH
4783: CALL_OW 88
// if Lisa then
4787: LD_EXP 33
4791: IFFALSE 4849
// begin Say ( Lisa , D1b-Lisa-4 ) ;
4793: LD_EXP 33
4797: PPUSH
4798: LD_STRING D1b-Lisa-4
4800: PPUSH
4801: CALL_OW 88
// if Cyrus then
4805: LD_EXP 32
4809: IFFALSE 4849
// begin if not IsInUnit ( Cyrus ) then
4811: LD_EXP 32
4815: PPUSH
4816: CALL_OW 310
4820: NOT
4821: IFFALSE 4837
// ComTurnUnit ( Cyrus , Lisa ) ;
4823: LD_EXP 32
4827: PPUSH
4828: LD_EXP 33
4832: PPUSH
4833: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
4837: LD_EXP 32
4841: PPUSH
4842: LD_STRING D1b-Cyrus-5
4844: PPUSH
4845: CALL_OW 88
// end ; end ; SelectGroup ;
4849: CALL 2549 0 0
// Say ( JMM , D1d-JMM-1 ) ;
4853: LD_EXP 30
4857: PPUSH
4858: LD_STRING D1d-JMM-1
4860: PPUSH
4861: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
4865: LD_EXP 37
4869: PPUSH
4870: LD_STRING D1d-Corn-1
4872: PPUSH
4873: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
4877: LD_ADDR_VAR 0 2
4881: PUSH
4882: LD_EXP 2
4886: PUSH
4887: LD_EXP 4
4891: ADD
4892: PUSH
4893: LD_EXP 30
4897: ADD
4898: PUSH
4899: FOR_IN
4900: IFFALSE 4913
// ComHold ( i ) ;
4902: LD_VAR 0 2
4906: PPUSH
4907: CALL_OW 140
4911: GO 4899
4913: POP
4914: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
4915: LD_ADDR_VAR 0 4
4919: PUSH
4920: LD_INT 22
4922: PUSH
4923: LD_INT 1
4925: PUSH
4926: EMPTY
4927: LIST
4928: LIST
4929: PUSH
4930: LD_INT 21
4932: PUSH
4933: LD_INT 2
4935: PUSH
4936: EMPTY
4937: LIST
4938: LIST
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: PPUSH
4944: CALL_OW 69
4948: ST_TO_ADDR
// if vehicles then
4949: LD_VAR 0 4
4953: IFFALSE 5291
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
4955: LD_EXP 4
4959: PPUSH
4960: LD_INT 55
4962: PUSH
4963: EMPTY
4964: LIST
4965: PPUSH
4966: CALL_OW 72
4970: IFFALSE 5009
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
4972: LD_ADDR_VAR 0 2
4976: PUSH
4977: LD_EXP 4
4981: PPUSH
4982: LD_INT 55
4984: PUSH
4985: EMPTY
4986: LIST
4987: PPUSH
4988: CALL_OW 72
4992: PUSH
4993: FOR_IN
4994: IFFALSE 5007
// ComExitVehicle ( i ) ;
4996: LD_VAR 0 2
5000: PPUSH
5001: CALL_OW 121
5005: GO 4993
5007: POP
5008: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
5009: LD_ADDR_VAR 0 5
5013: PUSH
5014: LD_VAR 0 4
5018: PPUSH
5019: LD_INT 34
5021: PUSH
5022: LD_INT 51
5024: PUSH
5025: EMPTY
5026: LIST
5027: LIST
5028: PPUSH
5029: CALL_OW 72
5033: ST_TO_ADDR
// if cargos then
5034: LD_VAR 0 5
5038: IFFALSE 5221
// begin vehicles := cargos ;
5040: LD_ADDR_VAR 0 4
5044: PUSH
5045: LD_VAR 0 5
5049: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
5050: LD_ADDR_VAR 0 6
5054: PUSH
5055: LD_STRING 02_resources_4
5057: PPUSH
5058: LD_INT 0
5060: PPUSH
5061: CALL_OW 30
5065: ST_TO_ADDR
// if debug and not resources then
5066: LD_EXP 1
5070: PUSH
5071: LD_VAR 0 6
5075: NOT
5076: AND
5077: IFFALSE 5087
// resources := 160 ;
5079: LD_ADDR_VAR 0 6
5083: PUSH
5084: LD_INT 160
5086: ST_TO_ADDR
// if resources mod 10 then
5087: LD_VAR 0 6
5091: PUSH
5092: LD_INT 10
5094: MOD
5095: IFFALSE 5117
// resources := resources - resources mod 10 ;
5097: LD_ADDR_VAR 0 6
5101: PUSH
5102: LD_VAR 0 6
5106: PUSH
5107: LD_VAR 0 6
5111: PUSH
5112: LD_INT 10
5114: MOD
5115: MINUS
5116: ST_TO_ADDR
// if resources then
5117: LD_VAR 0 6
5121: IFFALSE 5221
// for i in cargos do
5123: LD_ADDR_VAR 0 2
5127: PUSH
5128: LD_VAR 0 5
5132: PUSH
5133: FOR_IN
5134: IFFALSE 5219
// begin if resources < 100 then
5136: LD_VAR 0 6
5140: PUSH
5141: LD_INT 100
5143: LESS
5144: IFFALSE 5166
// begin cargo := resources ;
5146: LD_ADDR_VAR 0 7
5150: PUSH
5151: LD_VAR 0 6
5155: ST_TO_ADDR
// resources := 0 ;
5156: LD_ADDR_VAR 0 6
5160: PUSH
5161: LD_INT 0
5163: ST_TO_ADDR
// end else
5164: GO 5188
// begin cargo := 100 ;
5166: LD_ADDR_VAR 0 7
5170: PUSH
5171: LD_INT 100
5173: ST_TO_ADDR
// resources := resources - 100 ;
5174: LD_ADDR_VAR 0 6
5178: PUSH
5179: LD_VAR 0 6
5183: PUSH
5184: LD_INT 100
5186: MINUS
5187: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
5188: LD_VAR 0 2
5192: PPUSH
5193: LD_INT 1
5195: PPUSH
5196: LD_VAR 0 7
5200: PPUSH
5201: CALL_OW 290
// if resources = 0 then
5205: LD_VAR 0 6
5209: PUSH
5210: LD_INT 0
5212: EQUAL
5213: IFFALSE 5217
// break ;
5215: GO 5219
// end ;
5217: GO 5133
5219: POP
5220: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
5221: LD_VAR 0 4
5225: PUSH
5226: LD_INT 1
5228: ARRAY
5229: PPUSH
5230: CALL_OW 311
5234: PPUSH
5235: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
5239: LD_VAR 0 4
5243: PUSH
5244: LD_INT 1
5246: ARRAY
5247: PPUSH
5248: LD_INT 4
5250: PPUSH
5251: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
5255: LD_EXP 37
5259: PPUSH
5260: LD_VAR 0 4
5264: PUSH
5265: LD_INT 1
5267: ARRAY
5268: PPUSH
5269: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
5273: LD_INT 35
5275: PPUSH
5276: CALL_OW 67
// until IsInUnit ( Cornel ) ;
5280: LD_EXP 37
5284: PPUSH
5285: CALL_OW 310
5289: IFFALSE 5273
// end ; InGameOff ;
5291: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
5295: LD_STRING M1
5297: PPUSH
5298: CALL_OW 337
// SaveForQuickRestart ;
5302: CALL_OW 22
// cornel_active := true ;
5306: LD_ADDR_EXP 6
5310: PUSH
5311: LD_INT 1
5313: ST_TO_ADDR
// end ;
5314: LD_VAR 0 1
5318: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
5319: LD_EXP 30
5323: PPUSH
5324: LD_EXP 40
5328: PPUSH
5329: CALL_OW 296
5333: PUSH
5334: LD_INT 10
5336: LESS
5337: IFFALSE 6452
5339: GO 5341
5341: DISABLE
5342: LD_INT 0
5344: PPUSH
5345: PPUSH
5346: PPUSH
5347: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
5348: LD_ADDR_VAR 0 2
5352: PUSH
5353: LD_INT 89
5355: PUSH
5356: LD_INT 34
5358: PUSH
5359: EMPTY
5360: LIST
5361: LIST
5362: PUSH
5363: LD_INT 138
5365: PUSH
5366: LD_INT 63
5368: PUSH
5369: EMPTY
5370: LIST
5371: LIST
5372: PUSH
5373: LD_INT 196
5375: PUSH
5376: LD_INT 84
5378: PUSH
5379: EMPTY
5380: LIST
5381: LIST
5382: PUSH
5383: LD_INT 135
5385: PUSH
5386: LD_INT 52
5388: PUSH
5389: EMPTY
5390: LIST
5391: LIST
5392: PUSH
5393: LD_INT 103
5395: PUSH
5396: LD_INT 39
5398: PUSH
5399: EMPTY
5400: LIST
5401: LIST
5402: PUSH
5403: LD_INT 58
5405: PUSH
5406: LD_INT 30
5408: PUSH
5409: EMPTY
5410: LIST
5411: LIST
5412: PUSH
5413: LD_INT 38
5415: PUSH
5416: LD_INT 51
5418: PUSH
5419: EMPTY
5420: LIST
5421: LIST
5422: PUSH
5423: EMPTY
5424: LIST
5425: LIST
5426: LIST
5427: LIST
5428: LIST
5429: LIST
5430: LIST
5431: ST_TO_ADDR
// InGameOn ;
5432: CALL_OW 8
// if jmm_units then
5436: LD_EXP 2
5440: IFFALSE 5504
// for i in jmm_units do
5442: LD_ADDR_VAR 0 1
5446: PUSH
5447: LD_EXP 2
5451: PUSH
5452: FOR_IN
5453: IFFALSE 5502
// begin if GetDistUnits ( i , JMM ) < 10 then
5455: LD_VAR 0 1
5459: PPUSH
5460: LD_EXP 30
5464: PPUSH
5465: CALL_OW 296
5469: PUSH
5470: LD_INT 10
5472: LESS
5473: IFFALSE 5491
// ComTurnUnit ( i , JMM ) else
5475: LD_VAR 0 1
5479: PPUSH
5480: LD_EXP 30
5484: PPUSH
5485: CALL_OW 119
5489: GO 5500
// ComHold ( i ) ;
5491: LD_VAR 0 1
5495: PPUSH
5496: CALL_OW 140
// end ;
5500: GO 5452
5502: POP
5503: POP
// ComMoveUnit ( JMM , Lynch ) ;
5504: LD_EXP 30
5508: PPUSH
5509: LD_EXP 40
5513: PPUSH
5514: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5518: LD_INT 35
5520: PPUSH
5521: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
5525: LD_EXP 30
5529: PPUSH
5530: LD_EXP 40
5534: PPUSH
5535: CALL_OW 296
5539: PUSH
5540: LD_INT 6
5542: LESS
5543: IFFALSE 5518
// ComTurnUnit ( JMM , Lynch ) ;
5545: LD_EXP 30
5549: PPUSH
5550: LD_EXP 40
5554: PPUSH
5555: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
5559: LD_ADDR_VAR 0 1
5563: PUSH
5564: LD_EXP 40
5568: PUSH
5569: LD_EXP 41
5573: PUSH
5574: LD_EXP 42
5578: PUSH
5579: LD_EXP 43
5583: PUSH
5584: EMPTY
5585: LIST
5586: LIST
5587: LIST
5588: LIST
5589: PUSH
5590: FOR_IN
5591: IFFALSE 5609
// ComTurnUnit ( i , JMM ) ;
5593: LD_VAR 0 1
5597: PPUSH
5598: LD_EXP 30
5602: PPUSH
5603: CALL_OW 119
5607: GO 5590
5609: POP
5610: POP
// Wait ( 0 0$0.3 ) ;
5611: LD_INT 10
5613: PPUSH
5614: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
5618: LD_EXP 30
5622: PPUSH
5623: LD_STRING D2-JMM-1
5625: PPUSH
5626: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
5630: LD_EXP 40
5634: PPUSH
5635: LD_STRING D2-Sol1-1
5637: PPUSH
5638: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
5642: LD_EXP 30
5646: PPUSH
5647: LD_STRING D2-JMM-2
5649: PPUSH
5650: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
5654: LD_EXP 40
5658: PPUSH
5659: LD_STRING D2-Sol1-2
5661: PPUSH
5662: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
5666: LD_EXP 30
5670: PPUSH
5671: LD_STRING D2-JMM-3
5673: PPUSH
5674: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
5678: LD_EXP 40
5682: PPUSH
5683: LD_STRING D2-Sol1-3
5685: PPUSH
5686: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
5690: LD_ADDR_VAR 0 1
5694: PUSH
5695: LD_INT 22
5697: PUSH
5698: LD_INT 8
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: PPUSH
5705: CALL_OW 69
5709: PUSH
5710: FOR_IN
5711: IFFALSE 5727
// SetSide ( i , 1 ) ;
5713: LD_VAR 0 1
5717: PPUSH
5718: LD_INT 1
5720: PPUSH
5721: CALL_OW 235
5725: GO 5710
5727: POP
5728: POP
// Say ( JMM , D2-JMM-4 ) ;
5729: LD_EXP 30
5733: PPUSH
5734: LD_STRING D2-JMM-4
5736: PPUSH
5737: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
5741: LD_INT 1
5743: PPUSH
5744: LD_INT 5
5746: PPUSH
5747: CALL_OW 332
// for i = 1 to points do
5751: LD_ADDR_VAR 0 1
5755: PUSH
5756: DOUBLE
5757: LD_INT 1
5759: DEC
5760: ST_TO_ADDR
5761: LD_VAR 0 2
5765: PUSH
5766: FOR_TO
5767: IFFALSE 5942
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
5769: LD_VAR 0 2
5773: PUSH
5774: LD_VAR 0 1
5778: ARRAY
5779: PUSH
5780: LD_INT 1
5782: ARRAY
5783: PPUSH
5784: LD_VAR 0 2
5788: PUSH
5789: LD_VAR 0 1
5793: ARRAY
5794: PUSH
5795: LD_INT 2
5797: ARRAY
5798: PPUSH
5799: CALL_OW 84
// if i = 1 then
5803: LD_VAR 0 1
5807: PUSH
5808: LD_INT 1
5810: EQUAL
5811: IFFALSE 5825
// Say ( Lynch , D2-Sol1-4 ) ;
5813: LD_EXP 40
5817: PPUSH
5818: LD_STRING D2-Sol1-4
5820: PPUSH
5821: CALL_OW 88
// if i = 2 then
5825: LD_VAR 0 1
5829: PUSH
5830: LD_INT 2
5832: EQUAL
5833: IFFALSE 5847
// Say ( JMM , D2-JMM-5 ) ;
5835: LD_EXP 30
5839: PPUSH
5840: LD_STRING D2-JMM-5
5842: PPUSH
5843: CALL_OW 88
// if i = 4 then
5847: LD_VAR 0 1
5851: PUSH
5852: LD_INT 4
5854: EQUAL
5855: IFFALSE 5879
// begin RevealFogArea ( 1 , troopsArea ) ;
5857: LD_INT 1
5859: PPUSH
5860: LD_INT 6
5862: PPUSH
5863: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
5867: LD_EXP 40
5871: PPUSH
5872: LD_STRING D2-Sol1-5
5874: PPUSH
5875: CALL_OW 88
// end ; if i = 5 then
5879: LD_VAR 0 1
5883: PUSH
5884: LD_INT 5
5886: EQUAL
5887: IFFALSE 5901
// Say ( JMM , D2-JMM-6 ) ;
5889: LD_EXP 30
5893: PPUSH
5894: LD_STRING D2-JMM-6
5896: PPUSH
5897: CALL_OW 88
// if i = 7 then
5901: LD_VAR 0 1
5905: PUSH
5906: LD_INT 7
5908: EQUAL
5909: IFFALSE 5933
// begin RevealFogArea ( 1 , forestArea ) ;
5911: LD_INT 1
5913: PPUSH
5914: LD_INT 7
5916: PPUSH
5917: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
5921: LD_EXP 40
5925: PPUSH
5926: LD_STRING D2-Sol1-6
5928: PPUSH
5929: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
5933: LD_INT 46
5935: PPUSH
5936: CALL_OW 67
// end ;
5940: GO 5766
5942: POP
5943: POP
// CenterNowOnUnits ( JMM ) ;
5944: LD_EXP 30
5948: PPUSH
5949: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
5953: LD_EXP 30
5957: PPUSH
5958: LD_STRING D2-JMM-7
5960: PPUSH
5961: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
5965: LD_EXP 40
5969: PPUSH
5970: LD_STRING D2-Sol1-7
5972: PPUSH
5973: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
5977: LD_EXP 30
5981: PPUSH
5982: LD_STRING D2-JMM-8
5984: PPUSH
5985: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
5989: LD_ADDR_VAR 0 4
5993: PUSH
5994: LD_INT 22
5996: PUSH
5997: LD_INT 1
5999: PUSH
6000: EMPTY
6001: LIST
6002: LIST
6003: PUSH
6004: LD_INT 30
6006: PUSH
6007: LD_INT 31
6009: PUSH
6010: EMPTY
6011: LIST
6012: LIST
6013: PUSH
6014: EMPTY
6015: LIST
6016: LIST
6017: PPUSH
6018: CALL_OW 69
6022: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
6023: LD_EXP 40
6027: PPUSH
6028: LD_VAR 0 4
6032: PUSH
6033: LD_INT 1
6035: ARRAY
6036: PPUSH
6037: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
6041: LD_ADDR_VAR 0 3
6045: PUSH
6046: LD_EXP 2
6050: PPUSH
6051: LD_INT 25
6053: PUSH
6054: LD_INT 1
6056: PUSH
6057: EMPTY
6058: LIST
6059: LIST
6060: PPUSH
6061: CALL_OW 72
6065: PPUSH
6066: LD_EXP 30
6070: PPUSH
6071: CALL_OW 74
6075: ST_TO_ADDR
// if sol then
6076: LD_VAR 0 3
6080: IFFALSE 6120
// if GetDistUnits ( JMM , sol ) < 10 then
6082: LD_EXP 30
6086: PPUSH
6087: LD_VAR 0 3
6091: PPUSH
6092: CALL_OW 296
6096: PUSH
6097: LD_INT 10
6099: LESS
6100: IFFALSE 6120
// ComEnterUnit ( sol , buns [ 2 ] ) ;
6102: LD_VAR 0 3
6106: PPUSH
6107: LD_VAR 0 4
6111: PUSH
6112: LD_INT 2
6114: ARRAY
6115: PPUSH
6116: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
6120: LD_INT 10
6122: PPUSH
6123: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
6127: LD_EXP 30
6131: PPUSH
6132: LD_INT 65
6134: PPUSH
6135: LD_INT 101
6137: PPUSH
6138: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
6142: LD_EXP 30
6146: PPUSH
6147: LD_INT 63
6149: PPUSH
6150: LD_INT 100
6152: PPUSH
6153: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
6157: LD_INT 35
6159: PPUSH
6160: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
6164: LD_EXP 30
6168: PPUSH
6169: LD_INT 65
6171: PPUSH
6172: LD_INT 101
6174: PPUSH
6175: CALL_OW 307
6179: IFFALSE 6157
// Say ( JMM , D2a-JMM-1 ) ;
6181: LD_EXP 30
6185: PPUSH
6186: LD_STRING D2a-JMM-1
6188: PPUSH
6189: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
6193: LD_EXP 41
6197: PPUSH
6198: LD_INT 66
6200: PPUSH
6201: LD_INT 103
6203: PPUSH
6204: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
6208: LD_INT 35
6210: PPUSH
6211: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
6215: LD_EXP 41
6219: PPUSH
6220: LD_INT 66
6222: PPUSH
6223: LD_INT 103
6225: PPUSH
6226: CALL_OW 307
6230: IFFALSE 6208
// ComTurnUnit ( Walker , JMM ) ;
6232: LD_EXP 41
6236: PPUSH
6237: LD_EXP 30
6241: PPUSH
6242: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
6246: LD_EXP 41
6250: PPUSH
6251: LD_STRING D2a-Sci1-1
6253: PPUSH
6254: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
6258: LD_EXP 30
6262: PPUSH
6263: LD_EXP 41
6267: PPUSH
6268: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
6272: LD_EXP 30
6276: PPUSH
6277: LD_STRING D2a-JMM-2
6279: PPUSH
6280: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
6284: LD_EXP 41
6288: PPUSH
6289: LD_STRING D2a-Sci1-2
6291: PPUSH
6292: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
6296: LD_EXP 30
6300: PPUSH
6301: LD_STRING D2a-JMM-3
6303: PPUSH
6304: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
6308: LD_EXP 41
6312: PPUSH
6313: LD_STRING D2a-Sci1-3
6315: PPUSH
6316: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
6320: LD_ADDR_EXP 2
6324: PUSH
6325: LD_EXP 2
6329: PUSH
6330: LD_EXP 40
6334: PUSH
6335: LD_EXP 41
6339: PUSH
6340: LD_EXP 42
6344: PUSH
6345: LD_EXP 43
6349: PUSH
6350: EMPTY
6351: LIST
6352: LIST
6353: LIST
6354: LIST
6355: ADD
6356: ST_TO_ADDR
// for i in jmm_units do
6357: LD_ADDR_VAR 0 1
6361: PUSH
6362: LD_EXP 2
6366: PUSH
6367: FOR_IN
6368: IFFALSE 6393
// if not IsInUnit ( i ) then
6370: LD_VAR 0 1
6374: PPUSH
6375: CALL_OW 310
6379: NOT
6380: IFFALSE 6391
// ComFree ( i ) ;
6382: LD_VAR 0 1
6386: PPUSH
6387: CALL_OW 139
6391: GO 6367
6393: POP
6394: POP
// InGameOff ;
6395: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
6399: LD_STRING MSolar1
6401: PPUSH
6402: CALL_OW 337
// jmm_on_west := true ;
6406: LD_ADDR_EXP 3
6410: PUSH
6411: LD_INT 1
6413: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
6414: LD_INT 1050
6416: PPUSH
6417: CALL_OW 67
// frank_can_return := true ;
6421: LD_ADDR_EXP 10
6425: PUSH
6426: LD_INT 1
6428: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
6429: LD_INT 6300
6431: PPUSH
6432: LD_INT 8400
6434: PPUSH
6435: CALL_OW 12
6439: PPUSH
6440: CALL_OW 67
// send_spec_patrol := true ;
6444: LD_ADDR_EXP 25
6448: PUSH
6449: LD_INT 1
6451: ST_TO_ADDR
// end ;
6452: PPOPN 4
6454: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
6455: LD_INT 22
6457: PUSH
6458: LD_INT 1
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: PUSH
6465: LD_INT 34
6467: PUSH
6468: LD_INT 51
6470: PUSH
6471: EMPTY
6472: LIST
6473: LIST
6474: PUSH
6475: LD_INT 92
6477: PUSH
6478: LD_INT 63
6480: PUSH
6481: LD_INT 100
6483: PUSH
6484: LD_INT 5
6486: PUSH
6487: EMPTY
6488: LIST
6489: LIST
6490: LIST
6491: LIST
6492: PUSH
6493: EMPTY
6494: LIST
6495: LIST
6496: LIST
6497: PUSH
6498: EMPTY
6499: LIST
6500: PPUSH
6501: CALL_OW 69
6505: PUSH
6506: LD_EXP 3
6510: NOT
6511: AND
6512: IFFALSE 6625
6514: GO 6516
6516: DISABLE
6517: LD_INT 0
6519: PPUSH
6520: PPUSH
// begin enable ;
6521: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
6522: LD_ADDR_VAR 0 2
6526: PUSH
6527: LD_INT 22
6529: PUSH
6530: LD_INT 1
6532: PUSH
6533: EMPTY
6534: LIST
6535: LIST
6536: PUSH
6537: LD_INT 34
6539: PUSH
6540: LD_INT 51
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: PUSH
6547: LD_INT 92
6549: PUSH
6550: LD_INT 63
6552: PUSH
6553: LD_INT 100
6555: PUSH
6556: LD_INT 5
6558: PUSH
6559: EMPTY
6560: LIST
6561: LIST
6562: LIST
6563: LIST
6564: PUSH
6565: EMPTY
6566: LIST
6567: LIST
6568: LIST
6569: PUSH
6570: EMPTY
6571: LIST
6572: PPUSH
6573: CALL_OW 69
6577: ST_TO_ADDR
// if not filter then
6578: LD_VAR 0 2
6582: NOT
6583: IFFALSE 6587
// exit ;
6585: GO 6625
// for i in filter do
6587: LD_ADDR_VAR 0 1
6591: PUSH
6592: LD_VAR 0 2
6596: PUSH
6597: FOR_IN
6598: IFFALSE 6623
// begin SetFuel ( i , 0 ) ;
6600: LD_VAR 0 1
6604: PPUSH
6605: LD_INT 0
6607: PPUSH
6608: CALL_OW 240
// ComStop ( i ) ;
6612: LD_VAR 0 1
6616: PPUSH
6617: CALL_OW 141
// end ;
6621: GO 6597
6623: POP
6624: POP
// end ;
6625: PPOPN 2
6627: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
6628: LD_EXP 25
6632: IFFALSE 7597
6634: GO 6636
6636: DISABLE
6637: LD_INT 0
6639: PPUSH
6640: PPUSH
6641: PPUSH
6642: PPUSH
6643: PPUSH
6644: PPUSH
6645: PPUSH
// begin if not ru_spec_patrol then
6646: LD_EXP 47
6650: NOT
6651: IFFALSE 6655
// exit ;
6653: GO 7597
// dead1 := false ;
6655: LD_ADDR_VAR 0 1
6659: PUSH
6660: LD_INT 0
6662: ST_TO_ADDR
// dead2 := false ;
6663: LD_ADDR_VAR 0 2
6667: PUSH
6668: LD_INT 0
6670: ST_TO_ADDR
// inarea1 := false ;
6671: LD_ADDR_VAR 0 3
6675: PUSH
6676: LD_INT 0
6678: ST_TO_ADDR
// inarea2 := false ;
6679: LD_ADDR_VAR 0 4
6683: PUSH
6684: LD_INT 0
6686: ST_TO_ADDR
// tmp := [ ] ;
6687: LD_ADDR_VAR 0 6
6691: PUSH
6692: EMPTY
6693: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
6694: LD_EXP 47
6698: PPUSH
6699: LD_INT 75
6701: PPUSH
6702: LD_INT 101
6704: PPUSH
6705: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
6709: LD_INT 35
6711: PPUSH
6712: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
6716: LD_INT 1
6718: PPUSH
6719: LD_EXP 47
6723: PUSH
6724: LD_INT 1
6726: ARRAY
6727: PPUSH
6728: CALL_OW 292
6732: IFFALSE 6709
// ComStop ( ru_spec_patrol ) ;
6734: LD_EXP 47
6738: PPUSH
6739: CALL_OW 141
// Wait ( 0 0$02 ) ;
6743: LD_INT 70
6745: PPUSH
6746: CALL_OW 67
// DialogueOn ;
6750: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
6754: LD_EXP 47
6758: PUSH
6759: LD_INT 1
6761: ARRAY
6762: PPUSH
6763: LD_STRING D8-Rus1-1
6765: PPUSH
6766: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
6770: LD_EXP 30
6774: PPUSH
6775: LD_STRING D8-JMM-1
6777: PPUSH
6778: CALL_OW 88
// DialogueOff ;
6782: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
6786: LD_EXP 47
6790: PPUSH
6791: LD_INT 13
6793: PPUSH
6794: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
6798: LD_INT 35
6800: PPUSH
6801: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
6805: LD_VAR 0 1
6809: NOT
6810: PUSH
6811: LD_EXP 47
6815: PUSH
6816: LD_INT 1
6818: ARRAY
6819: PPUSH
6820: CALL_OW 301
6824: AND
6825: IFFALSE 6835
// dead1 := true ;
6827: LD_ADDR_VAR 0 1
6831: PUSH
6832: LD_INT 1
6834: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
6835: LD_VAR 0 2
6839: NOT
6840: PUSH
6841: LD_EXP 47
6845: PUSH
6846: LD_INT 2
6848: ARRAY
6849: PPUSH
6850: CALL_OW 301
6854: AND
6855: IFFALSE 6865
// dead2 := true ;
6857: LD_ADDR_VAR 0 2
6861: PUSH
6862: LD_INT 1
6864: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
6865: LD_VAR 0 3
6869: NOT
6870: PUSH
6871: LD_EXP 47
6875: PUSH
6876: LD_INT 1
6878: ARRAY
6879: PPUSH
6880: LD_INT 14
6882: PPUSH
6883: CALL_OW 308
6887: AND
6888: IFFALSE 6898
// inarea1 := true ;
6890: LD_ADDR_VAR 0 3
6894: PUSH
6895: LD_INT 1
6897: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
6898: LD_VAR 0 4
6902: NOT
6903: PUSH
6904: LD_EXP 47
6908: PUSH
6909: LD_INT 2
6911: ARRAY
6912: PPUSH
6913: LD_INT 14
6915: PPUSH
6916: CALL_OW 308
6920: AND
6921: IFFALSE 6931
// inarea2 := true ;
6923: LD_ADDR_VAR 0 4
6927: PUSH
6928: LD_INT 1
6930: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
6931: LD_VAR 0 1
6935: PUSH
6936: LD_VAR 0 2
6940: AND
6941: PUSH
6942: LD_VAR 0 1
6946: PUSH
6947: LD_VAR 0 4
6951: AND
6952: OR
6953: PUSH
6954: LD_VAR 0 2
6958: PUSH
6959: LD_VAR 0 3
6963: AND
6964: OR
6965: PUSH
6966: LD_VAR 0 3
6970: PUSH
6971: LD_VAR 0 4
6975: AND
6976: OR
6977: IFFALSE 6798
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
6979: LD_VAR 0 3
6983: PUSH
6984: LD_VAR 0 4
6988: AND
6989: PUSH
6990: LD_VAR 0 1
6994: PUSH
6995: LD_VAR 0 4
6999: AND
7000: OR
7001: PUSH
7002: LD_VAR 0 2
7006: PUSH
7007: LD_VAR 0 3
7011: AND
7012: OR
7013: IFFALSE 7577
// begin prepare_siege := true ;
7015: LD_ADDR_EXP 26
7019: PUSH
7020: LD_INT 1
7022: ST_TO_ADDR
// DialogueOn ;
7023: CALL_OW 6
// if ( inarea1 and inarea2 ) then
7027: LD_VAR 0 3
7031: PUSH
7032: LD_VAR 0 4
7036: AND
7037: IFFALSE 7053
// Say ( JMM , D8b-JMM-1a ) else
7039: LD_EXP 30
7043: PPUSH
7044: LD_STRING D8b-JMM-1a
7046: PPUSH
7047: CALL_OW 88
7051: GO 7065
// Say ( JMM , D8b-JMM-1 ) ;
7053: LD_EXP 30
7057: PPUSH
7058: LD_STRING D8b-JMM-1
7060: PPUSH
7061: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
7065: LD_EXP 2
7069: PPUSH
7070: LD_INT 26
7072: PUSH
7073: LD_INT 1
7075: PUSH
7076: EMPTY
7077: LIST
7078: LIST
7079: PPUSH
7080: CALL_OW 72
7084: PUSH
7085: LD_EXP 31
7089: PUSH
7090: LD_EXP 32
7094: PUSH
7095: LD_EXP 41
7099: PUSH
7100: LD_EXP 44
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: LIST
7109: LIST
7110: DIFF
7111: PPUSH
7112: LD_STRING D8b-Sol1-1
7114: PPUSH
7115: CALL 596 0 2
// if Cyrus and Cyrus in jmm_units then
7119: LD_EXP 32
7123: PUSH
7124: LD_EXP 32
7128: PUSH
7129: LD_EXP 2
7133: IN
7134: AND
7135: IFFALSE 7151
// Say ( Cyrus , D8b-Cyrus-1 ) else
7137: LD_EXP 32
7141: PPUSH
7142: LD_STRING D8b-Cyrus-1
7144: PPUSH
7145: CALL_OW 88
7149: GO 7163
// Say ( JMM , D8b-JMM-1a ) ;
7151: LD_EXP 30
7155: PPUSH
7156: LD_STRING D8b-JMM-1a
7158: PPUSH
7159: CALL_OW 88
// if Lisa and Lisa in jmm_units then
7163: LD_EXP 33
7167: PUSH
7168: LD_EXP 33
7172: PUSH
7173: LD_EXP 2
7177: IN
7178: AND
7179: IFFALSE 7193
// Say ( Lisa , D8b-Lisa-2 ) ;
7181: LD_EXP 33
7185: PPUSH
7186: LD_STRING D8b-Lisa-2
7188: PPUSH
7189: CALL_OW 88
// if Bobby and Bobby in jmm_units then
7193: LD_EXP 31
7197: PUSH
7198: LD_EXP 31
7202: PUSH
7203: LD_EXP 2
7207: IN
7208: AND
7209: IFFALSE 7225
// Say ( Bobby , D8b-Bobby-1 ) else
7211: LD_EXP 31
7215: PPUSH
7216: LD_STRING D8b-Bobby-1
7218: PPUSH
7219: CALL_OW 88
7223: GO 7285
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
7225: LD_ADDR_VAR 0 5
7229: PUSH
7230: LD_EXP 2
7234: PPUSH
7235: LD_INT 26
7237: PUSH
7238: LD_INT 1
7240: PUSH
7241: EMPTY
7242: LIST
7243: LIST
7244: PPUSH
7245: CALL_OW 72
7249: PUSH
7250: LD_EXP 31
7254: PUSH
7255: LD_EXP 32
7259: PUSH
7260: LD_EXP 41
7264: PUSH
7265: LD_EXP 44
7269: PUSH
7270: EMPTY
7271: LIST
7272: LIST
7273: LIST
7274: LIST
7275: DIFF
7276: PPUSH
7277: LD_STRING D8b-Sol2-1
7279: PPUSH
7280: CALL 596 0 2
7284: ST_TO_ADDR
// DialogueOff ;
7285: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
7289: LD_EXP 32
7293: PUSH
7294: LD_EXP 32
7298: PUSH
7299: LD_EXP 2
7303: IN
7304: AND
7305: IFFALSE 7330
// tmp := Insert ( tmp , 1 , Cyrus ) ;
7307: LD_ADDR_VAR 0 6
7311: PUSH
7312: LD_VAR 0 6
7316: PPUSH
7317: LD_INT 1
7319: PPUSH
7320: LD_EXP 32
7324: PPUSH
7325: CALL_OW 2
7329: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
7330: LD_EXP 31
7334: PUSH
7335: LD_EXP 31
7339: PUSH
7340: LD_EXP 2
7344: IN
7345: AND
7346: IFFALSE 7371
// tmp := Insert ( tmp , 1 , Bobby ) ;
7348: LD_ADDR_VAR 0 6
7352: PUSH
7353: LD_VAR 0 6
7357: PPUSH
7358: LD_INT 1
7360: PPUSH
7361: LD_EXP 31
7365: PPUSH
7366: CALL_OW 2
7370: ST_TO_ADDR
// if sol then
7371: LD_VAR 0 5
7375: IFFALSE 7400
// tmp := Insert ( tmp , 1 , sol ) ;
7377: LD_ADDR_VAR 0 6
7381: PUSH
7382: LD_VAR 0 6
7386: PPUSH
7387: LD_INT 1
7389: PPUSH
7390: LD_VAR 0 5
7394: PPUSH
7395: CALL_OW 2
7399: ST_TO_ADDR
// if tmp then
7400: LD_VAR 0 6
7404: IFFALSE 7536
// begin SetSide ( tmp , 8 ) ;
7406: LD_VAR 0 6
7410: PPUSH
7411: LD_INT 8
7413: PPUSH
7414: CALL_OW 235
// ComFree ( tmp ) ;
7418: LD_VAR 0 6
7422: PPUSH
7423: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
7427: LD_VAR 0 6
7431: PPUSH
7432: LD_INT 15
7434: PPUSH
7435: CALL_OW 173
// AddComHold ( tmp ) ;
7439: LD_VAR 0 6
7443: PPUSH
7444: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7448: LD_INT 35
7450: PPUSH
7451: CALL_OW 67
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
7455: LD_VAR 0 6
7459: PUSH
7460: LD_INT 1
7462: ARRAY
7463: PPUSH
7464: LD_INT 15
7466: PPUSH
7467: CALL_OW 308
7471: IFFALSE 7526
// begin RemoveUnit ( tmp [ 1 ] ) ;
7473: LD_VAR 0 6
7477: PUSH
7478: LD_INT 1
7480: ARRAY
7481: PPUSH
7482: CALL_OW 64
// jmm_units := jmm_units diff tmp [ 1 ] ;
7486: LD_ADDR_EXP 2
7490: PUSH
7491: LD_EXP 2
7495: PUSH
7496: LD_VAR 0 6
7500: PUSH
7501: LD_INT 1
7503: ARRAY
7504: DIFF
7505: ST_TO_ADDR
// tmp := tmp diff tmp [ 1 ] ;
7506: LD_ADDR_VAR 0 6
7510: PUSH
7511: LD_VAR 0 6
7515: PUSH
7516: LD_VAR 0 6
7520: PUSH
7521: LD_INT 1
7523: ARRAY
7524: DIFF
7525: ST_TO_ADDR
// end ; until tmp = 0 ;
7526: LD_VAR 0 6
7530: PUSH
7531: LD_INT 0
7533: EQUAL
7534: IFFALSE 7448
// end ; Wait ( 0 0$30 ) ;
7536: LD_INT 1050
7538: PPUSH
7539: CALL_OW 67
// if ru_spec_patrol then
7543: LD_EXP 47
7547: IFFALSE 7575
// for i in ru_spec_patrol do
7549: LD_ADDR_VAR 0 7
7553: PUSH
7554: LD_EXP 47
7558: PUSH
7559: FOR_IN
7560: IFFALSE 7573
// RemoveUnit ( i ) ;
7562: LD_VAR 0 7
7566: PPUSH
7567: CALL_OW 64
7571: GO 7559
7573: POP
7574: POP
// end else
7575: GO 7597
// begin prepare_siege := false ;
7577: LD_ADDR_EXP 26
7581: PUSH
7582: LD_INT 0
7584: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
7585: LD_EXP 30
7589: PPUSH
7590: LD_STRING D8a-JMM-1
7592: PPUSH
7593: CALL_OW 88
// end ; end ;
7597: PPOPN 7
7599: END
// every 0 0$10 trigger frank_can_return do var i , points ;
7600: LD_EXP 10
7604: IFFALSE 8730
7606: GO 7608
7608: DISABLE
7609: LD_INT 0
7611: PPUSH
7612: PPUSH
// begin uc_side := 8 ;
7613: LD_ADDR_OWVAR 20
7617: PUSH
7618: LD_INT 8
7620: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
7621: LD_ADDR_VAR 0 2
7625: PUSH
7626: LD_INT 59
7628: PUSH
7629: LD_INT 71
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: PUSH
7636: LD_INT 122
7638: PUSH
7639: LD_INT 117
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: PUSH
7646: EMPTY
7647: LIST
7648: LIST
7649: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
7650: LD_ADDR_EXP 44
7654: PUSH
7655: LD_STRING Frank
7657: PPUSH
7658: LD_INT 0
7660: PPUSH
7661: CALL 426 0 2
7665: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
7666: LD_ADDR_VAR 0 1
7670: PUSH
7671: LD_INT 1
7673: PPUSH
7674: LD_INT 2
7676: PPUSH
7677: CALL_OW 12
7681: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
7682: LD_EXP 44
7686: PPUSH
7687: LD_VAR 0 2
7691: PUSH
7692: LD_VAR 0 1
7696: ARRAY
7697: PUSH
7698: LD_INT 1
7700: ARRAY
7701: PPUSH
7702: LD_VAR 0 2
7706: PUSH
7707: LD_VAR 0 1
7711: ARRAY
7712: PUSH
7713: LD_INT 2
7715: ARRAY
7716: PPUSH
7717: LD_INT 0
7719: PPUSH
7720: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
7724: LD_EXP 44
7728: PPUSH
7729: LD_INT 1
7731: PPUSH
7732: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
7736: LD_INT 35
7738: PPUSH
7739: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
7743: LD_EXP 44
7747: PPUSH
7748: LD_EXP 30
7752: PPUSH
7753: CALL_OW 296
7757: PUSH
7758: LD_INT 8
7760: LESS
7761: IFFALSE 7736
// InGameOn ;
7763: CALL_OW 8
// CenterOnUnits ( JMM ) ;
7767: LD_EXP 30
7771: PPUSH
7772: CALL_OW 85
// if IsInUnit ( JMM ) then
7776: LD_EXP 30
7780: PPUSH
7781: CALL_OW 310
7785: IFFALSE 7796
// ComFree ( JMM ) ;
7787: LD_EXP 30
7791: PPUSH
7792: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
7796: LD_EXP 30
7800: PPUSH
7801: LD_EXP 44
7805: PPUSH
7806: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
7810: LD_EXP 44
7814: PPUSH
7815: LD_EXP 30
7819: PPUSH
7820: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
7824: LD_EXP 30
7828: PPUSH
7829: LD_STRING D6-JMM-1
7831: PPUSH
7832: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
7836: LD_INT 35
7838: PPUSH
7839: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
7843: LD_EXP 30
7847: PPUSH
7848: LD_EXP 44
7852: PPUSH
7853: CALL_OW 296
7857: PUSH
7858: LD_INT 8
7860: LESS
7861: IFFALSE 7836
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
7863: LD_EXP 33
7867: PUSH
7868: LD_EXP 33
7872: PPUSH
7873: LD_EXP 44
7877: PPUSH
7878: CALL_OW 296
7882: PUSH
7883: LD_INT 20
7885: LESS
7886: AND
7887: IFFALSE 7912
// begin ComFree ( Lisa ) ;
7889: LD_EXP 33
7893: PPUSH
7894: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
7898: LD_EXP 33
7902: PPUSH
7903: LD_EXP 44
7907: PPUSH
7908: CALL_OW 172
// end ; if Lynch then
7912: LD_EXP 40
7916: IFFALSE 7941
// begin ComFree ( Lynch ) ;
7918: LD_EXP 40
7922: PPUSH
7923: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
7927: LD_EXP 40
7931: PPUSH
7932: LD_EXP 44
7936: PPUSH
7937: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
7941: LD_EXP 30
7945: PPUSH
7946: LD_EXP 44
7950: PPUSH
7951: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
7955: LD_EXP 44
7959: PPUSH
7960: LD_EXP 30
7964: PPUSH
7965: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
7969: LD_EXP 44
7973: PPUSH
7974: LD_STRING D6-Frank-1
7976: PPUSH
7977: CALL_OW 88
// PlaceSeeing ( 69 , 20 , 1 , - 20 ) ;
7981: LD_INT 69
7983: PPUSH
7984: LD_INT 20
7986: PPUSH
7987: LD_INT 1
7989: PPUSH
7990: LD_INT 20
7992: NEG
7993: PPUSH
7994: CALL_OW 330
// RemoveSeeing ( 69 , 20 , 1 ) ;
7998: LD_INT 69
8000: PPUSH
8001: LD_INT 20
8003: PPUSH
8004: LD_INT 1
8006: PPUSH
8007: CALL_OW 331
// PlaceSeeing ( 190 , 31 , 1 , - 20 ) ;
8011: LD_INT 190
8013: PPUSH
8014: LD_INT 31
8016: PPUSH
8017: LD_INT 1
8019: PPUSH
8020: LD_INT 20
8022: NEG
8023: PPUSH
8024: CALL_OW 330
// RemoveSeeing ( 190 , 31 , 1 ) ;
8028: LD_INT 190
8030: PPUSH
8031: LD_INT 31
8033: PPUSH
8034: LD_INT 1
8036: PPUSH
8037: CALL_OW 331
// CenterOnXY ( 69 , 20 ) ;
8041: LD_INT 69
8043: PPUSH
8044: LD_INT 20
8046: PPUSH
8047: CALL_OW 84
// Wait ( 0 0$02 ) ;
8051: LD_INT 70
8053: PPUSH
8054: CALL_OW 67
// CenterNowOnUnits ( JMM ) ;
8058: LD_EXP 30
8062: PPUSH
8063: CALL_OW 87
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
8067: LD_EXP 33
8071: PUSH
8072: LD_EXP 33
8076: PPUSH
8077: LD_EXP 44
8081: PPUSH
8082: CALL_OW 296
8086: PUSH
8087: LD_INT 20
8089: LESS
8090: AND
8091: PUSH
8092: LD_EXP 33
8096: PPUSH
8097: CALL_OW 302
8101: AND
8102: IFFALSE 8192
// begin ComFree ( Lisa ) ;
8104: LD_EXP 33
8108: PPUSH
8109: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
8113: LD_INT 35
8115: PPUSH
8116: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
8120: LD_EXP 33
8124: PPUSH
8125: LD_EXP 44
8129: PPUSH
8130: CALL_OW 296
8134: PUSH
8135: LD_INT 7
8137: LESS
8138: IFFALSE 8113
// Say ( Lisa , D6-Lisa-1 ) ;
8140: LD_EXP 33
8144: PPUSH
8145: LD_STRING D6-Lisa-1
8147: PPUSH
8148: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
8152: LD_EXP 33
8156: PPUSH
8157: LD_EXP 44
8161: PPUSH
8162: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
8166: LD_EXP 44
8170: PPUSH
8171: LD_EXP 33
8175: PPUSH
8176: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
8180: LD_EXP 44
8184: PPUSH
8185: LD_STRING D6-Frank-2
8187: PPUSH
8188: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
8192: LD_EXP 40
8196: PUSH
8197: LD_EXP 40
8201: PPUSH
8202: LD_EXP 44
8206: PPUSH
8207: CALL_OW 296
8211: PUSH
8212: LD_INT 20
8214: LESS
8215: AND
8216: PUSH
8217: LD_EXP 40
8221: PPUSH
8222: CALL_OW 302
8226: AND
8227: IFFALSE 8408
// begin ComTurnUnit ( Lynch , JMM ) ;
8229: LD_EXP 40
8233: PPUSH
8234: LD_EXP 30
8238: PPUSH
8239: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
8243: LD_EXP 44
8247: PPUSH
8248: LD_EXP 30
8252: PPUSH
8253: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
8257: LD_EXP 40
8261: PPUSH
8262: LD_STRING D6-Sol1-2
8264: PPUSH
8265: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
8269: LD_EXP 30
8273: PPUSH
8274: LD_STRING D6-JMM-2
8276: PPUSH
8277: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
8281: LD_EXP 44
8285: PPUSH
8286: LD_STRING D6-Frank-3
8288: PPUSH
8289: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
8293: LD_EXP 30
8297: PPUSH
8298: LD_STRING D6-JMM-3
8300: PPUSH
8301: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
8305: LD_EXP 44
8309: PPUSH
8310: LD_STRING D6-Frank-4
8312: PPUSH
8313: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
8317: LD_EXP 44
8321: PPUSH
8322: LD_STRING D6-Frank-4a
8324: PPUSH
8325: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
8329: LD_EXP 30
8333: PPUSH
8334: LD_STRING D6-JMM-4
8336: PPUSH
8337: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
8341: LD_EXP 44
8345: PPUSH
8346: LD_STRING D6-Frank-5
8348: PPUSH
8349: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
8353: LD_EXP 33
8357: PUSH
8358: LD_EXP 33
8362: PPUSH
8363: CALL_OW 302
8367: AND
8368: IFFALSE 8382
// Say ( Lisa , D6-Lisa-5 ) ;
8370: LD_EXP 33
8374: PPUSH
8375: LD_STRING D6-Lisa-5
8377: PPUSH
8378: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
8382: LD_EXP 44
8386: PPUSH
8387: LD_STRING D6-Frank-6
8389: PPUSH
8390: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
8394: LD_EXP 30
8398: PPUSH
8399: LD_STRING D6-JMM-6
8401: PPUSH
8402: CALL_OW 88
// end else
8406: GO 8523
// begin ComTurnUnit ( Frank , JMM ) ;
8408: LD_EXP 44
8412: PPUSH
8413: LD_EXP 30
8417: PPUSH
8418: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
8422: LD_EXP 44
8426: PPUSH
8427: LD_STRING D6-Frank-4
8429: PPUSH
8430: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
8434: LD_EXP 44
8438: PPUSH
8439: LD_STRING D6-Frank-4a
8441: PPUSH
8442: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
8446: LD_EXP 30
8450: PPUSH
8451: LD_STRING D6-JMM-4
8453: PPUSH
8454: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
8458: LD_EXP 44
8462: PPUSH
8463: LD_STRING D6-Frank-5
8465: PPUSH
8466: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
8470: LD_EXP 33
8474: PUSH
8475: LD_EXP 33
8479: PPUSH
8480: CALL_OW 302
8484: AND
8485: IFFALSE 8499
// Say ( Lisa , D6-Lisa-5 ) ;
8487: LD_EXP 33
8491: PPUSH
8492: LD_STRING D6-Lisa-5
8494: PPUSH
8495: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
8499: LD_EXP 44
8503: PPUSH
8504: LD_STRING D6-Frank-6
8506: PPUSH
8507: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
8511: LD_EXP 30
8515: PPUSH
8516: LD_STRING D6-JMM-6
8518: PPUSH
8519: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
8523: LD_STRING Q1
8525: PPUSH
8526: CALL_OW 97
8530: PUSH
8531: LD_INT 1
8533: DOUBLE
8534: EQUAL
8535: IFTRUE 8539
8537: GO 8550
8539: POP
// frank_send_to_scout := true ; 2 :
8540: LD_ADDR_EXP 12
8544: PUSH
8545: LD_INT 1
8547: ST_TO_ADDR
8548: GO 8570
8550: LD_INT 2
8552: DOUBLE
8553: EQUAL
8554: IFTRUE 8558
8556: GO 8569
8558: POP
// frank_send_to_scout := false ; end ;
8559: LD_ADDR_EXP 12
8563: PUSH
8564: LD_INT 0
8566: ST_TO_ADDR
8567: GO 8570
8569: POP
// InGameOff ;
8570: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
8574: LD_EXP 30
8578: PUSH
8579: LD_EXP 33
8583: PUSH
8584: LD_EXP 40
8588: PUSH
8589: EMPTY
8590: LIST
8591: LIST
8592: LIST
8593: PPUSH
8594: CALL_OW 139
// if frank_send_to_scout then
8598: LD_EXP 12
8602: IFFALSE 8659
// begin ComMoveXY ( Frank , 130 , 123 ) ;
8604: LD_EXP 44
8608: PPUSH
8609: LD_INT 130
8611: PPUSH
8612: LD_INT 123
8614: PPUSH
8615: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
8619: LD_INT 35
8621: PPUSH
8622: CALL_OW 67
// until not See ( 1 , Frank ) ;
8626: LD_INT 1
8628: PPUSH
8629: LD_EXP 44
8633: PPUSH
8634: CALL_OW 292
8638: NOT
8639: IFFALSE 8619
// Wait ( 0 0$02 ) ;
8641: LD_INT 70
8643: PPUSH
8644: CALL_OW 67
// RemoveUnit ( Frank ) ;
8648: LD_EXP 44
8652: PPUSH
8653: CALL_OW 64
// end else
8657: GO 8671
// SetSide ( Frank , 1 ) ;
8659: LD_EXP 44
8663: PPUSH
8664: LD_INT 1
8666: PPUSH
8667: CALL_OW 235
// repeat wait ( 0 0$01 ) ;
8671: LD_INT 35
8673: PPUSH
8674: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
8678: LD_ADDR_EXP 24
8682: PUSH
8683: LD_EXP 24
8687: PPUSH
8688: LD_STRING -
8690: PPUSH
8691: CALL 1088 0 2
8695: ST_TO_ADDR
// if debug then
8696: LD_EXP 1
8700: IFFALSE 8712
// debug_strings := time_to_prepare ;
8702: LD_ADDR_OWVAR 48
8706: PUSH
8707: LD_EXP 24
8711: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
8712: LD_EXP 24
8716: PUSH
8717: LD_INT 0
8719: EQUAL
8720: IFFALSE 8671
// cornel_prepared := true ;
8722: LD_ADDR_EXP 9
8726: PUSH
8727: LD_INT 1
8729: ST_TO_ADDR
// end ;
8730: PPOPN 2
8732: END
// every 0 0$01 trigger cornel_prepared do
8733: LD_EXP 9
8737: IFFALSE 8963
8739: GO 8741
8741: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
8742: LD_EXP 37
8746: PPUSH
8747: LD_STRING D3-Corn-1
8749: PPUSH
8750: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
8754: LD_INT 35
8756: PPUSH
8757: CALL_OW 67
// until cornel_counter = 0 ;
8761: LD_EXP 8
8765: PUSH
8766: LD_INT 0
8768: EQUAL
8769: IFFALSE 8754
// SayRadio ( Cornel , D3a-Corn-1 ) ;
8771: LD_EXP 37
8775: PPUSH
8776: LD_STRING D3a-Corn-1
8778: PPUSH
8779: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
8783: LD_EXP 30
8787: PPUSH
8788: LD_STRING D3a-JMM-1
8790: PPUSH
8791: CALL_OW 88
// end_mission_allowed := true ;
8795: LD_ADDR_EXP 18
8799: PUSH
8800: LD_INT 1
8802: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
8803: LD_STRING M2
8805: PPUSH
8806: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
8810: LD_INT 9
8812: PPUSH
8813: LD_INT 1
8815: PPUSH
8816: CALL_OW 424
// Wait ( 0 0$05 ) ;
8820: LD_INT 175
8822: PPUSH
8823: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
8827: LD_EXP 37
8831: PPUSH
8832: LD_STRING D3a-Corn-2
8834: PPUSH
8835: CALL_OW 94
// cornel_attack := true ;
8839: LD_ADDR_EXP 7
8843: PUSH
8844: LD_INT 1
8846: ST_TO_ADDR
// if frank_send_to_scout then
8847: LD_EXP 12
8851: IFFALSE 8963
// begin InitHc ;
8853: CALL_OW 19
// InitUc ;
8857: CALL_OW 18
// uc_side := 8 ;
8861: LD_ADDR_OWVAR 20
8865: PUSH
8866: LD_INT 8
8868: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
8869: LD_ADDR_EXP 44
8873: PUSH
8874: LD_STRING Frank
8876: PPUSH
8877: LD_INT 0
8879: PPUSH
8880: CALL 426 0 2
8884: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
8885: LD_EXP 44
8889: PPUSH
8890: LD_INT 6
8892: PPUSH
8893: LD_INT 9
8895: PPUSH
8896: LD_INT 0
8898: PPUSH
8899: CALL_OW 48
// ComCrawl ( Frank ) ;
8903: LD_EXP 44
8907: PPUSH
8908: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
8912: LD_INT 35
8914: PPUSH
8915: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 9 ;
8919: LD_EXP 30
8923: PPUSH
8924: LD_EXP 44
8928: PPUSH
8929: CALL_OW 296
8933: PUSH
8934: LD_INT 9
8936: LESS
8937: IFFALSE 8912
// SetSide ( Frank , 1 ) ;
8939: LD_EXP 44
8943: PPUSH
8944: LD_INT 1
8946: PPUSH
8947: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
8951: LD_EXP 44
8955: PPUSH
8956: LD_STRING D6a-Frank-1
8958: PPUSH
8959: CALL_OW 88
// end ; end ;
8963: END
// every 0 0$01 trigger solar_builded do
8964: LD_EXP 11
8968: IFFALSE 9072
8970: GO 8972
8972: DISABLE
// begin Wait ( 0 0$02 ) ;
8973: LD_INT 70
8975: PPUSH
8976: CALL_OW 67
// DialogueOn ;
8980: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
8984: LD_EXP 30
8988: PPUSH
8989: LD_STRING D2b-JMM-1
8991: PPUSH
8992: CALL_OW 88
// if Walker and IsOk ( Walker ) then
8996: LD_EXP 41
9000: PUSH
9001: LD_EXP 41
9005: PPUSH
9006: CALL_OW 302
9010: AND
9011: IFFALSE 9061
// begin Say ( Walker , D2b-Sci1-1 ) ;
9013: LD_EXP 41
9017: PPUSH
9018: LD_STRING D2b-Sci1-1
9020: PPUSH
9021: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
9025: LD_EXP 30
9029: PPUSH
9030: LD_STRING D2b-JMM-2
9032: PPUSH
9033: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
9037: LD_EXP 41
9041: PPUSH
9042: LD_STRING D2b-Sci1-2
9044: PPUSH
9045: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
9049: LD_EXP 30
9053: PPUSH
9054: LD_STRING D2b-JMM-3
9056: PPUSH
9057: CALL_OW 88
// end ; DialogueOff ;
9061: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
9065: LD_STRING MOutSol
9067: PPUSH
9068: CALL_OW 337
// end ;
9072: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
9073: LD_EXP 11
9077: PUSH
9078: LD_EXP 30
9082: PPUSH
9083: CALL_OW 302
9087: AND
9088: PUSH
9089: LD_EXP 30
9093: PPUSH
9094: CALL 922 0 1
9098: AND
9099: PUSH
9100: LD_EXP 13
9104: NOT
9105: AND
9106: IFFALSE 9177
9108: GO 9110
9110: DISABLE
9111: LD_INT 0
9113: PPUSH
// begin jmm_in_veh := true ;
9114: LD_ADDR_EXP 13
9118: PUSH
9119: LD_INT 1
9121: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
9122: LD_ADDR_VAR 0 1
9126: PUSH
9127: LD_INT 0
9129: PPUSH
9130: LD_INT 1
9132: PPUSH
9133: CALL_OW 12
9137: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
9138: LD_INT 70
9140: PPUSH
9141: CALL_OW 67
// if i then
9145: LD_VAR 0 1
9149: IFFALSE 9165
// Say ( JMM , D2c-JMM-1 ) else
9151: LD_EXP 30
9155: PPUSH
9156: LD_STRING D2c-JMM-1
9158: PPUSH
9159: CALL_OW 88
9163: GO 9177
// Say ( JMM , D2c-JMM-1a ) ;
9165: LD_EXP 30
9169: PPUSH
9170: LD_STRING D2c-JMM-1a
9172: PPUSH
9173: CALL_OW 88
// end ;
9177: PPOPN 1
9179: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
9180: LD_EXP 11
9184: PUSH
9185: LD_EXP 31
9189: PPUSH
9190: CALL_OW 302
9194: AND
9195: PUSH
9196: LD_EXP 31
9200: PPUSH
9201: CALL 922 0 1
9205: AND
9206: PUSH
9207: LD_EXP 14
9211: NOT
9212: AND
9213: IFFALSE 9245
9215: GO 9217
9217: DISABLE
// begin bobby_in_veh := true ;
9218: LD_ADDR_EXP 14
9222: PUSH
9223: LD_INT 1
9225: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
9226: LD_INT 70
9228: PPUSH
9229: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
9233: LD_EXP 31
9237: PPUSH
9238: LD_STRING D2c-Bobby-1
9240: PPUSH
9241: CALL_OW 88
9245: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
9246: LD_EXP 11
9250: PUSH
9251: LD_EXP 33
9255: PPUSH
9256: CALL_OW 302
9260: AND
9261: PUSH
9262: LD_EXP 33
9266: PPUSH
9267: CALL 922 0 1
9271: AND
9272: PUSH
9273: LD_EXP 16
9277: NOT
9278: AND
9279: IFFALSE 9311
9281: GO 9283
9283: DISABLE
// begin lisa_in_veh := true ;
9284: LD_ADDR_EXP 16
9288: PUSH
9289: LD_INT 1
9291: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
9292: LD_INT 70
9294: PPUSH
9295: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
9299: LD_EXP 33
9303: PPUSH
9304: LD_STRING D2c-Lisa-1
9306: PPUSH
9307: CALL_OW 88
9311: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
9312: LD_EXP 11
9316: PUSH
9317: LD_EXP 32
9321: PPUSH
9322: CALL_OW 302
9326: AND
9327: PUSH
9328: LD_EXP 32
9332: PPUSH
9333: CALL 922 0 1
9337: AND
9338: PUSH
9339: LD_EXP 15
9343: NOT
9344: AND
9345: IFFALSE 9416
9347: GO 9349
9349: DISABLE
9350: LD_INT 0
9352: PPUSH
// begin cyrus_in_veh := true ;
9353: LD_ADDR_EXP 15
9357: PUSH
9358: LD_INT 1
9360: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
9361: LD_ADDR_VAR 0 1
9365: PUSH
9366: LD_INT 0
9368: PPUSH
9369: LD_INT 1
9371: PPUSH
9372: CALL_OW 12
9376: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
9377: LD_INT 70
9379: PPUSH
9380: CALL_OW 67
// if i then
9384: LD_VAR 0 1
9388: IFFALSE 9404
// Say ( Cyrus , D2c-Cyrus-1 ) else
9390: LD_EXP 32
9394: PPUSH
9395: LD_STRING D2c-Cyrus-1
9397: PPUSH
9398: CALL_OW 88
9402: GO 9416
// Say ( Cyrus , D2c-Cyrus-1a ) ;
9404: LD_EXP 32
9408: PPUSH
9409: LD_STRING D2c-Cyrus-1a
9411: PPUSH
9412: CALL_OW 88
// end ;
9416: PPOPN 1
9418: END
// every 0 0$01 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
9419: LD_EXP 37
9423: PPUSH
9424: LD_INT 16
9426: PPUSH
9427: CALL_OW 308
9431: IFFALSE 9673
9433: GO 9435
9435: DISABLE
9436: LD_INT 0
9438: PPUSH
// begin DoNotAttack ( 3 , Cornel ) ;
9439: LD_INT 3
9441: PPUSH
9442: LD_EXP 37
9446: PPUSH
9447: CALL_OW 471
// send_attack_on_cornel := true ;
9451: LD_ADDR_EXP 27
9455: PUSH
9456: LD_INT 1
9458: ST_TO_ADDR
// if ru_vehicles then
9459: LD_EXP 49
9463: IFFALSE 9497
// for i in ru_vehicles do
9465: LD_ADDR_VAR 0 1
9469: PUSH
9470: LD_EXP 49
9474: PUSH
9475: FOR_IN
9476: IFFALSE 9495
// ComAgressiveMove ( i , 215 , 69 ) ;
9478: LD_VAR 0 1
9482: PPUSH
9483: LD_INT 215
9485: PPUSH
9486: LD_INT 69
9488: PPUSH
9489: CALL_OW 114
9493: GO 9475
9495: POP
9496: POP
// if ru_patrol then
9497: LD_EXP 46
9501: IFFALSE 9535
// for i in ru_patrol do
9503: LD_ADDR_VAR 0 1
9507: PUSH
9508: LD_EXP 46
9512: PUSH
9513: FOR_IN
9514: IFFALSE 9533
// ComAgressiveMove ( i , 215 , 69 ) ;
9516: LD_VAR 0 1
9520: PPUSH
9521: LD_INT 215
9523: PPUSH
9524: LD_INT 69
9526: PPUSH
9527: CALL_OW 114
9531: GO 9513
9533: POP
9534: POP
// if frank_send_to_scout then
9535: LD_EXP 12
9539: IFFALSE 9553
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
9541: LD_EXP 44
9545: PPUSH
9546: LD_STRING D3b-Frank-1
9548: PPUSH
9549: CALL_OW 94
// end ; Wait ( 0 0$04 ) ;
9553: LD_INT 140
9555: PPUSH
9556: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
9560: LD_EXP 37
9564: PPUSH
9565: LD_STRING D4-Corn-1
9567: PPUSH
9568: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
9572: LD_INT 35
9574: PPUSH
9575: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 5 ;
9579: LD_INT 22
9581: PUSH
9582: LD_INT 4
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: PUSH
9589: LD_INT 21
9591: PUSH
9592: LD_INT 1
9594: PUSH
9595: EMPTY
9596: LIST
9597: LIST
9598: PUSH
9599: LD_INT 50
9601: PUSH
9602: EMPTY
9603: LIST
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: LIST
9609: PPUSH
9610: CALL_OW 69
9614: PUSH
9615: LD_INT 5
9617: LESS
9618: IFFALSE 9572
// SayRadio ( Cornel , D5-Corn-1 ) ;
9620: LD_EXP 37
9624: PPUSH
9625: LD_STRING D5-Corn-1
9627: PPUSH
9628: CALL_OW 94
// SaveCharacters ( Cornel , Cornel ) ;
9632: LD_EXP 37
9636: PPUSH
9637: LD_STRING Cornel
9639: PPUSH
9640: CALL_OW 38
// ChangeSideFog ( 4 , 8 ) ;
9644: LD_INT 4
9646: PPUSH
9647: LD_INT 8
9649: PPUSH
9650: CALL_OW 343
// Wait ( 0 0$01 ) ;
9654: LD_INT 35
9656: PPUSH
9657: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
9661: LD_INT 3
9663: PPUSH
9664: LD_EXP 37
9668: PPUSH
9669: CALL_OW 472
// end ;
9673: PPOPN 1
9675: END
// every 0 0$02 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
9676: LD_INT 9
9678: PPUSH
9679: LD_INT 22
9681: PUSH
9682: LD_INT 1
9684: PUSH
9685: EMPTY
9686: LIST
9687: LIST
9688: PPUSH
9689: CALL_OW 70
9693: PUSH
9694: LD_EXP 28
9698: OR
9699: IFFALSE 10218
9701: GO 9703
9703: DISABLE
9704: LD_INT 0
9706: PPUSH
9707: PPUSH
// begin enable ;
9708: ENABLE
// if not game_end then
9709: LD_EXP 28
9713: NOT
9714: IFFALSE 9724
// game_end := true ;
9716: LD_ADDR_EXP 28
9720: PUSH
9721: LD_INT 1
9723: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
9724: LD_ADDR_VAR 0 2
9728: PUSH
9729: LD_INT 9
9731: PPUSH
9732: LD_INT 22
9734: PUSH
9735: LD_INT 1
9737: PUSH
9738: EMPTY
9739: LIST
9740: LIST
9741: PPUSH
9742: CALL_OW 70
9746: ST_TO_ADDR
// if not filter then
9747: LD_VAR 0 2
9751: NOT
9752: IFFALSE 9756
// exit ;
9754: GO 10218
// for i in filter do
9756: LD_ADDR_VAR 0 1
9760: PUSH
9761: LD_VAR 0 2
9765: PUSH
9766: FOR_IN
9767: IFFALSE 10216
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
9769: LD_VAR 0 1
9773: PPUSH
9774: CALL_OW 302
9778: PUSH
9779: LD_VAR 0 1
9783: PPUSH
9784: CALL_OW 247
9788: PUSH
9789: LD_INT 2
9791: EQUAL
9792: AND
9793: IFFALSE 9833
// begin veh_on_meta := true ;
9795: LD_ADDR_EXP 23
9799: PUSH
9800: LD_INT 1
9802: ST_TO_ADDR
// ComExitVehicle ( IsInUnit ( i ) ) ;
9803: LD_VAR 0 1
9807: PPUSH
9808: CALL_OW 310
9812: PPUSH
9813: CALL_OW 121
// RemoveUnit ( i ) ;
9817: LD_VAR 0 1
9821: PPUSH
9822: CALL_OW 64
// Wait ( 10 ) ;
9826: LD_INT 10
9828: PPUSH
9829: CALL_OW 67
// end ; if i = JMM then
9833: LD_VAR 0 1
9837: PUSH
9838: LD_EXP 30
9842: EQUAL
9843: IFFALSE 9965
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
9845: LD_EXP 21
9849: PUSH
9850: LD_INT 22
9852: PUSH
9853: LD_INT 1
9855: PUSH
9856: EMPTY
9857: LIST
9858: LIST
9859: PUSH
9860: LD_INT 21
9862: PUSH
9863: LD_INT 1
9865: PUSH
9866: EMPTY
9867: LIST
9868: LIST
9869: PUSH
9870: EMPTY
9871: LIST
9872: LIST
9873: PPUSH
9874: CALL_OW 69
9878: PUSH
9879: LD_INT 1
9881: GREATER
9882: AND
9883: IFFALSE 9940
// begin show_query := false ;
9885: LD_ADDR_EXP 21
9889: PUSH
9890: LD_INT 0
9892: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
9893: LD_STRING Q2
9895: PPUSH
9896: CALL_OW 97
9900: PUSH
9901: LD_INT 1
9903: DOUBLE
9904: EQUAL
9905: IFTRUE 9909
9907: GO 9920
9909: POP
// wait_for_them := true ; 2 :
9910: LD_ADDR_EXP 22
9914: PUSH
9915: LD_INT 1
9917: ST_TO_ADDR
9918: GO 9940
9920: LD_INT 2
9922: DOUBLE
9923: EQUAL
9924: IFTRUE 9928
9926: GO 9939
9928: POP
// wait_for_them := false ; end ;
9929: LD_ADDR_EXP 22
9933: PUSH
9934: LD_INT 0
9936: ST_TO_ADDR
9937: GO 9940
9939: POP
// end ; save_group := save_group ^ JMM ;
9940: LD_ADDR_EXP 20
9944: PUSH
9945: LD_EXP 20
9949: PUSH
9950: LD_EXP 30
9954: ADD
9955: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
9956: LD_EXP 30
9960: PPUSH
9961: CALL_OW 64
// end ; if i = Lisa then
9965: LD_VAR 0 1
9969: PUSH
9970: LD_EXP 33
9974: EQUAL
9975: IFFALSE 10002
// begin save_group := save_group ^ Lisa ;
9977: LD_ADDR_EXP 20
9981: PUSH
9982: LD_EXP 20
9986: PUSH
9987: LD_EXP 33
9991: ADD
9992: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
9993: LD_EXP 33
9997: PPUSH
9998: CALL_OW 64
// end ; if i = Bobby then
10002: LD_VAR 0 1
10006: PUSH
10007: LD_EXP 31
10011: EQUAL
10012: IFFALSE 10039
// begin save_group := save_group ^ Bobby ;
10014: LD_ADDR_EXP 20
10018: PUSH
10019: LD_EXP 20
10023: PUSH
10024: LD_EXP 31
10028: ADD
10029: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
10030: LD_EXP 31
10034: PPUSH
10035: CALL_OW 64
// end ; if i = Cyrus then
10039: LD_VAR 0 1
10043: PUSH
10044: LD_EXP 32
10048: EQUAL
10049: IFFALSE 10076
// begin save_group := save_group ^ Cyrus ;
10051: LD_ADDR_EXP 20
10055: PUSH
10056: LD_EXP 20
10060: PUSH
10061: LD_EXP 32
10065: ADD
10066: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
10067: LD_EXP 32
10071: PPUSH
10072: CALL_OW 64
// end ; if i = Khatam then
10076: LD_VAR 0 1
10080: PUSH
10081: LD_EXP 34
10085: EQUAL
10086: IFFALSE 10113
// begin save_group := save_group ^ Khatam ;
10088: LD_ADDR_EXP 20
10092: PUSH
10093: LD_EXP 20
10097: PUSH
10098: LD_EXP 34
10102: ADD
10103: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
10104: LD_EXP 34
10108: PPUSH
10109: CALL_OW 64
// end ; if i = Frank then
10113: LD_VAR 0 1
10117: PUSH
10118: LD_EXP 44
10122: EQUAL
10123: IFFALSE 10150
// begin save_group := save_group ^ Frank ;
10125: LD_ADDR_EXP 20
10129: PUSH
10130: LD_EXP 20
10134: PUSH
10135: LD_EXP 44
10139: ADD
10140: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
10141: LD_EXP 44
10145: PPUSH
10146: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and not i in save_group then
10150: LD_VAR 0 1
10154: PPUSH
10155: CALL_OW 302
10159: PUSH
10160: LD_VAR 0 1
10164: PPUSH
10165: CALL_OW 247
10169: PUSH
10170: LD_INT 1
10172: EQUAL
10173: AND
10174: PUSH
10175: LD_VAR 0 1
10179: PUSH
10180: LD_EXP 20
10184: IN
10185: NOT
10186: AND
10187: IFFALSE 10214
// begin save_others := save_others ^ i ;
10189: LD_ADDR_EXP 19
10193: PUSH
10194: LD_EXP 19
10198: PUSH
10199: LD_VAR 0 1
10203: ADD
10204: ST_TO_ADDR
// RemoveUnit ( i ) ;
10205: LD_VAR 0 1
10209: PPUSH
10210: CALL_OW 64
// end ; end ;
10214: GO 9766
10216: POP
10217: POP
// end ;
10218: PPOPN 2
10220: END
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or ( wait_for_them and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 ) do
10221: LD_EXP 21
10225: NOT
10226: PUSH
10227: LD_EXP 22
10231: NOT
10232: AND
10233: PUSH
10234: LD_EXP 22
10238: PUSH
10239: LD_INT 22
10241: PUSH
10242: LD_INT 1
10244: PUSH
10245: EMPTY
10246: LIST
10247: LIST
10248: PUSH
10249: LD_INT 21
10251: PUSH
10252: LD_INT 1
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: PUSH
10259: EMPTY
10260: LIST
10261: LIST
10262: PPUSH
10263: CALL_OW 69
10267: PUSH
10268: LD_INT 0
10270: EQUAL
10271: AND
10272: OR
10273: IFFALSE 10282
10275: GO 10277
10277: DISABLE
// EndMission ;
10278: CALL 10283 0 0
10282: END
// export function EndMission ; var i ; begin
10283: LD_INT 0
10285: PPUSH
10286: PPUSH
// if solar_builded then
10287: LD_EXP 11
10291: IFFALSE 10305
// AddMedal ( Solar1 , 1 ) else
10293: LD_STRING Solar1
10295: PPUSH
10296: LD_INT 1
10298: PPUSH
10299: CALL_OW 101
10303: GO 10316
// AddMedal ( Solar1 , - 1 ) ;
10305: LD_STRING Solar1
10307: PPUSH
10308: LD_INT 1
10310: NEG
10311: PPUSH
10312: CALL_OW 101
// if veh_on_meta then
10316: LD_EXP 23
10320: IFFALSE 10334
// AddMedal ( Solar2 , 1 ) else
10322: LD_STRING Solar2
10324: PPUSH
10325: LD_INT 1
10327: PPUSH
10328: CALL_OW 101
10332: GO 10364
// if solar_builded then
10334: LD_EXP 11
10338: IFFALSE 10353
// AddMedal ( Solar2 , - 1 ) else
10340: LD_STRING Solar2
10342: PPUSH
10343: LD_INT 1
10345: NEG
10346: PPUSH
10347: CALL_OW 101
10351: GO 10364
// AddMedal ( Solar2 , - 2 ) ;
10353: LD_STRING Solar2
10355: PPUSH
10356: LD_INT 2
10358: NEG
10359: PPUSH
10360: CALL_OW 101
// if lose_counter = 0 then
10364: LD_EXP 29
10368: PUSH
10369: LD_INT 0
10371: EQUAL
10372: IFFALSE 10386
// AddMedal ( No , 1 ) else
10374: LD_STRING No
10376: PPUSH
10377: LD_INT 1
10379: PPUSH
10380: CALL_OW 101
10384: GO 10430
// if lose_counter > 0 and lose_counter < 4 then
10386: LD_EXP 29
10390: PUSH
10391: LD_INT 0
10393: GREATER
10394: PUSH
10395: LD_EXP 29
10399: PUSH
10400: LD_INT 4
10402: LESS
10403: AND
10404: IFFALSE 10419
// AddMedal ( No , - 1 ) else
10406: LD_STRING No
10408: PPUSH
10409: LD_INT 1
10411: NEG
10412: PPUSH
10413: CALL_OW 101
10417: GO 10430
// AddMedal ( UpTo4 , - 1 ) ;
10419: LD_STRING UpTo4
10421: PPUSH
10422: LD_INT 1
10424: NEG
10425: PPUSH
10426: CALL_OW 101
// GiveMedals ( MAIN ) ;
10430: LD_STRING MAIN
10432: PPUSH
10433: CALL_OW 102
// if IsDead ( Pokryshkin ) then
10437: LD_EXP 45
10441: PPUSH
10442: CALL_OW 301
10446: IFFALSE 10486
// for i in save_group ^ save_others do
10448: LD_ADDR_VAR 0 2
10452: PUSH
10453: LD_EXP 20
10457: PUSH
10458: LD_EXP 19
10462: ADD
10463: PUSH
10464: FOR_IN
10465: IFFALSE 10484
// AddExperience ( i , skill_combat , 1500 ) ;
10467: LD_VAR 0 2
10471: PPUSH
10472: LD_INT 1
10474: PPUSH
10475: LD_INT 1500
10477: PPUSH
10478: CALL_OW 492
10482: GO 10464
10484: POP
10485: POP
// RewardPeople ( save_group ^ save_others ) ;
10486: LD_EXP 20
10490: PUSH
10491: LD_EXP 19
10495: ADD
10496: PPUSH
10497: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
10501: LD_EXP 30
10505: PPUSH
10506: LD_STRING JMM
10508: PPUSH
10509: CALL_OW 38
// if Bobby in save_group then
10513: LD_EXP 31
10517: PUSH
10518: LD_EXP 20
10522: IN
10523: IFFALSE 10537
// SaveCharacters ( Bobby , Bobby ) ;
10525: LD_EXP 31
10529: PPUSH
10530: LD_STRING Bobby
10532: PPUSH
10533: CALL_OW 38
// if Cyrus in save_group then
10537: LD_EXP 32
10541: PUSH
10542: LD_EXP 20
10546: IN
10547: IFFALSE 10561
// SaveCharacters ( Cyrus , Cyrus ) ;
10549: LD_EXP 32
10553: PPUSH
10554: LD_STRING Cyrus
10556: PPUSH
10557: CALL_OW 38
// if Lisa in save_group then
10561: LD_EXP 33
10565: PUSH
10566: LD_EXP 20
10570: IN
10571: IFFALSE 10585
// SaveCharacters ( Lisa , Lisa ) ;
10573: LD_EXP 33
10577: PPUSH
10578: LD_STRING Lisa
10580: PPUSH
10581: CALL_OW 38
// if Frank in save_group then
10585: LD_EXP 44
10589: PUSH
10590: LD_EXP 20
10594: IN
10595: IFFALSE 10609
// SaveCharacters ( Frank , Frank ) ;
10597: LD_EXP 44
10601: PPUSH
10602: LD_STRING Frank
10604: PPUSH
10605: CALL_OW 38
// if Khatam in save_group then
10609: LD_EXP 34
10613: PUSH
10614: LD_EXP 20
10618: IN
10619: IFFALSE 10633
// SaveCharacters ( Khatam , Khatam ) ;
10621: LD_EXP 34
10625: PPUSH
10626: LD_STRING Khatam
10628: PPUSH
10629: CALL_OW 38
// if save_others then
10633: LD_EXP 19
10637: IFFALSE 10651
// SaveCharacters ( save_others , 03_others ) ;
10639: LD_EXP 19
10643: PPUSH
10644: LD_STRING 03_others
10646: PPUSH
10647: CALL_OW 38
// if Bierezov then
10651: LD_EXP 38
10655: IFFALSE 10665
// begin ResetFog ;
10657: CALL_OW 335
// DisplayEndingScene ;
10661: CALL 10674 0 0
// end ; YouWin ;
10665: CALL_OW 103
// end ;
10669: LD_VAR 0 1
10673: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
10674: LD_INT 0
10676: PPUSH
10677: PPUSH
10678: PPUSH
10679: PPUSH
10680: PPUSH
10681: PPUSH
// InGameOn ;
10682: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
10686: LD_INT 208
10688: PPUSH
10689: LD_INT 62
10691: PPUSH
10692: LD_INT 1
10694: PPUSH
10695: LD_INT 10
10697: NEG
10698: PPUSH
10699: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
10703: LD_INT 208
10705: PPUSH
10706: LD_INT 62
10708: PPUSH
10709: LD_INT 1
10711: PPUSH
10712: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
10716: LD_ADDR_VAR 0 3
10720: PUSH
10721: LD_INT 22
10723: PUSH
10724: LD_INT 3
10726: PUSH
10727: EMPTY
10728: LIST
10729: LIST
10730: PUSH
10731: LD_INT 2
10733: PUSH
10734: LD_INT 21
10736: PUSH
10737: LD_INT 2
10739: PUSH
10740: EMPTY
10741: LIST
10742: LIST
10743: PUSH
10744: LD_INT 21
10746: PUSH
10747: LD_INT 1
10749: PUSH
10750: EMPTY
10751: LIST
10752: LIST
10753: PUSH
10754: EMPTY
10755: LIST
10756: LIST
10757: LIST
10758: PUSH
10759: EMPTY
10760: LIST
10761: LIST
10762: PPUSH
10763: CALL_OW 69
10767: ST_TO_ADDR
// if filter then
10768: LD_VAR 0 3
10772: IFFALSE 10800
// for i in filter do
10774: LD_ADDR_VAR 0 2
10778: PUSH
10779: LD_VAR 0 3
10783: PUSH
10784: FOR_IN
10785: IFFALSE 10798
// RemoveUnit ( i ) ;
10787: LD_VAR 0 2
10791: PPUSH
10792: CALL_OW 64
10796: GO 10784
10798: POP
10799: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
10800: LD_ADDR_VAR 0 3
10804: PUSH
10805: LD_INT 22
10807: PUSH
10808: LD_INT 4
10810: PUSH
10811: EMPTY
10812: LIST
10813: LIST
10814: PUSH
10815: LD_INT 21
10817: PUSH
10818: LD_INT 1
10820: PUSH
10821: EMPTY
10822: LIST
10823: LIST
10824: PUSH
10825: EMPTY
10826: LIST
10827: LIST
10828: PPUSH
10829: CALL_OW 69
10833: ST_TO_ADDR
// if filter then
10834: LD_VAR 0 3
10838: IFFALSE 10869
// for i in filter do
10840: LD_ADDR_VAR 0 2
10844: PUSH
10845: LD_VAR 0 3
10849: PUSH
10850: FOR_IN
10851: IFFALSE 10867
// SetLives ( i , 0 ) ;
10853: LD_VAR 0 2
10857: PPUSH
10858: LD_INT 0
10860: PPUSH
10861: CALL_OW 234
10865: GO 10850
10867: POP
10868: POP
// uc_side := 4 ;
10869: LD_ADDR_OWVAR 20
10873: PUSH
10874: LD_INT 4
10876: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
10877: LD_ADDR_VAR 0 4
10881: PUSH
10882: LD_STRING Cornell
10884: PPUSH
10885: LD_INT 0
10887: PPUSH
10888: CALL 426 0 2
10892: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
10893: LD_VAR 0 4
10897: PPUSH
10898: LD_INT 208
10900: PPUSH
10901: LD_INT 62
10903: PPUSH
10904: LD_INT 0
10906: PPUSH
10907: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
10911: LD_VAR 0 4
10915: PPUSH
10916: LD_INT 100
10918: PPUSH
10919: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
10923: LD_INT 3
10925: PPUSH
10926: LD_VAR 0 4
10930: PPUSH
10931: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
10935: LD_INT 4
10937: PPUSH
10938: LD_INT 3
10940: PPUSH
10941: LD_INT 1
10943: PPUSH
10944: LD_INT 1
10946: PPUSH
10947: CALL_OW 80
// uc_side := 3 ;
10951: LD_ADDR_OWVAR 20
10955: PUSH
10956: LD_INT 3
10958: ST_TO_ADDR
// uc_nation := 3 ;
10959: LD_ADDR_OWVAR 21
10963: PUSH
10964: LD_INT 3
10966: ST_TO_ADDR
// InitHc ;
10967: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
10971: LD_ADDR_VAR 0 5
10975: PUSH
10976: LD_STRING Mikhail
10978: PPUSH
10979: LD_INT 0
10981: PPUSH
10982: CALL 426 0 2
10986: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
10987: LD_INT 1
10989: PPUSH
10990: LD_INT 1
10992: PPUSH
10993: LD_INT 0
10995: PPUSH
10996: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
11000: LD_ADDR_VAR 0 6
11004: PUSH
11005: LD_VAR 0 6
11009: PUSH
11010: CALL_OW 44
11014: ADD
11015: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
11016: LD_ADDR_VAR 0 6
11020: PUSH
11021: LD_VAR 0 6
11025: PUSH
11026: CALL_OW 44
11030: ADD
11031: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
11032: LD_INT 2
11034: PPUSH
11035: LD_INT 4
11037: PPUSH
11038: LD_INT 0
11040: PPUSH
11041: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
11045: LD_ADDR_VAR 0 6
11049: PUSH
11050: LD_VAR 0 6
11054: PUSH
11055: CALL_OW 44
11059: ADD
11060: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
11061: LD_VAR 0 5
11065: PPUSH
11066: LD_INT 17
11068: PPUSH
11069: LD_INT 0
11071: PPUSH
11072: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
11076: LD_VAR 0 5
11080: PPUSH
11081: LD_INT 210
11083: PPUSH
11084: LD_INT 63
11086: PPUSH
11087: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
11091: LD_VAR 0 5
11095: PPUSH
11096: LD_INT 208
11098: PPUSH
11099: LD_INT 62
11101: PPUSH
11102: CALL_OW 178
// for i in fake_russians do
11106: LD_ADDR_VAR 0 2
11110: PUSH
11111: LD_VAR 0 6
11115: PUSH
11116: FOR_IN
11117: IFFALSE 11195
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
11119: LD_VAR 0 2
11123: PPUSH
11124: LD_INT 17
11126: PPUSH
11127: LD_INT 0
11129: PPUSH
11130: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
11134: LD_VAR 0 2
11138: PPUSH
11139: LD_INT 215
11141: PPUSH
11142: LD_INT 67
11144: PPUSH
11145: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
11149: LD_VAR 0 2
11153: PPUSH
11154: LD_INT 208
11156: PPUSH
11157: LD_INT 62
11159: PPUSH
11160: CALL_OW 178
// if GetClass ( i ) = 4 then
11164: LD_VAR 0 2
11168: PPUSH
11169: CALL_OW 257
11173: PUSH
11174: LD_INT 4
11176: EQUAL
11177: IFFALSE 11193
// ComHeal ( i , fake_cornel ) ;
11179: LD_VAR 0 2
11183: PPUSH
11184: LD_VAR 0 4
11188: PPUSH
11189: CALL_OW 128
// end ;
11193: GO 11116
11195: POP
11196: POP
// Wait ( 0 0$01 ) ;
11197: LD_INT 35
11199: PPUSH
11200: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
11204: LD_INT 208
11206: PPUSH
11207: LD_INT 62
11209: PPUSH
11210: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
11214: LD_INT 208
11216: PPUSH
11217: LD_INT 62
11219: PPUSH
11220: LD_INT 1
11222: PPUSH
11223: LD_INT 10
11225: NEG
11226: PPUSH
11227: CALL_OW 330
// Wait ( 0 0$15 ) ;
11231: LD_INT 525
11233: PPUSH
11234: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
11238: LD_INT 208
11240: PPUSH
11241: LD_INT 62
11243: PPUSH
11244: LD_INT 1
11246: PPUSH
11247: CALL_OW 331
// ResetFog ;
11251: CALL_OW 335
// InGameOff ;
11255: CALL_OW 9
// end ;
11259: LD_VAR 0 1
11263: RET
// every 0 0$30 trigger GetDistUnits ( JMM , Cornel ) < 3 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) do
11264: LD_EXP 30
11268: PPUSH
11269: LD_EXP 37
11273: PPUSH
11274: CALL_OW 296
11278: PUSH
11279: LD_INT 3
11281: LESS
11282: PUSH
11283: LD_INT 22
11285: PUSH
11286: LD_INT 4
11288: PUSH
11289: EMPTY
11290: LIST
11291: LIST
11292: PUSH
11293: LD_INT 21
11295: PUSH
11296: LD_INT 3
11298: PUSH
11299: EMPTY
11300: LIST
11301: LIST
11302: PUSH
11303: EMPTY
11304: LIST
11305: LIST
11306: PPUSH
11307: CALL_OW 69
11311: AND
11312: IFFALSE 11330
11314: GO 11316
11316: DISABLE
// begin enable ;
11317: ENABLE
// SayRadio ( Powell , DWarn-Pow-1 ) ;
11318: LD_EXP 39
11322: PPUSH
11323: LD_STRING DWarn-Pow-1
11325: PPUSH
11326: CALL_OW 94
// end ; end_of_file
11330: END
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
11331: LD_EXP 6
11335: IFFALSE 12366
11337: GO 11339
11339: DISABLE
11340: LD_INT 0
11342: PPUSH
11343: PPUSH
11344: PPUSH
11345: PPUSH
11346: PPUSH
11347: PPUSH
11348: PPUSH
11349: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
11350: LD_EXP 37
11354: PUSH
11355: LD_EXP 38
11359: ADD
11360: PUSH
11361: LD_EXP 4
11365: ADD
11366: PPUSH
11367: LD_INT 250
11369: PPUSH
11370: LD_INT 120
11372: PPUSH
11373: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
11377: LD_ADDR_VAR 0 2
11381: PUSH
11382: LD_EXP 4
11386: PPUSH
11387: LD_INT 25
11389: PUSH
11390: LD_INT 2
11392: PUSH
11393: EMPTY
11394: LIST
11395: LIST
11396: PPUSH
11397: CALL_OW 72
11401: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
11402: LD_ADDR_VAR 0 3
11406: PUSH
11407: LD_EXP 4
11411: PPUSH
11412: LD_INT 21
11414: PUSH
11415: LD_INT 1
11417: PUSH
11418: EMPTY
11419: LIST
11420: LIST
11421: PPUSH
11422: CALL_OW 72
11426: ST_TO_ADDR
// if not has_eng then
11427: LD_VAR 0 2
11431: NOT
11432: IFFALSE 11515
// begin uc_side := 4 ;
11434: LD_ADDR_OWVAR 20
11438: PUSH
11439: LD_INT 4
11441: ST_TO_ADDR
// uc_nation := 1 ;
11442: LD_ADDR_OWVAR 21
11446: PUSH
11447: LD_INT 1
11449: ST_TO_ADDR
// bc_type := b_depot ;
11450: LD_ADDR_OWVAR 42
11454: PUSH
11455: LD_INT 0
11457: ST_TO_ADDR
// bc_level := 2 ;
11458: LD_ADDR_OWVAR 43
11462: PUSH
11463: LD_INT 2
11465: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
11466: LD_ADDR_VAR 0 4
11470: PUSH
11471: LD_INT 264
11473: PPUSH
11474: LD_INT 120
11476: PPUSH
11477: LD_INT 4
11479: PPUSH
11480: CALL_OW 47
11484: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
11485: LD_INT 264
11487: PPUSH
11488: LD_INT 120
11490: PPUSH
11491: LD_INT 4
11493: PPUSH
11494: LD_INT 10
11496: NEG
11497: PPUSH
11498: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
11502: LD_INT 264
11504: PPUSH
11505: LD_INT 120
11507: PPUSH
11508: LD_INT 4
11510: PPUSH
11511: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
11515: LD_INT 35
11517: PPUSH
11518: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
11522: LD_EXP 37
11526: PPUSH
11527: LD_INT 10
11529: PPUSH
11530: CALL_OW 308
11534: IFFALSE 11515
// if has_eng and not dep then
11536: LD_VAR 0 2
11540: PUSH
11541: LD_VAR 0 4
11545: NOT
11546: AND
11547: IFFALSE 11661
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
11549: LD_VAR 0 2
11553: PPUSH
11554: LD_INT 0
11556: PPUSH
11557: LD_INT 264
11559: PPUSH
11560: LD_INT 120
11562: PPUSH
11563: LD_INT 4
11565: PPUSH
11566: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
11570: LD_INT 35
11572: PPUSH
11573: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
11577: LD_INT 22
11579: PUSH
11580: LD_INT 4
11582: PUSH
11583: EMPTY
11584: LIST
11585: LIST
11586: PUSH
11587: LD_INT 30
11589: PUSH
11590: LD_INT 0
11592: PUSH
11593: EMPTY
11594: LIST
11595: LIST
11596: PUSH
11597: LD_INT 3
11599: PUSH
11600: LD_INT 57
11602: PUSH
11603: EMPTY
11604: LIST
11605: PUSH
11606: EMPTY
11607: LIST
11608: LIST
11609: PUSH
11610: EMPTY
11611: LIST
11612: LIST
11613: LIST
11614: PPUSH
11615: CALL_OW 69
11619: IFFALSE 11570
// dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
11621: LD_ADDR_VAR 0 4
11625: PUSH
11626: LD_INT 22
11628: PUSH
11629: LD_INT 4
11631: PUSH
11632: EMPTY
11633: LIST
11634: LIST
11635: PUSH
11636: LD_INT 30
11638: PUSH
11639: LD_INT 0
11641: PUSH
11642: EMPTY
11643: LIST
11644: LIST
11645: PUSH
11646: EMPTY
11647: LIST
11648: LIST
11649: PPUSH
11650: CALL_OW 69
11654: PUSH
11655: LD_INT 1
11657: ARRAY
11658: ST_TO_ADDR
// end else
11659: GO 11778
// begin SetSide ( dep , 4 ) ;
11661: LD_VAR 0 4
11665: PPUSH
11666: LD_INT 4
11668: PPUSH
11669: CALL_OW 235
// for i = 1 to 3 do
11673: LD_ADDR_VAR 0 1
11677: PUSH
11678: DOUBLE
11679: LD_INT 1
11681: DEC
11682: ST_TO_ADDR
11683: LD_INT 3
11685: PUSH
11686: FOR_TO
11687: IFFALSE 11744
// begin ComEnterUnit ( filter [ i ] , dep ) ;
11689: LD_VAR 0 3
11693: PUSH
11694: LD_VAR 0 1
11698: ARRAY
11699: PPUSH
11700: LD_VAR 0 4
11704: PPUSH
11705: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
11709: LD_VAR 0 3
11713: PUSH
11714: LD_VAR 0 1
11718: ARRAY
11719: PPUSH
11720: LD_INT 2
11722: PPUSH
11723: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
11727: LD_VAR 0 3
11731: PUSH
11732: LD_VAR 0 1
11736: ARRAY
11737: PPUSH
11738: CALL_OW 182
// end ;
11742: GO 11686
11744: POP
11745: POP
// repeat wait ( 0 0$01 ) ;
11746: LD_INT 35
11748: PPUSH
11749: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
11753: LD_VAR 0 3
11757: PPUSH
11758: LD_INT 25
11760: PUSH
11761: LD_INT 2
11763: PUSH
11764: EMPTY
11765: LIST
11766: LIST
11767: PPUSH
11768: CALL_OW 72
11772: PUSH
11773: LD_INT 3
11775: EQUAL
11776: IFFALSE 11746
// end ; ComEnterUnit ( Bierezov , dep ) ;
11778: LD_EXP 38
11782: PPUSH
11783: LD_VAR 0 4
11787: PPUSH
11788: CALL_OW 120
// if IsInUnit ( Cornel ) then
11792: LD_EXP 37
11796: PPUSH
11797: CALL_OW 310
11801: IFFALSE 11884
// begin cargo := IsInUnit ( Cornel ) ;
11803: LD_ADDR_VAR 0 7
11807: PUSH
11808: LD_EXP 37
11812: PPUSH
11813: CALL_OW 310
11817: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
11818: LD_VAR 0 7
11822: PPUSH
11823: LD_INT 1
11825: PPUSH
11826: CALL_OW 289
11830: IFFALSE 11846
// ComGive ( Cornel , dep ) ;
11832: LD_EXP 37
11836: PPUSH
11837: LD_VAR 0 4
11841: PPUSH
11842: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
11846: LD_EXP 37
11850: PPUSH
11851: LD_INT 235
11853: PPUSH
11854: LD_INT 122
11856: PPUSH
11857: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
11861: LD_EXP 37
11865: PPUSH
11866: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
11870: LD_EXP 37
11874: PPUSH
11875: LD_VAR 0 4
11879: PPUSH
11880: CALL_OW 180
// end ; has_eng := UnitFilter ( filter , [ f_class , 2 ] ) ;
11884: LD_ADDR_VAR 0 2
11888: PUSH
11889: LD_VAR 0 3
11893: PPUSH
11894: LD_INT 25
11896: PUSH
11897: LD_INT 2
11899: PUSH
11900: EMPTY
11901: LIST
11902: LIST
11903: PPUSH
11904: CALL_OW 72
11908: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
11909: LD_INT 35
11911: PPUSH
11912: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
11916: LD_ADDR_VAR 0 6
11920: PUSH
11921: LD_INT 10
11923: PPUSH
11924: CALL_OW 435
11928: ST_TO_ADDR
// if crates then
11929: LD_VAR 0 6
11933: IFFALSE 11962
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
11935: LD_VAR 0 2
11939: PPUSH
11940: LD_VAR 0 6
11944: PUSH
11945: LD_INT 1
11947: ARRAY
11948: PPUSH
11949: LD_VAR 0 6
11953: PUSH
11954: LD_INT 2
11956: ARRAY
11957: PPUSH
11958: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
11962: LD_VAR 0 4
11966: PPUSH
11967: CALL_OW 274
11971: PPUSH
11972: LD_INT 1
11974: PPUSH
11975: CALL_OW 275
11979: PUSH
11980: LD_INT 40
11982: GREATEREQUAL
11983: IFFALSE 11909
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
11985: LD_ADDR_VAR 0 5
11989: PUSH
11990: LD_INT 4
11992: PUSH
11993: LD_INT 256
11995: PUSH
11996: LD_INT 111
11998: PUSH
11999: LD_INT 2
12001: PUSH
12002: EMPTY
12003: LIST
12004: LIST
12005: LIST
12006: LIST
12007: PUSH
12008: LD_INT 31
12010: PUSH
12011: LD_INT 243
12013: PUSH
12014: LD_INT 112
12016: PUSH
12017: LD_INT 2
12019: PUSH
12020: EMPTY
12021: LIST
12022: LIST
12023: LIST
12024: LIST
12025: PUSH
12026: EMPTY
12027: LIST
12028: LIST
12029: ST_TO_ADDR
// for i in blist do
12030: LD_ADDR_VAR 0 1
12034: PUSH
12035: LD_VAR 0 5
12039: PUSH
12040: FOR_IN
12041: IFFALSE 12090
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
12043: LD_VAR 0 2
12047: PPUSH
12048: LD_VAR 0 1
12052: PUSH
12053: LD_INT 1
12055: ARRAY
12056: PPUSH
12057: LD_VAR 0 1
12061: PUSH
12062: LD_INT 2
12064: ARRAY
12065: PPUSH
12066: LD_VAR 0 1
12070: PUSH
12071: LD_INT 3
12073: ARRAY
12074: PPUSH
12075: LD_VAR 0 1
12079: PUSH
12080: LD_INT 4
12082: ARRAY
12083: PPUSH
12084: CALL_OW 205
12088: GO 12040
12090: POP
12091: POP
// repeat wait ( 0 0$01 ) ;
12092: LD_INT 35
12094: PPUSH
12095: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
12099: LD_INT 22
12101: PUSH
12102: LD_INT 4
12104: PUSH
12105: EMPTY
12106: LIST
12107: LIST
12108: PUSH
12109: LD_INT 30
12111: PUSH
12112: LD_INT 4
12114: PUSH
12115: EMPTY
12116: LIST
12117: LIST
12118: PUSH
12119: LD_INT 3
12121: PUSH
12122: LD_INT 57
12124: PUSH
12125: EMPTY
12126: LIST
12127: PUSH
12128: EMPTY
12129: LIST
12130: LIST
12131: PUSH
12132: EMPTY
12133: LIST
12134: LIST
12135: LIST
12136: PPUSH
12137: CALL_OW 69
12141: IFFALSE 12092
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
12143: LD_VAR 0 3
12147: PUSH
12148: LD_VAR 0 2
12152: DIFF
12153: PPUSH
12154: LD_INT 22
12156: PUSH
12157: LD_INT 4
12159: PUSH
12160: EMPTY
12161: LIST
12162: LIST
12163: PUSH
12164: LD_INT 30
12166: PUSH
12167: LD_INT 4
12169: PUSH
12170: EMPTY
12171: LIST
12172: LIST
12173: PUSH
12174: EMPTY
12175: LIST
12176: LIST
12177: PPUSH
12178: CALL_OW 69
12182: PUSH
12183: LD_INT 1
12185: ARRAY
12186: PPUSH
12187: CALL_OW 180
// repeat wait ( 0 0$01 ) ;
12191: LD_INT 35
12193: PPUSH
12194: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
12198: LD_INT 22
12200: PUSH
12201: LD_INT 4
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: LD_INT 30
12210: PUSH
12211: LD_INT 31
12213: PUSH
12214: EMPTY
12215: LIST
12216: LIST
12217: PUSH
12218: LD_INT 3
12220: PUSH
12221: LD_INT 57
12223: PUSH
12224: EMPTY
12225: LIST
12226: PUSH
12227: EMPTY
12228: LIST
12229: LIST
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: LIST
12235: PPUSH
12236: CALL_OW 69
12240: IFFALSE 12191
// sol := filter diff has_eng ;
12242: LD_ADDR_VAR 0 8
12246: PUSH
12247: LD_VAR 0 3
12251: PUSH
12252: LD_VAR 0 2
12256: DIFF
12257: ST_TO_ADDR
// if GetClass ( sol [ 1 ] ) > 1 then
12258: LD_VAR 0 8
12262: PUSH
12263: LD_INT 1
12265: ARRAY
12266: PPUSH
12267: CALL_OW 257
12271: PUSH
12272: LD_INT 1
12274: GREATER
12275: IFFALSE 12293
// SetClass ( sol [ 1 ] , 1 ) ;
12277: LD_VAR 0 8
12281: PUSH
12282: LD_INT 1
12284: ARRAY
12285: PPUSH
12286: LD_INT 1
12288: PPUSH
12289: CALL_OW 336
// ComExitBuilding ( sol [ 1 ] ) ;
12293: LD_VAR 0 8
12297: PUSH
12298: LD_INT 1
12300: ARRAY
12301: PPUSH
12302: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
12306: LD_VAR 0 8
12310: PUSH
12311: LD_INT 1
12313: ARRAY
12314: PPUSH
12315: LD_INT 22
12317: PUSH
12318: LD_INT 4
12320: PUSH
12321: EMPTY
12322: LIST
12323: LIST
12324: PUSH
12325: LD_INT 30
12327: PUSH
12328: LD_INT 31
12330: PUSH
12331: EMPTY
12332: LIST
12333: LIST
12334: PUSH
12335: EMPTY
12336: LIST
12337: LIST
12338: PPUSH
12339: CALL_OW 69
12343: PUSH
12344: LD_INT 1
12346: ARRAY
12347: PPUSH
12348: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
12352: LD_VAR 0 2
12356: PPUSH
12357: LD_VAR 0 4
12361: PPUSH
12362: CALL_OW 112
// end ;
12366: PPOPN 8
12368: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
12369: LD_EXP 9
12373: IFFALSE 12693
12375: GO 12377
12377: DISABLE
12378: LD_INT 0
12380: PPUSH
12381: PPUSH
12382: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
12383: LD_ADDR_VAR 0 2
12387: PUSH
12388: LD_INT 22
12390: PUSH
12391: LD_INT 4
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PUSH
12398: LD_INT 30
12400: PUSH
12401: LD_INT 4
12403: PUSH
12404: EMPTY
12405: LIST
12406: LIST
12407: PUSH
12408: EMPTY
12409: LIST
12410: LIST
12411: PPUSH
12412: CALL_OW 69
12416: PUSH
12417: LD_INT 1
12419: ARRAY
12420: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
12421: LD_EXP 4
12425: PPUSH
12426: CALL_OW 122
// for i in cornel_units do
12430: LD_ADDR_VAR 0 1
12434: PUSH
12435: LD_EXP 4
12439: PUSH
12440: FOR_IN
12441: IFFALSE 12495
// if GetClass ( i ) = 2 then
12443: LD_VAR 0 1
12447: PPUSH
12448: CALL_OW 257
12452: PUSH
12453: LD_INT 2
12455: EQUAL
12456: IFFALSE 12493
// begin ComEnterUnit ( i , arm ) ;
12458: LD_VAR 0 1
12462: PPUSH
12463: LD_VAR 0 2
12467: PPUSH
12468: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
12472: LD_VAR 0 1
12476: PPUSH
12477: LD_INT 1
12479: PPUSH
12480: CALL_OW 183
// AddComExitBuilding ( i ) ;
12484: LD_VAR 0 1
12488: PPUSH
12489: CALL_OW 182
// end ;
12493: GO 12440
12495: POP
12496: POP
// Wait ( 1 1$00 ) ;
12497: LD_INT 2100
12499: PPUSH
12500: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
12504: LD_ADDR_VAR 0 3
12508: PUSH
12509: LD_EXP 37
12513: PUSH
12514: LD_EXP 38
12518: ADD
12519: PUSH
12520: LD_EXP 4
12524: ADD
12525: PUSH
12526: LD_EXP 4
12530: PPUSH
12531: LD_INT 21
12533: PUSH
12534: LD_INT 2
12536: PUSH
12537: EMPTY
12538: LIST
12539: LIST
12540: PPUSH
12541: CALL_OW 72
12545: DIFF
12546: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
12547: LD_VAR 0 3
12551: PPUSH
12552: LD_INT 248
12554: PPUSH
12555: LD_INT 85
12557: PPUSH
12558: CALL_OW 111
// AddComHold ( filter ) ;
12562: LD_VAR 0 3
12566: PPUSH
12567: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
12571: LD_INT 35
12573: PPUSH
12574: CALL_OW 67
// until cornel_attack ;
12578: LD_EXP 7
12582: IFFALSE 12571
// ComAgressiveMove ( filter , 209 , 63 ) ;
12584: LD_VAR 0 3
12588: PPUSH
12589: LD_INT 209
12591: PPUSH
12592: LD_INT 63
12594: PPUSH
12595: CALL_OW 114
// if Bierezov then
12599: LD_EXP 38
12603: IFFALSE 12693
// begin filter := filter diff Bierezov ;
12605: LD_ADDR_VAR 0 3
12609: PUSH
12610: LD_VAR 0 3
12614: PUSH
12615: LD_EXP 38
12619: DIFF
12620: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
12621: LD_EXP 38
12625: PPUSH
12626: LD_INT 6
12628: PPUSH
12629: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
12633: LD_EXP 38
12637: PPUSH
12638: LD_INT 235
12640: PPUSH
12641: LD_INT 60
12643: PPUSH
12644: CALL_OW 111
// AddComHold ( Bierezov ) ;
12648: LD_EXP 38
12652: PPUSH
12653: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
12657: LD_EXP 38
12661: PPUSH
12662: LD_INT 350
12664: PPUSH
12665: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
12669: LD_EXP 38
12673: PPUSH
12674: LD_INT 198
12676: PPUSH
12677: LD_INT 28
12679: PPUSH
12680: CALL_OW 171
// AddComHold ( Bierezov ) ;
12684: LD_EXP 38
12688: PPUSH
12689: CALL_OW 200
// end ; end ; end_of_file
12693: PPOPN 3
12695: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
12696: LD_EXP 46
12700: PUSH
12701: LD_EXP 26
12705: NOT
12706: AND
12707: PUSH
12708: LD_EXP 27
12712: NOT
12713: AND
12714: IFFALSE 13164
12716: GO 12718
12718: DISABLE
12719: LD_INT 0
12721: PPUSH
12722: PPUSH
12723: PPUSH
12724: PPUSH
// begin enable ;
12725: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
12726: LD_ADDR_VAR 0 4
12730: PUSH
12731: LD_INT 81
12733: PUSH
12734: LD_INT 3
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: PPUSH
12741: CALL_OW 69
12745: ST_TO_ADDR
// for i = 1 to ru_patrol do
12746: LD_ADDR_VAR 0 2
12750: PUSH
12751: DOUBLE
12752: LD_INT 1
12754: DEC
12755: ST_TO_ADDR
12756: LD_EXP 46
12760: PUSH
12761: FOR_TO
12762: IFFALSE 13162
// begin un := ru_patrol [ i ] ;
12764: LD_ADDR_VAR 0 1
12768: PUSH
12769: LD_EXP 46
12773: PUSH
12774: LD_VAR 0 2
12778: ARRAY
12779: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
12780: LD_VAR 0 1
12784: PPUSH
12785: LD_INT 13
12787: PPUSH
12788: CALL_OW 308
12792: IFFALSE 12897
// begin if not ru_alert then
12794: LD_EXP 51
12798: NOT
12799: IFFALSE 12809
// ru_alert := true ;
12801: LD_ADDR_EXP 51
12805: PUSH
12806: LD_INT 1
12808: ST_TO_ADDR
// if not See ( 1 , un ) then
12809: LD_INT 1
12811: PPUSH
12812: LD_VAR 0 1
12816: PPUSH
12817: CALL_OW 292
12821: NOT
12822: IFFALSE 12836
// SetLives ( un , 1000 ) ;
12824: LD_VAR 0 1
12828: PPUSH
12829: LD_INT 1000
12831: PPUSH
12832: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
12836: LD_ADDR_EXP 46
12840: PUSH
12841: LD_EXP 46
12845: PUSH
12846: LD_VAR 0 1
12850: DIFF
12851: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
12852: LD_VAR 0 1
12856: PPUSH
12857: LD_INT 22
12859: PUSH
12860: LD_INT 3
12862: PUSH
12863: EMPTY
12864: LIST
12865: LIST
12866: PUSH
12867: LD_INT 30
12869: PUSH
12870: LD_INT 4
12872: PUSH
12873: EMPTY
12874: LIST
12875: LIST
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: PPUSH
12881: CALL_OW 69
12885: PPUSH
12886: CALL 1018 0 1
12890: PPUSH
12891: CALL_OW 120
// continue ;
12895: GO 12761
// end ; if IsOk ( un ) and not HasTask ( un ) then
12897: LD_VAR 0 1
12901: PPUSH
12902: CALL_OW 302
12906: PUSH
12907: LD_VAR 0 1
12911: PPUSH
12912: CALL_OW 314
12916: NOT
12917: AND
12918: IFFALSE 13011
// begin for j = 1 to ru_firepoints_south [ i ] do
12920: LD_ADDR_VAR 0 3
12924: PUSH
12925: DOUBLE
12926: LD_INT 1
12928: DEC
12929: ST_TO_ADDR
12930: LD_EXP 50
12934: PUSH
12935: LD_VAR 0 2
12939: ARRAY
12940: PUSH
12941: FOR_TO
12942: IFFALSE 13009
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
12944: LD_VAR 0 1
12948: PPUSH
12949: LD_EXP 50
12953: PUSH
12954: LD_VAR 0 2
12958: ARRAY
12959: PUSH
12960: LD_VAR 0 3
12964: ARRAY
12965: PUSH
12966: LD_INT 1
12968: ARRAY
12969: PPUSH
12970: LD_EXP 50
12974: PUSH
12975: LD_VAR 0 2
12979: ARRAY
12980: PUSH
12981: LD_VAR 0 3
12985: ARRAY
12986: PUSH
12987: LD_INT 2
12989: ARRAY
12990: PPUSH
12991: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
12995: LD_VAR 0 1
12999: PPUSH
13000: LD_INT 70
13002: PPUSH
13003: CALL_OW 202
// end ;
13007: GO 12941
13009: POP
13010: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
13011: LD_VAR 0 1
13015: PPUSH
13016: CALL_OW 256
13020: PUSH
13021: LD_INT 700
13023: LESS
13024: PUSH
13025: LD_VAR 0 1
13029: PPUSH
13030: LD_INT 13
13032: PPUSH
13033: CALL_OW 308
13037: NOT
13038: AND
13039: IFFALSE 13091
// begin ComMoveToArea ( un , retreatArea ) ;
13041: LD_VAR 0 1
13045: PPUSH
13046: LD_INT 13
13048: PPUSH
13049: CALL_OW 113
// if not ru_alert_xy then
13053: LD_EXP 52
13057: NOT
13058: IFFALSE 13089
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
13060: LD_ADDR_EXP 52
13064: PUSH
13065: LD_VAR 0 1
13069: PPUSH
13070: CALL_OW 250
13074: PUSH
13075: LD_VAR 0 1
13079: PPUSH
13080: CALL_OW 251
13084: PUSH
13085: EMPTY
13086: LIST
13087: LIST
13088: ST_TO_ADDR
// end else
13089: GO 13160
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
13091: LD_VAR 0 1
13095: PPUSH
13096: LD_VAR 0 4
13100: PPUSH
13101: LD_VAR 0 1
13105: PPUSH
13106: CALL_OW 74
13110: PPUSH
13111: CALL_OW 296
13115: PUSH
13116: LD_INT 9
13118: LESS
13119: PUSH
13120: LD_VAR 0 1
13124: PPUSH
13125: CALL_OW 256
13129: PUSH
13130: LD_INT 500
13132: GREATER
13133: AND
13134: IFFALSE 13160
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
13136: LD_VAR 0 1
13140: PPUSH
13141: LD_VAR 0 4
13145: PPUSH
13146: LD_VAR 0 1
13150: PPUSH
13151: CALL_OW 74
13155: PPUSH
13156: CALL_OW 115
// end ;
13160: GO 12761
13162: POP
13163: POP
// end ;
13164: PPOPN 4
13166: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
13167: LD_EXP 51
13171: PUSH
13172: LD_EXP 52
13176: AND
13177: PUSH
13178: LD_EXP 26
13182: NOT
13183: AND
13184: PUSH
13185: LD_EXP 27
13189: NOT
13190: AND
13191: IFFALSE 13401
13193: GO 13195
13195: DISABLE
13196: LD_INT 0
13198: PPUSH
13199: PPUSH
// begin enable ;
13200: ENABLE
// if not ru_vehicles then
13201: LD_EXP 49
13205: NOT
13206: IFFALSE 13210
// exit ;
13208: GO 13401
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
13210: LD_ADDR_VAR 0 2
13214: PUSH
13215: LD_INT 81
13217: PUSH
13218: LD_INT 3
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: PPUSH
13225: CALL_OW 69
13229: ST_TO_ADDR
// if ru_vehicles then
13230: LD_EXP 49
13234: IFFALSE 13401
// begin for i in ru_vehicles do
13236: LD_ADDR_VAR 0 1
13240: PUSH
13241: LD_EXP 49
13245: PUSH
13246: FOR_IN
13247: IFFALSE 13399
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
13249: LD_VAR 0 1
13253: PPUSH
13254: CALL_OW 302
13258: PUSH
13259: LD_VAR 0 1
13263: PPUSH
13264: LD_VAR 0 2
13268: PPUSH
13269: LD_VAR 0 1
13273: PPUSH
13274: CALL_OW 74
13278: PPUSH
13279: CALL_OW 296
13283: PUSH
13284: LD_INT 9
13286: LESS
13287: AND
13288: IFFALSE 13314
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
13290: LD_VAR 0 1
13294: PPUSH
13295: LD_VAR 0 2
13299: PPUSH
13300: LD_VAR 0 1
13304: PPUSH
13305: CALL_OW 74
13309: PPUSH
13310: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
13314: LD_VAR 0 1
13318: PPUSH
13319: CALL_OW 314
13323: NOT
13324: PUSH
13325: LD_VAR 0 1
13329: PPUSH
13330: CALL_OW 302
13334: AND
13335: PUSH
13336: LD_VAR 0 1
13340: PPUSH
13341: LD_EXP 52
13345: PUSH
13346: LD_INT 1
13348: ARRAY
13349: PPUSH
13350: LD_EXP 52
13354: PUSH
13355: LD_INT 2
13357: ARRAY
13358: PPUSH
13359: CALL_OW 297
13363: PUSH
13364: LD_INT 10
13366: GREATER
13367: AND
13368: IFFALSE 13397
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
13370: LD_VAR 0 1
13374: PPUSH
13375: LD_EXP 52
13379: PUSH
13380: LD_INT 1
13382: ARRAY
13383: PPUSH
13384: LD_EXP 52
13388: PUSH
13389: LD_INT 2
13391: ARRAY
13392: PPUSH
13393: CALL_OW 114
// end ;
13397: GO 13246
13399: POP
13400: POP
// end ; end ;
13401: PPOPN 2
13403: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
13404: LD_EXP 52
13408: PUSH
13409: LD_EXP 51
13413: AND
13414: PUSH
13415: LD_INT 3
13417: PPUSH
13418: CALL_OW 463
13422: NOT
13423: AND
13424: PUSH
13425: LD_EXP 26
13429: NOT
13430: AND
13431: PUSH
13432: LD_EXP 27
13436: NOT
13437: AND
13438: IFFALSE 13533
13440: GO 13442
13442: DISABLE
13443: LD_INT 0
13445: PPUSH
// begin enable ;
13446: ENABLE
// ru_alert_xy := false ;
13447: LD_ADDR_EXP 52
13451: PUSH
13452: LD_INT 0
13454: ST_TO_ADDR
// ru_alert := false ;
13455: LD_ADDR_EXP 51
13459: PUSH
13460: LD_INT 0
13462: ST_TO_ADDR
// if ru_vehicles then
13463: LD_EXP 49
13467: IFFALSE 13533
// for i in ru_vehicles do
13469: LD_ADDR_VAR 0 1
13473: PUSH
13474: LD_EXP 49
13478: PUSH
13479: FOR_IN
13480: IFFALSE 13531
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
13482: LD_VAR 0 1
13486: PPUSH
13487: CALL_OW 302
13491: PUSH
13492: LD_VAR 0 1
13496: PPUSH
13497: LD_INT 89
13499: PPUSH
13500: LD_INT 36
13502: PPUSH
13503: CALL_OW 297
13507: PUSH
13508: LD_INT 10
13510: GREATER
13511: AND
13512: IFFALSE 13529
// ComMoveXY ( i , 89 , 36 ) ;
13514: LD_VAR 0 1
13518: PPUSH
13519: LD_INT 89
13521: PPUSH
13522: LD_INT 36
13524: PPUSH
13525: CALL_OW 111
13529: GO 13479
13531: POP
13532: POP
// end ;
13533: PPOPN 1
13535: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
13536: LD_EXP 48
13540: PUSH
13541: LD_EXP 26
13545: NOT
13546: AND
13547: PUSH
13548: LD_EXP 27
13552: NOT
13553: AND
13554: IFFALSE 13838
13556: GO 13558
13558: DISABLE
13559: LD_INT 0
13561: PPUSH
13562: PPUSH
13563: PPUSH
// begin enable ;
13564: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
13565: LD_ADDR_VAR 0 3
13569: PUSH
13570: LD_INT 81
13572: PUSH
13573: LD_INT 3
13575: PUSH
13576: EMPTY
13577: LIST
13578: LIST
13579: PPUSH
13580: CALL_OW 69
13584: ST_TO_ADDR
// for i = 1 to ru_forest do
13585: LD_ADDR_VAR 0 1
13589: PUSH
13590: DOUBLE
13591: LD_INT 1
13593: DEC
13594: ST_TO_ADDR
13595: LD_EXP 48
13599: PUSH
13600: FOR_TO
13601: IFFALSE 13836
// begin un := ru_forest [ i ] ;
13603: LD_ADDR_VAR 0 2
13607: PUSH
13608: LD_EXP 48
13612: PUSH
13613: LD_VAR 0 1
13617: ARRAY
13618: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
13619: LD_VAR 0 2
13623: PPUSH
13624: LD_INT 13
13626: PPUSH
13627: CALL_OW 308
13631: IFFALSE 13721
// begin if not See ( 1 , un ) then
13633: LD_INT 1
13635: PPUSH
13636: LD_VAR 0 2
13640: PPUSH
13641: CALL_OW 292
13645: NOT
13646: IFFALSE 13660
// SetLives ( un , 1000 ) ;
13648: LD_VAR 0 2
13652: PPUSH
13653: LD_INT 1000
13655: PPUSH
13656: CALL_OW 234
// ru_forest := ru_forest diff un ;
13660: LD_ADDR_EXP 48
13664: PUSH
13665: LD_EXP 48
13669: PUSH
13670: LD_VAR 0 2
13674: DIFF
13675: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
13676: LD_VAR 0 2
13680: PPUSH
13681: LD_INT 22
13683: PUSH
13684: LD_INT 3
13686: PUSH
13687: EMPTY
13688: LIST
13689: LIST
13690: PUSH
13691: LD_INT 30
13693: PUSH
13694: LD_INT 4
13696: PUSH
13697: EMPTY
13698: LIST
13699: LIST
13700: PUSH
13701: EMPTY
13702: LIST
13703: LIST
13704: PPUSH
13705: CALL_OW 69
13709: PPUSH
13710: CALL 1018 0 1
13714: PPUSH
13715: CALL_OW 120
// continue ;
13719: GO 13600
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
13721: LD_VAR 0 2
13725: PPUSH
13726: CALL_OW 256
13730: PUSH
13731: LD_INT 700
13733: LESS
13734: PUSH
13735: LD_VAR 0 2
13739: PPUSH
13740: LD_INT 13
13742: PPUSH
13743: CALL_OW 308
13747: NOT
13748: AND
13749: IFFALSE 13765
// ComMoveToArea ( un , retreatArea ) else
13751: LD_VAR 0 2
13755: PPUSH
13756: LD_INT 13
13758: PPUSH
13759: CALL_OW 113
13763: GO 13834
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
13765: LD_VAR 0 2
13769: PPUSH
13770: LD_VAR 0 3
13774: PPUSH
13775: LD_VAR 0 2
13779: PPUSH
13780: CALL_OW 74
13784: PPUSH
13785: CALL_OW 296
13789: PUSH
13790: LD_INT 9
13792: LESS
13793: PUSH
13794: LD_VAR 0 2
13798: PPUSH
13799: CALL_OW 256
13803: PUSH
13804: LD_INT 500
13806: GREATER
13807: AND
13808: IFFALSE 13834
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
13810: LD_VAR 0 2
13814: PPUSH
13815: LD_VAR 0 3
13819: PPUSH
13820: LD_VAR 0 2
13824: PPUSH
13825: CALL_OW 74
13829: PPUSH
13830: CALL_OW 115
// end ;
13834: GO 13600
13836: POP
13837: POP
// end ;
13838: PPOPN 3
13840: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
13841: LD_EXP 27
13845: NOT
13846: IFFALSE 13967
13848: GO 13850
13850: DISABLE
13851: LD_INT 0
13853: PPUSH
13854: PPUSH
// begin enable ;
13855: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
13856: LD_ADDR_VAR 0 2
13860: PUSH
13861: LD_INT 22
13863: PUSH
13864: LD_INT 3
13866: PUSH
13867: EMPTY
13868: LIST
13869: LIST
13870: PUSH
13871: LD_INT 21
13873: PUSH
13874: LD_INT 3
13876: PUSH
13877: EMPTY
13878: LIST
13879: LIST
13880: PUSH
13881: EMPTY
13882: LIST
13883: LIST
13884: PPUSH
13885: CALL_OW 69
13889: ST_TO_ADDR
// if filter then
13890: LD_VAR 0 2
13894: IFFALSE 13967
// for i in filter do
13896: LD_ADDR_VAR 0 1
13900: PUSH
13901: LD_VAR 0 2
13905: PUSH
13906: FOR_IN
13907: IFFALSE 13965
// if GetLives ( i ) < 990 then
13909: LD_VAR 0 1
13913: PPUSH
13914: CALL_OW 256
13918: PUSH
13919: LD_INT 990
13921: LESS
13922: IFFALSE 13963
// begin ru_alert := true ;
13924: LD_ADDR_EXP 51
13928: PUSH
13929: LD_INT 1
13931: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
13932: LD_ADDR_EXP 52
13936: PUSH
13937: LD_VAR 0 1
13941: PPUSH
13942: CALL_OW 250
13946: PUSH
13947: LD_VAR 0 1
13951: PPUSH
13952: CALL_OW 251
13956: PUSH
13957: EMPTY
13958: LIST
13959: LIST
13960: ST_TO_ADDR
// break ;
13961: GO 13965
// end ;
13963: GO 13906
13965: POP
13966: POP
// end ;
13967: PPOPN 2
13969: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
13970: LD_EXP 26
13974: IFFALSE 14113
13976: GO 13978
13978: DISABLE
13979: LD_INT 0
13981: PPUSH
13982: PPUSH
13983: PPUSH
13984: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
13985: LD_ADDR_VAR 0 4
13989: PUSH
13990: LD_EXP 49
13994: PUSH
13995: LD_EXP 48
13999: ADD
14000: PUSH
14001: LD_EXP 46
14005: ADD
14006: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
14007: LD_ADDR_VAR 0 3
14011: PUSH
14012: LD_INT 3
14014: PPUSH
14015: LD_INT 81
14017: PUSH
14018: LD_INT 3
14020: PUSH
14021: EMPTY
14022: LIST
14023: LIST
14024: PPUSH
14025: CALL_OW 70
14029: ST_TO_ADDR
// if filter and enemy then
14030: LD_VAR 0 4
14034: PUSH
14035: LD_VAR 0 3
14039: AND
14040: IFFALSE 14113
// repeat wait ( 0 0$01 ) ;
14042: LD_INT 35
14044: PPUSH
14045: CALL_OW 67
// for i in filter do
14049: LD_ADDR_VAR 0 1
14053: PUSH
14054: LD_VAR 0 4
14058: PUSH
14059: FOR_IN
14060: IFFALSE 14088
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
14062: LD_VAR 0 1
14066: PPUSH
14067: LD_VAR 0 3
14071: PPUSH
14072: LD_VAR 0 1
14076: PPUSH
14077: CALL_OW 74
14081: PPUSH
14082: CALL_OW 115
// end ;
14086: GO 14059
14088: POP
14089: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 ;
14090: LD_INT 3
14092: PPUSH
14093: LD_INT 81
14095: PUSH
14096: LD_INT 3
14098: PUSH
14099: EMPTY
14100: LIST
14101: LIST
14102: PPUSH
14103: CALL_OW 70
14107: PUSH
14108: LD_INT 0
14110: EQUAL
14111: IFFALSE 14042
// end ; end_of_file
14113: PPOPN 4
14115: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
14116: LD_EXP 3
14120: PUSH
14121: LD_EXP 7
14125: NOT
14126: AND
14127: PUSH
14128: LD_EXP 17
14132: AND
14133: IFFALSE 14245
14135: GO 14137
14137: DISABLE
14138: LD_INT 0
14140: PPUSH
// begin enable ;
14141: ENABLE
// crates_counter := crates_counter - 50 ;
14142: LD_ADDR_EXP 17
14146: PUSH
14147: LD_EXP 17
14151: PUSH
14152: LD_INT 50
14154: MINUS
14155: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
14156: LD_INT 8
14158: PPUSH
14159: LD_INT 2
14161: PPUSH
14162: LD_INT 5
14164: PPUSH
14165: CALL_OW 12
14169: PPUSH
14170: LD_INT 1
14172: PPUSH
14173: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
14177: LD_INT 1785
14179: PPUSH
14180: LD_INT 2345
14182: PPUSH
14183: CALL_OW 12
14187: PPUSH
14188: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
14192: LD_ADDR_VAR 0 1
14196: PUSH
14197: LD_INT 1
14199: PPUSH
14200: LD_OWVAR 67
14204: PUSH
14205: LD_INT 2
14207: PLUS
14208: PPUSH
14209: CALL_OW 12
14213: ST_TO_ADDR
// if r < 3 then
14214: LD_VAR 0 1
14218: PUSH
14219: LD_INT 3
14221: LESS
14222: IFFALSE 14245
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
14224: LD_INT 4
14226: PPUSH
14227: LD_INT 1
14229: PPUSH
14230: LD_INT 5
14232: PPUSH
14233: CALL_OW 12
14237: PPUSH
14238: LD_INT 1
14240: PPUSH
14241: CALL_OW 55
// end ;
14245: PPOPN 1
14247: END
// every 0 0$01 trigger cornel_active do
14248: LD_EXP 6
14252: IFFALSE 14341
14254: GO 14256
14256: DISABLE
// begin Wait ( 0 0$03 ) ;
14257: LD_INT 105
14259: PPUSH
14260: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
14264: LD_INT 2
14266: PPUSH
14267: LD_INT 5
14269: PPUSH
14270: CALL_OW 12
14274: PPUSH
14275: LD_INT 10
14277: PPUSH
14278: LD_INT 1
14280: PPUSH
14281: CALL_OW 55
// Wait ( 0 0$13 ) ;
14285: LD_INT 455
14287: PPUSH
14288: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
14292: LD_INT 2
14294: PPUSH
14295: LD_INT 5
14297: PPUSH
14298: CALL_OW 12
14302: PPUSH
14303: LD_INT 10
14305: PPUSH
14306: LD_INT 1
14308: PPUSH
14309: CALL_OW 55
// Wait ( 0 0$16 ) ;
14313: LD_INT 560
14315: PPUSH
14316: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
14320: LD_INT 2
14322: PPUSH
14323: LD_INT 5
14325: PPUSH
14326: CALL_OW 12
14330: PPUSH
14331: LD_INT 10
14333: PPUSH
14334: LD_INT 1
14336: PPUSH
14337: CALL_OW 55
// end ; end_of_file
14341: END
// every 0 0$01 trigger cornel_prepared do
14342: LD_EXP 9
14346: IFFALSE 14405
14348: GO 14350
14350: DISABLE
// begin enable ;
14351: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
14352: LD_ADDR_OWVAR 47
14356: PUSH
14357: LD_STRING #Am03-1
14359: PUSH
14360: LD_EXP 8
14364: PUSH
14365: EMPTY
14366: LIST
14367: LIST
14368: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
14369: LD_ADDR_EXP 8
14373: PUSH
14374: LD_EXP 8
14378: PPUSH
14379: LD_STRING -
14381: PPUSH
14382: CALL 1088 0 2
14386: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
14387: LD_EXP 8
14391: PUSH
14392: LD_INT 0
14394: EQUAL
14395: IFFALSE 14405
// begin Display_Strings := [ ] ;
14397: LD_ADDR_OWVAR 47
14401: PUSH
14402: EMPTY
14403: ST_TO_ADDR
// disable ;
14404: DISABLE
// end ; end ;
14405: END
// every 0 0$01 trigger debug and debug_strings do
14406: LD_EXP 1
14410: PUSH
14411: LD_OWVAR 48
14415: AND
14416: IFFALSE 14432
14418: GO 14420
14420: DISABLE
// begin enable ;
14421: ENABLE
// Display_Strings := debug_strings ;
14422: LD_ADDR_OWVAR 47
14426: PUSH
14427: LD_OWVAR 48
14431: ST_TO_ADDR
// end ; end_of_file
14432: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
14433: LD_VAR 0 1
14437: PPUSH
14438: CALL_OW 255
14442: PUSH
14443: LD_INT 1
14445: EQUAL
14446: PUSH
14447: LD_EXP 11
14451: NOT
14452: AND
14453: IFFALSE 14463
// solar_builded := true ;
14455: LD_ADDR_EXP 11
14459: PUSH
14460: LD_INT 1
14462: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
14463: LD_VAR 0 1
14467: PPUSH
14468: CALL_OW 255
14472: PUSH
14473: LD_INT 1
14475: EQUAL
14476: PUSH
14477: LD_EXP 24
14481: AND
14482: IFFALSE 14515
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
14484: LD_ADDR_EXP 24
14488: PUSH
14489: LD_EXP 24
14493: PUSH
14494: LD_INT 1750
14496: PUSH
14497: LD_INT 1400
14499: PUSH
14500: LD_INT 1225
14502: PUSH
14503: EMPTY
14504: LIST
14505: LIST
14506: LIST
14507: PUSH
14508: LD_OWVAR 67
14512: ARRAY
14513: PLUS
14514: ST_TO_ADDR
// end ;
14515: PPOPN 2
14517: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
14518: LD_VAR 0 1
14522: PUSH
14523: LD_EXP 46
14527: IN
14528: IFFALSE 14546
// ru_patrol := ru_patrol diff un ;
14530: LD_ADDR_EXP 46
14534: PUSH
14535: LD_EXP 46
14539: PUSH
14540: LD_VAR 0 1
14544: DIFF
14545: ST_TO_ADDR
// if un in ru_forest then
14546: LD_VAR 0 1
14550: PUSH
14551: LD_EXP 48
14555: IN
14556: IFFALSE 14574
// ru_forest := ru_forest diff un ;
14558: LD_ADDR_EXP 48
14562: PUSH
14563: LD_EXP 48
14567: PUSH
14568: LD_VAR 0 1
14572: DIFF
14573: ST_TO_ADDR
// if un in ru_vehicles then
14574: LD_VAR 0 1
14578: PUSH
14579: LD_EXP 49
14583: IN
14584: IFFALSE 14602
// ru_vehicles := ru_vehicles diff un ;
14586: LD_ADDR_EXP 49
14590: PUSH
14591: LD_EXP 49
14595: PUSH
14596: LD_VAR 0 1
14600: DIFF
14601: ST_TO_ADDR
// if un = JMM then
14602: LD_VAR 0 1
14606: PUSH
14607: LD_EXP 30
14611: EQUAL
14612: IFFALSE 14621
// YouLost ( 0 ) ;
14614: LD_STRING 0
14616: PPUSH
14617: CALL_OW 104
// if un = us_dep_west then
14621: LD_VAR 0 1
14625: PUSH
14626: LD_INT 1
14628: EQUAL
14629: IFFALSE 14638
// YouLost ( 2 ) ;
14631: LD_STRING 2
14633: PPUSH
14634: CALL_OW 104
// if un = Lynch and GetSide ( Lynch ) = 8 then
14638: LD_VAR 0 1
14642: PUSH
14643: LD_EXP 40
14647: EQUAL
14648: PUSH
14649: LD_EXP 40
14653: PPUSH
14654: CALL_OW 255
14658: PUSH
14659: LD_INT 8
14661: EQUAL
14662: AND
14663: IFFALSE 14672
// YouLost ( 4 ) ;
14665: LD_STRING 4
14667: PPUSH
14668: CALL_OW 104
// if un in jmm_units then
14672: LD_VAR 0 1
14676: PUSH
14677: LD_EXP 2
14681: IN
14682: IFFALSE 14698
// lose_counter := lose_counter + 1 ;
14684: LD_ADDR_EXP 29
14688: PUSH
14689: LD_EXP 29
14693: PUSH
14694: LD_INT 1
14696: PLUS
14697: ST_TO_ADDR
// end ;
14698: PPOPN 1
14700: END
// every 0 0$01 trigger not game_end and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) < 4 do
14701: LD_EXP 28
14705: NOT
14706: PUSH
14707: LD_INT 22
14709: PUSH
14710: LD_INT 1
14712: PUSH
14713: EMPTY
14714: LIST
14715: LIST
14716: PUSH
14717: LD_INT 21
14719: PUSH
14720: LD_INT 1
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: PUSH
14727: EMPTY
14728: LIST
14729: LIST
14730: PPUSH
14731: CALL_OW 69
14735: PUSH
14736: LD_INT 22
14738: PUSH
14739: LD_INT 8
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PUSH
14746: LD_INT 21
14748: PUSH
14749: LD_INT 1
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PUSH
14756: EMPTY
14757: LIST
14758: LIST
14759: PPUSH
14760: CALL_OW 69
14764: PLUS
14765: PUSH
14766: LD_INT 4
14768: LESS
14769: AND
14770: IFFALSE 14782
14772: GO 14774
14774: DISABLE
// YouLost ( 1 ) ;
14775: LD_STRING 1
14777: PPUSH
14778: CALL_OW 104
14782: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
14783: LD_INT 1
14785: PPUSH
14786: CALL_OW 255
14790: PUSH
14791: LD_INT 3
14793: EQUAL
14794: IFFALSE 14806
14796: GO 14798
14798: DISABLE
// YouLost ( 3 ) ;
14799: LD_STRING 3
14801: PPUSH
14802: CALL_OW 104
14806: END
