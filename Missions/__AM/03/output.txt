// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 39 0 0
// SetDiplomacy ;
   8: CALL 271 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 359 0 0
// PrepareRussian ;
  22: CALL 2811 0 0
// PrepareAmerican ;
  26: CALL 1068 0 0
// PrepareCornell ;
  30: CALL 2092 0 0
// PrepareWesternBase ;
  34: CALL 2318 0 0
// end ;
  38: END
// export debug ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , veh_on_meta , time_to_prepare ; function Init ; begin
  39: LD_INT 0
  41: PPUSH
// debug := true ;
  42: LD_ADDR_EXP 1
  46: PUSH
  47: LD_INT 1
  49: ST_TO_ADDR
// jmm_units := 0 ;
  50: LD_ADDR_EXP 2
  54: PUSH
  55: LD_INT 0
  57: ST_TO_ADDR
// cornel_units := 0 ;
  58: LD_ADDR_EXP 4
  62: PUSH
  63: LD_INT 0
  65: ST_TO_ADDR
// bierezov_exist := false ;
  66: LD_ADDR_EXP 5
  70: PUSH
  71: LD_INT 0
  73: ST_TO_ADDR
// jmm_on_west := false ;
  74: LD_ADDR_EXP 3
  78: PUSH
  79: LD_INT 0
  81: ST_TO_ADDR
// cornel_active := false ;
  82: LD_ADDR_EXP 6
  86: PUSH
  87: LD_INT 0
  89: ST_TO_ADDR
// cornel_attack := false ;
  90: LD_ADDR_EXP 7
  94: PUSH
  95: LD_INT 0
  97: ST_TO_ADDR
// cornel_prepared := false ;
  98: LD_ADDR_EXP 9
 102: PUSH
 103: LD_INT 0
 105: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 106: LD_ADDR_EXP 8
 110: PUSH
 111: LD_INT 4200
 113: ST_TO_ADDR
// frank_can_return := false ;
 114: LD_ADDR_EXP 10
 118: PUSH
 119: LD_INT 0
 121: ST_TO_ADDR
// solar_builded := false ;
 122: LD_ADDR_EXP 11
 126: PUSH
 127: LD_INT 0
 129: ST_TO_ADDR
// frank_send_to_scout := false ;
 130: LD_ADDR_EXP 12
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// jmm_in_veh := false ;
 138: LD_ADDR_EXP 13
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// bobby_in_veh := false ;
 146: LD_ADDR_EXP 14
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// cyrus_in_veh := false ;
 154: LD_ADDR_EXP 15
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// lisa_in_veh := false ;
 162: LD_ADDR_EXP 16
 166: PUSH
 167: LD_INT 0
 169: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 170: LD_ADDR_EXP 24
 174: PUSH
 175: LD_INT 25200
 177: PUSH
 178: LD_INT 23100
 180: PUSH
 181: LD_INT 21000
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: LIST
 188: PUSH
 189: LD_OWVAR 67
 193: ARRAY
 194: ST_TO_ADDR
// crates_counter := [ 1200 , 1000 , 800 ] [ Difficulty ] ;
 195: LD_ADDR_EXP 17
 199: PUSH
 200: LD_INT 1200
 202: PUSH
 203: LD_INT 1000
 205: PUSH
 206: LD_INT 800
 208: PUSH
 209: EMPTY
 210: LIST
 211: LIST
 212: LIST
 213: PUSH
 214: LD_OWVAR 67
 218: ARRAY
 219: ST_TO_ADDR
// end_mission_allowed := false ;
 220: LD_ADDR_EXP 18
 224: PUSH
 225: LD_INT 0
 227: ST_TO_ADDR
// save_others := [ ] ;
 228: LD_ADDR_EXP 19
 232: PUSH
 233: EMPTY
 234: ST_TO_ADDR
// save_group := [ ] ;
 235: LD_ADDR_EXP 20
 239: PUSH
 240: EMPTY
 241: ST_TO_ADDR
// show_query := true ;
 242: LD_ADDR_EXP 21
 246: PUSH
 247: LD_INT 1
 249: ST_TO_ADDR
// wait_for_them := false ;
 250: LD_ADDR_EXP 22
 254: PUSH
 255: LD_INT 0
 257: ST_TO_ADDR
// veh_on_meta := false ;
 258: LD_ADDR_EXP 23
 262: PUSH
 263: LD_INT 0
 265: ST_TO_ADDR
// end ;
 266: LD_VAR 0 1
 270: RET
// function SetDiplomacy ; begin
 271: LD_INT 0
 273: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 274: LD_INT 1
 276: PPUSH
 277: LD_INT 4
 279: PPUSH
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 1
 285: PPUSH
 286: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 290: LD_INT 1
 292: PPUSH
 293: LD_INT 8
 295: PPUSH
 296: LD_INT 1
 298: PPUSH
 299: LD_INT 1
 301: PPUSH
 302: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 306: LD_INT 3
 308: PPUSH
 309: LD_INT 6
 311: PPUSH
 312: LD_INT 1
 314: PPUSH
 315: LD_INT 1
 317: PPUSH
 318: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 322: LD_INT 4
 324: PPUSH
 325: LD_INT 6
 327: PPUSH
 328: LD_INT 0
 330: PPUSH
 331: LD_INT 1
 333: PPUSH
 334: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 338: LD_INT 3
 340: PPUSH
 341: LD_INT 8
 343: PPUSH
 344: LD_INT 0
 346: PPUSH
 347: LD_INT 1
 349: PPUSH
 350: CALL_OW 80
// end ;
 354: LD_VAR 0 1
 358: RET
// export function DebugMode ; begin
 359: LD_INT 0
 361: PPUSH
// FogOff ( 1 ) ;
 362: LD_INT 1
 364: PPUSH
 365: CALL_OW 344
// debug_strings := [ ] ;
 369: LD_ADDR_OWVAR 48
 373: PUSH
 374: EMPTY
 375: ST_TO_ADDR
// end ; end_of_file
 376: LD_VAR 0 1
 380: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 381: LD_INT 0
 383: PPUSH
 384: PPUSH
// if exist_mode then
 385: LD_VAR 0 2
 389: IFFALSE 408
// unit := CreateCharacter ( ident ) else
 391: LD_ADDR_VAR 0 4
 395: PUSH
 396: LD_VAR 0 1
 400: PPUSH
 401: CALL_OW 34
 405: ST_TO_ADDR
 406: GO 423
// unit := NewCharacter ( ident ) ;
 408: LD_ADDR_VAR 0 4
 412: PUSH
 413: LD_VAR 0 1
 417: PPUSH
 418: CALL_OW 25
 422: ST_TO_ADDR
// result := unit ;
 423: LD_ADDR_VAR 0 3
 427: PUSH
 428: LD_VAR 0 4
 432: ST_TO_ADDR
// end ;
 433: LD_VAR 0 3
 437: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 438: LD_INT 0
 440: PPUSH
// uc_side := side ;
 441: LD_ADDR_OWVAR 20
 445: PUSH
 446: LD_VAR 0 1
 450: ST_TO_ADDR
// uc_nation := nation ;
 451: LD_ADDR_OWVAR 21
 455: PUSH
 456: LD_VAR 0 2
 460: ST_TO_ADDR
// vc_chassis := chassis ;
 461: LD_ADDR_OWVAR 37
 465: PUSH
 466: LD_VAR 0 3
 470: ST_TO_ADDR
// vc_engine := engine ;
 471: LD_ADDR_OWVAR 39
 475: PUSH
 476: LD_VAR 0 4
 480: ST_TO_ADDR
// vc_control := control ;
 481: LD_ADDR_OWVAR 38
 485: PUSH
 486: LD_VAR 0 5
 490: ST_TO_ADDR
// vc_weapon := weapon ;
 491: LD_ADDR_OWVAR 40
 495: PUSH
 496: LD_VAR 0 6
 500: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 501: LD_ADDR_OWVAR 41
 505: PUSH
 506: LD_VAR 0 7
 510: ST_TO_ADDR
// result := CreateVehicle ;
 511: LD_ADDR_VAR 0 8
 515: PUSH
 516: CALL_OW 45
 520: ST_TO_ADDR
// end ;
 521: LD_VAR 0 8
 525: RET
// export function SayX ( units , ident ) ; var i ; begin
 526: LD_INT 0
 528: PPUSH
 529: PPUSH
// if not units then
 530: LD_VAR 0 1
 534: NOT
 535: IFFALSE 539
// exit ;
 537: GO 583
// for i in ident do
 539: LD_ADDR_VAR 0 4
 543: PUSH
 544: LD_VAR 0 2
 548: PUSH
 549: FOR_IN
 550: IFFALSE 581
// if IsOk ( i ) then
 552: LD_VAR 0 4
 556: PPUSH
 557: CALL_OW 302
 561: IFFALSE 579
// begin Say ( i , ident ) ;
 563: LD_VAR 0 4
 567: PPUSH
 568: LD_VAR 0 2
 572: PPUSH
 573: CALL_OW 88
// break ;
 577: GO 581
// end ;
 579: GO 549
 581: POP
 582: POP
// end ;
 583: LD_VAR 0 3
 587: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 588: LD_INT 0
 590: PPUSH
 591: PPUSH
 592: PPUSH
 593: PPUSH
// for i = 1 to count do
 594: LD_ADDR_VAR 0 8
 598: PUSH
 599: DOUBLE
 600: LD_INT 1
 602: DEC
 603: ST_TO_ADDR
 604: LD_VAR 0 6
 608: PUSH
 609: FOR_TO
 610: IFFALSE 691
// begin uc_side = side ;
 612: LD_ADDR_OWVAR 20
 616: PUSH
 617: LD_VAR 0 1
 621: ST_TO_ADDR
// uc_nation = nation ;
 622: LD_ADDR_OWVAR 21
 626: PUSH
 627: LD_VAR 0 2
 631: ST_TO_ADDR
// hc_gallery =  ;
 632: LD_ADDR_OWVAR 33
 636: PUSH
 637: LD_STRING 
 639: ST_TO_ADDR
// hc_name =  ;
 640: LD_ADDR_OWVAR 26
 644: PUSH
 645: LD_STRING 
 647: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 648: LD_INT 0
 650: PPUSH
 651: LD_VAR 0 5
 655: PPUSH
 656: LD_VAR 0 4
 660: PPUSH
 661: CALL_OW 380
// un = CreateHuman ;
 665: LD_ADDR_VAR 0 10
 669: PUSH
 670: CALL_OW 44
 674: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 675: LD_VAR 0 10
 679: PPUSH
 680: LD_VAR 0 3
 684: PPUSH
 685: CALL_OW 52
// end ;
 689: GO 609
 691: POP
 692: POP
// end ;
 693: LD_VAR 0 7
 697: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 698: LD_INT 0
 700: PPUSH
 701: PPUSH
 702: PPUSH
// uc_side := GetSide ( b ) ;
 703: LD_ADDR_OWVAR 20
 707: PUSH
 708: LD_VAR 0 2
 712: PPUSH
 713: CALL_OW 255
 717: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 718: LD_ADDR_OWVAR 21
 722: PUSH
 723: LD_VAR 0 2
 727: PPUSH
 728: CALL_OW 248
 732: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 733: LD_INT 0
 735: PPUSH
 736: LD_INT 1
 738: PPUSH
 739: LD_VAR 0 1
 743: PPUSH
 744: CALL_OW 380
// un = CreateHuman ;
 748: LD_ADDR_VAR 0 4
 752: PUSH
 753: CALL_OW 44
 757: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 758: LD_ADDR_VAR 0 5
 762: PUSH
 763: LD_VAR 0 2
 767: PPUSH
 768: CALL_OW 254
 772: PUSH
 773: LD_INT 3
 775: MINUS
 776: ST_TO_ADDR
// if dir < 0 then
 777: LD_VAR 0 5
 781: PUSH
 782: LD_INT 0
 784: LESS
 785: IFFALSE 801
// dir := 6 + dir ;
 787: LD_ADDR_VAR 0 5
 791: PUSH
 792: LD_INT 6
 794: PUSH
 795: LD_VAR 0 5
 799: PLUS
 800: ST_TO_ADDR
// SetDir ( un , dir ) ;
 801: LD_VAR 0 4
 805: PPUSH
 806: LD_VAR 0 5
 810: PPUSH
 811: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 815: LD_VAR 0 4
 819: PPUSH
 820: LD_VAR 0 2
 824: PPUSH
 825: CALL_OW 52
// end ;
 829: LD_VAR 0 3
 833: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 834: LD_INT 0
 836: PPUSH
 837: PPUSH
 838: PPUSH
// result := false ;
 839: LD_ADDR_VAR 0 2
 843: PUSH
 844: LD_INT 0
 846: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 847: LD_ADDR_VAR 0 3
 851: PUSH
 852: LD_INT 22
 854: PUSH
 855: LD_INT 1
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 34
 864: PUSH
 865: LD_INT 2
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: PPUSH
 876: CALL_OW 69
 880: ST_TO_ADDR
// for i in filter do
 881: LD_ADDR_VAR 0 4
 885: PUSH
 886: LD_VAR 0 3
 890: PUSH
 891: FOR_IN
 892: IFFALSE 923
// if IsDrivenBy ( i ) = unit then
 894: LD_VAR 0 4
 898: PPUSH
 899: CALL_OW 311
 903: PUSH
 904: LD_VAR 0 1
 908: EQUAL
 909: IFFALSE 921
// begin result := true ;
 911: LD_ADDR_VAR 0 2
 915: PUSH
 916: LD_INT 1
 918: ST_TO_ADDR
// break ;
 919: GO 923
// end ;
 921: GO 891
 923: POP
 924: POP
// end ;
 925: LD_VAR 0 2
 929: RET
// export function FindFreePlace ( blist ) ; var i ; begin
 930: LD_INT 0
 932: PPUSH
 933: PPUSH
// result := false ;
 934: LD_ADDR_VAR 0 2
 938: PUSH
 939: LD_INT 0
 941: ST_TO_ADDR
// if not blist then
 942: LD_VAR 0 1
 946: NOT
 947: IFFALSE 951
// exit ;
 949: GO 995
// for i in blist do
 951: LD_ADDR_VAR 0 3
 955: PUSH
 956: LD_VAR 0 1
 960: PUSH
 961: FOR_IN
 962: IFFALSE 993
// if UnitsInside ( i ) < 6 then
 964: LD_VAR 0 3
 968: PPUSH
 969: CALL_OW 313
 973: PUSH
 974: LD_INT 6
 976: LESS
 977: IFFALSE 991
// begin result := i ;
 979: LD_ADDR_VAR 0 2
 983: PUSH
 984: LD_VAR 0 3
 988: ST_TO_ADDR
// break ;
 989: GO 993
// end ;
 991: GO 961
 993: POP
 994: POP
// end ;
 995: LD_VAR 0 2
 999: RET
// export function Count ( timer , mode ) ; begin
1000: LD_INT 0
1002: PPUSH
// if not timer then
1003: LD_VAR 0 1
1007: NOT
1008: IFFALSE 1012
// exit ;
1010: GO 1063
// if mode in [ asc , up , + ] then
1012: LD_VAR 0 2
1016: PUSH
1017: LD_STRING asc
1019: PUSH
1020: LD_STRING up
1022: PUSH
1023: LD_STRING +
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: LIST
1030: IN
1031: IFFALSE 1049
// result := timer + 0 0$01 else
1033: LD_ADDR_VAR 0 3
1037: PUSH
1038: LD_VAR 0 1
1042: PUSH
1043: LD_INT 35
1045: PLUS
1046: ST_TO_ADDR
1047: GO 1063
// result := timer - 0 0$01 ;
1049: LD_ADDR_VAR 0 3
1053: PUSH
1054: LD_VAR 0 1
1058: PUSH
1059: LD_INT 35
1061: MINUS
1062: ST_TO_ADDR
// end ; end_of_file
1063: LD_VAR 0 3
1067: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1068: LD_INT 0
1070: PPUSH
1071: PPUSH
1072: PPUSH
1073: PPUSH
1074: PPUSH
1075: PPUSH
1076: PPUSH
1077: PPUSH
// uc_side := 4 ;
1078: LD_ADDR_OWVAR 20
1082: PUSH
1083: LD_INT 4
1085: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1086: LD_ADDR_EXP 34
1090: PUSH
1091: LD_STRING Powell
1093: PPUSH
1094: LD_INT 0
1096: PPUSH
1097: CALL 381 0 2
1101: ST_TO_ADDR
// uc_side := 1 ;
1102: LD_ADDR_OWVAR 20
1106: PUSH
1107: LD_INT 1
1109: ST_TO_ADDR
// uc_nation := 1 ;
1110: LD_ADDR_OWVAR 21
1114: PUSH
1115: LD_INT 1
1117: ST_TO_ADDR
// if debug then
1118: LD_EXP 1
1122: IFFALSE 1252
// begin for i = 1 to 4 do
1124: LD_ADDR_VAR 0 2
1128: PUSH
1129: DOUBLE
1130: LD_INT 1
1132: DEC
1133: ST_TO_ADDR
1134: LD_INT 4
1136: PUSH
1137: FOR_TO
1138: IFFALSE 1189
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1140: LD_INT 0
1142: PPUSH
1143: LD_INT 1
1145: PPUSH
1146: LD_INT 2
1148: PPUSH
1149: CALL_OW 12
1153: PPUSH
1154: LD_INT 3
1156: PPUSH
1157: CALL_OW 380
// un := CreateHuman ;
1161: LD_ADDR_VAR 0 3
1165: PUSH
1166: CALL_OW 44
1170: ST_TO_ADDR
// others := others ^ un ;
1171: LD_ADDR_VAR 0 5
1175: PUSH
1176: LD_VAR 0 5
1180: PUSH
1181: LD_VAR 0 3
1185: ADD
1186: ST_TO_ADDR
// end ;
1187: GO 1137
1189: POP
1190: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1191: LD_ADDR_VAR 0 6
1195: PUSH
1196: LD_INT 21
1198: PUSH
1199: LD_INT 1
1201: PUSH
1202: LD_INT 1
1204: PUSH
1205: LD_INT 51
1207: PUSH
1208: LD_INT 90
1210: PUSH
1211: LD_INT 504
1213: PUSH
1214: EMPTY
1215: LIST
1216: LIST
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 21
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 1
1230: PUSH
1231: LD_INT 51
1233: PUSH
1234: LD_INT 80
1236: PUSH
1237: LD_INT 750
1239: PUSH
1240: EMPTY
1241: LIST
1242: LIST
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: PUSH
1248: EMPTY
1249: LIST
1250: LIST
1251: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1252: LD_ADDR_EXP 25
1256: PUSH
1257: LD_STRING JMM
1259: PPUSH
1260: LD_EXP 1
1264: NOT
1265: PPUSH
1266: CALL 381 0 2
1270: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1271: LD_ADDR_EXP 26
1275: PUSH
1276: LD_STRING Bobby
1278: PPUSH
1279: LD_EXP 1
1283: NOT
1284: PPUSH
1285: CALL 381 0 2
1289: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1290: LD_ADDR_EXP 27
1294: PUSH
1295: LD_STRING Cyrus
1297: PPUSH
1298: LD_EXP 1
1302: NOT
1303: PPUSH
1304: CALL 381 0 2
1308: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1309: LD_ADDR_EXP 28
1313: PUSH
1314: LD_STRING Lisa
1316: PPUSH
1317: LD_EXP 1
1321: NOT
1322: PPUSH
1323: CALL 381 0 2
1327: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1328: LD_ADDR_EXP 29
1332: PUSH
1333: LD_STRING Khatam
1335: PPUSH
1336: LD_EXP 1
1340: NOT
1341: PPUSH
1342: CALL 381 0 2
1346: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1347: LD_ADDR_EXP 30
1351: PUSH
1352: LD_STRING Brian
1354: PPUSH
1355: LD_EXP 1
1359: NOT
1360: PPUSH
1361: CALL 381 0 2
1365: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1366: LD_ADDR_EXP 31
1370: PUSH
1371: LD_STRING Jerry
1373: PPUSH
1374: LD_EXP 1
1378: NOT
1379: PPUSH
1380: CALL 381 0 2
1384: ST_TO_ADDR
// if Bobby then
1385: LD_EXP 26
1389: IFFALSE 1420
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1391: LD_ADDR_VAR 0 4
1395: PUSH
1396: LD_VAR 0 4
1400: PPUSH
1401: LD_VAR 0 4
1405: PUSH
1406: LD_INT 1
1408: PLUS
1409: PPUSH
1410: LD_EXP 26
1414: PPUSH
1415: CALL_OW 2
1419: ST_TO_ADDR
// if Cyrus then
1420: LD_EXP 27
1424: IFFALSE 1455
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1426: LD_ADDR_VAR 0 4
1430: PUSH
1431: LD_VAR 0 4
1435: PPUSH
1436: LD_VAR 0 4
1440: PUSH
1441: LD_INT 1
1443: PLUS
1444: PPUSH
1445: LD_EXP 27
1449: PPUSH
1450: CALL_OW 2
1454: ST_TO_ADDR
// if Lisa then
1455: LD_EXP 28
1459: IFFALSE 1490
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1461: LD_ADDR_VAR 0 4
1465: PUSH
1466: LD_VAR 0 4
1470: PPUSH
1471: LD_VAR 0 4
1475: PUSH
1476: LD_INT 1
1478: PLUS
1479: PPUSH
1480: LD_EXP 28
1484: PPUSH
1485: CALL_OW 2
1489: ST_TO_ADDR
// if Khatam then
1490: LD_EXP 29
1494: IFFALSE 1525
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1496: LD_ADDR_VAR 0 4
1500: PUSH
1501: LD_VAR 0 4
1505: PPUSH
1506: LD_VAR 0 4
1510: PUSH
1511: LD_INT 1
1513: PLUS
1514: PPUSH
1515: LD_EXP 29
1519: PPUSH
1520: CALL_OW 2
1524: ST_TO_ADDR
// if Brian then
1525: LD_EXP 30
1529: IFFALSE 1560
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1531: LD_ADDR_VAR 0 4
1535: PUSH
1536: LD_VAR 0 4
1540: PPUSH
1541: LD_VAR 0 4
1545: PUSH
1546: LD_INT 1
1548: PLUS
1549: PPUSH
1550: LD_EXP 30
1554: PPUSH
1555: CALL_OW 2
1559: ST_TO_ADDR
// if Jerry then
1560: LD_EXP 31
1564: IFFALSE 1595
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1566: LD_ADDR_VAR 0 4
1570: PUSH
1571: LD_VAR 0 4
1575: PPUSH
1576: LD_VAR 0 4
1580: PUSH
1581: LD_INT 1
1583: PLUS
1584: PPUSH
1585: LD_EXP 31
1589: PPUSH
1590: CALL_OW 2
1594: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1595: LD_STRING 02_other_survivors
1597: PPUSH
1598: CALL_OW 28
1602: IFFALSE 1617
// others := CreateCharacterSet ( 02_other_survivors ) ;
1604: LD_ADDR_VAR 0 5
1608: PUSH
1609: LD_STRING 02_other_survivors
1611: PPUSH
1612: CALL_OW 31
1616: ST_TO_ADDR
// if others then
1617: LD_VAR 0 5
1621: IFFALSE 1646
// begin tmp := tmp ^ others ;
1623: LD_ADDR_VAR 0 4
1627: PUSH
1628: LD_VAR 0 4
1632: PUSH
1633: LD_VAR 0 5
1637: ADD
1638: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1639: LD_STRING 02_other_survivors
1641: PPUSH
1642: CALL_OW 40
// end ; jmm_units := tmp ;
1646: LD_ADDR_EXP 2
1650: PUSH
1651: LD_VAR 0 4
1655: ST_TO_ADDR
// if not vehicles then
1656: LD_VAR 0 6
1660: NOT
1661: IFFALSE 1679
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1663: LD_ADDR_VAR 0 6
1667: PUSH
1668: LD_STRING 02_tanks_1
1670: PPUSH
1671: LD_INT 0
1673: PPUSH
1674: CALL_OW 30
1678: ST_TO_ADDR
// if vehicles then
1679: LD_VAR 0 6
1683: IFFALSE 1877
// begin got_mech := false ;
1685: LD_ADDR_VAR 0 7
1689: PUSH
1690: LD_INT 0
1692: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1693: LD_VAR 0 4
1697: PPUSH
1698: LD_INT 25
1700: PUSH
1701: LD_INT 3
1703: PUSH
1704: EMPTY
1705: LIST
1706: LIST
1707: PPUSH
1708: CALL_OW 72
1712: IFFALSE 1722
// got_mech := true ;
1714: LD_ADDR_VAR 0 7
1718: PUSH
1719: LD_INT 1
1721: ST_TO_ADDR
// for i = 1 to vehicles do
1722: LD_ADDR_VAR 0 2
1726: PUSH
1727: DOUBLE
1728: LD_INT 1
1730: DEC
1731: ST_TO_ADDR
1732: LD_VAR 0 6
1736: PUSH
1737: FOR_TO
1738: IFFALSE 1875
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1740: LD_ADDR_VAR 0 3
1744: PUSH
1745: LD_INT 1
1747: PPUSH
1748: LD_INT 3
1750: PPUSH
1751: LD_VAR 0 6
1755: PUSH
1756: LD_VAR 0 2
1760: ARRAY
1761: PUSH
1762: LD_INT 1
1764: ARRAY
1765: PPUSH
1766: LD_VAR 0 6
1770: PUSH
1771: LD_VAR 0 2
1775: ARRAY
1776: PUSH
1777: LD_INT 2
1779: ARRAY
1780: PPUSH
1781: LD_VAR 0 6
1785: PUSH
1786: LD_VAR 0 2
1790: ARRAY
1791: PUSH
1792: LD_INT 3
1794: ARRAY
1795: PPUSH
1796: LD_VAR 0 6
1800: PUSH
1801: LD_VAR 0 2
1805: ARRAY
1806: PUSH
1807: LD_INT 4
1809: ARRAY
1810: PPUSH
1811: LD_INT 40
1813: PPUSH
1814: CALL 438 0 7
1818: ST_TO_ADDR
// if not got_mech then
1819: LD_VAR 0 7
1823: NOT
1824: IFFALSE 1850
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1826: LD_VAR 0 3
1830: PPUSH
1831: LD_VAR 0 6
1835: PUSH
1836: LD_VAR 0 2
1840: ARRAY
1841: PUSH
1842: LD_INT 6
1844: ARRAY
1845: PPUSH
1846: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1850: LD_ADDR_VAR 0 4
1854: PUSH
1855: LD_VAR 0 4
1859: PPUSH
1860: LD_INT 1
1862: PPUSH
1863: LD_VAR 0 3
1867: PPUSH
1868: CALL_OW 2
1872: ST_TO_ADDR
// end ;
1873: GO 1737
1875: POP
1876: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1877: LD_EXP 25
1881: PPUSH
1882: LD_INT 194
1884: PPUSH
1885: LD_INT 119
1887: PPUSH
1888: LD_INT 0
1890: PPUSH
1891: CALL_OW 48
// if tmp then
1895: LD_VAR 0 4
1899: IFFALSE 2024
// begin for i in tmp do
1901: LD_ADDR_VAR 0 2
1905: PUSH
1906: LD_VAR 0 4
1910: PUSH
1911: FOR_IN
1912: IFFALSE 2022
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1914: LD_ADDR_VAR 0 8
1918: PUSH
1919: LD_INT 22
1921: PUSH
1922: LD_INT 1
1924: PUSH
1925: EMPTY
1926: LIST
1927: LIST
1928: PUSH
1929: LD_INT 21
1931: PUSH
1932: LD_INT 2
1934: PUSH
1935: EMPTY
1936: LIST
1937: LIST
1938: PUSH
1939: LD_INT 58
1941: PUSH
1942: EMPTY
1943: LIST
1944: PUSH
1945: EMPTY
1946: LIST
1947: LIST
1948: LIST
1949: PPUSH
1950: CALL_OW 69
1954: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
1955: LD_VAR 0 2
1959: PPUSH
1960: CALL_OW 247
1964: PUSH
1965: LD_INT 1
1967: EQUAL
1968: PUSH
1969: LD_VAR 0 8
1973: AND
1974: IFFALSE 1996
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
1976: LD_VAR 0 2
1980: PPUSH
1981: LD_VAR 0 8
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: PPUSH
1990: CALL_OW 52
1994: GO 2011
// PlaceUnitArea ( i , startArea , false ) ;
1996: LD_VAR 0 2
2000: PPUSH
2001: LD_INT 1
2003: PPUSH
2004: LD_INT 0
2006: PPUSH
2007: CALL_OW 49
// ComHold ( i ) ;
2011: LD_VAR 0 2
2015: PPUSH
2016: CALL_OW 140
// end ;
2020: GO 1911
2022: POP
2023: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2024: LD_ADDR_EXP 5
2028: PUSH
2029: LD_STRING 02_mikhailStatus_1
2031: PPUSH
2032: LD_INT 0
2034: PPUSH
2035: CALL_OW 30
2039: ST_TO_ADDR
// if not bierezov_exist and not debug then
2040: LD_EXP 5
2044: NOT
2045: PUSH
2046: LD_EXP 1
2050: NOT
2051: AND
2052: IFFALSE 2056
// exit ;
2054: GO 2087
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2056: LD_ADDR_EXP 33
2060: PUSH
2061: LD_STRING Mikhail
2063: PPUSH
2064: LD_INT 0
2066: PPUSH
2067: CALL 381 0 2
2071: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2072: LD_EXP 33
2076: PPUSH
2077: LD_INT 1
2079: PPUSH
2080: LD_INT 0
2082: PPUSH
2083: CALL_OW 49
// end ;
2087: LD_VAR 0 1
2091: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2092: LD_INT 0
2094: PPUSH
2095: PPUSH
2096: PPUSH
2097: PPUSH
// uc_side := 4 ;
2098: LD_ADDR_OWVAR 20
2102: PUSH
2103: LD_INT 4
2105: ST_TO_ADDR
// uc_nation := 1 ;
2106: LD_ADDR_OWVAR 21
2110: PUSH
2111: LD_INT 1
2113: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2114: LD_ADDR_EXP 32
2118: PUSH
2119: LD_STRING Cornell
2121: PPUSH
2122: LD_INT 0
2124: PPUSH
2125: CALL 381 0 2
2129: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
2130: LD_ADDR_EXP 4
2134: PUSH
2135: LD_INT 8
2137: PUSH
2138: LD_EXP 2
2142: MINUS
2143: ST_TO_ADDR
// tmp := [ ] ;
2144: LD_ADDR_VAR 0 2
2148: PUSH
2149: EMPTY
2150: ST_TO_ADDR
// if cornel_units < 3 then
2151: LD_EXP 4
2155: PUSH
2156: LD_INT 3
2158: LESS
2159: IFFALSE 2169
// cornel_units := 3 ;
2161: LD_ADDR_EXP 4
2165: PUSH
2166: LD_INT 3
2168: ST_TO_ADDR
// for i = 1 to cornel_units do
2169: LD_ADDR_VAR 0 4
2173: PUSH
2174: DOUBLE
2175: LD_INT 1
2177: DEC
2178: ST_TO_ADDR
2179: LD_EXP 4
2183: PUSH
2184: FOR_TO
2185: IFFALSE 2283
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2187: LD_INT 0
2189: PPUSH
2190: LD_INT 1
2192: PUSH
2193: LD_INT 1
2195: PUSH
2196: LD_INT 1
2198: PUSH
2199: LD_INT 2
2201: PUSH
2202: LD_INT 4
2204: PUSH
2205: EMPTY
2206: LIST
2207: LIST
2208: LIST
2209: LIST
2210: LIST
2211: PUSH
2212: LD_VAR 0 4
2216: PUSH
2217: LD_INT 5
2219: MOD
2220: PUSH
2221: LD_INT 1
2223: PLUS
2224: ARRAY
2225: PPUSH
2226: LD_INT 2
2228: PPUSH
2229: CALL_OW 380
// un := CreateHuman ;
2233: LD_ADDR_VAR 0 3
2237: PUSH
2238: CALL_OW 44
2242: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2243: LD_ADDR_VAR 0 2
2247: PUSH
2248: LD_VAR 0 2
2252: PPUSH
2253: LD_INT 1
2255: PPUSH
2256: LD_VAR 0 3
2260: PPUSH
2261: CALL_OW 2
2265: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2266: LD_VAR 0 3
2270: PPUSH
2271: LD_INT 2
2273: PPUSH
2274: LD_INT 0
2276: PPUSH
2277: CALL_OW 49
// end ;
2281: GO 2184
2283: POP
2284: POP
// cornel_units := tmp ;
2285: LD_ADDR_EXP 4
2289: PUSH
2290: LD_VAR 0 2
2294: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2295: LD_EXP 32
2299: PPUSH
2300: LD_INT 191
2302: PPUSH
2303: LD_INT 106
2305: PPUSH
2306: LD_INT 0
2308: PPUSH
2309: CALL_OW 48
// end ;
2313: LD_VAR 0 1
2317: RET
// export function PrepareWesternBase ; var i ; begin
2318: LD_INT 0
2320: PPUSH
2321: PPUSH
// uc_side := 8 ;
2322: LD_ADDR_OWVAR 20
2326: PUSH
2327: LD_INT 8
2329: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2330: LD_ADDR_EXP 35
2334: PUSH
2335: LD_STRING Lynch
2337: PPUSH
2338: LD_INT 0
2340: PPUSH
2341: CALL 381 0 2
2345: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2346: LD_ADDR_EXP 36
2350: PUSH
2351: LD_STRING Walker
2353: PPUSH
2354: LD_INT 0
2356: PPUSH
2357: CALL 381 0 2
2361: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2362: LD_ADDR_EXP 37
2366: PUSH
2367: LD_STRING Turner
2369: PPUSH
2370: LD_INT 0
2372: PPUSH
2373: CALL 381 0 2
2377: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2378: LD_ADDR_EXP 38
2382: PUSH
2383: LD_STRING Jillian
2385: PPUSH
2386: LD_INT 0
2388: PPUSH
2389: CALL 381 0 2
2393: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2394: LD_ADDR_VAR 0 2
2398: PUSH
2399: LD_EXP 35
2403: PUSH
2404: LD_EXP 36
2408: PUSH
2409: LD_EXP 37
2413: PUSH
2414: LD_EXP 38
2418: PUSH
2419: EMPTY
2420: LIST
2421: LIST
2422: LIST
2423: LIST
2424: PUSH
2425: FOR_IN
2426: IFFALSE 2454
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2428: LD_VAR 0 2
2432: PPUSH
2433: LD_INT 3
2435: PPUSH
2436: LD_INT 0
2438: PPUSH
2439: CALL_OW 49
// ComHold ( i ) ;
2443: LD_VAR 0 2
2447: PPUSH
2448: CALL_OW 140
// end ;
2452: GO 2425
2454: POP
2455: POP
// end ;
2456: LD_VAR 0 1
2460: RET
// export function SelectGroup ; var units , selected , i ; begin
2461: LD_INT 0
2463: PPUSH
2464: PPUSH
2465: PPUSH
2466: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2467: LD_ADDR_VAR 0 2
2471: PUSH
2472: LD_EXP 25
2476: PUSH
2477: LD_INT -3
2479: PUSH
2480: EMPTY
2481: LIST
2482: LIST
2483: PUSH
2484: LD_EXP 2
2488: ADD
2489: PUSH
2490: LD_INT -2
2492: PUSH
2493: LD_INT -4
2495: PUSH
2496: LD_EXP 32
2500: PUSH
2501: LD_EXP 33
2505: PUSH
2506: EMPTY
2507: LIST
2508: LIST
2509: LIST
2510: LIST
2511: ADD
2512: PUSH
2513: LD_INT -3
2515: PUSH
2516: EMPTY
2517: LIST
2518: ADD
2519: PUSH
2520: LD_EXP 4
2524: ADD
2525: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2526: LD_ADDR_VAR 0 3
2530: PUSH
2531: LD_EXP 25
2535: PUSH
2536: LD_STRING Select five characters to go with you
2538: PPUSH
2539: LD_INT 4
2541: PPUSH
2542: LD_INT 4
2544: PPUSH
2545: LD_VAR 0 2
2549: PPUSH
2550: EMPTY
2551: PPUSH
2552: CALL_OW 42
2556: ADD
2557: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2558: LD_ADDR_EXP 4
2562: PUSH
2563: LD_EXP 2
2567: PUSH
2568: LD_EXP 4
2572: UNION
2573: PUSH
2574: LD_VAR 0 3
2578: DIFF
2579: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2580: LD_ADDR_VAR 0 4
2584: PUSH
2585: LD_EXP 4
2589: PUSH
2590: LD_EXP 33
2594: ADD
2595: PUSH
2596: FOR_IN
2597: IFFALSE 2628
// if GetSide ( i ) = 1 then
2599: LD_VAR 0 4
2603: PPUSH
2604: CALL_OW 255
2608: PUSH
2609: LD_INT 1
2611: EQUAL
2612: IFFALSE 2626
// SetSide ( i , 4 ) ;
2614: LD_VAR 0 4
2618: PPUSH
2619: LD_INT 4
2621: PPUSH
2622: CALL_OW 235
2626: GO 2596
2628: POP
2629: POP
// for i in selected do
2630: LD_ADDR_VAR 0 4
2634: PUSH
2635: LD_VAR 0 3
2639: PUSH
2640: FOR_IN
2641: IFFALSE 2672
// if GetSide ( i ) = 4 then
2643: LD_VAR 0 4
2647: PPUSH
2648: CALL_OW 255
2652: PUSH
2653: LD_INT 4
2655: EQUAL
2656: IFFALSE 2670
// SetSide ( i , 1 ) ;
2658: LD_VAR 0 4
2662: PPUSH
2663: LD_INT 1
2665: PPUSH
2666: CALL_OW 235
2670: GO 2640
2672: POP
2673: POP
// if GetSide ( Bobby ) = 4 then
2674: LD_EXP 26
2678: PPUSH
2679: CALL_OW 255
2683: PUSH
2684: LD_INT 4
2686: EQUAL
2687: IFFALSE 2696
// DeleteCharacters ( Bobby ) ;
2689: LD_STRING Bobby
2691: PPUSH
2692: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2696: LD_EXP 27
2700: PPUSH
2701: CALL_OW 255
2705: PUSH
2706: LD_INT 4
2708: EQUAL
2709: IFFALSE 2718
// DeleteCharacters ( Cyrus ) ;
2711: LD_STRING Cyrus
2713: PPUSH
2714: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2718: LD_EXP 28
2722: PPUSH
2723: CALL_OW 255
2727: PUSH
2728: LD_INT 4
2730: EQUAL
2731: IFFALSE 2740
// DeleteCharacters ( Lisa ) ;
2733: LD_STRING Lisa
2735: PPUSH
2736: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2740: LD_EXP 29
2744: PPUSH
2745: CALL_OW 255
2749: PUSH
2750: LD_INT 4
2752: EQUAL
2753: IFFALSE 2762
// DeleteCharacters ( Khatam ) ;
2755: LD_STRING Khatam
2757: PPUSH
2758: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2762: LD_EXP 30
2766: PPUSH
2767: CALL_OW 255
2771: PUSH
2772: LD_INT 4
2774: EQUAL
2775: IFFALSE 2784
// DeleteCharacters ( Brian ) ;
2777: LD_STRING Brian
2779: PPUSH
2780: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2784: LD_EXP 31
2788: PPUSH
2789: CALL_OW 255
2793: PUSH
2794: LD_INT 4
2796: EQUAL
2797: IFFALSE 2806
// DeleteCharacters ( Jerry ) ;
2799: LD_STRING Jerry
2801: PPUSH
2802: CALL_OW 40
// end ; end_of_file
2806: LD_VAR 0 1
2810: RET
// export Pokryshkin ; export ru_patrol , ru_forest , ru_vehicles ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , b , un , veh , tw , bar , skill , vehicles , spot_xy ; begin
2811: LD_INT 0
2813: PPUSH
2814: PPUSH
2815: PPUSH
2816: PPUSH
2817: PPUSH
2818: PPUSH
2819: PPUSH
2820: PPUSH
2821: PPUSH
2822: PPUSH
// ru_alert := false ;
2823: LD_ADDR_EXP 45
2827: PUSH
2828: LD_INT 0
2830: ST_TO_ADDR
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
2831: LD_ADDR_VAR 0 6
2835: PUSH
2836: LD_INT 22
2838: PUSH
2839: LD_INT 3
2841: PUSH
2842: EMPTY
2843: LIST
2844: LIST
2845: PUSH
2846: LD_INT 2
2848: PUSH
2849: LD_INT 30
2851: PUSH
2852: LD_INT 31
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: PUSH
2859: LD_INT 30
2861: PUSH
2862: LD_INT 32
2864: PUSH
2865: EMPTY
2866: LIST
2867: LIST
2868: PUSH
2869: EMPTY
2870: LIST
2871: LIST
2872: LIST
2873: PUSH
2874: EMPTY
2875: LIST
2876: LIST
2877: PPUSH
2878: CALL_OW 69
2882: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
2883: LD_ADDR_VAR 0 7
2887: PUSH
2888: LD_INT 22
2890: PUSH
2891: LD_INT 3
2893: PUSH
2894: EMPTY
2895: LIST
2896: LIST
2897: PUSH
2898: LD_INT 30
2900: PUSH
2901: LD_INT 4
2903: PUSH
2904: EMPTY
2905: LIST
2906: LIST
2907: PUSH
2908: EMPTY
2909: LIST
2910: LIST
2911: PPUSH
2912: CALL_OW 69
2916: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
2917: LD_ADDR_VAR 0 2
2921: PUSH
2922: LD_INT 22
2924: PUSH
2925: LD_INT 3
2927: PUSH
2928: EMPTY
2929: LIST
2930: LIST
2931: PUSH
2932: LD_INT 30
2934: PUSH
2935: LD_INT 1
2937: PUSH
2938: EMPTY
2939: LIST
2940: LIST
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: PPUSH
2946: CALL_OW 69
2950: PUSH
2951: FOR_IN
2952: IFFALSE 2996
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
2954: LD_VAR 0 2
2958: PPUSH
2959: CALL_OW 274
2963: PPUSH
2964: LD_INT 1
2966: PPUSH
2967: LD_INT 1000
2969: PPUSH
2970: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 300 ) ;
2974: LD_VAR 0 2
2978: PPUSH
2979: CALL_OW 274
2983: PPUSH
2984: LD_INT 2
2986: PPUSH
2987: LD_INT 300
2989: PPUSH
2990: CALL_OW 277
// end ;
2994: GO 2951
2996: POP
2997: POP
// uc_side := 3 ;
2998: LD_ADDR_OWVAR 20
3002: PUSH
3003: LD_INT 3
3005: ST_TO_ADDR
// uc_nation := 3 ;
3006: LD_ADDR_OWVAR 21
3010: PUSH
3011: LD_INT 3
3013: ST_TO_ADDR
// skill := [ 2 , 2 , 3 ] [ Difficulty ] ;
3014: LD_ADDR_VAR 0 8
3018: PUSH
3019: LD_INT 2
3021: PUSH
3022: LD_INT 2
3024: PUSH
3025: LD_INT 3
3027: PUSH
3028: EMPTY
3029: LIST
3030: LIST
3031: LIST
3032: PUSH
3033: LD_OWVAR 67
3037: ARRAY
3038: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3039: LD_ADDR_EXP 40
3043: PUSH
3044: LD_STRING Pokryshkin
3046: PPUSH
3047: LD_INT 0
3049: PPUSH
3050: CALL 381 0 2
3054: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3055: LD_EXP 40
3059: PPUSH
3060: LD_INT 63
3062: PPUSH
3063: LD_INT 21
3065: PPUSH
3066: LD_INT 0
3068: PPUSH
3069: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3073: LD_EXP 40
3077: PPUSH
3078: CALL_OW 140
// InitHc ;
3082: CALL_OW 19
// for i in tw do
3086: LD_ADDR_VAR 0 2
3090: PUSH
3091: LD_VAR 0 6
3095: PUSH
3096: FOR_IN
3097: IFFALSE 3146
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3099: LD_VAR 0 2
3103: PPUSH
3104: LD_INT 42
3106: PUSH
3107: LD_INT 43
3109: PUSH
3110: EMPTY
3111: LIST
3112: LIST
3113: PUSH
3114: LD_INT 1
3116: PPUSH
3117: LD_INT 2
3119: PPUSH
3120: CALL_OW 12
3124: ARRAY
3125: PPUSH
3126: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3130: LD_VAR 0 8
3134: PPUSH
3135: LD_VAR 0 2
3139: PPUSH
3140: CALL 698 0 2
// end ;
3144: GO 3096
3146: POP
3147: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3148: LD_ADDR_VAR 0 10
3152: PUSH
3153: LD_INT 100
3155: PUSH
3156: LD_INT 9
3158: PUSH
3159: EMPTY
3160: LIST
3161: LIST
3162: PUSH
3163: LD_INT 135
3165: PUSH
3166: LD_INT 60
3168: PUSH
3169: EMPTY
3170: LIST
3171: LIST
3172: PUSH
3173: LD_INT 41
3175: PUSH
3176: LD_INT 6
3178: PUSH
3179: EMPTY
3180: LIST
3181: LIST
3182: PUSH
3183: LD_INT 22
3185: PUSH
3186: LD_INT 9
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: PUSH
3193: LD_INT 84
3195: PUSH
3196: LD_INT 14
3198: PUSH
3199: EMPTY
3200: LIST
3201: LIST
3202: PUSH
3203: EMPTY
3204: LIST
3205: LIST
3206: LIST
3207: LIST
3208: LIST
3209: ST_TO_ADDR
// vehicles := [ ] ;
3210: LD_ADDR_VAR 0 9
3214: PUSH
3215: EMPTY
3216: ST_TO_ADDR
// for i in spot_xy do
3217: LD_ADDR_VAR 0 2
3221: PUSH
3222: LD_VAR 0 10
3226: PUSH
3227: FOR_IN
3228: IFFALSE 3382
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
3230: LD_ADDR_VAR 0 5
3234: PUSH
3235: LD_INT 3
3237: PPUSH
3238: LD_INT 3
3240: PPUSH
3241: LD_INT 22
3243: PPUSH
3244: LD_INT 1
3246: PPUSH
3247: LD_INT 1
3249: PPUSH
3250: LD_INT 42
3252: PUSH
3253: LD_INT 43
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: PUSH
3260: LD_INT 1
3262: PPUSH
3263: LD_INT 2
3265: PPUSH
3266: CALL_OW 12
3270: ARRAY
3271: PPUSH
3272: LD_INT 100
3274: PPUSH
3275: CALL 438 0 7
3279: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3280: LD_ADDR_VAR 0 9
3284: PUSH
3285: LD_VAR 0 9
3289: PPUSH
3290: LD_VAR 0 9
3294: PUSH
3295: LD_INT 1
3297: PLUS
3298: PPUSH
3299: LD_VAR 0 5
3303: PPUSH
3304: CALL_OW 2
3308: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3309: LD_VAR 0 5
3313: PPUSH
3314: LD_INT 3
3316: PPUSH
3317: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3321: LD_VAR 0 5
3325: PPUSH
3326: LD_VAR 0 2
3330: PUSH
3331: LD_INT 1
3333: ARRAY
3334: PPUSH
3335: LD_VAR 0 2
3339: PUSH
3340: LD_INT 2
3342: ARRAY
3343: PPUSH
3344: LD_INT 0
3346: PPUSH
3347: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3351: LD_INT 0
3353: PPUSH
3354: LD_INT 3
3356: PPUSH
3357: LD_VAR 0 8
3361: PPUSH
3362: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3366: CALL_OW 44
3370: PPUSH
3371: LD_VAR 0 5
3375: PPUSH
3376: CALL_OW 52
// end ;
3380: GO 3227
3382: POP
3383: POP
// for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
3384: LD_ADDR_VAR 0 2
3388: PUSH
3389: DOUBLE
3390: LD_INT 1
3392: DEC
3393: ST_TO_ADDR
3394: LD_INT 3
3396: PUSH
3397: LD_INT 4
3399: PUSH
3400: LD_INT 5
3402: PUSH
3403: EMPTY
3404: LIST
3405: LIST
3406: LIST
3407: PUSH
3408: LD_OWVAR 67
3412: ARRAY
3413: PUSH
3414: FOR_TO
3415: IFFALSE 3475
// begin PrepareHuman ( false , 1 , skill ) ;
3417: LD_INT 0
3419: PPUSH
3420: LD_INT 1
3422: PPUSH
3423: LD_VAR 0 8
3427: PPUSH
3428: CALL_OW 380
// un := CreateHuman ;
3432: LD_ADDR_VAR 0 4
3436: PUSH
3437: CALL_OW 44
3441: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3442: LD_VAR 0 4
3446: PPUSH
3447: LD_INT 11
3449: PPUSH
3450: LD_INT 0
3452: PPUSH
3453: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3457: LD_ADDR_EXP 42
3461: PUSH
3462: LD_EXP 42
3466: PUSH
3467: LD_VAR 0 4
3471: ADD
3472: ST_TO_ADDR
// end ;
3473: GO 3414
3475: POP
3476: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3477: LD_ADDR_VAR 0 2
3481: PUSH
3482: DOUBLE
3483: LD_INT 1
3485: DEC
3486: ST_TO_ADDR
3487: LD_INT 2
3489: PUSH
3490: LD_INT 3
3492: PUSH
3493: LD_INT 4
3495: PUSH
3496: EMPTY
3497: LIST
3498: LIST
3499: LIST
3500: PUSH
3501: LD_OWVAR 67
3505: ARRAY
3506: PUSH
3507: FOR_TO
3508: IFFALSE 3568
// begin PrepareHuman ( false , 1 , skill ) ;
3510: LD_INT 0
3512: PPUSH
3513: LD_INT 1
3515: PPUSH
3516: LD_VAR 0 8
3520: PPUSH
3521: CALL_OW 380
// un := CreateHuman ;
3525: LD_ADDR_VAR 0 4
3529: PUSH
3530: CALL_OW 44
3534: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
3535: LD_VAR 0 4
3539: PPUSH
3540: LD_INT 12
3542: PPUSH
3543: LD_INT 0
3545: PPUSH
3546: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
3550: LD_ADDR_EXP 41
3554: PUSH
3555: LD_EXP 41
3559: PUSH
3560: LD_VAR 0 4
3564: ADD
3565: ST_TO_ADDR
// end ;
3566: GO 3507
3568: POP
3569: POP
// ru_vehicles := vehicles ;
3570: LD_ADDR_EXP 43
3574: PUSH
3575: LD_VAR 0 9
3579: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
3580: LD_ADDR_EXP 44
3584: PUSH
3585: LD_INT 131
3587: PUSH
3588: LD_INT 121
3590: PUSH
3591: EMPTY
3592: LIST
3593: LIST
3594: PUSH
3595: LD_INT 113
3597: PUSH
3598: LD_INT 90
3600: PUSH
3601: EMPTY
3602: LIST
3603: LIST
3604: PUSH
3605: LD_INT 93
3607: PUSH
3608: LD_INT 62
3610: PUSH
3611: EMPTY
3612: LIST
3613: LIST
3614: PUSH
3615: EMPTY
3616: LIST
3617: LIST
3618: LIST
3619: PUSH
3620: LD_INT 106
3622: PUSH
3623: LD_INT 54
3625: PUSH
3626: EMPTY
3627: LIST
3628: LIST
3629: PUSH
3630: LD_INT 120
3632: PUSH
3633: LD_INT 80
3635: PUSH
3636: EMPTY
3637: LIST
3638: LIST
3639: PUSH
3640: LD_INT 143
3642: PUSH
3643: LD_INT 120
3645: PUSH
3646: EMPTY
3647: LIST
3648: LIST
3649: PUSH
3650: EMPTY
3651: LIST
3652: LIST
3653: LIST
3654: PUSH
3655: LD_INT 154
3657: PUSH
3658: LD_INT 116
3660: PUSH
3661: EMPTY
3662: LIST
3663: LIST
3664: PUSH
3665: LD_INT 140
3667: PUSH
3668: LD_INT 93
3670: PUSH
3671: EMPTY
3672: LIST
3673: LIST
3674: PUSH
3675: LD_INT 130
3677: PUSH
3678: LD_INT 58
3680: PUSH
3681: EMPTY
3682: LIST
3683: LIST
3684: PUSH
3685: EMPTY
3686: LIST
3687: LIST
3688: LIST
3689: PUSH
3690: LD_INT 105
3692: PUSH
3693: LD_INT 106
3695: PUSH
3696: EMPTY
3697: LIST
3698: LIST
3699: PUSH
3700: LD_INT 134
3702: PUSH
3703: LD_INT 98
3705: PUSH
3706: EMPTY
3707: LIST
3708: LIST
3709: PUSH
3710: LD_INT 159
3712: PUSH
3713: LD_INT 113
3715: PUSH
3716: EMPTY
3717: LIST
3718: LIST
3719: PUSH
3720: EMPTY
3721: LIST
3722: LIST
3723: LIST
3724: PUSH
3725: EMPTY
3726: LIST
3727: LIST
3728: LIST
3729: LIST
3730: ST_TO_ADDR
// end ; end_of_file
3731: LD_VAR 0 1
3735: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
3736: LD_INT 0
3738: PPUSH
3739: PPUSH
3740: PPUSH
3741: PPUSH
3742: PPUSH
3743: PPUSH
3744: PPUSH
// InGameOn ;
3745: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
3749: LD_EXP 25
3753: PPUSH
3754: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
3758: LD_EXP 25
3762: PPUSH
3763: LD_EXP 32
3767: PPUSH
3768: CALL_OW 119
// if Bierezov then
3772: LD_EXP 33
3776: IFFALSE 3792
// ComTurnUnit ( Bierezov , Cornel ) ;
3778: LD_EXP 33
3782: PPUSH
3783: LD_EXP 32
3787: PPUSH
3788: CALL_OW 119
// for i in jmm_units do
3792: LD_ADDR_VAR 0 2
3796: PUSH
3797: LD_EXP 2
3801: PUSH
3802: FOR_IN
3803: IFFALSE 3821
// ComTurnUnit ( i , Cornel ) ;
3805: LD_VAR 0 2
3809: PPUSH
3810: LD_EXP 32
3814: PPUSH
3815: CALL_OW 119
3819: GO 3802
3821: POP
3822: POP
// units := cornel_units union Cornel ;
3823: LD_ADDR_VAR 0 3
3827: PUSH
3828: LD_EXP 4
3832: PUSH
3833: LD_EXP 32
3837: UNION
3838: ST_TO_ADDR
// repeat wait ( 1 ) ;
3839: LD_INT 1
3841: PPUSH
3842: CALL_OW 67
// for i in units do
3846: LD_ADDR_VAR 0 2
3850: PUSH
3851: LD_VAR 0 3
3855: PUSH
3856: FOR_IN
3857: IFFALSE 3890
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
3859: LD_VAR 0 2
3863: PPUSH
3864: LD_EXP 25
3868: PPUSH
3869: CALL_OW 250
3873: PPUSH
3874: LD_EXP 25
3878: PPUSH
3879: CALL_OW 251
3883: PPUSH
3884: CALL_OW 111
3888: GO 3856
3890: POP
3891: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
3892: LD_VAR 0 3
3896: PPUSH
3897: LD_INT 92
3899: PUSH
3900: LD_EXP 25
3904: PPUSH
3905: CALL_OW 250
3909: PUSH
3910: LD_EXP 25
3914: PPUSH
3915: CALL_OW 251
3919: PUSH
3920: LD_INT 10
3922: PUSH
3923: EMPTY
3924: LIST
3925: LIST
3926: LIST
3927: LIST
3928: PPUSH
3929: CALL_OW 72
3933: PUSH
3934: LD_VAR 0 3
3938: EQUAL
3939: IFFALSE 3839
// for i in units do
3941: LD_ADDR_VAR 0 2
3945: PUSH
3946: LD_VAR 0 3
3950: PUSH
3951: FOR_IN
3952: IFFALSE 3970
// ComTurnUnit ( i , JMM ) ;
3954: LD_VAR 0 2
3958: PPUSH
3959: LD_EXP 25
3963: PPUSH
3964: CALL_OW 119
3968: GO 3951
3970: POP
3971: POP
// ComTurnUnit ( Cornel , JMM ) ;
3972: LD_EXP 32
3976: PPUSH
3977: LD_EXP 25
3981: PPUSH
3982: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
3986: LD_EXP 25
3990: PPUSH
3991: LD_STRING D1-JMM-1
3993: PPUSH
3994: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
3998: LD_EXP 32
4002: PPUSH
4003: LD_STRING D1-Corn-1
4005: PPUSH
4006: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
4010: LD_EXP 25
4014: PPUSH
4015: LD_EXP 32
4019: PPUSH
4020: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
4024: LD_EXP 32
4028: PPUSH
4029: LD_EXP 25
4033: PPUSH
4034: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
4038: LD_INT 35
4040: PPUSH
4041: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
4045: LD_EXP 25
4049: PPUSH
4050: LD_EXP 32
4054: PPUSH
4055: CALL_OW 296
4059: PUSH
4060: LD_INT 6
4062: LESS
4063: IFFALSE 4038
// ChangeSideFog ( 4 , 1 ) ;
4065: LD_INT 4
4067: PPUSH
4068: LD_INT 1
4070: PPUSH
4071: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
4075: LD_EXP 25
4079: PPUSH
4080: LD_EXP 32
4084: PPUSH
4085: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
4089: LD_EXP 32
4093: PPUSH
4094: LD_EXP 25
4098: PPUSH
4099: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
4103: LD_EXP 25
4107: PPUSH
4108: LD_STRING D1-JMM-2
4110: PPUSH
4111: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
4115: LD_EXP 25
4119: PPUSH
4120: LD_STRING D1-JMM-2a
4122: PPUSH
4123: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
4127: LD_EXP 32
4131: PPUSH
4132: LD_STRING D1-Corn-2
4134: PPUSH
4135: CALL_OW 88
// if bierezov_exist or debug then
4139: LD_EXP 5
4143: PUSH
4144: LD_EXP 1
4148: OR
4149: IFFALSE 4390
// begin ComTurnUnit ( Cornel , Bierezov ) ;
4151: LD_EXP 32
4155: PPUSH
4156: LD_EXP 33
4160: PPUSH
4161: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
4165: LD_INT 10
4167: PPUSH
4168: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
4172: LD_EXP 32
4176: PPUSH
4177: LD_STRING D1a-Corn-1
4179: PPUSH
4180: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
4184: LD_EXP 25
4188: PPUSH
4189: LD_EXP 33
4193: PPUSH
4194: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
4198: LD_EXP 33
4202: PPUSH
4203: LD_EXP 25
4207: PPUSH
4208: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
4212: LD_EXP 25
4216: PPUSH
4217: LD_STRING D1a-JMM-1
4219: PPUSH
4220: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
4224: LD_EXP 25
4228: PPUSH
4229: LD_EXP 32
4233: PPUSH
4234: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
4238: LD_EXP 32
4242: PPUSH
4243: LD_EXP 25
4247: PPUSH
4248: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
4252: LD_EXP 32
4256: PPUSH
4257: LD_STRING D1a-Corn-2
4259: PPUSH
4260: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
4264: LD_EXP 25
4268: PPUSH
4269: LD_STRING D1a-JMM-2
4271: PPUSH
4272: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
4276: LD_EXP 32
4280: PPUSH
4281: LD_STRING D1a-Corn-3
4283: PPUSH
4284: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
4288: LD_EXP 25
4292: PPUSH
4293: LD_STRING D1a-JMM-3
4295: PPUSH
4296: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
4300: LD_EXP 32
4304: PPUSH
4305: LD_STRING D1a-Corn-4
4307: PPUSH
4308: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
4312: LD_EXP 25
4316: PPUSH
4317: LD_STRING D1a-JMM-4
4319: PPUSH
4320: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
4324: LD_EXP 32
4328: PPUSH
4329: LD_STRING D1a-Corn-5
4331: PPUSH
4332: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
4336: LD_EXP 33
4340: PPUSH
4341: LD_EXP 32
4345: PPUSH
4346: CALL_OW 250
4350: PPUSH
4351: LD_EXP 32
4355: PPUSH
4356: CALL_OW 251
4360: PUSH
4361: LD_INT 2
4363: MINUS
4364: PPUSH
4365: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
4369: LD_EXP 33
4373: PPUSH
4374: LD_EXP 32
4378: PPUSH
4379: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
4383: LD_INT 10
4385: PPUSH
4386: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
4390: LD_EXP 25
4394: PPUSH
4395: LD_STRING D1b-JMM-1
4397: PPUSH
4398: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
4402: LD_EXP 32
4406: PPUSH
4407: LD_STRING D1b-Corn-1
4409: PPUSH
4410: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
4414: LD_EXP 25
4418: PPUSH
4419: LD_STRING D1b-JMM-2
4421: PPUSH
4422: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
4426: LD_EXP 32
4430: PPUSH
4431: LD_STRING D1b-Corn-2
4433: PPUSH
4434: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
4438: LD_EXP 25
4442: PPUSH
4443: LD_STRING D1b-JMM-3
4445: PPUSH
4446: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
4450: LD_INT 10
4452: PPUSH
4453: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
4457: LD_EXP 34
4461: PPUSH
4462: LD_STRING D1b-Pow-3
4464: PPUSH
4465: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
4469: LD_EXP 25
4473: PPUSH
4474: LD_STRING D1b-JMM-4
4476: PPUSH
4477: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
4481: LD_EXP 32
4485: PPUSH
4486: LD_STRING D1b-Corn-4
4488: PPUSH
4489: CALL_OW 88
// if Khatam then
4493: LD_EXP 29
4497: IFFALSE 4513
// Say ( Khatam , D1b-Khat-4 ) else
4499: LD_EXP 29
4503: PPUSH
4504: LD_STRING D1b-Khat-4
4506: PPUSH
4507: CALL_OW 88
4511: GO 4549
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
4513: LD_EXP 4
4517: PPUSH
4518: LD_INT 26
4520: PUSH
4521: LD_INT 1
4523: PUSH
4524: EMPTY
4525: LIST
4526: LIST
4527: PPUSH
4528: CALL_OW 72
4532: PUSH
4533: LD_EXP 32
4537: PUSH
4538: EMPTY
4539: LIST
4540: DIFF
4541: PPUSH
4542: LD_STRING D1b-Sol1-4
4544: PPUSH
4545: CALL 526 0 2
// if Cyrus then
4549: LD_EXP 27
4553: IFFALSE 4567
// Say ( Cyrus , D1b-Cyrus-4 ) ;
4555: LD_EXP 27
4559: PPUSH
4560: LD_STRING D1b-Cyrus-4
4562: PPUSH
4563: CALL_OW 88
// if Lisa then
4567: LD_EXP 28
4571: IFFALSE 4629
// begin Say ( Lisa , D1b-Lisa-4 ) ;
4573: LD_EXP 28
4577: PPUSH
4578: LD_STRING D1b-Lisa-4
4580: PPUSH
4581: CALL_OW 88
// if Cyrus then
4585: LD_EXP 27
4589: IFFALSE 4629
// begin if not IsInUnit ( Cyrus ) then
4591: LD_EXP 27
4595: PPUSH
4596: CALL_OW 310
4600: NOT
4601: IFFALSE 4617
// ComTurnUnit ( Cyrus , Lisa ) ;
4603: LD_EXP 27
4607: PPUSH
4608: LD_EXP 28
4612: PPUSH
4613: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
4617: LD_EXP 27
4621: PPUSH
4622: LD_STRING D1b-Cyrus-5
4624: PPUSH
4625: CALL_OW 88
// end ; end ; SelectGroup ;
4629: CALL 2461 0 0
// Say ( JMM , D1d-JMM-1 ) ;
4633: LD_EXP 25
4637: PPUSH
4638: LD_STRING D1d-JMM-1
4640: PPUSH
4641: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
4645: LD_EXP 32
4649: PPUSH
4650: LD_STRING D1d-Corn-1
4652: PPUSH
4653: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
4657: LD_ADDR_VAR 0 2
4661: PUSH
4662: LD_EXP 2
4666: PUSH
4667: LD_EXP 4
4671: ADD
4672: PUSH
4673: LD_EXP 25
4677: ADD
4678: PUSH
4679: FOR_IN
4680: IFFALSE 4693
// ComHold ( i ) ;
4682: LD_VAR 0 2
4686: PPUSH
4687: CALL_OW 140
4691: GO 4679
4693: POP
4694: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
4695: LD_ADDR_VAR 0 4
4699: PUSH
4700: LD_INT 22
4702: PUSH
4703: LD_INT 1
4705: PUSH
4706: EMPTY
4707: LIST
4708: LIST
4709: PUSH
4710: LD_INT 21
4712: PUSH
4713: LD_INT 2
4715: PUSH
4716: EMPTY
4717: LIST
4718: LIST
4719: PUSH
4720: EMPTY
4721: LIST
4722: LIST
4723: PPUSH
4724: CALL_OW 69
4728: ST_TO_ADDR
// if vehicles then
4729: LD_VAR 0 4
4733: IFFALSE 5071
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
4735: LD_EXP 4
4739: PPUSH
4740: LD_INT 55
4742: PUSH
4743: EMPTY
4744: LIST
4745: PPUSH
4746: CALL_OW 72
4750: IFFALSE 4789
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
4752: LD_ADDR_VAR 0 2
4756: PUSH
4757: LD_EXP 4
4761: PPUSH
4762: LD_INT 55
4764: PUSH
4765: EMPTY
4766: LIST
4767: PPUSH
4768: CALL_OW 72
4772: PUSH
4773: FOR_IN
4774: IFFALSE 4787
// ComExitVehicle ( i ) ;
4776: LD_VAR 0 2
4780: PPUSH
4781: CALL_OW 121
4785: GO 4773
4787: POP
4788: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
4789: LD_ADDR_VAR 0 5
4793: PUSH
4794: LD_VAR 0 4
4798: PPUSH
4799: LD_INT 34
4801: PUSH
4802: LD_INT 51
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: PPUSH
4809: CALL_OW 72
4813: ST_TO_ADDR
// if cargos then
4814: LD_VAR 0 5
4818: IFFALSE 5001
// begin vehicles := cargos ;
4820: LD_ADDR_VAR 0 4
4824: PUSH
4825: LD_VAR 0 5
4829: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
4830: LD_ADDR_VAR 0 6
4834: PUSH
4835: LD_STRING 02_resources_4
4837: PPUSH
4838: LD_INT 0
4840: PPUSH
4841: CALL_OW 30
4845: ST_TO_ADDR
// if debug and not resources then
4846: LD_EXP 1
4850: PUSH
4851: LD_VAR 0 6
4855: NOT
4856: AND
4857: IFFALSE 4867
// resources := 160 ;
4859: LD_ADDR_VAR 0 6
4863: PUSH
4864: LD_INT 160
4866: ST_TO_ADDR
// if resources mod 10 then
4867: LD_VAR 0 6
4871: PUSH
4872: LD_INT 10
4874: MOD
4875: IFFALSE 4897
// resources := resources - resources mod 10 ;
4877: LD_ADDR_VAR 0 6
4881: PUSH
4882: LD_VAR 0 6
4886: PUSH
4887: LD_VAR 0 6
4891: PUSH
4892: LD_INT 10
4894: MOD
4895: MINUS
4896: ST_TO_ADDR
// if resources then
4897: LD_VAR 0 6
4901: IFFALSE 5001
// for i in cargos do
4903: LD_ADDR_VAR 0 2
4907: PUSH
4908: LD_VAR 0 5
4912: PUSH
4913: FOR_IN
4914: IFFALSE 4999
// begin if resources < 100 then
4916: LD_VAR 0 6
4920: PUSH
4921: LD_INT 100
4923: LESS
4924: IFFALSE 4946
// begin cargo := resources ;
4926: LD_ADDR_VAR 0 7
4930: PUSH
4931: LD_VAR 0 6
4935: ST_TO_ADDR
// resources := 0 ;
4936: LD_ADDR_VAR 0 6
4940: PUSH
4941: LD_INT 0
4943: ST_TO_ADDR
// end else
4944: GO 4968
// begin cargo := 100 ;
4946: LD_ADDR_VAR 0 7
4950: PUSH
4951: LD_INT 100
4953: ST_TO_ADDR
// resources := resources - 100 ;
4954: LD_ADDR_VAR 0 6
4958: PUSH
4959: LD_VAR 0 6
4963: PUSH
4964: LD_INT 100
4966: MINUS
4967: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
4968: LD_VAR 0 2
4972: PPUSH
4973: LD_INT 1
4975: PPUSH
4976: LD_VAR 0 7
4980: PPUSH
4981: CALL_OW 290
// if resources = 0 then
4985: LD_VAR 0 6
4989: PUSH
4990: LD_INT 0
4992: EQUAL
4993: IFFALSE 4997
// break ;
4995: GO 4999
// end ;
4997: GO 4913
4999: POP
5000: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
5001: LD_VAR 0 4
5005: PUSH
5006: LD_INT 1
5008: ARRAY
5009: PPUSH
5010: CALL_OW 311
5014: PPUSH
5015: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
5019: LD_VAR 0 4
5023: PUSH
5024: LD_INT 1
5026: ARRAY
5027: PPUSH
5028: LD_INT 4
5030: PPUSH
5031: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
5035: LD_EXP 32
5039: PPUSH
5040: LD_VAR 0 4
5044: PUSH
5045: LD_INT 1
5047: ARRAY
5048: PPUSH
5049: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
5053: LD_INT 35
5055: PPUSH
5056: CALL_OW 67
// until IsInUnit ( Cornel ) ;
5060: LD_EXP 32
5064: PPUSH
5065: CALL_OW 310
5069: IFFALSE 5053
// end ; InGameOff ;
5071: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
5075: LD_STRING M1
5077: PPUSH
5078: CALL_OW 337
// SaveForQuickRestart ;
5082: CALL_OW 22
// cornel_active := true ;
5086: LD_ADDR_EXP 6
5090: PUSH
5091: LD_INT 1
5093: ST_TO_ADDR
// end ;
5094: LD_VAR 0 1
5098: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
5099: LD_EXP 25
5103: PPUSH
5104: LD_EXP 35
5108: PPUSH
5109: CALL_OW 296
5113: PUSH
5114: LD_INT 10
5116: LESS
5117: IFFALSE 6209
5119: GO 5121
5121: DISABLE
5122: LD_INT 0
5124: PPUSH
5125: PPUSH
5126: PPUSH
5127: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
5128: LD_ADDR_VAR 0 2
5132: PUSH
5133: LD_INT 89
5135: PUSH
5136: LD_INT 34
5138: PUSH
5139: EMPTY
5140: LIST
5141: LIST
5142: PUSH
5143: LD_INT 138
5145: PUSH
5146: LD_INT 63
5148: PUSH
5149: EMPTY
5150: LIST
5151: LIST
5152: PUSH
5153: LD_INT 196
5155: PUSH
5156: LD_INT 84
5158: PUSH
5159: EMPTY
5160: LIST
5161: LIST
5162: PUSH
5163: LD_INT 135
5165: PUSH
5166: LD_INT 52
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: PUSH
5173: LD_INT 103
5175: PUSH
5176: LD_INT 39
5178: PUSH
5179: EMPTY
5180: LIST
5181: LIST
5182: PUSH
5183: LD_INT 58
5185: PUSH
5186: LD_INT 30
5188: PUSH
5189: EMPTY
5190: LIST
5191: LIST
5192: PUSH
5193: LD_INT 38
5195: PUSH
5196: LD_INT 51
5198: PUSH
5199: EMPTY
5200: LIST
5201: LIST
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: LIST
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: ST_TO_ADDR
// InGameOn ;
5212: CALL_OW 8
// if jmm_units then
5216: LD_EXP 2
5220: IFFALSE 5284
// for i in jmm_units do
5222: LD_ADDR_VAR 0 1
5226: PUSH
5227: LD_EXP 2
5231: PUSH
5232: FOR_IN
5233: IFFALSE 5282
// begin if GetDistUnits ( i , JMM ) < 10 then
5235: LD_VAR 0 1
5239: PPUSH
5240: LD_EXP 25
5244: PPUSH
5245: CALL_OW 296
5249: PUSH
5250: LD_INT 10
5252: LESS
5253: IFFALSE 5271
// ComTurnUnit ( i , JMM ) else
5255: LD_VAR 0 1
5259: PPUSH
5260: LD_EXP 25
5264: PPUSH
5265: CALL_OW 119
5269: GO 5280
// ComHold ( i ) ;
5271: LD_VAR 0 1
5275: PPUSH
5276: CALL_OW 140
// end ;
5280: GO 5232
5282: POP
5283: POP
// ComMoveUnit ( JMM , Lynch ) ;
5284: LD_EXP 25
5288: PPUSH
5289: LD_EXP 35
5293: PPUSH
5294: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5298: LD_INT 35
5300: PPUSH
5301: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
5305: LD_EXP 25
5309: PPUSH
5310: LD_EXP 35
5314: PPUSH
5315: CALL_OW 296
5319: PUSH
5320: LD_INT 6
5322: LESS
5323: IFFALSE 5298
// ComTurnUnit ( JMM , Lynch ) ;
5325: LD_EXP 25
5329: PPUSH
5330: LD_EXP 35
5334: PPUSH
5335: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
5339: LD_ADDR_VAR 0 1
5343: PUSH
5344: LD_EXP 35
5348: PUSH
5349: LD_EXP 36
5353: PUSH
5354: LD_EXP 37
5358: PUSH
5359: LD_EXP 38
5363: PUSH
5364: EMPTY
5365: LIST
5366: LIST
5367: LIST
5368: LIST
5369: PUSH
5370: FOR_IN
5371: IFFALSE 5389
// ComTurnUnit ( i , JMM ) ;
5373: LD_VAR 0 1
5377: PPUSH
5378: LD_EXP 25
5382: PPUSH
5383: CALL_OW 119
5387: GO 5370
5389: POP
5390: POP
// Wait ( 0 0$0.3 ) ;
5391: LD_INT 10
5393: PPUSH
5394: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
5398: LD_EXP 25
5402: PPUSH
5403: LD_STRING D2-JMM-1
5405: PPUSH
5406: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
5410: LD_EXP 35
5414: PPUSH
5415: LD_STRING D2-Sol1-1
5417: PPUSH
5418: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
5422: LD_EXP 25
5426: PPUSH
5427: LD_STRING D2-JMM-2
5429: PPUSH
5430: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
5434: LD_EXP 35
5438: PPUSH
5439: LD_STRING D2-Sol1-2
5441: PPUSH
5442: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
5446: LD_EXP 25
5450: PPUSH
5451: LD_STRING D2-JMM-3
5453: PPUSH
5454: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
5458: LD_EXP 35
5462: PPUSH
5463: LD_STRING D2-Sol1-3
5465: PPUSH
5466: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
5470: LD_ADDR_VAR 0 1
5474: PUSH
5475: LD_INT 22
5477: PUSH
5478: LD_INT 8
5480: PUSH
5481: EMPTY
5482: LIST
5483: LIST
5484: PPUSH
5485: CALL_OW 69
5489: PUSH
5490: FOR_IN
5491: IFFALSE 5507
// SetSide ( i , 1 ) ;
5493: LD_VAR 0 1
5497: PPUSH
5498: LD_INT 1
5500: PPUSH
5501: CALL_OW 235
5505: GO 5490
5507: POP
5508: POP
// Say ( JMM , D2-JMM-4 ) ;
5509: LD_EXP 25
5513: PPUSH
5514: LD_STRING D2-JMM-4
5516: PPUSH
5517: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
5521: LD_INT 1
5523: PPUSH
5524: LD_INT 5
5526: PPUSH
5527: CALL_OW 332
// for i = 1 to points do
5531: LD_ADDR_VAR 0 1
5535: PUSH
5536: DOUBLE
5537: LD_INT 1
5539: DEC
5540: ST_TO_ADDR
5541: LD_VAR 0 2
5545: PUSH
5546: FOR_TO
5547: IFFALSE 5722
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
5549: LD_VAR 0 2
5553: PUSH
5554: LD_VAR 0 1
5558: ARRAY
5559: PUSH
5560: LD_INT 1
5562: ARRAY
5563: PPUSH
5564: LD_VAR 0 2
5568: PUSH
5569: LD_VAR 0 1
5573: ARRAY
5574: PUSH
5575: LD_INT 2
5577: ARRAY
5578: PPUSH
5579: CALL_OW 84
// if i = 1 then
5583: LD_VAR 0 1
5587: PUSH
5588: LD_INT 1
5590: EQUAL
5591: IFFALSE 5605
// Say ( Lynch , D2-Sol1-4 ) ;
5593: LD_EXP 35
5597: PPUSH
5598: LD_STRING D2-Sol1-4
5600: PPUSH
5601: CALL_OW 88
// if i = 2 then
5605: LD_VAR 0 1
5609: PUSH
5610: LD_INT 2
5612: EQUAL
5613: IFFALSE 5627
// Say ( JMM , D2-JMM-5 ) ;
5615: LD_EXP 25
5619: PPUSH
5620: LD_STRING D2-JMM-5
5622: PPUSH
5623: CALL_OW 88
// if i = 4 then
5627: LD_VAR 0 1
5631: PUSH
5632: LD_INT 4
5634: EQUAL
5635: IFFALSE 5659
// begin RevealFogArea ( 1 , troopsArea ) ;
5637: LD_INT 1
5639: PPUSH
5640: LD_INT 6
5642: PPUSH
5643: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
5647: LD_EXP 35
5651: PPUSH
5652: LD_STRING D2-Sol1-5
5654: PPUSH
5655: CALL_OW 88
// end ; if i = 5 then
5659: LD_VAR 0 1
5663: PUSH
5664: LD_INT 5
5666: EQUAL
5667: IFFALSE 5681
// Say ( JMM , D2-JMM-6 ) ;
5669: LD_EXP 25
5673: PPUSH
5674: LD_STRING D2-JMM-6
5676: PPUSH
5677: CALL_OW 88
// if i = 7 then
5681: LD_VAR 0 1
5685: PUSH
5686: LD_INT 7
5688: EQUAL
5689: IFFALSE 5713
// begin RevealFogArea ( 1 , forestArea ) ;
5691: LD_INT 1
5693: PPUSH
5694: LD_INT 7
5696: PPUSH
5697: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
5701: LD_EXP 35
5705: PPUSH
5706: LD_STRING D2-Sol1-6
5708: PPUSH
5709: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
5713: LD_INT 46
5715: PPUSH
5716: CALL_OW 67
// end ;
5720: GO 5546
5722: POP
5723: POP
// CenterNowOnUnits ( JMM ) ;
5724: LD_EXP 25
5728: PPUSH
5729: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
5733: LD_EXP 25
5737: PPUSH
5738: LD_STRING D2-JMM-7
5740: PPUSH
5741: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
5745: LD_EXP 35
5749: PPUSH
5750: LD_STRING D2-Sol1-7
5752: PPUSH
5753: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
5757: LD_EXP 25
5761: PPUSH
5762: LD_STRING D2-JMM-8
5764: PPUSH
5765: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
5769: LD_ADDR_VAR 0 4
5773: PUSH
5774: LD_INT 22
5776: PUSH
5777: LD_INT 1
5779: PUSH
5780: EMPTY
5781: LIST
5782: LIST
5783: PUSH
5784: LD_INT 30
5786: PUSH
5787: LD_INT 31
5789: PUSH
5790: EMPTY
5791: LIST
5792: LIST
5793: PUSH
5794: EMPTY
5795: LIST
5796: LIST
5797: PPUSH
5798: CALL_OW 69
5802: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
5803: LD_EXP 35
5807: PPUSH
5808: LD_VAR 0 4
5812: PUSH
5813: LD_INT 1
5815: ARRAY
5816: PPUSH
5817: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
5821: LD_ADDR_VAR 0 3
5825: PUSH
5826: LD_EXP 2
5830: PPUSH
5831: LD_INT 25
5833: PUSH
5834: LD_INT 1
5836: PUSH
5837: EMPTY
5838: LIST
5839: LIST
5840: PPUSH
5841: CALL_OW 72
5845: PPUSH
5846: LD_EXP 25
5850: PPUSH
5851: CALL_OW 74
5855: ST_TO_ADDR
// if sol then
5856: LD_VAR 0 3
5860: IFFALSE 5900
// if GetDistUnits ( JMM , sol ) < 10 then
5862: LD_EXP 25
5866: PPUSH
5867: LD_VAR 0 3
5871: PPUSH
5872: CALL_OW 296
5876: PUSH
5877: LD_INT 10
5879: LESS
5880: IFFALSE 5900
// ComEnterUnit ( sol , buns [ 2 ] ) ;
5882: LD_VAR 0 3
5886: PPUSH
5887: LD_VAR 0 4
5891: PUSH
5892: LD_INT 2
5894: ARRAY
5895: PPUSH
5896: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
5900: LD_INT 10
5902: PPUSH
5903: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
5907: LD_EXP 25
5911: PPUSH
5912: LD_INT 65
5914: PPUSH
5915: LD_INT 101
5917: PPUSH
5918: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
5922: LD_EXP 25
5926: PPUSH
5927: LD_INT 63
5929: PPUSH
5930: LD_INT 100
5932: PPUSH
5933: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
5937: LD_INT 35
5939: PPUSH
5940: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
5944: LD_EXP 25
5948: PPUSH
5949: LD_INT 65
5951: PPUSH
5952: LD_INT 101
5954: PPUSH
5955: CALL_OW 307
5959: IFFALSE 5937
// Say ( JMM , D2a-JMM-1 ) ;
5961: LD_EXP 25
5965: PPUSH
5966: LD_STRING D2a-JMM-1
5968: PPUSH
5969: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
5973: LD_EXP 36
5977: PPUSH
5978: LD_INT 66
5980: PPUSH
5981: LD_INT 103
5983: PPUSH
5984: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
5988: LD_INT 35
5990: PPUSH
5991: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
5995: LD_EXP 36
5999: PPUSH
6000: LD_INT 66
6002: PPUSH
6003: LD_INT 103
6005: PPUSH
6006: CALL_OW 307
6010: IFFALSE 5988
// ComTurnUnit ( Walker , JMM ) ;
6012: LD_EXP 36
6016: PPUSH
6017: LD_EXP 25
6021: PPUSH
6022: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
6026: LD_EXP 36
6030: PPUSH
6031: LD_STRING D2a-Sci1-1
6033: PPUSH
6034: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
6038: LD_EXP 25
6042: PPUSH
6043: LD_EXP 36
6047: PPUSH
6048: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
6052: LD_EXP 25
6056: PPUSH
6057: LD_STRING D2a-JMM-2
6059: PPUSH
6060: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
6064: LD_EXP 36
6068: PPUSH
6069: LD_STRING D2a-Sci1-2
6071: PPUSH
6072: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
6076: LD_EXP 25
6080: PPUSH
6081: LD_STRING D2a-JMM-3
6083: PPUSH
6084: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
6088: LD_EXP 36
6092: PPUSH
6093: LD_STRING D2a-Sci1-3
6095: PPUSH
6096: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
6100: LD_ADDR_EXP 2
6104: PUSH
6105: LD_EXP 2
6109: PUSH
6110: LD_EXP 35
6114: PUSH
6115: LD_EXP 36
6119: PUSH
6120: LD_EXP 37
6124: PUSH
6125: LD_EXP 38
6129: PUSH
6130: EMPTY
6131: LIST
6132: LIST
6133: LIST
6134: LIST
6135: ADD
6136: ST_TO_ADDR
// for i in jmm_units do
6137: LD_ADDR_VAR 0 1
6141: PUSH
6142: LD_EXP 2
6146: PUSH
6147: FOR_IN
6148: IFFALSE 6173
// if not IsInUnit ( i ) then
6150: LD_VAR 0 1
6154: PPUSH
6155: CALL_OW 310
6159: NOT
6160: IFFALSE 6171
// ComFree ( i ) ;
6162: LD_VAR 0 1
6166: PPUSH
6167: CALL_OW 139
6171: GO 6147
6173: POP
6174: POP
// InGameOff ;
6175: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
6179: LD_STRING MSolar1
6181: PPUSH
6182: CALL_OW 337
// jmm_on_west := true ;
6186: LD_ADDR_EXP 3
6190: PUSH
6191: LD_INT 1
6193: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
6194: LD_INT 1050
6196: PPUSH
6197: CALL_OW 67
// frank_can_return := true ;
6201: LD_ADDR_EXP 10
6205: PUSH
6206: LD_INT 1
6208: ST_TO_ADDR
// end ;
6209: PPOPN 4
6211: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
6212: LD_INT 22
6214: PUSH
6215: LD_INT 1
6217: PUSH
6218: EMPTY
6219: LIST
6220: LIST
6221: PUSH
6222: LD_INT 34
6224: PUSH
6225: LD_INT 51
6227: PUSH
6228: EMPTY
6229: LIST
6230: LIST
6231: PUSH
6232: LD_INT 92
6234: PUSH
6235: LD_INT 63
6237: PUSH
6238: LD_INT 100
6240: PUSH
6241: LD_INT 5
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: LIST
6248: LIST
6249: PUSH
6250: EMPTY
6251: LIST
6252: LIST
6253: LIST
6254: PUSH
6255: EMPTY
6256: LIST
6257: PPUSH
6258: CALL_OW 69
6262: PUSH
6263: LD_EXP 3
6267: NOT
6268: AND
6269: IFFALSE 6382
6271: GO 6273
6273: DISABLE
6274: LD_INT 0
6276: PPUSH
6277: PPUSH
// begin enable ;
6278: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
6279: LD_ADDR_VAR 0 2
6283: PUSH
6284: LD_INT 22
6286: PUSH
6287: LD_INT 1
6289: PUSH
6290: EMPTY
6291: LIST
6292: LIST
6293: PUSH
6294: LD_INT 34
6296: PUSH
6297: LD_INT 51
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 92
6306: PUSH
6307: LD_INT 63
6309: PUSH
6310: LD_INT 100
6312: PUSH
6313: LD_INT 5
6315: PUSH
6316: EMPTY
6317: LIST
6318: LIST
6319: LIST
6320: LIST
6321: PUSH
6322: EMPTY
6323: LIST
6324: LIST
6325: LIST
6326: PUSH
6327: EMPTY
6328: LIST
6329: PPUSH
6330: CALL_OW 69
6334: ST_TO_ADDR
// if not filter then
6335: LD_VAR 0 2
6339: NOT
6340: IFFALSE 6344
// exit ;
6342: GO 6382
// for i in filter do
6344: LD_ADDR_VAR 0 1
6348: PUSH
6349: LD_VAR 0 2
6353: PUSH
6354: FOR_IN
6355: IFFALSE 6380
// begin SetFuel ( i , 0 ) ;
6357: LD_VAR 0 1
6361: PPUSH
6362: LD_INT 0
6364: PPUSH
6365: CALL_OW 240
// ComStop ( i ) ;
6369: LD_VAR 0 1
6373: PPUSH
6374: CALL_OW 141
// end ;
6378: GO 6354
6380: POP
6381: POP
// end ;
6382: PPOPN 2
6384: END
// every 0 0$10 trigger frank_can_return do var i , points ;
6385: LD_EXP 10
6389: IFFALSE 7429
6391: GO 6393
6393: DISABLE
6394: LD_INT 0
6396: PPUSH
6397: PPUSH
// begin uc_side := 8 ;
6398: LD_ADDR_OWVAR 20
6402: PUSH
6403: LD_INT 8
6405: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
6406: LD_ADDR_VAR 0 2
6410: PUSH
6411: LD_INT 59
6413: PUSH
6414: LD_INT 71
6416: PUSH
6417: EMPTY
6418: LIST
6419: LIST
6420: PUSH
6421: LD_INT 122
6423: PUSH
6424: LD_INT 117
6426: PUSH
6427: EMPTY
6428: LIST
6429: LIST
6430: PUSH
6431: EMPTY
6432: LIST
6433: LIST
6434: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
6435: LD_ADDR_EXP 39
6439: PUSH
6440: LD_STRING Frank
6442: PPUSH
6443: LD_INT 0
6445: PPUSH
6446: CALL 381 0 2
6450: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
6451: LD_ADDR_VAR 0 1
6455: PUSH
6456: LD_INT 1
6458: PPUSH
6459: LD_INT 2
6461: PPUSH
6462: CALL_OW 12
6466: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
6467: LD_EXP 39
6471: PPUSH
6472: LD_VAR 0 2
6476: PUSH
6477: LD_VAR 0 1
6481: ARRAY
6482: PUSH
6483: LD_INT 1
6485: ARRAY
6486: PPUSH
6487: LD_VAR 0 2
6491: PUSH
6492: LD_VAR 0 1
6496: ARRAY
6497: PUSH
6498: LD_INT 2
6500: ARRAY
6501: PPUSH
6502: LD_INT 0
6504: PPUSH
6505: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
6509: LD_EXP 39
6513: PPUSH
6514: LD_INT 1
6516: PPUSH
6517: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
6521: LD_INT 35
6523: PPUSH
6524: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
6528: LD_EXP 39
6532: PPUSH
6533: LD_EXP 25
6537: PPUSH
6538: CALL_OW 296
6542: PUSH
6543: LD_INT 8
6545: LESS
6546: IFFALSE 6521
// InGameOn ;
6548: CALL_OW 8
// CenterOnUnits ( JMM ) ;
6552: LD_EXP 25
6556: PPUSH
6557: CALL_OW 85
// if IsInUnit ( JMM ) then
6561: LD_EXP 25
6565: PPUSH
6566: CALL_OW 310
6570: IFFALSE 6581
// ComFree ( JMM ) ;
6572: LD_EXP 25
6576: PPUSH
6577: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
6581: LD_EXP 25
6585: PPUSH
6586: LD_EXP 39
6590: PPUSH
6591: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
6595: LD_EXP 39
6599: PPUSH
6600: LD_EXP 25
6604: PPUSH
6605: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
6609: LD_EXP 25
6613: PPUSH
6614: LD_STRING D6-JMM-1
6616: PPUSH
6617: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
6621: LD_INT 35
6623: PPUSH
6624: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
6628: LD_EXP 25
6632: PPUSH
6633: LD_EXP 39
6637: PPUSH
6638: CALL_OW 296
6642: PUSH
6643: LD_INT 8
6645: LESS
6646: IFFALSE 6621
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
6648: LD_EXP 28
6652: PUSH
6653: LD_EXP 28
6657: PPUSH
6658: LD_EXP 39
6662: PPUSH
6663: CALL_OW 296
6667: PUSH
6668: LD_INT 20
6670: LESS
6671: AND
6672: IFFALSE 6697
// begin ComFree ( Lisa ) ;
6674: LD_EXP 28
6678: PPUSH
6679: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
6683: LD_EXP 28
6687: PPUSH
6688: LD_EXP 39
6692: PPUSH
6693: CALL_OW 172
// end ; if Lynch then
6697: LD_EXP 35
6701: IFFALSE 6726
// begin ComFree ( Lynch ) ;
6703: LD_EXP 35
6707: PPUSH
6708: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
6712: LD_EXP 35
6716: PPUSH
6717: LD_EXP 39
6721: PPUSH
6722: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
6726: LD_EXP 25
6730: PPUSH
6731: LD_EXP 39
6735: PPUSH
6736: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
6740: LD_EXP 39
6744: PPUSH
6745: LD_EXP 25
6749: PPUSH
6750: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
6754: LD_EXP 39
6758: PPUSH
6759: LD_STRING D6-Frank-1
6761: PPUSH
6762: CALL_OW 88
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
6766: LD_EXP 28
6770: PUSH
6771: LD_EXP 28
6775: PPUSH
6776: LD_EXP 39
6780: PPUSH
6781: CALL_OW 296
6785: PUSH
6786: LD_INT 20
6788: LESS
6789: AND
6790: PUSH
6791: LD_EXP 28
6795: PPUSH
6796: CALL_OW 302
6800: AND
6801: IFFALSE 6891
// begin ComFree ( Lisa ) ;
6803: LD_EXP 28
6807: PPUSH
6808: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
6812: LD_INT 35
6814: PPUSH
6815: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
6819: LD_EXP 28
6823: PPUSH
6824: LD_EXP 39
6828: PPUSH
6829: CALL_OW 296
6833: PUSH
6834: LD_INT 7
6836: LESS
6837: IFFALSE 6812
// Say ( Lisa , D6-Lisa-1 ) ;
6839: LD_EXP 28
6843: PPUSH
6844: LD_STRING D6-Lisa-1
6846: PPUSH
6847: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
6851: LD_EXP 28
6855: PPUSH
6856: LD_EXP 39
6860: PPUSH
6861: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
6865: LD_EXP 39
6869: PPUSH
6870: LD_EXP 28
6874: PPUSH
6875: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
6879: LD_EXP 39
6883: PPUSH
6884: LD_STRING D6-Frank-2
6886: PPUSH
6887: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
6891: LD_EXP 35
6895: PUSH
6896: LD_EXP 35
6900: PPUSH
6901: LD_EXP 39
6905: PPUSH
6906: CALL_OW 296
6910: PUSH
6911: LD_INT 20
6913: LESS
6914: AND
6915: PUSH
6916: LD_EXP 35
6920: PPUSH
6921: CALL_OW 302
6925: AND
6926: IFFALSE 7107
// begin ComTurnUnit ( Lynch , JMM ) ;
6928: LD_EXP 35
6932: PPUSH
6933: LD_EXP 25
6937: PPUSH
6938: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
6942: LD_EXP 39
6946: PPUSH
6947: LD_EXP 25
6951: PPUSH
6952: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
6956: LD_EXP 35
6960: PPUSH
6961: LD_STRING D6-Sol1-2
6963: PPUSH
6964: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
6968: LD_EXP 25
6972: PPUSH
6973: LD_STRING D6-JMM-2
6975: PPUSH
6976: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
6980: LD_EXP 39
6984: PPUSH
6985: LD_STRING D6-Frank-3
6987: PPUSH
6988: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
6992: LD_EXP 25
6996: PPUSH
6997: LD_STRING D6-JMM-3
6999: PPUSH
7000: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
7004: LD_EXP 39
7008: PPUSH
7009: LD_STRING D6-Frank-4
7011: PPUSH
7012: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
7016: LD_EXP 39
7020: PPUSH
7021: LD_STRING D6-Frank-4a
7023: PPUSH
7024: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
7028: LD_EXP 25
7032: PPUSH
7033: LD_STRING D6-JMM-4
7035: PPUSH
7036: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
7040: LD_EXP 39
7044: PPUSH
7045: LD_STRING D6-Frank-5
7047: PPUSH
7048: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
7052: LD_EXP 28
7056: PUSH
7057: LD_EXP 28
7061: PPUSH
7062: CALL_OW 302
7066: AND
7067: IFFALSE 7081
// Say ( Lisa , D6-Lisa-5 ) ;
7069: LD_EXP 28
7073: PPUSH
7074: LD_STRING D6-Lisa-5
7076: PPUSH
7077: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
7081: LD_EXP 39
7085: PPUSH
7086: LD_STRING D6-Frank-6
7088: PPUSH
7089: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
7093: LD_EXP 25
7097: PPUSH
7098: LD_STRING D6-JMM-6
7100: PPUSH
7101: CALL_OW 88
// end else
7105: GO 7222
// begin ComTurnUnit ( Frank , JMM ) ;
7107: LD_EXP 39
7111: PPUSH
7112: LD_EXP 25
7116: PPUSH
7117: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
7121: LD_EXP 39
7125: PPUSH
7126: LD_STRING D6-Frank-4
7128: PPUSH
7129: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
7133: LD_EXP 39
7137: PPUSH
7138: LD_STRING D6-Frank-4a
7140: PPUSH
7141: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
7145: LD_EXP 25
7149: PPUSH
7150: LD_STRING D6-JMM-4
7152: PPUSH
7153: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
7157: LD_EXP 39
7161: PPUSH
7162: LD_STRING D6-Frank-5
7164: PPUSH
7165: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
7169: LD_EXP 28
7173: PUSH
7174: LD_EXP 28
7178: PPUSH
7179: CALL_OW 302
7183: AND
7184: IFFALSE 7198
// Say ( Lisa , D6-Lisa-5 ) ;
7186: LD_EXP 28
7190: PPUSH
7191: LD_STRING D6-Lisa-5
7193: PPUSH
7194: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
7198: LD_EXP 39
7202: PPUSH
7203: LD_STRING D6-Frank-6
7205: PPUSH
7206: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
7210: LD_EXP 25
7214: PPUSH
7215: LD_STRING D6-JMM-6
7217: PPUSH
7218: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
7222: LD_STRING Q1
7224: PPUSH
7225: CALL_OW 97
7229: PUSH
7230: LD_INT 1
7232: DOUBLE
7233: EQUAL
7234: IFTRUE 7238
7236: GO 7249
7238: POP
// frank_send_to_scout := true ; 2 :
7239: LD_ADDR_EXP 12
7243: PUSH
7244: LD_INT 1
7246: ST_TO_ADDR
7247: GO 7269
7249: LD_INT 2
7251: DOUBLE
7252: EQUAL
7253: IFTRUE 7257
7255: GO 7268
7257: POP
// frank_send_to_scout := false ; end ;
7258: LD_ADDR_EXP 12
7262: PUSH
7263: LD_INT 0
7265: ST_TO_ADDR
7266: GO 7269
7268: POP
// InGameOff ;
7269: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
7273: LD_EXP 25
7277: PUSH
7278: LD_EXP 28
7282: PUSH
7283: LD_EXP 35
7287: PUSH
7288: EMPTY
7289: LIST
7290: LIST
7291: LIST
7292: PPUSH
7293: CALL_OW 139
// if frank_send_to_scout then
7297: LD_EXP 12
7301: IFFALSE 7358
// begin ComMoveXY ( Frank , 130 , 123 ) ;
7303: LD_EXP 39
7307: PPUSH
7308: LD_INT 130
7310: PPUSH
7311: LD_INT 123
7313: PPUSH
7314: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
7318: LD_INT 35
7320: PPUSH
7321: CALL_OW 67
// until not See ( 1 , Frank ) ;
7325: LD_INT 1
7327: PPUSH
7328: LD_EXP 39
7332: PPUSH
7333: CALL_OW 292
7337: NOT
7338: IFFALSE 7318
// Wait ( 0 0$02 ) ;
7340: LD_INT 70
7342: PPUSH
7343: CALL_OW 67
// RemoveUnit ( Frank ) ;
7347: LD_EXP 39
7351: PPUSH
7352: CALL_OW 64
// end else
7356: GO 7370
// SetSide ( Frank , 1 ) ;
7358: LD_EXP 39
7362: PPUSH
7363: LD_INT 1
7365: PPUSH
7366: CALL_OW 235
// repeat wait ( 0 0$01 ) ;
7370: LD_INT 35
7372: PPUSH
7373: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
7377: LD_ADDR_EXP 24
7381: PUSH
7382: LD_EXP 24
7386: PPUSH
7387: LD_STRING -
7389: PPUSH
7390: CALL 1000 0 2
7394: ST_TO_ADDR
// if debug then
7395: LD_EXP 1
7399: IFFALSE 7411
// debug_strings := time_to_prepare ;
7401: LD_ADDR_OWVAR 48
7405: PUSH
7406: LD_EXP 24
7410: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
7411: LD_EXP 24
7415: PUSH
7416: LD_INT 0
7418: EQUAL
7419: IFFALSE 7370
// cornel_prepared := true ;
7421: LD_ADDR_EXP 9
7425: PUSH
7426: LD_INT 1
7428: ST_TO_ADDR
// end ;
7429: PPOPN 2
7431: END
// every 0 0$01 trigger cornel_prepared do
7432: LD_EXP 9
7436: IFFALSE 7656
7438: GO 7440
7440: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
7441: LD_EXP 32
7445: PPUSH
7446: LD_STRING D3-Corn-1
7448: PPUSH
7449: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
7453: LD_INT 35
7455: PPUSH
7456: CALL_OW 67
// until cornel_counter = 0 ;
7460: LD_EXP 8
7464: PUSH
7465: LD_INT 0
7467: EQUAL
7468: IFFALSE 7453
// SayRadio ( Cornel , D3a-Corn-1 ) ;
7470: LD_EXP 32
7474: PPUSH
7475: LD_STRING D3a-Corn-1
7477: PPUSH
7478: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
7482: LD_EXP 25
7486: PPUSH
7487: LD_STRING D3a-JMM-1
7489: PPUSH
7490: CALL_OW 88
// end_mission_allowed := true ;
7494: LD_ADDR_EXP 18
7498: PUSH
7499: LD_INT 1
7501: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
7502: LD_STRING M2
7504: PPUSH
7505: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
7509: LD_INT 9
7511: PPUSH
7512: LD_INT 1
7514: PPUSH
7515: CALL_OW 424
// Wait ( 0 0$05 ) ;
7519: LD_INT 175
7521: PPUSH
7522: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
7526: LD_EXP 32
7530: PPUSH
7531: LD_STRING D3a-Corn-2
7533: PPUSH
7534: CALL_OW 94
// cornel_attack := true ;
7538: LD_ADDR_EXP 7
7542: PUSH
7543: LD_INT 1
7545: ST_TO_ADDR
// if frank_send_to_scout then
7546: LD_EXP 12
7550: IFFALSE 7656
// begin InitHc ;
7552: CALL_OW 19
// InitUc ;
7556: CALL_OW 18
// uc_side := 8 ;
7560: LD_ADDR_OWVAR 20
7564: PUSH
7565: LD_INT 8
7567: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
7568: LD_ADDR_EXP 39
7572: PUSH
7573: LD_STRING Frank
7575: PPUSH
7576: LD_INT 0
7578: PPUSH
7579: CALL 381 0 2
7583: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
7584: LD_EXP 39
7588: PPUSH
7589: LD_INT 6
7591: PPUSH
7592: LD_INT 9
7594: PPUSH
7595: LD_INT 0
7597: PPUSH
7598: CALL_OW 48
// ComCrawl ( Frank ) ;
7602: LD_EXP 39
7606: PPUSH
7607: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
7611: LD_INT 35
7613: PPUSH
7614: CALL_OW 67
// until See ( 1 , Frank ) ;
7618: LD_INT 1
7620: PPUSH
7621: LD_EXP 39
7625: PPUSH
7626: CALL_OW 292
7630: IFFALSE 7611
// SetSide ( Frank , 1 ) ;
7632: LD_EXP 39
7636: PPUSH
7637: LD_INT 1
7639: PPUSH
7640: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
7644: LD_EXP 39
7648: PPUSH
7649: LD_STRING D6a-Frank-1
7651: PPUSH
7652: CALL_OW 88
// end ; end ;
7656: END
// every 0 0$01 trigger solar_builded do
7657: LD_EXP 11
7661: IFFALSE 7765
7663: GO 7665
7665: DISABLE
// begin Wait ( 0 0$02 ) ;
7666: LD_INT 70
7668: PPUSH
7669: CALL_OW 67
// DialogueOn ;
7673: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
7677: LD_EXP 25
7681: PPUSH
7682: LD_STRING D2b-JMM-1
7684: PPUSH
7685: CALL_OW 88
// if Walker and IsOk ( Walker ) then
7689: LD_EXP 36
7693: PUSH
7694: LD_EXP 36
7698: PPUSH
7699: CALL_OW 302
7703: AND
7704: IFFALSE 7754
// begin Say ( Walker , D2b-Sci1-1 ) ;
7706: LD_EXP 36
7710: PPUSH
7711: LD_STRING D2b-Sci1-1
7713: PPUSH
7714: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
7718: LD_EXP 25
7722: PPUSH
7723: LD_STRING D2b-JMM-2
7725: PPUSH
7726: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
7730: LD_EXP 36
7734: PPUSH
7735: LD_STRING D2b-Sci1-2
7737: PPUSH
7738: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
7742: LD_EXP 25
7746: PPUSH
7747: LD_STRING D2b-JMM-3
7749: PPUSH
7750: CALL_OW 88
// end ; DialogueOff ;
7754: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
7758: LD_STRING MOutSol
7760: PPUSH
7761: CALL_OW 337
// end ;
7765: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
7766: LD_EXP 11
7770: PUSH
7771: LD_EXP 25
7775: PPUSH
7776: CALL_OW 302
7780: AND
7781: PUSH
7782: LD_EXP 25
7786: PPUSH
7787: CALL 834 0 1
7791: AND
7792: PUSH
7793: LD_EXP 13
7797: NOT
7798: AND
7799: IFFALSE 7870
7801: GO 7803
7803: DISABLE
7804: LD_INT 0
7806: PPUSH
// begin jmm_in_veh := true ;
7807: LD_ADDR_EXP 13
7811: PUSH
7812: LD_INT 1
7814: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
7815: LD_ADDR_VAR 0 1
7819: PUSH
7820: LD_INT 0
7822: PPUSH
7823: LD_INT 1
7825: PPUSH
7826: CALL_OW 12
7830: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
7831: LD_INT 70
7833: PPUSH
7834: CALL_OW 67
// if i then
7838: LD_VAR 0 1
7842: IFFALSE 7858
// Say ( JMM , D2c-JMM-1 ) else
7844: LD_EXP 25
7848: PPUSH
7849: LD_STRING D2c-JMM-1
7851: PPUSH
7852: CALL_OW 88
7856: GO 7870
// Say ( JMM , D2c-JMM-1a ) ;
7858: LD_EXP 25
7862: PPUSH
7863: LD_STRING D2c-JMM-1a
7865: PPUSH
7866: CALL_OW 88
// end ;
7870: PPOPN 1
7872: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
7873: LD_EXP 11
7877: PUSH
7878: LD_EXP 26
7882: PPUSH
7883: CALL_OW 302
7887: AND
7888: PUSH
7889: LD_EXP 26
7893: PPUSH
7894: CALL 834 0 1
7898: AND
7899: PUSH
7900: LD_EXP 14
7904: NOT
7905: AND
7906: IFFALSE 7938
7908: GO 7910
7910: DISABLE
// begin bobby_in_veh := true ;
7911: LD_ADDR_EXP 14
7915: PUSH
7916: LD_INT 1
7918: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
7919: LD_INT 70
7921: PPUSH
7922: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
7926: LD_EXP 26
7930: PPUSH
7931: LD_STRING D2c-Bobby-1
7933: PPUSH
7934: CALL_OW 88
7938: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
7939: LD_EXP 11
7943: PUSH
7944: LD_EXP 28
7948: PPUSH
7949: CALL_OW 302
7953: AND
7954: PUSH
7955: LD_EXP 28
7959: PPUSH
7960: CALL 834 0 1
7964: AND
7965: PUSH
7966: LD_EXP 16
7970: NOT
7971: AND
7972: IFFALSE 8004
7974: GO 7976
7976: DISABLE
// begin lisa_in_veh := true ;
7977: LD_ADDR_EXP 16
7981: PUSH
7982: LD_INT 1
7984: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
7985: LD_INT 70
7987: PPUSH
7988: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
7992: LD_EXP 28
7996: PPUSH
7997: LD_STRING D2c-Lisa-1
7999: PPUSH
8000: CALL_OW 88
8004: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
8005: LD_EXP 11
8009: PUSH
8010: LD_EXP 27
8014: PPUSH
8015: CALL_OW 302
8019: AND
8020: PUSH
8021: LD_EXP 27
8025: PPUSH
8026: CALL 834 0 1
8030: AND
8031: PUSH
8032: LD_EXP 15
8036: NOT
8037: AND
8038: IFFALSE 8109
8040: GO 8042
8042: DISABLE
8043: LD_INT 0
8045: PPUSH
// begin cyrus_in_veh := true ;
8046: LD_ADDR_EXP 15
8050: PUSH
8051: LD_INT 1
8053: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
8054: LD_ADDR_VAR 0 1
8058: PUSH
8059: LD_INT 0
8061: PPUSH
8062: LD_INT 1
8064: PPUSH
8065: CALL_OW 12
8069: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
8070: LD_INT 70
8072: PPUSH
8073: CALL_OW 67
// if i then
8077: LD_VAR 0 1
8081: IFFALSE 8097
// Say ( Cyrus , D2c-Cyrus-1 ) else
8083: LD_EXP 27
8087: PPUSH
8088: LD_STRING D2c-Cyrus-1
8090: PPUSH
8091: CALL_OW 88
8095: GO 8109
// Say ( Cyrus , D2c-Cyrus-1a ) ;
8097: LD_EXP 27
8101: PPUSH
8102: LD_STRING D2c-Cyrus-1a
8104: PPUSH
8105: CALL_OW 88
// end ;
8109: PPOPN 1
8111: END
// every 0 0$01 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) do var i , filter ;
8112: LD_INT 9
8114: PPUSH
8115: LD_INT 22
8117: PUSH
8118: LD_INT 1
8120: PUSH
8121: EMPTY
8122: LIST
8123: LIST
8124: PPUSH
8125: CALL_OW 70
8129: IFFALSE 8921
8131: GO 8133
8133: DISABLE
8134: LD_INT 0
8136: PPUSH
8137: PPUSH
// begin enable ;
8138: ENABLE
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
8139: LD_ADDR_VAR 0 2
8143: PUSH
8144: LD_INT 9
8146: PPUSH
8147: LD_INT 22
8149: PUSH
8150: LD_INT 1
8152: PUSH
8153: EMPTY
8154: LIST
8155: LIST
8156: PPUSH
8157: CALL_OW 70
8161: ST_TO_ADDR
// if not filter then
8162: LD_VAR 0 2
8166: NOT
8167: IFFALSE 8171
// exit ;
8169: GO 8921
// for i in filter do
8171: LD_ADDR_VAR 0 1
8175: PUSH
8176: LD_VAR 0 2
8180: PUSH
8181: FOR_IN
8182: IFFALSE 8919
// begin if IsDrivenBy ( i ) and GetType ( i ) = unit_human then
8184: LD_VAR 0 1
8188: PPUSH
8189: CALL_OW 311
8193: PUSH
8194: LD_VAR 0 1
8198: PPUSH
8199: CALL_OW 247
8203: PUSH
8204: LD_INT 1
8206: EQUAL
8207: AND
8208: IFFALSE 8226
// begin ComExitVehicle ( i ) ;
8210: LD_VAR 0 1
8214: PPUSH
8215: CALL_OW 121
// Wait ( 3 ) ;
8219: LD_INT 3
8221: PPUSH
8222: CALL_OW 67
// end ; if i = JMM then
8226: LD_VAR 0 1
8230: PUSH
8231: LD_EXP 25
8235: EQUAL
8236: IFFALSE 8403
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
8238: LD_EXP 21
8242: PUSH
8243: LD_INT 22
8245: PUSH
8246: LD_INT 1
8248: PUSH
8249: EMPTY
8250: LIST
8251: LIST
8252: PUSH
8253: LD_INT 21
8255: PUSH
8256: LD_INT 1
8258: PUSH
8259: EMPTY
8260: LIST
8261: LIST
8262: PUSH
8263: EMPTY
8264: LIST
8265: LIST
8266: PPUSH
8267: CALL_OW 69
8271: PUSH
8272: LD_INT 1
8274: GREATER
8275: AND
8276: IFFALSE 8333
// begin show_query := false ;
8278: LD_ADDR_EXP 21
8282: PUSH
8283: LD_INT 0
8285: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
8286: LD_STRING Q2
8288: PPUSH
8289: CALL_OW 97
8293: PUSH
8294: LD_INT 1
8296: DOUBLE
8297: EQUAL
8298: IFTRUE 8302
8300: GO 8313
8302: POP
// wait_for_them := true ; 2 :
8303: LD_ADDR_EXP 22
8307: PUSH
8308: LD_INT 1
8310: ST_TO_ADDR
8311: GO 8333
8313: LD_INT 2
8315: DOUBLE
8316: EQUAL
8317: IFTRUE 8321
8319: GO 8332
8321: POP
// wait_for_them := false ; end ;
8322: LD_ADDR_EXP 22
8326: PUSH
8327: LD_INT 0
8329: ST_TO_ADDR
8330: GO 8333
8332: POP
// end ; if not wait_for_them or FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 1 then
8333: LD_EXP 22
8337: NOT
8338: PUSH
8339: LD_INT 22
8341: PUSH
8342: LD_INT 1
8344: PUSH
8345: EMPTY
8346: LIST
8347: LIST
8348: PUSH
8349: LD_INT 21
8351: PUSH
8352: LD_INT 1
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: PUSH
8359: EMPTY
8360: LIST
8361: LIST
8362: PPUSH
8363: CALL_OW 69
8367: PUSH
8368: LD_INT 1
8370: EQUAL
8371: OR
8372: IFFALSE 8403
// begin save_group := save_group ^ JMM ;
8374: LD_ADDR_EXP 20
8378: PUSH
8379: LD_EXP 20
8383: PUSH
8384: LD_EXP 25
8388: ADD
8389: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
8390: LD_EXP 25
8394: PPUSH
8395: CALL_OW 64
// EndMission ;
8399: CALL 8924 0 0
// end ; end ; if i = Lisa then
8403: LD_VAR 0 1
8407: PUSH
8408: LD_EXP 28
8412: EQUAL
8413: IFFALSE 8440
// begin save_group := save_group ^ Lisa ;
8415: LD_ADDR_EXP 20
8419: PUSH
8420: LD_EXP 20
8424: PUSH
8425: LD_EXP 28
8429: ADD
8430: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
8431: LD_EXP 28
8435: PPUSH
8436: CALL_OW 64
// end ; if i = Bobby then
8440: LD_VAR 0 1
8444: PUSH
8445: LD_EXP 26
8449: EQUAL
8450: IFFALSE 8477
// begin save_group := save_group ^ Bobby ;
8452: LD_ADDR_EXP 20
8456: PUSH
8457: LD_EXP 20
8461: PUSH
8462: LD_EXP 26
8466: ADD
8467: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
8468: LD_EXP 26
8472: PPUSH
8473: CALL_OW 64
// end ; if i = Cyrus then
8477: LD_VAR 0 1
8481: PUSH
8482: LD_EXP 27
8486: EQUAL
8487: IFFALSE 8514
// begin save_group := save_group ^ Cyrus ;
8489: LD_ADDR_EXP 20
8493: PUSH
8494: LD_EXP 20
8498: PUSH
8499: LD_EXP 27
8503: ADD
8504: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
8505: LD_EXP 27
8509: PPUSH
8510: CALL_OW 64
// end ; if i = Khatam then
8514: LD_VAR 0 1
8518: PUSH
8519: LD_EXP 29
8523: EQUAL
8524: IFFALSE 8551
// begin save_group := save_group ^ Khatam ;
8526: LD_ADDR_EXP 20
8530: PUSH
8531: LD_EXP 20
8535: PUSH
8536: LD_EXP 29
8540: ADD
8541: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
8542: LD_EXP 29
8546: PPUSH
8547: CALL_OW 64
// end ; if i = Jerry then
8551: LD_VAR 0 1
8555: PUSH
8556: LD_EXP 31
8560: EQUAL
8561: IFFALSE 8588
// begin save_group := save_group ^ Jerry ;
8563: LD_ADDR_EXP 20
8567: PUSH
8568: LD_EXP 20
8572: PUSH
8573: LD_EXP 31
8577: ADD
8578: ST_TO_ADDR
// RemoveUnit ( Jerry ) ;
8579: LD_EXP 31
8583: PPUSH
8584: CALL_OW 64
// end ; if i = Brian then
8588: LD_VAR 0 1
8592: PUSH
8593: LD_EXP 30
8597: EQUAL
8598: IFFALSE 8625
// begin save_group := save_group ^ Brian ;
8600: LD_ADDR_EXP 20
8604: PUSH
8605: LD_EXP 20
8609: PUSH
8610: LD_EXP 30
8614: ADD
8615: ST_TO_ADDR
// RemoveUnit ( Brian ) ;
8616: LD_EXP 30
8620: PPUSH
8621: CALL_OW 64
// end ; if i = Lynch then
8625: LD_VAR 0 1
8629: PUSH
8630: LD_EXP 35
8634: EQUAL
8635: IFFALSE 8662
// begin save_group := save_group ^ Lynch ;
8637: LD_ADDR_EXP 20
8641: PUSH
8642: LD_EXP 20
8646: PUSH
8647: LD_EXP 35
8651: ADD
8652: ST_TO_ADDR
// RemoveUnit ( Lynch ) ;
8653: LD_EXP 35
8657: PPUSH
8658: CALL_OW 64
// end ; if i = Turner then
8662: LD_VAR 0 1
8666: PUSH
8667: LD_EXP 37
8671: EQUAL
8672: IFFALSE 8699
// begin save_group := save_group ^ Turner ;
8674: LD_ADDR_EXP 20
8678: PUSH
8679: LD_EXP 20
8683: PUSH
8684: LD_EXP 37
8688: ADD
8689: ST_TO_ADDR
// RemoveUnit ( Turner ) ;
8690: LD_EXP 37
8694: PPUSH
8695: CALL_OW 64
// end ; if i = Jillian then
8699: LD_VAR 0 1
8703: PUSH
8704: LD_EXP 38
8708: EQUAL
8709: IFFALSE 8736
// begin save_group := save_group ^ Jillian ;
8711: LD_ADDR_EXP 20
8715: PUSH
8716: LD_EXP 20
8720: PUSH
8721: LD_EXP 38
8725: ADD
8726: ST_TO_ADDR
// RemoveUnit ( Jillian ) ;
8727: LD_EXP 38
8731: PPUSH
8732: CALL_OW 64
// end ; if i = Walker then
8736: LD_VAR 0 1
8740: PUSH
8741: LD_EXP 36
8745: EQUAL
8746: IFFALSE 8773
// begin save_group := save_group ^ Walker ;
8748: LD_ADDR_EXP 20
8752: PUSH
8753: LD_EXP 20
8757: PUSH
8758: LD_EXP 36
8762: ADD
8763: ST_TO_ADDR
// RemoveUnit ( Walker ) ;
8764: LD_EXP 36
8768: PPUSH
8769: CALL_OW 64
// end ; if i = Frank then
8773: LD_VAR 0 1
8777: PUSH
8778: LD_EXP 39
8782: EQUAL
8783: IFFALSE 8810
// begin save_group := save_group ^ Frank ;
8785: LD_ADDR_EXP 20
8789: PUSH
8790: LD_EXP 20
8794: PUSH
8795: LD_EXP 39
8799: ADD
8800: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
8801: LD_EXP 39
8805: PPUSH
8806: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and not i in save_group then
8810: LD_VAR 0 1
8814: PPUSH
8815: CALL_OW 302
8819: PUSH
8820: LD_VAR 0 1
8824: PPUSH
8825: CALL_OW 247
8829: PUSH
8830: LD_INT 1
8832: EQUAL
8833: AND
8834: PUSH
8835: LD_VAR 0 1
8839: PUSH
8840: LD_EXP 20
8844: IN
8845: NOT
8846: AND
8847: IFFALSE 8874
// begin save_others := save_others ^ i ;
8849: LD_ADDR_EXP 19
8853: PUSH
8854: LD_EXP 19
8858: PUSH
8859: LD_VAR 0 1
8863: ADD
8864: ST_TO_ADDR
// RemoveUnit ( i ) ;
8865: LD_VAR 0 1
8869: PPUSH
8870: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_vehicle then
8874: LD_VAR 0 1
8878: PPUSH
8879: CALL_OW 302
8883: PUSH
8884: LD_VAR 0 1
8888: PPUSH
8889: CALL_OW 247
8893: PUSH
8894: LD_INT 2
8896: EQUAL
8897: AND
8898: IFFALSE 8917
// begin veh_on_meta := true ;
8900: LD_ADDR_EXP 23
8904: PUSH
8905: LD_INT 1
8907: ST_TO_ADDR
// RemoveUnit ( i ) ;
8908: LD_VAR 0 1
8912: PPUSH
8913: CALL_OW 64
// end ; end ;
8917: GO 8181
8919: POP
8920: POP
// end ;
8921: PPOPN 2
8923: END
// export function EndMission ; var counter ; begin
8924: LD_INT 0
8926: PPUSH
8927: PPUSH
// if solar_builded then
8928: LD_EXP 11
8932: IFFALSE 8946
// AddMedal ( Solar1 , 1 ) else
8934: LD_STRING Solar1
8936: PPUSH
8937: LD_INT 1
8939: PPUSH
8940: CALL_OW 101
8944: GO 8957
// AddMedal ( Solar1 , - 1 ) ;
8946: LD_STRING Solar1
8948: PPUSH
8949: LD_INT 1
8951: NEG
8952: PPUSH
8953: CALL_OW 101
// if veh_on_meta then
8957: LD_EXP 23
8961: IFFALSE 8975
// AddMedal ( Solar2 , 1 ) else
8963: LD_STRING Solar2
8965: PPUSH
8966: LD_INT 1
8968: PPUSH
8969: CALL_OW 101
8973: GO 9005
// if solar_builded then
8975: LD_EXP 11
8979: IFFALSE 8994
// AddMedal ( Solar2 , - 1 ) else
8981: LD_STRING Solar2
8983: PPUSH
8984: LD_INT 1
8986: NEG
8987: PPUSH
8988: CALL_OW 101
8992: GO 9005
// AddMedal ( Solar2 , - 2 ) ;
8994: LD_STRING Solar2
8996: PPUSH
8997: LD_INT 2
8999: NEG
9000: PPUSH
9001: CALL_OW 101
// counter := save_group ^ save_others ;
9005: LD_ADDR_VAR 0 2
9009: PUSH
9010: LD_EXP 20
9014: PUSH
9015: LD_EXP 19
9019: ADD
9020: ST_TO_ADDR
// if counter = 10 then
9021: LD_VAR 0 2
9025: PUSH
9026: LD_INT 10
9028: EQUAL
9029: IFFALSE 9043
// AddMedal ( No , 1 ) else
9031: LD_STRING No
9033: PPUSH
9034: LD_INT 1
9036: PPUSH
9037: CALL_OW 101
9041: GO 9087
// if counter < 10 and counter > 6 then
9043: LD_VAR 0 2
9047: PUSH
9048: LD_INT 10
9050: LESS
9051: PUSH
9052: LD_VAR 0 2
9056: PUSH
9057: LD_INT 6
9059: GREATER
9060: AND
9061: IFFALSE 9076
// AddMedal ( No , - 1 ) else
9063: LD_STRING No
9065: PPUSH
9066: LD_INT 1
9068: NEG
9069: PPUSH
9070: CALL_OW 101
9074: GO 9087
// AddMedal ( UpTo4 , - 1 ) ;
9076: LD_STRING UpTo4
9078: PPUSH
9079: LD_INT 1
9081: NEG
9082: PPUSH
9083: CALL_OW 101
// GiveMedals ( MAIN ) ;
9087: LD_STRING MAIN
9089: PPUSH
9090: CALL_OW 102
// RewardPeople ( save_group ^ save_others ) ;
9094: LD_EXP 20
9098: PUSH
9099: LD_EXP 19
9103: ADD
9104: PPUSH
9105: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
9109: LD_EXP 25
9113: PPUSH
9114: LD_STRING JMM
9116: PPUSH
9117: CALL_OW 38
// if Bobby in save_group then
9121: LD_EXP 26
9125: PUSH
9126: LD_EXP 20
9130: IN
9131: IFFALSE 9145
// SaveCharacters ( Bobby , Bobby ) ;
9133: LD_EXP 26
9137: PPUSH
9138: LD_STRING Bobby
9140: PPUSH
9141: CALL_OW 38
// if Cyrus in save_group then
9145: LD_EXP 27
9149: PUSH
9150: LD_EXP 20
9154: IN
9155: IFFALSE 9169
// SaveCharacters ( Cyrus , Cyrus ) ;
9157: LD_EXP 27
9161: PPUSH
9162: LD_STRING Cyrus
9164: PPUSH
9165: CALL_OW 38
// if Lisa in save_group then
9169: LD_EXP 28
9173: PUSH
9174: LD_EXP 20
9178: IN
9179: IFFALSE 9193
// SaveCharacters ( Lisa , Lisa ) ;
9181: LD_EXP 28
9185: PPUSH
9186: LD_STRING Lisa
9188: PPUSH
9189: CALL_OW 38
// if Frank in save_group then
9193: LD_EXP 39
9197: PUSH
9198: LD_EXP 20
9202: IN
9203: IFFALSE 9217
// SaveCharacters ( Frank , Frank ) ;
9205: LD_EXP 39
9209: PPUSH
9210: LD_STRING Frank
9212: PPUSH
9213: CALL_OW 38
// if Khatam in save_group then
9217: LD_EXP 29
9221: PUSH
9222: LD_EXP 20
9226: IN
9227: IFFALSE 9241
// SaveCharacters ( Khatam , Khatam ) ;
9229: LD_EXP 29
9233: PPUSH
9234: LD_STRING Khatam
9236: PPUSH
9237: CALL_OW 38
// if save_others then
9241: LD_EXP 19
9245: IFFALSE 9259
// SaveCharacters ( save_others , 03_others ) ;
9247: LD_EXP 19
9251: PPUSH
9252: LD_STRING 03_others
9254: PPUSH
9255: CALL_OW 38
// YouWin ;
9259: CALL_OW 103
// end ; end_of_file
9263: LD_VAR 0 1
9267: RET
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
9268: LD_EXP 6
9272: IFFALSE 10303
9274: GO 9276
9276: DISABLE
9277: LD_INT 0
9279: PPUSH
9280: PPUSH
9281: PPUSH
9282: PPUSH
9283: PPUSH
9284: PPUSH
9285: PPUSH
9286: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
9287: LD_EXP 32
9291: PUSH
9292: LD_EXP 33
9296: ADD
9297: PUSH
9298: LD_EXP 4
9302: ADD
9303: PPUSH
9304: LD_INT 250
9306: PPUSH
9307: LD_INT 120
9309: PPUSH
9310: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
9314: LD_ADDR_VAR 0 2
9318: PUSH
9319: LD_EXP 4
9323: PPUSH
9324: LD_INT 25
9326: PUSH
9327: LD_INT 2
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: PPUSH
9334: CALL_OW 72
9338: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
9339: LD_ADDR_VAR 0 3
9343: PUSH
9344: LD_EXP 4
9348: PPUSH
9349: LD_INT 21
9351: PUSH
9352: LD_INT 1
9354: PUSH
9355: EMPTY
9356: LIST
9357: LIST
9358: PPUSH
9359: CALL_OW 72
9363: ST_TO_ADDR
// if not has_eng then
9364: LD_VAR 0 2
9368: NOT
9369: IFFALSE 9452
// begin uc_side := 4 ;
9371: LD_ADDR_OWVAR 20
9375: PUSH
9376: LD_INT 4
9378: ST_TO_ADDR
// uc_nation := 1 ;
9379: LD_ADDR_OWVAR 21
9383: PUSH
9384: LD_INT 1
9386: ST_TO_ADDR
// bc_type := b_depot ;
9387: LD_ADDR_OWVAR 42
9391: PUSH
9392: LD_INT 0
9394: ST_TO_ADDR
// bc_level := 2 ;
9395: LD_ADDR_OWVAR 43
9399: PUSH
9400: LD_INT 2
9402: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
9403: LD_ADDR_VAR 0 4
9407: PUSH
9408: LD_INT 264
9410: PPUSH
9411: LD_INT 120
9413: PPUSH
9414: LD_INT 4
9416: PPUSH
9417: CALL_OW 47
9421: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
9422: LD_INT 264
9424: PPUSH
9425: LD_INT 120
9427: PPUSH
9428: LD_INT 4
9430: PPUSH
9431: LD_INT 10
9433: NEG
9434: PPUSH
9435: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
9439: LD_INT 264
9441: PPUSH
9442: LD_INT 120
9444: PPUSH
9445: LD_INT 4
9447: PPUSH
9448: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
9452: LD_INT 35
9454: PPUSH
9455: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
9459: LD_EXP 32
9463: PPUSH
9464: LD_INT 10
9466: PPUSH
9467: CALL_OW 308
9471: IFFALSE 9452
// if has_eng and not dep then
9473: LD_VAR 0 2
9477: PUSH
9478: LD_VAR 0 4
9482: NOT
9483: AND
9484: IFFALSE 9598
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
9486: LD_VAR 0 2
9490: PPUSH
9491: LD_INT 0
9493: PPUSH
9494: LD_INT 264
9496: PPUSH
9497: LD_INT 120
9499: PPUSH
9500: LD_INT 4
9502: PPUSH
9503: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
9507: LD_INT 35
9509: PPUSH
9510: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
9514: LD_INT 22
9516: PUSH
9517: LD_INT 4
9519: PUSH
9520: EMPTY
9521: LIST
9522: LIST
9523: PUSH
9524: LD_INT 30
9526: PUSH
9527: LD_INT 0
9529: PUSH
9530: EMPTY
9531: LIST
9532: LIST
9533: PUSH
9534: LD_INT 3
9536: PUSH
9537: LD_INT 57
9539: PUSH
9540: EMPTY
9541: LIST
9542: PUSH
9543: EMPTY
9544: LIST
9545: LIST
9546: PUSH
9547: EMPTY
9548: LIST
9549: LIST
9550: LIST
9551: PPUSH
9552: CALL_OW 69
9556: IFFALSE 9507
// dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
9558: LD_ADDR_VAR 0 4
9562: PUSH
9563: LD_INT 22
9565: PUSH
9566: LD_INT 4
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: PUSH
9573: LD_INT 30
9575: PUSH
9576: LD_INT 0
9578: PUSH
9579: EMPTY
9580: LIST
9581: LIST
9582: PUSH
9583: EMPTY
9584: LIST
9585: LIST
9586: PPUSH
9587: CALL_OW 69
9591: PUSH
9592: LD_INT 1
9594: ARRAY
9595: ST_TO_ADDR
// end else
9596: GO 9715
// begin SetSide ( dep , 4 ) ;
9598: LD_VAR 0 4
9602: PPUSH
9603: LD_INT 4
9605: PPUSH
9606: CALL_OW 235
// for i = 1 to 3 do
9610: LD_ADDR_VAR 0 1
9614: PUSH
9615: DOUBLE
9616: LD_INT 1
9618: DEC
9619: ST_TO_ADDR
9620: LD_INT 3
9622: PUSH
9623: FOR_TO
9624: IFFALSE 9681
// begin ComEnterUnit ( filter [ i ] , dep ) ;
9626: LD_VAR 0 3
9630: PUSH
9631: LD_VAR 0 1
9635: ARRAY
9636: PPUSH
9637: LD_VAR 0 4
9641: PPUSH
9642: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
9646: LD_VAR 0 3
9650: PUSH
9651: LD_VAR 0 1
9655: ARRAY
9656: PPUSH
9657: LD_INT 2
9659: PPUSH
9660: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
9664: LD_VAR 0 3
9668: PUSH
9669: LD_VAR 0 1
9673: ARRAY
9674: PPUSH
9675: CALL_OW 182
// end ;
9679: GO 9623
9681: POP
9682: POP
// repeat wait ( 0 0$01 ) ;
9683: LD_INT 35
9685: PPUSH
9686: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
9690: LD_VAR 0 3
9694: PPUSH
9695: LD_INT 25
9697: PUSH
9698: LD_INT 2
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: PPUSH
9705: CALL_OW 72
9709: PUSH
9710: LD_INT 3
9712: EQUAL
9713: IFFALSE 9683
// end ; ComEnterUnit ( Bierezov , dep ) ;
9715: LD_EXP 33
9719: PPUSH
9720: LD_VAR 0 4
9724: PPUSH
9725: CALL_OW 120
// if IsInUnit ( Cornel ) then
9729: LD_EXP 32
9733: PPUSH
9734: CALL_OW 310
9738: IFFALSE 9821
// begin cargo := IsInUnit ( Cornel ) ;
9740: LD_ADDR_VAR 0 7
9744: PUSH
9745: LD_EXP 32
9749: PPUSH
9750: CALL_OW 310
9754: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
9755: LD_VAR 0 7
9759: PPUSH
9760: LD_INT 1
9762: PPUSH
9763: CALL_OW 289
9767: IFFALSE 9783
// ComGive ( Cornel , dep ) ;
9769: LD_EXP 32
9773: PPUSH
9774: LD_VAR 0 4
9778: PPUSH
9779: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
9783: LD_EXP 32
9787: PPUSH
9788: LD_INT 235
9790: PPUSH
9791: LD_INT 122
9793: PPUSH
9794: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
9798: LD_EXP 32
9802: PPUSH
9803: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
9807: LD_EXP 32
9811: PPUSH
9812: LD_VAR 0 4
9816: PPUSH
9817: CALL_OW 180
// end ; has_eng := UnitFilter ( filter , [ f_class , 2 ] ) ;
9821: LD_ADDR_VAR 0 2
9825: PUSH
9826: LD_VAR 0 3
9830: PPUSH
9831: LD_INT 25
9833: PUSH
9834: LD_INT 2
9836: PUSH
9837: EMPTY
9838: LIST
9839: LIST
9840: PPUSH
9841: CALL_OW 72
9845: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
9846: LD_INT 35
9848: PPUSH
9849: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
9853: LD_ADDR_VAR 0 6
9857: PUSH
9858: LD_INT 10
9860: PPUSH
9861: CALL_OW 435
9865: ST_TO_ADDR
// if crates then
9866: LD_VAR 0 6
9870: IFFALSE 9899
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
9872: LD_VAR 0 2
9876: PPUSH
9877: LD_VAR 0 6
9881: PUSH
9882: LD_INT 1
9884: ARRAY
9885: PPUSH
9886: LD_VAR 0 6
9890: PUSH
9891: LD_INT 2
9893: ARRAY
9894: PPUSH
9895: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
9899: LD_VAR 0 4
9903: PPUSH
9904: CALL_OW 274
9908: PPUSH
9909: LD_INT 1
9911: PPUSH
9912: CALL_OW 275
9916: PUSH
9917: LD_INT 40
9919: GREATEREQUAL
9920: IFFALSE 9846
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
9922: LD_ADDR_VAR 0 5
9926: PUSH
9927: LD_INT 4
9929: PUSH
9930: LD_INT 256
9932: PUSH
9933: LD_INT 111
9935: PUSH
9936: LD_INT 2
9938: PUSH
9939: EMPTY
9940: LIST
9941: LIST
9942: LIST
9943: LIST
9944: PUSH
9945: LD_INT 31
9947: PUSH
9948: LD_INT 243
9950: PUSH
9951: LD_INT 112
9953: PUSH
9954: LD_INT 2
9956: PUSH
9957: EMPTY
9958: LIST
9959: LIST
9960: LIST
9961: LIST
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: ST_TO_ADDR
// for i in blist do
9967: LD_ADDR_VAR 0 1
9971: PUSH
9972: LD_VAR 0 5
9976: PUSH
9977: FOR_IN
9978: IFFALSE 10027
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
9980: LD_VAR 0 2
9984: PPUSH
9985: LD_VAR 0 1
9989: PUSH
9990: LD_INT 1
9992: ARRAY
9993: PPUSH
9994: LD_VAR 0 1
9998: PUSH
9999: LD_INT 2
10001: ARRAY
10002: PPUSH
10003: LD_VAR 0 1
10007: PUSH
10008: LD_INT 3
10010: ARRAY
10011: PPUSH
10012: LD_VAR 0 1
10016: PUSH
10017: LD_INT 4
10019: ARRAY
10020: PPUSH
10021: CALL_OW 205
10025: GO 9977
10027: POP
10028: POP
// repeat wait ( 0 0$01 ) ;
10029: LD_INT 35
10031: PPUSH
10032: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
10036: LD_INT 22
10038: PUSH
10039: LD_INT 4
10041: PUSH
10042: EMPTY
10043: LIST
10044: LIST
10045: PUSH
10046: LD_INT 30
10048: PUSH
10049: LD_INT 4
10051: PUSH
10052: EMPTY
10053: LIST
10054: LIST
10055: PUSH
10056: LD_INT 3
10058: PUSH
10059: LD_INT 57
10061: PUSH
10062: EMPTY
10063: LIST
10064: PUSH
10065: EMPTY
10066: LIST
10067: LIST
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: LIST
10073: PPUSH
10074: CALL_OW 69
10078: IFFALSE 10029
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
10080: LD_VAR 0 3
10084: PUSH
10085: LD_VAR 0 2
10089: DIFF
10090: PPUSH
10091: LD_INT 22
10093: PUSH
10094: LD_INT 4
10096: PUSH
10097: EMPTY
10098: LIST
10099: LIST
10100: PUSH
10101: LD_INT 30
10103: PUSH
10104: LD_INT 4
10106: PUSH
10107: EMPTY
10108: LIST
10109: LIST
10110: PUSH
10111: EMPTY
10112: LIST
10113: LIST
10114: PPUSH
10115: CALL_OW 69
10119: PUSH
10120: LD_INT 1
10122: ARRAY
10123: PPUSH
10124: CALL_OW 180
// repeat wait ( 0 0$01 ) ;
10128: LD_INT 35
10130: PPUSH
10131: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
10135: LD_INT 22
10137: PUSH
10138: LD_INT 4
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: LD_INT 30
10147: PUSH
10148: LD_INT 31
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: PUSH
10155: LD_INT 3
10157: PUSH
10158: LD_INT 57
10160: PUSH
10161: EMPTY
10162: LIST
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: PPUSH
10173: CALL_OW 69
10177: IFFALSE 10128
// sol := filter diff has_eng ;
10179: LD_ADDR_VAR 0 8
10183: PUSH
10184: LD_VAR 0 3
10188: PUSH
10189: LD_VAR 0 2
10193: DIFF
10194: ST_TO_ADDR
// if GetClass ( sol [ 1 ] ) > 1 then
10195: LD_VAR 0 8
10199: PUSH
10200: LD_INT 1
10202: ARRAY
10203: PPUSH
10204: CALL_OW 257
10208: PUSH
10209: LD_INT 1
10211: GREATER
10212: IFFALSE 10230
// SetClass ( sol [ 1 ] , 1 ) ;
10214: LD_VAR 0 8
10218: PUSH
10219: LD_INT 1
10221: ARRAY
10222: PPUSH
10223: LD_INT 1
10225: PPUSH
10226: CALL_OW 336
// ComExitBuilding ( sol [ 1 ] ) ;
10230: LD_VAR 0 8
10234: PUSH
10235: LD_INT 1
10237: ARRAY
10238: PPUSH
10239: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
10243: LD_VAR 0 8
10247: PUSH
10248: LD_INT 1
10250: ARRAY
10251: PPUSH
10252: LD_INT 22
10254: PUSH
10255: LD_INT 4
10257: PUSH
10258: EMPTY
10259: LIST
10260: LIST
10261: PUSH
10262: LD_INT 30
10264: PUSH
10265: LD_INT 31
10267: PUSH
10268: EMPTY
10269: LIST
10270: LIST
10271: PUSH
10272: EMPTY
10273: LIST
10274: LIST
10275: PPUSH
10276: CALL_OW 69
10280: PUSH
10281: LD_INT 1
10283: ARRAY
10284: PPUSH
10285: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
10289: LD_VAR 0 2
10293: PPUSH
10294: LD_VAR 0 4
10298: PPUSH
10299: CALL_OW 112
// end ;
10303: PPOPN 8
10305: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
10306: LD_EXP 9
10310: IFFALSE 10630
10312: GO 10314
10314: DISABLE
10315: LD_INT 0
10317: PPUSH
10318: PPUSH
10319: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
10320: LD_ADDR_VAR 0 2
10324: PUSH
10325: LD_INT 22
10327: PUSH
10328: LD_INT 4
10330: PUSH
10331: EMPTY
10332: LIST
10333: LIST
10334: PUSH
10335: LD_INT 30
10337: PUSH
10338: LD_INT 4
10340: PUSH
10341: EMPTY
10342: LIST
10343: LIST
10344: PUSH
10345: EMPTY
10346: LIST
10347: LIST
10348: PPUSH
10349: CALL_OW 69
10353: PUSH
10354: LD_INT 1
10356: ARRAY
10357: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
10358: LD_EXP 4
10362: PPUSH
10363: CALL_OW 122
// for i in cornel_units do
10367: LD_ADDR_VAR 0 1
10371: PUSH
10372: LD_EXP 4
10376: PUSH
10377: FOR_IN
10378: IFFALSE 10432
// if GetClass ( i ) = 2 then
10380: LD_VAR 0 1
10384: PPUSH
10385: CALL_OW 257
10389: PUSH
10390: LD_INT 2
10392: EQUAL
10393: IFFALSE 10430
// begin ComEnterUnit ( i , arm ) ;
10395: LD_VAR 0 1
10399: PPUSH
10400: LD_VAR 0 2
10404: PPUSH
10405: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
10409: LD_VAR 0 1
10413: PPUSH
10414: LD_INT 1
10416: PPUSH
10417: CALL_OW 183
// AddComExitBuilding ( i ) ;
10421: LD_VAR 0 1
10425: PPUSH
10426: CALL_OW 182
// end ;
10430: GO 10377
10432: POP
10433: POP
// Wait ( 1 1$00 ) ;
10434: LD_INT 2100
10436: PPUSH
10437: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
10441: LD_ADDR_VAR 0 3
10445: PUSH
10446: LD_EXP 32
10450: PUSH
10451: LD_EXP 33
10455: ADD
10456: PUSH
10457: LD_EXP 4
10461: ADD
10462: PUSH
10463: LD_EXP 4
10467: PPUSH
10468: LD_INT 21
10470: PUSH
10471: LD_INT 2
10473: PUSH
10474: EMPTY
10475: LIST
10476: LIST
10477: PPUSH
10478: CALL_OW 72
10482: DIFF
10483: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
10484: LD_VAR 0 3
10488: PPUSH
10489: LD_INT 248
10491: PPUSH
10492: LD_INT 85
10494: PPUSH
10495: CALL_OW 111
// AddComHold ( filter ) ;
10499: LD_VAR 0 3
10503: PPUSH
10504: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
10508: LD_INT 35
10510: PPUSH
10511: CALL_OW 67
// until cornel_attack ;
10515: LD_EXP 7
10519: IFFALSE 10508
// ComAgressiveMove ( filter , 209 , 63 ) ;
10521: LD_VAR 0 3
10525: PPUSH
10526: LD_INT 209
10528: PPUSH
10529: LD_INT 63
10531: PPUSH
10532: CALL_OW 114
// if Bierezov then
10536: LD_EXP 33
10540: IFFALSE 10630
// begin filter := filter diff Bierezov ;
10542: LD_ADDR_VAR 0 3
10546: PUSH
10547: LD_VAR 0 3
10551: PUSH
10552: LD_EXP 33
10556: DIFF
10557: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
10558: LD_EXP 33
10562: PPUSH
10563: LD_INT 6
10565: PPUSH
10566: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
10570: LD_EXP 33
10574: PPUSH
10575: LD_INT 235
10577: PPUSH
10578: LD_INT 60
10580: PPUSH
10581: CALL_OW 111
// AddComHold ( Bierezov ) ;
10585: LD_EXP 33
10589: PPUSH
10590: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
10594: LD_EXP 33
10598: PPUSH
10599: LD_INT 350
10601: PPUSH
10602: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
10606: LD_EXP 33
10610: PPUSH
10611: LD_INT 198
10613: PPUSH
10614: LD_INT 28
10616: PPUSH
10617: CALL_OW 171
// AddComHold ( Bierezov ) ;
10621: LD_EXP 33
10625: PPUSH
10626: CALL_OW 200
// end ; end ; end_of_file
10630: PPOPN 3
10632: END
// every 0 0$01 trigger ru_patrol do var un , i , j , enemy ;
10633: LD_EXP 41
10637: IFFALSE 11087
10639: GO 10641
10641: DISABLE
10642: LD_INT 0
10644: PPUSH
10645: PPUSH
10646: PPUSH
10647: PPUSH
// begin enable ;
10648: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
10649: LD_ADDR_VAR 0 4
10653: PUSH
10654: LD_INT 81
10656: PUSH
10657: LD_INT 3
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: PPUSH
10664: CALL_OW 69
10668: ST_TO_ADDR
// for i = 1 to ru_patrol do
10669: LD_ADDR_VAR 0 2
10673: PUSH
10674: DOUBLE
10675: LD_INT 1
10677: DEC
10678: ST_TO_ADDR
10679: LD_EXP 41
10683: PUSH
10684: FOR_TO
10685: IFFALSE 11085
// begin un := ru_patrol [ i ] ;
10687: LD_ADDR_VAR 0 1
10691: PUSH
10692: LD_EXP 41
10696: PUSH
10697: LD_VAR 0 2
10701: ARRAY
10702: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
10703: LD_VAR 0 1
10707: PPUSH
10708: LD_INT 13
10710: PPUSH
10711: CALL_OW 308
10715: IFFALSE 10820
// begin if not ru_alert then
10717: LD_EXP 45
10721: NOT
10722: IFFALSE 10732
// ru_alert := true ;
10724: LD_ADDR_EXP 45
10728: PUSH
10729: LD_INT 1
10731: ST_TO_ADDR
// if not See ( 1 , un ) then
10732: LD_INT 1
10734: PPUSH
10735: LD_VAR 0 1
10739: PPUSH
10740: CALL_OW 292
10744: NOT
10745: IFFALSE 10759
// SetLives ( un , 1000 ) ;
10747: LD_VAR 0 1
10751: PPUSH
10752: LD_INT 1000
10754: PPUSH
10755: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
10759: LD_ADDR_EXP 41
10763: PUSH
10764: LD_EXP 41
10768: PUSH
10769: LD_VAR 0 1
10773: DIFF
10774: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
10775: LD_VAR 0 1
10779: PPUSH
10780: LD_INT 22
10782: PUSH
10783: LD_INT 3
10785: PUSH
10786: EMPTY
10787: LIST
10788: LIST
10789: PUSH
10790: LD_INT 30
10792: PUSH
10793: LD_INT 4
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: PUSH
10800: EMPTY
10801: LIST
10802: LIST
10803: PPUSH
10804: CALL_OW 69
10808: PPUSH
10809: CALL 930 0 1
10813: PPUSH
10814: CALL_OW 120
// continue ;
10818: GO 10684
// end ; if IsOk ( un ) and not HasTask ( un ) then
10820: LD_VAR 0 1
10824: PPUSH
10825: CALL_OW 302
10829: PUSH
10830: LD_VAR 0 1
10834: PPUSH
10835: CALL_OW 314
10839: NOT
10840: AND
10841: IFFALSE 10934
// begin for j = 1 to ru_firepoints_south [ i ] do
10843: LD_ADDR_VAR 0 3
10847: PUSH
10848: DOUBLE
10849: LD_INT 1
10851: DEC
10852: ST_TO_ADDR
10853: LD_EXP 44
10857: PUSH
10858: LD_VAR 0 2
10862: ARRAY
10863: PUSH
10864: FOR_TO
10865: IFFALSE 10932
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
10867: LD_VAR 0 1
10871: PPUSH
10872: LD_EXP 44
10876: PUSH
10877: LD_VAR 0 2
10881: ARRAY
10882: PUSH
10883: LD_VAR 0 3
10887: ARRAY
10888: PUSH
10889: LD_INT 1
10891: ARRAY
10892: PPUSH
10893: LD_EXP 44
10897: PUSH
10898: LD_VAR 0 2
10902: ARRAY
10903: PUSH
10904: LD_VAR 0 3
10908: ARRAY
10909: PUSH
10910: LD_INT 2
10912: ARRAY
10913: PPUSH
10914: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
10918: LD_VAR 0 1
10922: PPUSH
10923: LD_INT 70
10925: PPUSH
10926: CALL_OW 202
// end ;
10930: GO 10864
10932: POP
10933: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
10934: LD_VAR 0 1
10938: PPUSH
10939: CALL_OW 256
10943: PUSH
10944: LD_INT 700
10946: LESS
10947: PUSH
10948: LD_VAR 0 1
10952: PPUSH
10953: LD_INT 13
10955: PPUSH
10956: CALL_OW 308
10960: NOT
10961: AND
10962: IFFALSE 11014
// begin ComMoveToArea ( un , retreatArea ) ;
10964: LD_VAR 0 1
10968: PPUSH
10969: LD_INT 13
10971: PPUSH
10972: CALL_OW 113
// if not ru_alert_xy then
10976: LD_EXP 46
10980: NOT
10981: IFFALSE 11012
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
10983: LD_ADDR_EXP 46
10987: PUSH
10988: LD_VAR 0 1
10992: PPUSH
10993: CALL_OW 250
10997: PUSH
10998: LD_VAR 0 1
11002: PPUSH
11003: CALL_OW 251
11007: PUSH
11008: EMPTY
11009: LIST
11010: LIST
11011: ST_TO_ADDR
// end else
11012: GO 11083
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
11014: LD_VAR 0 1
11018: PPUSH
11019: LD_VAR 0 4
11023: PPUSH
11024: LD_VAR 0 1
11028: PPUSH
11029: CALL_OW 74
11033: PPUSH
11034: CALL_OW 296
11038: PUSH
11039: LD_INT 9
11041: LESS
11042: PUSH
11043: LD_VAR 0 1
11047: PPUSH
11048: CALL_OW 256
11052: PUSH
11053: LD_INT 500
11055: GREATER
11056: AND
11057: IFFALSE 11083
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
11059: LD_VAR 0 1
11063: PPUSH
11064: LD_VAR 0 4
11068: PPUSH
11069: LD_VAR 0 1
11073: PPUSH
11074: CALL_OW 74
11078: PPUSH
11079: CALL_OW 115
// end ;
11083: GO 10684
11085: POP
11086: POP
// end ;
11087: PPOPN 4
11089: END
// every 0 0$01 trigger ru_alert and ru_alert_xy do var i ;
11090: LD_EXP 45
11094: PUSH
11095: LD_EXP 46
11099: AND
11100: IFFALSE 11224
11102: GO 11104
11104: DISABLE
11105: LD_INT 0
11107: PPUSH
// begin enable ;
11108: ENABLE
// if not ru_vehicles then
11109: LD_EXP 43
11113: NOT
11114: IFFALSE 11118
// exit ;
11116: GO 11224
// if ru_vehicles then
11118: LD_EXP 43
11122: IFFALSE 11224
// begin for i in ru_vehicles do
11124: LD_ADDR_VAR 0 1
11128: PUSH
11129: LD_EXP 43
11133: PUSH
11134: FOR_IN
11135: IFFALSE 11222
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
11137: LD_VAR 0 1
11141: PPUSH
11142: CALL_OW 314
11146: NOT
11147: PUSH
11148: LD_VAR 0 1
11152: PPUSH
11153: CALL_OW 302
11157: AND
11158: PUSH
11159: LD_VAR 0 1
11163: PPUSH
11164: LD_EXP 46
11168: PUSH
11169: LD_INT 1
11171: ARRAY
11172: PPUSH
11173: LD_EXP 46
11177: PUSH
11178: LD_INT 2
11180: ARRAY
11181: PPUSH
11182: CALL_OW 297
11186: PUSH
11187: LD_INT 10
11189: GREATER
11190: AND
11191: IFFALSE 11220
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
11193: LD_VAR 0 1
11197: PPUSH
11198: LD_EXP 46
11202: PUSH
11203: LD_INT 1
11205: ARRAY
11206: PPUSH
11207: LD_EXP 46
11211: PUSH
11212: LD_INT 2
11214: ARRAY
11215: PPUSH
11216: CALL_OW 114
11220: GO 11134
11222: POP
11223: POP
// end ; end ;
11224: PPOPN 1
11226: END
// every 3 3$00 trigger ru_alert_xy and ru_alert do var i ;
11227: LD_EXP 46
11231: PUSH
11232: LD_EXP 45
11236: AND
11237: IFFALSE 11332
11239: GO 11241
11241: DISABLE
11242: LD_INT 0
11244: PPUSH
// begin enable ;
11245: ENABLE
// ru_alert_xy := false ;
11246: LD_ADDR_EXP 46
11250: PUSH
11251: LD_INT 0
11253: ST_TO_ADDR
// ru_alert := false ;
11254: LD_ADDR_EXP 45
11258: PUSH
11259: LD_INT 0
11261: ST_TO_ADDR
// if ru_vehicles then
11262: LD_EXP 43
11266: IFFALSE 11332
// for i in ru_vehicles do
11268: LD_ADDR_VAR 0 1
11272: PUSH
11273: LD_EXP 43
11277: PUSH
11278: FOR_IN
11279: IFFALSE 11330
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
11281: LD_VAR 0 1
11285: PPUSH
11286: CALL_OW 302
11290: PUSH
11291: LD_VAR 0 1
11295: PPUSH
11296: LD_INT 89
11298: PPUSH
11299: LD_INT 36
11301: PPUSH
11302: CALL_OW 297
11306: PUSH
11307: LD_INT 10
11309: GREATER
11310: AND
11311: IFFALSE 11328
// ComMoveXY ( i , 89 , 36 ) ;
11313: LD_VAR 0 1
11317: PPUSH
11318: LD_INT 89
11320: PPUSH
11321: LD_INT 36
11323: PPUSH
11324: CALL_OW 111
11328: GO 11278
11330: POP
11331: POP
// end ; end_of_file
11332: PPOPN 1
11334: END
// every 0 0$50 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
11335: LD_EXP 3
11339: PUSH
11340: LD_EXP 7
11344: NOT
11345: AND
11346: PUSH
11347: LD_EXP 17
11351: AND
11352: IFFALSE 11464
11354: GO 11356
11356: DISABLE
11357: LD_INT 0
11359: PPUSH
// begin enable ;
11360: ENABLE
// crates_counter := crates_counter - 50 ;
11361: LD_ADDR_EXP 17
11365: PUSH
11366: LD_EXP 17
11370: PUSH
11371: LD_INT 50
11373: MINUS
11374: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
11375: LD_INT 8
11377: PPUSH
11378: LD_INT 2
11380: PPUSH
11381: LD_INT 5
11383: PPUSH
11384: CALL_OW 12
11388: PPUSH
11389: LD_INT 1
11391: PPUSH
11392: CALL_OW 55
// Wait ( Rand ( 0 0$11 , 0 0$37 ) ) ;
11396: LD_INT 385
11398: PPUSH
11399: LD_INT 1295
11401: PPUSH
11402: CALL_OW 12
11406: PPUSH
11407: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
11411: LD_ADDR_VAR 0 1
11415: PUSH
11416: LD_INT 1
11418: PPUSH
11419: LD_OWVAR 67
11423: PUSH
11424: LD_INT 2
11426: PLUS
11427: PPUSH
11428: CALL_OW 12
11432: ST_TO_ADDR
// if r < 3 then
11433: LD_VAR 0 1
11437: PUSH
11438: LD_INT 3
11440: LESS
11441: IFFALSE 11464
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
11443: LD_INT 4
11445: PPUSH
11446: LD_INT 1
11448: PPUSH
11449: LD_INT 5
11451: PPUSH
11452: CALL_OW 12
11456: PPUSH
11457: LD_INT 1
11459: PPUSH
11460: CALL_OW 55
// end ;
11464: PPOPN 1
11466: END
// every 0 0$01 trigger cornel_active do
11467: LD_EXP 6
11471: IFFALSE 11560
11473: GO 11475
11475: DISABLE
// begin Wait ( 0 0$03 ) ;
11476: LD_INT 105
11478: PPUSH
11479: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
11483: LD_INT 2
11485: PPUSH
11486: LD_INT 5
11488: PPUSH
11489: CALL_OW 12
11493: PPUSH
11494: LD_INT 10
11496: PPUSH
11497: LD_INT 1
11499: PPUSH
11500: CALL_OW 55
// Wait ( 0 0$13 ) ;
11504: LD_INT 455
11506: PPUSH
11507: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
11511: LD_INT 2
11513: PPUSH
11514: LD_INT 5
11516: PPUSH
11517: CALL_OW 12
11521: PPUSH
11522: LD_INT 10
11524: PPUSH
11525: LD_INT 1
11527: PPUSH
11528: CALL_OW 55
// Wait ( 0 0$16 ) ;
11532: LD_INT 560
11534: PPUSH
11535: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
11539: LD_INT 2
11541: PPUSH
11542: LD_INT 5
11544: PPUSH
11545: CALL_OW 12
11549: PPUSH
11550: LD_INT 10
11552: PPUSH
11553: LD_INT 1
11555: PPUSH
11556: CALL_OW 55
// end ; end_of_file
11560: END
// every 0 0$01 trigger cornel_prepared do
11561: LD_EXP 9
11565: IFFALSE 11624
11567: GO 11569
11569: DISABLE
// begin enable ;
11570: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
11571: LD_ADDR_OWVAR 47
11575: PUSH
11576: LD_STRING #Am03-1
11578: PUSH
11579: LD_EXP 8
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
11588: LD_ADDR_EXP 8
11592: PUSH
11593: LD_EXP 8
11597: PPUSH
11598: LD_STRING -
11600: PPUSH
11601: CALL 1000 0 2
11605: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
11606: LD_EXP 8
11610: PUSH
11611: LD_INT 0
11613: EQUAL
11614: IFFALSE 11624
// begin Display_Strings := [ ] ;
11616: LD_ADDR_OWVAR 47
11620: PUSH
11621: EMPTY
11622: ST_TO_ADDR
// disable ;
11623: DISABLE
// end ; end ;
11624: END
// every 0 0$01 trigger debug and debug_strings do
11625: LD_EXP 1
11629: PUSH
11630: LD_OWVAR 48
11634: AND
11635: IFFALSE 11651
11637: GO 11639
11639: DISABLE
// begin enable ;
11640: ENABLE
// Display_Strings := debug_strings ;
11641: LD_ADDR_OWVAR 47
11645: PUSH
11646: LD_OWVAR 48
11650: ST_TO_ADDR
// end ; end_of_file
11651: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
11652: LD_VAR 0 1
11656: PPUSH
11657: CALL_OW 255
11661: PUSH
11662: LD_INT 1
11664: EQUAL
11665: PUSH
11666: LD_EXP 11
11670: NOT
11671: AND
11672: IFFALSE 11682
// solar_builded := true ;
11674: LD_ADDR_EXP 11
11678: PUSH
11679: LD_INT 1
11681: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
11682: LD_VAR 0 1
11686: PPUSH
11687: CALL_OW 255
11691: PUSH
11692: LD_INT 1
11694: EQUAL
11695: PUSH
11696: LD_EXP 24
11700: AND
11701: IFFALSE 11734
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
11703: LD_ADDR_EXP 24
11707: PUSH
11708: LD_EXP 24
11712: PUSH
11713: LD_INT 1750
11715: PUSH
11716: LD_INT 1400
11718: PUSH
11719: LD_INT 1225
11721: PUSH
11722: EMPTY
11723: LIST
11724: LIST
11725: LIST
11726: PUSH
11727: LD_OWVAR 67
11731: ARRAY
11732: PLUS
11733: ST_TO_ADDR
// end ;
11734: PPOPN 2
11736: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
11737: LD_VAR 0 1
11741: PUSH
11742: LD_EXP 41
11746: IN
11747: IFFALSE 11765
// ru_patrol := ru_patrol diff un ;
11749: LD_ADDR_EXP 41
11753: PUSH
11754: LD_EXP 41
11758: PUSH
11759: LD_VAR 0 1
11763: DIFF
11764: ST_TO_ADDR
// if un in ru_forest then
11765: LD_VAR 0 1
11769: PUSH
11770: LD_EXP 42
11774: IN
11775: IFFALSE 11793
// ru_forest := ru_forest diff un ;
11777: LD_ADDR_EXP 42
11781: PUSH
11782: LD_EXP 42
11786: PUSH
11787: LD_VAR 0 1
11791: DIFF
11792: ST_TO_ADDR
// if un in ru_vehicles then
11793: LD_VAR 0 1
11797: PUSH
11798: LD_EXP 43
11802: IN
11803: IFFALSE 11821
// ru_vehicles := ru_vehicles diff un ;
11805: LD_ADDR_EXP 43
11809: PUSH
11810: LD_EXP 43
11814: PUSH
11815: LD_VAR 0 1
11819: DIFF
11820: ST_TO_ADDR
// if un = JMM then
11821: LD_VAR 0 1
11825: PUSH
11826: LD_EXP 25
11830: EQUAL
11831: IFFALSE 11840
// YouLost ( 0 ) ;
11833: LD_STRING 0
11835: PPUSH
11836: CALL_OW 104
// if un = us_dep_west then
11840: LD_VAR 0 1
11844: PUSH
11845: LD_INT 1
11847: EQUAL
11848: IFFALSE 11857
// YouLost ( 2 ) ;
11850: LD_STRING 2
11852: PPUSH
11853: CALL_OW 104
// if un = Lynch and GetSide ( Lynch ) = 8 then
11857: LD_VAR 0 1
11861: PUSH
11862: LD_EXP 35
11866: EQUAL
11867: PUSH
11868: LD_EXP 35
11872: PPUSH
11873: CALL_OW 255
11877: PUSH
11878: LD_INT 8
11880: EQUAL
11881: AND
11882: IFFALSE 11891
// YouLost ( 4 ) ;
11884: LD_STRING 4
11886: PPUSH
11887: CALL_OW 104
// end ;
11891: PPOPN 1
11893: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) < 4 do
11894: LD_INT 22
11896: PUSH
11897: LD_INT 1
11899: PUSH
11900: EMPTY
11901: LIST
11902: LIST
11903: PUSH
11904: LD_INT 21
11906: PUSH
11907: LD_INT 1
11909: PUSH
11910: EMPTY
11911: LIST
11912: LIST
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: PPUSH
11918: CALL_OW 69
11922: PUSH
11923: LD_INT 22
11925: PUSH
11926: LD_INT 8
11928: PUSH
11929: EMPTY
11930: LIST
11931: LIST
11932: PUSH
11933: LD_INT 21
11935: PUSH
11936: LD_INT 1
11938: PUSH
11939: EMPTY
11940: LIST
11941: LIST
11942: PUSH
11943: EMPTY
11944: LIST
11945: LIST
11946: PPUSH
11947: CALL_OW 69
11951: PLUS
11952: PUSH
11953: LD_INT 4
11955: LESS
11956: IFFALSE 11968
11958: GO 11960
11960: DISABLE
// YouLost ( 1 ) ;
11961: LD_STRING 1
11963: PPUSH
11964: CALL_OW 104
11968: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
11969: LD_INT 1
11971: PPUSH
11972: CALL_OW 255
11976: PUSH
11977: LD_INT 3
11979: EQUAL
11980: IFFALSE 11992
11982: GO 11984
11984: DISABLE
// YouLost ( 3 ) ;
11985: LD_STRING 3
11987: PPUSH
11988: CALL_OW 104
11992: END
