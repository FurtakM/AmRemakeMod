// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 43 0 0
// SetDiplomacy ;
   8: CALL 307 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 22
// DebugMode ;
  18: CALL 395 0 0
// PrepareRussian ;
  22: CALL 2865 0 0
// PrepareAmerican ;
  26: CALL 1122 0 0
// PrepareCornell ;
  30: CALL 2146 0 0
// PrepareWesternBase ;
  34: CALL 2372 0 0
// Action ;
  38: CALL 3872 0 0
// end ;
  42: END
// export debug ; export jmm_units , jmm_on_west , cornel_units , bierezov_exist , cornel_active , cornel_attack , cornel_counter , cornel_prepared , frank_can_return , solar_builded , frank_send_to_scout , jmm_in_veh , bobby_in_veh , cyrus_in_veh , lisa_in_veh , crates_counter , end_mission_allowed , save_others , save_group , show_query , wait_for_them , veh_on_meta , time_to_prepare , send_spec_patrol , prepare_siege , send_attack_on_cornel , game_end ; function Init ; begin
  43: LD_INT 0
  45: PPUSH
// debug := false ;
  46: LD_ADDR_EXP 1
  50: PUSH
  51: LD_INT 0
  53: ST_TO_ADDR
// jmm_units := 0 ;
  54: LD_ADDR_EXP 2
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// cornel_units := 0 ;
  62: LD_ADDR_EXP 4
  66: PUSH
  67: LD_INT 0
  69: ST_TO_ADDR
// bierezov_exist := false ;
  70: LD_ADDR_EXP 5
  74: PUSH
  75: LD_INT 0
  77: ST_TO_ADDR
// jmm_on_west := false ;
  78: LD_ADDR_EXP 3
  82: PUSH
  83: LD_INT 0
  85: ST_TO_ADDR
// cornel_active := false ;
  86: LD_ADDR_EXP 6
  90: PUSH
  91: LD_INT 0
  93: ST_TO_ADDR
// cornel_attack := false ;
  94: LD_ADDR_EXP 7
  98: PUSH
  99: LD_INT 0
 101: ST_TO_ADDR
// cornel_prepared := false ;
 102: LD_ADDR_EXP 9
 106: PUSH
 107: LD_INT 0
 109: ST_TO_ADDR
// cornel_counter := 2 2$00 ;
 110: LD_ADDR_EXP 8
 114: PUSH
 115: LD_INT 4200
 117: ST_TO_ADDR
// frank_can_return := false ;
 118: LD_ADDR_EXP 10
 122: PUSH
 123: LD_INT 0
 125: ST_TO_ADDR
// solar_builded := false ;
 126: LD_ADDR_EXP 11
 130: PUSH
 131: LD_INT 0
 133: ST_TO_ADDR
// frank_send_to_scout := false ;
 134: LD_ADDR_EXP 12
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// jmm_in_veh := false ;
 142: LD_ADDR_EXP 13
 146: PUSH
 147: LD_INT 0
 149: ST_TO_ADDR
// bobby_in_veh := false ;
 150: LD_ADDR_EXP 14
 154: PUSH
 155: LD_INT 0
 157: ST_TO_ADDR
// cyrus_in_veh := false ;
 158: LD_ADDR_EXP 15
 162: PUSH
 163: LD_INT 0
 165: ST_TO_ADDR
// lisa_in_veh := false ;
 166: LD_ADDR_EXP 16
 170: PUSH
 171: LD_INT 0
 173: ST_TO_ADDR
// time_to_prepare := [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] ;
 174: LD_ADDR_EXP 24
 178: PUSH
 179: LD_INT 25200
 181: PUSH
 182: LD_INT 23100
 184: PUSH
 185: LD_INT 21000
 187: PUSH
 188: EMPTY
 189: LIST
 190: LIST
 191: LIST
 192: PUSH
 193: LD_OWVAR 67
 197: ARRAY
 198: ST_TO_ADDR
// crates_counter := [ 600 , 500 , 400 ] [ Difficulty ] ;
 199: LD_ADDR_EXP 17
 203: PUSH
 204: LD_INT 600
 206: PUSH
 207: LD_INT 500
 209: PUSH
 210: LD_INT 400
 212: PUSH
 213: EMPTY
 214: LIST
 215: LIST
 216: LIST
 217: PUSH
 218: LD_OWVAR 67
 222: ARRAY
 223: ST_TO_ADDR
// end_mission_allowed := false ;
 224: LD_ADDR_EXP 18
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// save_others := [ ] ;
 232: LD_ADDR_EXP 19
 236: PUSH
 237: EMPTY
 238: ST_TO_ADDR
// save_group := [ ] ;
 239: LD_ADDR_EXP 20
 243: PUSH
 244: EMPTY
 245: ST_TO_ADDR
// show_query := true ;
 246: LD_ADDR_EXP 21
 250: PUSH
 251: LD_INT 1
 253: ST_TO_ADDR
// wait_for_them := false ;
 254: LD_ADDR_EXP 22
 258: PUSH
 259: LD_INT 0
 261: ST_TO_ADDR
// veh_on_meta := false ;
 262: LD_ADDR_EXP 23
 266: PUSH
 267: LD_INT 0
 269: ST_TO_ADDR
// send_spec_patrol := false ;
 270: LD_ADDR_EXP 25
 274: PUSH
 275: LD_INT 0
 277: ST_TO_ADDR
// prepare_siege := false ;
 278: LD_ADDR_EXP 26
 282: PUSH
 283: LD_INT 0
 285: ST_TO_ADDR
// send_attack_on_cornel := false ;
 286: LD_ADDR_EXP 27
 290: PUSH
 291: LD_INT 0
 293: ST_TO_ADDR
// game_end := false ;
 294: LD_ADDR_EXP 28
 298: PUSH
 299: LD_INT 0
 301: ST_TO_ADDR
// end ;
 302: LD_VAR 0 1
 306: RET
// function SetDiplomacy ; begin
 307: LD_INT 0
 309: PPUSH
// SetAttitude ( 1 , 4 , att_friend , true ) ;
 310: LD_INT 1
 312: PPUSH
 313: LD_INT 4
 315: PPUSH
 316: LD_INT 1
 318: PPUSH
 319: LD_INT 1
 321: PPUSH
 322: CALL_OW 80
// SetAttitude ( 1 , 8 , att_friend , true ) ;
 326: LD_INT 1
 328: PPUSH
 329: LD_INT 8
 331: PPUSH
 332: LD_INT 1
 334: PPUSH
 335: LD_INT 1
 337: PPUSH
 338: CALL_OW 80
// SetAttitude ( 3 , 6 , att_friend , true ) ;
 342: LD_INT 3
 344: PPUSH
 345: LD_INT 6
 347: PPUSH
 348: LD_INT 1
 350: PPUSH
 351: LD_INT 1
 353: PPUSH
 354: CALL_OW 80
// SetAttitude ( 4 , 6 , att_neutral , true ) ;
 358: LD_INT 4
 360: PPUSH
 361: LD_INT 6
 363: PPUSH
 364: LD_INT 0
 366: PPUSH
 367: LD_INT 1
 369: PPUSH
 370: CALL_OW 80
// SetAttitude ( 3 , 8 , att_neutral , true ) ;
 374: LD_INT 3
 376: PPUSH
 377: LD_INT 8
 379: PPUSH
 380: LD_INT 0
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: CALL_OW 80
// end ;
 390: LD_VAR 0 1
 394: RET
// export function DebugMode ; begin
 395: LD_INT 0
 397: PPUSH
// FogOff ( 1 ) ;
 398: LD_INT 1
 400: PPUSH
 401: CALL_OW 344
// debug_strings := [ ] ;
 405: LD_ADDR_OWVAR 48
 409: PUSH
 410: EMPTY
 411: ST_TO_ADDR
// end ; end_of_file
 412: LD_VAR 0 1
 416: RET
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 417: LD_INT 0
 419: PPUSH
 420: PPUSH
// if exist_mode then
 421: LD_VAR 0 2
 425: IFFALSE 444
// unit := CreateCharacter ( ident ) else
 427: LD_ADDR_VAR 0 4
 431: PUSH
 432: LD_VAR 0 1
 436: PPUSH
 437: CALL_OW 34
 441: ST_TO_ADDR
 442: GO 459
// unit := NewCharacter ( ident ) ;
 444: LD_ADDR_VAR 0 4
 448: PUSH
 449: LD_VAR 0 1
 453: PPUSH
 454: CALL_OW 25
 458: ST_TO_ADDR
// result := unit ;
 459: LD_ADDR_VAR 0 3
 463: PUSH
 464: LD_VAR 0 4
 468: ST_TO_ADDR
// end ;
 469: LD_VAR 0 3
 473: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 474: LD_INT 0
 476: PPUSH
// uc_side := side ;
 477: LD_ADDR_OWVAR 20
 481: PUSH
 482: LD_VAR 0 1
 486: ST_TO_ADDR
// uc_nation := nation ;
 487: LD_ADDR_OWVAR 21
 491: PUSH
 492: LD_VAR 0 2
 496: ST_TO_ADDR
// vc_chassis := chassis ;
 497: LD_ADDR_OWVAR 37
 501: PUSH
 502: LD_VAR 0 3
 506: ST_TO_ADDR
// vc_engine := engine ;
 507: LD_ADDR_OWVAR 39
 511: PUSH
 512: LD_VAR 0 4
 516: ST_TO_ADDR
// vc_control := control ;
 517: LD_ADDR_OWVAR 38
 521: PUSH
 522: LD_VAR 0 5
 526: ST_TO_ADDR
// vc_weapon := weapon ;
 527: LD_ADDR_OWVAR 40
 531: PUSH
 532: LD_VAR 0 6
 536: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 537: LD_ADDR_OWVAR 41
 541: PUSH
 542: LD_VAR 0 7
 546: ST_TO_ADDR
// result := CreateVehicle ;
 547: LD_ADDR_VAR 0 8
 551: PUSH
 552: CALL_OW 45
 556: ST_TO_ADDR
// end ;
 557: LD_VAR 0 8
 561: RET
// export function SayX ( units , ident ) ; var i ; begin
 562: LD_INT 0
 564: PPUSH
 565: PPUSH
// result := false ;
 566: LD_ADDR_VAR 0 3
 570: PUSH
 571: LD_INT 0
 573: ST_TO_ADDR
// if not units then
 574: LD_VAR 0 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 637
// for i in units do
 583: LD_ADDR_VAR 0 4
 587: PUSH
 588: LD_VAR 0 1
 592: PUSH
 593: FOR_IN
 594: IFFALSE 635
// if IsOk ( i ) then
 596: LD_VAR 0 4
 600: PPUSH
 601: CALL_OW 302
 605: IFFALSE 633
// begin Say ( i , ident ) ;
 607: LD_VAR 0 4
 611: PPUSH
 612: LD_VAR 0 2
 616: PPUSH
 617: CALL_OW 88
// result := i ;
 621: LD_ADDR_VAR 0 3
 625: PUSH
 626: LD_VAR 0 4
 630: ST_TO_ADDR
// break ;
 631: GO 635
// end ;
 633: GO 593
 635: POP
 636: POP
// end ;
 637: LD_VAR 0 3
 641: RET
// export function RespawnInside ( side , nation , build , skill , class , count ) ; var i , l , un ; begin
 642: LD_INT 0
 644: PPUSH
 645: PPUSH
 646: PPUSH
 647: PPUSH
// for i = 1 to count do
 648: LD_ADDR_VAR 0 8
 652: PUSH
 653: DOUBLE
 654: LD_INT 1
 656: DEC
 657: ST_TO_ADDR
 658: LD_VAR 0 6
 662: PUSH
 663: FOR_TO
 664: IFFALSE 745
// begin uc_side = side ;
 666: LD_ADDR_OWVAR 20
 670: PUSH
 671: LD_VAR 0 1
 675: ST_TO_ADDR
// uc_nation = nation ;
 676: LD_ADDR_OWVAR 21
 680: PUSH
 681: LD_VAR 0 2
 685: ST_TO_ADDR
// hc_gallery =  ;
 686: LD_ADDR_OWVAR 33
 690: PUSH
 691: LD_STRING 
 693: ST_TO_ADDR
// hc_name =  ;
 694: LD_ADDR_OWVAR 26
 698: PUSH
 699: LD_STRING 
 701: ST_TO_ADDR
// PrepareHuman ( false , class , skill ) ;
 702: LD_INT 0
 704: PPUSH
 705: LD_VAR 0 5
 709: PPUSH
 710: LD_VAR 0 4
 714: PPUSH
 715: CALL_OW 380
// un = CreateHuman ;
 719: LD_ADDR_VAR 0 10
 723: PUSH
 724: CALL_OW 44
 728: ST_TO_ADDR
// PlaceHumanInUnit ( un , build ) ;
 729: LD_VAR 0 10
 733: PPUSH
 734: LD_VAR 0 3
 738: PPUSH
 739: CALL_OW 52
// end ;
 743: GO 663
 745: POP
 746: POP
// end ;
 747: LD_VAR 0 7
 751: RET
// export function PrepareSolBun ( skill , b ) ; var un , dir ; begin
 752: LD_INT 0
 754: PPUSH
 755: PPUSH
 756: PPUSH
// uc_side := GetSide ( b ) ;
 757: LD_ADDR_OWVAR 20
 761: PUSH
 762: LD_VAR 0 2
 766: PPUSH
 767: CALL_OW 255
 771: ST_TO_ADDR
// uc_nation := GetNation ( b ) ;
 772: LD_ADDR_OWVAR 21
 776: PUSH
 777: LD_VAR 0 2
 781: PPUSH
 782: CALL_OW 248
 786: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
 787: LD_INT 0
 789: PPUSH
 790: LD_INT 1
 792: PPUSH
 793: LD_VAR 0 1
 797: PPUSH
 798: CALL_OW 380
// un = CreateHuman ;
 802: LD_ADDR_VAR 0 4
 806: PUSH
 807: CALL_OW 44
 811: ST_TO_ADDR
// dir := GetDir ( b ) - 3 ;
 812: LD_ADDR_VAR 0 5
 816: PUSH
 817: LD_VAR 0 2
 821: PPUSH
 822: CALL_OW 254
 826: PUSH
 827: LD_INT 3
 829: MINUS
 830: ST_TO_ADDR
// if dir < 0 then
 831: LD_VAR 0 5
 835: PUSH
 836: LD_INT 0
 838: LESS
 839: IFFALSE 855
// dir := 6 + dir ;
 841: LD_ADDR_VAR 0 5
 845: PUSH
 846: LD_INT 6
 848: PUSH
 849: LD_VAR 0 5
 853: PLUS
 854: ST_TO_ADDR
// SetDir ( un , dir ) ;
 855: LD_VAR 0 4
 859: PPUSH
 860: LD_VAR 0 5
 864: PPUSH
 865: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
 869: LD_VAR 0 4
 873: PPUSH
 874: LD_VAR 0 2
 878: PPUSH
 879: CALL_OW 52
// end ;
 883: LD_VAR 0 3
 887: RET
// export function InVeh ( unit ) ; var filter , i ; begin
 888: LD_INT 0
 890: PPUSH
 891: PPUSH
 892: PPUSH
// result := false ;
 893: LD_ADDR_VAR 0 2
 897: PUSH
 898: LD_INT 0
 900: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_machine_gun ] ] ) ;
 901: LD_ADDR_VAR 0 3
 905: PUSH
 906: LD_INT 22
 908: PUSH
 909: LD_INT 1
 911: PUSH
 912: EMPTY
 913: LIST
 914: LIST
 915: PUSH
 916: LD_INT 34
 918: PUSH
 919: LD_INT 2
 921: PUSH
 922: EMPTY
 923: LIST
 924: LIST
 925: PUSH
 926: EMPTY
 927: LIST
 928: LIST
 929: PPUSH
 930: CALL_OW 69
 934: ST_TO_ADDR
// for i in filter do
 935: LD_ADDR_VAR 0 4
 939: PUSH
 940: LD_VAR 0 3
 944: PUSH
 945: FOR_IN
 946: IFFALSE 977
// if IsDrivenBy ( i ) = unit then
 948: LD_VAR 0 4
 952: PPUSH
 953: CALL_OW 311
 957: PUSH
 958: LD_VAR 0 1
 962: EQUAL
 963: IFFALSE 975
// begin result := true ;
 965: LD_ADDR_VAR 0 2
 969: PUSH
 970: LD_INT 1
 972: ST_TO_ADDR
// break ;
 973: GO 977
// end ;
 975: GO 945
 977: POP
 978: POP
// end ;
 979: LD_VAR 0 2
 983: RET
// export function FindFreePlace ( blist ) ; var i ; begin
 984: LD_INT 0
 986: PPUSH
 987: PPUSH
// result := false ;
 988: LD_ADDR_VAR 0 2
 992: PUSH
 993: LD_INT 0
 995: ST_TO_ADDR
// if not blist then
 996: LD_VAR 0 1
1000: NOT
1001: IFFALSE 1005
// exit ;
1003: GO 1049
// for i in blist do
1005: LD_ADDR_VAR 0 3
1009: PUSH
1010: LD_VAR 0 1
1014: PUSH
1015: FOR_IN
1016: IFFALSE 1047
// if UnitsInside ( i ) < 6 then
1018: LD_VAR 0 3
1022: PPUSH
1023: CALL_OW 313
1027: PUSH
1028: LD_INT 6
1030: LESS
1031: IFFALSE 1045
// begin result := i ;
1033: LD_ADDR_VAR 0 2
1037: PUSH
1038: LD_VAR 0 3
1042: ST_TO_ADDR
// break ;
1043: GO 1047
// end ;
1045: GO 1015
1047: POP
1048: POP
// end ;
1049: LD_VAR 0 2
1053: RET
// export function Count ( timer , mode ) ; begin
1054: LD_INT 0
1056: PPUSH
// if not timer then
1057: LD_VAR 0 1
1061: NOT
1062: IFFALSE 1066
// exit ;
1064: GO 1117
// if mode in [ asc , up , + ] then
1066: LD_VAR 0 2
1070: PUSH
1071: LD_STRING asc
1073: PUSH
1074: LD_STRING up
1076: PUSH
1077: LD_STRING +
1079: PUSH
1080: EMPTY
1081: LIST
1082: LIST
1083: LIST
1084: IN
1085: IFFALSE 1103
// result := timer + 0 0$01 else
1087: LD_ADDR_VAR 0 3
1091: PUSH
1092: LD_VAR 0 1
1096: PUSH
1097: LD_INT 35
1099: PLUS
1100: ST_TO_ADDR
1101: GO 1117
// result := timer - 0 0$01 ;
1103: LD_ADDR_VAR 0 3
1107: PUSH
1108: LD_VAR 0 1
1112: PUSH
1113: LD_INT 35
1115: MINUS
1116: ST_TO_ADDR
// end ; end_of_file
1117: LD_VAR 0 3
1121: RET
// export JMM , Bobby , Cyrus , Lisa , Khatam , Brian , Jerry , Cornel , Bierezov , Powell , Lynch , Walker , Turner , Jillian , Frank ; export function PrepareAmerican ; var i , un , tmp , others , vehicles , got_mech , empty ; begin
1122: LD_INT 0
1124: PPUSH
1125: PPUSH
1126: PPUSH
1127: PPUSH
1128: PPUSH
1129: PPUSH
1130: PPUSH
1131: PPUSH
// uc_side := 4 ;
1132: LD_ADDR_OWVAR 20
1136: PUSH
1137: LD_INT 4
1139: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ) ;
1140: LD_ADDR_EXP 38
1144: PUSH
1145: LD_STRING Powell
1147: PPUSH
1148: LD_INT 0
1150: PPUSH
1151: CALL 417 0 2
1155: ST_TO_ADDR
// uc_side := 1 ;
1156: LD_ADDR_OWVAR 20
1160: PUSH
1161: LD_INT 1
1163: ST_TO_ADDR
// uc_nation := 1 ;
1164: LD_ADDR_OWVAR 21
1168: PUSH
1169: LD_INT 1
1171: ST_TO_ADDR
// if debug then
1172: LD_EXP 1
1176: IFFALSE 1306
// begin for i = 1 to 4 do
1178: LD_ADDR_VAR 0 2
1182: PUSH
1183: DOUBLE
1184: LD_INT 1
1186: DEC
1187: ST_TO_ADDR
1188: LD_INT 4
1190: PUSH
1191: FOR_TO
1192: IFFALSE 1243
// begin PrepareHuman ( false , rand ( 1 , 2 ) , 3 ) ;
1194: LD_INT 0
1196: PPUSH
1197: LD_INT 1
1199: PPUSH
1200: LD_INT 2
1202: PPUSH
1203: CALL_OW 12
1207: PPUSH
1208: LD_INT 3
1210: PPUSH
1211: CALL_OW 380
// un := CreateHuman ;
1215: LD_ADDR_VAR 0 3
1219: PUSH
1220: CALL_OW 44
1224: ST_TO_ADDR
// others := others ^ un ;
1225: LD_ADDR_VAR 0 5
1229: PUSH
1230: LD_VAR 0 5
1234: PUSH
1235: LD_VAR 0 3
1239: ADD
1240: ST_TO_ADDR
// end ;
1241: GO 1191
1243: POP
1244: POP
// vehicles := [ [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 90 , 504 ] , [ ru_medium_wheeled , engine_combustion , control_manual , ru_cargo_bay , 80 , 750 ] ] ;
1245: LD_ADDR_VAR 0 6
1249: PUSH
1250: LD_INT 21
1252: PUSH
1253: LD_INT 1
1255: PUSH
1256: LD_INT 1
1258: PUSH
1259: LD_INT 51
1261: PUSH
1262: LD_INT 90
1264: PUSH
1265: LD_INT 504
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 21
1278: PUSH
1279: LD_INT 1
1281: PUSH
1282: LD_INT 1
1284: PUSH
1285: LD_INT 51
1287: PUSH
1288: LD_INT 80
1290: PUSH
1291: LD_INT 750
1293: PUSH
1294: EMPTY
1295: LIST
1296: LIST
1297: LIST
1298: LIST
1299: LIST
1300: LIST
1301: PUSH
1302: EMPTY
1303: LIST
1304: LIST
1305: ST_TO_ADDR
// end ; JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1306: LD_ADDR_EXP 29
1310: PUSH
1311: LD_STRING JMM
1313: PPUSH
1314: LD_EXP 1
1318: NOT
1319: PPUSH
1320: CALL 417 0 2
1324: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1325: LD_ADDR_EXP 30
1329: PUSH
1330: LD_STRING Bobby
1332: PPUSH
1333: LD_EXP 1
1337: NOT
1338: PPUSH
1339: CALL 417 0 2
1343: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1344: LD_ADDR_EXP 31
1348: PUSH
1349: LD_STRING Cyrus
1351: PPUSH
1352: LD_EXP 1
1356: NOT
1357: PPUSH
1358: CALL 417 0 2
1362: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1363: LD_ADDR_EXP 32
1367: PUSH
1368: LD_STRING Lisa
1370: PPUSH
1371: LD_EXP 1
1375: NOT
1376: PPUSH
1377: CALL 417 0 2
1381: ST_TO_ADDR
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1382: LD_ADDR_EXP 33
1386: PUSH
1387: LD_STRING Khatam
1389: PPUSH
1390: LD_EXP 1
1394: NOT
1395: PPUSH
1396: CALL 417 0 2
1400: ST_TO_ADDR
// Brian := PrepareUnit ( Brian , ( not debug ) ) ;
1401: LD_ADDR_EXP 34
1405: PUSH
1406: LD_STRING Brian
1408: PPUSH
1409: LD_EXP 1
1413: NOT
1414: PPUSH
1415: CALL 417 0 2
1419: ST_TO_ADDR
// Jerry := PrepareUnit ( Jerry , ( not debug ) ) ;
1420: LD_ADDR_EXP 35
1424: PUSH
1425: LD_STRING Jerry
1427: PPUSH
1428: LD_EXP 1
1432: NOT
1433: PPUSH
1434: CALL 417 0 2
1438: ST_TO_ADDR
// if Bobby then
1439: LD_EXP 30
1443: IFFALSE 1474
// tmp := Insert ( tmp , tmp + 1 , Bobby ) ;
1445: LD_ADDR_VAR 0 4
1449: PUSH
1450: LD_VAR 0 4
1454: PPUSH
1455: LD_VAR 0 4
1459: PUSH
1460: LD_INT 1
1462: PLUS
1463: PPUSH
1464: LD_EXP 30
1468: PPUSH
1469: CALL_OW 2
1473: ST_TO_ADDR
// if Cyrus then
1474: LD_EXP 31
1478: IFFALSE 1509
// tmp := Insert ( tmp , tmp + 1 , Cyrus ) ;
1480: LD_ADDR_VAR 0 4
1484: PUSH
1485: LD_VAR 0 4
1489: PPUSH
1490: LD_VAR 0 4
1494: PUSH
1495: LD_INT 1
1497: PLUS
1498: PPUSH
1499: LD_EXP 31
1503: PPUSH
1504: CALL_OW 2
1508: ST_TO_ADDR
// if Lisa then
1509: LD_EXP 32
1513: IFFALSE 1544
// tmp := Insert ( tmp , tmp + 1 , Lisa ) ;
1515: LD_ADDR_VAR 0 4
1519: PUSH
1520: LD_VAR 0 4
1524: PPUSH
1525: LD_VAR 0 4
1529: PUSH
1530: LD_INT 1
1532: PLUS
1533: PPUSH
1534: LD_EXP 32
1538: PPUSH
1539: CALL_OW 2
1543: ST_TO_ADDR
// if Khatam then
1544: LD_EXP 33
1548: IFFALSE 1579
// tmp := Insert ( tmp , tmp + 1 , Khatam ) ;
1550: LD_ADDR_VAR 0 4
1554: PUSH
1555: LD_VAR 0 4
1559: PPUSH
1560: LD_VAR 0 4
1564: PUSH
1565: LD_INT 1
1567: PLUS
1568: PPUSH
1569: LD_EXP 33
1573: PPUSH
1574: CALL_OW 2
1578: ST_TO_ADDR
// if Brian then
1579: LD_EXP 34
1583: IFFALSE 1614
// tmp := Insert ( tmp , tmp + 1 , Brian ) ;
1585: LD_ADDR_VAR 0 4
1589: PUSH
1590: LD_VAR 0 4
1594: PPUSH
1595: LD_VAR 0 4
1599: PUSH
1600: LD_INT 1
1602: PLUS
1603: PPUSH
1604: LD_EXP 34
1608: PPUSH
1609: CALL_OW 2
1613: ST_TO_ADDR
// if Jerry then
1614: LD_EXP 35
1618: IFFALSE 1649
// tmp := Insert ( tmp , tmp + 1 , Jerry ) ;
1620: LD_ADDR_VAR 0 4
1624: PUSH
1625: LD_VAR 0 4
1629: PPUSH
1630: LD_VAR 0 4
1634: PUSH
1635: LD_INT 1
1637: PLUS
1638: PPUSH
1639: LD_EXP 35
1643: PPUSH
1644: CALL_OW 2
1648: ST_TO_ADDR
// if TestCharacters ( 02_other_survivors ) then
1649: LD_STRING 02_other_survivors
1651: PPUSH
1652: CALL_OW 28
1656: IFFALSE 1671
// others := CreateCharacterSet ( 02_other_survivors ) ;
1658: LD_ADDR_VAR 0 5
1662: PUSH
1663: LD_STRING 02_other_survivors
1665: PPUSH
1666: CALL_OW 31
1670: ST_TO_ADDR
// if others then
1671: LD_VAR 0 5
1675: IFFALSE 1700
// begin tmp := tmp ^ others ;
1677: LD_ADDR_VAR 0 4
1681: PUSH
1682: LD_VAR 0 4
1686: PUSH
1687: LD_VAR 0 5
1691: ADD
1692: ST_TO_ADDR
// DeleteCharacters ( 02_other_survivors ) ;
1693: LD_STRING 02_other_survivors
1695: PPUSH
1696: CALL_OW 40
// end ; jmm_units := tmp ;
1700: LD_ADDR_EXP 2
1704: PUSH
1705: LD_VAR 0 4
1709: ST_TO_ADDR
// if not vehicles then
1710: LD_VAR 0 6
1714: NOT
1715: IFFALSE 1733
// vehicles := LoadVariable ( 02_tanks_1 , 0 ) ;
1717: LD_ADDR_VAR 0 6
1721: PUSH
1722: LD_STRING 02_tanks_1
1724: PPUSH
1725: LD_INT 0
1727: PPUSH
1728: CALL_OW 30
1732: ST_TO_ADDR
// if vehicles then
1733: LD_VAR 0 6
1737: IFFALSE 1931
// begin got_mech := false ;
1739: LD_ADDR_VAR 0 7
1743: PUSH
1744: LD_INT 0
1746: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_class , 3 ] ) then
1747: LD_VAR 0 4
1751: PPUSH
1752: LD_INT 25
1754: PUSH
1755: LD_INT 3
1757: PUSH
1758: EMPTY
1759: LIST
1760: LIST
1761: PPUSH
1762: CALL_OW 72
1766: IFFALSE 1776
// got_mech := true ;
1768: LD_ADDR_VAR 0 7
1772: PUSH
1773: LD_INT 1
1775: ST_TO_ADDR
// for i = 1 to vehicles do
1776: LD_ADDR_VAR 0 2
1780: PUSH
1781: DOUBLE
1782: LD_INT 1
1784: DEC
1785: ST_TO_ADDR
1786: LD_VAR 0 6
1790: PUSH
1791: FOR_TO
1792: IFFALSE 1929
// begin un := PrepareTank ( 1 , 3 , vehicles [ i ] [ 1 ] , vehicles [ i ] [ 2 ] , vehicles [ i ] [ 3 ] , vehicles [ i ] [ 4 ] , 40 ) ;
1794: LD_ADDR_VAR 0 3
1798: PUSH
1799: LD_INT 1
1801: PPUSH
1802: LD_INT 3
1804: PPUSH
1805: LD_VAR 0 6
1809: PUSH
1810: LD_VAR 0 2
1814: ARRAY
1815: PUSH
1816: LD_INT 1
1818: ARRAY
1819: PPUSH
1820: LD_VAR 0 6
1824: PUSH
1825: LD_VAR 0 2
1829: ARRAY
1830: PUSH
1831: LD_INT 2
1833: ARRAY
1834: PPUSH
1835: LD_VAR 0 6
1839: PUSH
1840: LD_VAR 0 2
1844: ARRAY
1845: PUSH
1846: LD_INT 3
1848: ARRAY
1849: PPUSH
1850: LD_VAR 0 6
1854: PUSH
1855: LD_VAR 0 2
1859: ARRAY
1860: PUSH
1861: LD_INT 4
1863: ARRAY
1864: PPUSH
1865: LD_INT 40
1867: PPUSH
1868: CALL 474 0 7
1872: ST_TO_ADDR
// if not got_mech then
1873: LD_VAR 0 7
1877: NOT
1878: IFFALSE 1904
// SetLives ( un , vehicles [ i ] [ 6 ] ) ;
1880: LD_VAR 0 3
1884: PPUSH
1885: LD_VAR 0 6
1889: PUSH
1890: LD_VAR 0 2
1894: ARRAY
1895: PUSH
1896: LD_INT 6
1898: ARRAY
1899: PPUSH
1900: CALL_OW 234
// tmp := Insert ( tmp , 1 , un ) ;
1904: LD_ADDR_VAR 0 4
1908: PUSH
1909: LD_VAR 0 4
1913: PPUSH
1914: LD_INT 1
1916: PPUSH
1917: LD_VAR 0 3
1921: PPUSH
1922: CALL_OW 2
1926: ST_TO_ADDR
// end ;
1927: GO 1791
1929: POP
1930: POP
// end ; PlaceUnitXY ( JMM , 194 , 119 , false ) ;
1931: LD_EXP 29
1935: PPUSH
1936: LD_INT 194
1938: PPUSH
1939: LD_INT 119
1941: PPUSH
1942: LD_INT 0
1944: PPUSH
1945: CALL_OW 48
// if tmp then
1949: LD_VAR 0 4
1953: IFFALSE 2078
// begin for i in tmp do
1955: LD_ADDR_VAR 0 2
1959: PUSH
1960: LD_VAR 0 4
1964: PUSH
1965: FOR_IN
1966: IFFALSE 2076
// begin empty := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
1968: LD_ADDR_VAR 0 8
1972: PUSH
1973: LD_INT 22
1975: PUSH
1976: LD_INT 1
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: PUSH
1983: LD_INT 21
1985: PUSH
1986: LD_INT 2
1988: PUSH
1989: EMPTY
1990: LIST
1991: LIST
1992: PUSH
1993: LD_INT 58
1995: PUSH
1996: EMPTY
1997: LIST
1998: PUSH
1999: EMPTY
2000: LIST
2001: LIST
2002: LIST
2003: PPUSH
2004: CALL_OW 69
2008: ST_TO_ADDR
// if GetType ( i ) = unit_human and empty then
2009: LD_VAR 0 2
2013: PPUSH
2014: CALL_OW 247
2018: PUSH
2019: LD_INT 1
2021: EQUAL
2022: PUSH
2023: LD_VAR 0 8
2027: AND
2028: IFFALSE 2050
// PlaceHumanInUnit ( i , empty [ 1 ] ) else
2030: LD_VAR 0 2
2034: PPUSH
2035: LD_VAR 0 8
2039: PUSH
2040: LD_INT 1
2042: ARRAY
2043: PPUSH
2044: CALL_OW 52
2048: GO 2065
// PlaceUnitArea ( i , startArea , false ) ;
2050: LD_VAR 0 2
2054: PPUSH
2055: LD_INT 1
2057: PPUSH
2058: LD_INT 0
2060: PPUSH
2061: CALL_OW 49
// ComHold ( i ) ;
2065: LD_VAR 0 2
2069: PPUSH
2070: CALL_OW 140
// end ;
2074: GO 1965
2076: POP
2077: POP
// end ; bierezov_exist := LoadVariable ( 02_mikhailStatus_1 , false ) ;
2078: LD_ADDR_EXP 5
2082: PUSH
2083: LD_STRING 02_mikhailStatus_1
2085: PPUSH
2086: LD_INT 0
2088: PPUSH
2089: CALL_OW 30
2093: ST_TO_ADDR
// if not bierezov_exist and not debug then
2094: LD_EXP 5
2098: NOT
2099: PUSH
2100: LD_EXP 1
2104: NOT
2105: AND
2106: IFFALSE 2110
// exit ;
2108: GO 2141
// Bierezov = PrepareUnit ( Mikhail , false ) ;
2110: LD_ADDR_EXP 37
2114: PUSH
2115: LD_STRING Mikhail
2117: PPUSH
2118: LD_INT 0
2120: PPUSH
2121: CALL 417 0 2
2125: ST_TO_ADDR
// PlaceUnitArea ( Bierezov , startArea , false ) ;
2126: LD_EXP 37
2130: PPUSH
2131: LD_INT 1
2133: PPUSH
2134: LD_INT 0
2136: PPUSH
2137: CALL_OW 49
// end ;
2141: LD_VAR 0 1
2145: RET
// export function PrepareCornell ; var tmp , un , i ; begin
2146: LD_INT 0
2148: PPUSH
2149: PPUSH
2150: PPUSH
2151: PPUSH
// uc_side := 4 ;
2152: LD_ADDR_OWVAR 20
2156: PUSH
2157: LD_INT 4
2159: ST_TO_ADDR
// uc_nation := 1 ;
2160: LD_ADDR_OWVAR 21
2164: PUSH
2165: LD_INT 1
2167: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , false ) ;
2168: LD_ADDR_EXP 36
2172: PUSH
2173: LD_STRING Cornell
2175: PPUSH
2176: LD_INT 0
2178: PPUSH
2179: CALL 417 0 2
2183: ST_TO_ADDR
// cornel_units := 8 - jmm_units ;
2184: LD_ADDR_EXP 4
2188: PUSH
2189: LD_INT 8
2191: PUSH
2192: LD_EXP 2
2196: MINUS
2197: ST_TO_ADDR
// tmp := [ ] ;
2198: LD_ADDR_VAR 0 2
2202: PUSH
2203: EMPTY
2204: ST_TO_ADDR
// if cornel_units < 3 then
2205: LD_EXP 4
2209: PUSH
2210: LD_INT 3
2212: LESS
2213: IFFALSE 2223
// cornel_units := 3 ;
2215: LD_ADDR_EXP 4
2219: PUSH
2220: LD_INT 3
2222: ST_TO_ADDR
// for i = 1 to cornel_units do
2223: LD_ADDR_VAR 0 4
2227: PUSH
2228: DOUBLE
2229: LD_INT 1
2231: DEC
2232: ST_TO_ADDR
2233: LD_EXP 4
2237: PUSH
2238: FOR_TO
2239: IFFALSE 2337
// begin PrepareHuman ( false , [ 1 , 1 , 1 , 2 , 4 ] [ i mod 5 + 1 ] , 2 ) ;
2241: LD_INT 0
2243: PPUSH
2244: LD_INT 1
2246: PUSH
2247: LD_INT 1
2249: PUSH
2250: LD_INT 1
2252: PUSH
2253: LD_INT 2
2255: PUSH
2256: LD_INT 4
2258: PUSH
2259: EMPTY
2260: LIST
2261: LIST
2262: LIST
2263: LIST
2264: LIST
2265: PUSH
2266: LD_VAR 0 4
2270: PUSH
2271: LD_INT 5
2273: MOD
2274: PUSH
2275: LD_INT 1
2277: PLUS
2278: ARRAY
2279: PPUSH
2280: LD_INT 2
2282: PPUSH
2283: CALL_OW 380
// un := CreateHuman ;
2287: LD_ADDR_VAR 0 3
2291: PUSH
2292: CALL_OW 44
2296: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , un ) ;
2297: LD_ADDR_VAR 0 2
2301: PUSH
2302: LD_VAR 0 2
2306: PPUSH
2307: LD_INT 1
2309: PPUSH
2310: LD_VAR 0 3
2314: PPUSH
2315: CALL_OW 2
2319: ST_TO_ADDR
// PlaceUnitArea ( un , cornelStartArea , false ) ;
2320: LD_VAR 0 3
2324: PPUSH
2325: LD_INT 2
2327: PPUSH
2328: LD_INT 0
2330: PPUSH
2331: CALL_OW 49
// end ;
2335: GO 2238
2337: POP
2338: POP
// cornel_units := tmp ;
2339: LD_ADDR_EXP 4
2343: PUSH
2344: LD_VAR 0 2
2348: ST_TO_ADDR
// PlaceUnitXY ( Cornel , 191 , 106 , false ) ;
2349: LD_EXP 36
2353: PPUSH
2354: LD_INT 191
2356: PPUSH
2357: LD_INT 106
2359: PPUSH
2360: LD_INT 0
2362: PPUSH
2363: CALL_OW 48
// end ;
2367: LD_VAR 0 1
2371: RET
// export function PrepareWesternBase ; var i ; begin
2372: LD_INT 0
2374: PPUSH
2375: PPUSH
// uc_side := 8 ;
2376: LD_ADDR_OWVAR 20
2380: PUSH
2381: LD_INT 8
2383: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ) ;
2384: LD_ADDR_EXP 39
2388: PUSH
2389: LD_STRING Lynch
2391: PPUSH
2392: LD_INT 0
2394: PPUSH
2395: CALL 417 0 2
2399: ST_TO_ADDR
// Walker := PrepareUnit ( Walker , false ) ;
2400: LD_ADDR_EXP 40
2404: PUSH
2405: LD_STRING Walker
2407: PPUSH
2408: LD_INT 0
2410: PPUSH
2411: CALL 417 0 2
2415: ST_TO_ADDR
// Turner := PrepareUnit ( Turner , false ) ;
2416: LD_ADDR_EXP 41
2420: PUSH
2421: LD_STRING Turner
2423: PPUSH
2424: LD_INT 0
2426: PPUSH
2427: CALL 417 0 2
2431: ST_TO_ADDR
// Jillian := PrepareUnit ( Jillian , false ) ;
2432: LD_ADDR_EXP 42
2436: PUSH
2437: LD_STRING Jillian
2439: PPUSH
2440: LD_INT 0
2442: PPUSH
2443: CALL 417 0 2
2447: ST_TO_ADDR
// for i in [ Lynch , Walker , Turner , Jillian ] do
2448: LD_ADDR_VAR 0 2
2452: PUSH
2453: LD_EXP 39
2457: PUSH
2458: LD_EXP 40
2462: PUSH
2463: LD_EXP 41
2467: PUSH
2468: LD_EXP 42
2472: PUSH
2473: EMPTY
2474: LIST
2475: LIST
2476: LIST
2477: LIST
2478: PUSH
2479: FOR_IN
2480: IFFALSE 2508
// begin PlaceUnitArea ( i , westBaseArea , false ) ;
2482: LD_VAR 0 2
2486: PPUSH
2487: LD_INT 3
2489: PPUSH
2490: LD_INT 0
2492: PPUSH
2493: CALL_OW 49
// ComHold ( i ) ;
2497: LD_VAR 0 2
2501: PPUSH
2502: CALL_OW 140
// end ;
2506: GO 2479
2508: POP
2509: POP
// end ;
2510: LD_VAR 0 1
2514: RET
// export function SelectGroup ; var units , selected , i ; begin
2515: LD_INT 0
2517: PPUSH
2518: PPUSH
2519: PPUSH
2520: PPUSH
// units := [ JMM , sel_changeable ] ^ jmm_units ^ [ sel_not_hired , sel_not_changeable , Cornel , Bierezov ] ^ [ sel_changeable ] ^ cornel_units ;
2521: LD_ADDR_VAR 0 2
2525: PUSH
2526: LD_EXP 29
2530: PUSH
2531: LD_INT -3
2533: PUSH
2534: EMPTY
2535: LIST
2536: LIST
2537: PUSH
2538: LD_EXP 2
2542: ADD
2543: PUSH
2544: LD_INT -2
2546: PUSH
2547: LD_INT -4
2549: PUSH
2550: LD_EXP 36
2554: PUSH
2555: LD_EXP 37
2559: PUSH
2560: EMPTY
2561: LIST
2562: LIST
2563: LIST
2564: LIST
2565: ADD
2566: PUSH
2567: LD_INT -3
2569: PUSH
2570: EMPTY
2571: LIST
2572: ADD
2573: PUSH
2574: LD_EXP 4
2578: ADD
2579: ST_TO_ADDR
// selected := JMM ^ CharacterSelection ( Select five characters to go with you , 4 , 4 , units , [ ] ) ;
2580: LD_ADDR_VAR 0 3
2584: PUSH
2585: LD_EXP 29
2589: PUSH
2590: LD_STRING Select five characters to go with you
2592: PPUSH
2593: LD_INT 4
2595: PPUSH
2596: LD_INT 4
2598: PPUSH
2599: LD_VAR 0 2
2603: PPUSH
2604: EMPTY
2605: PPUSH
2606: CALL_OW 42
2610: ADD
2611: ST_TO_ADDR
// cornel_units := jmm_units union cornel_units diff selected ;
2612: LD_ADDR_EXP 4
2616: PUSH
2617: LD_EXP 2
2621: PUSH
2622: LD_EXP 4
2626: UNION
2627: PUSH
2628: LD_VAR 0 3
2632: DIFF
2633: ST_TO_ADDR
// for i in cornel_units ^ Bierezov do
2634: LD_ADDR_VAR 0 4
2638: PUSH
2639: LD_EXP 4
2643: PUSH
2644: LD_EXP 37
2648: ADD
2649: PUSH
2650: FOR_IN
2651: IFFALSE 2682
// if GetSide ( i ) = 1 then
2653: LD_VAR 0 4
2657: PPUSH
2658: CALL_OW 255
2662: PUSH
2663: LD_INT 1
2665: EQUAL
2666: IFFALSE 2680
// SetSide ( i , 4 ) ;
2668: LD_VAR 0 4
2672: PPUSH
2673: LD_INT 4
2675: PPUSH
2676: CALL_OW 235
2680: GO 2650
2682: POP
2683: POP
// for i in selected do
2684: LD_ADDR_VAR 0 4
2688: PUSH
2689: LD_VAR 0 3
2693: PUSH
2694: FOR_IN
2695: IFFALSE 2726
// if GetSide ( i ) = 4 then
2697: LD_VAR 0 4
2701: PPUSH
2702: CALL_OW 255
2706: PUSH
2707: LD_INT 4
2709: EQUAL
2710: IFFALSE 2724
// SetSide ( i , 1 ) ;
2712: LD_VAR 0 4
2716: PPUSH
2717: LD_INT 1
2719: PPUSH
2720: CALL_OW 235
2724: GO 2694
2726: POP
2727: POP
// if GetSide ( Bobby ) = 4 then
2728: LD_EXP 30
2732: PPUSH
2733: CALL_OW 255
2737: PUSH
2738: LD_INT 4
2740: EQUAL
2741: IFFALSE 2750
// DeleteCharacters ( Bobby ) ;
2743: LD_STRING Bobby
2745: PPUSH
2746: CALL_OW 40
// if GetSide ( Cyrus ) = 4 then
2750: LD_EXP 31
2754: PPUSH
2755: CALL_OW 255
2759: PUSH
2760: LD_INT 4
2762: EQUAL
2763: IFFALSE 2772
// DeleteCharacters ( Cyrus ) ;
2765: LD_STRING Cyrus
2767: PPUSH
2768: CALL_OW 40
// if GetSide ( Lisa ) = 4 then
2772: LD_EXP 32
2776: PPUSH
2777: CALL_OW 255
2781: PUSH
2782: LD_INT 4
2784: EQUAL
2785: IFFALSE 2794
// DeleteCharacters ( Lisa ) ;
2787: LD_STRING Lisa
2789: PPUSH
2790: CALL_OW 40
// if GetSide ( Khatam ) = 4 then
2794: LD_EXP 33
2798: PPUSH
2799: CALL_OW 255
2803: PUSH
2804: LD_INT 4
2806: EQUAL
2807: IFFALSE 2816
// DeleteCharacters ( Khatam ) ;
2809: LD_STRING Khatam
2811: PPUSH
2812: CALL_OW 40
// if GetSide ( Brian ) = 4 then
2816: LD_EXP 34
2820: PPUSH
2821: CALL_OW 255
2825: PUSH
2826: LD_INT 4
2828: EQUAL
2829: IFFALSE 2838
// DeleteCharacters ( Brian ) ;
2831: LD_STRING Brian
2833: PPUSH
2834: CALL_OW 40
// if GetSide ( Jerry ) = 4 then
2838: LD_EXP 35
2842: PPUSH
2843: CALL_OW 255
2847: PUSH
2848: LD_INT 4
2850: EQUAL
2851: IFFALSE 2860
// DeleteCharacters ( Jerry ) ;
2853: LD_STRING Jerry
2855: PPUSH
2856: CALL_OW 40
// end ; end_of_file
2860: LD_VAR 0 1
2864: RET
// export Pokryshkin ; export ru_patrol , ru_spec_patrol , ru_forest , ru_vehicles ; export ru_firepoints_south , ru_alert , ru_alert_xy ; export function PrepareRussian ; var i , b , un , veh , tw , bar , skill , vehicles , spot_xy ; begin
2865: LD_INT 0
2867: PPUSH
2868: PPUSH
2869: PPUSH
2870: PPUSH
2871: PPUSH
2872: PPUSH
2873: PPUSH
2874: PPUSH
2875: PPUSH
2876: PPUSH
// ru_alert := false ;
2877: LD_ADDR_EXP 50
2881: PUSH
2882: LD_INT 0
2884: ST_TO_ADDR
// tw := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) ;
2885: LD_ADDR_VAR 0 6
2889: PUSH
2890: LD_INT 22
2892: PUSH
2893: LD_INT 3
2895: PUSH
2896: EMPTY
2897: LIST
2898: LIST
2899: PUSH
2900: LD_INT 2
2902: PUSH
2903: LD_INT 30
2905: PUSH
2906: LD_INT 31
2908: PUSH
2909: EMPTY
2910: LIST
2911: LIST
2912: PUSH
2913: LD_INT 30
2915: PUSH
2916: LD_INT 32
2918: PUSH
2919: EMPTY
2920: LIST
2921: LIST
2922: PUSH
2923: EMPTY
2924: LIST
2925: LIST
2926: LIST
2927: PUSH
2928: EMPTY
2929: LIST
2930: LIST
2931: PPUSH
2932: CALL_OW 69
2936: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ;
2937: LD_ADDR_VAR 0 7
2941: PUSH
2942: LD_INT 22
2944: PUSH
2945: LD_INT 3
2947: PUSH
2948: EMPTY
2949: LIST
2950: LIST
2951: PUSH
2952: LD_INT 30
2954: PUSH
2955: LD_INT 4
2957: PUSH
2958: EMPTY
2959: LIST
2960: LIST
2961: PUSH
2962: EMPTY
2963: LIST
2964: LIST
2965: PPUSH
2966: CALL_OW 69
2970: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_warehouse ] ] ) do
2971: LD_ADDR_VAR 0 2
2975: PUSH
2976: LD_INT 22
2978: PUSH
2979: LD_INT 3
2981: PUSH
2982: EMPTY
2983: LIST
2984: LIST
2985: PUSH
2986: LD_INT 30
2988: PUSH
2989: LD_INT 1
2991: PUSH
2992: EMPTY
2993: LIST
2994: LIST
2995: PUSH
2996: EMPTY
2997: LIST
2998: LIST
2999: PPUSH
3000: CALL_OW 69
3004: PUSH
3005: FOR_IN
3006: IFFALSE 3050
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
3008: LD_VAR 0 2
3012: PPUSH
3013: CALL_OW 274
3017: PPUSH
3018: LD_INT 1
3020: PPUSH
3021: LD_INT 1000
3023: PPUSH
3024: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 300 ) ;
3028: LD_VAR 0 2
3032: PPUSH
3033: CALL_OW 274
3037: PPUSH
3038: LD_INT 2
3040: PPUSH
3041: LD_INT 300
3043: PPUSH
3044: CALL_OW 277
// end ;
3048: GO 3005
3050: POP
3051: POP
// uc_side := 3 ;
3052: LD_ADDR_OWVAR 20
3056: PUSH
3057: LD_INT 3
3059: ST_TO_ADDR
// uc_nation := 3 ;
3060: LD_ADDR_OWVAR 21
3064: PUSH
3065: LD_INT 3
3067: ST_TO_ADDR
// skill := [ 2 , 2 , 3 ] [ Difficulty ] ;
3068: LD_ADDR_VAR 0 8
3072: PUSH
3073: LD_INT 2
3075: PUSH
3076: LD_INT 2
3078: PUSH
3079: LD_INT 3
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: LIST
3086: PUSH
3087: LD_OWVAR 67
3091: ARRAY
3092: ST_TO_ADDR
// Pokryshkin := PrepareUnit ( Pokryshkin , false ) ;
3093: LD_ADDR_EXP 44
3097: PUSH
3098: LD_STRING Pokryshkin
3100: PPUSH
3101: LD_INT 0
3103: PPUSH
3104: CALL 417 0 2
3108: ST_TO_ADDR
// PlaceUnitXY ( Pokryshkin , 63 , 21 , false ) ;
3109: LD_EXP 44
3113: PPUSH
3114: LD_INT 63
3116: PPUSH
3117: LD_INT 21
3119: PPUSH
3120: LD_INT 0
3122: PPUSH
3123: CALL_OW 48
// ComHold ( Pokryshkin ) ;
3127: LD_EXP 44
3131: PPUSH
3132: CALL_OW 140
// InitHc ;
3136: CALL_OW 19
// for i in tw do
3140: LD_ADDR_VAR 0 2
3144: PUSH
3145: LD_VAR 0 6
3149: PUSH
3150: FOR_IN
3151: IFFALSE 3200
// begin PlaceWeaponTurret ( i , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] ) ;
3153: LD_VAR 0 2
3157: PPUSH
3158: LD_INT 42
3160: PUSH
3161: LD_INT 43
3163: PUSH
3164: EMPTY
3165: LIST
3166: LIST
3167: PUSH
3168: LD_INT 1
3170: PPUSH
3171: LD_INT 2
3173: PPUSH
3174: CALL_OW 12
3178: ARRAY
3179: PPUSH
3180: CALL_OW 431
// PrepareSolBun ( skill , i ) ;
3184: LD_VAR 0 8
3188: PPUSH
3189: LD_VAR 0 2
3193: PPUSH
3194: CALL 752 0 2
// end ;
3198: GO 3150
3200: POP
3201: POP
// spot_xy := [ [ 100 , 9 ] , [ 135 , 60 ] , [ 41 , 6 ] , [ 22 , 9 ] , [ 84 , 14 ] ] ;
3202: LD_ADDR_VAR 0 10
3206: PUSH
3207: LD_INT 100
3209: PUSH
3210: LD_INT 9
3212: PUSH
3213: EMPTY
3214: LIST
3215: LIST
3216: PUSH
3217: LD_INT 135
3219: PUSH
3220: LD_INT 60
3222: PUSH
3223: EMPTY
3224: LIST
3225: LIST
3226: PUSH
3227: LD_INT 41
3229: PUSH
3230: LD_INT 6
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: PUSH
3237: LD_INT 22
3239: PUSH
3240: LD_INT 9
3242: PUSH
3243: EMPTY
3244: LIST
3245: LIST
3246: PUSH
3247: LD_INT 84
3249: PUSH
3250: LD_INT 14
3252: PUSH
3253: EMPTY
3254: LIST
3255: LIST
3256: PUSH
3257: EMPTY
3258: LIST
3259: LIST
3260: LIST
3261: LIST
3262: LIST
3263: ST_TO_ADDR
// vehicles := [ ] ;
3264: LD_ADDR_VAR 0 9
3268: PUSH
3269: EMPTY
3270: ST_TO_ADDR
// for i in spot_xy do
3271: LD_ADDR_VAR 0 2
3275: PUSH
3276: LD_VAR 0 10
3280: PUSH
3281: FOR_IN
3282: IFFALSE 3436
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_heavy_machine_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
3284: LD_ADDR_VAR 0 5
3288: PUSH
3289: LD_INT 3
3291: PPUSH
3292: LD_INT 3
3294: PPUSH
3295: LD_INT 22
3297: PPUSH
3298: LD_INT 1
3300: PPUSH
3301: LD_INT 1
3303: PPUSH
3304: LD_INT 42
3306: PUSH
3307: LD_INT 43
3309: PUSH
3310: EMPTY
3311: LIST
3312: LIST
3313: PUSH
3314: LD_INT 1
3316: PPUSH
3317: LD_INT 2
3319: PPUSH
3320: CALL_OW 12
3324: ARRAY
3325: PPUSH
3326: LD_INT 100
3328: PPUSH
3329: CALL 474 0 7
3333: ST_TO_ADDR
// vehicles := Insert ( vehicles , vehicles + 1 , veh ) ;
3334: LD_ADDR_VAR 0 9
3338: PUSH
3339: LD_VAR 0 9
3343: PPUSH
3344: LD_VAR 0 9
3348: PUSH
3349: LD_INT 1
3351: PLUS
3352: PPUSH
3353: LD_VAR 0 5
3357: PPUSH
3358: CALL_OW 2
3362: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3363: LD_VAR 0 5
3367: PPUSH
3368: LD_INT 3
3370: PPUSH
3371: CALL_OW 233
// PlaceUnitXY ( veh , i [ 1 ] , i [ 2 ] , false ) ;
3375: LD_VAR 0 5
3379: PPUSH
3380: LD_VAR 0 2
3384: PUSH
3385: LD_INT 1
3387: ARRAY
3388: PPUSH
3389: LD_VAR 0 2
3393: PUSH
3394: LD_INT 2
3396: ARRAY
3397: PPUSH
3398: LD_INT 0
3400: PPUSH
3401: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
3405: LD_INT 0
3407: PPUSH
3408: LD_INT 3
3410: PPUSH
3411: LD_VAR 0 8
3415: PPUSH
3416: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3420: CALL_OW 44
3424: PPUSH
3425: LD_VAR 0 5
3429: PPUSH
3430: CALL_OW 52
// end ;
3434: GO 3281
3436: POP
3437: POP
// for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
3438: LD_ADDR_VAR 0 2
3442: PUSH
3443: DOUBLE
3444: LD_INT 1
3446: DEC
3447: ST_TO_ADDR
3448: LD_INT 3
3450: PUSH
3451: LD_INT 4
3453: PUSH
3454: LD_INT 5
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: LIST
3461: PUSH
3462: LD_OWVAR 67
3466: ARRAY
3467: PUSH
3468: FOR_TO
3469: IFFALSE 3529
// begin PrepareHuman ( false , 1 , skill ) ;
3471: LD_INT 0
3473: PPUSH
3474: LD_INT 1
3476: PPUSH
3477: LD_VAR 0 8
3481: PPUSH
3482: CALL_OW 380
// un := CreateHuman ;
3486: LD_ADDR_VAR 0 4
3490: PUSH
3491: CALL_OW 44
3495: ST_TO_ADDR
// PlaceUnitArea ( un , forestGuardArea , false ) ;
3496: LD_VAR 0 4
3500: PPUSH
3501: LD_INT 11
3503: PPUSH
3504: LD_INT 0
3506: PPUSH
3507: CALL_OW 49
// ru_forest := ru_forest ^ un ;
3511: LD_ADDR_EXP 47
3515: PUSH
3516: LD_EXP 47
3520: PUSH
3521: LD_VAR 0 4
3525: ADD
3526: ST_TO_ADDR
// end ;
3527: GO 3468
3529: POP
3530: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
3531: LD_ADDR_VAR 0 2
3535: PUSH
3536: DOUBLE
3537: LD_INT 1
3539: DEC
3540: ST_TO_ADDR
3541: LD_INT 2
3543: PUSH
3544: LD_INT 3
3546: PUSH
3547: LD_INT 4
3549: PUSH
3550: EMPTY
3551: LIST
3552: LIST
3553: LIST
3554: PUSH
3555: LD_OWVAR 67
3559: ARRAY
3560: PUSH
3561: FOR_TO
3562: IFFALSE 3622
// begin PrepareHuman ( false , 1 , skill ) ;
3564: LD_INT 0
3566: PPUSH
3567: LD_INT 1
3569: PPUSH
3570: LD_VAR 0 8
3574: PPUSH
3575: CALL_OW 380
// un := CreateHuman ;
3579: LD_ADDR_VAR 0 4
3583: PUSH
3584: CALL_OW 44
3588: ST_TO_ADDR
// PlaceUnitArea ( un , forestSouthGuardArea , false ) ;
3589: LD_VAR 0 4
3593: PPUSH
3594: LD_INT 12
3596: PPUSH
3597: LD_INT 0
3599: PPUSH
3600: CALL_OW 49
// ru_patrol := ru_patrol ^ un ;
3604: LD_ADDR_EXP 45
3608: PUSH
3609: LD_EXP 45
3613: PUSH
3614: LD_VAR 0 4
3618: ADD
3619: ST_TO_ADDR
// end ;
3620: GO 3561
3622: POP
3623: POP
// for i = 1 to 2 do
3624: LD_ADDR_VAR 0 2
3628: PUSH
3629: DOUBLE
3630: LD_INT 1
3632: DEC
3633: ST_TO_ADDR
3634: LD_INT 2
3636: PUSH
3637: FOR_TO
3638: IFFALSE 3704
// begin PrepareHuman ( false , 1 , skill ) ;
3640: LD_INT 0
3642: PPUSH
3643: LD_INT 1
3645: PPUSH
3646: LD_VAR 0 8
3650: PPUSH
3651: CALL_OW 380
// un := CreateHuman ;
3655: LD_ADDR_VAR 0 4
3659: PUSH
3660: CALL_OW 44
3664: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 12 , 3 , false ) ;
3665: LD_VAR 0 4
3669: PPUSH
3670: LD_INT 39
3672: PPUSH
3673: LD_INT 12
3675: PPUSH
3676: LD_INT 3
3678: PPUSH
3679: LD_INT 0
3681: PPUSH
3682: CALL_OW 50
// ru_spec_patrol := ru_spec_patrol ^ un ;
3686: LD_ADDR_EXP 46
3690: PUSH
3691: LD_EXP 46
3695: PUSH
3696: LD_VAR 0 4
3700: ADD
3701: ST_TO_ADDR
// end ;
3702: GO 3637
3704: POP
3705: POP
// ru_vehicles := vehicles ;
3706: LD_ADDR_EXP 48
3710: PUSH
3711: LD_VAR 0 9
3715: ST_TO_ADDR
// ru_firepoints_south := [ [ [ 131 , 121 ] , [ 113 , 90 ] , [ 93 , 62 ] ] , [ [ 106 , 54 ] , [ 120 , 80 ] , [ 143 , 120 ] ] , [ [ 154 , 116 ] , [ 140 , 93 ] , [ 130 , 58 ] ] , [ [ 105 , 106 ] , [ 134 , 98 ] , [ 159 , 113 ] ] , ] ;
3716: LD_ADDR_EXP 49
3720: PUSH
3721: LD_INT 131
3723: PUSH
3724: LD_INT 121
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: PUSH
3731: LD_INT 113
3733: PUSH
3734: LD_INT 90
3736: PUSH
3737: EMPTY
3738: LIST
3739: LIST
3740: PUSH
3741: LD_INT 93
3743: PUSH
3744: LD_INT 62
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: PUSH
3751: EMPTY
3752: LIST
3753: LIST
3754: LIST
3755: PUSH
3756: LD_INT 106
3758: PUSH
3759: LD_INT 54
3761: PUSH
3762: EMPTY
3763: LIST
3764: LIST
3765: PUSH
3766: LD_INT 120
3768: PUSH
3769: LD_INT 80
3771: PUSH
3772: EMPTY
3773: LIST
3774: LIST
3775: PUSH
3776: LD_INT 143
3778: PUSH
3779: LD_INT 120
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: PUSH
3786: EMPTY
3787: LIST
3788: LIST
3789: LIST
3790: PUSH
3791: LD_INT 154
3793: PUSH
3794: LD_INT 116
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: PUSH
3801: LD_INT 140
3803: PUSH
3804: LD_INT 93
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: PUSH
3811: LD_INT 130
3813: PUSH
3814: LD_INT 58
3816: PUSH
3817: EMPTY
3818: LIST
3819: LIST
3820: PUSH
3821: EMPTY
3822: LIST
3823: LIST
3824: LIST
3825: PUSH
3826: LD_INT 105
3828: PUSH
3829: LD_INT 106
3831: PUSH
3832: EMPTY
3833: LIST
3834: LIST
3835: PUSH
3836: LD_INT 134
3838: PUSH
3839: LD_INT 98
3841: PUSH
3842: EMPTY
3843: LIST
3844: LIST
3845: PUSH
3846: LD_INT 159
3848: PUSH
3849: LD_INT 113
3851: PUSH
3852: EMPTY
3853: LIST
3854: LIST
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: LIST
3860: PUSH
3861: EMPTY
3862: LIST
3863: LIST
3864: LIST
3865: LIST
3866: ST_TO_ADDR
// end ; end_of_file
3867: LD_VAR 0 1
3871: RET
// export function Action ; var i , units , vehicles , cargos , resources , cargo ; begin
3872: LD_INT 0
3874: PPUSH
3875: PPUSH
3876: PPUSH
3877: PPUSH
3878: PPUSH
3879: PPUSH
3880: PPUSH
// InGameOn ;
3881: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
3885: LD_EXP 29
3889: PPUSH
3890: CALL_OW 87
// ComTurnUnit ( JMM , Cornel ) ;
3894: LD_EXP 29
3898: PPUSH
3899: LD_EXP 36
3903: PPUSH
3904: CALL_OW 119
// if Bierezov then
3908: LD_EXP 37
3912: IFFALSE 3928
// ComTurnUnit ( Bierezov , Cornel ) ;
3914: LD_EXP 37
3918: PPUSH
3919: LD_EXP 36
3923: PPUSH
3924: CALL_OW 119
// for i in jmm_units do
3928: LD_ADDR_VAR 0 2
3932: PUSH
3933: LD_EXP 2
3937: PUSH
3938: FOR_IN
3939: IFFALSE 3957
// ComTurnUnit ( i , Cornel ) ;
3941: LD_VAR 0 2
3945: PPUSH
3946: LD_EXP 36
3950: PPUSH
3951: CALL_OW 119
3955: GO 3938
3957: POP
3958: POP
// units := cornel_units union Cornel ;
3959: LD_ADDR_VAR 0 3
3963: PUSH
3964: LD_EXP 4
3968: PUSH
3969: LD_EXP 36
3973: UNION
3974: ST_TO_ADDR
// repeat wait ( 1 ) ;
3975: LD_INT 1
3977: PPUSH
3978: CALL_OW 67
// for i in units do
3982: LD_ADDR_VAR 0 2
3986: PUSH
3987: LD_VAR 0 3
3991: PUSH
3992: FOR_IN
3993: IFFALSE 4026
// ComMoveXY ( i , GetX ( JMM ) , GetY ( JMM ) ) ;
3995: LD_VAR 0 2
3999: PPUSH
4000: LD_EXP 29
4004: PPUSH
4005: CALL_OW 250
4009: PPUSH
4010: LD_EXP 29
4014: PPUSH
4015: CALL_OW 251
4019: PPUSH
4020: CALL_OW 111
4024: GO 3992
4026: POP
4027: POP
// until UnitFilter ( units , [ f_distxy , GetX ( JMM ) , GetY ( JMM ) , 10 ] ) = units ;
4028: LD_VAR 0 3
4032: PPUSH
4033: LD_INT 92
4035: PUSH
4036: LD_EXP 29
4040: PPUSH
4041: CALL_OW 250
4045: PUSH
4046: LD_EXP 29
4050: PPUSH
4051: CALL_OW 251
4055: PUSH
4056: LD_INT 10
4058: PUSH
4059: EMPTY
4060: LIST
4061: LIST
4062: LIST
4063: LIST
4064: PPUSH
4065: CALL_OW 72
4069: PUSH
4070: LD_VAR 0 3
4074: EQUAL
4075: IFFALSE 3975
// for i in units do
4077: LD_ADDR_VAR 0 2
4081: PUSH
4082: LD_VAR 0 3
4086: PUSH
4087: FOR_IN
4088: IFFALSE 4106
// ComTurnUnit ( i , JMM ) ;
4090: LD_VAR 0 2
4094: PPUSH
4095: LD_EXP 29
4099: PPUSH
4100: CALL_OW 119
4104: GO 4087
4106: POP
4107: POP
// ComTurnUnit ( Cornel , JMM ) ;
4108: LD_EXP 36
4112: PPUSH
4113: LD_EXP 29
4117: PPUSH
4118: CALL_OW 119
// Say ( JMM , D1-JMM-1 ) ;
4122: LD_EXP 29
4126: PPUSH
4127: LD_STRING D1-JMM-1
4129: PPUSH
4130: CALL_OW 88
// Say ( Cornel , D1-Corn-1 ) ;
4134: LD_EXP 36
4138: PPUSH
4139: LD_STRING D1-Corn-1
4141: PPUSH
4142: CALL_OW 88
// ComMoveUnit ( JMM , Cornel ) ;
4146: LD_EXP 29
4150: PPUSH
4151: LD_EXP 36
4155: PPUSH
4156: CALL_OW 112
// ComMoveUnit ( Cornel , JMM ) ;
4160: LD_EXP 36
4164: PPUSH
4165: LD_EXP 29
4169: PPUSH
4170: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
4174: LD_INT 35
4176: PPUSH
4177: CALL_OW 67
// until GetDistUnits ( JMM , Cornel ) < 6 ;
4181: LD_EXP 29
4185: PPUSH
4186: LD_EXP 36
4190: PPUSH
4191: CALL_OW 296
4195: PUSH
4196: LD_INT 6
4198: LESS
4199: IFFALSE 4174
// ChangeSideFog ( 4 , 1 ) ;
4201: LD_INT 4
4203: PPUSH
4204: LD_INT 1
4206: PPUSH
4207: CALL_OW 343
// ComTurnUnit ( JMM , Cornel ) ;
4211: LD_EXP 29
4215: PPUSH
4216: LD_EXP 36
4220: PPUSH
4221: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
4225: LD_EXP 36
4229: PPUSH
4230: LD_EXP 29
4234: PPUSH
4235: CALL_OW 119
// Say ( JMM , D1-JMM-2 ) ;
4239: LD_EXP 29
4243: PPUSH
4244: LD_STRING D1-JMM-2
4246: PPUSH
4247: CALL_OW 88
// Say ( JMM , D1-JMM-2a ) ;
4251: LD_EXP 29
4255: PPUSH
4256: LD_STRING D1-JMM-2a
4258: PPUSH
4259: CALL_OW 88
// Say ( Cornel , D1-Corn-2 ) ;
4263: LD_EXP 36
4267: PPUSH
4268: LD_STRING D1-Corn-2
4270: PPUSH
4271: CALL_OW 88
// if bierezov_exist or debug then
4275: LD_EXP 5
4279: PUSH
4280: LD_EXP 1
4284: OR
4285: IFFALSE 4526
// begin ComTurnUnit ( Cornel , Bierezov ) ;
4287: LD_EXP 36
4291: PPUSH
4292: LD_EXP 37
4296: PPUSH
4297: CALL_OW 119
// Wait ( 0 0$0.3 ) ;
4301: LD_INT 10
4303: PPUSH
4304: CALL_OW 67
// Say ( Cornel , D1a-Corn-1 ) ;
4308: LD_EXP 36
4312: PPUSH
4313: LD_STRING D1a-Corn-1
4315: PPUSH
4316: CALL_OW 88
// ComTurnUnit ( JMM , Bierezov ) ;
4320: LD_EXP 29
4324: PPUSH
4325: LD_EXP 37
4329: PPUSH
4330: CALL_OW 119
// ComTurnUnit ( Bierezov , JMM ) ;
4334: LD_EXP 37
4338: PPUSH
4339: LD_EXP 29
4343: PPUSH
4344: CALL_OW 119
// Say ( JMM , D1a-JMM-1 ) ;
4348: LD_EXP 29
4352: PPUSH
4353: LD_STRING D1a-JMM-1
4355: PPUSH
4356: CALL_OW 88
// ComTurnUnit ( JMM , Cornel ) ;
4360: LD_EXP 29
4364: PPUSH
4365: LD_EXP 36
4369: PPUSH
4370: CALL_OW 119
// ComTurnUnit ( Cornel , JMM ) ;
4374: LD_EXP 36
4378: PPUSH
4379: LD_EXP 29
4383: PPUSH
4384: CALL_OW 119
// Say ( Cornel , D1a-Corn-2 ) ;
4388: LD_EXP 36
4392: PPUSH
4393: LD_STRING D1a-Corn-2
4395: PPUSH
4396: CALL_OW 88
// Say ( JMM , D1a-JMM-2 ) ;
4400: LD_EXP 29
4404: PPUSH
4405: LD_STRING D1a-JMM-2
4407: PPUSH
4408: CALL_OW 88
// Say ( Cornel , D1a-Corn-3 ) ;
4412: LD_EXP 36
4416: PPUSH
4417: LD_STRING D1a-Corn-3
4419: PPUSH
4420: CALL_OW 88
// Say ( JMM , D1a-JMM-3 ) ;
4424: LD_EXP 29
4428: PPUSH
4429: LD_STRING D1a-JMM-3
4431: PPUSH
4432: CALL_OW 88
// Say ( Cornel , D1a-Corn-4 ) ;
4436: LD_EXP 36
4440: PPUSH
4441: LD_STRING D1a-Corn-4
4443: PPUSH
4444: CALL_OW 88
// Say ( JMM , D1a-JMM-4 ) ;
4448: LD_EXP 29
4452: PPUSH
4453: LD_STRING D1a-JMM-4
4455: PPUSH
4456: CALL_OW 88
// Say ( Cornel , D1a-Corn-5 ) ;
4460: LD_EXP 36
4464: PPUSH
4465: LD_STRING D1a-Corn-5
4467: PPUSH
4468: CALL_OW 88
// ComMoveXY ( Bierezov , GetX ( Cornel ) , GetY ( Cornel ) - 2 ) ;
4472: LD_EXP 37
4476: PPUSH
4477: LD_EXP 36
4481: PPUSH
4482: CALL_OW 250
4486: PPUSH
4487: LD_EXP 36
4491: PPUSH
4492: CALL_OW 251
4496: PUSH
4497: LD_INT 2
4499: MINUS
4500: PPUSH
4501: CALL_OW 111
// AddComTurnUnit ( Bierezov , Cornel ) ;
4505: LD_EXP 37
4509: PPUSH
4510: LD_EXP 36
4514: PPUSH
4515: CALL_OW 179
// Wait ( 0 0$0.3 ) ;
4519: LD_INT 10
4521: PPUSH
4522: CALL_OW 67
// end ; Say ( JMM , D1b-JMM-1 ) ;
4526: LD_EXP 29
4530: PPUSH
4531: LD_STRING D1b-JMM-1
4533: PPUSH
4534: CALL_OW 88
// Say ( Cornel , D1b-Corn-1 ) ;
4538: LD_EXP 36
4542: PPUSH
4543: LD_STRING D1b-Corn-1
4545: PPUSH
4546: CALL_OW 88
// Say ( JMM , D1b-JMM-2 ) ;
4550: LD_EXP 29
4554: PPUSH
4555: LD_STRING D1b-JMM-2
4557: PPUSH
4558: CALL_OW 88
// Say ( Cornel , D1b-Corn-2 ) ;
4562: LD_EXP 36
4566: PPUSH
4567: LD_STRING D1b-Corn-2
4569: PPUSH
4570: CALL_OW 88
// Say ( JMM , D1b-JMM-3 ) ;
4574: LD_EXP 29
4578: PPUSH
4579: LD_STRING D1b-JMM-3
4581: PPUSH
4582: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
4586: LD_INT 10
4588: PPUSH
4589: CALL_OW 67
// SayRadio ( Powell , D1b-Pow-3 ) ;
4593: LD_EXP 38
4597: PPUSH
4598: LD_STRING D1b-Pow-3
4600: PPUSH
4601: CALL_OW 94
// Say ( JMM , D1b-JMM-4 ) ;
4605: LD_EXP 29
4609: PPUSH
4610: LD_STRING D1b-JMM-4
4612: PPUSH
4613: CALL_OW 88
// Say ( Cornel , D1b-Corn-4 ) ;
4617: LD_EXP 36
4621: PPUSH
4622: LD_STRING D1b-Corn-4
4624: PPUSH
4625: CALL_OW 88
// if Khatam then
4629: LD_EXP 33
4633: IFFALSE 4649
// Say ( Khatam , D1b-Khat-4 ) else
4635: LD_EXP 33
4639: PPUSH
4640: LD_STRING D1b-Khat-4
4642: PPUSH
4643: CALL_OW 88
4647: GO 4685
// SayX ( UnitFilter ( cornel_units , [ f_sex , sex_male ] ) diff [ Cornel ] , D1b-Sol1-4 ) ;
4649: LD_EXP 4
4653: PPUSH
4654: LD_INT 26
4656: PUSH
4657: LD_INT 1
4659: PUSH
4660: EMPTY
4661: LIST
4662: LIST
4663: PPUSH
4664: CALL_OW 72
4668: PUSH
4669: LD_EXP 36
4673: PUSH
4674: EMPTY
4675: LIST
4676: DIFF
4677: PPUSH
4678: LD_STRING D1b-Sol1-4
4680: PPUSH
4681: CALL 562 0 2
// if Cyrus then
4685: LD_EXP 31
4689: IFFALSE 4703
// Say ( Cyrus , D1b-Cyrus-4 ) ;
4691: LD_EXP 31
4695: PPUSH
4696: LD_STRING D1b-Cyrus-4
4698: PPUSH
4699: CALL_OW 88
// if Lisa then
4703: LD_EXP 32
4707: IFFALSE 4765
// begin Say ( Lisa , D1b-Lisa-4 ) ;
4709: LD_EXP 32
4713: PPUSH
4714: LD_STRING D1b-Lisa-4
4716: PPUSH
4717: CALL_OW 88
// if Cyrus then
4721: LD_EXP 31
4725: IFFALSE 4765
// begin if not IsInUnit ( Cyrus ) then
4727: LD_EXP 31
4731: PPUSH
4732: CALL_OW 310
4736: NOT
4737: IFFALSE 4753
// ComTurnUnit ( Cyrus , Lisa ) ;
4739: LD_EXP 31
4743: PPUSH
4744: LD_EXP 32
4748: PPUSH
4749: CALL_OW 119
// Say ( Cyrus , D1b-Cyrus-5 ) ;
4753: LD_EXP 31
4757: PPUSH
4758: LD_STRING D1b-Cyrus-5
4760: PPUSH
4761: CALL_OW 88
// end ; end ; SelectGroup ;
4765: CALL 2515 0 0
// Say ( JMM , D1d-JMM-1 ) ;
4769: LD_EXP 29
4773: PPUSH
4774: LD_STRING D1d-JMM-1
4776: PPUSH
4777: CALL_OW 88
// Say ( Cornel , D1d-Corn-1 ) ;
4781: LD_EXP 36
4785: PPUSH
4786: LD_STRING D1d-Corn-1
4788: PPUSH
4789: CALL_OW 88
// for i in jmm_units ^ cornel_units ^ JMM do
4793: LD_ADDR_VAR 0 2
4797: PUSH
4798: LD_EXP 2
4802: PUSH
4803: LD_EXP 4
4807: ADD
4808: PUSH
4809: LD_EXP 29
4813: ADD
4814: PUSH
4815: FOR_IN
4816: IFFALSE 4829
// ComHold ( i ) ;
4818: LD_VAR 0 2
4822: PPUSH
4823: CALL_OW 140
4827: GO 4815
4829: POP
4830: POP
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
4831: LD_ADDR_VAR 0 4
4835: PUSH
4836: LD_INT 22
4838: PUSH
4839: LD_INT 1
4841: PUSH
4842: EMPTY
4843: LIST
4844: LIST
4845: PUSH
4846: LD_INT 21
4848: PUSH
4849: LD_INT 2
4851: PUSH
4852: EMPTY
4853: LIST
4854: LIST
4855: PUSH
4856: EMPTY
4857: LIST
4858: LIST
4859: PPUSH
4860: CALL_OW 69
4864: ST_TO_ADDR
// if vehicles then
4865: LD_VAR 0 4
4869: IFFALSE 5207
// begin if UnitFilter ( cornel_units , [ f_driving ] ) then
4871: LD_EXP 4
4875: PPUSH
4876: LD_INT 55
4878: PUSH
4879: EMPTY
4880: LIST
4881: PPUSH
4882: CALL_OW 72
4886: IFFALSE 4925
// for i in UnitFilter ( cornel_units , [ f_driving ] ) do
4888: LD_ADDR_VAR 0 2
4892: PUSH
4893: LD_EXP 4
4897: PPUSH
4898: LD_INT 55
4900: PUSH
4901: EMPTY
4902: LIST
4903: PPUSH
4904: CALL_OW 72
4908: PUSH
4909: FOR_IN
4910: IFFALSE 4923
// ComExitVehicle ( i ) ;
4912: LD_VAR 0 2
4916: PPUSH
4917: CALL_OW 121
4921: GO 4909
4923: POP
4924: POP
// cargos := UnitFilter ( vehicles , [ f_weapon , ru_cargo_bay ] ) ;
4925: LD_ADDR_VAR 0 5
4929: PUSH
4930: LD_VAR 0 4
4934: PPUSH
4935: LD_INT 34
4937: PUSH
4938: LD_INT 51
4940: PUSH
4941: EMPTY
4942: LIST
4943: LIST
4944: PPUSH
4945: CALL_OW 72
4949: ST_TO_ADDR
// if cargos then
4950: LD_VAR 0 5
4954: IFFALSE 5137
// begin vehicles := cargos ;
4956: LD_ADDR_VAR 0 4
4960: PUSH
4961: LD_VAR 0 5
4965: ST_TO_ADDR
// resources := LoadVariable ( 02_resources_4 , 0 ) ;
4966: LD_ADDR_VAR 0 6
4970: PUSH
4971: LD_STRING 02_resources_4
4973: PPUSH
4974: LD_INT 0
4976: PPUSH
4977: CALL_OW 30
4981: ST_TO_ADDR
// if debug and not resources then
4982: LD_EXP 1
4986: PUSH
4987: LD_VAR 0 6
4991: NOT
4992: AND
4993: IFFALSE 5003
// resources := 160 ;
4995: LD_ADDR_VAR 0 6
4999: PUSH
5000: LD_INT 160
5002: ST_TO_ADDR
// if resources mod 10 then
5003: LD_VAR 0 6
5007: PUSH
5008: LD_INT 10
5010: MOD
5011: IFFALSE 5033
// resources := resources - resources mod 10 ;
5013: LD_ADDR_VAR 0 6
5017: PUSH
5018: LD_VAR 0 6
5022: PUSH
5023: LD_VAR 0 6
5027: PUSH
5028: LD_INT 10
5030: MOD
5031: MINUS
5032: ST_TO_ADDR
// if resources then
5033: LD_VAR 0 6
5037: IFFALSE 5137
// for i in cargos do
5039: LD_ADDR_VAR 0 2
5043: PUSH
5044: LD_VAR 0 5
5048: PUSH
5049: FOR_IN
5050: IFFALSE 5135
// begin if resources < 100 then
5052: LD_VAR 0 6
5056: PUSH
5057: LD_INT 100
5059: LESS
5060: IFFALSE 5082
// begin cargo := resources ;
5062: LD_ADDR_VAR 0 7
5066: PUSH
5067: LD_VAR 0 6
5071: ST_TO_ADDR
// resources := 0 ;
5072: LD_ADDR_VAR 0 6
5076: PUSH
5077: LD_INT 0
5079: ST_TO_ADDR
// end else
5080: GO 5104
// begin cargo := 100 ;
5082: LD_ADDR_VAR 0 7
5086: PUSH
5087: LD_INT 100
5089: ST_TO_ADDR
// resources := resources - 100 ;
5090: LD_ADDR_VAR 0 6
5094: PUSH
5095: LD_VAR 0 6
5099: PUSH
5100: LD_INT 100
5102: MINUS
5103: ST_TO_ADDR
// end ; SetCargo ( i , mat_cans , cargo ) ;
5104: LD_VAR 0 2
5108: PPUSH
5109: LD_INT 1
5111: PPUSH
5112: LD_VAR 0 7
5116: PPUSH
5117: CALL_OW 290
// if resources = 0 then
5121: LD_VAR 0 6
5125: PUSH
5126: LD_INT 0
5128: EQUAL
5129: IFFALSE 5133
// break ;
5131: GO 5135
// end ;
5133: GO 5049
5135: POP
5136: POP
// end ; ComExitVehicle ( IsDrivenBy ( vehicles [ 1 ] ) ) ;
5137: LD_VAR 0 4
5141: PUSH
5142: LD_INT 1
5144: ARRAY
5145: PPUSH
5146: CALL_OW 311
5150: PPUSH
5151: CALL_OW 121
// SetSide ( vehicles [ 1 ] , 4 ) ;
5155: LD_VAR 0 4
5159: PUSH
5160: LD_INT 1
5162: ARRAY
5163: PPUSH
5164: LD_INT 4
5166: PPUSH
5167: CALL_OW 235
// ComEnterUnit ( Cornel , vehicles [ 1 ] ) ;
5171: LD_EXP 36
5175: PPUSH
5176: LD_VAR 0 4
5180: PUSH
5181: LD_INT 1
5183: ARRAY
5184: PPUSH
5185: CALL_OW 120
// repeat wait ( 0 0$01 ) ;
5189: LD_INT 35
5191: PPUSH
5192: CALL_OW 67
// until IsInUnit ( Cornel ) ;
5196: LD_EXP 36
5200: PPUSH
5201: CALL_OW 310
5205: IFFALSE 5189
// end ; InGameOff ;
5207: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
5211: LD_STRING M1
5213: PPUSH
5214: CALL_OW 337
// SaveForQuickRestart ;
5218: CALL_OW 22
// cornel_active := true ;
5222: LD_ADDR_EXP 6
5226: PUSH
5227: LD_INT 1
5229: ST_TO_ADDR
// end ;
5230: LD_VAR 0 1
5234: RET
// every 0 0$01 trigger GetDistUnits ( JMM , Lynch ) < 10 do var i , points , sol , buns ;
5235: LD_EXP 29
5239: PPUSH
5240: LD_EXP 39
5244: PPUSH
5245: CALL_OW 296
5249: PUSH
5250: LD_INT 10
5252: LESS
5253: IFFALSE 6368
5255: GO 5257
5257: DISABLE
5258: LD_INT 0
5260: PPUSH
5261: PPUSH
5262: PPUSH
5263: PPUSH
// begin points := [ [ 89 , 34 ] , [ 138 , 63 ] , [ 196 , 84 ] , [ 135 , 52 ] , [ 103 , 39 ] , [ 58 , 30 ] , [ 38 , 51 ] ] ;
5264: LD_ADDR_VAR 0 2
5268: PUSH
5269: LD_INT 89
5271: PUSH
5272: LD_INT 34
5274: PUSH
5275: EMPTY
5276: LIST
5277: LIST
5278: PUSH
5279: LD_INT 138
5281: PUSH
5282: LD_INT 63
5284: PUSH
5285: EMPTY
5286: LIST
5287: LIST
5288: PUSH
5289: LD_INT 196
5291: PUSH
5292: LD_INT 84
5294: PUSH
5295: EMPTY
5296: LIST
5297: LIST
5298: PUSH
5299: LD_INT 135
5301: PUSH
5302: LD_INT 52
5304: PUSH
5305: EMPTY
5306: LIST
5307: LIST
5308: PUSH
5309: LD_INT 103
5311: PUSH
5312: LD_INT 39
5314: PUSH
5315: EMPTY
5316: LIST
5317: LIST
5318: PUSH
5319: LD_INT 58
5321: PUSH
5322: LD_INT 30
5324: PUSH
5325: EMPTY
5326: LIST
5327: LIST
5328: PUSH
5329: LD_INT 38
5331: PUSH
5332: LD_INT 51
5334: PUSH
5335: EMPTY
5336: LIST
5337: LIST
5338: PUSH
5339: EMPTY
5340: LIST
5341: LIST
5342: LIST
5343: LIST
5344: LIST
5345: LIST
5346: LIST
5347: ST_TO_ADDR
// InGameOn ;
5348: CALL_OW 8
// if jmm_units then
5352: LD_EXP 2
5356: IFFALSE 5420
// for i in jmm_units do
5358: LD_ADDR_VAR 0 1
5362: PUSH
5363: LD_EXP 2
5367: PUSH
5368: FOR_IN
5369: IFFALSE 5418
// begin if GetDistUnits ( i , JMM ) < 10 then
5371: LD_VAR 0 1
5375: PPUSH
5376: LD_EXP 29
5380: PPUSH
5381: CALL_OW 296
5385: PUSH
5386: LD_INT 10
5388: LESS
5389: IFFALSE 5407
// ComTurnUnit ( i , JMM ) else
5391: LD_VAR 0 1
5395: PPUSH
5396: LD_EXP 29
5400: PPUSH
5401: CALL_OW 119
5405: GO 5416
// ComHold ( i ) ;
5407: LD_VAR 0 1
5411: PPUSH
5412: CALL_OW 140
// end ;
5416: GO 5368
5418: POP
5419: POP
// ComMoveUnit ( JMM , Lynch ) ;
5420: LD_EXP 29
5424: PPUSH
5425: LD_EXP 39
5429: PPUSH
5430: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
5434: LD_INT 35
5436: PPUSH
5437: CALL_OW 67
// until GetDistUnits ( JMM , Lynch ) < 6 ;
5441: LD_EXP 29
5445: PPUSH
5446: LD_EXP 39
5450: PPUSH
5451: CALL_OW 296
5455: PUSH
5456: LD_INT 6
5458: LESS
5459: IFFALSE 5434
// ComTurnUnit ( JMM , Lynch ) ;
5461: LD_EXP 29
5465: PPUSH
5466: LD_EXP 39
5470: PPUSH
5471: CALL_OW 119
// for i in [ Lynch , Walker , Turner , Jillian ] do
5475: LD_ADDR_VAR 0 1
5479: PUSH
5480: LD_EXP 39
5484: PUSH
5485: LD_EXP 40
5489: PUSH
5490: LD_EXP 41
5494: PUSH
5495: LD_EXP 42
5499: PUSH
5500: EMPTY
5501: LIST
5502: LIST
5503: LIST
5504: LIST
5505: PUSH
5506: FOR_IN
5507: IFFALSE 5525
// ComTurnUnit ( i , JMM ) ;
5509: LD_VAR 0 1
5513: PPUSH
5514: LD_EXP 29
5518: PPUSH
5519: CALL_OW 119
5523: GO 5506
5525: POP
5526: POP
// Wait ( 0 0$0.3 ) ;
5527: LD_INT 10
5529: PPUSH
5530: CALL_OW 67
// Say ( JMM , D2-JMM-1 ) ;
5534: LD_EXP 29
5538: PPUSH
5539: LD_STRING D2-JMM-1
5541: PPUSH
5542: CALL_OW 88
// Say ( Lynch , D2-Sol1-1 ) ;
5546: LD_EXP 39
5550: PPUSH
5551: LD_STRING D2-Sol1-1
5553: PPUSH
5554: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
5558: LD_EXP 29
5562: PPUSH
5563: LD_STRING D2-JMM-2
5565: PPUSH
5566: CALL_OW 88
// Say ( Lynch , D2-Sol1-2 ) ;
5570: LD_EXP 39
5574: PPUSH
5575: LD_STRING D2-Sol1-2
5577: PPUSH
5578: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
5582: LD_EXP 29
5586: PPUSH
5587: LD_STRING D2-JMM-3
5589: PPUSH
5590: CALL_OW 88
// Say ( Lynch , D2-Sol1-3 ) ;
5594: LD_EXP 39
5598: PPUSH
5599: LD_STRING D2-Sol1-3
5601: PPUSH
5602: CALL_OW 88
// for i in FilterAllUnits ( [ f_side , 8 ] ) do
5606: LD_ADDR_VAR 0 1
5610: PUSH
5611: LD_INT 22
5613: PUSH
5614: LD_INT 8
5616: PUSH
5617: EMPTY
5618: LIST
5619: LIST
5620: PPUSH
5621: CALL_OW 69
5625: PUSH
5626: FOR_IN
5627: IFFALSE 5643
// SetSide ( i , 1 ) ;
5629: LD_VAR 0 1
5633: PPUSH
5634: LD_INT 1
5636: PPUSH
5637: CALL_OW 235
5641: GO 5626
5643: POP
5644: POP
// Say ( JMM , D2-JMM-4 ) ;
5645: LD_EXP 29
5649: PPUSH
5650: LD_STRING D2-JMM-4
5652: PPUSH
5653: CALL_OW 88
// RevealFogArea ( 1 , roadArea ) ;
5657: LD_INT 1
5659: PPUSH
5660: LD_INT 5
5662: PPUSH
5663: CALL_OW 332
// for i = 1 to points do
5667: LD_ADDR_VAR 0 1
5671: PUSH
5672: DOUBLE
5673: LD_INT 1
5675: DEC
5676: ST_TO_ADDR
5677: LD_VAR 0 2
5681: PUSH
5682: FOR_TO
5683: IFFALSE 5858
// begin CenterOnXY ( points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
5685: LD_VAR 0 2
5689: PUSH
5690: LD_VAR 0 1
5694: ARRAY
5695: PUSH
5696: LD_INT 1
5698: ARRAY
5699: PPUSH
5700: LD_VAR 0 2
5704: PUSH
5705: LD_VAR 0 1
5709: ARRAY
5710: PUSH
5711: LD_INT 2
5713: ARRAY
5714: PPUSH
5715: CALL_OW 84
// if i = 1 then
5719: LD_VAR 0 1
5723: PUSH
5724: LD_INT 1
5726: EQUAL
5727: IFFALSE 5741
// Say ( Lynch , D2-Sol1-4 ) ;
5729: LD_EXP 39
5733: PPUSH
5734: LD_STRING D2-Sol1-4
5736: PPUSH
5737: CALL_OW 88
// if i = 2 then
5741: LD_VAR 0 1
5745: PUSH
5746: LD_INT 2
5748: EQUAL
5749: IFFALSE 5763
// Say ( JMM , D2-JMM-5 ) ;
5751: LD_EXP 29
5755: PPUSH
5756: LD_STRING D2-JMM-5
5758: PPUSH
5759: CALL_OW 88
// if i = 4 then
5763: LD_VAR 0 1
5767: PUSH
5768: LD_INT 4
5770: EQUAL
5771: IFFALSE 5795
// begin RevealFogArea ( 1 , troopsArea ) ;
5773: LD_INT 1
5775: PPUSH
5776: LD_INT 6
5778: PPUSH
5779: CALL_OW 332
// Say ( Lynch , D2-Sol1-5 ) ;
5783: LD_EXP 39
5787: PPUSH
5788: LD_STRING D2-Sol1-5
5790: PPUSH
5791: CALL_OW 88
// end ; if i = 5 then
5795: LD_VAR 0 1
5799: PUSH
5800: LD_INT 5
5802: EQUAL
5803: IFFALSE 5817
// Say ( JMM , D2-JMM-6 ) ;
5805: LD_EXP 29
5809: PPUSH
5810: LD_STRING D2-JMM-6
5812: PPUSH
5813: CALL_OW 88
// if i = 7 then
5817: LD_VAR 0 1
5821: PUSH
5822: LD_INT 7
5824: EQUAL
5825: IFFALSE 5849
// begin RevealFogArea ( 1 , forestArea ) ;
5827: LD_INT 1
5829: PPUSH
5830: LD_INT 7
5832: PPUSH
5833: CALL_OW 332
// Say ( Lynch , D2-Sol1-6 ) ;
5837: LD_EXP 39
5841: PPUSH
5842: LD_STRING D2-Sol1-6
5844: PPUSH
5845: CALL_OW 88
// end ; Wait ( 0 0$1.3 ) ;
5849: LD_INT 46
5851: PPUSH
5852: CALL_OW 67
// end ;
5856: GO 5682
5858: POP
5859: POP
// CenterNowOnUnits ( JMM ) ;
5860: LD_EXP 29
5864: PPUSH
5865: CALL_OW 87
// Say ( JMM , D2-JMM-7 ) ;
5869: LD_EXP 29
5873: PPUSH
5874: LD_STRING D2-JMM-7
5876: PPUSH
5877: CALL_OW 88
// Say ( Lynch , D2-Sol1-7 ) ;
5881: LD_EXP 39
5885: PPUSH
5886: LD_STRING D2-Sol1-7
5888: PPUSH
5889: CALL_OW 88
// Say ( JMM , D2-JMM-8 ) ;
5893: LD_EXP 29
5897: PPUSH
5898: LD_STRING D2-JMM-8
5900: PPUSH
5901: CALL_OW 88
// buns := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
5905: LD_ADDR_VAR 0 4
5909: PUSH
5910: LD_INT 22
5912: PUSH
5913: LD_INT 1
5915: PUSH
5916: EMPTY
5917: LIST
5918: LIST
5919: PUSH
5920: LD_INT 30
5922: PUSH
5923: LD_INT 31
5925: PUSH
5926: EMPTY
5927: LIST
5928: LIST
5929: PUSH
5930: EMPTY
5931: LIST
5932: LIST
5933: PPUSH
5934: CALL_OW 69
5938: ST_TO_ADDR
// ComEnterUnit ( Lynch , buns [ 1 ] ) ;
5939: LD_EXP 39
5943: PPUSH
5944: LD_VAR 0 4
5948: PUSH
5949: LD_INT 1
5951: ARRAY
5952: PPUSH
5953: CALL_OW 120
// sol := NearestUnitToUnit ( UnitFilter ( jmm_units , [ f_class , 1 ] ) , JMM ) ;
5957: LD_ADDR_VAR 0 3
5961: PUSH
5962: LD_EXP 2
5966: PPUSH
5967: LD_INT 25
5969: PUSH
5970: LD_INT 1
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: PPUSH
5977: CALL_OW 72
5981: PPUSH
5982: LD_EXP 29
5986: PPUSH
5987: CALL_OW 74
5991: ST_TO_ADDR
// if sol then
5992: LD_VAR 0 3
5996: IFFALSE 6036
// if GetDistUnits ( JMM , sol ) < 10 then
5998: LD_EXP 29
6002: PPUSH
6003: LD_VAR 0 3
6007: PPUSH
6008: CALL_OW 296
6012: PUSH
6013: LD_INT 10
6015: LESS
6016: IFFALSE 6036
// ComEnterUnit ( sol , buns [ 2 ] ) ;
6018: LD_VAR 0 3
6022: PPUSH
6023: LD_VAR 0 4
6027: PUSH
6028: LD_INT 2
6030: ARRAY
6031: PPUSH
6032: CALL_OW 120
// Wait ( 0 0$0.3 ) ;
6036: LD_INT 10
6038: PPUSH
6039: CALL_OW 67
// ComMoveXY ( JMM , 65 , 101 ) ;
6043: LD_EXP 29
6047: PPUSH
6048: LD_INT 65
6050: PPUSH
6051: LD_INT 101
6053: PPUSH
6054: CALL_OW 111
// AddComTurnXY ( JMM , 63 , 100 ) ;
6058: LD_EXP 29
6062: PPUSH
6063: LD_INT 63
6065: PPUSH
6066: LD_INT 100
6068: PPUSH
6069: CALL_OW 178
// repeat wait ( 0 0$01 ) ;
6073: LD_INT 35
6075: PPUSH
6076: CALL_OW 67
// until IsAt ( JMM , 65 , 101 ) ;
6080: LD_EXP 29
6084: PPUSH
6085: LD_INT 65
6087: PPUSH
6088: LD_INT 101
6090: PPUSH
6091: CALL_OW 307
6095: IFFALSE 6073
// Say ( JMM , D2a-JMM-1 ) ;
6097: LD_EXP 29
6101: PPUSH
6102: LD_STRING D2a-JMM-1
6104: PPUSH
6105: CALL_OW 88
// ComMoveXY ( Walker , 66 , 103 ) ;
6109: LD_EXP 40
6113: PPUSH
6114: LD_INT 66
6116: PPUSH
6117: LD_INT 103
6119: PPUSH
6120: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
6124: LD_INT 35
6126: PPUSH
6127: CALL_OW 67
// until IsAt ( Walker , 66 , 103 ) ;
6131: LD_EXP 40
6135: PPUSH
6136: LD_INT 66
6138: PPUSH
6139: LD_INT 103
6141: PPUSH
6142: CALL_OW 307
6146: IFFALSE 6124
// ComTurnUnit ( Walker , JMM ) ;
6148: LD_EXP 40
6152: PPUSH
6153: LD_EXP 29
6157: PPUSH
6158: CALL_OW 119
// Say ( Walker , D2a-Sci1-1 ) ;
6162: LD_EXP 40
6166: PPUSH
6167: LD_STRING D2a-Sci1-1
6169: PPUSH
6170: CALL_OW 88
// ComTurnUnit ( JMM , Walker ) ;
6174: LD_EXP 29
6178: PPUSH
6179: LD_EXP 40
6183: PPUSH
6184: CALL_OW 119
// Say ( JMM , D2a-JMM-2 ) ;
6188: LD_EXP 29
6192: PPUSH
6193: LD_STRING D2a-JMM-2
6195: PPUSH
6196: CALL_OW 88
// Say ( Walker , D2a-Sci1-2 ) ;
6200: LD_EXP 40
6204: PPUSH
6205: LD_STRING D2a-Sci1-2
6207: PPUSH
6208: CALL_OW 88
// Say ( JMM , D2a-JMM-3 ) ;
6212: LD_EXP 29
6216: PPUSH
6217: LD_STRING D2a-JMM-3
6219: PPUSH
6220: CALL_OW 88
// Say ( Walker , D2a-Sci1-3 ) ;
6224: LD_EXP 40
6228: PPUSH
6229: LD_STRING D2a-Sci1-3
6231: PPUSH
6232: CALL_OW 88
// jmm_units := jmm_units ^ [ Lynch , Walker , Turner , Jillian ] ;
6236: LD_ADDR_EXP 2
6240: PUSH
6241: LD_EXP 2
6245: PUSH
6246: LD_EXP 39
6250: PUSH
6251: LD_EXP 40
6255: PUSH
6256: LD_EXP 41
6260: PUSH
6261: LD_EXP 42
6265: PUSH
6266: EMPTY
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: ADD
6272: ST_TO_ADDR
// for i in jmm_units do
6273: LD_ADDR_VAR 0 1
6277: PUSH
6278: LD_EXP 2
6282: PUSH
6283: FOR_IN
6284: IFFALSE 6309
// if not IsInUnit ( i ) then
6286: LD_VAR 0 1
6290: PPUSH
6291: CALL_OW 310
6295: NOT
6296: IFFALSE 6307
// ComFree ( i ) ;
6298: LD_VAR 0 1
6302: PPUSH
6303: CALL_OW 139
6307: GO 6283
6309: POP
6310: POP
// InGameOff ;
6311: CALL_OW 9
// ChangeMissionObjectives ( MSolar1 ) ;
6315: LD_STRING MSolar1
6317: PPUSH
6318: CALL_OW 337
// jmm_on_west := true ;
6322: LD_ADDR_EXP 3
6326: PUSH
6327: LD_INT 1
6329: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
6330: LD_INT 1050
6332: PPUSH
6333: CALL_OW 67
// frank_can_return := true ;
6337: LD_ADDR_EXP 10
6341: PUSH
6342: LD_INT 1
6344: ST_TO_ADDR
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
6345: LD_INT 6300
6347: PPUSH
6348: LD_INT 8400
6350: PPUSH
6351: CALL_OW 12
6355: PPUSH
6356: CALL_OW 67
// send_spec_patrol := true ;
6360: LD_ADDR_EXP 25
6364: PUSH
6365: LD_INT 1
6367: ST_TO_ADDR
// end ;
6368: PPOPN 4
6370: END
// every 0 0$01 trigger FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) and not jmm_on_west do var i , filter ;
6371: LD_INT 22
6373: PUSH
6374: LD_INT 1
6376: PUSH
6377: EMPTY
6378: LIST
6379: LIST
6380: PUSH
6381: LD_INT 34
6383: PUSH
6384: LD_INT 51
6386: PUSH
6387: EMPTY
6388: LIST
6389: LIST
6390: PUSH
6391: LD_INT 92
6393: PUSH
6394: LD_INT 63
6396: PUSH
6397: LD_INT 100
6399: PUSH
6400: LD_INT 5
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: LIST
6413: PUSH
6414: EMPTY
6415: LIST
6416: PPUSH
6417: CALL_OW 69
6421: PUSH
6422: LD_EXP 3
6426: NOT
6427: AND
6428: IFFALSE 6541
6430: GO 6432
6432: DISABLE
6433: LD_INT 0
6435: PPUSH
6436: PPUSH
// begin enable ;
6437: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_weapon , ru_cargo_bay ] , [ f_distxy , 63 , 100 , 5 ] ] ] ) ;
6438: LD_ADDR_VAR 0 2
6442: PUSH
6443: LD_INT 22
6445: PUSH
6446: LD_INT 1
6448: PUSH
6449: EMPTY
6450: LIST
6451: LIST
6452: PUSH
6453: LD_INT 34
6455: PUSH
6456: LD_INT 51
6458: PUSH
6459: EMPTY
6460: LIST
6461: LIST
6462: PUSH
6463: LD_INT 92
6465: PUSH
6466: LD_INT 63
6468: PUSH
6469: LD_INT 100
6471: PUSH
6472: LD_INT 5
6474: PUSH
6475: EMPTY
6476: LIST
6477: LIST
6478: LIST
6479: LIST
6480: PUSH
6481: EMPTY
6482: LIST
6483: LIST
6484: LIST
6485: PUSH
6486: EMPTY
6487: LIST
6488: PPUSH
6489: CALL_OW 69
6493: ST_TO_ADDR
// if not filter then
6494: LD_VAR 0 2
6498: NOT
6499: IFFALSE 6503
// exit ;
6501: GO 6541
// for i in filter do
6503: LD_ADDR_VAR 0 1
6507: PUSH
6508: LD_VAR 0 2
6512: PUSH
6513: FOR_IN
6514: IFFALSE 6539
// begin SetFuel ( i , 0 ) ;
6516: LD_VAR 0 1
6520: PPUSH
6521: LD_INT 0
6523: PPUSH
6524: CALL_OW 240
// ComStop ( i ) ;
6528: LD_VAR 0 1
6532: PPUSH
6533: CALL_OW 141
// end ;
6537: GO 6513
6539: POP
6540: POP
// end ;
6541: PPOPN 2
6543: END
// every 0 0$01 trigger send_spec_patrol do var dead1 , dead2 , inarea1 , inarea2 , sol , tmp ; var i ;
6544: LD_EXP 25
6548: IFFALSE 7493
6550: GO 6552
6552: DISABLE
6553: LD_INT 0
6555: PPUSH
6556: PPUSH
6557: PPUSH
6558: PPUSH
6559: PPUSH
6560: PPUSH
6561: PPUSH
// begin if not ru_spec_patrol then
6562: LD_EXP 46
6566: NOT
6567: IFFALSE 6571
// exit ;
6569: GO 7493
// dead1 := false ;
6571: LD_ADDR_VAR 0 1
6575: PUSH
6576: LD_INT 0
6578: ST_TO_ADDR
// dead2 := false ;
6579: LD_ADDR_VAR 0 2
6583: PUSH
6584: LD_INT 0
6586: ST_TO_ADDR
// inarea1 := false ;
6587: LD_ADDR_VAR 0 3
6591: PUSH
6592: LD_INT 0
6594: ST_TO_ADDR
// inarea2 := false ;
6595: LD_ADDR_VAR 0 4
6599: PUSH
6600: LD_INT 0
6602: ST_TO_ADDR
// tmp := [ ] ;
6603: LD_ADDR_VAR 0 6
6607: PUSH
6608: EMPTY
6609: ST_TO_ADDR
// ComAgressiveMove ( ru_spec_patrol , 75 , 101 ) ;
6610: LD_EXP 46
6614: PPUSH
6615: LD_INT 75
6617: PPUSH
6618: LD_INT 101
6620: PPUSH
6621: CALL_OW 114
// repeat wait ( 0 0$01 ) ;
6625: LD_INT 35
6627: PPUSH
6628: CALL_OW 67
// until See ( 1 , ru_spec_patrol [ 1 ] ) ;
6632: LD_INT 1
6634: PPUSH
6635: LD_EXP 46
6639: PUSH
6640: LD_INT 1
6642: ARRAY
6643: PPUSH
6644: CALL_OW 292
6648: IFFALSE 6625
// ComStop ( ru_spec_patrol ) ;
6650: LD_EXP 46
6654: PPUSH
6655: CALL_OW 141
// Wait ( 0 0$02 ) ;
6659: LD_INT 70
6661: PPUSH
6662: CALL_OW 67
// DialogueOn ;
6666: CALL_OW 6
// Say ( ru_spec_patrol [ 1 ] , D8-Rus1-1 ) ;
6670: LD_EXP 46
6674: PUSH
6675: LD_INT 1
6677: ARRAY
6678: PPUSH
6679: LD_STRING D8-Rus1-1
6681: PPUSH
6682: CALL_OW 88
// Say ( JMM , D8-JMM-1 ) ;
6686: LD_EXP 29
6690: PPUSH
6691: LD_STRING D8-JMM-1
6693: PPUSH
6694: CALL_OW 88
// DialogueOff ;
6698: CALL_OW 7
// ComMoveToArea ( ru_spec_patrol , retreatArea ) ;
6702: LD_EXP 46
6706: PPUSH
6707: LD_INT 13
6709: PPUSH
6710: CALL_OW 113
// repeat wait ( 0 0$01 ) ;
6714: LD_INT 35
6716: PPUSH
6717: CALL_OW 67
// if not dead1 and IsDead ( ru_spec_patrol [ 1 ] ) then
6721: LD_VAR 0 1
6725: NOT
6726: PUSH
6727: LD_EXP 46
6731: PUSH
6732: LD_INT 1
6734: ARRAY
6735: PPUSH
6736: CALL_OW 301
6740: AND
6741: IFFALSE 6751
// dead1 := true ;
6743: LD_ADDR_VAR 0 1
6747: PUSH
6748: LD_INT 1
6750: ST_TO_ADDR
// if not dead2 and IsDead ( ru_spec_patrol [ 2 ] ) then
6751: LD_VAR 0 2
6755: NOT
6756: PUSH
6757: LD_EXP 46
6761: PUSH
6762: LD_INT 2
6764: ARRAY
6765: PPUSH
6766: CALL_OW 301
6770: AND
6771: IFFALSE 6781
// dead2 := true ;
6773: LD_ADDR_VAR 0 2
6777: PUSH
6778: LD_INT 1
6780: ST_TO_ADDR
// if not inarea1 and IsInArea ( ru_spec_patrol [ 1 ] , baseBorder ) then
6781: LD_VAR 0 3
6785: NOT
6786: PUSH
6787: LD_EXP 46
6791: PUSH
6792: LD_INT 1
6794: ARRAY
6795: PPUSH
6796: LD_INT 14
6798: PPUSH
6799: CALL_OW 308
6803: AND
6804: IFFALSE 6814
// inarea1 := true ;
6806: LD_ADDR_VAR 0 3
6810: PUSH
6811: LD_INT 1
6813: ST_TO_ADDR
// if not inarea2 and IsInArea ( ru_spec_patrol [ 2 ] , baseBorder ) then
6814: LD_VAR 0 4
6818: NOT
6819: PUSH
6820: LD_EXP 46
6824: PUSH
6825: LD_INT 2
6827: ARRAY
6828: PPUSH
6829: LD_INT 14
6831: PPUSH
6832: CALL_OW 308
6836: AND
6837: IFFALSE 6847
// inarea2 := true ;
6839: LD_ADDR_VAR 0 4
6843: PUSH
6844: LD_INT 1
6846: ST_TO_ADDR
// until ( dead1 and dead2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) or ( inarea1 and inarea2 ) ;
6847: LD_VAR 0 1
6851: PUSH
6852: LD_VAR 0 2
6856: AND
6857: PUSH
6858: LD_VAR 0 1
6862: PUSH
6863: LD_VAR 0 4
6867: AND
6868: OR
6869: PUSH
6870: LD_VAR 0 2
6874: PUSH
6875: LD_VAR 0 3
6879: AND
6880: OR
6881: PUSH
6882: LD_VAR 0 3
6886: PUSH
6887: LD_VAR 0 4
6891: AND
6892: OR
6893: IFFALSE 6714
// if ( inarea1 and inarea2 ) or ( dead1 and inarea2 ) or ( dead2 and inarea1 ) then
6895: LD_VAR 0 3
6899: PUSH
6900: LD_VAR 0 4
6904: AND
6905: PUSH
6906: LD_VAR 0 1
6910: PUSH
6911: LD_VAR 0 4
6915: AND
6916: OR
6917: PUSH
6918: LD_VAR 0 2
6922: PUSH
6923: LD_VAR 0 3
6927: AND
6928: OR
6929: IFFALSE 7473
// begin prepare_siege := true ;
6931: LD_ADDR_EXP 26
6935: PUSH
6936: LD_INT 1
6938: ST_TO_ADDR
// DialogueOn ;
6939: CALL_OW 6
// if ( inarea1 and inarea2 ) then
6943: LD_VAR 0 3
6947: PUSH
6948: LD_VAR 0 4
6952: AND
6953: IFFALSE 6969
// Say ( JMM , D8b-JMM-1a ) else
6955: LD_EXP 29
6959: PPUSH
6960: LD_STRING D8b-JMM-1a
6962: PPUSH
6963: CALL_OW 88
6967: GO 6981
// Say ( JMM , D8b-JMM-1 ) ;
6969: LD_EXP 29
6973: PPUSH
6974: LD_STRING D8b-JMM-1
6976: PPUSH
6977: CALL_OW 88
// SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol1-1 ) ;
6981: LD_EXP 2
6985: PPUSH
6986: LD_INT 26
6988: PUSH
6989: LD_INT 1
6991: PUSH
6992: EMPTY
6993: LIST
6994: LIST
6995: PPUSH
6996: CALL_OW 72
7000: PUSH
7001: LD_EXP 30
7005: PUSH
7006: LD_EXP 31
7010: PUSH
7011: LD_EXP 40
7015: PUSH
7016: LD_EXP 43
7020: PUSH
7021: EMPTY
7022: LIST
7023: LIST
7024: LIST
7025: LIST
7026: DIFF
7027: PPUSH
7028: LD_STRING D8b-Sol1-1
7030: PPUSH
7031: CALL 562 0 2
// if Cyrus and Cyrus in jmm_units then
7035: LD_EXP 31
7039: PUSH
7040: LD_EXP 31
7044: PUSH
7045: LD_EXP 2
7049: IN
7050: AND
7051: IFFALSE 7067
// Say ( Cyrus , D8b-Cyrus-1 ) else
7053: LD_EXP 31
7057: PPUSH
7058: LD_STRING D8b-Cyrus-1
7060: PPUSH
7061: CALL_OW 88
7065: GO 7079
// Say ( JMM , D8b-JMM-1a ) ;
7067: LD_EXP 29
7071: PPUSH
7072: LD_STRING D8b-JMM-1a
7074: PPUSH
7075: CALL_OW 88
// if Lisa and Lisa in jmm_units then
7079: LD_EXP 32
7083: PUSH
7084: LD_EXP 32
7088: PUSH
7089: LD_EXP 2
7093: IN
7094: AND
7095: IFFALSE 7109
// Say ( Lisa , D8b-Lisa-2 ) ;
7097: LD_EXP 32
7101: PPUSH
7102: LD_STRING D8b-Lisa-2
7104: PPUSH
7105: CALL_OW 88
// if Bobby and Bobby in jmm_units then
7109: LD_EXP 30
7113: PUSH
7114: LD_EXP 30
7118: PUSH
7119: LD_EXP 2
7123: IN
7124: AND
7125: IFFALSE 7141
// Say ( Bobby , D8b-Bobby-1 ) else
7127: LD_EXP 30
7131: PPUSH
7132: LD_STRING D8b-Bobby-1
7134: PPUSH
7135: CALL_OW 88
7139: GO 7201
// sol := SayX ( UnitFilter ( jmm_units , [ f_sex , sex_male ] ) diff [ Bobby , Cyrus , Walker , Frank ] , D8b-Sol2-1 ) ;
7141: LD_ADDR_VAR 0 5
7145: PUSH
7146: LD_EXP 2
7150: PPUSH
7151: LD_INT 26
7153: PUSH
7154: LD_INT 1
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PPUSH
7161: CALL_OW 72
7165: PUSH
7166: LD_EXP 30
7170: PUSH
7171: LD_EXP 31
7175: PUSH
7176: LD_EXP 40
7180: PUSH
7181: LD_EXP 43
7185: PUSH
7186: EMPTY
7187: LIST
7188: LIST
7189: LIST
7190: LIST
7191: DIFF
7192: PPUSH
7193: LD_STRING D8b-Sol2-1
7195: PPUSH
7196: CALL 562 0 2
7200: ST_TO_ADDR
// DialogueOff ;
7201: CALL_OW 7
// if Cyrus and Cyrus in jmm_units then
7205: LD_EXP 31
7209: PUSH
7210: LD_EXP 31
7214: PUSH
7215: LD_EXP 2
7219: IN
7220: AND
7221: IFFALSE 7246
// tmp := Insert ( tmp , 1 , Cyrus ) ;
7223: LD_ADDR_VAR 0 6
7227: PUSH
7228: LD_VAR 0 6
7232: PPUSH
7233: LD_INT 1
7235: PPUSH
7236: LD_EXP 31
7240: PPUSH
7241: CALL_OW 2
7245: ST_TO_ADDR
// if Bobby and Bobby in jmm_units then
7246: LD_EXP 30
7250: PUSH
7251: LD_EXP 30
7255: PUSH
7256: LD_EXP 2
7260: IN
7261: AND
7262: IFFALSE 7287
// tmp := Insert ( tmp , 1 , Bobby ) ;
7264: LD_ADDR_VAR 0 6
7268: PUSH
7269: LD_VAR 0 6
7273: PPUSH
7274: LD_INT 1
7276: PPUSH
7277: LD_EXP 30
7281: PPUSH
7282: CALL_OW 2
7286: ST_TO_ADDR
// if sol then
7287: LD_VAR 0 5
7291: IFFALSE 7316
// tmp := Insert ( tmp , 1 , sol ) ;
7293: LD_ADDR_VAR 0 6
7297: PUSH
7298: LD_VAR 0 6
7302: PPUSH
7303: LD_INT 1
7305: PPUSH
7306: LD_VAR 0 5
7310: PPUSH
7311: CALL_OW 2
7315: ST_TO_ADDR
// if tmp then
7316: LD_VAR 0 6
7320: IFFALSE 7432
// begin SetSide ( tmp , 8 ) ;
7322: LD_VAR 0 6
7326: PPUSH
7327: LD_INT 8
7329: PPUSH
7330: CALL_OW 235
// ComFree ( tmp ) ;
7334: LD_VAR 0 6
7338: PPUSH
7339: CALL_OW 139
// AddComMoveToArea ( tmp , cyrusEscape ) ;
7343: LD_VAR 0 6
7347: PPUSH
7348: LD_INT 15
7350: PPUSH
7351: CALL_OW 173
// AddComHold ( tmp ) ;
7355: LD_VAR 0 6
7359: PPUSH
7360: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
7364: LD_INT 35
7366: PPUSH
7367: CALL_OW 67
// if IsInArea ( tmp [ 1 ] , cyrusEscape ) then
7371: LD_VAR 0 6
7375: PUSH
7376: LD_INT 1
7378: ARRAY
7379: PPUSH
7380: LD_INT 15
7382: PPUSH
7383: CALL_OW 308
7387: IFFALSE 7422
// begin RemoveUnit ( tmp [ 1 ] ) ;
7389: LD_VAR 0 6
7393: PUSH
7394: LD_INT 1
7396: ARRAY
7397: PPUSH
7398: CALL_OW 64
// tmp := tmp diff tmp [ 1 ] ;
7402: LD_ADDR_VAR 0 6
7406: PUSH
7407: LD_VAR 0 6
7411: PUSH
7412: LD_VAR 0 6
7416: PUSH
7417: LD_INT 1
7419: ARRAY
7420: DIFF
7421: ST_TO_ADDR
// end ; until tmp = 0 ;
7422: LD_VAR 0 6
7426: PUSH
7427: LD_INT 0
7429: EQUAL
7430: IFFALSE 7364
// end ; Wait ( 0 0$30 ) ;
7432: LD_INT 1050
7434: PPUSH
7435: CALL_OW 67
// if ru_spec_patrol then
7439: LD_EXP 46
7443: IFFALSE 7471
// for i in ru_spec_patrol do
7445: LD_ADDR_VAR 0 7
7449: PUSH
7450: LD_EXP 46
7454: PUSH
7455: FOR_IN
7456: IFFALSE 7469
// RemoveUnit ( i ) ;
7458: LD_VAR 0 7
7462: PPUSH
7463: CALL_OW 64
7467: GO 7455
7469: POP
7470: POP
// end else
7471: GO 7493
// begin prepare_siege := false ;
7473: LD_ADDR_EXP 26
7477: PUSH
7478: LD_INT 0
7480: ST_TO_ADDR
// Say ( JMM , D8a-JMM-1 ) ;
7481: LD_EXP 29
7485: PPUSH
7486: LD_STRING D8a-JMM-1
7488: PPUSH
7489: CALL_OW 88
// end ; end ;
7493: PPOPN 7
7495: END
// every 0 0$10 trigger frank_can_return do var i , points ;
7496: LD_EXP 10
7500: IFFALSE 8540
7502: GO 7504
7504: DISABLE
7505: LD_INT 0
7507: PPUSH
7508: PPUSH
// begin uc_side := 8 ;
7509: LD_ADDR_OWVAR 20
7513: PUSH
7514: LD_INT 8
7516: ST_TO_ADDR
// points := [ [ 59 , 71 ] , [ 122 , 117 ] ] ;
7517: LD_ADDR_VAR 0 2
7521: PUSH
7522: LD_INT 59
7524: PUSH
7525: LD_INT 71
7527: PUSH
7528: EMPTY
7529: LIST
7530: LIST
7531: PUSH
7532: LD_INT 122
7534: PUSH
7535: LD_INT 117
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: PUSH
7542: EMPTY
7543: LIST
7544: LIST
7545: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
7546: LD_ADDR_EXP 43
7550: PUSH
7551: LD_STRING Frank
7553: PPUSH
7554: LD_INT 0
7556: PPUSH
7557: CALL 417 0 2
7561: ST_TO_ADDR
// i := rand ( 1 , 2 ) ;
7562: LD_ADDR_VAR 0 1
7566: PUSH
7567: LD_INT 1
7569: PPUSH
7570: LD_INT 2
7572: PPUSH
7573: CALL_OW 12
7577: ST_TO_ADDR
// PlaceUnitXY ( Frank , points [ i ] [ 1 ] , points [ i ] [ 2 ] , false ) ;
7578: LD_EXP 43
7582: PPUSH
7583: LD_VAR 0 2
7587: PUSH
7588: LD_VAR 0 1
7592: ARRAY
7593: PUSH
7594: LD_INT 1
7596: ARRAY
7597: PPUSH
7598: LD_VAR 0 2
7602: PUSH
7603: LD_VAR 0 1
7607: ARRAY
7608: PUSH
7609: LD_INT 2
7611: ARRAY
7612: PPUSH
7613: LD_INT 0
7615: PPUSH
7616: CALL_OW 48
// ComMoveUnit ( Frank , us_dep_west ) ;
7620: LD_EXP 43
7624: PPUSH
7625: LD_INT 1
7627: PPUSH
7628: CALL_OW 112
// repeat wait ( 0 0$01 ) ;
7632: LD_INT 35
7634: PPUSH
7635: CALL_OW 67
// until GetDistUnits ( Frank , JMM ) < 8 ;
7639: LD_EXP 43
7643: PPUSH
7644: LD_EXP 29
7648: PPUSH
7649: CALL_OW 296
7653: PUSH
7654: LD_INT 8
7656: LESS
7657: IFFALSE 7632
// InGameOn ;
7659: CALL_OW 8
// CenterOnUnits ( JMM ) ;
7663: LD_EXP 29
7667: PPUSH
7668: CALL_OW 85
// if IsInUnit ( JMM ) then
7672: LD_EXP 29
7676: PPUSH
7677: CALL_OW 310
7681: IFFALSE 7692
// ComFree ( JMM ) ;
7683: LD_EXP 29
7687: PPUSH
7688: CALL_OW 139
// ComMoveUnit ( JMM , Frank ) ;
7692: LD_EXP 29
7696: PPUSH
7697: LD_EXP 43
7701: PPUSH
7702: CALL_OW 112
// ComMoveUnit ( Frank , JMM ) ;
7706: LD_EXP 43
7710: PPUSH
7711: LD_EXP 29
7715: PPUSH
7716: CALL_OW 112
// Say ( JMM , D6-JMM-1 ) ;
7720: LD_EXP 29
7724: PPUSH
7725: LD_STRING D6-JMM-1
7727: PPUSH
7728: CALL_OW 88
// repeat wait ( 0 0$01 ) ;
7732: LD_INT 35
7734: PPUSH
7735: CALL_OW 67
// until GetDistUnits ( JMM , Frank ) < 8 ;
7739: LD_EXP 29
7743: PPUSH
7744: LD_EXP 43
7748: PPUSH
7749: CALL_OW 296
7753: PUSH
7754: LD_INT 8
7756: LESS
7757: IFFALSE 7732
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 then
7759: LD_EXP 32
7763: PUSH
7764: LD_EXP 32
7768: PPUSH
7769: LD_EXP 43
7773: PPUSH
7774: CALL_OW 296
7778: PUSH
7779: LD_INT 20
7781: LESS
7782: AND
7783: IFFALSE 7808
// begin ComFree ( Lisa ) ;
7785: LD_EXP 32
7789: PPUSH
7790: CALL_OW 139
// AddComMoveUnit ( Lisa , Frank ) ;
7794: LD_EXP 32
7798: PPUSH
7799: LD_EXP 43
7803: PPUSH
7804: CALL_OW 172
// end ; if Lynch then
7808: LD_EXP 39
7812: IFFALSE 7837
// begin ComFree ( Lynch ) ;
7814: LD_EXP 39
7818: PPUSH
7819: CALL_OW 139
// AddComMoveUnit ( Lynch , Frank ) ;
7823: LD_EXP 39
7827: PPUSH
7828: LD_EXP 43
7832: PPUSH
7833: CALL_OW 172
// end ; ComTurnUnit ( JMM , Frank ) ;
7837: LD_EXP 29
7841: PPUSH
7842: LD_EXP 43
7846: PPUSH
7847: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
7851: LD_EXP 43
7855: PPUSH
7856: LD_EXP 29
7860: PPUSH
7861: CALL_OW 119
// Say ( Frank , D6-Frank-1 ) ;
7865: LD_EXP 43
7869: PPUSH
7870: LD_STRING D6-Frank-1
7872: PPUSH
7873: CALL_OW 88
// if Lisa and GetDistUnits ( Lisa , Frank ) < 20 and IsOk ( Lisa ) then
7877: LD_EXP 32
7881: PUSH
7882: LD_EXP 32
7886: PPUSH
7887: LD_EXP 43
7891: PPUSH
7892: CALL_OW 296
7896: PUSH
7897: LD_INT 20
7899: LESS
7900: AND
7901: PUSH
7902: LD_EXP 32
7906: PPUSH
7907: CALL_OW 302
7911: AND
7912: IFFALSE 8002
// begin ComFree ( Lisa ) ;
7914: LD_EXP 32
7918: PPUSH
7919: CALL_OW 139
// repeat wait ( 0 0$01 ) ;
7923: LD_INT 35
7925: PPUSH
7926: CALL_OW 67
// until GetDistUnits ( Lisa , Frank ) < 7 ;
7930: LD_EXP 32
7934: PPUSH
7935: LD_EXP 43
7939: PPUSH
7940: CALL_OW 296
7944: PUSH
7945: LD_INT 7
7947: LESS
7948: IFFALSE 7923
// Say ( Lisa , D6-Lisa-1 ) ;
7950: LD_EXP 32
7954: PPUSH
7955: LD_STRING D6-Lisa-1
7957: PPUSH
7958: CALL_OW 88
// ComTurnUnit ( Lisa , Frank ) ;
7962: LD_EXP 32
7966: PPUSH
7967: LD_EXP 43
7971: PPUSH
7972: CALL_OW 119
// ComTurnUnit ( Frank , Lisa ) ;
7976: LD_EXP 43
7980: PPUSH
7981: LD_EXP 32
7985: PPUSH
7986: CALL_OW 119
// Say ( Frank , D6-Frank-2 ) ;
7990: LD_EXP 43
7994: PPUSH
7995: LD_STRING D6-Frank-2
7997: PPUSH
7998: CALL_OW 88
// end ; if Lynch and GetDistUnits ( Lynch , Frank ) < 20 and IsOk ( Lynch ) then
8002: LD_EXP 39
8006: PUSH
8007: LD_EXP 39
8011: PPUSH
8012: LD_EXP 43
8016: PPUSH
8017: CALL_OW 296
8021: PUSH
8022: LD_INT 20
8024: LESS
8025: AND
8026: PUSH
8027: LD_EXP 39
8031: PPUSH
8032: CALL_OW 302
8036: AND
8037: IFFALSE 8218
// begin ComTurnUnit ( Lynch , JMM ) ;
8039: LD_EXP 39
8043: PPUSH
8044: LD_EXP 29
8048: PPUSH
8049: CALL_OW 119
// ComTurnUnit ( Frank , JMM ) ;
8053: LD_EXP 43
8057: PPUSH
8058: LD_EXP 29
8062: PPUSH
8063: CALL_OW 119
// Say ( Lynch , D6-Sol1-2 ) ;
8067: LD_EXP 39
8071: PPUSH
8072: LD_STRING D6-Sol1-2
8074: PPUSH
8075: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
8079: LD_EXP 29
8083: PPUSH
8084: LD_STRING D6-JMM-2
8086: PPUSH
8087: CALL_OW 88
// Say ( Frank , D6-Frank-3 ) ;
8091: LD_EXP 43
8095: PPUSH
8096: LD_STRING D6-Frank-3
8098: PPUSH
8099: CALL_OW 88
// Say ( JMM , D6-JMM-3 ) ;
8103: LD_EXP 29
8107: PPUSH
8108: LD_STRING D6-JMM-3
8110: PPUSH
8111: CALL_OW 88
// Say ( Frank , D6-Frank-4 ) ;
8115: LD_EXP 43
8119: PPUSH
8120: LD_STRING D6-Frank-4
8122: PPUSH
8123: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
8127: LD_EXP 43
8131: PPUSH
8132: LD_STRING D6-Frank-4a
8134: PPUSH
8135: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
8139: LD_EXP 29
8143: PPUSH
8144: LD_STRING D6-JMM-4
8146: PPUSH
8147: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
8151: LD_EXP 43
8155: PPUSH
8156: LD_STRING D6-Frank-5
8158: PPUSH
8159: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
8163: LD_EXP 32
8167: PUSH
8168: LD_EXP 32
8172: PPUSH
8173: CALL_OW 302
8177: AND
8178: IFFALSE 8192
// Say ( Lisa , D6-Lisa-5 ) ;
8180: LD_EXP 32
8184: PPUSH
8185: LD_STRING D6-Lisa-5
8187: PPUSH
8188: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
8192: LD_EXP 43
8196: PPUSH
8197: LD_STRING D6-Frank-6
8199: PPUSH
8200: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
8204: LD_EXP 29
8208: PPUSH
8209: LD_STRING D6-JMM-6
8211: PPUSH
8212: CALL_OW 88
// end else
8216: GO 8333
// begin ComTurnUnit ( Frank , JMM ) ;
8218: LD_EXP 43
8222: PPUSH
8223: LD_EXP 29
8227: PPUSH
8228: CALL_OW 119
// Say ( Frank , D6-Frank-4 ) ;
8232: LD_EXP 43
8236: PPUSH
8237: LD_STRING D6-Frank-4
8239: PPUSH
8240: CALL_OW 88
// Say ( Frank , D6-Frank-4a ) ;
8244: LD_EXP 43
8248: PPUSH
8249: LD_STRING D6-Frank-4a
8251: PPUSH
8252: CALL_OW 88
// Say ( JMM , D6-JMM-4 ) ;
8256: LD_EXP 29
8260: PPUSH
8261: LD_STRING D6-JMM-4
8263: PPUSH
8264: CALL_OW 88
// Say ( Frank , D6-Frank-5 ) ;
8268: LD_EXP 43
8272: PPUSH
8273: LD_STRING D6-Frank-5
8275: PPUSH
8276: CALL_OW 88
// if Lisa and IsOk ( Lisa ) then
8280: LD_EXP 32
8284: PUSH
8285: LD_EXP 32
8289: PPUSH
8290: CALL_OW 302
8294: AND
8295: IFFALSE 8309
// Say ( Lisa , D6-Lisa-5 ) ;
8297: LD_EXP 32
8301: PPUSH
8302: LD_STRING D6-Lisa-5
8304: PPUSH
8305: CALL_OW 88
// Say ( Frank , D6-Frank-6 ) ;
8309: LD_EXP 43
8313: PPUSH
8314: LD_STRING D6-Frank-6
8316: PPUSH
8317: CALL_OW 88
// Say ( JMM , D6-JMM-6 ) ;
8321: LD_EXP 29
8325: PPUSH
8326: LD_STRING D6-JMM-6
8328: PPUSH
8329: CALL_OW 88
// end ; case Query ( Q1 ) of 1 :
8333: LD_STRING Q1
8335: PPUSH
8336: CALL_OW 97
8340: PUSH
8341: LD_INT 1
8343: DOUBLE
8344: EQUAL
8345: IFTRUE 8349
8347: GO 8360
8349: POP
// frank_send_to_scout := true ; 2 :
8350: LD_ADDR_EXP 12
8354: PUSH
8355: LD_INT 1
8357: ST_TO_ADDR
8358: GO 8380
8360: LD_INT 2
8362: DOUBLE
8363: EQUAL
8364: IFTRUE 8368
8366: GO 8379
8368: POP
// frank_send_to_scout := false ; end ;
8369: LD_ADDR_EXP 12
8373: PUSH
8374: LD_INT 0
8376: ST_TO_ADDR
8377: GO 8380
8379: POP
// InGameOff ;
8380: CALL_OW 9
// ComFree ( [ JMM , Lisa , Lynch ] ) ;
8384: LD_EXP 29
8388: PUSH
8389: LD_EXP 32
8393: PUSH
8394: LD_EXP 39
8398: PUSH
8399: EMPTY
8400: LIST
8401: LIST
8402: LIST
8403: PPUSH
8404: CALL_OW 139
// if frank_send_to_scout then
8408: LD_EXP 12
8412: IFFALSE 8469
// begin ComMoveXY ( Frank , 130 , 123 ) ;
8414: LD_EXP 43
8418: PPUSH
8419: LD_INT 130
8421: PPUSH
8422: LD_INT 123
8424: PPUSH
8425: CALL_OW 111
// repeat wait ( 0 0$01 ) ;
8429: LD_INT 35
8431: PPUSH
8432: CALL_OW 67
// until not See ( 1 , Frank ) ;
8436: LD_INT 1
8438: PPUSH
8439: LD_EXP 43
8443: PPUSH
8444: CALL_OW 292
8448: NOT
8449: IFFALSE 8429
// Wait ( 0 0$02 ) ;
8451: LD_INT 70
8453: PPUSH
8454: CALL_OW 67
// RemoveUnit ( Frank ) ;
8458: LD_EXP 43
8462: PPUSH
8463: CALL_OW 64
// end else
8467: GO 8481
// SetSide ( Frank , 1 ) ;
8469: LD_EXP 43
8473: PPUSH
8474: LD_INT 1
8476: PPUSH
8477: CALL_OW 235
// repeat wait ( 0 0$01 ) ;
8481: LD_INT 35
8483: PPUSH
8484: CALL_OW 67
// time_to_prepare := Count ( time_to_prepare , - ) ;
8488: LD_ADDR_EXP 24
8492: PUSH
8493: LD_EXP 24
8497: PPUSH
8498: LD_STRING -
8500: PPUSH
8501: CALL 1054 0 2
8505: ST_TO_ADDR
// if debug then
8506: LD_EXP 1
8510: IFFALSE 8522
// debug_strings := time_to_prepare ;
8512: LD_ADDR_OWVAR 48
8516: PUSH
8517: LD_EXP 24
8521: ST_TO_ADDR
// until time_to_prepare = 0 0$00 ;
8522: LD_EXP 24
8526: PUSH
8527: LD_INT 0
8529: EQUAL
8530: IFFALSE 8481
// cornel_prepared := true ;
8532: LD_ADDR_EXP 9
8536: PUSH
8537: LD_INT 1
8539: ST_TO_ADDR
// end ;
8540: PPOPN 2
8542: END
// every 0 0$01 trigger cornel_prepared do
8543: LD_EXP 9
8547: IFFALSE 8767
8549: GO 8551
8551: DISABLE
// begin SayRadio ( Cornel , D3-Corn-1 ) ;
8552: LD_EXP 36
8556: PPUSH
8557: LD_STRING D3-Corn-1
8559: PPUSH
8560: CALL_OW 94
// repeat wait ( 0 0$01 ) ;
8564: LD_INT 35
8566: PPUSH
8567: CALL_OW 67
// until cornel_counter = 0 ;
8571: LD_EXP 8
8575: PUSH
8576: LD_INT 0
8578: EQUAL
8579: IFFALSE 8564
// SayRadio ( Cornel , D3a-Corn-1 ) ;
8581: LD_EXP 36
8585: PPUSH
8586: LD_STRING D3a-Corn-1
8588: PPUSH
8589: CALL_OW 94
// Say ( JMM , D3a-JMM-1 ) ;
8593: LD_EXP 29
8597: PPUSH
8598: LD_STRING D3a-JMM-1
8600: PPUSH
8601: CALL_OW 88
// end_mission_allowed := true ;
8605: LD_ADDR_EXP 18
8609: PUSH
8610: LD_INT 1
8612: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
8613: LD_STRING M2
8615: PPUSH
8616: CALL_OW 337
// SetAreaMapShow ( endMArea , 1 ) ;
8620: LD_INT 9
8622: PPUSH
8623: LD_INT 1
8625: PPUSH
8626: CALL_OW 424
// Wait ( 0 0$05 ) ;
8630: LD_INT 175
8632: PPUSH
8633: CALL_OW 67
// SayRadio ( Cornel , D3a-Corn-2 ) ;
8637: LD_EXP 36
8641: PPUSH
8642: LD_STRING D3a-Corn-2
8644: PPUSH
8645: CALL_OW 94
// cornel_attack := true ;
8649: LD_ADDR_EXP 7
8653: PUSH
8654: LD_INT 1
8656: ST_TO_ADDR
// if frank_send_to_scout then
8657: LD_EXP 12
8661: IFFALSE 8767
// begin InitHc ;
8663: CALL_OW 19
// InitUc ;
8667: CALL_OW 18
// uc_side := 8 ;
8671: LD_ADDR_OWVAR 20
8675: PUSH
8676: LD_INT 8
8678: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , false ) ;
8679: LD_ADDR_EXP 43
8683: PUSH
8684: LD_STRING Frank
8686: PPUSH
8687: LD_INT 0
8689: PPUSH
8690: CALL 417 0 2
8694: ST_TO_ADDR
// PlaceUnitXY ( Frank , 6 , 9 , false ) ;
8695: LD_EXP 43
8699: PPUSH
8700: LD_INT 6
8702: PPUSH
8703: LD_INT 9
8705: PPUSH
8706: LD_INT 0
8708: PPUSH
8709: CALL_OW 48
// ComCrawl ( Frank ) ;
8713: LD_EXP 43
8717: PPUSH
8718: CALL_OW 137
// repeat wait ( 0 0$01 ) ;
8722: LD_INT 35
8724: PPUSH
8725: CALL_OW 67
// until See ( 1 , Frank ) ;
8729: LD_INT 1
8731: PPUSH
8732: LD_EXP 43
8736: PPUSH
8737: CALL_OW 292
8741: IFFALSE 8722
// SetSide ( Frank , 1 ) ;
8743: LD_EXP 43
8747: PPUSH
8748: LD_INT 1
8750: PPUSH
8751: CALL_OW 235
// Say ( Frank , D6a-Frank-1 ) ;
8755: LD_EXP 43
8759: PPUSH
8760: LD_STRING D6a-Frank-1
8762: PPUSH
8763: CALL_OW 88
// end ; end ;
8767: END
// every 0 0$01 trigger solar_builded do
8768: LD_EXP 11
8772: IFFALSE 8876
8774: GO 8776
8776: DISABLE
// begin Wait ( 0 0$02 ) ;
8777: LD_INT 70
8779: PPUSH
8780: CALL_OW 67
// DialogueOn ;
8784: CALL_OW 6
// Say ( JMM , D2b-JMM-1 ) ;
8788: LD_EXP 29
8792: PPUSH
8793: LD_STRING D2b-JMM-1
8795: PPUSH
8796: CALL_OW 88
// if Walker and IsOk ( Walker ) then
8800: LD_EXP 40
8804: PUSH
8805: LD_EXP 40
8809: PPUSH
8810: CALL_OW 302
8814: AND
8815: IFFALSE 8865
// begin Say ( Walker , D2b-Sci1-1 ) ;
8817: LD_EXP 40
8821: PPUSH
8822: LD_STRING D2b-Sci1-1
8824: PPUSH
8825: CALL_OW 88
// Say ( JMM , D2b-JMM-2 ) ;
8829: LD_EXP 29
8833: PPUSH
8834: LD_STRING D2b-JMM-2
8836: PPUSH
8837: CALL_OW 88
// Say ( Walker , D2b-Sci1-2 ) ;
8841: LD_EXP 40
8845: PPUSH
8846: LD_STRING D2b-Sci1-2
8848: PPUSH
8849: CALL_OW 88
// Say ( JMM , D2b-JMM-3 ) ;
8853: LD_EXP 29
8857: PPUSH
8858: LD_STRING D2b-JMM-3
8860: PPUSH
8861: CALL_OW 88
// end ; DialogueOff ;
8865: CALL_OW 7
// ChangeMissionObjectives ( MOutSol ) ;
8869: LD_STRING MOutSol
8871: PPUSH
8872: CALL_OW 337
// end ;
8876: END
// every 0 0$01 trigger solar_builded and IsOk ( JMM ) and InVeh ( JMM ) and not jmm_in_veh do var i ;
8877: LD_EXP 11
8881: PUSH
8882: LD_EXP 29
8886: PPUSH
8887: CALL_OW 302
8891: AND
8892: PUSH
8893: LD_EXP 29
8897: PPUSH
8898: CALL 888 0 1
8902: AND
8903: PUSH
8904: LD_EXP 13
8908: NOT
8909: AND
8910: IFFALSE 8981
8912: GO 8914
8914: DISABLE
8915: LD_INT 0
8917: PPUSH
// begin jmm_in_veh := true ;
8918: LD_ADDR_EXP 13
8922: PUSH
8923: LD_INT 1
8925: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
8926: LD_ADDR_VAR 0 1
8930: PUSH
8931: LD_INT 0
8933: PPUSH
8934: LD_INT 1
8936: PPUSH
8937: CALL_OW 12
8941: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
8942: LD_INT 70
8944: PPUSH
8945: CALL_OW 67
// if i then
8949: LD_VAR 0 1
8953: IFFALSE 8969
// Say ( JMM , D2c-JMM-1 ) else
8955: LD_EXP 29
8959: PPUSH
8960: LD_STRING D2c-JMM-1
8962: PPUSH
8963: CALL_OW 88
8967: GO 8981
// Say ( JMM , D2c-JMM-1a ) ;
8969: LD_EXP 29
8973: PPUSH
8974: LD_STRING D2c-JMM-1a
8976: PPUSH
8977: CALL_OW 88
// end ;
8981: PPOPN 1
8983: END
// every 0 0$01 trigger solar_builded and IsOk ( Bobby ) and InVeh ( Bobby ) and not bobby_in_veh do
8984: LD_EXP 11
8988: PUSH
8989: LD_EXP 30
8993: PPUSH
8994: CALL_OW 302
8998: AND
8999: PUSH
9000: LD_EXP 30
9004: PPUSH
9005: CALL 888 0 1
9009: AND
9010: PUSH
9011: LD_EXP 14
9015: NOT
9016: AND
9017: IFFALSE 9049
9019: GO 9021
9021: DISABLE
// begin bobby_in_veh := true ;
9022: LD_ADDR_EXP 14
9026: PUSH
9027: LD_INT 1
9029: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
9030: LD_INT 70
9032: PPUSH
9033: CALL_OW 67
// Say ( Bobby , D2c-Bobby-1 ) end ;
9037: LD_EXP 30
9041: PPUSH
9042: LD_STRING D2c-Bobby-1
9044: PPUSH
9045: CALL_OW 88
9049: END
// every 0 0$01 trigger solar_builded and IsOk ( Lisa ) and InVeh ( Lisa ) and not lisa_in_veh do
9050: LD_EXP 11
9054: PUSH
9055: LD_EXP 32
9059: PPUSH
9060: CALL_OW 302
9064: AND
9065: PUSH
9066: LD_EXP 32
9070: PPUSH
9071: CALL 888 0 1
9075: AND
9076: PUSH
9077: LD_EXP 16
9081: NOT
9082: AND
9083: IFFALSE 9115
9085: GO 9087
9087: DISABLE
// begin lisa_in_veh := true ;
9088: LD_ADDR_EXP 16
9092: PUSH
9093: LD_INT 1
9095: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
9096: LD_INT 70
9098: PPUSH
9099: CALL_OW 67
// Say ( Lisa , D2c-Lisa-1 ) end ;
9103: LD_EXP 32
9107: PPUSH
9108: LD_STRING D2c-Lisa-1
9110: PPUSH
9111: CALL_OW 88
9115: END
// every 0 0$01 trigger solar_builded and IsOk ( Cyrus ) and InVeh ( Cyrus ) and not cyrus_in_veh do var i ;
9116: LD_EXP 11
9120: PUSH
9121: LD_EXP 31
9125: PPUSH
9126: CALL_OW 302
9130: AND
9131: PUSH
9132: LD_EXP 31
9136: PPUSH
9137: CALL 888 0 1
9141: AND
9142: PUSH
9143: LD_EXP 15
9147: NOT
9148: AND
9149: IFFALSE 9220
9151: GO 9153
9153: DISABLE
9154: LD_INT 0
9156: PPUSH
// begin cyrus_in_veh := true ;
9157: LD_ADDR_EXP 15
9161: PUSH
9162: LD_INT 1
9164: ST_TO_ADDR
// i := rand ( 0 , 1 ) ;
9165: LD_ADDR_VAR 0 1
9169: PUSH
9170: LD_INT 0
9172: PPUSH
9173: LD_INT 1
9175: PPUSH
9176: CALL_OW 12
9180: ST_TO_ADDR
// Wait ( 0 0$02 ) ;
9181: LD_INT 70
9183: PPUSH
9184: CALL_OW 67
// if i then
9188: LD_VAR 0 1
9192: IFFALSE 9208
// Say ( Cyrus , D2c-Cyrus-1 ) else
9194: LD_EXP 31
9198: PPUSH
9199: LD_STRING D2c-Cyrus-1
9201: PPUSH
9202: CALL_OW 88
9206: GO 9220
// Say ( Cyrus , D2c-Cyrus-1a ) ;
9208: LD_EXP 31
9212: PPUSH
9213: LD_STRING D2c-Cyrus-1a
9215: PPUSH
9216: CALL_OW 88
// end ;
9220: PPOPN 1
9222: END
// every 0 0$04 trigger IsInArea ( Cornel , cornelKappaArea ) do var i ;
9223: LD_EXP 36
9227: PPUSH
9228: LD_INT 16
9230: PPUSH
9231: CALL_OW 308
9235: IFFALSE 9477
9237: GO 9239
9239: DISABLE
9240: LD_INT 0
9242: PPUSH
// begin if frank_send_to_scout then
9243: LD_EXP 12
9247: IFFALSE 9261
// begin SayRadio ( Frank , D3b-Frank-1 ) ;
9249: LD_EXP 43
9253: PPUSH
9254: LD_STRING D3b-Frank-1
9256: PPUSH
9257: CALL_OW 94
// end ; DoNotAttack ( 3 , Cornel ) ;
9261: LD_INT 3
9263: PPUSH
9264: LD_EXP 36
9268: PPUSH
9269: CALL_OW 471
// Wait ( 0 0$10 ) ;
9273: LD_INT 350
9275: PPUSH
9276: CALL_OW 67
// SayRadio ( Cornel , D4-Corn-1 ) ;
9280: LD_EXP 36
9284: PPUSH
9285: LD_STRING D4-Corn-1
9287: PPUSH
9288: CALL_OW 94
// send_attack_on_cornel := true ;
9292: LD_ADDR_EXP 27
9296: PUSH
9297: LD_INT 1
9299: ST_TO_ADDR
// if ru_vehicles then
9300: LD_EXP 48
9304: IFFALSE 9338
// for i in ru_vehicles do
9306: LD_ADDR_VAR 0 1
9310: PUSH
9311: LD_EXP 48
9315: PUSH
9316: FOR_IN
9317: IFFALSE 9336
// ComAgressiveMove ( i , 215 , 69 ) ;
9319: LD_VAR 0 1
9323: PPUSH
9324: LD_INT 215
9326: PPUSH
9327: LD_INT 69
9329: PPUSH
9330: CALL_OW 114
9334: GO 9316
9336: POP
9337: POP
// if ru_patrol then
9338: LD_EXP 45
9342: IFFALSE 9376
// for i in ru_patrol do
9344: LD_ADDR_VAR 0 1
9348: PUSH
9349: LD_EXP 45
9353: PUSH
9354: FOR_IN
9355: IFFALSE 9374
// ComAgressiveMove ( i , 215 , 69 ) ;
9357: LD_VAR 0 1
9361: PPUSH
9362: LD_INT 215
9364: PPUSH
9365: LD_INT 69
9367: PPUSH
9368: CALL_OW 114
9372: GO 9354
9374: POP
9375: POP
// repeat wait ( 0 0$01 ) ;
9376: LD_INT 35
9378: PPUSH
9379: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < 5 ;
9383: LD_INT 22
9385: PUSH
9386: LD_INT 4
9388: PUSH
9389: EMPTY
9390: LIST
9391: LIST
9392: PUSH
9393: LD_INT 21
9395: PUSH
9396: LD_INT 1
9398: PUSH
9399: EMPTY
9400: LIST
9401: LIST
9402: PUSH
9403: LD_INT 50
9405: PUSH
9406: EMPTY
9407: LIST
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: LIST
9413: PPUSH
9414: CALL_OW 69
9418: PUSH
9419: LD_INT 5
9421: LESS
9422: IFFALSE 9376
// SayRadio ( Cornel , D5-Corn-1 ) ;
9424: LD_EXP 36
9428: PPUSH
9429: LD_STRING D5-Corn-1
9431: PPUSH
9432: CALL_OW 94
// SaveCharacters ( Cornel , Cornel ) ;
9436: LD_EXP 36
9440: PPUSH
9441: LD_STRING Cornel
9443: PPUSH
9444: CALL_OW 38
// Wait ( 0 0$01 ) ;
9448: LD_INT 35
9450: PPUSH
9451: CALL_OW 67
// NormalAttack ( 3 , Cornel ) ;
9455: LD_INT 3
9457: PPUSH
9458: LD_EXP 36
9462: PPUSH
9463: CALL_OW 472
// ChangeSideFog ( 4 , 8 ) ;
9467: LD_INT 4
9469: PPUSH
9470: LD_INT 8
9472: PPUSH
9473: CALL_OW 343
// end ;
9477: PPOPN 1
9479: END
// every 0 0$02 trigger FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) or game_end do var i , filter ;
9480: LD_INT 9
9482: PPUSH
9483: LD_INT 22
9485: PUSH
9486: LD_INT 1
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PPUSH
9493: CALL_OW 70
9497: PUSH
9498: LD_EXP 28
9502: OR
9503: IFFALSE 10244
9505: GO 9507
9507: DISABLE
9508: LD_INT 0
9510: PPUSH
9511: PPUSH
// begin enable ;
9512: ENABLE
// if not game_end then
9513: LD_EXP 28
9517: NOT
9518: IFFALSE 9528
// game_end := true ;
9520: LD_ADDR_EXP 28
9524: PUSH
9525: LD_INT 1
9527: ST_TO_ADDR
// filter := FilterUnitsInArea ( endMArea , [ f_side , 1 ] ) ;
9528: LD_ADDR_VAR 0 2
9532: PUSH
9533: LD_INT 9
9535: PPUSH
9536: LD_INT 22
9538: PUSH
9539: LD_INT 1
9541: PUSH
9542: EMPTY
9543: LIST
9544: LIST
9545: PPUSH
9546: CALL_OW 70
9550: ST_TO_ADDR
// if not filter then
9551: LD_VAR 0 2
9555: NOT
9556: IFFALSE 9560
// exit ;
9558: GO 10244
// for i in filter do
9560: LD_ADDR_VAR 0 1
9564: PUSH
9565: LD_VAR 0 2
9569: PUSH
9570: FOR_IN
9571: IFFALSE 10242
// begin if IsOk ( i ) and GetType ( i ) = unit_vehicle then
9573: LD_VAR 0 1
9577: PPUSH
9578: CALL_OW 302
9582: PUSH
9583: LD_VAR 0 1
9587: PPUSH
9588: CALL_OW 247
9592: PUSH
9593: LD_INT 2
9595: EQUAL
9596: AND
9597: IFFALSE 9637
// begin veh_on_meta := true ;
9599: LD_ADDR_EXP 23
9603: PUSH
9604: LD_INT 1
9606: ST_TO_ADDR
// ComExitVehicle ( IsInUnit ( i ) ) ;
9607: LD_VAR 0 1
9611: PPUSH
9612: CALL_OW 310
9616: PPUSH
9617: CALL_OW 121
// RemoveUnit ( i ) ;
9621: LD_VAR 0 1
9625: PPUSH
9626: CALL_OW 64
// Wait ( 10 ) ;
9630: LD_INT 10
9632: PPUSH
9633: CALL_OW 67
// end ; if i = JMM then
9637: LD_VAR 0 1
9641: PUSH
9642: LD_EXP 29
9646: EQUAL
9647: IFFALSE 9769
// begin if show_query and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) > 1 then
9649: LD_EXP 21
9653: PUSH
9654: LD_INT 22
9656: PUSH
9657: LD_INT 1
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: PUSH
9664: LD_INT 21
9666: PUSH
9667: LD_INT 1
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: PUSH
9674: EMPTY
9675: LIST
9676: LIST
9677: PPUSH
9678: CALL_OW 69
9682: PUSH
9683: LD_INT 1
9685: GREATER
9686: AND
9687: IFFALSE 9769
// begin show_query := false ;
9689: LD_ADDR_EXP 21
9693: PUSH
9694: LD_INT 0
9696: ST_TO_ADDR
// case Query ( Q2 ) of 1 :
9697: LD_STRING Q2
9699: PPUSH
9700: CALL_OW 97
9704: PUSH
9705: LD_INT 1
9707: DOUBLE
9708: EQUAL
9709: IFTRUE 9713
9711: GO 9724
9713: POP
// wait_for_them := true ; 2 :
9714: LD_ADDR_EXP 22
9718: PUSH
9719: LD_INT 1
9721: ST_TO_ADDR
9722: GO 9744
9724: LD_INT 2
9726: DOUBLE
9727: EQUAL
9728: IFTRUE 9732
9730: GO 9743
9732: POP
// wait_for_them := false ; end ;
9733: LD_ADDR_EXP 22
9737: PUSH
9738: LD_INT 0
9740: ST_TO_ADDR
9741: GO 9744
9743: POP
// save_group := save_group ^ JMM ;
9744: LD_ADDR_EXP 20
9748: PUSH
9749: LD_EXP 20
9753: PUSH
9754: LD_EXP 29
9758: ADD
9759: ST_TO_ADDR
// RemoveUnit ( JMM ) ;
9760: LD_EXP 29
9764: PPUSH
9765: CALL_OW 64
// end ; end ; if i = Lisa then
9769: LD_VAR 0 1
9773: PUSH
9774: LD_EXP 32
9778: EQUAL
9779: IFFALSE 9806
// begin save_group := save_group ^ Lisa ;
9781: LD_ADDR_EXP 20
9785: PUSH
9786: LD_EXP 20
9790: PUSH
9791: LD_EXP 32
9795: ADD
9796: ST_TO_ADDR
// RemoveUnit ( Lisa ) ;
9797: LD_EXP 32
9801: PPUSH
9802: CALL_OW 64
// end ; if i = Bobby then
9806: LD_VAR 0 1
9810: PUSH
9811: LD_EXP 30
9815: EQUAL
9816: IFFALSE 9843
// begin save_group := save_group ^ Bobby ;
9818: LD_ADDR_EXP 20
9822: PUSH
9823: LD_EXP 20
9827: PUSH
9828: LD_EXP 30
9832: ADD
9833: ST_TO_ADDR
// RemoveUnit ( Bobby ) ;
9834: LD_EXP 30
9838: PPUSH
9839: CALL_OW 64
// end ; if i = Cyrus then
9843: LD_VAR 0 1
9847: PUSH
9848: LD_EXP 31
9852: EQUAL
9853: IFFALSE 9880
// begin save_group := save_group ^ Cyrus ;
9855: LD_ADDR_EXP 20
9859: PUSH
9860: LD_EXP 20
9864: PUSH
9865: LD_EXP 31
9869: ADD
9870: ST_TO_ADDR
// RemoveUnit ( Cyrus ) ;
9871: LD_EXP 31
9875: PPUSH
9876: CALL_OW 64
// end ; if i = Khatam then
9880: LD_VAR 0 1
9884: PUSH
9885: LD_EXP 33
9889: EQUAL
9890: IFFALSE 9917
// begin save_group := save_group ^ Khatam ;
9892: LD_ADDR_EXP 20
9896: PUSH
9897: LD_EXP 20
9901: PUSH
9902: LD_EXP 33
9906: ADD
9907: ST_TO_ADDR
// RemoveUnit ( Khatam ) ;
9908: LD_EXP 33
9912: PPUSH
9913: CALL_OW 64
// end ; if i = Jerry then
9917: LD_VAR 0 1
9921: PUSH
9922: LD_EXP 35
9926: EQUAL
9927: IFFALSE 9954
// begin save_group := save_group ^ Jerry ;
9929: LD_ADDR_EXP 20
9933: PUSH
9934: LD_EXP 20
9938: PUSH
9939: LD_EXP 35
9943: ADD
9944: ST_TO_ADDR
// RemoveUnit ( Jerry ) ;
9945: LD_EXP 35
9949: PPUSH
9950: CALL_OW 64
// end ; if i = Brian then
9954: LD_VAR 0 1
9958: PUSH
9959: LD_EXP 34
9963: EQUAL
9964: IFFALSE 9991
// begin save_group := save_group ^ Brian ;
9966: LD_ADDR_EXP 20
9970: PUSH
9971: LD_EXP 20
9975: PUSH
9976: LD_EXP 34
9980: ADD
9981: ST_TO_ADDR
// RemoveUnit ( Brian ) ;
9982: LD_EXP 34
9986: PPUSH
9987: CALL_OW 64
// end ; if i = Lynch then
9991: LD_VAR 0 1
9995: PUSH
9996: LD_EXP 39
10000: EQUAL
10001: IFFALSE 10028
// begin save_group := save_group ^ Lynch ;
10003: LD_ADDR_EXP 20
10007: PUSH
10008: LD_EXP 20
10012: PUSH
10013: LD_EXP 39
10017: ADD
10018: ST_TO_ADDR
// RemoveUnit ( Lynch ) ;
10019: LD_EXP 39
10023: PPUSH
10024: CALL_OW 64
// end ; if i = Turner then
10028: LD_VAR 0 1
10032: PUSH
10033: LD_EXP 41
10037: EQUAL
10038: IFFALSE 10065
// begin save_group := save_group ^ Turner ;
10040: LD_ADDR_EXP 20
10044: PUSH
10045: LD_EXP 20
10049: PUSH
10050: LD_EXP 41
10054: ADD
10055: ST_TO_ADDR
// RemoveUnit ( Turner ) ;
10056: LD_EXP 41
10060: PPUSH
10061: CALL_OW 64
// end ; if i = Jillian then
10065: LD_VAR 0 1
10069: PUSH
10070: LD_EXP 42
10074: EQUAL
10075: IFFALSE 10102
// begin save_group := save_group ^ Jillian ;
10077: LD_ADDR_EXP 20
10081: PUSH
10082: LD_EXP 20
10086: PUSH
10087: LD_EXP 42
10091: ADD
10092: ST_TO_ADDR
// RemoveUnit ( Jillian ) ;
10093: LD_EXP 42
10097: PPUSH
10098: CALL_OW 64
// end ; if i = Walker then
10102: LD_VAR 0 1
10106: PUSH
10107: LD_EXP 40
10111: EQUAL
10112: IFFALSE 10139
// begin save_group := save_group ^ Walker ;
10114: LD_ADDR_EXP 20
10118: PUSH
10119: LD_EXP 20
10123: PUSH
10124: LD_EXP 40
10128: ADD
10129: ST_TO_ADDR
// RemoveUnit ( Walker ) ;
10130: LD_EXP 40
10134: PPUSH
10135: CALL_OW 64
// end ; if i = Frank then
10139: LD_VAR 0 1
10143: PUSH
10144: LD_EXP 43
10148: EQUAL
10149: IFFALSE 10176
// begin save_group := save_group ^ Frank ;
10151: LD_ADDR_EXP 20
10155: PUSH
10156: LD_EXP 20
10160: PUSH
10161: LD_EXP 43
10165: ADD
10166: ST_TO_ADDR
// RemoveUnit ( Frank ) ;
10167: LD_EXP 43
10171: PPUSH
10172: CALL_OW 64
// end ; if IsOk ( i ) and GetType ( i ) = unit_human and not i in save_group then
10176: LD_VAR 0 1
10180: PPUSH
10181: CALL_OW 302
10185: PUSH
10186: LD_VAR 0 1
10190: PPUSH
10191: CALL_OW 247
10195: PUSH
10196: LD_INT 1
10198: EQUAL
10199: AND
10200: PUSH
10201: LD_VAR 0 1
10205: PUSH
10206: LD_EXP 20
10210: IN
10211: NOT
10212: AND
10213: IFFALSE 10240
// begin save_others := save_others ^ i ;
10215: LD_ADDR_EXP 19
10219: PUSH
10220: LD_EXP 19
10224: PUSH
10225: LD_VAR 0 1
10229: ADD
10230: ST_TO_ADDR
// RemoveUnit ( i ) ;
10231: LD_VAR 0 1
10235: PPUSH
10236: CALL_OW 64
// end ; end ;
10240: GO 9570
10242: POP
10243: POP
// end ;
10244: PPOPN 2
10246: END
// every 0 0$01 trigger ( not show_query and not wait_for_them ) or ( wait_for_them and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 ) do
10247: LD_EXP 21
10251: NOT
10252: PUSH
10253: LD_EXP 22
10257: NOT
10258: AND
10259: PUSH
10260: LD_EXP 22
10264: PUSH
10265: LD_INT 22
10267: PUSH
10268: LD_INT 1
10270: PUSH
10271: EMPTY
10272: LIST
10273: LIST
10274: PUSH
10275: LD_INT 21
10277: PUSH
10278: LD_INT 1
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: PUSH
10285: EMPTY
10286: LIST
10287: LIST
10288: PPUSH
10289: CALL_OW 69
10293: PUSH
10294: LD_INT 0
10296: EQUAL
10297: AND
10298: OR
10299: IFFALSE 10308
10301: GO 10303
10303: DISABLE
// EndMission ;
10304: CALL 10309 0 0
10308: END
// export function EndMission ; var counter , i ; begin
10309: LD_INT 0
10311: PPUSH
10312: PPUSH
10313: PPUSH
// if solar_builded then
10314: LD_EXP 11
10318: IFFALSE 10332
// AddMedal ( Solar1 , 1 ) else
10320: LD_STRING Solar1
10322: PPUSH
10323: LD_INT 1
10325: PPUSH
10326: CALL_OW 101
10330: GO 10343
// AddMedal ( Solar1 , - 1 ) ;
10332: LD_STRING Solar1
10334: PPUSH
10335: LD_INT 1
10337: NEG
10338: PPUSH
10339: CALL_OW 101
// if veh_on_meta then
10343: LD_EXP 23
10347: IFFALSE 10361
// AddMedal ( Solar2 , 1 ) else
10349: LD_STRING Solar2
10351: PPUSH
10352: LD_INT 1
10354: PPUSH
10355: CALL_OW 101
10359: GO 10391
// if solar_builded then
10361: LD_EXP 11
10365: IFFALSE 10380
// AddMedal ( Solar2 , - 1 ) else
10367: LD_STRING Solar2
10369: PPUSH
10370: LD_INT 1
10372: NEG
10373: PPUSH
10374: CALL_OW 101
10378: GO 10391
// AddMedal ( Solar2 , - 2 ) ;
10380: LD_STRING Solar2
10382: PPUSH
10383: LD_INT 2
10385: NEG
10386: PPUSH
10387: CALL_OW 101
// counter := save_group ^ save_others ;
10391: LD_ADDR_VAR 0 2
10395: PUSH
10396: LD_EXP 20
10400: PUSH
10401: LD_EXP 19
10405: ADD
10406: ST_TO_ADDR
// if counter = 10 then
10407: LD_VAR 0 2
10411: PUSH
10412: LD_INT 10
10414: EQUAL
10415: IFFALSE 10429
// AddMedal ( No , 1 ) else
10417: LD_STRING No
10419: PPUSH
10420: LD_INT 1
10422: PPUSH
10423: CALL_OW 101
10427: GO 10473
// if counter < 10 and counter > 6 then
10429: LD_VAR 0 2
10433: PUSH
10434: LD_INT 10
10436: LESS
10437: PUSH
10438: LD_VAR 0 2
10442: PUSH
10443: LD_INT 6
10445: GREATER
10446: AND
10447: IFFALSE 10462
// AddMedal ( No , - 1 ) else
10449: LD_STRING No
10451: PPUSH
10452: LD_INT 1
10454: NEG
10455: PPUSH
10456: CALL_OW 101
10460: GO 10473
// AddMedal ( UpTo4 , - 1 ) ;
10462: LD_STRING UpTo4
10464: PPUSH
10465: LD_INT 1
10467: NEG
10468: PPUSH
10469: CALL_OW 101
// GiveMedals ( MAIN ) ;
10473: LD_STRING MAIN
10475: PPUSH
10476: CALL_OW 102
// if IsDead ( Pokryshkin ) then
10480: LD_EXP 44
10484: PPUSH
10485: CALL_OW 301
10489: IFFALSE 10529
// for i in save_group ^ save_others do
10491: LD_ADDR_VAR 0 3
10495: PUSH
10496: LD_EXP 20
10500: PUSH
10501: LD_EXP 19
10505: ADD
10506: PUSH
10507: FOR_IN
10508: IFFALSE 10527
// AddExperience ( i , skill_combat , 1500 ) ;
10510: LD_VAR 0 3
10514: PPUSH
10515: LD_INT 1
10517: PPUSH
10518: LD_INT 1500
10520: PPUSH
10521: CALL_OW 492
10525: GO 10507
10527: POP
10528: POP
// RewardPeople ( save_group ^ save_others ) ;
10529: LD_EXP 20
10533: PUSH
10534: LD_EXP 19
10538: ADD
10539: PPUSH
10540: CALL_OW 43
// SaveCharacters ( JMM , JMM ) ;
10544: LD_EXP 29
10548: PPUSH
10549: LD_STRING JMM
10551: PPUSH
10552: CALL_OW 38
// if Bobby in save_group then
10556: LD_EXP 30
10560: PUSH
10561: LD_EXP 20
10565: IN
10566: IFFALSE 10580
// SaveCharacters ( Bobby , Bobby ) ;
10568: LD_EXP 30
10572: PPUSH
10573: LD_STRING Bobby
10575: PPUSH
10576: CALL_OW 38
// if Cyrus in save_group then
10580: LD_EXP 31
10584: PUSH
10585: LD_EXP 20
10589: IN
10590: IFFALSE 10604
// SaveCharacters ( Cyrus , Cyrus ) ;
10592: LD_EXP 31
10596: PPUSH
10597: LD_STRING Cyrus
10599: PPUSH
10600: CALL_OW 38
// if Lisa in save_group then
10604: LD_EXP 32
10608: PUSH
10609: LD_EXP 20
10613: IN
10614: IFFALSE 10628
// SaveCharacters ( Lisa , Lisa ) ;
10616: LD_EXP 32
10620: PPUSH
10621: LD_STRING Lisa
10623: PPUSH
10624: CALL_OW 38
// if Frank in save_group then
10628: LD_EXP 43
10632: PUSH
10633: LD_EXP 20
10637: IN
10638: IFFALSE 10652
// SaveCharacters ( Frank , Frank ) ;
10640: LD_EXP 43
10644: PPUSH
10645: LD_STRING Frank
10647: PPUSH
10648: CALL_OW 38
// if Khatam in save_group then
10652: LD_EXP 33
10656: PUSH
10657: LD_EXP 20
10661: IN
10662: IFFALSE 10676
// SaveCharacters ( Khatam , Khatam ) ;
10664: LD_EXP 33
10668: PPUSH
10669: LD_STRING Khatam
10671: PPUSH
10672: CALL_OW 38
// if Lynch in save_group then
10676: LD_EXP 39
10680: PUSH
10681: LD_EXP 20
10685: IN
10686: IFFALSE 10700
// SaveCharacters ( Lynch , Lynch ) ;
10688: LD_EXP 39
10692: PPUSH
10693: LD_STRING Lynch
10695: PPUSH
10696: CALL_OW 38
// if Walker in save_group then
10700: LD_EXP 40
10704: PUSH
10705: LD_EXP 20
10709: IN
10710: IFFALSE 10724
// SaveCharacters ( Walker , Walker ) ;
10712: LD_EXP 40
10716: PPUSH
10717: LD_STRING Walker
10719: PPUSH
10720: CALL_OW 38
// if Turner in save_group then
10724: LD_EXP 41
10728: PUSH
10729: LD_EXP 20
10733: IN
10734: IFFALSE 10748
// SaveCharacters ( Turner , Turner ) ;
10736: LD_EXP 41
10740: PPUSH
10741: LD_STRING Turner
10743: PPUSH
10744: CALL_OW 38
// if Jillian in save_group then
10748: LD_EXP 42
10752: PUSH
10753: LD_EXP 20
10757: IN
10758: IFFALSE 10772
// SaveCharacters ( Jillian , Jillian ) ;
10760: LD_EXP 42
10764: PPUSH
10765: LD_STRING Jillian
10767: PPUSH
10768: CALL_OW 38
// if save_others then
10772: LD_EXP 19
10776: IFFALSE 10790
// SaveCharacters ( save_others , 03_others ) ;
10778: LD_EXP 19
10782: PPUSH
10783: LD_STRING 03_others
10785: PPUSH
10786: CALL_OW 38
// if Bierezov then
10790: LD_EXP 37
10794: IFFALSE 10804
// begin ResetFog ;
10796: CALL_OW 335
// DisplayEndingScene ;
10800: CALL 10813 0 0
// end ; YouWin ;
10804: CALL_OW 103
// end ;
10808: LD_VAR 0 1
10812: RET
// export function DisplayEndingScene ; var i , filter , fake_cornel , fake_bierezov , fake_russians ; begin
10813: LD_INT 0
10815: PPUSH
10816: PPUSH
10817: PPUSH
10818: PPUSH
10819: PPUSH
10820: PPUSH
// InGameOn ;
10821: CALL_OW 8
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
10825: LD_INT 208
10827: PPUSH
10828: LD_INT 62
10830: PPUSH
10831: LD_INT 1
10833: PPUSH
10834: LD_INT 10
10836: NEG
10837: PPUSH
10838: CALL_OW 330
// RemoveSeeing ( 208 , 62 , 1 ) ;
10842: LD_INT 208
10844: PPUSH
10845: LD_INT 62
10847: PPUSH
10848: LD_INT 1
10850: PPUSH
10851: CALL_OW 331
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ] ) ;
10855: LD_ADDR_VAR 0 3
10859: PUSH
10860: LD_INT 22
10862: PUSH
10863: LD_INT 3
10865: PUSH
10866: EMPTY
10867: LIST
10868: LIST
10869: PUSH
10870: LD_INT 2
10872: PUSH
10873: LD_INT 21
10875: PUSH
10876: LD_INT 2
10878: PUSH
10879: EMPTY
10880: LIST
10881: LIST
10882: PUSH
10883: LD_INT 21
10885: PUSH
10886: LD_INT 1
10888: PUSH
10889: EMPTY
10890: LIST
10891: LIST
10892: PUSH
10893: EMPTY
10894: LIST
10895: LIST
10896: LIST
10897: PUSH
10898: EMPTY
10899: LIST
10900: LIST
10901: PPUSH
10902: CALL_OW 69
10906: ST_TO_ADDR
// if filter then
10907: LD_VAR 0 3
10911: IFFALSE 10939
// for i in filter do
10913: LD_ADDR_VAR 0 2
10917: PUSH
10918: LD_VAR 0 3
10922: PUSH
10923: FOR_IN
10924: IFFALSE 10937
// RemoveUnit ( i ) ;
10926: LD_VAR 0 2
10930: PPUSH
10931: CALL_OW 64
10935: GO 10923
10937: POP
10938: POP
// filter := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) ;
10939: LD_ADDR_VAR 0 3
10943: PUSH
10944: LD_INT 22
10946: PUSH
10947: LD_INT 4
10949: PUSH
10950: EMPTY
10951: LIST
10952: LIST
10953: PUSH
10954: LD_INT 21
10956: PUSH
10957: LD_INT 1
10959: PUSH
10960: EMPTY
10961: LIST
10962: LIST
10963: PUSH
10964: EMPTY
10965: LIST
10966: LIST
10967: PPUSH
10968: CALL_OW 69
10972: ST_TO_ADDR
// if filter then
10973: LD_VAR 0 3
10977: IFFALSE 11008
// for i in filter do
10979: LD_ADDR_VAR 0 2
10983: PUSH
10984: LD_VAR 0 3
10988: PUSH
10989: FOR_IN
10990: IFFALSE 11006
// SetLives ( i , 0 ) ;
10992: LD_VAR 0 2
10996: PPUSH
10997: LD_INT 0
10999: PPUSH
11000: CALL_OW 234
11004: GO 10989
11006: POP
11007: POP
// uc_side := 4 ;
11008: LD_ADDR_OWVAR 20
11012: PUSH
11013: LD_INT 4
11015: ST_TO_ADDR
// fake_cornel := PrepareUnit ( Cornell , false ) ;
11016: LD_ADDR_VAR 0 4
11020: PUSH
11021: LD_STRING Cornell
11023: PPUSH
11024: LD_INT 0
11026: PPUSH
11027: CALL 417 0 2
11031: ST_TO_ADDR
// PlaceUnitXY ( fake_cornel , 208 , 62 , false ) ;
11032: LD_VAR 0 4
11036: PPUSH
11037: LD_INT 208
11039: PPUSH
11040: LD_INT 62
11042: PPUSH
11043: LD_INT 0
11045: PPUSH
11046: CALL_OW 48
// SetLives ( fake_cornel , 100 ) ;
11050: LD_VAR 0 4
11054: PPUSH
11055: LD_INT 100
11057: PPUSH
11058: CALL_OW 234
// DoNotAttack ( 3 , fake_cornel ) ;
11062: LD_INT 3
11064: PPUSH
11065: LD_VAR 0 4
11069: PPUSH
11070: CALL_OW 471
// SetAttitude ( 4 , 3 , att_friend , true ) ;
11074: LD_INT 4
11076: PPUSH
11077: LD_INT 3
11079: PPUSH
11080: LD_INT 1
11082: PPUSH
11083: LD_INT 1
11085: PPUSH
11086: CALL_OW 80
// uc_side := 3 ;
11090: LD_ADDR_OWVAR 20
11094: PUSH
11095: LD_INT 3
11097: ST_TO_ADDR
// uc_nation := 3 ;
11098: LD_ADDR_OWVAR 21
11102: PUSH
11103: LD_INT 3
11105: ST_TO_ADDR
// InitHc ;
11106: CALL_OW 19
// fake_bierezov := PrepareUnit ( Mikhail , false ) ;
11110: LD_ADDR_VAR 0 5
11114: PUSH
11115: LD_STRING Mikhail
11117: PPUSH
11118: LD_INT 0
11120: PPUSH
11121: CALL 417 0 2
11125: ST_TO_ADDR
// PrepareHuman ( 1 , 1 , 0 ) ;
11126: LD_INT 1
11128: PPUSH
11129: LD_INT 1
11131: PPUSH
11132: LD_INT 0
11134: PPUSH
11135: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
11139: LD_ADDR_VAR 0 6
11143: PUSH
11144: LD_VAR 0 6
11148: PUSH
11149: CALL_OW 44
11153: ADD
11154: ST_TO_ADDR
// fake_russians := fake_russians ^ CreateHuman ;
11155: LD_ADDR_VAR 0 6
11159: PUSH
11160: LD_VAR 0 6
11164: PUSH
11165: CALL_OW 44
11169: ADD
11170: ST_TO_ADDR
// PrepareHuman ( 2 , 4 , 0 ) ;
11171: LD_INT 2
11173: PPUSH
11174: LD_INT 4
11176: PPUSH
11177: LD_INT 0
11179: PPUSH
11180: CALL_OW 380
// fake_russians := fake_russians ^ CreateHuman ;
11184: LD_ADDR_VAR 0 6
11188: PUSH
11189: LD_VAR 0 6
11193: PUSH
11194: CALL_OW 44
11198: ADD
11199: ST_TO_ADDR
// PlaceUnitArea ( fake_bierezov , endingSceneArea , false ) ;
11200: LD_VAR 0 5
11204: PPUSH
11205: LD_INT 17
11207: PPUSH
11208: LD_INT 0
11210: PPUSH
11211: CALL_OW 49
// ComMoveXY ( fake_bierezov , 210 , 63 ) ;
11215: LD_VAR 0 5
11219: PPUSH
11220: LD_INT 210
11222: PPUSH
11223: LD_INT 63
11225: PPUSH
11226: CALL_OW 111
// AddComTurnXY ( fake_bierezov , 208 , 62 ) ;
11230: LD_VAR 0 5
11234: PPUSH
11235: LD_INT 208
11237: PPUSH
11238: LD_INT 62
11240: PPUSH
11241: CALL_OW 178
// for i in fake_russians do
11245: LD_ADDR_VAR 0 2
11249: PUSH
11250: LD_VAR 0 6
11254: PUSH
11255: FOR_IN
11256: IFFALSE 11334
// begin PlaceUnitArea ( i , endingSceneArea , false ) ;
11258: LD_VAR 0 2
11262: PPUSH
11263: LD_INT 17
11265: PPUSH
11266: LD_INT 0
11268: PPUSH
11269: CALL_OW 49
// ComMoveXY ( i , 215 , 67 ) ;
11273: LD_VAR 0 2
11277: PPUSH
11278: LD_INT 215
11280: PPUSH
11281: LD_INT 67
11283: PPUSH
11284: CALL_OW 111
// AddComTurnXY ( i , 208 , 62 ) ;
11288: LD_VAR 0 2
11292: PPUSH
11293: LD_INT 208
11295: PPUSH
11296: LD_INT 62
11298: PPUSH
11299: CALL_OW 178
// if GetClass ( i ) = 4 then
11303: LD_VAR 0 2
11307: PPUSH
11308: CALL_OW 257
11312: PUSH
11313: LD_INT 4
11315: EQUAL
11316: IFFALSE 11332
// ComHeal ( i , fake_cornel ) ;
11318: LD_VAR 0 2
11322: PPUSH
11323: LD_VAR 0 4
11327: PPUSH
11328: CALL_OW 128
// end ;
11332: GO 11255
11334: POP
11335: POP
// Wait ( 0 0$01 ) ;
11336: LD_INT 35
11338: PPUSH
11339: CALL_OW 67
// CenterNowOnXY ( 208 , 62 ) ;
11343: LD_INT 208
11345: PPUSH
11346: LD_INT 62
11348: PPUSH
11349: CALL_OW 86
// PlaceSeeing ( 208 , 62 , 1 , - 10 ) ;
11353: LD_INT 208
11355: PPUSH
11356: LD_INT 62
11358: PPUSH
11359: LD_INT 1
11361: PPUSH
11362: LD_INT 10
11364: NEG
11365: PPUSH
11366: CALL_OW 330
// Wait ( 0 0$15 ) ;
11370: LD_INT 525
11372: PPUSH
11373: CALL_OW 67
// RemoveSeeing ( 208 , 62 , 1 ) ;
11377: LD_INT 208
11379: PPUSH
11380: LD_INT 62
11382: PPUSH
11383: LD_INT 1
11385: PPUSH
11386: CALL_OW 331
// ResetFog ;
11390: CALL_OW 335
// InGameOff ;
11394: CALL_OW 9
// end ; end_of_file
11398: LD_VAR 0 1
11402: RET
// every 0 0$01 trigger cornel_active do var i , has_eng , filter , dep , blist , crates , cargo , sol ;
11403: LD_EXP 6
11407: IFFALSE 12438
11409: GO 11411
11411: DISABLE
11412: LD_INT 0
11414: PPUSH
11415: PPUSH
11416: PPUSH
11417: PPUSH
11418: PPUSH
11419: PPUSH
11420: PPUSH
11421: PPUSH
// begin ComMoveXY ( Cornel ^ Bierezov ^ cornel_units , 250 , 120 ) ;
11422: LD_EXP 36
11426: PUSH
11427: LD_EXP 37
11431: ADD
11432: PUSH
11433: LD_EXP 4
11437: ADD
11438: PPUSH
11439: LD_INT 250
11441: PPUSH
11442: LD_INT 120
11444: PPUSH
11445: CALL_OW 111
// has_eng := UnitFilter ( cornel_units , [ f_class , 2 ] ) ;
11449: LD_ADDR_VAR 0 2
11453: PUSH
11454: LD_EXP 4
11458: PPUSH
11459: LD_INT 25
11461: PUSH
11462: LD_INT 2
11464: PUSH
11465: EMPTY
11466: LIST
11467: LIST
11468: PPUSH
11469: CALL_OW 72
11473: ST_TO_ADDR
// filter := UnitFilter ( cornel_units , [ f_type , unit_human ] ) ;
11474: LD_ADDR_VAR 0 3
11478: PUSH
11479: LD_EXP 4
11483: PPUSH
11484: LD_INT 21
11486: PUSH
11487: LD_INT 1
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: PPUSH
11494: CALL_OW 72
11498: ST_TO_ADDR
// if not has_eng then
11499: LD_VAR 0 2
11503: NOT
11504: IFFALSE 11587
// begin uc_side := 4 ;
11506: LD_ADDR_OWVAR 20
11510: PUSH
11511: LD_INT 4
11513: ST_TO_ADDR
// uc_nation := 1 ;
11514: LD_ADDR_OWVAR 21
11518: PUSH
11519: LD_INT 1
11521: ST_TO_ADDR
// bc_type := b_depot ;
11522: LD_ADDR_OWVAR 42
11526: PUSH
11527: LD_INT 0
11529: ST_TO_ADDR
// bc_level := 2 ;
11530: LD_ADDR_OWVAR 43
11534: PUSH
11535: LD_INT 2
11537: ST_TO_ADDR
// dep := CreateAndPlaceBuildingXYD ( 264 , 120 , 4 ) ;
11538: LD_ADDR_VAR 0 4
11542: PUSH
11543: LD_INT 264
11545: PPUSH
11546: LD_INT 120
11548: PPUSH
11549: LD_INT 4
11551: PPUSH
11552: CALL_OW 47
11556: ST_TO_ADDR
// PlaceSeeing ( 264 , 120 , 4 , - 10 ) ;
11557: LD_INT 264
11559: PPUSH
11560: LD_INT 120
11562: PPUSH
11563: LD_INT 4
11565: PPUSH
11566: LD_INT 10
11568: NEG
11569: PPUSH
11570: CALL_OW 330
// RemoveSeeing ( 264 , 120 , 4 ) ;
11574: LD_INT 264
11576: PPUSH
11577: LD_INT 120
11579: PPUSH
11580: LD_INT 4
11582: PPUSH
11583: CALL_OW 331
// end ; repeat wait ( 0 0$01 ) ;
11587: LD_INT 35
11589: PPUSH
11590: CALL_OW 67
// until IsInArea ( Cornel , cornelBaseArea ) ;
11594: LD_EXP 36
11598: PPUSH
11599: LD_INT 10
11601: PPUSH
11602: CALL_OW 308
11606: IFFALSE 11587
// if has_eng and not dep then
11608: LD_VAR 0 2
11612: PUSH
11613: LD_VAR 0 4
11617: NOT
11618: AND
11619: IFFALSE 11733
// begin ComBuild ( has_eng , b_depot , 264 , 120 , 4 ) ;
11621: LD_VAR 0 2
11625: PPUSH
11626: LD_INT 0
11628: PPUSH
11629: LD_INT 264
11631: PPUSH
11632: LD_INT 120
11634: PPUSH
11635: LD_INT 4
11637: PPUSH
11638: CALL_OW 145
// repeat wait ( 0 0$01 ) ;
11642: LD_INT 35
11644: PPUSH
11645: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] , [ f_not , [ f_constructed ] ] ] ) ;
11649: LD_INT 22
11651: PUSH
11652: LD_INT 4
11654: PUSH
11655: EMPTY
11656: LIST
11657: LIST
11658: PUSH
11659: LD_INT 30
11661: PUSH
11662: LD_INT 0
11664: PUSH
11665: EMPTY
11666: LIST
11667: LIST
11668: PUSH
11669: LD_INT 3
11671: PUSH
11672: LD_INT 57
11674: PUSH
11675: EMPTY
11676: LIST
11677: PUSH
11678: EMPTY
11679: LIST
11680: LIST
11681: PUSH
11682: EMPTY
11683: LIST
11684: LIST
11685: LIST
11686: PPUSH
11687: CALL_OW 69
11691: IFFALSE 11642
// dep := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
11693: LD_ADDR_VAR 0 4
11697: PUSH
11698: LD_INT 22
11700: PUSH
11701: LD_INT 4
11703: PUSH
11704: EMPTY
11705: LIST
11706: LIST
11707: PUSH
11708: LD_INT 30
11710: PUSH
11711: LD_INT 0
11713: PUSH
11714: EMPTY
11715: LIST
11716: LIST
11717: PUSH
11718: EMPTY
11719: LIST
11720: LIST
11721: PPUSH
11722: CALL_OW 69
11726: PUSH
11727: LD_INT 1
11729: ARRAY
11730: ST_TO_ADDR
// end else
11731: GO 11850
// begin SetSide ( dep , 4 ) ;
11733: LD_VAR 0 4
11737: PPUSH
11738: LD_INT 4
11740: PPUSH
11741: CALL_OW 235
// for i = 1 to 3 do
11745: LD_ADDR_VAR 0 1
11749: PUSH
11750: DOUBLE
11751: LD_INT 1
11753: DEC
11754: ST_TO_ADDR
11755: LD_INT 3
11757: PUSH
11758: FOR_TO
11759: IFFALSE 11816
// begin ComEnterUnit ( filter [ i ] , dep ) ;
11761: LD_VAR 0 3
11765: PUSH
11766: LD_VAR 0 1
11770: ARRAY
11771: PPUSH
11772: LD_VAR 0 4
11776: PPUSH
11777: CALL_OW 120
// AddComChangeProfession ( filter [ i ] , 2 ) ;
11781: LD_VAR 0 3
11785: PUSH
11786: LD_VAR 0 1
11790: ARRAY
11791: PPUSH
11792: LD_INT 2
11794: PPUSH
11795: CALL_OW 183
// AddComExitBuilding ( filter [ i ] ) ;
11799: LD_VAR 0 3
11803: PUSH
11804: LD_VAR 0 1
11808: ARRAY
11809: PPUSH
11810: CALL_OW 182
// end ;
11814: GO 11758
11816: POP
11817: POP
// repeat wait ( 0 0$01 ) ;
11818: LD_INT 35
11820: PPUSH
11821: CALL_OW 67
// until UnitFilter ( filter , [ f_class , 2 ] ) = 3 ;
11825: LD_VAR 0 3
11829: PPUSH
11830: LD_INT 25
11832: PUSH
11833: LD_INT 2
11835: PUSH
11836: EMPTY
11837: LIST
11838: LIST
11839: PPUSH
11840: CALL_OW 72
11844: PUSH
11845: LD_INT 3
11847: EQUAL
11848: IFFALSE 11818
// end ; ComEnterUnit ( Bierezov , dep ) ;
11850: LD_EXP 37
11854: PPUSH
11855: LD_VAR 0 4
11859: PPUSH
11860: CALL_OW 120
// if IsInUnit ( Cornel ) then
11864: LD_EXP 36
11868: PPUSH
11869: CALL_OW 310
11873: IFFALSE 11956
// begin cargo := IsInUnit ( Cornel ) ;
11875: LD_ADDR_VAR 0 7
11879: PUSH
11880: LD_EXP 36
11884: PPUSH
11885: CALL_OW 310
11889: ST_TO_ADDR
// if GetCargo ( cargo , mat_cans ) then
11890: LD_VAR 0 7
11894: PPUSH
11895: LD_INT 1
11897: PPUSH
11898: CALL_OW 289
11902: IFFALSE 11918
// ComGive ( Cornel , dep ) ;
11904: LD_EXP 36
11908: PPUSH
11909: LD_VAR 0 4
11913: PPUSH
11914: CALL_OW 161
// AddComMoveXY ( Cornel , 235 , 122 ) ;
11918: LD_EXP 36
11922: PPUSH
11923: LD_INT 235
11925: PPUSH
11926: LD_INT 122
11928: PPUSH
11929: CALL_OW 171
// AddComExitVehicle ( Cornel ) ;
11933: LD_EXP 36
11937: PPUSH
11938: CALL_OW 181
// AddComEnterUnit ( Cornel , dep ) ;
11942: LD_EXP 36
11946: PPUSH
11947: LD_VAR 0 4
11951: PPUSH
11952: CALL_OW 180
// end ; has_eng := UnitFilter ( filter , [ f_class , 2 ] ) ;
11956: LD_ADDR_VAR 0 2
11960: PUSH
11961: LD_VAR 0 3
11965: PPUSH
11966: LD_INT 25
11968: PUSH
11969: LD_INT 2
11971: PUSH
11972: EMPTY
11973: LIST
11974: LIST
11975: PPUSH
11976: CALL_OW 72
11980: ST_TO_ADDR
// repeat wait ( 0 0$01 ) ;
11981: LD_INT 35
11983: PPUSH
11984: CALL_OW 67
// crates := GetListOfCratesInArea ( cornelBaseArea ) ;
11988: LD_ADDR_VAR 0 6
11992: PUSH
11993: LD_INT 10
11995: PPUSH
11996: CALL_OW 435
12000: ST_TO_ADDR
// if crates then
12001: LD_VAR 0 6
12005: IFFALSE 12034
// ComCollect ( has_eng , crates [ 1 ] , crates [ 2 ] ) ;
12007: LD_VAR 0 2
12011: PPUSH
12012: LD_VAR 0 6
12016: PUSH
12017: LD_INT 1
12019: ARRAY
12020: PPUSH
12021: LD_VAR 0 6
12025: PUSH
12026: LD_INT 2
12028: ARRAY
12029: PPUSH
12030: CALL_OW 117
// until GetResourceType ( GetBase ( dep ) , mat_cans ) >= 40 ;
12034: LD_VAR 0 4
12038: PPUSH
12039: CALL_OW 274
12043: PPUSH
12044: LD_INT 1
12046: PPUSH
12047: CALL_OW 275
12051: PUSH
12052: LD_INT 40
12054: GREATEREQUAL
12055: IFFALSE 11981
// blist := [ [ b_armoury , 256 , 111 , 2 ] , [ b_breastwork , 243 , 112 , 2 ] ] ;
12057: LD_ADDR_VAR 0 5
12061: PUSH
12062: LD_INT 4
12064: PUSH
12065: LD_INT 256
12067: PUSH
12068: LD_INT 111
12070: PUSH
12071: LD_INT 2
12073: PUSH
12074: EMPTY
12075: LIST
12076: LIST
12077: LIST
12078: LIST
12079: PUSH
12080: LD_INT 31
12082: PUSH
12083: LD_INT 243
12085: PUSH
12086: LD_INT 112
12088: PUSH
12089: LD_INT 2
12091: PUSH
12092: EMPTY
12093: LIST
12094: LIST
12095: LIST
12096: LIST
12097: PUSH
12098: EMPTY
12099: LIST
12100: LIST
12101: ST_TO_ADDR
// for i in blist do
12102: LD_ADDR_VAR 0 1
12106: PUSH
12107: LD_VAR 0 5
12111: PUSH
12112: FOR_IN
12113: IFFALSE 12162
// AddComBuild ( has_eng , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
12115: LD_VAR 0 2
12119: PPUSH
12120: LD_VAR 0 1
12124: PUSH
12125: LD_INT 1
12127: ARRAY
12128: PPUSH
12129: LD_VAR 0 1
12133: PUSH
12134: LD_INT 2
12136: ARRAY
12137: PPUSH
12138: LD_VAR 0 1
12142: PUSH
12143: LD_INT 3
12145: ARRAY
12146: PPUSH
12147: LD_VAR 0 1
12151: PUSH
12152: LD_INT 4
12154: ARRAY
12155: PPUSH
12156: CALL_OW 205
12160: GO 12112
12162: POP
12163: POP
// repeat wait ( 0 0$01 ) ;
12164: LD_INT 35
12166: PPUSH
12167: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
12171: LD_INT 22
12173: PUSH
12174: LD_INT 4
12176: PUSH
12177: EMPTY
12178: LIST
12179: LIST
12180: PUSH
12181: LD_INT 30
12183: PUSH
12184: LD_INT 4
12186: PUSH
12187: EMPTY
12188: LIST
12189: LIST
12190: PUSH
12191: LD_INT 3
12193: PUSH
12194: LD_INT 57
12196: PUSH
12197: EMPTY
12198: LIST
12199: PUSH
12200: EMPTY
12201: LIST
12202: LIST
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: LIST
12208: PPUSH
12209: CALL_OW 69
12213: IFFALSE 12164
// AddComEnterUnit ( filter diff has_eng , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
12215: LD_VAR 0 3
12219: PUSH
12220: LD_VAR 0 2
12224: DIFF
12225: PPUSH
12226: LD_INT 22
12228: PUSH
12229: LD_INT 4
12231: PUSH
12232: EMPTY
12233: LIST
12234: LIST
12235: PUSH
12236: LD_INT 30
12238: PUSH
12239: LD_INT 4
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: PUSH
12246: EMPTY
12247: LIST
12248: LIST
12249: PPUSH
12250: CALL_OW 69
12254: PUSH
12255: LD_INT 1
12257: ARRAY
12258: PPUSH
12259: CALL_OW 180
// repeat wait ( 0 0$01 ) ;
12263: LD_INT 35
12265: PPUSH
12266: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) ;
12270: LD_INT 22
12272: PUSH
12273: LD_INT 4
12275: PUSH
12276: EMPTY
12277: LIST
12278: LIST
12279: PUSH
12280: LD_INT 30
12282: PUSH
12283: LD_INT 31
12285: PUSH
12286: EMPTY
12287: LIST
12288: LIST
12289: PUSH
12290: LD_INT 3
12292: PUSH
12293: LD_INT 57
12295: PUSH
12296: EMPTY
12297: LIST
12298: PUSH
12299: EMPTY
12300: LIST
12301: LIST
12302: PUSH
12303: EMPTY
12304: LIST
12305: LIST
12306: LIST
12307: PPUSH
12308: CALL_OW 69
12312: IFFALSE 12263
// sol := filter diff has_eng ;
12314: LD_ADDR_VAR 0 8
12318: PUSH
12319: LD_VAR 0 3
12323: PUSH
12324: LD_VAR 0 2
12328: DIFF
12329: ST_TO_ADDR
// if GetClass ( sol [ 1 ] ) > 1 then
12330: LD_VAR 0 8
12334: PUSH
12335: LD_INT 1
12337: ARRAY
12338: PPUSH
12339: CALL_OW 257
12343: PUSH
12344: LD_INT 1
12346: GREATER
12347: IFFALSE 12365
// SetClass ( sol [ 1 ] , 1 ) ;
12349: LD_VAR 0 8
12353: PUSH
12354: LD_INT 1
12356: ARRAY
12357: PPUSH
12358: LD_INT 1
12360: PPUSH
12361: CALL_OW 336
// ComExitBuilding ( sol [ 1 ] ) ;
12365: LD_VAR 0 8
12369: PUSH
12370: LD_INT 1
12372: ARRAY
12373: PPUSH
12374: CALL_OW 122
// AddComEnterUnit ( sol [ 1 ] , FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
12378: LD_VAR 0 8
12382: PUSH
12383: LD_INT 1
12385: ARRAY
12386: PPUSH
12387: LD_INT 22
12389: PUSH
12390: LD_INT 4
12392: PUSH
12393: EMPTY
12394: LIST
12395: LIST
12396: PUSH
12397: LD_INT 30
12399: PUSH
12400: LD_INT 31
12402: PUSH
12403: EMPTY
12404: LIST
12405: LIST
12406: PUSH
12407: EMPTY
12408: LIST
12409: LIST
12410: PPUSH
12411: CALL_OW 69
12415: PUSH
12416: LD_INT 1
12418: ARRAY
12419: PPUSH
12420: CALL_OW 180
// ComMoveUnit ( has_eng , dep ) ;
12424: LD_VAR 0 2
12428: PPUSH
12429: LD_VAR 0 4
12433: PPUSH
12434: CALL_OW 112
// end ;
12438: PPOPN 8
12440: END
// every 0 0$03 trigger cornel_prepared do var i , arm , filter ;
12441: LD_EXP 9
12445: IFFALSE 12765
12447: GO 12449
12449: DISABLE
12450: LD_INT 0
12452: PPUSH
12453: PPUSH
12454: PPUSH
// begin arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
12455: LD_ADDR_VAR 0 2
12459: PUSH
12460: LD_INT 22
12462: PUSH
12463: LD_INT 4
12465: PUSH
12466: EMPTY
12467: LIST
12468: LIST
12469: PUSH
12470: LD_INT 30
12472: PUSH
12473: LD_INT 4
12475: PUSH
12476: EMPTY
12477: LIST
12478: LIST
12479: PUSH
12480: EMPTY
12481: LIST
12482: LIST
12483: PPUSH
12484: CALL_OW 69
12488: PUSH
12489: LD_INT 1
12491: ARRAY
12492: ST_TO_ADDR
// ComExitBuilding ( cornel_units ) ;
12493: LD_EXP 4
12497: PPUSH
12498: CALL_OW 122
// for i in cornel_units do
12502: LD_ADDR_VAR 0 1
12506: PUSH
12507: LD_EXP 4
12511: PUSH
12512: FOR_IN
12513: IFFALSE 12567
// if GetClass ( i ) = 2 then
12515: LD_VAR 0 1
12519: PPUSH
12520: CALL_OW 257
12524: PUSH
12525: LD_INT 2
12527: EQUAL
12528: IFFALSE 12565
// begin ComEnterUnit ( i , arm ) ;
12530: LD_VAR 0 1
12534: PPUSH
12535: LD_VAR 0 2
12539: PPUSH
12540: CALL_OW 120
// AddComChangeProfession ( i , 1 ) ;
12544: LD_VAR 0 1
12548: PPUSH
12549: LD_INT 1
12551: PPUSH
12552: CALL_OW 183
// AddComExitBuilding ( i ) ;
12556: LD_VAR 0 1
12560: PPUSH
12561: CALL_OW 182
// end ;
12565: GO 12512
12567: POP
12568: POP
// Wait ( 1 1$00 ) ;
12569: LD_INT 2100
12571: PPUSH
12572: CALL_OW 67
// filter := Cornel ^ Bierezov ^ cornel_units diff UnitFilter ( cornel_units , [ f_type , unit_vehicle ] ) ;
12576: LD_ADDR_VAR 0 3
12580: PUSH
12581: LD_EXP 36
12585: PUSH
12586: LD_EXP 37
12590: ADD
12591: PUSH
12592: LD_EXP 4
12596: ADD
12597: PUSH
12598: LD_EXP 4
12602: PPUSH
12603: LD_INT 21
12605: PUSH
12606: LD_INT 2
12608: PUSH
12609: EMPTY
12610: LIST
12611: LIST
12612: PPUSH
12613: CALL_OW 72
12617: DIFF
12618: ST_TO_ADDR
// ComMoveXY ( filter , 248 , 85 ) ;
12619: LD_VAR 0 3
12623: PPUSH
12624: LD_INT 248
12626: PPUSH
12627: LD_INT 85
12629: PPUSH
12630: CALL_OW 111
// AddComHold ( filter ) ;
12634: LD_VAR 0 3
12638: PPUSH
12639: CALL_OW 200
// repeat wait ( 0 0$01 ) ;
12643: LD_INT 35
12645: PPUSH
12646: CALL_OW 67
// until cornel_attack ;
12650: LD_EXP 7
12654: IFFALSE 12643
// ComAgressiveMove ( filter , 209 , 63 ) ;
12656: LD_VAR 0 3
12660: PPUSH
12661: LD_INT 209
12663: PPUSH
12664: LD_INT 63
12666: PPUSH
12667: CALL_OW 114
// if Bierezov then
12671: LD_EXP 37
12675: IFFALSE 12765
// begin filter := filter diff Bierezov ;
12677: LD_ADDR_VAR 0 3
12681: PUSH
12682: LD_VAR 0 3
12686: PUSH
12687: LD_EXP 37
12691: DIFF
12692: ST_TO_ADDR
// SetSide ( Bierezov , 6 ) ;
12693: LD_EXP 37
12697: PPUSH
12698: LD_INT 6
12700: PPUSH
12701: CALL_OW 235
// ComMoveXY ( Bierezov , 235 , 60 ) ;
12705: LD_EXP 37
12709: PPUSH
12710: LD_INT 235
12712: PPUSH
12713: LD_INT 60
12715: PPUSH
12716: CALL_OW 111
// AddComHold ( Bierezov ) ;
12720: LD_EXP 37
12724: PPUSH
12725: CALL_OW 200
// AddComWait ( Bierezov , 0 0$10 ) ;
12729: LD_EXP 37
12733: PPUSH
12734: LD_INT 350
12736: PPUSH
12737: CALL_OW 202
// AddComMoveXY ( Bierezov , 198 , 28 ) ;
12741: LD_EXP 37
12745: PPUSH
12746: LD_INT 198
12748: PPUSH
12749: LD_INT 28
12751: PPUSH
12752: CALL_OW 171
// AddComHold ( Bierezov ) ;
12756: LD_EXP 37
12760: PPUSH
12761: CALL_OW 200
// end ; end ; end_of_file
12765: PPOPN 3
12767: END
// every 0 0$01 trigger ru_patrol and not prepare_siege and not send_attack_on_cornel do var un , i , j , enemy ;
12768: LD_EXP 45
12772: PUSH
12773: LD_EXP 26
12777: NOT
12778: AND
12779: PUSH
12780: LD_EXP 27
12784: NOT
12785: AND
12786: IFFALSE 13236
12788: GO 12790
12790: DISABLE
12791: LD_INT 0
12793: PPUSH
12794: PPUSH
12795: PPUSH
12796: PPUSH
// begin enable ;
12797: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
12798: LD_ADDR_VAR 0 4
12802: PUSH
12803: LD_INT 81
12805: PUSH
12806: LD_INT 3
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: PPUSH
12813: CALL_OW 69
12817: ST_TO_ADDR
// for i = 1 to ru_patrol do
12818: LD_ADDR_VAR 0 2
12822: PUSH
12823: DOUBLE
12824: LD_INT 1
12826: DEC
12827: ST_TO_ADDR
12828: LD_EXP 45
12832: PUSH
12833: FOR_TO
12834: IFFALSE 13234
// begin un := ru_patrol [ i ] ;
12836: LD_ADDR_VAR 0 1
12840: PUSH
12841: LD_EXP 45
12845: PUSH
12846: LD_VAR 0 2
12850: ARRAY
12851: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
12852: LD_VAR 0 1
12856: PPUSH
12857: LD_INT 13
12859: PPUSH
12860: CALL_OW 308
12864: IFFALSE 12969
// begin if not ru_alert then
12866: LD_EXP 50
12870: NOT
12871: IFFALSE 12881
// ru_alert := true ;
12873: LD_ADDR_EXP 50
12877: PUSH
12878: LD_INT 1
12880: ST_TO_ADDR
// if not See ( 1 , un ) then
12881: LD_INT 1
12883: PPUSH
12884: LD_VAR 0 1
12888: PPUSH
12889: CALL_OW 292
12893: NOT
12894: IFFALSE 12908
// SetLives ( un , 1000 ) ;
12896: LD_VAR 0 1
12900: PPUSH
12901: LD_INT 1000
12903: PPUSH
12904: CALL_OW 234
// ru_patrol := ru_patrol diff un ;
12908: LD_ADDR_EXP 45
12912: PUSH
12913: LD_EXP 45
12917: PUSH
12918: LD_VAR 0 1
12922: DIFF
12923: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
12924: LD_VAR 0 1
12928: PPUSH
12929: LD_INT 22
12931: PUSH
12932: LD_INT 3
12934: PUSH
12935: EMPTY
12936: LIST
12937: LIST
12938: PUSH
12939: LD_INT 30
12941: PUSH
12942: LD_INT 4
12944: PUSH
12945: EMPTY
12946: LIST
12947: LIST
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: PPUSH
12953: CALL_OW 69
12957: PPUSH
12958: CALL 984 0 1
12962: PPUSH
12963: CALL_OW 120
// continue ;
12967: GO 12833
// end ; if IsOk ( un ) and not HasTask ( un ) then
12969: LD_VAR 0 1
12973: PPUSH
12974: CALL_OW 302
12978: PUSH
12979: LD_VAR 0 1
12983: PPUSH
12984: CALL_OW 314
12988: NOT
12989: AND
12990: IFFALSE 13083
// begin for j = 1 to ru_firepoints_south [ i ] do
12992: LD_ADDR_VAR 0 3
12996: PUSH
12997: DOUBLE
12998: LD_INT 1
13000: DEC
13001: ST_TO_ADDR
13002: LD_EXP 49
13006: PUSH
13007: LD_VAR 0 2
13011: ARRAY
13012: PUSH
13013: FOR_TO
13014: IFFALSE 13081
// begin AddComAgressiveMove ( un , ru_firepoints_south [ i ] [ j ] [ 1 ] , ru_firepoints_south [ i ] [ j ] [ 2 ] ) ;
13016: LD_VAR 0 1
13020: PPUSH
13021: LD_EXP 49
13025: PUSH
13026: LD_VAR 0 2
13030: ARRAY
13031: PUSH
13032: LD_VAR 0 3
13036: ARRAY
13037: PUSH
13038: LD_INT 1
13040: ARRAY
13041: PPUSH
13042: LD_EXP 49
13046: PUSH
13047: LD_VAR 0 2
13051: ARRAY
13052: PUSH
13053: LD_VAR 0 3
13057: ARRAY
13058: PUSH
13059: LD_INT 2
13061: ARRAY
13062: PPUSH
13063: CALL_OW 174
// AddComWait ( un , 0 0$02 ) ;
13067: LD_VAR 0 1
13071: PPUSH
13072: LD_INT 70
13074: PPUSH
13075: CALL_OW 202
// end ;
13079: GO 13013
13081: POP
13082: POP
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
13083: LD_VAR 0 1
13087: PPUSH
13088: CALL_OW 256
13092: PUSH
13093: LD_INT 700
13095: LESS
13096: PUSH
13097: LD_VAR 0 1
13101: PPUSH
13102: LD_INT 13
13104: PPUSH
13105: CALL_OW 308
13109: NOT
13110: AND
13111: IFFALSE 13163
// begin ComMoveToArea ( un , retreatArea ) ;
13113: LD_VAR 0 1
13117: PPUSH
13118: LD_INT 13
13120: PPUSH
13121: CALL_OW 113
// if not ru_alert_xy then
13125: LD_EXP 51
13129: NOT
13130: IFFALSE 13161
// ru_alert_xy := [ GetX ( un ) , GetY ( un ) ] ;
13132: LD_ADDR_EXP 51
13136: PUSH
13137: LD_VAR 0 1
13141: PPUSH
13142: CALL_OW 250
13146: PUSH
13147: LD_VAR 0 1
13151: PPUSH
13152: CALL_OW 251
13156: PUSH
13157: EMPTY
13158: LIST
13159: LIST
13160: ST_TO_ADDR
// end else
13161: GO 13232
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
13163: LD_VAR 0 1
13167: PPUSH
13168: LD_VAR 0 4
13172: PPUSH
13173: LD_VAR 0 1
13177: PPUSH
13178: CALL_OW 74
13182: PPUSH
13183: CALL_OW 296
13187: PUSH
13188: LD_INT 9
13190: LESS
13191: PUSH
13192: LD_VAR 0 1
13196: PPUSH
13197: CALL_OW 256
13201: PUSH
13202: LD_INT 500
13204: GREATER
13205: AND
13206: IFFALSE 13232
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
13208: LD_VAR 0 1
13212: PPUSH
13213: LD_VAR 0 4
13217: PPUSH
13218: LD_VAR 0 1
13222: PPUSH
13223: CALL_OW 74
13227: PPUSH
13228: CALL_OW 115
// end ;
13232: GO 12833
13234: POP
13235: POP
// end ;
13236: PPOPN 4
13238: END
// every 0 0$01 trigger ru_alert and ru_alert_xy and not prepare_siege and not send_attack_on_cornel do var i , enemy ;
13239: LD_EXP 50
13243: PUSH
13244: LD_EXP 51
13248: AND
13249: PUSH
13250: LD_EXP 26
13254: NOT
13255: AND
13256: PUSH
13257: LD_EXP 27
13261: NOT
13262: AND
13263: IFFALSE 13473
13265: GO 13267
13267: DISABLE
13268: LD_INT 0
13270: PPUSH
13271: PPUSH
// begin enable ;
13272: ENABLE
// if not ru_vehicles then
13273: LD_EXP 48
13277: NOT
13278: IFFALSE 13282
// exit ;
13280: GO 13473
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
13282: LD_ADDR_VAR 0 2
13286: PUSH
13287: LD_INT 81
13289: PUSH
13290: LD_INT 3
13292: PUSH
13293: EMPTY
13294: LIST
13295: LIST
13296: PPUSH
13297: CALL_OW 69
13301: ST_TO_ADDR
// if ru_vehicles then
13302: LD_EXP 48
13306: IFFALSE 13473
// begin for i in ru_vehicles do
13308: LD_ADDR_VAR 0 1
13312: PUSH
13313: LD_EXP 48
13317: PUSH
13318: FOR_IN
13319: IFFALSE 13471
// begin if IsOk ( i ) and GetDistUnits ( i , NearestUnitToUnit ( enemy , i ) ) < 9 then
13321: LD_VAR 0 1
13325: PPUSH
13326: CALL_OW 302
13330: PUSH
13331: LD_VAR 0 1
13335: PPUSH
13336: LD_VAR 0 2
13340: PPUSH
13341: LD_VAR 0 1
13345: PPUSH
13346: CALL_OW 74
13350: PPUSH
13351: CALL_OW 296
13355: PUSH
13356: LD_INT 9
13358: LESS
13359: AND
13360: IFFALSE 13386
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
13362: LD_VAR 0 1
13366: PPUSH
13367: LD_VAR 0 2
13371: PPUSH
13372: LD_VAR 0 1
13376: PPUSH
13377: CALL_OW 74
13381: PPUSH
13382: CALL_OW 115
// if not HasTask ( i ) and IsOk ( i ) and GetDistUnitXY ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) > 10 then
13386: LD_VAR 0 1
13390: PPUSH
13391: CALL_OW 314
13395: NOT
13396: PUSH
13397: LD_VAR 0 1
13401: PPUSH
13402: CALL_OW 302
13406: AND
13407: PUSH
13408: LD_VAR 0 1
13412: PPUSH
13413: LD_EXP 51
13417: PUSH
13418: LD_INT 1
13420: ARRAY
13421: PPUSH
13422: LD_EXP 51
13426: PUSH
13427: LD_INT 2
13429: ARRAY
13430: PPUSH
13431: CALL_OW 297
13435: PUSH
13436: LD_INT 10
13438: GREATER
13439: AND
13440: IFFALSE 13469
// ComAgressiveMove ( i , ru_alert_xy [ 1 ] , ru_alert_xy [ 2 ] ) ;
13442: LD_VAR 0 1
13446: PPUSH
13447: LD_EXP 51
13451: PUSH
13452: LD_INT 1
13454: ARRAY
13455: PPUSH
13456: LD_EXP 51
13460: PUSH
13461: LD_INT 2
13463: ARRAY
13464: PPUSH
13465: CALL_OW 114
// end ;
13469: GO 13318
13471: POP
13472: POP
// end ; end ;
13473: PPOPN 2
13475: END
// every 3 3$00 trigger ru_alert_xy and ru_alert and not InBattle ( 3 ) and not prepare_siege and not send_attack_on_cornel do var i ;
13476: LD_EXP 51
13480: PUSH
13481: LD_EXP 50
13485: AND
13486: PUSH
13487: LD_INT 3
13489: PPUSH
13490: CALL_OW 463
13494: NOT
13495: AND
13496: PUSH
13497: LD_EXP 26
13501: NOT
13502: AND
13503: PUSH
13504: LD_EXP 27
13508: NOT
13509: AND
13510: IFFALSE 13605
13512: GO 13514
13514: DISABLE
13515: LD_INT 0
13517: PPUSH
// begin enable ;
13518: ENABLE
// ru_alert_xy := false ;
13519: LD_ADDR_EXP 51
13523: PUSH
13524: LD_INT 0
13526: ST_TO_ADDR
// ru_alert := false ;
13527: LD_ADDR_EXP 50
13531: PUSH
13532: LD_INT 0
13534: ST_TO_ADDR
// if ru_vehicles then
13535: LD_EXP 48
13539: IFFALSE 13605
// for i in ru_vehicles do
13541: LD_ADDR_VAR 0 1
13545: PUSH
13546: LD_EXP 48
13550: PUSH
13551: FOR_IN
13552: IFFALSE 13603
// if IsOk ( i ) and GetDistUnitXY ( i , 89 , 36 ) > 10 then
13554: LD_VAR 0 1
13558: PPUSH
13559: CALL_OW 302
13563: PUSH
13564: LD_VAR 0 1
13568: PPUSH
13569: LD_INT 89
13571: PPUSH
13572: LD_INT 36
13574: PPUSH
13575: CALL_OW 297
13579: PUSH
13580: LD_INT 10
13582: GREATER
13583: AND
13584: IFFALSE 13601
// ComMoveXY ( i , 89 , 36 ) ;
13586: LD_VAR 0 1
13590: PPUSH
13591: LD_INT 89
13593: PPUSH
13594: LD_INT 36
13596: PPUSH
13597: CALL_OW 111
13601: GO 13551
13603: POP
13604: POP
// end ;
13605: PPOPN 1
13607: END
// every 0 0$01 trigger ru_forest and not prepare_siege and not send_attack_on_cornel do var i , un , enemy ;
13608: LD_EXP 47
13612: PUSH
13613: LD_EXP 26
13617: NOT
13618: AND
13619: PUSH
13620: LD_EXP 27
13624: NOT
13625: AND
13626: IFFALSE 13910
13628: GO 13630
13630: DISABLE
13631: LD_INT 0
13633: PPUSH
13634: PPUSH
13635: PPUSH
// begin enable ;
13636: ENABLE
// enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
13637: LD_ADDR_VAR 0 3
13641: PUSH
13642: LD_INT 81
13644: PUSH
13645: LD_INT 3
13647: PUSH
13648: EMPTY
13649: LIST
13650: LIST
13651: PPUSH
13652: CALL_OW 69
13656: ST_TO_ADDR
// for i = 1 to ru_forest do
13657: LD_ADDR_VAR 0 1
13661: PUSH
13662: DOUBLE
13663: LD_INT 1
13665: DEC
13666: ST_TO_ADDR
13667: LD_EXP 47
13671: PUSH
13672: FOR_TO
13673: IFFALSE 13908
// begin un := ru_forest [ i ] ;
13675: LD_ADDR_VAR 0 2
13679: PUSH
13680: LD_EXP 47
13684: PUSH
13685: LD_VAR 0 1
13689: ARRAY
13690: ST_TO_ADDR
// if IsInArea ( un , retreatArea ) then
13691: LD_VAR 0 2
13695: PPUSH
13696: LD_INT 13
13698: PPUSH
13699: CALL_OW 308
13703: IFFALSE 13793
// begin if not See ( 1 , un ) then
13705: LD_INT 1
13707: PPUSH
13708: LD_VAR 0 2
13712: PPUSH
13713: CALL_OW 292
13717: NOT
13718: IFFALSE 13732
// SetLives ( un , 1000 ) ;
13720: LD_VAR 0 2
13724: PPUSH
13725: LD_INT 1000
13727: PPUSH
13728: CALL_OW 234
// ru_forest := ru_forest diff un ;
13732: LD_ADDR_EXP 47
13736: PUSH
13737: LD_EXP 47
13741: PUSH
13742: LD_VAR 0 2
13746: DIFF
13747: ST_TO_ADDR
// ComEnterUnit ( un , FindFreePlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_armoury ] ] ) ) ) ;
13748: LD_VAR 0 2
13752: PPUSH
13753: LD_INT 22
13755: PUSH
13756: LD_INT 3
13758: PUSH
13759: EMPTY
13760: LIST
13761: LIST
13762: PUSH
13763: LD_INT 30
13765: PUSH
13766: LD_INT 4
13768: PUSH
13769: EMPTY
13770: LIST
13771: LIST
13772: PUSH
13773: EMPTY
13774: LIST
13775: LIST
13776: PPUSH
13777: CALL_OW 69
13781: PPUSH
13782: CALL 984 0 1
13786: PPUSH
13787: CALL_OW 120
// continue ;
13791: GO 13672
// end ; if GetLives ( un ) < 700 and not IsInArea ( un , retreatArea ) then
13793: LD_VAR 0 2
13797: PPUSH
13798: CALL_OW 256
13802: PUSH
13803: LD_INT 700
13805: LESS
13806: PUSH
13807: LD_VAR 0 2
13811: PPUSH
13812: LD_INT 13
13814: PPUSH
13815: CALL_OW 308
13819: NOT
13820: AND
13821: IFFALSE 13837
// ComMoveToArea ( un , retreatArea ) else
13823: LD_VAR 0 2
13827: PPUSH
13828: LD_INT 13
13830: PPUSH
13831: CALL_OW 113
13835: GO 13906
// if GetDistUnits ( un , NearestUnitToUnit ( enemy , un ) ) < 9 and GetLives ( un ) > 500 then
13837: LD_VAR 0 2
13841: PPUSH
13842: LD_VAR 0 3
13846: PPUSH
13847: LD_VAR 0 2
13851: PPUSH
13852: CALL_OW 74
13856: PPUSH
13857: CALL_OW 296
13861: PUSH
13862: LD_INT 9
13864: LESS
13865: PUSH
13866: LD_VAR 0 2
13870: PPUSH
13871: CALL_OW 256
13875: PUSH
13876: LD_INT 500
13878: GREATER
13879: AND
13880: IFFALSE 13906
// ComAttackUnit ( un , NearestUnitToUnit ( enemy , un ) ) ;
13882: LD_VAR 0 2
13886: PPUSH
13887: LD_VAR 0 3
13891: PPUSH
13892: LD_VAR 0 2
13896: PPUSH
13897: CALL_OW 74
13901: PPUSH
13902: CALL_OW 115
// end ;
13906: GO 13672
13908: POP
13909: POP
// end ;
13910: PPOPN 3
13912: END
// every 0 0$10 trigger not send_attack_on_cornel do var i , filter ;
13913: LD_EXP 27
13917: NOT
13918: IFFALSE 14039
13920: GO 13922
13922: DISABLE
13923: LD_INT 0
13925: PPUSH
13926: PPUSH
// begin enable ;
13927: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
13928: LD_ADDR_VAR 0 2
13932: PUSH
13933: LD_INT 22
13935: PUSH
13936: LD_INT 3
13938: PUSH
13939: EMPTY
13940: LIST
13941: LIST
13942: PUSH
13943: LD_INT 21
13945: PUSH
13946: LD_INT 3
13948: PUSH
13949: EMPTY
13950: LIST
13951: LIST
13952: PUSH
13953: EMPTY
13954: LIST
13955: LIST
13956: PPUSH
13957: CALL_OW 69
13961: ST_TO_ADDR
// if filter then
13962: LD_VAR 0 2
13966: IFFALSE 14039
// for i in filter do
13968: LD_ADDR_VAR 0 1
13972: PUSH
13973: LD_VAR 0 2
13977: PUSH
13978: FOR_IN
13979: IFFALSE 14037
// if GetLives ( i ) < 990 then
13981: LD_VAR 0 1
13985: PPUSH
13986: CALL_OW 256
13990: PUSH
13991: LD_INT 990
13993: LESS
13994: IFFALSE 14035
// begin ru_alert := true ;
13996: LD_ADDR_EXP 50
14000: PUSH
14001: LD_INT 1
14003: ST_TO_ADDR
// ru_alert_xy := [ GetX ( i ) , GetY ( i ) ] ;
14004: LD_ADDR_EXP 51
14008: PUSH
14009: LD_VAR 0 1
14013: PPUSH
14014: CALL_OW 250
14018: PUSH
14019: LD_VAR 0 1
14023: PPUSH
14024: CALL_OW 251
14028: PUSH
14029: EMPTY
14030: LIST
14031: LIST
14032: ST_TO_ADDR
// break ;
14033: GO 14037
// end ;
14035: GO 13978
14037: POP
14038: POP
// end ;
14039: PPOPN 2
14041: END
// every 0 0$30 trigger prepare_siege do var i , un , enemy , filter ;
14042: LD_EXP 26
14046: IFFALSE 14185
14048: GO 14050
14050: DISABLE
14051: LD_INT 0
14053: PPUSH
14054: PPUSH
14055: PPUSH
14056: PPUSH
// begin filter := ru_vehicles ^ ru_forest ^ ru_patrol ;
14057: LD_ADDR_VAR 0 4
14061: PUSH
14062: LD_EXP 48
14066: PUSH
14067: LD_EXP 47
14071: ADD
14072: PUSH
14073: LD_EXP 45
14077: ADD
14078: ST_TO_ADDR
// enemy := FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) ;
14079: LD_ADDR_VAR 0 3
14083: PUSH
14084: LD_INT 3
14086: PPUSH
14087: LD_INT 81
14089: PUSH
14090: LD_INT 3
14092: PUSH
14093: EMPTY
14094: LIST
14095: LIST
14096: PPUSH
14097: CALL_OW 70
14101: ST_TO_ADDR
// if filter and enemy then
14102: LD_VAR 0 4
14106: PUSH
14107: LD_VAR 0 3
14111: AND
14112: IFFALSE 14185
// repeat wait ( 0 0$01 ) ;
14114: LD_INT 35
14116: PPUSH
14117: CALL_OW 67
// for i in filter do
14121: LD_ADDR_VAR 0 1
14125: PUSH
14126: LD_VAR 0 4
14130: PUSH
14131: FOR_IN
14132: IFFALSE 14160
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
14134: LD_VAR 0 1
14138: PPUSH
14139: LD_VAR 0 3
14143: PPUSH
14144: LD_VAR 0 1
14148: PPUSH
14149: CALL_OW 74
14153: PPUSH
14154: CALL_OW 115
// end ;
14158: GO 14131
14160: POP
14161: POP
// until FilterUnitsInArea ( westBaseArea , [ f_enemy , 3 ] ) = 0 ;
14162: LD_INT 3
14164: PPUSH
14165: LD_INT 81
14167: PUSH
14168: LD_INT 3
14170: PUSH
14171: EMPTY
14172: LIST
14173: LIST
14174: PPUSH
14175: CALL_OW 70
14179: PUSH
14180: LD_INT 0
14182: EQUAL
14183: IFFALSE 14114
// end ; end_of_file
14185: PPOPN 4
14187: END
// every 1 1$10 + 0 0$10 trigger jmm_on_west and not cornel_attack and crates_counter do var r ;
14188: LD_EXP 3
14192: PUSH
14193: LD_EXP 7
14197: NOT
14198: AND
14199: PUSH
14200: LD_EXP 17
14204: AND
14205: IFFALSE 14317
14207: GO 14209
14209: DISABLE
14210: LD_INT 0
14212: PPUSH
// begin enable ;
14213: ENABLE
// crates_counter := crates_counter - 50 ;
14214: LD_ADDR_EXP 17
14218: PUSH
14219: LD_EXP 17
14223: PUSH
14224: LD_INT 50
14226: MINUS
14227: ST_TO_ADDR
// CreateCratesArea ( cratesSpawnArea , Rand ( 2 , 5 ) , true ) ;
14228: LD_INT 8
14230: PPUSH
14231: LD_INT 2
14233: PPUSH
14234: LD_INT 5
14236: PPUSH
14237: CALL_OW 12
14241: PPUSH
14242: LD_INT 1
14244: PPUSH
14245: CALL_OW 55
// Wait ( Rand ( 0 0$51 , 0 0$67 ) ) ;
14249: LD_INT 1785
14251: PPUSH
14252: LD_INT 2345
14254: PPUSH
14255: CALL_OW 12
14259: PPUSH
14260: CALL_OW 67
// r := Rand ( 1 , Difficulty + 2 ) ;
14264: LD_ADDR_VAR 0 1
14268: PUSH
14269: LD_INT 1
14271: PPUSH
14272: LD_OWVAR 67
14276: PUSH
14277: LD_INT 2
14279: PLUS
14280: PPUSH
14281: CALL_OW 12
14285: ST_TO_ADDR
// if r < 3 then
14286: LD_VAR 0 1
14290: PUSH
14291: LD_INT 3
14293: LESS
14294: IFFALSE 14317
// CreateCratesArea ( westBaseSpot , Rand ( 1 , 5 ) , true ) ;
14296: LD_INT 4
14298: PPUSH
14299: LD_INT 1
14301: PPUSH
14302: LD_INT 5
14304: PPUSH
14305: CALL_OW 12
14309: PPUSH
14310: LD_INT 1
14312: PPUSH
14313: CALL_OW 55
// end ;
14317: PPOPN 1
14319: END
// every 0 0$01 trigger cornel_active do
14320: LD_EXP 6
14324: IFFALSE 14413
14326: GO 14328
14328: DISABLE
// begin Wait ( 0 0$03 ) ;
14329: LD_INT 105
14331: PPUSH
14332: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
14336: LD_INT 2
14338: PPUSH
14339: LD_INT 5
14341: PPUSH
14342: CALL_OW 12
14346: PPUSH
14347: LD_INT 10
14349: PPUSH
14350: LD_INT 1
14352: PPUSH
14353: CALL_OW 55
// Wait ( 0 0$13 ) ;
14357: LD_INT 455
14359: PPUSH
14360: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
14364: LD_INT 2
14366: PPUSH
14367: LD_INT 5
14369: PPUSH
14370: CALL_OW 12
14374: PPUSH
14375: LD_INT 10
14377: PPUSH
14378: LD_INT 1
14380: PPUSH
14381: CALL_OW 55
// Wait ( 0 0$16 ) ;
14385: LD_INT 560
14387: PPUSH
14388: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , cornelBaseArea , true ) ;
14392: LD_INT 2
14394: PPUSH
14395: LD_INT 5
14397: PPUSH
14398: CALL_OW 12
14402: PPUSH
14403: LD_INT 10
14405: PPUSH
14406: LD_INT 1
14408: PPUSH
14409: CALL_OW 55
// end ; end_of_file
14413: END
// every 0 0$01 trigger cornel_prepared do
14414: LD_EXP 9
14418: IFFALSE 14477
14420: GO 14422
14422: DISABLE
// begin enable ;
14423: ENABLE
// Display_Strings := [ #Am03-1 , cornel_counter ] ;
14424: LD_ADDR_OWVAR 47
14428: PUSH
14429: LD_STRING #Am03-1
14431: PUSH
14432: LD_EXP 8
14436: PUSH
14437: EMPTY
14438: LIST
14439: LIST
14440: ST_TO_ADDR
// cornel_counter := Count ( cornel_counter , - ) ;
14441: LD_ADDR_EXP 8
14445: PUSH
14446: LD_EXP 8
14450: PPUSH
14451: LD_STRING -
14453: PPUSH
14454: CALL 1054 0 2
14458: ST_TO_ADDR
// if cornel_counter = 0 0$00 then
14459: LD_EXP 8
14463: PUSH
14464: LD_INT 0
14466: EQUAL
14467: IFFALSE 14477
// begin Display_Strings := [ ] ;
14469: LD_ADDR_OWVAR 47
14473: PUSH
14474: EMPTY
14475: ST_TO_ADDR
// disable ;
14476: DISABLE
// end ; end ;
14477: END
// every 0 0$01 trigger debug and debug_strings do
14478: LD_EXP 1
14482: PUSH
14483: LD_OWVAR 48
14487: AND
14488: IFFALSE 14504
14490: GO 14492
14492: DISABLE
// begin enable ;
14493: ENABLE
// Display_Strings := debug_strings ;
14494: LD_ADDR_OWVAR 47
14498: PUSH
14499: LD_OWVAR 48
14503: ST_TO_ADDR
// end ; end_of_file
14504: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 1 and not solar_builded then
14505: LD_VAR 0 1
14509: PPUSH
14510: CALL_OW 255
14514: PUSH
14515: LD_INT 1
14517: EQUAL
14518: PUSH
14519: LD_EXP 11
14523: NOT
14524: AND
14525: IFFALSE 14535
// solar_builded := true ;
14527: LD_ADDR_EXP 11
14531: PUSH
14532: LD_INT 1
14534: ST_TO_ADDR
// if GetSide ( veh ) = 1 and time_to_prepare then
14535: LD_VAR 0 1
14539: PPUSH
14540: CALL_OW 255
14544: PUSH
14545: LD_INT 1
14547: EQUAL
14548: PUSH
14549: LD_EXP 24
14553: AND
14554: IFFALSE 14587
// time_to_prepare := time_to_prepare + [ 0 0$50 , 0 0$40 , 0 0$35 ] [ Difficulty ] ;
14556: LD_ADDR_EXP 24
14560: PUSH
14561: LD_EXP 24
14565: PUSH
14566: LD_INT 1750
14568: PUSH
14569: LD_INT 1400
14571: PUSH
14572: LD_INT 1225
14574: PUSH
14575: EMPTY
14576: LIST
14577: LIST
14578: LIST
14579: PUSH
14580: LD_OWVAR 67
14584: ARRAY
14585: PLUS
14586: ST_TO_ADDR
// end ;
14587: PPOPN 2
14589: END
// on UnitDestroyed ( un ) do begin if un in ru_patrol then
14590: LD_VAR 0 1
14594: PUSH
14595: LD_EXP 45
14599: IN
14600: IFFALSE 14618
// ru_patrol := ru_patrol diff un ;
14602: LD_ADDR_EXP 45
14606: PUSH
14607: LD_EXP 45
14611: PUSH
14612: LD_VAR 0 1
14616: DIFF
14617: ST_TO_ADDR
// if un in ru_forest then
14618: LD_VAR 0 1
14622: PUSH
14623: LD_EXP 47
14627: IN
14628: IFFALSE 14646
// ru_forest := ru_forest diff un ;
14630: LD_ADDR_EXP 47
14634: PUSH
14635: LD_EXP 47
14639: PUSH
14640: LD_VAR 0 1
14644: DIFF
14645: ST_TO_ADDR
// if un in ru_vehicles then
14646: LD_VAR 0 1
14650: PUSH
14651: LD_EXP 48
14655: IN
14656: IFFALSE 14674
// ru_vehicles := ru_vehicles diff un ;
14658: LD_ADDR_EXP 48
14662: PUSH
14663: LD_EXP 48
14667: PUSH
14668: LD_VAR 0 1
14672: DIFF
14673: ST_TO_ADDR
// if un = JMM then
14674: LD_VAR 0 1
14678: PUSH
14679: LD_EXP 29
14683: EQUAL
14684: IFFALSE 14693
// YouLost ( 0 ) ;
14686: LD_STRING 0
14688: PPUSH
14689: CALL_OW 104
// if un = us_dep_west then
14693: LD_VAR 0 1
14697: PUSH
14698: LD_INT 1
14700: EQUAL
14701: IFFALSE 14710
// YouLost ( 2 ) ;
14703: LD_STRING 2
14705: PPUSH
14706: CALL_OW 104
// if un = Lynch and GetSide ( Lynch ) = 8 then
14710: LD_VAR 0 1
14714: PUSH
14715: LD_EXP 39
14719: EQUAL
14720: PUSH
14721: LD_EXP 39
14725: PPUSH
14726: CALL_OW 255
14730: PUSH
14731: LD_INT 8
14733: EQUAL
14734: AND
14735: IFFALSE 14744
// YouLost ( 4 ) ;
14737: LD_STRING 4
14739: PPUSH
14740: CALL_OW 104
// end ;
14744: PPOPN 1
14746: END
// every 0 0$01 trigger not game_end and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) + FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) < 4 do
14747: LD_EXP 28
14751: NOT
14752: PUSH
14753: LD_INT 22
14755: PUSH
14756: LD_INT 1
14758: PUSH
14759: EMPTY
14760: LIST
14761: LIST
14762: PUSH
14763: LD_INT 21
14765: PUSH
14766: LD_INT 1
14768: PUSH
14769: EMPTY
14770: LIST
14771: LIST
14772: PUSH
14773: EMPTY
14774: LIST
14775: LIST
14776: PPUSH
14777: CALL_OW 69
14781: PUSH
14782: LD_INT 22
14784: PUSH
14785: LD_INT 8
14787: PUSH
14788: EMPTY
14789: LIST
14790: LIST
14791: PUSH
14792: LD_INT 21
14794: PUSH
14795: LD_INT 1
14797: PUSH
14798: EMPTY
14799: LIST
14800: LIST
14801: PUSH
14802: EMPTY
14803: LIST
14804: LIST
14805: PPUSH
14806: CALL_OW 69
14810: PLUS
14811: PUSH
14812: LD_INT 4
14814: LESS
14815: AND
14816: IFFALSE 14828
14818: GO 14820
14820: DISABLE
// YouLost ( 1 ) ;
14821: LD_STRING 1
14823: PPUSH
14824: CALL_OW 104
14828: END
// every 0 0$01 trigger GetSide ( us_dep_west ) = 3 do
14829: LD_INT 1
14831: PPUSH
14832: CALL_OW 255
14836: PUSH
14837: LD_INT 3
14839: EQUAL
14840: IFFALSE 14852
14842: GO 14844
14844: DISABLE
// YouLost ( 3 ) ;
14845: LD_STRING 3
14847: PPUSH
14848: CALL_OW 104
14852: END
