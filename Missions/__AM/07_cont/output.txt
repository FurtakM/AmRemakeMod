// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 33 0 0
// DebugMode ;
  12: CALL 234 0 0
// PrepareNature ;
  16: CALL 2917 0 0
// PrepareRussians ;
  20: CALL 4459 0 0
// PrepareAmericans ;
  24: CALL 3402 0 0
// Action ;
  28: CALL 8193 0 0
// end ;
  32: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end , must_end ; function Init ; begin
  33: LD_INT 0
  35: PPUSH
// debug := false ;
  36: LD_ADDR_EXP 1
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// mission_prefix := 07c_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 07c_
  51: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  52: LD_ADDR_EXP 2
  56: PUSH
  57: LD_STRING 07_
  59: ST_TO_ADDR
// buildings_counter := 0 ;
  60: LD_ADDR_EXP 4
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// time_to_end := [ [ 30 30$00 , 27 27$00 , 24 24$00 ] [ Difficulty ] , [ 36 36$00 , 33 33$00 , 30 30$00 ] [ Difficulty ] , [ 42 42$00 , 39 39$00 , 36 36$00 ] [ Difficulty ] ] ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 63000
  75: PUSH
  76: LD_INT 56700
  78: PUSH
  79: LD_INT 50400
  81: PUSH
  82: EMPTY
  83: LIST
  84: LIST
  85: LIST
  86: PUSH
  87: LD_OWVAR 67
  91: ARRAY
  92: PUSH
  93: LD_INT 75600
  95: PUSH
  96: LD_INT 69300
  98: PUSH
  99: LD_INT 63000
 101: PUSH
 102: EMPTY
 103: LIST
 104: LIST
 105: LIST
 106: PUSH
 107: LD_OWVAR 67
 111: ARRAY
 112: PUSH
 113: LD_INT 88200
 115: PUSH
 116: LD_INT 81900
 118: PUSH
 119: LD_INT 75600
 121: PUSH
 122: EMPTY
 123: LIST
 124: LIST
 125: LIST
 126: PUSH
 127: LD_OWVAR 67
 131: ARRAY
 132: PUSH
 133: EMPTY
 134: LIST
 135: LIST
 136: LIST
 137: ST_TO_ADDR
// can_end := false ;
 138: LD_ADDR_EXP 6
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// must_end := false ;
 146: LD_ADDR_EXP 7
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// end ;
 154: LD_VAR 0 1
 158: RET
// every 0 0$01 trigger not debug do
 159: LD_EXP 1
 163: NOT
 164: IFFALSE 233
 166: GO 168
 168: DISABLE
// begin enable ;
 169: ENABLE
// if not must_end then
 170: LD_EXP 7
 174: NOT
 175: IFFALSE 196
// display_strings := [ #Am07-1 , tick ] else
 177: LD_ADDR_OWVAR 47
 181: PUSH
 182: LD_STRING #Am07-1
 184: PUSH
 185: LD_OWVAR 1
 189: PUSH
 190: EMPTY
 191: LIST
 192: LIST
 193: ST_TO_ADDR
 194: GO 233
// display_strings := [ #Am07-1 , tick , #Am07-2 , time_to_end [ 3 ] - tick ] ;
 196: LD_ADDR_OWVAR 47
 200: PUSH
 201: LD_STRING #Am07-1
 203: PUSH
 204: LD_OWVAR 1
 208: PUSH
 209: LD_STRING #Am07-2
 211: PUSH
 212: LD_EXP 5
 216: PUSH
 217: LD_INT 3
 219: ARRAY
 220: PUSH
 221: LD_OWVAR 1
 225: MINUS
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: LIST
 232: ST_TO_ADDR
// end ;
 233: END
// function DebugMode ; begin
 234: LD_INT 0
 236: PPUSH
// if not debug then
 237: LD_EXP 1
 241: NOT
 242: IFFALSE 246
// exit ;
 244: GO 253
// FogOff ( 1 ) ;
 246: LD_INT 1
 248: PPUSH
 249: CALL_OW 344
// end ;
 253: LD_VAR 0 1
 257: RET
// every 3 trigger debug do var i , filter ;
 258: LD_EXP 1
 262: IFFALSE 351
 264: GO 266
 266: DISABLE
 267: LD_INT 0
 269: PPUSH
 270: PPUSH
// begin enable ;
 271: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 272: LD_ADDR_VAR 0 2
 276: PUSH
 277: LD_INT 22
 279: PUSH
 280: LD_INT 1
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: PUSH
 287: LD_INT 3
 289: PUSH
 290: LD_INT 24
 292: PUSH
 293: LD_INT 500
 295: PUSH
 296: EMPTY
 297: LIST
 298: LIST
 299: PUSH
 300: EMPTY
 301: LIST
 302: LIST
 303: PUSH
 304: EMPTY
 305: LIST
 306: LIST
 307: PPUSH
 308: CALL_OW 69
 312: ST_TO_ADDR
// if not filter then
 313: LD_VAR 0 2
 317: NOT
 318: IFFALSE 322
// exit ;
 320: GO 351
// for i in filter do
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_VAR 0 2
 331: PUSH
 332: FOR_IN
 333: IFFALSE 349
// SetLives ( i , 1000 ) ;
 335: LD_VAR 0 1
 339: PPUSH
 340: LD_INT 1000
 342: PPUSH
 343: CALL_OW 234
 347: GO 332
 349: POP
 350: POP
// end ; end_of_file
 351: PPOPN 2
 353: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 354: LD_INT 0
 356: PPUSH
 357: PPUSH
// if exist_mode then
 358: LD_VAR 0 2
 362: IFFALSE 387
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 364: LD_ADDR_VAR 0 4
 368: PUSH
 369: LD_EXP 2
 373: PUSH
 374: LD_VAR 0 1
 378: STR
 379: PPUSH
 380: CALL_OW 34
 384: ST_TO_ADDR
 385: GO 402
// unit := NewCharacter ( ident ) ;
 387: LD_ADDR_VAR 0 4
 391: PUSH
 392: LD_VAR 0 1
 396: PPUSH
 397: CALL_OW 25
 401: ST_TO_ADDR
// result := unit ;
 402: LD_ADDR_VAR 0 3
 406: PUSH
 407: LD_VAR 0 4
 411: ST_TO_ADDR
// end ;
 412: LD_VAR 0 3
 416: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 417: LD_INT 0
 419: PPUSH
// uc_side := side ;
 420: LD_ADDR_OWVAR 20
 424: PUSH
 425: LD_VAR 0 1
 429: ST_TO_ADDR
// uc_nation := nation ;
 430: LD_ADDR_OWVAR 21
 434: PUSH
 435: LD_VAR 0 2
 439: ST_TO_ADDR
// vc_chassis := chassis ;
 440: LD_ADDR_OWVAR 37
 444: PUSH
 445: LD_VAR 0 3
 449: ST_TO_ADDR
// vc_engine := engine ;
 450: LD_ADDR_OWVAR 39
 454: PUSH
 455: LD_VAR 0 4
 459: ST_TO_ADDR
// vc_control := control ;
 460: LD_ADDR_OWVAR 38
 464: PUSH
 465: LD_VAR 0 5
 469: ST_TO_ADDR
// vc_weapon := weapon ;
 470: LD_ADDR_OWVAR 40
 474: PUSH
 475: LD_VAR 0 6
 479: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 480: LD_ADDR_OWVAR 41
 484: PUSH
 485: LD_VAR 0 7
 489: ST_TO_ADDR
// result := CreateVehicle ;
 490: LD_ADDR_VAR 0 8
 494: PUSH
 495: CALL_OW 45
 499: ST_TO_ADDR
// end ;
 500: LD_VAR 0 8
 504: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 505: LD_INT 0
 507: PPUSH
 508: PPUSH
 509: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 510: LD_ADDR_VAR 0 4
 514: PUSH
 515: LD_INT 22
 517: PUSH
 518: LD_INT 1
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: PUSH
 525: LD_INT 21
 527: PUSH
 528: LD_INT 1
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: PUSH
 535: LD_INT 50
 537: PUSH
 538: EMPTY
 539: LIST
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: PPUSH
 546: CALL_OW 69
 550: PUSH
 551: LD_EXP 8
 555: PUSH
 556: LD_EXP 9
 560: PUSH
 561: LD_EXP 10
 565: PUSH
 566: LD_EXP 11
 570: PUSH
 571: LD_EXP 12
 575: PUSH
 576: LD_EXP 13
 580: PUSH
 581: LD_EXP 14
 585: PUSH
 586: LD_EXP 15
 590: PUSH
 591: LD_EXP 17
 595: PUSH
 596: LD_EXP 16
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: DIFF
 613: ST_TO_ADDR
// if not filter then
 614: LD_VAR 0 4
 618: NOT
 619: IFFALSE 623
// exit ;
 621: GO 650
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 623: LD_ADDR_VAR 0 2
 627: PUSH
 628: LD_VAR 0 4
 632: PPUSH
 633: LD_INT 26
 635: PUSH
 636: LD_VAR 0 1
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL_OW 72
 649: ST_TO_ADDR
// end ;
 650: LD_VAR 0 2
 654: RET
// export function SayX ( units , ident ) ; var i ; begin
 655: LD_INT 0
 657: PPUSH
 658: PPUSH
// result := false ;
 659: LD_ADDR_VAR 0 3
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// if not units then
 667: LD_VAR 0 1
 671: NOT
 672: IFFALSE 676
// exit ;
 674: GO 730
// for i in units do
 676: LD_ADDR_VAR 0 4
 680: PUSH
 681: LD_VAR 0 1
 685: PUSH
 686: FOR_IN
 687: IFFALSE 728
// if IsOk ( i ) then
 689: LD_VAR 0 4
 693: PPUSH
 694: CALL_OW 302
 698: IFFALSE 726
// begin Say ( i , ident ) ;
 700: LD_VAR 0 4
 704: PPUSH
 705: LD_VAR 0 2
 709: PPUSH
 710: CALL_OW 88
// result := i ;
 714: LD_ADDR_VAR 0 3
 718: PUSH
 719: LD_VAR 0 4
 723: ST_TO_ADDR
// break ;
 724: GO 728
// end ;
 726: GO 686
 728: POP
 729: POP
// end ;
 730: LD_VAR 0 3
 734: RET
// export function GetBaseBuildings ( base ) ; var tmp , i ; begin
 735: LD_INT 0
 737: PPUSH
 738: PPUSH
 739: PPUSH
// result := [ ] ;
 740: LD_ADDR_VAR 0 2
 744: PUSH
 745: EMPTY
 746: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
 747: LD_ADDR_VAR 0 3
 751: PUSH
 752: LD_INT 21
 754: PUSH
 755: LD_INT 3
 757: PUSH
 758: EMPTY
 759: LIST
 760: LIST
 761: PPUSH
 762: CALL_OW 69
 766: ST_TO_ADDR
// if not tmp then
 767: LD_VAR 0 3
 771: NOT
 772: IFFALSE 776
// exit ;
 774: GO 826
// for i in tmp do
 776: LD_ADDR_VAR 0 4
 780: PUSH
 781: LD_VAR 0 3
 785: PUSH
 786: FOR_IN
 787: IFFALSE 824
// if GetBase ( i ) = base then
 789: LD_VAR 0 4
 793: PPUSH
 794: CALL_OW 274
 798: PUSH
 799: LD_VAR 0 1
 803: EQUAL
 804: IFFALSE 822
// result := result ^ i ;
 806: LD_ADDR_VAR 0 2
 810: PUSH
 811: LD_VAR 0 2
 815: PUSH
 816: LD_VAR 0 4
 820: ADD
 821: ST_TO_ADDR
 822: GO 786
 824: POP
 825: POP
// end ;
 826: LD_VAR 0 2
 830: RET
// export function GetTurretWeapon ( tower ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
 831: LD_INT 0
 833: PPUSH
 834: PPUSH
 835: PPUSH
 836: PPUSH
 837: PPUSH
 838: PPUSH
 839: PPUSH
 840: PPUSH
 841: PPUSH
 842: PPUSH
 843: PPUSH
 844: PPUSH
 845: PPUSH
 846: PPUSH
 847: PPUSH
 848: PPUSH
// result := false ;
 849: LD_ADDR_VAR 0 2
 853: PUSH
 854: LD_INT 0
 856: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
 857: LD_VAR 0 1
 861: NOT
 862: PUSH
 863: LD_VAR 0 1
 867: PPUSH
 868: CALL_OW 266
 872: PUSH
 873: LD_INT 32
 875: PUSH
 876: LD_INT 33
 878: PUSH
 879: EMPTY
 880: LIST
 881: LIST
 882: IN
 883: NOT
 884: OR
 885: IFFALSE 889
// exit ;
 887: GO 2049
// nat := GetNation ( tower ) ;
 889: LD_ADDR_VAR 0 11
 893: PUSH
 894: LD_VAR 0 1
 898: PPUSH
 899: CALL_OW 248
 903: ST_TO_ADDR
// side := GetSide ( tower ) ;
 904: LD_ADDR_VAR 0 15
 908: PUSH
 909: LD_VAR 0 1
 913: PPUSH
 914: CALL_OW 255
 918: ST_TO_ADDR
// x := GetX ( tower ) ;
 919: LD_ADDR_VAR 0 9
 923: PUSH
 924: LD_VAR 0 1
 928: PPUSH
 929: CALL_OW 250
 933: ST_TO_ADDR
// y := GetY ( tower ) ;
 934: LD_ADDR_VAR 0 10
 938: PUSH
 939: LD_VAR 0 1
 943: PPUSH
 944: CALL_OW 251
 948: ST_TO_ADDR
// if not x or not y then
 949: LD_VAR 0 9
 953: NOT
 954: PUSH
 955: LD_VAR 0 10
 959: NOT
 960: OR
 961: IFFALSE 965
// exit ;
 963: GO 2049
// weapon := 0 ;
 965: LD_ADDR_VAR 0 17
 969: PUSH
 970: LD_INT 0
 972: ST_TO_ADDR
// fac_list := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun ] ;
 973: LD_ADDR_VAR 0 16
 977: PUSH
 978: LD_INT 42
 980: PUSH
 981: LD_INT 43
 983: PUSH
 984: LD_INT 44
 986: PUSH
 987: LD_INT 46
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: ST_TO_ADDR
// if not fac_list then
 996: LD_VAR 0 16
1000: NOT
1001: IFFALSE 1005
// exit ;
1003: GO 2049
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
1005: LD_ADDR_VAR 0 4
1009: PUSH
1010: LD_INT 4
1012: PUSH
1013: LD_INT 5
1015: PUSH
1016: LD_INT 9
1018: PUSH
1019: LD_INT 10
1021: PUSH
1022: LD_INT 6
1024: PUSH
1025: LD_INT 7
1027: PUSH
1028: LD_INT 11
1030: PUSH
1031: EMPTY
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: PUSH
1040: LD_INT 27
1042: PUSH
1043: LD_INT 28
1045: PUSH
1046: LD_INT 26
1048: PUSH
1049: LD_INT 30
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: PUSH
1058: LD_INT 43
1060: PUSH
1061: LD_INT 44
1063: PUSH
1064: LD_INT 46
1066: PUSH
1067: LD_INT 45
1069: PUSH
1070: LD_INT 47
1072: PUSH
1073: LD_INT 49
1075: PUSH
1076: EMPTY
1077: LIST
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: PUSH
1084: EMPTY
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: LD_VAR 0 11
1093: ARRAY
1094: ST_TO_ADDR
// for i in list do
1095: LD_ADDR_VAR 0 7
1099: PUSH
1100: LD_VAR 0 4
1104: PUSH
1105: FOR_IN
1106: IFFALSE 1139
// if not i in fac_list then
1108: LD_VAR 0 7
1112: PUSH
1113: LD_VAR 0 16
1117: IN
1118: NOT
1119: IFFALSE 1137
// list := list diff i ;
1121: LD_ADDR_VAR 0 4
1125: PUSH
1126: LD_VAR 0 4
1130: PUSH
1131: LD_VAR 0 7
1135: DIFF
1136: ST_TO_ADDR
1137: GO 1105
1139: POP
1140: POP
// if not list then
1141: LD_VAR 0 4
1145: NOT
1146: IFFALSE 1150
// exit ;
1148: GO 2049
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
1150: LD_VAR 0 11
1154: PUSH
1155: LD_INT 3
1157: EQUAL
1158: PUSH
1159: LD_INT 49
1161: PUSH
1162: LD_VAR 0 4
1166: IN
1167: AND
1168: PUSH
1169: LD_INT 31
1171: PPUSH
1172: LD_VAR 0 15
1176: PPUSH
1177: CALL_OW 321
1181: PUSH
1182: LD_INT 2
1184: EQUAL
1185: AND
1186: IFFALSE 1246
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
1188: LD_INT 22
1190: PUSH
1191: LD_VAR 0 15
1195: PUSH
1196: EMPTY
1197: LIST
1198: LIST
1199: PUSH
1200: LD_INT 35
1202: PUSH
1203: LD_INT 49
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: PUSH
1210: LD_INT 91
1212: PUSH
1213: LD_VAR 0 1
1217: PUSH
1218: LD_INT 10
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PPUSH
1231: CALL_OW 69
1235: NOT
1236: IFFALSE 1246
// weapon := ru_time_lapser ;
1238: LD_ADDR_VAR 0 17
1242: PUSH
1243: LD_INT 49
1245: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
1246: LD_VAR 0 11
1250: PUSH
1251: LD_INT 1
1253: PUSH
1254: LD_INT 2
1256: PUSH
1257: EMPTY
1258: LIST
1259: LIST
1260: IN
1261: PUSH
1262: LD_INT 11
1264: PUSH
1265: LD_VAR 0 4
1269: IN
1270: PUSH
1271: LD_INT 30
1273: PUSH
1274: LD_VAR 0 4
1278: IN
1279: OR
1280: AND
1281: PUSH
1282: LD_INT 6
1284: PPUSH
1285: LD_VAR 0 15
1289: PPUSH
1290: CALL_OW 321
1294: PUSH
1295: LD_INT 2
1297: EQUAL
1298: AND
1299: IFFALSE 1464
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
1301: LD_INT 22
1303: PUSH
1304: LD_VAR 0 15
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: PUSH
1313: LD_INT 2
1315: PUSH
1316: LD_INT 35
1318: PUSH
1319: LD_INT 11
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: PUSH
1326: LD_INT 35
1328: PUSH
1329: LD_INT 30
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: PUSH
1341: LD_INT 91
1343: PUSH
1344: LD_VAR 0 1
1348: PUSH
1349: LD_INT 18
1351: PUSH
1352: EMPTY
1353: LIST
1354: LIST
1355: LIST
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: LIST
1361: PPUSH
1362: CALL_OW 69
1366: NOT
1367: PUSH
1368: LD_INT 22
1370: PUSH
1371: LD_VAR 0 15
1375: PUSH
1376: EMPTY
1377: LIST
1378: LIST
1379: PUSH
1380: LD_INT 2
1382: PUSH
1383: LD_INT 30
1385: PUSH
1386: LD_INT 32
1388: PUSH
1389: EMPTY
1390: LIST
1391: LIST
1392: PUSH
1393: LD_INT 30
1395: PUSH
1396: LD_INT 33
1398: PUSH
1399: EMPTY
1400: LIST
1401: LIST
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: LIST
1407: PUSH
1408: LD_INT 91
1410: PUSH
1411: LD_VAR 0 1
1415: PUSH
1416: LD_INT 12
1418: PUSH
1419: EMPTY
1420: LIST
1421: LIST
1422: LIST
1423: PUSH
1424: EMPTY
1425: LIST
1426: LIST
1427: LIST
1428: PUSH
1429: EMPTY
1430: LIST
1431: PPUSH
1432: CALL_OW 69
1436: PUSH
1437: LD_INT 2
1439: GREATER
1440: AND
1441: IFFALSE 1464
// weapon := [ us_radar , ar_radar ] [ nat ] ;
1443: LD_ADDR_VAR 0 17
1447: PUSH
1448: LD_INT 11
1450: PUSH
1451: LD_INT 30
1453: PUSH
1454: EMPTY
1455: LIST
1456: LIST
1457: PUSH
1458: LD_VAR 0 11
1462: ARRAY
1463: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
1464: LD_VAR 0 17
1468: NOT
1469: PUSH
1470: LD_INT 40
1472: PPUSH
1473: LD_VAR 0 15
1477: PPUSH
1478: CALL_OW 321
1482: PUSH
1483: LD_INT 2
1485: EQUAL
1486: AND
1487: PUSH
1488: LD_INT 7
1490: PUSH
1491: LD_VAR 0 4
1495: IN
1496: PUSH
1497: LD_INT 28
1499: PUSH
1500: LD_VAR 0 4
1504: IN
1505: OR
1506: PUSH
1507: LD_INT 45
1509: PUSH
1510: LD_VAR 0 4
1514: IN
1515: OR
1516: AND
1517: IFFALSE 1771
// begin hex := GetHexInfo ( x , y ) ;
1519: LD_ADDR_VAR 0 3
1523: PUSH
1524: LD_VAR 0 9
1528: PPUSH
1529: LD_VAR 0 10
1533: PPUSH
1534: CALL_OW 546
1538: ST_TO_ADDR
// if hex [ 1 ] then
1539: LD_VAR 0 3
1543: PUSH
1544: LD_INT 1
1546: ARRAY
1547: IFFALSE 1551
// exit ;
1549: GO 2049
// height := hex [ 2 ] ;
1551: LD_ADDR_VAR 0 14
1555: PUSH
1556: LD_VAR 0 3
1560: PUSH
1561: LD_INT 2
1563: ARRAY
1564: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
1565: LD_ADDR_VAR 0 13
1569: PUSH
1570: LD_INT 0
1572: PUSH
1573: LD_INT 2
1575: PUSH
1576: LD_INT 3
1578: PUSH
1579: LD_INT 5
1581: PUSH
1582: EMPTY
1583: LIST
1584: LIST
1585: LIST
1586: LIST
1587: ST_TO_ADDR
// for i in tmp do
1588: LD_ADDR_VAR 0 7
1592: PUSH
1593: LD_VAR 0 13
1597: PUSH
1598: FOR_IN
1599: IFFALSE 1769
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
1601: LD_ADDR_VAR 0 8
1605: PUSH
1606: LD_VAR 0 9
1610: PPUSH
1611: LD_VAR 0 7
1615: PPUSH
1616: LD_INT 5
1618: PPUSH
1619: CALL_OW 272
1623: PUSH
1624: LD_VAR 0 10
1628: PPUSH
1629: LD_VAR 0 7
1633: PPUSH
1634: LD_INT 5
1636: PPUSH
1637: CALL_OW 273
1641: PUSH
1642: EMPTY
1643: LIST
1644: LIST
1645: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
1646: LD_VAR 0 8
1650: PUSH
1651: LD_INT 1
1653: ARRAY
1654: PPUSH
1655: LD_VAR 0 8
1659: PUSH
1660: LD_INT 2
1662: ARRAY
1663: PPUSH
1664: CALL_OW 488
1668: IFFALSE 1767
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
1670: LD_ADDR_VAR 0 3
1674: PUSH
1675: LD_VAR 0 8
1679: PUSH
1680: LD_INT 1
1682: ARRAY
1683: PPUSH
1684: LD_VAR 0 8
1688: PUSH
1689: LD_INT 2
1691: ARRAY
1692: PPUSH
1693: CALL_OW 546
1697: ST_TO_ADDR
// if hex [ 1 ] then
1698: LD_VAR 0 3
1702: PUSH
1703: LD_INT 1
1705: ARRAY
1706: IFFALSE 1710
// continue ;
1708: GO 1598
// h := hex [ 2 ] ;
1710: LD_ADDR_VAR 0 12
1714: PUSH
1715: LD_VAR 0 3
1719: PUSH
1720: LD_INT 2
1722: ARRAY
1723: ST_TO_ADDR
// if h + 7 < height then
1724: LD_VAR 0 12
1728: PUSH
1729: LD_INT 7
1731: PLUS
1732: PUSH
1733: LD_VAR 0 14
1737: LESS
1738: IFFALSE 1767
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
1740: LD_ADDR_VAR 0 17
1744: PUSH
1745: LD_INT 7
1747: PUSH
1748: LD_INT 28
1750: PUSH
1751: LD_INT 45
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: LD_VAR 0 11
1763: ARRAY
1764: ST_TO_ADDR
// break ;
1765: GO 1769
// end ; end ; end ;
1767: GO 1598
1769: POP
1770: POP
// end ; if not weapon then
1771: LD_VAR 0 17
1775: NOT
1776: IFFALSE 1931
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
1778: LD_ADDR_VAR 0 4
1782: PUSH
1783: LD_VAR 0 4
1787: PUSH
1788: LD_INT 11
1790: PUSH
1791: LD_INT 30
1793: PUSH
1794: LD_INT 49
1796: PUSH
1797: EMPTY
1798: LIST
1799: LIST
1800: LIST
1801: DIFF
1802: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , tower , 6 ] , [ f_not , [ f_bweapon , 0 ] ] ] ) ;
1803: LD_ADDR_VAR 0 13
1807: PUSH
1808: LD_INT 22
1810: PUSH
1811: LD_VAR 0 15
1815: PUSH
1816: EMPTY
1817: LIST
1818: LIST
1819: PUSH
1820: LD_INT 91
1822: PUSH
1823: LD_VAR 0 1
1827: PUSH
1828: LD_INT 6
1830: PUSH
1831: EMPTY
1832: LIST
1833: LIST
1834: LIST
1835: PUSH
1836: LD_INT 3
1838: PUSH
1839: LD_INT 35
1841: PUSH
1842: LD_INT 0
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: PUSH
1853: EMPTY
1854: LIST
1855: LIST
1856: LIST
1857: PPUSH
1858: CALL_OW 69
1862: ST_TO_ADDR
// for i in tmp do
1863: LD_ADDR_VAR 0 7
1867: PUSH
1868: LD_VAR 0 13
1872: PUSH
1873: FOR_IN
1874: IFFALSE 1899
// list := list diff GetBWeapon ( i ) ;
1876: LD_ADDR_VAR 0 4
1880: PUSH
1881: LD_VAR 0 4
1885: PUSH
1886: LD_VAR 0 7
1890: PPUSH
1891: CALL_OW 269
1895: DIFF
1896: ST_TO_ADDR
1897: GO 1873
1899: POP
1900: POP
// if list then
1901: LD_VAR 0 4
1905: IFFALSE 1931
// weapon := list [ rand ( 1 , list ) ] ;
1907: LD_ADDR_VAR 0 17
1911: PUSH
1912: LD_VAR 0 4
1916: PUSH
1917: LD_INT 1
1919: PPUSH
1920: LD_VAR 0 4
1924: PPUSH
1925: CALL_OW 12
1929: ARRAY
1930: ST_TO_ADDR
// end ; if weapon then
1931: LD_VAR 0 17
1935: IFFALSE 2049
// begin tmp := CostOfWeapon ( weapon ) ;
1937: LD_ADDR_VAR 0 13
1941: PUSH
1942: LD_VAR 0 17
1946: PPUSH
1947: CALL_OW 451
1951: ST_TO_ADDR
// j := GetBase ( tower ) ;
1952: LD_ADDR_VAR 0 8
1956: PUSH
1957: LD_VAR 0 1
1961: PPUSH
1962: CALL_OW 274
1966: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
1967: LD_VAR 0 8
1971: PPUSH
1972: LD_INT 1
1974: PPUSH
1975: CALL_OW 275
1979: PUSH
1980: LD_VAR 0 13
1984: PUSH
1985: LD_INT 1
1987: ARRAY
1988: GREATEREQUAL
1989: PUSH
1990: LD_VAR 0 8
1994: PPUSH
1995: LD_INT 2
1997: PPUSH
1998: CALL_OW 275
2002: PUSH
2003: LD_VAR 0 13
2007: PUSH
2008: LD_INT 2
2010: ARRAY
2011: GREATEREQUAL
2012: AND
2013: PUSH
2014: LD_VAR 0 8
2018: PPUSH
2019: LD_INT 3
2021: PPUSH
2022: CALL_OW 275
2026: PUSH
2027: LD_VAR 0 13
2031: PUSH
2032: LD_INT 3
2034: ARRAY
2035: GREATEREQUAL
2036: AND
2037: IFFALSE 2049
// result := weapon ;
2039: LD_ADDR_VAR 0 2
2043: PUSH
2044: LD_VAR 0 17
2048: ST_TO_ADDR
// end ; end ;
2049: LD_VAR 0 2
2053: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
2054: LD_INT 0
2056: PPUSH
2057: PPUSH
2058: PPUSH
2059: PPUSH
2060: PPUSH
// if not un or not IsOk ( un ) then
2061: LD_VAR 0 1
2065: NOT
2066: PUSH
2067: LD_VAR 0 1
2071: PPUSH
2072: CALL_OW 302
2076: NOT
2077: OR
2078: IFFALSE 2082
// exit ;
2080: GO 2522
// side := GetSide ( un ) ;
2082: LD_ADDR_VAR 0 9
2086: PUSH
2087: LD_VAR 0 1
2091: PPUSH
2092: CALL_OW 255
2096: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
2097: LD_ADDR_VAR 0 7
2101: PUSH
2102: LD_INT 22
2104: PUSH
2105: LD_VAR 0 9
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: PUSH
2114: LD_INT 30
2116: PUSH
2117: LD_INT 32
2119: PUSH
2120: EMPTY
2121: LIST
2122: LIST
2123: PUSH
2124: LD_INT 50
2126: PUSH
2127: EMPTY
2128: LIST
2129: PUSH
2130: LD_INT 58
2132: PUSH
2133: EMPTY
2134: LIST
2135: PUSH
2136: EMPTY
2137: LIST
2138: LIST
2139: LIST
2140: LIST
2141: PPUSH
2142: CALL_OW 69
2146: PUSH
2147: LD_VAR 0 2
2151: DIFF
2152: ST_TO_ADDR
// if not filter then
2153: LD_VAR 0 7
2157: NOT
2158: IFFALSE 2387
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
2160: LD_ADDR_VAR 0 7
2164: PUSH
2165: LD_INT 22
2167: PUSH
2168: LD_VAR 0 9
2172: PUSH
2173: EMPTY
2174: LIST
2175: LIST
2176: PUSH
2177: LD_INT 30
2179: PUSH
2180: LD_INT 5
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: EMPTY
2188: LIST
2189: LIST
2190: PPUSH
2191: CALL_OW 69
2195: ST_TO_ADDR
// if debug then
2196: LD_EXP 1
2200: IFFALSE 2219
// display_strings := [ filter , 1 ] ;
2202: LD_ADDR_OWVAR 47
2206: PUSH
2207: LD_VAR 0 7
2211: PUSH
2212: LD_STRING 1
2214: PUSH
2215: EMPTY
2216: LIST
2217: LIST
2218: ST_TO_ADDR
// if not filter then
2219: LD_VAR 0 7
2223: NOT
2224: IFFALSE 2247
// begin ComMoveXY ( un , x , y ) ;
2226: LD_VAR 0 1
2230: PPUSH
2231: LD_VAR 0 3
2235: PPUSH
2236: LD_VAR 0 4
2240: PPUSH
2241: CALL_OW 111
// exit ;
2245: GO 2522
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
2247: LD_ADDR_VAR 0 8
2251: PUSH
2252: LD_VAR 0 7
2256: PPUSH
2257: LD_VAR 0 1
2261: PPUSH
2262: CALL_OW 74
2266: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
2267: LD_VAR 0 8
2271: PPUSH
2272: CALL_OW 313
2276: PUSH
2277: LD_INT 6
2279: EQUAL
2280: IFFALSE 2300
// filter := filter diff t else
2282: LD_ADDR_VAR 0 7
2286: PUSH
2287: LD_VAR 0 7
2291: PUSH
2292: LD_VAR 0 8
2296: DIFF
2297: ST_TO_ADDR
2298: GO 2302
// break ;
2300: GO 2324
// until UnitsInside ( t ) < 6 or not filter ;
2302: LD_VAR 0 8
2306: PPUSH
2307: CALL_OW 313
2311: PUSH
2312: LD_INT 6
2314: LESS
2315: PUSH
2316: LD_VAR 0 7
2320: NOT
2321: OR
2322: IFFALSE 2247
// display_strings := [ filter , t ] ;
2324: LD_ADDR_OWVAR 47
2328: PUSH
2329: LD_VAR 0 7
2333: PUSH
2334: LD_VAR 0 8
2338: PUSH
2339: EMPTY
2340: LIST
2341: LIST
2342: ST_TO_ADDR
// if not filter then
2343: LD_VAR 0 7
2347: NOT
2348: IFFALSE 2371
// ComMoveXY ( un , x , y ) else
2350: LD_VAR 0 1
2354: PPUSH
2355: LD_VAR 0 3
2359: PPUSH
2360: LD_VAR 0 4
2364: PPUSH
2365: CALL_OW 111
2369: GO 2385
// ComEnterUnit ( un , t ) ;
2371: LD_VAR 0 1
2375: PPUSH
2376: LD_VAR 0 8
2380: PPUSH
2381: CALL_OW 120
// end else
2385: GO 2522
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
2387: LD_ADDR_VAR 0 8
2391: PUSH
2392: LD_VAR 0 7
2396: PPUSH
2397: LD_VAR 0 1
2401: PPUSH
2402: CALL_OW 74
2406: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
2407: LD_VAR 0 8
2411: PPUSH
2412: CALL_OW 110
2416: PUSH
2417: LD_INT 7
2419: EQUAL
2420: IFFALSE 2438
// filter := filter diff t ;
2422: LD_ADDR_VAR 0 7
2426: PUSH
2427: LD_VAR 0 7
2431: PUSH
2432: LD_VAR 0 8
2436: DIFF
2437: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
2438: LD_VAR 0 8
2442: PPUSH
2443: CALL_OW 110
2447: PUSH
2448: LD_INT 7
2450: NONEQUAL
2451: PUSH
2452: LD_VAR 0 7
2456: NOT
2457: OR
2458: IFFALSE 2387
// if GetTag ( t ) <> 7 then
2460: LD_VAR 0 8
2464: PPUSH
2465: CALL_OW 110
2469: PUSH
2470: LD_INT 7
2472: NONEQUAL
2473: IFFALSE 2503
// begin SetTag ( t , 7 ) ;
2475: LD_VAR 0 8
2479: PPUSH
2480: LD_INT 7
2482: PPUSH
2483: CALL_OW 109
// ComEnterUnit ( un , t ) ;
2487: LD_VAR 0 1
2491: PPUSH
2492: LD_VAR 0 8
2496: PPUSH
2497: CALL_OW 120
// end else
2501: GO 2522
// ComMoveXY ( un , x , y ) ;
2503: LD_VAR 0 1
2507: PPUSH
2508: LD_VAR 0 3
2512: PPUSH
2513: LD_VAR 0 4
2517: PPUSH
2518: CALL_OW 111
// end ; end ;
2522: LD_VAR 0 5
2526: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
2527: LD_INT 0
2529: PPUSH
2530: PPUSH
2531: PPUSH
// if not base then
2532: LD_VAR 0 1
2536: NOT
2537: IFFALSE 2541
// exit ;
2539: GO 2599
// tmp := GetEnergy ( GetBase ( base ) ) ;
2541: LD_ADDR_VAR 0 4
2545: PUSH
2546: LD_VAR 0 1
2550: PPUSH
2551: CALL_OW 274
2555: PPUSH
2556: CALL_OW 278
2560: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
2561: LD_VAR 0 4
2565: PUSH
2566: LD_INT 1
2568: ARRAY
2569: PUSH
2570: LD_VAR 0 4
2574: PUSH
2575: LD_INT 4
2577: ARRAY
2578: GREATER
2579: IFFALSE 2591
// result := true else
2581: LD_ADDR_VAR 0 2
2585: PUSH
2586: LD_INT 1
2588: ST_TO_ADDR
2589: GO 2599
// result := false ;
2591: LD_ADDR_VAR 0 2
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// end ;
2599: LD_VAR 0 2
2603: RET
// export function FilterPeople ( side ) ; begin
2604: LD_INT 0
2606: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
2607: LD_ADDR_VAR 0 2
2611: PUSH
2612: LD_INT 22
2614: PUSH
2615: LD_VAR 0 1
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: PUSH
2624: LD_INT 21
2626: PUSH
2627: LD_INT 1
2629: PUSH
2630: EMPTY
2631: LIST
2632: LIST
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PPUSH
2638: CALL_OW 69
2642: ST_TO_ADDR
// end ;
2643: LD_VAR 0 2
2647: RET
// export function FilterDrivers ( side ) ; begin
2648: LD_INT 0
2650: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
2651: LD_ADDR_VAR 0 2
2655: PUSH
2656: LD_INT 22
2658: PUSH
2659: LD_VAR 0 1
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: PUSH
2668: LD_INT 3
2670: PUSH
2671: LD_INT 56
2673: PUSH
2674: EMPTY
2675: LIST
2676: PUSH
2677: EMPTY
2678: LIST
2679: LIST
2680: PUSH
2681: EMPTY
2682: LIST
2683: LIST
2684: PPUSH
2685: CALL_OW 69
2689: ST_TO_ADDR
// end ;
2690: LD_VAR 0 2
2694: RET
// export function FilterPeopleArea ( side , area ) ; begin
2695: LD_INT 0
2697: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
2698: LD_ADDR_VAR 0 3
2702: PUSH
2703: LD_VAR 0 2
2707: PPUSH
2708: LD_INT 22
2710: PUSH
2711: LD_INT 1
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: PUSH
2718: LD_INT 21
2720: PUSH
2721: LD_INT 1
2723: PUSH
2724: EMPTY
2725: LIST
2726: LIST
2727: PUSH
2728: EMPTY
2729: LIST
2730: LIST
2731: PPUSH
2732: CALL_OW 70
2736: ST_TO_ADDR
// end ;
2737: LD_VAR 0 3
2741: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
2742: LD_INT 0
2744: PPUSH
2745: PPUSH
2746: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
2747: LD_ADDR_VAR 0 5
2751: PUSH
2752: LD_VAR 0 2
2756: PPUSH
2757: LD_INT 22
2759: PUSH
2760: LD_INT 1
2762: PUSH
2763: EMPTY
2764: LIST
2765: LIST
2766: PUSH
2767: LD_INT 21
2769: PUSH
2770: LD_INT 2
2772: PUSH
2773: EMPTY
2774: LIST
2775: LIST
2776: PUSH
2777: LD_INT 3
2779: PUSH
2780: LD_INT 58
2782: PUSH
2783: EMPTY
2784: LIST
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: LIST
2794: PPUSH
2795: CALL_OW 70
2799: ST_TO_ADDR
// result := [ ] ;
2800: LD_ADDR_VAR 0 3
2804: PUSH
2805: EMPTY
2806: ST_TO_ADDR
// if not tmp then
2807: LD_VAR 0 5
2811: NOT
2812: IFFALSE 2816
// exit ;
2814: GO 2868
// for i in tmp do
2816: LD_ADDR_VAR 0 4
2820: PUSH
2821: LD_VAR 0 5
2825: PUSH
2826: FOR_IN
2827: IFFALSE 2852
// result := result ^ IsDrivenBy ( i ) ;
2829: LD_ADDR_VAR 0 3
2833: PUSH
2834: LD_VAR 0 3
2838: PUSH
2839: LD_VAR 0 4
2843: PPUSH
2844: CALL_OW 311
2848: ADD
2849: ST_TO_ADDR
2850: GO 2826
2852: POP
2853: POP
// result := result diff 0 ;
2854: LD_ADDR_VAR 0 3
2858: PUSH
2859: LD_VAR 0 3
2863: PUSH
2864: LD_INT 0
2866: DIFF
2867: ST_TO_ADDR
// end ;
2868: LD_VAR 0 3
2872: RET
// export function FilterBuildings ( side ) ; begin
2873: LD_INT 0
2875: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
2876: LD_ADDR_VAR 0 2
2880: PUSH
2881: LD_INT 22
2883: PUSH
2884: LD_VAR 0 1
2888: PUSH
2889: EMPTY
2890: LIST
2891: LIST
2892: PUSH
2893: LD_INT 21
2895: PUSH
2896: LD_INT 3
2898: PUSH
2899: EMPTY
2900: LIST
2901: LIST
2902: PUSH
2903: EMPTY
2904: LIST
2905: LIST
2906: PPUSH
2907: CALL_OW 69
2911: ST_TO_ADDR
// end ;
2912: LD_VAR 0 2
2916: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
2917: LD_INT 0
2919: PPUSH
2920: PPUSH
2921: PPUSH
2922: PPUSH
// uc_side = 0 ;
2923: LD_ADDR_OWVAR 20
2927: PUSH
2928: LD_INT 0
2930: ST_TO_ADDR
// uc_nation = 0 ;
2931: LD_ADDR_OWVAR 21
2935: PUSH
2936: LD_INT 0
2938: ST_TO_ADDR
// nat_area := wildArea ;
2939: LD_ADDR_VAR 0 4
2943: PUSH
2944: LD_INT 3
2946: ST_TO_ADDR
// InitHc ;
2947: CALL_OW 19
// for i = 1 to 4 do
2951: LD_ADDR_VAR 0 2
2955: PUSH
2956: DOUBLE
2957: LD_INT 1
2959: DEC
2960: ST_TO_ADDR
2961: LD_INT 4
2963: PUSH
2964: FOR_TO
2965: IFFALSE 3020
// begin hc_class = 18 ;
2967: LD_ADDR_OWVAR 28
2971: PUSH
2972: LD_INT 18
2974: ST_TO_ADDR
// hc_gallery =  ;
2975: LD_ADDR_OWVAR 33
2979: PUSH
2980: LD_STRING 
2982: ST_TO_ADDR
// hc_face_number = 1 ;
2983: LD_ADDR_OWVAR 34
2987: PUSH
2988: LD_INT 1
2990: ST_TO_ADDR
// animal := CreateHuman ;
2991: LD_ADDR_VAR 0 3
2995: PUSH
2996: CALL_OW 44
3000: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3001: LD_VAR 0 3
3005: PPUSH
3006: LD_VAR 0 4
3010: PPUSH
3011: LD_INT 0
3013: PPUSH
3014: CALL_OW 49
// end ;
3018: GO 2964
3020: POP
3021: POP
// for i = 1 to 6 do
3022: LD_ADDR_VAR 0 2
3026: PUSH
3027: DOUBLE
3028: LD_INT 1
3030: DEC
3031: ST_TO_ADDR
3032: LD_INT 6
3034: PUSH
3035: FOR_TO
3036: IFFALSE 3107
// begin hc_class = class_tiger ;
3038: LD_ADDR_OWVAR 28
3042: PUSH
3043: LD_INT 14
3045: ST_TO_ADDR
// hc_gallery =  ;
3046: LD_ADDR_OWVAR 33
3050: PUSH
3051: LD_STRING 
3053: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 10 ) ;
3054: LD_ADDR_OWVAR 35
3058: PUSH
3059: LD_INT 0
3061: PPUSH
3062: LD_INT 10
3064: PPUSH
3065: CALL_OW 12
3069: ST_TO_ADDR
// hc_face_number = 3 ;
3070: LD_ADDR_OWVAR 34
3074: PUSH
3075: LD_INT 3
3077: ST_TO_ADDR
// animal := CreateHuman ;
3078: LD_ADDR_VAR 0 3
3082: PUSH
3083: CALL_OW 44
3087: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3088: LD_VAR 0 3
3092: PPUSH
3093: LD_VAR 0 4
3097: PPUSH
3098: LD_INT 0
3100: PPUSH
3101: CALL_OW 49
// end ;
3105: GO 3035
3107: POP
3108: POP
// for i = 1 to 2 do
3109: LD_ADDR_VAR 0 2
3113: PUSH
3114: DOUBLE
3115: LD_INT 1
3117: DEC
3118: ST_TO_ADDR
3119: LD_INT 2
3121: PUSH
3122: FOR_TO
3123: IFFALSE 3186
// begin hc_class = 21 ;
3125: LD_ADDR_OWVAR 28
3129: PUSH
3130: LD_INT 21
3132: ST_TO_ADDR
// hc_gallery =  ;
3133: LD_ADDR_OWVAR 33
3137: PUSH
3138: LD_STRING 
3140: ST_TO_ADDR
// hc_agressivity = 0 ;
3141: LD_ADDR_OWVAR 35
3145: PUSH
3146: LD_INT 0
3148: ST_TO_ADDR
// hc_face_number = 5 ;
3149: LD_ADDR_OWVAR 34
3153: PUSH
3154: LD_INT 5
3156: ST_TO_ADDR
// animal := CreateHuman ;
3157: LD_ADDR_VAR 0 3
3161: PUSH
3162: CALL_OW 44
3166: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3167: LD_VAR 0 3
3171: PPUSH
3172: LD_VAR 0 4
3176: PPUSH
3177: LD_INT 0
3179: PPUSH
3180: CALL_OW 49
// end ;
3184: GO 3122
3186: POP
3187: POP
// for i = 1 to 6 do
3188: LD_ADDR_VAR 0 2
3192: PUSH
3193: DOUBLE
3194: LD_INT 1
3196: DEC
3197: ST_TO_ADDR
3198: LD_INT 6
3200: PUSH
3201: FOR_TO
3202: IFFALSE 3257
// begin hc_class = 13 ;
3204: LD_ADDR_OWVAR 28
3208: PUSH
3209: LD_INT 13
3211: ST_TO_ADDR
// hc_gallery =  ;
3212: LD_ADDR_OWVAR 33
3216: PUSH
3217: LD_STRING 
3219: ST_TO_ADDR
// hc_face_number = 4 ;
3220: LD_ADDR_OWVAR 34
3224: PUSH
3225: LD_INT 4
3227: ST_TO_ADDR
// animal := CreateHuman ;
3228: LD_ADDR_VAR 0 3
3232: PUSH
3233: CALL_OW 44
3237: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3238: LD_VAR 0 3
3242: PPUSH
3243: LD_VAR 0 4
3247: PPUSH
3248: LD_INT 0
3250: PPUSH
3251: CALL_OW 49
// end ;
3255: GO 3201
3257: POP
3258: POP
// for i = 1 to 2 do
3259: LD_ADDR_VAR 0 2
3263: PUSH
3264: DOUBLE
3265: LD_INT 1
3267: DEC
3268: ST_TO_ADDR
3269: LD_INT 2
3271: PUSH
3272: FOR_TO
3273: IFFALSE 3332
// begin hc_class = 20 ;
3275: LD_ADDR_OWVAR 28
3279: PUSH
3280: LD_INT 20
3282: ST_TO_ADDR
// hc_gallery =  ;
3283: LD_ADDR_OWVAR 33
3287: PUSH
3288: LD_STRING 
3290: ST_TO_ADDR
// hc_face_number = 2 ;
3291: LD_ADDR_OWVAR 34
3295: PUSH
3296: LD_INT 2
3298: ST_TO_ADDR
// animal := CreateHuman ;
3299: LD_ADDR_VAR 0 3
3303: PUSH
3304: CALL_OW 44
3308: ST_TO_ADDR
// PlaceUnitXYR ( animal , 101 , 37 , 3 , false ) ;
3309: LD_VAR 0 3
3313: PPUSH
3314: LD_INT 101
3316: PPUSH
3317: LD_INT 37
3319: PPUSH
3320: LD_INT 3
3322: PPUSH
3323: LD_INT 0
3325: PPUSH
3326: CALL_OW 50
// end ;
3330: GO 3272
3332: POP
3333: POP
// for i = 1 to 1 do
3334: LD_ADDR_VAR 0 2
3338: PUSH
3339: DOUBLE
3340: LD_INT 1
3342: DEC
3343: ST_TO_ADDR
3344: LD_INT 1
3346: PUSH
3347: FOR_TO
3348: IFFALSE 3395
// begin vc_chassis := 31 ;
3350: LD_ADDR_OWVAR 37
3354: PUSH
3355: LD_INT 31
3357: ST_TO_ADDR
// vc_control := control_rider ;
3358: LD_ADDR_OWVAR 38
3362: PUSH
3363: LD_INT 4
3365: ST_TO_ADDR
// animal := CreateVehicle ;
3366: LD_ADDR_VAR 0 3
3370: PUSH
3371: CALL_OW 45
3375: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3376: LD_VAR 0 3
3380: PPUSH
3381: LD_VAR 0 4
3385: PPUSH
3386: LD_INT 0
3388: PPUSH
3389: CALL_OW 49
// end ;
3393: GO 3347
3395: POP
3396: POP
// end ; end_of_file
3397: LD_VAR 0 1
3401: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
3402: LD_INT 0
3404: PPUSH
3405: PPUSH
3406: PPUSH
3407: PPUSH
3408: PPUSH
3409: PPUSH
// uc_side := 1 ;
3410: LD_ADDR_OWVAR 20
3414: PUSH
3415: LD_INT 1
3417: ST_TO_ADDR
// uc_nation := 1 ;
3418: LD_ADDR_OWVAR 21
3422: PUSH
3423: LD_INT 1
3425: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
3426: LD_ADDR_EXP 8
3430: PUSH
3431: LD_STRING JMM
3433: PPUSH
3434: LD_EXP 1
3438: NOT
3439: PPUSH
3440: CALL 354 0 2
3444: ST_TO_ADDR
// team := [ JMM ] ;
3445: LD_ADDR_VAR 0 3
3449: PUSH
3450: LD_EXP 8
3454: PUSH
3455: EMPTY
3456: LIST
3457: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
3458: LD_STRING BrownIn07
3460: PPUSH
3461: LD_EXP 1
3465: PPUSH
3466: CALL_OW 30
3470: IFFALSE 3491
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
3472: LD_ADDR_EXP 9
3476: PUSH
3477: LD_STRING Brown
3479: PPUSH
3480: LD_EXP 1
3484: NOT
3485: PPUSH
3486: CALL 354 0 2
3490: ST_TO_ADDR
// if Brown then
3491: LD_EXP 9
3495: IFFALSE 3513
// team := team ^ Brown ;
3497: LD_ADDR_VAR 0 3
3501: PUSH
3502: LD_VAR 0 3
3506: PUSH
3507: LD_EXP 9
3511: ADD
3512: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
3513: LD_STRING DonaldsonIn07
3515: PPUSH
3516: LD_EXP 1
3520: PPUSH
3521: CALL_OW 30
3525: IFFALSE 3546
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
3527: LD_ADDR_EXP 10
3531: PUSH
3532: LD_STRING Donaldson
3534: PPUSH
3535: LD_EXP 1
3539: NOT
3540: PPUSH
3541: CALL 354 0 2
3545: ST_TO_ADDR
// if Donaldson then
3546: LD_EXP 10
3550: IFFALSE 3568
// team := team ^ Donaldson ;
3552: LD_ADDR_VAR 0 3
3556: PUSH
3557: LD_VAR 0 3
3561: PUSH
3562: LD_EXP 10
3566: ADD
3567: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
3568: LD_STRING BobbyIn07
3570: PPUSH
3571: LD_EXP 1
3575: PPUSH
3576: CALL_OW 30
3580: IFFALSE 3601
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
3582: LD_ADDR_EXP 11
3586: PUSH
3587: LD_STRING Bobby
3589: PPUSH
3590: LD_EXP 1
3594: NOT
3595: PPUSH
3596: CALL 354 0 2
3600: ST_TO_ADDR
// if Bobby then
3601: LD_EXP 11
3605: IFFALSE 3623
// team := team ^ Bobby ;
3607: LD_ADDR_VAR 0 3
3611: PUSH
3612: LD_VAR 0 3
3616: PUSH
3617: LD_EXP 11
3621: ADD
3622: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
3623: LD_STRING CyrusIn07
3625: PPUSH
3626: LD_EXP 1
3630: PPUSH
3631: CALL_OW 30
3635: IFFALSE 3656
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
3637: LD_ADDR_EXP 12
3641: PUSH
3642: LD_STRING Cyrus
3644: PPUSH
3645: LD_EXP 1
3649: NOT
3650: PPUSH
3651: CALL 354 0 2
3655: ST_TO_ADDR
// if Cyrus then
3656: LD_EXP 12
3660: IFFALSE 3678
// team := team ^ Cyrus ;
3662: LD_ADDR_VAR 0 3
3666: PUSH
3667: LD_VAR 0 3
3671: PUSH
3672: LD_EXP 12
3676: ADD
3677: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
3678: LD_STRING LisaIn07
3680: PPUSH
3681: LD_EXP 1
3685: PPUSH
3686: CALL_OW 30
3690: IFFALSE 3711
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
3692: LD_ADDR_EXP 13
3696: PUSH
3697: LD_STRING Lisa
3699: PPUSH
3700: LD_EXP 1
3704: NOT
3705: PPUSH
3706: CALL 354 0 2
3710: ST_TO_ADDR
// if Lisa then
3711: LD_EXP 13
3715: IFFALSE 3733
// team := team ^ Lisa ;
3717: LD_ADDR_VAR 0 3
3721: PUSH
3722: LD_VAR 0 3
3726: PUSH
3727: LD_EXP 13
3731: ADD
3732: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
3733: LD_STRING GladstoneIn07
3735: PPUSH
3736: LD_EXP 1
3740: PPUSH
3741: CALL_OW 30
3745: IFFALSE 3766
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
3747: LD_ADDR_EXP 15
3751: PUSH
3752: LD_STRING Gladstone
3754: PPUSH
3755: LD_EXP 1
3759: NOT
3760: PPUSH
3761: CALL 354 0 2
3765: ST_TO_ADDR
// if Gladstone then
3766: LD_EXP 15
3770: IFFALSE 3788
// team := team ^ Gladstone ;
3772: LD_ADDR_VAR 0 3
3776: PUSH
3777: LD_VAR 0 3
3781: PUSH
3782: LD_EXP 15
3786: ADD
3787: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
3788: LD_STRING KhatamIn07
3790: PPUSH
3791: LD_EXP 1
3795: PPUSH
3796: CALL_OW 30
3800: IFFALSE 3821
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
3802: LD_ADDR_EXP 16
3806: PUSH
3807: LD_STRING Khatam
3809: PPUSH
3810: LD_EXP 1
3814: NOT
3815: PPUSH
3816: CALL 354 0 2
3820: ST_TO_ADDR
// if Khatam then
3821: LD_EXP 16
3825: IFFALSE 3843
// team := team ^ Khatam ;
3827: LD_ADDR_VAR 0 3
3831: PUSH
3832: LD_VAR 0 3
3836: PUSH
3837: LD_EXP 16
3841: ADD
3842: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
3843: LD_ADDR_VAR 0 4
3847: PUSH
3848: LD_STRING 07_others
3850: PPUSH
3851: CALL_OW 31
3855: ST_TO_ADDR
// if others then
3856: LD_VAR 0 4
3860: IFFALSE 3878
// team := team ^ others ;
3862: LD_ADDR_VAR 0 3
3866: PUSH
3867: LD_VAR 0 3
3871: PUSH
3872: LD_VAR 0 4
3876: ADD
3877: ST_TO_ADDR
// if debug then
3878: LD_EXP 1
3882: IFFALSE 3956
// begin InitHc ;
3884: CALL_OW 19
// for i = 1 to 4 do
3888: LD_ADDR_VAR 0 2
3892: PUSH
3893: DOUBLE
3894: LD_INT 1
3896: DEC
3897: ST_TO_ADDR
3898: LD_INT 4
3900: PUSH
3901: FOR_TO
3902: IFFALSE 3954
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
3904: LD_INT 0
3906: PPUSH
3907: LD_INT 1
3909: PUSH
3910: LD_INT 3
3912: PUSH
3913: EMPTY
3914: LIST
3915: LIST
3916: PUSH
3917: LD_INT 1
3919: PPUSH
3920: LD_INT 2
3922: PPUSH
3923: CALL_OW 12
3927: ARRAY
3928: PPUSH
3929: LD_INT 4
3931: PPUSH
3932: CALL_OW 380
// team := team ^ CreateHuman ;
3936: LD_ADDR_VAR 0 3
3940: PUSH
3941: LD_VAR 0 3
3945: PUSH
3946: CALL_OW 44
3950: ADD
3951: ST_TO_ADDR
// end ;
3952: GO 3901
3954: POP
3955: POP
// end ; m := 0 ;
3956: LD_ADDR_VAR 0 6
3960: PUSH
3961: LD_INT 0
3963: ST_TO_ADDR
// for i in team do
3964: LD_ADDR_VAR 0 2
3968: PUSH
3969: LD_VAR 0 3
3973: PUSH
3974: FOR_IN
3975: IFFALSE 4155
// if GetClass ( i ) = 3 then
3977: LD_VAR 0 2
3981: PPUSH
3982: CALL_OW 257
3986: PUSH
3987: LD_INT 3
3989: EQUAL
3990: IFFALSE 4138
// begin m := m + 1 ;
3992: LD_ADDR_VAR 0 6
3996: PUSH
3997: LD_VAR 0 6
4001: PUSH
4002: LD_INT 1
4004: PLUS
4005: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
4006: LD_ADDR_VAR 0 5
4010: PUSH
4011: LD_INT 1
4013: PPUSH
4014: LD_INT 1
4016: PPUSH
4017: LD_INT 2
4019: PUSH
4020: LD_INT 3
4022: PUSH
4023: LD_INT 2
4025: PUSH
4026: LD_INT 1
4028: PUSH
4029: EMPTY
4030: LIST
4031: LIST
4032: LIST
4033: LIST
4034: PUSH
4035: LD_VAR 0 6
4039: PUSH
4040: LD_INT 4
4042: MOD
4043: PUSH
4044: LD_INT 1
4046: PLUS
4047: ARRAY
4048: PPUSH
4049: LD_INT 2
4051: PPUSH
4052: LD_INT 1
4054: PPUSH
4055: LD_INT 4
4057: PUSH
4058: LD_INT 5
4060: PUSH
4061: LD_INT 3
4063: PUSH
4064: LD_INT 11
4066: PUSH
4067: EMPTY
4068: LIST
4069: LIST
4070: LIST
4071: LIST
4072: PUSH
4073: LD_VAR 0 6
4077: PUSH
4078: LD_INT 4
4080: MOD
4081: PUSH
4082: LD_INT 1
4084: PLUS
4085: ARRAY
4086: PPUSH
4087: LD_INT 60
4089: PPUSH
4090: CALL 417 0 7
4094: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
4095: LD_VAR 0 5
4099: PPUSH
4100: LD_INT 2
4102: PPUSH
4103: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
4107: LD_VAR 0 5
4111: PPUSH
4112: LD_INT 1
4114: PPUSH
4115: LD_INT 0
4117: PPUSH
4118: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4122: LD_VAR 0 2
4126: PPUSH
4127: LD_VAR 0 5
4131: PPUSH
4132: CALL_OW 52
// end else
4136: GO 4153
// PlaceUnitArea ( i , startArea , false ) ;
4138: LD_VAR 0 2
4142: PPUSH
4143: LD_INT 1
4145: PPUSH
4146: LD_INT 0
4148: PPUSH
4149: CALL_OW 49
4153: GO 3974
4155: POP
4156: POP
// uc_side := 4 ;
4157: LD_ADDR_OWVAR 20
4161: PUSH
4162: LD_INT 4
4164: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
4165: LD_ADDR_EXP 18
4169: PUSH
4170: LD_STRING Harisson
4172: PPUSH
4173: LD_INT 0
4175: PPUSH
4176: CALL 354 0 2
4180: ST_TO_ADDR
// PrepareScout ;
4181: CALL 4190 0 0
// end ;
4185: LD_VAR 0 1
4189: RET
// function PrepareScout ; var ape ; begin
4190: LD_INT 0
4192: PPUSH
4193: PPUSH
// uc_side := 4 ;
4194: LD_ADDR_OWVAR 20
4198: PUSH
4199: LD_INT 4
4201: ST_TO_ADDR
// uc_nation := 1 ;
4202: LD_ADDR_OWVAR 21
4206: PUSH
4207: LD_INT 1
4209: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
4210: LD_STRING FrankIn06
4212: PPUSH
4213: LD_INT 0
4215: PPUSH
4216: CALL_OW 30
4220: IFFALSE 4237
// Frank := CreateCharacter ( 06c_Frank ) else
4222: LD_ADDR_EXP 14
4226: PUSH
4227: LD_STRING 06c_Frank
4229: PPUSH
4230: CALL_OW 34
4234: ST_TO_ADDR
4235: GO 4277
// if LoadVariable ( FrankInDelta , 0 ) then
4237: LD_STRING FrankInDelta
4239: PPUSH
4240: LD_INT 0
4242: PPUSH
4243: CALL_OW 30
4247: IFFALSE 4264
// Frank := CreateCharacter ( 05_Frank ) else
4249: LD_ADDR_EXP 14
4253: PUSH
4254: LD_STRING 05_Frank
4256: PPUSH
4257: CALL_OW 34
4261: ST_TO_ADDR
4262: GO 4277
// Frank := CreateCharacter ( 04_Frank ) ;
4264: LD_ADDR_EXP 14
4268: PUSH
4269: LD_STRING 04_Frank
4271: PPUSH
4272: CALL_OW 34
4276: ST_TO_ADDR
// if Frank then
4277: LD_EXP 14
4281: IFFALSE 4414
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
4283: LD_EXP 14
4287: PPUSH
4288: LD_INT 2
4290: PPUSH
4291: LD_INT 0
4293: PPUSH
4294: CALL_OW 49
// SetClass ( Frank , 1 ) ;
4298: LD_EXP 14
4302: PPUSH
4303: LD_INT 1
4305: PPUSH
4306: CALL_OW 336
// uc_side := 0 ;
4310: LD_ADDR_OWVAR 20
4314: PUSH
4315: LD_INT 0
4317: ST_TO_ADDR
// uc_nation := 0 ;
4318: LD_ADDR_OWVAR 21
4322: PUSH
4323: LD_INT 0
4325: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
4326: LD_INT 0
4328: PPUSH
4329: LD_INT 12
4331: PPUSH
4332: LD_INT 0
4334: PPUSH
4335: CALL_OW 380
// ape := CreateHuman ;
4339: LD_ADDR_VAR 0 2
4343: PUSH
4344: CALL_OW 44
4348: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
4349: LD_VAR 0 2
4353: PPUSH
4354: LD_EXP 14
4358: PPUSH
4359: CALL_OW 250
4363: PPUSH
4364: LD_EXP 14
4368: PPUSH
4369: CALL_OW 251
4373: PPUSH
4374: LD_INT 5
4376: PPUSH
4377: LD_INT 0
4379: PPUSH
4380: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
4384: LD_VAR 0 2
4388: PPUSH
4389: LD_EXP 14
4393: PPUSH
4394: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
4398: LD_EXP 14
4402: PPUSH
4403: LD_VAR 0 2
4407: PPUSH
4408: CALL_OW 119
// exit ;
4412: GO 4454
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
4414: LD_ADDR_EXP 17
4418: PUSH
4419: LD_STRING Yamoko
4421: PPUSH
4422: LD_INT 0
4424: PPUSH
4425: CALL 354 0 2
4429: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
4430: LD_EXP 17
4434: PPUSH
4435: LD_INT 2
4437: PPUSH
4438: LD_INT 0
4440: PPUSH
4441: CALL_OW 49
// ComHold ( Kikuchi ) ;
4445: LD_EXP 17
4449: PPUSH
4450: CALL_OW 140
// end ; end_of_file
4454: LD_VAR 0 1
4458: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
4459: LD_INT 0
4461: PPUSH
4462: PPUSH
4463: PPUSH
4464: PPUSH
4465: PPUSH
4466: PPUSH
4467: PPUSH
4468: PPUSH
4469: PPUSH
4470: PPUSH
4471: PPUSH
4472: PPUSH
4473: PPUSH
4474: PPUSH
4475: PPUSH
4476: PPUSH
// ru_rebuild_list := [ ] ;
4477: LD_ADDR_EXP 19
4481: PUSH
4482: EMPTY
4483: ST_TO_ADDR
// uc_side := 3 ;
4484: LD_ADDR_OWVAR 20
4488: PUSH
4489: LD_INT 3
4491: ST_TO_ADDR
// uc_nation := 3 ;
4492: LD_ADDR_OWVAR 21
4496: PUSH
4497: LD_INT 3
4499: ST_TO_ADDR
// if Difficulty > 1 then
4500: LD_OWVAR 67
4504: PUSH
4505: LD_INT 1
4507: GREATER
4508: IFFALSE 4644
// begin bc_type := b_breastwork ;
4510: LD_ADDR_OWVAR 42
4514: PUSH
4515: LD_INT 31
4517: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
4518: LD_INT 78
4520: PPUSH
4521: LD_INT 74
4523: PPUSH
4524: LD_INT 2
4526: PPUSH
4527: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
4531: LD_INT 171
4533: PPUSH
4534: LD_INT 193
4536: PPUSH
4537: LD_INT 4
4539: PPUSH
4540: CALL_OW 47
// bc_type := b_turret ;
4544: LD_ADDR_OWVAR 42
4548: PUSH
4549: LD_INT 33
4551: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
4552: LD_INT 129
4554: PPUSH
4555: LD_INT 96
4557: PPUSH
4558: LD_INT 3
4560: PPUSH
4561: CALL_OW 47
// if Difficulty > 2 then
4565: LD_OWVAR 67
4569: PUSH
4570: LD_INT 2
4572: GREATER
4573: IFFALSE 4644
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
4575: LD_INT 83
4577: PPUSH
4578: LD_INT 141
4580: PPUSH
4581: CALL_OW 428
4585: PPUSH
4586: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
4590: LD_INT 78
4592: PPUSH
4593: LD_INT 133
4595: PPUSH
4596: CALL_OW 428
4600: PPUSH
4601: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
4605: LD_INT 83
4607: PPUSH
4608: LD_INT 141
4610: PPUSH
4611: LD_INT 2
4613: PPUSH
4614: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
4618: LD_INT 78
4620: PPUSH
4621: LD_INT 133
4623: PPUSH
4624: LD_INT 2
4626: PPUSH
4627: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
4631: LD_INT 145
4633: PPUSH
4634: LD_INT 112
4636: PPUSH
4637: LD_INT 3
4639: PPUSH
4640: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
4644: LD_ADDR_VAR 0 9
4648: PUSH
4649: LD_INT 22
4651: PUSH
4652: LD_INT 3
4654: PUSH
4655: EMPTY
4656: LIST
4657: LIST
4658: PUSH
4659: LD_INT 2
4661: PUSH
4662: LD_INT 30
4664: PUSH
4665: LD_INT 0
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: PUSH
4672: LD_INT 30
4674: PUSH
4675: LD_INT 1
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: LIST
4686: PUSH
4687: EMPTY
4688: LIST
4689: LIST
4690: PPUSH
4691: CALL_OW 69
4695: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
4696: LD_ADDR_VAR 0 10
4700: PUSH
4701: LD_INT 22
4703: PUSH
4704: LD_INT 3
4706: PUSH
4707: EMPTY
4708: LIST
4709: LIST
4710: PUSH
4711: LD_INT 2
4713: PUSH
4714: LD_INT 30
4716: PUSH
4717: LD_INT 6
4719: PUSH
4720: EMPTY
4721: LIST
4722: LIST
4723: PUSH
4724: LD_INT 30
4726: PUSH
4727: LD_INT 7
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PUSH
4734: LD_INT 30
4736: PUSH
4737: LD_INT 8
4739: PUSH
4740: EMPTY
4741: LIST
4742: LIST
4743: PUSH
4744: EMPTY
4745: LIST
4746: LIST
4747: LIST
4748: LIST
4749: PUSH
4750: EMPTY
4751: LIST
4752: LIST
4753: PPUSH
4754: CALL_OW 69
4758: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4759: LD_ADDR_VAR 0 11
4763: PUSH
4764: LD_INT 22
4766: PUSH
4767: LD_INT 3
4769: PUSH
4770: EMPTY
4771: LIST
4772: LIST
4773: PUSH
4774: LD_INT 30
4776: PUSH
4777: LD_INT 3
4779: PUSH
4780: EMPTY
4781: LIST
4782: LIST
4783: PUSH
4784: EMPTY
4785: LIST
4786: LIST
4787: PPUSH
4788: CALL_OW 69
4792: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
4793: LD_ADDR_VAR 0 12
4797: PUSH
4798: LD_INT 22
4800: PUSH
4801: LD_INT 3
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PUSH
4808: LD_INT 30
4810: PUSH
4811: LD_INT 31
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: EMPTY
4819: LIST
4820: LIST
4821: PPUSH
4822: CALL_OW 69
4826: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
4827: LD_ADDR_VAR 0 13
4831: PUSH
4832: LD_INT 22
4834: PUSH
4835: LD_INT 3
4837: PUSH
4838: EMPTY
4839: LIST
4840: LIST
4841: PUSH
4842: LD_INT 30
4844: PUSH
4845: LD_INT 32
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: PUSH
4852: EMPTY
4853: LIST
4854: LIST
4855: PPUSH
4856: CALL_OW 69
4860: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
4861: LD_ADDR_VAR 0 14
4865: PUSH
4866: LD_INT 22
4868: PUSH
4869: LD_INT 3
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: PUSH
4876: LD_INT 30
4878: PUSH
4879: LD_INT 33
4881: PUSH
4882: EMPTY
4883: LIST
4884: LIST
4885: PUSH
4886: EMPTY
4887: LIST
4888: LIST
4889: PPUSH
4890: CALL_OW 69
4894: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
4895: LD_ADDR_VAR 0 15
4899: PUSH
4900: LD_INT 42
4902: PUSH
4903: LD_INT 5
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: PUSH
4910: LD_INT 43
4912: PUSH
4913: LD_INT 50
4915: PUSH
4916: EMPTY
4917: LIST
4918: LIST
4919: PUSH
4920: LD_INT 44
4922: PUSH
4923: LD_INT 30
4925: PUSH
4926: EMPTY
4927: LIST
4928: LIST
4929: PUSH
4930: LD_INT 46
4932: PUSH
4933: LD_INT 15
4935: PUSH
4936: EMPTY
4937: LIST
4938: LIST
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: LIST
4944: LIST
4945: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 6 , 3 ] ;
4946: LD_ADDR_VAR 0 16
4950: PUSH
4951: LD_INT 0
4953: PUSH
4954: LD_INT 4
4956: PUSH
4957: LD_INT 6
4959: PUSH
4960: LD_INT 3
4962: PUSH
4963: EMPTY
4964: LIST
4965: LIST
4966: LIST
4967: LIST
4968: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
4969: LD_ADDR_VAR 0 6
4973: PUSH
4974: LD_INT 4
4976: PUSH
4977: LD_INT 5
4979: PUSH
4980: LD_INT 6
4982: PUSH
4983: EMPTY
4984: LIST
4985: LIST
4986: LIST
4987: PUSH
4988: LD_OWVAR 67
4992: ARRAY
4993: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
4994: LD_INT 16
4996: PPUSH
4997: LD_STRING am_tukh
4999: PPUSH
5000: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
5004: LD_ADDR_VAR 0 2
5008: PUSH
5009: LD_INT 21
5011: PUSH
5012: LD_INT 3
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: PPUSH
5019: CALL_OW 69
5023: PUSH
5024: FOR_IN
5025: IFFALSE 5058
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
5027: LD_VAR 0 2
5031: PPUSH
5032: LD_INT 4
5034: PUSH
5035: LD_INT 5
5037: PUSH
5038: LD_INT 6
5040: PUSH
5041: EMPTY
5042: LIST
5043: LIST
5044: LIST
5045: PUSH
5046: LD_OWVAR 67
5050: ARRAY
5051: PPUSH
5052: CALL_OW 241
5056: GO 5024
5058: POP
5059: POP
// for i in dep_list do
5060: LD_ADDR_VAR 0 2
5064: PUSH
5065: LD_VAR 0 9
5069: PUSH
5070: FOR_IN
5071: IFFALSE 5115
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
5073: LD_VAR 0 2
5077: PPUSH
5078: CALL_OW 274
5082: PPUSH
5083: LD_INT 1
5085: PPUSH
5086: LD_INT 1000
5088: PPUSH
5089: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
5093: LD_VAR 0 2
5097: PPUSH
5098: CALL_OW 274
5102: PPUSH
5103: LD_INT 2
5105: PPUSH
5106: LD_INT 1000
5108: PPUSH
5109: CALL_OW 277
// end ;
5113: GO 5070
5115: POP
5116: POP
// InitHc ;
5117: CALL_OW 19
// tmp := bunker_list * [ 45 , 60 , 75 ] [ Difficulty ] div 100 ;
5121: LD_ADDR_VAR 0 8
5125: PUSH
5126: LD_VAR 0 13
5130: PUSH
5131: LD_INT 45
5133: PUSH
5134: LD_INT 60
5136: PUSH
5137: LD_INT 75
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: LIST
5144: PUSH
5145: LD_OWVAR 67
5149: ARRAY
5150: MUL
5151: PUSH
5152: LD_INT 100
5154: DIV
5155: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
5156: LD_ADDR_VAR 0 16
5160: PUSH
5161: LD_VAR 0 16
5165: PPUSH
5166: LD_INT 1
5168: PPUSH
5169: LD_VAR 0 8
5173: PPUSH
5174: CALL_OW 1
5178: ST_TO_ADDR
// tmp := [ ] ;
5179: LD_ADDR_VAR 0 8
5183: PUSH
5184: EMPTY
5185: ST_TO_ADDR
// for i in bunker_list do
5186: LD_ADDR_VAR 0 2
5190: PUSH
5191: LD_VAR 0 13
5195: PUSH
5196: FOR_IN
5197: IFFALSE 5293
// if i mod 10 + 1 < tmp then
5199: LD_VAR 0 2
5203: PUSH
5204: LD_INT 10
5206: MOD
5207: PUSH
5208: LD_INT 1
5210: PLUS
5211: PUSH
5212: LD_VAR 0 8
5216: LESS
5217: IFFALSE 5262
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
5219: LD_ADDR_VAR 0 8
5223: PUSH
5224: LD_VAR 0 8
5228: PPUSH
5229: LD_VAR 0 2
5233: PUSH
5234: LD_INT 3
5236: PPUSH
5237: LD_INT 5
5239: PPUSH
5240: CALL_OW 12
5244: MOD
5245: PUSH
5246: LD_INT 1
5248: PLUS
5249: PPUSH
5250: LD_VAR 0 2
5254: PPUSH
5255: CALL_OW 2
5259: ST_TO_ADDR
5260: GO 5291
// tmp := Insert ( tmp , tmp + 1 , i ) ;
5262: LD_ADDR_VAR 0 8
5266: PUSH
5267: LD_VAR 0 8
5271: PPUSH
5272: LD_VAR 0 8
5276: PUSH
5277: LD_INT 1
5279: PLUS
5280: PPUSH
5281: LD_VAR 0 2
5285: PPUSH
5286: CALL_OW 2
5290: ST_TO_ADDR
5291: GO 5196
5293: POP
5294: POP
// bunker_list := tmp ;
5295: LD_ADDR_VAR 0 13
5299: PUSH
5300: LD_VAR 0 8
5304: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
5305: LD_ADDR_VAR 0 2
5309: PUSH
5310: LD_VAR 0 13
5314: PUSH
5315: LD_VAR 0 14
5319: ADD
5320: PUSH
5321: FOR_IN
5322: IFFALSE 5345
// PlaceWeaponTurret ( i , GetTurretWeapon ( i ) ) ;
5324: LD_VAR 0 2
5328: PPUSH
5329: LD_VAR 0 2
5333: PPUSH
5334: CALL 831 0 1
5338: PPUSH
5339: CALL_OW 431
5343: GO 5321
5345: POP
5346: POP
// while ( personel_counter [ 1 ] ) do
5347: LD_VAR 0 16
5351: PUSH
5352: LD_INT 1
5354: ARRAY
5355: IFFALSE 5463
// begin i := rand ( 1 , bunker_list ) ;
5357: LD_ADDR_VAR 0 2
5361: PUSH
5362: LD_INT 1
5364: PPUSH
5365: LD_VAR 0 13
5369: PPUSH
5370: CALL_OW 12
5374: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5375: LD_INT 0
5377: PPUSH
5378: LD_INT 1
5380: PPUSH
5381: LD_VAR 0 6
5385: PPUSH
5386: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
5390: CALL_OW 44
5394: PPUSH
5395: LD_VAR 0 13
5399: PUSH
5400: LD_VAR 0 2
5404: ARRAY
5405: PPUSH
5406: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
5410: LD_ADDR_VAR 0 13
5414: PUSH
5415: LD_VAR 0 13
5419: PPUSH
5420: LD_VAR 0 2
5424: PPUSH
5425: CALL_OW 3
5429: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
5430: LD_ADDR_VAR 0 16
5434: PUSH
5435: LD_VAR 0 16
5439: PPUSH
5440: LD_INT 1
5442: PPUSH
5443: LD_VAR 0 16
5447: PUSH
5448: LD_INT 1
5450: ARRAY
5451: PUSH
5452: LD_INT 1
5454: MINUS
5455: PPUSH
5456: CALL_OW 1
5460: ST_TO_ADDR
// end ;
5461: GO 5347
// for i = 1 to personel_counter [ 2 ] do
5463: LD_ADDR_VAR 0 2
5467: PUSH
5468: DOUBLE
5469: LD_INT 1
5471: DEC
5472: ST_TO_ADDR
5473: LD_VAR 0 16
5477: PUSH
5478: LD_INT 2
5480: ARRAY
5481: PUSH
5482: FOR_TO
5483: IFFALSE 5514
// begin PrepareHuman ( false , 2 , skill ) ;
5485: LD_INT 0
5487: PPUSH
5488: LD_INT 2
5490: PPUSH
5491: LD_VAR 0 6
5495: PPUSH
5496: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
5500: CALL_OW 44
5504: PPUSH
5505: LD_INT 16
5507: PPUSH
5508: CALL_OW 52
// end ;
5512: GO 5482
5514: POP
5515: POP
// for i = 1 to personel_counter [ 3 ] do
5516: LD_ADDR_VAR 0 2
5520: PUSH
5521: DOUBLE
5522: LD_INT 1
5524: DEC
5525: ST_TO_ADDR
5526: LD_VAR 0 16
5530: PUSH
5531: LD_INT 3
5533: ARRAY
5534: PUSH
5535: FOR_TO
5536: IFFALSE 5583
// begin PrepareHuman ( false , 3 , skill ) ;
5538: LD_INT 0
5540: PPUSH
5541: LD_INT 3
5543: PPUSH
5544: LD_VAR 0 6
5548: PPUSH
5549: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ i mod 2 + 1 ] ) ;
5553: CALL_OW 44
5557: PPUSH
5558: LD_VAR 0 11
5562: PUSH
5563: LD_VAR 0 2
5567: PUSH
5568: LD_INT 2
5570: MOD
5571: PUSH
5572: LD_INT 1
5574: PLUS
5575: ARRAY
5576: PPUSH
5577: CALL_OW 52
// end ;
5581: GO 5535
5583: POP
5584: POP
// for i = 1 to personel_counter [ 4 ] do
5585: LD_ADDR_VAR 0 2
5589: PUSH
5590: DOUBLE
5591: LD_INT 1
5593: DEC
5594: ST_TO_ADDR
5595: LD_VAR 0 16
5599: PUSH
5600: LD_INT 4
5602: ARRAY
5603: PUSH
5604: FOR_TO
5605: IFFALSE 5642
// begin PrepareHuman ( false , 4 , skill ) ;
5607: LD_INT 0
5609: PPUSH
5610: LD_INT 4
5612: PPUSH
5613: LD_VAR 0 6
5617: PPUSH
5618: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
5622: CALL_OW 44
5626: PPUSH
5627: LD_VAR 0 10
5631: PUSH
5632: LD_INT 1
5634: ARRAY
5635: PPUSH
5636: CALL_OW 52
// end ;
5640: GO 5604
5642: POP
5643: POP
// for i in breastworks_list do
5644: LD_ADDR_VAR 0 2
5648: PUSH
5649: LD_VAR 0 12
5653: PUSH
5654: FOR_IN
5655: IFFALSE 5767
// begin r := GetDir ( i ) ;
5657: LD_ADDR_VAR 0 4
5661: PUSH
5662: LD_VAR 0 2
5666: PPUSH
5667: CALL_OW 254
5671: ST_TO_ADDR
// if r > 3 then
5672: LD_VAR 0 4
5676: PUSH
5677: LD_INT 3
5679: GREATER
5680: IFFALSE 5698
// r := r - 3 else
5682: LD_ADDR_VAR 0 4
5686: PUSH
5687: LD_VAR 0 4
5691: PUSH
5692: LD_INT 3
5694: MINUS
5695: ST_TO_ADDR
5696: GO 5712
// r := r + 3 ;
5698: LD_ADDR_VAR 0 4
5702: PUSH
5703: LD_VAR 0 4
5707: PUSH
5708: LD_INT 3
5710: PLUS
5711: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5712: LD_INT 0
5714: PPUSH
5715: LD_INT 1
5717: PPUSH
5718: LD_VAR 0 6
5722: PPUSH
5723: CALL_OW 380
// un := CreateHuman ;
5727: LD_ADDR_VAR 0 5
5731: PUSH
5732: CALL_OW 44
5736: ST_TO_ADDR
// SetDir ( un , r ) ;
5737: LD_VAR 0 5
5741: PPUSH
5742: LD_VAR 0 4
5746: PPUSH
5747: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
5751: LD_VAR 0 5
5755: PPUSH
5756: LD_VAR 0 2
5760: PPUSH
5761: CALL_OW 52
// end ;
5765: GO 5654
5767: POP
5768: POP
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
5769: LD_ADDR_VAR 0 8
5773: PUSH
5774: LD_INT 22
5776: PUSH
5777: LD_INT 3
5779: PUSH
5780: EMPTY
5781: LIST
5782: LIST
5783: PUSH
5784: LD_INT 25
5786: PUSH
5787: LD_INT 3
5789: PUSH
5790: EMPTY
5791: LIST
5792: LIST
5793: PUSH
5794: EMPTY
5795: LIST
5796: LIST
5797: PPUSH
5798: CALL_OW 69
5802: ST_TO_ADDR
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
5803: LD_ADDR_VAR 0 4
5807: PUSH
5808: LD_INT 4
5810: PUSH
5811: LD_INT 5
5813: PUSH
5814: LD_INT 6
5816: PUSH
5817: EMPTY
5818: LIST
5819: LIST
5820: LIST
5821: PUSH
5822: LD_OWVAR 67
5826: ARRAY
5827: ST_TO_ADDR
// for i = 1 to r do
5828: LD_ADDR_VAR 0 2
5832: PUSH
5833: DOUBLE
5834: LD_INT 1
5836: DEC
5837: ST_TO_ADDR
5838: LD_VAR 0 4
5842: PUSH
5843: FOR_TO
5844: IFFALSE 6017
// begin un := PrepareTank ( 3 , 3 , [ ru_medium_tracked , ru_medium_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
5846: LD_ADDR_VAR 0 5
5850: PUSH
5851: LD_INT 3
5853: PPUSH
5854: LD_INT 3
5856: PPUSH
5857: LD_INT 22
5859: PUSH
5860: LD_INT 22
5862: PUSH
5863: LD_INT 24
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: LIST
5870: PUSH
5871: LD_VAR 0 2
5875: PUSH
5876: LD_INT 3
5878: MOD
5879: PUSH
5880: LD_INT 1
5882: PLUS
5883: ARRAY
5884: PPUSH
5885: LD_INT 1
5887: PPUSH
5888: LD_INT 1
5890: PPUSH
5891: LD_INT 43
5893: PUSH
5894: LD_INT 44
5896: PUSH
5897: LD_INT 42
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: LIST
5904: PUSH
5905: LD_VAR 0 2
5909: PUSH
5910: LD_INT 3
5912: MOD
5913: PUSH
5914: LD_INT 1
5916: PLUS
5917: ARRAY
5918: PPUSH
5919: LD_INT 100
5921: PPUSH
5922: CALL 417 0 7
5926: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
5927: LD_VAR 0 5
5931: PPUSH
5932: LD_INT 0
5934: PPUSH
5935: LD_INT 5
5937: PPUSH
5938: CALL_OW 12
5942: PPUSH
5943: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
5947: LD_VAR 0 5
5951: PPUSH
5952: LD_INT 5
5954: PPUSH
5955: LD_INT 0
5957: PPUSH
5958: CALL_OW 49
// if i > tmp - 2 then
5962: LD_VAR 0 2
5966: PUSH
5967: LD_VAR 0 8
5971: PUSH
5972: LD_INT 2
5974: MINUS
5975: GREATER
5976: IFFALSE 5980
// continue ;
5978: GO 5843
// ComExitBuilding ( tmp [ i ] ) ;
5980: LD_VAR 0 8
5984: PUSH
5985: LD_VAR 0 2
5989: ARRAY
5990: PPUSH
5991: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , un ) ;
5995: LD_VAR 0 8
5999: PUSH
6000: LD_VAR 0 2
6004: ARRAY
6005: PPUSH
6006: LD_VAR 0 5
6010: PPUSH
6011: CALL_OW 180
// end ;
6015: GO 5843
6017: POP
6018: POP
// end ;
6019: LD_VAR 0 1
6023: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_ok ] ] ) do var i , filter , tmp , engs , enemy ;
6024: LD_INT 22
6026: PUSH
6027: LD_INT 3
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: PUSH
6034: LD_INT 25
6036: PUSH
6037: LD_INT 2
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: PUSH
6044: LD_INT 50
6046: PUSH
6047: EMPTY
6048: LIST
6049: PUSH
6050: EMPTY
6051: LIST
6052: LIST
6053: LIST
6054: PPUSH
6055: CALL_OW 69
6059: IFFALSE 6755
6061: GO 6063
6063: DISABLE
6064: LD_INT 0
6066: PPUSH
6067: PPUSH
6068: PPUSH
6069: PPUSH
6070: PPUSH
// begin enable ;
6071: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
6072: LD_ADDR_VAR 0 2
6076: PUSH
6077: LD_INT 6
6079: PPUSH
6080: LD_INT 3
6082: PUSH
6083: LD_INT 24
6085: PUSH
6086: LD_INT 1000
6088: PUSH
6089: EMPTY
6090: LIST
6091: LIST
6092: PUSH
6093: EMPTY
6094: LIST
6095: LIST
6096: PUSH
6097: LD_INT 21
6099: PUSH
6100: LD_INT 3
6102: PUSH
6103: EMPTY
6104: LIST
6105: LIST
6106: PUSH
6107: EMPTY
6108: LIST
6109: LIST
6110: PPUSH
6111: CALL_OW 70
6115: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_lives , 650 ] ] ) ;
6116: LD_ADDR_VAR 0 4
6120: PUSH
6121: LD_INT 22
6123: PUSH
6124: LD_INT 3
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: PUSH
6131: LD_INT 25
6133: PUSH
6134: LD_INT 2
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: PUSH
6141: LD_INT 24
6143: PUSH
6144: LD_INT 650
6146: PUSH
6147: EMPTY
6148: LIST
6149: LIST
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: LIST
6155: PPUSH
6156: CALL_OW 69
6160: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
6161: LD_VAR 0 2
6165: NOT
6166: PUSH
6167: LD_EXP 19
6171: NOT
6172: AND
6173: IFFALSE 6205
// begin if not IsInUnit ( engs [ 1 ] ) then
6175: LD_VAR 0 4
6179: PUSH
6180: LD_INT 1
6182: ARRAY
6183: PPUSH
6184: CALL_OW 310
6188: NOT
6189: IFFALSE 6203
// ComEnterUnit ( engs , ru_dep_main ) ;
6191: LD_VAR 0 4
6195: PPUSH
6196: LD_INT 16
6198: PPUSH
6199: CALL_OW 120
// exit ;
6203: GO 6755
// end ; if debug then
6205: LD_EXP 1
6209: IFFALSE 6230
// display_strings := [ engs , filter ] ;
6211: LD_ADDR_OWVAR 47
6215: PUSH
6216: LD_VAR 0 4
6220: PUSH
6221: LD_VAR 0 2
6225: PUSH
6226: EMPTY
6227: LIST
6228: LIST
6229: ST_TO_ADDR
// if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
6230: LD_VAR 0 4
6234: PPUSH
6235: LD_INT 3
6237: PUSH
6238: LD_INT 24
6240: PUSH
6241: LD_INT 650
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: PUSH
6248: EMPTY
6249: LIST
6250: LIST
6251: PPUSH
6252: CALL_OW 72
6256: IFFALSE 6349
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
6258: LD_ADDR_VAR 0 3
6262: PUSH
6263: LD_VAR 0 4
6267: PPUSH
6268: LD_INT 3
6270: PUSH
6271: LD_INT 24
6273: PUSH
6274: LD_INT 650
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: PPUSH
6285: CALL_OW 72
6289: ST_TO_ADDR
// for i in tmp do
6290: LD_ADDR_VAR 0 1
6294: PUSH
6295: LD_VAR 0 3
6299: PUSH
6300: FOR_IN
6301: IFFALSE 6347
// if not IsInArea ( i , mainBaseArea ) then
6303: LD_VAR 0 1
6307: PPUSH
6308: LD_INT 14
6310: PPUSH
6311: CALL_OW 308
6315: NOT
6316: IFFALSE 6345
// begin ComMoveXY ( i , 129 , 125 ) ;
6318: LD_VAR 0 1
6322: PPUSH
6323: LD_INT 129
6325: PPUSH
6326: LD_INT 125
6328: PPUSH
6329: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
6333: LD_VAR 0 1
6337: PPUSH
6338: LD_INT 1050
6340: PPUSH
6341: CALL_OW 202
// end ;
6345: GO 6300
6347: POP
6348: POP
// end ; if filter then
6349: LD_VAR 0 2
6353: IFFALSE 6612
// begin for i in engs do
6355: LD_ADDR_VAR 0 1
6359: PUSH
6360: LD_VAR 0 4
6364: PUSH
6365: FOR_IN
6366: IFFALSE 6390
// if IsInUnit ( i ) then
6368: LD_VAR 0 1
6372: PPUSH
6373: CALL_OW 310
6377: IFFALSE 6388
// ComExitBuilding ( i ) ;
6379: LD_VAR 0 1
6383: PPUSH
6384: CALL_OW 122
6388: GO 6365
6390: POP
6391: POP
// wait ( 3 ) ;
6392: LD_INT 3
6394: PPUSH
6395: CALL_OW 67
// if filter >= 2 and engs >= 2 then
6399: LD_VAR 0 2
6403: PUSH
6404: LD_INT 2
6406: GREATEREQUAL
6407: PUSH
6408: LD_VAR 0 4
6412: PUSH
6413: LD_INT 2
6415: GREATEREQUAL
6416: AND
6417: IFFALSE 6565
// begin for i = 1 to engs / 2 do
6419: LD_ADDR_VAR 0 1
6423: PUSH
6424: DOUBLE
6425: LD_INT 1
6427: DEC
6428: ST_TO_ADDR
6429: LD_VAR 0 4
6433: PUSH
6434: LD_INT 2
6436: DIVREAL
6437: PUSH
6438: FOR_TO
6439: IFFALSE 6485
// if not HasTask ( engs [ i ] ) then
6441: LD_VAR 0 4
6445: PUSH
6446: LD_VAR 0 1
6450: ARRAY
6451: PPUSH
6452: CALL_OW 314
6456: NOT
6457: IFFALSE 6483
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
6459: LD_VAR 0 4
6463: PUSH
6464: LD_VAR 0 1
6468: ARRAY
6469: PPUSH
6470: LD_VAR 0 2
6474: PUSH
6475: LD_INT 1
6477: ARRAY
6478: PPUSH
6479: CALL_OW 130
6483: GO 6438
6485: POP
6486: POP
// for i = engs / 2 + 1 to engs do
6487: LD_ADDR_VAR 0 1
6491: PUSH
6492: DOUBLE
6493: LD_VAR 0 4
6497: PUSH
6498: LD_INT 2
6500: DIVREAL
6501: PUSH
6502: LD_INT 1
6504: PLUS
6505: DEC
6506: ST_TO_ADDR
6507: LD_VAR 0 4
6511: PUSH
6512: FOR_TO
6513: IFFALSE 6561
// if not HasTask ( engs [ i ] ) then
6515: LD_VAR 0 4
6519: PUSH
6520: LD_VAR 0 1
6524: ARRAY
6525: PPUSH
6526: CALL_OW 314
6530: NOT
6531: IFFALSE 6559
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
6533: LD_VAR 0 4
6537: PUSH
6538: LD_VAR 0 1
6542: ARRAY
6543: PPUSH
6544: LD_VAR 0 2
6548: PUSH
6549: LD_VAR 0 2
6553: ARRAY
6554: PPUSH
6555: CALL_OW 130
6559: GO 6512
6561: POP
6562: POP
// end else
6563: GO 6612
// for i in engs do
6565: LD_ADDR_VAR 0 1
6569: PUSH
6570: LD_VAR 0 4
6574: PUSH
6575: FOR_IN
6576: IFFALSE 6610
// if not HasTask ( i ) then
6578: LD_VAR 0 1
6582: PPUSH
6583: CALL_OW 314
6587: NOT
6588: IFFALSE 6608
// ComRepairBuilding ( i , filter [ 1 ] ) ;
6590: LD_VAR 0 1
6594: PPUSH
6595: LD_VAR 0 2
6599: PUSH
6600: LD_INT 1
6602: ARRAY
6603: PPUSH
6604: CALL_OW 130
6608: GO 6575
6610: POP
6611: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
6612: LD_ADDR_VAR 0 5
6616: PUSH
6617: LD_INT 81
6619: PUSH
6620: LD_INT 3
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: PPUSH
6627: CALL_OW 69
6631: ST_TO_ADDR
// if ru_rebuild_list and not filter then
6632: LD_EXP 19
6636: PUSH
6637: LD_VAR 0 2
6641: NOT
6642: AND
6643: IFFALSE 6755
// begin ComExitBuilding ( engs ) ;
6645: LD_VAR 0 4
6649: PPUSH
6650: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
6654: LD_VAR 0 5
6658: PPUSH
6659: LD_EXP 19
6663: PUSH
6664: LD_INT 2
6666: ARRAY
6667: PPUSH
6668: LD_EXP 19
6672: PUSH
6673: LD_INT 3
6675: ARRAY
6676: PPUSH
6677: CALL_OW 73
6681: PPUSH
6682: LD_EXP 19
6686: PUSH
6687: LD_INT 2
6689: ARRAY
6690: PPUSH
6691: LD_EXP 19
6695: PUSH
6696: LD_INT 3
6698: ARRAY
6699: PPUSH
6700: CALL_OW 297
6704: PUSH
6705: LD_INT 10
6707: GREATER
6708: IFFALSE 6755
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
6710: LD_VAR 0 4
6714: PPUSH
6715: LD_EXP 19
6719: PUSH
6720: LD_INT 1
6722: ARRAY
6723: PPUSH
6724: LD_EXP 19
6728: PUSH
6729: LD_INT 2
6731: ARRAY
6732: PPUSH
6733: LD_EXP 19
6737: PUSH
6738: LD_INT 3
6740: ARRAY
6741: PPUSH
6742: LD_EXP 19
6746: PUSH
6747: LD_INT 4
6749: ARRAY
6750: PPUSH
6751: CALL_OW 145
// end ; end ;
6755: PPOPN 5
6757: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 650 do var tmp ;
6758: LD_INT 16
6760: PPUSH
6761: CALL_OW 256
6765: PUSH
6766: LD_INT 650
6768: LESS
6769: IFFALSE 6852
6771: GO 6773
6773: DISABLE
6774: LD_INT 0
6776: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
6777: LD_ADDR_VAR 0 1
6781: PUSH
6782: LD_INT 22
6784: PUSH
6785: LD_INT 3
6787: PUSH
6788: EMPTY
6789: LIST
6790: LIST
6791: PUSH
6792: LD_INT 25
6794: PUSH
6795: LD_INT 1
6797: PUSH
6798: EMPTY
6799: LIST
6800: LIST
6801: PUSH
6802: EMPTY
6803: LIST
6804: LIST
6805: PPUSH
6806: CALL_OW 69
6810: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
6811: LD_VAR 0 1
6815: PPUSH
6816: CALL_OW 122
// wait ( 3 ) ;
6820: LD_INT 3
6822: PPUSH
6823: CALL_OW 67
// ComAgressiveMove ( tmp , GetX ( ru_dep_main ) , GetY ( ru_dep_main ) ) ;
6827: LD_VAR 0 1
6831: PPUSH
6832: LD_INT 16
6834: PPUSH
6835: CALL_OW 250
6839: PPUSH
6840: LD_INT 16
6842: PPUSH
6843: CALL_OW 251
6847: PPUSH
6848: CALL_OW 114
// end ;
6852: PPOPN 1
6854: END
// every 0 0$01 trigger GetLives ( ru_dep_main ) > 650 and FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] ] ] ) do var i , tmp ;
6855: LD_INT 16
6857: PPUSH
6858: CALL_OW 256
6862: PUSH
6863: LD_INT 650
6865: GREATER
6866: PUSH
6867: LD_INT 22
6869: PUSH
6870: LD_INT 3
6872: PUSH
6873: EMPTY
6874: LIST
6875: LIST
6876: PUSH
6877: LD_INT 25
6879: PUSH
6880: LD_INT 1
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: PUSH
6887: LD_INT 56
6889: PUSH
6890: EMPTY
6891: LIST
6892: PUSH
6893: EMPTY
6894: LIST
6895: LIST
6896: LIST
6897: PUSH
6898: EMPTY
6899: LIST
6900: PPUSH
6901: CALL_OW 69
6905: AND
6906: IFFALSE 7018
6908: GO 6910
6910: DISABLE
6911: LD_INT 0
6913: PPUSH
6914: PPUSH
// begin enable ;
6915: ENABLE
// tmp := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] , [ f_not , [ f_hastask ] ] ] ] ) ;
6916: LD_ADDR_VAR 0 2
6920: PUSH
6921: LD_INT 22
6923: PUSH
6924: LD_INT 3
6926: PUSH
6927: EMPTY
6928: LIST
6929: LIST
6930: PUSH
6931: LD_INT 25
6933: PUSH
6934: LD_INT 1
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: PUSH
6941: LD_INT 56
6943: PUSH
6944: EMPTY
6945: LIST
6946: PUSH
6947: LD_INT 3
6949: PUSH
6950: LD_INT 60
6952: PUSH
6953: EMPTY
6954: LIST
6955: PUSH
6956: EMPTY
6957: LIST
6958: LIST
6959: PUSH
6960: EMPTY
6961: LIST
6962: LIST
6963: LIST
6964: LIST
6965: PUSH
6966: EMPTY
6967: LIST
6968: PPUSH
6969: CALL_OW 69
6973: ST_TO_ADDR
// if not tmp then
6974: LD_VAR 0 2
6978: NOT
6979: IFFALSE 6983
// exit ;
6981: GO 7018
// for i in tmp do
6983: LD_ADDR_VAR 0 1
6987: PUSH
6988: LD_VAR 0 2
6992: PUSH
6993: FOR_IN
6994: IFFALSE 7016
// GoToAnotherTower ( i , 0 , 143 , 143 ) ;
6996: LD_VAR 0 1
7000: PPUSH
7001: LD_INT 0
7003: PPUSH
7004: LD_INT 143
7006: PPUSH
7007: LD_INT 143
7009: PPUSH
7010: CALL 2054 0 4
7014: GO 6993
7016: POP
7017: POP
// end ;
7018: PPOPN 2
7020: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
7021: LD_INT 22
7023: PUSH
7024: LD_INT 3
7026: PUSH
7027: EMPTY
7028: LIST
7029: LIST
7030: PUSH
7031: LD_INT 25
7033: PUSH
7034: LD_INT 4
7036: PUSH
7037: EMPTY
7038: LIST
7039: LIST
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PPUSH
7045: CALL_OW 69
7049: IFFALSE 7303
7051: GO 7053
7053: DISABLE
7054: LD_INT 0
7056: PPUSH
7057: PPUSH
7058: PPUSH
// begin enable ;
7059: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7060: LD_ADDR_VAR 0 2
7064: PUSH
7065: LD_INT 14
7067: PPUSH
7068: LD_INT 22
7070: PUSH
7071: LD_INT 3
7073: PUSH
7074: EMPTY
7075: LIST
7076: LIST
7077: PUSH
7078: LD_INT 21
7080: PUSH
7081: LD_INT 1
7083: PUSH
7084: EMPTY
7085: LIST
7086: LIST
7087: PUSH
7088: LD_INT 3
7090: PUSH
7091: LD_INT 24
7093: PUSH
7094: LD_INT 1000
7096: PUSH
7097: EMPTY
7098: LIST
7099: LIST
7100: PUSH
7101: EMPTY
7102: LIST
7103: LIST
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: LIST
7109: PPUSH
7110: CALL_OW 70
7114: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
7115: LD_ADDR_VAR 0 3
7119: PUSH
7120: LD_INT 22
7122: PUSH
7123: LD_INT 3
7125: PUSH
7126: EMPTY
7127: LIST
7128: LIST
7129: PUSH
7130: LD_INT 25
7132: PUSH
7133: LD_INT 4
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: PUSH
7140: EMPTY
7141: LIST
7142: LIST
7143: PPUSH
7144: CALL_OW 69
7148: ST_TO_ADDR
// if not doc then
7149: LD_VAR 0 3
7153: NOT
7154: IFFALSE 7158
// exit ;
7156: GO 7303
// if not tmp then
7158: LD_VAR 0 2
7162: NOT
7163: IFFALSE 7254
// begin if not IsInUnit ( doc [ 1 ] ) then
7165: LD_VAR 0 3
7169: PUSH
7170: LD_INT 1
7172: ARRAY
7173: PPUSH
7174: CALL_OW 310
7178: NOT
7179: IFFALSE 7252
// ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
7181: LD_VAR 0 3
7185: PPUSH
7186: LD_INT 22
7188: PUSH
7189: LD_INT 3
7191: PUSH
7192: EMPTY
7193: LIST
7194: LIST
7195: PUSH
7196: LD_INT 2
7198: PUSH
7199: LD_INT 30
7201: PUSH
7202: LD_INT 6
7204: PUSH
7205: EMPTY
7206: LIST
7207: LIST
7208: PUSH
7209: LD_INT 30
7211: PUSH
7212: LD_INT 7
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 30
7221: PUSH
7222: LD_INT 8
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: LIST
7233: LIST
7234: PUSH
7235: EMPTY
7236: LIST
7237: LIST
7238: PPUSH
7239: CALL_OW 69
7243: PUSH
7244: LD_INT 1
7246: ARRAY
7247: PPUSH
7248: CALL_OW 120
// exit ;
7252: GO 7303
// end ; if IsInUnit ( doc [ 1 ] ) then
7254: LD_VAR 0 3
7258: PUSH
7259: LD_INT 1
7261: ARRAY
7262: PPUSH
7263: CALL_OW 310
7267: IFFALSE 7278
// ComExitBuilding ( doc ) ;
7269: LD_VAR 0 3
7273: PPUSH
7274: CALL_OW 122
// wait ( 3 ) ;
7278: LD_INT 3
7280: PPUSH
7281: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
7285: LD_VAR 0 3
7289: PPUSH
7290: LD_VAR 0 2
7294: PUSH
7295: LD_INT 1
7297: ARRAY
7298: PPUSH
7299: CALL_OW 128
// end ;
7303: PPOPN 3
7305: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , tmp , attacking , areas , area ;
7306: LD_INT 22
7308: PUSH
7309: LD_INT 3
7311: PUSH
7312: EMPTY
7313: LIST
7314: LIST
7315: PUSH
7316: LD_INT 25
7318: PUSH
7319: LD_INT 3
7321: PUSH
7322: EMPTY
7323: LIST
7324: LIST
7325: PUSH
7326: EMPTY
7327: LIST
7328: LIST
7329: PPUSH
7330: CALL_OW 69
7334: PUSH
7335: LD_INT 22
7337: PUSH
7338: LD_INT 3
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PUSH
7345: LD_INT 21
7347: PUSH
7348: LD_INT 2
7350: PUSH
7351: EMPTY
7352: LIST
7353: LIST
7354: PUSH
7355: EMPTY
7356: LIST
7357: LIST
7358: PPUSH
7359: CALL_OW 69
7363: AND
7364: IFFALSE 7778
7366: GO 7368
7368: DISABLE
7369: LD_INT 0
7371: PPUSH
7372: PPUSH
7373: PPUSH
7374: PPUSH
7375: PPUSH
// begin enable ;
7376: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
7377: LD_ADDR_VAR 0 2
7381: PUSH
7382: LD_INT 22
7384: PUSH
7385: LD_INT 3
7387: PUSH
7388: EMPTY
7389: LIST
7390: LIST
7391: PUSH
7392: LD_INT 21
7394: PUSH
7395: LD_INT 2
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: PUSH
7402: LD_INT 3
7404: PUSH
7405: LD_INT 58
7407: PUSH
7408: EMPTY
7409: LIST
7410: PUSH
7411: EMPTY
7412: LIST
7413: LIST
7414: PUSH
7415: EMPTY
7416: LIST
7417: LIST
7418: LIST
7419: PPUSH
7420: CALL_OW 69
7424: ST_TO_ADDR
// areas := [ sectorAlpha , sectorBeta , sectorDelta , mainBaseArea ] ;
7425: LD_ADDR_VAR 0 4
7429: PUSH
7430: LD_INT 10
7432: PUSH
7433: LD_INT 11
7435: PUSH
7436: LD_INT 12
7438: PUSH
7439: LD_INT 14
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: LIST
7447: ST_TO_ADDR
// area := 0 ;
7448: LD_ADDR_VAR 0 5
7452: PUSH
7453: LD_INT 0
7455: ST_TO_ADDR
// attacking := false ;
7456: LD_ADDR_VAR 0 3
7460: PUSH
7461: LD_INT 0
7463: ST_TO_ADDR
// for i in tmp do
7464: LD_ADDR_VAR 0 1
7468: PUSH
7469: LD_VAR 0 2
7473: PUSH
7474: FOR_IN
7475: IFFALSE 7561
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
7477: LD_VAR 0 1
7481: PPUSH
7482: LD_INT 22
7484: PUSH
7485: LD_INT 1
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: PPUSH
7492: CALL_OW 69
7496: PPUSH
7497: LD_VAR 0 1
7501: PPUSH
7502: CALL_OW 74
7506: PPUSH
7507: CALL_OW 296
7511: PUSH
7512: LD_INT 10
7514: LESS
7515: IFFALSE 7559
// begin ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7517: LD_VAR 0 1
7521: PPUSH
7522: LD_INT 22
7524: PUSH
7525: LD_INT 1
7527: PUSH
7528: EMPTY
7529: LIST
7530: LIST
7531: PPUSH
7532: CALL_OW 69
7536: PPUSH
7537: LD_VAR 0 1
7541: PPUSH
7542: CALL_OW 74
7546: PPUSH
7547: CALL_OW 115
// attacking := true ;
7551: LD_ADDR_VAR 0 3
7555: PUSH
7556: LD_INT 1
7558: ST_TO_ADDR
// end ;
7559: GO 7474
7561: POP
7562: POP
// if attacking then
7563: LD_VAR 0 3
7567: IFFALSE 7571
// exit ;
7569: GO 7778
// for i in areas do
7571: LD_ADDR_VAR 0 1
7575: PUSH
7576: LD_VAR 0 4
7580: PUSH
7581: FOR_IN
7582: IFFALSE 7619
// if FilterUnitsInArea ( i , [ f_side , 1 ] ) then
7584: LD_VAR 0 1
7588: PPUSH
7589: LD_INT 22
7591: PUSH
7592: LD_INT 1
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PPUSH
7599: CALL_OW 70
7603: IFFALSE 7617
// begin area := i ;
7605: LD_ADDR_VAR 0 5
7609: PUSH
7610: LD_VAR 0 1
7614: ST_TO_ADDR
// break ;
7615: GO 7619
// end ;
7617: GO 7581
7619: POP
7620: POP
// if area then
7621: LD_VAR 0 5
7625: IFFALSE 7778
// begin for i in tmp do
7627: LD_ADDR_VAR 0 1
7631: PUSH
7632: LD_VAR 0 2
7636: PUSH
7637: FOR_IN
7638: IFFALSE 7776
// begin if GetFuel ( i ) < 33 then
7640: LD_VAR 0 1
7644: PPUSH
7645: CALL_OW 261
7649: PUSH
7650: LD_INT 33
7652: LESS
7653: IFFALSE 7667
// SetFuel ( i , 33 ) ;
7655: LD_VAR 0 1
7659: PPUSH
7660: LD_INT 33
7662: PPUSH
7663: CALL_OW 240
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
7667: LD_VAR 0 1
7671: PPUSH
7672: LD_INT 22
7674: PUSH
7675: LD_INT 1
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PPUSH
7682: CALL_OW 69
7686: PPUSH
7687: LD_VAR 0 1
7691: PPUSH
7692: CALL_OW 74
7696: PPUSH
7697: CALL_OW 296
7701: PUSH
7702: LD_INT 10
7704: LESS
7705: IFFALSE 7743
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7707: LD_VAR 0 1
7711: PPUSH
7712: LD_INT 22
7714: PUSH
7715: LD_INT 1
7717: PUSH
7718: EMPTY
7719: LIST
7720: LIST
7721: PPUSH
7722: CALL_OW 69
7726: PPUSH
7727: LD_VAR 0 1
7731: PPUSH
7732: CALL_OW 74
7736: PPUSH
7737: CALL_OW 115
7741: GO 7774
// if not IsInArea ( i , area ) then
7743: LD_VAR 0 1
7747: PPUSH
7748: LD_VAR 0 5
7752: PPUSH
7753: CALL_OW 308
7757: NOT
7758: IFFALSE 7774
// ComMoveToArea ( i , area ) ;
7760: LD_VAR 0 1
7764: PPUSH
7765: LD_VAR 0 5
7769: PPUSH
7770: CALL_OW 113
// end ;
7774: GO 7637
7776: POP
7777: POP
// end ; end ;
7778: PPOPN 5
7780: END
// every 10 10$00 do var i , j , un , veh , time , count ;
7781: GO 7783
7783: DISABLE
7784: LD_INT 0
7786: PPUSH
7787: PPUSH
7788: PPUSH
7789: PPUSH
7790: PPUSH
7791: PPUSH
// begin uc_side := 3 ;
7792: LD_ADDR_OWVAR 20
7796: PUSH
7797: LD_INT 3
7799: ST_TO_ADDR
// uc_nation := 3 ;
7800: LD_ADDR_OWVAR 21
7804: PUSH
7805: LD_INT 3
7807: ST_TO_ADDR
// time := [ 8 8$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
7808: LD_ADDR_VAR 0 5
7812: PUSH
7813: LD_INT 16800
7815: PUSH
7816: LD_INT 14700
7818: PUSH
7819: LD_INT 12600
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: LIST
7826: PUSH
7827: LD_OWVAR 67
7831: ARRAY
7832: ST_TO_ADDR
// count := [ 2 , 2 , 3 ] [ Difficulty ] ;
7833: LD_ADDR_VAR 0 6
7837: PUSH
7838: LD_INT 2
7840: PUSH
7841: LD_INT 2
7843: PUSH
7844: LD_INT 3
7846: PUSH
7847: EMPTY
7848: LIST
7849: LIST
7850: LIST
7851: PUSH
7852: LD_OWVAR 67
7856: ARRAY
7857: ST_TO_ADDR
// for i = 1 to count do
7858: LD_ADDR_VAR 0 1
7862: PUSH
7863: DOUBLE
7864: LD_INT 1
7866: DEC
7867: ST_TO_ADDR
7868: LD_VAR 0 6
7872: PUSH
7873: FOR_TO
7874: IFFALSE 8054
// begin wait ( time ) ;
7876: LD_VAR 0 5
7880: PPUSH
7881: CALL_OW 67
// for j = 1 to rand ( 1 , Difficulty ) do
7885: LD_ADDR_VAR 0 2
7889: PUSH
7890: DOUBLE
7891: LD_INT 1
7893: DEC
7894: ST_TO_ADDR
7895: LD_INT 1
7897: PPUSH
7898: LD_OWVAR 67
7902: PPUSH
7903: CALL_OW 12
7907: PUSH
7908: FOR_TO
7909: IFFALSE 8050
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 80 ) ;
7911: LD_ADDR_VAR 0 4
7915: PUSH
7916: LD_INT 3
7918: PPUSH
7919: LD_INT 3
7921: PPUSH
7922: LD_INT 22
7924: PPUSH
7925: LD_INT 1
7927: PPUSH
7928: LD_INT 1
7930: PPUSH
7931: LD_INT 43
7933: PUSH
7934: LD_INT 44
7936: PUSH
7937: LD_INT 42
7939: PUSH
7940: EMPTY
7941: LIST
7942: LIST
7943: LIST
7944: PUSH
7945: LD_VAR 0 1
7949: PUSH
7950: LD_INT 3
7952: MOD
7953: PUSH
7954: LD_INT 1
7956: PLUS
7957: ARRAY
7958: PPUSH
7959: LD_INT 80
7961: PPUSH
7962: CALL 417 0 7
7966: ST_TO_ADDR
// PlaceUnitArea ( veh , southArea , false ) ;
7967: LD_VAR 0 4
7971: PPUSH
7972: LD_INT 13
7974: PPUSH
7975: LD_INT 0
7977: PPUSH
7978: CALL_OW 49
// PrepareHuman ( false , 3 , [ 4 , 5 , 5 ] [ Difficulty ] ) ;
7982: LD_INT 0
7984: PPUSH
7985: LD_INT 3
7987: PPUSH
7988: LD_INT 4
7990: PUSH
7991: LD_INT 5
7993: PUSH
7994: LD_INT 5
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: LIST
8001: PUSH
8002: LD_OWVAR 67
8006: ARRAY
8007: PPUSH
8008: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
8012: CALL_OW 44
8016: PPUSH
8017: LD_VAR 0 4
8021: PPUSH
8022: CALL_OW 52
// wait ( 0 0$01 ) ;
8026: LD_INT 35
8028: PPUSH
8029: CALL_OW 67
// ComMoveXY ( veh , 143 , 143 ) ;
8033: LD_VAR 0 4
8037: PPUSH
8038: LD_INT 143
8040: PPUSH
8041: LD_INT 143
8043: PPUSH
8044: CALL_OW 111
// end ;
8048: GO 7908
8050: POP
8051: POP
// end ;
8052: GO 7873
8054: POP
8055: POP
// end ;
8056: PPOPN 6
8058: END
// every 8 8$00 do var i , un , time ;
8059: GO 8061
8061: DISABLE
8062: LD_INT 0
8064: PPUSH
8065: PPUSH
8066: PPUSH
// begin time := [ 2 2$00 , 1 1$00 , 0 0$30 ] ;
8067: LD_ADDR_VAR 0 3
8071: PUSH
8072: LD_INT 4200
8074: PUSH
8075: LD_INT 2100
8077: PUSH
8078: LD_INT 1050
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: LIST
8085: ST_TO_ADDR
// wait ( time ) ;
8086: LD_VAR 0 3
8090: PPUSH
8091: CALL_OW 67
// uc_side := 3 ;
8095: LD_ADDR_OWVAR 20
8099: PUSH
8100: LD_INT 3
8102: ST_TO_ADDR
// uc_nation := 3 ;
8103: LD_ADDR_OWVAR 21
8107: PUSH
8108: LD_INT 3
8110: ST_TO_ADDR
// for i = 1 to 2 do
8111: LD_ADDR_VAR 0 1
8115: PUSH
8116: DOUBLE
8117: LD_INT 1
8119: DEC
8120: ST_TO_ADDR
8121: LD_INT 2
8123: PUSH
8124: FOR_TO
8125: IFFALSE 8188
// begin PrepareHuman ( false , 1 , 4 ) ;
8127: LD_INT 0
8129: PPUSH
8130: LD_INT 1
8132: PPUSH
8133: LD_INT 4
8135: PPUSH
8136: CALL_OW 380
// un := CreateHuman ;
8140: LD_ADDR_VAR 0 2
8144: PUSH
8145: CALL_OW 44
8149: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_dep_main ) ;
8150: LD_VAR 0 2
8154: PPUSH
8155: LD_INT 16
8157: PPUSH
8158: CALL_OW 52
// ComExitBuilding ( un ) ;
8162: LD_VAR 0 2
8166: PPUSH
8167: CALL_OW 122
// AddComAgressiveMove ( un , 41 , 76 ) ;
8171: LD_VAR 0 2
8175: PPUSH
8176: LD_INT 41
8178: PPUSH
8179: LD_INT 76
8181: PPUSH
8182: CALL_OW 174
// end ;
8186: GO 8124
8188: POP
8189: POP
// end ; end_of_file
8190: PPOPN 3
8192: END
// export function Action ; begin
8193: LD_INT 0
8195: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
8196: LD_INT 28
8198: PPUSH
8199: LD_INT 3
8201: PPUSH
8202: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
8206: LD_INT 41
8208: PPUSH
8209: LD_INT 76
8211: PPUSH
8212: LD_INT 1
8214: PPUSH
8215: LD_INT 10
8217: PPUSH
8218: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
8222: LD_INT 41
8224: PPUSH
8225: LD_INT 76
8227: PPUSH
8228: LD_INT 1
8230: PPUSH
8231: CALL_OW 331
// InGameOn ;
8235: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
8239: LD_EXP 18
8243: PPUSH
8244: LD_STRING D2-Har-1
8246: PPUSH
8247: CALL_OW 94
// InGameOff ;
8251: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
8255: LD_STRING M1
8257: PPUSH
8258: CALL_OW 337
// end ;
8262: LD_VAR 0 1
8266: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
8267: LD_EXP 4
8271: PUSH
8272: LD_INT 1
8274: GREATER
8275: IFFALSE 8366
8277: GO 8279
8279: DISABLE
8280: LD_INT 0
8282: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
8283: LD_ADDR_VAR 0 1
8287: PUSH
8288: LD_INT 1
8290: PPUSH
8291: CALL 505 0 1
8295: PUSH
8296: LD_INT 1
8298: ARRAY
8299: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
8300: LD_VAR 0 1
8304: PPUSH
8305: LD_STRING D2a-Sol1-1
8307: PPUSH
8308: CALL_OW 88
// if not un then
8312: LD_VAR 0 1
8316: NOT
8317: IFFALSE 8348
// begin un := GetRandom ( sex_female ) [ 1 ] ;
8319: LD_ADDR_VAR 0 1
8323: PUSH
8324: LD_INT 2
8326: PPUSH
8327: CALL 505 0 1
8331: PUSH
8332: LD_INT 1
8334: ARRAY
8335: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
8336: LD_VAR 0 1
8340: PPUSH
8341: LD_STRING D2a-FSol1-1
8343: PPUSH
8344: CALL_OW 88
// end ; if Khatam then
8348: LD_EXP 16
8352: IFFALSE 8366
// Say ( Khatam , D3b-Khat-3 ) ;
8354: LD_EXP 16
8358: PPUSH
8359: LD_STRING D3b-Khat-3
8361: PPUSH
8362: CALL_OW 88
// end ;
8366: PPOPN 1
8368: END
// every 0 0$1 trigger Frank and not Kikuchi and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Frank ) , GetY ( Frank ) , 7 ] ] ) and not InBattle ( 1 ) do var i , ape ;
8369: LD_EXP 14
8373: PUSH
8374: LD_EXP 17
8378: NOT
8379: AND
8380: PUSH
8381: LD_INT 22
8383: PUSH
8384: LD_INT 1
8386: PUSH
8387: EMPTY
8388: LIST
8389: LIST
8390: PUSH
8391: LD_INT 92
8393: PUSH
8394: LD_EXP 14
8398: PPUSH
8399: CALL_OW 250
8403: PUSH
8404: LD_EXP 14
8408: PPUSH
8409: CALL_OW 251
8413: PUSH
8414: LD_INT 7
8416: PUSH
8417: EMPTY
8418: LIST
8419: LIST
8420: LIST
8421: LIST
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: PPUSH
8427: CALL_OW 69
8431: AND
8432: PUSH
8433: LD_INT 1
8435: PPUSH
8436: CALL_OW 463
8440: NOT
8441: AND
8442: IFFALSE 9029
8444: GO 8446
8446: DISABLE
8447: LD_INT 0
8449: PPUSH
8450: PPUSH
// begin InGameOn ;
8451: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
8455: LD_ADDR_VAR 0 2
8459: PUSH
8460: LD_INT 22
8462: PUSH
8463: LD_INT 0
8465: PUSH
8466: EMPTY
8467: LIST
8468: LIST
8469: PUSH
8470: LD_INT 25
8472: PUSH
8473: LD_INT 12
8475: PUSH
8476: EMPTY
8477: LIST
8478: LIST
8479: PUSH
8480: EMPTY
8481: LIST
8482: LIST
8483: PPUSH
8484: CALL_OW 69
8488: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
8489: LD_ADDR_VAR 0 2
8493: PUSH
8494: LD_VAR 0 2
8498: PPUSH
8499: LD_EXP 14
8503: PPUSH
8504: CALL_OW 74
8508: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
8509: LD_ADDR_VAR 0 1
8513: PUSH
8514: LD_INT 22
8516: PUSH
8517: LD_INT 1
8519: PUSH
8520: EMPTY
8521: LIST
8522: LIST
8523: PUSH
8524: LD_INT 21
8526: PUSH
8527: LD_INT 1
8529: PUSH
8530: EMPTY
8531: LIST
8532: LIST
8533: PUSH
8534: LD_INT 91
8536: PUSH
8537: LD_EXP 14
8541: PUSH
8542: LD_INT 20
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: LIST
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: LIST
8554: PPUSH
8555: CALL_OW 69
8559: PUSH
8560: FOR_IN
8561: IFFALSE 8579
// ComTurnUnit ( i , Frank ) ;
8563: LD_VAR 0 1
8567: PPUSH
8568: LD_EXP 14
8572: PPUSH
8573: CALL_OW 119
8577: GO 8560
8579: POP
8580: POP
// SetSide ( Frank , 1 ) ;
8581: LD_EXP 14
8585: PPUSH
8586: LD_INT 1
8588: PPUSH
8589: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
8593: LD_EXP 8
8597: PPUSH
8598: LD_EXP 14
8602: PPUSH
8603: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
8607: LD_EXP 8
8611: PPUSH
8612: LD_EXP 14
8616: PPUSH
8617: CALL_OW 179
// CenterOnUnits ( Frank ) ;
8621: LD_EXP 14
8625: PPUSH
8626: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
8630: LD_EXP 14
8634: PPUSH
8635: LD_STRING D3a-Frank-1
8637: PPUSH
8638: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
8642: LD_VAR 0 2
8646: PPUSH
8647: LD_INT 42
8649: PPUSH
8650: LD_INT 78
8652: PPUSH
8653: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
8657: LD_VAR 0 2
8661: PPUSH
8662: LD_EXP 14
8666: PPUSH
8667: CALL_OW 179
// if Lisa then
8671: LD_EXP 13
8675: IFFALSE 8689
// Say ( Lisa , D3a-Lisa-1 ) ;
8677: LD_EXP 13
8681: PPUSH
8682: LD_STRING D3a-Lisa-1
8684: PPUSH
8685: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
8689: LD_EXP 8
8693: PPUSH
8694: LD_STRING D3a-JMM-1
8696: PPUSH
8697: CALL_OW 88
// if Cyrus then
8701: LD_EXP 12
8705: IFFALSE 8719
// Say ( Cyrus , D3a-Cyrus-1 ) ;
8707: LD_EXP 12
8711: PPUSH
8712: LD_STRING D3a-Cyrus-1
8714: PPUSH
8715: CALL_OW 88
// if GetRandom ( sex_male ) then
8719: LD_INT 1
8721: PPUSH
8722: CALL 505 0 1
8726: IFFALSE 8747
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
8728: LD_INT 1
8730: PPUSH
8731: CALL 505 0 1
8735: PUSH
8736: LD_INT 1
8738: ARRAY
8739: PPUSH
8740: LD_STRING D3a-Sol1-1
8742: PPUSH
8743: CALL_OW 88
// if GetRandom ( sex_female ) then
8747: LD_INT 2
8749: PPUSH
8750: CALL 505 0 1
8754: IFFALSE 8775
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
8756: LD_INT 2
8758: PPUSH
8759: CALL 505 0 1
8763: PUSH
8764: LD_INT 1
8766: ARRAY
8767: PPUSH
8768: LD_STRING D3a-FSol1-1
8770: PPUSH
8771: CALL_OW 88
// if Gladstone then
8775: LD_EXP 15
8779: IFFALSE 8793
// Say ( Gladstone , D3a-Glad-1 ) ;
8781: LD_EXP 15
8785: PPUSH
8786: LD_STRING D3a-Glad-1
8788: PPUSH
8789: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
8793: LD_VAR 0 2
8797: PPUSH
8798: LD_INT 60
8800: PPUSH
8801: LD_INT 113
8803: PPUSH
8804: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
8808: LD_EXP 14
8812: PPUSH
8813: LD_STRING D3a-Frank-2
8815: PPUSH
8816: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
8820: LD_EXP 14
8824: PPUSH
8825: LD_EXP 8
8829: PPUSH
8830: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
8834: LD_EXP 8
8838: PPUSH
8839: LD_STRING D3a-JMM-2
8841: PPUSH
8842: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
8846: LD_INT 1
8848: PPUSH
8849: LD_INT 4
8851: PPUSH
8852: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
8856: LD_INT 85
8858: PPUSH
8859: LD_INT 134
8861: PPUSH
8862: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
8866: LD_EXP 14
8870: PPUSH
8871: LD_STRING D3a-Frank-3
8873: PPUSH
8874: CALL_OW 88
// Wait ( 0 0$01 ) ;
8878: LD_INT 35
8880: PPUSH
8881: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
8885: LD_INT 166
8887: PPUSH
8888: LD_INT 136
8890: PPUSH
8891: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
8895: LD_EXP 8
8899: PPUSH
8900: LD_STRING D3a-JMM-3
8902: PPUSH
8903: CALL_OW 88
// Wait ( 0 0$01 ) ;
8907: LD_INT 35
8909: PPUSH
8910: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
8914: LD_EXP 14
8918: PPUSH
8919: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
8923: LD_EXP 14
8927: PPUSH
8928: LD_STRING D3a-Frank-4
8930: PPUSH
8931: CALL_OW 88
// if Lisa then
8935: LD_EXP 13
8939: IFFALSE 8953
// Say ( Lisa , D3a-Lisa-4 ) ;
8941: LD_EXP 13
8945: PPUSH
8946: LD_STRING D3a-Lisa-4
8948: PPUSH
8949: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
8953: LD_EXP 8
8957: PPUSH
8958: LD_STRING D3a-JMM-4
8960: PPUSH
8961: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
8965: LD_EXP 14
8969: PPUSH
8970: LD_STRING D3a-Frank-5
8972: PPUSH
8973: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
8977: LD_EXP 8
8981: PPUSH
8982: LD_STRING D3a-JMM-5
8984: PPUSH
8985: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
8989: LD_EXP 14
8993: PPUSH
8994: LD_STRING D3a-Frank-6
8996: PPUSH
8997: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
9001: LD_EXP 8
9005: PPUSH
9006: LD_STRING D3a-JMM-6
9008: PPUSH
9009: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
9013: LD_EXP 14
9017: PPUSH
9018: LD_STRING D3a-Frank-7
9020: PPUSH
9021: CALL_OW 88
// InGameOff ;
9025: CALL_OW 9
// end ;
9029: PPOPN 2
9031: END
// every 0 0$1 trigger Kikuchi and not Frank and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Kikuchi ) , GetY ( Kikuchi ) , 7 ] ] ) and not InBattle ( 1 ) do
9032: LD_EXP 17
9036: PUSH
9037: LD_EXP 14
9041: NOT
9042: AND
9043: PUSH
9044: LD_INT 22
9046: PUSH
9047: LD_INT 1
9049: PUSH
9050: EMPTY
9051: LIST
9052: LIST
9053: PUSH
9054: LD_INT 92
9056: PUSH
9057: LD_EXP 17
9061: PPUSH
9062: CALL_OW 250
9066: PUSH
9067: LD_EXP 17
9071: PPUSH
9072: CALL_OW 251
9076: PUSH
9077: LD_INT 7
9079: PUSH
9080: EMPTY
9081: LIST
9082: LIST
9083: LIST
9084: LIST
9085: PUSH
9086: EMPTY
9087: LIST
9088: LIST
9089: PPUSH
9090: CALL_OW 69
9094: AND
9095: PUSH
9096: LD_INT 1
9098: PPUSH
9099: CALL_OW 463
9103: NOT
9104: AND
9105: IFFALSE 9285
9107: GO 9109
9109: DISABLE
// begin InGameOn ;
9110: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
9114: LD_EXP 8
9118: PPUSH
9119: LD_EXP 17
9123: PPUSH
9124: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
9128: LD_EXP 17
9132: PPUSH
9133: LD_EXP 8
9137: PPUSH
9138: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
9142: LD_EXP 17
9146: PPUSH
9147: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
9151: LD_EXP 17
9155: PPUSH
9156: LD_STRING D3b-Yam-1
9158: PPUSH
9159: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
9163: LD_EXP 8
9167: PPUSH
9168: LD_STRING D3b-JMM-1
9170: PPUSH
9171: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
9175: LD_INT 1
9177: PPUSH
9178: LD_INT 4
9180: PPUSH
9181: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
9185: LD_INT 85
9187: PPUSH
9188: LD_INT 134
9190: PPUSH
9191: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
9195: LD_EXP 17
9199: PPUSH
9200: LD_STRING D3b-Yam-2
9202: PPUSH
9203: CALL_OW 88
// Wait ( 0 0$01 ) ;
9207: LD_INT 35
9209: PPUSH
9210: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
9214: LD_EXP 8
9218: PPUSH
9219: LD_STRING D3b-JMM-2
9221: PPUSH
9222: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
9226: LD_INT 166
9228: PPUSH
9229: LD_INT 136
9231: PPUSH
9232: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
9236: LD_EXP 17
9240: PPUSH
9241: LD_STRING D3b-Yam-3
9243: PPUSH
9244: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
9248: LD_EXP 8
9252: PPUSH
9253: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
9257: LD_EXP 8
9261: PPUSH
9262: LD_STRING D3b-JMM-3a
9264: PPUSH
9265: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
9269: LD_EXP 17
9273: PPUSH
9274: LD_INT 1
9276: PPUSH
9277: CALL_OW 235
// InGameOff ;
9281: CALL_OW 9
// end ;
9285: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , i ;
9286: LD_INT 7
9288: PPUSH
9289: LD_INT 22
9291: PUSH
9292: LD_INT 1
9294: PUSH
9295: EMPTY
9296: LIST
9297: LIST
9298: PUSH
9299: LD_INT 3
9301: PUSH
9302: LD_INT 24
9304: PUSH
9305: LD_INT 1000
9307: PUSH
9308: EMPTY
9309: LIST
9310: LIST
9311: PUSH
9312: EMPTY
9313: LIST
9314: LIST
9315: PUSH
9316: EMPTY
9317: LIST
9318: LIST
9319: PPUSH
9320: CALL_OW 70
9324: IFFALSE 9742
9326: GO 9328
9328: DISABLE
9329: LD_INT 0
9331: PPUSH
9332: PPUSH
9333: PPUSH
// begin un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) [ 1 ] ;
9334: LD_ADDR_VAR 0 1
9338: PUSH
9339: LD_INT 7
9341: PPUSH
9342: LD_INT 22
9344: PUSH
9345: LD_INT 1
9347: PUSH
9348: EMPTY
9349: LIST
9350: LIST
9351: PUSH
9352: LD_INT 3
9354: PUSH
9355: LD_INT 24
9357: PUSH
9358: LD_INT 1000
9360: PUSH
9361: EMPTY
9362: LIST
9363: LIST
9364: PUSH
9365: EMPTY
9366: LIST
9367: LIST
9368: PUSH
9369: EMPTY
9370: LIST
9371: LIST
9372: PPUSH
9373: CALL_OW 70
9377: PUSH
9378: LD_INT 1
9380: ARRAY
9381: ST_TO_ADDR
// DialogueOn ;
9382: CALL_OW 6
// CenterNowOnUnits ( un ) ;
9386: LD_VAR 0 1
9390: PPUSH
9391: CALL_OW 87
// if Lisa then
9395: LD_EXP 13
9399: IFFALSE 9427
// begin Say ( Lisa , D5-Lisa-1 ) ;
9401: LD_EXP 13
9405: PPUSH
9406: LD_STRING D5-Lisa-1
9408: PPUSH
9409: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
9413: LD_EXP 8
9417: PPUSH
9418: LD_STRING D5-JMM-1a
9420: PPUSH
9421: CALL_OW 88
// end else
9425: GO 9439
// Say ( JMM , D5-JMM-1 ) ;
9427: LD_EXP 8
9431: PPUSH
9432: LD_STRING D5-JMM-1
9434: PPUSH
9435: CALL_OW 88
// DialogueOff ;
9439: CALL_OW 7
// while ( true ) do
9443: LD_INT 1
9445: IFFALSE 9501
// begin wait ( 0 0$01 ) ;
9447: LD_INT 35
9449: PPUSH
9450: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
9454: LD_ADDR_VAR 0 2
9458: PUSH
9459: LD_INT 8
9461: PPUSH
9462: LD_INT 30
9464: PUSH
9465: LD_INT 26
9467: PUSH
9468: EMPTY
9469: LIST
9470: LIST
9471: PUSH
9472: LD_INT 101
9474: PUSH
9475: LD_INT 1
9477: PUSH
9478: EMPTY
9479: LIST
9480: LIST
9481: PUSH
9482: EMPTY
9483: LIST
9484: LIST
9485: PPUSH
9486: CALL_OW 71
9490: ST_TO_ADDR
// if x then
9491: LD_VAR 0 2
9495: IFFALSE 9499
// break ;
9497: GO 9501
// end ;
9499: GO 9443
// CenterOnUnits ( x [ 1 ] ) ;
9501: LD_VAR 0 2
9505: PUSH
9506: LD_INT 1
9508: ARRAY
9509: PPUSH
9510: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
9514: LD_EXP 14
9518: PUSH
9519: LD_EXP 14
9523: PPUSH
9524: CALL_OW 255
9528: PUSH
9529: LD_INT 1
9531: EQUAL
9532: AND
9533: IFFALSE 9549
// Say ( Frank , D5a-Frank-1 ) else
9535: LD_EXP 14
9539: PPUSH
9540: LD_STRING D5a-Frank-1
9542: PPUSH
9543: CALL_OW 88
9547: GO 9603
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
9549: LD_EXP 17
9553: PUSH
9554: LD_EXP 17
9558: PPUSH
9559: CALL_OW 255
9563: PUSH
9564: LD_INT 1
9566: EQUAL
9567: AND
9568: IFFALSE 9584
// Say ( Kikuchi , D5a-Yam-1 ) else
9570: LD_EXP 17
9574: PPUSH
9575: LD_STRING D5a-Yam-1
9577: PPUSH
9578: CALL_OW 88
9582: GO 9603
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
9584: LD_INT 1
9586: PPUSH
9587: CALL 505 0 1
9591: PUSH
9592: LD_INT 1
9594: ARRAY
9595: PPUSH
9596: LD_STRING D5a-Sol1-1
9598: PPUSH
9599: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
9603: LD_EXP 8
9607: PPUSH
9608: LD_STRING D5a-JMM-1
9610: PPUSH
9611: CALL_OW 88
// if Cyrus then
9615: LD_EXP 12
9619: IFFALSE 9633
// Say ( Cyrus , D5a-Cyrus-1 ) ;
9621: LD_EXP 12
9625: PPUSH
9626: LD_STRING D5a-Cyrus-1
9628: PPUSH
9629: CALL_OW 88
// x := false ;
9633: LD_ADDR_VAR 0 2
9637: PUSH
9638: LD_INT 0
9640: ST_TO_ADDR
// while ( true ) do
9641: LD_INT 1
9643: IFFALSE 9730
// begin wait ( 0 0$01 ) ;
9645: LD_INT 35
9647: PPUSH
9648: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
9652: LD_ADDR_VAR 0 3
9656: PUSH
9657: LD_INT 2
9659: PUSH
9660: LD_INT 30
9662: PUSH
9663: LD_INT 0
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: PUSH
9670: LD_INT 30
9672: PUSH
9673: LD_INT 1
9675: PUSH
9676: EMPTY
9677: LIST
9678: LIST
9679: PUSH
9680: EMPTY
9681: LIST
9682: LIST
9683: LIST
9684: PPUSH
9685: CALL_OW 69
9689: PUSH
9690: LD_INT 1
9692: DIFF
9693: PUSH
9694: FOR_IN
9695: IFFALSE 9718
// if BaseNeedEnergy ( i ) then
9697: LD_VAR 0 3
9701: PPUSH
9702: CALL 2527 0 1
9706: IFFALSE 9716
// x := true ;
9708: LD_ADDR_VAR 0 2
9712: PUSH
9713: LD_INT 1
9715: ST_TO_ADDR
9716: GO 9694
9718: POP
9719: POP
// if x then
9720: LD_VAR 0 2
9724: IFFALSE 9728
// break ;
9726: GO 9730
// end ;
9728: GO 9641
// Say ( JMM , D5b-JMM-1 ) ;
9730: LD_EXP 8
9734: PPUSH
9735: LD_STRING D5b-JMM-1
9737: PPUSH
9738: CALL_OW 88
// end ;
9742: PPOPN 3
9744: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
9745: LD_EXP 5
9749: PUSH
9750: LD_INT 1
9752: ARRAY
9753: PUSH
9754: LD_OWVAR 1
9758: LESS
9759: IFFALSE 9959
9761: GO 9763
9763: DISABLE
// begin if not IsDead ( ru_dep_main ) then
9764: LD_INT 16
9766: PPUSH
9767: CALL_OW 301
9771: NOT
9772: IFFALSE 9795
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
9774: LD_EXP 18
9778: PPUSH
9779: LD_STRING D3b-Har-3
9781: PPUSH
9782: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
9786: LD_STRING M2a
9788: PPUSH
9789: CALL_OW 337
// end else
9793: GO 9814
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
9795: LD_EXP 18
9799: PPUSH
9800: LD_STRING D3b-Har-3a
9802: PPUSH
9803: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
9807: LD_STRING M2
9809: PPUSH
9810: CALL_OW 337
// end ; can_end := true ;
9814: LD_ADDR_EXP 6
9818: PUSH
9819: LD_INT 1
9821: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
9822: LD_INT 9
9824: PPUSH
9825: LD_INT 1
9827: PPUSH
9828: CALL_OW 424
// Wait ( 0 0$02 ) ;
9832: LD_INT 70
9834: PPUSH
9835: CALL_OW 67
// if Lisa then
9839: LD_EXP 13
9843: IFFALSE 9857
// Say ( Lisa , D3b-Lisa ) ;
9845: LD_EXP 13
9849: PPUSH
9850: LD_STRING D3b-Lisa
9852: PPUSH
9853: CALL_OW 88
// if Bobby then
9857: LD_EXP 11
9861: IFFALSE 9875
// Say ( Bobby , D3b-Bobby-3 ) ;
9863: LD_EXP 11
9867: PPUSH
9868: LD_STRING D3b-Bobby-3
9870: PPUSH
9871: CALL_OW 88
// if Cyrus then
9875: LD_EXP 12
9879: IFFALSE 9893
// Say ( Cyrus , D3b-Cyrus-3 ) ;
9881: LD_EXP 12
9885: PPUSH
9886: LD_STRING D3b-Cyrus-3
9888: PPUSH
9889: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
9893: LD_EXP 14
9897: PUSH
9898: LD_EXP 14
9902: PPUSH
9903: CALL_OW 255
9907: PUSH
9908: LD_INT 1
9910: EQUAL
9911: AND
9912: IFFALSE 9926
// Say ( Frank , D3b-Frank-3 ) ;
9914: LD_EXP 14
9918: PPUSH
9919: LD_STRING D3b-Frank-3
9921: PPUSH
9922: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
9926: LD_EXP 17
9930: PUSH
9931: LD_EXP 17
9935: PPUSH
9936: CALL_OW 255
9940: PUSH
9941: LD_INT 1
9943: EQUAL
9944: AND
9945: IFFALSE 9959
// Say ( Kikuchi , D3b-Yam-4 ) ;
9947: LD_EXP 17
9951: PPUSH
9952: LD_STRING D3b-Yam-4
9954: PPUSH
9955: CALL_OW 88
// end ;
9959: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
9960: LD_EXP 5
9964: PUSH
9965: LD_INT 2
9967: ARRAY
9968: PUSH
9969: LD_OWVAR 1
9973: LESS
9974: IFFALSE 10006
9976: GO 9978
9978: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
9979: LD_EXP 18
9983: PPUSH
9984: LD_STRING D4-Har-1
9986: PPUSH
9987: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
9991: LD_STRING M3
9993: PPUSH
9994: CALL_OW 337
// must_end := true ;
9998: LD_ADDR_EXP 7
10002: PUSH
10003: LD_INT 1
10005: ST_TO_ADDR
// end ;
10006: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
10007: LD_EXP 5
10011: PUSH
10012: LD_INT 3
10014: ARRAY
10015: PUSH
10016: LD_OWVAR 1
10020: LESS
10021: IFFALSE 10052
10023: GO 10025
10025: DISABLE
// begin if not IsDead ( ru_dep_main ) then
10026: LD_INT 16
10028: PPUSH
10029: CALL_OW 301
10033: NOT
10034: IFFALSE 10045
// YouLost ( TimeOut1 ) else
10036: LD_STRING TimeOut1
10038: PPUSH
10039: CALL_OW 104
10043: GO 10052
// YouLost ( TimeOut2 ) ;
10045: LD_STRING TimeOut2
10047: PPUSH
10048: CALL_OW 104
// end ;
10052: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , i , tmp ;
10053: LD_EXP 8
10057: PPUSH
10058: LD_INT 9
10060: PPUSH
10061: CALL_OW 308
10065: PUSH
10066: LD_EXP 6
10070: AND
10071: IFFALSE 11065
10073: GO 10075
10075: DISABLE
10076: LD_INT 0
10078: PPUSH
10079: PPUSH
10080: PPUSH
// begin wait_on := false ;
10081: LD_ADDR_VAR 0 1
10085: PUSH
10086: LD_INT 0
10088: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
10089: LD_INT 1
10091: PPUSH
10092: CALL 2604 0 1
10096: PUSH
10097: LD_INT 0
10099: PLUS
10100: PUSH
10101: LD_INT 1
10103: PPUSH
10104: LD_INT 9
10106: PPUSH
10107: CALL 2695 0 2
10111: PUSH
10112: LD_INT 1
10114: PPUSH
10115: LD_INT 9
10117: PPUSH
10118: CALL 2742 0 2
10122: ADD
10123: PUSH
10124: LD_INT 0
10126: PLUS
10127: GREATER
10128: IFFALSE 10177
// case Query ( Q1 ) of 1 :
10130: LD_STRING Q1
10132: PPUSH
10133: CALL_OW 97
10137: PUSH
10138: LD_INT 1
10140: DOUBLE
10141: EQUAL
10142: IFTRUE 10146
10144: GO 10157
10146: POP
// wait_on := true ; 2 :
10147: LD_ADDR_VAR 0 1
10151: PUSH
10152: LD_INT 1
10154: ST_TO_ADDR
10155: GO 10177
10157: LD_INT 2
10159: DOUBLE
10160: EQUAL
10161: IFTRUE 10165
10163: GO 10176
10165: POP
// wait_on := false ; end ;
10166: LD_ADDR_VAR 0 1
10170: PUSH
10171: LD_INT 0
10173: ST_TO_ADDR
10174: GO 10177
10176: POP
// repeat wait ( 0 0$01 ) ;
10177: LD_INT 35
10179: PPUSH
10180: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
10184: LD_VAR 0 1
10188: NOT
10189: PUSH
10190: LD_INT 1
10192: PPUSH
10193: CALL 2604 0 1
10197: PUSH
10198: LD_INT 0
10200: PLUS
10201: PUSH
10202: LD_INT 1
10204: PPUSH
10205: LD_INT 9
10207: PPUSH
10208: CALL 2695 0 2
10212: PUSH
10213: LD_INT 1
10215: PPUSH
10216: LD_INT 9
10218: PPUSH
10219: CALL 2742 0 2
10223: ADD
10224: PUSH
10225: LD_INT 0
10227: PLUS
10228: EQUAL
10229: OR
10230: IFFALSE 10177
// DialogueOn ;
10232: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10236: LD_EXP 8
10240: PPUSH
10241: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
10245: LD_EXP 8
10249: PPUSH
10250: LD_STRING D6-JMM-1
10252: PPUSH
10253: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
10257: LD_EXP 18
10261: PPUSH
10262: LD_STRING D6-Har-1
10264: PPUSH
10265: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
10269: LD_EXP 8
10273: PPUSH
10274: LD_STRING D6-JMM-2
10276: PPUSH
10277: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
10281: LD_EXP 18
10285: PPUSH
10286: LD_STRING D6-Har-2
10288: PPUSH
10289: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
10293: LD_EXP 8
10297: PPUSH
10298: LD_STRING D6-JMM-3
10300: PPUSH
10301: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
10305: LD_EXP 18
10309: PPUSH
10310: LD_STRING D6-Har-3
10312: PPUSH
10313: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
10317: LD_EXP 8
10321: PPUSH
10322: LD_STRING D6-JMM-4
10324: PPUSH
10325: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
10329: LD_EXP 18
10333: PPUSH
10334: LD_STRING D6-Har-4
10336: PPUSH
10337: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
10341: LD_EXP 8
10345: PPUSH
10346: LD_STRING D6-JMM-5
10348: PPUSH
10349: CALL_OW 88
// DialogueOff ;
10353: CALL_OW 7
// tmp := FilterBuildings ( 3 ) ;
10357: LD_ADDR_VAR 0 3
10361: PUSH
10362: LD_INT 3
10364: PPUSH
10365: CALL 2873 0 1
10369: ST_TO_ADDR
// if tmp >= 35 then
10370: LD_VAR 0 3
10374: PUSH
10375: LD_INT 35
10377: GREATEREQUAL
10378: IFFALSE 10415
// begin AddMedal ( Destroy1 , - 1 ) ;
10380: LD_STRING Destroy1
10382: PPUSH
10383: LD_INT 1
10385: NEG
10386: PPUSH
10387: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
10391: LD_STRING Destroy2
10393: PPUSH
10394: LD_INT 1
10396: NEG
10397: PPUSH
10398: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
10402: LD_STRING Destroy3
10404: PPUSH
10405: LD_INT 1
10407: NEG
10408: PPUSH
10409: CALL_OW 101
// end else
10413: GO 10502
// begin AddMedal ( Destroy1 , 1 ) ;
10415: LD_STRING Destroy1
10417: PPUSH
10418: LD_INT 1
10420: PPUSH
10421: CALL_OW 101
// if tmp >= 25 then
10425: LD_VAR 0 3
10429: PUSH
10430: LD_INT 25
10432: GREATEREQUAL
10433: IFFALSE 10459
// begin AddMedal ( Destroy2 , - 1 ) ;
10435: LD_STRING Destroy2
10437: PPUSH
10438: LD_INT 1
10440: NEG
10441: PPUSH
10442: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
10446: LD_STRING Destroy3
10448: PPUSH
10449: LD_INT 1
10451: NEG
10452: PPUSH
10453: CALL_OW 101
// end else
10457: GO 10502
// begin AddMedal ( Destroy2 , 1 ) ;
10459: LD_STRING Destroy2
10461: PPUSH
10462: LD_INT 1
10464: PPUSH
10465: CALL_OW 101
// if tmp >= 15 then
10469: LD_VAR 0 3
10473: PUSH
10474: LD_INT 15
10476: GREATEREQUAL
10477: IFFALSE 10492
// AddMedal ( Destroy3 , - 1 ) else
10479: LD_STRING Destroy3
10481: PPUSH
10482: LD_INT 1
10484: NEG
10485: PPUSH
10486: CALL_OW 101
10490: GO 10502
// AddMedal ( Destroy3 , 1 ) ;
10492: LD_STRING Destroy3
10494: PPUSH
10495: LD_INT 1
10497: PPUSH
10498: CALL_OW 101
// end ; end ; GiveMedals ( MAIN ) ;
10502: LD_STRING MAIN
10504: PPUSH
10505: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ;
10509: LD_ADDR_VAR 0 3
10513: PUSH
10514: LD_INT 1
10516: PPUSH
10517: LD_INT 9
10519: PPUSH
10520: CALL 2695 0 2
10524: PUSH
10525: LD_INT 1
10527: PPUSH
10528: LD_INT 9
10530: PPUSH
10531: CALL 2742 0 2
10535: ADD
10536: ST_TO_ADDR
// RewardPeople ( tmp ) ;
10537: LD_VAR 0 3
10541: PPUSH
10542: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10546: LD_EXP 8
10550: PPUSH
10551: LD_EXP 3
10555: PUSH
10556: LD_STRING JMM
10558: STR
10559: PPUSH
10560: CALL_OW 38
// if Brown in tmp then
10564: LD_EXP 9
10568: PUSH
10569: LD_VAR 0 3
10573: IN
10574: IFFALSE 10594
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
10576: LD_EXP 9
10580: PPUSH
10581: LD_EXP 3
10585: PUSH
10586: LD_STRING Brown
10588: STR
10589: PPUSH
10590: CALL_OW 38
// if Donaldson in tmp then
10594: LD_EXP 10
10598: PUSH
10599: LD_VAR 0 3
10603: IN
10604: IFFALSE 10624
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
10606: LD_EXP 10
10610: PPUSH
10611: LD_EXP 3
10615: PUSH
10616: LD_STRING Donaldson
10618: STR
10619: PPUSH
10620: CALL_OW 38
// if Bobby in tmp then
10624: LD_EXP 11
10628: PUSH
10629: LD_VAR 0 3
10633: IN
10634: IFFALSE 10654
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10636: LD_EXP 11
10640: PPUSH
10641: LD_EXP 3
10645: PUSH
10646: LD_STRING Bobby
10648: STR
10649: PPUSH
10650: CALL_OW 38
// if Cyrus in tmp then
10654: LD_EXP 12
10658: PUSH
10659: LD_VAR 0 3
10663: IN
10664: IFFALSE 10684
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10666: LD_EXP 12
10670: PPUSH
10671: LD_EXP 3
10675: PUSH
10676: LD_STRING Cyrus
10678: STR
10679: PPUSH
10680: CALL_OW 38
// if Lisa in tmp then
10684: LD_EXP 13
10688: PUSH
10689: LD_VAR 0 3
10693: IN
10694: IFFALSE 10714
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
10696: LD_EXP 13
10700: PPUSH
10701: LD_EXP 3
10705: PUSH
10706: LD_STRING Lisa
10708: STR
10709: PPUSH
10710: CALL_OW 38
// if Frank in tmp then
10714: LD_EXP 14
10718: PUSH
10719: LD_VAR 0 3
10723: IN
10724: IFFALSE 10744
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
10726: LD_EXP 14
10730: PPUSH
10731: LD_EXP 3
10735: PUSH
10736: LD_STRING Frank
10738: STR
10739: PPUSH
10740: CALL_OW 38
// if Gladstone in tmp then
10744: LD_EXP 15
10748: PUSH
10749: LD_VAR 0 3
10753: IN
10754: IFFALSE 10774
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
10756: LD_EXP 15
10760: PPUSH
10761: LD_EXP 3
10765: PUSH
10766: LD_STRING Gladstone
10768: STR
10769: PPUSH
10770: CALL_OW 38
// if Khatam in tmp then
10774: LD_EXP 16
10778: PUSH
10779: LD_VAR 0 3
10783: IN
10784: IFFALSE 10804
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
10786: LD_EXP 16
10790: PPUSH
10791: LD_EXP 3
10795: PUSH
10796: LD_STRING Khatam
10798: STR
10799: PPUSH
10800: CALL_OW 38
// if Kikuchi in tmp then
10804: LD_EXP 17
10808: PUSH
10809: LD_VAR 0 3
10813: IN
10814: IFFALSE 10834
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
10816: LD_EXP 17
10820: PPUSH
10821: LD_EXP 3
10825: PUSH
10826: LD_STRING Kikuchi
10828: STR
10829: PPUSH
10830: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] , mission_prefix & others ) ;
10834: LD_VAR 0 3
10838: PUSH
10839: LD_EXP 8
10843: PUSH
10844: LD_EXP 9
10848: PUSH
10849: LD_EXP 10
10853: PUSH
10854: LD_EXP 11
10858: PUSH
10859: LD_EXP 12
10863: PUSH
10864: LD_EXP 13
10868: PUSH
10869: LD_EXP 14
10873: PUSH
10874: LD_EXP 15
10878: PUSH
10879: LD_EXP 17
10883: PUSH
10884: LD_EXP 16
10888: PUSH
10889: EMPTY
10890: LIST
10891: LIST
10892: LIST
10893: LIST
10894: LIST
10895: LIST
10896: LIST
10897: LIST
10898: LIST
10899: LIST
10900: DIFF
10901: PPUSH
10902: LD_EXP 3
10906: PUSH
10907: LD_STRING others
10909: STR
10910: PPUSH
10911: CALL_OW 38
// SaveVariable ( tick , 07_time ) ;
10915: LD_OWVAR 1
10919: PPUSH
10920: LD_STRING 07_time
10922: PPUSH
10923: CALL_OW 39
// tmp := [ ] ;
10927: LD_ADDR_VAR 0 3
10931: PUSH
10932: EMPTY
10933: ST_TO_ADDR
// for i in FilterUnitsInArea ( endArea , [ [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ] ) do
10934: LD_ADDR_VAR 0 2
10938: PUSH
10939: LD_INT 9
10941: PPUSH
10942: LD_INT 22
10944: PUSH
10945: LD_INT 1
10947: PUSH
10948: EMPTY
10949: LIST
10950: LIST
10951: PUSH
10952: LD_INT 23
10954: PUSH
10955: LD_INT 1
10957: PUSH
10958: EMPTY
10959: LIST
10960: LIST
10961: PUSH
10962: LD_INT 21
10964: PUSH
10965: LD_INT 2
10967: PUSH
10968: EMPTY
10969: LIST
10970: LIST
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: LIST
10976: PUSH
10977: EMPTY
10978: LIST
10979: PPUSH
10980: CALL_OW 70
10984: PUSH
10985: FOR_IN
10986: IFFALSE 11047
// tmp := tmp ^ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
10988: LD_ADDR_VAR 0 3
10992: PUSH
10993: LD_VAR 0 3
10997: PUSH
10998: LD_VAR 0 2
11002: PPUSH
11003: CALL_OW 265
11007: PUSH
11008: LD_VAR 0 2
11012: PPUSH
11013: CALL_OW 262
11017: PUSH
11018: LD_VAR 0 2
11022: PPUSH
11023: CALL_OW 263
11027: PUSH
11028: LD_VAR 0 2
11032: PPUSH
11033: CALL_OW 264
11037: PUSH
11038: EMPTY
11039: LIST
11040: LIST
11041: LIST
11042: LIST
11043: ADD
11044: ST_TO_ADDR
11045: GO 10985
11047: POP
11048: POP
// SaveVariable ( tmp , 07_vehicles ) ;
11049: LD_VAR 0 3
11053: PPUSH
11054: LD_STRING 07_vehicles
11056: PPUSH
11057: CALL_OW 39
// YouWin ;
11061: CALL_OW 103
// end ; end_of_file
11065: PPOPN 3
11067: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11068: LD_VAR 0 1
11072: PUSH
11073: LD_EXP 8
11077: EQUAL
11078: IFFALSE 11087
// YouLost ( JMM ) ;
11080: LD_STRING JMM
11082: PPUSH
11083: CALL_OW 104
// if GetType ( un ) = unit_building then
11087: LD_VAR 0 1
11091: PPUSH
11092: CALL_OW 247
11096: PUSH
11097: LD_INT 3
11099: EQUAL
11100: IFFALSE 11116
// buildings_counter := buildings_counter + 1 ;
11102: LD_ADDR_EXP 4
11106: PUSH
11107: LD_EXP 4
11111: PUSH
11112: LD_INT 1
11114: PLUS
11115: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
11116: LD_VAR 0 1
11120: PUSH
11121: LD_INT 6
11123: PPUSH
11124: LD_INT 2
11126: PUSH
11127: LD_INT 30
11129: PUSH
11130: LD_INT 33
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: PUSH
11137: LD_INT 30
11139: PUSH
11140: LD_INT 32
11142: PUSH
11143: EMPTY
11144: LIST
11145: LIST
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: LIST
11151: PPUSH
11152: CALL_OW 70
11156: IN
11157: IFFALSE 11216
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11159: LD_ADDR_EXP 19
11163: PUSH
11164: LD_EXP 19
11168: PUSH
11169: LD_VAR 0 1
11173: PPUSH
11174: CALL_OW 266
11178: PUSH
11179: LD_VAR 0 1
11183: PPUSH
11184: CALL_OW 250
11188: PUSH
11189: LD_VAR 0 1
11193: PPUSH
11194: CALL_OW 251
11198: PUSH
11199: LD_VAR 0 1
11203: PPUSH
11204: CALL_OW 254
11208: PUSH
11209: EMPTY
11210: LIST
11211: LIST
11212: LIST
11213: LIST
11214: ADD
11215: ST_TO_ADDR
// if un = ru_dep_main then
11216: LD_VAR 0 1
11220: PUSH
11221: LD_INT 16
11223: EQUAL
11224: IFFALSE 11233
// ChangeMissionObjectives ( M1a ) ;
11226: LD_STRING M1a
11228: PPUSH
11229: CALL_OW 337
// end ;
11233: PPOPN 1
11235: END
// on BuildingStarted ( b , builder ) do var i ;
11236: LD_INT 0
11238: PPUSH
// begin if GetSide ( b ) = 3 then
11239: LD_VAR 0 1
11243: PPUSH
11244: CALL_OW 255
11248: PUSH
11249: LD_INT 3
11251: EQUAL
11252: IFFALSE 11292
// for i = 1 to 4 do
11254: LD_ADDR_VAR 0 3
11258: PUSH
11259: DOUBLE
11260: LD_INT 1
11262: DEC
11263: ST_TO_ADDR
11264: LD_INT 4
11266: PUSH
11267: FOR_TO
11268: IFFALSE 11290
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
11270: LD_ADDR_EXP 19
11274: PUSH
11275: LD_EXP 19
11279: PPUSH
11280: LD_INT 1
11282: PPUSH
11283: CALL_OW 3
11287: ST_TO_ADDR
11288: GO 11267
11290: POP
11291: POP
// end ;
11292: PPOPN 3
11294: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
11295: LD_VAR 0 1
11299: PPUSH
11300: CALL_OW 266
11304: PUSH
11305: LD_INT 32
11307: PUSH
11308: LD_INT 33
11310: PUSH
11311: EMPTY
11312: LIST
11313: LIST
11314: IN
11315: IFFALSE 11329
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
11317: LD_VAR 0 1
11321: PPUSH
11322: LD_INT 43
11324: PPUSH
11325: CALL_OW 148
11329: PPOPN 1
11331: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
11332: LD_VAR 0 1
11336: PUSH
11337: LD_INT 22
11339: PUSH
11340: LD_INT 3
11342: PUSH
11343: EMPTY
11344: LIST
11345: LIST
11346: PUSH
11347: LD_INT 2
11349: PUSH
11350: LD_INT 30
11352: PUSH
11353: LD_INT 31
11355: PUSH
11356: EMPTY
11357: LIST
11358: LIST
11359: PUSH
11360: LD_INT 30
11362: PUSH
11363: LD_INT 32
11365: PUSH
11366: EMPTY
11367: LIST
11368: LIST
11369: PUSH
11370: EMPTY
11371: LIST
11372: LIST
11373: LIST
11374: PUSH
11375: EMPTY
11376: LIST
11377: LIST
11378: PPUSH
11379: CALL_OW 69
11383: IN
11384: IFFALSE 11406
// GoToAnotherTower ( un , b , 143 , 143 ) ;
11386: LD_VAR 0 2
11390: PPUSH
11391: LD_VAR 0 1
11395: PPUSH
11396: LD_INT 143
11398: PPUSH
11399: LD_INT 143
11401: PPUSH
11402: CALL 2054 0 4
// end ;
11406: PPOPN 2
11408: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
11409: LD_VAR 0 1
11413: PUSH
11414: LD_INT 22
11416: PUSH
11417: LD_INT 3
11419: PUSH
11420: EMPTY
11421: LIST
11422: LIST
11423: PUSH
11424: LD_INT 30
11426: PUSH
11427: LD_INT 32
11429: PUSH
11430: EMPTY
11431: LIST
11432: LIST
11433: PUSH
11434: EMPTY
11435: LIST
11436: LIST
11437: PPUSH
11438: CALL_OW 69
11442: IN
11443: IFFALSE 11457
// SetTag ( b , 0 ) ;
11445: LD_VAR 0 1
11449: PPUSH
11450: LD_INT 0
11452: PPUSH
11453: CALL_OW 109
// end ;
11457: PPOPN 2
11459: END
