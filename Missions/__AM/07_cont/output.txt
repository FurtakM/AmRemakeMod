// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 33 0 0
// DebugMode ;
  12: CALL 234 0 0
// PrepareNature ;
  16: CALL 1552 0 0
// PrepareRussians ;
  20: CALL 3094 0 0
// PrepareAmericans ;
  24: CALL 2037 0 0
// Action ;
  28: CALL 6645 0 0
// end ;
  32: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end , must_end ; function Init ; begin
  33: LD_INT 0
  35: PPUSH
// debug := false ;
  36: LD_ADDR_EXP 1
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// mission_prefix := 07c_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 07c_
  51: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  52: LD_ADDR_EXP 2
  56: PUSH
  57: LD_STRING 07_
  59: ST_TO_ADDR
// buildings_counter := 0 ;
  60: LD_ADDR_EXP 4
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// time_to_end := [ [ 30 30$00 , 27 27$00 , 24 24$00 ] [ Difficulty ] , [ 36 36$00 , 33 33$00 , 30 30$00 ] [ Difficulty ] , [ 42 42$00 , 39 39$00 , 36 36$00 ] [ Difficulty ] ] ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 63000
  75: PUSH
  76: LD_INT 56700
  78: PUSH
  79: LD_INT 50400
  81: PUSH
  82: EMPTY
  83: LIST
  84: LIST
  85: LIST
  86: PUSH
  87: LD_OWVAR 67
  91: ARRAY
  92: PUSH
  93: LD_INT 75600
  95: PUSH
  96: LD_INT 69300
  98: PUSH
  99: LD_INT 63000
 101: PUSH
 102: EMPTY
 103: LIST
 104: LIST
 105: LIST
 106: PUSH
 107: LD_OWVAR 67
 111: ARRAY
 112: PUSH
 113: LD_INT 88200
 115: PUSH
 116: LD_INT 81900
 118: PUSH
 119: LD_INT 75600
 121: PUSH
 122: EMPTY
 123: LIST
 124: LIST
 125: LIST
 126: PUSH
 127: LD_OWVAR 67
 131: ARRAY
 132: PUSH
 133: EMPTY
 134: LIST
 135: LIST
 136: LIST
 137: ST_TO_ADDR
// can_end := false ;
 138: LD_ADDR_EXP 6
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// must_end := false ;
 146: LD_ADDR_EXP 7
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// end ;
 154: LD_VAR 0 1
 158: RET
// every 0 0$01 trigger not debug do
 159: LD_EXP 1
 163: NOT
 164: IFFALSE 233
 166: GO 168
 168: DISABLE
// begin enable ;
 169: ENABLE
// if not must_end then
 170: LD_EXP 7
 174: NOT
 175: IFFALSE 196
// display_strings := [ #Am07-1 , tick ] else
 177: LD_ADDR_OWVAR 47
 181: PUSH
 182: LD_STRING #Am07-1
 184: PUSH
 185: LD_OWVAR 1
 189: PUSH
 190: EMPTY
 191: LIST
 192: LIST
 193: ST_TO_ADDR
 194: GO 233
// display_strings := [ #Am07-1 , tick , #Am07-2 , time_to_end [ 3 ] - tick ] ;
 196: LD_ADDR_OWVAR 47
 200: PUSH
 201: LD_STRING #Am07-1
 203: PUSH
 204: LD_OWVAR 1
 208: PUSH
 209: LD_STRING #Am07-2
 211: PUSH
 212: LD_EXP 5
 216: PUSH
 217: LD_INT 3
 219: ARRAY
 220: PUSH
 221: LD_OWVAR 1
 225: MINUS
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: LIST
 232: ST_TO_ADDR
// end ;
 233: END
// function DebugMode ; begin
 234: LD_INT 0
 236: PPUSH
// if not debug then
 237: LD_EXP 1
 241: NOT
 242: IFFALSE 246
// exit ;
 244: GO 253
// FogOff ( 1 ) ;
 246: LD_INT 1
 248: PPUSH
 249: CALL_OW 344
// end ;
 253: LD_VAR 0 1
 257: RET
// every 3 trigger debug do var i , filter ;
 258: LD_EXP 1
 262: IFFALSE 351
 264: GO 266
 266: DISABLE
 267: LD_INT 0
 269: PPUSH
 270: PPUSH
// begin enable ;
 271: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 272: LD_ADDR_VAR 0 2
 276: PUSH
 277: LD_INT 22
 279: PUSH
 280: LD_INT 1
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: PUSH
 287: LD_INT 3
 289: PUSH
 290: LD_INT 24
 292: PUSH
 293: LD_INT 500
 295: PUSH
 296: EMPTY
 297: LIST
 298: LIST
 299: PUSH
 300: EMPTY
 301: LIST
 302: LIST
 303: PUSH
 304: EMPTY
 305: LIST
 306: LIST
 307: PPUSH
 308: CALL_OW 69
 312: ST_TO_ADDR
// if not filter then
 313: LD_VAR 0 2
 317: NOT
 318: IFFALSE 322
// exit ;
 320: GO 351
// for i in filter do
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_VAR 0 2
 331: PUSH
 332: FOR_IN
 333: IFFALSE 349
// SetLives ( i , 1000 ) ;
 335: LD_VAR 0 1
 339: PPUSH
 340: LD_INT 1000
 342: PPUSH
 343: CALL_OW 234
 347: GO 332
 349: POP
 350: POP
// end ; end_of_file
 351: PPOPN 2
 353: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 354: LD_INT 0
 356: PPUSH
 357: PPUSH
// if exist_mode then
 358: LD_VAR 0 2
 362: IFFALSE 387
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 364: LD_ADDR_VAR 0 4
 368: PUSH
 369: LD_EXP 2
 373: PUSH
 374: LD_VAR 0 1
 378: STR
 379: PPUSH
 380: CALL_OW 34
 384: ST_TO_ADDR
 385: GO 402
// unit := NewCharacter ( ident ) ;
 387: LD_ADDR_VAR 0 4
 391: PUSH
 392: LD_VAR 0 1
 396: PPUSH
 397: CALL_OW 25
 401: ST_TO_ADDR
// result := unit ;
 402: LD_ADDR_VAR 0 3
 406: PUSH
 407: LD_VAR 0 4
 411: ST_TO_ADDR
// end ;
 412: LD_VAR 0 3
 416: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 417: LD_INT 0
 419: PPUSH
// uc_side := side ;
 420: LD_ADDR_OWVAR 20
 424: PUSH
 425: LD_VAR 0 1
 429: ST_TO_ADDR
// uc_nation := nation ;
 430: LD_ADDR_OWVAR 21
 434: PUSH
 435: LD_VAR 0 2
 439: ST_TO_ADDR
// vc_chassis := chassis ;
 440: LD_ADDR_OWVAR 37
 444: PUSH
 445: LD_VAR 0 3
 449: ST_TO_ADDR
// vc_engine := engine ;
 450: LD_ADDR_OWVAR 39
 454: PUSH
 455: LD_VAR 0 4
 459: ST_TO_ADDR
// vc_control := control ;
 460: LD_ADDR_OWVAR 38
 464: PUSH
 465: LD_VAR 0 5
 469: ST_TO_ADDR
// vc_weapon := weapon ;
 470: LD_ADDR_OWVAR 40
 474: PUSH
 475: LD_VAR 0 6
 479: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 480: LD_ADDR_OWVAR 41
 484: PUSH
 485: LD_VAR 0 7
 489: ST_TO_ADDR
// result := CreateVehicle ;
 490: LD_ADDR_VAR 0 8
 494: PUSH
 495: CALL_OW 45
 499: ST_TO_ADDR
// end ;
 500: LD_VAR 0 8
 504: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 505: LD_INT 0
 507: PPUSH
 508: PPUSH
 509: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 510: LD_ADDR_VAR 0 4
 514: PUSH
 515: LD_INT 22
 517: PUSH
 518: LD_INT 1
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: PUSH
 525: LD_INT 21
 527: PUSH
 528: LD_INT 1
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: PUSH
 535: LD_INT 50
 537: PUSH
 538: EMPTY
 539: LIST
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: PPUSH
 546: CALL_OW 69
 550: PUSH
 551: LD_EXP 8
 555: PUSH
 556: LD_EXP 9
 560: PUSH
 561: LD_EXP 10
 565: PUSH
 566: LD_EXP 11
 570: PUSH
 571: LD_EXP 12
 575: PUSH
 576: LD_EXP 13
 580: PUSH
 581: LD_EXP 14
 585: PUSH
 586: LD_EXP 15
 590: PUSH
 591: LD_EXP 17
 595: PUSH
 596: LD_EXP 16
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: DIFF
 613: ST_TO_ADDR
// if not filter then
 614: LD_VAR 0 4
 618: NOT
 619: IFFALSE 623
// exit ;
 621: GO 650
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 623: LD_ADDR_VAR 0 2
 627: PUSH
 628: LD_VAR 0 4
 632: PPUSH
 633: LD_INT 26
 635: PUSH
 636: LD_VAR 0 1
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL_OW 72
 649: ST_TO_ADDR
// end ;
 650: LD_VAR 0 2
 654: RET
// export function SayX ( units , ident ) ; var i ; begin
 655: LD_INT 0
 657: PPUSH
 658: PPUSH
// result := false ;
 659: LD_ADDR_VAR 0 3
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// if not units then
 667: LD_VAR 0 1
 671: NOT
 672: IFFALSE 676
// exit ;
 674: GO 730
// for i in units do
 676: LD_ADDR_VAR 0 4
 680: PUSH
 681: LD_VAR 0 1
 685: PUSH
 686: FOR_IN
 687: IFFALSE 728
// if IsOk ( i ) then
 689: LD_VAR 0 4
 693: PPUSH
 694: CALL_OW 302
 698: IFFALSE 726
// begin Say ( i , ident ) ;
 700: LD_VAR 0 4
 704: PPUSH
 705: LD_VAR 0 2
 709: PPUSH
 710: CALL_OW 88
// result := i ;
 714: LD_ADDR_VAR 0 3
 718: PUSH
 719: LD_VAR 0 4
 723: ST_TO_ADDR
// break ;
 724: GO 728
// end ;
 726: GO 686
 728: POP
 729: POP
// end ;
 730: LD_VAR 0 3
 734: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
 735: LD_INT 0
 737: PPUSH
 738: PPUSH
 739: PPUSH
 740: PPUSH
 741: PPUSH
// if not un or not IsOk ( un ) then
 742: LD_VAR 0 1
 746: NOT
 747: PUSH
 748: LD_VAR 0 1
 752: PPUSH
 753: CALL_OW 302
 757: NOT
 758: OR
 759: IFFALSE 763
// exit ;
 761: GO 1157
// side := GetSide ( un ) ;
 763: LD_ADDR_VAR 0 9
 767: PUSH
 768: LD_VAR 0 1
 772: PPUSH
 773: CALL_OW 255
 777: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
 778: LD_ADDR_VAR 0 7
 782: PUSH
 783: LD_INT 22
 785: PUSH
 786: LD_VAR 0 9
 790: PUSH
 791: EMPTY
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 30
 797: PUSH
 798: LD_INT 32
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: PUSH
 805: LD_INT 50
 807: PUSH
 808: EMPTY
 809: LIST
 810: PUSH
 811: LD_INT 58
 813: PUSH
 814: EMPTY
 815: LIST
 816: PUSH
 817: EMPTY
 818: LIST
 819: LIST
 820: LIST
 821: LIST
 822: PPUSH
 823: CALL_OW 69
 827: PUSH
 828: LD_VAR 0 2
 832: DIFF
 833: ST_TO_ADDR
// if not filter then
 834: LD_VAR 0 7
 838: NOT
 839: IFFALSE 1022
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
 841: LD_ADDR_VAR 0 7
 845: PUSH
 846: LD_INT 22
 848: PUSH
 849: LD_VAR 0 9
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: PUSH
 858: LD_INT 30
 860: PUSH
 861: LD_INT 5
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PPUSH
 872: CALL_OW 69
 876: ST_TO_ADDR
// if not filter then
 877: LD_VAR 0 7
 881: NOT
 882: IFFALSE 905
// begin ComMoveXY ( un , x , y ) ;
 884: LD_VAR 0 1
 888: PPUSH
 889: LD_VAR 0 3
 893: PPUSH
 894: LD_VAR 0 4
 898: PPUSH
 899: CALL_OW 111
// exit ;
 903: GO 1157
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
 905: LD_ADDR_VAR 0 8
 909: PUSH
 910: LD_VAR 0 7
 914: PPUSH
 915: LD_VAR 0 1
 919: PPUSH
 920: CALL_OW 74
 924: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
 925: LD_VAR 0 8
 929: PPUSH
 930: CALL_OW 313
 934: PUSH
 935: LD_INT 6
 937: EQUAL
 938: IFFALSE 956
// filter := filter diff t ;
 940: LD_ADDR_VAR 0 7
 944: PUSH
 945: LD_VAR 0 7
 949: PUSH
 950: LD_VAR 0 8
 954: DIFF
 955: ST_TO_ADDR
// until UnitsInside ( t ) < 6 or not filter ;
 956: LD_VAR 0 8
 960: PPUSH
 961: CALL_OW 313
 965: PUSH
 966: LD_INT 6
 968: LESS
 969: PUSH
 970: LD_VAR 0 7
 974: NOT
 975: OR
 976: IFFALSE 905
// if not filter then
 978: LD_VAR 0 7
 982: NOT
 983: IFFALSE 1006
// ComMoveXY ( un , x , y ) else
 985: LD_VAR 0 1
 989: PPUSH
 990: LD_VAR 0 3
 994: PPUSH
 995: LD_VAR 0 4
 999: PPUSH
1000: CALL_OW 111
1004: GO 1020
// ComEnterUnit ( un , t ) ;
1006: LD_VAR 0 1
1010: PPUSH
1011: LD_VAR 0 8
1015: PPUSH
1016: CALL_OW 120
// end else
1020: GO 1157
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
1022: LD_ADDR_VAR 0 8
1026: PUSH
1027: LD_VAR 0 7
1031: PPUSH
1032: LD_VAR 0 1
1036: PPUSH
1037: CALL_OW 74
1041: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
1042: LD_VAR 0 8
1046: PPUSH
1047: CALL_OW 110
1051: PUSH
1052: LD_INT 7
1054: EQUAL
1055: IFFALSE 1073
// filter := filter diff t ;
1057: LD_ADDR_VAR 0 7
1061: PUSH
1062: LD_VAR 0 7
1066: PUSH
1067: LD_VAR 0 8
1071: DIFF
1072: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
1073: LD_VAR 0 8
1077: PPUSH
1078: CALL_OW 110
1082: PUSH
1083: LD_INT 7
1085: NONEQUAL
1086: PUSH
1087: LD_VAR 0 7
1091: NOT
1092: OR
1093: IFFALSE 1022
// if GetTag ( t ) <> 7 then
1095: LD_VAR 0 8
1099: PPUSH
1100: CALL_OW 110
1104: PUSH
1105: LD_INT 7
1107: NONEQUAL
1108: IFFALSE 1138
// begin SetTag ( t , 7 ) ;
1110: LD_VAR 0 8
1114: PPUSH
1115: LD_INT 7
1117: PPUSH
1118: CALL_OW 109
// ComEnterUnit ( un , t ) ;
1122: LD_VAR 0 1
1126: PPUSH
1127: LD_VAR 0 8
1131: PPUSH
1132: CALL_OW 120
// end else
1136: GO 1157
// ComMoveXY ( un , x , y ) ;
1138: LD_VAR 0 1
1142: PPUSH
1143: LD_VAR 0 3
1147: PPUSH
1148: LD_VAR 0 4
1152: PPUSH
1153: CALL_OW 111
// end ; end ;
1157: LD_VAR 0 5
1161: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
1162: LD_INT 0
1164: PPUSH
1165: PPUSH
1166: PPUSH
// if not base then
1167: LD_VAR 0 1
1171: NOT
1172: IFFALSE 1176
// exit ;
1174: GO 1234
// tmp := GetEnergy ( GetBase ( base ) ) ;
1176: LD_ADDR_VAR 0 4
1180: PUSH
1181: LD_VAR 0 1
1185: PPUSH
1186: CALL_OW 274
1190: PPUSH
1191: CALL_OW 278
1195: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
1196: LD_VAR 0 4
1200: PUSH
1201: LD_INT 1
1203: ARRAY
1204: PUSH
1205: LD_VAR 0 4
1209: PUSH
1210: LD_INT 4
1212: ARRAY
1213: GREATER
1214: IFFALSE 1226
// result := true else
1216: LD_ADDR_VAR 0 2
1220: PUSH
1221: LD_INT 1
1223: ST_TO_ADDR
1224: GO 1234
// result := false ;
1226: LD_ADDR_VAR 0 2
1230: PUSH
1231: LD_INT 0
1233: ST_TO_ADDR
// end ;
1234: LD_VAR 0 2
1238: RET
// export function FilterPeople ( side ) ; begin
1239: LD_INT 0
1241: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
1242: LD_ADDR_VAR 0 2
1246: PUSH
1247: LD_INT 22
1249: PUSH
1250: LD_VAR 0 1
1254: PUSH
1255: EMPTY
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 21
1261: PUSH
1262: LD_INT 1
1264: PUSH
1265: EMPTY
1266: LIST
1267: LIST
1268: PUSH
1269: EMPTY
1270: LIST
1271: LIST
1272: PPUSH
1273: CALL_OW 69
1277: ST_TO_ADDR
// end ;
1278: LD_VAR 0 2
1282: RET
// export function FilterDrivers ( side ) ; begin
1283: LD_INT 0
1285: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
1286: LD_ADDR_VAR 0 2
1290: PUSH
1291: LD_INT 22
1293: PUSH
1294: LD_VAR 0 1
1298: PUSH
1299: EMPTY
1300: LIST
1301: LIST
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: LD_INT 56
1308: PUSH
1309: EMPTY
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: PUSH
1316: EMPTY
1317: LIST
1318: LIST
1319: PPUSH
1320: CALL_OW 69
1324: ST_TO_ADDR
// end ;
1325: LD_VAR 0 2
1329: RET
// export function FilterPeopleArea ( side , area ) ; begin
1330: LD_INT 0
1332: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
1333: LD_ADDR_VAR 0 3
1337: PUSH
1338: LD_VAR 0 2
1342: PPUSH
1343: LD_INT 22
1345: PUSH
1346: LD_INT 1
1348: PUSH
1349: EMPTY
1350: LIST
1351: LIST
1352: PUSH
1353: LD_INT 21
1355: PUSH
1356: LD_INT 1
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: PUSH
1363: EMPTY
1364: LIST
1365: LIST
1366: PPUSH
1367: CALL_OW 70
1371: ST_TO_ADDR
// end ;
1372: LD_VAR 0 3
1376: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
1377: LD_INT 0
1379: PPUSH
1380: PPUSH
1381: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
1382: LD_ADDR_VAR 0 5
1386: PUSH
1387: LD_VAR 0 2
1391: PPUSH
1392: LD_INT 22
1394: PUSH
1395: LD_INT 1
1397: PUSH
1398: EMPTY
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 21
1404: PUSH
1405: LD_INT 2
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: PUSH
1412: LD_INT 3
1414: PUSH
1415: LD_INT 58
1417: PUSH
1418: EMPTY
1419: LIST
1420: PUSH
1421: EMPTY
1422: LIST
1423: LIST
1424: PUSH
1425: EMPTY
1426: LIST
1427: LIST
1428: LIST
1429: PPUSH
1430: CALL_OW 70
1434: ST_TO_ADDR
// result := [ ] ;
1435: LD_ADDR_VAR 0 3
1439: PUSH
1440: EMPTY
1441: ST_TO_ADDR
// if not tmp then
1442: LD_VAR 0 5
1446: NOT
1447: IFFALSE 1451
// exit ;
1449: GO 1503
// for i in tmp do
1451: LD_ADDR_VAR 0 4
1455: PUSH
1456: LD_VAR 0 5
1460: PUSH
1461: FOR_IN
1462: IFFALSE 1487
// result := result ^ IsDrivenBy ( i ) ;
1464: LD_ADDR_VAR 0 3
1468: PUSH
1469: LD_VAR 0 3
1473: PUSH
1474: LD_VAR 0 4
1478: PPUSH
1479: CALL_OW 311
1483: ADD
1484: ST_TO_ADDR
1485: GO 1461
1487: POP
1488: POP
// result := result diff 0 ;
1489: LD_ADDR_VAR 0 3
1493: PUSH
1494: LD_VAR 0 3
1498: PUSH
1499: LD_INT 0
1501: DIFF
1502: ST_TO_ADDR
// end ;
1503: LD_VAR 0 3
1507: RET
// export function FilterBuildings ( side ) ; begin
1508: LD_INT 0
1510: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
1511: LD_ADDR_VAR 0 2
1515: PUSH
1516: LD_INT 22
1518: PUSH
1519: LD_VAR 0 1
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: PUSH
1528: LD_INT 21
1530: PUSH
1531: LD_INT 3
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: PUSH
1538: EMPTY
1539: LIST
1540: LIST
1541: PPUSH
1542: CALL_OW 69
1546: ST_TO_ADDR
// end ;
1547: LD_VAR 0 2
1551: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
1552: LD_INT 0
1554: PPUSH
1555: PPUSH
1556: PPUSH
1557: PPUSH
// uc_side = 0 ;
1558: LD_ADDR_OWVAR 20
1562: PUSH
1563: LD_INT 0
1565: ST_TO_ADDR
// uc_nation = 0 ;
1566: LD_ADDR_OWVAR 21
1570: PUSH
1571: LD_INT 0
1573: ST_TO_ADDR
// nat_area := wildArea ;
1574: LD_ADDR_VAR 0 4
1578: PUSH
1579: LD_INT 3
1581: ST_TO_ADDR
// InitHc ;
1582: CALL_OW 19
// for i = 1 to 4 do
1586: LD_ADDR_VAR 0 2
1590: PUSH
1591: DOUBLE
1592: LD_INT 1
1594: DEC
1595: ST_TO_ADDR
1596: LD_INT 4
1598: PUSH
1599: FOR_TO
1600: IFFALSE 1655
// begin hc_class = 18 ;
1602: LD_ADDR_OWVAR 28
1606: PUSH
1607: LD_INT 18
1609: ST_TO_ADDR
// hc_gallery =  ;
1610: LD_ADDR_OWVAR 33
1614: PUSH
1615: LD_STRING 
1617: ST_TO_ADDR
// hc_face_number = 1 ;
1618: LD_ADDR_OWVAR 34
1622: PUSH
1623: LD_INT 1
1625: ST_TO_ADDR
// animal := CreateHuman ;
1626: LD_ADDR_VAR 0 3
1630: PUSH
1631: CALL_OW 44
1635: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1636: LD_VAR 0 3
1640: PPUSH
1641: LD_VAR 0 4
1645: PPUSH
1646: LD_INT 0
1648: PPUSH
1649: CALL_OW 49
// end ;
1653: GO 1599
1655: POP
1656: POP
// for i = 1 to 6 do
1657: LD_ADDR_VAR 0 2
1661: PUSH
1662: DOUBLE
1663: LD_INT 1
1665: DEC
1666: ST_TO_ADDR
1667: LD_INT 6
1669: PUSH
1670: FOR_TO
1671: IFFALSE 1742
// begin hc_class = class_tiger ;
1673: LD_ADDR_OWVAR 28
1677: PUSH
1678: LD_INT 14
1680: ST_TO_ADDR
// hc_gallery =  ;
1681: LD_ADDR_OWVAR 33
1685: PUSH
1686: LD_STRING 
1688: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 50 ) ;
1689: LD_ADDR_OWVAR 35
1693: PUSH
1694: LD_INT 0
1696: PPUSH
1697: LD_INT 50
1699: PPUSH
1700: CALL_OW 12
1704: ST_TO_ADDR
// hc_face_number = 3 ;
1705: LD_ADDR_OWVAR 34
1709: PUSH
1710: LD_INT 3
1712: ST_TO_ADDR
// animal := CreateHuman ;
1713: LD_ADDR_VAR 0 3
1717: PUSH
1718: CALL_OW 44
1722: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1723: LD_VAR 0 3
1727: PPUSH
1728: LD_VAR 0 4
1732: PPUSH
1733: LD_INT 0
1735: PPUSH
1736: CALL_OW 49
// end ;
1740: GO 1670
1742: POP
1743: POP
// for i = 1 to 2 do
1744: LD_ADDR_VAR 0 2
1748: PUSH
1749: DOUBLE
1750: LD_INT 1
1752: DEC
1753: ST_TO_ADDR
1754: LD_INT 2
1756: PUSH
1757: FOR_TO
1758: IFFALSE 1821
// begin hc_class = 21 ;
1760: LD_ADDR_OWVAR 28
1764: PUSH
1765: LD_INT 21
1767: ST_TO_ADDR
// hc_gallery =  ;
1768: LD_ADDR_OWVAR 33
1772: PUSH
1773: LD_STRING 
1775: ST_TO_ADDR
// hc_agressivity = 0 ;
1776: LD_ADDR_OWVAR 35
1780: PUSH
1781: LD_INT 0
1783: ST_TO_ADDR
// hc_face_number = 5 ;
1784: LD_ADDR_OWVAR 34
1788: PUSH
1789: LD_INT 5
1791: ST_TO_ADDR
// animal := CreateHuman ;
1792: LD_ADDR_VAR 0 3
1796: PUSH
1797: CALL_OW 44
1801: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1802: LD_VAR 0 3
1806: PPUSH
1807: LD_VAR 0 4
1811: PPUSH
1812: LD_INT 0
1814: PPUSH
1815: CALL_OW 49
// end ;
1819: GO 1757
1821: POP
1822: POP
// for i = 1 to 6 do
1823: LD_ADDR_VAR 0 2
1827: PUSH
1828: DOUBLE
1829: LD_INT 1
1831: DEC
1832: ST_TO_ADDR
1833: LD_INT 6
1835: PUSH
1836: FOR_TO
1837: IFFALSE 1892
// begin hc_class = 13 ;
1839: LD_ADDR_OWVAR 28
1843: PUSH
1844: LD_INT 13
1846: ST_TO_ADDR
// hc_gallery =  ;
1847: LD_ADDR_OWVAR 33
1851: PUSH
1852: LD_STRING 
1854: ST_TO_ADDR
// hc_face_number = 4 ;
1855: LD_ADDR_OWVAR 34
1859: PUSH
1860: LD_INT 4
1862: ST_TO_ADDR
// animal := CreateHuman ;
1863: LD_ADDR_VAR 0 3
1867: PUSH
1868: CALL_OW 44
1872: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1873: LD_VAR 0 3
1877: PPUSH
1878: LD_VAR 0 4
1882: PPUSH
1883: LD_INT 0
1885: PPUSH
1886: CALL_OW 49
// end ;
1890: GO 1836
1892: POP
1893: POP
// for i = 1 to 2 do
1894: LD_ADDR_VAR 0 2
1898: PUSH
1899: DOUBLE
1900: LD_INT 1
1902: DEC
1903: ST_TO_ADDR
1904: LD_INT 2
1906: PUSH
1907: FOR_TO
1908: IFFALSE 1967
// begin hc_class = 20 ;
1910: LD_ADDR_OWVAR 28
1914: PUSH
1915: LD_INT 20
1917: ST_TO_ADDR
// hc_gallery =  ;
1918: LD_ADDR_OWVAR 33
1922: PUSH
1923: LD_STRING 
1925: ST_TO_ADDR
// hc_face_number = 2 ;
1926: LD_ADDR_OWVAR 34
1930: PUSH
1931: LD_INT 2
1933: ST_TO_ADDR
// animal := CreateHuman ;
1934: LD_ADDR_VAR 0 3
1938: PUSH
1939: CALL_OW 44
1943: ST_TO_ADDR
// PlaceUnitXYR ( animal , 101 , 37 , 3 , false ) ;
1944: LD_VAR 0 3
1948: PPUSH
1949: LD_INT 101
1951: PPUSH
1952: LD_INT 37
1954: PPUSH
1955: LD_INT 3
1957: PPUSH
1958: LD_INT 0
1960: PPUSH
1961: CALL_OW 50
// end ;
1965: GO 1907
1967: POP
1968: POP
// for i = 1 to 1 do
1969: LD_ADDR_VAR 0 2
1973: PUSH
1974: DOUBLE
1975: LD_INT 1
1977: DEC
1978: ST_TO_ADDR
1979: LD_INT 1
1981: PUSH
1982: FOR_TO
1983: IFFALSE 2030
// begin vc_chassis := 31 ;
1985: LD_ADDR_OWVAR 37
1989: PUSH
1990: LD_INT 31
1992: ST_TO_ADDR
// vc_control := control_rider ;
1993: LD_ADDR_OWVAR 38
1997: PUSH
1998: LD_INT 4
2000: ST_TO_ADDR
// animal := CreateVehicle ;
2001: LD_ADDR_VAR 0 3
2005: PUSH
2006: CALL_OW 45
2010: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
2011: LD_VAR 0 3
2015: PPUSH
2016: LD_VAR 0 4
2020: PPUSH
2021: LD_INT 0
2023: PPUSH
2024: CALL_OW 49
// end ;
2028: GO 1982
2030: POP
2031: POP
// end ; end_of_file
2032: LD_VAR 0 1
2036: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
2037: LD_INT 0
2039: PPUSH
2040: PPUSH
2041: PPUSH
2042: PPUSH
2043: PPUSH
2044: PPUSH
// uc_side := 1 ;
2045: LD_ADDR_OWVAR 20
2049: PUSH
2050: LD_INT 1
2052: ST_TO_ADDR
// uc_nation := 1 ;
2053: LD_ADDR_OWVAR 21
2057: PUSH
2058: LD_INT 1
2060: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
2061: LD_ADDR_EXP 8
2065: PUSH
2066: LD_STRING JMM
2068: PPUSH
2069: LD_EXP 1
2073: NOT
2074: PPUSH
2075: CALL 354 0 2
2079: ST_TO_ADDR
// team := [ JMM ] ;
2080: LD_ADDR_VAR 0 3
2084: PUSH
2085: LD_EXP 8
2089: PUSH
2090: EMPTY
2091: LIST
2092: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
2093: LD_STRING BrownIn07
2095: PPUSH
2096: LD_EXP 1
2100: PPUSH
2101: CALL_OW 30
2105: IFFALSE 2126
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
2107: LD_ADDR_EXP 9
2111: PUSH
2112: LD_STRING Brown
2114: PPUSH
2115: LD_EXP 1
2119: NOT
2120: PPUSH
2121: CALL 354 0 2
2125: ST_TO_ADDR
// if Brown then
2126: LD_EXP 9
2130: IFFALSE 2148
// team := team ^ Brown ;
2132: LD_ADDR_VAR 0 3
2136: PUSH
2137: LD_VAR 0 3
2141: PUSH
2142: LD_EXP 9
2146: ADD
2147: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
2148: LD_STRING DonaldsonIn07
2150: PPUSH
2151: LD_EXP 1
2155: PPUSH
2156: CALL_OW 30
2160: IFFALSE 2181
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
2162: LD_ADDR_EXP 10
2166: PUSH
2167: LD_STRING Donaldson
2169: PPUSH
2170: LD_EXP 1
2174: NOT
2175: PPUSH
2176: CALL 354 0 2
2180: ST_TO_ADDR
// if Donaldson then
2181: LD_EXP 10
2185: IFFALSE 2203
// team := team ^ Donaldson ;
2187: LD_ADDR_VAR 0 3
2191: PUSH
2192: LD_VAR 0 3
2196: PUSH
2197: LD_EXP 10
2201: ADD
2202: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
2203: LD_STRING BobbyIn07
2205: PPUSH
2206: LD_EXP 1
2210: PPUSH
2211: CALL_OW 30
2215: IFFALSE 2236
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
2217: LD_ADDR_EXP 11
2221: PUSH
2222: LD_STRING Bobby
2224: PPUSH
2225: LD_EXP 1
2229: NOT
2230: PPUSH
2231: CALL 354 0 2
2235: ST_TO_ADDR
// if Bobby then
2236: LD_EXP 11
2240: IFFALSE 2258
// team := team ^ Bobby ;
2242: LD_ADDR_VAR 0 3
2246: PUSH
2247: LD_VAR 0 3
2251: PUSH
2252: LD_EXP 11
2256: ADD
2257: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
2258: LD_STRING CyrusIn07
2260: PPUSH
2261: LD_EXP 1
2265: PPUSH
2266: CALL_OW 30
2270: IFFALSE 2291
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
2272: LD_ADDR_EXP 12
2276: PUSH
2277: LD_STRING Cyrus
2279: PPUSH
2280: LD_EXP 1
2284: NOT
2285: PPUSH
2286: CALL 354 0 2
2290: ST_TO_ADDR
// if Cyrus then
2291: LD_EXP 12
2295: IFFALSE 2313
// team := team ^ Cyrus ;
2297: LD_ADDR_VAR 0 3
2301: PUSH
2302: LD_VAR 0 3
2306: PUSH
2307: LD_EXP 12
2311: ADD
2312: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
2313: LD_STRING LisaIn07
2315: PPUSH
2316: LD_EXP 1
2320: PPUSH
2321: CALL_OW 30
2325: IFFALSE 2346
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
2327: LD_ADDR_EXP 13
2331: PUSH
2332: LD_STRING Lisa
2334: PPUSH
2335: LD_EXP 1
2339: NOT
2340: PPUSH
2341: CALL 354 0 2
2345: ST_TO_ADDR
// if Lisa then
2346: LD_EXP 13
2350: IFFALSE 2368
// team := team ^ Lisa ;
2352: LD_ADDR_VAR 0 3
2356: PUSH
2357: LD_VAR 0 3
2361: PUSH
2362: LD_EXP 13
2366: ADD
2367: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
2368: LD_STRING GladstoneIn07
2370: PPUSH
2371: LD_EXP 1
2375: PPUSH
2376: CALL_OW 30
2380: IFFALSE 2401
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
2382: LD_ADDR_EXP 15
2386: PUSH
2387: LD_STRING Gladstone
2389: PPUSH
2390: LD_EXP 1
2394: NOT
2395: PPUSH
2396: CALL 354 0 2
2400: ST_TO_ADDR
// if Gladstone then
2401: LD_EXP 15
2405: IFFALSE 2423
// team := team ^ Gladstone ;
2407: LD_ADDR_VAR 0 3
2411: PUSH
2412: LD_VAR 0 3
2416: PUSH
2417: LD_EXP 15
2421: ADD
2422: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
2423: LD_STRING KhatamIn07
2425: PPUSH
2426: LD_EXP 1
2430: PPUSH
2431: CALL_OW 30
2435: IFFALSE 2456
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
2437: LD_ADDR_EXP 16
2441: PUSH
2442: LD_STRING Khatam
2444: PPUSH
2445: LD_EXP 1
2449: NOT
2450: PPUSH
2451: CALL 354 0 2
2455: ST_TO_ADDR
// if Khatam then
2456: LD_EXP 16
2460: IFFALSE 2478
// team := team ^ Khatam ;
2462: LD_ADDR_VAR 0 3
2466: PUSH
2467: LD_VAR 0 3
2471: PUSH
2472: LD_EXP 16
2476: ADD
2477: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
2478: LD_ADDR_VAR 0 4
2482: PUSH
2483: LD_STRING 07_others
2485: PPUSH
2486: CALL_OW 31
2490: ST_TO_ADDR
// if others then
2491: LD_VAR 0 4
2495: IFFALSE 2513
// team := team ^ others ;
2497: LD_ADDR_VAR 0 3
2501: PUSH
2502: LD_VAR 0 3
2506: PUSH
2507: LD_VAR 0 4
2511: ADD
2512: ST_TO_ADDR
// if debug then
2513: LD_EXP 1
2517: IFFALSE 2591
// begin InitHc ;
2519: CALL_OW 19
// for i = 1 to 4 do
2523: LD_ADDR_VAR 0 2
2527: PUSH
2528: DOUBLE
2529: LD_INT 1
2531: DEC
2532: ST_TO_ADDR
2533: LD_INT 4
2535: PUSH
2536: FOR_TO
2537: IFFALSE 2589
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
2539: LD_INT 0
2541: PPUSH
2542: LD_INT 1
2544: PUSH
2545: LD_INT 3
2547: PUSH
2548: EMPTY
2549: LIST
2550: LIST
2551: PUSH
2552: LD_INT 1
2554: PPUSH
2555: LD_INT 2
2557: PPUSH
2558: CALL_OW 12
2562: ARRAY
2563: PPUSH
2564: LD_INT 4
2566: PPUSH
2567: CALL_OW 380
// team := team ^ CreateHuman ;
2571: LD_ADDR_VAR 0 3
2575: PUSH
2576: LD_VAR 0 3
2580: PUSH
2581: CALL_OW 44
2585: ADD
2586: ST_TO_ADDR
// end ;
2587: GO 2536
2589: POP
2590: POP
// end ; m := 0 ;
2591: LD_ADDR_VAR 0 6
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// for i in team do
2599: LD_ADDR_VAR 0 2
2603: PUSH
2604: LD_VAR 0 3
2608: PUSH
2609: FOR_IN
2610: IFFALSE 2790
// if GetClass ( i ) = 3 then
2612: LD_VAR 0 2
2616: PPUSH
2617: CALL_OW 257
2621: PUSH
2622: LD_INT 3
2624: EQUAL
2625: IFFALSE 2773
// begin m := m + 1 ;
2627: LD_ADDR_VAR 0 6
2631: PUSH
2632: LD_VAR 0 6
2636: PUSH
2637: LD_INT 1
2639: PLUS
2640: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
2641: LD_ADDR_VAR 0 5
2645: PUSH
2646: LD_INT 1
2648: PPUSH
2649: LD_INT 1
2651: PPUSH
2652: LD_INT 2
2654: PUSH
2655: LD_INT 3
2657: PUSH
2658: LD_INT 2
2660: PUSH
2661: LD_INT 1
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: LIST
2668: LIST
2669: PUSH
2670: LD_VAR 0 6
2674: PUSH
2675: LD_INT 4
2677: MOD
2678: PUSH
2679: LD_INT 1
2681: PLUS
2682: ARRAY
2683: PPUSH
2684: LD_INT 2
2686: PPUSH
2687: LD_INT 1
2689: PPUSH
2690: LD_INT 4
2692: PUSH
2693: LD_INT 5
2695: PUSH
2696: LD_INT 3
2698: PUSH
2699: LD_INT 11
2701: PUSH
2702: EMPTY
2703: LIST
2704: LIST
2705: LIST
2706: LIST
2707: PUSH
2708: LD_VAR 0 6
2712: PUSH
2713: LD_INT 4
2715: MOD
2716: PUSH
2717: LD_INT 1
2719: PLUS
2720: ARRAY
2721: PPUSH
2722: LD_INT 60
2724: PPUSH
2725: CALL 417 0 7
2729: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2730: LD_VAR 0 5
2734: PPUSH
2735: LD_INT 2
2737: PPUSH
2738: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
2742: LD_VAR 0 5
2746: PPUSH
2747: LD_INT 1
2749: PPUSH
2750: LD_INT 0
2752: PPUSH
2753: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2757: LD_VAR 0 2
2761: PPUSH
2762: LD_VAR 0 5
2766: PPUSH
2767: CALL_OW 52
// end else
2771: GO 2788
// PlaceUnitArea ( i , startArea , false ) ;
2773: LD_VAR 0 2
2777: PPUSH
2778: LD_INT 1
2780: PPUSH
2781: LD_INT 0
2783: PPUSH
2784: CALL_OW 49
2788: GO 2609
2790: POP
2791: POP
// uc_side := 4 ;
2792: LD_ADDR_OWVAR 20
2796: PUSH
2797: LD_INT 4
2799: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
2800: LD_ADDR_EXP 18
2804: PUSH
2805: LD_STRING Harisson
2807: PPUSH
2808: LD_INT 0
2810: PPUSH
2811: CALL 354 0 2
2815: ST_TO_ADDR
// PrepareScout ;
2816: CALL 2825 0 0
// end ;
2820: LD_VAR 0 1
2824: RET
// function PrepareScout ; var ape ; begin
2825: LD_INT 0
2827: PPUSH
2828: PPUSH
// uc_side := 4 ;
2829: LD_ADDR_OWVAR 20
2833: PUSH
2834: LD_INT 4
2836: ST_TO_ADDR
// uc_nation := 1 ;
2837: LD_ADDR_OWVAR 21
2841: PUSH
2842: LD_INT 1
2844: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
2845: LD_STRING FrankIn06
2847: PPUSH
2848: LD_INT 0
2850: PPUSH
2851: CALL_OW 30
2855: IFFALSE 2872
// Frank := CreateCharacter ( 06c_Frank ) else
2857: LD_ADDR_EXP 14
2861: PUSH
2862: LD_STRING 06c_Frank
2864: PPUSH
2865: CALL_OW 34
2869: ST_TO_ADDR
2870: GO 2912
// if LoadVariable ( FrankInDelta , 0 ) then
2872: LD_STRING FrankInDelta
2874: PPUSH
2875: LD_INT 0
2877: PPUSH
2878: CALL_OW 30
2882: IFFALSE 2899
// Frank := CreateCharacter ( 05_Frank ) else
2884: LD_ADDR_EXP 14
2888: PUSH
2889: LD_STRING 05_Frank
2891: PPUSH
2892: CALL_OW 34
2896: ST_TO_ADDR
2897: GO 2912
// Frank := CreateCharacter ( 04_Frank ) ;
2899: LD_ADDR_EXP 14
2903: PUSH
2904: LD_STRING 04_Frank
2906: PPUSH
2907: CALL_OW 34
2911: ST_TO_ADDR
// if Frank then
2912: LD_EXP 14
2916: IFFALSE 3049
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
2918: LD_EXP 14
2922: PPUSH
2923: LD_INT 2
2925: PPUSH
2926: LD_INT 0
2928: PPUSH
2929: CALL_OW 49
// SetClass ( Frank , 1 ) ;
2933: LD_EXP 14
2937: PPUSH
2938: LD_INT 1
2940: PPUSH
2941: CALL_OW 336
// uc_side := 0 ;
2945: LD_ADDR_OWVAR 20
2949: PUSH
2950: LD_INT 0
2952: ST_TO_ADDR
// uc_nation := 0 ;
2953: LD_ADDR_OWVAR 21
2957: PUSH
2958: LD_INT 0
2960: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
2961: LD_INT 0
2963: PPUSH
2964: LD_INT 12
2966: PPUSH
2967: LD_INT 0
2969: PPUSH
2970: CALL_OW 380
// ape := CreateHuman ;
2974: LD_ADDR_VAR 0 2
2978: PUSH
2979: CALL_OW 44
2983: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
2984: LD_VAR 0 2
2988: PPUSH
2989: LD_EXP 14
2993: PPUSH
2994: CALL_OW 250
2998: PPUSH
2999: LD_EXP 14
3003: PPUSH
3004: CALL_OW 251
3008: PPUSH
3009: LD_INT 5
3011: PPUSH
3012: LD_INT 0
3014: PPUSH
3015: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
3019: LD_VAR 0 2
3023: PPUSH
3024: LD_EXP 14
3028: PPUSH
3029: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
3033: LD_EXP 14
3037: PPUSH
3038: LD_VAR 0 2
3042: PPUSH
3043: CALL_OW 119
// exit ;
3047: GO 3089
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
3049: LD_ADDR_EXP 17
3053: PUSH
3054: LD_STRING Yamoko
3056: PPUSH
3057: LD_INT 0
3059: PPUSH
3060: CALL 354 0 2
3064: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
3065: LD_EXP 17
3069: PPUSH
3070: LD_INT 2
3072: PPUSH
3073: LD_INT 0
3075: PPUSH
3076: CALL_OW 49
// ComHold ( Kikuchi ) ;
3080: LD_EXP 17
3084: PPUSH
3085: CALL_OW 140
// end ; end_of_file
3089: LD_VAR 0 1
3093: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
3094: LD_INT 0
3096: PPUSH
3097: PPUSH
3098: PPUSH
3099: PPUSH
3100: PPUSH
3101: PPUSH
3102: PPUSH
3103: PPUSH
3104: PPUSH
3105: PPUSH
3106: PPUSH
3107: PPUSH
3108: PPUSH
3109: PPUSH
3110: PPUSH
3111: PPUSH
// ru_rebuild_list := [ ] ;
3112: LD_ADDR_EXP 19
3116: PUSH
3117: EMPTY
3118: ST_TO_ADDR
// uc_side := 3 ;
3119: LD_ADDR_OWVAR 20
3123: PUSH
3124: LD_INT 3
3126: ST_TO_ADDR
// uc_nation := 3 ;
3127: LD_ADDR_OWVAR 21
3131: PUSH
3132: LD_INT 3
3134: ST_TO_ADDR
// if Difficulty > 1 then
3135: LD_OWVAR 67
3139: PUSH
3140: LD_INT 1
3142: GREATER
3143: IFFALSE 3279
// begin bc_type := b_breastwork ;
3145: LD_ADDR_OWVAR 42
3149: PUSH
3150: LD_INT 31
3152: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
3153: LD_INT 78
3155: PPUSH
3156: LD_INT 74
3158: PPUSH
3159: LD_INT 2
3161: PPUSH
3162: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
3166: LD_INT 171
3168: PPUSH
3169: LD_INT 193
3171: PPUSH
3172: LD_INT 4
3174: PPUSH
3175: CALL_OW 47
// bc_type := b_turret ;
3179: LD_ADDR_OWVAR 42
3183: PUSH
3184: LD_INT 33
3186: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
3187: LD_INT 129
3189: PPUSH
3190: LD_INT 96
3192: PPUSH
3193: LD_INT 3
3195: PPUSH
3196: CALL_OW 47
// if Difficulty > 2 then
3200: LD_OWVAR 67
3204: PUSH
3205: LD_INT 2
3207: GREATER
3208: IFFALSE 3279
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
3210: LD_INT 83
3212: PPUSH
3213: LD_INT 141
3215: PPUSH
3216: CALL_OW 428
3220: PPUSH
3221: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
3225: LD_INT 78
3227: PPUSH
3228: LD_INT 133
3230: PPUSH
3231: CALL_OW 428
3235: PPUSH
3236: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
3240: LD_INT 83
3242: PPUSH
3243: LD_INT 141
3245: PPUSH
3246: LD_INT 2
3248: PPUSH
3249: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
3253: LD_INT 78
3255: PPUSH
3256: LD_INT 133
3258: PPUSH
3259: LD_INT 2
3261: PPUSH
3262: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
3266: LD_INT 145
3268: PPUSH
3269: LD_INT 112
3271: PPUSH
3272: LD_INT 3
3274: PPUSH
3275: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
3279: LD_ADDR_VAR 0 9
3283: PUSH
3284: LD_INT 22
3286: PUSH
3287: LD_INT 3
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: LD_INT 2
3296: PUSH
3297: LD_INT 30
3299: PUSH
3300: LD_INT 0
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 30
3309: PUSH
3310: LD_INT 1
3312: PUSH
3313: EMPTY
3314: LIST
3315: LIST
3316: PUSH
3317: EMPTY
3318: LIST
3319: LIST
3320: LIST
3321: PUSH
3322: EMPTY
3323: LIST
3324: LIST
3325: PPUSH
3326: CALL_OW 69
3330: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
3331: LD_ADDR_VAR 0 10
3335: PUSH
3336: LD_INT 22
3338: PUSH
3339: LD_INT 3
3341: PUSH
3342: EMPTY
3343: LIST
3344: LIST
3345: PUSH
3346: LD_INT 2
3348: PUSH
3349: LD_INT 30
3351: PUSH
3352: LD_INT 6
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: PUSH
3359: LD_INT 30
3361: PUSH
3362: LD_INT 7
3364: PUSH
3365: EMPTY
3366: LIST
3367: LIST
3368: PUSH
3369: LD_INT 30
3371: PUSH
3372: LD_INT 8
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: PUSH
3379: EMPTY
3380: LIST
3381: LIST
3382: LIST
3383: LIST
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: PPUSH
3389: CALL_OW 69
3393: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3394: LD_ADDR_VAR 0 11
3398: PUSH
3399: LD_INT 22
3401: PUSH
3402: LD_INT 3
3404: PUSH
3405: EMPTY
3406: LIST
3407: LIST
3408: PUSH
3409: LD_INT 30
3411: PUSH
3412: LD_INT 3
3414: PUSH
3415: EMPTY
3416: LIST
3417: LIST
3418: PUSH
3419: EMPTY
3420: LIST
3421: LIST
3422: PPUSH
3423: CALL_OW 69
3427: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
3428: LD_ADDR_VAR 0 12
3432: PUSH
3433: LD_INT 22
3435: PUSH
3436: LD_INT 3
3438: PUSH
3439: EMPTY
3440: LIST
3441: LIST
3442: PUSH
3443: LD_INT 30
3445: PUSH
3446: LD_INT 31
3448: PUSH
3449: EMPTY
3450: LIST
3451: LIST
3452: PUSH
3453: EMPTY
3454: LIST
3455: LIST
3456: PPUSH
3457: CALL_OW 69
3461: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
3462: LD_ADDR_VAR 0 13
3466: PUSH
3467: LD_INT 22
3469: PUSH
3470: LD_INT 3
3472: PUSH
3473: EMPTY
3474: LIST
3475: LIST
3476: PUSH
3477: LD_INT 30
3479: PUSH
3480: LD_INT 32
3482: PUSH
3483: EMPTY
3484: LIST
3485: LIST
3486: PUSH
3487: EMPTY
3488: LIST
3489: LIST
3490: PPUSH
3491: CALL_OW 69
3495: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3496: LD_ADDR_VAR 0 14
3500: PUSH
3501: LD_INT 22
3503: PUSH
3504: LD_INT 3
3506: PUSH
3507: EMPTY
3508: LIST
3509: LIST
3510: PUSH
3511: LD_INT 30
3513: PUSH
3514: LD_INT 33
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: PUSH
3521: EMPTY
3522: LIST
3523: LIST
3524: PPUSH
3525: CALL_OW 69
3529: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
3530: LD_ADDR_VAR 0 15
3534: PUSH
3535: LD_INT 42
3537: PUSH
3538: LD_INT 5
3540: PUSH
3541: EMPTY
3542: LIST
3543: LIST
3544: PUSH
3545: LD_INT 43
3547: PUSH
3548: LD_INT 50
3550: PUSH
3551: EMPTY
3552: LIST
3553: LIST
3554: PUSH
3555: LD_INT 44
3557: PUSH
3558: LD_INT 30
3560: PUSH
3561: EMPTY
3562: LIST
3563: LIST
3564: PUSH
3565: LD_INT 46
3567: PUSH
3568: LD_INT 15
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: PUSH
3575: EMPTY
3576: LIST
3577: LIST
3578: LIST
3579: LIST
3580: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 4 , 3 ] ;
3581: LD_ADDR_VAR 0 16
3585: PUSH
3586: LD_INT 0
3588: PUSH
3589: LD_INT 4
3591: PUSH
3592: LD_INT 4
3594: PUSH
3595: LD_INT 3
3597: PUSH
3598: EMPTY
3599: LIST
3600: LIST
3601: LIST
3602: LIST
3603: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
3604: LD_ADDR_VAR 0 6
3608: PUSH
3609: LD_INT 4
3611: PUSH
3612: LD_INT 5
3614: PUSH
3615: LD_INT 6
3617: PUSH
3618: EMPTY
3619: LIST
3620: LIST
3621: LIST
3622: PUSH
3623: LD_OWVAR 67
3627: ARRAY
3628: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
3629: LD_INT 16
3631: PPUSH
3632: LD_STRING am_tukh
3634: PPUSH
3635: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
3639: LD_ADDR_VAR 0 2
3643: PUSH
3644: LD_INT 21
3646: PUSH
3647: LD_INT 3
3649: PUSH
3650: EMPTY
3651: LIST
3652: LIST
3653: PPUSH
3654: CALL_OW 69
3658: PUSH
3659: FOR_IN
3660: IFFALSE 3693
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
3662: LD_VAR 0 2
3666: PPUSH
3667: LD_INT 4
3669: PUSH
3670: LD_INT 5
3672: PUSH
3673: LD_INT 6
3675: PUSH
3676: EMPTY
3677: LIST
3678: LIST
3679: LIST
3680: PUSH
3681: LD_OWVAR 67
3685: ARRAY
3686: PPUSH
3687: CALL_OW 241
3691: GO 3659
3693: POP
3694: POP
// for i in dep_list do
3695: LD_ADDR_VAR 0 2
3699: PUSH
3700: LD_VAR 0 9
3704: PUSH
3705: FOR_IN
3706: IFFALSE 3750
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
3708: LD_VAR 0 2
3712: PPUSH
3713: CALL_OW 274
3717: PPUSH
3718: LD_INT 1
3720: PPUSH
3721: LD_INT 1000
3723: PPUSH
3724: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
3728: LD_VAR 0 2
3732: PPUSH
3733: CALL_OW 274
3737: PPUSH
3738: LD_INT 2
3740: PPUSH
3741: LD_INT 1000
3743: PPUSH
3744: CALL_OW 277
// end ;
3748: GO 3705
3750: POP
3751: POP
// InitHc ;
3752: CALL_OW 19
// tmp := bunker_list * [ 50 , 70 , 85 ] [ Difficulty ] div 100 ;
3756: LD_ADDR_VAR 0 8
3760: PUSH
3761: LD_VAR 0 13
3765: PUSH
3766: LD_INT 50
3768: PUSH
3769: LD_INT 70
3771: PUSH
3772: LD_INT 85
3774: PUSH
3775: EMPTY
3776: LIST
3777: LIST
3778: LIST
3779: PUSH
3780: LD_OWVAR 67
3784: ARRAY
3785: MUL
3786: PUSH
3787: LD_INT 100
3789: DIV
3790: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
3791: LD_ADDR_VAR 0 16
3795: PUSH
3796: LD_VAR 0 16
3800: PPUSH
3801: LD_INT 1
3803: PPUSH
3804: LD_VAR 0 8
3808: PPUSH
3809: CALL_OW 1
3813: ST_TO_ADDR
// tmp := [ ] ;
3814: LD_ADDR_VAR 0 8
3818: PUSH
3819: EMPTY
3820: ST_TO_ADDR
// for i in bunker_list do
3821: LD_ADDR_VAR 0 2
3825: PUSH
3826: LD_VAR 0 13
3830: PUSH
3831: FOR_IN
3832: IFFALSE 3928
// if i mod 10 + 1 < tmp then
3834: LD_VAR 0 2
3838: PUSH
3839: LD_INT 10
3841: MOD
3842: PUSH
3843: LD_INT 1
3845: PLUS
3846: PUSH
3847: LD_VAR 0 8
3851: LESS
3852: IFFALSE 3897
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
3854: LD_ADDR_VAR 0 8
3858: PUSH
3859: LD_VAR 0 8
3863: PPUSH
3864: LD_VAR 0 2
3868: PUSH
3869: LD_INT 3
3871: PPUSH
3872: LD_INT 5
3874: PPUSH
3875: CALL_OW 12
3879: MOD
3880: PUSH
3881: LD_INT 1
3883: PLUS
3884: PPUSH
3885: LD_VAR 0 2
3889: PPUSH
3890: CALL_OW 2
3894: ST_TO_ADDR
3895: GO 3926
// tmp := Insert ( tmp , tmp + 1 , i ) ;
3897: LD_ADDR_VAR 0 8
3901: PUSH
3902: LD_VAR 0 8
3906: PPUSH
3907: LD_VAR 0 8
3911: PUSH
3912: LD_INT 1
3914: PLUS
3915: PPUSH
3916: LD_VAR 0 2
3920: PPUSH
3921: CALL_OW 2
3925: ST_TO_ADDR
3926: GO 3831
3928: POP
3929: POP
// bunker_list := tmp ;
3930: LD_ADDR_VAR 0 13
3934: PUSH
3935: LD_VAR 0 8
3939: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
3940: LD_ADDR_VAR 0 2
3944: PUSH
3945: LD_VAR 0 13
3949: PUSH
3950: LD_VAR 0 14
3954: ADD
3955: PUSH
3956: FOR_IN
3957: IFFALSE 4054
// begin tmp := rand ( 0 , 100 ) ;
3959: LD_ADDR_VAR 0 8
3963: PUSH
3964: LD_INT 0
3966: PPUSH
3967: LD_INT 100
3969: PPUSH
3970: CALL_OW 12
3974: ST_TO_ADDR
// r := 0 ;
3975: LD_ADDR_VAR 0 4
3979: PUSH
3980: LD_INT 0
3982: ST_TO_ADDR
// for j in weapons_list do
3983: LD_ADDR_VAR 0 3
3987: PUSH
3988: LD_VAR 0 15
3992: PUSH
3993: FOR_IN
3994: IFFALSE 4050
// begin r := r + j [ 2 ] ;
3996: LD_ADDR_VAR 0 4
4000: PUSH
4001: LD_VAR 0 4
4005: PUSH
4006: LD_VAR 0 3
4010: PUSH
4011: LD_INT 2
4013: ARRAY
4014: PLUS
4015: ST_TO_ADDR
// if r >= tmp then
4016: LD_VAR 0 4
4020: PUSH
4021: LD_VAR 0 8
4025: GREATEREQUAL
4026: IFFALSE 4048
// begin PlaceWeaponTurret ( i , j [ 1 ] ) ;
4028: LD_VAR 0 2
4032: PPUSH
4033: LD_VAR 0 3
4037: PUSH
4038: LD_INT 1
4040: ARRAY
4041: PPUSH
4042: CALL_OW 431
// break ;
4046: GO 4050
// end ; end ;
4048: GO 3993
4050: POP
4051: POP
// end ;
4052: GO 3956
4054: POP
4055: POP
// while ( personel_counter [ 1 ] ) do
4056: LD_VAR 0 16
4060: PUSH
4061: LD_INT 1
4063: ARRAY
4064: IFFALSE 4172
// begin i := rand ( 1 , bunker_list ) ;
4066: LD_ADDR_VAR 0 2
4070: PUSH
4071: LD_INT 1
4073: PPUSH
4074: LD_VAR 0 13
4078: PPUSH
4079: CALL_OW 12
4083: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4084: LD_INT 0
4086: PPUSH
4087: LD_INT 1
4089: PPUSH
4090: LD_VAR 0 6
4094: PPUSH
4095: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
4099: CALL_OW 44
4103: PPUSH
4104: LD_VAR 0 13
4108: PUSH
4109: LD_VAR 0 2
4113: ARRAY
4114: PPUSH
4115: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
4119: LD_ADDR_VAR 0 13
4123: PUSH
4124: LD_VAR 0 13
4128: PPUSH
4129: LD_VAR 0 2
4133: PPUSH
4134: CALL_OW 3
4138: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
4139: LD_ADDR_VAR 0 16
4143: PUSH
4144: LD_VAR 0 16
4148: PPUSH
4149: LD_INT 1
4151: PPUSH
4152: LD_VAR 0 16
4156: PUSH
4157: LD_INT 1
4159: ARRAY
4160: PUSH
4161: LD_INT 1
4163: MINUS
4164: PPUSH
4165: CALL_OW 1
4169: ST_TO_ADDR
// end ;
4170: GO 4056
// for i = 1 to personel_counter [ 2 ] do
4172: LD_ADDR_VAR 0 2
4176: PUSH
4177: DOUBLE
4178: LD_INT 1
4180: DEC
4181: ST_TO_ADDR
4182: LD_VAR 0 16
4186: PUSH
4187: LD_INT 2
4189: ARRAY
4190: PUSH
4191: FOR_TO
4192: IFFALSE 4223
// begin PrepareHuman ( false , 2 , skill ) ;
4194: LD_INT 0
4196: PPUSH
4197: LD_INT 2
4199: PPUSH
4200: LD_VAR 0 6
4204: PPUSH
4205: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
4209: CALL_OW 44
4213: PPUSH
4214: LD_INT 16
4216: PPUSH
4217: CALL_OW 52
// end ;
4221: GO 4191
4223: POP
4224: POP
// for i = 1 to personel_counter [ 3 ] do
4225: LD_ADDR_VAR 0 2
4229: PUSH
4230: DOUBLE
4231: LD_INT 1
4233: DEC
4234: ST_TO_ADDR
4235: LD_VAR 0 16
4239: PUSH
4240: LD_INT 3
4242: ARRAY
4243: PUSH
4244: FOR_TO
4245: IFFALSE 4282
// begin PrepareHuman ( false , 3 , skill ) ;
4247: LD_INT 0
4249: PPUSH
4250: LD_INT 3
4252: PPUSH
4253: LD_VAR 0 6
4257: PPUSH
4258: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ 1 ] ) ;
4262: CALL_OW 44
4266: PPUSH
4267: LD_VAR 0 11
4271: PUSH
4272: LD_INT 1
4274: ARRAY
4275: PPUSH
4276: CALL_OW 52
// end ;
4280: GO 4244
4282: POP
4283: POP
// for i = 1 to personel_counter [ 4 ] do
4284: LD_ADDR_VAR 0 2
4288: PUSH
4289: DOUBLE
4290: LD_INT 1
4292: DEC
4293: ST_TO_ADDR
4294: LD_VAR 0 16
4298: PUSH
4299: LD_INT 4
4301: ARRAY
4302: PUSH
4303: FOR_TO
4304: IFFALSE 4341
// begin PrepareHuman ( false , 4 , skill ) ;
4306: LD_INT 0
4308: PPUSH
4309: LD_INT 4
4311: PPUSH
4312: LD_VAR 0 6
4316: PPUSH
4317: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
4321: CALL_OW 44
4325: PPUSH
4326: LD_VAR 0 10
4330: PUSH
4331: LD_INT 1
4333: ARRAY
4334: PPUSH
4335: CALL_OW 52
// end ;
4339: GO 4303
4341: POP
4342: POP
// for i in breastworks_list do
4343: LD_ADDR_VAR 0 2
4347: PUSH
4348: LD_VAR 0 12
4352: PUSH
4353: FOR_IN
4354: IFFALSE 4466
// begin r := GetDir ( i ) ;
4356: LD_ADDR_VAR 0 4
4360: PUSH
4361: LD_VAR 0 2
4365: PPUSH
4366: CALL_OW 254
4370: ST_TO_ADDR
// if r > 3 then
4371: LD_VAR 0 4
4375: PUSH
4376: LD_INT 3
4378: GREATER
4379: IFFALSE 4397
// r := r - 3 else
4381: LD_ADDR_VAR 0 4
4385: PUSH
4386: LD_VAR 0 4
4390: PUSH
4391: LD_INT 3
4393: MINUS
4394: ST_TO_ADDR
4395: GO 4411
// r := r + 3 ;
4397: LD_ADDR_VAR 0 4
4401: PUSH
4402: LD_VAR 0 4
4406: PUSH
4407: LD_INT 3
4409: PLUS
4410: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4411: LD_INT 0
4413: PPUSH
4414: LD_INT 1
4416: PPUSH
4417: LD_VAR 0 6
4421: PPUSH
4422: CALL_OW 380
// un := CreateHuman ;
4426: LD_ADDR_VAR 0 5
4430: PUSH
4431: CALL_OW 44
4435: ST_TO_ADDR
// SetDir ( un , r ) ;
4436: LD_VAR 0 5
4440: PPUSH
4441: LD_VAR 0 4
4445: PPUSH
4446: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
4450: LD_VAR 0 5
4454: PPUSH
4455: LD_VAR 0 2
4459: PPUSH
4460: CALL_OW 52
// end ;
4464: GO 4353
4466: POP
4467: POP
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
4468: LD_ADDR_VAR 0 8
4472: PUSH
4473: LD_INT 22
4475: PUSH
4476: LD_INT 3
4478: PUSH
4479: EMPTY
4480: LIST
4481: LIST
4482: PUSH
4483: LD_INT 25
4485: PUSH
4486: LD_INT 3
4488: PUSH
4489: EMPTY
4490: LIST
4491: LIST
4492: PUSH
4493: EMPTY
4494: LIST
4495: LIST
4496: PPUSH
4497: CALL_OW 69
4501: ST_TO_ADDR
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
4502: LD_ADDR_VAR 0 4
4506: PUSH
4507: LD_INT 4
4509: PUSH
4510: LD_INT 5
4512: PUSH
4513: LD_INT 6
4515: PUSH
4516: EMPTY
4517: LIST
4518: LIST
4519: LIST
4520: PUSH
4521: LD_OWVAR 67
4525: ARRAY
4526: ST_TO_ADDR
// for i = 1 to r do
4527: LD_ADDR_VAR 0 2
4531: PUSH
4532: DOUBLE
4533: LD_INT 1
4535: DEC
4536: ST_TO_ADDR
4537: LD_VAR 0 4
4541: PUSH
4542: FOR_TO
4543: IFFALSE 4712
// begin un := PrepareTank ( 3 , 3 , [ ru_medium_tracked , ru_medium_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
4545: LD_ADDR_VAR 0 5
4549: PUSH
4550: LD_INT 3
4552: PPUSH
4553: LD_INT 3
4555: PPUSH
4556: LD_INT 22
4558: PUSH
4559: LD_INT 22
4561: PUSH
4562: LD_INT 24
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: LIST
4569: PUSH
4570: LD_VAR 0 2
4574: PUSH
4575: LD_INT 3
4577: MOD
4578: PUSH
4579: LD_INT 1
4581: PLUS
4582: ARRAY
4583: PPUSH
4584: LD_INT 1
4586: PPUSH
4587: LD_INT 1
4589: PPUSH
4590: LD_INT 43
4592: PUSH
4593: LD_INT 44
4595: PUSH
4596: LD_INT 42
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: LIST
4603: PUSH
4604: LD_VAR 0 2
4608: PUSH
4609: LD_INT 3
4611: MOD
4612: PUSH
4613: LD_INT 1
4615: PLUS
4616: ARRAY
4617: PPUSH
4618: LD_INT 100
4620: PPUSH
4621: CALL 417 0 7
4625: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4626: LD_VAR 0 5
4630: PPUSH
4631: LD_INT 0
4633: PPUSH
4634: LD_INT 5
4636: PPUSH
4637: CALL_OW 12
4641: PPUSH
4642: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
4646: LD_VAR 0 5
4650: PPUSH
4651: LD_INT 5
4653: PPUSH
4654: LD_INT 0
4656: PPUSH
4657: CALL_OW 49
// if i > tmp then
4661: LD_VAR 0 2
4665: PUSH
4666: LD_VAR 0 8
4670: GREATER
4671: IFFALSE 4675
// continue ;
4673: GO 4542
// ComExitBuilding ( tmp [ i ] ) ;
4675: LD_VAR 0 8
4679: PUSH
4680: LD_VAR 0 2
4684: ARRAY
4685: PPUSH
4686: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , un ) ;
4690: LD_VAR 0 8
4694: PUSH
4695: LD_VAR 0 2
4699: ARRAY
4700: PPUSH
4701: LD_VAR 0 5
4705: PPUSH
4706: CALL_OW 180
// end ;
4710: GO 4542
4712: POP
4713: POP
// end ;
4714: LD_VAR 0 1
4718: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_ok ] ] ) do var i , filter , tmp , engs , enemy ;
4719: LD_INT 22
4721: PUSH
4722: LD_INT 3
4724: PUSH
4725: EMPTY
4726: LIST
4727: LIST
4728: PUSH
4729: LD_INT 25
4731: PUSH
4732: LD_INT 2
4734: PUSH
4735: EMPTY
4736: LIST
4737: LIST
4738: PUSH
4739: LD_INT 50
4741: PUSH
4742: EMPTY
4743: LIST
4744: PUSH
4745: EMPTY
4746: LIST
4747: LIST
4748: LIST
4749: PPUSH
4750: CALL_OW 69
4754: IFFALSE 5450
4756: GO 4758
4758: DISABLE
4759: LD_INT 0
4761: PPUSH
4762: PPUSH
4763: PPUSH
4764: PPUSH
4765: PPUSH
// begin enable ;
4766: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
4767: LD_ADDR_VAR 0 2
4771: PUSH
4772: LD_INT 6
4774: PPUSH
4775: LD_INT 3
4777: PUSH
4778: LD_INT 24
4780: PUSH
4781: LD_INT 1000
4783: PUSH
4784: EMPTY
4785: LIST
4786: LIST
4787: PUSH
4788: EMPTY
4789: LIST
4790: LIST
4791: PUSH
4792: LD_INT 21
4794: PUSH
4795: LD_INT 3
4797: PUSH
4798: EMPTY
4799: LIST
4800: LIST
4801: PUSH
4802: EMPTY
4803: LIST
4804: LIST
4805: PPUSH
4806: CALL_OW 70
4810: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_lives , 650 ] ] ) ;
4811: LD_ADDR_VAR 0 4
4815: PUSH
4816: LD_INT 22
4818: PUSH
4819: LD_INT 3
4821: PUSH
4822: EMPTY
4823: LIST
4824: LIST
4825: PUSH
4826: LD_INT 25
4828: PUSH
4829: LD_INT 2
4831: PUSH
4832: EMPTY
4833: LIST
4834: LIST
4835: PUSH
4836: LD_INT 24
4838: PUSH
4839: LD_INT 650
4841: PUSH
4842: EMPTY
4843: LIST
4844: LIST
4845: PUSH
4846: EMPTY
4847: LIST
4848: LIST
4849: LIST
4850: PPUSH
4851: CALL_OW 69
4855: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
4856: LD_VAR 0 2
4860: NOT
4861: PUSH
4862: LD_EXP 19
4866: NOT
4867: AND
4868: IFFALSE 4900
// begin if not IsInUnit ( engs [ 1 ] ) then
4870: LD_VAR 0 4
4874: PUSH
4875: LD_INT 1
4877: ARRAY
4878: PPUSH
4879: CALL_OW 310
4883: NOT
4884: IFFALSE 4898
// ComEnterUnit ( engs , ru_dep_main ) ;
4886: LD_VAR 0 4
4890: PPUSH
4891: LD_INT 16
4893: PPUSH
4894: CALL_OW 120
// exit ;
4898: GO 5450
// end ; if debug then
4900: LD_EXP 1
4904: IFFALSE 4925
// display_strings := [ engs , filter ] ;
4906: LD_ADDR_OWVAR 47
4910: PUSH
4911: LD_VAR 0 4
4915: PUSH
4916: LD_VAR 0 2
4920: PUSH
4921: EMPTY
4922: LIST
4923: LIST
4924: ST_TO_ADDR
// if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
4925: LD_VAR 0 4
4929: PPUSH
4930: LD_INT 3
4932: PUSH
4933: LD_INT 24
4935: PUSH
4936: LD_INT 650
4938: PUSH
4939: EMPTY
4940: LIST
4941: LIST
4942: PUSH
4943: EMPTY
4944: LIST
4945: LIST
4946: PPUSH
4947: CALL_OW 72
4951: IFFALSE 5044
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
4953: LD_ADDR_VAR 0 3
4957: PUSH
4958: LD_VAR 0 4
4962: PPUSH
4963: LD_INT 3
4965: PUSH
4966: LD_INT 24
4968: PUSH
4969: LD_INT 650
4971: PUSH
4972: EMPTY
4973: LIST
4974: LIST
4975: PUSH
4976: EMPTY
4977: LIST
4978: LIST
4979: PPUSH
4980: CALL_OW 72
4984: ST_TO_ADDR
// for i in tmp do
4985: LD_ADDR_VAR 0 1
4989: PUSH
4990: LD_VAR 0 3
4994: PUSH
4995: FOR_IN
4996: IFFALSE 5042
// if not IsInArea ( i , mainBaseArea ) then
4998: LD_VAR 0 1
5002: PPUSH
5003: LD_INT 14
5005: PPUSH
5006: CALL_OW 308
5010: NOT
5011: IFFALSE 5040
// begin ComMoveXY ( i , 129 , 125 ) ;
5013: LD_VAR 0 1
5017: PPUSH
5018: LD_INT 129
5020: PPUSH
5021: LD_INT 125
5023: PPUSH
5024: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
5028: LD_VAR 0 1
5032: PPUSH
5033: LD_INT 1050
5035: PPUSH
5036: CALL_OW 202
// end ;
5040: GO 4995
5042: POP
5043: POP
// end ; if filter then
5044: LD_VAR 0 2
5048: IFFALSE 5307
// begin for i in engs do
5050: LD_ADDR_VAR 0 1
5054: PUSH
5055: LD_VAR 0 4
5059: PUSH
5060: FOR_IN
5061: IFFALSE 5085
// if IsInUnit ( i ) then
5063: LD_VAR 0 1
5067: PPUSH
5068: CALL_OW 310
5072: IFFALSE 5083
// ComExitBuilding ( i ) ;
5074: LD_VAR 0 1
5078: PPUSH
5079: CALL_OW 122
5083: GO 5060
5085: POP
5086: POP
// wait ( 3 ) ;
5087: LD_INT 3
5089: PPUSH
5090: CALL_OW 67
// if filter >= 2 and engs >= 2 then
5094: LD_VAR 0 2
5098: PUSH
5099: LD_INT 2
5101: GREATEREQUAL
5102: PUSH
5103: LD_VAR 0 4
5107: PUSH
5108: LD_INT 2
5110: GREATEREQUAL
5111: AND
5112: IFFALSE 5260
// begin for i = 1 to engs / 2 do
5114: LD_ADDR_VAR 0 1
5118: PUSH
5119: DOUBLE
5120: LD_INT 1
5122: DEC
5123: ST_TO_ADDR
5124: LD_VAR 0 4
5128: PUSH
5129: LD_INT 2
5131: DIVREAL
5132: PUSH
5133: FOR_TO
5134: IFFALSE 5180
// if not HasTask ( engs [ i ] ) then
5136: LD_VAR 0 4
5140: PUSH
5141: LD_VAR 0 1
5145: ARRAY
5146: PPUSH
5147: CALL_OW 314
5151: NOT
5152: IFFALSE 5178
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
5154: LD_VAR 0 4
5158: PUSH
5159: LD_VAR 0 1
5163: ARRAY
5164: PPUSH
5165: LD_VAR 0 2
5169: PUSH
5170: LD_INT 1
5172: ARRAY
5173: PPUSH
5174: CALL_OW 130
5178: GO 5133
5180: POP
5181: POP
// for i = engs / 2 + 1 to engs do
5182: LD_ADDR_VAR 0 1
5186: PUSH
5187: DOUBLE
5188: LD_VAR 0 4
5192: PUSH
5193: LD_INT 2
5195: DIVREAL
5196: PUSH
5197: LD_INT 1
5199: PLUS
5200: DEC
5201: ST_TO_ADDR
5202: LD_VAR 0 4
5206: PUSH
5207: FOR_TO
5208: IFFALSE 5256
// if not HasTask ( engs [ i ] ) then
5210: LD_VAR 0 4
5214: PUSH
5215: LD_VAR 0 1
5219: ARRAY
5220: PPUSH
5221: CALL_OW 314
5225: NOT
5226: IFFALSE 5254
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
5228: LD_VAR 0 4
5232: PUSH
5233: LD_VAR 0 1
5237: ARRAY
5238: PPUSH
5239: LD_VAR 0 2
5243: PUSH
5244: LD_VAR 0 2
5248: ARRAY
5249: PPUSH
5250: CALL_OW 130
5254: GO 5207
5256: POP
5257: POP
// end else
5258: GO 5307
// for i in engs do
5260: LD_ADDR_VAR 0 1
5264: PUSH
5265: LD_VAR 0 4
5269: PUSH
5270: FOR_IN
5271: IFFALSE 5305
// if not HasTask ( i ) then
5273: LD_VAR 0 1
5277: PPUSH
5278: CALL_OW 314
5282: NOT
5283: IFFALSE 5303
// ComRepairBuilding ( i , filter [ 1 ] ) ;
5285: LD_VAR 0 1
5289: PPUSH
5290: LD_VAR 0 2
5294: PUSH
5295: LD_INT 1
5297: ARRAY
5298: PPUSH
5299: CALL_OW 130
5303: GO 5270
5305: POP
5306: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
5307: LD_ADDR_VAR 0 5
5311: PUSH
5312: LD_INT 81
5314: PUSH
5315: LD_INT 3
5317: PUSH
5318: EMPTY
5319: LIST
5320: LIST
5321: PPUSH
5322: CALL_OW 69
5326: ST_TO_ADDR
// if ru_rebuild_list and not filter then
5327: LD_EXP 19
5331: PUSH
5332: LD_VAR 0 2
5336: NOT
5337: AND
5338: IFFALSE 5450
// begin ComExitBuilding ( engs ) ;
5340: LD_VAR 0 4
5344: PPUSH
5345: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
5349: LD_VAR 0 5
5353: PPUSH
5354: LD_EXP 19
5358: PUSH
5359: LD_INT 2
5361: ARRAY
5362: PPUSH
5363: LD_EXP 19
5367: PUSH
5368: LD_INT 3
5370: ARRAY
5371: PPUSH
5372: CALL_OW 73
5376: PPUSH
5377: LD_EXP 19
5381: PUSH
5382: LD_INT 2
5384: ARRAY
5385: PPUSH
5386: LD_EXP 19
5390: PUSH
5391: LD_INT 3
5393: ARRAY
5394: PPUSH
5395: CALL_OW 297
5399: PUSH
5400: LD_INT 10
5402: GREATER
5403: IFFALSE 5450
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
5405: LD_VAR 0 4
5409: PPUSH
5410: LD_EXP 19
5414: PUSH
5415: LD_INT 1
5417: ARRAY
5418: PPUSH
5419: LD_EXP 19
5423: PUSH
5424: LD_INT 2
5426: ARRAY
5427: PPUSH
5428: LD_EXP 19
5432: PUSH
5433: LD_INT 3
5435: ARRAY
5436: PPUSH
5437: LD_EXP 19
5441: PUSH
5442: LD_INT 4
5444: ARRAY
5445: PPUSH
5446: CALL_OW 145
// end ; end ;
5450: PPOPN 5
5452: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 650 do var tmp ;
5453: LD_INT 16
5455: PPUSH
5456: CALL_OW 256
5460: PUSH
5461: LD_INT 650
5463: LESS
5464: IFFALSE 5547
5466: GO 5468
5468: DISABLE
5469: LD_INT 0
5471: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
5472: LD_ADDR_VAR 0 1
5476: PUSH
5477: LD_INT 22
5479: PUSH
5480: LD_INT 3
5482: PUSH
5483: EMPTY
5484: LIST
5485: LIST
5486: PUSH
5487: LD_INT 25
5489: PUSH
5490: LD_INT 1
5492: PUSH
5493: EMPTY
5494: LIST
5495: LIST
5496: PUSH
5497: EMPTY
5498: LIST
5499: LIST
5500: PPUSH
5501: CALL_OW 69
5505: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
5506: LD_VAR 0 1
5510: PPUSH
5511: CALL_OW 122
// wait ( 3 ) ;
5515: LD_INT 3
5517: PPUSH
5518: CALL_OW 67
// ComAgressiveMove ( tmp , GetX ( ru_dep_main ) , GetY ( ru_dep_main ) ) ;
5522: LD_VAR 0 1
5526: PPUSH
5527: LD_INT 16
5529: PPUSH
5530: CALL_OW 250
5534: PPUSH
5535: LD_INT 16
5537: PPUSH
5538: CALL_OW 251
5542: PPUSH
5543: CALL_OW 114
// end ;
5547: PPOPN 1
5549: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
5550: LD_INT 22
5552: PUSH
5553: LD_INT 3
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: PUSH
5560: LD_INT 25
5562: PUSH
5563: LD_INT 4
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PPUSH
5574: CALL_OW 69
5578: IFFALSE 5832
5580: GO 5582
5582: DISABLE
5583: LD_INT 0
5585: PPUSH
5586: PPUSH
5587: PPUSH
// begin enable ;
5588: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5589: LD_ADDR_VAR 0 2
5593: PUSH
5594: LD_INT 14
5596: PPUSH
5597: LD_INT 22
5599: PUSH
5600: LD_INT 3
5602: PUSH
5603: EMPTY
5604: LIST
5605: LIST
5606: PUSH
5607: LD_INT 21
5609: PUSH
5610: LD_INT 1
5612: PUSH
5613: EMPTY
5614: LIST
5615: LIST
5616: PUSH
5617: LD_INT 3
5619: PUSH
5620: LD_INT 24
5622: PUSH
5623: LD_INT 1000
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: PPUSH
5639: CALL_OW 70
5643: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
5644: LD_ADDR_VAR 0 3
5648: PUSH
5649: LD_INT 22
5651: PUSH
5652: LD_INT 3
5654: PUSH
5655: EMPTY
5656: LIST
5657: LIST
5658: PUSH
5659: LD_INT 25
5661: PUSH
5662: LD_INT 4
5664: PUSH
5665: EMPTY
5666: LIST
5667: LIST
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: PPUSH
5673: CALL_OW 69
5677: ST_TO_ADDR
// if not doc then
5678: LD_VAR 0 3
5682: NOT
5683: IFFALSE 5687
// exit ;
5685: GO 5832
// if not tmp then
5687: LD_VAR 0 2
5691: NOT
5692: IFFALSE 5783
// begin if not IsInUnit ( doc [ 1 ] ) then
5694: LD_VAR 0 3
5698: PUSH
5699: LD_INT 1
5701: ARRAY
5702: PPUSH
5703: CALL_OW 310
5707: NOT
5708: IFFALSE 5781
// ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
5710: LD_VAR 0 3
5714: PPUSH
5715: LD_INT 22
5717: PUSH
5718: LD_INT 3
5720: PUSH
5721: EMPTY
5722: LIST
5723: LIST
5724: PUSH
5725: LD_INT 2
5727: PUSH
5728: LD_INT 30
5730: PUSH
5731: LD_INT 6
5733: PUSH
5734: EMPTY
5735: LIST
5736: LIST
5737: PUSH
5738: LD_INT 30
5740: PUSH
5741: LD_INT 7
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: PUSH
5748: LD_INT 30
5750: PUSH
5751: LD_INT 8
5753: PUSH
5754: EMPTY
5755: LIST
5756: LIST
5757: PUSH
5758: EMPTY
5759: LIST
5760: LIST
5761: LIST
5762: LIST
5763: PUSH
5764: EMPTY
5765: LIST
5766: LIST
5767: PPUSH
5768: CALL_OW 69
5772: PUSH
5773: LD_INT 1
5775: ARRAY
5776: PPUSH
5777: CALL_OW 120
// exit ;
5781: GO 5832
// end ; if IsInUnit ( doc [ 1 ] ) then
5783: LD_VAR 0 3
5787: PUSH
5788: LD_INT 1
5790: ARRAY
5791: PPUSH
5792: CALL_OW 310
5796: IFFALSE 5807
// ComExitBuilding ( doc ) ;
5798: LD_VAR 0 3
5802: PPUSH
5803: CALL_OW 122
// wait ( 3 ) ;
5807: LD_INT 3
5809: PPUSH
5810: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
5814: LD_VAR 0 3
5818: PPUSH
5819: LD_VAR 0 2
5823: PUSH
5824: LD_INT 1
5826: ARRAY
5827: PPUSH
5828: CALL_OW 128
// end ;
5832: PPOPN 3
5834: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , tmp , areas , area ;
5835: LD_INT 22
5837: PUSH
5838: LD_INT 3
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: PUSH
5845: LD_INT 25
5847: PUSH
5848: LD_INT 3
5850: PUSH
5851: EMPTY
5852: LIST
5853: LIST
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PPUSH
5859: CALL_OW 69
5863: PUSH
5864: LD_INT 22
5866: PUSH
5867: LD_INT 3
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: PUSH
5874: LD_INT 21
5876: PUSH
5877: LD_INT 2
5879: PUSH
5880: EMPTY
5881: LIST
5882: LIST
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: PPUSH
5888: CALL_OW 69
5892: AND
5893: IFFALSE 6115
5895: GO 5897
5897: DISABLE
5898: LD_INT 0
5900: PPUSH
5901: PPUSH
5902: PPUSH
5903: PPUSH
// begin enable ;
5904: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
5905: LD_ADDR_VAR 0 2
5909: PUSH
5910: LD_INT 22
5912: PUSH
5913: LD_INT 3
5915: PUSH
5916: EMPTY
5917: LIST
5918: LIST
5919: PUSH
5920: LD_INT 21
5922: PUSH
5923: LD_INT 2
5925: PUSH
5926: EMPTY
5927: LIST
5928: LIST
5929: PUSH
5930: LD_INT 3
5932: PUSH
5933: LD_INT 58
5935: PUSH
5936: EMPTY
5937: LIST
5938: PUSH
5939: EMPTY
5940: LIST
5941: LIST
5942: PUSH
5943: EMPTY
5944: LIST
5945: LIST
5946: LIST
5947: PPUSH
5948: CALL_OW 69
5952: ST_TO_ADDR
// areas := [ sectorAlpha , sectorBeta , sectorDelta , mainBaseArea ] ;
5953: LD_ADDR_VAR 0 3
5957: PUSH
5958: LD_INT 10
5960: PUSH
5961: LD_INT 11
5963: PUSH
5964: LD_INT 12
5966: PUSH
5967: LD_INT 14
5969: PUSH
5970: EMPTY
5971: LIST
5972: LIST
5973: LIST
5974: LIST
5975: ST_TO_ADDR
// area := 0 ;
5976: LD_ADDR_VAR 0 4
5980: PUSH
5981: LD_INT 0
5983: ST_TO_ADDR
// for i in areas do
5984: LD_ADDR_VAR 0 1
5988: PUSH
5989: LD_VAR 0 3
5993: PUSH
5994: FOR_IN
5995: IFFALSE 6032
// if FilterUnitsInArea ( i , [ f_side , 1 ] ) then
5997: LD_VAR 0 1
6001: PPUSH
6002: LD_INT 22
6004: PUSH
6005: LD_INT 1
6007: PUSH
6008: EMPTY
6009: LIST
6010: LIST
6011: PPUSH
6012: CALL_OW 70
6016: IFFALSE 6030
// begin area := i ;
6018: LD_ADDR_VAR 0 4
6022: PUSH
6023: LD_VAR 0 1
6027: ST_TO_ADDR
// break ;
6028: GO 6032
// end ;
6030: GO 5994
6032: POP
6033: POP
// if area then
6034: LD_VAR 0 4
6038: IFFALSE 6115
// begin for i in tmp do
6040: LD_ADDR_VAR 0 1
6044: PUSH
6045: LD_VAR 0 2
6049: PUSH
6050: FOR_IN
6051: IFFALSE 6113
// begin if GetFuel ( i ) < 33 then
6053: LD_VAR 0 1
6057: PPUSH
6058: CALL_OW 261
6062: PUSH
6063: LD_INT 33
6065: LESS
6066: IFFALSE 6080
// SetFuel ( i , 33 ) ;
6068: LD_VAR 0 1
6072: PPUSH
6073: LD_INT 33
6075: PPUSH
6076: CALL_OW 240
// if not IsInArea ( i , area ) then
6080: LD_VAR 0 1
6084: PPUSH
6085: LD_VAR 0 4
6089: PPUSH
6090: CALL_OW 308
6094: NOT
6095: IFFALSE 6111
// ComMoveToArea ( i , area ) ;
6097: LD_VAR 0 1
6101: PPUSH
6102: LD_VAR 0 4
6106: PPUSH
6107: CALL_OW 113
// end ;
6111: GO 6050
6113: POP
6114: POP
// end ; end ;
6115: PPOPN 4
6117: END
// every 10 10$00 do var i , j , un , veh , time , count ;
6118: GO 6120
6120: DISABLE
6121: LD_INT 0
6123: PPUSH
6124: PPUSH
6125: PPUSH
6126: PPUSH
6127: PPUSH
6128: PPUSH
// begin uc_side := 3 ;
6129: LD_ADDR_OWVAR 20
6133: PUSH
6134: LD_INT 3
6136: ST_TO_ADDR
// uc_nation := 3 ;
6137: LD_ADDR_OWVAR 21
6141: PUSH
6142: LD_INT 3
6144: ST_TO_ADDR
// time := [ 6 6$00 , 5 5$00 , 4 4$00 ] [ Difficulty ] ;
6145: LD_ADDR_VAR 0 5
6149: PUSH
6150: LD_INT 12600
6152: PUSH
6153: LD_INT 10500
6155: PUSH
6156: LD_INT 8400
6158: PUSH
6159: EMPTY
6160: LIST
6161: LIST
6162: LIST
6163: PUSH
6164: LD_OWVAR 67
6168: ARRAY
6169: ST_TO_ADDR
// count := [ 3 , 4 , 5 ] [ Difficulty ] ;
6170: LD_ADDR_VAR 0 6
6174: PUSH
6175: LD_INT 3
6177: PUSH
6178: LD_INT 4
6180: PUSH
6181: LD_INT 5
6183: PUSH
6184: EMPTY
6185: LIST
6186: LIST
6187: LIST
6188: PUSH
6189: LD_OWVAR 67
6193: ARRAY
6194: ST_TO_ADDR
// for i = 1 to count do
6195: LD_ADDR_VAR 0 1
6199: PUSH
6200: DOUBLE
6201: LD_INT 1
6203: DEC
6204: ST_TO_ADDR
6205: LD_VAR 0 6
6209: PUSH
6210: FOR_TO
6211: IFFALSE 6506
// begin wait ( time ) ;
6213: LD_VAR 0 5
6217: PPUSH
6218: CALL_OW 67
// for j = 1 to rand ( 1 , Difficulty ) do
6222: LD_ADDR_VAR 0 2
6226: PUSH
6227: DOUBLE
6228: LD_INT 1
6230: DEC
6231: ST_TO_ADDR
6232: LD_INT 1
6234: PPUSH
6235: LD_OWVAR 67
6239: PPUSH
6240: CALL_OW 12
6244: PUSH
6245: FOR_TO
6246: IFFALSE 6387
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 80 ) ;
6248: LD_ADDR_VAR 0 4
6252: PUSH
6253: LD_INT 3
6255: PPUSH
6256: LD_INT 3
6258: PPUSH
6259: LD_INT 22
6261: PPUSH
6262: LD_INT 1
6264: PPUSH
6265: LD_INT 1
6267: PPUSH
6268: LD_INT 43
6270: PUSH
6271: LD_INT 44
6273: PUSH
6274: LD_INT 42
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: LIST
6281: PUSH
6282: LD_VAR 0 1
6286: PUSH
6287: LD_INT 3
6289: MOD
6290: PUSH
6291: LD_INT 1
6293: PLUS
6294: ARRAY
6295: PPUSH
6296: LD_INT 80
6298: PPUSH
6299: CALL 417 0 7
6303: ST_TO_ADDR
// PlaceUnitArea ( veh , southArea , false ) ;
6304: LD_VAR 0 4
6308: PPUSH
6309: LD_INT 13
6311: PPUSH
6312: LD_INT 0
6314: PPUSH
6315: CALL_OW 49
// PrepareHuman ( false , 3 , [ 4 , 5 , 5 ] [ Difficulty ] ) ;
6319: LD_INT 0
6321: PPUSH
6322: LD_INT 3
6324: PPUSH
6325: LD_INT 4
6327: PUSH
6328: LD_INT 5
6330: PUSH
6331: LD_INT 5
6333: PUSH
6334: EMPTY
6335: LIST
6336: LIST
6337: LIST
6338: PUSH
6339: LD_OWVAR 67
6343: ARRAY
6344: PPUSH
6345: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6349: CALL_OW 44
6353: PPUSH
6354: LD_VAR 0 4
6358: PPUSH
6359: CALL_OW 52
// wait ( 0 0$01 ) ;
6363: LD_INT 35
6365: PPUSH
6366: CALL_OW 67
// ComMoveXY ( veh , 143 , 143 ) ;
6370: LD_VAR 0 4
6374: PPUSH
6375: LD_INT 143
6377: PPUSH
6378: LD_INT 143
6380: PPUSH
6381: CALL_OW 111
// end ;
6385: GO 6245
6387: POP
6388: POP
// if count < 3 then
6389: LD_VAR 0 6
6393: PUSH
6394: LD_INT 3
6396: LESS
6397: IFFALSE 6401
// continue ;
6399: GO 6210
// for j = 1 to 1 + Difficulty do
6401: LD_ADDR_VAR 0 2
6405: PUSH
6406: DOUBLE
6407: LD_INT 1
6409: DEC
6410: ST_TO_ADDR
6411: LD_INT 1
6413: PUSH
6414: LD_OWVAR 67
6418: PLUS
6419: PUSH
6420: FOR_TO
6421: IFFALSE 6502
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
6423: LD_INT 0
6425: PPUSH
6426: LD_INT 1
6428: PPUSH
6429: LD_INT 4
6431: PUSH
6432: LD_INT 5
6434: PUSH
6435: LD_INT 6
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: LIST
6442: PUSH
6443: LD_OWVAR 67
6447: ARRAY
6448: PPUSH
6449: CALL_OW 380
// un := CreateHuman ;
6453: LD_ADDR_VAR 0 3
6457: PUSH
6458: CALL_OW 44
6462: ST_TO_ADDR
// PlaceUnitArea ( un , southArea , false ) ;
6463: LD_VAR 0 3
6467: PPUSH
6468: LD_INT 13
6470: PPUSH
6471: LD_INT 0
6473: PPUSH
6474: CALL_OW 49
// ComMoveXY ( un , 143 , 143 ) ;
6478: LD_VAR 0 3
6482: PPUSH
6483: LD_INT 143
6485: PPUSH
6486: LD_INT 143
6488: PPUSH
6489: CALL_OW 111
// wait ( 0 0$01 ) ;
6493: LD_INT 35
6495: PPUSH
6496: CALL_OW 67
// end ;
6500: GO 6420
6502: POP
6503: POP
// end ;
6504: GO 6210
6506: POP
6507: POP
// end ;
6508: PPOPN 6
6510: END
// every 4 4$00 do var i , un , time ;
6511: GO 6513
6513: DISABLE
6514: LD_INT 0
6516: PPUSH
6517: PPUSH
6518: PPUSH
// begin time := [ 2 2$00 , 1 1$00 , 0 0$30 ] ;
6519: LD_ADDR_VAR 0 3
6523: PUSH
6524: LD_INT 4200
6526: PUSH
6527: LD_INT 2100
6529: PUSH
6530: LD_INT 1050
6532: PUSH
6533: EMPTY
6534: LIST
6535: LIST
6536: LIST
6537: ST_TO_ADDR
// wait ( time ) ;
6538: LD_VAR 0 3
6542: PPUSH
6543: CALL_OW 67
// uc_side := 3 ;
6547: LD_ADDR_OWVAR 20
6551: PUSH
6552: LD_INT 3
6554: ST_TO_ADDR
// uc_nation := 3 ;
6555: LD_ADDR_OWVAR 21
6559: PUSH
6560: LD_INT 3
6562: ST_TO_ADDR
// for i = 1 to 2 do
6563: LD_ADDR_VAR 0 1
6567: PUSH
6568: DOUBLE
6569: LD_INT 1
6571: DEC
6572: ST_TO_ADDR
6573: LD_INT 2
6575: PUSH
6576: FOR_TO
6577: IFFALSE 6640
// begin PrepareHuman ( false , 1 , 4 ) ;
6579: LD_INT 0
6581: PPUSH
6582: LD_INT 1
6584: PPUSH
6585: LD_INT 4
6587: PPUSH
6588: CALL_OW 380
// un := CreateHuman ;
6592: LD_ADDR_VAR 0 2
6596: PUSH
6597: CALL_OW 44
6601: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_dep_main ) ;
6602: LD_VAR 0 2
6606: PPUSH
6607: LD_INT 16
6609: PPUSH
6610: CALL_OW 52
// ComExitBuilding ( un ) ;
6614: LD_VAR 0 2
6618: PPUSH
6619: CALL_OW 122
// AddComAgressiveMove ( un , 41 , 76 ) ;
6623: LD_VAR 0 2
6627: PPUSH
6628: LD_INT 41
6630: PPUSH
6631: LD_INT 76
6633: PPUSH
6634: CALL_OW 174
// end ;
6638: GO 6576
6640: POP
6641: POP
// end ; end_of_file
6642: PPOPN 3
6644: END
// export function Action ; begin
6645: LD_INT 0
6647: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
6648: LD_INT 28
6650: PPUSH
6651: LD_INT 3
6653: PPUSH
6654: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
6658: LD_INT 41
6660: PPUSH
6661: LD_INT 76
6663: PPUSH
6664: LD_INT 1
6666: PPUSH
6667: LD_INT 10
6669: PPUSH
6670: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
6674: LD_INT 41
6676: PPUSH
6677: LD_INT 76
6679: PPUSH
6680: LD_INT 1
6682: PPUSH
6683: CALL_OW 331
// InGameOn ;
6687: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
6691: LD_EXP 18
6695: PPUSH
6696: LD_STRING D2-Har-1
6698: PPUSH
6699: CALL_OW 94
// InGameOff ;
6703: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6707: LD_STRING M1
6709: PPUSH
6710: CALL_OW 337
// end ;
6714: LD_VAR 0 1
6718: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
6719: LD_EXP 4
6723: PUSH
6724: LD_INT 1
6726: GREATER
6727: IFFALSE 6818
6729: GO 6731
6731: DISABLE
6732: LD_INT 0
6734: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
6735: LD_ADDR_VAR 0 1
6739: PUSH
6740: LD_INT 1
6742: PPUSH
6743: CALL 505 0 1
6747: PUSH
6748: LD_INT 1
6750: ARRAY
6751: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
6752: LD_VAR 0 1
6756: PPUSH
6757: LD_STRING D2a-Sol1-1
6759: PPUSH
6760: CALL_OW 88
// if not un then
6764: LD_VAR 0 1
6768: NOT
6769: IFFALSE 6800
// begin un := GetRandom ( sex_female ) [ 1 ] ;
6771: LD_ADDR_VAR 0 1
6775: PUSH
6776: LD_INT 2
6778: PPUSH
6779: CALL 505 0 1
6783: PUSH
6784: LD_INT 1
6786: ARRAY
6787: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
6788: LD_VAR 0 1
6792: PPUSH
6793: LD_STRING D2a-FSol1-1
6795: PPUSH
6796: CALL_OW 88
// end ; if Khatam then
6800: LD_EXP 16
6804: IFFALSE 6818
// Say ( Khatam , D3b-Khat-3 ) ;
6806: LD_EXP 16
6810: PPUSH
6811: LD_STRING D3b-Khat-3
6813: PPUSH
6814: CALL_OW 88
// end ;
6818: PPOPN 1
6820: END
// every 0 0$1 trigger Frank and GetDistUnits ( JMM , Frank ) < 5 and not InBattle ( 1 ) do var i , ape ;
6821: LD_EXP 14
6825: PUSH
6826: LD_EXP 8
6830: PPUSH
6831: LD_EXP 14
6835: PPUSH
6836: CALL_OW 296
6840: PUSH
6841: LD_INT 5
6843: LESS
6844: AND
6845: PUSH
6846: LD_INT 1
6848: PPUSH
6849: CALL_OW 463
6853: NOT
6854: AND
6855: IFFALSE 7442
6857: GO 6859
6859: DISABLE
6860: LD_INT 0
6862: PPUSH
6863: PPUSH
// begin InGameOn ;
6864: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6868: LD_ADDR_VAR 0 2
6872: PUSH
6873: LD_INT 22
6875: PUSH
6876: LD_INT 0
6878: PUSH
6879: EMPTY
6880: LIST
6881: LIST
6882: PUSH
6883: LD_INT 25
6885: PUSH
6886: LD_INT 12
6888: PUSH
6889: EMPTY
6890: LIST
6891: LIST
6892: PUSH
6893: EMPTY
6894: LIST
6895: LIST
6896: PPUSH
6897: CALL_OW 69
6901: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
6902: LD_ADDR_VAR 0 2
6906: PUSH
6907: LD_VAR 0 2
6911: PPUSH
6912: LD_EXP 14
6916: PPUSH
6917: CALL_OW 74
6921: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
6922: LD_ADDR_VAR 0 1
6926: PUSH
6927: LD_INT 22
6929: PUSH
6930: LD_INT 1
6932: PUSH
6933: EMPTY
6934: LIST
6935: LIST
6936: PUSH
6937: LD_INT 21
6939: PUSH
6940: LD_INT 1
6942: PUSH
6943: EMPTY
6944: LIST
6945: LIST
6946: PUSH
6947: LD_INT 91
6949: PUSH
6950: LD_EXP 14
6954: PUSH
6955: LD_INT 20
6957: PUSH
6958: EMPTY
6959: LIST
6960: LIST
6961: LIST
6962: PUSH
6963: EMPTY
6964: LIST
6965: LIST
6966: LIST
6967: PPUSH
6968: CALL_OW 69
6972: PUSH
6973: FOR_IN
6974: IFFALSE 6992
// ComTurnUnit ( i , Frank ) ;
6976: LD_VAR 0 1
6980: PPUSH
6981: LD_EXP 14
6985: PPUSH
6986: CALL_OW 119
6990: GO 6973
6992: POP
6993: POP
// SetSide ( Frank , 1 ) ;
6994: LD_EXP 14
6998: PPUSH
6999: LD_INT 1
7001: PPUSH
7002: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
7006: LD_EXP 8
7010: PPUSH
7011: LD_EXP 14
7015: PPUSH
7016: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
7020: LD_EXP 8
7024: PPUSH
7025: LD_EXP 14
7029: PPUSH
7030: CALL_OW 179
// CenterOnUnits ( Frank ) ;
7034: LD_EXP 14
7038: PPUSH
7039: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
7043: LD_EXP 14
7047: PPUSH
7048: LD_STRING D3a-Frank-1
7050: PPUSH
7051: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
7055: LD_VAR 0 2
7059: PPUSH
7060: LD_INT 42
7062: PPUSH
7063: LD_INT 78
7065: PPUSH
7066: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
7070: LD_VAR 0 2
7074: PPUSH
7075: LD_EXP 14
7079: PPUSH
7080: CALL_OW 179
// if Lisa then
7084: LD_EXP 13
7088: IFFALSE 7102
// Say ( Lisa , D3a-Lisa-1 ) ;
7090: LD_EXP 13
7094: PPUSH
7095: LD_STRING D3a-Lisa-1
7097: PPUSH
7098: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
7102: LD_EXP 8
7106: PPUSH
7107: LD_STRING D3a-JMM-1
7109: PPUSH
7110: CALL_OW 88
// if Cyrus then
7114: LD_EXP 12
7118: IFFALSE 7132
// Say ( Cyrus , D3a-Cyrus-1 ) ;
7120: LD_EXP 12
7124: PPUSH
7125: LD_STRING D3a-Cyrus-1
7127: PPUSH
7128: CALL_OW 88
// if GetRandom ( sex_male ) then
7132: LD_INT 1
7134: PPUSH
7135: CALL 505 0 1
7139: IFFALSE 7160
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
7141: LD_INT 1
7143: PPUSH
7144: CALL 505 0 1
7148: PUSH
7149: LD_INT 1
7151: ARRAY
7152: PPUSH
7153: LD_STRING D3a-Sol1-1
7155: PPUSH
7156: CALL_OW 88
// if GetRandom ( sex_female ) then
7160: LD_INT 2
7162: PPUSH
7163: CALL 505 0 1
7167: IFFALSE 7188
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
7169: LD_INT 2
7171: PPUSH
7172: CALL 505 0 1
7176: PUSH
7177: LD_INT 1
7179: ARRAY
7180: PPUSH
7181: LD_STRING D3a-FSol1-1
7183: PPUSH
7184: CALL_OW 88
// if Gladstone then
7188: LD_EXP 15
7192: IFFALSE 7206
// Say ( Gladstone , D3a-Glad-1 ) ;
7194: LD_EXP 15
7198: PPUSH
7199: LD_STRING D3a-Glad-1
7201: PPUSH
7202: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
7206: LD_VAR 0 2
7210: PPUSH
7211: LD_INT 60
7213: PPUSH
7214: LD_INT 113
7216: PPUSH
7217: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
7221: LD_EXP 14
7225: PPUSH
7226: LD_STRING D3a-Frank-2
7228: PPUSH
7229: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
7233: LD_EXP 14
7237: PPUSH
7238: LD_EXP 8
7242: PPUSH
7243: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
7247: LD_EXP 8
7251: PPUSH
7252: LD_STRING D3a-JMM-2
7254: PPUSH
7255: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
7259: LD_INT 1
7261: PPUSH
7262: LD_INT 4
7264: PPUSH
7265: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
7269: LD_INT 85
7271: PPUSH
7272: LD_INT 134
7274: PPUSH
7275: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
7279: LD_EXP 14
7283: PPUSH
7284: LD_STRING D3a-Frank-3
7286: PPUSH
7287: CALL_OW 88
// Wait ( 0 0$01 ) ;
7291: LD_INT 35
7293: PPUSH
7294: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
7298: LD_INT 166
7300: PPUSH
7301: LD_INT 136
7303: PPUSH
7304: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
7308: LD_EXP 8
7312: PPUSH
7313: LD_STRING D3a-JMM-3
7315: PPUSH
7316: CALL_OW 88
// Wait ( 0 0$01 ) ;
7320: LD_INT 35
7322: PPUSH
7323: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
7327: LD_EXP 14
7331: PPUSH
7332: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
7336: LD_EXP 14
7340: PPUSH
7341: LD_STRING D3a-Frank-4
7343: PPUSH
7344: CALL_OW 88
// if Lisa then
7348: LD_EXP 13
7352: IFFALSE 7366
// Say ( Lisa , D3a-Lisa-4 ) ;
7354: LD_EXP 13
7358: PPUSH
7359: LD_STRING D3a-Lisa-4
7361: PPUSH
7362: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
7366: LD_EXP 8
7370: PPUSH
7371: LD_STRING D3a-JMM-4
7373: PPUSH
7374: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
7378: LD_EXP 14
7382: PPUSH
7383: LD_STRING D3a-Frank-5
7385: PPUSH
7386: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
7390: LD_EXP 8
7394: PPUSH
7395: LD_STRING D3a-JMM-5
7397: PPUSH
7398: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
7402: LD_EXP 14
7406: PPUSH
7407: LD_STRING D3a-Frank-6
7409: PPUSH
7410: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
7414: LD_EXP 8
7418: PPUSH
7419: LD_STRING D3a-JMM-6
7421: PPUSH
7422: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
7426: LD_EXP 14
7430: PPUSH
7431: LD_STRING D3a-Frank-7
7433: PPUSH
7434: CALL_OW 88
// InGameOff ;
7438: CALL_OW 9
// end ;
7442: PPOPN 2
7444: END
// every 0 0$1 trigger Kikuchi and GetDistUnits ( JMM , Kikuchi ) < 5 and not InBattle ( 1 ) do
7445: LD_EXP 17
7449: PUSH
7450: LD_EXP 8
7454: PPUSH
7455: LD_EXP 17
7459: PPUSH
7460: CALL_OW 296
7464: PUSH
7465: LD_INT 5
7467: LESS
7468: AND
7469: PUSH
7470: LD_INT 1
7472: PPUSH
7473: CALL_OW 463
7477: NOT
7478: AND
7479: IFFALSE 7659
7481: GO 7483
7483: DISABLE
// begin InGameOn ;
7484: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
7488: LD_EXP 8
7492: PPUSH
7493: LD_EXP 17
7497: PPUSH
7498: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
7502: LD_EXP 17
7506: PPUSH
7507: LD_EXP 8
7511: PPUSH
7512: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
7516: LD_EXP 17
7520: PPUSH
7521: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
7525: LD_EXP 17
7529: PPUSH
7530: LD_STRING D3b-Yam-1
7532: PPUSH
7533: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
7537: LD_EXP 8
7541: PPUSH
7542: LD_STRING D3b-JMM-1
7544: PPUSH
7545: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
7549: LD_INT 1
7551: PPUSH
7552: LD_INT 4
7554: PPUSH
7555: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
7559: LD_INT 85
7561: PPUSH
7562: LD_INT 134
7564: PPUSH
7565: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
7569: LD_EXP 17
7573: PPUSH
7574: LD_STRING D3b-Yam-2
7576: PPUSH
7577: CALL_OW 88
// Wait ( 0 0$01 ) ;
7581: LD_INT 35
7583: PPUSH
7584: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
7588: LD_EXP 8
7592: PPUSH
7593: LD_STRING D3b-JMM-2
7595: PPUSH
7596: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
7600: LD_INT 166
7602: PPUSH
7603: LD_INT 136
7605: PPUSH
7606: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
7610: LD_EXP 17
7614: PPUSH
7615: LD_STRING D3b-Yam-3
7617: PPUSH
7618: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
7622: LD_EXP 8
7626: PPUSH
7627: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
7631: LD_EXP 8
7635: PPUSH
7636: LD_STRING D3b-JMM-3a
7638: PPUSH
7639: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
7643: LD_EXP 17
7647: PPUSH
7648: LD_INT 1
7650: PPUSH
7651: CALL_OW 235
// InGameOff ;
7655: CALL_OW 9
// end ;
7659: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , i ;
7660: LD_INT 7
7662: PPUSH
7663: LD_INT 22
7665: PUSH
7666: LD_INT 1
7668: PUSH
7669: EMPTY
7670: LIST
7671: LIST
7672: PUSH
7673: LD_INT 3
7675: PUSH
7676: LD_INT 24
7678: PUSH
7679: LD_INT 1000
7681: PUSH
7682: EMPTY
7683: LIST
7684: LIST
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: PUSH
7690: EMPTY
7691: LIST
7692: LIST
7693: PPUSH
7694: CALL_OW 70
7698: IFFALSE 8116
7700: GO 7702
7702: DISABLE
7703: LD_INT 0
7705: PPUSH
7706: PPUSH
7707: PPUSH
// begin un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) [ 1 ] ;
7708: LD_ADDR_VAR 0 1
7712: PUSH
7713: LD_INT 7
7715: PPUSH
7716: LD_INT 22
7718: PUSH
7719: LD_INT 1
7721: PUSH
7722: EMPTY
7723: LIST
7724: LIST
7725: PUSH
7726: LD_INT 3
7728: PUSH
7729: LD_INT 24
7731: PUSH
7732: LD_INT 1000
7734: PUSH
7735: EMPTY
7736: LIST
7737: LIST
7738: PUSH
7739: EMPTY
7740: LIST
7741: LIST
7742: PUSH
7743: EMPTY
7744: LIST
7745: LIST
7746: PPUSH
7747: CALL_OW 70
7751: PUSH
7752: LD_INT 1
7754: ARRAY
7755: ST_TO_ADDR
// DialogueOn ;
7756: CALL_OW 6
// CenterNowOnUnits ( un ) ;
7760: LD_VAR 0 1
7764: PPUSH
7765: CALL_OW 87
// if Lisa then
7769: LD_EXP 13
7773: IFFALSE 7801
// begin Say ( Lisa , D5-Lisa-1 ) ;
7775: LD_EXP 13
7779: PPUSH
7780: LD_STRING D5-Lisa-1
7782: PPUSH
7783: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
7787: LD_EXP 8
7791: PPUSH
7792: LD_STRING D5-JMM-1a
7794: PPUSH
7795: CALL_OW 88
// end else
7799: GO 7813
// Say ( JMM , D5-JMM-1 ) ;
7801: LD_EXP 8
7805: PPUSH
7806: LD_STRING D5-JMM-1
7808: PPUSH
7809: CALL_OW 88
// DialogueOff ;
7813: CALL_OW 7
// while ( true ) do
7817: LD_INT 1
7819: IFFALSE 7875
// begin wait ( 0 0$01 ) ;
7821: LD_INT 35
7823: PPUSH
7824: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
7828: LD_ADDR_VAR 0 2
7832: PUSH
7833: LD_INT 8
7835: PPUSH
7836: LD_INT 30
7838: PUSH
7839: LD_INT 26
7841: PUSH
7842: EMPTY
7843: LIST
7844: LIST
7845: PUSH
7846: LD_INT 101
7848: PUSH
7849: LD_INT 1
7851: PUSH
7852: EMPTY
7853: LIST
7854: LIST
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PPUSH
7860: CALL_OW 71
7864: ST_TO_ADDR
// if x then
7865: LD_VAR 0 2
7869: IFFALSE 7873
// break ;
7871: GO 7875
// end ;
7873: GO 7817
// CenterOnUnits ( x [ 1 ] ) ;
7875: LD_VAR 0 2
7879: PUSH
7880: LD_INT 1
7882: ARRAY
7883: PPUSH
7884: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
7888: LD_EXP 14
7892: PUSH
7893: LD_EXP 14
7897: PPUSH
7898: CALL_OW 255
7902: PUSH
7903: LD_INT 1
7905: EQUAL
7906: AND
7907: IFFALSE 7923
// Say ( Frank , D5a-Frank-1 ) else
7909: LD_EXP 14
7913: PPUSH
7914: LD_STRING D5a-Frank-1
7916: PPUSH
7917: CALL_OW 88
7921: GO 7977
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
7923: LD_EXP 17
7927: PUSH
7928: LD_EXP 17
7932: PPUSH
7933: CALL_OW 255
7937: PUSH
7938: LD_INT 1
7940: EQUAL
7941: AND
7942: IFFALSE 7958
// Say ( Kikuchi , D5a-Yam-1 ) else
7944: LD_EXP 17
7948: PPUSH
7949: LD_STRING D5a-Yam-1
7951: PPUSH
7952: CALL_OW 88
7956: GO 7977
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
7958: LD_INT 1
7960: PPUSH
7961: CALL 505 0 1
7965: PUSH
7966: LD_INT 1
7968: ARRAY
7969: PPUSH
7970: LD_STRING D5a-Sol1-1
7972: PPUSH
7973: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
7977: LD_EXP 8
7981: PPUSH
7982: LD_STRING D5a-JMM-1
7984: PPUSH
7985: CALL_OW 88
// if Cyrus then
7989: LD_EXP 12
7993: IFFALSE 8007
// Say ( Cyrus , D5a-Cyrus-1 ) ;
7995: LD_EXP 12
7999: PPUSH
8000: LD_STRING D5a-Cyrus-1
8002: PPUSH
8003: CALL_OW 88
// x := false ;
8007: LD_ADDR_VAR 0 2
8011: PUSH
8012: LD_INT 0
8014: ST_TO_ADDR
// while ( true ) do
8015: LD_INT 1
8017: IFFALSE 8104
// begin wait ( 0 0$01 ) ;
8019: LD_INT 35
8021: PPUSH
8022: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
8026: LD_ADDR_VAR 0 3
8030: PUSH
8031: LD_INT 2
8033: PUSH
8034: LD_INT 30
8036: PUSH
8037: LD_INT 0
8039: PUSH
8040: EMPTY
8041: LIST
8042: LIST
8043: PUSH
8044: LD_INT 30
8046: PUSH
8047: LD_INT 1
8049: PUSH
8050: EMPTY
8051: LIST
8052: LIST
8053: PUSH
8054: EMPTY
8055: LIST
8056: LIST
8057: LIST
8058: PPUSH
8059: CALL_OW 69
8063: PUSH
8064: LD_INT 1
8066: DIFF
8067: PUSH
8068: FOR_IN
8069: IFFALSE 8092
// if BaseNeedEnergy ( i ) then
8071: LD_VAR 0 3
8075: PPUSH
8076: CALL 1162 0 1
8080: IFFALSE 8090
// x := true ;
8082: LD_ADDR_VAR 0 2
8086: PUSH
8087: LD_INT 1
8089: ST_TO_ADDR
8090: GO 8068
8092: POP
8093: POP
// if x then
8094: LD_VAR 0 2
8098: IFFALSE 8102
// break ;
8100: GO 8104
// end ;
8102: GO 8015
// Say ( JMM , D5b-JMM-1 ) ;
8104: LD_EXP 8
8108: PPUSH
8109: LD_STRING D5b-JMM-1
8111: PPUSH
8112: CALL_OW 88
// end ;
8116: PPOPN 3
8118: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
8119: LD_EXP 5
8123: PUSH
8124: LD_INT 1
8126: ARRAY
8127: PUSH
8128: LD_OWVAR 1
8132: LESS
8133: IFFALSE 8333
8135: GO 8137
8137: DISABLE
// begin if not IsDead ( ru_dep_main ) then
8138: LD_INT 16
8140: PPUSH
8141: CALL_OW 301
8145: NOT
8146: IFFALSE 8169
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
8148: LD_EXP 18
8152: PPUSH
8153: LD_STRING D3b-Har-3
8155: PPUSH
8156: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
8160: LD_STRING M2a
8162: PPUSH
8163: CALL_OW 337
// end else
8167: GO 8188
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
8169: LD_EXP 18
8173: PPUSH
8174: LD_STRING D3b-Har-3a
8176: PPUSH
8177: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
8181: LD_STRING M2
8183: PPUSH
8184: CALL_OW 337
// end ; can_end := true ;
8188: LD_ADDR_EXP 6
8192: PUSH
8193: LD_INT 1
8195: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
8196: LD_INT 9
8198: PPUSH
8199: LD_INT 1
8201: PPUSH
8202: CALL_OW 424
// Wait ( 0 0$02 ) ;
8206: LD_INT 70
8208: PPUSH
8209: CALL_OW 67
// if Lisa then
8213: LD_EXP 13
8217: IFFALSE 8231
// Say ( Lisa , D3b-Lisa ) ;
8219: LD_EXP 13
8223: PPUSH
8224: LD_STRING D3b-Lisa
8226: PPUSH
8227: CALL_OW 88
// if Bobby then
8231: LD_EXP 11
8235: IFFALSE 8249
// Say ( Bobby , D3b-Bobby-3 ) ;
8237: LD_EXP 11
8241: PPUSH
8242: LD_STRING D3b-Bobby-3
8244: PPUSH
8245: CALL_OW 88
// if Cyrus then
8249: LD_EXP 12
8253: IFFALSE 8267
// Say ( Cyrus , D3b-Cyrus-3 ) ;
8255: LD_EXP 12
8259: PPUSH
8260: LD_STRING D3b-Cyrus-3
8262: PPUSH
8263: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
8267: LD_EXP 14
8271: PUSH
8272: LD_EXP 14
8276: PPUSH
8277: CALL_OW 255
8281: PUSH
8282: LD_INT 1
8284: EQUAL
8285: AND
8286: IFFALSE 8300
// Say ( Frank , D3b-Frank-3 ) ;
8288: LD_EXP 14
8292: PPUSH
8293: LD_STRING D3b-Frank-3
8295: PPUSH
8296: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
8300: LD_EXP 17
8304: PUSH
8305: LD_EXP 17
8309: PPUSH
8310: CALL_OW 255
8314: PUSH
8315: LD_INT 1
8317: EQUAL
8318: AND
8319: IFFALSE 8333
// Say ( Kikuchi , D3b-Yam-4 ) ;
8321: LD_EXP 17
8325: PPUSH
8326: LD_STRING D3b-Yam-4
8328: PPUSH
8329: CALL_OW 88
// end ;
8333: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
8334: LD_EXP 5
8338: PUSH
8339: LD_INT 2
8341: ARRAY
8342: PUSH
8343: LD_OWVAR 1
8347: LESS
8348: IFFALSE 8380
8350: GO 8352
8352: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
8353: LD_EXP 18
8357: PPUSH
8358: LD_STRING D4-Har-1
8360: PPUSH
8361: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
8365: LD_STRING M3
8367: PPUSH
8368: CALL_OW 337
// must_end := true ;
8372: LD_ADDR_EXP 7
8376: PUSH
8377: LD_INT 1
8379: ST_TO_ADDR
// end ;
8380: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
8381: LD_EXP 5
8385: PUSH
8386: LD_INT 3
8388: ARRAY
8389: PUSH
8390: LD_OWVAR 1
8394: LESS
8395: IFFALSE 8426
8397: GO 8399
8399: DISABLE
// begin if not IsDead ( ru_dep_main ) then
8400: LD_INT 16
8402: PPUSH
8403: CALL_OW 301
8407: NOT
8408: IFFALSE 8419
// YouLost ( TimeOut1 ) else
8410: LD_STRING TimeOut1
8412: PPUSH
8413: CALL_OW 104
8417: GO 8426
// YouLost ( TimeOut2 ) ;
8419: LD_STRING TimeOut2
8421: PPUSH
8422: CALL_OW 104
// end ;
8426: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , i , tmp ;
8427: LD_EXP 8
8431: PPUSH
8432: LD_INT 9
8434: PPUSH
8435: CALL_OW 308
8439: PUSH
8440: LD_EXP 6
8444: AND
8445: IFFALSE 9430
8447: GO 8449
8449: DISABLE
8450: LD_INT 0
8452: PPUSH
8453: PPUSH
8454: PPUSH
// begin wait_on := false ;
8455: LD_ADDR_VAR 0 1
8459: PUSH
8460: LD_INT 0
8462: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
8463: LD_INT 1
8465: PPUSH
8466: CALL 1239 0 1
8470: PUSH
8471: LD_INT 0
8473: PLUS
8474: PUSH
8475: LD_INT 1
8477: PPUSH
8478: LD_INT 9
8480: PPUSH
8481: CALL 1330 0 2
8485: PUSH
8486: LD_INT 1
8488: PPUSH
8489: LD_INT 9
8491: PPUSH
8492: CALL 1377 0 2
8496: ADD
8497: PUSH
8498: LD_INT 0
8500: PLUS
8501: GREATER
8502: IFFALSE 8551
// case Query ( Q1 ) of 1 :
8504: LD_STRING Q1
8506: PPUSH
8507: CALL_OW 97
8511: PUSH
8512: LD_INT 1
8514: DOUBLE
8515: EQUAL
8516: IFTRUE 8520
8518: GO 8531
8520: POP
// wait_on := true ; 2 :
8521: LD_ADDR_VAR 0 1
8525: PUSH
8526: LD_INT 1
8528: ST_TO_ADDR
8529: GO 8551
8531: LD_INT 2
8533: DOUBLE
8534: EQUAL
8535: IFTRUE 8539
8537: GO 8550
8539: POP
// wait_on := false ; end ;
8540: LD_ADDR_VAR 0 1
8544: PUSH
8545: LD_INT 0
8547: ST_TO_ADDR
8548: GO 8551
8550: POP
// repeat wait ( 0 0$01 ) ;
8551: LD_INT 35
8553: PPUSH
8554: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
8558: LD_VAR 0 1
8562: NOT
8563: PUSH
8564: LD_INT 1
8566: PPUSH
8567: CALL 1239 0 1
8571: PUSH
8572: LD_INT 0
8574: PLUS
8575: PUSH
8576: LD_INT 1
8578: PPUSH
8579: LD_INT 9
8581: PPUSH
8582: CALL 1330 0 2
8586: PUSH
8587: LD_INT 1
8589: PPUSH
8590: LD_INT 9
8592: PPUSH
8593: CALL 1377 0 2
8597: ADD
8598: PUSH
8599: LD_INT 0
8601: PLUS
8602: EQUAL
8603: OR
8604: IFFALSE 8551
// DialogueOn ;
8606: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
8610: LD_EXP 8
8614: PPUSH
8615: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
8619: LD_EXP 8
8623: PPUSH
8624: LD_STRING D6-JMM-1
8626: PPUSH
8627: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
8631: LD_EXP 18
8635: PPUSH
8636: LD_STRING D6-Har-1
8638: PPUSH
8639: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
8643: LD_EXP 8
8647: PPUSH
8648: LD_STRING D6-JMM-2
8650: PPUSH
8651: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
8655: LD_EXP 18
8659: PPUSH
8660: LD_STRING D6-Har-2
8662: PPUSH
8663: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
8667: LD_EXP 8
8671: PPUSH
8672: LD_STRING D6-JMM-3
8674: PPUSH
8675: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
8679: LD_EXP 18
8683: PPUSH
8684: LD_STRING D6-Har-3
8686: PPUSH
8687: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
8691: LD_EXP 8
8695: PPUSH
8696: LD_STRING D6-JMM-4
8698: PPUSH
8699: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
8703: LD_EXP 18
8707: PPUSH
8708: LD_STRING D6-Har-4
8710: PPUSH
8711: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
8715: LD_EXP 8
8719: PPUSH
8720: LD_STRING D6-JMM-5
8722: PPUSH
8723: CALL_OW 88
// DialogueOff ;
8727: CALL_OW 7
// tmp := FilterBuildings ( 3 ) ;
8731: LD_ADDR_VAR 0 3
8735: PUSH
8736: LD_INT 3
8738: PPUSH
8739: CALL 1508 0 1
8743: ST_TO_ADDR
// if tmp >= 35 then
8744: LD_VAR 0 3
8748: PUSH
8749: LD_INT 35
8751: GREATEREQUAL
8752: IFFALSE 8789
// begin AddMedal ( Destroy1 , - 1 ) ;
8754: LD_STRING Destroy1
8756: PPUSH
8757: LD_INT 1
8759: NEG
8760: PPUSH
8761: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
8765: LD_STRING Destroy2
8767: PPUSH
8768: LD_INT 1
8770: NEG
8771: PPUSH
8772: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
8776: LD_STRING Destroy3
8778: PPUSH
8779: LD_INT 1
8781: NEG
8782: PPUSH
8783: CALL_OW 101
// end else
8787: GO 8876
// begin AddMedal ( Destroy1 , 1 ) ;
8789: LD_STRING Destroy1
8791: PPUSH
8792: LD_INT 1
8794: PPUSH
8795: CALL_OW 101
// if tmp >= 25 then
8799: LD_VAR 0 3
8803: PUSH
8804: LD_INT 25
8806: GREATEREQUAL
8807: IFFALSE 8833
// begin AddMedal ( Destroy2 , - 1 ) ;
8809: LD_STRING Destroy2
8811: PPUSH
8812: LD_INT 1
8814: NEG
8815: PPUSH
8816: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
8820: LD_STRING Destroy3
8822: PPUSH
8823: LD_INT 1
8825: NEG
8826: PPUSH
8827: CALL_OW 101
// end else
8831: GO 8876
// begin AddMedal ( Destroy2 , 1 ) ;
8833: LD_STRING Destroy2
8835: PPUSH
8836: LD_INT 1
8838: PPUSH
8839: CALL_OW 101
// if tmp >= 15 then
8843: LD_VAR 0 3
8847: PUSH
8848: LD_INT 15
8850: GREATEREQUAL
8851: IFFALSE 8866
// AddMedal ( Destroy3 , - 1 ) else
8853: LD_STRING Destroy3
8855: PPUSH
8856: LD_INT 1
8858: NEG
8859: PPUSH
8860: CALL_OW 101
8864: GO 8876
// AddMedal ( Destroy3 , 1 ) ;
8866: LD_STRING Destroy3
8868: PPUSH
8869: LD_INT 1
8871: PPUSH
8872: CALL_OW 101
// end ; end ; GiveMedals ( MAIN ) ;
8876: LD_STRING MAIN
8878: PPUSH
8879: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ;
8883: LD_ADDR_VAR 0 3
8887: PUSH
8888: LD_INT 1
8890: PPUSH
8891: LD_INT 9
8893: PPUSH
8894: CALL 1330 0 2
8898: PUSH
8899: LD_INT 1
8901: PPUSH
8902: LD_INT 9
8904: PPUSH
8905: CALL 1377 0 2
8909: ADD
8910: ST_TO_ADDR
// RewardPeople ( tmp ) ;
8911: LD_VAR 0 3
8915: PPUSH
8916: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
8920: LD_EXP 8
8924: PPUSH
8925: LD_EXP 3
8929: PUSH
8930: LD_STRING JMM
8932: STR
8933: PPUSH
8934: CALL_OW 38
// if Brown in tmp then
8938: LD_EXP 9
8942: PUSH
8943: LD_VAR 0 3
8947: IN
8948: IFFALSE 8968
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
8950: LD_EXP 9
8954: PPUSH
8955: LD_EXP 3
8959: PUSH
8960: LD_STRING Brown
8962: STR
8963: PPUSH
8964: CALL_OW 38
// if Donaldson in tmp then
8968: LD_EXP 10
8972: PUSH
8973: LD_VAR 0 3
8977: IN
8978: IFFALSE 8998
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
8980: LD_EXP 10
8984: PPUSH
8985: LD_EXP 3
8989: PUSH
8990: LD_STRING Donaldson
8992: STR
8993: PPUSH
8994: CALL_OW 38
// if Bobby in tmp then
8998: LD_EXP 11
9002: PUSH
9003: LD_VAR 0 3
9007: IN
9008: IFFALSE 9028
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
9010: LD_EXP 11
9014: PPUSH
9015: LD_EXP 3
9019: PUSH
9020: LD_STRING Bobby
9022: STR
9023: PPUSH
9024: CALL_OW 38
// if Cyrus in tmp then
9028: LD_EXP 12
9032: PUSH
9033: LD_VAR 0 3
9037: IN
9038: IFFALSE 9058
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
9040: LD_EXP 12
9044: PPUSH
9045: LD_EXP 3
9049: PUSH
9050: LD_STRING Cyrus
9052: STR
9053: PPUSH
9054: CALL_OW 38
// if Lisa in tmp then
9058: LD_EXP 13
9062: PUSH
9063: LD_VAR 0 3
9067: IN
9068: IFFALSE 9088
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
9070: LD_EXP 13
9074: PPUSH
9075: LD_EXP 3
9079: PUSH
9080: LD_STRING Lisa
9082: STR
9083: PPUSH
9084: CALL_OW 38
// if Frank in tmp then
9088: LD_EXP 14
9092: PUSH
9093: LD_VAR 0 3
9097: IN
9098: IFFALSE 9118
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
9100: LD_EXP 14
9104: PPUSH
9105: LD_EXP 3
9109: PUSH
9110: LD_STRING Frank
9112: STR
9113: PPUSH
9114: CALL_OW 38
// if Gladstone in tmp then
9118: LD_EXP 15
9122: PUSH
9123: LD_VAR 0 3
9127: IN
9128: IFFALSE 9148
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
9130: LD_EXP 15
9134: PPUSH
9135: LD_EXP 3
9139: PUSH
9140: LD_STRING Gladstone
9142: STR
9143: PPUSH
9144: CALL_OW 38
// if Khatam in tmp then
9148: LD_EXP 16
9152: PUSH
9153: LD_VAR 0 3
9157: IN
9158: IFFALSE 9178
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
9160: LD_EXP 16
9164: PPUSH
9165: LD_EXP 3
9169: PUSH
9170: LD_STRING Khatam
9172: STR
9173: PPUSH
9174: CALL_OW 38
// if Kikuchi in tmp then
9178: LD_EXP 17
9182: PUSH
9183: LD_VAR 0 3
9187: IN
9188: IFFALSE 9208
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
9190: LD_EXP 17
9194: PPUSH
9195: LD_EXP 3
9199: PUSH
9200: LD_STRING Kikuchi
9202: STR
9203: PPUSH
9204: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi ] , mission_prefix & others ) ;
9208: LD_VAR 0 3
9212: PUSH
9213: LD_EXP 8
9217: PUSH
9218: LD_EXP 9
9222: PUSH
9223: LD_EXP 10
9227: PUSH
9228: LD_EXP 11
9232: PUSH
9233: LD_EXP 12
9237: PUSH
9238: LD_EXP 13
9242: PUSH
9243: LD_EXP 14
9247: PUSH
9248: LD_EXP 15
9252: PUSH
9253: LD_EXP 17
9257: PUSH
9258: EMPTY
9259: LIST
9260: LIST
9261: LIST
9262: LIST
9263: LIST
9264: LIST
9265: LIST
9266: LIST
9267: LIST
9268: DIFF
9269: PPUSH
9270: LD_EXP 3
9274: PUSH
9275: LD_STRING others
9277: STR
9278: PPUSH
9279: CALL_OW 38
// SaveVariable ( tick , 07_time ) ;
9283: LD_OWVAR 1
9287: PPUSH
9288: LD_STRING 07_time
9290: PPUSH
9291: CALL_OW 39
// tmp := [ ] ;
9295: LD_ADDR_VAR 0 3
9299: PUSH
9300: EMPTY
9301: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ] ) do
9302: LD_ADDR_VAR 0 2
9306: PUSH
9307: LD_INT 22
9309: PUSH
9310: LD_INT 1
9312: PUSH
9313: EMPTY
9314: LIST
9315: LIST
9316: PUSH
9317: LD_INT 23
9319: PUSH
9320: LD_INT 1
9322: PUSH
9323: EMPTY
9324: LIST
9325: LIST
9326: PUSH
9327: LD_INT 21
9329: PUSH
9330: LD_INT 2
9332: PUSH
9333: EMPTY
9334: LIST
9335: LIST
9336: PUSH
9337: EMPTY
9338: LIST
9339: LIST
9340: LIST
9341: PUSH
9342: EMPTY
9343: LIST
9344: PPUSH
9345: CALL_OW 69
9349: PUSH
9350: FOR_IN
9351: IFFALSE 9412
// tmp := tmp ^ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
9353: LD_ADDR_VAR 0 3
9357: PUSH
9358: LD_VAR 0 3
9362: PUSH
9363: LD_VAR 0 2
9367: PPUSH
9368: CALL_OW 265
9372: PUSH
9373: LD_VAR 0 2
9377: PPUSH
9378: CALL_OW 262
9382: PUSH
9383: LD_VAR 0 2
9387: PPUSH
9388: CALL_OW 263
9392: PUSH
9393: LD_VAR 0 2
9397: PPUSH
9398: CALL_OW 264
9402: PUSH
9403: EMPTY
9404: LIST
9405: LIST
9406: LIST
9407: LIST
9408: ADD
9409: ST_TO_ADDR
9410: GO 9350
9412: POP
9413: POP
// SaveVariable ( tmp , 07_vehicles ) ;
9414: LD_VAR 0 3
9418: PPUSH
9419: LD_STRING 07_vehicles
9421: PPUSH
9422: CALL_OW 39
// YouWin ;
9426: CALL_OW 103
// end ; end_of_file
9430: PPOPN 3
9432: END
// on UnitDestroyed ( un ) do begin if un = JMM then
9433: LD_VAR 0 1
9437: PUSH
9438: LD_EXP 8
9442: EQUAL
9443: IFFALSE 9452
// YouLost ( JMM ) ;
9445: LD_STRING JMM
9447: PPUSH
9448: CALL_OW 104
// if GetType ( un ) = unit_building then
9452: LD_VAR 0 1
9456: PPUSH
9457: CALL_OW 247
9461: PUSH
9462: LD_INT 3
9464: EQUAL
9465: IFFALSE 9481
// buildings_counter := buildings_counter + 1 ;
9467: LD_ADDR_EXP 4
9471: PUSH
9472: LD_EXP 4
9476: PUSH
9477: LD_INT 1
9479: PLUS
9480: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
9481: LD_VAR 0 1
9485: PUSH
9486: LD_INT 6
9488: PPUSH
9489: LD_INT 2
9491: PUSH
9492: LD_INT 30
9494: PUSH
9495: LD_INT 33
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: PUSH
9502: LD_INT 30
9504: PUSH
9505: LD_INT 32
9507: PUSH
9508: EMPTY
9509: LIST
9510: LIST
9511: PUSH
9512: EMPTY
9513: LIST
9514: LIST
9515: LIST
9516: PPUSH
9517: CALL_OW 70
9521: IN
9522: IFFALSE 9581
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
9524: LD_ADDR_EXP 19
9528: PUSH
9529: LD_EXP 19
9533: PUSH
9534: LD_VAR 0 1
9538: PPUSH
9539: CALL_OW 266
9543: PUSH
9544: LD_VAR 0 1
9548: PPUSH
9549: CALL_OW 250
9553: PUSH
9554: LD_VAR 0 1
9558: PPUSH
9559: CALL_OW 251
9563: PUSH
9564: LD_VAR 0 1
9568: PPUSH
9569: CALL_OW 254
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: LIST
9578: LIST
9579: ADD
9580: ST_TO_ADDR
// if un = ru_dep_main then
9581: LD_VAR 0 1
9585: PUSH
9586: LD_INT 16
9588: EQUAL
9589: IFFALSE 9598
// ChangeMissionObjectives ( M1a ) ;
9591: LD_STRING M1a
9593: PPUSH
9594: CALL_OW 337
// end ;
9598: PPOPN 1
9600: END
// on BuildingStarted ( b , builder ) do var i ;
9601: LD_INT 0
9603: PPUSH
// begin if GetSide ( b ) = 3 then
9604: LD_VAR 0 1
9608: PPUSH
9609: CALL_OW 255
9613: PUSH
9614: LD_INT 3
9616: EQUAL
9617: IFFALSE 9657
// for i = 1 to 4 do
9619: LD_ADDR_VAR 0 3
9623: PUSH
9624: DOUBLE
9625: LD_INT 1
9627: DEC
9628: ST_TO_ADDR
9629: LD_INT 4
9631: PUSH
9632: FOR_TO
9633: IFFALSE 9655
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
9635: LD_ADDR_EXP 19
9639: PUSH
9640: LD_EXP 19
9644: PPUSH
9645: LD_INT 1
9647: PPUSH
9648: CALL_OW 3
9652: ST_TO_ADDR
9653: GO 9632
9655: POP
9656: POP
// end ;
9657: PPOPN 3
9659: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
9660: LD_VAR 0 1
9664: PPUSH
9665: CALL_OW 266
9669: PUSH
9670: LD_INT 32
9672: PUSH
9673: LD_INT 33
9675: PUSH
9676: EMPTY
9677: LIST
9678: LIST
9679: IN
9680: IFFALSE 9694
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
9682: LD_VAR 0 1
9686: PPUSH
9687: LD_INT 43
9689: PPUSH
9690: CALL_OW 148
9694: PPOPN 1
9696: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
9697: LD_VAR 0 1
9701: PUSH
9702: LD_INT 22
9704: PUSH
9705: LD_INT 3
9707: PUSH
9708: EMPTY
9709: LIST
9710: LIST
9711: PUSH
9712: LD_INT 2
9714: PUSH
9715: LD_INT 30
9717: PUSH
9718: LD_INT 31
9720: PUSH
9721: EMPTY
9722: LIST
9723: LIST
9724: PUSH
9725: LD_INT 30
9727: PUSH
9728: LD_INT 32
9730: PUSH
9731: EMPTY
9732: LIST
9733: LIST
9734: PUSH
9735: EMPTY
9736: LIST
9737: LIST
9738: LIST
9739: PUSH
9740: EMPTY
9741: LIST
9742: LIST
9743: PPUSH
9744: CALL_OW 69
9748: IN
9749: IFFALSE 9771
// GoToAnotherTower ( un , b , 143 , 143 ) ;
9751: LD_VAR 0 2
9755: PPUSH
9756: LD_VAR 0 1
9760: PPUSH
9761: LD_INT 143
9763: PPUSH
9764: LD_INT 143
9766: PPUSH
9767: CALL 735 0 4
// end ;
9771: PPOPN 2
9773: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
9774: LD_VAR 0 1
9778: PUSH
9779: LD_INT 22
9781: PUSH
9782: LD_INT 3
9784: PUSH
9785: EMPTY
9786: LIST
9787: LIST
9788: PUSH
9789: LD_INT 30
9791: PUSH
9792: LD_INT 32
9794: PUSH
9795: EMPTY
9796: LIST
9797: LIST
9798: PUSH
9799: EMPTY
9800: LIST
9801: LIST
9802: PPUSH
9803: CALL_OW 69
9807: IN
9808: IFFALSE 9822
// SetTag ( b , 0 ) ;
9810: LD_VAR 0 1
9814: PPUSH
9815: LD_INT 0
9817: PPUSH
9818: CALL_OW 109
// end ;
9822: PPOPN 2
9824: END
