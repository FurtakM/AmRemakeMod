// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 29 0 0
// DebugMode ;
  12: CALL 147 0 0
// PrepareRussians ;
  16: CALL 2510 0 0
// PrepareAmericans ;
  20: CALL 1465 0 0
// Action ;
  24: CALL 5121 0 0
// end ;
  28: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end ; function Init ; begin
  29: LD_INT 0
  31: PPUSH
// debug := false ;
  32: LD_ADDR_EXP 1
  36: PUSH
  37: LD_INT 0
  39: ST_TO_ADDR
// mission_prefix := 07c_ ;
  40: LD_ADDR_EXP 3
  44: PUSH
  45: LD_STRING 07c_
  47: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  48: LD_ADDR_EXP 2
  52: PUSH
  53: LD_STRING 07_
  55: ST_TO_ADDR
// buildings_counter := 0 ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: LD_INT 0
  63: ST_TO_ADDR
// time_to_end := [ [ 27 27$00 , 24 24$00 , 21 21$00 ] [ Difficulty ] , [ 35 35$00 , 32 32$00 , 29 29$00 ] [ Difficulty ] , [ 38 38$00 , 35 35$00 , 32 32$00 ] [ Difficulty ] ] ;
  64: LD_ADDR_EXP 5
  68: PUSH
  69: LD_INT 56700
  71: PUSH
  72: LD_INT 50400
  74: PUSH
  75: LD_INT 44100
  77: PUSH
  78: EMPTY
  79: LIST
  80: LIST
  81: LIST
  82: PUSH
  83: LD_OWVAR 67
  87: ARRAY
  88: PUSH
  89: LD_INT 73500
  91: PUSH
  92: LD_INT 67200
  94: PUSH
  95: LD_INT 60900
  97: PUSH
  98: EMPTY
  99: LIST
 100: LIST
 101: LIST
 102: PUSH
 103: LD_OWVAR 67
 107: ARRAY
 108: PUSH
 109: LD_INT 79800
 111: PUSH
 112: LD_INT 73500
 114: PUSH
 115: LD_INT 67200
 117: PUSH
 118: EMPTY
 119: LIST
 120: LIST
 121: LIST
 122: PUSH
 123: LD_OWVAR 67
 127: ARRAY
 128: PUSH
 129: EMPTY
 130: LIST
 131: LIST
 132: LIST
 133: ST_TO_ADDR
// can_end := false ;
 134: LD_ADDR_EXP 6
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// end ;
 142: LD_VAR 0 1
 146: RET
// function DebugMode ; begin
 147: LD_INT 0
 149: PPUSH
// if not debug then
 150: LD_EXP 1
 154: NOT
 155: IFFALSE 159
// exit ;
 157: GO 166
// FogOff ( 1 ) ;
 159: LD_INT 1
 161: PPUSH
 162: CALL_OW 344
// end ;
 166: LD_VAR 0 1
 170: RET
// every 3 trigger debug do var i , filter ;
 171: LD_EXP 1
 175: IFFALSE 264
 177: GO 179
 179: DISABLE
 180: LD_INT 0
 182: PPUSH
 183: PPUSH
// begin enable ;
 184: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 185: LD_ADDR_VAR 0 2
 189: PUSH
 190: LD_INT 22
 192: PUSH
 193: LD_INT 1
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: PUSH
 200: LD_INT 3
 202: PUSH
 203: LD_INT 24
 205: PUSH
 206: LD_INT 500
 208: PUSH
 209: EMPTY
 210: LIST
 211: LIST
 212: PUSH
 213: EMPTY
 214: LIST
 215: LIST
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: PPUSH
 221: CALL_OW 69
 225: ST_TO_ADDR
// if not filter then
 226: LD_VAR 0 2
 230: NOT
 231: IFFALSE 235
// exit ;
 233: GO 264
// for i in filter do
 235: LD_ADDR_VAR 0 1
 239: PUSH
 240: LD_VAR 0 2
 244: PUSH
 245: FOR_IN
 246: IFFALSE 262
// SetLives ( i , 1000 ) ;
 248: LD_VAR 0 1
 252: PPUSH
 253: LD_INT 1000
 255: PPUSH
 256: CALL_OW 234
 260: GO 245
 262: POP
 263: POP
// end ; end_of_file
 264: PPOPN 2
 266: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 267: LD_INT 0
 269: PPUSH
 270: PPUSH
// if exist_mode then
 271: LD_VAR 0 2
 275: IFFALSE 300
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 277: LD_ADDR_VAR 0 4
 281: PUSH
 282: LD_EXP 2
 286: PUSH
 287: LD_VAR 0 1
 291: STR
 292: PPUSH
 293: CALL_OW 34
 297: ST_TO_ADDR
 298: GO 315
// unit := NewCharacter ( ident ) ;
 300: LD_ADDR_VAR 0 4
 304: PUSH
 305: LD_VAR 0 1
 309: PPUSH
 310: CALL_OW 25
 314: ST_TO_ADDR
// result := unit ;
 315: LD_ADDR_VAR 0 3
 319: PUSH
 320: LD_VAR 0 4
 324: ST_TO_ADDR
// end ;
 325: LD_VAR 0 3
 329: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 330: LD_INT 0
 332: PPUSH
// uc_side := side ;
 333: LD_ADDR_OWVAR 20
 337: PUSH
 338: LD_VAR 0 1
 342: ST_TO_ADDR
// uc_nation := nation ;
 343: LD_ADDR_OWVAR 21
 347: PUSH
 348: LD_VAR 0 2
 352: ST_TO_ADDR
// vc_chassis := chassis ;
 353: LD_ADDR_OWVAR 37
 357: PUSH
 358: LD_VAR 0 3
 362: ST_TO_ADDR
// vc_engine := engine ;
 363: LD_ADDR_OWVAR 39
 367: PUSH
 368: LD_VAR 0 4
 372: ST_TO_ADDR
// vc_control := control ;
 373: LD_ADDR_OWVAR 38
 377: PUSH
 378: LD_VAR 0 5
 382: ST_TO_ADDR
// vc_weapon := weapon ;
 383: LD_ADDR_OWVAR 40
 387: PUSH
 388: LD_VAR 0 6
 392: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 393: LD_ADDR_OWVAR 41
 397: PUSH
 398: LD_VAR 0 7
 402: ST_TO_ADDR
// result := CreateVehicle ;
 403: LD_ADDR_VAR 0 8
 407: PUSH
 408: CALL_OW 45
 412: ST_TO_ADDR
// end ;
 413: LD_VAR 0 8
 417: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 418: LD_INT 0
 420: PPUSH
 421: PPUSH
 422: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 423: LD_ADDR_VAR 0 4
 427: PUSH
 428: LD_INT 22
 430: PUSH
 431: LD_INT 1
 433: PUSH
 434: EMPTY
 435: LIST
 436: LIST
 437: PUSH
 438: LD_INT 21
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: PUSH
 448: LD_INT 50
 450: PUSH
 451: EMPTY
 452: LIST
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: LIST
 458: PPUSH
 459: CALL_OW 69
 463: PUSH
 464: LD_EXP 7
 468: PUSH
 469: LD_EXP 8
 473: PUSH
 474: LD_EXP 9
 478: PUSH
 479: LD_EXP 10
 483: PUSH
 484: LD_EXP 11
 488: PUSH
 489: LD_EXP 12
 493: PUSH
 494: LD_EXP 13
 498: PUSH
 499: LD_EXP 14
 503: PUSH
 504: LD_EXP 16
 508: PUSH
 509: LD_EXP 15
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: LIST
 525: DIFF
 526: ST_TO_ADDR
// if not filter then
 527: LD_VAR 0 4
 531: NOT
 532: IFFALSE 536
// exit ;
 534: GO 563
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 536: LD_ADDR_VAR 0 2
 540: PUSH
 541: LD_VAR 0 4
 545: PPUSH
 546: LD_INT 26
 548: PUSH
 549: LD_VAR 0 1
 553: PUSH
 554: EMPTY
 555: LIST
 556: LIST
 557: PPUSH
 558: CALL_OW 72
 562: ST_TO_ADDR
// end ;
 563: LD_VAR 0 2
 567: RET
// export function SayX ( units , ident ) ; var i ; begin
 568: LD_INT 0
 570: PPUSH
 571: PPUSH
// result := false ;
 572: LD_ADDR_VAR 0 3
 576: PUSH
 577: LD_INT 0
 579: ST_TO_ADDR
// if not units then
 580: LD_VAR 0 1
 584: NOT
 585: IFFALSE 589
// exit ;
 587: GO 643
// for i in units do
 589: LD_ADDR_VAR 0 4
 593: PUSH
 594: LD_VAR 0 1
 598: PUSH
 599: FOR_IN
 600: IFFALSE 641
// if IsOk ( i ) then
 602: LD_VAR 0 4
 606: PPUSH
 607: CALL_OW 302
 611: IFFALSE 639
// begin Say ( i , ident ) ;
 613: LD_VAR 0 4
 617: PPUSH
 618: LD_VAR 0 2
 622: PPUSH
 623: CALL_OW 88
// result := i ;
 627: LD_ADDR_VAR 0 3
 631: PUSH
 632: LD_VAR 0 4
 636: ST_TO_ADDR
// break ;
 637: GO 641
// end ;
 639: GO 599
 641: POP
 642: POP
// end ;
 643: LD_VAR 0 3
 647: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
 648: LD_INT 0
 650: PPUSH
 651: PPUSH
 652: PPUSH
 653: PPUSH
 654: PPUSH
// if not un or not IsOk ( un ) then
 655: LD_VAR 0 1
 659: NOT
 660: PUSH
 661: LD_VAR 0 1
 665: PPUSH
 666: CALL_OW 302
 670: NOT
 671: OR
 672: IFFALSE 676
// exit ;
 674: GO 1070
// side := GetSide ( un ) ;
 676: LD_ADDR_VAR 0 9
 680: PUSH
 681: LD_VAR 0 1
 685: PPUSH
 686: CALL_OW 255
 690: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
 691: LD_ADDR_VAR 0 7
 695: PUSH
 696: LD_INT 22
 698: PUSH
 699: LD_VAR 0 9
 703: PUSH
 704: EMPTY
 705: LIST
 706: LIST
 707: PUSH
 708: LD_INT 30
 710: PUSH
 711: LD_INT 32
 713: PUSH
 714: EMPTY
 715: LIST
 716: LIST
 717: PUSH
 718: LD_INT 50
 720: PUSH
 721: EMPTY
 722: LIST
 723: PUSH
 724: LD_INT 58
 726: PUSH
 727: EMPTY
 728: LIST
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: LIST
 734: LIST
 735: PPUSH
 736: CALL_OW 69
 740: PUSH
 741: LD_VAR 0 2
 745: DIFF
 746: ST_TO_ADDR
// if not filter then
 747: LD_VAR 0 7
 751: NOT
 752: IFFALSE 935
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
 754: LD_ADDR_VAR 0 7
 758: PUSH
 759: LD_INT 22
 761: PUSH
 762: LD_VAR 0 9
 766: PUSH
 767: EMPTY
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 30
 773: PUSH
 774: LD_INT 5
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: PPUSH
 785: CALL_OW 69
 789: ST_TO_ADDR
// if not filter then
 790: LD_VAR 0 7
 794: NOT
 795: IFFALSE 818
// begin ComMoveXY ( un , x , y ) ;
 797: LD_VAR 0 1
 801: PPUSH
 802: LD_VAR 0 3
 806: PPUSH
 807: LD_VAR 0 4
 811: PPUSH
 812: CALL_OW 111
// exit ;
 816: GO 1070
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
 818: LD_ADDR_VAR 0 8
 822: PUSH
 823: LD_VAR 0 7
 827: PPUSH
 828: LD_VAR 0 1
 832: PPUSH
 833: CALL_OW 74
 837: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
 838: LD_VAR 0 8
 842: PPUSH
 843: CALL_OW 313
 847: PUSH
 848: LD_INT 6
 850: EQUAL
 851: IFFALSE 869
// filter := filter diff t ;
 853: LD_ADDR_VAR 0 7
 857: PUSH
 858: LD_VAR 0 7
 862: PUSH
 863: LD_VAR 0 8
 867: DIFF
 868: ST_TO_ADDR
// until UnitsInside ( t ) < 6 or not filter ;
 869: LD_VAR 0 8
 873: PPUSH
 874: CALL_OW 313
 878: PUSH
 879: LD_INT 6
 881: LESS
 882: PUSH
 883: LD_VAR 0 7
 887: NOT
 888: OR
 889: IFFALSE 818
// if not filter then
 891: LD_VAR 0 7
 895: NOT
 896: IFFALSE 919
// ComMoveXY ( un , x , y ) else
 898: LD_VAR 0 1
 902: PPUSH
 903: LD_VAR 0 3
 907: PPUSH
 908: LD_VAR 0 4
 912: PPUSH
 913: CALL_OW 111
 917: GO 933
// ComEnterUnit ( un , t ) ;
 919: LD_VAR 0 1
 923: PPUSH
 924: LD_VAR 0 8
 928: PPUSH
 929: CALL_OW 120
// end else
 933: GO 1070
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
 935: LD_ADDR_VAR 0 8
 939: PUSH
 940: LD_VAR 0 7
 944: PPUSH
 945: LD_VAR 0 1
 949: PPUSH
 950: CALL_OW 74
 954: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
 955: LD_VAR 0 8
 959: PPUSH
 960: CALL_OW 110
 964: PUSH
 965: LD_INT 7
 967: EQUAL
 968: IFFALSE 986
// filter := filter diff t ;
 970: LD_ADDR_VAR 0 7
 974: PUSH
 975: LD_VAR 0 7
 979: PUSH
 980: LD_VAR 0 8
 984: DIFF
 985: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
 986: LD_VAR 0 8
 990: PPUSH
 991: CALL_OW 110
 995: PUSH
 996: LD_INT 7
 998: NONEQUAL
 999: PUSH
1000: LD_VAR 0 7
1004: NOT
1005: OR
1006: IFFALSE 935
// if GetTag ( t ) <> 7 then
1008: LD_VAR 0 8
1012: PPUSH
1013: CALL_OW 110
1017: PUSH
1018: LD_INT 7
1020: NONEQUAL
1021: IFFALSE 1051
// begin SetTag ( t , 7 ) ;
1023: LD_VAR 0 8
1027: PPUSH
1028: LD_INT 7
1030: PPUSH
1031: CALL_OW 109
// ComEnterUnit ( un , t ) ;
1035: LD_VAR 0 1
1039: PPUSH
1040: LD_VAR 0 8
1044: PPUSH
1045: CALL_OW 120
// end else
1049: GO 1070
// ComMoveXY ( un , x , y ) ;
1051: LD_VAR 0 1
1055: PPUSH
1056: LD_VAR 0 3
1060: PPUSH
1061: LD_VAR 0 4
1065: PPUSH
1066: CALL_OW 111
// end ; end ;
1070: LD_VAR 0 5
1074: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
1075: LD_INT 0
1077: PPUSH
1078: PPUSH
1079: PPUSH
// if not base then
1080: LD_VAR 0 1
1084: NOT
1085: IFFALSE 1089
// exit ;
1087: GO 1147
// tmp := GetEnergy ( GetBase ( base ) ) ;
1089: LD_ADDR_VAR 0 4
1093: PUSH
1094: LD_VAR 0 1
1098: PPUSH
1099: CALL_OW 274
1103: PPUSH
1104: CALL_OW 278
1108: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
1109: LD_VAR 0 4
1113: PUSH
1114: LD_INT 1
1116: ARRAY
1117: PUSH
1118: LD_VAR 0 4
1122: PUSH
1123: LD_INT 4
1125: ARRAY
1126: GREATER
1127: IFFALSE 1139
// result := true else
1129: LD_ADDR_VAR 0 2
1133: PUSH
1134: LD_INT 1
1136: ST_TO_ADDR
1137: GO 1147
// result := false ;
1139: LD_ADDR_VAR 0 2
1143: PUSH
1144: LD_INT 0
1146: ST_TO_ADDR
// end ;
1147: LD_VAR 0 2
1151: RET
// export function FilterPeople ( side ) ; begin
1152: LD_INT 0
1154: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
1155: LD_ADDR_VAR 0 2
1159: PUSH
1160: LD_INT 22
1162: PUSH
1163: LD_VAR 0 1
1167: PUSH
1168: EMPTY
1169: LIST
1170: LIST
1171: PUSH
1172: LD_INT 21
1174: PUSH
1175: LD_INT 1
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PUSH
1182: EMPTY
1183: LIST
1184: LIST
1185: PPUSH
1186: CALL_OW 69
1190: ST_TO_ADDR
// end ;
1191: LD_VAR 0 2
1195: RET
// export function FilterDrivers ( side ) ; begin
1196: LD_INT 0
1198: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
1199: LD_ADDR_VAR 0 2
1203: PUSH
1204: LD_INT 22
1206: PUSH
1207: LD_VAR 0 1
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 3
1218: PUSH
1219: LD_INT 56
1221: PUSH
1222: EMPTY
1223: LIST
1224: PUSH
1225: EMPTY
1226: LIST
1227: LIST
1228: PUSH
1229: EMPTY
1230: LIST
1231: LIST
1232: PPUSH
1233: CALL_OW 69
1237: ST_TO_ADDR
// end ;
1238: LD_VAR 0 2
1242: RET
// export function FilterPeopleArea ( side , area ) ; begin
1243: LD_INT 0
1245: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
1246: LD_ADDR_VAR 0 3
1250: PUSH
1251: LD_VAR 0 2
1255: PPUSH
1256: LD_INT 22
1258: PUSH
1259: LD_INT 1
1261: PUSH
1262: EMPTY
1263: LIST
1264: LIST
1265: PUSH
1266: LD_INT 21
1268: PUSH
1269: LD_INT 1
1271: PUSH
1272: EMPTY
1273: LIST
1274: LIST
1275: PUSH
1276: EMPTY
1277: LIST
1278: LIST
1279: PPUSH
1280: CALL_OW 70
1284: ST_TO_ADDR
// end ;
1285: LD_VAR 0 3
1289: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
1290: LD_INT 0
1292: PPUSH
1293: PPUSH
1294: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
1295: LD_ADDR_VAR 0 5
1299: PUSH
1300: LD_VAR 0 2
1304: PPUSH
1305: LD_INT 22
1307: PUSH
1308: LD_INT 1
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: PUSH
1315: LD_INT 21
1317: PUSH
1318: LD_INT 2
1320: PUSH
1321: EMPTY
1322: LIST
1323: LIST
1324: PUSH
1325: LD_INT 3
1327: PUSH
1328: LD_INT 58
1330: PUSH
1331: EMPTY
1332: LIST
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: PUSH
1338: EMPTY
1339: LIST
1340: LIST
1341: LIST
1342: PPUSH
1343: CALL_OW 70
1347: ST_TO_ADDR
// result := [ ] ;
1348: LD_ADDR_VAR 0 3
1352: PUSH
1353: EMPTY
1354: ST_TO_ADDR
// if not tmp then
1355: LD_VAR 0 5
1359: NOT
1360: IFFALSE 1364
// exit ;
1362: GO 1416
// for i in tmp do
1364: LD_ADDR_VAR 0 4
1368: PUSH
1369: LD_VAR 0 5
1373: PUSH
1374: FOR_IN
1375: IFFALSE 1400
// result := result ^ IsDrivenBy ( i ) ;
1377: LD_ADDR_VAR 0 3
1381: PUSH
1382: LD_VAR 0 3
1386: PUSH
1387: LD_VAR 0 4
1391: PPUSH
1392: CALL_OW 311
1396: ADD
1397: ST_TO_ADDR
1398: GO 1374
1400: POP
1401: POP
// result := result diff 0 ;
1402: LD_ADDR_VAR 0 3
1406: PUSH
1407: LD_VAR 0 3
1411: PUSH
1412: LD_INT 0
1414: DIFF
1415: ST_TO_ADDR
// end ;
1416: LD_VAR 0 3
1420: RET
// export function FilterBuildings ( side ) ; begin
1421: LD_INT 0
1423: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
1424: LD_ADDR_VAR 0 2
1428: PUSH
1429: LD_INT 22
1431: PUSH
1432: LD_VAR 0 1
1436: PUSH
1437: EMPTY
1438: LIST
1439: LIST
1440: PUSH
1441: LD_INT 21
1443: PUSH
1444: LD_INT 3
1446: PUSH
1447: EMPTY
1448: LIST
1449: LIST
1450: PUSH
1451: EMPTY
1452: LIST
1453: LIST
1454: PPUSH
1455: CALL_OW 69
1459: ST_TO_ADDR
// end ; end_of_file
1460: LD_VAR 0 2
1464: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
1465: LD_INT 0
1467: PPUSH
1468: PPUSH
1469: PPUSH
1470: PPUSH
1471: PPUSH
1472: PPUSH
// uc_side := 1 ;
1473: LD_ADDR_OWVAR 20
1477: PUSH
1478: LD_INT 1
1480: ST_TO_ADDR
// uc_nation := 1 ;
1481: LD_ADDR_OWVAR 21
1485: PUSH
1486: LD_INT 1
1488: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1489: LD_ADDR_EXP 7
1493: PUSH
1494: LD_STRING JMM
1496: PPUSH
1497: LD_EXP 1
1501: NOT
1502: PPUSH
1503: CALL 267 0 2
1507: ST_TO_ADDR
// team := [ JMM ] ;
1508: LD_ADDR_VAR 0 3
1512: PUSH
1513: LD_EXP 7
1517: PUSH
1518: EMPTY
1519: LIST
1520: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
1521: LD_STRING BrownIn07
1523: PPUSH
1524: LD_EXP 1
1528: PPUSH
1529: CALL_OW 30
1533: IFFALSE 1554
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1535: LD_ADDR_EXP 8
1539: PUSH
1540: LD_STRING Brown
1542: PPUSH
1543: LD_EXP 1
1547: NOT
1548: PPUSH
1549: CALL 267 0 2
1553: ST_TO_ADDR
// if Brown then
1554: LD_EXP 8
1558: IFFALSE 1576
// team := team ^ Brown ;
1560: LD_ADDR_VAR 0 3
1564: PUSH
1565: LD_VAR 0 3
1569: PUSH
1570: LD_EXP 8
1574: ADD
1575: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
1576: LD_STRING DonaldsonIn07
1578: PPUSH
1579: LD_EXP 1
1583: PPUSH
1584: CALL_OW 30
1588: IFFALSE 1609
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1590: LD_ADDR_EXP 9
1594: PUSH
1595: LD_STRING Donaldson
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: CALL 267 0 2
1608: ST_TO_ADDR
// if Donaldson then
1609: LD_EXP 9
1613: IFFALSE 1631
// team := team ^ Donaldson ;
1615: LD_ADDR_VAR 0 3
1619: PUSH
1620: LD_VAR 0 3
1624: PUSH
1625: LD_EXP 9
1629: ADD
1630: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
1631: LD_STRING BobbyIn07
1633: PPUSH
1634: LD_EXP 1
1638: PPUSH
1639: CALL_OW 30
1643: IFFALSE 1664
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1645: LD_ADDR_EXP 10
1649: PUSH
1650: LD_STRING Bobby
1652: PPUSH
1653: LD_EXP 1
1657: NOT
1658: PPUSH
1659: CALL 267 0 2
1663: ST_TO_ADDR
// if Bobby then
1664: LD_EXP 10
1668: IFFALSE 1686
// team := team ^ Bobby ;
1670: LD_ADDR_VAR 0 3
1674: PUSH
1675: LD_VAR 0 3
1679: PUSH
1680: LD_EXP 10
1684: ADD
1685: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
1686: LD_STRING CyrusIn07
1688: PPUSH
1689: LD_EXP 1
1693: PPUSH
1694: CALL_OW 30
1698: IFFALSE 1719
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1700: LD_ADDR_EXP 11
1704: PUSH
1705: LD_STRING Cyrus
1707: PPUSH
1708: LD_EXP 1
1712: NOT
1713: PPUSH
1714: CALL 267 0 2
1718: ST_TO_ADDR
// if Cyrus then
1719: LD_EXP 11
1723: IFFALSE 1741
// team := team ^ Cyrus ;
1725: LD_ADDR_VAR 0 3
1729: PUSH
1730: LD_VAR 0 3
1734: PUSH
1735: LD_EXP 11
1739: ADD
1740: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
1741: LD_STRING LisaIn07
1743: PPUSH
1744: LD_EXP 1
1748: PPUSH
1749: CALL_OW 30
1753: IFFALSE 1774
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1755: LD_ADDR_EXP 12
1759: PUSH
1760: LD_STRING Lisa
1762: PPUSH
1763: LD_EXP 1
1767: NOT
1768: PPUSH
1769: CALL 267 0 2
1773: ST_TO_ADDR
// if Lisa then
1774: LD_EXP 12
1778: IFFALSE 1796
// team := team ^ Lisa ;
1780: LD_ADDR_VAR 0 3
1784: PUSH
1785: LD_VAR 0 3
1789: PUSH
1790: LD_EXP 12
1794: ADD
1795: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
1796: LD_STRING GladstoneIn07
1798: PPUSH
1799: LD_EXP 1
1803: PPUSH
1804: CALL_OW 30
1808: IFFALSE 1829
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
1810: LD_ADDR_EXP 14
1814: PUSH
1815: LD_STRING Gladstone
1817: PPUSH
1818: LD_EXP 1
1822: NOT
1823: PPUSH
1824: CALL 267 0 2
1828: ST_TO_ADDR
// if Gladstone then
1829: LD_EXP 14
1833: IFFALSE 1851
// team := team ^ Gladstone ;
1835: LD_ADDR_VAR 0 3
1839: PUSH
1840: LD_VAR 0 3
1844: PUSH
1845: LD_EXP 14
1849: ADD
1850: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
1851: LD_STRING KhatamIn07
1853: PPUSH
1854: LD_EXP 1
1858: PPUSH
1859: CALL_OW 30
1863: IFFALSE 1884
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1865: LD_ADDR_EXP 15
1869: PUSH
1870: LD_STRING Khatam
1872: PPUSH
1873: LD_EXP 1
1877: NOT
1878: PPUSH
1879: CALL 267 0 2
1883: ST_TO_ADDR
// if Khatam then
1884: LD_EXP 15
1888: IFFALSE 1906
// team := team ^ Khatam ;
1890: LD_ADDR_VAR 0 3
1894: PUSH
1895: LD_VAR 0 3
1899: PUSH
1900: LD_EXP 15
1904: ADD
1905: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
1906: LD_ADDR_VAR 0 4
1910: PUSH
1911: LD_STRING 07_others
1913: PPUSH
1914: CALL_OW 31
1918: ST_TO_ADDR
// if others then
1919: LD_VAR 0 4
1923: IFFALSE 1941
// team := team ^ others ;
1925: LD_ADDR_VAR 0 3
1929: PUSH
1930: LD_VAR 0 3
1934: PUSH
1935: LD_VAR 0 4
1939: ADD
1940: ST_TO_ADDR
// if debug then
1941: LD_EXP 1
1945: IFFALSE 2019
// begin InitHc ;
1947: CALL_OW 19
// for i = 1 to 4 do
1951: LD_ADDR_VAR 0 2
1955: PUSH
1956: DOUBLE
1957: LD_INT 1
1959: DEC
1960: ST_TO_ADDR
1961: LD_INT 4
1963: PUSH
1964: FOR_TO
1965: IFFALSE 2017
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
1967: LD_INT 0
1969: PPUSH
1970: LD_INT 1
1972: PUSH
1973: LD_INT 3
1975: PUSH
1976: EMPTY
1977: LIST
1978: LIST
1979: PUSH
1980: LD_INT 1
1982: PPUSH
1983: LD_INT 2
1985: PPUSH
1986: CALL_OW 12
1990: ARRAY
1991: PPUSH
1992: LD_INT 4
1994: PPUSH
1995: CALL_OW 380
// team := team ^ CreateHuman ;
1999: LD_ADDR_VAR 0 3
2003: PUSH
2004: LD_VAR 0 3
2008: PUSH
2009: CALL_OW 44
2013: ADD
2014: ST_TO_ADDR
// end ;
2015: GO 1964
2017: POP
2018: POP
// end ; m := 0 ;
2019: LD_ADDR_VAR 0 6
2023: PUSH
2024: LD_INT 0
2026: ST_TO_ADDR
// for i in team do
2027: LD_ADDR_VAR 0 2
2031: PUSH
2032: LD_VAR 0 3
2036: PUSH
2037: FOR_IN
2038: IFFALSE 2218
// if GetClass ( i ) = 3 then
2040: LD_VAR 0 2
2044: PPUSH
2045: CALL_OW 257
2049: PUSH
2050: LD_INT 3
2052: EQUAL
2053: IFFALSE 2201
// begin m := m + 1 ;
2055: LD_ADDR_VAR 0 6
2059: PUSH
2060: LD_VAR 0 6
2064: PUSH
2065: LD_INT 1
2067: PLUS
2068: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
2069: LD_ADDR_VAR 0 5
2073: PUSH
2074: LD_INT 1
2076: PPUSH
2077: LD_INT 1
2079: PPUSH
2080: LD_INT 2
2082: PUSH
2083: LD_INT 3
2085: PUSH
2086: LD_INT 2
2088: PUSH
2089: LD_INT 1
2091: PUSH
2092: EMPTY
2093: LIST
2094: LIST
2095: LIST
2096: LIST
2097: PUSH
2098: LD_VAR 0 6
2102: PUSH
2103: LD_INT 4
2105: MOD
2106: PUSH
2107: LD_INT 1
2109: PLUS
2110: ARRAY
2111: PPUSH
2112: LD_INT 2
2114: PPUSH
2115: LD_INT 1
2117: PPUSH
2118: LD_INT 4
2120: PUSH
2121: LD_INT 5
2123: PUSH
2124: LD_INT 3
2126: PUSH
2127: LD_INT 11
2129: PUSH
2130: EMPTY
2131: LIST
2132: LIST
2133: LIST
2134: LIST
2135: PUSH
2136: LD_VAR 0 6
2140: PUSH
2141: LD_INT 4
2143: MOD
2144: PUSH
2145: LD_INT 1
2147: PLUS
2148: ARRAY
2149: PPUSH
2150: LD_INT 60
2152: PPUSH
2153: CALL 330 0 7
2157: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2158: LD_VAR 0 5
2162: PPUSH
2163: LD_INT 2
2165: PPUSH
2166: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
2170: LD_VAR 0 5
2174: PPUSH
2175: LD_INT 1
2177: PPUSH
2178: LD_INT 0
2180: PPUSH
2181: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2185: LD_VAR 0 2
2189: PPUSH
2190: LD_VAR 0 5
2194: PPUSH
2195: CALL_OW 52
// end else
2199: GO 2216
// PlaceUnitArea ( i , startArea , false ) ;
2201: LD_VAR 0 2
2205: PPUSH
2206: LD_INT 1
2208: PPUSH
2209: LD_INT 0
2211: PPUSH
2212: CALL_OW 49
2216: GO 2037
2218: POP
2219: POP
// uc_side := 4 ;
2220: LD_ADDR_OWVAR 20
2224: PUSH
2225: LD_INT 4
2227: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
2228: LD_ADDR_EXP 17
2232: PUSH
2233: LD_STRING Harisson
2235: PPUSH
2236: LD_INT 0
2238: PPUSH
2239: CALL 267 0 2
2243: ST_TO_ADDR
// PrepareScout ;
2244: CALL 2253 0 0
// end ;
2248: LD_VAR 0 1
2252: RET
// function PrepareScout ; var ape ; begin
2253: LD_INT 0
2255: PPUSH
2256: PPUSH
// uc_side := 4 ;
2257: LD_ADDR_OWVAR 20
2261: PUSH
2262: LD_INT 4
2264: ST_TO_ADDR
// uc_nation := 1 ;
2265: LD_ADDR_OWVAR 21
2269: PUSH
2270: LD_INT 1
2272: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
2273: LD_STRING FrankIn06
2275: PPUSH
2276: LD_INT 0
2278: PPUSH
2279: CALL_OW 30
2283: IFFALSE 2300
// Frank := CreateCharacter ( 06c_Frank ) else
2285: LD_ADDR_EXP 13
2289: PUSH
2290: LD_STRING 06c_Frank
2292: PPUSH
2293: CALL_OW 34
2297: ST_TO_ADDR
2298: GO 2340
// if LoadVariable ( FrankInDelta , 0 ) then
2300: LD_STRING FrankInDelta
2302: PPUSH
2303: LD_INT 0
2305: PPUSH
2306: CALL_OW 30
2310: IFFALSE 2327
// Frank := CreateCharacter ( 05_Frank ) else
2312: LD_ADDR_EXP 13
2316: PUSH
2317: LD_STRING 05_Frank
2319: PPUSH
2320: CALL_OW 34
2324: ST_TO_ADDR
2325: GO 2340
// Frank := CreateCharacter ( 04_Frank ) ;
2327: LD_ADDR_EXP 13
2331: PUSH
2332: LD_STRING 04_Frank
2334: PPUSH
2335: CALL_OW 34
2339: ST_TO_ADDR
// if Frank then
2340: LD_EXP 13
2344: IFFALSE 2465
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
2346: LD_EXP 13
2350: PPUSH
2351: LD_INT 2
2353: PPUSH
2354: LD_INT 0
2356: PPUSH
2357: CALL_OW 49
// uc_side := 0 ;
2361: LD_ADDR_OWVAR 20
2365: PUSH
2366: LD_INT 0
2368: ST_TO_ADDR
// uc_nation := 0 ;
2369: LD_ADDR_OWVAR 21
2373: PUSH
2374: LD_INT 0
2376: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
2377: LD_INT 0
2379: PPUSH
2380: LD_INT 12
2382: PPUSH
2383: LD_INT 0
2385: PPUSH
2386: CALL_OW 380
// ape := CreateHuman ;
2390: LD_ADDR_VAR 0 2
2394: PUSH
2395: CALL_OW 44
2399: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
2400: LD_VAR 0 2
2404: PPUSH
2405: LD_EXP 13
2409: PPUSH
2410: CALL_OW 250
2414: PPUSH
2415: LD_EXP 13
2419: PPUSH
2420: CALL_OW 251
2424: PPUSH
2425: LD_INT 5
2427: PPUSH
2428: LD_INT 0
2430: PPUSH
2431: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
2435: LD_VAR 0 2
2439: PPUSH
2440: LD_EXP 13
2444: PPUSH
2445: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
2449: LD_EXP 13
2453: PPUSH
2454: LD_VAR 0 2
2458: PPUSH
2459: CALL_OW 119
// exit ;
2463: GO 2505
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
2465: LD_ADDR_EXP 16
2469: PUSH
2470: LD_STRING Yamoko
2472: PPUSH
2473: LD_INT 0
2475: PPUSH
2476: CALL 267 0 2
2480: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
2481: LD_EXP 16
2485: PPUSH
2486: LD_INT 2
2488: PPUSH
2489: LD_INT 0
2491: PPUSH
2492: CALL_OW 49
// ComHold ( Kikuchi ) ;
2496: LD_EXP 16
2500: PPUSH
2501: CALL_OW 140
// end ; end_of_file
2505: LD_VAR 0 1
2509: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
2510: LD_INT 0
2512: PPUSH
2513: PPUSH
2514: PPUSH
2515: PPUSH
2516: PPUSH
2517: PPUSH
2518: PPUSH
2519: PPUSH
2520: PPUSH
2521: PPUSH
2522: PPUSH
2523: PPUSH
2524: PPUSH
2525: PPUSH
2526: PPUSH
2527: PPUSH
// ru_rebuild_list := [ ] ;
2528: LD_ADDR_EXP 18
2532: PUSH
2533: EMPTY
2534: ST_TO_ADDR
// uc_side := 3 ;
2535: LD_ADDR_OWVAR 20
2539: PUSH
2540: LD_INT 3
2542: ST_TO_ADDR
// uc_nation := 3 ;
2543: LD_ADDR_OWVAR 21
2547: PUSH
2548: LD_INT 3
2550: ST_TO_ADDR
// if Difficulty > 1 then
2551: LD_OWVAR 67
2555: PUSH
2556: LD_INT 1
2558: GREATER
2559: IFFALSE 2695
// begin bc_type := b_breastwork ;
2561: LD_ADDR_OWVAR 42
2565: PUSH
2566: LD_INT 31
2568: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
2569: LD_INT 78
2571: PPUSH
2572: LD_INT 74
2574: PPUSH
2575: LD_INT 2
2577: PPUSH
2578: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
2582: LD_INT 171
2584: PPUSH
2585: LD_INT 193
2587: PPUSH
2588: LD_INT 4
2590: PPUSH
2591: CALL_OW 47
// bc_type := b_turret ;
2595: LD_ADDR_OWVAR 42
2599: PUSH
2600: LD_INT 33
2602: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
2603: LD_INT 129
2605: PPUSH
2606: LD_INT 96
2608: PPUSH
2609: LD_INT 3
2611: PPUSH
2612: CALL_OW 47
// if Difficulty > 2 then
2616: LD_OWVAR 67
2620: PUSH
2621: LD_INT 2
2623: GREATER
2624: IFFALSE 2695
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
2626: LD_INT 83
2628: PPUSH
2629: LD_INT 141
2631: PPUSH
2632: CALL_OW 428
2636: PPUSH
2637: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
2641: LD_INT 78
2643: PPUSH
2644: LD_INT 133
2646: PPUSH
2647: CALL_OW 428
2651: PPUSH
2652: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
2656: LD_INT 83
2658: PPUSH
2659: LD_INT 141
2661: PPUSH
2662: LD_INT 2
2664: PPUSH
2665: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
2669: LD_INT 78
2671: PPUSH
2672: LD_INT 133
2674: PPUSH
2675: LD_INT 2
2677: PPUSH
2678: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
2682: LD_INT 145
2684: PPUSH
2685: LD_INT 112
2687: PPUSH
2688: LD_INT 3
2690: PPUSH
2691: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
2695: LD_ADDR_VAR 0 9
2699: PUSH
2700: LD_INT 22
2702: PUSH
2703: LD_INT 3
2705: PUSH
2706: EMPTY
2707: LIST
2708: LIST
2709: PUSH
2710: LD_INT 2
2712: PUSH
2713: LD_INT 30
2715: PUSH
2716: LD_INT 0
2718: PUSH
2719: EMPTY
2720: LIST
2721: LIST
2722: PUSH
2723: LD_INT 30
2725: PUSH
2726: LD_INT 1
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: PUSH
2733: EMPTY
2734: LIST
2735: LIST
2736: LIST
2737: PUSH
2738: EMPTY
2739: LIST
2740: LIST
2741: PPUSH
2742: CALL_OW 69
2746: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
2747: LD_ADDR_VAR 0 10
2751: PUSH
2752: LD_INT 22
2754: PUSH
2755: LD_INT 3
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: PUSH
2762: LD_INT 2
2764: PUSH
2765: LD_INT 30
2767: PUSH
2768: LD_INT 6
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: PUSH
2775: LD_INT 30
2777: PUSH
2778: LD_INT 7
2780: PUSH
2781: EMPTY
2782: LIST
2783: LIST
2784: PUSH
2785: LD_INT 30
2787: PUSH
2788: LD_INT 8
2790: PUSH
2791: EMPTY
2792: LIST
2793: LIST
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: LIST
2799: LIST
2800: PUSH
2801: EMPTY
2802: LIST
2803: LIST
2804: PPUSH
2805: CALL_OW 69
2809: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
2810: LD_ADDR_VAR 0 11
2814: PUSH
2815: LD_INT 22
2817: PUSH
2818: LD_INT 3
2820: PUSH
2821: EMPTY
2822: LIST
2823: LIST
2824: PUSH
2825: LD_INT 30
2827: PUSH
2828: LD_INT 3
2830: PUSH
2831: EMPTY
2832: LIST
2833: LIST
2834: PUSH
2835: EMPTY
2836: LIST
2837: LIST
2838: PPUSH
2839: CALL_OW 69
2843: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
2844: LD_ADDR_VAR 0 12
2848: PUSH
2849: LD_INT 22
2851: PUSH
2852: LD_INT 3
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: PUSH
2859: LD_INT 30
2861: PUSH
2862: LD_INT 31
2864: PUSH
2865: EMPTY
2866: LIST
2867: LIST
2868: PUSH
2869: EMPTY
2870: LIST
2871: LIST
2872: PPUSH
2873: CALL_OW 69
2877: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
2878: LD_ADDR_VAR 0 13
2882: PUSH
2883: LD_INT 22
2885: PUSH
2886: LD_INT 3
2888: PUSH
2889: EMPTY
2890: LIST
2891: LIST
2892: PUSH
2893: LD_INT 30
2895: PUSH
2896: LD_INT 32
2898: PUSH
2899: EMPTY
2900: LIST
2901: LIST
2902: PUSH
2903: EMPTY
2904: LIST
2905: LIST
2906: PPUSH
2907: CALL_OW 69
2911: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
2912: LD_ADDR_VAR 0 14
2916: PUSH
2917: LD_INT 22
2919: PUSH
2920: LD_INT 3
2922: PUSH
2923: EMPTY
2924: LIST
2925: LIST
2926: PUSH
2927: LD_INT 30
2929: PUSH
2930: LD_INT 33
2932: PUSH
2933: EMPTY
2934: LIST
2935: LIST
2936: PUSH
2937: EMPTY
2938: LIST
2939: LIST
2940: PPUSH
2941: CALL_OW 69
2945: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
2946: LD_ADDR_VAR 0 15
2950: PUSH
2951: LD_INT 42
2953: PUSH
2954: LD_INT 5
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: PUSH
2961: LD_INT 43
2963: PUSH
2964: LD_INT 50
2966: PUSH
2967: EMPTY
2968: LIST
2969: LIST
2970: PUSH
2971: LD_INT 44
2973: PUSH
2974: LD_INT 30
2976: PUSH
2977: EMPTY
2978: LIST
2979: LIST
2980: PUSH
2981: LD_INT 46
2983: PUSH
2984: LD_INT 15
2986: PUSH
2987: EMPTY
2988: LIST
2989: LIST
2990: PUSH
2991: EMPTY
2992: LIST
2993: LIST
2994: LIST
2995: LIST
2996: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 4 , 3 ] ;
2997: LD_ADDR_VAR 0 16
3001: PUSH
3002: LD_INT 0
3004: PUSH
3005: LD_INT 4
3007: PUSH
3008: LD_INT 4
3010: PUSH
3011: LD_INT 3
3013: PUSH
3014: EMPTY
3015: LIST
3016: LIST
3017: LIST
3018: LIST
3019: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
3020: LD_ADDR_VAR 0 6
3024: PUSH
3025: LD_INT 4
3027: PUSH
3028: LD_INT 5
3030: PUSH
3031: LD_INT 6
3033: PUSH
3034: EMPTY
3035: LIST
3036: LIST
3037: LIST
3038: PUSH
3039: LD_OWVAR 67
3043: ARRAY
3044: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
3045: LD_INT 16
3047: PPUSH
3048: LD_STRING am_tukh
3050: PPUSH
3051: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
3055: LD_ADDR_VAR 0 2
3059: PUSH
3060: LD_INT 21
3062: PUSH
3063: LD_INT 3
3065: PUSH
3066: EMPTY
3067: LIST
3068: LIST
3069: PPUSH
3070: CALL_OW 69
3074: PUSH
3075: FOR_IN
3076: IFFALSE 3109
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
3078: LD_VAR 0 2
3082: PPUSH
3083: LD_INT 4
3085: PUSH
3086: LD_INT 5
3088: PUSH
3089: LD_INT 6
3091: PUSH
3092: EMPTY
3093: LIST
3094: LIST
3095: LIST
3096: PUSH
3097: LD_OWVAR 67
3101: ARRAY
3102: PPUSH
3103: CALL_OW 241
3107: GO 3075
3109: POP
3110: POP
// for i in dep_list do
3111: LD_ADDR_VAR 0 2
3115: PUSH
3116: LD_VAR 0 9
3120: PUSH
3121: FOR_IN
3122: IFFALSE 3166
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
3124: LD_VAR 0 2
3128: PPUSH
3129: CALL_OW 274
3133: PPUSH
3134: LD_INT 1
3136: PPUSH
3137: LD_INT 1000
3139: PPUSH
3140: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
3144: LD_VAR 0 2
3148: PPUSH
3149: CALL_OW 274
3153: PPUSH
3154: LD_INT 2
3156: PPUSH
3157: LD_INT 1000
3159: PPUSH
3160: CALL_OW 277
// end ;
3164: GO 3121
3166: POP
3167: POP
// InitHc ;
3168: CALL_OW 19
// tmp := bunker_list * [ 50 , 70 , 85 ] [ Difficulty ] div 100 ;
3172: LD_ADDR_VAR 0 8
3176: PUSH
3177: LD_VAR 0 13
3181: PUSH
3182: LD_INT 50
3184: PUSH
3185: LD_INT 70
3187: PUSH
3188: LD_INT 85
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: LIST
3195: PUSH
3196: LD_OWVAR 67
3200: ARRAY
3201: MUL
3202: PUSH
3203: LD_INT 100
3205: DIV
3206: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
3207: LD_ADDR_VAR 0 16
3211: PUSH
3212: LD_VAR 0 16
3216: PPUSH
3217: LD_INT 1
3219: PPUSH
3220: LD_VAR 0 8
3224: PPUSH
3225: CALL_OW 1
3229: ST_TO_ADDR
// tmp := [ ] ;
3230: LD_ADDR_VAR 0 8
3234: PUSH
3235: EMPTY
3236: ST_TO_ADDR
// for i in bunker_list do
3237: LD_ADDR_VAR 0 2
3241: PUSH
3242: LD_VAR 0 13
3246: PUSH
3247: FOR_IN
3248: IFFALSE 3344
// if i mod 10 + 1 < tmp then
3250: LD_VAR 0 2
3254: PUSH
3255: LD_INT 10
3257: MOD
3258: PUSH
3259: LD_INT 1
3261: PLUS
3262: PUSH
3263: LD_VAR 0 8
3267: LESS
3268: IFFALSE 3313
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
3270: LD_ADDR_VAR 0 8
3274: PUSH
3275: LD_VAR 0 8
3279: PPUSH
3280: LD_VAR 0 2
3284: PUSH
3285: LD_INT 3
3287: PPUSH
3288: LD_INT 5
3290: PPUSH
3291: CALL_OW 12
3295: MOD
3296: PUSH
3297: LD_INT 1
3299: PLUS
3300: PPUSH
3301: LD_VAR 0 2
3305: PPUSH
3306: CALL_OW 2
3310: ST_TO_ADDR
3311: GO 3342
// tmp := Insert ( tmp , tmp + 1 , i ) ;
3313: LD_ADDR_VAR 0 8
3317: PUSH
3318: LD_VAR 0 8
3322: PPUSH
3323: LD_VAR 0 8
3327: PUSH
3328: LD_INT 1
3330: PLUS
3331: PPUSH
3332: LD_VAR 0 2
3336: PPUSH
3337: CALL_OW 2
3341: ST_TO_ADDR
3342: GO 3247
3344: POP
3345: POP
// bunker_list := tmp ;
3346: LD_ADDR_VAR 0 13
3350: PUSH
3351: LD_VAR 0 8
3355: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
3356: LD_ADDR_VAR 0 2
3360: PUSH
3361: LD_VAR 0 13
3365: PUSH
3366: LD_VAR 0 14
3370: ADD
3371: PUSH
3372: FOR_IN
3373: IFFALSE 3470
// begin tmp := rand ( 0 , 100 ) ;
3375: LD_ADDR_VAR 0 8
3379: PUSH
3380: LD_INT 0
3382: PPUSH
3383: LD_INT 100
3385: PPUSH
3386: CALL_OW 12
3390: ST_TO_ADDR
// r := 0 ;
3391: LD_ADDR_VAR 0 4
3395: PUSH
3396: LD_INT 0
3398: ST_TO_ADDR
// for j in weapons_list do
3399: LD_ADDR_VAR 0 3
3403: PUSH
3404: LD_VAR 0 15
3408: PUSH
3409: FOR_IN
3410: IFFALSE 3466
// begin r := r + j [ 2 ] ;
3412: LD_ADDR_VAR 0 4
3416: PUSH
3417: LD_VAR 0 4
3421: PUSH
3422: LD_VAR 0 3
3426: PUSH
3427: LD_INT 2
3429: ARRAY
3430: PLUS
3431: ST_TO_ADDR
// if r >= tmp then
3432: LD_VAR 0 4
3436: PUSH
3437: LD_VAR 0 8
3441: GREATEREQUAL
3442: IFFALSE 3464
// begin PlaceWeaponTurret ( i , j [ 1 ] ) ;
3444: LD_VAR 0 2
3448: PPUSH
3449: LD_VAR 0 3
3453: PUSH
3454: LD_INT 1
3456: ARRAY
3457: PPUSH
3458: CALL_OW 431
// break ;
3462: GO 3466
// end ; end ;
3464: GO 3409
3466: POP
3467: POP
// end ;
3468: GO 3372
3470: POP
3471: POP
// while ( personel_counter [ 1 ] ) do
3472: LD_VAR 0 16
3476: PUSH
3477: LD_INT 1
3479: ARRAY
3480: IFFALSE 3588
// begin i := rand ( 1 , bunker_list ) ;
3482: LD_ADDR_VAR 0 2
3486: PUSH
3487: LD_INT 1
3489: PPUSH
3490: LD_VAR 0 13
3494: PPUSH
3495: CALL_OW 12
3499: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3500: LD_INT 0
3502: PPUSH
3503: LD_INT 1
3505: PPUSH
3506: LD_VAR 0 6
3510: PPUSH
3511: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
3515: CALL_OW 44
3519: PPUSH
3520: LD_VAR 0 13
3524: PUSH
3525: LD_VAR 0 2
3529: ARRAY
3530: PPUSH
3531: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
3535: LD_ADDR_VAR 0 13
3539: PUSH
3540: LD_VAR 0 13
3544: PPUSH
3545: LD_VAR 0 2
3549: PPUSH
3550: CALL_OW 3
3554: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
3555: LD_ADDR_VAR 0 16
3559: PUSH
3560: LD_VAR 0 16
3564: PPUSH
3565: LD_INT 1
3567: PPUSH
3568: LD_VAR 0 16
3572: PUSH
3573: LD_INT 1
3575: ARRAY
3576: PUSH
3577: LD_INT 1
3579: MINUS
3580: PPUSH
3581: CALL_OW 1
3585: ST_TO_ADDR
// end ;
3586: GO 3472
// for i = 1 to personel_counter [ 2 ] do
3588: LD_ADDR_VAR 0 2
3592: PUSH
3593: DOUBLE
3594: LD_INT 1
3596: DEC
3597: ST_TO_ADDR
3598: LD_VAR 0 16
3602: PUSH
3603: LD_INT 2
3605: ARRAY
3606: PUSH
3607: FOR_TO
3608: IFFALSE 3639
// begin PrepareHuman ( false , 2 , skill ) ;
3610: LD_INT 0
3612: PPUSH
3613: LD_INT 2
3615: PPUSH
3616: LD_VAR 0 6
3620: PPUSH
3621: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
3625: CALL_OW 44
3629: PPUSH
3630: LD_INT 16
3632: PPUSH
3633: CALL_OW 52
// end ;
3637: GO 3607
3639: POP
3640: POP
// for i = 1 to personel_counter [ 3 ] do
3641: LD_ADDR_VAR 0 2
3645: PUSH
3646: DOUBLE
3647: LD_INT 1
3649: DEC
3650: ST_TO_ADDR
3651: LD_VAR 0 16
3655: PUSH
3656: LD_INT 3
3658: ARRAY
3659: PUSH
3660: FOR_TO
3661: IFFALSE 3698
// begin PrepareHuman ( false , 3 , skill ) ;
3663: LD_INT 0
3665: PPUSH
3666: LD_INT 3
3668: PPUSH
3669: LD_VAR 0 6
3673: PPUSH
3674: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ 1 ] ) ;
3678: CALL_OW 44
3682: PPUSH
3683: LD_VAR 0 11
3687: PUSH
3688: LD_INT 1
3690: ARRAY
3691: PPUSH
3692: CALL_OW 52
// end ;
3696: GO 3660
3698: POP
3699: POP
// for i = 1 to personel_counter [ 4 ] do
3700: LD_ADDR_VAR 0 2
3704: PUSH
3705: DOUBLE
3706: LD_INT 1
3708: DEC
3709: ST_TO_ADDR
3710: LD_VAR 0 16
3714: PUSH
3715: LD_INT 4
3717: ARRAY
3718: PUSH
3719: FOR_TO
3720: IFFALSE 3757
// begin PrepareHuman ( false , 4 , skill ) ;
3722: LD_INT 0
3724: PPUSH
3725: LD_INT 4
3727: PPUSH
3728: LD_VAR 0 6
3732: PPUSH
3733: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
3737: CALL_OW 44
3741: PPUSH
3742: LD_VAR 0 10
3746: PUSH
3747: LD_INT 1
3749: ARRAY
3750: PPUSH
3751: CALL_OW 52
// end ;
3755: GO 3719
3757: POP
3758: POP
// for i in breastworks_list do
3759: LD_ADDR_VAR 0 2
3763: PUSH
3764: LD_VAR 0 12
3768: PUSH
3769: FOR_IN
3770: IFFALSE 3882
// begin r := GetDir ( i ) ;
3772: LD_ADDR_VAR 0 4
3776: PUSH
3777: LD_VAR 0 2
3781: PPUSH
3782: CALL_OW 254
3786: ST_TO_ADDR
// if r > 3 then
3787: LD_VAR 0 4
3791: PUSH
3792: LD_INT 3
3794: GREATER
3795: IFFALSE 3813
// r := r - 3 else
3797: LD_ADDR_VAR 0 4
3801: PUSH
3802: LD_VAR 0 4
3806: PUSH
3807: LD_INT 3
3809: MINUS
3810: ST_TO_ADDR
3811: GO 3827
// r := r + 3 ;
3813: LD_ADDR_VAR 0 4
3817: PUSH
3818: LD_VAR 0 4
3822: PUSH
3823: LD_INT 3
3825: PLUS
3826: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3827: LD_INT 0
3829: PPUSH
3830: LD_INT 1
3832: PPUSH
3833: LD_VAR 0 6
3837: PPUSH
3838: CALL_OW 380
// un := CreateHuman ;
3842: LD_ADDR_VAR 0 5
3846: PUSH
3847: CALL_OW 44
3851: ST_TO_ADDR
// SetDir ( un , r ) ;
3852: LD_VAR 0 5
3856: PPUSH
3857: LD_VAR 0 4
3861: PPUSH
3862: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3866: LD_VAR 0 5
3870: PPUSH
3871: LD_VAR 0 2
3875: PPUSH
3876: CALL_OW 52
// end ;
3880: GO 3769
3882: POP
3883: POP
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
3884: LD_ADDR_VAR 0 4
3888: PUSH
3889: LD_INT 4
3891: PUSH
3892: LD_INT 5
3894: PUSH
3895: LD_INT 6
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: LIST
3902: PUSH
3903: LD_OWVAR 67
3907: ARRAY
3908: ST_TO_ADDR
// for i = 1 to r do
3909: LD_ADDR_VAR 0 2
3913: PUSH
3914: DOUBLE
3915: LD_INT 1
3917: DEC
3918: ST_TO_ADDR
3919: LD_VAR 0 4
3923: PUSH
3924: FOR_TO
3925: IFFALSE 4020
// begin un := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
3927: LD_ADDR_VAR 0 5
3931: PUSH
3932: LD_INT 3
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 22
3940: PPUSH
3941: LD_INT 1
3943: PPUSH
3944: LD_INT 1
3946: PPUSH
3947: LD_INT 43
3949: PUSH
3950: LD_INT 44
3952: PUSH
3953: LD_INT 42
3955: PUSH
3956: EMPTY
3957: LIST
3958: LIST
3959: LIST
3960: PUSH
3961: LD_VAR 0 2
3965: PUSH
3966: LD_INT 3
3968: MOD
3969: PUSH
3970: LD_INT 1
3972: PLUS
3973: ARRAY
3974: PPUSH
3975: LD_INT 100
3977: PPUSH
3978: CALL 330 0 7
3982: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3983: LD_VAR 0 5
3987: PPUSH
3988: LD_INT 0
3990: PPUSH
3991: LD_INT 5
3993: PPUSH
3994: CALL_OW 12
3998: PPUSH
3999: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
4003: LD_VAR 0 5
4007: PPUSH
4008: LD_INT 5
4010: PPUSH
4011: LD_INT 0
4013: PPUSH
4014: CALL_OW 49
// end ;
4018: GO 3924
4020: POP
4021: POP
// end ;
4022: LD_VAR 0 1
4026: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_ok ] ] ) do var i , filter , tmp , engs , enemy ;
4027: LD_INT 22
4029: PUSH
4030: LD_INT 3
4032: PUSH
4033: EMPTY
4034: LIST
4035: LIST
4036: PUSH
4037: LD_INT 25
4039: PUSH
4040: LD_INT 2
4042: PUSH
4043: EMPTY
4044: LIST
4045: LIST
4046: PUSH
4047: LD_INT 50
4049: PUSH
4050: EMPTY
4051: LIST
4052: PUSH
4053: EMPTY
4054: LIST
4055: LIST
4056: LIST
4057: PPUSH
4058: CALL_OW 69
4062: IFFALSE 4758
4064: GO 4066
4066: DISABLE
4067: LD_INT 0
4069: PPUSH
4070: PPUSH
4071: PPUSH
4072: PPUSH
4073: PPUSH
// begin enable ;
4074: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
4075: LD_ADDR_VAR 0 2
4079: PUSH
4080: LD_INT 6
4082: PPUSH
4083: LD_INT 3
4085: PUSH
4086: LD_INT 24
4088: PUSH
4089: LD_INT 1000
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: PUSH
4096: EMPTY
4097: LIST
4098: LIST
4099: PUSH
4100: LD_INT 21
4102: PUSH
4103: LD_INT 3
4105: PUSH
4106: EMPTY
4107: LIST
4108: LIST
4109: PUSH
4110: EMPTY
4111: LIST
4112: LIST
4113: PPUSH
4114: CALL_OW 70
4118: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_lives , 650 ] ] ) ;
4119: LD_ADDR_VAR 0 4
4123: PUSH
4124: LD_INT 22
4126: PUSH
4127: LD_INT 3
4129: PUSH
4130: EMPTY
4131: LIST
4132: LIST
4133: PUSH
4134: LD_INT 25
4136: PUSH
4137: LD_INT 2
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: PUSH
4144: LD_INT 24
4146: PUSH
4147: LD_INT 650
4149: PUSH
4150: EMPTY
4151: LIST
4152: LIST
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: LIST
4158: PPUSH
4159: CALL_OW 69
4163: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
4164: LD_VAR 0 2
4168: NOT
4169: PUSH
4170: LD_EXP 18
4174: NOT
4175: AND
4176: IFFALSE 4208
// begin if not IsInUnit ( engs [ 1 ] ) then
4178: LD_VAR 0 4
4182: PUSH
4183: LD_INT 1
4185: ARRAY
4186: PPUSH
4187: CALL_OW 310
4191: NOT
4192: IFFALSE 4206
// ComEnterUnit ( engs , ru_dep_main ) ;
4194: LD_VAR 0 4
4198: PPUSH
4199: LD_INT 16
4201: PPUSH
4202: CALL_OW 120
// exit ;
4206: GO 4758
// end ; if debug then
4208: LD_EXP 1
4212: IFFALSE 4233
// display_strings := [ engs , filter ] ;
4214: LD_ADDR_OWVAR 47
4218: PUSH
4219: LD_VAR 0 4
4223: PUSH
4224: LD_VAR 0 2
4228: PUSH
4229: EMPTY
4230: LIST
4231: LIST
4232: ST_TO_ADDR
// if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
4233: LD_VAR 0 4
4237: PPUSH
4238: LD_INT 3
4240: PUSH
4241: LD_INT 24
4243: PUSH
4244: LD_INT 650
4246: PUSH
4247: EMPTY
4248: LIST
4249: LIST
4250: PUSH
4251: EMPTY
4252: LIST
4253: LIST
4254: PPUSH
4255: CALL_OW 72
4259: IFFALSE 4352
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
4261: LD_ADDR_VAR 0 3
4265: PUSH
4266: LD_VAR 0 4
4270: PPUSH
4271: LD_INT 3
4273: PUSH
4274: LD_INT 24
4276: PUSH
4277: LD_INT 650
4279: PUSH
4280: EMPTY
4281: LIST
4282: LIST
4283: PUSH
4284: EMPTY
4285: LIST
4286: LIST
4287: PPUSH
4288: CALL_OW 72
4292: ST_TO_ADDR
// for i in tmp do
4293: LD_ADDR_VAR 0 1
4297: PUSH
4298: LD_VAR 0 3
4302: PUSH
4303: FOR_IN
4304: IFFALSE 4350
// if not IsInArea ( i , mainBaseArea ) then
4306: LD_VAR 0 1
4310: PPUSH
4311: LD_INT 14
4313: PPUSH
4314: CALL_OW 308
4318: NOT
4319: IFFALSE 4348
// begin ComMoveXY ( i , 129 , 125 ) ;
4321: LD_VAR 0 1
4325: PPUSH
4326: LD_INT 129
4328: PPUSH
4329: LD_INT 125
4331: PPUSH
4332: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
4336: LD_VAR 0 1
4340: PPUSH
4341: LD_INT 1050
4343: PPUSH
4344: CALL_OW 202
// end ;
4348: GO 4303
4350: POP
4351: POP
// end ; if filter then
4352: LD_VAR 0 2
4356: IFFALSE 4615
// begin for i in engs do
4358: LD_ADDR_VAR 0 1
4362: PUSH
4363: LD_VAR 0 4
4367: PUSH
4368: FOR_IN
4369: IFFALSE 4393
// if IsInUnit ( i ) then
4371: LD_VAR 0 1
4375: PPUSH
4376: CALL_OW 310
4380: IFFALSE 4391
// ComExitBuilding ( i ) ;
4382: LD_VAR 0 1
4386: PPUSH
4387: CALL_OW 122
4391: GO 4368
4393: POP
4394: POP
// wait ( 3 ) ;
4395: LD_INT 3
4397: PPUSH
4398: CALL_OW 67
// if filter >= 2 and engs >= 2 then
4402: LD_VAR 0 2
4406: PUSH
4407: LD_INT 2
4409: GREATEREQUAL
4410: PUSH
4411: LD_VAR 0 4
4415: PUSH
4416: LD_INT 2
4418: GREATEREQUAL
4419: AND
4420: IFFALSE 4568
// begin for i = 1 to engs / 2 do
4422: LD_ADDR_VAR 0 1
4426: PUSH
4427: DOUBLE
4428: LD_INT 1
4430: DEC
4431: ST_TO_ADDR
4432: LD_VAR 0 4
4436: PUSH
4437: LD_INT 2
4439: DIVREAL
4440: PUSH
4441: FOR_TO
4442: IFFALSE 4488
// if not HasTask ( engs [ i ] ) then
4444: LD_VAR 0 4
4448: PUSH
4449: LD_VAR 0 1
4453: ARRAY
4454: PPUSH
4455: CALL_OW 314
4459: NOT
4460: IFFALSE 4486
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
4462: LD_VAR 0 4
4466: PUSH
4467: LD_VAR 0 1
4471: ARRAY
4472: PPUSH
4473: LD_VAR 0 2
4477: PUSH
4478: LD_INT 1
4480: ARRAY
4481: PPUSH
4482: CALL_OW 130
4486: GO 4441
4488: POP
4489: POP
// for i = engs / 2 + 1 to engs do
4490: LD_ADDR_VAR 0 1
4494: PUSH
4495: DOUBLE
4496: LD_VAR 0 4
4500: PUSH
4501: LD_INT 2
4503: DIVREAL
4504: PUSH
4505: LD_INT 1
4507: PLUS
4508: DEC
4509: ST_TO_ADDR
4510: LD_VAR 0 4
4514: PUSH
4515: FOR_TO
4516: IFFALSE 4564
// if not HasTask ( engs [ i ] ) then
4518: LD_VAR 0 4
4522: PUSH
4523: LD_VAR 0 1
4527: ARRAY
4528: PPUSH
4529: CALL_OW 314
4533: NOT
4534: IFFALSE 4562
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
4536: LD_VAR 0 4
4540: PUSH
4541: LD_VAR 0 1
4545: ARRAY
4546: PPUSH
4547: LD_VAR 0 2
4551: PUSH
4552: LD_VAR 0 2
4556: ARRAY
4557: PPUSH
4558: CALL_OW 130
4562: GO 4515
4564: POP
4565: POP
// end else
4566: GO 4615
// for i in engs do
4568: LD_ADDR_VAR 0 1
4572: PUSH
4573: LD_VAR 0 4
4577: PUSH
4578: FOR_IN
4579: IFFALSE 4613
// if not HasTask ( i ) then
4581: LD_VAR 0 1
4585: PPUSH
4586: CALL_OW 314
4590: NOT
4591: IFFALSE 4611
// ComRepairBuilding ( i , filter [ 1 ] ) ;
4593: LD_VAR 0 1
4597: PPUSH
4598: LD_VAR 0 2
4602: PUSH
4603: LD_INT 1
4605: ARRAY
4606: PPUSH
4607: CALL_OW 130
4611: GO 4578
4613: POP
4614: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
4615: LD_ADDR_VAR 0 5
4619: PUSH
4620: LD_INT 81
4622: PUSH
4623: LD_INT 3
4625: PUSH
4626: EMPTY
4627: LIST
4628: LIST
4629: PPUSH
4630: CALL_OW 69
4634: ST_TO_ADDR
// if ru_rebuild_list and not filter then
4635: LD_EXP 18
4639: PUSH
4640: LD_VAR 0 2
4644: NOT
4645: AND
4646: IFFALSE 4758
// begin ComExitBuilding ( engs ) ;
4648: LD_VAR 0 4
4652: PPUSH
4653: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
4657: LD_VAR 0 5
4661: PPUSH
4662: LD_EXP 18
4666: PUSH
4667: LD_INT 2
4669: ARRAY
4670: PPUSH
4671: LD_EXP 18
4675: PUSH
4676: LD_INT 3
4678: ARRAY
4679: PPUSH
4680: CALL_OW 73
4684: PPUSH
4685: LD_EXP 18
4689: PUSH
4690: LD_INT 2
4692: ARRAY
4693: PPUSH
4694: LD_EXP 18
4698: PUSH
4699: LD_INT 3
4701: ARRAY
4702: PPUSH
4703: CALL_OW 297
4707: PUSH
4708: LD_INT 10
4710: GREATER
4711: IFFALSE 4758
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
4713: LD_VAR 0 4
4717: PPUSH
4718: LD_EXP 18
4722: PUSH
4723: LD_INT 1
4725: ARRAY
4726: PPUSH
4727: LD_EXP 18
4731: PUSH
4732: LD_INT 2
4734: ARRAY
4735: PPUSH
4736: LD_EXP 18
4740: PUSH
4741: LD_INT 3
4743: ARRAY
4744: PPUSH
4745: LD_EXP 18
4749: PUSH
4750: LD_INT 4
4752: ARRAY
4753: PPUSH
4754: CALL_OW 145
// end ; end ;
4758: PPOPN 5
4760: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 650 do var tmp ;
4761: LD_INT 16
4763: PPUSH
4764: CALL_OW 256
4768: PUSH
4769: LD_INT 650
4771: LESS
4772: IFFALSE 4855
4774: GO 4776
4776: DISABLE
4777: LD_INT 0
4779: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
4780: LD_ADDR_VAR 0 1
4784: PUSH
4785: LD_INT 22
4787: PUSH
4788: LD_INT 3
4790: PUSH
4791: EMPTY
4792: LIST
4793: LIST
4794: PUSH
4795: LD_INT 25
4797: PUSH
4798: LD_INT 1
4800: PUSH
4801: EMPTY
4802: LIST
4803: LIST
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: PPUSH
4809: CALL_OW 69
4813: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
4814: LD_VAR 0 1
4818: PPUSH
4819: CALL_OW 122
// wait ( 3 ) ;
4823: LD_INT 3
4825: PPUSH
4826: CALL_OW 67
// ComAgressiveMove ( tmp , GetX ( ru_dep_main ) , GetY ( ru_dep_main ) ) ;
4830: LD_VAR 0 1
4834: PPUSH
4835: LD_INT 16
4837: PPUSH
4838: CALL_OW 250
4842: PPUSH
4843: LD_INT 16
4845: PPUSH
4846: CALL_OW 251
4850: PPUSH
4851: CALL_OW 114
// end ;
4855: PPOPN 1
4857: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
4858: LD_INT 22
4860: PUSH
4861: LD_INT 3
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PUSH
4868: LD_INT 25
4870: PUSH
4871: LD_INT 4
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: PPUSH
4882: CALL_OW 69
4886: IFFALSE 5118
4888: GO 4890
4890: DISABLE
4891: LD_INT 0
4893: PPUSH
4894: PPUSH
4895: PPUSH
// begin enable ;
4896: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4897: LD_ADDR_VAR 0 2
4901: PUSH
4902: LD_INT 14
4904: PPUSH
4905: LD_INT 21
4907: PUSH
4908: LD_INT 1
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PUSH
4915: LD_INT 3
4917: PUSH
4918: LD_INT 24
4920: PUSH
4921: LD_INT 1000
4923: PUSH
4924: EMPTY
4925: LIST
4926: LIST
4927: PUSH
4928: EMPTY
4929: LIST
4930: LIST
4931: PUSH
4932: EMPTY
4933: LIST
4934: LIST
4935: PPUSH
4936: CALL_OW 70
4940: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
4941: LD_ADDR_VAR 0 3
4945: PUSH
4946: LD_INT 22
4948: PUSH
4949: LD_INT 3
4951: PUSH
4952: EMPTY
4953: LIST
4954: LIST
4955: PUSH
4956: LD_INT 25
4958: PUSH
4959: LD_INT 4
4961: PUSH
4962: EMPTY
4963: LIST
4964: LIST
4965: PUSH
4966: EMPTY
4967: LIST
4968: LIST
4969: PPUSH
4970: CALL_OW 69
4974: ST_TO_ADDR
// if not tmp and not IsInUnit ( doc [ 1 ] ) then
4975: LD_VAR 0 2
4979: NOT
4980: PUSH
4981: LD_VAR 0 3
4985: PUSH
4986: LD_INT 1
4988: ARRAY
4989: PPUSH
4990: CALL_OW 310
4994: NOT
4995: AND
4996: IFFALSE 5069
// ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
4998: LD_VAR 0 3
5002: PPUSH
5003: LD_INT 22
5005: PUSH
5006: LD_INT 3
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 2
5015: PUSH
5016: LD_INT 30
5018: PUSH
5019: LD_INT 6
5021: PUSH
5022: EMPTY
5023: LIST
5024: LIST
5025: PUSH
5026: LD_INT 30
5028: PUSH
5029: LD_INT 7
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PUSH
5036: LD_INT 30
5038: PUSH
5039: LD_INT 8
5041: PUSH
5042: EMPTY
5043: LIST
5044: LIST
5045: PUSH
5046: EMPTY
5047: LIST
5048: LIST
5049: LIST
5050: LIST
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: PPUSH
5056: CALL_OW 69
5060: PUSH
5061: LD_INT 1
5063: ARRAY
5064: PPUSH
5065: CALL_OW 120
// if IsInUnit ( doc [ 1 ] ) then
5069: LD_VAR 0 3
5073: PUSH
5074: LD_INT 1
5076: ARRAY
5077: PPUSH
5078: CALL_OW 310
5082: IFFALSE 5093
// ComExitBuilding ( doc ) ;
5084: LD_VAR 0 3
5088: PPUSH
5089: CALL_OW 122
// wait ( 3 ) ;
5093: LD_INT 3
5095: PPUSH
5096: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
5100: LD_VAR 0 3
5104: PPUSH
5105: LD_VAR 0 2
5109: PUSH
5110: LD_INT 1
5112: ARRAY
5113: PPUSH
5114: CALL_OW 128
// end ; end_of_file
5118: PPOPN 3
5120: END
// export function Action ; begin
5121: LD_INT 0
5123: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
5124: LD_INT 28
5126: PPUSH
5127: LD_INT 3
5129: PPUSH
5130: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
5134: LD_INT 41
5136: PPUSH
5137: LD_INT 76
5139: PPUSH
5140: LD_INT 1
5142: PPUSH
5143: LD_INT 10
5145: PPUSH
5146: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
5150: LD_INT 41
5152: PPUSH
5153: LD_INT 76
5155: PPUSH
5156: LD_INT 1
5158: PPUSH
5159: CALL_OW 331
// InGameOn ;
5163: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
5167: LD_EXP 17
5171: PPUSH
5172: LD_STRING D2-Har-1
5174: PPUSH
5175: CALL_OW 94
// InGameOff ;
5179: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
5183: LD_STRING M1
5185: PPUSH
5186: CALL_OW 337
// end ;
5190: LD_VAR 0 1
5194: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
5195: LD_EXP 4
5199: PUSH
5200: LD_INT 1
5202: GREATER
5203: IFFALSE 5294
5205: GO 5207
5207: DISABLE
5208: LD_INT 0
5210: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
5211: LD_ADDR_VAR 0 1
5215: PUSH
5216: LD_INT 1
5218: PPUSH
5219: CALL 418 0 1
5223: PUSH
5224: LD_INT 1
5226: ARRAY
5227: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
5228: LD_VAR 0 1
5232: PPUSH
5233: LD_STRING D2a-Sol1-1
5235: PPUSH
5236: CALL_OW 88
// if not un then
5240: LD_VAR 0 1
5244: NOT
5245: IFFALSE 5276
// begin un := GetRandom ( sex_female ) [ 1 ] ;
5247: LD_ADDR_VAR 0 1
5251: PUSH
5252: LD_INT 2
5254: PPUSH
5255: CALL 418 0 1
5259: PUSH
5260: LD_INT 1
5262: ARRAY
5263: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
5264: LD_VAR 0 1
5268: PPUSH
5269: LD_STRING D2a-FSol1-1
5271: PPUSH
5272: CALL_OW 88
// end ; if Khatam then
5276: LD_EXP 15
5280: IFFALSE 5294
// Say ( Khatam , D3b-Khat-3 ) ;
5282: LD_EXP 15
5286: PPUSH
5287: LD_STRING D3b-Khat-3
5289: PPUSH
5290: CALL_OW 88
// end ;
5294: PPOPN 1
5296: END
// every 0 0$1 trigger Frank and GetDistUnits ( JMM , Frank ) < 5 and not InBattle ( 1 ) do var i , ape ;
5297: LD_EXP 13
5301: PUSH
5302: LD_EXP 7
5306: PPUSH
5307: LD_EXP 13
5311: PPUSH
5312: CALL_OW 296
5316: PUSH
5317: LD_INT 5
5319: LESS
5320: AND
5321: PUSH
5322: LD_INT 1
5324: PPUSH
5325: CALL_OW 463
5329: NOT
5330: AND
5331: IFFALSE 5918
5333: GO 5335
5335: DISABLE
5336: LD_INT 0
5338: PPUSH
5339: PPUSH
// begin InGameOn ;
5340: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
5344: LD_ADDR_VAR 0 2
5348: PUSH
5349: LD_INT 22
5351: PUSH
5352: LD_INT 0
5354: PUSH
5355: EMPTY
5356: LIST
5357: LIST
5358: PUSH
5359: LD_INT 25
5361: PUSH
5362: LD_INT 12
5364: PUSH
5365: EMPTY
5366: LIST
5367: LIST
5368: PUSH
5369: EMPTY
5370: LIST
5371: LIST
5372: PPUSH
5373: CALL_OW 69
5377: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
5378: LD_ADDR_VAR 0 2
5382: PUSH
5383: LD_VAR 0 2
5387: PPUSH
5388: LD_EXP 13
5392: PPUSH
5393: CALL_OW 74
5397: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
5398: LD_ADDR_VAR 0 1
5402: PUSH
5403: LD_INT 22
5405: PUSH
5406: LD_INT 1
5408: PUSH
5409: EMPTY
5410: LIST
5411: LIST
5412: PUSH
5413: LD_INT 21
5415: PUSH
5416: LD_INT 1
5418: PUSH
5419: EMPTY
5420: LIST
5421: LIST
5422: PUSH
5423: LD_INT 91
5425: PUSH
5426: LD_EXP 13
5430: PUSH
5431: LD_INT 20
5433: PUSH
5434: EMPTY
5435: LIST
5436: LIST
5437: LIST
5438: PUSH
5439: EMPTY
5440: LIST
5441: LIST
5442: LIST
5443: PPUSH
5444: CALL_OW 69
5448: PUSH
5449: FOR_IN
5450: IFFALSE 5468
// ComTurnUnit ( i , Frank ) ;
5452: LD_VAR 0 1
5456: PPUSH
5457: LD_EXP 13
5461: PPUSH
5462: CALL_OW 119
5466: GO 5449
5468: POP
5469: POP
// SetSide ( Frank , 1 ) ;
5470: LD_EXP 13
5474: PPUSH
5475: LD_INT 1
5477: PPUSH
5478: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
5482: LD_EXP 7
5486: PPUSH
5487: LD_EXP 13
5491: PPUSH
5492: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
5496: LD_EXP 7
5500: PPUSH
5501: LD_EXP 13
5505: PPUSH
5506: CALL_OW 179
// CenterOnUnits ( Frank ) ;
5510: LD_EXP 13
5514: PPUSH
5515: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
5519: LD_EXP 13
5523: PPUSH
5524: LD_STRING D3a-Frank-1
5526: PPUSH
5527: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
5531: LD_VAR 0 2
5535: PPUSH
5536: LD_INT 42
5538: PPUSH
5539: LD_INT 78
5541: PPUSH
5542: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
5546: LD_VAR 0 2
5550: PPUSH
5551: LD_EXP 13
5555: PPUSH
5556: CALL_OW 179
// if Lisa then
5560: LD_EXP 12
5564: IFFALSE 5578
// Say ( Lisa , D3a-Lisa-1 ) ;
5566: LD_EXP 12
5570: PPUSH
5571: LD_STRING D3a-Lisa-1
5573: PPUSH
5574: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
5578: LD_EXP 7
5582: PPUSH
5583: LD_STRING D3a-JMM-1
5585: PPUSH
5586: CALL_OW 88
// if Cyrus then
5590: LD_EXP 11
5594: IFFALSE 5608
// Say ( Cyrus , D3a-Cyrus-1 ) ;
5596: LD_EXP 11
5600: PPUSH
5601: LD_STRING D3a-Cyrus-1
5603: PPUSH
5604: CALL_OW 88
// if GetRandom ( sex_male ) then
5608: LD_INT 1
5610: PPUSH
5611: CALL 418 0 1
5615: IFFALSE 5636
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
5617: LD_INT 1
5619: PPUSH
5620: CALL 418 0 1
5624: PUSH
5625: LD_INT 1
5627: ARRAY
5628: PPUSH
5629: LD_STRING D3a-Sol1-1
5631: PPUSH
5632: CALL_OW 88
// if GetRandom ( sex_female ) then
5636: LD_INT 2
5638: PPUSH
5639: CALL 418 0 1
5643: IFFALSE 5664
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
5645: LD_INT 2
5647: PPUSH
5648: CALL 418 0 1
5652: PUSH
5653: LD_INT 1
5655: ARRAY
5656: PPUSH
5657: LD_STRING D3a-FSol1-1
5659: PPUSH
5660: CALL_OW 88
// if Gladstone then
5664: LD_EXP 14
5668: IFFALSE 5682
// Say ( Gladstone , D3a-Glad-1 ) ;
5670: LD_EXP 14
5674: PPUSH
5675: LD_STRING D3a-Glad-1
5677: PPUSH
5678: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
5682: LD_VAR 0 2
5686: PPUSH
5687: LD_INT 60
5689: PPUSH
5690: LD_INT 113
5692: PPUSH
5693: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
5697: LD_EXP 13
5701: PPUSH
5702: LD_STRING D3a-Frank-2
5704: PPUSH
5705: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
5709: LD_EXP 13
5713: PPUSH
5714: LD_EXP 7
5718: PPUSH
5719: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
5723: LD_EXP 7
5727: PPUSH
5728: LD_STRING D3a-JMM-2
5730: PPUSH
5731: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
5735: LD_INT 1
5737: PPUSH
5738: LD_INT 4
5740: PPUSH
5741: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
5745: LD_INT 85
5747: PPUSH
5748: LD_INT 134
5750: PPUSH
5751: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
5755: LD_EXP 13
5759: PPUSH
5760: LD_STRING D3a-Frank-3
5762: PPUSH
5763: CALL_OW 88
// Wait ( 0 0$01 ) ;
5767: LD_INT 35
5769: PPUSH
5770: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
5774: LD_INT 166
5776: PPUSH
5777: LD_INT 136
5779: PPUSH
5780: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
5784: LD_EXP 7
5788: PPUSH
5789: LD_STRING D3a-JMM-3
5791: PPUSH
5792: CALL_OW 88
// Wait ( 0 0$01 ) ;
5796: LD_INT 35
5798: PPUSH
5799: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
5803: LD_EXP 13
5807: PPUSH
5808: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
5812: LD_EXP 13
5816: PPUSH
5817: LD_STRING D3a-Frank-4
5819: PPUSH
5820: CALL_OW 88
// if Lisa then
5824: LD_EXP 12
5828: IFFALSE 5842
// Say ( Lisa , D3a-Lisa-4 ) ;
5830: LD_EXP 12
5834: PPUSH
5835: LD_STRING D3a-Lisa-4
5837: PPUSH
5838: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
5842: LD_EXP 7
5846: PPUSH
5847: LD_STRING D3a-JMM-4
5849: PPUSH
5850: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
5854: LD_EXP 13
5858: PPUSH
5859: LD_STRING D3a-Frank-5
5861: PPUSH
5862: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
5866: LD_EXP 7
5870: PPUSH
5871: LD_STRING D3a-JMM-5
5873: PPUSH
5874: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
5878: LD_EXP 13
5882: PPUSH
5883: LD_STRING D3a-Frank-6
5885: PPUSH
5886: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
5890: LD_EXP 7
5894: PPUSH
5895: LD_STRING D3a-JMM-6
5897: PPUSH
5898: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
5902: LD_EXP 13
5906: PPUSH
5907: LD_STRING D3a-Frank-7
5909: PPUSH
5910: CALL_OW 88
// InGameOff ;
5914: CALL_OW 9
// end ;
5918: PPOPN 2
5920: END
// every 0 0$1 trigger Kikuchi and GetDistUnits ( JMM , Kikuchi ) < 5 and not InBattle ( 1 ) do
5921: LD_EXP 16
5925: PUSH
5926: LD_EXP 7
5930: PPUSH
5931: LD_EXP 16
5935: PPUSH
5936: CALL_OW 296
5940: PUSH
5941: LD_INT 5
5943: LESS
5944: AND
5945: PUSH
5946: LD_INT 1
5948: PPUSH
5949: CALL_OW 463
5953: NOT
5954: AND
5955: IFFALSE 6135
5957: GO 5959
5959: DISABLE
// begin InGameOn ;
5960: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
5964: LD_EXP 7
5968: PPUSH
5969: LD_EXP 16
5973: PPUSH
5974: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
5978: LD_EXP 16
5982: PPUSH
5983: LD_EXP 7
5987: PPUSH
5988: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
5992: LD_EXP 16
5996: PPUSH
5997: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
6001: LD_EXP 16
6005: PPUSH
6006: LD_STRING D3b-Yam-1
6008: PPUSH
6009: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
6013: LD_EXP 7
6017: PPUSH
6018: LD_STRING D3b-JMM-1
6020: PPUSH
6021: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
6025: LD_INT 1
6027: PPUSH
6028: LD_INT 4
6030: PPUSH
6031: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
6035: LD_INT 85
6037: PPUSH
6038: LD_INT 134
6040: PPUSH
6041: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
6045: LD_EXP 16
6049: PPUSH
6050: LD_STRING D3b-Yam-2
6052: PPUSH
6053: CALL_OW 88
// Wait ( 0 0$01 ) ;
6057: LD_INT 35
6059: PPUSH
6060: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
6064: LD_EXP 7
6068: PPUSH
6069: LD_STRING D3b-JMM-2
6071: PPUSH
6072: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
6076: LD_INT 166
6078: PPUSH
6079: LD_INT 136
6081: PPUSH
6082: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
6086: LD_EXP 16
6090: PPUSH
6091: LD_STRING D3b-Yam-3
6093: PPUSH
6094: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
6098: LD_EXP 7
6102: PPUSH
6103: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
6107: LD_EXP 7
6111: PPUSH
6112: LD_STRING D3b-JMM-3a
6114: PPUSH
6115: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
6119: LD_EXP 16
6123: PPUSH
6124: LD_INT 1
6126: PPUSH
6127: CALL_OW 235
// InGameOff ;
6131: CALL_OW 9
// end ;
6135: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , i ;
6136: LD_INT 7
6138: PPUSH
6139: LD_INT 22
6141: PUSH
6142: LD_INT 1
6144: PUSH
6145: EMPTY
6146: LIST
6147: LIST
6148: PUSH
6149: LD_INT 3
6151: PUSH
6152: LD_INT 24
6154: PUSH
6155: LD_INT 1000
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: PUSH
6162: EMPTY
6163: LIST
6164: LIST
6165: PUSH
6166: EMPTY
6167: LIST
6168: LIST
6169: PPUSH
6170: CALL_OW 70
6174: IFFALSE 6592
6176: GO 6178
6178: DISABLE
6179: LD_INT 0
6181: PPUSH
6182: PPUSH
6183: PPUSH
// begin un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) [ 1 ] ;
6184: LD_ADDR_VAR 0 1
6188: PUSH
6189: LD_INT 7
6191: PPUSH
6192: LD_INT 22
6194: PUSH
6195: LD_INT 1
6197: PUSH
6198: EMPTY
6199: LIST
6200: LIST
6201: PUSH
6202: LD_INT 3
6204: PUSH
6205: LD_INT 24
6207: PUSH
6208: LD_INT 1000
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: PUSH
6215: EMPTY
6216: LIST
6217: LIST
6218: PUSH
6219: EMPTY
6220: LIST
6221: LIST
6222: PPUSH
6223: CALL_OW 70
6227: PUSH
6228: LD_INT 1
6230: ARRAY
6231: ST_TO_ADDR
// DialogueOn ;
6232: CALL_OW 6
// CenterNowOnUnits ( un ) ;
6236: LD_VAR 0 1
6240: PPUSH
6241: CALL_OW 87
// if Lisa then
6245: LD_EXP 12
6249: IFFALSE 6277
// begin Say ( Lisa , D5-Lisa-1 ) ;
6251: LD_EXP 12
6255: PPUSH
6256: LD_STRING D5-Lisa-1
6258: PPUSH
6259: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
6263: LD_EXP 7
6267: PPUSH
6268: LD_STRING D5-JMM-1a
6270: PPUSH
6271: CALL_OW 88
// end else
6275: GO 6289
// Say ( JMM , D5-JMM-1 ) ;
6277: LD_EXP 7
6281: PPUSH
6282: LD_STRING D5-JMM-1
6284: PPUSH
6285: CALL_OW 88
// DialogueOff ;
6289: CALL_OW 7
// while ( true ) do
6293: LD_INT 1
6295: IFFALSE 6351
// begin wait ( 0 0$01 ) ;
6297: LD_INT 35
6299: PPUSH
6300: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
6304: LD_ADDR_VAR 0 2
6308: PUSH
6309: LD_INT 8
6311: PPUSH
6312: LD_INT 30
6314: PUSH
6315: LD_INT 26
6317: PUSH
6318: EMPTY
6319: LIST
6320: LIST
6321: PUSH
6322: LD_INT 101
6324: PUSH
6325: LD_INT 1
6327: PUSH
6328: EMPTY
6329: LIST
6330: LIST
6331: PUSH
6332: EMPTY
6333: LIST
6334: LIST
6335: PPUSH
6336: CALL_OW 71
6340: ST_TO_ADDR
// if x then
6341: LD_VAR 0 2
6345: IFFALSE 6349
// break ;
6347: GO 6351
// end ;
6349: GO 6293
// CenterOnUnits ( x [ 1 ] ) ;
6351: LD_VAR 0 2
6355: PUSH
6356: LD_INT 1
6358: ARRAY
6359: PPUSH
6360: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
6364: LD_EXP 13
6368: PUSH
6369: LD_EXP 13
6373: PPUSH
6374: CALL_OW 255
6378: PUSH
6379: LD_INT 1
6381: EQUAL
6382: AND
6383: IFFALSE 6399
// Say ( Frank , D5a-Frank-1 ) else
6385: LD_EXP 13
6389: PPUSH
6390: LD_STRING D5a-Frank-1
6392: PPUSH
6393: CALL_OW 88
6397: GO 6453
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
6399: LD_EXP 16
6403: PUSH
6404: LD_EXP 16
6408: PPUSH
6409: CALL_OW 255
6413: PUSH
6414: LD_INT 1
6416: EQUAL
6417: AND
6418: IFFALSE 6434
// Say ( Kikuchi , D5a-Yam-1 ) else
6420: LD_EXP 16
6424: PPUSH
6425: LD_STRING D5a-Yam-1
6427: PPUSH
6428: CALL_OW 88
6432: GO 6453
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
6434: LD_INT 1
6436: PPUSH
6437: CALL 418 0 1
6441: PUSH
6442: LD_INT 1
6444: ARRAY
6445: PPUSH
6446: LD_STRING D5a-Sol1-1
6448: PPUSH
6449: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
6453: LD_EXP 7
6457: PPUSH
6458: LD_STRING D5a-JMM-1
6460: PPUSH
6461: CALL_OW 88
// if Cyrus then
6465: LD_EXP 11
6469: IFFALSE 6483
// Say ( Cyrus , D5a-Cyrus-1 ) ;
6471: LD_EXP 11
6475: PPUSH
6476: LD_STRING D5a-Cyrus-1
6478: PPUSH
6479: CALL_OW 88
// x := false ;
6483: LD_ADDR_VAR 0 2
6487: PUSH
6488: LD_INT 0
6490: ST_TO_ADDR
// while ( true ) do
6491: LD_INT 1
6493: IFFALSE 6580
// begin wait ( 0 0$01 ) ;
6495: LD_INT 35
6497: PPUSH
6498: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
6502: LD_ADDR_VAR 0 3
6506: PUSH
6507: LD_INT 2
6509: PUSH
6510: LD_INT 30
6512: PUSH
6513: LD_INT 0
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: PUSH
6520: LD_INT 30
6522: PUSH
6523: LD_INT 1
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: PUSH
6530: EMPTY
6531: LIST
6532: LIST
6533: LIST
6534: PPUSH
6535: CALL_OW 69
6539: PUSH
6540: LD_INT 1
6542: DIFF
6543: PUSH
6544: FOR_IN
6545: IFFALSE 6568
// if BaseNeedEnergy ( i ) then
6547: LD_VAR 0 3
6551: PPUSH
6552: CALL 1075 0 1
6556: IFFALSE 6566
// x := true ;
6558: LD_ADDR_VAR 0 2
6562: PUSH
6563: LD_INT 1
6565: ST_TO_ADDR
6566: GO 6544
6568: POP
6569: POP
// if x then
6570: LD_VAR 0 2
6574: IFFALSE 6578
// break ;
6576: GO 6580
// end ;
6578: GO 6491
// Say ( JMM , D5b-JMM-1 ) ;
6580: LD_EXP 7
6584: PPUSH
6585: LD_STRING D5b-JMM-1
6587: PPUSH
6588: CALL_OW 88
// end ;
6592: PPOPN 3
6594: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
6595: LD_EXP 5
6599: PUSH
6600: LD_INT 1
6602: ARRAY
6603: PUSH
6604: LD_OWVAR 1
6608: LESS
6609: IFFALSE 6809
6611: GO 6613
6613: DISABLE
// begin if not IsDead ( ru_dep_main ) then
6614: LD_INT 16
6616: PPUSH
6617: CALL_OW 301
6621: NOT
6622: IFFALSE 6645
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
6624: LD_EXP 17
6628: PPUSH
6629: LD_STRING D3b-Har-3
6631: PPUSH
6632: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
6636: LD_STRING M2a
6638: PPUSH
6639: CALL_OW 337
// end else
6643: GO 6664
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
6645: LD_EXP 17
6649: PPUSH
6650: LD_STRING D3b-Har-3a
6652: PPUSH
6653: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
6657: LD_STRING M2
6659: PPUSH
6660: CALL_OW 337
// end ; can_end := true ;
6664: LD_ADDR_EXP 6
6668: PUSH
6669: LD_INT 1
6671: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
6672: LD_INT 9
6674: PPUSH
6675: LD_INT 1
6677: PPUSH
6678: CALL_OW 424
// Wait ( 0 0$02 ) ;
6682: LD_INT 70
6684: PPUSH
6685: CALL_OW 67
// if Lisa then
6689: LD_EXP 12
6693: IFFALSE 6707
// Say ( Lisa , D3b-Lisa ) ;
6695: LD_EXP 12
6699: PPUSH
6700: LD_STRING D3b-Lisa
6702: PPUSH
6703: CALL_OW 88
// if Bobby then
6707: LD_EXP 10
6711: IFFALSE 6725
// Say ( Bobby , D3b-Bobby-3 ) ;
6713: LD_EXP 10
6717: PPUSH
6718: LD_STRING D3b-Bobby-3
6720: PPUSH
6721: CALL_OW 88
// if Cyrus then
6725: LD_EXP 11
6729: IFFALSE 6743
// Say ( Cyrus , D3b-Cyrus-3 ) ;
6731: LD_EXP 11
6735: PPUSH
6736: LD_STRING D3b-Cyrus-3
6738: PPUSH
6739: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
6743: LD_EXP 13
6747: PUSH
6748: LD_EXP 13
6752: PPUSH
6753: CALL_OW 255
6757: PUSH
6758: LD_INT 1
6760: EQUAL
6761: AND
6762: IFFALSE 6776
// Say ( Frank , D3b-Frank-3 ) ;
6764: LD_EXP 13
6768: PPUSH
6769: LD_STRING D3b-Frank-3
6771: PPUSH
6772: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
6776: LD_EXP 16
6780: PUSH
6781: LD_EXP 16
6785: PPUSH
6786: CALL_OW 255
6790: PUSH
6791: LD_INT 1
6793: EQUAL
6794: AND
6795: IFFALSE 6809
// Say ( Kikuchi , D3b-Yam-4 ) ;
6797: LD_EXP 16
6801: PPUSH
6802: LD_STRING D3b-Yam-4
6804: PPUSH
6805: CALL_OW 88
// end ;
6809: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
6810: LD_EXP 5
6814: PUSH
6815: LD_INT 2
6817: ARRAY
6818: PUSH
6819: LD_OWVAR 1
6823: LESS
6824: IFFALSE 6848
6826: GO 6828
6828: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
6829: LD_EXP 17
6833: PPUSH
6834: LD_STRING D4-Har-1
6836: PPUSH
6837: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
6841: LD_STRING M3
6843: PPUSH
6844: CALL_OW 337
// end ;
6848: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
6849: LD_EXP 5
6853: PUSH
6854: LD_INT 3
6856: ARRAY
6857: PUSH
6858: LD_OWVAR 1
6862: LESS
6863: IFFALSE 6894
6865: GO 6867
6867: DISABLE
// begin if not IsDead ( ru_dep_main ) then
6868: LD_INT 16
6870: PPUSH
6871: CALL_OW 301
6875: NOT
6876: IFFALSE 6887
// YouLost ( TimeOut1 ) else
6878: LD_STRING TimeOut1
6880: PPUSH
6881: CALL_OW 104
6885: GO 6894
// YouLost ( TimeOut2 ) ;
6887: LD_STRING TimeOut2
6889: PPUSH
6890: CALL_OW 104
// end ;
6894: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , tmp ;
6895: LD_EXP 7
6899: PPUSH
6900: LD_INT 9
6902: PPUSH
6903: CALL_OW 308
6907: PUSH
6908: LD_EXP 6
6912: AND
6913: IFFALSE 7754
6915: GO 6917
6917: DISABLE
6918: LD_INT 0
6920: PPUSH
6921: PPUSH
// begin wait_on := false ;
6922: LD_ADDR_VAR 0 1
6926: PUSH
6927: LD_INT 0
6929: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
6930: LD_INT 1
6932: PPUSH
6933: CALL 1152 0 1
6937: PUSH
6938: LD_INT 0
6940: PLUS
6941: PUSH
6942: LD_INT 1
6944: PPUSH
6945: LD_INT 9
6947: PPUSH
6948: CALL 1243 0 2
6952: PUSH
6953: LD_INT 1
6955: PPUSH
6956: LD_INT 9
6958: PPUSH
6959: CALL 1290 0 2
6963: ADD
6964: PUSH
6965: LD_INT 0
6967: PLUS
6968: GREATER
6969: IFFALSE 7018
// case Query ( Q1 ) of 1 :
6971: LD_STRING Q1
6973: PPUSH
6974: CALL_OW 97
6978: PUSH
6979: LD_INT 1
6981: DOUBLE
6982: EQUAL
6983: IFTRUE 6987
6985: GO 6998
6987: POP
// wait_on := true ; 2 :
6988: LD_ADDR_VAR 0 1
6992: PUSH
6993: LD_INT 1
6995: ST_TO_ADDR
6996: GO 7018
6998: LD_INT 2
7000: DOUBLE
7001: EQUAL
7002: IFTRUE 7006
7004: GO 7017
7006: POP
// wait_on := false ; end ;
7007: LD_ADDR_VAR 0 1
7011: PUSH
7012: LD_INT 0
7014: ST_TO_ADDR
7015: GO 7018
7017: POP
// repeat wait ( 0 0$01 ) ;
7018: LD_INT 35
7020: PPUSH
7021: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
7025: LD_VAR 0 1
7029: NOT
7030: PUSH
7031: LD_INT 1
7033: PPUSH
7034: CALL 1152 0 1
7038: PUSH
7039: LD_INT 0
7041: PLUS
7042: PUSH
7043: LD_INT 1
7045: PPUSH
7046: LD_INT 9
7048: PPUSH
7049: CALL 1243 0 2
7053: PUSH
7054: LD_INT 1
7056: PPUSH
7057: LD_INT 9
7059: PPUSH
7060: CALL 1290 0 2
7064: ADD
7065: PUSH
7066: LD_INT 0
7068: PLUS
7069: EQUAL
7070: OR
7071: IFFALSE 7018
// DialogueOn ;
7073: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
7077: LD_EXP 7
7081: PPUSH
7082: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
7086: LD_EXP 7
7090: PPUSH
7091: LD_STRING D6-JMM-1
7093: PPUSH
7094: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
7098: LD_EXP 17
7102: PPUSH
7103: LD_STRING D6-Har-1
7105: PPUSH
7106: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
7110: LD_EXP 7
7114: PPUSH
7115: LD_STRING D6-JMM-2
7117: PPUSH
7118: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
7122: LD_EXP 17
7126: PPUSH
7127: LD_STRING D6-Har-2
7129: PPUSH
7130: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
7134: LD_EXP 7
7138: PPUSH
7139: LD_STRING D6-JMM-3
7141: PPUSH
7142: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
7146: LD_EXP 17
7150: PPUSH
7151: LD_STRING D6-Har-3
7153: PPUSH
7154: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
7158: LD_EXP 7
7162: PPUSH
7163: LD_STRING D6-JMM-4
7165: PPUSH
7166: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
7170: LD_EXP 17
7174: PPUSH
7175: LD_STRING D6-Har-4
7177: PPUSH
7178: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
7182: LD_EXP 7
7186: PPUSH
7187: LD_STRING D6-JMM-5
7189: PPUSH
7190: CALL_OW 88
// DialogueOff ;
7194: CALL_OW 7
// tmp := FilterBuildings ( 3 ) ;
7198: LD_ADDR_VAR 0 2
7202: PUSH
7203: LD_INT 3
7205: PPUSH
7206: CALL 1421 0 1
7210: ST_TO_ADDR
// if tmp >= 35 then
7211: LD_VAR 0 2
7215: PUSH
7216: LD_INT 35
7218: GREATEREQUAL
7219: IFFALSE 7256
// begin AddMedal ( Destroy1 , - 1 ) ;
7221: LD_STRING Destroy1
7223: PPUSH
7224: LD_INT 1
7226: NEG
7227: PPUSH
7228: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
7232: LD_STRING Destroy2
7234: PPUSH
7235: LD_INT 1
7237: NEG
7238: PPUSH
7239: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
7243: LD_STRING Destroy3
7245: PPUSH
7246: LD_INT 1
7248: NEG
7249: PPUSH
7250: CALL_OW 101
// end else
7254: GO 7343
// begin AddMedal ( Destroy1 , 1 ) ;
7256: LD_STRING Destroy1
7258: PPUSH
7259: LD_INT 1
7261: PPUSH
7262: CALL_OW 101
// if tmp >= 25 then
7266: LD_VAR 0 2
7270: PUSH
7271: LD_INT 25
7273: GREATEREQUAL
7274: IFFALSE 7300
// begin AddMedal ( Destroy2 , - 1 ) ;
7276: LD_STRING Destroy2
7278: PPUSH
7279: LD_INT 1
7281: NEG
7282: PPUSH
7283: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
7287: LD_STRING Destroy3
7289: PPUSH
7290: LD_INT 1
7292: NEG
7293: PPUSH
7294: CALL_OW 101
// end else
7298: GO 7343
// begin AddMedal ( Destroy2 , 1 ) ;
7300: LD_STRING Destroy2
7302: PPUSH
7303: LD_INT 1
7305: PPUSH
7306: CALL_OW 101
// if tmp >= 15 then
7310: LD_VAR 0 2
7314: PUSH
7315: LD_INT 15
7317: GREATEREQUAL
7318: IFFALSE 7333
// AddMedal ( Destroy3 , - 1 ) else
7320: LD_STRING Destroy3
7322: PPUSH
7323: LD_INT 1
7325: NEG
7326: PPUSH
7327: CALL_OW 101
7331: GO 7343
// AddMedal ( Destroy3 , 1 ) ;
7333: LD_STRING Destroy3
7335: PPUSH
7336: LD_INT 1
7338: PPUSH
7339: CALL_OW 101
// end ; end ; GiveMedals ( MAIN ) ;
7343: LD_STRING MAIN
7345: PPUSH
7346: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ;
7350: LD_ADDR_VAR 0 2
7354: PUSH
7355: LD_INT 1
7357: PPUSH
7358: LD_INT 9
7360: PPUSH
7361: CALL 1243 0 2
7365: PUSH
7366: LD_INT 1
7368: PPUSH
7369: LD_INT 9
7371: PPUSH
7372: CALL 1290 0 2
7376: ADD
7377: ST_TO_ADDR
// RewardPeople ( tmp ) ;
7378: LD_VAR 0 2
7382: PPUSH
7383: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
7387: LD_EXP 7
7391: PPUSH
7392: LD_EXP 3
7396: PUSH
7397: LD_STRING JMM
7399: STR
7400: PPUSH
7401: CALL_OW 38
// if Brown in tmp then
7405: LD_EXP 8
7409: PUSH
7410: LD_VAR 0 2
7414: IN
7415: IFFALSE 7435
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
7417: LD_EXP 8
7421: PPUSH
7422: LD_EXP 3
7426: PUSH
7427: LD_STRING Brown
7429: STR
7430: PPUSH
7431: CALL_OW 38
// if Donaldson in tmp then
7435: LD_EXP 9
7439: PUSH
7440: LD_VAR 0 2
7444: IN
7445: IFFALSE 7465
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
7447: LD_EXP 9
7451: PPUSH
7452: LD_EXP 3
7456: PUSH
7457: LD_STRING Donaldson
7459: STR
7460: PPUSH
7461: CALL_OW 38
// if Bobby in tmp then
7465: LD_EXP 10
7469: PUSH
7470: LD_VAR 0 2
7474: IN
7475: IFFALSE 7495
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
7477: LD_EXP 10
7481: PPUSH
7482: LD_EXP 3
7486: PUSH
7487: LD_STRING Bobby
7489: STR
7490: PPUSH
7491: CALL_OW 38
// if Cyrus in tmp then
7495: LD_EXP 11
7499: PUSH
7500: LD_VAR 0 2
7504: IN
7505: IFFALSE 7525
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
7507: LD_EXP 11
7511: PPUSH
7512: LD_EXP 3
7516: PUSH
7517: LD_STRING Cyrus
7519: STR
7520: PPUSH
7521: CALL_OW 38
// if Lisa in tmp then
7525: LD_EXP 12
7529: PUSH
7530: LD_VAR 0 2
7534: IN
7535: IFFALSE 7555
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
7537: LD_EXP 12
7541: PPUSH
7542: LD_EXP 3
7546: PUSH
7547: LD_STRING Lisa
7549: STR
7550: PPUSH
7551: CALL_OW 38
// if Frank in tmp then
7555: LD_EXP 13
7559: PUSH
7560: LD_VAR 0 2
7564: IN
7565: IFFALSE 7585
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
7567: LD_EXP 13
7571: PPUSH
7572: LD_EXP 3
7576: PUSH
7577: LD_STRING Frank
7579: STR
7580: PPUSH
7581: CALL_OW 38
// if Gladstone in tmp then
7585: LD_EXP 14
7589: PUSH
7590: LD_VAR 0 2
7594: IN
7595: IFFALSE 7615
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
7597: LD_EXP 14
7601: PPUSH
7602: LD_EXP 3
7606: PUSH
7607: LD_STRING Gladstone
7609: STR
7610: PPUSH
7611: CALL_OW 38
// if Khatam in tmp then
7615: LD_EXP 15
7619: PUSH
7620: LD_VAR 0 2
7624: IN
7625: IFFALSE 7645
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
7627: LD_EXP 15
7631: PPUSH
7632: LD_EXP 3
7636: PUSH
7637: LD_STRING Khatam
7639: STR
7640: PPUSH
7641: CALL_OW 38
// if Kikuchi in tmp then
7645: LD_EXP 16
7649: PUSH
7650: LD_VAR 0 2
7654: IN
7655: IFFALSE 7675
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
7657: LD_EXP 16
7661: PPUSH
7662: LD_EXP 3
7666: PUSH
7667: LD_STRING Kikuchi
7669: STR
7670: PPUSH
7671: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi ] , mission_prefix & others ) ;
7675: LD_VAR 0 2
7679: PUSH
7680: LD_EXP 7
7684: PUSH
7685: LD_EXP 8
7689: PUSH
7690: LD_EXP 9
7694: PUSH
7695: LD_EXP 10
7699: PUSH
7700: LD_EXP 11
7704: PUSH
7705: LD_EXP 12
7709: PUSH
7710: LD_EXP 13
7714: PUSH
7715: LD_EXP 14
7719: PUSH
7720: LD_EXP 16
7724: PUSH
7725: EMPTY
7726: LIST
7727: LIST
7728: LIST
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: DIFF
7736: PPUSH
7737: LD_EXP 3
7741: PUSH
7742: LD_STRING others
7744: STR
7745: PPUSH
7746: CALL_OW 38
// YouWin ;
7750: CALL_OW 103
// end ; end_of_file
7754: PPOPN 2
7756: END
// on UnitDestroyed ( un ) do begin if un = JMM then
7757: LD_VAR 0 1
7761: PUSH
7762: LD_EXP 7
7766: EQUAL
7767: IFFALSE 7776
// YouLost ( JMM ) ;
7769: LD_STRING JMM
7771: PPUSH
7772: CALL_OW 104
// if GetType ( un ) = unit_building then
7776: LD_VAR 0 1
7780: PPUSH
7781: CALL_OW 247
7785: PUSH
7786: LD_INT 3
7788: EQUAL
7789: IFFALSE 7805
// buildings_counter := buildings_counter + 1 ;
7791: LD_ADDR_EXP 4
7795: PUSH
7796: LD_EXP 4
7800: PUSH
7801: LD_INT 1
7803: PLUS
7804: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
7805: LD_VAR 0 1
7809: PUSH
7810: LD_INT 6
7812: PPUSH
7813: LD_INT 2
7815: PUSH
7816: LD_INT 30
7818: PUSH
7819: LD_INT 33
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PUSH
7826: LD_INT 30
7828: PUSH
7829: LD_INT 32
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: PUSH
7836: EMPTY
7837: LIST
7838: LIST
7839: LIST
7840: PPUSH
7841: CALL_OW 70
7845: IN
7846: IFFALSE 7905
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
7848: LD_ADDR_EXP 18
7852: PUSH
7853: LD_EXP 18
7857: PUSH
7858: LD_VAR 0 1
7862: PPUSH
7863: CALL_OW 266
7867: PUSH
7868: LD_VAR 0 1
7872: PPUSH
7873: CALL_OW 250
7877: PUSH
7878: LD_VAR 0 1
7882: PPUSH
7883: CALL_OW 251
7887: PUSH
7888: LD_VAR 0 1
7892: PPUSH
7893: CALL_OW 254
7897: PUSH
7898: EMPTY
7899: LIST
7900: LIST
7901: LIST
7902: LIST
7903: ADD
7904: ST_TO_ADDR
// if un = ru_dep_main then
7905: LD_VAR 0 1
7909: PUSH
7910: LD_INT 16
7912: EQUAL
7913: IFFALSE 7922
// ChangeMissionObjectives ( M1a ) ;
7915: LD_STRING M1a
7917: PPUSH
7918: CALL_OW 337
// end ;
7922: PPOPN 1
7924: END
// on BuildingStarted ( b , builder ) do var i ;
7925: LD_INT 0
7927: PPUSH
// begin if GetSide ( b ) = 3 then
7928: LD_VAR 0 1
7932: PPUSH
7933: CALL_OW 255
7937: PUSH
7938: LD_INT 3
7940: EQUAL
7941: IFFALSE 7981
// for i = 1 to 4 do
7943: LD_ADDR_VAR 0 3
7947: PUSH
7948: DOUBLE
7949: LD_INT 1
7951: DEC
7952: ST_TO_ADDR
7953: LD_INT 4
7955: PUSH
7956: FOR_TO
7957: IFFALSE 7979
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
7959: LD_ADDR_EXP 18
7963: PUSH
7964: LD_EXP 18
7968: PPUSH
7969: LD_INT 1
7971: PPUSH
7972: CALL_OW 3
7976: ST_TO_ADDR
7977: GO 7956
7979: POP
7980: POP
// end ;
7981: PPOPN 3
7983: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
7984: LD_VAR 0 1
7988: PPUSH
7989: CALL_OW 266
7993: PUSH
7994: LD_INT 32
7996: PUSH
7997: LD_INT 33
7999: PUSH
8000: EMPTY
8001: LIST
8002: LIST
8003: IN
8004: IFFALSE 8018
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
8006: LD_VAR 0 1
8010: PPUSH
8011: LD_INT 43
8013: PPUSH
8014: CALL_OW 148
8018: PPOPN 1
8020: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
8021: LD_VAR 0 1
8025: PUSH
8026: LD_INT 22
8028: PUSH
8029: LD_INT 3
8031: PUSH
8032: EMPTY
8033: LIST
8034: LIST
8035: PUSH
8036: LD_INT 2
8038: PUSH
8039: LD_INT 30
8041: PUSH
8042: LD_INT 31
8044: PUSH
8045: EMPTY
8046: LIST
8047: LIST
8048: PUSH
8049: LD_INT 30
8051: PUSH
8052: LD_INT 32
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: PUSH
8059: EMPTY
8060: LIST
8061: LIST
8062: LIST
8063: PUSH
8064: EMPTY
8065: LIST
8066: LIST
8067: PPUSH
8068: CALL_OW 69
8072: IN
8073: IFFALSE 8095
// GoToAnotherTower ( un , b , 143 , 143 ) ;
8075: LD_VAR 0 2
8079: PPUSH
8080: LD_VAR 0 1
8084: PPUSH
8085: LD_INT 143
8087: PPUSH
8088: LD_INT 143
8090: PPUSH
8091: CALL 648 0 4
// end ;
8095: PPOPN 2
8097: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
8098: LD_VAR 0 1
8102: PUSH
8103: LD_INT 22
8105: PUSH
8106: LD_INT 3
8108: PUSH
8109: EMPTY
8110: LIST
8111: LIST
8112: PUSH
8113: LD_INT 30
8115: PUSH
8116: LD_INT 32
8118: PUSH
8119: EMPTY
8120: LIST
8121: LIST
8122: PUSH
8123: EMPTY
8124: LIST
8125: LIST
8126: PPUSH
8127: CALL_OW 69
8131: IN
8132: IFFALSE 8146
// SetTag ( b , 0 ) ;
8134: LD_VAR 0 1
8138: PPUSH
8139: LD_INT 0
8141: PPUSH
8142: CALL_OW 109
// end ;
8146: PPOPN 2
8148: END
