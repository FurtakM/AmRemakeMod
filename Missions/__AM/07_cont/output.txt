// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 33 0 0
// DebugMode ;
  12: CALL 234 0 0
// PrepareNature ;
  16: CALL 1552 0 0
// PrepareRussians ;
  20: CALL 3082 0 0
// PrepareAmericans ;
  24: CALL 2037 0 0
// Action ;
  28: CALL 6492 0 0
// end ;
  32: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end , must_end ; function Init ; begin
  33: LD_INT 0
  35: PPUSH
// debug := false ;
  36: LD_ADDR_EXP 1
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// mission_prefix := 07c_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 07c_
  51: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  52: LD_ADDR_EXP 2
  56: PUSH
  57: LD_STRING 07_
  59: ST_TO_ADDR
// buildings_counter := 0 ;
  60: LD_ADDR_EXP 4
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// time_to_end := [ [ 33 33$00 , 30 30$00 , 27 27$00 ] [ Difficulty ] , [ 39 39$00 , 36 36$00 , 33 33$00 ] [ Difficulty ] , [ 45 45$00 , 42 42$00 , 39 39$00 ] [ Difficulty ] ] ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 69300
  75: PUSH
  76: LD_INT 63000
  78: PUSH
  79: LD_INT 56700
  81: PUSH
  82: EMPTY
  83: LIST
  84: LIST
  85: LIST
  86: PUSH
  87: LD_OWVAR 67
  91: ARRAY
  92: PUSH
  93: LD_INT 81900
  95: PUSH
  96: LD_INT 75600
  98: PUSH
  99: LD_INT 69300
 101: PUSH
 102: EMPTY
 103: LIST
 104: LIST
 105: LIST
 106: PUSH
 107: LD_OWVAR 67
 111: ARRAY
 112: PUSH
 113: LD_INT 94500
 115: PUSH
 116: LD_INT 88200
 118: PUSH
 119: LD_INT 81900
 121: PUSH
 122: EMPTY
 123: LIST
 124: LIST
 125: LIST
 126: PUSH
 127: LD_OWVAR 67
 131: ARRAY
 132: PUSH
 133: EMPTY
 134: LIST
 135: LIST
 136: LIST
 137: ST_TO_ADDR
// can_end := false ;
 138: LD_ADDR_EXP 6
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// must_end := false ;
 146: LD_ADDR_EXP 7
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// end ;
 154: LD_VAR 0 1
 158: RET
// every 0 0$01 trigger not debug do
 159: LD_EXP 1
 163: NOT
 164: IFFALSE 233
 166: GO 168
 168: DISABLE
// begin enable ;
 169: ENABLE
// if not must_end then
 170: LD_EXP 7
 174: NOT
 175: IFFALSE 196
// display_strings := [ #Am07-1 , tick ] else
 177: LD_ADDR_OWVAR 47
 181: PUSH
 182: LD_STRING #Am07-1
 184: PUSH
 185: LD_OWVAR 1
 189: PUSH
 190: EMPTY
 191: LIST
 192: LIST
 193: ST_TO_ADDR
 194: GO 233
// display_strings := [ #Am07-1 , tick , #Am07-2 , time_to_end [ 3 ] - tick ] ;
 196: LD_ADDR_OWVAR 47
 200: PUSH
 201: LD_STRING #Am07-1
 203: PUSH
 204: LD_OWVAR 1
 208: PUSH
 209: LD_STRING #Am07-2
 211: PUSH
 212: LD_EXP 5
 216: PUSH
 217: LD_INT 3
 219: ARRAY
 220: PUSH
 221: LD_OWVAR 1
 225: MINUS
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: LIST
 232: ST_TO_ADDR
// end ;
 233: END
// function DebugMode ; begin
 234: LD_INT 0
 236: PPUSH
// if not debug then
 237: LD_EXP 1
 241: NOT
 242: IFFALSE 246
// exit ;
 244: GO 253
// FogOff ( 1 ) ;
 246: LD_INT 1
 248: PPUSH
 249: CALL_OW 344
// end ;
 253: LD_VAR 0 1
 257: RET
// every 3 trigger debug do var i , filter ;
 258: LD_EXP 1
 262: IFFALSE 351
 264: GO 266
 266: DISABLE
 267: LD_INT 0
 269: PPUSH
 270: PPUSH
// begin enable ;
 271: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 272: LD_ADDR_VAR 0 2
 276: PUSH
 277: LD_INT 22
 279: PUSH
 280: LD_INT 1
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: PUSH
 287: LD_INT 3
 289: PUSH
 290: LD_INT 24
 292: PUSH
 293: LD_INT 500
 295: PUSH
 296: EMPTY
 297: LIST
 298: LIST
 299: PUSH
 300: EMPTY
 301: LIST
 302: LIST
 303: PUSH
 304: EMPTY
 305: LIST
 306: LIST
 307: PPUSH
 308: CALL_OW 69
 312: ST_TO_ADDR
// if not filter then
 313: LD_VAR 0 2
 317: NOT
 318: IFFALSE 322
// exit ;
 320: GO 351
// for i in filter do
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_VAR 0 2
 331: PUSH
 332: FOR_IN
 333: IFFALSE 349
// SetLives ( i , 1000 ) ;
 335: LD_VAR 0 1
 339: PPUSH
 340: LD_INT 1000
 342: PPUSH
 343: CALL_OW 234
 347: GO 332
 349: POP
 350: POP
// end ; end_of_file
 351: PPOPN 2
 353: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 354: LD_INT 0
 356: PPUSH
 357: PPUSH
// if exist_mode then
 358: LD_VAR 0 2
 362: IFFALSE 387
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 364: LD_ADDR_VAR 0 4
 368: PUSH
 369: LD_EXP 2
 373: PUSH
 374: LD_VAR 0 1
 378: STR
 379: PPUSH
 380: CALL_OW 34
 384: ST_TO_ADDR
 385: GO 402
// unit := NewCharacter ( ident ) ;
 387: LD_ADDR_VAR 0 4
 391: PUSH
 392: LD_VAR 0 1
 396: PPUSH
 397: CALL_OW 25
 401: ST_TO_ADDR
// result := unit ;
 402: LD_ADDR_VAR 0 3
 406: PUSH
 407: LD_VAR 0 4
 411: ST_TO_ADDR
// end ;
 412: LD_VAR 0 3
 416: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 417: LD_INT 0
 419: PPUSH
// uc_side := side ;
 420: LD_ADDR_OWVAR 20
 424: PUSH
 425: LD_VAR 0 1
 429: ST_TO_ADDR
// uc_nation := nation ;
 430: LD_ADDR_OWVAR 21
 434: PUSH
 435: LD_VAR 0 2
 439: ST_TO_ADDR
// vc_chassis := chassis ;
 440: LD_ADDR_OWVAR 37
 444: PUSH
 445: LD_VAR 0 3
 449: ST_TO_ADDR
// vc_engine := engine ;
 450: LD_ADDR_OWVAR 39
 454: PUSH
 455: LD_VAR 0 4
 459: ST_TO_ADDR
// vc_control := control ;
 460: LD_ADDR_OWVAR 38
 464: PUSH
 465: LD_VAR 0 5
 469: ST_TO_ADDR
// vc_weapon := weapon ;
 470: LD_ADDR_OWVAR 40
 474: PUSH
 475: LD_VAR 0 6
 479: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 480: LD_ADDR_OWVAR 41
 484: PUSH
 485: LD_VAR 0 7
 489: ST_TO_ADDR
// result := CreateVehicle ;
 490: LD_ADDR_VAR 0 8
 494: PUSH
 495: CALL_OW 45
 499: ST_TO_ADDR
// end ;
 500: LD_VAR 0 8
 504: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 505: LD_INT 0
 507: PPUSH
 508: PPUSH
 509: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 510: LD_ADDR_VAR 0 4
 514: PUSH
 515: LD_INT 22
 517: PUSH
 518: LD_INT 1
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: PUSH
 525: LD_INT 21
 527: PUSH
 528: LD_INT 1
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: PUSH
 535: LD_INT 50
 537: PUSH
 538: EMPTY
 539: LIST
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: PPUSH
 546: CALL_OW 69
 550: PUSH
 551: LD_EXP 8
 555: PUSH
 556: LD_EXP 9
 560: PUSH
 561: LD_EXP 10
 565: PUSH
 566: LD_EXP 11
 570: PUSH
 571: LD_EXP 12
 575: PUSH
 576: LD_EXP 13
 580: PUSH
 581: LD_EXP 14
 585: PUSH
 586: LD_EXP 15
 590: PUSH
 591: LD_EXP 17
 595: PUSH
 596: LD_EXP 16
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: DIFF
 613: ST_TO_ADDR
// if not filter then
 614: LD_VAR 0 4
 618: NOT
 619: IFFALSE 623
// exit ;
 621: GO 650
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 623: LD_ADDR_VAR 0 2
 627: PUSH
 628: LD_VAR 0 4
 632: PPUSH
 633: LD_INT 26
 635: PUSH
 636: LD_VAR 0 1
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL_OW 72
 649: ST_TO_ADDR
// end ;
 650: LD_VAR 0 2
 654: RET
// export function SayX ( units , ident ) ; var i ; begin
 655: LD_INT 0
 657: PPUSH
 658: PPUSH
// result := false ;
 659: LD_ADDR_VAR 0 3
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// if not units then
 667: LD_VAR 0 1
 671: NOT
 672: IFFALSE 676
// exit ;
 674: GO 730
// for i in units do
 676: LD_ADDR_VAR 0 4
 680: PUSH
 681: LD_VAR 0 1
 685: PUSH
 686: FOR_IN
 687: IFFALSE 728
// if IsOk ( i ) then
 689: LD_VAR 0 4
 693: PPUSH
 694: CALL_OW 302
 698: IFFALSE 726
// begin Say ( i , ident ) ;
 700: LD_VAR 0 4
 704: PPUSH
 705: LD_VAR 0 2
 709: PPUSH
 710: CALL_OW 88
// result := i ;
 714: LD_ADDR_VAR 0 3
 718: PUSH
 719: LD_VAR 0 4
 723: ST_TO_ADDR
// break ;
 724: GO 728
// end ;
 726: GO 686
 728: POP
 729: POP
// end ;
 730: LD_VAR 0 3
 734: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
 735: LD_INT 0
 737: PPUSH
 738: PPUSH
 739: PPUSH
 740: PPUSH
 741: PPUSH
// if not un or not IsOk ( un ) then
 742: LD_VAR 0 1
 746: NOT
 747: PUSH
 748: LD_VAR 0 1
 752: PPUSH
 753: CALL_OW 302
 757: NOT
 758: OR
 759: IFFALSE 763
// exit ;
 761: GO 1157
// side := GetSide ( un ) ;
 763: LD_ADDR_VAR 0 9
 767: PUSH
 768: LD_VAR 0 1
 772: PPUSH
 773: CALL_OW 255
 777: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
 778: LD_ADDR_VAR 0 7
 782: PUSH
 783: LD_INT 22
 785: PUSH
 786: LD_VAR 0 9
 790: PUSH
 791: EMPTY
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 30
 797: PUSH
 798: LD_INT 32
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: PUSH
 805: LD_INT 50
 807: PUSH
 808: EMPTY
 809: LIST
 810: PUSH
 811: LD_INT 58
 813: PUSH
 814: EMPTY
 815: LIST
 816: PUSH
 817: EMPTY
 818: LIST
 819: LIST
 820: LIST
 821: LIST
 822: PPUSH
 823: CALL_OW 69
 827: PUSH
 828: LD_VAR 0 2
 832: DIFF
 833: ST_TO_ADDR
// if not filter then
 834: LD_VAR 0 7
 838: NOT
 839: IFFALSE 1022
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
 841: LD_ADDR_VAR 0 7
 845: PUSH
 846: LD_INT 22
 848: PUSH
 849: LD_VAR 0 9
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: PUSH
 858: LD_INT 30
 860: PUSH
 861: LD_INT 5
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PPUSH
 872: CALL_OW 69
 876: ST_TO_ADDR
// if not filter then
 877: LD_VAR 0 7
 881: NOT
 882: IFFALSE 905
// begin ComMoveXY ( un , x , y ) ;
 884: LD_VAR 0 1
 888: PPUSH
 889: LD_VAR 0 3
 893: PPUSH
 894: LD_VAR 0 4
 898: PPUSH
 899: CALL_OW 111
// exit ;
 903: GO 1157
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
 905: LD_ADDR_VAR 0 8
 909: PUSH
 910: LD_VAR 0 7
 914: PPUSH
 915: LD_VAR 0 1
 919: PPUSH
 920: CALL_OW 74
 924: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
 925: LD_VAR 0 8
 929: PPUSH
 930: CALL_OW 313
 934: PUSH
 935: LD_INT 6
 937: EQUAL
 938: IFFALSE 956
// filter := filter diff t ;
 940: LD_ADDR_VAR 0 7
 944: PUSH
 945: LD_VAR 0 7
 949: PUSH
 950: LD_VAR 0 8
 954: DIFF
 955: ST_TO_ADDR
// until UnitsInside ( t ) < 6 or not filter ;
 956: LD_VAR 0 8
 960: PPUSH
 961: CALL_OW 313
 965: PUSH
 966: LD_INT 6
 968: LESS
 969: PUSH
 970: LD_VAR 0 7
 974: NOT
 975: OR
 976: IFFALSE 905
// if not filter then
 978: LD_VAR 0 7
 982: NOT
 983: IFFALSE 1006
// ComMoveXY ( un , x , y ) else
 985: LD_VAR 0 1
 989: PPUSH
 990: LD_VAR 0 3
 994: PPUSH
 995: LD_VAR 0 4
 999: PPUSH
1000: CALL_OW 111
1004: GO 1020
// ComEnterUnit ( un , t ) ;
1006: LD_VAR 0 1
1010: PPUSH
1011: LD_VAR 0 8
1015: PPUSH
1016: CALL_OW 120
// end else
1020: GO 1157
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
1022: LD_ADDR_VAR 0 8
1026: PUSH
1027: LD_VAR 0 7
1031: PPUSH
1032: LD_VAR 0 1
1036: PPUSH
1037: CALL_OW 74
1041: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
1042: LD_VAR 0 8
1046: PPUSH
1047: CALL_OW 110
1051: PUSH
1052: LD_INT 7
1054: EQUAL
1055: IFFALSE 1073
// filter := filter diff t ;
1057: LD_ADDR_VAR 0 7
1061: PUSH
1062: LD_VAR 0 7
1066: PUSH
1067: LD_VAR 0 8
1071: DIFF
1072: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
1073: LD_VAR 0 8
1077: PPUSH
1078: CALL_OW 110
1082: PUSH
1083: LD_INT 7
1085: NONEQUAL
1086: PUSH
1087: LD_VAR 0 7
1091: NOT
1092: OR
1093: IFFALSE 1022
// if GetTag ( t ) <> 7 then
1095: LD_VAR 0 8
1099: PPUSH
1100: CALL_OW 110
1104: PUSH
1105: LD_INT 7
1107: NONEQUAL
1108: IFFALSE 1138
// begin SetTag ( t , 7 ) ;
1110: LD_VAR 0 8
1114: PPUSH
1115: LD_INT 7
1117: PPUSH
1118: CALL_OW 109
// ComEnterUnit ( un , t ) ;
1122: LD_VAR 0 1
1126: PPUSH
1127: LD_VAR 0 8
1131: PPUSH
1132: CALL_OW 120
// end else
1136: GO 1157
// ComMoveXY ( un , x , y ) ;
1138: LD_VAR 0 1
1142: PPUSH
1143: LD_VAR 0 3
1147: PPUSH
1148: LD_VAR 0 4
1152: PPUSH
1153: CALL_OW 111
// end ; end ;
1157: LD_VAR 0 5
1161: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
1162: LD_INT 0
1164: PPUSH
1165: PPUSH
1166: PPUSH
// if not base then
1167: LD_VAR 0 1
1171: NOT
1172: IFFALSE 1176
// exit ;
1174: GO 1234
// tmp := GetEnergy ( GetBase ( base ) ) ;
1176: LD_ADDR_VAR 0 4
1180: PUSH
1181: LD_VAR 0 1
1185: PPUSH
1186: CALL_OW 274
1190: PPUSH
1191: CALL_OW 278
1195: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
1196: LD_VAR 0 4
1200: PUSH
1201: LD_INT 1
1203: ARRAY
1204: PUSH
1205: LD_VAR 0 4
1209: PUSH
1210: LD_INT 4
1212: ARRAY
1213: GREATER
1214: IFFALSE 1226
// result := true else
1216: LD_ADDR_VAR 0 2
1220: PUSH
1221: LD_INT 1
1223: ST_TO_ADDR
1224: GO 1234
// result := false ;
1226: LD_ADDR_VAR 0 2
1230: PUSH
1231: LD_INT 0
1233: ST_TO_ADDR
// end ;
1234: LD_VAR 0 2
1238: RET
// export function FilterPeople ( side ) ; begin
1239: LD_INT 0
1241: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
1242: LD_ADDR_VAR 0 2
1246: PUSH
1247: LD_INT 22
1249: PUSH
1250: LD_VAR 0 1
1254: PUSH
1255: EMPTY
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 21
1261: PUSH
1262: LD_INT 1
1264: PUSH
1265: EMPTY
1266: LIST
1267: LIST
1268: PUSH
1269: EMPTY
1270: LIST
1271: LIST
1272: PPUSH
1273: CALL_OW 69
1277: ST_TO_ADDR
// end ;
1278: LD_VAR 0 2
1282: RET
// export function FilterDrivers ( side ) ; begin
1283: LD_INT 0
1285: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
1286: LD_ADDR_VAR 0 2
1290: PUSH
1291: LD_INT 22
1293: PUSH
1294: LD_VAR 0 1
1298: PUSH
1299: EMPTY
1300: LIST
1301: LIST
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: LD_INT 56
1308: PUSH
1309: EMPTY
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: PUSH
1316: EMPTY
1317: LIST
1318: LIST
1319: PPUSH
1320: CALL_OW 69
1324: ST_TO_ADDR
// end ;
1325: LD_VAR 0 2
1329: RET
// export function FilterPeopleArea ( side , area ) ; begin
1330: LD_INT 0
1332: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
1333: LD_ADDR_VAR 0 3
1337: PUSH
1338: LD_VAR 0 2
1342: PPUSH
1343: LD_INT 22
1345: PUSH
1346: LD_INT 1
1348: PUSH
1349: EMPTY
1350: LIST
1351: LIST
1352: PUSH
1353: LD_INT 21
1355: PUSH
1356: LD_INT 1
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: PUSH
1363: EMPTY
1364: LIST
1365: LIST
1366: PPUSH
1367: CALL_OW 70
1371: ST_TO_ADDR
// end ;
1372: LD_VAR 0 3
1376: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
1377: LD_INT 0
1379: PPUSH
1380: PPUSH
1381: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
1382: LD_ADDR_VAR 0 5
1386: PUSH
1387: LD_VAR 0 2
1391: PPUSH
1392: LD_INT 22
1394: PUSH
1395: LD_INT 1
1397: PUSH
1398: EMPTY
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 21
1404: PUSH
1405: LD_INT 2
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: PUSH
1412: LD_INT 3
1414: PUSH
1415: LD_INT 58
1417: PUSH
1418: EMPTY
1419: LIST
1420: PUSH
1421: EMPTY
1422: LIST
1423: LIST
1424: PUSH
1425: EMPTY
1426: LIST
1427: LIST
1428: LIST
1429: PPUSH
1430: CALL_OW 70
1434: ST_TO_ADDR
// result := [ ] ;
1435: LD_ADDR_VAR 0 3
1439: PUSH
1440: EMPTY
1441: ST_TO_ADDR
// if not tmp then
1442: LD_VAR 0 5
1446: NOT
1447: IFFALSE 1451
// exit ;
1449: GO 1503
// for i in tmp do
1451: LD_ADDR_VAR 0 4
1455: PUSH
1456: LD_VAR 0 5
1460: PUSH
1461: FOR_IN
1462: IFFALSE 1487
// result := result ^ IsDrivenBy ( i ) ;
1464: LD_ADDR_VAR 0 3
1468: PUSH
1469: LD_VAR 0 3
1473: PUSH
1474: LD_VAR 0 4
1478: PPUSH
1479: CALL_OW 311
1483: ADD
1484: ST_TO_ADDR
1485: GO 1461
1487: POP
1488: POP
// result := result diff 0 ;
1489: LD_ADDR_VAR 0 3
1493: PUSH
1494: LD_VAR 0 3
1498: PUSH
1499: LD_INT 0
1501: DIFF
1502: ST_TO_ADDR
// end ;
1503: LD_VAR 0 3
1507: RET
// export function FilterBuildings ( side ) ; begin
1508: LD_INT 0
1510: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
1511: LD_ADDR_VAR 0 2
1515: PUSH
1516: LD_INT 22
1518: PUSH
1519: LD_VAR 0 1
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: PUSH
1528: LD_INT 21
1530: PUSH
1531: LD_INT 3
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: PUSH
1538: EMPTY
1539: LIST
1540: LIST
1541: PPUSH
1542: CALL_OW 69
1546: ST_TO_ADDR
// end ;
1547: LD_VAR 0 2
1551: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
1552: LD_INT 0
1554: PPUSH
1555: PPUSH
1556: PPUSH
1557: PPUSH
// uc_side = 0 ;
1558: LD_ADDR_OWVAR 20
1562: PUSH
1563: LD_INT 0
1565: ST_TO_ADDR
// uc_nation = 0 ;
1566: LD_ADDR_OWVAR 21
1570: PUSH
1571: LD_INT 0
1573: ST_TO_ADDR
// nat_area := wildArea ;
1574: LD_ADDR_VAR 0 4
1578: PUSH
1579: LD_INT 3
1581: ST_TO_ADDR
// InitHc ;
1582: CALL_OW 19
// for i = 1 to 4 do
1586: LD_ADDR_VAR 0 2
1590: PUSH
1591: DOUBLE
1592: LD_INT 1
1594: DEC
1595: ST_TO_ADDR
1596: LD_INT 4
1598: PUSH
1599: FOR_TO
1600: IFFALSE 1655
// begin hc_class = 18 ;
1602: LD_ADDR_OWVAR 28
1606: PUSH
1607: LD_INT 18
1609: ST_TO_ADDR
// hc_gallery =  ;
1610: LD_ADDR_OWVAR 33
1614: PUSH
1615: LD_STRING 
1617: ST_TO_ADDR
// hc_face_number = 1 ;
1618: LD_ADDR_OWVAR 34
1622: PUSH
1623: LD_INT 1
1625: ST_TO_ADDR
// animal := CreateHuman ;
1626: LD_ADDR_VAR 0 3
1630: PUSH
1631: CALL_OW 44
1635: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1636: LD_VAR 0 3
1640: PPUSH
1641: LD_VAR 0 4
1645: PPUSH
1646: LD_INT 0
1648: PPUSH
1649: CALL_OW 49
// end ;
1653: GO 1599
1655: POP
1656: POP
// for i = 1 to 6 do
1657: LD_ADDR_VAR 0 2
1661: PUSH
1662: DOUBLE
1663: LD_INT 1
1665: DEC
1666: ST_TO_ADDR
1667: LD_INT 6
1669: PUSH
1670: FOR_TO
1671: IFFALSE 1742
// begin hc_class = class_tiger ;
1673: LD_ADDR_OWVAR 28
1677: PUSH
1678: LD_INT 14
1680: ST_TO_ADDR
// hc_gallery =  ;
1681: LD_ADDR_OWVAR 33
1685: PUSH
1686: LD_STRING 
1688: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 50 ) ;
1689: LD_ADDR_OWVAR 35
1693: PUSH
1694: LD_INT 0
1696: PPUSH
1697: LD_INT 50
1699: PPUSH
1700: CALL_OW 12
1704: ST_TO_ADDR
// hc_face_number = 3 ;
1705: LD_ADDR_OWVAR 34
1709: PUSH
1710: LD_INT 3
1712: ST_TO_ADDR
// animal := CreateHuman ;
1713: LD_ADDR_VAR 0 3
1717: PUSH
1718: CALL_OW 44
1722: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1723: LD_VAR 0 3
1727: PPUSH
1728: LD_VAR 0 4
1732: PPUSH
1733: LD_INT 0
1735: PPUSH
1736: CALL_OW 49
// end ;
1740: GO 1670
1742: POP
1743: POP
// for i = 1 to 2 do
1744: LD_ADDR_VAR 0 2
1748: PUSH
1749: DOUBLE
1750: LD_INT 1
1752: DEC
1753: ST_TO_ADDR
1754: LD_INT 2
1756: PUSH
1757: FOR_TO
1758: IFFALSE 1821
// begin hc_class = 21 ;
1760: LD_ADDR_OWVAR 28
1764: PUSH
1765: LD_INT 21
1767: ST_TO_ADDR
// hc_gallery =  ;
1768: LD_ADDR_OWVAR 33
1772: PUSH
1773: LD_STRING 
1775: ST_TO_ADDR
// hc_agressivity = 0 ;
1776: LD_ADDR_OWVAR 35
1780: PUSH
1781: LD_INT 0
1783: ST_TO_ADDR
// hc_face_number = 5 ;
1784: LD_ADDR_OWVAR 34
1788: PUSH
1789: LD_INT 5
1791: ST_TO_ADDR
// animal := CreateHuman ;
1792: LD_ADDR_VAR 0 3
1796: PUSH
1797: CALL_OW 44
1801: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1802: LD_VAR 0 3
1806: PPUSH
1807: LD_VAR 0 4
1811: PPUSH
1812: LD_INT 0
1814: PPUSH
1815: CALL_OW 49
// end ;
1819: GO 1757
1821: POP
1822: POP
// for i = 1 to 6 do
1823: LD_ADDR_VAR 0 2
1827: PUSH
1828: DOUBLE
1829: LD_INT 1
1831: DEC
1832: ST_TO_ADDR
1833: LD_INT 6
1835: PUSH
1836: FOR_TO
1837: IFFALSE 1892
// begin hc_class = 13 ;
1839: LD_ADDR_OWVAR 28
1843: PUSH
1844: LD_INT 13
1846: ST_TO_ADDR
// hc_gallery =  ;
1847: LD_ADDR_OWVAR 33
1851: PUSH
1852: LD_STRING 
1854: ST_TO_ADDR
// hc_face_number = 4 ;
1855: LD_ADDR_OWVAR 34
1859: PUSH
1860: LD_INT 4
1862: ST_TO_ADDR
// animal := CreateHuman ;
1863: LD_ADDR_VAR 0 3
1867: PUSH
1868: CALL_OW 44
1872: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1873: LD_VAR 0 3
1877: PPUSH
1878: LD_VAR 0 4
1882: PPUSH
1883: LD_INT 0
1885: PPUSH
1886: CALL_OW 49
// end ;
1890: GO 1836
1892: POP
1893: POP
// for i = 1 to 2 do
1894: LD_ADDR_VAR 0 2
1898: PUSH
1899: DOUBLE
1900: LD_INT 1
1902: DEC
1903: ST_TO_ADDR
1904: LD_INT 2
1906: PUSH
1907: FOR_TO
1908: IFFALSE 1967
// begin hc_class = 20 ;
1910: LD_ADDR_OWVAR 28
1914: PUSH
1915: LD_INT 20
1917: ST_TO_ADDR
// hc_gallery =  ;
1918: LD_ADDR_OWVAR 33
1922: PUSH
1923: LD_STRING 
1925: ST_TO_ADDR
// hc_face_number = 2 ;
1926: LD_ADDR_OWVAR 34
1930: PUSH
1931: LD_INT 2
1933: ST_TO_ADDR
// animal := CreateHuman ;
1934: LD_ADDR_VAR 0 3
1938: PUSH
1939: CALL_OW 44
1943: ST_TO_ADDR
// PlaceUnitXYR ( animal , 101 , 37 , 3 , false ) ;
1944: LD_VAR 0 3
1948: PPUSH
1949: LD_INT 101
1951: PPUSH
1952: LD_INT 37
1954: PPUSH
1955: LD_INT 3
1957: PPUSH
1958: LD_INT 0
1960: PPUSH
1961: CALL_OW 50
// end ;
1965: GO 1907
1967: POP
1968: POP
// for i = 1 to 1 do
1969: LD_ADDR_VAR 0 2
1973: PUSH
1974: DOUBLE
1975: LD_INT 1
1977: DEC
1978: ST_TO_ADDR
1979: LD_INT 1
1981: PUSH
1982: FOR_TO
1983: IFFALSE 2030
// begin vc_chassis := 31 ;
1985: LD_ADDR_OWVAR 37
1989: PUSH
1990: LD_INT 31
1992: ST_TO_ADDR
// vc_control := control_rider ;
1993: LD_ADDR_OWVAR 38
1997: PUSH
1998: LD_INT 4
2000: ST_TO_ADDR
// animal := CreateVehicle ;
2001: LD_ADDR_VAR 0 3
2005: PUSH
2006: CALL_OW 45
2010: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
2011: LD_VAR 0 3
2015: PPUSH
2016: LD_VAR 0 4
2020: PPUSH
2021: LD_INT 0
2023: PPUSH
2024: CALL_OW 49
// end ;
2028: GO 1982
2030: POP
2031: POP
// end ; end_of_file
2032: LD_VAR 0 1
2036: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
2037: LD_INT 0
2039: PPUSH
2040: PPUSH
2041: PPUSH
2042: PPUSH
2043: PPUSH
2044: PPUSH
// uc_side := 1 ;
2045: LD_ADDR_OWVAR 20
2049: PUSH
2050: LD_INT 1
2052: ST_TO_ADDR
// uc_nation := 1 ;
2053: LD_ADDR_OWVAR 21
2057: PUSH
2058: LD_INT 1
2060: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
2061: LD_ADDR_EXP 8
2065: PUSH
2066: LD_STRING JMM
2068: PPUSH
2069: LD_EXP 1
2073: NOT
2074: PPUSH
2075: CALL 354 0 2
2079: ST_TO_ADDR
// team := [ JMM ] ;
2080: LD_ADDR_VAR 0 3
2084: PUSH
2085: LD_EXP 8
2089: PUSH
2090: EMPTY
2091: LIST
2092: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
2093: LD_STRING BrownIn07
2095: PPUSH
2096: LD_EXP 1
2100: PPUSH
2101: CALL_OW 30
2105: IFFALSE 2126
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
2107: LD_ADDR_EXP 9
2111: PUSH
2112: LD_STRING Brown
2114: PPUSH
2115: LD_EXP 1
2119: NOT
2120: PPUSH
2121: CALL 354 0 2
2125: ST_TO_ADDR
// if Brown then
2126: LD_EXP 9
2130: IFFALSE 2148
// team := team ^ Brown ;
2132: LD_ADDR_VAR 0 3
2136: PUSH
2137: LD_VAR 0 3
2141: PUSH
2142: LD_EXP 9
2146: ADD
2147: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
2148: LD_STRING DonaldsonIn07
2150: PPUSH
2151: LD_EXP 1
2155: PPUSH
2156: CALL_OW 30
2160: IFFALSE 2181
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
2162: LD_ADDR_EXP 10
2166: PUSH
2167: LD_STRING Donaldson
2169: PPUSH
2170: LD_EXP 1
2174: NOT
2175: PPUSH
2176: CALL 354 0 2
2180: ST_TO_ADDR
// if Donaldson then
2181: LD_EXP 10
2185: IFFALSE 2203
// team := team ^ Donaldson ;
2187: LD_ADDR_VAR 0 3
2191: PUSH
2192: LD_VAR 0 3
2196: PUSH
2197: LD_EXP 10
2201: ADD
2202: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
2203: LD_STRING BobbyIn07
2205: PPUSH
2206: LD_EXP 1
2210: PPUSH
2211: CALL_OW 30
2215: IFFALSE 2236
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
2217: LD_ADDR_EXP 11
2221: PUSH
2222: LD_STRING Bobby
2224: PPUSH
2225: LD_EXP 1
2229: NOT
2230: PPUSH
2231: CALL 354 0 2
2235: ST_TO_ADDR
// if Bobby then
2236: LD_EXP 11
2240: IFFALSE 2258
// team := team ^ Bobby ;
2242: LD_ADDR_VAR 0 3
2246: PUSH
2247: LD_VAR 0 3
2251: PUSH
2252: LD_EXP 11
2256: ADD
2257: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
2258: LD_STRING CyrusIn07
2260: PPUSH
2261: LD_EXP 1
2265: PPUSH
2266: CALL_OW 30
2270: IFFALSE 2291
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
2272: LD_ADDR_EXP 12
2276: PUSH
2277: LD_STRING Cyrus
2279: PPUSH
2280: LD_EXP 1
2284: NOT
2285: PPUSH
2286: CALL 354 0 2
2290: ST_TO_ADDR
// if Cyrus then
2291: LD_EXP 12
2295: IFFALSE 2313
// team := team ^ Cyrus ;
2297: LD_ADDR_VAR 0 3
2301: PUSH
2302: LD_VAR 0 3
2306: PUSH
2307: LD_EXP 12
2311: ADD
2312: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
2313: LD_STRING LisaIn07
2315: PPUSH
2316: LD_EXP 1
2320: PPUSH
2321: CALL_OW 30
2325: IFFALSE 2346
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
2327: LD_ADDR_EXP 13
2331: PUSH
2332: LD_STRING Lisa
2334: PPUSH
2335: LD_EXP 1
2339: NOT
2340: PPUSH
2341: CALL 354 0 2
2345: ST_TO_ADDR
// if Lisa then
2346: LD_EXP 13
2350: IFFALSE 2368
// team := team ^ Lisa ;
2352: LD_ADDR_VAR 0 3
2356: PUSH
2357: LD_VAR 0 3
2361: PUSH
2362: LD_EXP 13
2366: ADD
2367: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
2368: LD_STRING GladstoneIn07
2370: PPUSH
2371: LD_EXP 1
2375: PPUSH
2376: CALL_OW 30
2380: IFFALSE 2401
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
2382: LD_ADDR_EXP 15
2386: PUSH
2387: LD_STRING Gladstone
2389: PPUSH
2390: LD_EXP 1
2394: NOT
2395: PPUSH
2396: CALL 354 0 2
2400: ST_TO_ADDR
// if Gladstone then
2401: LD_EXP 15
2405: IFFALSE 2423
// team := team ^ Gladstone ;
2407: LD_ADDR_VAR 0 3
2411: PUSH
2412: LD_VAR 0 3
2416: PUSH
2417: LD_EXP 15
2421: ADD
2422: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
2423: LD_STRING KhatamIn07
2425: PPUSH
2426: LD_EXP 1
2430: PPUSH
2431: CALL_OW 30
2435: IFFALSE 2456
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
2437: LD_ADDR_EXP 16
2441: PUSH
2442: LD_STRING Khatam
2444: PPUSH
2445: LD_EXP 1
2449: NOT
2450: PPUSH
2451: CALL 354 0 2
2455: ST_TO_ADDR
// if Khatam then
2456: LD_EXP 16
2460: IFFALSE 2478
// team := team ^ Khatam ;
2462: LD_ADDR_VAR 0 3
2466: PUSH
2467: LD_VAR 0 3
2471: PUSH
2472: LD_EXP 16
2476: ADD
2477: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
2478: LD_ADDR_VAR 0 4
2482: PUSH
2483: LD_STRING 07_others
2485: PPUSH
2486: CALL_OW 31
2490: ST_TO_ADDR
// if others then
2491: LD_VAR 0 4
2495: IFFALSE 2513
// team := team ^ others ;
2497: LD_ADDR_VAR 0 3
2501: PUSH
2502: LD_VAR 0 3
2506: PUSH
2507: LD_VAR 0 4
2511: ADD
2512: ST_TO_ADDR
// if debug then
2513: LD_EXP 1
2517: IFFALSE 2591
// begin InitHc ;
2519: CALL_OW 19
// for i = 1 to 4 do
2523: LD_ADDR_VAR 0 2
2527: PUSH
2528: DOUBLE
2529: LD_INT 1
2531: DEC
2532: ST_TO_ADDR
2533: LD_INT 4
2535: PUSH
2536: FOR_TO
2537: IFFALSE 2589
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
2539: LD_INT 0
2541: PPUSH
2542: LD_INT 1
2544: PUSH
2545: LD_INT 3
2547: PUSH
2548: EMPTY
2549: LIST
2550: LIST
2551: PUSH
2552: LD_INT 1
2554: PPUSH
2555: LD_INT 2
2557: PPUSH
2558: CALL_OW 12
2562: ARRAY
2563: PPUSH
2564: LD_INT 4
2566: PPUSH
2567: CALL_OW 380
// team := team ^ CreateHuman ;
2571: LD_ADDR_VAR 0 3
2575: PUSH
2576: LD_VAR 0 3
2580: PUSH
2581: CALL_OW 44
2585: ADD
2586: ST_TO_ADDR
// end ;
2587: GO 2536
2589: POP
2590: POP
// end ; m := 0 ;
2591: LD_ADDR_VAR 0 6
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// for i in team do
2599: LD_ADDR_VAR 0 2
2603: PUSH
2604: LD_VAR 0 3
2608: PUSH
2609: FOR_IN
2610: IFFALSE 2790
// if GetClass ( i ) = 3 then
2612: LD_VAR 0 2
2616: PPUSH
2617: CALL_OW 257
2621: PUSH
2622: LD_INT 3
2624: EQUAL
2625: IFFALSE 2773
// begin m := m + 1 ;
2627: LD_ADDR_VAR 0 6
2631: PUSH
2632: LD_VAR 0 6
2636: PUSH
2637: LD_INT 1
2639: PLUS
2640: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
2641: LD_ADDR_VAR 0 5
2645: PUSH
2646: LD_INT 1
2648: PPUSH
2649: LD_INT 1
2651: PPUSH
2652: LD_INT 2
2654: PUSH
2655: LD_INT 3
2657: PUSH
2658: LD_INT 2
2660: PUSH
2661: LD_INT 1
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: LIST
2668: LIST
2669: PUSH
2670: LD_VAR 0 6
2674: PUSH
2675: LD_INT 4
2677: MOD
2678: PUSH
2679: LD_INT 1
2681: PLUS
2682: ARRAY
2683: PPUSH
2684: LD_INT 2
2686: PPUSH
2687: LD_INT 1
2689: PPUSH
2690: LD_INT 4
2692: PUSH
2693: LD_INT 5
2695: PUSH
2696: LD_INT 3
2698: PUSH
2699: LD_INT 11
2701: PUSH
2702: EMPTY
2703: LIST
2704: LIST
2705: LIST
2706: LIST
2707: PUSH
2708: LD_VAR 0 6
2712: PUSH
2713: LD_INT 4
2715: MOD
2716: PUSH
2717: LD_INT 1
2719: PLUS
2720: ARRAY
2721: PPUSH
2722: LD_INT 60
2724: PPUSH
2725: CALL 417 0 7
2729: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2730: LD_VAR 0 5
2734: PPUSH
2735: LD_INT 2
2737: PPUSH
2738: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
2742: LD_VAR 0 5
2746: PPUSH
2747: LD_INT 1
2749: PPUSH
2750: LD_INT 0
2752: PPUSH
2753: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2757: LD_VAR 0 2
2761: PPUSH
2762: LD_VAR 0 5
2766: PPUSH
2767: CALL_OW 52
// end else
2771: GO 2788
// PlaceUnitArea ( i , startArea , false ) ;
2773: LD_VAR 0 2
2777: PPUSH
2778: LD_INT 1
2780: PPUSH
2781: LD_INT 0
2783: PPUSH
2784: CALL_OW 49
2788: GO 2609
2790: POP
2791: POP
// uc_side := 4 ;
2792: LD_ADDR_OWVAR 20
2796: PUSH
2797: LD_INT 4
2799: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
2800: LD_ADDR_EXP 18
2804: PUSH
2805: LD_STRING Harisson
2807: PPUSH
2808: LD_INT 0
2810: PPUSH
2811: CALL 354 0 2
2815: ST_TO_ADDR
// PrepareScout ;
2816: CALL 2825 0 0
// end ;
2820: LD_VAR 0 1
2824: RET
// function PrepareScout ; var ape ; begin
2825: LD_INT 0
2827: PPUSH
2828: PPUSH
// uc_side := 4 ;
2829: LD_ADDR_OWVAR 20
2833: PUSH
2834: LD_INT 4
2836: ST_TO_ADDR
// uc_nation := 1 ;
2837: LD_ADDR_OWVAR 21
2841: PUSH
2842: LD_INT 1
2844: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
2845: LD_STRING FrankIn06
2847: PPUSH
2848: LD_INT 0
2850: PPUSH
2851: CALL_OW 30
2855: IFFALSE 2872
// Frank := CreateCharacter ( 06c_Frank ) else
2857: LD_ADDR_EXP 14
2861: PUSH
2862: LD_STRING 06c_Frank
2864: PPUSH
2865: CALL_OW 34
2869: ST_TO_ADDR
2870: GO 2912
// if LoadVariable ( FrankInDelta , 0 ) then
2872: LD_STRING FrankInDelta
2874: PPUSH
2875: LD_INT 0
2877: PPUSH
2878: CALL_OW 30
2882: IFFALSE 2899
// Frank := CreateCharacter ( 05_Frank ) else
2884: LD_ADDR_EXP 14
2888: PUSH
2889: LD_STRING 05_Frank
2891: PPUSH
2892: CALL_OW 34
2896: ST_TO_ADDR
2897: GO 2912
// Frank := CreateCharacter ( 04_Frank ) ;
2899: LD_ADDR_EXP 14
2903: PUSH
2904: LD_STRING 04_Frank
2906: PPUSH
2907: CALL_OW 34
2911: ST_TO_ADDR
// if Frank then
2912: LD_EXP 14
2916: IFFALSE 3037
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
2918: LD_EXP 14
2922: PPUSH
2923: LD_INT 2
2925: PPUSH
2926: LD_INT 0
2928: PPUSH
2929: CALL_OW 49
// uc_side := 0 ;
2933: LD_ADDR_OWVAR 20
2937: PUSH
2938: LD_INT 0
2940: ST_TO_ADDR
// uc_nation := 0 ;
2941: LD_ADDR_OWVAR 21
2945: PUSH
2946: LD_INT 0
2948: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
2949: LD_INT 0
2951: PPUSH
2952: LD_INT 12
2954: PPUSH
2955: LD_INT 0
2957: PPUSH
2958: CALL_OW 380
// ape := CreateHuman ;
2962: LD_ADDR_VAR 0 2
2966: PUSH
2967: CALL_OW 44
2971: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
2972: LD_VAR 0 2
2976: PPUSH
2977: LD_EXP 14
2981: PPUSH
2982: CALL_OW 250
2986: PPUSH
2987: LD_EXP 14
2991: PPUSH
2992: CALL_OW 251
2996: PPUSH
2997: LD_INT 5
2999: PPUSH
3000: LD_INT 0
3002: PPUSH
3003: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
3007: LD_VAR 0 2
3011: PPUSH
3012: LD_EXP 14
3016: PPUSH
3017: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
3021: LD_EXP 14
3025: PPUSH
3026: LD_VAR 0 2
3030: PPUSH
3031: CALL_OW 119
// exit ;
3035: GO 3077
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
3037: LD_ADDR_EXP 17
3041: PUSH
3042: LD_STRING Yamoko
3044: PPUSH
3045: LD_INT 0
3047: PPUSH
3048: CALL 354 0 2
3052: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
3053: LD_EXP 17
3057: PPUSH
3058: LD_INT 2
3060: PPUSH
3061: LD_INT 0
3063: PPUSH
3064: CALL_OW 49
// ComHold ( Kikuchi ) ;
3068: LD_EXP 17
3072: PPUSH
3073: CALL_OW 140
// end ; end_of_file
3077: LD_VAR 0 1
3081: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
3082: LD_INT 0
3084: PPUSH
3085: PPUSH
3086: PPUSH
3087: PPUSH
3088: PPUSH
3089: PPUSH
3090: PPUSH
3091: PPUSH
3092: PPUSH
3093: PPUSH
3094: PPUSH
3095: PPUSH
3096: PPUSH
3097: PPUSH
3098: PPUSH
3099: PPUSH
// ru_rebuild_list := [ ] ;
3100: LD_ADDR_EXP 19
3104: PUSH
3105: EMPTY
3106: ST_TO_ADDR
// uc_side := 3 ;
3107: LD_ADDR_OWVAR 20
3111: PUSH
3112: LD_INT 3
3114: ST_TO_ADDR
// uc_nation := 3 ;
3115: LD_ADDR_OWVAR 21
3119: PUSH
3120: LD_INT 3
3122: ST_TO_ADDR
// if Difficulty > 1 then
3123: LD_OWVAR 67
3127: PUSH
3128: LD_INT 1
3130: GREATER
3131: IFFALSE 3267
// begin bc_type := b_breastwork ;
3133: LD_ADDR_OWVAR 42
3137: PUSH
3138: LD_INT 31
3140: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
3141: LD_INT 78
3143: PPUSH
3144: LD_INT 74
3146: PPUSH
3147: LD_INT 2
3149: PPUSH
3150: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
3154: LD_INT 171
3156: PPUSH
3157: LD_INT 193
3159: PPUSH
3160: LD_INT 4
3162: PPUSH
3163: CALL_OW 47
// bc_type := b_turret ;
3167: LD_ADDR_OWVAR 42
3171: PUSH
3172: LD_INT 33
3174: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
3175: LD_INT 129
3177: PPUSH
3178: LD_INT 96
3180: PPUSH
3181: LD_INT 3
3183: PPUSH
3184: CALL_OW 47
// if Difficulty > 2 then
3188: LD_OWVAR 67
3192: PUSH
3193: LD_INT 2
3195: GREATER
3196: IFFALSE 3267
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
3198: LD_INT 83
3200: PPUSH
3201: LD_INT 141
3203: PPUSH
3204: CALL_OW 428
3208: PPUSH
3209: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
3213: LD_INT 78
3215: PPUSH
3216: LD_INT 133
3218: PPUSH
3219: CALL_OW 428
3223: PPUSH
3224: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
3228: LD_INT 83
3230: PPUSH
3231: LD_INT 141
3233: PPUSH
3234: LD_INT 2
3236: PPUSH
3237: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
3241: LD_INT 78
3243: PPUSH
3244: LD_INT 133
3246: PPUSH
3247: LD_INT 2
3249: PPUSH
3250: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
3254: LD_INT 145
3256: PPUSH
3257: LD_INT 112
3259: PPUSH
3260: LD_INT 3
3262: PPUSH
3263: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
3267: LD_ADDR_VAR 0 9
3271: PUSH
3272: LD_INT 22
3274: PUSH
3275: LD_INT 3
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: PUSH
3282: LD_INT 2
3284: PUSH
3285: LD_INT 30
3287: PUSH
3288: LD_INT 0
3290: PUSH
3291: EMPTY
3292: LIST
3293: LIST
3294: PUSH
3295: LD_INT 30
3297: PUSH
3298: LD_INT 1
3300: PUSH
3301: EMPTY
3302: LIST
3303: LIST
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: LIST
3309: PUSH
3310: EMPTY
3311: LIST
3312: LIST
3313: PPUSH
3314: CALL_OW 69
3318: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
3319: LD_ADDR_VAR 0 10
3323: PUSH
3324: LD_INT 22
3326: PUSH
3327: LD_INT 3
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PUSH
3334: LD_INT 2
3336: PUSH
3337: LD_INT 30
3339: PUSH
3340: LD_INT 6
3342: PUSH
3343: EMPTY
3344: LIST
3345: LIST
3346: PUSH
3347: LD_INT 30
3349: PUSH
3350: LD_INT 7
3352: PUSH
3353: EMPTY
3354: LIST
3355: LIST
3356: PUSH
3357: LD_INT 30
3359: PUSH
3360: LD_INT 8
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: PUSH
3367: EMPTY
3368: LIST
3369: LIST
3370: LIST
3371: LIST
3372: PUSH
3373: EMPTY
3374: LIST
3375: LIST
3376: PPUSH
3377: CALL_OW 69
3381: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3382: LD_ADDR_VAR 0 11
3386: PUSH
3387: LD_INT 22
3389: PUSH
3390: LD_INT 3
3392: PUSH
3393: EMPTY
3394: LIST
3395: LIST
3396: PUSH
3397: LD_INT 30
3399: PUSH
3400: LD_INT 3
3402: PUSH
3403: EMPTY
3404: LIST
3405: LIST
3406: PUSH
3407: EMPTY
3408: LIST
3409: LIST
3410: PPUSH
3411: CALL_OW 69
3415: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
3416: LD_ADDR_VAR 0 12
3420: PUSH
3421: LD_INT 22
3423: PUSH
3424: LD_INT 3
3426: PUSH
3427: EMPTY
3428: LIST
3429: LIST
3430: PUSH
3431: LD_INT 30
3433: PUSH
3434: LD_INT 31
3436: PUSH
3437: EMPTY
3438: LIST
3439: LIST
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: PPUSH
3445: CALL_OW 69
3449: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
3450: LD_ADDR_VAR 0 13
3454: PUSH
3455: LD_INT 22
3457: PUSH
3458: LD_INT 3
3460: PUSH
3461: EMPTY
3462: LIST
3463: LIST
3464: PUSH
3465: LD_INT 30
3467: PUSH
3468: LD_INT 32
3470: PUSH
3471: EMPTY
3472: LIST
3473: LIST
3474: PUSH
3475: EMPTY
3476: LIST
3477: LIST
3478: PPUSH
3479: CALL_OW 69
3483: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3484: LD_ADDR_VAR 0 14
3488: PUSH
3489: LD_INT 22
3491: PUSH
3492: LD_INT 3
3494: PUSH
3495: EMPTY
3496: LIST
3497: LIST
3498: PUSH
3499: LD_INT 30
3501: PUSH
3502: LD_INT 33
3504: PUSH
3505: EMPTY
3506: LIST
3507: LIST
3508: PUSH
3509: EMPTY
3510: LIST
3511: LIST
3512: PPUSH
3513: CALL_OW 69
3517: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
3518: LD_ADDR_VAR 0 15
3522: PUSH
3523: LD_INT 42
3525: PUSH
3526: LD_INT 5
3528: PUSH
3529: EMPTY
3530: LIST
3531: LIST
3532: PUSH
3533: LD_INT 43
3535: PUSH
3536: LD_INT 50
3538: PUSH
3539: EMPTY
3540: LIST
3541: LIST
3542: PUSH
3543: LD_INT 44
3545: PUSH
3546: LD_INT 30
3548: PUSH
3549: EMPTY
3550: LIST
3551: LIST
3552: PUSH
3553: LD_INT 46
3555: PUSH
3556: LD_INT 15
3558: PUSH
3559: EMPTY
3560: LIST
3561: LIST
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: LIST
3567: LIST
3568: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 4 , 3 ] ;
3569: LD_ADDR_VAR 0 16
3573: PUSH
3574: LD_INT 0
3576: PUSH
3577: LD_INT 4
3579: PUSH
3580: LD_INT 4
3582: PUSH
3583: LD_INT 3
3585: PUSH
3586: EMPTY
3587: LIST
3588: LIST
3589: LIST
3590: LIST
3591: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
3592: LD_ADDR_VAR 0 6
3596: PUSH
3597: LD_INT 4
3599: PUSH
3600: LD_INT 5
3602: PUSH
3603: LD_INT 6
3605: PUSH
3606: EMPTY
3607: LIST
3608: LIST
3609: LIST
3610: PUSH
3611: LD_OWVAR 67
3615: ARRAY
3616: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
3617: LD_INT 16
3619: PPUSH
3620: LD_STRING am_tukh
3622: PPUSH
3623: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
3627: LD_ADDR_VAR 0 2
3631: PUSH
3632: LD_INT 21
3634: PUSH
3635: LD_INT 3
3637: PUSH
3638: EMPTY
3639: LIST
3640: LIST
3641: PPUSH
3642: CALL_OW 69
3646: PUSH
3647: FOR_IN
3648: IFFALSE 3681
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
3650: LD_VAR 0 2
3654: PPUSH
3655: LD_INT 4
3657: PUSH
3658: LD_INT 5
3660: PUSH
3661: LD_INT 6
3663: PUSH
3664: EMPTY
3665: LIST
3666: LIST
3667: LIST
3668: PUSH
3669: LD_OWVAR 67
3673: ARRAY
3674: PPUSH
3675: CALL_OW 241
3679: GO 3647
3681: POP
3682: POP
// for i in dep_list do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: LD_VAR 0 9
3692: PUSH
3693: FOR_IN
3694: IFFALSE 3738
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
3696: LD_VAR 0 2
3700: PPUSH
3701: CALL_OW 274
3705: PPUSH
3706: LD_INT 1
3708: PPUSH
3709: LD_INT 1000
3711: PPUSH
3712: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
3716: LD_VAR 0 2
3720: PPUSH
3721: CALL_OW 274
3725: PPUSH
3726: LD_INT 2
3728: PPUSH
3729: LD_INT 1000
3731: PPUSH
3732: CALL_OW 277
// end ;
3736: GO 3693
3738: POP
3739: POP
// InitHc ;
3740: CALL_OW 19
// tmp := bunker_list * [ 50 , 70 , 85 ] [ Difficulty ] div 100 ;
3744: LD_ADDR_VAR 0 8
3748: PUSH
3749: LD_VAR 0 13
3753: PUSH
3754: LD_INT 50
3756: PUSH
3757: LD_INT 70
3759: PUSH
3760: LD_INT 85
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: LIST
3767: PUSH
3768: LD_OWVAR 67
3772: ARRAY
3773: MUL
3774: PUSH
3775: LD_INT 100
3777: DIV
3778: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
3779: LD_ADDR_VAR 0 16
3783: PUSH
3784: LD_VAR 0 16
3788: PPUSH
3789: LD_INT 1
3791: PPUSH
3792: LD_VAR 0 8
3796: PPUSH
3797: CALL_OW 1
3801: ST_TO_ADDR
// tmp := [ ] ;
3802: LD_ADDR_VAR 0 8
3806: PUSH
3807: EMPTY
3808: ST_TO_ADDR
// for i in bunker_list do
3809: LD_ADDR_VAR 0 2
3813: PUSH
3814: LD_VAR 0 13
3818: PUSH
3819: FOR_IN
3820: IFFALSE 3916
// if i mod 10 + 1 < tmp then
3822: LD_VAR 0 2
3826: PUSH
3827: LD_INT 10
3829: MOD
3830: PUSH
3831: LD_INT 1
3833: PLUS
3834: PUSH
3835: LD_VAR 0 8
3839: LESS
3840: IFFALSE 3885
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
3842: LD_ADDR_VAR 0 8
3846: PUSH
3847: LD_VAR 0 8
3851: PPUSH
3852: LD_VAR 0 2
3856: PUSH
3857: LD_INT 3
3859: PPUSH
3860: LD_INT 5
3862: PPUSH
3863: CALL_OW 12
3867: MOD
3868: PUSH
3869: LD_INT 1
3871: PLUS
3872: PPUSH
3873: LD_VAR 0 2
3877: PPUSH
3878: CALL_OW 2
3882: ST_TO_ADDR
3883: GO 3914
// tmp := Insert ( tmp , tmp + 1 , i ) ;
3885: LD_ADDR_VAR 0 8
3889: PUSH
3890: LD_VAR 0 8
3894: PPUSH
3895: LD_VAR 0 8
3899: PUSH
3900: LD_INT 1
3902: PLUS
3903: PPUSH
3904: LD_VAR 0 2
3908: PPUSH
3909: CALL_OW 2
3913: ST_TO_ADDR
3914: GO 3819
3916: POP
3917: POP
// bunker_list := tmp ;
3918: LD_ADDR_VAR 0 13
3922: PUSH
3923: LD_VAR 0 8
3927: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
3928: LD_ADDR_VAR 0 2
3932: PUSH
3933: LD_VAR 0 13
3937: PUSH
3938: LD_VAR 0 14
3942: ADD
3943: PUSH
3944: FOR_IN
3945: IFFALSE 4042
// begin tmp := rand ( 0 , 100 ) ;
3947: LD_ADDR_VAR 0 8
3951: PUSH
3952: LD_INT 0
3954: PPUSH
3955: LD_INT 100
3957: PPUSH
3958: CALL_OW 12
3962: ST_TO_ADDR
// r := 0 ;
3963: LD_ADDR_VAR 0 4
3967: PUSH
3968: LD_INT 0
3970: ST_TO_ADDR
// for j in weapons_list do
3971: LD_ADDR_VAR 0 3
3975: PUSH
3976: LD_VAR 0 15
3980: PUSH
3981: FOR_IN
3982: IFFALSE 4038
// begin r := r + j [ 2 ] ;
3984: LD_ADDR_VAR 0 4
3988: PUSH
3989: LD_VAR 0 4
3993: PUSH
3994: LD_VAR 0 3
3998: PUSH
3999: LD_INT 2
4001: ARRAY
4002: PLUS
4003: ST_TO_ADDR
// if r >= tmp then
4004: LD_VAR 0 4
4008: PUSH
4009: LD_VAR 0 8
4013: GREATEREQUAL
4014: IFFALSE 4036
// begin PlaceWeaponTurret ( i , j [ 1 ] ) ;
4016: LD_VAR 0 2
4020: PPUSH
4021: LD_VAR 0 3
4025: PUSH
4026: LD_INT 1
4028: ARRAY
4029: PPUSH
4030: CALL_OW 431
// break ;
4034: GO 4038
// end ; end ;
4036: GO 3981
4038: POP
4039: POP
// end ;
4040: GO 3944
4042: POP
4043: POP
// while ( personel_counter [ 1 ] ) do
4044: LD_VAR 0 16
4048: PUSH
4049: LD_INT 1
4051: ARRAY
4052: IFFALSE 4160
// begin i := rand ( 1 , bunker_list ) ;
4054: LD_ADDR_VAR 0 2
4058: PUSH
4059: LD_INT 1
4061: PPUSH
4062: LD_VAR 0 13
4066: PPUSH
4067: CALL_OW 12
4071: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4072: LD_INT 0
4074: PPUSH
4075: LD_INT 1
4077: PPUSH
4078: LD_VAR 0 6
4082: PPUSH
4083: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
4087: CALL_OW 44
4091: PPUSH
4092: LD_VAR 0 13
4096: PUSH
4097: LD_VAR 0 2
4101: ARRAY
4102: PPUSH
4103: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
4107: LD_ADDR_VAR 0 13
4111: PUSH
4112: LD_VAR 0 13
4116: PPUSH
4117: LD_VAR 0 2
4121: PPUSH
4122: CALL_OW 3
4126: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
4127: LD_ADDR_VAR 0 16
4131: PUSH
4132: LD_VAR 0 16
4136: PPUSH
4137: LD_INT 1
4139: PPUSH
4140: LD_VAR 0 16
4144: PUSH
4145: LD_INT 1
4147: ARRAY
4148: PUSH
4149: LD_INT 1
4151: MINUS
4152: PPUSH
4153: CALL_OW 1
4157: ST_TO_ADDR
// end ;
4158: GO 4044
// for i = 1 to personel_counter [ 2 ] do
4160: LD_ADDR_VAR 0 2
4164: PUSH
4165: DOUBLE
4166: LD_INT 1
4168: DEC
4169: ST_TO_ADDR
4170: LD_VAR 0 16
4174: PUSH
4175: LD_INT 2
4177: ARRAY
4178: PUSH
4179: FOR_TO
4180: IFFALSE 4211
// begin PrepareHuman ( false , 2 , skill ) ;
4182: LD_INT 0
4184: PPUSH
4185: LD_INT 2
4187: PPUSH
4188: LD_VAR 0 6
4192: PPUSH
4193: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
4197: CALL_OW 44
4201: PPUSH
4202: LD_INT 16
4204: PPUSH
4205: CALL_OW 52
// end ;
4209: GO 4179
4211: POP
4212: POP
// for i = 1 to personel_counter [ 3 ] do
4213: LD_ADDR_VAR 0 2
4217: PUSH
4218: DOUBLE
4219: LD_INT 1
4221: DEC
4222: ST_TO_ADDR
4223: LD_VAR 0 16
4227: PUSH
4228: LD_INT 3
4230: ARRAY
4231: PUSH
4232: FOR_TO
4233: IFFALSE 4270
// begin PrepareHuman ( false , 3 , skill ) ;
4235: LD_INT 0
4237: PPUSH
4238: LD_INT 3
4240: PPUSH
4241: LD_VAR 0 6
4245: PPUSH
4246: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ 1 ] ) ;
4250: CALL_OW 44
4254: PPUSH
4255: LD_VAR 0 11
4259: PUSH
4260: LD_INT 1
4262: ARRAY
4263: PPUSH
4264: CALL_OW 52
// end ;
4268: GO 4232
4270: POP
4271: POP
// for i = 1 to personel_counter [ 4 ] do
4272: LD_ADDR_VAR 0 2
4276: PUSH
4277: DOUBLE
4278: LD_INT 1
4280: DEC
4281: ST_TO_ADDR
4282: LD_VAR 0 16
4286: PUSH
4287: LD_INT 4
4289: ARRAY
4290: PUSH
4291: FOR_TO
4292: IFFALSE 4329
// begin PrepareHuman ( false , 4 , skill ) ;
4294: LD_INT 0
4296: PPUSH
4297: LD_INT 4
4299: PPUSH
4300: LD_VAR 0 6
4304: PPUSH
4305: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
4309: CALL_OW 44
4313: PPUSH
4314: LD_VAR 0 10
4318: PUSH
4319: LD_INT 1
4321: ARRAY
4322: PPUSH
4323: CALL_OW 52
// end ;
4327: GO 4291
4329: POP
4330: POP
// for i in breastworks_list do
4331: LD_ADDR_VAR 0 2
4335: PUSH
4336: LD_VAR 0 12
4340: PUSH
4341: FOR_IN
4342: IFFALSE 4454
// begin r := GetDir ( i ) ;
4344: LD_ADDR_VAR 0 4
4348: PUSH
4349: LD_VAR 0 2
4353: PPUSH
4354: CALL_OW 254
4358: ST_TO_ADDR
// if r > 3 then
4359: LD_VAR 0 4
4363: PUSH
4364: LD_INT 3
4366: GREATER
4367: IFFALSE 4385
// r := r - 3 else
4369: LD_ADDR_VAR 0 4
4373: PUSH
4374: LD_VAR 0 4
4378: PUSH
4379: LD_INT 3
4381: MINUS
4382: ST_TO_ADDR
4383: GO 4399
// r := r + 3 ;
4385: LD_ADDR_VAR 0 4
4389: PUSH
4390: LD_VAR 0 4
4394: PUSH
4395: LD_INT 3
4397: PLUS
4398: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4399: LD_INT 0
4401: PPUSH
4402: LD_INT 1
4404: PPUSH
4405: LD_VAR 0 6
4409: PPUSH
4410: CALL_OW 380
// un := CreateHuman ;
4414: LD_ADDR_VAR 0 5
4418: PUSH
4419: CALL_OW 44
4423: ST_TO_ADDR
// SetDir ( un , r ) ;
4424: LD_VAR 0 5
4428: PPUSH
4429: LD_VAR 0 4
4433: PPUSH
4434: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
4438: LD_VAR 0 5
4442: PPUSH
4443: LD_VAR 0 2
4447: PPUSH
4448: CALL_OW 52
// end ;
4452: GO 4341
4454: POP
4455: POP
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
4456: LD_ADDR_VAR 0 8
4460: PUSH
4461: LD_INT 22
4463: PUSH
4464: LD_INT 3
4466: PUSH
4467: EMPTY
4468: LIST
4469: LIST
4470: PUSH
4471: LD_INT 25
4473: PUSH
4474: LD_INT 3
4476: PUSH
4477: EMPTY
4478: LIST
4479: LIST
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: PPUSH
4485: CALL_OW 69
4489: ST_TO_ADDR
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
4490: LD_ADDR_VAR 0 4
4494: PUSH
4495: LD_INT 4
4497: PUSH
4498: LD_INT 5
4500: PUSH
4501: LD_INT 6
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: LIST
4508: PUSH
4509: LD_OWVAR 67
4513: ARRAY
4514: ST_TO_ADDR
// for i = 1 to r do
4515: LD_ADDR_VAR 0 2
4519: PUSH
4520: DOUBLE
4521: LD_INT 1
4523: DEC
4524: ST_TO_ADDR
4525: LD_VAR 0 4
4529: PUSH
4530: FOR_TO
4531: IFFALSE 4675
// begin un := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
4533: LD_ADDR_VAR 0 5
4537: PUSH
4538: LD_INT 3
4540: PPUSH
4541: LD_INT 3
4543: PPUSH
4544: LD_INT 22
4546: PPUSH
4547: LD_INT 1
4549: PPUSH
4550: LD_INT 1
4552: PPUSH
4553: LD_INT 43
4555: PUSH
4556: LD_INT 44
4558: PUSH
4559: LD_INT 42
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: LIST
4566: PUSH
4567: LD_VAR 0 2
4571: PUSH
4572: LD_INT 3
4574: MOD
4575: PUSH
4576: LD_INT 1
4578: PLUS
4579: ARRAY
4580: PPUSH
4581: LD_INT 100
4583: PPUSH
4584: CALL 417 0 7
4588: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4589: LD_VAR 0 5
4593: PPUSH
4594: LD_INT 0
4596: PPUSH
4597: LD_INT 5
4599: PPUSH
4600: CALL_OW 12
4604: PPUSH
4605: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
4609: LD_VAR 0 5
4613: PPUSH
4614: LD_INT 5
4616: PPUSH
4617: LD_INT 0
4619: PPUSH
4620: CALL_OW 49
// if i > tmp then
4624: LD_VAR 0 2
4628: PUSH
4629: LD_VAR 0 8
4633: GREATER
4634: IFFALSE 4638
// continue ;
4636: GO 4530
// ComExitBuilding ( tmp [ i ] ) ;
4638: LD_VAR 0 8
4642: PUSH
4643: LD_VAR 0 2
4647: ARRAY
4648: PPUSH
4649: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , un ) ;
4653: LD_VAR 0 8
4657: PUSH
4658: LD_VAR 0 2
4662: ARRAY
4663: PPUSH
4664: LD_VAR 0 5
4668: PPUSH
4669: CALL_OW 180
// end ;
4673: GO 4530
4675: POP
4676: POP
// end ;
4677: LD_VAR 0 1
4681: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_ok ] ] ) do var i , filter , tmp , engs , enemy ;
4682: LD_INT 22
4684: PUSH
4685: LD_INT 3
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: PUSH
4692: LD_INT 25
4694: PUSH
4695: LD_INT 2
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PUSH
4702: LD_INT 50
4704: PUSH
4705: EMPTY
4706: LIST
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: LIST
4712: PPUSH
4713: CALL_OW 69
4717: IFFALSE 5413
4719: GO 4721
4721: DISABLE
4722: LD_INT 0
4724: PPUSH
4725: PPUSH
4726: PPUSH
4727: PPUSH
4728: PPUSH
// begin enable ;
4729: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
4730: LD_ADDR_VAR 0 2
4734: PUSH
4735: LD_INT 6
4737: PPUSH
4738: LD_INT 3
4740: PUSH
4741: LD_INT 24
4743: PUSH
4744: LD_INT 1000
4746: PUSH
4747: EMPTY
4748: LIST
4749: LIST
4750: PUSH
4751: EMPTY
4752: LIST
4753: LIST
4754: PUSH
4755: LD_INT 21
4757: PUSH
4758: LD_INT 3
4760: PUSH
4761: EMPTY
4762: LIST
4763: LIST
4764: PUSH
4765: EMPTY
4766: LIST
4767: LIST
4768: PPUSH
4769: CALL_OW 70
4773: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_lives , 650 ] ] ) ;
4774: LD_ADDR_VAR 0 4
4778: PUSH
4779: LD_INT 22
4781: PUSH
4782: LD_INT 3
4784: PUSH
4785: EMPTY
4786: LIST
4787: LIST
4788: PUSH
4789: LD_INT 25
4791: PUSH
4792: LD_INT 2
4794: PUSH
4795: EMPTY
4796: LIST
4797: LIST
4798: PUSH
4799: LD_INT 24
4801: PUSH
4802: LD_INT 650
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: PUSH
4809: EMPTY
4810: LIST
4811: LIST
4812: LIST
4813: PPUSH
4814: CALL_OW 69
4818: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
4819: LD_VAR 0 2
4823: NOT
4824: PUSH
4825: LD_EXP 19
4829: NOT
4830: AND
4831: IFFALSE 4863
// begin if not IsInUnit ( engs [ 1 ] ) then
4833: LD_VAR 0 4
4837: PUSH
4838: LD_INT 1
4840: ARRAY
4841: PPUSH
4842: CALL_OW 310
4846: NOT
4847: IFFALSE 4861
// ComEnterUnit ( engs , ru_dep_main ) ;
4849: LD_VAR 0 4
4853: PPUSH
4854: LD_INT 16
4856: PPUSH
4857: CALL_OW 120
// exit ;
4861: GO 5413
// end ; if debug then
4863: LD_EXP 1
4867: IFFALSE 4888
// display_strings := [ engs , filter ] ;
4869: LD_ADDR_OWVAR 47
4873: PUSH
4874: LD_VAR 0 4
4878: PUSH
4879: LD_VAR 0 2
4883: PUSH
4884: EMPTY
4885: LIST
4886: LIST
4887: ST_TO_ADDR
// if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
4888: LD_VAR 0 4
4892: PPUSH
4893: LD_INT 3
4895: PUSH
4896: LD_INT 24
4898: PUSH
4899: LD_INT 650
4901: PUSH
4902: EMPTY
4903: LIST
4904: LIST
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: PPUSH
4910: CALL_OW 72
4914: IFFALSE 5007
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
4916: LD_ADDR_VAR 0 3
4920: PUSH
4921: LD_VAR 0 4
4925: PPUSH
4926: LD_INT 3
4928: PUSH
4929: LD_INT 24
4931: PUSH
4932: LD_INT 650
4934: PUSH
4935: EMPTY
4936: LIST
4937: LIST
4938: PUSH
4939: EMPTY
4940: LIST
4941: LIST
4942: PPUSH
4943: CALL_OW 72
4947: ST_TO_ADDR
// for i in tmp do
4948: LD_ADDR_VAR 0 1
4952: PUSH
4953: LD_VAR 0 3
4957: PUSH
4958: FOR_IN
4959: IFFALSE 5005
// if not IsInArea ( i , mainBaseArea ) then
4961: LD_VAR 0 1
4965: PPUSH
4966: LD_INT 14
4968: PPUSH
4969: CALL_OW 308
4973: NOT
4974: IFFALSE 5003
// begin ComMoveXY ( i , 129 , 125 ) ;
4976: LD_VAR 0 1
4980: PPUSH
4981: LD_INT 129
4983: PPUSH
4984: LD_INT 125
4986: PPUSH
4987: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
4991: LD_VAR 0 1
4995: PPUSH
4996: LD_INT 1050
4998: PPUSH
4999: CALL_OW 202
// end ;
5003: GO 4958
5005: POP
5006: POP
// end ; if filter then
5007: LD_VAR 0 2
5011: IFFALSE 5270
// begin for i in engs do
5013: LD_ADDR_VAR 0 1
5017: PUSH
5018: LD_VAR 0 4
5022: PUSH
5023: FOR_IN
5024: IFFALSE 5048
// if IsInUnit ( i ) then
5026: LD_VAR 0 1
5030: PPUSH
5031: CALL_OW 310
5035: IFFALSE 5046
// ComExitBuilding ( i ) ;
5037: LD_VAR 0 1
5041: PPUSH
5042: CALL_OW 122
5046: GO 5023
5048: POP
5049: POP
// wait ( 3 ) ;
5050: LD_INT 3
5052: PPUSH
5053: CALL_OW 67
// if filter >= 2 and engs >= 2 then
5057: LD_VAR 0 2
5061: PUSH
5062: LD_INT 2
5064: GREATEREQUAL
5065: PUSH
5066: LD_VAR 0 4
5070: PUSH
5071: LD_INT 2
5073: GREATEREQUAL
5074: AND
5075: IFFALSE 5223
// begin for i = 1 to engs / 2 do
5077: LD_ADDR_VAR 0 1
5081: PUSH
5082: DOUBLE
5083: LD_INT 1
5085: DEC
5086: ST_TO_ADDR
5087: LD_VAR 0 4
5091: PUSH
5092: LD_INT 2
5094: DIVREAL
5095: PUSH
5096: FOR_TO
5097: IFFALSE 5143
// if not HasTask ( engs [ i ] ) then
5099: LD_VAR 0 4
5103: PUSH
5104: LD_VAR 0 1
5108: ARRAY
5109: PPUSH
5110: CALL_OW 314
5114: NOT
5115: IFFALSE 5141
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
5117: LD_VAR 0 4
5121: PUSH
5122: LD_VAR 0 1
5126: ARRAY
5127: PPUSH
5128: LD_VAR 0 2
5132: PUSH
5133: LD_INT 1
5135: ARRAY
5136: PPUSH
5137: CALL_OW 130
5141: GO 5096
5143: POP
5144: POP
// for i = engs / 2 + 1 to engs do
5145: LD_ADDR_VAR 0 1
5149: PUSH
5150: DOUBLE
5151: LD_VAR 0 4
5155: PUSH
5156: LD_INT 2
5158: DIVREAL
5159: PUSH
5160: LD_INT 1
5162: PLUS
5163: DEC
5164: ST_TO_ADDR
5165: LD_VAR 0 4
5169: PUSH
5170: FOR_TO
5171: IFFALSE 5219
// if not HasTask ( engs [ i ] ) then
5173: LD_VAR 0 4
5177: PUSH
5178: LD_VAR 0 1
5182: ARRAY
5183: PPUSH
5184: CALL_OW 314
5188: NOT
5189: IFFALSE 5217
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
5191: LD_VAR 0 4
5195: PUSH
5196: LD_VAR 0 1
5200: ARRAY
5201: PPUSH
5202: LD_VAR 0 2
5206: PUSH
5207: LD_VAR 0 2
5211: ARRAY
5212: PPUSH
5213: CALL_OW 130
5217: GO 5170
5219: POP
5220: POP
// end else
5221: GO 5270
// for i in engs do
5223: LD_ADDR_VAR 0 1
5227: PUSH
5228: LD_VAR 0 4
5232: PUSH
5233: FOR_IN
5234: IFFALSE 5268
// if not HasTask ( i ) then
5236: LD_VAR 0 1
5240: PPUSH
5241: CALL_OW 314
5245: NOT
5246: IFFALSE 5266
// ComRepairBuilding ( i , filter [ 1 ] ) ;
5248: LD_VAR 0 1
5252: PPUSH
5253: LD_VAR 0 2
5257: PUSH
5258: LD_INT 1
5260: ARRAY
5261: PPUSH
5262: CALL_OW 130
5266: GO 5233
5268: POP
5269: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
5270: LD_ADDR_VAR 0 5
5274: PUSH
5275: LD_INT 81
5277: PUSH
5278: LD_INT 3
5280: PUSH
5281: EMPTY
5282: LIST
5283: LIST
5284: PPUSH
5285: CALL_OW 69
5289: ST_TO_ADDR
// if ru_rebuild_list and not filter then
5290: LD_EXP 19
5294: PUSH
5295: LD_VAR 0 2
5299: NOT
5300: AND
5301: IFFALSE 5413
// begin ComExitBuilding ( engs ) ;
5303: LD_VAR 0 4
5307: PPUSH
5308: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
5312: LD_VAR 0 5
5316: PPUSH
5317: LD_EXP 19
5321: PUSH
5322: LD_INT 2
5324: ARRAY
5325: PPUSH
5326: LD_EXP 19
5330: PUSH
5331: LD_INT 3
5333: ARRAY
5334: PPUSH
5335: CALL_OW 73
5339: PPUSH
5340: LD_EXP 19
5344: PUSH
5345: LD_INT 2
5347: ARRAY
5348: PPUSH
5349: LD_EXP 19
5353: PUSH
5354: LD_INT 3
5356: ARRAY
5357: PPUSH
5358: CALL_OW 297
5362: PUSH
5363: LD_INT 10
5365: GREATER
5366: IFFALSE 5413
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
5368: LD_VAR 0 4
5372: PPUSH
5373: LD_EXP 19
5377: PUSH
5378: LD_INT 1
5380: ARRAY
5381: PPUSH
5382: LD_EXP 19
5386: PUSH
5387: LD_INT 2
5389: ARRAY
5390: PPUSH
5391: LD_EXP 19
5395: PUSH
5396: LD_INT 3
5398: ARRAY
5399: PPUSH
5400: LD_EXP 19
5404: PUSH
5405: LD_INT 4
5407: ARRAY
5408: PPUSH
5409: CALL_OW 145
// end ; end ;
5413: PPOPN 5
5415: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 650 do var tmp ;
5416: LD_INT 16
5418: PPUSH
5419: CALL_OW 256
5423: PUSH
5424: LD_INT 650
5426: LESS
5427: IFFALSE 5510
5429: GO 5431
5431: DISABLE
5432: LD_INT 0
5434: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
5435: LD_ADDR_VAR 0 1
5439: PUSH
5440: LD_INT 22
5442: PUSH
5443: LD_INT 3
5445: PUSH
5446: EMPTY
5447: LIST
5448: LIST
5449: PUSH
5450: LD_INT 25
5452: PUSH
5453: LD_INT 1
5455: PUSH
5456: EMPTY
5457: LIST
5458: LIST
5459: PUSH
5460: EMPTY
5461: LIST
5462: LIST
5463: PPUSH
5464: CALL_OW 69
5468: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
5469: LD_VAR 0 1
5473: PPUSH
5474: CALL_OW 122
// wait ( 3 ) ;
5478: LD_INT 3
5480: PPUSH
5481: CALL_OW 67
// ComAgressiveMove ( tmp , GetX ( ru_dep_main ) , GetY ( ru_dep_main ) ) ;
5485: LD_VAR 0 1
5489: PPUSH
5490: LD_INT 16
5492: PPUSH
5493: CALL_OW 250
5497: PPUSH
5498: LD_INT 16
5500: PPUSH
5501: CALL_OW 251
5505: PPUSH
5506: CALL_OW 114
// end ;
5510: PPOPN 1
5512: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
5513: LD_INT 22
5515: PUSH
5516: LD_INT 3
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PUSH
5523: LD_INT 25
5525: PUSH
5526: LD_INT 4
5528: PUSH
5529: EMPTY
5530: LIST
5531: LIST
5532: PUSH
5533: EMPTY
5534: LIST
5535: LIST
5536: PPUSH
5537: CALL_OW 69
5541: IFFALSE 5795
5543: GO 5545
5545: DISABLE
5546: LD_INT 0
5548: PPUSH
5549: PPUSH
5550: PPUSH
// begin enable ;
5551: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5552: LD_ADDR_VAR 0 2
5556: PUSH
5557: LD_INT 14
5559: PPUSH
5560: LD_INT 22
5562: PUSH
5563: LD_INT 3
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PUSH
5570: LD_INT 21
5572: PUSH
5573: LD_INT 1
5575: PUSH
5576: EMPTY
5577: LIST
5578: LIST
5579: PUSH
5580: LD_INT 3
5582: PUSH
5583: LD_INT 24
5585: PUSH
5586: LD_INT 1000
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: EMPTY
5594: LIST
5595: LIST
5596: PUSH
5597: EMPTY
5598: LIST
5599: LIST
5600: LIST
5601: PPUSH
5602: CALL_OW 70
5606: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
5607: LD_ADDR_VAR 0 3
5611: PUSH
5612: LD_INT 22
5614: PUSH
5615: LD_INT 3
5617: PUSH
5618: EMPTY
5619: LIST
5620: LIST
5621: PUSH
5622: LD_INT 25
5624: PUSH
5625: LD_INT 4
5627: PUSH
5628: EMPTY
5629: LIST
5630: LIST
5631: PUSH
5632: EMPTY
5633: LIST
5634: LIST
5635: PPUSH
5636: CALL_OW 69
5640: ST_TO_ADDR
// if not doc then
5641: LD_VAR 0 3
5645: NOT
5646: IFFALSE 5650
// exit ;
5648: GO 5795
// if not tmp then
5650: LD_VAR 0 2
5654: NOT
5655: IFFALSE 5746
// begin if not IsInUnit ( doc [ 1 ] ) then
5657: LD_VAR 0 3
5661: PUSH
5662: LD_INT 1
5664: ARRAY
5665: PPUSH
5666: CALL_OW 310
5670: NOT
5671: IFFALSE 5744
// ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
5673: LD_VAR 0 3
5677: PPUSH
5678: LD_INT 22
5680: PUSH
5681: LD_INT 3
5683: PUSH
5684: EMPTY
5685: LIST
5686: LIST
5687: PUSH
5688: LD_INT 2
5690: PUSH
5691: LD_INT 30
5693: PUSH
5694: LD_INT 6
5696: PUSH
5697: EMPTY
5698: LIST
5699: LIST
5700: PUSH
5701: LD_INT 30
5703: PUSH
5704: LD_INT 7
5706: PUSH
5707: EMPTY
5708: LIST
5709: LIST
5710: PUSH
5711: LD_INT 30
5713: PUSH
5714: LD_INT 8
5716: PUSH
5717: EMPTY
5718: LIST
5719: LIST
5720: PUSH
5721: EMPTY
5722: LIST
5723: LIST
5724: LIST
5725: LIST
5726: PUSH
5727: EMPTY
5728: LIST
5729: LIST
5730: PPUSH
5731: CALL_OW 69
5735: PUSH
5736: LD_INT 1
5738: ARRAY
5739: PPUSH
5740: CALL_OW 120
// exit ;
5744: GO 5795
// end ; if IsInUnit ( doc [ 1 ] ) then
5746: LD_VAR 0 3
5750: PUSH
5751: LD_INT 1
5753: ARRAY
5754: PPUSH
5755: CALL_OW 310
5759: IFFALSE 5770
// ComExitBuilding ( doc ) ;
5761: LD_VAR 0 3
5765: PPUSH
5766: CALL_OW 122
// wait ( 3 ) ;
5770: LD_INT 3
5772: PPUSH
5773: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
5777: LD_VAR 0 3
5781: PPUSH
5782: LD_VAR 0 2
5786: PUSH
5787: LD_INT 1
5789: ARRAY
5790: PPUSH
5791: CALL_OW 128
// end ;
5795: PPOPN 3
5797: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , tmp , areas , area ;
5798: LD_INT 22
5800: PUSH
5801: LD_INT 3
5803: PUSH
5804: EMPTY
5805: LIST
5806: LIST
5807: PUSH
5808: LD_INT 25
5810: PUSH
5811: LD_INT 3
5813: PUSH
5814: EMPTY
5815: LIST
5816: LIST
5817: PUSH
5818: EMPTY
5819: LIST
5820: LIST
5821: PPUSH
5822: CALL_OW 69
5826: PUSH
5827: LD_INT 22
5829: PUSH
5830: LD_INT 3
5832: PUSH
5833: EMPTY
5834: LIST
5835: LIST
5836: PUSH
5837: LD_INT 21
5839: PUSH
5840: LD_INT 2
5842: PUSH
5843: EMPTY
5844: LIST
5845: LIST
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: PPUSH
5851: CALL_OW 69
5855: AND
5856: IFFALSE 6078
5858: GO 5860
5860: DISABLE
5861: LD_INT 0
5863: PPUSH
5864: PPUSH
5865: PPUSH
5866: PPUSH
// begin enable ;
5867: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
5868: LD_ADDR_VAR 0 2
5872: PUSH
5873: LD_INT 22
5875: PUSH
5876: LD_INT 3
5878: PUSH
5879: EMPTY
5880: LIST
5881: LIST
5882: PUSH
5883: LD_INT 21
5885: PUSH
5886: LD_INT 2
5888: PUSH
5889: EMPTY
5890: LIST
5891: LIST
5892: PUSH
5893: LD_INT 3
5895: PUSH
5896: LD_INT 58
5898: PUSH
5899: EMPTY
5900: LIST
5901: PUSH
5902: EMPTY
5903: LIST
5904: LIST
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: LIST
5910: PPUSH
5911: CALL_OW 69
5915: ST_TO_ADDR
// areas := [ sectorAlpha , sectorBeta , sectorDelta , mainBaseArea ] ;
5916: LD_ADDR_VAR 0 3
5920: PUSH
5921: LD_INT 10
5923: PUSH
5924: LD_INT 11
5926: PUSH
5927: LD_INT 12
5929: PUSH
5930: LD_INT 14
5932: PUSH
5933: EMPTY
5934: LIST
5935: LIST
5936: LIST
5937: LIST
5938: ST_TO_ADDR
// area := 0 ;
5939: LD_ADDR_VAR 0 4
5943: PUSH
5944: LD_INT 0
5946: ST_TO_ADDR
// for i in areas do
5947: LD_ADDR_VAR 0 1
5951: PUSH
5952: LD_VAR 0 3
5956: PUSH
5957: FOR_IN
5958: IFFALSE 5995
// if FilterUnitsInArea ( i , [ f_side , 1 ] ) then
5960: LD_VAR 0 1
5964: PPUSH
5965: LD_INT 22
5967: PUSH
5968: LD_INT 1
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: PPUSH
5975: CALL_OW 70
5979: IFFALSE 5993
// begin area := i ;
5981: LD_ADDR_VAR 0 4
5985: PUSH
5986: LD_VAR 0 1
5990: ST_TO_ADDR
// break ;
5991: GO 5995
// end ;
5993: GO 5957
5995: POP
5996: POP
// if area then
5997: LD_VAR 0 4
6001: IFFALSE 6078
// begin for i in tmp do
6003: LD_ADDR_VAR 0 1
6007: PUSH
6008: LD_VAR 0 2
6012: PUSH
6013: FOR_IN
6014: IFFALSE 6076
// begin if GetFuel ( i ) < 33 then
6016: LD_VAR 0 1
6020: PPUSH
6021: CALL_OW 261
6025: PUSH
6026: LD_INT 33
6028: LESS
6029: IFFALSE 6043
// SetFuel ( i , 33 ) ;
6031: LD_VAR 0 1
6035: PPUSH
6036: LD_INT 33
6038: PPUSH
6039: CALL_OW 240
// if not IsInArea ( i , area ) then
6043: LD_VAR 0 1
6047: PPUSH
6048: LD_VAR 0 4
6052: PPUSH
6053: CALL_OW 308
6057: NOT
6058: IFFALSE 6074
// ComMoveToArea ( i , area ) ;
6060: LD_VAR 0 1
6064: PPUSH
6065: LD_VAR 0 4
6069: PPUSH
6070: CALL_OW 113
// end ;
6074: GO 6013
6076: POP
6077: POP
// end ; end ;
6078: PPOPN 4
6080: END
// every 10 10$00 do var i , j , veh , time , count ;
6081: GO 6083
6083: DISABLE
6084: LD_INT 0
6086: PPUSH
6087: PPUSH
6088: PPUSH
6089: PPUSH
6090: PPUSH
// begin uc_side := 3 ;
6091: LD_ADDR_OWVAR 20
6095: PUSH
6096: LD_INT 3
6098: ST_TO_ADDR
// uc_nation := 3 ;
6099: LD_ADDR_OWVAR 21
6103: PUSH
6104: LD_INT 3
6106: ST_TO_ADDR
// time := [ 6 6$00 , 5 5$00 , 4 4$00 ] [ Difficulty ] ;
6107: LD_ADDR_VAR 0 4
6111: PUSH
6112: LD_INT 12600
6114: PUSH
6115: LD_INT 10500
6117: PUSH
6118: LD_INT 8400
6120: PUSH
6121: EMPTY
6122: LIST
6123: LIST
6124: LIST
6125: PUSH
6126: LD_OWVAR 67
6130: ARRAY
6131: ST_TO_ADDR
// count := [ 3 , 4 , 5 ] [ Difficulty ] ;
6132: LD_ADDR_VAR 0 5
6136: PUSH
6137: LD_INT 3
6139: PUSH
6140: LD_INT 4
6142: PUSH
6143: LD_INT 5
6145: PUSH
6146: EMPTY
6147: LIST
6148: LIST
6149: LIST
6150: PUSH
6151: LD_OWVAR 67
6155: ARRAY
6156: ST_TO_ADDR
// for i = 1 to count do
6157: LD_ADDR_VAR 0 1
6161: PUSH
6162: DOUBLE
6163: LD_INT 1
6165: DEC
6166: ST_TO_ADDR
6167: LD_VAR 0 5
6171: PUSH
6172: FOR_TO
6173: IFFALSE 6353
// begin wait ( time ) ;
6175: LD_VAR 0 4
6179: PPUSH
6180: CALL_OW 67
// for j = 1 to rand ( 1 , Difficulty ) do
6184: LD_ADDR_VAR 0 2
6188: PUSH
6189: DOUBLE
6190: LD_INT 1
6192: DEC
6193: ST_TO_ADDR
6194: LD_INT 1
6196: PPUSH
6197: LD_OWVAR 67
6201: PPUSH
6202: CALL_OW 12
6206: PUSH
6207: FOR_TO
6208: IFFALSE 6349
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 80 ) ;
6210: LD_ADDR_VAR 0 3
6214: PUSH
6215: LD_INT 3
6217: PPUSH
6218: LD_INT 3
6220: PPUSH
6221: LD_INT 22
6223: PPUSH
6224: LD_INT 1
6226: PPUSH
6227: LD_INT 1
6229: PPUSH
6230: LD_INT 43
6232: PUSH
6233: LD_INT 44
6235: PUSH
6236: LD_INT 42
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: LIST
6243: PUSH
6244: LD_VAR 0 1
6248: PUSH
6249: LD_INT 3
6251: MOD
6252: PUSH
6253: LD_INT 1
6255: PLUS
6256: ARRAY
6257: PPUSH
6258: LD_INT 80
6260: PPUSH
6261: CALL 417 0 7
6265: ST_TO_ADDR
// PlaceUnitArea ( veh , southArea , false ) ;
6266: LD_VAR 0 3
6270: PPUSH
6271: LD_INT 13
6273: PPUSH
6274: LD_INT 0
6276: PPUSH
6277: CALL_OW 49
// PrepareHuman ( false , 1 , [ 4 , 5 , 5 ] [ Difficulty ] ) ;
6281: LD_INT 0
6283: PPUSH
6284: LD_INT 1
6286: PPUSH
6287: LD_INT 4
6289: PUSH
6290: LD_INT 5
6292: PUSH
6293: LD_INT 5
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: LIST
6300: PUSH
6301: LD_OWVAR 67
6305: ARRAY
6306: PPUSH
6307: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6311: CALL_OW 44
6315: PPUSH
6316: LD_VAR 0 3
6320: PPUSH
6321: CALL_OW 52
// wait ( 0 0$01 ) ;
6325: LD_INT 35
6327: PPUSH
6328: CALL_OW 67
// ComMoveXY ( veh , 143 , 143 ) ;
6332: LD_VAR 0 3
6336: PPUSH
6337: LD_INT 143
6339: PPUSH
6340: LD_INT 143
6342: PPUSH
6343: CALL_OW 111
// end ;
6347: GO 6207
6349: POP
6350: POP
// end ;
6351: GO 6172
6353: POP
6354: POP
// end ;
6355: PPOPN 5
6357: END
// every 4 4$00 do var i , un , time ;
6358: GO 6360
6360: DISABLE
6361: LD_INT 0
6363: PPUSH
6364: PPUSH
6365: PPUSH
// begin time := [ 2 2$00 , 1 1$00 , 0 0$30 ] ;
6366: LD_ADDR_VAR 0 3
6370: PUSH
6371: LD_INT 4200
6373: PUSH
6374: LD_INT 2100
6376: PUSH
6377: LD_INT 1050
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: LIST
6384: ST_TO_ADDR
// wait ( time ) ;
6385: LD_VAR 0 3
6389: PPUSH
6390: CALL_OW 67
// uc_side := 3 ;
6394: LD_ADDR_OWVAR 20
6398: PUSH
6399: LD_INT 3
6401: ST_TO_ADDR
// uc_nation := 3 ;
6402: LD_ADDR_OWVAR 21
6406: PUSH
6407: LD_INT 3
6409: ST_TO_ADDR
// for i = 1 to 2 do
6410: LD_ADDR_VAR 0 1
6414: PUSH
6415: DOUBLE
6416: LD_INT 1
6418: DEC
6419: ST_TO_ADDR
6420: LD_INT 2
6422: PUSH
6423: FOR_TO
6424: IFFALSE 6487
// begin PrepareHuman ( false , 1 , 4 ) ;
6426: LD_INT 0
6428: PPUSH
6429: LD_INT 1
6431: PPUSH
6432: LD_INT 4
6434: PPUSH
6435: CALL_OW 380
// un := CreateHuman ;
6439: LD_ADDR_VAR 0 2
6443: PUSH
6444: CALL_OW 44
6448: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_dep_main ) ;
6449: LD_VAR 0 2
6453: PPUSH
6454: LD_INT 16
6456: PPUSH
6457: CALL_OW 52
// ComExitBuilding ( un ) ;
6461: LD_VAR 0 2
6465: PPUSH
6466: CALL_OW 122
// AddComAgressiveMove ( un , 41 , 76 ) ;
6470: LD_VAR 0 2
6474: PPUSH
6475: LD_INT 41
6477: PPUSH
6478: LD_INT 76
6480: PPUSH
6481: CALL_OW 174
// end ;
6485: GO 6423
6487: POP
6488: POP
// end ; end_of_file
6489: PPOPN 3
6491: END
// export function Action ; begin
6492: LD_INT 0
6494: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
6495: LD_INT 28
6497: PPUSH
6498: LD_INT 3
6500: PPUSH
6501: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
6505: LD_INT 41
6507: PPUSH
6508: LD_INT 76
6510: PPUSH
6511: LD_INT 1
6513: PPUSH
6514: LD_INT 10
6516: PPUSH
6517: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
6521: LD_INT 41
6523: PPUSH
6524: LD_INT 76
6526: PPUSH
6527: LD_INT 1
6529: PPUSH
6530: CALL_OW 331
// InGameOn ;
6534: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
6538: LD_EXP 18
6542: PPUSH
6543: LD_STRING D2-Har-1
6545: PPUSH
6546: CALL_OW 94
// InGameOff ;
6550: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6554: LD_STRING M1
6556: PPUSH
6557: CALL_OW 337
// end ;
6561: LD_VAR 0 1
6565: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
6566: LD_EXP 4
6570: PUSH
6571: LD_INT 1
6573: GREATER
6574: IFFALSE 6665
6576: GO 6578
6578: DISABLE
6579: LD_INT 0
6581: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
6582: LD_ADDR_VAR 0 1
6586: PUSH
6587: LD_INT 1
6589: PPUSH
6590: CALL 505 0 1
6594: PUSH
6595: LD_INT 1
6597: ARRAY
6598: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
6599: LD_VAR 0 1
6603: PPUSH
6604: LD_STRING D2a-Sol1-1
6606: PPUSH
6607: CALL_OW 88
// if not un then
6611: LD_VAR 0 1
6615: NOT
6616: IFFALSE 6647
// begin un := GetRandom ( sex_female ) [ 1 ] ;
6618: LD_ADDR_VAR 0 1
6622: PUSH
6623: LD_INT 2
6625: PPUSH
6626: CALL 505 0 1
6630: PUSH
6631: LD_INT 1
6633: ARRAY
6634: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
6635: LD_VAR 0 1
6639: PPUSH
6640: LD_STRING D2a-FSol1-1
6642: PPUSH
6643: CALL_OW 88
// end ; if Khatam then
6647: LD_EXP 16
6651: IFFALSE 6665
// Say ( Khatam , D3b-Khat-3 ) ;
6653: LD_EXP 16
6657: PPUSH
6658: LD_STRING D3b-Khat-3
6660: PPUSH
6661: CALL_OW 88
// end ;
6665: PPOPN 1
6667: END
// every 0 0$1 trigger Frank and GetDistUnits ( JMM , Frank ) < 5 and not InBattle ( 1 ) do var i , ape ;
6668: LD_EXP 14
6672: PUSH
6673: LD_EXP 8
6677: PPUSH
6678: LD_EXP 14
6682: PPUSH
6683: CALL_OW 296
6687: PUSH
6688: LD_INT 5
6690: LESS
6691: AND
6692: PUSH
6693: LD_INT 1
6695: PPUSH
6696: CALL_OW 463
6700: NOT
6701: AND
6702: IFFALSE 7289
6704: GO 6706
6706: DISABLE
6707: LD_INT 0
6709: PPUSH
6710: PPUSH
// begin InGameOn ;
6711: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6715: LD_ADDR_VAR 0 2
6719: PUSH
6720: LD_INT 22
6722: PUSH
6723: LD_INT 0
6725: PUSH
6726: EMPTY
6727: LIST
6728: LIST
6729: PUSH
6730: LD_INT 25
6732: PUSH
6733: LD_INT 12
6735: PUSH
6736: EMPTY
6737: LIST
6738: LIST
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: PPUSH
6744: CALL_OW 69
6748: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
6749: LD_ADDR_VAR 0 2
6753: PUSH
6754: LD_VAR 0 2
6758: PPUSH
6759: LD_EXP 14
6763: PPUSH
6764: CALL_OW 74
6768: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
6769: LD_ADDR_VAR 0 1
6773: PUSH
6774: LD_INT 22
6776: PUSH
6777: LD_INT 1
6779: PUSH
6780: EMPTY
6781: LIST
6782: LIST
6783: PUSH
6784: LD_INT 21
6786: PUSH
6787: LD_INT 1
6789: PUSH
6790: EMPTY
6791: LIST
6792: LIST
6793: PUSH
6794: LD_INT 91
6796: PUSH
6797: LD_EXP 14
6801: PUSH
6802: LD_INT 20
6804: PUSH
6805: EMPTY
6806: LIST
6807: LIST
6808: LIST
6809: PUSH
6810: EMPTY
6811: LIST
6812: LIST
6813: LIST
6814: PPUSH
6815: CALL_OW 69
6819: PUSH
6820: FOR_IN
6821: IFFALSE 6839
// ComTurnUnit ( i , Frank ) ;
6823: LD_VAR 0 1
6827: PPUSH
6828: LD_EXP 14
6832: PPUSH
6833: CALL_OW 119
6837: GO 6820
6839: POP
6840: POP
// SetSide ( Frank , 1 ) ;
6841: LD_EXP 14
6845: PPUSH
6846: LD_INT 1
6848: PPUSH
6849: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
6853: LD_EXP 8
6857: PPUSH
6858: LD_EXP 14
6862: PPUSH
6863: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
6867: LD_EXP 8
6871: PPUSH
6872: LD_EXP 14
6876: PPUSH
6877: CALL_OW 179
// CenterOnUnits ( Frank ) ;
6881: LD_EXP 14
6885: PPUSH
6886: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
6890: LD_EXP 14
6894: PPUSH
6895: LD_STRING D3a-Frank-1
6897: PPUSH
6898: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
6902: LD_VAR 0 2
6906: PPUSH
6907: LD_INT 42
6909: PPUSH
6910: LD_INT 78
6912: PPUSH
6913: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
6917: LD_VAR 0 2
6921: PPUSH
6922: LD_EXP 14
6926: PPUSH
6927: CALL_OW 179
// if Lisa then
6931: LD_EXP 13
6935: IFFALSE 6949
// Say ( Lisa , D3a-Lisa-1 ) ;
6937: LD_EXP 13
6941: PPUSH
6942: LD_STRING D3a-Lisa-1
6944: PPUSH
6945: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
6949: LD_EXP 8
6953: PPUSH
6954: LD_STRING D3a-JMM-1
6956: PPUSH
6957: CALL_OW 88
// if Cyrus then
6961: LD_EXP 12
6965: IFFALSE 6979
// Say ( Cyrus , D3a-Cyrus-1 ) ;
6967: LD_EXP 12
6971: PPUSH
6972: LD_STRING D3a-Cyrus-1
6974: PPUSH
6975: CALL_OW 88
// if GetRandom ( sex_male ) then
6979: LD_INT 1
6981: PPUSH
6982: CALL 505 0 1
6986: IFFALSE 7007
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
6988: LD_INT 1
6990: PPUSH
6991: CALL 505 0 1
6995: PUSH
6996: LD_INT 1
6998: ARRAY
6999: PPUSH
7000: LD_STRING D3a-Sol1-1
7002: PPUSH
7003: CALL_OW 88
// if GetRandom ( sex_female ) then
7007: LD_INT 2
7009: PPUSH
7010: CALL 505 0 1
7014: IFFALSE 7035
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
7016: LD_INT 2
7018: PPUSH
7019: CALL 505 0 1
7023: PUSH
7024: LD_INT 1
7026: ARRAY
7027: PPUSH
7028: LD_STRING D3a-FSol1-1
7030: PPUSH
7031: CALL_OW 88
// if Gladstone then
7035: LD_EXP 15
7039: IFFALSE 7053
// Say ( Gladstone , D3a-Glad-1 ) ;
7041: LD_EXP 15
7045: PPUSH
7046: LD_STRING D3a-Glad-1
7048: PPUSH
7049: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
7053: LD_VAR 0 2
7057: PPUSH
7058: LD_INT 60
7060: PPUSH
7061: LD_INT 113
7063: PPUSH
7064: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
7068: LD_EXP 14
7072: PPUSH
7073: LD_STRING D3a-Frank-2
7075: PPUSH
7076: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
7080: LD_EXP 14
7084: PPUSH
7085: LD_EXP 8
7089: PPUSH
7090: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
7094: LD_EXP 8
7098: PPUSH
7099: LD_STRING D3a-JMM-2
7101: PPUSH
7102: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
7106: LD_INT 1
7108: PPUSH
7109: LD_INT 4
7111: PPUSH
7112: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
7116: LD_INT 85
7118: PPUSH
7119: LD_INT 134
7121: PPUSH
7122: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
7126: LD_EXP 14
7130: PPUSH
7131: LD_STRING D3a-Frank-3
7133: PPUSH
7134: CALL_OW 88
// Wait ( 0 0$01 ) ;
7138: LD_INT 35
7140: PPUSH
7141: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
7145: LD_INT 166
7147: PPUSH
7148: LD_INT 136
7150: PPUSH
7151: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
7155: LD_EXP 8
7159: PPUSH
7160: LD_STRING D3a-JMM-3
7162: PPUSH
7163: CALL_OW 88
// Wait ( 0 0$01 ) ;
7167: LD_INT 35
7169: PPUSH
7170: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
7174: LD_EXP 14
7178: PPUSH
7179: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
7183: LD_EXP 14
7187: PPUSH
7188: LD_STRING D3a-Frank-4
7190: PPUSH
7191: CALL_OW 88
// if Lisa then
7195: LD_EXP 13
7199: IFFALSE 7213
// Say ( Lisa , D3a-Lisa-4 ) ;
7201: LD_EXP 13
7205: PPUSH
7206: LD_STRING D3a-Lisa-4
7208: PPUSH
7209: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
7213: LD_EXP 8
7217: PPUSH
7218: LD_STRING D3a-JMM-4
7220: PPUSH
7221: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
7225: LD_EXP 14
7229: PPUSH
7230: LD_STRING D3a-Frank-5
7232: PPUSH
7233: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
7237: LD_EXP 8
7241: PPUSH
7242: LD_STRING D3a-JMM-5
7244: PPUSH
7245: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
7249: LD_EXP 14
7253: PPUSH
7254: LD_STRING D3a-Frank-6
7256: PPUSH
7257: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
7261: LD_EXP 8
7265: PPUSH
7266: LD_STRING D3a-JMM-6
7268: PPUSH
7269: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
7273: LD_EXP 14
7277: PPUSH
7278: LD_STRING D3a-Frank-7
7280: PPUSH
7281: CALL_OW 88
// InGameOff ;
7285: CALL_OW 9
// end ;
7289: PPOPN 2
7291: END
// every 0 0$1 trigger Kikuchi and GetDistUnits ( JMM , Kikuchi ) < 5 and not InBattle ( 1 ) do
7292: LD_EXP 17
7296: PUSH
7297: LD_EXP 8
7301: PPUSH
7302: LD_EXP 17
7306: PPUSH
7307: CALL_OW 296
7311: PUSH
7312: LD_INT 5
7314: LESS
7315: AND
7316: PUSH
7317: LD_INT 1
7319: PPUSH
7320: CALL_OW 463
7324: NOT
7325: AND
7326: IFFALSE 7506
7328: GO 7330
7330: DISABLE
// begin InGameOn ;
7331: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
7335: LD_EXP 8
7339: PPUSH
7340: LD_EXP 17
7344: PPUSH
7345: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
7349: LD_EXP 17
7353: PPUSH
7354: LD_EXP 8
7358: PPUSH
7359: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
7363: LD_EXP 17
7367: PPUSH
7368: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
7372: LD_EXP 17
7376: PPUSH
7377: LD_STRING D3b-Yam-1
7379: PPUSH
7380: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
7384: LD_EXP 8
7388: PPUSH
7389: LD_STRING D3b-JMM-1
7391: PPUSH
7392: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
7396: LD_INT 1
7398: PPUSH
7399: LD_INT 4
7401: PPUSH
7402: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
7406: LD_INT 85
7408: PPUSH
7409: LD_INT 134
7411: PPUSH
7412: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
7416: LD_EXP 17
7420: PPUSH
7421: LD_STRING D3b-Yam-2
7423: PPUSH
7424: CALL_OW 88
// Wait ( 0 0$01 ) ;
7428: LD_INT 35
7430: PPUSH
7431: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
7435: LD_EXP 8
7439: PPUSH
7440: LD_STRING D3b-JMM-2
7442: PPUSH
7443: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
7447: LD_INT 166
7449: PPUSH
7450: LD_INT 136
7452: PPUSH
7453: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
7457: LD_EXP 17
7461: PPUSH
7462: LD_STRING D3b-Yam-3
7464: PPUSH
7465: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
7469: LD_EXP 8
7473: PPUSH
7474: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
7478: LD_EXP 8
7482: PPUSH
7483: LD_STRING D3b-JMM-3a
7485: PPUSH
7486: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
7490: LD_EXP 17
7494: PPUSH
7495: LD_INT 1
7497: PPUSH
7498: CALL_OW 235
// InGameOff ;
7502: CALL_OW 9
// end ;
7506: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , i ;
7507: LD_INT 7
7509: PPUSH
7510: LD_INT 22
7512: PUSH
7513: LD_INT 1
7515: PUSH
7516: EMPTY
7517: LIST
7518: LIST
7519: PUSH
7520: LD_INT 3
7522: PUSH
7523: LD_INT 24
7525: PUSH
7526: LD_INT 1000
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: PUSH
7537: EMPTY
7538: LIST
7539: LIST
7540: PPUSH
7541: CALL_OW 70
7545: IFFALSE 7963
7547: GO 7549
7549: DISABLE
7550: LD_INT 0
7552: PPUSH
7553: PPUSH
7554: PPUSH
// begin un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) [ 1 ] ;
7555: LD_ADDR_VAR 0 1
7559: PUSH
7560: LD_INT 7
7562: PPUSH
7563: LD_INT 22
7565: PUSH
7566: LD_INT 1
7568: PUSH
7569: EMPTY
7570: LIST
7571: LIST
7572: PUSH
7573: LD_INT 3
7575: PUSH
7576: LD_INT 24
7578: PUSH
7579: LD_INT 1000
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: PUSH
7586: EMPTY
7587: LIST
7588: LIST
7589: PUSH
7590: EMPTY
7591: LIST
7592: LIST
7593: PPUSH
7594: CALL_OW 70
7598: PUSH
7599: LD_INT 1
7601: ARRAY
7602: ST_TO_ADDR
// DialogueOn ;
7603: CALL_OW 6
// CenterNowOnUnits ( un ) ;
7607: LD_VAR 0 1
7611: PPUSH
7612: CALL_OW 87
// if Lisa then
7616: LD_EXP 13
7620: IFFALSE 7648
// begin Say ( Lisa , D5-Lisa-1 ) ;
7622: LD_EXP 13
7626: PPUSH
7627: LD_STRING D5-Lisa-1
7629: PPUSH
7630: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
7634: LD_EXP 8
7638: PPUSH
7639: LD_STRING D5-JMM-1a
7641: PPUSH
7642: CALL_OW 88
// end else
7646: GO 7660
// Say ( JMM , D5-JMM-1 ) ;
7648: LD_EXP 8
7652: PPUSH
7653: LD_STRING D5-JMM-1
7655: PPUSH
7656: CALL_OW 88
// DialogueOff ;
7660: CALL_OW 7
// while ( true ) do
7664: LD_INT 1
7666: IFFALSE 7722
// begin wait ( 0 0$01 ) ;
7668: LD_INT 35
7670: PPUSH
7671: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
7675: LD_ADDR_VAR 0 2
7679: PUSH
7680: LD_INT 8
7682: PPUSH
7683: LD_INT 30
7685: PUSH
7686: LD_INT 26
7688: PUSH
7689: EMPTY
7690: LIST
7691: LIST
7692: PUSH
7693: LD_INT 101
7695: PUSH
7696: LD_INT 1
7698: PUSH
7699: EMPTY
7700: LIST
7701: LIST
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: PPUSH
7707: CALL_OW 71
7711: ST_TO_ADDR
// if x then
7712: LD_VAR 0 2
7716: IFFALSE 7720
// break ;
7718: GO 7722
// end ;
7720: GO 7664
// CenterOnUnits ( x [ 1 ] ) ;
7722: LD_VAR 0 2
7726: PUSH
7727: LD_INT 1
7729: ARRAY
7730: PPUSH
7731: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
7735: LD_EXP 14
7739: PUSH
7740: LD_EXP 14
7744: PPUSH
7745: CALL_OW 255
7749: PUSH
7750: LD_INT 1
7752: EQUAL
7753: AND
7754: IFFALSE 7770
// Say ( Frank , D5a-Frank-1 ) else
7756: LD_EXP 14
7760: PPUSH
7761: LD_STRING D5a-Frank-1
7763: PPUSH
7764: CALL_OW 88
7768: GO 7824
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
7770: LD_EXP 17
7774: PUSH
7775: LD_EXP 17
7779: PPUSH
7780: CALL_OW 255
7784: PUSH
7785: LD_INT 1
7787: EQUAL
7788: AND
7789: IFFALSE 7805
// Say ( Kikuchi , D5a-Yam-1 ) else
7791: LD_EXP 17
7795: PPUSH
7796: LD_STRING D5a-Yam-1
7798: PPUSH
7799: CALL_OW 88
7803: GO 7824
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
7805: LD_INT 1
7807: PPUSH
7808: CALL 505 0 1
7812: PUSH
7813: LD_INT 1
7815: ARRAY
7816: PPUSH
7817: LD_STRING D5a-Sol1-1
7819: PPUSH
7820: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
7824: LD_EXP 8
7828: PPUSH
7829: LD_STRING D5a-JMM-1
7831: PPUSH
7832: CALL_OW 88
// if Cyrus then
7836: LD_EXP 12
7840: IFFALSE 7854
// Say ( Cyrus , D5a-Cyrus-1 ) ;
7842: LD_EXP 12
7846: PPUSH
7847: LD_STRING D5a-Cyrus-1
7849: PPUSH
7850: CALL_OW 88
// x := false ;
7854: LD_ADDR_VAR 0 2
7858: PUSH
7859: LD_INT 0
7861: ST_TO_ADDR
// while ( true ) do
7862: LD_INT 1
7864: IFFALSE 7951
// begin wait ( 0 0$01 ) ;
7866: LD_INT 35
7868: PPUSH
7869: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
7873: LD_ADDR_VAR 0 3
7877: PUSH
7878: LD_INT 2
7880: PUSH
7881: LD_INT 30
7883: PUSH
7884: LD_INT 0
7886: PUSH
7887: EMPTY
7888: LIST
7889: LIST
7890: PUSH
7891: LD_INT 30
7893: PUSH
7894: LD_INT 1
7896: PUSH
7897: EMPTY
7898: LIST
7899: LIST
7900: PUSH
7901: EMPTY
7902: LIST
7903: LIST
7904: LIST
7905: PPUSH
7906: CALL_OW 69
7910: PUSH
7911: LD_INT 1
7913: DIFF
7914: PUSH
7915: FOR_IN
7916: IFFALSE 7939
// if BaseNeedEnergy ( i ) then
7918: LD_VAR 0 3
7922: PPUSH
7923: CALL 1162 0 1
7927: IFFALSE 7937
// x := true ;
7929: LD_ADDR_VAR 0 2
7933: PUSH
7934: LD_INT 1
7936: ST_TO_ADDR
7937: GO 7915
7939: POP
7940: POP
// if x then
7941: LD_VAR 0 2
7945: IFFALSE 7949
// break ;
7947: GO 7951
// end ;
7949: GO 7862
// Say ( JMM , D5b-JMM-1 ) ;
7951: LD_EXP 8
7955: PPUSH
7956: LD_STRING D5b-JMM-1
7958: PPUSH
7959: CALL_OW 88
// end ;
7963: PPOPN 3
7965: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
7966: LD_EXP 5
7970: PUSH
7971: LD_INT 1
7973: ARRAY
7974: PUSH
7975: LD_OWVAR 1
7979: LESS
7980: IFFALSE 8180
7982: GO 7984
7984: DISABLE
// begin if not IsDead ( ru_dep_main ) then
7985: LD_INT 16
7987: PPUSH
7988: CALL_OW 301
7992: NOT
7993: IFFALSE 8016
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
7995: LD_EXP 18
7999: PPUSH
8000: LD_STRING D3b-Har-3
8002: PPUSH
8003: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
8007: LD_STRING M2a
8009: PPUSH
8010: CALL_OW 337
// end else
8014: GO 8035
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
8016: LD_EXP 18
8020: PPUSH
8021: LD_STRING D3b-Har-3a
8023: PPUSH
8024: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
8028: LD_STRING M2
8030: PPUSH
8031: CALL_OW 337
// end ; can_end := true ;
8035: LD_ADDR_EXP 6
8039: PUSH
8040: LD_INT 1
8042: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
8043: LD_INT 9
8045: PPUSH
8046: LD_INT 1
8048: PPUSH
8049: CALL_OW 424
// Wait ( 0 0$02 ) ;
8053: LD_INT 70
8055: PPUSH
8056: CALL_OW 67
// if Lisa then
8060: LD_EXP 13
8064: IFFALSE 8078
// Say ( Lisa , D3b-Lisa ) ;
8066: LD_EXP 13
8070: PPUSH
8071: LD_STRING D3b-Lisa
8073: PPUSH
8074: CALL_OW 88
// if Bobby then
8078: LD_EXP 11
8082: IFFALSE 8096
// Say ( Bobby , D3b-Bobby-3 ) ;
8084: LD_EXP 11
8088: PPUSH
8089: LD_STRING D3b-Bobby-3
8091: PPUSH
8092: CALL_OW 88
// if Cyrus then
8096: LD_EXP 12
8100: IFFALSE 8114
// Say ( Cyrus , D3b-Cyrus-3 ) ;
8102: LD_EXP 12
8106: PPUSH
8107: LD_STRING D3b-Cyrus-3
8109: PPUSH
8110: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
8114: LD_EXP 14
8118: PUSH
8119: LD_EXP 14
8123: PPUSH
8124: CALL_OW 255
8128: PUSH
8129: LD_INT 1
8131: EQUAL
8132: AND
8133: IFFALSE 8147
// Say ( Frank , D3b-Frank-3 ) ;
8135: LD_EXP 14
8139: PPUSH
8140: LD_STRING D3b-Frank-3
8142: PPUSH
8143: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
8147: LD_EXP 17
8151: PUSH
8152: LD_EXP 17
8156: PPUSH
8157: CALL_OW 255
8161: PUSH
8162: LD_INT 1
8164: EQUAL
8165: AND
8166: IFFALSE 8180
// Say ( Kikuchi , D3b-Yam-4 ) ;
8168: LD_EXP 17
8172: PPUSH
8173: LD_STRING D3b-Yam-4
8175: PPUSH
8176: CALL_OW 88
// end ;
8180: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
8181: LD_EXP 5
8185: PUSH
8186: LD_INT 2
8188: ARRAY
8189: PUSH
8190: LD_OWVAR 1
8194: LESS
8195: IFFALSE 8227
8197: GO 8199
8199: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
8200: LD_EXP 18
8204: PPUSH
8205: LD_STRING D4-Har-1
8207: PPUSH
8208: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
8212: LD_STRING M3
8214: PPUSH
8215: CALL_OW 337
// must_end := true ;
8219: LD_ADDR_EXP 7
8223: PUSH
8224: LD_INT 1
8226: ST_TO_ADDR
// end ;
8227: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
8228: LD_EXP 5
8232: PUSH
8233: LD_INT 3
8235: ARRAY
8236: PUSH
8237: LD_OWVAR 1
8241: LESS
8242: IFFALSE 8273
8244: GO 8246
8246: DISABLE
// begin if not IsDead ( ru_dep_main ) then
8247: LD_INT 16
8249: PPUSH
8250: CALL_OW 301
8254: NOT
8255: IFFALSE 8266
// YouLost ( TimeOut1 ) else
8257: LD_STRING TimeOut1
8259: PPUSH
8260: CALL_OW 104
8264: GO 8273
// YouLost ( TimeOut2 ) ;
8266: LD_STRING TimeOut2
8268: PPUSH
8269: CALL_OW 104
// end ;
8273: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , i , tmp ;
8274: LD_EXP 8
8278: PPUSH
8279: LD_INT 9
8281: PPUSH
8282: CALL_OW 308
8286: PUSH
8287: LD_EXP 6
8291: AND
8292: IFFALSE 9277
8294: GO 8296
8296: DISABLE
8297: LD_INT 0
8299: PPUSH
8300: PPUSH
8301: PPUSH
// begin wait_on := false ;
8302: LD_ADDR_VAR 0 1
8306: PUSH
8307: LD_INT 0
8309: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
8310: LD_INT 1
8312: PPUSH
8313: CALL 1239 0 1
8317: PUSH
8318: LD_INT 0
8320: PLUS
8321: PUSH
8322: LD_INT 1
8324: PPUSH
8325: LD_INT 9
8327: PPUSH
8328: CALL 1330 0 2
8332: PUSH
8333: LD_INT 1
8335: PPUSH
8336: LD_INT 9
8338: PPUSH
8339: CALL 1377 0 2
8343: ADD
8344: PUSH
8345: LD_INT 0
8347: PLUS
8348: GREATER
8349: IFFALSE 8398
// case Query ( Q1 ) of 1 :
8351: LD_STRING Q1
8353: PPUSH
8354: CALL_OW 97
8358: PUSH
8359: LD_INT 1
8361: DOUBLE
8362: EQUAL
8363: IFTRUE 8367
8365: GO 8378
8367: POP
// wait_on := true ; 2 :
8368: LD_ADDR_VAR 0 1
8372: PUSH
8373: LD_INT 1
8375: ST_TO_ADDR
8376: GO 8398
8378: LD_INT 2
8380: DOUBLE
8381: EQUAL
8382: IFTRUE 8386
8384: GO 8397
8386: POP
// wait_on := false ; end ;
8387: LD_ADDR_VAR 0 1
8391: PUSH
8392: LD_INT 0
8394: ST_TO_ADDR
8395: GO 8398
8397: POP
// repeat wait ( 0 0$01 ) ;
8398: LD_INT 35
8400: PPUSH
8401: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
8405: LD_VAR 0 1
8409: NOT
8410: PUSH
8411: LD_INT 1
8413: PPUSH
8414: CALL 1239 0 1
8418: PUSH
8419: LD_INT 0
8421: PLUS
8422: PUSH
8423: LD_INT 1
8425: PPUSH
8426: LD_INT 9
8428: PPUSH
8429: CALL 1330 0 2
8433: PUSH
8434: LD_INT 1
8436: PPUSH
8437: LD_INT 9
8439: PPUSH
8440: CALL 1377 0 2
8444: ADD
8445: PUSH
8446: LD_INT 0
8448: PLUS
8449: EQUAL
8450: OR
8451: IFFALSE 8398
// DialogueOn ;
8453: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
8457: LD_EXP 8
8461: PPUSH
8462: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
8466: LD_EXP 8
8470: PPUSH
8471: LD_STRING D6-JMM-1
8473: PPUSH
8474: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
8478: LD_EXP 18
8482: PPUSH
8483: LD_STRING D6-Har-1
8485: PPUSH
8486: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
8490: LD_EXP 8
8494: PPUSH
8495: LD_STRING D6-JMM-2
8497: PPUSH
8498: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
8502: LD_EXP 18
8506: PPUSH
8507: LD_STRING D6-Har-2
8509: PPUSH
8510: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
8514: LD_EXP 8
8518: PPUSH
8519: LD_STRING D6-JMM-3
8521: PPUSH
8522: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
8526: LD_EXP 18
8530: PPUSH
8531: LD_STRING D6-Har-3
8533: PPUSH
8534: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
8538: LD_EXP 8
8542: PPUSH
8543: LD_STRING D6-JMM-4
8545: PPUSH
8546: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
8550: LD_EXP 18
8554: PPUSH
8555: LD_STRING D6-Har-4
8557: PPUSH
8558: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
8562: LD_EXP 8
8566: PPUSH
8567: LD_STRING D6-JMM-5
8569: PPUSH
8570: CALL_OW 88
// DialogueOff ;
8574: CALL_OW 7
// tmp := FilterBuildings ( 3 ) ;
8578: LD_ADDR_VAR 0 3
8582: PUSH
8583: LD_INT 3
8585: PPUSH
8586: CALL 1508 0 1
8590: ST_TO_ADDR
// if tmp >= 35 then
8591: LD_VAR 0 3
8595: PUSH
8596: LD_INT 35
8598: GREATEREQUAL
8599: IFFALSE 8636
// begin AddMedal ( Destroy1 , - 1 ) ;
8601: LD_STRING Destroy1
8603: PPUSH
8604: LD_INT 1
8606: NEG
8607: PPUSH
8608: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
8612: LD_STRING Destroy2
8614: PPUSH
8615: LD_INT 1
8617: NEG
8618: PPUSH
8619: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
8623: LD_STRING Destroy3
8625: PPUSH
8626: LD_INT 1
8628: NEG
8629: PPUSH
8630: CALL_OW 101
// end else
8634: GO 8723
// begin AddMedal ( Destroy1 , 1 ) ;
8636: LD_STRING Destroy1
8638: PPUSH
8639: LD_INT 1
8641: PPUSH
8642: CALL_OW 101
// if tmp >= 25 then
8646: LD_VAR 0 3
8650: PUSH
8651: LD_INT 25
8653: GREATEREQUAL
8654: IFFALSE 8680
// begin AddMedal ( Destroy2 , - 1 ) ;
8656: LD_STRING Destroy2
8658: PPUSH
8659: LD_INT 1
8661: NEG
8662: PPUSH
8663: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
8667: LD_STRING Destroy3
8669: PPUSH
8670: LD_INT 1
8672: NEG
8673: PPUSH
8674: CALL_OW 101
// end else
8678: GO 8723
// begin AddMedal ( Destroy2 , 1 ) ;
8680: LD_STRING Destroy2
8682: PPUSH
8683: LD_INT 1
8685: PPUSH
8686: CALL_OW 101
// if tmp >= 15 then
8690: LD_VAR 0 3
8694: PUSH
8695: LD_INT 15
8697: GREATEREQUAL
8698: IFFALSE 8713
// AddMedal ( Destroy3 , - 1 ) else
8700: LD_STRING Destroy3
8702: PPUSH
8703: LD_INT 1
8705: NEG
8706: PPUSH
8707: CALL_OW 101
8711: GO 8723
// AddMedal ( Destroy3 , 1 ) ;
8713: LD_STRING Destroy3
8715: PPUSH
8716: LD_INT 1
8718: PPUSH
8719: CALL_OW 101
// end ; end ; GiveMedals ( MAIN ) ;
8723: LD_STRING MAIN
8725: PPUSH
8726: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ;
8730: LD_ADDR_VAR 0 3
8734: PUSH
8735: LD_INT 1
8737: PPUSH
8738: LD_INT 9
8740: PPUSH
8741: CALL 1330 0 2
8745: PUSH
8746: LD_INT 1
8748: PPUSH
8749: LD_INT 9
8751: PPUSH
8752: CALL 1377 0 2
8756: ADD
8757: ST_TO_ADDR
// RewardPeople ( tmp ) ;
8758: LD_VAR 0 3
8762: PPUSH
8763: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
8767: LD_EXP 8
8771: PPUSH
8772: LD_EXP 3
8776: PUSH
8777: LD_STRING JMM
8779: STR
8780: PPUSH
8781: CALL_OW 38
// if Brown in tmp then
8785: LD_EXP 9
8789: PUSH
8790: LD_VAR 0 3
8794: IN
8795: IFFALSE 8815
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
8797: LD_EXP 9
8801: PPUSH
8802: LD_EXP 3
8806: PUSH
8807: LD_STRING Brown
8809: STR
8810: PPUSH
8811: CALL_OW 38
// if Donaldson in tmp then
8815: LD_EXP 10
8819: PUSH
8820: LD_VAR 0 3
8824: IN
8825: IFFALSE 8845
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
8827: LD_EXP 10
8831: PPUSH
8832: LD_EXP 3
8836: PUSH
8837: LD_STRING Donaldson
8839: STR
8840: PPUSH
8841: CALL_OW 38
// if Bobby in tmp then
8845: LD_EXP 11
8849: PUSH
8850: LD_VAR 0 3
8854: IN
8855: IFFALSE 8875
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
8857: LD_EXP 11
8861: PPUSH
8862: LD_EXP 3
8866: PUSH
8867: LD_STRING Bobby
8869: STR
8870: PPUSH
8871: CALL_OW 38
// if Cyrus in tmp then
8875: LD_EXP 12
8879: PUSH
8880: LD_VAR 0 3
8884: IN
8885: IFFALSE 8905
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
8887: LD_EXP 12
8891: PPUSH
8892: LD_EXP 3
8896: PUSH
8897: LD_STRING Cyrus
8899: STR
8900: PPUSH
8901: CALL_OW 38
// if Lisa in tmp then
8905: LD_EXP 13
8909: PUSH
8910: LD_VAR 0 3
8914: IN
8915: IFFALSE 8935
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
8917: LD_EXP 13
8921: PPUSH
8922: LD_EXP 3
8926: PUSH
8927: LD_STRING Lisa
8929: STR
8930: PPUSH
8931: CALL_OW 38
// if Frank in tmp then
8935: LD_EXP 14
8939: PUSH
8940: LD_VAR 0 3
8944: IN
8945: IFFALSE 8965
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
8947: LD_EXP 14
8951: PPUSH
8952: LD_EXP 3
8956: PUSH
8957: LD_STRING Frank
8959: STR
8960: PPUSH
8961: CALL_OW 38
// if Gladstone in tmp then
8965: LD_EXP 15
8969: PUSH
8970: LD_VAR 0 3
8974: IN
8975: IFFALSE 8995
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
8977: LD_EXP 15
8981: PPUSH
8982: LD_EXP 3
8986: PUSH
8987: LD_STRING Gladstone
8989: STR
8990: PPUSH
8991: CALL_OW 38
// if Khatam in tmp then
8995: LD_EXP 16
8999: PUSH
9000: LD_VAR 0 3
9004: IN
9005: IFFALSE 9025
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
9007: LD_EXP 16
9011: PPUSH
9012: LD_EXP 3
9016: PUSH
9017: LD_STRING Khatam
9019: STR
9020: PPUSH
9021: CALL_OW 38
// if Kikuchi in tmp then
9025: LD_EXP 17
9029: PUSH
9030: LD_VAR 0 3
9034: IN
9035: IFFALSE 9055
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
9037: LD_EXP 17
9041: PPUSH
9042: LD_EXP 3
9046: PUSH
9047: LD_STRING Kikuchi
9049: STR
9050: PPUSH
9051: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi ] , mission_prefix & others ) ;
9055: LD_VAR 0 3
9059: PUSH
9060: LD_EXP 8
9064: PUSH
9065: LD_EXP 9
9069: PUSH
9070: LD_EXP 10
9074: PUSH
9075: LD_EXP 11
9079: PUSH
9080: LD_EXP 12
9084: PUSH
9085: LD_EXP 13
9089: PUSH
9090: LD_EXP 14
9094: PUSH
9095: LD_EXP 15
9099: PUSH
9100: LD_EXP 17
9104: PUSH
9105: EMPTY
9106: LIST
9107: LIST
9108: LIST
9109: LIST
9110: LIST
9111: LIST
9112: LIST
9113: LIST
9114: LIST
9115: DIFF
9116: PPUSH
9117: LD_EXP 3
9121: PUSH
9122: LD_STRING others
9124: STR
9125: PPUSH
9126: CALL_OW 38
// SaveVariable ( tick , 07_time ) ;
9130: LD_OWVAR 1
9134: PPUSH
9135: LD_STRING 07_time
9137: PPUSH
9138: CALL_OW 39
// tmp := [ ] ;
9142: LD_ADDR_VAR 0 3
9146: PUSH
9147: EMPTY
9148: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ] ) do
9149: LD_ADDR_VAR 0 2
9153: PUSH
9154: LD_INT 22
9156: PUSH
9157: LD_INT 1
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PUSH
9164: LD_INT 23
9166: PUSH
9167: LD_INT 1
9169: PUSH
9170: EMPTY
9171: LIST
9172: LIST
9173: PUSH
9174: LD_INT 21
9176: PUSH
9177: LD_INT 2
9179: PUSH
9180: EMPTY
9181: LIST
9182: LIST
9183: PUSH
9184: EMPTY
9185: LIST
9186: LIST
9187: LIST
9188: PUSH
9189: EMPTY
9190: LIST
9191: PPUSH
9192: CALL_OW 69
9196: PUSH
9197: FOR_IN
9198: IFFALSE 9259
// tmp := tmp ^ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
9200: LD_ADDR_VAR 0 3
9204: PUSH
9205: LD_VAR 0 3
9209: PUSH
9210: LD_VAR 0 2
9214: PPUSH
9215: CALL_OW 265
9219: PUSH
9220: LD_VAR 0 2
9224: PPUSH
9225: CALL_OW 262
9229: PUSH
9230: LD_VAR 0 2
9234: PPUSH
9235: CALL_OW 263
9239: PUSH
9240: LD_VAR 0 2
9244: PPUSH
9245: CALL_OW 264
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: LIST
9254: LIST
9255: ADD
9256: ST_TO_ADDR
9257: GO 9197
9259: POP
9260: POP
// SaveVariable ( tmp , 07_vehicles ) ;
9261: LD_VAR 0 3
9265: PPUSH
9266: LD_STRING 07_vehicles
9268: PPUSH
9269: CALL_OW 39
// YouWin ;
9273: CALL_OW 103
// end ; end_of_file
9277: PPOPN 3
9279: END
// on UnitDestroyed ( un ) do begin if un = JMM then
9280: LD_VAR 0 1
9284: PUSH
9285: LD_EXP 8
9289: EQUAL
9290: IFFALSE 9299
// YouLost ( JMM ) ;
9292: LD_STRING JMM
9294: PPUSH
9295: CALL_OW 104
// if GetType ( un ) = unit_building then
9299: LD_VAR 0 1
9303: PPUSH
9304: CALL_OW 247
9308: PUSH
9309: LD_INT 3
9311: EQUAL
9312: IFFALSE 9328
// buildings_counter := buildings_counter + 1 ;
9314: LD_ADDR_EXP 4
9318: PUSH
9319: LD_EXP 4
9323: PUSH
9324: LD_INT 1
9326: PLUS
9327: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
9328: LD_VAR 0 1
9332: PUSH
9333: LD_INT 6
9335: PPUSH
9336: LD_INT 2
9338: PUSH
9339: LD_INT 30
9341: PUSH
9342: LD_INT 33
9344: PUSH
9345: EMPTY
9346: LIST
9347: LIST
9348: PUSH
9349: LD_INT 30
9351: PUSH
9352: LD_INT 32
9354: PUSH
9355: EMPTY
9356: LIST
9357: LIST
9358: PUSH
9359: EMPTY
9360: LIST
9361: LIST
9362: LIST
9363: PPUSH
9364: CALL_OW 70
9368: IN
9369: IFFALSE 9428
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
9371: LD_ADDR_EXP 19
9375: PUSH
9376: LD_EXP 19
9380: PUSH
9381: LD_VAR 0 1
9385: PPUSH
9386: CALL_OW 266
9390: PUSH
9391: LD_VAR 0 1
9395: PPUSH
9396: CALL_OW 250
9400: PUSH
9401: LD_VAR 0 1
9405: PPUSH
9406: CALL_OW 251
9410: PUSH
9411: LD_VAR 0 1
9415: PPUSH
9416: CALL_OW 254
9420: PUSH
9421: EMPTY
9422: LIST
9423: LIST
9424: LIST
9425: LIST
9426: ADD
9427: ST_TO_ADDR
// if un = ru_dep_main then
9428: LD_VAR 0 1
9432: PUSH
9433: LD_INT 16
9435: EQUAL
9436: IFFALSE 9445
// ChangeMissionObjectives ( M1a ) ;
9438: LD_STRING M1a
9440: PPUSH
9441: CALL_OW 337
// end ;
9445: PPOPN 1
9447: END
// on BuildingStarted ( b , builder ) do var i ;
9448: LD_INT 0
9450: PPUSH
// begin if GetSide ( b ) = 3 then
9451: LD_VAR 0 1
9455: PPUSH
9456: CALL_OW 255
9460: PUSH
9461: LD_INT 3
9463: EQUAL
9464: IFFALSE 9504
// for i = 1 to 4 do
9466: LD_ADDR_VAR 0 3
9470: PUSH
9471: DOUBLE
9472: LD_INT 1
9474: DEC
9475: ST_TO_ADDR
9476: LD_INT 4
9478: PUSH
9479: FOR_TO
9480: IFFALSE 9502
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
9482: LD_ADDR_EXP 19
9486: PUSH
9487: LD_EXP 19
9491: PPUSH
9492: LD_INT 1
9494: PPUSH
9495: CALL_OW 3
9499: ST_TO_ADDR
9500: GO 9479
9502: POP
9503: POP
// end ;
9504: PPOPN 3
9506: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
9507: LD_VAR 0 1
9511: PPUSH
9512: CALL_OW 266
9516: PUSH
9517: LD_INT 32
9519: PUSH
9520: LD_INT 33
9522: PUSH
9523: EMPTY
9524: LIST
9525: LIST
9526: IN
9527: IFFALSE 9541
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
9529: LD_VAR 0 1
9533: PPUSH
9534: LD_INT 43
9536: PPUSH
9537: CALL_OW 148
9541: PPOPN 1
9543: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
9544: LD_VAR 0 1
9548: PUSH
9549: LD_INT 22
9551: PUSH
9552: LD_INT 3
9554: PUSH
9555: EMPTY
9556: LIST
9557: LIST
9558: PUSH
9559: LD_INT 2
9561: PUSH
9562: LD_INT 30
9564: PUSH
9565: LD_INT 31
9567: PUSH
9568: EMPTY
9569: LIST
9570: LIST
9571: PUSH
9572: LD_INT 30
9574: PUSH
9575: LD_INT 32
9577: PUSH
9578: EMPTY
9579: LIST
9580: LIST
9581: PUSH
9582: EMPTY
9583: LIST
9584: LIST
9585: LIST
9586: PUSH
9587: EMPTY
9588: LIST
9589: LIST
9590: PPUSH
9591: CALL_OW 69
9595: IN
9596: IFFALSE 9618
// GoToAnotherTower ( un , b , 143 , 143 ) ;
9598: LD_VAR 0 2
9602: PPUSH
9603: LD_VAR 0 1
9607: PPUSH
9608: LD_INT 143
9610: PPUSH
9611: LD_INT 143
9613: PPUSH
9614: CALL 735 0 4
// end ;
9618: PPOPN 2
9620: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
9621: LD_VAR 0 1
9625: PUSH
9626: LD_INT 22
9628: PUSH
9629: LD_INT 3
9631: PUSH
9632: EMPTY
9633: LIST
9634: LIST
9635: PUSH
9636: LD_INT 30
9638: PUSH
9639: LD_INT 32
9641: PUSH
9642: EMPTY
9643: LIST
9644: LIST
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: PPUSH
9650: CALL_OW 69
9654: IN
9655: IFFALSE 9669
// SetTag ( b , 0 ) ;
9657: LD_VAR 0 1
9661: PPUSH
9662: LD_INT 0
9664: PPUSH
9665: CALL_OW 109
// end ;
9669: PPOPN 2
9671: END
