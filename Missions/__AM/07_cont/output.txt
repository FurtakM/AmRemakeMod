// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 25 0 0
// DebugMode ;
  12: CALL 143 0 0
// PrepareRussians ;
  16: CALL 2213 0 0
// PrepareAmericans ;
  20: CALL 1168 0 0
// end ;
  24: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end ; function Init ; begin
  25: LD_INT 0
  27: PPUSH
// debug := 1 ;
  28: LD_ADDR_EXP 1
  32: PUSH
  33: LD_INT 1
  35: ST_TO_ADDR
// mission_prefix := 07c_ ;
  36: LD_ADDR_EXP 3
  40: PUSH
  41: LD_STRING 07c_
  43: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  44: LD_ADDR_EXP 2
  48: PUSH
  49: LD_STRING 07_
  51: ST_TO_ADDR
// buildings_counter := 0 ;
  52: LD_ADDR_EXP 4
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// time_to_end := [ [ 27 27$00 , 24 24$00 , 21 21$00 ] [ Difficulty ] , [ 35 35$00 , 32 32$00 , 29 29$00 ] [ Difficulty ] , [ 38 38$00 , 35 35$00 , 32 32$00 ] [ Difficulty ] ] ;
  60: LD_ADDR_EXP 5
  64: PUSH
  65: LD_INT 56700
  67: PUSH
  68: LD_INT 50400
  70: PUSH
  71: LD_INT 44100
  73: PUSH
  74: EMPTY
  75: LIST
  76: LIST
  77: LIST
  78: PUSH
  79: LD_OWVAR 67
  83: ARRAY
  84: PUSH
  85: LD_INT 73500
  87: PUSH
  88: LD_INT 67200
  90: PUSH
  91: LD_INT 60900
  93: PUSH
  94: EMPTY
  95: LIST
  96: LIST
  97: LIST
  98: PUSH
  99: LD_OWVAR 67
 103: ARRAY
 104: PUSH
 105: LD_INT 79800
 107: PUSH
 108: LD_INT 73500
 110: PUSH
 111: LD_INT 67200
 113: PUSH
 114: EMPTY
 115: LIST
 116: LIST
 117: LIST
 118: PUSH
 119: LD_OWVAR 67
 123: ARRAY
 124: PUSH
 125: EMPTY
 126: LIST
 127: LIST
 128: LIST
 129: ST_TO_ADDR
// can_end := false ;
 130: LD_ADDR_EXP 6
 134: PUSH
 135: LD_INT 0
 137: ST_TO_ADDR
// end ;
 138: LD_VAR 0 1
 142: RET
// function DebugMode ; begin
 143: LD_INT 0
 145: PPUSH
// if not debug then
 146: LD_EXP 1
 150: NOT
 151: IFFALSE 155
// exit ;
 153: GO 162
// FogOff ( 1 ) ;
 155: LD_INT 1
 157: PPUSH
 158: CALL_OW 344
// end ;
 162: LD_VAR 0 1
 166: RET
// every 0 0$10 do
 167: GO 169
 169: DISABLE
// begin can_end := true ;
 170: LD_ADDR_EXP 6
 174: PUSH
 175: LD_INT 1
 177: ST_TO_ADDR
// display_strings := CAN END ;
 178: LD_ADDR_OWVAR 47
 182: PUSH
 183: LD_STRING CAN END
 185: ST_TO_ADDR
// end ;
 186: END
// every 3 trigger debug do var i , filter ;
 187: LD_EXP 1
 191: IFFALSE 280
 193: GO 195
 195: DISABLE
 196: LD_INT 0
 198: PPUSH
 199: PPUSH
// begin enable ;
 200: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 201: LD_ADDR_VAR 0 2
 205: PUSH
 206: LD_INT 22
 208: PUSH
 209: LD_INT 1
 211: PUSH
 212: EMPTY
 213: LIST
 214: LIST
 215: PUSH
 216: LD_INT 3
 218: PUSH
 219: LD_INT 24
 221: PUSH
 222: LD_INT 500
 224: PUSH
 225: EMPTY
 226: LIST
 227: LIST
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: PPUSH
 237: CALL_OW 69
 241: ST_TO_ADDR
// if not filter then
 242: LD_VAR 0 2
 246: NOT
 247: IFFALSE 251
// exit ;
 249: GO 280
// for i in filter do
 251: LD_ADDR_VAR 0 1
 255: PUSH
 256: LD_VAR 0 2
 260: PUSH
 261: FOR_IN
 262: IFFALSE 278
// SetLives ( i , 1000 ) ;
 264: LD_VAR 0 1
 268: PPUSH
 269: LD_INT 1000
 271: PPUSH
 272: CALL_OW 234
 276: GO 261
 278: POP
 279: POP
// end ; end_of_file
 280: PPOPN 2
 282: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 283: LD_INT 0
 285: PPUSH
 286: PPUSH
// if exist_mode then
 287: LD_VAR 0 2
 291: IFFALSE 316
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 293: LD_ADDR_VAR 0 4
 297: PUSH
 298: LD_EXP 2
 302: PUSH
 303: LD_VAR 0 1
 307: STR
 308: PPUSH
 309: CALL_OW 34
 313: ST_TO_ADDR
 314: GO 331
// unit := NewCharacter ( ident ) ;
 316: LD_ADDR_VAR 0 4
 320: PUSH
 321: LD_VAR 0 1
 325: PPUSH
 326: CALL_OW 25
 330: ST_TO_ADDR
// result := unit ;
 331: LD_ADDR_VAR 0 3
 335: PUSH
 336: LD_VAR 0 4
 340: ST_TO_ADDR
// end ;
 341: LD_VAR 0 3
 345: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 346: LD_INT 0
 348: PPUSH
// uc_side := side ;
 349: LD_ADDR_OWVAR 20
 353: PUSH
 354: LD_VAR 0 1
 358: ST_TO_ADDR
// uc_nation := nation ;
 359: LD_ADDR_OWVAR 21
 363: PUSH
 364: LD_VAR 0 2
 368: ST_TO_ADDR
// vc_chassis := chassis ;
 369: LD_ADDR_OWVAR 37
 373: PUSH
 374: LD_VAR 0 3
 378: ST_TO_ADDR
// vc_engine := engine ;
 379: LD_ADDR_OWVAR 39
 383: PUSH
 384: LD_VAR 0 4
 388: ST_TO_ADDR
// vc_control := control ;
 389: LD_ADDR_OWVAR 38
 393: PUSH
 394: LD_VAR 0 5
 398: ST_TO_ADDR
// vc_weapon := weapon ;
 399: LD_ADDR_OWVAR 40
 403: PUSH
 404: LD_VAR 0 6
 408: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 409: LD_ADDR_OWVAR 41
 413: PUSH
 414: LD_VAR 0 7
 418: ST_TO_ADDR
// result := CreateVehicle ;
 419: LD_ADDR_VAR 0 8
 423: PUSH
 424: CALL_OW 45
 428: ST_TO_ADDR
// end ;
 429: LD_VAR 0 8
 433: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 434: LD_INT 0
 436: PPUSH
 437: PPUSH
 438: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 439: LD_ADDR_VAR 0 4
 443: PUSH
 444: LD_INT 22
 446: PUSH
 447: LD_INT 1
 449: PUSH
 450: EMPTY
 451: LIST
 452: LIST
 453: PUSH
 454: LD_INT 21
 456: PUSH
 457: LD_INT 1
 459: PUSH
 460: EMPTY
 461: LIST
 462: LIST
 463: PUSH
 464: LD_INT 50
 466: PUSH
 467: EMPTY
 468: LIST
 469: PUSH
 470: EMPTY
 471: LIST
 472: LIST
 473: LIST
 474: PPUSH
 475: CALL_OW 69
 479: PUSH
 480: LD_EXP 7
 484: PUSH
 485: LD_EXP 8
 489: PUSH
 490: LD_EXP 9
 494: PUSH
 495: LD_EXP 10
 499: PUSH
 500: LD_EXP 11
 504: PUSH
 505: LD_EXP 12
 509: PUSH
 510: LD_EXP 13
 514: PUSH
 515: LD_EXP 14
 519: PUSH
 520: LD_EXP 16
 524: PUSH
 525: LD_EXP 15
 529: PUSH
 530: EMPTY
 531: LIST
 532: LIST
 533: LIST
 534: LIST
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: LIST
 540: LIST
 541: DIFF
 542: ST_TO_ADDR
// if not filter then
 543: LD_VAR 0 4
 547: NOT
 548: IFFALSE 552
// exit ;
 550: GO 579
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 552: LD_ADDR_VAR 0 2
 556: PUSH
 557: LD_VAR 0 4
 561: PPUSH
 562: LD_INT 26
 564: PUSH
 565: LD_VAR 0 1
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: PPUSH
 574: CALL_OW 72
 578: ST_TO_ADDR
// end ;
 579: LD_VAR 0 2
 583: RET
// export function SayX ( units , ident ) ; var i ; begin
 584: LD_INT 0
 586: PPUSH
 587: PPUSH
// result := false ;
 588: LD_ADDR_VAR 0 3
 592: PUSH
 593: LD_INT 0
 595: ST_TO_ADDR
// if not units then
 596: LD_VAR 0 1
 600: NOT
 601: IFFALSE 605
// exit ;
 603: GO 659
// for i in units do
 605: LD_ADDR_VAR 0 4
 609: PUSH
 610: LD_VAR 0 1
 614: PUSH
 615: FOR_IN
 616: IFFALSE 657
// if IsOk ( i ) then
 618: LD_VAR 0 4
 622: PPUSH
 623: CALL_OW 302
 627: IFFALSE 655
// begin Say ( i , ident ) ;
 629: LD_VAR 0 4
 633: PPUSH
 634: LD_VAR 0 2
 638: PPUSH
 639: CALL_OW 88
// result := i ;
 643: LD_ADDR_VAR 0 3
 647: PUSH
 648: LD_VAR 0 4
 652: ST_TO_ADDR
// break ;
 653: GO 657
// end ;
 655: GO 615
 657: POP
 658: POP
// end ;
 659: LD_VAR 0 3
 663: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
 664: LD_INT 0
 666: PPUSH
 667: PPUSH
 668: PPUSH
 669: PPUSH
 670: PPUSH
// if not un or not IsOk ( un ) then
 671: LD_VAR 0 1
 675: NOT
 676: PUSH
 677: LD_VAR 0 1
 681: PPUSH
 682: CALL_OW 302
 686: NOT
 687: OR
 688: IFFALSE 692
// exit ;
 690: GO 1086
// side := GetSide ( un ) ;
 692: LD_ADDR_VAR 0 9
 696: PUSH
 697: LD_VAR 0 1
 701: PPUSH
 702: CALL_OW 255
 706: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
 707: LD_ADDR_VAR 0 7
 711: PUSH
 712: LD_INT 22
 714: PUSH
 715: LD_VAR 0 9
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: PUSH
 724: LD_INT 30
 726: PUSH
 727: LD_INT 32
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: PUSH
 734: LD_INT 50
 736: PUSH
 737: EMPTY
 738: LIST
 739: PUSH
 740: LD_INT 58
 742: PUSH
 743: EMPTY
 744: LIST
 745: PUSH
 746: EMPTY
 747: LIST
 748: LIST
 749: LIST
 750: LIST
 751: PPUSH
 752: CALL_OW 69
 756: PUSH
 757: LD_VAR 0 2
 761: DIFF
 762: ST_TO_ADDR
// if not filter then
 763: LD_VAR 0 7
 767: NOT
 768: IFFALSE 951
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
 770: LD_ADDR_VAR 0 7
 774: PUSH
 775: LD_INT 22
 777: PUSH
 778: LD_VAR 0 9
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: PUSH
 787: LD_INT 30
 789: PUSH
 790: LD_INT 5
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: PUSH
 797: EMPTY
 798: LIST
 799: LIST
 800: PPUSH
 801: CALL_OW 69
 805: ST_TO_ADDR
// if not filter then
 806: LD_VAR 0 7
 810: NOT
 811: IFFALSE 834
// begin ComMoveXY ( un , x , y ) ;
 813: LD_VAR 0 1
 817: PPUSH
 818: LD_VAR 0 3
 822: PPUSH
 823: LD_VAR 0 4
 827: PPUSH
 828: CALL_OW 111
// exit ;
 832: GO 1086
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
 834: LD_ADDR_VAR 0 8
 838: PUSH
 839: LD_VAR 0 7
 843: PPUSH
 844: LD_VAR 0 1
 848: PPUSH
 849: CALL_OW 74
 853: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
 854: LD_VAR 0 8
 858: PPUSH
 859: CALL_OW 313
 863: PUSH
 864: LD_INT 6
 866: EQUAL
 867: IFFALSE 885
// filter := filter diff t ;
 869: LD_ADDR_VAR 0 7
 873: PUSH
 874: LD_VAR 0 7
 878: PUSH
 879: LD_VAR 0 8
 883: DIFF
 884: ST_TO_ADDR
// until UnitsInside ( t ) < 6 or not filter ;
 885: LD_VAR 0 8
 889: PPUSH
 890: CALL_OW 313
 894: PUSH
 895: LD_INT 6
 897: LESS
 898: PUSH
 899: LD_VAR 0 7
 903: NOT
 904: OR
 905: IFFALSE 834
// if not filter then
 907: LD_VAR 0 7
 911: NOT
 912: IFFALSE 935
// ComMoveXY ( un , x , y ) else
 914: LD_VAR 0 1
 918: PPUSH
 919: LD_VAR 0 3
 923: PPUSH
 924: LD_VAR 0 4
 928: PPUSH
 929: CALL_OW 111
 933: GO 949
// ComEnterUnit ( un , t ) ;
 935: LD_VAR 0 1
 939: PPUSH
 940: LD_VAR 0 8
 944: PPUSH
 945: CALL_OW 120
// end else
 949: GO 1086
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
 951: LD_ADDR_VAR 0 8
 955: PUSH
 956: LD_VAR 0 7
 960: PPUSH
 961: LD_VAR 0 1
 965: PPUSH
 966: CALL_OW 74
 970: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
 971: LD_VAR 0 8
 975: PPUSH
 976: CALL_OW 110
 980: PUSH
 981: LD_INT 7
 983: EQUAL
 984: IFFALSE 1002
// filter := filter diff t ;
 986: LD_ADDR_VAR 0 7
 990: PUSH
 991: LD_VAR 0 7
 995: PUSH
 996: LD_VAR 0 8
1000: DIFF
1001: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
1002: LD_VAR 0 8
1006: PPUSH
1007: CALL_OW 110
1011: PUSH
1012: LD_INT 7
1014: NONEQUAL
1015: PUSH
1016: LD_VAR 0 7
1020: NOT
1021: OR
1022: IFFALSE 951
// if GetTag ( t ) <> 7 then
1024: LD_VAR 0 8
1028: PPUSH
1029: CALL_OW 110
1033: PUSH
1034: LD_INT 7
1036: NONEQUAL
1037: IFFALSE 1067
// begin SetTag ( t , 7 ) ;
1039: LD_VAR 0 8
1043: PPUSH
1044: LD_INT 7
1046: PPUSH
1047: CALL_OW 109
// ComEnterUnit ( un , t ) ;
1051: LD_VAR 0 1
1055: PPUSH
1056: LD_VAR 0 8
1060: PPUSH
1061: CALL_OW 120
// end else
1065: GO 1086
// ComMoveXY ( un , x , y ) ;
1067: LD_VAR 0 1
1071: PPUSH
1072: LD_VAR 0 3
1076: PPUSH
1077: LD_VAR 0 4
1081: PPUSH
1082: CALL_OW 111
// end ; end ;
1086: LD_VAR 0 5
1090: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
1091: LD_INT 0
1093: PPUSH
1094: PPUSH
1095: PPUSH
// if not base then
1096: LD_VAR 0 1
1100: NOT
1101: IFFALSE 1105
// exit ;
1103: GO 1163
// tmp := GetEnergy ( GetBase ( base ) ) ;
1105: LD_ADDR_VAR 0 4
1109: PUSH
1110: LD_VAR 0 1
1114: PPUSH
1115: CALL_OW 274
1119: PPUSH
1120: CALL_OW 278
1124: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
1125: LD_VAR 0 4
1129: PUSH
1130: LD_INT 1
1132: ARRAY
1133: PUSH
1134: LD_VAR 0 4
1138: PUSH
1139: LD_INT 4
1141: ARRAY
1142: GREATER
1143: IFFALSE 1155
// result := true else
1145: LD_ADDR_VAR 0 2
1149: PUSH
1150: LD_INT 1
1152: ST_TO_ADDR
1153: GO 1163
// result := false ;
1155: LD_ADDR_VAR 0 2
1159: PUSH
1160: LD_INT 0
1162: ST_TO_ADDR
// end ; end_of_file
1163: LD_VAR 0 2
1167: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
1168: LD_INT 0
1170: PPUSH
1171: PPUSH
1172: PPUSH
1173: PPUSH
1174: PPUSH
1175: PPUSH
// uc_side := 1 ;
1176: LD_ADDR_OWVAR 20
1180: PUSH
1181: LD_INT 1
1183: ST_TO_ADDR
// uc_nation := 1 ;
1184: LD_ADDR_OWVAR 21
1188: PUSH
1189: LD_INT 1
1191: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1192: LD_ADDR_EXP 7
1196: PUSH
1197: LD_STRING JMM
1199: PPUSH
1200: LD_EXP 1
1204: NOT
1205: PPUSH
1206: CALL 283 0 2
1210: ST_TO_ADDR
// team := [ JMM ] ;
1211: LD_ADDR_VAR 0 3
1215: PUSH
1216: LD_EXP 7
1220: PUSH
1221: EMPTY
1222: LIST
1223: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
1224: LD_STRING BrownIn07
1226: PPUSH
1227: LD_EXP 1
1231: PPUSH
1232: CALL_OW 30
1236: IFFALSE 1257
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1238: LD_ADDR_EXP 8
1242: PUSH
1243: LD_STRING Brown
1245: PPUSH
1246: LD_EXP 1
1250: NOT
1251: PPUSH
1252: CALL 283 0 2
1256: ST_TO_ADDR
// if Brown then
1257: LD_EXP 8
1261: IFFALSE 1279
// team := team ^ Brown ;
1263: LD_ADDR_VAR 0 3
1267: PUSH
1268: LD_VAR 0 3
1272: PUSH
1273: LD_EXP 8
1277: ADD
1278: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
1279: LD_STRING DonaldsonIn07
1281: PPUSH
1282: LD_EXP 1
1286: PPUSH
1287: CALL_OW 30
1291: IFFALSE 1312
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1293: LD_ADDR_EXP 9
1297: PUSH
1298: LD_STRING Donaldson
1300: PPUSH
1301: LD_EXP 1
1305: NOT
1306: PPUSH
1307: CALL 283 0 2
1311: ST_TO_ADDR
// if Donaldson then
1312: LD_EXP 9
1316: IFFALSE 1334
// team := team ^ Donaldson ;
1318: LD_ADDR_VAR 0 3
1322: PUSH
1323: LD_VAR 0 3
1327: PUSH
1328: LD_EXP 9
1332: ADD
1333: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
1334: LD_STRING BobbyIn07
1336: PPUSH
1337: LD_EXP 1
1341: PPUSH
1342: CALL_OW 30
1346: IFFALSE 1367
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1348: LD_ADDR_EXP 10
1352: PUSH
1353: LD_STRING Bobby
1355: PPUSH
1356: LD_EXP 1
1360: NOT
1361: PPUSH
1362: CALL 283 0 2
1366: ST_TO_ADDR
// if Bobby then
1367: LD_EXP 10
1371: IFFALSE 1389
// team := team ^ Bobby ;
1373: LD_ADDR_VAR 0 3
1377: PUSH
1378: LD_VAR 0 3
1382: PUSH
1383: LD_EXP 10
1387: ADD
1388: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
1389: LD_STRING CyrusIn07
1391: PPUSH
1392: LD_EXP 1
1396: PPUSH
1397: CALL_OW 30
1401: IFFALSE 1422
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1403: LD_ADDR_EXP 11
1407: PUSH
1408: LD_STRING Cyrus
1410: PPUSH
1411: LD_EXP 1
1415: NOT
1416: PPUSH
1417: CALL 283 0 2
1421: ST_TO_ADDR
// if Cyrus then
1422: LD_EXP 11
1426: IFFALSE 1444
// team := team ^ Cyrus ;
1428: LD_ADDR_VAR 0 3
1432: PUSH
1433: LD_VAR 0 3
1437: PUSH
1438: LD_EXP 11
1442: ADD
1443: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
1444: LD_STRING LisaIn07
1446: PPUSH
1447: LD_EXP 1
1451: PPUSH
1452: CALL_OW 30
1456: IFFALSE 1477
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1458: LD_ADDR_EXP 12
1462: PUSH
1463: LD_STRING Lisa
1465: PPUSH
1466: LD_EXP 1
1470: NOT
1471: PPUSH
1472: CALL 283 0 2
1476: ST_TO_ADDR
// if Lisa then
1477: LD_EXP 12
1481: IFFALSE 1499
// team := team ^ Lisa ;
1483: LD_ADDR_VAR 0 3
1487: PUSH
1488: LD_VAR 0 3
1492: PUSH
1493: LD_EXP 12
1497: ADD
1498: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
1499: LD_STRING GladstoneIn07
1501: PPUSH
1502: LD_EXP 1
1506: PPUSH
1507: CALL_OW 30
1511: IFFALSE 1532
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
1513: LD_ADDR_EXP 14
1517: PUSH
1518: LD_STRING Gladstone
1520: PPUSH
1521: LD_EXP 1
1525: NOT
1526: PPUSH
1527: CALL 283 0 2
1531: ST_TO_ADDR
// if Gladstone then
1532: LD_EXP 14
1536: IFFALSE 1554
// team := team ^ Gladstone ;
1538: LD_ADDR_VAR 0 3
1542: PUSH
1543: LD_VAR 0 3
1547: PUSH
1548: LD_EXP 14
1552: ADD
1553: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
1554: LD_STRING KhatamIn07
1556: PPUSH
1557: LD_EXP 1
1561: PPUSH
1562: CALL_OW 30
1566: IFFALSE 1587
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1568: LD_ADDR_EXP 15
1572: PUSH
1573: LD_STRING Khatam
1575: PPUSH
1576: LD_EXP 1
1580: NOT
1581: PPUSH
1582: CALL 283 0 2
1586: ST_TO_ADDR
// if Khatam then
1587: LD_EXP 15
1591: IFFALSE 1609
// team := team ^ Khatam ;
1593: LD_ADDR_VAR 0 3
1597: PUSH
1598: LD_VAR 0 3
1602: PUSH
1603: LD_EXP 15
1607: ADD
1608: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
1609: LD_ADDR_VAR 0 4
1613: PUSH
1614: LD_STRING 07_others
1616: PPUSH
1617: CALL_OW 31
1621: ST_TO_ADDR
// if others then
1622: LD_VAR 0 4
1626: IFFALSE 1644
// team := team ^ others ;
1628: LD_ADDR_VAR 0 3
1632: PUSH
1633: LD_VAR 0 3
1637: PUSH
1638: LD_VAR 0 4
1642: ADD
1643: ST_TO_ADDR
// if debug then
1644: LD_EXP 1
1648: IFFALSE 1722
// begin InitHc ;
1650: CALL_OW 19
// for i = 1 to 4 do
1654: LD_ADDR_VAR 0 2
1658: PUSH
1659: DOUBLE
1660: LD_INT 1
1662: DEC
1663: ST_TO_ADDR
1664: LD_INT 4
1666: PUSH
1667: FOR_TO
1668: IFFALSE 1720
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
1670: LD_INT 0
1672: PPUSH
1673: LD_INT 1
1675: PUSH
1676: LD_INT 3
1678: PUSH
1679: EMPTY
1680: LIST
1681: LIST
1682: PUSH
1683: LD_INT 1
1685: PPUSH
1686: LD_INT 2
1688: PPUSH
1689: CALL_OW 12
1693: ARRAY
1694: PPUSH
1695: LD_INT 4
1697: PPUSH
1698: CALL_OW 380
// team := team ^ CreateHuman ;
1702: LD_ADDR_VAR 0 3
1706: PUSH
1707: LD_VAR 0 3
1711: PUSH
1712: CALL_OW 44
1716: ADD
1717: ST_TO_ADDR
// end ;
1718: GO 1667
1720: POP
1721: POP
// end ; m := 0 ;
1722: LD_ADDR_VAR 0 6
1726: PUSH
1727: LD_INT 0
1729: ST_TO_ADDR
// for i in team do
1730: LD_ADDR_VAR 0 2
1734: PUSH
1735: LD_VAR 0 3
1739: PUSH
1740: FOR_IN
1741: IFFALSE 1921
// if GetClass ( i ) = 3 then
1743: LD_VAR 0 2
1747: PPUSH
1748: CALL_OW 257
1752: PUSH
1753: LD_INT 3
1755: EQUAL
1756: IFFALSE 1904
// begin m := m + 1 ;
1758: LD_ADDR_VAR 0 6
1762: PUSH
1763: LD_VAR 0 6
1767: PUSH
1768: LD_INT 1
1770: PLUS
1771: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
1772: LD_ADDR_VAR 0 5
1776: PUSH
1777: LD_INT 1
1779: PPUSH
1780: LD_INT 1
1782: PPUSH
1783: LD_INT 2
1785: PUSH
1786: LD_INT 3
1788: PUSH
1789: LD_INT 2
1791: PUSH
1792: LD_INT 1
1794: PUSH
1795: EMPTY
1796: LIST
1797: LIST
1798: LIST
1799: LIST
1800: PUSH
1801: LD_VAR 0 6
1805: PUSH
1806: LD_INT 4
1808: MOD
1809: PUSH
1810: LD_INT 1
1812: PLUS
1813: ARRAY
1814: PPUSH
1815: LD_INT 2
1817: PPUSH
1818: LD_INT 1
1820: PPUSH
1821: LD_INT 4
1823: PUSH
1824: LD_INT 5
1826: PUSH
1827: LD_INT 3
1829: PUSH
1830: LD_INT 11
1832: PUSH
1833: EMPTY
1834: LIST
1835: LIST
1836: LIST
1837: LIST
1838: PUSH
1839: LD_VAR 0 6
1843: PUSH
1844: LD_INT 4
1846: MOD
1847: PUSH
1848: LD_INT 1
1850: PLUS
1851: ARRAY
1852: PPUSH
1853: LD_INT 60
1855: PPUSH
1856: CALL 346 0 7
1860: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1861: LD_VAR 0 5
1865: PPUSH
1866: LD_INT 2
1868: PPUSH
1869: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
1873: LD_VAR 0 5
1877: PPUSH
1878: LD_INT 1
1880: PPUSH
1881: LD_INT 0
1883: PPUSH
1884: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
1888: LD_VAR 0 2
1892: PPUSH
1893: LD_VAR 0 5
1897: PPUSH
1898: CALL_OW 52
// end else
1902: GO 1919
// PlaceUnitArea ( i , startArea , false ) ;
1904: LD_VAR 0 2
1908: PPUSH
1909: LD_INT 1
1911: PPUSH
1912: LD_INT 0
1914: PPUSH
1915: CALL_OW 49
1919: GO 1740
1921: POP
1922: POP
// uc_side := 4 ;
1923: LD_ADDR_OWVAR 20
1927: PUSH
1928: LD_INT 4
1930: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
1931: LD_ADDR_EXP 17
1935: PUSH
1936: LD_STRING Harisson
1938: PPUSH
1939: LD_INT 0
1941: PPUSH
1942: CALL 283 0 2
1946: ST_TO_ADDR
// PrepareScout ;
1947: CALL 1956 0 0
// end ;
1951: LD_VAR 0 1
1955: RET
// function PrepareScout ; var ape ; begin
1956: LD_INT 0
1958: PPUSH
1959: PPUSH
// uc_side := 4 ;
1960: LD_ADDR_OWVAR 20
1964: PUSH
1965: LD_INT 4
1967: ST_TO_ADDR
// uc_nation := 1 ;
1968: LD_ADDR_OWVAR 21
1972: PUSH
1973: LD_INT 1
1975: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
1976: LD_STRING FrankIn06
1978: PPUSH
1979: LD_INT 0
1981: PPUSH
1982: CALL_OW 30
1986: IFFALSE 2003
// Frank := CreateCharacter ( 06c_Frank ) else
1988: LD_ADDR_EXP 13
1992: PUSH
1993: LD_STRING 06c_Frank
1995: PPUSH
1996: CALL_OW 34
2000: ST_TO_ADDR
2001: GO 2043
// if LoadVariable ( FrankInDelta , 0 ) then
2003: LD_STRING FrankInDelta
2005: PPUSH
2006: LD_INT 0
2008: PPUSH
2009: CALL_OW 30
2013: IFFALSE 2030
// Frank := CreateCharacter ( 05_Frank ) else
2015: LD_ADDR_EXP 13
2019: PUSH
2020: LD_STRING 05_Frank
2022: PPUSH
2023: CALL_OW 34
2027: ST_TO_ADDR
2028: GO 2043
// Frank := CreateCharacter ( 04_Frank ) ;
2030: LD_ADDR_EXP 13
2034: PUSH
2035: LD_STRING 04_Frank
2037: PPUSH
2038: CALL_OW 34
2042: ST_TO_ADDR
// if Frank then
2043: LD_EXP 13
2047: IFFALSE 2168
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
2049: LD_EXP 13
2053: PPUSH
2054: LD_INT 2
2056: PPUSH
2057: LD_INT 0
2059: PPUSH
2060: CALL_OW 49
// uc_side := 0 ;
2064: LD_ADDR_OWVAR 20
2068: PUSH
2069: LD_INT 0
2071: ST_TO_ADDR
// uc_nation := 0 ;
2072: LD_ADDR_OWVAR 21
2076: PUSH
2077: LD_INT 0
2079: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
2080: LD_INT 0
2082: PPUSH
2083: LD_INT 12
2085: PPUSH
2086: LD_INT 0
2088: PPUSH
2089: CALL_OW 380
// ape := CreateHuman ;
2093: LD_ADDR_VAR 0 2
2097: PUSH
2098: CALL_OW 44
2102: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
2103: LD_VAR 0 2
2107: PPUSH
2108: LD_EXP 13
2112: PPUSH
2113: CALL_OW 250
2117: PPUSH
2118: LD_EXP 13
2122: PPUSH
2123: CALL_OW 251
2127: PPUSH
2128: LD_INT 5
2130: PPUSH
2131: LD_INT 0
2133: PPUSH
2134: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
2138: LD_VAR 0 2
2142: PPUSH
2143: LD_EXP 13
2147: PPUSH
2148: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
2152: LD_EXP 13
2156: PPUSH
2157: LD_VAR 0 2
2161: PPUSH
2162: CALL_OW 119
// exit ;
2166: GO 2208
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
2168: LD_ADDR_EXP 16
2172: PUSH
2173: LD_STRING Yamoko
2175: PPUSH
2176: LD_INT 0
2178: PPUSH
2179: CALL 283 0 2
2183: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
2184: LD_EXP 16
2188: PPUSH
2189: LD_INT 2
2191: PPUSH
2192: LD_INT 0
2194: PPUSH
2195: CALL_OW 49
// ComHold ( Kikuchi ) ;
2199: LD_EXP 16
2203: PPUSH
2204: CALL_OW 140
// end ; end_of_file
2208: LD_VAR 0 1
2212: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
2213: LD_INT 0
2215: PPUSH
2216: PPUSH
2217: PPUSH
2218: PPUSH
2219: PPUSH
2220: PPUSH
2221: PPUSH
2222: PPUSH
2223: PPUSH
2224: PPUSH
2225: PPUSH
2226: PPUSH
2227: PPUSH
2228: PPUSH
2229: PPUSH
2230: PPUSH
// ru_rebuild_list := [ ] ;
2231: LD_ADDR_EXP 18
2235: PUSH
2236: EMPTY
2237: ST_TO_ADDR
// uc_side := 3 ;
2238: LD_ADDR_OWVAR 20
2242: PUSH
2243: LD_INT 3
2245: ST_TO_ADDR
// uc_nation := 3 ;
2246: LD_ADDR_OWVAR 21
2250: PUSH
2251: LD_INT 3
2253: ST_TO_ADDR
// if Difficulty > 1 then
2254: LD_OWVAR 67
2258: PUSH
2259: LD_INT 1
2261: GREATER
2262: IFFALSE 2398
// begin bc_type := b_breastwork ;
2264: LD_ADDR_OWVAR 42
2268: PUSH
2269: LD_INT 31
2271: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
2272: LD_INT 78
2274: PPUSH
2275: LD_INT 74
2277: PPUSH
2278: LD_INT 2
2280: PPUSH
2281: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
2285: LD_INT 171
2287: PPUSH
2288: LD_INT 193
2290: PPUSH
2291: LD_INT 4
2293: PPUSH
2294: CALL_OW 47
// bc_type := b_turret ;
2298: LD_ADDR_OWVAR 42
2302: PUSH
2303: LD_INT 33
2305: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
2306: LD_INT 129
2308: PPUSH
2309: LD_INT 96
2311: PPUSH
2312: LD_INT 3
2314: PPUSH
2315: CALL_OW 47
// if Difficulty > 2 then
2319: LD_OWVAR 67
2323: PUSH
2324: LD_INT 2
2326: GREATER
2327: IFFALSE 2398
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
2329: LD_INT 83
2331: PPUSH
2332: LD_INT 141
2334: PPUSH
2335: CALL_OW 428
2339: PPUSH
2340: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
2344: LD_INT 78
2346: PPUSH
2347: LD_INT 133
2349: PPUSH
2350: CALL_OW 428
2354: PPUSH
2355: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
2359: LD_INT 83
2361: PPUSH
2362: LD_INT 141
2364: PPUSH
2365: LD_INT 2
2367: PPUSH
2368: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
2372: LD_INT 78
2374: PPUSH
2375: LD_INT 133
2377: PPUSH
2378: LD_INT 2
2380: PPUSH
2381: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
2385: LD_INT 145
2387: PPUSH
2388: LD_INT 112
2390: PPUSH
2391: LD_INT 3
2393: PPUSH
2394: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
2398: LD_ADDR_VAR 0 9
2402: PUSH
2403: LD_INT 22
2405: PUSH
2406: LD_INT 3
2408: PUSH
2409: EMPTY
2410: LIST
2411: LIST
2412: PUSH
2413: LD_INT 2
2415: PUSH
2416: LD_INT 30
2418: PUSH
2419: LD_INT 0
2421: PUSH
2422: EMPTY
2423: LIST
2424: LIST
2425: PUSH
2426: LD_INT 30
2428: PUSH
2429: LD_INT 1
2431: PUSH
2432: EMPTY
2433: LIST
2434: LIST
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: LIST
2440: PUSH
2441: EMPTY
2442: LIST
2443: LIST
2444: PPUSH
2445: CALL_OW 69
2449: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
2450: LD_ADDR_VAR 0 10
2454: PUSH
2455: LD_INT 22
2457: PUSH
2458: LD_INT 3
2460: PUSH
2461: EMPTY
2462: LIST
2463: LIST
2464: PUSH
2465: LD_INT 2
2467: PUSH
2468: LD_INT 30
2470: PUSH
2471: LD_INT 6
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: PUSH
2478: LD_INT 30
2480: PUSH
2481: LD_INT 7
2483: PUSH
2484: EMPTY
2485: LIST
2486: LIST
2487: PUSH
2488: LD_INT 30
2490: PUSH
2491: LD_INT 8
2493: PUSH
2494: EMPTY
2495: LIST
2496: LIST
2497: PUSH
2498: EMPTY
2499: LIST
2500: LIST
2501: LIST
2502: LIST
2503: PUSH
2504: EMPTY
2505: LIST
2506: LIST
2507: PPUSH
2508: CALL_OW 69
2512: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
2513: LD_ADDR_VAR 0 11
2517: PUSH
2518: LD_INT 22
2520: PUSH
2521: LD_INT 3
2523: PUSH
2524: EMPTY
2525: LIST
2526: LIST
2527: PUSH
2528: LD_INT 30
2530: PUSH
2531: LD_INT 3
2533: PUSH
2534: EMPTY
2535: LIST
2536: LIST
2537: PUSH
2538: EMPTY
2539: LIST
2540: LIST
2541: PPUSH
2542: CALL_OW 69
2546: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
2547: LD_ADDR_VAR 0 12
2551: PUSH
2552: LD_INT 22
2554: PUSH
2555: LD_INT 3
2557: PUSH
2558: EMPTY
2559: LIST
2560: LIST
2561: PUSH
2562: LD_INT 30
2564: PUSH
2565: LD_INT 31
2567: PUSH
2568: EMPTY
2569: LIST
2570: LIST
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
2581: LD_ADDR_VAR 0 13
2585: PUSH
2586: LD_INT 22
2588: PUSH
2589: LD_INT 3
2591: PUSH
2592: EMPTY
2593: LIST
2594: LIST
2595: PUSH
2596: LD_INT 30
2598: PUSH
2599: LD_INT 32
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: PUSH
2606: EMPTY
2607: LIST
2608: LIST
2609: PPUSH
2610: CALL_OW 69
2614: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
2615: LD_ADDR_VAR 0 14
2619: PUSH
2620: LD_INT 22
2622: PUSH
2623: LD_INT 3
2625: PUSH
2626: EMPTY
2627: LIST
2628: LIST
2629: PUSH
2630: LD_INT 30
2632: PUSH
2633: LD_INT 33
2635: PUSH
2636: EMPTY
2637: LIST
2638: LIST
2639: PUSH
2640: EMPTY
2641: LIST
2642: LIST
2643: PPUSH
2644: CALL_OW 69
2648: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
2649: LD_ADDR_VAR 0 15
2653: PUSH
2654: LD_INT 42
2656: PUSH
2657: LD_INT 5
2659: PUSH
2660: EMPTY
2661: LIST
2662: LIST
2663: PUSH
2664: LD_INT 43
2666: PUSH
2667: LD_INT 50
2669: PUSH
2670: EMPTY
2671: LIST
2672: LIST
2673: PUSH
2674: LD_INT 44
2676: PUSH
2677: LD_INT 30
2679: PUSH
2680: EMPTY
2681: LIST
2682: LIST
2683: PUSH
2684: LD_INT 46
2686: PUSH
2687: LD_INT 15
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: PUSH
2694: EMPTY
2695: LIST
2696: LIST
2697: LIST
2698: LIST
2699: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 4 , 3 ] ;
2700: LD_ADDR_VAR 0 16
2704: PUSH
2705: LD_INT 0
2707: PUSH
2708: LD_INT 4
2710: PUSH
2711: LD_INT 4
2713: PUSH
2714: LD_INT 3
2716: PUSH
2717: EMPTY
2718: LIST
2719: LIST
2720: LIST
2721: LIST
2722: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
2723: LD_ADDR_VAR 0 6
2727: PUSH
2728: LD_INT 4
2730: PUSH
2731: LD_INT 5
2733: PUSH
2734: LD_INT 6
2736: PUSH
2737: EMPTY
2738: LIST
2739: LIST
2740: LIST
2741: PUSH
2742: LD_OWVAR 67
2746: ARRAY
2747: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
2748: LD_INT 16
2750: PPUSH
2751: LD_STRING am_tukh
2753: PPUSH
2754: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2758: LD_ADDR_VAR 0 2
2762: PUSH
2763: LD_INT 21
2765: PUSH
2766: LD_INT 3
2768: PUSH
2769: EMPTY
2770: LIST
2771: LIST
2772: PPUSH
2773: CALL_OW 69
2777: PUSH
2778: FOR_IN
2779: IFFALSE 2812
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
2781: LD_VAR 0 2
2785: PPUSH
2786: LD_INT 4
2788: PUSH
2789: LD_INT 5
2791: PUSH
2792: LD_INT 6
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: LIST
2799: PUSH
2800: LD_OWVAR 67
2804: ARRAY
2805: PPUSH
2806: CALL_OW 241
2810: GO 2778
2812: POP
2813: POP
// for i in dep_list do
2814: LD_ADDR_VAR 0 2
2818: PUSH
2819: LD_VAR 0 9
2823: PUSH
2824: FOR_IN
2825: IFFALSE 2869
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
2827: LD_VAR 0 2
2831: PPUSH
2832: CALL_OW 274
2836: PPUSH
2837: LD_INT 1
2839: PPUSH
2840: LD_INT 1000
2842: PPUSH
2843: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
2847: LD_VAR 0 2
2851: PPUSH
2852: CALL_OW 274
2856: PPUSH
2857: LD_INT 2
2859: PPUSH
2860: LD_INT 1000
2862: PPUSH
2863: CALL_OW 277
// end ;
2867: GO 2824
2869: POP
2870: POP
// InitHc ;
2871: CALL_OW 19
// tmp := bunker_list * [ 50 , 70 , 85 ] [ Difficulty ] div 100 ;
2875: LD_ADDR_VAR 0 8
2879: PUSH
2880: LD_VAR 0 13
2884: PUSH
2885: LD_INT 50
2887: PUSH
2888: LD_INT 70
2890: PUSH
2891: LD_INT 85
2893: PUSH
2894: EMPTY
2895: LIST
2896: LIST
2897: LIST
2898: PUSH
2899: LD_OWVAR 67
2903: ARRAY
2904: MUL
2905: PUSH
2906: LD_INT 100
2908: DIV
2909: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
2910: LD_ADDR_VAR 0 16
2914: PUSH
2915: LD_VAR 0 16
2919: PPUSH
2920: LD_INT 1
2922: PPUSH
2923: LD_VAR 0 8
2927: PPUSH
2928: CALL_OW 1
2932: ST_TO_ADDR
// tmp := [ ] ;
2933: LD_ADDR_VAR 0 8
2937: PUSH
2938: EMPTY
2939: ST_TO_ADDR
// for i in bunker_list do
2940: LD_ADDR_VAR 0 2
2944: PUSH
2945: LD_VAR 0 13
2949: PUSH
2950: FOR_IN
2951: IFFALSE 3047
// if i mod 10 + 1 < tmp then
2953: LD_VAR 0 2
2957: PUSH
2958: LD_INT 10
2960: MOD
2961: PUSH
2962: LD_INT 1
2964: PLUS
2965: PUSH
2966: LD_VAR 0 8
2970: LESS
2971: IFFALSE 3016
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
2973: LD_ADDR_VAR 0 8
2977: PUSH
2978: LD_VAR 0 8
2982: PPUSH
2983: LD_VAR 0 2
2987: PUSH
2988: LD_INT 3
2990: PPUSH
2991: LD_INT 5
2993: PPUSH
2994: CALL_OW 12
2998: MOD
2999: PUSH
3000: LD_INT 1
3002: PLUS
3003: PPUSH
3004: LD_VAR 0 2
3008: PPUSH
3009: CALL_OW 2
3013: ST_TO_ADDR
3014: GO 3045
// tmp := Insert ( tmp , tmp + 1 , i ) ;
3016: LD_ADDR_VAR 0 8
3020: PUSH
3021: LD_VAR 0 8
3025: PPUSH
3026: LD_VAR 0 8
3030: PUSH
3031: LD_INT 1
3033: PLUS
3034: PPUSH
3035: LD_VAR 0 2
3039: PPUSH
3040: CALL_OW 2
3044: ST_TO_ADDR
3045: GO 2950
3047: POP
3048: POP
// bunker_list := tmp ;
3049: LD_ADDR_VAR 0 13
3053: PUSH
3054: LD_VAR 0 8
3058: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
3059: LD_ADDR_VAR 0 2
3063: PUSH
3064: LD_VAR 0 13
3068: PUSH
3069: LD_VAR 0 14
3073: ADD
3074: PUSH
3075: FOR_IN
3076: IFFALSE 3173
// begin tmp := rand ( 0 , 100 ) ;
3078: LD_ADDR_VAR 0 8
3082: PUSH
3083: LD_INT 0
3085: PPUSH
3086: LD_INT 100
3088: PPUSH
3089: CALL_OW 12
3093: ST_TO_ADDR
// r := 0 ;
3094: LD_ADDR_VAR 0 4
3098: PUSH
3099: LD_INT 0
3101: ST_TO_ADDR
// for j in weapons_list do
3102: LD_ADDR_VAR 0 3
3106: PUSH
3107: LD_VAR 0 15
3111: PUSH
3112: FOR_IN
3113: IFFALSE 3169
// begin r := r + j [ 2 ] ;
3115: LD_ADDR_VAR 0 4
3119: PUSH
3120: LD_VAR 0 4
3124: PUSH
3125: LD_VAR 0 3
3129: PUSH
3130: LD_INT 2
3132: ARRAY
3133: PLUS
3134: ST_TO_ADDR
// if r >= tmp then
3135: LD_VAR 0 4
3139: PUSH
3140: LD_VAR 0 8
3144: GREATEREQUAL
3145: IFFALSE 3167
// begin PlaceWeaponTurret ( i , j [ 1 ] ) ;
3147: LD_VAR 0 2
3151: PPUSH
3152: LD_VAR 0 3
3156: PUSH
3157: LD_INT 1
3159: ARRAY
3160: PPUSH
3161: CALL_OW 431
// break ;
3165: GO 3169
// end ; end ;
3167: GO 3112
3169: POP
3170: POP
// end ;
3171: GO 3075
3173: POP
3174: POP
// while ( personel_counter [ 1 ] ) do
3175: LD_VAR 0 16
3179: PUSH
3180: LD_INT 1
3182: ARRAY
3183: IFFALSE 3291
// begin i := rand ( 1 , bunker_list ) ;
3185: LD_ADDR_VAR 0 2
3189: PUSH
3190: LD_INT 1
3192: PPUSH
3193: LD_VAR 0 13
3197: PPUSH
3198: CALL_OW 12
3202: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3203: LD_INT 0
3205: PPUSH
3206: LD_INT 1
3208: PPUSH
3209: LD_VAR 0 6
3213: PPUSH
3214: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
3218: CALL_OW 44
3222: PPUSH
3223: LD_VAR 0 13
3227: PUSH
3228: LD_VAR 0 2
3232: ARRAY
3233: PPUSH
3234: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
3238: LD_ADDR_VAR 0 13
3242: PUSH
3243: LD_VAR 0 13
3247: PPUSH
3248: LD_VAR 0 2
3252: PPUSH
3253: CALL_OW 3
3257: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
3258: LD_ADDR_VAR 0 16
3262: PUSH
3263: LD_VAR 0 16
3267: PPUSH
3268: LD_INT 1
3270: PPUSH
3271: LD_VAR 0 16
3275: PUSH
3276: LD_INT 1
3278: ARRAY
3279: PUSH
3280: LD_INT 1
3282: MINUS
3283: PPUSH
3284: CALL_OW 1
3288: ST_TO_ADDR
// end ;
3289: GO 3175
// for i = 1 to personel_counter [ 2 ] do
3291: LD_ADDR_VAR 0 2
3295: PUSH
3296: DOUBLE
3297: LD_INT 1
3299: DEC
3300: ST_TO_ADDR
3301: LD_VAR 0 16
3305: PUSH
3306: LD_INT 2
3308: ARRAY
3309: PUSH
3310: FOR_TO
3311: IFFALSE 3342
// begin PrepareHuman ( false , 2 , skill ) ;
3313: LD_INT 0
3315: PPUSH
3316: LD_INT 2
3318: PPUSH
3319: LD_VAR 0 6
3323: PPUSH
3324: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
3328: CALL_OW 44
3332: PPUSH
3333: LD_INT 16
3335: PPUSH
3336: CALL_OW 52
// end ;
3340: GO 3310
3342: POP
3343: POP
// for i = 1 to personel_counter [ 3 ] do
3344: LD_ADDR_VAR 0 2
3348: PUSH
3349: DOUBLE
3350: LD_INT 1
3352: DEC
3353: ST_TO_ADDR
3354: LD_VAR 0 16
3358: PUSH
3359: LD_INT 3
3361: ARRAY
3362: PUSH
3363: FOR_TO
3364: IFFALSE 3401
// begin PrepareHuman ( false , 3 , skill ) ;
3366: LD_INT 0
3368: PPUSH
3369: LD_INT 3
3371: PPUSH
3372: LD_VAR 0 6
3376: PPUSH
3377: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ 1 ] ) ;
3381: CALL_OW 44
3385: PPUSH
3386: LD_VAR 0 11
3390: PUSH
3391: LD_INT 1
3393: ARRAY
3394: PPUSH
3395: CALL_OW 52
// end ;
3399: GO 3363
3401: POP
3402: POP
// for i = 1 to personel_counter [ 4 ] do
3403: LD_ADDR_VAR 0 2
3407: PUSH
3408: DOUBLE
3409: LD_INT 1
3411: DEC
3412: ST_TO_ADDR
3413: LD_VAR 0 16
3417: PUSH
3418: LD_INT 4
3420: ARRAY
3421: PUSH
3422: FOR_TO
3423: IFFALSE 3460
// begin PrepareHuman ( false , 4 , skill ) ;
3425: LD_INT 0
3427: PPUSH
3428: LD_INT 4
3430: PPUSH
3431: LD_VAR 0 6
3435: PPUSH
3436: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
3440: CALL_OW 44
3444: PPUSH
3445: LD_VAR 0 10
3449: PUSH
3450: LD_INT 1
3452: ARRAY
3453: PPUSH
3454: CALL_OW 52
// end ;
3458: GO 3422
3460: POP
3461: POP
// for i in breastworks_list do
3462: LD_ADDR_VAR 0 2
3466: PUSH
3467: LD_VAR 0 12
3471: PUSH
3472: FOR_IN
3473: IFFALSE 3585
// begin r := GetDir ( i ) ;
3475: LD_ADDR_VAR 0 4
3479: PUSH
3480: LD_VAR 0 2
3484: PPUSH
3485: CALL_OW 254
3489: ST_TO_ADDR
// if r > 3 then
3490: LD_VAR 0 4
3494: PUSH
3495: LD_INT 3
3497: GREATER
3498: IFFALSE 3516
// r := r - 3 else
3500: LD_ADDR_VAR 0 4
3504: PUSH
3505: LD_VAR 0 4
3509: PUSH
3510: LD_INT 3
3512: MINUS
3513: ST_TO_ADDR
3514: GO 3530
// r := r + 3 ;
3516: LD_ADDR_VAR 0 4
3520: PUSH
3521: LD_VAR 0 4
3525: PUSH
3526: LD_INT 3
3528: PLUS
3529: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3530: LD_INT 0
3532: PPUSH
3533: LD_INT 1
3535: PPUSH
3536: LD_VAR 0 6
3540: PPUSH
3541: CALL_OW 380
// un := CreateHuman ;
3545: LD_ADDR_VAR 0 5
3549: PUSH
3550: CALL_OW 44
3554: ST_TO_ADDR
// SetDir ( un , r ) ;
3555: LD_VAR 0 5
3559: PPUSH
3560: LD_VAR 0 4
3564: PPUSH
3565: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3569: LD_VAR 0 5
3573: PPUSH
3574: LD_VAR 0 2
3578: PPUSH
3579: CALL_OW 52
// end ;
3583: GO 3472
3585: POP
3586: POP
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
3587: LD_ADDR_VAR 0 4
3591: PUSH
3592: LD_INT 4
3594: PUSH
3595: LD_INT 5
3597: PUSH
3598: LD_INT 6
3600: PUSH
3601: EMPTY
3602: LIST
3603: LIST
3604: LIST
3605: PUSH
3606: LD_OWVAR 67
3610: ARRAY
3611: ST_TO_ADDR
// for i = 1 to r do
3612: LD_ADDR_VAR 0 2
3616: PUSH
3617: DOUBLE
3618: LD_INT 1
3620: DEC
3621: ST_TO_ADDR
3622: LD_VAR 0 4
3626: PUSH
3627: FOR_TO
3628: IFFALSE 3723
// begin un := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
3630: LD_ADDR_VAR 0 5
3634: PUSH
3635: LD_INT 3
3637: PPUSH
3638: LD_INT 3
3640: PPUSH
3641: LD_INT 22
3643: PPUSH
3644: LD_INT 1
3646: PPUSH
3647: LD_INT 1
3649: PPUSH
3650: LD_INT 43
3652: PUSH
3653: LD_INT 44
3655: PUSH
3656: LD_INT 42
3658: PUSH
3659: EMPTY
3660: LIST
3661: LIST
3662: LIST
3663: PUSH
3664: LD_VAR 0 2
3668: PUSH
3669: LD_INT 3
3671: MOD
3672: PUSH
3673: LD_INT 1
3675: PLUS
3676: ARRAY
3677: PPUSH
3678: LD_INT 100
3680: PPUSH
3681: CALL 346 0 7
3685: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3686: LD_VAR 0 5
3690: PPUSH
3691: LD_INT 0
3693: PPUSH
3694: LD_INT 5
3696: PPUSH
3697: CALL_OW 12
3701: PPUSH
3702: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
3706: LD_VAR 0 5
3710: PPUSH
3711: LD_INT 5
3713: PPUSH
3714: LD_INT 0
3716: PPUSH
3717: CALL_OW 49
// end ;
3721: GO 3627
3723: POP
3724: POP
// end ;
3725: LD_VAR 0 1
3729: RET
// every 0 0$2 trigger FilterUnitsInArea ( baseArea , [ f_type , unit_building ] ) do var i , filter , engs ;
3730: LD_INT 6
3732: PPUSH
3733: LD_INT 21
3735: PUSH
3736: LD_INT 3
3738: PUSH
3739: EMPTY
3740: LIST
3741: LIST
3742: PPUSH
3743: CALL_OW 70
3747: IFFALSE 3855
3749: GO 3751
3751: DISABLE
3752: LD_INT 0
3754: PPUSH
3755: PPUSH
3756: PPUSH
// begin enable ;
3757: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_ok ] ] , [ f_type , unit_building ] ] ) ;
3758: LD_ADDR_VAR 0 2
3762: PUSH
3763: LD_INT 6
3765: PPUSH
3766: LD_INT 3
3768: PUSH
3769: LD_INT 50
3771: PUSH
3772: EMPTY
3773: LIST
3774: PUSH
3775: EMPTY
3776: LIST
3777: LIST
3778: PUSH
3779: LD_INT 21
3781: PUSH
3782: LD_INT 3
3784: PUSH
3785: EMPTY
3786: LIST
3787: LIST
3788: PUSH
3789: EMPTY
3790: LIST
3791: LIST
3792: PPUSH
3793: CALL_OW 70
3797: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_ok ] ] ) ;
3798: LD_ADDR_VAR 0 3
3802: PUSH
3803: LD_INT 22
3805: PUSH
3806: LD_INT 3
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PUSH
3813: LD_INT 25
3815: PUSH
3816: LD_INT 2
3818: PUSH
3819: EMPTY
3820: LIST
3821: LIST
3822: PUSH
3823: LD_INT 50
3825: PUSH
3826: EMPTY
3827: LIST
3828: PUSH
3829: EMPTY
3830: LIST
3831: LIST
3832: LIST
3833: PPUSH
3834: CALL_OW 69
3838: ST_TO_ADDR
// if not filter or not engs then
3839: LD_VAR 0 2
3843: NOT
3844: PUSH
3845: LD_VAR 0 3
3849: NOT
3850: OR
3851: IFFALSE 3855
// exit ;
3853: GO 3855
// end ; end_of_file
3855: PPOPN 3
3857: END
// export function Action ; begin
3858: LD_INT 0
3860: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
3861: LD_INT 28
3863: PPUSH
3864: LD_INT 3
3866: PPUSH
3867: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
3871: LD_INT 41
3873: PPUSH
3874: LD_INT 76
3876: PPUSH
3877: LD_INT 1
3879: PPUSH
3880: LD_INT 10
3882: PPUSH
3883: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
3887: LD_INT 41
3889: PPUSH
3890: LD_INT 76
3892: PPUSH
3893: LD_INT 1
3895: PPUSH
3896: CALL_OW 331
// InGameOn ;
3900: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
3904: LD_EXP 17
3908: PPUSH
3909: LD_STRING D2-Har-1
3911: PPUSH
3912: CALL_OW 94
// InGameOff ;
3916: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
3920: LD_STRING M1
3922: PPUSH
3923: CALL_OW 337
// end ;
3927: LD_VAR 0 1
3931: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
3932: LD_EXP 4
3936: PUSH
3937: LD_INT 1
3939: GREATER
3940: IFFALSE 4031
3942: GO 3944
3944: DISABLE
3945: LD_INT 0
3947: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
3948: LD_ADDR_VAR 0 1
3952: PUSH
3953: LD_INT 1
3955: PPUSH
3956: CALL 434 0 1
3960: PUSH
3961: LD_INT 1
3963: ARRAY
3964: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
3965: LD_VAR 0 1
3969: PPUSH
3970: LD_STRING D2a-Sol1-1
3972: PPUSH
3973: CALL_OW 88
// if not un then
3977: LD_VAR 0 1
3981: NOT
3982: IFFALSE 4013
// begin un := GetRandom ( sex_female ) [ 1 ] ;
3984: LD_ADDR_VAR 0 1
3988: PUSH
3989: LD_INT 2
3991: PPUSH
3992: CALL 434 0 1
3996: PUSH
3997: LD_INT 1
3999: ARRAY
4000: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
4001: LD_VAR 0 1
4005: PPUSH
4006: LD_STRING D2a-FSol1-1
4008: PPUSH
4009: CALL_OW 88
// end ; if Khatam then
4013: LD_EXP 15
4017: IFFALSE 4031
// Say ( Khatam , D3b-Khat-3 ) ;
4019: LD_EXP 15
4023: PPUSH
4024: LD_STRING D3b-Khat-3
4026: PPUSH
4027: CALL_OW 88
// end ;
4031: PPOPN 1
4033: END
// every 0 0$1 trigger Frank and GetDistUnits ( JMM , Frank ) < 5 and not InBattle ( 1 ) do var i , ape ;
4034: LD_EXP 13
4038: PUSH
4039: LD_EXP 7
4043: PPUSH
4044: LD_EXP 13
4048: PPUSH
4049: CALL_OW 296
4053: PUSH
4054: LD_INT 5
4056: LESS
4057: AND
4058: PUSH
4059: LD_INT 1
4061: PPUSH
4062: CALL_OW 463
4066: NOT
4067: AND
4068: IFFALSE 4655
4070: GO 4072
4072: DISABLE
4073: LD_INT 0
4075: PPUSH
4076: PPUSH
// begin InGameOn ;
4077: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
4081: LD_ADDR_VAR 0 2
4085: PUSH
4086: LD_INT 22
4088: PUSH
4089: LD_INT 0
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: PUSH
4096: LD_INT 25
4098: PUSH
4099: LD_INT 12
4101: PUSH
4102: EMPTY
4103: LIST
4104: LIST
4105: PUSH
4106: EMPTY
4107: LIST
4108: LIST
4109: PPUSH
4110: CALL_OW 69
4114: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
4115: LD_ADDR_VAR 0 2
4119: PUSH
4120: LD_VAR 0 2
4124: PPUSH
4125: LD_EXP 13
4129: PPUSH
4130: CALL_OW 74
4134: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
4135: LD_ADDR_VAR 0 1
4139: PUSH
4140: LD_INT 22
4142: PUSH
4143: LD_INT 1
4145: PUSH
4146: EMPTY
4147: LIST
4148: LIST
4149: PUSH
4150: LD_INT 21
4152: PUSH
4153: LD_INT 1
4155: PUSH
4156: EMPTY
4157: LIST
4158: LIST
4159: PUSH
4160: LD_INT 91
4162: PUSH
4163: LD_EXP 13
4167: PUSH
4168: LD_INT 20
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: PUSH
4176: EMPTY
4177: LIST
4178: LIST
4179: LIST
4180: PPUSH
4181: CALL_OW 69
4185: PUSH
4186: FOR_IN
4187: IFFALSE 4205
// ComTurnUnit ( i , Frank ) ;
4189: LD_VAR 0 1
4193: PPUSH
4194: LD_EXP 13
4198: PPUSH
4199: CALL_OW 119
4203: GO 4186
4205: POP
4206: POP
// SetSide ( Frank , 1 ) ;
4207: LD_EXP 13
4211: PPUSH
4212: LD_INT 1
4214: PPUSH
4215: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
4219: LD_EXP 7
4223: PPUSH
4224: LD_EXP 13
4228: PPUSH
4229: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
4233: LD_EXP 7
4237: PPUSH
4238: LD_EXP 13
4242: PPUSH
4243: CALL_OW 179
// CenterOnUnits ( Frank ) ;
4247: LD_EXP 13
4251: PPUSH
4252: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
4256: LD_EXP 13
4260: PPUSH
4261: LD_STRING D3a-Frank-1
4263: PPUSH
4264: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
4268: LD_VAR 0 2
4272: PPUSH
4273: LD_INT 42
4275: PPUSH
4276: LD_INT 78
4278: PPUSH
4279: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
4283: LD_VAR 0 2
4287: PPUSH
4288: LD_EXP 13
4292: PPUSH
4293: CALL_OW 179
// if Lisa then
4297: LD_EXP 12
4301: IFFALSE 4315
// Say ( Lisa , D3a-Lisa-1 ) ;
4303: LD_EXP 12
4307: PPUSH
4308: LD_STRING D3a-Lisa-1
4310: PPUSH
4311: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
4315: LD_EXP 7
4319: PPUSH
4320: LD_STRING D3a-JMM-1
4322: PPUSH
4323: CALL_OW 88
// if Cyrus then
4327: LD_EXP 11
4331: IFFALSE 4345
// Say ( Cyrus , D3a-Cyrus-1 ) ;
4333: LD_EXP 11
4337: PPUSH
4338: LD_STRING D3a-Cyrus-1
4340: PPUSH
4341: CALL_OW 88
// if GetRandom ( sex_male ) then
4345: LD_INT 1
4347: PPUSH
4348: CALL 434 0 1
4352: IFFALSE 4373
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
4354: LD_INT 1
4356: PPUSH
4357: CALL 434 0 1
4361: PUSH
4362: LD_INT 1
4364: ARRAY
4365: PPUSH
4366: LD_STRING D3a-Sol1-1
4368: PPUSH
4369: CALL_OW 88
// if GetRandom ( sex_female ) then
4373: LD_INT 2
4375: PPUSH
4376: CALL 434 0 1
4380: IFFALSE 4401
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
4382: LD_INT 2
4384: PPUSH
4385: CALL 434 0 1
4389: PUSH
4390: LD_INT 1
4392: ARRAY
4393: PPUSH
4394: LD_STRING D3a-FSol1-1
4396: PPUSH
4397: CALL_OW 88
// if Gladstone then
4401: LD_EXP 14
4405: IFFALSE 4419
// Say ( Gladstone , D3a-Glad-1 ) ;
4407: LD_EXP 14
4411: PPUSH
4412: LD_STRING D3a-Glad-1
4414: PPUSH
4415: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
4419: LD_VAR 0 2
4423: PPUSH
4424: LD_INT 60
4426: PPUSH
4427: LD_INT 113
4429: PPUSH
4430: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
4434: LD_EXP 13
4438: PPUSH
4439: LD_STRING D3a-Frank-2
4441: PPUSH
4442: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
4446: LD_EXP 13
4450: PPUSH
4451: LD_EXP 7
4455: PPUSH
4456: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
4460: LD_EXP 7
4464: PPUSH
4465: LD_STRING D3a-JMM-2
4467: PPUSH
4468: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
4472: LD_INT 1
4474: PPUSH
4475: LD_INT 4
4477: PPUSH
4478: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
4482: LD_INT 85
4484: PPUSH
4485: LD_INT 134
4487: PPUSH
4488: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
4492: LD_EXP 13
4496: PPUSH
4497: LD_STRING D3a-Frank-3
4499: PPUSH
4500: CALL_OW 88
// Wait ( 0 0$01 ) ;
4504: LD_INT 35
4506: PPUSH
4507: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
4511: LD_INT 166
4513: PPUSH
4514: LD_INT 136
4516: PPUSH
4517: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
4521: LD_EXP 7
4525: PPUSH
4526: LD_STRING D3a-JMM-3
4528: PPUSH
4529: CALL_OW 88
// Wait ( 0 0$01 ) ;
4533: LD_INT 35
4535: PPUSH
4536: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
4540: LD_EXP 13
4544: PPUSH
4545: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
4549: LD_EXP 13
4553: PPUSH
4554: LD_STRING D3a-Frank-4
4556: PPUSH
4557: CALL_OW 88
// if Lisa then
4561: LD_EXP 12
4565: IFFALSE 4579
// Say ( Lisa , D3a-Lisa-4 ) ;
4567: LD_EXP 12
4571: PPUSH
4572: LD_STRING D3a-Lisa-4
4574: PPUSH
4575: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
4579: LD_EXP 7
4583: PPUSH
4584: LD_STRING D3a-JMM-4
4586: PPUSH
4587: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
4591: LD_EXP 13
4595: PPUSH
4596: LD_STRING D3a-Frank-5
4598: PPUSH
4599: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
4603: LD_EXP 7
4607: PPUSH
4608: LD_STRING D3a-JMM-5
4610: PPUSH
4611: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
4615: LD_EXP 13
4619: PPUSH
4620: LD_STRING D3a-Frank-6
4622: PPUSH
4623: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
4627: LD_EXP 7
4631: PPUSH
4632: LD_STRING D3a-JMM-6
4634: PPUSH
4635: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
4639: LD_EXP 13
4643: PPUSH
4644: LD_STRING D3a-Frank-7
4646: PPUSH
4647: CALL_OW 88
// InGameOff ;
4651: CALL_OW 9
// end ;
4655: PPOPN 2
4657: END
// every 0 0$1 trigger Kikuchi and GetDistUnits ( JMM , Kikuchi ) < 5 and not InBattle ( 1 ) do
4658: LD_EXP 16
4662: PUSH
4663: LD_EXP 7
4667: PPUSH
4668: LD_EXP 16
4672: PPUSH
4673: CALL_OW 296
4677: PUSH
4678: LD_INT 5
4680: LESS
4681: AND
4682: PUSH
4683: LD_INT 1
4685: PPUSH
4686: CALL_OW 463
4690: NOT
4691: AND
4692: IFFALSE 4872
4694: GO 4696
4696: DISABLE
// begin InGameOn ;
4697: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
4701: LD_EXP 7
4705: PPUSH
4706: LD_EXP 16
4710: PPUSH
4711: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
4715: LD_EXP 16
4719: PPUSH
4720: LD_EXP 7
4724: PPUSH
4725: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
4729: LD_EXP 16
4733: PPUSH
4734: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
4738: LD_EXP 16
4742: PPUSH
4743: LD_STRING D3b-Yam-1
4745: PPUSH
4746: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
4750: LD_EXP 7
4754: PPUSH
4755: LD_STRING D3b-JMM-1
4757: PPUSH
4758: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
4762: LD_INT 1
4764: PPUSH
4765: LD_INT 4
4767: PPUSH
4768: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
4772: LD_INT 85
4774: PPUSH
4775: LD_INT 134
4777: PPUSH
4778: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
4782: LD_EXP 16
4786: PPUSH
4787: LD_STRING D3b-Yam-2
4789: PPUSH
4790: CALL_OW 88
// Wait ( 0 0$01 ) ;
4794: LD_INT 35
4796: PPUSH
4797: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
4801: LD_EXP 7
4805: PPUSH
4806: LD_STRING D3b-JMM-2
4808: PPUSH
4809: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
4813: LD_INT 166
4815: PPUSH
4816: LD_INT 136
4818: PPUSH
4819: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
4823: LD_EXP 16
4827: PPUSH
4828: LD_STRING D3b-Yam-3
4830: PPUSH
4831: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
4835: LD_EXP 7
4839: PPUSH
4840: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
4844: LD_EXP 7
4848: PPUSH
4849: LD_STRING D3b-JMM-3a
4851: PPUSH
4852: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
4856: LD_EXP 16
4860: PPUSH
4861: LD_INT 1
4863: PPUSH
4864: CALL_OW 235
// InGameOff ;
4868: CALL_OW 9
// end ;
4872: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , i ;
4873: LD_INT 7
4875: PPUSH
4876: LD_INT 22
4878: PUSH
4879: LD_INT 1
4881: PUSH
4882: EMPTY
4883: LIST
4884: LIST
4885: PUSH
4886: LD_INT 3
4888: PUSH
4889: LD_INT 24
4891: PUSH
4892: LD_INT 1000
4894: PUSH
4895: EMPTY
4896: LIST
4897: LIST
4898: PUSH
4899: EMPTY
4900: LIST
4901: LIST
4902: PUSH
4903: EMPTY
4904: LIST
4905: LIST
4906: PPUSH
4907: CALL_OW 70
4911: IFFALSE 5329
4913: GO 4915
4915: DISABLE
4916: LD_INT 0
4918: PPUSH
4919: PPUSH
4920: PPUSH
// begin un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) [ 1 ] ;
4921: LD_ADDR_VAR 0 1
4925: PUSH
4926: LD_INT 7
4928: PPUSH
4929: LD_INT 22
4931: PUSH
4932: LD_INT 1
4934: PUSH
4935: EMPTY
4936: LIST
4937: LIST
4938: PUSH
4939: LD_INT 3
4941: PUSH
4942: LD_INT 24
4944: PUSH
4945: LD_INT 1000
4947: PUSH
4948: EMPTY
4949: LIST
4950: LIST
4951: PUSH
4952: EMPTY
4953: LIST
4954: LIST
4955: PUSH
4956: EMPTY
4957: LIST
4958: LIST
4959: PPUSH
4960: CALL_OW 70
4964: PUSH
4965: LD_INT 1
4967: ARRAY
4968: ST_TO_ADDR
// DialogueOn ;
4969: CALL_OW 6
// CenterNowOnUnits ( un ) ;
4973: LD_VAR 0 1
4977: PPUSH
4978: CALL_OW 87
// if Lisa then
4982: LD_EXP 12
4986: IFFALSE 5014
// begin Say ( Lisa , D5-Lisa-1 ) ;
4988: LD_EXP 12
4992: PPUSH
4993: LD_STRING D5-Lisa-1
4995: PPUSH
4996: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
5000: LD_EXP 7
5004: PPUSH
5005: LD_STRING D5-JMM-1a
5007: PPUSH
5008: CALL_OW 88
// end else
5012: GO 5026
// Say ( JMM , D5-JMM-1 ) ;
5014: LD_EXP 7
5018: PPUSH
5019: LD_STRING D5-JMM-1
5021: PPUSH
5022: CALL_OW 88
// DialogueOff ;
5026: CALL_OW 7
// while ( true ) do
5030: LD_INT 1
5032: IFFALSE 5088
// begin wait ( 0 0$01 ) ;
5034: LD_INT 35
5036: PPUSH
5037: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
5041: LD_ADDR_VAR 0 2
5045: PUSH
5046: LD_INT 8
5048: PPUSH
5049: LD_INT 30
5051: PUSH
5052: LD_INT 26
5054: PUSH
5055: EMPTY
5056: LIST
5057: LIST
5058: PUSH
5059: LD_INT 101
5061: PUSH
5062: LD_INT 1
5064: PUSH
5065: EMPTY
5066: LIST
5067: LIST
5068: PUSH
5069: EMPTY
5070: LIST
5071: LIST
5072: PPUSH
5073: CALL_OW 71
5077: ST_TO_ADDR
// if x then
5078: LD_VAR 0 2
5082: IFFALSE 5086
// break ;
5084: GO 5088
// end ;
5086: GO 5030
// CenterOnUnits ( x [ 1 ] ) ;
5088: LD_VAR 0 2
5092: PUSH
5093: LD_INT 1
5095: ARRAY
5096: PPUSH
5097: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
5101: LD_EXP 13
5105: PUSH
5106: LD_EXP 13
5110: PPUSH
5111: CALL_OW 255
5115: PUSH
5116: LD_INT 1
5118: EQUAL
5119: AND
5120: IFFALSE 5136
// Say ( Frank , D5a-Frank-1 ) else
5122: LD_EXP 13
5126: PPUSH
5127: LD_STRING D5a-Frank-1
5129: PPUSH
5130: CALL_OW 88
5134: GO 5190
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
5136: LD_EXP 16
5140: PUSH
5141: LD_EXP 16
5145: PPUSH
5146: CALL_OW 255
5150: PUSH
5151: LD_INT 1
5153: EQUAL
5154: AND
5155: IFFALSE 5171
// Say ( Kikuchi , D5a-Yam-1 ) else
5157: LD_EXP 16
5161: PPUSH
5162: LD_STRING D5a-Yam-1
5164: PPUSH
5165: CALL_OW 88
5169: GO 5190
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
5171: LD_INT 1
5173: PPUSH
5174: CALL 434 0 1
5178: PUSH
5179: LD_INT 1
5181: ARRAY
5182: PPUSH
5183: LD_STRING D5a-Sol1-1
5185: PPUSH
5186: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
5190: LD_EXP 7
5194: PPUSH
5195: LD_STRING D5a-JMM-1
5197: PPUSH
5198: CALL_OW 88
// if Cyrus then
5202: LD_EXP 11
5206: IFFALSE 5220
// Say ( Cyrus , D5a-Cyrus-1 ) ;
5208: LD_EXP 11
5212: PPUSH
5213: LD_STRING D5a-Cyrus-1
5215: PPUSH
5216: CALL_OW 88
// x := false ;
5220: LD_ADDR_VAR 0 2
5224: PUSH
5225: LD_INT 0
5227: ST_TO_ADDR
// while ( true ) do
5228: LD_INT 1
5230: IFFALSE 5317
// begin wait ( 0 0$01 ) ;
5232: LD_INT 35
5234: PPUSH
5235: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
5239: LD_ADDR_VAR 0 3
5243: PUSH
5244: LD_INT 2
5246: PUSH
5247: LD_INT 30
5249: PUSH
5250: LD_INT 0
5252: PUSH
5253: EMPTY
5254: LIST
5255: LIST
5256: PUSH
5257: LD_INT 30
5259: PUSH
5260: LD_INT 1
5262: PUSH
5263: EMPTY
5264: LIST
5265: LIST
5266: PUSH
5267: EMPTY
5268: LIST
5269: LIST
5270: LIST
5271: PPUSH
5272: CALL_OW 69
5276: PUSH
5277: LD_INT 1
5279: DIFF
5280: PUSH
5281: FOR_IN
5282: IFFALSE 5305
// if BaseNeedEnergy ( i ) then
5284: LD_VAR 0 3
5288: PPUSH
5289: CALL 1091 0 1
5293: IFFALSE 5303
// x := true ;
5295: LD_ADDR_VAR 0 2
5299: PUSH
5300: LD_INT 1
5302: ST_TO_ADDR
5303: GO 5281
5305: POP
5306: POP
// if x then
5307: LD_VAR 0 2
5311: IFFALSE 5315
// break ;
5313: GO 5317
// end ;
5315: GO 5228
// Say ( JMM , D5b-JMM-1 ) ;
5317: LD_EXP 7
5321: PPUSH
5322: LD_STRING D5b-JMM-1
5324: PPUSH
5325: CALL_OW 88
// end ;
5329: PPOPN 3
5331: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
5332: LD_EXP 5
5336: PUSH
5337: LD_INT 1
5339: ARRAY
5340: PUSH
5341: LD_OWVAR 1
5345: LESS
5346: IFFALSE 5546
5348: GO 5350
5350: DISABLE
// begin if not IsDead ( ru_dep_main ) then
5351: LD_INT 16
5353: PPUSH
5354: CALL_OW 301
5358: NOT
5359: IFFALSE 5382
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
5361: LD_EXP 17
5365: PPUSH
5366: LD_STRING D3b-Har-3
5368: PPUSH
5369: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
5373: LD_STRING M2a
5375: PPUSH
5376: CALL_OW 337
// end else
5380: GO 5401
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
5382: LD_EXP 17
5386: PPUSH
5387: LD_STRING D3b-Har-3a
5389: PPUSH
5390: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
5394: LD_STRING M2
5396: PPUSH
5397: CALL_OW 337
// end ; can_end := true ;
5401: LD_ADDR_EXP 6
5405: PUSH
5406: LD_INT 1
5408: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
5409: LD_INT 9
5411: PPUSH
5412: LD_INT 1
5414: PPUSH
5415: CALL_OW 424
// Wait ( 0 0$02 ) ;
5419: LD_INT 70
5421: PPUSH
5422: CALL_OW 67
// if Lisa then
5426: LD_EXP 12
5430: IFFALSE 5444
// Say ( Lisa , D3b-Lisa ) ;
5432: LD_EXP 12
5436: PPUSH
5437: LD_STRING D3b-Lisa
5439: PPUSH
5440: CALL_OW 88
// if Bobby then
5444: LD_EXP 10
5448: IFFALSE 5462
// Say ( Bobby , D3b-Bobby-3 ) ;
5450: LD_EXP 10
5454: PPUSH
5455: LD_STRING D3b-Bobby-3
5457: PPUSH
5458: CALL_OW 88
// if Cyrus then
5462: LD_EXP 11
5466: IFFALSE 5480
// Say ( Cyrus , D3b-Cyrus-3 ) ;
5468: LD_EXP 11
5472: PPUSH
5473: LD_STRING D3b-Cyrus-3
5475: PPUSH
5476: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
5480: LD_EXP 13
5484: PUSH
5485: LD_EXP 13
5489: PPUSH
5490: CALL_OW 255
5494: PUSH
5495: LD_INT 1
5497: EQUAL
5498: AND
5499: IFFALSE 5513
// Say ( Frank , D3b-Frank-3 ) ;
5501: LD_EXP 13
5505: PPUSH
5506: LD_STRING D3b-Frank-3
5508: PPUSH
5509: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
5513: LD_EXP 16
5517: PUSH
5518: LD_EXP 16
5522: PPUSH
5523: CALL_OW 255
5527: PUSH
5528: LD_INT 1
5530: EQUAL
5531: AND
5532: IFFALSE 5546
// Say ( Kikuchi , D3b-Yam-4 ) ;
5534: LD_EXP 16
5538: PPUSH
5539: LD_STRING D3b-Yam-4
5541: PPUSH
5542: CALL_OW 88
// end ;
5546: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
5547: LD_EXP 5
5551: PUSH
5552: LD_INT 2
5554: ARRAY
5555: PUSH
5556: LD_OWVAR 1
5560: LESS
5561: IFFALSE 5585
5563: GO 5565
5565: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
5566: LD_EXP 17
5570: PPUSH
5571: LD_STRING D4-Har-1
5573: PPUSH
5574: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
5578: LD_STRING M3
5580: PPUSH
5581: CALL_OW 337
// end ;
5585: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
5586: LD_EXP 5
5590: PUSH
5591: LD_INT 3
5593: ARRAY
5594: PUSH
5595: LD_OWVAR 1
5599: LESS
5600: IFFALSE 5631
5602: GO 5604
5604: DISABLE
// begin if not IsDead ( ru_dep_main ) then
5605: LD_INT 16
5607: PPUSH
5608: CALL_OW 301
5612: NOT
5613: IFFALSE 5624
// YouLost ( TimeOut1 ) else
5615: LD_STRING TimeOut1
5617: PPUSH
5618: CALL_OW 104
5622: GO 5631
// YouLost ( TimeOut2 ) ;
5624: LD_STRING TimeOut2
5626: PPUSH
5627: CALL_OW 104
// end ;
5631: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on ;
5632: LD_EXP 7
5636: PPUSH
5637: LD_INT 9
5639: PPUSH
5640: CALL_OW 308
5644: PUSH
5645: LD_EXP 6
5649: AND
5650: IFFALSE 6034
5652: GO 5654
5654: DISABLE
5655: LD_INT 0
5657: PPUSH
// begin wait_on := false ;
5658: LD_ADDR_VAR 0 1
5662: PUSH
5663: LD_INT 0
5665: ST_TO_ADDR
// if FilterUnitsInArea ( endArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_driving ] ] ] ) < FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_driving ] ] ] ) then
5666: LD_INT 9
5668: PPUSH
5669: LD_INT 22
5671: PUSH
5672: LD_INT 1
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: PUSH
5679: LD_INT 2
5681: PUSH
5682: LD_INT 21
5684: PUSH
5685: LD_INT 1
5687: PUSH
5688: EMPTY
5689: LIST
5690: LIST
5691: PUSH
5692: LD_INT 55
5694: PUSH
5695: EMPTY
5696: LIST
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: LIST
5702: PUSH
5703: EMPTY
5704: LIST
5705: LIST
5706: PPUSH
5707: CALL_OW 70
5711: PUSH
5712: LD_INT 22
5714: PUSH
5715: LD_INT 1
5717: PUSH
5718: EMPTY
5719: LIST
5720: LIST
5721: PUSH
5722: LD_INT 2
5724: PUSH
5725: LD_INT 21
5727: PUSH
5728: LD_INT 1
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: PUSH
5735: LD_INT 55
5737: PUSH
5738: EMPTY
5739: LIST
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: LIST
5745: PUSH
5746: EMPTY
5747: LIST
5748: LIST
5749: PPUSH
5750: CALL_OW 69
5754: LESS
5755: IFFALSE 5804
// case Query ( Q1 ) of 1 :
5757: LD_STRING Q1
5759: PPUSH
5760: CALL_OW 97
5764: PUSH
5765: LD_INT 1
5767: DOUBLE
5768: EQUAL
5769: IFTRUE 5773
5771: GO 5784
5773: POP
// wait_on := true ; 2 :
5774: LD_ADDR_VAR 0 1
5778: PUSH
5779: LD_INT 1
5781: ST_TO_ADDR
5782: GO 5804
5784: LD_INT 2
5786: DOUBLE
5787: EQUAL
5788: IFTRUE 5792
5790: GO 5803
5792: POP
// wait_on := false ; end ;
5793: LD_ADDR_VAR 0 1
5797: PUSH
5798: LD_INT 0
5800: ST_TO_ADDR
5801: GO 5804
5803: POP
// repeat wait ( 0 0$01 ) ;
5804: LD_INT 35
5806: PPUSH
5807: CALL_OW 67
// display_strings := [ FilterUnitsInArea ( endArea , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterUnitsInArea ( endArea , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_outside ] ] ] ) , FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_outside ] ] ] ) ] ;
5811: LD_ADDR_OWVAR 47
5815: PUSH
5816: LD_INT 9
5818: PPUSH
5819: LD_INT 22
5821: PUSH
5822: LD_INT 1
5824: PUSH
5825: EMPTY
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 21
5831: PUSH
5832: LD_INT 1
5834: PUSH
5835: EMPTY
5836: LIST
5837: LIST
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: PPUSH
5843: CALL_OW 70
5847: PUSH
5848: LD_INT 9
5850: PPUSH
5851: LD_INT 22
5853: PUSH
5854: LD_INT 1
5856: PUSH
5857: EMPTY
5858: LIST
5859: LIST
5860: PUSH
5861: LD_INT 21
5863: PUSH
5864: LD_INT 1
5866: PUSH
5867: EMPTY
5868: LIST
5869: LIST
5870: PUSH
5871: LD_INT 3
5873: PUSH
5874: LD_INT 56
5876: PUSH
5877: EMPTY
5878: LIST
5879: PUSH
5880: EMPTY
5881: LIST
5882: LIST
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: PPUSH
5889: CALL_OW 70
5893: ADD
5894: PUSH
5895: LD_INT 22
5897: PUSH
5898: LD_INT 1
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 21
5907: PUSH
5908: LD_INT 1
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: PUSH
5915: LD_INT 3
5917: PUSH
5918: LD_INT 56
5920: PUSH
5921: EMPTY
5922: LIST
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: LIST
5932: PPUSH
5933: CALL_OW 69
5937: PUSH
5938: EMPTY
5939: LIST
5940: LIST
5941: ST_TO_ADDR
// until ( not wait_on ) or ( FilterUnitsInArea ( endArea , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_driving ] ] ) = FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_driving ] ] ) ) ;
5942: LD_VAR 0 1
5946: NOT
5947: PUSH
5948: LD_INT 9
5950: PPUSH
5951: LD_INT 22
5953: PUSH
5954: LD_INT 1
5956: PUSH
5957: EMPTY
5958: LIST
5959: LIST
5960: PUSH
5961: LD_INT 21
5963: PUSH
5964: LD_INT 1
5966: PUSH
5967: EMPTY
5968: LIST
5969: LIST
5970: PUSH
5971: LD_INT 55
5973: PUSH
5974: EMPTY
5975: LIST
5976: PUSH
5977: EMPTY
5978: LIST
5979: LIST
5980: LIST
5981: PPUSH
5982: CALL_OW 70
5986: PUSH
5987: LD_INT 22
5989: PUSH
5990: LD_INT 1
5992: PUSH
5993: EMPTY
5994: LIST
5995: LIST
5996: PUSH
5997: LD_INT 21
5999: PUSH
6000: LD_INT 1
6002: PUSH
6003: EMPTY
6004: LIST
6005: LIST
6006: PUSH
6007: LD_INT 55
6009: PUSH
6010: EMPTY
6011: LIST
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: PPUSH
6018: CALL_OW 69
6022: EQUAL
6023: OR
6024: IFFALSE 5804
// display_strings := END ;
6026: LD_ADDR_OWVAR 47
6030: PUSH
6031: LD_STRING END
6033: ST_TO_ADDR
// end ; end_of_file
6034: PPOPN 1
6036: END
// on UnitDestroyed ( un ) do begin if un = JMM then
6037: LD_VAR 0 1
6041: PUSH
6042: LD_EXP 7
6046: EQUAL
6047: IFFALSE 6056
// YouLost ( JMM ) ;
6049: LD_STRING JMM
6051: PPUSH
6052: CALL_OW 104
// if GetType ( un ) = unit_building then
6056: LD_VAR 0 1
6060: PPUSH
6061: CALL_OW 247
6065: PUSH
6066: LD_INT 3
6068: EQUAL
6069: IFFALSE 6085
// buildings_counter := buildings_counter + 1 ;
6071: LD_ADDR_EXP 4
6075: PUSH
6076: LD_EXP 4
6080: PUSH
6081: LD_INT 1
6083: PLUS
6084: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
6085: LD_VAR 0 1
6089: PUSH
6090: LD_INT 6
6092: PPUSH
6093: LD_INT 2
6095: PUSH
6096: LD_INT 30
6098: PUSH
6099: LD_INT 33
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PUSH
6106: LD_INT 30
6108: PUSH
6109: LD_INT 32
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: LIST
6120: PPUSH
6121: CALL_OW 70
6125: IN
6126: IFFALSE 6185
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
6128: LD_ADDR_EXP 18
6132: PUSH
6133: LD_EXP 18
6137: PUSH
6138: LD_VAR 0 1
6142: PPUSH
6143: CALL_OW 266
6147: PUSH
6148: LD_VAR 0 1
6152: PPUSH
6153: CALL_OW 250
6157: PUSH
6158: LD_VAR 0 1
6162: PPUSH
6163: CALL_OW 251
6167: PUSH
6168: LD_VAR 0 1
6172: PPUSH
6173: CALL_OW 254
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: ADD
6184: ST_TO_ADDR
// if un = ru_dep_main then
6185: LD_VAR 0 1
6189: PUSH
6190: LD_INT 16
6192: EQUAL
6193: IFFALSE 6202
// ChangeMissionObjectives ( M1a ) ;
6195: LD_STRING M1a
6197: PPUSH
6198: CALL_OW 337
// end ;
6202: PPOPN 1
6204: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
6205: LD_VAR 0 1
6209: PUSH
6210: LD_INT 22
6212: PUSH
6213: LD_INT 3
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PUSH
6220: LD_INT 2
6222: PUSH
6223: LD_INT 30
6225: PUSH
6226: LD_INT 31
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: PUSH
6233: LD_INT 30
6235: PUSH
6236: LD_INT 32
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: PUSH
6243: EMPTY
6244: LIST
6245: LIST
6246: LIST
6247: PUSH
6248: EMPTY
6249: LIST
6250: LIST
6251: PPUSH
6252: CALL_OW 69
6256: IN
6257: IFFALSE 6279
// GoToAnotherTower ( un , b , 143 , 143 ) ;
6259: LD_VAR 0 2
6263: PPUSH
6264: LD_VAR 0 1
6268: PPUSH
6269: LD_INT 143
6271: PPUSH
6272: LD_INT 143
6274: PPUSH
6275: CALL 664 0 4
// end ;
6279: PPOPN 2
6281: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
6282: LD_VAR 0 1
6286: PUSH
6287: LD_INT 22
6289: PUSH
6290: LD_INT 3
6292: PUSH
6293: EMPTY
6294: LIST
6295: LIST
6296: PUSH
6297: LD_INT 30
6299: PUSH
6300: LD_INT 32
6302: PUSH
6303: EMPTY
6304: LIST
6305: LIST
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: PPUSH
6311: CALL_OW 69
6315: IN
6316: IFFALSE 6330
// SetTag ( b , 0 ) ;
6318: LD_VAR 0 1
6322: PPUSH
6323: LD_INT 0
6325: PPUSH
6326: CALL_OW 109
// end ;
6330: PPOPN 2
6332: END
