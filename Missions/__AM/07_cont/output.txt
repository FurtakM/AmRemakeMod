// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 33 0 0
// DebugMode ;
  12: CALL 234 0 0
// PrepareNature ;
  16: CALL 1598 0 0
// PrepareRussians ;
  20: CALL 3140 0 0
// PrepareAmericans ;
  24: CALL 2083 0 0
// Action ;
  28: CALL 7063 0 0
// end ;
  32: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end , must_end ; function Init ; begin
  33: LD_INT 0
  35: PPUSH
// debug := false ;
  36: LD_ADDR_EXP 1
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// mission_prefix := 07c_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 07c_
  51: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  52: LD_ADDR_EXP 2
  56: PUSH
  57: LD_STRING 07_
  59: ST_TO_ADDR
// buildings_counter := 0 ;
  60: LD_ADDR_EXP 4
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// time_to_end := [ [ 30 30$00 , 27 27$00 , 24 24$00 ] [ Difficulty ] , [ 36 36$00 , 33 33$00 , 30 30$00 ] [ Difficulty ] , [ 42 42$00 , 39 39$00 , 36 36$00 ] [ Difficulty ] ] ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 63000
  75: PUSH
  76: LD_INT 56700
  78: PUSH
  79: LD_INT 50400
  81: PUSH
  82: EMPTY
  83: LIST
  84: LIST
  85: LIST
  86: PUSH
  87: LD_OWVAR 67
  91: ARRAY
  92: PUSH
  93: LD_INT 75600
  95: PUSH
  96: LD_INT 69300
  98: PUSH
  99: LD_INT 63000
 101: PUSH
 102: EMPTY
 103: LIST
 104: LIST
 105: LIST
 106: PUSH
 107: LD_OWVAR 67
 111: ARRAY
 112: PUSH
 113: LD_INT 88200
 115: PUSH
 116: LD_INT 81900
 118: PUSH
 119: LD_INT 75600
 121: PUSH
 122: EMPTY
 123: LIST
 124: LIST
 125: LIST
 126: PUSH
 127: LD_OWVAR 67
 131: ARRAY
 132: PUSH
 133: EMPTY
 134: LIST
 135: LIST
 136: LIST
 137: ST_TO_ADDR
// can_end := false ;
 138: LD_ADDR_EXP 6
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// must_end := false ;
 146: LD_ADDR_EXP 7
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// end ;
 154: LD_VAR 0 1
 158: RET
// every 0 0$01 trigger not debug do
 159: LD_EXP 1
 163: NOT
 164: IFFALSE 233
 166: GO 168
 168: DISABLE
// begin enable ;
 169: ENABLE
// if not must_end then
 170: LD_EXP 7
 174: NOT
 175: IFFALSE 196
// display_strings := [ #Am07-1 , tick ] else
 177: LD_ADDR_OWVAR 47
 181: PUSH
 182: LD_STRING #Am07-1
 184: PUSH
 185: LD_OWVAR 1
 189: PUSH
 190: EMPTY
 191: LIST
 192: LIST
 193: ST_TO_ADDR
 194: GO 233
// display_strings := [ #Am07-1 , tick , #Am07-2 , time_to_end [ 3 ] - tick ] ;
 196: LD_ADDR_OWVAR 47
 200: PUSH
 201: LD_STRING #Am07-1
 203: PUSH
 204: LD_OWVAR 1
 208: PUSH
 209: LD_STRING #Am07-2
 211: PUSH
 212: LD_EXP 5
 216: PUSH
 217: LD_INT 3
 219: ARRAY
 220: PUSH
 221: LD_OWVAR 1
 225: MINUS
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: LIST
 232: ST_TO_ADDR
// end ;
 233: END
// function DebugMode ; begin
 234: LD_INT 0
 236: PPUSH
// if not debug then
 237: LD_EXP 1
 241: NOT
 242: IFFALSE 246
// exit ;
 244: GO 253
// FogOff ( 1 ) ;
 246: LD_INT 1
 248: PPUSH
 249: CALL_OW 344
// end ;
 253: LD_VAR 0 1
 257: RET
// every 3 trigger debug do var i , filter ;
 258: LD_EXP 1
 262: IFFALSE 351
 264: GO 266
 266: DISABLE
 267: LD_INT 0
 269: PPUSH
 270: PPUSH
// begin enable ;
 271: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 272: LD_ADDR_VAR 0 2
 276: PUSH
 277: LD_INT 22
 279: PUSH
 280: LD_INT 1
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: PUSH
 287: LD_INT 3
 289: PUSH
 290: LD_INT 24
 292: PUSH
 293: LD_INT 500
 295: PUSH
 296: EMPTY
 297: LIST
 298: LIST
 299: PUSH
 300: EMPTY
 301: LIST
 302: LIST
 303: PUSH
 304: EMPTY
 305: LIST
 306: LIST
 307: PPUSH
 308: CALL_OW 69
 312: ST_TO_ADDR
// if not filter then
 313: LD_VAR 0 2
 317: NOT
 318: IFFALSE 322
// exit ;
 320: GO 351
// for i in filter do
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_VAR 0 2
 331: PUSH
 332: FOR_IN
 333: IFFALSE 349
// SetLives ( i , 1000 ) ;
 335: LD_VAR 0 1
 339: PPUSH
 340: LD_INT 1000
 342: PPUSH
 343: CALL_OW 234
 347: GO 332
 349: POP
 350: POP
// end ; end_of_file
 351: PPOPN 2
 353: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 354: LD_INT 0
 356: PPUSH
 357: PPUSH
// if exist_mode then
 358: LD_VAR 0 2
 362: IFFALSE 387
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 364: LD_ADDR_VAR 0 4
 368: PUSH
 369: LD_EXP 2
 373: PUSH
 374: LD_VAR 0 1
 378: STR
 379: PPUSH
 380: CALL_OW 34
 384: ST_TO_ADDR
 385: GO 402
// unit := NewCharacter ( ident ) ;
 387: LD_ADDR_VAR 0 4
 391: PUSH
 392: LD_VAR 0 1
 396: PPUSH
 397: CALL_OW 25
 401: ST_TO_ADDR
// result := unit ;
 402: LD_ADDR_VAR 0 3
 406: PUSH
 407: LD_VAR 0 4
 411: ST_TO_ADDR
// end ;
 412: LD_VAR 0 3
 416: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 417: LD_INT 0
 419: PPUSH
// uc_side := side ;
 420: LD_ADDR_OWVAR 20
 424: PUSH
 425: LD_VAR 0 1
 429: ST_TO_ADDR
// uc_nation := nation ;
 430: LD_ADDR_OWVAR 21
 434: PUSH
 435: LD_VAR 0 2
 439: ST_TO_ADDR
// vc_chassis := chassis ;
 440: LD_ADDR_OWVAR 37
 444: PUSH
 445: LD_VAR 0 3
 449: ST_TO_ADDR
// vc_engine := engine ;
 450: LD_ADDR_OWVAR 39
 454: PUSH
 455: LD_VAR 0 4
 459: ST_TO_ADDR
// vc_control := control ;
 460: LD_ADDR_OWVAR 38
 464: PUSH
 465: LD_VAR 0 5
 469: ST_TO_ADDR
// vc_weapon := weapon ;
 470: LD_ADDR_OWVAR 40
 474: PUSH
 475: LD_VAR 0 6
 479: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 480: LD_ADDR_OWVAR 41
 484: PUSH
 485: LD_VAR 0 7
 489: ST_TO_ADDR
// result := CreateVehicle ;
 490: LD_ADDR_VAR 0 8
 494: PUSH
 495: CALL_OW 45
 499: ST_TO_ADDR
// end ;
 500: LD_VAR 0 8
 504: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 505: LD_INT 0
 507: PPUSH
 508: PPUSH
 509: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 510: LD_ADDR_VAR 0 4
 514: PUSH
 515: LD_INT 22
 517: PUSH
 518: LD_INT 1
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: PUSH
 525: LD_INT 21
 527: PUSH
 528: LD_INT 1
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: PUSH
 535: LD_INT 50
 537: PUSH
 538: EMPTY
 539: LIST
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: PPUSH
 546: CALL_OW 69
 550: PUSH
 551: LD_EXP 8
 555: PUSH
 556: LD_EXP 9
 560: PUSH
 561: LD_EXP 10
 565: PUSH
 566: LD_EXP 11
 570: PUSH
 571: LD_EXP 12
 575: PUSH
 576: LD_EXP 13
 580: PUSH
 581: LD_EXP 14
 585: PUSH
 586: LD_EXP 15
 590: PUSH
 591: LD_EXP 17
 595: PUSH
 596: LD_EXP 16
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: DIFF
 613: ST_TO_ADDR
// if not filter then
 614: LD_VAR 0 4
 618: NOT
 619: IFFALSE 623
// exit ;
 621: GO 650
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 623: LD_ADDR_VAR 0 2
 627: PUSH
 628: LD_VAR 0 4
 632: PPUSH
 633: LD_INT 26
 635: PUSH
 636: LD_VAR 0 1
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL_OW 72
 649: ST_TO_ADDR
// end ;
 650: LD_VAR 0 2
 654: RET
// export function SayX ( units , ident ) ; var i ; begin
 655: LD_INT 0
 657: PPUSH
 658: PPUSH
// result := false ;
 659: LD_ADDR_VAR 0 3
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// if not units then
 667: LD_VAR 0 1
 671: NOT
 672: IFFALSE 676
// exit ;
 674: GO 730
// for i in units do
 676: LD_ADDR_VAR 0 4
 680: PUSH
 681: LD_VAR 0 1
 685: PUSH
 686: FOR_IN
 687: IFFALSE 728
// if IsOk ( i ) then
 689: LD_VAR 0 4
 693: PPUSH
 694: CALL_OW 302
 698: IFFALSE 726
// begin Say ( i , ident ) ;
 700: LD_VAR 0 4
 704: PPUSH
 705: LD_VAR 0 2
 709: PPUSH
 710: CALL_OW 88
// result := i ;
 714: LD_ADDR_VAR 0 3
 718: PUSH
 719: LD_VAR 0 4
 723: ST_TO_ADDR
// break ;
 724: GO 728
// end ;
 726: GO 686
 728: POP
 729: POP
// end ;
 730: LD_VAR 0 3
 734: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
 735: LD_INT 0
 737: PPUSH
 738: PPUSH
 739: PPUSH
 740: PPUSH
 741: PPUSH
// if not un or not IsOk ( un ) then
 742: LD_VAR 0 1
 746: NOT
 747: PUSH
 748: LD_VAR 0 1
 752: PPUSH
 753: CALL_OW 302
 757: NOT
 758: OR
 759: IFFALSE 763
// exit ;
 761: GO 1203
// side := GetSide ( un ) ;
 763: LD_ADDR_VAR 0 9
 767: PUSH
 768: LD_VAR 0 1
 772: PPUSH
 773: CALL_OW 255
 777: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
 778: LD_ADDR_VAR 0 7
 782: PUSH
 783: LD_INT 22
 785: PUSH
 786: LD_VAR 0 9
 790: PUSH
 791: EMPTY
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 30
 797: PUSH
 798: LD_INT 32
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: PUSH
 805: LD_INT 50
 807: PUSH
 808: EMPTY
 809: LIST
 810: PUSH
 811: LD_INT 58
 813: PUSH
 814: EMPTY
 815: LIST
 816: PUSH
 817: EMPTY
 818: LIST
 819: LIST
 820: LIST
 821: LIST
 822: PPUSH
 823: CALL_OW 69
 827: PUSH
 828: LD_VAR 0 2
 832: DIFF
 833: ST_TO_ADDR
// if not filter then
 834: LD_VAR 0 7
 838: NOT
 839: IFFALSE 1068
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
 841: LD_ADDR_VAR 0 7
 845: PUSH
 846: LD_INT 22
 848: PUSH
 849: LD_VAR 0 9
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: PUSH
 858: LD_INT 30
 860: PUSH
 861: LD_INT 5
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PPUSH
 872: CALL_OW 69
 876: ST_TO_ADDR
// if debug then
 877: LD_EXP 1
 881: IFFALSE 900
// display_strings := [ filter , 1 ] ;
 883: LD_ADDR_OWVAR 47
 887: PUSH
 888: LD_VAR 0 7
 892: PUSH
 893: LD_STRING 1
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: ST_TO_ADDR
// if not filter then
 900: LD_VAR 0 7
 904: NOT
 905: IFFALSE 928
// begin ComMoveXY ( un , x , y ) ;
 907: LD_VAR 0 1
 911: PPUSH
 912: LD_VAR 0 3
 916: PPUSH
 917: LD_VAR 0 4
 921: PPUSH
 922: CALL_OW 111
// exit ;
 926: GO 1203
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
 928: LD_ADDR_VAR 0 8
 932: PUSH
 933: LD_VAR 0 7
 937: PPUSH
 938: LD_VAR 0 1
 942: PPUSH
 943: CALL_OW 74
 947: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
 948: LD_VAR 0 8
 952: PPUSH
 953: CALL_OW 313
 957: PUSH
 958: LD_INT 6
 960: EQUAL
 961: IFFALSE 981
// filter := filter diff t else
 963: LD_ADDR_VAR 0 7
 967: PUSH
 968: LD_VAR 0 7
 972: PUSH
 973: LD_VAR 0 8
 977: DIFF
 978: ST_TO_ADDR
 979: GO 983
// break ;
 981: GO 1005
// until UnitsInside ( t ) < 6 or not filter ;
 983: LD_VAR 0 8
 987: PPUSH
 988: CALL_OW 313
 992: PUSH
 993: LD_INT 6
 995: LESS
 996: PUSH
 997: LD_VAR 0 7
1001: NOT
1002: OR
1003: IFFALSE 928
// display_strings := [ filter , t ] ;
1005: LD_ADDR_OWVAR 47
1009: PUSH
1010: LD_VAR 0 7
1014: PUSH
1015: LD_VAR 0 8
1019: PUSH
1020: EMPTY
1021: LIST
1022: LIST
1023: ST_TO_ADDR
// if not filter then
1024: LD_VAR 0 7
1028: NOT
1029: IFFALSE 1052
// ComMoveXY ( un , x , y ) else
1031: LD_VAR 0 1
1035: PPUSH
1036: LD_VAR 0 3
1040: PPUSH
1041: LD_VAR 0 4
1045: PPUSH
1046: CALL_OW 111
1050: GO 1066
// ComEnterUnit ( un , t ) ;
1052: LD_VAR 0 1
1056: PPUSH
1057: LD_VAR 0 8
1061: PPUSH
1062: CALL_OW 120
// end else
1066: GO 1203
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
1068: LD_ADDR_VAR 0 8
1072: PUSH
1073: LD_VAR 0 7
1077: PPUSH
1078: LD_VAR 0 1
1082: PPUSH
1083: CALL_OW 74
1087: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
1088: LD_VAR 0 8
1092: PPUSH
1093: CALL_OW 110
1097: PUSH
1098: LD_INT 7
1100: EQUAL
1101: IFFALSE 1119
// filter := filter diff t ;
1103: LD_ADDR_VAR 0 7
1107: PUSH
1108: LD_VAR 0 7
1112: PUSH
1113: LD_VAR 0 8
1117: DIFF
1118: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
1119: LD_VAR 0 8
1123: PPUSH
1124: CALL_OW 110
1128: PUSH
1129: LD_INT 7
1131: NONEQUAL
1132: PUSH
1133: LD_VAR 0 7
1137: NOT
1138: OR
1139: IFFALSE 1068
// if GetTag ( t ) <> 7 then
1141: LD_VAR 0 8
1145: PPUSH
1146: CALL_OW 110
1150: PUSH
1151: LD_INT 7
1153: NONEQUAL
1154: IFFALSE 1184
// begin SetTag ( t , 7 ) ;
1156: LD_VAR 0 8
1160: PPUSH
1161: LD_INT 7
1163: PPUSH
1164: CALL_OW 109
// ComEnterUnit ( un , t ) ;
1168: LD_VAR 0 1
1172: PPUSH
1173: LD_VAR 0 8
1177: PPUSH
1178: CALL_OW 120
// end else
1182: GO 1203
// ComMoveXY ( un , x , y ) ;
1184: LD_VAR 0 1
1188: PPUSH
1189: LD_VAR 0 3
1193: PPUSH
1194: LD_VAR 0 4
1198: PPUSH
1199: CALL_OW 111
// end ; end ;
1203: LD_VAR 0 5
1207: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
1208: LD_INT 0
1210: PPUSH
1211: PPUSH
1212: PPUSH
// if not base then
1213: LD_VAR 0 1
1217: NOT
1218: IFFALSE 1222
// exit ;
1220: GO 1280
// tmp := GetEnergy ( GetBase ( base ) ) ;
1222: LD_ADDR_VAR 0 4
1226: PUSH
1227: LD_VAR 0 1
1231: PPUSH
1232: CALL_OW 274
1236: PPUSH
1237: CALL_OW 278
1241: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
1242: LD_VAR 0 4
1246: PUSH
1247: LD_INT 1
1249: ARRAY
1250: PUSH
1251: LD_VAR 0 4
1255: PUSH
1256: LD_INT 4
1258: ARRAY
1259: GREATER
1260: IFFALSE 1272
// result := true else
1262: LD_ADDR_VAR 0 2
1266: PUSH
1267: LD_INT 1
1269: ST_TO_ADDR
1270: GO 1280
// result := false ;
1272: LD_ADDR_VAR 0 2
1276: PUSH
1277: LD_INT 0
1279: ST_TO_ADDR
// end ;
1280: LD_VAR 0 2
1284: RET
// export function FilterPeople ( side ) ; begin
1285: LD_INT 0
1287: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
1288: LD_ADDR_VAR 0 2
1292: PUSH
1293: LD_INT 22
1295: PUSH
1296: LD_VAR 0 1
1300: PUSH
1301: EMPTY
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 21
1307: PUSH
1308: LD_INT 1
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: PUSH
1315: EMPTY
1316: LIST
1317: LIST
1318: PPUSH
1319: CALL_OW 69
1323: ST_TO_ADDR
// end ;
1324: LD_VAR 0 2
1328: RET
// export function FilterDrivers ( side ) ; begin
1329: LD_INT 0
1331: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
1332: LD_ADDR_VAR 0 2
1336: PUSH
1337: LD_INT 22
1339: PUSH
1340: LD_VAR 0 1
1344: PUSH
1345: EMPTY
1346: LIST
1347: LIST
1348: PUSH
1349: LD_INT 3
1351: PUSH
1352: LD_INT 56
1354: PUSH
1355: EMPTY
1356: LIST
1357: PUSH
1358: EMPTY
1359: LIST
1360: LIST
1361: PUSH
1362: EMPTY
1363: LIST
1364: LIST
1365: PPUSH
1366: CALL_OW 69
1370: ST_TO_ADDR
// end ;
1371: LD_VAR 0 2
1375: RET
// export function FilterPeopleArea ( side , area ) ; begin
1376: LD_INT 0
1378: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
1379: LD_ADDR_VAR 0 3
1383: PUSH
1384: LD_VAR 0 2
1388: PPUSH
1389: LD_INT 22
1391: PUSH
1392: LD_INT 1
1394: PUSH
1395: EMPTY
1396: LIST
1397: LIST
1398: PUSH
1399: LD_INT 21
1401: PUSH
1402: LD_INT 1
1404: PUSH
1405: EMPTY
1406: LIST
1407: LIST
1408: PUSH
1409: EMPTY
1410: LIST
1411: LIST
1412: PPUSH
1413: CALL_OW 70
1417: ST_TO_ADDR
// end ;
1418: LD_VAR 0 3
1422: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
1423: LD_INT 0
1425: PPUSH
1426: PPUSH
1427: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
1428: LD_ADDR_VAR 0 5
1432: PUSH
1433: LD_VAR 0 2
1437: PPUSH
1438: LD_INT 22
1440: PUSH
1441: LD_INT 1
1443: PUSH
1444: EMPTY
1445: LIST
1446: LIST
1447: PUSH
1448: LD_INT 21
1450: PUSH
1451: LD_INT 2
1453: PUSH
1454: EMPTY
1455: LIST
1456: LIST
1457: PUSH
1458: LD_INT 3
1460: PUSH
1461: LD_INT 58
1463: PUSH
1464: EMPTY
1465: LIST
1466: PUSH
1467: EMPTY
1468: LIST
1469: LIST
1470: PUSH
1471: EMPTY
1472: LIST
1473: LIST
1474: LIST
1475: PPUSH
1476: CALL_OW 70
1480: ST_TO_ADDR
// result := [ ] ;
1481: LD_ADDR_VAR 0 3
1485: PUSH
1486: EMPTY
1487: ST_TO_ADDR
// if not tmp then
1488: LD_VAR 0 5
1492: NOT
1493: IFFALSE 1497
// exit ;
1495: GO 1549
// for i in tmp do
1497: LD_ADDR_VAR 0 4
1501: PUSH
1502: LD_VAR 0 5
1506: PUSH
1507: FOR_IN
1508: IFFALSE 1533
// result := result ^ IsDrivenBy ( i ) ;
1510: LD_ADDR_VAR 0 3
1514: PUSH
1515: LD_VAR 0 3
1519: PUSH
1520: LD_VAR 0 4
1524: PPUSH
1525: CALL_OW 311
1529: ADD
1530: ST_TO_ADDR
1531: GO 1507
1533: POP
1534: POP
// result := result diff 0 ;
1535: LD_ADDR_VAR 0 3
1539: PUSH
1540: LD_VAR 0 3
1544: PUSH
1545: LD_INT 0
1547: DIFF
1548: ST_TO_ADDR
// end ;
1549: LD_VAR 0 3
1553: RET
// export function FilterBuildings ( side ) ; begin
1554: LD_INT 0
1556: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
1557: LD_ADDR_VAR 0 2
1561: PUSH
1562: LD_INT 22
1564: PUSH
1565: LD_VAR 0 1
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: PUSH
1574: LD_INT 21
1576: PUSH
1577: LD_INT 3
1579: PUSH
1580: EMPTY
1581: LIST
1582: LIST
1583: PUSH
1584: EMPTY
1585: LIST
1586: LIST
1587: PPUSH
1588: CALL_OW 69
1592: ST_TO_ADDR
// end ;
1593: LD_VAR 0 2
1597: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
1598: LD_INT 0
1600: PPUSH
1601: PPUSH
1602: PPUSH
1603: PPUSH
// uc_side = 0 ;
1604: LD_ADDR_OWVAR 20
1608: PUSH
1609: LD_INT 0
1611: ST_TO_ADDR
// uc_nation = 0 ;
1612: LD_ADDR_OWVAR 21
1616: PUSH
1617: LD_INT 0
1619: ST_TO_ADDR
// nat_area := wildArea ;
1620: LD_ADDR_VAR 0 4
1624: PUSH
1625: LD_INT 3
1627: ST_TO_ADDR
// InitHc ;
1628: CALL_OW 19
// for i = 1 to 4 do
1632: LD_ADDR_VAR 0 2
1636: PUSH
1637: DOUBLE
1638: LD_INT 1
1640: DEC
1641: ST_TO_ADDR
1642: LD_INT 4
1644: PUSH
1645: FOR_TO
1646: IFFALSE 1701
// begin hc_class = 18 ;
1648: LD_ADDR_OWVAR 28
1652: PUSH
1653: LD_INT 18
1655: ST_TO_ADDR
// hc_gallery =  ;
1656: LD_ADDR_OWVAR 33
1660: PUSH
1661: LD_STRING 
1663: ST_TO_ADDR
// hc_face_number = 1 ;
1664: LD_ADDR_OWVAR 34
1668: PUSH
1669: LD_INT 1
1671: ST_TO_ADDR
// animal := CreateHuman ;
1672: LD_ADDR_VAR 0 3
1676: PUSH
1677: CALL_OW 44
1681: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1682: LD_VAR 0 3
1686: PPUSH
1687: LD_VAR 0 4
1691: PPUSH
1692: LD_INT 0
1694: PPUSH
1695: CALL_OW 49
// end ;
1699: GO 1645
1701: POP
1702: POP
// for i = 1 to 6 do
1703: LD_ADDR_VAR 0 2
1707: PUSH
1708: DOUBLE
1709: LD_INT 1
1711: DEC
1712: ST_TO_ADDR
1713: LD_INT 6
1715: PUSH
1716: FOR_TO
1717: IFFALSE 1788
// begin hc_class = class_tiger ;
1719: LD_ADDR_OWVAR 28
1723: PUSH
1724: LD_INT 14
1726: ST_TO_ADDR
// hc_gallery =  ;
1727: LD_ADDR_OWVAR 33
1731: PUSH
1732: LD_STRING 
1734: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 10 ) ;
1735: LD_ADDR_OWVAR 35
1739: PUSH
1740: LD_INT 0
1742: PPUSH
1743: LD_INT 10
1745: PPUSH
1746: CALL_OW 12
1750: ST_TO_ADDR
// hc_face_number = 3 ;
1751: LD_ADDR_OWVAR 34
1755: PUSH
1756: LD_INT 3
1758: ST_TO_ADDR
// animal := CreateHuman ;
1759: LD_ADDR_VAR 0 3
1763: PUSH
1764: CALL_OW 44
1768: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1769: LD_VAR 0 3
1773: PPUSH
1774: LD_VAR 0 4
1778: PPUSH
1779: LD_INT 0
1781: PPUSH
1782: CALL_OW 49
// end ;
1786: GO 1716
1788: POP
1789: POP
// for i = 1 to 2 do
1790: LD_ADDR_VAR 0 2
1794: PUSH
1795: DOUBLE
1796: LD_INT 1
1798: DEC
1799: ST_TO_ADDR
1800: LD_INT 2
1802: PUSH
1803: FOR_TO
1804: IFFALSE 1867
// begin hc_class = 21 ;
1806: LD_ADDR_OWVAR 28
1810: PUSH
1811: LD_INT 21
1813: ST_TO_ADDR
// hc_gallery =  ;
1814: LD_ADDR_OWVAR 33
1818: PUSH
1819: LD_STRING 
1821: ST_TO_ADDR
// hc_agressivity = 0 ;
1822: LD_ADDR_OWVAR 35
1826: PUSH
1827: LD_INT 0
1829: ST_TO_ADDR
// hc_face_number = 5 ;
1830: LD_ADDR_OWVAR 34
1834: PUSH
1835: LD_INT 5
1837: ST_TO_ADDR
// animal := CreateHuman ;
1838: LD_ADDR_VAR 0 3
1842: PUSH
1843: CALL_OW 44
1847: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1848: LD_VAR 0 3
1852: PPUSH
1853: LD_VAR 0 4
1857: PPUSH
1858: LD_INT 0
1860: PPUSH
1861: CALL_OW 49
// end ;
1865: GO 1803
1867: POP
1868: POP
// for i = 1 to 6 do
1869: LD_ADDR_VAR 0 2
1873: PUSH
1874: DOUBLE
1875: LD_INT 1
1877: DEC
1878: ST_TO_ADDR
1879: LD_INT 6
1881: PUSH
1882: FOR_TO
1883: IFFALSE 1938
// begin hc_class = 13 ;
1885: LD_ADDR_OWVAR 28
1889: PUSH
1890: LD_INT 13
1892: ST_TO_ADDR
// hc_gallery =  ;
1893: LD_ADDR_OWVAR 33
1897: PUSH
1898: LD_STRING 
1900: ST_TO_ADDR
// hc_face_number = 4 ;
1901: LD_ADDR_OWVAR 34
1905: PUSH
1906: LD_INT 4
1908: ST_TO_ADDR
// animal := CreateHuman ;
1909: LD_ADDR_VAR 0 3
1913: PUSH
1914: CALL_OW 44
1918: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1919: LD_VAR 0 3
1923: PPUSH
1924: LD_VAR 0 4
1928: PPUSH
1929: LD_INT 0
1931: PPUSH
1932: CALL_OW 49
// end ;
1936: GO 1882
1938: POP
1939: POP
// for i = 1 to 2 do
1940: LD_ADDR_VAR 0 2
1944: PUSH
1945: DOUBLE
1946: LD_INT 1
1948: DEC
1949: ST_TO_ADDR
1950: LD_INT 2
1952: PUSH
1953: FOR_TO
1954: IFFALSE 2013
// begin hc_class = 20 ;
1956: LD_ADDR_OWVAR 28
1960: PUSH
1961: LD_INT 20
1963: ST_TO_ADDR
// hc_gallery =  ;
1964: LD_ADDR_OWVAR 33
1968: PUSH
1969: LD_STRING 
1971: ST_TO_ADDR
// hc_face_number = 2 ;
1972: LD_ADDR_OWVAR 34
1976: PUSH
1977: LD_INT 2
1979: ST_TO_ADDR
// animal := CreateHuman ;
1980: LD_ADDR_VAR 0 3
1984: PUSH
1985: CALL_OW 44
1989: ST_TO_ADDR
// PlaceUnitXYR ( animal , 101 , 37 , 3 , false ) ;
1990: LD_VAR 0 3
1994: PPUSH
1995: LD_INT 101
1997: PPUSH
1998: LD_INT 37
2000: PPUSH
2001: LD_INT 3
2003: PPUSH
2004: LD_INT 0
2006: PPUSH
2007: CALL_OW 50
// end ;
2011: GO 1953
2013: POP
2014: POP
// for i = 1 to 1 do
2015: LD_ADDR_VAR 0 2
2019: PUSH
2020: DOUBLE
2021: LD_INT 1
2023: DEC
2024: ST_TO_ADDR
2025: LD_INT 1
2027: PUSH
2028: FOR_TO
2029: IFFALSE 2076
// begin vc_chassis := 31 ;
2031: LD_ADDR_OWVAR 37
2035: PUSH
2036: LD_INT 31
2038: ST_TO_ADDR
// vc_control := control_rider ;
2039: LD_ADDR_OWVAR 38
2043: PUSH
2044: LD_INT 4
2046: ST_TO_ADDR
// animal := CreateVehicle ;
2047: LD_ADDR_VAR 0 3
2051: PUSH
2052: CALL_OW 45
2056: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
2057: LD_VAR 0 3
2061: PPUSH
2062: LD_VAR 0 4
2066: PPUSH
2067: LD_INT 0
2069: PPUSH
2070: CALL_OW 49
// end ;
2074: GO 2028
2076: POP
2077: POP
// end ; end_of_file
2078: LD_VAR 0 1
2082: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
2083: LD_INT 0
2085: PPUSH
2086: PPUSH
2087: PPUSH
2088: PPUSH
2089: PPUSH
2090: PPUSH
// uc_side := 1 ;
2091: LD_ADDR_OWVAR 20
2095: PUSH
2096: LD_INT 1
2098: ST_TO_ADDR
// uc_nation := 1 ;
2099: LD_ADDR_OWVAR 21
2103: PUSH
2104: LD_INT 1
2106: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
2107: LD_ADDR_EXP 8
2111: PUSH
2112: LD_STRING JMM
2114: PPUSH
2115: LD_EXP 1
2119: NOT
2120: PPUSH
2121: CALL 354 0 2
2125: ST_TO_ADDR
// team := [ JMM ] ;
2126: LD_ADDR_VAR 0 3
2130: PUSH
2131: LD_EXP 8
2135: PUSH
2136: EMPTY
2137: LIST
2138: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
2139: LD_STRING BrownIn07
2141: PPUSH
2142: LD_EXP 1
2146: PPUSH
2147: CALL_OW 30
2151: IFFALSE 2172
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
2153: LD_ADDR_EXP 9
2157: PUSH
2158: LD_STRING Brown
2160: PPUSH
2161: LD_EXP 1
2165: NOT
2166: PPUSH
2167: CALL 354 0 2
2171: ST_TO_ADDR
// if Brown then
2172: LD_EXP 9
2176: IFFALSE 2194
// team := team ^ Brown ;
2178: LD_ADDR_VAR 0 3
2182: PUSH
2183: LD_VAR 0 3
2187: PUSH
2188: LD_EXP 9
2192: ADD
2193: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
2194: LD_STRING DonaldsonIn07
2196: PPUSH
2197: LD_EXP 1
2201: PPUSH
2202: CALL_OW 30
2206: IFFALSE 2227
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
2208: LD_ADDR_EXP 10
2212: PUSH
2213: LD_STRING Donaldson
2215: PPUSH
2216: LD_EXP 1
2220: NOT
2221: PPUSH
2222: CALL 354 0 2
2226: ST_TO_ADDR
// if Donaldson then
2227: LD_EXP 10
2231: IFFALSE 2249
// team := team ^ Donaldson ;
2233: LD_ADDR_VAR 0 3
2237: PUSH
2238: LD_VAR 0 3
2242: PUSH
2243: LD_EXP 10
2247: ADD
2248: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
2249: LD_STRING BobbyIn07
2251: PPUSH
2252: LD_EXP 1
2256: PPUSH
2257: CALL_OW 30
2261: IFFALSE 2282
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
2263: LD_ADDR_EXP 11
2267: PUSH
2268: LD_STRING Bobby
2270: PPUSH
2271: LD_EXP 1
2275: NOT
2276: PPUSH
2277: CALL 354 0 2
2281: ST_TO_ADDR
// if Bobby then
2282: LD_EXP 11
2286: IFFALSE 2304
// team := team ^ Bobby ;
2288: LD_ADDR_VAR 0 3
2292: PUSH
2293: LD_VAR 0 3
2297: PUSH
2298: LD_EXP 11
2302: ADD
2303: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
2304: LD_STRING CyrusIn07
2306: PPUSH
2307: LD_EXP 1
2311: PPUSH
2312: CALL_OW 30
2316: IFFALSE 2337
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
2318: LD_ADDR_EXP 12
2322: PUSH
2323: LD_STRING Cyrus
2325: PPUSH
2326: LD_EXP 1
2330: NOT
2331: PPUSH
2332: CALL 354 0 2
2336: ST_TO_ADDR
// if Cyrus then
2337: LD_EXP 12
2341: IFFALSE 2359
// team := team ^ Cyrus ;
2343: LD_ADDR_VAR 0 3
2347: PUSH
2348: LD_VAR 0 3
2352: PUSH
2353: LD_EXP 12
2357: ADD
2358: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
2359: LD_STRING LisaIn07
2361: PPUSH
2362: LD_EXP 1
2366: PPUSH
2367: CALL_OW 30
2371: IFFALSE 2392
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
2373: LD_ADDR_EXP 13
2377: PUSH
2378: LD_STRING Lisa
2380: PPUSH
2381: LD_EXP 1
2385: NOT
2386: PPUSH
2387: CALL 354 0 2
2391: ST_TO_ADDR
// if Lisa then
2392: LD_EXP 13
2396: IFFALSE 2414
// team := team ^ Lisa ;
2398: LD_ADDR_VAR 0 3
2402: PUSH
2403: LD_VAR 0 3
2407: PUSH
2408: LD_EXP 13
2412: ADD
2413: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
2414: LD_STRING GladstoneIn07
2416: PPUSH
2417: LD_EXP 1
2421: PPUSH
2422: CALL_OW 30
2426: IFFALSE 2447
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
2428: LD_ADDR_EXP 15
2432: PUSH
2433: LD_STRING Gladstone
2435: PPUSH
2436: LD_EXP 1
2440: NOT
2441: PPUSH
2442: CALL 354 0 2
2446: ST_TO_ADDR
// if Gladstone then
2447: LD_EXP 15
2451: IFFALSE 2469
// team := team ^ Gladstone ;
2453: LD_ADDR_VAR 0 3
2457: PUSH
2458: LD_VAR 0 3
2462: PUSH
2463: LD_EXP 15
2467: ADD
2468: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
2469: LD_STRING KhatamIn07
2471: PPUSH
2472: LD_EXP 1
2476: PPUSH
2477: CALL_OW 30
2481: IFFALSE 2502
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
2483: LD_ADDR_EXP 16
2487: PUSH
2488: LD_STRING Khatam
2490: PPUSH
2491: LD_EXP 1
2495: NOT
2496: PPUSH
2497: CALL 354 0 2
2501: ST_TO_ADDR
// if Khatam then
2502: LD_EXP 16
2506: IFFALSE 2524
// team := team ^ Khatam ;
2508: LD_ADDR_VAR 0 3
2512: PUSH
2513: LD_VAR 0 3
2517: PUSH
2518: LD_EXP 16
2522: ADD
2523: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
2524: LD_ADDR_VAR 0 4
2528: PUSH
2529: LD_STRING 07_others
2531: PPUSH
2532: CALL_OW 31
2536: ST_TO_ADDR
// if others then
2537: LD_VAR 0 4
2541: IFFALSE 2559
// team := team ^ others ;
2543: LD_ADDR_VAR 0 3
2547: PUSH
2548: LD_VAR 0 3
2552: PUSH
2553: LD_VAR 0 4
2557: ADD
2558: ST_TO_ADDR
// if debug then
2559: LD_EXP 1
2563: IFFALSE 2637
// begin InitHc ;
2565: CALL_OW 19
// for i = 1 to 4 do
2569: LD_ADDR_VAR 0 2
2573: PUSH
2574: DOUBLE
2575: LD_INT 1
2577: DEC
2578: ST_TO_ADDR
2579: LD_INT 4
2581: PUSH
2582: FOR_TO
2583: IFFALSE 2635
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
2585: LD_INT 0
2587: PPUSH
2588: LD_INT 1
2590: PUSH
2591: LD_INT 3
2593: PUSH
2594: EMPTY
2595: LIST
2596: LIST
2597: PUSH
2598: LD_INT 1
2600: PPUSH
2601: LD_INT 2
2603: PPUSH
2604: CALL_OW 12
2608: ARRAY
2609: PPUSH
2610: LD_INT 4
2612: PPUSH
2613: CALL_OW 380
// team := team ^ CreateHuman ;
2617: LD_ADDR_VAR 0 3
2621: PUSH
2622: LD_VAR 0 3
2626: PUSH
2627: CALL_OW 44
2631: ADD
2632: ST_TO_ADDR
// end ;
2633: GO 2582
2635: POP
2636: POP
// end ; m := 0 ;
2637: LD_ADDR_VAR 0 6
2641: PUSH
2642: LD_INT 0
2644: ST_TO_ADDR
// for i in team do
2645: LD_ADDR_VAR 0 2
2649: PUSH
2650: LD_VAR 0 3
2654: PUSH
2655: FOR_IN
2656: IFFALSE 2836
// if GetClass ( i ) = 3 then
2658: LD_VAR 0 2
2662: PPUSH
2663: CALL_OW 257
2667: PUSH
2668: LD_INT 3
2670: EQUAL
2671: IFFALSE 2819
// begin m := m + 1 ;
2673: LD_ADDR_VAR 0 6
2677: PUSH
2678: LD_VAR 0 6
2682: PUSH
2683: LD_INT 1
2685: PLUS
2686: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
2687: LD_ADDR_VAR 0 5
2691: PUSH
2692: LD_INT 1
2694: PPUSH
2695: LD_INT 1
2697: PPUSH
2698: LD_INT 2
2700: PUSH
2701: LD_INT 3
2703: PUSH
2704: LD_INT 2
2706: PUSH
2707: LD_INT 1
2709: PUSH
2710: EMPTY
2711: LIST
2712: LIST
2713: LIST
2714: LIST
2715: PUSH
2716: LD_VAR 0 6
2720: PUSH
2721: LD_INT 4
2723: MOD
2724: PUSH
2725: LD_INT 1
2727: PLUS
2728: ARRAY
2729: PPUSH
2730: LD_INT 2
2732: PPUSH
2733: LD_INT 1
2735: PPUSH
2736: LD_INT 4
2738: PUSH
2739: LD_INT 5
2741: PUSH
2742: LD_INT 3
2744: PUSH
2745: LD_INT 11
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: LIST
2752: LIST
2753: PUSH
2754: LD_VAR 0 6
2758: PUSH
2759: LD_INT 4
2761: MOD
2762: PUSH
2763: LD_INT 1
2765: PLUS
2766: ARRAY
2767: PPUSH
2768: LD_INT 60
2770: PPUSH
2771: CALL 417 0 7
2775: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2776: LD_VAR 0 5
2780: PPUSH
2781: LD_INT 2
2783: PPUSH
2784: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
2788: LD_VAR 0 5
2792: PPUSH
2793: LD_INT 1
2795: PPUSH
2796: LD_INT 0
2798: PPUSH
2799: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2803: LD_VAR 0 2
2807: PPUSH
2808: LD_VAR 0 5
2812: PPUSH
2813: CALL_OW 52
// end else
2817: GO 2834
// PlaceUnitArea ( i , startArea , false ) ;
2819: LD_VAR 0 2
2823: PPUSH
2824: LD_INT 1
2826: PPUSH
2827: LD_INT 0
2829: PPUSH
2830: CALL_OW 49
2834: GO 2655
2836: POP
2837: POP
// uc_side := 4 ;
2838: LD_ADDR_OWVAR 20
2842: PUSH
2843: LD_INT 4
2845: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
2846: LD_ADDR_EXP 18
2850: PUSH
2851: LD_STRING Harisson
2853: PPUSH
2854: LD_INT 0
2856: PPUSH
2857: CALL 354 0 2
2861: ST_TO_ADDR
// PrepareScout ;
2862: CALL 2871 0 0
// end ;
2866: LD_VAR 0 1
2870: RET
// function PrepareScout ; var ape ; begin
2871: LD_INT 0
2873: PPUSH
2874: PPUSH
// uc_side := 4 ;
2875: LD_ADDR_OWVAR 20
2879: PUSH
2880: LD_INT 4
2882: ST_TO_ADDR
// uc_nation := 1 ;
2883: LD_ADDR_OWVAR 21
2887: PUSH
2888: LD_INT 1
2890: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
2891: LD_STRING FrankIn06
2893: PPUSH
2894: LD_INT 0
2896: PPUSH
2897: CALL_OW 30
2901: IFFALSE 2918
// Frank := CreateCharacter ( 06c_Frank ) else
2903: LD_ADDR_EXP 14
2907: PUSH
2908: LD_STRING 06c_Frank
2910: PPUSH
2911: CALL_OW 34
2915: ST_TO_ADDR
2916: GO 2958
// if LoadVariable ( FrankInDelta , 0 ) then
2918: LD_STRING FrankInDelta
2920: PPUSH
2921: LD_INT 0
2923: PPUSH
2924: CALL_OW 30
2928: IFFALSE 2945
// Frank := CreateCharacter ( 05_Frank ) else
2930: LD_ADDR_EXP 14
2934: PUSH
2935: LD_STRING 05_Frank
2937: PPUSH
2938: CALL_OW 34
2942: ST_TO_ADDR
2943: GO 2958
// Frank := CreateCharacter ( 04_Frank ) ;
2945: LD_ADDR_EXP 14
2949: PUSH
2950: LD_STRING 04_Frank
2952: PPUSH
2953: CALL_OW 34
2957: ST_TO_ADDR
// if Frank then
2958: LD_EXP 14
2962: IFFALSE 3095
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
2964: LD_EXP 14
2968: PPUSH
2969: LD_INT 2
2971: PPUSH
2972: LD_INT 0
2974: PPUSH
2975: CALL_OW 49
// SetClass ( Frank , 1 ) ;
2979: LD_EXP 14
2983: PPUSH
2984: LD_INT 1
2986: PPUSH
2987: CALL_OW 336
// uc_side := 0 ;
2991: LD_ADDR_OWVAR 20
2995: PUSH
2996: LD_INT 0
2998: ST_TO_ADDR
// uc_nation := 0 ;
2999: LD_ADDR_OWVAR 21
3003: PUSH
3004: LD_INT 0
3006: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
3007: LD_INT 0
3009: PPUSH
3010: LD_INT 12
3012: PPUSH
3013: LD_INT 0
3015: PPUSH
3016: CALL_OW 380
// ape := CreateHuman ;
3020: LD_ADDR_VAR 0 2
3024: PUSH
3025: CALL_OW 44
3029: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
3030: LD_VAR 0 2
3034: PPUSH
3035: LD_EXP 14
3039: PPUSH
3040: CALL_OW 250
3044: PPUSH
3045: LD_EXP 14
3049: PPUSH
3050: CALL_OW 251
3054: PPUSH
3055: LD_INT 5
3057: PPUSH
3058: LD_INT 0
3060: PPUSH
3061: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
3065: LD_VAR 0 2
3069: PPUSH
3070: LD_EXP 14
3074: PPUSH
3075: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
3079: LD_EXP 14
3083: PPUSH
3084: LD_VAR 0 2
3088: PPUSH
3089: CALL_OW 119
// exit ;
3093: GO 3135
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
3095: LD_ADDR_EXP 17
3099: PUSH
3100: LD_STRING Yamoko
3102: PPUSH
3103: LD_INT 0
3105: PPUSH
3106: CALL 354 0 2
3110: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
3111: LD_EXP 17
3115: PPUSH
3116: LD_INT 2
3118: PPUSH
3119: LD_INT 0
3121: PPUSH
3122: CALL_OW 49
// ComHold ( Kikuchi ) ;
3126: LD_EXP 17
3130: PPUSH
3131: CALL_OW 140
// end ; end_of_file
3135: LD_VAR 0 1
3139: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
3140: LD_INT 0
3142: PPUSH
3143: PPUSH
3144: PPUSH
3145: PPUSH
3146: PPUSH
3147: PPUSH
3148: PPUSH
3149: PPUSH
3150: PPUSH
3151: PPUSH
3152: PPUSH
3153: PPUSH
3154: PPUSH
3155: PPUSH
3156: PPUSH
3157: PPUSH
// ru_rebuild_list := [ ] ;
3158: LD_ADDR_EXP 19
3162: PUSH
3163: EMPTY
3164: ST_TO_ADDR
// uc_side := 3 ;
3165: LD_ADDR_OWVAR 20
3169: PUSH
3170: LD_INT 3
3172: ST_TO_ADDR
// uc_nation := 3 ;
3173: LD_ADDR_OWVAR 21
3177: PUSH
3178: LD_INT 3
3180: ST_TO_ADDR
// if Difficulty > 1 then
3181: LD_OWVAR 67
3185: PUSH
3186: LD_INT 1
3188: GREATER
3189: IFFALSE 3325
// begin bc_type := b_breastwork ;
3191: LD_ADDR_OWVAR 42
3195: PUSH
3196: LD_INT 31
3198: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
3199: LD_INT 78
3201: PPUSH
3202: LD_INT 74
3204: PPUSH
3205: LD_INT 2
3207: PPUSH
3208: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
3212: LD_INT 171
3214: PPUSH
3215: LD_INT 193
3217: PPUSH
3218: LD_INT 4
3220: PPUSH
3221: CALL_OW 47
// bc_type := b_turret ;
3225: LD_ADDR_OWVAR 42
3229: PUSH
3230: LD_INT 33
3232: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
3233: LD_INT 129
3235: PPUSH
3236: LD_INT 96
3238: PPUSH
3239: LD_INT 3
3241: PPUSH
3242: CALL_OW 47
// if Difficulty > 2 then
3246: LD_OWVAR 67
3250: PUSH
3251: LD_INT 2
3253: GREATER
3254: IFFALSE 3325
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
3256: LD_INT 83
3258: PPUSH
3259: LD_INT 141
3261: PPUSH
3262: CALL_OW 428
3266: PPUSH
3267: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
3271: LD_INT 78
3273: PPUSH
3274: LD_INT 133
3276: PPUSH
3277: CALL_OW 428
3281: PPUSH
3282: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
3286: LD_INT 83
3288: PPUSH
3289: LD_INT 141
3291: PPUSH
3292: LD_INT 2
3294: PPUSH
3295: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
3299: LD_INT 78
3301: PPUSH
3302: LD_INT 133
3304: PPUSH
3305: LD_INT 2
3307: PPUSH
3308: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
3312: LD_INT 145
3314: PPUSH
3315: LD_INT 112
3317: PPUSH
3318: LD_INT 3
3320: PPUSH
3321: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
3325: LD_ADDR_VAR 0 9
3329: PUSH
3330: LD_INT 22
3332: PUSH
3333: LD_INT 3
3335: PUSH
3336: EMPTY
3337: LIST
3338: LIST
3339: PUSH
3340: LD_INT 2
3342: PUSH
3343: LD_INT 30
3345: PUSH
3346: LD_INT 0
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: PUSH
3353: LD_INT 30
3355: PUSH
3356: LD_INT 1
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: LIST
3367: PUSH
3368: EMPTY
3369: LIST
3370: LIST
3371: PPUSH
3372: CALL_OW 69
3376: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
3377: LD_ADDR_VAR 0 10
3381: PUSH
3382: LD_INT 22
3384: PUSH
3385: LD_INT 3
3387: PUSH
3388: EMPTY
3389: LIST
3390: LIST
3391: PUSH
3392: LD_INT 2
3394: PUSH
3395: LD_INT 30
3397: PUSH
3398: LD_INT 6
3400: PUSH
3401: EMPTY
3402: LIST
3403: LIST
3404: PUSH
3405: LD_INT 30
3407: PUSH
3408: LD_INT 7
3410: PUSH
3411: EMPTY
3412: LIST
3413: LIST
3414: PUSH
3415: LD_INT 30
3417: PUSH
3418: LD_INT 8
3420: PUSH
3421: EMPTY
3422: LIST
3423: LIST
3424: PUSH
3425: EMPTY
3426: LIST
3427: LIST
3428: LIST
3429: LIST
3430: PUSH
3431: EMPTY
3432: LIST
3433: LIST
3434: PPUSH
3435: CALL_OW 69
3439: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3440: LD_ADDR_VAR 0 11
3444: PUSH
3445: LD_INT 22
3447: PUSH
3448: LD_INT 3
3450: PUSH
3451: EMPTY
3452: LIST
3453: LIST
3454: PUSH
3455: LD_INT 30
3457: PUSH
3458: LD_INT 3
3460: PUSH
3461: EMPTY
3462: LIST
3463: LIST
3464: PUSH
3465: EMPTY
3466: LIST
3467: LIST
3468: PPUSH
3469: CALL_OW 69
3473: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
3474: LD_ADDR_VAR 0 12
3478: PUSH
3479: LD_INT 22
3481: PUSH
3482: LD_INT 3
3484: PUSH
3485: EMPTY
3486: LIST
3487: LIST
3488: PUSH
3489: LD_INT 30
3491: PUSH
3492: LD_INT 31
3494: PUSH
3495: EMPTY
3496: LIST
3497: LIST
3498: PUSH
3499: EMPTY
3500: LIST
3501: LIST
3502: PPUSH
3503: CALL_OW 69
3507: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
3508: LD_ADDR_VAR 0 13
3512: PUSH
3513: LD_INT 22
3515: PUSH
3516: LD_INT 3
3518: PUSH
3519: EMPTY
3520: LIST
3521: LIST
3522: PUSH
3523: LD_INT 30
3525: PUSH
3526: LD_INT 32
3528: PUSH
3529: EMPTY
3530: LIST
3531: LIST
3532: PUSH
3533: EMPTY
3534: LIST
3535: LIST
3536: PPUSH
3537: CALL_OW 69
3541: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3542: LD_ADDR_VAR 0 14
3546: PUSH
3547: LD_INT 22
3549: PUSH
3550: LD_INT 3
3552: PUSH
3553: EMPTY
3554: LIST
3555: LIST
3556: PUSH
3557: LD_INT 30
3559: PUSH
3560: LD_INT 33
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: PUSH
3567: EMPTY
3568: LIST
3569: LIST
3570: PPUSH
3571: CALL_OW 69
3575: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
3576: LD_ADDR_VAR 0 15
3580: PUSH
3581: LD_INT 42
3583: PUSH
3584: LD_INT 5
3586: PUSH
3587: EMPTY
3588: LIST
3589: LIST
3590: PUSH
3591: LD_INT 43
3593: PUSH
3594: LD_INT 50
3596: PUSH
3597: EMPTY
3598: LIST
3599: LIST
3600: PUSH
3601: LD_INT 44
3603: PUSH
3604: LD_INT 30
3606: PUSH
3607: EMPTY
3608: LIST
3609: LIST
3610: PUSH
3611: LD_INT 46
3613: PUSH
3614: LD_INT 15
3616: PUSH
3617: EMPTY
3618: LIST
3619: LIST
3620: PUSH
3621: EMPTY
3622: LIST
3623: LIST
3624: LIST
3625: LIST
3626: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 6 , 3 ] ;
3627: LD_ADDR_VAR 0 16
3631: PUSH
3632: LD_INT 0
3634: PUSH
3635: LD_INT 4
3637: PUSH
3638: LD_INT 6
3640: PUSH
3641: LD_INT 3
3643: PUSH
3644: EMPTY
3645: LIST
3646: LIST
3647: LIST
3648: LIST
3649: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
3650: LD_ADDR_VAR 0 6
3654: PUSH
3655: LD_INT 4
3657: PUSH
3658: LD_INT 5
3660: PUSH
3661: LD_INT 6
3663: PUSH
3664: EMPTY
3665: LIST
3666: LIST
3667: LIST
3668: PUSH
3669: LD_OWVAR 67
3673: ARRAY
3674: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
3675: LD_INT 16
3677: PPUSH
3678: LD_STRING am_tukh
3680: PPUSH
3681: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
3685: LD_ADDR_VAR 0 2
3689: PUSH
3690: LD_INT 21
3692: PUSH
3693: LD_INT 3
3695: PUSH
3696: EMPTY
3697: LIST
3698: LIST
3699: PPUSH
3700: CALL_OW 69
3704: PUSH
3705: FOR_IN
3706: IFFALSE 3739
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
3708: LD_VAR 0 2
3712: PPUSH
3713: LD_INT 4
3715: PUSH
3716: LD_INT 5
3718: PUSH
3719: LD_INT 6
3721: PUSH
3722: EMPTY
3723: LIST
3724: LIST
3725: LIST
3726: PUSH
3727: LD_OWVAR 67
3731: ARRAY
3732: PPUSH
3733: CALL_OW 241
3737: GO 3705
3739: POP
3740: POP
// for i in dep_list do
3741: LD_ADDR_VAR 0 2
3745: PUSH
3746: LD_VAR 0 9
3750: PUSH
3751: FOR_IN
3752: IFFALSE 3796
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
3754: LD_VAR 0 2
3758: PPUSH
3759: CALL_OW 274
3763: PPUSH
3764: LD_INT 1
3766: PPUSH
3767: LD_INT 1000
3769: PPUSH
3770: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
3774: LD_VAR 0 2
3778: PPUSH
3779: CALL_OW 274
3783: PPUSH
3784: LD_INT 2
3786: PPUSH
3787: LD_INT 1000
3789: PPUSH
3790: CALL_OW 277
// end ;
3794: GO 3751
3796: POP
3797: POP
// InitHc ;
3798: CALL_OW 19
// tmp := bunker_list * [ 50 , 70 , 85 ] [ Difficulty ] div 100 ;
3802: LD_ADDR_VAR 0 8
3806: PUSH
3807: LD_VAR 0 13
3811: PUSH
3812: LD_INT 50
3814: PUSH
3815: LD_INT 70
3817: PUSH
3818: LD_INT 85
3820: PUSH
3821: EMPTY
3822: LIST
3823: LIST
3824: LIST
3825: PUSH
3826: LD_OWVAR 67
3830: ARRAY
3831: MUL
3832: PUSH
3833: LD_INT 100
3835: DIV
3836: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
3837: LD_ADDR_VAR 0 16
3841: PUSH
3842: LD_VAR 0 16
3846: PPUSH
3847: LD_INT 1
3849: PPUSH
3850: LD_VAR 0 8
3854: PPUSH
3855: CALL_OW 1
3859: ST_TO_ADDR
// tmp := [ ] ;
3860: LD_ADDR_VAR 0 8
3864: PUSH
3865: EMPTY
3866: ST_TO_ADDR
// for i in bunker_list do
3867: LD_ADDR_VAR 0 2
3871: PUSH
3872: LD_VAR 0 13
3876: PUSH
3877: FOR_IN
3878: IFFALSE 3974
// if i mod 10 + 1 < tmp then
3880: LD_VAR 0 2
3884: PUSH
3885: LD_INT 10
3887: MOD
3888: PUSH
3889: LD_INT 1
3891: PLUS
3892: PUSH
3893: LD_VAR 0 8
3897: LESS
3898: IFFALSE 3943
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
3900: LD_ADDR_VAR 0 8
3904: PUSH
3905: LD_VAR 0 8
3909: PPUSH
3910: LD_VAR 0 2
3914: PUSH
3915: LD_INT 3
3917: PPUSH
3918: LD_INT 5
3920: PPUSH
3921: CALL_OW 12
3925: MOD
3926: PUSH
3927: LD_INT 1
3929: PLUS
3930: PPUSH
3931: LD_VAR 0 2
3935: PPUSH
3936: CALL_OW 2
3940: ST_TO_ADDR
3941: GO 3972
// tmp := Insert ( tmp , tmp + 1 , i ) ;
3943: LD_ADDR_VAR 0 8
3947: PUSH
3948: LD_VAR 0 8
3952: PPUSH
3953: LD_VAR 0 8
3957: PUSH
3958: LD_INT 1
3960: PLUS
3961: PPUSH
3962: LD_VAR 0 2
3966: PPUSH
3967: CALL_OW 2
3971: ST_TO_ADDR
3972: GO 3877
3974: POP
3975: POP
// bunker_list := tmp ;
3976: LD_ADDR_VAR 0 13
3980: PUSH
3981: LD_VAR 0 8
3985: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
3986: LD_ADDR_VAR 0 2
3990: PUSH
3991: LD_VAR 0 13
3995: PUSH
3996: LD_VAR 0 14
4000: ADD
4001: PUSH
4002: FOR_IN
4003: IFFALSE 4100
// begin tmp := rand ( 0 , 100 ) ;
4005: LD_ADDR_VAR 0 8
4009: PUSH
4010: LD_INT 0
4012: PPUSH
4013: LD_INT 100
4015: PPUSH
4016: CALL_OW 12
4020: ST_TO_ADDR
// r := 0 ;
4021: LD_ADDR_VAR 0 4
4025: PUSH
4026: LD_INT 0
4028: ST_TO_ADDR
// for j in weapons_list do
4029: LD_ADDR_VAR 0 3
4033: PUSH
4034: LD_VAR 0 15
4038: PUSH
4039: FOR_IN
4040: IFFALSE 4096
// begin r := r + j [ 2 ] ;
4042: LD_ADDR_VAR 0 4
4046: PUSH
4047: LD_VAR 0 4
4051: PUSH
4052: LD_VAR 0 3
4056: PUSH
4057: LD_INT 2
4059: ARRAY
4060: PLUS
4061: ST_TO_ADDR
// if r >= tmp then
4062: LD_VAR 0 4
4066: PUSH
4067: LD_VAR 0 8
4071: GREATEREQUAL
4072: IFFALSE 4094
// begin PlaceWeaponTurret ( i , j [ 1 ] ) ;
4074: LD_VAR 0 2
4078: PPUSH
4079: LD_VAR 0 3
4083: PUSH
4084: LD_INT 1
4086: ARRAY
4087: PPUSH
4088: CALL_OW 431
// break ;
4092: GO 4096
// end ; end ;
4094: GO 4039
4096: POP
4097: POP
// end ;
4098: GO 4002
4100: POP
4101: POP
// while ( personel_counter [ 1 ] ) do
4102: LD_VAR 0 16
4106: PUSH
4107: LD_INT 1
4109: ARRAY
4110: IFFALSE 4218
// begin i := rand ( 1 , bunker_list ) ;
4112: LD_ADDR_VAR 0 2
4116: PUSH
4117: LD_INT 1
4119: PPUSH
4120: LD_VAR 0 13
4124: PPUSH
4125: CALL_OW 12
4129: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4130: LD_INT 0
4132: PPUSH
4133: LD_INT 1
4135: PPUSH
4136: LD_VAR 0 6
4140: PPUSH
4141: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
4145: CALL_OW 44
4149: PPUSH
4150: LD_VAR 0 13
4154: PUSH
4155: LD_VAR 0 2
4159: ARRAY
4160: PPUSH
4161: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
4165: LD_ADDR_VAR 0 13
4169: PUSH
4170: LD_VAR 0 13
4174: PPUSH
4175: LD_VAR 0 2
4179: PPUSH
4180: CALL_OW 3
4184: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
4185: LD_ADDR_VAR 0 16
4189: PUSH
4190: LD_VAR 0 16
4194: PPUSH
4195: LD_INT 1
4197: PPUSH
4198: LD_VAR 0 16
4202: PUSH
4203: LD_INT 1
4205: ARRAY
4206: PUSH
4207: LD_INT 1
4209: MINUS
4210: PPUSH
4211: CALL_OW 1
4215: ST_TO_ADDR
// end ;
4216: GO 4102
// for i = 1 to personel_counter [ 2 ] do
4218: LD_ADDR_VAR 0 2
4222: PUSH
4223: DOUBLE
4224: LD_INT 1
4226: DEC
4227: ST_TO_ADDR
4228: LD_VAR 0 16
4232: PUSH
4233: LD_INT 2
4235: ARRAY
4236: PUSH
4237: FOR_TO
4238: IFFALSE 4269
// begin PrepareHuman ( false , 2 , skill ) ;
4240: LD_INT 0
4242: PPUSH
4243: LD_INT 2
4245: PPUSH
4246: LD_VAR 0 6
4250: PPUSH
4251: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
4255: CALL_OW 44
4259: PPUSH
4260: LD_INT 16
4262: PPUSH
4263: CALL_OW 52
// end ;
4267: GO 4237
4269: POP
4270: POP
// for i = 1 to personel_counter [ 3 ] do
4271: LD_ADDR_VAR 0 2
4275: PUSH
4276: DOUBLE
4277: LD_INT 1
4279: DEC
4280: ST_TO_ADDR
4281: LD_VAR 0 16
4285: PUSH
4286: LD_INT 3
4288: ARRAY
4289: PUSH
4290: FOR_TO
4291: IFFALSE 4338
// begin PrepareHuman ( false , 3 , skill ) ;
4293: LD_INT 0
4295: PPUSH
4296: LD_INT 3
4298: PPUSH
4299: LD_VAR 0 6
4303: PPUSH
4304: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ i mod 2 + 1 ] ) ;
4308: CALL_OW 44
4312: PPUSH
4313: LD_VAR 0 11
4317: PUSH
4318: LD_VAR 0 2
4322: PUSH
4323: LD_INT 2
4325: MOD
4326: PUSH
4327: LD_INT 1
4329: PLUS
4330: ARRAY
4331: PPUSH
4332: CALL_OW 52
// end ;
4336: GO 4290
4338: POP
4339: POP
// for i = 1 to personel_counter [ 4 ] do
4340: LD_ADDR_VAR 0 2
4344: PUSH
4345: DOUBLE
4346: LD_INT 1
4348: DEC
4349: ST_TO_ADDR
4350: LD_VAR 0 16
4354: PUSH
4355: LD_INT 4
4357: ARRAY
4358: PUSH
4359: FOR_TO
4360: IFFALSE 4397
// begin PrepareHuman ( false , 4 , skill ) ;
4362: LD_INT 0
4364: PPUSH
4365: LD_INT 4
4367: PPUSH
4368: LD_VAR 0 6
4372: PPUSH
4373: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
4377: CALL_OW 44
4381: PPUSH
4382: LD_VAR 0 10
4386: PUSH
4387: LD_INT 1
4389: ARRAY
4390: PPUSH
4391: CALL_OW 52
// end ;
4395: GO 4359
4397: POP
4398: POP
// for i in breastworks_list do
4399: LD_ADDR_VAR 0 2
4403: PUSH
4404: LD_VAR 0 12
4408: PUSH
4409: FOR_IN
4410: IFFALSE 4522
// begin r := GetDir ( i ) ;
4412: LD_ADDR_VAR 0 4
4416: PUSH
4417: LD_VAR 0 2
4421: PPUSH
4422: CALL_OW 254
4426: ST_TO_ADDR
// if r > 3 then
4427: LD_VAR 0 4
4431: PUSH
4432: LD_INT 3
4434: GREATER
4435: IFFALSE 4453
// r := r - 3 else
4437: LD_ADDR_VAR 0 4
4441: PUSH
4442: LD_VAR 0 4
4446: PUSH
4447: LD_INT 3
4449: MINUS
4450: ST_TO_ADDR
4451: GO 4467
// r := r + 3 ;
4453: LD_ADDR_VAR 0 4
4457: PUSH
4458: LD_VAR 0 4
4462: PUSH
4463: LD_INT 3
4465: PLUS
4466: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4467: LD_INT 0
4469: PPUSH
4470: LD_INT 1
4472: PPUSH
4473: LD_VAR 0 6
4477: PPUSH
4478: CALL_OW 380
// un := CreateHuman ;
4482: LD_ADDR_VAR 0 5
4486: PUSH
4487: CALL_OW 44
4491: ST_TO_ADDR
// SetDir ( un , r ) ;
4492: LD_VAR 0 5
4496: PPUSH
4497: LD_VAR 0 4
4501: PPUSH
4502: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
4506: LD_VAR 0 5
4510: PPUSH
4511: LD_VAR 0 2
4515: PPUSH
4516: CALL_OW 52
// end ;
4520: GO 4409
4522: POP
4523: POP
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
4524: LD_ADDR_VAR 0 8
4528: PUSH
4529: LD_INT 22
4531: PUSH
4532: LD_INT 3
4534: PUSH
4535: EMPTY
4536: LIST
4537: LIST
4538: PUSH
4539: LD_INT 25
4541: PUSH
4542: LD_INT 3
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: PUSH
4549: EMPTY
4550: LIST
4551: LIST
4552: PPUSH
4553: CALL_OW 69
4557: ST_TO_ADDR
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
4558: LD_ADDR_VAR 0 4
4562: PUSH
4563: LD_INT 4
4565: PUSH
4566: LD_INT 5
4568: PUSH
4569: LD_INT 6
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: LIST
4576: PUSH
4577: LD_OWVAR 67
4581: ARRAY
4582: ST_TO_ADDR
// for i = 1 to r do
4583: LD_ADDR_VAR 0 2
4587: PUSH
4588: DOUBLE
4589: LD_INT 1
4591: DEC
4592: ST_TO_ADDR
4593: LD_VAR 0 4
4597: PUSH
4598: FOR_TO
4599: IFFALSE 4772
// begin un := PrepareTank ( 3 , 3 , [ ru_medium_tracked , ru_medium_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
4601: LD_ADDR_VAR 0 5
4605: PUSH
4606: LD_INT 3
4608: PPUSH
4609: LD_INT 3
4611: PPUSH
4612: LD_INT 22
4614: PUSH
4615: LD_INT 22
4617: PUSH
4618: LD_INT 24
4620: PUSH
4621: EMPTY
4622: LIST
4623: LIST
4624: LIST
4625: PUSH
4626: LD_VAR 0 2
4630: PUSH
4631: LD_INT 3
4633: MOD
4634: PUSH
4635: LD_INT 1
4637: PLUS
4638: ARRAY
4639: PPUSH
4640: LD_INT 1
4642: PPUSH
4643: LD_INT 1
4645: PPUSH
4646: LD_INT 43
4648: PUSH
4649: LD_INT 44
4651: PUSH
4652: LD_INT 42
4654: PUSH
4655: EMPTY
4656: LIST
4657: LIST
4658: LIST
4659: PUSH
4660: LD_VAR 0 2
4664: PUSH
4665: LD_INT 3
4667: MOD
4668: PUSH
4669: LD_INT 1
4671: PLUS
4672: ARRAY
4673: PPUSH
4674: LD_INT 100
4676: PPUSH
4677: CALL 417 0 7
4681: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4682: LD_VAR 0 5
4686: PPUSH
4687: LD_INT 0
4689: PPUSH
4690: LD_INT 5
4692: PPUSH
4693: CALL_OW 12
4697: PPUSH
4698: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
4702: LD_VAR 0 5
4706: PPUSH
4707: LD_INT 5
4709: PPUSH
4710: LD_INT 0
4712: PPUSH
4713: CALL_OW 49
// if i > tmp - 2 then
4717: LD_VAR 0 2
4721: PUSH
4722: LD_VAR 0 8
4726: PUSH
4727: LD_INT 2
4729: MINUS
4730: GREATER
4731: IFFALSE 4735
// continue ;
4733: GO 4598
// ComExitBuilding ( tmp [ i ] ) ;
4735: LD_VAR 0 8
4739: PUSH
4740: LD_VAR 0 2
4744: ARRAY
4745: PPUSH
4746: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , un ) ;
4750: LD_VAR 0 8
4754: PUSH
4755: LD_VAR 0 2
4759: ARRAY
4760: PPUSH
4761: LD_VAR 0 5
4765: PPUSH
4766: CALL_OW 180
// end ;
4770: GO 4598
4772: POP
4773: POP
// end ;
4774: LD_VAR 0 1
4778: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_ok ] ] ) do var i , filter , tmp , engs , enemy ;
4779: LD_INT 22
4781: PUSH
4782: LD_INT 3
4784: PUSH
4785: EMPTY
4786: LIST
4787: LIST
4788: PUSH
4789: LD_INT 25
4791: PUSH
4792: LD_INT 2
4794: PUSH
4795: EMPTY
4796: LIST
4797: LIST
4798: PUSH
4799: LD_INT 50
4801: PUSH
4802: EMPTY
4803: LIST
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: LIST
4809: PPUSH
4810: CALL_OW 69
4814: IFFALSE 5510
4816: GO 4818
4818: DISABLE
4819: LD_INT 0
4821: PPUSH
4822: PPUSH
4823: PPUSH
4824: PPUSH
4825: PPUSH
// begin enable ;
4826: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
4827: LD_ADDR_VAR 0 2
4831: PUSH
4832: LD_INT 6
4834: PPUSH
4835: LD_INT 3
4837: PUSH
4838: LD_INT 24
4840: PUSH
4841: LD_INT 1000
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: PUSH
4852: LD_INT 21
4854: PUSH
4855: LD_INT 3
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: EMPTY
4863: LIST
4864: LIST
4865: PPUSH
4866: CALL_OW 70
4870: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_lives , 650 ] ] ) ;
4871: LD_ADDR_VAR 0 4
4875: PUSH
4876: LD_INT 22
4878: PUSH
4879: LD_INT 3
4881: PUSH
4882: EMPTY
4883: LIST
4884: LIST
4885: PUSH
4886: LD_INT 25
4888: PUSH
4889: LD_INT 2
4891: PUSH
4892: EMPTY
4893: LIST
4894: LIST
4895: PUSH
4896: LD_INT 24
4898: PUSH
4899: LD_INT 650
4901: PUSH
4902: EMPTY
4903: LIST
4904: LIST
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: LIST
4910: PPUSH
4911: CALL_OW 69
4915: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
4916: LD_VAR 0 2
4920: NOT
4921: PUSH
4922: LD_EXP 19
4926: NOT
4927: AND
4928: IFFALSE 4960
// begin if not IsInUnit ( engs [ 1 ] ) then
4930: LD_VAR 0 4
4934: PUSH
4935: LD_INT 1
4937: ARRAY
4938: PPUSH
4939: CALL_OW 310
4943: NOT
4944: IFFALSE 4958
// ComEnterUnit ( engs , ru_dep_main ) ;
4946: LD_VAR 0 4
4950: PPUSH
4951: LD_INT 16
4953: PPUSH
4954: CALL_OW 120
// exit ;
4958: GO 5510
// end ; if debug then
4960: LD_EXP 1
4964: IFFALSE 4985
// display_strings := [ engs , filter ] ;
4966: LD_ADDR_OWVAR 47
4970: PUSH
4971: LD_VAR 0 4
4975: PUSH
4976: LD_VAR 0 2
4980: PUSH
4981: EMPTY
4982: LIST
4983: LIST
4984: ST_TO_ADDR
// if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
4985: LD_VAR 0 4
4989: PPUSH
4990: LD_INT 3
4992: PUSH
4993: LD_INT 24
4995: PUSH
4996: LD_INT 650
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: PPUSH
5007: CALL_OW 72
5011: IFFALSE 5104
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
5013: LD_ADDR_VAR 0 3
5017: PUSH
5018: LD_VAR 0 4
5022: PPUSH
5023: LD_INT 3
5025: PUSH
5026: LD_INT 24
5028: PUSH
5029: LD_INT 650
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PUSH
5036: EMPTY
5037: LIST
5038: LIST
5039: PPUSH
5040: CALL_OW 72
5044: ST_TO_ADDR
// for i in tmp do
5045: LD_ADDR_VAR 0 1
5049: PUSH
5050: LD_VAR 0 3
5054: PUSH
5055: FOR_IN
5056: IFFALSE 5102
// if not IsInArea ( i , mainBaseArea ) then
5058: LD_VAR 0 1
5062: PPUSH
5063: LD_INT 14
5065: PPUSH
5066: CALL_OW 308
5070: NOT
5071: IFFALSE 5100
// begin ComMoveXY ( i , 129 , 125 ) ;
5073: LD_VAR 0 1
5077: PPUSH
5078: LD_INT 129
5080: PPUSH
5081: LD_INT 125
5083: PPUSH
5084: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
5088: LD_VAR 0 1
5092: PPUSH
5093: LD_INT 1050
5095: PPUSH
5096: CALL_OW 202
// end ;
5100: GO 5055
5102: POP
5103: POP
// end ; if filter then
5104: LD_VAR 0 2
5108: IFFALSE 5367
// begin for i in engs do
5110: LD_ADDR_VAR 0 1
5114: PUSH
5115: LD_VAR 0 4
5119: PUSH
5120: FOR_IN
5121: IFFALSE 5145
// if IsInUnit ( i ) then
5123: LD_VAR 0 1
5127: PPUSH
5128: CALL_OW 310
5132: IFFALSE 5143
// ComExitBuilding ( i ) ;
5134: LD_VAR 0 1
5138: PPUSH
5139: CALL_OW 122
5143: GO 5120
5145: POP
5146: POP
// wait ( 3 ) ;
5147: LD_INT 3
5149: PPUSH
5150: CALL_OW 67
// if filter >= 2 and engs >= 2 then
5154: LD_VAR 0 2
5158: PUSH
5159: LD_INT 2
5161: GREATEREQUAL
5162: PUSH
5163: LD_VAR 0 4
5167: PUSH
5168: LD_INT 2
5170: GREATEREQUAL
5171: AND
5172: IFFALSE 5320
// begin for i = 1 to engs / 2 do
5174: LD_ADDR_VAR 0 1
5178: PUSH
5179: DOUBLE
5180: LD_INT 1
5182: DEC
5183: ST_TO_ADDR
5184: LD_VAR 0 4
5188: PUSH
5189: LD_INT 2
5191: DIVREAL
5192: PUSH
5193: FOR_TO
5194: IFFALSE 5240
// if not HasTask ( engs [ i ] ) then
5196: LD_VAR 0 4
5200: PUSH
5201: LD_VAR 0 1
5205: ARRAY
5206: PPUSH
5207: CALL_OW 314
5211: NOT
5212: IFFALSE 5238
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
5214: LD_VAR 0 4
5218: PUSH
5219: LD_VAR 0 1
5223: ARRAY
5224: PPUSH
5225: LD_VAR 0 2
5229: PUSH
5230: LD_INT 1
5232: ARRAY
5233: PPUSH
5234: CALL_OW 130
5238: GO 5193
5240: POP
5241: POP
// for i = engs / 2 + 1 to engs do
5242: LD_ADDR_VAR 0 1
5246: PUSH
5247: DOUBLE
5248: LD_VAR 0 4
5252: PUSH
5253: LD_INT 2
5255: DIVREAL
5256: PUSH
5257: LD_INT 1
5259: PLUS
5260: DEC
5261: ST_TO_ADDR
5262: LD_VAR 0 4
5266: PUSH
5267: FOR_TO
5268: IFFALSE 5316
// if not HasTask ( engs [ i ] ) then
5270: LD_VAR 0 4
5274: PUSH
5275: LD_VAR 0 1
5279: ARRAY
5280: PPUSH
5281: CALL_OW 314
5285: NOT
5286: IFFALSE 5314
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
5288: LD_VAR 0 4
5292: PUSH
5293: LD_VAR 0 1
5297: ARRAY
5298: PPUSH
5299: LD_VAR 0 2
5303: PUSH
5304: LD_VAR 0 2
5308: ARRAY
5309: PPUSH
5310: CALL_OW 130
5314: GO 5267
5316: POP
5317: POP
// end else
5318: GO 5367
// for i in engs do
5320: LD_ADDR_VAR 0 1
5324: PUSH
5325: LD_VAR 0 4
5329: PUSH
5330: FOR_IN
5331: IFFALSE 5365
// if not HasTask ( i ) then
5333: LD_VAR 0 1
5337: PPUSH
5338: CALL_OW 314
5342: NOT
5343: IFFALSE 5363
// ComRepairBuilding ( i , filter [ 1 ] ) ;
5345: LD_VAR 0 1
5349: PPUSH
5350: LD_VAR 0 2
5354: PUSH
5355: LD_INT 1
5357: ARRAY
5358: PPUSH
5359: CALL_OW 130
5363: GO 5330
5365: POP
5366: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
5367: LD_ADDR_VAR 0 5
5371: PUSH
5372: LD_INT 81
5374: PUSH
5375: LD_INT 3
5377: PUSH
5378: EMPTY
5379: LIST
5380: LIST
5381: PPUSH
5382: CALL_OW 69
5386: ST_TO_ADDR
// if ru_rebuild_list and not filter then
5387: LD_EXP 19
5391: PUSH
5392: LD_VAR 0 2
5396: NOT
5397: AND
5398: IFFALSE 5510
// begin ComExitBuilding ( engs ) ;
5400: LD_VAR 0 4
5404: PPUSH
5405: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
5409: LD_VAR 0 5
5413: PPUSH
5414: LD_EXP 19
5418: PUSH
5419: LD_INT 2
5421: ARRAY
5422: PPUSH
5423: LD_EXP 19
5427: PUSH
5428: LD_INT 3
5430: ARRAY
5431: PPUSH
5432: CALL_OW 73
5436: PPUSH
5437: LD_EXP 19
5441: PUSH
5442: LD_INT 2
5444: ARRAY
5445: PPUSH
5446: LD_EXP 19
5450: PUSH
5451: LD_INT 3
5453: ARRAY
5454: PPUSH
5455: CALL_OW 297
5459: PUSH
5460: LD_INT 10
5462: GREATER
5463: IFFALSE 5510
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
5465: LD_VAR 0 4
5469: PPUSH
5470: LD_EXP 19
5474: PUSH
5475: LD_INT 1
5477: ARRAY
5478: PPUSH
5479: LD_EXP 19
5483: PUSH
5484: LD_INT 2
5486: ARRAY
5487: PPUSH
5488: LD_EXP 19
5492: PUSH
5493: LD_INT 3
5495: ARRAY
5496: PPUSH
5497: LD_EXP 19
5501: PUSH
5502: LD_INT 4
5504: ARRAY
5505: PPUSH
5506: CALL_OW 145
// end ; end ;
5510: PPOPN 5
5512: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 650 do var tmp ;
5513: LD_INT 16
5515: PPUSH
5516: CALL_OW 256
5520: PUSH
5521: LD_INT 650
5523: LESS
5524: IFFALSE 5607
5526: GO 5528
5528: DISABLE
5529: LD_INT 0
5531: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
5532: LD_ADDR_VAR 0 1
5536: PUSH
5537: LD_INT 22
5539: PUSH
5540: LD_INT 3
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: PUSH
5547: LD_INT 25
5549: PUSH
5550: LD_INT 1
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: PUSH
5557: EMPTY
5558: LIST
5559: LIST
5560: PPUSH
5561: CALL_OW 69
5565: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
5566: LD_VAR 0 1
5570: PPUSH
5571: CALL_OW 122
// wait ( 3 ) ;
5575: LD_INT 3
5577: PPUSH
5578: CALL_OW 67
// ComAgressiveMove ( tmp , GetX ( ru_dep_main ) , GetY ( ru_dep_main ) ) ;
5582: LD_VAR 0 1
5586: PPUSH
5587: LD_INT 16
5589: PPUSH
5590: CALL_OW 250
5594: PPUSH
5595: LD_INT 16
5597: PPUSH
5598: CALL_OW 251
5602: PPUSH
5603: CALL_OW 114
// end ;
5607: PPOPN 1
5609: END
// every 0 0$01 trigger GetLives ( ru_dep_main ) > 650 and FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] ] ] ) do var i , tmp ;
5610: LD_INT 16
5612: PPUSH
5613: CALL_OW 256
5617: PUSH
5618: LD_INT 650
5620: GREATER
5621: PUSH
5622: LD_INT 22
5624: PUSH
5625: LD_INT 3
5627: PUSH
5628: EMPTY
5629: LIST
5630: LIST
5631: PUSH
5632: LD_INT 25
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: EMPTY
5639: LIST
5640: LIST
5641: PUSH
5642: LD_INT 56
5644: PUSH
5645: EMPTY
5646: LIST
5647: PUSH
5648: EMPTY
5649: LIST
5650: LIST
5651: LIST
5652: PUSH
5653: EMPTY
5654: LIST
5655: PPUSH
5656: CALL_OW 69
5660: AND
5661: IFFALSE 5773
5663: GO 5665
5665: DISABLE
5666: LD_INT 0
5668: PPUSH
5669: PPUSH
// begin enable ;
5670: ENABLE
// tmp := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] , [ f_not , [ f_hastask ] ] ] ] ) ;
5671: LD_ADDR_VAR 0 2
5675: PUSH
5676: LD_INT 22
5678: PUSH
5679: LD_INT 3
5681: PUSH
5682: EMPTY
5683: LIST
5684: LIST
5685: PUSH
5686: LD_INT 25
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: EMPTY
5693: LIST
5694: LIST
5695: PUSH
5696: LD_INT 56
5698: PUSH
5699: EMPTY
5700: LIST
5701: PUSH
5702: LD_INT 3
5704: PUSH
5705: LD_INT 60
5707: PUSH
5708: EMPTY
5709: LIST
5710: PUSH
5711: EMPTY
5712: LIST
5713: LIST
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: LIST
5719: LIST
5720: PUSH
5721: EMPTY
5722: LIST
5723: PPUSH
5724: CALL_OW 69
5728: ST_TO_ADDR
// if not tmp then
5729: LD_VAR 0 2
5733: NOT
5734: IFFALSE 5738
// exit ;
5736: GO 5773
// for i in tmp do
5738: LD_ADDR_VAR 0 1
5742: PUSH
5743: LD_VAR 0 2
5747: PUSH
5748: FOR_IN
5749: IFFALSE 5771
// GoToAnotherTower ( i , 0 , 143 , 143 ) ;
5751: LD_VAR 0 1
5755: PPUSH
5756: LD_INT 0
5758: PPUSH
5759: LD_INT 143
5761: PPUSH
5762: LD_INT 143
5764: PPUSH
5765: CALL 735 0 4
5769: GO 5748
5771: POP
5772: POP
// end ;
5773: PPOPN 2
5775: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
5776: LD_INT 22
5778: PUSH
5779: LD_INT 3
5781: PUSH
5782: EMPTY
5783: LIST
5784: LIST
5785: PUSH
5786: LD_INT 25
5788: PUSH
5789: LD_INT 4
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: PUSH
5796: EMPTY
5797: LIST
5798: LIST
5799: PPUSH
5800: CALL_OW 69
5804: IFFALSE 6058
5806: GO 5808
5808: DISABLE
5809: LD_INT 0
5811: PPUSH
5812: PPUSH
5813: PPUSH
// begin enable ;
5814: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5815: LD_ADDR_VAR 0 2
5819: PUSH
5820: LD_INT 14
5822: PPUSH
5823: LD_INT 22
5825: PUSH
5826: LD_INT 3
5828: PUSH
5829: EMPTY
5830: LIST
5831: LIST
5832: PUSH
5833: LD_INT 21
5835: PUSH
5836: LD_INT 1
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: PUSH
5843: LD_INT 3
5845: PUSH
5846: LD_INT 24
5848: PUSH
5849: LD_INT 1000
5851: PUSH
5852: EMPTY
5853: LIST
5854: LIST
5855: PUSH
5856: EMPTY
5857: LIST
5858: LIST
5859: PUSH
5860: EMPTY
5861: LIST
5862: LIST
5863: LIST
5864: PPUSH
5865: CALL_OW 70
5869: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
5870: LD_ADDR_VAR 0 3
5874: PUSH
5875: LD_INT 22
5877: PUSH
5878: LD_INT 3
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: PUSH
5885: LD_INT 25
5887: PUSH
5888: LD_INT 4
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: EMPTY
5896: LIST
5897: LIST
5898: PPUSH
5899: CALL_OW 69
5903: ST_TO_ADDR
// if not doc then
5904: LD_VAR 0 3
5908: NOT
5909: IFFALSE 5913
// exit ;
5911: GO 6058
// if not tmp then
5913: LD_VAR 0 2
5917: NOT
5918: IFFALSE 6009
// begin if not IsInUnit ( doc [ 1 ] ) then
5920: LD_VAR 0 3
5924: PUSH
5925: LD_INT 1
5927: ARRAY
5928: PPUSH
5929: CALL_OW 310
5933: NOT
5934: IFFALSE 6007
// ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
5936: LD_VAR 0 3
5940: PPUSH
5941: LD_INT 22
5943: PUSH
5944: LD_INT 3
5946: PUSH
5947: EMPTY
5948: LIST
5949: LIST
5950: PUSH
5951: LD_INT 2
5953: PUSH
5954: LD_INT 30
5956: PUSH
5957: LD_INT 6
5959: PUSH
5960: EMPTY
5961: LIST
5962: LIST
5963: PUSH
5964: LD_INT 30
5966: PUSH
5967: LD_INT 7
5969: PUSH
5970: EMPTY
5971: LIST
5972: LIST
5973: PUSH
5974: LD_INT 30
5976: PUSH
5977: LD_INT 8
5979: PUSH
5980: EMPTY
5981: LIST
5982: LIST
5983: PUSH
5984: EMPTY
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: PUSH
5990: EMPTY
5991: LIST
5992: LIST
5993: PPUSH
5994: CALL_OW 69
5998: PUSH
5999: LD_INT 1
6001: ARRAY
6002: PPUSH
6003: CALL_OW 120
// exit ;
6007: GO 6058
// end ; if IsInUnit ( doc [ 1 ] ) then
6009: LD_VAR 0 3
6013: PUSH
6014: LD_INT 1
6016: ARRAY
6017: PPUSH
6018: CALL_OW 310
6022: IFFALSE 6033
// ComExitBuilding ( doc ) ;
6024: LD_VAR 0 3
6028: PPUSH
6029: CALL_OW 122
// wait ( 3 ) ;
6033: LD_INT 3
6035: PPUSH
6036: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
6040: LD_VAR 0 3
6044: PPUSH
6045: LD_VAR 0 2
6049: PUSH
6050: LD_INT 1
6052: ARRAY
6053: PPUSH
6054: CALL_OW 128
// end ;
6058: PPOPN 3
6060: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , tmp , attacking , areas , area ;
6061: LD_INT 22
6063: PUSH
6064: LD_INT 3
6066: PUSH
6067: EMPTY
6068: LIST
6069: LIST
6070: PUSH
6071: LD_INT 25
6073: PUSH
6074: LD_INT 3
6076: PUSH
6077: EMPTY
6078: LIST
6079: LIST
6080: PUSH
6081: EMPTY
6082: LIST
6083: LIST
6084: PPUSH
6085: CALL_OW 69
6089: PUSH
6090: LD_INT 22
6092: PUSH
6093: LD_INT 3
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PUSH
6100: LD_INT 21
6102: PUSH
6103: LD_INT 2
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: PPUSH
6114: CALL_OW 69
6118: AND
6119: IFFALSE 6533
6121: GO 6123
6123: DISABLE
6124: LD_INT 0
6126: PPUSH
6127: PPUSH
6128: PPUSH
6129: PPUSH
6130: PPUSH
// begin enable ;
6131: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
6132: LD_ADDR_VAR 0 2
6136: PUSH
6137: LD_INT 22
6139: PUSH
6140: LD_INT 3
6142: PUSH
6143: EMPTY
6144: LIST
6145: LIST
6146: PUSH
6147: LD_INT 21
6149: PUSH
6150: LD_INT 2
6152: PUSH
6153: EMPTY
6154: LIST
6155: LIST
6156: PUSH
6157: LD_INT 3
6159: PUSH
6160: LD_INT 58
6162: PUSH
6163: EMPTY
6164: LIST
6165: PUSH
6166: EMPTY
6167: LIST
6168: LIST
6169: PUSH
6170: EMPTY
6171: LIST
6172: LIST
6173: LIST
6174: PPUSH
6175: CALL_OW 69
6179: ST_TO_ADDR
// areas := [ sectorAlpha , sectorBeta , sectorDelta , mainBaseArea ] ;
6180: LD_ADDR_VAR 0 4
6184: PUSH
6185: LD_INT 10
6187: PUSH
6188: LD_INT 11
6190: PUSH
6191: LD_INT 12
6193: PUSH
6194: LD_INT 14
6196: PUSH
6197: EMPTY
6198: LIST
6199: LIST
6200: LIST
6201: LIST
6202: ST_TO_ADDR
// area := 0 ;
6203: LD_ADDR_VAR 0 5
6207: PUSH
6208: LD_INT 0
6210: ST_TO_ADDR
// attacking := false ;
6211: LD_ADDR_VAR 0 3
6215: PUSH
6216: LD_INT 0
6218: ST_TO_ADDR
// for i in tmp do
6219: LD_ADDR_VAR 0 1
6223: PUSH
6224: LD_VAR 0 2
6228: PUSH
6229: FOR_IN
6230: IFFALSE 6316
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
6232: LD_VAR 0 1
6236: PPUSH
6237: LD_INT 22
6239: PUSH
6240: LD_INT 1
6242: PUSH
6243: EMPTY
6244: LIST
6245: LIST
6246: PPUSH
6247: CALL_OW 69
6251: PPUSH
6252: LD_VAR 0 1
6256: PPUSH
6257: CALL_OW 74
6261: PPUSH
6262: CALL_OW 296
6266: PUSH
6267: LD_INT 10
6269: LESS
6270: IFFALSE 6314
// begin ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
6272: LD_VAR 0 1
6276: PPUSH
6277: LD_INT 22
6279: PUSH
6280: LD_INT 1
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: PPUSH
6287: CALL_OW 69
6291: PPUSH
6292: LD_VAR 0 1
6296: PPUSH
6297: CALL_OW 74
6301: PPUSH
6302: CALL_OW 115
// attacking := true ;
6306: LD_ADDR_VAR 0 3
6310: PUSH
6311: LD_INT 1
6313: ST_TO_ADDR
// end ;
6314: GO 6229
6316: POP
6317: POP
// if attacking then
6318: LD_VAR 0 3
6322: IFFALSE 6326
// exit ;
6324: GO 6533
// for i in areas do
6326: LD_ADDR_VAR 0 1
6330: PUSH
6331: LD_VAR 0 4
6335: PUSH
6336: FOR_IN
6337: IFFALSE 6374
// if FilterUnitsInArea ( i , [ f_side , 1 ] ) then
6339: LD_VAR 0 1
6343: PPUSH
6344: LD_INT 22
6346: PUSH
6347: LD_INT 1
6349: PUSH
6350: EMPTY
6351: LIST
6352: LIST
6353: PPUSH
6354: CALL_OW 70
6358: IFFALSE 6372
// begin area := i ;
6360: LD_ADDR_VAR 0 5
6364: PUSH
6365: LD_VAR 0 1
6369: ST_TO_ADDR
// break ;
6370: GO 6374
// end ;
6372: GO 6336
6374: POP
6375: POP
// if area then
6376: LD_VAR 0 5
6380: IFFALSE 6533
// begin for i in tmp do
6382: LD_ADDR_VAR 0 1
6386: PUSH
6387: LD_VAR 0 2
6391: PUSH
6392: FOR_IN
6393: IFFALSE 6531
// begin if GetFuel ( i ) < 33 then
6395: LD_VAR 0 1
6399: PPUSH
6400: CALL_OW 261
6404: PUSH
6405: LD_INT 33
6407: LESS
6408: IFFALSE 6422
// SetFuel ( i , 33 ) ;
6410: LD_VAR 0 1
6414: PPUSH
6415: LD_INT 33
6417: PPUSH
6418: CALL_OW 240
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
6422: LD_VAR 0 1
6426: PPUSH
6427: LD_INT 22
6429: PUSH
6430: LD_INT 1
6432: PUSH
6433: EMPTY
6434: LIST
6435: LIST
6436: PPUSH
6437: CALL_OW 69
6441: PPUSH
6442: LD_VAR 0 1
6446: PPUSH
6447: CALL_OW 74
6451: PPUSH
6452: CALL_OW 296
6456: PUSH
6457: LD_INT 10
6459: LESS
6460: IFFALSE 6498
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
6462: LD_VAR 0 1
6466: PPUSH
6467: LD_INT 22
6469: PUSH
6470: LD_INT 1
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: PPUSH
6477: CALL_OW 69
6481: PPUSH
6482: LD_VAR 0 1
6486: PPUSH
6487: CALL_OW 74
6491: PPUSH
6492: CALL_OW 115
6496: GO 6529
// if not IsInArea ( i , area ) then
6498: LD_VAR 0 1
6502: PPUSH
6503: LD_VAR 0 5
6507: PPUSH
6508: CALL_OW 308
6512: NOT
6513: IFFALSE 6529
// ComMoveToArea ( i , area ) ;
6515: LD_VAR 0 1
6519: PPUSH
6520: LD_VAR 0 5
6524: PPUSH
6525: CALL_OW 113
// end ;
6529: GO 6392
6531: POP
6532: POP
// end ; end ;
6533: PPOPN 5
6535: END
// every 10 10$00 do var i , j , un , veh , time , count ;
6536: GO 6538
6538: DISABLE
6539: LD_INT 0
6541: PPUSH
6542: PPUSH
6543: PPUSH
6544: PPUSH
6545: PPUSH
6546: PPUSH
// begin uc_side := 3 ;
6547: LD_ADDR_OWVAR 20
6551: PUSH
6552: LD_INT 3
6554: ST_TO_ADDR
// uc_nation := 3 ;
6555: LD_ADDR_OWVAR 21
6559: PUSH
6560: LD_INT 3
6562: ST_TO_ADDR
// time := [ 6 6$00 , 5 5$00 , 4 4$00 ] [ Difficulty ] ;
6563: LD_ADDR_VAR 0 5
6567: PUSH
6568: LD_INT 12600
6570: PUSH
6571: LD_INT 10500
6573: PUSH
6574: LD_INT 8400
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: LIST
6581: PUSH
6582: LD_OWVAR 67
6586: ARRAY
6587: ST_TO_ADDR
// count := [ 3 , 4 , 5 ] [ Difficulty ] ;
6588: LD_ADDR_VAR 0 6
6592: PUSH
6593: LD_INT 3
6595: PUSH
6596: LD_INT 4
6598: PUSH
6599: LD_INT 5
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: LIST
6606: PUSH
6607: LD_OWVAR 67
6611: ARRAY
6612: ST_TO_ADDR
// for i = 1 to count do
6613: LD_ADDR_VAR 0 1
6617: PUSH
6618: DOUBLE
6619: LD_INT 1
6621: DEC
6622: ST_TO_ADDR
6623: LD_VAR 0 6
6627: PUSH
6628: FOR_TO
6629: IFFALSE 6924
// begin wait ( time ) ;
6631: LD_VAR 0 5
6635: PPUSH
6636: CALL_OW 67
// for j = 1 to rand ( 1 , Difficulty ) do
6640: LD_ADDR_VAR 0 2
6644: PUSH
6645: DOUBLE
6646: LD_INT 1
6648: DEC
6649: ST_TO_ADDR
6650: LD_INT 1
6652: PPUSH
6653: LD_OWVAR 67
6657: PPUSH
6658: CALL_OW 12
6662: PUSH
6663: FOR_TO
6664: IFFALSE 6805
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 80 ) ;
6666: LD_ADDR_VAR 0 4
6670: PUSH
6671: LD_INT 3
6673: PPUSH
6674: LD_INT 3
6676: PPUSH
6677: LD_INT 22
6679: PPUSH
6680: LD_INT 1
6682: PPUSH
6683: LD_INT 1
6685: PPUSH
6686: LD_INT 43
6688: PUSH
6689: LD_INT 44
6691: PUSH
6692: LD_INT 42
6694: PUSH
6695: EMPTY
6696: LIST
6697: LIST
6698: LIST
6699: PUSH
6700: LD_VAR 0 1
6704: PUSH
6705: LD_INT 3
6707: MOD
6708: PUSH
6709: LD_INT 1
6711: PLUS
6712: ARRAY
6713: PPUSH
6714: LD_INT 80
6716: PPUSH
6717: CALL 417 0 7
6721: ST_TO_ADDR
// PlaceUnitArea ( veh , southArea , false ) ;
6722: LD_VAR 0 4
6726: PPUSH
6727: LD_INT 13
6729: PPUSH
6730: LD_INT 0
6732: PPUSH
6733: CALL_OW 49
// PrepareHuman ( false , 3 , [ 4 , 5 , 5 ] [ Difficulty ] ) ;
6737: LD_INT 0
6739: PPUSH
6740: LD_INT 3
6742: PPUSH
6743: LD_INT 4
6745: PUSH
6746: LD_INT 5
6748: PUSH
6749: LD_INT 5
6751: PUSH
6752: EMPTY
6753: LIST
6754: LIST
6755: LIST
6756: PUSH
6757: LD_OWVAR 67
6761: ARRAY
6762: PPUSH
6763: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6767: CALL_OW 44
6771: PPUSH
6772: LD_VAR 0 4
6776: PPUSH
6777: CALL_OW 52
// wait ( 0 0$01 ) ;
6781: LD_INT 35
6783: PPUSH
6784: CALL_OW 67
// ComMoveXY ( veh , 143 , 143 ) ;
6788: LD_VAR 0 4
6792: PPUSH
6793: LD_INT 143
6795: PPUSH
6796: LD_INT 143
6798: PPUSH
6799: CALL_OW 111
// end ;
6803: GO 6663
6805: POP
6806: POP
// if count < 3 then
6807: LD_VAR 0 6
6811: PUSH
6812: LD_INT 3
6814: LESS
6815: IFFALSE 6819
// continue ;
6817: GO 6628
// for j = 1 to 1 + Difficulty do
6819: LD_ADDR_VAR 0 2
6823: PUSH
6824: DOUBLE
6825: LD_INT 1
6827: DEC
6828: ST_TO_ADDR
6829: LD_INT 1
6831: PUSH
6832: LD_OWVAR 67
6836: PLUS
6837: PUSH
6838: FOR_TO
6839: IFFALSE 6920
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
6841: LD_INT 0
6843: PPUSH
6844: LD_INT 1
6846: PPUSH
6847: LD_INT 4
6849: PUSH
6850: LD_INT 5
6852: PUSH
6853: LD_INT 6
6855: PUSH
6856: EMPTY
6857: LIST
6858: LIST
6859: LIST
6860: PUSH
6861: LD_OWVAR 67
6865: ARRAY
6866: PPUSH
6867: CALL_OW 380
// un := CreateHuman ;
6871: LD_ADDR_VAR 0 3
6875: PUSH
6876: CALL_OW 44
6880: ST_TO_ADDR
// PlaceUnitArea ( un , southArea , false ) ;
6881: LD_VAR 0 3
6885: PPUSH
6886: LD_INT 13
6888: PPUSH
6889: LD_INT 0
6891: PPUSH
6892: CALL_OW 49
// ComMoveXY ( un , 143 , 143 ) ;
6896: LD_VAR 0 3
6900: PPUSH
6901: LD_INT 143
6903: PPUSH
6904: LD_INT 143
6906: PPUSH
6907: CALL_OW 111
// wait ( 0 0$01 ) ;
6911: LD_INT 35
6913: PPUSH
6914: CALL_OW 67
// end ;
6918: GO 6838
6920: POP
6921: POP
// end ;
6922: GO 6628
6924: POP
6925: POP
// end ;
6926: PPOPN 6
6928: END
// every 4 4$00 do var i , un , time ;
6929: GO 6931
6931: DISABLE
6932: LD_INT 0
6934: PPUSH
6935: PPUSH
6936: PPUSH
// begin time := [ 2 2$00 , 1 1$00 , 0 0$30 ] ;
6937: LD_ADDR_VAR 0 3
6941: PUSH
6942: LD_INT 4200
6944: PUSH
6945: LD_INT 2100
6947: PUSH
6948: LD_INT 1050
6950: PUSH
6951: EMPTY
6952: LIST
6953: LIST
6954: LIST
6955: ST_TO_ADDR
// wait ( time ) ;
6956: LD_VAR 0 3
6960: PPUSH
6961: CALL_OW 67
// uc_side := 3 ;
6965: LD_ADDR_OWVAR 20
6969: PUSH
6970: LD_INT 3
6972: ST_TO_ADDR
// uc_nation := 3 ;
6973: LD_ADDR_OWVAR 21
6977: PUSH
6978: LD_INT 3
6980: ST_TO_ADDR
// for i = 1 to 2 do
6981: LD_ADDR_VAR 0 1
6985: PUSH
6986: DOUBLE
6987: LD_INT 1
6989: DEC
6990: ST_TO_ADDR
6991: LD_INT 2
6993: PUSH
6994: FOR_TO
6995: IFFALSE 7058
// begin PrepareHuman ( false , 1 , 4 ) ;
6997: LD_INT 0
6999: PPUSH
7000: LD_INT 1
7002: PPUSH
7003: LD_INT 4
7005: PPUSH
7006: CALL_OW 380
// un := CreateHuman ;
7010: LD_ADDR_VAR 0 2
7014: PUSH
7015: CALL_OW 44
7019: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_dep_main ) ;
7020: LD_VAR 0 2
7024: PPUSH
7025: LD_INT 16
7027: PPUSH
7028: CALL_OW 52
// ComExitBuilding ( un ) ;
7032: LD_VAR 0 2
7036: PPUSH
7037: CALL_OW 122
// AddComAgressiveMove ( un , 41 , 76 ) ;
7041: LD_VAR 0 2
7045: PPUSH
7046: LD_INT 41
7048: PPUSH
7049: LD_INT 76
7051: PPUSH
7052: CALL_OW 174
// end ;
7056: GO 6994
7058: POP
7059: POP
// end ; end_of_file
7060: PPOPN 3
7062: END
// export function Action ; begin
7063: LD_INT 0
7065: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
7066: LD_INT 28
7068: PPUSH
7069: LD_INT 3
7071: PPUSH
7072: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
7076: LD_INT 41
7078: PPUSH
7079: LD_INT 76
7081: PPUSH
7082: LD_INT 1
7084: PPUSH
7085: LD_INT 10
7087: PPUSH
7088: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
7092: LD_INT 41
7094: PPUSH
7095: LD_INT 76
7097: PPUSH
7098: LD_INT 1
7100: PPUSH
7101: CALL_OW 331
// InGameOn ;
7105: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
7109: LD_EXP 18
7113: PPUSH
7114: LD_STRING D2-Har-1
7116: PPUSH
7117: CALL_OW 94
// InGameOff ;
7121: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
7125: LD_STRING M1
7127: PPUSH
7128: CALL_OW 337
// end ;
7132: LD_VAR 0 1
7136: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
7137: LD_EXP 4
7141: PUSH
7142: LD_INT 1
7144: GREATER
7145: IFFALSE 7236
7147: GO 7149
7149: DISABLE
7150: LD_INT 0
7152: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
7153: LD_ADDR_VAR 0 1
7157: PUSH
7158: LD_INT 1
7160: PPUSH
7161: CALL 505 0 1
7165: PUSH
7166: LD_INT 1
7168: ARRAY
7169: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
7170: LD_VAR 0 1
7174: PPUSH
7175: LD_STRING D2a-Sol1-1
7177: PPUSH
7178: CALL_OW 88
// if not un then
7182: LD_VAR 0 1
7186: NOT
7187: IFFALSE 7218
// begin un := GetRandom ( sex_female ) [ 1 ] ;
7189: LD_ADDR_VAR 0 1
7193: PUSH
7194: LD_INT 2
7196: PPUSH
7197: CALL 505 0 1
7201: PUSH
7202: LD_INT 1
7204: ARRAY
7205: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
7206: LD_VAR 0 1
7210: PPUSH
7211: LD_STRING D2a-FSol1-1
7213: PPUSH
7214: CALL_OW 88
// end ; if Khatam then
7218: LD_EXP 16
7222: IFFALSE 7236
// Say ( Khatam , D3b-Khat-3 ) ;
7224: LD_EXP 16
7228: PPUSH
7229: LD_STRING D3b-Khat-3
7231: PPUSH
7232: CALL_OW 88
// end ;
7236: PPOPN 1
7238: END
// every 0 0$1 trigger Frank and GetDistUnits ( JMM , Frank ) < 5 and not InBattle ( 1 ) do var i , ape ;
7239: LD_EXP 14
7243: PUSH
7244: LD_EXP 8
7248: PPUSH
7249: LD_EXP 14
7253: PPUSH
7254: CALL_OW 296
7258: PUSH
7259: LD_INT 5
7261: LESS
7262: AND
7263: PUSH
7264: LD_INT 1
7266: PPUSH
7267: CALL_OW 463
7271: NOT
7272: AND
7273: IFFALSE 7860
7275: GO 7277
7277: DISABLE
7278: LD_INT 0
7280: PPUSH
7281: PPUSH
// begin InGameOn ;
7282: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
7286: LD_ADDR_VAR 0 2
7290: PUSH
7291: LD_INT 22
7293: PUSH
7294: LD_INT 0
7296: PUSH
7297: EMPTY
7298: LIST
7299: LIST
7300: PUSH
7301: LD_INT 25
7303: PUSH
7304: LD_INT 12
7306: PUSH
7307: EMPTY
7308: LIST
7309: LIST
7310: PUSH
7311: EMPTY
7312: LIST
7313: LIST
7314: PPUSH
7315: CALL_OW 69
7319: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
7320: LD_ADDR_VAR 0 2
7324: PUSH
7325: LD_VAR 0 2
7329: PPUSH
7330: LD_EXP 14
7334: PPUSH
7335: CALL_OW 74
7339: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
7340: LD_ADDR_VAR 0 1
7344: PUSH
7345: LD_INT 22
7347: PUSH
7348: LD_INT 1
7350: PUSH
7351: EMPTY
7352: LIST
7353: LIST
7354: PUSH
7355: LD_INT 21
7357: PUSH
7358: LD_INT 1
7360: PUSH
7361: EMPTY
7362: LIST
7363: LIST
7364: PUSH
7365: LD_INT 91
7367: PUSH
7368: LD_EXP 14
7372: PUSH
7373: LD_INT 20
7375: PUSH
7376: EMPTY
7377: LIST
7378: LIST
7379: LIST
7380: PUSH
7381: EMPTY
7382: LIST
7383: LIST
7384: LIST
7385: PPUSH
7386: CALL_OW 69
7390: PUSH
7391: FOR_IN
7392: IFFALSE 7410
// ComTurnUnit ( i , Frank ) ;
7394: LD_VAR 0 1
7398: PPUSH
7399: LD_EXP 14
7403: PPUSH
7404: CALL_OW 119
7408: GO 7391
7410: POP
7411: POP
// SetSide ( Frank , 1 ) ;
7412: LD_EXP 14
7416: PPUSH
7417: LD_INT 1
7419: PPUSH
7420: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
7424: LD_EXP 8
7428: PPUSH
7429: LD_EXP 14
7433: PPUSH
7434: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
7438: LD_EXP 8
7442: PPUSH
7443: LD_EXP 14
7447: PPUSH
7448: CALL_OW 179
// CenterOnUnits ( Frank ) ;
7452: LD_EXP 14
7456: PPUSH
7457: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
7461: LD_EXP 14
7465: PPUSH
7466: LD_STRING D3a-Frank-1
7468: PPUSH
7469: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
7473: LD_VAR 0 2
7477: PPUSH
7478: LD_INT 42
7480: PPUSH
7481: LD_INT 78
7483: PPUSH
7484: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
7488: LD_VAR 0 2
7492: PPUSH
7493: LD_EXP 14
7497: PPUSH
7498: CALL_OW 179
// if Lisa then
7502: LD_EXP 13
7506: IFFALSE 7520
// Say ( Lisa , D3a-Lisa-1 ) ;
7508: LD_EXP 13
7512: PPUSH
7513: LD_STRING D3a-Lisa-1
7515: PPUSH
7516: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
7520: LD_EXP 8
7524: PPUSH
7525: LD_STRING D3a-JMM-1
7527: PPUSH
7528: CALL_OW 88
// if Cyrus then
7532: LD_EXP 12
7536: IFFALSE 7550
// Say ( Cyrus , D3a-Cyrus-1 ) ;
7538: LD_EXP 12
7542: PPUSH
7543: LD_STRING D3a-Cyrus-1
7545: PPUSH
7546: CALL_OW 88
// if GetRandom ( sex_male ) then
7550: LD_INT 1
7552: PPUSH
7553: CALL 505 0 1
7557: IFFALSE 7578
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
7559: LD_INT 1
7561: PPUSH
7562: CALL 505 0 1
7566: PUSH
7567: LD_INT 1
7569: ARRAY
7570: PPUSH
7571: LD_STRING D3a-Sol1-1
7573: PPUSH
7574: CALL_OW 88
// if GetRandom ( sex_female ) then
7578: LD_INT 2
7580: PPUSH
7581: CALL 505 0 1
7585: IFFALSE 7606
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
7587: LD_INT 2
7589: PPUSH
7590: CALL 505 0 1
7594: PUSH
7595: LD_INT 1
7597: ARRAY
7598: PPUSH
7599: LD_STRING D3a-FSol1-1
7601: PPUSH
7602: CALL_OW 88
// if Gladstone then
7606: LD_EXP 15
7610: IFFALSE 7624
// Say ( Gladstone , D3a-Glad-1 ) ;
7612: LD_EXP 15
7616: PPUSH
7617: LD_STRING D3a-Glad-1
7619: PPUSH
7620: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
7624: LD_VAR 0 2
7628: PPUSH
7629: LD_INT 60
7631: PPUSH
7632: LD_INT 113
7634: PPUSH
7635: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
7639: LD_EXP 14
7643: PPUSH
7644: LD_STRING D3a-Frank-2
7646: PPUSH
7647: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
7651: LD_EXP 14
7655: PPUSH
7656: LD_EXP 8
7660: PPUSH
7661: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
7665: LD_EXP 8
7669: PPUSH
7670: LD_STRING D3a-JMM-2
7672: PPUSH
7673: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
7677: LD_INT 1
7679: PPUSH
7680: LD_INT 4
7682: PPUSH
7683: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
7687: LD_INT 85
7689: PPUSH
7690: LD_INT 134
7692: PPUSH
7693: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
7697: LD_EXP 14
7701: PPUSH
7702: LD_STRING D3a-Frank-3
7704: PPUSH
7705: CALL_OW 88
// Wait ( 0 0$01 ) ;
7709: LD_INT 35
7711: PPUSH
7712: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
7716: LD_INT 166
7718: PPUSH
7719: LD_INT 136
7721: PPUSH
7722: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
7726: LD_EXP 8
7730: PPUSH
7731: LD_STRING D3a-JMM-3
7733: PPUSH
7734: CALL_OW 88
// Wait ( 0 0$01 ) ;
7738: LD_INT 35
7740: PPUSH
7741: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
7745: LD_EXP 14
7749: PPUSH
7750: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
7754: LD_EXP 14
7758: PPUSH
7759: LD_STRING D3a-Frank-4
7761: PPUSH
7762: CALL_OW 88
// if Lisa then
7766: LD_EXP 13
7770: IFFALSE 7784
// Say ( Lisa , D3a-Lisa-4 ) ;
7772: LD_EXP 13
7776: PPUSH
7777: LD_STRING D3a-Lisa-4
7779: PPUSH
7780: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
7784: LD_EXP 8
7788: PPUSH
7789: LD_STRING D3a-JMM-4
7791: PPUSH
7792: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
7796: LD_EXP 14
7800: PPUSH
7801: LD_STRING D3a-Frank-5
7803: PPUSH
7804: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
7808: LD_EXP 8
7812: PPUSH
7813: LD_STRING D3a-JMM-5
7815: PPUSH
7816: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
7820: LD_EXP 14
7824: PPUSH
7825: LD_STRING D3a-Frank-6
7827: PPUSH
7828: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
7832: LD_EXP 8
7836: PPUSH
7837: LD_STRING D3a-JMM-6
7839: PPUSH
7840: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
7844: LD_EXP 14
7848: PPUSH
7849: LD_STRING D3a-Frank-7
7851: PPUSH
7852: CALL_OW 88
// InGameOff ;
7856: CALL_OW 9
// end ;
7860: PPOPN 2
7862: END
// every 0 0$1 trigger Kikuchi and GetDistUnits ( JMM , Kikuchi ) < 5 and not InBattle ( 1 ) do
7863: LD_EXP 17
7867: PUSH
7868: LD_EXP 8
7872: PPUSH
7873: LD_EXP 17
7877: PPUSH
7878: CALL_OW 296
7882: PUSH
7883: LD_INT 5
7885: LESS
7886: AND
7887: PUSH
7888: LD_INT 1
7890: PPUSH
7891: CALL_OW 463
7895: NOT
7896: AND
7897: IFFALSE 8077
7899: GO 7901
7901: DISABLE
// begin InGameOn ;
7902: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
7906: LD_EXP 8
7910: PPUSH
7911: LD_EXP 17
7915: PPUSH
7916: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
7920: LD_EXP 17
7924: PPUSH
7925: LD_EXP 8
7929: PPUSH
7930: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
7934: LD_EXP 17
7938: PPUSH
7939: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
7943: LD_EXP 17
7947: PPUSH
7948: LD_STRING D3b-Yam-1
7950: PPUSH
7951: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
7955: LD_EXP 8
7959: PPUSH
7960: LD_STRING D3b-JMM-1
7962: PPUSH
7963: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
7967: LD_INT 1
7969: PPUSH
7970: LD_INT 4
7972: PPUSH
7973: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
7977: LD_INT 85
7979: PPUSH
7980: LD_INT 134
7982: PPUSH
7983: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
7987: LD_EXP 17
7991: PPUSH
7992: LD_STRING D3b-Yam-2
7994: PPUSH
7995: CALL_OW 88
// Wait ( 0 0$01 ) ;
7999: LD_INT 35
8001: PPUSH
8002: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
8006: LD_EXP 8
8010: PPUSH
8011: LD_STRING D3b-JMM-2
8013: PPUSH
8014: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
8018: LD_INT 166
8020: PPUSH
8021: LD_INT 136
8023: PPUSH
8024: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
8028: LD_EXP 17
8032: PPUSH
8033: LD_STRING D3b-Yam-3
8035: PPUSH
8036: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
8040: LD_EXP 8
8044: PPUSH
8045: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
8049: LD_EXP 8
8053: PPUSH
8054: LD_STRING D3b-JMM-3a
8056: PPUSH
8057: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
8061: LD_EXP 17
8065: PPUSH
8066: LD_INT 1
8068: PPUSH
8069: CALL_OW 235
// InGameOff ;
8073: CALL_OW 9
// end ;
8077: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , i ;
8078: LD_INT 7
8080: PPUSH
8081: LD_INT 22
8083: PUSH
8084: LD_INT 1
8086: PUSH
8087: EMPTY
8088: LIST
8089: LIST
8090: PUSH
8091: LD_INT 3
8093: PUSH
8094: LD_INT 24
8096: PUSH
8097: LD_INT 1000
8099: PUSH
8100: EMPTY
8101: LIST
8102: LIST
8103: PUSH
8104: EMPTY
8105: LIST
8106: LIST
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: PPUSH
8112: CALL_OW 70
8116: IFFALSE 8534
8118: GO 8120
8120: DISABLE
8121: LD_INT 0
8123: PPUSH
8124: PPUSH
8125: PPUSH
// begin un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) [ 1 ] ;
8126: LD_ADDR_VAR 0 1
8130: PUSH
8131: LD_INT 7
8133: PPUSH
8134: LD_INT 22
8136: PUSH
8137: LD_INT 1
8139: PUSH
8140: EMPTY
8141: LIST
8142: LIST
8143: PUSH
8144: LD_INT 3
8146: PUSH
8147: LD_INT 24
8149: PUSH
8150: LD_INT 1000
8152: PUSH
8153: EMPTY
8154: LIST
8155: LIST
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: PUSH
8161: EMPTY
8162: LIST
8163: LIST
8164: PPUSH
8165: CALL_OW 70
8169: PUSH
8170: LD_INT 1
8172: ARRAY
8173: ST_TO_ADDR
// DialogueOn ;
8174: CALL_OW 6
// CenterNowOnUnits ( un ) ;
8178: LD_VAR 0 1
8182: PPUSH
8183: CALL_OW 87
// if Lisa then
8187: LD_EXP 13
8191: IFFALSE 8219
// begin Say ( Lisa , D5-Lisa-1 ) ;
8193: LD_EXP 13
8197: PPUSH
8198: LD_STRING D5-Lisa-1
8200: PPUSH
8201: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
8205: LD_EXP 8
8209: PPUSH
8210: LD_STRING D5-JMM-1a
8212: PPUSH
8213: CALL_OW 88
// end else
8217: GO 8231
// Say ( JMM , D5-JMM-1 ) ;
8219: LD_EXP 8
8223: PPUSH
8224: LD_STRING D5-JMM-1
8226: PPUSH
8227: CALL_OW 88
// DialogueOff ;
8231: CALL_OW 7
// while ( true ) do
8235: LD_INT 1
8237: IFFALSE 8293
// begin wait ( 0 0$01 ) ;
8239: LD_INT 35
8241: PPUSH
8242: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
8246: LD_ADDR_VAR 0 2
8250: PUSH
8251: LD_INT 8
8253: PPUSH
8254: LD_INT 30
8256: PUSH
8257: LD_INT 26
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: PUSH
8264: LD_INT 101
8266: PUSH
8267: LD_INT 1
8269: PUSH
8270: EMPTY
8271: LIST
8272: LIST
8273: PUSH
8274: EMPTY
8275: LIST
8276: LIST
8277: PPUSH
8278: CALL_OW 71
8282: ST_TO_ADDR
// if x then
8283: LD_VAR 0 2
8287: IFFALSE 8291
// break ;
8289: GO 8293
// end ;
8291: GO 8235
// CenterOnUnits ( x [ 1 ] ) ;
8293: LD_VAR 0 2
8297: PUSH
8298: LD_INT 1
8300: ARRAY
8301: PPUSH
8302: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
8306: LD_EXP 14
8310: PUSH
8311: LD_EXP 14
8315: PPUSH
8316: CALL_OW 255
8320: PUSH
8321: LD_INT 1
8323: EQUAL
8324: AND
8325: IFFALSE 8341
// Say ( Frank , D5a-Frank-1 ) else
8327: LD_EXP 14
8331: PPUSH
8332: LD_STRING D5a-Frank-1
8334: PPUSH
8335: CALL_OW 88
8339: GO 8395
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
8341: LD_EXP 17
8345: PUSH
8346: LD_EXP 17
8350: PPUSH
8351: CALL_OW 255
8355: PUSH
8356: LD_INT 1
8358: EQUAL
8359: AND
8360: IFFALSE 8376
// Say ( Kikuchi , D5a-Yam-1 ) else
8362: LD_EXP 17
8366: PPUSH
8367: LD_STRING D5a-Yam-1
8369: PPUSH
8370: CALL_OW 88
8374: GO 8395
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
8376: LD_INT 1
8378: PPUSH
8379: CALL 505 0 1
8383: PUSH
8384: LD_INT 1
8386: ARRAY
8387: PPUSH
8388: LD_STRING D5a-Sol1-1
8390: PPUSH
8391: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
8395: LD_EXP 8
8399: PPUSH
8400: LD_STRING D5a-JMM-1
8402: PPUSH
8403: CALL_OW 88
// if Cyrus then
8407: LD_EXP 12
8411: IFFALSE 8425
// Say ( Cyrus , D5a-Cyrus-1 ) ;
8413: LD_EXP 12
8417: PPUSH
8418: LD_STRING D5a-Cyrus-1
8420: PPUSH
8421: CALL_OW 88
// x := false ;
8425: LD_ADDR_VAR 0 2
8429: PUSH
8430: LD_INT 0
8432: ST_TO_ADDR
// while ( true ) do
8433: LD_INT 1
8435: IFFALSE 8522
// begin wait ( 0 0$01 ) ;
8437: LD_INT 35
8439: PPUSH
8440: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
8444: LD_ADDR_VAR 0 3
8448: PUSH
8449: LD_INT 2
8451: PUSH
8452: LD_INT 30
8454: PUSH
8455: LD_INT 0
8457: PUSH
8458: EMPTY
8459: LIST
8460: LIST
8461: PUSH
8462: LD_INT 30
8464: PUSH
8465: LD_INT 1
8467: PUSH
8468: EMPTY
8469: LIST
8470: LIST
8471: PUSH
8472: EMPTY
8473: LIST
8474: LIST
8475: LIST
8476: PPUSH
8477: CALL_OW 69
8481: PUSH
8482: LD_INT 1
8484: DIFF
8485: PUSH
8486: FOR_IN
8487: IFFALSE 8510
// if BaseNeedEnergy ( i ) then
8489: LD_VAR 0 3
8493: PPUSH
8494: CALL 1208 0 1
8498: IFFALSE 8508
// x := true ;
8500: LD_ADDR_VAR 0 2
8504: PUSH
8505: LD_INT 1
8507: ST_TO_ADDR
8508: GO 8486
8510: POP
8511: POP
// if x then
8512: LD_VAR 0 2
8516: IFFALSE 8520
// break ;
8518: GO 8522
// end ;
8520: GO 8433
// Say ( JMM , D5b-JMM-1 ) ;
8522: LD_EXP 8
8526: PPUSH
8527: LD_STRING D5b-JMM-1
8529: PPUSH
8530: CALL_OW 88
// end ;
8534: PPOPN 3
8536: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
8537: LD_EXP 5
8541: PUSH
8542: LD_INT 1
8544: ARRAY
8545: PUSH
8546: LD_OWVAR 1
8550: LESS
8551: IFFALSE 8751
8553: GO 8555
8555: DISABLE
// begin if not IsDead ( ru_dep_main ) then
8556: LD_INT 16
8558: PPUSH
8559: CALL_OW 301
8563: NOT
8564: IFFALSE 8587
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
8566: LD_EXP 18
8570: PPUSH
8571: LD_STRING D3b-Har-3
8573: PPUSH
8574: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
8578: LD_STRING M2a
8580: PPUSH
8581: CALL_OW 337
// end else
8585: GO 8606
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
8587: LD_EXP 18
8591: PPUSH
8592: LD_STRING D3b-Har-3a
8594: PPUSH
8595: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
8599: LD_STRING M2
8601: PPUSH
8602: CALL_OW 337
// end ; can_end := true ;
8606: LD_ADDR_EXP 6
8610: PUSH
8611: LD_INT 1
8613: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
8614: LD_INT 9
8616: PPUSH
8617: LD_INT 1
8619: PPUSH
8620: CALL_OW 424
// Wait ( 0 0$02 ) ;
8624: LD_INT 70
8626: PPUSH
8627: CALL_OW 67
// if Lisa then
8631: LD_EXP 13
8635: IFFALSE 8649
// Say ( Lisa , D3b-Lisa ) ;
8637: LD_EXP 13
8641: PPUSH
8642: LD_STRING D3b-Lisa
8644: PPUSH
8645: CALL_OW 88
// if Bobby then
8649: LD_EXP 11
8653: IFFALSE 8667
// Say ( Bobby , D3b-Bobby-3 ) ;
8655: LD_EXP 11
8659: PPUSH
8660: LD_STRING D3b-Bobby-3
8662: PPUSH
8663: CALL_OW 88
// if Cyrus then
8667: LD_EXP 12
8671: IFFALSE 8685
// Say ( Cyrus , D3b-Cyrus-3 ) ;
8673: LD_EXP 12
8677: PPUSH
8678: LD_STRING D3b-Cyrus-3
8680: PPUSH
8681: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
8685: LD_EXP 14
8689: PUSH
8690: LD_EXP 14
8694: PPUSH
8695: CALL_OW 255
8699: PUSH
8700: LD_INT 1
8702: EQUAL
8703: AND
8704: IFFALSE 8718
// Say ( Frank , D3b-Frank-3 ) ;
8706: LD_EXP 14
8710: PPUSH
8711: LD_STRING D3b-Frank-3
8713: PPUSH
8714: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
8718: LD_EXP 17
8722: PUSH
8723: LD_EXP 17
8727: PPUSH
8728: CALL_OW 255
8732: PUSH
8733: LD_INT 1
8735: EQUAL
8736: AND
8737: IFFALSE 8751
// Say ( Kikuchi , D3b-Yam-4 ) ;
8739: LD_EXP 17
8743: PPUSH
8744: LD_STRING D3b-Yam-4
8746: PPUSH
8747: CALL_OW 88
// end ;
8751: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
8752: LD_EXP 5
8756: PUSH
8757: LD_INT 2
8759: ARRAY
8760: PUSH
8761: LD_OWVAR 1
8765: LESS
8766: IFFALSE 8798
8768: GO 8770
8770: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
8771: LD_EXP 18
8775: PPUSH
8776: LD_STRING D4-Har-1
8778: PPUSH
8779: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
8783: LD_STRING M3
8785: PPUSH
8786: CALL_OW 337
// must_end := true ;
8790: LD_ADDR_EXP 7
8794: PUSH
8795: LD_INT 1
8797: ST_TO_ADDR
// end ;
8798: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
8799: LD_EXP 5
8803: PUSH
8804: LD_INT 3
8806: ARRAY
8807: PUSH
8808: LD_OWVAR 1
8812: LESS
8813: IFFALSE 8844
8815: GO 8817
8817: DISABLE
// begin if not IsDead ( ru_dep_main ) then
8818: LD_INT 16
8820: PPUSH
8821: CALL_OW 301
8825: NOT
8826: IFFALSE 8837
// YouLost ( TimeOut1 ) else
8828: LD_STRING TimeOut1
8830: PPUSH
8831: CALL_OW 104
8835: GO 8844
// YouLost ( TimeOut2 ) ;
8837: LD_STRING TimeOut2
8839: PPUSH
8840: CALL_OW 104
// end ;
8844: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , i , tmp ;
8845: LD_EXP 8
8849: PPUSH
8850: LD_INT 9
8852: PPUSH
8853: CALL_OW 308
8857: PUSH
8858: LD_EXP 6
8862: AND
8863: IFFALSE 9854
8865: GO 8867
8867: DISABLE
8868: LD_INT 0
8870: PPUSH
8871: PPUSH
8872: PPUSH
// begin wait_on := false ;
8873: LD_ADDR_VAR 0 1
8877: PUSH
8878: LD_INT 0
8880: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
8881: LD_INT 1
8883: PPUSH
8884: CALL 1285 0 1
8888: PUSH
8889: LD_INT 0
8891: PLUS
8892: PUSH
8893: LD_INT 1
8895: PPUSH
8896: LD_INT 9
8898: PPUSH
8899: CALL 1376 0 2
8903: PUSH
8904: LD_INT 1
8906: PPUSH
8907: LD_INT 9
8909: PPUSH
8910: CALL 1423 0 2
8914: ADD
8915: PUSH
8916: LD_INT 0
8918: PLUS
8919: GREATER
8920: IFFALSE 8969
// case Query ( Q1 ) of 1 :
8922: LD_STRING Q1
8924: PPUSH
8925: CALL_OW 97
8929: PUSH
8930: LD_INT 1
8932: DOUBLE
8933: EQUAL
8934: IFTRUE 8938
8936: GO 8949
8938: POP
// wait_on := true ; 2 :
8939: LD_ADDR_VAR 0 1
8943: PUSH
8944: LD_INT 1
8946: ST_TO_ADDR
8947: GO 8969
8949: LD_INT 2
8951: DOUBLE
8952: EQUAL
8953: IFTRUE 8957
8955: GO 8968
8957: POP
// wait_on := false ; end ;
8958: LD_ADDR_VAR 0 1
8962: PUSH
8963: LD_INT 0
8965: ST_TO_ADDR
8966: GO 8969
8968: POP
// repeat wait ( 0 0$01 ) ;
8969: LD_INT 35
8971: PPUSH
8972: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
8976: LD_VAR 0 1
8980: NOT
8981: PUSH
8982: LD_INT 1
8984: PPUSH
8985: CALL 1285 0 1
8989: PUSH
8990: LD_INT 0
8992: PLUS
8993: PUSH
8994: LD_INT 1
8996: PPUSH
8997: LD_INT 9
8999: PPUSH
9000: CALL 1376 0 2
9004: PUSH
9005: LD_INT 1
9007: PPUSH
9008: LD_INT 9
9010: PPUSH
9011: CALL 1423 0 2
9015: ADD
9016: PUSH
9017: LD_INT 0
9019: PLUS
9020: EQUAL
9021: OR
9022: IFFALSE 8969
// DialogueOn ;
9024: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
9028: LD_EXP 8
9032: PPUSH
9033: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
9037: LD_EXP 8
9041: PPUSH
9042: LD_STRING D6-JMM-1
9044: PPUSH
9045: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
9049: LD_EXP 18
9053: PPUSH
9054: LD_STRING D6-Har-1
9056: PPUSH
9057: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
9061: LD_EXP 8
9065: PPUSH
9066: LD_STRING D6-JMM-2
9068: PPUSH
9069: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
9073: LD_EXP 18
9077: PPUSH
9078: LD_STRING D6-Har-2
9080: PPUSH
9081: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
9085: LD_EXP 8
9089: PPUSH
9090: LD_STRING D6-JMM-3
9092: PPUSH
9093: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
9097: LD_EXP 18
9101: PPUSH
9102: LD_STRING D6-Har-3
9104: PPUSH
9105: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
9109: LD_EXP 8
9113: PPUSH
9114: LD_STRING D6-JMM-4
9116: PPUSH
9117: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
9121: LD_EXP 18
9125: PPUSH
9126: LD_STRING D6-Har-4
9128: PPUSH
9129: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
9133: LD_EXP 8
9137: PPUSH
9138: LD_STRING D6-JMM-5
9140: PPUSH
9141: CALL_OW 88
// DialogueOff ;
9145: CALL_OW 7
// tmp := FilterBuildings ( 3 ) ;
9149: LD_ADDR_VAR 0 3
9153: PUSH
9154: LD_INT 3
9156: PPUSH
9157: CALL 1554 0 1
9161: ST_TO_ADDR
// if tmp >= 35 then
9162: LD_VAR 0 3
9166: PUSH
9167: LD_INT 35
9169: GREATEREQUAL
9170: IFFALSE 9207
// begin AddMedal ( Destroy1 , - 1 ) ;
9172: LD_STRING Destroy1
9174: PPUSH
9175: LD_INT 1
9177: NEG
9178: PPUSH
9179: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
9183: LD_STRING Destroy2
9185: PPUSH
9186: LD_INT 1
9188: NEG
9189: PPUSH
9190: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
9194: LD_STRING Destroy3
9196: PPUSH
9197: LD_INT 1
9199: NEG
9200: PPUSH
9201: CALL_OW 101
// end else
9205: GO 9294
// begin AddMedal ( Destroy1 , 1 ) ;
9207: LD_STRING Destroy1
9209: PPUSH
9210: LD_INT 1
9212: PPUSH
9213: CALL_OW 101
// if tmp >= 25 then
9217: LD_VAR 0 3
9221: PUSH
9222: LD_INT 25
9224: GREATEREQUAL
9225: IFFALSE 9251
// begin AddMedal ( Destroy2 , - 1 ) ;
9227: LD_STRING Destroy2
9229: PPUSH
9230: LD_INT 1
9232: NEG
9233: PPUSH
9234: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
9238: LD_STRING Destroy3
9240: PPUSH
9241: LD_INT 1
9243: NEG
9244: PPUSH
9245: CALL_OW 101
// end else
9249: GO 9294
// begin AddMedal ( Destroy2 , 1 ) ;
9251: LD_STRING Destroy2
9253: PPUSH
9254: LD_INT 1
9256: PPUSH
9257: CALL_OW 101
// if tmp >= 15 then
9261: LD_VAR 0 3
9265: PUSH
9266: LD_INT 15
9268: GREATEREQUAL
9269: IFFALSE 9284
// AddMedal ( Destroy3 , - 1 ) else
9271: LD_STRING Destroy3
9273: PPUSH
9274: LD_INT 1
9276: NEG
9277: PPUSH
9278: CALL_OW 101
9282: GO 9294
// AddMedal ( Destroy3 , 1 ) ;
9284: LD_STRING Destroy3
9286: PPUSH
9287: LD_INT 1
9289: PPUSH
9290: CALL_OW 101
// end ; end ; GiveMedals ( MAIN ) ;
9294: LD_STRING MAIN
9296: PPUSH
9297: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ;
9301: LD_ADDR_VAR 0 3
9305: PUSH
9306: LD_INT 1
9308: PPUSH
9309: LD_INT 9
9311: PPUSH
9312: CALL 1376 0 2
9316: PUSH
9317: LD_INT 1
9319: PPUSH
9320: LD_INT 9
9322: PPUSH
9323: CALL 1423 0 2
9327: ADD
9328: ST_TO_ADDR
// RewardPeople ( tmp ) ;
9329: LD_VAR 0 3
9333: PPUSH
9334: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
9338: LD_EXP 8
9342: PPUSH
9343: LD_EXP 3
9347: PUSH
9348: LD_STRING JMM
9350: STR
9351: PPUSH
9352: CALL_OW 38
// if Brown in tmp then
9356: LD_EXP 9
9360: PUSH
9361: LD_VAR 0 3
9365: IN
9366: IFFALSE 9386
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
9368: LD_EXP 9
9372: PPUSH
9373: LD_EXP 3
9377: PUSH
9378: LD_STRING Brown
9380: STR
9381: PPUSH
9382: CALL_OW 38
// if Donaldson in tmp then
9386: LD_EXP 10
9390: PUSH
9391: LD_VAR 0 3
9395: IN
9396: IFFALSE 9416
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
9398: LD_EXP 10
9402: PPUSH
9403: LD_EXP 3
9407: PUSH
9408: LD_STRING Donaldson
9410: STR
9411: PPUSH
9412: CALL_OW 38
// if Bobby in tmp then
9416: LD_EXP 11
9420: PUSH
9421: LD_VAR 0 3
9425: IN
9426: IFFALSE 9446
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
9428: LD_EXP 11
9432: PPUSH
9433: LD_EXP 3
9437: PUSH
9438: LD_STRING Bobby
9440: STR
9441: PPUSH
9442: CALL_OW 38
// if Cyrus in tmp then
9446: LD_EXP 12
9450: PUSH
9451: LD_VAR 0 3
9455: IN
9456: IFFALSE 9476
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
9458: LD_EXP 12
9462: PPUSH
9463: LD_EXP 3
9467: PUSH
9468: LD_STRING Cyrus
9470: STR
9471: PPUSH
9472: CALL_OW 38
// if Lisa in tmp then
9476: LD_EXP 13
9480: PUSH
9481: LD_VAR 0 3
9485: IN
9486: IFFALSE 9506
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
9488: LD_EXP 13
9492: PPUSH
9493: LD_EXP 3
9497: PUSH
9498: LD_STRING Lisa
9500: STR
9501: PPUSH
9502: CALL_OW 38
// if Frank in tmp then
9506: LD_EXP 14
9510: PUSH
9511: LD_VAR 0 3
9515: IN
9516: IFFALSE 9536
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
9518: LD_EXP 14
9522: PPUSH
9523: LD_EXP 3
9527: PUSH
9528: LD_STRING Frank
9530: STR
9531: PPUSH
9532: CALL_OW 38
// if Gladstone in tmp then
9536: LD_EXP 15
9540: PUSH
9541: LD_VAR 0 3
9545: IN
9546: IFFALSE 9566
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
9548: LD_EXP 15
9552: PPUSH
9553: LD_EXP 3
9557: PUSH
9558: LD_STRING Gladstone
9560: STR
9561: PPUSH
9562: CALL_OW 38
// if Khatam in tmp then
9566: LD_EXP 16
9570: PUSH
9571: LD_VAR 0 3
9575: IN
9576: IFFALSE 9596
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
9578: LD_EXP 16
9582: PPUSH
9583: LD_EXP 3
9587: PUSH
9588: LD_STRING Khatam
9590: STR
9591: PPUSH
9592: CALL_OW 38
// if Kikuchi in tmp then
9596: LD_EXP 17
9600: PUSH
9601: LD_VAR 0 3
9605: IN
9606: IFFALSE 9626
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
9608: LD_EXP 17
9612: PPUSH
9613: LD_EXP 3
9617: PUSH
9618: LD_STRING Kikuchi
9620: STR
9621: PPUSH
9622: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] , mission_prefix & others ) ;
9626: LD_VAR 0 3
9630: PUSH
9631: LD_EXP 8
9635: PUSH
9636: LD_EXP 9
9640: PUSH
9641: LD_EXP 10
9645: PUSH
9646: LD_EXP 11
9650: PUSH
9651: LD_EXP 12
9655: PUSH
9656: LD_EXP 13
9660: PUSH
9661: LD_EXP 14
9665: PUSH
9666: LD_EXP 15
9670: PUSH
9671: LD_EXP 17
9675: PUSH
9676: LD_EXP 16
9680: PUSH
9681: EMPTY
9682: LIST
9683: LIST
9684: LIST
9685: LIST
9686: LIST
9687: LIST
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: DIFF
9693: PPUSH
9694: LD_EXP 3
9698: PUSH
9699: LD_STRING others
9701: STR
9702: PPUSH
9703: CALL_OW 38
// SaveVariable ( tick , 07_time ) ;
9707: LD_OWVAR 1
9711: PPUSH
9712: LD_STRING 07_time
9714: PPUSH
9715: CALL_OW 39
// tmp := [ ] ;
9719: LD_ADDR_VAR 0 3
9723: PUSH
9724: EMPTY
9725: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ] ) do
9726: LD_ADDR_VAR 0 2
9730: PUSH
9731: LD_INT 22
9733: PUSH
9734: LD_INT 1
9736: PUSH
9737: EMPTY
9738: LIST
9739: LIST
9740: PUSH
9741: LD_INT 23
9743: PUSH
9744: LD_INT 1
9746: PUSH
9747: EMPTY
9748: LIST
9749: LIST
9750: PUSH
9751: LD_INT 21
9753: PUSH
9754: LD_INT 2
9756: PUSH
9757: EMPTY
9758: LIST
9759: LIST
9760: PUSH
9761: EMPTY
9762: LIST
9763: LIST
9764: LIST
9765: PUSH
9766: EMPTY
9767: LIST
9768: PPUSH
9769: CALL_OW 69
9773: PUSH
9774: FOR_IN
9775: IFFALSE 9836
// tmp := tmp ^ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
9777: LD_ADDR_VAR 0 3
9781: PUSH
9782: LD_VAR 0 3
9786: PUSH
9787: LD_VAR 0 2
9791: PPUSH
9792: CALL_OW 265
9796: PUSH
9797: LD_VAR 0 2
9801: PPUSH
9802: CALL_OW 262
9806: PUSH
9807: LD_VAR 0 2
9811: PPUSH
9812: CALL_OW 263
9816: PUSH
9817: LD_VAR 0 2
9821: PPUSH
9822: CALL_OW 264
9826: PUSH
9827: EMPTY
9828: LIST
9829: LIST
9830: LIST
9831: LIST
9832: ADD
9833: ST_TO_ADDR
9834: GO 9774
9836: POP
9837: POP
// SaveVariable ( tmp , 07_vehicles ) ;
9838: LD_VAR 0 3
9842: PPUSH
9843: LD_STRING 07_vehicles
9845: PPUSH
9846: CALL_OW 39
// YouWin ;
9850: CALL_OW 103
// end ; end_of_file
9854: PPOPN 3
9856: END
// on UnitDestroyed ( un ) do begin if un = JMM then
9857: LD_VAR 0 1
9861: PUSH
9862: LD_EXP 8
9866: EQUAL
9867: IFFALSE 9876
// YouLost ( JMM ) ;
9869: LD_STRING JMM
9871: PPUSH
9872: CALL_OW 104
// if GetType ( un ) = unit_building then
9876: LD_VAR 0 1
9880: PPUSH
9881: CALL_OW 247
9885: PUSH
9886: LD_INT 3
9888: EQUAL
9889: IFFALSE 9905
// buildings_counter := buildings_counter + 1 ;
9891: LD_ADDR_EXP 4
9895: PUSH
9896: LD_EXP 4
9900: PUSH
9901: LD_INT 1
9903: PLUS
9904: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
9905: LD_VAR 0 1
9909: PUSH
9910: LD_INT 6
9912: PPUSH
9913: LD_INT 2
9915: PUSH
9916: LD_INT 30
9918: PUSH
9919: LD_INT 33
9921: PUSH
9922: EMPTY
9923: LIST
9924: LIST
9925: PUSH
9926: LD_INT 30
9928: PUSH
9929: LD_INT 32
9931: PUSH
9932: EMPTY
9933: LIST
9934: LIST
9935: PUSH
9936: EMPTY
9937: LIST
9938: LIST
9939: LIST
9940: PPUSH
9941: CALL_OW 70
9945: IN
9946: IFFALSE 10005
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
9948: LD_ADDR_EXP 19
9952: PUSH
9953: LD_EXP 19
9957: PUSH
9958: LD_VAR 0 1
9962: PPUSH
9963: CALL_OW 266
9967: PUSH
9968: LD_VAR 0 1
9972: PPUSH
9973: CALL_OW 250
9977: PUSH
9978: LD_VAR 0 1
9982: PPUSH
9983: CALL_OW 251
9987: PUSH
9988: LD_VAR 0 1
9992: PPUSH
9993: CALL_OW 254
9997: PUSH
9998: EMPTY
9999: LIST
10000: LIST
10001: LIST
10002: LIST
10003: ADD
10004: ST_TO_ADDR
// if un = ru_dep_main then
10005: LD_VAR 0 1
10009: PUSH
10010: LD_INT 16
10012: EQUAL
10013: IFFALSE 10022
// ChangeMissionObjectives ( M1a ) ;
10015: LD_STRING M1a
10017: PPUSH
10018: CALL_OW 337
// end ;
10022: PPOPN 1
10024: END
// on BuildingStarted ( b , builder ) do var i ;
10025: LD_INT 0
10027: PPUSH
// begin if GetSide ( b ) = 3 then
10028: LD_VAR 0 1
10032: PPUSH
10033: CALL_OW 255
10037: PUSH
10038: LD_INT 3
10040: EQUAL
10041: IFFALSE 10081
// for i = 1 to 4 do
10043: LD_ADDR_VAR 0 3
10047: PUSH
10048: DOUBLE
10049: LD_INT 1
10051: DEC
10052: ST_TO_ADDR
10053: LD_INT 4
10055: PUSH
10056: FOR_TO
10057: IFFALSE 10079
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
10059: LD_ADDR_EXP 19
10063: PUSH
10064: LD_EXP 19
10068: PPUSH
10069: LD_INT 1
10071: PPUSH
10072: CALL_OW 3
10076: ST_TO_ADDR
10077: GO 10056
10079: POP
10080: POP
// end ;
10081: PPOPN 3
10083: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
10084: LD_VAR 0 1
10088: PPUSH
10089: CALL_OW 266
10093: PUSH
10094: LD_INT 32
10096: PUSH
10097: LD_INT 33
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: IN
10104: IFFALSE 10118
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
10106: LD_VAR 0 1
10110: PPUSH
10111: LD_INT 43
10113: PPUSH
10114: CALL_OW 148
10118: PPOPN 1
10120: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
10121: LD_VAR 0 1
10125: PUSH
10126: LD_INT 22
10128: PUSH
10129: LD_INT 3
10131: PUSH
10132: EMPTY
10133: LIST
10134: LIST
10135: PUSH
10136: LD_INT 2
10138: PUSH
10139: LD_INT 30
10141: PUSH
10142: LD_INT 31
10144: PUSH
10145: EMPTY
10146: LIST
10147: LIST
10148: PUSH
10149: LD_INT 30
10151: PUSH
10152: LD_INT 32
10154: PUSH
10155: EMPTY
10156: LIST
10157: LIST
10158: PUSH
10159: EMPTY
10160: LIST
10161: LIST
10162: LIST
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: PPUSH
10168: CALL_OW 69
10172: IN
10173: IFFALSE 10195
// GoToAnotherTower ( un , b , 143 , 143 ) ;
10175: LD_VAR 0 2
10179: PPUSH
10180: LD_VAR 0 1
10184: PPUSH
10185: LD_INT 143
10187: PPUSH
10188: LD_INT 143
10190: PPUSH
10191: CALL 735 0 4
// end ;
10195: PPOPN 2
10197: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
10198: LD_VAR 0 1
10202: PUSH
10203: LD_INT 22
10205: PUSH
10206: LD_INT 3
10208: PUSH
10209: EMPTY
10210: LIST
10211: LIST
10212: PUSH
10213: LD_INT 30
10215: PUSH
10216: LD_INT 32
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: PPUSH
10227: CALL_OW 69
10231: IN
10232: IFFALSE 10246
// SetTag ( b , 0 ) ;
10234: LD_VAR 0 1
10238: PPUSH
10239: LD_INT 0
10241: PPUSH
10242: CALL_OW 109
// end ;
10246: PPOPN 2
10248: END
