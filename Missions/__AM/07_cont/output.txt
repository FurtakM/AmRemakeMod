// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 33 0 0
// DebugMode ;
  12: CALL 234 0 0
// PrepareNature ;
  16: CALL 2917 0 0
// PrepareRussians ;
  20: CALL 4459 0 0
// PrepareAmericans ;
  24: CALL 3402 0 0
// Action ;
  28: CALL 8308 0 0
// end ;
  32: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end , must_end ; function Init ; begin
  33: LD_INT 0
  35: PPUSH
// debug := false ;
  36: LD_ADDR_EXP 1
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// mission_prefix := 07c_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 07c_
  51: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  52: LD_ADDR_EXP 2
  56: PUSH
  57: LD_STRING 07_
  59: ST_TO_ADDR
// buildings_counter := 0 ;
  60: LD_ADDR_EXP 4
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// time_to_end := [ [ 30 30$00 , 27 27$00 , 24 24$00 ] [ Difficulty ] , [ 36 36$00 , 33 33$00 , 30 30$00 ] [ Difficulty ] , [ 42 42$00 , 39 39$00 , 36 36$00 ] [ Difficulty ] ] ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 63000
  75: PUSH
  76: LD_INT 56700
  78: PUSH
  79: LD_INT 50400
  81: PUSH
  82: EMPTY
  83: LIST
  84: LIST
  85: LIST
  86: PUSH
  87: LD_OWVAR 67
  91: ARRAY
  92: PUSH
  93: LD_INT 75600
  95: PUSH
  96: LD_INT 69300
  98: PUSH
  99: LD_INT 63000
 101: PUSH
 102: EMPTY
 103: LIST
 104: LIST
 105: LIST
 106: PUSH
 107: LD_OWVAR 67
 111: ARRAY
 112: PUSH
 113: LD_INT 88200
 115: PUSH
 116: LD_INT 81900
 118: PUSH
 119: LD_INT 75600
 121: PUSH
 122: EMPTY
 123: LIST
 124: LIST
 125: LIST
 126: PUSH
 127: LD_OWVAR 67
 131: ARRAY
 132: PUSH
 133: EMPTY
 134: LIST
 135: LIST
 136: LIST
 137: ST_TO_ADDR
// can_end := false ;
 138: LD_ADDR_EXP 6
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// must_end := false ;
 146: LD_ADDR_EXP 7
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// end ;
 154: LD_VAR 0 1
 158: RET
// every 0 0$01 trigger not debug do
 159: LD_EXP 1
 163: NOT
 164: IFFALSE 233
 166: GO 168
 168: DISABLE
// begin enable ;
 169: ENABLE
// if not must_end then
 170: LD_EXP 7
 174: NOT
 175: IFFALSE 196
// display_strings := [ #Am07-1 , tick ] else
 177: LD_ADDR_OWVAR 47
 181: PUSH
 182: LD_STRING #Am07-1
 184: PUSH
 185: LD_OWVAR 1
 189: PUSH
 190: EMPTY
 191: LIST
 192: LIST
 193: ST_TO_ADDR
 194: GO 233
// display_strings := [ #Am07-1 , tick , #Am07-2 , time_to_end [ 3 ] - tick ] ;
 196: LD_ADDR_OWVAR 47
 200: PUSH
 201: LD_STRING #Am07-1
 203: PUSH
 204: LD_OWVAR 1
 208: PUSH
 209: LD_STRING #Am07-2
 211: PUSH
 212: LD_EXP 5
 216: PUSH
 217: LD_INT 3
 219: ARRAY
 220: PUSH
 221: LD_OWVAR 1
 225: MINUS
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: LIST
 232: ST_TO_ADDR
// end ;
 233: END
// function DebugMode ; begin
 234: LD_INT 0
 236: PPUSH
// if not debug then
 237: LD_EXP 1
 241: NOT
 242: IFFALSE 246
// exit ;
 244: GO 253
// FogOff ( 1 ) ;
 246: LD_INT 1
 248: PPUSH
 249: CALL_OW 344
// end ;
 253: LD_VAR 0 1
 257: RET
// every 3 trigger debug do var i , filter ;
 258: LD_EXP 1
 262: IFFALSE 351
 264: GO 266
 266: DISABLE
 267: LD_INT 0
 269: PPUSH
 270: PPUSH
// begin enable ;
 271: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 272: LD_ADDR_VAR 0 2
 276: PUSH
 277: LD_INT 22
 279: PUSH
 280: LD_INT 1
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: PUSH
 287: LD_INT 3
 289: PUSH
 290: LD_INT 24
 292: PUSH
 293: LD_INT 500
 295: PUSH
 296: EMPTY
 297: LIST
 298: LIST
 299: PUSH
 300: EMPTY
 301: LIST
 302: LIST
 303: PUSH
 304: EMPTY
 305: LIST
 306: LIST
 307: PPUSH
 308: CALL_OW 69
 312: ST_TO_ADDR
// if not filter then
 313: LD_VAR 0 2
 317: NOT
 318: IFFALSE 322
// exit ;
 320: GO 351
// for i in filter do
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_VAR 0 2
 331: PUSH
 332: FOR_IN
 333: IFFALSE 349
// SetLives ( i , 1000 ) ;
 335: LD_VAR 0 1
 339: PPUSH
 340: LD_INT 1000
 342: PPUSH
 343: CALL_OW 234
 347: GO 332
 349: POP
 350: POP
// end ; end_of_file
 351: PPOPN 2
 353: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 354: LD_INT 0
 356: PPUSH
 357: PPUSH
// if exist_mode then
 358: LD_VAR 0 2
 362: IFFALSE 387
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 364: LD_ADDR_VAR 0 4
 368: PUSH
 369: LD_EXP 2
 373: PUSH
 374: LD_VAR 0 1
 378: STR
 379: PPUSH
 380: CALL_OW 34
 384: ST_TO_ADDR
 385: GO 402
// unit := NewCharacter ( ident ) ;
 387: LD_ADDR_VAR 0 4
 391: PUSH
 392: LD_VAR 0 1
 396: PPUSH
 397: CALL_OW 25
 401: ST_TO_ADDR
// result := unit ;
 402: LD_ADDR_VAR 0 3
 406: PUSH
 407: LD_VAR 0 4
 411: ST_TO_ADDR
// end ;
 412: LD_VAR 0 3
 416: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 417: LD_INT 0
 419: PPUSH
// uc_side := side ;
 420: LD_ADDR_OWVAR 20
 424: PUSH
 425: LD_VAR 0 1
 429: ST_TO_ADDR
// uc_nation := nation ;
 430: LD_ADDR_OWVAR 21
 434: PUSH
 435: LD_VAR 0 2
 439: ST_TO_ADDR
// vc_chassis := chassis ;
 440: LD_ADDR_OWVAR 37
 444: PUSH
 445: LD_VAR 0 3
 449: ST_TO_ADDR
// vc_engine := engine ;
 450: LD_ADDR_OWVAR 39
 454: PUSH
 455: LD_VAR 0 4
 459: ST_TO_ADDR
// vc_control := control ;
 460: LD_ADDR_OWVAR 38
 464: PUSH
 465: LD_VAR 0 5
 469: ST_TO_ADDR
// vc_weapon := weapon ;
 470: LD_ADDR_OWVAR 40
 474: PUSH
 475: LD_VAR 0 6
 479: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 480: LD_ADDR_OWVAR 41
 484: PUSH
 485: LD_VAR 0 7
 489: ST_TO_ADDR
// result := CreateVehicle ;
 490: LD_ADDR_VAR 0 8
 494: PUSH
 495: CALL_OW 45
 499: ST_TO_ADDR
// end ;
 500: LD_VAR 0 8
 504: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 505: LD_INT 0
 507: PPUSH
 508: PPUSH
 509: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 510: LD_ADDR_VAR 0 4
 514: PUSH
 515: LD_INT 22
 517: PUSH
 518: LD_INT 1
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: PUSH
 525: LD_INT 21
 527: PUSH
 528: LD_INT 1
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: PUSH
 535: LD_INT 50
 537: PUSH
 538: EMPTY
 539: LIST
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: PPUSH
 546: CALL_OW 69
 550: PUSH
 551: LD_EXP 8
 555: PUSH
 556: LD_EXP 9
 560: PUSH
 561: LD_EXP 10
 565: PUSH
 566: LD_EXP 11
 570: PUSH
 571: LD_EXP 12
 575: PUSH
 576: LD_EXP 13
 580: PUSH
 581: LD_EXP 14
 585: PUSH
 586: LD_EXP 15
 590: PUSH
 591: LD_EXP 17
 595: PUSH
 596: LD_EXP 16
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: DIFF
 613: ST_TO_ADDR
// if not filter then
 614: LD_VAR 0 4
 618: NOT
 619: IFFALSE 623
// exit ;
 621: GO 650
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 623: LD_ADDR_VAR 0 2
 627: PUSH
 628: LD_VAR 0 4
 632: PPUSH
 633: LD_INT 26
 635: PUSH
 636: LD_VAR 0 1
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL_OW 72
 649: ST_TO_ADDR
// end ;
 650: LD_VAR 0 2
 654: RET
// export function SayX ( units , ident ) ; var i ; begin
 655: LD_INT 0
 657: PPUSH
 658: PPUSH
// result := false ;
 659: LD_ADDR_VAR 0 3
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// if not units then
 667: LD_VAR 0 1
 671: NOT
 672: IFFALSE 676
// exit ;
 674: GO 730
// for i in units do
 676: LD_ADDR_VAR 0 4
 680: PUSH
 681: LD_VAR 0 1
 685: PUSH
 686: FOR_IN
 687: IFFALSE 728
// if IsOk ( i ) then
 689: LD_VAR 0 4
 693: PPUSH
 694: CALL_OW 302
 698: IFFALSE 726
// begin Say ( i , ident ) ;
 700: LD_VAR 0 4
 704: PPUSH
 705: LD_VAR 0 2
 709: PPUSH
 710: CALL_OW 88
// result := i ;
 714: LD_ADDR_VAR 0 3
 718: PUSH
 719: LD_VAR 0 4
 723: ST_TO_ADDR
// break ;
 724: GO 728
// end ;
 726: GO 686
 728: POP
 729: POP
// end ;
 730: LD_VAR 0 3
 734: RET
// export function GetBaseBuildings ( base ) ; var tmp , i ; begin
 735: LD_INT 0
 737: PPUSH
 738: PPUSH
 739: PPUSH
// result := [ ] ;
 740: LD_ADDR_VAR 0 2
 744: PUSH
 745: EMPTY
 746: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
 747: LD_ADDR_VAR 0 3
 751: PUSH
 752: LD_INT 21
 754: PUSH
 755: LD_INT 3
 757: PUSH
 758: EMPTY
 759: LIST
 760: LIST
 761: PPUSH
 762: CALL_OW 69
 766: ST_TO_ADDR
// if not tmp then
 767: LD_VAR 0 3
 771: NOT
 772: IFFALSE 776
// exit ;
 774: GO 826
// for i in tmp do
 776: LD_ADDR_VAR 0 4
 780: PUSH
 781: LD_VAR 0 3
 785: PUSH
 786: FOR_IN
 787: IFFALSE 824
// if GetBase ( i ) = base then
 789: LD_VAR 0 4
 793: PPUSH
 794: CALL_OW 274
 798: PUSH
 799: LD_VAR 0 1
 803: EQUAL
 804: IFFALSE 822
// result := result ^ i ;
 806: LD_ADDR_VAR 0 2
 810: PUSH
 811: LD_VAR 0 2
 815: PUSH
 816: LD_VAR 0 4
 820: ADD
 821: ST_TO_ADDR
 822: GO 786
 824: POP
 825: POP
// end ;
 826: LD_VAR 0 2
 830: RET
// export function GetTurretWeapon ( tower ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
 831: LD_INT 0
 833: PPUSH
 834: PPUSH
 835: PPUSH
 836: PPUSH
 837: PPUSH
 838: PPUSH
 839: PPUSH
 840: PPUSH
 841: PPUSH
 842: PPUSH
 843: PPUSH
 844: PPUSH
 845: PPUSH
 846: PPUSH
 847: PPUSH
 848: PPUSH
// result := false ;
 849: LD_ADDR_VAR 0 2
 853: PUSH
 854: LD_INT 0
 856: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
 857: LD_VAR 0 1
 861: NOT
 862: PUSH
 863: LD_VAR 0 1
 867: PPUSH
 868: CALL_OW 266
 872: PUSH
 873: LD_INT 32
 875: PUSH
 876: LD_INT 33
 878: PUSH
 879: EMPTY
 880: LIST
 881: LIST
 882: IN
 883: NOT
 884: OR
 885: IFFALSE 889
// exit ;
 887: GO 2049
// nat := GetNation ( tower ) ;
 889: LD_ADDR_VAR 0 11
 893: PUSH
 894: LD_VAR 0 1
 898: PPUSH
 899: CALL_OW 248
 903: ST_TO_ADDR
// side := GetSide ( tower ) ;
 904: LD_ADDR_VAR 0 15
 908: PUSH
 909: LD_VAR 0 1
 913: PPUSH
 914: CALL_OW 255
 918: ST_TO_ADDR
// x := GetX ( tower ) ;
 919: LD_ADDR_VAR 0 9
 923: PUSH
 924: LD_VAR 0 1
 928: PPUSH
 929: CALL_OW 250
 933: ST_TO_ADDR
// y := GetY ( tower ) ;
 934: LD_ADDR_VAR 0 10
 938: PUSH
 939: LD_VAR 0 1
 943: PPUSH
 944: CALL_OW 251
 948: ST_TO_ADDR
// if not x or not y then
 949: LD_VAR 0 9
 953: NOT
 954: PUSH
 955: LD_VAR 0 10
 959: NOT
 960: OR
 961: IFFALSE 965
// exit ;
 963: GO 2049
// weapon := 0 ;
 965: LD_ADDR_VAR 0 17
 969: PUSH
 970: LD_INT 0
 972: ST_TO_ADDR
// fac_list := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun ] ;
 973: LD_ADDR_VAR 0 16
 977: PUSH
 978: LD_INT 42
 980: PUSH
 981: LD_INT 43
 983: PUSH
 984: LD_INT 44
 986: PUSH
 987: LD_INT 46
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: ST_TO_ADDR
// if not fac_list then
 996: LD_VAR 0 16
1000: NOT
1001: IFFALSE 1005
// exit ;
1003: GO 2049
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
1005: LD_ADDR_VAR 0 4
1009: PUSH
1010: LD_INT 4
1012: PUSH
1013: LD_INT 5
1015: PUSH
1016: LD_INT 9
1018: PUSH
1019: LD_INT 10
1021: PUSH
1022: LD_INT 6
1024: PUSH
1025: LD_INT 7
1027: PUSH
1028: LD_INT 11
1030: PUSH
1031: EMPTY
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: PUSH
1040: LD_INT 27
1042: PUSH
1043: LD_INT 28
1045: PUSH
1046: LD_INT 26
1048: PUSH
1049: LD_INT 30
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: PUSH
1058: LD_INT 43
1060: PUSH
1061: LD_INT 44
1063: PUSH
1064: LD_INT 46
1066: PUSH
1067: LD_INT 45
1069: PUSH
1070: LD_INT 47
1072: PUSH
1073: LD_INT 49
1075: PUSH
1076: EMPTY
1077: LIST
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: PUSH
1084: EMPTY
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: LD_VAR 0 11
1093: ARRAY
1094: ST_TO_ADDR
// for i in list do
1095: LD_ADDR_VAR 0 7
1099: PUSH
1100: LD_VAR 0 4
1104: PUSH
1105: FOR_IN
1106: IFFALSE 1139
// if not i in fac_list then
1108: LD_VAR 0 7
1112: PUSH
1113: LD_VAR 0 16
1117: IN
1118: NOT
1119: IFFALSE 1137
// list := list diff i ;
1121: LD_ADDR_VAR 0 4
1125: PUSH
1126: LD_VAR 0 4
1130: PUSH
1131: LD_VAR 0 7
1135: DIFF
1136: ST_TO_ADDR
1137: GO 1105
1139: POP
1140: POP
// if not list then
1141: LD_VAR 0 4
1145: NOT
1146: IFFALSE 1150
// exit ;
1148: GO 2049
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
1150: LD_VAR 0 11
1154: PUSH
1155: LD_INT 3
1157: EQUAL
1158: PUSH
1159: LD_INT 49
1161: PUSH
1162: LD_VAR 0 4
1166: IN
1167: AND
1168: PUSH
1169: LD_INT 31
1171: PPUSH
1172: LD_VAR 0 15
1176: PPUSH
1177: CALL_OW 321
1181: PUSH
1182: LD_INT 2
1184: EQUAL
1185: AND
1186: IFFALSE 1246
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
1188: LD_INT 22
1190: PUSH
1191: LD_VAR 0 15
1195: PUSH
1196: EMPTY
1197: LIST
1198: LIST
1199: PUSH
1200: LD_INT 35
1202: PUSH
1203: LD_INT 49
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: PUSH
1210: LD_INT 91
1212: PUSH
1213: LD_VAR 0 1
1217: PUSH
1218: LD_INT 10
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PPUSH
1231: CALL_OW 69
1235: NOT
1236: IFFALSE 1246
// weapon := ru_time_lapser ;
1238: LD_ADDR_VAR 0 17
1242: PUSH
1243: LD_INT 49
1245: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
1246: LD_VAR 0 11
1250: PUSH
1251: LD_INT 1
1253: PUSH
1254: LD_INT 2
1256: PUSH
1257: EMPTY
1258: LIST
1259: LIST
1260: IN
1261: PUSH
1262: LD_INT 11
1264: PUSH
1265: LD_VAR 0 4
1269: IN
1270: PUSH
1271: LD_INT 30
1273: PUSH
1274: LD_VAR 0 4
1278: IN
1279: OR
1280: AND
1281: PUSH
1282: LD_INT 6
1284: PPUSH
1285: LD_VAR 0 15
1289: PPUSH
1290: CALL_OW 321
1294: PUSH
1295: LD_INT 2
1297: EQUAL
1298: AND
1299: IFFALSE 1464
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
1301: LD_INT 22
1303: PUSH
1304: LD_VAR 0 15
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: PUSH
1313: LD_INT 2
1315: PUSH
1316: LD_INT 35
1318: PUSH
1319: LD_INT 11
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: PUSH
1326: LD_INT 35
1328: PUSH
1329: LD_INT 30
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: PUSH
1341: LD_INT 91
1343: PUSH
1344: LD_VAR 0 1
1348: PUSH
1349: LD_INT 18
1351: PUSH
1352: EMPTY
1353: LIST
1354: LIST
1355: LIST
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: LIST
1361: PPUSH
1362: CALL_OW 69
1366: NOT
1367: PUSH
1368: LD_INT 22
1370: PUSH
1371: LD_VAR 0 15
1375: PUSH
1376: EMPTY
1377: LIST
1378: LIST
1379: PUSH
1380: LD_INT 2
1382: PUSH
1383: LD_INT 30
1385: PUSH
1386: LD_INT 32
1388: PUSH
1389: EMPTY
1390: LIST
1391: LIST
1392: PUSH
1393: LD_INT 30
1395: PUSH
1396: LD_INT 33
1398: PUSH
1399: EMPTY
1400: LIST
1401: LIST
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: LIST
1407: PUSH
1408: LD_INT 91
1410: PUSH
1411: LD_VAR 0 1
1415: PUSH
1416: LD_INT 12
1418: PUSH
1419: EMPTY
1420: LIST
1421: LIST
1422: LIST
1423: PUSH
1424: EMPTY
1425: LIST
1426: LIST
1427: LIST
1428: PUSH
1429: EMPTY
1430: LIST
1431: PPUSH
1432: CALL_OW 69
1436: PUSH
1437: LD_INT 2
1439: GREATER
1440: AND
1441: IFFALSE 1464
// weapon := [ us_radar , ar_radar ] [ nat ] ;
1443: LD_ADDR_VAR 0 17
1447: PUSH
1448: LD_INT 11
1450: PUSH
1451: LD_INT 30
1453: PUSH
1454: EMPTY
1455: LIST
1456: LIST
1457: PUSH
1458: LD_VAR 0 11
1462: ARRAY
1463: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
1464: LD_VAR 0 17
1468: NOT
1469: PUSH
1470: LD_INT 40
1472: PPUSH
1473: LD_VAR 0 15
1477: PPUSH
1478: CALL_OW 321
1482: PUSH
1483: LD_INT 2
1485: EQUAL
1486: AND
1487: PUSH
1488: LD_INT 7
1490: PUSH
1491: LD_VAR 0 4
1495: IN
1496: PUSH
1497: LD_INT 28
1499: PUSH
1500: LD_VAR 0 4
1504: IN
1505: OR
1506: PUSH
1507: LD_INT 45
1509: PUSH
1510: LD_VAR 0 4
1514: IN
1515: OR
1516: AND
1517: IFFALSE 1771
// begin hex := GetHexInfo ( x , y ) ;
1519: LD_ADDR_VAR 0 3
1523: PUSH
1524: LD_VAR 0 9
1528: PPUSH
1529: LD_VAR 0 10
1533: PPUSH
1534: CALL_OW 546
1538: ST_TO_ADDR
// if hex [ 1 ] then
1539: LD_VAR 0 3
1543: PUSH
1544: LD_INT 1
1546: ARRAY
1547: IFFALSE 1551
// exit ;
1549: GO 2049
// height := hex [ 2 ] ;
1551: LD_ADDR_VAR 0 14
1555: PUSH
1556: LD_VAR 0 3
1560: PUSH
1561: LD_INT 2
1563: ARRAY
1564: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
1565: LD_ADDR_VAR 0 13
1569: PUSH
1570: LD_INT 0
1572: PUSH
1573: LD_INT 2
1575: PUSH
1576: LD_INT 3
1578: PUSH
1579: LD_INT 5
1581: PUSH
1582: EMPTY
1583: LIST
1584: LIST
1585: LIST
1586: LIST
1587: ST_TO_ADDR
// for i in tmp do
1588: LD_ADDR_VAR 0 7
1592: PUSH
1593: LD_VAR 0 13
1597: PUSH
1598: FOR_IN
1599: IFFALSE 1769
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
1601: LD_ADDR_VAR 0 8
1605: PUSH
1606: LD_VAR 0 9
1610: PPUSH
1611: LD_VAR 0 7
1615: PPUSH
1616: LD_INT 5
1618: PPUSH
1619: CALL_OW 272
1623: PUSH
1624: LD_VAR 0 10
1628: PPUSH
1629: LD_VAR 0 7
1633: PPUSH
1634: LD_INT 5
1636: PPUSH
1637: CALL_OW 273
1641: PUSH
1642: EMPTY
1643: LIST
1644: LIST
1645: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
1646: LD_VAR 0 8
1650: PUSH
1651: LD_INT 1
1653: ARRAY
1654: PPUSH
1655: LD_VAR 0 8
1659: PUSH
1660: LD_INT 2
1662: ARRAY
1663: PPUSH
1664: CALL_OW 488
1668: IFFALSE 1767
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
1670: LD_ADDR_VAR 0 3
1674: PUSH
1675: LD_VAR 0 8
1679: PUSH
1680: LD_INT 1
1682: ARRAY
1683: PPUSH
1684: LD_VAR 0 8
1688: PUSH
1689: LD_INT 2
1691: ARRAY
1692: PPUSH
1693: CALL_OW 546
1697: ST_TO_ADDR
// if hex [ 1 ] then
1698: LD_VAR 0 3
1702: PUSH
1703: LD_INT 1
1705: ARRAY
1706: IFFALSE 1710
// continue ;
1708: GO 1598
// h := hex [ 2 ] ;
1710: LD_ADDR_VAR 0 12
1714: PUSH
1715: LD_VAR 0 3
1719: PUSH
1720: LD_INT 2
1722: ARRAY
1723: ST_TO_ADDR
// if h + 7 < height then
1724: LD_VAR 0 12
1728: PUSH
1729: LD_INT 7
1731: PLUS
1732: PUSH
1733: LD_VAR 0 14
1737: LESS
1738: IFFALSE 1767
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
1740: LD_ADDR_VAR 0 17
1744: PUSH
1745: LD_INT 7
1747: PUSH
1748: LD_INT 28
1750: PUSH
1751: LD_INT 45
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: LD_VAR 0 11
1763: ARRAY
1764: ST_TO_ADDR
// break ;
1765: GO 1769
// end ; end ; end ;
1767: GO 1598
1769: POP
1770: POP
// end ; if not weapon then
1771: LD_VAR 0 17
1775: NOT
1776: IFFALSE 1931
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
1778: LD_ADDR_VAR 0 4
1782: PUSH
1783: LD_VAR 0 4
1787: PUSH
1788: LD_INT 11
1790: PUSH
1791: LD_INT 30
1793: PUSH
1794: LD_INT 49
1796: PUSH
1797: EMPTY
1798: LIST
1799: LIST
1800: LIST
1801: DIFF
1802: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , tower , 6 ] , [ f_not , [ f_bweapon , 0 ] ] ] ) ;
1803: LD_ADDR_VAR 0 13
1807: PUSH
1808: LD_INT 22
1810: PUSH
1811: LD_VAR 0 15
1815: PUSH
1816: EMPTY
1817: LIST
1818: LIST
1819: PUSH
1820: LD_INT 91
1822: PUSH
1823: LD_VAR 0 1
1827: PUSH
1828: LD_INT 6
1830: PUSH
1831: EMPTY
1832: LIST
1833: LIST
1834: LIST
1835: PUSH
1836: LD_INT 3
1838: PUSH
1839: LD_INT 35
1841: PUSH
1842: LD_INT 0
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: PUSH
1853: EMPTY
1854: LIST
1855: LIST
1856: LIST
1857: PPUSH
1858: CALL_OW 69
1862: ST_TO_ADDR
// for i in tmp do
1863: LD_ADDR_VAR 0 7
1867: PUSH
1868: LD_VAR 0 13
1872: PUSH
1873: FOR_IN
1874: IFFALSE 1899
// list := list diff GetBWeapon ( i ) ;
1876: LD_ADDR_VAR 0 4
1880: PUSH
1881: LD_VAR 0 4
1885: PUSH
1886: LD_VAR 0 7
1890: PPUSH
1891: CALL_OW 269
1895: DIFF
1896: ST_TO_ADDR
1897: GO 1873
1899: POP
1900: POP
// if list then
1901: LD_VAR 0 4
1905: IFFALSE 1931
// weapon := list [ rand ( 1 , list ) ] ;
1907: LD_ADDR_VAR 0 17
1911: PUSH
1912: LD_VAR 0 4
1916: PUSH
1917: LD_INT 1
1919: PPUSH
1920: LD_VAR 0 4
1924: PPUSH
1925: CALL_OW 12
1929: ARRAY
1930: ST_TO_ADDR
// end ; if weapon then
1931: LD_VAR 0 17
1935: IFFALSE 2049
// begin tmp := CostOfWeapon ( weapon ) ;
1937: LD_ADDR_VAR 0 13
1941: PUSH
1942: LD_VAR 0 17
1946: PPUSH
1947: CALL_OW 451
1951: ST_TO_ADDR
// j := GetBase ( tower ) ;
1952: LD_ADDR_VAR 0 8
1956: PUSH
1957: LD_VAR 0 1
1961: PPUSH
1962: CALL_OW 274
1966: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
1967: LD_VAR 0 8
1971: PPUSH
1972: LD_INT 1
1974: PPUSH
1975: CALL_OW 275
1979: PUSH
1980: LD_VAR 0 13
1984: PUSH
1985: LD_INT 1
1987: ARRAY
1988: GREATEREQUAL
1989: PUSH
1990: LD_VAR 0 8
1994: PPUSH
1995: LD_INT 2
1997: PPUSH
1998: CALL_OW 275
2002: PUSH
2003: LD_VAR 0 13
2007: PUSH
2008: LD_INT 2
2010: ARRAY
2011: GREATEREQUAL
2012: AND
2013: PUSH
2014: LD_VAR 0 8
2018: PPUSH
2019: LD_INT 3
2021: PPUSH
2022: CALL_OW 275
2026: PUSH
2027: LD_VAR 0 13
2031: PUSH
2032: LD_INT 3
2034: ARRAY
2035: GREATEREQUAL
2036: AND
2037: IFFALSE 2049
// result := weapon ;
2039: LD_ADDR_VAR 0 2
2043: PUSH
2044: LD_VAR 0 17
2048: ST_TO_ADDR
// end ; end ;
2049: LD_VAR 0 2
2053: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
2054: LD_INT 0
2056: PPUSH
2057: PPUSH
2058: PPUSH
2059: PPUSH
2060: PPUSH
// if not un or not IsOk ( un ) then
2061: LD_VAR 0 1
2065: NOT
2066: PUSH
2067: LD_VAR 0 1
2071: PPUSH
2072: CALL_OW 302
2076: NOT
2077: OR
2078: IFFALSE 2082
// exit ;
2080: GO 2522
// side := GetSide ( un ) ;
2082: LD_ADDR_VAR 0 9
2086: PUSH
2087: LD_VAR 0 1
2091: PPUSH
2092: CALL_OW 255
2096: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
2097: LD_ADDR_VAR 0 7
2101: PUSH
2102: LD_INT 22
2104: PUSH
2105: LD_VAR 0 9
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: PUSH
2114: LD_INT 30
2116: PUSH
2117: LD_INT 32
2119: PUSH
2120: EMPTY
2121: LIST
2122: LIST
2123: PUSH
2124: LD_INT 50
2126: PUSH
2127: EMPTY
2128: LIST
2129: PUSH
2130: LD_INT 58
2132: PUSH
2133: EMPTY
2134: LIST
2135: PUSH
2136: EMPTY
2137: LIST
2138: LIST
2139: LIST
2140: LIST
2141: PPUSH
2142: CALL_OW 69
2146: PUSH
2147: LD_VAR 0 2
2151: DIFF
2152: ST_TO_ADDR
// if not filter then
2153: LD_VAR 0 7
2157: NOT
2158: IFFALSE 2387
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
2160: LD_ADDR_VAR 0 7
2164: PUSH
2165: LD_INT 22
2167: PUSH
2168: LD_VAR 0 9
2172: PUSH
2173: EMPTY
2174: LIST
2175: LIST
2176: PUSH
2177: LD_INT 30
2179: PUSH
2180: LD_INT 5
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: EMPTY
2188: LIST
2189: LIST
2190: PPUSH
2191: CALL_OW 69
2195: ST_TO_ADDR
// if debug then
2196: LD_EXP 1
2200: IFFALSE 2219
// display_strings := [ filter , 1 ] ;
2202: LD_ADDR_OWVAR 47
2206: PUSH
2207: LD_VAR 0 7
2211: PUSH
2212: LD_STRING 1
2214: PUSH
2215: EMPTY
2216: LIST
2217: LIST
2218: ST_TO_ADDR
// if not filter then
2219: LD_VAR 0 7
2223: NOT
2224: IFFALSE 2247
// begin ComMoveXY ( un , x , y ) ;
2226: LD_VAR 0 1
2230: PPUSH
2231: LD_VAR 0 3
2235: PPUSH
2236: LD_VAR 0 4
2240: PPUSH
2241: CALL_OW 111
// exit ;
2245: GO 2522
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
2247: LD_ADDR_VAR 0 8
2251: PUSH
2252: LD_VAR 0 7
2256: PPUSH
2257: LD_VAR 0 1
2261: PPUSH
2262: CALL_OW 74
2266: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
2267: LD_VAR 0 8
2271: PPUSH
2272: CALL_OW 313
2276: PUSH
2277: LD_INT 6
2279: EQUAL
2280: IFFALSE 2300
// filter := filter diff t else
2282: LD_ADDR_VAR 0 7
2286: PUSH
2287: LD_VAR 0 7
2291: PUSH
2292: LD_VAR 0 8
2296: DIFF
2297: ST_TO_ADDR
2298: GO 2302
// break ;
2300: GO 2324
// until UnitsInside ( t ) < 6 or not filter ;
2302: LD_VAR 0 8
2306: PPUSH
2307: CALL_OW 313
2311: PUSH
2312: LD_INT 6
2314: LESS
2315: PUSH
2316: LD_VAR 0 7
2320: NOT
2321: OR
2322: IFFALSE 2247
// display_strings := [ filter , t ] ;
2324: LD_ADDR_OWVAR 47
2328: PUSH
2329: LD_VAR 0 7
2333: PUSH
2334: LD_VAR 0 8
2338: PUSH
2339: EMPTY
2340: LIST
2341: LIST
2342: ST_TO_ADDR
// if not filter then
2343: LD_VAR 0 7
2347: NOT
2348: IFFALSE 2371
// ComMoveXY ( un , x , y ) else
2350: LD_VAR 0 1
2354: PPUSH
2355: LD_VAR 0 3
2359: PPUSH
2360: LD_VAR 0 4
2364: PPUSH
2365: CALL_OW 111
2369: GO 2385
// ComEnterUnit ( un , t ) ;
2371: LD_VAR 0 1
2375: PPUSH
2376: LD_VAR 0 8
2380: PPUSH
2381: CALL_OW 120
// end else
2385: GO 2522
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
2387: LD_ADDR_VAR 0 8
2391: PUSH
2392: LD_VAR 0 7
2396: PPUSH
2397: LD_VAR 0 1
2401: PPUSH
2402: CALL_OW 74
2406: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
2407: LD_VAR 0 8
2411: PPUSH
2412: CALL_OW 110
2416: PUSH
2417: LD_INT 7
2419: EQUAL
2420: IFFALSE 2438
// filter := filter diff t ;
2422: LD_ADDR_VAR 0 7
2426: PUSH
2427: LD_VAR 0 7
2431: PUSH
2432: LD_VAR 0 8
2436: DIFF
2437: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
2438: LD_VAR 0 8
2442: PPUSH
2443: CALL_OW 110
2447: PUSH
2448: LD_INT 7
2450: NONEQUAL
2451: PUSH
2452: LD_VAR 0 7
2456: NOT
2457: OR
2458: IFFALSE 2387
// if GetTag ( t ) <> 7 then
2460: LD_VAR 0 8
2464: PPUSH
2465: CALL_OW 110
2469: PUSH
2470: LD_INT 7
2472: NONEQUAL
2473: IFFALSE 2503
// begin SetTag ( t , 7 ) ;
2475: LD_VAR 0 8
2479: PPUSH
2480: LD_INT 7
2482: PPUSH
2483: CALL_OW 109
// ComEnterUnit ( un , t ) ;
2487: LD_VAR 0 1
2491: PPUSH
2492: LD_VAR 0 8
2496: PPUSH
2497: CALL_OW 120
// end else
2501: GO 2522
// ComMoveXY ( un , x , y ) ;
2503: LD_VAR 0 1
2507: PPUSH
2508: LD_VAR 0 3
2512: PPUSH
2513: LD_VAR 0 4
2517: PPUSH
2518: CALL_OW 111
// end ; end ;
2522: LD_VAR 0 5
2526: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
2527: LD_INT 0
2529: PPUSH
2530: PPUSH
2531: PPUSH
// if not base then
2532: LD_VAR 0 1
2536: NOT
2537: IFFALSE 2541
// exit ;
2539: GO 2599
// tmp := GetEnergy ( GetBase ( base ) ) ;
2541: LD_ADDR_VAR 0 4
2545: PUSH
2546: LD_VAR 0 1
2550: PPUSH
2551: CALL_OW 274
2555: PPUSH
2556: CALL_OW 278
2560: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
2561: LD_VAR 0 4
2565: PUSH
2566: LD_INT 1
2568: ARRAY
2569: PUSH
2570: LD_VAR 0 4
2574: PUSH
2575: LD_INT 4
2577: ARRAY
2578: GREATER
2579: IFFALSE 2591
// result := true else
2581: LD_ADDR_VAR 0 2
2585: PUSH
2586: LD_INT 1
2588: ST_TO_ADDR
2589: GO 2599
// result := false ;
2591: LD_ADDR_VAR 0 2
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// end ;
2599: LD_VAR 0 2
2603: RET
// export function FilterPeople ( side ) ; begin
2604: LD_INT 0
2606: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
2607: LD_ADDR_VAR 0 2
2611: PUSH
2612: LD_INT 22
2614: PUSH
2615: LD_VAR 0 1
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: PUSH
2624: LD_INT 21
2626: PUSH
2627: LD_INT 1
2629: PUSH
2630: EMPTY
2631: LIST
2632: LIST
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PPUSH
2638: CALL_OW 69
2642: ST_TO_ADDR
// end ;
2643: LD_VAR 0 2
2647: RET
// export function FilterDrivers ( side ) ; begin
2648: LD_INT 0
2650: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
2651: LD_ADDR_VAR 0 2
2655: PUSH
2656: LD_INT 22
2658: PUSH
2659: LD_VAR 0 1
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: PUSH
2668: LD_INT 3
2670: PUSH
2671: LD_INT 56
2673: PUSH
2674: EMPTY
2675: LIST
2676: PUSH
2677: EMPTY
2678: LIST
2679: LIST
2680: PUSH
2681: EMPTY
2682: LIST
2683: LIST
2684: PPUSH
2685: CALL_OW 69
2689: ST_TO_ADDR
// end ;
2690: LD_VAR 0 2
2694: RET
// export function FilterPeopleArea ( side , area ) ; begin
2695: LD_INT 0
2697: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
2698: LD_ADDR_VAR 0 3
2702: PUSH
2703: LD_VAR 0 2
2707: PPUSH
2708: LD_INT 22
2710: PUSH
2711: LD_INT 1
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: PUSH
2718: LD_INT 21
2720: PUSH
2721: LD_INT 1
2723: PUSH
2724: EMPTY
2725: LIST
2726: LIST
2727: PUSH
2728: EMPTY
2729: LIST
2730: LIST
2731: PPUSH
2732: CALL_OW 70
2736: ST_TO_ADDR
// end ;
2737: LD_VAR 0 3
2741: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
2742: LD_INT 0
2744: PPUSH
2745: PPUSH
2746: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
2747: LD_ADDR_VAR 0 5
2751: PUSH
2752: LD_VAR 0 2
2756: PPUSH
2757: LD_INT 22
2759: PUSH
2760: LD_INT 1
2762: PUSH
2763: EMPTY
2764: LIST
2765: LIST
2766: PUSH
2767: LD_INT 21
2769: PUSH
2770: LD_INT 2
2772: PUSH
2773: EMPTY
2774: LIST
2775: LIST
2776: PUSH
2777: LD_INT 3
2779: PUSH
2780: LD_INT 58
2782: PUSH
2783: EMPTY
2784: LIST
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: LIST
2794: PPUSH
2795: CALL_OW 70
2799: ST_TO_ADDR
// result := [ ] ;
2800: LD_ADDR_VAR 0 3
2804: PUSH
2805: EMPTY
2806: ST_TO_ADDR
// if not tmp then
2807: LD_VAR 0 5
2811: NOT
2812: IFFALSE 2816
// exit ;
2814: GO 2868
// for i in tmp do
2816: LD_ADDR_VAR 0 4
2820: PUSH
2821: LD_VAR 0 5
2825: PUSH
2826: FOR_IN
2827: IFFALSE 2852
// result := result ^ IsDrivenBy ( i ) ;
2829: LD_ADDR_VAR 0 3
2833: PUSH
2834: LD_VAR 0 3
2838: PUSH
2839: LD_VAR 0 4
2843: PPUSH
2844: CALL_OW 311
2848: ADD
2849: ST_TO_ADDR
2850: GO 2826
2852: POP
2853: POP
// result := result diff 0 ;
2854: LD_ADDR_VAR 0 3
2858: PUSH
2859: LD_VAR 0 3
2863: PUSH
2864: LD_INT 0
2866: DIFF
2867: ST_TO_ADDR
// end ;
2868: LD_VAR 0 3
2872: RET
// export function FilterBuildings ( side ) ; begin
2873: LD_INT 0
2875: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
2876: LD_ADDR_VAR 0 2
2880: PUSH
2881: LD_INT 22
2883: PUSH
2884: LD_VAR 0 1
2888: PUSH
2889: EMPTY
2890: LIST
2891: LIST
2892: PUSH
2893: LD_INT 21
2895: PUSH
2896: LD_INT 3
2898: PUSH
2899: EMPTY
2900: LIST
2901: LIST
2902: PUSH
2903: EMPTY
2904: LIST
2905: LIST
2906: PPUSH
2907: CALL_OW 69
2911: ST_TO_ADDR
// end ;
2912: LD_VAR 0 2
2916: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
2917: LD_INT 0
2919: PPUSH
2920: PPUSH
2921: PPUSH
2922: PPUSH
// uc_side = 0 ;
2923: LD_ADDR_OWVAR 20
2927: PUSH
2928: LD_INT 0
2930: ST_TO_ADDR
// uc_nation = 0 ;
2931: LD_ADDR_OWVAR 21
2935: PUSH
2936: LD_INT 0
2938: ST_TO_ADDR
// nat_area := wildArea ;
2939: LD_ADDR_VAR 0 4
2943: PUSH
2944: LD_INT 3
2946: ST_TO_ADDR
// InitHc ;
2947: CALL_OW 19
// for i = 1 to 4 do
2951: LD_ADDR_VAR 0 2
2955: PUSH
2956: DOUBLE
2957: LD_INT 1
2959: DEC
2960: ST_TO_ADDR
2961: LD_INT 4
2963: PUSH
2964: FOR_TO
2965: IFFALSE 3020
// begin hc_class = 18 ;
2967: LD_ADDR_OWVAR 28
2971: PUSH
2972: LD_INT 18
2974: ST_TO_ADDR
// hc_gallery =  ;
2975: LD_ADDR_OWVAR 33
2979: PUSH
2980: LD_STRING 
2982: ST_TO_ADDR
// hc_face_number = 1 ;
2983: LD_ADDR_OWVAR 34
2987: PUSH
2988: LD_INT 1
2990: ST_TO_ADDR
// animal := CreateHuman ;
2991: LD_ADDR_VAR 0 3
2995: PUSH
2996: CALL_OW 44
3000: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3001: LD_VAR 0 3
3005: PPUSH
3006: LD_VAR 0 4
3010: PPUSH
3011: LD_INT 0
3013: PPUSH
3014: CALL_OW 49
// end ;
3018: GO 2964
3020: POP
3021: POP
// for i = 1 to 6 do
3022: LD_ADDR_VAR 0 2
3026: PUSH
3027: DOUBLE
3028: LD_INT 1
3030: DEC
3031: ST_TO_ADDR
3032: LD_INT 6
3034: PUSH
3035: FOR_TO
3036: IFFALSE 3107
// begin hc_class = class_tiger ;
3038: LD_ADDR_OWVAR 28
3042: PUSH
3043: LD_INT 14
3045: ST_TO_ADDR
// hc_gallery =  ;
3046: LD_ADDR_OWVAR 33
3050: PUSH
3051: LD_STRING 
3053: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 10 ) ;
3054: LD_ADDR_OWVAR 35
3058: PUSH
3059: LD_INT 0
3061: PPUSH
3062: LD_INT 10
3064: PPUSH
3065: CALL_OW 12
3069: ST_TO_ADDR
// hc_face_number = 3 ;
3070: LD_ADDR_OWVAR 34
3074: PUSH
3075: LD_INT 3
3077: ST_TO_ADDR
// animal := CreateHuman ;
3078: LD_ADDR_VAR 0 3
3082: PUSH
3083: CALL_OW 44
3087: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3088: LD_VAR 0 3
3092: PPUSH
3093: LD_VAR 0 4
3097: PPUSH
3098: LD_INT 0
3100: PPUSH
3101: CALL_OW 49
// end ;
3105: GO 3035
3107: POP
3108: POP
// for i = 1 to 2 do
3109: LD_ADDR_VAR 0 2
3113: PUSH
3114: DOUBLE
3115: LD_INT 1
3117: DEC
3118: ST_TO_ADDR
3119: LD_INT 2
3121: PUSH
3122: FOR_TO
3123: IFFALSE 3186
// begin hc_class = 21 ;
3125: LD_ADDR_OWVAR 28
3129: PUSH
3130: LD_INT 21
3132: ST_TO_ADDR
// hc_gallery =  ;
3133: LD_ADDR_OWVAR 33
3137: PUSH
3138: LD_STRING 
3140: ST_TO_ADDR
// hc_agressivity = 0 ;
3141: LD_ADDR_OWVAR 35
3145: PUSH
3146: LD_INT 0
3148: ST_TO_ADDR
// hc_face_number = 5 ;
3149: LD_ADDR_OWVAR 34
3153: PUSH
3154: LD_INT 5
3156: ST_TO_ADDR
// animal := CreateHuman ;
3157: LD_ADDR_VAR 0 3
3161: PUSH
3162: CALL_OW 44
3166: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3167: LD_VAR 0 3
3171: PPUSH
3172: LD_VAR 0 4
3176: PPUSH
3177: LD_INT 0
3179: PPUSH
3180: CALL_OW 49
// end ;
3184: GO 3122
3186: POP
3187: POP
// for i = 1 to 6 do
3188: LD_ADDR_VAR 0 2
3192: PUSH
3193: DOUBLE
3194: LD_INT 1
3196: DEC
3197: ST_TO_ADDR
3198: LD_INT 6
3200: PUSH
3201: FOR_TO
3202: IFFALSE 3257
// begin hc_class = 13 ;
3204: LD_ADDR_OWVAR 28
3208: PUSH
3209: LD_INT 13
3211: ST_TO_ADDR
// hc_gallery =  ;
3212: LD_ADDR_OWVAR 33
3216: PUSH
3217: LD_STRING 
3219: ST_TO_ADDR
// hc_face_number = 4 ;
3220: LD_ADDR_OWVAR 34
3224: PUSH
3225: LD_INT 4
3227: ST_TO_ADDR
// animal := CreateHuman ;
3228: LD_ADDR_VAR 0 3
3232: PUSH
3233: CALL_OW 44
3237: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3238: LD_VAR 0 3
3242: PPUSH
3243: LD_VAR 0 4
3247: PPUSH
3248: LD_INT 0
3250: PPUSH
3251: CALL_OW 49
// end ;
3255: GO 3201
3257: POP
3258: POP
// for i = 1 to 2 do
3259: LD_ADDR_VAR 0 2
3263: PUSH
3264: DOUBLE
3265: LD_INT 1
3267: DEC
3268: ST_TO_ADDR
3269: LD_INT 2
3271: PUSH
3272: FOR_TO
3273: IFFALSE 3332
// begin hc_class = 20 ;
3275: LD_ADDR_OWVAR 28
3279: PUSH
3280: LD_INT 20
3282: ST_TO_ADDR
// hc_gallery =  ;
3283: LD_ADDR_OWVAR 33
3287: PUSH
3288: LD_STRING 
3290: ST_TO_ADDR
// hc_face_number = 2 ;
3291: LD_ADDR_OWVAR 34
3295: PUSH
3296: LD_INT 2
3298: ST_TO_ADDR
// animal := CreateHuman ;
3299: LD_ADDR_VAR 0 3
3303: PUSH
3304: CALL_OW 44
3308: ST_TO_ADDR
// PlaceUnitXYR ( animal , 101 , 37 , 3 , false ) ;
3309: LD_VAR 0 3
3313: PPUSH
3314: LD_INT 101
3316: PPUSH
3317: LD_INT 37
3319: PPUSH
3320: LD_INT 3
3322: PPUSH
3323: LD_INT 0
3325: PPUSH
3326: CALL_OW 50
// end ;
3330: GO 3272
3332: POP
3333: POP
// for i = 1 to 1 do
3334: LD_ADDR_VAR 0 2
3338: PUSH
3339: DOUBLE
3340: LD_INT 1
3342: DEC
3343: ST_TO_ADDR
3344: LD_INT 1
3346: PUSH
3347: FOR_TO
3348: IFFALSE 3395
// begin vc_chassis := 31 ;
3350: LD_ADDR_OWVAR 37
3354: PUSH
3355: LD_INT 31
3357: ST_TO_ADDR
// vc_control := control_rider ;
3358: LD_ADDR_OWVAR 38
3362: PUSH
3363: LD_INT 4
3365: ST_TO_ADDR
// animal := CreateVehicle ;
3366: LD_ADDR_VAR 0 3
3370: PUSH
3371: CALL_OW 45
3375: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3376: LD_VAR 0 3
3380: PPUSH
3381: LD_VAR 0 4
3385: PPUSH
3386: LD_INT 0
3388: PPUSH
3389: CALL_OW 49
// end ;
3393: GO 3347
3395: POP
3396: POP
// end ; end_of_file
3397: LD_VAR 0 1
3401: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
3402: LD_INT 0
3404: PPUSH
3405: PPUSH
3406: PPUSH
3407: PPUSH
3408: PPUSH
3409: PPUSH
// uc_side := 1 ;
3410: LD_ADDR_OWVAR 20
3414: PUSH
3415: LD_INT 1
3417: ST_TO_ADDR
// uc_nation := 1 ;
3418: LD_ADDR_OWVAR 21
3422: PUSH
3423: LD_INT 1
3425: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
3426: LD_ADDR_EXP 8
3430: PUSH
3431: LD_STRING JMM
3433: PPUSH
3434: LD_EXP 1
3438: NOT
3439: PPUSH
3440: CALL 354 0 2
3444: ST_TO_ADDR
// team := [ JMM ] ;
3445: LD_ADDR_VAR 0 3
3449: PUSH
3450: LD_EXP 8
3454: PUSH
3455: EMPTY
3456: LIST
3457: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
3458: LD_STRING BrownIn07
3460: PPUSH
3461: LD_EXP 1
3465: PPUSH
3466: CALL_OW 30
3470: IFFALSE 3491
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
3472: LD_ADDR_EXP 9
3476: PUSH
3477: LD_STRING Brown
3479: PPUSH
3480: LD_EXP 1
3484: NOT
3485: PPUSH
3486: CALL 354 0 2
3490: ST_TO_ADDR
// if Brown then
3491: LD_EXP 9
3495: IFFALSE 3513
// team := team ^ Brown ;
3497: LD_ADDR_VAR 0 3
3501: PUSH
3502: LD_VAR 0 3
3506: PUSH
3507: LD_EXP 9
3511: ADD
3512: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
3513: LD_STRING DonaldsonIn07
3515: PPUSH
3516: LD_EXP 1
3520: PPUSH
3521: CALL_OW 30
3525: IFFALSE 3546
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
3527: LD_ADDR_EXP 10
3531: PUSH
3532: LD_STRING Donaldson
3534: PPUSH
3535: LD_EXP 1
3539: NOT
3540: PPUSH
3541: CALL 354 0 2
3545: ST_TO_ADDR
// if Donaldson then
3546: LD_EXP 10
3550: IFFALSE 3568
// team := team ^ Donaldson ;
3552: LD_ADDR_VAR 0 3
3556: PUSH
3557: LD_VAR 0 3
3561: PUSH
3562: LD_EXP 10
3566: ADD
3567: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
3568: LD_STRING BobbyIn07
3570: PPUSH
3571: LD_EXP 1
3575: PPUSH
3576: CALL_OW 30
3580: IFFALSE 3601
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
3582: LD_ADDR_EXP 11
3586: PUSH
3587: LD_STRING Bobby
3589: PPUSH
3590: LD_EXP 1
3594: NOT
3595: PPUSH
3596: CALL 354 0 2
3600: ST_TO_ADDR
// if Bobby then
3601: LD_EXP 11
3605: IFFALSE 3623
// team := team ^ Bobby ;
3607: LD_ADDR_VAR 0 3
3611: PUSH
3612: LD_VAR 0 3
3616: PUSH
3617: LD_EXP 11
3621: ADD
3622: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
3623: LD_STRING CyrusIn07
3625: PPUSH
3626: LD_EXP 1
3630: PPUSH
3631: CALL_OW 30
3635: IFFALSE 3656
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
3637: LD_ADDR_EXP 12
3641: PUSH
3642: LD_STRING Cyrus
3644: PPUSH
3645: LD_EXP 1
3649: NOT
3650: PPUSH
3651: CALL 354 0 2
3655: ST_TO_ADDR
// if Cyrus then
3656: LD_EXP 12
3660: IFFALSE 3678
// team := team ^ Cyrus ;
3662: LD_ADDR_VAR 0 3
3666: PUSH
3667: LD_VAR 0 3
3671: PUSH
3672: LD_EXP 12
3676: ADD
3677: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
3678: LD_STRING LisaIn07
3680: PPUSH
3681: LD_EXP 1
3685: PPUSH
3686: CALL_OW 30
3690: IFFALSE 3711
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
3692: LD_ADDR_EXP 13
3696: PUSH
3697: LD_STRING Lisa
3699: PPUSH
3700: LD_EXP 1
3704: NOT
3705: PPUSH
3706: CALL 354 0 2
3710: ST_TO_ADDR
// if Lisa then
3711: LD_EXP 13
3715: IFFALSE 3733
// team := team ^ Lisa ;
3717: LD_ADDR_VAR 0 3
3721: PUSH
3722: LD_VAR 0 3
3726: PUSH
3727: LD_EXP 13
3731: ADD
3732: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
3733: LD_STRING GladstoneIn07
3735: PPUSH
3736: LD_EXP 1
3740: PPUSH
3741: CALL_OW 30
3745: IFFALSE 3766
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
3747: LD_ADDR_EXP 15
3751: PUSH
3752: LD_STRING Gladstone
3754: PPUSH
3755: LD_EXP 1
3759: NOT
3760: PPUSH
3761: CALL 354 0 2
3765: ST_TO_ADDR
// if Gladstone then
3766: LD_EXP 15
3770: IFFALSE 3788
// team := team ^ Gladstone ;
3772: LD_ADDR_VAR 0 3
3776: PUSH
3777: LD_VAR 0 3
3781: PUSH
3782: LD_EXP 15
3786: ADD
3787: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
3788: LD_STRING KhatamIn07
3790: PPUSH
3791: LD_EXP 1
3795: PPUSH
3796: CALL_OW 30
3800: IFFALSE 3821
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
3802: LD_ADDR_EXP 16
3806: PUSH
3807: LD_STRING Khatam
3809: PPUSH
3810: LD_EXP 1
3814: NOT
3815: PPUSH
3816: CALL 354 0 2
3820: ST_TO_ADDR
// if Khatam then
3821: LD_EXP 16
3825: IFFALSE 3843
// team := team ^ Khatam ;
3827: LD_ADDR_VAR 0 3
3831: PUSH
3832: LD_VAR 0 3
3836: PUSH
3837: LD_EXP 16
3841: ADD
3842: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
3843: LD_ADDR_VAR 0 4
3847: PUSH
3848: LD_STRING 07_others
3850: PPUSH
3851: CALL_OW 31
3855: ST_TO_ADDR
// if others then
3856: LD_VAR 0 4
3860: IFFALSE 3878
// team := team ^ others ;
3862: LD_ADDR_VAR 0 3
3866: PUSH
3867: LD_VAR 0 3
3871: PUSH
3872: LD_VAR 0 4
3876: ADD
3877: ST_TO_ADDR
// if debug then
3878: LD_EXP 1
3882: IFFALSE 3956
// begin InitHc ;
3884: CALL_OW 19
// for i = 1 to 4 do
3888: LD_ADDR_VAR 0 2
3892: PUSH
3893: DOUBLE
3894: LD_INT 1
3896: DEC
3897: ST_TO_ADDR
3898: LD_INT 4
3900: PUSH
3901: FOR_TO
3902: IFFALSE 3954
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
3904: LD_INT 0
3906: PPUSH
3907: LD_INT 1
3909: PUSH
3910: LD_INT 3
3912: PUSH
3913: EMPTY
3914: LIST
3915: LIST
3916: PUSH
3917: LD_INT 1
3919: PPUSH
3920: LD_INT 2
3922: PPUSH
3923: CALL_OW 12
3927: ARRAY
3928: PPUSH
3929: LD_INT 4
3931: PPUSH
3932: CALL_OW 380
// team := team ^ CreateHuman ;
3936: LD_ADDR_VAR 0 3
3940: PUSH
3941: LD_VAR 0 3
3945: PUSH
3946: CALL_OW 44
3950: ADD
3951: ST_TO_ADDR
// end ;
3952: GO 3901
3954: POP
3955: POP
// end ; m := 0 ;
3956: LD_ADDR_VAR 0 6
3960: PUSH
3961: LD_INT 0
3963: ST_TO_ADDR
// for i in team do
3964: LD_ADDR_VAR 0 2
3968: PUSH
3969: LD_VAR 0 3
3973: PUSH
3974: FOR_IN
3975: IFFALSE 4155
// if GetClass ( i ) = 3 then
3977: LD_VAR 0 2
3981: PPUSH
3982: CALL_OW 257
3986: PUSH
3987: LD_INT 3
3989: EQUAL
3990: IFFALSE 4138
// begin m := m + 1 ;
3992: LD_ADDR_VAR 0 6
3996: PUSH
3997: LD_VAR 0 6
4001: PUSH
4002: LD_INT 1
4004: PLUS
4005: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
4006: LD_ADDR_VAR 0 5
4010: PUSH
4011: LD_INT 1
4013: PPUSH
4014: LD_INT 1
4016: PPUSH
4017: LD_INT 2
4019: PUSH
4020: LD_INT 3
4022: PUSH
4023: LD_INT 2
4025: PUSH
4026: LD_INT 1
4028: PUSH
4029: EMPTY
4030: LIST
4031: LIST
4032: LIST
4033: LIST
4034: PUSH
4035: LD_VAR 0 6
4039: PUSH
4040: LD_INT 4
4042: MOD
4043: PUSH
4044: LD_INT 1
4046: PLUS
4047: ARRAY
4048: PPUSH
4049: LD_INT 2
4051: PPUSH
4052: LD_INT 1
4054: PPUSH
4055: LD_INT 4
4057: PUSH
4058: LD_INT 5
4060: PUSH
4061: LD_INT 3
4063: PUSH
4064: LD_INT 11
4066: PUSH
4067: EMPTY
4068: LIST
4069: LIST
4070: LIST
4071: LIST
4072: PUSH
4073: LD_VAR 0 6
4077: PUSH
4078: LD_INT 4
4080: MOD
4081: PUSH
4082: LD_INT 1
4084: PLUS
4085: ARRAY
4086: PPUSH
4087: LD_INT 60
4089: PPUSH
4090: CALL 417 0 7
4094: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
4095: LD_VAR 0 5
4099: PPUSH
4100: LD_INT 2
4102: PPUSH
4103: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
4107: LD_VAR 0 5
4111: PPUSH
4112: LD_INT 1
4114: PPUSH
4115: LD_INT 0
4117: PPUSH
4118: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4122: LD_VAR 0 2
4126: PPUSH
4127: LD_VAR 0 5
4131: PPUSH
4132: CALL_OW 52
// end else
4136: GO 4153
// PlaceUnitArea ( i , startArea , false ) ;
4138: LD_VAR 0 2
4142: PPUSH
4143: LD_INT 1
4145: PPUSH
4146: LD_INT 0
4148: PPUSH
4149: CALL_OW 49
4153: GO 3974
4155: POP
4156: POP
// uc_side := 4 ;
4157: LD_ADDR_OWVAR 20
4161: PUSH
4162: LD_INT 4
4164: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
4165: LD_ADDR_EXP 18
4169: PUSH
4170: LD_STRING Harisson
4172: PPUSH
4173: LD_INT 0
4175: PPUSH
4176: CALL 354 0 2
4180: ST_TO_ADDR
// PrepareScout ;
4181: CALL 4190 0 0
// end ;
4185: LD_VAR 0 1
4189: RET
// function PrepareScout ; var ape ; begin
4190: LD_INT 0
4192: PPUSH
4193: PPUSH
// uc_side := 4 ;
4194: LD_ADDR_OWVAR 20
4198: PUSH
4199: LD_INT 4
4201: ST_TO_ADDR
// uc_nation := 1 ;
4202: LD_ADDR_OWVAR 21
4206: PUSH
4207: LD_INT 1
4209: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
4210: LD_STRING FrankIn06
4212: PPUSH
4213: LD_INT 0
4215: PPUSH
4216: CALL_OW 30
4220: IFFALSE 4237
// Frank := CreateCharacter ( 06c_Frank ) else
4222: LD_ADDR_EXP 14
4226: PUSH
4227: LD_STRING 06c_Frank
4229: PPUSH
4230: CALL_OW 34
4234: ST_TO_ADDR
4235: GO 4277
// if LoadVariable ( FrankInDelta , 0 ) then
4237: LD_STRING FrankInDelta
4239: PPUSH
4240: LD_INT 0
4242: PPUSH
4243: CALL_OW 30
4247: IFFALSE 4264
// Frank := CreateCharacter ( 05_Frank ) else
4249: LD_ADDR_EXP 14
4253: PUSH
4254: LD_STRING 05_Frank
4256: PPUSH
4257: CALL_OW 34
4261: ST_TO_ADDR
4262: GO 4277
// Frank := CreateCharacter ( 04_Frank ) ;
4264: LD_ADDR_EXP 14
4268: PUSH
4269: LD_STRING 04_Frank
4271: PPUSH
4272: CALL_OW 34
4276: ST_TO_ADDR
// if Frank then
4277: LD_EXP 14
4281: IFFALSE 4414
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
4283: LD_EXP 14
4287: PPUSH
4288: LD_INT 2
4290: PPUSH
4291: LD_INT 0
4293: PPUSH
4294: CALL_OW 49
// SetClass ( Frank , 1 ) ;
4298: LD_EXP 14
4302: PPUSH
4303: LD_INT 1
4305: PPUSH
4306: CALL_OW 336
// uc_side := 0 ;
4310: LD_ADDR_OWVAR 20
4314: PUSH
4315: LD_INT 0
4317: ST_TO_ADDR
// uc_nation := 0 ;
4318: LD_ADDR_OWVAR 21
4322: PUSH
4323: LD_INT 0
4325: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
4326: LD_INT 0
4328: PPUSH
4329: LD_INT 12
4331: PPUSH
4332: LD_INT 0
4334: PPUSH
4335: CALL_OW 380
// ape := CreateHuman ;
4339: LD_ADDR_VAR 0 2
4343: PUSH
4344: CALL_OW 44
4348: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
4349: LD_VAR 0 2
4353: PPUSH
4354: LD_EXP 14
4358: PPUSH
4359: CALL_OW 250
4363: PPUSH
4364: LD_EXP 14
4368: PPUSH
4369: CALL_OW 251
4373: PPUSH
4374: LD_INT 5
4376: PPUSH
4377: LD_INT 0
4379: PPUSH
4380: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
4384: LD_VAR 0 2
4388: PPUSH
4389: LD_EXP 14
4393: PPUSH
4394: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
4398: LD_EXP 14
4402: PPUSH
4403: LD_VAR 0 2
4407: PPUSH
4408: CALL_OW 119
// exit ;
4412: GO 4454
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
4414: LD_ADDR_EXP 17
4418: PUSH
4419: LD_STRING Yamoko
4421: PPUSH
4422: LD_INT 0
4424: PPUSH
4425: CALL 354 0 2
4429: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
4430: LD_EXP 17
4434: PPUSH
4435: LD_INT 2
4437: PPUSH
4438: LD_INT 0
4440: PPUSH
4441: CALL_OW 49
// ComHold ( Kikuchi ) ;
4445: LD_EXP 17
4449: PPUSH
4450: CALL_OW 140
// end ; end_of_file
4454: LD_VAR 0 1
4458: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
4459: LD_INT 0
4461: PPUSH
4462: PPUSH
4463: PPUSH
4464: PPUSH
4465: PPUSH
4466: PPUSH
4467: PPUSH
4468: PPUSH
4469: PPUSH
4470: PPUSH
4471: PPUSH
4472: PPUSH
4473: PPUSH
4474: PPUSH
4475: PPUSH
4476: PPUSH
// ru_rebuild_list := [ ] ;
4477: LD_ADDR_EXP 19
4481: PUSH
4482: EMPTY
4483: ST_TO_ADDR
// uc_side := 3 ;
4484: LD_ADDR_OWVAR 20
4488: PUSH
4489: LD_INT 3
4491: ST_TO_ADDR
// uc_nation := 3 ;
4492: LD_ADDR_OWVAR 21
4496: PUSH
4497: LD_INT 3
4499: ST_TO_ADDR
// if Difficulty > 1 then
4500: LD_OWVAR 67
4504: PUSH
4505: LD_INT 1
4507: GREATER
4508: IFFALSE 4644
// begin bc_type := b_breastwork ;
4510: LD_ADDR_OWVAR 42
4514: PUSH
4515: LD_INT 31
4517: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
4518: LD_INT 78
4520: PPUSH
4521: LD_INT 74
4523: PPUSH
4524: LD_INT 2
4526: PPUSH
4527: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
4531: LD_INT 171
4533: PPUSH
4534: LD_INT 193
4536: PPUSH
4537: LD_INT 4
4539: PPUSH
4540: CALL_OW 47
// bc_type := b_turret ;
4544: LD_ADDR_OWVAR 42
4548: PUSH
4549: LD_INT 33
4551: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
4552: LD_INT 129
4554: PPUSH
4555: LD_INT 96
4557: PPUSH
4558: LD_INT 3
4560: PPUSH
4561: CALL_OW 47
// if Difficulty > 2 then
4565: LD_OWVAR 67
4569: PUSH
4570: LD_INT 2
4572: GREATER
4573: IFFALSE 4644
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
4575: LD_INT 83
4577: PPUSH
4578: LD_INT 141
4580: PPUSH
4581: CALL_OW 428
4585: PPUSH
4586: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
4590: LD_INT 78
4592: PPUSH
4593: LD_INT 133
4595: PPUSH
4596: CALL_OW 428
4600: PPUSH
4601: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
4605: LD_INT 83
4607: PPUSH
4608: LD_INT 141
4610: PPUSH
4611: LD_INT 2
4613: PPUSH
4614: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
4618: LD_INT 78
4620: PPUSH
4621: LD_INT 133
4623: PPUSH
4624: LD_INT 2
4626: PPUSH
4627: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
4631: LD_INT 145
4633: PPUSH
4634: LD_INT 112
4636: PPUSH
4637: LD_INT 3
4639: PPUSH
4640: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
4644: LD_ADDR_VAR 0 9
4648: PUSH
4649: LD_INT 22
4651: PUSH
4652: LD_INT 3
4654: PUSH
4655: EMPTY
4656: LIST
4657: LIST
4658: PUSH
4659: LD_INT 2
4661: PUSH
4662: LD_INT 30
4664: PUSH
4665: LD_INT 0
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: PUSH
4672: LD_INT 30
4674: PUSH
4675: LD_INT 1
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: LIST
4686: PUSH
4687: EMPTY
4688: LIST
4689: LIST
4690: PPUSH
4691: CALL_OW 69
4695: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
4696: LD_ADDR_VAR 0 10
4700: PUSH
4701: LD_INT 22
4703: PUSH
4704: LD_INT 3
4706: PUSH
4707: EMPTY
4708: LIST
4709: LIST
4710: PUSH
4711: LD_INT 2
4713: PUSH
4714: LD_INT 30
4716: PUSH
4717: LD_INT 6
4719: PUSH
4720: EMPTY
4721: LIST
4722: LIST
4723: PUSH
4724: LD_INT 30
4726: PUSH
4727: LD_INT 7
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PUSH
4734: LD_INT 30
4736: PUSH
4737: LD_INT 8
4739: PUSH
4740: EMPTY
4741: LIST
4742: LIST
4743: PUSH
4744: EMPTY
4745: LIST
4746: LIST
4747: LIST
4748: LIST
4749: PUSH
4750: EMPTY
4751: LIST
4752: LIST
4753: PPUSH
4754: CALL_OW 69
4758: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4759: LD_ADDR_VAR 0 11
4763: PUSH
4764: LD_INT 22
4766: PUSH
4767: LD_INT 3
4769: PUSH
4770: EMPTY
4771: LIST
4772: LIST
4773: PUSH
4774: LD_INT 30
4776: PUSH
4777: LD_INT 3
4779: PUSH
4780: EMPTY
4781: LIST
4782: LIST
4783: PUSH
4784: EMPTY
4785: LIST
4786: LIST
4787: PPUSH
4788: CALL_OW 69
4792: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
4793: LD_ADDR_VAR 0 12
4797: PUSH
4798: LD_INT 22
4800: PUSH
4801: LD_INT 3
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PUSH
4808: LD_INT 30
4810: PUSH
4811: LD_INT 31
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: EMPTY
4819: LIST
4820: LIST
4821: PPUSH
4822: CALL_OW 69
4826: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
4827: LD_ADDR_VAR 0 13
4831: PUSH
4832: LD_INT 22
4834: PUSH
4835: LD_INT 3
4837: PUSH
4838: EMPTY
4839: LIST
4840: LIST
4841: PUSH
4842: LD_INT 30
4844: PUSH
4845: LD_INT 32
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: PUSH
4852: EMPTY
4853: LIST
4854: LIST
4855: PPUSH
4856: CALL_OW 69
4860: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
4861: LD_ADDR_VAR 0 14
4865: PUSH
4866: LD_INT 22
4868: PUSH
4869: LD_INT 3
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: PUSH
4876: LD_INT 30
4878: PUSH
4879: LD_INT 33
4881: PUSH
4882: EMPTY
4883: LIST
4884: LIST
4885: PUSH
4886: EMPTY
4887: LIST
4888: LIST
4889: PPUSH
4890: CALL_OW 69
4894: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
4895: LD_ADDR_VAR 0 15
4899: PUSH
4900: LD_INT 42
4902: PUSH
4903: LD_INT 5
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: PUSH
4910: LD_INT 43
4912: PUSH
4913: LD_INT 50
4915: PUSH
4916: EMPTY
4917: LIST
4918: LIST
4919: PUSH
4920: LD_INT 44
4922: PUSH
4923: LD_INT 30
4925: PUSH
4926: EMPTY
4927: LIST
4928: LIST
4929: PUSH
4930: LD_INT 46
4932: PUSH
4933: LD_INT 15
4935: PUSH
4936: EMPTY
4937: LIST
4938: LIST
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: LIST
4944: LIST
4945: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 6 , 3 ] ;
4946: LD_ADDR_VAR 0 16
4950: PUSH
4951: LD_INT 0
4953: PUSH
4954: LD_INT 4
4956: PUSH
4957: LD_INT 6
4959: PUSH
4960: LD_INT 3
4962: PUSH
4963: EMPTY
4964: LIST
4965: LIST
4966: LIST
4967: LIST
4968: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
4969: LD_ADDR_VAR 0 6
4973: PUSH
4974: LD_INT 4
4976: PUSH
4977: LD_INT 5
4979: PUSH
4980: LD_INT 6
4982: PUSH
4983: EMPTY
4984: LIST
4985: LIST
4986: LIST
4987: PUSH
4988: LD_OWVAR 67
4992: ARRAY
4993: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
4994: LD_INT 16
4996: PPUSH
4997: LD_STRING am_tukh
4999: PPUSH
5000: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
5004: LD_ADDR_VAR 0 2
5008: PUSH
5009: LD_INT 21
5011: PUSH
5012: LD_INT 3
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: PPUSH
5019: CALL_OW 69
5023: PUSH
5024: FOR_IN
5025: IFFALSE 5058
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
5027: LD_VAR 0 2
5031: PPUSH
5032: LD_INT 4
5034: PUSH
5035: LD_INT 5
5037: PUSH
5038: LD_INT 6
5040: PUSH
5041: EMPTY
5042: LIST
5043: LIST
5044: LIST
5045: PUSH
5046: LD_OWVAR 67
5050: ARRAY
5051: PPUSH
5052: CALL_OW 241
5056: GO 5024
5058: POP
5059: POP
// for i in dep_list do
5060: LD_ADDR_VAR 0 2
5064: PUSH
5065: LD_VAR 0 9
5069: PUSH
5070: FOR_IN
5071: IFFALSE 5115
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
5073: LD_VAR 0 2
5077: PPUSH
5078: CALL_OW 274
5082: PPUSH
5083: LD_INT 1
5085: PPUSH
5086: LD_INT 1000
5088: PPUSH
5089: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
5093: LD_VAR 0 2
5097: PPUSH
5098: CALL_OW 274
5102: PPUSH
5103: LD_INT 2
5105: PPUSH
5106: LD_INT 1000
5108: PPUSH
5109: CALL_OW 277
// end ;
5113: GO 5070
5115: POP
5116: POP
// InitHc ;
5117: CALL_OW 19
// tmp := bunker_list * [ 50 , 70 , 85 ] [ Difficulty ] div 100 ;
5121: LD_ADDR_VAR 0 8
5125: PUSH
5126: LD_VAR 0 13
5130: PUSH
5131: LD_INT 50
5133: PUSH
5134: LD_INT 70
5136: PUSH
5137: LD_INT 85
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: LIST
5144: PUSH
5145: LD_OWVAR 67
5149: ARRAY
5150: MUL
5151: PUSH
5152: LD_INT 100
5154: DIV
5155: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
5156: LD_ADDR_VAR 0 16
5160: PUSH
5161: LD_VAR 0 16
5165: PPUSH
5166: LD_INT 1
5168: PPUSH
5169: LD_VAR 0 8
5173: PPUSH
5174: CALL_OW 1
5178: ST_TO_ADDR
// tmp := [ ] ;
5179: LD_ADDR_VAR 0 8
5183: PUSH
5184: EMPTY
5185: ST_TO_ADDR
// for i in bunker_list do
5186: LD_ADDR_VAR 0 2
5190: PUSH
5191: LD_VAR 0 13
5195: PUSH
5196: FOR_IN
5197: IFFALSE 5293
// if i mod 10 + 1 < tmp then
5199: LD_VAR 0 2
5203: PUSH
5204: LD_INT 10
5206: MOD
5207: PUSH
5208: LD_INT 1
5210: PLUS
5211: PUSH
5212: LD_VAR 0 8
5216: LESS
5217: IFFALSE 5262
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
5219: LD_ADDR_VAR 0 8
5223: PUSH
5224: LD_VAR 0 8
5228: PPUSH
5229: LD_VAR 0 2
5233: PUSH
5234: LD_INT 3
5236: PPUSH
5237: LD_INT 5
5239: PPUSH
5240: CALL_OW 12
5244: MOD
5245: PUSH
5246: LD_INT 1
5248: PLUS
5249: PPUSH
5250: LD_VAR 0 2
5254: PPUSH
5255: CALL_OW 2
5259: ST_TO_ADDR
5260: GO 5291
// tmp := Insert ( tmp , tmp + 1 , i ) ;
5262: LD_ADDR_VAR 0 8
5266: PUSH
5267: LD_VAR 0 8
5271: PPUSH
5272: LD_VAR 0 8
5276: PUSH
5277: LD_INT 1
5279: PLUS
5280: PPUSH
5281: LD_VAR 0 2
5285: PPUSH
5286: CALL_OW 2
5290: ST_TO_ADDR
5291: GO 5196
5293: POP
5294: POP
// bunker_list := tmp ;
5295: LD_ADDR_VAR 0 13
5299: PUSH
5300: LD_VAR 0 8
5304: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
5305: LD_ADDR_VAR 0 2
5309: PUSH
5310: LD_VAR 0 13
5314: PUSH
5315: LD_VAR 0 14
5319: ADD
5320: PUSH
5321: FOR_IN
5322: IFFALSE 5345
// PlaceWeaponTurret ( i , GetTurretWeapon ( i ) ) ;
5324: LD_VAR 0 2
5328: PPUSH
5329: LD_VAR 0 2
5333: PPUSH
5334: CALL 831 0 1
5338: PPUSH
5339: CALL_OW 431
5343: GO 5321
5345: POP
5346: POP
// while ( personel_counter [ 1 ] ) do
5347: LD_VAR 0 16
5351: PUSH
5352: LD_INT 1
5354: ARRAY
5355: IFFALSE 5463
// begin i := rand ( 1 , bunker_list ) ;
5357: LD_ADDR_VAR 0 2
5361: PUSH
5362: LD_INT 1
5364: PPUSH
5365: LD_VAR 0 13
5369: PPUSH
5370: CALL_OW 12
5374: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5375: LD_INT 0
5377: PPUSH
5378: LD_INT 1
5380: PPUSH
5381: LD_VAR 0 6
5385: PPUSH
5386: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
5390: CALL_OW 44
5394: PPUSH
5395: LD_VAR 0 13
5399: PUSH
5400: LD_VAR 0 2
5404: ARRAY
5405: PPUSH
5406: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
5410: LD_ADDR_VAR 0 13
5414: PUSH
5415: LD_VAR 0 13
5419: PPUSH
5420: LD_VAR 0 2
5424: PPUSH
5425: CALL_OW 3
5429: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
5430: LD_ADDR_VAR 0 16
5434: PUSH
5435: LD_VAR 0 16
5439: PPUSH
5440: LD_INT 1
5442: PPUSH
5443: LD_VAR 0 16
5447: PUSH
5448: LD_INT 1
5450: ARRAY
5451: PUSH
5452: LD_INT 1
5454: MINUS
5455: PPUSH
5456: CALL_OW 1
5460: ST_TO_ADDR
// end ;
5461: GO 5347
// for i = 1 to personel_counter [ 2 ] do
5463: LD_ADDR_VAR 0 2
5467: PUSH
5468: DOUBLE
5469: LD_INT 1
5471: DEC
5472: ST_TO_ADDR
5473: LD_VAR 0 16
5477: PUSH
5478: LD_INT 2
5480: ARRAY
5481: PUSH
5482: FOR_TO
5483: IFFALSE 5514
// begin PrepareHuman ( false , 2 , skill ) ;
5485: LD_INT 0
5487: PPUSH
5488: LD_INT 2
5490: PPUSH
5491: LD_VAR 0 6
5495: PPUSH
5496: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
5500: CALL_OW 44
5504: PPUSH
5505: LD_INT 16
5507: PPUSH
5508: CALL_OW 52
// end ;
5512: GO 5482
5514: POP
5515: POP
// for i = 1 to personel_counter [ 3 ] do
5516: LD_ADDR_VAR 0 2
5520: PUSH
5521: DOUBLE
5522: LD_INT 1
5524: DEC
5525: ST_TO_ADDR
5526: LD_VAR 0 16
5530: PUSH
5531: LD_INT 3
5533: ARRAY
5534: PUSH
5535: FOR_TO
5536: IFFALSE 5583
// begin PrepareHuman ( false , 3 , skill ) ;
5538: LD_INT 0
5540: PPUSH
5541: LD_INT 3
5543: PPUSH
5544: LD_VAR 0 6
5548: PPUSH
5549: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ i mod 2 + 1 ] ) ;
5553: CALL_OW 44
5557: PPUSH
5558: LD_VAR 0 11
5562: PUSH
5563: LD_VAR 0 2
5567: PUSH
5568: LD_INT 2
5570: MOD
5571: PUSH
5572: LD_INT 1
5574: PLUS
5575: ARRAY
5576: PPUSH
5577: CALL_OW 52
// end ;
5581: GO 5535
5583: POP
5584: POP
// for i = 1 to personel_counter [ 4 ] do
5585: LD_ADDR_VAR 0 2
5589: PUSH
5590: DOUBLE
5591: LD_INT 1
5593: DEC
5594: ST_TO_ADDR
5595: LD_VAR 0 16
5599: PUSH
5600: LD_INT 4
5602: ARRAY
5603: PUSH
5604: FOR_TO
5605: IFFALSE 5642
// begin PrepareHuman ( false , 4 , skill ) ;
5607: LD_INT 0
5609: PPUSH
5610: LD_INT 4
5612: PPUSH
5613: LD_VAR 0 6
5617: PPUSH
5618: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
5622: CALL_OW 44
5626: PPUSH
5627: LD_VAR 0 10
5631: PUSH
5632: LD_INT 1
5634: ARRAY
5635: PPUSH
5636: CALL_OW 52
// end ;
5640: GO 5604
5642: POP
5643: POP
// for i in breastworks_list do
5644: LD_ADDR_VAR 0 2
5648: PUSH
5649: LD_VAR 0 12
5653: PUSH
5654: FOR_IN
5655: IFFALSE 5767
// begin r := GetDir ( i ) ;
5657: LD_ADDR_VAR 0 4
5661: PUSH
5662: LD_VAR 0 2
5666: PPUSH
5667: CALL_OW 254
5671: ST_TO_ADDR
// if r > 3 then
5672: LD_VAR 0 4
5676: PUSH
5677: LD_INT 3
5679: GREATER
5680: IFFALSE 5698
// r := r - 3 else
5682: LD_ADDR_VAR 0 4
5686: PUSH
5687: LD_VAR 0 4
5691: PUSH
5692: LD_INT 3
5694: MINUS
5695: ST_TO_ADDR
5696: GO 5712
// r := r + 3 ;
5698: LD_ADDR_VAR 0 4
5702: PUSH
5703: LD_VAR 0 4
5707: PUSH
5708: LD_INT 3
5710: PLUS
5711: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5712: LD_INT 0
5714: PPUSH
5715: LD_INT 1
5717: PPUSH
5718: LD_VAR 0 6
5722: PPUSH
5723: CALL_OW 380
// un := CreateHuman ;
5727: LD_ADDR_VAR 0 5
5731: PUSH
5732: CALL_OW 44
5736: ST_TO_ADDR
// SetDir ( un , r ) ;
5737: LD_VAR 0 5
5741: PPUSH
5742: LD_VAR 0 4
5746: PPUSH
5747: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
5751: LD_VAR 0 5
5755: PPUSH
5756: LD_VAR 0 2
5760: PPUSH
5761: CALL_OW 52
// end ;
5765: GO 5654
5767: POP
5768: POP
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
5769: LD_ADDR_VAR 0 8
5773: PUSH
5774: LD_INT 22
5776: PUSH
5777: LD_INT 3
5779: PUSH
5780: EMPTY
5781: LIST
5782: LIST
5783: PUSH
5784: LD_INT 25
5786: PUSH
5787: LD_INT 3
5789: PUSH
5790: EMPTY
5791: LIST
5792: LIST
5793: PUSH
5794: EMPTY
5795: LIST
5796: LIST
5797: PPUSH
5798: CALL_OW 69
5802: ST_TO_ADDR
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
5803: LD_ADDR_VAR 0 4
5807: PUSH
5808: LD_INT 4
5810: PUSH
5811: LD_INT 5
5813: PUSH
5814: LD_INT 6
5816: PUSH
5817: EMPTY
5818: LIST
5819: LIST
5820: LIST
5821: PUSH
5822: LD_OWVAR 67
5826: ARRAY
5827: ST_TO_ADDR
// for i = 1 to r do
5828: LD_ADDR_VAR 0 2
5832: PUSH
5833: DOUBLE
5834: LD_INT 1
5836: DEC
5837: ST_TO_ADDR
5838: LD_VAR 0 4
5842: PUSH
5843: FOR_TO
5844: IFFALSE 6017
// begin un := PrepareTank ( 3 , 3 , [ ru_medium_tracked , ru_medium_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
5846: LD_ADDR_VAR 0 5
5850: PUSH
5851: LD_INT 3
5853: PPUSH
5854: LD_INT 3
5856: PPUSH
5857: LD_INT 22
5859: PUSH
5860: LD_INT 22
5862: PUSH
5863: LD_INT 24
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: LIST
5870: PUSH
5871: LD_VAR 0 2
5875: PUSH
5876: LD_INT 3
5878: MOD
5879: PUSH
5880: LD_INT 1
5882: PLUS
5883: ARRAY
5884: PPUSH
5885: LD_INT 1
5887: PPUSH
5888: LD_INT 1
5890: PPUSH
5891: LD_INT 43
5893: PUSH
5894: LD_INT 44
5896: PUSH
5897: LD_INT 42
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: LIST
5904: PUSH
5905: LD_VAR 0 2
5909: PUSH
5910: LD_INT 3
5912: MOD
5913: PUSH
5914: LD_INT 1
5916: PLUS
5917: ARRAY
5918: PPUSH
5919: LD_INT 100
5921: PPUSH
5922: CALL 417 0 7
5926: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
5927: LD_VAR 0 5
5931: PPUSH
5932: LD_INT 0
5934: PPUSH
5935: LD_INT 5
5937: PPUSH
5938: CALL_OW 12
5942: PPUSH
5943: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
5947: LD_VAR 0 5
5951: PPUSH
5952: LD_INT 5
5954: PPUSH
5955: LD_INT 0
5957: PPUSH
5958: CALL_OW 49
// if i > tmp - 2 then
5962: LD_VAR 0 2
5966: PUSH
5967: LD_VAR 0 8
5971: PUSH
5972: LD_INT 2
5974: MINUS
5975: GREATER
5976: IFFALSE 5980
// continue ;
5978: GO 5843
// ComExitBuilding ( tmp [ i ] ) ;
5980: LD_VAR 0 8
5984: PUSH
5985: LD_VAR 0 2
5989: ARRAY
5990: PPUSH
5991: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , un ) ;
5995: LD_VAR 0 8
5999: PUSH
6000: LD_VAR 0 2
6004: ARRAY
6005: PPUSH
6006: LD_VAR 0 5
6010: PPUSH
6011: CALL_OW 180
// end ;
6015: GO 5843
6017: POP
6018: POP
// end ;
6019: LD_VAR 0 1
6023: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_ok ] ] ) do var i , filter , tmp , engs , enemy ;
6024: LD_INT 22
6026: PUSH
6027: LD_INT 3
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: PUSH
6034: LD_INT 25
6036: PUSH
6037: LD_INT 2
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: PUSH
6044: LD_INT 50
6046: PUSH
6047: EMPTY
6048: LIST
6049: PUSH
6050: EMPTY
6051: LIST
6052: LIST
6053: LIST
6054: PPUSH
6055: CALL_OW 69
6059: IFFALSE 6755
6061: GO 6063
6063: DISABLE
6064: LD_INT 0
6066: PPUSH
6067: PPUSH
6068: PPUSH
6069: PPUSH
6070: PPUSH
// begin enable ;
6071: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
6072: LD_ADDR_VAR 0 2
6076: PUSH
6077: LD_INT 6
6079: PPUSH
6080: LD_INT 3
6082: PUSH
6083: LD_INT 24
6085: PUSH
6086: LD_INT 1000
6088: PUSH
6089: EMPTY
6090: LIST
6091: LIST
6092: PUSH
6093: EMPTY
6094: LIST
6095: LIST
6096: PUSH
6097: LD_INT 21
6099: PUSH
6100: LD_INT 3
6102: PUSH
6103: EMPTY
6104: LIST
6105: LIST
6106: PUSH
6107: EMPTY
6108: LIST
6109: LIST
6110: PPUSH
6111: CALL_OW 70
6115: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_lives , 650 ] ] ) ;
6116: LD_ADDR_VAR 0 4
6120: PUSH
6121: LD_INT 22
6123: PUSH
6124: LD_INT 3
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: PUSH
6131: LD_INT 25
6133: PUSH
6134: LD_INT 2
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: PUSH
6141: LD_INT 24
6143: PUSH
6144: LD_INT 650
6146: PUSH
6147: EMPTY
6148: LIST
6149: LIST
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: LIST
6155: PPUSH
6156: CALL_OW 69
6160: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
6161: LD_VAR 0 2
6165: NOT
6166: PUSH
6167: LD_EXP 19
6171: NOT
6172: AND
6173: IFFALSE 6205
// begin if not IsInUnit ( engs [ 1 ] ) then
6175: LD_VAR 0 4
6179: PUSH
6180: LD_INT 1
6182: ARRAY
6183: PPUSH
6184: CALL_OW 310
6188: NOT
6189: IFFALSE 6203
// ComEnterUnit ( engs , ru_dep_main ) ;
6191: LD_VAR 0 4
6195: PPUSH
6196: LD_INT 16
6198: PPUSH
6199: CALL_OW 120
// exit ;
6203: GO 6755
// end ; if debug then
6205: LD_EXP 1
6209: IFFALSE 6230
// display_strings := [ engs , filter ] ;
6211: LD_ADDR_OWVAR 47
6215: PUSH
6216: LD_VAR 0 4
6220: PUSH
6221: LD_VAR 0 2
6225: PUSH
6226: EMPTY
6227: LIST
6228: LIST
6229: ST_TO_ADDR
// if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
6230: LD_VAR 0 4
6234: PPUSH
6235: LD_INT 3
6237: PUSH
6238: LD_INT 24
6240: PUSH
6241: LD_INT 650
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: PUSH
6248: EMPTY
6249: LIST
6250: LIST
6251: PPUSH
6252: CALL_OW 72
6256: IFFALSE 6349
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
6258: LD_ADDR_VAR 0 3
6262: PUSH
6263: LD_VAR 0 4
6267: PPUSH
6268: LD_INT 3
6270: PUSH
6271: LD_INT 24
6273: PUSH
6274: LD_INT 650
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: PPUSH
6285: CALL_OW 72
6289: ST_TO_ADDR
// for i in tmp do
6290: LD_ADDR_VAR 0 1
6294: PUSH
6295: LD_VAR 0 3
6299: PUSH
6300: FOR_IN
6301: IFFALSE 6347
// if not IsInArea ( i , mainBaseArea ) then
6303: LD_VAR 0 1
6307: PPUSH
6308: LD_INT 14
6310: PPUSH
6311: CALL_OW 308
6315: NOT
6316: IFFALSE 6345
// begin ComMoveXY ( i , 129 , 125 ) ;
6318: LD_VAR 0 1
6322: PPUSH
6323: LD_INT 129
6325: PPUSH
6326: LD_INT 125
6328: PPUSH
6329: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
6333: LD_VAR 0 1
6337: PPUSH
6338: LD_INT 1050
6340: PPUSH
6341: CALL_OW 202
// end ;
6345: GO 6300
6347: POP
6348: POP
// end ; if filter then
6349: LD_VAR 0 2
6353: IFFALSE 6612
// begin for i in engs do
6355: LD_ADDR_VAR 0 1
6359: PUSH
6360: LD_VAR 0 4
6364: PUSH
6365: FOR_IN
6366: IFFALSE 6390
// if IsInUnit ( i ) then
6368: LD_VAR 0 1
6372: PPUSH
6373: CALL_OW 310
6377: IFFALSE 6388
// ComExitBuilding ( i ) ;
6379: LD_VAR 0 1
6383: PPUSH
6384: CALL_OW 122
6388: GO 6365
6390: POP
6391: POP
// wait ( 3 ) ;
6392: LD_INT 3
6394: PPUSH
6395: CALL_OW 67
// if filter >= 2 and engs >= 2 then
6399: LD_VAR 0 2
6403: PUSH
6404: LD_INT 2
6406: GREATEREQUAL
6407: PUSH
6408: LD_VAR 0 4
6412: PUSH
6413: LD_INT 2
6415: GREATEREQUAL
6416: AND
6417: IFFALSE 6565
// begin for i = 1 to engs / 2 do
6419: LD_ADDR_VAR 0 1
6423: PUSH
6424: DOUBLE
6425: LD_INT 1
6427: DEC
6428: ST_TO_ADDR
6429: LD_VAR 0 4
6433: PUSH
6434: LD_INT 2
6436: DIVREAL
6437: PUSH
6438: FOR_TO
6439: IFFALSE 6485
// if not HasTask ( engs [ i ] ) then
6441: LD_VAR 0 4
6445: PUSH
6446: LD_VAR 0 1
6450: ARRAY
6451: PPUSH
6452: CALL_OW 314
6456: NOT
6457: IFFALSE 6483
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
6459: LD_VAR 0 4
6463: PUSH
6464: LD_VAR 0 1
6468: ARRAY
6469: PPUSH
6470: LD_VAR 0 2
6474: PUSH
6475: LD_INT 1
6477: ARRAY
6478: PPUSH
6479: CALL_OW 130
6483: GO 6438
6485: POP
6486: POP
// for i = engs / 2 + 1 to engs do
6487: LD_ADDR_VAR 0 1
6491: PUSH
6492: DOUBLE
6493: LD_VAR 0 4
6497: PUSH
6498: LD_INT 2
6500: DIVREAL
6501: PUSH
6502: LD_INT 1
6504: PLUS
6505: DEC
6506: ST_TO_ADDR
6507: LD_VAR 0 4
6511: PUSH
6512: FOR_TO
6513: IFFALSE 6561
// if not HasTask ( engs [ i ] ) then
6515: LD_VAR 0 4
6519: PUSH
6520: LD_VAR 0 1
6524: ARRAY
6525: PPUSH
6526: CALL_OW 314
6530: NOT
6531: IFFALSE 6559
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
6533: LD_VAR 0 4
6537: PUSH
6538: LD_VAR 0 1
6542: ARRAY
6543: PPUSH
6544: LD_VAR 0 2
6548: PUSH
6549: LD_VAR 0 2
6553: ARRAY
6554: PPUSH
6555: CALL_OW 130
6559: GO 6512
6561: POP
6562: POP
// end else
6563: GO 6612
// for i in engs do
6565: LD_ADDR_VAR 0 1
6569: PUSH
6570: LD_VAR 0 4
6574: PUSH
6575: FOR_IN
6576: IFFALSE 6610
// if not HasTask ( i ) then
6578: LD_VAR 0 1
6582: PPUSH
6583: CALL_OW 314
6587: NOT
6588: IFFALSE 6608
// ComRepairBuilding ( i , filter [ 1 ] ) ;
6590: LD_VAR 0 1
6594: PPUSH
6595: LD_VAR 0 2
6599: PUSH
6600: LD_INT 1
6602: ARRAY
6603: PPUSH
6604: CALL_OW 130
6608: GO 6575
6610: POP
6611: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
6612: LD_ADDR_VAR 0 5
6616: PUSH
6617: LD_INT 81
6619: PUSH
6620: LD_INT 3
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: PPUSH
6627: CALL_OW 69
6631: ST_TO_ADDR
// if ru_rebuild_list and not filter then
6632: LD_EXP 19
6636: PUSH
6637: LD_VAR 0 2
6641: NOT
6642: AND
6643: IFFALSE 6755
// begin ComExitBuilding ( engs ) ;
6645: LD_VAR 0 4
6649: PPUSH
6650: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
6654: LD_VAR 0 5
6658: PPUSH
6659: LD_EXP 19
6663: PUSH
6664: LD_INT 2
6666: ARRAY
6667: PPUSH
6668: LD_EXP 19
6672: PUSH
6673: LD_INT 3
6675: ARRAY
6676: PPUSH
6677: CALL_OW 73
6681: PPUSH
6682: LD_EXP 19
6686: PUSH
6687: LD_INT 2
6689: ARRAY
6690: PPUSH
6691: LD_EXP 19
6695: PUSH
6696: LD_INT 3
6698: ARRAY
6699: PPUSH
6700: CALL_OW 297
6704: PUSH
6705: LD_INT 10
6707: GREATER
6708: IFFALSE 6755
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
6710: LD_VAR 0 4
6714: PPUSH
6715: LD_EXP 19
6719: PUSH
6720: LD_INT 1
6722: ARRAY
6723: PPUSH
6724: LD_EXP 19
6728: PUSH
6729: LD_INT 2
6731: ARRAY
6732: PPUSH
6733: LD_EXP 19
6737: PUSH
6738: LD_INT 3
6740: ARRAY
6741: PPUSH
6742: LD_EXP 19
6746: PUSH
6747: LD_INT 4
6749: ARRAY
6750: PPUSH
6751: CALL_OW 145
// end ; end ;
6755: PPOPN 5
6757: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 650 do var tmp ;
6758: LD_INT 16
6760: PPUSH
6761: CALL_OW 256
6765: PUSH
6766: LD_INT 650
6768: LESS
6769: IFFALSE 6852
6771: GO 6773
6773: DISABLE
6774: LD_INT 0
6776: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
6777: LD_ADDR_VAR 0 1
6781: PUSH
6782: LD_INT 22
6784: PUSH
6785: LD_INT 3
6787: PUSH
6788: EMPTY
6789: LIST
6790: LIST
6791: PUSH
6792: LD_INT 25
6794: PUSH
6795: LD_INT 1
6797: PUSH
6798: EMPTY
6799: LIST
6800: LIST
6801: PUSH
6802: EMPTY
6803: LIST
6804: LIST
6805: PPUSH
6806: CALL_OW 69
6810: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
6811: LD_VAR 0 1
6815: PPUSH
6816: CALL_OW 122
// wait ( 3 ) ;
6820: LD_INT 3
6822: PPUSH
6823: CALL_OW 67
// ComAgressiveMove ( tmp , GetX ( ru_dep_main ) , GetY ( ru_dep_main ) ) ;
6827: LD_VAR 0 1
6831: PPUSH
6832: LD_INT 16
6834: PPUSH
6835: CALL_OW 250
6839: PPUSH
6840: LD_INT 16
6842: PPUSH
6843: CALL_OW 251
6847: PPUSH
6848: CALL_OW 114
// end ;
6852: PPOPN 1
6854: END
// every 0 0$01 trigger GetLives ( ru_dep_main ) > 650 and FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] ] ] ) do var i , tmp ;
6855: LD_INT 16
6857: PPUSH
6858: CALL_OW 256
6862: PUSH
6863: LD_INT 650
6865: GREATER
6866: PUSH
6867: LD_INT 22
6869: PUSH
6870: LD_INT 3
6872: PUSH
6873: EMPTY
6874: LIST
6875: LIST
6876: PUSH
6877: LD_INT 25
6879: PUSH
6880: LD_INT 1
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: PUSH
6887: LD_INT 56
6889: PUSH
6890: EMPTY
6891: LIST
6892: PUSH
6893: EMPTY
6894: LIST
6895: LIST
6896: LIST
6897: PUSH
6898: EMPTY
6899: LIST
6900: PPUSH
6901: CALL_OW 69
6905: AND
6906: IFFALSE 7018
6908: GO 6910
6910: DISABLE
6911: LD_INT 0
6913: PPUSH
6914: PPUSH
// begin enable ;
6915: ENABLE
// tmp := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] , [ f_not , [ f_hastask ] ] ] ] ) ;
6916: LD_ADDR_VAR 0 2
6920: PUSH
6921: LD_INT 22
6923: PUSH
6924: LD_INT 3
6926: PUSH
6927: EMPTY
6928: LIST
6929: LIST
6930: PUSH
6931: LD_INT 25
6933: PUSH
6934: LD_INT 1
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: PUSH
6941: LD_INT 56
6943: PUSH
6944: EMPTY
6945: LIST
6946: PUSH
6947: LD_INT 3
6949: PUSH
6950: LD_INT 60
6952: PUSH
6953: EMPTY
6954: LIST
6955: PUSH
6956: EMPTY
6957: LIST
6958: LIST
6959: PUSH
6960: EMPTY
6961: LIST
6962: LIST
6963: LIST
6964: LIST
6965: PUSH
6966: EMPTY
6967: LIST
6968: PPUSH
6969: CALL_OW 69
6973: ST_TO_ADDR
// if not tmp then
6974: LD_VAR 0 2
6978: NOT
6979: IFFALSE 6983
// exit ;
6981: GO 7018
// for i in tmp do
6983: LD_ADDR_VAR 0 1
6987: PUSH
6988: LD_VAR 0 2
6992: PUSH
6993: FOR_IN
6994: IFFALSE 7016
// GoToAnotherTower ( i , 0 , 143 , 143 ) ;
6996: LD_VAR 0 1
7000: PPUSH
7001: LD_INT 0
7003: PPUSH
7004: LD_INT 143
7006: PPUSH
7007: LD_INT 143
7009: PPUSH
7010: CALL 2054 0 4
7014: GO 6993
7016: POP
7017: POP
// end ;
7018: PPOPN 2
7020: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
7021: LD_INT 22
7023: PUSH
7024: LD_INT 3
7026: PUSH
7027: EMPTY
7028: LIST
7029: LIST
7030: PUSH
7031: LD_INT 25
7033: PUSH
7034: LD_INT 4
7036: PUSH
7037: EMPTY
7038: LIST
7039: LIST
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PPUSH
7045: CALL_OW 69
7049: IFFALSE 7303
7051: GO 7053
7053: DISABLE
7054: LD_INT 0
7056: PPUSH
7057: PPUSH
7058: PPUSH
// begin enable ;
7059: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7060: LD_ADDR_VAR 0 2
7064: PUSH
7065: LD_INT 14
7067: PPUSH
7068: LD_INT 22
7070: PUSH
7071: LD_INT 3
7073: PUSH
7074: EMPTY
7075: LIST
7076: LIST
7077: PUSH
7078: LD_INT 21
7080: PUSH
7081: LD_INT 1
7083: PUSH
7084: EMPTY
7085: LIST
7086: LIST
7087: PUSH
7088: LD_INT 3
7090: PUSH
7091: LD_INT 24
7093: PUSH
7094: LD_INT 1000
7096: PUSH
7097: EMPTY
7098: LIST
7099: LIST
7100: PUSH
7101: EMPTY
7102: LIST
7103: LIST
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: LIST
7109: PPUSH
7110: CALL_OW 70
7114: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
7115: LD_ADDR_VAR 0 3
7119: PUSH
7120: LD_INT 22
7122: PUSH
7123: LD_INT 3
7125: PUSH
7126: EMPTY
7127: LIST
7128: LIST
7129: PUSH
7130: LD_INT 25
7132: PUSH
7133: LD_INT 4
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: PUSH
7140: EMPTY
7141: LIST
7142: LIST
7143: PPUSH
7144: CALL_OW 69
7148: ST_TO_ADDR
// if not doc then
7149: LD_VAR 0 3
7153: NOT
7154: IFFALSE 7158
// exit ;
7156: GO 7303
// if not tmp then
7158: LD_VAR 0 2
7162: NOT
7163: IFFALSE 7254
// begin if not IsInUnit ( doc [ 1 ] ) then
7165: LD_VAR 0 3
7169: PUSH
7170: LD_INT 1
7172: ARRAY
7173: PPUSH
7174: CALL_OW 310
7178: NOT
7179: IFFALSE 7252
// ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
7181: LD_VAR 0 3
7185: PPUSH
7186: LD_INT 22
7188: PUSH
7189: LD_INT 3
7191: PUSH
7192: EMPTY
7193: LIST
7194: LIST
7195: PUSH
7196: LD_INT 2
7198: PUSH
7199: LD_INT 30
7201: PUSH
7202: LD_INT 6
7204: PUSH
7205: EMPTY
7206: LIST
7207: LIST
7208: PUSH
7209: LD_INT 30
7211: PUSH
7212: LD_INT 7
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 30
7221: PUSH
7222: LD_INT 8
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: LIST
7233: LIST
7234: PUSH
7235: EMPTY
7236: LIST
7237: LIST
7238: PPUSH
7239: CALL_OW 69
7243: PUSH
7244: LD_INT 1
7246: ARRAY
7247: PPUSH
7248: CALL_OW 120
// exit ;
7252: GO 7303
// end ; if IsInUnit ( doc [ 1 ] ) then
7254: LD_VAR 0 3
7258: PUSH
7259: LD_INT 1
7261: ARRAY
7262: PPUSH
7263: CALL_OW 310
7267: IFFALSE 7278
// ComExitBuilding ( doc ) ;
7269: LD_VAR 0 3
7273: PPUSH
7274: CALL_OW 122
// wait ( 3 ) ;
7278: LD_INT 3
7280: PPUSH
7281: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
7285: LD_VAR 0 3
7289: PPUSH
7290: LD_VAR 0 2
7294: PUSH
7295: LD_INT 1
7297: ARRAY
7298: PPUSH
7299: CALL_OW 128
// end ;
7303: PPOPN 3
7305: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , tmp , attacking , areas , area ;
7306: LD_INT 22
7308: PUSH
7309: LD_INT 3
7311: PUSH
7312: EMPTY
7313: LIST
7314: LIST
7315: PUSH
7316: LD_INT 25
7318: PUSH
7319: LD_INT 3
7321: PUSH
7322: EMPTY
7323: LIST
7324: LIST
7325: PUSH
7326: EMPTY
7327: LIST
7328: LIST
7329: PPUSH
7330: CALL_OW 69
7334: PUSH
7335: LD_INT 22
7337: PUSH
7338: LD_INT 3
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PUSH
7345: LD_INT 21
7347: PUSH
7348: LD_INT 2
7350: PUSH
7351: EMPTY
7352: LIST
7353: LIST
7354: PUSH
7355: EMPTY
7356: LIST
7357: LIST
7358: PPUSH
7359: CALL_OW 69
7363: AND
7364: IFFALSE 7778
7366: GO 7368
7368: DISABLE
7369: LD_INT 0
7371: PPUSH
7372: PPUSH
7373: PPUSH
7374: PPUSH
7375: PPUSH
// begin enable ;
7376: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
7377: LD_ADDR_VAR 0 2
7381: PUSH
7382: LD_INT 22
7384: PUSH
7385: LD_INT 3
7387: PUSH
7388: EMPTY
7389: LIST
7390: LIST
7391: PUSH
7392: LD_INT 21
7394: PUSH
7395: LD_INT 2
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: PUSH
7402: LD_INT 3
7404: PUSH
7405: LD_INT 58
7407: PUSH
7408: EMPTY
7409: LIST
7410: PUSH
7411: EMPTY
7412: LIST
7413: LIST
7414: PUSH
7415: EMPTY
7416: LIST
7417: LIST
7418: LIST
7419: PPUSH
7420: CALL_OW 69
7424: ST_TO_ADDR
// areas := [ sectorAlpha , sectorBeta , sectorDelta , mainBaseArea ] ;
7425: LD_ADDR_VAR 0 4
7429: PUSH
7430: LD_INT 10
7432: PUSH
7433: LD_INT 11
7435: PUSH
7436: LD_INT 12
7438: PUSH
7439: LD_INT 14
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: LIST
7447: ST_TO_ADDR
// area := 0 ;
7448: LD_ADDR_VAR 0 5
7452: PUSH
7453: LD_INT 0
7455: ST_TO_ADDR
// attacking := false ;
7456: LD_ADDR_VAR 0 3
7460: PUSH
7461: LD_INT 0
7463: ST_TO_ADDR
// for i in tmp do
7464: LD_ADDR_VAR 0 1
7468: PUSH
7469: LD_VAR 0 2
7473: PUSH
7474: FOR_IN
7475: IFFALSE 7561
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
7477: LD_VAR 0 1
7481: PPUSH
7482: LD_INT 22
7484: PUSH
7485: LD_INT 1
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: PPUSH
7492: CALL_OW 69
7496: PPUSH
7497: LD_VAR 0 1
7501: PPUSH
7502: CALL_OW 74
7506: PPUSH
7507: CALL_OW 296
7511: PUSH
7512: LD_INT 10
7514: LESS
7515: IFFALSE 7559
// begin ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7517: LD_VAR 0 1
7521: PPUSH
7522: LD_INT 22
7524: PUSH
7525: LD_INT 1
7527: PUSH
7528: EMPTY
7529: LIST
7530: LIST
7531: PPUSH
7532: CALL_OW 69
7536: PPUSH
7537: LD_VAR 0 1
7541: PPUSH
7542: CALL_OW 74
7546: PPUSH
7547: CALL_OW 115
// attacking := true ;
7551: LD_ADDR_VAR 0 3
7555: PUSH
7556: LD_INT 1
7558: ST_TO_ADDR
// end ;
7559: GO 7474
7561: POP
7562: POP
// if attacking then
7563: LD_VAR 0 3
7567: IFFALSE 7571
// exit ;
7569: GO 7778
// for i in areas do
7571: LD_ADDR_VAR 0 1
7575: PUSH
7576: LD_VAR 0 4
7580: PUSH
7581: FOR_IN
7582: IFFALSE 7619
// if FilterUnitsInArea ( i , [ f_side , 1 ] ) then
7584: LD_VAR 0 1
7588: PPUSH
7589: LD_INT 22
7591: PUSH
7592: LD_INT 1
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PPUSH
7599: CALL_OW 70
7603: IFFALSE 7617
// begin area := i ;
7605: LD_ADDR_VAR 0 5
7609: PUSH
7610: LD_VAR 0 1
7614: ST_TO_ADDR
// break ;
7615: GO 7619
// end ;
7617: GO 7581
7619: POP
7620: POP
// if area then
7621: LD_VAR 0 5
7625: IFFALSE 7778
// begin for i in tmp do
7627: LD_ADDR_VAR 0 1
7631: PUSH
7632: LD_VAR 0 2
7636: PUSH
7637: FOR_IN
7638: IFFALSE 7776
// begin if GetFuel ( i ) < 33 then
7640: LD_VAR 0 1
7644: PPUSH
7645: CALL_OW 261
7649: PUSH
7650: LD_INT 33
7652: LESS
7653: IFFALSE 7667
// SetFuel ( i , 33 ) ;
7655: LD_VAR 0 1
7659: PPUSH
7660: LD_INT 33
7662: PPUSH
7663: CALL_OW 240
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
7667: LD_VAR 0 1
7671: PPUSH
7672: LD_INT 22
7674: PUSH
7675: LD_INT 1
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PPUSH
7682: CALL_OW 69
7686: PPUSH
7687: LD_VAR 0 1
7691: PPUSH
7692: CALL_OW 74
7696: PPUSH
7697: CALL_OW 296
7701: PUSH
7702: LD_INT 10
7704: LESS
7705: IFFALSE 7743
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7707: LD_VAR 0 1
7711: PPUSH
7712: LD_INT 22
7714: PUSH
7715: LD_INT 1
7717: PUSH
7718: EMPTY
7719: LIST
7720: LIST
7721: PPUSH
7722: CALL_OW 69
7726: PPUSH
7727: LD_VAR 0 1
7731: PPUSH
7732: CALL_OW 74
7736: PPUSH
7737: CALL_OW 115
7741: GO 7774
// if not IsInArea ( i , area ) then
7743: LD_VAR 0 1
7747: PPUSH
7748: LD_VAR 0 5
7752: PPUSH
7753: CALL_OW 308
7757: NOT
7758: IFFALSE 7774
// ComMoveToArea ( i , area ) ;
7760: LD_VAR 0 1
7764: PPUSH
7765: LD_VAR 0 5
7769: PPUSH
7770: CALL_OW 113
// end ;
7774: GO 7637
7776: POP
7777: POP
// end ; end ;
7778: PPOPN 5
7780: END
// every 10 10$00 do var i , j , un , veh , time , count ;
7781: GO 7783
7783: DISABLE
7784: LD_INT 0
7786: PPUSH
7787: PPUSH
7788: PPUSH
7789: PPUSH
7790: PPUSH
7791: PPUSH
// begin uc_side := 3 ;
7792: LD_ADDR_OWVAR 20
7796: PUSH
7797: LD_INT 3
7799: ST_TO_ADDR
// uc_nation := 3 ;
7800: LD_ADDR_OWVAR 21
7804: PUSH
7805: LD_INT 3
7807: ST_TO_ADDR
// time := [ 6 6$00 , 5 5$00 , 4 4$00 ] [ Difficulty ] ;
7808: LD_ADDR_VAR 0 5
7812: PUSH
7813: LD_INT 12600
7815: PUSH
7816: LD_INT 10500
7818: PUSH
7819: LD_INT 8400
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: LIST
7826: PUSH
7827: LD_OWVAR 67
7831: ARRAY
7832: ST_TO_ADDR
// count := [ 3 , 4 , 5 ] [ Difficulty ] ;
7833: LD_ADDR_VAR 0 6
7837: PUSH
7838: LD_INT 3
7840: PUSH
7841: LD_INT 4
7843: PUSH
7844: LD_INT 5
7846: PUSH
7847: EMPTY
7848: LIST
7849: LIST
7850: LIST
7851: PUSH
7852: LD_OWVAR 67
7856: ARRAY
7857: ST_TO_ADDR
// for i = 1 to count do
7858: LD_ADDR_VAR 0 1
7862: PUSH
7863: DOUBLE
7864: LD_INT 1
7866: DEC
7867: ST_TO_ADDR
7868: LD_VAR 0 6
7872: PUSH
7873: FOR_TO
7874: IFFALSE 8169
// begin wait ( time ) ;
7876: LD_VAR 0 5
7880: PPUSH
7881: CALL_OW 67
// for j = 1 to rand ( 1 , Difficulty ) do
7885: LD_ADDR_VAR 0 2
7889: PUSH
7890: DOUBLE
7891: LD_INT 1
7893: DEC
7894: ST_TO_ADDR
7895: LD_INT 1
7897: PPUSH
7898: LD_OWVAR 67
7902: PPUSH
7903: CALL_OW 12
7907: PUSH
7908: FOR_TO
7909: IFFALSE 8050
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 80 ) ;
7911: LD_ADDR_VAR 0 4
7915: PUSH
7916: LD_INT 3
7918: PPUSH
7919: LD_INT 3
7921: PPUSH
7922: LD_INT 22
7924: PPUSH
7925: LD_INT 1
7927: PPUSH
7928: LD_INT 1
7930: PPUSH
7931: LD_INT 43
7933: PUSH
7934: LD_INT 44
7936: PUSH
7937: LD_INT 42
7939: PUSH
7940: EMPTY
7941: LIST
7942: LIST
7943: LIST
7944: PUSH
7945: LD_VAR 0 1
7949: PUSH
7950: LD_INT 3
7952: MOD
7953: PUSH
7954: LD_INT 1
7956: PLUS
7957: ARRAY
7958: PPUSH
7959: LD_INT 80
7961: PPUSH
7962: CALL 417 0 7
7966: ST_TO_ADDR
// PlaceUnitArea ( veh , southArea , false ) ;
7967: LD_VAR 0 4
7971: PPUSH
7972: LD_INT 13
7974: PPUSH
7975: LD_INT 0
7977: PPUSH
7978: CALL_OW 49
// PrepareHuman ( false , 3 , [ 4 , 5 , 5 ] [ Difficulty ] ) ;
7982: LD_INT 0
7984: PPUSH
7985: LD_INT 3
7987: PPUSH
7988: LD_INT 4
7990: PUSH
7991: LD_INT 5
7993: PUSH
7994: LD_INT 5
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: LIST
8001: PUSH
8002: LD_OWVAR 67
8006: ARRAY
8007: PPUSH
8008: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
8012: CALL_OW 44
8016: PPUSH
8017: LD_VAR 0 4
8021: PPUSH
8022: CALL_OW 52
// wait ( 0 0$01 ) ;
8026: LD_INT 35
8028: PPUSH
8029: CALL_OW 67
// ComMoveXY ( veh , 143 , 143 ) ;
8033: LD_VAR 0 4
8037: PPUSH
8038: LD_INT 143
8040: PPUSH
8041: LD_INT 143
8043: PPUSH
8044: CALL_OW 111
// end ;
8048: GO 7908
8050: POP
8051: POP
// if count < 3 then
8052: LD_VAR 0 6
8056: PUSH
8057: LD_INT 3
8059: LESS
8060: IFFALSE 8064
// continue ;
8062: GO 7873
// for j = 1 to 1 + Difficulty do
8064: LD_ADDR_VAR 0 2
8068: PUSH
8069: DOUBLE
8070: LD_INT 1
8072: DEC
8073: ST_TO_ADDR
8074: LD_INT 1
8076: PUSH
8077: LD_OWVAR 67
8081: PLUS
8082: PUSH
8083: FOR_TO
8084: IFFALSE 8165
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
8086: LD_INT 0
8088: PPUSH
8089: LD_INT 1
8091: PPUSH
8092: LD_INT 4
8094: PUSH
8095: LD_INT 5
8097: PUSH
8098: LD_INT 6
8100: PUSH
8101: EMPTY
8102: LIST
8103: LIST
8104: LIST
8105: PUSH
8106: LD_OWVAR 67
8110: ARRAY
8111: PPUSH
8112: CALL_OW 380
// un := CreateHuman ;
8116: LD_ADDR_VAR 0 3
8120: PUSH
8121: CALL_OW 44
8125: ST_TO_ADDR
// PlaceUnitArea ( un , southArea , false ) ;
8126: LD_VAR 0 3
8130: PPUSH
8131: LD_INT 13
8133: PPUSH
8134: LD_INT 0
8136: PPUSH
8137: CALL_OW 49
// ComMoveXY ( un , 143 , 143 ) ;
8141: LD_VAR 0 3
8145: PPUSH
8146: LD_INT 143
8148: PPUSH
8149: LD_INT 143
8151: PPUSH
8152: CALL_OW 111
// wait ( 0 0$01 ) ;
8156: LD_INT 35
8158: PPUSH
8159: CALL_OW 67
// end ;
8163: GO 8083
8165: POP
8166: POP
// end ;
8167: GO 7873
8169: POP
8170: POP
// end ;
8171: PPOPN 6
8173: END
// every 8 8$00 do var i , un , time ;
8174: GO 8176
8176: DISABLE
8177: LD_INT 0
8179: PPUSH
8180: PPUSH
8181: PPUSH
// begin time := [ 2 2$00 , 1 1$00 , 0 0$30 ] ;
8182: LD_ADDR_VAR 0 3
8186: PUSH
8187: LD_INT 4200
8189: PUSH
8190: LD_INT 2100
8192: PUSH
8193: LD_INT 1050
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: LIST
8200: ST_TO_ADDR
// wait ( time ) ;
8201: LD_VAR 0 3
8205: PPUSH
8206: CALL_OW 67
// uc_side := 3 ;
8210: LD_ADDR_OWVAR 20
8214: PUSH
8215: LD_INT 3
8217: ST_TO_ADDR
// uc_nation := 3 ;
8218: LD_ADDR_OWVAR 21
8222: PUSH
8223: LD_INT 3
8225: ST_TO_ADDR
// for i = 1 to 2 do
8226: LD_ADDR_VAR 0 1
8230: PUSH
8231: DOUBLE
8232: LD_INT 1
8234: DEC
8235: ST_TO_ADDR
8236: LD_INT 2
8238: PUSH
8239: FOR_TO
8240: IFFALSE 8303
// begin PrepareHuman ( false , 1 , 4 ) ;
8242: LD_INT 0
8244: PPUSH
8245: LD_INT 1
8247: PPUSH
8248: LD_INT 4
8250: PPUSH
8251: CALL_OW 380
// un := CreateHuman ;
8255: LD_ADDR_VAR 0 2
8259: PUSH
8260: CALL_OW 44
8264: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_dep_main ) ;
8265: LD_VAR 0 2
8269: PPUSH
8270: LD_INT 16
8272: PPUSH
8273: CALL_OW 52
// ComExitBuilding ( un ) ;
8277: LD_VAR 0 2
8281: PPUSH
8282: CALL_OW 122
// AddComAgressiveMove ( un , 41 , 76 ) ;
8286: LD_VAR 0 2
8290: PPUSH
8291: LD_INT 41
8293: PPUSH
8294: LD_INT 76
8296: PPUSH
8297: CALL_OW 174
// end ;
8301: GO 8239
8303: POP
8304: POP
// end ; end_of_file
8305: PPOPN 3
8307: END
// export function Action ; begin
8308: LD_INT 0
8310: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
8311: LD_INT 28
8313: PPUSH
8314: LD_INT 3
8316: PPUSH
8317: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
8321: LD_INT 41
8323: PPUSH
8324: LD_INT 76
8326: PPUSH
8327: LD_INT 1
8329: PPUSH
8330: LD_INT 10
8332: PPUSH
8333: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
8337: LD_INT 41
8339: PPUSH
8340: LD_INT 76
8342: PPUSH
8343: LD_INT 1
8345: PPUSH
8346: CALL_OW 331
// InGameOn ;
8350: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
8354: LD_EXP 18
8358: PPUSH
8359: LD_STRING D2-Har-1
8361: PPUSH
8362: CALL_OW 94
// InGameOff ;
8366: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
8370: LD_STRING M1
8372: PPUSH
8373: CALL_OW 337
// end ;
8377: LD_VAR 0 1
8381: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
8382: LD_EXP 4
8386: PUSH
8387: LD_INT 1
8389: GREATER
8390: IFFALSE 8481
8392: GO 8394
8394: DISABLE
8395: LD_INT 0
8397: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
8398: LD_ADDR_VAR 0 1
8402: PUSH
8403: LD_INT 1
8405: PPUSH
8406: CALL 505 0 1
8410: PUSH
8411: LD_INT 1
8413: ARRAY
8414: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
8415: LD_VAR 0 1
8419: PPUSH
8420: LD_STRING D2a-Sol1-1
8422: PPUSH
8423: CALL_OW 88
// if not un then
8427: LD_VAR 0 1
8431: NOT
8432: IFFALSE 8463
// begin un := GetRandom ( sex_female ) [ 1 ] ;
8434: LD_ADDR_VAR 0 1
8438: PUSH
8439: LD_INT 2
8441: PPUSH
8442: CALL 505 0 1
8446: PUSH
8447: LD_INT 1
8449: ARRAY
8450: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
8451: LD_VAR 0 1
8455: PPUSH
8456: LD_STRING D2a-FSol1-1
8458: PPUSH
8459: CALL_OW 88
// end ; if Khatam then
8463: LD_EXP 16
8467: IFFALSE 8481
// Say ( Khatam , D3b-Khat-3 ) ;
8469: LD_EXP 16
8473: PPUSH
8474: LD_STRING D3b-Khat-3
8476: PPUSH
8477: CALL_OW 88
// end ;
8481: PPOPN 1
8483: END
// every 0 0$1 trigger Frank and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Frank ) , GetY ( Frank ) , 7 ] ] ) and not InBattle ( 1 ) do var i , ape ;
8484: LD_EXP 14
8488: PUSH
8489: LD_INT 22
8491: PUSH
8492: LD_INT 1
8494: PUSH
8495: EMPTY
8496: LIST
8497: LIST
8498: PUSH
8499: LD_INT 92
8501: PUSH
8502: LD_EXP 14
8506: PPUSH
8507: CALL_OW 250
8511: PUSH
8512: LD_EXP 14
8516: PPUSH
8517: CALL_OW 251
8521: PUSH
8522: LD_INT 7
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: PUSH
8531: EMPTY
8532: LIST
8533: LIST
8534: PPUSH
8535: CALL_OW 69
8539: AND
8540: PUSH
8541: LD_INT 1
8543: PPUSH
8544: CALL_OW 463
8548: NOT
8549: AND
8550: IFFALSE 9137
8552: GO 8554
8554: DISABLE
8555: LD_INT 0
8557: PPUSH
8558: PPUSH
// begin InGameOn ;
8559: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
8563: LD_ADDR_VAR 0 2
8567: PUSH
8568: LD_INT 22
8570: PUSH
8571: LD_INT 0
8573: PUSH
8574: EMPTY
8575: LIST
8576: LIST
8577: PUSH
8578: LD_INT 25
8580: PUSH
8581: LD_INT 12
8583: PUSH
8584: EMPTY
8585: LIST
8586: LIST
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: PPUSH
8592: CALL_OW 69
8596: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
8597: LD_ADDR_VAR 0 2
8601: PUSH
8602: LD_VAR 0 2
8606: PPUSH
8607: LD_EXP 14
8611: PPUSH
8612: CALL_OW 74
8616: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
8617: LD_ADDR_VAR 0 1
8621: PUSH
8622: LD_INT 22
8624: PUSH
8625: LD_INT 1
8627: PUSH
8628: EMPTY
8629: LIST
8630: LIST
8631: PUSH
8632: LD_INT 21
8634: PUSH
8635: LD_INT 1
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: PUSH
8642: LD_INT 91
8644: PUSH
8645: LD_EXP 14
8649: PUSH
8650: LD_INT 20
8652: PUSH
8653: EMPTY
8654: LIST
8655: LIST
8656: LIST
8657: PUSH
8658: EMPTY
8659: LIST
8660: LIST
8661: LIST
8662: PPUSH
8663: CALL_OW 69
8667: PUSH
8668: FOR_IN
8669: IFFALSE 8687
// ComTurnUnit ( i , Frank ) ;
8671: LD_VAR 0 1
8675: PPUSH
8676: LD_EXP 14
8680: PPUSH
8681: CALL_OW 119
8685: GO 8668
8687: POP
8688: POP
// SetSide ( Frank , 1 ) ;
8689: LD_EXP 14
8693: PPUSH
8694: LD_INT 1
8696: PPUSH
8697: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
8701: LD_EXP 8
8705: PPUSH
8706: LD_EXP 14
8710: PPUSH
8711: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
8715: LD_EXP 8
8719: PPUSH
8720: LD_EXP 14
8724: PPUSH
8725: CALL_OW 179
// CenterOnUnits ( Frank ) ;
8729: LD_EXP 14
8733: PPUSH
8734: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
8738: LD_EXP 14
8742: PPUSH
8743: LD_STRING D3a-Frank-1
8745: PPUSH
8746: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
8750: LD_VAR 0 2
8754: PPUSH
8755: LD_INT 42
8757: PPUSH
8758: LD_INT 78
8760: PPUSH
8761: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
8765: LD_VAR 0 2
8769: PPUSH
8770: LD_EXP 14
8774: PPUSH
8775: CALL_OW 179
// if Lisa then
8779: LD_EXP 13
8783: IFFALSE 8797
// Say ( Lisa , D3a-Lisa-1 ) ;
8785: LD_EXP 13
8789: PPUSH
8790: LD_STRING D3a-Lisa-1
8792: PPUSH
8793: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
8797: LD_EXP 8
8801: PPUSH
8802: LD_STRING D3a-JMM-1
8804: PPUSH
8805: CALL_OW 88
// if Cyrus then
8809: LD_EXP 12
8813: IFFALSE 8827
// Say ( Cyrus , D3a-Cyrus-1 ) ;
8815: LD_EXP 12
8819: PPUSH
8820: LD_STRING D3a-Cyrus-1
8822: PPUSH
8823: CALL_OW 88
// if GetRandom ( sex_male ) then
8827: LD_INT 1
8829: PPUSH
8830: CALL 505 0 1
8834: IFFALSE 8855
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
8836: LD_INT 1
8838: PPUSH
8839: CALL 505 0 1
8843: PUSH
8844: LD_INT 1
8846: ARRAY
8847: PPUSH
8848: LD_STRING D3a-Sol1-1
8850: PPUSH
8851: CALL_OW 88
// if GetRandom ( sex_female ) then
8855: LD_INT 2
8857: PPUSH
8858: CALL 505 0 1
8862: IFFALSE 8883
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
8864: LD_INT 2
8866: PPUSH
8867: CALL 505 0 1
8871: PUSH
8872: LD_INT 1
8874: ARRAY
8875: PPUSH
8876: LD_STRING D3a-FSol1-1
8878: PPUSH
8879: CALL_OW 88
// if Gladstone then
8883: LD_EXP 15
8887: IFFALSE 8901
// Say ( Gladstone , D3a-Glad-1 ) ;
8889: LD_EXP 15
8893: PPUSH
8894: LD_STRING D3a-Glad-1
8896: PPUSH
8897: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
8901: LD_VAR 0 2
8905: PPUSH
8906: LD_INT 60
8908: PPUSH
8909: LD_INT 113
8911: PPUSH
8912: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
8916: LD_EXP 14
8920: PPUSH
8921: LD_STRING D3a-Frank-2
8923: PPUSH
8924: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
8928: LD_EXP 14
8932: PPUSH
8933: LD_EXP 8
8937: PPUSH
8938: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
8942: LD_EXP 8
8946: PPUSH
8947: LD_STRING D3a-JMM-2
8949: PPUSH
8950: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
8954: LD_INT 1
8956: PPUSH
8957: LD_INT 4
8959: PPUSH
8960: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
8964: LD_INT 85
8966: PPUSH
8967: LD_INT 134
8969: PPUSH
8970: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
8974: LD_EXP 14
8978: PPUSH
8979: LD_STRING D3a-Frank-3
8981: PPUSH
8982: CALL_OW 88
// Wait ( 0 0$01 ) ;
8986: LD_INT 35
8988: PPUSH
8989: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
8993: LD_INT 166
8995: PPUSH
8996: LD_INT 136
8998: PPUSH
8999: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
9003: LD_EXP 8
9007: PPUSH
9008: LD_STRING D3a-JMM-3
9010: PPUSH
9011: CALL_OW 88
// Wait ( 0 0$01 ) ;
9015: LD_INT 35
9017: PPUSH
9018: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
9022: LD_EXP 14
9026: PPUSH
9027: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
9031: LD_EXP 14
9035: PPUSH
9036: LD_STRING D3a-Frank-4
9038: PPUSH
9039: CALL_OW 88
// if Lisa then
9043: LD_EXP 13
9047: IFFALSE 9061
// Say ( Lisa , D3a-Lisa-4 ) ;
9049: LD_EXP 13
9053: PPUSH
9054: LD_STRING D3a-Lisa-4
9056: PPUSH
9057: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
9061: LD_EXP 8
9065: PPUSH
9066: LD_STRING D3a-JMM-4
9068: PPUSH
9069: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
9073: LD_EXP 14
9077: PPUSH
9078: LD_STRING D3a-Frank-5
9080: PPUSH
9081: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
9085: LD_EXP 8
9089: PPUSH
9090: LD_STRING D3a-JMM-5
9092: PPUSH
9093: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
9097: LD_EXP 14
9101: PPUSH
9102: LD_STRING D3a-Frank-6
9104: PPUSH
9105: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
9109: LD_EXP 8
9113: PPUSH
9114: LD_STRING D3a-JMM-6
9116: PPUSH
9117: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
9121: LD_EXP 14
9125: PPUSH
9126: LD_STRING D3a-Frank-7
9128: PPUSH
9129: CALL_OW 88
// InGameOff ;
9133: CALL_OW 9
// end ;
9137: PPOPN 2
9139: END
// every 0 0$1 trigger Kikuchi and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Kikuchi ) , GetY ( Kikuchi ) , 7 ] ] ) and not InBattle ( 1 ) do
9140: LD_EXP 17
9144: PUSH
9145: LD_INT 22
9147: PUSH
9148: LD_INT 1
9150: PUSH
9151: EMPTY
9152: LIST
9153: LIST
9154: PUSH
9155: LD_INT 92
9157: PUSH
9158: LD_EXP 17
9162: PPUSH
9163: CALL_OW 250
9167: PUSH
9168: LD_EXP 17
9172: PPUSH
9173: CALL_OW 251
9177: PUSH
9178: LD_INT 7
9180: PUSH
9181: EMPTY
9182: LIST
9183: LIST
9184: LIST
9185: LIST
9186: PUSH
9187: EMPTY
9188: LIST
9189: LIST
9190: PPUSH
9191: CALL_OW 69
9195: AND
9196: PUSH
9197: LD_INT 1
9199: PPUSH
9200: CALL_OW 463
9204: NOT
9205: AND
9206: IFFALSE 9386
9208: GO 9210
9210: DISABLE
// begin InGameOn ;
9211: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
9215: LD_EXP 8
9219: PPUSH
9220: LD_EXP 17
9224: PPUSH
9225: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
9229: LD_EXP 17
9233: PPUSH
9234: LD_EXP 8
9238: PPUSH
9239: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
9243: LD_EXP 17
9247: PPUSH
9248: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
9252: LD_EXP 17
9256: PPUSH
9257: LD_STRING D3b-Yam-1
9259: PPUSH
9260: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
9264: LD_EXP 8
9268: PPUSH
9269: LD_STRING D3b-JMM-1
9271: PPUSH
9272: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
9276: LD_INT 1
9278: PPUSH
9279: LD_INT 4
9281: PPUSH
9282: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
9286: LD_INT 85
9288: PPUSH
9289: LD_INT 134
9291: PPUSH
9292: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
9296: LD_EXP 17
9300: PPUSH
9301: LD_STRING D3b-Yam-2
9303: PPUSH
9304: CALL_OW 88
// Wait ( 0 0$01 ) ;
9308: LD_INT 35
9310: PPUSH
9311: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
9315: LD_EXP 8
9319: PPUSH
9320: LD_STRING D3b-JMM-2
9322: PPUSH
9323: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
9327: LD_INT 166
9329: PPUSH
9330: LD_INT 136
9332: PPUSH
9333: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
9337: LD_EXP 17
9341: PPUSH
9342: LD_STRING D3b-Yam-3
9344: PPUSH
9345: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
9349: LD_EXP 8
9353: PPUSH
9354: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
9358: LD_EXP 8
9362: PPUSH
9363: LD_STRING D3b-JMM-3a
9365: PPUSH
9366: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
9370: LD_EXP 17
9374: PPUSH
9375: LD_INT 1
9377: PPUSH
9378: CALL_OW 235
// InGameOff ;
9382: CALL_OW 9
// end ;
9386: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , i ;
9387: LD_INT 7
9389: PPUSH
9390: LD_INT 22
9392: PUSH
9393: LD_INT 1
9395: PUSH
9396: EMPTY
9397: LIST
9398: LIST
9399: PUSH
9400: LD_INT 3
9402: PUSH
9403: LD_INT 24
9405: PUSH
9406: LD_INT 1000
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PUSH
9413: EMPTY
9414: LIST
9415: LIST
9416: PUSH
9417: EMPTY
9418: LIST
9419: LIST
9420: PPUSH
9421: CALL_OW 70
9425: IFFALSE 9843
9427: GO 9429
9429: DISABLE
9430: LD_INT 0
9432: PPUSH
9433: PPUSH
9434: PPUSH
// begin un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) [ 1 ] ;
9435: LD_ADDR_VAR 0 1
9439: PUSH
9440: LD_INT 7
9442: PPUSH
9443: LD_INT 22
9445: PUSH
9446: LD_INT 1
9448: PUSH
9449: EMPTY
9450: LIST
9451: LIST
9452: PUSH
9453: LD_INT 3
9455: PUSH
9456: LD_INT 24
9458: PUSH
9459: LD_INT 1000
9461: PUSH
9462: EMPTY
9463: LIST
9464: LIST
9465: PUSH
9466: EMPTY
9467: LIST
9468: LIST
9469: PUSH
9470: EMPTY
9471: LIST
9472: LIST
9473: PPUSH
9474: CALL_OW 70
9478: PUSH
9479: LD_INT 1
9481: ARRAY
9482: ST_TO_ADDR
// DialogueOn ;
9483: CALL_OW 6
// CenterNowOnUnits ( un ) ;
9487: LD_VAR 0 1
9491: PPUSH
9492: CALL_OW 87
// if Lisa then
9496: LD_EXP 13
9500: IFFALSE 9528
// begin Say ( Lisa , D5-Lisa-1 ) ;
9502: LD_EXP 13
9506: PPUSH
9507: LD_STRING D5-Lisa-1
9509: PPUSH
9510: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
9514: LD_EXP 8
9518: PPUSH
9519: LD_STRING D5-JMM-1a
9521: PPUSH
9522: CALL_OW 88
// end else
9526: GO 9540
// Say ( JMM , D5-JMM-1 ) ;
9528: LD_EXP 8
9532: PPUSH
9533: LD_STRING D5-JMM-1
9535: PPUSH
9536: CALL_OW 88
// DialogueOff ;
9540: CALL_OW 7
// while ( true ) do
9544: LD_INT 1
9546: IFFALSE 9602
// begin wait ( 0 0$01 ) ;
9548: LD_INT 35
9550: PPUSH
9551: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
9555: LD_ADDR_VAR 0 2
9559: PUSH
9560: LD_INT 8
9562: PPUSH
9563: LD_INT 30
9565: PUSH
9566: LD_INT 26
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: PUSH
9573: LD_INT 101
9575: PUSH
9576: LD_INT 1
9578: PUSH
9579: EMPTY
9580: LIST
9581: LIST
9582: PUSH
9583: EMPTY
9584: LIST
9585: LIST
9586: PPUSH
9587: CALL_OW 71
9591: ST_TO_ADDR
// if x then
9592: LD_VAR 0 2
9596: IFFALSE 9600
// break ;
9598: GO 9602
// end ;
9600: GO 9544
// CenterOnUnits ( x [ 1 ] ) ;
9602: LD_VAR 0 2
9606: PUSH
9607: LD_INT 1
9609: ARRAY
9610: PPUSH
9611: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
9615: LD_EXP 14
9619: PUSH
9620: LD_EXP 14
9624: PPUSH
9625: CALL_OW 255
9629: PUSH
9630: LD_INT 1
9632: EQUAL
9633: AND
9634: IFFALSE 9650
// Say ( Frank , D5a-Frank-1 ) else
9636: LD_EXP 14
9640: PPUSH
9641: LD_STRING D5a-Frank-1
9643: PPUSH
9644: CALL_OW 88
9648: GO 9704
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
9650: LD_EXP 17
9654: PUSH
9655: LD_EXP 17
9659: PPUSH
9660: CALL_OW 255
9664: PUSH
9665: LD_INT 1
9667: EQUAL
9668: AND
9669: IFFALSE 9685
// Say ( Kikuchi , D5a-Yam-1 ) else
9671: LD_EXP 17
9675: PPUSH
9676: LD_STRING D5a-Yam-1
9678: PPUSH
9679: CALL_OW 88
9683: GO 9704
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
9685: LD_INT 1
9687: PPUSH
9688: CALL 505 0 1
9692: PUSH
9693: LD_INT 1
9695: ARRAY
9696: PPUSH
9697: LD_STRING D5a-Sol1-1
9699: PPUSH
9700: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
9704: LD_EXP 8
9708: PPUSH
9709: LD_STRING D5a-JMM-1
9711: PPUSH
9712: CALL_OW 88
// if Cyrus then
9716: LD_EXP 12
9720: IFFALSE 9734
// Say ( Cyrus , D5a-Cyrus-1 ) ;
9722: LD_EXP 12
9726: PPUSH
9727: LD_STRING D5a-Cyrus-1
9729: PPUSH
9730: CALL_OW 88
// x := false ;
9734: LD_ADDR_VAR 0 2
9738: PUSH
9739: LD_INT 0
9741: ST_TO_ADDR
// while ( true ) do
9742: LD_INT 1
9744: IFFALSE 9831
// begin wait ( 0 0$01 ) ;
9746: LD_INT 35
9748: PPUSH
9749: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
9753: LD_ADDR_VAR 0 3
9757: PUSH
9758: LD_INT 2
9760: PUSH
9761: LD_INT 30
9763: PUSH
9764: LD_INT 0
9766: PUSH
9767: EMPTY
9768: LIST
9769: LIST
9770: PUSH
9771: LD_INT 30
9773: PUSH
9774: LD_INT 1
9776: PUSH
9777: EMPTY
9778: LIST
9779: LIST
9780: PUSH
9781: EMPTY
9782: LIST
9783: LIST
9784: LIST
9785: PPUSH
9786: CALL_OW 69
9790: PUSH
9791: LD_INT 1
9793: DIFF
9794: PUSH
9795: FOR_IN
9796: IFFALSE 9819
// if BaseNeedEnergy ( i ) then
9798: LD_VAR 0 3
9802: PPUSH
9803: CALL 2527 0 1
9807: IFFALSE 9817
// x := true ;
9809: LD_ADDR_VAR 0 2
9813: PUSH
9814: LD_INT 1
9816: ST_TO_ADDR
9817: GO 9795
9819: POP
9820: POP
// if x then
9821: LD_VAR 0 2
9825: IFFALSE 9829
// break ;
9827: GO 9831
// end ;
9829: GO 9742
// Say ( JMM , D5b-JMM-1 ) ;
9831: LD_EXP 8
9835: PPUSH
9836: LD_STRING D5b-JMM-1
9838: PPUSH
9839: CALL_OW 88
// end ;
9843: PPOPN 3
9845: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
9846: LD_EXP 5
9850: PUSH
9851: LD_INT 1
9853: ARRAY
9854: PUSH
9855: LD_OWVAR 1
9859: LESS
9860: IFFALSE 10060
9862: GO 9864
9864: DISABLE
// begin if not IsDead ( ru_dep_main ) then
9865: LD_INT 16
9867: PPUSH
9868: CALL_OW 301
9872: NOT
9873: IFFALSE 9896
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
9875: LD_EXP 18
9879: PPUSH
9880: LD_STRING D3b-Har-3
9882: PPUSH
9883: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
9887: LD_STRING M2a
9889: PPUSH
9890: CALL_OW 337
// end else
9894: GO 9915
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
9896: LD_EXP 18
9900: PPUSH
9901: LD_STRING D3b-Har-3a
9903: PPUSH
9904: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
9908: LD_STRING M2
9910: PPUSH
9911: CALL_OW 337
// end ; can_end := true ;
9915: LD_ADDR_EXP 6
9919: PUSH
9920: LD_INT 1
9922: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
9923: LD_INT 9
9925: PPUSH
9926: LD_INT 1
9928: PPUSH
9929: CALL_OW 424
// Wait ( 0 0$02 ) ;
9933: LD_INT 70
9935: PPUSH
9936: CALL_OW 67
// if Lisa then
9940: LD_EXP 13
9944: IFFALSE 9958
// Say ( Lisa , D3b-Lisa ) ;
9946: LD_EXP 13
9950: PPUSH
9951: LD_STRING D3b-Lisa
9953: PPUSH
9954: CALL_OW 88
// if Bobby then
9958: LD_EXP 11
9962: IFFALSE 9976
// Say ( Bobby , D3b-Bobby-3 ) ;
9964: LD_EXP 11
9968: PPUSH
9969: LD_STRING D3b-Bobby-3
9971: PPUSH
9972: CALL_OW 88
// if Cyrus then
9976: LD_EXP 12
9980: IFFALSE 9994
// Say ( Cyrus , D3b-Cyrus-3 ) ;
9982: LD_EXP 12
9986: PPUSH
9987: LD_STRING D3b-Cyrus-3
9989: PPUSH
9990: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
9994: LD_EXP 14
9998: PUSH
9999: LD_EXP 14
10003: PPUSH
10004: CALL_OW 255
10008: PUSH
10009: LD_INT 1
10011: EQUAL
10012: AND
10013: IFFALSE 10027
// Say ( Frank , D3b-Frank-3 ) ;
10015: LD_EXP 14
10019: PPUSH
10020: LD_STRING D3b-Frank-3
10022: PPUSH
10023: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
10027: LD_EXP 17
10031: PUSH
10032: LD_EXP 17
10036: PPUSH
10037: CALL_OW 255
10041: PUSH
10042: LD_INT 1
10044: EQUAL
10045: AND
10046: IFFALSE 10060
// Say ( Kikuchi , D3b-Yam-4 ) ;
10048: LD_EXP 17
10052: PPUSH
10053: LD_STRING D3b-Yam-4
10055: PPUSH
10056: CALL_OW 88
// end ;
10060: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
10061: LD_EXP 5
10065: PUSH
10066: LD_INT 2
10068: ARRAY
10069: PUSH
10070: LD_OWVAR 1
10074: LESS
10075: IFFALSE 10107
10077: GO 10079
10079: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
10080: LD_EXP 18
10084: PPUSH
10085: LD_STRING D4-Har-1
10087: PPUSH
10088: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
10092: LD_STRING M3
10094: PPUSH
10095: CALL_OW 337
// must_end := true ;
10099: LD_ADDR_EXP 7
10103: PUSH
10104: LD_INT 1
10106: ST_TO_ADDR
// end ;
10107: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
10108: LD_EXP 5
10112: PUSH
10113: LD_INT 3
10115: ARRAY
10116: PUSH
10117: LD_OWVAR 1
10121: LESS
10122: IFFALSE 10153
10124: GO 10126
10126: DISABLE
// begin if not IsDead ( ru_dep_main ) then
10127: LD_INT 16
10129: PPUSH
10130: CALL_OW 301
10134: NOT
10135: IFFALSE 10146
// YouLost ( TimeOut1 ) else
10137: LD_STRING TimeOut1
10139: PPUSH
10140: CALL_OW 104
10144: GO 10153
// YouLost ( TimeOut2 ) ;
10146: LD_STRING TimeOut2
10148: PPUSH
10149: CALL_OW 104
// end ;
10153: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , i , tmp ;
10154: LD_EXP 8
10158: PPUSH
10159: LD_INT 9
10161: PPUSH
10162: CALL_OW 308
10166: PUSH
10167: LD_EXP 6
10171: AND
10172: IFFALSE 11163
10174: GO 10176
10176: DISABLE
10177: LD_INT 0
10179: PPUSH
10180: PPUSH
10181: PPUSH
// begin wait_on := false ;
10182: LD_ADDR_VAR 0 1
10186: PUSH
10187: LD_INT 0
10189: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
10190: LD_INT 1
10192: PPUSH
10193: CALL 2604 0 1
10197: PUSH
10198: LD_INT 0
10200: PLUS
10201: PUSH
10202: LD_INT 1
10204: PPUSH
10205: LD_INT 9
10207: PPUSH
10208: CALL 2695 0 2
10212: PUSH
10213: LD_INT 1
10215: PPUSH
10216: LD_INT 9
10218: PPUSH
10219: CALL 2742 0 2
10223: ADD
10224: PUSH
10225: LD_INT 0
10227: PLUS
10228: GREATER
10229: IFFALSE 10278
// case Query ( Q1 ) of 1 :
10231: LD_STRING Q1
10233: PPUSH
10234: CALL_OW 97
10238: PUSH
10239: LD_INT 1
10241: DOUBLE
10242: EQUAL
10243: IFTRUE 10247
10245: GO 10258
10247: POP
// wait_on := true ; 2 :
10248: LD_ADDR_VAR 0 1
10252: PUSH
10253: LD_INT 1
10255: ST_TO_ADDR
10256: GO 10278
10258: LD_INT 2
10260: DOUBLE
10261: EQUAL
10262: IFTRUE 10266
10264: GO 10277
10266: POP
// wait_on := false ; end ;
10267: LD_ADDR_VAR 0 1
10271: PUSH
10272: LD_INT 0
10274: ST_TO_ADDR
10275: GO 10278
10277: POP
// repeat wait ( 0 0$01 ) ;
10278: LD_INT 35
10280: PPUSH
10281: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
10285: LD_VAR 0 1
10289: NOT
10290: PUSH
10291: LD_INT 1
10293: PPUSH
10294: CALL 2604 0 1
10298: PUSH
10299: LD_INT 0
10301: PLUS
10302: PUSH
10303: LD_INT 1
10305: PPUSH
10306: LD_INT 9
10308: PPUSH
10309: CALL 2695 0 2
10313: PUSH
10314: LD_INT 1
10316: PPUSH
10317: LD_INT 9
10319: PPUSH
10320: CALL 2742 0 2
10324: ADD
10325: PUSH
10326: LD_INT 0
10328: PLUS
10329: EQUAL
10330: OR
10331: IFFALSE 10278
// DialogueOn ;
10333: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10337: LD_EXP 8
10341: PPUSH
10342: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
10346: LD_EXP 8
10350: PPUSH
10351: LD_STRING D6-JMM-1
10353: PPUSH
10354: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
10358: LD_EXP 18
10362: PPUSH
10363: LD_STRING D6-Har-1
10365: PPUSH
10366: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
10370: LD_EXP 8
10374: PPUSH
10375: LD_STRING D6-JMM-2
10377: PPUSH
10378: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
10382: LD_EXP 18
10386: PPUSH
10387: LD_STRING D6-Har-2
10389: PPUSH
10390: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
10394: LD_EXP 8
10398: PPUSH
10399: LD_STRING D6-JMM-3
10401: PPUSH
10402: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
10406: LD_EXP 18
10410: PPUSH
10411: LD_STRING D6-Har-3
10413: PPUSH
10414: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
10418: LD_EXP 8
10422: PPUSH
10423: LD_STRING D6-JMM-4
10425: PPUSH
10426: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
10430: LD_EXP 18
10434: PPUSH
10435: LD_STRING D6-Har-4
10437: PPUSH
10438: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
10442: LD_EXP 8
10446: PPUSH
10447: LD_STRING D6-JMM-5
10449: PPUSH
10450: CALL_OW 88
// DialogueOff ;
10454: CALL_OW 7
// tmp := FilterBuildings ( 3 ) ;
10458: LD_ADDR_VAR 0 3
10462: PUSH
10463: LD_INT 3
10465: PPUSH
10466: CALL 2873 0 1
10470: ST_TO_ADDR
// if tmp >= 35 then
10471: LD_VAR 0 3
10475: PUSH
10476: LD_INT 35
10478: GREATEREQUAL
10479: IFFALSE 10516
// begin AddMedal ( Destroy1 , - 1 ) ;
10481: LD_STRING Destroy1
10483: PPUSH
10484: LD_INT 1
10486: NEG
10487: PPUSH
10488: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
10492: LD_STRING Destroy2
10494: PPUSH
10495: LD_INT 1
10497: NEG
10498: PPUSH
10499: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
10503: LD_STRING Destroy3
10505: PPUSH
10506: LD_INT 1
10508: NEG
10509: PPUSH
10510: CALL_OW 101
// end else
10514: GO 10603
// begin AddMedal ( Destroy1 , 1 ) ;
10516: LD_STRING Destroy1
10518: PPUSH
10519: LD_INT 1
10521: PPUSH
10522: CALL_OW 101
// if tmp >= 25 then
10526: LD_VAR 0 3
10530: PUSH
10531: LD_INT 25
10533: GREATEREQUAL
10534: IFFALSE 10560
// begin AddMedal ( Destroy2 , - 1 ) ;
10536: LD_STRING Destroy2
10538: PPUSH
10539: LD_INT 1
10541: NEG
10542: PPUSH
10543: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
10547: LD_STRING Destroy3
10549: PPUSH
10550: LD_INT 1
10552: NEG
10553: PPUSH
10554: CALL_OW 101
// end else
10558: GO 10603
// begin AddMedal ( Destroy2 , 1 ) ;
10560: LD_STRING Destroy2
10562: PPUSH
10563: LD_INT 1
10565: PPUSH
10566: CALL_OW 101
// if tmp >= 15 then
10570: LD_VAR 0 3
10574: PUSH
10575: LD_INT 15
10577: GREATEREQUAL
10578: IFFALSE 10593
// AddMedal ( Destroy3 , - 1 ) else
10580: LD_STRING Destroy3
10582: PPUSH
10583: LD_INT 1
10585: NEG
10586: PPUSH
10587: CALL_OW 101
10591: GO 10603
// AddMedal ( Destroy3 , 1 ) ;
10593: LD_STRING Destroy3
10595: PPUSH
10596: LD_INT 1
10598: PPUSH
10599: CALL_OW 101
// end ; end ; GiveMedals ( MAIN ) ;
10603: LD_STRING MAIN
10605: PPUSH
10606: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ;
10610: LD_ADDR_VAR 0 3
10614: PUSH
10615: LD_INT 1
10617: PPUSH
10618: LD_INT 9
10620: PPUSH
10621: CALL 2695 0 2
10625: PUSH
10626: LD_INT 1
10628: PPUSH
10629: LD_INT 9
10631: PPUSH
10632: CALL 2742 0 2
10636: ADD
10637: ST_TO_ADDR
// RewardPeople ( tmp ) ;
10638: LD_VAR 0 3
10642: PPUSH
10643: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10647: LD_EXP 8
10651: PPUSH
10652: LD_EXP 3
10656: PUSH
10657: LD_STRING JMM
10659: STR
10660: PPUSH
10661: CALL_OW 38
// if Brown in tmp then
10665: LD_EXP 9
10669: PUSH
10670: LD_VAR 0 3
10674: IN
10675: IFFALSE 10695
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
10677: LD_EXP 9
10681: PPUSH
10682: LD_EXP 3
10686: PUSH
10687: LD_STRING Brown
10689: STR
10690: PPUSH
10691: CALL_OW 38
// if Donaldson in tmp then
10695: LD_EXP 10
10699: PUSH
10700: LD_VAR 0 3
10704: IN
10705: IFFALSE 10725
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
10707: LD_EXP 10
10711: PPUSH
10712: LD_EXP 3
10716: PUSH
10717: LD_STRING Donaldson
10719: STR
10720: PPUSH
10721: CALL_OW 38
// if Bobby in tmp then
10725: LD_EXP 11
10729: PUSH
10730: LD_VAR 0 3
10734: IN
10735: IFFALSE 10755
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10737: LD_EXP 11
10741: PPUSH
10742: LD_EXP 3
10746: PUSH
10747: LD_STRING Bobby
10749: STR
10750: PPUSH
10751: CALL_OW 38
// if Cyrus in tmp then
10755: LD_EXP 12
10759: PUSH
10760: LD_VAR 0 3
10764: IN
10765: IFFALSE 10785
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10767: LD_EXP 12
10771: PPUSH
10772: LD_EXP 3
10776: PUSH
10777: LD_STRING Cyrus
10779: STR
10780: PPUSH
10781: CALL_OW 38
// if Lisa in tmp then
10785: LD_EXP 13
10789: PUSH
10790: LD_VAR 0 3
10794: IN
10795: IFFALSE 10815
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
10797: LD_EXP 13
10801: PPUSH
10802: LD_EXP 3
10806: PUSH
10807: LD_STRING Lisa
10809: STR
10810: PPUSH
10811: CALL_OW 38
// if Frank in tmp then
10815: LD_EXP 14
10819: PUSH
10820: LD_VAR 0 3
10824: IN
10825: IFFALSE 10845
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
10827: LD_EXP 14
10831: PPUSH
10832: LD_EXP 3
10836: PUSH
10837: LD_STRING Frank
10839: STR
10840: PPUSH
10841: CALL_OW 38
// if Gladstone in tmp then
10845: LD_EXP 15
10849: PUSH
10850: LD_VAR 0 3
10854: IN
10855: IFFALSE 10875
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
10857: LD_EXP 15
10861: PPUSH
10862: LD_EXP 3
10866: PUSH
10867: LD_STRING Gladstone
10869: STR
10870: PPUSH
10871: CALL_OW 38
// if Khatam in tmp then
10875: LD_EXP 16
10879: PUSH
10880: LD_VAR 0 3
10884: IN
10885: IFFALSE 10905
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
10887: LD_EXP 16
10891: PPUSH
10892: LD_EXP 3
10896: PUSH
10897: LD_STRING Khatam
10899: STR
10900: PPUSH
10901: CALL_OW 38
// if Kikuchi in tmp then
10905: LD_EXP 17
10909: PUSH
10910: LD_VAR 0 3
10914: IN
10915: IFFALSE 10935
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
10917: LD_EXP 17
10921: PPUSH
10922: LD_EXP 3
10926: PUSH
10927: LD_STRING Kikuchi
10929: STR
10930: PPUSH
10931: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] , mission_prefix & others ) ;
10935: LD_VAR 0 3
10939: PUSH
10940: LD_EXP 8
10944: PUSH
10945: LD_EXP 9
10949: PUSH
10950: LD_EXP 10
10954: PUSH
10955: LD_EXP 11
10959: PUSH
10960: LD_EXP 12
10964: PUSH
10965: LD_EXP 13
10969: PUSH
10970: LD_EXP 14
10974: PUSH
10975: LD_EXP 15
10979: PUSH
10980: LD_EXP 17
10984: PUSH
10985: LD_EXP 16
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: LIST
10995: LIST
10996: LIST
10997: LIST
10998: LIST
10999: LIST
11000: LIST
11001: DIFF
11002: PPUSH
11003: LD_EXP 3
11007: PUSH
11008: LD_STRING others
11010: STR
11011: PPUSH
11012: CALL_OW 38
// SaveVariable ( tick , 07_time ) ;
11016: LD_OWVAR 1
11020: PPUSH
11021: LD_STRING 07_time
11023: PPUSH
11024: CALL_OW 39
// tmp := [ ] ;
11028: LD_ADDR_VAR 0 3
11032: PUSH
11033: EMPTY
11034: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ] ) do
11035: LD_ADDR_VAR 0 2
11039: PUSH
11040: LD_INT 22
11042: PUSH
11043: LD_INT 1
11045: PUSH
11046: EMPTY
11047: LIST
11048: LIST
11049: PUSH
11050: LD_INT 23
11052: PUSH
11053: LD_INT 1
11055: PUSH
11056: EMPTY
11057: LIST
11058: LIST
11059: PUSH
11060: LD_INT 21
11062: PUSH
11063: LD_INT 2
11065: PUSH
11066: EMPTY
11067: LIST
11068: LIST
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: LIST
11074: PUSH
11075: EMPTY
11076: LIST
11077: PPUSH
11078: CALL_OW 69
11082: PUSH
11083: FOR_IN
11084: IFFALSE 11145
// tmp := tmp ^ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
11086: LD_ADDR_VAR 0 3
11090: PUSH
11091: LD_VAR 0 3
11095: PUSH
11096: LD_VAR 0 2
11100: PPUSH
11101: CALL_OW 265
11105: PUSH
11106: LD_VAR 0 2
11110: PPUSH
11111: CALL_OW 262
11115: PUSH
11116: LD_VAR 0 2
11120: PPUSH
11121: CALL_OW 263
11125: PUSH
11126: LD_VAR 0 2
11130: PPUSH
11131: CALL_OW 264
11135: PUSH
11136: EMPTY
11137: LIST
11138: LIST
11139: LIST
11140: LIST
11141: ADD
11142: ST_TO_ADDR
11143: GO 11083
11145: POP
11146: POP
// SaveVariable ( tmp , 07_vehicles ) ;
11147: LD_VAR 0 3
11151: PPUSH
11152: LD_STRING 07_vehicles
11154: PPUSH
11155: CALL_OW 39
// YouWin ;
11159: CALL_OW 103
// end ; end_of_file
11163: PPOPN 3
11165: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11166: LD_VAR 0 1
11170: PUSH
11171: LD_EXP 8
11175: EQUAL
11176: IFFALSE 11185
// YouLost ( JMM ) ;
11178: LD_STRING JMM
11180: PPUSH
11181: CALL_OW 104
// if GetType ( un ) = unit_building then
11185: LD_VAR 0 1
11189: PPUSH
11190: CALL_OW 247
11194: PUSH
11195: LD_INT 3
11197: EQUAL
11198: IFFALSE 11214
// buildings_counter := buildings_counter + 1 ;
11200: LD_ADDR_EXP 4
11204: PUSH
11205: LD_EXP 4
11209: PUSH
11210: LD_INT 1
11212: PLUS
11213: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
11214: LD_VAR 0 1
11218: PUSH
11219: LD_INT 6
11221: PPUSH
11222: LD_INT 2
11224: PUSH
11225: LD_INT 30
11227: PUSH
11228: LD_INT 33
11230: PUSH
11231: EMPTY
11232: LIST
11233: LIST
11234: PUSH
11235: LD_INT 30
11237: PUSH
11238: LD_INT 32
11240: PUSH
11241: EMPTY
11242: LIST
11243: LIST
11244: PUSH
11245: EMPTY
11246: LIST
11247: LIST
11248: LIST
11249: PPUSH
11250: CALL_OW 70
11254: IN
11255: IFFALSE 11314
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11257: LD_ADDR_EXP 19
11261: PUSH
11262: LD_EXP 19
11266: PUSH
11267: LD_VAR 0 1
11271: PPUSH
11272: CALL_OW 266
11276: PUSH
11277: LD_VAR 0 1
11281: PPUSH
11282: CALL_OW 250
11286: PUSH
11287: LD_VAR 0 1
11291: PPUSH
11292: CALL_OW 251
11296: PUSH
11297: LD_VAR 0 1
11301: PPUSH
11302: CALL_OW 254
11306: PUSH
11307: EMPTY
11308: LIST
11309: LIST
11310: LIST
11311: LIST
11312: ADD
11313: ST_TO_ADDR
// if un = ru_dep_main then
11314: LD_VAR 0 1
11318: PUSH
11319: LD_INT 16
11321: EQUAL
11322: IFFALSE 11331
// ChangeMissionObjectives ( M1a ) ;
11324: LD_STRING M1a
11326: PPUSH
11327: CALL_OW 337
// end ;
11331: PPOPN 1
11333: END
// on BuildingStarted ( b , builder ) do var i ;
11334: LD_INT 0
11336: PPUSH
// begin if GetSide ( b ) = 3 then
11337: LD_VAR 0 1
11341: PPUSH
11342: CALL_OW 255
11346: PUSH
11347: LD_INT 3
11349: EQUAL
11350: IFFALSE 11390
// for i = 1 to 4 do
11352: LD_ADDR_VAR 0 3
11356: PUSH
11357: DOUBLE
11358: LD_INT 1
11360: DEC
11361: ST_TO_ADDR
11362: LD_INT 4
11364: PUSH
11365: FOR_TO
11366: IFFALSE 11388
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
11368: LD_ADDR_EXP 19
11372: PUSH
11373: LD_EXP 19
11377: PPUSH
11378: LD_INT 1
11380: PPUSH
11381: CALL_OW 3
11385: ST_TO_ADDR
11386: GO 11365
11388: POP
11389: POP
// end ;
11390: PPOPN 3
11392: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
11393: LD_VAR 0 1
11397: PPUSH
11398: CALL_OW 266
11402: PUSH
11403: LD_INT 32
11405: PUSH
11406: LD_INT 33
11408: PUSH
11409: EMPTY
11410: LIST
11411: LIST
11412: IN
11413: IFFALSE 11427
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
11415: LD_VAR 0 1
11419: PPUSH
11420: LD_INT 43
11422: PPUSH
11423: CALL_OW 148
11427: PPOPN 1
11429: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
11430: LD_VAR 0 1
11434: PUSH
11435: LD_INT 22
11437: PUSH
11438: LD_INT 3
11440: PUSH
11441: EMPTY
11442: LIST
11443: LIST
11444: PUSH
11445: LD_INT 2
11447: PUSH
11448: LD_INT 30
11450: PUSH
11451: LD_INT 31
11453: PUSH
11454: EMPTY
11455: LIST
11456: LIST
11457: PUSH
11458: LD_INT 30
11460: PUSH
11461: LD_INT 32
11463: PUSH
11464: EMPTY
11465: LIST
11466: LIST
11467: PUSH
11468: EMPTY
11469: LIST
11470: LIST
11471: LIST
11472: PUSH
11473: EMPTY
11474: LIST
11475: LIST
11476: PPUSH
11477: CALL_OW 69
11481: IN
11482: IFFALSE 11504
// GoToAnotherTower ( un , b , 143 , 143 ) ;
11484: LD_VAR 0 2
11488: PPUSH
11489: LD_VAR 0 1
11493: PPUSH
11494: LD_INT 143
11496: PPUSH
11497: LD_INT 143
11499: PPUSH
11500: CALL 2054 0 4
// end ;
11504: PPOPN 2
11506: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
11507: LD_VAR 0 1
11511: PUSH
11512: LD_INT 22
11514: PUSH
11515: LD_INT 3
11517: PUSH
11518: EMPTY
11519: LIST
11520: LIST
11521: PUSH
11522: LD_INT 30
11524: PUSH
11525: LD_INT 32
11527: PUSH
11528: EMPTY
11529: LIST
11530: LIST
11531: PUSH
11532: EMPTY
11533: LIST
11534: LIST
11535: PPUSH
11536: CALL_OW 69
11540: IN
11541: IFFALSE 11555
// SetTag ( b , 0 ) ;
11543: LD_VAR 0 1
11547: PPUSH
11548: LD_INT 0
11550: PPUSH
11551: CALL_OW 109
// end ;
11555: PPOPN 2
11557: END
