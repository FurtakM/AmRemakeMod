// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 29 0 0
// DebugMode ;
  12: CALL 147 0 0
// PrepareRussians ;
  16: CALL 2510 0 0
// PrepareAmericans ;
  20: CALL 1465 0 0
// Action ;
  24: CALL 5123 0 0
// end ;
  28: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end ; function Init ; begin
  29: LD_INT 0
  31: PPUSH
// debug := false ;
  32: LD_ADDR_EXP 1
  36: PUSH
  37: LD_INT 0
  39: ST_TO_ADDR
// mission_prefix := 07c_ ;
  40: LD_ADDR_EXP 3
  44: PUSH
  45: LD_STRING 07c_
  47: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  48: LD_ADDR_EXP 2
  52: PUSH
  53: LD_STRING 07_
  55: ST_TO_ADDR
// buildings_counter := 0 ;
  56: LD_ADDR_EXP 4
  60: PUSH
  61: LD_INT 0
  63: ST_TO_ADDR
// time_to_end := [ [ 27 27$00 , 24 24$00 , 21 21$00 ] [ Difficulty ] , [ 35 35$00 , 32 32$00 , 29 29$00 ] [ Difficulty ] , [ 38 38$00 , 35 35$00 , 32 32$00 ] [ Difficulty ] ] ;
  64: LD_ADDR_EXP 5
  68: PUSH
  69: LD_INT 56700
  71: PUSH
  72: LD_INT 50400
  74: PUSH
  75: LD_INT 44100
  77: PUSH
  78: EMPTY
  79: LIST
  80: LIST
  81: LIST
  82: PUSH
  83: LD_OWVAR 67
  87: ARRAY
  88: PUSH
  89: LD_INT 73500
  91: PUSH
  92: LD_INT 67200
  94: PUSH
  95: LD_INT 60900
  97: PUSH
  98: EMPTY
  99: LIST
 100: LIST
 101: LIST
 102: PUSH
 103: LD_OWVAR 67
 107: ARRAY
 108: PUSH
 109: LD_INT 79800
 111: PUSH
 112: LD_INT 73500
 114: PUSH
 115: LD_INT 67200
 117: PUSH
 118: EMPTY
 119: LIST
 120: LIST
 121: LIST
 122: PUSH
 123: LD_OWVAR 67
 127: ARRAY
 128: PUSH
 129: EMPTY
 130: LIST
 131: LIST
 132: LIST
 133: ST_TO_ADDR
// can_end := false ;
 134: LD_ADDR_EXP 6
 138: PUSH
 139: LD_INT 0
 141: ST_TO_ADDR
// end ;
 142: LD_VAR 0 1
 146: RET
// function DebugMode ; begin
 147: LD_INT 0
 149: PPUSH
// if not debug then
 150: LD_EXP 1
 154: NOT
 155: IFFALSE 159
// exit ;
 157: GO 166
// FogOff ( 1 ) ;
 159: LD_INT 1
 161: PPUSH
 162: CALL_OW 344
// end ;
 166: LD_VAR 0 1
 170: RET
// every 3 trigger debug do var i , filter ;
 171: LD_EXP 1
 175: IFFALSE 264
 177: GO 179
 179: DISABLE
 180: LD_INT 0
 182: PPUSH
 183: PPUSH
// begin enable ;
 184: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 185: LD_ADDR_VAR 0 2
 189: PUSH
 190: LD_INT 22
 192: PUSH
 193: LD_INT 1
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: PUSH
 200: LD_INT 3
 202: PUSH
 203: LD_INT 24
 205: PUSH
 206: LD_INT 500
 208: PUSH
 209: EMPTY
 210: LIST
 211: LIST
 212: PUSH
 213: EMPTY
 214: LIST
 215: LIST
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: PPUSH
 221: CALL_OW 69
 225: ST_TO_ADDR
// if not filter then
 226: LD_VAR 0 2
 230: NOT
 231: IFFALSE 235
// exit ;
 233: GO 264
// for i in filter do
 235: LD_ADDR_VAR 0 1
 239: PUSH
 240: LD_VAR 0 2
 244: PUSH
 245: FOR_IN
 246: IFFALSE 262
// SetLives ( i , 1000 ) ;
 248: LD_VAR 0 1
 252: PPUSH
 253: LD_INT 1000
 255: PPUSH
 256: CALL_OW 234
 260: GO 245
 262: POP
 263: POP
// end ; end_of_file
 264: PPOPN 2
 266: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 267: LD_INT 0
 269: PPUSH
 270: PPUSH
// if exist_mode then
 271: LD_VAR 0 2
 275: IFFALSE 300
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 277: LD_ADDR_VAR 0 4
 281: PUSH
 282: LD_EXP 2
 286: PUSH
 287: LD_VAR 0 1
 291: STR
 292: PPUSH
 293: CALL_OW 34
 297: ST_TO_ADDR
 298: GO 315
// unit := NewCharacter ( ident ) ;
 300: LD_ADDR_VAR 0 4
 304: PUSH
 305: LD_VAR 0 1
 309: PPUSH
 310: CALL_OW 25
 314: ST_TO_ADDR
// result := unit ;
 315: LD_ADDR_VAR 0 3
 319: PUSH
 320: LD_VAR 0 4
 324: ST_TO_ADDR
// end ;
 325: LD_VAR 0 3
 329: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 330: LD_INT 0
 332: PPUSH
// uc_side := side ;
 333: LD_ADDR_OWVAR 20
 337: PUSH
 338: LD_VAR 0 1
 342: ST_TO_ADDR
// uc_nation := nation ;
 343: LD_ADDR_OWVAR 21
 347: PUSH
 348: LD_VAR 0 2
 352: ST_TO_ADDR
// vc_chassis := chassis ;
 353: LD_ADDR_OWVAR 37
 357: PUSH
 358: LD_VAR 0 3
 362: ST_TO_ADDR
// vc_engine := engine ;
 363: LD_ADDR_OWVAR 39
 367: PUSH
 368: LD_VAR 0 4
 372: ST_TO_ADDR
// vc_control := control ;
 373: LD_ADDR_OWVAR 38
 377: PUSH
 378: LD_VAR 0 5
 382: ST_TO_ADDR
// vc_weapon := weapon ;
 383: LD_ADDR_OWVAR 40
 387: PUSH
 388: LD_VAR 0 6
 392: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 393: LD_ADDR_OWVAR 41
 397: PUSH
 398: LD_VAR 0 7
 402: ST_TO_ADDR
// result := CreateVehicle ;
 403: LD_ADDR_VAR 0 8
 407: PUSH
 408: CALL_OW 45
 412: ST_TO_ADDR
// end ;
 413: LD_VAR 0 8
 417: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 418: LD_INT 0
 420: PPUSH
 421: PPUSH
 422: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 423: LD_ADDR_VAR 0 4
 427: PUSH
 428: LD_INT 22
 430: PUSH
 431: LD_INT 1
 433: PUSH
 434: EMPTY
 435: LIST
 436: LIST
 437: PUSH
 438: LD_INT 21
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: PUSH
 448: LD_INT 50
 450: PUSH
 451: EMPTY
 452: LIST
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: LIST
 458: PPUSH
 459: CALL_OW 69
 463: PUSH
 464: LD_EXP 7
 468: PUSH
 469: LD_EXP 8
 473: PUSH
 474: LD_EXP 9
 478: PUSH
 479: LD_EXP 10
 483: PUSH
 484: LD_EXP 11
 488: PUSH
 489: LD_EXP 12
 493: PUSH
 494: LD_EXP 13
 498: PUSH
 499: LD_EXP 14
 503: PUSH
 504: LD_EXP 16
 508: PUSH
 509: LD_EXP 15
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: LIST
 525: DIFF
 526: ST_TO_ADDR
// if not filter then
 527: LD_VAR 0 4
 531: NOT
 532: IFFALSE 536
// exit ;
 534: GO 563
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 536: LD_ADDR_VAR 0 2
 540: PUSH
 541: LD_VAR 0 4
 545: PPUSH
 546: LD_INT 26
 548: PUSH
 549: LD_VAR 0 1
 553: PUSH
 554: EMPTY
 555: LIST
 556: LIST
 557: PPUSH
 558: CALL_OW 72
 562: ST_TO_ADDR
// end ;
 563: LD_VAR 0 2
 567: RET
// export function SayX ( units , ident ) ; var i ; begin
 568: LD_INT 0
 570: PPUSH
 571: PPUSH
// result := false ;
 572: LD_ADDR_VAR 0 3
 576: PUSH
 577: LD_INT 0
 579: ST_TO_ADDR
// if not units then
 580: LD_VAR 0 1
 584: NOT
 585: IFFALSE 589
// exit ;
 587: GO 643
// for i in units do
 589: LD_ADDR_VAR 0 4
 593: PUSH
 594: LD_VAR 0 1
 598: PUSH
 599: FOR_IN
 600: IFFALSE 641
// if IsOk ( i ) then
 602: LD_VAR 0 4
 606: PPUSH
 607: CALL_OW 302
 611: IFFALSE 639
// begin Say ( i , ident ) ;
 613: LD_VAR 0 4
 617: PPUSH
 618: LD_VAR 0 2
 622: PPUSH
 623: CALL_OW 88
// result := i ;
 627: LD_ADDR_VAR 0 3
 631: PUSH
 632: LD_VAR 0 4
 636: ST_TO_ADDR
// break ;
 637: GO 641
// end ;
 639: GO 599
 641: POP
 642: POP
// end ;
 643: LD_VAR 0 3
 647: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
 648: LD_INT 0
 650: PPUSH
 651: PPUSH
 652: PPUSH
 653: PPUSH
 654: PPUSH
// if not un or not IsOk ( un ) then
 655: LD_VAR 0 1
 659: NOT
 660: PUSH
 661: LD_VAR 0 1
 665: PPUSH
 666: CALL_OW 302
 670: NOT
 671: OR
 672: IFFALSE 676
// exit ;
 674: GO 1070
// side := GetSide ( un ) ;
 676: LD_ADDR_VAR 0 9
 680: PUSH
 681: LD_VAR 0 1
 685: PPUSH
 686: CALL_OW 255
 690: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
 691: LD_ADDR_VAR 0 7
 695: PUSH
 696: LD_INT 22
 698: PUSH
 699: LD_VAR 0 9
 703: PUSH
 704: EMPTY
 705: LIST
 706: LIST
 707: PUSH
 708: LD_INT 30
 710: PUSH
 711: LD_INT 32
 713: PUSH
 714: EMPTY
 715: LIST
 716: LIST
 717: PUSH
 718: LD_INT 50
 720: PUSH
 721: EMPTY
 722: LIST
 723: PUSH
 724: LD_INT 58
 726: PUSH
 727: EMPTY
 728: LIST
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: LIST
 734: LIST
 735: PPUSH
 736: CALL_OW 69
 740: PUSH
 741: LD_VAR 0 2
 745: DIFF
 746: ST_TO_ADDR
// if not filter then
 747: LD_VAR 0 7
 751: NOT
 752: IFFALSE 935
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
 754: LD_ADDR_VAR 0 7
 758: PUSH
 759: LD_INT 22
 761: PUSH
 762: LD_VAR 0 9
 766: PUSH
 767: EMPTY
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 30
 773: PUSH
 774: LD_INT 5
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: PPUSH
 785: CALL_OW 69
 789: ST_TO_ADDR
// if not filter then
 790: LD_VAR 0 7
 794: NOT
 795: IFFALSE 818
// begin ComMoveXY ( un , x , y ) ;
 797: LD_VAR 0 1
 801: PPUSH
 802: LD_VAR 0 3
 806: PPUSH
 807: LD_VAR 0 4
 811: PPUSH
 812: CALL_OW 111
// exit ;
 816: GO 1070
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
 818: LD_ADDR_VAR 0 8
 822: PUSH
 823: LD_VAR 0 7
 827: PPUSH
 828: LD_VAR 0 1
 832: PPUSH
 833: CALL_OW 74
 837: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
 838: LD_VAR 0 8
 842: PPUSH
 843: CALL_OW 313
 847: PUSH
 848: LD_INT 6
 850: EQUAL
 851: IFFALSE 869
// filter := filter diff t ;
 853: LD_ADDR_VAR 0 7
 857: PUSH
 858: LD_VAR 0 7
 862: PUSH
 863: LD_VAR 0 8
 867: DIFF
 868: ST_TO_ADDR
// until UnitsInside ( t ) < 6 or not filter ;
 869: LD_VAR 0 8
 873: PPUSH
 874: CALL_OW 313
 878: PUSH
 879: LD_INT 6
 881: LESS
 882: PUSH
 883: LD_VAR 0 7
 887: NOT
 888: OR
 889: IFFALSE 818
// if not filter then
 891: LD_VAR 0 7
 895: NOT
 896: IFFALSE 919
// ComMoveXY ( un , x , y ) else
 898: LD_VAR 0 1
 902: PPUSH
 903: LD_VAR 0 3
 907: PPUSH
 908: LD_VAR 0 4
 912: PPUSH
 913: CALL_OW 111
 917: GO 933
// ComEnterUnit ( un , t ) ;
 919: LD_VAR 0 1
 923: PPUSH
 924: LD_VAR 0 8
 928: PPUSH
 929: CALL_OW 120
// end else
 933: GO 1070
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
 935: LD_ADDR_VAR 0 8
 939: PUSH
 940: LD_VAR 0 7
 944: PPUSH
 945: LD_VAR 0 1
 949: PPUSH
 950: CALL_OW 74
 954: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
 955: LD_VAR 0 8
 959: PPUSH
 960: CALL_OW 110
 964: PUSH
 965: LD_INT 7
 967: EQUAL
 968: IFFALSE 986
// filter := filter diff t ;
 970: LD_ADDR_VAR 0 7
 974: PUSH
 975: LD_VAR 0 7
 979: PUSH
 980: LD_VAR 0 8
 984: DIFF
 985: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
 986: LD_VAR 0 8
 990: PPUSH
 991: CALL_OW 110
 995: PUSH
 996: LD_INT 7
 998: NONEQUAL
 999: PUSH
1000: LD_VAR 0 7
1004: NOT
1005: OR
1006: IFFALSE 935
// if GetTag ( t ) <> 7 then
1008: LD_VAR 0 8
1012: PPUSH
1013: CALL_OW 110
1017: PUSH
1018: LD_INT 7
1020: NONEQUAL
1021: IFFALSE 1051
// begin SetTag ( t , 7 ) ;
1023: LD_VAR 0 8
1027: PPUSH
1028: LD_INT 7
1030: PPUSH
1031: CALL_OW 109
// ComEnterUnit ( un , t ) ;
1035: LD_VAR 0 1
1039: PPUSH
1040: LD_VAR 0 8
1044: PPUSH
1045: CALL_OW 120
// end else
1049: GO 1070
// ComMoveXY ( un , x , y ) ;
1051: LD_VAR 0 1
1055: PPUSH
1056: LD_VAR 0 3
1060: PPUSH
1061: LD_VAR 0 4
1065: PPUSH
1066: CALL_OW 111
// end ; end ;
1070: LD_VAR 0 5
1074: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
1075: LD_INT 0
1077: PPUSH
1078: PPUSH
1079: PPUSH
// if not base then
1080: LD_VAR 0 1
1084: NOT
1085: IFFALSE 1089
// exit ;
1087: GO 1147
// tmp := GetEnergy ( GetBase ( base ) ) ;
1089: LD_ADDR_VAR 0 4
1093: PUSH
1094: LD_VAR 0 1
1098: PPUSH
1099: CALL_OW 274
1103: PPUSH
1104: CALL_OW 278
1108: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
1109: LD_VAR 0 4
1113: PUSH
1114: LD_INT 1
1116: ARRAY
1117: PUSH
1118: LD_VAR 0 4
1122: PUSH
1123: LD_INT 4
1125: ARRAY
1126: GREATER
1127: IFFALSE 1139
// result := true else
1129: LD_ADDR_VAR 0 2
1133: PUSH
1134: LD_INT 1
1136: ST_TO_ADDR
1137: GO 1147
// result := false ;
1139: LD_ADDR_VAR 0 2
1143: PUSH
1144: LD_INT 0
1146: ST_TO_ADDR
// end ;
1147: LD_VAR 0 2
1151: RET
// export function FilterPeople ( side ) ; begin
1152: LD_INT 0
1154: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
1155: LD_ADDR_VAR 0 2
1159: PUSH
1160: LD_INT 22
1162: PUSH
1163: LD_VAR 0 1
1167: PUSH
1168: EMPTY
1169: LIST
1170: LIST
1171: PUSH
1172: LD_INT 21
1174: PUSH
1175: LD_INT 1
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PUSH
1182: EMPTY
1183: LIST
1184: LIST
1185: PPUSH
1186: CALL_OW 69
1190: ST_TO_ADDR
// end ;
1191: LD_VAR 0 2
1195: RET
// export function FilterDrivers ( side ) ; begin
1196: LD_INT 0
1198: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
1199: LD_ADDR_VAR 0 2
1203: PUSH
1204: LD_INT 22
1206: PUSH
1207: LD_VAR 0 1
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 3
1218: PUSH
1219: LD_INT 56
1221: PUSH
1222: EMPTY
1223: LIST
1224: PUSH
1225: EMPTY
1226: LIST
1227: LIST
1228: PUSH
1229: EMPTY
1230: LIST
1231: LIST
1232: PPUSH
1233: CALL_OW 69
1237: ST_TO_ADDR
// end ;
1238: LD_VAR 0 2
1242: RET
// export function FilterPeopleArea ( side , area ) ; begin
1243: LD_INT 0
1245: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
1246: LD_ADDR_VAR 0 3
1250: PUSH
1251: LD_VAR 0 2
1255: PPUSH
1256: LD_INT 22
1258: PUSH
1259: LD_INT 1
1261: PUSH
1262: EMPTY
1263: LIST
1264: LIST
1265: PUSH
1266: LD_INT 21
1268: PUSH
1269: LD_INT 1
1271: PUSH
1272: EMPTY
1273: LIST
1274: LIST
1275: PUSH
1276: EMPTY
1277: LIST
1278: LIST
1279: PPUSH
1280: CALL_OW 70
1284: ST_TO_ADDR
// end ;
1285: LD_VAR 0 3
1289: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
1290: LD_INT 0
1292: PPUSH
1293: PPUSH
1294: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
1295: LD_ADDR_VAR 0 5
1299: PUSH
1300: LD_VAR 0 2
1304: PPUSH
1305: LD_INT 22
1307: PUSH
1308: LD_INT 1
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: PUSH
1315: LD_INT 21
1317: PUSH
1318: LD_INT 2
1320: PUSH
1321: EMPTY
1322: LIST
1323: LIST
1324: PUSH
1325: LD_INT 3
1327: PUSH
1328: LD_INT 58
1330: PUSH
1331: EMPTY
1332: LIST
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: PUSH
1338: EMPTY
1339: LIST
1340: LIST
1341: LIST
1342: PPUSH
1343: CALL_OW 70
1347: ST_TO_ADDR
// result := [ ] ;
1348: LD_ADDR_VAR 0 3
1352: PUSH
1353: EMPTY
1354: ST_TO_ADDR
// if not tmp then
1355: LD_VAR 0 5
1359: NOT
1360: IFFALSE 1364
// exit ;
1362: GO 1416
// for i in tmp do
1364: LD_ADDR_VAR 0 4
1368: PUSH
1369: LD_VAR 0 5
1373: PUSH
1374: FOR_IN
1375: IFFALSE 1400
// result := result ^ IsDrivenBy ( i ) ;
1377: LD_ADDR_VAR 0 3
1381: PUSH
1382: LD_VAR 0 3
1386: PUSH
1387: LD_VAR 0 4
1391: PPUSH
1392: CALL_OW 311
1396: ADD
1397: ST_TO_ADDR
1398: GO 1374
1400: POP
1401: POP
// result := result diff 0 ;
1402: LD_ADDR_VAR 0 3
1406: PUSH
1407: LD_VAR 0 3
1411: PUSH
1412: LD_INT 0
1414: DIFF
1415: ST_TO_ADDR
// end ;
1416: LD_VAR 0 3
1420: RET
// export function FilterBuildings ( side ) ; begin
1421: LD_INT 0
1423: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
1424: LD_ADDR_VAR 0 2
1428: PUSH
1429: LD_INT 22
1431: PUSH
1432: LD_VAR 0 1
1436: PUSH
1437: EMPTY
1438: LIST
1439: LIST
1440: PUSH
1441: LD_INT 21
1443: PUSH
1444: LD_INT 3
1446: PUSH
1447: EMPTY
1448: LIST
1449: LIST
1450: PUSH
1451: EMPTY
1452: LIST
1453: LIST
1454: PPUSH
1455: CALL_OW 69
1459: ST_TO_ADDR
// end ; end_of_file
1460: LD_VAR 0 2
1464: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
1465: LD_INT 0
1467: PPUSH
1468: PPUSH
1469: PPUSH
1470: PPUSH
1471: PPUSH
1472: PPUSH
// uc_side := 1 ;
1473: LD_ADDR_OWVAR 20
1477: PUSH
1478: LD_INT 1
1480: ST_TO_ADDR
// uc_nation := 1 ;
1481: LD_ADDR_OWVAR 21
1485: PUSH
1486: LD_INT 1
1488: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
1489: LD_ADDR_EXP 7
1493: PUSH
1494: LD_STRING JMM
1496: PPUSH
1497: LD_EXP 1
1501: NOT
1502: PPUSH
1503: CALL 267 0 2
1507: ST_TO_ADDR
// team := [ JMM ] ;
1508: LD_ADDR_VAR 0 3
1512: PUSH
1513: LD_EXP 7
1517: PUSH
1518: EMPTY
1519: LIST
1520: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
1521: LD_STRING BrownIn07
1523: PPUSH
1524: LD_EXP 1
1528: PPUSH
1529: CALL_OW 30
1533: IFFALSE 1554
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
1535: LD_ADDR_EXP 8
1539: PUSH
1540: LD_STRING Brown
1542: PPUSH
1543: LD_EXP 1
1547: NOT
1548: PPUSH
1549: CALL 267 0 2
1553: ST_TO_ADDR
// if Brown then
1554: LD_EXP 8
1558: IFFALSE 1576
// team := team ^ Brown ;
1560: LD_ADDR_VAR 0 3
1564: PUSH
1565: LD_VAR 0 3
1569: PUSH
1570: LD_EXP 8
1574: ADD
1575: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
1576: LD_STRING DonaldsonIn07
1578: PPUSH
1579: LD_EXP 1
1583: PPUSH
1584: CALL_OW 30
1588: IFFALSE 1609
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
1590: LD_ADDR_EXP 9
1594: PUSH
1595: LD_STRING Donaldson
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: CALL 267 0 2
1608: ST_TO_ADDR
// if Donaldson then
1609: LD_EXP 9
1613: IFFALSE 1631
// team := team ^ Donaldson ;
1615: LD_ADDR_VAR 0 3
1619: PUSH
1620: LD_VAR 0 3
1624: PUSH
1625: LD_EXP 9
1629: ADD
1630: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
1631: LD_STRING BobbyIn07
1633: PPUSH
1634: LD_EXP 1
1638: PPUSH
1639: CALL_OW 30
1643: IFFALSE 1664
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
1645: LD_ADDR_EXP 10
1649: PUSH
1650: LD_STRING Bobby
1652: PPUSH
1653: LD_EXP 1
1657: NOT
1658: PPUSH
1659: CALL 267 0 2
1663: ST_TO_ADDR
// if Bobby then
1664: LD_EXP 10
1668: IFFALSE 1686
// team := team ^ Bobby ;
1670: LD_ADDR_VAR 0 3
1674: PUSH
1675: LD_VAR 0 3
1679: PUSH
1680: LD_EXP 10
1684: ADD
1685: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
1686: LD_STRING CyrusIn07
1688: PPUSH
1689: LD_EXP 1
1693: PPUSH
1694: CALL_OW 30
1698: IFFALSE 1719
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
1700: LD_ADDR_EXP 11
1704: PUSH
1705: LD_STRING Cyrus
1707: PPUSH
1708: LD_EXP 1
1712: NOT
1713: PPUSH
1714: CALL 267 0 2
1718: ST_TO_ADDR
// if Cyrus then
1719: LD_EXP 11
1723: IFFALSE 1741
// team := team ^ Cyrus ;
1725: LD_ADDR_VAR 0 3
1729: PUSH
1730: LD_VAR 0 3
1734: PUSH
1735: LD_EXP 11
1739: ADD
1740: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
1741: LD_STRING LisaIn07
1743: PPUSH
1744: LD_EXP 1
1748: PPUSH
1749: CALL_OW 30
1753: IFFALSE 1774
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
1755: LD_ADDR_EXP 12
1759: PUSH
1760: LD_STRING Lisa
1762: PPUSH
1763: LD_EXP 1
1767: NOT
1768: PPUSH
1769: CALL 267 0 2
1773: ST_TO_ADDR
// if Lisa then
1774: LD_EXP 12
1778: IFFALSE 1796
// team := team ^ Lisa ;
1780: LD_ADDR_VAR 0 3
1784: PUSH
1785: LD_VAR 0 3
1789: PUSH
1790: LD_EXP 12
1794: ADD
1795: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
1796: LD_STRING GladstoneIn07
1798: PPUSH
1799: LD_EXP 1
1803: PPUSH
1804: CALL_OW 30
1808: IFFALSE 1829
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
1810: LD_ADDR_EXP 14
1814: PUSH
1815: LD_STRING Gladstone
1817: PPUSH
1818: LD_EXP 1
1822: NOT
1823: PPUSH
1824: CALL 267 0 2
1828: ST_TO_ADDR
// if Gladstone then
1829: LD_EXP 14
1833: IFFALSE 1851
// team := team ^ Gladstone ;
1835: LD_ADDR_VAR 0 3
1839: PUSH
1840: LD_VAR 0 3
1844: PUSH
1845: LD_EXP 14
1849: ADD
1850: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
1851: LD_STRING KhatamIn07
1853: PPUSH
1854: LD_EXP 1
1858: PPUSH
1859: CALL_OW 30
1863: IFFALSE 1884
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
1865: LD_ADDR_EXP 15
1869: PUSH
1870: LD_STRING Khatam
1872: PPUSH
1873: LD_EXP 1
1877: NOT
1878: PPUSH
1879: CALL 267 0 2
1883: ST_TO_ADDR
// if Khatam then
1884: LD_EXP 15
1888: IFFALSE 1906
// team := team ^ Khatam ;
1890: LD_ADDR_VAR 0 3
1894: PUSH
1895: LD_VAR 0 3
1899: PUSH
1900: LD_EXP 15
1904: ADD
1905: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
1906: LD_ADDR_VAR 0 4
1910: PUSH
1911: LD_STRING 07_others
1913: PPUSH
1914: CALL_OW 31
1918: ST_TO_ADDR
// if others then
1919: LD_VAR 0 4
1923: IFFALSE 1941
// team := team ^ others ;
1925: LD_ADDR_VAR 0 3
1929: PUSH
1930: LD_VAR 0 3
1934: PUSH
1935: LD_VAR 0 4
1939: ADD
1940: ST_TO_ADDR
// if debug then
1941: LD_EXP 1
1945: IFFALSE 2019
// begin InitHc ;
1947: CALL_OW 19
// for i = 1 to 4 do
1951: LD_ADDR_VAR 0 2
1955: PUSH
1956: DOUBLE
1957: LD_INT 1
1959: DEC
1960: ST_TO_ADDR
1961: LD_INT 4
1963: PUSH
1964: FOR_TO
1965: IFFALSE 2017
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
1967: LD_INT 0
1969: PPUSH
1970: LD_INT 1
1972: PUSH
1973: LD_INT 3
1975: PUSH
1976: EMPTY
1977: LIST
1978: LIST
1979: PUSH
1980: LD_INT 1
1982: PPUSH
1983: LD_INT 2
1985: PPUSH
1986: CALL_OW 12
1990: ARRAY
1991: PPUSH
1992: LD_INT 4
1994: PPUSH
1995: CALL_OW 380
// team := team ^ CreateHuman ;
1999: LD_ADDR_VAR 0 3
2003: PUSH
2004: LD_VAR 0 3
2008: PUSH
2009: CALL_OW 44
2013: ADD
2014: ST_TO_ADDR
// end ;
2015: GO 1964
2017: POP
2018: POP
// end ; m := 0 ;
2019: LD_ADDR_VAR 0 6
2023: PUSH
2024: LD_INT 0
2026: ST_TO_ADDR
// for i in team do
2027: LD_ADDR_VAR 0 2
2031: PUSH
2032: LD_VAR 0 3
2036: PUSH
2037: FOR_IN
2038: IFFALSE 2218
// if GetClass ( i ) = 3 then
2040: LD_VAR 0 2
2044: PPUSH
2045: CALL_OW 257
2049: PUSH
2050: LD_INT 3
2052: EQUAL
2053: IFFALSE 2201
// begin m := m + 1 ;
2055: LD_ADDR_VAR 0 6
2059: PUSH
2060: LD_VAR 0 6
2064: PUSH
2065: LD_INT 1
2067: PLUS
2068: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
2069: LD_ADDR_VAR 0 5
2073: PUSH
2074: LD_INT 1
2076: PPUSH
2077: LD_INT 1
2079: PPUSH
2080: LD_INT 2
2082: PUSH
2083: LD_INT 3
2085: PUSH
2086: LD_INT 2
2088: PUSH
2089: LD_INT 1
2091: PUSH
2092: EMPTY
2093: LIST
2094: LIST
2095: LIST
2096: LIST
2097: PUSH
2098: LD_VAR 0 6
2102: PUSH
2103: LD_INT 4
2105: MOD
2106: PUSH
2107: LD_INT 1
2109: PLUS
2110: ARRAY
2111: PPUSH
2112: LD_INT 2
2114: PPUSH
2115: LD_INT 1
2117: PPUSH
2118: LD_INT 4
2120: PUSH
2121: LD_INT 5
2123: PUSH
2124: LD_INT 3
2126: PUSH
2127: LD_INT 11
2129: PUSH
2130: EMPTY
2131: LIST
2132: LIST
2133: LIST
2134: LIST
2135: PUSH
2136: LD_VAR 0 6
2140: PUSH
2141: LD_INT 4
2143: MOD
2144: PUSH
2145: LD_INT 1
2147: PLUS
2148: ARRAY
2149: PPUSH
2150: LD_INT 60
2152: PPUSH
2153: CALL 330 0 7
2157: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2158: LD_VAR 0 5
2162: PPUSH
2163: LD_INT 2
2165: PPUSH
2166: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
2170: LD_VAR 0 5
2174: PPUSH
2175: LD_INT 1
2177: PPUSH
2178: LD_INT 0
2180: PPUSH
2181: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2185: LD_VAR 0 2
2189: PPUSH
2190: LD_VAR 0 5
2194: PPUSH
2195: CALL_OW 52
// end else
2199: GO 2216
// PlaceUnitArea ( i , startArea , false ) ;
2201: LD_VAR 0 2
2205: PPUSH
2206: LD_INT 1
2208: PPUSH
2209: LD_INT 0
2211: PPUSH
2212: CALL_OW 49
2216: GO 2037
2218: POP
2219: POP
// uc_side := 4 ;
2220: LD_ADDR_OWVAR 20
2224: PUSH
2225: LD_INT 4
2227: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
2228: LD_ADDR_EXP 17
2232: PUSH
2233: LD_STRING Harisson
2235: PPUSH
2236: LD_INT 0
2238: PPUSH
2239: CALL 267 0 2
2243: ST_TO_ADDR
// PrepareScout ;
2244: CALL 2253 0 0
// end ;
2248: LD_VAR 0 1
2252: RET
// function PrepareScout ; var ape ; begin
2253: LD_INT 0
2255: PPUSH
2256: PPUSH
// uc_side := 4 ;
2257: LD_ADDR_OWVAR 20
2261: PUSH
2262: LD_INT 4
2264: ST_TO_ADDR
// uc_nation := 1 ;
2265: LD_ADDR_OWVAR 21
2269: PUSH
2270: LD_INT 1
2272: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
2273: LD_STRING FrankIn06
2275: PPUSH
2276: LD_INT 0
2278: PPUSH
2279: CALL_OW 30
2283: IFFALSE 2300
// Frank := CreateCharacter ( 06c_Frank ) else
2285: LD_ADDR_EXP 13
2289: PUSH
2290: LD_STRING 06c_Frank
2292: PPUSH
2293: CALL_OW 34
2297: ST_TO_ADDR
2298: GO 2340
// if LoadVariable ( FrankInDelta , 0 ) then
2300: LD_STRING FrankInDelta
2302: PPUSH
2303: LD_INT 0
2305: PPUSH
2306: CALL_OW 30
2310: IFFALSE 2327
// Frank := CreateCharacter ( 05_Frank ) else
2312: LD_ADDR_EXP 13
2316: PUSH
2317: LD_STRING 05_Frank
2319: PPUSH
2320: CALL_OW 34
2324: ST_TO_ADDR
2325: GO 2340
// Frank := CreateCharacter ( 04_Frank ) ;
2327: LD_ADDR_EXP 13
2331: PUSH
2332: LD_STRING 04_Frank
2334: PPUSH
2335: CALL_OW 34
2339: ST_TO_ADDR
// if Frank then
2340: LD_EXP 13
2344: IFFALSE 2465
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
2346: LD_EXP 13
2350: PPUSH
2351: LD_INT 2
2353: PPUSH
2354: LD_INT 0
2356: PPUSH
2357: CALL_OW 49
// uc_side := 0 ;
2361: LD_ADDR_OWVAR 20
2365: PUSH
2366: LD_INT 0
2368: ST_TO_ADDR
// uc_nation := 0 ;
2369: LD_ADDR_OWVAR 21
2373: PUSH
2374: LD_INT 0
2376: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
2377: LD_INT 0
2379: PPUSH
2380: LD_INT 12
2382: PPUSH
2383: LD_INT 0
2385: PPUSH
2386: CALL_OW 380
// ape := CreateHuman ;
2390: LD_ADDR_VAR 0 2
2394: PUSH
2395: CALL_OW 44
2399: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
2400: LD_VAR 0 2
2404: PPUSH
2405: LD_EXP 13
2409: PPUSH
2410: CALL_OW 250
2414: PPUSH
2415: LD_EXP 13
2419: PPUSH
2420: CALL_OW 251
2424: PPUSH
2425: LD_INT 5
2427: PPUSH
2428: LD_INT 0
2430: PPUSH
2431: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
2435: LD_VAR 0 2
2439: PPUSH
2440: LD_EXP 13
2444: PPUSH
2445: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
2449: LD_EXP 13
2453: PPUSH
2454: LD_VAR 0 2
2458: PPUSH
2459: CALL_OW 119
// exit ;
2463: GO 2505
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
2465: LD_ADDR_EXP 16
2469: PUSH
2470: LD_STRING Yamoko
2472: PPUSH
2473: LD_INT 0
2475: PPUSH
2476: CALL 267 0 2
2480: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
2481: LD_EXP 16
2485: PPUSH
2486: LD_INT 2
2488: PPUSH
2489: LD_INT 0
2491: PPUSH
2492: CALL_OW 49
// ComHold ( Kikuchi ) ;
2496: LD_EXP 16
2500: PPUSH
2501: CALL_OW 140
// end ; end_of_file
2505: LD_VAR 0 1
2509: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
2510: LD_INT 0
2512: PPUSH
2513: PPUSH
2514: PPUSH
2515: PPUSH
2516: PPUSH
2517: PPUSH
2518: PPUSH
2519: PPUSH
2520: PPUSH
2521: PPUSH
2522: PPUSH
2523: PPUSH
2524: PPUSH
2525: PPUSH
2526: PPUSH
2527: PPUSH
// ru_rebuild_list := [ ] ;
2528: LD_ADDR_EXP 18
2532: PUSH
2533: EMPTY
2534: ST_TO_ADDR
// uc_side := 3 ;
2535: LD_ADDR_OWVAR 20
2539: PUSH
2540: LD_INT 3
2542: ST_TO_ADDR
// uc_nation := 3 ;
2543: LD_ADDR_OWVAR 21
2547: PUSH
2548: LD_INT 3
2550: ST_TO_ADDR
// if Difficulty > 1 then
2551: LD_OWVAR 67
2555: PUSH
2556: LD_INT 1
2558: GREATER
2559: IFFALSE 2695
// begin bc_type := b_breastwork ;
2561: LD_ADDR_OWVAR 42
2565: PUSH
2566: LD_INT 31
2568: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
2569: LD_INT 78
2571: PPUSH
2572: LD_INT 74
2574: PPUSH
2575: LD_INT 2
2577: PPUSH
2578: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
2582: LD_INT 171
2584: PPUSH
2585: LD_INT 193
2587: PPUSH
2588: LD_INT 4
2590: PPUSH
2591: CALL_OW 47
// bc_type := b_turret ;
2595: LD_ADDR_OWVAR 42
2599: PUSH
2600: LD_INT 33
2602: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
2603: LD_INT 129
2605: PPUSH
2606: LD_INT 96
2608: PPUSH
2609: LD_INT 3
2611: PPUSH
2612: CALL_OW 47
// if Difficulty > 2 then
2616: LD_OWVAR 67
2620: PUSH
2621: LD_INT 2
2623: GREATER
2624: IFFALSE 2695
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
2626: LD_INT 83
2628: PPUSH
2629: LD_INT 141
2631: PPUSH
2632: CALL_OW 428
2636: PPUSH
2637: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
2641: LD_INT 78
2643: PPUSH
2644: LD_INT 133
2646: PPUSH
2647: CALL_OW 428
2651: PPUSH
2652: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
2656: LD_INT 83
2658: PPUSH
2659: LD_INT 141
2661: PPUSH
2662: LD_INT 2
2664: PPUSH
2665: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
2669: LD_INT 78
2671: PPUSH
2672: LD_INT 133
2674: PPUSH
2675: LD_INT 2
2677: PPUSH
2678: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
2682: LD_INT 145
2684: PPUSH
2685: LD_INT 112
2687: PPUSH
2688: LD_INT 3
2690: PPUSH
2691: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
2695: LD_ADDR_VAR 0 9
2699: PUSH
2700: LD_INT 22
2702: PUSH
2703: LD_INT 3
2705: PUSH
2706: EMPTY
2707: LIST
2708: LIST
2709: PUSH
2710: LD_INT 2
2712: PUSH
2713: LD_INT 30
2715: PUSH
2716: LD_INT 0
2718: PUSH
2719: EMPTY
2720: LIST
2721: LIST
2722: PUSH
2723: LD_INT 30
2725: PUSH
2726: LD_INT 1
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: PUSH
2733: EMPTY
2734: LIST
2735: LIST
2736: LIST
2737: PUSH
2738: EMPTY
2739: LIST
2740: LIST
2741: PPUSH
2742: CALL_OW 69
2746: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
2747: LD_ADDR_VAR 0 10
2751: PUSH
2752: LD_INT 22
2754: PUSH
2755: LD_INT 3
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: PUSH
2762: LD_INT 2
2764: PUSH
2765: LD_INT 30
2767: PUSH
2768: LD_INT 6
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: PUSH
2775: LD_INT 30
2777: PUSH
2778: LD_INT 7
2780: PUSH
2781: EMPTY
2782: LIST
2783: LIST
2784: PUSH
2785: LD_INT 30
2787: PUSH
2788: LD_INT 8
2790: PUSH
2791: EMPTY
2792: LIST
2793: LIST
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: LIST
2799: LIST
2800: PUSH
2801: EMPTY
2802: LIST
2803: LIST
2804: PPUSH
2805: CALL_OW 69
2809: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
2810: LD_ADDR_VAR 0 11
2814: PUSH
2815: LD_INT 22
2817: PUSH
2818: LD_INT 3
2820: PUSH
2821: EMPTY
2822: LIST
2823: LIST
2824: PUSH
2825: LD_INT 30
2827: PUSH
2828: LD_INT 3
2830: PUSH
2831: EMPTY
2832: LIST
2833: LIST
2834: PUSH
2835: EMPTY
2836: LIST
2837: LIST
2838: PPUSH
2839: CALL_OW 69
2843: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
2844: LD_ADDR_VAR 0 12
2848: PUSH
2849: LD_INT 22
2851: PUSH
2852: LD_INT 3
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: PUSH
2859: LD_INT 30
2861: PUSH
2862: LD_INT 31
2864: PUSH
2865: EMPTY
2866: LIST
2867: LIST
2868: PUSH
2869: EMPTY
2870: LIST
2871: LIST
2872: PPUSH
2873: CALL_OW 69
2877: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
2878: LD_ADDR_VAR 0 13
2882: PUSH
2883: LD_INT 22
2885: PUSH
2886: LD_INT 3
2888: PUSH
2889: EMPTY
2890: LIST
2891: LIST
2892: PUSH
2893: LD_INT 30
2895: PUSH
2896: LD_INT 32
2898: PUSH
2899: EMPTY
2900: LIST
2901: LIST
2902: PUSH
2903: EMPTY
2904: LIST
2905: LIST
2906: PPUSH
2907: CALL_OW 69
2911: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
2912: LD_ADDR_VAR 0 14
2916: PUSH
2917: LD_INT 22
2919: PUSH
2920: LD_INT 3
2922: PUSH
2923: EMPTY
2924: LIST
2925: LIST
2926: PUSH
2927: LD_INT 30
2929: PUSH
2930: LD_INT 33
2932: PUSH
2933: EMPTY
2934: LIST
2935: LIST
2936: PUSH
2937: EMPTY
2938: LIST
2939: LIST
2940: PPUSH
2941: CALL_OW 69
2945: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
2946: LD_ADDR_VAR 0 15
2950: PUSH
2951: LD_INT 42
2953: PUSH
2954: LD_INT 5
2956: PUSH
2957: EMPTY
2958: LIST
2959: LIST
2960: PUSH
2961: LD_INT 43
2963: PUSH
2964: LD_INT 50
2966: PUSH
2967: EMPTY
2968: LIST
2969: LIST
2970: PUSH
2971: LD_INT 44
2973: PUSH
2974: LD_INT 30
2976: PUSH
2977: EMPTY
2978: LIST
2979: LIST
2980: PUSH
2981: LD_INT 46
2983: PUSH
2984: LD_INT 15
2986: PUSH
2987: EMPTY
2988: LIST
2989: LIST
2990: PUSH
2991: EMPTY
2992: LIST
2993: LIST
2994: LIST
2995: LIST
2996: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 4 , 3 ] ;
2997: LD_ADDR_VAR 0 16
3001: PUSH
3002: LD_INT 0
3004: PUSH
3005: LD_INT 4
3007: PUSH
3008: LD_INT 4
3010: PUSH
3011: LD_INT 3
3013: PUSH
3014: EMPTY
3015: LIST
3016: LIST
3017: LIST
3018: LIST
3019: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
3020: LD_ADDR_VAR 0 6
3024: PUSH
3025: LD_INT 4
3027: PUSH
3028: LD_INT 5
3030: PUSH
3031: LD_INT 6
3033: PUSH
3034: EMPTY
3035: LIST
3036: LIST
3037: LIST
3038: PUSH
3039: LD_OWVAR 67
3043: ARRAY
3044: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
3045: LD_INT 16
3047: PPUSH
3048: LD_STRING am_tukh
3050: PPUSH
3051: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
3055: LD_ADDR_VAR 0 2
3059: PUSH
3060: LD_INT 21
3062: PUSH
3063: LD_INT 3
3065: PUSH
3066: EMPTY
3067: LIST
3068: LIST
3069: PPUSH
3070: CALL_OW 69
3074: PUSH
3075: FOR_IN
3076: IFFALSE 3109
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
3078: LD_VAR 0 2
3082: PPUSH
3083: LD_INT 4
3085: PUSH
3086: LD_INT 5
3088: PUSH
3089: LD_INT 6
3091: PUSH
3092: EMPTY
3093: LIST
3094: LIST
3095: LIST
3096: PUSH
3097: LD_OWVAR 67
3101: ARRAY
3102: PPUSH
3103: CALL_OW 241
3107: GO 3075
3109: POP
3110: POP
// for i in dep_list do
3111: LD_ADDR_VAR 0 2
3115: PUSH
3116: LD_VAR 0 9
3120: PUSH
3121: FOR_IN
3122: IFFALSE 3166
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
3124: LD_VAR 0 2
3128: PPUSH
3129: CALL_OW 274
3133: PPUSH
3134: LD_INT 1
3136: PPUSH
3137: LD_INT 1000
3139: PPUSH
3140: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
3144: LD_VAR 0 2
3148: PPUSH
3149: CALL_OW 274
3153: PPUSH
3154: LD_INT 2
3156: PPUSH
3157: LD_INT 1000
3159: PPUSH
3160: CALL_OW 277
// end ;
3164: GO 3121
3166: POP
3167: POP
// InitHc ;
3168: CALL_OW 19
// tmp := bunker_list * [ 50 , 70 , 85 ] [ Difficulty ] div 100 ;
3172: LD_ADDR_VAR 0 8
3176: PUSH
3177: LD_VAR 0 13
3181: PUSH
3182: LD_INT 50
3184: PUSH
3185: LD_INT 70
3187: PUSH
3188: LD_INT 85
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: LIST
3195: PUSH
3196: LD_OWVAR 67
3200: ARRAY
3201: MUL
3202: PUSH
3203: LD_INT 100
3205: DIV
3206: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
3207: LD_ADDR_VAR 0 16
3211: PUSH
3212: LD_VAR 0 16
3216: PPUSH
3217: LD_INT 1
3219: PPUSH
3220: LD_VAR 0 8
3224: PPUSH
3225: CALL_OW 1
3229: ST_TO_ADDR
// tmp := [ ] ;
3230: LD_ADDR_VAR 0 8
3234: PUSH
3235: EMPTY
3236: ST_TO_ADDR
// for i in bunker_list do
3237: LD_ADDR_VAR 0 2
3241: PUSH
3242: LD_VAR 0 13
3246: PUSH
3247: FOR_IN
3248: IFFALSE 3344
// if i mod 10 + 1 < tmp then
3250: LD_VAR 0 2
3254: PUSH
3255: LD_INT 10
3257: MOD
3258: PUSH
3259: LD_INT 1
3261: PLUS
3262: PUSH
3263: LD_VAR 0 8
3267: LESS
3268: IFFALSE 3313
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
3270: LD_ADDR_VAR 0 8
3274: PUSH
3275: LD_VAR 0 8
3279: PPUSH
3280: LD_VAR 0 2
3284: PUSH
3285: LD_INT 3
3287: PPUSH
3288: LD_INT 5
3290: PPUSH
3291: CALL_OW 12
3295: MOD
3296: PUSH
3297: LD_INT 1
3299: PLUS
3300: PPUSH
3301: LD_VAR 0 2
3305: PPUSH
3306: CALL_OW 2
3310: ST_TO_ADDR
3311: GO 3342
// tmp := Insert ( tmp , tmp + 1 , i ) ;
3313: LD_ADDR_VAR 0 8
3317: PUSH
3318: LD_VAR 0 8
3322: PPUSH
3323: LD_VAR 0 8
3327: PUSH
3328: LD_INT 1
3330: PLUS
3331: PPUSH
3332: LD_VAR 0 2
3336: PPUSH
3337: CALL_OW 2
3341: ST_TO_ADDR
3342: GO 3247
3344: POP
3345: POP
// bunker_list := tmp ;
3346: LD_ADDR_VAR 0 13
3350: PUSH
3351: LD_VAR 0 8
3355: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
3356: LD_ADDR_VAR 0 2
3360: PUSH
3361: LD_VAR 0 13
3365: PUSH
3366: LD_VAR 0 14
3370: ADD
3371: PUSH
3372: FOR_IN
3373: IFFALSE 3470
// begin tmp := rand ( 0 , 100 ) ;
3375: LD_ADDR_VAR 0 8
3379: PUSH
3380: LD_INT 0
3382: PPUSH
3383: LD_INT 100
3385: PPUSH
3386: CALL_OW 12
3390: ST_TO_ADDR
// r := 0 ;
3391: LD_ADDR_VAR 0 4
3395: PUSH
3396: LD_INT 0
3398: ST_TO_ADDR
// for j in weapons_list do
3399: LD_ADDR_VAR 0 3
3403: PUSH
3404: LD_VAR 0 15
3408: PUSH
3409: FOR_IN
3410: IFFALSE 3466
// begin r := r + j [ 2 ] ;
3412: LD_ADDR_VAR 0 4
3416: PUSH
3417: LD_VAR 0 4
3421: PUSH
3422: LD_VAR 0 3
3426: PUSH
3427: LD_INT 2
3429: ARRAY
3430: PLUS
3431: ST_TO_ADDR
// if r >= tmp then
3432: LD_VAR 0 4
3436: PUSH
3437: LD_VAR 0 8
3441: GREATEREQUAL
3442: IFFALSE 3464
// begin PlaceWeaponTurret ( i , j [ 1 ] ) ;
3444: LD_VAR 0 2
3448: PPUSH
3449: LD_VAR 0 3
3453: PUSH
3454: LD_INT 1
3456: ARRAY
3457: PPUSH
3458: CALL_OW 431
// break ;
3462: GO 3466
// end ; end ;
3464: GO 3409
3466: POP
3467: POP
// end ;
3468: GO 3372
3470: POP
3471: POP
// while ( personel_counter [ 1 ] ) do
3472: LD_VAR 0 16
3476: PUSH
3477: LD_INT 1
3479: ARRAY
3480: IFFALSE 3588
// begin i := rand ( 1 , bunker_list ) ;
3482: LD_ADDR_VAR 0 2
3486: PUSH
3487: LD_INT 1
3489: PPUSH
3490: LD_VAR 0 13
3494: PPUSH
3495: CALL_OW 12
3499: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3500: LD_INT 0
3502: PPUSH
3503: LD_INT 1
3505: PPUSH
3506: LD_VAR 0 6
3510: PPUSH
3511: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
3515: CALL_OW 44
3519: PPUSH
3520: LD_VAR 0 13
3524: PUSH
3525: LD_VAR 0 2
3529: ARRAY
3530: PPUSH
3531: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
3535: LD_ADDR_VAR 0 13
3539: PUSH
3540: LD_VAR 0 13
3544: PPUSH
3545: LD_VAR 0 2
3549: PPUSH
3550: CALL_OW 3
3554: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
3555: LD_ADDR_VAR 0 16
3559: PUSH
3560: LD_VAR 0 16
3564: PPUSH
3565: LD_INT 1
3567: PPUSH
3568: LD_VAR 0 16
3572: PUSH
3573: LD_INT 1
3575: ARRAY
3576: PUSH
3577: LD_INT 1
3579: MINUS
3580: PPUSH
3581: CALL_OW 1
3585: ST_TO_ADDR
// end ;
3586: GO 3472
// for i = 1 to personel_counter [ 2 ] do
3588: LD_ADDR_VAR 0 2
3592: PUSH
3593: DOUBLE
3594: LD_INT 1
3596: DEC
3597: ST_TO_ADDR
3598: LD_VAR 0 16
3602: PUSH
3603: LD_INT 2
3605: ARRAY
3606: PUSH
3607: FOR_TO
3608: IFFALSE 3639
// begin PrepareHuman ( false , 2 , skill ) ;
3610: LD_INT 0
3612: PPUSH
3613: LD_INT 2
3615: PPUSH
3616: LD_VAR 0 6
3620: PPUSH
3621: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
3625: CALL_OW 44
3629: PPUSH
3630: LD_INT 16
3632: PPUSH
3633: CALL_OW 52
// end ;
3637: GO 3607
3639: POP
3640: POP
// for i = 1 to personel_counter [ 3 ] do
3641: LD_ADDR_VAR 0 2
3645: PUSH
3646: DOUBLE
3647: LD_INT 1
3649: DEC
3650: ST_TO_ADDR
3651: LD_VAR 0 16
3655: PUSH
3656: LD_INT 3
3658: ARRAY
3659: PUSH
3660: FOR_TO
3661: IFFALSE 3698
// begin PrepareHuman ( false , 3 , skill ) ;
3663: LD_INT 0
3665: PPUSH
3666: LD_INT 3
3668: PPUSH
3669: LD_VAR 0 6
3673: PPUSH
3674: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ 1 ] ) ;
3678: CALL_OW 44
3682: PPUSH
3683: LD_VAR 0 11
3687: PUSH
3688: LD_INT 1
3690: ARRAY
3691: PPUSH
3692: CALL_OW 52
// end ;
3696: GO 3660
3698: POP
3699: POP
// for i = 1 to personel_counter [ 4 ] do
3700: LD_ADDR_VAR 0 2
3704: PUSH
3705: DOUBLE
3706: LD_INT 1
3708: DEC
3709: ST_TO_ADDR
3710: LD_VAR 0 16
3714: PUSH
3715: LD_INT 4
3717: ARRAY
3718: PUSH
3719: FOR_TO
3720: IFFALSE 3757
// begin PrepareHuman ( false , 4 , skill ) ;
3722: LD_INT 0
3724: PPUSH
3725: LD_INT 4
3727: PPUSH
3728: LD_VAR 0 6
3732: PPUSH
3733: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
3737: CALL_OW 44
3741: PPUSH
3742: LD_VAR 0 10
3746: PUSH
3747: LD_INT 1
3749: ARRAY
3750: PPUSH
3751: CALL_OW 52
// end ;
3755: GO 3719
3757: POP
3758: POP
// for i in breastworks_list do
3759: LD_ADDR_VAR 0 2
3763: PUSH
3764: LD_VAR 0 12
3768: PUSH
3769: FOR_IN
3770: IFFALSE 3882
// begin r := GetDir ( i ) ;
3772: LD_ADDR_VAR 0 4
3776: PUSH
3777: LD_VAR 0 2
3781: PPUSH
3782: CALL_OW 254
3786: ST_TO_ADDR
// if r > 3 then
3787: LD_VAR 0 4
3791: PUSH
3792: LD_INT 3
3794: GREATER
3795: IFFALSE 3813
// r := r - 3 else
3797: LD_ADDR_VAR 0 4
3801: PUSH
3802: LD_VAR 0 4
3806: PUSH
3807: LD_INT 3
3809: MINUS
3810: ST_TO_ADDR
3811: GO 3827
// r := r + 3 ;
3813: LD_ADDR_VAR 0 4
3817: PUSH
3818: LD_VAR 0 4
3822: PUSH
3823: LD_INT 3
3825: PLUS
3826: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3827: LD_INT 0
3829: PPUSH
3830: LD_INT 1
3832: PPUSH
3833: LD_VAR 0 6
3837: PPUSH
3838: CALL_OW 380
// un := CreateHuman ;
3842: LD_ADDR_VAR 0 5
3846: PUSH
3847: CALL_OW 44
3851: ST_TO_ADDR
// SetDir ( un , r ) ;
3852: LD_VAR 0 5
3856: PPUSH
3857: LD_VAR 0 4
3861: PPUSH
3862: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3866: LD_VAR 0 5
3870: PPUSH
3871: LD_VAR 0 2
3875: PPUSH
3876: CALL_OW 52
// end ;
3880: GO 3769
3882: POP
3883: POP
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
3884: LD_ADDR_VAR 0 4
3888: PUSH
3889: LD_INT 4
3891: PUSH
3892: LD_INT 5
3894: PUSH
3895: LD_INT 6
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: LIST
3902: PUSH
3903: LD_OWVAR 67
3907: ARRAY
3908: ST_TO_ADDR
// for i = 1 to r do
3909: LD_ADDR_VAR 0 2
3913: PUSH
3914: DOUBLE
3915: LD_INT 1
3917: DEC
3918: ST_TO_ADDR
3919: LD_VAR 0 4
3923: PUSH
3924: FOR_TO
3925: IFFALSE 4020
// begin un := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
3927: LD_ADDR_VAR 0 5
3931: PUSH
3932: LD_INT 3
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 22
3940: PPUSH
3941: LD_INT 1
3943: PPUSH
3944: LD_INT 1
3946: PPUSH
3947: LD_INT 43
3949: PUSH
3950: LD_INT 44
3952: PUSH
3953: LD_INT 42
3955: PUSH
3956: EMPTY
3957: LIST
3958: LIST
3959: LIST
3960: PUSH
3961: LD_VAR 0 2
3965: PUSH
3966: LD_INT 3
3968: MOD
3969: PUSH
3970: LD_INT 1
3972: PLUS
3973: ARRAY
3974: PPUSH
3975: LD_INT 100
3977: PPUSH
3978: CALL 330 0 7
3982: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3983: LD_VAR 0 5
3987: PPUSH
3988: LD_INT 0
3990: PPUSH
3991: LD_INT 5
3993: PPUSH
3994: CALL_OW 12
3998: PPUSH
3999: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
4003: LD_VAR 0 5
4007: PPUSH
4008: LD_INT 5
4010: PPUSH
4011: LD_INT 0
4013: PPUSH
4014: CALL_OW 49
// end ;
4018: GO 3924
4020: POP
4021: POP
// end ;
4022: LD_VAR 0 1
4026: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_ok ] ] ) do var i , filter , tmp , engs , enemy ;
4027: LD_INT 22
4029: PUSH
4030: LD_INT 3
4032: PUSH
4033: EMPTY
4034: LIST
4035: LIST
4036: PUSH
4037: LD_INT 25
4039: PUSH
4040: LD_INT 2
4042: PUSH
4043: EMPTY
4044: LIST
4045: LIST
4046: PUSH
4047: LD_INT 50
4049: PUSH
4050: EMPTY
4051: LIST
4052: PUSH
4053: EMPTY
4054: LIST
4055: LIST
4056: LIST
4057: PPUSH
4058: CALL_OW 69
4062: IFFALSE 4758
4064: GO 4066
4066: DISABLE
4067: LD_INT 0
4069: PPUSH
4070: PPUSH
4071: PPUSH
4072: PPUSH
4073: PPUSH
// begin enable ;
4074: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
4075: LD_ADDR_VAR 0 2
4079: PUSH
4080: LD_INT 6
4082: PPUSH
4083: LD_INT 3
4085: PUSH
4086: LD_INT 24
4088: PUSH
4089: LD_INT 1000
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: PUSH
4096: EMPTY
4097: LIST
4098: LIST
4099: PUSH
4100: LD_INT 21
4102: PUSH
4103: LD_INT 3
4105: PUSH
4106: EMPTY
4107: LIST
4108: LIST
4109: PUSH
4110: EMPTY
4111: LIST
4112: LIST
4113: PPUSH
4114: CALL_OW 70
4118: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_lives , 650 ] ] ) ;
4119: LD_ADDR_VAR 0 4
4123: PUSH
4124: LD_INT 22
4126: PUSH
4127: LD_INT 3
4129: PUSH
4130: EMPTY
4131: LIST
4132: LIST
4133: PUSH
4134: LD_INT 25
4136: PUSH
4137: LD_INT 2
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: PUSH
4144: LD_INT 24
4146: PUSH
4147: LD_INT 650
4149: PUSH
4150: EMPTY
4151: LIST
4152: LIST
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: LIST
4158: PPUSH
4159: CALL_OW 69
4163: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
4164: LD_VAR 0 2
4168: NOT
4169: PUSH
4170: LD_EXP 18
4174: NOT
4175: AND
4176: IFFALSE 4208
// begin if not IsInUnit ( engs [ 1 ] ) then
4178: LD_VAR 0 4
4182: PUSH
4183: LD_INT 1
4185: ARRAY
4186: PPUSH
4187: CALL_OW 310
4191: NOT
4192: IFFALSE 4206
// ComEnterUnit ( engs , ru_dep_main ) ;
4194: LD_VAR 0 4
4198: PPUSH
4199: LD_INT 16
4201: PPUSH
4202: CALL_OW 120
// exit ;
4206: GO 4758
// end ; if debug then
4208: LD_EXP 1
4212: IFFALSE 4233
// display_strings := [ engs , filter ] ;
4214: LD_ADDR_OWVAR 47
4218: PUSH
4219: LD_VAR 0 4
4223: PUSH
4224: LD_VAR 0 2
4228: PUSH
4229: EMPTY
4230: LIST
4231: LIST
4232: ST_TO_ADDR
// if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
4233: LD_VAR 0 4
4237: PPUSH
4238: LD_INT 3
4240: PUSH
4241: LD_INT 24
4243: PUSH
4244: LD_INT 650
4246: PUSH
4247: EMPTY
4248: LIST
4249: LIST
4250: PUSH
4251: EMPTY
4252: LIST
4253: LIST
4254: PPUSH
4255: CALL_OW 72
4259: IFFALSE 4352
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
4261: LD_ADDR_VAR 0 3
4265: PUSH
4266: LD_VAR 0 4
4270: PPUSH
4271: LD_INT 3
4273: PUSH
4274: LD_INT 24
4276: PUSH
4277: LD_INT 650
4279: PUSH
4280: EMPTY
4281: LIST
4282: LIST
4283: PUSH
4284: EMPTY
4285: LIST
4286: LIST
4287: PPUSH
4288: CALL_OW 72
4292: ST_TO_ADDR
// for i in tmp do
4293: LD_ADDR_VAR 0 1
4297: PUSH
4298: LD_VAR 0 3
4302: PUSH
4303: FOR_IN
4304: IFFALSE 4350
// if not IsInArea ( i , mainBaseArea ) then
4306: LD_VAR 0 1
4310: PPUSH
4311: LD_INT 14
4313: PPUSH
4314: CALL_OW 308
4318: NOT
4319: IFFALSE 4348
// begin ComMoveXY ( i , 129 , 125 ) ;
4321: LD_VAR 0 1
4325: PPUSH
4326: LD_INT 129
4328: PPUSH
4329: LD_INT 125
4331: PPUSH
4332: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
4336: LD_VAR 0 1
4340: PPUSH
4341: LD_INT 1050
4343: PPUSH
4344: CALL_OW 202
// end ;
4348: GO 4303
4350: POP
4351: POP
// end ; if filter then
4352: LD_VAR 0 2
4356: IFFALSE 4615
// begin for i in engs do
4358: LD_ADDR_VAR 0 1
4362: PUSH
4363: LD_VAR 0 4
4367: PUSH
4368: FOR_IN
4369: IFFALSE 4393
// if IsInUnit ( i ) then
4371: LD_VAR 0 1
4375: PPUSH
4376: CALL_OW 310
4380: IFFALSE 4391
// ComExitBuilding ( i ) ;
4382: LD_VAR 0 1
4386: PPUSH
4387: CALL_OW 122
4391: GO 4368
4393: POP
4394: POP
// wait ( 3 ) ;
4395: LD_INT 3
4397: PPUSH
4398: CALL_OW 67
// if filter >= 2 and engs >= 2 then
4402: LD_VAR 0 2
4406: PUSH
4407: LD_INT 2
4409: GREATEREQUAL
4410: PUSH
4411: LD_VAR 0 4
4415: PUSH
4416: LD_INT 2
4418: GREATEREQUAL
4419: AND
4420: IFFALSE 4568
// begin for i = 1 to engs / 2 do
4422: LD_ADDR_VAR 0 1
4426: PUSH
4427: DOUBLE
4428: LD_INT 1
4430: DEC
4431: ST_TO_ADDR
4432: LD_VAR 0 4
4436: PUSH
4437: LD_INT 2
4439: DIVREAL
4440: PUSH
4441: FOR_TO
4442: IFFALSE 4488
// if not HasTask ( engs [ i ] ) then
4444: LD_VAR 0 4
4448: PUSH
4449: LD_VAR 0 1
4453: ARRAY
4454: PPUSH
4455: CALL_OW 314
4459: NOT
4460: IFFALSE 4486
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
4462: LD_VAR 0 4
4466: PUSH
4467: LD_VAR 0 1
4471: ARRAY
4472: PPUSH
4473: LD_VAR 0 2
4477: PUSH
4478: LD_INT 1
4480: ARRAY
4481: PPUSH
4482: CALL_OW 130
4486: GO 4441
4488: POP
4489: POP
// for i = engs / 2 + 1 to engs do
4490: LD_ADDR_VAR 0 1
4494: PUSH
4495: DOUBLE
4496: LD_VAR 0 4
4500: PUSH
4501: LD_INT 2
4503: DIVREAL
4504: PUSH
4505: LD_INT 1
4507: PLUS
4508: DEC
4509: ST_TO_ADDR
4510: LD_VAR 0 4
4514: PUSH
4515: FOR_TO
4516: IFFALSE 4564
// if not HasTask ( engs [ i ] ) then
4518: LD_VAR 0 4
4522: PUSH
4523: LD_VAR 0 1
4527: ARRAY
4528: PPUSH
4529: CALL_OW 314
4533: NOT
4534: IFFALSE 4562
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
4536: LD_VAR 0 4
4540: PUSH
4541: LD_VAR 0 1
4545: ARRAY
4546: PPUSH
4547: LD_VAR 0 2
4551: PUSH
4552: LD_VAR 0 2
4556: ARRAY
4557: PPUSH
4558: CALL_OW 130
4562: GO 4515
4564: POP
4565: POP
// end else
4566: GO 4615
// for i in engs do
4568: LD_ADDR_VAR 0 1
4572: PUSH
4573: LD_VAR 0 4
4577: PUSH
4578: FOR_IN
4579: IFFALSE 4613
// if not HasTask ( i ) then
4581: LD_VAR 0 1
4585: PPUSH
4586: CALL_OW 314
4590: NOT
4591: IFFALSE 4611
// ComRepairBuilding ( i , filter [ 1 ] ) ;
4593: LD_VAR 0 1
4597: PPUSH
4598: LD_VAR 0 2
4602: PUSH
4603: LD_INT 1
4605: ARRAY
4606: PPUSH
4607: CALL_OW 130
4611: GO 4578
4613: POP
4614: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
4615: LD_ADDR_VAR 0 5
4619: PUSH
4620: LD_INT 81
4622: PUSH
4623: LD_INT 3
4625: PUSH
4626: EMPTY
4627: LIST
4628: LIST
4629: PPUSH
4630: CALL_OW 69
4634: ST_TO_ADDR
// if ru_rebuild_list and not filter then
4635: LD_EXP 18
4639: PUSH
4640: LD_VAR 0 2
4644: NOT
4645: AND
4646: IFFALSE 4758
// begin ComExitBuilding ( engs ) ;
4648: LD_VAR 0 4
4652: PPUSH
4653: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
4657: LD_VAR 0 5
4661: PPUSH
4662: LD_EXP 18
4666: PUSH
4667: LD_INT 2
4669: ARRAY
4670: PPUSH
4671: LD_EXP 18
4675: PUSH
4676: LD_INT 3
4678: ARRAY
4679: PPUSH
4680: CALL_OW 73
4684: PPUSH
4685: LD_EXP 18
4689: PUSH
4690: LD_INT 2
4692: ARRAY
4693: PPUSH
4694: LD_EXP 18
4698: PUSH
4699: LD_INT 3
4701: ARRAY
4702: PPUSH
4703: CALL_OW 297
4707: PUSH
4708: LD_INT 10
4710: GREATER
4711: IFFALSE 4758
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
4713: LD_VAR 0 4
4717: PPUSH
4718: LD_EXP 18
4722: PUSH
4723: LD_INT 1
4725: ARRAY
4726: PPUSH
4727: LD_EXP 18
4731: PUSH
4732: LD_INT 2
4734: ARRAY
4735: PPUSH
4736: LD_EXP 18
4740: PUSH
4741: LD_INT 3
4743: ARRAY
4744: PPUSH
4745: LD_EXP 18
4749: PUSH
4750: LD_INT 4
4752: ARRAY
4753: PPUSH
4754: CALL_OW 145
// end ; end ;
4758: PPOPN 5
4760: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 650 do var tmp ;
4761: LD_INT 16
4763: PPUSH
4764: CALL_OW 256
4768: PUSH
4769: LD_INT 650
4771: LESS
4772: IFFALSE 4855
4774: GO 4776
4776: DISABLE
4777: LD_INT 0
4779: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
4780: LD_ADDR_VAR 0 1
4784: PUSH
4785: LD_INT 22
4787: PUSH
4788: LD_INT 3
4790: PUSH
4791: EMPTY
4792: LIST
4793: LIST
4794: PUSH
4795: LD_INT 25
4797: PUSH
4798: LD_INT 1
4800: PUSH
4801: EMPTY
4802: LIST
4803: LIST
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: PPUSH
4809: CALL_OW 69
4813: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
4814: LD_VAR 0 1
4818: PPUSH
4819: CALL_OW 122
// wait ( 3 ) ;
4823: LD_INT 3
4825: PPUSH
4826: CALL_OW 67
// ComAgressiveMove ( tmp , GetX ( ru_dep_main ) , GetY ( ru_dep_main ) ) ;
4830: LD_VAR 0 1
4834: PPUSH
4835: LD_INT 16
4837: PPUSH
4838: CALL_OW 250
4842: PPUSH
4843: LD_INT 16
4845: PPUSH
4846: CALL_OW 251
4850: PPUSH
4851: CALL_OW 114
// end ;
4855: PPOPN 1
4857: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
4858: LD_INT 22
4860: PUSH
4861: LD_INT 3
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PUSH
4868: LD_INT 25
4870: PUSH
4871: LD_INT 4
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: PPUSH
4882: CALL_OW 69
4886: IFFALSE 5120
4888: GO 4890
4890: DISABLE
4891: LD_INT 0
4893: PPUSH
4894: PPUSH
4895: PPUSH
// begin enable ;
4896: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4897: LD_ADDR_VAR 0 2
4901: PUSH
4902: LD_INT 14
4904: PPUSH
4905: LD_INT 21
4907: PUSH
4908: LD_INT 1
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PUSH
4915: LD_INT 3
4917: PUSH
4918: LD_INT 24
4920: PUSH
4921: LD_INT 1000
4923: PUSH
4924: EMPTY
4925: LIST
4926: LIST
4927: PUSH
4928: EMPTY
4929: LIST
4930: LIST
4931: PUSH
4932: EMPTY
4933: LIST
4934: LIST
4935: PPUSH
4936: CALL_OW 70
4940: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
4941: LD_ADDR_VAR 0 3
4945: PUSH
4946: LD_INT 22
4948: PUSH
4949: LD_INT 3
4951: PUSH
4952: EMPTY
4953: LIST
4954: LIST
4955: PUSH
4956: LD_INT 25
4958: PUSH
4959: LD_INT 4
4961: PUSH
4962: EMPTY
4963: LIST
4964: LIST
4965: PUSH
4966: EMPTY
4967: LIST
4968: LIST
4969: PPUSH
4970: CALL_OW 69
4974: ST_TO_ADDR
// if not tmp and not IsInUnit ( doc [ 1 ] ) then
4975: LD_VAR 0 2
4979: NOT
4980: PUSH
4981: LD_VAR 0 3
4985: PUSH
4986: LD_INT 1
4988: ARRAY
4989: PPUSH
4990: CALL_OW 310
4994: NOT
4995: AND
4996: IFFALSE 5071
// begin ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
4998: LD_VAR 0 3
5002: PPUSH
5003: LD_INT 22
5005: PUSH
5006: LD_INT 3
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 2
5015: PUSH
5016: LD_INT 30
5018: PUSH
5019: LD_INT 6
5021: PUSH
5022: EMPTY
5023: LIST
5024: LIST
5025: PUSH
5026: LD_INT 30
5028: PUSH
5029: LD_INT 7
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PUSH
5036: LD_INT 30
5038: PUSH
5039: LD_INT 8
5041: PUSH
5042: EMPTY
5043: LIST
5044: LIST
5045: PUSH
5046: EMPTY
5047: LIST
5048: LIST
5049: LIST
5050: LIST
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: PPUSH
5056: CALL_OW 69
5060: PUSH
5061: LD_INT 1
5063: ARRAY
5064: PPUSH
5065: CALL_OW 120
// exit ;
5069: GO 5120
// end ; if IsInUnit ( doc [ 1 ] ) then
5071: LD_VAR 0 3
5075: PUSH
5076: LD_INT 1
5078: ARRAY
5079: PPUSH
5080: CALL_OW 310
5084: IFFALSE 5095
// ComExitBuilding ( doc ) ;
5086: LD_VAR 0 3
5090: PPUSH
5091: CALL_OW 122
// wait ( 3 ) ;
5095: LD_INT 3
5097: PPUSH
5098: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
5102: LD_VAR 0 3
5106: PPUSH
5107: LD_VAR 0 2
5111: PUSH
5112: LD_INT 1
5114: ARRAY
5115: PPUSH
5116: CALL_OW 128
// end ; end_of_file
5120: PPOPN 3
5122: END
// export function Action ; begin
5123: LD_INT 0
5125: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
5126: LD_INT 28
5128: PPUSH
5129: LD_INT 3
5131: PPUSH
5132: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
5136: LD_INT 41
5138: PPUSH
5139: LD_INT 76
5141: PPUSH
5142: LD_INT 1
5144: PPUSH
5145: LD_INT 10
5147: PPUSH
5148: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
5152: LD_INT 41
5154: PPUSH
5155: LD_INT 76
5157: PPUSH
5158: LD_INT 1
5160: PPUSH
5161: CALL_OW 331
// InGameOn ;
5165: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
5169: LD_EXP 17
5173: PPUSH
5174: LD_STRING D2-Har-1
5176: PPUSH
5177: CALL_OW 94
// InGameOff ;
5181: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
5185: LD_STRING M1
5187: PPUSH
5188: CALL_OW 337
// end ;
5192: LD_VAR 0 1
5196: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
5197: LD_EXP 4
5201: PUSH
5202: LD_INT 1
5204: GREATER
5205: IFFALSE 5296
5207: GO 5209
5209: DISABLE
5210: LD_INT 0
5212: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
5213: LD_ADDR_VAR 0 1
5217: PUSH
5218: LD_INT 1
5220: PPUSH
5221: CALL 418 0 1
5225: PUSH
5226: LD_INT 1
5228: ARRAY
5229: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
5230: LD_VAR 0 1
5234: PPUSH
5235: LD_STRING D2a-Sol1-1
5237: PPUSH
5238: CALL_OW 88
// if not un then
5242: LD_VAR 0 1
5246: NOT
5247: IFFALSE 5278
// begin un := GetRandom ( sex_female ) [ 1 ] ;
5249: LD_ADDR_VAR 0 1
5253: PUSH
5254: LD_INT 2
5256: PPUSH
5257: CALL 418 0 1
5261: PUSH
5262: LD_INT 1
5264: ARRAY
5265: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
5266: LD_VAR 0 1
5270: PPUSH
5271: LD_STRING D2a-FSol1-1
5273: PPUSH
5274: CALL_OW 88
// end ; if Khatam then
5278: LD_EXP 15
5282: IFFALSE 5296
// Say ( Khatam , D3b-Khat-3 ) ;
5284: LD_EXP 15
5288: PPUSH
5289: LD_STRING D3b-Khat-3
5291: PPUSH
5292: CALL_OW 88
// end ;
5296: PPOPN 1
5298: END
// every 0 0$1 trigger Frank and GetDistUnits ( JMM , Frank ) < 5 and not InBattle ( 1 ) do var i , ape ;
5299: LD_EXP 13
5303: PUSH
5304: LD_EXP 7
5308: PPUSH
5309: LD_EXP 13
5313: PPUSH
5314: CALL_OW 296
5318: PUSH
5319: LD_INT 5
5321: LESS
5322: AND
5323: PUSH
5324: LD_INT 1
5326: PPUSH
5327: CALL_OW 463
5331: NOT
5332: AND
5333: IFFALSE 5920
5335: GO 5337
5337: DISABLE
5338: LD_INT 0
5340: PPUSH
5341: PPUSH
// begin InGameOn ;
5342: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
5346: LD_ADDR_VAR 0 2
5350: PUSH
5351: LD_INT 22
5353: PUSH
5354: LD_INT 0
5356: PUSH
5357: EMPTY
5358: LIST
5359: LIST
5360: PUSH
5361: LD_INT 25
5363: PUSH
5364: LD_INT 12
5366: PUSH
5367: EMPTY
5368: LIST
5369: LIST
5370: PUSH
5371: EMPTY
5372: LIST
5373: LIST
5374: PPUSH
5375: CALL_OW 69
5379: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
5380: LD_ADDR_VAR 0 2
5384: PUSH
5385: LD_VAR 0 2
5389: PPUSH
5390: LD_EXP 13
5394: PPUSH
5395: CALL_OW 74
5399: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
5400: LD_ADDR_VAR 0 1
5404: PUSH
5405: LD_INT 22
5407: PUSH
5408: LD_INT 1
5410: PUSH
5411: EMPTY
5412: LIST
5413: LIST
5414: PUSH
5415: LD_INT 21
5417: PUSH
5418: LD_INT 1
5420: PUSH
5421: EMPTY
5422: LIST
5423: LIST
5424: PUSH
5425: LD_INT 91
5427: PUSH
5428: LD_EXP 13
5432: PUSH
5433: LD_INT 20
5435: PUSH
5436: EMPTY
5437: LIST
5438: LIST
5439: LIST
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: LIST
5445: PPUSH
5446: CALL_OW 69
5450: PUSH
5451: FOR_IN
5452: IFFALSE 5470
// ComTurnUnit ( i , Frank ) ;
5454: LD_VAR 0 1
5458: PPUSH
5459: LD_EXP 13
5463: PPUSH
5464: CALL_OW 119
5468: GO 5451
5470: POP
5471: POP
// SetSide ( Frank , 1 ) ;
5472: LD_EXP 13
5476: PPUSH
5477: LD_INT 1
5479: PPUSH
5480: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
5484: LD_EXP 7
5488: PPUSH
5489: LD_EXP 13
5493: PPUSH
5494: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
5498: LD_EXP 7
5502: PPUSH
5503: LD_EXP 13
5507: PPUSH
5508: CALL_OW 179
// CenterOnUnits ( Frank ) ;
5512: LD_EXP 13
5516: PPUSH
5517: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
5521: LD_EXP 13
5525: PPUSH
5526: LD_STRING D3a-Frank-1
5528: PPUSH
5529: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
5533: LD_VAR 0 2
5537: PPUSH
5538: LD_INT 42
5540: PPUSH
5541: LD_INT 78
5543: PPUSH
5544: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
5548: LD_VAR 0 2
5552: PPUSH
5553: LD_EXP 13
5557: PPUSH
5558: CALL_OW 179
// if Lisa then
5562: LD_EXP 12
5566: IFFALSE 5580
// Say ( Lisa , D3a-Lisa-1 ) ;
5568: LD_EXP 12
5572: PPUSH
5573: LD_STRING D3a-Lisa-1
5575: PPUSH
5576: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
5580: LD_EXP 7
5584: PPUSH
5585: LD_STRING D3a-JMM-1
5587: PPUSH
5588: CALL_OW 88
// if Cyrus then
5592: LD_EXP 11
5596: IFFALSE 5610
// Say ( Cyrus , D3a-Cyrus-1 ) ;
5598: LD_EXP 11
5602: PPUSH
5603: LD_STRING D3a-Cyrus-1
5605: PPUSH
5606: CALL_OW 88
// if GetRandom ( sex_male ) then
5610: LD_INT 1
5612: PPUSH
5613: CALL 418 0 1
5617: IFFALSE 5638
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
5619: LD_INT 1
5621: PPUSH
5622: CALL 418 0 1
5626: PUSH
5627: LD_INT 1
5629: ARRAY
5630: PPUSH
5631: LD_STRING D3a-Sol1-1
5633: PPUSH
5634: CALL_OW 88
// if GetRandom ( sex_female ) then
5638: LD_INT 2
5640: PPUSH
5641: CALL 418 0 1
5645: IFFALSE 5666
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
5647: LD_INT 2
5649: PPUSH
5650: CALL 418 0 1
5654: PUSH
5655: LD_INT 1
5657: ARRAY
5658: PPUSH
5659: LD_STRING D3a-FSol1-1
5661: PPUSH
5662: CALL_OW 88
// if Gladstone then
5666: LD_EXP 14
5670: IFFALSE 5684
// Say ( Gladstone , D3a-Glad-1 ) ;
5672: LD_EXP 14
5676: PPUSH
5677: LD_STRING D3a-Glad-1
5679: PPUSH
5680: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
5684: LD_VAR 0 2
5688: PPUSH
5689: LD_INT 60
5691: PPUSH
5692: LD_INT 113
5694: PPUSH
5695: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
5699: LD_EXP 13
5703: PPUSH
5704: LD_STRING D3a-Frank-2
5706: PPUSH
5707: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
5711: LD_EXP 13
5715: PPUSH
5716: LD_EXP 7
5720: PPUSH
5721: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
5725: LD_EXP 7
5729: PPUSH
5730: LD_STRING D3a-JMM-2
5732: PPUSH
5733: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
5737: LD_INT 1
5739: PPUSH
5740: LD_INT 4
5742: PPUSH
5743: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
5747: LD_INT 85
5749: PPUSH
5750: LD_INT 134
5752: PPUSH
5753: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
5757: LD_EXP 13
5761: PPUSH
5762: LD_STRING D3a-Frank-3
5764: PPUSH
5765: CALL_OW 88
// Wait ( 0 0$01 ) ;
5769: LD_INT 35
5771: PPUSH
5772: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
5776: LD_INT 166
5778: PPUSH
5779: LD_INT 136
5781: PPUSH
5782: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
5786: LD_EXP 7
5790: PPUSH
5791: LD_STRING D3a-JMM-3
5793: PPUSH
5794: CALL_OW 88
// Wait ( 0 0$01 ) ;
5798: LD_INT 35
5800: PPUSH
5801: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
5805: LD_EXP 13
5809: PPUSH
5810: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
5814: LD_EXP 13
5818: PPUSH
5819: LD_STRING D3a-Frank-4
5821: PPUSH
5822: CALL_OW 88
// if Lisa then
5826: LD_EXP 12
5830: IFFALSE 5844
// Say ( Lisa , D3a-Lisa-4 ) ;
5832: LD_EXP 12
5836: PPUSH
5837: LD_STRING D3a-Lisa-4
5839: PPUSH
5840: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
5844: LD_EXP 7
5848: PPUSH
5849: LD_STRING D3a-JMM-4
5851: PPUSH
5852: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
5856: LD_EXP 13
5860: PPUSH
5861: LD_STRING D3a-Frank-5
5863: PPUSH
5864: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
5868: LD_EXP 7
5872: PPUSH
5873: LD_STRING D3a-JMM-5
5875: PPUSH
5876: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
5880: LD_EXP 13
5884: PPUSH
5885: LD_STRING D3a-Frank-6
5887: PPUSH
5888: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
5892: LD_EXP 7
5896: PPUSH
5897: LD_STRING D3a-JMM-6
5899: PPUSH
5900: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
5904: LD_EXP 13
5908: PPUSH
5909: LD_STRING D3a-Frank-7
5911: PPUSH
5912: CALL_OW 88
// InGameOff ;
5916: CALL_OW 9
// end ;
5920: PPOPN 2
5922: END
// every 0 0$1 trigger Kikuchi and GetDistUnits ( JMM , Kikuchi ) < 5 and not InBattle ( 1 ) do
5923: LD_EXP 16
5927: PUSH
5928: LD_EXP 7
5932: PPUSH
5933: LD_EXP 16
5937: PPUSH
5938: CALL_OW 296
5942: PUSH
5943: LD_INT 5
5945: LESS
5946: AND
5947: PUSH
5948: LD_INT 1
5950: PPUSH
5951: CALL_OW 463
5955: NOT
5956: AND
5957: IFFALSE 6137
5959: GO 5961
5961: DISABLE
// begin InGameOn ;
5962: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
5966: LD_EXP 7
5970: PPUSH
5971: LD_EXP 16
5975: PPUSH
5976: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
5980: LD_EXP 16
5984: PPUSH
5985: LD_EXP 7
5989: PPUSH
5990: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
5994: LD_EXP 16
5998: PPUSH
5999: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
6003: LD_EXP 16
6007: PPUSH
6008: LD_STRING D3b-Yam-1
6010: PPUSH
6011: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
6015: LD_EXP 7
6019: PPUSH
6020: LD_STRING D3b-JMM-1
6022: PPUSH
6023: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
6027: LD_INT 1
6029: PPUSH
6030: LD_INT 4
6032: PPUSH
6033: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
6037: LD_INT 85
6039: PPUSH
6040: LD_INT 134
6042: PPUSH
6043: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
6047: LD_EXP 16
6051: PPUSH
6052: LD_STRING D3b-Yam-2
6054: PPUSH
6055: CALL_OW 88
// Wait ( 0 0$01 ) ;
6059: LD_INT 35
6061: PPUSH
6062: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
6066: LD_EXP 7
6070: PPUSH
6071: LD_STRING D3b-JMM-2
6073: PPUSH
6074: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
6078: LD_INT 166
6080: PPUSH
6081: LD_INT 136
6083: PPUSH
6084: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
6088: LD_EXP 16
6092: PPUSH
6093: LD_STRING D3b-Yam-3
6095: PPUSH
6096: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
6100: LD_EXP 7
6104: PPUSH
6105: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
6109: LD_EXP 7
6113: PPUSH
6114: LD_STRING D3b-JMM-3a
6116: PPUSH
6117: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
6121: LD_EXP 16
6125: PPUSH
6126: LD_INT 1
6128: PPUSH
6129: CALL_OW 235
// InGameOff ;
6133: CALL_OW 9
// end ;
6137: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , i ;
6138: LD_INT 7
6140: PPUSH
6141: LD_INT 22
6143: PUSH
6144: LD_INT 1
6146: PUSH
6147: EMPTY
6148: LIST
6149: LIST
6150: PUSH
6151: LD_INT 3
6153: PUSH
6154: LD_INT 24
6156: PUSH
6157: LD_INT 1000
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: PPUSH
6172: CALL_OW 70
6176: IFFALSE 6594
6178: GO 6180
6180: DISABLE
6181: LD_INT 0
6183: PPUSH
6184: PPUSH
6185: PPUSH
// begin un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) [ 1 ] ;
6186: LD_ADDR_VAR 0 1
6190: PUSH
6191: LD_INT 7
6193: PPUSH
6194: LD_INT 22
6196: PUSH
6197: LD_INT 1
6199: PUSH
6200: EMPTY
6201: LIST
6202: LIST
6203: PUSH
6204: LD_INT 3
6206: PUSH
6207: LD_INT 24
6209: PUSH
6210: LD_INT 1000
6212: PUSH
6213: EMPTY
6214: LIST
6215: LIST
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: PPUSH
6225: CALL_OW 70
6229: PUSH
6230: LD_INT 1
6232: ARRAY
6233: ST_TO_ADDR
// DialogueOn ;
6234: CALL_OW 6
// CenterNowOnUnits ( un ) ;
6238: LD_VAR 0 1
6242: PPUSH
6243: CALL_OW 87
// if Lisa then
6247: LD_EXP 12
6251: IFFALSE 6279
// begin Say ( Lisa , D5-Lisa-1 ) ;
6253: LD_EXP 12
6257: PPUSH
6258: LD_STRING D5-Lisa-1
6260: PPUSH
6261: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
6265: LD_EXP 7
6269: PPUSH
6270: LD_STRING D5-JMM-1a
6272: PPUSH
6273: CALL_OW 88
// end else
6277: GO 6291
// Say ( JMM , D5-JMM-1 ) ;
6279: LD_EXP 7
6283: PPUSH
6284: LD_STRING D5-JMM-1
6286: PPUSH
6287: CALL_OW 88
// DialogueOff ;
6291: CALL_OW 7
// while ( true ) do
6295: LD_INT 1
6297: IFFALSE 6353
// begin wait ( 0 0$01 ) ;
6299: LD_INT 35
6301: PPUSH
6302: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
6306: LD_ADDR_VAR 0 2
6310: PUSH
6311: LD_INT 8
6313: PPUSH
6314: LD_INT 30
6316: PUSH
6317: LD_INT 26
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: PUSH
6324: LD_INT 101
6326: PUSH
6327: LD_INT 1
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: PUSH
6334: EMPTY
6335: LIST
6336: LIST
6337: PPUSH
6338: CALL_OW 71
6342: ST_TO_ADDR
// if x then
6343: LD_VAR 0 2
6347: IFFALSE 6351
// break ;
6349: GO 6353
// end ;
6351: GO 6295
// CenterOnUnits ( x [ 1 ] ) ;
6353: LD_VAR 0 2
6357: PUSH
6358: LD_INT 1
6360: ARRAY
6361: PPUSH
6362: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
6366: LD_EXP 13
6370: PUSH
6371: LD_EXP 13
6375: PPUSH
6376: CALL_OW 255
6380: PUSH
6381: LD_INT 1
6383: EQUAL
6384: AND
6385: IFFALSE 6401
// Say ( Frank , D5a-Frank-1 ) else
6387: LD_EXP 13
6391: PPUSH
6392: LD_STRING D5a-Frank-1
6394: PPUSH
6395: CALL_OW 88
6399: GO 6455
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
6401: LD_EXP 16
6405: PUSH
6406: LD_EXP 16
6410: PPUSH
6411: CALL_OW 255
6415: PUSH
6416: LD_INT 1
6418: EQUAL
6419: AND
6420: IFFALSE 6436
// Say ( Kikuchi , D5a-Yam-1 ) else
6422: LD_EXP 16
6426: PPUSH
6427: LD_STRING D5a-Yam-1
6429: PPUSH
6430: CALL_OW 88
6434: GO 6455
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
6436: LD_INT 1
6438: PPUSH
6439: CALL 418 0 1
6443: PUSH
6444: LD_INT 1
6446: ARRAY
6447: PPUSH
6448: LD_STRING D5a-Sol1-1
6450: PPUSH
6451: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
6455: LD_EXP 7
6459: PPUSH
6460: LD_STRING D5a-JMM-1
6462: PPUSH
6463: CALL_OW 88
// if Cyrus then
6467: LD_EXP 11
6471: IFFALSE 6485
// Say ( Cyrus , D5a-Cyrus-1 ) ;
6473: LD_EXP 11
6477: PPUSH
6478: LD_STRING D5a-Cyrus-1
6480: PPUSH
6481: CALL_OW 88
// x := false ;
6485: LD_ADDR_VAR 0 2
6489: PUSH
6490: LD_INT 0
6492: ST_TO_ADDR
// while ( true ) do
6493: LD_INT 1
6495: IFFALSE 6582
// begin wait ( 0 0$01 ) ;
6497: LD_INT 35
6499: PPUSH
6500: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
6504: LD_ADDR_VAR 0 3
6508: PUSH
6509: LD_INT 2
6511: PUSH
6512: LD_INT 30
6514: PUSH
6515: LD_INT 0
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PUSH
6522: LD_INT 30
6524: PUSH
6525: LD_INT 1
6527: PUSH
6528: EMPTY
6529: LIST
6530: LIST
6531: PUSH
6532: EMPTY
6533: LIST
6534: LIST
6535: LIST
6536: PPUSH
6537: CALL_OW 69
6541: PUSH
6542: LD_INT 1
6544: DIFF
6545: PUSH
6546: FOR_IN
6547: IFFALSE 6570
// if BaseNeedEnergy ( i ) then
6549: LD_VAR 0 3
6553: PPUSH
6554: CALL 1075 0 1
6558: IFFALSE 6568
// x := true ;
6560: LD_ADDR_VAR 0 2
6564: PUSH
6565: LD_INT 1
6567: ST_TO_ADDR
6568: GO 6546
6570: POP
6571: POP
// if x then
6572: LD_VAR 0 2
6576: IFFALSE 6580
// break ;
6578: GO 6582
// end ;
6580: GO 6493
// Say ( JMM , D5b-JMM-1 ) ;
6582: LD_EXP 7
6586: PPUSH
6587: LD_STRING D5b-JMM-1
6589: PPUSH
6590: CALL_OW 88
// end ;
6594: PPOPN 3
6596: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
6597: LD_EXP 5
6601: PUSH
6602: LD_INT 1
6604: ARRAY
6605: PUSH
6606: LD_OWVAR 1
6610: LESS
6611: IFFALSE 6811
6613: GO 6615
6615: DISABLE
// begin if not IsDead ( ru_dep_main ) then
6616: LD_INT 16
6618: PPUSH
6619: CALL_OW 301
6623: NOT
6624: IFFALSE 6647
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
6626: LD_EXP 17
6630: PPUSH
6631: LD_STRING D3b-Har-3
6633: PPUSH
6634: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
6638: LD_STRING M2a
6640: PPUSH
6641: CALL_OW 337
// end else
6645: GO 6666
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
6647: LD_EXP 17
6651: PPUSH
6652: LD_STRING D3b-Har-3a
6654: PPUSH
6655: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
6659: LD_STRING M2
6661: PPUSH
6662: CALL_OW 337
// end ; can_end := true ;
6666: LD_ADDR_EXP 6
6670: PUSH
6671: LD_INT 1
6673: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
6674: LD_INT 9
6676: PPUSH
6677: LD_INT 1
6679: PPUSH
6680: CALL_OW 424
// Wait ( 0 0$02 ) ;
6684: LD_INT 70
6686: PPUSH
6687: CALL_OW 67
// if Lisa then
6691: LD_EXP 12
6695: IFFALSE 6709
// Say ( Lisa , D3b-Lisa ) ;
6697: LD_EXP 12
6701: PPUSH
6702: LD_STRING D3b-Lisa
6704: PPUSH
6705: CALL_OW 88
// if Bobby then
6709: LD_EXP 10
6713: IFFALSE 6727
// Say ( Bobby , D3b-Bobby-3 ) ;
6715: LD_EXP 10
6719: PPUSH
6720: LD_STRING D3b-Bobby-3
6722: PPUSH
6723: CALL_OW 88
// if Cyrus then
6727: LD_EXP 11
6731: IFFALSE 6745
// Say ( Cyrus , D3b-Cyrus-3 ) ;
6733: LD_EXP 11
6737: PPUSH
6738: LD_STRING D3b-Cyrus-3
6740: PPUSH
6741: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
6745: LD_EXP 13
6749: PUSH
6750: LD_EXP 13
6754: PPUSH
6755: CALL_OW 255
6759: PUSH
6760: LD_INT 1
6762: EQUAL
6763: AND
6764: IFFALSE 6778
// Say ( Frank , D3b-Frank-3 ) ;
6766: LD_EXP 13
6770: PPUSH
6771: LD_STRING D3b-Frank-3
6773: PPUSH
6774: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
6778: LD_EXP 16
6782: PUSH
6783: LD_EXP 16
6787: PPUSH
6788: CALL_OW 255
6792: PUSH
6793: LD_INT 1
6795: EQUAL
6796: AND
6797: IFFALSE 6811
// Say ( Kikuchi , D3b-Yam-4 ) ;
6799: LD_EXP 16
6803: PPUSH
6804: LD_STRING D3b-Yam-4
6806: PPUSH
6807: CALL_OW 88
// end ;
6811: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
6812: LD_EXP 5
6816: PUSH
6817: LD_INT 2
6819: ARRAY
6820: PUSH
6821: LD_OWVAR 1
6825: LESS
6826: IFFALSE 6850
6828: GO 6830
6830: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
6831: LD_EXP 17
6835: PPUSH
6836: LD_STRING D4-Har-1
6838: PPUSH
6839: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
6843: LD_STRING M3
6845: PPUSH
6846: CALL_OW 337
// end ;
6850: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
6851: LD_EXP 5
6855: PUSH
6856: LD_INT 3
6858: ARRAY
6859: PUSH
6860: LD_OWVAR 1
6864: LESS
6865: IFFALSE 6896
6867: GO 6869
6869: DISABLE
// begin if not IsDead ( ru_dep_main ) then
6870: LD_INT 16
6872: PPUSH
6873: CALL_OW 301
6877: NOT
6878: IFFALSE 6889
// YouLost ( TimeOut1 ) else
6880: LD_STRING TimeOut1
6882: PPUSH
6883: CALL_OW 104
6887: GO 6896
// YouLost ( TimeOut2 ) ;
6889: LD_STRING TimeOut2
6891: PPUSH
6892: CALL_OW 104
// end ;
6896: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , tmp ;
6897: LD_EXP 7
6901: PPUSH
6902: LD_INT 9
6904: PPUSH
6905: CALL_OW 308
6909: PUSH
6910: LD_EXP 6
6914: AND
6915: IFFALSE 7756
6917: GO 6919
6919: DISABLE
6920: LD_INT 0
6922: PPUSH
6923: PPUSH
// begin wait_on := false ;
6924: LD_ADDR_VAR 0 1
6928: PUSH
6929: LD_INT 0
6931: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
6932: LD_INT 1
6934: PPUSH
6935: CALL 1152 0 1
6939: PUSH
6940: LD_INT 0
6942: PLUS
6943: PUSH
6944: LD_INT 1
6946: PPUSH
6947: LD_INT 9
6949: PPUSH
6950: CALL 1243 0 2
6954: PUSH
6955: LD_INT 1
6957: PPUSH
6958: LD_INT 9
6960: PPUSH
6961: CALL 1290 0 2
6965: ADD
6966: PUSH
6967: LD_INT 0
6969: PLUS
6970: GREATER
6971: IFFALSE 7020
// case Query ( Q1 ) of 1 :
6973: LD_STRING Q1
6975: PPUSH
6976: CALL_OW 97
6980: PUSH
6981: LD_INT 1
6983: DOUBLE
6984: EQUAL
6985: IFTRUE 6989
6987: GO 7000
6989: POP
// wait_on := true ; 2 :
6990: LD_ADDR_VAR 0 1
6994: PUSH
6995: LD_INT 1
6997: ST_TO_ADDR
6998: GO 7020
7000: LD_INT 2
7002: DOUBLE
7003: EQUAL
7004: IFTRUE 7008
7006: GO 7019
7008: POP
// wait_on := false ; end ;
7009: LD_ADDR_VAR 0 1
7013: PUSH
7014: LD_INT 0
7016: ST_TO_ADDR
7017: GO 7020
7019: POP
// repeat wait ( 0 0$01 ) ;
7020: LD_INT 35
7022: PPUSH
7023: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
7027: LD_VAR 0 1
7031: NOT
7032: PUSH
7033: LD_INT 1
7035: PPUSH
7036: CALL 1152 0 1
7040: PUSH
7041: LD_INT 0
7043: PLUS
7044: PUSH
7045: LD_INT 1
7047: PPUSH
7048: LD_INT 9
7050: PPUSH
7051: CALL 1243 0 2
7055: PUSH
7056: LD_INT 1
7058: PPUSH
7059: LD_INT 9
7061: PPUSH
7062: CALL 1290 0 2
7066: ADD
7067: PUSH
7068: LD_INT 0
7070: PLUS
7071: EQUAL
7072: OR
7073: IFFALSE 7020
// DialogueOn ;
7075: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
7079: LD_EXP 7
7083: PPUSH
7084: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
7088: LD_EXP 7
7092: PPUSH
7093: LD_STRING D6-JMM-1
7095: PPUSH
7096: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
7100: LD_EXP 17
7104: PPUSH
7105: LD_STRING D6-Har-1
7107: PPUSH
7108: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
7112: LD_EXP 7
7116: PPUSH
7117: LD_STRING D6-JMM-2
7119: PPUSH
7120: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
7124: LD_EXP 17
7128: PPUSH
7129: LD_STRING D6-Har-2
7131: PPUSH
7132: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
7136: LD_EXP 7
7140: PPUSH
7141: LD_STRING D6-JMM-3
7143: PPUSH
7144: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
7148: LD_EXP 17
7152: PPUSH
7153: LD_STRING D6-Har-3
7155: PPUSH
7156: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
7160: LD_EXP 7
7164: PPUSH
7165: LD_STRING D6-JMM-4
7167: PPUSH
7168: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
7172: LD_EXP 17
7176: PPUSH
7177: LD_STRING D6-Har-4
7179: PPUSH
7180: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
7184: LD_EXP 7
7188: PPUSH
7189: LD_STRING D6-JMM-5
7191: PPUSH
7192: CALL_OW 88
// DialogueOff ;
7196: CALL_OW 7
// tmp := FilterBuildings ( 3 ) ;
7200: LD_ADDR_VAR 0 2
7204: PUSH
7205: LD_INT 3
7207: PPUSH
7208: CALL 1421 0 1
7212: ST_TO_ADDR
// if tmp >= 35 then
7213: LD_VAR 0 2
7217: PUSH
7218: LD_INT 35
7220: GREATEREQUAL
7221: IFFALSE 7258
// begin AddMedal ( Destroy1 , - 1 ) ;
7223: LD_STRING Destroy1
7225: PPUSH
7226: LD_INT 1
7228: NEG
7229: PPUSH
7230: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
7234: LD_STRING Destroy2
7236: PPUSH
7237: LD_INT 1
7239: NEG
7240: PPUSH
7241: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
7245: LD_STRING Destroy3
7247: PPUSH
7248: LD_INT 1
7250: NEG
7251: PPUSH
7252: CALL_OW 101
// end else
7256: GO 7345
// begin AddMedal ( Destroy1 , 1 ) ;
7258: LD_STRING Destroy1
7260: PPUSH
7261: LD_INT 1
7263: PPUSH
7264: CALL_OW 101
// if tmp >= 25 then
7268: LD_VAR 0 2
7272: PUSH
7273: LD_INT 25
7275: GREATEREQUAL
7276: IFFALSE 7302
// begin AddMedal ( Destroy2 , - 1 ) ;
7278: LD_STRING Destroy2
7280: PPUSH
7281: LD_INT 1
7283: NEG
7284: PPUSH
7285: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
7289: LD_STRING Destroy3
7291: PPUSH
7292: LD_INT 1
7294: NEG
7295: PPUSH
7296: CALL_OW 101
// end else
7300: GO 7345
// begin AddMedal ( Destroy2 , 1 ) ;
7302: LD_STRING Destroy2
7304: PPUSH
7305: LD_INT 1
7307: PPUSH
7308: CALL_OW 101
// if tmp >= 15 then
7312: LD_VAR 0 2
7316: PUSH
7317: LD_INT 15
7319: GREATEREQUAL
7320: IFFALSE 7335
// AddMedal ( Destroy3 , - 1 ) else
7322: LD_STRING Destroy3
7324: PPUSH
7325: LD_INT 1
7327: NEG
7328: PPUSH
7329: CALL_OW 101
7333: GO 7345
// AddMedal ( Destroy3 , 1 ) ;
7335: LD_STRING Destroy3
7337: PPUSH
7338: LD_INT 1
7340: PPUSH
7341: CALL_OW 101
// end ; end ; GiveMedals ( MAIN ) ;
7345: LD_STRING MAIN
7347: PPUSH
7348: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ;
7352: LD_ADDR_VAR 0 2
7356: PUSH
7357: LD_INT 1
7359: PPUSH
7360: LD_INT 9
7362: PPUSH
7363: CALL 1243 0 2
7367: PUSH
7368: LD_INT 1
7370: PPUSH
7371: LD_INT 9
7373: PPUSH
7374: CALL 1290 0 2
7378: ADD
7379: ST_TO_ADDR
// RewardPeople ( tmp ) ;
7380: LD_VAR 0 2
7384: PPUSH
7385: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
7389: LD_EXP 7
7393: PPUSH
7394: LD_EXP 3
7398: PUSH
7399: LD_STRING JMM
7401: STR
7402: PPUSH
7403: CALL_OW 38
// if Brown in tmp then
7407: LD_EXP 8
7411: PUSH
7412: LD_VAR 0 2
7416: IN
7417: IFFALSE 7437
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
7419: LD_EXP 8
7423: PPUSH
7424: LD_EXP 3
7428: PUSH
7429: LD_STRING Brown
7431: STR
7432: PPUSH
7433: CALL_OW 38
// if Donaldson in tmp then
7437: LD_EXP 9
7441: PUSH
7442: LD_VAR 0 2
7446: IN
7447: IFFALSE 7467
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
7449: LD_EXP 9
7453: PPUSH
7454: LD_EXP 3
7458: PUSH
7459: LD_STRING Donaldson
7461: STR
7462: PPUSH
7463: CALL_OW 38
// if Bobby in tmp then
7467: LD_EXP 10
7471: PUSH
7472: LD_VAR 0 2
7476: IN
7477: IFFALSE 7497
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
7479: LD_EXP 10
7483: PPUSH
7484: LD_EXP 3
7488: PUSH
7489: LD_STRING Bobby
7491: STR
7492: PPUSH
7493: CALL_OW 38
// if Cyrus in tmp then
7497: LD_EXP 11
7501: PUSH
7502: LD_VAR 0 2
7506: IN
7507: IFFALSE 7527
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
7509: LD_EXP 11
7513: PPUSH
7514: LD_EXP 3
7518: PUSH
7519: LD_STRING Cyrus
7521: STR
7522: PPUSH
7523: CALL_OW 38
// if Lisa in tmp then
7527: LD_EXP 12
7531: PUSH
7532: LD_VAR 0 2
7536: IN
7537: IFFALSE 7557
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
7539: LD_EXP 12
7543: PPUSH
7544: LD_EXP 3
7548: PUSH
7549: LD_STRING Lisa
7551: STR
7552: PPUSH
7553: CALL_OW 38
// if Frank in tmp then
7557: LD_EXP 13
7561: PUSH
7562: LD_VAR 0 2
7566: IN
7567: IFFALSE 7587
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
7569: LD_EXP 13
7573: PPUSH
7574: LD_EXP 3
7578: PUSH
7579: LD_STRING Frank
7581: STR
7582: PPUSH
7583: CALL_OW 38
// if Gladstone in tmp then
7587: LD_EXP 14
7591: PUSH
7592: LD_VAR 0 2
7596: IN
7597: IFFALSE 7617
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
7599: LD_EXP 14
7603: PPUSH
7604: LD_EXP 3
7608: PUSH
7609: LD_STRING Gladstone
7611: STR
7612: PPUSH
7613: CALL_OW 38
// if Khatam in tmp then
7617: LD_EXP 15
7621: PUSH
7622: LD_VAR 0 2
7626: IN
7627: IFFALSE 7647
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
7629: LD_EXP 15
7633: PPUSH
7634: LD_EXP 3
7638: PUSH
7639: LD_STRING Khatam
7641: STR
7642: PPUSH
7643: CALL_OW 38
// if Kikuchi in tmp then
7647: LD_EXP 16
7651: PUSH
7652: LD_VAR 0 2
7656: IN
7657: IFFALSE 7677
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
7659: LD_EXP 16
7663: PPUSH
7664: LD_EXP 3
7668: PUSH
7669: LD_STRING Kikuchi
7671: STR
7672: PPUSH
7673: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi ] , mission_prefix & others ) ;
7677: LD_VAR 0 2
7681: PUSH
7682: LD_EXP 7
7686: PUSH
7687: LD_EXP 8
7691: PUSH
7692: LD_EXP 9
7696: PUSH
7697: LD_EXP 10
7701: PUSH
7702: LD_EXP 11
7706: PUSH
7707: LD_EXP 12
7711: PUSH
7712: LD_EXP 13
7716: PUSH
7717: LD_EXP 14
7721: PUSH
7722: LD_EXP 16
7726: PUSH
7727: EMPTY
7728: LIST
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: LIST
7736: LIST
7737: DIFF
7738: PPUSH
7739: LD_EXP 3
7743: PUSH
7744: LD_STRING others
7746: STR
7747: PPUSH
7748: CALL_OW 38
// YouWin ;
7752: CALL_OW 103
// end ; end_of_file
7756: PPOPN 2
7758: END
// on UnitDestroyed ( un ) do begin if un = JMM then
7759: LD_VAR 0 1
7763: PUSH
7764: LD_EXP 7
7768: EQUAL
7769: IFFALSE 7778
// YouLost ( JMM ) ;
7771: LD_STRING JMM
7773: PPUSH
7774: CALL_OW 104
// if GetType ( un ) = unit_building then
7778: LD_VAR 0 1
7782: PPUSH
7783: CALL_OW 247
7787: PUSH
7788: LD_INT 3
7790: EQUAL
7791: IFFALSE 7807
// buildings_counter := buildings_counter + 1 ;
7793: LD_ADDR_EXP 4
7797: PUSH
7798: LD_EXP 4
7802: PUSH
7803: LD_INT 1
7805: PLUS
7806: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
7807: LD_VAR 0 1
7811: PUSH
7812: LD_INT 6
7814: PPUSH
7815: LD_INT 2
7817: PUSH
7818: LD_INT 30
7820: PUSH
7821: LD_INT 33
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: PUSH
7828: LD_INT 30
7830: PUSH
7831: LD_INT 32
7833: PUSH
7834: EMPTY
7835: LIST
7836: LIST
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: LIST
7842: PPUSH
7843: CALL_OW 70
7847: IN
7848: IFFALSE 7907
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
7850: LD_ADDR_EXP 18
7854: PUSH
7855: LD_EXP 18
7859: PUSH
7860: LD_VAR 0 1
7864: PPUSH
7865: CALL_OW 266
7869: PUSH
7870: LD_VAR 0 1
7874: PPUSH
7875: CALL_OW 250
7879: PUSH
7880: LD_VAR 0 1
7884: PPUSH
7885: CALL_OW 251
7889: PUSH
7890: LD_VAR 0 1
7894: PPUSH
7895: CALL_OW 254
7899: PUSH
7900: EMPTY
7901: LIST
7902: LIST
7903: LIST
7904: LIST
7905: ADD
7906: ST_TO_ADDR
// if un = ru_dep_main then
7907: LD_VAR 0 1
7911: PUSH
7912: LD_INT 16
7914: EQUAL
7915: IFFALSE 7924
// ChangeMissionObjectives ( M1a ) ;
7917: LD_STRING M1a
7919: PPUSH
7920: CALL_OW 337
// end ;
7924: PPOPN 1
7926: END
// on BuildingStarted ( b , builder ) do var i ;
7927: LD_INT 0
7929: PPUSH
// begin if GetSide ( b ) = 3 then
7930: LD_VAR 0 1
7934: PPUSH
7935: CALL_OW 255
7939: PUSH
7940: LD_INT 3
7942: EQUAL
7943: IFFALSE 7983
// for i = 1 to 4 do
7945: LD_ADDR_VAR 0 3
7949: PUSH
7950: DOUBLE
7951: LD_INT 1
7953: DEC
7954: ST_TO_ADDR
7955: LD_INT 4
7957: PUSH
7958: FOR_TO
7959: IFFALSE 7981
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
7961: LD_ADDR_EXP 18
7965: PUSH
7966: LD_EXP 18
7970: PPUSH
7971: LD_INT 1
7973: PPUSH
7974: CALL_OW 3
7978: ST_TO_ADDR
7979: GO 7958
7981: POP
7982: POP
// end ;
7983: PPOPN 3
7985: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
7986: LD_VAR 0 1
7990: PPUSH
7991: CALL_OW 266
7995: PUSH
7996: LD_INT 32
7998: PUSH
7999: LD_INT 33
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: IN
8006: IFFALSE 8020
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
8008: LD_VAR 0 1
8012: PPUSH
8013: LD_INT 43
8015: PPUSH
8016: CALL_OW 148
8020: PPOPN 1
8022: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
8023: LD_VAR 0 1
8027: PUSH
8028: LD_INT 22
8030: PUSH
8031: LD_INT 3
8033: PUSH
8034: EMPTY
8035: LIST
8036: LIST
8037: PUSH
8038: LD_INT 2
8040: PUSH
8041: LD_INT 30
8043: PUSH
8044: LD_INT 31
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: PUSH
8051: LD_INT 30
8053: PUSH
8054: LD_INT 32
8056: PUSH
8057: EMPTY
8058: LIST
8059: LIST
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: LIST
8065: PUSH
8066: EMPTY
8067: LIST
8068: LIST
8069: PPUSH
8070: CALL_OW 69
8074: IN
8075: IFFALSE 8097
// GoToAnotherTower ( un , b , 143 , 143 ) ;
8077: LD_VAR 0 2
8081: PPUSH
8082: LD_VAR 0 1
8086: PPUSH
8087: LD_INT 143
8089: PPUSH
8090: LD_INT 143
8092: PPUSH
8093: CALL 648 0 4
// end ;
8097: PPOPN 2
8099: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
8100: LD_VAR 0 1
8104: PUSH
8105: LD_INT 22
8107: PUSH
8108: LD_INT 3
8110: PUSH
8111: EMPTY
8112: LIST
8113: LIST
8114: PUSH
8115: LD_INT 30
8117: PUSH
8118: LD_INT 32
8120: PUSH
8121: EMPTY
8122: LIST
8123: LIST
8124: PUSH
8125: EMPTY
8126: LIST
8127: LIST
8128: PPUSH
8129: CALL_OW 69
8133: IN
8134: IFFALSE 8148
// SetTag ( b , 0 ) ;
8136: LD_VAR 0 1
8140: PPUSH
8141: LD_INT 0
8143: PPUSH
8144: CALL_OW 109
// end ;
8148: PPOPN 2
8150: END
