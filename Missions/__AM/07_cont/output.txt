// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 33 0 0
// DebugMode ;
  12: CALL 234 0 0
// PrepareNature ;
  16: CALL 2917 0 0
// PrepareRussians ;
  20: CALL 4459 0 0
// PrepareAmericans ;
  24: CALL 3402 0 0
// Action ;
  28: CALL 8247 0 0
// end ;
  32: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end , must_end ; function Init ; begin
  33: LD_INT 0
  35: PPUSH
// debug := false ;
  36: LD_ADDR_EXP 1
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// mission_prefix := 07c_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 07c_
  51: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  52: LD_ADDR_EXP 2
  56: PUSH
  57: LD_STRING 07_
  59: ST_TO_ADDR
// buildings_counter := 0 ;
  60: LD_ADDR_EXP 4
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// time_to_end := [ [ 32 32$00 , 29 29$00 , 26 26$00 ] [ Difficulty ] , [ 38 38$00 , 35 35$00 , 32 32$00 ] [ Difficulty ] , [ 44 44$00 , 41 41$00 , 38 38$00 ] [ Difficulty ] ] ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 67200
  75: PUSH
  76: LD_INT 60900
  78: PUSH
  79: LD_INT 54600
  81: PUSH
  82: EMPTY
  83: LIST
  84: LIST
  85: LIST
  86: PUSH
  87: LD_OWVAR 67
  91: ARRAY
  92: PUSH
  93: LD_INT 79800
  95: PUSH
  96: LD_INT 73500
  98: PUSH
  99: LD_INT 67200
 101: PUSH
 102: EMPTY
 103: LIST
 104: LIST
 105: LIST
 106: PUSH
 107: LD_OWVAR 67
 111: ARRAY
 112: PUSH
 113: LD_INT 92400
 115: PUSH
 116: LD_INT 86100
 118: PUSH
 119: LD_INT 79800
 121: PUSH
 122: EMPTY
 123: LIST
 124: LIST
 125: LIST
 126: PUSH
 127: LD_OWVAR 67
 131: ARRAY
 132: PUSH
 133: EMPTY
 134: LIST
 135: LIST
 136: LIST
 137: ST_TO_ADDR
// can_end := false ;
 138: LD_ADDR_EXP 6
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// must_end := false ;
 146: LD_ADDR_EXP 7
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// end ;
 154: LD_VAR 0 1
 158: RET
// every 0 0$01 trigger not debug do
 159: LD_EXP 1
 163: NOT
 164: IFFALSE 233
 166: GO 168
 168: DISABLE
// begin enable ;
 169: ENABLE
// if not must_end then
 170: LD_EXP 7
 174: NOT
 175: IFFALSE 196
// display_strings := [ #Am07-1 , tick ] else
 177: LD_ADDR_OWVAR 47
 181: PUSH
 182: LD_STRING #Am07-1
 184: PUSH
 185: LD_OWVAR 1
 189: PUSH
 190: EMPTY
 191: LIST
 192: LIST
 193: ST_TO_ADDR
 194: GO 233
// display_strings := [ #Am07-1 , tick , #Am07-2 , time_to_end [ 3 ] - tick ] ;
 196: LD_ADDR_OWVAR 47
 200: PUSH
 201: LD_STRING #Am07-1
 203: PUSH
 204: LD_OWVAR 1
 208: PUSH
 209: LD_STRING #Am07-2
 211: PUSH
 212: LD_EXP 5
 216: PUSH
 217: LD_INT 3
 219: ARRAY
 220: PUSH
 221: LD_OWVAR 1
 225: MINUS
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: LIST
 232: ST_TO_ADDR
// end ;
 233: END
// function DebugMode ; begin
 234: LD_INT 0
 236: PPUSH
// if not debug then
 237: LD_EXP 1
 241: NOT
 242: IFFALSE 246
// exit ;
 244: GO 253
// FogOff ( 1 ) ;
 246: LD_INT 1
 248: PPUSH
 249: CALL_OW 344
// end ;
 253: LD_VAR 0 1
 257: RET
// every 3 trigger debug do var i , filter ;
 258: LD_EXP 1
 262: IFFALSE 351
 264: GO 266
 266: DISABLE
 267: LD_INT 0
 269: PPUSH
 270: PPUSH
// begin enable ;
 271: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 272: LD_ADDR_VAR 0 2
 276: PUSH
 277: LD_INT 22
 279: PUSH
 280: LD_INT 1
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: PUSH
 287: LD_INT 3
 289: PUSH
 290: LD_INT 24
 292: PUSH
 293: LD_INT 500
 295: PUSH
 296: EMPTY
 297: LIST
 298: LIST
 299: PUSH
 300: EMPTY
 301: LIST
 302: LIST
 303: PUSH
 304: EMPTY
 305: LIST
 306: LIST
 307: PPUSH
 308: CALL_OW 69
 312: ST_TO_ADDR
// if not filter then
 313: LD_VAR 0 2
 317: NOT
 318: IFFALSE 322
// exit ;
 320: GO 351
// for i in filter do
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_VAR 0 2
 331: PUSH
 332: FOR_IN
 333: IFFALSE 349
// SetLives ( i , 1000 ) ;
 335: LD_VAR 0 1
 339: PPUSH
 340: LD_INT 1000
 342: PPUSH
 343: CALL_OW 234
 347: GO 332
 349: POP
 350: POP
// end ; end_of_file
 351: PPOPN 2
 353: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 354: LD_INT 0
 356: PPUSH
 357: PPUSH
// if exist_mode then
 358: LD_VAR 0 2
 362: IFFALSE 387
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 364: LD_ADDR_VAR 0 4
 368: PUSH
 369: LD_EXP 2
 373: PUSH
 374: LD_VAR 0 1
 378: STR
 379: PPUSH
 380: CALL_OW 34
 384: ST_TO_ADDR
 385: GO 402
// unit := NewCharacter ( ident ) ;
 387: LD_ADDR_VAR 0 4
 391: PUSH
 392: LD_VAR 0 1
 396: PPUSH
 397: CALL_OW 25
 401: ST_TO_ADDR
// result := unit ;
 402: LD_ADDR_VAR 0 3
 406: PUSH
 407: LD_VAR 0 4
 411: ST_TO_ADDR
// end ;
 412: LD_VAR 0 3
 416: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 417: LD_INT 0
 419: PPUSH
// uc_side := side ;
 420: LD_ADDR_OWVAR 20
 424: PUSH
 425: LD_VAR 0 1
 429: ST_TO_ADDR
// uc_nation := nation ;
 430: LD_ADDR_OWVAR 21
 434: PUSH
 435: LD_VAR 0 2
 439: ST_TO_ADDR
// vc_chassis := chassis ;
 440: LD_ADDR_OWVAR 37
 444: PUSH
 445: LD_VAR 0 3
 449: ST_TO_ADDR
// vc_engine := engine ;
 450: LD_ADDR_OWVAR 39
 454: PUSH
 455: LD_VAR 0 4
 459: ST_TO_ADDR
// vc_control := control ;
 460: LD_ADDR_OWVAR 38
 464: PUSH
 465: LD_VAR 0 5
 469: ST_TO_ADDR
// vc_weapon := weapon ;
 470: LD_ADDR_OWVAR 40
 474: PUSH
 475: LD_VAR 0 6
 479: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 480: LD_ADDR_OWVAR 41
 484: PUSH
 485: LD_VAR 0 7
 489: ST_TO_ADDR
// result := CreateVehicle ;
 490: LD_ADDR_VAR 0 8
 494: PUSH
 495: CALL_OW 45
 499: ST_TO_ADDR
// end ;
 500: LD_VAR 0 8
 504: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 505: LD_INT 0
 507: PPUSH
 508: PPUSH
 509: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 510: LD_ADDR_VAR 0 4
 514: PUSH
 515: LD_INT 22
 517: PUSH
 518: LD_INT 1
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: PUSH
 525: LD_INT 21
 527: PUSH
 528: LD_INT 1
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: PUSH
 535: LD_INT 50
 537: PUSH
 538: EMPTY
 539: LIST
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: PPUSH
 546: CALL_OW 69
 550: PUSH
 551: LD_EXP 8
 555: PUSH
 556: LD_EXP 9
 560: PUSH
 561: LD_EXP 10
 565: PUSH
 566: LD_EXP 11
 570: PUSH
 571: LD_EXP 12
 575: PUSH
 576: LD_EXP 13
 580: PUSH
 581: LD_EXP 14
 585: PUSH
 586: LD_EXP 15
 590: PUSH
 591: LD_EXP 17
 595: PUSH
 596: LD_EXP 16
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: DIFF
 613: ST_TO_ADDR
// if not filter then
 614: LD_VAR 0 4
 618: NOT
 619: IFFALSE 623
// exit ;
 621: GO 650
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 623: LD_ADDR_VAR 0 2
 627: PUSH
 628: LD_VAR 0 4
 632: PPUSH
 633: LD_INT 26
 635: PUSH
 636: LD_VAR 0 1
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL_OW 72
 649: ST_TO_ADDR
// end ;
 650: LD_VAR 0 2
 654: RET
// export function SayX ( units , ident ) ; var i ; begin
 655: LD_INT 0
 657: PPUSH
 658: PPUSH
// result := false ;
 659: LD_ADDR_VAR 0 3
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// if not units then
 667: LD_VAR 0 1
 671: NOT
 672: IFFALSE 676
// exit ;
 674: GO 730
// for i in units do
 676: LD_ADDR_VAR 0 4
 680: PUSH
 681: LD_VAR 0 1
 685: PUSH
 686: FOR_IN
 687: IFFALSE 728
// if IsOk ( i ) then
 689: LD_VAR 0 4
 693: PPUSH
 694: CALL_OW 302
 698: IFFALSE 726
// begin Say ( i , ident ) ;
 700: LD_VAR 0 4
 704: PPUSH
 705: LD_VAR 0 2
 709: PPUSH
 710: CALL_OW 88
// result := i ;
 714: LD_ADDR_VAR 0 3
 718: PUSH
 719: LD_VAR 0 4
 723: ST_TO_ADDR
// break ;
 724: GO 728
// end ;
 726: GO 686
 728: POP
 729: POP
// end ;
 730: LD_VAR 0 3
 734: RET
// export function GetBaseBuildings ( base ) ; var tmp , i ; begin
 735: LD_INT 0
 737: PPUSH
 738: PPUSH
 739: PPUSH
// result := [ ] ;
 740: LD_ADDR_VAR 0 2
 744: PUSH
 745: EMPTY
 746: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
 747: LD_ADDR_VAR 0 3
 751: PUSH
 752: LD_INT 21
 754: PUSH
 755: LD_INT 3
 757: PUSH
 758: EMPTY
 759: LIST
 760: LIST
 761: PPUSH
 762: CALL_OW 69
 766: ST_TO_ADDR
// if not tmp then
 767: LD_VAR 0 3
 771: NOT
 772: IFFALSE 776
// exit ;
 774: GO 826
// for i in tmp do
 776: LD_ADDR_VAR 0 4
 780: PUSH
 781: LD_VAR 0 3
 785: PUSH
 786: FOR_IN
 787: IFFALSE 824
// if GetBase ( i ) = base then
 789: LD_VAR 0 4
 793: PPUSH
 794: CALL_OW 274
 798: PUSH
 799: LD_VAR 0 1
 803: EQUAL
 804: IFFALSE 822
// result := result ^ i ;
 806: LD_ADDR_VAR 0 2
 810: PUSH
 811: LD_VAR 0 2
 815: PUSH
 816: LD_VAR 0 4
 820: ADD
 821: ST_TO_ADDR
 822: GO 786
 824: POP
 825: POP
// end ;
 826: LD_VAR 0 2
 830: RET
// export function GetTurretWeapon ( tower ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
 831: LD_INT 0
 833: PPUSH
 834: PPUSH
 835: PPUSH
 836: PPUSH
 837: PPUSH
 838: PPUSH
 839: PPUSH
 840: PPUSH
 841: PPUSH
 842: PPUSH
 843: PPUSH
 844: PPUSH
 845: PPUSH
 846: PPUSH
 847: PPUSH
 848: PPUSH
// result := false ;
 849: LD_ADDR_VAR 0 2
 853: PUSH
 854: LD_INT 0
 856: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
 857: LD_VAR 0 1
 861: NOT
 862: PUSH
 863: LD_VAR 0 1
 867: PPUSH
 868: CALL_OW 266
 872: PUSH
 873: LD_INT 32
 875: PUSH
 876: LD_INT 33
 878: PUSH
 879: EMPTY
 880: LIST
 881: LIST
 882: IN
 883: NOT
 884: OR
 885: IFFALSE 889
// exit ;
 887: GO 2049
// nat := GetNation ( tower ) ;
 889: LD_ADDR_VAR 0 11
 893: PUSH
 894: LD_VAR 0 1
 898: PPUSH
 899: CALL_OW 248
 903: ST_TO_ADDR
// side := GetSide ( tower ) ;
 904: LD_ADDR_VAR 0 15
 908: PUSH
 909: LD_VAR 0 1
 913: PPUSH
 914: CALL_OW 255
 918: ST_TO_ADDR
// x := GetX ( tower ) ;
 919: LD_ADDR_VAR 0 9
 923: PUSH
 924: LD_VAR 0 1
 928: PPUSH
 929: CALL_OW 250
 933: ST_TO_ADDR
// y := GetY ( tower ) ;
 934: LD_ADDR_VAR 0 10
 938: PUSH
 939: LD_VAR 0 1
 943: PPUSH
 944: CALL_OW 251
 948: ST_TO_ADDR
// if not x or not y then
 949: LD_VAR 0 9
 953: NOT
 954: PUSH
 955: LD_VAR 0 10
 959: NOT
 960: OR
 961: IFFALSE 965
// exit ;
 963: GO 2049
// weapon := 0 ;
 965: LD_ADDR_VAR 0 17
 969: PUSH
 970: LD_INT 0
 972: ST_TO_ADDR
// fac_list := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun ] ;
 973: LD_ADDR_VAR 0 16
 977: PUSH
 978: LD_INT 42
 980: PUSH
 981: LD_INT 43
 983: PUSH
 984: LD_INT 44
 986: PUSH
 987: LD_INT 46
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: ST_TO_ADDR
// if not fac_list then
 996: LD_VAR 0 16
1000: NOT
1001: IFFALSE 1005
// exit ;
1003: GO 2049
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
1005: LD_ADDR_VAR 0 4
1009: PUSH
1010: LD_INT 4
1012: PUSH
1013: LD_INT 5
1015: PUSH
1016: LD_INT 9
1018: PUSH
1019: LD_INT 10
1021: PUSH
1022: LD_INT 6
1024: PUSH
1025: LD_INT 7
1027: PUSH
1028: LD_INT 11
1030: PUSH
1031: EMPTY
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: PUSH
1040: LD_INT 27
1042: PUSH
1043: LD_INT 28
1045: PUSH
1046: LD_INT 26
1048: PUSH
1049: LD_INT 30
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: PUSH
1058: LD_INT 43
1060: PUSH
1061: LD_INT 44
1063: PUSH
1064: LD_INT 46
1066: PUSH
1067: LD_INT 45
1069: PUSH
1070: LD_INT 47
1072: PUSH
1073: LD_INT 49
1075: PUSH
1076: EMPTY
1077: LIST
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: PUSH
1084: EMPTY
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: LD_VAR 0 11
1093: ARRAY
1094: ST_TO_ADDR
// for i in list do
1095: LD_ADDR_VAR 0 7
1099: PUSH
1100: LD_VAR 0 4
1104: PUSH
1105: FOR_IN
1106: IFFALSE 1139
// if not i in fac_list then
1108: LD_VAR 0 7
1112: PUSH
1113: LD_VAR 0 16
1117: IN
1118: NOT
1119: IFFALSE 1137
// list := list diff i ;
1121: LD_ADDR_VAR 0 4
1125: PUSH
1126: LD_VAR 0 4
1130: PUSH
1131: LD_VAR 0 7
1135: DIFF
1136: ST_TO_ADDR
1137: GO 1105
1139: POP
1140: POP
// if not list then
1141: LD_VAR 0 4
1145: NOT
1146: IFFALSE 1150
// exit ;
1148: GO 2049
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
1150: LD_VAR 0 11
1154: PUSH
1155: LD_INT 3
1157: EQUAL
1158: PUSH
1159: LD_INT 49
1161: PUSH
1162: LD_VAR 0 4
1166: IN
1167: AND
1168: PUSH
1169: LD_INT 31
1171: PPUSH
1172: LD_VAR 0 15
1176: PPUSH
1177: CALL_OW 321
1181: PUSH
1182: LD_INT 2
1184: EQUAL
1185: AND
1186: IFFALSE 1246
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
1188: LD_INT 22
1190: PUSH
1191: LD_VAR 0 15
1195: PUSH
1196: EMPTY
1197: LIST
1198: LIST
1199: PUSH
1200: LD_INT 35
1202: PUSH
1203: LD_INT 49
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: PUSH
1210: LD_INT 91
1212: PUSH
1213: LD_VAR 0 1
1217: PUSH
1218: LD_INT 10
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PPUSH
1231: CALL_OW 69
1235: NOT
1236: IFFALSE 1246
// weapon := ru_time_lapser ;
1238: LD_ADDR_VAR 0 17
1242: PUSH
1243: LD_INT 49
1245: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
1246: LD_VAR 0 11
1250: PUSH
1251: LD_INT 1
1253: PUSH
1254: LD_INT 2
1256: PUSH
1257: EMPTY
1258: LIST
1259: LIST
1260: IN
1261: PUSH
1262: LD_INT 11
1264: PUSH
1265: LD_VAR 0 4
1269: IN
1270: PUSH
1271: LD_INT 30
1273: PUSH
1274: LD_VAR 0 4
1278: IN
1279: OR
1280: AND
1281: PUSH
1282: LD_INT 6
1284: PPUSH
1285: LD_VAR 0 15
1289: PPUSH
1290: CALL_OW 321
1294: PUSH
1295: LD_INT 2
1297: EQUAL
1298: AND
1299: IFFALSE 1464
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
1301: LD_INT 22
1303: PUSH
1304: LD_VAR 0 15
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: PUSH
1313: LD_INT 2
1315: PUSH
1316: LD_INT 35
1318: PUSH
1319: LD_INT 11
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: PUSH
1326: LD_INT 35
1328: PUSH
1329: LD_INT 30
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: PUSH
1341: LD_INT 91
1343: PUSH
1344: LD_VAR 0 1
1348: PUSH
1349: LD_INT 18
1351: PUSH
1352: EMPTY
1353: LIST
1354: LIST
1355: LIST
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: LIST
1361: PPUSH
1362: CALL_OW 69
1366: NOT
1367: PUSH
1368: LD_INT 22
1370: PUSH
1371: LD_VAR 0 15
1375: PUSH
1376: EMPTY
1377: LIST
1378: LIST
1379: PUSH
1380: LD_INT 2
1382: PUSH
1383: LD_INT 30
1385: PUSH
1386: LD_INT 32
1388: PUSH
1389: EMPTY
1390: LIST
1391: LIST
1392: PUSH
1393: LD_INT 30
1395: PUSH
1396: LD_INT 33
1398: PUSH
1399: EMPTY
1400: LIST
1401: LIST
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: LIST
1407: PUSH
1408: LD_INT 91
1410: PUSH
1411: LD_VAR 0 1
1415: PUSH
1416: LD_INT 12
1418: PUSH
1419: EMPTY
1420: LIST
1421: LIST
1422: LIST
1423: PUSH
1424: EMPTY
1425: LIST
1426: LIST
1427: LIST
1428: PUSH
1429: EMPTY
1430: LIST
1431: PPUSH
1432: CALL_OW 69
1436: PUSH
1437: LD_INT 2
1439: GREATER
1440: AND
1441: IFFALSE 1464
// weapon := [ us_radar , ar_radar ] [ nat ] ;
1443: LD_ADDR_VAR 0 17
1447: PUSH
1448: LD_INT 11
1450: PUSH
1451: LD_INT 30
1453: PUSH
1454: EMPTY
1455: LIST
1456: LIST
1457: PUSH
1458: LD_VAR 0 11
1462: ARRAY
1463: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
1464: LD_VAR 0 17
1468: NOT
1469: PUSH
1470: LD_INT 40
1472: PPUSH
1473: LD_VAR 0 15
1477: PPUSH
1478: CALL_OW 321
1482: PUSH
1483: LD_INT 2
1485: EQUAL
1486: AND
1487: PUSH
1488: LD_INT 7
1490: PUSH
1491: LD_VAR 0 4
1495: IN
1496: PUSH
1497: LD_INT 28
1499: PUSH
1500: LD_VAR 0 4
1504: IN
1505: OR
1506: PUSH
1507: LD_INT 45
1509: PUSH
1510: LD_VAR 0 4
1514: IN
1515: OR
1516: AND
1517: IFFALSE 1771
// begin hex := GetHexInfo ( x , y ) ;
1519: LD_ADDR_VAR 0 3
1523: PUSH
1524: LD_VAR 0 9
1528: PPUSH
1529: LD_VAR 0 10
1533: PPUSH
1534: CALL_OW 546
1538: ST_TO_ADDR
// if hex [ 1 ] then
1539: LD_VAR 0 3
1543: PUSH
1544: LD_INT 1
1546: ARRAY
1547: IFFALSE 1551
// exit ;
1549: GO 2049
// height := hex [ 2 ] ;
1551: LD_ADDR_VAR 0 14
1555: PUSH
1556: LD_VAR 0 3
1560: PUSH
1561: LD_INT 2
1563: ARRAY
1564: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
1565: LD_ADDR_VAR 0 13
1569: PUSH
1570: LD_INT 0
1572: PUSH
1573: LD_INT 2
1575: PUSH
1576: LD_INT 3
1578: PUSH
1579: LD_INT 5
1581: PUSH
1582: EMPTY
1583: LIST
1584: LIST
1585: LIST
1586: LIST
1587: ST_TO_ADDR
// for i in tmp do
1588: LD_ADDR_VAR 0 7
1592: PUSH
1593: LD_VAR 0 13
1597: PUSH
1598: FOR_IN
1599: IFFALSE 1769
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
1601: LD_ADDR_VAR 0 8
1605: PUSH
1606: LD_VAR 0 9
1610: PPUSH
1611: LD_VAR 0 7
1615: PPUSH
1616: LD_INT 5
1618: PPUSH
1619: CALL_OW 272
1623: PUSH
1624: LD_VAR 0 10
1628: PPUSH
1629: LD_VAR 0 7
1633: PPUSH
1634: LD_INT 5
1636: PPUSH
1637: CALL_OW 273
1641: PUSH
1642: EMPTY
1643: LIST
1644: LIST
1645: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
1646: LD_VAR 0 8
1650: PUSH
1651: LD_INT 1
1653: ARRAY
1654: PPUSH
1655: LD_VAR 0 8
1659: PUSH
1660: LD_INT 2
1662: ARRAY
1663: PPUSH
1664: CALL_OW 488
1668: IFFALSE 1767
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
1670: LD_ADDR_VAR 0 3
1674: PUSH
1675: LD_VAR 0 8
1679: PUSH
1680: LD_INT 1
1682: ARRAY
1683: PPUSH
1684: LD_VAR 0 8
1688: PUSH
1689: LD_INT 2
1691: ARRAY
1692: PPUSH
1693: CALL_OW 546
1697: ST_TO_ADDR
// if hex [ 1 ] then
1698: LD_VAR 0 3
1702: PUSH
1703: LD_INT 1
1705: ARRAY
1706: IFFALSE 1710
// continue ;
1708: GO 1598
// h := hex [ 2 ] ;
1710: LD_ADDR_VAR 0 12
1714: PUSH
1715: LD_VAR 0 3
1719: PUSH
1720: LD_INT 2
1722: ARRAY
1723: ST_TO_ADDR
// if h + 7 < height then
1724: LD_VAR 0 12
1728: PUSH
1729: LD_INT 7
1731: PLUS
1732: PUSH
1733: LD_VAR 0 14
1737: LESS
1738: IFFALSE 1767
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
1740: LD_ADDR_VAR 0 17
1744: PUSH
1745: LD_INT 7
1747: PUSH
1748: LD_INT 28
1750: PUSH
1751: LD_INT 45
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: LD_VAR 0 11
1763: ARRAY
1764: ST_TO_ADDR
// break ;
1765: GO 1769
// end ; end ; end ;
1767: GO 1598
1769: POP
1770: POP
// end ; if not weapon then
1771: LD_VAR 0 17
1775: NOT
1776: IFFALSE 1931
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
1778: LD_ADDR_VAR 0 4
1782: PUSH
1783: LD_VAR 0 4
1787: PUSH
1788: LD_INT 11
1790: PUSH
1791: LD_INT 30
1793: PUSH
1794: LD_INT 49
1796: PUSH
1797: EMPTY
1798: LIST
1799: LIST
1800: LIST
1801: DIFF
1802: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , tower , 6 ] , [ f_not , [ f_bweapon , 0 ] ] ] ) ;
1803: LD_ADDR_VAR 0 13
1807: PUSH
1808: LD_INT 22
1810: PUSH
1811: LD_VAR 0 15
1815: PUSH
1816: EMPTY
1817: LIST
1818: LIST
1819: PUSH
1820: LD_INT 91
1822: PUSH
1823: LD_VAR 0 1
1827: PUSH
1828: LD_INT 6
1830: PUSH
1831: EMPTY
1832: LIST
1833: LIST
1834: LIST
1835: PUSH
1836: LD_INT 3
1838: PUSH
1839: LD_INT 35
1841: PUSH
1842: LD_INT 0
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: PUSH
1853: EMPTY
1854: LIST
1855: LIST
1856: LIST
1857: PPUSH
1858: CALL_OW 69
1862: ST_TO_ADDR
// for i in tmp do
1863: LD_ADDR_VAR 0 7
1867: PUSH
1868: LD_VAR 0 13
1872: PUSH
1873: FOR_IN
1874: IFFALSE 1899
// list := list diff GetBWeapon ( i ) ;
1876: LD_ADDR_VAR 0 4
1880: PUSH
1881: LD_VAR 0 4
1885: PUSH
1886: LD_VAR 0 7
1890: PPUSH
1891: CALL_OW 269
1895: DIFF
1896: ST_TO_ADDR
1897: GO 1873
1899: POP
1900: POP
// if list then
1901: LD_VAR 0 4
1905: IFFALSE 1931
// weapon := list [ rand ( 1 , list ) ] ;
1907: LD_ADDR_VAR 0 17
1911: PUSH
1912: LD_VAR 0 4
1916: PUSH
1917: LD_INT 1
1919: PPUSH
1920: LD_VAR 0 4
1924: PPUSH
1925: CALL_OW 12
1929: ARRAY
1930: ST_TO_ADDR
// end ; if weapon then
1931: LD_VAR 0 17
1935: IFFALSE 2049
// begin tmp := CostOfWeapon ( weapon ) ;
1937: LD_ADDR_VAR 0 13
1941: PUSH
1942: LD_VAR 0 17
1946: PPUSH
1947: CALL_OW 451
1951: ST_TO_ADDR
// j := GetBase ( tower ) ;
1952: LD_ADDR_VAR 0 8
1956: PUSH
1957: LD_VAR 0 1
1961: PPUSH
1962: CALL_OW 274
1966: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
1967: LD_VAR 0 8
1971: PPUSH
1972: LD_INT 1
1974: PPUSH
1975: CALL_OW 275
1979: PUSH
1980: LD_VAR 0 13
1984: PUSH
1985: LD_INT 1
1987: ARRAY
1988: GREATEREQUAL
1989: PUSH
1990: LD_VAR 0 8
1994: PPUSH
1995: LD_INT 2
1997: PPUSH
1998: CALL_OW 275
2002: PUSH
2003: LD_VAR 0 13
2007: PUSH
2008: LD_INT 2
2010: ARRAY
2011: GREATEREQUAL
2012: AND
2013: PUSH
2014: LD_VAR 0 8
2018: PPUSH
2019: LD_INT 3
2021: PPUSH
2022: CALL_OW 275
2026: PUSH
2027: LD_VAR 0 13
2031: PUSH
2032: LD_INT 3
2034: ARRAY
2035: GREATEREQUAL
2036: AND
2037: IFFALSE 2049
// result := weapon ;
2039: LD_ADDR_VAR 0 2
2043: PUSH
2044: LD_VAR 0 17
2048: ST_TO_ADDR
// end ; end ;
2049: LD_VAR 0 2
2053: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
2054: LD_INT 0
2056: PPUSH
2057: PPUSH
2058: PPUSH
2059: PPUSH
2060: PPUSH
// if not un or not IsOk ( un ) then
2061: LD_VAR 0 1
2065: NOT
2066: PUSH
2067: LD_VAR 0 1
2071: PPUSH
2072: CALL_OW 302
2076: NOT
2077: OR
2078: IFFALSE 2082
// exit ;
2080: GO 2522
// side := GetSide ( un ) ;
2082: LD_ADDR_VAR 0 9
2086: PUSH
2087: LD_VAR 0 1
2091: PPUSH
2092: CALL_OW 255
2096: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
2097: LD_ADDR_VAR 0 7
2101: PUSH
2102: LD_INT 22
2104: PUSH
2105: LD_VAR 0 9
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: PUSH
2114: LD_INT 30
2116: PUSH
2117: LD_INT 32
2119: PUSH
2120: EMPTY
2121: LIST
2122: LIST
2123: PUSH
2124: LD_INT 50
2126: PUSH
2127: EMPTY
2128: LIST
2129: PUSH
2130: LD_INT 58
2132: PUSH
2133: EMPTY
2134: LIST
2135: PUSH
2136: EMPTY
2137: LIST
2138: LIST
2139: LIST
2140: LIST
2141: PPUSH
2142: CALL_OW 69
2146: PUSH
2147: LD_VAR 0 2
2151: DIFF
2152: ST_TO_ADDR
// if not filter then
2153: LD_VAR 0 7
2157: NOT
2158: IFFALSE 2387
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
2160: LD_ADDR_VAR 0 7
2164: PUSH
2165: LD_INT 22
2167: PUSH
2168: LD_VAR 0 9
2172: PUSH
2173: EMPTY
2174: LIST
2175: LIST
2176: PUSH
2177: LD_INT 30
2179: PUSH
2180: LD_INT 5
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: EMPTY
2188: LIST
2189: LIST
2190: PPUSH
2191: CALL_OW 69
2195: ST_TO_ADDR
// if debug then
2196: LD_EXP 1
2200: IFFALSE 2219
// display_strings := [ filter , 1 ] ;
2202: LD_ADDR_OWVAR 47
2206: PUSH
2207: LD_VAR 0 7
2211: PUSH
2212: LD_STRING 1
2214: PUSH
2215: EMPTY
2216: LIST
2217: LIST
2218: ST_TO_ADDR
// if not filter then
2219: LD_VAR 0 7
2223: NOT
2224: IFFALSE 2247
// begin ComMoveXY ( un , x , y ) ;
2226: LD_VAR 0 1
2230: PPUSH
2231: LD_VAR 0 3
2235: PPUSH
2236: LD_VAR 0 4
2240: PPUSH
2241: CALL_OW 111
// exit ;
2245: GO 2522
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
2247: LD_ADDR_VAR 0 8
2251: PUSH
2252: LD_VAR 0 7
2256: PPUSH
2257: LD_VAR 0 1
2261: PPUSH
2262: CALL_OW 74
2266: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
2267: LD_VAR 0 8
2271: PPUSH
2272: CALL_OW 313
2276: PUSH
2277: LD_INT 6
2279: EQUAL
2280: IFFALSE 2300
// filter := filter diff t else
2282: LD_ADDR_VAR 0 7
2286: PUSH
2287: LD_VAR 0 7
2291: PUSH
2292: LD_VAR 0 8
2296: DIFF
2297: ST_TO_ADDR
2298: GO 2302
// break ;
2300: GO 2324
// until UnitsInside ( t ) < 6 or not filter ;
2302: LD_VAR 0 8
2306: PPUSH
2307: CALL_OW 313
2311: PUSH
2312: LD_INT 6
2314: LESS
2315: PUSH
2316: LD_VAR 0 7
2320: NOT
2321: OR
2322: IFFALSE 2247
// display_strings := [ filter , t ] ;
2324: LD_ADDR_OWVAR 47
2328: PUSH
2329: LD_VAR 0 7
2333: PUSH
2334: LD_VAR 0 8
2338: PUSH
2339: EMPTY
2340: LIST
2341: LIST
2342: ST_TO_ADDR
// if not filter then
2343: LD_VAR 0 7
2347: NOT
2348: IFFALSE 2371
// ComMoveXY ( un , x , y ) else
2350: LD_VAR 0 1
2354: PPUSH
2355: LD_VAR 0 3
2359: PPUSH
2360: LD_VAR 0 4
2364: PPUSH
2365: CALL_OW 111
2369: GO 2385
// ComEnterUnit ( un , t ) ;
2371: LD_VAR 0 1
2375: PPUSH
2376: LD_VAR 0 8
2380: PPUSH
2381: CALL_OW 120
// end else
2385: GO 2522
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
2387: LD_ADDR_VAR 0 8
2391: PUSH
2392: LD_VAR 0 7
2396: PPUSH
2397: LD_VAR 0 1
2401: PPUSH
2402: CALL_OW 74
2406: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
2407: LD_VAR 0 8
2411: PPUSH
2412: CALL_OW 110
2416: PUSH
2417: LD_INT 7
2419: EQUAL
2420: IFFALSE 2438
// filter := filter diff t ;
2422: LD_ADDR_VAR 0 7
2426: PUSH
2427: LD_VAR 0 7
2431: PUSH
2432: LD_VAR 0 8
2436: DIFF
2437: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
2438: LD_VAR 0 8
2442: PPUSH
2443: CALL_OW 110
2447: PUSH
2448: LD_INT 7
2450: NONEQUAL
2451: PUSH
2452: LD_VAR 0 7
2456: NOT
2457: OR
2458: IFFALSE 2387
// if GetTag ( t ) <> 7 then
2460: LD_VAR 0 8
2464: PPUSH
2465: CALL_OW 110
2469: PUSH
2470: LD_INT 7
2472: NONEQUAL
2473: IFFALSE 2503
// begin SetTag ( t , 7 ) ;
2475: LD_VAR 0 8
2479: PPUSH
2480: LD_INT 7
2482: PPUSH
2483: CALL_OW 109
// ComEnterUnit ( un , t ) ;
2487: LD_VAR 0 1
2491: PPUSH
2492: LD_VAR 0 8
2496: PPUSH
2497: CALL_OW 120
// end else
2501: GO 2522
// ComMoveXY ( un , x , y ) ;
2503: LD_VAR 0 1
2507: PPUSH
2508: LD_VAR 0 3
2512: PPUSH
2513: LD_VAR 0 4
2517: PPUSH
2518: CALL_OW 111
// end ; end ;
2522: LD_VAR 0 5
2526: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
2527: LD_INT 0
2529: PPUSH
2530: PPUSH
2531: PPUSH
// if not base then
2532: LD_VAR 0 1
2536: NOT
2537: IFFALSE 2541
// exit ;
2539: GO 2599
// tmp := GetEnergy ( GetBase ( base ) ) ;
2541: LD_ADDR_VAR 0 4
2545: PUSH
2546: LD_VAR 0 1
2550: PPUSH
2551: CALL_OW 274
2555: PPUSH
2556: CALL_OW 278
2560: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
2561: LD_VAR 0 4
2565: PUSH
2566: LD_INT 1
2568: ARRAY
2569: PUSH
2570: LD_VAR 0 4
2574: PUSH
2575: LD_INT 4
2577: ARRAY
2578: GREATER
2579: IFFALSE 2591
// result := true else
2581: LD_ADDR_VAR 0 2
2585: PUSH
2586: LD_INT 1
2588: ST_TO_ADDR
2589: GO 2599
// result := false ;
2591: LD_ADDR_VAR 0 2
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// end ;
2599: LD_VAR 0 2
2603: RET
// export function FilterPeople ( side ) ; begin
2604: LD_INT 0
2606: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
2607: LD_ADDR_VAR 0 2
2611: PUSH
2612: LD_INT 22
2614: PUSH
2615: LD_VAR 0 1
2619: PUSH
2620: EMPTY
2621: LIST
2622: LIST
2623: PUSH
2624: LD_INT 21
2626: PUSH
2627: LD_INT 1
2629: PUSH
2630: EMPTY
2631: LIST
2632: LIST
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PPUSH
2638: CALL_OW 69
2642: ST_TO_ADDR
// end ;
2643: LD_VAR 0 2
2647: RET
// export function FilterDrivers ( side ) ; begin
2648: LD_INT 0
2650: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
2651: LD_ADDR_VAR 0 2
2655: PUSH
2656: LD_INT 22
2658: PUSH
2659: LD_VAR 0 1
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: PUSH
2668: LD_INT 3
2670: PUSH
2671: LD_INT 56
2673: PUSH
2674: EMPTY
2675: LIST
2676: PUSH
2677: EMPTY
2678: LIST
2679: LIST
2680: PUSH
2681: EMPTY
2682: LIST
2683: LIST
2684: PPUSH
2685: CALL_OW 69
2689: ST_TO_ADDR
// end ;
2690: LD_VAR 0 2
2694: RET
// export function FilterPeopleArea ( side , area ) ; begin
2695: LD_INT 0
2697: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
2698: LD_ADDR_VAR 0 3
2702: PUSH
2703: LD_VAR 0 2
2707: PPUSH
2708: LD_INT 22
2710: PUSH
2711: LD_INT 1
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: PUSH
2718: LD_INT 21
2720: PUSH
2721: LD_INT 1
2723: PUSH
2724: EMPTY
2725: LIST
2726: LIST
2727: PUSH
2728: EMPTY
2729: LIST
2730: LIST
2731: PPUSH
2732: CALL_OW 70
2736: ST_TO_ADDR
// end ;
2737: LD_VAR 0 3
2741: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
2742: LD_INT 0
2744: PPUSH
2745: PPUSH
2746: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
2747: LD_ADDR_VAR 0 5
2751: PUSH
2752: LD_VAR 0 2
2756: PPUSH
2757: LD_INT 22
2759: PUSH
2760: LD_INT 1
2762: PUSH
2763: EMPTY
2764: LIST
2765: LIST
2766: PUSH
2767: LD_INT 21
2769: PUSH
2770: LD_INT 2
2772: PUSH
2773: EMPTY
2774: LIST
2775: LIST
2776: PUSH
2777: LD_INT 3
2779: PUSH
2780: LD_INT 58
2782: PUSH
2783: EMPTY
2784: LIST
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: LIST
2794: PPUSH
2795: CALL_OW 70
2799: ST_TO_ADDR
// result := [ ] ;
2800: LD_ADDR_VAR 0 3
2804: PUSH
2805: EMPTY
2806: ST_TO_ADDR
// if not tmp then
2807: LD_VAR 0 5
2811: NOT
2812: IFFALSE 2816
// exit ;
2814: GO 2868
// for i in tmp do
2816: LD_ADDR_VAR 0 4
2820: PUSH
2821: LD_VAR 0 5
2825: PUSH
2826: FOR_IN
2827: IFFALSE 2852
// result := result ^ IsDrivenBy ( i ) ;
2829: LD_ADDR_VAR 0 3
2833: PUSH
2834: LD_VAR 0 3
2838: PUSH
2839: LD_VAR 0 4
2843: PPUSH
2844: CALL_OW 311
2848: ADD
2849: ST_TO_ADDR
2850: GO 2826
2852: POP
2853: POP
// result := result diff 0 ;
2854: LD_ADDR_VAR 0 3
2858: PUSH
2859: LD_VAR 0 3
2863: PUSH
2864: LD_INT 0
2866: DIFF
2867: ST_TO_ADDR
// end ;
2868: LD_VAR 0 3
2872: RET
// export function FilterBuildings ( side ) ; begin
2873: LD_INT 0
2875: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
2876: LD_ADDR_VAR 0 2
2880: PUSH
2881: LD_INT 22
2883: PUSH
2884: LD_VAR 0 1
2888: PUSH
2889: EMPTY
2890: LIST
2891: LIST
2892: PUSH
2893: LD_INT 21
2895: PUSH
2896: LD_INT 3
2898: PUSH
2899: EMPTY
2900: LIST
2901: LIST
2902: PUSH
2903: EMPTY
2904: LIST
2905: LIST
2906: PPUSH
2907: CALL_OW 69
2911: ST_TO_ADDR
// end ;
2912: LD_VAR 0 2
2916: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
2917: LD_INT 0
2919: PPUSH
2920: PPUSH
2921: PPUSH
2922: PPUSH
// uc_side = 0 ;
2923: LD_ADDR_OWVAR 20
2927: PUSH
2928: LD_INT 0
2930: ST_TO_ADDR
// uc_nation = 0 ;
2931: LD_ADDR_OWVAR 21
2935: PUSH
2936: LD_INT 0
2938: ST_TO_ADDR
// nat_area := wildArea ;
2939: LD_ADDR_VAR 0 4
2943: PUSH
2944: LD_INT 3
2946: ST_TO_ADDR
// InitHc ;
2947: CALL_OW 19
// for i = 1 to 4 do
2951: LD_ADDR_VAR 0 2
2955: PUSH
2956: DOUBLE
2957: LD_INT 1
2959: DEC
2960: ST_TO_ADDR
2961: LD_INT 4
2963: PUSH
2964: FOR_TO
2965: IFFALSE 3020
// begin hc_class = 18 ;
2967: LD_ADDR_OWVAR 28
2971: PUSH
2972: LD_INT 18
2974: ST_TO_ADDR
// hc_gallery =  ;
2975: LD_ADDR_OWVAR 33
2979: PUSH
2980: LD_STRING 
2982: ST_TO_ADDR
// hc_face_number = 1 ;
2983: LD_ADDR_OWVAR 34
2987: PUSH
2988: LD_INT 1
2990: ST_TO_ADDR
// animal := CreateHuman ;
2991: LD_ADDR_VAR 0 3
2995: PUSH
2996: CALL_OW 44
3000: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3001: LD_VAR 0 3
3005: PPUSH
3006: LD_VAR 0 4
3010: PPUSH
3011: LD_INT 0
3013: PPUSH
3014: CALL_OW 49
// end ;
3018: GO 2964
3020: POP
3021: POP
// for i = 1 to 6 do
3022: LD_ADDR_VAR 0 2
3026: PUSH
3027: DOUBLE
3028: LD_INT 1
3030: DEC
3031: ST_TO_ADDR
3032: LD_INT 6
3034: PUSH
3035: FOR_TO
3036: IFFALSE 3107
// begin hc_class = class_tiger ;
3038: LD_ADDR_OWVAR 28
3042: PUSH
3043: LD_INT 14
3045: ST_TO_ADDR
// hc_gallery =  ;
3046: LD_ADDR_OWVAR 33
3050: PUSH
3051: LD_STRING 
3053: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 10 ) ;
3054: LD_ADDR_OWVAR 35
3058: PUSH
3059: LD_INT 0
3061: PPUSH
3062: LD_INT 10
3064: PPUSH
3065: CALL_OW 12
3069: ST_TO_ADDR
// hc_face_number = 3 ;
3070: LD_ADDR_OWVAR 34
3074: PUSH
3075: LD_INT 3
3077: ST_TO_ADDR
// animal := CreateHuman ;
3078: LD_ADDR_VAR 0 3
3082: PUSH
3083: CALL_OW 44
3087: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3088: LD_VAR 0 3
3092: PPUSH
3093: LD_VAR 0 4
3097: PPUSH
3098: LD_INT 0
3100: PPUSH
3101: CALL_OW 49
// end ;
3105: GO 3035
3107: POP
3108: POP
// for i = 1 to 2 do
3109: LD_ADDR_VAR 0 2
3113: PUSH
3114: DOUBLE
3115: LD_INT 1
3117: DEC
3118: ST_TO_ADDR
3119: LD_INT 2
3121: PUSH
3122: FOR_TO
3123: IFFALSE 3186
// begin hc_class = 21 ;
3125: LD_ADDR_OWVAR 28
3129: PUSH
3130: LD_INT 21
3132: ST_TO_ADDR
// hc_gallery =  ;
3133: LD_ADDR_OWVAR 33
3137: PUSH
3138: LD_STRING 
3140: ST_TO_ADDR
// hc_agressivity = 0 ;
3141: LD_ADDR_OWVAR 35
3145: PUSH
3146: LD_INT 0
3148: ST_TO_ADDR
// hc_face_number = 5 ;
3149: LD_ADDR_OWVAR 34
3153: PUSH
3154: LD_INT 5
3156: ST_TO_ADDR
// animal := CreateHuman ;
3157: LD_ADDR_VAR 0 3
3161: PUSH
3162: CALL_OW 44
3166: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3167: LD_VAR 0 3
3171: PPUSH
3172: LD_VAR 0 4
3176: PPUSH
3177: LD_INT 0
3179: PPUSH
3180: CALL_OW 49
// end ;
3184: GO 3122
3186: POP
3187: POP
// for i = 1 to 6 do
3188: LD_ADDR_VAR 0 2
3192: PUSH
3193: DOUBLE
3194: LD_INT 1
3196: DEC
3197: ST_TO_ADDR
3198: LD_INT 6
3200: PUSH
3201: FOR_TO
3202: IFFALSE 3257
// begin hc_class = 13 ;
3204: LD_ADDR_OWVAR 28
3208: PUSH
3209: LD_INT 13
3211: ST_TO_ADDR
// hc_gallery =  ;
3212: LD_ADDR_OWVAR 33
3216: PUSH
3217: LD_STRING 
3219: ST_TO_ADDR
// hc_face_number = 4 ;
3220: LD_ADDR_OWVAR 34
3224: PUSH
3225: LD_INT 4
3227: ST_TO_ADDR
// animal := CreateHuman ;
3228: LD_ADDR_VAR 0 3
3232: PUSH
3233: CALL_OW 44
3237: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3238: LD_VAR 0 3
3242: PPUSH
3243: LD_VAR 0 4
3247: PPUSH
3248: LD_INT 0
3250: PPUSH
3251: CALL_OW 49
// end ;
3255: GO 3201
3257: POP
3258: POP
// for i = 1 to 2 do
3259: LD_ADDR_VAR 0 2
3263: PUSH
3264: DOUBLE
3265: LD_INT 1
3267: DEC
3268: ST_TO_ADDR
3269: LD_INT 2
3271: PUSH
3272: FOR_TO
3273: IFFALSE 3332
// begin hc_class = 20 ;
3275: LD_ADDR_OWVAR 28
3279: PUSH
3280: LD_INT 20
3282: ST_TO_ADDR
// hc_gallery =  ;
3283: LD_ADDR_OWVAR 33
3287: PUSH
3288: LD_STRING 
3290: ST_TO_ADDR
// hc_face_number = 2 ;
3291: LD_ADDR_OWVAR 34
3295: PUSH
3296: LD_INT 2
3298: ST_TO_ADDR
// animal := CreateHuman ;
3299: LD_ADDR_VAR 0 3
3303: PUSH
3304: CALL_OW 44
3308: ST_TO_ADDR
// PlaceUnitXYR ( animal , 101 , 37 , 3 , false ) ;
3309: LD_VAR 0 3
3313: PPUSH
3314: LD_INT 101
3316: PPUSH
3317: LD_INT 37
3319: PPUSH
3320: LD_INT 3
3322: PPUSH
3323: LD_INT 0
3325: PPUSH
3326: CALL_OW 50
// end ;
3330: GO 3272
3332: POP
3333: POP
// for i = 1 to 1 do
3334: LD_ADDR_VAR 0 2
3338: PUSH
3339: DOUBLE
3340: LD_INT 1
3342: DEC
3343: ST_TO_ADDR
3344: LD_INT 1
3346: PUSH
3347: FOR_TO
3348: IFFALSE 3395
// begin vc_chassis := 31 ;
3350: LD_ADDR_OWVAR 37
3354: PUSH
3355: LD_INT 31
3357: ST_TO_ADDR
// vc_control := control_rider ;
3358: LD_ADDR_OWVAR 38
3362: PUSH
3363: LD_INT 4
3365: ST_TO_ADDR
// animal := CreateVehicle ;
3366: LD_ADDR_VAR 0 3
3370: PUSH
3371: CALL_OW 45
3375: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
3376: LD_VAR 0 3
3380: PPUSH
3381: LD_VAR 0 4
3385: PPUSH
3386: LD_INT 0
3388: PPUSH
3389: CALL_OW 49
// end ;
3393: GO 3347
3395: POP
3396: POP
// end ; end_of_file
3397: LD_VAR 0 1
3401: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
3402: LD_INT 0
3404: PPUSH
3405: PPUSH
3406: PPUSH
3407: PPUSH
3408: PPUSH
3409: PPUSH
// uc_side := 1 ;
3410: LD_ADDR_OWVAR 20
3414: PUSH
3415: LD_INT 1
3417: ST_TO_ADDR
// uc_nation := 1 ;
3418: LD_ADDR_OWVAR 21
3422: PUSH
3423: LD_INT 1
3425: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
3426: LD_ADDR_EXP 8
3430: PUSH
3431: LD_STRING JMM
3433: PPUSH
3434: LD_EXP 1
3438: NOT
3439: PPUSH
3440: CALL 354 0 2
3444: ST_TO_ADDR
// team := [ JMM ] ;
3445: LD_ADDR_VAR 0 3
3449: PUSH
3450: LD_EXP 8
3454: PUSH
3455: EMPTY
3456: LIST
3457: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
3458: LD_STRING BrownIn07
3460: PPUSH
3461: LD_EXP 1
3465: PPUSH
3466: CALL_OW 30
3470: IFFALSE 3491
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
3472: LD_ADDR_EXP 9
3476: PUSH
3477: LD_STRING Brown
3479: PPUSH
3480: LD_EXP 1
3484: NOT
3485: PPUSH
3486: CALL 354 0 2
3490: ST_TO_ADDR
// if Brown then
3491: LD_EXP 9
3495: IFFALSE 3513
// team := team ^ Brown ;
3497: LD_ADDR_VAR 0 3
3501: PUSH
3502: LD_VAR 0 3
3506: PUSH
3507: LD_EXP 9
3511: ADD
3512: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
3513: LD_STRING DonaldsonIn07
3515: PPUSH
3516: LD_EXP 1
3520: PPUSH
3521: CALL_OW 30
3525: IFFALSE 3546
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
3527: LD_ADDR_EXP 10
3531: PUSH
3532: LD_STRING Donaldson
3534: PPUSH
3535: LD_EXP 1
3539: NOT
3540: PPUSH
3541: CALL 354 0 2
3545: ST_TO_ADDR
// if Donaldson then
3546: LD_EXP 10
3550: IFFALSE 3568
// team := team ^ Donaldson ;
3552: LD_ADDR_VAR 0 3
3556: PUSH
3557: LD_VAR 0 3
3561: PUSH
3562: LD_EXP 10
3566: ADD
3567: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
3568: LD_STRING BobbyIn07
3570: PPUSH
3571: LD_EXP 1
3575: PPUSH
3576: CALL_OW 30
3580: IFFALSE 3601
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
3582: LD_ADDR_EXP 11
3586: PUSH
3587: LD_STRING Bobby
3589: PPUSH
3590: LD_EXP 1
3594: NOT
3595: PPUSH
3596: CALL 354 0 2
3600: ST_TO_ADDR
// if Bobby then
3601: LD_EXP 11
3605: IFFALSE 3623
// team := team ^ Bobby ;
3607: LD_ADDR_VAR 0 3
3611: PUSH
3612: LD_VAR 0 3
3616: PUSH
3617: LD_EXP 11
3621: ADD
3622: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
3623: LD_STRING CyrusIn07
3625: PPUSH
3626: LD_EXP 1
3630: PPUSH
3631: CALL_OW 30
3635: IFFALSE 3656
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
3637: LD_ADDR_EXP 12
3641: PUSH
3642: LD_STRING Cyrus
3644: PPUSH
3645: LD_EXP 1
3649: NOT
3650: PPUSH
3651: CALL 354 0 2
3655: ST_TO_ADDR
// if Cyrus then
3656: LD_EXP 12
3660: IFFALSE 3678
// team := team ^ Cyrus ;
3662: LD_ADDR_VAR 0 3
3666: PUSH
3667: LD_VAR 0 3
3671: PUSH
3672: LD_EXP 12
3676: ADD
3677: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
3678: LD_STRING LisaIn07
3680: PPUSH
3681: LD_EXP 1
3685: PPUSH
3686: CALL_OW 30
3690: IFFALSE 3711
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
3692: LD_ADDR_EXP 13
3696: PUSH
3697: LD_STRING Lisa
3699: PPUSH
3700: LD_EXP 1
3704: NOT
3705: PPUSH
3706: CALL 354 0 2
3710: ST_TO_ADDR
// if Lisa then
3711: LD_EXP 13
3715: IFFALSE 3733
// team := team ^ Lisa ;
3717: LD_ADDR_VAR 0 3
3721: PUSH
3722: LD_VAR 0 3
3726: PUSH
3727: LD_EXP 13
3731: ADD
3732: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
3733: LD_STRING GladstoneIn07
3735: PPUSH
3736: LD_EXP 1
3740: PPUSH
3741: CALL_OW 30
3745: IFFALSE 3766
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
3747: LD_ADDR_EXP 15
3751: PUSH
3752: LD_STRING Gladstone
3754: PPUSH
3755: LD_EXP 1
3759: NOT
3760: PPUSH
3761: CALL 354 0 2
3765: ST_TO_ADDR
// if Gladstone then
3766: LD_EXP 15
3770: IFFALSE 3788
// team := team ^ Gladstone ;
3772: LD_ADDR_VAR 0 3
3776: PUSH
3777: LD_VAR 0 3
3781: PUSH
3782: LD_EXP 15
3786: ADD
3787: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
3788: LD_STRING KhatamIn07
3790: PPUSH
3791: LD_EXP 1
3795: PPUSH
3796: CALL_OW 30
3800: IFFALSE 3821
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
3802: LD_ADDR_EXP 16
3806: PUSH
3807: LD_STRING Khatam
3809: PPUSH
3810: LD_EXP 1
3814: NOT
3815: PPUSH
3816: CALL 354 0 2
3820: ST_TO_ADDR
// if Khatam then
3821: LD_EXP 16
3825: IFFALSE 3843
// team := team ^ Khatam ;
3827: LD_ADDR_VAR 0 3
3831: PUSH
3832: LD_VAR 0 3
3836: PUSH
3837: LD_EXP 16
3841: ADD
3842: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
3843: LD_ADDR_VAR 0 4
3847: PUSH
3848: LD_STRING 07_others
3850: PPUSH
3851: CALL_OW 31
3855: ST_TO_ADDR
// if others then
3856: LD_VAR 0 4
3860: IFFALSE 3878
// team := team ^ others ;
3862: LD_ADDR_VAR 0 3
3866: PUSH
3867: LD_VAR 0 3
3871: PUSH
3872: LD_VAR 0 4
3876: ADD
3877: ST_TO_ADDR
// if debug then
3878: LD_EXP 1
3882: IFFALSE 3956
// begin InitHc ;
3884: CALL_OW 19
// for i = 1 to 4 do
3888: LD_ADDR_VAR 0 2
3892: PUSH
3893: DOUBLE
3894: LD_INT 1
3896: DEC
3897: ST_TO_ADDR
3898: LD_INT 4
3900: PUSH
3901: FOR_TO
3902: IFFALSE 3954
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
3904: LD_INT 0
3906: PPUSH
3907: LD_INT 1
3909: PUSH
3910: LD_INT 3
3912: PUSH
3913: EMPTY
3914: LIST
3915: LIST
3916: PUSH
3917: LD_INT 1
3919: PPUSH
3920: LD_INT 2
3922: PPUSH
3923: CALL_OW 12
3927: ARRAY
3928: PPUSH
3929: LD_INT 4
3931: PPUSH
3932: CALL_OW 380
// team := team ^ CreateHuman ;
3936: LD_ADDR_VAR 0 3
3940: PUSH
3941: LD_VAR 0 3
3945: PUSH
3946: CALL_OW 44
3950: ADD
3951: ST_TO_ADDR
// end ;
3952: GO 3901
3954: POP
3955: POP
// end ; m := 0 ;
3956: LD_ADDR_VAR 0 6
3960: PUSH
3961: LD_INT 0
3963: ST_TO_ADDR
// for i in team do
3964: LD_ADDR_VAR 0 2
3968: PUSH
3969: LD_VAR 0 3
3973: PUSH
3974: FOR_IN
3975: IFFALSE 4155
// if GetClass ( i ) = 3 then
3977: LD_VAR 0 2
3981: PPUSH
3982: CALL_OW 257
3986: PUSH
3987: LD_INT 3
3989: EQUAL
3990: IFFALSE 4138
// begin m := m + 1 ;
3992: LD_ADDR_VAR 0 6
3996: PUSH
3997: LD_VAR 0 6
4001: PUSH
4002: LD_INT 1
4004: PLUS
4005: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
4006: LD_ADDR_VAR 0 5
4010: PUSH
4011: LD_INT 1
4013: PPUSH
4014: LD_INT 1
4016: PPUSH
4017: LD_INT 2
4019: PUSH
4020: LD_INT 3
4022: PUSH
4023: LD_INT 2
4025: PUSH
4026: LD_INT 1
4028: PUSH
4029: EMPTY
4030: LIST
4031: LIST
4032: LIST
4033: LIST
4034: PUSH
4035: LD_VAR 0 6
4039: PUSH
4040: LD_INT 4
4042: MOD
4043: PUSH
4044: LD_INT 1
4046: PLUS
4047: ARRAY
4048: PPUSH
4049: LD_INT 2
4051: PPUSH
4052: LD_INT 1
4054: PPUSH
4055: LD_INT 4
4057: PUSH
4058: LD_INT 5
4060: PUSH
4061: LD_INT 3
4063: PUSH
4064: LD_INT 11
4066: PUSH
4067: EMPTY
4068: LIST
4069: LIST
4070: LIST
4071: LIST
4072: PUSH
4073: LD_VAR 0 6
4077: PUSH
4078: LD_INT 4
4080: MOD
4081: PUSH
4082: LD_INT 1
4084: PLUS
4085: ARRAY
4086: PPUSH
4087: LD_INT 60
4089: PPUSH
4090: CALL 417 0 7
4094: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
4095: LD_VAR 0 5
4099: PPUSH
4100: LD_INT 2
4102: PPUSH
4103: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
4107: LD_VAR 0 5
4111: PPUSH
4112: LD_INT 1
4114: PPUSH
4115: LD_INT 0
4117: PPUSH
4118: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4122: LD_VAR 0 2
4126: PPUSH
4127: LD_VAR 0 5
4131: PPUSH
4132: CALL_OW 52
// end else
4136: GO 4153
// PlaceUnitArea ( i , startArea , false ) ;
4138: LD_VAR 0 2
4142: PPUSH
4143: LD_INT 1
4145: PPUSH
4146: LD_INT 0
4148: PPUSH
4149: CALL_OW 49
4153: GO 3974
4155: POP
4156: POP
// uc_side := 4 ;
4157: LD_ADDR_OWVAR 20
4161: PUSH
4162: LD_INT 4
4164: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
4165: LD_ADDR_EXP 18
4169: PUSH
4170: LD_STRING Harisson
4172: PPUSH
4173: LD_INT 0
4175: PPUSH
4176: CALL 354 0 2
4180: ST_TO_ADDR
// PrepareScout ;
4181: CALL 4190 0 0
// end ;
4185: LD_VAR 0 1
4189: RET
// function PrepareScout ; var ape ; begin
4190: LD_INT 0
4192: PPUSH
4193: PPUSH
// uc_side := 4 ;
4194: LD_ADDR_OWVAR 20
4198: PUSH
4199: LD_INT 4
4201: ST_TO_ADDR
// uc_nation := 1 ;
4202: LD_ADDR_OWVAR 21
4206: PUSH
4207: LD_INT 1
4209: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
4210: LD_STRING FrankIn06
4212: PPUSH
4213: LD_INT 0
4215: PPUSH
4216: CALL_OW 30
4220: IFFALSE 4237
// Frank := CreateCharacter ( 06c_Frank ) else
4222: LD_ADDR_EXP 14
4226: PUSH
4227: LD_STRING 06c_Frank
4229: PPUSH
4230: CALL_OW 34
4234: ST_TO_ADDR
4235: GO 4277
// if LoadVariable ( FrankInDelta , 0 ) then
4237: LD_STRING FrankInDelta
4239: PPUSH
4240: LD_INT 0
4242: PPUSH
4243: CALL_OW 30
4247: IFFALSE 4264
// Frank := CreateCharacter ( 05_Frank ) else
4249: LD_ADDR_EXP 14
4253: PUSH
4254: LD_STRING 05_Frank
4256: PPUSH
4257: CALL_OW 34
4261: ST_TO_ADDR
4262: GO 4277
// Frank := CreateCharacter ( 04_Frank ) ;
4264: LD_ADDR_EXP 14
4268: PUSH
4269: LD_STRING 04_Frank
4271: PPUSH
4272: CALL_OW 34
4276: ST_TO_ADDR
// if Frank then
4277: LD_EXP 14
4281: IFFALSE 4414
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
4283: LD_EXP 14
4287: PPUSH
4288: LD_INT 2
4290: PPUSH
4291: LD_INT 0
4293: PPUSH
4294: CALL_OW 49
// SetClass ( Frank , 1 ) ;
4298: LD_EXP 14
4302: PPUSH
4303: LD_INT 1
4305: PPUSH
4306: CALL_OW 336
// uc_side := 0 ;
4310: LD_ADDR_OWVAR 20
4314: PUSH
4315: LD_INT 0
4317: ST_TO_ADDR
// uc_nation := 0 ;
4318: LD_ADDR_OWVAR 21
4322: PUSH
4323: LD_INT 0
4325: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
4326: LD_INT 0
4328: PPUSH
4329: LD_INT 12
4331: PPUSH
4332: LD_INT 0
4334: PPUSH
4335: CALL_OW 380
// ape := CreateHuman ;
4339: LD_ADDR_VAR 0 2
4343: PUSH
4344: CALL_OW 44
4348: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
4349: LD_VAR 0 2
4353: PPUSH
4354: LD_EXP 14
4358: PPUSH
4359: CALL_OW 250
4363: PPUSH
4364: LD_EXP 14
4368: PPUSH
4369: CALL_OW 251
4373: PPUSH
4374: LD_INT 5
4376: PPUSH
4377: LD_INT 0
4379: PPUSH
4380: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
4384: LD_VAR 0 2
4388: PPUSH
4389: LD_EXP 14
4393: PPUSH
4394: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
4398: LD_EXP 14
4402: PPUSH
4403: LD_VAR 0 2
4407: PPUSH
4408: CALL_OW 119
// exit ;
4412: GO 4454
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
4414: LD_ADDR_EXP 17
4418: PUSH
4419: LD_STRING Yamoko
4421: PPUSH
4422: LD_INT 0
4424: PPUSH
4425: CALL 354 0 2
4429: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
4430: LD_EXP 17
4434: PPUSH
4435: LD_INT 2
4437: PPUSH
4438: LD_INT 0
4440: PPUSH
4441: CALL_OW 49
// ComHold ( Kikuchi ) ;
4445: LD_EXP 17
4449: PPUSH
4450: CALL_OW 140
// end ; end_of_file
4454: LD_VAR 0 1
4458: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
4459: LD_INT 0
4461: PPUSH
4462: PPUSH
4463: PPUSH
4464: PPUSH
4465: PPUSH
4466: PPUSH
4467: PPUSH
4468: PPUSH
4469: PPUSH
4470: PPUSH
4471: PPUSH
4472: PPUSH
4473: PPUSH
4474: PPUSH
4475: PPUSH
4476: PPUSH
// ru_rebuild_list := [ ] ;
4477: LD_ADDR_EXP 19
4481: PUSH
4482: EMPTY
4483: ST_TO_ADDR
// uc_side := 3 ;
4484: LD_ADDR_OWVAR 20
4488: PUSH
4489: LD_INT 3
4491: ST_TO_ADDR
// uc_nation := 3 ;
4492: LD_ADDR_OWVAR 21
4496: PUSH
4497: LD_INT 3
4499: ST_TO_ADDR
// if Difficulty > 1 then
4500: LD_OWVAR 67
4504: PUSH
4505: LD_INT 1
4507: GREATER
4508: IFFALSE 4644
// begin bc_type := b_breastwork ;
4510: LD_ADDR_OWVAR 42
4514: PUSH
4515: LD_INT 31
4517: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
4518: LD_INT 78
4520: PPUSH
4521: LD_INT 74
4523: PPUSH
4524: LD_INT 2
4526: PPUSH
4527: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
4531: LD_INT 171
4533: PPUSH
4534: LD_INT 193
4536: PPUSH
4537: LD_INT 4
4539: PPUSH
4540: CALL_OW 47
// bc_type := b_turret ;
4544: LD_ADDR_OWVAR 42
4548: PUSH
4549: LD_INT 33
4551: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
4552: LD_INT 129
4554: PPUSH
4555: LD_INT 96
4557: PPUSH
4558: LD_INT 3
4560: PPUSH
4561: CALL_OW 47
// if Difficulty > 2 then
4565: LD_OWVAR 67
4569: PUSH
4570: LD_INT 2
4572: GREATER
4573: IFFALSE 4644
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
4575: LD_INT 83
4577: PPUSH
4578: LD_INT 141
4580: PPUSH
4581: CALL_OW 428
4585: PPUSH
4586: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
4590: LD_INT 78
4592: PPUSH
4593: LD_INT 133
4595: PPUSH
4596: CALL_OW 428
4600: PPUSH
4601: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
4605: LD_INT 83
4607: PPUSH
4608: LD_INT 141
4610: PPUSH
4611: LD_INT 2
4613: PPUSH
4614: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
4618: LD_INT 78
4620: PPUSH
4621: LD_INT 133
4623: PPUSH
4624: LD_INT 2
4626: PPUSH
4627: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
4631: LD_INT 145
4633: PPUSH
4634: LD_INT 112
4636: PPUSH
4637: LD_INT 3
4639: PPUSH
4640: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
4644: LD_ADDR_VAR 0 9
4648: PUSH
4649: LD_INT 22
4651: PUSH
4652: LD_INT 3
4654: PUSH
4655: EMPTY
4656: LIST
4657: LIST
4658: PUSH
4659: LD_INT 2
4661: PUSH
4662: LD_INT 30
4664: PUSH
4665: LD_INT 0
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: PUSH
4672: LD_INT 30
4674: PUSH
4675: LD_INT 1
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: LIST
4686: PUSH
4687: EMPTY
4688: LIST
4689: LIST
4690: PPUSH
4691: CALL_OW 69
4695: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
4696: LD_ADDR_VAR 0 10
4700: PUSH
4701: LD_INT 22
4703: PUSH
4704: LD_INT 3
4706: PUSH
4707: EMPTY
4708: LIST
4709: LIST
4710: PUSH
4711: LD_INT 2
4713: PUSH
4714: LD_INT 30
4716: PUSH
4717: LD_INT 6
4719: PUSH
4720: EMPTY
4721: LIST
4722: LIST
4723: PUSH
4724: LD_INT 30
4726: PUSH
4727: LD_INT 7
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PUSH
4734: LD_INT 30
4736: PUSH
4737: LD_INT 8
4739: PUSH
4740: EMPTY
4741: LIST
4742: LIST
4743: PUSH
4744: EMPTY
4745: LIST
4746: LIST
4747: LIST
4748: LIST
4749: PUSH
4750: EMPTY
4751: LIST
4752: LIST
4753: PPUSH
4754: CALL_OW 69
4758: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
4759: LD_ADDR_VAR 0 11
4763: PUSH
4764: LD_INT 22
4766: PUSH
4767: LD_INT 3
4769: PUSH
4770: EMPTY
4771: LIST
4772: LIST
4773: PUSH
4774: LD_INT 30
4776: PUSH
4777: LD_INT 3
4779: PUSH
4780: EMPTY
4781: LIST
4782: LIST
4783: PUSH
4784: EMPTY
4785: LIST
4786: LIST
4787: PPUSH
4788: CALL_OW 69
4792: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
4793: LD_ADDR_VAR 0 12
4797: PUSH
4798: LD_INT 22
4800: PUSH
4801: LD_INT 3
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PUSH
4808: LD_INT 30
4810: PUSH
4811: LD_INT 31
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: EMPTY
4819: LIST
4820: LIST
4821: PPUSH
4822: CALL_OW 69
4826: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
4827: LD_ADDR_VAR 0 13
4831: PUSH
4832: LD_INT 22
4834: PUSH
4835: LD_INT 3
4837: PUSH
4838: EMPTY
4839: LIST
4840: LIST
4841: PUSH
4842: LD_INT 30
4844: PUSH
4845: LD_INT 32
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: PUSH
4852: EMPTY
4853: LIST
4854: LIST
4855: PPUSH
4856: CALL_OW 69
4860: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
4861: LD_ADDR_VAR 0 14
4865: PUSH
4866: LD_INT 22
4868: PUSH
4869: LD_INT 3
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: PUSH
4876: LD_INT 30
4878: PUSH
4879: LD_INT 33
4881: PUSH
4882: EMPTY
4883: LIST
4884: LIST
4885: PUSH
4886: EMPTY
4887: LIST
4888: LIST
4889: PPUSH
4890: CALL_OW 69
4894: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
4895: LD_ADDR_VAR 0 15
4899: PUSH
4900: LD_INT 42
4902: PUSH
4903: LD_INT 5
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: PUSH
4910: LD_INT 43
4912: PUSH
4913: LD_INT 50
4915: PUSH
4916: EMPTY
4917: LIST
4918: LIST
4919: PUSH
4920: LD_INT 44
4922: PUSH
4923: LD_INT 30
4925: PUSH
4926: EMPTY
4927: LIST
4928: LIST
4929: PUSH
4930: LD_INT 46
4932: PUSH
4933: LD_INT 15
4935: PUSH
4936: EMPTY
4937: LIST
4938: LIST
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: LIST
4944: LIST
4945: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 6 , 3 ] ;
4946: LD_ADDR_VAR 0 16
4950: PUSH
4951: LD_INT 0
4953: PUSH
4954: LD_INT 4
4956: PUSH
4957: LD_INT 6
4959: PUSH
4960: LD_INT 3
4962: PUSH
4963: EMPTY
4964: LIST
4965: LIST
4966: LIST
4967: LIST
4968: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
4969: LD_ADDR_VAR 0 6
4973: PUSH
4974: LD_INT 4
4976: PUSH
4977: LD_INT 5
4979: PUSH
4980: LD_INT 6
4982: PUSH
4983: EMPTY
4984: LIST
4985: LIST
4986: LIST
4987: PUSH
4988: LD_OWVAR 67
4992: ARRAY
4993: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
4994: LD_INT 16
4996: PPUSH
4997: LD_STRING am_tukh
4999: PPUSH
5000: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
5004: LD_ADDR_VAR 0 2
5008: PUSH
5009: LD_INT 21
5011: PUSH
5012: LD_INT 3
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: PPUSH
5019: CALL_OW 69
5023: PUSH
5024: FOR_IN
5025: IFFALSE 5058
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
5027: LD_VAR 0 2
5031: PPUSH
5032: LD_INT 4
5034: PUSH
5035: LD_INT 5
5037: PUSH
5038: LD_INT 6
5040: PUSH
5041: EMPTY
5042: LIST
5043: LIST
5044: LIST
5045: PUSH
5046: LD_OWVAR 67
5050: ARRAY
5051: PPUSH
5052: CALL_OW 241
5056: GO 5024
5058: POP
5059: POP
// for i in dep_list do
5060: LD_ADDR_VAR 0 2
5064: PUSH
5065: LD_VAR 0 9
5069: PUSH
5070: FOR_IN
5071: IFFALSE 5115
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
5073: LD_VAR 0 2
5077: PPUSH
5078: CALL_OW 274
5082: PPUSH
5083: LD_INT 1
5085: PPUSH
5086: LD_INT 1000
5088: PPUSH
5089: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
5093: LD_VAR 0 2
5097: PPUSH
5098: CALL_OW 274
5102: PPUSH
5103: LD_INT 2
5105: PPUSH
5106: LD_INT 1000
5108: PPUSH
5109: CALL_OW 277
// end ;
5113: GO 5070
5115: POP
5116: POP
// InitHc ;
5117: CALL_OW 19
// tmp := bunker_list * [ 45 , 60 , 75 ] [ Difficulty ] div 100 ;
5121: LD_ADDR_VAR 0 8
5125: PUSH
5126: LD_VAR 0 13
5130: PUSH
5131: LD_INT 45
5133: PUSH
5134: LD_INT 60
5136: PUSH
5137: LD_INT 75
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: LIST
5144: PUSH
5145: LD_OWVAR 67
5149: ARRAY
5150: MUL
5151: PUSH
5152: LD_INT 100
5154: DIV
5155: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
5156: LD_ADDR_VAR 0 16
5160: PUSH
5161: LD_VAR 0 16
5165: PPUSH
5166: LD_INT 1
5168: PPUSH
5169: LD_VAR 0 8
5173: PPUSH
5174: CALL_OW 1
5178: ST_TO_ADDR
// tmp := [ ] ;
5179: LD_ADDR_VAR 0 8
5183: PUSH
5184: EMPTY
5185: ST_TO_ADDR
// for i in bunker_list do
5186: LD_ADDR_VAR 0 2
5190: PUSH
5191: LD_VAR 0 13
5195: PUSH
5196: FOR_IN
5197: IFFALSE 5293
// if i mod 10 + 1 < tmp then
5199: LD_VAR 0 2
5203: PUSH
5204: LD_INT 10
5206: MOD
5207: PUSH
5208: LD_INT 1
5210: PLUS
5211: PUSH
5212: LD_VAR 0 8
5216: LESS
5217: IFFALSE 5262
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
5219: LD_ADDR_VAR 0 8
5223: PUSH
5224: LD_VAR 0 8
5228: PPUSH
5229: LD_VAR 0 2
5233: PUSH
5234: LD_INT 3
5236: PPUSH
5237: LD_INT 5
5239: PPUSH
5240: CALL_OW 12
5244: MOD
5245: PUSH
5246: LD_INT 1
5248: PLUS
5249: PPUSH
5250: LD_VAR 0 2
5254: PPUSH
5255: CALL_OW 2
5259: ST_TO_ADDR
5260: GO 5291
// tmp := Insert ( tmp , tmp + 1 , i ) ;
5262: LD_ADDR_VAR 0 8
5266: PUSH
5267: LD_VAR 0 8
5271: PPUSH
5272: LD_VAR 0 8
5276: PUSH
5277: LD_INT 1
5279: PLUS
5280: PPUSH
5281: LD_VAR 0 2
5285: PPUSH
5286: CALL_OW 2
5290: ST_TO_ADDR
5291: GO 5196
5293: POP
5294: POP
// bunker_list := tmp ;
5295: LD_ADDR_VAR 0 13
5299: PUSH
5300: LD_VAR 0 8
5304: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
5305: LD_ADDR_VAR 0 2
5309: PUSH
5310: LD_VAR 0 13
5314: PUSH
5315: LD_VAR 0 14
5319: ADD
5320: PUSH
5321: FOR_IN
5322: IFFALSE 5345
// PlaceWeaponTurret ( i , GetTurretWeapon ( i ) ) ;
5324: LD_VAR 0 2
5328: PPUSH
5329: LD_VAR 0 2
5333: PPUSH
5334: CALL 831 0 1
5338: PPUSH
5339: CALL_OW 431
5343: GO 5321
5345: POP
5346: POP
// while ( personel_counter [ 1 ] ) do
5347: LD_VAR 0 16
5351: PUSH
5352: LD_INT 1
5354: ARRAY
5355: IFFALSE 5463
// begin i := rand ( 1 , bunker_list ) ;
5357: LD_ADDR_VAR 0 2
5361: PUSH
5362: LD_INT 1
5364: PPUSH
5365: LD_VAR 0 13
5369: PPUSH
5370: CALL_OW 12
5374: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5375: LD_INT 0
5377: PPUSH
5378: LD_INT 1
5380: PPUSH
5381: LD_VAR 0 6
5385: PPUSH
5386: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
5390: CALL_OW 44
5394: PPUSH
5395: LD_VAR 0 13
5399: PUSH
5400: LD_VAR 0 2
5404: ARRAY
5405: PPUSH
5406: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
5410: LD_ADDR_VAR 0 13
5414: PUSH
5415: LD_VAR 0 13
5419: PPUSH
5420: LD_VAR 0 2
5424: PPUSH
5425: CALL_OW 3
5429: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
5430: LD_ADDR_VAR 0 16
5434: PUSH
5435: LD_VAR 0 16
5439: PPUSH
5440: LD_INT 1
5442: PPUSH
5443: LD_VAR 0 16
5447: PUSH
5448: LD_INT 1
5450: ARRAY
5451: PUSH
5452: LD_INT 1
5454: MINUS
5455: PPUSH
5456: CALL_OW 1
5460: ST_TO_ADDR
// end ;
5461: GO 5347
// for i = 1 to personel_counter [ 2 ] do
5463: LD_ADDR_VAR 0 2
5467: PUSH
5468: DOUBLE
5469: LD_INT 1
5471: DEC
5472: ST_TO_ADDR
5473: LD_VAR 0 16
5477: PUSH
5478: LD_INT 2
5480: ARRAY
5481: PUSH
5482: FOR_TO
5483: IFFALSE 5514
// begin PrepareHuman ( false , 2 , skill ) ;
5485: LD_INT 0
5487: PPUSH
5488: LD_INT 2
5490: PPUSH
5491: LD_VAR 0 6
5495: PPUSH
5496: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
5500: CALL_OW 44
5504: PPUSH
5505: LD_INT 16
5507: PPUSH
5508: CALL_OW 52
// end ;
5512: GO 5482
5514: POP
5515: POP
// for i = 1 to personel_counter [ 3 ] do
5516: LD_ADDR_VAR 0 2
5520: PUSH
5521: DOUBLE
5522: LD_INT 1
5524: DEC
5525: ST_TO_ADDR
5526: LD_VAR 0 16
5530: PUSH
5531: LD_INT 3
5533: ARRAY
5534: PUSH
5535: FOR_TO
5536: IFFALSE 5583
// begin PrepareHuman ( false , 3 , skill ) ;
5538: LD_INT 0
5540: PPUSH
5541: LD_INT 3
5543: PPUSH
5544: LD_VAR 0 6
5548: PPUSH
5549: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ i mod 2 + 1 ] ) ;
5553: CALL_OW 44
5557: PPUSH
5558: LD_VAR 0 11
5562: PUSH
5563: LD_VAR 0 2
5567: PUSH
5568: LD_INT 2
5570: MOD
5571: PUSH
5572: LD_INT 1
5574: PLUS
5575: ARRAY
5576: PPUSH
5577: CALL_OW 52
// end ;
5581: GO 5535
5583: POP
5584: POP
// for i = 1 to personel_counter [ 4 ] do
5585: LD_ADDR_VAR 0 2
5589: PUSH
5590: DOUBLE
5591: LD_INT 1
5593: DEC
5594: ST_TO_ADDR
5595: LD_VAR 0 16
5599: PUSH
5600: LD_INT 4
5602: ARRAY
5603: PUSH
5604: FOR_TO
5605: IFFALSE 5642
// begin PrepareHuman ( false , 4 , skill ) ;
5607: LD_INT 0
5609: PPUSH
5610: LD_INT 4
5612: PPUSH
5613: LD_VAR 0 6
5617: PPUSH
5618: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
5622: CALL_OW 44
5626: PPUSH
5627: LD_VAR 0 10
5631: PUSH
5632: LD_INT 1
5634: ARRAY
5635: PPUSH
5636: CALL_OW 52
// end ;
5640: GO 5604
5642: POP
5643: POP
// for i in breastworks_list do
5644: LD_ADDR_VAR 0 2
5648: PUSH
5649: LD_VAR 0 12
5653: PUSH
5654: FOR_IN
5655: IFFALSE 5767
// begin r := GetDir ( i ) ;
5657: LD_ADDR_VAR 0 4
5661: PUSH
5662: LD_VAR 0 2
5666: PPUSH
5667: CALL_OW 254
5671: ST_TO_ADDR
// if r > 3 then
5672: LD_VAR 0 4
5676: PUSH
5677: LD_INT 3
5679: GREATER
5680: IFFALSE 5698
// r := r - 3 else
5682: LD_ADDR_VAR 0 4
5686: PUSH
5687: LD_VAR 0 4
5691: PUSH
5692: LD_INT 3
5694: MINUS
5695: ST_TO_ADDR
5696: GO 5712
// r := r + 3 ;
5698: LD_ADDR_VAR 0 4
5702: PUSH
5703: LD_VAR 0 4
5707: PUSH
5708: LD_INT 3
5710: PLUS
5711: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
5712: LD_INT 0
5714: PPUSH
5715: LD_INT 1
5717: PPUSH
5718: LD_VAR 0 6
5722: PPUSH
5723: CALL_OW 380
// un := CreateHuman ;
5727: LD_ADDR_VAR 0 5
5731: PUSH
5732: CALL_OW 44
5736: ST_TO_ADDR
// SetDir ( un , r ) ;
5737: LD_VAR 0 5
5741: PPUSH
5742: LD_VAR 0 4
5746: PPUSH
5747: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
5751: LD_VAR 0 5
5755: PPUSH
5756: LD_VAR 0 2
5760: PPUSH
5761: CALL_OW 52
// end ;
5765: GO 5654
5767: POP
5768: POP
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
5769: LD_ADDR_VAR 0 8
5773: PUSH
5774: LD_INT 22
5776: PUSH
5777: LD_INT 3
5779: PUSH
5780: EMPTY
5781: LIST
5782: LIST
5783: PUSH
5784: LD_INT 25
5786: PUSH
5787: LD_INT 3
5789: PUSH
5790: EMPTY
5791: LIST
5792: LIST
5793: PUSH
5794: EMPTY
5795: LIST
5796: LIST
5797: PPUSH
5798: CALL_OW 69
5802: ST_TO_ADDR
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
5803: LD_ADDR_VAR 0 4
5807: PUSH
5808: LD_INT 4
5810: PUSH
5811: LD_INT 5
5813: PUSH
5814: LD_INT 6
5816: PUSH
5817: EMPTY
5818: LIST
5819: LIST
5820: LIST
5821: PUSH
5822: LD_OWVAR 67
5826: ARRAY
5827: ST_TO_ADDR
// for i = 1 to r do
5828: LD_ADDR_VAR 0 2
5832: PUSH
5833: DOUBLE
5834: LD_INT 1
5836: DEC
5837: ST_TO_ADDR
5838: LD_VAR 0 4
5842: PUSH
5843: FOR_TO
5844: IFFALSE 6017
// begin un := PrepareTank ( 3 , 3 , [ ru_medium_tracked , ru_medium_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
5846: LD_ADDR_VAR 0 5
5850: PUSH
5851: LD_INT 3
5853: PPUSH
5854: LD_INT 3
5856: PPUSH
5857: LD_INT 22
5859: PUSH
5860: LD_INT 22
5862: PUSH
5863: LD_INT 24
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: LIST
5870: PUSH
5871: LD_VAR 0 2
5875: PUSH
5876: LD_INT 3
5878: MOD
5879: PUSH
5880: LD_INT 1
5882: PLUS
5883: ARRAY
5884: PPUSH
5885: LD_INT 1
5887: PPUSH
5888: LD_INT 1
5890: PPUSH
5891: LD_INT 43
5893: PUSH
5894: LD_INT 44
5896: PUSH
5897: LD_INT 42
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: LIST
5904: PUSH
5905: LD_VAR 0 2
5909: PUSH
5910: LD_INT 3
5912: MOD
5913: PUSH
5914: LD_INT 1
5916: PLUS
5917: ARRAY
5918: PPUSH
5919: LD_INT 100
5921: PPUSH
5922: CALL 417 0 7
5926: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
5927: LD_VAR 0 5
5931: PPUSH
5932: LD_INT 0
5934: PPUSH
5935: LD_INT 5
5937: PPUSH
5938: CALL_OW 12
5942: PPUSH
5943: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
5947: LD_VAR 0 5
5951: PPUSH
5952: LD_INT 5
5954: PPUSH
5955: LD_INT 0
5957: PPUSH
5958: CALL_OW 49
// if i > tmp - 2 then
5962: LD_VAR 0 2
5966: PUSH
5967: LD_VAR 0 8
5971: PUSH
5972: LD_INT 2
5974: MINUS
5975: GREATER
5976: IFFALSE 5980
// continue ;
5978: GO 5843
// ComExitBuilding ( tmp [ i ] ) ;
5980: LD_VAR 0 8
5984: PUSH
5985: LD_VAR 0 2
5989: ARRAY
5990: PPUSH
5991: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , un ) ;
5995: LD_VAR 0 8
5999: PUSH
6000: LD_VAR 0 2
6004: ARRAY
6005: PPUSH
6006: LD_VAR 0 5
6010: PPUSH
6011: CALL_OW 180
// end ;
6015: GO 5843
6017: POP
6018: POP
// end ;
6019: LD_VAR 0 1
6023: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) do var i , filter , tmp , engs , enemy ;
6024: LD_INT 22
6026: PUSH
6027: LD_INT 3
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: PUSH
6034: LD_INT 25
6036: PUSH
6037: LD_INT 2
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: PUSH
6044: EMPTY
6045: LIST
6046: LIST
6047: PPUSH
6048: CALL_OW 69
6052: IFFALSE 6809
6054: GO 6056
6056: DISABLE
6057: LD_INT 0
6059: PPUSH
6060: PPUSH
6061: PPUSH
6062: PPUSH
6063: PPUSH
// begin enable ;
6064: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
6065: LD_ADDR_VAR 0 2
6069: PUSH
6070: LD_INT 6
6072: PPUSH
6073: LD_INT 3
6075: PUSH
6076: LD_INT 24
6078: PUSH
6079: LD_INT 1000
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: PUSH
6090: LD_INT 21
6092: PUSH
6093: LD_INT 3
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PUSH
6100: EMPTY
6101: LIST
6102: LIST
6103: PPUSH
6104: CALL_OW 70
6108: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] ] ) ;
6109: LD_ADDR_VAR 0 4
6113: PUSH
6114: LD_INT 22
6116: PUSH
6117: LD_INT 3
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: PUSH
6124: LD_INT 25
6126: PUSH
6127: LD_INT 2
6129: PUSH
6130: EMPTY
6131: LIST
6132: LIST
6133: PUSH
6134: EMPTY
6135: LIST
6136: LIST
6137: PPUSH
6138: CALL_OW 69
6142: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
6143: LD_VAR 0 2
6147: NOT
6148: PUSH
6149: LD_EXP 19
6153: NOT
6154: AND
6155: IFFALSE 6225
// begin for i in engs do
6157: LD_ADDR_VAR 0 1
6161: PUSH
6162: LD_VAR 0 4
6166: PUSH
6167: FOR_IN
6168: IFFALSE 6223
// if GetLives ( i ) = 1000 and not HasTask ( i ) and not IsInUnit ( i ) then
6170: LD_VAR 0 1
6174: PPUSH
6175: CALL_OW 256
6179: PUSH
6180: LD_INT 1000
6182: EQUAL
6183: PUSH
6184: LD_VAR 0 1
6188: PPUSH
6189: CALL_OW 314
6193: NOT
6194: AND
6195: PUSH
6196: LD_VAR 0 1
6200: PPUSH
6201: CALL_OW 310
6205: NOT
6206: AND
6207: IFFALSE 6221
// ComEnterUnit ( i , ru_dep_main ) ;
6209: LD_VAR 0 1
6213: PPUSH
6214: LD_INT 16
6216: PPUSH
6217: CALL_OW 120
6221: GO 6167
6223: POP
6224: POP
// end ; if debug then
6225: LD_EXP 1
6229: IFFALSE 6250
// display_strings := [ engs , filter ] ;
6231: LD_ADDR_OWVAR 47
6235: PUSH
6236: LD_VAR 0 4
6240: PUSH
6241: LD_VAR 0 2
6245: PUSH
6246: EMPTY
6247: LIST
6248: LIST
6249: ST_TO_ADDR
// if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
6250: LD_VAR 0 4
6254: PPUSH
6255: LD_INT 3
6257: PUSH
6258: LD_INT 24
6260: PUSH
6261: LD_INT 650
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: PUSH
6268: EMPTY
6269: LIST
6270: LIST
6271: PPUSH
6272: CALL_OW 72
6276: IFFALSE 6369
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
6278: LD_ADDR_VAR 0 3
6282: PUSH
6283: LD_VAR 0 4
6287: PPUSH
6288: LD_INT 3
6290: PUSH
6291: LD_INT 24
6293: PUSH
6294: LD_INT 650
6296: PUSH
6297: EMPTY
6298: LIST
6299: LIST
6300: PUSH
6301: EMPTY
6302: LIST
6303: LIST
6304: PPUSH
6305: CALL_OW 72
6309: ST_TO_ADDR
// for i in tmp do
6310: LD_ADDR_VAR 0 1
6314: PUSH
6315: LD_VAR 0 3
6319: PUSH
6320: FOR_IN
6321: IFFALSE 6367
// if not IsInArea ( i , mainBaseArea ) then
6323: LD_VAR 0 1
6327: PPUSH
6328: LD_INT 14
6330: PPUSH
6331: CALL_OW 308
6335: NOT
6336: IFFALSE 6365
// begin ComMoveXY ( i , 129 , 125 ) ;
6338: LD_VAR 0 1
6342: PPUSH
6343: LD_INT 129
6345: PPUSH
6346: LD_INT 125
6348: PPUSH
6349: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
6353: LD_VAR 0 1
6357: PPUSH
6358: LD_INT 1050
6360: PPUSH
6361: CALL_OW 202
// end ;
6365: GO 6320
6367: POP
6368: POP
// end ; engs := UnitFilter ( engs , [ f_lives , 650 ] ) ;
6369: LD_ADDR_VAR 0 4
6373: PUSH
6374: LD_VAR 0 4
6378: PPUSH
6379: LD_INT 24
6381: PUSH
6382: LD_INT 650
6384: PUSH
6385: EMPTY
6386: LIST
6387: LIST
6388: PPUSH
6389: CALL_OW 72
6393: ST_TO_ADDR
// if not engs then
6394: LD_VAR 0 4
6398: NOT
6399: IFFALSE 6403
// exit ;
6401: GO 6809
// if filter then
6403: LD_VAR 0 2
6407: IFFALSE 6666
// begin for i in engs do
6409: LD_ADDR_VAR 0 1
6413: PUSH
6414: LD_VAR 0 4
6418: PUSH
6419: FOR_IN
6420: IFFALSE 6444
// if IsInUnit ( i ) then
6422: LD_VAR 0 1
6426: PPUSH
6427: CALL_OW 310
6431: IFFALSE 6442
// ComExitBuilding ( i ) ;
6433: LD_VAR 0 1
6437: PPUSH
6438: CALL_OW 122
6442: GO 6419
6444: POP
6445: POP
// wait ( 3 ) ;
6446: LD_INT 3
6448: PPUSH
6449: CALL_OW 67
// if filter >= 2 and engs >= 2 then
6453: LD_VAR 0 2
6457: PUSH
6458: LD_INT 2
6460: GREATEREQUAL
6461: PUSH
6462: LD_VAR 0 4
6466: PUSH
6467: LD_INT 2
6469: GREATEREQUAL
6470: AND
6471: IFFALSE 6619
// begin for i = 1 to engs / 2 do
6473: LD_ADDR_VAR 0 1
6477: PUSH
6478: DOUBLE
6479: LD_INT 1
6481: DEC
6482: ST_TO_ADDR
6483: LD_VAR 0 4
6487: PUSH
6488: LD_INT 2
6490: DIVREAL
6491: PUSH
6492: FOR_TO
6493: IFFALSE 6539
// if not HasTask ( engs [ i ] ) then
6495: LD_VAR 0 4
6499: PUSH
6500: LD_VAR 0 1
6504: ARRAY
6505: PPUSH
6506: CALL_OW 314
6510: NOT
6511: IFFALSE 6537
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
6513: LD_VAR 0 4
6517: PUSH
6518: LD_VAR 0 1
6522: ARRAY
6523: PPUSH
6524: LD_VAR 0 2
6528: PUSH
6529: LD_INT 1
6531: ARRAY
6532: PPUSH
6533: CALL_OW 130
6537: GO 6492
6539: POP
6540: POP
// for i = engs / 2 + 1 to engs do
6541: LD_ADDR_VAR 0 1
6545: PUSH
6546: DOUBLE
6547: LD_VAR 0 4
6551: PUSH
6552: LD_INT 2
6554: DIVREAL
6555: PUSH
6556: LD_INT 1
6558: PLUS
6559: DEC
6560: ST_TO_ADDR
6561: LD_VAR 0 4
6565: PUSH
6566: FOR_TO
6567: IFFALSE 6615
// if not HasTask ( engs [ i ] ) then
6569: LD_VAR 0 4
6573: PUSH
6574: LD_VAR 0 1
6578: ARRAY
6579: PPUSH
6580: CALL_OW 314
6584: NOT
6585: IFFALSE 6613
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
6587: LD_VAR 0 4
6591: PUSH
6592: LD_VAR 0 1
6596: ARRAY
6597: PPUSH
6598: LD_VAR 0 2
6602: PUSH
6603: LD_VAR 0 2
6607: ARRAY
6608: PPUSH
6609: CALL_OW 130
6613: GO 6566
6615: POP
6616: POP
// end else
6617: GO 6666
// for i in engs do
6619: LD_ADDR_VAR 0 1
6623: PUSH
6624: LD_VAR 0 4
6628: PUSH
6629: FOR_IN
6630: IFFALSE 6664
// if not HasTask ( i ) then
6632: LD_VAR 0 1
6636: PPUSH
6637: CALL_OW 314
6641: NOT
6642: IFFALSE 6662
// ComRepairBuilding ( i , filter [ 1 ] ) ;
6644: LD_VAR 0 1
6648: PPUSH
6649: LD_VAR 0 2
6653: PUSH
6654: LD_INT 1
6656: ARRAY
6657: PPUSH
6658: CALL_OW 130
6662: GO 6629
6664: POP
6665: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
6666: LD_ADDR_VAR 0 5
6670: PUSH
6671: LD_INT 81
6673: PUSH
6674: LD_INT 3
6676: PUSH
6677: EMPTY
6678: LIST
6679: LIST
6680: PPUSH
6681: CALL_OW 69
6685: ST_TO_ADDR
// if ru_rebuild_list and not filter then
6686: LD_EXP 19
6690: PUSH
6691: LD_VAR 0 2
6695: NOT
6696: AND
6697: IFFALSE 6809
// begin ComExitBuilding ( engs ) ;
6699: LD_VAR 0 4
6703: PPUSH
6704: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
6708: LD_VAR 0 5
6712: PPUSH
6713: LD_EXP 19
6717: PUSH
6718: LD_INT 2
6720: ARRAY
6721: PPUSH
6722: LD_EXP 19
6726: PUSH
6727: LD_INT 3
6729: ARRAY
6730: PPUSH
6731: CALL_OW 73
6735: PPUSH
6736: LD_EXP 19
6740: PUSH
6741: LD_INT 2
6743: ARRAY
6744: PPUSH
6745: LD_EXP 19
6749: PUSH
6750: LD_INT 3
6752: ARRAY
6753: PPUSH
6754: CALL_OW 297
6758: PUSH
6759: LD_INT 10
6761: GREATER
6762: IFFALSE 6809
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
6764: LD_VAR 0 4
6768: PPUSH
6769: LD_EXP 19
6773: PUSH
6774: LD_INT 1
6776: ARRAY
6777: PPUSH
6778: LD_EXP 19
6782: PUSH
6783: LD_INT 2
6785: ARRAY
6786: PPUSH
6787: LD_EXP 19
6791: PUSH
6792: LD_INT 3
6794: ARRAY
6795: PPUSH
6796: LD_EXP 19
6800: PUSH
6801: LD_INT 4
6803: ARRAY
6804: PPUSH
6805: CALL_OW 145
// end ; end ;
6809: PPOPN 5
6811: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 650 do var tmp ;
6812: LD_INT 16
6814: PPUSH
6815: CALL_OW 256
6819: PUSH
6820: LD_INT 650
6822: LESS
6823: IFFALSE 6906
6825: GO 6827
6827: DISABLE
6828: LD_INT 0
6830: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
6831: LD_ADDR_VAR 0 1
6835: PUSH
6836: LD_INT 22
6838: PUSH
6839: LD_INT 3
6841: PUSH
6842: EMPTY
6843: LIST
6844: LIST
6845: PUSH
6846: LD_INT 25
6848: PUSH
6849: LD_INT 1
6851: PUSH
6852: EMPTY
6853: LIST
6854: LIST
6855: PUSH
6856: EMPTY
6857: LIST
6858: LIST
6859: PPUSH
6860: CALL_OW 69
6864: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
6865: LD_VAR 0 1
6869: PPUSH
6870: CALL_OW 122
// wait ( 3 ) ;
6874: LD_INT 3
6876: PPUSH
6877: CALL_OW 67
// ComAgressiveMove ( tmp , GetX ( ru_dep_main ) , GetY ( ru_dep_main ) ) ;
6881: LD_VAR 0 1
6885: PPUSH
6886: LD_INT 16
6888: PPUSH
6889: CALL_OW 250
6893: PPUSH
6894: LD_INT 16
6896: PPUSH
6897: CALL_OW 251
6901: PPUSH
6902: CALL_OW 114
// end ;
6906: PPOPN 1
6908: END
// every 0 0$01 trigger GetLives ( ru_dep_main ) > 650 and FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] ] ] ) do var i , tmp ;
6909: LD_INT 16
6911: PPUSH
6912: CALL_OW 256
6916: PUSH
6917: LD_INT 650
6919: GREATER
6920: PUSH
6921: LD_INT 22
6923: PUSH
6924: LD_INT 3
6926: PUSH
6927: EMPTY
6928: LIST
6929: LIST
6930: PUSH
6931: LD_INT 25
6933: PUSH
6934: LD_INT 1
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: PUSH
6941: LD_INT 56
6943: PUSH
6944: EMPTY
6945: LIST
6946: PUSH
6947: EMPTY
6948: LIST
6949: LIST
6950: LIST
6951: PUSH
6952: EMPTY
6953: LIST
6954: PPUSH
6955: CALL_OW 69
6959: AND
6960: IFFALSE 7072
6962: GO 6964
6964: DISABLE
6965: LD_INT 0
6967: PPUSH
6968: PPUSH
// begin enable ;
6969: ENABLE
// tmp := FilterAllUnits ( [ [ [ f_side , 3 ] , [ f_class , 1 ] , [ f_outside ] , [ f_not , [ f_hastask ] ] ] ] ) ;
6970: LD_ADDR_VAR 0 2
6974: PUSH
6975: LD_INT 22
6977: PUSH
6978: LD_INT 3
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: PUSH
6985: LD_INT 25
6987: PUSH
6988: LD_INT 1
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PUSH
6995: LD_INT 56
6997: PUSH
6998: EMPTY
6999: LIST
7000: PUSH
7001: LD_INT 3
7003: PUSH
7004: LD_INT 60
7006: PUSH
7007: EMPTY
7008: LIST
7009: PUSH
7010: EMPTY
7011: LIST
7012: LIST
7013: PUSH
7014: EMPTY
7015: LIST
7016: LIST
7017: LIST
7018: LIST
7019: PUSH
7020: EMPTY
7021: LIST
7022: PPUSH
7023: CALL_OW 69
7027: ST_TO_ADDR
// if not tmp then
7028: LD_VAR 0 2
7032: NOT
7033: IFFALSE 7037
// exit ;
7035: GO 7072
// for i in tmp do
7037: LD_ADDR_VAR 0 1
7041: PUSH
7042: LD_VAR 0 2
7046: PUSH
7047: FOR_IN
7048: IFFALSE 7070
// GoToAnotherTower ( i , 0 , 143 , 143 ) ;
7050: LD_VAR 0 1
7054: PPUSH
7055: LD_INT 0
7057: PPUSH
7058: LD_INT 143
7060: PPUSH
7061: LD_INT 143
7063: PPUSH
7064: CALL 2054 0 4
7068: GO 7047
7070: POP
7071: POP
// end ;
7072: PPOPN 2
7074: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
7075: LD_INT 22
7077: PUSH
7078: LD_INT 3
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: PUSH
7085: LD_INT 25
7087: PUSH
7088: LD_INT 4
7090: PUSH
7091: EMPTY
7092: LIST
7093: LIST
7094: PUSH
7095: EMPTY
7096: LIST
7097: LIST
7098: PPUSH
7099: CALL_OW 69
7103: IFFALSE 7357
7105: GO 7107
7107: DISABLE
7108: LD_INT 0
7110: PPUSH
7111: PPUSH
7112: PPUSH
// begin enable ;
7113: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7114: LD_ADDR_VAR 0 2
7118: PUSH
7119: LD_INT 14
7121: PPUSH
7122: LD_INT 22
7124: PUSH
7125: LD_INT 3
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: PUSH
7132: LD_INT 21
7134: PUSH
7135: LD_INT 1
7137: PUSH
7138: EMPTY
7139: LIST
7140: LIST
7141: PUSH
7142: LD_INT 3
7144: PUSH
7145: LD_INT 24
7147: PUSH
7148: LD_INT 1000
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: PUSH
7155: EMPTY
7156: LIST
7157: LIST
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: LIST
7163: PPUSH
7164: CALL_OW 70
7168: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
7169: LD_ADDR_VAR 0 3
7173: PUSH
7174: LD_INT 22
7176: PUSH
7177: LD_INT 3
7179: PUSH
7180: EMPTY
7181: LIST
7182: LIST
7183: PUSH
7184: LD_INT 25
7186: PUSH
7187: LD_INT 4
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: PPUSH
7198: CALL_OW 69
7202: ST_TO_ADDR
// if not doc then
7203: LD_VAR 0 3
7207: NOT
7208: IFFALSE 7212
// exit ;
7210: GO 7357
// if not tmp then
7212: LD_VAR 0 2
7216: NOT
7217: IFFALSE 7308
// begin if not IsInUnit ( doc [ 1 ] ) then
7219: LD_VAR 0 3
7223: PUSH
7224: LD_INT 1
7226: ARRAY
7227: PPUSH
7228: CALL_OW 310
7232: NOT
7233: IFFALSE 7306
// ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
7235: LD_VAR 0 3
7239: PPUSH
7240: LD_INT 22
7242: PUSH
7243: LD_INT 3
7245: PUSH
7246: EMPTY
7247: LIST
7248: LIST
7249: PUSH
7250: LD_INT 2
7252: PUSH
7253: LD_INT 30
7255: PUSH
7256: LD_INT 6
7258: PUSH
7259: EMPTY
7260: LIST
7261: LIST
7262: PUSH
7263: LD_INT 30
7265: PUSH
7266: LD_INT 7
7268: PUSH
7269: EMPTY
7270: LIST
7271: LIST
7272: PUSH
7273: LD_INT 30
7275: PUSH
7276: LD_INT 8
7278: PUSH
7279: EMPTY
7280: LIST
7281: LIST
7282: PUSH
7283: EMPTY
7284: LIST
7285: LIST
7286: LIST
7287: LIST
7288: PUSH
7289: EMPTY
7290: LIST
7291: LIST
7292: PPUSH
7293: CALL_OW 69
7297: PUSH
7298: LD_INT 1
7300: ARRAY
7301: PPUSH
7302: CALL_OW 120
// exit ;
7306: GO 7357
// end ; if IsInUnit ( doc [ 1 ] ) then
7308: LD_VAR 0 3
7312: PUSH
7313: LD_INT 1
7315: ARRAY
7316: PPUSH
7317: CALL_OW 310
7321: IFFALSE 7332
// ComExitBuilding ( doc ) ;
7323: LD_VAR 0 3
7327: PPUSH
7328: CALL_OW 122
// wait ( 3 ) ;
7332: LD_INT 3
7334: PPUSH
7335: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
7339: LD_VAR 0 3
7343: PPUSH
7344: LD_VAR 0 2
7348: PUSH
7349: LD_INT 1
7351: ARRAY
7352: PPUSH
7353: CALL_OW 128
// end ;
7357: PPOPN 3
7359: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , tmp , attacking , areas , area ;
7360: LD_INT 22
7362: PUSH
7363: LD_INT 3
7365: PUSH
7366: EMPTY
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 25
7372: PUSH
7373: LD_INT 3
7375: PUSH
7376: EMPTY
7377: LIST
7378: LIST
7379: PUSH
7380: EMPTY
7381: LIST
7382: LIST
7383: PPUSH
7384: CALL_OW 69
7388: PUSH
7389: LD_INT 22
7391: PUSH
7392: LD_INT 3
7394: PUSH
7395: EMPTY
7396: LIST
7397: LIST
7398: PUSH
7399: LD_INT 21
7401: PUSH
7402: LD_INT 2
7404: PUSH
7405: EMPTY
7406: LIST
7407: LIST
7408: PUSH
7409: EMPTY
7410: LIST
7411: LIST
7412: PPUSH
7413: CALL_OW 69
7417: AND
7418: IFFALSE 7832
7420: GO 7422
7422: DISABLE
7423: LD_INT 0
7425: PPUSH
7426: PPUSH
7427: PPUSH
7428: PPUSH
7429: PPUSH
// begin enable ;
7430: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
7431: LD_ADDR_VAR 0 2
7435: PUSH
7436: LD_INT 22
7438: PUSH
7439: LD_INT 3
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: PUSH
7446: LD_INT 21
7448: PUSH
7449: LD_INT 2
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: PUSH
7456: LD_INT 3
7458: PUSH
7459: LD_INT 58
7461: PUSH
7462: EMPTY
7463: LIST
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: PUSH
7469: EMPTY
7470: LIST
7471: LIST
7472: LIST
7473: PPUSH
7474: CALL_OW 69
7478: ST_TO_ADDR
// areas := [ sectorAlpha , sectorBeta , sectorDelta , mainBaseArea ] ;
7479: LD_ADDR_VAR 0 4
7483: PUSH
7484: LD_INT 10
7486: PUSH
7487: LD_INT 11
7489: PUSH
7490: LD_INT 12
7492: PUSH
7493: LD_INT 14
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: ST_TO_ADDR
// area := 0 ;
7502: LD_ADDR_VAR 0 5
7506: PUSH
7507: LD_INT 0
7509: ST_TO_ADDR
// attacking := false ;
7510: LD_ADDR_VAR 0 3
7514: PUSH
7515: LD_INT 0
7517: ST_TO_ADDR
// for i in tmp do
7518: LD_ADDR_VAR 0 1
7522: PUSH
7523: LD_VAR 0 2
7527: PUSH
7528: FOR_IN
7529: IFFALSE 7615
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
7531: LD_VAR 0 1
7535: PPUSH
7536: LD_INT 22
7538: PUSH
7539: LD_INT 1
7541: PUSH
7542: EMPTY
7543: LIST
7544: LIST
7545: PPUSH
7546: CALL_OW 69
7550: PPUSH
7551: LD_VAR 0 1
7555: PPUSH
7556: CALL_OW 74
7560: PPUSH
7561: CALL_OW 296
7565: PUSH
7566: LD_INT 10
7568: LESS
7569: IFFALSE 7613
// begin ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7571: LD_VAR 0 1
7575: PPUSH
7576: LD_INT 22
7578: PUSH
7579: LD_INT 1
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: PPUSH
7586: CALL_OW 69
7590: PPUSH
7591: LD_VAR 0 1
7595: PPUSH
7596: CALL_OW 74
7600: PPUSH
7601: CALL_OW 115
// attacking := true ;
7605: LD_ADDR_VAR 0 3
7609: PUSH
7610: LD_INT 1
7612: ST_TO_ADDR
// end ;
7613: GO 7528
7615: POP
7616: POP
// if attacking then
7617: LD_VAR 0 3
7621: IFFALSE 7625
// exit ;
7623: GO 7832
// for i in areas do
7625: LD_ADDR_VAR 0 1
7629: PUSH
7630: LD_VAR 0 4
7634: PUSH
7635: FOR_IN
7636: IFFALSE 7673
// if FilterUnitsInArea ( i , [ f_side , 1 ] ) then
7638: LD_VAR 0 1
7642: PPUSH
7643: LD_INT 22
7645: PUSH
7646: LD_INT 1
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PPUSH
7653: CALL_OW 70
7657: IFFALSE 7671
// begin area := i ;
7659: LD_ADDR_VAR 0 5
7663: PUSH
7664: LD_VAR 0 1
7668: ST_TO_ADDR
// break ;
7669: GO 7673
// end ;
7671: GO 7635
7673: POP
7674: POP
// if area then
7675: LD_VAR 0 5
7679: IFFALSE 7832
// begin for i in tmp do
7681: LD_ADDR_VAR 0 1
7685: PUSH
7686: LD_VAR 0 2
7690: PUSH
7691: FOR_IN
7692: IFFALSE 7830
// begin if GetFuel ( i ) < 33 then
7694: LD_VAR 0 1
7698: PPUSH
7699: CALL_OW 261
7703: PUSH
7704: LD_INT 33
7706: LESS
7707: IFFALSE 7721
// SetFuel ( i , 33 ) ;
7709: LD_VAR 0 1
7713: PPUSH
7714: LD_INT 33
7716: PPUSH
7717: CALL_OW 240
// if GetDistUnits ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) < 10 then
7721: LD_VAR 0 1
7725: PPUSH
7726: LD_INT 22
7728: PUSH
7729: LD_INT 1
7731: PUSH
7732: EMPTY
7733: LIST
7734: LIST
7735: PPUSH
7736: CALL_OW 69
7740: PPUSH
7741: LD_VAR 0 1
7745: PPUSH
7746: CALL_OW 74
7750: PPUSH
7751: CALL_OW 296
7755: PUSH
7756: LD_INT 10
7758: LESS
7759: IFFALSE 7797
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7761: LD_VAR 0 1
7765: PPUSH
7766: LD_INT 22
7768: PUSH
7769: LD_INT 1
7771: PUSH
7772: EMPTY
7773: LIST
7774: LIST
7775: PPUSH
7776: CALL_OW 69
7780: PPUSH
7781: LD_VAR 0 1
7785: PPUSH
7786: CALL_OW 74
7790: PPUSH
7791: CALL_OW 115
7795: GO 7828
// if not IsInArea ( i , area ) then
7797: LD_VAR 0 1
7801: PPUSH
7802: LD_VAR 0 5
7806: PPUSH
7807: CALL_OW 308
7811: NOT
7812: IFFALSE 7828
// ComMoveToArea ( i , area ) ;
7814: LD_VAR 0 1
7818: PPUSH
7819: LD_VAR 0 5
7823: PPUSH
7824: CALL_OW 113
// end ;
7828: GO 7691
7830: POP
7831: POP
// end ; end ;
7832: PPOPN 5
7834: END
// every 10 10$00 do var i , j , un , veh , time , count ;
7835: GO 7837
7837: DISABLE
7838: LD_INT 0
7840: PPUSH
7841: PPUSH
7842: PPUSH
7843: PPUSH
7844: PPUSH
7845: PPUSH
// begin uc_side := 3 ;
7846: LD_ADDR_OWVAR 20
7850: PUSH
7851: LD_INT 3
7853: ST_TO_ADDR
// uc_nation := 3 ;
7854: LD_ADDR_OWVAR 21
7858: PUSH
7859: LD_INT 3
7861: ST_TO_ADDR
// time := [ 8 8$00 , 7 7$00 , 6 6$00 ] [ Difficulty ] ;
7862: LD_ADDR_VAR 0 5
7866: PUSH
7867: LD_INT 16800
7869: PUSH
7870: LD_INT 14700
7872: PUSH
7873: LD_INT 12600
7875: PUSH
7876: EMPTY
7877: LIST
7878: LIST
7879: LIST
7880: PUSH
7881: LD_OWVAR 67
7885: ARRAY
7886: ST_TO_ADDR
// count := [ 2 , 2 , 3 ] [ Difficulty ] ;
7887: LD_ADDR_VAR 0 6
7891: PUSH
7892: LD_INT 2
7894: PUSH
7895: LD_INT 2
7897: PUSH
7898: LD_INT 3
7900: PUSH
7901: EMPTY
7902: LIST
7903: LIST
7904: LIST
7905: PUSH
7906: LD_OWVAR 67
7910: ARRAY
7911: ST_TO_ADDR
// for i = 1 to count do
7912: LD_ADDR_VAR 0 1
7916: PUSH
7917: DOUBLE
7918: LD_INT 1
7920: DEC
7921: ST_TO_ADDR
7922: LD_VAR 0 6
7926: PUSH
7927: FOR_TO
7928: IFFALSE 8108
// begin wait ( time ) ;
7930: LD_VAR 0 5
7934: PPUSH
7935: CALL_OW 67
// for j = 1 to rand ( 1 , Difficulty ) do
7939: LD_ADDR_VAR 0 2
7943: PUSH
7944: DOUBLE
7945: LD_INT 1
7947: DEC
7948: ST_TO_ADDR
7949: LD_INT 1
7951: PPUSH
7952: LD_OWVAR 67
7956: PPUSH
7957: CALL_OW 12
7961: PUSH
7962: FOR_TO
7963: IFFALSE 8104
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 80 ) ;
7965: LD_ADDR_VAR 0 4
7969: PUSH
7970: LD_INT 3
7972: PPUSH
7973: LD_INT 3
7975: PPUSH
7976: LD_INT 22
7978: PPUSH
7979: LD_INT 1
7981: PPUSH
7982: LD_INT 1
7984: PPUSH
7985: LD_INT 43
7987: PUSH
7988: LD_INT 44
7990: PUSH
7991: LD_INT 42
7993: PUSH
7994: EMPTY
7995: LIST
7996: LIST
7997: LIST
7998: PUSH
7999: LD_VAR 0 1
8003: PUSH
8004: LD_INT 3
8006: MOD
8007: PUSH
8008: LD_INT 1
8010: PLUS
8011: ARRAY
8012: PPUSH
8013: LD_INT 80
8015: PPUSH
8016: CALL 417 0 7
8020: ST_TO_ADDR
// PlaceUnitArea ( veh , southArea , false ) ;
8021: LD_VAR 0 4
8025: PPUSH
8026: LD_INT 13
8028: PPUSH
8029: LD_INT 0
8031: PPUSH
8032: CALL_OW 49
// PrepareHuman ( false , 3 , [ 4 , 5 , 5 ] [ Difficulty ] ) ;
8036: LD_INT 0
8038: PPUSH
8039: LD_INT 3
8041: PPUSH
8042: LD_INT 4
8044: PUSH
8045: LD_INT 5
8047: PUSH
8048: LD_INT 5
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: LIST
8055: PUSH
8056: LD_OWVAR 67
8060: ARRAY
8061: PPUSH
8062: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
8066: CALL_OW 44
8070: PPUSH
8071: LD_VAR 0 4
8075: PPUSH
8076: CALL_OW 52
// wait ( 0 0$01 ) ;
8080: LD_INT 35
8082: PPUSH
8083: CALL_OW 67
// ComMoveXY ( veh , 143 , 143 ) ;
8087: LD_VAR 0 4
8091: PPUSH
8092: LD_INT 143
8094: PPUSH
8095: LD_INT 143
8097: PPUSH
8098: CALL_OW 111
// end ;
8102: GO 7962
8104: POP
8105: POP
// end ;
8106: GO 7927
8108: POP
8109: POP
// end ;
8110: PPOPN 6
8112: END
// every 8 8$00 do var i , un , time ;
8113: GO 8115
8115: DISABLE
8116: LD_INT 0
8118: PPUSH
8119: PPUSH
8120: PPUSH
// begin time := [ 2 2$00 , 1 1$00 , 0 0$30 ] ;
8121: LD_ADDR_VAR 0 3
8125: PUSH
8126: LD_INT 4200
8128: PUSH
8129: LD_INT 2100
8131: PUSH
8132: LD_INT 1050
8134: PUSH
8135: EMPTY
8136: LIST
8137: LIST
8138: LIST
8139: ST_TO_ADDR
// wait ( time ) ;
8140: LD_VAR 0 3
8144: PPUSH
8145: CALL_OW 67
// uc_side := 3 ;
8149: LD_ADDR_OWVAR 20
8153: PUSH
8154: LD_INT 3
8156: ST_TO_ADDR
// uc_nation := 3 ;
8157: LD_ADDR_OWVAR 21
8161: PUSH
8162: LD_INT 3
8164: ST_TO_ADDR
// for i = 1 to 2 do
8165: LD_ADDR_VAR 0 1
8169: PUSH
8170: DOUBLE
8171: LD_INT 1
8173: DEC
8174: ST_TO_ADDR
8175: LD_INT 2
8177: PUSH
8178: FOR_TO
8179: IFFALSE 8242
// begin PrepareHuman ( false , 1 , 4 ) ;
8181: LD_INT 0
8183: PPUSH
8184: LD_INT 1
8186: PPUSH
8187: LD_INT 4
8189: PPUSH
8190: CALL_OW 380
// un := CreateHuman ;
8194: LD_ADDR_VAR 0 2
8198: PUSH
8199: CALL_OW 44
8203: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_dep_main ) ;
8204: LD_VAR 0 2
8208: PPUSH
8209: LD_INT 16
8211: PPUSH
8212: CALL_OW 52
// ComExitBuilding ( un ) ;
8216: LD_VAR 0 2
8220: PPUSH
8221: CALL_OW 122
// AddComAgressiveMove ( un , 41 , 76 ) ;
8225: LD_VAR 0 2
8229: PPUSH
8230: LD_INT 41
8232: PPUSH
8233: LD_INT 76
8235: PPUSH
8236: CALL_OW 174
// end ;
8240: GO 8178
8242: POP
8243: POP
// end ; end_of_file
8244: PPOPN 3
8246: END
// export function Action ; begin
8247: LD_INT 0
8249: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
8250: LD_INT 28
8252: PPUSH
8253: LD_INT 3
8255: PPUSH
8256: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
8260: LD_INT 41
8262: PPUSH
8263: LD_INT 76
8265: PPUSH
8266: LD_INT 1
8268: PPUSH
8269: LD_INT 10
8271: PPUSH
8272: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
8276: LD_INT 41
8278: PPUSH
8279: LD_INT 76
8281: PPUSH
8282: LD_INT 1
8284: PPUSH
8285: CALL_OW 331
// InGameOn ;
8289: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
8293: LD_EXP 18
8297: PPUSH
8298: LD_STRING D2-Har-1
8300: PPUSH
8301: CALL_OW 94
// InGameOff ;
8305: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
8309: LD_STRING M1
8311: PPUSH
8312: CALL_OW 337
// end ;
8316: LD_VAR 0 1
8320: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
8321: LD_EXP 4
8325: PUSH
8326: LD_INT 1
8328: GREATER
8329: IFFALSE 8420
8331: GO 8333
8333: DISABLE
8334: LD_INT 0
8336: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
8337: LD_ADDR_VAR 0 1
8341: PUSH
8342: LD_INT 1
8344: PPUSH
8345: CALL 505 0 1
8349: PUSH
8350: LD_INT 1
8352: ARRAY
8353: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
8354: LD_VAR 0 1
8358: PPUSH
8359: LD_STRING D2a-Sol1-1
8361: PPUSH
8362: CALL_OW 88
// if not un then
8366: LD_VAR 0 1
8370: NOT
8371: IFFALSE 8402
// begin un := GetRandom ( sex_female ) [ 1 ] ;
8373: LD_ADDR_VAR 0 1
8377: PUSH
8378: LD_INT 2
8380: PPUSH
8381: CALL 505 0 1
8385: PUSH
8386: LD_INT 1
8388: ARRAY
8389: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
8390: LD_VAR 0 1
8394: PPUSH
8395: LD_STRING D2a-FSol1-1
8397: PPUSH
8398: CALL_OW 88
// end ; if Khatam then
8402: LD_EXP 16
8406: IFFALSE 8420
// Say ( Khatam , D3b-Khat-3 ) ;
8408: LD_EXP 16
8412: PPUSH
8413: LD_STRING D3b-Khat-3
8415: PPUSH
8416: CALL_OW 88
// end ;
8420: PPOPN 1
8422: END
// every 0 0$1 trigger Frank and not Kikuchi and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Frank ) , GetY ( Frank ) , 7 ] ] ) and not InBattle ( 1 ) do var i , ape ;
8423: LD_EXP 14
8427: PUSH
8428: LD_EXP 17
8432: NOT
8433: AND
8434: PUSH
8435: LD_INT 22
8437: PUSH
8438: LD_INT 1
8440: PUSH
8441: EMPTY
8442: LIST
8443: LIST
8444: PUSH
8445: LD_INT 92
8447: PUSH
8448: LD_EXP 14
8452: PPUSH
8453: CALL_OW 250
8457: PUSH
8458: LD_EXP 14
8462: PPUSH
8463: CALL_OW 251
8467: PUSH
8468: LD_INT 7
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: LIST
8475: LIST
8476: PUSH
8477: EMPTY
8478: LIST
8479: LIST
8480: PPUSH
8481: CALL_OW 69
8485: AND
8486: PUSH
8487: LD_INT 1
8489: PPUSH
8490: CALL_OW 463
8494: NOT
8495: AND
8496: IFFALSE 9083
8498: GO 8500
8500: DISABLE
8501: LD_INT 0
8503: PPUSH
8504: PPUSH
// begin InGameOn ;
8505: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
8509: LD_ADDR_VAR 0 2
8513: PUSH
8514: LD_INT 22
8516: PUSH
8517: LD_INT 0
8519: PUSH
8520: EMPTY
8521: LIST
8522: LIST
8523: PUSH
8524: LD_INT 25
8526: PUSH
8527: LD_INT 12
8529: PUSH
8530: EMPTY
8531: LIST
8532: LIST
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: PPUSH
8538: CALL_OW 69
8542: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
8543: LD_ADDR_VAR 0 2
8547: PUSH
8548: LD_VAR 0 2
8552: PPUSH
8553: LD_EXP 14
8557: PPUSH
8558: CALL_OW 74
8562: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
8563: LD_ADDR_VAR 0 1
8567: PUSH
8568: LD_INT 22
8570: PUSH
8571: LD_INT 1
8573: PUSH
8574: EMPTY
8575: LIST
8576: LIST
8577: PUSH
8578: LD_INT 21
8580: PUSH
8581: LD_INT 1
8583: PUSH
8584: EMPTY
8585: LIST
8586: LIST
8587: PUSH
8588: LD_INT 91
8590: PUSH
8591: LD_EXP 14
8595: PUSH
8596: LD_INT 20
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: LIST
8603: PUSH
8604: EMPTY
8605: LIST
8606: LIST
8607: LIST
8608: PPUSH
8609: CALL_OW 69
8613: PUSH
8614: FOR_IN
8615: IFFALSE 8633
// ComTurnUnit ( i , Frank ) ;
8617: LD_VAR 0 1
8621: PPUSH
8622: LD_EXP 14
8626: PPUSH
8627: CALL_OW 119
8631: GO 8614
8633: POP
8634: POP
// SetSide ( Frank , 1 ) ;
8635: LD_EXP 14
8639: PPUSH
8640: LD_INT 1
8642: PPUSH
8643: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
8647: LD_EXP 8
8651: PPUSH
8652: LD_EXP 14
8656: PPUSH
8657: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
8661: LD_EXP 8
8665: PPUSH
8666: LD_EXP 14
8670: PPUSH
8671: CALL_OW 179
// CenterOnUnits ( Frank ) ;
8675: LD_EXP 14
8679: PPUSH
8680: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
8684: LD_EXP 14
8688: PPUSH
8689: LD_STRING D3a-Frank-1
8691: PPUSH
8692: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
8696: LD_VAR 0 2
8700: PPUSH
8701: LD_INT 42
8703: PPUSH
8704: LD_INT 78
8706: PPUSH
8707: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
8711: LD_VAR 0 2
8715: PPUSH
8716: LD_EXP 14
8720: PPUSH
8721: CALL_OW 179
// if Lisa then
8725: LD_EXP 13
8729: IFFALSE 8743
// Say ( Lisa , D3a-Lisa-1 ) ;
8731: LD_EXP 13
8735: PPUSH
8736: LD_STRING D3a-Lisa-1
8738: PPUSH
8739: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
8743: LD_EXP 8
8747: PPUSH
8748: LD_STRING D3a-JMM-1
8750: PPUSH
8751: CALL_OW 88
// if Cyrus then
8755: LD_EXP 12
8759: IFFALSE 8773
// Say ( Cyrus , D3a-Cyrus-1 ) ;
8761: LD_EXP 12
8765: PPUSH
8766: LD_STRING D3a-Cyrus-1
8768: PPUSH
8769: CALL_OW 88
// if GetRandom ( sex_male ) then
8773: LD_INT 1
8775: PPUSH
8776: CALL 505 0 1
8780: IFFALSE 8801
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
8782: LD_INT 1
8784: PPUSH
8785: CALL 505 0 1
8789: PUSH
8790: LD_INT 1
8792: ARRAY
8793: PPUSH
8794: LD_STRING D3a-Sol1-1
8796: PPUSH
8797: CALL_OW 88
// if GetRandom ( sex_female ) then
8801: LD_INT 2
8803: PPUSH
8804: CALL 505 0 1
8808: IFFALSE 8829
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
8810: LD_INT 2
8812: PPUSH
8813: CALL 505 0 1
8817: PUSH
8818: LD_INT 1
8820: ARRAY
8821: PPUSH
8822: LD_STRING D3a-FSol1-1
8824: PPUSH
8825: CALL_OW 88
// if Gladstone then
8829: LD_EXP 15
8833: IFFALSE 8847
// Say ( Gladstone , D3a-Glad-1 ) ;
8835: LD_EXP 15
8839: PPUSH
8840: LD_STRING D3a-Glad-1
8842: PPUSH
8843: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
8847: LD_VAR 0 2
8851: PPUSH
8852: LD_INT 60
8854: PPUSH
8855: LD_INT 113
8857: PPUSH
8858: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
8862: LD_EXP 14
8866: PPUSH
8867: LD_STRING D3a-Frank-2
8869: PPUSH
8870: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
8874: LD_EXP 14
8878: PPUSH
8879: LD_EXP 8
8883: PPUSH
8884: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
8888: LD_EXP 8
8892: PPUSH
8893: LD_STRING D3a-JMM-2
8895: PPUSH
8896: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
8900: LD_INT 1
8902: PPUSH
8903: LD_INT 4
8905: PPUSH
8906: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
8910: LD_INT 85
8912: PPUSH
8913: LD_INT 134
8915: PPUSH
8916: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
8920: LD_EXP 14
8924: PPUSH
8925: LD_STRING D3a-Frank-3
8927: PPUSH
8928: CALL_OW 88
// Wait ( 0 0$01 ) ;
8932: LD_INT 35
8934: PPUSH
8935: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
8939: LD_INT 166
8941: PPUSH
8942: LD_INT 136
8944: PPUSH
8945: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
8949: LD_EXP 8
8953: PPUSH
8954: LD_STRING D3a-JMM-3
8956: PPUSH
8957: CALL_OW 88
// Wait ( 0 0$01 ) ;
8961: LD_INT 35
8963: PPUSH
8964: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
8968: LD_EXP 14
8972: PPUSH
8973: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
8977: LD_EXP 14
8981: PPUSH
8982: LD_STRING D3a-Frank-4
8984: PPUSH
8985: CALL_OW 88
// if Lisa then
8989: LD_EXP 13
8993: IFFALSE 9007
// Say ( Lisa , D3a-Lisa-4 ) ;
8995: LD_EXP 13
8999: PPUSH
9000: LD_STRING D3a-Lisa-4
9002: PPUSH
9003: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
9007: LD_EXP 8
9011: PPUSH
9012: LD_STRING D3a-JMM-4
9014: PPUSH
9015: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
9019: LD_EXP 14
9023: PPUSH
9024: LD_STRING D3a-Frank-5
9026: PPUSH
9027: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
9031: LD_EXP 8
9035: PPUSH
9036: LD_STRING D3a-JMM-5
9038: PPUSH
9039: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
9043: LD_EXP 14
9047: PPUSH
9048: LD_STRING D3a-Frank-6
9050: PPUSH
9051: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
9055: LD_EXP 8
9059: PPUSH
9060: LD_STRING D3a-JMM-6
9062: PPUSH
9063: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
9067: LD_EXP 14
9071: PPUSH
9072: LD_STRING D3a-Frank-7
9074: PPUSH
9075: CALL_OW 88
// InGameOff ;
9079: CALL_OW 9
// end ;
9083: PPOPN 2
9085: END
// every 0 0$1 trigger Kikuchi and not Frank and FilterAllUnits ( [ [ f_side , 1 ] , [ f_distxy , GetX ( Kikuchi ) , GetY ( Kikuchi ) , 7 ] ] ) and not InBattle ( 1 ) do
9086: LD_EXP 17
9090: PUSH
9091: LD_EXP 14
9095: NOT
9096: AND
9097: PUSH
9098: LD_INT 22
9100: PUSH
9101: LD_INT 1
9103: PUSH
9104: EMPTY
9105: LIST
9106: LIST
9107: PUSH
9108: LD_INT 92
9110: PUSH
9111: LD_EXP 17
9115: PPUSH
9116: CALL_OW 250
9120: PUSH
9121: LD_EXP 17
9125: PPUSH
9126: CALL_OW 251
9130: PUSH
9131: LD_INT 7
9133: PUSH
9134: EMPTY
9135: LIST
9136: LIST
9137: LIST
9138: LIST
9139: PUSH
9140: EMPTY
9141: LIST
9142: LIST
9143: PPUSH
9144: CALL_OW 69
9148: AND
9149: PUSH
9150: LD_INT 1
9152: PPUSH
9153: CALL_OW 463
9157: NOT
9158: AND
9159: IFFALSE 9339
9161: GO 9163
9163: DISABLE
// begin InGameOn ;
9164: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
9168: LD_EXP 8
9172: PPUSH
9173: LD_EXP 17
9177: PPUSH
9178: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
9182: LD_EXP 17
9186: PPUSH
9187: LD_EXP 8
9191: PPUSH
9192: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
9196: LD_EXP 17
9200: PPUSH
9201: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
9205: LD_EXP 17
9209: PPUSH
9210: LD_STRING D3b-Yam-1
9212: PPUSH
9213: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
9217: LD_EXP 8
9221: PPUSH
9222: LD_STRING D3b-JMM-1
9224: PPUSH
9225: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
9229: LD_INT 1
9231: PPUSH
9232: LD_INT 4
9234: PPUSH
9235: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
9239: LD_INT 85
9241: PPUSH
9242: LD_INT 134
9244: PPUSH
9245: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
9249: LD_EXP 17
9253: PPUSH
9254: LD_STRING D3b-Yam-2
9256: PPUSH
9257: CALL_OW 88
// Wait ( 0 0$01 ) ;
9261: LD_INT 35
9263: PPUSH
9264: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
9268: LD_EXP 8
9272: PPUSH
9273: LD_STRING D3b-JMM-2
9275: PPUSH
9276: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
9280: LD_INT 166
9282: PPUSH
9283: LD_INT 136
9285: PPUSH
9286: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
9290: LD_EXP 17
9294: PPUSH
9295: LD_STRING D3b-Yam-3
9297: PPUSH
9298: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
9302: LD_EXP 8
9306: PPUSH
9307: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
9311: LD_EXP 8
9315: PPUSH
9316: LD_STRING D3b-JMM-3a
9318: PPUSH
9319: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
9323: LD_EXP 17
9327: PPUSH
9328: LD_INT 1
9330: PPUSH
9331: CALL_OW 235
// InGameOff ;
9335: CALL_OW 9
// end ;
9339: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , i ;
9340: LD_INT 7
9342: PPUSH
9343: LD_INT 22
9345: PUSH
9346: LD_INT 1
9348: PUSH
9349: EMPTY
9350: LIST
9351: LIST
9352: PUSH
9353: LD_INT 3
9355: PUSH
9356: LD_INT 24
9358: PUSH
9359: LD_INT 1000
9361: PUSH
9362: EMPTY
9363: LIST
9364: LIST
9365: PUSH
9366: EMPTY
9367: LIST
9368: LIST
9369: PUSH
9370: EMPTY
9371: LIST
9372: LIST
9373: PPUSH
9374: CALL_OW 70
9378: IFFALSE 9796
9380: GO 9382
9382: DISABLE
9383: LD_INT 0
9385: PPUSH
9386: PPUSH
9387: PPUSH
// begin un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) [ 1 ] ;
9388: LD_ADDR_VAR 0 1
9392: PUSH
9393: LD_INT 7
9395: PPUSH
9396: LD_INT 22
9398: PUSH
9399: LD_INT 1
9401: PUSH
9402: EMPTY
9403: LIST
9404: LIST
9405: PUSH
9406: LD_INT 3
9408: PUSH
9409: LD_INT 24
9411: PUSH
9412: LD_INT 1000
9414: PUSH
9415: EMPTY
9416: LIST
9417: LIST
9418: PUSH
9419: EMPTY
9420: LIST
9421: LIST
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: PPUSH
9427: CALL_OW 70
9431: PUSH
9432: LD_INT 1
9434: ARRAY
9435: ST_TO_ADDR
// DialogueOn ;
9436: CALL_OW 6
// CenterNowOnUnits ( un ) ;
9440: LD_VAR 0 1
9444: PPUSH
9445: CALL_OW 87
// if Lisa then
9449: LD_EXP 13
9453: IFFALSE 9481
// begin Say ( Lisa , D5-Lisa-1 ) ;
9455: LD_EXP 13
9459: PPUSH
9460: LD_STRING D5-Lisa-1
9462: PPUSH
9463: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
9467: LD_EXP 8
9471: PPUSH
9472: LD_STRING D5-JMM-1a
9474: PPUSH
9475: CALL_OW 88
// end else
9479: GO 9493
// Say ( JMM , D5-JMM-1 ) ;
9481: LD_EXP 8
9485: PPUSH
9486: LD_STRING D5-JMM-1
9488: PPUSH
9489: CALL_OW 88
// DialogueOff ;
9493: CALL_OW 7
// while ( true ) do
9497: LD_INT 1
9499: IFFALSE 9555
// begin wait ( 0 0$01 ) ;
9501: LD_INT 35
9503: PPUSH
9504: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
9508: LD_ADDR_VAR 0 2
9512: PUSH
9513: LD_INT 8
9515: PPUSH
9516: LD_INT 30
9518: PUSH
9519: LD_INT 26
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: PUSH
9526: LD_INT 101
9528: PUSH
9529: LD_INT 1
9531: PUSH
9532: EMPTY
9533: LIST
9534: LIST
9535: PUSH
9536: EMPTY
9537: LIST
9538: LIST
9539: PPUSH
9540: CALL_OW 71
9544: ST_TO_ADDR
// if x then
9545: LD_VAR 0 2
9549: IFFALSE 9553
// break ;
9551: GO 9555
// end ;
9553: GO 9497
// CenterOnUnits ( x [ 1 ] ) ;
9555: LD_VAR 0 2
9559: PUSH
9560: LD_INT 1
9562: ARRAY
9563: PPUSH
9564: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
9568: LD_EXP 14
9572: PUSH
9573: LD_EXP 14
9577: PPUSH
9578: CALL_OW 255
9582: PUSH
9583: LD_INT 1
9585: EQUAL
9586: AND
9587: IFFALSE 9603
// Say ( Frank , D5a-Frank-1 ) else
9589: LD_EXP 14
9593: PPUSH
9594: LD_STRING D5a-Frank-1
9596: PPUSH
9597: CALL_OW 88
9601: GO 9657
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
9603: LD_EXP 17
9607: PUSH
9608: LD_EXP 17
9612: PPUSH
9613: CALL_OW 255
9617: PUSH
9618: LD_INT 1
9620: EQUAL
9621: AND
9622: IFFALSE 9638
// Say ( Kikuchi , D5a-Yam-1 ) else
9624: LD_EXP 17
9628: PPUSH
9629: LD_STRING D5a-Yam-1
9631: PPUSH
9632: CALL_OW 88
9636: GO 9657
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
9638: LD_INT 1
9640: PPUSH
9641: CALL 505 0 1
9645: PUSH
9646: LD_INT 1
9648: ARRAY
9649: PPUSH
9650: LD_STRING D5a-Sol1-1
9652: PPUSH
9653: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
9657: LD_EXP 8
9661: PPUSH
9662: LD_STRING D5a-JMM-1
9664: PPUSH
9665: CALL_OW 88
// if Cyrus then
9669: LD_EXP 12
9673: IFFALSE 9687
// Say ( Cyrus , D5a-Cyrus-1 ) ;
9675: LD_EXP 12
9679: PPUSH
9680: LD_STRING D5a-Cyrus-1
9682: PPUSH
9683: CALL_OW 88
// x := false ;
9687: LD_ADDR_VAR 0 2
9691: PUSH
9692: LD_INT 0
9694: ST_TO_ADDR
// while ( true ) do
9695: LD_INT 1
9697: IFFALSE 9784
// begin wait ( 0 0$01 ) ;
9699: LD_INT 35
9701: PPUSH
9702: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
9706: LD_ADDR_VAR 0 3
9710: PUSH
9711: LD_INT 2
9713: PUSH
9714: LD_INT 30
9716: PUSH
9717: LD_INT 0
9719: PUSH
9720: EMPTY
9721: LIST
9722: LIST
9723: PUSH
9724: LD_INT 30
9726: PUSH
9727: LD_INT 1
9729: PUSH
9730: EMPTY
9731: LIST
9732: LIST
9733: PUSH
9734: EMPTY
9735: LIST
9736: LIST
9737: LIST
9738: PPUSH
9739: CALL_OW 69
9743: PUSH
9744: LD_INT 1
9746: DIFF
9747: PUSH
9748: FOR_IN
9749: IFFALSE 9772
// if BaseNeedEnergy ( i ) then
9751: LD_VAR 0 3
9755: PPUSH
9756: CALL 2527 0 1
9760: IFFALSE 9770
// x := true ;
9762: LD_ADDR_VAR 0 2
9766: PUSH
9767: LD_INT 1
9769: ST_TO_ADDR
9770: GO 9748
9772: POP
9773: POP
// if x then
9774: LD_VAR 0 2
9778: IFFALSE 9782
// break ;
9780: GO 9784
// end ;
9782: GO 9695
// Say ( JMM , D5b-JMM-1 ) ;
9784: LD_EXP 8
9788: PPUSH
9789: LD_STRING D5b-JMM-1
9791: PPUSH
9792: CALL_OW 88
// end ;
9796: PPOPN 3
9798: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
9799: LD_EXP 5
9803: PUSH
9804: LD_INT 1
9806: ARRAY
9807: PUSH
9808: LD_OWVAR 1
9812: LESS
9813: IFFALSE 10013
9815: GO 9817
9817: DISABLE
// begin if not IsDead ( ru_dep_main ) then
9818: LD_INT 16
9820: PPUSH
9821: CALL_OW 301
9825: NOT
9826: IFFALSE 9849
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
9828: LD_EXP 18
9832: PPUSH
9833: LD_STRING D3b-Har-3
9835: PPUSH
9836: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
9840: LD_STRING M2a
9842: PPUSH
9843: CALL_OW 337
// end else
9847: GO 9868
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
9849: LD_EXP 18
9853: PPUSH
9854: LD_STRING D3b-Har-3a
9856: PPUSH
9857: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
9861: LD_STRING M2
9863: PPUSH
9864: CALL_OW 337
// end ; can_end := true ;
9868: LD_ADDR_EXP 6
9872: PUSH
9873: LD_INT 1
9875: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
9876: LD_INT 9
9878: PPUSH
9879: LD_INT 1
9881: PPUSH
9882: CALL_OW 424
// Wait ( 0 0$02 ) ;
9886: LD_INT 70
9888: PPUSH
9889: CALL_OW 67
// if Lisa then
9893: LD_EXP 13
9897: IFFALSE 9911
// Say ( Lisa , D3b-Lisa ) ;
9899: LD_EXP 13
9903: PPUSH
9904: LD_STRING D3b-Lisa
9906: PPUSH
9907: CALL_OW 88
// if Bobby then
9911: LD_EXP 11
9915: IFFALSE 9929
// Say ( Bobby , D3b-Bobby-3 ) ;
9917: LD_EXP 11
9921: PPUSH
9922: LD_STRING D3b-Bobby-3
9924: PPUSH
9925: CALL_OW 88
// if Cyrus then
9929: LD_EXP 12
9933: IFFALSE 9947
// Say ( Cyrus , D3b-Cyrus-3 ) ;
9935: LD_EXP 12
9939: PPUSH
9940: LD_STRING D3b-Cyrus-3
9942: PPUSH
9943: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
9947: LD_EXP 14
9951: PUSH
9952: LD_EXP 14
9956: PPUSH
9957: CALL_OW 255
9961: PUSH
9962: LD_INT 1
9964: EQUAL
9965: AND
9966: IFFALSE 9980
// Say ( Frank , D3b-Frank-3 ) ;
9968: LD_EXP 14
9972: PPUSH
9973: LD_STRING D3b-Frank-3
9975: PPUSH
9976: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
9980: LD_EXP 17
9984: PUSH
9985: LD_EXP 17
9989: PPUSH
9990: CALL_OW 255
9994: PUSH
9995: LD_INT 1
9997: EQUAL
9998: AND
9999: IFFALSE 10013
// Say ( Kikuchi , D3b-Yam-4 ) ;
10001: LD_EXP 17
10005: PPUSH
10006: LD_STRING D3b-Yam-4
10008: PPUSH
10009: CALL_OW 88
// end ;
10013: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
10014: LD_EXP 5
10018: PUSH
10019: LD_INT 2
10021: ARRAY
10022: PUSH
10023: LD_OWVAR 1
10027: LESS
10028: IFFALSE 10060
10030: GO 10032
10032: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
10033: LD_EXP 18
10037: PPUSH
10038: LD_STRING D4-Har-1
10040: PPUSH
10041: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
10045: LD_STRING M3
10047: PPUSH
10048: CALL_OW 337
// must_end := true ;
10052: LD_ADDR_EXP 7
10056: PUSH
10057: LD_INT 1
10059: ST_TO_ADDR
// end ;
10060: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
10061: LD_EXP 5
10065: PUSH
10066: LD_INT 3
10068: ARRAY
10069: PUSH
10070: LD_OWVAR 1
10074: LESS
10075: IFFALSE 10106
10077: GO 10079
10079: DISABLE
// begin if not IsDead ( ru_dep_main ) then
10080: LD_INT 16
10082: PPUSH
10083: CALL_OW 301
10087: NOT
10088: IFFALSE 10099
// YouLost ( TimeOut1 ) else
10090: LD_STRING TimeOut1
10092: PPUSH
10093: CALL_OW 104
10097: GO 10106
// YouLost ( TimeOut2 ) ;
10099: LD_STRING TimeOut2
10101: PPUSH
10102: CALL_OW 104
// end ;
10106: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , i , tmp ;
10107: LD_EXP 8
10111: PPUSH
10112: LD_INT 9
10114: PPUSH
10115: CALL_OW 308
10119: PUSH
10120: LD_EXP 6
10124: AND
10125: IFFALSE 11119
10127: GO 10129
10129: DISABLE
10130: LD_INT 0
10132: PPUSH
10133: PPUSH
10134: PPUSH
// begin wait_on := false ;
10135: LD_ADDR_VAR 0 1
10139: PUSH
10140: LD_INT 0
10142: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
10143: LD_INT 1
10145: PPUSH
10146: CALL 2604 0 1
10150: PUSH
10151: LD_INT 0
10153: PLUS
10154: PUSH
10155: LD_INT 1
10157: PPUSH
10158: LD_INT 9
10160: PPUSH
10161: CALL 2695 0 2
10165: PUSH
10166: LD_INT 1
10168: PPUSH
10169: LD_INT 9
10171: PPUSH
10172: CALL 2742 0 2
10176: ADD
10177: PUSH
10178: LD_INT 0
10180: PLUS
10181: GREATER
10182: IFFALSE 10231
// case Query ( Q1 ) of 1 :
10184: LD_STRING Q1
10186: PPUSH
10187: CALL_OW 97
10191: PUSH
10192: LD_INT 1
10194: DOUBLE
10195: EQUAL
10196: IFTRUE 10200
10198: GO 10211
10200: POP
// wait_on := true ; 2 :
10201: LD_ADDR_VAR 0 1
10205: PUSH
10206: LD_INT 1
10208: ST_TO_ADDR
10209: GO 10231
10211: LD_INT 2
10213: DOUBLE
10214: EQUAL
10215: IFTRUE 10219
10217: GO 10230
10219: POP
// wait_on := false ; end ;
10220: LD_ADDR_VAR 0 1
10224: PUSH
10225: LD_INT 0
10227: ST_TO_ADDR
10228: GO 10231
10230: POP
// repeat wait ( 0 0$01 ) ;
10231: LD_INT 35
10233: PPUSH
10234: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
10238: LD_VAR 0 1
10242: NOT
10243: PUSH
10244: LD_INT 1
10246: PPUSH
10247: CALL 2604 0 1
10251: PUSH
10252: LD_INT 0
10254: PLUS
10255: PUSH
10256: LD_INT 1
10258: PPUSH
10259: LD_INT 9
10261: PPUSH
10262: CALL 2695 0 2
10266: PUSH
10267: LD_INT 1
10269: PPUSH
10270: LD_INT 9
10272: PPUSH
10273: CALL 2742 0 2
10277: ADD
10278: PUSH
10279: LD_INT 0
10281: PLUS
10282: EQUAL
10283: OR
10284: IFFALSE 10231
// DialogueOn ;
10286: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10290: LD_EXP 8
10294: PPUSH
10295: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
10299: LD_EXP 8
10303: PPUSH
10304: LD_STRING D6-JMM-1
10306: PPUSH
10307: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
10311: LD_EXP 18
10315: PPUSH
10316: LD_STRING D6-Har-1
10318: PPUSH
10319: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
10323: LD_EXP 8
10327: PPUSH
10328: LD_STRING D6-JMM-2
10330: PPUSH
10331: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
10335: LD_EXP 18
10339: PPUSH
10340: LD_STRING D6-Har-2
10342: PPUSH
10343: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
10347: LD_EXP 8
10351: PPUSH
10352: LD_STRING D6-JMM-3
10354: PPUSH
10355: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
10359: LD_EXP 18
10363: PPUSH
10364: LD_STRING D6-Har-3
10366: PPUSH
10367: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
10371: LD_EXP 8
10375: PPUSH
10376: LD_STRING D6-JMM-4
10378: PPUSH
10379: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
10383: LD_EXP 18
10387: PPUSH
10388: LD_STRING D6-Har-4
10390: PPUSH
10391: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
10395: LD_EXP 8
10399: PPUSH
10400: LD_STRING D6-JMM-5
10402: PPUSH
10403: CALL_OW 88
// DialogueOff ;
10407: CALL_OW 7
// tmp := FilterBuildings ( 3 ) ;
10411: LD_ADDR_VAR 0 3
10415: PUSH
10416: LD_INT 3
10418: PPUSH
10419: CALL 2873 0 1
10423: ST_TO_ADDR
// if tmp >= 35 then
10424: LD_VAR 0 3
10428: PUSH
10429: LD_INT 35
10431: GREATEREQUAL
10432: IFFALSE 10469
// begin AddMedal ( Destroy1 , - 1 ) ;
10434: LD_STRING Destroy1
10436: PPUSH
10437: LD_INT 1
10439: NEG
10440: PPUSH
10441: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
10445: LD_STRING Destroy2
10447: PPUSH
10448: LD_INT 1
10450: NEG
10451: PPUSH
10452: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
10456: LD_STRING Destroy3
10458: PPUSH
10459: LD_INT 1
10461: NEG
10462: PPUSH
10463: CALL_OW 101
// end else
10467: GO 10556
// begin AddMedal ( Destroy1 , 1 ) ;
10469: LD_STRING Destroy1
10471: PPUSH
10472: LD_INT 1
10474: PPUSH
10475: CALL_OW 101
// if tmp >= 25 then
10479: LD_VAR 0 3
10483: PUSH
10484: LD_INT 25
10486: GREATEREQUAL
10487: IFFALSE 10513
// begin AddMedal ( Destroy2 , - 1 ) ;
10489: LD_STRING Destroy2
10491: PPUSH
10492: LD_INT 1
10494: NEG
10495: PPUSH
10496: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
10500: LD_STRING Destroy3
10502: PPUSH
10503: LD_INT 1
10505: NEG
10506: PPUSH
10507: CALL_OW 101
// end else
10511: GO 10556
// begin AddMedal ( Destroy2 , 1 ) ;
10513: LD_STRING Destroy2
10515: PPUSH
10516: LD_INT 1
10518: PPUSH
10519: CALL_OW 101
// if tmp >= 15 then
10523: LD_VAR 0 3
10527: PUSH
10528: LD_INT 15
10530: GREATEREQUAL
10531: IFFALSE 10546
// AddMedal ( Destroy3 , - 1 ) else
10533: LD_STRING Destroy3
10535: PPUSH
10536: LD_INT 1
10538: NEG
10539: PPUSH
10540: CALL_OW 101
10544: GO 10556
// AddMedal ( Destroy3 , 1 ) ;
10546: LD_STRING Destroy3
10548: PPUSH
10549: LD_INT 1
10551: PPUSH
10552: CALL_OW 101
// end ; end ; GiveMedals ( MAIN ) ;
10556: LD_STRING MAIN
10558: PPUSH
10559: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ;
10563: LD_ADDR_VAR 0 3
10567: PUSH
10568: LD_INT 1
10570: PPUSH
10571: LD_INT 9
10573: PPUSH
10574: CALL 2695 0 2
10578: PUSH
10579: LD_INT 1
10581: PPUSH
10582: LD_INT 9
10584: PPUSH
10585: CALL 2742 0 2
10589: ADD
10590: ST_TO_ADDR
// RewardPeople ( tmp ) ;
10591: LD_VAR 0 3
10595: PPUSH
10596: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
10600: LD_EXP 8
10604: PPUSH
10605: LD_EXP 3
10609: PUSH
10610: LD_STRING JMM
10612: STR
10613: PPUSH
10614: CALL_OW 38
// if Brown in tmp then
10618: LD_EXP 9
10622: PUSH
10623: LD_VAR 0 3
10627: IN
10628: IFFALSE 10648
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
10630: LD_EXP 9
10634: PPUSH
10635: LD_EXP 3
10639: PUSH
10640: LD_STRING Brown
10642: STR
10643: PPUSH
10644: CALL_OW 38
// if Donaldson in tmp then
10648: LD_EXP 10
10652: PUSH
10653: LD_VAR 0 3
10657: IN
10658: IFFALSE 10678
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
10660: LD_EXP 10
10664: PPUSH
10665: LD_EXP 3
10669: PUSH
10670: LD_STRING Donaldson
10672: STR
10673: PPUSH
10674: CALL_OW 38
// if Bobby in tmp then
10678: LD_EXP 11
10682: PUSH
10683: LD_VAR 0 3
10687: IN
10688: IFFALSE 10708
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
10690: LD_EXP 11
10694: PPUSH
10695: LD_EXP 3
10699: PUSH
10700: LD_STRING Bobby
10702: STR
10703: PPUSH
10704: CALL_OW 38
// if Cyrus in tmp then
10708: LD_EXP 12
10712: PUSH
10713: LD_VAR 0 3
10717: IN
10718: IFFALSE 10738
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
10720: LD_EXP 12
10724: PPUSH
10725: LD_EXP 3
10729: PUSH
10730: LD_STRING Cyrus
10732: STR
10733: PPUSH
10734: CALL_OW 38
// if Lisa in tmp then
10738: LD_EXP 13
10742: PUSH
10743: LD_VAR 0 3
10747: IN
10748: IFFALSE 10768
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
10750: LD_EXP 13
10754: PPUSH
10755: LD_EXP 3
10759: PUSH
10760: LD_STRING Lisa
10762: STR
10763: PPUSH
10764: CALL_OW 38
// if Frank in tmp then
10768: LD_EXP 14
10772: PUSH
10773: LD_VAR 0 3
10777: IN
10778: IFFALSE 10798
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
10780: LD_EXP 14
10784: PPUSH
10785: LD_EXP 3
10789: PUSH
10790: LD_STRING Frank
10792: STR
10793: PPUSH
10794: CALL_OW 38
// if Gladstone in tmp then
10798: LD_EXP 15
10802: PUSH
10803: LD_VAR 0 3
10807: IN
10808: IFFALSE 10828
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
10810: LD_EXP 15
10814: PPUSH
10815: LD_EXP 3
10819: PUSH
10820: LD_STRING Gladstone
10822: STR
10823: PPUSH
10824: CALL_OW 38
// if Khatam in tmp then
10828: LD_EXP 16
10832: PUSH
10833: LD_VAR 0 3
10837: IN
10838: IFFALSE 10858
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
10840: LD_EXP 16
10844: PPUSH
10845: LD_EXP 3
10849: PUSH
10850: LD_STRING Khatam
10852: STR
10853: PPUSH
10854: CALL_OW 38
// if Kikuchi in tmp then
10858: LD_EXP 17
10862: PUSH
10863: LD_VAR 0 3
10867: IN
10868: IFFALSE 10888
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
10870: LD_EXP 17
10874: PPUSH
10875: LD_EXP 3
10879: PUSH
10880: LD_STRING Kikuchi
10882: STR
10883: PPUSH
10884: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] , mission_prefix & others ) ;
10888: LD_VAR 0 3
10892: PUSH
10893: LD_EXP 8
10897: PUSH
10898: LD_EXP 9
10902: PUSH
10903: LD_EXP 10
10907: PUSH
10908: LD_EXP 11
10912: PUSH
10913: LD_EXP 12
10917: PUSH
10918: LD_EXP 13
10922: PUSH
10923: LD_EXP 14
10927: PUSH
10928: LD_EXP 15
10932: PUSH
10933: LD_EXP 17
10937: PUSH
10938: LD_EXP 16
10942: PUSH
10943: EMPTY
10944: LIST
10945: LIST
10946: LIST
10947: LIST
10948: LIST
10949: LIST
10950: LIST
10951: LIST
10952: LIST
10953: LIST
10954: DIFF
10955: PPUSH
10956: LD_EXP 3
10960: PUSH
10961: LD_STRING others
10963: STR
10964: PPUSH
10965: CALL_OW 38
// SaveVariable ( tick , 07_time ) ;
10969: LD_OWVAR 1
10973: PPUSH
10974: LD_STRING 07_time
10976: PPUSH
10977: CALL_OW 39
// tmp := [ ] ;
10981: LD_ADDR_VAR 0 3
10985: PUSH
10986: EMPTY
10987: ST_TO_ADDR
// for i in FilterUnitsInArea ( endArea , [ [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ] ) do
10988: LD_ADDR_VAR 0 2
10992: PUSH
10993: LD_INT 9
10995: PPUSH
10996: LD_INT 22
10998: PUSH
10999: LD_INT 1
11001: PUSH
11002: EMPTY
11003: LIST
11004: LIST
11005: PUSH
11006: LD_INT 23
11008: PUSH
11009: LD_INT 1
11011: PUSH
11012: EMPTY
11013: LIST
11014: LIST
11015: PUSH
11016: LD_INT 21
11018: PUSH
11019: LD_INT 2
11021: PUSH
11022: EMPTY
11023: LIST
11024: LIST
11025: PUSH
11026: EMPTY
11027: LIST
11028: LIST
11029: LIST
11030: PUSH
11031: EMPTY
11032: LIST
11033: PPUSH
11034: CALL_OW 70
11038: PUSH
11039: FOR_IN
11040: IFFALSE 11101
// tmp := tmp ^ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
11042: LD_ADDR_VAR 0 3
11046: PUSH
11047: LD_VAR 0 3
11051: PUSH
11052: LD_VAR 0 2
11056: PPUSH
11057: CALL_OW 265
11061: PUSH
11062: LD_VAR 0 2
11066: PPUSH
11067: CALL_OW 262
11071: PUSH
11072: LD_VAR 0 2
11076: PPUSH
11077: CALL_OW 263
11081: PUSH
11082: LD_VAR 0 2
11086: PPUSH
11087: CALL_OW 264
11091: PUSH
11092: EMPTY
11093: LIST
11094: LIST
11095: LIST
11096: LIST
11097: ADD
11098: ST_TO_ADDR
11099: GO 11039
11101: POP
11102: POP
// SaveVariable ( tmp , 07_vehicles ) ;
11103: LD_VAR 0 3
11107: PPUSH
11108: LD_STRING 07_vehicles
11110: PPUSH
11111: CALL_OW 39
// YouWin ;
11115: CALL_OW 103
// end ; end_of_file
11119: PPOPN 3
11121: END
// on UnitDestroyed ( un ) do begin if un = JMM then
11122: LD_VAR 0 1
11126: PUSH
11127: LD_EXP 8
11131: EQUAL
11132: IFFALSE 11141
// YouLost ( JMM ) ;
11134: LD_STRING JMM
11136: PPUSH
11137: CALL_OW 104
// if GetType ( un ) = unit_building then
11141: LD_VAR 0 1
11145: PPUSH
11146: CALL_OW 247
11150: PUSH
11151: LD_INT 3
11153: EQUAL
11154: IFFALSE 11170
// buildings_counter := buildings_counter + 1 ;
11156: LD_ADDR_EXP 4
11160: PUSH
11161: LD_EXP 4
11165: PUSH
11166: LD_INT 1
11168: PLUS
11169: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
11170: LD_VAR 0 1
11174: PUSH
11175: LD_INT 6
11177: PPUSH
11178: LD_INT 2
11180: PUSH
11181: LD_INT 30
11183: PUSH
11184: LD_INT 33
11186: PUSH
11187: EMPTY
11188: LIST
11189: LIST
11190: PUSH
11191: LD_INT 30
11193: PUSH
11194: LD_INT 32
11196: PUSH
11197: EMPTY
11198: LIST
11199: LIST
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: LIST
11205: PPUSH
11206: CALL_OW 70
11210: IN
11211: IFFALSE 11270
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
11213: LD_ADDR_EXP 19
11217: PUSH
11218: LD_EXP 19
11222: PUSH
11223: LD_VAR 0 1
11227: PPUSH
11228: CALL_OW 266
11232: PUSH
11233: LD_VAR 0 1
11237: PPUSH
11238: CALL_OW 250
11242: PUSH
11243: LD_VAR 0 1
11247: PPUSH
11248: CALL_OW 251
11252: PUSH
11253: LD_VAR 0 1
11257: PPUSH
11258: CALL_OW 254
11262: PUSH
11263: EMPTY
11264: LIST
11265: LIST
11266: LIST
11267: LIST
11268: ADD
11269: ST_TO_ADDR
// if un = ru_dep_main then
11270: LD_VAR 0 1
11274: PUSH
11275: LD_INT 16
11277: EQUAL
11278: IFFALSE 11287
// ChangeMissionObjectives ( M1a ) ;
11280: LD_STRING M1a
11282: PPUSH
11283: CALL_OW 337
// end ;
11287: PPOPN 1
11289: END
// on BuildingStarted ( b , builder ) do var i ;
11290: LD_INT 0
11292: PPUSH
// begin if GetSide ( b ) = 3 then
11293: LD_VAR 0 1
11297: PPUSH
11298: CALL_OW 255
11302: PUSH
11303: LD_INT 3
11305: EQUAL
11306: IFFALSE 11346
// for i = 1 to 4 do
11308: LD_ADDR_VAR 0 3
11312: PUSH
11313: DOUBLE
11314: LD_INT 1
11316: DEC
11317: ST_TO_ADDR
11318: LD_INT 4
11320: PUSH
11321: FOR_TO
11322: IFFALSE 11344
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
11324: LD_ADDR_EXP 19
11328: PUSH
11329: LD_EXP 19
11333: PPUSH
11334: LD_INT 1
11336: PPUSH
11337: CALL_OW 3
11341: ST_TO_ADDR
11342: GO 11321
11344: POP
11345: POP
// end ;
11346: PPOPN 3
11348: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
11349: LD_VAR 0 1
11353: PPUSH
11354: CALL_OW 266
11358: PUSH
11359: LD_INT 32
11361: PUSH
11362: LD_INT 33
11364: PUSH
11365: EMPTY
11366: LIST
11367: LIST
11368: IN
11369: IFFALSE 11383
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
11371: LD_VAR 0 1
11375: PPUSH
11376: LD_INT 43
11378: PPUSH
11379: CALL_OW 148
11383: PPOPN 1
11385: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
11386: LD_VAR 0 1
11390: PUSH
11391: LD_INT 22
11393: PUSH
11394: LD_INT 3
11396: PUSH
11397: EMPTY
11398: LIST
11399: LIST
11400: PUSH
11401: LD_INT 2
11403: PUSH
11404: LD_INT 30
11406: PUSH
11407: LD_INT 31
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: PUSH
11414: LD_INT 30
11416: PUSH
11417: LD_INT 32
11419: PUSH
11420: EMPTY
11421: LIST
11422: LIST
11423: PUSH
11424: EMPTY
11425: LIST
11426: LIST
11427: LIST
11428: PUSH
11429: EMPTY
11430: LIST
11431: LIST
11432: PPUSH
11433: CALL_OW 69
11437: IN
11438: IFFALSE 11460
// GoToAnotherTower ( un , b , 143 , 143 ) ;
11440: LD_VAR 0 2
11444: PPUSH
11445: LD_VAR 0 1
11449: PPUSH
11450: LD_INT 143
11452: PPUSH
11453: LD_INT 143
11455: PPUSH
11456: CALL 2054 0 4
// end ;
11460: PPOPN 2
11462: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
11463: LD_VAR 0 1
11467: PUSH
11468: LD_INT 22
11470: PUSH
11471: LD_INT 3
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: PUSH
11478: LD_INT 30
11480: PUSH
11481: LD_INT 32
11483: PUSH
11484: EMPTY
11485: LIST
11486: LIST
11487: PUSH
11488: EMPTY
11489: LIST
11490: LIST
11491: PPUSH
11492: CALL_OW 69
11496: IN
11497: IFFALSE 11511
// SetTag ( b , 0 ) ;
11499: LD_VAR 0 1
11503: PPUSH
11504: LD_INT 0
11506: PPUSH
11507: CALL_OW 109
// end ;
11511: PPOPN 2
11513: END
