// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 33 0 0
// DebugMode ;
  12: CALL 234 0 0
// PrepareNature ;
  16: CALL 1552 0 0
// PrepareRussians ;
  20: CALL 3094 0 0
// PrepareAmericans ;
  24: CALL 2037 0 0
// Action ;
  28: CALL 6620 0 0
// end ;
  32: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end , must_end ; function Init ; begin
  33: LD_INT 0
  35: PPUSH
// debug := false ;
  36: LD_ADDR_EXP 1
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// mission_prefix := 07c_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 07c_
  51: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  52: LD_ADDR_EXP 2
  56: PUSH
  57: LD_STRING 07_
  59: ST_TO_ADDR
// buildings_counter := 0 ;
  60: LD_ADDR_EXP 4
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// time_to_end := [ [ 33 33$00 , 30 30$00 , 27 27$00 ] [ Difficulty ] , [ 39 39$00 , 36 36$00 , 33 33$00 ] [ Difficulty ] , [ 45 45$00 , 42 42$00 , 39 39$00 ] [ Difficulty ] ] ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 69300
  75: PUSH
  76: LD_INT 63000
  78: PUSH
  79: LD_INT 56700
  81: PUSH
  82: EMPTY
  83: LIST
  84: LIST
  85: LIST
  86: PUSH
  87: LD_OWVAR 67
  91: ARRAY
  92: PUSH
  93: LD_INT 81900
  95: PUSH
  96: LD_INT 75600
  98: PUSH
  99: LD_INT 69300
 101: PUSH
 102: EMPTY
 103: LIST
 104: LIST
 105: LIST
 106: PUSH
 107: LD_OWVAR 67
 111: ARRAY
 112: PUSH
 113: LD_INT 94500
 115: PUSH
 116: LD_INT 88200
 118: PUSH
 119: LD_INT 81900
 121: PUSH
 122: EMPTY
 123: LIST
 124: LIST
 125: LIST
 126: PUSH
 127: LD_OWVAR 67
 131: ARRAY
 132: PUSH
 133: EMPTY
 134: LIST
 135: LIST
 136: LIST
 137: ST_TO_ADDR
// can_end := false ;
 138: LD_ADDR_EXP 6
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// must_end := false ;
 146: LD_ADDR_EXP 7
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// end ;
 154: LD_VAR 0 1
 158: RET
// every 0 0$01 trigger not debug do
 159: LD_EXP 1
 163: NOT
 164: IFFALSE 233
 166: GO 168
 168: DISABLE
// begin enable ;
 169: ENABLE
// if not must_end then
 170: LD_EXP 7
 174: NOT
 175: IFFALSE 196
// display_strings := [ #Am07-1 , tick ] else
 177: LD_ADDR_OWVAR 47
 181: PUSH
 182: LD_STRING #Am07-1
 184: PUSH
 185: LD_OWVAR 1
 189: PUSH
 190: EMPTY
 191: LIST
 192: LIST
 193: ST_TO_ADDR
 194: GO 233
// display_strings := [ #Am07-1 , tick , #Am07-2 , time_to_end [ 3 ] - tick ] ;
 196: LD_ADDR_OWVAR 47
 200: PUSH
 201: LD_STRING #Am07-1
 203: PUSH
 204: LD_OWVAR 1
 208: PUSH
 209: LD_STRING #Am07-2
 211: PUSH
 212: LD_EXP 5
 216: PUSH
 217: LD_INT 3
 219: ARRAY
 220: PUSH
 221: LD_OWVAR 1
 225: MINUS
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: LIST
 232: ST_TO_ADDR
// end ;
 233: END
// function DebugMode ; begin
 234: LD_INT 0
 236: PPUSH
// if not debug then
 237: LD_EXP 1
 241: NOT
 242: IFFALSE 246
// exit ;
 244: GO 253
// FogOff ( 1 ) ;
 246: LD_INT 1
 248: PPUSH
 249: CALL_OW 344
// end ;
 253: LD_VAR 0 1
 257: RET
// every 3 trigger debug do var i , filter ;
 258: LD_EXP 1
 262: IFFALSE 351
 264: GO 266
 266: DISABLE
 267: LD_INT 0
 269: PPUSH
 270: PPUSH
// begin enable ;
 271: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 272: LD_ADDR_VAR 0 2
 276: PUSH
 277: LD_INT 22
 279: PUSH
 280: LD_INT 1
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: PUSH
 287: LD_INT 3
 289: PUSH
 290: LD_INT 24
 292: PUSH
 293: LD_INT 500
 295: PUSH
 296: EMPTY
 297: LIST
 298: LIST
 299: PUSH
 300: EMPTY
 301: LIST
 302: LIST
 303: PUSH
 304: EMPTY
 305: LIST
 306: LIST
 307: PPUSH
 308: CALL_OW 69
 312: ST_TO_ADDR
// if not filter then
 313: LD_VAR 0 2
 317: NOT
 318: IFFALSE 322
// exit ;
 320: GO 351
// for i in filter do
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_VAR 0 2
 331: PUSH
 332: FOR_IN
 333: IFFALSE 349
// SetLives ( i , 1000 ) ;
 335: LD_VAR 0 1
 339: PPUSH
 340: LD_INT 1000
 342: PPUSH
 343: CALL_OW 234
 347: GO 332
 349: POP
 350: POP
// end ; end_of_file
 351: PPOPN 2
 353: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 354: LD_INT 0
 356: PPUSH
 357: PPUSH
// if exist_mode then
 358: LD_VAR 0 2
 362: IFFALSE 387
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 364: LD_ADDR_VAR 0 4
 368: PUSH
 369: LD_EXP 2
 373: PUSH
 374: LD_VAR 0 1
 378: STR
 379: PPUSH
 380: CALL_OW 34
 384: ST_TO_ADDR
 385: GO 402
// unit := NewCharacter ( ident ) ;
 387: LD_ADDR_VAR 0 4
 391: PUSH
 392: LD_VAR 0 1
 396: PPUSH
 397: CALL_OW 25
 401: ST_TO_ADDR
// result := unit ;
 402: LD_ADDR_VAR 0 3
 406: PUSH
 407: LD_VAR 0 4
 411: ST_TO_ADDR
// end ;
 412: LD_VAR 0 3
 416: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 417: LD_INT 0
 419: PPUSH
// uc_side := side ;
 420: LD_ADDR_OWVAR 20
 424: PUSH
 425: LD_VAR 0 1
 429: ST_TO_ADDR
// uc_nation := nation ;
 430: LD_ADDR_OWVAR 21
 434: PUSH
 435: LD_VAR 0 2
 439: ST_TO_ADDR
// vc_chassis := chassis ;
 440: LD_ADDR_OWVAR 37
 444: PUSH
 445: LD_VAR 0 3
 449: ST_TO_ADDR
// vc_engine := engine ;
 450: LD_ADDR_OWVAR 39
 454: PUSH
 455: LD_VAR 0 4
 459: ST_TO_ADDR
// vc_control := control ;
 460: LD_ADDR_OWVAR 38
 464: PUSH
 465: LD_VAR 0 5
 469: ST_TO_ADDR
// vc_weapon := weapon ;
 470: LD_ADDR_OWVAR 40
 474: PUSH
 475: LD_VAR 0 6
 479: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 480: LD_ADDR_OWVAR 41
 484: PUSH
 485: LD_VAR 0 7
 489: ST_TO_ADDR
// result := CreateVehicle ;
 490: LD_ADDR_VAR 0 8
 494: PUSH
 495: CALL_OW 45
 499: ST_TO_ADDR
// end ;
 500: LD_VAR 0 8
 504: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 505: LD_INT 0
 507: PPUSH
 508: PPUSH
 509: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 510: LD_ADDR_VAR 0 4
 514: PUSH
 515: LD_INT 22
 517: PUSH
 518: LD_INT 1
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: PUSH
 525: LD_INT 21
 527: PUSH
 528: LD_INT 1
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: PUSH
 535: LD_INT 50
 537: PUSH
 538: EMPTY
 539: LIST
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: PPUSH
 546: CALL_OW 69
 550: PUSH
 551: LD_EXP 8
 555: PUSH
 556: LD_EXP 9
 560: PUSH
 561: LD_EXP 10
 565: PUSH
 566: LD_EXP 11
 570: PUSH
 571: LD_EXP 12
 575: PUSH
 576: LD_EXP 13
 580: PUSH
 581: LD_EXP 14
 585: PUSH
 586: LD_EXP 15
 590: PUSH
 591: LD_EXP 17
 595: PUSH
 596: LD_EXP 16
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: DIFF
 613: ST_TO_ADDR
// if not filter then
 614: LD_VAR 0 4
 618: NOT
 619: IFFALSE 623
// exit ;
 621: GO 650
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 623: LD_ADDR_VAR 0 2
 627: PUSH
 628: LD_VAR 0 4
 632: PPUSH
 633: LD_INT 26
 635: PUSH
 636: LD_VAR 0 1
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL_OW 72
 649: ST_TO_ADDR
// end ;
 650: LD_VAR 0 2
 654: RET
// export function SayX ( units , ident ) ; var i ; begin
 655: LD_INT 0
 657: PPUSH
 658: PPUSH
// result := false ;
 659: LD_ADDR_VAR 0 3
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// if not units then
 667: LD_VAR 0 1
 671: NOT
 672: IFFALSE 676
// exit ;
 674: GO 730
// for i in units do
 676: LD_ADDR_VAR 0 4
 680: PUSH
 681: LD_VAR 0 1
 685: PUSH
 686: FOR_IN
 687: IFFALSE 728
// if IsOk ( i ) then
 689: LD_VAR 0 4
 693: PPUSH
 694: CALL_OW 302
 698: IFFALSE 726
// begin Say ( i , ident ) ;
 700: LD_VAR 0 4
 704: PPUSH
 705: LD_VAR 0 2
 709: PPUSH
 710: CALL_OW 88
// result := i ;
 714: LD_ADDR_VAR 0 3
 718: PUSH
 719: LD_VAR 0 4
 723: ST_TO_ADDR
// break ;
 724: GO 728
// end ;
 726: GO 686
 728: POP
 729: POP
// end ;
 730: LD_VAR 0 3
 734: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
 735: LD_INT 0
 737: PPUSH
 738: PPUSH
 739: PPUSH
 740: PPUSH
 741: PPUSH
// if not un or not IsOk ( un ) then
 742: LD_VAR 0 1
 746: NOT
 747: PUSH
 748: LD_VAR 0 1
 752: PPUSH
 753: CALL_OW 302
 757: NOT
 758: OR
 759: IFFALSE 763
// exit ;
 761: GO 1157
// side := GetSide ( un ) ;
 763: LD_ADDR_VAR 0 9
 767: PUSH
 768: LD_VAR 0 1
 772: PPUSH
 773: CALL_OW 255
 777: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
 778: LD_ADDR_VAR 0 7
 782: PUSH
 783: LD_INT 22
 785: PUSH
 786: LD_VAR 0 9
 790: PUSH
 791: EMPTY
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 30
 797: PUSH
 798: LD_INT 32
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: PUSH
 805: LD_INT 50
 807: PUSH
 808: EMPTY
 809: LIST
 810: PUSH
 811: LD_INT 58
 813: PUSH
 814: EMPTY
 815: LIST
 816: PUSH
 817: EMPTY
 818: LIST
 819: LIST
 820: LIST
 821: LIST
 822: PPUSH
 823: CALL_OW 69
 827: PUSH
 828: LD_VAR 0 2
 832: DIFF
 833: ST_TO_ADDR
// if not filter then
 834: LD_VAR 0 7
 838: NOT
 839: IFFALSE 1022
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
 841: LD_ADDR_VAR 0 7
 845: PUSH
 846: LD_INT 22
 848: PUSH
 849: LD_VAR 0 9
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: PUSH
 858: LD_INT 30
 860: PUSH
 861: LD_INT 5
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PPUSH
 872: CALL_OW 69
 876: ST_TO_ADDR
// if not filter then
 877: LD_VAR 0 7
 881: NOT
 882: IFFALSE 905
// begin ComMoveXY ( un , x , y ) ;
 884: LD_VAR 0 1
 888: PPUSH
 889: LD_VAR 0 3
 893: PPUSH
 894: LD_VAR 0 4
 898: PPUSH
 899: CALL_OW 111
// exit ;
 903: GO 1157
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
 905: LD_ADDR_VAR 0 8
 909: PUSH
 910: LD_VAR 0 7
 914: PPUSH
 915: LD_VAR 0 1
 919: PPUSH
 920: CALL_OW 74
 924: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
 925: LD_VAR 0 8
 929: PPUSH
 930: CALL_OW 313
 934: PUSH
 935: LD_INT 6
 937: EQUAL
 938: IFFALSE 956
// filter := filter diff t ;
 940: LD_ADDR_VAR 0 7
 944: PUSH
 945: LD_VAR 0 7
 949: PUSH
 950: LD_VAR 0 8
 954: DIFF
 955: ST_TO_ADDR
// until UnitsInside ( t ) < 6 or not filter ;
 956: LD_VAR 0 8
 960: PPUSH
 961: CALL_OW 313
 965: PUSH
 966: LD_INT 6
 968: LESS
 969: PUSH
 970: LD_VAR 0 7
 974: NOT
 975: OR
 976: IFFALSE 905
// if not filter then
 978: LD_VAR 0 7
 982: NOT
 983: IFFALSE 1006
// ComMoveXY ( un , x , y ) else
 985: LD_VAR 0 1
 989: PPUSH
 990: LD_VAR 0 3
 994: PPUSH
 995: LD_VAR 0 4
 999: PPUSH
1000: CALL_OW 111
1004: GO 1020
// ComEnterUnit ( un , t ) ;
1006: LD_VAR 0 1
1010: PPUSH
1011: LD_VAR 0 8
1015: PPUSH
1016: CALL_OW 120
// end else
1020: GO 1157
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
1022: LD_ADDR_VAR 0 8
1026: PUSH
1027: LD_VAR 0 7
1031: PPUSH
1032: LD_VAR 0 1
1036: PPUSH
1037: CALL_OW 74
1041: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
1042: LD_VAR 0 8
1046: PPUSH
1047: CALL_OW 110
1051: PUSH
1052: LD_INT 7
1054: EQUAL
1055: IFFALSE 1073
// filter := filter diff t ;
1057: LD_ADDR_VAR 0 7
1061: PUSH
1062: LD_VAR 0 7
1066: PUSH
1067: LD_VAR 0 8
1071: DIFF
1072: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
1073: LD_VAR 0 8
1077: PPUSH
1078: CALL_OW 110
1082: PUSH
1083: LD_INT 7
1085: NONEQUAL
1086: PUSH
1087: LD_VAR 0 7
1091: NOT
1092: OR
1093: IFFALSE 1022
// if GetTag ( t ) <> 7 then
1095: LD_VAR 0 8
1099: PPUSH
1100: CALL_OW 110
1104: PUSH
1105: LD_INT 7
1107: NONEQUAL
1108: IFFALSE 1138
// begin SetTag ( t , 7 ) ;
1110: LD_VAR 0 8
1114: PPUSH
1115: LD_INT 7
1117: PPUSH
1118: CALL_OW 109
// ComEnterUnit ( un , t ) ;
1122: LD_VAR 0 1
1126: PPUSH
1127: LD_VAR 0 8
1131: PPUSH
1132: CALL_OW 120
// end else
1136: GO 1157
// ComMoveXY ( un , x , y ) ;
1138: LD_VAR 0 1
1142: PPUSH
1143: LD_VAR 0 3
1147: PPUSH
1148: LD_VAR 0 4
1152: PPUSH
1153: CALL_OW 111
// end ; end ;
1157: LD_VAR 0 5
1161: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
1162: LD_INT 0
1164: PPUSH
1165: PPUSH
1166: PPUSH
// if not base then
1167: LD_VAR 0 1
1171: NOT
1172: IFFALSE 1176
// exit ;
1174: GO 1234
// tmp := GetEnergy ( GetBase ( base ) ) ;
1176: LD_ADDR_VAR 0 4
1180: PUSH
1181: LD_VAR 0 1
1185: PPUSH
1186: CALL_OW 274
1190: PPUSH
1191: CALL_OW 278
1195: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
1196: LD_VAR 0 4
1200: PUSH
1201: LD_INT 1
1203: ARRAY
1204: PUSH
1205: LD_VAR 0 4
1209: PUSH
1210: LD_INT 4
1212: ARRAY
1213: GREATER
1214: IFFALSE 1226
// result := true else
1216: LD_ADDR_VAR 0 2
1220: PUSH
1221: LD_INT 1
1223: ST_TO_ADDR
1224: GO 1234
// result := false ;
1226: LD_ADDR_VAR 0 2
1230: PUSH
1231: LD_INT 0
1233: ST_TO_ADDR
// end ;
1234: LD_VAR 0 2
1238: RET
// export function FilterPeople ( side ) ; begin
1239: LD_INT 0
1241: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
1242: LD_ADDR_VAR 0 2
1246: PUSH
1247: LD_INT 22
1249: PUSH
1250: LD_VAR 0 1
1254: PUSH
1255: EMPTY
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 21
1261: PUSH
1262: LD_INT 1
1264: PUSH
1265: EMPTY
1266: LIST
1267: LIST
1268: PUSH
1269: EMPTY
1270: LIST
1271: LIST
1272: PPUSH
1273: CALL_OW 69
1277: ST_TO_ADDR
// end ;
1278: LD_VAR 0 2
1282: RET
// export function FilterDrivers ( side ) ; begin
1283: LD_INT 0
1285: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
1286: LD_ADDR_VAR 0 2
1290: PUSH
1291: LD_INT 22
1293: PUSH
1294: LD_VAR 0 1
1298: PUSH
1299: EMPTY
1300: LIST
1301: LIST
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: LD_INT 56
1308: PUSH
1309: EMPTY
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: PUSH
1316: EMPTY
1317: LIST
1318: LIST
1319: PPUSH
1320: CALL_OW 69
1324: ST_TO_ADDR
// end ;
1325: LD_VAR 0 2
1329: RET
// export function FilterPeopleArea ( side , area ) ; begin
1330: LD_INT 0
1332: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
1333: LD_ADDR_VAR 0 3
1337: PUSH
1338: LD_VAR 0 2
1342: PPUSH
1343: LD_INT 22
1345: PUSH
1346: LD_INT 1
1348: PUSH
1349: EMPTY
1350: LIST
1351: LIST
1352: PUSH
1353: LD_INT 21
1355: PUSH
1356: LD_INT 1
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: PUSH
1363: EMPTY
1364: LIST
1365: LIST
1366: PPUSH
1367: CALL_OW 70
1371: ST_TO_ADDR
// end ;
1372: LD_VAR 0 3
1376: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
1377: LD_INT 0
1379: PPUSH
1380: PPUSH
1381: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
1382: LD_ADDR_VAR 0 5
1386: PUSH
1387: LD_VAR 0 2
1391: PPUSH
1392: LD_INT 22
1394: PUSH
1395: LD_INT 1
1397: PUSH
1398: EMPTY
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 21
1404: PUSH
1405: LD_INT 2
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: PUSH
1412: LD_INT 3
1414: PUSH
1415: LD_INT 58
1417: PUSH
1418: EMPTY
1419: LIST
1420: PUSH
1421: EMPTY
1422: LIST
1423: LIST
1424: PUSH
1425: EMPTY
1426: LIST
1427: LIST
1428: LIST
1429: PPUSH
1430: CALL_OW 70
1434: ST_TO_ADDR
// result := [ ] ;
1435: LD_ADDR_VAR 0 3
1439: PUSH
1440: EMPTY
1441: ST_TO_ADDR
// if not tmp then
1442: LD_VAR 0 5
1446: NOT
1447: IFFALSE 1451
// exit ;
1449: GO 1503
// for i in tmp do
1451: LD_ADDR_VAR 0 4
1455: PUSH
1456: LD_VAR 0 5
1460: PUSH
1461: FOR_IN
1462: IFFALSE 1487
// result := result ^ IsDrivenBy ( i ) ;
1464: LD_ADDR_VAR 0 3
1468: PUSH
1469: LD_VAR 0 3
1473: PUSH
1474: LD_VAR 0 4
1478: PPUSH
1479: CALL_OW 311
1483: ADD
1484: ST_TO_ADDR
1485: GO 1461
1487: POP
1488: POP
// result := result diff 0 ;
1489: LD_ADDR_VAR 0 3
1493: PUSH
1494: LD_VAR 0 3
1498: PUSH
1499: LD_INT 0
1501: DIFF
1502: ST_TO_ADDR
// end ;
1503: LD_VAR 0 3
1507: RET
// export function FilterBuildings ( side ) ; begin
1508: LD_INT 0
1510: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
1511: LD_ADDR_VAR 0 2
1515: PUSH
1516: LD_INT 22
1518: PUSH
1519: LD_VAR 0 1
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: PUSH
1528: LD_INT 21
1530: PUSH
1531: LD_INT 3
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: PUSH
1538: EMPTY
1539: LIST
1540: LIST
1541: PPUSH
1542: CALL_OW 69
1546: ST_TO_ADDR
// end ;
1547: LD_VAR 0 2
1551: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
1552: LD_INT 0
1554: PPUSH
1555: PPUSH
1556: PPUSH
1557: PPUSH
// uc_side = 0 ;
1558: LD_ADDR_OWVAR 20
1562: PUSH
1563: LD_INT 0
1565: ST_TO_ADDR
// uc_nation = 0 ;
1566: LD_ADDR_OWVAR 21
1570: PUSH
1571: LD_INT 0
1573: ST_TO_ADDR
// nat_area := wildArea ;
1574: LD_ADDR_VAR 0 4
1578: PUSH
1579: LD_INT 3
1581: ST_TO_ADDR
// InitHc ;
1582: CALL_OW 19
// for i = 1 to 4 do
1586: LD_ADDR_VAR 0 2
1590: PUSH
1591: DOUBLE
1592: LD_INT 1
1594: DEC
1595: ST_TO_ADDR
1596: LD_INT 4
1598: PUSH
1599: FOR_TO
1600: IFFALSE 1655
// begin hc_class = 18 ;
1602: LD_ADDR_OWVAR 28
1606: PUSH
1607: LD_INT 18
1609: ST_TO_ADDR
// hc_gallery =  ;
1610: LD_ADDR_OWVAR 33
1614: PUSH
1615: LD_STRING 
1617: ST_TO_ADDR
// hc_face_number = 1 ;
1618: LD_ADDR_OWVAR 34
1622: PUSH
1623: LD_INT 1
1625: ST_TO_ADDR
// animal := CreateHuman ;
1626: LD_ADDR_VAR 0 3
1630: PUSH
1631: CALL_OW 44
1635: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1636: LD_VAR 0 3
1640: PPUSH
1641: LD_VAR 0 4
1645: PPUSH
1646: LD_INT 0
1648: PPUSH
1649: CALL_OW 49
// end ;
1653: GO 1599
1655: POP
1656: POP
// for i = 1 to 6 do
1657: LD_ADDR_VAR 0 2
1661: PUSH
1662: DOUBLE
1663: LD_INT 1
1665: DEC
1666: ST_TO_ADDR
1667: LD_INT 6
1669: PUSH
1670: FOR_TO
1671: IFFALSE 1742
// begin hc_class = class_tiger ;
1673: LD_ADDR_OWVAR 28
1677: PUSH
1678: LD_INT 14
1680: ST_TO_ADDR
// hc_gallery =  ;
1681: LD_ADDR_OWVAR 33
1685: PUSH
1686: LD_STRING 
1688: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 50 ) ;
1689: LD_ADDR_OWVAR 35
1693: PUSH
1694: LD_INT 0
1696: PPUSH
1697: LD_INT 50
1699: PPUSH
1700: CALL_OW 12
1704: ST_TO_ADDR
// hc_face_number = 3 ;
1705: LD_ADDR_OWVAR 34
1709: PUSH
1710: LD_INT 3
1712: ST_TO_ADDR
// animal := CreateHuman ;
1713: LD_ADDR_VAR 0 3
1717: PUSH
1718: CALL_OW 44
1722: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1723: LD_VAR 0 3
1727: PPUSH
1728: LD_VAR 0 4
1732: PPUSH
1733: LD_INT 0
1735: PPUSH
1736: CALL_OW 49
// end ;
1740: GO 1670
1742: POP
1743: POP
// for i = 1 to 2 do
1744: LD_ADDR_VAR 0 2
1748: PUSH
1749: DOUBLE
1750: LD_INT 1
1752: DEC
1753: ST_TO_ADDR
1754: LD_INT 2
1756: PUSH
1757: FOR_TO
1758: IFFALSE 1821
// begin hc_class = 21 ;
1760: LD_ADDR_OWVAR 28
1764: PUSH
1765: LD_INT 21
1767: ST_TO_ADDR
// hc_gallery =  ;
1768: LD_ADDR_OWVAR 33
1772: PUSH
1773: LD_STRING 
1775: ST_TO_ADDR
// hc_agressivity = 0 ;
1776: LD_ADDR_OWVAR 35
1780: PUSH
1781: LD_INT 0
1783: ST_TO_ADDR
// hc_face_number = 5 ;
1784: LD_ADDR_OWVAR 34
1788: PUSH
1789: LD_INT 5
1791: ST_TO_ADDR
// animal := CreateHuman ;
1792: LD_ADDR_VAR 0 3
1796: PUSH
1797: CALL_OW 44
1801: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1802: LD_VAR 0 3
1806: PPUSH
1807: LD_VAR 0 4
1811: PPUSH
1812: LD_INT 0
1814: PPUSH
1815: CALL_OW 49
// end ;
1819: GO 1757
1821: POP
1822: POP
// for i = 1 to 6 do
1823: LD_ADDR_VAR 0 2
1827: PUSH
1828: DOUBLE
1829: LD_INT 1
1831: DEC
1832: ST_TO_ADDR
1833: LD_INT 6
1835: PUSH
1836: FOR_TO
1837: IFFALSE 1892
// begin hc_class = 13 ;
1839: LD_ADDR_OWVAR 28
1843: PUSH
1844: LD_INT 13
1846: ST_TO_ADDR
// hc_gallery =  ;
1847: LD_ADDR_OWVAR 33
1851: PUSH
1852: LD_STRING 
1854: ST_TO_ADDR
// hc_face_number = 4 ;
1855: LD_ADDR_OWVAR 34
1859: PUSH
1860: LD_INT 4
1862: ST_TO_ADDR
// animal := CreateHuman ;
1863: LD_ADDR_VAR 0 3
1867: PUSH
1868: CALL_OW 44
1872: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1873: LD_VAR 0 3
1877: PPUSH
1878: LD_VAR 0 4
1882: PPUSH
1883: LD_INT 0
1885: PPUSH
1886: CALL_OW 49
// end ;
1890: GO 1836
1892: POP
1893: POP
// for i = 1 to 2 do
1894: LD_ADDR_VAR 0 2
1898: PUSH
1899: DOUBLE
1900: LD_INT 1
1902: DEC
1903: ST_TO_ADDR
1904: LD_INT 2
1906: PUSH
1907: FOR_TO
1908: IFFALSE 1967
// begin hc_class = 20 ;
1910: LD_ADDR_OWVAR 28
1914: PUSH
1915: LD_INT 20
1917: ST_TO_ADDR
// hc_gallery =  ;
1918: LD_ADDR_OWVAR 33
1922: PUSH
1923: LD_STRING 
1925: ST_TO_ADDR
// hc_face_number = 2 ;
1926: LD_ADDR_OWVAR 34
1930: PUSH
1931: LD_INT 2
1933: ST_TO_ADDR
// animal := CreateHuman ;
1934: LD_ADDR_VAR 0 3
1938: PUSH
1939: CALL_OW 44
1943: ST_TO_ADDR
// PlaceUnitXYR ( animal , 101 , 37 , 3 , false ) ;
1944: LD_VAR 0 3
1948: PPUSH
1949: LD_INT 101
1951: PPUSH
1952: LD_INT 37
1954: PPUSH
1955: LD_INT 3
1957: PPUSH
1958: LD_INT 0
1960: PPUSH
1961: CALL_OW 50
// end ;
1965: GO 1907
1967: POP
1968: POP
// for i = 1 to 1 do
1969: LD_ADDR_VAR 0 2
1973: PUSH
1974: DOUBLE
1975: LD_INT 1
1977: DEC
1978: ST_TO_ADDR
1979: LD_INT 1
1981: PUSH
1982: FOR_TO
1983: IFFALSE 2030
// begin vc_chassis := 31 ;
1985: LD_ADDR_OWVAR 37
1989: PUSH
1990: LD_INT 31
1992: ST_TO_ADDR
// vc_control := control_rider ;
1993: LD_ADDR_OWVAR 38
1997: PUSH
1998: LD_INT 4
2000: ST_TO_ADDR
// animal := CreateVehicle ;
2001: LD_ADDR_VAR 0 3
2005: PUSH
2006: CALL_OW 45
2010: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
2011: LD_VAR 0 3
2015: PPUSH
2016: LD_VAR 0 4
2020: PPUSH
2021: LD_INT 0
2023: PPUSH
2024: CALL_OW 49
// end ;
2028: GO 1982
2030: POP
2031: POP
// end ; end_of_file
2032: LD_VAR 0 1
2036: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
2037: LD_INT 0
2039: PPUSH
2040: PPUSH
2041: PPUSH
2042: PPUSH
2043: PPUSH
2044: PPUSH
// uc_side := 1 ;
2045: LD_ADDR_OWVAR 20
2049: PUSH
2050: LD_INT 1
2052: ST_TO_ADDR
// uc_nation := 1 ;
2053: LD_ADDR_OWVAR 21
2057: PUSH
2058: LD_INT 1
2060: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
2061: LD_ADDR_EXP 8
2065: PUSH
2066: LD_STRING JMM
2068: PPUSH
2069: LD_EXP 1
2073: NOT
2074: PPUSH
2075: CALL 354 0 2
2079: ST_TO_ADDR
// team := [ JMM ] ;
2080: LD_ADDR_VAR 0 3
2084: PUSH
2085: LD_EXP 8
2089: PUSH
2090: EMPTY
2091: LIST
2092: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
2093: LD_STRING BrownIn07
2095: PPUSH
2096: LD_EXP 1
2100: PPUSH
2101: CALL_OW 30
2105: IFFALSE 2126
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
2107: LD_ADDR_EXP 9
2111: PUSH
2112: LD_STRING Brown
2114: PPUSH
2115: LD_EXP 1
2119: NOT
2120: PPUSH
2121: CALL 354 0 2
2125: ST_TO_ADDR
// if Brown then
2126: LD_EXP 9
2130: IFFALSE 2148
// team := team ^ Brown ;
2132: LD_ADDR_VAR 0 3
2136: PUSH
2137: LD_VAR 0 3
2141: PUSH
2142: LD_EXP 9
2146: ADD
2147: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
2148: LD_STRING DonaldsonIn07
2150: PPUSH
2151: LD_EXP 1
2155: PPUSH
2156: CALL_OW 30
2160: IFFALSE 2181
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
2162: LD_ADDR_EXP 10
2166: PUSH
2167: LD_STRING Donaldson
2169: PPUSH
2170: LD_EXP 1
2174: NOT
2175: PPUSH
2176: CALL 354 0 2
2180: ST_TO_ADDR
// if Donaldson then
2181: LD_EXP 10
2185: IFFALSE 2203
// team := team ^ Donaldson ;
2187: LD_ADDR_VAR 0 3
2191: PUSH
2192: LD_VAR 0 3
2196: PUSH
2197: LD_EXP 10
2201: ADD
2202: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
2203: LD_STRING BobbyIn07
2205: PPUSH
2206: LD_EXP 1
2210: PPUSH
2211: CALL_OW 30
2215: IFFALSE 2236
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
2217: LD_ADDR_EXP 11
2221: PUSH
2222: LD_STRING Bobby
2224: PPUSH
2225: LD_EXP 1
2229: NOT
2230: PPUSH
2231: CALL 354 0 2
2235: ST_TO_ADDR
// if Bobby then
2236: LD_EXP 11
2240: IFFALSE 2258
// team := team ^ Bobby ;
2242: LD_ADDR_VAR 0 3
2246: PUSH
2247: LD_VAR 0 3
2251: PUSH
2252: LD_EXP 11
2256: ADD
2257: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
2258: LD_STRING CyrusIn07
2260: PPUSH
2261: LD_EXP 1
2265: PPUSH
2266: CALL_OW 30
2270: IFFALSE 2291
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
2272: LD_ADDR_EXP 12
2276: PUSH
2277: LD_STRING Cyrus
2279: PPUSH
2280: LD_EXP 1
2284: NOT
2285: PPUSH
2286: CALL 354 0 2
2290: ST_TO_ADDR
// if Cyrus then
2291: LD_EXP 12
2295: IFFALSE 2313
// team := team ^ Cyrus ;
2297: LD_ADDR_VAR 0 3
2301: PUSH
2302: LD_VAR 0 3
2306: PUSH
2307: LD_EXP 12
2311: ADD
2312: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
2313: LD_STRING LisaIn07
2315: PPUSH
2316: LD_EXP 1
2320: PPUSH
2321: CALL_OW 30
2325: IFFALSE 2346
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
2327: LD_ADDR_EXP 13
2331: PUSH
2332: LD_STRING Lisa
2334: PPUSH
2335: LD_EXP 1
2339: NOT
2340: PPUSH
2341: CALL 354 0 2
2345: ST_TO_ADDR
// if Lisa then
2346: LD_EXP 13
2350: IFFALSE 2368
// team := team ^ Lisa ;
2352: LD_ADDR_VAR 0 3
2356: PUSH
2357: LD_VAR 0 3
2361: PUSH
2362: LD_EXP 13
2366: ADD
2367: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
2368: LD_STRING GladstoneIn07
2370: PPUSH
2371: LD_EXP 1
2375: PPUSH
2376: CALL_OW 30
2380: IFFALSE 2401
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
2382: LD_ADDR_EXP 15
2386: PUSH
2387: LD_STRING Gladstone
2389: PPUSH
2390: LD_EXP 1
2394: NOT
2395: PPUSH
2396: CALL 354 0 2
2400: ST_TO_ADDR
// if Gladstone then
2401: LD_EXP 15
2405: IFFALSE 2423
// team := team ^ Gladstone ;
2407: LD_ADDR_VAR 0 3
2411: PUSH
2412: LD_VAR 0 3
2416: PUSH
2417: LD_EXP 15
2421: ADD
2422: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
2423: LD_STRING KhatamIn07
2425: PPUSH
2426: LD_EXP 1
2430: PPUSH
2431: CALL_OW 30
2435: IFFALSE 2456
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
2437: LD_ADDR_EXP 16
2441: PUSH
2442: LD_STRING Khatam
2444: PPUSH
2445: LD_EXP 1
2449: NOT
2450: PPUSH
2451: CALL 354 0 2
2455: ST_TO_ADDR
// if Khatam then
2456: LD_EXP 16
2460: IFFALSE 2478
// team := team ^ Khatam ;
2462: LD_ADDR_VAR 0 3
2466: PUSH
2467: LD_VAR 0 3
2471: PUSH
2472: LD_EXP 16
2476: ADD
2477: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
2478: LD_ADDR_VAR 0 4
2482: PUSH
2483: LD_STRING 07_others
2485: PPUSH
2486: CALL_OW 31
2490: ST_TO_ADDR
// if others then
2491: LD_VAR 0 4
2495: IFFALSE 2513
// team := team ^ others ;
2497: LD_ADDR_VAR 0 3
2501: PUSH
2502: LD_VAR 0 3
2506: PUSH
2507: LD_VAR 0 4
2511: ADD
2512: ST_TO_ADDR
// if debug then
2513: LD_EXP 1
2517: IFFALSE 2591
// begin InitHc ;
2519: CALL_OW 19
// for i = 1 to 4 do
2523: LD_ADDR_VAR 0 2
2527: PUSH
2528: DOUBLE
2529: LD_INT 1
2531: DEC
2532: ST_TO_ADDR
2533: LD_INT 4
2535: PUSH
2536: FOR_TO
2537: IFFALSE 2589
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
2539: LD_INT 0
2541: PPUSH
2542: LD_INT 1
2544: PUSH
2545: LD_INT 3
2547: PUSH
2548: EMPTY
2549: LIST
2550: LIST
2551: PUSH
2552: LD_INT 1
2554: PPUSH
2555: LD_INT 2
2557: PPUSH
2558: CALL_OW 12
2562: ARRAY
2563: PPUSH
2564: LD_INT 4
2566: PPUSH
2567: CALL_OW 380
// team := team ^ CreateHuman ;
2571: LD_ADDR_VAR 0 3
2575: PUSH
2576: LD_VAR 0 3
2580: PUSH
2581: CALL_OW 44
2585: ADD
2586: ST_TO_ADDR
// end ;
2587: GO 2536
2589: POP
2590: POP
// end ; m := 0 ;
2591: LD_ADDR_VAR 0 6
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// for i in team do
2599: LD_ADDR_VAR 0 2
2603: PUSH
2604: LD_VAR 0 3
2608: PUSH
2609: FOR_IN
2610: IFFALSE 2790
// if GetClass ( i ) = 3 then
2612: LD_VAR 0 2
2616: PPUSH
2617: CALL_OW 257
2621: PUSH
2622: LD_INT 3
2624: EQUAL
2625: IFFALSE 2773
// begin m := m + 1 ;
2627: LD_ADDR_VAR 0 6
2631: PUSH
2632: LD_VAR 0 6
2636: PUSH
2637: LD_INT 1
2639: PLUS
2640: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
2641: LD_ADDR_VAR 0 5
2645: PUSH
2646: LD_INT 1
2648: PPUSH
2649: LD_INT 1
2651: PPUSH
2652: LD_INT 2
2654: PUSH
2655: LD_INT 3
2657: PUSH
2658: LD_INT 2
2660: PUSH
2661: LD_INT 1
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: LIST
2668: LIST
2669: PUSH
2670: LD_VAR 0 6
2674: PUSH
2675: LD_INT 4
2677: MOD
2678: PUSH
2679: LD_INT 1
2681: PLUS
2682: ARRAY
2683: PPUSH
2684: LD_INT 2
2686: PPUSH
2687: LD_INT 1
2689: PPUSH
2690: LD_INT 4
2692: PUSH
2693: LD_INT 5
2695: PUSH
2696: LD_INT 3
2698: PUSH
2699: LD_INT 11
2701: PUSH
2702: EMPTY
2703: LIST
2704: LIST
2705: LIST
2706: LIST
2707: PUSH
2708: LD_VAR 0 6
2712: PUSH
2713: LD_INT 4
2715: MOD
2716: PUSH
2717: LD_INT 1
2719: PLUS
2720: ARRAY
2721: PPUSH
2722: LD_INT 60
2724: PPUSH
2725: CALL 417 0 7
2729: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2730: LD_VAR 0 5
2734: PPUSH
2735: LD_INT 2
2737: PPUSH
2738: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
2742: LD_VAR 0 5
2746: PPUSH
2747: LD_INT 1
2749: PPUSH
2750: LD_INT 0
2752: PPUSH
2753: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2757: LD_VAR 0 2
2761: PPUSH
2762: LD_VAR 0 5
2766: PPUSH
2767: CALL_OW 52
// end else
2771: GO 2788
// PlaceUnitArea ( i , startArea , false ) ;
2773: LD_VAR 0 2
2777: PPUSH
2778: LD_INT 1
2780: PPUSH
2781: LD_INT 0
2783: PPUSH
2784: CALL_OW 49
2788: GO 2609
2790: POP
2791: POP
// uc_side := 4 ;
2792: LD_ADDR_OWVAR 20
2796: PUSH
2797: LD_INT 4
2799: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
2800: LD_ADDR_EXP 18
2804: PUSH
2805: LD_STRING Harisson
2807: PPUSH
2808: LD_INT 0
2810: PPUSH
2811: CALL 354 0 2
2815: ST_TO_ADDR
// PrepareScout ;
2816: CALL 2825 0 0
// end ;
2820: LD_VAR 0 1
2824: RET
// function PrepareScout ; var ape ; begin
2825: LD_INT 0
2827: PPUSH
2828: PPUSH
// uc_side := 4 ;
2829: LD_ADDR_OWVAR 20
2833: PUSH
2834: LD_INT 4
2836: ST_TO_ADDR
// uc_nation := 1 ;
2837: LD_ADDR_OWVAR 21
2841: PUSH
2842: LD_INT 1
2844: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
2845: LD_STRING FrankIn06
2847: PPUSH
2848: LD_INT 0
2850: PPUSH
2851: CALL_OW 30
2855: IFFALSE 2872
// Frank := CreateCharacter ( 06c_Frank ) else
2857: LD_ADDR_EXP 14
2861: PUSH
2862: LD_STRING 06c_Frank
2864: PPUSH
2865: CALL_OW 34
2869: ST_TO_ADDR
2870: GO 2912
// if LoadVariable ( FrankInDelta , 0 ) then
2872: LD_STRING FrankInDelta
2874: PPUSH
2875: LD_INT 0
2877: PPUSH
2878: CALL_OW 30
2882: IFFALSE 2899
// Frank := CreateCharacter ( 05_Frank ) else
2884: LD_ADDR_EXP 14
2888: PUSH
2889: LD_STRING 05_Frank
2891: PPUSH
2892: CALL_OW 34
2896: ST_TO_ADDR
2897: GO 2912
// Frank := CreateCharacter ( 04_Frank ) ;
2899: LD_ADDR_EXP 14
2903: PUSH
2904: LD_STRING 04_Frank
2906: PPUSH
2907: CALL_OW 34
2911: ST_TO_ADDR
// if Frank then
2912: LD_EXP 14
2916: IFFALSE 3049
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
2918: LD_EXP 14
2922: PPUSH
2923: LD_INT 2
2925: PPUSH
2926: LD_INT 0
2928: PPUSH
2929: CALL_OW 49
// SetClass ( Frank , 1 ) ;
2933: LD_EXP 14
2937: PPUSH
2938: LD_INT 1
2940: PPUSH
2941: CALL_OW 336
// uc_side := 0 ;
2945: LD_ADDR_OWVAR 20
2949: PUSH
2950: LD_INT 0
2952: ST_TO_ADDR
// uc_nation := 0 ;
2953: LD_ADDR_OWVAR 21
2957: PUSH
2958: LD_INT 0
2960: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
2961: LD_INT 0
2963: PPUSH
2964: LD_INT 12
2966: PPUSH
2967: LD_INT 0
2969: PPUSH
2970: CALL_OW 380
// ape := CreateHuman ;
2974: LD_ADDR_VAR 0 2
2978: PUSH
2979: CALL_OW 44
2983: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
2984: LD_VAR 0 2
2988: PPUSH
2989: LD_EXP 14
2993: PPUSH
2994: CALL_OW 250
2998: PPUSH
2999: LD_EXP 14
3003: PPUSH
3004: CALL_OW 251
3008: PPUSH
3009: LD_INT 5
3011: PPUSH
3012: LD_INT 0
3014: PPUSH
3015: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
3019: LD_VAR 0 2
3023: PPUSH
3024: LD_EXP 14
3028: PPUSH
3029: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
3033: LD_EXP 14
3037: PPUSH
3038: LD_VAR 0 2
3042: PPUSH
3043: CALL_OW 119
// exit ;
3047: GO 3089
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
3049: LD_ADDR_EXP 17
3053: PUSH
3054: LD_STRING Yamoko
3056: PPUSH
3057: LD_INT 0
3059: PPUSH
3060: CALL 354 0 2
3064: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
3065: LD_EXP 17
3069: PPUSH
3070: LD_INT 2
3072: PPUSH
3073: LD_INT 0
3075: PPUSH
3076: CALL_OW 49
// ComHold ( Kikuchi ) ;
3080: LD_EXP 17
3084: PPUSH
3085: CALL_OW 140
// end ; end_of_file
3089: LD_VAR 0 1
3093: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
3094: LD_INT 0
3096: PPUSH
3097: PPUSH
3098: PPUSH
3099: PPUSH
3100: PPUSH
3101: PPUSH
3102: PPUSH
3103: PPUSH
3104: PPUSH
3105: PPUSH
3106: PPUSH
3107: PPUSH
3108: PPUSH
3109: PPUSH
3110: PPUSH
3111: PPUSH
// ru_rebuild_list := [ ] ;
3112: LD_ADDR_EXP 19
3116: PUSH
3117: EMPTY
3118: ST_TO_ADDR
// uc_side := 3 ;
3119: LD_ADDR_OWVAR 20
3123: PUSH
3124: LD_INT 3
3126: ST_TO_ADDR
// uc_nation := 3 ;
3127: LD_ADDR_OWVAR 21
3131: PUSH
3132: LD_INT 3
3134: ST_TO_ADDR
// if Difficulty > 1 then
3135: LD_OWVAR 67
3139: PUSH
3140: LD_INT 1
3142: GREATER
3143: IFFALSE 3279
// begin bc_type := b_breastwork ;
3145: LD_ADDR_OWVAR 42
3149: PUSH
3150: LD_INT 31
3152: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
3153: LD_INT 78
3155: PPUSH
3156: LD_INT 74
3158: PPUSH
3159: LD_INT 2
3161: PPUSH
3162: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
3166: LD_INT 171
3168: PPUSH
3169: LD_INT 193
3171: PPUSH
3172: LD_INT 4
3174: PPUSH
3175: CALL_OW 47
// bc_type := b_turret ;
3179: LD_ADDR_OWVAR 42
3183: PUSH
3184: LD_INT 33
3186: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
3187: LD_INT 129
3189: PPUSH
3190: LD_INT 96
3192: PPUSH
3193: LD_INT 3
3195: PPUSH
3196: CALL_OW 47
// if Difficulty > 2 then
3200: LD_OWVAR 67
3204: PUSH
3205: LD_INT 2
3207: GREATER
3208: IFFALSE 3279
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
3210: LD_INT 83
3212: PPUSH
3213: LD_INT 141
3215: PPUSH
3216: CALL_OW 428
3220: PPUSH
3221: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
3225: LD_INT 78
3227: PPUSH
3228: LD_INT 133
3230: PPUSH
3231: CALL_OW 428
3235: PPUSH
3236: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
3240: LD_INT 83
3242: PPUSH
3243: LD_INT 141
3245: PPUSH
3246: LD_INT 2
3248: PPUSH
3249: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
3253: LD_INT 78
3255: PPUSH
3256: LD_INT 133
3258: PPUSH
3259: LD_INT 2
3261: PPUSH
3262: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
3266: LD_INT 145
3268: PPUSH
3269: LD_INT 112
3271: PPUSH
3272: LD_INT 3
3274: PPUSH
3275: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
3279: LD_ADDR_VAR 0 9
3283: PUSH
3284: LD_INT 22
3286: PUSH
3287: LD_INT 3
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: LD_INT 2
3296: PUSH
3297: LD_INT 30
3299: PUSH
3300: LD_INT 0
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 30
3309: PUSH
3310: LD_INT 1
3312: PUSH
3313: EMPTY
3314: LIST
3315: LIST
3316: PUSH
3317: EMPTY
3318: LIST
3319: LIST
3320: LIST
3321: PUSH
3322: EMPTY
3323: LIST
3324: LIST
3325: PPUSH
3326: CALL_OW 69
3330: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
3331: LD_ADDR_VAR 0 10
3335: PUSH
3336: LD_INT 22
3338: PUSH
3339: LD_INT 3
3341: PUSH
3342: EMPTY
3343: LIST
3344: LIST
3345: PUSH
3346: LD_INT 2
3348: PUSH
3349: LD_INT 30
3351: PUSH
3352: LD_INT 6
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: PUSH
3359: LD_INT 30
3361: PUSH
3362: LD_INT 7
3364: PUSH
3365: EMPTY
3366: LIST
3367: LIST
3368: PUSH
3369: LD_INT 30
3371: PUSH
3372: LD_INT 8
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: PUSH
3379: EMPTY
3380: LIST
3381: LIST
3382: LIST
3383: LIST
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: PPUSH
3389: CALL_OW 69
3393: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3394: LD_ADDR_VAR 0 11
3398: PUSH
3399: LD_INT 22
3401: PUSH
3402: LD_INT 3
3404: PUSH
3405: EMPTY
3406: LIST
3407: LIST
3408: PUSH
3409: LD_INT 30
3411: PUSH
3412: LD_INT 3
3414: PUSH
3415: EMPTY
3416: LIST
3417: LIST
3418: PUSH
3419: EMPTY
3420: LIST
3421: LIST
3422: PPUSH
3423: CALL_OW 69
3427: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
3428: LD_ADDR_VAR 0 12
3432: PUSH
3433: LD_INT 22
3435: PUSH
3436: LD_INT 3
3438: PUSH
3439: EMPTY
3440: LIST
3441: LIST
3442: PUSH
3443: LD_INT 30
3445: PUSH
3446: LD_INT 31
3448: PUSH
3449: EMPTY
3450: LIST
3451: LIST
3452: PUSH
3453: EMPTY
3454: LIST
3455: LIST
3456: PPUSH
3457: CALL_OW 69
3461: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
3462: LD_ADDR_VAR 0 13
3466: PUSH
3467: LD_INT 22
3469: PUSH
3470: LD_INT 3
3472: PUSH
3473: EMPTY
3474: LIST
3475: LIST
3476: PUSH
3477: LD_INT 30
3479: PUSH
3480: LD_INT 32
3482: PUSH
3483: EMPTY
3484: LIST
3485: LIST
3486: PUSH
3487: EMPTY
3488: LIST
3489: LIST
3490: PPUSH
3491: CALL_OW 69
3495: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3496: LD_ADDR_VAR 0 14
3500: PUSH
3501: LD_INT 22
3503: PUSH
3504: LD_INT 3
3506: PUSH
3507: EMPTY
3508: LIST
3509: LIST
3510: PUSH
3511: LD_INT 30
3513: PUSH
3514: LD_INT 33
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: PUSH
3521: EMPTY
3522: LIST
3523: LIST
3524: PPUSH
3525: CALL_OW 69
3529: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
3530: LD_ADDR_VAR 0 15
3534: PUSH
3535: LD_INT 42
3537: PUSH
3538: LD_INT 5
3540: PUSH
3541: EMPTY
3542: LIST
3543: LIST
3544: PUSH
3545: LD_INT 43
3547: PUSH
3548: LD_INT 50
3550: PUSH
3551: EMPTY
3552: LIST
3553: LIST
3554: PUSH
3555: LD_INT 44
3557: PUSH
3558: LD_INT 30
3560: PUSH
3561: EMPTY
3562: LIST
3563: LIST
3564: PUSH
3565: LD_INT 46
3567: PUSH
3568: LD_INT 15
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: PUSH
3575: EMPTY
3576: LIST
3577: LIST
3578: LIST
3579: LIST
3580: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 4 , 3 ] ;
3581: LD_ADDR_VAR 0 16
3585: PUSH
3586: LD_INT 0
3588: PUSH
3589: LD_INT 4
3591: PUSH
3592: LD_INT 4
3594: PUSH
3595: LD_INT 3
3597: PUSH
3598: EMPTY
3599: LIST
3600: LIST
3601: LIST
3602: LIST
3603: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
3604: LD_ADDR_VAR 0 6
3608: PUSH
3609: LD_INT 4
3611: PUSH
3612: LD_INT 5
3614: PUSH
3615: LD_INT 6
3617: PUSH
3618: EMPTY
3619: LIST
3620: LIST
3621: LIST
3622: PUSH
3623: LD_OWVAR 67
3627: ARRAY
3628: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
3629: LD_INT 16
3631: PPUSH
3632: LD_STRING am_tukh
3634: PPUSH
3635: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
3639: LD_ADDR_VAR 0 2
3643: PUSH
3644: LD_INT 21
3646: PUSH
3647: LD_INT 3
3649: PUSH
3650: EMPTY
3651: LIST
3652: LIST
3653: PPUSH
3654: CALL_OW 69
3658: PUSH
3659: FOR_IN
3660: IFFALSE 3693
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
3662: LD_VAR 0 2
3666: PPUSH
3667: LD_INT 4
3669: PUSH
3670: LD_INT 5
3672: PUSH
3673: LD_INT 6
3675: PUSH
3676: EMPTY
3677: LIST
3678: LIST
3679: LIST
3680: PUSH
3681: LD_OWVAR 67
3685: ARRAY
3686: PPUSH
3687: CALL_OW 241
3691: GO 3659
3693: POP
3694: POP
// for i in dep_list do
3695: LD_ADDR_VAR 0 2
3699: PUSH
3700: LD_VAR 0 9
3704: PUSH
3705: FOR_IN
3706: IFFALSE 3750
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
3708: LD_VAR 0 2
3712: PPUSH
3713: CALL_OW 274
3717: PPUSH
3718: LD_INT 1
3720: PPUSH
3721: LD_INT 1000
3723: PPUSH
3724: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
3728: LD_VAR 0 2
3732: PPUSH
3733: CALL_OW 274
3737: PPUSH
3738: LD_INT 2
3740: PPUSH
3741: LD_INT 1000
3743: PPUSH
3744: CALL_OW 277
// end ;
3748: GO 3705
3750: POP
3751: POP
// InitHc ;
3752: CALL_OW 19
// tmp := bunker_list * [ 50 , 70 , 85 ] [ Difficulty ] div 100 ;
3756: LD_ADDR_VAR 0 8
3760: PUSH
3761: LD_VAR 0 13
3765: PUSH
3766: LD_INT 50
3768: PUSH
3769: LD_INT 70
3771: PUSH
3772: LD_INT 85
3774: PUSH
3775: EMPTY
3776: LIST
3777: LIST
3778: LIST
3779: PUSH
3780: LD_OWVAR 67
3784: ARRAY
3785: MUL
3786: PUSH
3787: LD_INT 100
3789: DIV
3790: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
3791: LD_ADDR_VAR 0 16
3795: PUSH
3796: LD_VAR 0 16
3800: PPUSH
3801: LD_INT 1
3803: PPUSH
3804: LD_VAR 0 8
3808: PPUSH
3809: CALL_OW 1
3813: ST_TO_ADDR
// tmp := [ ] ;
3814: LD_ADDR_VAR 0 8
3818: PUSH
3819: EMPTY
3820: ST_TO_ADDR
// for i in bunker_list do
3821: LD_ADDR_VAR 0 2
3825: PUSH
3826: LD_VAR 0 13
3830: PUSH
3831: FOR_IN
3832: IFFALSE 3928
// if i mod 10 + 1 < tmp then
3834: LD_VAR 0 2
3838: PUSH
3839: LD_INT 10
3841: MOD
3842: PUSH
3843: LD_INT 1
3845: PLUS
3846: PUSH
3847: LD_VAR 0 8
3851: LESS
3852: IFFALSE 3897
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
3854: LD_ADDR_VAR 0 8
3858: PUSH
3859: LD_VAR 0 8
3863: PPUSH
3864: LD_VAR 0 2
3868: PUSH
3869: LD_INT 3
3871: PPUSH
3872: LD_INT 5
3874: PPUSH
3875: CALL_OW 12
3879: MOD
3880: PUSH
3881: LD_INT 1
3883: PLUS
3884: PPUSH
3885: LD_VAR 0 2
3889: PPUSH
3890: CALL_OW 2
3894: ST_TO_ADDR
3895: GO 3926
// tmp := Insert ( tmp , tmp + 1 , i ) ;
3897: LD_ADDR_VAR 0 8
3901: PUSH
3902: LD_VAR 0 8
3906: PPUSH
3907: LD_VAR 0 8
3911: PUSH
3912: LD_INT 1
3914: PLUS
3915: PPUSH
3916: LD_VAR 0 2
3920: PPUSH
3921: CALL_OW 2
3925: ST_TO_ADDR
3926: GO 3831
3928: POP
3929: POP
// bunker_list := tmp ;
3930: LD_ADDR_VAR 0 13
3934: PUSH
3935: LD_VAR 0 8
3939: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
3940: LD_ADDR_VAR 0 2
3944: PUSH
3945: LD_VAR 0 13
3949: PUSH
3950: LD_VAR 0 14
3954: ADD
3955: PUSH
3956: FOR_IN
3957: IFFALSE 4054
// begin tmp := rand ( 0 , 100 ) ;
3959: LD_ADDR_VAR 0 8
3963: PUSH
3964: LD_INT 0
3966: PPUSH
3967: LD_INT 100
3969: PPUSH
3970: CALL_OW 12
3974: ST_TO_ADDR
// r := 0 ;
3975: LD_ADDR_VAR 0 4
3979: PUSH
3980: LD_INT 0
3982: ST_TO_ADDR
// for j in weapons_list do
3983: LD_ADDR_VAR 0 3
3987: PUSH
3988: LD_VAR 0 15
3992: PUSH
3993: FOR_IN
3994: IFFALSE 4050
// begin r := r + j [ 2 ] ;
3996: LD_ADDR_VAR 0 4
4000: PUSH
4001: LD_VAR 0 4
4005: PUSH
4006: LD_VAR 0 3
4010: PUSH
4011: LD_INT 2
4013: ARRAY
4014: PLUS
4015: ST_TO_ADDR
// if r >= tmp then
4016: LD_VAR 0 4
4020: PUSH
4021: LD_VAR 0 8
4025: GREATEREQUAL
4026: IFFALSE 4048
// begin PlaceWeaponTurret ( i , j [ 1 ] ) ;
4028: LD_VAR 0 2
4032: PPUSH
4033: LD_VAR 0 3
4037: PUSH
4038: LD_INT 1
4040: ARRAY
4041: PPUSH
4042: CALL_OW 431
// break ;
4046: GO 4050
// end ; end ;
4048: GO 3993
4050: POP
4051: POP
// end ;
4052: GO 3956
4054: POP
4055: POP
// while ( personel_counter [ 1 ] ) do
4056: LD_VAR 0 16
4060: PUSH
4061: LD_INT 1
4063: ARRAY
4064: IFFALSE 4172
// begin i := rand ( 1 , bunker_list ) ;
4066: LD_ADDR_VAR 0 2
4070: PUSH
4071: LD_INT 1
4073: PPUSH
4074: LD_VAR 0 13
4078: PPUSH
4079: CALL_OW 12
4083: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4084: LD_INT 0
4086: PPUSH
4087: LD_INT 1
4089: PPUSH
4090: LD_VAR 0 6
4094: PPUSH
4095: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
4099: CALL_OW 44
4103: PPUSH
4104: LD_VAR 0 13
4108: PUSH
4109: LD_VAR 0 2
4113: ARRAY
4114: PPUSH
4115: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
4119: LD_ADDR_VAR 0 13
4123: PUSH
4124: LD_VAR 0 13
4128: PPUSH
4129: LD_VAR 0 2
4133: PPUSH
4134: CALL_OW 3
4138: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
4139: LD_ADDR_VAR 0 16
4143: PUSH
4144: LD_VAR 0 16
4148: PPUSH
4149: LD_INT 1
4151: PPUSH
4152: LD_VAR 0 16
4156: PUSH
4157: LD_INT 1
4159: ARRAY
4160: PUSH
4161: LD_INT 1
4163: MINUS
4164: PPUSH
4165: CALL_OW 1
4169: ST_TO_ADDR
// end ;
4170: GO 4056
// for i = 1 to personel_counter [ 2 ] do
4172: LD_ADDR_VAR 0 2
4176: PUSH
4177: DOUBLE
4178: LD_INT 1
4180: DEC
4181: ST_TO_ADDR
4182: LD_VAR 0 16
4186: PUSH
4187: LD_INT 2
4189: ARRAY
4190: PUSH
4191: FOR_TO
4192: IFFALSE 4223
// begin PrepareHuman ( false , 2 , skill ) ;
4194: LD_INT 0
4196: PPUSH
4197: LD_INT 2
4199: PPUSH
4200: LD_VAR 0 6
4204: PPUSH
4205: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
4209: CALL_OW 44
4213: PPUSH
4214: LD_INT 16
4216: PPUSH
4217: CALL_OW 52
// end ;
4221: GO 4191
4223: POP
4224: POP
// for i = 1 to personel_counter [ 3 ] do
4225: LD_ADDR_VAR 0 2
4229: PUSH
4230: DOUBLE
4231: LD_INT 1
4233: DEC
4234: ST_TO_ADDR
4235: LD_VAR 0 16
4239: PUSH
4240: LD_INT 3
4242: ARRAY
4243: PUSH
4244: FOR_TO
4245: IFFALSE 4282
// begin PrepareHuman ( false , 3 , skill ) ;
4247: LD_INT 0
4249: PPUSH
4250: LD_INT 3
4252: PPUSH
4253: LD_VAR 0 6
4257: PPUSH
4258: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ 1 ] ) ;
4262: CALL_OW 44
4266: PPUSH
4267: LD_VAR 0 11
4271: PUSH
4272: LD_INT 1
4274: ARRAY
4275: PPUSH
4276: CALL_OW 52
// end ;
4280: GO 4244
4282: POP
4283: POP
// for i = 1 to personel_counter [ 4 ] do
4284: LD_ADDR_VAR 0 2
4288: PUSH
4289: DOUBLE
4290: LD_INT 1
4292: DEC
4293: ST_TO_ADDR
4294: LD_VAR 0 16
4298: PUSH
4299: LD_INT 4
4301: ARRAY
4302: PUSH
4303: FOR_TO
4304: IFFALSE 4341
// begin PrepareHuman ( false , 4 , skill ) ;
4306: LD_INT 0
4308: PPUSH
4309: LD_INT 4
4311: PPUSH
4312: LD_VAR 0 6
4316: PPUSH
4317: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
4321: CALL_OW 44
4325: PPUSH
4326: LD_VAR 0 10
4330: PUSH
4331: LD_INT 1
4333: ARRAY
4334: PPUSH
4335: CALL_OW 52
// end ;
4339: GO 4303
4341: POP
4342: POP
// for i in breastworks_list do
4343: LD_ADDR_VAR 0 2
4347: PUSH
4348: LD_VAR 0 12
4352: PUSH
4353: FOR_IN
4354: IFFALSE 4466
// begin r := GetDir ( i ) ;
4356: LD_ADDR_VAR 0 4
4360: PUSH
4361: LD_VAR 0 2
4365: PPUSH
4366: CALL_OW 254
4370: ST_TO_ADDR
// if r > 3 then
4371: LD_VAR 0 4
4375: PUSH
4376: LD_INT 3
4378: GREATER
4379: IFFALSE 4397
// r := r - 3 else
4381: LD_ADDR_VAR 0 4
4385: PUSH
4386: LD_VAR 0 4
4390: PUSH
4391: LD_INT 3
4393: MINUS
4394: ST_TO_ADDR
4395: GO 4411
// r := r + 3 ;
4397: LD_ADDR_VAR 0 4
4401: PUSH
4402: LD_VAR 0 4
4406: PUSH
4407: LD_INT 3
4409: PLUS
4410: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4411: LD_INT 0
4413: PPUSH
4414: LD_INT 1
4416: PPUSH
4417: LD_VAR 0 6
4421: PPUSH
4422: CALL_OW 380
// un := CreateHuman ;
4426: LD_ADDR_VAR 0 5
4430: PUSH
4431: CALL_OW 44
4435: ST_TO_ADDR
// SetDir ( un , r ) ;
4436: LD_VAR 0 5
4440: PPUSH
4441: LD_VAR 0 4
4445: PPUSH
4446: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
4450: LD_VAR 0 5
4454: PPUSH
4455: LD_VAR 0 2
4459: PPUSH
4460: CALL_OW 52
// end ;
4464: GO 4353
4466: POP
4467: POP
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
4468: LD_ADDR_VAR 0 8
4472: PUSH
4473: LD_INT 22
4475: PUSH
4476: LD_INT 3
4478: PUSH
4479: EMPTY
4480: LIST
4481: LIST
4482: PUSH
4483: LD_INT 25
4485: PUSH
4486: LD_INT 3
4488: PUSH
4489: EMPTY
4490: LIST
4491: LIST
4492: PUSH
4493: EMPTY
4494: LIST
4495: LIST
4496: PPUSH
4497: CALL_OW 69
4501: ST_TO_ADDR
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
4502: LD_ADDR_VAR 0 4
4506: PUSH
4507: LD_INT 4
4509: PUSH
4510: LD_INT 5
4512: PUSH
4513: LD_INT 6
4515: PUSH
4516: EMPTY
4517: LIST
4518: LIST
4519: LIST
4520: PUSH
4521: LD_OWVAR 67
4525: ARRAY
4526: ST_TO_ADDR
// for i = 1 to r do
4527: LD_ADDR_VAR 0 2
4531: PUSH
4532: DOUBLE
4533: LD_INT 1
4535: DEC
4536: ST_TO_ADDR
4537: LD_VAR 0 4
4541: PUSH
4542: FOR_TO
4543: IFFALSE 4687
// begin un := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
4545: LD_ADDR_VAR 0 5
4549: PUSH
4550: LD_INT 3
4552: PPUSH
4553: LD_INT 3
4555: PPUSH
4556: LD_INT 22
4558: PPUSH
4559: LD_INT 1
4561: PPUSH
4562: LD_INT 1
4564: PPUSH
4565: LD_INT 43
4567: PUSH
4568: LD_INT 44
4570: PUSH
4571: LD_INT 42
4573: PUSH
4574: EMPTY
4575: LIST
4576: LIST
4577: LIST
4578: PUSH
4579: LD_VAR 0 2
4583: PUSH
4584: LD_INT 3
4586: MOD
4587: PUSH
4588: LD_INT 1
4590: PLUS
4591: ARRAY
4592: PPUSH
4593: LD_INT 100
4595: PPUSH
4596: CALL 417 0 7
4600: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4601: LD_VAR 0 5
4605: PPUSH
4606: LD_INT 0
4608: PPUSH
4609: LD_INT 5
4611: PPUSH
4612: CALL_OW 12
4616: PPUSH
4617: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
4621: LD_VAR 0 5
4625: PPUSH
4626: LD_INT 5
4628: PPUSH
4629: LD_INT 0
4631: PPUSH
4632: CALL_OW 49
// if i > tmp then
4636: LD_VAR 0 2
4640: PUSH
4641: LD_VAR 0 8
4645: GREATER
4646: IFFALSE 4650
// continue ;
4648: GO 4542
// ComExitBuilding ( tmp [ i ] ) ;
4650: LD_VAR 0 8
4654: PUSH
4655: LD_VAR 0 2
4659: ARRAY
4660: PPUSH
4661: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , un ) ;
4665: LD_VAR 0 8
4669: PUSH
4670: LD_VAR 0 2
4674: ARRAY
4675: PPUSH
4676: LD_VAR 0 5
4680: PPUSH
4681: CALL_OW 180
// end ;
4685: GO 4542
4687: POP
4688: POP
// end ;
4689: LD_VAR 0 1
4693: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_ok ] ] ) do var i , filter , tmp , engs , enemy ;
4694: LD_INT 22
4696: PUSH
4697: LD_INT 3
4699: PUSH
4700: EMPTY
4701: LIST
4702: LIST
4703: PUSH
4704: LD_INT 25
4706: PUSH
4707: LD_INT 2
4709: PUSH
4710: EMPTY
4711: LIST
4712: LIST
4713: PUSH
4714: LD_INT 50
4716: PUSH
4717: EMPTY
4718: LIST
4719: PUSH
4720: EMPTY
4721: LIST
4722: LIST
4723: LIST
4724: PPUSH
4725: CALL_OW 69
4729: IFFALSE 5425
4731: GO 4733
4733: DISABLE
4734: LD_INT 0
4736: PPUSH
4737: PPUSH
4738: PPUSH
4739: PPUSH
4740: PPUSH
// begin enable ;
4741: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
4742: LD_ADDR_VAR 0 2
4746: PUSH
4747: LD_INT 6
4749: PPUSH
4750: LD_INT 3
4752: PUSH
4753: LD_INT 24
4755: PUSH
4756: LD_INT 1000
4758: PUSH
4759: EMPTY
4760: LIST
4761: LIST
4762: PUSH
4763: EMPTY
4764: LIST
4765: LIST
4766: PUSH
4767: LD_INT 21
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: EMPTY
4774: LIST
4775: LIST
4776: PUSH
4777: EMPTY
4778: LIST
4779: LIST
4780: PPUSH
4781: CALL_OW 70
4785: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_lives , 650 ] ] ) ;
4786: LD_ADDR_VAR 0 4
4790: PUSH
4791: LD_INT 22
4793: PUSH
4794: LD_INT 3
4796: PUSH
4797: EMPTY
4798: LIST
4799: LIST
4800: PUSH
4801: LD_INT 25
4803: PUSH
4804: LD_INT 2
4806: PUSH
4807: EMPTY
4808: LIST
4809: LIST
4810: PUSH
4811: LD_INT 24
4813: PUSH
4814: LD_INT 650
4816: PUSH
4817: EMPTY
4818: LIST
4819: LIST
4820: PUSH
4821: EMPTY
4822: LIST
4823: LIST
4824: LIST
4825: PPUSH
4826: CALL_OW 69
4830: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
4831: LD_VAR 0 2
4835: NOT
4836: PUSH
4837: LD_EXP 19
4841: NOT
4842: AND
4843: IFFALSE 4875
// begin if not IsInUnit ( engs [ 1 ] ) then
4845: LD_VAR 0 4
4849: PUSH
4850: LD_INT 1
4852: ARRAY
4853: PPUSH
4854: CALL_OW 310
4858: NOT
4859: IFFALSE 4873
// ComEnterUnit ( engs , ru_dep_main ) ;
4861: LD_VAR 0 4
4865: PPUSH
4866: LD_INT 16
4868: PPUSH
4869: CALL_OW 120
// exit ;
4873: GO 5425
// end ; if debug then
4875: LD_EXP 1
4879: IFFALSE 4900
// display_strings := [ engs , filter ] ;
4881: LD_ADDR_OWVAR 47
4885: PUSH
4886: LD_VAR 0 4
4890: PUSH
4891: LD_VAR 0 2
4895: PUSH
4896: EMPTY
4897: LIST
4898: LIST
4899: ST_TO_ADDR
// if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
4900: LD_VAR 0 4
4904: PPUSH
4905: LD_INT 3
4907: PUSH
4908: LD_INT 24
4910: PUSH
4911: LD_INT 650
4913: PUSH
4914: EMPTY
4915: LIST
4916: LIST
4917: PUSH
4918: EMPTY
4919: LIST
4920: LIST
4921: PPUSH
4922: CALL_OW 72
4926: IFFALSE 5019
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
4928: LD_ADDR_VAR 0 3
4932: PUSH
4933: LD_VAR 0 4
4937: PPUSH
4938: LD_INT 3
4940: PUSH
4941: LD_INT 24
4943: PUSH
4944: LD_INT 650
4946: PUSH
4947: EMPTY
4948: LIST
4949: LIST
4950: PUSH
4951: EMPTY
4952: LIST
4953: LIST
4954: PPUSH
4955: CALL_OW 72
4959: ST_TO_ADDR
// for i in tmp do
4960: LD_ADDR_VAR 0 1
4964: PUSH
4965: LD_VAR 0 3
4969: PUSH
4970: FOR_IN
4971: IFFALSE 5017
// if not IsInArea ( i , mainBaseArea ) then
4973: LD_VAR 0 1
4977: PPUSH
4978: LD_INT 14
4980: PPUSH
4981: CALL_OW 308
4985: NOT
4986: IFFALSE 5015
// begin ComMoveXY ( i , 129 , 125 ) ;
4988: LD_VAR 0 1
4992: PPUSH
4993: LD_INT 129
4995: PPUSH
4996: LD_INT 125
4998: PPUSH
4999: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
5003: LD_VAR 0 1
5007: PPUSH
5008: LD_INT 1050
5010: PPUSH
5011: CALL_OW 202
// end ;
5015: GO 4970
5017: POP
5018: POP
// end ; if filter then
5019: LD_VAR 0 2
5023: IFFALSE 5282
// begin for i in engs do
5025: LD_ADDR_VAR 0 1
5029: PUSH
5030: LD_VAR 0 4
5034: PUSH
5035: FOR_IN
5036: IFFALSE 5060
// if IsInUnit ( i ) then
5038: LD_VAR 0 1
5042: PPUSH
5043: CALL_OW 310
5047: IFFALSE 5058
// ComExitBuilding ( i ) ;
5049: LD_VAR 0 1
5053: PPUSH
5054: CALL_OW 122
5058: GO 5035
5060: POP
5061: POP
// wait ( 3 ) ;
5062: LD_INT 3
5064: PPUSH
5065: CALL_OW 67
// if filter >= 2 and engs >= 2 then
5069: LD_VAR 0 2
5073: PUSH
5074: LD_INT 2
5076: GREATEREQUAL
5077: PUSH
5078: LD_VAR 0 4
5082: PUSH
5083: LD_INT 2
5085: GREATEREQUAL
5086: AND
5087: IFFALSE 5235
// begin for i = 1 to engs / 2 do
5089: LD_ADDR_VAR 0 1
5093: PUSH
5094: DOUBLE
5095: LD_INT 1
5097: DEC
5098: ST_TO_ADDR
5099: LD_VAR 0 4
5103: PUSH
5104: LD_INT 2
5106: DIVREAL
5107: PUSH
5108: FOR_TO
5109: IFFALSE 5155
// if not HasTask ( engs [ i ] ) then
5111: LD_VAR 0 4
5115: PUSH
5116: LD_VAR 0 1
5120: ARRAY
5121: PPUSH
5122: CALL_OW 314
5126: NOT
5127: IFFALSE 5153
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
5129: LD_VAR 0 4
5133: PUSH
5134: LD_VAR 0 1
5138: ARRAY
5139: PPUSH
5140: LD_VAR 0 2
5144: PUSH
5145: LD_INT 1
5147: ARRAY
5148: PPUSH
5149: CALL_OW 130
5153: GO 5108
5155: POP
5156: POP
// for i = engs / 2 + 1 to engs do
5157: LD_ADDR_VAR 0 1
5161: PUSH
5162: DOUBLE
5163: LD_VAR 0 4
5167: PUSH
5168: LD_INT 2
5170: DIVREAL
5171: PUSH
5172: LD_INT 1
5174: PLUS
5175: DEC
5176: ST_TO_ADDR
5177: LD_VAR 0 4
5181: PUSH
5182: FOR_TO
5183: IFFALSE 5231
// if not HasTask ( engs [ i ] ) then
5185: LD_VAR 0 4
5189: PUSH
5190: LD_VAR 0 1
5194: ARRAY
5195: PPUSH
5196: CALL_OW 314
5200: NOT
5201: IFFALSE 5229
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
5203: LD_VAR 0 4
5207: PUSH
5208: LD_VAR 0 1
5212: ARRAY
5213: PPUSH
5214: LD_VAR 0 2
5218: PUSH
5219: LD_VAR 0 2
5223: ARRAY
5224: PPUSH
5225: CALL_OW 130
5229: GO 5182
5231: POP
5232: POP
// end else
5233: GO 5282
// for i in engs do
5235: LD_ADDR_VAR 0 1
5239: PUSH
5240: LD_VAR 0 4
5244: PUSH
5245: FOR_IN
5246: IFFALSE 5280
// if not HasTask ( i ) then
5248: LD_VAR 0 1
5252: PPUSH
5253: CALL_OW 314
5257: NOT
5258: IFFALSE 5278
// ComRepairBuilding ( i , filter [ 1 ] ) ;
5260: LD_VAR 0 1
5264: PPUSH
5265: LD_VAR 0 2
5269: PUSH
5270: LD_INT 1
5272: ARRAY
5273: PPUSH
5274: CALL_OW 130
5278: GO 5245
5280: POP
5281: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
5282: LD_ADDR_VAR 0 5
5286: PUSH
5287: LD_INT 81
5289: PUSH
5290: LD_INT 3
5292: PUSH
5293: EMPTY
5294: LIST
5295: LIST
5296: PPUSH
5297: CALL_OW 69
5301: ST_TO_ADDR
// if ru_rebuild_list and not filter then
5302: LD_EXP 19
5306: PUSH
5307: LD_VAR 0 2
5311: NOT
5312: AND
5313: IFFALSE 5425
// begin ComExitBuilding ( engs ) ;
5315: LD_VAR 0 4
5319: PPUSH
5320: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
5324: LD_VAR 0 5
5328: PPUSH
5329: LD_EXP 19
5333: PUSH
5334: LD_INT 2
5336: ARRAY
5337: PPUSH
5338: LD_EXP 19
5342: PUSH
5343: LD_INT 3
5345: ARRAY
5346: PPUSH
5347: CALL_OW 73
5351: PPUSH
5352: LD_EXP 19
5356: PUSH
5357: LD_INT 2
5359: ARRAY
5360: PPUSH
5361: LD_EXP 19
5365: PUSH
5366: LD_INT 3
5368: ARRAY
5369: PPUSH
5370: CALL_OW 297
5374: PUSH
5375: LD_INT 10
5377: GREATER
5378: IFFALSE 5425
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
5380: LD_VAR 0 4
5384: PPUSH
5385: LD_EXP 19
5389: PUSH
5390: LD_INT 1
5392: ARRAY
5393: PPUSH
5394: LD_EXP 19
5398: PUSH
5399: LD_INT 2
5401: ARRAY
5402: PPUSH
5403: LD_EXP 19
5407: PUSH
5408: LD_INT 3
5410: ARRAY
5411: PPUSH
5412: LD_EXP 19
5416: PUSH
5417: LD_INT 4
5419: ARRAY
5420: PPUSH
5421: CALL_OW 145
// end ; end ;
5425: PPOPN 5
5427: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 650 do var tmp ;
5428: LD_INT 16
5430: PPUSH
5431: CALL_OW 256
5435: PUSH
5436: LD_INT 650
5438: LESS
5439: IFFALSE 5522
5441: GO 5443
5443: DISABLE
5444: LD_INT 0
5446: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
5447: LD_ADDR_VAR 0 1
5451: PUSH
5452: LD_INT 22
5454: PUSH
5455: LD_INT 3
5457: PUSH
5458: EMPTY
5459: LIST
5460: LIST
5461: PUSH
5462: LD_INT 25
5464: PUSH
5465: LD_INT 1
5467: PUSH
5468: EMPTY
5469: LIST
5470: LIST
5471: PUSH
5472: EMPTY
5473: LIST
5474: LIST
5475: PPUSH
5476: CALL_OW 69
5480: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
5481: LD_VAR 0 1
5485: PPUSH
5486: CALL_OW 122
// wait ( 3 ) ;
5490: LD_INT 3
5492: PPUSH
5493: CALL_OW 67
// ComAgressiveMove ( tmp , GetX ( ru_dep_main ) , GetY ( ru_dep_main ) ) ;
5497: LD_VAR 0 1
5501: PPUSH
5502: LD_INT 16
5504: PPUSH
5505: CALL_OW 250
5509: PPUSH
5510: LD_INT 16
5512: PPUSH
5513: CALL_OW 251
5517: PPUSH
5518: CALL_OW 114
// end ;
5522: PPOPN 1
5524: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
5525: LD_INT 22
5527: PUSH
5528: LD_INT 3
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: PUSH
5535: LD_INT 25
5537: PUSH
5538: LD_INT 4
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: PUSH
5545: EMPTY
5546: LIST
5547: LIST
5548: PPUSH
5549: CALL_OW 69
5553: IFFALSE 5807
5555: GO 5557
5557: DISABLE
5558: LD_INT 0
5560: PPUSH
5561: PPUSH
5562: PPUSH
// begin enable ;
5563: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5564: LD_ADDR_VAR 0 2
5568: PUSH
5569: LD_INT 14
5571: PPUSH
5572: LD_INT 22
5574: PUSH
5575: LD_INT 3
5577: PUSH
5578: EMPTY
5579: LIST
5580: LIST
5581: PUSH
5582: LD_INT 21
5584: PUSH
5585: LD_INT 1
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: PUSH
5592: LD_INT 3
5594: PUSH
5595: LD_INT 24
5597: PUSH
5598: LD_INT 1000
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PUSH
5609: EMPTY
5610: LIST
5611: LIST
5612: LIST
5613: PPUSH
5614: CALL_OW 70
5618: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
5619: LD_ADDR_VAR 0 3
5623: PUSH
5624: LD_INT 22
5626: PUSH
5627: LD_INT 3
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: PUSH
5634: LD_INT 25
5636: PUSH
5637: LD_INT 4
5639: PUSH
5640: EMPTY
5641: LIST
5642: LIST
5643: PUSH
5644: EMPTY
5645: LIST
5646: LIST
5647: PPUSH
5648: CALL_OW 69
5652: ST_TO_ADDR
// if not doc then
5653: LD_VAR 0 3
5657: NOT
5658: IFFALSE 5662
// exit ;
5660: GO 5807
// if not tmp then
5662: LD_VAR 0 2
5666: NOT
5667: IFFALSE 5758
// begin if not IsInUnit ( doc [ 1 ] ) then
5669: LD_VAR 0 3
5673: PUSH
5674: LD_INT 1
5676: ARRAY
5677: PPUSH
5678: CALL_OW 310
5682: NOT
5683: IFFALSE 5756
// ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
5685: LD_VAR 0 3
5689: PPUSH
5690: LD_INT 22
5692: PUSH
5693: LD_INT 3
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: PUSH
5700: LD_INT 2
5702: PUSH
5703: LD_INT 30
5705: PUSH
5706: LD_INT 6
5708: PUSH
5709: EMPTY
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 30
5715: PUSH
5716: LD_INT 7
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: PUSH
5723: LD_INT 30
5725: PUSH
5726: LD_INT 8
5728: PUSH
5729: EMPTY
5730: LIST
5731: LIST
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: LIST
5737: LIST
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: PPUSH
5743: CALL_OW 69
5747: PUSH
5748: LD_INT 1
5750: ARRAY
5751: PPUSH
5752: CALL_OW 120
// exit ;
5756: GO 5807
// end ; if IsInUnit ( doc [ 1 ] ) then
5758: LD_VAR 0 3
5762: PUSH
5763: LD_INT 1
5765: ARRAY
5766: PPUSH
5767: CALL_OW 310
5771: IFFALSE 5782
// ComExitBuilding ( doc ) ;
5773: LD_VAR 0 3
5777: PPUSH
5778: CALL_OW 122
// wait ( 3 ) ;
5782: LD_INT 3
5784: PPUSH
5785: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
5789: LD_VAR 0 3
5793: PPUSH
5794: LD_VAR 0 2
5798: PUSH
5799: LD_INT 1
5801: ARRAY
5802: PPUSH
5803: CALL_OW 128
// end ;
5807: PPOPN 3
5809: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , tmp , areas , area ;
5810: LD_INT 22
5812: PUSH
5813: LD_INT 3
5815: PUSH
5816: EMPTY
5817: LIST
5818: LIST
5819: PUSH
5820: LD_INT 25
5822: PUSH
5823: LD_INT 3
5825: PUSH
5826: EMPTY
5827: LIST
5828: LIST
5829: PUSH
5830: EMPTY
5831: LIST
5832: LIST
5833: PPUSH
5834: CALL_OW 69
5838: PUSH
5839: LD_INT 22
5841: PUSH
5842: LD_INT 3
5844: PUSH
5845: EMPTY
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 21
5851: PUSH
5852: LD_INT 2
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: PPUSH
5863: CALL_OW 69
5867: AND
5868: IFFALSE 6090
5870: GO 5872
5872: DISABLE
5873: LD_INT 0
5875: PPUSH
5876: PPUSH
5877: PPUSH
5878: PPUSH
// begin enable ;
5879: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
5880: LD_ADDR_VAR 0 2
5884: PUSH
5885: LD_INT 22
5887: PUSH
5888: LD_INT 3
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: LD_INT 21
5897: PUSH
5898: LD_INT 2
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 3
5907: PUSH
5908: LD_INT 58
5910: PUSH
5911: EMPTY
5912: LIST
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: PUSH
5918: EMPTY
5919: LIST
5920: LIST
5921: LIST
5922: PPUSH
5923: CALL_OW 69
5927: ST_TO_ADDR
// areas := [ sectorAlpha , sectorBeta , sectorDelta , mainBaseArea ] ;
5928: LD_ADDR_VAR 0 3
5932: PUSH
5933: LD_INT 10
5935: PUSH
5936: LD_INT 11
5938: PUSH
5939: LD_INT 12
5941: PUSH
5942: LD_INT 14
5944: PUSH
5945: EMPTY
5946: LIST
5947: LIST
5948: LIST
5949: LIST
5950: ST_TO_ADDR
// area := 0 ;
5951: LD_ADDR_VAR 0 4
5955: PUSH
5956: LD_INT 0
5958: ST_TO_ADDR
// for i in areas do
5959: LD_ADDR_VAR 0 1
5963: PUSH
5964: LD_VAR 0 3
5968: PUSH
5969: FOR_IN
5970: IFFALSE 6007
// if FilterUnitsInArea ( i , [ f_side , 1 ] ) then
5972: LD_VAR 0 1
5976: PPUSH
5977: LD_INT 22
5979: PUSH
5980: LD_INT 1
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: PPUSH
5987: CALL_OW 70
5991: IFFALSE 6005
// begin area := i ;
5993: LD_ADDR_VAR 0 4
5997: PUSH
5998: LD_VAR 0 1
6002: ST_TO_ADDR
// break ;
6003: GO 6007
// end ;
6005: GO 5969
6007: POP
6008: POP
// if area then
6009: LD_VAR 0 4
6013: IFFALSE 6090
// begin for i in tmp do
6015: LD_ADDR_VAR 0 1
6019: PUSH
6020: LD_VAR 0 2
6024: PUSH
6025: FOR_IN
6026: IFFALSE 6088
// begin if GetFuel ( i ) < 33 then
6028: LD_VAR 0 1
6032: PPUSH
6033: CALL_OW 261
6037: PUSH
6038: LD_INT 33
6040: LESS
6041: IFFALSE 6055
// SetFuel ( i , 33 ) ;
6043: LD_VAR 0 1
6047: PPUSH
6048: LD_INT 33
6050: PPUSH
6051: CALL_OW 240
// if not IsInArea ( i , area ) then
6055: LD_VAR 0 1
6059: PPUSH
6060: LD_VAR 0 4
6064: PPUSH
6065: CALL_OW 308
6069: NOT
6070: IFFALSE 6086
// ComMoveToArea ( i , area ) ;
6072: LD_VAR 0 1
6076: PPUSH
6077: LD_VAR 0 4
6081: PPUSH
6082: CALL_OW 113
// end ;
6086: GO 6025
6088: POP
6089: POP
// end ; end ;
6090: PPOPN 4
6092: END
// every 10 10$00 do var i , j , un , veh , time , count ;
6093: GO 6095
6095: DISABLE
6096: LD_INT 0
6098: PPUSH
6099: PPUSH
6100: PPUSH
6101: PPUSH
6102: PPUSH
6103: PPUSH
// begin uc_side := 3 ;
6104: LD_ADDR_OWVAR 20
6108: PUSH
6109: LD_INT 3
6111: ST_TO_ADDR
// uc_nation := 3 ;
6112: LD_ADDR_OWVAR 21
6116: PUSH
6117: LD_INT 3
6119: ST_TO_ADDR
// time := [ 6 6$00 , 5 5$00 , 4 4$00 ] [ Difficulty ] ;
6120: LD_ADDR_VAR 0 5
6124: PUSH
6125: LD_INT 12600
6127: PUSH
6128: LD_INT 10500
6130: PUSH
6131: LD_INT 8400
6133: PUSH
6134: EMPTY
6135: LIST
6136: LIST
6137: LIST
6138: PUSH
6139: LD_OWVAR 67
6143: ARRAY
6144: ST_TO_ADDR
// count := [ 3 , 4 , 5 ] [ Difficulty ] ;
6145: LD_ADDR_VAR 0 6
6149: PUSH
6150: LD_INT 3
6152: PUSH
6153: LD_INT 4
6155: PUSH
6156: LD_INT 5
6158: PUSH
6159: EMPTY
6160: LIST
6161: LIST
6162: LIST
6163: PUSH
6164: LD_OWVAR 67
6168: ARRAY
6169: ST_TO_ADDR
// for i = 1 to count do
6170: LD_ADDR_VAR 0 1
6174: PUSH
6175: DOUBLE
6176: LD_INT 1
6178: DEC
6179: ST_TO_ADDR
6180: LD_VAR 0 6
6184: PUSH
6185: FOR_TO
6186: IFFALSE 6481
// begin wait ( time ) ;
6188: LD_VAR 0 5
6192: PPUSH
6193: CALL_OW 67
// for j = 1 to rand ( 1 , Difficulty ) do
6197: LD_ADDR_VAR 0 2
6201: PUSH
6202: DOUBLE
6203: LD_INT 1
6205: DEC
6206: ST_TO_ADDR
6207: LD_INT 1
6209: PPUSH
6210: LD_OWVAR 67
6214: PPUSH
6215: CALL_OW 12
6219: PUSH
6220: FOR_TO
6221: IFFALSE 6362
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 80 ) ;
6223: LD_ADDR_VAR 0 4
6227: PUSH
6228: LD_INT 3
6230: PPUSH
6231: LD_INT 3
6233: PPUSH
6234: LD_INT 22
6236: PPUSH
6237: LD_INT 1
6239: PPUSH
6240: LD_INT 1
6242: PPUSH
6243: LD_INT 43
6245: PUSH
6246: LD_INT 44
6248: PUSH
6249: LD_INT 42
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: LIST
6256: PUSH
6257: LD_VAR 0 1
6261: PUSH
6262: LD_INT 3
6264: MOD
6265: PUSH
6266: LD_INT 1
6268: PLUS
6269: ARRAY
6270: PPUSH
6271: LD_INT 80
6273: PPUSH
6274: CALL 417 0 7
6278: ST_TO_ADDR
// PlaceUnitArea ( veh , southArea , false ) ;
6279: LD_VAR 0 4
6283: PPUSH
6284: LD_INT 13
6286: PPUSH
6287: LD_INT 0
6289: PPUSH
6290: CALL_OW 49
// PrepareHuman ( false , 3 , [ 4 , 5 , 5 ] [ Difficulty ] ) ;
6294: LD_INT 0
6296: PPUSH
6297: LD_INT 3
6299: PPUSH
6300: LD_INT 4
6302: PUSH
6303: LD_INT 5
6305: PUSH
6306: LD_INT 5
6308: PUSH
6309: EMPTY
6310: LIST
6311: LIST
6312: LIST
6313: PUSH
6314: LD_OWVAR 67
6318: ARRAY
6319: PPUSH
6320: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6324: CALL_OW 44
6328: PPUSH
6329: LD_VAR 0 4
6333: PPUSH
6334: CALL_OW 52
// wait ( 0 0$01 ) ;
6338: LD_INT 35
6340: PPUSH
6341: CALL_OW 67
// ComMoveXY ( veh , 143 , 143 ) ;
6345: LD_VAR 0 4
6349: PPUSH
6350: LD_INT 143
6352: PPUSH
6353: LD_INT 143
6355: PPUSH
6356: CALL_OW 111
// end ;
6360: GO 6220
6362: POP
6363: POP
// if count < 3 then
6364: LD_VAR 0 6
6368: PUSH
6369: LD_INT 3
6371: LESS
6372: IFFALSE 6376
// continue ;
6374: GO 6185
// for j = 1 to 1 + Difficulty do
6376: LD_ADDR_VAR 0 2
6380: PUSH
6381: DOUBLE
6382: LD_INT 1
6384: DEC
6385: ST_TO_ADDR
6386: LD_INT 1
6388: PUSH
6389: LD_OWVAR 67
6393: PLUS
6394: PUSH
6395: FOR_TO
6396: IFFALSE 6477
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
6398: LD_INT 0
6400: PPUSH
6401: LD_INT 1
6403: PPUSH
6404: LD_INT 4
6406: PUSH
6407: LD_INT 5
6409: PUSH
6410: LD_INT 6
6412: PUSH
6413: EMPTY
6414: LIST
6415: LIST
6416: LIST
6417: PUSH
6418: LD_OWVAR 67
6422: ARRAY
6423: PPUSH
6424: CALL_OW 380
// un := CreateHuman ;
6428: LD_ADDR_VAR 0 3
6432: PUSH
6433: CALL_OW 44
6437: ST_TO_ADDR
// PlaceUnitArea ( un , southArea , false ) ;
6438: LD_VAR 0 3
6442: PPUSH
6443: LD_INT 13
6445: PPUSH
6446: LD_INT 0
6448: PPUSH
6449: CALL_OW 49
// ComMoveXY ( un , 143 , 143 ) ;
6453: LD_VAR 0 3
6457: PPUSH
6458: LD_INT 143
6460: PPUSH
6461: LD_INT 143
6463: PPUSH
6464: CALL_OW 111
// wait ( 0 0$01 ) ;
6468: LD_INT 35
6470: PPUSH
6471: CALL_OW 67
// end ;
6475: GO 6395
6477: POP
6478: POP
// end ;
6479: GO 6185
6481: POP
6482: POP
// end ;
6483: PPOPN 6
6485: END
// every 4 4$00 do var i , un , time ;
6486: GO 6488
6488: DISABLE
6489: LD_INT 0
6491: PPUSH
6492: PPUSH
6493: PPUSH
// begin time := [ 2 2$00 , 1 1$00 , 0 0$30 ] ;
6494: LD_ADDR_VAR 0 3
6498: PUSH
6499: LD_INT 4200
6501: PUSH
6502: LD_INT 2100
6504: PUSH
6505: LD_INT 1050
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: LIST
6512: ST_TO_ADDR
// wait ( time ) ;
6513: LD_VAR 0 3
6517: PPUSH
6518: CALL_OW 67
// uc_side := 3 ;
6522: LD_ADDR_OWVAR 20
6526: PUSH
6527: LD_INT 3
6529: ST_TO_ADDR
// uc_nation := 3 ;
6530: LD_ADDR_OWVAR 21
6534: PUSH
6535: LD_INT 3
6537: ST_TO_ADDR
// for i = 1 to 2 do
6538: LD_ADDR_VAR 0 1
6542: PUSH
6543: DOUBLE
6544: LD_INT 1
6546: DEC
6547: ST_TO_ADDR
6548: LD_INT 2
6550: PUSH
6551: FOR_TO
6552: IFFALSE 6615
// begin PrepareHuman ( false , 1 , 4 ) ;
6554: LD_INT 0
6556: PPUSH
6557: LD_INT 1
6559: PPUSH
6560: LD_INT 4
6562: PPUSH
6563: CALL_OW 380
// un := CreateHuman ;
6567: LD_ADDR_VAR 0 2
6571: PUSH
6572: CALL_OW 44
6576: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_dep_main ) ;
6577: LD_VAR 0 2
6581: PPUSH
6582: LD_INT 16
6584: PPUSH
6585: CALL_OW 52
// ComExitBuilding ( un ) ;
6589: LD_VAR 0 2
6593: PPUSH
6594: CALL_OW 122
// AddComAgressiveMove ( un , 41 , 76 ) ;
6598: LD_VAR 0 2
6602: PPUSH
6603: LD_INT 41
6605: PPUSH
6606: LD_INT 76
6608: PPUSH
6609: CALL_OW 174
// end ;
6613: GO 6551
6615: POP
6616: POP
// end ; end_of_file
6617: PPOPN 3
6619: END
// export function Action ; begin
6620: LD_INT 0
6622: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
6623: LD_INT 28
6625: PPUSH
6626: LD_INT 3
6628: PPUSH
6629: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
6633: LD_INT 41
6635: PPUSH
6636: LD_INT 76
6638: PPUSH
6639: LD_INT 1
6641: PPUSH
6642: LD_INT 10
6644: PPUSH
6645: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
6649: LD_INT 41
6651: PPUSH
6652: LD_INT 76
6654: PPUSH
6655: LD_INT 1
6657: PPUSH
6658: CALL_OW 331
// InGameOn ;
6662: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
6666: LD_EXP 18
6670: PPUSH
6671: LD_STRING D2-Har-1
6673: PPUSH
6674: CALL_OW 94
// InGameOff ;
6678: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6682: LD_STRING M1
6684: PPUSH
6685: CALL_OW 337
// end ;
6689: LD_VAR 0 1
6693: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
6694: LD_EXP 4
6698: PUSH
6699: LD_INT 1
6701: GREATER
6702: IFFALSE 6793
6704: GO 6706
6706: DISABLE
6707: LD_INT 0
6709: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
6710: LD_ADDR_VAR 0 1
6714: PUSH
6715: LD_INT 1
6717: PPUSH
6718: CALL 505 0 1
6722: PUSH
6723: LD_INT 1
6725: ARRAY
6726: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
6727: LD_VAR 0 1
6731: PPUSH
6732: LD_STRING D2a-Sol1-1
6734: PPUSH
6735: CALL_OW 88
// if not un then
6739: LD_VAR 0 1
6743: NOT
6744: IFFALSE 6775
// begin un := GetRandom ( sex_female ) [ 1 ] ;
6746: LD_ADDR_VAR 0 1
6750: PUSH
6751: LD_INT 2
6753: PPUSH
6754: CALL 505 0 1
6758: PUSH
6759: LD_INT 1
6761: ARRAY
6762: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
6763: LD_VAR 0 1
6767: PPUSH
6768: LD_STRING D2a-FSol1-1
6770: PPUSH
6771: CALL_OW 88
// end ; if Khatam then
6775: LD_EXP 16
6779: IFFALSE 6793
// Say ( Khatam , D3b-Khat-3 ) ;
6781: LD_EXP 16
6785: PPUSH
6786: LD_STRING D3b-Khat-3
6788: PPUSH
6789: CALL_OW 88
// end ;
6793: PPOPN 1
6795: END
// every 0 0$1 trigger Frank and GetDistUnits ( JMM , Frank ) < 5 and not InBattle ( 1 ) do var i , ape ;
6796: LD_EXP 14
6800: PUSH
6801: LD_EXP 8
6805: PPUSH
6806: LD_EXP 14
6810: PPUSH
6811: CALL_OW 296
6815: PUSH
6816: LD_INT 5
6818: LESS
6819: AND
6820: PUSH
6821: LD_INT 1
6823: PPUSH
6824: CALL_OW 463
6828: NOT
6829: AND
6830: IFFALSE 7417
6832: GO 6834
6834: DISABLE
6835: LD_INT 0
6837: PPUSH
6838: PPUSH
// begin InGameOn ;
6839: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6843: LD_ADDR_VAR 0 2
6847: PUSH
6848: LD_INT 22
6850: PUSH
6851: LD_INT 0
6853: PUSH
6854: EMPTY
6855: LIST
6856: LIST
6857: PUSH
6858: LD_INT 25
6860: PUSH
6861: LD_INT 12
6863: PUSH
6864: EMPTY
6865: LIST
6866: LIST
6867: PUSH
6868: EMPTY
6869: LIST
6870: LIST
6871: PPUSH
6872: CALL_OW 69
6876: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
6877: LD_ADDR_VAR 0 2
6881: PUSH
6882: LD_VAR 0 2
6886: PPUSH
6887: LD_EXP 14
6891: PPUSH
6892: CALL_OW 74
6896: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
6897: LD_ADDR_VAR 0 1
6901: PUSH
6902: LD_INT 22
6904: PUSH
6905: LD_INT 1
6907: PUSH
6908: EMPTY
6909: LIST
6910: LIST
6911: PUSH
6912: LD_INT 21
6914: PUSH
6915: LD_INT 1
6917: PUSH
6918: EMPTY
6919: LIST
6920: LIST
6921: PUSH
6922: LD_INT 91
6924: PUSH
6925: LD_EXP 14
6929: PUSH
6930: LD_INT 20
6932: PUSH
6933: EMPTY
6934: LIST
6935: LIST
6936: LIST
6937: PUSH
6938: EMPTY
6939: LIST
6940: LIST
6941: LIST
6942: PPUSH
6943: CALL_OW 69
6947: PUSH
6948: FOR_IN
6949: IFFALSE 6967
// ComTurnUnit ( i , Frank ) ;
6951: LD_VAR 0 1
6955: PPUSH
6956: LD_EXP 14
6960: PPUSH
6961: CALL_OW 119
6965: GO 6948
6967: POP
6968: POP
// SetSide ( Frank , 1 ) ;
6969: LD_EXP 14
6973: PPUSH
6974: LD_INT 1
6976: PPUSH
6977: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
6981: LD_EXP 8
6985: PPUSH
6986: LD_EXP 14
6990: PPUSH
6991: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
6995: LD_EXP 8
6999: PPUSH
7000: LD_EXP 14
7004: PPUSH
7005: CALL_OW 179
// CenterOnUnits ( Frank ) ;
7009: LD_EXP 14
7013: PPUSH
7014: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
7018: LD_EXP 14
7022: PPUSH
7023: LD_STRING D3a-Frank-1
7025: PPUSH
7026: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
7030: LD_VAR 0 2
7034: PPUSH
7035: LD_INT 42
7037: PPUSH
7038: LD_INT 78
7040: PPUSH
7041: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
7045: LD_VAR 0 2
7049: PPUSH
7050: LD_EXP 14
7054: PPUSH
7055: CALL_OW 179
// if Lisa then
7059: LD_EXP 13
7063: IFFALSE 7077
// Say ( Lisa , D3a-Lisa-1 ) ;
7065: LD_EXP 13
7069: PPUSH
7070: LD_STRING D3a-Lisa-1
7072: PPUSH
7073: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
7077: LD_EXP 8
7081: PPUSH
7082: LD_STRING D3a-JMM-1
7084: PPUSH
7085: CALL_OW 88
// if Cyrus then
7089: LD_EXP 12
7093: IFFALSE 7107
// Say ( Cyrus , D3a-Cyrus-1 ) ;
7095: LD_EXP 12
7099: PPUSH
7100: LD_STRING D3a-Cyrus-1
7102: PPUSH
7103: CALL_OW 88
// if GetRandom ( sex_male ) then
7107: LD_INT 1
7109: PPUSH
7110: CALL 505 0 1
7114: IFFALSE 7135
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
7116: LD_INT 1
7118: PPUSH
7119: CALL 505 0 1
7123: PUSH
7124: LD_INT 1
7126: ARRAY
7127: PPUSH
7128: LD_STRING D3a-Sol1-1
7130: PPUSH
7131: CALL_OW 88
// if GetRandom ( sex_female ) then
7135: LD_INT 2
7137: PPUSH
7138: CALL 505 0 1
7142: IFFALSE 7163
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
7144: LD_INT 2
7146: PPUSH
7147: CALL 505 0 1
7151: PUSH
7152: LD_INT 1
7154: ARRAY
7155: PPUSH
7156: LD_STRING D3a-FSol1-1
7158: PPUSH
7159: CALL_OW 88
// if Gladstone then
7163: LD_EXP 15
7167: IFFALSE 7181
// Say ( Gladstone , D3a-Glad-1 ) ;
7169: LD_EXP 15
7173: PPUSH
7174: LD_STRING D3a-Glad-1
7176: PPUSH
7177: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
7181: LD_VAR 0 2
7185: PPUSH
7186: LD_INT 60
7188: PPUSH
7189: LD_INT 113
7191: PPUSH
7192: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
7196: LD_EXP 14
7200: PPUSH
7201: LD_STRING D3a-Frank-2
7203: PPUSH
7204: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
7208: LD_EXP 14
7212: PPUSH
7213: LD_EXP 8
7217: PPUSH
7218: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
7222: LD_EXP 8
7226: PPUSH
7227: LD_STRING D3a-JMM-2
7229: PPUSH
7230: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
7234: LD_INT 1
7236: PPUSH
7237: LD_INT 4
7239: PPUSH
7240: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
7244: LD_INT 85
7246: PPUSH
7247: LD_INT 134
7249: PPUSH
7250: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
7254: LD_EXP 14
7258: PPUSH
7259: LD_STRING D3a-Frank-3
7261: PPUSH
7262: CALL_OW 88
// Wait ( 0 0$01 ) ;
7266: LD_INT 35
7268: PPUSH
7269: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
7273: LD_INT 166
7275: PPUSH
7276: LD_INT 136
7278: PPUSH
7279: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
7283: LD_EXP 8
7287: PPUSH
7288: LD_STRING D3a-JMM-3
7290: PPUSH
7291: CALL_OW 88
// Wait ( 0 0$01 ) ;
7295: LD_INT 35
7297: PPUSH
7298: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
7302: LD_EXP 14
7306: PPUSH
7307: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
7311: LD_EXP 14
7315: PPUSH
7316: LD_STRING D3a-Frank-4
7318: PPUSH
7319: CALL_OW 88
// if Lisa then
7323: LD_EXP 13
7327: IFFALSE 7341
// Say ( Lisa , D3a-Lisa-4 ) ;
7329: LD_EXP 13
7333: PPUSH
7334: LD_STRING D3a-Lisa-4
7336: PPUSH
7337: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
7341: LD_EXP 8
7345: PPUSH
7346: LD_STRING D3a-JMM-4
7348: PPUSH
7349: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
7353: LD_EXP 14
7357: PPUSH
7358: LD_STRING D3a-Frank-5
7360: PPUSH
7361: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
7365: LD_EXP 8
7369: PPUSH
7370: LD_STRING D3a-JMM-5
7372: PPUSH
7373: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
7377: LD_EXP 14
7381: PPUSH
7382: LD_STRING D3a-Frank-6
7384: PPUSH
7385: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
7389: LD_EXP 8
7393: PPUSH
7394: LD_STRING D3a-JMM-6
7396: PPUSH
7397: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
7401: LD_EXP 14
7405: PPUSH
7406: LD_STRING D3a-Frank-7
7408: PPUSH
7409: CALL_OW 88
// InGameOff ;
7413: CALL_OW 9
// end ;
7417: PPOPN 2
7419: END
// every 0 0$1 trigger Kikuchi and GetDistUnits ( JMM , Kikuchi ) < 5 and not InBattle ( 1 ) do
7420: LD_EXP 17
7424: PUSH
7425: LD_EXP 8
7429: PPUSH
7430: LD_EXP 17
7434: PPUSH
7435: CALL_OW 296
7439: PUSH
7440: LD_INT 5
7442: LESS
7443: AND
7444: PUSH
7445: LD_INT 1
7447: PPUSH
7448: CALL_OW 463
7452: NOT
7453: AND
7454: IFFALSE 7634
7456: GO 7458
7458: DISABLE
// begin InGameOn ;
7459: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
7463: LD_EXP 8
7467: PPUSH
7468: LD_EXP 17
7472: PPUSH
7473: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
7477: LD_EXP 17
7481: PPUSH
7482: LD_EXP 8
7486: PPUSH
7487: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
7491: LD_EXP 17
7495: PPUSH
7496: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
7500: LD_EXP 17
7504: PPUSH
7505: LD_STRING D3b-Yam-1
7507: PPUSH
7508: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
7512: LD_EXP 8
7516: PPUSH
7517: LD_STRING D3b-JMM-1
7519: PPUSH
7520: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
7524: LD_INT 1
7526: PPUSH
7527: LD_INT 4
7529: PPUSH
7530: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
7534: LD_INT 85
7536: PPUSH
7537: LD_INT 134
7539: PPUSH
7540: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
7544: LD_EXP 17
7548: PPUSH
7549: LD_STRING D3b-Yam-2
7551: PPUSH
7552: CALL_OW 88
// Wait ( 0 0$01 ) ;
7556: LD_INT 35
7558: PPUSH
7559: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
7563: LD_EXP 8
7567: PPUSH
7568: LD_STRING D3b-JMM-2
7570: PPUSH
7571: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
7575: LD_INT 166
7577: PPUSH
7578: LD_INT 136
7580: PPUSH
7581: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
7585: LD_EXP 17
7589: PPUSH
7590: LD_STRING D3b-Yam-3
7592: PPUSH
7593: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
7597: LD_EXP 8
7601: PPUSH
7602: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
7606: LD_EXP 8
7610: PPUSH
7611: LD_STRING D3b-JMM-3a
7613: PPUSH
7614: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
7618: LD_EXP 17
7622: PPUSH
7623: LD_INT 1
7625: PPUSH
7626: CALL_OW 235
// InGameOff ;
7630: CALL_OW 9
// end ;
7634: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , i ;
7635: LD_INT 7
7637: PPUSH
7638: LD_INT 22
7640: PUSH
7641: LD_INT 1
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: PUSH
7648: LD_INT 3
7650: PUSH
7651: LD_INT 24
7653: PUSH
7654: LD_INT 1000
7656: PUSH
7657: EMPTY
7658: LIST
7659: LIST
7660: PUSH
7661: EMPTY
7662: LIST
7663: LIST
7664: PUSH
7665: EMPTY
7666: LIST
7667: LIST
7668: PPUSH
7669: CALL_OW 70
7673: IFFALSE 8091
7675: GO 7677
7677: DISABLE
7678: LD_INT 0
7680: PPUSH
7681: PPUSH
7682: PPUSH
// begin un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) [ 1 ] ;
7683: LD_ADDR_VAR 0 1
7687: PUSH
7688: LD_INT 7
7690: PPUSH
7691: LD_INT 22
7693: PUSH
7694: LD_INT 1
7696: PUSH
7697: EMPTY
7698: LIST
7699: LIST
7700: PUSH
7701: LD_INT 3
7703: PUSH
7704: LD_INT 24
7706: PUSH
7707: LD_INT 1000
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: PUSH
7714: EMPTY
7715: LIST
7716: LIST
7717: PUSH
7718: EMPTY
7719: LIST
7720: LIST
7721: PPUSH
7722: CALL_OW 70
7726: PUSH
7727: LD_INT 1
7729: ARRAY
7730: ST_TO_ADDR
// DialogueOn ;
7731: CALL_OW 6
// CenterNowOnUnits ( un ) ;
7735: LD_VAR 0 1
7739: PPUSH
7740: CALL_OW 87
// if Lisa then
7744: LD_EXP 13
7748: IFFALSE 7776
// begin Say ( Lisa , D5-Lisa-1 ) ;
7750: LD_EXP 13
7754: PPUSH
7755: LD_STRING D5-Lisa-1
7757: PPUSH
7758: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
7762: LD_EXP 8
7766: PPUSH
7767: LD_STRING D5-JMM-1a
7769: PPUSH
7770: CALL_OW 88
// end else
7774: GO 7788
// Say ( JMM , D5-JMM-1 ) ;
7776: LD_EXP 8
7780: PPUSH
7781: LD_STRING D5-JMM-1
7783: PPUSH
7784: CALL_OW 88
// DialogueOff ;
7788: CALL_OW 7
// while ( true ) do
7792: LD_INT 1
7794: IFFALSE 7850
// begin wait ( 0 0$01 ) ;
7796: LD_INT 35
7798: PPUSH
7799: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
7803: LD_ADDR_VAR 0 2
7807: PUSH
7808: LD_INT 8
7810: PPUSH
7811: LD_INT 30
7813: PUSH
7814: LD_INT 26
7816: PUSH
7817: EMPTY
7818: LIST
7819: LIST
7820: PUSH
7821: LD_INT 101
7823: PUSH
7824: LD_INT 1
7826: PUSH
7827: EMPTY
7828: LIST
7829: LIST
7830: PUSH
7831: EMPTY
7832: LIST
7833: LIST
7834: PPUSH
7835: CALL_OW 71
7839: ST_TO_ADDR
// if x then
7840: LD_VAR 0 2
7844: IFFALSE 7848
// break ;
7846: GO 7850
// end ;
7848: GO 7792
// CenterOnUnits ( x [ 1 ] ) ;
7850: LD_VAR 0 2
7854: PUSH
7855: LD_INT 1
7857: ARRAY
7858: PPUSH
7859: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
7863: LD_EXP 14
7867: PUSH
7868: LD_EXP 14
7872: PPUSH
7873: CALL_OW 255
7877: PUSH
7878: LD_INT 1
7880: EQUAL
7881: AND
7882: IFFALSE 7898
// Say ( Frank , D5a-Frank-1 ) else
7884: LD_EXP 14
7888: PPUSH
7889: LD_STRING D5a-Frank-1
7891: PPUSH
7892: CALL_OW 88
7896: GO 7952
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
7898: LD_EXP 17
7902: PUSH
7903: LD_EXP 17
7907: PPUSH
7908: CALL_OW 255
7912: PUSH
7913: LD_INT 1
7915: EQUAL
7916: AND
7917: IFFALSE 7933
// Say ( Kikuchi , D5a-Yam-1 ) else
7919: LD_EXP 17
7923: PPUSH
7924: LD_STRING D5a-Yam-1
7926: PPUSH
7927: CALL_OW 88
7931: GO 7952
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
7933: LD_INT 1
7935: PPUSH
7936: CALL 505 0 1
7940: PUSH
7941: LD_INT 1
7943: ARRAY
7944: PPUSH
7945: LD_STRING D5a-Sol1-1
7947: PPUSH
7948: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
7952: LD_EXP 8
7956: PPUSH
7957: LD_STRING D5a-JMM-1
7959: PPUSH
7960: CALL_OW 88
// if Cyrus then
7964: LD_EXP 12
7968: IFFALSE 7982
// Say ( Cyrus , D5a-Cyrus-1 ) ;
7970: LD_EXP 12
7974: PPUSH
7975: LD_STRING D5a-Cyrus-1
7977: PPUSH
7978: CALL_OW 88
// x := false ;
7982: LD_ADDR_VAR 0 2
7986: PUSH
7987: LD_INT 0
7989: ST_TO_ADDR
// while ( true ) do
7990: LD_INT 1
7992: IFFALSE 8079
// begin wait ( 0 0$01 ) ;
7994: LD_INT 35
7996: PPUSH
7997: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
8001: LD_ADDR_VAR 0 3
8005: PUSH
8006: LD_INT 2
8008: PUSH
8009: LD_INT 30
8011: PUSH
8012: LD_INT 0
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: PUSH
8019: LD_INT 30
8021: PUSH
8022: LD_INT 1
8024: PUSH
8025: EMPTY
8026: LIST
8027: LIST
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: LIST
8033: PPUSH
8034: CALL_OW 69
8038: PUSH
8039: LD_INT 1
8041: DIFF
8042: PUSH
8043: FOR_IN
8044: IFFALSE 8067
// if BaseNeedEnergy ( i ) then
8046: LD_VAR 0 3
8050: PPUSH
8051: CALL 1162 0 1
8055: IFFALSE 8065
// x := true ;
8057: LD_ADDR_VAR 0 2
8061: PUSH
8062: LD_INT 1
8064: ST_TO_ADDR
8065: GO 8043
8067: POP
8068: POP
// if x then
8069: LD_VAR 0 2
8073: IFFALSE 8077
// break ;
8075: GO 8079
// end ;
8077: GO 7990
// Say ( JMM , D5b-JMM-1 ) ;
8079: LD_EXP 8
8083: PPUSH
8084: LD_STRING D5b-JMM-1
8086: PPUSH
8087: CALL_OW 88
// end ;
8091: PPOPN 3
8093: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
8094: LD_EXP 5
8098: PUSH
8099: LD_INT 1
8101: ARRAY
8102: PUSH
8103: LD_OWVAR 1
8107: LESS
8108: IFFALSE 8308
8110: GO 8112
8112: DISABLE
// begin if not IsDead ( ru_dep_main ) then
8113: LD_INT 16
8115: PPUSH
8116: CALL_OW 301
8120: NOT
8121: IFFALSE 8144
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
8123: LD_EXP 18
8127: PPUSH
8128: LD_STRING D3b-Har-3
8130: PPUSH
8131: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
8135: LD_STRING M2a
8137: PPUSH
8138: CALL_OW 337
// end else
8142: GO 8163
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
8144: LD_EXP 18
8148: PPUSH
8149: LD_STRING D3b-Har-3a
8151: PPUSH
8152: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
8156: LD_STRING M2
8158: PPUSH
8159: CALL_OW 337
// end ; can_end := true ;
8163: LD_ADDR_EXP 6
8167: PUSH
8168: LD_INT 1
8170: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
8171: LD_INT 9
8173: PPUSH
8174: LD_INT 1
8176: PPUSH
8177: CALL_OW 424
// Wait ( 0 0$02 ) ;
8181: LD_INT 70
8183: PPUSH
8184: CALL_OW 67
// if Lisa then
8188: LD_EXP 13
8192: IFFALSE 8206
// Say ( Lisa , D3b-Lisa ) ;
8194: LD_EXP 13
8198: PPUSH
8199: LD_STRING D3b-Lisa
8201: PPUSH
8202: CALL_OW 88
// if Bobby then
8206: LD_EXP 11
8210: IFFALSE 8224
// Say ( Bobby , D3b-Bobby-3 ) ;
8212: LD_EXP 11
8216: PPUSH
8217: LD_STRING D3b-Bobby-3
8219: PPUSH
8220: CALL_OW 88
// if Cyrus then
8224: LD_EXP 12
8228: IFFALSE 8242
// Say ( Cyrus , D3b-Cyrus-3 ) ;
8230: LD_EXP 12
8234: PPUSH
8235: LD_STRING D3b-Cyrus-3
8237: PPUSH
8238: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
8242: LD_EXP 14
8246: PUSH
8247: LD_EXP 14
8251: PPUSH
8252: CALL_OW 255
8256: PUSH
8257: LD_INT 1
8259: EQUAL
8260: AND
8261: IFFALSE 8275
// Say ( Frank , D3b-Frank-3 ) ;
8263: LD_EXP 14
8267: PPUSH
8268: LD_STRING D3b-Frank-3
8270: PPUSH
8271: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
8275: LD_EXP 17
8279: PUSH
8280: LD_EXP 17
8284: PPUSH
8285: CALL_OW 255
8289: PUSH
8290: LD_INT 1
8292: EQUAL
8293: AND
8294: IFFALSE 8308
// Say ( Kikuchi , D3b-Yam-4 ) ;
8296: LD_EXP 17
8300: PPUSH
8301: LD_STRING D3b-Yam-4
8303: PPUSH
8304: CALL_OW 88
// end ;
8308: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
8309: LD_EXP 5
8313: PUSH
8314: LD_INT 2
8316: ARRAY
8317: PUSH
8318: LD_OWVAR 1
8322: LESS
8323: IFFALSE 8355
8325: GO 8327
8327: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
8328: LD_EXP 18
8332: PPUSH
8333: LD_STRING D4-Har-1
8335: PPUSH
8336: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
8340: LD_STRING M3
8342: PPUSH
8343: CALL_OW 337
// must_end := true ;
8347: LD_ADDR_EXP 7
8351: PUSH
8352: LD_INT 1
8354: ST_TO_ADDR
// end ;
8355: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
8356: LD_EXP 5
8360: PUSH
8361: LD_INT 3
8363: ARRAY
8364: PUSH
8365: LD_OWVAR 1
8369: LESS
8370: IFFALSE 8401
8372: GO 8374
8374: DISABLE
// begin if not IsDead ( ru_dep_main ) then
8375: LD_INT 16
8377: PPUSH
8378: CALL_OW 301
8382: NOT
8383: IFFALSE 8394
// YouLost ( TimeOut1 ) else
8385: LD_STRING TimeOut1
8387: PPUSH
8388: CALL_OW 104
8392: GO 8401
// YouLost ( TimeOut2 ) ;
8394: LD_STRING TimeOut2
8396: PPUSH
8397: CALL_OW 104
// end ;
8401: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , i , tmp ;
8402: LD_EXP 8
8406: PPUSH
8407: LD_INT 9
8409: PPUSH
8410: CALL_OW 308
8414: PUSH
8415: LD_EXP 6
8419: AND
8420: IFFALSE 9405
8422: GO 8424
8424: DISABLE
8425: LD_INT 0
8427: PPUSH
8428: PPUSH
8429: PPUSH
// begin wait_on := false ;
8430: LD_ADDR_VAR 0 1
8434: PUSH
8435: LD_INT 0
8437: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
8438: LD_INT 1
8440: PPUSH
8441: CALL 1239 0 1
8445: PUSH
8446: LD_INT 0
8448: PLUS
8449: PUSH
8450: LD_INT 1
8452: PPUSH
8453: LD_INT 9
8455: PPUSH
8456: CALL 1330 0 2
8460: PUSH
8461: LD_INT 1
8463: PPUSH
8464: LD_INT 9
8466: PPUSH
8467: CALL 1377 0 2
8471: ADD
8472: PUSH
8473: LD_INT 0
8475: PLUS
8476: GREATER
8477: IFFALSE 8526
// case Query ( Q1 ) of 1 :
8479: LD_STRING Q1
8481: PPUSH
8482: CALL_OW 97
8486: PUSH
8487: LD_INT 1
8489: DOUBLE
8490: EQUAL
8491: IFTRUE 8495
8493: GO 8506
8495: POP
// wait_on := true ; 2 :
8496: LD_ADDR_VAR 0 1
8500: PUSH
8501: LD_INT 1
8503: ST_TO_ADDR
8504: GO 8526
8506: LD_INT 2
8508: DOUBLE
8509: EQUAL
8510: IFTRUE 8514
8512: GO 8525
8514: POP
// wait_on := false ; end ;
8515: LD_ADDR_VAR 0 1
8519: PUSH
8520: LD_INT 0
8522: ST_TO_ADDR
8523: GO 8526
8525: POP
// repeat wait ( 0 0$01 ) ;
8526: LD_INT 35
8528: PPUSH
8529: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
8533: LD_VAR 0 1
8537: NOT
8538: PUSH
8539: LD_INT 1
8541: PPUSH
8542: CALL 1239 0 1
8546: PUSH
8547: LD_INT 0
8549: PLUS
8550: PUSH
8551: LD_INT 1
8553: PPUSH
8554: LD_INT 9
8556: PPUSH
8557: CALL 1330 0 2
8561: PUSH
8562: LD_INT 1
8564: PPUSH
8565: LD_INT 9
8567: PPUSH
8568: CALL 1377 0 2
8572: ADD
8573: PUSH
8574: LD_INT 0
8576: PLUS
8577: EQUAL
8578: OR
8579: IFFALSE 8526
// DialogueOn ;
8581: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
8585: LD_EXP 8
8589: PPUSH
8590: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
8594: LD_EXP 8
8598: PPUSH
8599: LD_STRING D6-JMM-1
8601: PPUSH
8602: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
8606: LD_EXP 18
8610: PPUSH
8611: LD_STRING D6-Har-1
8613: PPUSH
8614: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
8618: LD_EXP 8
8622: PPUSH
8623: LD_STRING D6-JMM-2
8625: PPUSH
8626: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
8630: LD_EXP 18
8634: PPUSH
8635: LD_STRING D6-Har-2
8637: PPUSH
8638: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
8642: LD_EXP 8
8646: PPUSH
8647: LD_STRING D6-JMM-3
8649: PPUSH
8650: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
8654: LD_EXP 18
8658: PPUSH
8659: LD_STRING D6-Har-3
8661: PPUSH
8662: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
8666: LD_EXP 8
8670: PPUSH
8671: LD_STRING D6-JMM-4
8673: PPUSH
8674: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
8678: LD_EXP 18
8682: PPUSH
8683: LD_STRING D6-Har-4
8685: PPUSH
8686: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
8690: LD_EXP 8
8694: PPUSH
8695: LD_STRING D6-JMM-5
8697: PPUSH
8698: CALL_OW 88
// DialogueOff ;
8702: CALL_OW 7
// tmp := FilterBuildings ( 3 ) ;
8706: LD_ADDR_VAR 0 3
8710: PUSH
8711: LD_INT 3
8713: PPUSH
8714: CALL 1508 0 1
8718: ST_TO_ADDR
// if tmp >= 35 then
8719: LD_VAR 0 3
8723: PUSH
8724: LD_INT 35
8726: GREATEREQUAL
8727: IFFALSE 8764
// begin AddMedal ( Destroy1 , - 1 ) ;
8729: LD_STRING Destroy1
8731: PPUSH
8732: LD_INT 1
8734: NEG
8735: PPUSH
8736: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
8740: LD_STRING Destroy2
8742: PPUSH
8743: LD_INT 1
8745: NEG
8746: PPUSH
8747: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
8751: LD_STRING Destroy3
8753: PPUSH
8754: LD_INT 1
8756: NEG
8757: PPUSH
8758: CALL_OW 101
// end else
8762: GO 8851
// begin AddMedal ( Destroy1 , 1 ) ;
8764: LD_STRING Destroy1
8766: PPUSH
8767: LD_INT 1
8769: PPUSH
8770: CALL_OW 101
// if tmp >= 25 then
8774: LD_VAR 0 3
8778: PUSH
8779: LD_INT 25
8781: GREATEREQUAL
8782: IFFALSE 8808
// begin AddMedal ( Destroy2 , - 1 ) ;
8784: LD_STRING Destroy2
8786: PPUSH
8787: LD_INT 1
8789: NEG
8790: PPUSH
8791: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
8795: LD_STRING Destroy3
8797: PPUSH
8798: LD_INT 1
8800: NEG
8801: PPUSH
8802: CALL_OW 101
// end else
8806: GO 8851
// begin AddMedal ( Destroy2 , 1 ) ;
8808: LD_STRING Destroy2
8810: PPUSH
8811: LD_INT 1
8813: PPUSH
8814: CALL_OW 101
// if tmp >= 15 then
8818: LD_VAR 0 3
8822: PUSH
8823: LD_INT 15
8825: GREATEREQUAL
8826: IFFALSE 8841
// AddMedal ( Destroy3 , - 1 ) else
8828: LD_STRING Destroy3
8830: PPUSH
8831: LD_INT 1
8833: NEG
8834: PPUSH
8835: CALL_OW 101
8839: GO 8851
// AddMedal ( Destroy3 , 1 ) ;
8841: LD_STRING Destroy3
8843: PPUSH
8844: LD_INT 1
8846: PPUSH
8847: CALL_OW 101
// end ; end ; GiveMedals ( MAIN ) ;
8851: LD_STRING MAIN
8853: PPUSH
8854: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ;
8858: LD_ADDR_VAR 0 3
8862: PUSH
8863: LD_INT 1
8865: PPUSH
8866: LD_INT 9
8868: PPUSH
8869: CALL 1330 0 2
8873: PUSH
8874: LD_INT 1
8876: PPUSH
8877: LD_INT 9
8879: PPUSH
8880: CALL 1377 0 2
8884: ADD
8885: ST_TO_ADDR
// RewardPeople ( tmp ) ;
8886: LD_VAR 0 3
8890: PPUSH
8891: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
8895: LD_EXP 8
8899: PPUSH
8900: LD_EXP 3
8904: PUSH
8905: LD_STRING JMM
8907: STR
8908: PPUSH
8909: CALL_OW 38
// if Brown in tmp then
8913: LD_EXP 9
8917: PUSH
8918: LD_VAR 0 3
8922: IN
8923: IFFALSE 8943
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
8925: LD_EXP 9
8929: PPUSH
8930: LD_EXP 3
8934: PUSH
8935: LD_STRING Brown
8937: STR
8938: PPUSH
8939: CALL_OW 38
// if Donaldson in tmp then
8943: LD_EXP 10
8947: PUSH
8948: LD_VAR 0 3
8952: IN
8953: IFFALSE 8973
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
8955: LD_EXP 10
8959: PPUSH
8960: LD_EXP 3
8964: PUSH
8965: LD_STRING Donaldson
8967: STR
8968: PPUSH
8969: CALL_OW 38
// if Bobby in tmp then
8973: LD_EXP 11
8977: PUSH
8978: LD_VAR 0 3
8982: IN
8983: IFFALSE 9003
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
8985: LD_EXP 11
8989: PPUSH
8990: LD_EXP 3
8994: PUSH
8995: LD_STRING Bobby
8997: STR
8998: PPUSH
8999: CALL_OW 38
// if Cyrus in tmp then
9003: LD_EXP 12
9007: PUSH
9008: LD_VAR 0 3
9012: IN
9013: IFFALSE 9033
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
9015: LD_EXP 12
9019: PPUSH
9020: LD_EXP 3
9024: PUSH
9025: LD_STRING Cyrus
9027: STR
9028: PPUSH
9029: CALL_OW 38
// if Lisa in tmp then
9033: LD_EXP 13
9037: PUSH
9038: LD_VAR 0 3
9042: IN
9043: IFFALSE 9063
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
9045: LD_EXP 13
9049: PPUSH
9050: LD_EXP 3
9054: PUSH
9055: LD_STRING Lisa
9057: STR
9058: PPUSH
9059: CALL_OW 38
// if Frank in tmp then
9063: LD_EXP 14
9067: PUSH
9068: LD_VAR 0 3
9072: IN
9073: IFFALSE 9093
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
9075: LD_EXP 14
9079: PPUSH
9080: LD_EXP 3
9084: PUSH
9085: LD_STRING Frank
9087: STR
9088: PPUSH
9089: CALL_OW 38
// if Gladstone in tmp then
9093: LD_EXP 15
9097: PUSH
9098: LD_VAR 0 3
9102: IN
9103: IFFALSE 9123
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
9105: LD_EXP 15
9109: PPUSH
9110: LD_EXP 3
9114: PUSH
9115: LD_STRING Gladstone
9117: STR
9118: PPUSH
9119: CALL_OW 38
// if Khatam in tmp then
9123: LD_EXP 16
9127: PUSH
9128: LD_VAR 0 3
9132: IN
9133: IFFALSE 9153
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
9135: LD_EXP 16
9139: PPUSH
9140: LD_EXP 3
9144: PUSH
9145: LD_STRING Khatam
9147: STR
9148: PPUSH
9149: CALL_OW 38
// if Kikuchi in tmp then
9153: LD_EXP 17
9157: PUSH
9158: LD_VAR 0 3
9162: IN
9163: IFFALSE 9183
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
9165: LD_EXP 17
9169: PPUSH
9170: LD_EXP 3
9174: PUSH
9175: LD_STRING Kikuchi
9177: STR
9178: PPUSH
9179: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi ] , mission_prefix & others ) ;
9183: LD_VAR 0 3
9187: PUSH
9188: LD_EXP 8
9192: PUSH
9193: LD_EXP 9
9197: PUSH
9198: LD_EXP 10
9202: PUSH
9203: LD_EXP 11
9207: PUSH
9208: LD_EXP 12
9212: PUSH
9213: LD_EXP 13
9217: PUSH
9218: LD_EXP 14
9222: PUSH
9223: LD_EXP 15
9227: PUSH
9228: LD_EXP 17
9232: PUSH
9233: EMPTY
9234: LIST
9235: LIST
9236: LIST
9237: LIST
9238: LIST
9239: LIST
9240: LIST
9241: LIST
9242: LIST
9243: DIFF
9244: PPUSH
9245: LD_EXP 3
9249: PUSH
9250: LD_STRING others
9252: STR
9253: PPUSH
9254: CALL_OW 38
// SaveVariable ( tick , 07_time ) ;
9258: LD_OWVAR 1
9262: PPUSH
9263: LD_STRING 07_time
9265: PPUSH
9266: CALL_OW 39
// tmp := [ ] ;
9270: LD_ADDR_VAR 0 3
9274: PUSH
9275: EMPTY
9276: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ] ) do
9277: LD_ADDR_VAR 0 2
9281: PUSH
9282: LD_INT 22
9284: PUSH
9285: LD_INT 1
9287: PUSH
9288: EMPTY
9289: LIST
9290: LIST
9291: PUSH
9292: LD_INT 23
9294: PUSH
9295: LD_INT 1
9297: PUSH
9298: EMPTY
9299: LIST
9300: LIST
9301: PUSH
9302: LD_INT 21
9304: PUSH
9305: LD_INT 2
9307: PUSH
9308: EMPTY
9309: LIST
9310: LIST
9311: PUSH
9312: EMPTY
9313: LIST
9314: LIST
9315: LIST
9316: PUSH
9317: EMPTY
9318: LIST
9319: PPUSH
9320: CALL_OW 69
9324: PUSH
9325: FOR_IN
9326: IFFALSE 9387
// tmp := tmp ^ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
9328: LD_ADDR_VAR 0 3
9332: PUSH
9333: LD_VAR 0 3
9337: PUSH
9338: LD_VAR 0 2
9342: PPUSH
9343: CALL_OW 265
9347: PUSH
9348: LD_VAR 0 2
9352: PPUSH
9353: CALL_OW 262
9357: PUSH
9358: LD_VAR 0 2
9362: PPUSH
9363: CALL_OW 263
9367: PUSH
9368: LD_VAR 0 2
9372: PPUSH
9373: CALL_OW 264
9377: PUSH
9378: EMPTY
9379: LIST
9380: LIST
9381: LIST
9382: LIST
9383: ADD
9384: ST_TO_ADDR
9385: GO 9325
9387: POP
9388: POP
// SaveVariable ( tmp , 07_vehicles ) ;
9389: LD_VAR 0 3
9393: PPUSH
9394: LD_STRING 07_vehicles
9396: PPUSH
9397: CALL_OW 39
// YouWin ;
9401: CALL_OW 103
// end ; end_of_file
9405: PPOPN 3
9407: END
// on UnitDestroyed ( un ) do begin if un = JMM then
9408: LD_VAR 0 1
9412: PUSH
9413: LD_EXP 8
9417: EQUAL
9418: IFFALSE 9427
// YouLost ( JMM ) ;
9420: LD_STRING JMM
9422: PPUSH
9423: CALL_OW 104
// if GetType ( un ) = unit_building then
9427: LD_VAR 0 1
9431: PPUSH
9432: CALL_OW 247
9436: PUSH
9437: LD_INT 3
9439: EQUAL
9440: IFFALSE 9456
// buildings_counter := buildings_counter + 1 ;
9442: LD_ADDR_EXP 4
9446: PUSH
9447: LD_EXP 4
9451: PUSH
9452: LD_INT 1
9454: PLUS
9455: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
9456: LD_VAR 0 1
9460: PUSH
9461: LD_INT 6
9463: PPUSH
9464: LD_INT 2
9466: PUSH
9467: LD_INT 30
9469: PUSH
9470: LD_INT 33
9472: PUSH
9473: EMPTY
9474: LIST
9475: LIST
9476: PUSH
9477: LD_INT 30
9479: PUSH
9480: LD_INT 32
9482: PUSH
9483: EMPTY
9484: LIST
9485: LIST
9486: PUSH
9487: EMPTY
9488: LIST
9489: LIST
9490: LIST
9491: PPUSH
9492: CALL_OW 70
9496: IN
9497: IFFALSE 9556
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
9499: LD_ADDR_EXP 19
9503: PUSH
9504: LD_EXP 19
9508: PUSH
9509: LD_VAR 0 1
9513: PPUSH
9514: CALL_OW 266
9518: PUSH
9519: LD_VAR 0 1
9523: PPUSH
9524: CALL_OW 250
9528: PUSH
9529: LD_VAR 0 1
9533: PPUSH
9534: CALL_OW 251
9538: PUSH
9539: LD_VAR 0 1
9543: PPUSH
9544: CALL_OW 254
9548: PUSH
9549: EMPTY
9550: LIST
9551: LIST
9552: LIST
9553: LIST
9554: ADD
9555: ST_TO_ADDR
// if un = ru_dep_main then
9556: LD_VAR 0 1
9560: PUSH
9561: LD_INT 16
9563: EQUAL
9564: IFFALSE 9573
// ChangeMissionObjectives ( M1a ) ;
9566: LD_STRING M1a
9568: PPUSH
9569: CALL_OW 337
// end ;
9573: PPOPN 1
9575: END
// on BuildingStarted ( b , builder ) do var i ;
9576: LD_INT 0
9578: PPUSH
// begin if GetSide ( b ) = 3 then
9579: LD_VAR 0 1
9583: PPUSH
9584: CALL_OW 255
9588: PUSH
9589: LD_INT 3
9591: EQUAL
9592: IFFALSE 9632
// for i = 1 to 4 do
9594: LD_ADDR_VAR 0 3
9598: PUSH
9599: DOUBLE
9600: LD_INT 1
9602: DEC
9603: ST_TO_ADDR
9604: LD_INT 4
9606: PUSH
9607: FOR_TO
9608: IFFALSE 9630
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
9610: LD_ADDR_EXP 19
9614: PUSH
9615: LD_EXP 19
9619: PPUSH
9620: LD_INT 1
9622: PPUSH
9623: CALL_OW 3
9627: ST_TO_ADDR
9628: GO 9607
9630: POP
9631: POP
// end ;
9632: PPOPN 3
9634: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
9635: LD_VAR 0 1
9639: PPUSH
9640: CALL_OW 266
9644: PUSH
9645: LD_INT 32
9647: PUSH
9648: LD_INT 33
9650: PUSH
9651: EMPTY
9652: LIST
9653: LIST
9654: IN
9655: IFFALSE 9669
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
9657: LD_VAR 0 1
9661: PPUSH
9662: LD_INT 43
9664: PPUSH
9665: CALL_OW 148
9669: PPOPN 1
9671: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
9672: LD_VAR 0 1
9676: PUSH
9677: LD_INT 22
9679: PUSH
9680: LD_INT 3
9682: PUSH
9683: EMPTY
9684: LIST
9685: LIST
9686: PUSH
9687: LD_INT 2
9689: PUSH
9690: LD_INT 30
9692: PUSH
9693: LD_INT 31
9695: PUSH
9696: EMPTY
9697: LIST
9698: LIST
9699: PUSH
9700: LD_INT 30
9702: PUSH
9703: LD_INT 32
9705: PUSH
9706: EMPTY
9707: LIST
9708: LIST
9709: PUSH
9710: EMPTY
9711: LIST
9712: LIST
9713: LIST
9714: PUSH
9715: EMPTY
9716: LIST
9717: LIST
9718: PPUSH
9719: CALL_OW 69
9723: IN
9724: IFFALSE 9746
// GoToAnotherTower ( un , b , 143 , 143 ) ;
9726: LD_VAR 0 2
9730: PPUSH
9731: LD_VAR 0 1
9735: PPUSH
9736: LD_INT 143
9738: PPUSH
9739: LD_INT 143
9741: PPUSH
9742: CALL 735 0 4
// end ;
9746: PPOPN 2
9748: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
9749: LD_VAR 0 1
9753: PUSH
9754: LD_INT 22
9756: PUSH
9757: LD_INT 3
9759: PUSH
9760: EMPTY
9761: LIST
9762: LIST
9763: PUSH
9764: LD_INT 30
9766: PUSH
9767: LD_INT 32
9769: PUSH
9770: EMPTY
9771: LIST
9772: LIST
9773: PUSH
9774: EMPTY
9775: LIST
9776: LIST
9777: PPUSH
9778: CALL_OW 69
9782: IN
9783: IFFALSE 9797
// SetTag ( b , 0 ) ;
9785: LD_VAR 0 1
9789: PPUSH
9790: LD_INT 0
9792: PPUSH
9793: CALL_OW 109
// end ;
9797: PPOPN 2
9799: END
