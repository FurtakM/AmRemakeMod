// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// Init ;
   8: CALL 33 0 0
// DebugMode ;
  12: CALL 234 0 0
// PrepareNature ;
  16: CALL 1552 0 0
// PrepareRussians ;
  20: CALL 3082 0 0
// PrepareAmericans ;
  24: CALL 2037 0 0
// Action ;
  28: CALL 6608 0 0
// end ;
  32: END
// export debug ; export mission_prev_prefix , mission_prefix ; export buildings_counter , time_to_end , can_end , must_end ; function Init ; begin
  33: LD_INT 0
  35: PPUSH
// debug := false ;
  36: LD_ADDR_EXP 1
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// mission_prefix := 07c_ ;
  44: LD_ADDR_EXP 3
  48: PUSH
  49: LD_STRING 07c_
  51: ST_TO_ADDR
// mission_prev_prefix := 07_ ;
  52: LD_ADDR_EXP 2
  56: PUSH
  57: LD_STRING 07_
  59: ST_TO_ADDR
// buildings_counter := 0 ;
  60: LD_ADDR_EXP 4
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// time_to_end := [ [ 33 33$00 , 30 30$00 , 27 27$00 ] [ Difficulty ] , [ 39 39$00 , 36 36$00 , 33 33$00 ] [ Difficulty ] , [ 45 45$00 , 42 42$00 , 39 39$00 ] [ Difficulty ] ] ;
  68: LD_ADDR_EXP 5
  72: PUSH
  73: LD_INT 69300
  75: PUSH
  76: LD_INT 63000
  78: PUSH
  79: LD_INT 56700
  81: PUSH
  82: EMPTY
  83: LIST
  84: LIST
  85: LIST
  86: PUSH
  87: LD_OWVAR 67
  91: ARRAY
  92: PUSH
  93: LD_INT 81900
  95: PUSH
  96: LD_INT 75600
  98: PUSH
  99: LD_INT 69300
 101: PUSH
 102: EMPTY
 103: LIST
 104: LIST
 105: LIST
 106: PUSH
 107: LD_OWVAR 67
 111: ARRAY
 112: PUSH
 113: LD_INT 94500
 115: PUSH
 116: LD_INT 88200
 118: PUSH
 119: LD_INT 81900
 121: PUSH
 122: EMPTY
 123: LIST
 124: LIST
 125: LIST
 126: PUSH
 127: LD_OWVAR 67
 131: ARRAY
 132: PUSH
 133: EMPTY
 134: LIST
 135: LIST
 136: LIST
 137: ST_TO_ADDR
// can_end := false ;
 138: LD_ADDR_EXP 6
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// must_end := false ;
 146: LD_ADDR_EXP 7
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// end ;
 154: LD_VAR 0 1
 158: RET
// every 0 0$01 trigger not debug do
 159: LD_EXP 1
 163: NOT
 164: IFFALSE 233
 166: GO 168
 168: DISABLE
// begin enable ;
 169: ENABLE
// if not must_end then
 170: LD_EXP 7
 174: NOT
 175: IFFALSE 196
// display_strings := [ #Am07-1 , tick ] else
 177: LD_ADDR_OWVAR 47
 181: PUSH
 182: LD_STRING #Am07-1
 184: PUSH
 185: LD_OWVAR 1
 189: PUSH
 190: EMPTY
 191: LIST
 192: LIST
 193: ST_TO_ADDR
 194: GO 233
// display_strings := [ #Am07-1 , tick , #Am07-2 , time_to_end [ 3 ] - tick ] ;
 196: LD_ADDR_OWVAR 47
 200: PUSH
 201: LD_STRING #Am07-1
 203: PUSH
 204: LD_OWVAR 1
 208: PUSH
 209: LD_STRING #Am07-2
 211: PUSH
 212: LD_EXP 5
 216: PUSH
 217: LD_INT 3
 219: ARRAY
 220: PUSH
 221: LD_OWVAR 1
 225: MINUS
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: LIST
 232: ST_TO_ADDR
// end ;
 233: END
// function DebugMode ; begin
 234: LD_INT 0
 236: PPUSH
// if not debug then
 237: LD_EXP 1
 241: NOT
 242: IFFALSE 246
// exit ;
 244: GO 253
// FogOff ( 1 ) ;
 246: LD_INT 1
 248: PPUSH
 249: CALL_OW 344
// end ;
 253: LD_VAR 0 1
 257: RET
// every 3 trigger debug do var i , filter ;
 258: LD_EXP 1
 262: IFFALSE 351
 264: GO 266
 266: DISABLE
 267: LD_INT 0
 269: PPUSH
 270: PPUSH
// begin enable ;
 271: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_lives , 500 ] ] ] ) ;
 272: LD_ADDR_VAR 0 2
 276: PUSH
 277: LD_INT 22
 279: PUSH
 280: LD_INT 1
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: PUSH
 287: LD_INT 3
 289: PUSH
 290: LD_INT 24
 292: PUSH
 293: LD_INT 500
 295: PUSH
 296: EMPTY
 297: LIST
 298: LIST
 299: PUSH
 300: EMPTY
 301: LIST
 302: LIST
 303: PUSH
 304: EMPTY
 305: LIST
 306: LIST
 307: PPUSH
 308: CALL_OW 69
 312: ST_TO_ADDR
// if not filter then
 313: LD_VAR 0 2
 317: NOT
 318: IFFALSE 322
// exit ;
 320: GO 351
// for i in filter do
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_VAR 0 2
 331: PUSH
 332: FOR_IN
 333: IFFALSE 349
// SetLives ( i , 1000 ) ;
 335: LD_VAR 0 1
 339: PPUSH
 340: LD_INT 1000
 342: PPUSH
 343: CALL_OW 234
 347: GO 332
 349: POP
 350: POP
// end ; end_of_file
 351: PPOPN 2
 353: END
// export function PrepareUnit ( ident , exist_mode ) ; var unit ; begin
 354: LD_INT 0
 356: PPUSH
 357: PPUSH
// if exist_mode then
 358: LD_VAR 0 2
 362: IFFALSE 387
// unit := CreateCharacter ( mission_prev_prefix & ident ) else
 364: LD_ADDR_VAR 0 4
 368: PUSH
 369: LD_EXP 2
 373: PUSH
 374: LD_VAR 0 1
 378: STR
 379: PPUSH
 380: CALL_OW 34
 384: ST_TO_ADDR
 385: GO 402
// unit := NewCharacter ( ident ) ;
 387: LD_ADDR_VAR 0 4
 391: PUSH
 392: LD_VAR 0 1
 396: PPUSH
 397: CALL_OW 25
 401: ST_TO_ADDR
// result := unit ;
 402: LD_ADDR_VAR 0 3
 406: PUSH
 407: LD_VAR 0 4
 411: ST_TO_ADDR
// end ;
 412: LD_VAR 0 3
 416: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 417: LD_INT 0
 419: PPUSH
// uc_side := side ;
 420: LD_ADDR_OWVAR 20
 424: PUSH
 425: LD_VAR 0 1
 429: ST_TO_ADDR
// uc_nation := nation ;
 430: LD_ADDR_OWVAR 21
 434: PUSH
 435: LD_VAR 0 2
 439: ST_TO_ADDR
// vc_chassis := chassis ;
 440: LD_ADDR_OWVAR 37
 444: PUSH
 445: LD_VAR 0 3
 449: ST_TO_ADDR
// vc_engine := engine ;
 450: LD_ADDR_OWVAR 39
 454: PUSH
 455: LD_VAR 0 4
 459: ST_TO_ADDR
// vc_control := control ;
 460: LD_ADDR_OWVAR 38
 464: PUSH
 465: LD_VAR 0 5
 469: ST_TO_ADDR
// vc_weapon := weapon ;
 470: LD_ADDR_OWVAR 40
 474: PUSH
 475: LD_VAR 0 6
 479: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 480: LD_ADDR_OWVAR 41
 484: PUSH
 485: LD_VAR 0 7
 489: ST_TO_ADDR
// result := CreateVehicle ;
 490: LD_ADDR_VAR 0 8
 494: PUSH
 495: CALL_OW 45
 499: ST_TO_ADDR
// end ;
 500: LD_VAR 0 8
 504: RET
// export function GetRandom ( sex ) ; var i , filter ; begin
 505: LD_INT 0
 507: PPUSH
 508: PPUSH
 509: PPUSH
// filter := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_ok ] ] ) diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi , Khatam ] ;
 510: LD_ADDR_VAR 0 4
 514: PUSH
 515: LD_INT 22
 517: PUSH
 518: LD_INT 1
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: PUSH
 525: LD_INT 21
 527: PUSH
 528: LD_INT 1
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: PUSH
 535: LD_INT 50
 537: PUSH
 538: EMPTY
 539: LIST
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: PPUSH
 546: CALL_OW 69
 550: PUSH
 551: LD_EXP 8
 555: PUSH
 556: LD_EXP 9
 560: PUSH
 561: LD_EXP 10
 565: PUSH
 566: LD_EXP 11
 570: PUSH
 571: LD_EXP 12
 575: PUSH
 576: LD_EXP 13
 580: PUSH
 581: LD_EXP 14
 585: PUSH
 586: LD_EXP 15
 590: PUSH
 591: LD_EXP 17
 595: PUSH
 596: LD_EXP 16
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: DIFF
 613: ST_TO_ADDR
// if not filter then
 614: LD_VAR 0 4
 618: NOT
 619: IFFALSE 623
// exit ;
 621: GO 650
// result := UnitFilter ( filter , [ f_sex , sex ] ) ;
 623: LD_ADDR_VAR 0 2
 627: PUSH
 628: LD_VAR 0 4
 632: PPUSH
 633: LD_INT 26
 635: PUSH
 636: LD_VAR 0 1
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL_OW 72
 649: ST_TO_ADDR
// end ;
 650: LD_VAR 0 2
 654: RET
// export function SayX ( units , ident ) ; var i ; begin
 655: LD_INT 0
 657: PPUSH
 658: PPUSH
// result := false ;
 659: LD_ADDR_VAR 0 3
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// if not units then
 667: LD_VAR 0 1
 671: NOT
 672: IFFALSE 676
// exit ;
 674: GO 730
// for i in units do
 676: LD_ADDR_VAR 0 4
 680: PUSH
 681: LD_VAR 0 1
 685: PUSH
 686: FOR_IN
 687: IFFALSE 728
// if IsOk ( i ) then
 689: LD_VAR 0 4
 693: PPUSH
 694: CALL_OW 302
 698: IFFALSE 726
// begin Say ( i , ident ) ;
 700: LD_VAR 0 4
 704: PPUSH
 705: LD_VAR 0 2
 709: PPUSH
 710: CALL_OW 88
// result := i ;
 714: LD_ADDR_VAR 0 3
 718: PUSH
 719: LD_VAR 0 4
 723: ST_TO_ADDR
// break ;
 724: GO 728
// end ;
 726: GO 686
 728: POP
 729: POP
// end ;
 730: LD_VAR 0 3
 734: RET
// export function GoToAnotherTower ( un , b , x , y ) ; var i , filter , t , side ; begin
 735: LD_INT 0
 737: PPUSH
 738: PPUSH
 739: PPUSH
 740: PPUSH
 741: PPUSH
// if not un or not IsOk ( un ) then
 742: LD_VAR 0 1
 746: NOT
 747: PUSH
 748: LD_VAR 0 1
 752: PPUSH
 753: CALL_OW 302
 757: NOT
 758: OR
 759: IFFALSE 763
// exit ;
 761: GO 1157
// side := GetSide ( un ) ;
 763: LD_ADDR_VAR 0 9
 767: PUSH
 768: LD_VAR 0 1
 772: PPUSH
 773: CALL_OW 255
 777: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_ok ] , [ f_empty ] ] ) diff b ;
 778: LD_ADDR_VAR 0 7
 782: PUSH
 783: LD_INT 22
 785: PUSH
 786: LD_VAR 0 9
 790: PUSH
 791: EMPTY
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 30
 797: PUSH
 798: LD_INT 32
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: PUSH
 805: LD_INT 50
 807: PUSH
 808: EMPTY
 809: LIST
 810: PUSH
 811: LD_INT 58
 813: PUSH
 814: EMPTY
 815: LIST
 816: PUSH
 817: EMPTY
 818: LIST
 819: LIST
 820: LIST
 821: LIST
 822: PPUSH
 823: CALL_OW 69
 827: PUSH
 828: LD_VAR 0 2
 832: DIFF
 833: ST_TO_ADDR
// if not filter then
 834: LD_VAR 0 7
 838: NOT
 839: IFFALSE 1022
// begin filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
 841: LD_ADDR_VAR 0 7
 845: PUSH
 846: LD_INT 22
 848: PUSH
 849: LD_VAR 0 9
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: PUSH
 858: LD_INT 30
 860: PUSH
 861: LD_INT 5
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PPUSH
 872: CALL_OW 69
 876: ST_TO_ADDR
// if not filter then
 877: LD_VAR 0 7
 881: NOT
 882: IFFALSE 905
// begin ComMoveXY ( un , x , y ) ;
 884: LD_VAR 0 1
 888: PPUSH
 889: LD_VAR 0 3
 893: PPUSH
 894: LD_VAR 0 4
 898: PPUSH
 899: CALL_OW 111
// exit ;
 903: GO 1157
// end ; repeat t := NearestUnitToUnit ( filter , un ) ;
 905: LD_ADDR_VAR 0 8
 909: PUSH
 910: LD_VAR 0 7
 914: PPUSH
 915: LD_VAR 0 1
 919: PPUSH
 920: CALL_OW 74
 924: ST_TO_ADDR
// if UnitsInside ( t ) = 6 then
 925: LD_VAR 0 8
 929: PPUSH
 930: CALL_OW 313
 934: PUSH
 935: LD_INT 6
 937: EQUAL
 938: IFFALSE 956
// filter := filter diff t ;
 940: LD_ADDR_VAR 0 7
 944: PUSH
 945: LD_VAR 0 7
 949: PUSH
 950: LD_VAR 0 8
 954: DIFF
 955: ST_TO_ADDR
// until UnitsInside ( t ) < 6 or not filter ;
 956: LD_VAR 0 8
 960: PPUSH
 961: CALL_OW 313
 965: PUSH
 966: LD_INT 6
 968: LESS
 969: PUSH
 970: LD_VAR 0 7
 974: NOT
 975: OR
 976: IFFALSE 905
// if not filter then
 978: LD_VAR 0 7
 982: NOT
 983: IFFALSE 1006
// ComMoveXY ( un , x , y ) else
 985: LD_VAR 0 1
 989: PPUSH
 990: LD_VAR 0 3
 994: PPUSH
 995: LD_VAR 0 4
 999: PPUSH
1000: CALL_OW 111
1004: GO 1020
// ComEnterUnit ( un , t ) ;
1006: LD_VAR 0 1
1010: PPUSH
1011: LD_VAR 0 8
1015: PPUSH
1016: CALL_OW 120
// end else
1020: GO 1157
// begin repeat t := NearestUnitToUnit ( filter , un ) ;
1022: LD_ADDR_VAR 0 8
1026: PUSH
1027: LD_VAR 0 7
1031: PPUSH
1032: LD_VAR 0 1
1036: PPUSH
1037: CALL_OW 74
1041: ST_TO_ADDR
// if ( GetTag ( t ) = 7 ) then
1042: LD_VAR 0 8
1046: PPUSH
1047: CALL_OW 110
1051: PUSH
1052: LD_INT 7
1054: EQUAL
1055: IFFALSE 1073
// filter := filter diff t ;
1057: LD_ADDR_VAR 0 7
1061: PUSH
1062: LD_VAR 0 7
1066: PUSH
1067: LD_VAR 0 8
1071: DIFF
1072: ST_TO_ADDR
// until GetTag ( t ) <> 7 or not filter ;
1073: LD_VAR 0 8
1077: PPUSH
1078: CALL_OW 110
1082: PUSH
1083: LD_INT 7
1085: NONEQUAL
1086: PUSH
1087: LD_VAR 0 7
1091: NOT
1092: OR
1093: IFFALSE 1022
// if GetTag ( t ) <> 7 then
1095: LD_VAR 0 8
1099: PPUSH
1100: CALL_OW 110
1104: PUSH
1105: LD_INT 7
1107: NONEQUAL
1108: IFFALSE 1138
// begin SetTag ( t , 7 ) ;
1110: LD_VAR 0 8
1114: PPUSH
1115: LD_INT 7
1117: PPUSH
1118: CALL_OW 109
// ComEnterUnit ( un , t ) ;
1122: LD_VAR 0 1
1126: PPUSH
1127: LD_VAR 0 8
1131: PPUSH
1132: CALL_OW 120
// end else
1136: GO 1157
// ComMoveXY ( un , x , y ) ;
1138: LD_VAR 0 1
1142: PPUSH
1143: LD_VAR 0 3
1147: PPUSH
1148: LD_VAR 0 4
1152: PPUSH
1153: CALL_OW 111
// end ; end ;
1157: LD_VAR 0 5
1161: RET
// export function BaseNeedEnergy ( base ) ; var i , tmp ; begin
1162: LD_INT 0
1164: PPUSH
1165: PPUSH
1166: PPUSH
// if not base then
1167: LD_VAR 0 1
1171: NOT
1172: IFFALSE 1176
// exit ;
1174: GO 1234
// tmp := GetEnergy ( GetBase ( base ) ) ;
1176: LD_ADDR_VAR 0 4
1180: PUSH
1181: LD_VAR 0 1
1185: PPUSH
1186: CALL_OW 274
1190: PPUSH
1191: CALL_OW 278
1195: ST_TO_ADDR
// if tmp [ 1 ] > tmp [ 4 ] then
1196: LD_VAR 0 4
1200: PUSH
1201: LD_INT 1
1203: ARRAY
1204: PUSH
1205: LD_VAR 0 4
1209: PUSH
1210: LD_INT 4
1212: ARRAY
1213: GREATER
1214: IFFALSE 1226
// result := true else
1216: LD_ADDR_VAR 0 2
1220: PUSH
1221: LD_INT 1
1223: ST_TO_ADDR
1224: GO 1234
// result := false ;
1226: LD_ADDR_VAR 0 2
1230: PUSH
1231: LD_INT 0
1233: ST_TO_ADDR
// end ;
1234: LD_VAR 0 2
1238: RET
// export function FilterPeople ( side ) ; begin
1239: LD_INT 0
1241: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
1242: LD_ADDR_VAR 0 2
1246: PUSH
1247: LD_INT 22
1249: PUSH
1250: LD_VAR 0 1
1254: PUSH
1255: EMPTY
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 21
1261: PUSH
1262: LD_INT 1
1264: PUSH
1265: EMPTY
1266: LIST
1267: LIST
1268: PUSH
1269: EMPTY
1270: LIST
1271: LIST
1272: PPUSH
1273: CALL_OW 69
1277: ST_TO_ADDR
// end ;
1278: LD_VAR 0 2
1282: RET
// export function FilterDrivers ( side ) ; begin
1283: LD_INT 0
1285: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_outside ] ] ] ) ;
1286: LD_ADDR_VAR 0 2
1290: PUSH
1291: LD_INT 22
1293: PUSH
1294: LD_VAR 0 1
1298: PUSH
1299: EMPTY
1300: LIST
1301: LIST
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: LD_INT 56
1308: PUSH
1309: EMPTY
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: PUSH
1316: EMPTY
1317: LIST
1318: LIST
1319: PPUSH
1320: CALL_OW 69
1324: ST_TO_ADDR
// end ;
1325: LD_VAR 0 2
1329: RET
// export function FilterPeopleArea ( side , area ) ; begin
1330: LD_INT 0
1332: PPUSH
// result := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
1333: LD_ADDR_VAR 0 3
1337: PUSH
1338: LD_VAR 0 2
1342: PPUSH
1343: LD_INT 22
1345: PUSH
1346: LD_INT 1
1348: PUSH
1349: EMPTY
1350: LIST
1351: LIST
1352: PUSH
1353: LD_INT 21
1355: PUSH
1356: LD_INT 1
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: PUSH
1363: EMPTY
1364: LIST
1365: LIST
1366: PPUSH
1367: CALL_OW 70
1371: ST_TO_ADDR
// end ;
1372: LD_VAR 0 3
1376: RET
// export function FilterDriversArea ( side , area ) ; var i , tmp ; begin
1377: LD_INT 0
1379: PPUSH
1380: PPUSH
1381: PPUSH
// tmp := FilterUnitsInArea ( area , [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
1382: LD_ADDR_VAR 0 5
1386: PUSH
1387: LD_VAR 0 2
1391: PPUSH
1392: LD_INT 22
1394: PUSH
1395: LD_INT 1
1397: PUSH
1398: EMPTY
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 21
1404: PUSH
1405: LD_INT 2
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: PUSH
1412: LD_INT 3
1414: PUSH
1415: LD_INT 58
1417: PUSH
1418: EMPTY
1419: LIST
1420: PUSH
1421: EMPTY
1422: LIST
1423: LIST
1424: PUSH
1425: EMPTY
1426: LIST
1427: LIST
1428: LIST
1429: PPUSH
1430: CALL_OW 70
1434: ST_TO_ADDR
// result := [ ] ;
1435: LD_ADDR_VAR 0 3
1439: PUSH
1440: EMPTY
1441: ST_TO_ADDR
// if not tmp then
1442: LD_VAR 0 5
1446: NOT
1447: IFFALSE 1451
// exit ;
1449: GO 1503
// for i in tmp do
1451: LD_ADDR_VAR 0 4
1455: PUSH
1456: LD_VAR 0 5
1460: PUSH
1461: FOR_IN
1462: IFFALSE 1487
// result := result ^ IsDrivenBy ( i ) ;
1464: LD_ADDR_VAR 0 3
1468: PUSH
1469: LD_VAR 0 3
1473: PUSH
1474: LD_VAR 0 4
1478: PPUSH
1479: CALL_OW 311
1483: ADD
1484: ST_TO_ADDR
1485: GO 1461
1487: POP
1488: POP
// result := result diff 0 ;
1489: LD_ADDR_VAR 0 3
1493: PUSH
1494: LD_VAR 0 3
1498: PUSH
1499: LD_INT 0
1501: DIFF
1502: ST_TO_ADDR
// end ;
1503: LD_VAR 0 3
1507: RET
// export function FilterBuildings ( side ) ; begin
1508: LD_INT 0
1510: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
1511: LD_ADDR_VAR 0 2
1515: PUSH
1516: LD_INT 22
1518: PUSH
1519: LD_VAR 0 1
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: PUSH
1528: LD_INT 21
1530: PUSH
1531: LD_INT 3
1533: PUSH
1534: EMPTY
1535: LIST
1536: LIST
1537: PUSH
1538: EMPTY
1539: LIST
1540: LIST
1541: PPUSH
1542: CALL_OW 69
1546: ST_TO_ADDR
// end ;
1547: LD_VAR 0 2
1551: RET
// export function PrepareNature ; var i , animal , nat_area ; begin
1552: LD_INT 0
1554: PPUSH
1555: PPUSH
1556: PPUSH
1557: PPUSH
// uc_side = 0 ;
1558: LD_ADDR_OWVAR 20
1562: PUSH
1563: LD_INT 0
1565: ST_TO_ADDR
// uc_nation = 0 ;
1566: LD_ADDR_OWVAR 21
1570: PUSH
1571: LD_INT 0
1573: ST_TO_ADDR
// nat_area := wildArea ;
1574: LD_ADDR_VAR 0 4
1578: PUSH
1579: LD_INT 3
1581: ST_TO_ADDR
// InitHc ;
1582: CALL_OW 19
// for i = 1 to 4 do
1586: LD_ADDR_VAR 0 2
1590: PUSH
1591: DOUBLE
1592: LD_INT 1
1594: DEC
1595: ST_TO_ADDR
1596: LD_INT 4
1598: PUSH
1599: FOR_TO
1600: IFFALSE 1655
// begin hc_class = 18 ;
1602: LD_ADDR_OWVAR 28
1606: PUSH
1607: LD_INT 18
1609: ST_TO_ADDR
// hc_gallery =  ;
1610: LD_ADDR_OWVAR 33
1614: PUSH
1615: LD_STRING 
1617: ST_TO_ADDR
// hc_face_number = 1 ;
1618: LD_ADDR_OWVAR 34
1622: PUSH
1623: LD_INT 1
1625: ST_TO_ADDR
// animal := CreateHuman ;
1626: LD_ADDR_VAR 0 3
1630: PUSH
1631: CALL_OW 44
1635: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1636: LD_VAR 0 3
1640: PPUSH
1641: LD_VAR 0 4
1645: PPUSH
1646: LD_INT 0
1648: PPUSH
1649: CALL_OW 49
// end ;
1653: GO 1599
1655: POP
1656: POP
// for i = 1 to 6 do
1657: LD_ADDR_VAR 0 2
1661: PUSH
1662: DOUBLE
1663: LD_INT 1
1665: DEC
1666: ST_TO_ADDR
1667: LD_INT 6
1669: PUSH
1670: FOR_TO
1671: IFFALSE 1742
// begin hc_class = class_tiger ;
1673: LD_ADDR_OWVAR 28
1677: PUSH
1678: LD_INT 14
1680: ST_TO_ADDR
// hc_gallery =  ;
1681: LD_ADDR_OWVAR 33
1685: PUSH
1686: LD_STRING 
1688: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 50 ) ;
1689: LD_ADDR_OWVAR 35
1693: PUSH
1694: LD_INT 0
1696: PPUSH
1697: LD_INT 50
1699: PPUSH
1700: CALL_OW 12
1704: ST_TO_ADDR
// hc_face_number = 3 ;
1705: LD_ADDR_OWVAR 34
1709: PUSH
1710: LD_INT 3
1712: ST_TO_ADDR
// animal := CreateHuman ;
1713: LD_ADDR_VAR 0 3
1717: PUSH
1718: CALL_OW 44
1722: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1723: LD_VAR 0 3
1727: PPUSH
1728: LD_VAR 0 4
1732: PPUSH
1733: LD_INT 0
1735: PPUSH
1736: CALL_OW 49
// end ;
1740: GO 1670
1742: POP
1743: POP
// for i = 1 to 2 do
1744: LD_ADDR_VAR 0 2
1748: PUSH
1749: DOUBLE
1750: LD_INT 1
1752: DEC
1753: ST_TO_ADDR
1754: LD_INT 2
1756: PUSH
1757: FOR_TO
1758: IFFALSE 1821
// begin hc_class = 21 ;
1760: LD_ADDR_OWVAR 28
1764: PUSH
1765: LD_INT 21
1767: ST_TO_ADDR
// hc_gallery =  ;
1768: LD_ADDR_OWVAR 33
1772: PUSH
1773: LD_STRING 
1775: ST_TO_ADDR
// hc_agressivity = 0 ;
1776: LD_ADDR_OWVAR 35
1780: PUSH
1781: LD_INT 0
1783: ST_TO_ADDR
// hc_face_number = 5 ;
1784: LD_ADDR_OWVAR 34
1788: PUSH
1789: LD_INT 5
1791: ST_TO_ADDR
// animal := CreateHuman ;
1792: LD_ADDR_VAR 0 3
1796: PUSH
1797: CALL_OW 44
1801: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1802: LD_VAR 0 3
1806: PPUSH
1807: LD_VAR 0 4
1811: PPUSH
1812: LD_INT 0
1814: PPUSH
1815: CALL_OW 49
// end ;
1819: GO 1757
1821: POP
1822: POP
// for i = 1 to 6 do
1823: LD_ADDR_VAR 0 2
1827: PUSH
1828: DOUBLE
1829: LD_INT 1
1831: DEC
1832: ST_TO_ADDR
1833: LD_INT 6
1835: PUSH
1836: FOR_TO
1837: IFFALSE 1892
// begin hc_class = 13 ;
1839: LD_ADDR_OWVAR 28
1843: PUSH
1844: LD_INT 13
1846: ST_TO_ADDR
// hc_gallery =  ;
1847: LD_ADDR_OWVAR 33
1851: PUSH
1852: LD_STRING 
1854: ST_TO_ADDR
// hc_face_number = 4 ;
1855: LD_ADDR_OWVAR 34
1859: PUSH
1860: LD_INT 4
1862: ST_TO_ADDR
// animal := CreateHuman ;
1863: LD_ADDR_VAR 0 3
1867: PUSH
1868: CALL_OW 44
1872: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
1873: LD_VAR 0 3
1877: PPUSH
1878: LD_VAR 0 4
1882: PPUSH
1883: LD_INT 0
1885: PPUSH
1886: CALL_OW 49
// end ;
1890: GO 1836
1892: POP
1893: POP
// for i = 1 to 2 do
1894: LD_ADDR_VAR 0 2
1898: PUSH
1899: DOUBLE
1900: LD_INT 1
1902: DEC
1903: ST_TO_ADDR
1904: LD_INT 2
1906: PUSH
1907: FOR_TO
1908: IFFALSE 1967
// begin hc_class = 20 ;
1910: LD_ADDR_OWVAR 28
1914: PUSH
1915: LD_INT 20
1917: ST_TO_ADDR
// hc_gallery =  ;
1918: LD_ADDR_OWVAR 33
1922: PUSH
1923: LD_STRING 
1925: ST_TO_ADDR
// hc_face_number = 2 ;
1926: LD_ADDR_OWVAR 34
1930: PUSH
1931: LD_INT 2
1933: ST_TO_ADDR
// animal := CreateHuman ;
1934: LD_ADDR_VAR 0 3
1938: PUSH
1939: CALL_OW 44
1943: ST_TO_ADDR
// PlaceUnitXYR ( animal , 101 , 37 , 3 , false ) ;
1944: LD_VAR 0 3
1948: PPUSH
1949: LD_INT 101
1951: PPUSH
1952: LD_INT 37
1954: PPUSH
1955: LD_INT 3
1957: PPUSH
1958: LD_INT 0
1960: PPUSH
1961: CALL_OW 50
// end ;
1965: GO 1907
1967: POP
1968: POP
// for i = 1 to 1 do
1969: LD_ADDR_VAR 0 2
1973: PUSH
1974: DOUBLE
1975: LD_INT 1
1977: DEC
1978: ST_TO_ADDR
1979: LD_INT 1
1981: PUSH
1982: FOR_TO
1983: IFFALSE 2030
// begin vc_chassis := 31 ;
1985: LD_ADDR_OWVAR 37
1989: PUSH
1990: LD_INT 31
1992: ST_TO_ADDR
// vc_control := control_rider ;
1993: LD_ADDR_OWVAR 38
1997: PUSH
1998: LD_INT 4
2000: ST_TO_ADDR
// animal := CreateVehicle ;
2001: LD_ADDR_VAR 0 3
2005: PUSH
2006: CALL_OW 45
2010: ST_TO_ADDR
// PlaceUnitArea ( animal , nat_area , false ) ;
2011: LD_VAR 0 3
2015: PPUSH
2016: LD_VAR 0 4
2020: PPUSH
2021: LD_INT 0
2023: PPUSH
2024: CALL_OW 49
// end ;
2028: GO 1982
2030: POP
2031: POP
// end ; end_of_file
2032: LD_VAR 0 1
2036: RET
// export JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Khatam , Kikuchi , Harisson ; export function PrepareAmericans ; var i , team , others , veh , m ; begin
2037: LD_INT 0
2039: PPUSH
2040: PPUSH
2041: PPUSH
2042: PPUSH
2043: PPUSH
2044: PPUSH
// uc_side := 1 ;
2045: LD_ADDR_OWVAR 20
2049: PUSH
2050: LD_INT 1
2052: ST_TO_ADDR
// uc_nation := 1 ;
2053: LD_ADDR_OWVAR 21
2057: PUSH
2058: LD_INT 1
2060: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) ) ;
2061: LD_ADDR_EXP 8
2065: PUSH
2066: LD_STRING JMM
2068: PPUSH
2069: LD_EXP 1
2073: NOT
2074: PPUSH
2075: CALL 354 0 2
2079: ST_TO_ADDR
// team := [ JMM ] ;
2080: LD_ADDR_VAR 0 3
2084: PUSH
2085: LD_EXP 8
2089: PUSH
2090: EMPTY
2091: LIST
2092: ST_TO_ADDR
// if LoadVariable ( BrownIn07 , debug ) then
2093: LD_STRING BrownIn07
2095: PPUSH
2096: LD_EXP 1
2100: PPUSH
2101: CALL_OW 30
2105: IFFALSE 2126
// Brown := PrepareUnit ( Brown , ( not debug ) ) ;
2107: LD_ADDR_EXP 9
2111: PUSH
2112: LD_STRING Brown
2114: PPUSH
2115: LD_EXP 1
2119: NOT
2120: PPUSH
2121: CALL 354 0 2
2125: ST_TO_ADDR
// if Brown then
2126: LD_EXP 9
2130: IFFALSE 2148
// team := team ^ Brown ;
2132: LD_ADDR_VAR 0 3
2136: PUSH
2137: LD_VAR 0 3
2141: PUSH
2142: LD_EXP 9
2146: ADD
2147: ST_TO_ADDR
// if LoadVariable ( DonaldsonIn07 , debug ) then
2148: LD_STRING DonaldsonIn07
2150: PPUSH
2151: LD_EXP 1
2155: PPUSH
2156: CALL_OW 30
2160: IFFALSE 2181
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) ) ;
2162: LD_ADDR_EXP 10
2166: PUSH
2167: LD_STRING Donaldson
2169: PPUSH
2170: LD_EXP 1
2174: NOT
2175: PPUSH
2176: CALL 354 0 2
2180: ST_TO_ADDR
// if Donaldson then
2181: LD_EXP 10
2185: IFFALSE 2203
// team := team ^ Donaldson ;
2187: LD_ADDR_VAR 0 3
2191: PUSH
2192: LD_VAR 0 3
2196: PUSH
2197: LD_EXP 10
2201: ADD
2202: ST_TO_ADDR
// if LoadVariable ( BobbyIn07 , debug ) then
2203: LD_STRING BobbyIn07
2205: PPUSH
2206: LD_EXP 1
2210: PPUSH
2211: CALL_OW 30
2215: IFFALSE 2236
// Bobby := PrepareUnit ( Bobby , ( not debug ) ) ;
2217: LD_ADDR_EXP 11
2221: PUSH
2222: LD_STRING Bobby
2224: PPUSH
2225: LD_EXP 1
2229: NOT
2230: PPUSH
2231: CALL 354 0 2
2235: ST_TO_ADDR
// if Bobby then
2236: LD_EXP 11
2240: IFFALSE 2258
// team := team ^ Bobby ;
2242: LD_ADDR_VAR 0 3
2246: PUSH
2247: LD_VAR 0 3
2251: PUSH
2252: LD_EXP 11
2256: ADD
2257: ST_TO_ADDR
// if LoadVariable ( CyrusIn07 , debug ) then
2258: LD_STRING CyrusIn07
2260: PPUSH
2261: LD_EXP 1
2265: PPUSH
2266: CALL_OW 30
2270: IFFALSE 2291
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) ) ;
2272: LD_ADDR_EXP 12
2276: PUSH
2277: LD_STRING Cyrus
2279: PPUSH
2280: LD_EXP 1
2284: NOT
2285: PPUSH
2286: CALL 354 0 2
2290: ST_TO_ADDR
// if Cyrus then
2291: LD_EXP 12
2295: IFFALSE 2313
// team := team ^ Cyrus ;
2297: LD_ADDR_VAR 0 3
2301: PUSH
2302: LD_VAR 0 3
2306: PUSH
2307: LD_EXP 12
2311: ADD
2312: ST_TO_ADDR
// if LoadVariable ( LisaIn07 , debug ) then
2313: LD_STRING LisaIn07
2315: PPUSH
2316: LD_EXP 1
2320: PPUSH
2321: CALL_OW 30
2325: IFFALSE 2346
// Lisa := PrepareUnit ( Lisa , ( not debug ) ) ;
2327: LD_ADDR_EXP 13
2331: PUSH
2332: LD_STRING Lisa
2334: PPUSH
2335: LD_EXP 1
2339: NOT
2340: PPUSH
2341: CALL 354 0 2
2345: ST_TO_ADDR
// if Lisa then
2346: LD_EXP 13
2350: IFFALSE 2368
// team := team ^ Lisa ;
2352: LD_ADDR_VAR 0 3
2356: PUSH
2357: LD_VAR 0 3
2361: PUSH
2362: LD_EXP 13
2366: ADD
2367: ST_TO_ADDR
// if LoadVariable ( GladstoneIn07 , debug ) then
2368: LD_STRING GladstoneIn07
2370: PPUSH
2371: LD_EXP 1
2375: PPUSH
2376: CALL_OW 30
2380: IFFALSE 2401
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) ) ;
2382: LD_ADDR_EXP 15
2386: PUSH
2387: LD_STRING Gladstone
2389: PPUSH
2390: LD_EXP 1
2394: NOT
2395: PPUSH
2396: CALL 354 0 2
2400: ST_TO_ADDR
// if Gladstone then
2401: LD_EXP 15
2405: IFFALSE 2423
// team := team ^ Gladstone ;
2407: LD_ADDR_VAR 0 3
2411: PUSH
2412: LD_VAR 0 3
2416: PUSH
2417: LD_EXP 15
2421: ADD
2422: ST_TO_ADDR
// if LoadVariable ( KhatamIn07 , debug ) then
2423: LD_STRING KhatamIn07
2425: PPUSH
2426: LD_EXP 1
2430: PPUSH
2431: CALL_OW 30
2435: IFFALSE 2456
// Khatam := PrepareUnit ( Khatam , ( not debug ) ) ;
2437: LD_ADDR_EXP 16
2441: PUSH
2442: LD_STRING Khatam
2444: PPUSH
2445: LD_EXP 1
2449: NOT
2450: PPUSH
2451: CALL 354 0 2
2455: ST_TO_ADDR
// if Khatam then
2456: LD_EXP 16
2460: IFFALSE 2478
// team := team ^ Khatam ;
2462: LD_ADDR_VAR 0 3
2466: PUSH
2467: LD_VAR 0 3
2471: PUSH
2472: LD_EXP 16
2476: ADD
2477: ST_TO_ADDR
// others := CreateCharacterSet ( 07_others ) ;
2478: LD_ADDR_VAR 0 4
2482: PUSH
2483: LD_STRING 07_others
2485: PPUSH
2486: CALL_OW 31
2490: ST_TO_ADDR
// if others then
2491: LD_VAR 0 4
2495: IFFALSE 2513
// team := team ^ others ;
2497: LD_ADDR_VAR 0 3
2501: PUSH
2502: LD_VAR 0 3
2506: PUSH
2507: LD_VAR 0 4
2511: ADD
2512: ST_TO_ADDR
// if debug then
2513: LD_EXP 1
2517: IFFALSE 2591
// begin InitHc ;
2519: CALL_OW 19
// for i = 1 to 4 do
2523: LD_ADDR_VAR 0 2
2527: PUSH
2528: DOUBLE
2529: LD_INT 1
2531: DEC
2532: ST_TO_ADDR
2533: LD_INT 4
2535: PUSH
2536: FOR_TO
2537: IFFALSE 2589
// begin PrepareHuman ( false , [ 1 , 3 ] [ Rand ( 1 , 2 ) ] , 4 ) ;
2539: LD_INT 0
2541: PPUSH
2542: LD_INT 1
2544: PUSH
2545: LD_INT 3
2547: PUSH
2548: EMPTY
2549: LIST
2550: LIST
2551: PUSH
2552: LD_INT 1
2554: PPUSH
2555: LD_INT 2
2557: PPUSH
2558: CALL_OW 12
2562: ARRAY
2563: PPUSH
2564: LD_INT 4
2566: PPUSH
2567: CALL_OW 380
// team := team ^ CreateHuman ;
2571: LD_ADDR_VAR 0 3
2575: PUSH
2576: LD_VAR 0 3
2580: PUSH
2581: CALL_OW 44
2585: ADD
2586: ST_TO_ADDR
// end ;
2587: GO 2536
2589: POP
2590: POP
// end ; m := 0 ;
2591: LD_ADDR_VAR 0 6
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// for i in team do
2599: LD_ADDR_VAR 0 2
2603: PUSH
2604: LD_VAR 0 3
2608: PUSH
2609: FOR_IN
2610: IFFALSE 2790
// if GetClass ( i ) = 3 then
2612: LD_VAR 0 2
2616: PPUSH
2617: CALL_OW 257
2621: PUSH
2622: LD_INT 3
2624: EQUAL
2625: IFFALSE 2773
// begin m := m + 1 ;
2627: LD_ADDR_VAR 0 6
2631: PUSH
2632: LD_VAR 0 6
2636: PUSH
2637: LD_INT 1
2639: PLUS
2640: ST_TO_ADDR
// veh := PrepareTank ( 1 , 1 , [ us_medium_wheeled , us_medium_tracked , us_medium_wheeled , us_light_wheeled ] [ m mod 4 + 1 ] , engine_solar , control_manual , [ us_gatling_gun , us_double_gun , us_light_gun , us_radar ] [ m mod 4 + 1 ] , 60 ) ;
2641: LD_ADDR_VAR 0 5
2645: PUSH
2646: LD_INT 1
2648: PPUSH
2649: LD_INT 1
2651: PPUSH
2652: LD_INT 2
2654: PUSH
2655: LD_INT 3
2657: PUSH
2658: LD_INT 2
2660: PUSH
2661: LD_INT 1
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: LIST
2668: LIST
2669: PUSH
2670: LD_VAR 0 6
2674: PUSH
2675: LD_INT 4
2677: MOD
2678: PUSH
2679: LD_INT 1
2681: PLUS
2682: ARRAY
2683: PPUSH
2684: LD_INT 2
2686: PPUSH
2687: LD_INT 1
2689: PPUSH
2690: LD_INT 4
2692: PUSH
2693: LD_INT 5
2695: PUSH
2696: LD_INT 3
2698: PUSH
2699: LD_INT 11
2701: PUSH
2702: EMPTY
2703: LIST
2704: LIST
2705: LIST
2706: LIST
2707: PUSH
2708: LD_VAR 0 6
2712: PUSH
2713: LD_INT 4
2715: MOD
2716: PUSH
2717: LD_INT 1
2719: PLUS
2720: ARRAY
2721: PPUSH
2722: LD_INT 60
2724: PPUSH
2725: CALL 417 0 7
2729: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2730: LD_VAR 0 5
2734: PPUSH
2735: LD_INT 2
2737: PPUSH
2738: CALL_OW 233
// PlaceUnitArea ( veh , startArea , false ) ;
2742: LD_VAR 0 5
2746: PPUSH
2747: LD_INT 1
2749: PPUSH
2750: LD_INT 0
2752: PPUSH
2753: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2757: LD_VAR 0 2
2761: PPUSH
2762: LD_VAR 0 5
2766: PPUSH
2767: CALL_OW 52
// end else
2771: GO 2788
// PlaceUnitArea ( i , startArea , false ) ;
2773: LD_VAR 0 2
2777: PPUSH
2778: LD_INT 1
2780: PPUSH
2781: LD_INT 0
2783: PPUSH
2784: CALL_OW 49
2788: GO 2609
2790: POP
2791: POP
// uc_side := 4 ;
2792: LD_ADDR_OWVAR 20
2796: PUSH
2797: LD_INT 4
2799: ST_TO_ADDR
// Harisson := PrepareUnit ( Harisson , false ) ;
2800: LD_ADDR_EXP 18
2804: PUSH
2805: LD_STRING Harisson
2807: PPUSH
2808: LD_INT 0
2810: PPUSH
2811: CALL 354 0 2
2815: ST_TO_ADDR
// PrepareScout ;
2816: CALL 2825 0 0
// end ;
2820: LD_VAR 0 1
2824: RET
// function PrepareScout ; var ape ; begin
2825: LD_INT 0
2827: PPUSH
2828: PPUSH
// uc_side := 4 ;
2829: LD_ADDR_OWVAR 20
2833: PUSH
2834: LD_INT 4
2836: ST_TO_ADDR
// uc_nation := 1 ;
2837: LD_ADDR_OWVAR 21
2841: PUSH
2842: LD_INT 1
2844: ST_TO_ADDR
// if LoadVariable ( FrankIn06 , 0 ) then
2845: LD_STRING FrankIn06
2847: PPUSH
2848: LD_INT 0
2850: PPUSH
2851: CALL_OW 30
2855: IFFALSE 2872
// Frank := CreateCharacter ( 06c_Frank ) else
2857: LD_ADDR_EXP 14
2861: PUSH
2862: LD_STRING 06c_Frank
2864: PPUSH
2865: CALL_OW 34
2869: ST_TO_ADDR
2870: GO 2912
// if LoadVariable ( FrankInDelta , 0 ) then
2872: LD_STRING FrankInDelta
2874: PPUSH
2875: LD_INT 0
2877: PPUSH
2878: CALL_OW 30
2882: IFFALSE 2899
// Frank := CreateCharacter ( 05_Frank ) else
2884: LD_ADDR_EXP 14
2888: PUSH
2889: LD_STRING 05_Frank
2891: PPUSH
2892: CALL_OW 34
2896: ST_TO_ADDR
2897: GO 2912
// Frank := CreateCharacter ( 04_Frank ) ;
2899: LD_ADDR_EXP 14
2903: PUSH
2904: LD_STRING 04_Frank
2906: PPUSH
2907: CALL_OW 34
2911: ST_TO_ADDR
// if Frank then
2912: LD_EXP 14
2916: IFFALSE 3037
// begin PlaceUnitArea ( Frank , scoutArea , false ) ;
2918: LD_EXP 14
2922: PPUSH
2923: LD_INT 2
2925: PPUSH
2926: LD_INT 0
2928: PPUSH
2929: CALL_OW 49
// uc_side := 0 ;
2933: LD_ADDR_OWVAR 20
2937: PUSH
2938: LD_INT 0
2940: ST_TO_ADDR
// uc_nation := 0 ;
2941: LD_ADDR_OWVAR 21
2945: PUSH
2946: LD_INT 0
2948: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 0 ) ;
2949: LD_INT 0
2951: PPUSH
2952: LD_INT 12
2954: PPUSH
2955: LD_INT 0
2957: PPUSH
2958: CALL_OW 380
// ape := CreateHuman ;
2962: LD_ADDR_VAR 0 2
2966: PUSH
2967: CALL_OW 44
2971: ST_TO_ADDR
// PlaceUnitXYR ( ape , GetX ( Frank ) , GetY ( Frank ) , 5 , false ) ;
2972: LD_VAR 0 2
2976: PPUSH
2977: LD_EXP 14
2981: PPUSH
2982: CALL_OW 250
2986: PPUSH
2987: LD_EXP 14
2991: PPUSH
2992: CALL_OW 251
2996: PPUSH
2997: LD_INT 5
2999: PPUSH
3000: LD_INT 0
3002: PPUSH
3003: CALL_OW 50
// ComTurnUnit ( ape , Frank ) ;
3007: LD_VAR 0 2
3011: PPUSH
3012: LD_EXP 14
3016: PPUSH
3017: CALL_OW 119
// ComTurnUnit ( Frank , ape ) ;
3021: LD_EXP 14
3025: PPUSH
3026: LD_VAR 0 2
3030: PPUSH
3031: CALL_OW 119
// exit ;
3035: GO 3077
// end ; Kikuchi := PrepareUnit ( Yamoko , false ) ;
3037: LD_ADDR_EXP 17
3041: PUSH
3042: LD_STRING Yamoko
3044: PPUSH
3045: LD_INT 0
3047: PPUSH
3048: CALL 354 0 2
3052: ST_TO_ADDR
// PlaceUnitArea ( Kikuchi , scoutArea , false ) ;
3053: LD_EXP 17
3057: PPUSH
3058: LD_INT 2
3060: PPUSH
3061: LD_INT 0
3063: PPUSH
3064: CALL_OW 49
// ComHold ( Kikuchi ) ;
3068: LD_EXP 17
3072: PPUSH
3073: CALL_OW 140
// end ; end_of_file
3077: LD_VAR 0 1
3081: RET
// export ru_rebuild_list ; export function PrepareRussians ; var i , j , r , un , skill , filter , tmp , dep_list , lab_list , fac_list , breastworks_list , bunker_list , turret_list , weapons_list , personel_counter ; begin
3082: LD_INT 0
3084: PPUSH
3085: PPUSH
3086: PPUSH
3087: PPUSH
3088: PPUSH
3089: PPUSH
3090: PPUSH
3091: PPUSH
3092: PPUSH
3093: PPUSH
3094: PPUSH
3095: PPUSH
3096: PPUSH
3097: PPUSH
3098: PPUSH
3099: PPUSH
// ru_rebuild_list := [ ] ;
3100: LD_ADDR_EXP 19
3104: PUSH
3105: EMPTY
3106: ST_TO_ADDR
// uc_side := 3 ;
3107: LD_ADDR_OWVAR 20
3111: PUSH
3112: LD_INT 3
3114: ST_TO_ADDR
// uc_nation := 3 ;
3115: LD_ADDR_OWVAR 21
3119: PUSH
3120: LD_INT 3
3122: ST_TO_ADDR
// if Difficulty > 1 then
3123: LD_OWVAR 67
3127: PUSH
3128: LD_INT 1
3130: GREATER
3131: IFFALSE 3267
// begin bc_type := b_breastwork ;
3133: LD_ADDR_OWVAR 42
3137: PUSH
3138: LD_INT 31
3140: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 78 , 74 , 2 ) ;
3141: LD_INT 78
3143: PPUSH
3144: LD_INT 74
3146: PPUSH
3147: LD_INT 2
3149: PPUSH
3150: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 171 , 193 , 4 ) ;
3154: LD_INT 171
3156: PPUSH
3157: LD_INT 193
3159: PPUSH
3160: LD_INT 4
3162: PPUSH
3163: CALL_OW 47
// bc_type := b_turret ;
3167: LD_ADDR_OWVAR 42
3171: PUSH
3172: LD_INT 33
3174: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 129 , 96 , 3 ) ;
3175: LD_INT 129
3177: PPUSH
3178: LD_INT 96
3180: PPUSH
3181: LD_INT 3
3183: PPUSH
3184: CALL_OW 47
// if Difficulty > 2 then
3188: LD_OWVAR 67
3192: PUSH
3193: LD_INT 2
3195: GREATER
3196: IFFALSE 3267
// begin RemoveUnit ( HexInfo ( 83 , 141 ) ) ;
3198: LD_INT 83
3200: PPUSH
3201: LD_INT 141
3203: PPUSH
3204: CALL_OW 428
3208: PPUSH
3209: CALL_OW 64
// RemoveUnit ( HexInfo ( 78 , 133 ) ) ;
3213: LD_INT 78
3215: PPUSH
3216: LD_INT 133
3218: PPUSH
3219: CALL_OW 428
3223: PPUSH
3224: CALL_OW 64
// CreateAndPlaceBuildingXYD ( 83 , 141 , 2 ) ;
3228: LD_INT 83
3230: PPUSH
3231: LD_INT 141
3233: PPUSH
3234: LD_INT 2
3236: PPUSH
3237: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 78 , 133 , 2 ) ;
3241: LD_INT 78
3243: PPUSH
3244: LD_INT 133
3246: PPUSH
3247: LD_INT 2
3249: PPUSH
3250: CALL_OW 47
// CreateAndPlaceBuildingXYD ( 145 , 112 , 3 ) ;
3254: LD_INT 145
3256: PPUSH
3257: LD_INT 112
3259: PPUSH
3260: LD_INT 3
3262: PPUSH
3263: CALL_OW 47
// end ; end ; dep_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
3267: LD_ADDR_VAR 0 9
3271: PUSH
3272: LD_INT 22
3274: PUSH
3275: LD_INT 3
3277: PUSH
3278: EMPTY
3279: LIST
3280: LIST
3281: PUSH
3282: LD_INT 2
3284: PUSH
3285: LD_INT 30
3287: PUSH
3288: LD_INT 0
3290: PUSH
3291: EMPTY
3292: LIST
3293: LIST
3294: PUSH
3295: LD_INT 30
3297: PUSH
3298: LD_INT 1
3300: PUSH
3301: EMPTY
3302: LIST
3303: LIST
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: LIST
3309: PUSH
3310: EMPTY
3311: LIST
3312: LIST
3313: PPUSH
3314: CALL_OW 69
3318: ST_TO_ADDR
// lab_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ;
3319: LD_ADDR_VAR 0 10
3323: PUSH
3324: LD_INT 22
3326: PUSH
3327: LD_INT 3
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PUSH
3334: LD_INT 2
3336: PUSH
3337: LD_INT 30
3339: PUSH
3340: LD_INT 6
3342: PUSH
3343: EMPTY
3344: LIST
3345: LIST
3346: PUSH
3347: LD_INT 30
3349: PUSH
3350: LD_INT 7
3352: PUSH
3353: EMPTY
3354: LIST
3355: LIST
3356: PUSH
3357: LD_INT 30
3359: PUSH
3360: LD_INT 8
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: PUSH
3367: EMPTY
3368: LIST
3369: LIST
3370: LIST
3371: LIST
3372: PUSH
3373: EMPTY
3374: LIST
3375: LIST
3376: PPUSH
3377: CALL_OW 69
3381: ST_TO_ADDR
// fac_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) ;
3382: LD_ADDR_VAR 0 11
3386: PUSH
3387: LD_INT 22
3389: PUSH
3390: LD_INT 3
3392: PUSH
3393: EMPTY
3394: LIST
3395: LIST
3396: PUSH
3397: LD_INT 30
3399: PUSH
3400: LD_INT 3
3402: PUSH
3403: EMPTY
3404: LIST
3405: LIST
3406: PUSH
3407: EMPTY
3408: LIST
3409: LIST
3410: PPUSH
3411: CALL_OW 69
3415: ST_TO_ADDR
// breastworks_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
3416: LD_ADDR_VAR 0 12
3420: PUSH
3421: LD_INT 22
3423: PUSH
3424: LD_INT 3
3426: PUSH
3427: EMPTY
3428: LIST
3429: LIST
3430: PUSH
3431: LD_INT 30
3433: PUSH
3434: LD_INT 31
3436: PUSH
3437: EMPTY
3438: LIST
3439: LIST
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: PPUSH
3445: CALL_OW 69
3449: ST_TO_ADDR
// bunker_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
3450: LD_ADDR_VAR 0 13
3454: PUSH
3455: LD_INT 22
3457: PUSH
3458: LD_INT 3
3460: PUSH
3461: EMPTY
3462: LIST
3463: LIST
3464: PUSH
3465: LD_INT 30
3467: PUSH
3468: LD_INT 32
3470: PUSH
3471: EMPTY
3472: LIST
3473: LIST
3474: PUSH
3475: EMPTY
3476: LIST
3477: LIST
3478: PPUSH
3479: CALL_OW 69
3483: ST_TO_ADDR
// turret_list := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_turret ] ] ) ;
3484: LD_ADDR_VAR 0 14
3488: PUSH
3489: LD_INT 22
3491: PUSH
3492: LD_INT 3
3494: PUSH
3495: EMPTY
3496: LIST
3497: LIST
3498: PUSH
3499: LD_INT 30
3501: PUSH
3502: LD_INT 33
3504: PUSH
3505: EMPTY
3506: LIST
3507: LIST
3508: PUSH
3509: EMPTY
3510: LIST
3511: LIST
3512: PPUSH
3513: CALL_OW 69
3517: ST_TO_ADDR
// weapons_list := [ [ ru_heavy_machine_gun , 5 ] , [ ru_gatling_gun , 50 ] , [ ru_gun , 30 ] , [ ru_heavy_gun , 15 ] ] ;
3518: LD_ADDR_VAR 0 15
3522: PUSH
3523: LD_INT 42
3525: PUSH
3526: LD_INT 5
3528: PUSH
3529: EMPTY
3530: LIST
3531: LIST
3532: PUSH
3533: LD_INT 43
3535: PUSH
3536: LD_INT 50
3538: PUSH
3539: EMPTY
3540: LIST
3541: LIST
3542: PUSH
3543: LD_INT 44
3545: PUSH
3546: LD_INT 30
3548: PUSH
3549: EMPTY
3550: LIST
3551: LIST
3552: PUSH
3553: LD_INT 46
3555: PUSH
3556: LD_INT 15
3558: PUSH
3559: EMPTY
3560: LIST
3561: LIST
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: LIST
3567: LIST
3568: ST_TO_ADDR
// personel_counter := [ 0 , 4 , 4 , 3 ] ;
3569: LD_ADDR_VAR 0 16
3573: PUSH
3574: LD_INT 0
3576: PUSH
3577: LD_INT 4
3579: PUSH
3580: LD_INT 4
3582: PUSH
3583: LD_INT 3
3585: PUSH
3586: EMPTY
3587: LIST
3588: LIST
3589: LIST
3590: LIST
3591: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
3592: LD_ADDR_VAR 0 6
3596: PUSH
3597: LD_INT 4
3599: PUSH
3600: LD_INT 5
3602: PUSH
3603: LD_INT 6
3605: PUSH
3606: EMPTY
3607: LIST
3608: LIST
3609: LIST
3610: PUSH
3611: LD_OWVAR 67
3615: ARRAY
3616: ST_TO_ADDR
// SetBName ( ru_dep_main , am_tukh ) ;
3617: LD_INT 16
3619: PPUSH
3620: LD_STRING am_tukh
3622: PPUSH
3623: CALL_OW 500
// for i in FilterAllUnits ( [ f_type , unit_building ] ) do
3627: LD_ADDR_VAR 0 2
3631: PUSH
3632: LD_INT 21
3634: PUSH
3635: LD_INT 3
3637: PUSH
3638: EMPTY
3639: LIST
3640: LIST
3641: PPUSH
3642: CALL_OW 69
3646: PUSH
3647: FOR_IN
3648: IFFALSE 3681
// SetBLevel ( i , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
3650: LD_VAR 0 2
3654: PPUSH
3655: LD_INT 4
3657: PUSH
3658: LD_INT 5
3660: PUSH
3661: LD_INT 6
3663: PUSH
3664: EMPTY
3665: LIST
3666: LIST
3667: LIST
3668: PUSH
3669: LD_OWVAR 67
3673: ARRAY
3674: PPUSH
3675: CALL_OW 241
3679: GO 3647
3681: POP
3682: POP
// for i in dep_list do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: LD_VAR 0 9
3692: PUSH
3693: FOR_IN
3694: IFFALSE 3738
// begin SetResourceType ( GetBase ( i ) , mat_cans , 1000 ) ;
3696: LD_VAR 0 2
3700: PPUSH
3701: CALL_OW 274
3705: PPUSH
3706: LD_INT 1
3708: PPUSH
3709: LD_INT 1000
3711: PPUSH
3712: CALL_OW 277
// SetResourceType ( GetBase ( i ) , mat_oil , 1000 ) ;
3716: LD_VAR 0 2
3720: PPUSH
3721: CALL_OW 274
3725: PPUSH
3726: LD_INT 2
3728: PPUSH
3729: LD_INT 1000
3731: PPUSH
3732: CALL_OW 277
// end ;
3736: GO 3693
3738: POP
3739: POP
// InitHc ;
3740: CALL_OW 19
// tmp := bunker_list * [ 50 , 70 , 85 ] [ Difficulty ] div 100 ;
3744: LD_ADDR_VAR 0 8
3748: PUSH
3749: LD_VAR 0 13
3753: PUSH
3754: LD_INT 50
3756: PUSH
3757: LD_INT 70
3759: PUSH
3760: LD_INT 85
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: LIST
3767: PUSH
3768: LD_OWVAR 67
3772: ARRAY
3773: MUL
3774: PUSH
3775: LD_INT 100
3777: DIV
3778: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , tmp ) ;
3779: LD_ADDR_VAR 0 16
3783: PUSH
3784: LD_VAR 0 16
3788: PPUSH
3789: LD_INT 1
3791: PPUSH
3792: LD_VAR 0 8
3796: PPUSH
3797: CALL_OW 1
3801: ST_TO_ADDR
// tmp := [ ] ;
3802: LD_ADDR_VAR 0 8
3806: PUSH
3807: EMPTY
3808: ST_TO_ADDR
// for i in bunker_list do
3809: LD_ADDR_VAR 0 2
3813: PUSH
3814: LD_VAR 0 13
3818: PUSH
3819: FOR_IN
3820: IFFALSE 3916
// if i mod 10 + 1 < tmp then
3822: LD_VAR 0 2
3826: PUSH
3827: LD_INT 10
3829: MOD
3830: PUSH
3831: LD_INT 1
3833: PLUS
3834: PUSH
3835: LD_VAR 0 8
3839: LESS
3840: IFFALSE 3885
// tmp := Insert ( tmp , i mod rand ( 3 , 5 ) + 1 , i ) else
3842: LD_ADDR_VAR 0 8
3846: PUSH
3847: LD_VAR 0 8
3851: PPUSH
3852: LD_VAR 0 2
3856: PUSH
3857: LD_INT 3
3859: PPUSH
3860: LD_INT 5
3862: PPUSH
3863: CALL_OW 12
3867: MOD
3868: PUSH
3869: LD_INT 1
3871: PLUS
3872: PPUSH
3873: LD_VAR 0 2
3877: PPUSH
3878: CALL_OW 2
3882: ST_TO_ADDR
3883: GO 3914
// tmp := Insert ( tmp , tmp + 1 , i ) ;
3885: LD_ADDR_VAR 0 8
3889: PUSH
3890: LD_VAR 0 8
3894: PPUSH
3895: LD_VAR 0 8
3899: PUSH
3900: LD_INT 1
3902: PLUS
3903: PPUSH
3904: LD_VAR 0 2
3908: PPUSH
3909: CALL_OW 2
3913: ST_TO_ADDR
3914: GO 3819
3916: POP
3917: POP
// bunker_list := tmp ;
3918: LD_ADDR_VAR 0 13
3922: PUSH
3923: LD_VAR 0 8
3927: ST_TO_ADDR
// for i in bunker_list ^ turret_list do
3928: LD_ADDR_VAR 0 2
3932: PUSH
3933: LD_VAR 0 13
3937: PUSH
3938: LD_VAR 0 14
3942: ADD
3943: PUSH
3944: FOR_IN
3945: IFFALSE 4042
// begin tmp := rand ( 0 , 100 ) ;
3947: LD_ADDR_VAR 0 8
3951: PUSH
3952: LD_INT 0
3954: PPUSH
3955: LD_INT 100
3957: PPUSH
3958: CALL_OW 12
3962: ST_TO_ADDR
// r := 0 ;
3963: LD_ADDR_VAR 0 4
3967: PUSH
3968: LD_INT 0
3970: ST_TO_ADDR
// for j in weapons_list do
3971: LD_ADDR_VAR 0 3
3975: PUSH
3976: LD_VAR 0 15
3980: PUSH
3981: FOR_IN
3982: IFFALSE 4038
// begin r := r + j [ 2 ] ;
3984: LD_ADDR_VAR 0 4
3988: PUSH
3989: LD_VAR 0 4
3993: PUSH
3994: LD_VAR 0 3
3998: PUSH
3999: LD_INT 2
4001: ARRAY
4002: PLUS
4003: ST_TO_ADDR
// if r >= tmp then
4004: LD_VAR 0 4
4008: PUSH
4009: LD_VAR 0 8
4013: GREATEREQUAL
4014: IFFALSE 4036
// begin PlaceWeaponTurret ( i , j [ 1 ] ) ;
4016: LD_VAR 0 2
4020: PPUSH
4021: LD_VAR 0 3
4025: PUSH
4026: LD_INT 1
4028: ARRAY
4029: PPUSH
4030: CALL_OW 431
// break ;
4034: GO 4038
// end ; end ;
4036: GO 3981
4038: POP
4039: POP
// end ;
4040: GO 3944
4042: POP
4043: POP
// while ( personel_counter [ 1 ] ) do
4044: LD_VAR 0 16
4048: PUSH
4049: LD_INT 1
4051: ARRAY
4052: IFFALSE 4160
// begin i := rand ( 1 , bunker_list ) ;
4054: LD_ADDR_VAR 0 2
4058: PUSH
4059: LD_INT 1
4061: PPUSH
4062: LD_VAR 0 13
4066: PPUSH
4067: CALL_OW 12
4071: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4072: LD_INT 0
4074: PPUSH
4075: LD_INT 1
4077: PPUSH
4078: LD_VAR 0 6
4082: PPUSH
4083: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , bunker_list [ i ] ) ;
4087: CALL_OW 44
4091: PPUSH
4092: LD_VAR 0 13
4096: PUSH
4097: LD_VAR 0 2
4101: ARRAY
4102: PPUSH
4103: CALL_OW 52
// bunker_list := Delete ( bunker_list , i ) ;
4107: LD_ADDR_VAR 0 13
4111: PUSH
4112: LD_VAR 0 13
4116: PPUSH
4117: LD_VAR 0 2
4121: PPUSH
4122: CALL_OW 3
4126: ST_TO_ADDR
// personel_counter := Replace ( personel_counter , 1 , personel_counter [ 1 ] - 1 ) ;
4127: LD_ADDR_VAR 0 16
4131: PUSH
4132: LD_VAR 0 16
4136: PPUSH
4137: LD_INT 1
4139: PPUSH
4140: LD_VAR 0 16
4144: PUSH
4145: LD_INT 1
4147: ARRAY
4148: PUSH
4149: LD_INT 1
4151: MINUS
4152: PPUSH
4153: CALL_OW 1
4157: ST_TO_ADDR
// end ;
4158: GO 4044
// for i = 1 to personel_counter [ 2 ] do
4160: LD_ADDR_VAR 0 2
4164: PUSH
4165: DOUBLE
4166: LD_INT 1
4168: DEC
4169: ST_TO_ADDR
4170: LD_VAR 0 16
4174: PUSH
4175: LD_INT 2
4177: ARRAY
4178: PUSH
4179: FOR_TO
4180: IFFALSE 4211
// begin PrepareHuman ( false , 2 , skill ) ;
4182: LD_INT 0
4184: PPUSH
4185: LD_INT 2
4187: PPUSH
4188: LD_VAR 0 6
4192: PPUSH
4193: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , ru_dep_main ) ;
4197: CALL_OW 44
4201: PPUSH
4202: LD_INT 16
4204: PPUSH
4205: CALL_OW 52
// end ;
4209: GO 4179
4211: POP
4212: POP
// for i = 1 to personel_counter [ 3 ] do
4213: LD_ADDR_VAR 0 2
4217: PUSH
4218: DOUBLE
4219: LD_INT 1
4221: DEC
4222: ST_TO_ADDR
4223: LD_VAR 0 16
4227: PUSH
4228: LD_INT 3
4230: ARRAY
4231: PUSH
4232: FOR_TO
4233: IFFALSE 4270
// begin PrepareHuman ( false , 3 , skill ) ;
4235: LD_INT 0
4237: PPUSH
4238: LD_INT 3
4240: PPUSH
4241: LD_VAR 0 6
4245: PPUSH
4246: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , fac_list [ 1 ] ) ;
4250: CALL_OW 44
4254: PPUSH
4255: LD_VAR 0 11
4259: PUSH
4260: LD_INT 1
4262: ARRAY
4263: PPUSH
4264: CALL_OW 52
// end ;
4268: GO 4232
4270: POP
4271: POP
// for i = 1 to personel_counter [ 4 ] do
4272: LD_ADDR_VAR 0 2
4276: PUSH
4277: DOUBLE
4278: LD_INT 1
4280: DEC
4281: ST_TO_ADDR
4282: LD_VAR 0 16
4286: PUSH
4287: LD_INT 4
4289: ARRAY
4290: PUSH
4291: FOR_TO
4292: IFFALSE 4329
// begin PrepareHuman ( false , 4 , skill ) ;
4294: LD_INT 0
4296: PPUSH
4297: LD_INT 4
4299: PPUSH
4300: LD_VAR 0 6
4304: PPUSH
4305: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , lab_list [ 1 ] ) ;
4309: CALL_OW 44
4313: PPUSH
4314: LD_VAR 0 10
4318: PUSH
4319: LD_INT 1
4321: ARRAY
4322: PPUSH
4323: CALL_OW 52
// end ;
4327: GO 4291
4329: POP
4330: POP
// for i in breastworks_list do
4331: LD_ADDR_VAR 0 2
4335: PUSH
4336: LD_VAR 0 12
4340: PUSH
4341: FOR_IN
4342: IFFALSE 4454
// begin r := GetDir ( i ) ;
4344: LD_ADDR_VAR 0 4
4348: PUSH
4349: LD_VAR 0 2
4353: PPUSH
4354: CALL_OW 254
4358: ST_TO_ADDR
// if r > 3 then
4359: LD_VAR 0 4
4363: PUSH
4364: LD_INT 3
4366: GREATER
4367: IFFALSE 4385
// r := r - 3 else
4369: LD_ADDR_VAR 0 4
4373: PUSH
4374: LD_VAR 0 4
4378: PUSH
4379: LD_INT 3
4381: MINUS
4382: ST_TO_ADDR
4383: GO 4399
// r := r + 3 ;
4385: LD_ADDR_VAR 0 4
4389: PUSH
4390: LD_VAR 0 4
4394: PUSH
4395: LD_INT 3
4397: PLUS
4398: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
4399: LD_INT 0
4401: PPUSH
4402: LD_INT 1
4404: PPUSH
4405: LD_VAR 0 6
4409: PPUSH
4410: CALL_OW 380
// un := CreateHuman ;
4414: LD_ADDR_VAR 0 5
4418: PUSH
4419: CALL_OW 44
4423: ST_TO_ADDR
// SetDir ( un , r ) ;
4424: LD_VAR 0 5
4428: PPUSH
4429: LD_VAR 0 4
4433: PPUSH
4434: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
4438: LD_VAR 0 5
4442: PPUSH
4443: LD_VAR 0 2
4447: PPUSH
4448: CALL_OW 52
// end ;
4452: GO 4341
4454: POP
4455: POP
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) ;
4456: LD_ADDR_VAR 0 8
4460: PUSH
4461: LD_INT 22
4463: PUSH
4464: LD_INT 3
4466: PUSH
4467: EMPTY
4468: LIST
4469: LIST
4470: PUSH
4471: LD_INT 25
4473: PUSH
4474: LD_INT 3
4476: PUSH
4477: EMPTY
4478: LIST
4479: LIST
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: PPUSH
4485: CALL_OW 69
4489: ST_TO_ADDR
// r := [ 4 , 5 , 6 ] [ Difficulty ] ;
4490: LD_ADDR_VAR 0 4
4494: PUSH
4495: LD_INT 4
4497: PUSH
4498: LD_INT 5
4500: PUSH
4501: LD_INT 6
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: LIST
4508: PUSH
4509: LD_OWVAR 67
4513: ARRAY
4514: ST_TO_ADDR
// for i = 1 to r do
4515: LD_ADDR_VAR 0 2
4519: PUSH
4520: DOUBLE
4521: LD_INT 1
4523: DEC
4524: ST_TO_ADDR
4525: LD_VAR 0 4
4529: PUSH
4530: FOR_TO
4531: IFFALSE 4675
// begin un := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 100 ) ;
4533: LD_ADDR_VAR 0 5
4537: PUSH
4538: LD_INT 3
4540: PPUSH
4541: LD_INT 3
4543: PPUSH
4544: LD_INT 22
4546: PPUSH
4547: LD_INT 1
4549: PPUSH
4550: LD_INT 1
4552: PPUSH
4553: LD_INT 43
4555: PUSH
4556: LD_INT 44
4558: PUSH
4559: LD_INT 42
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: LIST
4566: PUSH
4567: LD_VAR 0 2
4571: PUSH
4572: LD_INT 3
4574: MOD
4575: PUSH
4576: LD_INT 1
4578: PLUS
4579: ARRAY
4580: PPUSH
4581: LD_INT 100
4583: PPUSH
4584: CALL 417 0 7
4588: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4589: LD_VAR 0 5
4593: PPUSH
4594: LD_INT 0
4596: PPUSH
4597: LD_INT 5
4599: PPUSH
4600: CALL_OW 12
4604: PPUSH
4605: CALL_OW 233
// PlaceUnitArea ( un , parkingArea , false ) ;
4609: LD_VAR 0 5
4613: PPUSH
4614: LD_INT 5
4616: PPUSH
4617: LD_INT 0
4619: PPUSH
4620: CALL_OW 49
// if i > tmp then
4624: LD_VAR 0 2
4628: PUSH
4629: LD_VAR 0 8
4633: GREATER
4634: IFFALSE 4638
// continue ;
4636: GO 4530
// ComExitBuilding ( tmp [ i ] ) ;
4638: LD_VAR 0 8
4642: PUSH
4643: LD_VAR 0 2
4647: ARRAY
4648: PPUSH
4649: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , un ) ;
4653: LD_VAR 0 8
4657: PUSH
4658: LD_VAR 0 2
4662: ARRAY
4663: PPUSH
4664: LD_VAR 0 5
4668: PPUSH
4669: CALL_OW 180
// end ;
4673: GO 4530
4675: POP
4676: POP
// end ;
4677: LD_VAR 0 1
4681: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_ok ] ] ) do var i , filter , tmp , engs , enemy ;
4682: LD_INT 22
4684: PUSH
4685: LD_INT 3
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: PUSH
4692: LD_INT 25
4694: PUSH
4695: LD_INT 2
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PUSH
4702: LD_INT 50
4704: PUSH
4705: EMPTY
4706: LIST
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: LIST
4712: PPUSH
4713: CALL_OW 69
4717: IFFALSE 5413
4719: GO 4721
4721: DISABLE
4722: LD_INT 0
4724: PPUSH
4725: PPUSH
4726: PPUSH
4727: PPUSH
4728: PPUSH
// begin enable ;
4729: ENABLE
// filter := FilterUnitsInArea ( baseArea , [ [ f_not , [ f_lives , 1000 ] ] , [ f_type , unit_building ] ] ) ;
4730: LD_ADDR_VAR 0 2
4734: PUSH
4735: LD_INT 6
4737: PPUSH
4738: LD_INT 3
4740: PUSH
4741: LD_INT 24
4743: PUSH
4744: LD_INT 1000
4746: PUSH
4747: EMPTY
4748: LIST
4749: LIST
4750: PUSH
4751: EMPTY
4752: LIST
4753: LIST
4754: PUSH
4755: LD_INT 21
4757: PUSH
4758: LD_INT 3
4760: PUSH
4761: EMPTY
4762: LIST
4763: LIST
4764: PUSH
4765: EMPTY
4766: LIST
4767: LIST
4768: PPUSH
4769: CALL_OW 70
4773: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 2 ] , [ f_lives , 650 ] ] ) ;
4774: LD_ADDR_VAR 0 4
4778: PUSH
4779: LD_INT 22
4781: PUSH
4782: LD_INT 3
4784: PUSH
4785: EMPTY
4786: LIST
4787: LIST
4788: PUSH
4789: LD_INT 25
4791: PUSH
4792: LD_INT 2
4794: PUSH
4795: EMPTY
4796: LIST
4797: LIST
4798: PUSH
4799: LD_INT 24
4801: PUSH
4802: LD_INT 650
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: PUSH
4809: EMPTY
4810: LIST
4811: LIST
4812: LIST
4813: PPUSH
4814: CALL_OW 69
4818: ST_TO_ADDR
// if not filter and not ru_rebuild_list then
4819: LD_VAR 0 2
4823: NOT
4824: PUSH
4825: LD_EXP 19
4829: NOT
4830: AND
4831: IFFALSE 4863
// begin if not IsInUnit ( engs [ 1 ] ) then
4833: LD_VAR 0 4
4837: PUSH
4838: LD_INT 1
4840: ARRAY
4841: PPUSH
4842: CALL_OW 310
4846: NOT
4847: IFFALSE 4861
// ComEnterUnit ( engs , ru_dep_main ) ;
4849: LD_VAR 0 4
4853: PPUSH
4854: LD_INT 16
4856: PPUSH
4857: CALL_OW 120
// exit ;
4861: GO 5413
// end ; if debug then
4863: LD_EXP 1
4867: IFFALSE 4888
// display_strings := [ engs , filter ] ;
4869: LD_ADDR_OWVAR 47
4873: PUSH
4874: LD_VAR 0 4
4878: PUSH
4879: LD_VAR 0 2
4883: PUSH
4884: EMPTY
4885: LIST
4886: LIST
4887: ST_TO_ADDR
// if UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) then
4888: LD_VAR 0 4
4892: PPUSH
4893: LD_INT 3
4895: PUSH
4896: LD_INT 24
4898: PUSH
4899: LD_INT 650
4901: PUSH
4902: EMPTY
4903: LIST
4904: LIST
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: PPUSH
4910: CALL_OW 72
4914: IFFALSE 5007
// begin tmp := UnitFilter ( engs , [ f_not , [ f_lives , 650 ] ] ) ;
4916: LD_ADDR_VAR 0 3
4920: PUSH
4921: LD_VAR 0 4
4925: PPUSH
4926: LD_INT 3
4928: PUSH
4929: LD_INT 24
4931: PUSH
4932: LD_INT 650
4934: PUSH
4935: EMPTY
4936: LIST
4937: LIST
4938: PUSH
4939: EMPTY
4940: LIST
4941: LIST
4942: PPUSH
4943: CALL_OW 72
4947: ST_TO_ADDR
// for i in tmp do
4948: LD_ADDR_VAR 0 1
4952: PUSH
4953: LD_VAR 0 3
4957: PUSH
4958: FOR_IN
4959: IFFALSE 5005
// if not IsInArea ( i , mainBaseArea ) then
4961: LD_VAR 0 1
4965: PPUSH
4966: LD_INT 14
4968: PPUSH
4969: CALL_OW 308
4973: NOT
4974: IFFALSE 5003
// begin ComMoveXY ( i , 129 , 125 ) ;
4976: LD_VAR 0 1
4980: PPUSH
4981: LD_INT 129
4983: PPUSH
4984: LD_INT 125
4986: PPUSH
4987: CALL_OW 111
// AddComWait ( i , 0 0$30 ) ;
4991: LD_VAR 0 1
4995: PPUSH
4996: LD_INT 1050
4998: PPUSH
4999: CALL_OW 202
// end ;
5003: GO 4958
5005: POP
5006: POP
// end ; if filter then
5007: LD_VAR 0 2
5011: IFFALSE 5270
// begin for i in engs do
5013: LD_ADDR_VAR 0 1
5017: PUSH
5018: LD_VAR 0 4
5022: PUSH
5023: FOR_IN
5024: IFFALSE 5048
// if IsInUnit ( i ) then
5026: LD_VAR 0 1
5030: PPUSH
5031: CALL_OW 310
5035: IFFALSE 5046
// ComExitBuilding ( i ) ;
5037: LD_VAR 0 1
5041: PPUSH
5042: CALL_OW 122
5046: GO 5023
5048: POP
5049: POP
// wait ( 3 ) ;
5050: LD_INT 3
5052: PPUSH
5053: CALL_OW 67
// if filter >= 2 and engs >= 2 then
5057: LD_VAR 0 2
5061: PUSH
5062: LD_INT 2
5064: GREATEREQUAL
5065: PUSH
5066: LD_VAR 0 4
5070: PUSH
5071: LD_INT 2
5073: GREATEREQUAL
5074: AND
5075: IFFALSE 5223
// begin for i = 1 to engs / 2 do
5077: LD_ADDR_VAR 0 1
5081: PUSH
5082: DOUBLE
5083: LD_INT 1
5085: DEC
5086: ST_TO_ADDR
5087: LD_VAR 0 4
5091: PUSH
5092: LD_INT 2
5094: DIVREAL
5095: PUSH
5096: FOR_TO
5097: IFFALSE 5143
// if not HasTask ( engs [ i ] ) then
5099: LD_VAR 0 4
5103: PUSH
5104: LD_VAR 0 1
5108: ARRAY
5109: PPUSH
5110: CALL_OW 314
5114: NOT
5115: IFFALSE 5141
// ComRepairBuilding ( engs [ i ] , filter [ 1 ] ) ;
5117: LD_VAR 0 4
5121: PUSH
5122: LD_VAR 0 1
5126: ARRAY
5127: PPUSH
5128: LD_VAR 0 2
5132: PUSH
5133: LD_INT 1
5135: ARRAY
5136: PPUSH
5137: CALL_OW 130
5141: GO 5096
5143: POP
5144: POP
// for i = engs / 2 + 1 to engs do
5145: LD_ADDR_VAR 0 1
5149: PUSH
5150: DOUBLE
5151: LD_VAR 0 4
5155: PUSH
5156: LD_INT 2
5158: DIVREAL
5159: PUSH
5160: LD_INT 1
5162: PLUS
5163: DEC
5164: ST_TO_ADDR
5165: LD_VAR 0 4
5169: PUSH
5170: FOR_TO
5171: IFFALSE 5219
// if not HasTask ( engs [ i ] ) then
5173: LD_VAR 0 4
5177: PUSH
5178: LD_VAR 0 1
5182: ARRAY
5183: PPUSH
5184: CALL_OW 314
5188: NOT
5189: IFFALSE 5217
// ComRepairBuilding ( engs [ i ] , filter [ filter ] ) ;
5191: LD_VAR 0 4
5195: PUSH
5196: LD_VAR 0 1
5200: ARRAY
5201: PPUSH
5202: LD_VAR 0 2
5206: PUSH
5207: LD_VAR 0 2
5211: ARRAY
5212: PPUSH
5213: CALL_OW 130
5217: GO 5170
5219: POP
5220: POP
// end else
5221: GO 5270
// for i in engs do
5223: LD_ADDR_VAR 0 1
5227: PUSH
5228: LD_VAR 0 4
5232: PUSH
5233: FOR_IN
5234: IFFALSE 5268
// if not HasTask ( i ) then
5236: LD_VAR 0 1
5240: PPUSH
5241: CALL_OW 314
5245: NOT
5246: IFFALSE 5266
// ComRepairBuilding ( i , filter [ 1 ] ) ;
5248: LD_VAR 0 1
5252: PPUSH
5253: LD_VAR 0 2
5257: PUSH
5258: LD_INT 1
5260: ARRAY
5261: PPUSH
5262: CALL_OW 130
5266: GO 5233
5268: POP
5269: POP
// end ; enemy := FilterAllUnits ( [ f_enemy , 3 ] ) ;
5270: LD_ADDR_VAR 0 5
5274: PUSH
5275: LD_INT 81
5277: PUSH
5278: LD_INT 3
5280: PUSH
5281: EMPTY
5282: LIST
5283: LIST
5284: PPUSH
5285: CALL_OW 69
5289: ST_TO_ADDR
// if ru_rebuild_list and not filter then
5290: LD_EXP 19
5294: PUSH
5295: LD_VAR 0 2
5299: NOT
5300: AND
5301: IFFALSE 5413
// begin ComExitBuilding ( engs ) ;
5303: LD_VAR 0 4
5307: PPUSH
5308: CALL_OW 122
// if GetDistUnitXY ( NearestUnitToXY ( enemy , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] ) > 10 then
5312: LD_VAR 0 5
5316: PPUSH
5317: LD_EXP 19
5321: PUSH
5322: LD_INT 2
5324: ARRAY
5325: PPUSH
5326: LD_EXP 19
5330: PUSH
5331: LD_INT 3
5333: ARRAY
5334: PPUSH
5335: CALL_OW 73
5339: PPUSH
5340: LD_EXP 19
5344: PUSH
5345: LD_INT 2
5347: ARRAY
5348: PPUSH
5349: LD_EXP 19
5353: PUSH
5354: LD_INT 3
5356: ARRAY
5357: PPUSH
5358: CALL_OW 297
5362: PUSH
5363: LD_INT 10
5365: GREATER
5366: IFFALSE 5413
// ComBuild ( engs , ru_rebuild_list [ 1 ] , ru_rebuild_list [ 2 ] , ru_rebuild_list [ 3 ] , ru_rebuild_list [ 4 ] ) ;
5368: LD_VAR 0 4
5372: PPUSH
5373: LD_EXP 19
5377: PUSH
5378: LD_INT 1
5380: ARRAY
5381: PPUSH
5382: LD_EXP 19
5386: PUSH
5387: LD_INT 2
5389: ARRAY
5390: PPUSH
5391: LD_EXP 19
5395: PUSH
5396: LD_INT 3
5398: ARRAY
5399: PPUSH
5400: LD_EXP 19
5404: PUSH
5405: LD_INT 4
5407: ARRAY
5408: PPUSH
5409: CALL_OW 145
// end ; end ;
5413: PPOPN 5
5415: END
// every 0 0$1 trigger GetLives ( ru_dep_main ) < 650 do var tmp ;
5416: LD_INT 16
5418: PPUSH
5419: CALL_OW 256
5423: PUSH
5424: LD_INT 650
5426: LESS
5427: IFFALSE 5510
5429: GO 5431
5431: DISABLE
5432: LD_INT 0
5434: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 1 ] ] ) ;
5435: LD_ADDR_VAR 0 1
5439: PUSH
5440: LD_INT 22
5442: PUSH
5443: LD_INT 3
5445: PUSH
5446: EMPTY
5447: LIST
5448: LIST
5449: PUSH
5450: LD_INT 25
5452: PUSH
5453: LD_INT 1
5455: PUSH
5456: EMPTY
5457: LIST
5458: LIST
5459: PUSH
5460: EMPTY
5461: LIST
5462: LIST
5463: PPUSH
5464: CALL_OW 69
5468: ST_TO_ADDR
// ComExitBuilding ( tmp ) ;
5469: LD_VAR 0 1
5473: PPUSH
5474: CALL_OW 122
// wait ( 3 ) ;
5478: LD_INT 3
5480: PPUSH
5481: CALL_OW 67
// ComAgressiveMove ( tmp , GetX ( ru_dep_main ) , GetY ( ru_dep_main ) ) ;
5485: LD_VAR 0 1
5489: PPUSH
5490: LD_INT 16
5492: PPUSH
5493: CALL_OW 250
5497: PPUSH
5498: LD_INT 16
5500: PPUSH
5501: CALL_OW 251
5505: PPUSH
5506: CALL_OW 114
// end ;
5510: PPOPN 1
5512: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) do var i , tmp , doc ;
5513: LD_INT 22
5515: PUSH
5516: LD_INT 3
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PUSH
5523: LD_INT 25
5525: PUSH
5526: LD_INT 4
5528: PUSH
5529: EMPTY
5530: LIST
5531: LIST
5532: PUSH
5533: EMPTY
5534: LIST
5535: LIST
5536: PPUSH
5537: CALL_OW 69
5541: IFFALSE 5795
5543: GO 5545
5545: DISABLE
5546: LD_INT 0
5548: PPUSH
5549: PPUSH
5550: PPUSH
// begin enable ;
5551: ENABLE
// tmp := FilterUnitsInArea ( mainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5552: LD_ADDR_VAR 0 2
5556: PUSH
5557: LD_INT 14
5559: PPUSH
5560: LD_INT 22
5562: PUSH
5563: LD_INT 3
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PUSH
5570: LD_INT 21
5572: PUSH
5573: LD_INT 1
5575: PUSH
5576: EMPTY
5577: LIST
5578: LIST
5579: PUSH
5580: LD_INT 3
5582: PUSH
5583: LD_INT 24
5585: PUSH
5586: LD_INT 1000
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: EMPTY
5594: LIST
5595: LIST
5596: PUSH
5597: EMPTY
5598: LIST
5599: LIST
5600: LIST
5601: PPUSH
5602: CALL_OW 70
5606: ST_TO_ADDR
// doc := FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 4 ] ] ) ;
5607: LD_ADDR_VAR 0 3
5611: PUSH
5612: LD_INT 22
5614: PUSH
5615: LD_INT 3
5617: PUSH
5618: EMPTY
5619: LIST
5620: LIST
5621: PUSH
5622: LD_INT 25
5624: PUSH
5625: LD_INT 4
5627: PUSH
5628: EMPTY
5629: LIST
5630: LIST
5631: PUSH
5632: EMPTY
5633: LIST
5634: LIST
5635: PPUSH
5636: CALL_OW 69
5640: ST_TO_ADDR
// if not doc then
5641: LD_VAR 0 3
5645: NOT
5646: IFFALSE 5650
// exit ;
5648: GO 5795
// if not tmp then
5650: LD_VAR 0 2
5654: NOT
5655: IFFALSE 5746
// begin if not IsInUnit ( doc [ 1 ] ) then
5657: LD_VAR 0 3
5661: PUSH
5662: LD_INT 1
5664: ARRAY
5665: PPUSH
5666: CALL_OW 310
5670: NOT
5671: IFFALSE 5744
// ComEnterUnit ( doc , FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) [ 1 ] ) ;
5673: LD_VAR 0 3
5677: PPUSH
5678: LD_INT 22
5680: PUSH
5681: LD_INT 3
5683: PUSH
5684: EMPTY
5685: LIST
5686: LIST
5687: PUSH
5688: LD_INT 2
5690: PUSH
5691: LD_INT 30
5693: PUSH
5694: LD_INT 6
5696: PUSH
5697: EMPTY
5698: LIST
5699: LIST
5700: PUSH
5701: LD_INT 30
5703: PUSH
5704: LD_INT 7
5706: PUSH
5707: EMPTY
5708: LIST
5709: LIST
5710: PUSH
5711: LD_INT 30
5713: PUSH
5714: LD_INT 8
5716: PUSH
5717: EMPTY
5718: LIST
5719: LIST
5720: PUSH
5721: EMPTY
5722: LIST
5723: LIST
5724: LIST
5725: LIST
5726: PUSH
5727: EMPTY
5728: LIST
5729: LIST
5730: PPUSH
5731: CALL_OW 69
5735: PUSH
5736: LD_INT 1
5738: ARRAY
5739: PPUSH
5740: CALL_OW 120
// exit ;
5744: GO 5795
// end ; if IsInUnit ( doc [ 1 ] ) then
5746: LD_VAR 0 3
5750: PUSH
5751: LD_INT 1
5753: ARRAY
5754: PPUSH
5755: CALL_OW 310
5759: IFFALSE 5770
// ComExitBuilding ( doc ) ;
5761: LD_VAR 0 3
5765: PPUSH
5766: CALL_OW 122
// wait ( 3 ) ;
5770: LD_INT 3
5772: PPUSH
5773: CALL_OW 67
// ComHeal ( doc , tmp [ 1 ] ) ;
5777: LD_VAR 0 3
5781: PPUSH
5782: LD_VAR 0 2
5786: PUSH
5787: LD_INT 1
5789: ARRAY
5790: PPUSH
5791: CALL_OW 128
// end ;
5795: PPOPN 3
5797: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] ] ) do var i , tmp , areas , area ;
5798: LD_INT 22
5800: PUSH
5801: LD_INT 3
5803: PUSH
5804: EMPTY
5805: LIST
5806: LIST
5807: PUSH
5808: LD_INT 25
5810: PUSH
5811: LD_INT 3
5813: PUSH
5814: EMPTY
5815: LIST
5816: LIST
5817: PUSH
5818: EMPTY
5819: LIST
5820: LIST
5821: PPUSH
5822: CALL_OW 69
5826: PUSH
5827: LD_INT 22
5829: PUSH
5830: LD_INT 3
5832: PUSH
5833: EMPTY
5834: LIST
5835: LIST
5836: PUSH
5837: LD_INT 21
5839: PUSH
5840: LD_INT 2
5842: PUSH
5843: EMPTY
5844: LIST
5845: LIST
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: PPUSH
5851: CALL_OW 69
5855: AND
5856: IFFALSE 6078
5858: GO 5860
5860: DISABLE
5861: LD_INT 0
5863: PPUSH
5864: PPUSH
5865: PPUSH
5866: PPUSH
// begin enable ;
5867: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_empty ] ] ] ) ;
5868: LD_ADDR_VAR 0 2
5872: PUSH
5873: LD_INT 22
5875: PUSH
5876: LD_INT 3
5878: PUSH
5879: EMPTY
5880: LIST
5881: LIST
5882: PUSH
5883: LD_INT 21
5885: PUSH
5886: LD_INT 2
5888: PUSH
5889: EMPTY
5890: LIST
5891: LIST
5892: PUSH
5893: LD_INT 3
5895: PUSH
5896: LD_INT 58
5898: PUSH
5899: EMPTY
5900: LIST
5901: PUSH
5902: EMPTY
5903: LIST
5904: LIST
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: LIST
5910: PPUSH
5911: CALL_OW 69
5915: ST_TO_ADDR
// areas := [ sectorAlpha , sectorBeta , sectorDelta , mainBaseArea ] ;
5916: LD_ADDR_VAR 0 3
5920: PUSH
5921: LD_INT 10
5923: PUSH
5924: LD_INT 11
5926: PUSH
5927: LD_INT 12
5929: PUSH
5930: LD_INT 14
5932: PUSH
5933: EMPTY
5934: LIST
5935: LIST
5936: LIST
5937: LIST
5938: ST_TO_ADDR
// area := 0 ;
5939: LD_ADDR_VAR 0 4
5943: PUSH
5944: LD_INT 0
5946: ST_TO_ADDR
// for i in areas do
5947: LD_ADDR_VAR 0 1
5951: PUSH
5952: LD_VAR 0 3
5956: PUSH
5957: FOR_IN
5958: IFFALSE 5995
// if FilterUnitsInArea ( i , [ f_side , 1 ] ) then
5960: LD_VAR 0 1
5964: PPUSH
5965: LD_INT 22
5967: PUSH
5968: LD_INT 1
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: PPUSH
5975: CALL_OW 70
5979: IFFALSE 5993
// begin area := i ;
5981: LD_ADDR_VAR 0 4
5985: PUSH
5986: LD_VAR 0 1
5990: ST_TO_ADDR
// break ;
5991: GO 5995
// end ;
5993: GO 5957
5995: POP
5996: POP
// if area then
5997: LD_VAR 0 4
6001: IFFALSE 6078
// begin for i in tmp do
6003: LD_ADDR_VAR 0 1
6007: PUSH
6008: LD_VAR 0 2
6012: PUSH
6013: FOR_IN
6014: IFFALSE 6076
// begin if GetFuel ( i ) < 33 then
6016: LD_VAR 0 1
6020: PPUSH
6021: CALL_OW 261
6025: PUSH
6026: LD_INT 33
6028: LESS
6029: IFFALSE 6043
// SetFuel ( i , 33 ) ;
6031: LD_VAR 0 1
6035: PPUSH
6036: LD_INT 33
6038: PPUSH
6039: CALL_OW 240
// if not IsInArea ( i , area ) then
6043: LD_VAR 0 1
6047: PPUSH
6048: LD_VAR 0 4
6052: PPUSH
6053: CALL_OW 308
6057: NOT
6058: IFFALSE 6074
// ComMoveToArea ( i , area ) ;
6060: LD_VAR 0 1
6064: PPUSH
6065: LD_VAR 0 4
6069: PPUSH
6070: CALL_OW 113
// end ;
6074: GO 6013
6076: POP
6077: POP
// end ; end ;
6078: PPOPN 4
6080: END
// every 10 10$00 do var i , j , un , veh , time , count ;
6081: GO 6083
6083: DISABLE
6084: LD_INT 0
6086: PPUSH
6087: PPUSH
6088: PPUSH
6089: PPUSH
6090: PPUSH
6091: PPUSH
// begin uc_side := 3 ;
6092: LD_ADDR_OWVAR 20
6096: PUSH
6097: LD_INT 3
6099: ST_TO_ADDR
// uc_nation := 3 ;
6100: LD_ADDR_OWVAR 21
6104: PUSH
6105: LD_INT 3
6107: ST_TO_ADDR
// time := [ 6 6$00 , 5 5$00 , 4 4$00 ] [ Difficulty ] ;
6108: LD_ADDR_VAR 0 5
6112: PUSH
6113: LD_INT 12600
6115: PUSH
6116: LD_INT 10500
6118: PUSH
6119: LD_INT 8400
6121: PUSH
6122: EMPTY
6123: LIST
6124: LIST
6125: LIST
6126: PUSH
6127: LD_OWVAR 67
6131: ARRAY
6132: ST_TO_ADDR
// count := [ 3 , 4 , 5 ] [ Difficulty ] ;
6133: LD_ADDR_VAR 0 6
6137: PUSH
6138: LD_INT 3
6140: PUSH
6141: LD_INT 4
6143: PUSH
6144: LD_INT 5
6146: PUSH
6147: EMPTY
6148: LIST
6149: LIST
6150: LIST
6151: PUSH
6152: LD_OWVAR 67
6156: ARRAY
6157: ST_TO_ADDR
// for i = 1 to count do
6158: LD_ADDR_VAR 0 1
6162: PUSH
6163: DOUBLE
6164: LD_INT 1
6166: DEC
6167: ST_TO_ADDR
6168: LD_VAR 0 6
6172: PUSH
6173: FOR_TO
6174: IFFALSE 6469
// begin wait ( time ) ;
6176: LD_VAR 0 5
6180: PPUSH
6181: CALL_OW 67
// for j = 1 to rand ( 1 , Difficulty ) do
6185: LD_ADDR_VAR 0 2
6189: PUSH
6190: DOUBLE
6191: LD_INT 1
6193: DEC
6194: ST_TO_ADDR
6195: LD_INT 1
6197: PPUSH
6198: LD_OWVAR 67
6202: PPUSH
6203: CALL_OW 12
6207: PUSH
6208: FOR_TO
6209: IFFALSE 6350
// begin veh := PrepareTank ( 3 , 3 , ru_medium_tracked , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun , ru_heavy_machine_gun ] [ i mod 3 + 1 ] , 80 ) ;
6211: LD_ADDR_VAR 0 4
6215: PUSH
6216: LD_INT 3
6218: PPUSH
6219: LD_INT 3
6221: PPUSH
6222: LD_INT 22
6224: PPUSH
6225: LD_INT 1
6227: PPUSH
6228: LD_INT 1
6230: PPUSH
6231: LD_INT 43
6233: PUSH
6234: LD_INT 44
6236: PUSH
6237: LD_INT 42
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: LIST
6244: PUSH
6245: LD_VAR 0 1
6249: PUSH
6250: LD_INT 3
6252: MOD
6253: PUSH
6254: LD_INT 1
6256: PLUS
6257: ARRAY
6258: PPUSH
6259: LD_INT 80
6261: PPUSH
6262: CALL 417 0 7
6266: ST_TO_ADDR
// PlaceUnitArea ( veh , southArea , false ) ;
6267: LD_VAR 0 4
6271: PPUSH
6272: LD_INT 13
6274: PPUSH
6275: LD_INT 0
6277: PPUSH
6278: CALL_OW 49
// PrepareHuman ( false , 3 , [ 4 , 5 , 5 ] [ Difficulty ] ) ;
6282: LD_INT 0
6284: PPUSH
6285: LD_INT 3
6287: PPUSH
6288: LD_INT 4
6290: PUSH
6291: LD_INT 5
6293: PUSH
6294: LD_INT 5
6296: PUSH
6297: EMPTY
6298: LIST
6299: LIST
6300: LIST
6301: PUSH
6302: LD_OWVAR 67
6306: ARRAY
6307: PPUSH
6308: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6312: CALL_OW 44
6316: PPUSH
6317: LD_VAR 0 4
6321: PPUSH
6322: CALL_OW 52
// wait ( 0 0$01 ) ;
6326: LD_INT 35
6328: PPUSH
6329: CALL_OW 67
// ComMoveXY ( veh , 143 , 143 ) ;
6333: LD_VAR 0 4
6337: PPUSH
6338: LD_INT 143
6340: PPUSH
6341: LD_INT 143
6343: PPUSH
6344: CALL_OW 111
// end ;
6348: GO 6208
6350: POP
6351: POP
// if count < 3 then
6352: LD_VAR 0 6
6356: PUSH
6357: LD_INT 3
6359: LESS
6360: IFFALSE 6364
// continue ;
6362: GO 6173
// for j = 1 to 1 + Difficulty do
6364: LD_ADDR_VAR 0 2
6368: PUSH
6369: DOUBLE
6370: LD_INT 1
6372: DEC
6373: ST_TO_ADDR
6374: LD_INT 1
6376: PUSH
6377: LD_OWVAR 67
6381: PLUS
6382: PUSH
6383: FOR_TO
6384: IFFALSE 6465
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
6386: LD_INT 0
6388: PPUSH
6389: LD_INT 1
6391: PPUSH
6392: LD_INT 4
6394: PUSH
6395: LD_INT 5
6397: PUSH
6398: LD_INT 6
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: LIST
6405: PUSH
6406: LD_OWVAR 67
6410: ARRAY
6411: PPUSH
6412: CALL_OW 380
// un := CreateHuman ;
6416: LD_ADDR_VAR 0 3
6420: PUSH
6421: CALL_OW 44
6425: ST_TO_ADDR
// PlaceUnitArea ( un , southArea , false ) ;
6426: LD_VAR 0 3
6430: PPUSH
6431: LD_INT 13
6433: PPUSH
6434: LD_INT 0
6436: PPUSH
6437: CALL_OW 49
// ComMoveXY ( un , 143 , 143 ) ;
6441: LD_VAR 0 3
6445: PPUSH
6446: LD_INT 143
6448: PPUSH
6449: LD_INT 143
6451: PPUSH
6452: CALL_OW 111
// wait ( 0 0$01 ) ;
6456: LD_INT 35
6458: PPUSH
6459: CALL_OW 67
// end ;
6463: GO 6383
6465: POP
6466: POP
// end ;
6467: GO 6173
6469: POP
6470: POP
// end ;
6471: PPOPN 6
6473: END
// every 4 4$00 do var i , un , time ;
6474: GO 6476
6476: DISABLE
6477: LD_INT 0
6479: PPUSH
6480: PPUSH
6481: PPUSH
// begin time := [ 2 2$00 , 1 1$00 , 0 0$30 ] ;
6482: LD_ADDR_VAR 0 3
6486: PUSH
6487: LD_INT 4200
6489: PUSH
6490: LD_INT 2100
6492: PUSH
6493: LD_INT 1050
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: LIST
6500: ST_TO_ADDR
// wait ( time ) ;
6501: LD_VAR 0 3
6505: PPUSH
6506: CALL_OW 67
// uc_side := 3 ;
6510: LD_ADDR_OWVAR 20
6514: PUSH
6515: LD_INT 3
6517: ST_TO_ADDR
// uc_nation := 3 ;
6518: LD_ADDR_OWVAR 21
6522: PUSH
6523: LD_INT 3
6525: ST_TO_ADDR
// for i = 1 to 2 do
6526: LD_ADDR_VAR 0 1
6530: PUSH
6531: DOUBLE
6532: LD_INT 1
6534: DEC
6535: ST_TO_ADDR
6536: LD_INT 2
6538: PUSH
6539: FOR_TO
6540: IFFALSE 6603
// begin PrepareHuman ( false , 1 , 4 ) ;
6542: LD_INT 0
6544: PPUSH
6545: LD_INT 1
6547: PPUSH
6548: LD_INT 4
6550: PPUSH
6551: CALL_OW 380
// un := CreateHuman ;
6555: LD_ADDR_VAR 0 2
6559: PUSH
6560: CALL_OW 44
6564: ST_TO_ADDR
// PlaceHumanInUnit ( un , ru_dep_main ) ;
6565: LD_VAR 0 2
6569: PPUSH
6570: LD_INT 16
6572: PPUSH
6573: CALL_OW 52
// ComExitBuilding ( un ) ;
6577: LD_VAR 0 2
6581: PPUSH
6582: CALL_OW 122
// AddComAgressiveMove ( un , 41 , 76 ) ;
6586: LD_VAR 0 2
6590: PPUSH
6591: LD_INT 41
6593: PPUSH
6594: LD_INT 76
6596: PPUSH
6597: CALL_OW 174
// end ;
6601: GO 6539
6603: POP
6604: POP
// end ; end_of_file
6605: PPOPN 3
6607: END
// export function Action ; begin
6608: LD_INT 0
6610: PPUSH
// CenterNowOnXY ( 28 , 3 ) ;
6611: LD_INT 28
6613: PPUSH
6614: LD_INT 3
6616: PPUSH
6617: CALL_OW 86
// PlaceSeeing ( 41 , 76 , 1 , 10 ) ;
6621: LD_INT 41
6623: PPUSH
6624: LD_INT 76
6626: PPUSH
6627: LD_INT 1
6629: PPUSH
6630: LD_INT 10
6632: PPUSH
6633: CALL_OW 330
// RemoveSeeing ( 41 , 76 , 1 ) ;
6637: LD_INT 41
6639: PPUSH
6640: LD_INT 76
6642: PPUSH
6643: LD_INT 1
6645: PPUSH
6646: CALL_OW 331
// InGameOn ;
6650: CALL_OW 8
// SayRadio ( Harisson , D2-Har-1 ) ;
6654: LD_EXP 18
6658: PPUSH
6659: LD_STRING D2-Har-1
6661: PPUSH
6662: CALL_OW 94
// InGameOff ;
6666: CALL_OW 9
// ChangeMissionObjectives ( M1 ) ;
6670: LD_STRING M1
6672: PPUSH
6673: CALL_OW 337
// end ;
6677: LD_VAR 0 1
6681: RET
// every 0 0$1 trigger buildings_counter > 1 do var un ;
6682: LD_EXP 4
6686: PUSH
6687: LD_INT 1
6689: GREATER
6690: IFFALSE 6781
6692: GO 6694
6694: DISABLE
6695: LD_INT 0
6697: PPUSH
// begin un := GetRandom ( sex_male ) [ 1 ] ;
6698: LD_ADDR_VAR 0 1
6702: PUSH
6703: LD_INT 1
6705: PPUSH
6706: CALL 505 0 1
6710: PUSH
6711: LD_INT 1
6713: ARRAY
6714: ST_TO_ADDR
// Say ( un , D2a-Sol1-1 ) ;
6715: LD_VAR 0 1
6719: PPUSH
6720: LD_STRING D2a-Sol1-1
6722: PPUSH
6723: CALL_OW 88
// if not un then
6727: LD_VAR 0 1
6731: NOT
6732: IFFALSE 6763
// begin un := GetRandom ( sex_female ) [ 1 ] ;
6734: LD_ADDR_VAR 0 1
6738: PUSH
6739: LD_INT 2
6741: PPUSH
6742: CALL 505 0 1
6746: PUSH
6747: LD_INT 1
6749: ARRAY
6750: ST_TO_ADDR
// Say ( un , D2a-FSol1-1 ) ;
6751: LD_VAR 0 1
6755: PPUSH
6756: LD_STRING D2a-FSol1-1
6758: PPUSH
6759: CALL_OW 88
// end ; if Khatam then
6763: LD_EXP 16
6767: IFFALSE 6781
// Say ( Khatam , D3b-Khat-3 ) ;
6769: LD_EXP 16
6773: PPUSH
6774: LD_STRING D3b-Khat-3
6776: PPUSH
6777: CALL_OW 88
// end ;
6781: PPOPN 1
6783: END
// every 0 0$1 trigger Frank and GetDistUnits ( JMM , Frank ) < 5 and not InBattle ( 1 ) do var i , ape ;
6784: LD_EXP 14
6788: PUSH
6789: LD_EXP 8
6793: PPUSH
6794: LD_EXP 14
6798: PPUSH
6799: CALL_OW 296
6803: PUSH
6804: LD_INT 5
6806: LESS
6807: AND
6808: PUSH
6809: LD_INT 1
6811: PPUSH
6812: CALL_OW 463
6816: NOT
6817: AND
6818: IFFALSE 7405
6820: GO 6822
6822: DISABLE
6823: LD_INT 0
6825: PPUSH
6826: PPUSH
// begin InGameOn ;
6827: CALL_OW 8
// ape := FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) ;
6831: LD_ADDR_VAR 0 2
6835: PUSH
6836: LD_INT 22
6838: PUSH
6839: LD_INT 0
6841: PUSH
6842: EMPTY
6843: LIST
6844: LIST
6845: PUSH
6846: LD_INT 25
6848: PUSH
6849: LD_INT 12
6851: PUSH
6852: EMPTY
6853: LIST
6854: LIST
6855: PUSH
6856: EMPTY
6857: LIST
6858: LIST
6859: PPUSH
6860: CALL_OW 69
6864: ST_TO_ADDR
// ape := NearestUnitToUnit ( ape , Frank ) ;
6865: LD_ADDR_VAR 0 2
6869: PUSH
6870: LD_VAR 0 2
6874: PPUSH
6875: LD_EXP 14
6879: PPUSH
6880: CALL_OW 74
6884: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_dist , Frank , 20 ] ] ) do
6885: LD_ADDR_VAR 0 1
6889: PUSH
6890: LD_INT 22
6892: PUSH
6893: LD_INT 1
6895: PUSH
6896: EMPTY
6897: LIST
6898: LIST
6899: PUSH
6900: LD_INT 21
6902: PUSH
6903: LD_INT 1
6905: PUSH
6906: EMPTY
6907: LIST
6908: LIST
6909: PUSH
6910: LD_INT 91
6912: PUSH
6913: LD_EXP 14
6917: PUSH
6918: LD_INT 20
6920: PUSH
6921: EMPTY
6922: LIST
6923: LIST
6924: LIST
6925: PUSH
6926: EMPTY
6927: LIST
6928: LIST
6929: LIST
6930: PPUSH
6931: CALL_OW 69
6935: PUSH
6936: FOR_IN
6937: IFFALSE 6955
// ComTurnUnit ( i , Frank ) ;
6939: LD_VAR 0 1
6943: PPUSH
6944: LD_EXP 14
6948: PPUSH
6949: CALL_OW 119
6953: GO 6936
6955: POP
6956: POP
// SetSide ( Frank , 1 ) ;
6957: LD_EXP 14
6961: PPUSH
6962: LD_INT 1
6964: PPUSH
6965: CALL_OW 235
// ComMoveUnit ( JMM , Frank ) ;
6969: LD_EXP 8
6973: PPUSH
6974: LD_EXP 14
6978: PPUSH
6979: CALL_OW 112
// AddComTurnUnit ( JMM , Frank ) ;
6983: LD_EXP 8
6987: PPUSH
6988: LD_EXP 14
6992: PPUSH
6993: CALL_OW 179
// CenterOnUnits ( Frank ) ;
6997: LD_EXP 14
7001: PPUSH
7002: CALL_OW 85
// Say ( Frank , D3a-Frank-1 ) ;
7006: LD_EXP 14
7010: PPUSH
7011: LD_STRING D3a-Frank-1
7013: PPUSH
7014: CALL_OW 88
// ComMoveXY ( ape , 42 , 78 ) ;
7018: LD_VAR 0 2
7022: PPUSH
7023: LD_INT 42
7025: PPUSH
7026: LD_INT 78
7028: PPUSH
7029: CALL_OW 111
// AddComTurnUnit ( ape , Frank ) ;
7033: LD_VAR 0 2
7037: PPUSH
7038: LD_EXP 14
7042: PPUSH
7043: CALL_OW 179
// if Lisa then
7047: LD_EXP 13
7051: IFFALSE 7065
// Say ( Lisa , D3a-Lisa-1 ) ;
7053: LD_EXP 13
7057: PPUSH
7058: LD_STRING D3a-Lisa-1
7060: PPUSH
7061: CALL_OW 88
// Say ( JMM , D3a-JMM-1 ) ;
7065: LD_EXP 8
7069: PPUSH
7070: LD_STRING D3a-JMM-1
7072: PPUSH
7073: CALL_OW 88
// if Cyrus then
7077: LD_EXP 12
7081: IFFALSE 7095
// Say ( Cyrus , D3a-Cyrus-1 ) ;
7083: LD_EXP 12
7087: PPUSH
7088: LD_STRING D3a-Cyrus-1
7090: PPUSH
7091: CALL_OW 88
// if GetRandom ( sex_male ) then
7095: LD_INT 1
7097: PPUSH
7098: CALL 505 0 1
7102: IFFALSE 7123
// Say ( GetRandom ( sex_male ) [ 1 ] , D3a-Sol1-1 ) ;
7104: LD_INT 1
7106: PPUSH
7107: CALL 505 0 1
7111: PUSH
7112: LD_INT 1
7114: ARRAY
7115: PPUSH
7116: LD_STRING D3a-Sol1-1
7118: PPUSH
7119: CALL_OW 88
// if GetRandom ( sex_female ) then
7123: LD_INT 2
7125: PPUSH
7126: CALL 505 0 1
7130: IFFALSE 7151
// Say ( GetRandom ( sex_female ) [ 1 ] , D3a-FSol1-1 ) ;
7132: LD_INT 2
7134: PPUSH
7135: CALL 505 0 1
7139: PUSH
7140: LD_INT 1
7142: ARRAY
7143: PPUSH
7144: LD_STRING D3a-FSol1-1
7146: PPUSH
7147: CALL_OW 88
// if Gladstone then
7151: LD_EXP 15
7155: IFFALSE 7169
// Say ( Gladstone , D3a-Glad-1 ) ;
7157: LD_EXP 15
7161: PPUSH
7162: LD_STRING D3a-Glad-1
7164: PPUSH
7165: CALL_OW 88
// ComMoveXY ( ape , 60 , 113 ) ;
7169: LD_VAR 0 2
7173: PPUSH
7174: LD_INT 60
7176: PPUSH
7177: LD_INT 113
7179: PPUSH
7180: CALL_OW 111
// Say ( Frank , D3a-Frank-2 ) ;
7184: LD_EXP 14
7188: PPUSH
7189: LD_STRING D3a-Frank-2
7191: PPUSH
7192: CALL_OW 88
// ComTurnUnit ( Frank , JMM ) ;
7196: LD_EXP 14
7200: PPUSH
7201: LD_EXP 8
7205: PPUSH
7206: CALL_OW 119
// Say ( JMM , D3a-JMM-2 ) ;
7210: LD_EXP 8
7214: PPUSH
7215: LD_STRING D3a-JMM-2
7217: PPUSH
7218: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
7222: LD_INT 1
7224: PPUSH
7225: LD_INT 4
7227: PPUSH
7228: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
7232: LD_INT 85
7234: PPUSH
7235: LD_INT 134
7237: PPUSH
7238: CALL_OW 84
// Say ( Frank , D3a-Frank-3 ) ;
7242: LD_EXP 14
7246: PPUSH
7247: LD_STRING D3a-Frank-3
7249: PPUSH
7250: CALL_OW 88
// Wait ( 0 0$01 ) ;
7254: LD_INT 35
7256: PPUSH
7257: CALL_OW 67
// CenterOnXY ( 166 , 136 ) ;
7261: LD_INT 166
7263: PPUSH
7264: LD_INT 136
7266: PPUSH
7267: CALL_OW 84
// Say ( JMM , D3a-JMM-3 ) ;
7271: LD_EXP 8
7275: PPUSH
7276: LD_STRING D3a-JMM-3
7278: PPUSH
7279: CALL_OW 88
// Wait ( 0 0$01 ) ;
7283: LD_INT 35
7285: PPUSH
7286: CALL_OW 67
// CenterNowOnUnits ( Frank ) ;
7290: LD_EXP 14
7294: PPUSH
7295: CALL_OW 87
// Say ( Frank , D3a-Frank-4 ) ;
7299: LD_EXP 14
7303: PPUSH
7304: LD_STRING D3a-Frank-4
7306: PPUSH
7307: CALL_OW 88
// if Lisa then
7311: LD_EXP 13
7315: IFFALSE 7329
// Say ( Lisa , D3a-Lisa-4 ) ;
7317: LD_EXP 13
7321: PPUSH
7322: LD_STRING D3a-Lisa-4
7324: PPUSH
7325: CALL_OW 88
// Say ( JMM , D3a-JMM-4 ) ;
7329: LD_EXP 8
7333: PPUSH
7334: LD_STRING D3a-JMM-4
7336: PPUSH
7337: CALL_OW 88
// Say ( Frank , D3a-Frank-5 ) ;
7341: LD_EXP 14
7345: PPUSH
7346: LD_STRING D3a-Frank-5
7348: PPUSH
7349: CALL_OW 88
// Say ( JMM , D3a-JMM-5 ) ;
7353: LD_EXP 8
7357: PPUSH
7358: LD_STRING D3a-JMM-5
7360: PPUSH
7361: CALL_OW 88
// Say ( Frank , D3a-Frank-6 ) ;
7365: LD_EXP 14
7369: PPUSH
7370: LD_STRING D3a-Frank-6
7372: PPUSH
7373: CALL_OW 88
// Say ( JMM , D3a-JMM-6 ) ;
7377: LD_EXP 8
7381: PPUSH
7382: LD_STRING D3a-JMM-6
7384: PPUSH
7385: CALL_OW 88
// Say ( Frank , D3a-Frank-7 ) ;
7389: LD_EXP 14
7393: PPUSH
7394: LD_STRING D3a-Frank-7
7396: PPUSH
7397: CALL_OW 88
// InGameOff ;
7401: CALL_OW 9
// end ;
7405: PPOPN 2
7407: END
// every 0 0$1 trigger Kikuchi and GetDistUnits ( JMM , Kikuchi ) < 5 and not InBattle ( 1 ) do
7408: LD_EXP 17
7412: PUSH
7413: LD_EXP 8
7417: PPUSH
7418: LD_EXP 17
7422: PPUSH
7423: CALL_OW 296
7427: PUSH
7428: LD_INT 5
7430: LESS
7431: AND
7432: PUSH
7433: LD_INT 1
7435: PPUSH
7436: CALL_OW 463
7440: NOT
7441: AND
7442: IFFALSE 7622
7444: GO 7446
7446: DISABLE
// begin InGameOn ;
7447: CALL_OW 8
// ComTurnUnit ( JMM , Kikuchi ) ;
7451: LD_EXP 8
7455: PPUSH
7456: LD_EXP 17
7460: PPUSH
7461: CALL_OW 119
// ComTurnUnit ( Kikuchi , JMM ) ;
7465: LD_EXP 17
7469: PPUSH
7470: LD_EXP 8
7474: PPUSH
7475: CALL_OW 119
// CenterOnUnits ( Kikuchi ) ;
7479: LD_EXP 17
7483: PPUSH
7484: CALL_OW 85
// Say ( Kikuchi , D3b-Yam-1 ) ;
7488: LD_EXP 17
7492: PPUSH
7493: LD_STRING D3b-Yam-1
7495: PPUSH
7496: CALL_OW 88
// Say ( JMM , D3b-JMM-1 ) ;
7500: LD_EXP 8
7504: PPUSH
7505: LD_STRING D3b-JMM-1
7507: PPUSH
7508: CALL_OW 88
// RevealFogArea ( 1 , spotArea ) ;
7512: LD_INT 1
7514: PPUSH
7515: LD_INT 4
7517: PPUSH
7518: CALL_OW 332
// CenterOnXY ( 85 , 134 ) ;
7522: LD_INT 85
7524: PPUSH
7525: LD_INT 134
7527: PPUSH
7528: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-2 ) ;
7532: LD_EXP 17
7536: PPUSH
7537: LD_STRING D3b-Yam-2
7539: PPUSH
7540: CALL_OW 88
// Wait ( 0 0$01 ) ;
7544: LD_INT 35
7546: PPUSH
7547: CALL_OW 67
// Say ( JMM , D3b-JMM-2 ) ;
7551: LD_EXP 8
7555: PPUSH
7556: LD_STRING D3b-JMM-2
7558: PPUSH
7559: CALL_OW 88
// CenterOnXY ( 166 , 136 ) ;
7563: LD_INT 166
7565: PPUSH
7566: LD_INT 136
7568: PPUSH
7569: CALL_OW 84
// Say ( Kikuchi , D3b-Yam-3 ) ;
7573: LD_EXP 17
7577: PPUSH
7578: LD_STRING D3b-Yam-3
7580: PPUSH
7581: CALL_OW 88
// CenterNowOnUnits ( JMM ) ;
7585: LD_EXP 8
7589: PPUSH
7590: CALL_OW 87
// Say ( JMM , D3b-JMM-3a ) ;
7594: LD_EXP 8
7598: PPUSH
7599: LD_STRING D3b-JMM-3a
7601: PPUSH
7602: CALL_OW 88
// SetSide ( Kikuchi , 1 ) ;
7606: LD_EXP 17
7610: PPUSH
7611: LD_INT 1
7613: PPUSH
7614: CALL_OW 235
// InGameOff ;
7618: CALL_OW 9
// end ;
7622: END
// every 0 0$1 trigger FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) do var un , x , i ;
7623: LD_INT 7
7625: PPUSH
7626: LD_INT 22
7628: PUSH
7629: LD_INT 1
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: PUSH
7636: LD_INT 3
7638: PUSH
7639: LD_INT 24
7641: PUSH
7642: LD_INT 1000
7644: PUSH
7645: EMPTY
7646: LIST
7647: LIST
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: PPUSH
7657: CALL_OW 70
7661: IFFALSE 8079
7663: GO 7665
7665: DISABLE
7666: LD_INT 0
7668: PPUSH
7669: PPUSH
7670: PPUSH
// begin un := FilterUnitsInArea ( massDamageArea , [ [ f_side , 1 ] , [ f_not , [ f_lives , 1000 ] ] ] ) [ 1 ] ;
7671: LD_ADDR_VAR 0 1
7675: PUSH
7676: LD_INT 7
7678: PPUSH
7679: LD_INT 22
7681: PUSH
7682: LD_INT 1
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: PUSH
7689: LD_INT 3
7691: PUSH
7692: LD_INT 24
7694: PUSH
7695: LD_INT 1000
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: PUSH
7706: EMPTY
7707: LIST
7708: LIST
7709: PPUSH
7710: CALL_OW 70
7714: PUSH
7715: LD_INT 1
7717: ARRAY
7718: ST_TO_ADDR
// DialogueOn ;
7719: CALL_OW 6
// CenterNowOnUnits ( un ) ;
7723: LD_VAR 0 1
7727: PPUSH
7728: CALL_OW 87
// if Lisa then
7732: LD_EXP 13
7736: IFFALSE 7764
// begin Say ( Lisa , D5-Lisa-1 ) ;
7738: LD_EXP 13
7742: PPUSH
7743: LD_STRING D5-Lisa-1
7745: PPUSH
7746: CALL_OW 88
// Say ( JMM , D5-JMM-1a ) ;
7750: LD_EXP 8
7754: PPUSH
7755: LD_STRING D5-JMM-1a
7757: PPUSH
7758: CALL_OW 88
// end else
7762: GO 7776
// Say ( JMM , D5-JMM-1 ) ;
7764: LD_EXP 8
7768: PPUSH
7769: LD_STRING D5-JMM-1
7771: PPUSH
7772: CALL_OW 88
// DialogueOff ;
7776: CALL_OW 7
// while ( true ) do
7780: LD_INT 1
7782: IFFALSE 7838
// begin wait ( 0 0$01 ) ;
7784: LD_INT 35
7786: PPUSH
7787: CALL_OW 67
// x := FilterUnitsExceptArea ( northElectro , [ [ f_btype , b_oil_power ] , [ f_see , 1 ] ] ) ;
7791: LD_ADDR_VAR 0 2
7795: PUSH
7796: LD_INT 8
7798: PPUSH
7799: LD_INT 30
7801: PUSH
7802: LD_INT 26
7804: PUSH
7805: EMPTY
7806: LIST
7807: LIST
7808: PUSH
7809: LD_INT 101
7811: PUSH
7812: LD_INT 1
7814: PUSH
7815: EMPTY
7816: LIST
7817: LIST
7818: PUSH
7819: EMPTY
7820: LIST
7821: LIST
7822: PPUSH
7823: CALL_OW 71
7827: ST_TO_ADDR
// if x then
7828: LD_VAR 0 2
7832: IFFALSE 7836
// break ;
7834: GO 7838
// end ;
7836: GO 7780
// CenterOnUnits ( x [ 1 ] ) ;
7838: LD_VAR 0 2
7842: PUSH
7843: LD_INT 1
7845: ARRAY
7846: PPUSH
7847: CALL_OW 85
// if Frank and GetSide ( Frank ) = 1 then
7851: LD_EXP 14
7855: PUSH
7856: LD_EXP 14
7860: PPUSH
7861: CALL_OW 255
7865: PUSH
7866: LD_INT 1
7868: EQUAL
7869: AND
7870: IFFALSE 7886
// Say ( Frank , D5a-Frank-1 ) else
7872: LD_EXP 14
7876: PPUSH
7877: LD_STRING D5a-Frank-1
7879: PPUSH
7880: CALL_OW 88
7884: GO 7940
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
7886: LD_EXP 17
7890: PUSH
7891: LD_EXP 17
7895: PPUSH
7896: CALL_OW 255
7900: PUSH
7901: LD_INT 1
7903: EQUAL
7904: AND
7905: IFFALSE 7921
// Say ( Kikuchi , D5a-Yam-1 ) else
7907: LD_EXP 17
7911: PPUSH
7912: LD_STRING D5a-Yam-1
7914: PPUSH
7915: CALL_OW 88
7919: GO 7940
// Say ( GetRandom ( sex_male ) [ 1 ] , D5a-Sol1-1 ) ;
7921: LD_INT 1
7923: PPUSH
7924: CALL 505 0 1
7928: PUSH
7929: LD_INT 1
7931: ARRAY
7932: PPUSH
7933: LD_STRING D5a-Sol1-1
7935: PPUSH
7936: CALL_OW 88
// Say ( JMM , D5a-JMM-1 ) ;
7940: LD_EXP 8
7944: PPUSH
7945: LD_STRING D5a-JMM-1
7947: PPUSH
7948: CALL_OW 88
// if Cyrus then
7952: LD_EXP 12
7956: IFFALSE 7970
// Say ( Cyrus , D5a-Cyrus-1 ) ;
7958: LD_EXP 12
7962: PPUSH
7963: LD_STRING D5a-Cyrus-1
7965: PPUSH
7966: CALL_OW 88
// x := false ;
7970: LD_ADDR_VAR 0 2
7974: PUSH
7975: LD_INT 0
7977: ST_TO_ADDR
// while ( true ) do
7978: LD_INT 1
7980: IFFALSE 8067
// begin wait ( 0 0$01 ) ;
7982: LD_INT 35
7984: PPUSH
7985: CALL_OW 67
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) diff ru_dep_west do
7989: LD_ADDR_VAR 0 3
7993: PUSH
7994: LD_INT 2
7996: PUSH
7997: LD_INT 30
7999: PUSH
8000: LD_INT 0
8002: PUSH
8003: EMPTY
8004: LIST
8005: LIST
8006: PUSH
8007: LD_INT 30
8009: PUSH
8010: LD_INT 1
8012: PUSH
8013: EMPTY
8014: LIST
8015: LIST
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: LIST
8021: PPUSH
8022: CALL_OW 69
8026: PUSH
8027: LD_INT 1
8029: DIFF
8030: PUSH
8031: FOR_IN
8032: IFFALSE 8055
// if BaseNeedEnergy ( i ) then
8034: LD_VAR 0 3
8038: PPUSH
8039: CALL 1162 0 1
8043: IFFALSE 8053
// x := true ;
8045: LD_ADDR_VAR 0 2
8049: PUSH
8050: LD_INT 1
8052: ST_TO_ADDR
8053: GO 8031
8055: POP
8056: POP
// if x then
8057: LD_VAR 0 2
8061: IFFALSE 8065
// break ;
8063: GO 8067
// end ;
8065: GO 7978
// Say ( JMM , D5b-JMM-1 ) ;
8067: LD_EXP 8
8071: PPUSH
8072: LD_STRING D5b-JMM-1
8074: PPUSH
8075: CALL_OW 88
// end ;
8079: PPOPN 3
8081: END
// every 0 0$1 trigger time_to_end [ 1 ] < tick do
8082: LD_EXP 5
8086: PUSH
8087: LD_INT 1
8089: ARRAY
8090: PUSH
8091: LD_OWVAR 1
8095: LESS
8096: IFFALSE 8296
8098: GO 8100
8100: DISABLE
// begin if not IsDead ( ru_dep_main ) then
8101: LD_INT 16
8103: PPUSH
8104: CALL_OW 301
8108: NOT
8109: IFFALSE 8132
// begin SayRadio ( Harisson , D3b-Har-3 ) ;
8111: LD_EXP 18
8115: PPUSH
8116: LD_STRING D3b-Har-3
8118: PPUSH
8119: CALL_OW 94
// ChangeMissionObjectives ( M2a ) ;
8123: LD_STRING M2a
8125: PPUSH
8126: CALL_OW 337
// end else
8130: GO 8151
// begin SayRadio ( Harisson , D3b-Har-3a ) ;
8132: LD_EXP 18
8136: PPUSH
8137: LD_STRING D3b-Har-3a
8139: PPUSH
8140: CALL_OW 94
// ChangeMissionObjectives ( M2 ) ;
8144: LD_STRING M2
8146: PPUSH
8147: CALL_OW 337
// end ; can_end := true ;
8151: LD_ADDR_EXP 6
8155: PUSH
8156: LD_INT 1
8158: ST_TO_ADDR
// SetAreaMapShow ( endArea , 1 ) ;
8159: LD_INT 9
8161: PPUSH
8162: LD_INT 1
8164: PPUSH
8165: CALL_OW 424
// Wait ( 0 0$02 ) ;
8169: LD_INT 70
8171: PPUSH
8172: CALL_OW 67
// if Lisa then
8176: LD_EXP 13
8180: IFFALSE 8194
// Say ( Lisa , D3b-Lisa ) ;
8182: LD_EXP 13
8186: PPUSH
8187: LD_STRING D3b-Lisa
8189: PPUSH
8190: CALL_OW 88
// if Bobby then
8194: LD_EXP 11
8198: IFFALSE 8212
// Say ( Bobby , D3b-Bobby-3 ) ;
8200: LD_EXP 11
8204: PPUSH
8205: LD_STRING D3b-Bobby-3
8207: PPUSH
8208: CALL_OW 88
// if Cyrus then
8212: LD_EXP 12
8216: IFFALSE 8230
// Say ( Cyrus , D3b-Cyrus-3 ) ;
8218: LD_EXP 12
8222: PPUSH
8223: LD_STRING D3b-Cyrus-3
8225: PPUSH
8226: CALL_OW 88
// if Frank and GetSide ( Frank ) = 1 then
8230: LD_EXP 14
8234: PUSH
8235: LD_EXP 14
8239: PPUSH
8240: CALL_OW 255
8244: PUSH
8245: LD_INT 1
8247: EQUAL
8248: AND
8249: IFFALSE 8263
// Say ( Frank , D3b-Frank-3 ) ;
8251: LD_EXP 14
8255: PPUSH
8256: LD_STRING D3b-Frank-3
8258: PPUSH
8259: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 1 then
8263: LD_EXP 17
8267: PUSH
8268: LD_EXP 17
8272: PPUSH
8273: CALL_OW 255
8277: PUSH
8278: LD_INT 1
8280: EQUAL
8281: AND
8282: IFFALSE 8296
// Say ( Kikuchi , D3b-Yam-4 ) ;
8284: LD_EXP 17
8288: PPUSH
8289: LD_STRING D3b-Yam-4
8291: PPUSH
8292: CALL_OW 88
// end ;
8296: END
// every 0 0$1 trigger time_to_end [ 2 ] < tick do
8297: LD_EXP 5
8301: PUSH
8302: LD_INT 2
8304: ARRAY
8305: PUSH
8306: LD_OWVAR 1
8310: LESS
8311: IFFALSE 8343
8313: GO 8315
8315: DISABLE
// begin SayRadio ( Harisson , D4-Har-1 ) ;
8316: LD_EXP 18
8320: PPUSH
8321: LD_STRING D4-Har-1
8323: PPUSH
8324: CALL_OW 94
// ChangeMissionObjectives ( M3 ) ;
8328: LD_STRING M3
8330: PPUSH
8331: CALL_OW 337
// must_end := true ;
8335: LD_ADDR_EXP 7
8339: PUSH
8340: LD_INT 1
8342: ST_TO_ADDR
// end ;
8343: END
// every 0 0$01 trigger time_to_end [ 3 ] < tick do
8344: LD_EXP 5
8348: PUSH
8349: LD_INT 3
8351: ARRAY
8352: PUSH
8353: LD_OWVAR 1
8357: LESS
8358: IFFALSE 8389
8360: GO 8362
8362: DISABLE
// begin if not IsDead ( ru_dep_main ) then
8363: LD_INT 16
8365: PPUSH
8366: CALL_OW 301
8370: NOT
8371: IFFALSE 8382
// YouLost ( TimeOut1 ) else
8373: LD_STRING TimeOut1
8375: PPUSH
8376: CALL_OW 104
8380: GO 8389
// YouLost ( TimeOut2 ) ;
8382: LD_STRING TimeOut2
8384: PPUSH
8385: CALL_OW 104
// end ;
8389: END
// every 0 0$1 trigger IsInArea ( JMM , endArea ) and can_end do var wait_on , i , tmp ;
8390: LD_EXP 8
8394: PPUSH
8395: LD_INT 9
8397: PPUSH
8398: CALL_OW 308
8402: PUSH
8403: LD_EXP 6
8407: AND
8408: IFFALSE 9393
8410: GO 8412
8412: DISABLE
8413: LD_INT 0
8415: PPUSH
8416: PPUSH
8417: PPUSH
// begin wait_on := false ;
8418: LD_ADDR_VAR 0 1
8422: PUSH
8423: LD_INT 0
8425: ST_TO_ADDR
// if FilterPeople ( 1 ) + 0 > ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 then
8426: LD_INT 1
8428: PPUSH
8429: CALL 1239 0 1
8433: PUSH
8434: LD_INT 0
8436: PLUS
8437: PUSH
8438: LD_INT 1
8440: PPUSH
8441: LD_INT 9
8443: PPUSH
8444: CALL 1330 0 2
8448: PUSH
8449: LD_INT 1
8451: PPUSH
8452: LD_INT 9
8454: PPUSH
8455: CALL 1377 0 2
8459: ADD
8460: PUSH
8461: LD_INT 0
8463: PLUS
8464: GREATER
8465: IFFALSE 8514
// case Query ( Q1 ) of 1 :
8467: LD_STRING Q1
8469: PPUSH
8470: CALL_OW 97
8474: PUSH
8475: LD_INT 1
8477: DOUBLE
8478: EQUAL
8479: IFTRUE 8483
8481: GO 8494
8483: POP
// wait_on := true ; 2 :
8484: LD_ADDR_VAR 0 1
8488: PUSH
8489: LD_INT 1
8491: ST_TO_ADDR
8492: GO 8514
8494: LD_INT 2
8496: DOUBLE
8497: EQUAL
8498: IFTRUE 8502
8500: GO 8513
8502: POP
// wait_on := false ; end ;
8503: LD_ADDR_VAR 0 1
8507: PUSH
8508: LD_INT 0
8510: ST_TO_ADDR
8511: GO 8514
8513: POP
// repeat wait ( 0 0$01 ) ;
8514: LD_INT 35
8516: PPUSH
8517: CALL_OW 67
// until ( not wait_on ) or ( FilterPeople ( 1 ) + 0 ) = ( FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ) + 0 ;
8521: LD_VAR 0 1
8525: NOT
8526: PUSH
8527: LD_INT 1
8529: PPUSH
8530: CALL 1239 0 1
8534: PUSH
8535: LD_INT 0
8537: PLUS
8538: PUSH
8539: LD_INT 1
8541: PPUSH
8542: LD_INT 9
8544: PPUSH
8545: CALL 1330 0 2
8549: PUSH
8550: LD_INT 1
8552: PPUSH
8553: LD_INT 9
8555: PPUSH
8556: CALL 1377 0 2
8560: ADD
8561: PUSH
8562: LD_INT 0
8564: PLUS
8565: EQUAL
8566: OR
8567: IFFALSE 8514
// DialogueOn ;
8569: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
8573: LD_EXP 8
8577: PPUSH
8578: CALL_OW 87
// Say ( JMM , D6-JMM-1 ) ;
8582: LD_EXP 8
8586: PPUSH
8587: LD_STRING D6-JMM-1
8589: PPUSH
8590: CALL_OW 88
// SayRadio ( Harisson , D6-Har-1 ) ;
8594: LD_EXP 18
8598: PPUSH
8599: LD_STRING D6-Har-1
8601: PPUSH
8602: CALL_OW 94
// Say ( JMM , D6-JMM-2 ) ;
8606: LD_EXP 8
8610: PPUSH
8611: LD_STRING D6-JMM-2
8613: PPUSH
8614: CALL_OW 88
// SayRadio ( Harisson , D6-Har-2 ) ;
8618: LD_EXP 18
8622: PPUSH
8623: LD_STRING D6-Har-2
8625: PPUSH
8626: CALL_OW 94
// Say ( JMM , D6-JMM-3 ) ;
8630: LD_EXP 8
8634: PPUSH
8635: LD_STRING D6-JMM-3
8637: PPUSH
8638: CALL_OW 88
// SayRadio ( Harisson , D6-Har-3 ) ;
8642: LD_EXP 18
8646: PPUSH
8647: LD_STRING D6-Har-3
8649: PPUSH
8650: CALL_OW 94
// Say ( JMM , D6-JMM-4 ) ;
8654: LD_EXP 8
8658: PPUSH
8659: LD_STRING D6-JMM-4
8661: PPUSH
8662: CALL_OW 88
// SayRadio ( Harisson , D6-Har-4 ) ;
8666: LD_EXP 18
8670: PPUSH
8671: LD_STRING D6-Har-4
8673: PPUSH
8674: CALL_OW 94
// Say ( JMM , D6-JMM-5 ) ;
8678: LD_EXP 8
8682: PPUSH
8683: LD_STRING D6-JMM-5
8685: PPUSH
8686: CALL_OW 88
// DialogueOff ;
8690: CALL_OW 7
// tmp := FilterBuildings ( 3 ) ;
8694: LD_ADDR_VAR 0 3
8698: PUSH
8699: LD_INT 3
8701: PPUSH
8702: CALL 1508 0 1
8706: ST_TO_ADDR
// if tmp >= 35 then
8707: LD_VAR 0 3
8711: PUSH
8712: LD_INT 35
8714: GREATEREQUAL
8715: IFFALSE 8752
// begin AddMedal ( Destroy1 , - 1 ) ;
8717: LD_STRING Destroy1
8719: PPUSH
8720: LD_INT 1
8722: NEG
8723: PPUSH
8724: CALL_OW 101
// AddMedal ( Destroy2 , - 1 ) ;
8728: LD_STRING Destroy2
8730: PPUSH
8731: LD_INT 1
8733: NEG
8734: PPUSH
8735: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
8739: LD_STRING Destroy3
8741: PPUSH
8742: LD_INT 1
8744: NEG
8745: PPUSH
8746: CALL_OW 101
// end else
8750: GO 8839
// begin AddMedal ( Destroy1 , 1 ) ;
8752: LD_STRING Destroy1
8754: PPUSH
8755: LD_INT 1
8757: PPUSH
8758: CALL_OW 101
// if tmp >= 25 then
8762: LD_VAR 0 3
8766: PUSH
8767: LD_INT 25
8769: GREATEREQUAL
8770: IFFALSE 8796
// begin AddMedal ( Destroy2 , - 1 ) ;
8772: LD_STRING Destroy2
8774: PPUSH
8775: LD_INT 1
8777: NEG
8778: PPUSH
8779: CALL_OW 101
// AddMedal ( Destroy3 , - 1 ) ;
8783: LD_STRING Destroy3
8785: PPUSH
8786: LD_INT 1
8788: NEG
8789: PPUSH
8790: CALL_OW 101
// end else
8794: GO 8839
// begin AddMedal ( Destroy2 , 1 ) ;
8796: LD_STRING Destroy2
8798: PPUSH
8799: LD_INT 1
8801: PPUSH
8802: CALL_OW 101
// if tmp >= 15 then
8806: LD_VAR 0 3
8810: PUSH
8811: LD_INT 15
8813: GREATEREQUAL
8814: IFFALSE 8829
// AddMedal ( Destroy3 , - 1 ) else
8816: LD_STRING Destroy3
8818: PPUSH
8819: LD_INT 1
8821: NEG
8822: PPUSH
8823: CALL_OW 101
8827: GO 8839
// AddMedal ( Destroy3 , 1 ) ;
8829: LD_STRING Destroy3
8831: PPUSH
8832: LD_INT 1
8834: PPUSH
8835: CALL_OW 101
// end ; end ; GiveMedals ( MAIN ) ;
8839: LD_STRING MAIN
8841: PPUSH
8842: CALL_OW 102
// tmp := FilterPeopleArea ( 1 , endArea ) ^ FilterDriversArea ( 1 , endArea ) ;
8846: LD_ADDR_VAR 0 3
8850: PUSH
8851: LD_INT 1
8853: PPUSH
8854: LD_INT 9
8856: PPUSH
8857: CALL 1330 0 2
8861: PUSH
8862: LD_INT 1
8864: PPUSH
8865: LD_INT 9
8867: PPUSH
8868: CALL 1377 0 2
8872: ADD
8873: ST_TO_ADDR
// RewardPeople ( tmp ) ;
8874: LD_VAR 0 3
8878: PPUSH
8879: CALL_OW 43
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
8883: LD_EXP 8
8887: PPUSH
8888: LD_EXP 3
8892: PUSH
8893: LD_STRING JMM
8895: STR
8896: PPUSH
8897: CALL_OW 38
// if Brown in tmp then
8901: LD_EXP 9
8905: PUSH
8906: LD_VAR 0 3
8910: IN
8911: IFFALSE 8931
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
8913: LD_EXP 9
8917: PPUSH
8918: LD_EXP 3
8922: PUSH
8923: LD_STRING Brown
8925: STR
8926: PPUSH
8927: CALL_OW 38
// if Donaldson in tmp then
8931: LD_EXP 10
8935: PUSH
8936: LD_VAR 0 3
8940: IN
8941: IFFALSE 8961
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
8943: LD_EXP 10
8947: PPUSH
8948: LD_EXP 3
8952: PUSH
8953: LD_STRING Donaldson
8955: STR
8956: PPUSH
8957: CALL_OW 38
// if Bobby in tmp then
8961: LD_EXP 11
8965: PUSH
8966: LD_VAR 0 3
8970: IN
8971: IFFALSE 8991
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
8973: LD_EXP 11
8977: PPUSH
8978: LD_EXP 3
8982: PUSH
8983: LD_STRING Bobby
8985: STR
8986: PPUSH
8987: CALL_OW 38
// if Cyrus in tmp then
8991: LD_EXP 12
8995: PUSH
8996: LD_VAR 0 3
9000: IN
9001: IFFALSE 9021
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
9003: LD_EXP 12
9007: PPUSH
9008: LD_EXP 3
9012: PUSH
9013: LD_STRING Cyrus
9015: STR
9016: PPUSH
9017: CALL_OW 38
// if Lisa in tmp then
9021: LD_EXP 13
9025: PUSH
9026: LD_VAR 0 3
9030: IN
9031: IFFALSE 9051
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
9033: LD_EXP 13
9037: PPUSH
9038: LD_EXP 3
9042: PUSH
9043: LD_STRING Lisa
9045: STR
9046: PPUSH
9047: CALL_OW 38
// if Frank in tmp then
9051: LD_EXP 14
9055: PUSH
9056: LD_VAR 0 3
9060: IN
9061: IFFALSE 9081
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
9063: LD_EXP 14
9067: PPUSH
9068: LD_EXP 3
9072: PUSH
9073: LD_STRING Frank
9075: STR
9076: PPUSH
9077: CALL_OW 38
// if Gladstone in tmp then
9081: LD_EXP 15
9085: PUSH
9086: LD_VAR 0 3
9090: IN
9091: IFFALSE 9111
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
9093: LD_EXP 15
9097: PPUSH
9098: LD_EXP 3
9102: PUSH
9103: LD_STRING Gladstone
9105: STR
9106: PPUSH
9107: CALL_OW 38
// if Khatam in tmp then
9111: LD_EXP 16
9115: PUSH
9116: LD_VAR 0 3
9120: IN
9121: IFFALSE 9141
// SaveCharacters ( Khatam , mission_prefix & Khatam ) ;
9123: LD_EXP 16
9127: PPUSH
9128: LD_EXP 3
9132: PUSH
9133: LD_STRING Khatam
9135: STR
9136: PPUSH
9137: CALL_OW 38
// if Kikuchi in tmp then
9141: LD_EXP 17
9145: PUSH
9146: LD_VAR 0 3
9150: IN
9151: IFFALSE 9171
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
9153: LD_EXP 17
9157: PPUSH
9158: LD_EXP 3
9162: PUSH
9163: LD_STRING Kikuchi
9165: STR
9166: PPUSH
9167: CALL_OW 38
// SaveCharacters ( tmp diff [ JMM , Brown , Donaldson , Bobby , Cyrus , Lisa , Frank , Gladstone , Kikuchi ] , mission_prefix & others ) ;
9171: LD_VAR 0 3
9175: PUSH
9176: LD_EXP 8
9180: PUSH
9181: LD_EXP 9
9185: PUSH
9186: LD_EXP 10
9190: PUSH
9191: LD_EXP 11
9195: PUSH
9196: LD_EXP 12
9200: PUSH
9201: LD_EXP 13
9205: PUSH
9206: LD_EXP 14
9210: PUSH
9211: LD_EXP 15
9215: PUSH
9216: LD_EXP 17
9220: PUSH
9221: EMPTY
9222: LIST
9223: LIST
9224: LIST
9225: LIST
9226: LIST
9227: LIST
9228: LIST
9229: LIST
9230: LIST
9231: DIFF
9232: PPUSH
9233: LD_EXP 3
9237: PUSH
9238: LD_STRING others
9240: STR
9241: PPUSH
9242: CALL_OW 38
// SaveVariable ( tick , 07_time ) ;
9246: LD_OWVAR 1
9250: PPUSH
9251: LD_STRING 07_time
9253: PPUSH
9254: CALL_OW 39
// tmp := [ ] ;
9258: LD_ADDR_VAR 0 3
9262: PUSH
9263: EMPTY
9264: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ] ) do
9265: LD_ADDR_VAR 0 2
9269: PUSH
9270: LD_INT 22
9272: PUSH
9273: LD_INT 1
9275: PUSH
9276: EMPTY
9277: LIST
9278: LIST
9279: PUSH
9280: LD_INT 23
9282: PUSH
9283: LD_INT 1
9285: PUSH
9286: EMPTY
9287: LIST
9288: LIST
9289: PUSH
9290: LD_INT 21
9292: PUSH
9293: LD_INT 2
9295: PUSH
9296: EMPTY
9297: LIST
9298: LIST
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: LIST
9304: PUSH
9305: EMPTY
9306: LIST
9307: PPUSH
9308: CALL_OW 69
9312: PUSH
9313: FOR_IN
9314: IFFALSE 9375
// tmp := tmp ^ [ GetChassis ( i ) , GetEngine ( i ) , GetControl ( i ) , GetWeapon ( i ) ] ;
9316: LD_ADDR_VAR 0 3
9320: PUSH
9321: LD_VAR 0 3
9325: PUSH
9326: LD_VAR 0 2
9330: PPUSH
9331: CALL_OW 265
9335: PUSH
9336: LD_VAR 0 2
9340: PPUSH
9341: CALL_OW 262
9345: PUSH
9346: LD_VAR 0 2
9350: PPUSH
9351: CALL_OW 263
9355: PUSH
9356: LD_VAR 0 2
9360: PPUSH
9361: CALL_OW 264
9365: PUSH
9366: EMPTY
9367: LIST
9368: LIST
9369: LIST
9370: LIST
9371: ADD
9372: ST_TO_ADDR
9373: GO 9313
9375: POP
9376: POP
// SaveVariable ( tmp , 07_vehicles ) ;
9377: LD_VAR 0 3
9381: PPUSH
9382: LD_STRING 07_vehicles
9384: PPUSH
9385: CALL_OW 39
// YouWin ;
9389: CALL_OW 103
// end ; end_of_file
9393: PPOPN 3
9395: END
// on UnitDestroyed ( un ) do begin if un = JMM then
9396: LD_VAR 0 1
9400: PUSH
9401: LD_EXP 8
9405: EQUAL
9406: IFFALSE 9415
// YouLost ( JMM ) ;
9408: LD_STRING JMM
9410: PPUSH
9411: CALL_OW 104
// if GetType ( un ) = unit_building then
9415: LD_VAR 0 1
9419: PPUSH
9420: CALL_OW 247
9424: PUSH
9425: LD_INT 3
9427: EQUAL
9428: IFFALSE 9444
// buildings_counter := buildings_counter + 1 ;
9430: LD_ADDR_EXP 4
9434: PUSH
9435: LD_EXP 4
9439: PUSH
9440: LD_INT 1
9442: PLUS
9443: ST_TO_ADDR
// if un in FilterUnitsInArea ( baseArea , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] ) then
9444: LD_VAR 0 1
9448: PUSH
9449: LD_INT 6
9451: PPUSH
9452: LD_INT 2
9454: PUSH
9455: LD_INT 30
9457: PUSH
9458: LD_INT 33
9460: PUSH
9461: EMPTY
9462: LIST
9463: LIST
9464: PUSH
9465: LD_INT 30
9467: PUSH
9468: LD_INT 32
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: PUSH
9475: EMPTY
9476: LIST
9477: LIST
9478: LIST
9479: PPUSH
9480: CALL_OW 70
9484: IN
9485: IFFALSE 9544
// ru_rebuild_list := ru_rebuild_list ^ [ GetBType ( un ) , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ;
9487: LD_ADDR_EXP 19
9491: PUSH
9492: LD_EXP 19
9496: PUSH
9497: LD_VAR 0 1
9501: PPUSH
9502: CALL_OW 266
9506: PUSH
9507: LD_VAR 0 1
9511: PPUSH
9512: CALL_OW 250
9516: PUSH
9517: LD_VAR 0 1
9521: PPUSH
9522: CALL_OW 251
9526: PUSH
9527: LD_VAR 0 1
9531: PPUSH
9532: CALL_OW 254
9536: PUSH
9537: EMPTY
9538: LIST
9539: LIST
9540: LIST
9541: LIST
9542: ADD
9543: ST_TO_ADDR
// if un = ru_dep_main then
9544: LD_VAR 0 1
9548: PUSH
9549: LD_INT 16
9551: EQUAL
9552: IFFALSE 9561
// ChangeMissionObjectives ( M1a ) ;
9554: LD_STRING M1a
9556: PPUSH
9557: CALL_OW 337
// end ;
9561: PPOPN 1
9563: END
// on BuildingStarted ( b , builder ) do var i ;
9564: LD_INT 0
9566: PPUSH
// begin if GetSide ( b ) = 3 then
9567: LD_VAR 0 1
9571: PPUSH
9572: CALL_OW 255
9576: PUSH
9577: LD_INT 3
9579: EQUAL
9580: IFFALSE 9620
// for i = 1 to 4 do
9582: LD_ADDR_VAR 0 3
9586: PUSH
9587: DOUBLE
9588: LD_INT 1
9590: DEC
9591: ST_TO_ADDR
9592: LD_INT 4
9594: PUSH
9595: FOR_TO
9596: IFFALSE 9618
// ru_rebuild_list := Delete ( ru_rebuild_list , 1 ) ;
9598: LD_ADDR_EXP 19
9602: PUSH
9603: LD_EXP 19
9607: PPUSH
9608: LD_INT 1
9610: PPUSH
9611: CALL_OW 3
9615: ST_TO_ADDR
9616: GO 9595
9618: POP
9619: POP
// end ;
9620: PPOPN 3
9622: END
// on BuildingComplete ( b ) do if GetBType ( b ) in [ b_bunker , b_turret ] then
9623: LD_VAR 0 1
9627: PPUSH
9628: CALL_OW 266
9632: PUSH
9633: LD_INT 32
9635: PUSH
9636: LD_INT 33
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: IN
9643: IFFALSE 9657
// ComPlaceWeapon ( b , ru_gatling_gun ) ;
9645: LD_VAR 0 1
9649: PPUSH
9650: LD_INT 43
9652: PPUSH
9653: CALL_OW 148
9657: PPOPN 1
9659: END
// on LeaveBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
9660: LD_VAR 0 1
9664: PUSH
9665: LD_INT 22
9667: PUSH
9668: LD_INT 3
9670: PUSH
9671: EMPTY
9672: LIST
9673: LIST
9674: PUSH
9675: LD_INT 2
9677: PUSH
9678: LD_INT 30
9680: PUSH
9681: LD_INT 31
9683: PUSH
9684: EMPTY
9685: LIST
9686: LIST
9687: PUSH
9688: LD_INT 30
9690: PUSH
9691: LD_INT 32
9693: PUSH
9694: EMPTY
9695: LIST
9696: LIST
9697: PUSH
9698: EMPTY
9699: LIST
9700: LIST
9701: LIST
9702: PUSH
9703: EMPTY
9704: LIST
9705: LIST
9706: PPUSH
9707: CALL_OW 69
9711: IN
9712: IFFALSE 9734
// GoToAnotherTower ( un , b , 143 , 143 ) ;
9714: LD_VAR 0 2
9718: PPUSH
9719: LD_VAR 0 1
9723: PPUSH
9724: LD_INT 143
9726: PPUSH
9727: LD_INT 143
9729: PPUSH
9730: CALL 735 0 4
// end ;
9734: PPOPN 2
9736: END
// on EnterBuilding ( b , un ) do begin if b in FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) then
9737: LD_VAR 0 1
9741: PUSH
9742: LD_INT 22
9744: PUSH
9745: LD_INT 3
9747: PUSH
9748: EMPTY
9749: LIST
9750: LIST
9751: PUSH
9752: LD_INT 30
9754: PUSH
9755: LD_INT 32
9757: PUSH
9758: EMPTY
9759: LIST
9760: LIST
9761: PUSH
9762: EMPTY
9763: LIST
9764: LIST
9765: PPUSH
9766: CALL_OW 69
9770: IN
9771: IFFALSE 9785
// SetTag ( b , 0 ) ;
9773: LD_VAR 0 1
9777: PPUSH
9778: LD_INT 0
9780: PPUSH
9781: CALL_OW 109
// end ;
9785: PPOPN 2
9787: END
